static inline void mpc52xx_set_divisor(struct mpc52xx_psc __iomem *psc,\r\nu16 prescaler, unsigned int divisor)\r\n{\r\nout_be16(&psc->mpc52xx_psc_clock_select, prescaler);\r\nout_8(&psc->ctur, divisor >> 8);\r\nout_8(&psc->ctlr, divisor & 0xff);\r\n}\r\nstatic void mpc52xx_psc_fifo_init(struct uart_port *port)\r\n{\r\nstruct mpc52xx_psc __iomem *psc = PSC(port);\r\nstruct mpc52xx_psc_fifo __iomem *fifo = FIFO_52xx(port);\r\nout_8(&fifo->rfcntl, 0x00);\r\nout_be16(&fifo->rfalarm, 0x1ff);\r\nout_8(&fifo->tfcntl, 0x07);\r\nout_be16(&fifo->tfalarm, 0x80);\r\nport->read_status_mask |= MPC52xx_PSC_IMR_RXRDY | MPC52xx_PSC_IMR_TXRDY;\r\nout_be16(&psc->mpc52xx_psc_imr, port->read_status_mask);\r\n}\r\nstatic int mpc52xx_psc_raw_rx_rdy(struct uart_port *port)\r\n{\r\nreturn in_be16(&PSC(port)->mpc52xx_psc_status)\r\n& MPC52xx_PSC_SR_RXRDY;\r\n}\r\nstatic int mpc52xx_psc_raw_tx_rdy(struct uart_port *port)\r\n{\r\nreturn in_be16(&PSC(port)->mpc52xx_psc_status)\r\n& MPC52xx_PSC_SR_TXRDY;\r\n}\r\nstatic int mpc52xx_psc_rx_rdy(struct uart_port *port)\r\n{\r\nreturn in_be16(&PSC(port)->mpc52xx_psc_isr)\r\n& port->read_status_mask\r\n& MPC52xx_PSC_IMR_RXRDY;\r\n}\r\nstatic int mpc52xx_psc_tx_rdy(struct uart_port *port)\r\n{\r\nreturn in_be16(&PSC(port)->mpc52xx_psc_isr)\r\n& port->read_status_mask\r\n& MPC52xx_PSC_IMR_TXRDY;\r\n}\r\nstatic int mpc52xx_psc_tx_empty(struct uart_port *port)\r\n{\r\nreturn in_be16(&PSC(port)->mpc52xx_psc_status)\r\n& MPC52xx_PSC_SR_TXEMP;\r\n}\r\nstatic void mpc52xx_psc_start_tx(struct uart_port *port)\r\n{\r\nport->read_status_mask |= MPC52xx_PSC_IMR_TXRDY;\r\nout_be16(&PSC(port)->mpc52xx_psc_imr, port->read_status_mask);\r\n}\r\nstatic void mpc52xx_psc_stop_tx(struct uart_port *port)\r\n{\r\nport->read_status_mask &= ~MPC52xx_PSC_IMR_TXRDY;\r\nout_be16(&PSC(port)->mpc52xx_psc_imr, port->read_status_mask);\r\n}\r\nstatic void mpc52xx_psc_stop_rx(struct uart_port *port)\r\n{\r\nport->read_status_mask &= ~MPC52xx_PSC_IMR_RXRDY;\r\nout_be16(&PSC(port)->mpc52xx_psc_imr, port->read_status_mask);\r\n}\r\nstatic void mpc52xx_psc_rx_clr_irq(struct uart_port *port)\r\n{\r\n}\r\nstatic void mpc52xx_psc_tx_clr_irq(struct uart_port *port)\r\n{\r\n}\r\nstatic void mpc52xx_psc_write_char(struct uart_port *port, unsigned char c)\r\n{\r\nout_8(&PSC(port)->mpc52xx_psc_buffer_8, c);\r\n}\r\nstatic unsigned char mpc52xx_psc_read_char(struct uart_port *port)\r\n{\r\nreturn in_8(&PSC(port)->mpc52xx_psc_buffer_8);\r\n}\r\nstatic void mpc52xx_psc_cw_disable_ints(struct uart_port *port)\r\n{\r\nout_be16(&PSC(port)->mpc52xx_psc_imr, 0);\r\n}\r\nstatic void mpc52xx_psc_cw_restore_ints(struct uart_port *port)\r\n{\r\nout_be16(&PSC(port)->mpc52xx_psc_imr, port->read_status_mask);\r\n}\r\nstatic unsigned int mpc5200_psc_set_baudrate(struct uart_port *port,\r\nstruct ktermios *new,\r\nstruct ktermios *old)\r\n{\r\nunsigned int baud;\r\nunsigned int divisor;\r\nbaud = uart_get_baud_rate(port, new, old,\r\nport->uartclk / (32 * 0xffff) + 1,\r\nport->uartclk / 32);\r\ndivisor = (port->uartclk + 16 * baud) / (32 * baud);\r\nmpc52xx_set_divisor(PSC(port), 0xdd00, divisor);\r\nreturn baud;\r\n}\r\nstatic unsigned int mpc5200b_psc_set_baudrate(struct uart_port *port,\r\nstruct ktermios *new,\r\nstruct ktermios *old)\r\n{\r\nunsigned int baud;\r\nunsigned int divisor;\r\nu16 prescaler;\r\nbaud = uart_get_baud_rate(port, new, old,\r\nport->uartclk / (32 * 0xffff) + 1,\r\nport->uartclk / 4);\r\ndivisor = (port->uartclk + 2 * baud) / (4 * baud);\r\nif (divisor > 0xffff) {\r\ndivisor = (divisor + 4) / 8;\r\nprescaler = 0xdd00;\r\n} else\r\nprescaler = 0xff00;\r\nmpc52xx_set_divisor(PSC(port), prescaler, divisor);\r\nreturn baud;\r\n}\r\nstatic void mpc52xx_psc_get_irq(struct uart_port *port, struct device_node *np)\r\n{\r\nport->irqflags = 0;\r\nport->irq = irq_of_parse_and_map(np, 0);\r\n}\r\nstatic irqreturn_t mpc52xx_psc_handle_irq(struct uart_port *port)\r\n{\r\nreturn mpc5xxx_uart_process_int(port);\r\n}\r\nstatic void mpc512x_psc_fifo_init(struct uart_port *port)\r\n{\r\nout_be16(&PSC(port)->mpc52xx_psc_clock_select, 0xdd00);\r\nout_be32(&FIFO_512x(port)->txcmd, MPC512x_PSC_FIFO_RESET_SLICE);\r\nout_be32(&FIFO_512x(port)->txcmd, MPC512x_PSC_FIFO_ENABLE_SLICE);\r\nout_be32(&FIFO_512x(port)->txalarm, 1);\r\nout_be32(&FIFO_512x(port)->tximr, 0);\r\nout_be32(&FIFO_512x(port)->rxcmd, MPC512x_PSC_FIFO_RESET_SLICE);\r\nout_be32(&FIFO_512x(port)->rxcmd, MPC512x_PSC_FIFO_ENABLE_SLICE);\r\nout_be32(&FIFO_512x(port)->rxalarm, 1);\r\nout_be32(&FIFO_512x(port)->rximr, 0);\r\nout_be32(&FIFO_512x(port)->tximr, MPC512x_PSC_FIFO_ALARM);\r\nout_be32(&FIFO_512x(port)->rximr, MPC512x_PSC_FIFO_ALARM);\r\n}\r\nstatic int mpc512x_psc_raw_rx_rdy(struct uart_port *port)\r\n{\r\nreturn !(in_be32(&FIFO_512x(port)->rxsr) & MPC512x_PSC_FIFO_EMPTY);\r\n}\r\nstatic int mpc512x_psc_raw_tx_rdy(struct uart_port *port)\r\n{\r\nreturn !(in_be32(&FIFO_512x(port)->txsr) & MPC512x_PSC_FIFO_FULL);\r\n}\r\nstatic int mpc512x_psc_rx_rdy(struct uart_port *port)\r\n{\r\nreturn in_be32(&FIFO_512x(port)->rxsr)\r\n& in_be32(&FIFO_512x(port)->rximr)\r\n& MPC512x_PSC_FIFO_ALARM;\r\n}\r\nstatic int mpc512x_psc_tx_rdy(struct uart_port *port)\r\n{\r\nreturn in_be32(&FIFO_512x(port)->txsr)\r\n& in_be32(&FIFO_512x(port)->tximr)\r\n& MPC512x_PSC_FIFO_ALARM;\r\n}\r\nstatic int mpc512x_psc_tx_empty(struct uart_port *port)\r\n{\r\nreturn in_be32(&FIFO_512x(port)->txsr)\r\n& MPC512x_PSC_FIFO_EMPTY;\r\n}\r\nstatic void mpc512x_psc_stop_rx(struct uart_port *port)\r\n{\r\nunsigned long rx_fifo_imr;\r\nrx_fifo_imr = in_be32(&FIFO_512x(port)->rximr);\r\nrx_fifo_imr &= ~MPC512x_PSC_FIFO_ALARM;\r\nout_be32(&FIFO_512x(port)->rximr, rx_fifo_imr);\r\n}\r\nstatic void mpc512x_psc_start_tx(struct uart_port *port)\r\n{\r\nunsigned long tx_fifo_imr;\r\ntx_fifo_imr = in_be32(&FIFO_512x(port)->tximr);\r\ntx_fifo_imr |= MPC512x_PSC_FIFO_ALARM;\r\nout_be32(&FIFO_512x(port)->tximr, tx_fifo_imr);\r\n}\r\nstatic void mpc512x_psc_stop_tx(struct uart_port *port)\r\n{\r\nunsigned long tx_fifo_imr;\r\ntx_fifo_imr = in_be32(&FIFO_512x(port)->tximr);\r\ntx_fifo_imr &= ~MPC512x_PSC_FIFO_ALARM;\r\nout_be32(&FIFO_512x(port)->tximr, tx_fifo_imr);\r\n}\r\nstatic void mpc512x_psc_rx_clr_irq(struct uart_port *port)\r\n{\r\nout_be32(&FIFO_512x(port)->rxisr, in_be32(&FIFO_512x(port)->rxisr));\r\n}\r\nstatic void mpc512x_psc_tx_clr_irq(struct uart_port *port)\r\n{\r\nout_be32(&FIFO_512x(port)->txisr, in_be32(&FIFO_512x(port)->txisr));\r\n}\r\nstatic void mpc512x_psc_write_char(struct uart_port *port, unsigned char c)\r\n{\r\nout_8(&FIFO_512x(port)->txdata_8, c);\r\n}\r\nstatic unsigned char mpc512x_psc_read_char(struct uart_port *port)\r\n{\r\nreturn in_8(&FIFO_512x(port)->rxdata_8);\r\n}\r\nstatic void mpc512x_psc_cw_disable_ints(struct uart_port *port)\r\n{\r\nport->read_status_mask =\r\nin_be32(&FIFO_512x(port)->tximr) << 16 |\r\nin_be32(&FIFO_512x(port)->rximr);\r\nout_be32(&FIFO_512x(port)->tximr, 0);\r\nout_be32(&FIFO_512x(port)->rximr, 0);\r\n}\r\nstatic void mpc512x_psc_cw_restore_ints(struct uart_port *port)\r\n{\r\nout_be32(&FIFO_512x(port)->tximr,\r\n(port->read_status_mask >> 16) & 0x7f);\r\nout_be32(&FIFO_512x(port)->rximr, port->read_status_mask & 0x7f);\r\n}\r\nstatic unsigned int mpc512x_psc_set_baudrate(struct uart_port *port,\r\nstruct ktermios *new,\r\nstruct ktermios *old)\r\n{\r\nunsigned int baud;\r\nunsigned int divisor;\r\nbaud = uart_get_baud_rate(port, new, old,\r\nport->uartclk / (16 * 0xffff) + 1,\r\nport->uartclk / 16);\r\ndivisor = (port->uartclk + 8 * baud) / (16 * baud);\r\nmpc52xx_set_divisor(PSC(port), 0xdd00, divisor);\r\nreturn baud;\r\n}\r\nstatic int __init mpc512x_psc_fifoc_init(void)\r\n{\r\nstruct device_node *np;\r\nnp = of_find_compatible_node(NULL, NULL,\r\n"fsl,mpc5121-psc-fifo");\r\nif (!np) {\r\npr_err("%s: Can't find FIFOC node\n", __func__);\r\nreturn -ENODEV;\r\n}\r\npsc_fifoc = of_iomap(np, 0);\r\nif (!psc_fifoc) {\r\npr_err("%s: Can't map FIFOC\n", __func__);\r\nof_node_put(np);\r\nreturn -ENODEV;\r\n}\r\npsc_fifoc_irq = irq_of_parse_and_map(np, 0);\r\nof_node_put(np);\r\nif (psc_fifoc_irq == NO_IRQ) {\r\npr_err("%s: Can't get FIFOC irq\n", __func__);\r\niounmap(psc_fifoc);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit mpc512x_psc_fifoc_uninit(void)\r\n{\r\niounmap(psc_fifoc);\r\n}\r\nstatic irqreturn_t mpc512x_psc_handle_irq(struct uart_port *port)\r\n{\r\nunsigned long fifoc_int;\r\nint psc_num;\r\nfifoc_int = in_be32(&psc_fifoc->fifoc_int);\r\npsc_num = (port->mapbase & 0xf00) >> 8;\r\nif (test_bit(psc_num, &fifoc_int) ||\r\ntest_bit(psc_num + 16, &fifoc_int))\r\nreturn mpc5xxx_uart_process_int(port);\r\nreturn IRQ_NONE;\r\n}\r\nstatic int mpc512x_psc_clock(struct uart_port *port, int enable)\r\n{\r\nstruct clk *psc_clk;\r\nint psc_num;\r\nchar clk_name[10];\r\nif (uart_console(port))\r\nreturn 0;\r\npsc_num = (port->mapbase & 0xf00) >> 8;\r\nsnprintf(clk_name, sizeof(clk_name), "psc%d_clk", psc_num);\r\npsc_clk = clk_get(port->dev, clk_name);\r\nif (IS_ERR(psc_clk)) {\r\ndev_err(port->dev, "Failed to get PSC clock entry!\n");\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(port->dev, "%s %sable\n", clk_name, enable ? "en" : "dis");\r\nif (enable)\r\nclk_enable(psc_clk);\r\nelse\r\nclk_disable(psc_clk);\r\nreturn 0;\r\n}\r\nstatic void mpc512x_psc_get_irq(struct uart_port *port, struct device_node *np)\r\n{\r\nport->irqflags = IRQF_SHARED;\r\nport->irq = psc_fifoc_irq;\r\n}\r\nstatic unsigned int\r\nmpc52xx_uart_tx_empty(struct uart_port *port)\r\n{\r\nreturn psc_ops->tx_empty(port) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic void\r\nmpc52xx_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nif (mctrl & TIOCM_RTS)\r\nout_8(&PSC(port)->op1, MPC52xx_PSC_OP_RTS);\r\nelse\r\nout_8(&PSC(port)->op0, MPC52xx_PSC_OP_RTS);\r\n}\r\nstatic unsigned int\r\nmpc52xx_uart_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned int ret = TIOCM_DSR;\r\nu8 status = in_8(&PSC(port)->mpc52xx_psc_ipcr);\r\nif (!(status & MPC52xx_PSC_CTS))\r\nret |= TIOCM_CTS;\r\nif (!(status & MPC52xx_PSC_DCD))\r\nret |= TIOCM_CAR;\r\nreturn ret;\r\n}\r\nstatic void\r\nmpc52xx_uart_stop_tx(struct uart_port *port)\r\n{\r\npsc_ops->stop_tx(port);\r\n}\r\nstatic void\r\nmpc52xx_uart_start_tx(struct uart_port *port)\r\n{\r\npsc_ops->start_tx(port);\r\n}\r\nstatic void\r\nmpc52xx_uart_send_xchar(struct uart_port *port, char ch)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nport->x_char = ch;\r\nif (ch) {\r\npsc_ops->start_tx(port);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void\r\nmpc52xx_uart_stop_rx(struct uart_port *port)\r\n{\r\npsc_ops->stop_rx(port);\r\n}\r\nstatic void\r\nmpc52xx_uart_enable_ms(struct uart_port *port)\r\n{\r\nstruct mpc52xx_psc __iomem *psc = PSC(port);\r\nin_8(&psc->mpc52xx_psc_ipcr);\r\nout_8(&psc->mpc52xx_psc_acr, MPC52xx_PSC_IEC_CTS | MPC52xx_PSC_IEC_DCD);\r\nport->read_status_mask |= MPC52xx_PSC_IMR_IPC;\r\nout_be16(&psc->mpc52xx_psc_imr, port->read_status_mask);\r\n}\r\nstatic void\r\nmpc52xx_uart_break_ctl(struct uart_port *port, int ctl)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (ctl == -1)\r\nout_8(&PSC(port)->command, MPC52xx_PSC_START_BRK);\r\nelse\r\nout_8(&PSC(port)->command, MPC52xx_PSC_STOP_BRK);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int\r\nmpc52xx_uart_startup(struct uart_port *port)\r\n{\r\nstruct mpc52xx_psc __iomem *psc = PSC(port);\r\nint ret;\r\nif (psc_ops->clock) {\r\nret = psc_ops->clock(port, 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = request_irq(port->irq, mpc52xx_uart_int,\r\nport->irqflags, "mpc52xx_psc_uart", port);\r\nif (ret)\r\nreturn ret;\r\nout_8(&psc->command, MPC52xx_PSC_RST_RX);\r\nout_8(&psc->command, MPC52xx_PSC_RST_TX);\r\nout_be32(&psc->sicr, 0);\r\npsc_ops->fifo_init(port);\r\nout_8(&psc->command, MPC52xx_PSC_TX_ENABLE);\r\nout_8(&psc->command, MPC52xx_PSC_RX_ENABLE);\r\nreturn 0;\r\n}\r\nstatic void\r\nmpc52xx_uart_shutdown(struct uart_port *port)\r\n{\r\nstruct mpc52xx_psc __iomem *psc = PSC(port);\r\nout_8(&psc->command, MPC52xx_PSC_RST_RX);\r\nif (!uart_console(port))\r\nout_8(&psc->command, MPC52xx_PSC_RST_TX);\r\nport->read_status_mask = 0;\r\nout_be16(&psc->mpc52xx_psc_imr, port->read_status_mask);\r\nif (psc_ops->clock)\r\npsc_ops->clock(port, 0);\r\nfree_irq(port->irq, port);\r\n}\r\nstatic void\r\nmpc52xx_uart_set_termios(struct uart_port *port, struct ktermios *new,\r\nstruct ktermios *old)\r\n{\r\nstruct mpc52xx_psc __iomem *psc = PSC(port);\r\nunsigned long flags;\r\nunsigned char mr1, mr2;\r\nunsigned int j;\r\nunsigned int baud;\r\nmr1 = 0;\r\nswitch (new->c_cflag & CSIZE) {\r\ncase CS5: mr1 |= MPC52xx_PSC_MODE_5_BITS;\r\nbreak;\r\ncase CS6: mr1 |= MPC52xx_PSC_MODE_6_BITS;\r\nbreak;\r\ncase CS7: mr1 |= MPC52xx_PSC_MODE_7_BITS;\r\nbreak;\r\ncase CS8:\r\ndefault: mr1 |= MPC52xx_PSC_MODE_8_BITS;\r\n}\r\nif (new->c_cflag & PARENB) {\r\nmr1 |= (new->c_cflag & PARODD) ?\r\nMPC52xx_PSC_MODE_PARODD : MPC52xx_PSC_MODE_PAREVEN;\r\n} else\r\nmr1 |= MPC52xx_PSC_MODE_PARNONE;\r\nmr2 = 0;\r\nif (new->c_cflag & CSTOPB)\r\nmr2 |= MPC52xx_PSC_MODE_TWO_STOP;\r\nelse\r\nmr2 |= ((new->c_cflag & CSIZE) == CS5) ?\r\nMPC52xx_PSC_MODE_ONE_STOP_5_BITS :\r\nMPC52xx_PSC_MODE_ONE_STOP;\r\nif (new->c_cflag & CRTSCTS) {\r\nmr1 |= MPC52xx_PSC_MODE_RXRTS;\r\nmr2 |= MPC52xx_PSC_MODE_TXCTS;\r\n}\r\nspin_lock_irqsave(&port->lock, flags);\r\nj = 5000000;\r\nwhile (!mpc52xx_uart_tx_empty(port) && --j)\r\nudelay(1);\r\nif (!j)\r\nprintk(KERN_ERR "mpc52xx_uart.c: "\r\n"Unable to flush RX & TX fifos in-time in set_termios."\r\n"Some chars may have been lost.\n");\r\nout_8(&psc->command, MPC52xx_PSC_RST_RX);\r\nout_8(&psc->command, MPC52xx_PSC_RST_TX);\r\nout_8(&psc->command, MPC52xx_PSC_SEL_MODE_REG_1);\r\nout_8(&psc->mode, mr1);\r\nout_8(&psc->mode, mr2);\r\nbaud = psc_ops->set_baudrate(port, new, old);\r\nuart_update_timeout(port, new->c_cflag, baud);\r\nif (UART_ENABLE_MS(port, new->c_cflag))\r\nmpc52xx_uart_enable_ms(port);\r\nout_8(&psc->command, MPC52xx_PSC_TX_ENABLE);\r\nout_8(&psc->command, MPC52xx_PSC_RX_ENABLE);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *\r\nmpc52xx_uart_type(struct uart_port *port)\r\n{\r\nreturn port->type == PORT_MPC52xx ? "MPC5xxx PSC" : NULL;\r\n}\r\nstatic void\r\nmpc52xx_uart_release_port(struct uart_port *port)\r\n{\r\nif (port->flags & UPF_IOREMAP) {\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\nrelease_mem_region(port->mapbase, sizeof(struct mpc52xx_psc));\r\n}\r\nstatic int\r\nmpc52xx_uart_request_port(struct uart_port *port)\r\n{\r\nint err;\r\nif (port->flags & UPF_IOREMAP)\r\nport->membase = ioremap(port->mapbase,\r\nsizeof(struct mpc52xx_psc));\r\nif (!port->membase)\r\nreturn -EINVAL;\r\nerr = request_mem_region(port->mapbase, sizeof(struct mpc52xx_psc),\r\n"mpc52xx_psc_uart") != NULL ? 0 : -EBUSY;\r\nif (err && (port->flags & UPF_IOREMAP)) {\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\nreturn err;\r\n}\r\nstatic void\r\nmpc52xx_uart_config_port(struct uart_port *port, int flags)\r\n{\r\nif ((flags & UART_CONFIG_TYPE)\r\n&& (mpc52xx_uart_request_port(port) == 0))\r\nport->type = PORT_MPC52xx;\r\n}\r\nstatic int\r\nmpc52xx_uart_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_MPC52xx)\r\nreturn -EINVAL;\r\nif ((ser->irq != port->irq) ||\r\n(ser->io_type != UPIO_MEM) ||\r\n(ser->baud_base != port->uartclk) ||\r\n(ser->iomem_base != (void *)port->mapbase) ||\r\n(ser->hub6 != 0))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nmpc52xx_uart_int_rx_chars(struct uart_port *port)\r\n{\r\nstruct tty_struct *tty = port->state->port.tty;\r\nunsigned char ch, flag;\r\nunsigned short status;\r\nwhile (psc_ops->raw_rx_rdy(port)) {\r\nch = psc_ops->read_char(port);\r\n#ifdef SUPPORT_SYSRQ\r\nif (uart_handle_sysrq_char(port, ch)) {\r\nport->sysrq = 0;\r\ncontinue;\r\n}\r\n#endif\r\nflag = TTY_NORMAL;\r\nport->icount.rx++;\r\nstatus = in_be16(&PSC(port)->mpc52xx_psc_status);\r\nif (status & (MPC52xx_PSC_SR_PE |\r\nMPC52xx_PSC_SR_FE |\r\nMPC52xx_PSC_SR_RB)) {\r\nif (status & MPC52xx_PSC_SR_RB) {\r\nflag = TTY_BREAK;\r\nuart_handle_break(port);\r\nport->icount.brk++;\r\n} else if (status & MPC52xx_PSC_SR_PE) {\r\nflag = TTY_PARITY;\r\nport->icount.parity++;\r\n}\r\nelse if (status & MPC52xx_PSC_SR_FE) {\r\nflag = TTY_FRAME;\r\nport->icount.frame++;\r\n}\r\nout_8(&PSC(port)->command, MPC52xx_PSC_RST_ERR_STAT);\r\n}\r\ntty_insert_flip_char(tty, ch, flag);\r\nif (status & MPC52xx_PSC_SR_OE) {\r\ntty_insert_flip_char(tty, 0, TTY_OVERRUN);\r\nport->icount.overrun++;\r\n}\r\n}\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(tty);\r\nspin_lock(&port->lock);\r\nreturn psc_ops->raw_rx_rdy(port);\r\n}\r\nstatic inline int\r\nmpc52xx_uart_int_tx_chars(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (port->x_char) {\r\npsc_ops->write_char(port, port->x_char);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn 1;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\nmpc52xx_uart_stop_tx(port);\r\nreturn 0;\r\n}\r\nwhile (psc_ops->raw_tx_rdy(port)) {\r\npsc_ops->write_char(port, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit)) {\r\nmpc52xx_uart_stop_tx(port);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic irqreturn_t\r\nmpc5xxx_uart_process_int(struct uart_port *port)\r\n{\r\nunsigned long pass = ISR_PASS_LIMIT;\r\nunsigned int keepgoing;\r\nu8 status;\r\ndo {\r\nkeepgoing = 0;\r\npsc_ops->rx_clr_irq(port);\r\nif (psc_ops->rx_rdy(port))\r\nkeepgoing |= mpc52xx_uart_int_rx_chars(port);\r\npsc_ops->tx_clr_irq(port);\r\nif (psc_ops->tx_rdy(port))\r\nkeepgoing |= mpc52xx_uart_int_tx_chars(port);\r\nstatus = in_8(&PSC(port)->mpc52xx_psc_ipcr);\r\nif (status & MPC52xx_PSC_D_DCD)\r\nuart_handle_dcd_change(port, !(status & MPC52xx_PSC_DCD));\r\nif (status & MPC52xx_PSC_D_CTS)\r\nuart_handle_cts_change(port, !(status & MPC52xx_PSC_CTS));\r\nif (!(--pass))\r\nkeepgoing = 0;\r\n} while (keepgoing);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nmpc52xx_uart_int(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nirqreturn_t ret;\r\nspin_lock(&port->lock);\r\nret = psc_ops->handle_irq(port);\r\nspin_unlock(&port->lock);\r\nreturn ret;\r\n}\r\nstatic void __init\r\nmpc52xx_console_get_options(struct uart_port *port,\r\nint *baud, int *parity, int *bits, int *flow)\r\n{\r\nstruct mpc52xx_psc __iomem *psc = PSC(port);\r\nunsigned char mr1;\r\npr_debug("mpc52xx_console_get_options(port=%p)\n", port);\r\nout_8(&psc->command, MPC52xx_PSC_SEL_MODE_REG_1);\r\nmr1 = in_8(&psc->mode);\r\n*baud = CONFIG_SERIAL_MPC52xx_CONSOLE_BAUD;\r\nswitch (mr1 & MPC52xx_PSC_MODE_BITS_MASK) {\r\ncase MPC52xx_PSC_MODE_5_BITS:\r\n*bits = 5;\r\nbreak;\r\ncase MPC52xx_PSC_MODE_6_BITS:\r\n*bits = 6;\r\nbreak;\r\ncase MPC52xx_PSC_MODE_7_BITS:\r\n*bits = 7;\r\nbreak;\r\ncase MPC52xx_PSC_MODE_8_BITS:\r\ndefault:\r\n*bits = 8;\r\n}\r\nif (mr1 & MPC52xx_PSC_MODE_PARNONE)\r\n*parity = 'n';\r\nelse\r\n*parity = mr1 & MPC52xx_PSC_MODE_PARODD ? 'o' : 'e';\r\n}\r\nstatic void\r\nmpc52xx_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct uart_port *port = &mpc52xx_uart_ports[co->index];\r\nunsigned int i, j;\r\npsc_ops->cw_disable_ints(port);\r\nj = 5000000;\r\nwhile (!mpc52xx_uart_tx_empty(port) && --j)\r\nudelay(1);\r\nfor (i = 0; i < count; i++, s++) {\r\nif (*s == '\n')\r\npsc_ops->write_char(port, '\r');\r\npsc_ops->write_char(port, *s);\r\nj = 20000;\r\nwhile (!mpc52xx_uart_tx_empty(port) && --j)\r\nudelay(1);\r\n}\r\npsc_ops->cw_restore_ints(port);\r\n}\r\nstatic int __init\r\nmpc52xx_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port = &mpc52xx_uart_ports[co->index];\r\nstruct device_node *np = mpc52xx_uart_nodes[co->index];\r\nunsigned int uartclk;\r\nstruct resource res;\r\nint ret;\r\nint baud = CONFIG_SERIAL_MPC52xx_CONSOLE_BAUD;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\npr_debug("mpc52xx_console_setup co=%p, co->index=%i, options=%s\n",\r\nco, co->index, options);\r\nif ((co->index < 0) || (co->index >= MPC52xx_PSC_MAXNUM)) {\r\npr_debug("PSC%x out of range\n", co->index);\r\nreturn -EINVAL;\r\n}\r\nif (!np) {\r\npr_debug("PSC%x not found in device tree\n", co->index);\r\nreturn -EINVAL;\r\n}\r\npr_debug("Console on ttyPSC%x is %s\n",\r\nco->index, mpc52xx_uart_nodes[co->index]->full_name);\r\nret = of_address_to_resource(np, 0, &res);\r\nif (ret) {\r\npr_debug("Could not get resources for PSC%x\n", co->index);\r\nreturn ret;\r\n}\r\nuartclk = mpc5xxx_get_bus_frequency(np);\r\nif (uartclk == 0) {\r\npr_debug("Could not find uart clock frequency!\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_init(&port->lock);\r\nport->uartclk = uartclk;\r\nport->ops = &mpc52xx_uart_ops;\r\nport->mapbase = res.start;\r\nport->membase = ioremap(res.start, sizeof(struct mpc52xx_psc));\r\nport->irq = irq_of_parse_and_map(np, 0);\r\nif (port->membase == NULL)\r\nreturn -EINVAL;\r\npr_debug("mpc52xx-psc uart at %p, mapped to %p, irq=%x, freq=%i\n",\r\n(void *)port->mapbase, port->membase,\r\nport->irq, port->uartclk);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\nmpc52xx_console_get_options(port, &baud, &parity, &bits, &flow);\r\npr_debug("Setting console parameters: %i %i%c1 flow=%c\n",\r\nbaud, bits, parity, flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init\r\nmpc52xx_console_init(void)\r\n{\r\nmpc52xx_uart_of_enumerate();\r\nregister_console(&mpc52xx_console);\r\nreturn 0;\r\n}\r\nstatic int __devinit mpc52xx_uart_of_probe(struct platform_device *op)\r\n{\r\nint idx = -1;\r\nunsigned int uartclk;\r\nstruct uart_port *port = NULL;\r\nstruct resource res;\r\nint ret;\r\nfor (idx = 0; idx < MPC52xx_PSC_MAXNUM; idx++)\r\nif (mpc52xx_uart_nodes[idx] == op->dev.of_node)\r\nbreak;\r\nif (idx >= MPC52xx_PSC_MAXNUM)\r\nreturn -EINVAL;\r\npr_debug("Found %s assigned to ttyPSC%x\n",\r\nmpc52xx_uart_nodes[idx]->full_name, idx);\r\nuartclk = mpc5xxx_get_bus_frequency(op->dev.of_node);\r\nif (uartclk == 0) {\r\ndev_dbg(&op->dev, "Could not find uart clock frequency!\n");\r\nreturn -EINVAL;\r\n}\r\nport = &mpc52xx_uart_ports[idx];\r\nspin_lock_init(&port->lock);\r\nport->uartclk = uartclk;\r\nport->fifosize = 512;\r\nport->iotype = UPIO_MEM;\r\nport->flags = UPF_BOOT_AUTOCONF |\r\n(uart_console(port) ? 0 : UPF_IOREMAP);\r\nport->line = idx;\r\nport->ops = &mpc52xx_uart_ops;\r\nport->dev = &op->dev;\r\nret = of_address_to_resource(op->dev.of_node, 0, &res);\r\nif (ret)\r\nreturn ret;\r\nport->mapbase = res.start;\r\nif (!port->mapbase) {\r\ndev_dbg(&op->dev, "Could not allocate resources for PSC\n");\r\nreturn -EINVAL;\r\n}\r\npsc_ops->get_irq(port, op->dev.of_node);\r\nif (port->irq == NO_IRQ) {\r\ndev_dbg(&op->dev, "Could not get irq\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&op->dev, "mpc52xx-psc uart at %p, irq=%x, freq=%i\n",\r\n(void *)port->mapbase, port->irq, port->uartclk);\r\nret = uart_add_one_port(&mpc52xx_uart_driver, port);\r\nif (ret)\r\nreturn ret;\r\ndev_set_drvdata(&op->dev, (void *)port);\r\nreturn 0;\r\n}\r\nstatic int\r\nmpc52xx_uart_of_remove(struct platform_device *op)\r\n{\r\nstruct uart_port *port = dev_get_drvdata(&op->dev);\r\ndev_set_drvdata(&op->dev, NULL);\r\nif (port)\r\nuart_remove_one_port(&mpc52xx_uart_driver, port);\r\nreturn 0;\r\n}\r\nstatic int\r\nmpc52xx_uart_of_suspend(struct platform_device *op, pm_message_t state)\r\n{\r\nstruct uart_port *port = (struct uart_port *) dev_get_drvdata(&op->dev);\r\nif (port)\r\nuart_suspend_port(&mpc52xx_uart_driver, port);\r\nreturn 0;\r\n}\r\nstatic int\r\nmpc52xx_uart_of_resume(struct platform_device *op)\r\n{\r\nstruct uart_port *port = (struct uart_port *) dev_get_drvdata(&op->dev);\r\nif (port)\r\nuart_resume_port(&mpc52xx_uart_driver, port);\r\nreturn 0;\r\n}\r\nstatic void\r\nmpc52xx_uart_of_assign(struct device_node *np)\r\n{\r\nint i;\r\nfor (i = 0; i < MPC52xx_PSC_MAXNUM; i++) {\r\nif (mpc52xx_uart_nodes[i] == NULL) {\r\nof_node_get(np);\r\nmpc52xx_uart_nodes[i] = np;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void\r\nmpc52xx_uart_of_enumerate(void)\r\n{\r\nstatic int enum_done;\r\nstruct device_node *np;\r\nconst struct of_device_id *match;\r\nint i;\r\nif (enum_done)\r\nreturn;\r\nfor_each_matching_node(np, mpc52xx_uart_of_match) {\r\nmatch = of_match_node(mpc52xx_uart_of_match, np);\r\npsc_ops = match->data;\r\nmpc52xx_uart_of_assign(np);\r\n}\r\nenum_done = 1;\r\nfor (i = 0; i < MPC52xx_PSC_MAXNUM; i++) {\r\nif (mpc52xx_uart_nodes[i])\r\npr_debug("%s assigned to ttyPSC%x\n",\r\nmpc52xx_uart_nodes[i]->full_name, i);\r\n}\r\n}\r\nstatic int __init\r\nmpc52xx_uart_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "Serial: MPC52xx PSC UART driver\n");\r\nret = uart_register_driver(&mpc52xx_uart_driver);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: uart_register_driver failed (%i)\n",\r\n__FILE__, ret);\r\nreturn ret;\r\n}\r\nmpc52xx_uart_of_enumerate();\r\nif (psc_ops && psc_ops->fifoc_init) {\r\nret = psc_ops->fifoc_init();\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = platform_driver_register(&mpc52xx_uart_of_driver);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: platform_driver_register failed (%i)\n",\r\n__FILE__, ret);\r\nuart_unregister_driver(&mpc52xx_uart_driver);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit\r\nmpc52xx_uart_exit(void)\r\n{\r\nif (psc_ops->fifoc_uninit)\r\npsc_ops->fifoc_uninit();\r\nplatform_driver_unregister(&mpc52xx_uart_of_driver);\r\nuart_unregister_driver(&mpc52xx_uart_driver);\r\n}
