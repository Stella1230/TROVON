static int _mmc_select_card(struct mmc_host *host, struct mmc_card *card)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nBUG_ON(!host);\r\ncmd.opcode = MMC_SELECT_CARD;\r\nif (card) {\r\ncmd.arg = card->rca << 16;\r\ncmd.flags = MMC_RSP_R1 | MMC_CMD_AC;\r\n} else {\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_NONE | MMC_CMD_AC;\r\n}\r\nerr = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint mmc_select_card(struct mmc_card *card)\r\n{\r\nBUG_ON(!card);\r\nreturn _mmc_select_card(card->host, card);\r\n}\r\nint mmc_deselect_cards(struct mmc_host *host)\r\n{\r\nreturn _mmc_select_card(host, NULL);\r\n}\r\nint mmc_card_sleepawake(struct mmc_host *host, int sleep)\r\n{\r\nstruct mmc_command cmd = {0};\r\nstruct mmc_card *card = host->card;\r\nint err;\r\nif (sleep)\r\nmmc_deselect_cards(host);\r\ncmd.opcode = MMC_SLEEP_AWAKE;\r\ncmd.arg = card->rca << 16;\r\nif (sleep)\r\ncmd.arg |= 1 << 15;\r\ncmd.flags = MMC_RSP_R1B | MMC_CMD_AC;\r\nerr = mmc_wait_for_cmd(host, &cmd, 0);\r\nif (err)\r\nreturn err;\r\nif (!(host->caps & MMC_CAP_WAIT_WHILE_BUSY))\r\nmmc_delay(DIV_ROUND_UP(card->ext_csd.sa_timeout, 10000));\r\nif (!sleep)\r\nerr = mmc_select_card(card);\r\nreturn err;\r\n}\r\nint mmc_go_idle(struct mmc_host *host)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nif (!mmc_host_is_spi(host)) {\r\nmmc_set_chip_select(host, MMC_CS_HIGH);\r\nmmc_delay(1);\r\n}\r\ncmd.opcode = MMC_GO_IDLE_STATE;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_NONE | MMC_CMD_BC;\r\nerr = mmc_wait_for_cmd(host, &cmd, 0);\r\nmmc_delay(1);\r\nif (!mmc_host_is_spi(host)) {\r\nmmc_set_chip_select(host, MMC_CS_DONTCARE);\r\nmmc_delay(1);\r\n}\r\nhost->use_spi_crc = 0;\r\nreturn err;\r\n}\r\nint mmc_send_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)\r\n{\r\nstruct mmc_command cmd = {0};\r\nint i, err = 0;\r\nBUG_ON(!host);\r\ncmd.opcode = MMC_SEND_OP_COND;\r\ncmd.arg = mmc_host_is_spi(host) ? 0 : ocr;\r\ncmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R3 | MMC_CMD_BCR;\r\nfor (i = 100; i; i--) {\r\nerr = mmc_wait_for_cmd(host, &cmd, 0);\r\nif (err)\r\nbreak;\r\nif (ocr == 0)\r\nbreak;\r\nif (mmc_host_is_spi(host)) {\r\nif (!(cmd.resp[0] & R1_SPI_IDLE))\r\nbreak;\r\n} else {\r\nif (cmd.resp[0] & MMC_CARD_BUSY)\r\nbreak;\r\n}\r\nerr = -ETIMEDOUT;\r\nmmc_delay(10);\r\n}\r\nif (rocr && !mmc_host_is_spi(host))\r\n*rocr = cmd.resp[0];\r\nreturn err;\r\n}\r\nint mmc_all_send_cid(struct mmc_host *host, u32 *cid)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nBUG_ON(!host);\r\nBUG_ON(!cid);\r\ncmd.opcode = MMC_ALL_SEND_CID;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_R2 | MMC_CMD_BCR;\r\nerr = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\r\nif (err)\r\nreturn err;\r\nmemcpy(cid, cmd.resp, sizeof(u32) * 4);\r\nreturn 0;\r\n}\r\nint mmc_set_relative_addr(struct mmc_card *card)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nBUG_ON(!card);\r\nBUG_ON(!card->host);\r\ncmd.opcode = MMC_SET_RELATIVE_ADDR;\r\ncmd.arg = card->rca << 16;\r\ncmd.flags = MMC_RSP_R1 | MMC_CMD_AC;\r\nerr = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int\r\nmmc_send_cxd_native(struct mmc_host *host, u32 arg, u32 *cxd, int opcode)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nBUG_ON(!host);\r\nBUG_ON(!cxd);\r\ncmd.opcode = opcode;\r\ncmd.arg = arg;\r\ncmd.flags = MMC_RSP_R2 | MMC_CMD_AC;\r\nerr = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\r\nif (err)\r\nreturn err;\r\nmemcpy(cxd, cmd.resp, sizeof(u32) * 4);\r\nreturn 0;\r\n}\r\nstatic int\r\nmmc_send_cxd_data(struct mmc_card *card, struct mmc_host *host,\r\nu32 opcode, void *buf, unsigned len)\r\n{\r\nstruct mmc_request mrq = {NULL};\r\nstruct mmc_command cmd = {0};\r\nstruct mmc_data data = {0};\r\nstruct scatterlist sg;\r\nvoid *data_buf;\r\ndata_buf = kmalloc(len, GFP_KERNEL);\r\nif (data_buf == NULL)\r\nreturn -ENOMEM;\r\nmrq.cmd = &cmd;\r\nmrq.data = &data;\r\ncmd.opcode = opcode;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;\r\ndata.blksz = len;\r\ndata.blocks = 1;\r\ndata.flags = MMC_DATA_READ;\r\ndata.sg = &sg;\r\ndata.sg_len = 1;\r\nsg_init_one(&sg, data_buf, len);\r\nif (opcode == MMC_SEND_CSD || opcode == MMC_SEND_CID) {\r\ndata.timeout_ns = 0;\r\ndata.timeout_clks = 64;\r\n} else\r\nmmc_set_data_timeout(&data, card);\r\nmmc_wait_for_req(host, &mrq);\r\nmemcpy(buf, data_buf, len);\r\nkfree(data_buf);\r\nif (cmd.error)\r\nreturn cmd.error;\r\nif (data.error)\r\nreturn data.error;\r\nreturn 0;\r\n}\r\nint mmc_send_csd(struct mmc_card *card, u32 *csd)\r\n{\r\nint ret, i;\r\nif (!mmc_host_is_spi(card->host))\r\nreturn mmc_send_cxd_native(card->host, card->rca << 16,\r\ncsd, MMC_SEND_CSD);\r\nret = mmc_send_cxd_data(card, card->host, MMC_SEND_CSD, csd, 16);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0;i < 4;i++)\r\ncsd[i] = be32_to_cpu(csd[i]);\r\nreturn 0;\r\n}\r\nint mmc_send_cid(struct mmc_host *host, u32 *cid)\r\n{\r\nint ret, i;\r\nif (!mmc_host_is_spi(host)) {\r\nif (!host->card)\r\nreturn -EINVAL;\r\nreturn mmc_send_cxd_native(host, host->card->rca << 16,\r\ncid, MMC_SEND_CID);\r\n}\r\nret = mmc_send_cxd_data(NULL, host, MMC_SEND_CID, cid, 16);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0;i < 4;i++)\r\ncid[i] = be32_to_cpu(cid[i]);\r\nreturn 0;\r\n}\r\nint mmc_send_ext_csd(struct mmc_card *card, u8 *ext_csd)\r\n{\r\nreturn mmc_send_cxd_data(card, card->host, MMC_SEND_EXT_CSD,\r\next_csd, 512);\r\n}\r\nint mmc_spi_read_ocr(struct mmc_host *host, int highcap, u32 *ocrp)\r\n{\r\nstruct mmc_command cmd = {0};\r\nint err;\r\ncmd.opcode = MMC_SPI_READ_OCR;\r\ncmd.arg = highcap ? (1 << 30) : 0;\r\ncmd.flags = MMC_RSP_SPI_R3;\r\nerr = mmc_wait_for_cmd(host, &cmd, 0);\r\n*ocrp = cmd.resp[1];\r\nreturn err;\r\n}\r\nint mmc_spi_set_crc(struct mmc_host *host, int use_crc)\r\n{\r\nstruct mmc_command cmd = {0};\r\nint err;\r\ncmd.opcode = MMC_SPI_CRC_ON_OFF;\r\ncmd.flags = MMC_RSP_SPI_R1;\r\ncmd.arg = use_crc;\r\nerr = mmc_wait_for_cmd(host, &cmd, 0);\r\nif (!err)\r\nhost->use_spi_crc = use_crc;\r\nreturn err;\r\n}\r\nint mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,\r\nunsigned int timeout_ms)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nu32 status;\r\nBUG_ON(!card);\r\nBUG_ON(!card->host);\r\ncmd.opcode = MMC_SWITCH;\r\ncmd.arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |\r\n(index << 16) |\r\n(value << 8) |\r\nset;\r\ncmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;\r\ncmd.cmd_timeout_ms = timeout_ms;\r\nerr = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);\r\nif (err)\r\nreturn err;\r\ndo {\r\nerr = mmc_send_status(card, &status);\r\nif (err)\r\nreturn err;\r\nif (card->host->caps & MMC_CAP_WAIT_WHILE_BUSY)\r\nbreak;\r\nif (mmc_host_is_spi(card->host))\r\nbreak;\r\n} while (R1_CURRENT_STATE(status) == R1_STATE_PRG);\r\nif (mmc_host_is_spi(card->host)) {\r\nif (status & R1_SPI_ILLEGAL_COMMAND)\r\nreturn -EBADMSG;\r\n} else {\r\nif (status & 0xFDFFA000)\r\npr_warning("%s: unexpected status %#x after "\r\n"switch", mmc_hostname(card->host), status);\r\nif (status & R1_SWITCH_ERROR)\r\nreturn -EBADMSG;\r\n}\r\nreturn 0;\r\n}\r\nint mmc_send_status(struct mmc_card *card, u32 *status)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nBUG_ON(!card);\r\nBUG_ON(!card->host);\r\ncmd.opcode = MMC_SEND_STATUS;\r\nif (!mmc_host_is_spi(card->host))\r\ncmd.arg = card->rca << 16;\r\ncmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;\r\nerr = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);\r\nif (err)\r\nreturn err;\r\nif (status)\r\n*status = cmd.resp[0];\r\nreturn 0;\r\n}\r\nstatic int\r\nmmc_send_bus_test(struct mmc_card *card, struct mmc_host *host, u8 opcode,\r\nu8 len)\r\n{\r\nstruct mmc_request mrq = {NULL};\r\nstruct mmc_command cmd = {0};\r\nstruct mmc_data data = {0};\r\nstruct scatterlist sg;\r\nu8 *data_buf;\r\nu8 *test_buf;\r\nint i, err;\r\nstatic u8 testdata_8bit[8] = { 0x55, 0xaa, 0, 0, 0, 0, 0, 0 };\r\nstatic u8 testdata_4bit[4] = { 0x5a, 0, 0, 0 };\r\ndata_buf = kmalloc(len, GFP_KERNEL);\r\nif (!data_buf)\r\nreturn -ENOMEM;\r\nif (len == 8)\r\ntest_buf = testdata_8bit;\r\nelse if (len == 4)\r\ntest_buf = testdata_4bit;\r\nelse {\r\npr_err("%s: Invalid bus_width %d\n",\r\nmmc_hostname(host), len);\r\nkfree(data_buf);\r\nreturn -EINVAL;\r\n}\r\nif (opcode == MMC_BUS_TEST_W)\r\nmemcpy(data_buf, test_buf, len);\r\nmrq.cmd = &cmd;\r\nmrq.data = &data;\r\ncmd.opcode = opcode;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;\r\ndata.blksz = len;\r\ndata.blocks = 1;\r\nif (opcode == MMC_BUS_TEST_R)\r\ndata.flags = MMC_DATA_READ;\r\nelse\r\ndata.flags = MMC_DATA_WRITE;\r\ndata.sg = &sg;\r\ndata.sg_len = 1;\r\nsg_init_one(&sg, data_buf, len);\r\nmmc_wait_for_req(host, &mrq);\r\nerr = 0;\r\nif (opcode == MMC_BUS_TEST_R) {\r\nfor (i = 0; i < len / 4; i++)\r\nif ((test_buf[i] ^ data_buf[i]) != 0xff) {\r\nerr = -EIO;\r\nbreak;\r\n}\r\n}\r\nkfree(data_buf);\r\nif (cmd.error)\r\nreturn cmd.error;\r\nif (data.error)\r\nreturn data.error;\r\nreturn err;\r\n}\r\nint mmc_bus_test(struct mmc_card *card, u8 bus_width)\r\n{\r\nint err, width;\r\nif (bus_width == MMC_BUS_WIDTH_8)\r\nwidth = 8;\r\nelse if (bus_width == MMC_BUS_WIDTH_4)\r\nwidth = 4;\r\nelse if (bus_width == MMC_BUS_WIDTH_1)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\nmmc_send_bus_test(card, card->host, MMC_BUS_TEST_W, width);\r\nerr = mmc_send_bus_test(card, card->host, MMC_BUS_TEST_R, width);\r\nreturn err;\r\n}\r\nint mmc_send_hpi_cmd(struct mmc_card *card, u32 *status)\r\n{\r\nstruct mmc_command cmd = {0};\r\nunsigned int opcode;\r\nunsigned int flags;\r\nint err;\r\nopcode = card->ext_csd.hpi_cmd;\r\nif (opcode == MMC_STOP_TRANSMISSION)\r\nflags = MMC_RSP_R1 | MMC_CMD_AC;\r\nelse if (opcode == MMC_SEND_STATUS)\r\nflags = MMC_RSP_R1 | MMC_CMD_AC;\r\ncmd.opcode = opcode;\r\ncmd.arg = card->rca << 16 | 1;\r\ncmd.flags = flags;\r\ncmd.cmd_timeout_ms = card->ext_csd.out_of_int_time;\r\nerr = mmc_wait_for_cmd(card->host, &cmd, 0);\r\nif (err) {\r\npr_warn("%s: error %d interrupting operation. "\r\n"HPI command response %#x\n", mmc_hostname(card->host),\r\nerr, cmd.resp[0]);\r\nreturn err;\r\n}\r\nif (status)\r\n*status = cmd.resp[0];\r\nreturn 0;\r\n}
