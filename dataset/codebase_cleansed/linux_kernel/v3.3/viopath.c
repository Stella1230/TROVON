static int proc_viopath_show(struct seq_file *m, void *v)\r\n{\r\nchar *buf;\r\nu16 vlanMap;\r\ndma_addr_t handle;\r\nHvLpEvent_Rc hvrc;\r\nDECLARE_COMPLETION_ONSTACK(done);\r\nstruct device_node *node;\r\nconst char *sysid;\r\nbuf = kzalloc(HW_PAGE_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn 0;\r\nhandle = iseries_hv_map(buf, HW_PAGE_SIZE, DMA_FROM_DEVICE);\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_config | vioconfigget,\r\nHvLpEvent_AckInd_DoAck, HvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n(u64)(unsigned long)&done, VIOVERSION << 16,\r\n((u64)handle) << 32, HW_PAGE_SIZE, 0, 0);\r\nif (hvrc != HvLpEvent_Rc_Good)\r\nprintk(VIOPATH_KERN_WARN "hv error on op %d\n", (int)hvrc);\r\nwait_for_completion(&done);\r\nvlanMap = HvLpConfig_getVirtualLanIndexMap();\r\nbuf[HW_PAGE_SIZE-1] = '\0';\r\nseq_printf(m, "%s", buf);\r\niseries_hv_unmap(handle, HW_PAGE_SIZE, DMA_FROM_DEVICE);\r\nkfree(buf);\r\nseq_printf(m, "AVAILABLE_VETH=%x\n", vlanMap);\r\nnode = of_find_node_by_path("/");\r\nsysid = NULL;\r\nif (node != NULL)\r\nsysid = of_get_property(node, "system-id", NULL);\r\nif (sysid == NULL)\r\nseq_printf(m, "SRLNBR=<UNKNOWN>\n");\r\nelse\r\nseq_printf(m, "SRLNBR=%s\n", sysid + 4);\r\nof_node_put(node);\r\nreturn 0;\r\n}\r\nstatic int proc_viopath_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_viopath_show, NULL);\r\n}\r\nstatic int __init vio_proc_init(void)\r\n{\r\nif (!firmware_has_feature(FW_FEATURE_ISERIES))\r\nreturn 0;\r\nproc_create("iSeries/config", 0, NULL, &proc_viopath_operations);\r\nreturn 0;\r\n}\r\nint viopath_isactive(HvLpIndex lp)\r\n{\r\nif (lp == HvLpIndexInvalid)\r\nreturn 0;\r\nif (lp < HVMAXARCHITECTEDLPS)\r\nreturn viopathStatus[lp].isActive;\r\nelse\r\nreturn 0;\r\n}\r\nHvLpInstanceId viopath_sourceinst(HvLpIndex lp)\r\n{\r\nreturn viopathStatus[lp].mSourceInst;\r\n}\r\nHvLpInstanceId viopath_targetinst(HvLpIndex lp)\r\n{\r\nreturn viopathStatus[lp].mTargetInst;\r\n}\r\nstatic void sendMonMsg(HvLpIndex remoteLp)\r\n{\r\nHvLpEvent_Rc hvrc;\r\nviopathStatus[remoteLp].mSourceInst =\r\nHvCallEvent_getSourceLpInstanceId(remoteLp,\r\nHvLpEvent_Type_VirtualIo);\r\nviopathStatus[remoteLp].mTargetInst =\r\nHvCallEvent_getTargetLpInstanceId(remoteLp,\r\nHvLpEvent_Type_VirtualIo);\r\nvio_setHandler(viomajorsubtype_monitor, handleMonitorEvent);\r\nhvrc = HvCallEvent_signalLpEventFast(remoteLp, HvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_monitor, HvLpEvent_AckInd_DoAck,\r\nHvLpEvent_AckType_DeferredAck,\r\nviopathStatus[remoteLp].mSourceInst,\r\nviopathStatus[remoteLp].mTargetInst,\r\nviomonseq++, 0, 0, 0, 0, 0);\r\nif (hvrc == HvLpEvent_Rc_Good)\r\nviopathStatus[remoteLp].isActive = 1;\r\nelse {\r\nprintk(VIOPATH_KERN_WARN "could not connect to partition %d\n",\r\nremoteLp);\r\nviopathStatus[remoteLp].isActive = 0;\r\n}\r\n}\r\nstatic void handleMonitorEvent(struct HvLpEvent *event)\r\n{\r\nHvLpIndex remoteLp;\r\nint i;\r\nif (!event)\r\nreturn;\r\nif (hvlpevent_is_int(event)) {\r\nremoteLp = event->xSourceLp;\r\nif (!viopathStatus[remoteLp].isActive)\r\nsendMonMsg(remoteLp);\r\nreturn;\r\n}\r\nremoteLp = event->xTargetLp;\r\nif ((event->xSourceInstanceId != viopathStatus[remoteLp].mSourceInst) ||\r\n(event->xTargetInstanceId != viopathStatus[remoteLp].mTargetInst)) {\r\nprintk(VIOPATH_KERN_WARN "ignoring ack....mismatched instances\n");\r\nreturn;\r\n}\r\nprintk(VIOPATH_KERN_WARN "partition %d ended\n", remoteLp);\r\nviopathStatus[remoteLp].isActive = 0;\r\nfor (i = 0; i < VIO_MAX_SUBTYPES; i++) {\r\nif (vio_handler[i] != NULL)\r\n(*vio_handler[i])(NULL);\r\n}\r\n}\r\nint vio_setHandler(int subtype, vio_event_handler_t *beh)\r\n{\r\nsubtype = subtype >> VIOMAJOR_SUBTYPE_SHIFT;\r\nif ((subtype < 0) || (subtype >= VIO_MAX_SUBTYPES))\r\nreturn -EINVAL;\r\nif (vio_handler[subtype] != NULL)\r\nreturn -EBUSY;\r\nvio_handler[subtype] = beh;\r\nreturn 0;\r\n}\r\nint vio_clearHandler(int subtype)\r\n{\r\nsubtype = subtype >> VIOMAJOR_SUBTYPE_SHIFT;\r\nif ((subtype < 0) || (subtype >= VIO_MAX_SUBTYPES))\r\nreturn -EINVAL;\r\nif (vio_handler[subtype] == NULL)\r\nreturn -EAGAIN;\r\nvio_handler[subtype] = NULL;\r\nreturn 0;\r\n}\r\nstatic void handleConfig(struct HvLpEvent *event)\r\n{\r\nif (!event)\r\nreturn;\r\nif (hvlpevent_is_int(event)) {\r\nprintk(VIOPATH_KERN_WARN\r\n"unexpected config request from partition %d",\r\nevent->xSourceLp);\r\nif (hvlpevent_need_ack(event)) {\r\nevent->xRc = HvLpEvent_Rc_InvalidSubtype;\r\nHvCallEvent_ackLpEvent(event);\r\n}\r\nreturn;\r\n}\r\ncomplete((struct completion *)event->xCorrelationToken);\r\n}\r\nvoid vio_set_hostlp(void)\r\n{\r\nif (viopath_hostLp != HvLpIndexInvalid)\r\nreturn;\r\nviopath_ourLp = HvLpConfig_getLpIndex();\r\nviopath_hostLp = HvLpConfig_getHostingLpIndex(viopath_ourLp);\r\nif (viopath_hostLp != HvLpIndexInvalid)\r\nvio_setHandler(viomajorsubtype_config, handleConfig);\r\n}\r\nstatic void vio_handleEvent(struct HvLpEvent *event)\r\n{\r\nHvLpIndex remoteLp;\r\nint subtype = (event->xSubtype & VIOMAJOR_SUBTYPE_MASK)\r\n>> VIOMAJOR_SUBTYPE_SHIFT;\r\nif (hvlpevent_is_int(event)) {\r\nremoteLp = event->xSourceLp;\r\nif (viopathStatus[remoteLp].isActive\r\n&& (event->xSourceInstanceId !=\r\nviopathStatus[remoteLp].mTargetInst)) {\r\nprintk(VIOPATH_KERN_WARN\r\n"message from invalid partition. "\r\n"int msg rcvd, source inst (%d) doesn't match (%d)\n",\r\nviopathStatus[remoteLp].mTargetInst,\r\nevent->xSourceInstanceId);\r\nreturn;\r\n}\r\nif (viopathStatus[remoteLp].isActive\r\n&& (event->xTargetInstanceId !=\r\nviopathStatus[remoteLp].mSourceInst)) {\r\nprintk(VIOPATH_KERN_WARN\r\n"message from invalid partition. "\r\n"int msg rcvd, target inst (%d) doesn't match (%d)\n",\r\nviopathStatus[remoteLp].mSourceInst,\r\nevent->xTargetInstanceId);\r\nreturn;\r\n}\r\n} else {\r\nremoteLp = event->xTargetLp;\r\nif (event->xSourceInstanceId !=\r\nviopathStatus[remoteLp].mSourceInst) {\r\nprintk(VIOPATH_KERN_WARN\r\n"message from invalid partition. "\r\n"ack msg rcvd, source inst (%d) doesn't match (%d)\n",\r\nviopathStatus[remoteLp].mSourceInst,\r\nevent->xSourceInstanceId);\r\nreturn;\r\n}\r\nif (event->xTargetInstanceId !=\r\nviopathStatus[remoteLp].mTargetInst) {\r\nprintk(VIOPATH_KERN_WARN\r\n"message from invalid partition. "\r\n"viopath: ack msg rcvd, target inst (%d) doesn't match (%d)\n",\r\nviopathStatus[remoteLp].mTargetInst,\r\nevent->xTargetInstanceId);\r\nreturn;\r\n}\r\n}\r\nif (vio_handler[subtype] == NULL) {\r\nprintk(VIOPATH_KERN_WARN\r\n"unexpected virtual io event subtype %d from partition %d\n",\r\nevent->xSubtype, remoteLp);\r\nif (hvlpevent_is_int(event) && hvlpevent_need_ack(event)) {\r\nevent->xRc = HvLpEvent_Rc_InvalidSubtype;\r\nHvCallEvent_ackLpEvent(event);\r\n}\r\nreturn;\r\n}\r\n(*vio_handler[subtype])(event);\r\n}\r\nstatic void viopath_donealloc(void *parm, int number)\r\n{\r\nstruct alloc_parms *parmsp = parm;\r\nparmsp->number = number;\r\nif (parmsp->used_wait_atomic)\r\natomic_set(&parmsp->wait_atomic, 0);\r\nelse\r\ncomplete(&parmsp->done);\r\n}\r\nstatic int allocateEvents(HvLpIndex remoteLp, int numEvents)\r\n{\r\nstruct alloc_parms parms;\r\nif (system_state != SYSTEM_RUNNING) {\r\nparms.used_wait_atomic = 1;\r\natomic_set(&parms.wait_atomic, 1);\r\n} else {\r\nparms.used_wait_atomic = 0;\r\ninit_completion(&parms.done);\r\n}\r\nmf_allocate_lp_events(remoteLp, HvLpEvent_Type_VirtualIo, 250,\r\nnumEvents, &viopath_donealloc, &parms);\r\nif (system_state != SYSTEM_RUNNING) {\r\nwhile (atomic_read(&parms.wait_atomic))\r\nmb();\r\n} else\r\nwait_for_completion(&parms.done);\r\nreturn parms.number;\r\n}\r\nint viopath_open(HvLpIndex remoteLp, int subtype, int numReq)\r\n{\r\nint i;\r\nunsigned long flags;\r\nint tempNumAllocated;\r\nif ((remoteLp >= HVMAXARCHITECTEDLPS) || (remoteLp == HvLpIndexInvalid))\r\nreturn -EINVAL;\r\nsubtype = subtype >> VIOMAJOR_SUBTYPE_SHIFT;\r\nif ((subtype < 0) || (subtype >= VIO_MAX_SUBTYPES))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&statuslock, flags);\r\nif (!event_buffer_initialised) {\r\nfor (i = 0; i < VIO_MAX_SUBTYPES; i++)\r\natomic_set(&event_buffer_available[i], 1);\r\nevent_buffer_initialised = 1;\r\n}\r\nviopathStatus[remoteLp].users[subtype]++;\r\nif (!viopathStatus[remoteLp].isOpen) {\r\nviopathStatus[remoteLp].isOpen = 1;\r\nHvCallEvent_openLpEventPath(remoteLp, HvLpEvent_Type_VirtualIo);\r\nspin_unlock_irqrestore(&statuslock, flags);\r\ntempNumAllocated = allocateEvents(remoteLp, 1);\r\nspin_lock_irqsave(&statuslock, flags);\r\nviopathStatus[remoteLp].numberAllocated += tempNumAllocated;\r\nif (viopathStatus[remoteLp].numberAllocated == 0) {\r\nHvCallEvent_closeLpEventPath(remoteLp,\r\nHvLpEvent_Type_VirtualIo);\r\nspin_unlock_irqrestore(&statuslock, flags);\r\nreturn -ENOMEM;\r\n}\r\nviopathStatus[remoteLp].mSourceInst =\r\nHvCallEvent_getSourceLpInstanceId(remoteLp,\r\nHvLpEvent_Type_VirtualIo);\r\nviopathStatus[remoteLp].mTargetInst =\r\nHvCallEvent_getTargetLpInstanceId(remoteLp,\r\nHvLpEvent_Type_VirtualIo);\r\nHvLpEvent_registerHandler(HvLpEvent_Type_VirtualIo,\r\n&vio_handleEvent);\r\nsendMonMsg(remoteLp);\r\nprintk(VIOPATH_KERN_INFO "opening connection to partition %d, "\r\n"setting sinst %d, tinst %d\n",\r\nremoteLp, viopathStatus[remoteLp].mSourceInst,\r\nviopathStatus[remoteLp].mTargetInst);\r\n}\r\nspin_unlock_irqrestore(&statuslock, flags);\r\ntempNumAllocated = allocateEvents(remoteLp, numReq);\r\nspin_lock_irqsave(&statuslock, flags);\r\nviopathStatus[remoteLp].numberAllocated += tempNumAllocated;\r\nspin_unlock_irqrestore(&statuslock, flags);\r\nreturn 0;\r\n}\r\nint viopath_close(HvLpIndex remoteLp, int subtype, int numReq)\r\n{\r\nunsigned long flags;\r\nint i;\r\nint numOpen;\r\nstruct alloc_parms parms;\r\nif ((remoteLp >= HVMAXARCHITECTEDLPS) || (remoteLp == HvLpIndexInvalid))\r\nreturn -EINVAL;\r\nsubtype = subtype >> VIOMAJOR_SUBTYPE_SHIFT;\r\nif ((subtype < 0) || (subtype >= VIO_MAX_SUBTYPES))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&statuslock, flags);\r\nif (viopathStatus[remoteLp].users[subtype] > 0)\r\nviopathStatus[remoteLp].users[subtype]--;\r\nspin_unlock_irqrestore(&statuslock, flags);\r\nparms.used_wait_atomic = 0;\r\ninit_completion(&parms.done);\r\nmf_deallocate_lp_events(remoteLp, HvLpEvent_Type_VirtualIo,\r\nnumReq, &viopath_donealloc, &parms);\r\nwait_for_completion(&parms.done);\r\nspin_lock_irqsave(&statuslock, flags);\r\nfor (i = 0, numOpen = 0; i < VIO_MAX_SUBTYPES; i++)\r\nnumOpen += viopathStatus[remoteLp].users[i];\r\nif ((viopathStatus[remoteLp].isOpen) && (numOpen == 0)) {\r\nprintk(VIOPATH_KERN_INFO "closing connection to partition %d\n",\r\nremoteLp);\r\nHvCallEvent_closeLpEventPath(remoteLp,\r\nHvLpEvent_Type_VirtualIo);\r\nviopathStatus[remoteLp].isOpen = 0;\r\nviopathStatus[remoteLp].isActive = 0;\r\nfor (i = 0; i < VIO_MAX_SUBTYPES; i++)\r\natomic_set(&event_buffer_available[i], 0);\r\nevent_buffer_initialised = 0;\r\n}\r\nspin_unlock_irqrestore(&statuslock, flags);\r\nreturn 0;\r\n}\r\nvoid *vio_get_event_buffer(int subtype)\r\n{\r\nsubtype = subtype >> VIOMAJOR_SUBTYPE_SHIFT;\r\nif ((subtype < 0) || (subtype >= VIO_MAX_SUBTYPES))\r\nreturn NULL;\r\nif (atomic_dec_if_positive(&event_buffer_available[subtype]) == 0)\r\nreturn &event_buffer[subtype * 256];\r\nelse\r\nreturn NULL;\r\n}\r\nvoid vio_free_event_buffer(int subtype, void *buffer)\r\n{\r\nsubtype = subtype >> VIOMAJOR_SUBTYPE_SHIFT;\r\nif ((subtype < 0) || (subtype >= VIO_MAX_SUBTYPES)) {\r\nprintk(VIOPATH_KERN_WARN\r\n"unexpected subtype %d freeing event buffer\n", subtype);\r\nreturn;\r\n}\r\nif (atomic_read(&event_buffer_available[subtype]) != 0) {\r\nprintk(VIOPATH_KERN_WARN\r\n"freeing unallocated event buffer, subtype %d\n",\r\nsubtype);\r\nreturn;\r\n}\r\nif (buffer != &event_buffer[subtype * 256]) {\r\nprintk(VIOPATH_KERN_WARN\r\n"freeing invalid event buffer, subtype %d\n", subtype);\r\n}\r\natomic_set(&event_buffer_available[subtype], 1);\r\n}\r\nconst struct vio_error_entry *vio_lookup_rc(\r\nconst struct vio_error_entry *local_table, u16 rc)\r\n{\r\nconst struct vio_error_entry *cur;\r\nif (!rc)\r\nreturn &vio_no_error;\r\nif (local_table)\r\nfor (cur = local_table; cur->rc; ++cur)\r\nif (cur->rc == rc)\r\nreturn cur;\r\nfor (cur = vio_default_errors; cur->rc; ++cur)\r\nif (cur->rc == rc)\r\nreturn cur;\r\nreturn &vio_unknown_error;\r\n}
