static u32\r\nqlcnic_poll_rsp(struct qlcnic_adapter *adapter)\r\n{\r\nu32 rsp;\r\nint timeout = 0;\r\ndo {\r\nmsleep(1);\r\nif (++timeout > QLCNIC_OS_CRB_RETRY_COUNT)\r\nreturn QLCNIC_CDRP_RSP_TIMEOUT;\r\nrsp = QLCRD32(adapter, QLCNIC_CDRP_CRB_OFFSET);\r\n} while (!QLCNIC_CDRP_IS_RSP(rsp));\r\nreturn rsp;\r\n}\r\nvoid\r\nqlcnic_issue_cmd(struct qlcnic_adapter *adapter, struct qlcnic_cmd_args *cmd)\r\n{\r\nu32 rsp;\r\nu32 signature;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nsignature = QLCNIC_CDRP_SIGNATURE_MAKE(ahw->pci_func,\r\nadapter->fw_hal_version);\r\nif (qlcnic_api_lock(adapter)) {\r\ncmd->rsp.cmd = QLCNIC_RCODE_TIMEOUT;\r\nreturn;\r\n}\r\nQLCWR32(adapter, QLCNIC_SIGN_CRB_OFFSET, signature);\r\nQLCWR32(adapter, QLCNIC_ARG1_CRB_OFFSET, cmd->req.arg1);\r\nQLCWR32(adapter, QLCNIC_ARG2_CRB_OFFSET, cmd->req.arg2);\r\nQLCWR32(adapter, QLCNIC_ARG3_CRB_OFFSET, cmd->req.arg3);\r\nQLCWR32(adapter, QLCNIC_CDRP_CRB_OFFSET,\r\nQLCNIC_CDRP_FORM_CMD(cmd->req.cmd));\r\nrsp = qlcnic_poll_rsp(adapter);\r\nif (rsp == QLCNIC_CDRP_RSP_TIMEOUT) {\r\ndev_err(&pdev->dev, "card response timeout.\n");\r\ncmd->rsp.cmd = QLCNIC_RCODE_TIMEOUT;\r\n} else if (rsp == QLCNIC_CDRP_RSP_FAIL) {\r\ncmd->rsp.cmd = QLCRD32(adapter, QLCNIC_ARG1_CRB_OFFSET);\r\ndev_err(&pdev->dev, "failed card response code:0x%x\n",\r\ncmd->rsp.cmd);\r\n} else if (rsp == QLCNIC_CDRP_RSP_OK) {\r\ncmd->rsp.cmd = QLCNIC_RCODE_SUCCESS;\r\nif (cmd->rsp.arg2)\r\ncmd->rsp.arg2 = QLCRD32(adapter,\r\nQLCNIC_ARG2_CRB_OFFSET);\r\nif (cmd->rsp.arg3)\r\ncmd->rsp.arg3 = QLCRD32(adapter,\r\nQLCNIC_ARG3_CRB_OFFSET);\r\n}\r\nif (cmd->rsp.arg1)\r\ncmd->rsp.arg1 = QLCRD32(adapter, QLCNIC_ARG1_CRB_OFFSET);\r\nqlcnic_api_unlock(adapter);\r\n}\r\nstatic uint32_t qlcnic_temp_checksum(uint32_t *temp_buffer, u16 temp_size)\r\n{\r\nuint64_t sum = 0;\r\nint count = temp_size / sizeof(uint32_t);\r\nwhile (count-- > 0)\r\nsum += *temp_buffer++;\r\nwhile (sum >> 32)\r\nsum = (sum & 0xFFFFFFFF) + (sum >> 32);\r\nreturn ~sum;\r\n}\r\nint qlcnic_fw_cmd_get_minidump_temp(struct qlcnic_adapter *adapter)\r\n{\r\nint err, i;\r\nu16 temp_size;\r\nvoid *tmp_addr;\r\nu32 version, csum, *template, *tmp_buf;\r\nstruct qlcnic_cmd_args cmd;\r\nstruct qlcnic_hardware_context *ahw;\r\nstruct qlcnic_dump_template_hdr *tmpl_hdr, *tmp_tmpl;\r\ndma_addr_t tmp_addr_t = 0;\r\nahw = adapter->ahw;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_TEMP_SIZE;\r\nmemset(&cmd.rsp, 1, sizeof(struct _cdrp_cmd));\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nif (cmd.rsp.cmd != QLCNIC_RCODE_SUCCESS) {\r\ndev_info(&adapter->pdev->dev,\r\n"Can't get template size %d\n", cmd.rsp.cmd);\r\nerr = -EIO;\r\nreturn err;\r\n}\r\ntemp_size = cmd.rsp.arg2;\r\nversion = cmd.rsp.arg3;\r\nif (!temp_size)\r\nreturn -EIO;\r\ntmp_addr = dma_alloc_coherent(&adapter->pdev->dev, temp_size,\r\n&tmp_addr_t, GFP_KERNEL);\r\nif (!tmp_addr) {\r\ndev_err(&adapter->pdev->dev,\r\n"Can't get memory for FW dump template\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(&cmd.rsp, 0, sizeof(struct _cdrp_cmd));\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_GET_TEMP_HDR;\r\ncmd.req.arg1 = LSD(tmp_addr_t);\r\ncmd.req.arg2 = MSD(tmp_addr_t);\r\ncmd.req.arg3 = temp_size;\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nerr = cmd.rsp.cmd;\r\nif (err != QLCNIC_RCODE_SUCCESS) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to get mini dump template header %d\n", err);\r\nerr = -EIO;\r\ngoto error;\r\n}\r\ntmp_tmpl = tmp_addr;\r\ncsum = qlcnic_temp_checksum((uint32_t *) tmp_addr, temp_size);\r\nif (csum) {\r\ndev_err(&adapter->pdev->dev,\r\n"Template header checksum validation failed\n");\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nahw->fw_dump.tmpl_hdr = vzalloc(temp_size);\r\nif (!ahw->fw_dump.tmpl_hdr) {\r\nerr = -EIO;\r\ngoto error;\r\n}\r\ntmp_buf = tmp_addr;\r\ntemplate = (u32 *) ahw->fw_dump.tmpl_hdr;\r\nfor (i = 0; i < temp_size/sizeof(u32); i++)\r\n*template++ = __le32_to_cpu(*tmp_buf++);\r\ntmpl_hdr = ahw->fw_dump.tmpl_hdr;\r\ntmpl_hdr->drv_cap_mask = QLCNIC_DUMP_MASK_DEF;\r\nahw->fw_dump.enable = 1;\r\nerror:\r\ndma_free_coherent(&adapter->pdev->dev, temp_size, tmp_addr, tmp_addr_t);\r\nreturn err;\r\n}\r\nint\r\nqlcnic_fw_cmd_set_mtu(struct qlcnic_adapter *adapter, int mtu)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_SET_MTU;\r\ncmd.req.arg1 = recv_ctx->context_id;\r\ncmd.req.arg2 = mtu;\r\ncmd.req.arg3 = 0;\r\nif (recv_ctx->state == QLCNIC_HOST_CTX_STATE_ACTIVE) {\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nif (cmd.rsp.cmd) {\r\ndev_err(&adapter->pdev->dev, "Failed to set mtu\n");\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_fw_cmd_create_rx_ctx(struct qlcnic_adapter *adapter)\r\n{\r\nvoid *addr;\r\nstruct qlcnic_hostrq_rx_ctx *prq;\r\nstruct qlcnic_cardrsp_rx_ctx *prsp;\r\nstruct qlcnic_hostrq_rds_ring *prq_rds;\r\nstruct qlcnic_hostrq_sds_ring *prq_sds;\r\nstruct qlcnic_cardrsp_rds_ring *prsp_rds;\r\nstruct qlcnic_cardrsp_sds_ring *prsp_sds;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_cmd_args cmd;\r\ndma_addr_t hostrq_phys_addr, cardrsp_phys_addr;\r\nu64 phys_addr;\r\nu8 i, nrds_rings, nsds_rings;\r\nsize_t rq_size, rsp_size;\r\nu32 cap, reg, val, reg2;\r\nint err;\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nnrds_rings = adapter->max_rds_rings;\r\nnsds_rings = adapter->max_sds_rings;\r\nrq_size =\r\nSIZEOF_HOSTRQ_RX(struct qlcnic_hostrq_rx_ctx, nrds_rings,\r\nnsds_rings);\r\nrsp_size =\r\nSIZEOF_CARDRSP_RX(struct qlcnic_cardrsp_rx_ctx, nrds_rings,\r\nnsds_rings);\r\naddr = dma_alloc_coherent(&adapter->pdev->dev, rq_size,\r\n&hostrq_phys_addr, GFP_KERNEL);\r\nif (addr == NULL)\r\nreturn -ENOMEM;\r\nprq = addr;\r\naddr = dma_alloc_coherent(&adapter->pdev->dev, rsp_size,\r\n&cardrsp_phys_addr, GFP_KERNEL);\r\nif (addr == NULL) {\r\nerr = -ENOMEM;\r\ngoto out_free_rq;\r\n}\r\nprsp = addr;\r\nprq->host_rsp_dma_addr = cpu_to_le64(cardrsp_phys_addr);\r\ncap = (QLCNIC_CAP0_LEGACY_CONTEXT | QLCNIC_CAP0_LEGACY_MN\r\n| QLCNIC_CAP0_VALIDOFF);\r\ncap |= (QLCNIC_CAP0_JUMBO_CONTIGUOUS | QLCNIC_CAP0_LRO_CONTIGUOUS);\r\nprq->valid_field_offset = offsetof(struct qlcnic_hostrq_rx_ctx,\r\nmsix_handler);\r\nprq->txrx_sds_binding = nsds_rings - 1;\r\nprq->capabilities[0] = cpu_to_le32(cap);\r\nprq->host_int_crb_mode =\r\ncpu_to_le32(QLCNIC_HOST_INT_CRB_MODE_SHARED);\r\nprq->host_rds_crb_mode =\r\ncpu_to_le32(QLCNIC_HOST_RDS_CRB_MODE_UNIQUE);\r\nprq->num_rds_rings = cpu_to_le16(nrds_rings);\r\nprq->num_sds_rings = cpu_to_le16(nsds_rings);\r\nprq->rds_ring_offset = 0;\r\nval = le32_to_cpu(prq->rds_ring_offset) +\r\n(sizeof(struct qlcnic_hostrq_rds_ring) * nrds_rings);\r\nprq->sds_ring_offset = cpu_to_le32(val);\r\nprq_rds = (struct qlcnic_hostrq_rds_ring *)(prq->data +\r\nle32_to_cpu(prq->rds_ring_offset));\r\nfor (i = 0; i < nrds_rings; i++) {\r\nrds_ring = &recv_ctx->rds_rings[i];\r\nrds_ring->producer = 0;\r\nprq_rds[i].host_phys_addr = cpu_to_le64(rds_ring->phys_addr);\r\nprq_rds[i].ring_size = cpu_to_le32(rds_ring->num_desc);\r\nprq_rds[i].ring_kind = cpu_to_le32(i);\r\nprq_rds[i].buff_size = cpu_to_le64(rds_ring->dma_size);\r\n}\r\nprq_sds = (struct qlcnic_hostrq_sds_ring *)(prq->data +\r\nle32_to_cpu(prq->sds_ring_offset));\r\nfor (i = 0; i < nsds_rings; i++) {\r\nsds_ring = &recv_ctx->sds_rings[i];\r\nsds_ring->consumer = 0;\r\nmemset(sds_ring->desc_head, 0, STATUS_DESC_RINGSIZE(sds_ring));\r\nprq_sds[i].host_phys_addr = cpu_to_le64(sds_ring->phys_addr);\r\nprq_sds[i].ring_size = cpu_to_le32(sds_ring->num_desc);\r\nprq_sds[i].msi_index = cpu_to_le16(i);\r\n}\r\nphys_addr = hostrq_phys_addr;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.arg1 = (u32) (phys_addr >> 32);\r\ncmd.req.arg2 = (u32) (phys_addr & 0xffffffff);\r\ncmd.req.arg3 = rq_size;\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_CREATE_RX_CTX;\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nerr = cmd.rsp.cmd;\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to create rx ctx in firmware%d\n", err);\r\ngoto out_free_rsp;\r\n}\r\nprsp_rds = ((struct qlcnic_cardrsp_rds_ring *)\r\n&prsp->data[le32_to_cpu(prsp->rds_ring_offset)]);\r\nfor (i = 0; i < le16_to_cpu(prsp->num_rds_rings); i++) {\r\nrds_ring = &recv_ctx->rds_rings[i];\r\nreg = le32_to_cpu(prsp_rds[i].host_producer_crb);\r\nrds_ring->crb_rcv_producer = adapter->ahw->pci_base0 + reg;\r\n}\r\nprsp_sds = ((struct qlcnic_cardrsp_sds_ring *)\r\n&prsp->data[le32_to_cpu(prsp->sds_ring_offset)]);\r\nfor (i = 0; i < le16_to_cpu(prsp->num_sds_rings); i++) {\r\nsds_ring = &recv_ctx->sds_rings[i];\r\nreg = le32_to_cpu(prsp_sds[i].host_consumer_crb);\r\nreg2 = le32_to_cpu(prsp_sds[i].interrupt_crb);\r\nsds_ring->crb_sts_consumer = adapter->ahw->pci_base0 + reg;\r\nsds_ring->crb_intr_mask = adapter->ahw->pci_base0 + reg2;\r\n}\r\nrecv_ctx->state = le32_to_cpu(prsp->host_ctx_state);\r\nrecv_ctx->context_id = le16_to_cpu(prsp->context_id);\r\nrecv_ctx->virt_port = prsp->virt_port;\r\nout_free_rsp:\r\ndma_free_coherent(&adapter->pdev->dev, rsp_size, prsp,\r\ncardrsp_phys_addr);\r\nout_free_rq:\r\ndma_free_coherent(&adapter->pdev->dev, rq_size, prq, hostrq_phys_addr);\r\nreturn err;\r\n}\r\nstatic void\r\nqlcnic_fw_cmd_destroy_rx_ctx(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.arg1 = recv_ctx->context_id;\r\ncmd.req.arg2 = QLCNIC_DESTROY_CTX_RESET;\r\ncmd.req.arg3 = 0;\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_DESTROY_RX_CTX;\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nif (cmd.rsp.cmd)\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to destroy rx ctx in firmware\n");\r\nrecv_ctx->state = QLCNIC_HOST_CTX_STATE_FREED;\r\n}\r\nstatic int\r\nqlcnic_fw_cmd_create_tx_ctx(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hostrq_tx_ctx *prq;\r\nstruct qlcnic_hostrq_cds_ring *prq_cds;\r\nstruct qlcnic_cardrsp_tx_ctx *prsp;\r\nvoid *rq_addr, *rsp_addr;\r\nsize_t rq_size, rsp_size;\r\nu32 temp;\r\nstruct qlcnic_cmd_args cmd;\r\nint err;\r\nu64 phys_addr;\r\ndma_addr_t rq_phys_addr, rsp_phys_addr;\r\nstruct qlcnic_host_tx_ring *tx_ring = adapter->tx_ring;\r\ntx_ring->producer = 0;\r\ntx_ring->sw_consumer = 0;\r\n*(tx_ring->hw_consumer) = 0;\r\nrq_size = SIZEOF_HOSTRQ_TX(struct qlcnic_hostrq_tx_ctx);\r\nrq_addr = dma_alloc_coherent(&adapter->pdev->dev, rq_size,\r\n&rq_phys_addr, GFP_KERNEL);\r\nif (!rq_addr)\r\nreturn -ENOMEM;\r\nrsp_size = SIZEOF_CARDRSP_TX(struct qlcnic_cardrsp_tx_ctx);\r\nrsp_addr = dma_alloc_coherent(&adapter->pdev->dev, rsp_size,\r\n&rsp_phys_addr, GFP_KERNEL);\r\nif (!rsp_addr) {\r\nerr = -ENOMEM;\r\ngoto out_free_rq;\r\n}\r\nmemset(rq_addr, 0, rq_size);\r\nprq = rq_addr;\r\nmemset(rsp_addr, 0, rsp_size);\r\nprsp = rsp_addr;\r\nprq->host_rsp_dma_addr = cpu_to_le64(rsp_phys_addr);\r\ntemp = (QLCNIC_CAP0_LEGACY_CONTEXT | QLCNIC_CAP0_LEGACY_MN |\r\nQLCNIC_CAP0_LSO);\r\nprq->capabilities[0] = cpu_to_le32(temp);\r\nprq->host_int_crb_mode =\r\ncpu_to_le32(QLCNIC_HOST_INT_CRB_MODE_SHARED);\r\nprq->interrupt_ctl = 0;\r\nprq->msi_index = 0;\r\nprq->cmd_cons_dma_addr = cpu_to_le64(tx_ring->hw_cons_phys_addr);\r\nprq_cds = &prq->cds_ring;\r\nprq_cds->host_phys_addr = cpu_to_le64(tx_ring->phys_addr);\r\nprq_cds->ring_size = cpu_to_le32(tx_ring->num_desc);\r\nphys_addr = rq_phys_addr;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.arg1 = (u32)(phys_addr >> 32);\r\ncmd.req.arg2 = ((u32)phys_addr & 0xffffffff);\r\ncmd.req.arg3 = rq_size;\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_CREATE_TX_CTX;\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nerr = cmd.rsp.cmd;\r\nif (err == QLCNIC_RCODE_SUCCESS) {\r\ntemp = le32_to_cpu(prsp->cds_ring.host_producer_crb);\r\ntx_ring->crb_cmd_producer = adapter->ahw->pci_base0 + temp;\r\nadapter->tx_context_id =\r\nle16_to_cpu(prsp->context_id);\r\n} else {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to create tx ctx in firmware%d\n", err);\r\nerr = -EIO;\r\n}\r\ndma_free_coherent(&adapter->pdev->dev, rsp_size, rsp_addr,\r\nrsp_phys_addr);\r\nout_free_rq:\r\ndma_free_coherent(&adapter->pdev->dev, rq_size, rq_addr, rq_phys_addr);\r\nreturn err;\r\n}\r\nstatic void\r\nqlcnic_fw_cmd_destroy_tx_ctx(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.arg1 = adapter->tx_context_id;\r\ncmd.req.arg2 = QLCNIC_DESTROY_CTX_RESET;\r\ncmd.req.arg3 = 0;\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_DESTROY_TX_CTX;\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nif (cmd.rsp.cmd)\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to destroy tx ctx in firmware\n");\r\n}\r\nint\r\nqlcnic_fw_cmd_set_port(struct qlcnic_adapter *adapter, u32 config)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.arg1 = config;\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_CONFIG_PORT;\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nreturn cmd.rsp.cmd;\r\n}\r\nint qlcnic_alloc_hw_resources(struct qlcnic_adapter *adapter)\r\n{\r\nvoid *addr;\r\nint err;\r\nint ring;\r\nstruct qlcnic_recv_context *recv_ctx;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nrecv_ctx = adapter->recv_ctx;\r\ntx_ring = adapter->tx_ring;\r\ntx_ring->hw_consumer = (__le32 *) dma_alloc_coherent(&pdev->dev,\r\nsizeof(u32), &tx_ring->hw_cons_phys_addr, GFP_KERNEL);\r\nif (tx_ring->hw_consumer == NULL) {\r\ndev_err(&pdev->dev, "failed to allocate tx consumer\n");\r\nreturn -ENOMEM;\r\n}\r\naddr = dma_alloc_coherent(&pdev->dev, TX_DESC_RINGSIZE(tx_ring),\r\n&tx_ring->phys_addr, GFP_KERNEL);\r\nif (addr == NULL) {\r\ndev_err(&pdev->dev, "failed to allocate tx desc ring\n");\r\nerr = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\ntx_ring->desc_head = addr;\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\naddr = dma_alloc_coherent(&adapter->pdev->dev,\r\nRCV_DESC_RINGSIZE(rds_ring),\r\n&rds_ring->phys_addr, GFP_KERNEL);\r\nif (addr == NULL) {\r\ndev_err(&pdev->dev,\r\n"failed to allocate rds ring [%d]\n", ring);\r\nerr = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\nrds_ring->desc_head = addr;\r\n}\r\nfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\naddr = dma_alloc_coherent(&adapter->pdev->dev,\r\nSTATUS_DESC_RINGSIZE(sds_ring),\r\n&sds_ring->phys_addr, GFP_KERNEL);\r\nif (addr == NULL) {\r\ndev_err(&pdev->dev,\r\n"failed to allocate sds ring [%d]\n", ring);\r\nerr = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\nsds_ring->desc_head = addr;\r\n}\r\nreturn 0;\r\nerr_out_free:\r\nqlcnic_free_hw_resources(adapter);\r\nreturn err;\r\n}\r\nint qlcnic_fw_create_ctx(struct qlcnic_adapter *adapter)\r\n{\r\nint err;\r\nif (adapter->flags & QLCNIC_NEED_FLR) {\r\npci_reset_function(adapter->pdev);\r\nadapter->flags &= ~QLCNIC_NEED_FLR;\r\n}\r\nerr = qlcnic_fw_cmd_create_rx_ctx(adapter);\r\nif (err)\r\nreturn err;\r\nerr = qlcnic_fw_cmd_create_tx_ctx(adapter);\r\nif (err) {\r\nqlcnic_fw_cmd_destroy_rx_ctx(adapter);\r\nreturn err;\r\n}\r\nset_bit(__QLCNIC_FW_ATTACHED, &adapter->state);\r\nreturn 0;\r\n}\r\nvoid qlcnic_fw_destroy_ctx(struct qlcnic_adapter *adapter)\r\n{\r\nif (test_and_clear_bit(__QLCNIC_FW_ATTACHED, &adapter->state)) {\r\nqlcnic_fw_cmd_destroy_rx_ctx(adapter);\r\nqlcnic_fw_cmd_destroy_tx_ctx(adapter);\r\nmsleep(20);\r\n}\r\n}\r\nvoid qlcnic_free_hw_resources(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_recv_context *recv_ctx;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\nint ring;\r\nrecv_ctx = adapter->recv_ctx;\r\ntx_ring = adapter->tx_ring;\r\nif (tx_ring->hw_consumer != NULL) {\r\ndma_free_coherent(&adapter->pdev->dev,\r\nsizeof(u32),\r\ntx_ring->hw_consumer,\r\ntx_ring->hw_cons_phys_addr);\r\ntx_ring->hw_consumer = NULL;\r\n}\r\nif (tx_ring->desc_head != NULL) {\r\ndma_free_coherent(&adapter->pdev->dev,\r\nTX_DESC_RINGSIZE(tx_ring),\r\ntx_ring->desc_head, tx_ring->phys_addr);\r\ntx_ring->desc_head = NULL;\r\n}\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nif (rds_ring->desc_head != NULL) {\r\ndma_free_coherent(&adapter->pdev->dev,\r\nRCV_DESC_RINGSIZE(rds_ring),\r\nrds_ring->desc_head,\r\nrds_ring->phys_addr);\r\nrds_ring->desc_head = NULL;\r\n}\r\n}\r\nfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nif (sds_ring->desc_head != NULL) {\r\ndma_free_coherent(&adapter->pdev->dev,\r\nSTATUS_DESC_RINGSIZE(sds_ring),\r\nsds_ring->desc_head,\r\nsds_ring->phys_addr);\r\nsds_ring->desc_head = NULL;\r\n}\r\n}\r\n}\r\nint qlcnic_get_mac_address(struct qlcnic_adapter *adapter, u8 *mac)\r\n{\r\nint err;\r\nstruct qlcnic_cmd_args cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.arg1 = adapter->ahw->pci_func | BIT_8;\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_MAC_ADDRESS;\r\ncmd.rsp.arg1 = cmd.rsp.arg2 = 1;\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nerr = cmd.rsp.cmd;\r\nif (err == QLCNIC_RCODE_SUCCESS)\r\nqlcnic_fetch_mac(adapter, cmd.rsp.arg1, cmd.rsp.arg2, 0, mac);\r\nelse {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to get mac address%d\n", err);\r\nerr = -EIO;\r\n}\r\nreturn err;\r\n}\r\nint qlcnic_get_nic_info(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_info *npar_info, u8 func_id)\r\n{\r\nint err;\r\ndma_addr_t nic_dma_t;\r\nstruct qlcnic_info *nic_info;\r\nvoid *nic_info_addr;\r\nstruct qlcnic_cmd_args cmd;\r\nsize_t nic_size = sizeof(struct qlcnic_info);\r\nnic_info_addr = dma_alloc_coherent(&adapter->pdev->dev, nic_size,\r\n&nic_dma_t, GFP_KERNEL);\r\nif (!nic_info_addr)\r\nreturn -ENOMEM;\r\nmemset(nic_info_addr, 0, nic_size);\r\nnic_info = nic_info_addr;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_GET_NIC_INFO;\r\ncmd.req.arg1 = MSD(nic_dma_t);\r\ncmd.req.arg2 = LSD(nic_dma_t);\r\ncmd.req.arg3 = (func_id << 16 | nic_size);\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nerr = cmd.rsp.cmd;\r\nif (err == QLCNIC_RCODE_SUCCESS) {\r\nnpar_info->pci_func = le16_to_cpu(nic_info->pci_func);\r\nnpar_info->op_mode = le16_to_cpu(nic_info->op_mode);\r\nnpar_info->phys_port = le16_to_cpu(nic_info->phys_port);\r\nnpar_info->switch_mode = le16_to_cpu(nic_info->switch_mode);\r\nnpar_info->max_tx_ques = le16_to_cpu(nic_info->max_tx_ques);\r\nnpar_info->max_rx_ques = le16_to_cpu(nic_info->max_rx_ques);\r\nnpar_info->min_tx_bw = le16_to_cpu(nic_info->min_tx_bw);\r\nnpar_info->max_tx_bw = le16_to_cpu(nic_info->max_tx_bw);\r\nnpar_info->capabilities = le32_to_cpu(nic_info->capabilities);\r\nnpar_info->max_mtu = le16_to_cpu(nic_info->max_mtu);\r\ndev_info(&adapter->pdev->dev,\r\n"phy port: %d switch_mode: %d,\n"\r\n"\tmax_tx_q: %d max_rx_q: %d min_tx_bw: 0x%x,\n"\r\n"\tmax_tx_bw: 0x%x max_mtu:0x%x, capabilities: 0x%x\n",\r\nnpar_info->phys_port, npar_info->switch_mode,\r\nnpar_info->max_tx_ques, npar_info->max_rx_ques,\r\nnpar_info->min_tx_bw, npar_info->max_tx_bw,\r\nnpar_info->max_mtu, npar_info->capabilities);\r\n} else {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to get nic info%d\n", err);\r\nerr = -EIO;\r\n}\r\ndma_free_coherent(&adapter->pdev->dev, nic_size, nic_info_addr,\r\nnic_dma_t);\r\nreturn err;\r\n}\r\nint qlcnic_set_nic_info(struct qlcnic_adapter *adapter, struct qlcnic_info *nic)\r\n{\r\nint err = -EIO;\r\ndma_addr_t nic_dma_t;\r\nvoid *nic_info_addr;\r\nstruct qlcnic_cmd_args cmd;\r\nstruct qlcnic_info *nic_info;\r\nsize_t nic_size = sizeof(struct qlcnic_info);\r\nif (adapter->op_mode != QLCNIC_MGMT_FUNC)\r\nreturn err;\r\nnic_info_addr = dma_alloc_coherent(&adapter->pdev->dev, nic_size,\r\n&nic_dma_t, GFP_KERNEL);\r\nif (!nic_info_addr)\r\nreturn -ENOMEM;\r\nmemset(nic_info_addr, 0, nic_size);\r\nnic_info = nic_info_addr;\r\nnic_info->pci_func = cpu_to_le16(nic->pci_func);\r\nnic_info->op_mode = cpu_to_le16(nic->op_mode);\r\nnic_info->phys_port = cpu_to_le16(nic->phys_port);\r\nnic_info->switch_mode = cpu_to_le16(nic->switch_mode);\r\nnic_info->capabilities = cpu_to_le32(nic->capabilities);\r\nnic_info->max_mac_filters = nic->max_mac_filters;\r\nnic_info->max_tx_ques = cpu_to_le16(nic->max_tx_ques);\r\nnic_info->max_rx_ques = cpu_to_le16(nic->max_rx_ques);\r\nnic_info->min_tx_bw = cpu_to_le16(nic->min_tx_bw);\r\nnic_info->max_tx_bw = cpu_to_le16(nic->max_tx_bw);\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_SET_NIC_INFO;\r\ncmd.req.arg1 = MSD(nic_dma_t);\r\ncmd.req.arg2 = LSD(nic_dma_t);\r\ncmd.req.arg3 = ((nic->pci_func << 16) | nic_size);\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nerr = cmd.rsp.cmd;\r\nif (err != QLCNIC_RCODE_SUCCESS) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to set nic info%d\n", err);\r\nerr = -EIO;\r\n}\r\ndma_free_coherent(&adapter->pdev->dev, nic_size, nic_info_addr,\r\nnic_dma_t);\r\nreturn err;\r\n}\r\nint qlcnic_get_pci_info(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_pci_info *pci_info)\r\n{\r\nint err = 0, i;\r\nstruct qlcnic_cmd_args cmd;\r\ndma_addr_t pci_info_dma_t;\r\nstruct qlcnic_pci_info *npar;\r\nvoid *pci_info_addr;\r\nsize_t npar_size = sizeof(struct qlcnic_pci_info);\r\nsize_t pci_size = npar_size * QLCNIC_MAX_PCI_FUNC;\r\npci_info_addr = dma_alloc_coherent(&adapter->pdev->dev, pci_size,\r\n&pci_info_dma_t, GFP_KERNEL);\r\nif (!pci_info_addr)\r\nreturn -ENOMEM;\r\nmemset(pci_info_addr, 0, pci_size);\r\nnpar = pci_info_addr;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_GET_PCI_INFO;\r\ncmd.req.arg1 = MSD(pci_info_dma_t);\r\ncmd.req.arg2 = LSD(pci_info_dma_t);\r\ncmd.req.arg3 = pci_size;\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nerr = cmd.rsp.cmd;\r\nif (err == QLCNIC_RCODE_SUCCESS) {\r\nfor (i = 0; i < QLCNIC_MAX_PCI_FUNC; i++, npar++, pci_info++) {\r\npci_info->id = le16_to_cpu(npar->id);\r\npci_info->active = le16_to_cpu(npar->active);\r\npci_info->type = le16_to_cpu(npar->type);\r\npci_info->default_port =\r\nle16_to_cpu(npar->default_port);\r\npci_info->tx_min_bw =\r\nle16_to_cpu(npar->tx_min_bw);\r\npci_info->tx_max_bw =\r\nle16_to_cpu(npar->tx_max_bw);\r\nmemcpy(pci_info->mac, npar->mac, ETH_ALEN);\r\n}\r\n} else {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to get PCI Info%d\n", err);\r\nerr = -EIO;\r\n}\r\ndma_free_coherent(&adapter->pdev->dev, pci_size, pci_info_addr,\r\npci_info_dma_t);\r\nreturn err;\r\n}\r\nint qlcnic_config_port_mirroring(struct qlcnic_adapter *adapter, u8 id,\r\nu8 enable_mirroring, u8 pci_func)\r\n{\r\nint err = -EIO;\r\nu32 arg1;\r\nstruct qlcnic_cmd_args cmd;\r\nif (adapter->op_mode != QLCNIC_MGMT_FUNC ||\r\n!(adapter->eswitch[id].flags & QLCNIC_SWITCH_ENABLE))\r\nreturn err;\r\narg1 = id | (enable_mirroring ? BIT_4 : 0);\r\narg1 |= pci_func << 8;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_SET_PORTMIRRORING;\r\ncmd.req.arg1 = arg1;\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nerr = cmd.rsp.cmd;\r\nif (err != QLCNIC_RCODE_SUCCESS) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to configure port mirroring%d on eswitch:%d\n",\r\npci_func, id);\r\n} else {\r\ndev_info(&adapter->pdev->dev,\r\n"Configured eSwitch %d for port mirroring:%d\n",\r\nid, pci_func);\r\n}\r\nreturn err;\r\n}\r\nint qlcnic_get_port_stats(struct qlcnic_adapter *adapter, const u8 func,\r\nconst u8 rx_tx, struct __qlcnic_esw_statistics *esw_stats) {\r\nsize_t stats_size = sizeof(struct __qlcnic_esw_statistics);\r\nstruct __qlcnic_esw_statistics *stats;\r\ndma_addr_t stats_dma_t;\r\nvoid *stats_addr;\r\nu32 arg1;\r\nstruct qlcnic_cmd_args cmd;\r\nint err;\r\nif (esw_stats == NULL)\r\nreturn -ENOMEM;\r\nif (adapter->op_mode != QLCNIC_MGMT_FUNC &&\r\nfunc != adapter->ahw->pci_func) {\r\ndev_err(&adapter->pdev->dev,\r\n"Not privilege to query stats for func=%d", func);\r\nreturn -EIO;\r\n}\r\nstats_addr = dma_alloc_coherent(&adapter->pdev->dev, stats_size,\r\n&stats_dma_t, GFP_KERNEL);\r\nif (!stats_addr) {\r\ndev_err(&adapter->pdev->dev, "Unable to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(stats_addr, 0, stats_size);\r\narg1 = func | QLCNIC_STATS_VERSION << 8 | QLCNIC_STATS_PORT << 12;\r\narg1 |= rx_tx << 15 | stats_size << 16;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_GET_ESWITCH_STATS;\r\ncmd.req.arg1 = arg1;\r\ncmd.req.arg2 = MSD(stats_dma_t);\r\ncmd.req.arg3 = LSD(stats_dma_t);\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nerr = cmd.rsp.cmd;\r\nif (!err) {\r\nstats = stats_addr;\r\nesw_stats->context_id = le16_to_cpu(stats->context_id);\r\nesw_stats->version = le16_to_cpu(stats->version);\r\nesw_stats->size = le16_to_cpu(stats->size);\r\nesw_stats->multicast_frames =\r\nle64_to_cpu(stats->multicast_frames);\r\nesw_stats->broadcast_frames =\r\nle64_to_cpu(stats->broadcast_frames);\r\nesw_stats->unicast_frames = le64_to_cpu(stats->unicast_frames);\r\nesw_stats->dropped_frames = le64_to_cpu(stats->dropped_frames);\r\nesw_stats->local_frames = le64_to_cpu(stats->local_frames);\r\nesw_stats->errors = le64_to_cpu(stats->errors);\r\nesw_stats->numbytes = le64_to_cpu(stats->numbytes);\r\n}\r\ndma_free_coherent(&adapter->pdev->dev, stats_size, stats_addr,\r\nstats_dma_t);\r\nreturn err;\r\n}\r\nint qlcnic_get_eswitch_stats(struct qlcnic_adapter *adapter, const u8 eswitch,\r\nconst u8 rx_tx, struct __qlcnic_esw_statistics *esw_stats) {\r\nstruct __qlcnic_esw_statistics port_stats;\r\nu8 i;\r\nint ret = -EIO;\r\nif (esw_stats == NULL)\r\nreturn -ENOMEM;\r\nif (adapter->op_mode != QLCNIC_MGMT_FUNC)\r\nreturn -EIO;\r\nif (adapter->npars == NULL)\r\nreturn -EIO;\r\nmemset(esw_stats, 0, sizeof(u64));\r\nesw_stats->unicast_frames = QLCNIC_ESW_STATS_NOT_AVAIL;\r\nesw_stats->multicast_frames = QLCNIC_ESW_STATS_NOT_AVAIL;\r\nesw_stats->broadcast_frames = QLCNIC_ESW_STATS_NOT_AVAIL;\r\nesw_stats->dropped_frames = QLCNIC_ESW_STATS_NOT_AVAIL;\r\nesw_stats->errors = QLCNIC_ESW_STATS_NOT_AVAIL;\r\nesw_stats->local_frames = QLCNIC_ESW_STATS_NOT_AVAIL;\r\nesw_stats->numbytes = QLCNIC_ESW_STATS_NOT_AVAIL;\r\nesw_stats->context_id = eswitch;\r\nfor (i = 0; i < QLCNIC_MAX_PCI_FUNC; i++) {\r\nif (adapter->npars[i].phy_port != eswitch)\r\ncontinue;\r\nmemset(&port_stats, 0, sizeof(struct __qlcnic_esw_statistics));\r\nif (qlcnic_get_port_stats(adapter, i, rx_tx, &port_stats))\r\ncontinue;\r\nesw_stats->size = port_stats.size;\r\nesw_stats->version = port_stats.version;\r\nQLCNIC_ADD_ESW_STATS(esw_stats->unicast_frames,\r\nport_stats.unicast_frames);\r\nQLCNIC_ADD_ESW_STATS(esw_stats->multicast_frames,\r\nport_stats.multicast_frames);\r\nQLCNIC_ADD_ESW_STATS(esw_stats->broadcast_frames,\r\nport_stats.broadcast_frames);\r\nQLCNIC_ADD_ESW_STATS(esw_stats->dropped_frames,\r\nport_stats.dropped_frames);\r\nQLCNIC_ADD_ESW_STATS(esw_stats->errors,\r\nport_stats.errors);\r\nQLCNIC_ADD_ESW_STATS(esw_stats->local_frames,\r\nport_stats.local_frames);\r\nQLCNIC_ADD_ESW_STATS(esw_stats->numbytes,\r\nport_stats.numbytes);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nint qlcnic_clear_esw_stats(struct qlcnic_adapter *adapter, const u8 func_esw,\r\nconst u8 port, const u8 rx_tx)\r\n{\r\nu32 arg1;\r\nstruct qlcnic_cmd_args cmd;\r\nif (adapter->op_mode != QLCNIC_MGMT_FUNC)\r\nreturn -EIO;\r\nif (func_esw == QLCNIC_STATS_PORT) {\r\nif (port >= QLCNIC_MAX_PCI_FUNC)\r\ngoto err_ret;\r\n} else if (func_esw == QLCNIC_STATS_ESWITCH) {\r\nif (port >= QLCNIC_NIU_MAX_XG_PORTS)\r\ngoto err_ret;\r\n} else {\r\ngoto err_ret;\r\n}\r\nif (rx_tx > QLCNIC_QUERY_TX_COUNTER)\r\ngoto err_ret;\r\narg1 = port | QLCNIC_STATS_VERSION << 8 | func_esw << 12;\r\narg1 |= BIT_14 | rx_tx << 15;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_GET_ESWITCH_STATS;\r\ncmd.req.arg1 = arg1;\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nreturn cmd.rsp.cmd;\r\nerr_ret:\r\ndev_err(&adapter->pdev->dev, "Invalid argument func_esw=%d port=%d"\r\n"rx_ctx=%d\n", func_esw, port, rx_tx);\r\nreturn -EIO;\r\n}\r\nstatic int\r\n__qlcnic_get_eswitch_port_config(struct qlcnic_adapter *adapter,\r\nu32 *arg1, u32 *arg2)\r\n{\r\nint err = -EIO;\r\nstruct qlcnic_cmd_args cmd;\r\nu8 pci_func;\r\npci_func = (*arg1 >> 8);\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_GET_ESWITCH_PORT_CONFIG;\r\ncmd.req.arg1 = *arg1;\r\ncmd.rsp.arg1 = cmd.rsp.arg2 = 1;\r\nqlcnic_issue_cmd(adapter, &cmd);\r\n*arg1 = cmd.rsp.arg1;\r\n*arg2 = cmd.rsp.arg2;\r\nerr = cmd.rsp.cmd;\r\nif (err == QLCNIC_RCODE_SUCCESS) {\r\ndev_info(&adapter->pdev->dev,\r\n"eSwitch port config for pci func %d\n", pci_func);\r\n} else {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to get eswitch port config for pci func %d\n",\r\npci_func);\r\n}\r\nreturn err;\r\n}\r\nint qlcnic_config_switch_port(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_esw_func_cfg *esw_cfg)\r\n{\r\nint err = -EIO;\r\nu32 arg1, arg2 = 0;\r\nstruct qlcnic_cmd_args cmd;\r\nu8 pci_func;\r\nif (adapter->op_mode != QLCNIC_MGMT_FUNC)\r\nreturn err;\r\npci_func = esw_cfg->pci_func;\r\narg1 = (adapter->npars[pci_func].phy_port & BIT_0);\r\narg1 |= (pci_func << 8);\r\nif (__qlcnic_get_eswitch_port_config(adapter, &arg1, &arg2))\r\nreturn err;\r\narg1 &= ~(0x0ff << 8);\r\narg1 |= (pci_func << 8);\r\narg1 &= ~(BIT_2 | BIT_3);\r\nswitch (esw_cfg->op_mode) {\r\ncase QLCNIC_PORT_DEFAULTS:\r\narg1 |= (BIT_4 | BIT_6 | BIT_7);\r\narg2 |= (BIT_0 | BIT_1);\r\nif (adapter->capabilities & QLCNIC_FW_CAPABILITY_TSO)\r\narg2 |= (BIT_2 | BIT_3);\r\nif (!(esw_cfg->discard_tagged))\r\narg1 &= ~BIT_4;\r\nif (!(esw_cfg->promisc_mode))\r\narg1 &= ~BIT_6;\r\nif (!(esw_cfg->mac_override))\r\narg1 &= ~BIT_7;\r\nif (!(esw_cfg->mac_anti_spoof))\r\narg2 &= ~BIT_0;\r\nif (!(esw_cfg->offload_flags & BIT_0))\r\narg2 &= ~(BIT_1 | BIT_2 | BIT_3);\r\nif (!(esw_cfg->offload_flags & BIT_1))\r\narg2 &= ~BIT_2;\r\nif (!(esw_cfg->offload_flags & BIT_2))\r\narg2 &= ~BIT_3;\r\nbreak;\r\ncase QLCNIC_ADD_VLAN:\r\narg1 |= (BIT_2 | BIT_5);\r\narg1 |= (esw_cfg->vlan_id << 16);\r\nbreak;\r\ncase QLCNIC_DEL_VLAN:\r\narg1 |= (BIT_3 | BIT_5);\r\narg1 &= ~(0x0ffff << 16);\r\nbreak;\r\ndefault:\r\nreturn err;\r\n}\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_CONFIGURE_ESWITCH;\r\ncmd.req.arg1 = arg1;\r\ncmd.req.arg2 = arg2;\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nerr = cmd.rsp.cmd;\r\nif (err != QLCNIC_RCODE_SUCCESS) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to configure eswitch pci func %d\n", pci_func);\r\n} else {\r\ndev_info(&adapter->pdev->dev,\r\n"Configured eSwitch for pci func %d\n", pci_func);\r\n}\r\nreturn err;\r\n}\r\nint\r\nqlcnic_get_eswitch_port_config(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_esw_func_cfg *esw_cfg)\r\n{\r\nu32 arg1, arg2;\r\nu8 phy_port;\r\nif (adapter->op_mode == QLCNIC_MGMT_FUNC)\r\nphy_port = adapter->npars[esw_cfg->pci_func].phy_port;\r\nelse\r\nphy_port = adapter->physical_port;\r\narg1 = phy_port;\r\narg1 |= (esw_cfg->pci_func << 8);\r\nif (__qlcnic_get_eswitch_port_config(adapter, &arg1, &arg2))\r\nreturn -EIO;\r\nesw_cfg->discard_tagged = !!(arg1 & BIT_4);\r\nesw_cfg->host_vlan_tag = !!(arg1 & BIT_5);\r\nesw_cfg->promisc_mode = !!(arg1 & BIT_6);\r\nesw_cfg->mac_override = !!(arg1 & BIT_7);\r\nesw_cfg->vlan_id = LSW(arg1 >> 16);\r\nesw_cfg->mac_anti_spoof = (arg2 & 0x1);\r\nesw_cfg->offload_flags = ((arg2 >> 1) & 0x7);\r\nreturn 0;\r\n}
