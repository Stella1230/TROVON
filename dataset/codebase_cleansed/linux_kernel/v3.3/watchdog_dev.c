static int watchdog_ping(struct watchdog_device *wddev)\r\n{\r\nif (test_bit(WDOG_ACTIVE, &wddev->status)) {\r\nif (wddev->ops->ping)\r\nreturn wddev->ops->ping(wddev);\r\nelse\r\nreturn wddev->ops->start(wddev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int watchdog_start(struct watchdog_device *wddev)\r\n{\r\nint err;\r\nif (!test_bit(WDOG_ACTIVE, &wddev->status)) {\r\nerr = wddev->ops->start(wddev);\r\nif (err < 0)\r\nreturn err;\r\nset_bit(WDOG_ACTIVE, &wddev->status);\r\n}\r\nreturn 0;\r\n}\r\nstatic int watchdog_stop(struct watchdog_device *wddev)\r\n{\r\nint err = -EBUSY;\r\nif (test_bit(WDOG_NO_WAY_OUT, &wddev->status)) {\r\npr_info("%s: nowayout prevents watchdog to be stopped!\n",\r\nwddev->info->identity);\r\nreturn err;\r\n}\r\nif (test_bit(WDOG_ACTIVE, &wddev->status)) {\r\nerr = wddev->ops->stop(wddev);\r\nif (err < 0)\r\nreturn err;\r\nclear_bit(WDOG_ACTIVE, &wddev->status);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t watchdog_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nsize_t i;\r\nchar c;\r\nif (len == 0)\r\nreturn 0;\r\nclear_bit(WDOG_ALLOW_RELEASE, &wdd->status);\r\nfor (i = 0; i != len; i++) {\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nset_bit(WDOG_ALLOW_RELEASE, &wdd->status);\r\n}\r\nwatchdog_ping(wdd);\r\nreturn len;\r\n}\r\nstatic long watchdog_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nunsigned int val;\r\nint err;\r\nif (wdd->ops->ioctl) {\r\nerr = wdd->ops->ioctl(wdd, cmd, arg);\r\nif (err != -ENOIOCTLCMD)\r\nreturn err;\r\n}\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, wdd->info,\r\nsizeof(struct watchdog_info)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\nval = wdd->ops->status ? wdd->ops->status(wdd) : 0;\r\nreturn put_user(val, p);\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(wdd->bootstatus, p);\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nif (val & WDIOS_DISABLECARD) {\r\nerr = watchdog_stop(wdd);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (val & WDIOS_ENABLECARD) {\r\nerr = watchdog_start(wdd);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\ncase WDIOC_KEEPALIVE:\r\nif (!(wdd->info->options & WDIOF_KEEPALIVEPING))\r\nreturn -EOPNOTSUPP;\r\nwatchdog_ping(wdd);\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif ((wdd->ops->set_timeout == NULL) ||\r\n!(wdd->info->options & WDIOF_SETTIMEOUT))\r\nreturn -EOPNOTSUPP;\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nif ((wdd->max_timeout != 0) &&\r\n(val < wdd->min_timeout || val > wdd->max_timeout))\r\nreturn -EINVAL;\r\nerr = wdd->ops->set_timeout(wdd, val);\r\nif (err < 0)\r\nreturn err;\r\nwdd->timeout = val;\r\nwatchdog_ping(wdd);\r\ncase WDIOC_GETTIMEOUT:\r\nif (wdd->timeout == 0)\r\nreturn -EOPNOTSUPP;\r\nreturn put_user(wdd->timeout, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int watchdog_open(struct inode *inode, struct file *file)\r\n{\r\nint err = -EBUSY;\r\nif (test_and_set_bit(WDOG_DEV_OPEN, &wdd->status))\r\nreturn -EBUSY;\r\nif (!try_module_get(wdd->ops->owner))\r\ngoto out;\r\nerr = watchdog_start(wdd);\r\nif (err < 0)\r\ngoto out_mod;\r\nreturn nonseekable_open(inode, file);\r\nout_mod:\r\nmodule_put(wdd->ops->owner);\r\nout:\r\nclear_bit(WDOG_DEV_OPEN, &wdd->status);\r\nreturn err;\r\n}\r\nstatic int watchdog_release(struct inode *inode, struct file *file)\r\n{\r\nint err = -EBUSY;\r\nif (test_and_clear_bit(WDOG_ALLOW_RELEASE, &wdd->status) ||\r\n!(wdd->info->options & WDIOF_MAGICCLOSE))\r\nerr = watchdog_stop(wdd);\r\nif (err < 0) {\r\npr_crit("%s: watchdog did not stop!\n", wdd->info->identity);\r\nwatchdog_ping(wdd);\r\n}\r\nmodule_put(wdd->ops->owner);\r\nclear_bit(WDOG_DEV_OPEN, &wdd->status);\r\nreturn 0;\r\n}\r\nint watchdog_dev_register(struct watchdog_device *watchdog)\r\n{\r\nint err;\r\nif (test_and_set_bit(0, &watchdog_dev_busy)) {\r\npr_err("only one watchdog can use /dev/watchdog.\n");\r\nreturn -EBUSY;\r\n}\r\nwdd = watchdog;\r\nerr = misc_register(&watchdog_miscdev);\r\nif (err != 0) {\r\npr_err("%s: cannot register miscdev on minor=%d (err=%d).\n",\r\nwatchdog->info->identity, WATCHDOG_MINOR, err);\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nwdd = NULL;\r\nclear_bit(0, &watchdog_dev_busy);\r\nreturn err;\r\n}\r\nint watchdog_dev_unregister(struct watchdog_device *watchdog)\r\n{\r\nif (!test_bit(0, &watchdog_dev_busy) || !wdd)\r\nreturn -ENODEV;\r\nif (watchdog != wdd) {\r\npr_err("%s: watchdog was not registered as /dev/watchdog.\n",\r\nwatchdog->info->identity);\r\nreturn -ENODEV;\r\n}\r\nmisc_deregister(&watchdog_miscdev);\r\nwdd = NULL;\r\nclear_bit(0, &watchdog_dev_busy);\r\nreturn 0;\r\n}
