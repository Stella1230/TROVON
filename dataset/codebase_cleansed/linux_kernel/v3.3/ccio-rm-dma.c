static int ccio_dma_supported( struct pci_dev *dev, u64 mask)\r\n{\r\nif (dev == NULL) {\r\nprintk(KERN_ERR MODULE_NAME ": EISA/ISA/et al not supported\n");\r\nBUG();\r\nreturn(0);\r\n}\r\nreturn((int) (mask >= 0xffffffffUL));\r\n}\r\nstatic void *ccio_alloc_consistent(struct pci_dev *dev, size_t size,\r\ndma_addr_t *handle)\r\n{\r\nvoid *ret;\r\nret = (void *)__get_free_pages(GFP_ATOMIC, get_order(size));\r\nif (ret != NULL) {\r\nmemset(ret, 0, size);\r\n*handle = virt_to_phys(ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic void ccio_free_consistent(struct pci_dev *dev, size_t size,\r\nvoid *vaddr, dma_addr_t handle)\r\n{\r\nfree_pages((unsigned long)vaddr, get_order(size));\r\n}\r\nstatic dma_addr_t ccio_map_single(struct pci_dev *dev, void *ptr, size_t size,\r\nint direction)\r\n{\r\nreturn virt_to_phys(ptr);\r\n}\r\nstatic void ccio_unmap_single(struct pci_dev *dev, dma_addr_t dma_addr,\r\nsize_t size, int direction)\r\n{\r\n}\r\nstatic int ccio_map_sg(struct pci_dev *dev, struct scatterlist *sglist, int nents, int direction)\r\n{\r\nint tmp = nents;\r\nwhile (nents) {\r\nsg_dma_address(sglist) = ccio_map_single(dev, sglist->address, sglist->length, direction);\r\nsg_dma_len(sglist) = sglist->length;\r\nnents--;\r\nsglist++;\r\n}\r\nreturn tmp;\r\n}\r\nstatic void ccio_unmap_sg(struct pci_dev *dev, struct scatterlist *sglist, int nents, int direction)\r\n{\r\n#if 0\r\nwhile (nents) {\r\nccio_unmap_single(dev, sg_dma_address(sglist), sg_dma_len(sglist), direction);\r\nnents--;\r\nsglist++;\r\n}\r\nreturn;\r\n#else\r\n#endif\r\n}\r\nstatic int\r\nccio_probe(struct parisc_device *dev)\r\n{\r\nprintk(KERN_INFO "%s found %s at 0x%lx\n", MODULE_NAME,\r\ndev->id.hversion == U2_BC_GSC ? "U2" : "UTurn",\r\ndev->hpa.start);\r\n#if 0\r\nccio_hw_init(ccio_dev);\r\nccio_common_init(ccio_dev);\r\n#endif\r\nhppa_dma_ops = &ccio_ops;\r\nreturn 0;\r\n}\r\nvoid __init ccio_init(void)\r\n{\r\nregister_parisc_driver(&ccio_driver);\r\n}
