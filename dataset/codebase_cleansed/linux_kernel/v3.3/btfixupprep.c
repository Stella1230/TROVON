static void fatal(void)\r\n{\r\nfprintf(stderr, "Malformed output from objdump\n%s\n", buffer);\r\nexit(1);\r\n}\r\nstatic btfixup *find(int type, char *name)\r\n{\r\nint i;\r\nfor (i = 0; i < last; i++) {\r\nif (array[i].type == type && !strcmp(array[i].name, name))\r\nreturn array + i;\r\n}\r\narray[last].type = type;\r\narray[last].name = strdup(name);\r\narray[last].setinitval = 0;\r\nif (!array[last].name) fatal();\r\narray[last].rel = NULL;\r\nlast++;\r\nif (last >= MAXSYMS) {\r\nfprintf(stderr, "Ugh. Something strange. More than %d different BTFIXUP symbols\n", MAXSYMS);\r\nexit(1);\r\n}\r\nreturn array + last - 1;\r\n}\r\nstatic void set_mode (char *buffer)\r\n{\r\nfor (mode = 0;; mode++)\r\nif (buffer[mode] < '0' || buffer[mode] > '9')\r\nbreak;\r\nif (mode != 8 && mode != 16)\r\nfatal();\r\n}\r\nint main(int argc,char **argv)\r\n{\r\nchar *p, *q;\r\nchar *sect;\r\nint i, j, k;\r\nunsigned int initval;\r\nint shift;\r\nbtfixup *f;\r\nbtfixuprel *r, **rr;\r\nunsigned long offset;\r\nchar *initvalstr;\r\nsymlen = strlen(symtab);\r\nwhile (fgets (buffer, 1024, stdin) != NULL)\r\nif (!strncmp (buffer, symtab, symlen))\r\ngoto main0;\r\nfatal();\r\nmain0:\r\nrellen = strlen(relrec);\r\nwhile (fgets (buffer, 1024, stdin) != NULL)\r\nif (!strncmp (buffer, relrec, rellen))\r\ngoto main1;\r\nfatal();\r\nmain1:\r\nsect = malloc(strlen (buffer + rellen) + 1);\r\nif (!sect) fatal();\r\nstrcpy (sect, buffer + rellen);\r\np = strchr (sect, ']');\r\nif (!p) fatal();\r\n*p = 0;\r\nif (fgets (buffer, 1024, stdin) == NULL)\r\nfatal();\r\nwhile (fgets (buffer, 1024, stdin) != NULL) {\r\nint nbase;\r\nif (!strncmp (buffer, relrec, rellen))\r\ngoto main1;\r\nif (mode == 0)\r\nset_mode (buffer);\r\np = strchr (buffer, '\n');\r\nif (p) *p = 0;\r\nif (strlen (buffer) < 22+mode)\r\ncontinue;\r\nif (strncmp (buffer + mode, " R_SPARC_", 9))\r\ncontinue;\r\nnbase = 27 - 8 + mode;\r\nif (buffer[nbase] != '_' || buffer[nbase+1] != '_' || buffer[nbase+2] != '_')\r\ncontinue;\r\nswitch (buffer[nbase+3]) {\r\ncase 'f':\r\ncase 'b':\r\ncase 's':\r\ncase 'a':\r\ncase 'h':\r\ncase 'i':\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\np = strchr (buffer + nbase+5, '+');\r\nif (p) *p = 0;\r\nshift = nbase + 5;\r\nif (buffer[nbase+4] == 's' && buffer[nbase+5] == '_') {\r\nshift = nbase + 6;\r\nif (strcmp (sect, ".init.text")) {\r\nfprintf(stderr,\r\n"Wrong use of '%s' BTFIXUPSET in '%s' section.\n"\r\n"BTFIXUPSET_CALL can be used only in"\r\n" __init sections\n",\r\nbuffer + shift, sect);\r\nexit(1);\r\n}\r\n} else if (buffer[nbase+4] != '_')\r\ncontinue;\r\nif (!strcmp (sect, ".text.exit"))\r\ncontinue;\r\nif (strcmp (sect, ".text") &&\r\nstrcmp (sect, ".init.text") &&\r\nstrcmp (sect, ".fixup") &&\r\n(strcmp (sect, "__ksymtab") || buffer[nbase+3] != 'f')) {\r\nif (buffer[nbase+3] == 'f')\r\nfprintf(stderr,\r\n"Wrong use of '%s' in '%s' section.\n"\r\n" It can be used only in .text, .init.text,"\r\n" .fixup and __ksymtab\n",\r\nbuffer + shift, sect);\r\nelse\r\nfprintf(stderr,\r\n"Wrong use of '%s' in '%s' section.\n"\r\n" It can be only used in .text, .init.text,"\r\n" and .fixup\n", buffer + shift, sect);\r\nexit(1);\r\n}\r\np = strstr (buffer + shift, "__btset_");\r\nif (p && buffer[nbase+4] == 's') {\r\nfprintf(stderr, "__btset_ in BTFIXUP name can only be used when defining the variable, not for setting\n%s\n", buffer);\r\nexit(1);\r\n}\r\ninitval = 0;\r\ninitvalstr = NULL;\r\nif (p) {\r\nif (p[8] != '0' || p[9] != 'x') {\r\nfprintf(stderr, "Pre-initialized values can be only initialized with hexadecimal constants starting 0x\n%s\n", buffer);\r\nexit(1);\r\n}\r\ninitval = strtoul(p + 10, &q, 16);\r\nif (*q || !initval) {\r\nfprintf(stderr, "Pre-initialized values can be only in the form name__btset_0xXXXXXXXX where X are hex digits.\nThey cannot be name__btset_0x00000000 though. Use BTFIXUPDEF_XX instead of BTFIXUPDEF_XX_INIT then.\n%s\n", buffer);\r\nexit(1);\r\n}\r\ninitvalstr = p + 10;\r\n*p = 0;\r\n}\r\nf = find(buffer[nbase+3], buffer + shift);\r\nif (buffer[nbase+4] == 's')\r\ncontinue;\r\nswitch (buffer[nbase+3]) {\r\ncase 'f':\r\nif (initval) {\r\nfprintf(stderr, "Cannot use pre-initialized fixups for calls\n%s\n", buffer);\r\nexit(1);\r\n}\r\nif (!strcmp (sect, "__ksymtab")) {\r\nif (strncmp (buffer + mode+9, "32 ", 10)) {\r\nfprintf(stderr, "BTFIXUP_CALL in EXPORT_SYMBOL results in relocation other than R_SPARC_32\n\%s\n", buffer);\r\nexit(1);\r\n}\r\n} else if (strncmp (buffer + mode+9, "WDISP30 ", 10) &&\r\nstrncmp (buffer + mode+9, "HI22 ", 10) &&\r\nstrncmp (buffer + mode+9, "LO10 ", 10)) {\r\nfprintf(stderr, "BTFIXUP_CALL results in relocation other than R_SPARC_WDISP30, R_SPARC_HI22 or R_SPARC_LO10\n%s\n", buffer);\r\nexit(1);\r\n}\r\nbreak;\r\ncase 'b':\r\nif (initval) {\r\nfprintf(stderr, "Cannot use pre-initialized fixups for blackboxes\n%s\n", buffer);\r\nexit(1);\r\n}\r\nif (strncmp (buffer + mode+9, "HI22 ", 10)) {\r\nfprintf(stderr, "BTFIXUP_BLACKBOX results in relocation other than R_SPARC_HI22\n%s\n", buffer);\r\nexit(1);\r\n}\r\nbreak;\r\ncase 's':\r\nif (initval + 0x1000 >= 0x2000) {\r\nfprintf(stderr, "Wrong initializer for SIMM13. Has to be from $fffff000 to $00000fff\n%s\n", buffer);\r\nexit(1);\r\n}\r\nif (strncmp (buffer + mode+9, "13 ", 10)) {\r\nfprintf(stderr, "BTFIXUP_SIMM13 results in relocation other than R_SPARC_13\n%s\n", buffer);\r\nexit(1);\r\n}\r\nbreak;\r\ncase 'a':\r\nif (initval + 0x1000 >= 0x2000 && (initval & 0x3ff)) {\r\nfprintf(stderr, "Wrong initializer for HALF.\n%s\n", buffer);\r\nexit(1);\r\n}\r\nif (strncmp (buffer + mode+9, "13 ", 10)) {\r\nfprintf(stderr, "BTFIXUP_HALF results in relocation other than R_SPARC_13\n%s\n", buffer);\r\nexit(1);\r\n}\r\nbreak;\r\ncase 'h':\r\nif (initval & 0x3ff) {\r\nfprintf(stderr, "Wrong initializer for SETHI. Cannot have set low 10 bits\n%s\n", buffer);\r\nexit(1);\r\n}\r\nif (strncmp (buffer + mode+9, "HI22 ", 10)) {\r\nfprintf(stderr, "BTFIXUP_SETHI results in relocation other than R_SPARC_HI22\n%s\n", buffer);\r\nexit(1);\r\n}\r\nbreak;\r\ncase 'i':\r\nif (initval) {\r\nfprintf(stderr, "Cannot use pre-initialized fixups for INT\n%s\n", buffer);\r\nexit(1);\r\n}\r\nif (strncmp (buffer + mode+9, "HI22 ", 10) && strncmp (buffer + mode+9, "LO10 ", 10)) {\r\nfprintf(stderr, "BTFIXUP_INT results in relocation other than R_SPARC_HI22 and R_SPARC_LO10\n%s\n", buffer);\r\nexit(1);\r\n}\r\nbreak;\r\n}\r\nif (!f->setinitval) {\r\nf->initval = initval;\r\nif (initvalstr) {\r\nf->initvalstr = strdup(initvalstr);\r\nif (!f->initvalstr) fatal();\r\n}\r\nf->setinitval = 1;\r\n} else if (f->initval != initval) {\r\nfprintf(stderr, "Btfixup %s previously used with initializer %s which doesn't match with current initializer\n%s\n",\r\nf->name, f->initvalstr ? : "0x00000000", buffer);\r\nexit(1);\r\n} else if (initval && strcmp(f->initvalstr, initvalstr)) {\r\nfprintf(stderr, "Btfixup %s previously used with initializer %s which doesn't match with current initializer.\n"\r\n"Initializers have to match literally as well.\n%s\n",\r\nf->name, f->initvalstr, buffer);\r\nexit(1);\r\n}\r\noffset = strtoul(buffer, &q, 16);\r\nif (q != buffer + mode || (!offset && (mode == 8 ? strncmp (buffer, "00000000 ", 9) : strncmp (buffer, "0000000000000000 ", 17)))) {\r\nfprintf(stderr, "Malformed relocation address in\n%s\n", buffer);\r\nexit(1);\r\n}\r\nfor (k = 0, r = f->rel, rr = &f->rel; r; rr = &r->next, r = r->next, k++)\r\nif (r->offset == offset && !strcmp(r->sect, sect)) {\r\nfprintf(stderr, "Ugh. One address has two relocation records\n");\r\nexit(1);\r\n}\r\n*rr = malloc(sizeof(btfixuprel));\r\nif (!*rr) fatal();\r\n(*rr)->offset = offset;\r\n(*rr)->f = NULL;\r\nif (buffer[nbase+3] == 'f') {\r\nlastf = f;\r\nlastfoffset = offset;\r\nlastfrelno = k;\r\n} else if (lastfoffset + 4 == offset) {\r\n(*rr)->f = lastf;\r\n(*rr)->frel = lastfrelno;\r\n}\r\n(*rr)->sect = sect;\r\n(*rr)->next = NULL;\r\n}\r\nprintf("! Generated by btfixupprep. Do not edit.\n\n");\r\nprintf("\t.section\t\".data..init\",#alloc,#write\n\t.align\t4\n\n");\r\nprintf("\t.global\t___btfixup_start\n___btfixup_start:\n\n");\r\nfor (i = 0; i < last; i++) {\r\nf = array + i;\r\nprintf("\t.global\t___%cs_%s\n", f->type, f->name);\r\nif (f->type == 'f')\r\nprintf("___%cs_%s:\n\t.word 0x%08x,0,0,", f->type, f->name, f->type << 24);\r\nelse\r\nprintf("___%cs_%s:\n\t.word 0x%08x,0,", f->type, f->name, f->type << 24);\r\nfor (j = 0, r = f->rel; r != NULL; j++, r = r->next);\r\nif (j)\r\nprintf("%d\n\t.word\t", j * 2);\r\nelse\r\nprintf("0\n");\r\nfor (r = f->rel, j--; r != NULL; j--, r = r->next) {\r\nif (!strcmp (r->sect, ".text"))\r\nprintf ("_stext+0x%08lx", r->offset);\r\nelse if (!strcmp (r->sect, ".init.text"))\r\nprintf ("__init_begin+0x%08lx", r->offset);\r\nelse if (!strcmp (r->sect, "__ksymtab"))\r\nprintf ("__start___ksymtab+0x%08lx", r->offset);\r\nelse if (!strcmp (r->sect, ".fixup"))\r\nprintf ("__start___fixup+0x%08lx", r->offset);\r\nelse\r\nfatal();\r\nif (f->type == 'f' || !r->f)\r\nprintf (",0");\r\nelse\r\nprintf (",___fs_%s+0x%08x", r->f->name, (4 + r->frel*2)*4 + 4);\r\nif (j) printf (",");\r\nelse printf ("\n");\r\n}\r\nprintf("\n");\r\n}\r\nprintf("\n\t.global\t___btfixup_end\n___btfixup_end:\n");\r\nprintf("\n\n! Define undefined references\n\n");\r\nfor (i = 0; i < last; i++) {\r\nf = array + i;\r\nif (f->type == 'f') {\r\nprintf("\t.global\t___f_%s\n", f->name);\r\nprintf("___f_%s:\n", f->name);\r\n}\r\n}\r\nprintf("\tretl\n\t nop\n\n");\r\nfor (i = 0; i < last; i++) {\r\nf = array + i;\r\nif (f->type != 'f') {\r\nif (!f->initval) {\r\nprintf("\t.global\t___%c_%s\n", f->type, f->name);\r\nprintf("___%c_%s = 0\n", f->type, f->name);\r\n} else {\r\nprintf("\t.global\t___%c_%s__btset_0x%s\n", f->type, f->name, f->initvalstr);\r\nprintf("___%c_%s__btset_0x%s = 0x%08x\n", f->type, f->name, f->initvalstr, f->initval);\r\n}\r\n}\r\n}\r\nprintf("\n\n");\r\nexit(0);\r\n}
