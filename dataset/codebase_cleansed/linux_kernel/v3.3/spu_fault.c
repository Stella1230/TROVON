int spu_handle_mm_fault(struct mm_struct *mm, unsigned long ea,\r\nunsigned long dsisr, unsigned *flt)\r\n{\r\nstruct vm_area_struct *vma;\r\nunsigned long is_write;\r\nint ret;\r\nif (mm == NULL)\r\nreturn -EFAULT;\r\nif (mm->pgd == NULL)\r\nreturn -EFAULT;\r\ndown_read(&mm->mmap_sem);\r\nret = -EFAULT;\r\nvma = find_vma(mm, ea);\r\nif (!vma)\r\ngoto out_unlock;\r\nif (ea < vma->vm_start) {\r\nif (!(vma->vm_flags & VM_GROWSDOWN))\r\ngoto out_unlock;\r\nif (expand_stack(vma, ea))\r\ngoto out_unlock;\r\n}\r\nis_write = dsisr & MFC_DSISR_ACCESS_PUT;\r\nif (is_write) {\r\nif (!(vma->vm_flags & VM_WRITE))\r\ngoto out_unlock;\r\n} else {\r\nif (dsisr & MFC_DSISR_ACCESS_DENIED)\r\ngoto out_unlock;\r\nif (!(vma->vm_flags & (VM_READ | VM_EXEC)))\r\ngoto out_unlock;\r\n}\r\nret = 0;\r\n*flt = handle_mm_fault(mm, vma, ea, is_write ? FAULT_FLAG_WRITE : 0);\r\nif (unlikely(*flt & VM_FAULT_ERROR)) {\r\nif (*flt & VM_FAULT_OOM) {\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n} else if (*flt & VM_FAULT_SIGBUS) {\r\nret = -EFAULT;\r\ngoto out_unlock;\r\n}\r\nBUG();\r\n}\r\nif (*flt & VM_FAULT_MAJOR)\r\ncurrent->maj_flt++;\r\nelse\r\ncurrent->min_flt++;\r\nout_unlock:\r\nup_read(&mm->mmap_sem);\r\nreturn ret;\r\n}
