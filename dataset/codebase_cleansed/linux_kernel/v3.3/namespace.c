char *nfs_path(char **p, struct dentry *dentry, char *buffer, ssize_t buflen)\r\n{\r\nchar *end;\r\nint namelen;\r\nunsigned seq;\r\nconst char *base;\r\nrename_retry:\r\nend = buffer+buflen;\r\n*--end = '\0';\r\nbuflen--;\r\nseq = read_seqbegin(&rename_lock);\r\nrcu_read_lock();\r\nwhile (1) {\r\nspin_lock(&dentry->d_lock);\r\nif (IS_ROOT(dentry))\r\nbreak;\r\nnamelen = dentry->d_name.len;\r\nbuflen -= namelen + 1;\r\nif (buflen < 0)\r\ngoto Elong_unlock;\r\nend -= namelen;\r\nmemcpy(end, dentry->d_name.name, namelen);\r\n*--end = '/';\r\nspin_unlock(&dentry->d_lock);\r\ndentry = dentry->d_parent;\r\n}\r\nif (read_seqretry(&rename_lock, seq)) {\r\nspin_unlock(&dentry->d_lock);\r\nrcu_read_unlock();\r\ngoto rename_retry;\r\n}\r\nif (*end != '/') {\r\nif (--buflen < 0) {\r\nspin_unlock(&dentry->d_lock);\r\nrcu_read_unlock();\r\ngoto Elong;\r\n}\r\n*--end = '/';\r\n}\r\n*p = end;\r\nbase = dentry->d_fsdata;\r\nif (!base) {\r\nspin_unlock(&dentry->d_lock);\r\nrcu_read_unlock();\r\nWARN_ON(1);\r\nreturn end;\r\n}\r\nnamelen = strlen(base);\r\nwhile (namelen > 0 && base[namelen - 1] == '/')\r\nnamelen--;\r\nbuflen -= namelen;\r\nif (buflen < 0) {\r\nspin_unlock(&dentry->d_lock);\r\nrcu_read_unlock();\r\ngoto Elong;\r\n}\r\nend -= namelen;\r\nmemcpy(end, base, namelen);\r\nspin_unlock(&dentry->d_lock);\r\nrcu_read_unlock();\r\nreturn end;\r\nElong_unlock:\r\nspin_unlock(&dentry->d_lock);\r\nrcu_read_unlock();\r\nif (read_seqretry(&rename_lock, seq))\r\ngoto rename_retry;\r\nElong:\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\n}\r\nrpc_authflavor_t nfs_find_best_sec(struct nfs4_secinfo_flavors *flavors)\r\n{\r\nstruct gss_api_mech *mech;\r\nstruct xdr_netobj oid;\r\nint i;\r\nrpc_authflavor_t pseudoflavor = RPC_AUTH_UNIX;\r\nfor (i = 0; i < flavors->num_flavors; i++) {\r\nstruct nfs4_secinfo_flavor *flavor;\r\nflavor = &flavors->flavors[i];\r\nif (flavor->flavor == RPC_AUTH_NULL || flavor->flavor == RPC_AUTH_UNIX) {\r\npseudoflavor = flavor->flavor;\r\nbreak;\r\n} else if (flavor->flavor == RPC_AUTH_GSS) {\r\noid.len = flavor->gss.sec_oid4.len;\r\noid.data = flavor->gss.sec_oid4.data;\r\nmech = gss_mech_get_by_OID(&oid);\r\nif (!mech)\r\ncontinue;\r\npseudoflavor = gss_svc_to_pseudoflavor(mech, flavor->gss.service);\r\ngss_mech_put(mech);\r\nbreak;\r\n}\r\n}\r\nreturn pseudoflavor;\r\n}\r\nstatic int nfs_negotiate_security(const struct dentry *parent,\r\nconst struct dentry *dentry,\r\nrpc_authflavor_t *flavor)\r\n{\r\nstruct page *page;\r\nstruct nfs4_secinfo_flavors *flavors;\r\nint (*secinfo)(struct inode *, const struct qstr *, struct nfs4_secinfo_flavors *);\r\nint ret = -EPERM;\r\nsecinfo = NFS_PROTO(parent->d_inode)->secinfo;\r\nif (secinfo != NULL) {\r\npage = alloc_page(GFP_KERNEL);\r\nif (!page) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nflavors = page_address(page);\r\nret = secinfo(parent->d_inode, &dentry->d_name, flavors);\r\n*flavor = nfs_find_best_sec(flavors);\r\nput_page(page);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int nfs_lookup_with_sec(struct nfs_server *server, struct dentry *parent,\r\nstruct dentry *dentry, struct path *path,\r\nstruct nfs_fh *fh, struct nfs_fattr *fattr,\r\nrpc_authflavor_t *flavor)\r\n{\r\nstruct rpc_clnt *clone;\r\nstruct rpc_auth *auth;\r\nint err;\r\nerr = nfs_negotiate_security(parent, path->dentry, flavor);\r\nif (err < 0)\r\ngoto out;\r\nclone = rpc_clone_client(server->client);\r\nauth = rpcauth_create(*flavor, clone);\r\nif (!auth) {\r\nerr = -EIO;\r\ngoto out_shutdown;\r\n}\r\nerr = server->nfs_client->rpc_ops->lookup(clone, parent->d_inode,\r\n&path->dentry->d_name,\r\nfh, fattr);\r\nout_shutdown:\r\nrpc_shutdown_client(clone);\r\nout:\r\nreturn err;\r\n}\r\nstatic inline int nfs_lookup_with_sec(struct nfs_server *server,\r\nstruct dentry *parent, struct dentry *dentry,\r\nstruct path *path, struct nfs_fh *fh,\r\nstruct nfs_fattr *fattr,\r\nrpc_authflavor_t *flavor)\r\n{\r\nreturn -EPERM;\r\n}\r\nstruct vfsmount *nfs_d_automount(struct path *path)\r\n{\r\nstruct vfsmount *mnt;\r\nstruct nfs_server *server = NFS_SERVER(path->dentry->d_inode);\r\nstruct dentry *parent;\r\nstruct nfs_fh *fh = NULL;\r\nstruct nfs_fattr *fattr = NULL;\r\nint err;\r\nrpc_authflavor_t flavor = RPC_AUTH_UNIX;\r\ndprintk("--> nfs_d_automount()\n");\r\nmnt = ERR_PTR(-ESTALE);\r\nif (IS_ROOT(path->dentry))\r\ngoto out_nofree;\r\nmnt = ERR_PTR(-ENOMEM);\r\nfh = nfs_alloc_fhandle();\r\nfattr = nfs_alloc_fattr();\r\nif (fh == NULL || fattr == NULL)\r\ngoto out;\r\ndprintk("%s: enter\n", __func__);\r\nparent = dget_parent(path->dentry);\r\nerr = server->nfs_client->rpc_ops->lookup(server->client, parent->d_inode,\r\n&path->dentry->d_name,\r\nfh, fattr);\r\nif (err == -EPERM && NFS_PROTO(parent->d_inode)->secinfo != NULL)\r\nerr = nfs_lookup_with_sec(server, parent, path->dentry, path, fh, fattr, &flavor);\r\ndput(parent);\r\nif (err != 0) {\r\nmnt = ERR_PTR(err);\r\ngoto out;\r\n}\r\nif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL)\r\nmnt = nfs_do_refmount(path->dentry);\r\nelse\r\nmnt = nfs_do_submount(path->dentry, fh, fattr, flavor);\r\nif (IS_ERR(mnt))\r\ngoto out;\r\ndprintk("%s: done, success\n", __func__);\r\nmntget(mnt);\r\nmnt_set_expiry(mnt, &nfs_automount_list);\r\nschedule_delayed_work(&nfs_automount_task, nfs_mountpoint_expiry_timeout);\r\nout:\r\nnfs_free_fattr(fattr);\r\nnfs_free_fhandle(fh);\r\nout_nofree:\r\ndprintk("<-- nfs_follow_mountpoint() = %p\n", mnt);\r\nreturn mnt;\r\n}\r\nstatic void nfs_expire_automounts(struct work_struct *work)\r\n{\r\nstruct list_head *list = &nfs_automount_list;\r\nmark_mounts_for_expiry(list);\r\nif (!list_empty(list))\r\nschedule_delayed_work(&nfs_automount_task, nfs_mountpoint_expiry_timeout);\r\n}\r\nvoid nfs_release_automount_timer(void)\r\n{\r\nif (list_empty(&nfs_automount_list))\r\ncancel_delayed_work(&nfs_automount_task);\r\n}\r\nstatic struct vfsmount *nfs_do_clone_mount(struct nfs_server *server,\r\nconst char *devname,\r\nstruct nfs_clone_mount *mountdata)\r\n{\r\n#ifdef CONFIG_NFS_V4\r\nstruct vfsmount *mnt = ERR_PTR(-EINVAL);\r\nswitch (server->nfs_client->rpc_ops->version) {\r\ncase 2:\r\ncase 3:\r\nmnt = vfs_kern_mount(&nfs_xdev_fs_type, 0, devname, mountdata);\r\nbreak;\r\ncase 4:\r\nmnt = vfs_kern_mount(&nfs4_xdev_fs_type, 0, devname, mountdata);\r\n}\r\nreturn mnt;\r\n#else\r\nreturn vfs_kern_mount(&nfs_xdev_fs_type, 0, devname, mountdata);\r\n#endif\r\n}\r\nstatic struct vfsmount *nfs_do_submount(struct dentry *dentry,\r\nstruct nfs_fh *fh,\r\nstruct nfs_fattr *fattr,\r\nrpc_authflavor_t authflavor)\r\n{\r\nstruct nfs_clone_mount mountdata = {\r\n.sb = dentry->d_sb,\r\n.dentry = dentry,\r\n.fh = fh,\r\n.fattr = fattr,\r\n.authflavor = authflavor,\r\n};\r\nstruct vfsmount *mnt = ERR_PTR(-ENOMEM);\r\nchar *page = (char *) __get_free_page(GFP_USER);\r\nchar *devname;\r\ndprintk("--> nfs_do_submount()\n");\r\ndprintk("%s: submounting on %s/%s\n", __func__,\r\ndentry->d_parent->d_name.name,\r\ndentry->d_name.name);\r\nif (page == NULL)\r\ngoto out;\r\ndevname = nfs_devname(dentry, page, PAGE_SIZE);\r\nmnt = (struct vfsmount *)devname;\r\nif (IS_ERR(devname))\r\ngoto free_page;\r\nmnt = nfs_do_clone_mount(NFS_SB(dentry->d_sb), devname, &mountdata);\r\nfree_page:\r\nfree_page((unsigned long)page);\r\nout:\r\ndprintk("%s: done\n", __func__);\r\ndprintk("<-- nfs_do_submount() = %p\n", mnt);\r\nreturn mnt;\r\n}
