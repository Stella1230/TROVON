static inline int not_allowed_char(unsigned char c)\r\n{\r\nreturn c<' ' || c=='"' || c=='*' || c=='/' || c==':' || c=='<' ||\r\nc=='>' || c=='?' || c=='\\' || c=='|';\r\n}\r\nstatic inline int no_dos_char(unsigned char c)\r\n{\r\nreturn c=='+' || c==',' || c==';' || c=='=' || c=='[' || c==']';\r\n}\r\nstatic inline unsigned char upcase(unsigned char *dir, unsigned char a)\r\n{\r\nif (a<128 || a==255) return a>='a' && a<='z' ? a - 0x20 : a;\r\nif (!dir) return a;\r\nreturn dir[a-128];\r\n}\r\nunsigned char hpfs_upcase(unsigned char *dir, unsigned char a)\r\n{\r\nreturn upcase(dir, a);\r\n}\r\nstatic inline unsigned char locase(unsigned char *dir, unsigned char a)\r\n{\r\nif (a<128 || a==255) return a>='A' && a<='Z' ? a + 0x20 : a;\r\nif (!dir) return a;\r\nreturn dir[a];\r\n}\r\nint hpfs_chk_name(const unsigned char *name, unsigned *len)\r\n{\r\nint i;\r\nif (*len > 254) return -ENAMETOOLONG;\r\nhpfs_adjust_length(name, len);\r\nif (!*len) return -EINVAL;\r\nfor (i = 0; i < *len; i++) if (not_allowed_char(name[i])) return -EINVAL;\r\nif (*len == 1) if (name[0] == '.') return -EINVAL;\r\nif (*len == 2) if (name[0] == '.' && name[1] == '.') return -EINVAL;\r\nreturn 0;\r\n}\r\nunsigned char *hpfs_translate_name(struct super_block *s, unsigned char *from,\r\nunsigned len, int lc, int lng)\r\n{\r\nunsigned char *to;\r\nint i;\r\nif (hpfs_sb(s)->sb_chk >= 2) if (hpfs_is_name_long(from, len) != lng) {\r\nprintk("HPFS: Long name flag mismatch - name ");\r\nfor (i=0; i<len; i++) printk("%c", from[i]);\r\nprintk(" misidentified as %s.\n", lng ? "short" : "long");\r\nprintk("HPFS: It's nothing serious. It could happen because of bug in OS/2.\nHPFS: Set checks=normal to disable this message.\n");\r\n}\r\nif (!lc) return from;\r\nif (!(to = kmalloc(len, GFP_KERNEL))) {\r\nprintk("HPFS: can't allocate memory for name conversion buffer\n");\r\nreturn from;\r\n}\r\nfor (i = 0; i < len; i++) to[i] = locase(hpfs_sb(s)->sb_cp_table,from[i]);\r\nreturn to;\r\n}\r\nint hpfs_compare_names(struct super_block *s,\r\nconst unsigned char *n1, unsigned l1,\r\nconst unsigned char *n2, unsigned l2, int last)\r\n{\r\nunsigned l = l1 < l2 ? l1 : l2;\r\nunsigned i;\r\nif (last) return -1;\r\nfor (i = 0; i < l; i++) {\r\nunsigned char c1 = upcase(hpfs_sb(s)->sb_cp_table,n1[i]);\r\nunsigned char c2 = upcase(hpfs_sb(s)->sb_cp_table,n2[i]);\r\nif (c1 < c2) return -1;\r\nif (c1 > c2) return 1;\r\n}\r\nif (l1 < l2) return -1;\r\nif (l1 > l2) return 1;\r\nreturn 0;\r\n}\r\nint hpfs_is_name_long(const unsigned char *name, unsigned len)\r\n{\r\nint i,j;\r\nfor (i = 0; i < len && name[i] != '.'; i++)\r\nif (no_dos_char(name[i])) return 1;\r\nif (!i || i > 8) return 1;\r\nif (i == len) return 0;\r\nfor (j = i + 1; j < len; j++)\r\nif (name[j] == '.' || no_dos_char(name[i])) return 1;\r\nreturn j - i > 4;\r\n}\r\nvoid hpfs_adjust_length(const unsigned char *name, unsigned *len)\r\n{\r\nif (!*len) return;\r\nif (*len == 1 && name[0] == '.') return;\r\nif (*len == 2 && name[0] == '.' && name[1] == '.') return;\r\nwhile (*len && (name[*len - 1] == '.' || name[*len - 1] == ' '))\r\n(*len)--;\r\n}
