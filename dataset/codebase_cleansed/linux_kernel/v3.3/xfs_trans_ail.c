STATIC void\r\nxfs_ail_check(\r\nstruct xfs_ail *ailp,\r\nxfs_log_item_t *lip)\r\n{\r\nxfs_log_item_t *prev_lip;\r\nif (list_empty(&ailp->xa_ail))\r\nreturn;\r\nASSERT((lip->li_flags & XFS_LI_IN_AIL) != 0);\r\nprev_lip = list_entry(lip->li_ail.prev, xfs_log_item_t, li_ail);\r\nif (&prev_lip->li_ail != &ailp->xa_ail)\r\nASSERT(XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) <= 0);\r\nprev_lip = list_entry(lip->li_ail.next, xfs_log_item_t, li_ail);\r\nif (&prev_lip->li_ail != &ailp->xa_ail)\r\nASSERT(XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) >= 0);\r\n#ifdef XFS_TRANS_DEBUG\r\nprev_lip = list_entry(&ailp->xa_ail, xfs_log_item_t, li_ail);\r\nlist_for_each_entry(lip, &ailp->xa_ail, li_ail) {\r\nif (&prev_lip->li_ail != &ailp->xa_ail)\r\nASSERT(XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) <= 0);\r\nASSERT((lip->li_flags & XFS_LI_IN_AIL) != 0);\r\nprev_lip = lip;\r\n}\r\n#endif\r\n}\r\nstatic xfs_log_item_t *\r\nxfs_ail_min(\r\nstruct xfs_ail *ailp)\r\n{\r\nif (list_empty(&ailp->xa_ail))\r\nreturn NULL;\r\nreturn list_first_entry(&ailp->xa_ail, xfs_log_item_t, li_ail);\r\n}\r\nstatic xfs_log_item_t *\r\nxfs_ail_max(\r\nstruct xfs_ail *ailp)\r\n{\r\nif (list_empty(&ailp->xa_ail))\r\nreturn NULL;\r\nreturn list_entry(ailp->xa_ail.prev, xfs_log_item_t, li_ail);\r\n}\r\nstatic xfs_log_item_t *\r\nxfs_ail_next(\r\nstruct xfs_ail *ailp,\r\nxfs_log_item_t *lip)\r\n{\r\nif (lip->li_ail.next == &ailp->xa_ail)\r\nreturn NULL;\r\nreturn list_first_entry(&lip->li_ail, xfs_log_item_t, li_ail);\r\n}\r\nxfs_lsn_t\r\nxfs_ail_min_lsn(\r\nstruct xfs_ail *ailp)\r\n{\r\nxfs_lsn_t lsn = 0;\r\nxfs_log_item_t *lip;\r\nspin_lock(&ailp->xa_lock);\r\nlip = xfs_ail_min(ailp);\r\nif (lip)\r\nlsn = lip->li_lsn;\r\nspin_unlock(&ailp->xa_lock);\r\nreturn lsn;\r\n}\r\nstatic xfs_lsn_t\r\nxfs_ail_max_lsn(\r\nstruct xfs_ail *ailp)\r\n{\r\nxfs_lsn_t lsn = 0;\r\nxfs_log_item_t *lip;\r\nspin_lock(&ailp->xa_lock);\r\nlip = xfs_ail_max(ailp);\r\nif (lip)\r\nlsn = lip->li_lsn;\r\nspin_unlock(&ailp->xa_lock);\r\nreturn lsn;\r\n}\r\nSTATIC void\r\nxfs_trans_ail_cursor_init(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_ail_cursor *cur)\r\n{\r\ncur->item = NULL;\r\nlist_add_tail(&cur->list, &ailp->xa_cursors);\r\n}\r\nstruct xfs_log_item *\r\nxfs_trans_ail_cursor_next(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_ail_cursor *cur)\r\n{\r\nstruct xfs_log_item *lip = cur->item;\r\nif ((__psint_t)lip & 1)\r\nlip = xfs_ail_min(ailp);\r\nif (lip)\r\ncur->item = xfs_ail_next(ailp, lip);\r\nreturn lip;\r\n}\r\nvoid\r\nxfs_trans_ail_cursor_done(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_ail_cursor *cur)\r\n{\r\ncur->item = NULL;\r\nlist_del_init(&cur->list);\r\n}\r\nSTATIC void\r\nxfs_trans_ail_cursor_clear(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_log_item *lip)\r\n{\r\nstruct xfs_ail_cursor *cur;\r\nlist_for_each_entry(cur, &ailp->xa_cursors, list) {\r\nif (cur->item == lip)\r\ncur->item = (struct xfs_log_item *)\r\n((__psint_t)cur->item | 1);\r\n}\r\n}\r\nxfs_log_item_t *\r\nxfs_trans_ail_cursor_first(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_ail_cursor *cur,\r\nxfs_lsn_t lsn)\r\n{\r\nxfs_log_item_t *lip;\r\nxfs_trans_ail_cursor_init(ailp, cur);\r\nif (lsn == 0) {\r\nlip = xfs_ail_min(ailp);\r\ngoto out;\r\n}\r\nlist_for_each_entry(lip, &ailp->xa_ail, li_ail) {\r\nif (XFS_LSN_CMP(lip->li_lsn, lsn) >= 0)\r\ngoto out;\r\n}\r\nreturn NULL;\r\nout:\r\nif (lip)\r\ncur->item = xfs_ail_next(ailp, lip);\r\nreturn lip;\r\n}\r\nstatic struct xfs_log_item *\r\n__xfs_trans_ail_cursor_last(\r\nstruct xfs_ail *ailp,\r\nxfs_lsn_t lsn)\r\n{\r\nxfs_log_item_t *lip;\r\nlist_for_each_entry_reverse(lip, &ailp->xa_ail, li_ail) {\r\nif (XFS_LSN_CMP(lip->li_lsn, lsn) <= 0)\r\nreturn lip;\r\n}\r\nreturn NULL;\r\n}\r\nstruct xfs_log_item *\r\nxfs_trans_ail_cursor_last(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_ail_cursor *cur,\r\nxfs_lsn_t lsn)\r\n{\r\nxfs_trans_ail_cursor_init(ailp, cur);\r\ncur->item = __xfs_trans_ail_cursor_last(ailp, lsn);\r\nreturn cur->item;\r\n}\r\nstatic void\r\nxfs_ail_splice(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_ail_cursor *cur,\r\nstruct list_head *list,\r\nxfs_lsn_t lsn)\r\n{\r\nstruct xfs_log_item *lip;\r\nASSERT(!list_empty(list));\r\nlip = cur ? cur->item : NULL;\r\nif (!lip || (__psint_t) lip & 1)\r\nlip = __xfs_trans_ail_cursor_last(ailp, lsn);\r\nif (cur)\r\ncur->item = list_entry(list->prev, struct xfs_log_item, li_ail);\r\nif (lip)\r\nlist_splice(list, &lip->li_ail);\r\nelse\r\nlist_splice(list, &ailp->xa_ail);\r\n}\r\nstatic void\r\nxfs_ail_delete(\r\nstruct xfs_ail *ailp,\r\nxfs_log_item_t *lip)\r\n{\r\nxfs_ail_check(ailp, lip);\r\nlist_del(&lip->li_ail);\r\nxfs_trans_ail_cursor_clear(ailp, lip);\r\n}\r\nstatic long\r\nxfsaild_push(\r\nstruct xfs_ail *ailp)\r\n{\r\nxfs_mount_t *mp = ailp->xa_mount;\r\nstruct xfs_ail_cursor cur;\r\nxfs_log_item_t *lip;\r\nxfs_lsn_t lsn;\r\nxfs_lsn_t target;\r\nlong tout = 10;\r\nint stuck = 0;\r\nint count = 0;\r\nint push_xfsbufd = 0;\r\nspin_lock(&ailp->xa_lock);\r\nif (ailp->xa_last_pushed_lsn == 0 && ailp->xa_log_flush &&\r\n!list_empty(&ailp->xa_ail)) {\r\nailp->xa_log_flush = 0;\r\nspin_unlock(&ailp->xa_lock);\r\nXFS_STATS_INC(xs_push_ail_flush);\r\nxfs_log_force(mp, XFS_LOG_SYNC);\r\nspin_lock(&ailp->xa_lock);\r\n}\r\ntarget = ailp->xa_target;\r\nlip = xfs_trans_ail_cursor_first(ailp, &cur, ailp->xa_last_pushed_lsn);\r\nif (!lip || XFS_FORCED_SHUTDOWN(mp)) {\r\nxfs_trans_ail_cursor_done(ailp, &cur);\r\nspin_unlock(&ailp->xa_lock);\r\ngoto out_done;\r\n}\r\nXFS_STATS_INC(xs_push_ail);\r\nlsn = lip->li_lsn;\r\nwhile ((XFS_LSN_CMP(lip->li_lsn, target) <= 0)) {\r\nint lock_result;\r\nlock_result = IOP_TRYLOCK(lip);\r\nspin_unlock(&ailp->xa_lock);\r\nswitch (lock_result) {\r\ncase XFS_ITEM_SUCCESS:\r\nXFS_STATS_INC(xs_push_ail_success);\r\ntrace_xfs_ail_push(lip);\r\nIOP_PUSH(lip);\r\nailp->xa_last_pushed_lsn = lsn;\r\nbreak;\r\ncase XFS_ITEM_PUSHBUF:\r\nXFS_STATS_INC(xs_push_ail_pushbuf);\r\ntrace_xfs_ail_pushbuf(lip);\r\nif (!IOP_PUSHBUF(lip)) {\r\ntrace_xfs_ail_pushbuf_pinned(lip);\r\nstuck++;\r\nailp->xa_log_flush++;\r\n} else {\r\nailp->xa_last_pushed_lsn = lsn;\r\n}\r\npush_xfsbufd = 1;\r\nbreak;\r\ncase XFS_ITEM_PINNED:\r\nXFS_STATS_INC(xs_push_ail_pinned);\r\ntrace_xfs_ail_pinned(lip);\r\nstuck++;\r\nailp->xa_log_flush++;\r\nbreak;\r\ncase XFS_ITEM_LOCKED:\r\nXFS_STATS_INC(xs_push_ail_locked);\r\ntrace_xfs_ail_locked(lip);\r\nstuck++;\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\nbreak;\r\n}\r\nspin_lock(&ailp->xa_lock);\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nbreak;\r\nASSERT(mp->m_log);\r\ncount++;\r\nif (stuck > 100)\r\nbreak;\r\nlip = xfs_trans_ail_cursor_next(ailp, &cur);\r\nif (lip == NULL)\r\nbreak;\r\nlsn = lip->li_lsn;\r\n}\r\nxfs_trans_ail_cursor_done(ailp, &cur);\r\nspin_unlock(&ailp->xa_lock);\r\nif (push_xfsbufd) {\r\nwake_up_process(mp->m_ddev_targp->bt_task);\r\n}\r\nout_done:\r\nif (!count) {\r\nailp->xa_last_pushed_lsn = 0;\r\nailp->xa_log_flush = 0;\r\ntout = 50;\r\n} else if (XFS_LSN_CMP(lsn, target) >= 0) {\r\ntout = 50;\r\nailp->xa_last_pushed_lsn = 0;\r\n} else if ((stuck * 100) / count > 90) {\r\ntout = 20;\r\nailp->xa_last_pushed_lsn = 0;\r\n}\r\nreturn tout;\r\n}\r\nstatic int\r\nxfsaild(\r\nvoid *data)\r\n{\r\nstruct xfs_ail *ailp = data;\r\nlong tout = 0;\r\nwhile (!kthread_should_stop()) {\r\nif (tout && tout <= 20)\r\n__set_current_state(TASK_KILLABLE);\r\nelse\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(tout ?\r\nmsecs_to_jiffies(tout) : MAX_SCHEDULE_TIMEOUT);\r\ntry_to_freeze();\r\ntout = xfsaild_push(ailp);\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_ail_push(\r\nstruct xfs_ail *ailp,\r\nxfs_lsn_t threshold_lsn)\r\n{\r\nxfs_log_item_t *lip;\r\nlip = xfs_ail_min(ailp);\r\nif (!lip || XFS_FORCED_SHUTDOWN(ailp->xa_mount) ||\r\nXFS_LSN_CMP(threshold_lsn, ailp->xa_target) <= 0)\r\nreturn;\r\nsmp_wmb();\r\nxfs_trans_ail_copy_lsn(ailp, &ailp->xa_target, &threshold_lsn);\r\nsmp_wmb();\r\nwake_up_process(ailp->xa_task);\r\n}\r\nvoid\r\nxfs_ail_push_all(\r\nstruct xfs_ail *ailp)\r\n{\r\nxfs_lsn_t threshold_lsn = xfs_ail_max_lsn(ailp);\r\nif (threshold_lsn)\r\nxfs_ail_push(ailp, threshold_lsn);\r\n}\r\nvoid\r\nxfs_trans_unlocked_item(\r\nstruct xfs_ail *ailp,\r\nxfs_log_item_t *lip)\r\n{\r\nxfs_log_item_t *min_lip;\r\nif (!(lip->li_flags & XFS_LI_IN_AIL) ||\r\nXFS_FORCED_SHUTDOWN(ailp->xa_mount)) {\r\nreturn;\r\n}\r\nmin_lip = xfs_ail_min(ailp);\r\nif (min_lip == lip)\r\nxfs_log_move_tail(ailp->xa_mount, 1);\r\n}\r\nvoid\r\nxfs_trans_ail_update_bulk(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_ail_cursor *cur,\r\nstruct xfs_log_item **log_items,\r\nint nr_items,\r\nxfs_lsn_t lsn) __releases(ailp->xa_lock)\r\n{\r\nxfs_log_item_t *mlip;\r\nxfs_lsn_t tail_lsn;\r\nint mlip_changed = 0;\r\nint i;\r\nLIST_HEAD(tmp);\r\nASSERT(nr_items > 0);\r\nmlip = xfs_ail_min(ailp);\r\nfor (i = 0; i < nr_items; i++) {\r\nstruct xfs_log_item *lip = log_items[i];\r\nif (lip->li_flags & XFS_LI_IN_AIL) {\r\nif (XFS_LSN_CMP(lsn, lip->li_lsn) <= 0)\r\ncontinue;\r\nxfs_ail_delete(ailp, lip);\r\nif (mlip == lip)\r\nmlip_changed = 1;\r\n} else {\r\nlip->li_flags |= XFS_LI_IN_AIL;\r\n}\r\nlip->li_lsn = lsn;\r\nlist_add(&lip->li_ail, &tmp);\r\n}\r\nif (!list_empty(&tmp))\r\nxfs_ail_splice(ailp, cur, &tmp, lsn);\r\nif (!mlip_changed) {\r\nspin_unlock(&ailp->xa_lock);\r\nreturn;\r\n}\r\nmlip = xfs_ail_min(ailp);\r\ntail_lsn = mlip->li_lsn;\r\nspin_unlock(&ailp->xa_lock);\r\nxfs_log_move_tail(ailp->xa_mount, tail_lsn);\r\n}\r\nvoid\r\nxfs_trans_ail_delete_bulk(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_log_item **log_items,\r\nint nr_items) __releases(ailp->xa_lock)\r\n{\r\nxfs_log_item_t *mlip;\r\nxfs_lsn_t tail_lsn;\r\nint mlip_changed = 0;\r\nint i;\r\nmlip = xfs_ail_min(ailp);\r\nfor (i = 0; i < nr_items; i++) {\r\nstruct xfs_log_item *lip = log_items[i];\r\nif (!(lip->li_flags & XFS_LI_IN_AIL)) {\r\nstruct xfs_mount *mp = ailp->xa_mount;\r\nspin_unlock(&ailp->xa_lock);\r\nif (!XFS_FORCED_SHUTDOWN(mp)) {\r\nxfs_alert_tag(mp, XFS_PTAG_AILDELETE,\r\n"%s: attempting to delete a log item that is not in the AIL",\r\n__func__);\r\nxfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\r\n}\r\nreturn;\r\n}\r\nxfs_ail_delete(ailp, lip);\r\nlip->li_flags &= ~XFS_LI_IN_AIL;\r\nlip->li_lsn = 0;\r\nif (mlip == lip)\r\nmlip_changed = 1;\r\n}\r\nif (!mlip_changed) {\r\nspin_unlock(&ailp->xa_lock);\r\nreturn;\r\n}\r\nmlip = xfs_ail_min(ailp);\r\ntail_lsn = mlip ? mlip->li_lsn : 0;\r\nspin_unlock(&ailp->xa_lock);\r\nxfs_log_move_tail(ailp->xa_mount, tail_lsn);\r\n}\r\nint\r\nxfs_trans_ail_init(\r\nxfs_mount_t *mp)\r\n{\r\nstruct xfs_ail *ailp;\r\nailp = kmem_zalloc(sizeof(struct xfs_ail), KM_MAYFAIL);\r\nif (!ailp)\r\nreturn ENOMEM;\r\nailp->xa_mount = mp;\r\nINIT_LIST_HEAD(&ailp->xa_ail);\r\nINIT_LIST_HEAD(&ailp->xa_cursors);\r\nspin_lock_init(&ailp->xa_lock);\r\nailp->xa_task = kthread_run(xfsaild, ailp, "xfsaild/%s",\r\nailp->xa_mount->m_fsname);\r\nif (IS_ERR(ailp->xa_task))\r\ngoto out_free_ailp;\r\nmp->m_ail = ailp;\r\nreturn 0;\r\nout_free_ailp:\r\nkmem_free(ailp);\r\nreturn ENOMEM;\r\n}\r\nvoid\r\nxfs_trans_ail_destroy(\r\nxfs_mount_t *mp)\r\n{\r\nstruct xfs_ail *ailp = mp->m_ail;\r\nkthread_stop(ailp->xa_task);\r\nkmem_free(ailp);\r\n}
