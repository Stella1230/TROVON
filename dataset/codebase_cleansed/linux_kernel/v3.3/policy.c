static const char *hname_tail(const char *hname)\r\n{\r\nchar *split;\r\nhname = strim((char *)hname);\r\nfor (split = strstr(hname, "//"); split; split = strstr(hname, "//"))\r\nhname = split + 2;\r\nreturn hname;\r\n}\r\nstatic bool policy_init(struct aa_policy *policy, const char *prefix,\r\nconst char *name)\r\n{\r\nif (prefix) {\r\npolicy->hname = kmalloc(strlen(prefix) + strlen(name) + 3,\r\nGFP_KERNEL);\r\nif (policy->hname)\r\nsprintf(policy->hname, "%s//%s", prefix, name);\r\n} else\r\npolicy->hname = kstrdup(name, GFP_KERNEL);\r\nif (!policy->hname)\r\nreturn 0;\r\npolicy->name = (char *)hname_tail(policy->hname);\r\nINIT_LIST_HEAD(&policy->list);\r\nINIT_LIST_HEAD(&policy->profiles);\r\nkref_init(&policy->count);\r\nreturn 1;\r\n}\r\nstatic void policy_destroy(struct aa_policy *policy)\r\n{\r\nif (!list_empty(&policy->profiles)) {\r\nAA_ERROR("%s: internal error, "\r\n"policy '%s' still contains profiles\n",\r\n__func__, policy->name);\r\nBUG();\r\n}\r\nif (!list_empty(&policy->list)) {\r\nAA_ERROR("%s: internal error, policy '%s' still on list\n",\r\n__func__, policy->name);\r\nBUG();\r\n}\r\nkzfree(policy->hname);\r\n}\r\nstatic struct aa_policy *__policy_find(struct list_head *head, const char *name)\r\n{\r\nstruct aa_policy *policy;\r\nlist_for_each_entry(policy, head, list) {\r\nif (!strcmp(policy->name, name))\r\nreturn policy;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct aa_policy *__policy_strn_find(struct list_head *head,\r\nconst char *str, int len)\r\n{\r\nstruct aa_policy *policy;\r\nlist_for_each_entry(policy, head, list) {\r\nif (aa_strneq(policy->name, str, len))\r\nreturn policy;\r\n}\r\nreturn NULL;\r\n}\r\nbool aa_ns_visible(struct aa_namespace *curr, struct aa_namespace *view)\r\n{\r\nif (curr == view)\r\nreturn true;\r\nfor ( ; view; view = view->parent) {\r\nif (view->parent == curr)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nconst char *aa_ns_name(struct aa_namespace *curr, struct aa_namespace *view)\r\n{\r\nif (curr == view)\r\nreturn "";\r\nif (aa_ns_visible(curr, view)) {\r\nreturn view->base.hname + strlen(curr->base.hname) + 2;\r\n} else\r\nreturn hidden_ns_name;\r\n}\r\nstatic struct aa_namespace *alloc_namespace(const char *prefix,\r\nconst char *name)\r\n{\r\nstruct aa_namespace *ns;\r\nns = kzalloc(sizeof(*ns), GFP_KERNEL);\r\nAA_DEBUG("%s(%p)\n", __func__, ns);\r\nif (!ns)\r\nreturn NULL;\r\nif (!policy_init(&ns->base, prefix, name))\r\ngoto fail_ns;\r\nINIT_LIST_HEAD(&ns->sub_ns);\r\nrwlock_init(&ns->lock);\r\nns->unconfined = aa_alloc_profile("unconfined");\r\nif (!ns->unconfined)\r\ngoto fail_unconfined;\r\nns->unconfined->sid = aa_alloc_sid();\r\nns->unconfined->flags = PFLAG_UNCONFINED | PFLAG_IX_ON_NAME_ERROR |\r\nPFLAG_IMMUTABLE;\r\nns->unconfined->ns = aa_get_namespace(ns);\r\nreturn ns;\r\nfail_unconfined:\r\nkzfree(ns->base.hname);\r\nfail_ns:\r\nkzfree(ns);\r\nreturn NULL;\r\n}\r\nstatic void free_namespace(struct aa_namespace *ns)\r\n{\r\nif (!ns)\r\nreturn;\r\npolicy_destroy(&ns->base);\r\naa_put_namespace(ns->parent);\r\nif (ns->unconfined && ns->unconfined->ns == ns)\r\nns->unconfined->ns = NULL;\r\naa_put_profile(ns->unconfined);\r\nkzfree(ns);\r\n}\r\nvoid aa_free_namespace_kref(struct kref *kref)\r\n{\r\nfree_namespace(container_of(kref, struct aa_namespace, base.count));\r\n}\r\nstatic struct aa_namespace *__aa_find_namespace(struct list_head *head,\r\nconst char *name)\r\n{\r\nreturn (struct aa_namespace *)__policy_find(head, name);\r\n}\r\nstruct aa_namespace *aa_find_namespace(struct aa_namespace *root,\r\nconst char *name)\r\n{\r\nstruct aa_namespace *ns = NULL;\r\nread_lock(&root->lock);\r\nns = aa_get_namespace(__aa_find_namespace(&root->sub_ns, name));\r\nread_unlock(&root->lock);\r\nreturn ns;\r\n}\r\nstatic struct aa_namespace *aa_prepare_namespace(const char *name)\r\n{\r\nstruct aa_namespace *ns, *root;\r\nroot = aa_current_profile()->ns;\r\nwrite_lock(&root->lock);\r\nif (!name) {\r\nns = aa_get_namespace(root);\r\ngoto out;\r\n}\r\nns = aa_get_namespace(__aa_find_namespace(&root->sub_ns, name));\r\nif (!ns) {\r\nstruct aa_namespace *new_ns;\r\nwrite_unlock(&root->lock);\r\nnew_ns = alloc_namespace(root->base.hname, name);\r\nif (!new_ns)\r\nreturn NULL;\r\nwrite_lock(&root->lock);\r\nns = __aa_find_namespace(&root->sub_ns, name);\r\nif (!ns) {\r\nnew_ns->parent = aa_get_namespace(root);\r\nlist_add(&new_ns->base.list, &root->sub_ns);\r\nns = aa_get_namespace(new_ns);\r\n} else {\r\nfree_namespace(new_ns);\r\naa_get_namespace(ns);\r\n}\r\n}\r\nout:\r\nwrite_unlock(&root->lock);\r\nreturn ns;\r\n}\r\nstatic void __list_add_profile(struct list_head *list,\r\nstruct aa_profile *profile)\r\n{\r\nlist_add(&profile->base.list, list);\r\naa_get_profile(profile);\r\n}\r\nstatic void __list_remove_profile(struct aa_profile *profile)\r\n{\r\nlist_del_init(&profile->base.list);\r\nif (!(profile->flags & PFLAG_NO_LIST_REF))\r\naa_put_profile(profile);\r\n}\r\nstatic void __replace_profile(struct aa_profile *old, struct aa_profile *new)\r\n{\r\nstruct aa_policy *policy;\r\nstruct aa_profile *child, *tmp;\r\nif (old->parent)\r\npolicy = &old->parent->base;\r\nelse\r\npolicy = &old->ns->base;\r\nnew->parent = aa_get_profile(old->parent);\r\nnew->ns = aa_get_namespace(old->ns);\r\nnew->sid = old->sid;\r\n__list_add_profile(&policy->profiles, new);\r\nlist_for_each_entry_safe(child, tmp, &old->base.profiles, base.list) {\r\naa_put_profile(child->parent);\r\nchild->parent = aa_get_profile(new);\r\nlist_move(&child->base.list, &new->base.profiles);\r\n}\r\nold->replacedby = aa_get_profile(new);\r\n__list_remove_profile(old);\r\n}\r\nstatic void __remove_profile(struct aa_profile *profile)\r\n{\r\n__profile_list_release(&profile->base.profiles);\r\nprofile->replacedby = aa_get_profile(profile->ns->unconfined);\r\n__list_remove_profile(profile);\r\n}\r\nstatic void __profile_list_release(struct list_head *head)\r\n{\r\nstruct aa_profile *profile, *tmp;\r\nlist_for_each_entry_safe(profile, tmp, head, base.list)\r\n__remove_profile(profile);\r\n}\r\nstatic void destroy_namespace(struct aa_namespace *ns)\r\n{\r\nif (!ns)\r\nreturn;\r\nwrite_lock(&ns->lock);\r\n__profile_list_release(&ns->base.profiles);\r\n__ns_list_release(&ns->sub_ns);\r\nwrite_unlock(&ns->lock);\r\n}\r\nstatic void __remove_namespace(struct aa_namespace *ns)\r\n{\r\nstruct aa_profile *unconfined = ns->unconfined;\r\nlist_del_init(&ns->base.list);\r\nif (ns->parent)\r\nns->unconfined = aa_get_profile(ns->parent->unconfined);\r\ndestroy_namespace(ns);\r\naa_put_profile(unconfined);\r\naa_put_namespace(ns);\r\n}\r\nstatic void __ns_list_release(struct list_head *head)\r\n{\r\nstruct aa_namespace *ns, *tmp;\r\nlist_for_each_entry_safe(ns, tmp, head, base.list)\r\n__remove_namespace(ns);\r\n}\r\nint __init aa_alloc_root_ns(void)\r\n{\r\nroot_ns = alloc_namespace(NULL, "root");\r\nif (!root_ns)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid __init aa_free_root_ns(void)\r\n{\r\nstruct aa_namespace *ns = root_ns;\r\nroot_ns = NULL;\r\ndestroy_namespace(ns);\r\naa_put_namespace(ns);\r\n}\r\nstruct aa_profile *aa_alloc_profile(const char *hname)\r\n{\r\nstruct aa_profile *profile;\r\nprofile = kzalloc(sizeof(*profile), GFP_KERNEL);\r\nif (!profile)\r\nreturn NULL;\r\nif (!policy_init(&profile->base, NULL, hname)) {\r\nkzfree(profile);\r\nreturn NULL;\r\n}\r\nreturn profile;\r\n}\r\nstruct aa_profile *aa_new_null_profile(struct aa_profile *parent, int hat)\r\n{\r\nstruct aa_profile *profile = NULL;\r\nchar *name;\r\nu32 sid = aa_alloc_sid();\r\nname = kmalloc(strlen(parent->base.hname) + 2 + 7 + 8, GFP_KERNEL);\r\nif (!name)\r\ngoto fail;\r\nsprintf(name, "%s//null-%x", parent->base.hname, sid);\r\nprofile = aa_alloc_profile(name);\r\nkfree(name);\r\nif (!profile)\r\ngoto fail;\r\nprofile->sid = sid;\r\nprofile->mode = APPARMOR_COMPLAIN;\r\nprofile->flags = PFLAG_NULL;\r\nif (hat)\r\nprofile->flags |= PFLAG_HAT;\r\nprofile->parent = aa_get_profile(parent);\r\nprofile->ns = aa_get_namespace(parent->ns);\r\nwrite_lock(&profile->ns->lock);\r\n__list_add_profile(&parent->base.profiles, profile);\r\nwrite_unlock(&profile->ns->lock);\r\nreturn profile;\r\nfail:\r\naa_free_sid(sid);\r\nreturn NULL;\r\n}\r\nstatic void free_profile(struct aa_profile *profile)\r\n{\r\nAA_DEBUG("%s(%p)\n", __func__, profile);\r\nif (!profile)\r\nreturn;\r\nif (!list_empty(&profile->base.list)) {\r\nAA_ERROR("%s: internal error, "\r\n"profile '%s' still on ns list\n",\r\n__func__, profile->base.name);\r\nBUG();\r\n}\r\npolicy_destroy(&profile->base);\r\naa_put_profile(profile->parent);\r\naa_put_namespace(profile->ns);\r\nkzfree(profile->rename);\r\naa_free_file_rules(&profile->file);\r\naa_free_cap_rules(&profile->caps);\r\naa_free_rlimit_rules(&profile->rlimits);\r\naa_free_sid(profile->sid);\r\naa_put_dfa(profile->xmatch);\r\naa_put_profile(profile->replacedby);\r\nkzfree(profile);\r\n}\r\nvoid aa_free_profile_kref(struct kref *kref)\r\n{\r\nstruct aa_profile *p = container_of(kref, struct aa_profile,\r\nbase.count);\r\nfree_profile(p);\r\n}\r\nstatic struct aa_profile *__find_child(struct list_head *head, const char *name)\r\n{\r\nreturn (struct aa_profile *)__policy_find(head, name);\r\n}\r\nstatic struct aa_profile *__strn_find_child(struct list_head *head,\r\nconst char *name, int len)\r\n{\r\nreturn (struct aa_profile *)__policy_strn_find(head, name, len);\r\n}\r\nstruct aa_profile *aa_find_child(struct aa_profile *parent, const char *name)\r\n{\r\nstruct aa_profile *profile;\r\nread_lock(&parent->ns->lock);\r\nprofile = aa_get_profile(__find_child(&parent->base.profiles, name));\r\nread_unlock(&parent->ns->lock);\r\nreturn profile;\r\n}\r\nstatic struct aa_policy *__lookup_parent(struct aa_namespace *ns,\r\nconst char *hname)\r\n{\r\nstruct aa_policy *policy;\r\nstruct aa_profile *profile = NULL;\r\nchar *split;\r\npolicy = &ns->base;\r\nfor (split = strstr(hname, "//"); split;) {\r\nprofile = __strn_find_child(&policy->profiles, hname,\r\nsplit - hname);\r\nif (!profile)\r\nreturn NULL;\r\npolicy = &profile->base;\r\nhname = split + 2;\r\nsplit = strstr(hname, "//");\r\n}\r\nif (!profile)\r\nreturn &ns->base;\r\nreturn &profile->base;\r\n}\r\nstatic struct aa_profile *__lookup_profile(struct aa_policy *base,\r\nconst char *hname)\r\n{\r\nstruct aa_profile *profile = NULL;\r\nchar *split;\r\nfor (split = strstr(hname, "//"); split;) {\r\nprofile = __strn_find_child(&base->profiles, hname,\r\nsplit - hname);\r\nif (!profile)\r\nreturn NULL;\r\nbase = &profile->base;\r\nhname = split + 2;\r\nsplit = strstr(hname, "//");\r\n}\r\nprofile = __find_child(&base->profiles, hname);\r\nreturn profile;\r\n}\r\nstruct aa_profile *aa_lookup_profile(struct aa_namespace *ns, const char *hname)\r\n{\r\nstruct aa_profile *profile;\r\nread_lock(&ns->lock);\r\nprofile = aa_get_profile(__lookup_profile(&ns->base, hname));\r\nread_unlock(&ns->lock);\r\nreturn profile;\r\n}\r\nstatic int replacement_allowed(struct aa_profile *profile, int noreplace,\r\nconst char **info)\r\n{\r\nif (profile) {\r\nif (profile->flags & PFLAG_IMMUTABLE) {\r\n*info = "cannot replace immutible profile";\r\nreturn -EPERM;\r\n} else if (noreplace) {\r\n*info = "profile already exists";\r\nreturn -EEXIST;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void __add_new_profile(struct aa_namespace *ns, struct aa_policy *policy,\r\nstruct aa_profile *profile)\r\n{\r\nif (policy != &ns->base)\r\nprofile->parent = aa_get_profile((struct aa_profile *) policy);\r\n__list_add_profile(&policy->profiles, profile);\r\nprofile->sid = aa_alloc_sid();\r\nprofile->ns = aa_get_namespace(ns);\r\n}\r\nstatic int audit_policy(int op, gfp_t gfp, const char *name, const char *info,\r\nint error)\r\n{\r\nstruct common_audit_data sa;\r\nCOMMON_AUDIT_DATA_INIT(&sa, NONE);\r\nsa.aad.op = op;\r\nsa.aad.name = name;\r\nsa.aad.info = info;\r\nsa.aad.error = error;\r\nreturn aa_audit(AUDIT_APPARMOR_STATUS, __aa_current_profile(), gfp,\r\n&sa, NULL);\r\n}\r\nbool aa_may_manage_policy(int op)\r\n{\r\nif (aa_g_lock_policy) {\r\naudit_policy(op, GFP_KERNEL, NULL, "policy_locked", -EACCES);\r\nreturn 0;\r\n}\r\nif (!capable(CAP_MAC_ADMIN)) {\r\naudit_policy(op, GFP_KERNEL, NULL, "not policy admin", -EACCES);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nssize_t aa_replace_profiles(void *udata, size_t size, bool noreplace)\r\n{\r\nstruct aa_policy *policy;\r\nstruct aa_profile *old_profile = NULL, *new_profile = NULL;\r\nstruct aa_profile *rename_profile = NULL;\r\nstruct aa_namespace *ns = NULL;\r\nconst char *ns_name, *name = NULL, *info = NULL;\r\nint op = OP_PROF_REPL;\r\nssize_t error;\r\nnew_profile = aa_unpack(udata, size, &ns_name);\r\nif (IS_ERR(new_profile)) {\r\nerror = PTR_ERR(new_profile);\r\nnew_profile = NULL;\r\ngoto fail;\r\n}\r\nns = aa_prepare_namespace(ns_name);\r\nif (!ns) {\r\ninfo = "failed to prepare namespace";\r\nerror = -ENOMEM;\r\nname = ns_name;\r\ngoto fail;\r\n}\r\nname = new_profile->base.hname;\r\nwrite_lock(&ns->lock);\r\npolicy = __lookup_parent(ns, new_profile->base.hname);\r\nif (!policy) {\r\ninfo = "parent does not exist";\r\nerror = -ENOENT;\r\ngoto audit;\r\n}\r\nold_profile = __find_child(&policy->profiles, new_profile->base.name);\r\naa_get_profile(old_profile);\r\nif (new_profile->rename) {\r\nrename_profile = __lookup_profile(&ns->base,\r\nnew_profile->rename);\r\naa_get_profile(rename_profile);\r\nif (!rename_profile) {\r\ninfo = "profile to rename does not exist";\r\nname = new_profile->rename;\r\nerror = -ENOENT;\r\ngoto audit;\r\n}\r\n}\r\nerror = replacement_allowed(old_profile, noreplace, &info);\r\nif (error)\r\ngoto audit;\r\nerror = replacement_allowed(rename_profile, noreplace, &info);\r\nif (error)\r\ngoto audit;\r\naudit:\r\nif (!old_profile && !rename_profile)\r\nop = OP_PROF_LOAD;\r\nerror = audit_policy(op, GFP_ATOMIC, name, info, error);\r\nif (!error) {\r\nif (rename_profile)\r\n__replace_profile(rename_profile, new_profile);\r\nif (old_profile) {\r\nif (rename_profile)\r\naa_free_sid(new_profile->sid);\r\n__replace_profile(old_profile, new_profile);\r\n}\r\nif (!(old_profile || rename_profile))\r\n__add_new_profile(ns, policy, new_profile);\r\n}\r\nwrite_unlock(&ns->lock);\r\nout:\r\naa_put_namespace(ns);\r\naa_put_profile(rename_profile);\r\naa_put_profile(old_profile);\r\naa_put_profile(new_profile);\r\nif (error)\r\nreturn error;\r\nreturn size;\r\nfail:\r\nerror = audit_policy(op, GFP_KERNEL, name, info, error);\r\ngoto out;\r\n}\r\nssize_t aa_remove_profiles(char *fqname, size_t size)\r\n{\r\nstruct aa_namespace *root, *ns = NULL;\r\nstruct aa_profile *profile = NULL;\r\nconst char *name = fqname, *info = NULL;\r\nssize_t error = 0;\r\nif (*fqname == 0) {\r\ninfo = "no profile specified";\r\nerror = -ENOENT;\r\ngoto fail;\r\n}\r\nroot = aa_current_profile()->ns;\r\nif (fqname[0] == ':') {\r\nchar *ns_name;\r\nname = aa_split_fqname(fqname, &ns_name);\r\nif (ns_name) {\r\nns = aa_find_namespace(root, ns_name);\r\nif (!ns) {\r\ninfo = "namespace does not exist";\r\nerror = -ENOENT;\r\ngoto fail;\r\n}\r\n}\r\n} else\r\nns = aa_get_namespace(root);\r\nif (!name) {\r\nwrite_lock(&ns->parent->lock);\r\n__remove_namespace(ns);\r\nwrite_unlock(&ns->parent->lock);\r\n} else {\r\nwrite_lock(&ns->lock);\r\nprofile = aa_get_profile(__lookup_profile(&ns->base, name));\r\nif (!profile) {\r\nerror = -ENOENT;\r\ninfo = "profile does not exist";\r\ngoto fail_ns_lock;\r\n}\r\nname = profile->base.hname;\r\n__remove_profile(profile);\r\nwrite_unlock(&ns->lock);\r\n}\r\n(void) audit_policy(OP_PROF_RM, GFP_KERNEL, name, info, error);\r\naa_put_namespace(ns);\r\naa_put_profile(profile);\r\nreturn size;\r\nfail_ns_lock:\r\nwrite_unlock(&ns->lock);\r\naa_put_namespace(ns);\r\nfail:\r\n(void) audit_policy(OP_PROF_RM, GFP_KERNEL, name, info, error);\r\nreturn error;\r\n}
