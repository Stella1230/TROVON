static int pci20xxx_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nunsigned char i;\r\nint ret;\r\nint id;\r\nstruct comedi_subdevice *s;\r\nunion pci20xxx_subdev_private *sdp;\r\nret = alloc_subdevices(dev, 1 + PCI20000_MODULES);\r\nif (ret < 0)\r\nreturn ret;\r\nret = alloc_private(dev, sizeof(struct pci20xxx_private));\r\nif (ret < 0)\r\nreturn ret;\r\ndevpriv->ioaddr = (void *)(unsigned long)it->options[0];\r\ndev->board_name = "pci20kc";\r\nif ((readb(devpriv->ioaddr) & PCI20000_ID) != PCI20000_ID) {\r\nprintk(KERN_WARNING "comedi%d: ii_pci20kc PCI-20001"\r\n" C-2A Carrier Board at base=0x%p not found !\n",\r\ndev->minor, devpriv->ioaddr);\r\nreturn -EINVAL;\r\n}\r\nprintk(KERN_INFO "comedi%d: ii_pci20kc: PCI-20001 C-2A at base=0x%p\n",\r\ndev->minor, devpriv->ioaddr);\r\nfor (i = 0; i < PCI20000_MODULES; i++) {\r\ns = dev->subdevices + i;\r\nid = readb(devpriv->ioaddr + (i + 1) * PCI20000_OFFSET);\r\ns->private = devpriv->subdev_private + i;\r\nsdp = s->private;\r\nswitch (id) {\r\ncase PCI20006_ID:\r\nsdp->pci20006.iobase =\r\ndevpriv->ioaddr + (i + 1) * PCI20000_OFFSET;\r\npci20006_init(dev, s, it->options[2 * i + 2],\r\nit->options[2 * i + 3]);\r\nprintk(KERN_INFO "comedi%d: "\r\n"ii_pci20kc PCI-20006 module in slot %d\n",\r\ndev->minor, i + 1);\r\nbreak;\r\ncase PCI20341_ID:\r\nsdp->pci20341.iobase =\r\ndevpriv->ioaddr + (i + 1) * PCI20000_OFFSET;\r\npci20341_init(dev, s, it->options[2 * i + 2],\r\nit->options[2 * i + 3]);\r\nprintk(KERN_INFO "comedi%d: "\r\n"ii_pci20kc PCI-20341 module in slot %d\n",\r\ndev->minor, i + 1);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "ii_pci20kc: unknown module "\r\n"code 0x%02x in slot %d: module disabled\n",\r\nid, i);\r\ncase PCI20xxx_EMPTY_ID:\r\ns->type = COMEDI_SUBD_UNUSED;\r\nbreak;\r\n}\r\n}\r\npci20xxx_dio_init(dev, dev->subdevices + PCI20000_MODULES);\r\nreturn 1;\r\n}\r\nstatic int pci20xxx_detach(struct comedi_device *dev)\r\n{\r\nprintk(KERN_INFO "comedi%d: pci20xxx: remove\n", dev->minor);\r\nreturn 0;\r\n}\r\nstatic int pci20006_init(struct comedi_device *dev, struct comedi_subdevice *s,\r\nint opt0, int opt1)\r\n{\r\nunion pci20xxx_subdev_private *sdp = s->private;\r\nif (opt0 < 0 || opt0 > 2)\r\nopt0 = 0;\r\nif (opt1 < 0 || opt1 > 2)\r\nopt1 = 0;\r\nsdp->pci20006.ao_range_list[0] = pci20006_range_list[opt0];\r\nsdp->pci20006.ao_range_list[1] = pci20006_range_list[opt1];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 2;\r\ns->len_chanlist = 2;\r\ns->insn_read = pci20006_insn_read;\r\ns->insn_write = pci20006_insn_write;\r\ns->maxdata = 0xffff;\r\ns->range_table_list = sdp->pci20006.ao_range_list;\r\nreturn 0;\r\n}\r\nstatic int pci20006_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunion pci20xxx_subdev_private *sdp = s->private;\r\ndata[0] = sdp->pci20006.last_data[CR_CHAN(insn->chanspec)];\r\nreturn 1;\r\n}\r\nstatic int pci20006_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunion pci20xxx_subdev_private *sdp = s->private;\r\nint hi, lo;\r\nunsigned int boarddata;\r\nsdp->pci20006.last_data[CR_CHAN(insn->chanspec)] = data[0];\r\nboarddata = (((unsigned int)data[0] + 0x8000) & 0xffff);\r\nlo = (boarddata & 0xff);\r\nhi = ((boarddata >> 8) & 0xff);\r\nswitch (CR_CHAN(insn->chanspec)) {\r\ncase 0:\r\nwriteb(lo, sdp->iobase + PCI20006_LCHAN0);\r\nwriteb(hi, sdp->iobase + PCI20006_LCHAN0 + 1);\r\nwriteb(0x00, sdp->iobase + PCI20006_STROBE0);\r\nbreak;\r\ncase 1:\r\nwriteb(lo, sdp->iobase + PCI20006_LCHAN1);\r\nwriteb(hi, sdp->iobase + PCI20006_LCHAN1 + 1);\r\nwriteb(0x00, sdp->iobase + PCI20006_STROBE1);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n" comedi%d: pci20xxx: ao channel Error!\n", dev->minor);\r\nreturn -EINVAL;\r\n}\r\nreturn 1;\r\n}\r\nstatic int pci20341_init(struct comedi_device *dev, struct comedi_subdevice *s,\r\nint opt0, int opt1)\r\n{\r\nunion pci20xxx_subdev_private *sdp = s->private;\r\nint option;\r\nif (opt0 < 0 || opt0 > 3)\r\nopt0 = 0;\r\nsdp->pci20341.timebase = pci20341_timebase[opt0];\r\nsdp->pci20341.settling_time = pci20341_settling_time[opt0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = PCI20341_CHAN_NR;\r\ns->len_chanlist = PCI20341_SCANLIST;\r\ns->insn_read = pci20341_insn_read;\r\ns->maxdata = 0xffff;\r\ns->range_table = pci20341_ranges[opt0];\r\noption = sdp->pci20341.timebase | PCI20341_REPMODE;\r\nwriteb(PCI20341_INIT, sdp->iobase + PCI20341_CONFIG_REG);\r\nwriteb(PCI20341_PACER, sdp->iobase + PCI20341_MOD_STATUS);\r\nwriteb(option, sdp->iobase + PCI20341_OPT_REG);\r\nwriteb(sdp->pci20341.settling_time,\r\nsdp->iobase + PCI20341_SET_TIME_REG);\r\nreturn 0;\r\n}\r\nstatic int pci20341_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunion pci20xxx_subdev_private *sdp = s->private;\r\nunsigned int i = 0, j = 0;\r\nint lo, hi;\r\nunsigned char eoc;\r\nunsigned int clb;\r\nunsigned int boarddata;\r\nwriteb(1, sdp->iobase + PCI20341_LCHAN_ADDR_REG);\r\nclb = PCI20341_DAISY_CHAIN | PCI20341_MUX | (sdp->pci20341.ai_gain << 3)\r\n| CR_CHAN(insn->chanspec);\r\nwriteb(clb, sdp->iobase + PCI20341_CHAN_LIST);\r\nwriteb(0x00, sdp->iobase + PCI20341_CC_RESET);\r\nwriteb(0x00, sdp->iobase + PCI20341_CHAN_RESET);\r\nfor (i = 0; i < insn->n; i++) {\r\nj = 0;\r\nreadb(sdp->iobase + PCI20341_SOFT_PACER);\r\neoc = readb(sdp->iobase + PCI20341_STATUS_REG);\r\nwhile ((eoc < 0x80) && j < 100) {\r\nj++;\r\neoc = readb(sdp->iobase + PCI20341_STATUS_REG);\r\n}\r\nif (j >= 100) {\r\nprintk(KERN_WARNING\r\n"comedi%d: pci20xxx: "\r\n"AI interrupt channel %i polling exit !\n",\r\ndev->minor, i);\r\nreturn -EINVAL;\r\n}\r\nlo = readb(sdp->iobase + PCI20341_LDATA);\r\nhi = readb(sdp->iobase + PCI20341_LDATA + 1);\r\nboarddata = lo + 0x100 * hi;\r\ndata[i] = (short)((boarddata + 0x8000) & 0xffff);\r\n}\r\nreturn i;\r\n}\r\nstatic int pci20xxx_dio_init(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 32;\r\ns->insn_bits = pci20xxx_dio_insn_bits;\r\ns->insn_config = pci20xxx_dio_insn_config;\r\ns->maxdata = 1;\r\ns->len_chanlist = 32;\r\ns->range_table = &range_digital;\r\ns->io_bits = 0;\r\npci20xxx_dio_config(dev, s);\r\nreturn 0;\r\n}\r\nstatic int pci20xxx_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint mask, bits;\r\nmask = 1 << CR_CHAN(insn->chanspec);\r\nif (mask & 0x000000ff)\r\nbits = 0x000000ff;\r\nelse if (mask & 0x0000ff00)\r\nbits = 0x0000ff00;\r\nelse if (mask & 0x00ff0000)\r\nbits = 0x00ff0000;\r\nelse\r\nbits = 0xff000000;\r\nif (data[0])\r\ns->io_bits |= bits;\r\nelse\r\ns->io_bits &= ~bits;\r\npci20xxx_dio_config(dev, s);\r\nreturn 1;\r\n}\r\nstatic int pci20xxx_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int mask = data[0];\r\ns->state &= ~mask;\r\ns->state |= (mask & data[1]);\r\nmask &= s->io_bits;\r\nif (mask & 0x000000ff)\r\nwriteb((s->state >> 0) & 0xff,\r\ndevpriv->ioaddr + PCI20000_DIO_0);\r\nif (mask & 0x0000ff00)\r\nwriteb((s->state >> 8) & 0xff,\r\ndevpriv->ioaddr + PCI20000_DIO_1);\r\nif (mask & 0x00ff0000)\r\nwriteb((s->state >> 16) & 0xff,\r\ndevpriv->ioaddr + PCI20000_DIO_2);\r\nif (mask & 0xff000000)\r\nwriteb((s->state >> 24) & 0xff,\r\ndevpriv->ioaddr + PCI20000_DIO_3);\r\ndata[1] = readb(devpriv->ioaddr + PCI20000_DIO_0);\r\ndata[1] |= readb(devpriv->ioaddr + PCI20000_DIO_1) << 8;\r\ndata[1] |= readb(devpriv->ioaddr + PCI20000_DIO_2) << 16;\r\ndata[1] |= readb(devpriv->ioaddr + PCI20000_DIO_3) << 24;\r\nreturn 2;\r\n}\r\nstatic void pci20xxx_dio_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned char control_01;\r\nunsigned char control_23;\r\nunsigned char buffer;\r\ncontrol_01 = readb(devpriv->ioaddr + PCI20000_DIO_CONTROL_01);\r\ncontrol_23 = readb(devpriv->ioaddr + PCI20000_DIO_CONTROL_23);\r\nbuffer = readb(devpriv->ioaddr + PCI20000_DIO_BUFFER);\r\nif (s->io_bits & 0x000000ff) {\r\ncontrol_01 &= PCI20000_DIO_EOC;\r\nbuffer = (buffer & (~(DIO_BE << DIO_PS_0))) | (DIO_BO <<\r\nDIO_PS_0);\r\n} else {\r\ncontrol_01 = (control_01 & DIO_CAND) | PCI20000_DIO_EIC;\r\nbuffer = (buffer & (~(DIO_BI << DIO_PS_0)));\r\n}\r\nif (s->io_bits & 0x0000ff00) {\r\ncontrol_01 &= PCI20000_DIO_OOC;\r\nbuffer = (buffer & (~(DIO_BE << DIO_PS_1))) | (DIO_BO <<\r\nDIO_PS_1);\r\n} else {\r\ncontrol_01 = (control_01 & DIO_CAND) | PCI20000_DIO_OIC;\r\nbuffer = (buffer & (~(DIO_BI << DIO_PS_1)));\r\n}\r\nif (s->io_bits & 0x00ff0000) {\r\ncontrol_23 &= PCI20000_DIO_EOC;\r\nbuffer = (buffer & (~(DIO_BE << DIO_PS_2))) | (DIO_BO <<\r\nDIO_PS_2);\r\n} else {\r\ncontrol_23 = (control_23 & DIO_CAND) | PCI20000_DIO_EIC;\r\nbuffer = (buffer & (~(DIO_BI << DIO_PS_2)));\r\n}\r\nif (s->io_bits & 0xff000000) {\r\ncontrol_23 &= PCI20000_DIO_OOC;\r\nbuffer = (buffer & (~(DIO_BE << DIO_PS_3))) | (DIO_BO <<\r\nDIO_PS_3);\r\n} else {\r\ncontrol_23 = (control_23 & DIO_CAND) | PCI20000_DIO_OIC;\r\nbuffer = (buffer & (~(DIO_BI << DIO_PS_3)));\r\n}\r\nwriteb(control_01, devpriv->ioaddr + PCI20000_DIO_CONTROL_01);\r\nwriteb(control_23, devpriv->ioaddr + PCI20000_DIO_CONTROL_23);\r\nwriteb(buffer, devpriv->ioaddr + PCI20000_DIO_BUFFER);\r\n}\r\nstatic int __init driver_pci20xxx_init_module(void)\r\n{\r\nreturn comedi_driver_register(&driver_pci20xxx);\r\n}\r\nstatic void __exit driver_pci20xxx_cleanup_module(void)\r\n{\r\ncomedi_driver_unregister(&driver_pci20xxx);\r\n}
