static int __adp5520_read(struct i2c_client *client,\r\nint reg, uint8_t *val)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed reading at 0x%02x\n", reg);\r\nreturn ret;\r\n}\r\n*val = (uint8_t)ret;\r\nreturn 0;\r\n}\r\nstatic int __adp5520_write(struct i2c_client *client,\r\nint reg, uint8_t val)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, reg, val);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed writing 0x%02x to 0x%02x\n",\r\nval, reg);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __adp5520_ack_bits(struct i2c_client *client, int reg,\r\nuint8_t bit_mask)\r\n{\r\nstruct adp5520_chip *chip = i2c_get_clientdata(client);\r\nuint8_t reg_val;\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nret = __adp5520_read(client, reg, &reg_val);\r\nif (!ret) {\r\nreg_val |= bit_mask;\r\nret = __adp5520_write(client, reg, reg_val);\r\n}\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nint adp5520_write(struct device *dev, int reg, uint8_t val)\r\n{\r\nreturn __adp5520_write(to_i2c_client(dev), reg, val);\r\n}\r\nint adp5520_read(struct device *dev, int reg, uint8_t *val)\r\n{\r\nreturn __adp5520_read(to_i2c_client(dev), reg, val);\r\n}\r\nint adp5520_set_bits(struct device *dev, int reg, uint8_t bit_mask)\r\n{\r\nstruct adp5520_chip *chip = dev_get_drvdata(dev);\r\nuint8_t reg_val;\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nret = __adp5520_read(chip->client, reg, &reg_val);\r\nif (!ret && ((reg_val & bit_mask) != bit_mask)) {\r\nreg_val |= bit_mask;\r\nret = __adp5520_write(chip->client, reg, reg_val);\r\n}\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nint adp5520_clr_bits(struct device *dev, int reg, uint8_t bit_mask)\r\n{\r\nstruct adp5520_chip *chip = dev_get_drvdata(dev);\r\nuint8_t reg_val;\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nret = __adp5520_read(chip->client, reg, &reg_val);\r\nif (!ret && (reg_val & bit_mask)) {\r\nreg_val &= ~bit_mask;\r\nret = __adp5520_write(chip->client, reg, reg_val);\r\n}\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nint adp5520_register_notifier(struct device *dev, struct notifier_block *nb,\r\nunsigned int events)\r\n{\r\nstruct adp5520_chip *chip = dev_get_drvdata(dev);\r\nif (chip->irq) {\r\nadp5520_set_bits(chip->dev, ADP5520_INTERRUPT_ENABLE,\r\nevents & (ADP5520_KP_IEN | ADP5520_KR_IEN |\r\nADP5520_OVP_IEN | ADP5520_CMPR_IEN));\r\nreturn blocking_notifier_chain_register(&chip->notifier_list,\r\nnb);\r\n}\r\nreturn -ENODEV;\r\n}\r\nint adp5520_unregister_notifier(struct device *dev, struct notifier_block *nb,\r\nunsigned int events)\r\n{\r\nstruct adp5520_chip *chip = dev_get_drvdata(dev);\r\nadp5520_clr_bits(chip->dev, ADP5520_INTERRUPT_ENABLE,\r\nevents & (ADP5520_KP_IEN | ADP5520_KR_IEN |\r\nADP5520_OVP_IEN | ADP5520_CMPR_IEN));\r\nreturn blocking_notifier_chain_unregister(&chip->notifier_list, nb);\r\n}\r\nstatic irqreturn_t adp5520_irq_thread(int irq, void *data)\r\n{\r\nstruct adp5520_chip *chip = data;\r\nunsigned int events;\r\nuint8_t reg_val;\r\nint ret;\r\nret = __adp5520_read(chip->client, ADP5520_MODE_STATUS, &reg_val);\r\nif (ret)\r\ngoto out;\r\nevents = reg_val & (ADP5520_OVP_INT | ADP5520_CMPR_INT |\r\nADP5520_GPI_INT | ADP5520_KR_INT | ADP5520_KP_INT);\r\nblocking_notifier_call_chain(&chip->notifier_list, events, NULL);\r\n__adp5520_ack_bits(chip->client, ADP5520_MODE_STATUS, events);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __remove_subdev(struct device *dev, void *unused)\r\n{\r\nplatform_device_unregister(to_platform_device(dev));\r\nreturn 0;\r\n}\r\nstatic int adp5520_remove_subdevs(struct adp5520_chip *chip)\r\n{\r\nreturn device_for_each_child(chip->dev, NULL, __remove_subdev);\r\n}\r\nstatic int __devinit adp5520_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adp5520_platform_data *pdata = client->dev.platform_data;\r\nstruct platform_device *pdev;\r\nstruct adp5520_chip *chip;\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&client->dev, "SMBUS Word Data not Supported\n");\r\nreturn -EIO;\r\n}\r\nif (pdata == NULL) {\r\ndev_err(&client->dev, "missing platform data\n");\r\nreturn -ENODEV;\r\n}\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, chip);\r\nchip->client = client;\r\nchip->dev = &client->dev;\r\nchip->irq = client->irq;\r\nchip->id = id->driver_data;\r\nmutex_init(&chip->lock);\r\nif (chip->irq) {\r\nBLOCKING_INIT_NOTIFIER_HEAD(&chip->notifier_list);\r\nret = request_threaded_irq(chip->irq, NULL, adp5520_irq_thread,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"adp5520", chip);\r\nif (ret) {\r\ndev_err(&client->dev, "failed to request irq %d\n",\r\nchip->irq);\r\ngoto out_free_chip;\r\n}\r\n}\r\nret = adp5520_write(chip->dev, ADP5520_MODE_STATUS, ADP5520_nSTNBY);\r\nif (ret) {\r\ndev_err(&client->dev, "failed to write\n");\r\ngoto out_free_irq;\r\n}\r\nif (pdata->keys) {\r\npdev = platform_device_register_data(chip->dev, "adp5520-keys",\r\nchip->id, pdata->keys, sizeof(*pdata->keys));\r\nif (IS_ERR(pdev)) {\r\nret = PTR_ERR(pdev);\r\ngoto out_remove_subdevs;\r\n}\r\n}\r\nif (pdata->gpio) {\r\npdev = platform_device_register_data(chip->dev, "adp5520-gpio",\r\nchip->id, pdata->gpio, sizeof(*pdata->gpio));\r\nif (IS_ERR(pdev)) {\r\nret = PTR_ERR(pdev);\r\ngoto out_remove_subdevs;\r\n}\r\n}\r\nif (pdata->leds) {\r\npdev = platform_device_register_data(chip->dev, "adp5520-led",\r\nchip->id, pdata->leds, sizeof(*pdata->leds));\r\nif (IS_ERR(pdev)) {\r\nret = PTR_ERR(pdev);\r\ngoto out_remove_subdevs;\r\n}\r\n}\r\nif (pdata->backlight) {\r\npdev = platform_device_register_data(chip->dev,\r\n"adp5520-backlight",\r\nchip->id,\r\npdata->backlight,\r\nsizeof(*pdata->backlight));\r\nif (IS_ERR(pdev)) {\r\nret = PTR_ERR(pdev);\r\ngoto out_remove_subdevs;\r\n}\r\n}\r\nreturn 0;\r\nout_remove_subdevs:\r\nadp5520_remove_subdevs(chip);\r\nout_free_irq:\r\nif (chip->irq)\r\nfree_irq(chip->irq, chip);\r\nout_free_chip:\r\nkfree(chip);\r\nreturn ret;\r\n}\r\nstatic int __devexit adp5520_remove(struct i2c_client *client)\r\n{\r\nstruct adp5520_chip *chip = dev_get_drvdata(&client->dev);\r\nif (chip->irq)\r\nfree_irq(chip->irq, chip);\r\nadp5520_remove_subdevs(chip);\r\nadp5520_write(chip->dev, ADP5520_MODE_STATUS, 0);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int adp5520_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adp5520_chip *chip = dev_get_drvdata(&client->dev);\r\nadp5520_clr_bits(chip->dev, ADP5520_MODE_STATUS, ADP5520_nSTNBY);\r\nreturn 0;\r\n}\r\nstatic int adp5520_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adp5520_chip *chip = dev_get_drvdata(&client->dev);\r\nadp5520_set_bits(chip->dev, ADP5520_MODE_STATUS, ADP5520_nSTNBY);\r\nreturn 0;\r\n}\r\nstatic int __init adp5520_init(void)\r\n{\r\nreturn i2c_add_driver(&adp5520_driver);\r\n}\r\nstatic void __exit adp5520_exit(void)\r\n{\r\ni2c_del_driver(&adp5520_driver);\r\n}
