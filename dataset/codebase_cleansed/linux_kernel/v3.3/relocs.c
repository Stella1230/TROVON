static int is_abs_reloc(const char *sym_name)\r\n{\r\nreturn !regexec(&abs_sym_regex_c, sym_name, 0, NULL, 0);\r\n}\r\nstatic int is_rel_reloc(const char *sym_name)\r\n{\r\nreturn !regexec(&rel_sym_regex_c, sym_name, 0, NULL, 0);\r\n}\r\nstatic void regex_init(void)\r\n{\r\nchar errbuf[128];\r\nint err;\r\nerr = regcomp(&abs_sym_regex_c, abs_sym_regex,\r\nREG_EXTENDED|REG_NOSUB);\r\nif (err) {\r\nregerror(err, &abs_sym_regex_c, errbuf, sizeof errbuf);\r\ndie("%s", errbuf);\r\n}\r\nerr = regcomp(&rel_sym_regex_c, rel_sym_regex,\r\nREG_EXTENDED|REG_NOSUB);\r\nif (err) {\r\nregerror(err, &rel_sym_regex_c, errbuf, sizeof errbuf);\r\ndie("%s", errbuf);\r\n}\r\n}\r\nstatic void die(char *fmt, ...)\r\n{\r\nva_list ap;\r\nva_start(ap, fmt);\r\nvfprintf(stderr, fmt, ap);\r\nva_end(ap);\r\nexit(1);\r\n}\r\nstatic const char *sym_type(unsigned type)\r\n{\r\nstatic const char *type_name[] = {\r\n#define SYM_TYPE(X) [X] = #X\r\nSYM_TYPE(STT_NOTYPE),\r\nSYM_TYPE(STT_OBJECT),\r\nSYM_TYPE(STT_FUNC),\r\nSYM_TYPE(STT_SECTION),\r\nSYM_TYPE(STT_FILE),\r\nSYM_TYPE(STT_COMMON),\r\nSYM_TYPE(STT_TLS),\r\n#undef SYM_TYPE\r\n};\r\nconst char *name = "unknown sym type name";\r\nif (type < ARRAY_SIZE(type_name)) {\r\nname = type_name[type];\r\n}\r\nreturn name;\r\n}\r\nstatic const char *sym_bind(unsigned bind)\r\n{\r\nstatic const char *bind_name[] = {\r\n#define SYM_BIND(X) [X] = #X\r\nSYM_BIND(STB_LOCAL),\r\nSYM_BIND(STB_GLOBAL),\r\nSYM_BIND(STB_WEAK),\r\n#undef SYM_BIND\r\n};\r\nconst char *name = "unknown sym bind name";\r\nif (bind < ARRAY_SIZE(bind_name)) {\r\nname = bind_name[bind];\r\n}\r\nreturn name;\r\n}\r\nstatic const char *sym_visibility(unsigned visibility)\r\n{\r\nstatic const char *visibility_name[] = {\r\n#define SYM_VISIBILITY(X) [X] = #X\r\nSYM_VISIBILITY(STV_DEFAULT),\r\nSYM_VISIBILITY(STV_INTERNAL),\r\nSYM_VISIBILITY(STV_HIDDEN),\r\nSYM_VISIBILITY(STV_PROTECTED),\r\n#undef SYM_VISIBILITY\r\n};\r\nconst char *name = "unknown sym visibility name";\r\nif (visibility < ARRAY_SIZE(visibility_name)) {\r\nname = visibility_name[visibility];\r\n}\r\nreturn name;\r\n}\r\nstatic const char *rel_type(unsigned type)\r\n{\r\nstatic const char *type_name[] = {\r\n#define REL_TYPE(X) [X] = #X\r\nREL_TYPE(R_386_NONE),\r\nREL_TYPE(R_386_32),\r\nREL_TYPE(R_386_PC32),\r\nREL_TYPE(R_386_GOT32),\r\nREL_TYPE(R_386_PLT32),\r\nREL_TYPE(R_386_COPY),\r\nREL_TYPE(R_386_GLOB_DAT),\r\nREL_TYPE(R_386_JMP_SLOT),\r\nREL_TYPE(R_386_RELATIVE),\r\nREL_TYPE(R_386_GOTOFF),\r\nREL_TYPE(R_386_GOTPC),\r\n#undef REL_TYPE\r\n};\r\nconst char *name = "unknown type rel type name";\r\nif (type < ARRAY_SIZE(type_name) && type_name[type]) {\r\nname = type_name[type];\r\n}\r\nreturn name;\r\n}\r\nstatic const char *sec_name(unsigned shndx)\r\n{\r\nconst char *sec_strtab;\r\nconst char *name;\r\nsec_strtab = secs[ehdr.e_shstrndx].strtab;\r\nname = "<noname>";\r\nif (shndx < ehdr.e_shnum) {\r\nname = sec_strtab + secs[shndx].shdr.sh_name;\r\n}\r\nelse if (shndx == SHN_ABS) {\r\nname = "ABSOLUTE";\r\n}\r\nelse if (shndx == SHN_COMMON) {\r\nname = "COMMON";\r\n}\r\nreturn name;\r\n}\r\nstatic const char *sym_name(const char *sym_strtab, Elf32_Sym *sym)\r\n{\r\nconst char *name;\r\nname = "<noname>";\r\nif (sym->st_name) {\r\nname = sym_strtab + sym->st_name;\r\n}\r\nelse {\r\nname = sec_name(secs[sym->st_shndx].shdr.sh_name);\r\n}\r\nreturn name;\r\n}\r\nstatic uint16_t elf16_to_cpu(uint16_t val)\r\n{\r\nreturn le16_to_cpu(val);\r\n}\r\nstatic uint32_t elf32_to_cpu(uint32_t val)\r\n{\r\nreturn le32_to_cpu(val);\r\n}\r\nstatic void read_ehdr(FILE *fp)\r\n{\r\nif (fread(&ehdr, sizeof(ehdr), 1, fp) != 1) {\r\ndie("Cannot read ELF header: %s\n",\r\nstrerror(errno));\r\n}\r\nif (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) != 0) {\r\ndie("No ELF magic\n");\r\n}\r\nif (ehdr.e_ident[EI_CLASS] != ELFCLASS32) {\r\ndie("Not a 32 bit executable\n");\r\n}\r\nif (ehdr.e_ident[EI_DATA] != ELFDATA2LSB) {\r\ndie("Not a LSB ELF executable\n");\r\n}\r\nif (ehdr.e_ident[EI_VERSION] != EV_CURRENT) {\r\ndie("Unknown ELF version\n");\r\n}\r\nehdr.e_type = elf16_to_cpu(ehdr.e_type);\r\nehdr.e_machine = elf16_to_cpu(ehdr.e_machine);\r\nehdr.e_version = elf32_to_cpu(ehdr.e_version);\r\nehdr.e_entry = elf32_to_cpu(ehdr.e_entry);\r\nehdr.e_phoff = elf32_to_cpu(ehdr.e_phoff);\r\nehdr.e_shoff = elf32_to_cpu(ehdr.e_shoff);\r\nehdr.e_flags = elf32_to_cpu(ehdr.e_flags);\r\nehdr.e_ehsize = elf16_to_cpu(ehdr.e_ehsize);\r\nehdr.e_phentsize = elf16_to_cpu(ehdr.e_phentsize);\r\nehdr.e_phnum = elf16_to_cpu(ehdr.e_phnum);\r\nehdr.e_shentsize = elf16_to_cpu(ehdr.e_shentsize);\r\nehdr.e_shnum = elf16_to_cpu(ehdr.e_shnum);\r\nehdr.e_shstrndx = elf16_to_cpu(ehdr.e_shstrndx);\r\nif ((ehdr.e_type != ET_EXEC) && (ehdr.e_type != ET_DYN)) {\r\ndie("Unsupported ELF header type\n");\r\n}\r\nif (ehdr.e_machine != EM_386) {\r\ndie("Not for x86\n");\r\n}\r\nif (ehdr.e_version != EV_CURRENT) {\r\ndie("Unknown ELF version\n");\r\n}\r\nif (ehdr.e_ehsize != sizeof(Elf32_Ehdr)) {\r\ndie("Bad Elf header size\n");\r\n}\r\nif (ehdr.e_phentsize != sizeof(Elf32_Phdr)) {\r\ndie("Bad program header entry\n");\r\n}\r\nif (ehdr.e_shentsize != sizeof(Elf32_Shdr)) {\r\ndie("Bad section header entry\n");\r\n}\r\nif (ehdr.e_shstrndx >= ehdr.e_shnum) {\r\ndie("String table index out of bounds\n");\r\n}\r\n}\r\nstatic void read_shdrs(FILE *fp)\r\n{\r\nint i;\r\nElf32_Shdr shdr;\r\nsecs = calloc(ehdr.e_shnum, sizeof(struct section));\r\nif (!secs) {\r\ndie("Unable to allocate %d section headers\n",\r\nehdr.e_shnum);\r\n}\r\nif (fseek(fp, ehdr.e_shoff, SEEK_SET) < 0) {\r\ndie("Seek to %d failed: %s\n",\r\nehdr.e_shoff, strerror(errno));\r\n}\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nif (fread(&shdr, sizeof shdr, 1, fp) != 1)\r\ndie("Cannot read ELF section headers %d/%d: %s\n",\r\ni, ehdr.e_shnum, strerror(errno));\r\nsec->shdr.sh_name = elf32_to_cpu(shdr.sh_name);\r\nsec->shdr.sh_type = elf32_to_cpu(shdr.sh_type);\r\nsec->shdr.sh_flags = elf32_to_cpu(shdr.sh_flags);\r\nsec->shdr.sh_addr = elf32_to_cpu(shdr.sh_addr);\r\nsec->shdr.sh_offset = elf32_to_cpu(shdr.sh_offset);\r\nsec->shdr.sh_size = elf32_to_cpu(shdr.sh_size);\r\nsec->shdr.sh_link = elf32_to_cpu(shdr.sh_link);\r\nsec->shdr.sh_info = elf32_to_cpu(shdr.sh_info);\r\nsec->shdr.sh_addralign = elf32_to_cpu(shdr.sh_addralign);\r\nsec->shdr.sh_entsize = elf32_to_cpu(shdr.sh_entsize);\r\nif (sec->shdr.sh_link < ehdr.e_shnum)\r\nsec->link = &secs[sec->shdr.sh_link];\r\n}\r\n}\r\nstatic void read_strtabs(FILE *fp)\r\n{\r\nint i;\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nif (sec->shdr.sh_type != SHT_STRTAB) {\r\ncontinue;\r\n}\r\nsec->strtab = malloc(sec->shdr.sh_size);\r\nif (!sec->strtab) {\r\ndie("malloc of %d bytes for strtab failed\n",\r\nsec->shdr.sh_size);\r\n}\r\nif (fseek(fp, sec->shdr.sh_offset, SEEK_SET) < 0) {\r\ndie("Seek to %d failed: %s\n",\r\nsec->shdr.sh_offset, strerror(errno));\r\n}\r\nif (fread(sec->strtab, 1, sec->shdr.sh_size, fp)\r\n!= sec->shdr.sh_size) {\r\ndie("Cannot read symbol table: %s\n",\r\nstrerror(errno));\r\n}\r\n}\r\n}\r\nstatic void read_symtabs(FILE *fp)\r\n{\r\nint i,j;\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nif (sec->shdr.sh_type != SHT_SYMTAB) {\r\ncontinue;\r\n}\r\nsec->symtab = malloc(sec->shdr.sh_size);\r\nif (!sec->symtab) {\r\ndie("malloc of %d bytes for symtab failed\n",\r\nsec->shdr.sh_size);\r\n}\r\nif (fseek(fp, sec->shdr.sh_offset, SEEK_SET) < 0) {\r\ndie("Seek to %d failed: %s\n",\r\nsec->shdr.sh_offset, strerror(errno));\r\n}\r\nif (fread(sec->symtab, 1, sec->shdr.sh_size, fp)\r\n!= sec->shdr.sh_size) {\r\ndie("Cannot read symbol table: %s\n",\r\nstrerror(errno));\r\n}\r\nfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf32_Sym); j++) {\r\nElf32_Sym *sym = &sec->symtab[j];\r\nsym->st_name = elf32_to_cpu(sym->st_name);\r\nsym->st_value = elf32_to_cpu(sym->st_value);\r\nsym->st_size = elf32_to_cpu(sym->st_size);\r\nsym->st_shndx = elf16_to_cpu(sym->st_shndx);\r\n}\r\n}\r\n}\r\nstatic void read_relocs(FILE *fp)\r\n{\r\nint i,j;\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nif (sec->shdr.sh_type != SHT_REL) {\r\ncontinue;\r\n}\r\nsec->reltab = malloc(sec->shdr.sh_size);\r\nif (!sec->reltab) {\r\ndie("malloc of %d bytes for relocs failed\n",\r\nsec->shdr.sh_size);\r\n}\r\nif (fseek(fp, sec->shdr.sh_offset, SEEK_SET) < 0) {\r\ndie("Seek to %d failed: %s\n",\r\nsec->shdr.sh_offset, strerror(errno));\r\n}\r\nif (fread(sec->reltab, 1, sec->shdr.sh_size, fp)\r\n!= sec->shdr.sh_size) {\r\ndie("Cannot read symbol table: %s\n",\r\nstrerror(errno));\r\n}\r\nfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf32_Rel); j++) {\r\nElf32_Rel *rel = &sec->reltab[j];\r\nrel->r_offset = elf32_to_cpu(rel->r_offset);\r\nrel->r_info = elf32_to_cpu(rel->r_info);\r\n}\r\n}\r\n}\r\nstatic void print_absolute_symbols(void)\r\n{\r\nint i;\r\nprintf("Absolute symbols\n");\r\nprintf(" Num: Value Size Type Bind Visibility Name\n");\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nchar *sym_strtab;\r\nElf32_Sym *sh_symtab;\r\nint j;\r\nif (sec->shdr.sh_type != SHT_SYMTAB) {\r\ncontinue;\r\n}\r\nsh_symtab = sec->symtab;\r\nsym_strtab = sec->link->strtab;\r\nfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf32_Sym); j++) {\r\nElf32_Sym *sym;\r\nconst char *name;\r\nsym = &sec->symtab[j];\r\nname = sym_name(sym_strtab, sym);\r\nif (sym->st_shndx != SHN_ABS) {\r\ncontinue;\r\n}\r\nprintf("%5d %08x %5d %10s %10s %12s %s\n",\r\nj, sym->st_value, sym->st_size,\r\nsym_type(ELF32_ST_TYPE(sym->st_info)),\r\nsym_bind(ELF32_ST_BIND(sym->st_info)),\r\nsym_visibility(ELF32_ST_VISIBILITY(sym->st_other)),\r\nname);\r\n}\r\n}\r\nprintf("\n");\r\n}\r\nstatic void print_absolute_relocs(void)\r\n{\r\nint i, printed = 0;\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nstruct section *sec_applies, *sec_symtab;\r\nchar *sym_strtab;\r\nElf32_Sym *sh_symtab;\r\nint j;\r\nif (sec->shdr.sh_type != SHT_REL) {\r\ncontinue;\r\n}\r\nsec_symtab = sec->link;\r\nsec_applies = &secs[sec->shdr.sh_info];\r\nif (!(sec_applies->shdr.sh_flags & SHF_ALLOC)) {\r\ncontinue;\r\n}\r\nsh_symtab = sec_symtab->symtab;\r\nsym_strtab = sec_symtab->link->strtab;\r\nfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf32_Rel); j++) {\r\nElf32_Rel *rel;\r\nElf32_Sym *sym;\r\nconst char *name;\r\nrel = &sec->reltab[j];\r\nsym = &sh_symtab[ELF32_R_SYM(rel->r_info)];\r\nname = sym_name(sym_strtab, sym);\r\nif (sym->st_shndx != SHN_ABS) {\r\ncontinue;\r\n}\r\nif (is_abs_reloc(name) || is_rel_reloc(name))\r\ncontinue;\r\nif (!printed) {\r\nprintf("WARNING: Absolute relocations"\r\n" present\n");\r\nprintf("Offset Info Type Sym.Value "\r\n"Sym.Name\n");\r\nprinted = 1;\r\n}\r\nprintf("%08x %08x %10s %08x %s\n",\r\nrel->r_offset,\r\nrel->r_info,\r\nrel_type(ELF32_R_TYPE(rel->r_info)),\r\nsym->st_value,\r\nname);\r\n}\r\n}\r\nif (printed)\r\nprintf("\n");\r\n}\r\nstatic void walk_relocs(void (*visit)(Elf32_Rel *rel, Elf32_Sym *sym))\r\n{\r\nint i;\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nchar *sym_strtab;\r\nElf32_Sym *sh_symtab;\r\nstruct section *sec_applies, *sec_symtab;\r\nint j;\r\nstruct section *sec = &secs[i];\r\nif (sec->shdr.sh_type != SHT_REL) {\r\ncontinue;\r\n}\r\nsec_symtab = sec->link;\r\nsec_applies = &secs[sec->shdr.sh_info];\r\nif (!(sec_applies->shdr.sh_flags & SHF_ALLOC)) {\r\ncontinue;\r\n}\r\nsh_symtab = sec_symtab->symtab;\r\nsym_strtab = sec_symtab->link->strtab;\r\nfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf32_Rel); j++) {\r\nElf32_Rel *rel;\r\nElf32_Sym *sym;\r\nunsigned r_type;\r\nrel = &sec->reltab[j];\r\nsym = &sh_symtab[ELF32_R_SYM(rel->r_info)];\r\nr_type = ELF32_R_TYPE(rel->r_info);\r\nif (sym->st_shndx == SHN_ABS &&\r\n!is_rel_reloc(sym_name(sym_strtab, sym))) {\r\ncontinue;\r\n}\r\nswitch (r_type) {\r\ncase R_386_NONE:\r\ncase R_386_PC32:\r\nbreak;\r\ncase R_386_32:\r\nvisit(rel, sym);\r\nbreak;\r\ndefault:\r\ndie("Unsupported relocation type: %s (%d)\n",\r\nrel_type(r_type), r_type);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void count_reloc(Elf32_Rel *rel, Elf32_Sym *sym)\r\n{\r\nreloc_count += 1;\r\n}\r\nstatic void collect_reloc(Elf32_Rel *rel, Elf32_Sym *sym)\r\n{\r\nrelocs[reloc_idx++] = rel->r_offset;\r\n}\r\nstatic int cmp_relocs(const void *va, const void *vb)\r\n{\r\nconst unsigned long *a, *b;\r\na = va; b = vb;\r\nreturn (*a == *b)? 0 : (*a > *b)? 1 : -1;\r\n}\r\nstatic void emit_relocs(int as_text)\r\n{\r\nint i;\r\nreloc_count = 0;\r\nwalk_relocs(count_reloc);\r\nrelocs = malloc(reloc_count * sizeof(relocs[0]));\r\nif (!relocs) {\r\ndie("malloc of %d entries for relocs failed\n",\r\nreloc_count);\r\n}\r\nreloc_idx = 0;\r\nwalk_relocs(collect_reloc);\r\nqsort(relocs, reloc_count, sizeof(relocs[0]), cmp_relocs);\r\nif (as_text) {\r\nprintf(".section \".data.reloc\",\"a\"\n");\r\nprintf(".balign 4\n");\r\nfor (i = 0; i < reloc_count; i++) {\r\nprintf("\t .long 0x%08lx\n", relocs[i]);\r\n}\r\nprintf("\n");\r\n}\r\nelse {\r\nunsigned char buf[4];\r\nfwrite("\0\0\0\0", 4, 1, stdout);\r\nfor (i = 0; i < reloc_count; i++) {\r\nbuf[0] = (relocs[i] >> 0) & 0xff;\r\nbuf[1] = (relocs[i] >> 8) & 0xff;\r\nbuf[2] = (relocs[i] >> 16) & 0xff;\r\nbuf[3] = (relocs[i] >> 24) & 0xff;\r\nfwrite(buf, 4, 1, stdout);\r\n}\r\n}\r\n}\r\nstatic void usage(void)\r\n{\r\ndie("relocs [--abs-syms |--abs-relocs | --text] vmlinux\n");\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nint show_absolute_syms, show_absolute_relocs;\r\nint as_text;\r\nconst char *fname;\r\nFILE *fp;\r\nint i;\r\nregex_init();\r\nshow_absolute_syms = 0;\r\nshow_absolute_relocs = 0;\r\nas_text = 0;\r\nfname = NULL;\r\nfor (i = 1; i < argc; i++) {\r\nchar *arg = argv[i];\r\nif (*arg == '-') {\r\nif (strcmp(argv[1], "--abs-syms") == 0) {\r\nshow_absolute_syms = 1;\r\ncontinue;\r\n}\r\nif (strcmp(argv[1], "--abs-relocs") == 0) {\r\nshow_absolute_relocs = 1;\r\ncontinue;\r\n}\r\nelse if (strcmp(argv[1], "--text") == 0) {\r\nas_text = 1;\r\ncontinue;\r\n}\r\n}\r\nelse if (!fname) {\r\nfname = arg;\r\ncontinue;\r\n}\r\nusage();\r\n}\r\nif (!fname) {\r\nusage();\r\n}\r\nfp = fopen(fname, "r");\r\nif (!fp) {\r\ndie("Cannot open %s: %s\n",\r\nfname, strerror(errno));\r\n}\r\nread_ehdr(fp);\r\nread_shdrs(fp);\r\nread_strtabs(fp);\r\nread_symtabs(fp);\r\nread_relocs(fp);\r\nif (show_absolute_syms) {\r\nprint_absolute_symbols();\r\nreturn 0;\r\n}\r\nif (show_absolute_relocs) {\r\nprint_absolute_relocs();\r\nreturn 0;\r\n}\r\nemit_relocs(as_text);\r\nreturn 0;\r\n}
