static int asd_get_user_sas_addr(struct asd_ha_struct *asd_ha)\r\n{\r\nif (asd_ha->hw_prof.sas_addr[0])\r\nreturn 0;\r\nreturn sas_request_addr(asd_ha->sas_ha.core.shost,\r\nasd_ha->hw_prof.sas_addr);\r\n}\r\nstatic void asd_propagate_sas_addr(struct asd_ha_struct *asd_ha)\r\n{\r\nint i;\r\nfor (i = 0; i < ASD_MAX_PHYS; i++) {\r\nif (asd_ha->hw_prof.phy_desc[i].sas_addr[0] == 0)\r\ncontinue;\r\nASD_DPRINTK("setting phy%d addr to %llx\n", i,\r\nSAS_ADDR(asd_ha->hw_prof.sas_addr));\r\nmemcpy(asd_ha->hw_prof.phy_desc[i].sas_addr,\r\nasd_ha->hw_prof.sas_addr, SAS_ADDR_SIZE);\r\n}\r\n}\r\nstatic void asd_init_phy_identify(struct asd_phy *phy)\r\n{\r\nphy->identify_frame = phy->id_frm_tok->vaddr;\r\nmemset(phy->identify_frame, 0, sizeof(*phy->identify_frame));\r\nphy->identify_frame->dev_type = SAS_END_DEV;\r\nif (phy->sas_phy.role & PHY_ROLE_INITIATOR)\r\nphy->identify_frame->initiator_bits = phy->sas_phy.iproto;\r\nif (phy->sas_phy.role & PHY_ROLE_TARGET)\r\nphy->identify_frame->target_bits = phy->sas_phy.tproto;\r\nmemcpy(phy->identify_frame->sas_addr, phy->phy_desc->sas_addr,\r\nSAS_ADDR_SIZE);\r\nphy->identify_frame->phy_id = phy->sas_phy.id;\r\n}\r\nstatic int asd_init_phy(struct asd_phy *phy)\r\n{\r\nstruct asd_ha_struct *asd_ha = phy->sas_phy.ha->lldd_ha;\r\nstruct asd_sas_phy *sas_phy = &phy->sas_phy;\r\nsas_phy->enabled = 1;\r\nsas_phy->class = SAS;\r\nsas_phy->iproto = SAS_PROTOCOL_ALL;\r\nsas_phy->tproto = 0;\r\nsas_phy->type = PHY_TYPE_PHYSICAL;\r\nsas_phy->role = PHY_ROLE_INITIATOR;\r\nsas_phy->oob_mode = OOB_NOT_CONNECTED;\r\nsas_phy->linkrate = SAS_LINK_RATE_UNKNOWN;\r\nphy->id_frm_tok = asd_alloc_coherent(asd_ha,\r\nsizeof(*phy->identify_frame),\r\nGFP_KERNEL);\r\nif (!phy->id_frm_tok) {\r\nasd_printk("no mem for IDENTIFY for phy%d\n", sas_phy->id);\r\nreturn -ENOMEM;\r\n} else\r\nasd_init_phy_identify(phy);\r\nmemset(phy->frame_rcvd, 0, sizeof(phy->frame_rcvd));\r\nreturn 0;\r\n}\r\nstatic void asd_init_ports(struct asd_ha_struct *asd_ha)\r\n{\r\nint i;\r\nspin_lock_init(&asd_ha->asd_ports_lock);\r\nfor (i = 0; i < ASD_MAX_PHYS; i++) {\r\nstruct asd_port *asd_port = &asd_ha->asd_ports[i];\r\nmemset(asd_port->sas_addr, 0, SAS_ADDR_SIZE);\r\nmemset(asd_port->attached_sas_addr, 0, SAS_ADDR_SIZE);\r\nasd_port->phy_mask = 0;\r\nasd_port->num_phys = 0;\r\n}\r\n}\r\nstatic int asd_init_phys(struct asd_ha_struct *asd_ha)\r\n{\r\nu8 i;\r\nu8 phy_mask = asd_ha->hw_prof.enabled_phys;\r\nfor (i = 0; i < ASD_MAX_PHYS; i++) {\r\nstruct asd_phy *phy = &asd_ha->phys[i];\r\nphy->phy_desc = &asd_ha->hw_prof.phy_desc[i];\r\nphy->asd_port = NULL;\r\nphy->sas_phy.enabled = 0;\r\nphy->sas_phy.id = i;\r\nphy->sas_phy.sas_addr = &phy->phy_desc->sas_addr[0];\r\nphy->sas_phy.frame_rcvd = &phy->frame_rcvd[0];\r\nphy->sas_phy.ha = &asd_ha->sas_ha;\r\nphy->sas_phy.lldd_phy = phy;\r\n}\r\nfor_each_phy(phy_mask, phy_mask, i) {\r\nint err = asd_init_phy(&asd_ha->phys[i]);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int asd_init_sw(struct asd_ha_struct *asd_ha)\r\n{\r\nstruct pci_dev *pcidev = asd_ha->pcidev;\r\nint err;\r\nu32 v;\r\nerr = pci_read_config_dword(pcidev, PCI_CONF_MBAR_KEY, &v);\r\nif (err) {\r\nasd_printk("couldn't access conf. space of %s\n",\r\npci_name(pcidev));\r\ngoto Err;\r\n}\r\nif (v)\r\nerr = pci_write_config_dword(pcidev, PCI_CONF_MBAR_KEY, v);\r\nif (err) {\r\nasd_printk("couldn't write to MBAR_KEY of %s\n",\r\npci_name(pcidev));\r\ngoto Err;\r\n}\r\npci_write_config_dword(pcidev, PCI_CONF_MBAR0_SWA, REG_BASE_ADDR);\r\npci_write_config_dword(pcidev, PCI_CONF_MBAR0_SWB,\r\nREG_BASE_ADDR_CSEQCIO);\r\npci_write_config_dword(pcidev, PCI_CONF_MBAR0_SWC, REG_BASE_ADDR_EXSI);\r\nasd_ha->io_handle[0].swa_base = REG_BASE_ADDR;\r\nasd_ha->io_handle[0].swb_base = REG_BASE_ADDR_CSEQCIO;\r\nasd_ha->io_handle[0].swc_base = REG_BASE_ADDR_EXSI;\r\nMBAR0_SWB_SIZE = asd_ha->io_handle[0].len - 0x80;\r\nif (!asd_ha->iospace) {\r\npci_write_config_dword(pcidev, PCI_CONF_MBAR1, OCM_BASE_ADDR);\r\nasd_ha->io_handle[1].swa_base = OCM_BASE_ADDR;\r\n}\r\nspin_lock_init(&asd_ha->iolock);\r\nErr:\r\nreturn err;\r\n}\r\nstatic int asd_init_scbs(struct asd_ha_struct *asd_ha)\r\n{\r\nstruct asd_seq_data *seq = &asd_ha->seq;\r\nint bitmap_bytes;\r\nasd_ha->seq.tc_index_bitmap_bits = asd_ha->hw_prof.max_scbs;\r\nasd_ha->seq.tc_index_array = kzalloc(asd_ha->seq.tc_index_bitmap_bits*\r\nsizeof(void *), GFP_KERNEL);\r\nif (!asd_ha->seq.tc_index_array)\r\nreturn -ENOMEM;\r\nbitmap_bytes = (asd_ha->seq.tc_index_bitmap_bits+7)/8;\r\nbitmap_bytes = BITS_TO_LONGS(bitmap_bytes*8)*sizeof(unsigned long);\r\nasd_ha->seq.tc_index_bitmap = kzalloc(bitmap_bytes, GFP_KERNEL);\r\nif (!asd_ha->seq.tc_index_bitmap)\r\nreturn -ENOMEM;\r\nspin_lock_init(&seq->tc_index_lock);\r\nseq->next_scb.size = sizeof(struct scb);\r\nseq->next_scb.vaddr = dma_pool_alloc(asd_ha->scb_pool, GFP_KERNEL,\r\n&seq->next_scb.dma_handle);\r\nif (!seq->next_scb.vaddr) {\r\nkfree(asd_ha->seq.tc_index_bitmap);\r\nkfree(asd_ha->seq.tc_index_array);\r\nasd_ha->seq.tc_index_bitmap = NULL;\r\nasd_ha->seq.tc_index_array = NULL;\r\nreturn -ENOMEM;\r\n}\r\nseq->pending = 0;\r\nspin_lock_init(&seq->pend_q_lock);\r\nINIT_LIST_HEAD(&seq->pend_q);\r\nreturn 0;\r\n}\r\nstatic void asd_get_max_scb_ddb(struct asd_ha_struct *asd_ha)\r\n{\r\nasd_ha->hw_prof.max_scbs = asd_get_cmdctx_size(asd_ha)/ASD_SCB_SIZE;\r\nasd_ha->hw_prof.max_ddbs = asd_get_devctx_size(asd_ha)/ASD_DDB_SIZE;\r\nASD_DPRINTK("max_scbs:%d, max_ddbs:%d\n",\r\nasd_ha->hw_prof.max_scbs,\r\nasd_ha->hw_prof.max_ddbs);\r\n}\r\nstatic int asd_init_dl(struct asd_ha_struct *asd_ha)\r\n{\r\nasd_ha->seq.actual_dl\r\n= asd_alloc_coherent(asd_ha,\r\nASD_DL_SIZE * sizeof(struct done_list_struct),\r\nGFP_KERNEL);\r\nif (!asd_ha->seq.actual_dl)\r\nreturn -ENOMEM;\r\nasd_ha->seq.dl = asd_ha->seq.actual_dl->vaddr;\r\nasd_ha->seq.dl_toggle = ASD_DEF_DL_TOGGLE;\r\nasd_ha->seq.dl_next = 0;\r\ntasklet_init(&asd_ha->seq.dl_tasklet, asd_dl_tasklet_handler,\r\n(unsigned long) asd_ha);\r\nreturn 0;\r\n}\r\nstatic int asd_alloc_edbs(struct asd_ha_struct *asd_ha, gfp_t gfp_flags)\r\n{\r\nstruct asd_seq_data *seq = &asd_ha->seq;\r\nint i;\r\nseq->edb_arr = kmalloc(seq->num_edbs*sizeof(*seq->edb_arr), gfp_flags);\r\nif (!seq->edb_arr)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < seq->num_edbs; i++) {\r\nseq->edb_arr[i] = asd_alloc_coherent(asd_ha, ASD_EDB_SIZE,\r\ngfp_flags);\r\nif (!seq->edb_arr[i])\r\ngoto Err_unroll;\r\nmemset(seq->edb_arr[i]->vaddr, 0, ASD_EDB_SIZE);\r\n}\r\nASD_DPRINTK("num_edbs:%d\n", seq->num_edbs);\r\nreturn 0;\r\nErr_unroll:\r\nfor (i-- ; i >= 0; i--)\r\nasd_free_coherent(asd_ha, seq->edb_arr[i]);\r\nkfree(seq->edb_arr);\r\nseq->edb_arr = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic int asd_alloc_escbs(struct asd_ha_struct *asd_ha,\r\ngfp_t gfp_flags)\r\n{\r\nstruct asd_seq_data *seq = &asd_ha->seq;\r\nstruct asd_ascb *escb;\r\nint i, escbs;\r\nseq->escb_arr = kmalloc(seq->num_escbs*sizeof(*seq->escb_arr),\r\ngfp_flags);\r\nif (!seq->escb_arr)\r\nreturn -ENOMEM;\r\nescbs = seq->num_escbs;\r\nescb = asd_ascb_alloc_list(asd_ha, &escbs, gfp_flags);\r\nif (!escb) {\r\nasd_printk("couldn't allocate list of escbs\n");\r\ngoto Err;\r\n}\r\nseq->num_escbs -= escbs;\r\nASD_DPRINTK("num_escbs:%d\n", seq->num_escbs);\r\nfor (i = 0; i < seq->num_escbs; i++, escb = list_entry(escb->list.next,\r\nstruct asd_ascb,\r\nlist)) {\r\nseq->escb_arr[i] = escb;\r\nescb->scb->header.opcode = EMPTY_SCB;\r\n}\r\nreturn 0;\r\nErr:\r\nkfree(seq->escb_arr);\r\nseq->escb_arr = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic void asd_assign_edbs2escbs(struct asd_ha_struct *asd_ha)\r\n{\r\nstruct asd_seq_data *seq = &asd_ha->seq;\r\nint i, k, z = 0;\r\nfor (i = 0; i < seq->num_escbs; i++) {\r\nstruct asd_ascb *ascb = seq->escb_arr[i];\r\nstruct empty_scb *escb = &ascb->scb->escb;\r\nascb->edb_index = z;\r\nescb->num_valid = ASD_EDBS_PER_SCB;\r\nfor (k = 0; k < ASD_EDBS_PER_SCB; k++) {\r\nstruct sg_el *eb = &escb->eb[k];\r\nstruct asd_dma_tok *edb = seq->edb_arr[z++];\r\nmemset(eb, 0, sizeof(*eb));\r\neb->bus_addr = cpu_to_le64(((u64) edb->dma_handle));\r\neb->size = cpu_to_le32(((u32) edb->size));\r\n}\r\n}\r\n}\r\nstatic int asd_init_escbs(struct asd_ha_struct *asd_ha)\r\n{\r\nstruct asd_seq_data *seq = &asd_ha->seq;\r\nint err = 0;\r\nint edbs = 2*(1+asd_ha->hw_prof.num_phys);\r\nseq->num_escbs = (edbs+ASD_EDBS_PER_SCB-1)/ASD_EDBS_PER_SCB;\r\nseq->num_edbs = seq->num_escbs * ASD_EDBS_PER_SCB;\r\nerr = asd_alloc_edbs(asd_ha, GFP_KERNEL);\r\nif (err) {\r\nasd_printk("couldn't allocate edbs\n");\r\nreturn err;\r\n}\r\nerr = asd_alloc_escbs(asd_ha, GFP_KERNEL);\r\nif (err) {\r\nasd_printk("couldn't allocate escbs\n");\r\nreturn err;\r\n}\r\nasd_assign_edbs2escbs(asd_ha);\r\nseq->pending = seq->num_escbs;\r\nseq->can_queue = 1 + (asd_ha->hw_prof.max_scbs - seq->pending)/2;\r\nreturn 0;\r\n}\r\nint asd_chip_hardrst(struct asd_ha_struct *asd_ha)\r\n{\r\nint i;\r\nint count = 100;\r\nu32 reg;\r\nfor (i = 0 ; i < 4 ; i++) {\r\nasd_write_reg_dword(asd_ha, COMBIST, HARDRST);\r\n}\r\ndo {\r\nudelay(1);\r\nreg = asd_read_reg_dword(asd_ha, CHIMINT);\r\nif (reg & HARDRSTDET) {\r\nasd_write_reg_dword(asd_ha, CHIMINT,\r\nHARDRSTDET|PORRSTDET);\r\nreturn 0;\r\n}\r\n} while (--count > 0);\r\nreturn -ENODEV;\r\n}\r\nstatic int asd_init_chip(struct asd_ha_struct *asd_ha)\r\n{\r\nint err;\r\nerr = asd_chip_hardrst(asd_ha);\r\nif (err) {\r\nasd_printk("couldn't hard reset %s\n",\r\npci_name(asd_ha->pcidev));\r\ngoto out;\r\n}\r\nasd_disable_ints(asd_ha);\r\nerr = asd_init_seqs(asd_ha);\r\nif (err) {\r\nasd_printk("couldn't init seqs for %s\n",\r\npci_name(asd_ha->pcidev));\r\ngoto out;\r\n}\r\nerr = asd_start_seqs(asd_ha);\r\nif (err) {\r\nasd_printk("coudln't start seqs for %s\n",\r\npci_name(asd_ha->pcidev));\r\ngoto out;\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic void asd_extend_devctx_ocm(struct asd_ha_struct *asd_ha)\r\n{\r\nunsigned long dma_addr = OCM_BASE_ADDR;\r\nu32 d;\r\ndma_addr -= asd_ha->hw_prof.max_ddbs * ASD_DDB_SIZE;\r\nasd_write_reg_addr(asd_ha, DEVCTXBASE, (dma_addr_t) dma_addr);\r\nd = asd_read_reg_dword(asd_ha, CTXDOMAIN);\r\nd |= 4;\r\nasd_write_reg_dword(asd_ha, CTXDOMAIN, d);\r\nasd_ha->hw_prof.max_ddbs += MAX_DEVS;\r\n}\r\nstatic int asd_extend_devctx(struct asd_ha_struct *asd_ha)\r\n{\r\ndma_addr_t dma_handle;\r\nunsigned long dma_addr;\r\nu32 d;\r\nint size;\r\nasd_extend_devctx_ocm(asd_ha);\r\nasd_ha->hw_prof.ddb_ext = NULL;\r\nif (max_devs <= asd_ha->hw_prof.max_ddbs || max_devs > 0xFFFF) {\r\nmax_devs = asd_ha->hw_prof.max_ddbs;\r\nreturn 0;\r\n}\r\nsize = (max_devs - asd_ha->hw_prof.max_ddbs + 1) * ASD_DDB_SIZE;\r\nasd_ha->hw_prof.ddb_ext = asd_alloc_coherent(asd_ha, size, GFP_KERNEL);\r\nif (!asd_ha->hw_prof.ddb_ext) {\r\nasd_printk("couldn't allocate memory for %d devices\n",\r\nmax_devs);\r\nmax_devs = asd_ha->hw_prof.max_ddbs;\r\nreturn -ENOMEM;\r\n}\r\ndma_handle = asd_ha->hw_prof.ddb_ext->dma_handle;\r\ndma_addr = ALIGN((unsigned long) dma_handle, ASD_DDB_SIZE);\r\ndma_addr -= asd_ha->hw_prof.max_ddbs * ASD_DDB_SIZE;\r\ndma_handle = (dma_addr_t) dma_addr;\r\nasd_write_reg_addr(asd_ha, DEVCTXBASE, dma_handle);\r\nd = asd_read_reg_dword(asd_ha, CTXDOMAIN);\r\nd &= ~4;\r\nasd_write_reg_dword(asd_ha, CTXDOMAIN, d);\r\nasd_ha->hw_prof.max_ddbs = max_devs;\r\nreturn 0;\r\n}\r\nstatic int asd_extend_cmdctx(struct asd_ha_struct *asd_ha)\r\n{\r\ndma_addr_t dma_handle;\r\nunsigned long dma_addr;\r\nu32 d;\r\nint size;\r\nasd_ha->hw_prof.scb_ext = NULL;\r\nif (max_cmnds <= asd_ha->hw_prof.max_scbs || max_cmnds > 0xFFFF) {\r\nmax_cmnds = asd_ha->hw_prof.max_scbs;\r\nreturn 0;\r\n}\r\nsize = (max_cmnds - asd_ha->hw_prof.max_scbs + 1) * ASD_SCB_SIZE;\r\nasd_ha->hw_prof.scb_ext = asd_alloc_coherent(asd_ha, size, GFP_KERNEL);\r\nif (!asd_ha->hw_prof.scb_ext) {\r\nasd_printk("couldn't allocate memory for %d commands\n",\r\nmax_cmnds);\r\nmax_cmnds = asd_ha->hw_prof.max_scbs;\r\nreturn -ENOMEM;\r\n}\r\ndma_handle = asd_ha->hw_prof.scb_ext->dma_handle;\r\ndma_addr = ALIGN((unsigned long) dma_handle, ASD_SCB_SIZE);\r\ndma_addr -= asd_ha->hw_prof.max_scbs * ASD_SCB_SIZE;\r\ndma_handle = (dma_addr_t) dma_addr;\r\nasd_write_reg_addr(asd_ha, CMDCTXBASE, dma_handle);\r\nd = asd_read_reg_dword(asd_ha, CTXDOMAIN);\r\nd &= ~1;\r\nasd_write_reg_dword(asd_ha, CTXDOMAIN, d);\r\nasd_ha->hw_prof.max_scbs = max_cmnds;\r\nreturn 0;\r\n}\r\nstatic int asd_init_ctxmem(struct asd_ha_struct *asd_ha)\r\n{\r\nint bitmap_bytes;\r\nasd_get_max_scb_ddb(asd_ha);\r\nasd_extend_devctx(asd_ha);\r\nasd_extend_cmdctx(asd_ha);\r\nbitmap_bytes = (asd_ha->hw_prof.max_ddbs+7)/8;\r\nbitmap_bytes = BITS_TO_LONGS(bitmap_bytes*8)*sizeof(unsigned long);\r\nasd_ha->hw_prof.ddb_bitmap = kzalloc(bitmap_bytes, GFP_KERNEL);\r\nif (!asd_ha->hw_prof.ddb_bitmap)\r\nreturn -ENOMEM;\r\nspin_lock_init(&asd_ha->hw_prof.ddb_lock);\r\nreturn 0;\r\n}\r\nint asd_init_hw(struct asd_ha_struct *asd_ha)\r\n{\r\nint err;\r\nu32 v;\r\nerr = asd_init_sw(asd_ha);\r\nif (err)\r\nreturn err;\r\nerr = pci_read_config_dword(asd_ha->pcidev, PCIC_HSTPCIX_CNTRL, &v);\r\nif (err) {\r\nasd_printk("couldn't read PCIC_HSTPCIX_CNTRL of %s\n",\r\npci_name(asd_ha->pcidev));\r\nreturn err;\r\n}\r\npci_write_config_dword(asd_ha->pcidev, PCIC_HSTPCIX_CNTRL,\r\nv | SC_TMR_DIS);\r\nif (err) {\r\nasd_printk("couldn't disable split completion timer of %s\n",\r\npci_name(asd_ha->pcidev));\r\nreturn err;\r\n}\r\nerr = asd_read_ocm(asd_ha);\r\nif (err) {\r\nasd_printk("couldn't read ocm(%d)\n", err);\r\n}\r\nerr = asd_read_flash(asd_ha);\r\nif (err) {\r\nasd_printk("couldn't read flash(%d)\n", err);\r\n}\r\nasd_init_ctxmem(asd_ha);\r\nif (asd_get_user_sas_addr(asd_ha)) {\r\nasd_printk("No SAS Address provided for %s\n",\r\npci_name(asd_ha->pcidev));\r\nerr = -ENODEV;\r\ngoto Out;\r\n}\r\nasd_propagate_sas_addr(asd_ha);\r\nerr = asd_init_phys(asd_ha);\r\nif (err) {\r\nasd_printk("couldn't initialize phys for %s\n",\r\npci_name(asd_ha->pcidev));\r\ngoto Out;\r\n}\r\nasd_init_ports(asd_ha);\r\nerr = asd_init_scbs(asd_ha);\r\nif (err) {\r\nasd_printk("couldn't initialize scbs for %s\n",\r\npci_name(asd_ha->pcidev));\r\ngoto Out;\r\n}\r\nerr = asd_init_dl(asd_ha);\r\nif (err) {\r\nasd_printk("couldn't initialize the done list:%d\n",\r\nerr);\r\ngoto Out;\r\n}\r\nerr = asd_init_escbs(asd_ha);\r\nif (err) {\r\nasd_printk("couldn't initialize escbs\n");\r\ngoto Out;\r\n}\r\nerr = asd_init_chip(asd_ha);\r\nif (err) {\r\nasd_printk("couldn't init the chip\n");\r\ngoto Out;\r\n}\r\nOut:\r\nreturn err;\r\n}\r\nstatic void asd_chip_reset(struct asd_ha_struct *asd_ha)\r\n{\r\nstruct sas_ha_struct *sas_ha = &asd_ha->sas_ha;\r\nASD_DPRINTK("chip reset for %s\n", pci_name(asd_ha->pcidev));\r\nasd_chip_hardrst(asd_ha);\r\nsas_ha->notify_ha_event(sas_ha, HAE_RESET);\r\n}\r\nstatic void asd_dl_tasklet_handler(unsigned long data)\r\n{\r\nstruct asd_ha_struct *asd_ha = (struct asd_ha_struct *) data;\r\nstruct asd_seq_data *seq = &asd_ha->seq;\r\nunsigned long flags;\r\nwhile (1) {\r\nstruct done_list_struct *dl = &seq->dl[seq->dl_next];\r\nstruct asd_ascb *ascb;\r\nif ((dl->toggle & DL_TOGGLE_MASK) != seq->dl_toggle)\r\nbreak;\r\nspin_lock_irqsave(&seq->tc_index_lock, flags);\r\nascb = asd_tc_index_find(seq, (int)le16_to_cpu(dl->index));\r\nspin_unlock_irqrestore(&seq->tc_index_lock, flags);\r\nif (unlikely(!ascb)) {\r\nASD_DPRINTK("BUG:sequencer:dl:no ascb?!\n");\r\ngoto next_1;\r\n} else if (ascb->scb->header.opcode == EMPTY_SCB) {\r\ngoto out;\r\n} else if (!ascb->uldd_timer && !del_timer(&ascb->timer)) {\r\ngoto next_1;\r\n}\r\nspin_lock_irqsave(&seq->pend_q_lock, flags);\r\nlist_del_init(&ascb->list);\r\nseq->pending--;\r\nspin_unlock_irqrestore(&seq->pend_q_lock, flags);\r\nout:\r\nascb->tasklet_complete(ascb, dl);\r\nnext_1:\r\nseq->dl_next = (seq->dl_next + 1) & (ASD_DL_SIZE-1);\r\nif (!seq->dl_next)\r\nseq->dl_toggle ^= DL_TOGGLE_MASK;\r\n}\r\n}\r\nstatic void asd_process_donelist_isr(struct asd_ha_struct *asd_ha)\r\n{\r\ntasklet_schedule(&asd_ha->seq.dl_tasklet);\r\n}\r\nstatic void asd_com_sas_isr(struct asd_ha_struct *asd_ha)\r\n{\r\nu32 comstat = asd_read_reg_dword(asd_ha, COMSTAT);\r\nasd_write_reg_dword(asd_ha, COMSTAT, 0xFFFFFFFF);\r\nif (comstat & CSBUFPERR) {\r\nasd_printk("%s: command/status buffer dma parity error\n",\r\npci_name(asd_ha->pcidev));\r\n} else if (comstat & CSERR) {\r\nint i;\r\nu32 dmaerr = asd_read_reg_dword(asd_ha, DMAERR);\r\ndmaerr &= 0xFF;\r\nasd_printk("%s: command/status dma error, DMAERR: 0x%02x, "\r\n"CSDMAADR: 0x%04x, CSDMAADR+4: 0x%04x\n",\r\npci_name(asd_ha->pcidev),\r\ndmaerr,\r\nasd_read_reg_dword(asd_ha, CSDMAADR),\r\nasd_read_reg_dword(asd_ha, CSDMAADR+4));\r\nasd_printk("CSBUFFER:\n");\r\nfor (i = 0; i < 8; i++) {\r\nasd_printk("%08x %08x %08x %08x\n",\r\nasd_read_reg_dword(asd_ha, CSBUFFER),\r\nasd_read_reg_dword(asd_ha, CSBUFFER+4),\r\nasd_read_reg_dword(asd_ha, CSBUFFER+8),\r\nasd_read_reg_dword(asd_ha, CSBUFFER+12));\r\n}\r\nasd_dump_seq_state(asd_ha, 0);\r\n} else if (comstat & OVLYERR) {\r\nu32 dmaerr = asd_read_reg_dword(asd_ha, DMAERR);\r\ndmaerr = (dmaerr >> 8) & 0xFF;\r\nasd_printk("%s: overlay dma error:0x%x\n",\r\npci_name(asd_ha->pcidev),\r\ndmaerr);\r\n}\r\nasd_chip_reset(asd_ha);\r\n}\r\nstatic void asd_arp2_err(struct asd_ha_struct *asd_ha, u32 dchstatus)\r\n{\r\nstatic const char *halt_code[256] = {\r\n"UNEXPECTED_INTERRUPT0",\r\n"UNEXPECTED_INTERRUPT1",\r\n"UNEXPECTED_INTERRUPT2",\r\n"UNEXPECTED_INTERRUPT3",\r\n"UNEXPECTED_INTERRUPT4",\r\n"UNEXPECTED_INTERRUPT5",\r\n"UNEXPECTED_INTERRUPT6",\r\n"UNEXPECTED_INTERRUPT7",\r\n"UNEXPECTED_INTERRUPT8",\r\n"UNEXPECTED_INTERRUPT9",\r\n"UNEXPECTED_INTERRUPT10",\r\n[11 ... 19] = "unknown[11,19]",\r\n"NO_FREE_SCB_AVAILABLE",\r\n"INVALID_SCB_OPCODE",\r\n"INVALID_MBX_OPCODE",\r\n"INVALID_ATA_STATE",\r\n"ATA_QUEUE_FULL",\r\n"ATA_TAG_TABLE_FAULT",\r\n"ATA_TAG_MASK_FAULT",\r\n"BAD_LINK_QUEUE_STATE",\r\n"DMA2CHIM_QUEUE_ERROR",\r\n"EMPTY_SCB_LIST_FULL",\r\n"unknown[30]",\r\n"IN_USE_SCB_ON_FREE_LIST",\r\n"BAD_OPEN_WAIT_STATE",\r\n"INVALID_STP_AFFILIATION",\r\n"unknown[34]",\r\n"EXEC_QUEUE_ERROR",\r\n"TOO_MANY_EMPTIES_NEEDED",\r\n"EMPTY_REQ_QUEUE_ERROR",\r\n"Q_MONIRTT_MGMT_ERROR",\r\n"TARGET_MODE_FLOW_ERROR",\r\n"DEVICE_QUEUE_NOT_FOUND",\r\n"START_IRTT_TIMER_ERROR",\r\n"ABORT_TASK_ILLEGAL_REQ",\r\n[43 ... 255] = "unknown[43,255]"\r\n};\r\nif (dchstatus & CSEQINT) {\r\nu32 arp2int = asd_read_reg_dword(asd_ha, CARP2INT);\r\nif (arp2int & (ARP2WAITTO|ARP2ILLOPC|ARP2PERR|ARP2CIOPERR)) {\r\nasd_printk("%s: CSEQ arp2int:0x%x\n",\r\npci_name(asd_ha->pcidev),\r\narp2int);\r\n} else if (arp2int & ARP2HALTC)\r\nasd_printk("%s: CSEQ halted: %s\n",\r\npci_name(asd_ha->pcidev),\r\nhalt_code[(arp2int>>16)&0xFF]);\r\nelse\r\nasd_printk("%s: CARP2INT:0x%x\n",\r\npci_name(asd_ha->pcidev),\r\narp2int);\r\n}\r\nif (dchstatus & LSEQINT_MASK) {\r\nint lseq;\r\nu8 lseq_mask = dchstatus & LSEQINT_MASK;\r\nfor_each_sequencer(lseq_mask, lseq_mask, lseq) {\r\nu32 arp2int = asd_read_reg_dword(asd_ha,\r\nLmARP2INT(lseq));\r\nif (arp2int & (ARP2WAITTO | ARP2ILLOPC | ARP2PERR\r\n| ARP2CIOPERR)) {\r\nasd_printk("%s: LSEQ%d arp2int:0x%x\n",\r\npci_name(asd_ha->pcidev),\r\nlseq, arp2int);\r\n} else if (arp2int & ARP2HALTC)\r\nasd_printk("%s: LSEQ%d halted: %s\n",\r\npci_name(asd_ha->pcidev),\r\nlseq,halt_code[(arp2int>>16)&0xFF]);\r\nelse\r\nasd_printk("%s: LSEQ%d ARP2INT:0x%x\n",\r\npci_name(asd_ha->pcidev), lseq,\r\narp2int);\r\n}\r\n}\r\nasd_chip_reset(asd_ha);\r\n}\r\nstatic void asd_dch_sas_isr(struct asd_ha_struct *asd_ha)\r\n{\r\nu32 dchstatus = asd_read_reg_dword(asd_ha, DCHSTATUS);\r\nif (dchstatus & CFIFTOERR) {\r\nasd_printk("%s: CFIFTOERR\n", pci_name(asd_ha->pcidev));\r\nasd_chip_reset(asd_ha);\r\n} else\r\nasd_arp2_err(asd_ha, dchstatus);\r\n}\r\nstatic void asd_rbi_exsi_isr(struct asd_ha_struct *asd_ha)\r\n{\r\nu32 stat0r = asd_read_reg_dword(asd_ha, ASISTAT0R);\r\nif (!(stat0r & ASIERR)) {\r\nasd_printk("hmm, EXSI interrupted but no error?\n");\r\nreturn;\r\n}\r\nif (stat0r & ASIFMTERR) {\r\nasd_printk("ASI SEEPROM format error for %s\n",\r\npci_name(asd_ha->pcidev));\r\n} else if (stat0r & ASISEECHKERR) {\r\nu32 stat1r = asd_read_reg_dword(asd_ha, ASISTAT1R);\r\nasd_printk("ASI SEEPROM checksum 0x%x error for %s\n",\r\nstat1r & CHECKSUM_MASK,\r\npci_name(asd_ha->pcidev));\r\n} else {\r\nu32 statr = asd_read_reg_dword(asd_ha, ASIERRSTATR);\r\nif (!(statr & CPI2ASIMSTERR_MASK)) {\r\nASD_DPRINTK("hmm, ASIERR?\n");\r\nreturn;\r\n} else {\r\nu32 addr = asd_read_reg_dword(asd_ha, ASIERRADDR);\r\nu32 data = asd_read_reg_dword(asd_ha, ASIERRDATAR);\r\nasd_printk("%s: CPI2 xfer err: addr: 0x%x, wdata: 0x%x, "\r\n"count: 0x%x, byteen: 0x%x, targerr: 0x%x "\r\n"master id: 0x%x, master err: 0x%x\n",\r\npci_name(asd_ha->pcidev),\r\naddr, data,\r\n(statr & CPI2ASIBYTECNT_MASK) >> 16,\r\n(statr & CPI2ASIBYTEEN_MASK) >> 12,\r\n(statr & CPI2ASITARGERR_MASK) >> 8,\r\n(statr & CPI2ASITARGMID_MASK) >> 4,\r\n(statr & CPI2ASIMSTERR_MASK));\r\n}\r\n}\r\nasd_chip_reset(asd_ha);\r\n}\r\nstatic void asd_hst_pcix_isr(struct asd_ha_struct *asd_ha)\r\n{\r\nu16 status;\r\nu32 pcix_status;\r\nu32 ecc_status;\r\npci_read_config_word(asd_ha->pcidev, PCI_STATUS, &status);\r\npci_read_config_dword(asd_ha->pcidev, PCIX_STATUS, &pcix_status);\r\npci_read_config_dword(asd_ha->pcidev, ECC_CTRL_STAT, &ecc_status);\r\nif (status & PCI_STATUS_DETECTED_PARITY)\r\nasd_printk("parity error for %s\n", pci_name(asd_ha->pcidev));\r\nelse if (status & PCI_STATUS_REC_MASTER_ABORT)\r\nasd_printk("master abort for %s\n", pci_name(asd_ha->pcidev));\r\nelse if (status & PCI_STATUS_REC_TARGET_ABORT)\r\nasd_printk("target abort for %s\n", pci_name(asd_ha->pcidev));\r\nelse if (status & PCI_STATUS_PARITY)\r\nasd_printk("data parity for %s\n", pci_name(asd_ha->pcidev));\r\nelse if (pcix_status & RCV_SCE) {\r\nasd_printk("received split completion error for %s\n",\r\npci_name(asd_ha->pcidev));\r\npci_write_config_dword(asd_ha->pcidev,PCIX_STATUS,pcix_status);\r\nreturn;\r\n} else if (pcix_status & UNEXP_SC) {\r\nasd_printk("unexpected split completion for %s\n",\r\npci_name(asd_ha->pcidev));\r\npci_write_config_dword(asd_ha->pcidev,PCIX_STATUS,pcix_status);\r\nreturn;\r\n} else if (pcix_status & SC_DISCARD)\r\nasd_printk("split completion discarded for %s\n",\r\npci_name(asd_ha->pcidev));\r\nelse if (ecc_status & UNCOR_ECCERR)\r\nasd_printk("uncorrectable ECC error for %s\n",\r\npci_name(asd_ha->pcidev));\r\nasd_chip_reset(asd_ha);\r\n}\r\nirqreturn_t asd_hw_isr(int irq, void *dev_id)\r\n{\r\nstruct asd_ha_struct *asd_ha = dev_id;\r\nu32 chimint = asd_read_reg_dword(asd_ha, CHIMINT);\r\nif (!chimint)\r\nreturn IRQ_NONE;\r\nasd_write_reg_dword(asd_ha, CHIMINT, chimint);\r\n(void) asd_read_reg_dword(asd_ha, CHIMINT);\r\nif (chimint & DLAVAIL)\r\nasd_process_donelist_isr(asd_ha);\r\nif (chimint & COMINT)\r\nasd_com_sas_isr(asd_ha);\r\nif (chimint & DEVINT)\r\nasd_dch_sas_isr(asd_ha);\r\nif (chimint & INITERR)\r\nasd_rbi_exsi_isr(asd_ha);\r\nif (chimint & HOSTERR)\r\nasd_hst_pcix_isr(asd_ha);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct asd_ascb *asd_ascb_alloc(struct asd_ha_struct *asd_ha,\r\ngfp_t gfp_flags)\r\n{\r\nextern struct kmem_cache *asd_ascb_cache;\r\nstruct asd_seq_data *seq = &asd_ha->seq;\r\nstruct asd_ascb *ascb;\r\nunsigned long flags;\r\nascb = kmem_cache_zalloc(asd_ascb_cache, gfp_flags);\r\nif (ascb) {\r\nascb->dma_scb.size = sizeof(struct scb);\r\nascb->dma_scb.vaddr = dma_pool_alloc(asd_ha->scb_pool,\r\ngfp_flags,\r\n&ascb->dma_scb.dma_handle);\r\nif (!ascb->dma_scb.vaddr) {\r\nkmem_cache_free(asd_ascb_cache, ascb);\r\nreturn NULL;\r\n}\r\nmemset(ascb->dma_scb.vaddr, 0, sizeof(struct scb));\r\nasd_init_ascb(asd_ha, ascb);\r\nspin_lock_irqsave(&seq->tc_index_lock, flags);\r\nascb->tc_index = asd_tc_index_get(seq, ascb);\r\nspin_unlock_irqrestore(&seq->tc_index_lock, flags);\r\nif (ascb->tc_index == -1)\r\ngoto undo;\r\nascb->scb->header.index = cpu_to_le16((u16)ascb->tc_index);\r\n}\r\nreturn ascb;\r\nundo:\r\ndma_pool_free(asd_ha->scb_pool, ascb->dma_scb.vaddr,\r\nascb->dma_scb.dma_handle);\r\nkmem_cache_free(asd_ascb_cache, ascb);\r\nASD_DPRINTK("no index for ascb\n");\r\nreturn NULL;\r\n}\r\nstruct asd_ascb *asd_ascb_alloc_list(struct asd_ha_struct\r\n*asd_ha, int *num,\r\ngfp_t gfp_flags)\r\n{\r\nstruct asd_ascb *first = NULL;\r\nfor ( ; *num > 0; --*num) {\r\nstruct asd_ascb *ascb = asd_ascb_alloc(asd_ha, gfp_flags);\r\nif (!ascb)\r\nbreak;\r\nelse if (!first)\r\nfirst = ascb;\r\nelse {\r\nstruct asd_ascb *last = list_entry(first->list.prev,\r\nstruct asd_ascb,\r\nlist);\r\nlist_add_tail(&ascb->list, &first->list);\r\nlast->scb->header.next_scb =\r\ncpu_to_le64(((u64)ascb->dma_scb.dma_handle));\r\n}\r\n}\r\nreturn first;\r\n}\r\nstatic void asd_swap_head_scb(struct asd_ha_struct *asd_ha,\r\nstruct asd_ascb *ascb)\r\n{\r\nstruct asd_seq_data *seq = &asd_ha->seq;\r\nstruct asd_ascb *last = list_entry(ascb->list.prev,\r\nstruct asd_ascb,\r\nlist);\r\nstruct asd_dma_tok t = ascb->dma_scb;\r\nmemcpy(seq->next_scb.vaddr, ascb->scb, sizeof(*ascb->scb));\r\nascb->dma_scb = seq->next_scb;\r\nascb->scb = ascb->dma_scb.vaddr;\r\nseq->next_scb = t;\r\nlast->scb->header.next_scb =\r\ncpu_to_le64(((u64)seq->next_scb.dma_handle));\r\n}\r\nstatic void asd_start_scb_timers(struct list_head *list)\r\n{\r\nstruct asd_ascb *ascb;\r\nlist_for_each_entry(ascb, list, list) {\r\nif (!ascb->uldd_timer) {\r\nascb->timer.data = (unsigned long) ascb;\r\nascb->timer.function = asd_ascb_timedout;\r\nascb->timer.expires = jiffies + AIC94XX_SCB_TIMEOUT;\r\nadd_timer(&ascb->timer);\r\n}\r\n}\r\n}\r\nint asd_post_ascb_list(struct asd_ha_struct *asd_ha, struct asd_ascb *ascb,\r\nint num)\r\n{\r\nunsigned long flags;\r\nLIST_HEAD(list);\r\nint can_queue;\r\nspin_lock_irqsave(&asd_ha->seq.pend_q_lock, flags);\r\ncan_queue = asd_ha->hw_prof.max_scbs - asd_ha->seq.pending;\r\nif (can_queue >= num)\r\nasd_ha->seq.pending += num;\r\nelse\r\ncan_queue = 0;\r\nif (!can_queue) {\r\nspin_unlock_irqrestore(&asd_ha->seq.pend_q_lock, flags);\r\nasd_printk("%s: scb queue full\n", pci_name(asd_ha->pcidev));\r\nreturn -SAS_QUEUE_FULL;\r\n}\r\nasd_swap_head_scb(asd_ha, ascb);\r\n__list_add(&list, ascb->list.prev, &ascb->list);\r\nasd_start_scb_timers(&list);\r\nasd_ha->seq.scbpro += num;\r\nlist_splice_init(&list, asd_ha->seq.pend_q.prev);\r\nasd_write_reg_dword(asd_ha, SCBPRO, (u32)asd_ha->seq.scbpro);\r\nspin_unlock_irqrestore(&asd_ha->seq.pend_q_lock, flags);\r\nreturn 0;\r\n}\r\nint asd_post_escb_list(struct asd_ha_struct *asd_ha, struct asd_ascb *ascb,\r\nint num)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&asd_ha->seq.pend_q_lock, flags);\r\nasd_swap_head_scb(asd_ha, ascb);\r\nasd_ha->seq.scbpro += num;\r\nasd_write_reg_dword(asd_ha, SCBPRO, (u32)asd_ha->seq.scbpro);\r\nspin_unlock_irqrestore(&asd_ha->seq.pend_q_lock, flags);\r\nreturn 0;\r\n}\r\nvoid asd_turn_led(struct asd_ha_struct *asd_ha, int phy_id, int op)\r\n{\r\nif (phy_id < ASD_MAX_PHYS) {\r\nu32 v = asd_read_reg_dword(asd_ha, LmCONTROL(phy_id));\r\nif (op)\r\nv |= LEDPOL;\r\nelse\r\nv &= ~LEDPOL;\r\nasd_write_reg_dword(asd_ha, LmCONTROL(phy_id), v);\r\n}\r\n}\r\nvoid asd_control_led(struct asd_ha_struct *asd_ha, int phy_id, int op)\r\n{\r\nif (phy_id < ASD_MAX_PHYS) {\r\nu32 v;\r\nv = asd_read_reg_dword(asd_ha, GPIOOER);\r\nif (op)\r\nv |= (1 << phy_id);\r\nelse\r\nv &= ~(1 << phy_id);\r\nasd_write_reg_dword(asd_ha, GPIOOER, v);\r\nv = asd_read_reg_dword(asd_ha, GPIOCNFGR);\r\nif (op)\r\nv |= (1 << phy_id);\r\nelse\r\nv &= ~(1 << phy_id);\r\nasd_write_reg_dword(asd_ha, GPIOCNFGR, v);\r\n}\r\n}\r\nstatic int asd_enable_phy(struct asd_ha_struct *asd_ha, int phy_id)\r\n{\r\nstruct asd_phy *phy = &asd_ha->phys[phy_id];\r\nasd_write_reg_byte(asd_ha, LmSEQ_OOB_REG(phy_id, INT_ENABLE_2), 0);\r\nasd_write_reg_byte(asd_ha, LmSEQ_OOB_REG(phy_id, HOT_PLUG_DELAY),\r\nHOTPLUG_DELAY_TIMEOUT);\r\nasd_write_reg_byte(asd_ha, LmSEQ_OOB_REG(phy_id, PHY_CONTROL_0),\r\nphy->phy_desc->phy_control_0);\r\nasd_write_reg_byte(asd_ha, LmSEQ_OOB_REG(phy_id, PHY_CONTROL_1),\r\nphy->phy_desc->phy_control_1);\r\nasd_write_reg_byte(asd_ha, LmSEQ_OOB_REG(phy_id, PHY_CONTROL_2),\r\nphy->phy_desc->phy_control_2);\r\nasd_write_reg_byte(asd_ha, LmSEQ_OOB_REG(phy_id, PHY_CONTROL_3),\r\nphy->phy_desc->phy_control_3);\r\nasd_write_reg_dword(asd_ha, LmSEQ_TEN_MS_COMINIT_TIMEOUT(phy_id),\r\nASD_COMINIT_TIMEOUT);\r\nasd_write_reg_addr(asd_ha, LmSEQ_TX_ID_ADDR_FRAME(phy_id),\r\nphy->id_frm_tok->dma_handle);\r\nasd_control_led(asd_ha, phy_id, 1);\r\nreturn 0;\r\n}\r\nint asd_enable_phys(struct asd_ha_struct *asd_ha, const u8 phy_mask)\r\n{\r\nu8 phy_m;\r\nu8 i;\r\nint num = 0, k;\r\nstruct asd_ascb *ascb;\r\nstruct asd_ascb *ascb_list;\r\nif (!phy_mask) {\r\nasd_printk("%s called with phy_mask of 0!?\n", __func__);\r\nreturn 0;\r\n}\r\nfor_each_phy(phy_mask, phy_m, i) {\r\nnum++;\r\nasd_enable_phy(asd_ha, i);\r\n}\r\nk = num;\r\nascb_list = asd_ascb_alloc_list(asd_ha, &k, GFP_KERNEL);\r\nif (!ascb_list) {\r\nasd_printk("no memory for control phy ascb list\n");\r\nreturn -ENOMEM;\r\n}\r\nnum -= k;\r\nascb = ascb_list;\r\nfor_each_phy(phy_mask, phy_m, i) {\r\nasd_build_control_phy(ascb, i, ENABLE_PHY);\r\nascb = list_entry(ascb->list.next, struct asd_ascb, list);\r\n}\r\nASD_DPRINTK("posting %d control phy scbs\n", num);\r\nk = asd_post_ascb_list(asd_ha, ascb_list, num);\r\nif (k)\r\nasd_ascb_free_list(ascb_list);\r\nreturn k;\r\n}
