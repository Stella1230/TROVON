static short read_state(struct kp_data *lp)\r\n{\r\nunsigned char x, y, a, b;\r\ni2c_smbus_write_byte(lp->client, 240);\r\nx = 0xF & (~(i2c_smbus_read_byte(lp->client) >> 4));\r\ni2c_smbus_write_byte(lp->client, 15);\r\ny = 0xF & (~i2c_smbus_read_byte(lp->client));\r\nfor (a = 0; x > 0; a++)\r\nx = x >> 1;\r\nfor (b = 0; y > 0; b++)\r\ny = y >> 1;\r\nreturn ((a - 1) * 4) + b;\r\n}\r\nstatic irqreturn_t pcf8574_kp_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct kp_data *lp = dev_id;\r\nunsigned char nextstate = read_state(lp);\r\nif (lp->laststate != nextstate) {\r\nint key_down = nextstate < ARRAY_SIZE(lp->btncode);\r\nunsigned short keycode = key_down ?\r\nlp->btncode[nextstate] : lp->btncode[lp->laststate];\r\ninput_report_key(lp->idev, keycode, key_down);\r\ninput_sync(lp->idev);\r\nlp->laststate = nextstate;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit pcf8574_kp_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nint i, ret;\r\nstruct input_dev *idev;\r\nstruct kp_data *lp;\r\nif (i2c_smbus_write_byte(client, 240) < 0) {\r\ndev_err(&client->dev, "probe: write fail\n");\r\nreturn -ENODEV;\r\n}\r\nlp = kzalloc(sizeof(*lp), GFP_KERNEL);\r\nif (!lp)\r\nreturn -ENOMEM;\r\nidev = input_allocate_device();\r\nif (!idev) {\r\ndev_err(&client->dev, "Can't allocate input device\n");\r\nret = -ENOMEM;\r\ngoto fail_allocate;\r\n}\r\nlp->idev = idev;\r\nlp->client = client;\r\nidev->evbit[0] = BIT_MASK(EV_KEY);\r\nidev->keycode = lp->btncode;\r\nidev->keycodesize = sizeof(lp->btncode[0]);\r\nidev->keycodemax = ARRAY_SIZE(lp->btncode);\r\nfor (i = 0; i < ARRAY_SIZE(pcf8574_kp_btncode); i++) {\r\nlp->btncode[i] = pcf8574_kp_btncode[i];\r\n__set_bit(lp->btncode[i] & KEY_MAX, idev->keybit);\r\n}\r\nsprintf(lp->name, DRV_NAME);\r\nsprintf(lp->phys, "kp_data/input0");\r\nidev->name = lp->name;\r\nidev->phys = lp->phys;\r\nidev->id.bustype = BUS_I2C;\r\nidev->id.vendor = 0x0001;\r\nidev->id.product = 0x0001;\r\nidev->id.version = 0x0100;\r\nlp->laststate = read_state(lp);\r\nret = request_threaded_irq(client->irq, NULL, pcf8574_kp_irq_handler,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\nDRV_NAME, lp);\r\nif (ret) {\r\ndev_err(&client->dev, "IRQ %d is not free\n", client->irq);\r\ngoto fail_free_device;\r\n}\r\nret = input_register_device(idev);\r\nif (ret) {\r\ndev_err(&client->dev, "input_register_device() failed\n");\r\ngoto fail_free_irq;\r\n}\r\ni2c_set_clientdata(client, lp);\r\nreturn 0;\r\nfail_free_irq:\r\nfree_irq(client->irq, lp);\r\nfail_free_device:\r\ninput_free_device(idev);\r\nfail_allocate:\r\nkfree(lp);\r\nreturn ret;\r\n}\r\nstatic int __devexit pcf8574_kp_remove(struct i2c_client *client)\r\n{\r\nstruct kp_data *lp = i2c_get_clientdata(client);\r\nfree_irq(client->irq, lp);\r\ninput_unregister_device(lp->idev);\r\nkfree(lp);\r\nreturn 0;\r\n}\r\nstatic int pcf8574_kp_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nenable_irq(client->irq);\r\nreturn 0;\r\n}\r\nstatic int pcf8574_kp_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\ndisable_irq(client->irq);\r\nreturn 0;\r\n}\r\nstatic int __init pcf8574_kp_init(void)\r\n{\r\nreturn i2c_add_driver(&pcf8574_kp_driver);\r\n}\r\nstatic void __exit pcf8574_kp_exit(void)\r\n{\r\ni2c_del_driver(&pcf8574_kp_driver);\r\n}
