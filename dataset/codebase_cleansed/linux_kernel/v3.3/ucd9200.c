static int ucd9200_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nu8 block_buffer[I2C_SMBUS_BLOCK_MAX + 1];\r\nstruct pmbus_driver_info *info;\r\nconst struct i2c_device_id *mid;\r\nint i, j, ret;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_DATA))\r\nreturn -ENODEV;\r\nret = i2c_smbus_read_block_data(client, UCD9200_DEVICE_ID,\r\nblock_buffer);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to read device ID\n");\r\nreturn ret;\r\n}\r\nblock_buffer[ret] = '\0';\r\ndev_info(&client->dev, "Device ID %s\n", block_buffer);\r\nfor (mid = ucd9200_id; mid->name[0]; mid++) {\r\nif (!strncasecmp(mid->name, block_buffer, strlen(mid->name)))\r\nbreak;\r\n}\r\nif (!mid->name[0]) {\r\ndev_err(&client->dev, "Unsupported device\n");\r\nreturn -ENODEV;\r\n}\r\nif (id->driver_data != ucd9200 && id->driver_data != mid->driver_data)\r\ndev_notice(&client->dev,\r\n"Device mismatch: Configured %s, detected %s\n",\r\nid->name, mid->name);\r\ninfo = kzalloc(sizeof(struct pmbus_driver_info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nret = i2c_smbus_read_block_data(client, UCD9200_PHASE_INFO,\r\nblock_buffer);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to read phase information\n");\r\ngoto out;\r\n}\r\ninfo->pages = 0;\r\nfor (i = 0; i < ret; i++) {\r\nif (!block_buffer[i])\r\nbreak;\r\ninfo->pages++;\r\n}\r\nif (!info->pages) {\r\ndev_err(&client->dev, "No rails configured\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\ndev_info(&client->dev, "%d rails configured\n", info->pages);\r\nfor (i = 0; i < info->pages; i++) {\r\nfor (j = 0; j < 3; j++) {\r\nret = i2c_smbus_write_byte_data(client, PMBUS_PAGE, i);\r\nif (ret < 0)\r\ncontinue;\r\nret = i2c_smbus_write_byte_data(client, PMBUS_PHASE,\r\n0xff);\r\nif (ret < 0)\r\ncontinue;\r\nbreak;\r\n}\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"Failed to initialize PHASE registers\n");\r\ngoto out;\r\n}\r\n}\r\nif (info->pages > 1)\r\ni2c_smbus_write_byte_data(client, PMBUS_PAGE, 0);\r\ninfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT |\r\nPMBUS_HAVE_IIN | PMBUS_HAVE_PIN |\r\nPMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT |\r\nPMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT |\r\nPMBUS_HAVE_POUT | PMBUS_HAVE_TEMP |\r\nPMBUS_HAVE_TEMP2 | PMBUS_HAVE_STATUS_TEMP;\r\nfor (i = 1; i < info->pages; i++)\r\ninfo->func[i] = PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT |\r\nPMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT |\r\nPMBUS_HAVE_POUT |\r\nPMBUS_HAVE_TEMP2 | PMBUS_HAVE_STATUS_TEMP;\r\nif (mid->driver_data == ucd9240)\r\ninfo->func[0] |= PMBUS_HAVE_FAN12 | PMBUS_HAVE_STATUS_FAN12;\r\nret = pmbus_do_probe(client, mid, info);\r\nif (ret < 0)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nkfree(info);\r\nreturn ret;\r\n}\r\nstatic int ucd9200_remove(struct i2c_client *client)\r\n{\r\nconst struct pmbus_driver_info *info;\r\ninfo = pmbus_get_driver_info(client);\r\npmbus_do_remove(client);\r\nkfree(info);\r\nreturn 0;\r\n}\r\nstatic int __init ucd9200_init(void)\r\n{\r\nreturn i2c_add_driver(&ucd9200_driver);\r\n}\r\nstatic void __exit ucd9200_exit(void)\r\n{\r\ni2c_del_driver(&ucd9200_driver);\r\n}
