static int get_heap_comp_val(struct ubifs_lprops *lprops, int cat)\r\n{\r\nswitch (cat) {\r\ncase LPROPS_FREE:\r\nreturn lprops->free;\r\ncase LPROPS_DIRTY_IDX:\r\nreturn lprops->free + lprops->dirty;\r\ndefault:\r\nreturn lprops->dirty;\r\n}\r\n}\r\nstatic void move_up_lpt_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap,\r\nstruct ubifs_lprops *lprops, int cat)\r\n{\r\nint val1, val2, hpos;\r\nhpos = lprops->hpos;\r\nif (!hpos)\r\nreturn;\r\nval1 = get_heap_comp_val(lprops, cat);\r\ndo {\r\nint ppos = (hpos - 1) / 2;\r\nval2 = get_heap_comp_val(heap->arr[ppos], cat);\r\nif (val2 >= val1)\r\nreturn;\r\nheap->arr[ppos]->hpos = hpos;\r\nheap->arr[hpos] = heap->arr[ppos];\r\nheap->arr[ppos] = lprops;\r\nlprops->hpos = ppos;\r\nhpos = ppos;\r\n} while (hpos);\r\n}\r\nstatic void adjust_lpt_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap,\r\nstruct ubifs_lprops *lprops, int hpos, int cat)\r\n{\r\nint val1, val2, val3, cpos;\r\nval1 = get_heap_comp_val(lprops, cat);\r\nif (hpos) {\r\nint ppos = (hpos - 1) / 2;\r\nval2 = get_heap_comp_val(heap->arr[ppos], cat);\r\nif (val1 > val2) {\r\nwhile (1) {\r\nheap->arr[ppos]->hpos = hpos;\r\nheap->arr[hpos] = heap->arr[ppos];\r\nheap->arr[ppos] = lprops;\r\nlprops->hpos = ppos;\r\nhpos = ppos;\r\nif (!hpos)\r\nreturn;\r\nppos = (hpos - 1) / 2;\r\nval2 = get_heap_comp_val(heap->arr[ppos], cat);\r\nif (val1 <= val2)\r\nreturn;\r\n}\r\n}\r\n}\r\nwhile (1) {\r\ncpos = hpos * 2 + 1;\r\nif (cpos >= heap->cnt)\r\nreturn;\r\nval2 = get_heap_comp_val(heap->arr[cpos], cat);\r\nif (val1 < val2) {\r\nif (cpos + 1 < heap->cnt) {\r\nval3 = get_heap_comp_val(heap->arr[cpos + 1],\r\ncat);\r\nif (val3 > val2)\r\ncpos += 1;\r\n}\r\nheap->arr[cpos]->hpos = hpos;\r\nheap->arr[hpos] = heap->arr[cpos];\r\nheap->arr[cpos] = lprops;\r\nlprops->hpos = cpos;\r\nhpos = cpos;\r\ncontinue;\r\n}\r\ncpos += 1;\r\nif (cpos >= heap->cnt)\r\nreturn;\r\nval3 = get_heap_comp_val(heap->arr[cpos], cat);\r\nif (val1 < val3) {\r\nheap->arr[cpos]->hpos = hpos;\r\nheap->arr[hpos] = heap->arr[cpos];\r\nheap->arr[cpos] = lprops;\r\nlprops->hpos = cpos;\r\nhpos = cpos;\r\ncontinue;\r\n}\r\nreturn;\r\n}\r\n}\r\nstatic int add_to_lpt_heap(struct ubifs_info *c, struct ubifs_lprops *lprops,\r\nint cat)\r\n{\r\nstruct ubifs_lpt_heap *heap = &c->lpt_heap[cat - 1];\r\nif (heap->cnt >= heap->max_cnt) {\r\nconst int b = LPT_HEAP_SZ / 2 - 1;\r\nint cpos, val1, val2;\r\ncpos = (((size_t)lprops >> 4) & b) + b;\r\nubifs_assert(cpos >= b);\r\nubifs_assert(cpos < LPT_HEAP_SZ);\r\nubifs_assert(cpos < heap->cnt);\r\nval1 = get_heap_comp_val(lprops, cat);\r\nval2 = get_heap_comp_val(heap->arr[cpos], cat);\r\nif (val1 > val2) {\r\nstruct ubifs_lprops *lp;\r\nlp = heap->arr[cpos];\r\nlp->flags &= ~LPROPS_CAT_MASK;\r\nlp->flags |= LPROPS_UNCAT;\r\nlist_add(&lp->list, &c->uncat_list);\r\nlprops->hpos = cpos;\r\nheap->arr[cpos] = lprops;\r\nmove_up_lpt_heap(c, heap, lprops, cat);\r\ndbg_check_heap(c, heap, cat, lprops->hpos);\r\nreturn 1;\r\n}\r\ndbg_check_heap(c, heap, cat, -1);\r\nreturn 0;\r\n} else {\r\nlprops->hpos = heap->cnt++;\r\nheap->arr[lprops->hpos] = lprops;\r\nmove_up_lpt_heap(c, heap, lprops, cat);\r\ndbg_check_heap(c, heap, cat, lprops->hpos);\r\nreturn 1;\r\n}\r\n}\r\nstatic void remove_from_lpt_heap(struct ubifs_info *c,\r\nstruct ubifs_lprops *lprops, int cat)\r\n{\r\nstruct ubifs_lpt_heap *heap;\r\nint hpos = lprops->hpos;\r\nheap = &c->lpt_heap[cat - 1];\r\nubifs_assert(hpos >= 0 && hpos < heap->cnt);\r\nubifs_assert(heap->arr[hpos] == lprops);\r\nheap->cnt -= 1;\r\nif (hpos < heap->cnt) {\r\nheap->arr[hpos] = heap->arr[heap->cnt];\r\nheap->arr[hpos]->hpos = hpos;\r\nadjust_lpt_heap(c, heap, heap->arr[hpos], hpos, cat);\r\n}\r\ndbg_check_heap(c, heap, cat, -1);\r\n}\r\nstatic void lpt_heap_replace(struct ubifs_info *c,\r\nstruct ubifs_lprops *old_lprops,\r\nstruct ubifs_lprops *new_lprops, int cat)\r\n{\r\nstruct ubifs_lpt_heap *heap;\r\nint hpos = new_lprops->hpos;\r\nheap = &c->lpt_heap[cat - 1];\r\nheap->arr[hpos] = new_lprops;\r\n}\r\nvoid ubifs_add_to_cat(struct ubifs_info *c, struct ubifs_lprops *lprops,\r\nint cat)\r\n{\r\nswitch (cat) {\r\ncase LPROPS_DIRTY:\r\ncase LPROPS_DIRTY_IDX:\r\ncase LPROPS_FREE:\r\nif (add_to_lpt_heap(c, lprops, cat))\r\nbreak;\r\ncat = LPROPS_UNCAT;\r\ncase LPROPS_UNCAT:\r\nlist_add(&lprops->list, &c->uncat_list);\r\nbreak;\r\ncase LPROPS_EMPTY:\r\nlist_add(&lprops->list, &c->empty_list);\r\nbreak;\r\ncase LPROPS_FREEABLE:\r\nlist_add(&lprops->list, &c->freeable_list);\r\nc->freeable_cnt += 1;\r\nbreak;\r\ncase LPROPS_FRDI_IDX:\r\nlist_add(&lprops->list, &c->frdi_idx_list);\r\nbreak;\r\ndefault:\r\nubifs_assert(0);\r\n}\r\nlprops->flags &= ~LPROPS_CAT_MASK;\r\nlprops->flags |= cat;\r\n}\r\nstatic void ubifs_remove_from_cat(struct ubifs_info *c,\r\nstruct ubifs_lprops *lprops, int cat)\r\n{\r\nswitch (cat) {\r\ncase LPROPS_DIRTY:\r\ncase LPROPS_DIRTY_IDX:\r\ncase LPROPS_FREE:\r\nremove_from_lpt_heap(c, lprops, cat);\r\nbreak;\r\ncase LPROPS_FREEABLE:\r\nc->freeable_cnt -= 1;\r\nubifs_assert(c->freeable_cnt >= 0);\r\ncase LPROPS_UNCAT:\r\ncase LPROPS_EMPTY:\r\ncase LPROPS_FRDI_IDX:\r\nubifs_assert(!list_empty(&lprops->list));\r\nlist_del(&lprops->list);\r\nbreak;\r\ndefault:\r\nubifs_assert(0);\r\n}\r\n}\r\nvoid ubifs_replace_cat(struct ubifs_info *c, struct ubifs_lprops *old_lprops,\r\nstruct ubifs_lprops *new_lprops)\r\n{\r\nint cat;\r\ncat = new_lprops->flags & LPROPS_CAT_MASK;\r\nswitch (cat) {\r\ncase LPROPS_DIRTY:\r\ncase LPROPS_DIRTY_IDX:\r\ncase LPROPS_FREE:\r\nlpt_heap_replace(c, old_lprops, new_lprops, cat);\r\nbreak;\r\ncase LPROPS_UNCAT:\r\ncase LPROPS_EMPTY:\r\ncase LPROPS_FREEABLE:\r\ncase LPROPS_FRDI_IDX:\r\nlist_replace(&old_lprops->list, &new_lprops->list);\r\nbreak;\r\ndefault:\r\nubifs_assert(0);\r\n}\r\n}\r\nvoid ubifs_ensure_cat(struct ubifs_info *c, struct ubifs_lprops *lprops)\r\n{\r\nint cat = lprops->flags & LPROPS_CAT_MASK;\r\nif (cat != LPROPS_UNCAT)\r\nreturn;\r\ncat = ubifs_categorize_lprops(c, lprops);\r\nif (cat == LPROPS_UNCAT)\r\nreturn;\r\nubifs_remove_from_cat(c, lprops, LPROPS_UNCAT);\r\nubifs_add_to_cat(c, lprops, cat);\r\n}\r\nint ubifs_categorize_lprops(const struct ubifs_info *c,\r\nconst struct ubifs_lprops *lprops)\r\n{\r\nif (lprops->flags & LPROPS_TAKEN)\r\nreturn LPROPS_UNCAT;\r\nif (lprops->free == c->leb_size) {\r\nubifs_assert(!(lprops->flags & LPROPS_INDEX));\r\nreturn LPROPS_EMPTY;\r\n}\r\nif (lprops->free + lprops->dirty == c->leb_size) {\r\nif (lprops->flags & LPROPS_INDEX)\r\nreturn LPROPS_FRDI_IDX;\r\nelse\r\nreturn LPROPS_FREEABLE;\r\n}\r\nif (lprops->flags & LPROPS_INDEX) {\r\nif (lprops->dirty + lprops->free >= c->min_idx_node_sz)\r\nreturn LPROPS_DIRTY_IDX;\r\n} else {\r\nif (lprops->dirty >= c->dead_wm &&\r\nlprops->dirty > lprops->free)\r\nreturn LPROPS_DIRTY;\r\nif (lprops->free > 0)\r\nreturn LPROPS_FREE;\r\n}\r\nreturn LPROPS_UNCAT;\r\n}\r\nstatic void change_category(struct ubifs_info *c, struct ubifs_lprops *lprops)\r\n{\r\nint old_cat = lprops->flags & LPROPS_CAT_MASK;\r\nint new_cat = ubifs_categorize_lprops(c, lprops);\r\nif (old_cat == new_cat) {\r\nstruct ubifs_lpt_heap *heap = &c->lpt_heap[new_cat - 1];\r\nif (new_cat < 1 || new_cat > LPROPS_HEAP_CNT)\r\nreturn;\r\nheap = &c->lpt_heap[new_cat - 1];\r\nadjust_lpt_heap(c, heap, lprops, lprops->hpos, new_cat);\r\n} else {\r\nubifs_remove_from_cat(c, lprops, old_cat);\r\nubifs_add_to_cat(c, lprops, new_cat);\r\n}\r\n}\r\nint ubifs_calc_dark(const struct ubifs_info *c, int spc)\r\n{\r\nubifs_assert(!(spc & 7));\r\nif (spc < c->dark_wm)\r\nreturn spc;\r\nif (spc - c->dark_wm < MIN_WRITE_SZ)\r\nreturn spc - MIN_WRITE_SZ;\r\nreturn c->dark_wm;\r\n}\r\nstatic int is_lprops_dirty(struct ubifs_info *c, struct ubifs_lprops *lprops)\r\n{\r\nstruct ubifs_pnode *pnode;\r\nint pos;\r\npos = (lprops->lnum - c->main_first) & (UBIFS_LPT_FANOUT - 1);\r\npnode = (struct ubifs_pnode *)container_of(lprops - pos,\r\nstruct ubifs_pnode,\r\nlprops[0]);\r\nreturn !test_bit(COW_CNODE, &pnode->flags) &&\r\ntest_bit(DIRTY_CNODE, &pnode->flags);\r\n}\r\nconst struct ubifs_lprops *ubifs_change_lp(struct ubifs_info *c,\r\nconst struct ubifs_lprops *lp,\r\nint free, int dirty, int flags,\r\nint idx_gc_cnt)\r\n{\r\nstruct ubifs_lprops *lprops = (struct ubifs_lprops *)lp;\r\ndbg_lp("LEB %d, free %d, dirty %d, flags %d",\r\nlprops->lnum, free, dirty, flags);\r\nubifs_assert(mutex_is_locked(&c->lp_mutex));\r\nubifs_assert(c->lst.empty_lebs >= 0 &&\r\nc->lst.empty_lebs <= c->main_lebs);\r\nubifs_assert(c->freeable_cnt >= 0);\r\nubifs_assert(c->freeable_cnt <= c->main_lebs);\r\nubifs_assert(c->lst.taken_empty_lebs >= 0);\r\nubifs_assert(c->lst.taken_empty_lebs <= c->lst.empty_lebs);\r\nubifs_assert(!(c->lst.total_free & 7) && !(c->lst.total_dirty & 7));\r\nubifs_assert(!(c->lst.total_dead & 7) && !(c->lst.total_dark & 7));\r\nubifs_assert(!(c->lst.total_used & 7));\r\nubifs_assert(free == LPROPS_NC || free >= 0);\r\nubifs_assert(dirty == LPROPS_NC || dirty >= 0);\r\nif (!is_lprops_dirty(c, lprops)) {\r\nlprops = ubifs_lpt_lookup_dirty(c, lprops->lnum);\r\nif (IS_ERR(lprops))\r\nreturn lprops;\r\n} else\r\nubifs_assert(lprops == ubifs_lpt_lookup_dirty(c, lprops->lnum));\r\nubifs_assert(!(lprops->free & 7) && !(lprops->dirty & 7));\r\nspin_lock(&c->space_lock);\r\nif ((lprops->flags & LPROPS_TAKEN) && lprops->free == c->leb_size)\r\nc->lst.taken_empty_lebs -= 1;\r\nif (!(lprops->flags & LPROPS_INDEX)) {\r\nint old_spc;\r\nold_spc = lprops->free + lprops->dirty;\r\nif (old_spc < c->dead_wm)\r\nc->lst.total_dead -= old_spc;\r\nelse\r\nc->lst.total_dark -= ubifs_calc_dark(c, old_spc);\r\nc->lst.total_used -= c->leb_size - old_spc;\r\n}\r\nif (free != LPROPS_NC) {\r\nfree = ALIGN(free, 8);\r\nc->lst.total_free += free - lprops->free;\r\nif (free == c->leb_size) {\r\nif (lprops->free != c->leb_size)\r\nc->lst.empty_lebs += 1;\r\n} else if (lprops->free == c->leb_size)\r\nc->lst.empty_lebs -= 1;\r\nlprops->free = free;\r\n}\r\nif (dirty != LPROPS_NC) {\r\ndirty = ALIGN(dirty, 8);\r\nc->lst.total_dirty += dirty - lprops->dirty;\r\nlprops->dirty = dirty;\r\n}\r\nif (flags != LPROPS_NC) {\r\nif ((lprops->flags & LPROPS_INDEX)) {\r\nif (!(flags & LPROPS_INDEX))\r\nc->lst.idx_lebs -= 1;\r\n} else if (flags & LPROPS_INDEX)\r\nc->lst.idx_lebs += 1;\r\nlprops->flags = flags;\r\n}\r\nif (!(lprops->flags & LPROPS_INDEX)) {\r\nint new_spc;\r\nnew_spc = lprops->free + lprops->dirty;\r\nif (new_spc < c->dead_wm)\r\nc->lst.total_dead += new_spc;\r\nelse\r\nc->lst.total_dark += ubifs_calc_dark(c, new_spc);\r\nc->lst.total_used += c->leb_size - new_spc;\r\n}\r\nif ((lprops->flags & LPROPS_TAKEN) && lprops->free == c->leb_size)\r\nc->lst.taken_empty_lebs += 1;\r\nchange_category(c, lprops);\r\nc->idx_gc_cnt += idx_gc_cnt;\r\nspin_unlock(&c->space_lock);\r\nreturn lprops;\r\n}\r\nvoid ubifs_get_lp_stats(struct ubifs_info *c, struct ubifs_lp_stats *lst)\r\n{\r\nspin_lock(&c->space_lock);\r\nmemcpy(lst, &c->lst, sizeof(struct ubifs_lp_stats));\r\nspin_unlock(&c->space_lock);\r\n}\r\nint ubifs_change_one_lp(struct ubifs_info *c, int lnum, int free, int dirty,\r\nint flags_set, int flags_clean, int idx_gc_cnt)\r\n{\r\nint err = 0, flags;\r\nconst struct ubifs_lprops *lp;\r\nubifs_get_lprops(c);\r\nlp = ubifs_lpt_lookup_dirty(c, lnum);\r\nif (IS_ERR(lp)) {\r\nerr = PTR_ERR(lp);\r\ngoto out;\r\n}\r\nflags = (lp->flags | flags_set) & ~flags_clean;\r\nlp = ubifs_change_lp(c, lp, free, dirty, flags, idx_gc_cnt);\r\nif (IS_ERR(lp))\r\nerr = PTR_ERR(lp);\r\nout:\r\nubifs_release_lprops(c);\r\nif (err)\r\nubifs_err("cannot change properties of LEB %d, error %d",\r\nlnum, err);\r\nreturn err;\r\n}\r\nint ubifs_update_one_lp(struct ubifs_info *c, int lnum, int free, int dirty,\r\nint flags_set, int flags_clean)\r\n{\r\nint err = 0, flags;\r\nconst struct ubifs_lprops *lp;\r\nubifs_get_lprops(c);\r\nlp = ubifs_lpt_lookup_dirty(c, lnum);\r\nif (IS_ERR(lp)) {\r\nerr = PTR_ERR(lp);\r\ngoto out;\r\n}\r\nflags = (lp->flags | flags_set) & ~flags_clean;\r\nlp = ubifs_change_lp(c, lp, free, lp->dirty + dirty, flags, 0);\r\nif (IS_ERR(lp))\r\nerr = PTR_ERR(lp);\r\nout:\r\nubifs_release_lprops(c);\r\nif (err)\r\nubifs_err("cannot update properties of LEB %d, error %d",\r\nlnum, err);\r\nreturn err;\r\n}\r\nint ubifs_read_one_lp(struct ubifs_info *c, int lnum, struct ubifs_lprops *lp)\r\n{\r\nint err = 0;\r\nconst struct ubifs_lprops *lpp;\r\nubifs_get_lprops(c);\r\nlpp = ubifs_lpt_lookup(c, lnum);\r\nif (IS_ERR(lpp)) {\r\nerr = PTR_ERR(lpp);\r\nubifs_err("cannot read properties of LEB %d, error %d",\r\nlnum, err);\r\ngoto out;\r\n}\r\nmemcpy(lp, lpp, sizeof(struct ubifs_lprops));\r\nout:\r\nubifs_release_lprops(c);\r\nreturn err;\r\n}\r\nconst struct ubifs_lprops *ubifs_fast_find_free(struct ubifs_info *c)\r\n{\r\nstruct ubifs_lprops *lprops;\r\nstruct ubifs_lpt_heap *heap;\r\nubifs_assert(mutex_is_locked(&c->lp_mutex));\r\nheap = &c->lpt_heap[LPROPS_FREE - 1];\r\nif (heap->cnt == 0)\r\nreturn NULL;\r\nlprops = heap->arr[0];\r\nubifs_assert(!(lprops->flags & LPROPS_TAKEN));\r\nubifs_assert(!(lprops->flags & LPROPS_INDEX));\r\nreturn lprops;\r\n}\r\nconst struct ubifs_lprops *ubifs_fast_find_empty(struct ubifs_info *c)\r\n{\r\nstruct ubifs_lprops *lprops;\r\nubifs_assert(mutex_is_locked(&c->lp_mutex));\r\nif (list_empty(&c->empty_list))\r\nreturn NULL;\r\nlprops = list_entry(c->empty_list.next, struct ubifs_lprops, list);\r\nubifs_assert(!(lprops->flags & LPROPS_TAKEN));\r\nubifs_assert(!(lprops->flags & LPROPS_INDEX));\r\nubifs_assert(lprops->free == c->leb_size);\r\nreturn lprops;\r\n}\r\nconst struct ubifs_lprops *ubifs_fast_find_freeable(struct ubifs_info *c)\r\n{\r\nstruct ubifs_lprops *lprops;\r\nubifs_assert(mutex_is_locked(&c->lp_mutex));\r\nif (list_empty(&c->freeable_list))\r\nreturn NULL;\r\nlprops = list_entry(c->freeable_list.next, struct ubifs_lprops, list);\r\nubifs_assert(!(lprops->flags & LPROPS_TAKEN));\r\nubifs_assert(!(lprops->flags & LPROPS_INDEX));\r\nubifs_assert(lprops->free + lprops->dirty == c->leb_size);\r\nubifs_assert(c->freeable_cnt > 0);\r\nreturn lprops;\r\n}\r\nconst struct ubifs_lprops *ubifs_fast_find_frdi_idx(struct ubifs_info *c)\r\n{\r\nstruct ubifs_lprops *lprops;\r\nubifs_assert(mutex_is_locked(&c->lp_mutex));\r\nif (list_empty(&c->frdi_idx_list))\r\nreturn NULL;\r\nlprops = list_entry(c->frdi_idx_list.next, struct ubifs_lprops, list);\r\nubifs_assert(!(lprops->flags & LPROPS_TAKEN));\r\nubifs_assert((lprops->flags & LPROPS_INDEX));\r\nubifs_assert(lprops->free + lprops->dirty == c->leb_size);\r\nreturn lprops;\r\n}\r\nint dbg_check_cats(struct ubifs_info *c)\r\n{\r\nstruct ubifs_lprops *lprops;\r\nstruct list_head *pos;\r\nint i, cat;\r\nif (!dbg_is_chk_gen(c) && !dbg_is_chk_lprops(c))\r\nreturn 0;\r\nlist_for_each_entry(lprops, &c->empty_list, list) {\r\nif (lprops->free != c->leb_size) {\r\nubifs_err("non-empty LEB %d on empty list "\r\n"(free %d dirty %d flags %d)", lprops->lnum,\r\nlprops->free, lprops->dirty, lprops->flags);\r\nreturn -EINVAL;\r\n}\r\nif (lprops->flags & LPROPS_TAKEN) {\r\nubifs_err("taken LEB %d on empty list "\r\n"(free %d dirty %d flags %d)", lprops->lnum,\r\nlprops->free, lprops->dirty, lprops->flags);\r\nreturn -EINVAL;\r\n}\r\n}\r\ni = 0;\r\nlist_for_each_entry(lprops, &c->freeable_list, list) {\r\nif (lprops->free + lprops->dirty != c->leb_size) {\r\nubifs_err("non-freeable LEB %d on freeable list "\r\n"(free %d dirty %d flags %d)", lprops->lnum,\r\nlprops->free, lprops->dirty, lprops->flags);\r\nreturn -EINVAL;\r\n}\r\nif (lprops->flags & LPROPS_TAKEN) {\r\nubifs_err("taken LEB %d on freeable list "\r\n"(free %d dirty %d flags %d)", lprops->lnum,\r\nlprops->free, lprops->dirty, lprops->flags);\r\nreturn -EINVAL;\r\n}\r\ni += 1;\r\n}\r\nif (i != c->freeable_cnt) {\r\nubifs_err("freeable list count %d expected %d", i,\r\nc->freeable_cnt);\r\nreturn -EINVAL;\r\n}\r\ni = 0;\r\nlist_for_each(pos, &c->idx_gc)\r\ni += 1;\r\nif (i != c->idx_gc_cnt) {\r\nubifs_err("idx_gc list count %d expected %d", i,\r\nc->idx_gc_cnt);\r\nreturn -EINVAL;\r\n}\r\nlist_for_each_entry(lprops, &c->frdi_idx_list, list) {\r\nif (lprops->free + lprops->dirty != c->leb_size) {\r\nubifs_err("non-freeable LEB %d on frdi_idx list "\r\n"(free %d dirty %d flags %d)", lprops->lnum,\r\nlprops->free, lprops->dirty, lprops->flags);\r\nreturn -EINVAL;\r\n}\r\nif (lprops->flags & LPROPS_TAKEN) {\r\nubifs_err("taken LEB %d on frdi_idx list "\r\n"(free %d dirty %d flags %d)", lprops->lnum,\r\nlprops->free, lprops->dirty, lprops->flags);\r\nreturn -EINVAL;\r\n}\r\nif (!(lprops->flags & LPROPS_INDEX)) {\r\nubifs_err("non-index LEB %d on frdi_idx list "\r\n"(free %d dirty %d flags %d)", lprops->lnum,\r\nlprops->free, lprops->dirty, lprops->flags);\r\nreturn -EINVAL;\r\n}\r\n}\r\nfor (cat = 1; cat <= LPROPS_HEAP_CNT; cat++) {\r\nstruct ubifs_lpt_heap *heap = &c->lpt_heap[cat - 1];\r\nfor (i = 0; i < heap->cnt; i++) {\r\nlprops = heap->arr[i];\r\nif (!lprops) {\r\nubifs_err("null ptr in LPT heap cat %d", cat);\r\nreturn -EINVAL;\r\n}\r\nif (lprops->hpos != i) {\r\nubifs_err("bad ptr in LPT heap cat %d", cat);\r\nreturn -EINVAL;\r\n}\r\nif (lprops->flags & LPROPS_TAKEN) {\r\nubifs_err("taken LEB in LPT heap cat %d", cat);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid dbg_check_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap, int cat,\r\nint add_pos)\r\n{\r\nint i = 0, j, err = 0;\r\nif (!dbg_is_chk_gen(c) && !dbg_is_chk_lprops(c))\r\nreturn;\r\nfor (i = 0; i < heap->cnt; i++) {\r\nstruct ubifs_lprops *lprops = heap->arr[i];\r\nstruct ubifs_lprops *lp;\r\nif (i != add_pos)\r\nif ((lprops->flags & LPROPS_CAT_MASK) != cat) {\r\nerr = 1;\r\ngoto out;\r\n}\r\nif (lprops->hpos != i) {\r\nerr = 2;\r\ngoto out;\r\n}\r\nlp = ubifs_lpt_lookup(c, lprops->lnum);\r\nif (IS_ERR(lp)) {\r\nerr = 3;\r\ngoto out;\r\n}\r\nif (lprops != lp) {\r\ndbg_msg("lprops %zx lp %zx lprops->lnum %d lp->lnum %d",\r\n(size_t)lprops, (size_t)lp, lprops->lnum,\r\nlp->lnum);\r\nerr = 4;\r\ngoto out;\r\n}\r\nfor (j = 0; j < i; j++) {\r\nlp = heap->arr[j];\r\nif (lp == lprops) {\r\nerr = 5;\r\ngoto out;\r\n}\r\nif (lp->lnum == lprops->lnum) {\r\nerr = 6;\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nif (err) {\r\ndbg_msg("failed cat %d hpos %d err %d", cat, i, err);\r\ndbg_dump_stack();\r\ndbg_dump_heap(c, heap, cat);\r\n}\r\n}\r\nstatic int scan_check_cb(struct ubifs_info *c,\r\nconst struct ubifs_lprops *lp, int in_tree,\r\nstruct ubifs_lp_stats *lst)\r\n{\r\nstruct ubifs_scan_leb *sleb;\r\nstruct ubifs_scan_node *snod;\r\nint cat, lnum = lp->lnum, is_idx = 0, used = 0, free, dirty, ret;\r\nvoid *buf = NULL;\r\ncat = lp->flags & LPROPS_CAT_MASK;\r\nif (cat != LPROPS_UNCAT) {\r\ncat = ubifs_categorize_lprops(c, lp);\r\nif (cat != (lp->flags & LPROPS_CAT_MASK)) {\r\nubifs_err("bad LEB category %d expected %d",\r\n(lp->flags & LPROPS_CAT_MASK), cat);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (in_tree) {\r\nstruct list_head *list = NULL;\r\nswitch (cat) {\r\ncase LPROPS_EMPTY:\r\nlist = &c->empty_list;\r\nbreak;\r\ncase LPROPS_FREEABLE:\r\nlist = &c->freeable_list;\r\nbreak;\r\ncase LPROPS_FRDI_IDX:\r\nlist = &c->frdi_idx_list;\r\nbreak;\r\ncase LPROPS_UNCAT:\r\nlist = &c->uncat_list;\r\nbreak;\r\n}\r\nif (list) {\r\nstruct ubifs_lprops *lprops;\r\nint found = 0;\r\nlist_for_each_entry(lprops, list, list) {\r\nif (lprops == lp) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nubifs_err("bad LPT list (category %d)", cat);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nif (in_tree && cat > 0 && cat <= LPROPS_HEAP_CNT) {\r\nstruct ubifs_lpt_heap *heap = &c->lpt_heap[cat - 1];\r\nif ((lp->hpos != -1 && heap->arr[lp->hpos]->lnum != lnum) ||\r\nlp != heap->arr[lp->hpos]) {\r\nubifs_err("bad LPT heap (category %d)", cat);\r\nreturn -EINVAL;\r\n}\r\n}\r\nbuf = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (lp->free == c->leb_size) {\r\nlst->empty_lebs += 1;\r\nlst->total_free += c->leb_size;\r\nlst->total_dark += ubifs_calc_dark(c, c->leb_size);\r\nreturn LPT_SCAN_CONTINUE;\r\n}\r\nif (lp->free + lp->dirty == c->leb_size &&\r\n!(lp->flags & LPROPS_INDEX)) {\r\nlst->total_free += lp->free;\r\nlst->total_dirty += lp->dirty;\r\nlst->total_dark += ubifs_calc_dark(c, c->leb_size);\r\nreturn LPT_SCAN_CONTINUE;\r\n}\r\nsleb = ubifs_scan(c, lnum, 0, buf, 0);\r\nif (IS_ERR(sleb)) {\r\nret = PTR_ERR(sleb);\r\nif (ret == -EUCLEAN) {\r\ndbg_dump_lprops(c);\r\ndbg_dump_budg(c, &c->bi);\r\n}\r\ngoto out;\r\n}\r\nis_idx = -1;\r\nlist_for_each_entry(snod, &sleb->nodes, list) {\r\nint found, level = 0;\r\ncond_resched();\r\nif (is_idx == -1)\r\nis_idx = (snod->type == UBIFS_IDX_NODE) ? 1 : 0;\r\nif (is_idx && snod->type != UBIFS_IDX_NODE) {\r\nubifs_err("indexing node in data LEB %d:%d",\r\nlnum, snod->offs);\r\ngoto out_destroy;\r\n}\r\nif (snod->type == UBIFS_IDX_NODE) {\r\nstruct ubifs_idx_node *idx = snod->node;\r\nkey_read(c, ubifs_idx_key(c, idx), &snod->key);\r\nlevel = le16_to_cpu(idx->level);\r\n}\r\nfound = ubifs_tnc_has_node(c, &snod->key, level, lnum,\r\nsnod->offs, is_idx);\r\nif (found) {\r\nif (found < 0)\r\ngoto out_destroy;\r\nused += ALIGN(snod->len, 8);\r\n}\r\n}\r\nfree = c->leb_size - sleb->endpt;\r\ndirty = sleb->endpt - used;\r\nif (free > c->leb_size || free < 0 || dirty > c->leb_size ||\r\ndirty < 0) {\r\nubifs_err("bad calculated accounting for LEB %d: "\r\n"free %d, dirty %d", lnum, free, dirty);\r\ngoto out_destroy;\r\n}\r\nif (lp->free + lp->dirty == c->leb_size &&\r\nfree + dirty == c->leb_size)\r\nif ((is_idx && !(lp->flags & LPROPS_INDEX)) ||\r\n(!is_idx && free == c->leb_size) ||\r\nlp->free == c->leb_size) {\r\nfree = lp->free;\r\ndirty = lp->dirty;\r\nis_idx = 0;\r\n}\r\nif (is_idx && lp->free + lp->dirty == free + dirty &&\r\nlnum != c->ihead_lnum) {\r\nfree = lp->free;\r\ndirty = lp->dirty;\r\n}\r\nif (lp->free != free || lp->dirty != dirty)\r\ngoto out_print;\r\nif (is_idx && !(lp->flags & LPROPS_INDEX)) {\r\nif (free == c->leb_size)\r\nis_idx = 0;\r\nelse {\r\nubifs_err("indexing node without indexing "\r\n"flag");\r\ngoto out_print;\r\n}\r\n}\r\nif (!is_idx && (lp->flags & LPROPS_INDEX)) {\r\nubifs_err("data node with indexing flag");\r\ngoto out_print;\r\n}\r\nif (free == c->leb_size)\r\nlst->empty_lebs += 1;\r\nif (is_idx)\r\nlst->idx_lebs += 1;\r\nif (!(lp->flags & LPROPS_INDEX))\r\nlst->total_used += c->leb_size - free - dirty;\r\nlst->total_free += free;\r\nlst->total_dirty += dirty;\r\nif (!(lp->flags & LPROPS_INDEX)) {\r\nint spc = free + dirty;\r\nif (spc < c->dead_wm)\r\nlst->total_dead += spc;\r\nelse\r\nlst->total_dark += ubifs_calc_dark(c, spc);\r\n}\r\nubifs_scan_destroy(sleb);\r\nvfree(buf);\r\nreturn LPT_SCAN_CONTINUE;\r\nout_print:\r\nubifs_err("bad accounting of LEB %d: free %d, dirty %d flags %#x, "\r\n"should be free %d, dirty %d",\r\nlnum, lp->free, lp->dirty, lp->flags, free, dirty);\r\ndbg_dump_leb(c, lnum);\r\nout_destroy:\r\nubifs_scan_destroy(sleb);\r\nret = -EINVAL;\r\nout:\r\nvfree(buf);\r\nreturn ret;\r\n}\r\nint dbg_check_lprops(struct ubifs_info *c)\r\n{\r\nint i, err;\r\nstruct ubifs_lp_stats lst;\r\nif (!dbg_is_chk_lprops(c))\r\nreturn 0;\r\nfor (i = 0; i < c->jhead_cnt; i++) {\r\nerr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\r\nif (err)\r\nreturn err;\r\n}\r\nmemset(&lst, 0, sizeof(struct ubifs_lp_stats));\r\nerr = ubifs_lpt_scan_nolock(c, c->main_first, c->leb_cnt - 1,\r\n(ubifs_lpt_scan_callback)scan_check_cb,\r\n&lst);\r\nif (err && err != -ENOSPC)\r\ngoto out;\r\nif (lst.empty_lebs != c->lst.empty_lebs ||\r\nlst.idx_lebs != c->lst.idx_lebs ||\r\nlst.total_free != c->lst.total_free ||\r\nlst.total_dirty != c->lst.total_dirty ||\r\nlst.total_used != c->lst.total_used) {\r\nubifs_err("bad overall accounting");\r\nubifs_err("calculated: empty_lebs %d, idx_lebs %d, "\r\n"total_free %lld, total_dirty %lld, total_used %lld",\r\nlst.empty_lebs, lst.idx_lebs, lst.total_free,\r\nlst.total_dirty, lst.total_used);\r\nubifs_err("read from lprops: empty_lebs %d, idx_lebs %d, "\r\n"total_free %lld, total_dirty %lld, total_used %lld",\r\nc->lst.empty_lebs, c->lst.idx_lebs, c->lst.total_free,\r\nc->lst.total_dirty, c->lst.total_used);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (lst.total_dead != c->lst.total_dead ||\r\nlst.total_dark != c->lst.total_dark) {\r\nubifs_err("bad dead/dark space accounting");\r\nubifs_err("calculated: total_dead %lld, total_dark %lld",\r\nlst.total_dead, lst.total_dark);\r\nubifs_err("read from lprops: total_dead %lld, total_dark %lld",\r\nc->lst.total_dead, c->lst.total_dark);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nerr = dbg_check_cats(c);\r\nout:\r\nreturn err;\r\n}
