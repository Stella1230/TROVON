static int __init init_tqm_mtd(void)\r\n{\r\nint idx = 0, ret = 0;\r\nunsigned long flash_addr, flash_size, mtd_size = 0;\r\nbd_t *bd = (bd_t *)__res;\r\nflash_addr = bd->bi_flashstart;\r\nflash_size = bd->bi_flashsize;\r\nstart_scan_addr = ioremap(flash_addr, flash_size);\r\nif (!start_scan_addr) {\r\nprintk(KERN_WARNING "%s:Failed to ioremap address:0x%x\n", __func__, flash_addr);\r\nreturn -EIO;\r\n}\r\nfor (idx = 0 ; idx < FLASH_BANK_MAX ; idx++) {\r\nif(mtd_size >= flash_size)\r\nbreak;\r\nprintk(KERN_INFO "%s: chip probing count %d\n", __func__, idx);\r\nmap_banks[idx] = kzalloc(sizeof(struct map_info), GFP_KERNEL);\r\nif(map_banks[idx] == NULL) {\r\nret = -ENOMEM;\r\ngoto error_mem;\r\n}\r\nmap_banks[idx]->name = kmalloc(16, GFP_KERNEL);\r\nif (!map_banks[idx]->name) {\r\nret = -ENOMEM;\r\ngoto error_mem;\r\n}\r\nsprintf(map_banks[idx]->name, "TQM8xxL%d", idx);\r\nmap_banks[idx]->size = flash_size;\r\nmap_banks[idx]->bankwidth = 4;\r\nsimple_map_init(map_banks[idx]);\r\nmap_banks[idx]->virt = start_scan_addr;\r\nmap_banks[idx]->phys = flash_addr;\r\nif (idx && mtd_banks[idx-1]) {\r\nmap_banks[idx]->virt += mtd_banks[idx-1]->size;\r\nmap_banks[idx]->phys += mtd_banks[idx-1]->size;\r\n}\r\nmtd_banks[idx] = do_map_probe("cfi_probe", map_banks[idx]);\r\nif (mtd_banks[idx]) {\r\nmtd_banks[idx]->owner = THIS_MODULE;\r\nmtd_size += mtd_banks[idx]->size;\r\nnum_banks++;\r\nprintk(KERN_INFO "%s: bank%d, name:%s, size:%dbytes \n", __func__, num_banks,\r\nmtd_banks[idx]->name, mtd_banks[idx]->size);\r\n}\r\n}\r\nif (!num_banks) {\r\nprintk(KERN_NOTICE "TQM8xxL: No support flash chips found!\n");\r\nret = -ENXIO;\r\ngoto error_mem;\r\n}\r\npart_banks[0].mtd_part = tqm8xxl_partitions;\r\npart_banks[0].type = "Static image";\r\npart_banks[0].nums = ARRAY_SIZE(tqm8xxl_partitions);\r\npart_banks[1].mtd_part = tqm8xxl_fs_partitions;\r\npart_banks[1].type = "Static file system";\r\npart_banks[1].nums = ARRAY_SIZE(tqm8xxl_fs_partitions);\r\nfor(idx = 0; idx < num_banks ; idx++) {\r\nif (part_banks[idx].nums == 0)\r\nprintk(KERN_NOTICE "TQM flash%d: no partition info available, registering whole flash at once\n", idx);\r\nelse\r\nprintk(KERN_NOTICE "TQM flash%d: Using %s partition definition\n",\r\nidx, part_banks[idx].type);\r\nmtd_device_register(mtd_banks[idx], part_banks[idx].mtd_part,\r\npart_banks[idx].nums);\r\n}\r\nreturn 0;\r\nerror_mem:\r\nfor(idx = 0 ; idx < FLASH_BANK_MAX ; idx++) {\r\nif(map_banks[idx] != NULL) {\r\nkfree(map_banks[idx]->name);\r\nmap_banks[idx]->name = NULL;\r\nkfree(map_banks[idx]);\r\nmap_banks[idx] = NULL;\r\n}\r\n}\r\nerror:\r\niounmap(start_scan_addr);\r\nreturn ret;\r\n}\r\nstatic void __exit cleanup_tqm_mtd(void)\r\n{\r\nunsigned int idx = 0;\r\nfor(idx = 0 ; idx < num_banks ; idx++) {\r\nif (mtd_banks[idx]) {\r\nmtd_device_unregister(mtd_banks[idx]);\r\nmap_destroy(mtd_banks[idx]);\r\n}\r\nkfree(map_banks[idx]->name);\r\nkfree(map_banks[idx]);\r\n}\r\nif (start_scan_addr) {\r\niounmap(start_scan_addr);\r\nstart_scan_addr = 0;\r\n}\r\n}
