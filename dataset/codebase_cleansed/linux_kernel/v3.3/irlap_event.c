static void irlap_poll_timer_expired(void *data)\r\n{\r\nstruct irlap_cb *self = (struct irlap_cb *) data;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nirlap_do_event(self, POLL_TIMER_EXPIRED, NULL, NULL);\r\n}\r\nstatic void irlap_start_poll_timer(struct irlap_cb *self, int timeout)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\n#ifdef CONFIG_IRDA_FAST_RR\r\nif (skb_queue_empty(&self->txq) || self->remote_busy) {\r\nif (self->fast_RR == TRUE) {\r\nif (self->fast_RR_timeout < timeout) {\r\nself->fast_RR_timeout +=\r\n(sysctl_fast_poll_increase * HZ/1000);\r\ntimeout = self->fast_RR_timeout;\r\n}\r\n} else {\r\nself->fast_RR = TRUE;\r\nself->fast_RR_timeout = 0;\r\ntimeout = 0;\r\n}\r\n} else\r\nself->fast_RR = FALSE;\r\nIRDA_DEBUG(3, "%s(), timeout=%d (%ld)\n", __func__, timeout, jiffies);\r\n#endif\r\nif (timeout == 0)\r\nirlap_do_event(self, POLL_TIMER_EXPIRED, NULL, NULL);\r\nelse\r\nirda_start_timer(&self->poll_timer, timeout, self,\r\nirlap_poll_timer_expired);\r\n}\r\nvoid irlap_do_event(struct irlap_cb *self, IRLAP_EVENT event,\r\nstruct sk_buff *skb, struct irlap_info *info)\r\n{\r\nint ret;\r\nif (!self || self->magic != LAP_MAGIC)\r\nreturn;\r\nIRDA_DEBUG(3, "%s(), event = %s, state = %s\n", __func__,\r\nirlap_event[event], irlap_state[self->state]);\r\nret = (*state[self->state])(self, event, skb, info);\r\nswitch (self->state) {\r\ncase LAP_XMIT_P:\r\ncase LAP_XMIT_S:\r\nIRDA_DEBUG(2, "%s() : queue len = %d\n", __func__,\r\nskb_queue_len(&self->txq));\r\nif (!skb_queue_empty(&self->txq)) {\r\nself->local_busy = TRUE;\r\nwhile ((skb = skb_dequeue(&self->txq)) != NULL) {\r\nret = (*state[self->state])(self, SEND_I_CMD,\r\nskb, NULL);\r\nkfree_skb(skb);\r\nirlmp_flow_indication(self->notify.instance,\r\nFLOW_START);\r\nif (ret == -EPROTO)\r\nbreak;\r\n}\r\nself->local_busy = FALSE;\r\n} else if (self->disconnect_pending) {\r\nself->disconnect_pending = FALSE;\r\nret = (*state[self->state])(self, DISCONNECT_REQUEST,\r\nNULL, NULL);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int irlap_state_ndm(struct irlap_cb *self, IRLAP_EVENT event,\r\nstruct sk_buff *skb, struct irlap_info *info)\r\n{\r\ndiscovery_t *discovery_rsp;\r\nint ret = 0;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -1;);\r\nswitch (event) {\r\ncase CONNECT_REQUEST:\r\nIRDA_ASSERT(self->netdev != NULL, return -1;);\r\nif (self->media_busy) {\r\nIRDA_DEBUG(0, "%s(), CONNECT_REQUEST: media busy!\n",\r\n__func__);\r\nirlap_next_state(self, LAP_NDM);\r\nirlap_disconnect_indication(self, LAP_MEDIA_BUSY);\r\n} else {\r\nirlap_send_snrm_frame(self, &self->qos_rx);\r\nirlap_start_final_timer(self, self->final_timeout);\r\nself->retry_count = 0;\r\nirlap_next_state(self, LAP_SETUP);\r\n}\r\nbreak;\r\ncase RECV_SNRM_CMD:\r\nif (info) {\r\nself->daddr = info->daddr;\r\nself->caddr = info->caddr;\r\nirlap_next_state(self, LAP_CONN);\r\nirlap_connect_indication(self, skb);\r\n} else {\r\nIRDA_DEBUG(0, "%s(), SNRM frame does not "\r\n"contain an I field!\n", __func__);\r\n}\r\nbreak;\r\ncase DISCOVERY_REQUEST:\r\nIRDA_ASSERT(info != NULL, return -1;);\r\nif (self->media_busy) {\r\nIRDA_DEBUG(1, "%s(), DISCOVERY_REQUEST: media busy!\n",\r\n__func__);\r\nirlap_discovery_confirm(self, NULL);\r\nreturn 0;\r\n}\r\nself->S = info->S;\r\nself->s = info->s;\r\nirlap_send_discovery_xid_frame(self, info->S, info->s, TRUE,\r\ninfo->discovery);\r\nself->frame_sent = FALSE;\r\nself->s++;\r\nirlap_start_slot_timer(self, self->slot_timeout);\r\nirlap_next_state(self, LAP_QUERY);\r\nbreak;\r\ncase RECV_DISCOVERY_XID_CMD:\r\nIRDA_ASSERT(info != NULL, return -1;);\r\nif (info->s <= info->S) {\r\nself->slot = irlap_generate_rand_time_slot(info->S,\r\ninfo->s);\r\nif (self->slot == info->s) {\r\ndiscovery_rsp = irlmp_get_discovery_response();\r\ndiscovery_rsp->data.daddr = info->daddr;\r\nirlap_send_discovery_xid_frame(self, info->S,\r\nself->slot,\r\nFALSE,\r\ndiscovery_rsp);\r\nself->frame_sent = TRUE;\r\n} else\r\nself->frame_sent = FALSE;\r\nirlap_start_query_timer(self, info->S, info->s);\r\nirlap_next_state(self, LAP_REPLY);\r\n} else {\r\nIRDA_DEBUG(1, "%s(), Receiving final discovery request, missed the discovery slots :-(\n", __func__);\r\nirlap_discovery_indication(self, info->discovery);\r\n}\r\nbreak;\r\ncase MEDIA_BUSY_TIMER_EXPIRED:\r\n#ifdef CONFIG_IRDA_ULTRA\r\nif (!skb_queue_empty(&self->txq_ultra)) {\r\nret = (*state[self->state])(self, SEND_UI_FRAME,\r\nNULL, NULL);\r\n}\r\n#endif\r\nif (self->connect_pending) {\r\nself->connect_pending = FALSE;\r\nif (self->disconnect_pending)\r\nirlap_disconnect_indication(self, LAP_DISC_INDICATION);\r\nelse\r\nret = (*state[self->state])(self,\r\nCONNECT_REQUEST,\r\nNULL, NULL);\r\nself->disconnect_pending = FALSE;\r\n}\r\nbreak;\r\n#ifdef CONFIG_IRDA_ULTRA\r\ncase SEND_UI_FRAME:\r\n{\r\nint i;\r\nfor (i=0; ((i<2) && (self->media_busy == FALSE)); i++) {\r\nskb = skb_dequeue(&self->txq_ultra);\r\nif (skb)\r\nirlap_send_ui_frame(self, skb, CBROADCAST,\r\nCMD_FRAME);\r\nelse\r\nbreak;\r\n}\r\nif (i == 2) {\r\nirda_device_set_media_busy(self->netdev, TRUE);\r\n}\r\nbreak;\r\n}\r\ncase RECV_UI_FRAME:\r\nif (info->caddr != CBROADCAST) {\r\nIRDA_DEBUG(0, "%s(), not a broadcast frame!\n",\r\n__func__);\r\n} else\r\nirlap_unitdata_indication(self, skb);\r\nbreak;\r\n#endif\r\ncase RECV_TEST_CMD:\r\nskb_pull(skb, sizeof(struct test_frame));\r\nirlap_send_test_frame(self, CBROADCAST, info->daddr, skb);\r\nbreak;\r\ncase RECV_TEST_RSP:\r\nIRDA_DEBUG(0, "%s() not implemented!\n", __func__);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), Unknown event %s\n", __func__,\r\nirlap_event[event]);\r\nret = -1;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlap_state_query(struct irlap_cb *self, IRLAP_EVENT event,\r\nstruct sk_buff *skb, struct irlap_info *info)\r\n{\r\nint ret = 0;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -1;);\r\nswitch (event) {\r\ncase RECV_DISCOVERY_XID_RSP:\r\nIRDA_ASSERT(info != NULL, return -1;);\r\nIRDA_ASSERT(info->discovery != NULL, return -1;);\r\nIRDA_DEBUG(4, "%s(), daddr=%08x\n", __func__,\r\ninfo->discovery->data.daddr);\r\nif (!self->discovery_log) {\r\nIRDA_WARNING("%s: discovery log is gone! "\r\n"maybe the discovery timeout has been set"\r\n" too short?\n", __func__);\r\nbreak;\r\n}\r\nhashbin_insert(self->discovery_log,\r\n(irda_queue_t *) info->discovery,\r\ninfo->discovery->data.daddr, NULL);\r\nbreak;\r\ncase RECV_DISCOVERY_XID_CMD:\r\nIRDA_ASSERT(info != NULL, return -1;);\r\nIRDA_DEBUG(1, "%s(), Receiving discovery request (s = %d) while performing discovery :-(\n", __func__, info->s);\r\nif (info->s == 0xff)\r\nirlap_discovery_indication(self, info->discovery);\r\nbreak;\r\ncase SLOT_TIMER_EXPIRED:\r\nif (irda_device_is_receiving(self->netdev) && !self->add_wait) {\r\nIRDA_DEBUG(2, "%s(), device is slow to answer, "\r\n"waiting some more!\n", __func__);\r\nirlap_start_slot_timer(self, msecs_to_jiffies(10));\r\nself->add_wait = TRUE;\r\nreturn ret;\r\n}\r\nself->add_wait = FALSE;\r\nif (self->s < self->S) {\r\nirlap_send_discovery_xid_frame(self, self->S,\r\nself->s, TRUE,\r\nself->discovery_cmd);\r\nself->s++;\r\nirlap_start_slot_timer(self, self->slot_timeout);\r\nirlap_next_state(self, LAP_QUERY);\r\n} else {\r\nirlap_send_discovery_xid_frame(self, self->S, 0xff,\r\nTRUE,\r\nself->discovery_cmd);\r\nirlap_next_state(self, LAP_NDM);\r\nirlap_discovery_confirm(self, self->discovery_log);\r\nself->discovery_log = NULL;\r\n}\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), Unknown event %s\n", __func__,\r\nirlap_event[event]);\r\nret = -1;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlap_state_reply(struct irlap_cb *self, IRLAP_EVENT event,\r\nstruct sk_buff *skb, struct irlap_info *info)\r\n{\r\ndiscovery_t *discovery_rsp;\r\nint ret=0;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -1;);\r\nswitch (event) {\r\ncase QUERY_TIMER_EXPIRED:\r\nIRDA_DEBUG(0, "%s(), QUERY_TIMER_EXPIRED <%ld>\n",\r\n__func__, jiffies);\r\nirlap_next_state(self, LAP_NDM);\r\nbreak;\r\ncase RECV_DISCOVERY_XID_CMD:\r\nIRDA_ASSERT(info != NULL, return -1;);\r\nif (info->s == 0xff) {\r\ndel_timer(&self->query_timer);\r\nirlap_next_state(self, LAP_NDM);\r\nirlap_discovery_indication(self, info->discovery);\r\n} else {\r\nif ((info->s >= self->slot) && (!self->frame_sent)) {\r\ndiscovery_rsp = irlmp_get_discovery_response();\r\ndiscovery_rsp->data.daddr = info->daddr;\r\nirlap_send_discovery_xid_frame(self, info->S,\r\nself->slot,\r\nFALSE,\r\ndiscovery_rsp);\r\nself->frame_sent = TRUE;\r\n}\r\nirlap_start_query_timer(self, info->S, info->s);\r\n}\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(1, "%s(), Unknown event %d, %s\n", __func__,\r\nevent, irlap_event[event]);\r\nret = -1;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlap_state_conn(struct irlap_cb *self, IRLAP_EVENT event,\r\nstruct sk_buff *skb, struct irlap_info *info)\r\n{\r\nint ret = 0;\r\nIRDA_DEBUG(4, "%s(), event=%s\n", __func__, irlap_event[ event]);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -1;);\r\nswitch (event) {\r\ncase CONNECT_RESPONSE:\r\nskb_pull(skb, sizeof(struct snrm_frame));\r\nIRDA_ASSERT(self->netdev != NULL, return -1;);\r\nirlap_qos_negotiate(self, skb);\r\nirlap_initiate_connection_state(self);\r\nirlap_apply_connection_parameters(self, FALSE);\r\nirlap_send_ua_response_frame(self, &self->qos_rx);\r\n#if 0\r\nirlap_send_ua_response_frame(self, &self->qos_rx);\r\n#endif\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\nirlap_next_state(self, LAP_NRM_S);\r\nbreak;\r\ncase RECV_DISCOVERY_XID_CMD:\r\nIRDA_DEBUG(3, "%s(), event RECV_DISCOVER_XID_CMD!\n",\r\n__func__);\r\nirlap_next_state(self, LAP_NDM);\r\nbreak;\r\ncase DISCONNECT_REQUEST:\r\nIRDA_DEBUG(0, "%s(), Disconnect request!\n", __func__);\r\nirlap_send_dm_frame(self);\r\nirlap_next_state( self, LAP_NDM);\r\nirlap_disconnect_indication(self, LAP_DISC_INDICATION);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(1, "%s(), Unknown event %d, %s\n", __func__,\r\nevent, irlap_event[event]);\r\nret = -1;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlap_state_setup(struct irlap_cb *self, IRLAP_EVENT event,\r\nstruct sk_buff *skb, struct irlap_info *info)\r\n{\r\nint ret = 0;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -1;);\r\nswitch (event) {\r\ncase FINAL_TIMER_EXPIRED:\r\nif (self->retry_count < self->N3) {\r\nirlap_start_backoff_timer(self, msecs_to_jiffies(20 +\r\n(jiffies % 30)));\r\n} else {\r\nirlap_next_state(self, LAP_NDM);\r\nirlap_disconnect_indication(self, LAP_FOUND_NONE);\r\n}\r\nbreak;\r\ncase BACKOFF_TIMER_EXPIRED:\r\nirlap_send_snrm_frame(self, &self->qos_rx);\r\nirlap_start_final_timer(self, self->final_timeout);\r\nself->retry_count++;\r\nbreak;\r\ncase RECV_SNRM_CMD:\r\nIRDA_DEBUG(4, "%s(), SNRM battle!\n", __func__);\r\nIRDA_ASSERT(skb != NULL, return 0;);\r\nIRDA_ASSERT(info != NULL, return 0;);\r\nif (info &&(info->daddr > self->saddr)) {\r\ndel_timer(&self->final_timer);\r\nirlap_initiate_connection_state(self);\r\nIRDA_ASSERT(self->netdev != NULL, return -1;);\r\nskb_pull(skb, sizeof(struct snrm_frame));\r\nirlap_qos_negotiate(self, skb);\r\nirlap_apply_connection_parameters(self, FALSE);\r\nirlap_send_ua_response_frame(self, &self->qos_rx);\r\nirlap_next_state(self, LAP_NRM_S);\r\nirlap_connect_confirm(self, skb);\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\n} else {\r\nirlap_next_state(self, LAP_SETUP);\r\n}\r\nbreak;\r\ncase RECV_UA_RSP:\r\ndel_timer(&self->final_timer);\r\nirlap_initiate_connection_state(self);\r\nIRDA_ASSERT(skb->len > 10, return -1;);\r\nskb_pull(skb, sizeof(struct ua_frame));\r\nIRDA_ASSERT(self->netdev != NULL, return -1;);\r\nirlap_qos_negotiate(self, skb);\r\nirlap_apply_connection_parameters(self, TRUE);\r\nself->retry_count = 0;\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_rr_frame(self, CMD_FRAME);\r\nirlap_start_final_timer(self, self->final_timeout/2);\r\nirlap_next_state(self, LAP_NRM_P);\r\nirlap_connect_confirm(self, skb);\r\nbreak;\r\ncase RECV_DM_RSP:\r\ncase RECV_DISC_CMD:\r\ndel_timer(&self->final_timer);\r\nirlap_next_state(self, LAP_NDM);\r\nirlap_disconnect_indication(self, LAP_DISC_INDICATION);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(1, "%s(), Unknown event %d, %s\n", __func__,\r\nevent, irlap_event[event]);\r\nret = -1;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlap_state_offline(struct irlap_cb *self, IRLAP_EVENT event,\r\nstruct sk_buff *skb, struct irlap_info *info)\r\n{\r\nIRDA_DEBUG( 0, "%s(), Unknown event\n", __func__);\r\nreturn -1;\r\n}\r\nstatic int irlap_state_xmit_p(struct irlap_cb *self, IRLAP_EVENT event,\r\nstruct sk_buff *skb, struct irlap_info *info)\r\n{\r\nint ret = 0;\r\nswitch (event) {\r\ncase SEND_I_CMD:\r\nif ((self->window > 0) && (!self->remote_busy)) {\r\nint nextfit;\r\n#ifdef CONFIG_IRDA_DYNAMIC_WINDOW\r\nstruct sk_buff *skb_next;\r\nskb_next = skb_peek(&self->txq);\r\nnextfit = ((skb_next != NULL) &&\r\n((skb_next->len + skb->len) <=\r\nself->bytes_left));\r\nif((!nextfit) && (skb->len > self->bytes_left)) {\r\nIRDA_DEBUG(0, "%s(), Not allowed to transmit"\r\n" more bytes!\n", __func__);\r\nskb_queue_head(&self->txq, skb_get(skb));\r\nreturn -EPROTO;\r\n}\r\nself->bytes_left -= skb->len;\r\n#else\r\nnextfit = !skb_queue_empty(&self->txq);\r\n#endif\r\nif ((self->window > 1) && (nextfit)) {\r\nirlap_send_data_primary(self, skb);\r\nirlap_next_state(self, LAP_XMIT_P);\r\n} else {\r\nirlap_send_data_primary_poll(self, skb);\r\nret = -EPROTO;\r\n}\r\n#ifdef CONFIG_IRDA_FAST_RR\r\nself->fast_RR = FALSE;\r\n#endif\r\n} else {\r\nIRDA_DEBUG(4, "%s(), Unable to send! remote busy?\n",\r\n__func__);\r\nskb_queue_head(&self->txq, skb_get(skb));\r\nret = -EPROTO;\r\n}\r\nbreak;\r\ncase POLL_TIMER_EXPIRED:\r\nIRDA_DEBUG(3, "%s(), POLL_TIMER_EXPIRED <%ld>\n",\r\n__func__, jiffies);\r\nirlap_send_rr_frame(self, CMD_FRAME);\r\nself->window = self->window_size;\r\n#ifdef CONFIG_IRDA_DYNAMIC_WINDOW\r\nself->bytes_left = self->line_capacity;\r\n#endif\r\nirlap_start_final_timer(self, self->final_timeout);\r\nirlap_next_state(self, LAP_NRM_P);\r\nbreak;\r\ncase DISCONNECT_REQUEST:\r\ndel_timer(&self->poll_timer);\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_disc_frame(self);\r\nirlap_flush_all_queues(self);\r\nirlap_start_final_timer(self, self->final_timeout);\r\nself->retry_count = 0;\r\nirlap_next_state(self, LAP_PCLOSE);\r\nbreak;\r\ncase DATA_REQUEST:\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), Unknown event %s\n",\r\n__func__, irlap_event[event]);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlap_state_pclose(struct irlap_cb *self, IRLAP_EVENT event,\r\nstruct sk_buff *skb, struct irlap_info *info)\r\n{\r\nint ret = 0;\r\nIRDA_DEBUG(1, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -1;);\r\nswitch (event) {\r\ncase RECV_UA_RSP:\r\ncase RECV_DM_RSP:\r\ndel_timer(&self->final_timer);\r\nirlap_apply_default_connection_parameters(self);\r\nirlap_next_state(self, LAP_NDM);\r\nirlap_disconnect_indication(self, LAP_DISC_INDICATION);\r\nbreak;\r\ncase FINAL_TIMER_EXPIRED:\r\nif (self->retry_count < self->N3) {\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_disc_frame(self);\r\nirlap_start_final_timer(self, self->final_timeout);\r\nself->retry_count++;\r\n} else {\r\nirlap_apply_default_connection_parameters(self);\r\nirlap_next_state(self, LAP_NDM);\r\nirlap_disconnect_indication(self, LAP_NO_RESPONSE);\r\n}\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(1, "%s(), Unknown event %d\n", __func__, event);\r\nret = -1;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlap_state_nrm_p(struct irlap_cb *self, IRLAP_EVENT event,\r\nstruct sk_buff *skb, struct irlap_info *info)\r\n{\r\nint ret = 0;\r\nint ns_status;\r\nint nr_status;\r\nswitch (event) {\r\ncase RECV_I_RSP:\r\nif (unlikely(skb->len <= LAP_ADDR_HEADER + LAP_CTRL_HEADER)) {\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_rr_frame(self, CMD_FRAME);\r\nbreak;\r\n}\r\n#ifdef CONFIG_IRDA_FAST_RR\r\nself->fast_RR = FALSE;\r\n#endif\r\nIRDA_ASSERT( info != NULL, return -1;);\r\nns_status = irlap_validate_ns_received(self, info->ns);\r\nnr_status = irlap_validate_nr_received(self, info->nr);\r\nif ((ns_status == NS_EXPECTED) && (nr_status == NR_EXPECTED)) {\r\nself->vr = (self->vr + 1) % 8;\r\nirlap_update_nr_received(self, info->nr);\r\nself->retry_count = 0;\r\nself->ack_required = TRUE;\r\nif (!info->pf) {\r\nirlap_next_state(self, LAP_NRM_P);\r\nirlap_data_indication(self, skb, FALSE);\r\n} else {\r\ndel_timer(&self->final_timer);\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_data_indication(self, skb, FALSE);\r\nirlap_next_state(self, LAP_XMIT_P);\r\nirlap_start_poll_timer(self, self->poll_timeout);\r\n}\r\nbreak;\r\n}\r\nif ((ns_status == NS_UNEXPECTED) && (nr_status == NR_EXPECTED))\r\n{\r\nif (!info->pf) {\r\nirlap_update_nr_received(self, info->nr);\r\nirlap_next_state(self, LAP_NRM_P);\r\n} else {\r\nIRDA_DEBUG(4,\r\n"%s(), missing or duplicate frame!\n",\r\n__func__);\r\nirlap_update_nr_received(self, info->nr);\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_rr_frame(self, CMD_FRAME);\r\nself->ack_required = FALSE;\r\nirlap_start_final_timer(self, self->final_timeout);\r\nirlap_next_state(self, LAP_NRM_P);\r\n}\r\nbreak;\r\n}\r\nif ((ns_status == NS_EXPECTED) && (nr_status == NR_UNEXPECTED))\r\n{\r\nif (info->pf) {\r\nself->vr = (self->vr + 1) % 8;\r\nirlap_update_nr_received(self, info->nr);\r\nirlap_resend_rejected_frames(self, CMD_FRAME);\r\nself->ack_required = FALSE;\r\nirlap_start_final_timer(self, 2 * self->final_timeout);\r\nirlap_next_state(self, LAP_NRM_P);\r\nirlap_data_indication(self, skb, FALSE);\r\n} else {\r\nself->vr = (self->vr + 1) % 8;\r\nirlap_update_nr_received(self, info->nr);\r\nself->ack_required = FALSE;\r\nirlap_next_state(self, LAP_NRM_P);\r\nirlap_data_indication(self, skb, FALSE);\r\n}\r\nbreak;\r\n}\r\nif ((ns_status == NS_UNEXPECTED) &&\r\n(nr_status == NR_UNEXPECTED))\r\n{\r\nIRDA_DEBUG(4, "%s(), unexpected nr and ns!\n",\r\n__func__);\r\nif (info->pf) {\r\nirlap_resend_rejected_frames(self, CMD_FRAME);\r\nirlap_start_final_timer(self, 2 * self->final_timeout);\r\nirlap_next_state(self, LAP_NRM_P);\r\n} else {\r\nself->ack_required = FALSE;\r\n}\r\nbreak;\r\n}\r\nif ((nr_status == NR_INVALID) || (ns_status == NS_INVALID)) {\r\nif (info->pf) {\r\ndel_timer(&self->final_timer);\r\nirlap_next_state(self, LAP_RESET_WAIT);\r\nirlap_disconnect_indication(self, LAP_RESET_INDICATION);\r\nself->xmitflag = TRUE;\r\n} else {\r\ndel_timer(&self->final_timer);\r\nirlap_disconnect_indication(self, LAP_RESET_INDICATION);\r\nself->xmitflag = FALSE;\r\n}\r\nbreak;\r\n}\r\nIRDA_DEBUG(1, "%s(), Not implemented!\n", __func__);\r\nIRDA_DEBUG(1, "%s(), event=%s, ns_status=%d, nr_status=%d\n",\r\n__func__, irlap_event[event], ns_status, nr_status);\r\nbreak;\r\ncase RECV_UI_FRAME:\r\nif (!info->pf) {\r\nirlap_data_indication(self, skb, TRUE);\r\nirlap_next_state(self, LAP_NRM_P);\r\n} else {\r\ndel_timer(&self->final_timer);\r\nirlap_data_indication(self, skb, TRUE);\r\nirlap_next_state(self, LAP_XMIT_P);\r\nIRDA_DEBUG(1, "%s: RECV_UI_FRAME: next state %s\n", __func__, irlap_state[self->state]);\r\nirlap_start_poll_timer(self, self->poll_timeout);\r\n}\r\nbreak;\r\ncase RECV_RR_RSP:\r\nself->remote_busy = FALSE;\r\ndel_timer(&self->final_timer);\r\nret = irlap_validate_nr_received(self, info->nr);\r\nif (ret == NR_EXPECTED) {\r\nirlap_update_nr_received(self, info->nr);\r\nself->retry_count = 0;\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_next_state(self, LAP_XMIT_P);\r\nirlap_start_poll_timer(self, self->poll_timeout);\r\n} else if (ret == NR_UNEXPECTED) {\r\nIRDA_ASSERT(info != NULL, return -1;);\r\nirlap_update_nr_received(self, info->nr);\r\nIRDA_DEBUG(4, "RECV_RR_FRAME: Retrans:%d, nr=%d, va=%d, "\r\n"vs=%d, vr=%d\n",\r\nself->retry_count, info->nr, self->va,\r\nself->vs, self->vr);\r\nirlap_resend_rejected_frames(self, CMD_FRAME);\r\nirlap_start_final_timer(self, self->final_timeout * 2);\r\nirlap_next_state(self, LAP_NRM_P);\r\n} else if (ret == NR_INVALID) {\r\nIRDA_DEBUG(1, "%s(), Received RR with "\r\n"invalid nr !\n", __func__);\r\nirlap_next_state(self, LAP_RESET_WAIT);\r\nirlap_disconnect_indication(self, LAP_RESET_INDICATION);\r\nself->xmitflag = TRUE;\r\n}\r\nbreak;\r\ncase RECV_RNR_RSP:\r\nIRDA_ASSERT(info != NULL, return -1;);\r\ndel_timer(&self->final_timer);\r\nself->remote_busy = TRUE;\r\nirlap_update_nr_received(self, info->nr);\r\nirlap_next_state(self, LAP_XMIT_P);\r\nirlap_start_poll_timer(self, self->poll_timeout);\r\nbreak;\r\ncase RECV_FRMR_RSP:\r\ndel_timer(&self->final_timer);\r\nself->xmitflag = TRUE;\r\nirlap_next_state(self, LAP_RESET_WAIT);\r\nirlap_reset_indication(self);\r\nbreak;\r\ncase FINAL_TIMER_EXPIRED:\r\nif (irda_device_is_receiving(self->netdev) && !self->add_wait) {\r\nIRDA_DEBUG(1, "FINAL_TIMER_EXPIRED when receiving a "\r\n"frame! Waiting a little bit more!\n");\r\nirlap_start_final_timer(self, msecs_to_jiffies(300));\r\nself->add_wait = TRUE;\r\nbreak;\r\n}\r\nself->add_wait = FALSE;\r\nif (self->retry_count < self->N2) {\r\nif (skb_peek(&self->wx_list) == NULL) {\r\nIRDA_DEBUG(4, "nrm_p: resending rr");\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_rr_frame(self, CMD_FRAME);\r\n} else {\r\nIRDA_DEBUG(4, "nrm_p: resend frames");\r\nirlap_resend_rejected_frames(self, CMD_FRAME);\r\n}\r\nirlap_start_final_timer(self, self->final_timeout);\r\nself->retry_count++;\r\nIRDA_DEBUG(4, "irlap_state_nrm_p: FINAL_TIMER_EXPIRED:"\r\n" retry_count=%d\n", self->retry_count);\r\nif((self->retry_count % self->N1) == 0)\r\nirlap_status_indication(self,\r\nSTATUS_NO_ACTIVITY);\r\n} else {\r\nirlap_apply_default_connection_parameters(self);\r\nirlap_next_state(self, LAP_NDM);\r\nirlap_disconnect_indication(self, LAP_NO_RESPONSE);\r\n}\r\nbreak;\r\ncase RECV_REJ_RSP:\r\nirlap_update_nr_received(self, info->nr);\r\nif (self->remote_busy) {\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_rr_frame(self, CMD_FRAME);\r\n} else\r\nirlap_resend_rejected_frames(self, CMD_FRAME);\r\nirlap_start_final_timer(self, 2 * self->final_timeout);\r\nbreak;\r\ncase RECV_SREJ_RSP:\r\nirlap_update_nr_received(self, info->nr);\r\nif (self->remote_busy) {\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_rr_frame(self, CMD_FRAME);\r\n} else\r\nirlap_resend_rejected_frame(self, CMD_FRAME);\r\nirlap_start_final_timer(self, 2 * self->final_timeout);\r\nbreak;\r\ncase RECV_RD_RSP:\r\nIRDA_DEBUG(1, "%s(), RECV_RD_RSP\n", __func__);\r\nirlap_flush_all_queues(self);\r\nirlap_next_state(self, LAP_XMIT_P);\r\nirlap_disconnect_request(self);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(1, "%s(), Unknown event %s\n",\r\n__func__, irlap_event[event]);\r\nret = -1;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlap_state_reset_wait(struct irlap_cb *self, IRLAP_EVENT event,\r\nstruct sk_buff *skb, struct irlap_info *info)\r\n{\r\nint ret = 0;\r\nIRDA_DEBUG(3, "%s(), event = %s\n", __func__, irlap_event[event]);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -1;);\r\nswitch (event) {\r\ncase RESET_REQUEST:\r\nif (self->xmitflag) {\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_snrm_frame(self, NULL);\r\nirlap_start_final_timer(self, self->final_timeout);\r\nirlap_next_state(self, LAP_RESET);\r\n} else {\r\nirlap_start_final_timer(self, self->final_timeout);\r\nirlap_next_state(self, LAP_RESET);\r\n}\r\nbreak;\r\ncase DISCONNECT_REQUEST:\r\nirlap_wait_min_turn_around( self, &self->qos_tx);\r\nirlap_send_disc_frame( self);\r\nirlap_flush_all_queues( self);\r\nirlap_start_final_timer( self, self->final_timeout);\r\nself->retry_count = 0;\r\nirlap_next_state( self, LAP_PCLOSE);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), Unknown event %s\n", __func__,\r\nirlap_event[event]);\r\nret = -1;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlap_state_reset(struct irlap_cb *self, IRLAP_EVENT event,\r\nstruct sk_buff *skb, struct irlap_info *info)\r\n{\r\nint ret = 0;\r\nIRDA_DEBUG(3, "%s(), event = %s\n", __func__, irlap_event[event]);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -1;);\r\nswitch (event) {\r\ncase RECV_DISC_CMD:\r\ndel_timer(&self->final_timer);\r\nirlap_apply_default_connection_parameters(self);\r\nirlap_next_state(self, LAP_NDM);\r\nirlap_disconnect_indication(self, LAP_NO_RESPONSE);\r\nbreak;\r\ncase RECV_UA_RSP:\r\ndel_timer(&self->final_timer);\r\nirlap_initiate_connection_state(self);\r\nirlap_reset_confirm();\r\nself->remote_busy = FALSE;\r\nirlap_next_state(self, LAP_XMIT_P);\r\nirlap_start_poll_timer(self, self->poll_timeout);\r\nbreak;\r\ncase FINAL_TIMER_EXPIRED:\r\nif (self->retry_count < 3) {\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nIRDA_ASSERT(self->netdev != NULL, return -1;);\r\nirlap_send_snrm_frame(self, self->qos_dev);\r\nself->retry_count++;\r\nirlap_start_final_timer(self, self->final_timeout);\r\nirlap_next_state(self, LAP_RESET);\r\n} else if (self->retry_count >= self->N3) {\r\nirlap_apply_default_connection_parameters(self);\r\nirlap_next_state(self, LAP_NDM);\r\nirlap_disconnect_indication(self, LAP_NO_RESPONSE);\r\n}\r\nbreak;\r\ncase RECV_SNRM_CMD:\r\nif (!info) {\r\nIRDA_DEBUG(3, "%s(), RECV_SNRM_CMD\n", __func__);\r\nirlap_initiate_connection_state(self);\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_ua_response_frame(self, &self->qos_rx);\r\nirlap_reset_confirm();\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\nirlap_next_state(self, LAP_NDM);\r\n} else {\r\nIRDA_DEBUG(0,\r\n"%s(), SNRM frame contained an I field!\n",\r\n__func__);\r\n}\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(1, "%s(), Unknown event %s\n",\r\n__func__, irlap_event[event]);\r\nret = -1;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlap_state_xmit_s(struct irlap_cb *self, IRLAP_EVENT event,\r\nstruct sk_buff *skb, struct irlap_info *info)\r\n{\r\nint ret = 0;\r\nIRDA_DEBUG(4, "%s(), event=%s\n", __func__, irlap_event[event]);\r\nIRDA_ASSERT(self != NULL, return -ENODEV;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -EBADR;);\r\nswitch (event) {\r\ncase SEND_I_CMD:\r\nif ((self->window > 0) && (!self->remote_busy)) {\r\nint nextfit;\r\n#ifdef CONFIG_IRDA_DYNAMIC_WINDOW\r\nstruct sk_buff *skb_next;\r\nskb_next = skb_peek(&self->txq);\r\nnextfit = ((skb_next != NULL) &&\r\n((skb_next->len + skb->len) <=\r\nself->bytes_left));\r\nif((!nextfit) && (skb->len > self->bytes_left)) {\r\nIRDA_DEBUG(0, "%s(), Not allowed to transmit"\r\n" more bytes!\n", __func__);\r\nskb_queue_head(&self->txq, skb_get(skb));\r\nself->window = self->window_size;\r\nself->bytes_left = self->line_capacity;\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\nirlap_next_state(self, LAP_NRM_S);\r\nreturn -EPROTO;\r\n}\r\nself->bytes_left -= skb->len;\r\n#else\r\nnextfit = !skb_queue_empty(&self->txq);\r\n#endif\r\nif ((self->window > 1) && (nextfit)) {\r\nirlap_send_data_secondary(self, skb);\r\nirlap_next_state(self, LAP_XMIT_S);\r\n} else {\r\nirlap_send_data_secondary_final(self, skb);\r\nirlap_next_state(self, LAP_NRM_S);\r\nret = -EPROTO;\r\n}\r\n} else {\r\nIRDA_DEBUG(2, "%s(), Unable to send!\n", __func__);\r\nskb_queue_head(&self->txq, skb_get(skb));\r\nret = -EPROTO;\r\n}\r\nbreak;\r\ncase DISCONNECT_REQUEST:\r\nirlap_send_rd_frame(self);\r\nirlap_flush_all_queues(self);\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\nirlap_next_state(self, LAP_SCLOSE);\r\nbreak;\r\ncase DATA_REQUEST:\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), Unknown event %s\n", __func__,\r\nirlap_event[event]);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlap_state_nrm_s(struct irlap_cb *self, IRLAP_EVENT event,\r\nstruct sk_buff *skb, struct irlap_info *info)\r\n{\r\nint ns_status;\r\nint nr_status;\r\nint ret = 0;\r\nIRDA_DEBUG(4, "%s(), event=%s\n", __func__, irlap_event[ event]);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -1;);\r\nswitch (event) {\r\ncase RECV_I_CMD:\r\nIRDA_DEBUG(4, "%s(), event=%s nr=%d, vs=%d, ns=%d, "\r\n"vr=%d, pf=%d\n", __func__,\r\nirlap_event[event], info->nr,\r\nself->vs, info->ns, self->vr, info->pf);\r\nself->retry_count = 0;\r\nns_status = irlap_validate_ns_received(self, info->ns);\r\nnr_status = irlap_validate_nr_received(self, info->nr);\r\nif ((ns_status == NS_EXPECTED) && (nr_status == NR_EXPECTED)) {\r\nself->vr = (self->vr + 1) % 8;\r\nirlap_update_nr_received(self, info->nr);\r\nif (!info->pf) {\r\nself->ack_required = TRUE;\r\n#if 0\r\nirda_start_timer(WD_TIMER, self->wd_timeout);\r\n#endif\r\nirlap_next_state(self, LAP_NRM_S);\r\nirlap_data_indication(self, skb, FALSE);\r\nbreak;\r\n} else {\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_data_indication(self, skb, FALSE);\r\nif (!skb_queue_empty(&self->txq) &&\r\n(self->window > 0))\r\n{\r\nself->ack_required = TRUE;\r\ndel_timer(&self->wd_timer);\r\nirlap_next_state(self, LAP_XMIT_S);\r\n} else {\r\nirlap_send_rr_frame(self, RSP_FRAME);\r\nirlap_start_wd_timer(self,\r\nself->wd_timeout);\r\nirlap_next_state(self, LAP_NRM_S);\r\n}\r\nbreak;\r\n}\r\n}\r\nif ((ns_status == NS_UNEXPECTED) && (nr_status == NR_EXPECTED))\r\n{\r\nif (!info->pf) {\r\nirlap_update_nr_received(self, info->nr);\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\n} else {\r\nirlap_update_nr_received(self, info->nr);\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_rr_frame(self, RSP_FRAME);\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\n}\r\nbreak;\r\n}\r\nif ((ns_status == NS_EXPECTED) && (nr_status == NR_UNEXPECTED))\r\n{\r\nif (info->pf) {\r\nIRDA_DEBUG(4, "RECV_I_RSP: frame(s) lost\n");\r\nself->vr = (self->vr + 1) % 8;\r\nirlap_update_nr_received(self, info->nr);\r\nirlap_resend_rejected_frames(self, RSP_FRAME);\r\nirlap_next_state(self, LAP_NRM_S);\r\nirlap_data_indication(self, skb, FALSE);\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\nbreak;\r\n}\r\nif (!info->pf) {\r\nself->vr = (self->vr + 1) % 8;\r\nirlap_update_nr_received(self, info->nr);\r\nirlap_next_state(self, LAP_NRM_S);\r\nirlap_data_indication(self, skb, FALSE);\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\n}\r\nbreak;\r\n}\r\nif (ret == NR_INVALID) {\r\nIRDA_DEBUG(0, "NRM_S, NR_INVALID not implemented!\n");\r\n}\r\nif (ret == NS_INVALID) {\r\nIRDA_DEBUG(0, "NRM_S, NS_INVALID not implemented!\n");\r\n}\r\nbreak;\r\ncase RECV_UI_FRAME:\r\nif (!info->pf) {\r\nirlap_data_indication(self, skb, TRUE);\r\nirlap_next_state(self, LAP_NRM_S);\r\n} else {\r\nif (!skb_queue_empty(&self->txq) &&\r\n(self->window > 0) && !self->remote_busy)\r\n{\r\nirlap_data_indication(self, skb, TRUE);\r\ndel_timer(&self->wd_timer);\r\nirlap_next_state(self, LAP_XMIT_S);\r\n} else {\r\nirlap_data_indication(self, skb, TRUE);\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_rr_frame(self, RSP_FRAME);\r\nself->ack_required = FALSE;\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\nirlap_next_state(self, LAP_NRM_S);\r\n}\r\n}\r\nbreak;\r\ncase RECV_RR_CMD:\r\nself->retry_count = 0;\r\nnr_status = irlap_validate_nr_received(self, info->nr);\r\nif (nr_status == NR_EXPECTED) {\r\nif (!skb_queue_empty(&self->txq) &&\r\n(self->window > 0)) {\r\nself->remote_busy = FALSE;\r\nirlap_update_nr_received(self, info->nr);\r\ndel_timer(&self->wd_timer);\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_next_state(self, LAP_XMIT_S);\r\n} else {\r\nself->remote_busy = FALSE;\r\nirlap_update_nr_received(self, info->nr);\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\nif (self->disconnect_pending) {\r\nirlap_send_rd_frame(self);\r\nirlap_flush_all_queues(self);\r\nirlap_next_state(self, LAP_SCLOSE);\r\n} else {\r\nirlap_send_rr_frame(self, RSP_FRAME);\r\nirlap_next_state(self, LAP_NRM_S);\r\n}\r\n}\r\n} else if (nr_status == NR_UNEXPECTED) {\r\nself->remote_busy = FALSE;\r\nirlap_update_nr_received(self, info->nr);\r\nirlap_resend_rejected_frames(self, RSP_FRAME);\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\nirlap_next_state(self, LAP_NRM_S);\r\n} else {\r\nIRDA_DEBUG(1, "%s(), invalid nr not implemented!\n",\r\n__func__);\r\n}\r\nbreak;\r\ncase RECV_SNRM_CMD:\r\nif (!info) {\r\ndel_timer(&self->wd_timer);\r\nIRDA_DEBUG(1, "%s(), received SNRM cmd\n", __func__);\r\nirlap_next_state(self, LAP_RESET_CHECK);\r\nirlap_reset_indication(self);\r\n} else {\r\nIRDA_DEBUG(0,\r\n"%s(), SNRM frame contained an I-field!\n",\r\n__func__);\r\n}\r\nbreak;\r\ncase RECV_REJ_CMD:\r\nirlap_update_nr_received(self, info->nr);\r\nif (self->remote_busy) {\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_rr_frame(self, RSP_FRAME);\r\n} else\r\nirlap_resend_rejected_frames(self, RSP_FRAME);\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\nbreak;\r\ncase RECV_SREJ_CMD:\r\nirlap_update_nr_received(self, info->nr);\r\nif (self->remote_busy) {\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_rr_frame(self, RSP_FRAME);\r\n} else\r\nirlap_resend_rejected_frame(self, RSP_FRAME);\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\nbreak;\r\ncase WD_TIMER_EXPIRED:\r\nIRDA_DEBUG(1, "%s(), retry_count = %d\n", __func__,\r\nself->retry_count);\r\nif (self->retry_count < (self->N2 / 2)) {\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\nself->retry_count++;\r\nif((self->retry_count % (self->N1 / 2)) == 0)\r\nirlap_status_indication(self,\r\nSTATUS_NO_ACTIVITY);\r\n} else {\r\nirlap_apply_default_connection_parameters(self);\r\nirlap_next_state(self, LAP_NDM);\r\nirlap_disconnect_indication(self, LAP_NO_RESPONSE);\r\n}\r\nbreak;\r\ncase RECV_DISC_CMD:\r\nirlap_next_state(self, LAP_NDM);\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_ua_response_frame(self, NULL);\r\ndel_timer(&self->wd_timer);\r\nirlap_flush_all_queues(self);\r\nirlap_apply_default_connection_parameters(self);\r\nirlap_disconnect_indication(self, LAP_DISC_INDICATION);\r\nbreak;\r\ncase RECV_DISCOVERY_XID_CMD:\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_rr_frame(self, RSP_FRAME);\r\nself->ack_required = TRUE;\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\nirlap_next_state(self, LAP_NRM_S);\r\nbreak;\r\ncase RECV_TEST_CMD:\r\nskb_pull(skb, LAP_ADDR_HEADER + LAP_CTRL_HEADER);\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\nirlap_send_test_frame(self, self->caddr, info->daddr, skb);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(1, "%s(), Unknown event %d, (%s)\n", __func__,\r\nevent, irlap_event[event]);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlap_state_sclose(struct irlap_cb *self, IRLAP_EVENT event,\r\nstruct sk_buff *skb, struct irlap_info *info)\r\n{\r\nIRDA_DEBUG(1, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return -ENODEV;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -EBADR;);\r\nswitch (event) {\r\ncase RECV_DISC_CMD:\r\nirlap_next_state(self, LAP_NDM);\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_ua_response_frame(self, NULL);\r\ndel_timer(&self->wd_timer);\r\nirlap_apply_default_connection_parameters(self);\r\nirlap_disconnect_indication(self, LAP_DISC_INDICATION);\r\nbreak;\r\ncase RECV_DM_RSP:\r\ncase RECV_RR_RSP:\r\ncase RECV_RNR_RSP:\r\ncase RECV_REJ_RSP:\r\ncase RECV_SREJ_RSP:\r\ncase RECV_I_RSP:\r\nirlap_next_state(self, LAP_NDM);\r\ndel_timer(&self->wd_timer);\r\nirlap_apply_default_connection_parameters(self);\r\nirlap_disconnect_indication(self, LAP_DISC_INDICATION);\r\nbreak;\r\ncase WD_TIMER_EXPIRED:\r\nirlap_next_state(self, LAP_NDM);\r\nirlap_apply_default_connection_parameters(self);\r\nirlap_disconnect_indication(self, LAP_DISC_INDICATION);\r\nbreak;\r\ndefault:\r\nif (info != NULL && info->pf) {\r\ndel_timer(&self->wd_timer);\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_rd_frame(self);\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\nbreak;\r\n}\r\nIRDA_DEBUG(1, "%s(), Unknown event %d, (%s)\n", __func__,\r\nevent, irlap_event[event]);\r\nbreak;\r\n}\r\nreturn -1;\r\n}\r\nstatic int irlap_state_reset_check( struct irlap_cb *self, IRLAP_EVENT event,\r\nstruct sk_buff *skb,\r\nstruct irlap_info *info)\r\n{\r\nint ret = 0;\r\nIRDA_DEBUG(1, "%s(), event=%s\n", __func__, irlap_event[event]);\r\nIRDA_ASSERT(self != NULL, return -ENODEV;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -EBADR;);\r\nswitch (event) {\r\ncase RESET_RESPONSE:\r\nirlap_send_ua_response_frame(self, &self->qos_rx);\r\nirlap_initiate_connection_state(self);\r\nirlap_start_wd_timer(self, WD_TIMEOUT);\r\nirlap_flush_all_queues(self);\r\nirlap_next_state(self, LAP_NRM_S);\r\nbreak;\r\ncase DISCONNECT_REQUEST:\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_send_rd_frame(self);\r\nirlap_start_wd_timer(self, WD_TIMEOUT);\r\nirlap_next_state(self, LAP_SCLOSE);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(1, "%s(), Unknown event %d, (%s)\n", __func__,\r\nevent, irlap_event[event]);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}
