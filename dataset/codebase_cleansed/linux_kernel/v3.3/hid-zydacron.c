static __u8 *zc_report_fixup(struct hid_device *hdev, __u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\nif (*rsize >= 253 &&\r\nrdesc[0x96] == 0xbc && rdesc[0x97] == 0xff &&\r\nrdesc[0xca] == 0xbc && rdesc[0xcb] == 0xff &&\r\nrdesc[0xe1] == 0xbc && rdesc[0xe2] == 0xff) {\r\nhid_info(hdev,\r\n"fixing up zydacron remote control report descriptor\n");\r\nrdesc[0x96] = rdesc[0xca] = rdesc[0xe1] = 0x0c;\r\nrdesc[0x97] = rdesc[0xcb] = rdesc[0xe2] = 0x00;\r\n}\r\nreturn rdesc;\r\n}\r\nstatic int zc_input_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nint i;\r\nstruct zc_device *zc = hid_get_drvdata(hdev);\r\nzc->input_ep81 = hi->input;\r\nif ((usage->hid & HID_USAGE_PAGE) != HID_UP_CONSUMER)\r\nreturn 0;\r\ndbg_hid("zynacron input mapping event [0x%x]\n",\r\nusage->hid & HID_USAGE);\r\nswitch (usage->hid & HID_USAGE) {\r\ncase 0x10:\r\nzc_map_key_clear(KEY_MODE);\r\nbreak;\r\ncase 0x30:\r\nzc_map_key_clear(KEY_SCREEN);\r\nbreak;\r\ncase 0x70:\r\nzc_map_key_clear(KEY_INFO);\r\nbreak;\r\ncase 0x04:\r\nzc_map_key_clear(KEY_RADIO);\r\nbreak;\r\ncase 0x0d:\r\nzc_map_key_clear(KEY_PVR);\r\nbreak;\r\ncase 0x25:\r\nzc_map_key_clear(KEY_TV);\r\nbreak;\r\ncase 0x47:\r\nzc_map_key_clear(KEY_AUDIO);\r\nbreak;\r\ncase 0x49:\r\nzc_map_key_clear(KEY_AUX);\r\nbreak;\r\ncase 0x4a:\r\nzc_map_key_clear(KEY_VIDEO);\r\nbreak;\r\ncase 0x48:\r\nzc_map_key_clear(KEY_DVD);\r\nbreak;\r\ncase 0x24:\r\nzc_map_key_clear(KEY_MENU);\r\nbreak;\r\ncase 0x32:\r\nzc_map_key_clear(KEY_TEXT);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nfor (i = 0; i < 4; i++)\r\nzc->last_key[i] = 0;\r\nreturn 1;\r\n}\r\nstatic int zc_raw_event(struct hid_device *hdev, struct hid_report *report,\r\nu8 *data, int size)\r\n{\r\nstruct zc_device *zc = hid_get_drvdata(hdev);\r\nint ret = 0;\r\nunsigned key;\r\nunsigned short index;\r\nif (report->id == data[0]) {\r\nfor (index = 0; index < 4; index++) {\r\nkey = zc->last_key[index];\r\nif (key) {\r\ninput_event(zc->input_ep81, EV_KEY, key, 0);\r\nzc->last_key[index] = 0;\r\n}\r\n}\r\nkey = 0;\r\nswitch (report->id) {\r\ncase 0x02:\r\ncase 0x03:\r\nswitch (data[1]) {\r\ncase 0x10:\r\nkey = KEY_MODE;\r\nindex = 0;\r\nbreak;\r\ncase 0x30:\r\nkey = KEY_SCREEN;\r\nindex = 1;\r\nbreak;\r\ncase 0x70:\r\nkey = KEY_INFO;\r\nindex = 2;\r\nbreak;\r\ncase 0x04:\r\nkey = KEY_RADIO;\r\nindex = 3;\r\nbreak;\r\n}\r\nif (key) {\r\ninput_event(zc->input_ep81, EV_KEY, key, 1);\r\nzc->last_key[index] = key;\r\n}\r\nret = 1;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int zc_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nint ret;\r\nstruct zc_device *zc;\r\nzc = kzalloc(sizeof(*zc), GFP_KERNEL);\r\nif (zc == NULL) {\r\nhid_err(hdev, "can't alloc descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\nhid_set_drvdata(hdev, zc);\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\ngoto err_free;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\ngoto err_free;\r\n}\r\nreturn 0;\r\nerr_free:\r\nkfree(zc);\r\nreturn ret;\r\n}\r\nstatic void zc_remove(struct hid_device *hdev)\r\n{\r\nstruct zc_device *zc = hid_get_drvdata(hdev);\r\nhid_hw_stop(hdev);\r\nkfree(zc);\r\n}\r\nstatic int __init zc_init(void)\r\n{\r\nreturn hid_register_driver(&zc_driver);\r\n}\r\nstatic void __exit zc_exit(void)\r\n{\r\nhid_unregister_driver(&zc_driver);\r\n}
