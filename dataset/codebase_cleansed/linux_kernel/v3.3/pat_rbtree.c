static int is_node_overlap(struct memtype *node, u64 start, u64 end)\r\n{\r\nif (node->start >= end || node->end <= start)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic u64 get_subtree_max_end(struct rb_node *node)\r\n{\r\nu64 ret = 0;\r\nif (node) {\r\nstruct memtype *data = container_of(node, struct memtype, rb);\r\nret = data->subtree_max_end;\r\n}\r\nreturn ret;\r\n}\r\nstatic void memtype_rb_augment_cb(struct rb_node *node, void *__unused)\r\n{\r\nstruct memtype *data;\r\nu64 max_end, child_max_end;\r\nif (!node)\r\nreturn;\r\ndata = container_of(node, struct memtype, rb);\r\nmax_end = data->end;\r\nchild_max_end = get_subtree_max_end(node->rb_right);\r\nif (child_max_end > max_end)\r\nmax_end = child_max_end;\r\nchild_max_end = get_subtree_max_end(node->rb_left);\r\nif (child_max_end > max_end)\r\nmax_end = child_max_end;\r\ndata->subtree_max_end = max_end;\r\n}\r\nstatic struct memtype *memtype_rb_lowest_match(struct rb_root *root,\r\nu64 start, u64 end)\r\n{\r\nstruct rb_node *node = root->rb_node;\r\nstruct memtype *last_lower = NULL;\r\nwhile (node) {\r\nstruct memtype *data = container_of(node, struct memtype, rb);\r\nif (get_subtree_max_end(node->rb_left) > start) {\r\nnode = node->rb_left;\r\n} else if (is_node_overlap(data, start, end)) {\r\nlast_lower = data;\r\nbreak;\r\n} else if (start >= data->start) {\r\nnode = node->rb_right;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn last_lower;\r\n}\r\nstatic struct memtype *memtype_rb_exact_match(struct rb_root *root,\r\nu64 start, u64 end)\r\n{\r\nstruct memtype *match;\r\nmatch = memtype_rb_lowest_match(root, start, end);\r\nwhile (match != NULL && match->start < end) {\r\nstruct rb_node *node;\r\nif (match->start == start && match->end == end)\r\nreturn match;\r\nnode = rb_next(&match->rb);\r\nif (node)\r\nmatch = container_of(node, struct memtype, rb);\r\nelse\r\nmatch = NULL;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int memtype_rb_check_conflict(struct rb_root *root,\r\nu64 start, u64 end,\r\nunsigned long reqtype, unsigned long *newtype)\r\n{\r\nstruct rb_node *node;\r\nstruct memtype *match;\r\nint found_type = reqtype;\r\nmatch = memtype_rb_lowest_match(&memtype_rbroot, start, end);\r\nif (match == NULL)\r\ngoto success;\r\nif (match->type != found_type && newtype == NULL)\r\ngoto failure;\r\ndprintk("Overlap at 0x%Lx-0x%Lx\n", match->start, match->end);\r\nfound_type = match->type;\r\nnode = rb_next(&match->rb);\r\nwhile (node) {\r\nmatch = container_of(node, struct memtype, rb);\r\nif (match->start >= end)\r\ngoto success;\r\nif (is_node_overlap(match, start, end) &&\r\nmatch->type != found_type) {\r\ngoto failure;\r\n}\r\nnode = rb_next(&match->rb);\r\n}\r\nsuccess:\r\nif (newtype)\r\n*newtype = found_type;\r\nreturn 0;\r\nfailure:\r\nprintk(KERN_INFO "%s:%d conflicting memory types "\r\n"%Lx-%Lx %s<->%s\n", current->comm, current->pid, start,\r\nend, cattr_name(found_type), cattr_name(match->type));\r\nreturn -EBUSY;\r\n}\r\nstatic void memtype_rb_insert(struct rb_root *root, struct memtype *newdata)\r\n{\r\nstruct rb_node **node = &(root->rb_node);\r\nstruct rb_node *parent = NULL;\r\nwhile (*node) {\r\nstruct memtype *data = container_of(*node, struct memtype, rb);\r\nparent = *node;\r\nif (newdata->start <= data->start)\r\nnode = &((*node)->rb_left);\r\nelse if (newdata->start > data->start)\r\nnode = &((*node)->rb_right);\r\n}\r\nrb_link_node(&newdata->rb, parent, node);\r\nrb_insert_color(&newdata->rb, root);\r\nrb_augment_insert(&newdata->rb, memtype_rb_augment_cb, NULL);\r\n}\r\nint rbt_memtype_check_insert(struct memtype *new, unsigned long *ret_type)\r\n{\r\nint err = 0;\r\nerr = memtype_rb_check_conflict(&memtype_rbroot, new->start, new->end,\r\nnew->type, ret_type);\r\nif (!err) {\r\nif (ret_type)\r\nnew->type = *ret_type;\r\nnew->subtree_max_end = new->end;\r\nmemtype_rb_insert(&memtype_rbroot, new);\r\n}\r\nreturn err;\r\n}\r\nstruct memtype *rbt_memtype_erase(u64 start, u64 end)\r\n{\r\nstruct rb_node *deepest;\r\nstruct memtype *data;\r\ndata = memtype_rb_exact_match(&memtype_rbroot, start, end);\r\nif (!data)\r\ngoto out;\r\ndeepest = rb_augment_erase_begin(&data->rb);\r\nrb_erase(&data->rb, &memtype_rbroot);\r\nrb_augment_erase_end(deepest, memtype_rb_augment_cb, NULL);\r\nout:\r\nreturn data;\r\n}\r\nstruct memtype *rbt_memtype_lookup(u64 addr)\r\n{\r\nstruct memtype *data;\r\ndata = memtype_rb_lowest_match(&memtype_rbroot, addr, addr + PAGE_SIZE);\r\nreturn data;\r\n}\r\nint rbt_memtype_copy_nth_element(struct memtype *out, loff_t pos)\r\n{\r\nstruct rb_node *node;\r\nint i = 1;\r\nnode = rb_first(&memtype_rbroot);\r\nwhile (node && pos != i) {\r\nnode = rb_next(node);\r\ni++;\r\n}\r\nif (node) {\r\nstruct memtype *this = container_of(node, struct memtype, rb);\r\n*out = *this;\r\nreturn 0;\r\n} else {\r\nreturn 1;\r\n}\r\n}
