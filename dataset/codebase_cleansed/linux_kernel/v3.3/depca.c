static int __devexit depca_isa_remove(struct platform_device *pdev)\r\n{\r\nreturn depca_device_remove(&pdev->dev);\r\n}\r\nstatic int __init depca_hw_init (struct net_device *dev, struct device *device)\r\n{\r\nstruct depca_private *lp;\r\nint i, j, offset, netRAM, mem_len, status = 0;\r\ns16 nicsr;\r\nu_long ioaddr;\r\nu_long mem_start;\r\nioaddr = dev->base_addr;\r\nSTOP_DEPCA;\r\nnicsr = inb(DEPCA_NICSR);\r\nnicsr = ((nicsr & ~SHE & ~RBE & ~IEN) | IM);\r\noutb(nicsr, DEPCA_NICSR);\r\nif (inw(DEPCA_DATA) != STOP) {\r\nreturn -ENXIO;\r\n}\r\nlp = netdev_priv(dev);\r\nmem_start = lp->mem_start;\r\nif (!mem_start || lp->adapter < DEPCA || lp->adapter >=unknown)\r\nreturn -ENXIO;\r\nprintk("%s: %s at 0x%04lx",\r\ndev_name(device), depca_signature[lp->adapter], ioaddr);\r\nswitch (lp->depca_bus) {\r\n#ifdef CONFIG_MCA\r\ncase DEPCA_BUS_MCA:\r\nprintk(" (MCA slot %d)", to_mca_device(device)->slot + 1);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_EISA\r\ncase DEPCA_BUS_EISA:\r\nprintk(" (EISA slot %d)", to_eisa_device(device)->slot);\r\nbreak;\r\n#endif\r\ncase DEPCA_BUS_ISA:\r\nbreak;\r\ndefault:\r\nprintk("Unknown DEPCA bus %d\n", lp->depca_bus);\r\nreturn -ENXIO;\r\n}\r\nprintk(", h/w address ");\r\nstatus = get_hw_addr(dev);\r\nprintk("%pM", dev->dev_addr);\r\nif (status != 0) {\r\nprintk(" which has an Ethernet PROM CRC error.\n");\r\nreturn -ENXIO;\r\n}\r\nnetRAM = ((lp->adapter != DEPCA) ? 64 : 48);\r\nif ((nicsr & _128KB) && (lp->adapter == de422))\r\nnetRAM = 128;\r\nif (nicsr & BUF) {\r\nnicsr &= ~BS;\r\nnetRAM -= 32;\r\nif (lp->depca_bus != DEPCA_BUS_MCA)\r\nmem_start += 0x8000;\r\n}\r\nif ((mem_len = (NUM_RX_DESC * (sizeof(struct depca_rx_desc) + RX_BUFF_SZ) + NUM_TX_DESC * (sizeof(struct depca_tx_desc) + TX_BUFF_SZ) + sizeof(struct depca_init)))\r\n> (netRAM << 10)) {\r\nprintk(",\n requests %dkB RAM: only %dkB is available!\n", (mem_len >> 10), netRAM);\r\nreturn -ENXIO;\r\n}\r\nprintk(",\n has %dkB RAM at 0x%.5lx", netRAM, mem_start);\r\nif (lp->adapter != DEPCA) {\r\nnicsr |= SHE;\r\noutb(nicsr, DEPCA_NICSR);\r\n}\r\nspin_lock_init(&lp->lock);\r\nsprintf(lp->adapter_name, "%s (%s)",\r\ndepca_signature[lp->adapter], dev_name(device));\r\nstatus = -EBUSY;\r\nif (!request_mem_region (mem_start, mem_len, lp->adapter_name)) {\r\nprintk(KERN_ERR "depca: cannot request ISA memory, aborting\n");\r\ngoto out_priv;\r\n}\r\nstatus = -EIO;\r\nlp->sh_mem = ioremap(mem_start, mem_len);\r\nif (lp->sh_mem == NULL) {\r\nprintk(KERN_ERR "depca: cannot remap ISA memory, aborting\n");\r\ngoto out1;\r\n}\r\nlp->mem_start = mem_start;\r\nlp->mem_len = mem_len;\r\nlp->device_ram_start = mem_start & LA_MASK;\r\noffset = 0;\r\noffset += sizeof(struct depca_init);\r\noffset = (offset + DEPCA_ALIGN) & ~DEPCA_ALIGN;\r\nlp->rx_ring = lp->sh_mem + offset;\r\nlp->rx_ring_offset = offset;\r\noffset += (sizeof(struct depca_rx_desc) * NUM_RX_DESC);\r\nlp->tx_ring = lp->sh_mem + offset;\r\nlp->tx_ring_offset = offset;\r\noffset += (sizeof(struct depca_tx_desc) * NUM_TX_DESC);\r\nlp->buffs_offset = offset;\r\nlp->rxRingMask = NUM_RX_DESC - 1;\r\nlp->txRingMask = NUM_TX_DESC - 1;\r\nfor (i = 0, j = lp->rxRingMask; j > 0; i++) {\r\nj >>= 1;\r\n}\r\nlp->rx_rlen = (s32) (i << 29);\r\nfor (i = 0, j = lp->txRingMask; j > 0; i++) {\r\nj >>= 1;\r\n}\r\nlp->tx_rlen = (s32) (i << 29);\r\ndepca_init_ring(dev);\r\nLoadCSRs(dev);\r\nnicsr = ((nicsr & ~IM) | IEN);\r\noutb(nicsr, DEPCA_NICSR);\r\nif (dev->irq < 2) {\r\nunsigned char irqnum;\r\nunsigned long irq_mask, delay;\r\nirq_mask = probe_irq_on();\r\nswitch (lp->adapter) {\r\ncase DEPCA:\r\ncase de100:\r\ncase de101:\r\ndepca_irq = de1xx_irq;\r\nbreak;\r\ncase de200:\r\ncase de201:\r\ncase de202:\r\ncase de210:\r\ncase de212:\r\ndepca_irq = de2xx_irq;\r\nbreak;\r\ncase de422:\r\ndepca_irq = de422_irq;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\noutw(INEA | INIT, DEPCA_DATA);\r\ndelay = jiffies + HZ/50;\r\nwhile (time_before(jiffies, delay))\r\nyield();\r\nirqnum = probe_irq_off(irq_mask);\r\nstatus = -ENXIO;\r\nif (!irqnum) {\r\nprintk(" and failed to detect IRQ line.\n");\r\ngoto out2;\r\n} else {\r\nfor (dev->irq = 0, i = 0; (depca_irq[i]) && (!dev->irq); i++)\r\nif (irqnum == depca_irq[i]) {\r\ndev->irq = irqnum;\r\nprintk(" and uses IRQ%d.\n", dev->irq);\r\n}\r\nif (!dev->irq) {\r\nprintk(" but incorrect IRQ line detected.\n");\r\ngoto out2;\r\n}\r\n}\r\n} else {\r\nprintk(" and assigned IRQ%d.\n", dev->irq);\r\n}\r\nif (depca_debug > 1) {\r\nprintk(version);\r\n}\r\ndev->netdev_ops = &depca_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\ndev->mem_start = 0;\r\ndev_set_drvdata(device, dev);\r\nSET_NETDEV_DEV (dev, device);\r\nstatus = register_netdev(dev);\r\nif (status == 0)\r\nreturn 0;\r\nout2:\r\niounmap(lp->sh_mem);\r\nout1:\r\nrelease_mem_region (mem_start, mem_len);\r\nout_priv:\r\nreturn status;\r\n}\r\nstatic int depca_open(struct net_device *dev)\r\n{\r\nstruct depca_private *lp = netdev_priv(dev);\r\nu_long ioaddr = dev->base_addr;\r\ns16 nicsr;\r\nint status = 0;\r\nSTOP_DEPCA;\r\nnicsr = inb(DEPCA_NICSR);\r\nif (lp->adapter != DEPCA) {\r\nnicsr |= SHE;\r\noutb(nicsr, DEPCA_NICSR);\r\n}\r\ndepca_init_ring(dev);\r\nLoadCSRs(dev);\r\ndepca_dbg_open(dev);\r\nif (request_irq(dev->irq, depca_interrupt, 0, lp->adapter_name, dev)) {\r\nprintk("depca_open(): Requested IRQ%d is busy\n", dev->irq);\r\nstatus = -EAGAIN;\r\n} else {\r\nnicsr = ((nicsr & ~IM & ~LED) | IEN);\r\noutb(nicsr, DEPCA_NICSR);\r\noutw(CSR0, DEPCA_ADDR);\r\nnetif_start_queue(dev);\r\nstatus = InitRestartDepca(dev);\r\nif (depca_debug > 1) {\r\nprintk("CSR0: 0x%4.4x\n", inw(DEPCA_DATA));\r\nprintk("nicsr: 0x%02x\n", inb(DEPCA_NICSR));\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic void depca_init_ring(struct net_device *dev)\r\n{\r\nstruct depca_private *lp = netdev_priv(dev);\r\nu_int i;\r\nu_long offset;\r\nnetif_stop_queue(dev);\r\nlp->rx_new = lp->tx_new = 0;\r\nlp->rx_old = lp->tx_old = 0;\r\nfor (i = 0; i <= lp->rxRingMask; i++) {\r\noffset = lp->buffs_offset + i * RX_BUFF_SZ;\r\nwritel((lp->device_ram_start + offset) | R_OWN, &lp->rx_ring[i].base);\r\nwritew(-RX_BUFF_SZ, &lp->rx_ring[i].buf_length);\r\nlp->rx_buff[i] = lp->sh_mem + offset;\r\n}\r\nfor (i = 0; i <= lp->txRingMask; i++) {\r\noffset = lp->buffs_offset + (i + lp->rxRingMask + 1) * TX_BUFF_SZ;\r\nwritel((lp->device_ram_start + offset) & 0x00ffffff, &lp->tx_ring[i].base);\r\nlp->tx_buff[i] = lp->sh_mem + offset;\r\n}\r\nlp->init_block.rx_ring = (lp->device_ram_start + lp->rx_ring_offset) | lp->rx_rlen;\r\nlp->init_block.tx_ring = (lp->device_ram_start + lp->tx_ring_offset) | lp->tx_rlen;\r\nSetMulticastFilter(dev);\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\nlp->init_block.phys_addr[i] = dev->dev_addr[i];\r\n}\r\nlp->init_block.mode = 0x0000;\r\n}\r\nstatic void depca_tx_timeout(struct net_device *dev)\r\n{\r\nu_long ioaddr = dev->base_addr;\r\nprintk("%s: transmit timed out, status %04x, resetting.\n", dev->name, inw(DEPCA_DATA));\r\nSTOP_DEPCA;\r\ndepca_init_ring(dev);\r\nLoadCSRs(dev);\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\nInitRestartDepca(dev);\r\n}\r\nstatic netdev_tx_t depca_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct depca_private *lp = netdev_priv(dev);\r\nu_long ioaddr = dev->base_addr;\r\nint status = 0;\r\nif (skb->len < 1)\r\ngoto out;\r\nif (skb_padto(skb, ETH_ZLEN))\r\ngoto out;\r\nnetif_stop_queue(dev);\r\nif (TX_BUFFS_AVAIL) {\r\nstatus = load_packet(dev, skb);\r\nif (!status) {\r\noutw(CSR0, DEPCA_ADDR);\r\noutw(INEA | TDMD, DEPCA_DATA);\r\ndev_kfree_skb(skb);\r\n}\r\nif (TX_BUFFS_AVAIL)\r\nnetif_start_queue(dev);\r\n} else\r\nstatus = NETDEV_TX_LOCKED;\r\nout:\r\nreturn status;\r\n}\r\nstatic irqreturn_t depca_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct depca_private *lp;\r\ns16 csr0, nicsr;\r\nu_long ioaddr;\r\nif (dev == NULL) {\r\nprintk("depca_interrupt(): irq %d for unknown device.\n", irq);\r\nreturn IRQ_NONE;\r\n}\r\nlp = netdev_priv(dev);\r\nioaddr = dev->base_addr;\r\nspin_lock(&lp->lock);\r\nnicsr = inb(DEPCA_NICSR);\r\nnicsr |= (IM | LED);\r\noutb(nicsr, DEPCA_NICSR);\r\noutw(CSR0, DEPCA_ADDR);\r\ncsr0 = inw(DEPCA_DATA);\r\noutw(csr0 & INTE, DEPCA_DATA);\r\nif (csr0 & RINT)\r\ndepca_rx(dev);\r\nif (csr0 & TINT)\r\ndepca_tx(dev);\r\nif ((TX_BUFFS_AVAIL >= 0) && netif_queue_stopped(dev)) {\r\nnetif_wake_queue(dev);\r\n}\r\nnicsr = (nicsr & ~IM & ~LED);\r\noutb(nicsr, DEPCA_NICSR);\r\nspin_unlock(&lp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int depca_rx(struct net_device *dev)\r\n{\r\nstruct depca_private *lp = netdev_priv(dev);\r\nint i, entry;\r\ns32 status;\r\nfor (entry = lp->rx_new; !(readl(&lp->rx_ring[entry].base) & R_OWN); entry = lp->rx_new) {\r\nstatus = readl(&lp->rx_ring[entry].base) >> 16;\r\nif (status & R_STP) {\r\nlp->rx_old = entry;\r\n}\r\nif (status & R_ENP) {\r\nif (status & R_ERR) {\r\ndev->stats.rx_errors++;\r\nif (status & R_FRAM)\r\ndev->stats.rx_frame_errors++;\r\nif (status & R_OFLO)\r\ndev->stats.rx_over_errors++;\r\nif (status & R_CRC)\r\ndev->stats.rx_crc_errors++;\r\nif (status & R_BUFF)\r\ndev->stats.rx_fifo_errors++;\r\n} else {\r\nshort len, pkt_len = readw(&lp->rx_ring[entry].msg_length) - 4;\r\nstruct sk_buff *skb;\r\nskb = dev_alloc_skb(pkt_len + 2);\r\nif (skb != NULL) {\r\nunsigned char *buf;\r\nskb_reserve(skb, 2);\r\nbuf = skb_put(skb, pkt_len);\r\nif (entry < lp->rx_old) {\r\nlen = (lp->rxRingMask - lp->rx_old + 1) * RX_BUFF_SZ;\r\nmemcpy_fromio(buf, lp->rx_buff[lp->rx_old], len);\r\nmemcpy_fromio(buf + len, lp->rx_buff[0], pkt_len - len);\r\n} else {\r\nmemcpy_fromio(buf, lp->rx_buff[lp->rx_old], pkt_len);\r\n}\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\nfor (i = 1; i < DEPCA_PKT_STAT_SZ - 1; i++) {\r\nif (pkt_len < (i * DEPCA_PKT_BIN_SZ)) {\r\nlp->pktStats.bins[i]++;\r\ni = DEPCA_PKT_STAT_SZ;\r\n}\r\n}\r\nif (is_multicast_ether_addr(buf)) {\r\nif (is_broadcast_ether_addr(buf)) {\r\nlp->pktStats.broadcast++;\r\n} else {\r\nlp->pktStats.multicast++;\r\n}\r\n} else if (compare_ether_addr(buf, dev->dev_addr) == 0) {\r\nlp->pktStats.unicast++;\r\n}\r\nlp->pktStats.bins[0]++;\r\nif (lp->pktStats.bins[0] == 0) {\r\nmemset((char *) &lp->pktStats, 0, sizeof(lp->pktStats));\r\n}\r\n} else {\r\nprintk("%s: Memory squeeze, deferring packet.\n", dev->name);\r\ndev->stats.rx_dropped++;\r\nbreak;\r\n}\r\n}\r\nfor (; lp->rx_old != entry; lp->rx_old = (lp->rx_old + 1) & lp->rxRingMask) {\r\nwritel(readl(&lp->rx_ring[lp->rx_old].base) | R_OWN, &lp->rx_ring[lp->rx_old].base);\r\n}\r\nwritel(readl(&lp->rx_ring[entry].base) | R_OWN, &lp->rx_ring[entry].base);\r\n}\r\nlp->rx_new = (lp->rx_new + 1) & lp->rxRingMask;\r\n}\r\nreturn 0;\r\n}\r\nstatic int depca_tx(struct net_device *dev)\r\n{\r\nstruct depca_private *lp = netdev_priv(dev);\r\nint entry;\r\ns32 status;\r\nu_long ioaddr = dev->base_addr;\r\nfor (entry = lp->tx_old; entry != lp->tx_new; entry = lp->tx_old) {\r\nstatus = readl(&lp->tx_ring[entry].base) >> 16;\r\nif (status < 0) {\r\nbreak;\r\n} else if (status & T_ERR) {\r\nstatus = readl(&lp->tx_ring[entry].misc);\r\ndev->stats.tx_errors++;\r\nif (status & TMD3_RTRY)\r\ndev->stats.tx_aborted_errors++;\r\nif (status & TMD3_LCAR)\r\ndev->stats.tx_carrier_errors++;\r\nif (status & TMD3_LCOL)\r\ndev->stats.tx_window_errors++;\r\nif (status & TMD3_UFLO)\r\ndev->stats.tx_fifo_errors++;\r\nif (status & (TMD3_BUFF | TMD3_UFLO)) {\r\noutw(CSR0, DEPCA_ADDR);\r\noutw(INEA | TDMD, DEPCA_DATA);\r\n}\r\n} else if (status & (T_MORE | T_ONE)) {\r\ndev->stats.collisions++;\r\n} else {\r\ndev->stats.tx_packets++;\r\n}\r\nlp->tx_old = (lp->tx_old + 1) & lp->txRingMask;\r\n}\r\nreturn 0;\r\n}\r\nstatic int depca_close(struct net_device *dev)\r\n{\r\nstruct depca_private *lp = netdev_priv(dev);\r\ns16 nicsr;\r\nu_long ioaddr = dev->base_addr;\r\nnetif_stop_queue(dev);\r\noutw(CSR0, DEPCA_ADDR);\r\nif (depca_debug > 1) {\r\nprintk("%s: Shutting down ethercard, status was %2.2x.\n", dev->name, inw(DEPCA_DATA));\r\n}\r\noutw(STOP, DEPCA_DATA);\r\nif (lp->adapter != DEPCA) {\r\nnicsr = inb(DEPCA_NICSR);\r\nnicsr &= ~SHE;\r\noutb(nicsr, DEPCA_NICSR);\r\n}\r\nfree_irq(dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic void LoadCSRs(struct net_device *dev)\r\n{\r\nstruct depca_private *lp = netdev_priv(dev);\r\nu_long ioaddr = dev->base_addr;\r\noutw(CSR1, DEPCA_ADDR);\r\noutw((u16) lp->device_ram_start, DEPCA_DATA);\r\noutw(CSR2, DEPCA_ADDR);\r\noutw((u16) (lp->device_ram_start >> 16), DEPCA_DATA);\r\noutw(CSR3, DEPCA_ADDR);\r\noutw(ACON, DEPCA_DATA);\r\noutw(CSR0, DEPCA_ADDR);\r\n}\r\nstatic int InitRestartDepca(struct net_device *dev)\r\n{\r\nstruct depca_private *lp = netdev_priv(dev);\r\nu_long ioaddr = dev->base_addr;\r\nint i, status = 0;\r\nmemcpy_toio(lp->sh_mem, &lp->init_block, sizeof(struct depca_init));\r\noutw(CSR0, DEPCA_ADDR);\r\noutw(INIT, DEPCA_DATA);\r\nfor (i = 0; (i < 100) && !(inw(DEPCA_DATA) & IDON); i++);\r\nif (i != 100) {\r\noutw(IDON | INEA | STRT, DEPCA_DATA);\r\nif (depca_debug > 2) {\r\nprintk("%s: DEPCA open after %d ticks, init block 0x%08lx csr0 %4.4x.\n", dev->name, i, lp->mem_start, inw(DEPCA_DATA));\r\n}\r\n} else {\r\nprintk("%s: DEPCA unopen after %d ticks, init block 0x%08lx csr0 %4.4x.\n", dev->name, i, lp->mem_start, inw(DEPCA_DATA));\r\nstatus = -1;\r\n}\r\nreturn status;\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nstruct depca_private *lp = netdev_priv(dev);\r\nu_long ioaddr = dev->base_addr;\r\nnetif_stop_queue(dev);\r\nwhile (lp->tx_old != lp->tx_new);\r\nSTOP_DEPCA;\r\ndepca_init_ring(dev);\r\nif (dev->flags & IFF_PROMISC) {\r\nlp->init_block.mode |= PROM;\r\n} else {\r\nSetMulticastFilter(dev);\r\nlp->init_block.mode &= ~PROM;\r\n}\r\nLoadCSRs(dev);\r\nInitRestartDepca(dev);\r\nnetif_start_queue(dev);\r\n}\r\nstatic void SetMulticastFilter(struct net_device *dev)\r\n{\r\nstruct depca_private *lp = netdev_priv(dev);\r\nstruct netdev_hw_addr *ha;\r\nint i, j, bit, byte;\r\nu16 hashcode;\r\nu32 crc;\r\nif (dev->flags & IFF_ALLMULTI) {\r\nfor (i = 0; i < (HASH_TABLE_LEN >> 3); i++) {\r\nlp->init_block.mcast_table[i] = (char) 0xff;\r\n}\r\n} else {\r\nfor (i = 0; i < (HASH_TABLE_LEN >> 3); i++) {\r\nlp->init_block.mcast_table[i] = 0;\r\n}\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc(ETH_ALEN, ha->addr);\r\nhashcode = (crc & 1);\r\nfor (j = 0; j < 5; j++) {\r\nhashcode = (hashcode << 1) | ((crc >>= 1) & 1);\r\n}\r\nbyte = hashcode >> 3;\r\nbit = 1 << (hashcode & 0x07);\r\nlp->init_block.mcast_table[byte] |= bit;\r\n}\r\n}\r\n}\r\nstatic int __init depca_common_init (u_long ioaddr, struct net_device **devp)\r\n{\r\nint status = 0;\r\nif (!request_region (ioaddr, DEPCA_TOTAL_SIZE, depca_string)) {\r\nstatus = -EBUSY;\r\ngoto out;\r\n}\r\nif (DevicePresent(ioaddr)) {\r\nstatus = -ENODEV;\r\ngoto out_release;\r\n}\r\nif (!(*devp = alloc_etherdev (sizeof (struct depca_private)))) {\r\nstatus = -ENOMEM;\r\ngoto out_release;\r\n}\r\nreturn 0;\r\nout_release:\r\nrelease_region (ioaddr, DEPCA_TOTAL_SIZE);\r\nout:\r\nreturn status;\r\n}\r\nstatic int __init depca_mca_probe(struct device *device)\r\n{\r\nunsigned char pos[2];\r\nunsigned char where;\r\nunsigned long iobase, mem_start;\r\nint irq, err;\r\nstruct mca_device *mdev = to_mca_device (device);\r\nstruct net_device *dev;\r\nstruct depca_private *lp;\r\npos[0] = mca_device_read_stored_pos(mdev, 2);\r\npos[1] = mca_device_read_stored_pos(mdev, 3);\r\nwhere = (pos[0] & 6) >> 1;\r\niobase = 0x2c00 + (0x10 * where);\r\nwhere = pos[1] & 0x0f;\r\nswitch (where) {\r\ncase 1:\r\nirq = 9;\r\nbreak;\r\ncase 2:\r\nirq = 5;\r\nbreak;\r\ncase 4:\r\nirq = 10;\r\nbreak;\r\ncase 8:\r\nirq = 11;\r\nbreak;\r\ndefault:\r\nprintk("%s: mca_probe IRQ error. You should never get here (%d).\n", mdev->name, where);\r\nreturn -EINVAL;\r\n}\r\nwhere = (pos[0] & 0x18) >> 3;\r\nmem_start = 0xc0000 + (where * 0x10000);\r\nif (pos[0] & 0x20) {\r\nmem_start += 0x8000;\r\n}\r\nstrncpy(mdev->name, depca_mca_adapter_name[mdev->index],\r\nsizeof(mdev->name));\r\nmca_device_set_claim(mdev, 1);\r\nirq = mca_device_transform_irq(mdev, irq);\r\niobase = mca_device_transform_ioport(mdev, iobase);\r\nif ((err = depca_common_init (iobase, &dev)))\r\ngoto out_unclaim;\r\ndev->irq = irq;\r\ndev->base_addr = iobase;\r\nlp = netdev_priv(dev);\r\nlp->depca_bus = DEPCA_BUS_MCA;\r\nlp->adapter = depca_mca_adapter_type[mdev->index];\r\nlp->mem_start = mem_start;\r\nif ((err = depca_hw_init(dev, device)))\r\ngoto out_free;\r\nreturn 0;\r\nout_free:\r\nfree_netdev (dev);\r\nrelease_region (iobase, DEPCA_TOTAL_SIZE);\r\nout_unclaim:\r\nmca_device_set_claim(mdev, 0);\r\nreturn err;\r\n}\r\nstatic void __init depca_platform_probe (void)\r\n{\r\nint i;\r\nstruct platform_device *pldev;\r\nfor (i = 0; depca_io_ports[i].iobase; i++) {\r\ndepca_io_ports[i].device = NULL;\r\nif (io && io != depca_io_ports[i].iobase)\r\ncontinue;\r\npldev = platform_device_alloc(depca_string, i);\r\nif (!pldev)\r\ncontinue;\r\npldev->dev.platform_data = (void *) depca_io_ports[i].iobase;\r\ndepca_io_ports[i].device = pldev;\r\nif (platform_device_add(pldev)) {\r\ndepca_io_ports[i].device = NULL;\r\npldev->dev.platform_data = NULL;\r\nplatform_device_put(pldev);\r\ncontinue;\r\n}\r\nif (!pldev->dev.driver) {\r\ndepca_io_ports[i].device = NULL;\r\npldev->dev.platform_data = NULL;\r\nplatform_device_unregister (pldev);\r\n}\r\n}\r\n}\r\nstatic enum depca_type __init depca_shmem_probe (ulong *mem_start)\r\n{\r\nu_long mem_base[] = DEPCA_RAM_BASE_ADDRESSES;\r\nenum depca_type adapter = unknown;\r\nint i;\r\nfor (i = 0; mem_base[i]; i++) {\r\n*mem_start = mem ? mem : mem_base[i];\r\nadapter = DepcaSignature (adapter_name, *mem_start);\r\nif (adapter != unknown)\r\nbreak;\r\n}\r\nreturn adapter;\r\n}\r\nstatic int __devinit depca_isa_probe (struct platform_device *device)\r\n{\r\nstruct net_device *dev;\r\nstruct depca_private *lp;\r\nu_long ioaddr, mem_start = 0;\r\nenum depca_type adapter = unknown;\r\nint status = 0;\r\nioaddr = (u_long) device->dev.platform_data;\r\nif ((status = depca_common_init (ioaddr, &dev)))\r\ngoto out;\r\nadapter = depca_shmem_probe (&mem_start);\r\nif (adapter == unknown) {\r\nstatus = -ENODEV;\r\ngoto out_free;\r\n}\r\ndev->base_addr = ioaddr;\r\ndev->irq = irq;\r\nlp = netdev_priv(dev);\r\nlp->depca_bus = DEPCA_BUS_ISA;\r\nlp->adapter = adapter;\r\nlp->mem_start = mem_start;\r\nif ((status = depca_hw_init(dev, &device->dev)))\r\ngoto out_free;\r\nreturn 0;\r\nout_free:\r\nfree_netdev (dev);\r\nrelease_region (ioaddr, DEPCA_TOTAL_SIZE);\r\nout:\r\nreturn status;\r\n}\r\nstatic int __init depca_eisa_probe (struct device *device)\r\n{\r\nenum depca_type adapter = unknown;\r\nstruct eisa_device *edev;\r\nstruct net_device *dev;\r\nstruct depca_private *lp;\r\nu_long ioaddr, mem_start;\r\nint status = 0;\r\nedev = to_eisa_device (device);\r\nioaddr = edev->base_addr + DEPCA_EISA_IO_PORTS;\r\nif ((status = depca_common_init (ioaddr, &dev)))\r\ngoto out;\r\nadapter = depca_shmem_probe (&mem_start);\r\nif (adapter == unknown) {\r\nstatus = -ENODEV;\r\ngoto out_free;\r\n}\r\ndev->base_addr = ioaddr;\r\ndev->irq = irq;\r\nlp = netdev_priv(dev);\r\nlp->depca_bus = DEPCA_BUS_EISA;\r\nlp->adapter = edev->id.driver_data;\r\nlp->mem_start = mem_start;\r\nif ((status = depca_hw_init(dev, device)))\r\ngoto out_free;\r\nreturn 0;\r\nout_free:\r\nfree_netdev (dev);\r\nrelease_region (ioaddr, DEPCA_TOTAL_SIZE);\r\nout:\r\nreturn status;\r\n}\r\nstatic int __devexit depca_device_remove (struct device *device)\r\n{\r\nstruct net_device *dev;\r\nstruct depca_private *lp;\r\nint bus;\r\ndev = dev_get_drvdata(device);\r\nlp = netdev_priv(dev);\r\nunregister_netdev (dev);\r\niounmap (lp->sh_mem);\r\nrelease_mem_region (lp->mem_start, lp->mem_len);\r\nrelease_region (dev->base_addr, DEPCA_TOTAL_SIZE);\r\nbus = lp->depca_bus;\r\nfree_netdev (dev);\r\nreturn 0;\r\n}\r\nstatic int __init DepcaSignature(char *name, u_long base_addr)\r\n{\r\nu_int i, j, k;\r\nvoid __iomem *ptr;\r\nchar tmpstr[16];\r\nu_long prom_addr = base_addr + 0xc000;\r\nu_long mem_addr = base_addr + 0x8000;\r\nif (!request_mem_region (mem_addr, 16, depca_string))\r\nreturn unknown;\r\nptr = ioremap(prom_addr, 16);\r\nif (ptr == NULL) {\r\nprintk(KERN_ERR "depca: I/O remap failed at %lx\n", prom_addr);\r\nreturn unknown;\r\n}\r\nfor (i = 0; i < 16; i++) {\r\ntmpstr[i] = readb(ptr + i);\r\n}\r\niounmap(ptr);\r\nrelease_mem_region (mem_addr, 16);\r\nfor (i = 0; *depca_signature[i] != '\0'; i++) {\r\nfor (j = 0, k = 0; j < 16 && k < strlen(depca_signature[i]); j++) {\r\nif (depca_signature[i][k] == tmpstr[j]) {\r\nk++;\r\n} else {\r\nk = 0;\r\n}\r\n}\r\nif (k == strlen(depca_signature[i]))\r\nbreak;\r\n}\r\nif (name && *name && (i == unknown)) {\r\nfor (i = 0; *depca_signature[i] != '\0'; i++) {\r\nif (strcmp(name, depca_signature[i]) == 0)\r\nbreak;\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic int __init DevicePresent(u_long ioaddr)\r\n{\r\nunion {\r\nstruct {\r\nu32 a;\r\nu32 b;\r\n} llsig;\r\nchar Sig[sizeof(u32) << 1];\r\n}\r\ndev;\r\nshort sigLength = 0;\r\ns8 data;\r\ns16 nicsr;\r\nint i, j, status = 0;\r\ndata = inb(DEPCA_PROM);\r\ndata = inb(DEPCA_PROM);\r\nif (data == 0x08) {\r\nnicsr = inb(DEPCA_NICSR);\r\nnicsr |= AAC;\r\noutb(nicsr, DEPCA_NICSR);\r\n}\r\ndev.llsig.a = ETH_PROM_SIG;\r\ndev.llsig.b = ETH_PROM_SIG;\r\nsigLength = sizeof(u32) << 1;\r\nfor (i = 0, j = 0; j < sigLength && i < PROBE_LENGTH + sigLength - 1; i++) {\r\ndata = inb(DEPCA_PROM);\r\nif (dev.Sig[j] == data) {\r\nj++;\r\n} else {\r\nif (data == dev.Sig[0]) {\r\nj = 1;\r\n} else {\r\nj = 0;\r\n}\r\n}\r\n}\r\nif (j != sigLength) {\r\nstatus = -ENODEV;\r\n}\r\nreturn status;\r\n}\r\nstatic int __init get_hw_addr(struct net_device *dev)\r\n{\r\nu_long ioaddr = dev->base_addr;\r\nstruct depca_private *lp = netdev_priv(dev);\r\nint i, k, tmp, status = 0;\r\nu_short j, x, chksum;\r\nx = (((lp->adapter == de100) || (lp->adapter == de101)) ? 1 : 0);\r\nfor (i = 0, k = 0, j = 0; j < 3; j++) {\r\nk <<= 1;\r\nif (k > 0xffff)\r\nk -= 0xffff;\r\nk += (u_char) (tmp = inb(DEPCA_PROM + x));\r\ndev->dev_addr[i++] = (u_char) tmp;\r\nk += (u_short) ((tmp = inb(DEPCA_PROM + x)) << 8);\r\ndev->dev_addr[i++] = (u_char) tmp;\r\nif (k > 0xffff)\r\nk -= 0xffff;\r\n}\r\nif (k == 0xffff)\r\nk = 0;\r\nchksum = (u_char) inb(DEPCA_PROM + x);\r\nchksum |= (u_short) (inb(DEPCA_PROM + x) << 8);\r\nif (k != chksum)\r\nstatus = -1;\r\nreturn status;\r\n}\r\nstatic int load_packet(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct depca_private *lp = netdev_priv(dev);\r\nint i, entry, end, len, status = NETDEV_TX_OK;\r\nentry = lp->tx_new;\r\nend = (entry + (skb->len - 1) / TX_BUFF_SZ) & lp->txRingMask;\r\nif (!(readl(&lp->tx_ring[end].base) & T_OWN)) {\r\nif (end < entry) {\r\nlen = (lp->txRingMask - entry + 1) * TX_BUFF_SZ;\r\nmemcpy_toio(lp->tx_buff[entry], skb->data, len);\r\nmemcpy_toio(lp->tx_buff[0], skb->data + len, skb->len - len);\r\n} else {\r\nmemcpy_toio(lp->tx_buff[entry], skb->data, skb->len);\r\n}\r\nlen = (skb->len < ETH_ZLEN) ? ETH_ZLEN : skb->len;\r\nfor (i = entry; i != end; i = (i+1) & lp->txRingMask) {\r\nwritel(readl(&lp->tx_ring[i].base) & ~T_FLAGS, &lp->tx_ring[i].base);\r\nwritew(0x0000, &lp->tx_ring[i].misc);\r\nwritew(-TX_BUFF_SZ, &lp->tx_ring[i].length);\r\nlen -= TX_BUFF_SZ;\r\n}\r\nwritel(readl(&lp->tx_ring[end].base) & ~T_FLAGS, &lp->tx_ring[end].base);\r\nwritew(0x0000, &lp->tx_ring[end].misc);\r\nwritew(-len, &lp->tx_ring[end].length);\r\nwritel(readl(&lp->tx_ring[entry].base) | T_STP, &lp->tx_ring[entry].base);\r\nwritel(readl(&lp->tx_ring[end].base) | T_ENP, &lp->tx_ring[end].base);\r\nfor (i = end; i != entry; --i) {\r\nwritel(readl(&lp->tx_ring[i].base) | T_OWN, &lp->tx_ring[i].base);\r\nif (i == 0)\r\ni = lp->txRingMask + 1;\r\n}\r\nwritel(readl(&lp->tx_ring[entry].base) | T_OWN, &lp->tx_ring[entry].base);\r\nlp->tx_new = (++end) & lp->txRingMask;\r\n} else {\r\nstatus = NETDEV_TX_LOCKED;\r\n}\r\nreturn status;\r\n}\r\nstatic void depca_dbg_open(struct net_device *dev)\r\n{\r\nstruct depca_private *lp = netdev_priv(dev);\r\nu_long ioaddr = dev->base_addr;\r\nstruct depca_init *p = &lp->init_block;\r\nint i;\r\nif (depca_debug > 1) {\r\nprintk("%s: depca open with irq %d\n", dev->name, dev->irq);\r\nprintk("Descriptor head addresses (CPU):\n");\r\nprintk(" 0x%lx 0x%lx\n", (u_long) lp->rx_ring, (u_long) lp->tx_ring);\r\nprintk("Descriptor addresses (CPU):\nRX: ");\r\nfor (i = 0; i < lp->rxRingMask; i++) {\r\nif (i < 3) {\r\nprintk("%p ", &lp->rx_ring[i].base);\r\n}\r\n}\r\nprintk("...%p\n", &lp->rx_ring[i].base);\r\nprintk("TX: ");\r\nfor (i = 0; i < lp->txRingMask; i++) {\r\nif (i < 3) {\r\nprintk("%p ", &lp->tx_ring[i].base);\r\n}\r\n}\r\nprintk("...%p\n", &lp->tx_ring[i].base);\r\nprintk("\nDescriptor buffers (Device):\nRX: ");\r\nfor (i = 0; i < lp->rxRingMask; i++) {\r\nif (i < 3) {\r\nprintk("0x%8.8x ", readl(&lp->rx_ring[i].base));\r\n}\r\n}\r\nprintk("...0x%8.8x\n", readl(&lp->rx_ring[i].base));\r\nprintk("TX: ");\r\nfor (i = 0; i < lp->txRingMask; i++) {\r\nif (i < 3) {\r\nprintk("0x%8.8x ", readl(&lp->tx_ring[i].base));\r\n}\r\n}\r\nprintk("...0x%8.8x\n", readl(&lp->tx_ring[i].base));\r\nprintk("Initialisation block at 0x%8.8lx(Phys)\n", lp->mem_start);\r\nprintk(" mode: 0x%4.4x\n", p->mode);\r\nprintk(" physical address: %pM\n", p->phys_addr);\r\nprintk(" multicast hash table: ");\r\nfor (i = 0; i < (HASH_TABLE_LEN >> 3) - 1; i++) {\r\nprintk("%2.2x:", p->mcast_table[i]);\r\n}\r\nprintk("%2.2x\n", p->mcast_table[i]);\r\nprintk(" rx_ring at: 0x%8.8x\n", p->rx_ring);\r\nprintk(" tx_ring at: 0x%8.8x\n", p->tx_ring);\r\nprintk("buffers (Phys): 0x%8.8lx\n", lp->mem_start + lp->buffs_offset);\r\nprintk("Ring size:\nRX: %d Log2(rxRingMask): 0x%8.8x\n", (int) lp->rxRingMask + 1, lp->rx_rlen);\r\nprintk("TX: %d Log2(txRingMask): 0x%8.8x\n", (int) lp->txRingMask + 1, lp->tx_rlen);\r\noutw(CSR2, DEPCA_ADDR);\r\nprintk("CSR2&1: 0x%4.4x", inw(DEPCA_DATA));\r\noutw(CSR1, DEPCA_ADDR);\r\nprintk("%4.4x\n", inw(DEPCA_DATA));\r\noutw(CSR3, DEPCA_ADDR);\r\nprintk("CSR3: 0x%4.4x\n", inw(DEPCA_DATA));\r\n}\r\n}\r\nstatic int depca_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct depca_private *lp = netdev_priv(dev);\r\nstruct depca_ioctl *ioc = (struct depca_ioctl *) &rq->ifr_ifru;\r\nint i, status = 0;\r\nu_long ioaddr = dev->base_addr;\r\nunion {\r\nu8 addr[(HASH_TABLE_LEN * ETH_ALEN)];\r\nu16 sval[(HASH_TABLE_LEN * ETH_ALEN) >> 1];\r\nu32 lval[(HASH_TABLE_LEN * ETH_ALEN) >> 2];\r\n} tmp;\r\nunsigned long flags;\r\nvoid *buf;\r\nswitch (ioc->cmd) {\r\ncase DEPCA_GET_HWADDR:\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\ntmp.addr[i] = dev->dev_addr[i];\r\n}\r\nioc->len = ETH_ALEN;\r\nif (copy_to_user(ioc->data, tmp.addr, ioc->len))\r\nreturn -EFAULT;\r\nbreak;\r\ncase DEPCA_SET_HWADDR:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(tmp.addr, ioc->data, ETH_ALEN))\r\nreturn -EFAULT;\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\ndev->dev_addr[i] = tmp.addr[i];\r\n}\r\nnetif_stop_queue(dev);\r\nwhile (lp->tx_old != lp->tx_new)\r\ncpu_relax();\r\nSTOP_DEPCA;\r\ndepca_init_ring(dev);\r\nLoadCSRs(dev);\r\nInitRestartDepca(dev);\r\nnetif_start_queue(dev);\r\nbreak;\r\ncase DEPCA_SET_PROM:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nnetif_stop_queue(dev);\r\nwhile (lp->tx_old != lp->tx_new)\r\ncpu_relax();\r\nSTOP_DEPCA;\r\ndepca_init_ring(dev);\r\nlp->init_block.mode |= PROM;\r\nLoadCSRs(dev);\r\nInitRestartDepca(dev);\r\nnetif_start_queue(dev);\r\nbreak;\r\ncase DEPCA_CLR_PROM:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nnetif_stop_queue(dev);\r\nwhile (lp->tx_old != lp->tx_new)\r\ncpu_relax();\r\nSTOP_DEPCA;\r\ndepca_init_ring(dev);\r\nlp->init_block.mode &= ~PROM;\r\nLoadCSRs(dev);\r\nInitRestartDepca(dev);\r\nnetif_start_queue(dev);\r\nbreak;\r\ncase DEPCA_SAY_BOO:\r\nif(!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nprintk("%s: Boo!\n", dev->name);\r\nbreak;\r\ncase DEPCA_GET_MCA:\r\nioc->len = (HASH_TABLE_LEN >> 3);\r\nif (copy_to_user(ioc->data, lp->init_block.mcast_table, ioc->len))\r\nreturn -EFAULT;\r\nbreak;\r\ncase DEPCA_SET_MCA:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (ioc->len >= HASH_TABLE_LEN)\r\nreturn -EINVAL;\r\nif (copy_from_user(tmp.addr, ioc->data, ETH_ALEN * ioc->len))\r\nreturn -EFAULT;\r\nset_multicast_list(dev);\r\nbreak;\r\ncase DEPCA_CLR_MCA:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nset_multicast_list(dev);\r\nbreak;\r\ncase DEPCA_MCA_EN:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nset_multicast_list(dev);\r\nbreak;\r\ncase DEPCA_GET_STATS:\r\nioc->len = sizeof(lp->pktStats);\r\nbuf = kmalloc(ioc->len, GFP_KERNEL);\r\nif(!buf)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nmemcpy(buf, &lp->pktStats, ioc->len);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nif (copy_to_user(ioc->data, buf, ioc->len))\r\nstatus = -EFAULT;\r\nkfree(buf);\r\nbreak;\r\ncase DEPCA_CLR_STATS:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nmemset(&lp->pktStats, 0, sizeof(lp->pktStats));\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nbreak;\r\ncase DEPCA_GET_REG:\r\ni = 0;\r\ntmp.sval[i++] = inw(DEPCA_NICSR);\r\noutw(CSR0, DEPCA_ADDR);\r\ntmp.sval[i++] = inw(DEPCA_DATA);\r\nmemcpy(&tmp.sval[i], &lp->init_block, sizeof(struct depca_init));\r\nioc->len = i + sizeof(struct depca_init);\r\nif (copy_to_user(ioc->data, tmp.addr, ioc->len))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn status;\r\n}\r\nstatic int __init depca_module_init (void)\r\n{\r\nint err = 0;\r\n#ifdef CONFIG_MCA\r\nerr = mca_register_driver(&depca_mca_driver);\r\nif (err)\r\ngoto err;\r\n#endif\r\n#ifdef CONFIG_EISA\r\nerr = eisa_driver_register(&depca_eisa_driver);\r\nif (err)\r\ngoto err_mca;\r\n#endif\r\nerr = platform_driver_register(&depca_isa_driver);\r\nif (err)\r\ngoto err_eisa;\r\ndepca_platform_probe();\r\nreturn 0;\r\nerr_eisa:\r\n#ifdef CONFIG_EISA\r\neisa_driver_unregister(&depca_eisa_driver);\r\nerr_mca:\r\n#endif\r\n#ifdef CONFIG_MCA\r\nmca_unregister_driver(&depca_mca_driver);\r\nerr:\r\n#endif\r\nreturn err;\r\n}\r\nstatic void __exit depca_module_exit (void)\r\n{\r\nint i;\r\n#ifdef CONFIG_MCA\r\nmca_unregister_driver (&depca_mca_driver);\r\n#endif\r\n#ifdef CONFIG_EISA\r\neisa_driver_unregister (&depca_eisa_driver);\r\n#endif\r\nplatform_driver_unregister (&depca_isa_driver);\r\nfor (i = 0; depca_io_ports[i].iobase; i++) {\r\nif (depca_io_ports[i].device) {\r\ndepca_io_ports[i].device->dev.platform_data = NULL;\r\nplatform_device_unregister (depca_io_ports[i].device);\r\ndepca_io_ports[i].device = NULL;\r\n}\r\n}\r\n}
