static void\r\nlcs_unregister_debug_facility(void)\r\n{\r\nif (lcs_dbf_setup)\r\ndebug_unregister(lcs_dbf_setup);\r\nif (lcs_dbf_trace)\r\ndebug_unregister(lcs_dbf_trace);\r\n}\r\nstatic int\r\nlcs_register_debug_facility(void)\r\n{\r\nlcs_dbf_setup = debug_register("lcs_setup", 2, 1, 8);\r\nlcs_dbf_trace = debug_register("lcs_trace", 4, 1, 8);\r\nif (lcs_dbf_setup == NULL || lcs_dbf_trace == NULL) {\r\npr_err("Not enough memory for debug facility.\n");\r\nlcs_unregister_debug_facility();\r\nreturn -ENOMEM;\r\n}\r\ndebug_register_view(lcs_dbf_setup, &debug_hex_ascii_view);\r\ndebug_set_level(lcs_dbf_setup, 2);\r\ndebug_register_view(lcs_dbf_trace, &debug_hex_ascii_view);\r\ndebug_set_level(lcs_dbf_trace, 2);\r\nreturn 0;\r\n}\r\nstatic int\r\nlcs_alloc_channel(struct lcs_channel *channel)\r\n{\r\nint cnt;\r\nLCS_DBF_TEXT(2, setup, "ichalloc");\r\nfor (cnt = 0; cnt < LCS_NUM_BUFFS; cnt++) {\r\nchannel->iob[cnt].data =\r\nkzalloc(LCS_IOBUFFERSIZE, GFP_DMA | GFP_KERNEL);\r\nif (channel->iob[cnt].data == NULL)\r\nbreak;\r\nchannel->iob[cnt].state = LCS_BUF_STATE_EMPTY;\r\n}\r\nif (cnt < LCS_NUM_BUFFS) {\r\nLCS_DBF_TEXT(2, setup, "echalloc");\r\nwhile (cnt-- > 0)\r\nkfree(channel->iob[cnt].data);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlcs_free_channel(struct lcs_channel *channel)\r\n{\r\nint cnt;\r\nLCS_DBF_TEXT(2, setup, "ichfree");\r\nfor (cnt = 0; cnt < LCS_NUM_BUFFS; cnt++) {\r\nkfree(channel->iob[cnt].data);\r\nchannel->iob[cnt].data = NULL;\r\n}\r\n}\r\nstatic void\r\nlcs_cleanup_channel(struct lcs_channel *channel)\r\n{\r\nLCS_DBF_TEXT(3, setup, "cleanch");\r\ntasklet_kill(&channel->irq_tasklet);\r\nlcs_free_channel(channel);\r\n}\r\nstatic void\r\nlcs_free_card(struct lcs_card *card)\r\n{\r\nLCS_DBF_TEXT(2, setup, "remcard");\r\nLCS_DBF_HEX(2, setup, &card, sizeof(void*));\r\nkfree(card);\r\n}\r\nstatic struct lcs_card *\r\nlcs_alloc_card(void)\r\n{\r\nstruct lcs_card *card;\r\nint rc;\r\nLCS_DBF_TEXT(2, setup, "alloclcs");\r\ncard = kzalloc(sizeof(struct lcs_card), GFP_KERNEL | GFP_DMA);\r\nif (card == NULL)\r\nreturn NULL;\r\ncard->lan_type = LCS_FRAME_TYPE_AUTO;\r\ncard->pkt_seq = 0;\r\ncard->lancmd_timeout = LCS_LANCMD_TIMEOUT_DEFAULT;\r\nrc = lcs_alloc_channel(&card->read);\r\nif (rc){\r\nLCS_DBF_TEXT(2, setup, "iccwerr");\r\nlcs_free_card(card);\r\nreturn NULL;\r\n}\r\nrc = lcs_alloc_channel(&card->write);\r\nif (rc) {\r\nLCS_DBF_TEXT(2, setup, "iccwerr");\r\nlcs_cleanup_channel(&card->read);\r\nlcs_free_card(card);\r\nreturn NULL;\r\n}\r\n#ifdef CONFIG_IP_MULTICAST\r\nINIT_LIST_HEAD(&card->ipm_list);\r\n#endif\r\nLCS_DBF_HEX(2, setup, &card, sizeof(void*));\r\nreturn card;\r\n}\r\nstatic void\r\nlcs_setup_read_ccws(struct lcs_card *card)\r\n{\r\nint cnt;\r\nLCS_DBF_TEXT(2, setup, "ireadccw");\r\nmemset(card->read.ccws, 0, sizeof (struct ccw1) * (LCS_NUM_BUFFS + 1));\r\nfor (cnt = 0; cnt < LCS_NUM_BUFFS; cnt++) {\r\ncard->read.ccws[cnt].cmd_code = LCS_CCW_READ;\r\ncard->read.ccws[cnt].count = LCS_IOBUFFERSIZE;\r\ncard->read.ccws[cnt].flags =\r\nCCW_FLAG_CC | CCW_FLAG_SLI | CCW_FLAG_PCI;\r\ncard->read.ccws[cnt].cda =\r\n(__u32) __pa(card->read.iob[cnt].data);\r\n((struct lcs_header *)\r\ncard->read.iob[cnt].data)->offset = LCS_ILLEGAL_OFFSET;\r\ncard->read.iob[cnt].callback = lcs_get_frames_cb;\r\ncard->read.iob[cnt].state = LCS_BUF_STATE_READY;\r\ncard->read.iob[cnt].count = LCS_IOBUFFERSIZE;\r\n}\r\ncard->read.ccws[0].flags &= ~CCW_FLAG_PCI;\r\ncard->read.ccws[LCS_NUM_BUFFS - 1].flags &= ~CCW_FLAG_PCI;\r\ncard->read.ccws[LCS_NUM_BUFFS - 1].flags |= CCW_FLAG_SUSPEND;\r\ncard->read.ccws[LCS_NUM_BUFFS].cmd_code = LCS_CCW_TRANSFER;\r\ncard->read.ccws[LCS_NUM_BUFFS].cda =\r\n(__u32) __pa(card->read.ccws);\r\ncard->read.state = LCS_CH_STATE_INIT;\r\ncard->read.io_idx = 0;\r\ncard->read.buf_idx = 0;\r\n}\r\nstatic void\r\nlcs_setup_read(struct lcs_card *card)\r\n{\r\nLCS_DBF_TEXT(3, setup, "initread");\r\nlcs_setup_read_ccws(card);\r\ncard->read.irq_tasklet.data = (unsigned long) &card->read;\r\ncard->read.irq_tasklet.func = lcs_tasklet;\r\ninit_waitqueue_head(&card->read.wait_q);\r\n}\r\nstatic void\r\nlcs_setup_write_ccws(struct lcs_card *card)\r\n{\r\nint cnt;\r\nLCS_DBF_TEXT(3, setup, "iwritccw");\r\nmemset(card->write.ccws, 0, sizeof(struct ccw1) * LCS_NUM_BUFFS + 1);\r\nfor (cnt = 0; cnt < LCS_NUM_BUFFS; cnt++) {\r\ncard->write.ccws[cnt].cmd_code = LCS_CCW_WRITE;\r\ncard->write.ccws[cnt].count = 0;\r\ncard->write.ccws[cnt].flags =\r\nCCW_FLAG_SUSPEND | CCW_FLAG_CC | CCW_FLAG_SLI;\r\ncard->write.ccws[cnt].cda =\r\n(__u32) __pa(card->write.iob[cnt].data);\r\n}\r\ncard->write.ccws[LCS_NUM_BUFFS].cmd_code = LCS_CCW_TRANSFER;\r\ncard->write.ccws[LCS_NUM_BUFFS].cda =\r\n(__u32) __pa(card->write.ccws);\r\ncard->read.state = LCS_CH_STATE_INIT;\r\ncard->write.io_idx = 0;\r\ncard->write.buf_idx = 0;\r\n}\r\nstatic void\r\nlcs_setup_write(struct lcs_card *card)\r\n{\r\nLCS_DBF_TEXT(3, setup, "initwrit");\r\nlcs_setup_write_ccws(card);\r\ncard->write.irq_tasklet.data = (unsigned long) &card->write;\r\ncard->write.irq_tasklet.func = lcs_tasklet;\r\ninit_waitqueue_head(&card->write.wait_q);\r\n}\r\nstatic void\r\nlcs_set_allowed_threads(struct lcs_card *card, unsigned long threads)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->mask_lock, flags);\r\ncard->thread_allowed_mask = threads;\r\nspin_unlock_irqrestore(&card->mask_lock, flags);\r\nwake_up(&card->wait_q);\r\n}\r\nstatic inline int\r\nlcs_threads_running(struct lcs_card *card, unsigned long threads)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave(&card->mask_lock, flags);\r\nrc = (card->thread_running_mask & threads);\r\nspin_unlock_irqrestore(&card->mask_lock, flags);\r\nreturn rc;\r\n}\r\nstatic int\r\nlcs_wait_for_threads(struct lcs_card *card, unsigned long threads)\r\n{\r\nreturn wait_event_interruptible(card->wait_q,\r\nlcs_threads_running(card, threads) == 0);\r\n}\r\nstatic inline int\r\nlcs_set_thread_start_bit(struct lcs_card *card, unsigned long thread)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->mask_lock, flags);\r\nif ( !(card->thread_allowed_mask & thread) ||\r\n(card->thread_start_mask & thread) ) {\r\nspin_unlock_irqrestore(&card->mask_lock, flags);\r\nreturn -EPERM;\r\n}\r\ncard->thread_start_mask |= thread;\r\nspin_unlock_irqrestore(&card->mask_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void\r\nlcs_clear_thread_running_bit(struct lcs_card *card, unsigned long thread)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->mask_lock, flags);\r\ncard->thread_running_mask &= ~thread;\r\nspin_unlock_irqrestore(&card->mask_lock, flags);\r\nwake_up(&card->wait_q);\r\n}\r\nstatic inline int\r\n__lcs_do_run_thread(struct lcs_card *card, unsigned long thread)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave(&card->mask_lock, flags);\r\nif (card->thread_start_mask & thread){\r\nif ((card->thread_allowed_mask & thread) &&\r\n!(card->thread_running_mask & thread)){\r\nrc = 1;\r\ncard->thread_start_mask &= ~thread;\r\ncard->thread_running_mask |= thread;\r\n} else\r\nrc = -EPERM;\r\n}\r\nspin_unlock_irqrestore(&card->mask_lock, flags);\r\nreturn rc;\r\n}\r\nstatic int\r\nlcs_do_run_thread(struct lcs_card *card, unsigned long thread)\r\n{\r\nint rc = 0;\r\nwait_event(card->wait_q,\r\n(rc = __lcs_do_run_thread(card, thread)) >= 0);\r\nreturn rc;\r\n}\r\nstatic int\r\nlcs_do_start_thread(struct lcs_card *card, unsigned long thread)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave(&card->mask_lock, flags);\r\nLCS_DBF_TEXT_(4, trace, " %02x%02x%02x",\r\n(u8) card->thread_start_mask,\r\n(u8) card->thread_allowed_mask,\r\n(u8) card->thread_running_mask);\r\nrc = (card->thread_start_mask & thread);\r\nspin_unlock_irqrestore(&card->mask_lock, flags);\r\nreturn rc;\r\n}\r\nstatic void\r\nlcs_setup_card(struct lcs_card *card)\r\n{\r\nLCS_DBF_TEXT(2, setup, "initcard");\r\nLCS_DBF_HEX(2, setup, &card, sizeof(void*));\r\nlcs_setup_read(card);\r\nlcs_setup_write(card);\r\ncard->state = DEV_STATE_DOWN;\r\ncard->tx_buffer = NULL;\r\ncard->tx_emitted = 0;\r\ninit_waitqueue_head(&card->wait_q);\r\nspin_lock_init(&card->lock);\r\nspin_lock_init(&card->ipm_lock);\r\nspin_lock_init(&card->mask_lock);\r\n#ifdef CONFIG_IP_MULTICAST\r\nINIT_LIST_HEAD(&card->ipm_list);\r\n#endif\r\nINIT_LIST_HEAD(&card->lancmd_waiters);\r\n}\r\nstatic inline void\r\nlcs_clear_multicast_list(struct lcs_card *card)\r\n{\r\n#ifdef CONFIG_IP_MULTICAST\r\nstruct lcs_ipm_list *ipm;\r\nunsigned long flags;\r\nLCS_DBF_TEXT(3, setup, "clmclist");\r\nspin_lock_irqsave(&card->ipm_lock, flags);\r\nwhile (!list_empty(&card->ipm_list)){\r\nipm = list_entry(card->ipm_list.next,\r\nstruct lcs_ipm_list, list);\r\nlist_del(&ipm->list);\r\nif (ipm->ipm_state != LCS_IPM_STATE_SET_REQUIRED){\r\nspin_unlock_irqrestore(&card->ipm_lock, flags);\r\nlcs_send_delipm(card, ipm);\r\nspin_lock_irqsave(&card->ipm_lock, flags);\r\n}\r\nkfree(ipm);\r\n}\r\nspin_unlock_irqrestore(&card->ipm_lock, flags);\r\n#endif\r\n}\r\nstatic void\r\nlcs_cleanup_card(struct lcs_card *card)\r\n{\r\nLCS_DBF_TEXT(3, setup, "cleancrd");\r\nLCS_DBF_HEX(2,setup,&card,sizeof(void*));\r\nif (card->dev != NULL)\r\nfree_netdev(card->dev);\r\nlcs_cleanup_channel(&card->write);\r\nlcs_cleanup_channel(&card->read);\r\n}\r\nstatic int\r\nlcs_start_channel(struct lcs_channel *channel)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nLCS_DBF_TEXT_(4, trace,"ssch%s", dev_name(&channel->ccwdev->dev));\r\nspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\r\nrc = ccw_device_start(channel->ccwdev,\r\nchannel->ccws + channel->io_idx, 0, 0,\r\nDOIO_DENY_PREFETCH | DOIO_ALLOW_SUSPEND);\r\nif (rc == 0)\r\nchannel->state = LCS_CH_STATE_RUNNING;\r\nspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\r\nif (rc) {\r\nLCS_DBF_TEXT_(4,trace,"essh%s",\r\ndev_name(&channel->ccwdev->dev));\r\ndev_err(&channel->ccwdev->dev,\r\n"Starting an LCS device resulted in an error,"\r\n" rc=%d!\n", rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nlcs_clear_channel(struct lcs_channel *channel)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nLCS_DBF_TEXT(4,trace,"clearch");\r\nLCS_DBF_TEXT_(4, trace, "%s", dev_name(&channel->ccwdev->dev));\r\nspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\r\nrc = ccw_device_clear(channel->ccwdev, (addr_t) channel);\r\nspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\r\nif (rc) {\r\nLCS_DBF_TEXT_(4, trace, "ecsc%s",\r\ndev_name(&channel->ccwdev->dev));\r\nreturn rc;\r\n}\r\nwait_event(channel->wait_q, (channel->state == LCS_CH_STATE_CLEARED));\r\nchannel->state = LCS_CH_STATE_STOPPED;\r\nreturn rc;\r\n}\r\nstatic int\r\nlcs_stop_channel(struct lcs_channel *channel)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nif (channel->state == LCS_CH_STATE_STOPPED)\r\nreturn 0;\r\nLCS_DBF_TEXT(4,trace,"haltsch");\r\nLCS_DBF_TEXT_(4, trace, "%s", dev_name(&channel->ccwdev->dev));\r\nchannel->state = LCS_CH_STATE_INIT;\r\nspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\r\nrc = ccw_device_halt(channel->ccwdev, (addr_t) channel);\r\nspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\r\nif (rc) {\r\nLCS_DBF_TEXT_(4, trace, "ehsc%s",\r\ndev_name(&channel->ccwdev->dev));\r\nreturn rc;\r\n}\r\nwait_event(channel->wait_q, (channel->state == LCS_CH_STATE_HALTED));\r\nlcs_clear_channel(channel);\r\nreturn 0;\r\n}\r\nstatic int\r\nlcs_start_channels(struct lcs_card *card)\r\n{\r\nint rc;\r\nLCS_DBF_TEXT(2, trace, "chstart");\r\nrc = lcs_start_channel(&card->read);\r\nif (rc)\r\nreturn rc;\r\nrc = lcs_start_channel(&card->write);\r\nif (rc)\r\nlcs_stop_channel(&card->read);\r\nreturn rc;\r\n}\r\nstatic int\r\nlcs_stop_channels(struct lcs_card *card)\r\n{\r\nLCS_DBF_TEXT(2, trace, "chhalt");\r\nlcs_stop_channel(&card->read);\r\nlcs_stop_channel(&card->write);\r\nreturn 0;\r\n}\r\nstatic struct lcs_buffer *\r\n__lcs_get_buffer(struct lcs_channel *channel)\r\n{\r\nint index;\r\nLCS_DBF_TEXT(5, trace, "_getbuff");\r\nindex = channel->io_idx;\r\ndo {\r\nif (channel->iob[index].state == LCS_BUF_STATE_EMPTY) {\r\nchannel->iob[index].state = LCS_BUF_STATE_LOCKED;\r\nreturn channel->iob + index;\r\n}\r\nindex = (index + 1) & (LCS_NUM_BUFFS - 1);\r\n} while (index != channel->io_idx);\r\nreturn NULL;\r\n}\r\nstatic struct lcs_buffer *\r\nlcs_get_buffer(struct lcs_channel *channel)\r\n{\r\nstruct lcs_buffer *buffer;\r\nunsigned long flags;\r\nLCS_DBF_TEXT(5, trace, "getbuff");\r\nspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\r\nbuffer = __lcs_get_buffer(channel);\r\nspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\r\nreturn buffer;\r\n}\r\nstatic int\r\n__lcs_resume_channel(struct lcs_channel *channel)\r\n{\r\nint rc;\r\nif (channel->state != LCS_CH_STATE_SUSPENDED)\r\nreturn 0;\r\nif (channel->ccws[channel->io_idx].flags & CCW_FLAG_SUSPEND)\r\nreturn 0;\r\nLCS_DBF_TEXT_(5, trace, "rsch%s", dev_name(&channel->ccwdev->dev));\r\nrc = ccw_device_resume(channel->ccwdev);\r\nif (rc) {\r\nLCS_DBF_TEXT_(4, trace, "ersc%s",\r\ndev_name(&channel->ccwdev->dev));\r\ndev_err(&channel->ccwdev->dev,\r\n"Sending data from the LCS device to the LAN failed"\r\n" with rc=%d\n",rc);\r\n} else\r\nchannel->state = LCS_CH_STATE_RUNNING;\r\nreturn rc;\r\n}\r\nstatic inline void\r\n__lcs_ready_buffer_bits(struct lcs_channel *channel, int index)\r\n{\r\nint prev, next;\r\nLCS_DBF_TEXT(5, trace, "rdybits");\r\nprev = (index - 1) & (LCS_NUM_BUFFS - 1);\r\nnext = (index + 1) & (LCS_NUM_BUFFS - 1);\r\nif (channel->ccws[next].flags & CCW_FLAG_SUSPEND) {\r\nif (!(channel->ccws[prev].flags & CCW_FLAG_SUSPEND))\r\nchannel->ccws[index].flags |= CCW_FLAG_PCI;\r\nchannel->ccws[index].flags &= ~CCW_FLAG_SUSPEND;\r\n}\r\n}\r\nstatic int\r\nlcs_ready_buffer(struct lcs_channel *channel, struct lcs_buffer *buffer)\r\n{\r\nunsigned long flags;\r\nint index, rc;\r\nLCS_DBF_TEXT(5, trace, "rdybuff");\r\nBUG_ON(buffer->state != LCS_BUF_STATE_LOCKED &&\r\nbuffer->state != LCS_BUF_STATE_PROCESSED);\r\nspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\r\nbuffer->state = LCS_BUF_STATE_READY;\r\nindex = buffer - channel->iob;\r\nchannel->ccws[index].count = buffer->count;\r\n__lcs_ready_buffer_bits(channel, index);\r\nrc = __lcs_resume_channel(channel);\r\nspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\r\nreturn rc;\r\n}\r\nstatic int\r\n__lcs_processed_buffer(struct lcs_channel *channel, struct lcs_buffer *buffer)\r\n{\r\nint index, prev, next;\r\nLCS_DBF_TEXT(5, trace, "prcsbuff");\r\nBUG_ON(buffer->state != LCS_BUF_STATE_READY);\r\nbuffer->state = LCS_BUF_STATE_PROCESSED;\r\nindex = buffer - channel->iob;\r\nprev = (index - 1) & (LCS_NUM_BUFFS - 1);\r\nnext = (index + 1) & (LCS_NUM_BUFFS - 1);\r\nchannel->ccws[index].flags |= CCW_FLAG_SUSPEND;\r\nchannel->ccws[index].flags &= ~CCW_FLAG_PCI;\r\nif (channel->iob[prev].state == LCS_BUF_STATE_READY) {\r\n__lcs_ready_buffer_bits(channel, prev);\r\n}\r\nchannel->ccws[next].flags &= ~CCW_FLAG_PCI;\r\nreturn __lcs_resume_channel(channel);\r\n}\r\nstatic void\r\nlcs_release_buffer(struct lcs_channel *channel, struct lcs_buffer *buffer)\r\n{\r\nunsigned long flags;\r\nLCS_DBF_TEXT(5, trace, "relbuff");\r\nBUG_ON(buffer->state != LCS_BUF_STATE_LOCKED &&\r\nbuffer->state != LCS_BUF_STATE_PROCESSED);\r\nspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\r\nbuffer->state = LCS_BUF_STATE_EMPTY;\r\nspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\r\n}\r\nstatic struct lcs_buffer *\r\nlcs_get_lancmd(struct lcs_card *card, int count)\r\n{\r\nstruct lcs_buffer *buffer;\r\nstruct lcs_cmd *cmd;\r\nLCS_DBF_TEXT(4, trace, "getlncmd");\r\nwait_event(card->write.wait_q,\r\n((buffer = lcs_get_buffer(&card->write)) != NULL));\r\ncount += sizeof(struct lcs_header);\r\n*(__u16 *)(buffer->data + count) = 0;\r\nbuffer->count = count + sizeof(__u16);\r\nbuffer->callback = lcs_release_buffer;\r\ncmd = (struct lcs_cmd *) buffer->data;\r\ncmd->offset = count;\r\ncmd->type = LCS_FRAME_TYPE_CONTROL;\r\ncmd->slot = 0;\r\nreturn buffer;\r\n}\r\nstatic void\r\nlcs_get_reply(struct lcs_reply *reply)\r\n{\r\nWARN_ON(atomic_read(&reply->refcnt) <= 0);\r\natomic_inc(&reply->refcnt);\r\n}\r\nstatic void\r\nlcs_put_reply(struct lcs_reply *reply)\r\n{\r\nWARN_ON(atomic_read(&reply->refcnt) <= 0);\r\nif (atomic_dec_and_test(&reply->refcnt)) {\r\nkfree(reply);\r\n}\r\n}\r\nstatic struct lcs_reply *\r\nlcs_alloc_reply(struct lcs_cmd *cmd)\r\n{\r\nstruct lcs_reply *reply;\r\nLCS_DBF_TEXT(4, trace, "getreply");\r\nreply = kzalloc(sizeof(struct lcs_reply), GFP_ATOMIC);\r\nif (!reply)\r\nreturn NULL;\r\natomic_set(&reply->refcnt,1);\r\nreply->sequence_no = cmd->sequence_no;\r\nreply->received = 0;\r\nreply->rc = 0;\r\ninit_waitqueue_head(&reply->wait_q);\r\nreturn reply;\r\n}\r\nstatic void\r\nlcs_notify_lancmd_waiters(struct lcs_card *card, struct lcs_cmd *cmd)\r\n{\r\nstruct list_head *l, *n;\r\nstruct lcs_reply *reply;\r\nLCS_DBF_TEXT(4, trace, "notiwait");\r\nspin_lock(&card->lock);\r\nlist_for_each_safe(l, n, &card->lancmd_waiters) {\r\nreply = list_entry(l, struct lcs_reply, list);\r\nif (reply->sequence_no == cmd->sequence_no) {\r\nlcs_get_reply(reply);\r\nlist_del_init(&reply->list);\r\nif (reply->callback != NULL)\r\nreply->callback(card, cmd);\r\nreply->received = 1;\r\nreply->rc = cmd->return_code;\r\nwake_up(&reply->wait_q);\r\nlcs_put_reply(reply);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&card->lock);\r\n}\r\nstatic void\r\nlcs_lancmd_timeout(unsigned long data)\r\n{\r\nstruct lcs_reply *reply, *list_reply, *r;\r\nunsigned long flags;\r\nLCS_DBF_TEXT(4, trace, "timeout");\r\nreply = (struct lcs_reply *) data;\r\nspin_lock_irqsave(&reply->card->lock, flags);\r\nlist_for_each_entry_safe(list_reply, r,\r\n&reply->card->lancmd_waiters,list) {\r\nif (reply == list_reply) {\r\nlcs_get_reply(reply);\r\nlist_del_init(&reply->list);\r\nspin_unlock_irqrestore(&reply->card->lock, flags);\r\nreply->received = 1;\r\nreply->rc = -ETIME;\r\nwake_up(&reply->wait_q);\r\nlcs_put_reply(reply);\r\nreturn;\r\n}\r\n}\r\nspin_unlock_irqrestore(&reply->card->lock, flags);\r\n}\r\nstatic int\r\nlcs_send_lancmd(struct lcs_card *card, struct lcs_buffer *buffer,\r\nvoid (*reply_callback)(struct lcs_card *, struct lcs_cmd *))\r\n{\r\nstruct lcs_reply *reply;\r\nstruct lcs_cmd *cmd;\r\nstruct timer_list timer;\r\nunsigned long flags;\r\nint rc;\r\nLCS_DBF_TEXT(4, trace, "sendcmd");\r\ncmd = (struct lcs_cmd *) buffer->data;\r\ncmd->return_code = 0;\r\ncmd->sequence_no = card->sequence_no++;\r\nreply = lcs_alloc_reply(cmd);\r\nif (!reply)\r\nreturn -ENOMEM;\r\nreply->callback = reply_callback;\r\nreply->card = card;\r\nspin_lock_irqsave(&card->lock, flags);\r\nlist_add_tail(&reply->list, &card->lancmd_waiters);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nbuffer->callback = lcs_release_buffer;\r\nrc = lcs_ready_buffer(&card->write, buffer);\r\nif (rc)\r\nreturn rc;\r\ninit_timer_on_stack(&timer);\r\ntimer.function = lcs_lancmd_timeout;\r\ntimer.data = (unsigned long) reply;\r\ntimer.expires = jiffies + HZ*card->lancmd_timeout;\r\nadd_timer(&timer);\r\nwait_event(reply->wait_q, reply->received);\r\ndel_timer_sync(&timer);\r\nLCS_DBF_TEXT_(4, trace, "rc:%d",reply->rc);\r\nrc = reply->rc;\r\nlcs_put_reply(reply);\r\nreturn rc ? -EIO : 0;\r\n}\r\nstatic int\r\nlcs_send_startup(struct lcs_card *card, __u8 initiator)\r\n{\r\nstruct lcs_buffer *buffer;\r\nstruct lcs_cmd *cmd;\r\nLCS_DBF_TEXT(2, trace, "startup");\r\nbuffer = lcs_get_lancmd(card, LCS_STD_CMD_SIZE);\r\ncmd = (struct lcs_cmd *) buffer->data;\r\ncmd->cmd_code = LCS_CMD_STARTUP;\r\ncmd->initiator = initiator;\r\ncmd->cmd.lcs_startup.buff_size = LCS_IOBUFFERSIZE;\r\nreturn lcs_send_lancmd(card, buffer, NULL);\r\n}\r\nstatic int\r\nlcs_send_shutdown(struct lcs_card *card)\r\n{\r\nstruct lcs_buffer *buffer;\r\nstruct lcs_cmd *cmd;\r\nLCS_DBF_TEXT(2, trace, "shutdown");\r\nbuffer = lcs_get_lancmd(card, LCS_STD_CMD_SIZE);\r\ncmd = (struct lcs_cmd *) buffer->data;\r\ncmd->cmd_code = LCS_CMD_SHUTDOWN;\r\ncmd->initiator = LCS_INITIATOR_TCPIP;\r\nreturn lcs_send_lancmd(card, buffer, NULL);\r\n}\r\nstatic void\r\n__lcs_lanstat_cb(struct lcs_card *card, struct lcs_cmd *cmd)\r\n{\r\nLCS_DBF_TEXT(2, trace, "statcb");\r\nmemcpy(card->mac, cmd->cmd.lcs_lanstat_cmd.mac_addr, LCS_MAC_LENGTH);\r\n}\r\nstatic int\r\nlcs_send_lanstat(struct lcs_card *card)\r\n{\r\nstruct lcs_buffer *buffer;\r\nstruct lcs_cmd *cmd;\r\nLCS_DBF_TEXT(2,trace, "cmdstat");\r\nbuffer = lcs_get_lancmd(card, LCS_STD_CMD_SIZE);\r\ncmd = (struct lcs_cmd *) buffer->data;\r\ncmd->cmd_code = LCS_CMD_LANSTAT;\r\ncmd->initiator = LCS_INITIATOR_TCPIP;\r\ncmd->cmd.lcs_std_cmd.lan_type = card->lan_type;\r\ncmd->cmd.lcs_std_cmd.portno = card->portno;\r\nreturn lcs_send_lancmd(card, buffer, __lcs_lanstat_cb);\r\n}\r\nstatic int\r\nlcs_send_stoplan(struct lcs_card *card, __u8 initiator)\r\n{\r\nstruct lcs_buffer *buffer;\r\nstruct lcs_cmd *cmd;\r\nLCS_DBF_TEXT(2, trace, "cmdstpln");\r\nbuffer = lcs_get_lancmd(card, LCS_STD_CMD_SIZE);\r\ncmd = (struct lcs_cmd *) buffer->data;\r\ncmd->cmd_code = LCS_CMD_STOPLAN;\r\ncmd->initiator = initiator;\r\ncmd->cmd.lcs_std_cmd.lan_type = card->lan_type;\r\ncmd->cmd.lcs_std_cmd.portno = card->portno;\r\nreturn lcs_send_lancmd(card, buffer, NULL);\r\n}\r\nstatic void\r\n__lcs_send_startlan_cb(struct lcs_card *card, struct lcs_cmd *cmd)\r\n{\r\nLCS_DBF_TEXT(2, trace, "srtlancb");\r\ncard->lan_type = cmd->cmd.lcs_std_cmd.lan_type;\r\ncard->portno = cmd->cmd.lcs_std_cmd.portno;\r\n}\r\nstatic int\r\nlcs_send_startlan(struct lcs_card *card, __u8 initiator)\r\n{\r\nstruct lcs_buffer *buffer;\r\nstruct lcs_cmd *cmd;\r\nLCS_DBF_TEXT(2, trace, "cmdstaln");\r\nbuffer = lcs_get_lancmd(card, LCS_STD_CMD_SIZE);\r\ncmd = (struct lcs_cmd *) buffer->data;\r\ncmd->cmd_code = LCS_CMD_STARTLAN;\r\ncmd->initiator = initiator;\r\ncmd->cmd.lcs_std_cmd.lan_type = card->lan_type;\r\ncmd->cmd.lcs_std_cmd.portno = card->portno;\r\nreturn lcs_send_lancmd(card, buffer, __lcs_send_startlan_cb);\r\n}\r\nstatic int\r\nlcs_send_setipm(struct lcs_card *card,struct lcs_ipm_list *ipm_list)\r\n{\r\nstruct lcs_buffer *buffer;\r\nstruct lcs_cmd *cmd;\r\nLCS_DBF_TEXT(2, trace, "cmdsetim");\r\nbuffer = lcs_get_lancmd(card, LCS_MULTICAST_CMD_SIZE);\r\ncmd = (struct lcs_cmd *) buffer->data;\r\ncmd->cmd_code = LCS_CMD_SETIPM;\r\ncmd->initiator = LCS_INITIATOR_TCPIP;\r\ncmd->cmd.lcs_qipassist.lan_type = card->lan_type;\r\ncmd->cmd.lcs_qipassist.portno = card->portno;\r\ncmd->cmd.lcs_qipassist.version = 4;\r\ncmd->cmd.lcs_qipassist.num_ip_pairs = 1;\r\nmemcpy(cmd->cmd.lcs_qipassist.lcs_ipass_ctlmsg.ip_mac_pair,\r\n&ipm_list->ipm, sizeof (struct lcs_ip_mac_pair));\r\nLCS_DBF_TEXT_(2, trace, "%x",ipm_list->ipm.ip_addr);\r\nreturn lcs_send_lancmd(card, buffer, NULL);\r\n}\r\nstatic int\r\nlcs_send_delipm(struct lcs_card *card,struct lcs_ipm_list *ipm_list)\r\n{\r\nstruct lcs_buffer *buffer;\r\nstruct lcs_cmd *cmd;\r\nLCS_DBF_TEXT(2, trace, "cmddelim");\r\nbuffer = lcs_get_lancmd(card, LCS_MULTICAST_CMD_SIZE);\r\ncmd = (struct lcs_cmd *) buffer->data;\r\ncmd->cmd_code = LCS_CMD_DELIPM;\r\ncmd->initiator = LCS_INITIATOR_TCPIP;\r\ncmd->cmd.lcs_qipassist.lan_type = card->lan_type;\r\ncmd->cmd.lcs_qipassist.portno = card->portno;\r\ncmd->cmd.lcs_qipassist.version = 4;\r\ncmd->cmd.lcs_qipassist.num_ip_pairs = 1;\r\nmemcpy(cmd->cmd.lcs_qipassist.lcs_ipass_ctlmsg.ip_mac_pair,\r\n&ipm_list->ipm, sizeof (struct lcs_ip_mac_pair));\r\nLCS_DBF_TEXT_(2, trace, "%x",ipm_list->ipm.ip_addr);\r\nreturn lcs_send_lancmd(card, buffer, NULL);\r\n}\r\nstatic void\r\n__lcs_check_multicast_cb(struct lcs_card *card, struct lcs_cmd *cmd)\r\n{\r\nLCS_DBF_TEXT(2, trace, "chkmccb");\r\ncard->ip_assists_supported =\r\ncmd->cmd.lcs_qipassist.ip_assists_supported;\r\ncard->ip_assists_enabled =\r\ncmd->cmd.lcs_qipassist.ip_assists_enabled;\r\n}\r\nstatic int\r\nlcs_check_multicast_support(struct lcs_card *card)\r\n{\r\nstruct lcs_buffer *buffer;\r\nstruct lcs_cmd *cmd;\r\nint rc;\r\nLCS_DBF_TEXT(2, trace, "cmdqipa");\r\nbuffer = lcs_get_lancmd(card, LCS_STD_CMD_SIZE);\r\ncmd = (struct lcs_cmd *) buffer->data;\r\ncmd->cmd_code = LCS_CMD_QIPASSIST;\r\ncmd->initiator = LCS_INITIATOR_TCPIP;\r\ncmd->cmd.lcs_qipassist.lan_type = card->lan_type;\r\ncmd->cmd.lcs_qipassist.portno = card->portno;\r\ncmd->cmd.lcs_qipassist.version = 4;\r\ncmd->cmd.lcs_qipassist.num_ip_pairs = 1;\r\nrc = lcs_send_lancmd(card, buffer, __lcs_check_multicast_cb);\r\nif (rc != 0) {\r\npr_err("Query IPAssist failed. Assuming unsupported!\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (card->ip_assists_supported & LCS_IPASS_MULTICAST_SUPPORT)\r\nreturn 0;\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void\r\nlcs_fix_multicast_list(struct lcs_card *card)\r\n{\r\nstruct list_head failed_list;\r\nstruct lcs_ipm_list *ipm, *tmp;\r\nunsigned long flags;\r\nint rc;\r\nLCS_DBF_TEXT(4,trace, "fixipm");\r\nINIT_LIST_HEAD(&failed_list);\r\nspin_lock_irqsave(&card->ipm_lock, flags);\r\nlist_modified:\r\nlist_for_each_entry_safe(ipm, tmp, &card->ipm_list, list){\r\nswitch (ipm->ipm_state) {\r\ncase LCS_IPM_STATE_SET_REQUIRED:\r\nlist_del_init(&ipm->list);\r\nspin_unlock_irqrestore(&card->ipm_lock, flags);\r\nrc = lcs_send_setipm(card, ipm);\r\nspin_lock_irqsave(&card->ipm_lock, flags);\r\nif (rc) {\r\npr_info("Adding multicast address failed."\r\n" Table possibly full!\n");\r\nlist_add_tail(&ipm->list, &failed_list);\r\n} else {\r\nipm->ipm_state = LCS_IPM_STATE_ON_CARD;\r\nlist_add_tail(&ipm->list, &card->ipm_list);\r\n}\r\ngoto list_modified;\r\ncase LCS_IPM_STATE_DEL_REQUIRED:\r\nlist_del(&ipm->list);\r\nspin_unlock_irqrestore(&card->ipm_lock, flags);\r\nlcs_send_delipm(card, ipm);\r\nspin_lock_irqsave(&card->ipm_lock, flags);\r\nkfree(ipm);\r\ngoto list_modified;\r\ncase LCS_IPM_STATE_ON_CARD:\r\nbreak;\r\n}\r\n}\r\nlist_for_each_entry_safe(ipm, tmp, &failed_list, list)\r\nlist_move_tail(&ipm->list, &card->ipm_list);\r\nspin_unlock_irqrestore(&card->ipm_lock, flags);\r\n}\r\nstatic void\r\nlcs_get_mac_for_ipm(__be32 ipm, char *mac, struct net_device *dev)\r\n{\r\nLCS_DBF_TEXT(4,trace, "getmac");\r\nif (dev->type == ARPHRD_IEEE802_TR)\r\nip_tr_mc_map(ipm, mac);\r\nelse\r\nip_eth_mc_map(ipm, mac);\r\n}\r\nstatic inline void\r\nlcs_remove_mc_addresses(struct lcs_card *card, struct in_device *in4_dev)\r\n{\r\nstruct ip_mc_list *im4;\r\nstruct list_head *l;\r\nstruct lcs_ipm_list *ipm;\r\nunsigned long flags;\r\nchar buf[MAX_ADDR_LEN];\r\nLCS_DBF_TEXT(4, trace, "remmclst");\r\nspin_lock_irqsave(&card->ipm_lock, flags);\r\nlist_for_each(l, &card->ipm_list) {\r\nipm = list_entry(l, struct lcs_ipm_list, list);\r\nfor (im4 = rcu_dereference(in4_dev->mc_list);\r\nim4 != NULL; im4 = rcu_dereference(im4->next_rcu)) {\r\nlcs_get_mac_for_ipm(im4->multiaddr, buf, card->dev);\r\nif ( (ipm->ipm.ip_addr == im4->multiaddr) &&\r\n(memcmp(buf, &ipm->ipm.mac_addr,\r\nLCS_MAC_LENGTH) == 0) )\r\nbreak;\r\n}\r\nif (im4 == NULL)\r\nipm->ipm_state = LCS_IPM_STATE_DEL_REQUIRED;\r\n}\r\nspin_unlock_irqrestore(&card->ipm_lock, flags);\r\n}\r\nstatic inline struct lcs_ipm_list *\r\nlcs_check_addr_entry(struct lcs_card *card, struct ip_mc_list *im4, char *buf)\r\n{\r\nstruct lcs_ipm_list *tmp, *ipm = NULL;\r\nstruct list_head *l;\r\nunsigned long flags;\r\nLCS_DBF_TEXT(4, trace, "chkmcent");\r\nspin_lock_irqsave(&card->ipm_lock, flags);\r\nlist_for_each(l, &card->ipm_list) {\r\ntmp = list_entry(l, struct lcs_ipm_list, list);\r\nif ( (tmp->ipm.ip_addr == im4->multiaddr) &&\r\n(memcmp(buf, &tmp->ipm.mac_addr,\r\nLCS_MAC_LENGTH) == 0) ) {\r\nipm = tmp;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&card->ipm_lock, flags);\r\nreturn ipm;\r\n}\r\nstatic inline void\r\nlcs_set_mc_addresses(struct lcs_card *card, struct in_device *in4_dev)\r\n{\r\nstruct ip_mc_list *im4;\r\nstruct lcs_ipm_list *ipm;\r\nchar buf[MAX_ADDR_LEN];\r\nunsigned long flags;\r\nLCS_DBF_TEXT(4, trace, "setmclst");\r\nfor (im4 = rcu_dereference(in4_dev->mc_list); im4 != NULL;\r\nim4 = rcu_dereference(im4->next_rcu)) {\r\nlcs_get_mac_for_ipm(im4->multiaddr, buf, card->dev);\r\nipm = lcs_check_addr_entry(card, im4, buf);\r\nif (ipm != NULL)\r\ncontinue;\r\nipm = kzalloc(sizeof(struct lcs_ipm_list), GFP_ATOMIC);\r\nif (ipm == NULL) {\r\npr_info("Not enough memory to add"\r\n" new multicast entry!\n");\r\nbreak;\r\n}\r\nmemcpy(&ipm->ipm.mac_addr, buf, LCS_MAC_LENGTH);\r\nipm->ipm.ip_addr = im4->multiaddr;\r\nipm->ipm_state = LCS_IPM_STATE_SET_REQUIRED;\r\nspin_lock_irqsave(&card->ipm_lock, flags);\r\nLCS_DBF_HEX(2,trace,&ipm->ipm.ip_addr,4);\r\nlist_add(&ipm->list, &card->ipm_list);\r\nspin_unlock_irqrestore(&card->ipm_lock, flags);\r\n}\r\n}\r\nstatic int\r\nlcs_register_mc_addresses(void *data)\r\n{\r\nstruct lcs_card *card;\r\nstruct in_device *in4_dev;\r\ncard = (struct lcs_card *) data;\r\nif (!lcs_do_run_thread(card, LCS_SET_MC_THREAD))\r\nreturn 0;\r\nLCS_DBF_TEXT(4, trace, "regmulti");\r\nin4_dev = in_dev_get(card->dev);\r\nif (in4_dev == NULL)\r\ngoto out;\r\nrcu_read_lock();\r\nlcs_remove_mc_addresses(card,in4_dev);\r\nlcs_set_mc_addresses(card, in4_dev);\r\nrcu_read_unlock();\r\nin_dev_put(in4_dev);\r\nnetif_carrier_off(card->dev);\r\nnetif_tx_disable(card->dev);\r\nwait_event(card->write.wait_q,\r\n(card->write.state != LCS_CH_STATE_RUNNING));\r\nlcs_fix_multicast_list(card);\r\nif (card->state == DEV_STATE_UP) {\r\nnetif_carrier_on(card->dev);\r\nnetif_wake_queue(card->dev);\r\n}\r\nout:\r\nlcs_clear_thread_running_bit(card, LCS_SET_MC_THREAD);\r\nreturn 0;\r\n}\r\nstatic void\r\nlcs_set_multicast_list(struct net_device *dev)\r\n{\r\n#ifdef CONFIG_IP_MULTICAST\r\nstruct lcs_card *card;\r\nLCS_DBF_TEXT(4, trace, "setmulti");\r\ncard = (struct lcs_card *) dev->ml_priv;\r\nif (!lcs_set_thread_start_bit(card, LCS_SET_MC_THREAD))\r\nschedule_work(&card->kernel_thread_starter);\r\n#endif\r\n}\r\nstatic long\r\nlcs_check_irb_error(struct ccw_device *cdev, struct irb *irb)\r\n{\r\nif (!IS_ERR(irb))\r\nreturn 0;\r\nswitch (PTR_ERR(irb)) {\r\ncase -EIO:\r\ndev_warn(&cdev->dev,\r\n"An I/O-error occurred on the LCS device\n");\r\nLCS_DBF_TEXT(2, trace, "ckirberr");\r\nLCS_DBF_TEXT_(2, trace, " rc%d", -EIO);\r\nbreak;\r\ncase -ETIMEDOUT:\r\ndev_warn(&cdev->dev,\r\n"A command timed out on the LCS device\n");\r\nLCS_DBF_TEXT(2, trace, "ckirberr");\r\nLCS_DBF_TEXT_(2, trace, " rc%d", -ETIMEDOUT);\r\nbreak;\r\ndefault:\r\ndev_warn(&cdev->dev,\r\n"An error occurred on the LCS device, rc=%ld\n",\r\nPTR_ERR(irb));\r\nLCS_DBF_TEXT(2, trace, "ckirberr");\r\nLCS_DBF_TEXT(2, trace, " rc???");\r\n}\r\nreturn PTR_ERR(irb);\r\n}\r\nstatic int\r\nlcs_get_problem(struct ccw_device *cdev, struct irb *irb)\r\n{\r\nint dstat, cstat;\r\nchar *sense;\r\nsense = (char *) irb->ecw;\r\ncstat = irb->scsw.cmd.cstat;\r\ndstat = irb->scsw.cmd.dstat;\r\nif (cstat & (SCHN_STAT_CHN_CTRL_CHK | SCHN_STAT_INTF_CTRL_CHK |\r\nSCHN_STAT_CHN_DATA_CHK | SCHN_STAT_CHAIN_CHECK |\r\nSCHN_STAT_PROT_CHECK | SCHN_STAT_PROG_CHECK)) {\r\nLCS_DBF_TEXT(2, trace, "CGENCHK");\r\nreturn 1;\r\n}\r\nif (dstat & DEV_STAT_UNIT_CHECK) {\r\nif (sense[LCS_SENSE_BYTE_1] &\r\nLCS_SENSE_RESETTING_EVENT) {\r\nLCS_DBF_TEXT(2, trace, "REVIND");\r\nreturn 1;\r\n}\r\nif (sense[LCS_SENSE_BYTE_0] &\r\nLCS_SENSE_CMD_REJECT) {\r\nLCS_DBF_TEXT(2, trace, "CMDREJ");\r\nreturn 0;\r\n}\r\nif ((!sense[LCS_SENSE_BYTE_0]) &&\r\n(!sense[LCS_SENSE_BYTE_1]) &&\r\n(!sense[LCS_SENSE_BYTE_2]) &&\r\n(!sense[LCS_SENSE_BYTE_3])) {\r\nLCS_DBF_TEXT(2, trace, "ZEROSEN");\r\nreturn 0;\r\n}\r\nLCS_DBF_TEXT(2, trace, "DGENCHK");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlcs_schedule_recovery(struct lcs_card *card)\r\n{\r\nLCS_DBF_TEXT(2, trace, "startrec");\r\nif (!lcs_set_thread_start_bit(card, LCS_RECOVERY_THREAD))\r\nschedule_work(&card->kernel_thread_starter);\r\n}\r\nstatic void\r\nlcs_irq(struct ccw_device *cdev, unsigned long intparm, struct irb *irb)\r\n{\r\nstruct lcs_card *card;\r\nstruct lcs_channel *channel;\r\nint rc, index;\r\nint cstat, dstat;\r\nif (lcs_check_irb_error(cdev, irb))\r\nreturn;\r\ncard = CARD_FROM_DEV(cdev);\r\nif (card->read.ccwdev == cdev)\r\nchannel = &card->read;\r\nelse\r\nchannel = &card->write;\r\ncstat = irb->scsw.cmd.cstat;\r\ndstat = irb->scsw.cmd.dstat;\r\nLCS_DBF_TEXT_(5, trace, "Rint%s", dev_name(&cdev->dev));\r\nLCS_DBF_TEXT_(5, trace, "%4x%4x", irb->scsw.cmd.cstat,\r\nirb->scsw.cmd.dstat);\r\nLCS_DBF_TEXT_(5, trace, "%4x%4x", irb->scsw.cmd.fctl,\r\nirb->scsw.cmd.actl);\r\nrc = lcs_get_problem(cdev, irb);\r\nif (rc || (dstat & DEV_STAT_UNIT_EXCEP)) {\r\ndev_warn(&cdev->dev,\r\n"The LCS device stopped because of an error,"\r\n" dstat=0x%X, cstat=0x%X \n",\r\ndstat, cstat);\r\nif (rc) {\r\nchannel->state = LCS_CH_STATE_ERROR;\r\n}\r\n}\r\nif (channel->state == LCS_CH_STATE_ERROR) {\r\nlcs_schedule_recovery(card);\r\nwake_up(&card->wait_q);\r\nreturn;\r\n}\r\nif ((channel->state != LCS_CH_STATE_INIT) &&\r\n(irb->scsw.cmd.fctl & SCSW_FCTL_START_FUNC) &&\r\n(irb->scsw.cmd.cpa != 0)) {\r\nindex = (struct ccw1 *) __va((addr_t) irb->scsw.cmd.cpa)\r\n- channel->ccws;\r\nif ((irb->scsw.cmd.actl & SCSW_ACTL_SUSPENDED) ||\r\n(irb->scsw.cmd.cstat & SCHN_STAT_PCI))\r\nindex = (index - 1) & (LCS_NUM_BUFFS - 1);\r\nwhile (channel->io_idx != index) {\r\n__lcs_processed_buffer(channel,\r\nchannel->iob + channel->io_idx);\r\nchannel->io_idx =\r\n(channel->io_idx + 1) & (LCS_NUM_BUFFS - 1);\r\n}\r\n}\r\nif ((irb->scsw.cmd.dstat & DEV_STAT_DEV_END) ||\r\n(irb->scsw.cmd.dstat & DEV_STAT_CHN_END) ||\r\n(irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK))\r\nchannel->state = LCS_CH_STATE_STOPPED;\r\nelse if (irb->scsw.cmd.actl & SCSW_ACTL_SUSPENDED)\r\nchannel->state = LCS_CH_STATE_SUSPENDED;\r\nif (irb->scsw.cmd.fctl & SCSW_FCTL_HALT_FUNC) {\r\nif (irb->scsw.cmd.cc != 0) {\r\nccw_device_halt(channel->ccwdev, (addr_t) channel);\r\nreturn;\r\n}\r\nchannel->state = LCS_CH_STATE_HALTED;\r\n}\r\nif (irb->scsw.cmd.fctl & SCSW_FCTL_CLEAR_FUNC)\r\nchannel->state = LCS_CH_STATE_CLEARED;\r\ntasklet_schedule(&channel->irq_tasklet);\r\n}\r\nstatic void\r\nlcs_tasklet(unsigned long data)\r\n{\r\nunsigned long flags;\r\nstruct lcs_channel *channel;\r\nstruct lcs_buffer *iob;\r\nint buf_idx;\r\nchannel = (struct lcs_channel *) data;\r\nLCS_DBF_TEXT_(5, trace, "tlet%s", dev_name(&channel->ccwdev->dev));\r\niob = channel->iob;\r\nbuf_idx = channel->buf_idx;\r\nwhile (iob[buf_idx].state == LCS_BUF_STATE_PROCESSED) {\r\nif (iob[buf_idx].callback != NULL)\r\niob[buf_idx].callback(channel, iob + buf_idx);\r\nbuf_idx = (buf_idx + 1) & (LCS_NUM_BUFFS - 1);\r\n}\r\nchannel->buf_idx = buf_idx;\r\nif (channel->state == LCS_CH_STATE_STOPPED)\r\nlcs_start_channel(channel);\r\nspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\r\nif (channel->state == LCS_CH_STATE_SUSPENDED &&\r\nchannel->iob[channel->io_idx].state == LCS_BUF_STATE_READY)\r\n__lcs_resume_channel(channel);\r\nspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\r\nwake_up(&channel->wait_q);\r\n}\r\nstatic void\r\n__lcs_emit_txbuffer(struct lcs_card *card)\r\n{\r\nLCS_DBF_TEXT(5, trace, "emittx");\r\n*(__u16 *)(card->tx_buffer->data + card->tx_buffer->count) = 0;\r\ncard->tx_buffer->count += 2;\r\nlcs_ready_buffer(&card->write, card->tx_buffer);\r\ncard->tx_buffer = NULL;\r\ncard->tx_emitted++;\r\n}\r\nstatic void\r\nlcs_txbuffer_cb(struct lcs_channel *channel, struct lcs_buffer *buffer)\r\n{\r\nstruct lcs_card *card;\r\nLCS_DBF_TEXT(5, trace, "txbuffcb");\r\nlcs_release_buffer(channel, buffer);\r\ncard = container_of(channel, struct lcs_card, write);\r\nif (netif_queue_stopped(card->dev) && netif_carrier_ok(card->dev))\r\nnetif_wake_queue(card->dev);\r\nspin_lock(&card->lock);\r\ncard->tx_emitted--;\r\nif (card->tx_emitted <= 0 && card->tx_buffer != NULL)\r\n__lcs_emit_txbuffer(card);\r\nspin_unlock(&card->lock);\r\n}\r\nstatic int\r\n__lcs_start_xmit(struct lcs_card *card, struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct lcs_header *header;\r\nint rc = NETDEV_TX_OK;\r\nLCS_DBF_TEXT(5, trace, "hardxmit");\r\nif (skb == NULL) {\r\ncard->stats.tx_dropped++;\r\ncard->stats.tx_errors++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (card->state != DEV_STATE_UP) {\r\ndev_kfree_skb(skb);\r\ncard->stats.tx_dropped++;\r\ncard->stats.tx_errors++;\r\ncard->stats.tx_carrier_errors++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (skb->protocol == htons(ETH_P_IPV6)) {\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nnetif_stop_queue(card->dev);\r\nspin_lock(&card->lock);\r\nif (card->tx_buffer != NULL &&\r\ncard->tx_buffer->count + sizeof(struct lcs_header) +\r\nskb->len + sizeof(u16) > LCS_IOBUFFERSIZE)\r\n__lcs_emit_txbuffer(card);\r\nif (card->tx_buffer == NULL) {\r\ncard->tx_buffer = lcs_get_buffer(&card->write);\r\nif (card->tx_buffer == NULL) {\r\ncard->stats.tx_dropped++;\r\nrc = NETDEV_TX_BUSY;\r\ngoto out;\r\n}\r\ncard->tx_buffer->callback = lcs_txbuffer_cb;\r\ncard->tx_buffer->count = 0;\r\n}\r\nheader = (struct lcs_header *)\r\n(card->tx_buffer->data + card->tx_buffer->count);\r\ncard->tx_buffer->count += skb->len + sizeof(struct lcs_header);\r\nheader->offset = card->tx_buffer->count;\r\nheader->type = card->lan_type;\r\nheader->slot = card->portno;\r\nskb_copy_from_linear_data(skb, header + 1, skb->len);\r\nspin_unlock(&card->lock);\r\ncard->stats.tx_bytes += skb->len;\r\ncard->stats.tx_packets++;\r\ndev_kfree_skb(skb);\r\nnetif_wake_queue(card->dev);\r\nspin_lock(&card->lock);\r\nif (card->tx_emitted <= 0 && card->tx_buffer != NULL)\r\n__lcs_emit_txbuffer(card);\r\nout:\r\nspin_unlock(&card->lock);\r\nreturn rc;\r\n}\r\nstatic int\r\nlcs_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct lcs_card *card;\r\nint rc;\r\nLCS_DBF_TEXT(5, trace, "pktxmit");\r\ncard = (struct lcs_card *) dev->ml_priv;\r\nrc = __lcs_start_xmit(card, skb, dev);\r\nreturn rc;\r\n}\r\nstatic int\r\nlcs_startlan_auto(struct lcs_card *card)\r\n{\r\nint rc;\r\nLCS_DBF_TEXT(2, trace, "strtauto");\r\n#ifdef CONFIG_ETHERNET\r\ncard->lan_type = LCS_FRAME_TYPE_ENET;\r\nrc = lcs_send_startlan(card, LCS_INITIATOR_TCPIP);\r\nif (rc == 0)\r\nreturn 0;\r\n#endif\r\n#ifdef CONFIG_TR\r\ncard->lan_type = LCS_FRAME_TYPE_TR;\r\nrc = lcs_send_startlan(card, LCS_INITIATOR_TCPIP);\r\nif (rc == 0)\r\nreturn 0;\r\n#endif\r\n#ifdef CONFIG_FDDI\r\ncard->lan_type = LCS_FRAME_TYPE_FDDI;\r\nrc = lcs_send_startlan(card, LCS_INITIATOR_TCPIP);\r\nif (rc == 0)\r\nreturn 0;\r\n#endif\r\nreturn -EIO;\r\n}\r\nstatic int\r\nlcs_startlan(struct lcs_card *card)\r\n{\r\nint rc, i;\r\nLCS_DBF_TEXT(2, trace, "startlan");\r\nrc = 0;\r\nif (card->portno != LCS_INVALID_PORT_NO) {\r\nif (card->lan_type == LCS_FRAME_TYPE_AUTO)\r\nrc = lcs_startlan_auto(card);\r\nelse\r\nrc = lcs_send_startlan(card, LCS_INITIATOR_TCPIP);\r\n} else {\r\nfor (i = 0; i <= 16; i++) {\r\ncard->portno = i;\r\nif (card->lan_type != LCS_FRAME_TYPE_AUTO)\r\nrc = lcs_send_startlan(card,\r\nLCS_INITIATOR_TCPIP);\r\nelse\r\nrc = lcs_startlan_auto(card);\r\nif (rc == 0)\r\nbreak;\r\n}\r\n}\r\nif (rc == 0)\r\nreturn lcs_send_lanstat(card);\r\nreturn rc;\r\n}\r\nstatic int\r\nlcs_detect(struct lcs_card *card)\r\n{\r\nint rc = 0;\r\nLCS_DBF_TEXT(2, setup, "lcsdetct");\r\nif (card->dev)\r\nnetif_stop_queue(card->dev);\r\nrc = lcs_stop_channels(card);\r\nif (rc == 0) {\r\nrc = lcs_start_channels(card);\r\nif (rc == 0) {\r\nrc = lcs_send_startup(card, LCS_INITIATOR_TCPIP);\r\nif (rc == 0)\r\nrc = lcs_startlan(card);\r\n}\r\n}\r\nif (rc == 0) {\r\ncard->state = DEV_STATE_UP;\r\n} else {\r\ncard->state = DEV_STATE_DOWN;\r\ncard->write.state = LCS_CH_STATE_INIT;\r\ncard->read.state = LCS_CH_STATE_INIT;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nlcs_stopcard(struct lcs_card *card)\r\n{\r\nint rc;\r\nLCS_DBF_TEXT(3, setup, "stopcard");\r\nif (card->read.state != LCS_CH_STATE_STOPPED &&\r\ncard->write.state != LCS_CH_STATE_STOPPED &&\r\ncard->read.state != LCS_CH_STATE_ERROR &&\r\ncard->write.state != LCS_CH_STATE_ERROR &&\r\ncard->state == DEV_STATE_UP) {\r\nlcs_clear_multicast_list(card);\r\nrc = lcs_send_stoplan(card,LCS_INITIATOR_TCPIP);\r\nrc = lcs_send_shutdown(card);\r\n}\r\nrc = lcs_stop_channels(card);\r\ncard->state = DEV_STATE_DOWN;\r\nreturn rc;\r\n}\r\nstatic void\r\nlcs_start_kernel_thread(struct work_struct *work)\r\n{\r\nstruct lcs_card *card = container_of(work, struct lcs_card, kernel_thread_starter);\r\nLCS_DBF_TEXT(5, trace, "krnthrd");\r\nif (lcs_do_start_thread(card, LCS_RECOVERY_THREAD))\r\nkthread_run(lcs_recovery, card, "lcs_recover");\r\n#ifdef CONFIG_IP_MULTICAST\r\nif (lcs_do_start_thread(card, LCS_SET_MC_THREAD))\r\nkthread_run(lcs_register_mc_addresses, card, "regipm");\r\n#endif\r\n}\r\nstatic void\r\nlcs_get_control(struct lcs_card *card, struct lcs_cmd *cmd)\r\n{\r\nLCS_DBF_TEXT(5, trace, "getctrl");\r\nif (cmd->initiator == LCS_INITIATOR_LGW) {\r\nswitch(cmd->cmd_code) {\r\ncase LCS_CMD_STARTUP:\r\ncase LCS_CMD_STARTLAN:\r\nlcs_schedule_recovery(card);\r\nbreak;\r\ncase LCS_CMD_STOPLAN:\r\npr_warning("Stoplan for %s initiated by LGW.\n",\r\ncard->dev->name);\r\nif (card->dev)\r\nnetif_carrier_off(card->dev);\r\nbreak;\r\ndefault:\r\nLCS_DBF_TEXT(5, trace, "noLGWcmd");\r\nbreak;\r\n}\r\n} else\r\nlcs_notify_lancmd_waiters(card, cmd);\r\n}\r\nstatic void\r\nlcs_get_skb(struct lcs_card *card, char *skb_data, unsigned int skb_len)\r\n{\r\nstruct sk_buff *skb;\r\nLCS_DBF_TEXT(5, trace, "getskb");\r\nif (card->dev == NULL ||\r\ncard->state != DEV_STATE_UP)\r\nreturn;\r\nskb = dev_alloc_skb(skb_len);\r\nif (skb == NULL) {\r\ndev_err(&card->dev->dev,\r\n" Allocating a socket buffer to interface %s failed\n",\r\ncard->dev->name);\r\ncard->stats.rx_dropped++;\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, skb_len), skb_data, skb_len);\r\nskb->protocol = card->lan_type_trans(skb, card->dev);\r\ncard->stats.rx_bytes += skb_len;\r\ncard->stats.rx_packets++;\r\nif (skb->protocol == htons(ETH_P_802_2))\r\n*((__u32 *)skb->cb) = ++card->pkt_seq;\r\nnetif_rx(skb);\r\n}\r\nstatic void\r\nlcs_get_frames_cb(struct lcs_channel *channel, struct lcs_buffer *buffer)\r\n{\r\nstruct lcs_card *card;\r\nstruct lcs_header *lcs_hdr;\r\n__u16 offset;\r\nLCS_DBF_TEXT(5, trace, "lcsgtpkt");\r\nlcs_hdr = (struct lcs_header *) buffer->data;\r\nif (lcs_hdr->offset == LCS_ILLEGAL_OFFSET) {\r\nLCS_DBF_TEXT(4, trace, "-eiogpkt");\r\nreturn;\r\n}\r\ncard = container_of(channel, struct lcs_card, read);\r\noffset = 0;\r\nwhile (lcs_hdr->offset != 0) {\r\nif (lcs_hdr->offset <= 0 ||\r\nlcs_hdr->offset > LCS_IOBUFFERSIZE ||\r\nlcs_hdr->offset < offset) {\r\ncard->stats.rx_length_errors++;\r\ncard->stats.rx_errors++;\r\nreturn;\r\n}\r\nif (lcs_hdr->type == LCS_FRAME_TYPE_CONTROL)\r\nlcs_get_control(card, (struct lcs_cmd *) lcs_hdr);\r\nelse if (lcs_hdr->type == LCS_FRAME_TYPE_ENET ||\r\nlcs_hdr->type == LCS_FRAME_TYPE_TR ||\r\nlcs_hdr->type == LCS_FRAME_TYPE_FDDI)\r\nlcs_get_skb(card, (char *)(lcs_hdr + 1),\r\nlcs_hdr->offset - offset -\r\nsizeof(struct lcs_header));\r\nelse\r\n;\r\noffset = lcs_hdr->offset;\r\nlcs_hdr->offset = LCS_ILLEGAL_OFFSET;\r\nlcs_hdr = (struct lcs_header *) (buffer->data + offset);\r\n}\r\nlcs_ready_buffer(&card->read, buffer);\r\n}\r\nstatic struct net_device_stats *\r\nlcs_getstats(struct net_device *dev)\r\n{\r\nstruct lcs_card *card;\r\nLCS_DBF_TEXT(4, trace, "netstats");\r\ncard = (struct lcs_card *) dev->ml_priv;\r\nreturn &card->stats;\r\n}\r\nstatic int\r\nlcs_stop_device(struct net_device *dev)\r\n{\r\nstruct lcs_card *card;\r\nint rc;\r\nLCS_DBF_TEXT(2, trace, "stopdev");\r\ncard = (struct lcs_card *) dev->ml_priv;\r\nnetif_carrier_off(dev);\r\nnetif_tx_disable(dev);\r\ndev->flags &= ~IFF_UP;\r\nwait_event(card->write.wait_q,\r\n(card->write.state != LCS_CH_STATE_RUNNING));\r\nrc = lcs_stopcard(card);\r\nif (rc)\r\ndev_err(&card->dev->dev,\r\n" Shutting down the LCS device failed\n ");\r\nreturn rc;\r\n}\r\nstatic int\r\nlcs_open_device(struct net_device *dev)\r\n{\r\nstruct lcs_card *card;\r\nint rc;\r\nLCS_DBF_TEXT(2, trace, "opendev");\r\ncard = (struct lcs_card *) dev->ml_priv;\r\nrc = lcs_detect(card);\r\nif (rc) {\r\npr_err("Error in opening device!\n");\r\n} else {\r\ndev->flags |= IFF_UP;\r\nnetif_carrier_on(dev);\r\nnetif_wake_queue(dev);\r\ncard->state = DEV_STATE_UP;\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\nlcs_portno_show (struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct lcs_card *card;\r\ncard = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn 0;\r\nreturn sprintf(buf, "%d\n", card->portno);\r\n}\r\nstatic ssize_t\r\nlcs_portno_store (struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct lcs_card *card;\r\nint value;\r\ncard = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn 0;\r\nsscanf(buf, "%u", &value);\r\ncard->portno = value;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nlcs_type_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct ccwgroup_device *cgdev;\r\ncgdev = to_ccwgroupdev(dev);\r\nif (!cgdev)\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%s\n", lcs_type[cgdev->cdev[0]->id.driver_info]);\r\n}\r\nstatic ssize_t\r\nlcs_timeout_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct lcs_card *card;\r\ncard = dev_get_drvdata(dev);\r\nreturn card ? sprintf(buf, "%u\n", card->lancmd_timeout) : 0;\r\n}\r\nstatic ssize_t\r\nlcs_timeout_store (struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct lcs_card *card;\r\nint value;\r\ncard = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn 0;\r\nsscanf(buf, "%u", &value);\r\ncard->lancmd_timeout = value;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nlcs_dev_recover_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct lcs_card *card = dev_get_drvdata(dev);\r\nchar *tmp;\r\nint i;\r\nif (!card)\r\nreturn -EINVAL;\r\nif (card->state != DEV_STATE_UP)\r\nreturn -EPERM;\r\ni = simple_strtoul(buf, &tmp, 16);\r\nif (i == 1)\r\nlcs_schedule_recovery(card);\r\nreturn count;\r\n}\r\nstatic int\r\nlcs_probe_device(struct ccwgroup_device *ccwgdev)\r\n{\r\nstruct lcs_card *card;\r\nint ret;\r\nif (!get_device(&ccwgdev->dev))\r\nreturn -ENODEV;\r\nLCS_DBF_TEXT(2, setup, "add_dev");\r\ncard = lcs_alloc_card();\r\nif (!card) {\r\nLCS_DBF_TEXT_(2, setup, " rc%d", -ENOMEM);\r\nput_device(&ccwgdev->dev);\r\nreturn -ENOMEM;\r\n}\r\nret = sysfs_create_group(&ccwgdev->dev.kobj, &lcs_attr_group);\r\nif (ret) {\r\nlcs_free_card(card);\r\nput_device(&ccwgdev->dev);\r\nreturn ret;\r\n}\r\ndev_set_drvdata(&ccwgdev->dev, card);\r\nccwgdev->cdev[0]->handler = lcs_irq;\r\nccwgdev->cdev[1]->handler = lcs_irq;\r\ncard->gdev = ccwgdev;\r\nINIT_WORK(&card->kernel_thread_starter, lcs_start_kernel_thread);\r\ncard->thread_start_mask = 0;\r\ncard->thread_allowed_mask = 0;\r\ncard->thread_running_mask = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nlcs_register_netdev(struct ccwgroup_device *ccwgdev)\r\n{\r\nstruct lcs_card *card;\r\nLCS_DBF_TEXT(2, setup, "regnetdv");\r\ncard = dev_get_drvdata(&ccwgdev->dev);\r\nif (card->dev->reg_state != NETREG_UNINITIALIZED)\r\nreturn 0;\r\nSET_NETDEV_DEV(card->dev, &ccwgdev->dev);\r\nreturn register_netdev(card->dev);\r\n}\r\nstatic int\r\nlcs_new_device(struct ccwgroup_device *ccwgdev)\r\n{\r\nstruct lcs_card *card;\r\nstruct net_device *dev=NULL;\r\nenum lcs_dev_states recover_state;\r\nint rc;\r\ncard = dev_get_drvdata(&ccwgdev->dev);\r\nif (!card)\r\nreturn -ENODEV;\r\nLCS_DBF_TEXT(2, setup, "newdev");\r\nLCS_DBF_HEX(3, setup, &card, sizeof(void*));\r\ncard->read.ccwdev = ccwgdev->cdev[0];\r\ncard->write.ccwdev = ccwgdev->cdev[1];\r\nrecover_state = card->state;\r\nrc = ccw_device_set_online(card->read.ccwdev);\r\nif (rc)\r\ngoto out_err;\r\nrc = ccw_device_set_online(card->write.ccwdev);\r\nif (rc)\r\ngoto out_werr;\r\nLCS_DBF_TEXT(3, setup, "lcsnewdv");\r\nlcs_setup_card(card);\r\nrc = lcs_detect(card);\r\nif (rc) {\r\nLCS_DBF_TEXT(2, setup, "dtctfail");\r\ndev_err(&card->dev->dev,\r\n"Detecting a network adapter for LCS devices"\r\n" failed with rc=%d (0x%x)\n", rc, rc);\r\nlcs_stopcard(card);\r\ngoto out;\r\n}\r\nif (card->dev) {\r\nLCS_DBF_TEXT(2, setup, "samedev");\r\nLCS_DBF_HEX(3, setup, &card, sizeof(void*));\r\ngoto netdev_out;\r\n}\r\nswitch (card->lan_type) {\r\n#ifdef CONFIG_ETHERNET\r\ncase LCS_FRAME_TYPE_ENET:\r\ncard->lan_type_trans = eth_type_trans;\r\ndev = alloc_etherdev(0);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_TR\r\ncase LCS_FRAME_TYPE_TR:\r\ncard->lan_type_trans = tr_type_trans;\r\ndev = alloc_trdev(0);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_FDDI\r\ncase LCS_FRAME_TYPE_FDDI:\r\ncard->lan_type_trans = fddi_type_trans;\r\ndev = alloc_fddidev(0);\r\nbreak;\r\n#endif\r\ndefault:\r\nLCS_DBF_TEXT(3, setup, "errinit");\r\npr_err(" Initialization failed\n");\r\ngoto out;\r\n}\r\nif (!dev)\r\ngoto out;\r\ncard->dev = dev;\r\ncard->dev->ml_priv = card;\r\ncard->dev->netdev_ops = &lcs_netdev_ops;\r\nmemcpy(card->dev->dev_addr, card->mac, LCS_MAC_LENGTH);\r\n#ifdef CONFIG_IP_MULTICAST\r\nif (!lcs_check_multicast_support(card))\r\ncard->dev->netdev_ops = &lcs_mc_netdev_ops;\r\n#endif\r\nnetdev_out:\r\nlcs_set_allowed_threads(card,0xffffffff);\r\nif (recover_state == DEV_STATE_RECOVER) {\r\nlcs_set_multicast_list(card->dev);\r\ncard->dev->flags |= IFF_UP;\r\nnetif_carrier_on(card->dev);\r\nnetif_wake_queue(card->dev);\r\ncard->state = DEV_STATE_UP;\r\n} else {\r\nlcs_stopcard(card);\r\n}\r\nif (lcs_register_netdev(ccwgdev) != 0)\r\ngoto out;\r\npr_info("LCS device %s %s IPv6 support\n", card->dev->name,\r\n(card->ip_assists_supported & LCS_IPASS_IPV6_SUPPORT) ?\r\n"with" : "without");\r\npr_info("LCS device %s %s Multicast support\n", card->dev->name,\r\n(card->ip_assists_supported & LCS_IPASS_MULTICAST_SUPPORT) ?\r\n"with" : "without");\r\nreturn 0;\r\nout:\r\nccw_device_set_offline(card->write.ccwdev);\r\nout_werr:\r\nccw_device_set_offline(card->read.ccwdev);\r\nout_err:\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\n__lcs_shutdown_device(struct ccwgroup_device *ccwgdev, int recovery_mode)\r\n{\r\nstruct lcs_card *card;\r\nenum lcs_dev_states recover_state;\r\nint ret;\r\nLCS_DBF_TEXT(3, setup, "shtdndev");\r\ncard = dev_get_drvdata(&ccwgdev->dev);\r\nif (!card)\r\nreturn -ENODEV;\r\nif (recovery_mode == 0) {\r\nlcs_set_allowed_threads(card, 0);\r\nif (lcs_wait_for_threads(card, LCS_SET_MC_THREAD))\r\nreturn -ERESTARTSYS;\r\n}\r\nLCS_DBF_HEX(3, setup, &card, sizeof(void*));\r\nrecover_state = card->state;\r\nret = lcs_stop_device(card->dev);\r\nret = ccw_device_set_offline(card->read.ccwdev);\r\nret = ccw_device_set_offline(card->write.ccwdev);\r\nif (recover_state == DEV_STATE_UP) {\r\ncard->state = DEV_STATE_RECOVER;\r\n}\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int\r\nlcs_shutdown_device(struct ccwgroup_device *ccwgdev)\r\n{\r\nreturn __lcs_shutdown_device(ccwgdev, 0);\r\n}\r\nstatic int\r\nlcs_recovery(void *ptr)\r\n{\r\nstruct lcs_card *card;\r\nstruct ccwgroup_device *gdev;\r\nint rc;\r\ncard = (struct lcs_card *) ptr;\r\nLCS_DBF_TEXT(4, trace, "recover1");\r\nif (!lcs_do_run_thread(card, LCS_RECOVERY_THREAD))\r\nreturn 0;\r\nLCS_DBF_TEXT(4, trace, "recover2");\r\ngdev = card->gdev;\r\ndev_warn(&gdev->dev,\r\n"A recovery process has been started for the LCS device\n");\r\nrc = __lcs_shutdown_device(gdev, 1);\r\nrc = lcs_new_device(gdev);\r\nif (!rc)\r\npr_info("Device %s successfully recovered!\n",\r\ncard->dev->name);\r\nelse\r\npr_info("Device %s could not be recovered!\n",\r\ncard->dev->name);\r\nlcs_clear_thread_running_bit(card, LCS_RECOVERY_THREAD);\r\nreturn 0;\r\n}\r\nstatic void\r\nlcs_remove_device(struct ccwgroup_device *ccwgdev)\r\n{\r\nstruct lcs_card *card;\r\ncard = dev_get_drvdata(&ccwgdev->dev);\r\nif (!card)\r\nreturn;\r\nLCS_DBF_TEXT(3, setup, "remdev");\r\nLCS_DBF_HEX(3, setup, &card, sizeof(void*));\r\nif (ccwgdev->state == CCWGROUP_ONLINE) {\r\nlcs_shutdown_device(ccwgdev);\r\n}\r\nif (card->dev)\r\nunregister_netdev(card->dev);\r\nsysfs_remove_group(&ccwgdev->dev.kobj, &lcs_attr_group);\r\nlcs_cleanup_card(card);\r\nlcs_free_card(card);\r\nput_device(&ccwgdev->dev);\r\n}\r\nstatic int lcs_pm_suspend(struct lcs_card *card)\r\n{\r\nif (card->dev)\r\nnetif_device_detach(card->dev);\r\nlcs_set_allowed_threads(card, 0);\r\nlcs_wait_for_threads(card, 0xffffffff);\r\nif (card->state != DEV_STATE_DOWN)\r\n__lcs_shutdown_device(card->gdev, 1);\r\nreturn 0;\r\n}\r\nstatic int lcs_pm_resume(struct lcs_card *card)\r\n{\r\nint rc = 0;\r\nif (card->state == DEV_STATE_RECOVER)\r\nrc = lcs_new_device(card->gdev);\r\nif (card->dev)\r\nnetif_device_attach(card->dev);\r\nif (rc) {\r\ndev_warn(&card->gdev->dev, "The lcs device driver "\r\n"failed to recover the device\n");\r\n}\r\nreturn rc;\r\n}\r\nstatic int lcs_prepare(struct ccwgroup_device *gdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void lcs_complete(struct ccwgroup_device *gdev)\r\n{\r\nreturn;\r\n}\r\nstatic int lcs_freeze(struct ccwgroup_device *gdev)\r\n{\r\nstruct lcs_card *card = dev_get_drvdata(&gdev->dev);\r\nreturn lcs_pm_suspend(card);\r\n}\r\nstatic int lcs_thaw(struct ccwgroup_device *gdev)\r\n{\r\nstruct lcs_card *card = dev_get_drvdata(&gdev->dev);\r\nreturn lcs_pm_resume(card);\r\n}\r\nstatic int lcs_restore(struct ccwgroup_device *gdev)\r\n{\r\nstruct lcs_card *card = dev_get_drvdata(&gdev->dev);\r\nreturn lcs_pm_resume(card);\r\n}\r\nstatic ssize_t\r\nlcs_driver_group_store(struct device_driver *ddrv, const char *buf,\r\nsize_t count)\r\n{\r\nint err;\r\nerr = ccwgroup_create_from_string(lcs_root_dev,\r\nlcs_group_driver.driver_id,\r\n&lcs_ccw_driver, 2, buf);\r\nreturn err ? err : count;\r\n}\r\nstatic int\r\n__init lcs_init_module(void)\r\n{\r\nint rc;\r\npr_info("Loading %s\n", version);\r\nrc = lcs_register_debug_facility();\r\nLCS_DBF_TEXT(0, setup, "lcsinit");\r\nif (rc)\r\ngoto out_err;\r\nlcs_root_dev = root_device_register("lcs");\r\nrc = IS_ERR(lcs_root_dev) ? PTR_ERR(lcs_root_dev) : 0;\r\nif (rc)\r\ngoto register_err;\r\nrc = ccw_driver_register(&lcs_ccw_driver);\r\nif (rc)\r\ngoto ccw_err;\r\nlcs_group_driver.driver.groups = lcs_group_attr_groups;\r\nrc = ccwgroup_driver_register(&lcs_group_driver);\r\nif (rc)\r\ngoto ccwgroup_err;\r\nreturn 0;\r\nccwgroup_err:\r\nccw_driver_unregister(&lcs_ccw_driver);\r\nccw_err:\r\nroot_device_unregister(lcs_root_dev);\r\nregister_err:\r\nlcs_unregister_debug_facility();\r\nout_err:\r\npr_err("Initializing the lcs device driver failed\n");\r\nreturn rc;\r\n}\r\nstatic void\r\n__exit lcs_cleanup_module(void)\r\n{\r\npr_info("Terminating lcs module.\n");\r\nLCS_DBF_TEXT(0, trace, "cleanup");\r\ndriver_remove_file(&lcs_group_driver.driver,\r\n&driver_attr_group);\r\nccwgroup_driver_unregister(&lcs_group_driver);\r\nccw_driver_unregister(&lcs_ccw_driver);\r\nroot_device_unregister(lcs_root_dev);\r\nlcs_unregister_debug_facility();\r\n}
