static int hdcs_reg_write_seq(struct sd *sd, u8 reg, u8 *vals, u8 len)\r\n{\r\nu8 regs[I2C_MAX_BYTES * 2];\r\nint i;\r\nif (unlikely((len <= 0) || (len >= I2C_MAX_BYTES) ||\r\n(reg + len > 0xff)))\r\nreturn -EINVAL;\r\nfor (i = 0; i < len; i++) {\r\nregs[2 * i] = reg;\r\nregs[2 * i + 1] = vals[i];\r\nreg += 2;\r\n}\r\nreturn stv06xx_write_sensor_bytes(sd, regs, len);\r\n}\r\nstatic int hdcs_set_state(struct sd *sd, enum hdcs_power_state state)\r\n{\r\nstruct hdcs *hdcs = sd->sensor_priv;\r\nu8 val;\r\nint ret;\r\nif (hdcs->state == state)\r\nreturn 0;\r\nif (hdcs->state != HDCS_STATE_IDLE) {\r\nret = stv06xx_write_sensor(sd, HDCS_REG_CONTROL(sd), 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nhdcs->state = HDCS_STATE_IDLE;\r\nif (state == HDCS_STATE_IDLE)\r\nreturn 0;\r\nswitch (state) {\r\ncase HDCS_STATE_SLEEP:\r\nval = HDCS_SLEEP_MODE;\r\nbreak;\r\ncase HDCS_STATE_RUN:\r\nval = HDCS_RUN_ENABLE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = stv06xx_write_sensor(sd, HDCS_REG_CONTROL(sd), val);\r\nif (!ret)\r\nhdcs->state = state;\r\nreturn ret;\r\n}\r\nstatic int hdcs_reset(struct sd *sd)\r\n{\r\nstruct hdcs *hdcs = sd->sensor_priv;\r\nint err;\r\nerr = stv06xx_write_sensor(sd, HDCS_REG_CONTROL(sd), 1);\r\nif (err < 0)\r\nreturn err;\r\nerr = stv06xx_write_sensor(sd, HDCS_REG_CONTROL(sd), 0);\r\nif (err < 0)\r\nhdcs->state = HDCS_STATE_IDLE;\r\nreturn err;\r\n}\r\nstatic int hdcs_get_exposure(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct hdcs *hdcs = sd->sensor_priv;\r\n*val = hdcs->exp_cache;\r\nreturn 0;\r\n}\r\nstatic int hdcs_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct hdcs *hdcs = sd->sensor_priv;\r\nint rowexp, srowexp;\r\nint max_srowexp;\r\nint ct;\r\nint cp;\r\nint rp;\r\nint mnct;\r\nint cycles, err;\r\nu8 exp[14];\r\nval &= 0xff;\r\nhdcs->exp_cache = val;\r\ncycles = val * HDCS_CLK_FREQ_MHZ * 257;\r\nct = hdcs->exp.cto + hdcs->psmp + (HDCS_ADC_START_SIG_DUR + 2);\r\ncp = hdcs->exp.cto + (hdcs->w * ct / 2);\r\nrp = hdcs->exp.rs + cp;\r\nrowexp = cycles / rp;\r\ncycles -= rowexp * rp;\r\nif (IS_1020(sd)) {\r\nsrowexp = hdcs->w - (cycles + hdcs->exp.er + 13) / ct;\r\nmnct = (hdcs->exp.er + 12 + ct - 1) / ct;\r\nmax_srowexp = hdcs->w - mnct;\r\n} else {\r\nsrowexp = cp - hdcs->exp.er - 6 - cycles;\r\nmnct = (hdcs->exp.er + 5 + ct - 1) / ct;\r\nmax_srowexp = cp - mnct * ct - 1;\r\n}\r\nif (srowexp < 0)\r\nsrowexp = 0;\r\nelse if (srowexp > max_srowexp)\r\nsrowexp = max_srowexp;\r\nif (IS_1020(sd)) {\r\nexp[0] = HDCS20_CONTROL;\r\nexp[1] = 0x00;\r\nexp[2] = HDCS_ROWEXPL;\r\nexp[3] = rowexp & 0xff;\r\nexp[4] = HDCS_ROWEXPH;\r\nexp[5] = rowexp >> 8;\r\nexp[6] = HDCS20_SROWEXP;\r\nexp[7] = (srowexp >> 2) & 0xff;\r\nexp[8] = HDCS20_ERROR;\r\nexp[9] = 0x10;\r\nexp[10] = HDCS20_CONTROL;\r\nexp[11] = 0x04;\r\nerr = stv06xx_write_sensor_bytes(sd, exp, 6);\r\n} else {\r\nexp[0] = HDCS00_CONTROL;\r\nexp[1] = 0x00;\r\nexp[2] = HDCS_ROWEXPL;\r\nexp[3] = rowexp & 0xff;\r\nexp[4] = HDCS_ROWEXPH;\r\nexp[5] = rowexp >> 8;\r\nexp[6] = HDCS00_SROWEXPL;\r\nexp[7] = srowexp & 0xff;\r\nexp[8] = HDCS00_SROWEXPH;\r\nexp[9] = srowexp >> 8;\r\nexp[10] = HDCS_STATUS;\r\nexp[11] = 0x10;\r\nexp[12] = HDCS00_CONTROL;\r\nexp[13] = 0x04;\r\nerr = stv06xx_write_sensor_bytes(sd, exp, 7);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nPDEBUG(D_V4L2, "Writing exposure %d, rowexp %d, srowexp %d",\r\nval, rowexp, srowexp);\r\nreturn err;\r\n}\r\nstatic int hdcs_set_gains(struct sd *sd, u8 g)\r\n{\r\nstruct hdcs *hdcs = sd->sensor_priv;\r\nint err;\r\nu8 gains[4];\r\nhdcs->gain_cache = g;\r\nif (g > 127)\r\ng = 0x80 | (g / 2);\r\ngains[0] = g;\r\ngains[1] = g;\r\ngains[2] = g;\r\ngains[3] = g;\r\nerr = hdcs_reg_write_seq(sd, HDCS_ERECPGA, gains, 4);\r\nreturn err;\r\n}\r\nstatic int hdcs_get_gain(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct hdcs *hdcs = sd->sensor_priv;\r\n*val = hdcs->gain_cache;\r\nreturn 0;\r\n}\r\nstatic int hdcs_set_gain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nPDEBUG(D_V4L2, "Writing gain %d", val);\r\nreturn hdcs_set_gains((struct sd *) gspca_dev,\r\nval & 0xff);\r\n}\r\nstatic int hdcs_set_size(struct sd *sd,\r\nunsigned int width, unsigned int height)\r\n{\r\nstruct hdcs *hdcs = sd->sensor_priv;\r\nu8 win[4];\r\nunsigned int x, y;\r\nint err;\r\nwidth = (width + 3) & ~0x3;\r\nheight = (height + 3) & ~0x3;\r\nif (width > hdcs->array.width)\r\nwidth = hdcs->array.width;\r\nif (IS_1020(sd)) {\r\nif (height + 2 * hdcs->array.border + HDCS_1020_BOTTOM_Y_SKIP\r\n> hdcs->array.height)\r\nheight = hdcs->array.height - 2 * hdcs->array.border -\r\nHDCS_1020_BOTTOM_Y_SKIP;\r\ny = (hdcs->array.height - HDCS_1020_BOTTOM_Y_SKIP - height) / 2\r\n+ hdcs->array.top;\r\n} else {\r\nif (height > hdcs->array.height)\r\nheight = hdcs->array.height;\r\ny = hdcs->array.top + (hdcs->array.height - height) / 2;\r\n}\r\nx = hdcs->array.left + (hdcs->array.width - width) / 2;\r\nwin[0] = y / 4;\r\nwin[1] = x / 4;\r\nwin[2] = (y + height) / 4 - 1;\r\nwin[3] = (x + width) / 4 - 1;\r\nerr = hdcs_reg_write_seq(sd, HDCS_FWROW, win, 4);\r\nif (err < 0)\r\nreturn err;\r\nhdcs->w = width;\r\nhdcs->h = height;\r\nreturn err;\r\n}\r\nstatic int hdcs_probe_1x00(struct sd *sd)\r\n{\r\nstruct hdcs *hdcs;\r\nu16 sensor;\r\nint ret;\r\nret = stv06xx_read_sensor(sd, HDCS_IDENT, &sensor);\r\nif (ret < 0 || sensor != 0x08)\r\nreturn -ENODEV;\r\npr_info("HDCS-1000/1100 sensor detected\n");\r\nsd->gspca_dev.cam.cam_mode = hdcs1x00_mode;\r\nsd->gspca_dev.cam.nmodes = ARRAY_SIZE(hdcs1x00_mode);\r\nsd->desc.ctrls = hdcs1x00_ctrl;\r\nsd->desc.nctrls = ARRAY_SIZE(hdcs1x00_ctrl);\r\nhdcs = kmalloc(sizeof(struct hdcs), GFP_KERNEL);\r\nif (!hdcs)\r\nreturn -ENOMEM;\r\nhdcs->array.left = 8;\r\nhdcs->array.top = 8;\r\nhdcs->array.width = HDCS_1X00_DEF_WIDTH;\r\nhdcs->array.height = HDCS_1X00_DEF_HEIGHT;\r\nhdcs->array.border = 4;\r\nhdcs->exp.cto = 4;\r\nhdcs->exp.cpo = 2;\r\nhdcs->exp.rs = 186;\r\nhdcs->exp.er = 100;\r\nhdcs->psmp = (sd->bridge == BRIDGE_STV602) ? 20 : 5;\r\nsd->sensor_priv = hdcs;\r\nreturn 0;\r\n}\r\nstatic int hdcs_probe_1020(struct sd *sd)\r\n{\r\nstruct hdcs *hdcs;\r\nu16 sensor;\r\nint ret;\r\nret = stv06xx_read_sensor(sd, HDCS_IDENT, &sensor);\r\nif (ret < 0 || sensor != 0x10)\r\nreturn -ENODEV;\r\npr_info("HDCS-1020 sensor detected\n");\r\nsd->gspca_dev.cam.cam_mode = hdcs1020_mode;\r\nsd->gspca_dev.cam.nmodes = ARRAY_SIZE(hdcs1020_mode);\r\nsd->desc.ctrls = hdcs1020_ctrl;\r\nsd->desc.nctrls = ARRAY_SIZE(hdcs1020_ctrl);\r\nhdcs = kmalloc(sizeof(struct hdcs), GFP_KERNEL);\r\nif (!hdcs)\r\nreturn -ENOMEM;\r\nhdcs->array.left = 24;\r\nhdcs->array.top = 4;\r\nhdcs->array.width = HDCS_1020_DEF_WIDTH;\r\nhdcs->array.height = 304;\r\nhdcs->array.border = 4;\r\nhdcs->psmp = 6;\r\nhdcs->exp.cto = 3;\r\nhdcs->exp.cpo = 3;\r\nhdcs->exp.rs = 155;\r\nhdcs->exp.er = 96;\r\nsd->sensor_priv = hdcs;\r\nreturn 0;\r\n}\r\nstatic int hdcs_start(struct sd *sd)\r\n{\r\nPDEBUG(D_STREAM, "Starting stream");\r\nreturn hdcs_set_state(sd, HDCS_STATE_RUN);\r\n}\r\nstatic int hdcs_stop(struct sd *sd)\r\n{\r\nPDEBUG(D_STREAM, "Halting stream");\r\nreturn hdcs_set_state(sd, HDCS_STATE_SLEEP);\r\n}\r\nstatic void hdcs_disconnect(struct sd *sd)\r\n{\r\nPDEBUG(D_PROBE, "Disconnecting the sensor");\r\nkfree(sd->sensor_priv);\r\n}\r\nstatic int hdcs_init(struct sd *sd)\r\n{\r\nstruct hdcs *hdcs = sd->sensor_priv;\r\nint i, err = 0;\r\nif (sd->bridge == BRIDGE_STV602)\r\nstv06xx_write_bridge(sd, STV_STV0600_EMULATION, 1);\r\nfor (i = 0; i < ARRAY_SIZE(stv_bridge_init) && !err; i++) {\r\nerr = stv06xx_write_bridge(sd, stv_bridge_init[i][0],\r\nstv_bridge_init[i][1]);\r\n}\r\nif (err < 0)\r\nreturn err;\r\nhdcs_reset(sd);\r\nfor (i = 0; i < ARRAY_SIZE(stv_sensor_init) && !err; i++) {\r\nerr = stv06xx_write_sensor(sd, stv_sensor_init[i][0],\r\nstv_sensor_init[i][1]);\r\n}\r\nif (err < 0)\r\nreturn err;\r\nerr = stv06xx_write_sensor(sd, HDCS_REG_CONFIG(sd), BIT(3));\r\nif (err < 0)\r\nreturn err;\r\nif (IS_1020(sd))\r\nerr = stv06xx_write_sensor(sd, HDCS_TCTRL,\r\n(HDCS_ADC_START_SIG_DUR << 6) | hdcs->psmp);\r\nelse\r\nerr = stv06xx_write_sensor(sd, HDCS_TCTRL,\r\n(HDCS_ADC_START_SIG_DUR << 5) | hdcs->psmp);\r\nif (err < 0)\r\nreturn err;\r\nerr = hdcs_set_gains(sd, HDCS_DEFAULT_GAIN);\r\nif (err < 0)\r\nreturn err;\r\nerr = hdcs_set_size(sd, hdcs->array.width, hdcs->array.height);\r\nif (err < 0)\r\nreturn err;\r\nerr = hdcs_set_exposure(&sd->gspca_dev, HDCS_DEFAULT_EXPOSURE);\r\nreturn err;\r\n}\r\nstatic int hdcs_dump(struct sd *sd)\r\n{\r\nu16 reg, val;\r\npr_info("Dumping sensor registers:\n");\r\nfor (reg = HDCS_IDENT; reg <= HDCS_ROWEXPH; reg++) {\r\nstv06xx_read_sensor(sd, reg, &val);\r\npr_info("reg 0x%02x = 0x%02x\n", reg, val);\r\n}\r\nreturn 0;\r\n}
