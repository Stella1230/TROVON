static void _set_gpio_direction(struct gpio_bank *bank, int gpio, int is_input)\r\n{\r\nvoid __iomem *reg = bank->base;\r\nu32 l;\r\nreg += bank->regs->direction;\r\nl = __raw_readl(reg);\r\nif (is_input)\r\nl |= 1 << gpio;\r\nelse\r\nl &= ~(1 << gpio);\r\n__raw_writel(l, reg);\r\n}\r\nstatic void _set_gpio_dataout_reg(struct gpio_bank *bank, int gpio, int enable)\r\n{\r\nvoid __iomem *reg = bank->base;\r\nu32 l = GPIO_BIT(bank, gpio);\r\nif (enable)\r\nreg += bank->regs->set_dataout;\r\nelse\r\nreg += bank->regs->clr_dataout;\r\n__raw_writel(l, reg);\r\n}\r\nstatic void _set_gpio_dataout_mask(struct gpio_bank *bank, int gpio, int enable)\r\n{\r\nvoid __iomem *reg = bank->base + bank->regs->dataout;\r\nu32 gpio_bit = GPIO_BIT(bank, gpio);\r\nu32 l;\r\nl = __raw_readl(reg);\r\nif (enable)\r\nl |= gpio_bit;\r\nelse\r\nl &= ~gpio_bit;\r\n__raw_writel(l, reg);\r\n}\r\nstatic int _get_gpio_datain(struct gpio_bank *bank, int gpio)\r\n{\r\nvoid __iomem *reg = bank->base + bank->regs->datain;\r\nreturn (__raw_readl(reg) & GPIO_BIT(bank, gpio)) != 0;\r\n}\r\nstatic int _get_gpio_dataout(struct gpio_bank *bank, int gpio)\r\n{\r\nvoid __iomem *reg = bank->base + bank->regs->dataout;\r\nreturn (__raw_readl(reg) & GPIO_BIT(bank, gpio)) != 0;\r\n}\r\nstatic inline void _gpio_rmw(void __iomem *base, u32 reg, u32 mask, bool set)\r\n{\r\nint l = __raw_readl(base + reg);\r\nif (set)\r\nl |= mask;\r\nelse\r\nl &= ~mask;\r\n__raw_writel(l, base + reg);\r\n}\r\nstatic void _set_gpio_debounce(struct gpio_bank *bank, unsigned gpio,\r\nunsigned debounce)\r\n{\r\nvoid __iomem *reg;\r\nu32 val;\r\nu32 l;\r\nif (!bank->dbck_flag)\r\nreturn;\r\nif (debounce < 32)\r\ndebounce = 0x01;\r\nelse if (debounce > 7936)\r\ndebounce = 0xff;\r\nelse\r\ndebounce = (debounce / 0x1f) - 1;\r\nl = GPIO_BIT(bank, gpio);\r\nreg = bank->base + bank->regs->debounce;\r\n__raw_writel(debounce, reg);\r\nreg = bank->base + bank->regs->debounce_en;\r\nval = __raw_readl(reg);\r\nif (debounce) {\r\nval |= l;\r\nclk_enable(bank->dbck);\r\n} else {\r\nval &= ~l;\r\nclk_disable(bank->dbck);\r\n}\r\nbank->dbck_enable_mask = val;\r\n__raw_writel(val, reg);\r\n}\r\nstatic inline void set_24xx_gpio_triggering(struct gpio_bank *bank, int gpio,\r\nint trigger)\r\n{\r\nvoid __iomem *base = bank->base;\r\nu32 gpio_bit = 1 << gpio;\r\nif (cpu_is_omap44xx()) {\r\n_gpio_rmw(base, OMAP4_GPIO_LEVELDETECT0, gpio_bit,\r\ntrigger & IRQ_TYPE_LEVEL_LOW);\r\n_gpio_rmw(base, OMAP4_GPIO_LEVELDETECT1, gpio_bit,\r\ntrigger & IRQ_TYPE_LEVEL_HIGH);\r\n_gpio_rmw(base, OMAP4_GPIO_RISINGDETECT, gpio_bit,\r\ntrigger & IRQ_TYPE_EDGE_RISING);\r\n_gpio_rmw(base, OMAP4_GPIO_FALLINGDETECT, gpio_bit,\r\ntrigger & IRQ_TYPE_EDGE_FALLING);\r\n} else {\r\n_gpio_rmw(base, OMAP24XX_GPIO_LEVELDETECT0, gpio_bit,\r\ntrigger & IRQ_TYPE_LEVEL_LOW);\r\n_gpio_rmw(base, OMAP24XX_GPIO_LEVELDETECT1, gpio_bit,\r\ntrigger & IRQ_TYPE_LEVEL_HIGH);\r\n_gpio_rmw(base, OMAP24XX_GPIO_RISINGDETECT, gpio_bit,\r\ntrigger & IRQ_TYPE_EDGE_RISING);\r\n_gpio_rmw(base, OMAP24XX_GPIO_FALLINGDETECT, gpio_bit,\r\ntrigger & IRQ_TYPE_EDGE_FALLING);\r\n}\r\nif (likely(!(bank->non_wakeup_gpios & gpio_bit))) {\r\nif (cpu_is_omap44xx()) {\r\n_gpio_rmw(base, OMAP4_GPIO_IRQWAKEN0, gpio_bit,\r\ntrigger != 0);\r\n} else {\r\nif (trigger & IRQ_TYPE_EDGE_BOTH)\r\n__raw_writel(1 << gpio, bank->base\r\n+ OMAP24XX_GPIO_SETWKUENA);\r\nelse\r\n__raw_writel(1 << gpio, bank->base\r\n+ OMAP24XX_GPIO_CLEARWKUENA);\r\n}\r\n}\r\nif (cpu_is_omap34xx() || cpu_is_omap44xx() ||\r\n(bank->non_wakeup_gpios & gpio_bit)) {\r\nif (trigger & IRQ_TYPE_EDGE_BOTH)\r\nbank->enabled_non_wakeup_gpios |= gpio_bit;\r\nelse\r\nbank->enabled_non_wakeup_gpios &= ~gpio_bit;\r\n}\r\nif (cpu_is_omap44xx()) {\r\nbank->level_mask =\r\n__raw_readl(bank->base + OMAP4_GPIO_LEVELDETECT0) |\r\n__raw_readl(bank->base + OMAP4_GPIO_LEVELDETECT1);\r\n} else {\r\nbank->level_mask =\r\n__raw_readl(bank->base + OMAP24XX_GPIO_LEVELDETECT0) |\r\n__raw_readl(bank->base + OMAP24XX_GPIO_LEVELDETECT1);\r\n}\r\n}\r\nstatic void _toggle_gpio_edge_triggering(struct gpio_bank *bank, int gpio)\r\n{\r\nvoid __iomem *reg = bank->base;\r\nu32 l = 0;\r\nswitch (bank->method) {\r\ncase METHOD_MPUIO:\r\nreg += OMAP_MPUIO_GPIO_INT_EDGE / bank->stride;\r\nbreak;\r\n#ifdef CONFIG_ARCH_OMAP15XX\r\ncase METHOD_GPIO_1510:\r\nreg += OMAP1510_GPIO_INT_CONTROL;\r\nbreak;\r\n#endif\r\n#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)\r\ncase METHOD_GPIO_7XX:\r\nreg += OMAP7XX_GPIO_INT_CONTROL;\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn;\r\n}\r\nl = __raw_readl(reg);\r\nif ((l >> gpio) & 1)\r\nl &= ~(1 << gpio);\r\nelse\r\nl |= 1 << gpio;\r\n__raw_writel(l, reg);\r\n}\r\nstatic int _set_gpio_triggering(struct gpio_bank *bank, int gpio, int trigger)\r\n{\r\nvoid __iomem *reg = bank->base;\r\nu32 l = 0;\r\nswitch (bank->method) {\r\n#ifdef CONFIG_ARCH_OMAP1\r\ncase METHOD_MPUIO:\r\nreg += OMAP_MPUIO_GPIO_INT_EDGE / bank->stride;\r\nl = __raw_readl(reg);\r\nif ((trigger & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH)\r\nbank->toggle_mask |= 1 << gpio;\r\nif (trigger & IRQ_TYPE_EDGE_RISING)\r\nl |= 1 << gpio;\r\nelse if (trigger & IRQ_TYPE_EDGE_FALLING)\r\nl &= ~(1 << gpio);\r\nelse\r\ngoto bad;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_ARCH_OMAP15XX\r\ncase METHOD_GPIO_1510:\r\nreg += OMAP1510_GPIO_INT_CONTROL;\r\nl = __raw_readl(reg);\r\nif ((trigger & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH)\r\nbank->toggle_mask |= 1 << gpio;\r\nif (trigger & IRQ_TYPE_EDGE_RISING)\r\nl |= 1 << gpio;\r\nelse if (trigger & IRQ_TYPE_EDGE_FALLING)\r\nl &= ~(1 << gpio);\r\nelse\r\ngoto bad;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_ARCH_OMAP16XX\r\ncase METHOD_GPIO_1610:\r\nif (gpio & 0x08)\r\nreg += OMAP1610_GPIO_EDGE_CTRL2;\r\nelse\r\nreg += OMAP1610_GPIO_EDGE_CTRL1;\r\ngpio &= 0x07;\r\nl = __raw_readl(reg);\r\nl &= ~(3 << (gpio << 1));\r\nif (trigger & IRQ_TYPE_EDGE_RISING)\r\nl |= 2 << (gpio << 1);\r\nif (trigger & IRQ_TYPE_EDGE_FALLING)\r\nl |= 1 << (gpio << 1);\r\nif (trigger)\r\n__raw_writel(1 << gpio, bank->base + OMAP1610_GPIO_SET_WAKEUPENA);\r\nelse\r\n__raw_writel(1 << gpio, bank->base + OMAP1610_GPIO_CLEAR_WAKEUPENA);\r\nbreak;\r\n#endif\r\n#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)\r\ncase METHOD_GPIO_7XX:\r\nreg += OMAP7XX_GPIO_INT_CONTROL;\r\nl = __raw_readl(reg);\r\nif ((trigger & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH)\r\nbank->toggle_mask |= 1 << gpio;\r\nif (trigger & IRQ_TYPE_EDGE_RISING)\r\nl |= 1 << gpio;\r\nelse if (trigger & IRQ_TYPE_EDGE_FALLING)\r\nl &= ~(1 << gpio);\r\nelse\r\ngoto bad;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_ARCH_OMAP2PLUS\r\ncase METHOD_GPIO_24XX:\r\ncase METHOD_GPIO_44XX:\r\nset_24xx_gpio_triggering(bank, gpio, trigger);\r\nreturn 0;\r\n#endif\r\ndefault:\r\ngoto bad;\r\n}\r\n__raw_writel(l, reg);\r\nreturn 0;\r\nbad:\r\nreturn -EINVAL;\r\n}\r\nstatic int gpio_irq_type(struct irq_data *d, unsigned type)\r\n{\r\nstruct gpio_bank *bank;\r\nunsigned gpio;\r\nint retval;\r\nunsigned long flags;\r\nif (!cpu_class_is_omap2() && d->irq > IH_MPUIO_BASE)\r\ngpio = OMAP_MPUIO(d->irq - IH_MPUIO_BASE);\r\nelse\r\ngpio = d->irq - IH_GPIO_BASE;\r\nif (type & ~IRQ_TYPE_SENSE_MASK)\r\nreturn -EINVAL;\r\nif (!cpu_class_is_omap2()\r\n&& (type & (IRQ_TYPE_LEVEL_LOW|IRQ_TYPE_LEVEL_HIGH)))\r\nreturn -EINVAL;\r\nbank = irq_data_get_irq_chip_data(d);\r\nspin_lock_irqsave(&bank->lock, flags);\r\nretval = _set_gpio_triggering(bank, GPIO_INDEX(bank, gpio), type);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nif (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH))\r\n__irq_set_handler_locked(d->irq, handle_level_irq);\r\nelse if (type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\r\n__irq_set_handler_locked(d->irq, handle_edge_irq);\r\nreturn retval;\r\n}\r\nstatic void _clear_gpio_irqbank(struct gpio_bank *bank, int gpio_mask)\r\n{\r\nvoid __iomem *reg = bank->base;\r\nreg += bank->regs->irqstatus;\r\n__raw_writel(gpio_mask, reg);\r\nif (bank->regs->irqstatus2) {\r\nreg = bank->base + bank->regs->irqstatus2;\r\n__raw_writel(gpio_mask, reg);\r\n}\r\n__raw_readl(reg);\r\n}\r\nstatic inline void _clear_gpio_irqstatus(struct gpio_bank *bank, int gpio)\r\n{\r\n_clear_gpio_irqbank(bank, GPIO_BIT(bank, gpio));\r\n}\r\nstatic u32 _get_gpio_irqbank_mask(struct gpio_bank *bank)\r\n{\r\nvoid __iomem *reg = bank->base;\r\nu32 l;\r\nu32 mask = (1 << bank->width) - 1;\r\nreg += bank->regs->irqenable;\r\nl = __raw_readl(reg);\r\nif (bank->regs->irqenable_inv)\r\nl = ~l;\r\nl &= mask;\r\nreturn l;\r\n}\r\nstatic void _enable_gpio_irqbank(struct gpio_bank *bank, int gpio_mask)\r\n{\r\nvoid __iomem *reg = bank->base;\r\nu32 l;\r\nif (bank->regs->set_irqenable) {\r\nreg += bank->regs->set_irqenable;\r\nl = gpio_mask;\r\n} else {\r\nreg += bank->regs->irqenable;\r\nl = __raw_readl(reg);\r\nif (bank->regs->irqenable_inv)\r\nl &= ~gpio_mask;\r\nelse\r\nl |= gpio_mask;\r\n}\r\n__raw_writel(l, reg);\r\n}\r\nstatic void _disable_gpio_irqbank(struct gpio_bank *bank, int gpio_mask)\r\n{\r\nvoid __iomem *reg = bank->base;\r\nu32 l;\r\nif (bank->regs->clr_irqenable) {\r\nreg += bank->regs->clr_irqenable;\r\nl = gpio_mask;\r\n} else {\r\nreg += bank->regs->irqenable;\r\nl = __raw_readl(reg);\r\nif (bank->regs->irqenable_inv)\r\nl |= gpio_mask;\r\nelse\r\nl &= ~gpio_mask;\r\n}\r\n__raw_writel(l, reg);\r\n}\r\nstatic inline void _set_gpio_irqenable(struct gpio_bank *bank, int gpio, int enable)\r\n{\r\n_enable_gpio_irqbank(bank, GPIO_BIT(bank, gpio));\r\n}\r\nstatic int _set_gpio_wakeup(struct gpio_bank *bank, int gpio, int enable)\r\n{\r\nu32 gpio_bit = GPIO_BIT(bank, gpio);\r\nunsigned long flags;\r\nif (bank->non_wakeup_gpios & gpio_bit) {\r\ndev_err(bank->dev,\r\n"Unable to modify wakeup on non-wakeup GPIO%d\n", gpio);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&bank->lock, flags);\r\nif (enable)\r\nbank->suspend_wakeup |= gpio_bit;\r\nelse\r\nbank->suspend_wakeup &= ~gpio_bit;\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void _reset_gpio(struct gpio_bank *bank, int gpio)\r\n{\r\n_set_gpio_direction(bank, GPIO_INDEX(bank, gpio), 1);\r\n_set_gpio_irqenable(bank, gpio, 0);\r\n_clear_gpio_irqstatus(bank, gpio);\r\n_set_gpio_triggering(bank, GPIO_INDEX(bank, gpio), IRQ_TYPE_NONE);\r\n}\r\nstatic int gpio_wake_enable(struct irq_data *d, unsigned int enable)\r\n{\r\nunsigned int gpio = d->irq - IH_GPIO_BASE;\r\nstruct gpio_bank *bank;\r\nint retval;\r\nbank = irq_data_get_irq_chip_data(d);\r\nretval = _set_gpio_wakeup(bank, gpio, enable);\r\nreturn retval;\r\n}\r\nstatic int omap_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_bank *bank = container_of(chip, struct gpio_bank, chip);\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->lock, flags);\r\n_set_gpio_triggering(bank, offset, IRQ_TYPE_NONE);\r\n#ifdef CONFIG_ARCH_OMAP15XX\r\nif (bank->method == METHOD_GPIO_1510) {\r\nvoid __iomem *reg;\r\nreg = bank->base + OMAP1510_GPIO_PIN_CONTROL;\r\n__raw_writel(__raw_readl(reg) | (1 << offset), reg);\r\n}\r\n#endif\r\nif (!cpu_class_is_omap1()) {\r\nif (!bank->mod_usage) {\r\nvoid __iomem *reg = bank->base;\r\nu32 ctrl;\r\nif (cpu_is_omap24xx() || cpu_is_omap34xx())\r\nreg += OMAP24XX_GPIO_CTRL;\r\nelse if (cpu_is_omap44xx())\r\nreg += OMAP4_GPIO_CTRL;\r\nctrl = __raw_readl(reg);\r\nctrl &= 0xFFFFFFFE;\r\n__raw_writel(ctrl, reg);\r\n}\r\nbank->mod_usage |= 1 << offset;\r\n}\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void omap_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_bank *bank = container_of(chip, struct gpio_bank, chip);\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->lock, flags);\r\n#ifdef CONFIG_ARCH_OMAP16XX\r\nif (bank->method == METHOD_GPIO_1610) {\r\nvoid __iomem *reg = bank->base + OMAP1610_GPIO_CLEAR_WAKEUPENA;\r\n__raw_writel(1 << offset, reg);\r\n}\r\n#endif\r\n#if defined(CONFIG_ARCH_OMAP2) || defined(CONFIG_ARCH_OMAP3)\r\nif (bank->method == METHOD_GPIO_24XX) {\r\nvoid __iomem *reg = bank->base + OMAP24XX_GPIO_CLEARWKUENA;\r\n__raw_writel(1 << offset, reg);\r\n}\r\n#endif\r\n#ifdef CONFIG_ARCH_OMAP4\r\nif (bank->method == METHOD_GPIO_44XX) {\r\nvoid __iomem *reg = bank->base + OMAP4_GPIO_IRQWAKEN0;\r\n__raw_writel(1 << offset, reg);\r\n}\r\n#endif\r\nif (!cpu_class_is_omap1()) {\r\nbank->mod_usage &= ~(1 << offset);\r\nif (!bank->mod_usage) {\r\nvoid __iomem *reg = bank->base;\r\nu32 ctrl;\r\nif (cpu_is_omap24xx() || cpu_is_omap34xx())\r\nreg += OMAP24XX_GPIO_CTRL;\r\nelse if (cpu_is_omap44xx())\r\nreg += OMAP4_GPIO_CTRL;\r\nctrl = __raw_readl(reg);\r\nctrl |= 1;\r\n__raw_writel(ctrl, reg);\r\n}\r\n}\r\n_reset_gpio(bank, bank->chip.base + offset);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\n}\r\nstatic void gpio_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nvoid __iomem *isr_reg = NULL;\r\nu32 isr;\r\nunsigned int gpio_irq, gpio_index;\r\nstruct gpio_bank *bank;\r\nu32 retrigger = 0;\r\nint unmasked = 0;\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nchained_irq_enter(chip, desc);\r\nbank = irq_get_handler_data(irq);\r\nisr_reg = bank->base + bank->regs->irqstatus;\r\nif (WARN_ON(!isr_reg))\r\ngoto exit;\r\nwhile(1) {\r\nu32 isr_saved, level_mask = 0;\r\nu32 enabled;\r\nenabled = _get_gpio_irqbank_mask(bank);\r\nisr_saved = isr = __raw_readl(isr_reg) & enabled;\r\nif (cpu_is_omap15xx() && (bank->method == METHOD_MPUIO))\r\nisr &= 0x0000ffff;\r\nif (cpu_class_is_omap2()) {\r\nlevel_mask = bank->level_mask & enabled;\r\n}\r\n_disable_gpio_irqbank(bank, isr_saved & ~level_mask);\r\n_clear_gpio_irqbank(bank, isr_saved & ~level_mask);\r\n_enable_gpio_irqbank(bank, isr_saved & ~level_mask);\r\nif (!level_mask && !unmasked) {\r\nunmasked = 1;\r\nchained_irq_exit(chip, desc);\r\n}\r\nisr |= retrigger;\r\nretrigger = 0;\r\nif (!isr)\r\nbreak;\r\ngpio_irq = bank->virtual_irq_start;\r\nfor (; isr != 0; isr >>= 1, gpio_irq++) {\r\ngpio_index = GPIO_INDEX(bank, irq_to_gpio(gpio_irq));\r\nif (!(isr & 1))\r\ncontinue;\r\n#ifdef CONFIG_ARCH_OMAP1\r\nif (bank->toggle_mask & (1 << gpio_index))\r\n_toggle_gpio_edge_triggering(bank, gpio_index);\r\n#endif\r\ngeneric_handle_irq(gpio_irq);\r\n}\r\n}\r\nexit:\r\nif (!unmasked)\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void gpio_irq_shutdown(struct irq_data *d)\r\n{\r\nunsigned int gpio = d->irq - IH_GPIO_BASE;\r\nstruct gpio_bank *bank = irq_data_get_irq_chip_data(d);\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->lock, flags);\r\n_reset_gpio(bank, gpio);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\n}\r\nstatic void gpio_ack_irq(struct irq_data *d)\r\n{\r\nunsigned int gpio = d->irq - IH_GPIO_BASE;\r\nstruct gpio_bank *bank = irq_data_get_irq_chip_data(d);\r\n_clear_gpio_irqstatus(bank, gpio);\r\n}\r\nstatic void gpio_mask_irq(struct irq_data *d)\r\n{\r\nunsigned int gpio = d->irq - IH_GPIO_BASE;\r\nstruct gpio_bank *bank = irq_data_get_irq_chip_data(d);\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->lock, flags);\r\n_set_gpio_irqenable(bank, gpio, 0);\r\n_set_gpio_triggering(bank, GPIO_INDEX(bank, gpio), IRQ_TYPE_NONE);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\n}\r\nstatic void gpio_unmask_irq(struct irq_data *d)\r\n{\r\nunsigned int gpio = d->irq - IH_GPIO_BASE;\r\nstruct gpio_bank *bank = irq_data_get_irq_chip_data(d);\r\nunsigned int irq_mask = GPIO_BIT(bank, gpio);\r\nu32 trigger = irqd_get_trigger_type(d);\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->lock, flags);\r\nif (trigger)\r\n_set_gpio_triggering(bank, GPIO_INDEX(bank, gpio), trigger);\r\nif (bank->level_mask & irq_mask) {\r\n_set_gpio_irqenable(bank, gpio, 0);\r\n_clear_gpio_irqstatus(bank, gpio);\r\n}\r\n_set_gpio_irqenable(bank, gpio, 1);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\n}\r\nstatic int omap_mpuio_suspend_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct gpio_bank *bank = platform_get_drvdata(pdev);\r\nvoid __iomem *mask_reg = bank->base +\r\nOMAP_MPUIO_GPIO_MASKIT / bank->stride;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->lock, flags);\r\nbank->saved_wakeup = __raw_readl(mask_reg);\r\n__raw_writel(0xffff & ~bank->suspend_wakeup, mask_reg);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int omap_mpuio_resume_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct gpio_bank *bank = platform_get_drvdata(pdev);\r\nvoid __iomem *mask_reg = bank->base +\r\nOMAP_MPUIO_GPIO_MASKIT / bank->stride;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->lock, flags);\r\n__raw_writel(bank->saved_wakeup, mask_reg);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic inline void mpuio_init(void)\r\n{\r\nstruct gpio_bank *bank = &gpio_bank[0];\r\nplatform_set_drvdata(&omap_mpuio_device, bank);\r\nif (platform_driver_register(&omap_mpuio_driver) == 0)\r\n(void) platform_device_register(&omap_mpuio_device);\r\n}\r\nstatic inline void mpuio_init(void) {}\r\nstatic inline void mpuio_init(void) {}\r\nstatic int gpio_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_bank *bank;\r\nunsigned long flags;\r\nbank = container_of(chip, struct gpio_bank, chip);\r\nspin_lock_irqsave(&bank->lock, flags);\r\n_set_gpio_direction(bank, offset, 1);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int gpio_is_input(struct gpio_bank *bank, int mask)\r\n{\r\nvoid __iomem *reg = bank->base + bank->regs->direction;\r\nreturn __raw_readl(reg) & mask;\r\n}\r\nstatic int gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_bank *bank;\r\nvoid __iomem *reg;\r\nint gpio;\r\nu32 mask;\r\ngpio = chip->base + offset;\r\nbank = container_of(chip, struct gpio_bank, chip);\r\nreg = bank->base;\r\nmask = GPIO_BIT(bank, gpio);\r\nif (gpio_is_input(bank, mask))\r\nreturn _get_gpio_datain(bank, gpio);\r\nelse\r\nreturn _get_gpio_dataout(bank, gpio);\r\n}\r\nstatic int gpio_output(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct gpio_bank *bank;\r\nunsigned long flags;\r\nbank = container_of(chip, struct gpio_bank, chip);\r\nspin_lock_irqsave(&bank->lock, flags);\r\nbank->set_dataout(bank, offset, value);\r\n_set_gpio_direction(bank, offset, 0);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int gpio_debounce(struct gpio_chip *chip, unsigned offset,\r\nunsigned debounce)\r\n{\r\nstruct gpio_bank *bank;\r\nunsigned long flags;\r\nbank = container_of(chip, struct gpio_bank, chip);\r\nif (!bank->dbck) {\r\nbank->dbck = clk_get(bank->dev, "dbclk");\r\nif (IS_ERR(bank->dbck))\r\ndev_err(bank->dev, "Could not get gpio dbck\n");\r\n}\r\nspin_lock_irqsave(&bank->lock, flags);\r\n_set_gpio_debounce(bank, offset, debounce);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct gpio_bank *bank;\r\nunsigned long flags;\r\nbank = container_of(chip, struct gpio_bank, chip);\r\nspin_lock_irqsave(&bank->lock, flags);\r\nbank->set_dataout(bank, offset, value);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\n}\r\nstatic int gpio_2irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_bank *bank;\r\nbank = container_of(chip, struct gpio_bank, chip);\r\nreturn bank->virtual_irq_start + offset;\r\n}\r\nstatic void __init omap_gpio_show_rev(struct gpio_bank *bank)\r\n{\r\nstatic bool called;\r\nu32 rev;\r\nif (called || bank->regs->revision == USHRT_MAX)\r\nreturn;\r\nrev = __raw_readw(bank->base + bank->regs->revision);\r\npr_info("OMAP GPIO hardware version %d.%d\n",\r\n(rev >> 4) & 0x0f, rev & 0x0f);\r\ncalled = true;\r\n}\r\nstatic inline int init_gpio_info(struct platform_device *pdev)\r\n{\r\ngpio_bank = kzalloc(gpio_bank_count * sizeof(struct gpio_bank),\r\nGFP_KERNEL);\r\nif (!gpio_bank) {\r\ndev_err(&pdev->dev, "Memory alloc failed for gpio_bank\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_gpio_mod_init(struct gpio_bank *bank, int id)\r\n{\r\nif (cpu_class_is_omap2()) {\r\nif (cpu_is_omap44xx()) {\r\n__raw_writel(0xffffffff, bank->base +\r\nOMAP4_GPIO_IRQSTATUSCLR0);\r\n__raw_writel(0x00000000, bank->base +\r\nOMAP4_GPIO_DEBOUNCENABLE);\r\n__raw_writel(0, bank->base + OMAP4_GPIO_CTRL);\r\n} else if (cpu_is_omap34xx()) {\r\n__raw_writel(0x00000000, bank->base +\r\nOMAP24XX_GPIO_IRQENABLE1);\r\n__raw_writel(0xffffffff, bank->base +\r\nOMAP24XX_GPIO_IRQSTATUS1);\r\n__raw_writel(0x00000000, bank->base +\r\nOMAP24XX_GPIO_DEBOUNCE_EN);\r\n__raw_writel(0, bank->base + OMAP24XX_GPIO_CTRL);\r\n} else if (cpu_is_omap24xx()) {\r\nstatic const u32 non_wakeup_gpios[] = {\r\n0xe203ffc0, 0x08700040\r\n};\r\nif (id < ARRAY_SIZE(non_wakeup_gpios))\r\nbank->non_wakeup_gpios = non_wakeup_gpios[id];\r\n}\r\n} else if (cpu_class_is_omap1()) {\r\nif (bank_is_mpuio(bank))\r\n__raw_writew(0xffff, bank->base +\r\nOMAP_MPUIO_GPIO_MASKIT / bank->stride);\r\nif (cpu_is_omap15xx() && bank->method == METHOD_GPIO_1510) {\r\n__raw_writew(0xffff, bank->base\r\n+ OMAP1510_GPIO_INT_MASK);\r\n__raw_writew(0x0000, bank->base\r\n+ OMAP1510_GPIO_INT_STATUS);\r\n}\r\nif (cpu_is_omap16xx() && bank->method == METHOD_GPIO_1610) {\r\n__raw_writew(0x0000, bank->base\r\n+ OMAP1610_GPIO_IRQENABLE1);\r\n__raw_writew(0xffff, bank->base\r\n+ OMAP1610_GPIO_IRQSTATUS1);\r\n__raw_writew(0x0014, bank->base\r\n+ OMAP1610_GPIO_SYSCONFIG);\r\nomap_writel(omap_readl(ULPD_CAM_CLK_CTRL) | 0x04,\r\nULPD_CAM_CLK_CTRL);\r\n}\r\nif (cpu_is_omap7xx() && bank->method == METHOD_GPIO_7XX) {\r\n__raw_writel(0xffffffff, bank->base\r\n+ OMAP7XX_GPIO_INT_MASK);\r\n__raw_writel(0x00000000, bank->base\r\n+ OMAP7XX_GPIO_INT_STATUS);\r\n}\r\n}\r\n}\r\nstatic __init void\r\nomap_mpuio_alloc_gc(struct gpio_bank *bank, unsigned int irq_start,\r\nunsigned int num)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\ngc = irq_alloc_generic_chip("MPUIO", 1, irq_start, bank->base,\r\nhandle_simple_irq);\r\nif (!gc) {\r\ndev_err(bank->dev, "Memory alloc failed for gc\n");\r\nreturn;\r\n}\r\nct = gc->chip_types;\r\nct->chip.irq_mask = irq_gc_mask_set_bit;\r\nct->chip.irq_unmask = irq_gc_mask_clr_bit;\r\nct->chip.irq_set_type = gpio_irq_type;\r\nif (cpu_is_omap16xx())\r\nct->chip.irq_set_wake = gpio_wake_enable,\r\nct->regs.mask = OMAP_MPUIO_GPIO_INT / bank->stride;\r\nirq_setup_generic_chip(gc, IRQ_MSK(num), IRQ_GC_INIT_MASK_CACHE,\r\nIRQ_NOREQUEST | IRQ_NOPROBE, 0);\r\n}\r\nstatic void __devinit omap_gpio_chip_init(struct gpio_bank *bank)\r\n{\r\nint j;\r\nstatic int gpio;\r\nbank->mod_usage = 0;\r\nbank->chip.request = omap_gpio_request;\r\nbank->chip.free = omap_gpio_free;\r\nbank->chip.direction_input = gpio_input;\r\nbank->chip.get = gpio_get;\r\nbank->chip.direction_output = gpio_output;\r\nbank->chip.set_debounce = gpio_debounce;\r\nbank->chip.set = gpio_set;\r\nbank->chip.to_irq = gpio_2irq;\r\nif (bank_is_mpuio(bank)) {\r\nbank->chip.label = "mpuio";\r\n#ifdef CONFIG_ARCH_OMAP16XX\r\nbank->chip.dev = &omap_mpuio_device.dev;\r\n#endif\r\nbank->chip.base = OMAP_MPUIO(0);\r\n} else {\r\nbank->chip.label = "gpio";\r\nbank->chip.base = gpio;\r\ngpio += bank->width;\r\n}\r\nbank->chip.ngpio = bank->width;\r\ngpiochip_add(&bank->chip);\r\nfor (j = bank->virtual_irq_start;\r\nj < bank->virtual_irq_start + bank->width; j++) {\r\nirq_set_lockdep_class(j, &gpio_lock_class);\r\nirq_set_chip_data(j, bank);\r\nif (bank_is_mpuio(bank)) {\r\nomap_mpuio_alloc_gc(bank, j, bank->width);\r\n} else {\r\nirq_set_chip(j, &gpio_irq_chip);\r\nirq_set_handler(j, handle_simple_irq);\r\nset_irq_flags(j, IRQF_VALID);\r\n}\r\n}\r\nirq_set_chained_handler(bank->irq, gpio_irq_handler);\r\nirq_set_handler_data(bank->irq, bank);\r\n}\r\nstatic int __devinit omap_gpio_probe(struct platform_device *pdev)\r\n{\r\nstatic int gpio_init_done;\r\nstruct omap_gpio_platform_data *pdata;\r\nstruct resource *res;\r\nint id;\r\nstruct gpio_bank *bank;\r\nif (!pdev->dev.platform_data)\r\nreturn -EINVAL;\r\npdata = pdev->dev.platform_data;\r\nif (!gpio_init_done) {\r\nint ret;\r\nret = init_gpio_info(pdev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nid = pdev->id;\r\nbank = &gpio_bank[id];\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (unlikely(!res)) {\r\ndev_err(&pdev->dev, "GPIO Bank %i Invalid IRQ resource\n", id);\r\nreturn -ENODEV;\r\n}\r\nbank->irq = res->start;\r\nbank->virtual_irq_start = pdata->virtual_irq_start;\r\nbank->method = pdata->bank_type;\r\nbank->dev = &pdev->dev;\r\nbank->dbck_flag = pdata->dbck_flag;\r\nbank->stride = pdata->bank_stride;\r\nbank->width = pdata->bank_width;\r\nbank->regs = pdata->regs;\r\nif (bank->regs->set_dataout && bank->regs->clr_dataout)\r\nbank->set_dataout = _set_gpio_dataout_reg;\r\nelse\r\nbank->set_dataout = _set_gpio_dataout_mask;\r\nspin_lock_init(&bank->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!res)) {\r\ndev_err(&pdev->dev, "GPIO Bank %i Invalid mem resource\n", id);\r\nreturn -ENODEV;\r\n}\r\nbank->base = ioremap(res->start, resource_size(res));\r\nif (!bank->base) {\r\ndev_err(&pdev->dev, "Could not ioremap gpio bank%i\n", id);\r\nreturn -ENOMEM;\r\n}\r\npm_runtime_enable(bank->dev);\r\npm_runtime_get_sync(bank->dev);\r\nomap_gpio_mod_init(bank, id);\r\nomap_gpio_chip_init(bank);\r\nomap_gpio_show_rev(bank);\r\nif (!gpio_init_done)\r\ngpio_init_done = 1;\r\nreturn 0;\r\n}\r\nstatic int omap_gpio_suspend(void)\r\n{\r\nint i;\r\nif (!cpu_class_is_omap2() && !cpu_is_omap16xx())\r\nreturn 0;\r\nfor (i = 0; i < gpio_bank_count; i++) {\r\nstruct gpio_bank *bank = &gpio_bank[i];\r\nvoid __iomem *wake_status;\r\nvoid __iomem *wake_clear;\r\nvoid __iomem *wake_set;\r\nunsigned long flags;\r\nswitch (bank->method) {\r\n#ifdef CONFIG_ARCH_OMAP16XX\r\ncase METHOD_GPIO_1610:\r\nwake_status = bank->base + OMAP1610_GPIO_WAKEUPENABLE;\r\nwake_clear = bank->base + OMAP1610_GPIO_CLEAR_WAKEUPENA;\r\nwake_set = bank->base + OMAP1610_GPIO_SET_WAKEUPENA;\r\nbreak;\r\n#endif\r\n#if defined(CONFIG_ARCH_OMAP2) || defined(CONFIG_ARCH_OMAP3)\r\ncase METHOD_GPIO_24XX:\r\nwake_status = bank->base + OMAP24XX_GPIO_WAKE_EN;\r\nwake_clear = bank->base + OMAP24XX_GPIO_CLEARWKUENA;\r\nwake_set = bank->base + OMAP24XX_GPIO_SETWKUENA;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_ARCH_OMAP4\r\ncase METHOD_GPIO_44XX:\r\nwake_status = bank->base + OMAP4_GPIO_IRQWAKEN0;\r\nwake_clear = bank->base + OMAP4_GPIO_IRQWAKEN0;\r\nwake_set = bank->base + OMAP4_GPIO_IRQWAKEN0;\r\nbreak;\r\n#endif\r\ndefault:\r\ncontinue;\r\n}\r\nspin_lock_irqsave(&bank->lock, flags);\r\nbank->saved_wakeup = __raw_readl(wake_status);\r\n__raw_writel(0xffffffff, wake_clear);\r\n__raw_writel(bank->suspend_wakeup, wake_set);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_gpio_resume(void)\r\n{\r\nint i;\r\nif (!cpu_class_is_omap2() && !cpu_is_omap16xx())\r\nreturn;\r\nfor (i = 0; i < gpio_bank_count; i++) {\r\nstruct gpio_bank *bank = &gpio_bank[i];\r\nvoid __iomem *wake_clear;\r\nvoid __iomem *wake_set;\r\nunsigned long flags;\r\nswitch (bank->method) {\r\n#ifdef CONFIG_ARCH_OMAP16XX\r\ncase METHOD_GPIO_1610:\r\nwake_clear = bank->base + OMAP1610_GPIO_CLEAR_WAKEUPENA;\r\nwake_set = bank->base + OMAP1610_GPIO_SET_WAKEUPENA;\r\nbreak;\r\n#endif\r\n#if defined(CONFIG_ARCH_OMAP2) || defined(CONFIG_ARCH_OMAP3)\r\ncase METHOD_GPIO_24XX:\r\nwake_clear = bank->base + OMAP24XX_GPIO_CLEARWKUENA;\r\nwake_set = bank->base + OMAP24XX_GPIO_SETWKUENA;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_ARCH_OMAP4\r\ncase METHOD_GPIO_44XX:\r\nwake_clear = bank->base + OMAP4_GPIO_IRQWAKEN0;\r\nwake_set = bank->base + OMAP4_GPIO_IRQWAKEN0;\r\nbreak;\r\n#endif\r\ndefault:\r\ncontinue;\r\n}\r\nspin_lock_irqsave(&bank->lock, flags);\r\n__raw_writel(0xffffffff, wake_clear);\r\n__raw_writel(bank->saved_wakeup, wake_set);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\n}\r\n}\r\nvoid omap2_gpio_prepare_for_idle(int off_mode)\r\n{\r\nint i, c = 0;\r\nint min = 0;\r\nif (cpu_is_omap34xx())\r\nmin = 1;\r\nfor (i = min; i < gpio_bank_count; i++) {\r\nstruct gpio_bank *bank = &gpio_bank[i];\r\nu32 l1 = 0, l2 = 0;\r\nint j;\r\nfor (j = 0; j < hweight_long(bank->dbck_enable_mask); j++)\r\nclk_disable(bank->dbck);\r\nif (!off_mode)\r\ncontinue;\r\nif (!(bank->enabled_non_wakeup_gpios))\r\ncontinue;\r\nif (cpu_is_omap24xx() || cpu_is_omap34xx()) {\r\nbank->saved_datain = __raw_readl(bank->base +\r\nOMAP24XX_GPIO_DATAIN);\r\nl1 = __raw_readl(bank->base +\r\nOMAP24XX_GPIO_FALLINGDETECT);\r\nl2 = __raw_readl(bank->base +\r\nOMAP24XX_GPIO_RISINGDETECT);\r\n}\r\nif (cpu_is_omap44xx()) {\r\nbank->saved_datain = __raw_readl(bank->base +\r\nOMAP4_GPIO_DATAIN);\r\nl1 = __raw_readl(bank->base +\r\nOMAP4_GPIO_FALLINGDETECT);\r\nl2 = __raw_readl(bank->base +\r\nOMAP4_GPIO_RISINGDETECT);\r\n}\r\nbank->saved_fallingdetect = l1;\r\nbank->saved_risingdetect = l2;\r\nl1 &= ~bank->enabled_non_wakeup_gpios;\r\nl2 &= ~bank->enabled_non_wakeup_gpios;\r\nif (cpu_is_omap24xx() || cpu_is_omap34xx()) {\r\n__raw_writel(l1, bank->base +\r\nOMAP24XX_GPIO_FALLINGDETECT);\r\n__raw_writel(l2, bank->base +\r\nOMAP24XX_GPIO_RISINGDETECT);\r\n}\r\nif (cpu_is_omap44xx()) {\r\n__raw_writel(l1, bank->base + OMAP4_GPIO_FALLINGDETECT);\r\n__raw_writel(l2, bank->base + OMAP4_GPIO_RISINGDETECT);\r\n}\r\nc++;\r\n}\r\nif (!c) {\r\nworkaround_enabled = 0;\r\nreturn;\r\n}\r\nworkaround_enabled = 1;\r\n}\r\nvoid omap2_gpio_resume_after_idle(void)\r\n{\r\nint i;\r\nint min = 0;\r\nif (cpu_is_omap34xx())\r\nmin = 1;\r\nfor (i = min; i < gpio_bank_count; i++) {\r\nstruct gpio_bank *bank = &gpio_bank[i];\r\nu32 l = 0, gen, gen0, gen1;\r\nint j;\r\nfor (j = 0; j < hweight_long(bank->dbck_enable_mask); j++)\r\nclk_enable(bank->dbck);\r\nif (!workaround_enabled)\r\ncontinue;\r\nif (!(bank->enabled_non_wakeup_gpios))\r\ncontinue;\r\nif (cpu_is_omap24xx() || cpu_is_omap34xx()) {\r\n__raw_writel(bank->saved_fallingdetect,\r\nbank->base + OMAP24XX_GPIO_FALLINGDETECT);\r\n__raw_writel(bank->saved_risingdetect,\r\nbank->base + OMAP24XX_GPIO_RISINGDETECT);\r\nl = __raw_readl(bank->base + OMAP24XX_GPIO_DATAIN);\r\n}\r\nif (cpu_is_omap44xx()) {\r\n__raw_writel(bank->saved_fallingdetect,\r\nbank->base + OMAP4_GPIO_FALLINGDETECT);\r\n__raw_writel(bank->saved_risingdetect,\r\nbank->base + OMAP4_GPIO_RISINGDETECT);\r\nl = __raw_readl(bank->base + OMAP4_GPIO_DATAIN);\r\n}\r\nl ^= bank->saved_datain;\r\nl &= bank->enabled_non_wakeup_gpios;\r\ngen0 = l & bank->saved_fallingdetect;\r\ngen0 &= bank->saved_datain;\r\ngen1 = l & bank->saved_risingdetect;\r\ngen1 &= ~(bank->saved_datain);\r\ngen = l & (~(bank->saved_fallingdetect) &\r\n~(bank->saved_risingdetect));\r\ngen |= gen0 | gen1;\r\nif (gen) {\r\nu32 old0, old1;\r\nif (cpu_is_omap24xx() || cpu_is_omap34xx()) {\r\nold0 = __raw_readl(bank->base +\r\nOMAP24XX_GPIO_LEVELDETECT0);\r\nold1 = __raw_readl(bank->base +\r\nOMAP24XX_GPIO_LEVELDETECT1);\r\n__raw_writel(old0 | gen, bank->base +\r\nOMAP24XX_GPIO_LEVELDETECT0);\r\n__raw_writel(old1 | gen, bank->base +\r\nOMAP24XX_GPIO_LEVELDETECT1);\r\n__raw_writel(old0, bank->base +\r\nOMAP24XX_GPIO_LEVELDETECT0);\r\n__raw_writel(old1, bank->base +\r\nOMAP24XX_GPIO_LEVELDETECT1);\r\n}\r\nif (cpu_is_omap44xx()) {\r\nold0 = __raw_readl(bank->base +\r\nOMAP4_GPIO_LEVELDETECT0);\r\nold1 = __raw_readl(bank->base +\r\nOMAP4_GPIO_LEVELDETECT1);\r\n__raw_writel(old0 | l, bank->base +\r\nOMAP4_GPIO_LEVELDETECT0);\r\n__raw_writel(old1 | l, bank->base +\r\nOMAP4_GPIO_LEVELDETECT1);\r\n__raw_writel(old0, bank->base +\r\nOMAP4_GPIO_LEVELDETECT0);\r\n__raw_writel(old1, bank->base +\r\nOMAP4_GPIO_LEVELDETECT1);\r\n}\r\n}\r\n}\r\n}\r\nvoid omap_gpio_save_context(void)\r\n{\r\nint i;\r\nfor (i = 1; i < gpio_bank_count; i++) {\r\nstruct gpio_bank *bank = &gpio_bank[i];\r\ngpio_context[i].irqenable1 =\r\n__raw_readl(bank->base + OMAP24XX_GPIO_IRQENABLE1);\r\ngpio_context[i].irqenable2 =\r\n__raw_readl(bank->base + OMAP24XX_GPIO_IRQENABLE2);\r\ngpio_context[i].wake_en =\r\n__raw_readl(bank->base + OMAP24XX_GPIO_WAKE_EN);\r\ngpio_context[i].ctrl =\r\n__raw_readl(bank->base + OMAP24XX_GPIO_CTRL);\r\ngpio_context[i].oe =\r\n__raw_readl(bank->base + OMAP24XX_GPIO_OE);\r\ngpio_context[i].leveldetect0 =\r\n__raw_readl(bank->base + OMAP24XX_GPIO_LEVELDETECT0);\r\ngpio_context[i].leveldetect1 =\r\n__raw_readl(bank->base + OMAP24XX_GPIO_LEVELDETECT1);\r\ngpio_context[i].risingdetect =\r\n__raw_readl(bank->base + OMAP24XX_GPIO_RISINGDETECT);\r\ngpio_context[i].fallingdetect =\r\n__raw_readl(bank->base + OMAP24XX_GPIO_FALLINGDETECT);\r\ngpio_context[i].dataout =\r\n__raw_readl(bank->base + OMAP24XX_GPIO_DATAOUT);\r\n}\r\n}\r\nvoid omap_gpio_restore_context(void)\r\n{\r\nint i;\r\nfor (i = 1; i < gpio_bank_count; i++) {\r\nstruct gpio_bank *bank = &gpio_bank[i];\r\n__raw_writel(gpio_context[i].irqenable1,\r\nbank->base + OMAP24XX_GPIO_IRQENABLE1);\r\n__raw_writel(gpio_context[i].irqenable2,\r\nbank->base + OMAP24XX_GPIO_IRQENABLE2);\r\n__raw_writel(gpio_context[i].wake_en,\r\nbank->base + OMAP24XX_GPIO_WAKE_EN);\r\n__raw_writel(gpio_context[i].ctrl,\r\nbank->base + OMAP24XX_GPIO_CTRL);\r\n__raw_writel(gpio_context[i].oe,\r\nbank->base + OMAP24XX_GPIO_OE);\r\n__raw_writel(gpio_context[i].leveldetect0,\r\nbank->base + OMAP24XX_GPIO_LEVELDETECT0);\r\n__raw_writel(gpio_context[i].leveldetect1,\r\nbank->base + OMAP24XX_GPIO_LEVELDETECT1);\r\n__raw_writel(gpio_context[i].risingdetect,\r\nbank->base + OMAP24XX_GPIO_RISINGDETECT);\r\n__raw_writel(gpio_context[i].fallingdetect,\r\nbank->base + OMAP24XX_GPIO_FALLINGDETECT);\r\n__raw_writel(gpio_context[i].dataout,\r\nbank->base + OMAP24XX_GPIO_DATAOUT);\r\n}\r\n}\r\nstatic int __init omap_gpio_drv_reg(void)\r\n{\r\nreturn platform_driver_register(&omap_gpio_driver);\r\n}\r\nstatic int __init omap_gpio_sysinit(void)\r\n{\r\nmpuio_init();\r\n#if defined(CONFIG_ARCH_OMAP16XX) || defined(CONFIG_ARCH_OMAP2PLUS)\r\nif (cpu_is_omap16xx() || cpu_class_is_omap2())\r\nregister_syscore_ops(&omap_gpio_syscore_ops);\r\n#endif\r\nreturn 0;\r\n}
