static inline int unsigned_offsets(struct file *file)\r\n{\r\nreturn file->f_mode & FMODE_UNSIGNED_OFFSET;\r\n}\r\nstatic loff_t lseek_execute(struct file *file, struct inode *inode,\r\nloff_t offset, loff_t maxsize)\r\n{\r\nif (offset < 0 && !unsigned_offsets(file))\r\nreturn -EINVAL;\r\nif (offset > maxsize)\r\nreturn -EINVAL;\r\nif (offset != file->f_pos) {\r\nfile->f_pos = offset;\r\nfile->f_version = 0;\r\n}\r\nreturn offset;\r\n}\r\nloff_t\r\ngeneric_file_llseek_size(struct file *file, loff_t offset, int origin,\r\nloff_t maxsize)\r\n{\r\nstruct inode *inode = file->f_mapping->host;\r\nswitch (origin) {\r\ncase SEEK_END:\r\noffset += i_size_read(inode);\r\nbreak;\r\ncase SEEK_CUR:\r\nif (offset == 0)\r\nreturn file->f_pos;\r\nspin_lock(&file->f_lock);\r\noffset = lseek_execute(file, inode, file->f_pos + offset,\r\nmaxsize);\r\nspin_unlock(&file->f_lock);\r\nreturn offset;\r\ncase SEEK_DATA:\r\nif (offset >= i_size_read(inode))\r\nreturn -ENXIO;\r\nbreak;\r\ncase SEEK_HOLE:\r\nif (offset >= i_size_read(inode))\r\nreturn -ENXIO;\r\noffset = i_size_read(inode);\r\nbreak;\r\n}\r\nreturn lseek_execute(file, inode, offset, maxsize);\r\n}\r\nloff_t generic_file_llseek(struct file *file, loff_t offset, int origin)\r\n{\r\nstruct inode *inode = file->f_mapping->host;\r\nreturn generic_file_llseek_size(file, offset, origin,\r\ninode->i_sb->s_maxbytes);\r\n}\r\nloff_t noop_llseek(struct file *file, loff_t offset, int origin)\r\n{\r\nreturn file->f_pos;\r\n}\r\nloff_t no_llseek(struct file *file, loff_t offset, int origin)\r\n{\r\nreturn -ESPIPE;\r\n}\r\nloff_t default_llseek(struct file *file, loff_t offset, int origin)\r\n{\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nloff_t retval;\r\nmutex_lock(&inode->i_mutex);\r\nswitch (origin) {\r\ncase SEEK_END:\r\noffset += i_size_read(inode);\r\nbreak;\r\ncase SEEK_CUR:\r\nif (offset == 0) {\r\nretval = file->f_pos;\r\ngoto out;\r\n}\r\noffset += file->f_pos;\r\nbreak;\r\ncase SEEK_DATA:\r\nif (offset >= inode->i_size) {\r\nretval = -ENXIO;\r\ngoto out;\r\n}\r\nbreak;\r\ncase SEEK_HOLE:\r\nif (offset >= inode->i_size) {\r\nretval = -ENXIO;\r\ngoto out;\r\n}\r\noffset = inode->i_size;\r\nbreak;\r\n}\r\nretval = -EINVAL;\r\nif (offset >= 0 || unsigned_offsets(file)) {\r\nif (offset != file->f_pos) {\r\nfile->f_pos = offset;\r\nfile->f_version = 0;\r\n}\r\nretval = offset;\r\n}\r\nout:\r\nmutex_unlock(&inode->i_mutex);\r\nreturn retval;\r\n}\r\nloff_t vfs_llseek(struct file *file, loff_t offset, int origin)\r\n{\r\nloff_t (*fn)(struct file *, loff_t, int);\r\nfn = no_llseek;\r\nif (file->f_mode & FMODE_LSEEK) {\r\nif (file->f_op && file->f_op->llseek)\r\nfn = file->f_op->llseek;\r\n}\r\nreturn fn(file, offset, origin);\r\n}\r\nint rw_verify_area(int read_write, struct file *file, loff_t *ppos, size_t count)\r\n{\r\nstruct inode *inode;\r\nloff_t pos;\r\nint retval = -EINVAL;\r\ninode = file->f_path.dentry->d_inode;\r\nif (unlikely((ssize_t) count < 0))\r\nreturn retval;\r\npos = *ppos;\r\nif (unlikely(pos < 0)) {\r\nif (!unsigned_offsets(file))\r\nreturn retval;\r\nif (count >= -pos)\r\nreturn -EOVERFLOW;\r\n} else if (unlikely((loff_t) (pos + count) < 0)) {\r\nif (!unsigned_offsets(file))\r\nreturn retval;\r\n}\r\nif (unlikely(inode->i_flock && mandatory_lock(inode))) {\r\nretval = locks_mandatory_area(\r\nread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\r\ninode, file, pos, count);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nretval = security_file_permission(file,\r\nread_write == READ ? MAY_READ : MAY_WRITE);\r\nif (retval)\r\nreturn retval;\r\nreturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\r\n}\r\nstatic void wait_on_retry_sync_kiocb(struct kiocb *iocb)\r\n{\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nif (!kiocbIsKicked(iocb))\r\nschedule();\r\nelse\r\nkiocbClearKicked(iocb);\r\n__set_current_state(TASK_RUNNING);\r\n}\r\nssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\r\n{\r\nstruct iovec iov = { .iov_base = buf, .iov_len = len };\r\nstruct kiocb kiocb;\r\nssize_t ret;\r\ninit_sync_kiocb(&kiocb, filp);\r\nkiocb.ki_pos = *ppos;\r\nkiocb.ki_left = len;\r\nkiocb.ki_nbytes = len;\r\nfor (;;) {\r\nret = filp->f_op->aio_read(&kiocb, &iov, 1, kiocb.ki_pos);\r\nif (ret != -EIOCBRETRY)\r\nbreak;\r\nwait_on_retry_sync_kiocb(&kiocb);\r\n}\r\nif (-EIOCBQUEUED == ret)\r\nret = wait_on_sync_kiocb(&kiocb);\r\n*ppos = kiocb.ki_pos;\r\nreturn ret;\r\n}\r\nssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\r\n{\r\nssize_t ret;\r\nif (!(file->f_mode & FMODE_READ))\r\nreturn -EBADF;\r\nif (!file->f_op || (!file->f_op->read && !file->f_op->aio_read))\r\nreturn -EINVAL;\r\nif (unlikely(!access_ok(VERIFY_WRITE, buf, count)))\r\nreturn -EFAULT;\r\nret = rw_verify_area(READ, file, pos, count);\r\nif (ret >= 0) {\r\ncount = ret;\r\nif (file->f_op->read)\r\nret = file->f_op->read(file, buf, count, pos);\r\nelse\r\nret = do_sync_read(file, buf, count, pos);\r\nif (ret > 0) {\r\nfsnotify_access(file);\r\nadd_rchar(current, ret);\r\n}\r\ninc_syscr(current);\r\n}\r\nreturn ret;\r\n}\r\nssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\r\n{\r\nstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\r\nstruct kiocb kiocb;\r\nssize_t ret;\r\ninit_sync_kiocb(&kiocb, filp);\r\nkiocb.ki_pos = *ppos;\r\nkiocb.ki_left = len;\r\nkiocb.ki_nbytes = len;\r\nfor (;;) {\r\nret = filp->f_op->aio_write(&kiocb, &iov, 1, kiocb.ki_pos);\r\nif (ret != -EIOCBRETRY)\r\nbreak;\r\nwait_on_retry_sync_kiocb(&kiocb);\r\n}\r\nif (-EIOCBQUEUED == ret)\r\nret = wait_on_sync_kiocb(&kiocb);\r\n*ppos = kiocb.ki_pos;\r\nreturn ret;\r\n}\r\nssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\r\n{\r\nssize_t ret;\r\nif (!(file->f_mode & FMODE_WRITE))\r\nreturn -EBADF;\r\nif (!file->f_op || (!file->f_op->write && !file->f_op->aio_write))\r\nreturn -EINVAL;\r\nif (unlikely(!access_ok(VERIFY_READ, buf, count)))\r\nreturn -EFAULT;\r\nret = rw_verify_area(WRITE, file, pos, count);\r\nif (ret >= 0) {\r\ncount = ret;\r\nif (file->f_op->write)\r\nret = file->f_op->write(file, buf, count, pos);\r\nelse\r\nret = do_sync_write(file, buf, count, pos);\r\nif (ret > 0) {\r\nfsnotify_modify(file);\r\nadd_wchar(current, ret);\r\n}\r\ninc_syscw(current);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline loff_t file_pos_read(struct file *file)\r\n{\r\nreturn file->f_pos;\r\n}\r\nstatic inline void file_pos_write(struct file *file, loff_t pos)\r\n{\r\nfile->f_pos = pos;\r\n}\r\nSYSCALL_DEFINE(pread64)(unsigned int fd, char __user *buf,\r\nsize_t count, loff_t pos)\r\n{\r\nstruct file *file;\r\nssize_t ret = -EBADF;\r\nint fput_needed;\r\nif (pos < 0)\r\nreturn -EINVAL;\r\nfile = fget_light(fd, &fput_needed);\r\nif (file) {\r\nret = -ESPIPE;\r\nif (file->f_mode & FMODE_PREAD)\r\nret = vfs_read(file, buf, count, &pos);\r\nfput_light(file, fput_needed);\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage long SyS_pread64(long fd, long buf, long count, loff_t pos)\r\n{\r\nreturn SYSC_pread64((unsigned int) fd, (char __user *) buf,\r\n(size_t) count, pos);\r\n}\r\nSYSCALL_DEFINE(pwrite64)(unsigned int fd, const char __user *buf,\r\nsize_t count, loff_t pos)\r\n{\r\nstruct file *file;\r\nssize_t ret = -EBADF;\r\nint fput_needed;\r\nif (pos < 0)\r\nreturn -EINVAL;\r\nfile = fget_light(fd, &fput_needed);\r\nif (file) {\r\nret = -ESPIPE;\r\nif (file->f_mode & FMODE_PWRITE)\r\nret = vfs_write(file, buf, count, &pos);\r\nfput_light(file, fput_needed);\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage long SyS_pwrite64(long fd, long buf, long count, loff_t pos)\r\n{\r\nreturn SYSC_pwrite64((unsigned int) fd, (const char __user *) buf,\r\n(size_t) count, pos);\r\n}\r\nunsigned long iov_shorten(struct iovec *iov, unsigned long nr_segs, size_t to)\r\n{\r\nunsigned long seg = 0;\r\nsize_t len = 0;\r\nwhile (seg < nr_segs) {\r\nseg++;\r\nif (len + iov->iov_len >= to) {\r\niov->iov_len = to - len;\r\nbreak;\r\n}\r\nlen += iov->iov_len;\r\niov++;\r\n}\r\nreturn seg;\r\n}\r\nssize_t do_sync_readv_writev(struct file *filp, const struct iovec *iov,\r\nunsigned long nr_segs, size_t len, loff_t *ppos, iov_fn_t fn)\r\n{\r\nstruct kiocb kiocb;\r\nssize_t ret;\r\ninit_sync_kiocb(&kiocb, filp);\r\nkiocb.ki_pos = *ppos;\r\nkiocb.ki_left = len;\r\nkiocb.ki_nbytes = len;\r\nfor (;;) {\r\nret = fn(&kiocb, iov, nr_segs, kiocb.ki_pos);\r\nif (ret != -EIOCBRETRY)\r\nbreak;\r\nwait_on_retry_sync_kiocb(&kiocb);\r\n}\r\nif (ret == -EIOCBQUEUED)\r\nret = wait_on_sync_kiocb(&kiocb);\r\n*ppos = kiocb.ki_pos;\r\nreturn ret;\r\n}\r\nssize_t do_loop_readv_writev(struct file *filp, struct iovec *iov,\r\nunsigned long nr_segs, loff_t *ppos, io_fn_t fn)\r\n{\r\nstruct iovec *vector = iov;\r\nssize_t ret = 0;\r\nwhile (nr_segs > 0) {\r\nvoid __user *base;\r\nsize_t len;\r\nssize_t nr;\r\nbase = vector->iov_base;\r\nlen = vector->iov_len;\r\nvector++;\r\nnr_segs--;\r\nnr = fn(filp, base, len, ppos);\r\nif (nr < 0) {\r\nif (!ret)\r\nret = nr;\r\nbreak;\r\n}\r\nret += nr;\r\nif (nr != len)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,\r\nunsigned long nr_segs, unsigned long fast_segs,\r\nstruct iovec *fast_pointer,\r\nstruct iovec **ret_pointer,\r\nint check_access)\r\n{\r\nunsigned long seg;\r\nssize_t ret;\r\nstruct iovec *iov = fast_pointer;\r\nif (nr_segs == 0) {\r\nret = 0;\r\ngoto out;\r\n}\r\nif (nr_segs > UIO_MAXIOV) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (nr_segs > fast_segs) {\r\niov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);\r\nif (iov == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nif (copy_from_user(iov, uvector, nr_segs*sizeof(*uvector))) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nret = 0;\r\nfor (seg = 0; seg < nr_segs; seg++) {\r\nvoid __user *buf = iov[seg].iov_base;\r\nssize_t len = (ssize_t)iov[seg].iov_len;\r\nif (len < 0) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (check_access\r\n&& unlikely(!access_ok(vrfy_dir(type), buf, len))) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif (len > MAX_RW_COUNT - ret) {\r\nlen = MAX_RW_COUNT - ret;\r\niov[seg].iov_len = len;\r\n}\r\nret += len;\r\n}\r\nout:\r\n*ret_pointer = iov;\r\nreturn ret;\r\n}\r\nstatic ssize_t do_readv_writev(int type, struct file *file,\r\nconst struct iovec __user * uvector,\r\nunsigned long nr_segs, loff_t *pos)\r\n{\r\nsize_t tot_len;\r\nstruct iovec iovstack[UIO_FASTIOV];\r\nstruct iovec *iov = iovstack;\r\nssize_t ret;\r\nio_fn_t fn;\r\niov_fn_t fnv;\r\nif (!file->f_op) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = rw_copy_check_uvector(type, uvector, nr_segs,\r\nARRAY_SIZE(iovstack), iovstack, &iov, 1);\r\nif (ret <= 0)\r\ngoto out;\r\ntot_len = ret;\r\nret = rw_verify_area(type, file, pos, tot_len);\r\nif (ret < 0)\r\ngoto out;\r\nfnv = NULL;\r\nif (type == READ) {\r\nfn = file->f_op->read;\r\nfnv = file->f_op->aio_read;\r\n} else {\r\nfn = (io_fn_t)file->f_op->write;\r\nfnv = file->f_op->aio_write;\r\n}\r\nif (fnv)\r\nret = do_sync_readv_writev(file, iov, nr_segs, tot_len,\r\npos, fnv);\r\nelse\r\nret = do_loop_readv_writev(file, iov, nr_segs, pos, fn);\r\nout:\r\nif (iov != iovstack)\r\nkfree(iov);\r\nif ((ret + (type == READ)) > 0) {\r\nif (type == READ)\r\nfsnotify_access(file);\r\nelse\r\nfsnotify_modify(file);\r\n}\r\nreturn ret;\r\n}\r\nssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\r\nunsigned long vlen, loff_t *pos)\r\n{\r\nif (!(file->f_mode & FMODE_READ))\r\nreturn -EBADF;\r\nif (!file->f_op || (!file->f_op->aio_read && !file->f_op->read))\r\nreturn -EINVAL;\r\nreturn do_readv_writev(READ, file, vec, vlen, pos);\r\n}\r\nssize_t vfs_writev(struct file *file, const struct iovec __user *vec,\r\nunsigned long vlen, loff_t *pos)\r\n{\r\nif (!(file->f_mode & FMODE_WRITE))\r\nreturn -EBADF;\r\nif (!file->f_op || (!file->f_op->aio_write && !file->f_op->write))\r\nreturn -EINVAL;\r\nreturn do_readv_writev(WRITE, file, vec, vlen, pos);\r\n}\r\nstatic inline loff_t pos_from_hilo(unsigned long high, unsigned long low)\r\n{\r\n#define HALF_LONG_BITS (BITS_PER_LONG / 2)\r\nreturn (((loff_t)high << HALF_LONG_BITS) << HALF_LONG_BITS) | low;\r\n}\r\nstatic ssize_t do_sendfile(int out_fd, int in_fd, loff_t *ppos,\r\nsize_t count, loff_t max)\r\n{\r\nstruct file * in_file, * out_file;\r\nstruct inode * in_inode, * out_inode;\r\nloff_t pos;\r\nssize_t retval;\r\nint fput_needed_in, fput_needed_out, fl;\r\nretval = -EBADF;\r\nin_file = fget_light(in_fd, &fput_needed_in);\r\nif (!in_file)\r\ngoto out;\r\nif (!(in_file->f_mode & FMODE_READ))\r\ngoto fput_in;\r\nretval = -ESPIPE;\r\nif (!ppos)\r\nppos = &in_file->f_pos;\r\nelse\r\nif (!(in_file->f_mode & FMODE_PREAD))\r\ngoto fput_in;\r\nretval = rw_verify_area(READ, in_file, ppos, count);\r\nif (retval < 0)\r\ngoto fput_in;\r\ncount = retval;\r\nretval = -EBADF;\r\nout_file = fget_light(out_fd, &fput_needed_out);\r\nif (!out_file)\r\ngoto fput_in;\r\nif (!(out_file->f_mode & FMODE_WRITE))\r\ngoto fput_out;\r\nretval = -EINVAL;\r\nin_inode = in_file->f_path.dentry->d_inode;\r\nout_inode = out_file->f_path.dentry->d_inode;\r\nretval = rw_verify_area(WRITE, out_file, &out_file->f_pos, count);\r\nif (retval < 0)\r\ngoto fput_out;\r\ncount = retval;\r\nif (!max)\r\nmax = min(in_inode->i_sb->s_maxbytes, out_inode->i_sb->s_maxbytes);\r\npos = *ppos;\r\nif (unlikely(pos + count > max)) {\r\nretval = -EOVERFLOW;\r\nif (pos >= max)\r\ngoto fput_out;\r\ncount = max - pos;\r\n}\r\nfl = 0;\r\n#if 0\r\nif (in_file->f_flags & O_NONBLOCK)\r\nfl = SPLICE_F_NONBLOCK;\r\n#endif\r\nretval = do_splice_direct(in_file, ppos, out_file, count, fl);\r\nif (retval > 0) {\r\nadd_rchar(current, retval);\r\nadd_wchar(current, retval);\r\n}\r\ninc_syscr(current);\r\ninc_syscw(current);\r\nif (*ppos > max)\r\nretval = -EOVERFLOW;\r\nfput_out:\r\nfput_light(out_file, fput_needed_out);\r\nfput_in:\r\nfput_light(in_file, fput_needed_in);\r\nout:\r\nreturn retval;\r\n}
