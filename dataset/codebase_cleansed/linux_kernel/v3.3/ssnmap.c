static inline size_t sctp_ssnmap_size(__u16 in, __u16 out)\r\n{\r\nreturn sizeof(struct sctp_ssnmap) + (in + out) * sizeof(__u16);\r\n}\r\nstruct sctp_ssnmap *sctp_ssnmap_new(__u16 in, __u16 out,\r\ngfp_t gfp)\r\n{\r\nstruct sctp_ssnmap *retval;\r\nint size;\r\nsize = sctp_ssnmap_size(in, out);\r\nif (size <= MAX_KMALLOC_SIZE)\r\nretval = kmalloc(size, gfp);\r\nelse\r\nretval = (struct sctp_ssnmap *)\r\n__get_free_pages(gfp, get_order(size));\r\nif (!retval)\r\ngoto fail;\r\nif (!sctp_ssnmap_init(retval, in, out))\r\ngoto fail_map;\r\nretval->malloced = 1;\r\nSCTP_DBG_OBJCNT_INC(ssnmap);\r\nreturn retval;\r\nfail_map:\r\nif (size <= MAX_KMALLOC_SIZE)\r\nkfree(retval);\r\nelse\r\nfree_pages((unsigned long)retval, get_order(size));\r\nfail:\r\nreturn NULL;\r\n}\r\nstatic struct sctp_ssnmap *sctp_ssnmap_init(struct sctp_ssnmap *map, __u16 in,\r\n__u16 out)\r\n{\r\nmemset(map, 0x00, sctp_ssnmap_size(in, out));\r\nmap->in.ssn = (__u16 *)&map[1];\r\nmap->in.len = in;\r\nmap->out.ssn = &map->in.ssn[in];\r\nmap->out.len = out;\r\nreturn map;\r\n}\r\nvoid sctp_ssnmap_clear(struct sctp_ssnmap *map)\r\n{\r\nsize_t size;\r\nsize = (map->in.len + map->out.len) * sizeof(__u16);\r\nmemset(map->in.ssn, 0x00, size);\r\n}\r\nvoid sctp_ssnmap_free(struct sctp_ssnmap *map)\r\n{\r\nif (map && map->malloced) {\r\nint size;\r\nsize = sctp_ssnmap_size(map->in.len, map->out.len);\r\nif (size <= MAX_KMALLOC_SIZE)\r\nkfree(map);\r\nelse\r\nfree_pages((unsigned long)map, get_order(size));\r\nSCTP_DBG_OBJCNT_DEC(ssnmap);\r\n}\r\n}
