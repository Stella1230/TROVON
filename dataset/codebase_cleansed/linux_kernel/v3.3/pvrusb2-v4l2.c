static long pvr2_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_v4l2 *vp = fh->vhead;\r\nstruct pvr2_v4l2_dev *pdi = fh->pdi;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nlong ret = -EINVAL;\r\nif (pvrusb2_debug & PVR2_TRACE_V4LIOCTL) {\r\nv4l_print_ioctl(pvr2_hdw_get_driver_name(hdw),cmd);\r\n}\r\nif (!pvr2_hdw_dev_ok(hdw)) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"ioctl failed - bad or no context");\r\nreturn -EFAULT;\r\n}\r\nswitch (cmd) {\r\ncase VIDIOC_S_CTRL:\r\ncase VIDIOC_S_STD:\r\ncase VIDIOC_S_INPUT:\r\ncase VIDIOC_S_TUNER:\r\ncase VIDIOC_S_FREQUENCY:\r\nret = v4l2_prio_check(&vp->prio, fh->prio);\r\nif (ret)\r\nreturn ret;\r\n}\r\nswitch (cmd) {\r\ncase VIDIOC_QUERYCAP:\r\n{\r\nstruct v4l2_capability *cap = arg;\r\nmemcpy(cap, &pvr_capability, sizeof(struct v4l2_capability));\r\nstrlcpy(cap->bus_info,pvr2_hdw_get_bus_info(hdw),\r\nsizeof(cap->bus_info));\r\nstrlcpy(cap->card,pvr2_hdw_get_desc(hdw),sizeof(cap->card));\r\nret = 0;\r\nbreak;\r\n}\r\ncase VIDIOC_G_PRIORITY:\r\n{\r\nenum v4l2_priority *p = arg;\r\n*p = v4l2_prio_max(&vp->prio);\r\nret = 0;\r\nbreak;\r\n}\r\ncase VIDIOC_S_PRIORITY:\r\n{\r\nenum v4l2_priority *prio = arg;\r\nret = v4l2_prio_change(&vp->prio, &fh->prio, *prio);\r\nbreak;\r\n}\r\ncase VIDIOC_ENUMSTD:\r\n{\r\nstruct v4l2_standard *vs = (struct v4l2_standard *)arg;\r\nint idx = vs->index;\r\nret = pvr2_hdw_get_stdenum_value(hdw,vs,idx+1);\r\nbreak;\r\n}\r\ncase VIDIOC_QUERYSTD:\r\n{\r\nv4l2_std_id *std = arg;\r\n*std = V4L2_STD_ALL;\r\nret = pvr2_hdw_get_detected_std(hdw, std);\r\nbreak;\r\n}\r\ncase VIDIOC_G_STD:\r\n{\r\nint val = 0;\r\nret = pvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_STDCUR),&val);\r\n*(v4l2_std_id *)arg = val;\r\nbreak;\r\n}\r\ncase VIDIOC_S_STD:\r\n{\r\nret = pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_STDCUR),\r\n*(v4l2_std_id *)arg);\r\nbreak;\r\n}\r\ncase VIDIOC_ENUMINPUT:\r\n{\r\nstruct pvr2_ctrl *cptr;\r\nstruct v4l2_input *vi = (struct v4l2_input *)arg;\r\nstruct v4l2_input tmp;\r\nunsigned int cnt;\r\nint val;\r\ncptr = pvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_INPUT);\r\nmemset(&tmp,0,sizeof(tmp));\r\ntmp.index = vi->index;\r\nret = 0;\r\nif (vi->index >= fh->input_cnt) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nval = fh->input_map[vi->index];\r\nswitch (val) {\r\ncase PVR2_CVAL_INPUT_TV:\r\ncase PVR2_CVAL_INPUT_DTV:\r\ncase PVR2_CVAL_INPUT_RADIO:\r\ntmp.type = V4L2_INPUT_TYPE_TUNER;\r\nbreak;\r\ncase PVR2_CVAL_INPUT_SVIDEO:\r\ncase PVR2_CVAL_INPUT_COMPOSITE:\r\ntmp.type = V4L2_INPUT_TYPE_CAMERA;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret < 0) break;\r\ncnt = 0;\r\npvr2_ctrl_get_valname(cptr,val,\r\ntmp.name,sizeof(tmp.name)-1,&cnt);\r\ntmp.name[cnt] = 0;\r\nmemcpy(vi, &tmp, sizeof(tmp));\r\nret = 0;\r\nbreak;\r\n}\r\ncase VIDIOC_G_INPUT:\r\n{\r\nunsigned int idx;\r\nstruct pvr2_ctrl *cptr;\r\nstruct v4l2_input *vi = (struct v4l2_input *)arg;\r\nint val;\r\ncptr = pvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_INPUT);\r\nval = 0;\r\nret = pvr2_ctrl_get_value(cptr,&val);\r\nvi->index = 0;\r\nfor (idx = 0; idx < fh->input_cnt; idx++) {\r\nif (fh->input_map[idx] == val) {\r\nvi->index = idx;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_S_INPUT:\r\n{\r\nstruct v4l2_input *vi = (struct v4l2_input *)arg;\r\nif (vi->index >= fh->input_cnt) {\r\nret = -ERANGE;\r\nbreak;\r\n}\r\nret = pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_INPUT),\r\nfh->input_map[vi->index]);\r\nbreak;\r\n}\r\ncase VIDIOC_ENUMAUDIO:\r\n{\r\nstruct v4l2_audio *vin = arg;\r\nret = -EINVAL;\r\nif (vin->index > 0) break;\r\nstrncpy(vin->name, "PVRUSB2 Audio",14);\r\nvin->capability = V4L2_AUDCAP_STEREO;\r\nret = 0;\r\nbreak;\r\nbreak;\r\n}\r\ncase VIDIOC_G_AUDIO:\r\n{\r\nstruct v4l2_audio *vin = arg;\r\nmemset(vin,0,sizeof(*vin));\r\nvin->index = 0;\r\nstrncpy(vin->name, "PVRUSB2 Audio",14);\r\nvin->capability = V4L2_AUDCAP_STEREO;\r\nret = 0;\r\nbreak;\r\n}\r\ncase VIDIOC_G_TUNER:\r\n{\r\nstruct v4l2_tuner *vt = (struct v4l2_tuner *)arg;\r\nif (vt->index != 0) break;\r\npvr2_hdw_execute_tuner_poll(hdw);\r\nret = pvr2_hdw_get_tuner_status(hdw,vt);\r\nbreak;\r\n}\r\ncase VIDIOC_S_TUNER:\r\n{\r\nstruct v4l2_tuner *vt=(struct v4l2_tuner *)arg;\r\nif (vt->index != 0)\r\nbreak;\r\nret = pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_AUDIOMODE),\r\nvt->audmode);\r\nbreak;\r\n}\r\ncase VIDIOC_S_FREQUENCY:\r\n{\r\nconst struct v4l2_frequency *vf = (struct v4l2_frequency *)arg;\r\nunsigned long fv;\r\nstruct v4l2_tuner vt;\r\nint cur_input;\r\nstruct pvr2_ctrl *ctrlp;\r\nret = pvr2_hdw_get_tuner_status(hdw,&vt);\r\nif (ret != 0) break;\r\nctrlp = pvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_INPUT);\r\nret = pvr2_ctrl_get_value(ctrlp,&cur_input);\r\nif (ret != 0) break;\r\nif (vf->type == V4L2_TUNER_RADIO) {\r\nif (cur_input != PVR2_CVAL_INPUT_RADIO) {\r\npvr2_ctrl_set_value(ctrlp,\r\nPVR2_CVAL_INPUT_RADIO);\r\n}\r\n} else {\r\nif (cur_input == PVR2_CVAL_INPUT_RADIO) {\r\npvr2_ctrl_set_value(ctrlp,\r\nPVR2_CVAL_INPUT_TV);\r\n}\r\n}\r\nfv = vf->frequency;\r\nif (vt.capability & V4L2_TUNER_CAP_LOW) {\r\nfv = (fv * 125) / 2;\r\n} else {\r\nfv = fv * 62500;\r\n}\r\nret = pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_FREQUENCY),fv);\r\nbreak;\r\n}\r\ncase VIDIOC_G_FREQUENCY:\r\n{\r\nstruct v4l2_frequency *vf = (struct v4l2_frequency *)arg;\r\nint val = 0;\r\nint cur_input;\r\nstruct v4l2_tuner vt;\r\nret = pvr2_hdw_get_tuner_status(hdw,&vt);\r\nif (ret != 0) break;\r\nret = pvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_FREQUENCY),\r\n&val);\r\nif (ret != 0) break;\r\npvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_INPUT),\r\n&cur_input);\r\nif (cur_input == PVR2_CVAL_INPUT_RADIO) {\r\nvf->type = V4L2_TUNER_RADIO;\r\n} else {\r\nvf->type = V4L2_TUNER_ANALOG_TV;\r\n}\r\nif (vt.capability & V4L2_TUNER_CAP_LOW) {\r\nval = (val * 2) / 125;\r\n} else {\r\nval /= 62500;\r\n}\r\nvf->frequency = val;\r\nbreak;\r\n}\r\ncase VIDIOC_ENUM_FMT:\r\n{\r\nstruct v4l2_fmtdesc *fd = (struct v4l2_fmtdesc *)arg;\r\nif (fd->index != 0)\r\nbreak;\r\nmemcpy(fd, pvr_fmtdesc, sizeof(struct v4l2_fmtdesc));\r\nret = 0;\r\nbreak;\r\n}\r\ncase VIDIOC_G_FMT:\r\n{\r\nstruct v4l2_format *vf = (struct v4l2_format *)arg;\r\nint val;\r\nswitch(vf->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nmemcpy(vf, &pvr_format[PVR_FORMAT_PIX],\r\nsizeof(struct v4l2_format));\r\nval = 0;\r\npvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_HRES),\r\n&val);\r\nvf->fmt.pix.width = val;\r\nval = 0;\r\npvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_VRES),\r\n&val);\r\nvf->fmt.pix.height = val;\r\nret = 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nret = -EINVAL;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_TRY_FMT:\r\ncase VIDIOC_S_FMT:\r\n{\r\nstruct v4l2_format *vf = (struct v4l2_format *)arg;\r\nret = 0;\r\nswitch(vf->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE: {\r\nint lmin,lmax,ldef;\r\nstruct pvr2_ctrl *hcp,*vcp;\r\nint h = vf->fmt.pix.height;\r\nint w = vf->fmt.pix.width;\r\nhcp = pvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_HRES);\r\nvcp = pvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_VRES);\r\nlmin = pvr2_ctrl_get_min(hcp);\r\nlmax = pvr2_ctrl_get_max(hcp);\r\npvr2_ctrl_get_def(hcp, &ldef);\r\nif (w == -1) {\r\nw = ldef;\r\n} else if (w < lmin) {\r\nw = lmin;\r\n} else if (w > lmax) {\r\nw = lmax;\r\n}\r\nlmin = pvr2_ctrl_get_min(vcp);\r\nlmax = pvr2_ctrl_get_max(vcp);\r\npvr2_ctrl_get_def(vcp, &ldef);\r\nif (h == -1) {\r\nh = ldef;\r\n} else if (h < lmin) {\r\nh = lmin;\r\n} else if (h > lmax) {\r\nh = lmax;\r\n}\r\nmemcpy(vf, &pvr_format[PVR_FORMAT_PIX],\r\nsizeof(struct v4l2_format));\r\nvf->fmt.pix.width = w;\r\nvf->fmt.pix.height = h;\r\nif (cmd == VIDIOC_S_FMT) {\r\npvr2_ctrl_set_value(hcp,vf->fmt.pix.width);\r\npvr2_ctrl_set_value(vcp,vf->fmt.pix.height);\r\n}\r\n} break;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nret = -EINVAL;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_STREAMON:\r\n{\r\nif (!fh->pdi->stream) {\r\nret = -EPERM;\r\nbreak;\r\n}\r\nret = pvr2_hdw_set_stream_type(hdw,pdi->config);\r\nif (ret < 0) return ret;\r\nret = pvr2_hdw_set_streaming(hdw,!0);\r\nbreak;\r\n}\r\ncase VIDIOC_STREAMOFF:\r\n{\r\nif (!fh->pdi->stream) {\r\nret = -EPERM;\r\nbreak;\r\n}\r\nret = pvr2_hdw_set_streaming(hdw,0);\r\nbreak;\r\n}\r\ncase VIDIOC_QUERYCTRL:\r\n{\r\nstruct pvr2_ctrl *cptr;\r\nint val;\r\nstruct v4l2_queryctrl *vc = (struct v4l2_queryctrl *)arg;\r\nret = 0;\r\nif (vc->id & V4L2_CTRL_FLAG_NEXT_CTRL) {\r\ncptr = pvr2_hdw_get_ctrl_nextv4l(\r\nhdw,(vc->id & ~V4L2_CTRL_FLAG_NEXT_CTRL));\r\nif (cptr) vc->id = pvr2_ctrl_get_v4lid(cptr);\r\n} else {\r\ncptr = pvr2_hdw_get_ctrl_v4l(hdw,vc->id);\r\n}\r\nif (!cptr) {\r\npvr2_trace(PVR2_TRACE_V4LIOCTL,\r\n"QUERYCTRL id=0x%x not implemented here",\r\nvc->id);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\npvr2_trace(PVR2_TRACE_V4LIOCTL,\r\n"QUERYCTRL id=0x%x mapping name=%s (%s)",\r\nvc->id,pvr2_ctrl_get_name(cptr),\r\npvr2_ctrl_get_desc(cptr));\r\nstrlcpy(vc->name,pvr2_ctrl_get_desc(cptr),sizeof(vc->name));\r\nvc->flags = pvr2_ctrl_get_v4lflags(cptr);\r\npvr2_ctrl_get_def(cptr, &val);\r\nvc->default_value = val;\r\nswitch (pvr2_ctrl_get_type(cptr)) {\r\ncase pvr2_ctl_enum:\r\nvc->type = V4L2_CTRL_TYPE_MENU;\r\nvc->minimum = 0;\r\nvc->maximum = pvr2_ctrl_get_cnt(cptr) - 1;\r\nvc->step = 1;\r\nbreak;\r\ncase pvr2_ctl_bool:\r\nvc->type = V4L2_CTRL_TYPE_BOOLEAN;\r\nvc->minimum = 0;\r\nvc->maximum = 1;\r\nvc->step = 1;\r\nbreak;\r\ncase pvr2_ctl_int:\r\nvc->type = V4L2_CTRL_TYPE_INTEGER;\r\nvc->minimum = pvr2_ctrl_get_min(cptr);\r\nvc->maximum = pvr2_ctrl_get_max(cptr);\r\nvc->step = 1;\r\nbreak;\r\ndefault:\r\npvr2_trace(PVR2_TRACE_V4LIOCTL,\r\n"QUERYCTRL id=0x%x name=%s not mappable",\r\nvc->id,pvr2_ctrl_get_name(cptr));\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_QUERYMENU:\r\n{\r\nstruct v4l2_querymenu *vm = (struct v4l2_querymenu *)arg;\r\nunsigned int cnt = 0;\r\nret = pvr2_ctrl_get_valname(pvr2_hdw_get_ctrl_v4l(hdw,vm->id),\r\nvm->index,\r\nvm->name,sizeof(vm->name)-1,\r\n&cnt);\r\nvm->name[cnt] = 0;\r\nbreak;\r\n}\r\ncase VIDIOC_G_CTRL:\r\n{\r\nstruct v4l2_control *vc = (struct v4l2_control *)arg;\r\nint val = 0;\r\nret = pvr2_ctrl_get_value(pvr2_hdw_get_ctrl_v4l(hdw,vc->id),\r\n&val);\r\nvc->value = val;\r\nbreak;\r\n}\r\ncase VIDIOC_S_CTRL:\r\n{\r\nstruct v4l2_control *vc = (struct v4l2_control *)arg;\r\nret = pvr2_ctrl_set_value(pvr2_hdw_get_ctrl_v4l(hdw,vc->id),\r\nvc->value);\r\nbreak;\r\n}\r\ncase VIDIOC_G_EXT_CTRLS:\r\n{\r\nstruct v4l2_ext_controls *ctls =\r\n(struct v4l2_ext_controls *)arg;\r\nstruct v4l2_ext_control *ctrl;\r\nunsigned int idx;\r\nint val;\r\nret = 0;\r\nfor (idx = 0; idx < ctls->count; idx++) {\r\nctrl = ctls->controls + idx;\r\nret = pvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_v4l(hdw,ctrl->id),&val);\r\nif (ret) {\r\nctls->error_idx = idx;\r\nbreak;\r\n}\r\nctrl->value64 = 0;\r\nctrl->value = val;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_S_EXT_CTRLS:\r\n{\r\nstruct v4l2_ext_controls *ctls =\r\n(struct v4l2_ext_controls *)arg;\r\nstruct v4l2_ext_control *ctrl;\r\nunsigned int idx;\r\nret = 0;\r\nfor (idx = 0; idx < ctls->count; idx++) {\r\nctrl = ctls->controls + idx;\r\nret = pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_v4l(hdw,ctrl->id),\r\nctrl->value);\r\nif (ret) {\r\nctls->error_idx = idx;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_TRY_EXT_CTRLS:\r\n{\r\nstruct v4l2_ext_controls *ctls =\r\n(struct v4l2_ext_controls *)arg;\r\nstruct v4l2_ext_control *ctrl;\r\nstruct pvr2_ctrl *pctl;\r\nunsigned int idx;\r\nret = 0;\r\nfor (idx = 0; idx < ctls->count; idx++) {\r\nctrl = ctls->controls + idx;\r\npctl = pvr2_hdw_get_ctrl_v4l(hdw,ctrl->id);\r\nif (!pctl) {\r\nret = -EINVAL;\r\nctls->error_idx = idx;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_CROPCAP:\r\n{\r\nstruct v4l2_cropcap *cap = (struct v4l2_cropcap *)arg;\r\nif (cap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = pvr2_hdw_get_cropcap(hdw, cap);\r\ncap->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nbreak;\r\n}\r\ncase VIDIOC_G_CROP:\r\n{\r\nstruct v4l2_crop *crop = (struct v4l2_crop *)arg;\r\nint val = 0;\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = pvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPL), &val);\r\nif (ret != 0) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ncrop->c.left = val;\r\nret = pvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPT), &val);\r\nif (ret != 0) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ncrop->c.top = val;\r\nret = pvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPW), &val);\r\nif (ret != 0) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ncrop->c.width = val;\r\nret = pvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPH), &val);\r\nif (ret != 0) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ncrop->c.height = val;\r\n}\r\ncase VIDIOC_S_CROP:\r\n{\r\nstruct v4l2_crop *crop = (struct v4l2_crop *)arg;\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPL),\r\ncrop->c.left);\r\nif (ret != 0) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPT),\r\ncrop->c.top);\r\nif (ret != 0) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPW),\r\ncrop->c.width);\r\nif (ret != 0) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPH),\r\ncrop->c.height);\r\nif (ret != 0) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n}\r\ncase VIDIOC_LOG_STATUS:\r\n{\r\npvr2_hdw_trigger_module_log(hdw);\r\nret = 0;\r\nbreak;\r\n}\r\n#ifdef CONFIG_VIDEO_ADV_DEBUG\r\ncase VIDIOC_DBG_S_REGISTER:\r\ncase VIDIOC_DBG_G_REGISTER:\r\n{\r\nu64 val;\r\nstruct v4l2_dbg_register *req = (struct v4l2_dbg_register *)arg;\r\nif (cmd == VIDIOC_DBG_S_REGISTER) val = req->val;\r\nret = pvr2_hdw_register_access(\r\nhdw, &req->match, req->reg,\r\ncmd == VIDIOC_DBG_S_REGISTER, &val);\r\nif (cmd == VIDIOC_DBG_G_REGISTER) req->val = val;\r\nbreak;\r\n}\r\n#endif\r\ndefault :\r\nret = -ENOTTY;\r\nbreak;\r\n}\r\npvr2_hdw_commit_ctl(hdw);\r\nif (ret < 0) {\r\nif (pvrusb2_debug & PVR2_TRACE_V4LIOCTL) {\r\npvr2_trace(PVR2_TRACE_V4LIOCTL,\r\n"pvr2_v4l2_do_ioctl failure, ret=%ld", ret);\r\n} else {\r\nif (pvrusb2_debug & PVR2_TRACE_V4LIOCTL) {\r\npvr2_trace(PVR2_TRACE_V4LIOCTL,\r\n"pvr2_v4l2_do_ioctl failure, ret=%ld"\r\n" command was:", ret);\r\nv4l_print_ioctl(pvr2_hdw_get_driver_name(hdw),\r\ncmd);\r\n}\r\n}\r\n} else {\r\npvr2_trace(PVR2_TRACE_V4LIOCTL,\r\n"pvr2_v4l2_do_ioctl complete, ret=%ld (0x%lx)",\r\nret, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic void pvr2_v4l2_dev_destroy(struct pvr2_v4l2_dev *dip)\r\n{\r\nstruct pvr2_hdw *hdw = dip->v4lp->channel.mc_head->hdw;\r\nenum pvr2_config cfg = dip->config;\r\nchar msg[80];\r\nunsigned int mcnt;\r\nmcnt = scnprintf(msg, sizeof(msg) - 1,\r\n"pvrusb2: unregistered device %s [%s]",\r\nvideo_device_node_name(&dip->devbase),\r\npvr2_config_get_name(cfg));\r\nmsg[mcnt] = 0;\r\npvr2_hdw_v4l_store_minor_number(hdw,dip->minor_type,-1);\r\ndip->v4lp = NULL;\r\ndip->stream = NULL;\r\nvideo_unregister_device(&dip->devbase);\r\nprintk(KERN_INFO "%s\n", msg);\r\n}\r\nstatic void pvr2_v4l2_dev_disassociate_parent(struct pvr2_v4l2_dev *dip)\r\n{\r\nif (!dip) return;\r\nif (!dip->devbase.parent) return;\r\ndip->devbase.parent = NULL;\r\ndevice_move(&dip->devbase.dev, NULL, DPM_ORDER_NONE);\r\n}\r\nstatic void pvr2_v4l2_destroy_no_lock(struct pvr2_v4l2 *vp)\r\n{\r\nif (vp->dev_video) {\r\npvr2_v4l2_dev_destroy(vp->dev_video);\r\nvp->dev_video = NULL;\r\n}\r\nif (vp->dev_radio) {\r\npvr2_v4l2_dev_destroy(vp->dev_radio);\r\nvp->dev_radio = NULL;\r\n}\r\npvr2_trace(PVR2_TRACE_STRUCT,"Destroying pvr2_v4l2 id=%p",vp);\r\npvr2_channel_done(&vp->channel);\r\nkfree(vp);\r\n}\r\nstatic void pvr2_video_device_release(struct video_device *vdev)\r\n{\r\nstruct pvr2_v4l2_dev *dev;\r\ndev = container_of(vdev,struct pvr2_v4l2_dev,devbase);\r\nkfree(dev);\r\n}\r\nstatic void pvr2_v4l2_internal_check(struct pvr2_channel *chp)\r\n{\r\nstruct pvr2_v4l2 *vp;\r\nvp = container_of(chp,struct pvr2_v4l2,channel);\r\nif (!vp->channel.mc_head->disconnect_flag) return;\r\npvr2_v4l2_dev_disassociate_parent(vp->dev_video);\r\npvr2_v4l2_dev_disassociate_parent(vp->dev_radio);\r\nif (vp->vfirst) return;\r\npvr2_v4l2_destroy_no_lock(vp);\r\n}\r\nstatic long pvr2_v4l2_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn video_usercopy(file, cmd, arg, pvr2_v4l2_do_ioctl);\r\n}\r\nstatic int pvr2_v4l2_release(struct file *file)\r\n{\r\nstruct pvr2_v4l2_fh *fhp = file->private_data;\r\nstruct pvr2_v4l2 *vp = fhp->vhead;\r\nstruct pvr2_hdw *hdw = fhp->channel.mc_head->hdw;\r\npvr2_trace(PVR2_TRACE_OPEN_CLOSE,"pvr2_v4l2_release");\r\nif (fhp->rhp) {\r\nstruct pvr2_stream *sp;\r\npvr2_hdw_set_streaming(hdw,0);\r\nsp = pvr2_ioread_get_stream(fhp->rhp);\r\nif (sp) pvr2_stream_set_callback(sp,NULL,NULL);\r\npvr2_ioread_destroy(fhp->rhp);\r\nfhp->rhp = NULL;\r\n}\r\nv4l2_prio_close(&vp->prio, fhp->prio);\r\nfile->private_data = NULL;\r\nif (fhp->vnext) {\r\nfhp->vnext->vprev = fhp->vprev;\r\n} else {\r\nvp->vlast = fhp->vprev;\r\n}\r\nif (fhp->vprev) {\r\nfhp->vprev->vnext = fhp->vnext;\r\n} else {\r\nvp->vfirst = fhp->vnext;\r\n}\r\nfhp->vnext = NULL;\r\nfhp->vprev = NULL;\r\nfhp->vhead = NULL;\r\npvr2_channel_done(&fhp->channel);\r\npvr2_trace(PVR2_TRACE_STRUCT,\r\n"Destroying pvr_v4l2_fh id=%p",fhp);\r\nif (fhp->input_map) {\r\nkfree(fhp->input_map);\r\nfhp->input_map = NULL;\r\n}\r\nkfree(fhp);\r\nif (vp->channel.mc_head->disconnect_flag && !vp->vfirst) {\r\npvr2_v4l2_destroy_no_lock(vp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pvr2_v4l2_open(struct file *file)\r\n{\r\nstruct pvr2_v4l2_dev *dip;\r\nstruct pvr2_v4l2_fh *fhp;\r\nstruct pvr2_v4l2 *vp;\r\nstruct pvr2_hdw *hdw;\r\nunsigned int input_mask = 0;\r\nunsigned int input_cnt,idx;\r\nint ret = 0;\r\ndip = container_of(video_devdata(file),struct pvr2_v4l2_dev,devbase);\r\nvp = dip->v4lp;\r\nhdw = vp->channel.hdw;\r\npvr2_trace(PVR2_TRACE_OPEN_CLOSE,"pvr2_v4l2_open");\r\nif (!pvr2_hdw_dev_ok(hdw)) {\r\npvr2_trace(PVR2_TRACE_OPEN_CLOSE,\r\n"pvr2_v4l2_open: hardware not ready");\r\nreturn -EIO;\r\n}\r\nfhp = kzalloc(sizeof(*fhp),GFP_KERNEL);\r\nif (!fhp) {\r\nreturn -ENOMEM;\r\n}\r\ninit_waitqueue_head(&fhp->wait_data);\r\nfhp->pdi = dip;\r\npvr2_trace(PVR2_TRACE_STRUCT,"Creating pvr_v4l2_fh id=%p",fhp);\r\npvr2_channel_init(&fhp->channel,vp->channel.mc_head);\r\nif (dip->v4l_type == VFL_TYPE_RADIO) {\r\ninput_mask = (1 << PVR2_CVAL_INPUT_RADIO);\r\n} else {\r\ninput_mask = ((1 << PVR2_CVAL_INPUT_RADIO) |\r\n(1 << PVR2_CVAL_INPUT_TV) |\r\n(1 << PVR2_CVAL_INPUT_COMPOSITE) |\r\n(1 << PVR2_CVAL_INPUT_SVIDEO));\r\n}\r\nret = pvr2_channel_limit_inputs(&fhp->channel,input_mask);\r\nif (ret) {\r\npvr2_channel_done(&fhp->channel);\r\npvr2_trace(PVR2_TRACE_STRUCT,\r\n"Destroying pvr_v4l2_fh id=%p (input mask error)",\r\nfhp);\r\nkfree(fhp);\r\nreturn ret;\r\n}\r\ninput_mask &= pvr2_hdw_get_input_available(hdw);\r\ninput_cnt = 0;\r\nfor (idx = 0; idx < (sizeof(input_mask) << 3); idx++) {\r\nif (input_mask & (1 << idx)) input_cnt++;\r\n}\r\nfhp->input_cnt = input_cnt;\r\nfhp->input_map = kzalloc(input_cnt,GFP_KERNEL);\r\nif (!fhp->input_map) {\r\npvr2_channel_done(&fhp->channel);\r\npvr2_trace(PVR2_TRACE_STRUCT,\r\n"Destroying pvr_v4l2_fh id=%p (input map failure)",\r\nfhp);\r\nkfree(fhp);\r\nreturn -ENOMEM;\r\n}\r\ninput_cnt = 0;\r\nfor (idx = 0; idx < (sizeof(input_mask) << 3); idx++) {\r\nif (!(input_mask & (1 << idx))) continue;\r\nfhp->input_map[input_cnt++] = idx;\r\n}\r\nfhp->vnext = NULL;\r\nfhp->vprev = vp->vlast;\r\nif (vp->vlast) {\r\nvp->vlast->vnext = fhp;\r\n} else {\r\nvp->vfirst = fhp;\r\n}\r\nvp->vlast = fhp;\r\nfhp->vhead = vp;\r\nfhp->file = file;\r\nfile->private_data = fhp;\r\nv4l2_prio_open(&vp->prio, &fhp->prio);\r\nfhp->fw_mode_flag = pvr2_hdw_cpufw_get_enabled(hdw);\r\nreturn 0;\r\n}\r\nstatic void pvr2_v4l2_notify(struct pvr2_v4l2_fh *fhp)\r\n{\r\nwake_up(&fhp->wait_data);\r\n}\r\nstatic int pvr2_v4l2_iosetup(struct pvr2_v4l2_fh *fh)\r\n{\r\nint ret;\r\nstruct pvr2_stream *sp;\r\nstruct pvr2_hdw *hdw;\r\nif (fh->rhp) return 0;\r\nif (!fh->pdi->stream) {\r\nreturn -EPERM;\r\n}\r\nif ((ret = pvr2_channel_claim_stream(&fh->channel,\r\nfh->pdi->stream)) != 0) {\r\nreturn ret;\r\n}\r\nfh->rhp = pvr2_channel_create_mpeg_stream(fh->pdi->stream);\r\nif (!fh->rhp) {\r\npvr2_channel_claim_stream(&fh->channel,NULL);\r\nreturn -ENOMEM;\r\n}\r\nhdw = fh->channel.mc_head->hdw;\r\nsp = fh->pdi->stream->stream;\r\npvr2_stream_set_callback(sp,(pvr2_stream_callback)pvr2_v4l2_notify,fh);\r\npvr2_hdw_set_stream_type(hdw,fh->pdi->config);\r\nif ((ret = pvr2_hdw_set_streaming(hdw,!0)) < 0) return ret;\r\nreturn pvr2_ioread_set_enabled(fh->rhp,!0);\r\n}\r\nstatic ssize_t pvr2_v4l2_read(struct file *file,\r\nchar __user *buff, size_t count, loff_t *ppos)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nint ret;\r\nif (fh->fw_mode_flag) {\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nchar *tbuf;\r\nint c1,c2;\r\nint tcnt = 0;\r\nunsigned int offs = *ppos;\r\ntbuf = kmalloc(PAGE_SIZE,GFP_KERNEL);\r\nif (!tbuf) return -ENOMEM;\r\nwhile (count) {\r\nc1 = count;\r\nif (c1 > PAGE_SIZE) c1 = PAGE_SIZE;\r\nc2 = pvr2_hdw_cpufw_get(hdw,offs,tbuf,c1);\r\nif (c2 < 0) {\r\ntcnt = c2;\r\nbreak;\r\n}\r\nif (!c2) break;\r\nif (copy_to_user(buff,tbuf,c2)) {\r\ntcnt = -EFAULT;\r\nbreak;\r\n}\r\noffs += c2;\r\ntcnt += c2;\r\nbuff += c2;\r\ncount -= c2;\r\n*ppos += c2;\r\n}\r\nkfree(tbuf);\r\nreturn tcnt;\r\n}\r\nif (!fh->rhp) {\r\nret = pvr2_v4l2_iosetup(fh);\r\nif (ret) {\r\nreturn ret;\r\n}\r\n}\r\nfor (;;) {\r\nret = pvr2_ioread_read(fh->rhp,buff,count);\r\nif (ret >= 0) break;\r\nif (ret != -EAGAIN) break;\r\nif (file->f_flags & O_NONBLOCK) break;\r\nret = wait_event_interruptible(\r\nfh->wait_data,\r\npvr2_ioread_avail(fh->rhp) >= 0);\r\nif (ret < 0) break;\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int pvr2_v4l2_poll(struct file *file, poll_table *wait)\r\n{\r\nunsigned int mask = 0;\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nint ret;\r\nif (fh->fw_mode_flag) {\r\nmask |= POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}\r\nif (!fh->rhp) {\r\nret = pvr2_v4l2_iosetup(fh);\r\nif (ret) return POLLERR;\r\n}\r\npoll_wait(file,&fh->wait_data,wait);\r\nif (pvr2_ioread_avail(fh->rhp) >= 0) {\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\nreturn mask;\r\n}\r\nstatic void pvr2_v4l2_dev_init(struct pvr2_v4l2_dev *dip,\r\nstruct pvr2_v4l2 *vp,\r\nint v4l_type)\r\n{\r\nstruct usb_device *usbdev;\r\nint mindevnum;\r\nint unit_number;\r\nint *nr_ptr = NULL;\r\ndip->v4lp = vp;\r\nusbdev = pvr2_hdw_get_dev(vp->channel.mc_head->hdw);\r\ndip->v4l_type = v4l_type;\r\nswitch (v4l_type) {\r\ncase VFL_TYPE_GRABBER:\r\ndip->stream = &vp->channel.mc_head->video_stream;\r\ndip->config = pvr2_config_mpeg;\r\ndip->minor_type = pvr2_v4l_type_video;\r\nnr_ptr = video_nr;\r\nif (!dip->stream) {\r\npr_err(KBUILD_MODNAME\r\n": Failed to set up pvrusb2 v4l video dev"\r\n" due to missing stream instance\n");\r\nreturn;\r\n}\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\ndip->config = pvr2_config_vbi;\r\ndip->minor_type = pvr2_v4l_type_vbi;\r\nnr_ptr = vbi_nr;\r\nbreak;\r\ncase VFL_TYPE_RADIO:\r\ndip->stream = &vp->channel.mc_head->video_stream;\r\ndip->config = pvr2_config_mpeg;\r\ndip->minor_type = pvr2_v4l_type_radio;\r\nnr_ptr = radio_nr;\r\nbreak;\r\ndefault:\r\npr_err(KBUILD_MODNAME ": Failed to set up pvrusb2 v4l dev"\r\n" due to unrecognized config\n");\r\nreturn;\r\n}\r\nmemcpy(&dip->devbase,&vdev_template,sizeof(vdev_template));\r\ndip->devbase.release = pvr2_video_device_release;\r\nmindevnum = -1;\r\nunit_number = pvr2_hdw_get_unit_number(vp->channel.mc_head->hdw);\r\nif (nr_ptr && (unit_number >= 0) && (unit_number < PVR_NUM)) {\r\nmindevnum = nr_ptr[unit_number];\r\n}\r\ndip->devbase.parent = &usbdev->dev;\r\nif ((video_register_device(&dip->devbase,\r\ndip->v4l_type, mindevnum) < 0) &&\r\n(video_register_device(&dip->devbase,\r\ndip->v4l_type, -1) < 0)) {\r\npr_err(KBUILD_MODNAME\r\n": Failed to register pvrusb2 v4l device\n");\r\n}\r\nprintk(KERN_INFO "pvrusb2: registered device %s [%s]\n",\r\nvideo_device_node_name(&dip->devbase),\r\npvr2_config_get_name(dip->config));\r\npvr2_hdw_v4l_store_minor_number(vp->channel.mc_head->hdw,\r\ndip->minor_type,dip->devbase.minor);\r\n}\r\nstruct pvr2_v4l2 *pvr2_v4l2_create(struct pvr2_context *mnp)\r\n{\r\nstruct pvr2_v4l2 *vp;\r\nvp = kzalloc(sizeof(*vp),GFP_KERNEL);\r\nif (!vp) return vp;\r\npvr2_channel_init(&vp->channel,mnp);\r\npvr2_trace(PVR2_TRACE_STRUCT,"Creating pvr2_v4l2 id=%p",vp);\r\nvp->channel.check_func = pvr2_v4l2_internal_check;\r\nvp->dev_video = kzalloc(sizeof(*vp->dev_video),GFP_KERNEL);\r\nif (!vp->dev_video) goto fail;\r\npvr2_v4l2_dev_init(vp->dev_video,vp,VFL_TYPE_GRABBER);\r\nif (pvr2_hdw_get_input_available(vp->channel.mc_head->hdw) &\r\n(1 << PVR2_CVAL_INPUT_RADIO)) {\r\nvp->dev_radio = kzalloc(sizeof(*vp->dev_radio),GFP_KERNEL);\r\nif (!vp->dev_radio) goto fail;\r\npvr2_v4l2_dev_init(vp->dev_radio,vp,VFL_TYPE_RADIO);\r\n}\r\nreturn vp;\r\nfail:\r\npvr2_trace(PVR2_TRACE_STRUCT,"Failure creating pvr2_v4l2 id=%p",vp);\r\npvr2_v4l2_destroy_no_lock(vp);\r\nreturn NULL;\r\n}
