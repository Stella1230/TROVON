static struct ov772x_priv *to_ov772x(const struct i2c_client *client)\r\n{\r\nreturn container_of(i2c_get_clientdata(client), struct ov772x_priv,\r\nsubdev);\r\n}\r\nstatic int ov772x_write_array(struct i2c_client *client,\r\nconst struct regval_list *vals)\r\n{\r\nwhile (vals->reg_num != 0xff) {\r\nint ret = i2c_smbus_write_byte_data(client,\r\nvals->reg_num,\r\nvals->value);\r\nif (ret < 0)\r\nreturn ret;\r\nvals++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov772x_mask_set(struct i2c_client *client,\r\nu8 command,\r\nu8 mask,\r\nu8 set)\r\n{\r\ns32 val = i2c_smbus_read_byte_data(client, command);\r\nif (val < 0)\r\nreturn val;\r\nval &= ~mask;\r\nval |= set & mask;\r\nreturn i2c_smbus_write_byte_data(client, command, val);\r\n}\r\nstatic int ov772x_reset(struct i2c_client *client)\r\n{\r\nint ret = i2c_smbus_write_byte_data(client, COM7, SCCB_RESET);\r\nmsleep(1);\r\nreturn ret;\r\n}\r\nstatic int ov772x_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov772x_priv *priv = container_of(sd, struct ov772x_priv, subdev);\r\nif (!enable) {\r\nov772x_mask_set(client, COM2, SOFT_SLEEP_MODE, SOFT_SLEEP_MODE);\r\nreturn 0;\r\n}\r\nif (!priv->win || !priv->cfmt) {\r\ndev_err(&client->dev, "norm or win select error\n");\r\nreturn -EPERM;\r\n}\r\nov772x_mask_set(client, COM2, SOFT_SLEEP_MODE, 0);\r\ndev_dbg(&client->dev, "format %d, win %s\n",\r\npriv->cfmt->code, priv->win->name);\r\nreturn 0;\r\n}\r\nstatic int ov772x_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct ov772x_priv *priv = container_of(ctrl->handler,\r\nstruct ov772x_priv, hdl);\r\nstruct v4l2_subdev *sd = &priv->subdev;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret = 0;\r\nu8 val;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_VFLIP:\r\nval = ctrl->val ? VFLIP_IMG : 0x00;\r\npriv->flag_vflip = ctrl->val;\r\nif (priv->info->flags & OV772X_FLAG_VFLIP)\r\nval ^= VFLIP_IMG;\r\nreturn ov772x_mask_set(client, COM3, VFLIP_IMG, val);\r\ncase V4L2_CID_HFLIP:\r\nval = ctrl->val ? HFLIP_IMG : 0x00;\r\npriv->flag_hflip = ctrl->val;\r\nif (priv->info->flags & OV772X_FLAG_HFLIP)\r\nval ^= HFLIP_IMG;\r\nreturn ov772x_mask_set(client, COM3, HFLIP_IMG, val);\r\ncase V4L2_CID_BAND_STOP_FILTER:\r\nif (!ctrl->val) {\r\nret = ov772x_mask_set(client, BDBASE, 0xff, 0xff);\r\nif (!ret)\r\nret = ov772x_mask_set(client, COM8,\r\nBNDF_ON_OFF, 0);\r\n} else {\r\nval = 256 - ctrl->val;\r\nret = ov772x_mask_set(client, COM8,\r\nBNDF_ON_OFF, BNDF_ON_OFF);\r\nif (!ret)\r\nret = ov772x_mask_set(client, BDBASE,\r\n0xff, val);\r\n}\r\nif (!ret)\r\npriv->band_filter = ctrl->val;\r\nreturn ret;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ov772x_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *id)\r\n{\r\nstruct ov772x_priv *priv = container_of(sd, struct ov772x_priv, subdev);\r\nid->ident = priv->model;\r\nid->revision = 0;\r\nreturn 0;\r\n}\r\nstatic int ov772x_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nreg->size = 1;\r\nif (reg->reg > 0xff)\r\nreturn -EINVAL;\r\nret = i2c_smbus_read_byte_data(client, reg->reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreg->val = (__u64)ret;\r\nreturn 0;\r\n}\r\nstatic int ov772x_s_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->reg > 0xff ||\r\nreg->val > 0xff)\r\nreturn -EINVAL;\r\nreturn i2c_smbus_write_byte_data(client, reg->reg, reg->val);\r\n}\r\nstatic const struct ov772x_win_size *ov772x_select_win(u32 width, u32 height)\r\n{\r\n__u32 diff;\r\nconst struct ov772x_win_size *win;\r\ndiff = abs(width - ov772x_win_qvga.width) +\r\nabs(height - ov772x_win_qvga.height);\r\nwin = &ov772x_win_qvga;\r\nif (diff >\r\nabs(width - ov772x_win_vga.width) +\r\nabs(height - ov772x_win_vga.height))\r\nwin = &ov772x_win_vga;\r\nreturn win;\r\n}\r\nstatic int ov772x_set_params(struct i2c_client *client, u32 *width, u32 *height,\r\nenum v4l2_mbus_pixelcode code)\r\n{\r\nstruct ov772x_priv *priv = to_ov772x(client);\r\nint ret = -EINVAL;\r\nu8 val;\r\nint i;\r\npriv->cfmt = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(ov772x_cfmts); i++) {\r\nif (code == ov772x_cfmts[i].code) {\r\npriv->cfmt = ov772x_cfmts + i;\r\nbreak;\r\n}\r\n}\r\nif (!priv->cfmt)\r\ngoto ov772x_set_fmt_error;\r\npriv->win = ov772x_select_win(*width, *height);\r\nov772x_reset(client);\r\nif (priv->info->edgectrl.strength & OV772X_MANUAL_EDGE_CTRL) {\r\nret = ov772x_mask_set(client, DSPAUTO, EDGE_ACTRL, 0x00);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nret = ov772x_mask_set(client,\r\nEDGE_TRSHLD, OV772X_EDGE_THRESHOLD_MASK,\r\npriv->info->edgectrl.threshold);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nret = ov772x_mask_set(client,\r\nEDGE_STRNGT, OV772X_EDGE_STRENGTH_MASK,\r\npriv->info->edgectrl.strength);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\n} else if (priv->info->edgectrl.upper > priv->info->edgectrl.lower) {\r\nret = ov772x_mask_set(client,\r\nEDGE_UPPER, OV772X_EDGE_UPPER_MASK,\r\npriv->info->edgectrl.upper);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nret = ov772x_mask_set(client,\r\nEDGE_LOWER, OV772X_EDGE_LOWER_MASK,\r\npriv->info->edgectrl.lower);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\n}\r\nret = ov772x_write_array(client, priv->win->regs);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nval = priv->cfmt->dsp3;\r\nif (val) {\r\nret = ov772x_mask_set(client,\r\nDSP_CTRL3, UV_MASK, val);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\n}\r\nval = priv->cfmt->com3;\r\nif (priv->info->flags & OV772X_FLAG_VFLIP)\r\nval |= VFLIP_IMG;\r\nif (priv->info->flags & OV772X_FLAG_HFLIP)\r\nval |= HFLIP_IMG;\r\nif (priv->flag_vflip)\r\nval ^= VFLIP_IMG;\r\nif (priv->flag_hflip)\r\nval ^= HFLIP_IMG;\r\nret = ov772x_mask_set(client,\r\nCOM3, SWAP_MASK | IMG_MASK, val);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nval = priv->win->com7_bit | priv->cfmt->com7;\r\nret = ov772x_mask_set(client,\r\nCOM7, SLCT_MASK | FMT_MASK | OFMT_MASK,\r\nval);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nif (priv->band_filter) {\r\nret = ov772x_mask_set(client, COM8, BNDF_ON_OFF, 1);\r\nif (!ret)\r\nret = ov772x_mask_set(client, BDBASE,\r\n0xff, 256 - priv->band_filter);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\n}\r\n*width = priv->win->width;\r\n*height = priv->win->height;\r\nreturn ret;\r\nov772x_set_fmt_error:\r\nov772x_reset(client);\r\npriv->win = NULL;\r\npriv->cfmt = NULL;\r\nreturn ret;\r\n}\r\nstatic int ov772x_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\na->c.left = 0;\r\na->c.top = 0;\r\na->c.width = VGA_WIDTH;\r\na->c.height = VGA_HEIGHT;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic int ov772x_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)\r\n{\r\na->bounds.left = 0;\r\na->bounds.top = 0;\r\na->bounds.width = VGA_WIDTH;\r\na->bounds.height = VGA_HEIGHT;\r\na->defrect = a->bounds;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\na->pixelaspect.numerator = 1;\r\na->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int ov772x_g_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov772x_priv *priv = container_of(sd, struct ov772x_priv, subdev);\r\nif (!priv->win || !priv->cfmt) {\r\nu32 width = VGA_WIDTH, height = VGA_HEIGHT;\r\nint ret = ov772x_set_params(client, &width, &height,\r\nV4L2_MBUS_FMT_YUYV8_2X8);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nmf->width = priv->win->width;\r\nmf->height = priv->win->height;\r\nmf->code = priv->cfmt->code;\r\nmf->colorspace = priv->cfmt->colorspace;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int ov772x_s_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov772x_priv *priv = container_of(sd, struct ov772x_priv, subdev);\r\nint ret = ov772x_set_params(client, &mf->width, &mf->height,\r\nmf->code);\r\nif (!ret)\r\nmf->colorspace = priv->cfmt->colorspace;\r\nreturn ret;\r\n}\r\nstatic int ov772x_try_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct ov772x_priv *priv = container_of(sd, struct ov772x_priv, subdev);\r\nconst struct ov772x_win_size *win;\r\nint i;\r\nwin = ov772x_select_win(mf->width, mf->height);\r\nmf->width = win->width;\r\nmf->height = win->height;\r\nmf->field = V4L2_FIELD_NONE;\r\nfor (i = 0; i < ARRAY_SIZE(ov772x_cfmts); i++)\r\nif (mf->code == ov772x_cfmts[i].code)\r\nbreak;\r\nif (i == ARRAY_SIZE(ov772x_cfmts)) {\r\nif (priv->cfmt) {\r\nmf->colorspace = priv->cfmt->colorspace;\r\nmf->code = priv->cfmt->code;\r\n} else {\r\nmf->colorspace = ov772x_cfmts[0].colorspace;\r\nmf->code = ov772x_cfmts[0].code;\r\n}\r\n} else {\r\nmf->colorspace = ov772x_cfmts[i].colorspace;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov772x_video_probe(struct i2c_client *client)\r\n{\r\nstruct ov772x_priv *priv = to_ov772x(client);\r\nu8 pid, ver;\r\nconst char *devname;\r\npid = i2c_smbus_read_byte_data(client, PID);\r\nver = i2c_smbus_read_byte_data(client, VER);\r\nswitch (VERSION(pid, ver)) {\r\ncase OV7720:\r\ndevname = "ov7720";\r\npriv->model = V4L2_IDENT_OV7720;\r\nbreak;\r\ncase OV7725:\r\ndevname = "ov7725";\r\npriv->model = V4L2_IDENT_OV7725;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"Product ID error %x:%x\n", pid, ver);\r\nreturn -ENODEV;\r\n}\r\ndev_info(&client->dev,\r\n"%s Product ID %0x:%0x Manufacturer ID %x:%x\n",\r\ndevname,\r\npid,\r\nver,\r\ni2c_smbus_read_byte_data(client, MIDH),\r\ni2c_smbus_read_byte_data(client, MIDL));\r\nreturn v4l2_ctrl_handler_setup(&priv->hdl);\r\n}\r\nstatic int ov772x_enum_fmt(struct v4l2_subdev *sd, unsigned int index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index >= ARRAY_SIZE(ov772x_cfmts))\r\nreturn -EINVAL;\r\n*code = ov772x_cfmts[index].code;\r\nreturn 0;\r\n}\r\nstatic int ov772x_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\ncfg->flags = V4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_MASTER |\r\nV4L2_MBUS_VSYNC_ACTIVE_HIGH | V4L2_MBUS_HSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_DATA_ACTIVE_HIGH;\r\ncfg->type = V4L2_MBUS_PARALLEL;\r\ncfg->flags = soc_camera_apply_board_flags(icl, cfg);\r\nreturn 0;\r\n}\r\nstatic int ov772x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct ov772x_priv *priv;\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nint ret;\r\nif (!icl || !icl->priv) {\r\ndev_err(&client->dev, "OV772X: missing platform data!\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&adapter->dev,\r\n"I2C-Adapter doesn't support "\r\n"I2C_FUNC_SMBUS_BYTE_DATA\n");\r\nreturn -EIO;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->info = icl->priv;\r\nv4l2_i2c_subdev_init(&priv->subdev, client, &ov772x_subdev_ops);\r\nv4l2_ctrl_handler_init(&priv->hdl, 3);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov772x_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov772x_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov772x_ctrl_ops,\r\nV4L2_CID_BAND_STOP_FILTER, 0, 256, 1, 0);\r\npriv->subdev.ctrl_handler = &priv->hdl;\r\nif (priv->hdl.error) {\r\nint err = priv->hdl.error;\r\nkfree(priv);\r\nreturn err;\r\n}\r\nret = ov772x_video_probe(client);\r\nif (ret) {\r\nv4l2_ctrl_handler_free(&priv->hdl);\r\nkfree(priv);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov772x_remove(struct i2c_client *client)\r\n{\r\nstruct ov772x_priv *priv = to_ov772x(client);\r\nv4l2_device_unregister_subdev(&priv->subdev);\r\nv4l2_ctrl_handler_free(&priv->hdl);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int __init ov772x_module_init(void)\r\n{\r\nreturn i2c_add_driver(&ov772x_i2c_driver);\r\n}\r\nstatic void __exit ov772x_module_exit(void)\r\n{\r\ni2c_del_driver(&ov772x_i2c_driver);\r\n}
