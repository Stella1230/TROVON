static int dcbnl_reply(u8 value, u8 event, u8 cmd, u8 attr, u32 pid,\r\nu32 seq, u16 flags)\r\n{\r\nstruct sk_buff *dcbnl_skb;\r\nstruct dcbmsg *dcb;\r\nstruct nlmsghdr *nlh;\r\nint ret = -EINVAL;\r\ndcbnl_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!dcbnl_skb)\r\nreturn ret;\r\nnlh = NLMSG_NEW(dcbnl_skb, pid, seq, event, sizeof(*dcb), flags);\r\ndcb = NLMSG_DATA(nlh);\r\ndcb->dcb_family = AF_UNSPEC;\r\ndcb->cmd = cmd;\r\ndcb->dcb_pad = 0;\r\nret = nla_put_u8(dcbnl_skb, attr, value);\r\nif (ret)\r\ngoto err;\r\nnlmsg_end(dcbnl_skb, nlh);\r\nret = rtnl_unicast(dcbnl_skb, &init_net, pid);\r\nif (ret)\r\nreturn -EINVAL;\r\nreturn 0;\r\nnlmsg_failure:\r\nerr:\r\nkfree_skb(dcbnl_skb);\r\nreturn ret;\r\n}\r\nstatic int dcbnl_getstate(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nint ret = -EINVAL;\r\nif (!netdev->dcbnl_ops->getstate)\r\nreturn ret;\r\nret = dcbnl_reply(netdev->dcbnl_ops->getstate(netdev), RTM_GETDCB,\r\nDCB_CMD_GSTATE, DCB_ATTR_STATE, pid, seq, flags);\r\nreturn ret;\r\n}\r\nstatic int dcbnl_getpfccfg(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nstruct sk_buff *dcbnl_skb;\r\nstruct nlmsghdr *nlh;\r\nstruct dcbmsg *dcb;\r\nstruct nlattr *data[DCB_PFC_UP_ATTR_MAX + 1], *nest;\r\nu8 value;\r\nint ret = -EINVAL;\r\nint i;\r\nint getall = 0;\r\nif (!tb[DCB_ATTR_PFC_CFG] || !netdev->dcbnl_ops->getpfccfg)\r\nreturn ret;\r\nret = nla_parse_nested(data, DCB_PFC_UP_ATTR_MAX,\r\ntb[DCB_ATTR_PFC_CFG],\r\ndcbnl_pfc_up_nest);\r\nif (ret)\r\ngoto err_out;\r\ndcbnl_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!dcbnl_skb)\r\ngoto err_out;\r\nnlh = NLMSG_NEW(dcbnl_skb, pid, seq, RTM_GETDCB, sizeof(*dcb), flags);\r\ndcb = NLMSG_DATA(nlh);\r\ndcb->dcb_family = AF_UNSPEC;\r\ndcb->cmd = DCB_CMD_PFC_GCFG;\r\nnest = nla_nest_start(dcbnl_skb, DCB_ATTR_PFC_CFG);\r\nif (!nest)\r\ngoto err;\r\nif (data[DCB_PFC_UP_ATTR_ALL])\r\ngetall = 1;\r\nfor (i = DCB_PFC_UP_ATTR_0; i <= DCB_PFC_UP_ATTR_7; i++) {\r\nif (!getall && !data[i])\r\ncontinue;\r\nnetdev->dcbnl_ops->getpfccfg(netdev, i - DCB_PFC_UP_ATTR_0,\r\n&value);\r\nret = nla_put_u8(dcbnl_skb, i, value);\r\nif (ret) {\r\nnla_nest_cancel(dcbnl_skb, nest);\r\ngoto err;\r\n}\r\n}\r\nnla_nest_end(dcbnl_skb, nest);\r\nnlmsg_end(dcbnl_skb, nlh);\r\nret = rtnl_unicast(dcbnl_skb, &init_net, pid);\r\nif (ret)\r\ngoto err_out;\r\nreturn 0;\r\nnlmsg_failure:\r\nerr:\r\nkfree_skb(dcbnl_skb);\r\nerr_out:\r\nreturn -EINVAL;\r\n}\r\nstatic int dcbnl_getperm_hwaddr(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nstruct sk_buff *dcbnl_skb;\r\nstruct nlmsghdr *nlh;\r\nstruct dcbmsg *dcb;\r\nu8 perm_addr[MAX_ADDR_LEN];\r\nint ret = -EINVAL;\r\nif (!netdev->dcbnl_ops->getpermhwaddr)\r\nreturn ret;\r\ndcbnl_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!dcbnl_skb)\r\ngoto err_out;\r\nnlh = NLMSG_NEW(dcbnl_skb, pid, seq, RTM_GETDCB, sizeof(*dcb), flags);\r\ndcb = NLMSG_DATA(nlh);\r\ndcb->dcb_family = AF_UNSPEC;\r\ndcb->cmd = DCB_CMD_GPERM_HWADDR;\r\nnetdev->dcbnl_ops->getpermhwaddr(netdev, perm_addr);\r\nret = nla_put(dcbnl_skb, DCB_ATTR_PERM_HWADDR, sizeof(perm_addr),\r\nperm_addr);\r\nnlmsg_end(dcbnl_skb, nlh);\r\nret = rtnl_unicast(dcbnl_skb, &init_net, pid);\r\nif (ret)\r\ngoto err_out;\r\nreturn 0;\r\nnlmsg_failure:\r\nkfree_skb(dcbnl_skb);\r\nerr_out:\r\nreturn -EINVAL;\r\n}\r\nstatic int dcbnl_getcap(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nstruct sk_buff *dcbnl_skb;\r\nstruct nlmsghdr *nlh;\r\nstruct dcbmsg *dcb;\r\nstruct nlattr *data[DCB_CAP_ATTR_MAX + 1], *nest;\r\nu8 value;\r\nint ret = -EINVAL;\r\nint i;\r\nint getall = 0;\r\nif (!tb[DCB_ATTR_CAP] || !netdev->dcbnl_ops->getcap)\r\nreturn ret;\r\nret = nla_parse_nested(data, DCB_CAP_ATTR_MAX, tb[DCB_ATTR_CAP],\r\ndcbnl_cap_nest);\r\nif (ret)\r\ngoto err_out;\r\ndcbnl_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!dcbnl_skb)\r\ngoto err_out;\r\nnlh = NLMSG_NEW(dcbnl_skb, pid, seq, RTM_GETDCB, sizeof(*dcb), flags);\r\ndcb = NLMSG_DATA(nlh);\r\ndcb->dcb_family = AF_UNSPEC;\r\ndcb->cmd = DCB_CMD_GCAP;\r\nnest = nla_nest_start(dcbnl_skb, DCB_ATTR_CAP);\r\nif (!nest)\r\ngoto err;\r\nif (data[DCB_CAP_ATTR_ALL])\r\ngetall = 1;\r\nfor (i = DCB_CAP_ATTR_ALL+1; i <= DCB_CAP_ATTR_MAX; i++) {\r\nif (!getall && !data[i])\r\ncontinue;\r\nif (!netdev->dcbnl_ops->getcap(netdev, i, &value)) {\r\nret = nla_put_u8(dcbnl_skb, i, value);\r\nif (ret) {\r\nnla_nest_cancel(dcbnl_skb, nest);\r\ngoto err;\r\n}\r\n}\r\n}\r\nnla_nest_end(dcbnl_skb, nest);\r\nnlmsg_end(dcbnl_skb, nlh);\r\nret = rtnl_unicast(dcbnl_skb, &init_net, pid);\r\nif (ret)\r\ngoto err_out;\r\nreturn 0;\r\nnlmsg_failure:\r\nerr:\r\nkfree_skb(dcbnl_skb);\r\nerr_out:\r\nreturn -EINVAL;\r\n}\r\nstatic int dcbnl_getnumtcs(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nstruct sk_buff *dcbnl_skb;\r\nstruct nlmsghdr *nlh;\r\nstruct dcbmsg *dcb;\r\nstruct nlattr *data[DCB_NUMTCS_ATTR_MAX + 1], *nest;\r\nu8 value;\r\nint ret = -EINVAL;\r\nint i;\r\nint getall = 0;\r\nif (!tb[DCB_ATTR_NUMTCS] || !netdev->dcbnl_ops->getnumtcs)\r\nreturn ret;\r\nret = nla_parse_nested(data, DCB_NUMTCS_ATTR_MAX, tb[DCB_ATTR_NUMTCS],\r\ndcbnl_numtcs_nest);\r\nif (ret) {\r\nret = -EINVAL;\r\ngoto err_out;\r\n}\r\ndcbnl_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!dcbnl_skb) {\r\nret = -EINVAL;\r\ngoto err_out;\r\n}\r\nnlh = NLMSG_NEW(dcbnl_skb, pid, seq, RTM_GETDCB, sizeof(*dcb), flags);\r\ndcb = NLMSG_DATA(nlh);\r\ndcb->dcb_family = AF_UNSPEC;\r\ndcb->cmd = DCB_CMD_GNUMTCS;\r\nnest = nla_nest_start(dcbnl_skb, DCB_ATTR_NUMTCS);\r\nif (!nest) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (data[DCB_NUMTCS_ATTR_ALL])\r\ngetall = 1;\r\nfor (i = DCB_NUMTCS_ATTR_ALL+1; i <= DCB_NUMTCS_ATTR_MAX; i++) {\r\nif (!getall && !data[i])\r\ncontinue;\r\nret = netdev->dcbnl_ops->getnumtcs(netdev, i, &value);\r\nif (!ret) {\r\nret = nla_put_u8(dcbnl_skb, i, value);\r\nif (ret) {\r\nnla_nest_cancel(dcbnl_skb, nest);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\n} else {\r\ngoto err;\r\n}\r\n}\r\nnla_nest_end(dcbnl_skb, nest);\r\nnlmsg_end(dcbnl_skb, nlh);\r\nret = rtnl_unicast(dcbnl_skb, &init_net, pid);\r\nif (ret) {\r\nret = -EINVAL;\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nnlmsg_failure:\r\nerr:\r\nkfree_skb(dcbnl_skb);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic int dcbnl_setnumtcs(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nstruct nlattr *data[DCB_NUMTCS_ATTR_MAX + 1];\r\nint ret = -EINVAL;\r\nu8 value;\r\nint i;\r\nif (!tb[DCB_ATTR_NUMTCS] || !netdev->dcbnl_ops->setnumtcs)\r\nreturn ret;\r\nret = nla_parse_nested(data, DCB_NUMTCS_ATTR_MAX, tb[DCB_ATTR_NUMTCS],\r\ndcbnl_numtcs_nest);\r\nif (ret) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nfor (i = DCB_NUMTCS_ATTR_ALL+1; i <= DCB_NUMTCS_ATTR_MAX; i++) {\r\nif (data[i] == NULL)\r\ncontinue;\r\nvalue = nla_get_u8(data[i]);\r\nret = netdev->dcbnl_ops->setnumtcs(netdev, i, value);\r\nif (ret)\r\ngoto operr;\r\n}\r\noperr:\r\nret = dcbnl_reply(!!ret, RTM_SETDCB, DCB_CMD_SNUMTCS,\r\nDCB_ATTR_NUMTCS, pid, seq, flags);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int dcbnl_getpfcstate(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nint ret = -EINVAL;\r\nif (!netdev->dcbnl_ops->getpfcstate)\r\nreturn ret;\r\nret = dcbnl_reply(netdev->dcbnl_ops->getpfcstate(netdev), RTM_GETDCB,\r\nDCB_CMD_PFC_GSTATE, DCB_ATTR_PFC_STATE,\r\npid, seq, flags);\r\nreturn ret;\r\n}\r\nstatic int dcbnl_setpfcstate(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nint ret = -EINVAL;\r\nu8 value;\r\nif (!tb[DCB_ATTR_PFC_STATE] || !netdev->dcbnl_ops->setpfcstate)\r\nreturn ret;\r\nvalue = nla_get_u8(tb[DCB_ATTR_PFC_STATE]);\r\nnetdev->dcbnl_ops->setpfcstate(netdev, value);\r\nret = dcbnl_reply(0, RTM_SETDCB, DCB_CMD_PFC_SSTATE, DCB_ATTR_PFC_STATE,\r\npid, seq, flags);\r\nreturn ret;\r\n}\r\nstatic int dcbnl_getapp(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nstruct sk_buff *dcbnl_skb;\r\nstruct nlmsghdr *nlh;\r\nstruct dcbmsg *dcb;\r\nstruct nlattr *app_nest;\r\nstruct nlattr *app_tb[DCB_APP_ATTR_MAX + 1];\r\nu16 id;\r\nu8 up, idtype;\r\nint ret = -EINVAL;\r\nif (!tb[DCB_ATTR_APP])\r\ngoto out;\r\nret = nla_parse_nested(app_tb, DCB_APP_ATTR_MAX, tb[DCB_ATTR_APP],\r\ndcbnl_app_nest);\r\nif (ret)\r\ngoto out;\r\nret = -EINVAL;\r\nif ((!app_tb[DCB_APP_ATTR_IDTYPE]) ||\r\n(!app_tb[DCB_APP_ATTR_ID]))\r\ngoto out;\r\nidtype = nla_get_u8(app_tb[DCB_APP_ATTR_IDTYPE]);\r\nif ((idtype != DCB_APP_IDTYPE_ETHTYPE) &&\r\n(idtype != DCB_APP_IDTYPE_PORTNUM))\r\ngoto out;\r\nid = nla_get_u16(app_tb[DCB_APP_ATTR_ID]);\r\nif (netdev->dcbnl_ops->getapp) {\r\nup = netdev->dcbnl_ops->getapp(netdev, idtype, id);\r\n} else {\r\nstruct dcb_app app = {\r\n.selector = idtype,\r\n.protocol = id,\r\n};\r\nup = dcb_getapp(netdev, &app);\r\n}\r\ndcbnl_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!dcbnl_skb)\r\ngoto out;\r\nnlh = NLMSG_NEW(dcbnl_skb, pid, seq, RTM_GETDCB, sizeof(*dcb), flags);\r\ndcb = NLMSG_DATA(nlh);\r\ndcb->dcb_family = AF_UNSPEC;\r\ndcb->cmd = DCB_CMD_GAPP;\r\napp_nest = nla_nest_start(dcbnl_skb, DCB_ATTR_APP);\r\nif (!app_nest)\r\ngoto out_cancel;\r\nret = nla_put_u8(dcbnl_skb, DCB_APP_ATTR_IDTYPE, idtype);\r\nif (ret)\r\ngoto out_cancel;\r\nret = nla_put_u16(dcbnl_skb, DCB_APP_ATTR_ID, id);\r\nif (ret)\r\ngoto out_cancel;\r\nret = nla_put_u8(dcbnl_skb, DCB_APP_ATTR_PRIORITY, up);\r\nif (ret)\r\ngoto out_cancel;\r\nnla_nest_end(dcbnl_skb, app_nest);\r\nnlmsg_end(dcbnl_skb, nlh);\r\nret = rtnl_unicast(dcbnl_skb, &init_net, pid);\r\nif (ret)\r\ngoto nlmsg_failure;\r\ngoto out;\r\nout_cancel:\r\nnla_nest_cancel(dcbnl_skb, app_nest);\r\nnlmsg_failure:\r\nkfree_skb(dcbnl_skb);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int dcbnl_setapp(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nint err, ret = -EINVAL;\r\nu16 id;\r\nu8 up, idtype;\r\nstruct nlattr *app_tb[DCB_APP_ATTR_MAX + 1];\r\nif (!tb[DCB_ATTR_APP])\r\ngoto out;\r\nret = nla_parse_nested(app_tb, DCB_APP_ATTR_MAX, tb[DCB_ATTR_APP],\r\ndcbnl_app_nest);\r\nif (ret)\r\ngoto out;\r\nret = -EINVAL;\r\nif ((!app_tb[DCB_APP_ATTR_IDTYPE]) ||\r\n(!app_tb[DCB_APP_ATTR_ID]) ||\r\n(!app_tb[DCB_APP_ATTR_PRIORITY]))\r\ngoto out;\r\nidtype = nla_get_u8(app_tb[DCB_APP_ATTR_IDTYPE]);\r\nif ((idtype != DCB_APP_IDTYPE_ETHTYPE) &&\r\n(idtype != DCB_APP_IDTYPE_PORTNUM))\r\ngoto out;\r\nid = nla_get_u16(app_tb[DCB_APP_ATTR_ID]);\r\nup = nla_get_u8(app_tb[DCB_APP_ATTR_PRIORITY]);\r\nif (netdev->dcbnl_ops->setapp) {\r\nerr = netdev->dcbnl_ops->setapp(netdev, idtype, id, up);\r\n} else {\r\nstruct dcb_app app;\r\napp.selector = idtype;\r\napp.protocol = id;\r\napp.priority = up;\r\nerr = dcb_setapp(netdev, &app);\r\n}\r\nret = dcbnl_reply(err, RTM_SETDCB, DCB_CMD_SAPP, DCB_ATTR_APP,\r\npid, seq, flags);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __dcbnl_pg_getcfg(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags, int dir)\r\n{\r\nstruct sk_buff *dcbnl_skb;\r\nstruct nlmsghdr *nlh;\r\nstruct dcbmsg *dcb;\r\nstruct nlattr *pg_nest, *param_nest, *data;\r\nstruct nlattr *pg_tb[DCB_PG_ATTR_MAX + 1];\r\nstruct nlattr *param_tb[DCB_TC_ATTR_PARAM_MAX + 1];\r\nu8 prio, pgid, tc_pct, up_map;\r\nint ret = -EINVAL;\r\nint getall = 0;\r\nint i;\r\nif (!tb[DCB_ATTR_PG_CFG] ||\r\n!netdev->dcbnl_ops->getpgtccfgtx ||\r\n!netdev->dcbnl_ops->getpgtccfgrx ||\r\n!netdev->dcbnl_ops->getpgbwgcfgtx ||\r\n!netdev->dcbnl_ops->getpgbwgcfgrx)\r\nreturn ret;\r\nret = nla_parse_nested(pg_tb, DCB_PG_ATTR_MAX,\r\ntb[DCB_ATTR_PG_CFG], dcbnl_pg_nest);\r\nif (ret)\r\ngoto err_out;\r\ndcbnl_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!dcbnl_skb)\r\ngoto err_out;\r\nnlh = NLMSG_NEW(dcbnl_skb, pid, seq, RTM_GETDCB, sizeof(*dcb), flags);\r\ndcb = NLMSG_DATA(nlh);\r\ndcb->dcb_family = AF_UNSPEC;\r\ndcb->cmd = (dir) ? DCB_CMD_PGRX_GCFG : DCB_CMD_PGTX_GCFG;\r\npg_nest = nla_nest_start(dcbnl_skb, DCB_ATTR_PG_CFG);\r\nif (!pg_nest)\r\ngoto err;\r\nif (pg_tb[DCB_PG_ATTR_TC_ALL])\r\ngetall = 1;\r\nfor (i = DCB_PG_ATTR_TC_0; i <= DCB_PG_ATTR_TC_7; i++) {\r\nif (!getall && !pg_tb[i])\r\ncontinue;\r\nif (pg_tb[DCB_PG_ATTR_TC_ALL])\r\ndata = pg_tb[DCB_PG_ATTR_TC_ALL];\r\nelse\r\ndata = pg_tb[i];\r\nret = nla_parse_nested(param_tb, DCB_TC_ATTR_PARAM_MAX,\r\ndata, dcbnl_tc_param_nest);\r\nif (ret)\r\ngoto err_pg;\r\nparam_nest = nla_nest_start(dcbnl_skb, i);\r\nif (!param_nest)\r\ngoto err_pg;\r\npgid = DCB_ATTR_VALUE_UNDEFINED;\r\nprio = DCB_ATTR_VALUE_UNDEFINED;\r\ntc_pct = DCB_ATTR_VALUE_UNDEFINED;\r\nup_map = DCB_ATTR_VALUE_UNDEFINED;\r\nif (dir) {\r\nnetdev->dcbnl_ops->getpgtccfgrx(netdev,\r\ni - DCB_PG_ATTR_TC_0, &prio,\r\n&pgid, &tc_pct, &up_map);\r\n} else {\r\nnetdev->dcbnl_ops->getpgtccfgtx(netdev,\r\ni - DCB_PG_ATTR_TC_0, &prio,\r\n&pgid, &tc_pct, &up_map);\r\n}\r\nif (param_tb[DCB_TC_ATTR_PARAM_PGID] ||\r\nparam_tb[DCB_TC_ATTR_PARAM_ALL]) {\r\nret = nla_put_u8(dcbnl_skb,\r\nDCB_TC_ATTR_PARAM_PGID, pgid);\r\nif (ret)\r\ngoto err_param;\r\n}\r\nif (param_tb[DCB_TC_ATTR_PARAM_UP_MAPPING] ||\r\nparam_tb[DCB_TC_ATTR_PARAM_ALL]) {\r\nret = nla_put_u8(dcbnl_skb,\r\nDCB_TC_ATTR_PARAM_UP_MAPPING, up_map);\r\nif (ret)\r\ngoto err_param;\r\n}\r\nif (param_tb[DCB_TC_ATTR_PARAM_STRICT_PRIO] ||\r\nparam_tb[DCB_TC_ATTR_PARAM_ALL]) {\r\nret = nla_put_u8(dcbnl_skb,\r\nDCB_TC_ATTR_PARAM_STRICT_PRIO, prio);\r\nif (ret)\r\ngoto err_param;\r\n}\r\nif (param_tb[DCB_TC_ATTR_PARAM_BW_PCT] ||\r\nparam_tb[DCB_TC_ATTR_PARAM_ALL]) {\r\nret = nla_put_u8(dcbnl_skb, DCB_TC_ATTR_PARAM_BW_PCT,\r\ntc_pct);\r\nif (ret)\r\ngoto err_param;\r\n}\r\nnla_nest_end(dcbnl_skb, param_nest);\r\n}\r\nif (pg_tb[DCB_PG_ATTR_BW_ID_ALL])\r\ngetall = 1;\r\nelse\r\ngetall = 0;\r\nfor (i = DCB_PG_ATTR_BW_ID_0; i <= DCB_PG_ATTR_BW_ID_7; i++) {\r\nif (!getall && !pg_tb[i])\r\ncontinue;\r\ntc_pct = DCB_ATTR_VALUE_UNDEFINED;\r\nif (dir) {\r\nnetdev->dcbnl_ops->getpgbwgcfgrx(netdev,\r\ni - DCB_PG_ATTR_BW_ID_0, &tc_pct);\r\n} else {\r\nnetdev->dcbnl_ops->getpgbwgcfgtx(netdev,\r\ni - DCB_PG_ATTR_BW_ID_0, &tc_pct);\r\n}\r\nret = nla_put_u8(dcbnl_skb, i, tc_pct);\r\nif (ret)\r\ngoto err_pg;\r\n}\r\nnla_nest_end(dcbnl_skb, pg_nest);\r\nnlmsg_end(dcbnl_skb, nlh);\r\nret = rtnl_unicast(dcbnl_skb, &init_net, pid);\r\nif (ret)\r\ngoto err_out;\r\nreturn 0;\r\nerr_param:\r\nnla_nest_cancel(dcbnl_skb, param_nest);\r\nerr_pg:\r\nnla_nest_cancel(dcbnl_skb, pg_nest);\r\nnlmsg_failure:\r\nerr:\r\nkfree_skb(dcbnl_skb);\r\nerr_out:\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int dcbnl_pgtx_getcfg(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nreturn __dcbnl_pg_getcfg(netdev, tb, pid, seq, flags, 0);\r\n}\r\nstatic int dcbnl_pgrx_getcfg(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nreturn __dcbnl_pg_getcfg(netdev, tb, pid, seq, flags, 1);\r\n}\r\nstatic int dcbnl_setstate(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nint ret = -EINVAL;\r\nu8 value;\r\nif (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->setstate)\r\nreturn ret;\r\nvalue = nla_get_u8(tb[DCB_ATTR_STATE]);\r\nret = dcbnl_reply(netdev->dcbnl_ops->setstate(netdev, value),\r\nRTM_SETDCB, DCB_CMD_SSTATE, DCB_ATTR_STATE,\r\npid, seq, flags);\r\nreturn ret;\r\n}\r\nstatic int dcbnl_setpfccfg(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nstruct nlattr *data[DCB_PFC_UP_ATTR_MAX + 1];\r\nint i;\r\nint ret = -EINVAL;\r\nu8 value;\r\nif (!tb[DCB_ATTR_PFC_CFG] || !netdev->dcbnl_ops->setpfccfg)\r\nreturn ret;\r\nret = nla_parse_nested(data, DCB_PFC_UP_ATTR_MAX,\r\ntb[DCB_ATTR_PFC_CFG],\r\ndcbnl_pfc_up_nest);\r\nif (ret)\r\ngoto err;\r\nfor (i = DCB_PFC_UP_ATTR_0; i <= DCB_PFC_UP_ATTR_7; i++) {\r\nif (data[i] == NULL)\r\ncontinue;\r\nvalue = nla_get_u8(data[i]);\r\nnetdev->dcbnl_ops->setpfccfg(netdev,\r\ndata[i]->nla_type - DCB_PFC_UP_ATTR_0, value);\r\n}\r\nret = dcbnl_reply(0, RTM_SETDCB, DCB_CMD_PFC_SCFG, DCB_ATTR_PFC_CFG,\r\npid, seq, flags);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int dcbnl_setall(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nint ret = -EINVAL;\r\nif (!tb[DCB_ATTR_SET_ALL] || !netdev->dcbnl_ops->setall)\r\nreturn ret;\r\nret = dcbnl_reply(netdev->dcbnl_ops->setall(netdev), RTM_SETDCB,\r\nDCB_CMD_SET_ALL, DCB_ATTR_SET_ALL, pid, seq, flags);\r\nreturn ret;\r\n}\r\nstatic int __dcbnl_pg_setcfg(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags, int dir)\r\n{\r\nstruct nlattr *pg_tb[DCB_PG_ATTR_MAX + 1];\r\nstruct nlattr *param_tb[DCB_TC_ATTR_PARAM_MAX + 1];\r\nint ret = -EINVAL;\r\nint i;\r\nu8 pgid;\r\nu8 up_map;\r\nu8 prio;\r\nu8 tc_pct;\r\nif (!tb[DCB_ATTR_PG_CFG] ||\r\n!netdev->dcbnl_ops->setpgtccfgtx ||\r\n!netdev->dcbnl_ops->setpgtccfgrx ||\r\n!netdev->dcbnl_ops->setpgbwgcfgtx ||\r\n!netdev->dcbnl_ops->setpgbwgcfgrx)\r\nreturn ret;\r\nret = nla_parse_nested(pg_tb, DCB_PG_ATTR_MAX,\r\ntb[DCB_ATTR_PG_CFG], dcbnl_pg_nest);\r\nif (ret)\r\ngoto err;\r\nfor (i = DCB_PG_ATTR_TC_0; i <= DCB_PG_ATTR_TC_7; i++) {\r\nif (!pg_tb[i])\r\ncontinue;\r\nret = nla_parse_nested(param_tb, DCB_TC_ATTR_PARAM_MAX,\r\npg_tb[i], dcbnl_tc_param_nest);\r\nif (ret)\r\ngoto err;\r\npgid = DCB_ATTR_VALUE_UNDEFINED;\r\nprio = DCB_ATTR_VALUE_UNDEFINED;\r\ntc_pct = DCB_ATTR_VALUE_UNDEFINED;\r\nup_map = DCB_ATTR_VALUE_UNDEFINED;\r\nif (param_tb[DCB_TC_ATTR_PARAM_STRICT_PRIO])\r\nprio =\r\nnla_get_u8(param_tb[DCB_TC_ATTR_PARAM_STRICT_PRIO]);\r\nif (param_tb[DCB_TC_ATTR_PARAM_PGID])\r\npgid = nla_get_u8(param_tb[DCB_TC_ATTR_PARAM_PGID]);\r\nif (param_tb[DCB_TC_ATTR_PARAM_BW_PCT])\r\ntc_pct = nla_get_u8(param_tb[DCB_TC_ATTR_PARAM_BW_PCT]);\r\nif (param_tb[DCB_TC_ATTR_PARAM_UP_MAPPING])\r\nup_map =\r\nnla_get_u8(param_tb[DCB_TC_ATTR_PARAM_UP_MAPPING]);\r\nif (dir) {\r\nnetdev->dcbnl_ops->setpgtccfgrx(netdev,\r\ni - DCB_PG_ATTR_TC_0,\r\nprio, pgid, tc_pct, up_map);\r\n} else {\r\nnetdev->dcbnl_ops->setpgtccfgtx(netdev,\r\ni - DCB_PG_ATTR_TC_0,\r\nprio, pgid, tc_pct, up_map);\r\n}\r\n}\r\nfor (i = DCB_PG_ATTR_BW_ID_0; i <= DCB_PG_ATTR_BW_ID_7; i++) {\r\nif (!pg_tb[i])\r\ncontinue;\r\ntc_pct = nla_get_u8(pg_tb[i]);\r\nif (dir) {\r\nnetdev->dcbnl_ops->setpgbwgcfgrx(netdev,\r\ni - DCB_PG_ATTR_BW_ID_0, tc_pct);\r\n} else {\r\nnetdev->dcbnl_ops->setpgbwgcfgtx(netdev,\r\ni - DCB_PG_ATTR_BW_ID_0, tc_pct);\r\n}\r\n}\r\nret = dcbnl_reply(0, RTM_SETDCB,\r\n(dir ? DCB_CMD_PGRX_SCFG : DCB_CMD_PGTX_SCFG),\r\nDCB_ATTR_PG_CFG, pid, seq, flags);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int dcbnl_pgtx_setcfg(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nreturn __dcbnl_pg_setcfg(netdev, tb, pid, seq, flags, 0);\r\n}\r\nstatic int dcbnl_pgrx_setcfg(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nreturn __dcbnl_pg_setcfg(netdev, tb, pid, seq, flags, 1);\r\n}\r\nstatic int dcbnl_bcn_getcfg(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nstruct sk_buff *dcbnl_skb;\r\nstruct nlmsghdr *nlh;\r\nstruct dcbmsg *dcb;\r\nstruct nlattr *bcn_nest;\r\nstruct nlattr *bcn_tb[DCB_BCN_ATTR_MAX + 1];\r\nu8 value_byte;\r\nu32 value_integer;\r\nint ret = -EINVAL;\r\nbool getall = false;\r\nint i;\r\nif (!tb[DCB_ATTR_BCN] || !netdev->dcbnl_ops->getbcnrp ||\r\n!netdev->dcbnl_ops->getbcncfg)\r\nreturn ret;\r\nret = nla_parse_nested(bcn_tb, DCB_BCN_ATTR_MAX,\r\ntb[DCB_ATTR_BCN], dcbnl_bcn_nest);\r\nif (ret)\r\ngoto err_out;\r\ndcbnl_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!dcbnl_skb)\r\ngoto err_out;\r\nnlh = NLMSG_NEW(dcbnl_skb, pid, seq, RTM_GETDCB, sizeof(*dcb), flags);\r\ndcb = NLMSG_DATA(nlh);\r\ndcb->dcb_family = AF_UNSPEC;\r\ndcb->cmd = DCB_CMD_BCN_GCFG;\r\nbcn_nest = nla_nest_start(dcbnl_skb, DCB_ATTR_BCN);\r\nif (!bcn_nest)\r\ngoto err;\r\nif (bcn_tb[DCB_BCN_ATTR_ALL])\r\ngetall = true;\r\nfor (i = DCB_BCN_ATTR_RP_0; i <= DCB_BCN_ATTR_RP_7; i++) {\r\nif (!getall && !bcn_tb[i])\r\ncontinue;\r\nnetdev->dcbnl_ops->getbcnrp(netdev, i - DCB_BCN_ATTR_RP_0,\r\n&value_byte);\r\nret = nla_put_u8(dcbnl_skb, i, value_byte);\r\nif (ret)\r\ngoto err_bcn;\r\n}\r\nfor (i = DCB_BCN_ATTR_BCNA_0; i <= DCB_BCN_ATTR_RI; i++) {\r\nif (!getall && !bcn_tb[i])\r\ncontinue;\r\nnetdev->dcbnl_ops->getbcncfg(netdev, i,\r\n&value_integer);\r\nret = nla_put_u32(dcbnl_skb, i, value_integer);\r\nif (ret)\r\ngoto err_bcn;\r\n}\r\nnla_nest_end(dcbnl_skb, bcn_nest);\r\nnlmsg_end(dcbnl_skb, nlh);\r\nret = rtnl_unicast(dcbnl_skb, &init_net, pid);\r\nif (ret)\r\ngoto err_out;\r\nreturn 0;\r\nerr_bcn:\r\nnla_nest_cancel(dcbnl_skb, bcn_nest);\r\nnlmsg_failure:\r\nerr:\r\nkfree_skb(dcbnl_skb);\r\nerr_out:\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int dcbnl_bcn_setcfg(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nstruct nlattr *data[DCB_BCN_ATTR_MAX + 1];\r\nint i;\r\nint ret = -EINVAL;\r\nu8 value_byte;\r\nu32 value_int;\r\nif (!tb[DCB_ATTR_BCN] || !netdev->dcbnl_ops->setbcncfg ||\r\n!netdev->dcbnl_ops->setbcnrp)\r\nreturn ret;\r\nret = nla_parse_nested(data, DCB_BCN_ATTR_MAX,\r\ntb[DCB_ATTR_BCN],\r\ndcbnl_pfc_up_nest);\r\nif (ret)\r\ngoto err;\r\nfor (i = DCB_BCN_ATTR_RP_0; i <= DCB_BCN_ATTR_RP_7; i++) {\r\nif (data[i] == NULL)\r\ncontinue;\r\nvalue_byte = nla_get_u8(data[i]);\r\nnetdev->dcbnl_ops->setbcnrp(netdev,\r\ndata[i]->nla_type - DCB_BCN_ATTR_RP_0, value_byte);\r\n}\r\nfor (i = DCB_BCN_ATTR_BCNA_0; i <= DCB_BCN_ATTR_RI; i++) {\r\nif (data[i] == NULL)\r\ncontinue;\r\nvalue_int = nla_get_u32(data[i]);\r\nnetdev->dcbnl_ops->setbcncfg(netdev,\r\ni, value_int);\r\n}\r\nret = dcbnl_reply(0, RTM_SETDCB, DCB_CMD_BCN_SCFG, DCB_ATTR_BCN,\r\npid, seq, flags);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int dcbnl_build_peer_app(struct net_device *netdev, struct sk_buff* skb,\r\nint app_nested_type, int app_info_type,\r\nint app_entry_type)\r\n{\r\nstruct dcb_peer_app_info info;\r\nstruct dcb_app *table = NULL;\r\nconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\r\nu16 app_count;\r\nint err;\r\nerr = ops->peer_getappinfo(netdev, &info, &app_count);\r\nif (!err && app_count) {\r\ntable = kmalloc(sizeof(struct dcb_app) * app_count, GFP_KERNEL);\r\nif (!table)\r\nreturn -ENOMEM;\r\nerr = ops->peer_getapptable(netdev, table);\r\n}\r\nif (!err) {\r\nu16 i;\r\nstruct nlattr *app;\r\nerr = -EMSGSIZE;\r\napp = nla_nest_start(skb, app_nested_type);\r\nif (!app)\r\ngoto nla_put_failure;\r\nif (app_info_type)\r\nNLA_PUT(skb, app_info_type, sizeof(info), &info);\r\nfor (i = 0; i < app_count; i++)\r\nNLA_PUT(skb, app_entry_type, sizeof(struct dcb_app),\r\n&table[i]);\r\nnla_nest_end(skb, app);\r\n}\r\nerr = 0;\r\nnla_put_failure:\r\nkfree(table);\r\nreturn err;\r\n}\r\nstatic int dcbnl_ieee_fill(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct nlattr *ieee, *app;\r\nstruct dcb_app_type *itr;\r\nconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\r\nint dcbx;\r\nint err = -EMSGSIZE;\r\nNLA_PUT_STRING(skb, DCB_ATTR_IFNAME, netdev->name);\r\nieee = nla_nest_start(skb, DCB_ATTR_IEEE);\r\nif (!ieee)\r\ngoto nla_put_failure;\r\nif (ops->ieee_getets) {\r\nstruct ieee_ets ets;\r\nerr = ops->ieee_getets(netdev, &ets);\r\nif (!err)\r\nNLA_PUT(skb, DCB_ATTR_IEEE_ETS, sizeof(ets), &ets);\r\n}\r\nif (ops->ieee_getpfc) {\r\nstruct ieee_pfc pfc;\r\nerr = ops->ieee_getpfc(netdev, &pfc);\r\nif (!err)\r\nNLA_PUT(skb, DCB_ATTR_IEEE_PFC, sizeof(pfc), &pfc);\r\n}\r\napp = nla_nest_start(skb, DCB_ATTR_IEEE_APP_TABLE);\r\nif (!app)\r\ngoto nla_put_failure;\r\nspin_lock(&dcb_lock);\r\nlist_for_each_entry(itr, &dcb_app_list, list) {\r\nif (itr->ifindex == netdev->ifindex) {\r\nerr = nla_put(skb, DCB_ATTR_IEEE_APP, sizeof(itr->app),\r\n&itr->app);\r\nif (err) {\r\nspin_unlock(&dcb_lock);\r\ngoto nla_put_failure;\r\n}\r\n}\r\n}\r\nif (netdev->dcbnl_ops->getdcbx)\r\ndcbx = netdev->dcbnl_ops->getdcbx(netdev);\r\nelse\r\ndcbx = -EOPNOTSUPP;\r\nspin_unlock(&dcb_lock);\r\nnla_nest_end(skb, app);\r\nif (ops->ieee_peer_getets) {\r\nstruct ieee_ets ets;\r\nerr = ops->ieee_peer_getets(netdev, &ets);\r\nif (!err)\r\nNLA_PUT(skb, DCB_ATTR_IEEE_PEER_ETS, sizeof(ets), &ets);\r\n}\r\nif (ops->ieee_peer_getpfc) {\r\nstruct ieee_pfc pfc;\r\nerr = ops->ieee_peer_getpfc(netdev, &pfc);\r\nif (!err)\r\nNLA_PUT(skb, DCB_ATTR_IEEE_PEER_PFC, sizeof(pfc), &pfc);\r\n}\r\nif (ops->peer_getappinfo && ops->peer_getapptable) {\r\nerr = dcbnl_build_peer_app(netdev, skb,\r\nDCB_ATTR_IEEE_PEER_APP,\r\nDCB_ATTR_IEEE_APP_UNSPEC,\r\nDCB_ATTR_IEEE_APP);\r\nif (err)\r\ngoto nla_put_failure;\r\n}\r\nnla_nest_end(skb, ieee);\r\nif (dcbx >= 0) {\r\nerr = nla_put_u8(skb, DCB_ATTR_DCBX, dcbx);\r\nif (err)\r\ngoto nla_put_failure;\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn err;\r\n}\r\nstatic int dcbnl_cee_pg_fill(struct sk_buff *skb, struct net_device *dev,\r\nint dir)\r\n{\r\nu8 pgid, up_map, prio, tc_pct;\r\nconst struct dcbnl_rtnl_ops *ops = dev->dcbnl_ops;\r\nint i = dir ? DCB_ATTR_CEE_TX_PG : DCB_ATTR_CEE_RX_PG;\r\nstruct nlattr *pg = nla_nest_start(skb, i);\r\nif (!pg)\r\ngoto nla_put_failure;\r\nfor (i = DCB_PG_ATTR_TC_0; i <= DCB_PG_ATTR_TC_7; i++) {\r\nstruct nlattr *tc_nest = nla_nest_start(skb, i);\r\nif (!tc_nest)\r\ngoto nla_put_failure;\r\npgid = DCB_ATTR_VALUE_UNDEFINED;\r\nprio = DCB_ATTR_VALUE_UNDEFINED;\r\ntc_pct = DCB_ATTR_VALUE_UNDEFINED;\r\nup_map = DCB_ATTR_VALUE_UNDEFINED;\r\nif (!dir)\r\nops->getpgtccfgrx(dev, i - DCB_PG_ATTR_TC_0,\r\n&prio, &pgid, &tc_pct, &up_map);\r\nelse\r\nops->getpgtccfgtx(dev, i - DCB_PG_ATTR_TC_0,\r\n&prio, &pgid, &tc_pct, &up_map);\r\nNLA_PUT_U8(skb, DCB_TC_ATTR_PARAM_PGID, pgid);\r\nNLA_PUT_U8(skb, DCB_TC_ATTR_PARAM_UP_MAPPING, up_map);\r\nNLA_PUT_U8(skb, DCB_TC_ATTR_PARAM_STRICT_PRIO, prio);\r\nNLA_PUT_U8(skb, DCB_TC_ATTR_PARAM_BW_PCT, tc_pct);\r\nnla_nest_end(skb, tc_nest);\r\n}\r\nfor (i = DCB_PG_ATTR_BW_ID_0; i <= DCB_PG_ATTR_BW_ID_7; i++) {\r\ntc_pct = DCB_ATTR_VALUE_UNDEFINED;\r\nif (!dir)\r\nops->getpgbwgcfgrx(dev, i - DCB_PG_ATTR_BW_ID_0,\r\n&tc_pct);\r\nelse\r\nops->getpgbwgcfgtx(dev, i - DCB_PG_ATTR_BW_ID_0,\r\n&tc_pct);\r\nNLA_PUT_U8(skb, i, tc_pct);\r\n}\r\nnla_nest_end(skb, pg);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int dcbnl_cee_fill(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct nlattr *cee, *app;\r\nstruct dcb_app_type *itr;\r\nconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\r\nint dcbx, i, err = -EMSGSIZE;\r\nu8 value;\r\nNLA_PUT_STRING(skb, DCB_ATTR_IFNAME, netdev->name);\r\ncee = nla_nest_start(skb, DCB_ATTR_CEE);\r\nif (!cee)\r\ngoto nla_put_failure;\r\nif (ops->getpgtccfgtx && ops->getpgbwgcfgtx) {\r\nerr = dcbnl_cee_pg_fill(skb, netdev, 1);\r\nif (err)\r\ngoto nla_put_failure;\r\n}\r\nif (ops->getpgtccfgrx && ops->getpgbwgcfgrx) {\r\nerr = dcbnl_cee_pg_fill(skb, netdev, 0);\r\nif (err)\r\ngoto nla_put_failure;\r\n}\r\nif (ops->getpfccfg) {\r\nstruct nlattr *pfc_nest = nla_nest_start(skb, DCB_ATTR_CEE_PFC);\r\nif (!pfc_nest)\r\ngoto nla_put_failure;\r\nfor (i = DCB_PFC_UP_ATTR_0; i <= DCB_PFC_UP_ATTR_7; i++) {\r\nops->getpfccfg(netdev, i - DCB_PFC_UP_ATTR_0, &value);\r\nNLA_PUT_U8(skb, i, value);\r\n}\r\nnla_nest_end(skb, pfc_nest);\r\n}\r\nspin_lock(&dcb_lock);\r\napp = nla_nest_start(skb, DCB_ATTR_CEE_APP_TABLE);\r\nif (!app)\r\ngoto dcb_unlock;\r\nlist_for_each_entry(itr, &dcb_app_list, list) {\r\nif (itr->ifindex == netdev->ifindex) {\r\nstruct nlattr *app_nest = nla_nest_start(skb,\r\nDCB_ATTR_APP);\r\nif (!app_nest)\r\ngoto dcb_unlock;\r\nerr = nla_put_u8(skb, DCB_APP_ATTR_IDTYPE,\r\nitr->app.selector);\r\nif (err)\r\ngoto dcb_unlock;\r\nerr = nla_put_u16(skb, DCB_APP_ATTR_ID,\r\nitr->app.protocol);\r\nif (err)\r\ngoto dcb_unlock;\r\nerr = nla_put_u8(skb, DCB_APP_ATTR_PRIORITY,\r\nitr->app.priority);\r\nif (err)\r\ngoto dcb_unlock;\r\nnla_nest_end(skb, app_nest);\r\n}\r\n}\r\nnla_nest_end(skb, app);\r\nif (netdev->dcbnl_ops->getdcbx)\r\ndcbx = netdev->dcbnl_ops->getdcbx(netdev);\r\nelse\r\ndcbx = -EOPNOTSUPP;\r\nspin_unlock(&dcb_lock);\r\nif (ops->getfeatcfg) {\r\nstruct nlattr *feat = nla_nest_start(skb, DCB_ATTR_CEE_FEAT);\r\nif (!feat)\r\ngoto nla_put_failure;\r\nfor (i = DCB_FEATCFG_ATTR_ALL + 1; i <= DCB_FEATCFG_ATTR_MAX;\r\ni++)\r\nif (!ops->getfeatcfg(netdev, i, &value))\r\nNLA_PUT_U8(skb, i, value);\r\nnla_nest_end(skb, feat);\r\n}\r\nif (ops->cee_peer_getpg) {\r\nstruct cee_pg pg;\r\nerr = ops->cee_peer_getpg(netdev, &pg);\r\nif (!err)\r\nNLA_PUT(skb, DCB_ATTR_CEE_PEER_PG, sizeof(pg), &pg);\r\n}\r\nif (ops->cee_peer_getpfc) {\r\nstruct cee_pfc pfc;\r\nerr = ops->cee_peer_getpfc(netdev, &pfc);\r\nif (!err)\r\nNLA_PUT(skb, DCB_ATTR_CEE_PEER_PFC, sizeof(pfc), &pfc);\r\n}\r\nif (ops->peer_getappinfo && ops->peer_getapptable) {\r\nerr = dcbnl_build_peer_app(netdev, skb,\r\nDCB_ATTR_CEE_PEER_APP_TABLE,\r\nDCB_ATTR_CEE_PEER_APP_INFO,\r\nDCB_ATTR_CEE_PEER_APP);\r\nif (err)\r\ngoto nla_put_failure;\r\n}\r\nnla_nest_end(skb, cee);\r\nif (dcbx >= 0) {\r\nerr = nla_put_u8(skb, DCB_ATTR_DCBX, dcbx);\r\nif (err)\r\ngoto nla_put_failure;\r\n}\r\nreturn 0;\r\ndcb_unlock:\r\nspin_unlock(&dcb_lock);\r\nnla_put_failure:\r\nreturn err;\r\n}\r\nstatic int dcbnl_notify(struct net_device *dev, int event, int cmd,\r\nu32 seq, u32 pid, int dcbx_ver)\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct sk_buff *skb;\r\nstruct nlmsghdr *nlh;\r\nstruct dcbmsg *dcb;\r\nconst struct dcbnl_rtnl_ops *ops = dev->dcbnl_ops;\r\nint err;\r\nif (!ops)\r\nreturn -EOPNOTSUPP;\r\nskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOBUFS;\r\nnlh = nlmsg_put(skb, pid, 0, event, sizeof(*dcb), 0);\r\nif (nlh == NULL) {\r\nnlmsg_free(skb);\r\nreturn -EMSGSIZE;\r\n}\r\ndcb = NLMSG_DATA(nlh);\r\ndcb->dcb_family = AF_UNSPEC;\r\ndcb->cmd = cmd;\r\nif (dcbx_ver == DCB_CAP_DCBX_VER_IEEE)\r\nerr = dcbnl_ieee_fill(skb, dev);\r\nelse\r\nerr = dcbnl_cee_fill(skb, dev);\r\nif (err < 0) {\r\nnlmsg_cancel(skb, nlh);\r\nkfree_skb(skb);\r\nrtnl_set_sk_err(net, RTNLGRP_DCB, err);\r\n} else {\r\nnlmsg_end(skb, nlh);\r\nrtnl_notify(skb, net, 0, RTNLGRP_DCB, NULL, GFP_KERNEL);\r\n}\r\nreturn err;\r\n}\r\nint dcbnl_ieee_notify(struct net_device *dev, int event, int cmd,\r\nu32 seq, u32 pid)\r\n{\r\nreturn dcbnl_notify(dev, event, cmd, seq, pid, DCB_CAP_DCBX_VER_IEEE);\r\n}\r\nint dcbnl_cee_notify(struct net_device *dev, int event, int cmd,\r\nu32 seq, u32 pid)\r\n{\r\nreturn dcbnl_notify(dev, event, cmd, seq, pid, DCB_CAP_DCBX_VER_CEE);\r\n}\r\nstatic int dcbnl_ieee_set(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\r\nstruct nlattr *ieee[DCB_ATTR_IEEE_MAX + 1];\r\nint err = -EOPNOTSUPP;\r\nif (!ops)\r\nreturn err;\r\nif (!tb[DCB_ATTR_IEEE])\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(ieee, DCB_ATTR_IEEE_MAX,\r\ntb[DCB_ATTR_IEEE], dcbnl_ieee_policy);\r\nif (err)\r\nreturn err;\r\nif (ieee[DCB_ATTR_IEEE_ETS] && ops->ieee_setets) {\r\nstruct ieee_ets *ets = nla_data(ieee[DCB_ATTR_IEEE_ETS]);\r\nerr = ops->ieee_setets(netdev, ets);\r\nif (err)\r\ngoto err;\r\n}\r\nif (ieee[DCB_ATTR_IEEE_PFC] && ops->ieee_setpfc) {\r\nstruct ieee_pfc *pfc = nla_data(ieee[DCB_ATTR_IEEE_PFC]);\r\nerr = ops->ieee_setpfc(netdev, pfc);\r\nif (err)\r\ngoto err;\r\n}\r\nif (ieee[DCB_ATTR_IEEE_APP_TABLE]) {\r\nstruct nlattr *attr;\r\nint rem;\r\nnla_for_each_nested(attr, ieee[DCB_ATTR_IEEE_APP_TABLE], rem) {\r\nstruct dcb_app *app_data;\r\nif (nla_type(attr) != DCB_ATTR_IEEE_APP)\r\ncontinue;\r\napp_data = nla_data(attr);\r\nif (ops->ieee_setapp)\r\nerr = ops->ieee_setapp(netdev, app_data);\r\nelse\r\nerr = dcb_ieee_setapp(netdev, app_data);\r\nif (err)\r\ngoto err;\r\n}\r\n}\r\nerr:\r\ndcbnl_reply(err, RTM_SETDCB, DCB_CMD_IEEE_SET, DCB_ATTR_IEEE,\r\npid, seq, flags);\r\ndcbnl_ieee_notify(netdev, RTM_SETDCB, DCB_CMD_IEEE_SET, seq, 0);\r\nreturn err;\r\n}\r\nstatic int dcbnl_ieee_get(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nstruct net *net = dev_net(netdev);\r\nstruct sk_buff *skb;\r\nstruct nlmsghdr *nlh;\r\nstruct dcbmsg *dcb;\r\nconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\r\nint err;\r\nif (!ops)\r\nreturn -EOPNOTSUPP;\r\nskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOBUFS;\r\nnlh = nlmsg_put(skb, pid, seq, RTM_GETDCB, sizeof(*dcb), flags);\r\nif (nlh == NULL) {\r\nnlmsg_free(skb);\r\nreturn -EMSGSIZE;\r\n}\r\ndcb = NLMSG_DATA(nlh);\r\ndcb->dcb_family = AF_UNSPEC;\r\ndcb->cmd = DCB_CMD_IEEE_GET;\r\nerr = dcbnl_ieee_fill(skb, netdev);\r\nif (err < 0) {\r\nnlmsg_cancel(skb, nlh);\r\nkfree_skb(skb);\r\n} else {\r\nnlmsg_end(skb, nlh);\r\nerr = rtnl_unicast(skb, net, pid);\r\n}\r\nreturn err;\r\n}\r\nstatic int dcbnl_ieee_del(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\r\nstruct nlattr *ieee[DCB_ATTR_IEEE_MAX + 1];\r\nint err = -EOPNOTSUPP;\r\nif (!ops)\r\nreturn -EOPNOTSUPP;\r\nif (!tb[DCB_ATTR_IEEE])\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(ieee, DCB_ATTR_IEEE_MAX,\r\ntb[DCB_ATTR_IEEE], dcbnl_ieee_policy);\r\nif (err)\r\nreturn err;\r\nif (ieee[DCB_ATTR_IEEE_APP_TABLE]) {\r\nstruct nlattr *attr;\r\nint rem;\r\nnla_for_each_nested(attr, ieee[DCB_ATTR_IEEE_APP_TABLE], rem) {\r\nstruct dcb_app *app_data;\r\nif (nla_type(attr) != DCB_ATTR_IEEE_APP)\r\ncontinue;\r\napp_data = nla_data(attr);\r\nif (ops->ieee_delapp)\r\nerr = ops->ieee_delapp(netdev, app_data);\r\nelse\r\nerr = dcb_ieee_delapp(netdev, app_data);\r\nif (err)\r\ngoto err;\r\n}\r\n}\r\nerr:\r\ndcbnl_reply(err, RTM_SETDCB, DCB_CMD_IEEE_DEL, DCB_ATTR_IEEE,\r\npid, seq, flags);\r\ndcbnl_ieee_notify(netdev, RTM_SETDCB, DCB_CMD_IEEE_DEL, seq, 0);\r\nreturn err;\r\n}\r\nstatic int dcbnl_getdcbx(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nint ret;\r\nif (!netdev->dcbnl_ops->getdcbx)\r\nreturn -EOPNOTSUPP;\r\nret = dcbnl_reply(netdev->dcbnl_ops->getdcbx(netdev), RTM_GETDCB,\r\nDCB_CMD_GDCBX, DCB_ATTR_DCBX, pid, seq, flags);\r\nreturn ret;\r\n}\r\nstatic int dcbnl_setdcbx(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nint ret;\r\nu8 value;\r\nif (!netdev->dcbnl_ops->setdcbx)\r\nreturn -EOPNOTSUPP;\r\nif (!tb[DCB_ATTR_DCBX])\r\nreturn -EINVAL;\r\nvalue = nla_get_u8(tb[DCB_ATTR_DCBX]);\r\nret = dcbnl_reply(netdev->dcbnl_ops->setdcbx(netdev, value),\r\nRTM_SETDCB, DCB_CMD_SDCBX, DCB_ATTR_DCBX,\r\npid, seq, flags);\r\nreturn ret;\r\n}\r\nstatic int dcbnl_getfeatcfg(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nstruct sk_buff *dcbnl_skb;\r\nstruct nlmsghdr *nlh;\r\nstruct dcbmsg *dcb;\r\nstruct nlattr *data[DCB_FEATCFG_ATTR_MAX + 1], *nest;\r\nu8 value;\r\nint ret, i;\r\nint getall = 0;\r\nif (!netdev->dcbnl_ops->getfeatcfg)\r\nreturn -EOPNOTSUPP;\r\nif (!tb[DCB_ATTR_FEATCFG])\r\nreturn -EINVAL;\r\nret = nla_parse_nested(data, DCB_FEATCFG_ATTR_MAX, tb[DCB_ATTR_FEATCFG],\r\ndcbnl_featcfg_nest);\r\nif (ret)\r\ngoto err_out;\r\ndcbnl_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!dcbnl_skb) {\r\nret = -ENOBUFS;\r\ngoto err_out;\r\n}\r\nnlh = NLMSG_NEW(dcbnl_skb, pid, seq, RTM_GETDCB, sizeof(*dcb), flags);\r\ndcb = NLMSG_DATA(nlh);\r\ndcb->dcb_family = AF_UNSPEC;\r\ndcb->cmd = DCB_CMD_GFEATCFG;\r\nnest = nla_nest_start(dcbnl_skb, DCB_ATTR_FEATCFG);\r\nif (!nest) {\r\nret = -EMSGSIZE;\r\ngoto nla_put_failure;\r\n}\r\nif (data[DCB_FEATCFG_ATTR_ALL])\r\ngetall = 1;\r\nfor (i = DCB_FEATCFG_ATTR_ALL+1; i <= DCB_FEATCFG_ATTR_MAX; i++) {\r\nif (!getall && !data[i])\r\ncontinue;\r\nret = netdev->dcbnl_ops->getfeatcfg(netdev, i, &value);\r\nif (!ret)\r\nret = nla_put_u8(dcbnl_skb, i, value);\r\nif (ret) {\r\nnla_nest_cancel(dcbnl_skb, nest);\r\ngoto nla_put_failure;\r\n}\r\n}\r\nnla_nest_end(dcbnl_skb, nest);\r\nnlmsg_end(dcbnl_skb, nlh);\r\nreturn rtnl_unicast(dcbnl_skb, &init_net, pid);\r\nnla_put_failure:\r\nnlmsg_cancel(dcbnl_skb, nlh);\r\nnlmsg_failure:\r\nkfree_skb(dcbnl_skb);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic int dcbnl_setfeatcfg(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nstruct nlattr *data[DCB_FEATCFG_ATTR_MAX + 1];\r\nint ret, i;\r\nu8 value;\r\nif (!netdev->dcbnl_ops->setfeatcfg)\r\nreturn -ENOTSUPP;\r\nif (!tb[DCB_ATTR_FEATCFG])\r\nreturn -EINVAL;\r\nret = nla_parse_nested(data, DCB_FEATCFG_ATTR_MAX, tb[DCB_ATTR_FEATCFG],\r\ndcbnl_featcfg_nest);\r\nif (ret)\r\ngoto err;\r\nfor (i = DCB_FEATCFG_ATTR_ALL+1; i <= DCB_FEATCFG_ATTR_MAX; i++) {\r\nif (data[i] == NULL)\r\ncontinue;\r\nvalue = nla_get_u8(data[i]);\r\nret = netdev->dcbnl_ops->setfeatcfg(netdev, i, value);\r\nif (ret)\r\ngoto err;\r\n}\r\nerr:\r\ndcbnl_reply(ret, RTM_SETDCB, DCB_CMD_SFEATCFG, DCB_ATTR_FEATCFG,\r\npid, seq, flags);\r\nreturn ret;\r\n}\r\nstatic int dcbnl_cee_get(struct net_device *netdev, struct nlattr **tb,\r\nu32 pid, u32 seq, u16 flags)\r\n{\r\nstruct net *net = dev_net(netdev);\r\nstruct sk_buff *skb;\r\nstruct nlmsghdr *nlh;\r\nstruct dcbmsg *dcb;\r\nconst struct dcbnl_rtnl_ops *ops = netdev->dcbnl_ops;\r\nint err;\r\nif (!ops)\r\nreturn -EOPNOTSUPP;\r\nskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOBUFS;\r\nnlh = nlmsg_put(skb, pid, seq, RTM_GETDCB, sizeof(*dcb), flags);\r\nif (nlh == NULL) {\r\nnlmsg_free(skb);\r\nreturn -EMSGSIZE;\r\n}\r\ndcb = NLMSG_DATA(nlh);\r\ndcb->dcb_family = AF_UNSPEC;\r\ndcb->cmd = DCB_CMD_CEE_GET;\r\nerr = dcbnl_cee_fill(skb, netdev);\r\nif (err < 0) {\r\nnlmsg_cancel(skb, nlh);\r\nnlmsg_free(skb);\r\n} else {\r\nnlmsg_end(skb, nlh);\r\nerr = rtnl_unicast(skb, net, pid);\r\n}\r\nreturn err;\r\n}\r\nstatic int dcb_doit(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct net_device *netdev;\r\nstruct dcbmsg *dcb = (struct dcbmsg *)NLMSG_DATA(nlh);\r\nstruct nlattr *tb[DCB_ATTR_MAX + 1];\r\nu32 pid = skb ? NETLINK_CB(skb).pid : 0;\r\nint ret = -EINVAL;\r\nif (!net_eq(net, &init_net))\r\nreturn -EINVAL;\r\nret = nlmsg_parse(nlh, sizeof(*dcb), tb, DCB_ATTR_MAX,\r\ndcbnl_rtnl_policy);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!tb[DCB_ATTR_IFNAME])\r\nreturn -EINVAL;\r\nnetdev = dev_get_by_name(&init_net, nla_data(tb[DCB_ATTR_IFNAME]));\r\nif (!netdev)\r\nreturn -EINVAL;\r\nif (!netdev->dcbnl_ops)\r\ngoto errout;\r\nswitch (dcb->cmd) {\r\ncase DCB_CMD_GSTATE:\r\nret = dcbnl_getstate(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_PFC_GCFG:\r\nret = dcbnl_getpfccfg(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_GPERM_HWADDR:\r\nret = dcbnl_getperm_hwaddr(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_PGTX_GCFG:\r\nret = dcbnl_pgtx_getcfg(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_PGRX_GCFG:\r\nret = dcbnl_pgrx_getcfg(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_BCN_GCFG:\r\nret = dcbnl_bcn_getcfg(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_SSTATE:\r\nret = dcbnl_setstate(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_PFC_SCFG:\r\nret = dcbnl_setpfccfg(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_SET_ALL:\r\nret = dcbnl_setall(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_PGTX_SCFG:\r\nret = dcbnl_pgtx_setcfg(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_PGRX_SCFG:\r\nret = dcbnl_pgrx_setcfg(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_GCAP:\r\nret = dcbnl_getcap(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_GNUMTCS:\r\nret = dcbnl_getnumtcs(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_SNUMTCS:\r\nret = dcbnl_setnumtcs(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_PFC_GSTATE:\r\nret = dcbnl_getpfcstate(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_PFC_SSTATE:\r\nret = dcbnl_setpfcstate(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_BCN_SCFG:\r\nret = dcbnl_bcn_setcfg(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_GAPP:\r\nret = dcbnl_getapp(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_SAPP:\r\nret = dcbnl_setapp(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_IEEE_SET:\r\nret = dcbnl_ieee_set(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_IEEE_GET:\r\nret = dcbnl_ieee_get(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_IEEE_DEL:\r\nret = dcbnl_ieee_del(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_GDCBX:\r\nret = dcbnl_getdcbx(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_SDCBX:\r\nret = dcbnl_setdcbx(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_GFEATCFG:\r\nret = dcbnl_getfeatcfg(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_SFEATCFG:\r\nret = dcbnl_setfeatcfg(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ncase DCB_CMD_CEE_GET:\r\nret = dcbnl_cee_get(netdev, tb, pid, nlh->nlmsg_seq,\r\nnlh->nlmsg_flags);\r\ngoto out;\r\ndefault:\r\ngoto errout;\r\n}\r\nerrout:\r\nret = -EINVAL;\r\nout:\r\ndev_put(netdev);\r\nreturn ret;\r\n}\r\nu8 dcb_getapp(struct net_device *dev, struct dcb_app *app)\r\n{\r\nstruct dcb_app_type *itr;\r\nu8 prio = 0;\r\nspin_lock(&dcb_lock);\r\nlist_for_each_entry(itr, &dcb_app_list, list) {\r\nif (itr->app.selector == app->selector &&\r\nitr->app.protocol == app->protocol &&\r\nitr->ifindex == dev->ifindex) {\r\nprio = itr->app.priority;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&dcb_lock);\r\nreturn prio;\r\n}\r\nint dcb_setapp(struct net_device *dev, struct dcb_app *new)\r\n{\r\nstruct dcb_app_type *itr;\r\nstruct dcb_app_type event;\r\nevent.ifindex = dev->ifindex;\r\nmemcpy(&event.app, new, sizeof(event.app));\r\nif (dev->dcbnl_ops->getdcbx)\r\nevent.dcbx = dev->dcbnl_ops->getdcbx(dev);\r\nspin_lock(&dcb_lock);\r\nlist_for_each_entry(itr, &dcb_app_list, list) {\r\nif (itr->app.selector == new->selector &&\r\nitr->app.protocol == new->protocol &&\r\nitr->ifindex == dev->ifindex) {\r\nif (new->priority)\r\nitr->app.priority = new->priority;\r\nelse {\r\nlist_del(&itr->list);\r\nkfree(itr);\r\n}\r\ngoto out;\r\n}\r\n}\r\nif (new->priority) {\r\nstruct dcb_app_type *entry;\r\nentry = kmalloc(sizeof(struct dcb_app_type), GFP_ATOMIC);\r\nif (!entry) {\r\nspin_unlock(&dcb_lock);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(&entry->app, new, sizeof(*new));\r\nentry->ifindex = dev->ifindex;\r\nlist_add(&entry->list, &dcb_app_list);\r\n}\r\nout:\r\nspin_unlock(&dcb_lock);\r\ncall_dcbevent_notifiers(DCB_APP_EVENT, &event);\r\nreturn 0;\r\n}\r\nu8 dcb_ieee_getapp_mask(struct net_device *dev, struct dcb_app *app)\r\n{\r\nstruct dcb_app_type *itr;\r\nu8 prio = 0;\r\nspin_lock(&dcb_lock);\r\nlist_for_each_entry(itr, &dcb_app_list, list) {\r\nif (itr->app.selector == app->selector &&\r\nitr->app.protocol == app->protocol &&\r\nitr->ifindex == dev->ifindex) {\r\nprio |= 1 << itr->app.priority;\r\n}\r\n}\r\nspin_unlock(&dcb_lock);\r\nreturn prio;\r\n}\r\nint dcb_ieee_setapp(struct net_device *dev, struct dcb_app *new)\r\n{\r\nstruct dcb_app_type *itr, *entry;\r\nstruct dcb_app_type event;\r\nint err = 0;\r\nevent.ifindex = dev->ifindex;\r\nmemcpy(&event.app, new, sizeof(event.app));\r\nif (dev->dcbnl_ops->getdcbx)\r\nevent.dcbx = dev->dcbnl_ops->getdcbx(dev);\r\nspin_lock(&dcb_lock);\r\nlist_for_each_entry(itr, &dcb_app_list, list) {\r\nif (itr->app.selector == new->selector &&\r\nitr->app.protocol == new->protocol &&\r\nitr->app.priority == new->priority &&\r\nitr->ifindex == dev->ifindex) {\r\nerr = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nentry = kmalloc(sizeof(struct dcb_app_type), GFP_ATOMIC);\r\nif (!entry) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(&entry->app, new, sizeof(*new));\r\nentry->ifindex = dev->ifindex;\r\nlist_add(&entry->list, &dcb_app_list);\r\nout:\r\nspin_unlock(&dcb_lock);\r\nif (!err)\r\ncall_dcbevent_notifiers(DCB_APP_EVENT, &event);\r\nreturn err;\r\n}\r\nint dcb_ieee_delapp(struct net_device *dev, struct dcb_app *del)\r\n{\r\nstruct dcb_app_type *itr;\r\nstruct dcb_app_type event;\r\nint err = -ENOENT;\r\nevent.ifindex = dev->ifindex;\r\nmemcpy(&event.app, del, sizeof(event.app));\r\nif (dev->dcbnl_ops->getdcbx)\r\nevent.dcbx = dev->dcbnl_ops->getdcbx(dev);\r\nspin_lock(&dcb_lock);\r\nlist_for_each_entry(itr, &dcb_app_list, list) {\r\nif (itr->app.selector == del->selector &&\r\nitr->app.protocol == del->protocol &&\r\nitr->app.priority == del->priority &&\r\nitr->ifindex == dev->ifindex) {\r\nlist_del(&itr->list);\r\nkfree(itr);\r\nerr = 0;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nspin_unlock(&dcb_lock);\r\nif (!err)\r\ncall_dcbevent_notifiers(DCB_APP_EVENT, &event);\r\nreturn err;\r\n}\r\nstatic void dcb_flushapp(void)\r\n{\r\nstruct dcb_app_type *app;\r\nstruct dcb_app_type *tmp;\r\nspin_lock(&dcb_lock);\r\nlist_for_each_entry_safe(app, tmp, &dcb_app_list, list) {\r\nlist_del(&app->list);\r\nkfree(app);\r\n}\r\nspin_unlock(&dcb_lock);\r\n}\r\nstatic int __init dcbnl_init(void)\r\n{\r\nINIT_LIST_HEAD(&dcb_app_list);\r\nrtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);\r\nrtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, NULL);\r\nreturn 0;\r\n}\r\nstatic void __exit dcbnl_exit(void)\r\n{\r\nrtnl_unregister(PF_UNSPEC, RTM_GETDCB);\r\nrtnl_unregister(PF_UNSPEC, RTM_SETDCB);\r\ndcb_flushapp();\r\n}
