static loff_t get_pos(struct dnode *d, struct hpfs_dirent *fde)\r\n{\r\nstruct hpfs_dirent *de;\r\nstruct hpfs_dirent *de_end = dnode_end_de(d);\r\nint i = 1;\r\nfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\r\nif (de == fde) return ((loff_t) le32_to_cpu(d->self) << 4) | (loff_t)i;\r\ni++;\r\n}\r\nprintk("HPFS: get_pos: not_found\n");\r\nreturn ((loff_t)le32_to_cpu(d->self) << 4) | (loff_t)1;\r\n}\r\nvoid hpfs_add_pos(struct inode *inode, loff_t *pos)\r\n{\r\nstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\r\nint i = 0;\r\nloff_t **ppos;\r\nif (hpfs_inode->i_rddir_off)\r\nfor (; hpfs_inode->i_rddir_off[i]; i++)\r\nif (hpfs_inode->i_rddir_off[i] == pos) return;\r\nif (!(i&0x0f)) {\r\nif (!(ppos = kmalloc((i+0x11) * sizeof(loff_t*), GFP_NOFS))) {\r\nprintk("HPFS: out of memory for position list\n");\r\nreturn;\r\n}\r\nif (hpfs_inode->i_rddir_off) {\r\nmemcpy(ppos, hpfs_inode->i_rddir_off, i * sizeof(loff_t));\r\nkfree(hpfs_inode->i_rddir_off);\r\n}\r\nhpfs_inode->i_rddir_off = ppos;\r\n}\r\nhpfs_inode->i_rddir_off[i] = pos;\r\nhpfs_inode->i_rddir_off[i + 1] = NULL;\r\n}\r\nvoid hpfs_del_pos(struct inode *inode, loff_t *pos)\r\n{\r\nstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\r\nloff_t **i, **j;\r\nif (!hpfs_inode->i_rddir_off) goto not_f;\r\nfor (i = hpfs_inode->i_rddir_off; *i; i++) if (*i == pos) goto fnd;\r\ngoto not_f;\r\nfnd:\r\nfor (j = i + 1; *j; j++) ;\r\n*i = *(j - 1);\r\n*(j - 1) = NULL;\r\nif (j - 1 == hpfs_inode->i_rddir_off) {\r\nkfree(hpfs_inode->i_rddir_off);\r\nhpfs_inode->i_rddir_off = NULL;\r\n}\r\nreturn;\r\nnot_f:\r\nreturn;\r\n}\r\nstatic void for_all_poss(struct inode *inode, void (*f)(loff_t *, loff_t, loff_t),\r\nloff_t p1, loff_t p2)\r\n{\r\nstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\r\nloff_t **i;\r\nif (!hpfs_inode->i_rddir_off) return;\r\nfor (i = hpfs_inode->i_rddir_off; *i; i++) (*f)(*i, p1, p2);\r\nreturn;\r\n}\r\nstatic void hpfs_pos_subst(loff_t *p, loff_t f, loff_t t)\r\n{\r\nif (*p == f) *p = t;\r\n}\r\nstatic void hpfs_pos_ins(loff_t *p, loff_t d, loff_t c)\r\n{\r\nif ((*p & ~0x3f) == (d & ~0x3f) && (*p & 0x3f) >= (d & 0x3f)) {\r\nint n = (*p & 0x3f) + c;\r\nif (n > 0x3f) printk("HPFS: hpfs_pos_ins: %08x + %d\n", (int)*p, (int)c >> 8);\r\nelse *p = (*p & ~0x3f) | n;\r\n}\r\n}\r\nstatic void hpfs_pos_del(loff_t *p, loff_t d, loff_t c)\r\n{\r\nif ((*p & ~0x3f) == (d & ~0x3f) && (*p & 0x3f) >= (d & 0x3f)) {\r\nint n = (*p & 0x3f) - c;\r\nif (n < 1) printk("HPFS: hpfs_pos_ins: %08x - %d\n", (int)*p, (int)c >> 8);\r\nelse *p = (*p & ~0x3f) | n;\r\n}\r\n}\r\nstatic struct hpfs_dirent *dnode_pre_last_de(struct dnode *d)\r\n{\r\nstruct hpfs_dirent *de, *de_end, *dee = NULL, *deee = NULL;\r\nde_end = dnode_end_de(d);\r\nfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\r\ndeee = dee; dee = de;\r\n}\r\nreturn deee;\r\n}\r\nstatic struct hpfs_dirent *dnode_last_de(struct dnode *d)\r\n{\r\nstruct hpfs_dirent *de, *de_end, *dee = NULL;\r\nde_end = dnode_end_de(d);\r\nfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\r\ndee = de;\r\n}\r\nreturn dee;\r\n}\r\nstatic void set_last_pointer(struct super_block *s, struct dnode *d, dnode_secno ptr)\r\n{\r\nstruct hpfs_dirent *de;\r\nif (!(de = dnode_last_de(d))) {\r\nhpfs_error(s, "set_last_pointer: empty dnode %08x", le32_to_cpu(d->self));\r\nreturn;\r\n}\r\nif (hpfs_sb(s)->sb_chk) {\r\nif (de->down) {\r\nhpfs_error(s, "set_last_pointer: dnode %08x has already last pointer %08x",\r\nle32_to_cpu(d->self), de_down_pointer(de));\r\nreturn;\r\n}\r\nif (le16_to_cpu(de->length) != 32) {\r\nhpfs_error(s, "set_last_pointer: bad last dirent in dnode %08x", le32_to_cpu(d->self));\r\nreturn;\r\n}\r\n}\r\nif (ptr) {\r\nd->first_free = cpu_to_le32(le32_to_cpu(d->first_free) + 4);\r\nif (le32_to_cpu(d->first_free) > 2048) {\r\nhpfs_error(s, "set_last_pointer: too long dnode %08x", le32_to_cpu(d->self));\r\nd->first_free = cpu_to_le32(le32_to_cpu(d->first_free) - 4);\r\nreturn;\r\n}\r\nde->length = cpu_to_le16(36);\r\nde->down = 1;\r\n*(dnode_secno *)((char *)de + 32) = cpu_to_le32(ptr);\r\n}\r\n}\r\nstruct hpfs_dirent *hpfs_add_de(struct super_block *s, struct dnode *d,\r\nconst unsigned char *name,\r\nunsigned namelen, secno down_ptr)\r\n{\r\nstruct hpfs_dirent *de;\r\nstruct hpfs_dirent *de_end = dnode_end_de(d);\r\nunsigned d_size = de_size(namelen, down_ptr);\r\nfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\r\nint c = hpfs_compare_names(s, name, namelen, de->name, de->namelen, de->last);\r\nif (!c) {\r\nhpfs_error(s, "name (%c,%d) already exists in dnode %08x", *name, namelen, le32_to_cpu(d->self));\r\nreturn NULL;\r\n}\r\nif (c < 0) break;\r\n}\r\nmemmove((char *)de + d_size, de, (char *)de_end - (char *)de);\r\nmemset(de, 0, d_size);\r\nif (down_ptr) {\r\n*(dnode_secno *)((char *)de + d_size - 4) = cpu_to_le32(down_ptr);\r\nde->down = 1;\r\n}\r\nde->length = cpu_to_le16(d_size);\r\nde->not_8x3 = hpfs_is_name_long(name, namelen);\r\nde->namelen = namelen;\r\nmemcpy(de->name, name, namelen);\r\nd->first_free = cpu_to_le32(le32_to_cpu(d->first_free) + d_size);\r\nreturn de;\r\n}\r\nstatic void hpfs_delete_de(struct super_block *s, struct dnode *d,\r\nstruct hpfs_dirent *de)\r\n{\r\nif (de->last) {\r\nhpfs_error(s, "attempt to delete last dirent in dnode %08x", le32_to_cpu(d->self));\r\nreturn;\r\n}\r\nd->first_free = cpu_to_le32(le32_to_cpu(d->first_free) - le16_to_cpu(de->length));\r\nmemmove(de, de_next_de(de), le32_to_cpu(d->first_free) + (char *)d - (char *)de);\r\n}\r\nstatic void fix_up_ptrs(struct super_block *s, struct dnode *d)\r\n{\r\nstruct hpfs_dirent *de;\r\nstruct hpfs_dirent *de_end = dnode_end_de(d);\r\ndnode_secno dno = le32_to_cpu(d->self);\r\nfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de))\r\nif (de->down) {\r\nstruct quad_buffer_head qbh;\r\nstruct dnode *dd;\r\nif ((dd = hpfs_map_dnode(s, de_down_pointer(de), &qbh))) {\r\nif (le32_to_cpu(dd->up) != dno || dd->root_dnode) {\r\ndd->up = cpu_to_le32(dno);\r\ndd->root_dnode = 0;\r\nhpfs_mark_4buffers_dirty(&qbh);\r\n}\r\nhpfs_brelse4(&qbh);\r\n}\r\n}\r\n}\r\nstatic int hpfs_add_to_dnode(struct inode *i, dnode_secno dno,\r\nconst unsigned char *name, unsigned namelen,\r\nstruct hpfs_dirent *new_de, dnode_secno down_ptr)\r\n{\r\nstruct quad_buffer_head qbh, qbh1, qbh2;\r\nstruct dnode *d, *ad, *rd, *nd = NULL;\r\ndnode_secno adno, rdno;\r\nstruct hpfs_dirent *de;\r\nstruct hpfs_dirent nde;\r\nunsigned char *nname;\r\nint h;\r\nint pos;\r\nstruct buffer_head *bh;\r\nstruct fnode *fnode;\r\nint c1, c2 = 0;\r\nif (!(nname = kmalloc(256, GFP_NOFS))) {\r\nprintk("HPFS: out of memory, can't add to dnode\n");\r\nreturn 1;\r\n}\r\ngo_up:\r\nif (namelen >= 256) {\r\nhpfs_error(i->i_sb, "hpfs_add_to_dnode: namelen == %d", namelen);\r\nkfree(nd);\r\nkfree(nname);\r\nreturn 1;\r\n}\r\nif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) {\r\nkfree(nd);\r\nkfree(nname);\r\nreturn 1;\r\n}\r\ngo_up_a:\r\nif (hpfs_sb(i->i_sb)->sb_chk)\r\nif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, "hpfs_add_to_dnode")) {\r\nhpfs_brelse4(&qbh);\r\nkfree(nd);\r\nkfree(nname);\r\nreturn 1;\r\n}\r\nif (le32_to_cpu(d->first_free) + de_size(namelen, down_ptr) <= 2048) {\r\nloff_t t;\r\ncopy_de(de=hpfs_add_de(i->i_sb, d, name, namelen, down_ptr), new_de);\r\nt = get_pos(d, de);\r\nfor_all_poss(i, hpfs_pos_ins, t, 1);\r\nfor_all_poss(i, hpfs_pos_subst, 4, t);\r\nfor_all_poss(i, hpfs_pos_subst, 5, t + 1);\r\nhpfs_mark_4buffers_dirty(&qbh);\r\nhpfs_brelse4(&qbh);\r\nkfree(nd);\r\nkfree(nname);\r\nreturn 0;\r\n}\r\nif (!nd) if (!(nd = kmalloc(0x924, GFP_NOFS))) {\r\nprintk("HPFS: out of memory for dnode splitting\n");\r\nhpfs_brelse4(&qbh);\r\nkfree(nname);\r\nreturn 1;\r\n}\r\nmemcpy(nd, d, le32_to_cpu(d->first_free));\r\ncopy_de(de = hpfs_add_de(i->i_sb, nd, name, namelen, down_ptr), new_de);\r\nfor_all_poss(i, hpfs_pos_ins, get_pos(nd, de), 1);\r\nh = ((char *)dnode_last_de(nd) - (char *)nd) / 2 + 10;\r\nif (!(ad = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &adno, &qbh1))) {\r\nhpfs_error(i->i_sb, "unable to alloc dnode - dnode tree will be corrupted");\r\nhpfs_brelse4(&qbh);\r\nkfree(nd);\r\nkfree(nname);\r\nreturn 1;\r\n}\r\ni->i_size += 2048;\r\ni->i_blocks += 4;\r\npos = 1;\r\nfor (de = dnode_first_de(nd); (char *)de_next_de(de) - (char *)nd < h; de = de_next_de(de)) {\r\ncopy_de(hpfs_add_de(i->i_sb, ad, de->name, de->namelen, de->down ? de_down_pointer(de) : 0), de);\r\nfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, ((loff_t)adno << 4) | pos);\r\npos++;\r\n}\r\ncopy_de(new_de = &nde, de);\r\nmemcpy(nname, de->name, de->namelen);\r\nname = nname;\r\nnamelen = de->namelen;\r\nfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, 4);\r\ndown_ptr = adno;\r\nset_last_pointer(i->i_sb, ad, de->down ? de_down_pointer(de) : 0);\r\nde = de_next_de(de);\r\nmemmove((char *)nd + 20, de, le32_to_cpu(nd->first_free) + (char *)nd - (char *)de);\r\nnd->first_free = cpu_to_le32(le32_to_cpu(nd->first_free) - ((char *)de - (char *)nd - 20));\r\nmemcpy(d, nd, le32_to_cpu(nd->first_free));\r\nfor_all_poss(i, hpfs_pos_del, (loff_t)dno << 4, pos);\r\nfix_up_ptrs(i->i_sb, ad);\r\nif (!d->root_dnode) {\r\nad->up = d->up;\r\ndno = le32_to_cpu(ad->up);\r\nhpfs_mark_4buffers_dirty(&qbh);\r\nhpfs_brelse4(&qbh);\r\nhpfs_mark_4buffers_dirty(&qbh1);\r\nhpfs_brelse4(&qbh1);\r\ngoto go_up;\r\n}\r\nif (!(rd = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &rdno, &qbh2))) {\r\nhpfs_error(i->i_sb, "unable to alloc dnode - dnode tree will be corrupted");\r\nhpfs_brelse4(&qbh);\r\nhpfs_brelse4(&qbh1);\r\nkfree(nd);\r\nkfree(nname);\r\nreturn 1;\r\n}\r\ni->i_size += 2048;\r\ni->i_blocks += 4;\r\nrd->root_dnode = 1;\r\nrd->up = d->up;\r\nif (!(fnode = hpfs_map_fnode(i->i_sb, le32_to_cpu(d->up), &bh))) {\r\nhpfs_free_dnode(i->i_sb, rdno);\r\nhpfs_brelse4(&qbh);\r\nhpfs_brelse4(&qbh1);\r\nhpfs_brelse4(&qbh2);\r\nkfree(nd);\r\nkfree(nname);\r\nreturn 1;\r\n}\r\nfnode->u.external[0].disk_secno = cpu_to_le32(rdno);\r\nmark_buffer_dirty(bh);\r\nbrelse(bh);\r\nhpfs_i(i)->i_dno = rdno;\r\nd->up = ad->up = cpu_to_le32(rdno);\r\nd->root_dnode = ad->root_dnode = 0;\r\nhpfs_mark_4buffers_dirty(&qbh);\r\nhpfs_brelse4(&qbh);\r\nhpfs_mark_4buffers_dirty(&qbh1);\r\nhpfs_brelse4(&qbh1);\r\nqbh = qbh2;\r\nset_last_pointer(i->i_sb, rd, dno);\r\ndno = rdno;\r\nd = rd;\r\ngoto go_up_a;\r\n}\r\nint hpfs_add_dirent(struct inode *i,\r\nconst unsigned char *name, unsigned namelen,\r\nstruct hpfs_dirent *new_de)\r\n{\r\nstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\r\nstruct dnode *d;\r\nstruct hpfs_dirent *de, *de_end;\r\nstruct quad_buffer_head qbh;\r\ndnode_secno dno;\r\nint c;\r\nint c1, c2 = 0;\r\ndno = hpfs_inode->i_dno;\r\ndown:\r\nif (hpfs_sb(i->i_sb)->sb_chk)\r\nif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, "hpfs_add_dirent")) return 1;\r\nif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 1;\r\nde_end = dnode_end_de(d);\r\nfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\r\nif (!(c = hpfs_compare_names(i->i_sb, name, namelen, de->name, de->namelen, de->last))) {\r\nhpfs_brelse4(&qbh);\r\nreturn -1;\r\n}\r\nif (c < 0) {\r\nif (de->down) {\r\ndno = de_down_pointer(de);\r\nhpfs_brelse4(&qbh);\r\ngoto down;\r\n}\r\nbreak;\r\n}\r\n}\r\nhpfs_brelse4(&qbh);\r\nif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_ADD)) {\r\nc = 1;\r\ngoto ret;\r\n}\r\ni->i_version++;\r\nc = hpfs_add_to_dnode(i, dno, name, namelen, new_de, 0);\r\nret:\r\nreturn c;\r\n}\r\nstatic secno move_to_top(struct inode *i, dnode_secno from, dnode_secno to)\r\n{\r\ndnode_secno dno, ddno;\r\ndnode_secno chk_up = to;\r\nstruct dnode *dnode;\r\nstruct quad_buffer_head qbh;\r\nstruct hpfs_dirent *de, *nde;\r\nint a;\r\nloff_t t;\r\nint c1, c2 = 0;\r\ndno = from;\r\nwhile (1) {\r\nif (hpfs_sb(i->i_sb)->sb_chk)\r\nif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, "move_to_top"))\r\nreturn 0;\r\nif (!(dnode = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 0;\r\nif (hpfs_sb(i->i_sb)->sb_chk) {\r\nif (le32_to_cpu(dnode->up) != chk_up) {\r\nhpfs_error(i->i_sb, "move_to_top: up pointer from %08x should be %08x, is %08x",\r\ndno, chk_up, le32_to_cpu(dnode->up));\r\nhpfs_brelse4(&qbh);\r\nreturn 0;\r\n}\r\nchk_up = dno;\r\n}\r\nif (!(de = dnode_last_de(dnode))) {\r\nhpfs_error(i->i_sb, "move_to_top: dnode %08x has no last de", dno);\r\nhpfs_brelse4(&qbh);\r\nreturn 0;\r\n}\r\nif (!de->down) break;\r\ndno = de_down_pointer(de);\r\nhpfs_brelse4(&qbh);\r\n}\r\nwhile (!(de = dnode_pre_last_de(dnode))) {\r\ndnode_secno up = le32_to_cpu(dnode->up);\r\nhpfs_brelse4(&qbh);\r\nhpfs_free_dnode(i->i_sb, dno);\r\ni->i_size -= 2048;\r\ni->i_blocks -= 4;\r\nfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, 5);\r\nif (up == to) return to;\r\nif (!(dnode = hpfs_map_dnode(i->i_sb, up, &qbh))) return 0;\r\nif (dnode->root_dnode) {\r\nhpfs_error(i->i_sb, "move_to_top: got to root_dnode while moving from %08x to %08x", from, to);\r\nhpfs_brelse4(&qbh);\r\nreturn 0;\r\n}\r\nde = dnode_last_de(dnode);\r\nif (!de || !de->down) {\r\nhpfs_error(i->i_sb, "move_to_top: dnode %08x doesn't point down to %08x", up, dno);\r\nhpfs_brelse4(&qbh);\r\nreturn 0;\r\n}\r\ndnode->first_free = cpu_to_le32(le32_to_cpu(dnode->first_free) - 4);\r\nde->length = cpu_to_le16(le16_to_cpu(de->length) - 4);\r\nde->down = 0;\r\nhpfs_mark_4buffers_dirty(&qbh);\r\ndno = up;\r\n}\r\nt = get_pos(dnode, de);\r\nfor_all_poss(i, hpfs_pos_subst, t, 4);\r\nfor_all_poss(i, hpfs_pos_subst, t + 1, 5);\r\nif (!(nde = kmalloc(le16_to_cpu(de->length), GFP_NOFS))) {\r\nhpfs_error(i->i_sb, "out of memory for dirent - directory will be corrupted");\r\nhpfs_brelse4(&qbh);\r\nreturn 0;\r\n}\r\nmemcpy(nde, de, le16_to_cpu(de->length));\r\nddno = de->down ? de_down_pointer(de) : 0;\r\nhpfs_delete_de(i->i_sb, dnode, de);\r\nset_last_pointer(i->i_sb, dnode, ddno);\r\nhpfs_mark_4buffers_dirty(&qbh);\r\nhpfs_brelse4(&qbh);\r\na = hpfs_add_to_dnode(i, to, nde->name, nde->namelen, nde, from);\r\nkfree(nde);\r\nif (a) return 0;\r\nreturn dno;\r\n}\r\nstatic void delete_empty_dnode(struct inode *i, dnode_secno dno)\r\n{\r\nstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\r\nstruct quad_buffer_head qbh;\r\nstruct dnode *dnode;\r\ndnode_secno down, up, ndown;\r\nint p;\r\nstruct hpfs_dirent *de;\r\nint c1, c2 = 0;\r\ntry_it_again:\r\nif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, "delete_empty_dnode")) return;\r\nif (!(dnode = hpfs_map_dnode(i->i_sb, dno, &qbh))) return;\r\nif (le32_to_cpu(dnode->first_free) > 56) goto end;\r\nif (le32_to_cpu(dnode->first_free) == 52 || le32_to_cpu(dnode->first_free) == 56) {\r\nstruct hpfs_dirent *de_end;\r\nint root = dnode->root_dnode;\r\nup = le32_to_cpu(dnode->up);\r\nde = dnode_first_de(dnode);\r\ndown = de->down ? de_down_pointer(de) : 0;\r\nif (hpfs_sb(i->i_sb)->sb_chk) if (root && !down) {\r\nhpfs_error(i->i_sb, "delete_empty_dnode: root dnode %08x is empty", dno);\r\ngoto end;\r\n}\r\nhpfs_brelse4(&qbh);\r\nhpfs_free_dnode(i->i_sb, dno);\r\ni->i_size -= 2048;\r\ni->i_blocks -= 4;\r\nif (root) {\r\nstruct fnode *fnode;\r\nstruct buffer_head *bh;\r\nstruct dnode *d1;\r\nstruct quad_buffer_head qbh1;\r\nif (hpfs_sb(i->i_sb)->sb_chk)\r\nif (up != i->i_ino) {\r\nhpfs_error(i->i_sb,\r\n"bad pointer to fnode, dnode %08x, pointing to %08x, should be %08lx",\r\ndno, up, (unsigned long)i->i_ino);\r\nreturn;\r\n}\r\nif ((d1 = hpfs_map_dnode(i->i_sb, down, &qbh1))) {\r\nd1->up = cpu_to_le32(up);\r\nd1->root_dnode = 1;\r\nhpfs_mark_4buffers_dirty(&qbh1);\r\nhpfs_brelse4(&qbh1);\r\n}\r\nif ((fnode = hpfs_map_fnode(i->i_sb, up, &bh))) {\r\nfnode->u.external[0].disk_secno = cpu_to_le32(down);\r\nmark_buffer_dirty(bh);\r\nbrelse(bh);\r\n}\r\nhpfs_inode->i_dno = down;\r\nfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, (loff_t) 12);\r\nreturn;\r\n}\r\nif (!(dnode = hpfs_map_dnode(i->i_sb, up, &qbh))) return;\r\np = 1;\r\nde_end = dnode_end_de(dnode);\r\nfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de), p++)\r\nif (de->down) if (de_down_pointer(de) == dno) goto fnd;\r\nhpfs_error(i->i_sb, "delete_empty_dnode: pointer to dnode %08x not found in dnode %08x", dno, up);\r\ngoto end;\r\nfnd:\r\nfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, ((loff_t)up << 4) | p);\r\nif (!down) {\r\nde->down = 0;\r\nde->length = cpu_to_le16(le16_to_cpu(de->length) - 4);\r\ndnode->first_free = cpu_to_le32(le32_to_cpu(dnode->first_free) - 4);\r\nmemmove(de_next_de(de), (char *)de_next_de(de) + 4,\r\n(char *)dnode + le32_to_cpu(dnode->first_free) - (char *)de_next_de(de));\r\n} else {\r\nstruct dnode *d1;\r\nstruct quad_buffer_head qbh1;\r\n*(dnode_secno *) ((void *) de + le16_to_cpu(de->length) - 4) = down;\r\nif ((d1 = hpfs_map_dnode(i->i_sb, down, &qbh1))) {\r\nd1->up = cpu_to_le32(up);\r\nhpfs_mark_4buffers_dirty(&qbh1);\r\nhpfs_brelse4(&qbh1);\r\n}\r\n}\r\n} else {\r\nhpfs_error(i->i_sb, "delete_empty_dnode: dnode %08x, first_free == %03x", dno, le32_to_cpu(dnode->first_free));\r\ngoto end;\r\n}\r\nif (!de->last) {\r\nstruct hpfs_dirent *de_next = de_next_de(de);\r\nstruct hpfs_dirent *de_cp;\r\nstruct dnode *d1;\r\nstruct quad_buffer_head qbh1;\r\nif (!de_next->down) goto endm;\r\nndown = de_down_pointer(de_next);\r\nif (!(de_cp = kmalloc(le16_to_cpu(de->length), GFP_NOFS))) {\r\nprintk("HPFS: out of memory for dtree balancing\n");\r\ngoto endm;\r\n}\r\nmemcpy(de_cp, de, le16_to_cpu(de->length));\r\nhpfs_delete_de(i->i_sb, dnode, de);\r\nhpfs_mark_4buffers_dirty(&qbh);\r\nhpfs_brelse4(&qbh);\r\nfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | p, 4);\r\nfor_all_poss(i, hpfs_pos_del, ((loff_t)up << 4) | p, 1);\r\nif (de_cp->down) if ((d1 = hpfs_map_dnode(i->i_sb, de_down_pointer(de_cp), &qbh1))) {\r\nd1->up = cpu_to_le32(ndown);\r\nhpfs_mark_4buffers_dirty(&qbh1);\r\nhpfs_brelse4(&qbh1);\r\n}\r\nhpfs_add_to_dnode(i, ndown, de_cp->name, de_cp->namelen, de_cp, de_cp->down ? de_down_pointer(de_cp) : 0);\r\ndno = up;\r\nkfree(de_cp);\r\ngoto try_it_again;\r\n} else {\r\nstruct hpfs_dirent *de_prev = dnode_pre_last_de(dnode);\r\nstruct hpfs_dirent *de_cp;\r\nstruct dnode *d1;\r\nstruct quad_buffer_head qbh1;\r\ndnode_secno dlp;\r\nif (!de_prev) {\r\nhpfs_error(i->i_sb, "delete_empty_dnode: empty dnode %08x", up);\r\nhpfs_mark_4buffers_dirty(&qbh);\r\nhpfs_brelse4(&qbh);\r\ndno = up;\r\ngoto try_it_again;\r\n}\r\nif (!de_prev->down) goto endm;\r\nndown = de_down_pointer(de_prev);\r\nif ((d1 = hpfs_map_dnode(i->i_sb, ndown, &qbh1))) {\r\nstruct hpfs_dirent *del = dnode_last_de(d1);\r\ndlp = del->down ? de_down_pointer(del) : 0;\r\nif (!dlp && down) {\r\nif (le32_to_cpu(d1->first_free) > 2044) {\r\nif (hpfs_sb(i->i_sb)->sb_chk >= 2) {\r\nprintk("HPFS: warning: unbalanced dnode tree, see hpfs.txt 4 more info\n");\r\nprintk("HPFS: warning: terminating balancing operation\n");\r\n}\r\nhpfs_brelse4(&qbh1);\r\ngoto endm;\r\n}\r\nif (hpfs_sb(i->i_sb)->sb_chk >= 2) {\r\nprintk("HPFS: warning: unbalanced dnode tree, see hpfs.txt 4 more info\n");\r\nprintk("HPFS: warning: goin'on\n");\r\n}\r\ndel->length = cpu_to_le16(le16_to_cpu(del->length) + 4);\r\ndel->down = 1;\r\nd1->first_free = cpu_to_le32(le32_to_cpu(d1->first_free) + 4);\r\n}\r\nif (dlp && !down) {\r\ndel->length = cpu_to_le16(le16_to_cpu(del->length) - 4);\r\ndel->down = 0;\r\nd1->first_free = cpu_to_le32(le32_to_cpu(d1->first_free) - 4);\r\n} else if (down)\r\n*(dnode_secno *) ((void *) del + le16_to_cpu(del->length) - 4) = cpu_to_le32(down);\r\n} else goto endm;\r\nif (!(de_cp = kmalloc(le16_to_cpu(de_prev->length), GFP_NOFS))) {\r\nprintk("HPFS: out of memory for dtree balancing\n");\r\nhpfs_brelse4(&qbh1);\r\ngoto endm;\r\n}\r\nhpfs_mark_4buffers_dirty(&qbh1);\r\nhpfs_brelse4(&qbh1);\r\nmemcpy(de_cp, de_prev, le16_to_cpu(de_prev->length));\r\nhpfs_delete_de(i->i_sb, dnode, de_prev);\r\nif (!de_prev->down) {\r\nde_prev->length = cpu_to_le16(le16_to_cpu(de_prev->length) + 4);\r\nde_prev->down = 1;\r\ndnode->first_free = cpu_to_le32(le32_to_cpu(dnode->first_free) + 4);\r\n}\r\n*(dnode_secno *) ((void *) de_prev + le16_to_cpu(de_prev->length) - 4) = cpu_to_le32(ndown);\r\nhpfs_mark_4buffers_dirty(&qbh);\r\nhpfs_brelse4(&qbh);\r\nfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | (p - 1), 4);\r\nfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | p, ((loff_t)up << 4) | (p - 1));\r\nif (down) if ((d1 = hpfs_map_dnode(i->i_sb, de_down_pointer(de), &qbh1))) {\r\nd1->up = cpu_to_le32(ndown);\r\nhpfs_mark_4buffers_dirty(&qbh1);\r\nhpfs_brelse4(&qbh1);\r\n}\r\nhpfs_add_to_dnode(i, ndown, de_cp->name, de_cp->namelen, de_cp, dlp);\r\ndno = up;\r\nkfree(de_cp);\r\ngoto try_it_again;\r\n}\r\nendm:\r\nhpfs_mark_4buffers_dirty(&qbh);\r\nend:\r\nhpfs_brelse4(&qbh);\r\n}\r\nint hpfs_remove_dirent(struct inode *i, dnode_secno dno, struct hpfs_dirent *de,\r\nstruct quad_buffer_head *qbh, int depth)\r\n{\r\nstruct dnode *dnode = qbh->data;\r\ndnode_secno down = 0;\r\nloff_t t;\r\nif (de->first || de->last) {\r\nhpfs_error(i->i_sb, "hpfs_remove_dirent: attempt to delete first or last dirent in dnode %08x", dno);\r\nhpfs_brelse4(qbh);\r\nreturn 1;\r\n}\r\nif (de->down) down = de_down_pointer(de);\r\nif (depth && (de->down || (de == dnode_first_de(dnode) && de_next_de(de)->last))) {\r\nif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_DEL)) {\r\nhpfs_brelse4(qbh);\r\nreturn 2;\r\n}\r\n}\r\ni->i_version++;\r\nfor_all_poss(i, hpfs_pos_del, (t = get_pos(dnode, de)) + 1, 1);\r\nhpfs_delete_de(i->i_sb, dnode, de);\r\nhpfs_mark_4buffers_dirty(qbh);\r\nhpfs_brelse4(qbh);\r\nif (down) {\r\ndnode_secno a = move_to_top(i, down, dno);\r\nfor_all_poss(i, hpfs_pos_subst, 5, t);\r\nif (a) delete_empty_dnode(i, a);\r\nreturn !a;\r\n}\r\ndelete_empty_dnode(i, dno);\r\nreturn 0;\r\n}\r\nvoid hpfs_count_dnodes(struct super_block *s, dnode_secno dno, int *n_dnodes,\r\nint *n_subdirs, int *n_items)\r\n{\r\nstruct dnode *dnode;\r\nstruct quad_buffer_head qbh;\r\nstruct hpfs_dirent *de;\r\ndnode_secno ptr, odno = 0;\r\nint c1, c2 = 0;\r\nint d1, d2 = 0;\r\ngo_down:\r\nif (n_dnodes) (*n_dnodes)++;\r\nif (hpfs_sb(s)->sb_chk)\r\nif (hpfs_stop_cycles(s, dno, &c1, &c2, "hpfs_count_dnodes #1")) return;\r\nptr = 0;\r\ngo_up:\r\nif (!(dnode = hpfs_map_dnode(s, dno, &qbh))) return;\r\nif (hpfs_sb(s)->sb_chk) if (odno && odno != -1 && le32_to_cpu(dnode->up) != odno)\r\nhpfs_error(s, "hpfs_count_dnodes: bad up pointer; dnode %08x, down %08x points to %08x", odno, dno, le32_to_cpu(dnode->up));\r\nde = dnode_first_de(dnode);\r\nif (ptr) while(1) {\r\nif (de->down) if (de_down_pointer(de) == ptr) goto process_de;\r\nif (de->last) {\r\nhpfs_brelse4(&qbh);\r\nhpfs_error(s, "hpfs_count_dnodes: pointer to dnode %08x not found in dnode %08x, got here from %08x",\r\nptr, dno, odno);\r\nreturn;\r\n}\r\nde = de_next_de(de);\r\n}\r\nnext_de:\r\nif (de->down) {\r\nodno = dno;\r\ndno = de_down_pointer(de);\r\nhpfs_brelse4(&qbh);\r\ngoto go_down;\r\n}\r\nprocess_de:\r\nif (!de->first && !de->last && de->directory && n_subdirs) (*n_subdirs)++;\r\nif (!de->first && !de->last && n_items) (*n_items)++;\r\nif ((de = de_next_de(de)) < dnode_end_de(dnode)) goto next_de;\r\nptr = dno;\r\ndno = le32_to_cpu(dnode->up);\r\nif (dnode->root_dnode) {\r\nhpfs_brelse4(&qbh);\r\nreturn;\r\n}\r\nhpfs_brelse4(&qbh);\r\nif (hpfs_sb(s)->sb_chk)\r\nif (hpfs_stop_cycles(s, ptr, &d1, &d2, "hpfs_count_dnodes #2")) return;\r\nodno = -1;\r\ngoto go_up;\r\n}\r\nstatic struct hpfs_dirent *map_nth_dirent(struct super_block *s, dnode_secno dno, int n,\r\nstruct quad_buffer_head *qbh, struct dnode **dn)\r\n{\r\nint i;\r\nstruct hpfs_dirent *de, *de_end;\r\nstruct dnode *dnode;\r\ndnode = hpfs_map_dnode(s, dno, qbh);\r\nif (!dnode) return NULL;\r\nif (dn) *dn=dnode;\r\nde = dnode_first_de(dnode);\r\nde_end = dnode_end_de(dnode);\r\nfor (i = 1; de < de_end; i++, de = de_next_de(de)) {\r\nif (i == n) {\r\nreturn de;\r\n}\r\nif (de->last) break;\r\n}\r\nhpfs_brelse4(qbh);\r\nhpfs_error(s, "map_nth_dirent: n too high; dnode = %08x, requested %08x", dno, n);\r\nreturn NULL;\r\n}\r\ndnode_secno hpfs_de_as_down_as_possible(struct super_block *s, dnode_secno dno)\r\n{\r\nstruct quad_buffer_head qbh;\r\ndnode_secno d = dno;\r\ndnode_secno up = 0;\r\nstruct hpfs_dirent *de;\r\nint c1, c2 = 0;\r\nagain:\r\nif (hpfs_sb(s)->sb_chk)\r\nif (hpfs_stop_cycles(s, d, &c1, &c2, "hpfs_de_as_down_as_possible"))\r\nreturn d;\r\nif (!(de = map_nth_dirent(s, d, 1, &qbh, NULL))) return dno;\r\nif (hpfs_sb(s)->sb_chk)\r\nif (up && le32_to_cpu(((struct dnode *)qbh.data)->up) != up)\r\nhpfs_error(s, "hpfs_de_as_down_as_possible: bad up pointer; dnode %08x, down %08x points to %08x", up, d, le32_to_cpu(((struct dnode *)qbh.data)->up));\r\nif (!de->down) {\r\nhpfs_brelse4(&qbh);\r\nreturn d;\r\n}\r\nup = d;\r\nd = de_down_pointer(de);\r\nhpfs_brelse4(&qbh);\r\ngoto again;\r\n}\r\nstruct hpfs_dirent *map_pos_dirent(struct inode *inode, loff_t *posp,\r\nstruct quad_buffer_head *qbh)\r\n{\r\nloff_t pos;\r\nunsigned c;\r\ndnode_secno dno;\r\nstruct hpfs_dirent *de, *d;\r\nstruct hpfs_dirent *up_de;\r\nstruct hpfs_dirent *end_up_de;\r\nstruct dnode *dnode;\r\nstruct dnode *up_dnode;\r\nstruct quad_buffer_head qbh0;\r\npos = *posp;\r\ndno = pos >> 6 << 2;\r\npos &= 077;\r\nif (!(de = map_nth_dirent(inode->i_sb, dno, pos, qbh, &dnode)))\r\ngoto bail;\r\nif ((d = de_next_de(de)) < dnode_end_de(dnode)) {\r\nif (!(++*posp & 077)) {\r\nhpfs_error(inode->i_sb,\r\n"map_pos_dirent: pos crossed dnode boundary; pos = %08llx",\r\n(unsigned long long)*posp);\r\ngoto bail;\r\n}\r\nif (d->down) {\r\n*posp = ((loff_t) hpfs_de_as_down_as_possible(inode->i_sb, de_down_pointer(d)) << 4) + 1;\r\n}\r\nreturn de;\r\n}\r\nif (dnode->root_dnode) goto bail;\r\nif (!(up_dnode = hpfs_map_dnode(inode->i_sb, le32_to_cpu(dnode->up), &qbh0)))\r\ngoto bail;\r\nend_up_de = dnode_end_de(up_dnode);\r\nc = 0;\r\nfor (up_de = dnode_first_de(up_dnode); up_de < end_up_de;\r\nup_de = de_next_de(up_de)) {\r\nif (!(++c & 077)) hpfs_error(inode->i_sb,\r\n"map_pos_dirent: pos crossed dnode boundary; dnode = %08x", le32_to_cpu(dnode->up));\r\nif (up_de->down && de_down_pointer(up_de) == dno) {\r\n*posp = ((loff_t) le32_to_cpu(dnode->up) << 4) + c;\r\nhpfs_brelse4(&qbh0);\r\nreturn de;\r\n}\r\n}\r\nhpfs_error(inode->i_sb, "map_pos_dirent: pointer to dnode %08x not found in parent dnode %08x",\r\ndno, le32_to_cpu(dnode->up));\r\nhpfs_brelse4(&qbh0);\r\nbail:\r\n*posp = 12;\r\nreturn de;\r\n}\r\nstruct hpfs_dirent *map_dirent(struct inode *inode, dnode_secno dno,\r\nconst unsigned char *name, unsigned len,\r\ndnode_secno *dd, struct quad_buffer_head *qbh)\r\n{\r\nstruct dnode *dnode;\r\nstruct hpfs_dirent *de;\r\nstruct hpfs_dirent *de_end;\r\nint c1, c2 = 0;\r\nif (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, "map_dirent: not a directory\n");\r\nagain:\r\nif (hpfs_sb(inode->i_sb)->sb_chk)\r\nif (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, "map_dirent")) return NULL;\r\nif (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;\r\nde_end = dnode_end_de(dnode);\r\nfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de)) {\r\nint t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);\r\nif (!t) {\r\nif (dd) *dd = dno;\r\nreturn de;\r\n}\r\nif (t < 0) {\r\nif (de->down) {\r\ndno = de_down_pointer(de);\r\nhpfs_brelse4(qbh);\r\ngoto again;\r\n}\r\nbreak;\r\n}\r\n}\r\nhpfs_brelse4(qbh);\r\nreturn NULL;\r\n}\r\nvoid hpfs_remove_dtree(struct super_block *s, dnode_secno dno)\r\n{\r\nstruct quad_buffer_head qbh;\r\nstruct dnode *dnode;\r\nstruct hpfs_dirent *de;\r\ndnode_secno d1, d2, rdno = dno;\r\nwhile (1) {\r\nif (!(dnode = hpfs_map_dnode(s, dno, &qbh))) return;\r\nde = dnode_first_de(dnode);\r\nif (de->last) {\r\nif (de->down) d1 = de_down_pointer(de);\r\nelse goto error;\r\nhpfs_brelse4(&qbh);\r\nhpfs_free_dnode(s, dno);\r\ndno = d1;\r\n} else break;\r\n}\r\nif (!de->first) goto error;\r\nd1 = de->down ? de_down_pointer(de) : 0;\r\nde = de_next_de(de);\r\nif (!de->last) goto error;\r\nd2 = de->down ? de_down_pointer(de) : 0;\r\nhpfs_brelse4(&qbh);\r\nhpfs_free_dnode(s, dno);\r\ndo {\r\nwhile (d1) {\r\nif (!(dnode = hpfs_map_dnode(s, dno = d1, &qbh))) return;\r\nde = dnode_first_de(dnode);\r\nif (!de->last) goto error;\r\nd1 = de->down ? de_down_pointer(de) : 0;\r\nhpfs_brelse4(&qbh);\r\nhpfs_free_dnode(s, dno);\r\n}\r\nd1 = d2;\r\nd2 = 0;\r\n} while (d1);\r\nreturn;\r\nerror:\r\nhpfs_brelse4(&qbh);\r\nhpfs_free_dnode(s, dno);\r\nhpfs_error(s, "directory %08x is corrupted or not empty", rdno);\r\n}\r\nstruct hpfs_dirent *map_fnode_dirent(struct super_block *s, fnode_secno fno,\r\nstruct fnode *f, struct quad_buffer_head *qbh)\r\n{\r\nunsigned char *name1;\r\nunsigned char *name2;\r\nint name1len, name2len;\r\nstruct dnode *d;\r\ndnode_secno dno, downd;\r\nstruct fnode *upf;\r\nstruct buffer_head *bh;\r\nstruct hpfs_dirent *de, *de_end;\r\nint c;\r\nint c1, c2 = 0;\r\nint d1, d2 = 0;\r\nname1 = f->name;\r\nif (!(name2 = kmalloc(256, GFP_NOFS))) {\r\nprintk("HPFS: out of memory, can't map dirent\n");\r\nreturn NULL;\r\n}\r\nif (f->len <= 15)\r\nmemcpy(name2, name1, name1len = name2len = f->len);\r\nelse {\r\nmemcpy(name2, name1, 15);\r\nmemset(name2 + 15, 0xff, 256 - 15);\r\nname1len = 15; name2len = 256;\r\n}\r\nif (!(upf = hpfs_map_fnode(s, le32_to_cpu(f->up), &bh))) {\r\nkfree(name2);\r\nreturn NULL;\r\n}\r\nif (!upf->dirflag) {\r\nbrelse(bh);\r\nhpfs_error(s, "fnode %08x has non-directory parent %08x", fno, le32_to_cpu(f->up));\r\nkfree(name2);\r\nreturn NULL;\r\n}\r\ndno = le32_to_cpu(upf->u.external[0].disk_secno);\r\nbrelse(bh);\r\ngo_down:\r\ndownd = 0;\r\ngo_up:\r\nif (!(d = hpfs_map_dnode(s, dno, qbh))) {\r\nkfree(name2);\r\nreturn NULL;\r\n}\r\nde_end = dnode_end_de(d);\r\nde = dnode_first_de(d);\r\nif (downd) {\r\nwhile (de < de_end) {\r\nif (de->down) if (de_down_pointer(de) == downd) goto f;\r\nde = de_next_de(de);\r\n}\r\nhpfs_error(s, "pointer to dnode %08x not found in dnode %08x", downd, dno);\r\nhpfs_brelse4(qbh);\r\nkfree(name2);\r\nreturn NULL;\r\n}\r\nnext_de:\r\nif (le32_to_cpu(de->fnode) == fno) {\r\nkfree(name2);\r\nreturn de;\r\n}\r\nc = hpfs_compare_names(s, name1, name1len, de->name, de->namelen, de->last);\r\nif (c < 0 && de->down) {\r\ndno = de_down_pointer(de);\r\nhpfs_brelse4(qbh);\r\nif (hpfs_sb(s)->sb_chk)\r\nif (hpfs_stop_cycles(s, dno, &c1, &c2, "map_fnode_dirent #1")) {\r\nkfree(name2);\r\nreturn NULL;\r\n}\r\ngoto go_down;\r\n}\r\nf:\r\nif (le32_to_cpu(de->fnode) == fno) {\r\nkfree(name2);\r\nreturn de;\r\n}\r\nc = hpfs_compare_names(s, name2, name2len, de->name, de->namelen, de->last);\r\nif (c < 0 && !de->last) goto not_found;\r\nif ((de = de_next_de(de)) < de_end) goto next_de;\r\nif (d->root_dnode) goto not_found;\r\ndownd = dno;\r\ndno = le32_to_cpu(d->up);\r\nhpfs_brelse4(qbh);\r\nif (hpfs_sb(s)->sb_chk)\r\nif (hpfs_stop_cycles(s, downd, &d1, &d2, "map_fnode_dirent #2")) {\r\nkfree(name2);\r\nreturn NULL;\r\n}\r\ngoto go_up;\r\nnot_found:\r\nhpfs_brelse4(qbh);\r\nhpfs_error(s, "dirent for fnode %08x not found", fno);\r\nkfree(name2);\r\nreturn NULL;\r\n}
