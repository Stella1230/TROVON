static bool ipv4_pkt_to_tuple(const struct sk_buff *skb, unsigned int nhoff,\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nconst __be32 *ap;\r\n__be32 _addrs[2];\r\nap = skb_header_pointer(skb, nhoff + offsetof(struct iphdr, saddr),\r\nsizeof(u_int32_t) * 2, _addrs);\r\nif (ap == NULL)\r\nreturn false;\r\ntuple->src.u3.ip = ap[0];\r\ntuple->dst.u3.ip = ap[1];\r\nreturn true;\r\n}\r\nstatic bool ipv4_invert_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple *orig)\r\n{\r\ntuple->src.u3.ip = orig->dst.u3.ip;\r\ntuple->dst.u3.ip = orig->src.u3.ip;\r\nreturn true;\r\n}\r\nstatic int ipv4_print_tuple(struct seq_file *s,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nreturn seq_printf(s, "src=%pI4 dst=%pI4 ",\r\n&tuple->src.u3.ip, &tuple->dst.u3.ip);\r\n}\r\nstatic int ipv4_get_l4proto(const struct sk_buff *skb, unsigned int nhoff,\r\nunsigned int *dataoff, u_int8_t *protonum)\r\n{\r\nconst struct iphdr *iph;\r\nstruct iphdr _iph;\r\niph = skb_header_pointer(skb, nhoff, sizeof(_iph), &_iph);\r\nif (iph == NULL)\r\nreturn -NF_DROP;\r\nif (iph->frag_off & htons(IP_OFFSET))\r\nreturn -NF_DROP;\r\n*dataoff = nhoff + (iph->ihl << 2);\r\n*protonum = iph->protocol;\r\nreturn NF_ACCEPT;\r\n}\r\nstatic unsigned int ipv4_confirm(unsigned int hooknum,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nconst struct nf_conn_help *help;\r\nconst struct nf_conntrack_helper *helper;\r\nunsigned int ret;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (!ct || ctinfo == IP_CT_RELATED_REPLY)\r\ngoto out;\r\nhelp = nfct_help(ct);\r\nif (!help)\r\ngoto out;\r\nhelper = rcu_dereference(help->helper);\r\nif (!helper)\r\ngoto out;\r\nret = helper->help(skb, skb_network_offset(skb) + ip_hdrlen(skb),\r\nct, ctinfo);\r\nif (ret != NF_ACCEPT) {\r\nnf_log_packet(NFPROTO_IPV4, hooknum, skb, in, out, NULL,\r\n"nf_ct_%s: dropping packet", helper->name);\r\nreturn ret;\r\n}\r\nif (test_bit(IPS_SEQ_ADJUST_BIT, &ct->status) &&\r\n!nf_is_loopback_packet(skb)) {\r\ntypeof(nf_nat_seq_adjust_hook) seq_adjust;\r\nseq_adjust = rcu_dereference(nf_nat_seq_adjust_hook);\r\nif (!seq_adjust || !seq_adjust(skb, ct, ctinfo)) {\r\nNF_CT_STAT_INC_ATOMIC(nf_ct_net(ct), drop);\r\nreturn NF_DROP;\r\n}\r\n}\r\nout:\r\nreturn nf_conntrack_confirm(skb);\r\n}\r\nstatic unsigned int ipv4_conntrack_in(unsigned int hooknum,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nreturn nf_conntrack_in(dev_net(in), PF_INET, hooknum, skb);\r\n}\r\nstatic unsigned int ipv4_conntrack_local(unsigned int hooknum,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nif (skb->len < sizeof(struct iphdr) ||\r\nip_hdrlen(skb) < sizeof(struct iphdr))\r\nreturn NF_ACCEPT;\r\nreturn nf_conntrack_in(dev_net(out), PF_INET, hooknum, skb);\r\n}\r\nstatic int\r\ngetorigdst(struct sock *sk, int optval, void __user *user, int *len)\r\n{\r\nconst struct inet_sock *inet = inet_sk(sk);\r\nconst struct nf_conntrack_tuple_hash *h;\r\nstruct nf_conntrack_tuple tuple;\r\nmemset(&tuple, 0, sizeof(tuple));\r\ntuple.src.u3.ip = inet->inet_rcv_saddr;\r\ntuple.src.u.tcp.port = inet->inet_sport;\r\ntuple.dst.u3.ip = inet->inet_daddr;\r\ntuple.dst.u.tcp.port = inet->inet_dport;\r\ntuple.src.l3num = PF_INET;\r\ntuple.dst.protonum = sk->sk_protocol;\r\nif (sk->sk_protocol != IPPROTO_TCP && sk->sk_protocol != IPPROTO_SCTP) {\r\npr_debug("SO_ORIGINAL_DST: Not a TCP/SCTP socket\n");\r\nreturn -ENOPROTOOPT;\r\n}\r\nif ((unsigned int) *len < sizeof(struct sockaddr_in)) {\r\npr_debug("SO_ORIGINAL_DST: len %d not %Zu\n",\r\n*len, sizeof(struct sockaddr_in));\r\nreturn -EINVAL;\r\n}\r\nh = nf_conntrack_find_get(sock_net(sk), NF_CT_DEFAULT_ZONE, &tuple);\r\nif (h) {\r\nstruct sockaddr_in sin;\r\nstruct nf_conn *ct = nf_ct_tuplehash_to_ctrack(h);\r\nsin.sin_family = AF_INET;\r\nsin.sin_port = ct->tuplehash[IP_CT_DIR_ORIGINAL]\r\n.tuple.dst.u.tcp.port;\r\nsin.sin_addr.s_addr = ct->tuplehash[IP_CT_DIR_ORIGINAL]\r\n.tuple.dst.u3.ip;\r\nmemset(sin.sin_zero, 0, sizeof(sin.sin_zero));\r\npr_debug("SO_ORIGINAL_DST: %pI4 %u\n",\r\n&sin.sin_addr.s_addr, ntohs(sin.sin_port));\r\nnf_ct_put(ct);\r\nif (copy_to_user(user, &sin, sizeof(sin)) != 0)\r\nreturn -EFAULT;\r\nelse\r\nreturn 0;\r\n}\r\npr_debug("SO_ORIGINAL_DST: Can't find %pI4/%u-%pI4/%u.\n",\r\n&tuple.src.u3.ip, ntohs(tuple.src.u.tcp.port),\r\n&tuple.dst.u3.ip, ntohs(tuple.dst.u.tcp.port));\r\nreturn -ENOENT;\r\n}\r\nstatic int ipv4_tuple_to_nlattr(struct sk_buff *skb,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nNLA_PUT_BE32(skb, CTA_IP_V4_SRC, tuple->src.u3.ip);\r\nNLA_PUT_BE32(skb, CTA_IP_V4_DST, tuple->dst.u3.ip);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int ipv4_nlattr_to_tuple(struct nlattr *tb[],\r\nstruct nf_conntrack_tuple *t)\r\n{\r\nif (!tb[CTA_IP_V4_SRC] || !tb[CTA_IP_V4_DST])\r\nreturn -EINVAL;\r\nt->src.u3.ip = nla_get_be32(tb[CTA_IP_V4_SRC]);\r\nt->dst.u3.ip = nla_get_be32(tb[CTA_IP_V4_DST]);\r\nreturn 0;\r\n}\r\nstatic int ipv4_nlattr_tuple_size(void)\r\n{\r\nreturn nla_policy_len(ipv4_nla_policy, CTA_IP_MAX + 1);\r\n}\r\nstatic int __init nf_conntrack_l3proto_ipv4_init(void)\r\n{\r\nint ret = 0;\r\nneed_conntrack();\r\nnf_defrag_ipv4_enable();\r\nret = nf_register_sockopt(&so_getorigdst);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "Unable to register netfilter socket option\n");\r\nreturn ret;\r\n}\r\nret = nf_conntrack_l4proto_register(&nf_conntrack_l4proto_tcp4);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv4: can't register tcp.\n");\r\ngoto cleanup_sockopt;\r\n}\r\nret = nf_conntrack_l4proto_register(&nf_conntrack_l4proto_udp4);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv4: can't register udp.\n");\r\ngoto cleanup_tcp;\r\n}\r\nret = nf_conntrack_l4proto_register(&nf_conntrack_l4proto_icmp);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv4: can't register icmp.\n");\r\ngoto cleanup_udp;\r\n}\r\nret = nf_conntrack_l3proto_register(&nf_conntrack_l3proto_ipv4);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv4: can't register ipv4\n");\r\ngoto cleanup_icmp;\r\n}\r\nret = nf_register_hooks(ipv4_conntrack_ops,\r\nARRAY_SIZE(ipv4_conntrack_ops));\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv4: can't register hooks.\n");\r\ngoto cleanup_ipv4;\r\n}\r\n#if defined(CONFIG_PROC_FS) && defined(CONFIG_NF_CONNTRACK_PROC_COMPAT)\r\nret = nf_conntrack_ipv4_compat_init();\r\nif (ret < 0)\r\ngoto cleanup_hooks;\r\n#endif\r\nreturn ret;\r\n#if defined(CONFIG_PROC_FS) && defined(CONFIG_NF_CONNTRACK_PROC_COMPAT)\r\ncleanup_hooks:\r\nnf_unregister_hooks(ipv4_conntrack_ops, ARRAY_SIZE(ipv4_conntrack_ops));\r\n#endif\r\ncleanup_ipv4:\r\nnf_conntrack_l3proto_unregister(&nf_conntrack_l3proto_ipv4);\r\ncleanup_icmp:\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_icmp);\r\ncleanup_udp:\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_udp4);\r\ncleanup_tcp:\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_tcp4);\r\ncleanup_sockopt:\r\nnf_unregister_sockopt(&so_getorigdst);\r\nreturn ret;\r\n}\r\nstatic void __exit nf_conntrack_l3proto_ipv4_fini(void)\r\n{\r\nsynchronize_net();\r\n#if defined(CONFIG_PROC_FS) && defined(CONFIG_NF_CONNTRACK_PROC_COMPAT)\r\nnf_conntrack_ipv4_compat_fini();\r\n#endif\r\nnf_unregister_hooks(ipv4_conntrack_ops, ARRAY_SIZE(ipv4_conntrack_ops));\r\nnf_conntrack_l3proto_unregister(&nf_conntrack_l3proto_ipv4);\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_icmp);\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_udp4);\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_tcp4);\r\nnf_unregister_sockopt(&so_getorigdst);\r\n}\r\nvoid need_ipv4_conntrack(void)\r\n{\r\nreturn;\r\n}
