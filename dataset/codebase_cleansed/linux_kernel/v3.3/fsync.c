static void dump_completed_IO(struct inode * inode)\r\n{\r\n#ifdef EXT4FS_DEBUG\r\nstruct list_head *cur, *before, *after;\r\next4_io_end_t *io, *io0, *io1;\r\nunsigned long flags;\r\nif (list_empty(&EXT4_I(inode)->i_completed_io_list)){\r\next4_debug("inode %lu completed_io list is empty\n", inode->i_ino);\r\nreturn;\r\n}\r\next4_debug("Dump inode %lu completed_io list \n", inode->i_ino);\r\nspin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);\r\nlist_for_each_entry(io, &EXT4_I(inode)->i_completed_io_list, list){\r\ncur = &io->list;\r\nbefore = cur->prev;\r\nio0 = container_of(before, ext4_io_end_t, list);\r\nafter = cur->next;\r\nio1 = container_of(after, ext4_io_end_t, list);\r\next4_debug("io 0x%p from inode %lu,prev 0x%p,next 0x%p\n",\r\nio, inode->i_ino, io0, io1);\r\n}\r\nspin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);\r\n#endif\r\n}\r\nint ext4_flush_completed_IO(struct inode *inode)\r\n{\r\next4_io_end_t *io;\r\nstruct ext4_inode_info *ei = EXT4_I(inode);\r\nunsigned long flags;\r\nint ret = 0;\r\nint ret2 = 0;\r\ndump_completed_IO(inode);\r\nspin_lock_irqsave(&ei->i_completed_io_lock, flags);\r\nwhile (!list_empty(&ei->i_completed_io_list)){\r\nio = list_entry(ei->i_completed_io_list.next,\r\next4_io_end_t, list);\r\nlist_del_init(&io->list);\r\nspin_unlock_irqrestore(&ei->i_completed_io_lock, flags);\r\nret = ext4_end_io_nolock(io);\r\nif (ret < 0)\r\nret2 = ret;\r\nspin_lock_irqsave(&ei->i_completed_io_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&ei->i_completed_io_lock, flags);\r\nreturn (ret2 < 0) ? ret2 : 0;\r\n}\r\nstatic int ext4_sync_parent(struct inode *inode)\r\n{\r\nstruct writeback_control wbc;\r\nstruct dentry *dentry = NULL;\r\nstruct inode *next;\r\nint ret = 0;\r\nif (!ext4_test_inode_state(inode, EXT4_STATE_NEWENTRY))\r\nreturn 0;\r\ninode = igrab(inode);\r\nwhile (ext4_test_inode_state(inode, EXT4_STATE_NEWENTRY)) {\r\next4_clear_inode_state(inode, EXT4_STATE_NEWENTRY);\r\ndentry = NULL;\r\nspin_lock(&inode->i_lock);\r\nif (!list_empty(&inode->i_dentry)) {\r\ndentry = list_first_entry(&inode->i_dentry,\r\nstruct dentry, d_alias);\r\ndget(dentry);\r\n}\r\nspin_unlock(&inode->i_lock);\r\nif (!dentry)\r\nbreak;\r\nnext = igrab(dentry->d_parent->d_inode);\r\ndput(dentry);\r\nif (!next)\r\nbreak;\r\niput(inode);\r\ninode = next;\r\nret = sync_mapping_buffers(inode->i_mapping);\r\nif (ret)\r\nbreak;\r\nmemset(&wbc, 0, sizeof(wbc));\r\nwbc.sync_mode = WB_SYNC_ALL;\r\nwbc.nr_to_write = 0;\r\nret = sync_inode(inode, &wbc);\r\nif (ret)\r\nbreak;\r\n}\r\niput(inode);\r\nreturn ret;\r\n}\r\nstatic int __sync_inode(struct inode *inode, int datasync)\r\n{\r\nint err;\r\nint ret;\r\nret = sync_mapping_buffers(inode->i_mapping);\r\nif (!(inode->i_state & I_DIRTY))\r\nreturn ret;\r\nif (datasync && !(inode->i_state & I_DIRTY_DATASYNC))\r\nreturn ret;\r\nerr = sync_inode_metadata(inode, 1);\r\nif (ret == 0)\r\nret = err;\r\nreturn ret;\r\n}\r\nint ext4_sync_file(struct file *file, loff_t start, loff_t end, int datasync)\r\n{\r\nstruct inode *inode = file->f_mapping->host;\r\nstruct ext4_inode_info *ei = EXT4_I(inode);\r\njournal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\r\nint ret;\r\ntid_t commit_tid;\r\nbool needs_barrier = false;\r\nJ_ASSERT(ext4_journal_current_handle() == NULL);\r\ntrace_ext4_sync_file_enter(file, datasync);\r\nret = filemap_write_and_wait_range(inode->i_mapping, start, end);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&inode->i_mutex);\r\nif (inode->i_sb->s_flags & MS_RDONLY)\r\ngoto out;\r\nret = ext4_flush_completed_IO(inode);\r\nif (ret < 0)\r\ngoto out;\r\nif (!journal) {\r\nret = __sync_inode(inode, datasync);\r\nif (!ret && !list_empty(&inode->i_dentry))\r\nret = ext4_sync_parent(inode);\r\ngoto out;\r\n}\r\nif (ext4_should_journal_data(inode)) {\r\nret = ext4_force_commit(inode->i_sb);\r\ngoto out;\r\n}\r\ncommit_tid = datasync ? ei->i_datasync_tid : ei->i_sync_tid;\r\nif (journal->j_flags & JBD2_BARRIER &&\r\n!jbd2_trans_will_send_data_barrier(journal, commit_tid))\r\nneeds_barrier = true;\r\njbd2_log_start_commit(journal, commit_tid);\r\nret = jbd2_log_wait_commit(journal, commit_tid);\r\nif (needs_barrier)\r\nblkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);\r\nout:\r\nmutex_unlock(&inode->i_mutex);\r\ntrace_ext4_sync_file_exit(inode, ret);\r\nreturn ret;\r\n}
