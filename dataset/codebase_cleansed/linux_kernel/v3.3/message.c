static void usb_api_blocking_completion(struct urb *urb)\r\n{\r\nstruct api_context *ctx = urb->context;\r\nctx->status = urb->status;\r\ncomplete(&ctx->done);\r\n}\r\nstatic int usb_start_wait_urb(struct urb *urb, int timeout, int *actual_length)\r\n{\r\nstruct api_context ctx;\r\nunsigned long expire;\r\nint retval;\r\ninit_completion(&ctx.done);\r\nurb->context = &ctx;\r\nurb->actual_length = 0;\r\nretval = usb_submit_urb(urb, GFP_NOIO);\r\nif (unlikely(retval))\r\ngoto out;\r\nexpire = timeout ? msecs_to_jiffies(timeout) : MAX_SCHEDULE_TIMEOUT;\r\nif (!wait_for_completion_timeout(&ctx.done, expire)) {\r\nusb_kill_urb(urb);\r\nretval = (ctx.status == -ENOENT ? -ETIMEDOUT : ctx.status);\r\ndev_dbg(&urb->dev->dev,\r\n"%s timed out on ep%d%s len=%u/%u\n",\r\ncurrent->comm,\r\nusb_endpoint_num(&urb->ep->desc),\r\nusb_urb_dir_in(urb) ? "in" : "out",\r\nurb->actual_length,\r\nurb->transfer_buffer_length);\r\n} else\r\nretval = ctx.status;\r\nout:\r\nif (actual_length)\r\n*actual_length = urb->actual_length;\r\nusb_free_urb(urb);\r\nreturn retval;\r\n}\r\nstatic int usb_internal_control_msg(struct usb_device *usb_dev,\r\nunsigned int pipe,\r\nstruct usb_ctrlrequest *cmd,\r\nvoid *data, int len, int timeout)\r\n{\r\nstruct urb *urb;\r\nint retv;\r\nint length;\r\nurb = usb_alloc_urb(0, GFP_NOIO);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nusb_fill_control_urb(urb, usb_dev, pipe, (unsigned char *)cmd, data,\r\nlen, usb_api_blocking_completion, NULL);\r\nretv = usb_start_wait_urb(urb, timeout, &length);\r\nif (retv < 0)\r\nreturn retv;\r\nelse\r\nreturn length;\r\n}\r\nint usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request,\r\n__u8 requesttype, __u16 value, __u16 index, void *data,\r\n__u16 size, int timeout)\r\n{\r\nstruct usb_ctrlrequest *dr;\r\nint ret;\r\ndr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_NOIO);\r\nif (!dr)\r\nreturn -ENOMEM;\r\ndr->bRequestType = requesttype;\r\ndr->bRequest = request;\r\ndr->wValue = cpu_to_le16(value);\r\ndr->wIndex = cpu_to_le16(index);\r\ndr->wLength = cpu_to_le16(size);\r\nret = usb_internal_control_msg(dev, pipe, dr, data, size, timeout);\r\nkfree(dr);\r\nreturn ret;\r\n}\r\nint usb_interrupt_msg(struct usb_device *usb_dev, unsigned int pipe,\r\nvoid *data, int len, int *actual_length, int timeout)\r\n{\r\nreturn usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout);\r\n}\r\nint usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,\r\nvoid *data, int len, int *actual_length, int timeout)\r\n{\r\nstruct urb *urb;\r\nstruct usb_host_endpoint *ep;\r\nep = usb_pipe_endpoint(usb_dev, pipe);\r\nif (!ep || len < 0)\r\nreturn -EINVAL;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nif ((ep->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\r\nUSB_ENDPOINT_XFER_INT) {\r\npipe = (pipe & ~(3 << 30)) | (PIPE_INTERRUPT << 30);\r\nusb_fill_int_urb(urb, usb_dev, pipe, data, len,\r\nusb_api_blocking_completion, NULL,\r\nep->desc.bInterval);\r\n} else\r\nusb_fill_bulk_urb(urb, usb_dev, pipe, data, len,\r\nusb_api_blocking_completion, NULL);\r\nreturn usb_start_wait_urb(urb, timeout, actual_length);\r\n}\r\nstatic void sg_clean(struct usb_sg_request *io)\r\n{\r\nif (io->urbs) {\r\nwhile (io->entries--)\r\nusb_free_urb(io->urbs [io->entries]);\r\nkfree(io->urbs);\r\nio->urbs = NULL;\r\n}\r\nio->dev = NULL;\r\n}\r\nstatic void sg_complete(struct urb *urb)\r\n{\r\nstruct usb_sg_request *io = urb->context;\r\nint status = urb->status;\r\nspin_lock(&io->lock);\r\nif (io->status\r\n&& (io->status != -ECONNRESET\r\n|| status != -ECONNRESET)\r\n&& urb->actual_length) {\r\ndev_err(io->dev->bus->controller,\r\n"dev %s ep%d%s scatterlist error %d/%d\n",\r\nio->dev->devpath,\r\nusb_endpoint_num(&urb->ep->desc),\r\nusb_urb_dir_in(urb) ? "in" : "out",\r\nstatus, io->status);\r\n}\r\nif (io->status == 0 && status && status != -ECONNRESET) {\r\nint i, found, retval;\r\nio->status = status;\r\nspin_unlock(&io->lock);\r\nfor (i = 0, found = 0; i < io->entries; i++) {\r\nif (!io->urbs [i] || !io->urbs [i]->dev)\r\ncontinue;\r\nif (found) {\r\nretval = usb_unlink_urb(io->urbs [i]);\r\nif (retval != -EINPROGRESS &&\r\nretval != -ENODEV &&\r\nretval != -EBUSY)\r\ndev_err(&io->dev->dev,\r\n"%s, unlink --> %d\n",\r\n__func__, retval);\r\n} else if (urb == io->urbs [i])\r\nfound = 1;\r\n}\r\nspin_lock(&io->lock);\r\n}\r\nurb->dev = NULL;\r\nio->bytes += urb->actual_length;\r\nio->count--;\r\nif (!io->count)\r\ncomplete(&io->complete);\r\nspin_unlock(&io->lock);\r\n}\r\nint usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,\r\nunsigned pipe, unsigned period, struct scatterlist *sg,\r\nint nents, size_t length, gfp_t mem_flags)\r\n{\r\nint i;\r\nint urb_flags;\r\nint use_sg;\r\nif (!io || !dev || !sg\r\n|| usb_pipecontrol(pipe)\r\n|| usb_pipeisoc(pipe)\r\n|| nents <= 0)\r\nreturn -EINVAL;\r\nspin_lock_init(&io->lock);\r\nio->dev = dev;\r\nio->pipe = pipe;\r\nif (dev->bus->sg_tablesize > 0) {\r\nuse_sg = true;\r\nio->entries = 1;\r\n} else {\r\nuse_sg = false;\r\nio->entries = nents;\r\n}\r\nio->urbs = kmalloc(io->entries * sizeof *io->urbs, mem_flags);\r\nif (!io->urbs)\r\ngoto nomem;\r\nurb_flags = URB_NO_INTERRUPT;\r\nif (usb_pipein(pipe))\r\nurb_flags |= URB_SHORT_NOT_OK;\r\nfor_each_sg(sg, sg, io->entries, i) {\r\nstruct urb *urb;\r\nunsigned len;\r\nurb = usb_alloc_urb(0, mem_flags);\r\nif (!urb) {\r\nio->entries = i;\r\ngoto nomem;\r\n}\r\nio->urbs[i] = urb;\r\nurb->dev = NULL;\r\nurb->pipe = pipe;\r\nurb->interval = period;\r\nurb->transfer_flags = urb_flags;\r\nurb->complete = sg_complete;\r\nurb->context = io;\r\nurb->sg = sg;\r\nif (use_sg) {\r\nurb->transfer_buffer = NULL;\r\nurb->num_sgs = nents;\r\nlen = length;\r\nif (len == 0) {\r\nstruct scatterlist *sg2;\r\nint j;\r\nfor_each_sg(sg, sg2, nents, j)\r\nlen += sg2->length;\r\n}\r\n} else {\r\nif (!PageHighMem(sg_page(sg)))\r\nurb->transfer_buffer = sg_virt(sg);\r\nelse\r\nurb->transfer_buffer = NULL;\r\nlen = sg->length;\r\nif (length) {\r\nlen = min_t(size_t, len, length);\r\nlength -= len;\r\nif (length == 0)\r\nio->entries = i + 1;\r\n}\r\n}\r\nurb->transfer_buffer_length = len;\r\n}\r\nio->urbs[--i]->transfer_flags &= ~URB_NO_INTERRUPT;\r\nio->count = io->entries;\r\nio->status = 0;\r\nio->bytes = 0;\r\ninit_completion(&io->complete);\r\nreturn 0;\r\nnomem:\r\nsg_clean(io);\r\nreturn -ENOMEM;\r\n}\r\nvoid usb_sg_wait(struct usb_sg_request *io)\r\n{\r\nint i;\r\nint entries = io->entries;\r\nspin_lock_irq(&io->lock);\r\ni = 0;\r\nwhile (i < entries && !io->status) {\r\nint retval;\r\nio->urbs[i]->dev = io->dev;\r\nretval = usb_submit_urb(io->urbs [i], GFP_ATOMIC);\r\nspin_unlock_irq(&io->lock);\r\nswitch (retval) {\r\ncase -ENXIO:\r\ncase -EAGAIN:\r\ncase -ENOMEM:\r\nio->urbs[i]->dev = NULL;\r\nretval = 0;\r\nyield();\r\nbreak;\r\ncase 0:\r\n++i;\r\ncpu_relax();\r\nbreak;\r\ndefault:\r\nio->urbs[i]->dev = NULL;\r\nio->urbs[i]->status = retval;\r\ndev_dbg(&io->dev->dev, "%s, submit --> %d\n",\r\n__func__, retval);\r\nusb_sg_cancel(io);\r\n}\r\nspin_lock_irq(&io->lock);\r\nif (retval && (io->status == 0 || io->status == -ECONNRESET))\r\nio->status = retval;\r\n}\r\nio->count -= entries - i;\r\nif (io->count == 0)\r\ncomplete(&io->complete);\r\nspin_unlock_irq(&io->lock);\r\nwait_for_completion(&io->complete);\r\nsg_clean(io);\r\n}\r\nvoid usb_sg_cancel(struct usb_sg_request *io)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&io->lock, flags);\r\nif (!io->status) {\r\nint i;\r\nio->status = -ECONNRESET;\r\nspin_unlock(&io->lock);\r\nfor (i = 0; i < io->entries; i++) {\r\nint retval;\r\nif (!io->urbs [i]->dev)\r\ncontinue;\r\nretval = usb_unlink_urb(io->urbs [i]);\r\nif (retval != -EINPROGRESS && retval != -EBUSY)\r\ndev_warn(&io->dev->dev, "%s, unlink --> %d\n",\r\n__func__, retval);\r\n}\r\nspin_lock(&io->lock);\r\n}\r\nspin_unlock_irqrestore(&io->lock, flags);\r\n}\r\nint usb_get_descriptor(struct usb_device *dev, unsigned char type,\r\nunsigned char index, void *buf, int size)\r\n{\r\nint i;\r\nint result;\r\nmemset(buf, 0, size);\r\nfor (i = 0; i < 3; ++i) {\r\nresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN,\r\n(type << 8) + index, 0, buf, size,\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (result <= 0 && result != -ETIMEDOUT)\r\ncontinue;\r\nif (result > 1 && ((u8 *)buf)[1] != type) {\r\nresult = -ENODATA;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int usb_get_string(struct usb_device *dev, unsigned short langid,\r\nunsigned char index, void *buf, int size)\r\n{\r\nint i;\r\nint result;\r\nfor (i = 0; i < 3; ++i) {\r\nresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN,\r\n(USB_DT_STRING << 8) + index, langid, buf, size,\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (result == 0 || result == -EPIPE)\r\ncontinue;\r\nif (result > 1 && ((u8 *) buf)[1] != USB_DT_STRING) {\r\nresult = -ENODATA;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic void usb_try_string_workarounds(unsigned char *buf, int *length)\r\n{\r\nint newlength, oldlength = *length;\r\nfor (newlength = 2; newlength + 1 < oldlength; newlength += 2)\r\nif (!isprint(buf[newlength]) || buf[newlength + 1])\r\nbreak;\r\nif (newlength > 2) {\r\nbuf[0] = newlength;\r\n*length = newlength;\r\n}\r\n}\r\nstatic int usb_string_sub(struct usb_device *dev, unsigned int langid,\r\nunsigned int index, unsigned char *buf)\r\n{\r\nint rc;\r\nif (dev->quirks & USB_QUIRK_STRING_FETCH_255)\r\nrc = -EIO;\r\nelse\r\nrc = usb_get_string(dev, langid, index, buf, 255);\r\nif (rc < 2) {\r\nrc = usb_get_string(dev, langid, index, buf, 2);\r\nif (rc == 2)\r\nrc = usb_get_string(dev, langid, index, buf, buf[0]);\r\n}\r\nif (rc >= 2) {\r\nif (!buf[0] && !buf[1])\r\nusb_try_string_workarounds(buf, &rc);\r\nif (buf[0] < rc)\r\nrc = buf[0];\r\nrc = rc - (rc & 1);\r\n}\r\nif (rc < 2)\r\nrc = (rc < 0 ? rc : -EINVAL);\r\nreturn rc;\r\n}\r\nstatic int usb_get_langid(struct usb_device *dev, unsigned char *tbuf)\r\n{\r\nint err;\r\nif (dev->have_langid)\r\nreturn 0;\r\nif (dev->string_langid < 0)\r\nreturn -EPIPE;\r\nerr = usb_string_sub(dev, 0, 0, tbuf);\r\nif (err == -ENODATA || (err > 0 && err < 4)) {\r\ndev->string_langid = 0x0409;\r\ndev->have_langid = 1;\r\ndev_err(&dev->dev,\r\n"string descriptor 0 malformed (err = %d), "\r\n"defaulting to 0x%04x\n",\r\nerr, dev->string_langid);\r\nreturn 0;\r\n}\r\nif (err < 0) {\r\ndev_err(&dev->dev, "string descriptor 0 read error: %d\n",\r\nerr);\r\ndev->string_langid = -1;\r\nreturn -EPIPE;\r\n}\r\ndev->string_langid = tbuf[2] | (tbuf[3] << 8);\r\ndev->have_langid = 1;\r\ndev_dbg(&dev->dev, "default language 0x%04x\n",\r\ndev->string_langid);\r\nreturn 0;\r\n}\r\nint usb_string(struct usb_device *dev, int index, char *buf, size_t size)\r\n{\r\nunsigned char *tbuf;\r\nint err;\r\nif (dev->state == USB_STATE_SUSPENDED)\r\nreturn -EHOSTUNREACH;\r\nif (size <= 0 || !buf || !index)\r\nreturn -EINVAL;\r\nbuf[0] = 0;\r\ntbuf = kmalloc(256, GFP_NOIO);\r\nif (!tbuf)\r\nreturn -ENOMEM;\r\nerr = usb_get_langid(dev, tbuf);\r\nif (err < 0)\r\ngoto errout;\r\nerr = usb_string_sub(dev, dev->string_langid, index, tbuf);\r\nif (err < 0)\r\ngoto errout;\r\nsize--;\r\nerr = utf16s_to_utf8s((wchar_t *) &tbuf[2], (err - 2) / 2,\r\nUTF16_LITTLE_ENDIAN, buf, size);\r\nbuf[err] = 0;\r\nif (tbuf[1] != USB_DT_STRING)\r\ndev_dbg(&dev->dev,\r\n"wrong descriptor type %02x for string %d (\"%s\")\n",\r\ntbuf[1], index, buf);\r\nerrout:\r\nkfree(tbuf);\r\nreturn err;\r\n}\r\nchar *usb_cache_string(struct usb_device *udev, int index)\r\n{\r\nchar *buf;\r\nchar *smallbuf = NULL;\r\nint len;\r\nif (index <= 0)\r\nreturn NULL;\r\nbuf = kmalloc(MAX_USB_STRING_SIZE, GFP_NOIO);\r\nif (buf) {\r\nlen = usb_string(udev, index, buf, MAX_USB_STRING_SIZE);\r\nif (len > 0) {\r\nsmallbuf = kmalloc(++len, GFP_NOIO);\r\nif (!smallbuf)\r\nreturn buf;\r\nmemcpy(smallbuf, buf, len);\r\n}\r\nkfree(buf);\r\n}\r\nreturn smallbuf;\r\n}\r\nint usb_get_device_descriptor(struct usb_device *dev, unsigned int size)\r\n{\r\nstruct usb_device_descriptor *desc;\r\nint ret;\r\nif (size > sizeof(*desc))\r\nreturn -EINVAL;\r\ndesc = kmalloc(sizeof(*desc), GFP_NOIO);\r\nif (!desc)\r\nreturn -ENOMEM;\r\nret = usb_get_descriptor(dev, USB_DT_DEVICE, 0, desc, size);\r\nif (ret >= 0)\r\nmemcpy(&dev->descriptor, desc, size);\r\nkfree(desc);\r\nreturn ret;\r\n}\r\nint usb_get_status(struct usb_device *dev, int type, int target, void *data)\r\n{\r\nint ret;\r\nu16 *status = kmalloc(sizeof(*status), GFP_KERNEL);\r\nif (!status)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nUSB_REQ_GET_STATUS, USB_DIR_IN | type, 0, target, status,\r\nsizeof(*status), USB_CTRL_GET_TIMEOUT);\r\n*(u16 *)data = *status;\r\nkfree(status);\r\nreturn ret;\r\n}\r\nint usb_clear_halt(struct usb_device *dev, int pipe)\r\n{\r\nint result;\r\nint endp = usb_pipeendpoint(pipe);\r\nif (usb_pipein(pipe))\r\nendp |= USB_DIR_IN;\r\nresult = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nUSB_REQ_CLEAR_FEATURE, USB_RECIP_ENDPOINT,\r\nUSB_ENDPOINT_HALT, endp, NULL, 0,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (result < 0)\r\nreturn result;\r\nusb_reset_endpoint(dev, endp);\r\nreturn 0;\r\n}\r\nstatic int create_intf_ep_devs(struct usb_interface *intf)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usb_host_interface *alt = intf->cur_altsetting;\r\nint i;\r\nif (intf->ep_devs_created || intf->unregistering)\r\nreturn 0;\r\nfor (i = 0; i < alt->desc.bNumEndpoints; ++i)\r\n(void) usb_create_ep_devs(&intf->dev, &alt->endpoint[i], udev);\r\nintf->ep_devs_created = 1;\r\nreturn 0;\r\n}\r\nstatic void remove_intf_ep_devs(struct usb_interface *intf)\r\n{\r\nstruct usb_host_interface *alt = intf->cur_altsetting;\r\nint i;\r\nif (!intf->ep_devs_created)\r\nreturn;\r\nfor (i = 0; i < alt->desc.bNumEndpoints; ++i)\r\nusb_remove_ep_devs(&alt->endpoint[i]);\r\nintf->ep_devs_created = 0;\r\n}\r\nvoid usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr,\r\nbool reset_hardware)\r\n{\r\nunsigned int epnum = epaddr & USB_ENDPOINT_NUMBER_MASK;\r\nstruct usb_host_endpoint *ep;\r\nif (!dev)\r\nreturn;\r\nif (usb_endpoint_out(epaddr)) {\r\nep = dev->ep_out[epnum];\r\nif (reset_hardware)\r\ndev->ep_out[epnum] = NULL;\r\n} else {\r\nep = dev->ep_in[epnum];\r\nif (reset_hardware)\r\ndev->ep_in[epnum] = NULL;\r\n}\r\nif (ep) {\r\nep->enabled = 0;\r\nusb_hcd_flush_endpoint(dev, ep);\r\nif (reset_hardware)\r\nusb_hcd_disable_endpoint(dev, ep);\r\n}\r\n}\r\nvoid usb_reset_endpoint(struct usb_device *dev, unsigned int epaddr)\r\n{\r\nunsigned int epnum = epaddr & USB_ENDPOINT_NUMBER_MASK;\r\nstruct usb_host_endpoint *ep;\r\nif (usb_endpoint_out(epaddr))\r\nep = dev->ep_out[epnum];\r\nelse\r\nep = dev->ep_in[epnum];\r\nif (ep)\r\nusb_hcd_reset_endpoint(dev, ep);\r\n}\r\nvoid usb_disable_interface(struct usb_device *dev, struct usb_interface *intf,\r\nbool reset_hardware)\r\n{\r\nstruct usb_host_interface *alt = intf->cur_altsetting;\r\nint i;\r\nfor (i = 0; i < alt->desc.bNumEndpoints; ++i) {\r\nusb_disable_endpoint(dev,\r\nalt->endpoint[i].desc.bEndpointAddress,\r\nreset_hardware);\r\n}\r\n}\r\nvoid usb_disable_device(struct usb_device *dev, int skip_ep0)\r\n{\r\nint i;\r\nstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\r\nif (dev->actconfig) {\r\nfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++)\r\ndev->actconfig->interface[i]->unregistering = 1;\r\nfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\r\nstruct usb_interface *interface;\r\ninterface = dev->actconfig->interface[i];\r\nif (!device_is_registered(&interface->dev))\r\ncontinue;\r\ndev_dbg(&dev->dev, "unregistering interface %s\n",\r\ndev_name(&interface->dev));\r\nremove_intf_ep_devs(interface);\r\ndevice_del(&interface->dev);\r\n}\r\nfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\r\nput_device(&dev->actconfig->interface[i]->dev);\r\ndev->actconfig->interface[i] = NULL;\r\n}\r\ndev->actconfig = NULL;\r\nif (dev->state == USB_STATE_CONFIGURED)\r\nusb_set_device_state(dev, USB_STATE_ADDRESS);\r\n}\r\ndev_dbg(&dev->dev, "%s nuking %s URBs\n", __func__,\r\nskip_ep0 ? "non-ep0" : "all");\r\nif (hcd->driver->check_bandwidth) {\r\nfor (i = skip_ep0; i < 16; ++i) {\r\nusb_disable_endpoint(dev, i, false);\r\nusb_disable_endpoint(dev, i + USB_DIR_IN, false);\r\n}\r\nusb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);\r\n}\r\nfor (i = skip_ep0; i < 16; ++i) {\r\nusb_disable_endpoint(dev, i, true);\r\nusb_disable_endpoint(dev, i + USB_DIR_IN, true);\r\n}\r\n}\r\nvoid usb_enable_endpoint(struct usb_device *dev, struct usb_host_endpoint *ep,\r\nbool reset_ep)\r\n{\r\nint epnum = usb_endpoint_num(&ep->desc);\r\nint is_out = usb_endpoint_dir_out(&ep->desc);\r\nint is_control = usb_endpoint_xfer_control(&ep->desc);\r\nif (reset_ep)\r\nusb_hcd_reset_endpoint(dev, ep);\r\nif (is_out || is_control)\r\ndev->ep_out[epnum] = ep;\r\nif (!is_out || is_control)\r\ndev->ep_in[epnum] = ep;\r\nep->enabled = 1;\r\n}\r\nvoid usb_enable_interface(struct usb_device *dev,\r\nstruct usb_interface *intf, bool reset_eps)\r\n{\r\nstruct usb_host_interface *alt = intf->cur_altsetting;\r\nint i;\r\nfor (i = 0; i < alt->desc.bNumEndpoints; ++i)\r\nusb_enable_endpoint(dev, &alt->endpoint[i], reset_eps);\r\n}\r\nint usb_set_interface(struct usb_device *dev, int interface, int alternate)\r\n{\r\nstruct usb_interface *iface;\r\nstruct usb_host_interface *alt;\r\nstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\r\nint ret;\r\nint manual = 0;\r\nunsigned int epaddr;\r\nunsigned int pipe;\r\nif (dev->state == USB_STATE_SUSPENDED)\r\nreturn -EHOSTUNREACH;\r\niface = usb_ifnum_to_if(dev, interface);\r\nif (!iface) {\r\ndev_dbg(&dev->dev, "selecting invalid interface %d\n",\r\ninterface);\r\nreturn -EINVAL;\r\n}\r\nif (iface->unregistering)\r\nreturn -ENODEV;\r\nalt = usb_altnum_to_altsetting(iface, alternate);\r\nif (!alt) {\r\ndev_warn(&dev->dev, "selecting invalid altsetting %d\n",\r\nalternate);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(hcd->bandwidth_mutex);\r\nret = usb_hcd_alloc_bandwidth(dev, NULL, iface->cur_altsetting, alt);\r\nif (ret < 0) {\r\ndev_info(&dev->dev, "Not enough bandwidth for altsetting %d\n",\r\nalternate);\r\nmutex_unlock(hcd->bandwidth_mutex);\r\nreturn ret;\r\n}\r\nif (dev->quirks & USB_QUIRK_NO_SET_INTF)\r\nret = -EPIPE;\r\nelse\r\nret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nUSB_REQ_SET_INTERFACE, USB_RECIP_INTERFACE,\r\nalternate, interface, NULL, 0, 5000);\r\nif (ret == -EPIPE && iface->num_altsetting == 1) {\r\ndev_dbg(&dev->dev,\r\n"manual set_interface for iface %d, alt %d\n",\r\ninterface, alternate);\r\nmanual = 1;\r\n} else if (ret < 0) {\r\nusb_hcd_alloc_bandwidth(dev, NULL, alt, iface->cur_altsetting);\r\nmutex_unlock(hcd->bandwidth_mutex);\r\nreturn ret;\r\n}\r\nmutex_unlock(hcd->bandwidth_mutex);\r\nif (iface->cur_altsetting != alt) {\r\nremove_intf_ep_devs(iface);\r\nusb_remove_sysfs_intf_files(iface);\r\n}\r\nusb_disable_interface(dev, iface, true);\r\niface->cur_altsetting = alt;\r\nif (manual) {\r\nint i;\r\nfor (i = 0; i < alt->desc.bNumEndpoints; i++) {\r\nepaddr = alt->endpoint[i].desc.bEndpointAddress;\r\npipe = __create_pipe(dev,\r\nUSB_ENDPOINT_NUMBER_MASK & epaddr) |\r\n(usb_endpoint_out(epaddr) ?\r\nUSB_DIR_OUT : USB_DIR_IN);\r\nusb_clear_halt(dev, pipe);\r\n}\r\n}\r\nusb_enable_interface(dev, iface, true);\r\nif (device_is_registered(&iface->dev)) {\r\nusb_create_sysfs_intf_files(iface);\r\ncreate_intf_ep_devs(iface);\r\n}\r\nreturn 0;\r\n}\r\nint usb_reset_configuration(struct usb_device *dev)\r\n{\r\nint i, retval;\r\nstruct usb_host_config *config;\r\nstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\r\nif (dev->state == USB_STATE_SUSPENDED)\r\nreturn -EHOSTUNREACH;\r\nfor (i = 1; i < 16; ++i) {\r\nusb_disable_endpoint(dev, i, true);\r\nusb_disable_endpoint(dev, i + USB_DIR_IN, true);\r\n}\r\nconfig = dev->actconfig;\r\nretval = 0;\r\nmutex_lock(hcd->bandwidth_mutex);\r\nfor (i = 0; i < config->desc.bNumInterfaces; i++) {\r\nstruct usb_interface *intf = config->interface[i];\r\nstruct usb_host_interface *alt;\r\nalt = usb_altnum_to_altsetting(intf, 0);\r\nif (!alt)\r\nalt = &intf->altsetting[0];\r\nif (alt != intf->cur_altsetting)\r\nretval = usb_hcd_alloc_bandwidth(dev, NULL,\r\nintf->cur_altsetting, alt);\r\nif (retval < 0)\r\nbreak;\r\n}\r\nif (retval < 0) {\r\nreset_old_alts:\r\nfor (i--; i >= 0; i--) {\r\nstruct usb_interface *intf = config->interface[i];\r\nstruct usb_host_interface *alt;\r\nalt = usb_altnum_to_altsetting(intf, 0);\r\nif (!alt)\r\nalt = &intf->altsetting[0];\r\nif (alt != intf->cur_altsetting)\r\nusb_hcd_alloc_bandwidth(dev, NULL,\r\nalt, intf->cur_altsetting);\r\n}\r\nmutex_unlock(hcd->bandwidth_mutex);\r\nreturn retval;\r\n}\r\nretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nUSB_REQ_SET_CONFIGURATION, 0,\r\nconfig->desc.bConfigurationValue, 0,\r\nNULL, 0, USB_CTRL_SET_TIMEOUT);\r\nif (retval < 0)\r\ngoto reset_old_alts;\r\nmutex_unlock(hcd->bandwidth_mutex);\r\nfor (i = 0; i < config->desc.bNumInterfaces; i++) {\r\nstruct usb_interface *intf = config->interface[i];\r\nstruct usb_host_interface *alt;\r\nalt = usb_altnum_to_altsetting(intf, 0);\r\nif (!alt)\r\nalt = &intf->altsetting[0];\r\nif (alt != intf->cur_altsetting) {\r\nremove_intf_ep_devs(intf);\r\nusb_remove_sysfs_intf_files(intf);\r\n}\r\nintf->cur_altsetting = alt;\r\nusb_enable_interface(dev, intf, true);\r\nif (device_is_registered(&intf->dev)) {\r\nusb_create_sysfs_intf_files(intf);\r\ncreate_intf_ep_devs(intf);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void usb_release_interface(struct device *dev)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct usb_interface_cache *intfc =\r\naltsetting_to_usb_interface_cache(intf->altsetting);\r\nkref_put(&intfc->ref, usb_release_interface_cache);\r\nkfree(intf);\r\n}\r\nstatic int usb_if_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct usb_device *usb_dev;\r\nstruct usb_interface *intf;\r\nstruct usb_host_interface *alt;\r\nintf = to_usb_interface(dev);\r\nusb_dev = interface_to_usbdev(intf);\r\nalt = intf->cur_altsetting;\r\nif (add_uevent_var(env, "INTERFACE=%d/%d/%d",\r\nalt->desc.bInterfaceClass,\r\nalt->desc.bInterfaceSubClass,\r\nalt->desc.bInterfaceProtocol))\r\nreturn -ENOMEM;\r\nif (add_uevent_var(env,\r\n"MODALIAS=usb:"\r\n"v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02X",\r\nle16_to_cpu(usb_dev->descriptor.idVendor),\r\nle16_to_cpu(usb_dev->descriptor.idProduct),\r\nle16_to_cpu(usb_dev->descriptor.bcdDevice),\r\nusb_dev->descriptor.bDeviceClass,\r\nusb_dev->descriptor.bDeviceSubClass,\r\nusb_dev->descriptor.bDeviceProtocol,\r\nalt->desc.bInterfaceClass,\r\nalt->desc.bInterfaceSubClass,\r\nalt->desc.bInterfaceProtocol))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int usb_if_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic struct usb_interface_assoc_descriptor *find_iad(struct usb_device *dev,\r\nstruct usb_host_config *config,\r\nu8 inum)\r\n{\r\nstruct usb_interface_assoc_descriptor *retval = NULL;\r\nstruct usb_interface_assoc_descriptor *intf_assoc;\r\nint first_intf;\r\nint last_intf;\r\nint i;\r\nfor (i = 0; (i < USB_MAXIADS && config->intf_assoc[i]); i++) {\r\nintf_assoc = config->intf_assoc[i];\r\nif (intf_assoc->bInterfaceCount == 0)\r\ncontinue;\r\nfirst_intf = intf_assoc->bFirstInterface;\r\nlast_intf = first_intf + (intf_assoc->bInterfaceCount - 1);\r\nif (inum >= first_intf && inum <= last_intf) {\r\nif (!retval)\r\nretval = intf_assoc;\r\nelse\r\ndev_err(&dev->dev, "Interface #%d referenced"\r\n" by multiple IADs\n", inum);\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic void __usb_queue_reset_device(struct work_struct *ws)\r\n{\r\nint rc;\r\nstruct usb_interface *iface =\r\ncontainer_of(ws, struct usb_interface, reset_ws);\r\nstruct usb_device *udev = interface_to_usbdev(iface);\r\nrc = usb_lock_device_for_reset(udev, iface);\r\nif (rc >= 0) {\r\niface->reset_running = 1;\r\nusb_reset_device(udev);\r\niface->reset_running = 0;\r\nusb_unlock_device(udev);\r\n}\r\n}\r\nint usb_set_configuration(struct usb_device *dev, int configuration)\r\n{\r\nint i, ret;\r\nstruct usb_host_config *cp = NULL;\r\nstruct usb_interface **new_interfaces = NULL;\r\nstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\r\nint n, nintf;\r\nif (dev->authorized == 0 || configuration == -1)\r\nconfiguration = 0;\r\nelse {\r\nfor (i = 0; i < dev->descriptor.bNumConfigurations; i++) {\r\nif (dev->config[i].desc.bConfigurationValue ==\r\nconfiguration) {\r\ncp = &dev->config[i];\r\nbreak;\r\n}\r\n}\r\n}\r\nif ((!cp && configuration != 0))\r\nreturn -EINVAL;\r\nif (cp && configuration == 0)\r\ndev_warn(&dev->dev, "config 0 descriptor??\n");\r\nn = nintf = 0;\r\nif (cp) {\r\nnintf = cp->desc.bNumInterfaces;\r\nnew_interfaces = kmalloc(nintf * sizeof(*new_interfaces),\r\nGFP_NOIO);\r\nif (!new_interfaces) {\r\ndev_err(&dev->dev, "Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (; n < nintf; ++n) {\r\nnew_interfaces[n] = kzalloc(\r\nsizeof(struct usb_interface),\r\nGFP_NOIO);\r\nif (!new_interfaces[n]) {\r\ndev_err(&dev->dev, "Out of memory\n");\r\nret = -ENOMEM;\r\nfree_interfaces:\r\nwhile (--n >= 0)\r\nkfree(new_interfaces[n]);\r\nkfree(new_interfaces);\r\nreturn ret;\r\n}\r\n}\r\ni = dev->bus_mA - cp->desc.bMaxPower * 2;\r\nif (i < 0)\r\ndev_warn(&dev->dev, "new config #%d exceeds power "\r\n"limit by %dmA\n",\r\nconfiguration, -i);\r\n}\r\nret = usb_autoresume_device(dev);\r\nif (ret)\r\ngoto free_interfaces;\r\nmutex_lock(hcd->bandwidth_mutex);\r\nif (dev->state != USB_STATE_ADDRESS)\r\nusb_disable_device(dev, 1);\r\ncancel_async_set_config(dev);\r\nret = usb_hcd_alloc_bandwidth(dev, cp, NULL, NULL);\r\nif (ret < 0) {\r\nmutex_unlock(hcd->bandwidth_mutex);\r\nusb_autosuspend_device(dev);\r\ngoto free_interfaces;\r\n}\r\nret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nUSB_REQ_SET_CONFIGURATION, 0, configuration, 0,\r\nNULL, 0, USB_CTRL_SET_TIMEOUT);\r\nif (ret < 0) {\r\ncp = NULL;\r\n}\r\ndev->actconfig = cp;\r\nif (!cp) {\r\nusb_set_device_state(dev, USB_STATE_ADDRESS);\r\nusb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);\r\nmutex_unlock(hcd->bandwidth_mutex);\r\nusb_autosuspend_device(dev);\r\ngoto free_interfaces;\r\n}\r\nmutex_unlock(hcd->bandwidth_mutex);\r\nusb_set_device_state(dev, USB_STATE_CONFIGURED);\r\nfor (i = 0; i < nintf; ++i) {\r\nstruct usb_interface_cache *intfc;\r\nstruct usb_interface *intf;\r\nstruct usb_host_interface *alt;\r\ncp->interface[i] = intf = new_interfaces[i];\r\nintfc = cp->intf_cache[i];\r\nintf->altsetting = intfc->altsetting;\r\nintf->num_altsetting = intfc->num_altsetting;\r\nintf->intf_assoc = find_iad(dev, cp, i);\r\nkref_get(&intfc->ref);\r\nalt = usb_altnum_to_altsetting(intf, 0);\r\nif (!alt)\r\nalt = &intf->altsetting[0];\r\nintf->cur_altsetting = alt;\r\nusb_enable_interface(dev, intf, true);\r\nintf->dev.parent = &dev->dev;\r\nintf->dev.driver = NULL;\r\nintf->dev.bus = &usb_bus_type;\r\nintf->dev.type = &usb_if_device_type;\r\nintf->dev.groups = usb_interface_groups;\r\nintf->dev.dma_mask = dev->dev.dma_mask;\r\nINIT_WORK(&intf->reset_ws, __usb_queue_reset_device);\r\nintf->minor = -1;\r\ndevice_initialize(&intf->dev);\r\npm_runtime_no_callbacks(&intf->dev);\r\ndev_set_name(&intf->dev, "%d-%s:%d.%d",\r\ndev->bus->busnum, dev->devpath,\r\nconfiguration, alt->desc.bInterfaceNumber);\r\n}\r\nkfree(new_interfaces);\r\nif (cp->string == NULL &&\r\n!(dev->quirks & USB_QUIRK_CONFIG_INTF_STRINGS))\r\ncp->string = usb_cache_string(dev, cp->desc.iConfiguration);\r\nfor (i = 0; i < nintf; ++i) {\r\nstruct usb_interface *intf = cp->interface[i];\r\ndev_dbg(&dev->dev,\r\n"adding %s (config #%d, interface %d)\n",\r\ndev_name(&intf->dev), configuration,\r\nintf->cur_altsetting->desc.bInterfaceNumber);\r\ndevice_enable_async_suspend(&intf->dev);\r\nret = device_add(&intf->dev);\r\nif (ret != 0) {\r\ndev_err(&dev->dev, "device_add(%s) --> %d\n",\r\ndev_name(&intf->dev), ret);\r\ncontinue;\r\n}\r\ncreate_intf_ep_devs(intf);\r\n}\r\nusb_autosuspend_device(dev);\r\nreturn 0;\r\n}\r\nstatic void driver_set_config_work(struct work_struct *work)\r\n{\r\nstruct set_config_request *req =\r\ncontainer_of(work, struct set_config_request, work);\r\nstruct usb_device *udev = req->udev;\r\nusb_lock_device(udev);\r\nspin_lock(&set_config_lock);\r\nlist_del(&req->node);\r\nspin_unlock(&set_config_lock);\r\nif (req->config >= -1)\r\nusb_set_configuration(udev, req->config);\r\nusb_unlock_device(udev);\r\nusb_put_dev(udev);\r\nkfree(req);\r\n}\r\nstatic void cancel_async_set_config(struct usb_device *udev)\r\n{\r\nstruct set_config_request *req;\r\nspin_lock(&set_config_lock);\r\nlist_for_each_entry(req, &set_config_list, node) {\r\nif (req->udev == udev)\r\nreq->config = -999;\r\n}\r\nspin_unlock(&set_config_lock);\r\n}\r\nint usb_driver_set_configuration(struct usb_device *udev, int config)\r\n{\r\nstruct set_config_request *req;\r\nreq = kmalloc(sizeof(*req), GFP_KERNEL);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq->udev = udev;\r\nreq->config = config;\r\nINIT_WORK(&req->work, driver_set_config_work);\r\nspin_lock(&set_config_lock);\r\nlist_add(&req->node, &set_config_list);\r\nspin_unlock(&set_config_lock);\r\nusb_get_dev(udev);\r\nschedule_work(&req->work);\r\nreturn 0;\r\n}
