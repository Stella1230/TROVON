static ssize_t display_enabled_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nbool enabled = dssdev->state != OMAP_DSS_DISPLAY_DISABLED;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", enabled);\r\n}\r\nstatic ssize_t display_enabled_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nint r;\r\nbool enabled;\r\nr = strtobool(buf, &enabled);\r\nif (r)\r\nreturn r;\r\nif (enabled != (dssdev->state != OMAP_DSS_DISPLAY_DISABLED)) {\r\nif (enabled) {\r\nr = dssdev->driver->enable(dssdev);\r\nif (r)\r\nreturn r;\r\n} else {\r\ndssdev->driver->disable(dssdev);\r\n}\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t display_tear_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\ndssdev->driver->get_te ?\r\ndssdev->driver->get_te(dssdev) : 0);\r\n}\r\nstatic ssize_t display_tear_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nint r;\r\nbool te;\r\nif (!dssdev->driver->enable_te || !dssdev->driver->get_te)\r\nreturn -ENOENT;\r\nr = strtobool(buf, &te);\r\nif (r)\r\nreturn r;\r\nr = dssdev->driver->enable_te(dssdev, te);\r\nif (r)\r\nreturn r;\r\nreturn size;\r\n}\r\nstatic ssize_t display_timings_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nstruct omap_video_timings t;\r\nif (!dssdev->driver->get_timings)\r\nreturn -ENOENT;\r\ndssdev->driver->get_timings(dssdev, &t);\r\nreturn snprintf(buf, PAGE_SIZE, "%u,%u/%u/%u/%u,%u/%u/%u/%u\n",\r\nt.pixel_clock,\r\nt.x_res, t.hfp, t.hbp, t.hsw,\r\nt.y_res, t.vfp, t.vbp, t.vsw);\r\n}\r\nstatic ssize_t display_timings_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nstruct omap_video_timings t;\r\nint r, found;\r\nif (!dssdev->driver->set_timings || !dssdev->driver->check_timings)\r\nreturn -ENOENT;\r\nfound = 0;\r\n#ifdef CONFIG_OMAP2_DSS_VENC\r\nif (strncmp("pal", buf, 3) == 0) {\r\nt = omap_dss_pal_timings;\r\nfound = 1;\r\n} else if (strncmp("ntsc", buf, 4) == 0) {\r\nt = omap_dss_ntsc_timings;\r\nfound = 1;\r\n}\r\n#endif\r\nif (!found && sscanf(buf, "%u,%hu/%hu/%hu/%hu,%hu/%hu/%hu/%hu",\r\n&t.pixel_clock,\r\n&t.x_res, &t.hfp, &t.hbp, &t.hsw,\r\n&t.y_res, &t.vfp, &t.vbp, &t.vsw) != 9)\r\nreturn -EINVAL;\r\nr = dssdev->driver->check_timings(dssdev, &t);\r\nif (r)\r\nreturn r;\r\ndssdev->driver->set_timings(dssdev, &t);\r\nreturn size;\r\n}\r\nstatic ssize_t display_rotate_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nint rotate;\r\nif (!dssdev->driver->get_rotate)\r\nreturn -ENOENT;\r\nrotate = dssdev->driver->get_rotate(dssdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", rotate);\r\n}\r\nstatic ssize_t display_rotate_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nint rot, r;\r\nif (!dssdev->driver->set_rotate || !dssdev->driver->get_rotate)\r\nreturn -ENOENT;\r\nr = kstrtoint(buf, 0, &rot);\r\nif (r)\r\nreturn r;\r\nr = dssdev->driver->set_rotate(dssdev, rot);\r\nif (r)\r\nreturn r;\r\nreturn size;\r\n}\r\nstatic ssize_t display_mirror_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nint mirror;\r\nif (!dssdev->driver->get_mirror)\r\nreturn -ENOENT;\r\nmirror = dssdev->driver->get_mirror(dssdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", mirror);\r\n}\r\nstatic ssize_t display_mirror_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nint r;\r\nbool mirror;\r\nif (!dssdev->driver->set_mirror || !dssdev->driver->get_mirror)\r\nreturn -ENOENT;\r\nr = strtobool(buf, &mirror);\r\nif (r)\r\nreturn r;\r\nr = dssdev->driver->set_mirror(dssdev, mirror);\r\nif (r)\r\nreturn r;\r\nreturn size;\r\n}\r\nstatic ssize_t display_wss_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nunsigned int wss;\r\nif (!dssdev->driver->get_wss)\r\nreturn -ENOENT;\r\nwss = dssdev->driver->get_wss(dssdev);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%05x\n", wss);\r\n}\r\nstatic ssize_t display_wss_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nu32 wss;\r\nint r;\r\nif (!dssdev->driver->get_wss || !dssdev->driver->set_wss)\r\nreturn -ENOENT;\r\nr = kstrtou32(buf, 0, &wss);\r\nif (r)\r\nreturn r;\r\nif (wss > 0xfffff)\r\nreturn -EINVAL;\r\nr = dssdev->driver->set_wss(dssdev, wss);\r\nif (r)\r\nreturn r;\r\nreturn size;\r\n}\r\nvoid omapdss_default_get_resolution(struct omap_dss_device *dssdev,\r\nu16 *xres, u16 *yres)\r\n{\r\n*xres = dssdev->panel.timings.x_res;\r\n*yres = dssdev->panel.timings.y_res;\r\n}\r\nvoid default_get_overlay_fifo_thresholds(enum omap_plane plane,\r\nu32 fifo_size, u32 burst_size,\r\nu32 *fifo_low, u32 *fifo_high)\r\n{\r\nunsigned buf_unit = dss_feat_get_buffer_size_unit();\r\n*fifo_high = fifo_size - buf_unit;\r\n*fifo_low = fifo_size - burst_size;\r\n}\r\nint omapdss_default_get_recommended_bpp(struct omap_dss_device *dssdev)\r\n{\r\nswitch (dssdev->type) {\r\ncase OMAP_DISPLAY_TYPE_DPI:\r\nif (dssdev->phy.dpi.data_lines == 24)\r\nreturn 24;\r\nelse\r\nreturn 16;\r\ncase OMAP_DISPLAY_TYPE_DBI:\r\nif (dssdev->ctrl.pixel_size == 24)\r\nreturn 24;\r\nelse\r\nreturn 16;\r\ncase OMAP_DISPLAY_TYPE_DSI:\r\nif (dsi_get_pixel_size(dssdev->panel.dsi_pix_fmt) > 16)\r\nreturn 24;\r\nelse\r\nreturn 16;\r\ncase OMAP_DISPLAY_TYPE_VENC:\r\ncase OMAP_DISPLAY_TYPE_SDI:\r\ncase OMAP_DISPLAY_TYPE_HDMI:\r\nreturn 24;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nbool dss_use_replication(struct omap_dss_device *dssdev,\r\nenum omap_color_mode mode)\r\n{\r\nint bpp;\r\nif (mode != OMAP_DSS_COLOR_RGB12U && mode != OMAP_DSS_COLOR_RGB16)\r\nreturn false;\r\nif (dssdev->type == OMAP_DISPLAY_TYPE_DPI &&\r\n(dssdev->panel.config & OMAP_DSS_LCD_TFT) == 0)\r\nreturn false;\r\nswitch (dssdev->type) {\r\ncase OMAP_DISPLAY_TYPE_DPI:\r\nbpp = dssdev->phy.dpi.data_lines;\r\nbreak;\r\ncase OMAP_DISPLAY_TYPE_HDMI:\r\ncase OMAP_DISPLAY_TYPE_VENC:\r\ncase OMAP_DISPLAY_TYPE_SDI:\r\nbpp = 24;\r\nbreak;\r\ncase OMAP_DISPLAY_TYPE_DBI:\r\nbpp = dssdev->ctrl.pixel_size;\r\nbreak;\r\ncase OMAP_DISPLAY_TYPE_DSI:\r\nbpp = dsi_get_pixel_size(dssdev->panel.dsi_pix_fmt);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn bpp > 16;\r\n}\r\nvoid dss_init_device(struct platform_device *pdev,\r\nstruct omap_dss_device *dssdev)\r\n{\r\nstruct device_attribute *attr;\r\nint i;\r\nint r;\r\nswitch (dssdev->type) {\r\n#ifdef CONFIG_OMAP2_DSS_DPI\r\ncase OMAP_DISPLAY_TYPE_DPI:\r\nr = dpi_init_display(dssdev);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_OMAP2_DSS_RFBI\r\ncase OMAP_DISPLAY_TYPE_DBI:\r\nr = rfbi_init_display(dssdev);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_OMAP2_DSS_VENC\r\ncase OMAP_DISPLAY_TYPE_VENC:\r\nr = venc_init_display(dssdev);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_OMAP2_DSS_SDI\r\ncase OMAP_DISPLAY_TYPE_SDI:\r\nr = sdi_init_display(dssdev);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_OMAP2_DSS_DSI\r\ncase OMAP_DISPLAY_TYPE_DSI:\r\nr = dsi_init_display(dssdev);\r\nbreak;\r\n#endif\r\ncase OMAP_DISPLAY_TYPE_HDMI:\r\nr = hdmi_init_display(dssdev);\r\nbreak;\r\ndefault:\r\nDSSERR("Support for display '%s' not compiled in.\n",\r\ndssdev->name);\r\nreturn;\r\n}\r\nif (r) {\r\nDSSERR("failed to init display %s\n", dssdev->name);\r\nreturn;\r\n}\r\ni = 0;\r\nwhile ((attr = display_sysfs_attrs[i++]) != NULL) {\r\nr = device_create_file(&dssdev->dev, attr);\r\nif (r)\r\nDSSERR("failed to create sysfs file\n");\r\n}\r\nr = sysfs_create_link(&pdev->dev.kobj, &dssdev->dev.kobj,\r\ndev_name(&dssdev->dev));\r\nif (r)\r\nDSSERR("failed to create sysfs display link\n");\r\n}\r\nvoid dss_uninit_device(struct platform_device *pdev,\r\nstruct omap_dss_device *dssdev)\r\n{\r\nstruct device_attribute *attr;\r\nint i = 0;\r\nsysfs_remove_link(&pdev->dev.kobj, dev_name(&dssdev->dev));\r\nwhile ((attr = display_sysfs_attrs[i++]) != NULL)\r\ndevice_remove_file(&dssdev->dev, attr);\r\nif (dssdev->manager)\r\ndssdev->manager->unset_device(dssdev->manager);\r\n}\r\nstatic int dss_suspend_device(struct device *dev, void *data)\r\n{\r\nint r;\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nif (dssdev->state != OMAP_DSS_DISPLAY_ACTIVE) {\r\ndssdev->activate_after_resume = false;\r\nreturn 0;\r\n}\r\nif (!dssdev->driver->suspend) {\r\nDSSERR("display '%s' doesn't implement suspend\n",\r\ndssdev->name);\r\nreturn -ENOSYS;\r\n}\r\nr = dssdev->driver->suspend(dssdev);\r\nif (r)\r\nreturn r;\r\ndssdev->activate_after_resume = true;\r\nreturn 0;\r\n}\r\nint dss_suspend_all_devices(void)\r\n{\r\nint r;\r\nstruct bus_type *bus = dss_get_bus();\r\nr = bus_for_each_dev(bus, NULL, NULL, dss_suspend_device);\r\nif (r) {\r\ndss_resume_all_devices();\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dss_resume_device(struct device *dev, void *data)\r\n{\r\nint r;\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nif (dssdev->activate_after_resume && dssdev->driver->resume) {\r\nr = dssdev->driver->resume(dssdev);\r\nif (r)\r\nreturn r;\r\n}\r\ndssdev->activate_after_resume = false;\r\nreturn 0;\r\n}\r\nint dss_resume_all_devices(void)\r\n{\r\nstruct bus_type *bus = dss_get_bus();\r\nreturn bus_for_each_dev(bus, NULL, NULL, dss_resume_device);\r\n}\r\nstatic int dss_disable_device(struct device *dev, void *data)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nif (dssdev->state != OMAP_DSS_DISPLAY_DISABLED)\r\ndssdev->driver->disable(dssdev);\r\nreturn 0;\r\n}\r\nvoid dss_disable_all_devices(void)\r\n{\r\nstruct bus_type *bus = dss_get_bus();\r\nbus_for_each_dev(bus, NULL, NULL, dss_disable_device);\r\n}\r\nvoid omap_dss_get_device(struct omap_dss_device *dssdev)\r\n{\r\nget_device(&dssdev->dev);\r\n}\r\nvoid omap_dss_put_device(struct omap_dss_device *dssdev)\r\n{\r\nput_device(&dssdev->dev);\r\n}\r\nint match(struct device *dev, void *data)\r\n{\r\nreturn 1;\r\n}\r\nstruct omap_dss_device *omap_dss_find_device(void *data,\r\nint (*match)(struct omap_dss_device *dssdev, void *data))\r\n{\r\nstruct omap_dss_device *dssdev = NULL;\r\nwhile ((dssdev = omap_dss_get_next_device(dssdev)) != NULL) {\r\nif (match(dssdev, data))\r\nreturn dssdev;\r\n}\r\nreturn NULL;\r\n}\r\nint omap_dss_start_device(struct omap_dss_device *dssdev)\r\n{\r\nif (!dssdev->driver) {\r\nDSSDBG("no driver\n");\r\nreturn -ENODEV;\r\n}\r\nif (!try_module_get(dssdev->dev.driver->owner)) {\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nvoid omap_dss_stop_device(struct omap_dss_device *dssdev)\r\n{\r\nmodule_put(dssdev->dev.driver->owner);\r\n}
