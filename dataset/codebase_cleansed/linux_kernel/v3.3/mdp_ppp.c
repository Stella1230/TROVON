static void rotate_dst_addr_x(struct mdp_blit_req *req, struct mdp_regs *regs)\r\n{\r\nregs->dst0 += (req->dst_rect.w -\r\nmin((uint32_t)16, req->dst_rect.w)) * regs->dst_bpp;\r\nregs->dst1 += (req->dst_rect.w -\r\nmin((uint32_t)16, req->dst_rect.w)) * regs->dst_bpp;\r\n}\r\nstatic void rotate_dst_addr_y(struct mdp_blit_req *req, struct mdp_regs *regs)\r\n{\r\nregs->dst0 += (req->dst_rect.h -\r\nmin((uint32_t)16, req->dst_rect.h)) *\r\nregs->dst_ystride;\r\nregs->dst1 += (req->dst_rect.h -\r\nmin((uint32_t)16, req->dst_rect.h)) *\r\nregs->dst_ystride;\r\n}\r\nstatic void blit_rotate(struct mdp_blit_req *req,\r\nstruct mdp_regs *regs)\r\n{\r\nif (req->flags == MDP_ROT_NOP)\r\nreturn;\r\nregs->op |= PPP_OP_ROT_ON;\r\nif ((req->flags & MDP_ROT_90 || req->flags & MDP_FLIP_LR) &&\r\n!(req->flags & MDP_ROT_90 && req->flags & MDP_FLIP_LR))\r\nrotate_dst_addr_x(req, regs);\r\nif (req->flags & MDP_ROT_90)\r\nregs->op |= PPP_OP_ROT_90;\r\nif (req->flags & MDP_FLIP_UD) {\r\nregs->op |= PPP_OP_FLIP_UD;\r\nrotate_dst_addr_y(req, regs);\r\n}\r\nif (req->flags & MDP_FLIP_LR)\r\nregs->op |= PPP_OP_FLIP_LR;\r\n}\r\nstatic void blit_convert(struct mdp_blit_req *req, struct mdp_regs *regs)\r\n{\r\nif (req->src.format == req->dst.format)\r\nreturn;\r\nif (IS_RGB(req->src.format) && IS_YCRCB(req->dst.format)) {\r\nregs->op |= PPP_OP_CONVERT_RGB2YCBCR | PPP_OP_CONVERT_ON;\r\n} else if (IS_YCRCB(req->src.format) && IS_RGB(req->dst.format)) {\r\nregs->op |= PPP_OP_CONVERT_YCBCR2RGB | PPP_OP_CONVERT_ON;\r\nif (req->dst.format == MDP_RGB_565)\r\nregs->op |= PPP_OP_CONVERT_MATRIX_SECONDARY;\r\n}\r\n}\r\nstatic uint32_t transp_convert(struct mdp_blit_req *req)\r\n{\r\nuint32_t transp = 0;\r\nif (req->src.format == MDP_RGB_565) {\r\ntransp |= ((GET_BIT_RANGE(req->transp_mask, 15, 11) << 3) |\r\n(GET_BIT_RANGE(req->transp_mask, 15, 13))) << 16;\r\ntransp |= ((GET_BIT_RANGE(req->transp_mask, 4, 0) << 3) |\r\n(GET_BIT_RANGE(req->transp_mask, 4, 2))) << 8;\r\ntransp |= (GET_BIT_RANGE(req->transp_mask, 10, 5) << 2) |\r\n(GET_BIT_RANGE(req->transp_mask, 10, 9));\r\n} else {\r\ntransp |= (GET_BIT_RANGE(req->transp_mask, 15, 8)) |\r\n(GET_BIT_RANGE(req->transp_mask, 23, 16) << 16) |\r\n(GET_BIT_RANGE(req->transp_mask, 7, 0) << 8);\r\n}\r\nreturn transp;\r\n}\r\nstatic void blit_blend(struct mdp_blit_req *req, struct mdp_regs *regs)\r\n{\r\nif (req->transp_mask != MDP_TRANSP_NOP) {\r\nreq->transp_mask = transp_convert(req);\r\nif (req->alpha != MDP_ALPHA_NOP) {\r\nregs->op |= PPP_OP_ROT_ON | PPP_OP_BLEND_ON |\r\nPPP_OP_BLEND_ALPHA_BLEND_NORMAL |\r\nPPP_OP_BLEND_CONSTANT_ALPHA |\r\nPPP_BLEND_ALPHA_TRANSP;\r\n} else {\r\nregs->op |= PPP_OP_ROT_ON | PPP_OP_BLEND_ON |\r\nPPP_OP_BLEND_SRCPIXEL_TRANSP;\r\n}\r\n}\r\nreq->alpha &= 0xff;\r\nif (HAS_ALPHA(req->src.format)) {\r\nregs->op |= PPP_OP_ROT_ON | PPP_OP_BLEND_ON |\r\nPPP_OP_BLEND_SRCPIXEL_ALPHA;\r\n} else if (req->alpha < MDP_ALPHA_NOP) {\r\nregs->op |= PPP_OP_ROT_ON | PPP_OP_BLEND_ON |\r\nPPP_OP_BLEND_ALPHA_BLEND_NORMAL |\r\nPPP_OP_BLEND_CONSTANT_ALPHA;\r\n}\r\nregs->op |= bg_op_chroma[req->dst.format];\r\n}\r\nstatic int scale_params(uint32_t dim_in, uint32_t dim_out, uint32_t origin,\r\nuint32_t *phase_init, uint32_t *phase_step)\r\n{\r\nint64_t k1, k2, k3, k4, tmp;\r\nuint64_t n, d, os, os_p, od, od_p, oreq;\r\nunsigned rpa = 0;\r\nint64_t ip64, delta;\r\nif (dim_out % 3 == 0)\r\nrpa = !(dim_in % (dim_out / 3));\r\nn = ((uint64_t)dim_out) << 34;\r\nd = dim_in;\r\nif (!d)\r\nreturn -1;\r\ndo_div(n, d);\r\nk3 = (n + 1) >> 1;\r\nif ((k3 >> 4) < (1LL << 27) || (k3 >> 4) > (1LL << 31)) {\r\nDLOG("crap bad scale\n");\r\nreturn -1;\r\n}\r\nn = ((uint64_t)dim_in) << 34;\r\nd = (uint64_t)dim_out;\r\nif (!d)\r\nreturn -1;\r\ndo_div(n, d);\r\nk1 = (n + 1) >> 1;\r\nk2 = (k1 - ONE) >> 1;\r\n*phase_init = (int)(k2 >> 4);\r\nk4 = (k3 - ONE) >> 1;\r\nif (rpa) {\r\nos = ((uint64_t)origin << 33) - ONE_HALF;\r\ntmp = (dim_out * os) + ONE_HALF;\r\nif (!dim_in)\r\nreturn -1;\r\ndo_div(tmp, dim_in);\r\nod = tmp - ONE_HALF;\r\n} else {\r\nos = ((uint64_t)origin << 1) - 1;\r\nod = (((k3 * os) >> 1) + k4);\r\n}\r\nod_p = od & INT_MASK;\r\nif (od_p != od)\r\nod_p += ONE;\r\nif (rpa) {\r\ntmp = (dim_in * od_p) + ONE_HALF;\r\nif (!dim_in)\r\nreturn -1;\r\ndo_div(tmp, dim_in);\r\nos_p = tmp - ONE_HALF;\r\n} else {\r\nos_p = ((k1 * (od_p >> 33)) + k2);\r\n}\r\noreq = (os_p & INT_MASK) - ONE;\r\nip64 = os_p - oreq;\r\ndelta = ((int64_t)(origin) << 33) - oreq;\r\nip64 -= delta;\r\ndelta = (ip64 & (1LL << 63)) ? 4 : -4;\r\ndelta <<= 33;\r\nwhile (abs((int)(ip64 >> 33)) > 4)\r\nip64 += delta;\r\n*phase_init = (int)(ip64 >> 4);\r\n*phase_step = (uint32_t)(k1 >> 4);\r\nreturn 0;\r\n}\r\nstatic void load_scale_table(const struct mdp_info *mdp,\r\nstruct mdp_table_entry *table, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nmdp_writel(mdp, table[i].val, table[i].reg);\r\n}\r\nstatic void get_edge_info(uint32_t src, uint32_t src_coord, uint32_t dst,\r\nuint32_t *interp1, uint32_t *interp2,\r\nuint32_t *repeat1, uint32_t *repeat2) {\r\nif (src > 3 * dst) {\r\n*interp1 = 0;\r\n*interp2 = src - 1;\r\n*repeat1 = 0;\r\n*repeat2 = 0;\r\n} else if (src == 3 * dst) {\r\n*interp1 = 0;\r\n*interp2 = src;\r\n*repeat1 = 0;\r\n*repeat2 = 1;\r\n} else if (src > dst && src < 3 * dst) {\r\n*interp1 = -1;\r\n*interp2 = src;\r\n*repeat1 = 1;\r\n*repeat2 = 1;\r\n} else if (src == dst) {\r\n*interp1 = -1;\r\n*interp2 = src + 1;\r\n*repeat1 = 1;\r\n*repeat2 = 2;\r\n} else {\r\n*interp1 = -2;\r\n*interp2 = src + 1;\r\n*repeat1 = 2;\r\n*repeat2 = 2;\r\n}\r\n*interp1 += src_coord;\r\n*interp2 += src_coord;\r\n}\r\nstatic int get_edge_cond(struct mdp_blit_req *req, struct mdp_regs *regs)\r\n{\r\nint32_t luma_interp[4];\r\nint32_t luma_repeat[4];\r\nint32_t chroma_interp[4];\r\nint32_t chroma_bound[4];\r\nint32_t chroma_repeat[4];\r\nuint32_t dst_w, dst_h;\r\nmemset(&luma_interp, 0, sizeof(int32_t) * 4);\r\nmemset(&luma_repeat, 0, sizeof(int32_t) * 4);\r\nmemset(&chroma_interp, 0, sizeof(int32_t) * 4);\r\nmemset(&chroma_bound, 0, sizeof(int32_t) * 4);\r\nmemset(&chroma_repeat, 0, sizeof(int32_t) * 4);\r\nregs->edge = 0;\r\nif (req->flags & MDP_ROT_90) {\r\ndst_w = req->dst_rect.h;\r\ndst_h = req->dst_rect.w;\r\n} else {\r\ndst_w = req->dst_rect.w;\r\ndst_h = req->dst_rect.h;\r\n}\r\nif (regs->op & (PPP_OP_SCALE_Y_ON | PPP_OP_SCALE_X_ON)) {\r\nget_edge_info(req->src_rect.h, req->src_rect.y, dst_h,\r\n&luma_interp[IMG_TOP], &luma_interp[IMG_BOTTOM],\r\n&luma_repeat[IMG_TOP], &luma_repeat[IMG_BOTTOM]);\r\nget_edge_info(req->src_rect.w, req->src_rect.x, dst_w,\r\n&luma_interp[IMG_LEFT], &luma_interp[IMG_RIGHT],\r\n&luma_repeat[IMG_LEFT], &luma_repeat[IMG_RIGHT]);\r\n} else {\r\nluma_interp[IMG_LEFT] = req->src_rect.x;\r\nluma_interp[IMG_RIGHT] = req->src_rect.x + req->src_rect.w - 1;\r\nluma_interp[IMG_TOP] = req->src_rect.y;\r\nluma_interp[IMG_BOTTOM] = req->src_rect.y + req->src_rect.h - 1;\r\nluma_repeat[IMG_LEFT] = 0;\r\nluma_repeat[IMG_TOP] = 0;\r\nluma_repeat[IMG_RIGHT] = 0;\r\nluma_repeat[IMG_BOTTOM] = 0;\r\n}\r\nchroma_interp[IMG_LEFT] = luma_interp[IMG_LEFT];\r\nchroma_interp[IMG_RIGHT] = luma_interp[IMG_RIGHT];\r\nchroma_interp[IMG_TOP] = luma_interp[IMG_TOP];\r\nchroma_interp[IMG_BOTTOM] = luma_interp[IMG_BOTTOM];\r\nchroma_bound[IMG_LEFT] = req->src_rect.x;\r\nchroma_bound[IMG_RIGHT] = req->src_rect.x + req->src_rect.w - 1;\r\nchroma_bound[IMG_TOP] = req->src_rect.y;\r\nchroma_bound[IMG_BOTTOM] = req->src_rect.y + req->src_rect.h - 1;\r\nif (IS_YCRCB(req->src.format)) {\r\nchroma_interp[IMG_LEFT] = chroma_interp[IMG_LEFT] >> 1;\r\nchroma_interp[IMG_RIGHT] = (chroma_interp[IMG_RIGHT] + 1) >> 1;\r\nchroma_bound[IMG_LEFT] = chroma_bound[IMG_LEFT] >> 1;\r\nchroma_bound[IMG_RIGHT] = chroma_bound[IMG_RIGHT] >> 1;\r\n}\r\nif (req->src.format == MDP_Y_CBCR_H2V2 ||\r\nreq->src.format == MDP_Y_CRCB_H2V2) {\r\nchroma_interp[IMG_TOP] = (chroma_interp[IMG_TOP] - 1) >> 1;\r\nchroma_interp[IMG_BOTTOM] = (chroma_interp[IMG_BOTTOM] + 1)\r\n>> 1;\r\nchroma_bound[IMG_TOP] = (chroma_bound[IMG_TOP] + 1) >> 1;\r\nchroma_bound[IMG_BOTTOM] = chroma_bound[IMG_BOTTOM] >> 1;\r\n}\r\nchroma_repeat[IMG_LEFT] = chroma_bound[IMG_LEFT] -\r\nchroma_interp[IMG_LEFT];\r\nchroma_repeat[IMG_RIGHT] = chroma_interp[IMG_RIGHT] -\r\nchroma_bound[IMG_RIGHT];\r\nchroma_repeat[IMG_TOP] = chroma_bound[IMG_TOP] -\r\nchroma_interp[IMG_TOP];\r\nchroma_repeat[IMG_BOTTOM] = chroma_interp[IMG_BOTTOM] -\r\nchroma_bound[IMG_BOTTOM];\r\nif (chroma_repeat[IMG_LEFT] < 0 || chroma_repeat[IMG_LEFT] > 3 ||\r\nchroma_repeat[IMG_RIGHT] < 0 || chroma_repeat[IMG_RIGHT] > 3 ||\r\nchroma_repeat[IMG_TOP] < 0 || chroma_repeat[IMG_TOP] > 3 ||\r\nchroma_repeat[IMG_BOTTOM] < 0 || chroma_repeat[IMG_BOTTOM] > 3 ||\r\nluma_repeat[IMG_LEFT] < 0 || luma_repeat[IMG_LEFT] > 3 ||\r\nluma_repeat[IMG_RIGHT] < 0 || luma_repeat[IMG_RIGHT] > 3 ||\r\nluma_repeat[IMG_TOP] < 0 || luma_repeat[IMG_TOP] > 3 ||\r\nluma_repeat[IMG_BOTTOM] < 0 || luma_repeat[IMG_BOTTOM] > 3)\r\nreturn -1;\r\nregs->edge |= (chroma_repeat[IMG_LEFT] & 3) << MDP_LEFT_CHROMA;\r\nregs->edge |= (chroma_repeat[IMG_RIGHT] & 3) << MDP_RIGHT_CHROMA;\r\nregs->edge |= (chroma_repeat[IMG_TOP] & 3) << MDP_TOP_CHROMA;\r\nregs->edge |= (chroma_repeat[IMG_BOTTOM] & 3) << MDP_BOTTOM_CHROMA;\r\nregs->edge |= (luma_repeat[IMG_LEFT] & 3) << MDP_LEFT_LUMA;\r\nregs->edge |= (luma_repeat[IMG_RIGHT] & 3) << MDP_RIGHT_LUMA;\r\nregs->edge |= (luma_repeat[IMG_TOP] & 3) << MDP_TOP_LUMA;\r\nregs->edge |= (luma_repeat[IMG_BOTTOM] & 3) << MDP_BOTTOM_LUMA;\r\nreturn 0;\r\n}\r\nstatic int blit_scale(const struct mdp_info *mdp, struct mdp_blit_req *req,\r\nstruct mdp_regs *regs)\r\n{\r\nuint32_t phase_init_x, phase_init_y, phase_step_x, phase_step_y;\r\nuint32_t scale_factor_x, scale_factor_y;\r\nuint32_t downscale;\r\nuint32_t dst_w, dst_h;\r\nif (req->flags & MDP_ROT_90) {\r\ndst_w = req->dst_rect.h;\r\ndst_h = req->dst_rect.w;\r\n} else {\r\ndst_w = req->dst_rect.w;\r\ndst_h = req->dst_rect.h;\r\n}\r\nif ((req->src_rect.w == dst_w) && (req->src_rect.h == dst_h) &&\r\n!(req->flags & MDP_BLUR)) {\r\nregs->phasex_init = 0;\r\nregs->phasey_init = 0;\r\nregs->phasex_step = 0;\r\nregs->phasey_step = 0;\r\nreturn 0;\r\n}\r\nif (scale_params(req->src_rect.w, dst_w, 1, &phase_init_x,\r\n&phase_step_x) ||\r\nscale_params(req->src_rect.h, dst_h, 1, &phase_init_y,\r\n&phase_step_y))\r\nreturn -1;\r\nscale_factor_x = (dst_w * 10) / req->src_rect.w;\r\nscale_factor_y = (dst_h * 10) / req->src_rect.h;\r\nif (scale_factor_x > 8)\r\ndownscale = MDP_DOWNSCALE_PT8TO1;\r\nelse if (scale_factor_x > 6)\r\ndownscale = MDP_DOWNSCALE_PT6TOPT8;\r\nelse if (scale_factor_x > 4)\r\ndownscale = MDP_DOWNSCALE_PT4TOPT6;\r\nelse\r\ndownscale = MDP_DOWNSCALE_PT2TOPT4;\r\nif (downscale != downscale_x_table) {\r\nload_scale_table(mdp, mdp_downscale_x_table[downscale], 64);\r\ndownscale_x_table = downscale;\r\n}\r\nif (scale_factor_y > 8)\r\ndownscale = MDP_DOWNSCALE_PT8TO1;\r\nelse if (scale_factor_y > 6)\r\ndownscale = MDP_DOWNSCALE_PT6TOPT8;\r\nelse if (scale_factor_y > 4)\r\ndownscale = MDP_DOWNSCALE_PT4TOPT6;\r\nelse\r\ndownscale = MDP_DOWNSCALE_PT2TOPT4;\r\nif (downscale != downscale_y_table) {\r\nload_scale_table(mdp, mdp_downscale_y_table[downscale], 64);\r\ndownscale_y_table = downscale;\r\n}\r\nregs->phasex_init = phase_init_x;\r\nregs->phasey_init = phase_init_y;\r\nregs->phasex_step = phase_step_x;\r\nregs->phasey_step = phase_step_y;\r\nregs->op |= (PPP_OP_SCALE_Y_ON | PPP_OP_SCALE_X_ON);\r\nreturn 0;\r\n}\r\nstatic void blit_blur(const struct mdp_info *mdp, struct mdp_blit_req *req,\r\nstruct mdp_regs *regs)\r\n{\r\nif (!(req->flags & MDP_BLUR))\r\nreturn;\r\nif (!(downscale_x_table == MDP_DOWNSCALE_BLUR &&\r\ndownscale_y_table == MDP_DOWNSCALE_BLUR)) {\r\nload_scale_table(mdp, mdp_gaussian_blur_table, 128);\r\ndownscale_x_table = MDP_DOWNSCALE_BLUR;\r\ndownscale_y_table = MDP_DOWNSCALE_BLUR;\r\n}\r\nregs->op |= (PPP_OP_SCALE_Y_ON | PPP_OP_SCALE_X_ON);\r\n}\r\nstatic void get_len(struct mdp_img *img, struct mdp_rect *rect, uint32_t bpp,\r\nuint32_t *len0, uint32_t *len1)\r\n{\r\n*len0 = IMG_LEN(rect->h, img->width, rect->w, bpp);\r\nif (IS_PSEUDOPLNR(img->format))\r\n*len1 = *len0/Y_TO_CRCB_RATIO(img->format);\r\nelse\r\n*len1 = 0;\r\n}\r\nstatic int valid_src_dst(unsigned long src_start, unsigned long src_len,\r\nunsigned long dst_start, unsigned long dst_len,\r\nstruct mdp_blit_req *req, struct mdp_regs *regs)\r\n{\r\nunsigned long src_min_ok = src_start;\r\nunsigned long src_max_ok = src_start + src_len;\r\nunsigned long dst_min_ok = dst_start;\r\nunsigned long dst_max_ok = dst_start + dst_len;\r\nuint32_t src0_len, src1_len, dst0_len, dst1_len;\r\nget_len(&req->src, &req->src_rect, regs->src_bpp, &src0_len,\r\n&src1_len);\r\nget_len(&req->dst, &req->dst_rect, regs->dst_bpp, &dst0_len,\r\n&dst1_len);\r\nif (regs->src0 < src_min_ok || regs->src0 > src_max_ok ||\r\nregs->src0 + src0_len > src_max_ok) {\r\nDLOG("invalid_src %x %x %lx %lx\n", regs->src0,\r\nsrc0_len, src_min_ok, src_max_ok);\r\nreturn 0;\r\n}\r\nif (regs->src_cfg & PPP_SRC_PLANE_PSEUDOPLNR) {\r\nif (regs->src1 < src_min_ok || regs->src1 > src_max_ok ||\r\nregs->src1 + src1_len > src_max_ok) {\r\nDLOG("invalid_src1");\r\nreturn 0;\r\n}\r\n}\r\nif (regs->dst0 < dst_min_ok || regs->dst0 > dst_max_ok ||\r\nregs->dst0 + dst0_len > dst_max_ok) {\r\nDLOG("invalid_dst");\r\nreturn 0;\r\n}\r\nif (regs->dst_cfg & PPP_SRC_PLANE_PSEUDOPLNR) {\r\nif (regs->dst1 < dst_min_ok || regs->dst1 > dst_max_ok ||\r\nregs->dst1 + dst1_len > dst_max_ok) {\r\nDLOG("invalid_dst1");\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void flush_imgs(struct mdp_blit_req *req, struct mdp_regs *regs,\r\nstruct file *src_file, struct file *dst_file)\r\n{\r\n}\r\nstatic void get_chroma_addr(struct mdp_img *img, struct mdp_rect *rect,\r\nuint32_t base, uint32_t bpp, uint32_t cfg,\r\nuint32_t *addr, uint32_t *ystride)\r\n{\r\nuint32_t compress_v = Y_TO_CRCB_RATIO(img->format);\r\nuint32_t compress_h = 2;\r\nuint32_t offset;\r\nif (IS_PSEUDOPLNR(img->format)) {\r\noffset = (rect->x / compress_h) * compress_h;\r\noffset += rect->y == 0 ? 0 :\r\n((rect->y + 1) / compress_v) * img->width;\r\n*addr = base + (img->width * img->height * bpp);\r\n*addr += offset * bpp;\r\n*ystride |= *ystride << 16;\r\n} else {\r\n*addr = 0;\r\n}\r\n}\r\nstatic int send_blit(const struct mdp_info *mdp, struct mdp_blit_req *req,\r\nstruct mdp_regs *regs, struct file *src_file,\r\nstruct file *dst_file)\r\n{\r\nmdp_writel(mdp, 1, 0x060);\r\nmdp_writel(mdp, regs->src_rect, PPP_ADDR_SRC_ROI);\r\nmdp_writel(mdp, regs->src0, PPP_ADDR_SRC0);\r\nmdp_writel(mdp, regs->src1, PPP_ADDR_SRC1);\r\nmdp_writel(mdp, regs->src_ystride, PPP_ADDR_SRC_YSTRIDE);\r\nmdp_writel(mdp, regs->src_cfg, PPP_ADDR_SRC_CFG);\r\nmdp_writel(mdp, regs->src_pack, PPP_ADDR_SRC_PACK_PATTERN);\r\nmdp_writel(mdp, regs->op, PPP_ADDR_OPERATION);\r\nmdp_writel(mdp, regs->phasex_init, PPP_ADDR_PHASEX_INIT);\r\nmdp_writel(mdp, regs->phasey_init, PPP_ADDR_PHASEY_INIT);\r\nmdp_writel(mdp, regs->phasex_step, PPP_ADDR_PHASEX_STEP);\r\nmdp_writel(mdp, regs->phasey_step, PPP_ADDR_PHASEY_STEP);\r\nmdp_writel(mdp, (req->alpha << 24) | (req->transp_mask & 0xffffff),\r\nPPP_ADDR_ALPHA_TRANSP);\r\nmdp_writel(mdp, regs->dst_cfg, PPP_ADDR_DST_CFG);\r\nmdp_writel(mdp, regs->dst_pack, PPP_ADDR_DST_PACK_PATTERN);\r\nmdp_writel(mdp, regs->dst_rect, PPP_ADDR_DST_ROI);\r\nmdp_writel(mdp, regs->dst0, PPP_ADDR_DST0);\r\nmdp_writel(mdp, regs->dst1, PPP_ADDR_DST1);\r\nmdp_writel(mdp, regs->dst_ystride, PPP_ADDR_DST_YSTRIDE);\r\nmdp_writel(mdp, regs->edge, PPP_ADDR_EDGE);\r\nif (regs->op & PPP_OP_BLEND_ON) {\r\nmdp_writel(mdp, regs->dst0, PPP_ADDR_BG0);\r\nmdp_writel(mdp, regs->dst1, PPP_ADDR_BG1);\r\nmdp_writel(mdp, regs->dst_ystride, PPP_ADDR_BG_YSTRIDE);\r\nmdp_writel(mdp, src_img_cfg[req->dst.format], PPP_ADDR_BG_CFG);\r\nmdp_writel(mdp, pack_pattern[req->dst.format],\r\nPPP_ADDR_BG_PACK_PATTERN);\r\n}\r\nflush_imgs(req, regs, src_file, dst_file);\r\nmdp_writel(mdp, 0x1000, MDP_DISPLAY0_START);\r\nreturn 0;\r\n}\r\nint mdp_ppp_blit(const struct mdp_info *mdp, struct mdp_blit_req *req,\r\nstruct file *src_file, unsigned long src_start, unsigned long src_len,\r\nstruct file *dst_file, unsigned long dst_start, unsigned long dst_len)\r\n{\r\nstruct mdp_regs regs = {0};\r\nif (unlikely(req->src.format >= MDP_IMGTYPE_LIMIT ||\r\nreq->dst.format >= MDP_IMGTYPE_LIMIT)) {\r\nprintk(KERN_ERR "mpd_ppp: img is of wrong format\n");\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(req->src_rect.x > req->src.width ||\r\nreq->src_rect.y > req->src.height ||\r\nreq->dst_rect.x > req->dst.width ||\r\nreq->dst_rect.y > req->dst.height)) {\r\nprintk(KERN_ERR "mpd_ppp: img rect is outside of img!\n");\r\nreturn -EINVAL;\r\n}\r\nregs.src_cfg = src_img_cfg[req->src.format];\r\nregs.src_cfg |= (req->src_rect.x & 0x1) ? PPP_SRC_BPP_ROI_ODD_X : 0;\r\nregs.src_cfg |= (req->src_rect.y & 0x1) ? PPP_SRC_BPP_ROI_ODD_Y : 0;\r\nregs.src_rect = (req->src_rect.h << 16) | req->src_rect.w;\r\nregs.src_pack = pack_pattern[req->src.format];\r\nregs.dst_cfg = dst_img_cfg[req->dst.format] | PPP_DST_OUT_SEL_AXI;\r\nregs.dst_rect = (req->dst_rect.h << 16) | req->dst_rect.w;\r\nregs.dst_pack = pack_pattern[req->dst.format];\r\nregs.src_bpp = bytes_per_pixel[req->src.format];\r\nregs.src0 = src_start + req->src.offset;\r\nregs.src_ystride = req->src.width * regs.src_bpp;\r\nget_chroma_addr(&req->src, &req->src_rect, regs.src0, regs.src_bpp,\r\nregs.src_cfg, &regs.src1, &regs.src_ystride);\r\nregs.src0 += (req->src_rect.x + (req->src_rect.y * req->src.width)) *\r\nregs.src_bpp;\r\nregs.dst_bpp = bytes_per_pixel[req->dst.format];\r\nregs.dst0 = dst_start + req->dst.offset;\r\nregs.dst_ystride = req->dst.width * regs.dst_bpp;\r\nget_chroma_addr(&req->dst, &req->dst_rect, regs.dst0, regs.dst_bpp,\r\nregs.dst_cfg, &regs.dst1, &regs.dst_ystride);\r\nregs.dst0 += (req->dst_rect.x + (req->dst_rect.y * req->dst.width)) *\r\nregs.dst_bpp;\r\nif (!valid_src_dst(src_start, src_len, dst_start, dst_len, req,\r\n&regs)) {\r\nprintk(KERN_ERR "mpd_ppp: final src or dst location is "\r\n"invalid, are you trying to make an image too large "\r\n"or to place it outside the screen?\n");\r\nreturn -EINVAL;\r\n}\r\nregs.op = 0;\r\nblit_rotate(req, &regs);\r\nblit_convert(req, &regs);\r\nif (req->flags & MDP_DITHER)\r\nregs.op |= PPP_OP_DITHER_EN;\r\nblit_blend(req, &regs);\r\nif (blit_scale(mdp, req, &regs)) {\r\nprintk(KERN_ERR "mpd_ppp: error computing scale for img.\n");\r\nreturn -EINVAL;\r\n}\r\nblit_blur(mdp, req, &regs);\r\nregs.op |= dst_op_chroma[req->dst.format] |\r\nsrc_op_chroma[req->src.format];\r\nif (unlikely(req->src.format == MDP_YCRYCB_H2V1)) {\r\nreq->src_rect.x = req->src_rect.x & (~0x1);\r\nreq->src_rect.w = req->src_rect.w & (~0x1);\r\nreq->dst_rect.x = req->dst_rect.x & (~0x1);\r\nreq->dst_rect.w = req->dst_rect.w & (~0x1);\r\n}\r\nif (get_edge_cond(req, &regs))\r\nreturn -EINVAL;\r\nsend_blit(mdp, req, &regs, src_file, dst_file);\r\nreturn 0;\r\n}
