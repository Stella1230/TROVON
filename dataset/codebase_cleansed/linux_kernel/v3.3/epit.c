static inline void epit_irq_disable(void)\r\n{\r\nu32 val;\r\nval = __raw_readl(timer_base + EPITCR);\r\nval &= ~EPITCR_OCIEN;\r\n__raw_writel(val, timer_base + EPITCR);\r\n}\r\nstatic inline void epit_irq_enable(void)\r\n{\r\nu32 val;\r\nval = __raw_readl(timer_base + EPITCR);\r\nval |= EPITCR_OCIEN;\r\n__raw_writel(val, timer_base + EPITCR);\r\n}\r\nstatic void epit_irq_acknowledge(void)\r\n{\r\n__raw_writel(EPITSR_OCIF, timer_base + EPITSR);\r\n}\r\nstatic int __init epit_clocksource_init(struct clk *timer_clk)\r\n{\r\nunsigned int c = clk_get_rate(timer_clk);\r\nreturn clocksource_mmio_init(timer_base + EPITCNR, "epit", c, 200, 32,\r\nclocksource_mmio_readl_down);\r\n}\r\nstatic int epit_set_next_event(unsigned long evt,\r\nstruct clock_event_device *unused)\r\n{\r\nunsigned long tcmp;\r\ntcmp = __raw_readl(timer_base + EPITCNR);\r\n__raw_writel(tcmp - evt, timer_base + EPITCMPR);\r\nreturn 0;\r\n}\r\nstatic void epit_set_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *evt)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nepit_irq_disable();\r\nif (mode != clockevent_mode) {\r\nepit_irq_acknowledge();\r\n}\r\nclockevent_mode = mode;\r\nlocal_irq_restore(flags);\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\nprintk(KERN_ERR "epit_set_mode: Periodic mode is not "\r\n"supported for i.MX EPIT\n");\r\nbreak;\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\nlocal_irq_save(flags);\r\nepit_irq_enable();\r\nlocal_irq_restore(flags);\r\nbreak;\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\ncase CLOCK_EVT_MODE_UNUSED:\r\ncase CLOCK_EVT_MODE_RESUME:\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t epit_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = &clockevent_epit;\r\nepit_irq_acknowledge();\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init epit_clockevent_init(struct clk *timer_clk)\r\n{\r\nunsigned int c = clk_get_rate(timer_clk);\r\nclockevent_epit.mult = div_sc(c, NSEC_PER_SEC,\r\nclockevent_epit.shift);\r\nclockevent_epit.max_delta_ns =\r\nclockevent_delta2ns(0xfffffffe, &clockevent_epit);\r\nclockevent_epit.min_delta_ns =\r\nclockevent_delta2ns(0x800, &clockevent_epit);\r\nclockevent_epit.cpumask = cpumask_of(0);\r\nclockevents_register_device(&clockevent_epit);\r\nreturn 0;\r\n}\r\nvoid __init epit_timer_init(struct clk *timer_clk, void __iomem *base, int irq)\r\n{\r\nclk_enable(timer_clk);\r\ntimer_base = base;\r\n__raw_writel(0x0, timer_base + EPITCR);\r\n__raw_writel(0xffffffff, timer_base + EPITLR);\r\n__raw_writel(EPITCR_EN | EPITCR_CLKSRC_REF_HIGH | EPITCR_WAITEN,\r\ntimer_base + EPITCR);\r\nepit_clocksource_init(timer_clk);\r\nepit_clockevent_init(timer_clk);\r\nsetup_irq(irq, &epit_timer_irq);\r\n}
