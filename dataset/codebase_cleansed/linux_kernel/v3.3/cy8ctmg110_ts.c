static void cy8ctmg110_power(struct cy8ctmg110 *ts, bool poweron)\r\n{\r\nif (ts->reset_pin)\r\ngpio_direction_output(ts->reset_pin, 1 - poweron);\r\n}\r\nstatic int cy8ctmg110_write_regs(struct cy8ctmg110 *tsc, unsigned char reg,\r\nunsigned char len, unsigned char *value)\r\n{\r\nstruct i2c_client *client = tsc->client;\r\nint ret;\r\nunsigned char i2c_data[6];\r\nBUG_ON(len > 5);\r\ni2c_data[0] = reg;\r\nmemcpy(i2c_data + 1, value, len);\r\nret = i2c_master_send(client, i2c_data, len + 1);\r\nif (ret != len + 1) {\r\ndev_err(&client->dev, "i2c write data cmd failed\n");\r\nreturn ret < 0 ? ret : -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cy8ctmg110_read_regs(struct cy8ctmg110 *tsc,\r\nunsigned char *data, unsigned char len, unsigned char cmd)\r\n{\r\nstruct i2c_client *client = tsc->client;\r\nint ret;\r\nstruct i2c_msg msg[2] = {\r\n{ client->addr, 0, 1, &cmd },\r\n{ client->addr, I2C_M_RD, len, data }\r\n};\r\nret = i2c_transfer(client->adapter, msg, 2);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int cy8ctmg110_touch_pos(struct cy8ctmg110 *tsc)\r\n{\r\nstruct input_dev *input = tsc->input;\r\nunsigned char reg_p[CY8CTMG110_REG_MAX];\r\nint x, y;\r\nmemset(reg_p, 0, CY8CTMG110_REG_MAX);\r\nif (cy8ctmg110_read_regs(tsc, reg_p, 9, CY8CTMG110_TOUCH_X1) != 0)\r\nreturn -EIO;\r\ny = reg_p[2] << 8 | reg_p[3];\r\nx = reg_p[0] << 8 | reg_p[1];\r\nif (reg_p[8] == 0) {\r\ninput_report_key(input, BTN_TOUCH, 0);\r\n} else {\r\ninput_report_key(input, BTN_TOUCH, 1);\r\ninput_report_abs(input, ABS_X, x);\r\ninput_report_abs(input, ABS_Y, y);\r\n}\r\ninput_sync(input);\r\nreturn 0;\r\n}\r\nstatic int cy8ctmg110_set_sleepmode(struct cy8ctmg110 *ts, bool sleep)\r\n{\r\nunsigned char reg_p[3];\r\nif (sleep) {\r\nreg_p[0] = 0x00;\r\nreg_p[1] = 0xff;\r\nreg_p[2] = 5;\r\n} else {\r\nreg_p[0] = 0x10;\r\nreg_p[1] = 0xff;\r\nreg_p[2] = 0;\r\n}\r\nreturn cy8ctmg110_write_regs(ts, CY8CTMG110_TOUCH_WAKEUP_TIME, 3, reg_p);\r\n}\r\nstatic irqreturn_t cy8ctmg110_irq_thread(int irq, void *dev_id)\r\n{\r\nstruct cy8ctmg110 *tsc = dev_id;\r\ncy8ctmg110_touch_pos(tsc);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit cy8ctmg110_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct cy8ctmg110_pdata *pdata = client->dev.platform_data;\r\nstruct cy8ctmg110 *ts;\r\nstruct input_dev *input_dev;\r\nint err;\r\nif (pdata == NULL) {\r\ndev_err(&client->dev, "no pdata\n");\r\nreturn -ENODEV;\r\n}\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_WORD_DATA))\r\nreturn -EIO;\r\nts = kzalloc(sizeof(struct cy8ctmg110), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!ts || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nts->client = client;\r\nts->input = input_dev;\r\nts->reset_pin = pdata->reset_pin;\r\nts->irq_pin = pdata->irq_pin;\r\nsnprintf(ts->phys, sizeof(ts->phys),\r\n"%s/input0", dev_name(&client->dev));\r\ninput_dev->name = CY8CTMG110_DRIVER_NAME " Touchscreen";\r\ninput_dev->phys = ts->phys;\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->dev.parent = &client->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(input_dev, ABS_X,\r\nCY8CTMG110_X_MIN, CY8CTMG110_X_MAX, 4, 0);\r\ninput_set_abs_params(input_dev, ABS_Y,\r\nCY8CTMG110_Y_MIN, CY8CTMG110_Y_MAX, 4, 0);\r\nif (ts->reset_pin) {\r\nerr = gpio_request(ts->reset_pin, NULL);\r\nif (err) {\r\ndev_err(&client->dev,\r\n"Unable to request GPIO pin %d.\n",\r\nts->reset_pin);\r\ngoto err_free_mem;\r\n}\r\n}\r\ncy8ctmg110_power(ts, true);\r\ncy8ctmg110_set_sleepmode(ts, false);\r\nerr = gpio_request(ts->irq_pin, "touch_irq_key");\r\nif (err < 0) {\r\ndev_err(&client->dev,\r\n"Failed to request GPIO %d, error %d\n",\r\nts->irq_pin, err);\r\ngoto err_shutoff_device;\r\n}\r\nerr = gpio_direction_input(ts->irq_pin);\r\nif (err < 0) {\r\ndev_err(&client->dev,\r\n"Failed to configure input direction for GPIO %d, error %d\n",\r\nts->irq_pin, err);\r\ngoto err_free_irq_gpio;\r\n}\r\nclient->irq = gpio_to_irq(ts->irq_pin);\r\nif (client->irq < 0) {\r\nerr = client->irq;\r\ndev_err(&client->dev,\r\n"Unable to get irq number for GPIO %d, error %d\n",\r\nts->irq_pin, err);\r\ngoto err_free_irq_gpio;\r\n}\r\nerr = request_threaded_irq(client->irq, NULL, cy8ctmg110_irq_thread,\r\nIRQF_TRIGGER_RISING, "touch_reset_key", ts);\r\nif (err < 0) {\r\ndev_err(&client->dev,\r\n"irq %d busy? error %d\n", client->irq, err);\r\ngoto err_free_irq_gpio;\r\n}\r\nerr = input_register_device(input_dev);\r\nif (err)\r\ngoto err_free_irq;\r\ni2c_set_clientdata(client, ts);\r\ndevice_init_wakeup(&client->dev, 1);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(client->irq, ts);\r\nerr_free_irq_gpio:\r\ngpio_free(ts->irq_pin);\r\nerr_shutoff_device:\r\ncy8ctmg110_set_sleepmode(ts, true);\r\ncy8ctmg110_power(ts, false);\r\nif (ts->reset_pin)\r\ngpio_free(ts->reset_pin);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(ts);\r\nreturn err;\r\n}\r\nstatic int cy8ctmg110_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct cy8ctmg110 *ts = i2c_get_clientdata(client);\r\nif (device_may_wakeup(&client->dev))\r\nenable_irq_wake(client->irq);\r\nelse {\r\ncy8ctmg110_set_sleepmode(ts, true);\r\ncy8ctmg110_power(ts, false);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cy8ctmg110_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct cy8ctmg110 *ts = i2c_get_clientdata(client);\r\nif (device_may_wakeup(&client->dev))\r\ndisable_irq_wake(client->irq);\r\nelse {\r\ncy8ctmg110_power(ts, true);\r\ncy8ctmg110_set_sleepmode(ts, false);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devexit cy8ctmg110_remove(struct i2c_client *client)\r\n{\r\nstruct cy8ctmg110 *ts = i2c_get_clientdata(client);\r\ncy8ctmg110_set_sleepmode(ts, true);\r\ncy8ctmg110_power(ts, false);\r\nfree_irq(client->irq, ts);\r\ninput_unregister_device(ts->input);\r\ngpio_free(ts->irq_pin);\r\nif (ts->reset_pin)\r\ngpio_free(ts->reset_pin);\r\nkfree(ts);\r\nreturn 0;\r\n}\r\nstatic int __init cy8ctmg110_init(void)\r\n{\r\nreturn i2c_add_driver(&cy8ctmg110_driver);\r\n}\r\nstatic void __exit cy8ctmg110_exit(void)\r\n{\r\ni2c_del_driver(&cy8ctmg110_driver);\r\n}
