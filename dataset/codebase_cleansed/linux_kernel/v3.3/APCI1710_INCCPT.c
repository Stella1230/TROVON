int i_APCI1710_InsnConfigINCCPT(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ui_ConfigType;\r\nint i_ReturnValue = 0;\r\nui_ConfigType = CR_CHAN(insn->chanspec);\r\nprintk("\nINC_CPT");\r\ndevpriv->tsk_Current = current;\r\nswitch (ui_ConfigType) {\r\ncase APCI1710_INCCPT_INITCOUNTER:\r\ni_ReturnValue = i_APCI1710_InitCounter(dev,\r\nCR_AREF(insn->chanspec),\r\n(unsigned char) data[0],\r\n(unsigned char) data[1],\r\n(unsigned char) data[2], (unsigned char) data[3], (unsigned char) data[4]);\r\nbreak;\r\ncase APCI1710_INCCPT_COUNTERAUTOTEST:\r\ni_ReturnValue = i_APCI1710_CounterAutoTest(dev,\r\n(unsigned char *) &data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_INITINDEX:\r\ni_ReturnValue = i_APCI1710_InitIndex(dev,\r\nCR_AREF(insn->chanspec),\r\n(unsigned char) data[0],\r\n(unsigned char) data[1], (unsigned char) data[2], (unsigned char) data[3]);\r\nbreak;\r\ncase APCI1710_INCCPT_INITREFERENCE:\r\ni_ReturnValue = i_APCI1710_InitReference(dev,\r\nCR_AREF(insn->chanspec), (unsigned char) data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_INITEXTERNALSTROBE:\r\ni_ReturnValue = i_APCI1710_InitExternalStrobe(dev,\r\nCR_AREF(insn->chanspec),\r\n(unsigned char) data[0], (unsigned char) data[1]);\r\nbreak;\r\ncase APCI1710_INCCPT_INITCOMPARELOGIC:\r\ni_ReturnValue = i_APCI1710_InitCompareLogic(dev,\r\nCR_AREF(insn->chanspec), (unsigned int) data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_INITFREQUENCYMEASUREMENT:\r\ni_ReturnValue = i_APCI1710_InitFrequencyMeasurement(dev,\r\nCR_AREF(insn->chanspec),\r\n(unsigned char) data[0],\r\n(unsigned char) data[1], (unsigned int) data[2], (unsigned int *) &data[0]);\r\nbreak;\r\ndefault:\r\nprintk("Insn Config : Config Parameter Wrong\n");\r\n}\r\nif (i_ReturnValue >= 0)\r\ni_ReturnValue = insn->n;\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_InitCounter(struct comedi_device *dev,\r\nunsigned char b_ModulNbr,\r\nunsigned char b_CounterRange,\r\nunsigned char b_FirstCounterModus,\r\nunsigned char b_FirstCounterOption,\r\nunsigned char b_SecondCounterModus, unsigned char b_SecondCounterOption)\r\n{\r\nint i_ReturnValue = 0;\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] & 0xFFFF0000UL) ==\r\nAPCI1710_INCREMENTAL_COUNTER) {\r\nif (b_CounterRange == APCI1710_16BIT_COUNTER\r\n|| b_CounterRange == APCI1710_32BIT_COUNTER) {\r\nif (b_FirstCounterModus == APCI1710_QUADRUPLE_MODE ||\r\nb_FirstCounterModus == APCI1710_DOUBLE_MODE ||\r\nb_FirstCounterModus == APCI1710_SIMPLE_MODE ||\r\nb_FirstCounterModus == APCI1710_DIRECT_MODE) {\r\nif ((b_FirstCounterModus == APCI1710_DIRECT_MODE\r\n&& (b_FirstCounterOption ==\r\nAPCI1710_INCREMENT\r\n|| b_FirstCounterOption\r\n== APCI1710_DECREMENT))\r\n|| (b_FirstCounterModus !=\r\nAPCI1710_DIRECT_MODE\r\n&& (b_FirstCounterOption ==\r\nAPCI1710_HYSTERESIS_ON\r\n|| b_FirstCounterOption\r\n==\r\nAPCI1710_HYSTERESIS_OFF)))\r\n{\r\nif (b_CounterRange ==\r\nAPCI1710_16BIT_COUNTER) {\r\nif ((b_FirstCounterModus !=\r\nAPCI1710_DIRECT_MODE\r\n&&\r\n(b_SecondCounterModus\r\n==\r\nAPCI1710_QUADRUPLE_MODE\r\n||\r\nb_SecondCounterModus\r\n==\r\nAPCI1710_DOUBLE_MODE\r\n||\r\nb_SecondCounterModus\r\n==\r\nAPCI1710_SIMPLE_MODE))\r\n|| (b_FirstCounterModus\r\n==\r\nAPCI1710_DIRECT_MODE\r\n&&\r\nb_SecondCounterModus\r\n==\r\nAPCI1710_DIRECT_MODE))\r\n{\r\nif ((b_SecondCounterModus == APCI1710_DIRECT_MODE && (b_SecondCounterOption == APCI1710_INCREMENT || b_SecondCounterOption == APCI1710_DECREMENT)) || (b_SecondCounterModus != APCI1710_DIRECT_MODE && (b_SecondCounterOption == APCI1710_HYSTERESIS_ON || b_SecondCounterOption == APCI1710_HYSTERESIS_OFF))) {\r\ni_ReturnValue =\r\n0;\r\n} else {\r\nDPRINTK("The selected second counter operating option is wrong\n");\r\ni_ReturnValue =\r\n-7;\r\n}\r\n} else {\r\nDPRINTK("The selected second counter operating mode is wrong\n");\r\ni_ReturnValue = -6;\r\n}\r\n}\r\n} else {\r\nDPRINTK("The selected first counter operating option is wrong\n");\r\ni_ReturnValue = -5;\r\n}\r\n} else {\r\nDPRINTK("The selected first counter operating mode is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("The selected counter range is wrong\n");\r\ni_ReturnValue = -3;\r\n}\r\nif (i_ReturnValue == 0) {\r\nif (b_CounterRange == APCI1710_32BIT_COUNTER) {\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister1 = b_CounterRange |\r\nb_FirstCounterModus |\r\nb_FirstCounterOption;\r\n} else {\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister1 = b_CounterRange |\r\n(b_FirstCounterModus & 0x5) |\r\n(b_FirstCounterOption & 0x20) |\r\n(b_SecondCounterModus & 0xA) |\r\n(b_SecondCounterOption & 0x40);\r\nif (b_FirstCounterModus == APCI1710_DIRECT_MODE) {\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister1 = devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister1 |\r\nAPCI1710_DIRECT_MODE;\r\n}\r\n}\r\noutl(devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ndw_ModeRegister1_2_3_4,\r\ndevpriv->s_BoardInfos.\r\nui_Address + 20 + (64 * b_ModulNbr));\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_InitFlag.b_CounterInit = 1;\r\n}\r\n} else {\r\nDPRINTK("The module is not a counter module\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_CounterAutoTest(struct comedi_device *dev, unsigned char *pb_TestStatus)\r\n{\r\nunsigned char b_ModulCpt = 0;\r\nint i_ReturnValue = 0;\r\nunsigned int dw_LathchValue;\r\n*pb_TestStatus = 0;\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[0] & 0xFFFF0000UL) ==\r\nAPCI1710_INCREMENTAL_COUNTER\r\n|| (devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[1] & 0xFFFF0000UL) ==\r\nAPCI1710_INCREMENTAL_COUNTER\r\n|| (devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[2] & 0xFFFF0000UL) ==\r\nAPCI1710_INCREMENTAL_COUNTER\r\n|| (devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[3] & 0xFFFF0000UL) ==\r\nAPCI1710_INCREMENTAL_COUNTER) {\r\nfor (b_ModulCpt = 0; b_ModulCpt < 4; b_ModulCpt++) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulCpt] &\r\n0xFFFF0000UL) ==\r\nAPCI1710_INCREMENTAL_COUNTER) {\r\noutl(3, devpriv->s_BoardInfos.\r\nui_Address + 16 + (64 * b_ModulCpt));\r\noutl(1, devpriv->s_BoardInfos.\r\nui_Address + (64 * b_ModulCpt));\r\ndw_LathchValue = inl(devpriv->s_BoardInfos.\r\nui_Address + 4 + (64 * b_ModulCpt));\r\nif ((dw_LathchValue & 0xFF) !=\r\n((dw_LathchValue >> 8) & 0xFF)\r\n&& (dw_LathchValue & 0xFF) !=\r\n((dw_LathchValue >> 16) & 0xFF)\r\n&& (dw_LathchValue & 0xFF) !=\r\n((dw_LathchValue >> 24) & 0xFF)) {\r\n*pb_TestStatus =\r\n*pb_TestStatus | (1 <<\r\nb_ModulCpt);\r\n}\r\noutl(0, devpriv->s_BoardInfos.\r\nui_Address + 16 + (64 * b_ModulCpt));\r\n}\r\n}\r\n} else {\r\nDPRINTK("No counter module found\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_InitIndex(struct comedi_device *dev,\r\nunsigned char b_ModulNbr,\r\nunsigned char b_ReferenceAction,\r\nunsigned char b_IndexOperation, unsigned char b_AutoMode, unsigned char b_InterruptEnable)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (b_ReferenceAction == APCI1710_ENABLE ||\r\nb_ReferenceAction == APCI1710_DISABLE) {\r\nif (b_IndexOperation ==\r\nAPCI1710_HIGH_EDGE_LATCH_COUNTER\r\n|| b_IndexOperation ==\r\nAPCI1710_LOW_EDGE_LATCH_COUNTER\r\n|| b_IndexOperation ==\r\nAPCI1710_HIGH_EDGE_CLEAR_COUNTER\r\n|| b_IndexOperation ==\r\nAPCI1710_LOW_EDGE_CLEAR_COUNTER\r\n|| b_IndexOperation ==\r\nAPCI1710_HIGH_EDGE_LATCH_AND_CLEAR_COUNTER\r\n|| b_IndexOperation ==\r\nAPCI1710_LOW_EDGE_LATCH_AND_CLEAR_COUNTER)\r\n{\r\nif (b_AutoMode == APCI1710_ENABLE ||\r\nb_AutoMode == APCI1710_DISABLE)\r\n{\r\nif (b_InterruptEnable ==\r\nAPCI1710_ENABLE\r\n|| b_InterruptEnable ==\r\nAPCI1710_DISABLE) {\r\nif (b_ReferenceAction ==\r\nAPCI1710_ENABLE)\r\n{\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2\r\n|\r\nAPCI1710_ENABLE_INDEX_ACTION;\r\n} else {\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2\r\n&\r\nAPCI1710_DISABLE_INDEX_ACTION;\r\n}\r\nif (b_IndexOperation ==\r\nAPCI1710_LOW_EDGE_LATCH_COUNTER\r\n||\r\nb_IndexOperation\r\n==\r\nAPCI1710_LOW_EDGE_CLEAR_COUNTER\r\n||\r\nb_IndexOperation\r\n==\r\nAPCI1710_LOW_EDGE_LATCH_AND_CLEAR_COUNTER)\r\n{\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n|\r\nAPCI1710_SET_LOW_INDEX_LEVEL;\r\n} else {\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n&\r\nAPCI1710_SET_HIGH_INDEX_LEVEL;\r\n}\r\nif (b_IndexOperation ==\r\nAPCI1710_HIGH_EDGE_LATCH_AND_CLEAR_COUNTER\r\n||\r\nb_IndexOperation\r\n==\r\nAPCI1710_LOW_EDGE_LATCH_AND_CLEAR_COUNTER)\r\n{\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n|\r\nAPCI1710_ENABLE_LATCH_AND_CLEAR;\r\n}\r\nelse {\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n&\r\nAPCI1710_DISABLE_LATCH_AND_CLEAR;\r\nif (b_IndexOperation == APCI1710_HIGH_EDGE_LATCH_COUNTER || b_IndexOperation == APCI1710_LOW_EDGE_LATCH_COUNTER) {\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2\r\n|\r\nAPCI1710_INDEX_LATCH_COUNTER;\r\n} else {\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2\r\n&\r\n(~APCI1710_INDEX_LATCH_COUNTER);\r\n}\r\n}\r\nif (b_AutoMode ==\r\nAPCI1710_DISABLE)\r\n{\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2\r\n|\r\nAPCI1710_INDEX_AUTO_MODE;\r\n} else {\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2\r\n&\r\n(~APCI1710_INDEX_AUTO_MODE);\r\n}\r\nif (b_InterruptEnable ==\r\nAPCI1710_ENABLE)\r\n{\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3\r\n|\r\nAPCI1710_ENABLE_INDEX_INT;\r\n} else {\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3\r\n&\r\nAPCI1710_DISABLE_INDEX_INT;\r\n}\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_InitFlag.\r\nb_IndexInit = 1;\r\n} else {\r\nDPRINTK("Interrupt parameter is wrong\n");\r\ni_ReturnValue = -7;\r\n}\r\n} else {\r\nDPRINTK("The auto mode parameter is wrong\n");\r\ni_ReturnValue = -6;\r\n}\r\n} else {\r\nDPRINTK("The index operating mode parameter is wrong\n");\r\ni_ReturnValue = -5;\r\n}\r\n} else {\r\nDPRINTK("The reference action parameter is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_InitReference(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char b_ReferenceLevel)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (b_ReferenceLevel == 0 || b_ReferenceLevel == 1) {\r\nif (b_ReferenceLevel == 1) {\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2 = devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2 |\r\nAPCI1710_REFERENCE_HIGH;\r\n} else {\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2 = devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2 &\r\nAPCI1710_REFERENCE_LOW;\r\n}\r\noutl(devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ndw_ModeRegister1_2_3_4,\r\ndevpriv->s_BoardInfos.ui_Address + 20 +\r\n(64 * b_ModulNbr));\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_InitFlag.b_ReferenceInit = 1;\r\n} else {\r\nDPRINTK("Reference level parameter is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_InitExternalStrobe(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char b_ExternalStrobe, unsigned char b_ExternalStrobeLevel)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (b_ExternalStrobe == 0 || b_ExternalStrobe == 1) {\r\nif ((b_ExternalStrobeLevel == APCI1710_HIGH) ||\r\n((b_ExternalStrobeLevel == APCI1710_LOW\r\n&& (devpriv->\r\ns_BoardInfos.\r\ndw_MolduleConfiguration\r\n[b_ModulNbr] &\r\n0xFFFF) >=\r\n0x3135))) {\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4 = (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4 & (0xFF -\r\n(0x10 << b_ExternalStrobe))) | ((b_ExternalStrobeLevel ^ 1) << (4 + b_ExternalStrobe));\r\n} else {\r\nDPRINTK("External strobe level parameter is wrong\n");\r\ni_ReturnValue = -5;\r\n}\r\n}\r\nelse {\r\nDPRINTK("External strobe selection is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_InitCompareLogic(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned int ui_CompareValue)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\noutl(ui_CompareValue, devpriv->s_BoardInfos.\r\nui_Address + 28 + (64 * b_ModulNbr));\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_InitFlag.b_CompareLogicInit = 1;\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_InitFrequencyMeasurement(struct comedi_device *dev,\r\nunsigned char b_ModulNbr,\r\nunsigned char b_PCIInputClock,\r\nunsigned char b_TimingUnity,\r\nunsigned int ul_TimingInterval, unsigned int *pul_RealTimingInterval)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int ul_TimerValue = 0;\r\ndouble d_RealTimingInterval;\r\nunsigned int dw_Status = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif ((b_PCIInputClock == APCI1710_30MHZ) ||\r\n(b_PCIInputClock == APCI1710_33MHZ) ||\r\n(b_PCIInputClock == APCI1710_40MHZ)) {\r\nif (b_TimingUnity <= 2) {\r\nif (((b_PCIInputClock == APCI1710_30MHZ)\r\n&& (b_TimingUnity == 0)\r\n&& (ul_TimingInterval >=\r\n266)\r\n&& (ul_TimingInterval <=\r\n8738133UL))\r\n|| ((b_PCIInputClock ==\r\nAPCI1710_30MHZ)\r\n&& (b_TimingUnity == 1)\r\n&& (ul_TimingInterval >=\r\n1)\r\n&& (ul_TimingInterval <=\r\n8738UL))\r\n|| ((b_PCIInputClock ==\r\nAPCI1710_30MHZ)\r\n&& (b_TimingUnity == 2)\r\n&& (ul_TimingInterval >=\r\n1)\r\n&& (ul_TimingInterval <=\r\n8UL))\r\n|| ((b_PCIInputClock ==\r\nAPCI1710_33MHZ)\r\n&& (b_TimingUnity == 0)\r\n&& (ul_TimingInterval >=\r\n242)\r\n&& (ul_TimingInterval <=\r\n7943757UL))\r\n|| ((b_PCIInputClock ==\r\nAPCI1710_33MHZ)\r\n&& (b_TimingUnity == 1)\r\n&& (ul_TimingInterval >=\r\n1)\r\n&& (ul_TimingInterval <=\r\n7943UL))\r\n|| ((b_PCIInputClock ==\r\nAPCI1710_33MHZ)\r\n&& (b_TimingUnity == 2)\r\n&& (ul_TimingInterval >=\r\n1)\r\n&& (ul_TimingInterval <=\r\n7UL))\r\n|| ((b_PCIInputClock ==\r\nAPCI1710_40MHZ)\r\n&& (b_TimingUnity == 0)\r\n&& (ul_TimingInterval >=\r\n200)\r\n&& (ul_TimingInterval <=\r\n6553500UL))\r\n|| ((b_PCIInputClock ==\r\nAPCI1710_40MHZ)\r\n&& (b_TimingUnity == 1)\r\n&& (ul_TimingInterval >=\r\n1)\r\n&& (ul_TimingInterval <=\r\n6553UL))\r\n|| ((b_PCIInputClock ==\r\nAPCI1710_40MHZ)\r\n&& (b_TimingUnity == 2)\r\n&& (ul_TimingInterval >=\r\n1)\r\n&& (ul_TimingInterval <=\r\n6UL))) {\r\nif (b_PCIInputClock ==\r\nAPCI1710_40MHZ) {\r\nif ((devpriv->s_BoardInfos.dw_MolduleConfiguration[b_ModulNbr] & 0xFFFF) >= 0x3135) {\r\ndw_Status =\r\ninl\r\n(devpriv->\r\ns_BoardInfos.\r\nui_Address\r\n+ 36 +\r\n(64 * b_ModulNbr));\r\nif ((dw_Status & 1) != 1) {\r\nDPRINTK("40MHz quartz not on board\n");\r\ni_ReturnValue\r\n=\r\n-7;\r\n}\r\n} else {\r\nDPRINTK("40MHz quartz not on board\n");\r\ni_ReturnValue =\r\n-7;\r\n}\r\n}\r\nif (i_ReturnValue == 0) {\r\nif ((devpriv->s_BoardInfos.dw_MolduleConfiguration[b_ModulNbr] & 0xFFFF) >= 0x3131) {\r\nif (b_PCIInputClock == APCI1710_40MHZ) {\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n|\r\nAPCI1710_ENABLE_40MHZ_FREQUENCY;\r\n}\r\nelse {\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n&\r\nAPCI1710_DISABLE_40MHZ_FREQUENCY;\r\n}\r\nfpu_begin();\r\nswitch (b_TimingUnity) {\r\ncase 0:\r\nul_TimerValue\r\n=\r\n(unsigned int)\r\n(ul_TimingInterval\r\n*\r\n(0.00025 * b_PCIInputClock));\r\nif ((double)((double)ul_TimingInterval * (0.00025 * (double)b_PCIInputClock)) >= ((double)((double)ul_TimerValue + 0.5))) {\r\nul_TimerValue\r\n=\r\nul_TimerValue\r\n+\r\n1;\r\n}\r\n*pul_RealTimingInterval\r\n=\r\n(unsigned int)\r\n(ul_TimerValue\r\n/\r\n(0.00025 * (double)b_PCIInputClock));\r\nd_RealTimingInterval\r\n=\r\n(double)\r\nul_TimerValue\r\n/\r\n(0.00025\r\n*\r\n(double)\r\nb_PCIInputClock);\r\nif ((double)((double)ul_TimerValue / (0.00025 * (double)b_PCIInputClock)) >= (double)((double)*pul_RealTimingInterval + 0.5)) {\r\n*pul_RealTimingInterval\r\n=\r\n*pul_RealTimingInterval\r\n+\r\n1;\r\n}\r\nul_TimingInterval\r\n=\r\nul_TimingInterval\r\n-\r\n1;\r\nul_TimerValue\r\n=\r\nul_TimerValue\r\n-\r\n2;\r\nbreak;\r\ncase 1:\r\nul_TimerValue\r\n=\r\n(unsigned int)\r\n(ul_TimingInterval\r\n*\r\n(0.25 * b_PCIInputClock));\r\nif ((double)((double)ul_TimingInterval * (0.25 * (double)b_PCIInputClock)) >= ((double)((double)ul_TimerValue + 0.5))) {\r\nul_TimerValue\r\n=\r\nul_TimerValue\r\n+\r\n1;\r\n}\r\n*pul_RealTimingInterval\r\n=\r\n(unsigned int)\r\n(ul_TimerValue\r\n/\r\n(0.25 * (double)b_PCIInputClock));\r\nd_RealTimingInterval\r\n=\r\n(double)\r\nul_TimerValue\r\n/\r\n(\r\n(double)\r\n0.25\r\n*\r\n(double)\r\nb_PCIInputClock);\r\nif ((double)((double)ul_TimerValue / (0.25 * (double)b_PCIInputClock)) >= (double)((double)*pul_RealTimingInterval + 0.5)) {\r\n*pul_RealTimingInterval\r\n=\r\n*pul_RealTimingInterval\r\n+\r\n1;\r\n}\r\nul_TimingInterval\r\n=\r\nul_TimingInterval\r\n-\r\n1;\r\nul_TimerValue\r\n=\r\nul_TimerValue\r\n-\r\n2;\r\nbreak;\r\ncase 2:\r\nul_TimerValue\r\n=\r\nul_TimingInterval\r\n*\r\n(250.0\r\n*\r\nb_PCIInputClock);\r\nif ((double)((double)ul_TimingInterval * (250.0 * (double)b_PCIInputClock)) >= ((double)((double)ul_TimerValue + 0.5))) {\r\nul_TimerValue\r\n=\r\nul_TimerValue\r\n+\r\n1;\r\n}\r\n*pul_RealTimingInterval\r\n=\r\n(unsigned int)\r\n(ul_TimerValue\r\n/\r\n(250.0 * (double)b_PCIInputClock));\r\nd_RealTimingInterval\r\n=\r\n(double)\r\nul_TimerValue\r\n/\r\n(250.0\r\n*\r\n(double)\r\nb_PCIInputClock);\r\nif ((double)((double)ul_TimerValue / (250.0 * (double)b_PCIInputClock)) >= (double)((double)*pul_RealTimingInterval + 0.5)) {\r\n*pul_RealTimingInterval\r\n=\r\n*pul_RealTimingInterval\r\n+\r\n1;\r\n}\r\nul_TimingInterval\r\n=\r\nul_TimingInterval\r\n-\r\n1;\r\nul_TimerValue\r\n=\r\nul_TimerValue\r\n-\r\n2;\r\nbreak;\r\n}\r\nfpu_end();\r\noutl(ul_TimerValue, devpriv->s_BoardInfos.ui_Address + 32 + (64 * b_ModulNbr));\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_InitFlag.\r\nb_FrequencyMeasurementInit\r\n= 1;\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue =\r\n-3;\r\n}\r\n}\r\n} else {\r\nDPRINTK("Base timing selection is wrong\n");\r\ni_ReturnValue = -6;\r\n}\r\n} else {\r\nDPRINTK("Timing unity selection is wrong\n");\r\ni_ReturnValue = -5;\r\n}\r\n} else {\r\nDPRINTK("The selected PCI input clock is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_InsnBitsINCCPT(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ui_BitsType;\r\nint i_ReturnValue = 0;\r\nui_BitsType = CR_CHAN(insn->chanspec);\r\ndevpriv->tsk_Current = current;\r\nswitch (ui_BitsType) {\r\ncase APCI1710_INCCPT_CLEARCOUNTERVALUE:\r\ni_ReturnValue = i_APCI1710_ClearCounterValue(dev,\r\n(unsigned char) CR_AREF(insn->chanspec));\r\nbreak;\r\ncase APCI1710_INCCPT_CLEARALLCOUNTERVALUE:\r\ni_ReturnValue = i_APCI1710_ClearAllCounterValue(dev);\r\nbreak;\r\ncase APCI1710_INCCPT_SETINPUTFILTER:\r\ni_ReturnValue = i_APCI1710_SetInputFilter(dev,\r\n(unsigned char) CR_AREF(insn->chanspec),\r\n(unsigned char) data[0], (unsigned char) data[1]);\r\nbreak;\r\ncase APCI1710_INCCPT_LATCHCOUNTER:\r\ni_ReturnValue = i_APCI1710_LatchCounter(dev,\r\n(unsigned char) CR_AREF(insn->chanspec), (unsigned char) data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_SETINDEXANDREFERENCESOURCE:\r\ni_ReturnValue = i_APCI1710_SetIndexAndReferenceSource(dev,\r\n(unsigned char) CR_AREF(insn->chanspec), (unsigned char) data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_SETDIGITALCHLON:\r\ni_ReturnValue = i_APCI1710_SetDigitalChlOn(dev,\r\n(unsigned char) CR_AREF(insn->chanspec));\r\nbreak;\r\ncase APCI1710_INCCPT_SETDIGITALCHLOFF:\r\ni_ReturnValue = i_APCI1710_SetDigitalChlOff(dev,\r\n(unsigned char) CR_AREF(insn->chanspec));\r\nbreak;\r\ndefault:\r\nprintk("Bits Config Parameter Wrong\n");\r\n}\r\nif (i_ReturnValue >= 0)\r\ni_ReturnValue = insn->n;\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_ClearCounterValue(struct comedi_device *dev, unsigned char b_ModulNbr)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\noutl(1, devpriv->s_BoardInfos.\r\nui_Address + 16 + (64 * b_ModulNbr));\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_ClearAllCounterValue(struct comedi_device *dev)\r\n{\r\nunsigned char b_ModulCpt = 0;\r\nint i_ReturnValue = 0;\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[0] & 0xFFFF0000UL) ==\r\nAPCI1710_INCREMENTAL_COUNTER\r\n|| (devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[1] & 0xFFFF0000UL) ==\r\nAPCI1710_INCREMENTAL_COUNTER\r\n|| (devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[2] & 0xFFFF0000UL) ==\r\nAPCI1710_INCREMENTAL_COUNTER\r\n|| (devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[3] & 0xFFFF0000UL) ==\r\nAPCI1710_INCREMENTAL_COUNTER) {\r\nfor (b_ModulCpt = 0; b_ModulCpt < 4; b_ModulCpt++) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulCpt] &\r\n0xFFFF0000UL) ==\r\nAPCI1710_INCREMENTAL_COUNTER) {\r\noutl(1, devpriv->s_BoardInfos.\r\nui_Address + 16 + (64 * b_ModulCpt));\r\n}\r\n}\r\n} else {\r\nDPRINTK("No counter module found\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_SetInputFilter(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char b_PCIInputClock, unsigned char b_Filter)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int dw_Status = 0;\r\nif (b_ModulNbr < 4) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] &\r\n0xFFFF0000UL) == APCI1710_INCREMENTAL_COUNTER) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] &\r\n0xFFFF) >= 0x3135) {\r\nif ((b_PCIInputClock == APCI1710_30MHZ) ||\r\n(b_PCIInputClock == APCI1710_33MHZ) ||\r\n(b_PCIInputClock == APCI1710_40MHZ)) {\r\nif (b_Filter < 16) {\r\nif (b_PCIInputClock ==\r\nAPCI1710_40MHZ) {\r\ndw_Status =\r\ninl(devpriv->\r\ns_BoardInfos.\r\nui_Address +\r\n36 +\r\n(64 * b_ModulNbr));\r\nif ((dw_Status & 1) !=\r\n1) {\r\nDPRINTK("40MHz quartz not on board\n");\r\ni_ReturnValue =\r\n-6;\r\n}\r\n}\r\nif (i_ReturnValue == 0) {\r\nif (b_PCIInputClock ==\r\nAPCI1710_40MHZ)\r\n{\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n|\r\nAPCI1710_ENABLE_40MHZ_FILTER;\r\n}\r\nelse {\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n&\r\nAPCI1710_DISABLE_40MHZ_FILTER;\r\n}\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3\r\n=\r\n(devpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3\r\n& 0x1F) |\r\n((b_Filter &\r\n0x7) <<\r\n5);\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n=\r\n(devpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4\r\n& 0xFE) |\r\n((b_Filter &\r\n0x8) >>\r\n3);\r\noutl(devpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ndw_ModeRegister1_2_3_4,\r\ndevpriv->\r\ns_BoardInfos.\r\nui_Address +\r\n20 +\r\n(64 * b_ModulNbr));\r\n}\r\n}\r\nelse {\r\nDPRINTK("The selected filter value is wrong\n");\r\ni_ReturnValue = -5;\r\n}\r\n}\r\nelse {\r\nDPRINTK("The selected PCI input clock is wrong\n");\r\ni_ReturnValue = 4;\r\n}\r\n} else {\r\nDPRINTK("The module is not a counter module\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The module is not a counter module\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_LatchCounter(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char b_LatchReg)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (b_LatchReg < 2) {\r\noutl(1 << (b_LatchReg * 4),\r\ndevpriv->s_BoardInfos.ui_Address +\r\n(64 * b_ModulNbr));\r\n} else {\r\nDPRINTK("The selected latch register parameter is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_SetIndexAndReferenceSource(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char b_SourceSelection)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] &\r\n0xFFFF0000UL) == APCI1710_INCREMENTAL_COUNTER) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] &\r\n0xFFFF) >= 0x3135) {\r\nif (b_SourceSelection == APCI1710_SOURCE_0 ||\r\nb_SourceSelection == APCI1710_SOURCE_1)\r\n{\r\nif (b_SourceSelection ==\r\nAPCI1710_SOURCE_1) {\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4 =\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4 |\r\nAPCI1710_INVERT_INDEX_RFERENCE;\r\n} else {\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4 =\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister4 &\r\nAPCI1710_DEFAULT_INDEX_RFERENCE;\r\n}\r\n}\r\nelse {\r\nDPRINTK("The source selection is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("The module is not a counter module\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The module is not a counter module\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_SetDigitalChlOn(struct comedi_device *dev, unsigned char b_ModulNbr)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3 = devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.b_ModeRegister3 | 0x10;\r\noutl(devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ndw_ModeRegister1_2_3_4, devpriv->s_BoardInfos.\r\nui_Address + 20 + (64 * b_ModulNbr));\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_SetDigitalChlOff(struct comedi_device *dev, unsigned char b_ModulNbr)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3 = devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.b_ModeRegister3 & 0xEF;\r\noutl(devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ndw_ModeRegister1_2_3_4, devpriv->s_BoardInfos.\r\nui_Address + 20 + (64 * b_ModulNbr));\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_InsnWriteINCCPT(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ui_WriteType;\r\nint i_ReturnValue = 0;\r\nui_WriteType = CR_CHAN(insn->chanspec);\r\ndevpriv->tsk_Current = current;\r\nswitch (ui_WriteType) {\r\ncase APCI1710_INCCPT_ENABLELATCHINTERRUPT:\r\ni_ReturnValue = i_APCI1710_EnableLatchInterrupt(dev,\r\n(unsigned char) CR_AREF(insn->chanspec));\r\nbreak;\r\ncase APCI1710_INCCPT_DISABLELATCHINTERRUPT:\r\ni_ReturnValue = i_APCI1710_DisableLatchInterrupt(dev,\r\n(unsigned char) CR_AREF(insn->chanspec));\r\nbreak;\r\ncase APCI1710_INCCPT_WRITE16BITCOUNTERVALUE:\r\ni_ReturnValue = i_APCI1710_Write16BitCounterValue(dev,\r\n(unsigned char) CR_AREF(insn->chanspec),\r\n(unsigned char) data[0], (unsigned int) data[1]);\r\nbreak;\r\ncase APCI1710_INCCPT_WRITE32BITCOUNTERVALUE:\r\ni_ReturnValue = i_APCI1710_Write32BitCounterValue(dev,\r\n(unsigned char) CR_AREF(insn->chanspec), (unsigned int) data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_ENABLEINDEX:\r\ni_APCI1710_EnableIndex(dev, (unsigned char) CR_AREF(insn->chanspec));\r\nbreak;\r\ncase APCI1710_INCCPT_DISABLEINDEX:\r\ni_ReturnValue = i_APCI1710_DisableIndex(dev,\r\n(unsigned char) CR_AREF(insn->chanspec));\r\nbreak;\r\ncase APCI1710_INCCPT_ENABLECOMPARELOGIC:\r\ni_ReturnValue = i_APCI1710_EnableCompareLogic(dev,\r\n(unsigned char) CR_AREF(insn->chanspec));\r\nbreak;\r\ncase APCI1710_INCCPT_DISABLECOMPARELOGIC:\r\ni_ReturnValue = i_APCI1710_DisableCompareLogic(dev,\r\n(unsigned char) CR_AREF(insn->chanspec));\r\nbreak;\r\ncase APCI1710_INCCPT_ENABLEFREQUENCYMEASUREMENT:\r\ni_ReturnValue = i_APCI1710_EnableFrequencyMeasurement(dev,\r\n(unsigned char) CR_AREF(insn->chanspec), (unsigned char) data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_DISABLEFREQUENCYMEASUREMENT:\r\ni_ReturnValue = i_APCI1710_DisableFrequencyMeasurement(dev,\r\n(unsigned char) CR_AREF(insn->chanspec));\r\nbreak;\r\ndefault:\r\nprintk("Write Config Parameter Wrong\n");\r\n}\r\nif (i_ReturnValue >= 0)\r\ni_ReturnValue = insn->n;\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_EnableLatchInterrupt(struct comedi_device *dev, unsigned char b_ModulNbr)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\ndevpriv->s_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2 = devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2 | APCI1710_ENABLE_LATCH_INT;\r\noutl(devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ndw_ModeRegister1_2_3_4, devpriv->s_BoardInfos.\r\nui_Address + 20 + (64 * b_ModulNbr));\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_DisableLatchInterrupt(struct comedi_device *dev, unsigned char b_ModulNbr)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\noutl(devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ndw_ModeRegister1_2_3_4 &\r\n((APCI1710_DISABLE_LATCH_INT << 8) | 0xFF),\r\ndevpriv->s_BoardInfos.ui_Address + 20 +\r\n(64 * b_ModulNbr));\r\nmdelay(1000);\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2 = devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2 & APCI1710_DISABLE_LATCH_INT;\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_Write16BitCounterValue(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char b_SelectedCounter, unsigned int ui_WriteValue)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (b_SelectedCounter < 2) {\r\noutl((unsigned int) ((unsigned int) (ui_WriteValue) << (16 *\r\nb_SelectedCounter)),\r\ndevpriv->s_BoardInfos.ui_Address + 8 +\r\n(b_SelectedCounter * 4) +\r\n(64 * b_ModulNbr));\r\n} else {\r\nDPRINTK("The selected 16-Bit counter parameter is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_Write32BitCounterValue(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned int ul_WriteValue)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\noutl(ul_WriteValue, devpriv->s_BoardInfos.\r\nui_Address + 4 + (64 * b_ModulNbr));\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_EnableIndex(struct comedi_device *dev, unsigned char b_ModulNbr)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int ul_InterruptLatchReg;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_IndexInit) {\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2 = devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2 | APCI1710_ENABLE_INDEX;\r\nul_InterruptLatchReg =\r\ninl(devpriv->s_BoardInfos.ui_Address +\r\n24 + (64 * b_ModulNbr));\r\noutl(devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ndw_ModeRegister1_2_3_4,\r\ndevpriv->s_BoardInfos.ui_Address + 20 +\r\n(64 * b_ModulNbr));\r\n} else {\r\nDPRINTK("Index not initialised \n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_DisableIndex(struct comedi_device *dev, unsigned char b_ModulNbr)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_IndexInit) {\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2 = devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister2 &\r\nAPCI1710_DISABLE_INDEX;\r\noutl(devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ndw_ModeRegister1_2_3_4,\r\ndevpriv->s_BoardInfos.ui_Address + 20 +\r\n(64 * b_ModulNbr));\r\n} else {\r\nDPRINTK("Index not initialised \n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_EnableCompareLogic(struct comedi_device *dev, unsigned char b_ModulNbr)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_InitFlag.b_CompareLogicInit == 1) {\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3 = devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3 |\r\nAPCI1710_ENABLE_COMPARE_INT;\r\noutl(devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ndw_ModeRegister1_2_3_4,\r\ndevpriv->s_BoardInfos.ui_Address + 20 +\r\n(64 * b_ModulNbr));\r\n} else {\r\nDPRINTK("Compare logic not initialised\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_DisableCompareLogic(struct comedi_device *dev, unsigned char b_ModulNbr)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_InitFlag.b_CompareLogicInit == 1) {\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3 = devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3 &\r\nAPCI1710_DISABLE_COMPARE_INT;\r\noutl(devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ndw_ModeRegister1_2_3_4,\r\ndevpriv->s_BoardInfos.ui_Address + 20 +\r\n(64 * b_ModulNbr));\r\n} else {\r\nDPRINTK("Compare logic not initialised\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_EnableFrequencyMeasurement(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char b_InterruptEnable)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_InitFlag.b_FrequencyMeasurementInit == 1) {\r\nif ((b_InterruptEnable == APCI1710_DISABLE) ||\r\n(b_InterruptEnable == APCI1710_ENABLE))\r\n{\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3 = devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3 |\r\nAPCI1710_ENABLE_FREQUENCY;\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3 = (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3 &\r\nAPCI1710_DISABLE_FREQUENCY_INT)\r\n| (b_InterruptEnable << 3);\r\noutl(devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ndw_ModeRegister1_2_3_4,\r\ndevpriv->s_BoardInfos.\r\nui_Address + 20 +\r\n(64 * b_ModulNbr));\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_InitFlag.\r\nb_FrequencyMeasurementEnable =\r\n1;\r\n} else {\r\nDPRINTK("Interrupt parameter is wrong\n");\r\ni_ReturnValue = -5;\r\n}\r\n} else {\r\nDPRINTK("Frequency measurement logic not initialised\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_DisableFrequencyMeasurement(struct comedi_device *dev, unsigned char b_ModulNbr)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_InitFlag.b_FrequencyMeasurementInit == 1) {\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3 = devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister3 &\r\nAPCI1710_DISABLE_FREQUENCY\r\n& APCI1710_DISABLE_FREQUENCY_INT;\r\noutl(devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ndw_ModeRegister1_2_3_4,\r\ndevpriv->s_BoardInfos.ui_Address + 20 +\r\n(64 * b_ModulNbr));\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_InitFlag.\r\nb_FrequencyMeasurementEnable = 0;\r\n} else {\r\nDPRINTK("Frequency measurement logic not initialised\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_InsnReadINCCPT(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ui_ReadType;\r\nint i_ReturnValue = 0;\r\nui_ReadType = CR_CHAN(insn->chanspec);\r\ndevpriv->tsk_Current = current;\r\nswitch (ui_ReadType) {\r\ncase APCI1710_INCCPT_READLATCHREGISTERSTATUS:\r\ni_ReturnValue = i_APCI1710_ReadLatchRegisterStatus(dev,\r\n(unsigned char) CR_AREF(insn->chanspec),\r\n(unsigned char) CR_RANGE(insn->chanspec), (unsigned char *) &data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_READLATCHREGISTERVALUE:\r\ni_ReturnValue = i_APCI1710_ReadLatchRegisterValue(dev,\r\n(unsigned char) CR_AREF(insn->chanspec),\r\n(unsigned char) CR_RANGE(insn->chanspec), (unsigned int *) &data[0]);\r\nprintk("Latch Register Value %d\n", data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_READ16BITCOUNTERVALUE:\r\ni_ReturnValue = i_APCI1710_Read16BitCounterValue(dev,\r\n(unsigned char) CR_AREF(insn->chanspec),\r\n(unsigned char) CR_RANGE(insn->chanspec), (unsigned int *) &data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_READ32BITCOUNTERVALUE:\r\ni_ReturnValue = i_APCI1710_Read32BitCounterValue(dev,\r\n(unsigned char) CR_AREF(insn->chanspec), (unsigned int *) &data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_GETINDEXSTATUS:\r\ni_ReturnValue = i_APCI1710_GetIndexStatus(dev,\r\n(unsigned char) CR_AREF(insn->chanspec), (unsigned char *) &data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_GETREFERENCESTATUS:\r\ni_ReturnValue = i_APCI1710_GetReferenceStatus(dev,\r\n(unsigned char) CR_AREF(insn->chanspec), (unsigned char *) &data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_GETUASSTATUS:\r\ni_ReturnValue = i_APCI1710_GetUASStatus(dev,\r\n(unsigned char) CR_AREF(insn->chanspec), (unsigned char *) &data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_GETCBSTATUS:\r\ni_ReturnValue = i_APCI1710_GetCBStatus(dev,\r\n(unsigned char) CR_AREF(insn->chanspec), (unsigned char *) &data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_GET16BITCBSTATUS:\r\ni_ReturnValue = i_APCI1710_Get16BitCBStatus(dev,\r\n(unsigned char) CR_AREF(insn->chanspec),\r\n(unsigned char *) &data[0], (unsigned char *) &data[1]);\r\nbreak;\r\ncase APCI1710_INCCPT_GETUDSTATUS:\r\ni_ReturnValue = i_APCI1710_GetUDStatus(dev,\r\n(unsigned char) CR_AREF(insn->chanspec), (unsigned char *) &data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_GETINTERRUPTUDLATCHEDSTATUS:\r\ni_ReturnValue = i_APCI1710_GetInterruptUDLatchedStatus(dev,\r\n(unsigned char) CR_AREF(insn->chanspec), (unsigned char *) &data[0]);\r\nbreak;\r\ncase APCI1710_INCCPT_READFREQUENCYMEASUREMENT:\r\ni_ReturnValue = i_APCI1710_ReadFrequencyMeasurement(dev,\r\n(unsigned char) CR_AREF(insn->chanspec),\r\n(unsigned char *) &data[0],\r\n(unsigned char *) &data[1], (unsigned int *) &data[2]);\r\nbreak;\r\ncase APCI1710_INCCPT_READINTERRUPT:\r\ndata[0] = devpriv->s_InterruptParameters.\r\ns_FIFOInterruptParameters[devpriv->\r\ns_InterruptParameters.ui_Read].b_OldModuleMask;\r\ndata[1] = devpriv->s_InterruptParameters.\r\ns_FIFOInterruptParameters[devpriv->\r\ns_InterruptParameters.ui_Read].ul_OldInterruptMask;\r\ndata[2] = devpriv->s_InterruptParameters.\r\ns_FIFOInterruptParameters[devpriv->\r\ns_InterruptParameters.ui_Read].ul_OldCounterLatchValue;\r\ndevpriv->\r\ns_InterruptParameters.\r\nui_Read = (devpriv->s_InterruptParameters.\r\nui_Read + 1) % APCI1710_SAVE_INTERRUPT;\r\nbreak;\r\ndefault:\r\nprintk("ReadType Parameter wrong\n");\r\n}\r\nif (i_ReturnValue >= 0)\r\ni_ReturnValue = insn->n;\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_ReadLatchRegisterStatus(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char b_LatchReg, unsigned char *pb_LatchStatus)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int dw_LatchReg;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (b_LatchReg < 2) {\r\ndw_LatchReg = inl(devpriv->s_BoardInfos.\r\nui_Address + (64 * b_ModulNbr));\r\n*pb_LatchStatus =\r\n(unsigned char) ((dw_LatchReg >> (b_LatchReg *\r\n4)) & 0x3);\r\n} else {\r\nDPRINTK("The selected latch register parameter is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_ReadLatchRegisterValue(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char b_LatchReg, unsigned int *pul_LatchValue)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (b_LatchReg < 2) {\r\n*pul_LatchValue = inl(devpriv->s_BoardInfos.\r\nui_Address + ((b_LatchReg + 1) * 4) +\r\n(64 * b_ModulNbr));\r\n} else {\r\nDPRINTK("The selected latch register parameter is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_Read16BitCounterValue(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char b_SelectedCounter, unsigned int *pui_CounterValue)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int dw_LathchValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (b_SelectedCounter < 2) {\r\noutl(1, devpriv->s_BoardInfos.\r\nui_Address + (64 * b_ModulNbr));\r\ndw_LathchValue = inl(devpriv->s_BoardInfos.\r\nui_Address + 4 + (64 * b_ModulNbr));\r\n*pui_CounterValue =\r\n(unsigned int) ((dw_LathchValue >> (16 *\r\nb_SelectedCounter)) &\r\n0xFFFFU);\r\n} else {\r\nDPRINTK("The selected 16-Bit counter parameter is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_Read32BitCounterValue(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned int *pul_CounterValue)\r\n{\r\nint i_ReturnValue = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\noutl(1, devpriv->s_BoardInfos.\r\nui_Address + (64 * b_ModulNbr));\r\n*pul_CounterValue = inl(devpriv->s_BoardInfos.\r\nui_Address + 4 + (64 * b_ModulNbr));\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_GetIndexStatus(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char *pb_IndexStatus)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int dw_StatusReg = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_IndexInit) {\r\ndw_StatusReg = inl(devpriv->s_BoardInfos.\r\nui_Address + 12 + (64 * b_ModulNbr));\r\n*pb_IndexStatus = (unsigned char) (dw_StatusReg & 1);\r\n} else {\r\nDPRINTK("Index not initialised\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_GetReferenceStatus(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char *pb_ReferenceStatus)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int dw_StatusReg = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_InitFlag.b_ReferenceInit) {\r\ndw_StatusReg = inl(devpriv->s_BoardInfos.\r\nui_Address + 24 + (64 * b_ModulNbr));\r\n*pb_ReferenceStatus =\r\n(unsigned char) (~dw_StatusReg & 1);\r\n} else {\r\nDPRINTK("Reference not initialised\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_GetUASStatus(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char *pb_UASStatus)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int dw_StatusReg = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\ndw_StatusReg = inl(devpriv->s_BoardInfos.\r\nui_Address + 24 + (64 * b_ModulNbr));\r\n*pb_UASStatus = (unsigned char) ((dw_StatusReg >> 1) & 1);\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_GetCBStatus(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char *pb_CBStatus)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int dw_StatusReg = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\ndw_StatusReg = inl(devpriv->s_BoardInfos.\r\nui_Address + 16 + (64 * b_ModulNbr));\r\n*pb_CBStatus = (unsigned char) (dw_StatusReg & 1);\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_Get16BitCBStatus(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char *pb_CBStatusCounter0, unsigned char *pb_CBStatusCounter1)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int dw_StatusReg = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif ((devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_ModeRegister.\r\ns_ByteModeRegister.\r\nb_ModeRegister1 & 0x10) == 0x10) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration\r\n[b_ModulNbr] & 0xFFFF) >=\r\n0x3136) {\r\ndw_StatusReg =\r\ninl(devpriv->s_BoardInfos.\r\nui_Address + 16 +\r\n(64 * b_ModulNbr));\r\n*pb_CBStatusCounter1 =\r\n(unsigned char) ((dw_StatusReg >> 0) &\r\n1);\r\n*pb_CBStatusCounter0 =\r\n(unsigned char) ((dw_StatusReg >> 1) &\r\n1);\r\n}\r\nelse {\r\ni_ReturnValue = -5;\r\n}\r\n}\r\nelse {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -4;\r\n}\r\n}\r\nelse {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n}\r\nelse {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_GetUDStatus(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char *pb_UDStatus)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int dw_StatusReg = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\ndw_StatusReg = inl(devpriv->s_BoardInfos.\r\nui_Address + 24 + (64 * b_ModulNbr));\r\n*pb_UDStatus = (unsigned char) ((dw_StatusReg >> 2) & 1);\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_GetInterruptUDLatchedStatus(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char *pb_UDStatus)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int dw_StatusReg = 0;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_InitFlag.b_IndexInterruptOccur == 1) {\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_InitFlag.b_IndexInterruptOccur = 0;\r\ndw_StatusReg = inl(devpriv->s_BoardInfos.\r\nui_Address + 12 + (64 * b_ModulNbr));\r\n*pb_UDStatus = (unsigned char) ((dw_StatusReg >> 1) & 1);\r\n} else {\r\n*pb_UDStatus = 2;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_ReadFrequencyMeasurement(struct comedi_device *dev,\r\nunsigned char b_ModulNbr,\r\nunsigned char *pb_Status, unsigned char *pb_UDStatus, unsigned int *pul_ReadValue)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int ui_16BitValue;\r\nunsigned int dw_StatusReg;\r\nif (b_ModulNbr < 4) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_InitFlag.b_FrequencyMeasurementInit == 1) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SiemensCounterInfo.\r\ns_InitFlag.\r\nb_FrequencyMeasurementEnable == 1) {\r\ndw_StatusReg =\r\ninl(devpriv->s_BoardInfos.\r\nui_Address + 32 +\r\n(64 * b_ModulNbr));\r\nif (dw_StatusReg & 1) {\r\n*pb_Status = 2;\r\n*pb_UDStatus =\r\n(unsigned char) ((dw_StatusReg >>\r\n1) & 3);\r\n*pul_ReadValue =\r\ninl(devpriv->\r\ns_BoardInfos.\r\nui_Address + 28 +\r\n(64 * b_ModulNbr));\r\nif (*pb_UDStatus == 0) {\r\nif ((devpriv->s_ModuleInfo[b_ModulNbr].s_SiemensCounterInfo.s_ModeRegister.s_ByteModeRegister.b_ModeRegister1 & APCI1710_16BIT_COUNTER) == APCI1710_16BIT_COUNTER) {\r\nif ((*pul_ReadValue & 0xFFFFU) != 0) {\r\nui_16BitValue\r\n=\r\n(unsigned int)\r\n*\r\npul_ReadValue\r\n&\r\n0xFFFFU;\r\n*pul_ReadValue\r\n=\r\n(*pul_ReadValue\r\n&\r\n0xFFFF0000UL)\r\n|\r\n(0xFFFFU\r\n-\r\nui_16BitValue);\r\n}\r\nif ((*pul_ReadValue & 0xFFFF0000UL) != 0) {\r\nui_16BitValue\r\n=\r\n(unsigned int)\r\n(\r\n(*pul_ReadValue\r\n>>\r\n16)\r\n&\r\n0xFFFFU);\r\n*pul_ReadValue\r\n=\r\n(*pul_ReadValue\r\n&\r\n0xFFFFUL)\r\n|\r\n(\r\n(0xFFFFU - ui_16BitValue) << 16);\r\n}\r\n} else {\r\nif (*pul_ReadValue != 0) {\r\n*pul_ReadValue\r\n=\r\n0xFFFFFFFFUL\r\n-\r\n*pul_ReadValue;\r\n}\r\n}\r\n} else {\r\nif (*pb_UDStatus == 1) {\r\nif ((*pul_ReadValue & 0xFFFF0000UL) != 0) {\r\nui_16BitValue\r\n=\r\n(unsigned int)\r\n(\r\n(*pul_ReadValue\r\n>>\r\n16)\r\n&\r\n0xFFFFU);\r\n*pul_ReadValue\r\n=\r\n(*pul_ReadValue\r\n&\r\n0xFFFFUL)\r\n|\r\n(\r\n(0xFFFFU - ui_16BitValue) << 16);\r\n}\r\n} else {\r\nif (*pb_UDStatus\r\n== 2) {\r\nif ((*pul_ReadValue & 0xFFFFU) != 0) {\r\nui_16BitValue\r\n=\r\n(unsigned int)\r\n*\r\npul_ReadValue\r\n&\r\n0xFFFFU;\r\n*pul_ReadValue\r\n=\r\n(*pul_ReadValue\r\n&\r\n0xFFFF0000UL)\r\n|\r\n(0xFFFFU\r\n-\r\nui_16BitValue);\r\n}\r\n}\r\n}\r\n}\r\n} else {\r\n*pb_Status = 1;\r\n*pb_UDStatus = 0;\r\n}\r\n} else {\r\n*pb_Status = 0;\r\n*pb_UDStatus = 0;\r\n}\r\n} else {\r\nDPRINTK("Frequency measurement logic not initialised\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("Counter not initialised\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("The selected module number parameter is wrong\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}
