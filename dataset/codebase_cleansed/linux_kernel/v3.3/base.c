void __gcov_init(struct gcov_info *info)\r\n{\r\nstatic unsigned int gcov_version;\r\nmutex_lock(&gcov_lock);\r\nif (gcov_version == 0) {\r\ngcov_version = info->version;\r\npr_info("version magic: 0x%x\n", gcov_version);\r\n}\r\ninfo->next = gcov_info_head;\r\ngcov_info_head = info;\r\nif (gcov_events_enabled)\r\ngcov_event(GCOV_ADD, info);\r\nmutex_unlock(&gcov_lock);\r\n}\r\nvoid __gcov_flush(void)\r\n{\r\n}\r\nvoid __gcov_merge_add(gcov_type *counters, unsigned int n_counters)\r\n{\r\n}\r\nvoid __gcov_merge_single(gcov_type *counters, unsigned int n_counters)\r\n{\r\n}\r\nvoid __gcov_merge_delta(gcov_type *counters, unsigned int n_counters)\r\n{\r\n}\r\nvoid gcov_enable_events(void)\r\n{\r\nstruct gcov_info *info;\r\nmutex_lock(&gcov_lock);\r\ngcov_events_enabled = 1;\r\nfor (info = gcov_info_head; info; info = info->next)\r\ngcov_event(GCOV_ADD, info);\r\nmutex_unlock(&gcov_lock);\r\n}\r\nstatic inline int within(void *addr, void *start, unsigned long size)\r\n{\r\nreturn ((addr >= start) && (addr < start + size));\r\n}\r\nstatic int gcov_module_notifier(struct notifier_block *nb, unsigned long event,\r\nvoid *data)\r\n{\r\nstruct module *mod = data;\r\nstruct gcov_info *info;\r\nstruct gcov_info *prev;\r\nif (event != MODULE_STATE_GOING)\r\nreturn NOTIFY_OK;\r\nmutex_lock(&gcov_lock);\r\nprev = NULL;\r\nfor (info = gcov_info_head; info; info = info->next) {\r\nif (within(info, mod->module_core, mod->core_size)) {\r\nif (prev)\r\nprev->next = info->next;\r\nelse\r\ngcov_info_head = info->next;\r\nif (gcov_events_enabled)\r\ngcov_event(GCOV_REMOVE, info);\r\n} else\r\nprev = info;\r\n}\r\nmutex_unlock(&gcov_lock);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init gcov_init(void)\r\n{\r\nreturn register_module_notifier(&gcov_nb);\r\n}
