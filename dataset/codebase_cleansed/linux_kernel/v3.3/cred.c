static inline void set_cred_subscribers(struct cred *cred, int n)\r\n{\r\n#ifdef CONFIG_DEBUG_CREDENTIALS\r\natomic_set(&cred->subscribers, n);\r\n#endif\r\n}\r\nstatic inline int read_cred_subscribers(const struct cred *cred)\r\n{\r\n#ifdef CONFIG_DEBUG_CREDENTIALS\r\nreturn atomic_read(&cred->subscribers);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic inline void alter_cred_subscribers(const struct cred *_cred, int n)\r\n{\r\n#ifdef CONFIG_DEBUG_CREDENTIALS\r\nstruct cred *cred = (struct cred *) _cred;\r\natomic_add(n, &cred->subscribers);\r\n#endif\r\n}\r\nstatic void release_tgcred_rcu(struct rcu_head *rcu)\r\n{\r\nstruct thread_group_cred *tgcred =\r\ncontainer_of(rcu, struct thread_group_cred, rcu);\r\nBUG_ON(atomic_read(&tgcred->usage) != 0);\r\nkey_put(tgcred->session_keyring);\r\nkey_put(tgcred->process_keyring);\r\nkfree(tgcred);\r\n}\r\nstatic void release_tgcred(struct cred *cred)\r\n{\r\n#ifdef CONFIG_KEYS\r\nstruct thread_group_cred *tgcred = cred->tgcred;\r\nif (atomic_dec_and_test(&tgcred->usage))\r\ncall_rcu(&tgcred->rcu, release_tgcred_rcu);\r\n#endif\r\n}\r\nstatic void put_cred_rcu(struct rcu_head *rcu)\r\n{\r\nstruct cred *cred = container_of(rcu, struct cred, rcu);\r\nkdebug("put_cred_rcu(%p)", cred);\r\n#ifdef CONFIG_DEBUG_CREDENTIALS\r\nif (cred->magic != CRED_MAGIC_DEAD ||\r\natomic_read(&cred->usage) != 0 ||\r\nread_cred_subscribers(cred) != 0)\r\npanic("CRED: put_cred_rcu() sees %p with"\r\n" mag %x, put %p, usage %d, subscr %d\n",\r\ncred, cred->magic, cred->put_addr,\r\natomic_read(&cred->usage),\r\nread_cred_subscribers(cred));\r\n#else\r\nif (atomic_read(&cred->usage) != 0)\r\npanic("CRED: put_cred_rcu() sees %p with usage %d\n",\r\ncred, atomic_read(&cred->usage));\r\n#endif\r\nsecurity_cred_free(cred);\r\nkey_put(cred->thread_keyring);\r\nkey_put(cred->request_key_auth);\r\nrelease_tgcred(cred);\r\nif (cred->group_info)\r\nput_group_info(cred->group_info);\r\nfree_uid(cred->user);\r\nkmem_cache_free(cred_jar, cred);\r\n}\r\nvoid __put_cred(struct cred *cred)\r\n{\r\nkdebug("__put_cred(%p{%d,%d})", cred,\r\natomic_read(&cred->usage),\r\nread_cred_subscribers(cred));\r\nBUG_ON(atomic_read(&cred->usage) != 0);\r\n#ifdef CONFIG_DEBUG_CREDENTIALS\r\nBUG_ON(read_cred_subscribers(cred) != 0);\r\ncred->magic = CRED_MAGIC_DEAD;\r\ncred->put_addr = __builtin_return_address(0);\r\n#endif\r\nBUG_ON(cred == current->cred);\r\nBUG_ON(cred == current->real_cred);\r\ncall_rcu(&cred->rcu, put_cred_rcu);\r\n}\r\nvoid exit_creds(struct task_struct *tsk)\r\n{\r\nstruct cred *cred;\r\nkdebug("exit_creds(%u,%p,%p,{%d,%d})", tsk->pid, tsk->real_cred, tsk->cred,\r\natomic_read(&tsk->cred->usage),\r\nread_cred_subscribers(tsk->cred));\r\ncred = (struct cred *) tsk->real_cred;\r\ntsk->real_cred = NULL;\r\nvalidate_creds(cred);\r\nalter_cred_subscribers(cred, -1);\r\nput_cred(cred);\r\ncred = (struct cred *) tsk->cred;\r\ntsk->cred = NULL;\r\nvalidate_creds(cred);\r\nalter_cred_subscribers(cred, -1);\r\nput_cred(cred);\r\ncred = (struct cred *) tsk->replacement_session_keyring;\r\nif (cred) {\r\ntsk->replacement_session_keyring = NULL;\r\nvalidate_creds(cred);\r\nput_cred(cred);\r\n}\r\n}\r\nconst struct cred *get_task_cred(struct task_struct *task)\r\n{\r\nconst struct cred *cred;\r\nrcu_read_lock();\r\ndo {\r\ncred = __task_cred((task));\r\nBUG_ON(!cred);\r\n} while (!atomic_inc_not_zero(&((struct cred *)cred)->usage));\r\nrcu_read_unlock();\r\nreturn cred;\r\n}\r\nstruct cred *cred_alloc_blank(void)\r\n{\r\nstruct cred *new;\r\nnew = kmem_cache_zalloc(cred_jar, GFP_KERNEL);\r\nif (!new)\r\nreturn NULL;\r\n#ifdef CONFIG_KEYS\r\nnew->tgcred = kzalloc(sizeof(*new->tgcred), GFP_KERNEL);\r\nif (!new->tgcred) {\r\nkmem_cache_free(cred_jar, new);\r\nreturn NULL;\r\n}\r\natomic_set(&new->tgcred->usage, 1);\r\n#endif\r\natomic_set(&new->usage, 1);\r\n#ifdef CONFIG_DEBUG_CREDENTIALS\r\nnew->magic = CRED_MAGIC;\r\n#endif\r\nif (security_cred_alloc_blank(new, GFP_KERNEL) < 0)\r\ngoto error;\r\nreturn new;\r\nerror:\r\nabort_creds(new);\r\nreturn NULL;\r\n}\r\nstruct cred *prepare_creds(void)\r\n{\r\nstruct task_struct *task = current;\r\nconst struct cred *old;\r\nstruct cred *new;\r\nvalidate_process_creds();\r\nnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\r\nif (!new)\r\nreturn NULL;\r\nkdebug("prepare_creds() alloc %p", new);\r\nold = task->cred;\r\nmemcpy(new, old, sizeof(struct cred));\r\natomic_set(&new->usage, 1);\r\nset_cred_subscribers(new, 0);\r\nget_group_info(new->group_info);\r\nget_uid(new->user);\r\n#ifdef CONFIG_KEYS\r\nkey_get(new->thread_keyring);\r\nkey_get(new->request_key_auth);\r\natomic_inc(&new->tgcred->usage);\r\n#endif\r\n#ifdef CONFIG_SECURITY\r\nnew->security = NULL;\r\n#endif\r\nif (security_prepare_creds(new, old, GFP_KERNEL) < 0)\r\ngoto error;\r\nvalidate_creds(new);\r\nreturn new;\r\nerror:\r\nabort_creds(new);\r\nreturn NULL;\r\n}\r\nstruct cred *prepare_exec_creds(void)\r\n{\r\nstruct thread_group_cred *tgcred = NULL;\r\nstruct cred *new;\r\n#ifdef CONFIG_KEYS\r\ntgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\r\nif (!tgcred)\r\nreturn NULL;\r\n#endif\r\nnew = prepare_creds();\r\nif (!new) {\r\nkfree(tgcred);\r\nreturn new;\r\n}\r\n#ifdef CONFIG_KEYS\r\nkey_put(new->thread_keyring);\r\nnew->thread_keyring = NULL;\r\nmemcpy(tgcred, new->tgcred, sizeof(struct thread_group_cred));\r\natomic_set(&tgcred->usage, 1);\r\nspin_lock_init(&tgcred->lock);\r\nkey_get(tgcred->session_keyring);\r\ntgcred->process_keyring = NULL;\r\nrelease_tgcred(new);\r\nnew->tgcred = tgcred;\r\n#endif\r\nreturn new;\r\n}\r\nint copy_creds(struct task_struct *p, unsigned long clone_flags)\r\n{\r\n#ifdef CONFIG_KEYS\r\nstruct thread_group_cred *tgcred;\r\n#endif\r\nstruct cred *new;\r\nint ret;\r\nif (\r\n#ifdef CONFIG_KEYS\r\n!p->cred->thread_keyring &&\r\n#endif\r\nclone_flags & CLONE_THREAD\r\n) {\r\np->real_cred = get_cred(p->cred);\r\nget_cred(p->cred);\r\nalter_cred_subscribers(p->cred, 2);\r\nkdebug("share_creds(%p{%d,%d})",\r\np->cred, atomic_read(&p->cred->usage),\r\nread_cred_subscribers(p->cred));\r\natomic_inc(&p->cred->user->processes);\r\nreturn 0;\r\n}\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\nif (clone_flags & CLONE_NEWUSER) {\r\nret = create_user_ns(new);\r\nif (ret < 0)\r\ngoto error_put;\r\n}\r\nnew->user_ns = new->user->user_ns;\r\n#ifdef CONFIG_KEYS\r\nif (new->thread_keyring) {\r\nkey_put(new->thread_keyring);\r\nnew->thread_keyring = NULL;\r\nif (clone_flags & CLONE_THREAD)\r\ninstall_thread_keyring_to_cred(new);\r\n}\r\nif (!(clone_flags & CLONE_THREAD)) {\r\ntgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\r\nif (!tgcred) {\r\nret = -ENOMEM;\r\ngoto error_put;\r\n}\r\natomic_set(&tgcred->usage, 1);\r\nspin_lock_init(&tgcred->lock);\r\ntgcred->process_keyring = NULL;\r\ntgcred->session_keyring = key_get(new->tgcred->session_keyring);\r\nrelease_tgcred(new);\r\nnew->tgcred = tgcred;\r\n}\r\n#endif\r\natomic_inc(&new->user->processes);\r\np->cred = p->real_cred = get_cred(new);\r\nalter_cred_subscribers(new, 2);\r\nvalidate_creds(new);\r\nreturn 0;\r\nerror_put:\r\nput_cred(new);\r\nreturn ret;\r\n}\r\nint commit_creds(struct cred *new)\r\n{\r\nstruct task_struct *task = current;\r\nconst struct cred *old = task->real_cred;\r\nkdebug("commit_creds(%p{%d,%d})", new,\r\natomic_read(&new->usage),\r\nread_cred_subscribers(new));\r\nBUG_ON(task->cred != old);\r\n#ifdef CONFIG_DEBUG_CREDENTIALS\r\nBUG_ON(read_cred_subscribers(old) < 2);\r\nvalidate_creds(old);\r\nvalidate_creds(new);\r\n#endif\r\nBUG_ON(atomic_read(&new->usage) < 1);\r\nget_cred(new);\r\nif (old->euid != new->euid ||\r\nold->egid != new->egid ||\r\nold->fsuid != new->fsuid ||\r\nold->fsgid != new->fsgid ||\r\n!cap_issubset(new->cap_permitted, old->cap_permitted)) {\r\nif (task->mm)\r\nset_dumpable(task->mm, suid_dumpable);\r\ntask->pdeath_signal = 0;\r\nsmp_wmb();\r\n}\r\nif (new->fsuid != old->fsuid)\r\nkey_fsuid_changed(task);\r\nif (new->fsgid != old->fsgid)\r\nkey_fsgid_changed(task);\r\nalter_cred_subscribers(new, 2);\r\nif (new->user != old->user)\r\natomic_inc(&new->user->processes);\r\nrcu_assign_pointer(task->real_cred, new);\r\nrcu_assign_pointer(task->cred, new);\r\nif (new->user != old->user)\r\natomic_dec(&old->user->processes);\r\nalter_cred_subscribers(old, -2);\r\nif (new->uid != old->uid ||\r\nnew->euid != old->euid ||\r\nnew->suid != old->suid ||\r\nnew->fsuid != old->fsuid)\r\nproc_id_connector(task, PROC_EVENT_UID);\r\nif (new->gid != old->gid ||\r\nnew->egid != old->egid ||\r\nnew->sgid != old->sgid ||\r\nnew->fsgid != old->fsgid)\r\nproc_id_connector(task, PROC_EVENT_GID);\r\nput_cred(old);\r\nput_cred(old);\r\nreturn 0;\r\n}\r\nvoid abort_creds(struct cred *new)\r\n{\r\nkdebug("abort_creds(%p{%d,%d})", new,\r\natomic_read(&new->usage),\r\nread_cred_subscribers(new));\r\n#ifdef CONFIG_DEBUG_CREDENTIALS\r\nBUG_ON(read_cred_subscribers(new) != 0);\r\n#endif\r\nBUG_ON(atomic_read(&new->usage) < 1);\r\nput_cred(new);\r\n}\r\nconst struct cred *override_creds(const struct cred *new)\r\n{\r\nconst struct cred *old = current->cred;\r\nkdebug("override_creds(%p{%d,%d})", new,\r\natomic_read(&new->usage),\r\nread_cred_subscribers(new));\r\nvalidate_creds(old);\r\nvalidate_creds(new);\r\nget_cred(new);\r\nalter_cred_subscribers(new, 1);\r\nrcu_assign_pointer(current->cred, new);\r\nalter_cred_subscribers(old, -1);\r\nkdebug("override_creds() = %p{%d,%d}", old,\r\natomic_read(&old->usage),\r\nread_cred_subscribers(old));\r\nreturn old;\r\n}\r\nvoid revert_creds(const struct cred *old)\r\n{\r\nconst struct cred *override = current->cred;\r\nkdebug("revert_creds(%p{%d,%d})", old,\r\natomic_read(&old->usage),\r\nread_cred_subscribers(old));\r\nvalidate_creds(old);\r\nvalidate_creds(override);\r\nalter_cred_subscribers(old, 1);\r\nrcu_assign_pointer(current->cred, old);\r\nalter_cred_subscribers(override, -1);\r\nput_cred(override);\r\n}\r\nvoid __init cred_init(void)\r\n{\r\ncred_jar = kmem_cache_create("cred_jar", sizeof(struct cred),\r\n0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\r\n}\r\nstruct cred *prepare_kernel_cred(struct task_struct *daemon)\r\n{\r\n#ifdef CONFIG_KEYS\r\nstruct thread_group_cred *tgcred;\r\n#endif\r\nconst struct cred *old;\r\nstruct cred *new;\r\nnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\r\nif (!new)\r\nreturn NULL;\r\n#ifdef CONFIG_KEYS\r\ntgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\r\nif (!tgcred) {\r\nkmem_cache_free(cred_jar, new);\r\nreturn NULL;\r\n}\r\n#endif\r\nkdebug("prepare_kernel_cred() alloc %p", new);\r\nif (daemon)\r\nold = get_task_cred(daemon);\r\nelse\r\nold = get_cred(&init_cred);\r\nvalidate_creds(old);\r\n*new = *old;\r\natomic_set(&new->usage, 1);\r\nset_cred_subscribers(new, 0);\r\nget_uid(new->user);\r\nget_group_info(new->group_info);\r\n#ifdef CONFIG_KEYS\r\natomic_set(&tgcred->usage, 1);\r\nspin_lock_init(&tgcred->lock);\r\ntgcred->process_keyring = NULL;\r\ntgcred->session_keyring = NULL;\r\nnew->tgcred = tgcred;\r\nnew->request_key_auth = NULL;\r\nnew->thread_keyring = NULL;\r\nnew->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\r\n#endif\r\n#ifdef CONFIG_SECURITY\r\nnew->security = NULL;\r\n#endif\r\nif (security_prepare_creds(new, old, GFP_KERNEL) < 0)\r\ngoto error;\r\nput_cred(old);\r\nvalidate_creds(new);\r\nreturn new;\r\nerror:\r\nput_cred(new);\r\nput_cred(old);\r\nreturn NULL;\r\n}\r\nint set_security_override(struct cred *new, u32 secid)\r\n{\r\nreturn security_kernel_act_as(new, secid);\r\n}\r\nint set_security_override_from_ctx(struct cred *new, const char *secctx)\r\n{\r\nu32 secid;\r\nint ret;\r\nret = security_secctx_to_secid(secctx, strlen(secctx), &secid);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn set_security_override(new, secid);\r\n}\r\nint set_create_files_as(struct cred *new, struct inode *inode)\r\n{\r\nnew->fsuid = inode->i_uid;\r\nnew->fsgid = inode->i_gid;\r\nreturn security_kernel_create_files_as(new, inode);\r\n}\r\nbool creds_are_invalid(const struct cred *cred)\r\n{\r\nif (cred->magic != CRED_MAGIC)\r\nreturn true;\r\n#ifdef CONFIG_SECURITY_SELINUX\r\nif (selinux_is_enabled() && cred->security) {\r\nif ((unsigned long) cred->security < PAGE_SIZE)\r\nreturn true;\r\nif ((*(u32 *)cred->security & 0xffffff00) ==\r\n(POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8))\r\nreturn true;\r\n}\r\n#endif\r\nreturn false;\r\n}\r\nstatic void dump_invalid_creds(const struct cred *cred, const char *label,\r\nconst struct task_struct *tsk)\r\n{\r\nprintk(KERN_ERR "CRED: %s credentials: %p %s%s%s\n",\r\nlabel, cred,\r\ncred == &init_cred ? "[init]" : "",\r\ncred == tsk->real_cred ? "[real]" : "",\r\ncred == tsk->cred ? "[eff]" : "");\r\nprintk(KERN_ERR "CRED: ->magic=%x, put_addr=%p\n",\r\ncred->magic, cred->put_addr);\r\nprintk(KERN_ERR "CRED: ->usage=%d, subscr=%d\n",\r\natomic_read(&cred->usage),\r\nread_cred_subscribers(cred));\r\nprintk(KERN_ERR "CRED: ->*uid = { %d,%d,%d,%d }\n",\r\ncred->uid, cred->euid, cred->suid, cred->fsuid);\r\nprintk(KERN_ERR "CRED: ->*gid = { %d,%d,%d,%d }\n",\r\ncred->gid, cred->egid, cred->sgid, cred->fsgid);\r\n#ifdef CONFIG_SECURITY\r\nprintk(KERN_ERR "CRED: ->security is %p\n", cred->security);\r\nif ((unsigned long) cred->security >= PAGE_SIZE &&\r\n(((unsigned long) cred->security & 0xffffff00) !=\r\n(POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8)))\r\nprintk(KERN_ERR "CRED: ->security {%x, %x}\n",\r\n((u32*)cred->security)[0],\r\n((u32*)cred->security)[1]);\r\n#endif\r\n}\r\nvoid __invalid_creds(const struct cred *cred, const char *file, unsigned line)\r\n{\r\nprintk(KERN_ERR "CRED: Invalid credentials\n");\r\nprintk(KERN_ERR "CRED: At %s:%u\n", file, line);\r\ndump_invalid_creds(cred, "Specified", current);\r\nBUG();\r\n}\r\nvoid __validate_process_creds(struct task_struct *tsk,\r\nconst char *file, unsigned line)\r\n{\r\nif (tsk->cred == tsk->real_cred) {\r\nif (unlikely(read_cred_subscribers(tsk->cred) < 2 ||\r\ncreds_are_invalid(tsk->cred)))\r\ngoto invalid_creds;\r\n} else {\r\nif (unlikely(read_cred_subscribers(tsk->real_cred) < 1 ||\r\nread_cred_subscribers(tsk->cred) < 1 ||\r\ncreds_are_invalid(tsk->real_cred) ||\r\ncreds_are_invalid(tsk->cred)))\r\ngoto invalid_creds;\r\n}\r\nreturn;\r\ninvalid_creds:\r\nprintk(KERN_ERR "CRED: Invalid process credentials\n");\r\nprintk(KERN_ERR "CRED: At %s:%u\n", file, line);\r\ndump_invalid_creds(tsk->real_cred, "Real", tsk);\r\nif (tsk->cred != tsk->real_cred)\r\ndump_invalid_creds(tsk->cred, "Effective", tsk);\r\nelse\r\nprintk(KERN_ERR "CRED: Effective creds == Real creds\n");\r\nBUG();\r\n}\r\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\r\n{\r\nkdebug("validate_creds_for_do_exit(%p,%p{%d,%d})",\r\ntsk->real_cred, tsk->cred,\r\natomic_read(&tsk->cred->usage),\r\nread_cred_subscribers(tsk->cred));\r\n__validate_process_creds(tsk, __FILE__, __LINE__);\r\n}
