static void __devinit pm8001_phy_init(struct pm8001_hba_info *pm8001_ha,\r\nint phy_id)\r\n{\r\nstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\r\nstruct asd_sas_phy *sas_phy = &phy->sas_phy;\r\nphy->phy_state = 0;\r\nphy->pm8001_ha = pm8001_ha;\r\nsas_phy->enabled = (phy_id < pm8001_ha->chip->n_phy) ? 1 : 0;\r\nsas_phy->class = SAS;\r\nsas_phy->iproto = SAS_PROTOCOL_ALL;\r\nsas_phy->tproto = 0;\r\nsas_phy->type = PHY_TYPE_PHYSICAL;\r\nsas_phy->role = PHY_ROLE_INITIATOR;\r\nsas_phy->oob_mode = OOB_NOT_CONNECTED;\r\nsas_phy->linkrate = SAS_LINK_RATE_UNKNOWN;\r\nsas_phy->id = phy_id;\r\nsas_phy->sas_addr = &pm8001_ha->sas_addr[0];\r\nsas_phy->frame_rcvd = &phy->frame_rcvd[0];\r\nsas_phy->ha = (struct sas_ha_struct *)pm8001_ha->shost->hostdata;\r\nsas_phy->lldd_phy = phy;\r\n}\r\nstatic void pm8001_free(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nint i;\r\nif (!pm8001_ha)\r\nreturn;\r\nfor (i = 0; i < USI_MAX_MEMCNT; i++) {\r\nif (pm8001_ha->memoryMap.region[i].virt_ptr != NULL) {\r\npci_free_consistent(pm8001_ha->pdev,\r\npm8001_ha->memoryMap.region[i].element_size,\r\npm8001_ha->memoryMap.region[i].virt_ptr,\r\npm8001_ha->memoryMap.region[i].phys_addr);\r\n}\r\n}\r\nPM8001_CHIP_DISP->chip_iounmap(pm8001_ha);\r\nif (pm8001_ha->shost)\r\nscsi_host_put(pm8001_ha->shost);\r\nflush_workqueue(pm8001_wq);\r\nkfree(pm8001_ha->tags);\r\nkfree(pm8001_ha);\r\n}\r\nstatic void pm8001_tasklet(unsigned long opaque)\r\n{\r\nstruct pm8001_hba_info *pm8001_ha;\r\npm8001_ha = (struct pm8001_hba_info *)opaque;\r\nif (unlikely(!pm8001_ha))\r\nBUG_ON(1);\r\nPM8001_CHIP_DISP->isr(pm8001_ha);\r\n}\r\nstatic irqreturn_t pm8001_interrupt(int irq, void *opaque)\r\n{\r\nstruct pm8001_hba_info *pm8001_ha;\r\nirqreturn_t ret = IRQ_HANDLED;\r\nstruct sas_ha_struct *sha = opaque;\r\npm8001_ha = sha->lldd_ha;\r\nif (unlikely(!pm8001_ha))\r\nreturn IRQ_NONE;\r\nif (!PM8001_CHIP_DISP->is_our_interupt(pm8001_ha))\r\nreturn IRQ_NONE;\r\n#ifdef PM8001_USE_TASKLET\r\ntasklet_schedule(&pm8001_ha->tasklet);\r\n#else\r\nret = PM8001_CHIP_DISP->isr(pm8001_ha);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int __devinit pm8001_alloc(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nint i;\r\nspin_lock_init(&pm8001_ha->lock);\r\nfor (i = 0; i < pm8001_ha->chip->n_phy; i++) {\r\npm8001_phy_init(pm8001_ha, i);\r\npm8001_ha->port[i].wide_port_phymap = 0;\r\npm8001_ha->port[i].port_attached = 0;\r\npm8001_ha->port[i].port_state = 0;\r\nINIT_LIST_HEAD(&pm8001_ha->port[i].list);\r\n}\r\npm8001_ha->tags = kzalloc(PM8001_MAX_CCB, GFP_KERNEL);\r\nif (!pm8001_ha->tags)\r\ngoto err_out;\r\npm8001_ha->memoryMap.region[AAP1].num_elements = 1;\r\npm8001_ha->memoryMap.region[AAP1].element_size = PM8001_EVENT_LOG_SIZE;\r\npm8001_ha->memoryMap.region[AAP1].total_len = PM8001_EVENT_LOG_SIZE;\r\npm8001_ha->memoryMap.region[AAP1].alignment = 32;\r\npm8001_ha->memoryMap.region[IOP].num_elements = 1;\r\npm8001_ha->memoryMap.region[IOP].element_size = PM8001_EVENT_LOG_SIZE;\r\npm8001_ha->memoryMap.region[IOP].total_len = PM8001_EVENT_LOG_SIZE;\r\npm8001_ha->memoryMap.region[IOP].alignment = 32;\r\npm8001_ha->memoryMap.region[CI].num_elements = 1;\r\npm8001_ha->memoryMap.region[CI].element_size = 4;\r\npm8001_ha->memoryMap.region[CI].total_len = 4;\r\npm8001_ha->memoryMap.region[CI].alignment = 4;\r\npm8001_ha->memoryMap.region[PI].num_elements = 1;\r\npm8001_ha->memoryMap.region[PI].element_size = 4;\r\npm8001_ha->memoryMap.region[PI].total_len = 4;\r\npm8001_ha->memoryMap.region[PI].alignment = 4;\r\npm8001_ha->memoryMap.region[IB].num_elements = 256;\r\npm8001_ha->memoryMap.region[IB].element_size = 64;\r\npm8001_ha->memoryMap.region[IB].total_len = 256 * 64;\r\npm8001_ha->memoryMap.region[IB].alignment = 64;\r\npm8001_ha->memoryMap.region[OB].num_elements = 256;\r\npm8001_ha->memoryMap.region[OB].element_size = 64;\r\npm8001_ha->memoryMap.region[OB].total_len = 256 * 64;\r\npm8001_ha->memoryMap.region[OB].alignment = 64;\r\npm8001_ha->memoryMap.region[NVMD].num_elements = 1;\r\npm8001_ha->memoryMap.region[NVMD].element_size = 4096;\r\npm8001_ha->memoryMap.region[NVMD].total_len = 4096;\r\npm8001_ha->memoryMap.region[DEV_MEM].num_elements = 1;\r\npm8001_ha->memoryMap.region[DEV_MEM].element_size = PM8001_MAX_DEVICES *\r\nsizeof(struct pm8001_device);\r\npm8001_ha->memoryMap.region[DEV_MEM].total_len = PM8001_MAX_DEVICES *\r\nsizeof(struct pm8001_device);\r\npm8001_ha->memoryMap.region[CCB_MEM].num_elements = 1;\r\npm8001_ha->memoryMap.region[CCB_MEM].element_size = PM8001_MAX_CCB *\r\nsizeof(struct pm8001_ccb_info);\r\npm8001_ha->memoryMap.region[CCB_MEM].total_len = PM8001_MAX_CCB *\r\nsizeof(struct pm8001_ccb_info);\r\nfor (i = 0; i < USI_MAX_MEMCNT; i++) {\r\nif (pm8001_mem_alloc(pm8001_ha->pdev,\r\n&pm8001_ha->memoryMap.region[i].virt_ptr,\r\n&pm8001_ha->memoryMap.region[i].phys_addr,\r\n&pm8001_ha->memoryMap.region[i].phys_addr_hi,\r\n&pm8001_ha->memoryMap.region[i].phys_addr_lo,\r\npm8001_ha->memoryMap.region[i].total_len,\r\npm8001_ha->memoryMap.region[i].alignment) != 0) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Mem%d alloc failed\n",\r\ni));\r\ngoto err_out;\r\n}\r\n}\r\npm8001_ha->devices = pm8001_ha->memoryMap.region[DEV_MEM].virt_ptr;\r\nfor (i = 0; i < PM8001_MAX_DEVICES; i++) {\r\npm8001_ha->devices[i].dev_type = NO_DEVICE;\r\npm8001_ha->devices[i].id = i;\r\npm8001_ha->devices[i].device_id = PM8001_MAX_DEVICES;\r\npm8001_ha->devices[i].running_req = 0;\r\n}\r\npm8001_ha->ccb_info = pm8001_ha->memoryMap.region[CCB_MEM].virt_ptr;\r\nfor (i = 0; i < PM8001_MAX_CCB; i++) {\r\npm8001_ha->ccb_info[i].ccb_dma_handle =\r\npm8001_ha->memoryMap.region[CCB_MEM].phys_addr +\r\ni * sizeof(struct pm8001_ccb_info);\r\npm8001_ha->ccb_info[i].task = NULL;\r\npm8001_ha->ccb_info[i].ccb_tag = 0xffffffff;\r\npm8001_ha->ccb_info[i].device = NULL;\r\n++pm8001_ha->tags_num;\r\n}\r\npm8001_ha->flags = PM8001F_INIT_TIME;\r\npm8001_tag_init(pm8001_ha);\r\nreturn 0;\r\nerr_out:\r\nreturn 1;\r\n}\r\nstatic int pm8001_ioremap(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 bar;\r\nu32 logicalBar = 0;\r\nstruct pci_dev *pdev;\r\npdev = pm8001_ha->pdev;\r\nfor (bar = 0; bar < 6; bar++) {\r\nif ((bar == 1) || (bar == 3))\r\ncontinue;\r\nif (pci_resource_flags(pdev, bar) & IORESOURCE_MEM) {\r\npm8001_ha->io_mem[logicalBar].membase =\r\npci_resource_start(pdev, bar);\r\npm8001_ha->io_mem[logicalBar].membase &=\r\n(u32)PCI_BASE_ADDRESS_MEM_MASK;\r\npm8001_ha->io_mem[logicalBar].memsize =\r\npci_resource_len(pdev, bar);\r\npm8001_ha->io_mem[logicalBar].memvirtaddr =\r\nioremap(pm8001_ha->io_mem[logicalBar].membase,\r\npm8001_ha->io_mem[logicalBar].memsize);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("PCI: bar %d, logicalBar %d "\r\n"virt_addr=%lx,len=%d\n", bar, logicalBar,\r\n(unsigned long)\r\npm8001_ha->io_mem[logicalBar].memvirtaddr,\r\npm8001_ha->io_mem[logicalBar].memsize));\r\n} else {\r\npm8001_ha->io_mem[logicalBar].membase = 0;\r\npm8001_ha->io_mem[logicalBar].memsize = 0;\r\npm8001_ha->io_mem[logicalBar].memvirtaddr = 0;\r\n}\r\nlogicalBar++;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct pm8001_hba_info *__devinit\r\npm8001_pci_alloc(struct pci_dev *pdev, u32 chip_id, struct Scsi_Host *shost)\r\n{\r\nstruct pm8001_hba_info *pm8001_ha;\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\npm8001_ha = sha->lldd_ha;\r\nif (!pm8001_ha)\r\nreturn NULL;\r\npm8001_ha->pdev = pdev;\r\npm8001_ha->dev = &pdev->dev;\r\npm8001_ha->chip_id = chip_id;\r\npm8001_ha->chip = &pm8001_chips[pm8001_ha->chip_id];\r\npm8001_ha->irq = pdev->irq;\r\npm8001_ha->sas = sha;\r\npm8001_ha->shost = shost;\r\npm8001_ha->id = pm8001_id++;\r\npm8001_ha->logging_level = 0x01;\r\nsprintf(pm8001_ha->name, "%s%d", DRV_NAME, pm8001_ha->id);\r\n#ifdef PM8001_USE_TASKLET\r\ntasklet_init(&pm8001_ha->tasklet, pm8001_tasklet,\r\n(unsigned long)pm8001_ha);\r\n#endif\r\npm8001_ioremap(pm8001_ha);\r\nif (!pm8001_alloc(pm8001_ha))\r\nreturn pm8001_ha;\r\npm8001_free(pm8001_ha);\r\nreturn NULL;\r\n}\r\nstatic int pci_go_44(struct pci_dev *pdev)\r\n{\r\nint rc;\r\nif (!pci_set_dma_mask(pdev, DMA_BIT_MASK(44))) {\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(44));\r\nif (rc) {\r\nrc = pci_set_consistent_dma_mask(pdev,\r\nDMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"44-bit DMA enable failed\n");\r\nreturn rc;\r\n}\r\n}\r\n} else {\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"32-bit DMA enable failed\n");\r\nreturn rc;\r\n}\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"32-bit consistent DMA enable failed\n");\r\nreturn rc;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int __devinit pm8001_prep_sas_ha_init(struct Scsi_Host * shost,\r\nconst struct pm8001_chip_info *chip_info)\r\n{\r\nint phy_nr, port_nr;\r\nstruct asd_sas_phy **arr_phy;\r\nstruct asd_sas_port **arr_port;\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nphy_nr = chip_info->n_phy;\r\nport_nr = phy_nr;\r\nmemset(sha, 0x00, sizeof(*sha));\r\narr_phy = kcalloc(phy_nr, sizeof(void *), GFP_KERNEL);\r\nif (!arr_phy)\r\ngoto exit;\r\narr_port = kcalloc(port_nr, sizeof(void *), GFP_KERNEL);\r\nif (!arr_port)\r\ngoto exit_free2;\r\nsha->sas_phy = arr_phy;\r\nsha->sas_port = arr_port;\r\nsha->lldd_ha = kzalloc(sizeof(struct pm8001_hba_info), GFP_KERNEL);\r\nif (!sha->lldd_ha)\r\ngoto exit_free1;\r\nshost->transportt = pm8001_stt;\r\nshost->max_id = PM8001_MAX_DEVICES;\r\nshost->max_lun = 8;\r\nshost->max_channel = 0;\r\nshost->unique_id = pm8001_id;\r\nshost->max_cmd_len = 16;\r\nshost->can_queue = PM8001_CAN_QUEUE;\r\nshost->cmd_per_lun = 32;\r\nreturn 0;\r\nexit_free1:\r\nkfree(arr_port);\r\nexit_free2:\r\nkfree(arr_phy);\r\nexit:\r\nreturn -1;\r\n}\r\nstatic void __devinit pm8001_post_sas_ha_init(struct Scsi_Host *shost,\r\nconst struct pm8001_chip_info *chip_info)\r\n{\r\nint i = 0;\r\nstruct pm8001_hba_info *pm8001_ha;\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\npm8001_ha = sha->lldd_ha;\r\nfor (i = 0; i < chip_info->n_phy; i++) {\r\nsha->sas_phy[i] = &pm8001_ha->phy[i].sas_phy;\r\nsha->sas_port[i] = &pm8001_ha->port[i].sas_port;\r\n}\r\nsha->sas_ha_name = DRV_NAME;\r\nsha->dev = pm8001_ha->dev;\r\nsha->lldd_module = THIS_MODULE;\r\nsha->sas_addr = &pm8001_ha->sas_addr[0];\r\nsha->num_phys = chip_info->n_phy;\r\nsha->lldd_max_execute_num = 1;\r\nsha->lldd_queue_size = PM8001_CAN_QUEUE;\r\nsha->core.shost = shost;\r\n}\r\nstatic void pm8001_init_sas_add(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu8 i;\r\n#ifdef PM8001_READ_VPD\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nstruct pm8001_ioctl_payload payload;\r\npm8001_ha->nvmd_completion = &completion;\r\npayload.minor_function = 0;\r\npayload.length = 128;\r\npayload.func_specific = kzalloc(128, GFP_KERNEL);\r\nPM8001_CHIP_DISP->get_nvmd_req(pm8001_ha, &payload);\r\nwait_for_completion(&completion);\r\nfor (i = 0; i < pm8001_ha->chip->n_phy; i++) {\r\nmemcpy(&pm8001_ha->phy[i].dev_sas_addr, pm8001_ha->sas_addr,\r\nSAS_ADDR_SIZE);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("phy %d sas_addr = %016llx \n", i,\r\npm8001_ha->phy[i].dev_sas_addr));\r\n}\r\n#else\r\nfor (i = 0; i < pm8001_ha->chip->n_phy; i++) {\r\npm8001_ha->phy[i].dev_sas_addr = 0x50010c600047f9d0ULL;\r\npm8001_ha->phy[i].dev_sas_addr =\r\ncpu_to_be64((u64)\r\n(*(u64 *)&pm8001_ha->phy[i].dev_sas_addr));\r\n}\r\nmemcpy(pm8001_ha->sas_addr, &pm8001_ha->phy[0].dev_sas_addr,\r\nSAS_ADDR_SIZE);\r\n#endif\r\n}\r\nstatic u32 pm8001_setup_msix(struct pm8001_hba_info *pm8001_ha,\r\nirq_handler_t irq_handler)\r\n{\r\nu32 i = 0, j = 0;\r\nu32 number_of_intr = 1;\r\nint flag = 0;\r\nu32 max_entry;\r\nint rc;\r\nmax_entry = sizeof(pm8001_ha->msix_entries) /\r\nsizeof(pm8001_ha->msix_entries[0]);\r\nflag |= IRQF_DISABLED;\r\nfor (i = 0; i < max_entry ; i++)\r\npm8001_ha->msix_entries[i].entry = i;\r\nrc = pci_enable_msix(pm8001_ha->pdev, pm8001_ha->msix_entries,\r\nnumber_of_intr);\r\npm8001_ha->number_of_intr = number_of_intr;\r\nif (!rc) {\r\nfor (i = 0; i < number_of_intr; i++) {\r\nif (request_irq(pm8001_ha->msix_entries[i].vector,\r\nirq_handler, flag, DRV_NAME,\r\nSHOST_TO_SAS_HA(pm8001_ha->shost))) {\r\nfor (j = 0; j < i; j++)\r\nfree_irq(\r\npm8001_ha->msix_entries[j].vector,\r\nSHOST_TO_SAS_HA(pm8001_ha->shost));\r\npci_disable_msix(pm8001_ha->pdev);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic u32 pm8001_request_irq(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nstruct pci_dev *pdev;\r\nirq_handler_t irq_handler = pm8001_interrupt;\r\nint rc;\r\npdev = pm8001_ha->pdev;\r\n#ifdef PM8001_USE_MSIX\r\nif (pci_find_capability(pdev, PCI_CAP_ID_MSIX))\r\nreturn pm8001_setup_msix(pm8001_ha, irq_handler);\r\nelse\r\ngoto intx;\r\n#endif\r\nintx:\r\nrc = request_irq(pdev->irq, irq_handler, IRQF_SHARED, DRV_NAME,\r\nSHOST_TO_SAS_HA(pm8001_ha->shost));\r\nreturn rc;\r\n}\r\nstatic int __devinit pm8001_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nunsigned int rc;\r\nu32 pci_reg;\r\nstruct pm8001_hba_info *pm8001_ha;\r\nstruct Scsi_Host *shost = NULL;\r\nconst struct pm8001_chip_info *chip;\r\ndev_printk(KERN_INFO, &pdev->dev,\r\n"pm8001: driver version %s\n", DRV_VERSION);\r\nrc = pci_enable_device(pdev);\r\nif (rc)\r\ngoto err_out_enable;\r\npci_set_master(pdev);\r\npci_read_config_dword(pdev, PCI_COMMAND, &pci_reg);\r\npci_reg |= 0x157;\r\npci_write_config_dword(pdev, PCI_COMMAND, pci_reg);\r\nrc = pci_request_regions(pdev, DRV_NAME);\r\nif (rc)\r\ngoto err_out_disable;\r\nrc = pci_go_44(pdev);\r\nif (rc)\r\ngoto err_out_regions;\r\nshost = scsi_host_alloc(&pm8001_sht, sizeof(void *));\r\nif (!shost) {\r\nrc = -ENOMEM;\r\ngoto err_out_regions;\r\n}\r\nchip = &pm8001_chips[ent->driver_data];\r\nSHOST_TO_SAS_HA(shost) =\r\nkzalloc(sizeof(struct sas_ha_struct), GFP_KERNEL);\r\nif (!SHOST_TO_SAS_HA(shost)) {\r\nrc = -ENOMEM;\r\ngoto err_out_free_host;\r\n}\r\nrc = pm8001_prep_sas_ha_init(shost, chip);\r\nif (rc) {\r\nrc = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\npci_set_drvdata(pdev, SHOST_TO_SAS_HA(shost));\r\npm8001_ha = pm8001_pci_alloc(pdev, chip_8001, shost);\r\nif (!pm8001_ha) {\r\nrc = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\nlist_add_tail(&pm8001_ha->list, &hba_list);\r\nPM8001_CHIP_DISP->chip_soft_rst(pm8001_ha, 0x252acbcd);\r\nrc = PM8001_CHIP_DISP->chip_init(pm8001_ha);\r\nif (rc)\r\ngoto err_out_ha_free;\r\nrc = scsi_add_host(shost, &pdev->dev);\r\nif (rc)\r\ngoto err_out_ha_free;\r\nrc = pm8001_request_irq(pm8001_ha);\r\nif (rc)\r\ngoto err_out_shost;\r\nPM8001_CHIP_DISP->interrupt_enable(pm8001_ha);\r\npm8001_init_sas_add(pm8001_ha);\r\npm8001_post_sas_ha_init(shost, chip);\r\nrc = sas_register_ha(SHOST_TO_SAS_HA(shost));\r\nif (rc)\r\ngoto err_out_shost;\r\nscsi_scan_host(pm8001_ha->shost);\r\nreturn 0;\r\nerr_out_shost:\r\nscsi_remove_host(pm8001_ha->shost);\r\nerr_out_ha_free:\r\npm8001_free(pm8001_ha);\r\nerr_out_free:\r\nkfree(SHOST_TO_SAS_HA(shost));\r\nerr_out_free_host:\r\nkfree(shost);\r\nerr_out_regions:\r\npci_release_regions(pdev);\r\nerr_out_disable:\r\npci_disable_device(pdev);\r\nerr_out_enable:\r\nreturn rc;\r\n}\r\nstatic void __devexit pm8001_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\r\nstruct pm8001_hba_info *pm8001_ha;\r\nint i;\r\npm8001_ha = sha->lldd_ha;\r\npci_set_drvdata(pdev, NULL);\r\nsas_unregister_ha(sha);\r\nsas_remove_host(pm8001_ha->shost);\r\nlist_del(&pm8001_ha->list);\r\nscsi_remove_host(pm8001_ha->shost);\r\nPM8001_CHIP_DISP->interrupt_disable(pm8001_ha);\r\nPM8001_CHIP_DISP->chip_soft_rst(pm8001_ha, 0x252acbcd);\r\n#ifdef PM8001_USE_MSIX\r\nfor (i = 0; i < pm8001_ha->number_of_intr; i++)\r\nsynchronize_irq(pm8001_ha->msix_entries[i].vector);\r\nfor (i = 0; i < pm8001_ha->number_of_intr; i++)\r\nfree_irq(pm8001_ha->msix_entries[i].vector, sha);\r\npci_disable_msix(pdev);\r\n#else\r\nfree_irq(pm8001_ha->irq, sha);\r\n#endif\r\n#ifdef PM8001_USE_TASKLET\r\ntasklet_kill(&pm8001_ha->tasklet);\r\n#endif\r\npm8001_free(pm8001_ha);\r\nkfree(sha->sas_phy);\r\nkfree(sha->sas_port);\r\nkfree(sha);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int pm8001_pci_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\r\nstruct pm8001_hba_info *pm8001_ha;\r\nint i , pos;\r\nu32 device_state;\r\npm8001_ha = sha->lldd_ha;\r\nflush_workqueue(pm8001_wq);\r\nscsi_block_requests(pm8001_ha->shost);\r\npos = pci_find_capability(pdev, PCI_CAP_ID_PM);\r\nif (pos == 0) {\r\nprintk(KERN_ERR " PCI PM not supported\n");\r\nreturn -ENODEV;\r\n}\r\nPM8001_CHIP_DISP->interrupt_disable(pm8001_ha);\r\nPM8001_CHIP_DISP->chip_soft_rst(pm8001_ha, 0x252acbcd);\r\n#ifdef PM8001_USE_MSIX\r\nfor (i = 0; i < pm8001_ha->number_of_intr; i++)\r\nsynchronize_irq(pm8001_ha->msix_entries[i].vector);\r\nfor (i = 0; i < pm8001_ha->number_of_intr; i++)\r\nfree_irq(pm8001_ha->msix_entries[i].vector, sha);\r\npci_disable_msix(pdev);\r\n#else\r\nfree_irq(pm8001_ha->irq, sha);\r\n#endif\r\n#ifdef PM8001_USE_TASKLET\r\ntasklet_kill(&pm8001_ha->tasklet);\r\n#endif\r\ndevice_state = pci_choose_state(pdev, state);\r\npm8001_printk("pdev=0x%p, slot=%s, entering "\r\n"operating state [D%d]\n", pdev,\r\npm8001_ha->name, device_state);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, device_state);\r\nreturn 0;\r\n}\r\nstatic int pm8001_pci_resume(struct pci_dev *pdev)\r\n{\r\nstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\r\nstruct pm8001_hba_info *pm8001_ha;\r\nint rc;\r\nu32 device_state;\r\npm8001_ha = sha->lldd_ha;\r\ndevice_state = pdev->current_state;\r\npm8001_printk("pdev=0x%p, slot=%s, resuming from previous "\r\n"operating state [D%d]\n", pdev, pm8001_ha->name, device_state);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_enable_wake(pdev, PCI_D0, 0);\r\npci_restore_state(pdev);\r\nrc = pci_enable_device(pdev);\r\nif (rc) {\r\npm8001_printk("slot=%s Enable device failed during resume\n",\r\npm8001_ha->name);\r\ngoto err_out_enable;\r\n}\r\npci_set_master(pdev);\r\nrc = pci_go_44(pdev);\r\nif (rc)\r\ngoto err_out_disable;\r\nPM8001_CHIP_DISP->chip_soft_rst(pm8001_ha, 0x252acbcd);\r\nrc = PM8001_CHIP_DISP->chip_init(pm8001_ha);\r\nif (rc)\r\ngoto err_out_disable;\r\nPM8001_CHIP_DISP->interrupt_disable(pm8001_ha);\r\nrc = pm8001_request_irq(pm8001_ha);\r\nif (rc)\r\ngoto err_out_disable;\r\n#ifdef PM8001_USE_TASKLET\r\ntasklet_init(&pm8001_ha->tasklet, pm8001_tasklet,\r\n(unsigned long)pm8001_ha);\r\n#endif\r\nPM8001_CHIP_DISP->interrupt_enable(pm8001_ha);\r\nscsi_unblock_requests(pm8001_ha->shost);\r\nreturn 0;\r\nerr_out_disable:\r\nscsi_remove_host(pm8001_ha->shost);\r\npci_disable_device(pdev);\r\nerr_out_enable:\r\nreturn rc;\r\n}\r\nstatic int __init pm8001_init(void)\r\n{\r\nint rc = -ENOMEM;\r\npm8001_wq = alloc_workqueue("pm8001", 0, 0);\r\nif (!pm8001_wq)\r\ngoto err;\r\npm8001_id = 0;\r\npm8001_stt = sas_domain_attach_transport(&pm8001_transport_ops);\r\nif (!pm8001_stt)\r\ngoto err_wq;\r\nrc = pci_register_driver(&pm8001_pci_driver);\r\nif (rc)\r\ngoto err_tp;\r\nreturn 0;\r\nerr_tp:\r\nsas_release_transport(pm8001_stt);\r\nerr_wq:\r\ndestroy_workqueue(pm8001_wq);\r\nerr:\r\nreturn rc;\r\n}\r\nstatic void __exit pm8001_exit(void)\r\n{\r\npci_unregister_driver(&pm8001_pci_driver);\r\nsas_release_transport(pm8001_stt);\r\ndestroy_workqueue(pm8001_wq);\r\n}
