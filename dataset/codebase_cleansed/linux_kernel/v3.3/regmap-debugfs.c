static size_t regmap_calc_reg_len(int max_val, char *buf, size_t buf_size)\r\n{\r\nsnprintf(buf, buf_size, "%x", max_val);\r\nreturn strlen(buf);\r\n}\r\nstatic int regmap_open_file(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = inode->i_private;\r\nreturn 0;\r\n}\r\nstatic ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint reg_len, val_len, tot_len;\r\nsize_t buf_pos = 0;\r\nloff_t p = 0;\r\nssize_t ret;\r\nint i;\r\nstruct regmap *map = file->private_data;\r\nchar *buf;\r\nunsigned int val;\r\nif (*ppos < 0 || !count)\r\nreturn -EINVAL;\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nreg_len = regmap_calc_reg_len(map->max_register, buf, count);\r\nval_len = 2 * map->format.val_bytes;\r\ntot_len = reg_len + val_len + 3;\r\nfor (i = 0; i < map->max_register + 1; i++) {\r\nif (!regmap_readable(map, i))\r\ncontinue;\r\nif (regmap_precious(map, i))\r\ncontinue;\r\nif (p >= *ppos) {\r\nif (buf_pos >= count - 1 - tot_len)\r\nbreak;\r\nsnprintf(buf + buf_pos, count - buf_pos, "%.*x: ",\r\nreg_len, i);\r\nbuf_pos += reg_len + 2;\r\nret = regmap_read(map, i, &val);\r\nif (ret == 0)\r\nsnprintf(buf + buf_pos, count - buf_pos,\r\n"%.*x", val_len, val);\r\nelse\r\nmemset(buf + buf_pos, 'X', val_len);\r\nbuf_pos += 2 * map->format.val_bytes;\r\nbuf[buf_pos++] = '\n';\r\n}\r\np += tot_len;\r\n}\r\nret = buf_pos;\r\nif (copy_to_user(user_buf, buf, buf_pos)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\n*ppos += buf_pos;\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t regmap_access_read_file(struct file *file,\r\nchar __user *user_buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nint reg_len, tot_len;\r\nsize_t buf_pos = 0;\r\nloff_t p = 0;\r\nssize_t ret;\r\nint i;\r\nstruct regmap *map = file->private_data;\r\nchar *buf;\r\nif (*ppos < 0 || !count)\r\nreturn -EINVAL;\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nreg_len = regmap_calc_reg_len(map->max_register, buf, count);\r\ntot_len = reg_len + 10;\r\nfor (i = 0; i < map->max_register + 1; i++) {\r\nif (!regmap_readable(map, i) && !regmap_writeable(map, i))\r\ncontinue;\r\nif (p >= *ppos) {\r\nif (buf_pos >= count - 1 - tot_len)\r\nbreak;\r\nsnprintf(buf + buf_pos, count - buf_pos,\r\n"%.*x: %c %c %c %c\n",\r\nreg_len, i,\r\nregmap_readable(map, i) ? 'y' : 'n',\r\nregmap_writeable(map, i) ? 'y' : 'n',\r\nregmap_volatile(map, i) ? 'y' : 'n',\r\nregmap_precious(map, i) ? 'y' : 'n');\r\nbuf_pos += tot_len;\r\n}\r\np += tot_len;\r\n}\r\nret = buf_pos;\r\nif (copy_to_user(user_buf, buf, buf_pos)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\n*ppos += buf_pos;\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nvoid regmap_debugfs_init(struct regmap *map)\r\n{\r\nmap->debugfs = debugfs_create_dir(dev_name(map->dev),\r\nregmap_debugfs_root);\r\nif (!map->debugfs) {\r\ndev_warn(map->dev, "Failed to create debugfs directory\n");\r\nreturn;\r\n}\r\nif (map->max_register) {\r\ndebugfs_create_file("registers", 0400, map->debugfs,\r\nmap, &regmap_map_fops);\r\ndebugfs_create_file("access", 0400, map->debugfs,\r\nmap, &regmap_access_fops);\r\n}\r\n}\r\nvoid regmap_debugfs_exit(struct regmap *map)\r\n{\r\ndebugfs_remove_recursive(map->debugfs);\r\n}\r\nvoid regmap_debugfs_initcall(void)\r\n{\r\nregmap_debugfs_root = debugfs_create_dir("regmap", NULL);\r\nif (!regmap_debugfs_root) {\r\npr_warn("regmap: Failed to create debugfs root\n");\r\nreturn;\r\n}\r\n}
