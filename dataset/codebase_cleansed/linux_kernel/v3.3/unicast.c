static struct sk_buff *frag_merge_packet(struct list_head *head,\r\nstruct frag_packet_list_entry *tfp,\r\nstruct sk_buff *skb)\r\n{\r\nstruct unicast_frag_packet *up =\r\n(struct unicast_frag_packet *)skb->data;\r\nstruct sk_buff *tmp_skb;\r\nstruct unicast_packet *unicast_packet;\r\nint hdr_len = sizeof(*unicast_packet);\r\nint uni_diff = sizeof(*up) - hdr_len;\r\nif (up->flags & UNI_FRAG_HEAD) {\r\ntmp_skb = tfp->skb;\r\n} else {\r\ntmp_skb = skb;\r\nskb = tfp->skb;\r\n}\r\nif (skb_linearize(skb) < 0 || skb_linearize(tmp_skb) < 0)\r\ngoto err;\r\nskb_pull(tmp_skb, sizeof(*up));\r\nif (pskb_expand_head(skb, 0, tmp_skb->len, GFP_ATOMIC) < 0)\r\ngoto err;\r\ntfp->skb = NULL;\r\ntfp->seqno = 0;\r\nlist_move_tail(&tfp->list, head);\r\nmemcpy(skb_put(skb, tmp_skb->len), tmp_skb->data, tmp_skb->len);\r\nkfree_skb(tmp_skb);\r\nmemmove(skb->data + uni_diff, skb->data, hdr_len);\r\nunicast_packet = (struct unicast_packet *) skb_pull(skb, uni_diff);\r\nunicast_packet->packet_type = BAT_UNICAST;\r\nreturn skb;\r\nerr:\r\nkfree_skb(tfp->skb);\r\nreturn NULL;\r\n}\r\nstatic void frag_create_entry(struct list_head *head, struct sk_buff *skb)\r\n{\r\nstruct frag_packet_list_entry *tfp;\r\nstruct unicast_frag_packet *up =\r\n(struct unicast_frag_packet *)skb->data;\r\ntfp = list_entry((head)->prev, typeof(*tfp), list);\r\nkfree_skb(tfp->skb);\r\ntfp->seqno = ntohs(up->seqno);\r\ntfp->skb = skb;\r\nlist_move(&tfp->list, head);\r\nreturn;\r\n}\r\nstatic int frag_create_buffer(struct list_head *head)\r\n{\r\nint i;\r\nstruct frag_packet_list_entry *tfp;\r\nfor (i = 0; i < FRAG_BUFFER_SIZE; i++) {\r\ntfp = kmalloc(sizeof(*tfp), GFP_ATOMIC);\r\nif (!tfp) {\r\nfrag_list_free(head);\r\nreturn -ENOMEM;\r\n}\r\ntfp->skb = NULL;\r\ntfp->seqno = 0;\r\nINIT_LIST_HEAD(&tfp->list);\r\nlist_add(&tfp->list, head);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct frag_packet_list_entry *frag_search_packet(struct list_head *head,\r\nconst struct unicast_frag_packet *up)\r\n{\r\nstruct frag_packet_list_entry *tfp;\r\nstruct unicast_frag_packet *tmp_up = NULL;\r\nuint16_t search_seqno;\r\nif (up->flags & UNI_FRAG_HEAD)\r\nsearch_seqno = ntohs(up->seqno)+1;\r\nelse\r\nsearch_seqno = ntohs(up->seqno)-1;\r\nlist_for_each_entry(tfp, head, list) {\r\nif (!tfp->skb)\r\ncontinue;\r\nif (tfp->seqno == ntohs(up->seqno))\r\ngoto mov_tail;\r\ntmp_up = (struct unicast_frag_packet *)tfp->skb->data;\r\nif (tfp->seqno == search_seqno) {\r\nif ((tmp_up->flags & UNI_FRAG_HEAD) !=\r\n(up->flags & UNI_FRAG_HEAD))\r\nreturn tfp;\r\nelse\r\ngoto mov_tail;\r\n}\r\n}\r\nreturn NULL;\r\nmov_tail:\r\nlist_move_tail(&tfp->list, head);\r\nreturn NULL;\r\n}\r\nvoid frag_list_free(struct list_head *head)\r\n{\r\nstruct frag_packet_list_entry *pf, *tmp_pf;\r\nif (!list_empty(head)) {\r\nlist_for_each_entry_safe(pf, tmp_pf, head, list) {\r\nkfree_skb(pf->skb);\r\nlist_del(&pf->list);\r\nkfree(pf);\r\n}\r\n}\r\nreturn;\r\n}\r\nint frag_reassemble_skb(struct sk_buff *skb, struct bat_priv *bat_priv,\r\nstruct sk_buff **new_skb)\r\n{\r\nstruct orig_node *orig_node;\r\nstruct frag_packet_list_entry *tmp_frag_entry;\r\nint ret = NET_RX_DROP;\r\nstruct unicast_frag_packet *unicast_packet =\r\n(struct unicast_frag_packet *)skb->data;\r\n*new_skb = NULL;\r\norig_node = orig_hash_find(bat_priv, unicast_packet->orig);\r\nif (!orig_node)\r\ngoto out;\r\norig_node->last_frag_packet = jiffies;\r\nif (list_empty(&orig_node->frag_list) &&\r\nfrag_create_buffer(&orig_node->frag_list)) {\r\npr_debug("couldn't create frag buffer\n");\r\ngoto out;\r\n}\r\ntmp_frag_entry = frag_search_packet(&orig_node->frag_list,\r\nunicast_packet);\r\nif (!tmp_frag_entry) {\r\nfrag_create_entry(&orig_node->frag_list, skb);\r\nret = NET_RX_SUCCESS;\r\ngoto out;\r\n}\r\n*new_skb = frag_merge_packet(&orig_node->frag_list, tmp_frag_entry,\r\nskb);\r\nif (*new_skb)\r\nret = NET_RX_SUCCESS;\r\nout:\r\nif (orig_node)\r\norig_node_free_ref(orig_node);\r\nreturn ret;\r\n}\r\nint frag_send_skb(struct sk_buff *skb, struct bat_priv *bat_priv,\r\nstruct hard_iface *hard_iface, const uint8_t dstaddr[])\r\n{\r\nstruct unicast_packet tmp_uc, *unicast_packet;\r\nstruct hard_iface *primary_if;\r\nstruct sk_buff *frag_skb;\r\nstruct unicast_frag_packet *frag1, *frag2;\r\nint uc_hdr_len = sizeof(*unicast_packet);\r\nint ucf_hdr_len = sizeof(*frag1);\r\nint data_len = skb->len - uc_hdr_len;\r\nint large_tail = 0, ret = NET_RX_DROP;\r\nuint16_t seqno;\r\nprimary_if = primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto dropped;\r\nfrag_skb = dev_alloc_skb(data_len - (data_len / 2) + ucf_hdr_len);\r\nif (!frag_skb)\r\ngoto dropped;\r\nskb_reserve(frag_skb, ucf_hdr_len);\r\nunicast_packet = (struct unicast_packet *) skb->data;\r\nmemcpy(&tmp_uc, unicast_packet, uc_hdr_len);\r\nskb_split(skb, frag_skb, data_len / 2 + uc_hdr_len);\r\nif (my_skb_head_push(skb, ucf_hdr_len - uc_hdr_len) < 0 ||\r\nmy_skb_head_push(frag_skb, ucf_hdr_len) < 0)\r\ngoto drop_frag;\r\nfrag1 = (struct unicast_frag_packet *)skb->data;\r\nfrag2 = (struct unicast_frag_packet *)frag_skb->data;\r\nmemcpy(frag1, &tmp_uc, sizeof(tmp_uc));\r\nfrag1->ttl--;\r\nfrag1->version = COMPAT_VERSION;\r\nfrag1->packet_type = BAT_UNICAST_FRAG;\r\nmemcpy(frag1->orig, primary_if->net_dev->dev_addr, ETH_ALEN);\r\nmemcpy(frag2, frag1, sizeof(*frag2));\r\nif (data_len & 1)\r\nlarge_tail = UNI_FRAG_LARGETAIL;\r\nfrag1->flags = UNI_FRAG_HEAD | large_tail;\r\nfrag2->flags = large_tail;\r\nseqno = atomic_add_return(2, &hard_iface->frag_seqno);\r\nfrag1->seqno = htons(seqno - 1);\r\nfrag2->seqno = htons(seqno);\r\nsend_skb_packet(skb, hard_iface, dstaddr);\r\nsend_skb_packet(frag_skb, hard_iface, dstaddr);\r\nret = NET_RX_SUCCESS;\r\ngoto out;\r\ndrop_frag:\r\nkfree_skb(frag_skb);\r\ndropped:\r\nkfree_skb(skb);\r\nout:\r\nif (primary_if)\r\nhardif_free_ref(primary_if);\r\nreturn ret;\r\n}\r\nint unicast_send_skb(struct sk_buff *skb, struct bat_priv *bat_priv)\r\n{\r\nstruct ethhdr *ethhdr = (struct ethhdr *)skb->data;\r\nstruct unicast_packet *unicast_packet;\r\nstruct orig_node *orig_node;\r\nstruct neigh_node *neigh_node;\r\nint data_len = skb->len;\r\nint ret = 1;\r\nif (is_multicast_ether_addr(ethhdr->h_dest)) {\r\norig_node = gw_get_selected_orig(bat_priv);\r\nif (orig_node)\r\ngoto find_router;\r\n}\r\norig_node = transtable_search(bat_priv, ethhdr->h_source,\r\nethhdr->h_dest);\r\nfind_router:\r\nneigh_node = find_router(bat_priv, orig_node, NULL);\r\nif (!neigh_node)\r\ngoto out;\r\nif (my_skb_head_push(skb, sizeof(*unicast_packet)) < 0)\r\ngoto out;\r\nunicast_packet = (struct unicast_packet *)skb->data;\r\nunicast_packet->version = COMPAT_VERSION;\r\nunicast_packet->packet_type = BAT_UNICAST;\r\nunicast_packet->ttl = TTL;\r\nmemcpy(unicast_packet->dest, orig_node->orig, ETH_ALEN);\r\nunicast_packet->ttvn =\r\n(uint8_t)atomic_read(&orig_node->last_ttvn);\r\nif (atomic_read(&bat_priv->fragmentation) &&\r\ndata_len + sizeof(*unicast_packet) >\r\nneigh_node->if_incoming->net_dev->mtu) {\r\nunicast_packet->ttl++;\r\nret = frag_send_skb(skb, bat_priv,\r\nneigh_node->if_incoming, neigh_node->addr);\r\ngoto out;\r\n}\r\nsend_skb_packet(skb, neigh_node->if_incoming, neigh_node->addr);\r\nret = 0;\r\ngoto out;\r\nout:\r\nif (neigh_node)\r\nneigh_node_free_ref(neigh_node);\r\nif (orig_node)\r\norig_node_free_ref(orig_node);\r\nif (ret == 1)\r\nkfree_skb(skb);\r\nreturn ret;\r\n}
