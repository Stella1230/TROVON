static char *getrev(const char *revision)\r\n{\r\nchar *rev;\r\nchar *p;\r\nif ((p = strchr(revision, ':'))) {\r\nrev = p + 2;\r\np = strchr(rev, '$');\r\n*--p = 0;\r\n} else\r\nrev = "1.0";\r\nreturn rev;\r\n}\r\ndiva_os_message_buffer_s *diva_os_alloc_message_buffer(unsigned long size,\r\nvoid **data_buf)\r\n{\r\ndiva_os_message_buffer_s *dmb = alloc_skb(size, GFP_ATOMIC);\r\nif (dmb) {\r\n*data_buf = skb_put(dmb, size);\r\n}\r\nreturn (dmb);\r\n}\r\nvoid diva_os_free_message_buffer(diva_os_message_buffer_s * dmb)\r\n{\r\nkfree_skb(dmb);\r\n}\r\nstatic int diva_ctl_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct capi_ctr *ctrl = m->private;\r\ndiva_card *card = (diva_card *) ctrl->driverdata;\r\nseq_printf(m, "%s\n", ctrl->name);\r\nseq_printf(m, "Serial No. : %s\n", ctrl->serial);\r\nseq_printf(m, "Id : %d\n", card->Id);\r\nseq_printf(m, "Channels : %d\n", card->d.channels);\r\nreturn 0;\r\n}\r\nstatic int diva_ctl_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, diva_ctl_proc_show, NULL);\r\n}\r\nvoid diva_os_set_controller_struct(struct capi_ctr *ctrl)\r\n{\r\nctrl->driver_name = DRIVERLNAME;\r\nctrl->load_firmware = NULL;\r\nctrl->reset_ctr = NULL;\r\nctrl->proc_fops = &diva_ctl_proc_fops;\r\nctrl->owner = THIS_MODULE;\r\n}\r\nstatic int DIVA_INIT_FUNCTION divacapi_init(void)\r\n{\r\nchar tmprev[32];\r\nint ret = 0;\r\nsprintf(DRIVERRELEASE_CAPI, "%d.%d%s", DRRELMAJOR, DRRELMINOR,\r\nDRRELEXTRA);\r\nprintk(KERN_INFO "%s\n", DRIVERNAME);\r\nprintk(KERN_INFO "%s: Rel:%s Rev:", DRIVERLNAME, DRIVERRELEASE_CAPI);\r\nstrcpy(tmprev, main_revision);\r\nprintk("%s Build: %s(%s)\n", getrev(tmprev),\r\ndiva_capi_common_code_build, DIVA_BUILD);\r\nif (!(init_capifunc())) {\r\nprintk(KERN_ERR "%s: failed init capi_driver.\n",\r\nDRIVERLNAME);\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic void DIVA_EXIT_FUNCTION divacapi_exit(void)\r\n{\r\nfinit_capifunc();\r\nprintk(KERN_INFO "%s: module unloaded.\n", DRIVERLNAME);\r\n}
