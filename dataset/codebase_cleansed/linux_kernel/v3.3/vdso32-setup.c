static int __init vdso_setup(char *s)\r\n{\r\nvdso_enabled = simple_strtoul(s, NULL, 0);\r\nreturn 1;\r\n}\r\nstatic __init void reloc_symtab(Elf32_Ehdr *ehdr,\r\nunsigned offset, unsigned size)\r\n{\r\nElf32_Sym *sym = (void *)ehdr + offset;\r\nunsigned nsym = size / sizeof(*sym);\r\nunsigned i;\r\nfor(i = 0; i < nsym; i++, sym++) {\r\nif (sym->st_shndx == SHN_UNDEF ||\r\nsym->st_shndx == SHN_ABS)\r\ncontinue;\r\nif (sym->st_shndx > SHN_LORESERVE) {\r\nprintk(KERN_INFO "VDSO: unexpected st_shndx %x\n",\r\nsym->st_shndx);\r\ncontinue;\r\n}\r\nswitch(ELF_ST_TYPE(sym->st_info)) {\r\ncase STT_OBJECT:\r\ncase STT_FUNC:\r\ncase STT_SECTION:\r\ncase STT_FILE:\r\nsym->st_value += VDSO_ADDR_ADJUST;\r\n}\r\n}\r\n}\r\nstatic __init void reloc_dyn(Elf32_Ehdr *ehdr, unsigned offset)\r\n{\r\nElf32_Dyn *dyn = (void *)ehdr + offset;\r\nfor(; dyn->d_tag != DT_NULL; dyn++)\r\nswitch(dyn->d_tag) {\r\ncase DT_PLTGOT:\r\ncase DT_HASH:\r\ncase DT_STRTAB:\r\ncase DT_SYMTAB:\r\ncase DT_RELA:\r\ncase DT_INIT:\r\ncase DT_FINI:\r\ncase DT_REL:\r\ncase DT_DEBUG:\r\ncase DT_JMPREL:\r\ncase DT_VERSYM:\r\ncase DT_VERDEF:\r\ncase DT_VERNEED:\r\ncase DT_ADDRRNGLO ... DT_ADDRRNGHI:\r\ndyn->d_un.d_ptr += VDSO_ADDR_ADJUST;\r\nbreak;\r\ncase DT_ENCODING ... OLD_DT_LOOS-1:\r\ncase DT_LOOS ... DT_HIOS-1:\r\nif (dyn->d_tag >= DT_ENCODING &&\r\n(dyn->d_tag & 1) == 0)\r\ndyn->d_un.d_ptr += VDSO_ADDR_ADJUST;\r\nbreak;\r\ncase DT_VERDEFNUM:\r\ncase DT_VERNEEDNUM:\r\ncase DT_FLAGS_1:\r\ncase DT_RELACOUNT:\r\ncase DT_RELCOUNT:\r\ncase DT_VALRNGLO ... DT_VALRNGHI:\r\nbreak;\r\ncase OLD_DT_LOOS ... DT_LOOS-1:\r\ncase DT_HIOS ... DT_VALRNGLO-1:\r\ndefault:\r\nif (dyn->d_tag > DT_ENCODING)\r\nprintk(KERN_INFO "VDSO: unexpected DT_tag %x\n",\r\ndyn->d_tag);\r\nbreak;\r\n}\r\n}\r\nstatic __init void relocate_vdso(Elf32_Ehdr *ehdr)\r\n{\r\nElf32_Phdr *phdr;\r\nElf32_Shdr *shdr;\r\nint i;\r\nBUG_ON(memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0 ||\r\n!elf_check_arch_ia32(ehdr) ||\r\nehdr->e_type != ET_DYN);\r\nehdr->e_entry += VDSO_ADDR_ADJUST;\r\nphdr = (void *)ehdr + ehdr->e_phoff;\r\nfor (i = 0; i < ehdr->e_phnum; i++) {\r\nphdr[i].p_vaddr += VDSO_ADDR_ADJUST;\r\nif (phdr[i].p_type == PT_DYNAMIC)\r\nreloc_dyn(ehdr, phdr[i].p_offset);\r\n}\r\nshdr = (void *)ehdr + ehdr->e_shoff;\r\nfor(i = 0; i < ehdr->e_shnum; i++) {\r\nif (!(shdr[i].sh_flags & SHF_ALLOC))\r\ncontinue;\r\nshdr[i].sh_addr += VDSO_ADDR_ADJUST;\r\nif (shdr[i].sh_type == SHT_SYMTAB ||\r\nshdr[i].sh_type == SHT_DYNSYM)\r\nreloc_symtab(ehdr, shdr[i].sh_offset,\r\nshdr[i].sh_size);\r\n}\r\n}\r\nvoid syscall32_cpu_init(void)\r\n{\r\nchecking_wrmsrl(MSR_IA32_SYSENTER_CS, (u64)__KERNEL_CS);\r\nchecking_wrmsrl(MSR_IA32_SYSENTER_ESP, 0ULL);\r\nchecking_wrmsrl(MSR_IA32_SYSENTER_EIP, (u64)ia32_sysenter_target);\r\nwrmsrl(MSR_CSTAR, ia32_cstar_target);\r\n}\r\nstatic inline void map_compat_vdso(int map)\r\n{\r\n}\r\nvoid enable_sep_cpu(void)\r\n{\r\nint cpu = get_cpu();\r\nstruct tss_struct *tss = &per_cpu(init_tss, cpu);\r\nif (!boot_cpu_has(X86_FEATURE_SEP)) {\r\nput_cpu();\r\nreturn;\r\n}\r\ntss->x86_tss.ss1 = __KERNEL_CS;\r\ntss->x86_tss.sp1 = sizeof(struct tss_struct) + (unsigned long) tss;\r\nwrmsr(MSR_IA32_SYSENTER_CS, __KERNEL_CS, 0);\r\nwrmsr(MSR_IA32_SYSENTER_ESP, tss->x86_tss.sp1, 0);\r\nwrmsr(MSR_IA32_SYSENTER_EIP, (unsigned long) ia32_sysenter_target, 0);\r\nput_cpu();\r\n}\r\nstatic int __init gate_vma_init(void)\r\n{\r\ngate_vma.vm_mm = NULL;\r\ngate_vma.vm_start = FIXADDR_USER_START;\r\ngate_vma.vm_end = FIXADDR_USER_END;\r\ngate_vma.vm_flags = VM_READ | VM_MAYREAD | VM_EXEC | VM_MAYEXEC;\r\ngate_vma.vm_page_prot = __P101;\r\ngate_vma.vm_flags |= VM_ALWAYSDUMP;\r\nreturn 0;\r\n}\r\nstatic void map_compat_vdso(int map)\r\n{\r\nstatic int vdso_mapped;\r\nif (map == vdso_mapped)\r\nreturn;\r\nvdso_mapped = map;\r\n__set_fixmap(FIX_VDSO, page_to_pfn(vdso32_pages[0]) << PAGE_SHIFT,\r\nmap ? PAGE_READONLY_EXEC : PAGE_NONE);\r\nflush_tlb_all();\r\n}\r\nint __init sysenter_setup(void)\r\n{\r\nvoid *syscall_page = (void *)get_zeroed_page(GFP_ATOMIC);\r\nconst void *vsyscall;\r\nsize_t vsyscall_len;\r\nvdso32_pages[0] = virt_to_page(syscall_page);\r\n#ifdef CONFIG_X86_32\r\ngate_vma_init();\r\n#endif\r\nif (vdso32_syscall()) {\r\nvsyscall = &vdso32_syscall_start;\r\nvsyscall_len = &vdso32_syscall_end - &vdso32_syscall_start;\r\n} else if (vdso32_sysenter()){\r\nvsyscall = &vdso32_sysenter_start;\r\nvsyscall_len = &vdso32_sysenter_end - &vdso32_sysenter_start;\r\n} else {\r\nvsyscall = &vdso32_int80_start;\r\nvsyscall_len = &vdso32_int80_end - &vdso32_int80_start;\r\n}\r\nmemcpy(syscall_page, vsyscall, vsyscall_len);\r\nrelocate_vdso(syscall_page);\r\nreturn 0;\r\n}\r\nint arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\nunsigned long addr;\r\nint ret = 0;\r\nbool compat;\r\nif (vdso_enabled == VDSO_DISABLED)\r\nreturn 0;\r\ndown_write(&mm->mmap_sem);\r\ncompat = (vdso_enabled == VDSO_COMPAT);\r\nmap_compat_vdso(compat);\r\nif (compat)\r\naddr = VDSO_HIGH_BASE;\r\nelse {\r\naddr = get_unmapped_area(NULL, 0, PAGE_SIZE, 0, 0);\r\nif (IS_ERR_VALUE(addr)) {\r\nret = addr;\r\ngoto up_fail;\r\n}\r\n}\r\ncurrent->mm->context.vdso = (void *)addr;\r\nif (compat_uses_vma || !compat) {\r\nret = install_special_mapping(mm, addr, PAGE_SIZE,\r\nVM_READ|VM_EXEC|\r\nVM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC|\r\nVM_ALWAYSDUMP,\r\nvdso32_pages);\r\nif (ret)\r\ngoto up_fail;\r\n}\r\ncurrent_thread_info()->sysenter_return =\r\nVDSO32_SYMBOL(addr, SYSENTER_RETURN);\r\nup_fail:\r\nif (ret)\r\ncurrent->mm->context.vdso = NULL;\r\nup_write(&mm->mmap_sem);\r\nreturn ret;\r\n}\r\nstatic __init int ia32_binfmt_init(void)\r\n{\r\nregister_sysctl_table(abi_root_table2);\r\nreturn 0;\r\n}\r\nconst char *arch_vma_name(struct vm_area_struct *vma)\r\n{\r\nif (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso)\r\nreturn "[vdso]";\r\nreturn NULL;\r\n}\r\nstruct vm_area_struct *get_gate_vma(struct mm_struct *mm)\r\n{\r\nif (mm && mm->context.vdso == (void *)VDSO_HIGH_BASE)\r\nreturn &gate_vma;\r\nreturn NULL;\r\n}\r\nint in_gate_area(struct mm_struct *mm, unsigned long addr)\r\n{\r\nconst struct vm_area_struct *vma = get_gate_vma(mm);\r\nreturn vma && addr >= vma->vm_start && addr < vma->vm_end;\r\n}\r\nint in_gate_area_no_mm(unsigned long addr)\r\n{\r\nreturn 0;\r\n}
