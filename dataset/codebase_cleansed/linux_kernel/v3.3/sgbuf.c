int snd_free_sgbuf_pages(struct snd_dma_buffer *dmab)\r\n{\r\nstruct snd_sg_buf *sgbuf = dmab->private_data;\r\nstruct snd_dma_buffer tmpb;\r\nint i;\r\nif (! sgbuf)\r\nreturn -EINVAL;\r\nif (dmab->area)\r\nvunmap(dmab->area);\r\ndmab->area = NULL;\r\ntmpb.dev.type = SNDRV_DMA_TYPE_DEV;\r\ntmpb.dev.dev = sgbuf->dev;\r\nfor (i = 0; i < sgbuf->pages; i++) {\r\nif (!(sgbuf->table[i].addr & ~PAGE_MASK))\r\ncontinue;\r\ntmpb.area = sgbuf->table[i].buf;\r\ntmpb.addr = sgbuf->table[i].addr & PAGE_MASK;\r\ntmpb.bytes = (sgbuf->table[i].addr & ~PAGE_MASK) << PAGE_SHIFT;\r\nsnd_dma_free_pages(&tmpb);\r\n}\r\nkfree(sgbuf->table);\r\nkfree(sgbuf->page_table);\r\nkfree(sgbuf);\r\ndmab->private_data = NULL;\r\nreturn 0;\r\n}\r\nvoid *snd_malloc_sgbuf_pages(struct device *device,\r\nsize_t size, struct snd_dma_buffer *dmab,\r\nsize_t *res_size)\r\n{\r\nstruct snd_sg_buf *sgbuf;\r\nunsigned int i, pages, chunk, maxpages;\r\nstruct snd_dma_buffer tmpb;\r\nstruct snd_sg_page *table;\r\nstruct page **pgtable;\r\ndmab->area = NULL;\r\ndmab->addr = 0;\r\ndmab->private_data = sgbuf = kzalloc(sizeof(*sgbuf), GFP_KERNEL);\r\nif (! sgbuf)\r\nreturn NULL;\r\nsgbuf->dev = device;\r\npages = snd_sgbuf_aligned_pages(size);\r\nsgbuf->tblsize = sgbuf_align_table(pages);\r\ntable = kcalloc(sgbuf->tblsize, sizeof(*table), GFP_KERNEL);\r\nif (!table)\r\ngoto _failed;\r\nsgbuf->table = table;\r\npgtable = kcalloc(sgbuf->tblsize, sizeof(*pgtable), GFP_KERNEL);\r\nif (!pgtable)\r\ngoto _failed;\r\nsgbuf->page_table = pgtable;\r\nmaxpages = MAX_ALLOC_PAGES;\r\nwhile (pages > 0) {\r\nchunk = pages;\r\nif (chunk > maxpages)\r\nchunk = maxpages;\r\nchunk <<= PAGE_SHIFT;\r\nif (snd_dma_alloc_pages_fallback(SNDRV_DMA_TYPE_DEV, device,\r\nchunk, &tmpb) < 0) {\r\nif (!sgbuf->pages)\r\nreturn NULL;\r\nif (!res_size)\r\ngoto _failed;\r\nsize = sgbuf->pages * PAGE_SIZE;\r\nbreak;\r\n}\r\nchunk = tmpb.bytes >> PAGE_SHIFT;\r\nfor (i = 0; i < chunk; i++) {\r\ntable->buf = tmpb.area;\r\ntable->addr = tmpb.addr;\r\nif (!i)\r\ntable->addr |= chunk;\r\ntable++;\r\n*pgtable++ = virt_to_page(tmpb.area);\r\ntmpb.area += PAGE_SIZE;\r\ntmpb.addr += PAGE_SIZE;\r\n}\r\nsgbuf->pages += chunk;\r\npages -= chunk;\r\nif (chunk < maxpages)\r\nmaxpages = chunk;\r\n}\r\nsgbuf->size = size;\r\ndmab->area = vmap(sgbuf->page_table, sgbuf->pages, VM_MAP, PAGE_KERNEL);\r\nif (! dmab->area)\r\ngoto _failed;\r\nif (res_size)\r\n*res_size = sgbuf->size;\r\nreturn dmab->area;\r\n_failed:\r\nsnd_free_sgbuf_pages(dmab);\r\nreturn NULL;\r\n}
