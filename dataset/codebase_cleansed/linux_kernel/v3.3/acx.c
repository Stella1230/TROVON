int wl1251_acx_frame_rates(struct wl1251 *wl, u8 ctrl_rate, u8 ctrl_mod,\r\nu8 mgt_rate, u8 mgt_mod)\r\n{\r\nstruct acx_fw_gen_frame_rates *rates;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx frame rates");\r\nrates = kzalloc(sizeof(*rates), GFP_KERNEL);\r\nif (!rates) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nrates->tx_ctrl_frame_rate = ctrl_rate;\r\nrates->tx_ctrl_frame_mod = ctrl_mod;\r\nrates->tx_mgt_frame_rate = mgt_rate;\r\nrates->tx_mgt_frame_mod = mgt_mod;\r\nret = wl1251_cmd_configure(wl, ACX_FW_GEN_FRAME_RATES,\r\nrates, sizeof(*rates));\r\nif (ret < 0) {\r\nwl1251_error("Failed to set FW rates and modulation");\r\ngoto out;\r\n}\r\nout:\r\nkfree(rates);\r\nreturn ret;\r\n}\r\nint wl1251_acx_station_id(struct wl1251 *wl)\r\n{\r\nstruct acx_dot11_station_id *mac;\r\nint ret, i;\r\nwl1251_debug(DEBUG_ACX, "acx dot11_station_id");\r\nmac = kzalloc(sizeof(*mac), GFP_KERNEL);\r\nif (!mac) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nmac->mac[i] = wl->mac_addr[ETH_ALEN - 1 - i];\r\nret = wl1251_cmd_configure(wl, DOT11_STATION_ID, mac, sizeof(*mac));\r\nif (ret < 0)\r\ngoto out;\r\nout:\r\nkfree(mac);\r\nreturn ret;\r\n}\r\nint wl1251_acx_default_key(struct wl1251 *wl, u8 key_id)\r\n{\r\nstruct acx_dot11_default_key *default_key;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx dot11_default_key (%d)", key_id);\r\ndefault_key = kzalloc(sizeof(*default_key), GFP_KERNEL);\r\nif (!default_key) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ndefault_key->id = key_id;\r\nret = wl1251_cmd_configure(wl, DOT11_DEFAULT_KEY,\r\ndefault_key, sizeof(*default_key));\r\nif (ret < 0) {\r\nwl1251_error("Couldn't set default key");\r\ngoto out;\r\n}\r\nwl->default_key = key_id;\r\nout:\r\nkfree(default_key);\r\nreturn ret;\r\n}\r\nint wl1251_acx_wake_up_conditions(struct wl1251 *wl, u8 wake_up_event,\r\nu8 listen_interval)\r\n{\r\nstruct acx_wake_up_condition *wake_up;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx wake up conditions");\r\nwake_up = kzalloc(sizeof(*wake_up), GFP_KERNEL);\r\nif (!wake_up) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nwake_up->wake_up_event = wake_up_event;\r\nwake_up->listen_interval = listen_interval;\r\nret = wl1251_cmd_configure(wl, ACX_WAKE_UP_CONDITIONS,\r\nwake_up, sizeof(*wake_up));\r\nif (ret < 0) {\r\nwl1251_warning("could not set wake up conditions: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(wake_up);\r\nreturn ret;\r\n}\r\nint wl1251_acx_sleep_auth(struct wl1251 *wl, u8 sleep_auth)\r\n{\r\nstruct acx_sleep_auth *auth;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx sleep auth");\r\nauth = kzalloc(sizeof(*auth), GFP_KERNEL);\r\nif (!auth) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nauth->sleep_auth = sleep_auth;\r\nret = wl1251_cmd_configure(wl, ACX_SLEEP_AUTH, auth, sizeof(*auth));\r\nout:\r\nkfree(auth);\r\nreturn ret;\r\n}\r\nint wl1251_acx_fw_version(struct wl1251 *wl, char *buf, size_t len)\r\n{\r\nstruct acx_revision *rev;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx fw rev");\r\nrev = kzalloc(sizeof(*rev), GFP_KERNEL);\r\nif (!rev) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = wl1251_cmd_interrogate(wl, ACX_FW_REV, rev, sizeof(*rev));\r\nif (ret < 0) {\r\nwl1251_warning("ACX_FW_REV interrogate failed");\r\ngoto out;\r\n}\r\nstrncpy(buf, rev->fw_version, min(len, sizeof(rev->fw_version)));\r\nbuf[min(len, sizeof(rev->fw_version)) - 1] = '\0';\r\nout:\r\nkfree(rev);\r\nreturn ret;\r\n}\r\nint wl1251_acx_tx_power(struct wl1251 *wl, int power)\r\n{\r\nstruct acx_current_tx_power *acx;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx dot11_cur_tx_pwr");\r\nif (power < 0 || power > 25)\r\nreturn -EINVAL;\r\nacx = kzalloc(sizeof(*acx), GFP_KERNEL);\r\nif (!acx) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nacx->current_tx_power = power * 10;\r\nret = wl1251_cmd_configure(wl, DOT11_CUR_TX_PWR, acx, sizeof(*acx));\r\nif (ret < 0) {\r\nwl1251_warning("configure of tx power failed: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(acx);\r\nreturn ret;\r\n}\r\nint wl1251_acx_feature_cfg(struct wl1251 *wl)\r\n{\r\nstruct acx_feature_config *feature;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx feature cfg");\r\nfeature = kzalloc(sizeof(*feature), GFP_KERNEL);\r\nif (!feature) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfeature->data_flow_options = 0;\r\nfeature->options = 0;\r\nret = wl1251_cmd_configure(wl, ACX_FEATURE_CFG,\r\nfeature, sizeof(*feature));\r\nif (ret < 0) {\r\nwl1251_error("Couldn't set HW encryption");\r\ngoto out;\r\n}\r\nout:\r\nkfree(feature);\r\nreturn ret;\r\n}\r\nint wl1251_acx_mem_map(struct wl1251 *wl, struct acx_header *mem_map,\r\nsize_t len)\r\n{\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx mem map");\r\nret = wl1251_cmd_interrogate(wl, ACX_MEM_MAP, mem_map, len);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint wl1251_acx_data_path_params(struct wl1251 *wl,\r\nstruct acx_data_path_params_resp *resp)\r\n{\r\nstruct acx_data_path_params *params;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx data path params");\r\nparams = kzalloc(sizeof(*params), GFP_KERNEL);\r\nif (!params) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nparams->rx_packet_ring_chunk_size = DP_RX_PACKET_RING_CHUNK_SIZE;\r\nparams->tx_packet_ring_chunk_size = DP_TX_PACKET_RING_CHUNK_SIZE;\r\nparams->rx_packet_ring_chunk_num = DP_RX_PACKET_RING_CHUNK_NUM;\r\nparams->tx_packet_ring_chunk_num = DP_TX_PACKET_RING_CHUNK_NUM;\r\nparams->tx_complete_threshold = 1;\r\nparams->tx_complete_ring_depth = FW_TX_CMPLT_BLOCK_SIZE;\r\nparams->tx_complete_timeout = DP_TX_COMPLETE_TIME_OUT;\r\nret = wl1251_cmd_configure(wl, ACX_DATA_PATH_PARAMS,\r\nparams, sizeof(*params));\r\nif (ret < 0)\r\ngoto out;\r\nret = wl1251_cmd_interrogate(wl, ACX_DATA_PATH_PARAMS,\r\nresp, sizeof(*resp));\r\nif (ret < 0) {\r\nwl1251_warning("failed to read data path parameters: %d", ret);\r\ngoto out;\r\n} else if (resp->header.cmd.status != CMD_STATUS_SUCCESS) {\r\nwl1251_warning("data path parameter acx status failed");\r\nret = -EIO;\r\ngoto out;\r\n}\r\nout:\r\nkfree(params);\r\nreturn ret;\r\n}\r\nint wl1251_acx_rx_msdu_life_time(struct wl1251 *wl, u32 life_time)\r\n{\r\nstruct acx_rx_msdu_lifetime *acx;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx rx msdu life time");\r\nacx = kzalloc(sizeof(*acx), GFP_KERNEL);\r\nif (!acx) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nacx->lifetime = life_time;\r\nret = wl1251_cmd_configure(wl, DOT11_RX_MSDU_LIFE_TIME,\r\nacx, sizeof(*acx));\r\nif (ret < 0) {\r\nwl1251_warning("failed to set rx msdu life time: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(acx);\r\nreturn ret;\r\n}\r\nint wl1251_acx_rx_config(struct wl1251 *wl, u32 config, u32 filter)\r\n{\r\nstruct acx_rx_config *rx_config;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx rx config");\r\nrx_config = kzalloc(sizeof(*rx_config), GFP_KERNEL);\r\nif (!rx_config) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nrx_config->config_options = config;\r\nrx_config->filter_options = filter;\r\nret = wl1251_cmd_configure(wl, ACX_RX_CFG,\r\nrx_config, sizeof(*rx_config));\r\nif (ret < 0) {\r\nwl1251_warning("failed to set rx config: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(rx_config);\r\nreturn ret;\r\n}\r\nint wl1251_acx_pd_threshold(struct wl1251 *wl)\r\n{\r\nstruct acx_packet_detection *pd;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx data pd threshold");\r\npd = kzalloc(sizeof(*pd), GFP_KERNEL);\r\nif (!pd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = wl1251_cmd_configure(wl, ACX_PD_THRESHOLD, pd, sizeof(*pd));\r\nif (ret < 0) {\r\nwl1251_warning("failed to set pd threshold: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(pd);\r\nreturn ret;\r\n}\r\nint wl1251_acx_slot(struct wl1251 *wl, enum acx_slot_type slot_time)\r\n{\r\nstruct acx_slot *slot;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx slot");\r\nslot = kzalloc(sizeof(*slot), GFP_KERNEL);\r\nif (!slot) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nslot->wone_index = STATION_WONE_INDEX;\r\nslot->slot_time = slot_time;\r\nret = wl1251_cmd_configure(wl, ACX_SLOT, slot, sizeof(*slot));\r\nif (ret < 0) {\r\nwl1251_warning("failed to set slot time: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(slot);\r\nreturn ret;\r\n}\r\nint wl1251_acx_group_address_tbl(struct wl1251 *wl)\r\n{\r\nstruct acx_dot11_grp_addr_tbl *acx;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx group address tbl");\r\nacx = kzalloc(sizeof(*acx), GFP_KERNEL);\r\nif (!acx) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nacx->enabled = 0;\r\nacx->num_groups = 0;\r\nmemset(acx->mac_table, 0, ADDRESS_GROUP_MAX_LEN);\r\nret = wl1251_cmd_configure(wl, DOT11_GROUP_ADDRESS_TBL,\r\nacx, sizeof(*acx));\r\nif (ret < 0) {\r\nwl1251_warning("failed to set group addr table: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(acx);\r\nreturn ret;\r\n}\r\nint wl1251_acx_service_period_timeout(struct wl1251 *wl)\r\n{\r\nstruct acx_rx_timeout *rx_timeout;\r\nint ret;\r\nrx_timeout = kzalloc(sizeof(*rx_timeout), GFP_KERNEL);\r\nif (!rx_timeout) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nwl1251_debug(DEBUG_ACX, "acx service period timeout");\r\nrx_timeout->ps_poll_timeout = RX_TIMEOUT_PS_POLL_DEF;\r\nrx_timeout->upsd_timeout = RX_TIMEOUT_UPSD_DEF;\r\nret = wl1251_cmd_configure(wl, ACX_SERVICE_PERIOD_TIMEOUT,\r\nrx_timeout, sizeof(*rx_timeout));\r\nif (ret < 0) {\r\nwl1251_warning("failed to set service period timeout: %d",\r\nret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(rx_timeout);\r\nreturn ret;\r\n}\r\nint wl1251_acx_rts_threshold(struct wl1251 *wl, u16 rts_threshold)\r\n{\r\nstruct acx_rts_threshold *rts;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx rts threshold");\r\nrts = kzalloc(sizeof(*rts), GFP_KERNEL);\r\nif (!rts) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nrts->threshold = rts_threshold;\r\nret = wl1251_cmd_configure(wl, DOT11_RTS_THRESHOLD, rts, sizeof(*rts));\r\nif (ret < 0) {\r\nwl1251_warning("failed to set rts threshold: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(rts);\r\nreturn ret;\r\n}\r\nint wl1251_acx_beacon_filter_opt(struct wl1251 *wl, bool enable_filter)\r\n{\r\nstruct acx_beacon_filter_option *beacon_filter;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx beacon filter opt");\r\nbeacon_filter = kzalloc(sizeof(*beacon_filter), GFP_KERNEL);\r\nif (!beacon_filter) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nbeacon_filter->enable = enable_filter;\r\nbeacon_filter->max_num_beacons = 0;\r\nret = wl1251_cmd_configure(wl, ACX_BEACON_FILTER_OPT,\r\nbeacon_filter, sizeof(*beacon_filter));\r\nif (ret < 0) {\r\nwl1251_warning("failed to set beacon filter opt: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(beacon_filter);\r\nreturn ret;\r\n}\r\nint wl1251_acx_beacon_filter_table(struct wl1251 *wl)\r\n{\r\nstruct acx_beacon_filter_ie_table *ie_table;\r\nint idx = 0;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx beacon filter table");\r\nie_table = kzalloc(sizeof(*ie_table), GFP_KERNEL);\r\nif (!ie_table) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nie_table->num_ie = 1;\r\nie_table->table[idx++] = BEACON_FILTER_IE_ID_CHANNEL_SWITCH_ANN;\r\nie_table->table[idx++] = BEACON_RULE_PASS_ON_APPEARANCE;\r\nret = wl1251_cmd_configure(wl, ACX_BEACON_FILTER_TABLE,\r\nie_table, sizeof(*ie_table));\r\nif (ret < 0) {\r\nwl1251_warning("failed to set beacon filter table: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(ie_table);\r\nreturn ret;\r\n}\r\nint wl1251_acx_conn_monit_params(struct wl1251 *wl)\r\n{\r\nstruct acx_conn_monit_params *acx;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx connection monitor parameters");\r\nacx = kzalloc(sizeof(*acx), GFP_KERNEL);\r\nif (!acx) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nacx->synch_fail_thold = SYNCH_FAIL_DEFAULT_THRESHOLD;\r\nacx->bss_lose_timeout = NO_BEACON_DEFAULT_TIMEOUT;\r\nret = wl1251_cmd_configure(wl, ACX_CONN_MONIT_PARAMS,\r\nacx, sizeof(*acx));\r\nif (ret < 0) {\r\nwl1251_warning("failed to set connection monitor "\r\n"parameters: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(acx);\r\nreturn ret;\r\n}\r\nint wl1251_acx_sg_enable(struct wl1251 *wl)\r\n{\r\nstruct acx_bt_wlan_coex *pta;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx sg enable");\r\npta = kzalloc(sizeof(*pta), GFP_KERNEL);\r\nif (!pta) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\npta->enable = SG_ENABLE;\r\nret = wl1251_cmd_configure(wl, ACX_SG_ENABLE, pta, sizeof(*pta));\r\nif (ret < 0) {\r\nwl1251_warning("failed to set softgemini enable: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(pta);\r\nreturn ret;\r\n}\r\nint wl1251_acx_sg_cfg(struct wl1251 *wl)\r\n{\r\nstruct acx_bt_wlan_coex_param *param;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx sg cfg");\r\nparam = kzalloc(sizeof(*param), GFP_KERNEL);\r\nif (!param) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nparam->min_rate = RATE_INDEX_24MBPS;\r\nparam->bt_hp_max_time = PTA_BT_HP_MAXTIME_DEF;\r\nparam->wlan_hp_max_time = PTA_WLAN_HP_MAX_TIME_DEF;\r\nparam->sense_disable_timer = PTA_SENSE_DISABLE_TIMER_DEF;\r\nparam->rx_time_bt_hp = PTA_PROTECTIVE_RX_TIME_DEF;\r\nparam->tx_time_bt_hp = PTA_PROTECTIVE_TX_TIME_DEF;\r\nparam->rx_time_bt_hp_fast = PTA_PROTECTIVE_RX_TIME_FAST_DEF;\r\nparam->tx_time_bt_hp_fast = PTA_PROTECTIVE_TX_TIME_FAST_DEF;\r\nparam->wlan_cycle_fast = PTA_CYCLE_TIME_FAST_DEF;\r\nparam->bt_anti_starvation_period = PTA_ANTI_STARVE_PERIOD_DEF;\r\nparam->next_bt_lp_packet = PTA_TIMEOUT_NEXT_BT_LP_PACKET_DEF;\r\nparam->wake_up_beacon = PTA_TIME_BEFORE_BEACON_DEF;\r\nparam->hp_dm_max_guard_time = PTA_HPDM_MAX_TIME_DEF;\r\nparam->next_wlan_packet = PTA_TIME_OUT_NEXT_WLAN_DEF;\r\nparam->antenna_type = PTA_ANTENNA_TYPE_DEF;\r\nparam->signal_type = PTA_SIGNALING_TYPE_DEF;\r\nparam->afh_leverage_on = PTA_AFH_LEVERAGE_ON_DEF;\r\nparam->quiet_cycle_num = PTA_NUMBER_QUIET_CYCLE_DEF;\r\nparam->max_cts = PTA_MAX_NUM_CTS_DEF;\r\nparam->wlan_packets_num = PTA_NUMBER_OF_WLAN_PACKETS_DEF;\r\nparam->bt_packets_num = PTA_NUMBER_OF_BT_PACKETS_DEF;\r\nparam->missed_rx_avalanche = PTA_RX_FOR_AVALANCHE_DEF;\r\nparam->wlan_elp_hp = PTA_ELP_HP_DEF;\r\nparam->bt_anti_starvation_cycles = PTA_ANTI_STARVE_NUM_CYCLE_DEF;\r\nparam->ack_mode_dual_ant = PTA_ACK_MODE_DEF;\r\nparam->pa_sd_enable = PTA_ALLOW_PA_SD_DEF;\r\nparam->pta_auto_mode_enable = PTA_AUTO_MODE_NO_CTS_DEF;\r\nparam->bt_hp_respected_num = PTA_BT_HP_RESPECTED_DEF;\r\nret = wl1251_cmd_configure(wl, ACX_SG_CFG, param, sizeof(*param));\r\nif (ret < 0) {\r\nwl1251_warning("failed to set sg config: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(param);\r\nreturn ret;\r\n}\r\nint wl1251_acx_cca_threshold(struct wl1251 *wl)\r\n{\r\nstruct acx_energy_detection *detection;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx cca threshold");\r\ndetection = kzalloc(sizeof(*detection), GFP_KERNEL);\r\nif (!detection) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ndetection->rx_cca_threshold = CCA_THRSH_DISABLE_ENERGY_D;\r\ndetection->tx_energy_detection = 0;\r\nret = wl1251_cmd_configure(wl, ACX_CCA_THRESHOLD,\r\ndetection, sizeof(*detection));\r\nif (ret < 0)\r\nwl1251_warning("failed to set cca threshold: %d", ret);\r\nout:\r\nkfree(detection);\r\nreturn ret;\r\n}\r\nint wl1251_acx_bcn_dtim_options(struct wl1251 *wl)\r\n{\r\nstruct acx_beacon_broadcast *bb;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx bcn dtim options");\r\nbb = kzalloc(sizeof(*bb), GFP_KERNEL);\r\nif (!bb) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nbb->beacon_rx_timeout = BCN_RX_TIMEOUT_DEF_VALUE;\r\nbb->broadcast_timeout = BROADCAST_RX_TIMEOUT_DEF_VALUE;\r\nbb->rx_broadcast_in_ps = RX_BROADCAST_IN_PS_DEF_VALUE;\r\nbb->ps_poll_threshold = CONSECUTIVE_PS_POLL_FAILURE_DEF;\r\nret = wl1251_cmd_configure(wl, ACX_BCN_DTIM_OPTIONS, bb, sizeof(*bb));\r\nif (ret < 0) {\r\nwl1251_warning("failed to set rx config: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(bb);\r\nreturn ret;\r\n}\r\nint wl1251_acx_aid(struct wl1251 *wl, u16 aid)\r\n{\r\nstruct acx_aid *acx_aid;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx aid");\r\nacx_aid = kzalloc(sizeof(*acx_aid), GFP_KERNEL);\r\nif (!acx_aid) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nacx_aid->aid = aid;\r\nret = wl1251_cmd_configure(wl, ACX_AID, acx_aid, sizeof(*acx_aid));\r\nif (ret < 0) {\r\nwl1251_warning("failed to set aid: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(acx_aid);\r\nreturn ret;\r\n}\r\nint wl1251_acx_event_mbox_mask(struct wl1251 *wl, u32 event_mask)\r\n{\r\nstruct acx_event_mask *mask;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx event mbox mask");\r\nmask = kzalloc(sizeof(*mask), GFP_KERNEL);\r\nif (!mask) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmask->high_event_mask = 0xffffffff;\r\nmask->event_mask = event_mask;\r\nret = wl1251_cmd_configure(wl, ACX_EVENT_MBOX_MASK,\r\nmask, sizeof(*mask));\r\nif (ret < 0) {\r\nwl1251_warning("failed to set acx_event_mbox_mask: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(mask);\r\nreturn ret;\r\n}\r\nint wl1251_acx_low_rssi(struct wl1251 *wl, s8 threshold, u8 weight,\r\nu8 depth, enum wl1251_acx_low_rssi_type type)\r\n{\r\nstruct acx_low_rssi *rssi;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx low rssi");\r\nrssi = kzalloc(sizeof(*rssi), GFP_KERNEL);\r\nif (!rssi)\r\nreturn -ENOMEM;\r\nrssi->threshold = threshold;\r\nrssi->weight = weight;\r\nrssi->depth = depth;\r\nrssi->type = type;\r\nret = wl1251_cmd_configure(wl, ACX_LOW_RSSI, rssi, sizeof(*rssi));\r\nif (ret < 0)\r\nwl1251_warning("failed to set low rssi threshold: %d", ret);\r\nkfree(rssi);\r\nreturn ret;\r\n}\r\nint wl1251_acx_set_preamble(struct wl1251 *wl, enum acx_preamble_type preamble)\r\n{\r\nstruct acx_preamble *acx;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx_set_preamble");\r\nacx = kzalloc(sizeof(*acx), GFP_KERNEL);\r\nif (!acx) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nacx->preamble = preamble;\r\nret = wl1251_cmd_configure(wl, ACX_PREAMBLE_TYPE, acx, sizeof(*acx));\r\nif (ret < 0) {\r\nwl1251_warning("Setting of preamble failed: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(acx);\r\nreturn ret;\r\n}\r\nint wl1251_acx_cts_protect(struct wl1251 *wl,\r\nenum acx_ctsprotect_type ctsprotect)\r\n{\r\nstruct acx_ctsprotect *acx;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx_set_ctsprotect");\r\nacx = kzalloc(sizeof(*acx), GFP_KERNEL);\r\nif (!acx) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nacx->ctsprotect = ctsprotect;\r\nret = wl1251_cmd_configure(wl, ACX_CTS_PROTECTION, acx, sizeof(*acx));\r\nif (ret < 0) {\r\nwl1251_warning("Setting of ctsprotect failed: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(acx);\r\nreturn ret;\r\n}\r\nint wl1251_acx_tsf_info(struct wl1251 *wl, u64 *mactime)\r\n{\r\nstruct acx_tsf_info *tsf_info;\r\nint ret;\r\ntsf_info = kzalloc(sizeof(*tsf_info), GFP_KERNEL);\r\nif (!tsf_info) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = wl1251_cmd_interrogate(wl, ACX_TSF_INFO,\r\ntsf_info, sizeof(*tsf_info));\r\nif (ret < 0) {\r\nwl1251_warning("ACX_FW_REV interrogate failed");\r\ngoto out;\r\n}\r\n*mactime = tsf_info->current_tsf_lsb |\r\n(tsf_info->current_tsf_msb << 31);\r\nout:\r\nkfree(tsf_info);\r\nreturn ret;\r\n}\r\nint wl1251_acx_statistics(struct wl1251 *wl, struct acx_statistics *stats)\r\n{\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx statistics");\r\nret = wl1251_cmd_interrogate(wl, ACX_STATISTICS, stats,\r\nsizeof(*stats));\r\nif (ret < 0) {\r\nwl1251_warning("acx statistics failed: %d", ret);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nint wl1251_acx_rate_policies(struct wl1251 *wl)\r\n{\r\nstruct acx_rate_policy *acx;\r\nint ret = 0;\r\nwl1251_debug(DEBUG_ACX, "acx rate policies");\r\nacx = kzalloc(sizeof(*acx), GFP_KERNEL);\r\nif (!acx) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nacx->rate_class_cnt = 1;\r\nacx->rate_class[0].enabled_rates = ACX_RATE_MASK_UNSPECIFIED;\r\nacx->rate_class[0].short_retry_limit = ACX_RATE_RETRY_LIMIT;\r\nacx->rate_class[0].long_retry_limit = ACX_RATE_RETRY_LIMIT;\r\nacx->rate_class[0].aflags = 0;\r\nret = wl1251_cmd_configure(wl, ACX_RATE_POLICY, acx, sizeof(*acx));\r\nif (ret < 0) {\r\nwl1251_warning("Setting of rate policies failed: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(acx);\r\nreturn ret;\r\n}\r\nint wl1251_acx_mem_cfg(struct wl1251 *wl)\r\n{\r\nstruct wl1251_acx_config_memory *mem_conf;\r\nint ret, i;\r\nwl1251_debug(DEBUG_ACX, "acx mem cfg");\r\nmem_conf = kzalloc(sizeof(*mem_conf), GFP_KERNEL);\r\nif (!mem_conf) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmem_conf->mem_config.num_stations = cpu_to_le16(DEFAULT_NUM_STATIONS);\r\nmem_conf->mem_config.rx_mem_block_num = 35;\r\nmem_conf->mem_config.tx_min_mem_block_num = 64;\r\nmem_conf->mem_config.num_tx_queues = MAX_TX_QUEUES;\r\nmem_conf->mem_config.host_if_options = HOSTIF_PKT_RING;\r\nmem_conf->mem_config.num_ssid_profiles = 1;\r\nmem_conf->mem_config.debug_buffer_size =\r\ncpu_to_le16(TRACE_BUFFER_MAX_SIZE);\r\nmem_conf->rx_queue_config.dma_address = 0;\r\nmem_conf->rx_queue_config.num_descs = ACX_RX_DESC_DEF;\r\nmem_conf->rx_queue_config.priority = DEFAULT_RXQ_PRIORITY;\r\nmem_conf->rx_queue_config.type = DEFAULT_RXQ_TYPE;\r\nfor (i = 0; i < MAX_TX_QUEUES; i++) {\r\nmem_conf->tx_queue_config[i].num_descs = ACX_TX_DESC_DEF;\r\nmem_conf->tx_queue_config[i].attributes = i;\r\n}\r\nret = wl1251_cmd_configure(wl, ACX_MEM_CFG, mem_conf,\r\nsizeof(*mem_conf));\r\nif (ret < 0) {\r\nwl1251_warning("wl1251 mem config failed: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(mem_conf);\r\nreturn ret;\r\n}\r\nint wl1251_acx_wr_tbtt_and_dtim(struct wl1251 *wl, u16 tbtt, u8 dtim)\r\n{\r\nstruct wl1251_acx_wr_tbtt_and_dtim *acx;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx tbtt and dtim");\r\nacx = kzalloc(sizeof(*acx), GFP_KERNEL);\r\nif (!acx) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nacx->tbtt = tbtt;\r\nacx->dtim = dtim;\r\nret = wl1251_cmd_configure(wl, ACX_WR_TBTT_AND_DTIM,\r\nacx, sizeof(*acx));\r\nif (ret < 0) {\r\nwl1251_warning("failed to set tbtt and dtim: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(acx);\r\nreturn ret;\r\n}\r\nint wl1251_acx_bet_enable(struct wl1251 *wl, enum wl1251_acx_bet_mode mode,\r\nu8 max_consecutive)\r\n{\r\nstruct wl1251_acx_bet_enable *acx;\r\nint ret;\r\nwl1251_debug(DEBUG_ACX, "acx bet enable");\r\nacx = kzalloc(sizeof(*acx), GFP_KERNEL);\r\nif (!acx) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nacx->enable = mode;\r\nacx->max_consecutive = max_consecutive;\r\nret = wl1251_cmd_configure(wl, ACX_BET_ENABLE, acx, sizeof(*acx));\r\nif (ret < 0) {\r\nwl1251_warning("wl1251 acx bet enable failed: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(acx);\r\nreturn ret;\r\n}\r\nint wl1251_acx_ac_cfg(struct wl1251 *wl, u8 ac, u8 cw_min, u16 cw_max,\r\nu8 aifs, u16 txop)\r\n{\r\nstruct wl1251_acx_ac_cfg *acx;\r\nint ret = 0;\r\nwl1251_debug(DEBUG_ACX, "acx ac cfg %d cw_ming %d cw_max %d "\r\n"aifs %d txop %d", ac, cw_min, cw_max, aifs, txop);\r\nacx = kzalloc(sizeof(*acx), GFP_KERNEL);\r\nif (!acx) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nacx->ac = ac;\r\nacx->cw_min = cw_min;\r\nacx->cw_max = cw_max;\r\nacx->aifsn = aifs;\r\nacx->txop_limit = txop;\r\nret = wl1251_cmd_configure(wl, ACX_AC_CFG, acx, sizeof(*acx));\r\nif (ret < 0) {\r\nwl1251_warning("acx ac cfg failed: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(acx);\r\nreturn ret;\r\n}\r\nint wl1251_acx_tid_cfg(struct wl1251 *wl, u8 queue,\r\nenum wl1251_acx_channel_type type,\r\nu8 tsid, enum wl1251_acx_ps_scheme ps_scheme,\r\nenum wl1251_acx_ack_policy ack_policy)\r\n{\r\nstruct wl1251_acx_tid_cfg *acx;\r\nint ret = 0;\r\nwl1251_debug(DEBUG_ACX, "acx tid cfg %d type %d tsid %d "\r\n"ps_scheme %d ack_policy %d", queue, type, tsid,\r\nps_scheme, ack_policy);\r\nacx = kzalloc(sizeof(*acx), GFP_KERNEL);\r\nif (!acx) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nacx->queue = queue;\r\nacx->type = type;\r\nacx->tsid = tsid;\r\nacx->ps_scheme = ps_scheme;\r\nacx->ack_policy = ack_policy;\r\nret = wl1251_cmd_configure(wl, ACX_TID_CFG, acx, sizeof(*acx));\r\nif (ret < 0) {\r\nwl1251_warning("acx tid cfg failed: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nkfree(acx);\r\nreturn ret;\r\n}
