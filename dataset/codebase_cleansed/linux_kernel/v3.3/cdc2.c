static int __init cdc_do_config(struct usb_configuration *c)\r\n{\r\nint status;\r\nif (gadget_is_otg(c->cdev->gadget)) {\r\nc->descriptors = otg_desc;\r\nc->bmAttributes |= USB_CONFIG_ATT_WAKEUP;\r\n}\r\nstatus = ecm_bind_config(c, hostaddr);\r\nif (status < 0)\r\nreturn status;\r\nstatus = acm_bind_config(c, 0);\r\nif (status < 0)\r\nreturn status;\r\nreturn 0;\r\n}\r\nstatic int __init cdc_bind(struct usb_composite_dev *cdev)\r\n{\r\nint gcnum;\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nint status;\r\nif (!can_support_ecm(cdev->gadget)) {\r\ndev_err(&gadget->dev, "controller '%s' not usable\n",\r\ngadget->name);\r\nreturn -EINVAL;\r\n}\r\nstatus = gether_setup(cdev->gadget, hostaddr);\r\nif (status < 0)\r\nreturn status;\r\nstatus = gserial_setup(cdev->gadget, 1);\r\nif (status < 0)\r\ngoto fail0;\r\ngcnum = usb_gadget_controller_number(gadget);\r\nif (gcnum >= 0)\r\ndevice_desc.bcdDevice = cpu_to_le16(0x0300 | gcnum);\r\nelse {\r\nWARNING(cdev, "controller '%s' not recognized; trying %s\n",\r\ngadget->name,\r\ncdc_config_driver.label);\r\ndevice_desc.bcdDevice =\r\ncpu_to_le16(0x0300 | 0x0099);\r\n}\r\nsnprintf(manufacturer, sizeof manufacturer, "%s %s with %s",\r\ninit_utsname()->sysname, init_utsname()->release,\r\ngadget->name);\r\nstatus = usb_string_id(cdev);\r\nif (status < 0)\r\ngoto fail1;\r\nstrings_dev[STRING_MANUFACTURER_IDX].id = status;\r\ndevice_desc.iManufacturer = status;\r\nstatus = usb_string_id(cdev);\r\nif (status < 0)\r\ngoto fail1;\r\nstrings_dev[STRING_PRODUCT_IDX].id = status;\r\ndevice_desc.iProduct = status;\r\nstatus = usb_add_config(cdev, &cdc_config_driver, cdc_do_config);\r\nif (status < 0)\r\ngoto fail1;\r\ndev_info(&gadget->dev, "%s, version: " DRIVER_VERSION "\n",\r\nDRIVER_DESC);\r\nreturn 0;\r\nfail1:\r\ngserial_cleanup();\r\nfail0:\r\ngether_cleanup();\r\nreturn status;\r\n}\r\nstatic int __exit cdc_unbind(struct usb_composite_dev *cdev)\r\n{\r\ngserial_cleanup();\r\ngether_cleanup();\r\nreturn 0;\r\n}\r\nstatic int __init init(void)\r\n{\r\nreturn usb_composite_probe(&cdc_driver, cdc_bind);\r\n}\r\nstatic void __exit cleanup(void)\r\n{\r\nusb_composite_unregister(&cdc_driver);\r\n}
