static struct layout *find_layout_by_id(unsigned int id)\r\n{\r\nstruct layout *l;\r\nl = layouts;\r\nwhile (l->codecs[0].name) {\r\nif (l->layout_id == id)\r\nreturn l;\r\nl++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct layout *find_layout_by_device(unsigned int id)\r\n{\r\nstruct layout *l;\r\nl = layouts;\r\nwhile (l->codecs[0].name) {\r\nif (l->device_id == id)\r\nreturn l;\r\nl++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void use_layout(struct layout *l)\r\n{\r\nint i;\r\nfor (i=0; i<MAX_CODECS_PER_BUS; i++) {\r\nif (l->codecs[i].name) {\r\nrequest_module("snd-aoa-codec-%s", l->codecs[i].name);\r\n}\r\n}\r\n}\r\nstatic int detect_choice_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct layout_dev *ldev = snd_kcontrol_chip(kcontrol);\r\nswitch (kcontrol->private_value) {\r\ncase 0:\r\nucontrol->value.integer.value[0] = ldev->switch_on_headphone;\r\nbreak;\r\ncase 1:\r\nucontrol->value.integer.value[0] = ldev->switch_on_lineout;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int detect_choice_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct layout_dev *ldev = snd_kcontrol_chip(kcontrol);\r\nswitch (kcontrol->private_value) {\r\ncase 0:\r\nldev->switch_on_headphone = !!ucontrol->value.integer.value[0];\r\nbreak;\r\ncase 1:\r\nldev->switch_on_lineout = !!ucontrol->value.integer.value[0];\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nreturn 1;\r\n}\r\nstatic int detected_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct layout_dev *ldev = snd_kcontrol_chip(kcontrol);\r\nint v;\r\nswitch (kcontrol->private_value) {\r\ncase 0:\r\nv = ldev->gpio.methods->get_detect(&ldev->gpio,\r\nAOA_NOTIFY_HEADPHONE);\r\nbreak;\r\ncase 1:\r\nv = ldev->gpio.methods->get_detect(&ldev->gpio,\r\nAOA_NOTIFY_LINE_OUT);\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nucontrol->value.integer.value[0] = v;\r\nreturn 0;\r\n}\r\nstatic int check_codec(struct aoa_codec *codec,\r\nstruct layout_dev *ldev,\r\nstruct codec_connect_info *cci)\r\n{\r\nconst u32 *ref;\r\nchar propname[32];\r\nstruct codec_connection *cc;\r\nif (codec->node && (strcmp(codec->node->name, "codec") == 0)) {\r\nsnprintf(propname, sizeof(propname),\r\n"platform-%s-codec-ref", codec->name);\r\nref = of_get_property(ldev->sound, propname, NULL);\r\nif (!ref) {\r\nprintk(KERN_INFO "snd-aoa-fabric-layout: "\r\n"required property %s not present\n", propname);\r\nreturn -ENODEV;\r\n}\r\nif (*ref != codec->node->phandle) {\r\nprintk(KERN_INFO "snd-aoa-fabric-layout: "\r\n"%s doesn't match!\n", propname);\r\nreturn -ENODEV;\r\n}\r\n} else {\r\nif (layouts_list_items != 1) {\r\nprintk(KERN_INFO "snd-aoa-fabric-layout: "\r\n"more than one soundbus, but no references.\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\ncodec->soundbus_dev = ldev->sdev;\r\ncodec->gpio = &ldev->gpio;\r\ncc = cci->connections;\r\nif (!cc)\r\nreturn -EINVAL;\r\nprintk(KERN_INFO "snd-aoa-fabric-layout: can use this codec\n");\r\ncodec->connected = 0;\r\ncodec->fabric_data = cc;\r\nwhile (cc->connected) {\r\ncodec->connected |= 1<<cc->codec_bit;\r\ncc++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int layout_found_codec(struct aoa_codec *codec)\r\n{\r\nstruct layout_dev *ldev;\r\nint i;\r\nlist_for_each_entry(ldev, &layouts_list, list) {\r\nfor (i=0; i<MAX_CODECS_PER_BUS; i++) {\r\nif (!ldev->layout->codecs[i].name)\r\ncontinue;\r\nif (strcmp(ldev->layout->codecs[i].name, codec->name) == 0) {\r\nif (check_codec(codec,\r\nldev,\r\n&ldev->layout->codecs[i]) == 0)\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void layout_remove_codec(struct aoa_codec *codec)\r\n{\r\nint i;\r\ncodec->soundbus_dev = NULL;\r\ncodec->gpio = NULL;\r\nfor (i=0; i<MAX_CODECS_PER_BUS; i++) {\r\n}\r\n}\r\nstatic void layout_notify(void *data)\r\n{\r\nstruct layout_dev_ptr *dptr = data;\r\nstruct layout_dev *ldev;\r\nint v, update;\r\nstruct snd_kcontrol *detected, *c;\r\nstruct snd_card *card = aoa_get_card();\r\nldev = dptr->ptr;\r\nif (data == &ldev->selfptr_headphone) {\r\nv = ldev->gpio.methods->get_detect(&ldev->gpio, AOA_NOTIFY_HEADPHONE);\r\ndetected = ldev->headphone_detected_ctrl;\r\nupdate = ldev->switch_on_headphone;\r\nif (update) {\r\nldev->gpio.methods->set_speakers(&ldev->gpio, !v);\r\nldev->gpio.methods->set_headphone(&ldev->gpio, v);\r\nldev->gpio.methods->set_lineout(&ldev->gpio, 0);\r\n}\r\n} else if (data == &ldev->selfptr_lineout) {\r\nv = ldev->gpio.methods->get_detect(&ldev->gpio, AOA_NOTIFY_LINE_OUT);\r\ndetected = ldev->lineout_detected_ctrl;\r\nupdate = ldev->switch_on_lineout;\r\nif (update) {\r\nldev->gpio.methods->set_speakers(&ldev->gpio, !v);\r\nldev->gpio.methods->set_headphone(&ldev->gpio, 0);\r\nldev->gpio.methods->set_lineout(&ldev->gpio, v);\r\n}\r\n} else\r\nreturn;\r\nif (detected)\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &detected->id);\r\nif (update) {\r\nc = ldev->headphone_ctrl;\r\nif (c)\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &c->id);\r\nc = ldev->speaker_ctrl;\r\nif (c)\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &c->id);\r\nc = ldev->lineout_ctrl;\r\nif (c)\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &c->id);\r\n}\r\n}\r\nstatic void layout_attached_codec(struct aoa_codec *codec)\r\n{\r\nstruct codec_connection *cc;\r\nstruct snd_kcontrol *ctl;\r\nint headphones, lineout;\r\nstruct layout_dev *ldev = layout_device;\r\ncc = codec->fabric_data;\r\nheadphones = codec->gpio->methods->get_detect(codec->gpio,\r\nAOA_NOTIFY_HEADPHONE);\r\nlineout = codec->gpio->methods->get_detect(codec->gpio,\r\nAOA_NOTIFY_LINE_OUT);\r\nif (codec->gpio->methods->set_master) {\r\nctl = snd_ctl_new1(&master_ctl, codec->gpio);\r\nldev->master_ctrl = ctl;\r\naoa_snd_ctl_add(ctl);\r\n}\r\nwhile (cc->connected) {\r\nif (cc->connected & CC_SPEAKERS) {\r\nif (headphones <= 0 && lineout <= 0)\r\nldev->gpio.methods->set_speakers(codec->gpio, 1);\r\nctl = snd_ctl_new1(&speakers_ctl, codec->gpio);\r\nldev->speaker_ctrl = ctl;\r\naoa_snd_ctl_add(ctl);\r\n}\r\nif (cc->connected & CC_HEADPHONE) {\r\nif (headphones == 1)\r\nldev->gpio.methods->set_headphone(codec->gpio, 1);\r\nctl = snd_ctl_new1(&headphone_ctl, codec->gpio);\r\nldev->headphone_ctrl = ctl;\r\naoa_snd_ctl_add(ctl);\r\nldev->have_headphone_detect =\r\n!ldev->gpio.methods\r\n->set_notify(&ldev->gpio,\r\nAOA_NOTIFY_HEADPHONE,\r\nlayout_notify,\r\n&ldev->selfptr_headphone);\r\nif (ldev->have_headphone_detect) {\r\nctl = snd_ctl_new1(&headphone_detect_choice,\r\nldev);\r\naoa_snd_ctl_add(ctl);\r\nctl = snd_ctl_new1(&headphone_detected,\r\nldev);\r\nldev->headphone_detected_ctrl = ctl;\r\naoa_snd_ctl_add(ctl);\r\n}\r\n}\r\nif (cc->connected & CC_LINEOUT) {\r\nif (lineout == 1)\r\nldev->gpio.methods->set_lineout(codec->gpio, 1);\r\nctl = snd_ctl_new1(&lineout_ctl, codec->gpio);\r\nif (cc->connected & CC_LINEOUT_LABELLED_HEADPHONE)\r\nstrlcpy(ctl->id.name,\r\n"Headphone Switch", sizeof(ctl->id.name));\r\nldev->lineout_ctrl = ctl;\r\naoa_snd_ctl_add(ctl);\r\nldev->have_lineout_detect =\r\n!ldev->gpio.methods\r\n->set_notify(&ldev->gpio,\r\nAOA_NOTIFY_LINE_OUT,\r\nlayout_notify,\r\n&ldev->selfptr_lineout);\r\nif (ldev->have_lineout_detect) {\r\nctl = snd_ctl_new1(&lineout_detect_choice,\r\nldev);\r\nif (cc->connected & CC_LINEOUT_LABELLED_HEADPHONE)\r\nstrlcpy(ctl->id.name,\r\n"Headphone Detect Autoswitch",\r\nsizeof(ctl->id.name));\r\naoa_snd_ctl_add(ctl);\r\nctl = snd_ctl_new1(&lineout_detected,\r\nldev);\r\nif (cc->connected & CC_LINEOUT_LABELLED_HEADPHONE)\r\nstrlcpy(ctl->id.name,\r\n"Headphone Detected",\r\nsizeof(ctl->id.name));\r\nldev->lineout_detected_ctrl = ctl;\r\naoa_snd_ctl_add(ctl);\r\n}\r\n}\r\ncc++;\r\n}\r\nif (ldev->have_headphone_detect)\r\nlayout_notify(&ldev->selfptr_headphone);\r\nif (ldev->have_lineout_detect)\r\nlayout_notify(&ldev->selfptr_lineout);\r\n}\r\nstatic int aoa_fabric_layout_probe(struct soundbus_dev *sdev)\r\n{\r\nstruct device_node *sound = NULL;\r\nconst unsigned int *id;\r\nstruct layout *layout = NULL;\r\nstruct layout_dev *ldev = NULL;\r\nint err;\r\nif (layout_device)\r\nreturn -ENODEV;\r\nwhile ((sound = of_get_next_child(sdev->ofdev.dev.of_node, sound))) {\r\nif (sound->type && strcasecmp(sound->type, "soundchip") == 0)\r\nbreak;\r\n}\r\nif (!sound)\r\nreturn -ENODEV;\r\nid = of_get_property(sound, "layout-id", NULL);\r\nif (id) {\r\nlayout = find_layout_by_id(*id);\r\n} else {\r\nid = of_get_property(sound, "device-id", NULL);\r\nif (id)\r\nlayout = find_layout_by_device(*id);\r\n}\r\nif (!layout) {\r\nprintk(KERN_ERR "snd-aoa-fabric-layout: unknown layout\n");\r\ngoto outnodev;\r\n}\r\nldev = kzalloc(sizeof(struct layout_dev), GFP_KERNEL);\r\nif (!ldev)\r\ngoto outnodev;\r\nlayout_device = ldev;\r\nldev->sdev = sdev;\r\nldev->sound = sound;\r\nldev->layout = layout;\r\nldev->gpio.node = sound->parent;\r\nswitch (layout->layout_id) {\r\ncase 0:\r\ncase 41:\r\ncase 51:\r\ncase 58:\r\nldev->gpio.methods = ftr_gpio_methods;\r\nprintk(KERN_DEBUG\r\n"snd-aoa-fabric-layout: Using direct GPIOs\n");\r\nbreak;\r\ndefault:\r\nldev->gpio.methods = pmf_gpio_methods;\r\nprintk(KERN_DEBUG\r\n"snd-aoa-fabric-layout: Using PMF GPIOs\n");\r\n}\r\nldev->selfptr_headphone.ptr = ldev;\r\nldev->selfptr_lineout.ptr = ldev;\r\ndev_set_drvdata(&sdev->ofdev.dev, ldev);\r\nlist_add(&ldev->list, &layouts_list);\r\nlayouts_list_items++;\r\nsdev->pcmid = ldev->layout->pcmid;\r\nif (ldev->layout->busname) {\r\nsdev->pcmname = ldev->layout->busname;\r\n} else {\r\nsdev->pcmname = "Master";\r\n}\r\nldev->gpio.methods->init(&ldev->gpio);\r\nerr = aoa_fabric_register(&layout_fabric, &sdev->ofdev.dev);\r\nif (err && err != -EALREADY) {\r\nprintk(KERN_INFO "snd-aoa-fabric-layout: can't use,"\r\n" another fabric is active!\n");\r\ngoto outlistdel;\r\n}\r\nuse_layout(layout);\r\nldev->switch_on_headphone = 1;\r\nldev->switch_on_lineout = 1;\r\nreturn 0;\r\noutlistdel:\r\nldev->gpio.methods->exit(&ldev->gpio);\r\nsdev->pcmname = NULL;\r\nsdev->pcmid = -1;\r\nlist_del(&ldev->list);\r\nlayouts_list_items--;\r\nkfree(ldev);\r\noutnodev:\r\nof_node_put(sound);\r\nlayout_device = NULL;\r\nreturn -ENODEV;\r\n}\r\nstatic int aoa_fabric_layout_remove(struct soundbus_dev *sdev)\r\n{\r\nstruct layout_dev *ldev = dev_get_drvdata(&sdev->ofdev.dev);\r\nint i;\r\nfor (i=0; i<MAX_CODECS_PER_BUS; i++) {\r\nif (ldev->codecs[i]) {\r\naoa_fabric_unlink_codec(ldev->codecs[i]);\r\n}\r\nldev->codecs[i] = NULL;\r\n}\r\nlist_del(&ldev->list);\r\nlayouts_list_items--;\r\nof_node_put(ldev->sound);\r\nldev->gpio.methods->set_notify(&ldev->gpio,\r\nAOA_NOTIFY_HEADPHONE,\r\nNULL,\r\nNULL);\r\nldev->gpio.methods->set_notify(&ldev->gpio,\r\nAOA_NOTIFY_LINE_OUT,\r\nNULL,\r\nNULL);\r\nldev->gpio.methods->exit(&ldev->gpio);\r\nlayout_device = NULL;\r\nkfree(ldev);\r\nsdev->pcmid = -1;\r\nsdev->pcmname = NULL;\r\nreturn 0;\r\n}\r\nstatic int aoa_fabric_layout_suspend(struct soundbus_dev *sdev, pm_message_t state)\r\n{\r\nstruct layout_dev *ldev = dev_get_drvdata(&sdev->ofdev.dev);\r\nif (ldev->gpio.methods && ldev->gpio.methods->all_amps_off)\r\nldev->gpio.methods->all_amps_off(&ldev->gpio);\r\nreturn 0;\r\n}\r\nstatic int aoa_fabric_layout_resume(struct soundbus_dev *sdev)\r\n{\r\nstruct layout_dev *ldev = dev_get_drvdata(&sdev->ofdev.dev);\r\nif (ldev->gpio.methods && ldev->gpio.methods->all_amps_off)\r\nldev->gpio.methods->all_amps_restore(&ldev->gpio);\r\nreturn 0;\r\n}\r\nstatic int __init aoa_fabric_layout_init(void)\r\n{\r\nint err;\r\nerr = soundbus_register_driver(&aoa_soundbus_driver);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void __exit aoa_fabric_layout_exit(void)\r\n{\r\nsoundbus_unregister_driver(&aoa_soundbus_driver);\r\naoa_fabric_unregister(&layout_fabric);\r\n}
