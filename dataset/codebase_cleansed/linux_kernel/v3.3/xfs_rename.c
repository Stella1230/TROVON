STATIC void\r\nxfs_sort_for_rename(\r\nxfs_inode_t *dp1,\r\nxfs_inode_t *dp2,\r\nxfs_inode_t *ip1,\r\nxfs_inode_t *ip2,\r\nxfs_inode_t **i_tab,\r\nint *num_inodes)\r\n{\r\nxfs_inode_t *temp;\r\nint i, j;\r\ni_tab[0] = dp1;\r\ni_tab[1] = dp2;\r\ni_tab[2] = ip1;\r\nif (ip2) {\r\n*num_inodes = 4;\r\ni_tab[3] = ip2;\r\n} else {\r\n*num_inodes = 3;\r\ni_tab[3] = NULL;\r\n}\r\nfor (i = 0; i < *num_inodes; i++) {\r\nfor (j = 1; j < *num_inodes; j++) {\r\nif (i_tab[j]->i_ino < i_tab[j-1]->i_ino) {\r\ntemp = i_tab[j];\r\ni_tab[j] = i_tab[j-1];\r\ni_tab[j-1] = temp;\r\n}\r\n}\r\n}\r\n}\r\nint\r\nxfs_rename(\r\nxfs_inode_t *src_dp,\r\nstruct xfs_name *src_name,\r\nxfs_inode_t *src_ip,\r\nxfs_inode_t *target_dp,\r\nstruct xfs_name *target_name,\r\nxfs_inode_t *target_ip)\r\n{\r\nxfs_trans_t *tp = NULL;\r\nxfs_mount_t *mp = src_dp->i_mount;\r\nint new_parent;\r\nint src_is_directory;\r\nint error;\r\nxfs_bmap_free_t free_list;\r\nxfs_fsblock_t first_block;\r\nint cancel_flags;\r\nint committed;\r\nxfs_inode_t *inodes[4];\r\nint spaceres;\r\nint num_inodes;\r\ntrace_xfs_rename(src_dp, target_dp, src_name, target_name);\r\nnew_parent = (src_dp != target_dp);\r\nsrc_is_directory = S_ISDIR(src_ip->i_d.di_mode);\r\nif (src_is_directory) {\r\nif (target_ip == NULL && new_parent &&\r\ntarget_dp->i_d.di_nlink >= XFS_MAXLINK) {\r\nerror = XFS_ERROR(EMLINK);\r\ngoto std_return;\r\n}\r\n}\r\nxfs_sort_for_rename(src_dp, target_dp, src_ip, target_ip,\r\ninodes, &num_inodes);\r\nxfs_bmap_init(&free_list, &first_block);\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_RENAME);\r\ncancel_flags = XFS_TRANS_RELEASE_LOG_RES;\r\nspaceres = XFS_RENAME_SPACE_RES(mp, target_name->len);\r\nerror = xfs_trans_reserve(tp, spaceres, XFS_RENAME_LOG_RES(mp), 0,\r\nXFS_TRANS_PERM_LOG_RES, XFS_RENAME_LOG_COUNT);\r\nif (error == ENOSPC) {\r\nspaceres = 0;\r\nerror = xfs_trans_reserve(tp, 0, XFS_RENAME_LOG_RES(mp), 0,\r\nXFS_TRANS_PERM_LOG_RES, XFS_RENAME_LOG_COUNT);\r\n}\r\nif (error) {\r\nxfs_trans_cancel(tp, 0);\r\ngoto std_return;\r\n}\r\nerror = xfs_qm_vop_rename_dqattach(inodes);\r\nif (error) {\r\nxfs_trans_cancel(tp, cancel_flags);\r\ngoto std_return;\r\n}\r\nxfs_lock_inodes(inodes, num_inodes, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, src_dp, XFS_ILOCK_EXCL);\r\nif (new_parent)\r\nxfs_trans_ijoin(tp, target_dp, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, src_ip, XFS_ILOCK_EXCL);\r\nif (target_ip)\r\nxfs_trans_ijoin(tp, target_ip, XFS_ILOCK_EXCL);\r\nif (unlikely((target_dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&\r\n(xfs_get_projid(target_dp) != xfs_get_projid(src_ip)))) {\r\nerror = XFS_ERROR(EXDEV);\r\ngoto error_return;\r\n}\r\nif (target_ip == NULL) {\r\nerror = xfs_dir_canenter(tp, target_dp, target_name, spaceres);\r\nif (error)\r\ngoto error_return;\r\nerror = xfs_dir_createname(tp, target_dp, target_name,\r\nsrc_ip->i_ino, &first_block,\r\n&free_list, spaceres);\r\nif (error == ENOSPC)\r\ngoto error_return;\r\nif (error)\r\ngoto abort_return;\r\nxfs_trans_ichgtime(tp, target_dp,\r\nXFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\r\nif (new_parent && src_is_directory) {\r\nerror = xfs_bumplink(tp, target_dp);\r\nif (error)\r\ngoto abort_return;\r\n}\r\n} else {\r\nif (S_ISDIR(target_ip->i_d.di_mode)) {\r\nif (!(xfs_dir_isempty(target_ip)) ||\r\n(target_ip->i_d.di_nlink > 2)) {\r\nerror = XFS_ERROR(EEXIST);\r\ngoto error_return;\r\n}\r\n}\r\nerror = xfs_dir_replace(tp, target_dp, target_name,\r\nsrc_ip->i_ino,\r\n&first_block, &free_list, spaceres);\r\nif (error)\r\ngoto abort_return;\r\nxfs_trans_ichgtime(tp, target_dp,\r\nXFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\r\nerror = xfs_droplink(tp, target_ip);\r\nif (error)\r\ngoto abort_return;\r\nif (src_is_directory) {\r\nerror = xfs_droplink(tp, target_ip);\r\nif (error)\r\ngoto abort_return;\r\n}\r\n}\r\nif (new_parent && src_is_directory) {\r\nerror = xfs_dir_replace(tp, src_ip, &xfs_name_dotdot,\r\ntarget_dp->i_ino,\r\n&first_block, &free_list, spaceres);\r\nASSERT(error != EEXIST);\r\nif (error)\r\ngoto abort_return;\r\n}\r\nxfs_trans_ichgtime(tp, src_ip, XFS_ICHGTIME_CHG);\r\nxfs_trans_log_inode(tp, src_ip, XFS_ILOG_CORE);\r\nif (src_is_directory && (new_parent || target_ip != NULL)) {\r\nerror = xfs_droplink(tp, src_dp);\r\nif (error)\r\ngoto abort_return;\r\n}\r\nerror = xfs_dir_removename(tp, src_dp, src_name, src_ip->i_ino,\r\n&first_block, &free_list, spaceres);\r\nif (error)\r\ngoto abort_return;\r\nxfs_trans_ichgtime(tp, src_dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\r\nxfs_trans_log_inode(tp, src_dp, XFS_ILOG_CORE);\r\nif (new_parent)\r\nxfs_trans_log_inode(tp, target_dp, XFS_ILOG_CORE);\r\nif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {\r\nxfs_trans_set_sync(tp);\r\n}\r\nerror = xfs_bmap_finish(&tp, &free_list, &committed);\r\nif (error) {\r\nxfs_bmap_cancel(&free_list);\r\nxfs_trans_cancel(tp, (XFS_TRANS_RELEASE_LOG_RES |\r\nXFS_TRANS_ABORT));\r\ngoto std_return;\r\n}\r\nreturn xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\r\nabort_return:\r\ncancel_flags |= XFS_TRANS_ABORT;\r\nerror_return:\r\nxfs_bmap_cancel(&free_list);\r\nxfs_trans_cancel(tp, cancel_flags);\r\nstd_return:\r\nreturn error;\r\n}
