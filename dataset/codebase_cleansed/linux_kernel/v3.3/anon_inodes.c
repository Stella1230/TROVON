static char *anon_inodefs_dname(struct dentry *dentry, char *buffer, int buflen)\r\n{\r\nreturn dynamic_dname(dentry, buffer, buflen, "anon_inode:%s",\r\ndentry->d_name.name);\r\n}\r\nstatic struct dentry *anon_inodefs_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nreturn mount_pseudo(fs_type, "anon_inode:", NULL,\r\n&anon_inodefs_dentry_operations, ANON_INODE_FS_MAGIC);\r\n}\r\nstatic int anon_set_page_dirty(struct page *page)\r\n{\r\nreturn 0;\r\n}\r\nstruct file *anon_inode_getfile(const char *name,\r\nconst struct file_operations *fops,\r\nvoid *priv, int flags)\r\n{\r\nstruct qstr this;\r\nstruct path path;\r\nstruct file *file;\r\nint error;\r\nif (IS_ERR(anon_inode_inode))\r\nreturn ERR_PTR(-ENODEV);\r\nif (fops->owner && !try_module_get(fops->owner))\r\nreturn ERR_PTR(-ENOENT);\r\nerror = -ENOMEM;\r\nthis.name = name;\r\nthis.len = strlen(name);\r\nthis.hash = 0;\r\npath.dentry = d_alloc_pseudo(anon_inode_mnt->mnt_sb, &this);\r\nif (!path.dentry)\r\ngoto err_module;\r\npath.mnt = mntget(anon_inode_mnt);\r\nihold(anon_inode_inode);\r\nd_instantiate(path.dentry, anon_inode_inode);\r\nerror = -ENFILE;\r\nfile = alloc_file(&path, OPEN_FMODE(flags), fops);\r\nif (!file)\r\ngoto err_dput;\r\nfile->f_mapping = anon_inode_inode->i_mapping;\r\nfile->f_pos = 0;\r\nfile->f_flags = flags & (O_ACCMODE | O_NONBLOCK);\r\nfile->f_version = 0;\r\nfile->private_data = priv;\r\nreturn file;\r\nerr_dput:\r\npath_put(&path);\r\nerr_module:\r\nmodule_put(fops->owner);\r\nreturn ERR_PTR(error);\r\n}\r\nint anon_inode_getfd(const char *name, const struct file_operations *fops,\r\nvoid *priv, int flags)\r\n{\r\nint error, fd;\r\nstruct file *file;\r\nerror = get_unused_fd_flags(flags);\r\nif (error < 0)\r\nreturn error;\r\nfd = error;\r\nfile = anon_inode_getfile(name, fops, priv, flags);\r\nif (IS_ERR(file)) {\r\nerror = PTR_ERR(file);\r\ngoto err_put_unused_fd;\r\n}\r\nfd_install(fd, file);\r\nreturn fd;\r\nerr_put_unused_fd:\r\nput_unused_fd(fd);\r\nreturn error;\r\n}\r\nstatic struct inode *anon_inode_mkinode(void)\r\n{\r\nstruct inode *inode = new_inode_pseudo(anon_inode_mnt->mnt_sb);\r\nif (!inode)\r\nreturn ERR_PTR(-ENOMEM);\r\ninode->i_ino = get_next_ino();\r\ninode->i_fop = &anon_inode_fops;\r\ninode->i_mapping->a_ops = &anon_aops;\r\ninode->i_state = I_DIRTY;\r\ninode->i_mode = S_IRUSR | S_IWUSR;\r\ninode->i_uid = current_fsuid();\r\ninode->i_gid = current_fsgid();\r\ninode->i_flags |= S_PRIVATE;\r\ninode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\r\nreturn inode;\r\n}\r\nstatic int __init anon_inode_init(void)\r\n{\r\nint error;\r\nerror = register_filesystem(&anon_inode_fs_type);\r\nif (error)\r\ngoto err_exit;\r\nanon_inode_mnt = kern_mount(&anon_inode_fs_type);\r\nif (IS_ERR(anon_inode_mnt)) {\r\nerror = PTR_ERR(anon_inode_mnt);\r\ngoto err_unregister_filesystem;\r\n}\r\nanon_inode_inode = anon_inode_mkinode();\r\nif (IS_ERR(anon_inode_inode)) {\r\nerror = PTR_ERR(anon_inode_inode);\r\ngoto err_mntput;\r\n}\r\nreturn 0;\r\nerr_mntput:\r\nkern_unmount(anon_inode_mnt);\r\nerr_unregister_filesystem:\r\nunregister_filesystem(&anon_inode_fs_type);\r\nerr_exit:\r\npanic(KERN_ERR "anon_inode_init() failed (%d)\n", error);\r\n}
