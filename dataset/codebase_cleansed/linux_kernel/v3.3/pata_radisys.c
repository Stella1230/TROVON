static void radisys_set_piomode (struct ata_port *ap, struct ata_device *adev)\r\n{\r\nunsigned int pio = adev->pio_mode - XFER_PIO_0;\r\nstruct pci_dev *dev = to_pci_dev(ap->host->dev);\r\nu16 idetm_data;\r\nint control = 0;\r\nstatic const\r\nu8 timings[][2] = { { 0, 0 },\r\n{ 0, 0 },\r\n{ 1, 1 },\r\n{ 2, 2 },\r\n{ 3, 3 }, };\r\nif (pio > 0)\r\ncontrol |= 1;\r\nif (ata_pio_need_iordy(adev))\r\ncontrol |= 2;\r\npci_read_config_word(dev, 0x40, &idetm_data);\r\nidetm_data &= 0xCCCC;\r\nidetm_data |= (control << (4 * adev->devno));\r\nidetm_data |= (timings[pio][0] << 12) |\r\n(timings[pio][1] << 8);\r\npci_write_config_word(dev, 0x40, idetm_data);\r\nap->private_data = adev;\r\n}\r\nstatic void radisys_set_dmamode (struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(ap->host->dev);\r\nu16 idetm_data;\r\nu8 udma_enable;\r\nstatic const\r\nu8 timings[][2] = { { 0, 0 },\r\n{ 0, 0 },\r\n{ 1, 1 },\r\n{ 2, 2 },\r\n{ 3, 3 }, };\r\npci_read_config_word(dev, 0x40, &idetm_data);\r\npci_read_config_byte(dev, 0x48, &udma_enable);\r\nif (adev->dma_mode < XFER_UDMA_0) {\r\nunsigned int mwdma = adev->dma_mode - XFER_MW_DMA_0;\r\nconst unsigned int needed_pio[3] = {\r\nXFER_PIO_0, XFER_PIO_3, XFER_PIO_4\r\n};\r\nint pio = needed_pio[mwdma] - XFER_PIO_0;\r\nint control = 3;\r\nif (adev->pio_mode < needed_pio[mwdma])\r\ncontrol = 1;\r\nidetm_data &= 0xCCCC;\r\nidetm_data |= control << (4 * adev->devno);\r\nidetm_data |= (timings[pio][0] << 12) | (timings[pio][1] << 8);\r\nudma_enable &= ~(1 << adev->devno);\r\n} else {\r\nu8 udma_mode;\r\npci_read_config_byte(dev, 0x4A, &udma_mode);\r\nif (adev->xfer_mode == XFER_UDMA_2)\r\nudma_mode &= ~(2 << (adev->devno * 4));\r\nelse\r\nudma_mode |= (2 << (adev->devno * 4));\r\npci_write_config_byte(dev, 0x4A, udma_mode);\r\nudma_enable |= (1 << adev->devno);\r\n}\r\npci_write_config_word(dev, 0x40, idetm_data);\r\npci_write_config_byte(dev, 0x48, udma_enable);\r\nap->private_data = adev;\r\n}\r\nstatic unsigned int radisys_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ata_device *adev = qc->dev;\r\nif (adev != ap->private_data) {\r\nif (adev->dma_mode < XFER_UDMA_0) {\r\nif (adev->dma_mode)\r\nradisys_set_dmamode(ap, adev);\r\nelse if (adev->pio_mode)\r\nradisys_set_piomode(ap, adev);\r\n}\r\n}\r\nreturn ata_bmdma_qc_issue(qc);\r\n}\r\nstatic int radisys_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstatic const struct ata_port_info info = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA12_ONLY,\r\n.udma_mask = ATA_UDMA24_ONLY,\r\n.port_ops = &radisys_pata_ops,\r\n};\r\nconst struct ata_port_info *ppi[] = { &info, NULL };\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nreturn ata_pci_bmdma_init_one(pdev, ppi, &radisys_sht, NULL, 0);\r\n}\r\nstatic int __init radisys_init(void)\r\n{\r\nreturn pci_register_driver(&radisys_pci_driver);\r\n}\r\nstatic void __exit radisys_exit(void)\r\n{\r\npci_unregister_driver(&radisys_pci_driver);\r\n}
