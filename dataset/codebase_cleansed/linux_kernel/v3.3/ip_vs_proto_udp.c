static int\r\nudp_conn_schedule(int af, struct sk_buff *skb, struct ip_vs_proto_data *pd,\r\nint *verdict, struct ip_vs_conn **cpp)\r\n{\r\nstruct net *net;\r\nstruct ip_vs_service *svc;\r\nstruct udphdr _udph, *uh;\r\nstruct ip_vs_iphdr iph;\r\nip_vs_fill_iphdr(af, skb_network_header(skb), &iph);\r\nuh = skb_header_pointer(skb, iph.len, sizeof(_udph), &_udph);\r\nif (uh == NULL) {\r\n*verdict = NF_DROP;\r\nreturn 0;\r\n}\r\nnet = skb_net(skb);\r\nsvc = ip_vs_service_get(net, af, skb->mark, iph.protocol,\r\n&iph.daddr, uh->dest);\r\nif (svc) {\r\nint ignored;\r\nif (ip_vs_todrop(net_ipvs(net))) {\r\nip_vs_service_put(svc);\r\n*verdict = NF_DROP;\r\nreturn 0;\r\n}\r\n*cpp = ip_vs_schedule(svc, skb, pd, &ignored);\r\nif (!*cpp && ignored <= 0) {\r\nif (!ignored)\r\n*verdict = ip_vs_leave(svc, skb, pd);\r\nelse {\r\nip_vs_service_put(svc);\r\n*verdict = NF_DROP;\r\n}\r\nreturn 0;\r\n}\r\nip_vs_service_put(svc);\r\n}\r\nreturn 1;\r\n}\r\nstatic inline void\r\nudp_fast_csum_update(int af, struct udphdr *uhdr,\r\nconst union nf_inet_addr *oldip,\r\nconst union nf_inet_addr *newip,\r\n__be16 oldport, __be16 newport)\r\n{\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\nuhdr->check =\r\ncsum_fold(ip_vs_check_diff16(oldip->ip6, newip->ip6,\r\nip_vs_check_diff2(oldport, newport,\r\n~csum_unfold(uhdr->check))));\r\nelse\r\n#endif\r\nuhdr->check =\r\ncsum_fold(ip_vs_check_diff4(oldip->ip, newip->ip,\r\nip_vs_check_diff2(oldport, newport,\r\n~csum_unfold(uhdr->check))));\r\nif (!uhdr->check)\r\nuhdr->check = CSUM_MANGLED_0;\r\n}\r\nstatic inline void\r\nudp_partial_csum_update(int af, struct udphdr *uhdr,\r\nconst union nf_inet_addr *oldip,\r\nconst union nf_inet_addr *newip,\r\n__be16 oldlen, __be16 newlen)\r\n{\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\nuhdr->check =\r\n~csum_fold(ip_vs_check_diff16(oldip->ip6, newip->ip6,\r\nip_vs_check_diff2(oldlen, newlen,\r\ncsum_unfold(uhdr->check))));\r\nelse\r\n#endif\r\nuhdr->check =\r\n~csum_fold(ip_vs_check_diff4(oldip->ip, newip->ip,\r\nip_vs_check_diff2(oldlen, newlen,\r\ncsum_unfold(uhdr->check))));\r\n}\r\nstatic int\r\nudp_snat_handler(struct sk_buff *skb,\r\nstruct ip_vs_protocol *pp, struct ip_vs_conn *cp)\r\n{\r\nstruct udphdr *udph;\r\nunsigned int udphoff;\r\nint oldlen;\r\nint payload_csum = 0;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6)\r\nudphoff = sizeof(struct ipv6hdr);\r\nelse\r\n#endif\r\nudphoff = ip_hdrlen(skb);\r\noldlen = skb->len - udphoff;\r\nif (!skb_make_writable(skb, udphoff+sizeof(*udph)))\r\nreturn 0;\r\nif (unlikely(cp->app != NULL)) {\r\nint ret;\r\nif (pp->csum_check && !pp->csum_check(cp->af, skb, pp))\r\nreturn 0;\r\nif (!(ret = ip_vs_app_pkt_out(cp, skb)))\r\nreturn 0;\r\nif (ret == 1)\r\noldlen = skb->len - udphoff;\r\nelse\r\npayload_csum = 1;\r\n}\r\nudph = (void *)skb_network_header(skb) + udphoff;\r\nudph->source = cp->vport;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nudp_partial_csum_update(cp->af, udph, &cp->daddr, &cp->vaddr,\r\nhtons(oldlen),\r\nhtons(skb->len - udphoff));\r\n} else if (!payload_csum && (udph->check != 0)) {\r\nudp_fast_csum_update(cp->af, udph, &cp->daddr, &cp->vaddr,\r\ncp->dport, cp->vport);\r\nif (skb->ip_summed == CHECKSUM_COMPLETE)\r\nskb->ip_summed = (cp->app && pp->csum_check) ?\r\nCHECKSUM_UNNECESSARY : CHECKSUM_NONE;\r\n} else {\r\nudph->check = 0;\r\nskb->csum = skb_checksum(skb, udphoff, skb->len - udphoff, 0);\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6)\r\nudph->check = csum_ipv6_magic(&cp->vaddr.in6,\r\n&cp->caddr.in6,\r\nskb->len - udphoff,\r\ncp->protocol, skb->csum);\r\nelse\r\n#endif\r\nudph->check = csum_tcpudp_magic(cp->vaddr.ip,\r\ncp->caddr.ip,\r\nskb->len - udphoff,\r\ncp->protocol,\r\nskb->csum);\r\nif (udph->check == 0)\r\nudph->check = CSUM_MANGLED_0;\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nIP_VS_DBG(11, "O-pkt: %s O-csum=%d (+%zd)\n",\r\npp->name, udph->check,\r\n(char*)&(udph->check) - (char*)udph);\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nudp_dnat_handler(struct sk_buff *skb,\r\nstruct ip_vs_protocol *pp, struct ip_vs_conn *cp)\r\n{\r\nstruct udphdr *udph;\r\nunsigned int udphoff;\r\nint oldlen;\r\nint payload_csum = 0;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6)\r\nudphoff = sizeof(struct ipv6hdr);\r\nelse\r\n#endif\r\nudphoff = ip_hdrlen(skb);\r\noldlen = skb->len - udphoff;\r\nif (!skb_make_writable(skb, udphoff+sizeof(*udph)))\r\nreturn 0;\r\nif (unlikely(cp->app != NULL)) {\r\nint ret;\r\nif (pp->csum_check && !pp->csum_check(cp->af, skb, pp))\r\nreturn 0;\r\nif (!(ret = ip_vs_app_pkt_in(cp, skb)))\r\nreturn 0;\r\nif (ret == 1)\r\noldlen = skb->len - udphoff;\r\nelse\r\npayload_csum = 1;\r\n}\r\nudph = (void *)skb_network_header(skb) + udphoff;\r\nudph->dest = cp->dport;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nudp_partial_csum_update(cp->af, udph, &cp->vaddr, &cp->daddr,\r\nhtons(oldlen),\r\nhtons(skb->len - udphoff));\r\n} else if (!payload_csum && (udph->check != 0)) {\r\nudp_fast_csum_update(cp->af, udph, &cp->vaddr, &cp->daddr,\r\ncp->vport, cp->dport);\r\nif (skb->ip_summed == CHECKSUM_COMPLETE)\r\nskb->ip_summed = (cp->app && pp->csum_check) ?\r\nCHECKSUM_UNNECESSARY : CHECKSUM_NONE;\r\n} else {\r\nudph->check = 0;\r\nskb->csum = skb_checksum(skb, udphoff, skb->len - udphoff, 0);\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6)\r\nudph->check = csum_ipv6_magic(&cp->caddr.in6,\r\n&cp->daddr.in6,\r\nskb->len - udphoff,\r\ncp->protocol, skb->csum);\r\nelse\r\n#endif\r\nudph->check = csum_tcpudp_magic(cp->caddr.ip,\r\ncp->daddr.ip,\r\nskb->len - udphoff,\r\ncp->protocol,\r\nskb->csum);\r\nif (udph->check == 0)\r\nudph->check = CSUM_MANGLED_0;\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nudp_csum_check(int af, struct sk_buff *skb, struct ip_vs_protocol *pp)\r\n{\r\nstruct udphdr _udph, *uh;\r\nunsigned int udphoff;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\nudphoff = sizeof(struct ipv6hdr);\r\nelse\r\n#endif\r\nudphoff = ip_hdrlen(skb);\r\nuh = skb_header_pointer(skb, udphoff, sizeof(_udph), &_udph);\r\nif (uh == NULL)\r\nreturn 0;\r\nif (uh->check != 0) {\r\nswitch (skb->ip_summed) {\r\ncase CHECKSUM_NONE:\r\nskb->csum = skb_checksum(skb, udphoff,\r\nskb->len - udphoff, 0);\r\ncase CHECKSUM_COMPLETE:\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6) {\r\nif (csum_ipv6_magic(&ipv6_hdr(skb)->saddr,\r\n&ipv6_hdr(skb)->daddr,\r\nskb->len - udphoff,\r\nipv6_hdr(skb)->nexthdr,\r\nskb->csum)) {\r\nIP_VS_DBG_RL_PKT(0, af, pp, skb, 0,\r\n"Failed checksum for");\r\nreturn 0;\r\n}\r\n} else\r\n#endif\r\nif (csum_tcpudp_magic(ip_hdr(skb)->saddr,\r\nip_hdr(skb)->daddr,\r\nskb->len - udphoff,\r\nip_hdr(skb)->protocol,\r\nskb->csum)) {\r\nIP_VS_DBG_RL_PKT(0, af, pp, skb, 0,\r\n"Failed checksum for");\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic inline __u16 udp_app_hashkey(__be16 port)\r\n{\r\nreturn (((__force u16)port >> UDP_APP_TAB_BITS) ^ (__force u16)port)\r\n& UDP_APP_TAB_MASK;\r\n}\r\nstatic int udp_register_app(struct net *net, struct ip_vs_app *inc)\r\n{\r\nstruct ip_vs_app *i;\r\n__u16 hash;\r\n__be16 port = inc->port;\r\nint ret = 0;\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(net, IPPROTO_UDP);\r\nhash = udp_app_hashkey(port);\r\nspin_lock_bh(&ipvs->udp_app_lock);\r\nlist_for_each_entry(i, &ipvs->udp_apps[hash], p_list) {\r\nif (i->port == port) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nlist_add(&inc->p_list, &ipvs->udp_apps[hash]);\r\natomic_inc(&pd->appcnt);\r\nout:\r\nspin_unlock_bh(&ipvs->udp_app_lock);\r\nreturn ret;\r\n}\r\nstatic void\r\nudp_unregister_app(struct net *net, struct ip_vs_app *inc)\r\n{\r\nstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(net, IPPROTO_UDP);\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nspin_lock_bh(&ipvs->udp_app_lock);\r\natomic_dec(&pd->appcnt);\r\nlist_del(&inc->p_list);\r\nspin_unlock_bh(&ipvs->udp_app_lock);\r\n}\r\nstatic int udp_app_conn_bind(struct ip_vs_conn *cp)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(ip_vs_conn_net(cp));\r\nint hash;\r\nstruct ip_vs_app *inc;\r\nint result = 0;\r\nif (IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ)\r\nreturn 0;\r\nhash = udp_app_hashkey(cp->vport);\r\nspin_lock(&ipvs->udp_app_lock);\r\nlist_for_each_entry(inc, &ipvs->udp_apps[hash], p_list) {\r\nif (inc->port == cp->vport) {\r\nif (unlikely(!ip_vs_app_inc_get(inc)))\r\nbreak;\r\nspin_unlock(&ipvs->udp_app_lock);\r\nIP_VS_DBG_BUF(9, "%s(): Binding conn %s:%u->"\r\n"%s:%u to app %s on port %u\n",\r\n__func__,\r\nIP_VS_DBG_ADDR(cp->af, &cp->caddr),\r\nntohs(cp->cport),\r\nIP_VS_DBG_ADDR(cp->af, &cp->vaddr),\r\nntohs(cp->vport),\r\ninc->name, ntohs(inc->port));\r\ncp->app = inc;\r\nif (inc->init_conn)\r\nresult = inc->init_conn(inc, cp);\r\ngoto out;\r\n}\r\n}\r\nspin_unlock(&ipvs->udp_app_lock);\r\nout:\r\nreturn result;\r\n}\r\nstatic const char * udp_state_name(int state)\r\n{\r\nif (state >= IP_VS_UDP_S_LAST)\r\nreturn "ERR!";\r\nreturn udp_state_name_table[state] ? udp_state_name_table[state] : "?";\r\n}\r\nstatic void\r\nudp_state_transition(struct ip_vs_conn *cp, int direction,\r\nconst struct sk_buff *skb,\r\nstruct ip_vs_proto_data *pd)\r\n{\r\nif (unlikely(!pd)) {\r\npr_err("UDP no ns data\n");\r\nreturn;\r\n}\r\ncp->timeout = pd->timeout_table[IP_VS_UDP_S_NORMAL];\r\n}\r\nstatic void __udp_init(struct net *net, struct ip_vs_proto_data *pd)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nip_vs_init_hash_table(ipvs->udp_apps, UDP_APP_TAB_SIZE);\r\nspin_lock_init(&ipvs->udp_app_lock);\r\npd->timeout_table = ip_vs_create_timeout_table((int *)udp_timeouts,\r\nsizeof(udp_timeouts));\r\n}\r\nstatic void __udp_exit(struct net *net, struct ip_vs_proto_data *pd)\r\n{\r\nkfree(pd->timeout_table);\r\n}
