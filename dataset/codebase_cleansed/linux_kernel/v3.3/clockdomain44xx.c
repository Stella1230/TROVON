static int omap4_clkdm_add_wkup_sleep_dep(struct clockdomain *clkdm1,\r\nstruct clockdomain *clkdm2)\r\n{\r\nomap4_cminst_set_inst_reg_bits((1 << clkdm2->dep_bit),\r\nclkdm1->prcm_partition,\r\nclkdm1->cm_inst, clkdm1->clkdm_offs +\r\nOMAP4_CM_STATICDEP);\r\nreturn 0;\r\n}\r\nstatic int omap4_clkdm_del_wkup_sleep_dep(struct clockdomain *clkdm1,\r\nstruct clockdomain *clkdm2)\r\n{\r\nomap4_cminst_clear_inst_reg_bits((1 << clkdm2->dep_bit),\r\nclkdm1->prcm_partition,\r\nclkdm1->cm_inst, clkdm1->clkdm_offs +\r\nOMAP4_CM_STATICDEP);\r\nreturn 0;\r\n}\r\nstatic int omap4_clkdm_read_wkup_sleep_dep(struct clockdomain *clkdm1,\r\nstruct clockdomain *clkdm2)\r\n{\r\nreturn omap4_cminst_read_inst_reg_bits(clkdm1->prcm_partition,\r\nclkdm1->cm_inst, clkdm1->clkdm_offs +\r\nOMAP4_CM_STATICDEP,\r\n(1 << clkdm2->dep_bit));\r\n}\r\nstatic int omap4_clkdm_clear_all_wkup_sleep_deps(struct clockdomain *clkdm)\r\n{\r\nstruct clkdm_dep *cd;\r\nu32 mask = 0;\r\nfor (cd = clkdm->wkdep_srcs; cd && cd->clkdm_name; cd++) {\r\nif (!cd->clkdm)\r\ncontinue;\r\nmask |= 1 << cd->clkdm->dep_bit;\r\natomic_set(&cd->wkdep_usecount, 0);\r\n}\r\nomap4_cminst_clear_inst_reg_bits(mask, clkdm->prcm_partition,\r\nclkdm->cm_inst, clkdm->clkdm_offs +\r\nOMAP4_CM_STATICDEP);\r\nreturn 0;\r\n}\r\nstatic int omap4_clkdm_sleep(struct clockdomain *clkdm)\r\n{\r\nomap4_cminst_clkdm_force_sleep(clkdm->prcm_partition,\r\nclkdm->cm_inst, clkdm->clkdm_offs);\r\nreturn 0;\r\n}\r\nstatic int omap4_clkdm_wakeup(struct clockdomain *clkdm)\r\n{\r\nomap4_cminst_clkdm_force_wakeup(clkdm->prcm_partition,\r\nclkdm->cm_inst, clkdm->clkdm_offs);\r\nreturn 0;\r\n}\r\nstatic void omap4_clkdm_allow_idle(struct clockdomain *clkdm)\r\n{\r\nomap4_cminst_clkdm_enable_hwsup(clkdm->prcm_partition,\r\nclkdm->cm_inst, clkdm->clkdm_offs);\r\n}\r\nstatic void omap4_clkdm_deny_idle(struct clockdomain *clkdm)\r\n{\r\nomap4_cminst_clkdm_disable_hwsup(clkdm->prcm_partition,\r\nclkdm->cm_inst, clkdm->clkdm_offs);\r\n}\r\nstatic int omap4_clkdm_clk_enable(struct clockdomain *clkdm)\r\n{\r\nif (clkdm->flags & CLKDM_CAN_FORCE_WAKEUP)\r\nreturn omap4_clkdm_wakeup(clkdm);\r\nreturn 0;\r\n}\r\nstatic int omap4_clkdm_clk_disable(struct clockdomain *clkdm)\r\n{\r\nbool hwsup = false;\r\nhwsup = omap4_cminst_is_clkdm_in_hwsup(clkdm->prcm_partition,\r\nclkdm->cm_inst, clkdm->clkdm_offs);\r\nif (!hwsup && (clkdm->flags & CLKDM_CAN_FORCE_SLEEP))\r\nomap4_clkdm_sleep(clkdm);\r\nreturn 0;\r\n}
