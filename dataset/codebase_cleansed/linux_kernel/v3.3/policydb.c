static struct policydb_compat_info *policydb_lookup_compat(int version)\r\n{\r\nint i;\r\nstruct policydb_compat_info *info = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(policydb_compat); i++) {\r\nif (policydb_compat[i].version == version) {\r\ninfo = &policydb_compat[i];\r\nbreak;\r\n}\r\n}\r\nreturn info;\r\n}\r\nstatic int roles_init(struct policydb *p)\r\n{\r\nchar *key = NULL;\r\nint rc;\r\nstruct role_datum *role;\r\nrc = -ENOMEM;\r\nrole = kzalloc(sizeof(*role), GFP_KERNEL);\r\nif (!role)\r\ngoto out;\r\nrc = -EINVAL;\r\nrole->value = ++p->p_roles.nprim;\r\nif (role->value != OBJECT_R_VAL)\r\ngoto out;\r\nrc = -ENOMEM;\r\nkey = kstrdup(OBJECT_R, GFP_KERNEL);\r\nif (!key)\r\ngoto out;\r\nrc = hashtab_insert(p->p_roles.table, key, role);\r\nif (rc)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nkfree(key);\r\nkfree(role);\r\nreturn rc;\r\n}\r\nstatic u32 filenametr_hash(struct hashtab *h, const void *k)\r\n{\r\nconst struct filename_trans *ft = k;\r\nunsigned long hash;\r\nunsigned int byte_num;\r\nunsigned char focus;\r\nhash = ft->stype ^ ft->ttype ^ ft->tclass;\r\nbyte_num = 0;\r\nwhile ((focus = ft->name[byte_num++]))\r\nhash = partial_name_hash(focus, hash);\r\nreturn hash & (h->size - 1);\r\n}\r\nstatic int filenametr_cmp(struct hashtab *h, const void *k1, const void *k2)\r\n{\r\nconst struct filename_trans *ft1 = k1;\r\nconst struct filename_trans *ft2 = k2;\r\nint v;\r\nv = ft1->stype - ft2->stype;\r\nif (v)\r\nreturn v;\r\nv = ft1->ttype - ft2->ttype;\r\nif (v)\r\nreturn v;\r\nv = ft1->tclass - ft2->tclass;\r\nif (v)\r\nreturn v;\r\nreturn strcmp(ft1->name, ft2->name);\r\n}\r\nstatic u32 rangetr_hash(struct hashtab *h, const void *k)\r\n{\r\nconst struct range_trans *key = k;\r\nreturn (key->source_type + (key->target_type << 3) +\r\n(key->target_class << 5)) & (h->size - 1);\r\n}\r\nstatic int rangetr_cmp(struct hashtab *h, const void *k1, const void *k2)\r\n{\r\nconst struct range_trans *key1 = k1, *key2 = k2;\r\nint v;\r\nv = key1->source_type - key2->source_type;\r\nif (v)\r\nreturn v;\r\nv = key1->target_type - key2->target_type;\r\nif (v)\r\nreturn v;\r\nv = key1->target_class - key2->target_class;\r\nreturn v;\r\n}\r\nstatic int policydb_init(struct policydb *p)\r\n{\r\nint i, rc;\r\nmemset(p, 0, sizeof(*p));\r\nfor (i = 0; i < SYM_NUM; i++) {\r\nrc = symtab_init(&p->symtab[i], symtab_sizes[i]);\r\nif (rc)\r\ngoto out;\r\n}\r\nrc = avtab_init(&p->te_avtab);\r\nif (rc)\r\ngoto out;\r\nrc = roles_init(p);\r\nif (rc)\r\ngoto out;\r\nrc = cond_policydb_init(p);\r\nif (rc)\r\ngoto out;\r\np->filename_trans = hashtab_create(filenametr_hash, filenametr_cmp, (1 << 10));\r\nif (!p->filename_trans)\r\ngoto out;\r\np->range_tr = hashtab_create(rangetr_hash, rangetr_cmp, 256);\r\nif (!p->range_tr)\r\ngoto out;\r\nebitmap_init(&p->filename_trans_ttypes);\r\nebitmap_init(&p->policycaps);\r\nebitmap_init(&p->permissive_map);\r\nreturn 0;\r\nout:\r\nhashtab_destroy(p->filename_trans);\r\nhashtab_destroy(p->range_tr);\r\nfor (i = 0; i < SYM_NUM; i++)\r\nhashtab_destroy(p->symtab[i].table);\r\nreturn rc;\r\n}\r\nstatic int common_index(void *key, void *datum, void *datap)\r\n{\r\nstruct policydb *p;\r\nstruct common_datum *comdatum;\r\nstruct flex_array *fa;\r\ncomdatum = datum;\r\np = datap;\r\nif (!comdatum->value || comdatum->value > p->p_commons.nprim)\r\nreturn -EINVAL;\r\nfa = p->sym_val_to_name[SYM_COMMONS];\r\nif (flex_array_put_ptr(fa, comdatum->value - 1, key,\r\nGFP_KERNEL | __GFP_ZERO))\r\nBUG();\r\nreturn 0;\r\n}\r\nstatic int class_index(void *key, void *datum, void *datap)\r\n{\r\nstruct policydb *p;\r\nstruct class_datum *cladatum;\r\nstruct flex_array *fa;\r\ncladatum = datum;\r\np = datap;\r\nif (!cladatum->value || cladatum->value > p->p_classes.nprim)\r\nreturn -EINVAL;\r\nfa = p->sym_val_to_name[SYM_CLASSES];\r\nif (flex_array_put_ptr(fa, cladatum->value - 1, key,\r\nGFP_KERNEL | __GFP_ZERO))\r\nBUG();\r\np->class_val_to_struct[cladatum->value - 1] = cladatum;\r\nreturn 0;\r\n}\r\nstatic int role_index(void *key, void *datum, void *datap)\r\n{\r\nstruct policydb *p;\r\nstruct role_datum *role;\r\nstruct flex_array *fa;\r\nrole = datum;\r\np = datap;\r\nif (!role->value\r\n|| role->value > p->p_roles.nprim\r\n|| role->bounds > p->p_roles.nprim)\r\nreturn -EINVAL;\r\nfa = p->sym_val_to_name[SYM_ROLES];\r\nif (flex_array_put_ptr(fa, role->value - 1, key,\r\nGFP_KERNEL | __GFP_ZERO))\r\nBUG();\r\np->role_val_to_struct[role->value - 1] = role;\r\nreturn 0;\r\n}\r\nstatic int type_index(void *key, void *datum, void *datap)\r\n{\r\nstruct policydb *p;\r\nstruct type_datum *typdatum;\r\nstruct flex_array *fa;\r\ntypdatum = datum;\r\np = datap;\r\nif (typdatum->primary) {\r\nif (!typdatum->value\r\n|| typdatum->value > p->p_types.nprim\r\n|| typdatum->bounds > p->p_types.nprim)\r\nreturn -EINVAL;\r\nfa = p->sym_val_to_name[SYM_TYPES];\r\nif (flex_array_put_ptr(fa, typdatum->value - 1, key,\r\nGFP_KERNEL | __GFP_ZERO))\r\nBUG();\r\nfa = p->type_val_to_struct_array;\r\nif (flex_array_put_ptr(fa, typdatum->value - 1, typdatum,\r\nGFP_KERNEL | __GFP_ZERO))\r\nBUG();\r\n}\r\nreturn 0;\r\n}\r\nstatic int user_index(void *key, void *datum, void *datap)\r\n{\r\nstruct policydb *p;\r\nstruct user_datum *usrdatum;\r\nstruct flex_array *fa;\r\nusrdatum = datum;\r\np = datap;\r\nif (!usrdatum->value\r\n|| usrdatum->value > p->p_users.nprim\r\n|| usrdatum->bounds > p->p_users.nprim)\r\nreturn -EINVAL;\r\nfa = p->sym_val_to_name[SYM_USERS];\r\nif (flex_array_put_ptr(fa, usrdatum->value - 1, key,\r\nGFP_KERNEL | __GFP_ZERO))\r\nBUG();\r\np->user_val_to_struct[usrdatum->value - 1] = usrdatum;\r\nreturn 0;\r\n}\r\nstatic int sens_index(void *key, void *datum, void *datap)\r\n{\r\nstruct policydb *p;\r\nstruct level_datum *levdatum;\r\nstruct flex_array *fa;\r\nlevdatum = datum;\r\np = datap;\r\nif (!levdatum->isalias) {\r\nif (!levdatum->level->sens ||\r\nlevdatum->level->sens > p->p_levels.nprim)\r\nreturn -EINVAL;\r\nfa = p->sym_val_to_name[SYM_LEVELS];\r\nif (flex_array_put_ptr(fa, levdatum->level->sens - 1, key,\r\nGFP_KERNEL | __GFP_ZERO))\r\nBUG();\r\n}\r\nreturn 0;\r\n}\r\nstatic int cat_index(void *key, void *datum, void *datap)\r\n{\r\nstruct policydb *p;\r\nstruct cat_datum *catdatum;\r\nstruct flex_array *fa;\r\ncatdatum = datum;\r\np = datap;\r\nif (!catdatum->isalias) {\r\nif (!catdatum->value || catdatum->value > p->p_cats.nprim)\r\nreturn -EINVAL;\r\nfa = p->sym_val_to_name[SYM_CATS];\r\nif (flex_array_put_ptr(fa, catdatum->value - 1, key,\r\nGFP_KERNEL | __GFP_ZERO))\r\nBUG();\r\n}\r\nreturn 0;\r\n}\r\nstatic void hash_eval(struct hashtab *h, const char *hash_name)\r\n{\r\nstruct hashtab_info info;\r\nhashtab_stat(h, &info);\r\nprintk(KERN_DEBUG "SELinux: %s: %d entries and %d/%d buckets used, "\r\n"longest chain length %d\n", hash_name, h->nel,\r\ninfo.slots_used, h->size, info.max_chain_len);\r\n}\r\nstatic void symtab_hash_eval(struct symtab *s)\r\n{\r\nint i;\r\nfor (i = 0; i < SYM_NUM; i++)\r\nhash_eval(s[i].table, symtab_name[i]);\r\n}\r\nstatic inline void hash_eval(struct hashtab *h, char *hash_name)\r\n{\r\n}\r\nstatic int policydb_index(struct policydb *p)\r\n{\r\nint i, rc;\r\nprintk(KERN_DEBUG "SELinux: %d users, %d roles, %d types, %d bools",\r\np->p_users.nprim, p->p_roles.nprim, p->p_types.nprim, p->p_bools.nprim);\r\nif (p->mls_enabled)\r\nprintk(", %d sens, %d cats", p->p_levels.nprim,\r\np->p_cats.nprim);\r\nprintk("\n");\r\nprintk(KERN_DEBUG "SELinux: %d classes, %d rules\n",\r\np->p_classes.nprim, p->te_avtab.nel);\r\n#ifdef DEBUG_HASHES\r\navtab_hash_eval(&p->te_avtab, "rules");\r\nsymtab_hash_eval(p->symtab);\r\n#endif\r\nrc = -ENOMEM;\r\np->class_val_to_struct =\r\nkmalloc(p->p_classes.nprim * sizeof(*(p->class_val_to_struct)),\r\nGFP_KERNEL);\r\nif (!p->class_val_to_struct)\r\ngoto out;\r\nrc = -ENOMEM;\r\np->role_val_to_struct =\r\nkmalloc(p->p_roles.nprim * sizeof(*(p->role_val_to_struct)),\r\nGFP_KERNEL);\r\nif (!p->role_val_to_struct)\r\ngoto out;\r\nrc = -ENOMEM;\r\np->user_val_to_struct =\r\nkmalloc(p->p_users.nprim * sizeof(*(p->user_val_to_struct)),\r\nGFP_KERNEL);\r\nif (!p->user_val_to_struct)\r\ngoto out;\r\nrc = -ENOMEM;\r\np->type_val_to_struct_array = flex_array_alloc(sizeof(struct type_datum *),\r\np->p_types.nprim,\r\nGFP_KERNEL | __GFP_ZERO);\r\nif (!p->type_val_to_struct_array)\r\ngoto out;\r\nrc = flex_array_prealloc(p->type_val_to_struct_array, 0,\r\np->p_types.nprim, GFP_KERNEL | __GFP_ZERO);\r\nif (rc)\r\ngoto out;\r\nrc = cond_init_bool_indexes(p);\r\nif (rc)\r\ngoto out;\r\nfor (i = 0; i < SYM_NUM; i++) {\r\nrc = -ENOMEM;\r\np->sym_val_to_name[i] = flex_array_alloc(sizeof(char *),\r\np->symtab[i].nprim,\r\nGFP_KERNEL | __GFP_ZERO);\r\nif (!p->sym_val_to_name[i])\r\ngoto out;\r\nrc = flex_array_prealloc(p->sym_val_to_name[i],\r\n0, p->symtab[i].nprim,\r\nGFP_KERNEL | __GFP_ZERO);\r\nif (rc)\r\ngoto out;\r\nrc = hashtab_map(p->symtab[i].table, index_f[i], p);\r\nif (rc)\r\ngoto out;\r\n}\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int perm_destroy(void *key, void *datum, void *p)\r\n{\r\nkfree(key);\r\nkfree(datum);\r\nreturn 0;\r\n}\r\nstatic int common_destroy(void *key, void *datum, void *p)\r\n{\r\nstruct common_datum *comdatum;\r\nkfree(key);\r\nif (datum) {\r\ncomdatum = datum;\r\nhashtab_map(comdatum->permissions.table, perm_destroy, NULL);\r\nhashtab_destroy(comdatum->permissions.table);\r\n}\r\nkfree(datum);\r\nreturn 0;\r\n}\r\nstatic int cls_destroy(void *key, void *datum, void *p)\r\n{\r\nstruct class_datum *cladatum;\r\nstruct constraint_node *constraint, *ctemp;\r\nstruct constraint_expr *e, *etmp;\r\nkfree(key);\r\nif (datum) {\r\ncladatum = datum;\r\nhashtab_map(cladatum->permissions.table, perm_destroy, NULL);\r\nhashtab_destroy(cladatum->permissions.table);\r\nconstraint = cladatum->constraints;\r\nwhile (constraint) {\r\ne = constraint->expr;\r\nwhile (e) {\r\nebitmap_destroy(&e->names);\r\netmp = e;\r\ne = e->next;\r\nkfree(etmp);\r\n}\r\nctemp = constraint;\r\nconstraint = constraint->next;\r\nkfree(ctemp);\r\n}\r\nconstraint = cladatum->validatetrans;\r\nwhile (constraint) {\r\ne = constraint->expr;\r\nwhile (e) {\r\nebitmap_destroy(&e->names);\r\netmp = e;\r\ne = e->next;\r\nkfree(etmp);\r\n}\r\nctemp = constraint;\r\nconstraint = constraint->next;\r\nkfree(ctemp);\r\n}\r\nkfree(cladatum->comkey);\r\n}\r\nkfree(datum);\r\nreturn 0;\r\n}\r\nstatic int role_destroy(void *key, void *datum, void *p)\r\n{\r\nstruct role_datum *role;\r\nkfree(key);\r\nif (datum) {\r\nrole = datum;\r\nebitmap_destroy(&role->dominates);\r\nebitmap_destroy(&role->types);\r\n}\r\nkfree(datum);\r\nreturn 0;\r\n}\r\nstatic int type_destroy(void *key, void *datum, void *p)\r\n{\r\nkfree(key);\r\nkfree(datum);\r\nreturn 0;\r\n}\r\nstatic int user_destroy(void *key, void *datum, void *p)\r\n{\r\nstruct user_datum *usrdatum;\r\nkfree(key);\r\nif (datum) {\r\nusrdatum = datum;\r\nebitmap_destroy(&usrdatum->roles);\r\nebitmap_destroy(&usrdatum->range.level[0].cat);\r\nebitmap_destroy(&usrdatum->range.level[1].cat);\r\nebitmap_destroy(&usrdatum->dfltlevel.cat);\r\n}\r\nkfree(datum);\r\nreturn 0;\r\n}\r\nstatic int sens_destroy(void *key, void *datum, void *p)\r\n{\r\nstruct level_datum *levdatum;\r\nkfree(key);\r\nif (datum) {\r\nlevdatum = datum;\r\nebitmap_destroy(&levdatum->level->cat);\r\nkfree(levdatum->level);\r\n}\r\nkfree(datum);\r\nreturn 0;\r\n}\r\nstatic int cat_destroy(void *key, void *datum, void *p)\r\n{\r\nkfree(key);\r\nkfree(datum);\r\nreturn 0;\r\n}\r\nstatic int filenametr_destroy(void *key, void *datum, void *p)\r\n{\r\nstruct filename_trans *ft = key;\r\nkfree(ft->name);\r\nkfree(key);\r\nkfree(datum);\r\ncond_resched();\r\nreturn 0;\r\n}\r\nstatic int range_tr_destroy(void *key, void *datum, void *p)\r\n{\r\nstruct mls_range *rt = datum;\r\nkfree(key);\r\nebitmap_destroy(&rt->level[0].cat);\r\nebitmap_destroy(&rt->level[1].cat);\r\nkfree(datum);\r\ncond_resched();\r\nreturn 0;\r\n}\r\nstatic void ocontext_destroy(struct ocontext *c, int i)\r\n{\r\nif (!c)\r\nreturn;\r\ncontext_destroy(&c->context[0]);\r\ncontext_destroy(&c->context[1]);\r\nif (i == OCON_ISID || i == OCON_FS ||\r\ni == OCON_NETIF || i == OCON_FSUSE)\r\nkfree(c->u.name);\r\nkfree(c);\r\n}\r\nvoid policydb_destroy(struct policydb *p)\r\n{\r\nstruct ocontext *c, *ctmp;\r\nstruct genfs *g, *gtmp;\r\nint i;\r\nstruct role_allow *ra, *lra = NULL;\r\nstruct role_trans *tr, *ltr = NULL;\r\nfor (i = 0; i < SYM_NUM; i++) {\r\ncond_resched();\r\nhashtab_map(p->symtab[i].table, destroy_f[i], NULL);\r\nhashtab_destroy(p->symtab[i].table);\r\n}\r\nfor (i = 0; i < SYM_NUM; i++) {\r\nif (p->sym_val_to_name[i])\r\nflex_array_free(p->sym_val_to_name[i]);\r\n}\r\nkfree(p->class_val_to_struct);\r\nkfree(p->role_val_to_struct);\r\nkfree(p->user_val_to_struct);\r\nif (p->type_val_to_struct_array)\r\nflex_array_free(p->type_val_to_struct_array);\r\navtab_destroy(&p->te_avtab);\r\nfor (i = 0; i < OCON_NUM; i++) {\r\ncond_resched();\r\nc = p->ocontexts[i];\r\nwhile (c) {\r\nctmp = c;\r\nc = c->next;\r\nocontext_destroy(ctmp, i);\r\n}\r\np->ocontexts[i] = NULL;\r\n}\r\ng = p->genfs;\r\nwhile (g) {\r\ncond_resched();\r\nkfree(g->fstype);\r\nc = g->head;\r\nwhile (c) {\r\nctmp = c;\r\nc = c->next;\r\nocontext_destroy(ctmp, OCON_FSUSE);\r\n}\r\ngtmp = g;\r\ng = g->next;\r\nkfree(gtmp);\r\n}\r\np->genfs = NULL;\r\ncond_policydb_destroy(p);\r\nfor (tr = p->role_tr; tr; tr = tr->next) {\r\ncond_resched();\r\nkfree(ltr);\r\nltr = tr;\r\n}\r\nkfree(ltr);\r\nfor (ra = p->role_allow; ra; ra = ra->next) {\r\ncond_resched();\r\nkfree(lra);\r\nlra = ra;\r\n}\r\nkfree(lra);\r\nhashtab_map(p->filename_trans, filenametr_destroy, NULL);\r\nhashtab_destroy(p->filename_trans);\r\nhashtab_map(p->range_tr, range_tr_destroy, NULL);\r\nhashtab_destroy(p->range_tr);\r\nif (p->type_attr_map_array) {\r\nfor (i = 0; i < p->p_types.nprim; i++) {\r\nstruct ebitmap *e;\r\ne = flex_array_get(p->type_attr_map_array, i);\r\nif (!e)\r\ncontinue;\r\nebitmap_destroy(e);\r\n}\r\nflex_array_free(p->type_attr_map_array);\r\n}\r\nebitmap_destroy(&p->filename_trans_ttypes);\r\nebitmap_destroy(&p->policycaps);\r\nebitmap_destroy(&p->permissive_map);\r\nreturn;\r\n}\r\nint policydb_load_isids(struct policydb *p, struct sidtab *s)\r\n{\r\nstruct ocontext *head, *c;\r\nint rc;\r\nrc = sidtab_init(s);\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: out of memory on SID table init\n");\r\ngoto out;\r\n}\r\nhead = p->ocontexts[OCON_ISID];\r\nfor (c = head; c; c = c->next) {\r\nrc = -EINVAL;\r\nif (!c->context[0].user) {\r\nprintk(KERN_ERR "SELinux: SID %s was never defined.\n",\r\nc->u.name);\r\ngoto out;\r\n}\r\nrc = sidtab_insert(s, c->sid[0], &c->context[0]);\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: unable to load initial SID %s.\n",\r\nc->u.name);\r\ngoto out;\r\n}\r\n}\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nint policydb_class_isvalid(struct policydb *p, unsigned int class)\r\n{\r\nif (!class || class > p->p_classes.nprim)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint policydb_role_isvalid(struct policydb *p, unsigned int role)\r\n{\r\nif (!role || role > p->p_roles.nprim)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint policydb_type_isvalid(struct policydb *p, unsigned int type)\r\n{\r\nif (!type || type > p->p_types.nprim)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint policydb_context_isvalid(struct policydb *p, struct context *c)\r\n{\r\nstruct role_datum *role;\r\nstruct user_datum *usrdatum;\r\nif (!c->role || c->role > p->p_roles.nprim)\r\nreturn 0;\r\nif (!c->user || c->user > p->p_users.nprim)\r\nreturn 0;\r\nif (!c->type || c->type > p->p_types.nprim)\r\nreturn 0;\r\nif (c->role != OBJECT_R_VAL) {\r\nrole = p->role_val_to_struct[c->role - 1];\r\nif (!ebitmap_get_bit(&role->types, c->type - 1))\r\nreturn 0;\r\nusrdatum = p->user_val_to_struct[c->user - 1];\r\nif (!usrdatum)\r\nreturn 0;\r\nif (!ebitmap_get_bit(&usrdatum->roles, c->role - 1))\r\nreturn 0;\r\n}\r\nif (!mls_context_isvalid(p, c))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int mls_read_range_helper(struct mls_range *r, void *fp)\r\n{\r\n__le32 buf[2];\r\nu32 items;\r\nint rc;\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\ngoto out;\r\nrc = -EINVAL;\r\nitems = le32_to_cpu(buf[0]);\r\nif (items > ARRAY_SIZE(buf)) {\r\nprintk(KERN_ERR "SELinux: mls: range overflow\n");\r\ngoto out;\r\n}\r\nrc = next_entry(buf, fp, sizeof(u32) * items);\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: mls: truncated range\n");\r\ngoto out;\r\n}\r\nr->level[0].sens = le32_to_cpu(buf[0]);\r\nif (items > 1)\r\nr->level[1].sens = le32_to_cpu(buf[1]);\r\nelse\r\nr->level[1].sens = r->level[0].sens;\r\nrc = ebitmap_read(&r->level[0].cat, fp);\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: mls: error reading low categories\n");\r\ngoto out;\r\n}\r\nif (items > 1) {\r\nrc = ebitmap_read(&r->level[1].cat, fp);\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: mls: error reading high categories\n");\r\ngoto bad_high;\r\n}\r\n} else {\r\nrc = ebitmap_cpy(&r->level[1].cat, &r->level[0].cat);\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: mls: out of memory\n");\r\ngoto bad_high;\r\n}\r\n}\r\nreturn 0;\r\nbad_high:\r\nebitmap_destroy(&r->level[0].cat);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int context_read_and_validate(struct context *c,\r\nstruct policydb *p,\r\nvoid *fp)\r\n{\r\n__le32 buf[3];\r\nint rc;\r\nrc = next_entry(buf, fp, sizeof buf);\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: context truncated\n");\r\ngoto out;\r\n}\r\nc->user = le32_to_cpu(buf[0]);\r\nc->role = le32_to_cpu(buf[1]);\r\nc->type = le32_to_cpu(buf[2]);\r\nif (p->policyvers >= POLICYDB_VERSION_MLS) {\r\nrc = mls_read_range_helper(&c->range, fp);\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: error reading MLS range of context\n");\r\ngoto out;\r\n}\r\n}\r\nrc = -EINVAL;\r\nif (!policydb_context_isvalid(p, c)) {\r\nprintk(KERN_ERR "SELinux: invalid security context\n");\r\ncontext_destroy(c);\r\ngoto out;\r\n}\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int perm_read(struct policydb *p, struct hashtab *h, void *fp)\r\n{\r\nchar *key = NULL;\r\nstruct perm_datum *perdatum;\r\nint rc;\r\n__le32 buf[2];\r\nu32 len;\r\nrc = -ENOMEM;\r\nperdatum = kzalloc(sizeof(*perdatum), GFP_KERNEL);\r\nif (!perdatum)\r\ngoto bad;\r\nrc = next_entry(buf, fp, sizeof buf);\r\nif (rc)\r\ngoto bad;\r\nlen = le32_to_cpu(buf[0]);\r\nperdatum->value = le32_to_cpu(buf[1]);\r\nrc = -ENOMEM;\r\nkey = kmalloc(len + 1, GFP_KERNEL);\r\nif (!key)\r\ngoto bad;\r\nrc = next_entry(key, fp, len);\r\nif (rc)\r\ngoto bad;\r\nkey[len] = '\0';\r\nrc = hashtab_insert(h, key, perdatum);\r\nif (rc)\r\ngoto bad;\r\nreturn 0;\r\nbad:\r\nperm_destroy(key, perdatum, NULL);\r\nreturn rc;\r\n}\r\nstatic int common_read(struct policydb *p, struct hashtab *h, void *fp)\r\n{\r\nchar *key = NULL;\r\nstruct common_datum *comdatum;\r\n__le32 buf[4];\r\nu32 len, nel;\r\nint i, rc;\r\nrc = -ENOMEM;\r\ncomdatum = kzalloc(sizeof(*comdatum), GFP_KERNEL);\r\nif (!comdatum)\r\ngoto bad;\r\nrc = next_entry(buf, fp, sizeof buf);\r\nif (rc)\r\ngoto bad;\r\nlen = le32_to_cpu(buf[0]);\r\ncomdatum->value = le32_to_cpu(buf[1]);\r\nrc = symtab_init(&comdatum->permissions, PERM_SYMTAB_SIZE);\r\nif (rc)\r\ngoto bad;\r\ncomdatum->permissions.nprim = le32_to_cpu(buf[2]);\r\nnel = le32_to_cpu(buf[3]);\r\nrc = -ENOMEM;\r\nkey = kmalloc(len + 1, GFP_KERNEL);\r\nif (!key)\r\ngoto bad;\r\nrc = next_entry(key, fp, len);\r\nif (rc)\r\ngoto bad;\r\nkey[len] = '\0';\r\nfor (i = 0; i < nel; i++) {\r\nrc = perm_read(p, comdatum->permissions.table, fp);\r\nif (rc)\r\ngoto bad;\r\n}\r\nrc = hashtab_insert(h, key, comdatum);\r\nif (rc)\r\ngoto bad;\r\nreturn 0;\r\nbad:\r\ncommon_destroy(key, comdatum, NULL);\r\nreturn rc;\r\n}\r\nstatic int read_cons_helper(struct constraint_node **nodep, int ncons,\r\nint allowxtarget, void *fp)\r\n{\r\nstruct constraint_node *c, *lc;\r\nstruct constraint_expr *e, *le;\r\n__le32 buf[3];\r\nu32 nexpr;\r\nint rc, i, j, depth;\r\nlc = NULL;\r\nfor (i = 0; i < ncons; i++) {\r\nc = kzalloc(sizeof(*c), GFP_KERNEL);\r\nif (!c)\r\nreturn -ENOMEM;\r\nif (lc)\r\nlc->next = c;\r\nelse\r\n*nodep = c;\r\nrc = next_entry(buf, fp, (sizeof(u32) * 2));\r\nif (rc)\r\nreturn rc;\r\nc->permissions = le32_to_cpu(buf[0]);\r\nnexpr = le32_to_cpu(buf[1]);\r\nle = NULL;\r\ndepth = -1;\r\nfor (j = 0; j < nexpr; j++) {\r\ne = kzalloc(sizeof(*e), GFP_KERNEL);\r\nif (!e)\r\nreturn -ENOMEM;\r\nif (le)\r\nle->next = e;\r\nelse\r\nc->expr = e;\r\nrc = next_entry(buf, fp, (sizeof(u32) * 3));\r\nif (rc)\r\nreturn rc;\r\ne->expr_type = le32_to_cpu(buf[0]);\r\ne->attr = le32_to_cpu(buf[1]);\r\ne->op = le32_to_cpu(buf[2]);\r\nswitch (e->expr_type) {\r\ncase CEXPR_NOT:\r\nif (depth < 0)\r\nreturn -EINVAL;\r\nbreak;\r\ncase CEXPR_AND:\r\ncase CEXPR_OR:\r\nif (depth < 1)\r\nreturn -EINVAL;\r\ndepth--;\r\nbreak;\r\ncase CEXPR_ATTR:\r\nif (depth == (CEXPR_MAXDEPTH - 1))\r\nreturn -EINVAL;\r\ndepth++;\r\nbreak;\r\ncase CEXPR_NAMES:\r\nif (!allowxtarget && (e->attr & CEXPR_XTARGET))\r\nreturn -EINVAL;\r\nif (depth == (CEXPR_MAXDEPTH - 1))\r\nreturn -EINVAL;\r\ndepth++;\r\nrc = ebitmap_read(&e->names, fp);\r\nif (rc)\r\nreturn rc;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nle = e;\r\n}\r\nif (depth != 0)\r\nreturn -EINVAL;\r\nlc = c;\r\n}\r\nreturn 0;\r\n}\r\nstatic int class_read(struct policydb *p, struct hashtab *h, void *fp)\r\n{\r\nchar *key = NULL;\r\nstruct class_datum *cladatum;\r\n__le32 buf[6];\r\nu32 len, len2, ncons, nel;\r\nint i, rc;\r\nrc = -ENOMEM;\r\ncladatum = kzalloc(sizeof(*cladatum), GFP_KERNEL);\r\nif (!cladatum)\r\ngoto bad;\r\nrc = next_entry(buf, fp, sizeof(u32)*6);\r\nif (rc)\r\ngoto bad;\r\nlen = le32_to_cpu(buf[0]);\r\nlen2 = le32_to_cpu(buf[1]);\r\ncladatum->value = le32_to_cpu(buf[2]);\r\nrc = symtab_init(&cladatum->permissions, PERM_SYMTAB_SIZE);\r\nif (rc)\r\ngoto bad;\r\ncladatum->permissions.nprim = le32_to_cpu(buf[3]);\r\nnel = le32_to_cpu(buf[4]);\r\nncons = le32_to_cpu(buf[5]);\r\nrc = -ENOMEM;\r\nkey = kmalloc(len + 1, GFP_KERNEL);\r\nif (!key)\r\ngoto bad;\r\nrc = next_entry(key, fp, len);\r\nif (rc)\r\ngoto bad;\r\nkey[len] = '\0';\r\nif (len2) {\r\nrc = -ENOMEM;\r\ncladatum->comkey = kmalloc(len2 + 1, GFP_KERNEL);\r\nif (!cladatum->comkey)\r\ngoto bad;\r\nrc = next_entry(cladatum->comkey, fp, len2);\r\nif (rc)\r\ngoto bad;\r\ncladatum->comkey[len2] = '\0';\r\nrc = -EINVAL;\r\ncladatum->comdatum = hashtab_search(p->p_commons.table, cladatum->comkey);\r\nif (!cladatum->comdatum) {\r\nprintk(KERN_ERR "SELinux: unknown common %s\n", cladatum->comkey);\r\ngoto bad;\r\n}\r\n}\r\nfor (i = 0; i < nel; i++) {\r\nrc = perm_read(p, cladatum->permissions.table, fp);\r\nif (rc)\r\ngoto bad;\r\n}\r\nrc = read_cons_helper(&cladatum->constraints, ncons, 0, fp);\r\nif (rc)\r\ngoto bad;\r\nif (p->policyvers >= POLICYDB_VERSION_VALIDATETRANS) {\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\ngoto bad;\r\nncons = le32_to_cpu(buf[0]);\r\nrc = read_cons_helper(&cladatum->validatetrans, ncons, 1, fp);\r\nif (rc)\r\ngoto bad;\r\n}\r\nrc = hashtab_insert(h, key, cladatum);\r\nif (rc)\r\ngoto bad;\r\nreturn 0;\r\nbad:\r\ncls_destroy(key, cladatum, NULL);\r\nreturn rc;\r\n}\r\nstatic int role_read(struct policydb *p, struct hashtab *h, void *fp)\r\n{\r\nchar *key = NULL;\r\nstruct role_datum *role;\r\nint rc, to_read = 2;\r\n__le32 buf[3];\r\nu32 len;\r\nrc = -ENOMEM;\r\nrole = kzalloc(sizeof(*role), GFP_KERNEL);\r\nif (!role)\r\ngoto bad;\r\nif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\r\nto_read = 3;\r\nrc = next_entry(buf, fp, sizeof(buf[0]) * to_read);\r\nif (rc)\r\ngoto bad;\r\nlen = le32_to_cpu(buf[0]);\r\nrole->value = le32_to_cpu(buf[1]);\r\nif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\r\nrole->bounds = le32_to_cpu(buf[2]);\r\nrc = -ENOMEM;\r\nkey = kmalloc(len + 1, GFP_KERNEL);\r\nif (!key)\r\ngoto bad;\r\nrc = next_entry(key, fp, len);\r\nif (rc)\r\ngoto bad;\r\nkey[len] = '\0';\r\nrc = ebitmap_read(&role->dominates, fp);\r\nif (rc)\r\ngoto bad;\r\nrc = ebitmap_read(&role->types, fp);\r\nif (rc)\r\ngoto bad;\r\nif (strcmp(key, OBJECT_R) == 0) {\r\nrc = -EINVAL;\r\nif (role->value != OBJECT_R_VAL) {\r\nprintk(KERN_ERR "SELinux: Role %s has wrong value %d\n",\r\nOBJECT_R, role->value);\r\ngoto bad;\r\n}\r\nrc = 0;\r\ngoto bad;\r\n}\r\nrc = hashtab_insert(h, key, role);\r\nif (rc)\r\ngoto bad;\r\nreturn 0;\r\nbad:\r\nrole_destroy(key, role, NULL);\r\nreturn rc;\r\n}\r\nstatic int type_read(struct policydb *p, struct hashtab *h, void *fp)\r\n{\r\nchar *key = NULL;\r\nstruct type_datum *typdatum;\r\nint rc, to_read = 3;\r\n__le32 buf[4];\r\nu32 len;\r\nrc = -ENOMEM;\r\ntypdatum = kzalloc(sizeof(*typdatum), GFP_KERNEL);\r\nif (!typdatum)\r\ngoto bad;\r\nif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\r\nto_read = 4;\r\nrc = next_entry(buf, fp, sizeof(buf[0]) * to_read);\r\nif (rc)\r\ngoto bad;\r\nlen = le32_to_cpu(buf[0]);\r\ntypdatum->value = le32_to_cpu(buf[1]);\r\nif (p->policyvers >= POLICYDB_VERSION_BOUNDARY) {\r\nu32 prop = le32_to_cpu(buf[2]);\r\nif (prop & TYPEDATUM_PROPERTY_PRIMARY)\r\ntypdatum->primary = 1;\r\nif (prop & TYPEDATUM_PROPERTY_ATTRIBUTE)\r\ntypdatum->attribute = 1;\r\ntypdatum->bounds = le32_to_cpu(buf[3]);\r\n} else {\r\ntypdatum->primary = le32_to_cpu(buf[2]);\r\n}\r\nrc = -ENOMEM;\r\nkey = kmalloc(len + 1, GFP_KERNEL);\r\nif (!key)\r\ngoto bad;\r\nrc = next_entry(key, fp, len);\r\nif (rc)\r\ngoto bad;\r\nkey[len] = '\0';\r\nrc = hashtab_insert(h, key, typdatum);\r\nif (rc)\r\ngoto bad;\r\nreturn 0;\r\nbad:\r\ntype_destroy(key, typdatum, NULL);\r\nreturn rc;\r\n}\r\nstatic int mls_read_level(struct mls_level *lp, void *fp)\r\n{\r\n__le32 buf[1];\r\nint rc;\r\nmemset(lp, 0, sizeof(*lp));\r\nrc = next_entry(buf, fp, sizeof buf);\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: mls: truncated level\n");\r\nreturn rc;\r\n}\r\nlp->sens = le32_to_cpu(buf[0]);\r\nrc = ebitmap_read(&lp->cat, fp);\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: mls: error reading level categories\n");\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int user_read(struct policydb *p, struct hashtab *h, void *fp)\r\n{\r\nchar *key = NULL;\r\nstruct user_datum *usrdatum;\r\nint rc, to_read = 2;\r\n__le32 buf[3];\r\nu32 len;\r\nrc = -ENOMEM;\r\nusrdatum = kzalloc(sizeof(*usrdatum), GFP_KERNEL);\r\nif (!usrdatum)\r\ngoto bad;\r\nif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\r\nto_read = 3;\r\nrc = next_entry(buf, fp, sizeof(buf[0]) * to_read);\r\nif (rc)\r\ngoto bad;\r\nlen = le32_to_cpu(buf[0]);\r\nusrdatum->value = le32_to_cpu(buf[1]);\r\nif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\r\nusrdatum->bounds = le32_to_cpu(buf[2]);\r\nrc = -ENOMEM;\r\nkey = kmalloc(len + 1, GFP_KERNEL);\r\nif (!key)\r\ngoto bad;\r\nrc = next_entry(key, fp, len);\r\nif (rc)\r\ngoto bad;\r\nkey[len] = '\0';\r\nrc = ebitmap_read(&usrdatum->roles, fp);\r\nif (rc)\r\ngoto bad;\r\nif (p->policyvers >= POLICYDB_VERSION_MLS) {\r\nrc = mls_read_range_helper(&usrdatum->range, fp);\r\nif (rc)\r\ngoto bad;\r\nrc = mls_read_level(&usrdatum->dfltlevel, fp);\r\nif (rc)\r\ngoto bad;\r\n}\r\nrc = hashtab_insert(h, key, usrdatum);\r\nif (rc)\r\ngoto bad;\r\nreturn 0;\r\nbad:\r\nuser_destroy(key, usrdatum, NULL);\r\nreturn rc;\r\n}\r\nstatic int sens_read(struct policydb *p, struct hashtab *h, void *fp)\r\n{\r\nchar *key = NULL;\r\nstruct level_datum *levdatum;\r\nint rc;\r\n__le32 buf[2];\r\nu32 len;\r\nrc = -ENOMEM;\r\nlevdatum = kzalloc(sizeof(*levdatum), GFP_ATOMIC);\r\nif (!levdatum)\r\ngoto bad;\r\nrc = next_entry(buf, fp, sizeof buf);\r\nif (rc)\r\ngoto bad;\r\nlen = le32_to_cpu(buf[0]);\r\nlevdatum->isalias = le32_to_cpu(buf[1]);\r\nrc = -ENOMEM;\r\nkey = kmalloc(len + 1, GFP_ATOMIC);\r\nif (!key)\r\ngoto bad;\r\nrc = next_entry(key, fp, len);\r\nif (rc)\r\ngoto bad;\r\nkey[len] = '\0';\r\nrc = -ENOMEM;\r\nlevdatum->level = kmalloc(sizeof(struct mls_level), GFP_ATOMIC);\r\nif (!levdatum->level)\r\ngoto bad;\r\nrc = mls_read_level(levdatum->level, fp);\r\nif (rc)\r\ngoto bad;\r\nrc = hashtab_insert(h, key, levdatum);\r\nif (rc)\r\ngoto bad;\r\nreturn 0;\r\nbad:\r\nsens_destroy(key, levdatum, NULL);\r\nreturn rc;\r\n}\r\nstatic int cat_read(struct policydb *p, struct hashtab *h, void *fp)\r\n{\r\nchar *key = NULL;\r\nstruct cat_datum *catdatum;\r\nint rc;\r\n__le32 buf[3];\r\nu32 len;\r\nrc = -ENOMEM;\r\ncatdatum = kzalloc(sizeof(*catdatum), GFP_ATOMIC);\r\nif (!catdatum)\r\ngoto bad;\r\nrc = next_entry(buf, fp, sizeof buf);\r\nif (rc)\r\ngoto bad;\r\nlen = le32_to_cpu(buf[0]);\r\ncatdatum->value = le32_to_cpu(buf[1]);\r\ncatdatum->isalias = le32_to_cpu(buf[2]);\r\nrc = -ENOMEM;\r\nkey = kmalloc(len + 1, GFP_ATOMIC);\r\nif (!key)\r\ngoto bad;\r\nrc = next_entry(key, fp, len);\r\nif (rc)\r\ngoto bad;\r\nkey[len] = '\0';\r\nrc = hashtab_insert(h, key, catdatum);\r\nif (rc)\r\ngoto bad;\r\nreturn 0;\r\nbad:\r\ncat_destroy(key, catdatum, NULL);\r\nreturn rc;\r\n}\r\nstatic int user_bounds_sanity_check(void *key, void *datum, void *datap)\r\n{\r\nstruct user_datum *upper, *user;\r\nstruct policydb *p = datap;\r\nint depth = 0;\r\nupper = user = datum;\r\nwhile (upper->bounds) {\r\nstruct ebitmap_node *node;\r\nunsigned long bit;\r\nif (++depth == POLICYDB_BOUNDS_MAXDEPTH) {\r\nprintk(KERN_ERR "SELinux: user %s: "\r\n"too deep or looped boundary",\r\n(char *) key);\r\nreturn -EINVAL;\r\n}\r\nupper = p->user_val_to_struct[upper->bounds - 1];\r\nebitmap_for_each_positive_bit(&user->roles, node, bit) {\r\nif (ebitmap_get_bit(&upper->roles, bit))\r\ncontinue;\r\nprintk(KERN_ERR\r\n"SELinux: boundary violated policy: "\r\n"user=%s role=%s bounds=%s\n",\r\nsym_name(p, SYM_USERS, user->value - 1),\r\nsym_name(p, SYM_ROLES, bit),\r\nsym_name(p, SYM_USERS, upper->value - 1));\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int role_bounds_sanity_check(void *key, void *datum, void *datap)\r\n{\r\nstruct role_datum *upper, *role;\r\nstruct policydb *p = datap;\r\nint depth = 0;\r\nupper = role = datum;\r\nwhile (upper->bounds) {\r\nstruct ebitmap_node *node;\r\nunsigned long bit;\r\nif (++depth == POLICYDB_BOUNDS_MAXDEPTH) {\r\nprintk(KERN_ERR "SELinux: role %s: "\r\n"too deep or looped bounds\n",\r\n(char *) key);\r\nreturn -EINVAL;\r\n}\r\nupper = p->role_val_to_struct[upper->bounds - 1];\r\nebitmap_for_each_positive_bit(&role->types, node, bit) {\r\nif (ebitmap_get_bit(&upper->types, bit))\r\ncontinue;\r\nprintk(KERN_ERR\r\n"SELinux: boundary violated policy: "\r\n"role=%s type=%s bounds=%s\n",\r\nsym_name(p, SYM_ROLES, role->value - 1),\r\nsym_name(p, SYM_TYPES, bit),\r\nsym_name(p, SYM_ROLES, upper->value - 1));\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int type_bounds_sanity_check(void *key, void *datum, void *datap)\r\n{\r\nstruct type_datum *upper;\r\nstruct policydb *p = datap;\r\nint depth = 0;\r\nupper = datum;\r\nwhile (upper->bounds) {\r\nif (++depth == POLICYDB_BOUNDS_MAXDEPTH) {\r\nprintk(KERN_ERR "SELinux: type %s: "\r\n"too deep or looped boundary\n",\r\n(char *) key);\r\nreturn -EINVAL;\r\n}\r\nupper = flex_array_get_ptr(p->type_val_to_struct_array,\r\nupper->bounds - 1);\r\nBUG_ON(!upper);\r\nif (upper->attribute) {\r\nprintk(KERN_ERR "SELinux: type %s: "\r\n"bounded by attribute %s",\r\n(char *) key,\r\nsym_name(p, SYM_TYPES, upper->value - 1));\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int policydb_bounds_sanity_check(struct policydb *p)\r\n{\r\nint rc;\r\nif (p->policyvers < POLICYDB_VERSION_BOUNDARY)\r\nreturn 0;\r\nrc = hashtab_map(p->p_users.table,\r\nuser_bounds_sanity_check, p);\r\nif (rc)\r\nreturn rc;\r\nrc = hashtab_map(p->p_roles.table,\r\nrole_bounds_sanity_check, p);\r\nif (rc)\r\nreturn rc;\r\nrc = hashtab_map(p->p_types.table,\r\ntype_bounds_sanity_check, p);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nu16 string_to_security_class(struct policydb *p, const char *name)\r\n{\r\nstruct class_datum *cladatum;\r\ncladatum = hashtab_search(p->p_classes.table, name);\r\nif (!cladatum)\r\nreturn 0;\r\nreturn cladatum->value;\r\n}\r\nu32 string_to_av_perm(struct policydb *p, u16 tclass, const char *name)\r\n{\r\nstruct class_datum *cladatum;\r\nstruct perm_datum *perdatum = NULL;\r\nstruct common_datum *comdatum;\r\nif (!tclass || tclass > p->p_classes.nprim)\r\nreturn 0;\r\ncladatum = p->class_val_to_struct[tclass-1];\r\ncomdatum = cladatum->comdatum;\r\nif (comdatum)\r\nperdatum = hashtab_search(comdatum->permissions.table,\r\nname);\r\nif (!perdatum)\r\nperdatum = hashtab_search(cladatum->permissions.table,\r\nname);\r\nif (!perdatum)\r\nreturn 0;\r\nreturn 1U << (perdatum->value-1);\r\n}\r\nstatic int range_read(struct policydb *p, void *fp)\r\n{\r\nstruct range_trans *rt = NULL;\r\nstruct mls_range *r = NULL;\r\nint i, rc;\r\n__le32 buf[2];\r\nu32 nel;\r\nif (p->policyvers < POLICYDB_VERSION_MLS)\r\nreturn 0;\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\ngoto out;\r\nnel = le32_to_cpu(buf[0]);\r\nfor (i = 0; i < nel; i++) {\r\nrc = -ENOMEM;\r\nrt = kzalloc(sizeof(*rt), GFP_KERNEL);\r\nif (!rt)\r\ngoto out;\r\nrc = next_entry(buf, fp, (sizeof(u32) * 2));\r\nif (rc)\r\ngoto out;\r\nrt->source_type = le32_to_cpu(buf[0]);\r\nrt->target_type = le32_to_cpu(buf[1]);\r\nif (p->policyvers >= POLICYDB_VERSION_RANGETRANS) {\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\ngoto out;\r\nrt->target_class = le32_to_cpu(buf[0]);\r\n} else\r\nrt->target_class = p->process_class;\r\nrc = -EINVAL;\r\nif (!policydb_type_isvalid(p, rt->source_type) ||\r\n!policydb_type_isvalid(p, rt->target_type) ||\r\n!policydb_class_isvalid(p, rt->target_class))\r\ngoto out;\r\nrc = -ENOMEM;\r\nr = kzalloc(sizeof(*r), GFP_KERNEL);\r\nif (!r)\r\ngoto out;\r\nrc = mls_read_range_helper(r, fp);\r\nif (rc)\r\ngoto out;\r\nrc = -EINVAL;\r\nif (!mls_range_isvalid(p, r)) {\r\nprintk(KERN_WARNING "SELinux: rangetrans: invalid range\n");\r\ngoto out;\r\n}\r\nrc = hashtab_insert(p->range_tr, rt, r);\r\nif (rc)\r\ngoto out;\r\nrt = NULL;\r\nr = NULL;\r\n}\r\nhash_eval(p->range_tr, "rangetr");\r\nrc = 0;\r\nout:\r\nkfree(rt);\r\nkfree(r);\r\nreturn rc;\r\n}\r\nstatic int filename_trans_read(struct policydb *p, void *fp)\r\n{\r\nstruct filename_trans *ft;\r\nstruct filename_trans_datum *otype;\r\nchar *name;\r\nu32 nel, len;\r\n__le32 buf[4];\r\nint rc, i;\r\nif (p->policyvers < POLICYDB_VERSION_FILENAME_TRANS)\r\nreturn 0;\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\nreturn rc;\r\nnel = le32_to_cpu(buf[0]);\r\nfor (i = 0; i < nel; i++) {\r\nft = NULL;\r\notype = NULL;\r\nname = NULL;\r\nrc = -ENOMEM;\r\nft = kzalloc(sizeof(*ft), GFP_KERNEL);\r\nif (!ft)\r\ngoto out;\r\nrc = -ENOMEM;\r\notype = kmalloc(sizeof(*otype), GFP_KERNEL);\r\nif (!otype)\r\ngoto out;\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\ngoto out;\r\nlen = le32_to_cpu(buf[0]);\r\nrc = -ENOMEM;\r\nname = kmalloc(len + 1, GFP_KERNEL);\r\nif (!name)\r\ngoto out;\r\nft->name = name;\r\nrc = next_entry(name, fp, len);\r\nif (rc)\r\ngoto out;\r\nname[len] = 0;\r\nrc = next_entry(buf, fp, sizeof(u32) * 4);\r\nif (rc)\r\ngoto out;\r\nft->stype = le32_to_cpu(buf[0]);\r\nft->ttype = le32_to_cpu(buf[1]);\r\nft->tclass = le32_to_cpu(buf[2]);\r\notype->otype = le32_to_cpu(buf[3]);\r\nrc = ebitmap_set_bit(&p->filename_trans_ttypes, ft->ttype, 1);\r\nif (rc)\r\ngoto out;\r\nhashtab_insert(p->filename_trans, ft, otype);\r\n}\r\nhash_eval(p->filename_trans, "filenametr");\r\nreturn 0;\r\nout:\r\nkfree(ft);\r\nkfree(name);\r\nkfree(otype);\r\nreturn rc;\r\n}\r\nstatic int genfs_read(struct policydb *p, void *fp)\r\n{\r\nint i, j, rc;\r\nu32 nel, nel2, len, len2;\r\n__le32 buf[1];\r\nstruct ocontext *l, *c;\r\nstruct ocontext *newc = NULL;\r\nstruct genfs *genfs_p, *genfs;\r\nstruct genfs *newgenfs = NULL;\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\ngoto out;\r\nnel = le32_to_cpu(buf[0]);\r\nfor (i = 0; i < nel; i++) {\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\ngoto out;\r\nlen = le32_to_cpu(buf[0]);\r\nrc = -ENOMEM;\r\nnewgenfs = kzalloc(sizeof(*newgenfs), GFP_KERNEL);\r\nif (!newgenfs)\r\ngoto out;\r\nrc = -ENOMEM;\r\nnewgenfs->fstype = kmalloc(len + 1, GFP_KERNEL);\r\nif (!newgenfs->fstype)\r\ngoto out;\r\nrc = next_entry(newgenfs->fstype, fp, len);\r\nif (rc)\r\ngoto out;\r\nnewgenfs->fstype[len] = 0;\r\nfor (genfs_p = NULL, genfs = p->genfs; genfs;\r\ngenfs_p = genfs, genfs = genfs->next) {\r\nrc = -EINVAL;\r\nif (strcmp(newgenfs->fstype, genfs->fstype) == 0) {\r\nprintk(KERN_ERR "SELinux: dup genfs fstype %s\n",\r\nnewgenfs->fstype);\r\ngoto out;\r\n}\r\nif (strcmp(newgenfs->fstype, genfs->fstype) < 0)\r\nbreak;\r\n}\r\nnewgenfs->next = genfs;\r\nif (genfs_p)\r\ngenfs_p->next = newgenfs;\r\nelse\r\np->genfs = newgenfs;\r\ngenfs = newgenfs;\r\nnewgenfs = NULL;\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\ngoto out;\r\nnel2 = le32_to_cpu(buf[0]);\r\nfor (j = 0; j < nel2; j++) {\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\ngoto out;\r\nlen = le32_to_cpu(buf[0]);\r\nrc = -ENOMEM;\r\nnewc = kzalloc(sizeof(*newc), GFP_KERNEL);\r\nif (!newc)\r\ngoto out;\r\nrc = -ENOMEM;\r\nnewc->u.name = kmalloc(len + 1, GFP_KERNEL);\r\nif (!newc->u.name)\r\ngoto out;\r\nrc = next_entry(newc->u.name, fp, len);\r\nif (rc)\r\ngoto out;\r\nnewc->u.name[len] = 0;\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\ngoto out;\r\nnewc->v.sclass = le32_to_cpu(buf[0]);\r\nrc = context_read_and_validate(&newc->context[0], p, fp);\r\nif (rc)\r\ngoto out;\r\nfor (l = NULL, c = genfs->head; c;\r\nl = c, c = c->next) {\r\nrc = -EINVAL;\r\nif (!strcmp(newc->u.name, c->u.name) &&\r\n(!c->v.sclass || !newc->v.sclass ||\r\nnewc->v.sclass == c->v.sclass)) {\r\nprintk(KERN_ERR "SELinux: dup genfs entry (%s,%s)\n",\r\ngenfs->fstype, c->u.name);\r\ngoto out;\r\n}\r\nlen = strlen(newc->u.name);\r\nlen2 = strlen(c->u.name);\r\nif (len > len2)\r\nbreak;\r\n}\r\nnewc->next = c;\r\nif (l)\r\nl->next = newc;\r\nelse\r\ngenfs->head = newc;\r\nnewc = NULL;\r\n}\r\n}\r\nrc = 0;\r\nout:\r\nif (newgenfs)\r\nkfree(newgenfs->fstype);\r\nkfree(newgenfs);\r\nocontext_destroy(newc, OCON_FSUSE);\r\nreturn rc;\r\n}\r\nstatic int ocontext_read(struct policydb *p, struct policydb_compat_info *info,\r\nvoid *fp)\r\n{\r\nint i, j, rc;\r\nu32 nel, len;\r\n__le32 buf[3];\r\nstruct ocontext *l, *c;\r\nu32 nodebuf[8];\r\nfor (i = 0; i < info->ocon_num; i++) {\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\ngoto out;\r\nnel = le32_to_cpu(buf[0]);\r\nl = NULL;\r\nfor (j = 0; j < nel; j++) {\r\nrc = -ENOMEM;\r\nc = kzalloc(sizeof(*c), GFP_KERNEL);\r\nif (!c)\r\ngoto out;\r\nif (l)\r\nl->next = c;\r\nelse\r\np->ocontexts[i] = c;\r\nl = c;\r\nswitch (i) {\r\ncase OCON_ISID:\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\ngoto out;\r\nc->sid[0] = le32_to_cpu(buf[0]);\r\nrc = context_read_and_validate(&c->context[0], p, fp);\r\nif (rc)\r\ngoto out;\r\nbreak;\r\ncase OCON_FS:\r\ncase OCON_NETIF:\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\ngoto out;\r\nlen = le32_to_cpu(buf[0]);\r\nrc = -ENOMEM;\r\nc->u.name = kmalloc(len + 1, GFP_KERNEL);\r\nif (!c->u.name)\r\ngoto out;\r\nrc = next_entry(c->u.name, fp, len);\r\nif (rc)\r\ngoto out;\r\nc->u.name[len] = 0;\r\nrc = context_read_and_validate(&c->context[0], p, fp);\r\nif (rc)\r\ngoto out;\r\nrc = context_read_and_validate(&c->context[1], p, fp);\r\nif (rc)\r\ngoto out;\r\nbreak;\r\ncase OCON_PORT:\r\nrc = next_entry(buf, fp, sizeof(u32)*3);\r\nif (rc)\r\ngoto out;\r\nc->u.port.protocol = le32_to_cpu(buf[0]);\r\nc->u.port.low_port = le32_to_cpu(buf[1]);\r\nc->u.port.high_port = le32_to_cpu(buf[2]);\r\nrc = context_read_and_validate(&c->context[0], p, fp);\r\nif (rc)\r\ngoto out;\r\nbreak;\r\ncase OCON_NODE:\r\nrc = next_entry(nodebuf, fp, sizeof(u32) * 2);\r\nif (rc)\r\ngoto out;\r\nc->u.node.addr = nodebuf[0];\r\nc->u.node.mask = nodebuf[1];\r\nrc = context_read_and_validate(&c->context[0], p, fp);\r\nif (rc)\r\ngoto out;\r\nbreak;\r\ncase OCON_FSUSE:\r\nrc = next_entry(buf, fp, sizeof(u32)*2);\r\nif (rc)\r\ngoto out;\r\nrc = -EINVAL;\r\nc->v.behavior = le32_to_cpu(buf[0]);\r\nif (c->v.behavior > SECURITY_FS_USE_NONE)\r\ngoto out;\r\nrc = -ENOMEM;\r\nlen = le32_to_cpu(buf[1]);\r\nc->u.name = kmalloc(len + 1, GFP_KERNEL);\r\nif (!c->u.name)\r\ngoto out;\r\nrc = next_entry(c->u.name, fp, len);\r\nif (rc)\r\ngoto out;\r\nc->u.name[len] = 0;\r\nrc = context_read_and_validate(&c->context[0], p, fp);\r\nif (rc)\r\ngoto out;\r\nbreak;\r\ncase OCON_NODE6: {\r\nint k;\r\nrc = next_entry(nodebuf, fp, sizeof(u32) * 8);\r\nif (rc)\r\ngoto out;\r\nfor (k = 0; k < 4; k++)\r\nc->u.node6.addr[k] = nodebuf[k];\r\nfor (k = 0; k < 4; k++)\r\nc->u.node6.mask[k] = nodebuf[k+4];\r\nrc = context_read_and_validate(&c->context[0], p, fp);\r\nif (rc)\r\ngoto out;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nint policydb_read(struct policydb *p, void *fp)\r\n{\r\nstruct role_allow *ra, *lra;\r\nstruct role_trans *tr, *ltr;\r\nint i, j, rc;\r\n__le32 buf[4];\r\nu32 len, nprim, nel;\r\nchar *policydb_str;\r\nstruct policydb_compat_info *info;\r\nrc = policydb_init(p);\r\nif (rc)\r\nreturn rc;\r\nrc = next_entry(buf, fp, sizeof(u32) * 2);\r\nif (rc)\r\ngoto bad;\r\nrc = -EINVAL;\r\nif (le32_to_cpu(buf[0]) != POLICYDB_MAGIC) {\r\nprintk(KERN_ERR "SELinux: policydb magic number 0x%x does "\r\n"not match expected magic number 0x%x\n",\r\nle32_to_cpu(buf[0]), POLICYDB_MAGIC);\r\ngoto bad;\r\n}\r\nrc = -EINVAL;\r\nlen = le32_to_cpu(buf[1]);\r\nif (len != strlen(POLICYDB_STRING)) {\r\nprintk(KERN_ERR "SELinux: policydb string length %d does not "\r\n"match expected length %Zu\n",\r\nlen, strlen(POLICYDB_STRING));\r\ngoto bad;\r\n}\r\nrc = -ENOMEM;\r\npolicydb_str = kmalloc(len + 1, GFP_KERNEL);\r\nif (!policydb_str) {\r\nprintk(KERN_ERR "SELinux: unable to allocate memory for policydb "\r\n"string of length %d\n", len);\r\ngoto bad;\r\n}\r\nrc = next_entry(policydb_str, fp, len);\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: truncated policydb string identifier\n");\r\nkfree(policydb_str);\r\ngoto bad;\r\n}\r\nrc = -EINVAL;\r\npolicydb_str[len] = '\0';\r\nif (strcmp(policydb_str, POLICYDB_STRING)) {\r\nprintk(KERN_ERR "SELinux: policydb string %s does not match "\r\n"my string %s\n", policydb_str, POLICYDB_STRING);\r\nkfree(policydb_str);\r\ngoto bad;\r\n}\r\nkfree(policydb_str);\r\npolicydb_str = NULL;\r\nrc = next_entry(buf, fp, sizeof(u32)*4);\r\nif (rc)\r\ngoto bad;\r\nrc = -EINVAL;\r\np->policyvers = le32_to_cpu(buf[0]);\r\nif (p->policyvers < POLICYDB_VERSION_MIN ||\r\np->policyvers > POLICYDB_VERSION_MAX) {\r\nprintk(KERN_ERR "SELinux: policydb version %d does not match "\r\n"my version range %d-%d\n",\r\nle32_to_cpu(buf[0]), POLICYDB_VERSION_MIN, POLICYDB_VERSION_MAX);\r\ngoto bad;\r\n}\r\nif ((le32_to_cpu(buf[1]) & POLICYDB_CONFIG_MLS)) {\r\np->mls_enabled = 1;\r\nrc = -EINVAL;\r\nif (p->policyvers < POLICYDB_VERSION_MLS) {\r\nprintk(KERN_ERR "SELinux: security policydb version %d "\r\n"(MLS) not backwards compatible\n",\r\np->policyvers);\r\ngoto bad;\r\n}\r\n}\r\np->reject_unknown = !!(le32_to_cpu(buf[1]) & REJECT_UNKNOWN);\r\np->allow_unknown = !!(le32_to_cpu(buf[1]) & ALLOW_UNKNOWN);\r\nif (p->policyvers >= POLICYDB_VERSION_POLCAP) {\r\nrc = ebitmap_read(&p->policycaps, fp);\r\nif (rc)\r\ngoto bad;\r\n}\r\nif (p->policyvers >= POLICYDB_VERSION_PERMISSIVE) {\r\nrc = ebitmap_read(&p->permissive_map, fp);\r\nif (rc)\r\ngoto bad;\r\n}\r\nrc = -EINVAL;\r\ninfo = policydb_lookup_compat(p->policyvers);\r\nif (!info) {\r\nprintk(KERN_ERR "SELinux: unable to find policy compat info "\r\n"for version %d\n", p->policyvers);\r\ngoto bad;\r\n}\r\nrc = -EINVAL;\r\nif (le32_to_cpu(buf[2]) != info->sym_num ||\r\nle32_to_cpu(buf[3]) != info->ocon_num) {\r\nprintk(KERN_ERR "SELinux: policydb table sizes (%d,%d) do "\r\n"not match mine (%d,%d)\n", le32_to_cpu(buf[2]),\r\nle32_to_cpu(buf[3]),\r\ninfo->sym_num, info->ocon_num);\r\ngoto bad;\r\n}\r\nfor (i = 0; i < info->sym_num; i++) {\r\nrc = next_entry(buf, fp, sizeof(u32)*2);\r\nif (rc)\r\ngoto bad;\r\nnprim = le32_to_cpu(buf[0]);\r\nnel = le32_to_cpu(buf[1]);\r\nfor (j = 0; j < nel; j++) {\r\nrc = read_f[i](p, p->symtab[i].table, fp);\r\nif (rc)\r\ngoto bad;\r\n}\r\np->symtab[i].nprim = nprim;\r\n}\r\nrc = -EINVAL;\r\np->process_class = string_to_security_class(p, "process");\r\nif (!p->process_class)\r\ngoto bad;\r\nrc = avtab_read(&p->te_avtab, fp, p);\r\nif (rc)\r\ngoto bad;\r\nif (p->policyvers >= POLICYDB_VERSION_BOOL) {\r\nrc = cond_read_list(p, fp);\r\nif (rc)\r\ngoto bad;\r\n}\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\ngoto bad;\r\nnel = le32_to_cpu(buf[0]);\r\nltr = NULL;\r\nfor (i = 0; i < nel; i++) {\r\nrc = -ENOMEM;\r\ntr = kzalloc(sizeof(*tr), GFP_KERNEL);\r\nif (!tr)\r\ngoto bad;\r\nif (ltr)\r\nltr->next = tr;\r\nelse\r\np->role_tr = tr;\r\nrc = next_entry(buf, fp, sizeof(u32)*3);\r\nif (rc)\r\ngoto bad;\r\nrc = -EINVAL;\r\ntr->role = le32_to_cpu(buf[0]);\r\ntr->type = le32_to_cpu(buf[1]);\r\ntr->new_role = le32_to_cpu(buf[2]);\r\nif (p->policyvers >= POLICYDB_VERSION_ROLETRANS) {\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\ngoto bad;\r\ntr->tclass = le32_to_cpu(buf[0]);\r\n} else\r\ntr->tclass = p->process_class;\r\nif (!policydb_role_isvalid(p, tr->role) ||\r\n!policydb_type_isvalid(p, tr->type) ||\r\n!policydb_class_isvalid(p, tr->tclass) ||\r\n!policydb_role_isvalid(p, tr->new_role))\r\ngoto bad;\r\nltr = tr;\r\n}\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\ngoto bad;\r\nnel = le32_to_cpu(buf[0]);\r\nlra = NULL;\r\nfor (i = 0; i < nel; i++) {\r\nrc = -ENOMEM;\r\nra = kzalloc(sizeof(*ra), GFP_KERNEL);\r\nif (!ra)\r\ngoto bad;\r\nif (lra)\r\nlra->next = ra;\r\nelse\r\np->role_allow = ra;\r\nrc = next_entry(buf, fp, sizeof(u32)*2);\r\nif (rc)\r\ngoto bad;\r\nrc = -EINVAL;\r\nra->role = le32_to_cpu(buf[0]);\r\nra->new_role = le32_to_cpu(buf[1]);\r\nif (!policydb_role_isvalid(p, ra->role) ||\r\n!policydb_role_isvalid(p, ra->new_role))\r\ngoto bad;\r\nlra = ra;\r\n}\r\nrc = filename_trans_read(p, fp);\r\nif (rc)\r\ngoto bad;\r\nrc = policydb_index(p);\r\nif (rc)\r\ngoto bad;\r\nrc = -EINVAL;\r\np->process_trans_perms = string_to_av_perm(p, p->process_class, "transition");\r\np->process_trans_perms |= string_to_av_perm(p, p->process_class, "dyntransition");\r\nif (!p->process_trans_perms)\r\ngoto bad;\r\nrc = ocontext_read(p, info, fp);\r\nif (rc)\r\ngoto bad;\r\nrc = genfs_read(p, fp);\r\nif (rc)\r\ngoto bad;\r\nrc = range_read(p, fp);\r\nif (rc)\r\ngoto bad;\r\nrc = -ENOMEM;\r\np->type_attr_map_array = flex_array_alloc(sizeof(struct ebitmap),\r\np->p_types.nprim,\r\nGFP_KERNEL | __GFP_ZERO);\r\nif (!p->type_attr_map_array)\r\ngoto bad;\r\nrc = flex_array_prealloc(p->type_attr_map_array, 0, p->p_types.nprim,\r\nGFP_KERNEL | __GFP_ZERO);\r\nif (rc)\r\ngoto bad;\r\nfor (i = 0; i < p->p_types.nprim; i++) {\r\nstruct ebitmap *e = flex_array_get(p->type_attr_map_array, i);\r\nBUG_ON(!e);\r\nebitmap_init(e);\r\nif (p->policyvers >= POLICYDB_VERSION_AVTAB) {\r\nrc = ebitmap_read(e, fp);\r\nif (rc)\r\ngoto bad;\r\n}\r\nrc = ebitmap_set_bit(e, i, 1);\r\nif (rc)\r\ngoto bad;\r\n}\r\nrc = policydb_bounds_sanity_check(p);\r\nif (rc)\r\ngoto bad;\r\nrc = 0;\r\nout:\r\nreturn rc;\r\nbad:\r\npolicydb_destroy(p);\r\ngoto out;\r\n}\r\nstatic int mls_write_level(struct mls_level *l, void *fp)\r\n{\r\n__le32 buf[1];\r\nint rc;\r\nbuf[0] = cpu_to_le32(l->sens);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = ebitmap_write(&l->cat, fp);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int mls_write_range_helper(struct mls_range *r, void *fp)\r\n{\r\n__le32 buf[3];\r\nsize_t items;\r\nint rc, eq;\r\neq = mls_level_eq(&r->level[1], &r->level[0]);\r\nif (eq)\r\nitems = 2;\r\nelse\r\nitems = 3;\r\nbuf[0] = cpu_to_le32(items-1);\r\nbuf[1] = cpu_to_le32(r->level[0].sens);\r\nif (!eq)\r\nbuf[2] = cpu_to_le32(r->level[1].sens);\r\nBUG_ON(items > (sizeof(buf)/sizeof(buf[0])));\r\nrc = put_entry(buf, sizeof(u32), items, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = ebitmap_write(&r->level[0].cat, fp);\r\nif (rc)\r\nreturn rc;\r\nif (!eq) {\r\nrc = ebitmap_write(&r->level[1].cat, fp);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sens_write(void *vkey, void *datum, void *ptr)\r\n{\r\nchar *key = vkey;\r\nstruct level_datum *levdatum = datum;\r\nstruct policy_data *pd = ptr;\r\nvoid *fp = pd->fp;\r\n__le32 buf[2];\r\nsize_t len;\r\nint rc;\r\nlen = strlen(key);\r\nbuf[0] = cpu_to_le32(len);\r\nbuf[1] = cpu_to_le32(levdatum->isalias);\r\nrc = put_entry(buf, sizeof(u32), 2, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = put_entry(key, 1, len, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = mls_write_level(levdatum->level, fp);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int cat_write(void *vkey, void *datum, void *ptr)\r\n{\r\nchar *key = vkey;\r\nstruct cat_datum *catdatum = datum;\r\nstruct policy_data *pd = ptr;\r\nvoid *fp = pd->fp;\r\n__le32 buf[3];\r\nsize_t len;\r\nint rc;\r\nlen = strlen(key);\r\nbuf[0] = cpu_to_le32(len);\r\nbuf[1] = cpu_to_le32(catdatum->value);\r\nbuf[2] = cpu_to_le32(catdatum->isalias);\r\nrc = put_entry(buf, sizeof(u32), 3, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = put_entry(key, 1, len, fp);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int role_trans_write(struct policydb *p, void *fp)\r\n{\r\nstruct role_trans *r = p->role_tr;\r\nstruct role_trans *tr;\r\nu32 buf[3];\r\nsize_t nel;\r\nint rc;\r\nnel = 0;\r\nfor (tr = r; tr; tr = tr->next)\r\nnel++;\r\nbuf[0] = cpu_to_le32(nel);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nfor (tr = r; tr; tr = tr->next) {\r\nbuf[0] = cpu_to_le32(tr->role);\r\nbuf[1] = cpu_to_le32(tr->type);\r\nbuf[2] = cpu_to_le32(tr->new_role);\r\nrc = put_entry(buf, sizeof(u32), 3, fp);\r\nif (rc)\r\nreturn rc;\r\nif (p->policyvers >= POLICYDB_VERSION_ROLETRANS) {\r\nbuf[0] = cpu_to_le32(tr->tclass);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int role_allow_write(struct role_allow *r, void *fp)\r\n{\r\nstruct role_allow *ra;\r\nu32 buf[2];\r\nsize_t nel;\r\nint rc;\r\nnel = 0;\r\nfor (ra = r; ra; ra = ra->next)\r\nnel++;\r\nbuf[0] = cpu_to_le32(nel);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nfor (ra = r; ra; ra = ra->next) {\r\nbuf[0] = cpu_to_le32(ra->role);\r\nbuf[1] = cpu_to_le32(ra->new_role);\r\nrc = put_entry(buf, sizeof(u32), 2, fp);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int context_write(struct policydb *p, struct context *c,\r\nvoid *fp)\r\n{\r\nint rc;\r\n__le32 buf[3];\r\nbuf[0] = cpu_to_le32(c->user);\r\nbuf[1] = cpu_to_le32(c->role);\r\nbuf[2] = cpu_to_le32(c->type);\r\nrc = put_entry(buf, sizeof(u32), 3, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = mls_write_range_helper(&c->range, fp);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int perm_write(void *vkey, void *datum, void *fp)\r\n{\r\nchar *key = vkey;\r\nstruct perm_datum *perdatum = datum;\r\n__le32 buf[2];\r\nsize_t len;\r\nint rc;\r\nlen = strlen(key);\r\nbuf[0] = cpu_to_le32(len);\r\nbuf[1] = cpu_to_le32(perdatum->value);\r\nrc = put_entry(buf, sizeof(u32), 2, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = put_entry(key, 1, len, fp);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int common_write(void *vkey, void *datum, void *ptr)\r\n{\r\nchar *key = vkey;\r\nstruct common_datum *comdatum = datum;\r\nstruct policy_data *pd = ptr;\r\nvoid *fp = pd->fp;\r\n__le32 buf[4];\r\nsize_t len;\r\nint rc;\r\nlen = strlen(key);\r\nbuf[0] = cpu_to_le32(len);\r\nbuf[1] = cpu_to_le32(comdatum->value);\r\nbuf[2] = cpu_to_le32(comdatum->permissions.nprim);\r\nbuf[3] = cpu_to_le32(comdatum->permissions.table->nel);\r\nrc = put_entry(buf, sizeof(u32), 4, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = put_entry(key, 1, len, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = hashtab_map(comdatum->permissions.table, perm_write, fp);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int write_cons_helper(struct policydb *p, struct constraint_node *node,\r\nvoid *fp)\r\n{\r\nstruct constraint_node *c;\r\nstruct constraint_expr *e;\r\n__le32 buf[3];\r\nu32 nel;\r\nint rc;\r\nfor (c = node; c; c = c->next) {\r\nnel = 0;\r\nfor (e = c->expr; e; e = e->next)\r\nnel++;\r\nbuf[0] = cpu_to_le32(c->permissions);\r\nbuf[1] = cpu_to_le32(nel);\r\nrc = put_entry(buf, sizeof(u32), 2, fp);\r\nif (rc)\r\nreturn rc;\r\nfor (e = c->expr; e; e = e->next) {\r\nbuf[0] = cpu_to_le32(e->expr_type);\r\nbuf[1] = cpu_to_le32(e->attr);\r\nbuf[2] = cpu_to_le32(e->op);\r\nrc = put_entry(buf, sizeof(u32), 3, fp);\r\nif (rc)\r\nreturn rc;\r\nswitch (e->expr_type) {\r\ncase CEXPR_NAMES:\r\nrc = ebitmap_write(&e->names, fp);\r\nif (rc)\r\nreturn rc;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int class_write(void *vkey, void *datum, void *ptr)\r\n{\r\nchar *key = vkey;\r\nstruct class_datum *cladatum = datum;\r\nstruct policy_data *pd = ptr;\r\nvoid *fp = pd->fp;\r\nstruct policydb *p = pd->p;\r\nstruct constraint_node *c;\r\n__le32 buf[6];\r\nu32 ncons;\r\nsize_t len, len2;\r\nint rc;\r\nlen = strlen(key);\r\nif (cladatum->comkey)\r\nlen2 = strlen(cladatum->comkey);\r\nelse\r\nlen2 = 0;\r\nncons = 0;\r\nfor (c = cladatum->constraints; c; c = c->next)\r\nncons++;\r\nbuf[0] = cpu_to_le32(len);\r\nbuf[1] = cpu_to_le32(len2);\r\nbuf[2] = cpu_to_le32(cladatum->value);\r\nbuf[3] = cpu_to_le32(cladatum->permissions.nprim);\r\nif (cladatum->permissions.table)\r\nbuf[4] = cpu_to_le32(cladatum->permissions.table->nel);\r\nelse\r\nbuf[4] = 0;\r\nbuf[5] = cpu_to_le32(ncons);\r\nrc = put_entry(buf, sizeof(u32), 6, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = put_entry(key, 1, len, fp);\r\nif (rc)\r\nreturn rc;\r\nif (cladatum->comkey) {\r\nrc = put_entry(cladatum->comkey, 1, len2, fp);\r\nif (rc)\r\nreturn rc;\r\n}\r\nrc = hashtab_map(cladatum->permissions.table, perm_write, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = write_cons_helper(p, cladatum->constraints, fp);\r\nif (rc)\r\nreturn rc;\r\nncons = 0;\r\nfor (c = cladatum->validatetrans; c; c = c->next)\r\nncons++;\r\nbuf[0] = cpu_to_le32(ncons);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = write_cons_helper(p, cladatum->validatetrans, fp);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int role_write(void *vkey, void *datum, void *ptr)\r\n{\r\nchar *key = vkey;\r\nstruct role_datum *role = datum;\r\nstruct policy_data *pd = ptr;\r\nvoid *fp = pd->fp;\r\nstruct policydb *p = pd->p;\r\n__le32 buf[3];\r\nsize_t items, len;\r\nint rc;\r\nlen = strlen(key);\r\nitems = 0;\r\nbuf[items++] = cpu_to_le32(len);\r\nbuf[items++] = cpu_to_le32(role->value);\r\nif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\r\nbuf[items++] = cpu_to_le32(role->bounds);\r\nBUG_ON(items > (sizeof(buf)/sizeof(buf[0])));\r\nrc = put_entry(buf, sizeof(u32), items, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = put_entry(key, 1, len, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = ebitmap_write(&role->dominates, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = ebitmap_write(&role->types, fp);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int type_write(void *vkey, void *datum, void *ptr)\r\n{\r\nchar *key = vkey;\r\nstruct type_datum *typdatum = datum;\r\nstruct policy_data *pd = ptr;\r\nstruct policydb *p = pd->p;\r\nvoid *fp = pd->fp;\r\n__le32 buf[4];\r\nint rc;\r\nsize_t items, len;\r\nlen = strlen(key);\r\nitems = 0;\r\nbuf[items++] = cpu_to_le32(len);\r\nbuf[items++] = cpu_to_le32(typdatum->value);\r\nif (p->policyvers >= POLICYDB_VERSION_BOUNDARY) {\r\nu32 properties = 0;\r\nif (typdatum->primary)\r\nproperties |= TYPEDATUM_PROPERTY_PRIMARY;\r\nif (typdatum->attribute)\r\nproperties |= TYPEDATUM_PROPERTY_ATTRIBUTE;\r\nbuf[items++] = cpu_to_le32(properties);\r\nbuf[items++] = cpu_to_le32(typdatum->bounds);\r\n} else {\r\nbuf[items++] = cpu_to_le32(typdatum->primary);\r\n}\r\nBUG_ON(items > (sizeof(buf) / sizeof(buf[0])));\r\nrc = put_entry(buf, sizeof(u32), items, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = put_entry(key, 1, len, fp);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int user_write(void *vkey, void *datum, void *ptr)\r\n{\r\nchar *key = vkey;\r\nstruct user_datum *usrdatum = datum;\r\nstruct policy_data *pd = ptr;\r\nstruct policydb *p = pd->p;\r\nvoid *fp = pd->fp;\r\n__le32 buf[3];\r\nsize_t items, len;\r\nint rc;\r\nlen = strlen(key);\r\nitems = 0;\r\nbuf[items++] = cpu_to_le32(len);\r\nbuf[items++] = cpu_to_le32(usrdatum->value);\r\nif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\r\nbuf[items++] = cpu_to_le32(usrdatum->bounds);\r\nBUG_ON(items > (sizeof(buf) / sizeof(buf[0])));\r\nrc = put_entry(buf, sizeof(u32), items, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = put_entry(key, 1, len, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = ebitmap_write(&usrdatum->roles, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = mls_write_range_helper(&usrdatum->range, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = mls_write_level(&usrdatum->dfltlevel, fp);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int ocontext_write(struct policydb *p, struct policydb_compat_info *info,\r\nvoid *fp)\r\n{\r\nunsigned int i, j, rc;\r\nsize_t nel, len;\r\n__le32 buf[3];\r\nu32 nodebuf[8];\r\nstruct ocontext *c;\r\nfor (i = 0; i < info->ocon_num; i++) {\r\nnel = 0;\r\nfor (c = p->ocontexts[i]; c; c = c->next)\r\nnel++;\r\nbuf[0] = cpu_to_le32(nel);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nfor (c = p->ocontexts[i]; c; c = c->next) {\r\nswitch (i) {\r\ncase OCON_ISID:\r\nbuf[0] = cpu_to_le32(c->sid[0]);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = context_write(p, &c->context[0], fp);\r\nif (rc)\r\nreturn rc;\r\nbreak;\r\ncase OCON_FS:\r\ncase OCON_NETIF:\r\nlen = strlen(c->u.name);\r\nbuf[0] = cpu_to_le32(len);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = put_entry(c->u.name, 1, len, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = context_write(p, &c->context[0], fp);\r\nif (rc)\r\nreturn rc;\r\nrc = context_write(p, &c->context[1], fp);\r\nif (rc)\r\nreturn rc;\r\nbreak;\r\ncase OCON_PORT:\r\nbuf[0] = cpu_to_le32(c->u.port.protocol);\r\nbuf[1] = cpu_to_le32(c->u.port.low_port);\r\nbuf[2] = cpu_to_le32(c->u.port.high_port);\r\nrc = put_entry(buf, sizeof(u32), 3, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = context_write(p, &c->context[0], fp);\r\nif (rc)\r\nreturn rc;\r\nbreak;\r\ncase OCON_NODE:\r\nnodebuf[0] = c->u.node.addr;\r\nnodebuf[1] = c->u.node.mask;\r\nrc = put_entry(nodebuf, sizeof(u32), 2, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = context_write(p, &c->context[0], fp);\r\nif (rc)\r\nreturn rc;\r\nbreak;\r\ncase OCON_FSUSE:\r\nbuf[0] = cpu_to_le32(c->v.behavior);\r\nlen = strlen(c->u.name);\r\nbuf[1] = cpu_to_le32(len);\r\nrc = put_entry(buf, sizeof(u32), 2, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = put_entry(c->u.name, 1, len, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = context_write(p, &c->context[0], fp);\r\nif (rc)\r\nreturn rc;\r\nbreak;\r\ncase OCON_NODE6:\r\nfor (j = 0; j < 4; j++)\r\nnodebuf[j] = c->u.node6.addr[j];\r\nfor (j = 0; j < 4; j++)\r\nnodebuf[j + 4] = c->u.node6.mask[j];\r\nrc = put_entry(nodebuf, sizeof(u32), 8, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = context_write(p, &c->context[0], fp);\r\nif (rc)\r\nreturn rc;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int genfs_write(struct policydb *p, void *fp)\r\n{\r\nstruct genfs *genfs;\r\nstruct ocontext *c;\r\nsize_t len;\r\n__le32 buf[1];\r\nint rc;\r\nlen = 0;\r\nfor (genfs = p->genfs; genfs; genfs = genfs->next)\r\nlen++;\r\nbuf[0] = cpu_to_le32(len);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nfor (genfs = p->genfs; genfs; genfs = genfs->next) {\r\nlen = strlen(genfs->fstype);\r\nbuf[0] = cpu_to_le32(len);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = put_entry(genfs->fstype, 1, len, fp);\r\nif (rc)\r\nreturn rc;\r\nlen = 0;\r\nfor (c = genfs->head; c; c = c->next)\r\nlen++;\r\nbuf[0] = cpu_to_le32(len);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nfor (c = genfs->head; c; c = c->next) {\r\nlen = strlen(c->u.name);\r\nbuf[0] = cpu_to_le32(len);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = put_entry(c->u.name, 1, len, fp);\r\nif (rc)\r\nreturn rc;\r\nbuf[0] = cpu_to_le32(c->v.sclass);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = context_write(p, &c->context[0], fp);\r\nif (rc)\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int hashtab_cnt(void *key, void *data, void *ptr)\r\n{\r\nint *cnt = ptr;\r\n*cnt = *cnt + 1;\r\nreturn 0;\r\n}\r\nstatic int range_write_helper(void *key, void *data, void *ptr)\r\n{\r\n__le32 buf[2];\r\nstruct range_trans *rt = key;\r\nstruct mls_range *r = data;\r\nstruct policy_data *pd = ptr;\r\nvoid *fp = pd->fp;\r\nstruct policydb *p = pd->p;\r\nint rc;\r\nbuf[0] = cpu_to_le32(rt->source_type);\r\nbuf[1] = cpu_to_le32(rt->target_type);\r\nrc = put_entry(buf, sizeof(u32), 2, fp);\r\nif (rc)\r\nreturn rc;\r\nif (p->policyvers >= POLICYDB_VERSION_RANGETRANS) {\r\nbuf[0] = cpu_to_le32(rt->target_class);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\n}\r\nrc = mls_write_range_helper(r, fp);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int range_write(struct policydb *p, void *fp)\r\n{\r\nsize_t nel;\r\n__le32 buf[1];\r\nint rc;\r\nstruct policy_data pd;\r\npd.p = p;\r\npd.fp = fp;\r\nnel = 0;\r\nrc = hashtab_map(p->range_tr, hashtab_cnt, &nel);\r\nif (rc)\r\nreturn rc;\r\nbuf[0] = cpu_to_le32(nel);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = hashtab_map(p->range_tr, range_write_helper, &pd);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int filename_write_helper(void *key, void *data, void *ptr)\r\n{\r\n__le32 buf[4];\r\nstruct filename_trans *ft = key;\r\nstruct filename_trans_datum *otype = data;\r\nvoid *fp = ptr;\r\nint rc;\r\nu32 len;\r\nlen = strlen(ft->name);\r\nbuf[0] = cpu_to_le32(len);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = put_entry(ft->name, sizeof(char), len, fp);\r\nif (rc)\r\nreturn rc;\r\nbuf[0] = ft->stype;\r\nbuf[1] = ft->ttype;\r\nbuf[2] = ft->tclass;\r\nbuf[3] = otype->otype;\r\nrc = put_entry(buf, sizeof(u32), 4, fp);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int filename_trans_write(struct policydb *p, void *fp)\r\n{\r\nu32 nel;\r\n__le32 buf[1];\r\nint rc;\r\nif (p->policyvers < POLICYDB_VERSION_FILENAME_TRANS)\r\nreturn 0;\r\nnel = 0;\r\nrc = hashtab_map(p->filename_trans, hashtab_cnt, &nel);\r\nif (rc)\r\nreturn rc;\r\nbuf[0] = cpu_to_le32(nel);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = hashtab_map(p->filename_trans, filename_write_helper, fp);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nint policydb_write(struct policydb *p, void *fp)\r\n{\r\nunsigned int i, num_syms;\r\nint rc;\r\n__le32 buf[4];\r\nu32 config;\r\nsize_t len;\r\nstruct policydb_compat_info *info;\r\nif (p->policyvers < POLICYDB_VERSION_AVTAB) {\r\nprintk(KERN_ERR "SELinux: refusing to write policy version %d."\r\n" Because it is less than version %d\n", p->policyvers,\r\nPOLICYDB_VERSION_AVTAB);\r\nreturn -EINVAL;\r\n}\r\nconfig = 0;\r\nif (p->mls_enabled)\r\nconfig |= POLICYDB_CONFIG_MLS;\r\nif (p->reject_unknown)\r\nconfig |= REJECT_UNKNOWN;\r\nif (p->allow_unknown)\r\nconfig |= ALLOW_UNKNOWN;\r\nbuf[0] = cpu_to_le32(POLICYDB_MAGIC);\r\nlen = strlen(POLICYDB_STRING);\r\nbuf[1] = cpu_to_le32(len);\r\nrc = put_entry(buf, sizeof(u32), 2, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = put_entry(POLICYDB_STRING, 1, len, fp);\r\nif (rc)\r\nreturn rc;\r\ninfo = policydb_lookup_compat(p->policyvers);\r\nif (!info) {\r\nprintk(KERN_ERR "SELinux: compatibility lookup failed for policy "\r\n"version %d", p->policyvers);\r\nreturn -EINVAL;\r\n}\r\nbuf[0] = cpu_to_le32(p->policyvers);\r\nbuf[1] = cpu_to_le32(config);\r\nbuf[2] = cpu_to_le32(info->sym_num);\r\nbuf[3] = cpu_to_le32(info->ocon_num);\r\nrc = put_entry(buf, sizeof(u32), 4, fp);\r\nif (rc)\r\nreturn rc;\r\nif (p->policyvers >= POLICYDB_VERSION_POLCAP) {\r\nrc = ebitmap_write(&p->policycaps, fp);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (p->policyvers >= POLICYDB_VERSION_PERMISSIVE) {\r\nrc = ebitmap_write(&p->permissive_map, fp);\r\nif (rc)\r\nreturn rc;\r\n}\r\nnum_syms = info->sym_num;\r\nfor (i = 0; i < num_syms; i++) {\r\nstruct policy_data pd;\r\npd.fp = fp;\r\npd.p = p;\r\nbuf[0] = cpu_to_le32(p->symtab[i].nprim);\r\nbuf[1] = cpu_to_le32(p->symtab[i].table->nel);\r\nrc = put_entry(buf, sizeof(u32), 2, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = hashtab_map(p->symtab[i].table, write_f[i], &pd);\r\nif (rc)\r\nreturn rc;\r\n}\r\nrc = avtab_write(p, &p->te_avtab, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = cond_write_list(p, p->cond_list, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = role_trans_write(p, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = role_allow_write(p->role_allow, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = filename_trans_write(p, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = ocontext_write(p, info, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = genfs_write(p, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = range_write(p, fp);\r\nif (rc)\r\nreturn rc;\r\nfor (i = 0; i < p->p_types.nprim; i++) {\r\nstruct ebitmap *e = flex_array_get(p->type_attr_map_array, i);\r\nBUG_ON(!e);\r\nrc = ebitmap_write(e, fp);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}
