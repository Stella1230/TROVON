static int send_dux_commands(struct usbduxfastsub_s *udfs, int cmd_type)\r\n{\r\nint tmp, nsent;\r\nudfs->dux_commands[0] = cmd_type;\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi%d: usbduxfast: dux_commands: ",\r\nudfs->comedidev->minor);\r\nfor (tmp = 0; tmp < SIZEOFDUXBUFFER; tmp++)\r\nprintk(" %02x", udfs->dux_commands[tmp]);\r\nprintk("\n");\r\n#endif\r\ntmp = usb_bulk_msg(udfs->usbdev,\r\nusb_sndbulkpipe(udfs->usbdev, CHANNELLISTEP),\r\nudfs->dux_commands, SIZEOFDUXBUFFER, &nsent, 10000);\r\nif (tmp < 0)\r\nprintk(KERN_ERR "comedi%d: could not transmit dux_commands to"\r\n"the usb-device, err=%d\n", udfs->comedidev->minor, tmp);\r\nreturn tmp;\r\n}\r\nstatic int usbduxfastsub_unlink_InURBs(struct usbduxfastsub_s *udfs)\r\n{\r\nint j = 0;\r\nint err = 0;\r\nif (udfs && udfs->urbIn) {\r\nudfs->ai_cmd_running = 0;\r\nusb_kill_urb(udfs->urbIn);\r\nj = 0;\r\n}\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi: usbduxfast: unlinked InURB: res=%d\n", j);\r\n#endif\r\nreturn err;\r\n}\r\nstatic int usbduxfast_ai_stop(struct usbduxfastsub_s *udfs, int do_unlink)\r\n{\r\nint ret = 0;\r\nif (!udfs) {\r\nprintk(KERN_ERR "comedi?: usbduxfast_ai_stop: udfs=NULL!\n");\r\nreturn -EFAULT;\r\n}\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi: usbduxfast_ai_stop\n");\r\n#endif\r\nudfs->ai_cmd_running = 0;\r\nif (do_unlink)\r\nret = usbduxfastsub_unlink_InURBs(udfs);\r\nreturn ret;\r\n}\r\nstatic int usbduxfast_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct usbduxfastsub_s *udfs;\r\nint ret;\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi: usbduxfast_ai_cancel\n");\r\n#endif\r\nudfs = dev->private;\r\nif (!udfs) {\r\nprintk(KERN_ERR "comedi: usbduxfast_ai_cancel: udfs=NULL\n");\r\nreturn -EFAULT;\r\n}\r\ndown(&udfs->sem);\r\nif (!udfs->probed) {\r\nup(&udfs->sem);\r\nreturn -ENODEV;\r\n}\r\nret = usbduxfast_ai_stop(udfs, 1);\r\nup(&udfs->sem);\r\nreturn ret;\r\n}\r\nstatic void usbduxfastsub_ai_Irq(struct urb *urb)\r\n{\r\nint n, err;\r\nstruct usbduxfastsub_s *udfs;\r\nstruct comedi_device *this_comedidev;\r\nstruct comedi_subdevice *s;\r\nuint16_t *p;\r\nif (!urb) {\r\nprintk(KERN_ERR "comedi_: usbduxfast_: ao int-handler called "\r\n"with urb=NULL!\n");\r\nreturn;\r\n}\r\nthis_comedidev = urb->context;\r\nif (!this_comedidev) {\r\nprintk(KERN_ERR "comedi_: usbduxfast_: urb context is a NULL "\r\n"pointer!\n");\r\nreturn;\r\n}\r\nudfs = this_comedidev->private;\r\nif (!udfs) {\r\nprintk(KERN_ERR "comedi_: usbduxfast_: private of comedi "\r\n"subdev is a NULL pointer!\n");\r\nreturn;\r\n}\r\nif (unlikely(!udfs->ai_cmd_running)) {\r\nreturn;\r\n}\r\nif (unlikely(!udfs->attached)) {\r\nreturn;\r\n}\r\ns = this_comedidev->subdevices + SUBDEV_AD;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ECONNABORTED:\r\ns->async->events |= COMEDI_CB_EOA;\r\ns->async->events |= COMEDI_CB_ERROR;\r\ncomedi_event(udfs->comedidev, s);\r\nusbduxfast_ai_stop(udfs, 0);\r\nreturn;\r\ndefault:\r\nprintk("comedi%d: usbduxfast: non-zero urb status received in "\r\n"ai intr context: %d\n",\r\nudfs->comedidev->minor, urb->status);\r\ns->async->events |= COMEDI_CB_EOA;\r\ns->async->events |= COMEDI_CB_ERROR;\r\ncomedi_event(udfs->comedidev, s);\r\nusbduxfast_ai_stop(udfs, 0);\r\nreturn;\r\n}\r\np = urb->transfer_buffer;\r\nif (!udfs->ignore) {\r\nif (!udfs->ai_continous) {\r\nn = urb->actual_length / sizeof(uint16_t);\r\nif (unlikely(udfs->ai_sample_count < n)) {\r\ncfc_write_array_to_buffer(s,\r\nurb->transfer_buffer,\r\nudfs->ai_sample_count\r\n* sizeof(uint16_t));\r\nusbduxfast_ai_stop(udfs, 0);\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_event(udfs->comedidev, s);\r\nreturn;\r\n}\r\nudfs->ai_sample_count -= n;\r\n}\r\nerr = cfc_write_array_to_buffer(s, urb->transfer_buffer,\r\nurb->actual_length);\r\nif (unlikely(err == 0)) {\r\nusbduxfast_ai_stop(udfs, 0);\r\nreturn;\r\n}\r\ncomedi_event(udfs->comedidev, s);\r\n} else {\r\nudfs->ignore--;\r\n}\r\nurb->dev = udfs->usbdev;\r\nurb->status = 0;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0) {\r\nprintk(KERN_ERR "comedi%d: usbduxfast: urb resubm failed: %d",\r\nudfs->comedidev->minor, err);\r\ns->async->events |= COMEDI_CB_EOA;\r\ns->async->events |= COMEDI_CB_ERROR;\r\ncomedi_event(udfs->comedidev, s);\r\nusbduxfast_ai_stop(udfs, 0);\r\n}\r\n}\r\nstatic int usbduxfastsub_start(struct usbduxfastsub_s *udfs)\r\n{\r\nint ret;\r\nunsigned char local_transfer_buffer[16];\r\nlocal_transfer_buffer[0] = 0;\r\nret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,\r\nVENDOR_DIR_OUT,\r\nUSBDUXFASTSUB_CPUCS,\r\n0x0000,\r\nlocal_transfer_buffer,\r\n1,\r\nEZTIMEOUT);\r\nif (ret < 0) {\r\nprintk("comedi_: usbduxfast_: control msg failed (start)\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbduxfastsub_stop(struct usbduxfastsub_s *udfs)\r\n{\r\nint ret;\r\nunsigned char local_transfer_buffer[16];\r\nlocal_transfer_buffer[0] = 1;\r\nret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,\r\nVENDOR_DIR_OUT,\r\nUSBDUXFASTSUB_CPUCS,\r\n0x0000,\r\nlocal_transfer_buffer, 1,\r\nEZTIMEOUT);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "comedi_: usbduxfast: control msg failed "\r\n"(stop)\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,\r\nunsigned char *local_transfer_buffer,\r\nunsigned int startAddr, unsigned int len)\r\n{\r\nint ret;\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi: usbduxfast: uploading %d bytes", len);\r\nprintk(KERN_DEBUG " to addr %d, first byte=%d.\n",\r\nstartAddr, local_transfer_buffer[0]);\r\n#endif\r\nret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,\r\nVENDOR_DIR_OUT,\r\nstartAddr,\r\n0x0000,\r\nlocal_transfer_buffer,\r\nlen,\r\nEZTIMEOUT);\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi_: usbduxfast: result=%d\n", ret);\r\n#endif\r\nif (ret < 0) {\r\nprintk(KERN_ERR "comedi_: usbduxfast: uppload failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbduxfastsub_submit_InURBs(struct usbduxfastsub_s *udfs)\r\n{\r\nint ret;\r\nif (!udfs)\r\nreturn -EFAULT;\r\nusb_fill_bulk_urb(udfs->urbIn, udfs->usbdev,\r\nusb_rcvbulkpipe(udfs->usbdev, BULKINEP),\r\nudfs->transfer_buffer,\r\nSIZEINBUF, usbduxfastsub_ai_Irq, udfs->comedidev);\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi%d: usbduxfast: submitting in-urb: "\r\n"0x%p,0x%p\n", udfs->comedidev->minor, udfs->urbIn->context,\r\nudfs->urbIn->dev);\r\n#endif\r\nret = usb_submit_urb(udfs->urbIn, GFP_ATOMIC);\r\nif (ret) {\r\nprintk(KERN_ERR "comedi_: usbduxfast: ai: usb_submit_urb error"\r\n" %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbduxfast_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0, stop_mask = 0;\r\nlong int steps, tmp;\r\nint minSamplPer;\r\nstruct usbduxfastsub_s *udfs = dev->private;\r\nif (!udfs->probed)\r\nreturn -ENODEV;\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi%d: usbduxfast_ai_cmdtest\n", dev->minor);\r\nprintk(KERN_DEBUG "comedi%d: usbduxfast: convert_arg=%u "\r\n"scan_begin_arg=%u\n",\r\ndev->minor, cmd->convert_arg, cmd->scan_begin_arg);\r\n#endif\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW | TRIG_EXT | TRIG_INT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_TIMER | TRIG_FOLLOW | TRIG_EXT;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_TIMER | TRIG_EXT;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\nstop_mask = TRIG_COUNT | TRIG_NONE;\r\ncmd->stop_src &= stop_mask;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->start_src != TRIG_NOW &&\r\ncmd->start_src != TRIG_EXT && cmd->start_src != TRIG_INT)\r\nerr++;\r\nif (cmd->scan_begin_src != TRIG_TIMER &&\r\ncmd->scan_begin_src != TRIG_FOLLOW &&\r\ncmd->scan_begin_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->stop_src != TRIG_COUNT &&\r\ncmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)\r\nerr++;\r\nif (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_src == TRIG_NOW && cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nif (!cmd->chanlist_len)\r\nerr++;\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->chanlist_len == 1)\r\nminSamplPer = 1;\r\nelse\r\nminSamplPer = MIN_SAMPLING_PERIOD;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nsteps = cmd->convert_arg * 30;\r\nif (steps < (minSamplPer * 1000))\r\nsteps = minSamplPer * 1000;\r\nif (steps > (MAX_SAMPLING_PERIOD * 1000))\r\nsteps = MAX_SAMPLING_PERIOD * 1000;\r\ntmp = steps / 30;\r\nif (cmd->convert_arg != tmp) {\r\ncmd->convert_arg = tmp;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER)\r\nerr++;\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nif (!cmd->stop_arg) {\r\ncmd->stop_arg = 1;\r\nerr++;\r\n}\r\nbreak;\r\ncase TRIG_NONE:\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (err)\r\nreturn 3;\r\nreturn 0;\r\n}\r\nstatic int usbduxfast_ai_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trignum)\r\n{\r\nint ret;\r\nstruct usbduxfastsub_s *udfs = dev->private;\r\nif (!udfs)\r\nreturn -EFAULT;\r\ndown(&udfs->sem);\r\nif (!udfs->probed) {\r\nup(&udfs->sem);\r\nreturn -ENODEV;\r\n}\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi%d: usbduxfast_ai_inttrig\n", dev->minor);\r\n#endif\r\nif (trignum != 0) {\r\nprintk(KERN_ERR "comedi%d: usbduxfast_ai_inttrig: invalid"\r\n" trignum\n", dev->minor);\r\nup(&udfs->sem);\r\nreturn -EINVAL;\r\n}\r\nif (!udfs->ai_cmd_running) {\r\nudfs->ai_cmd_running = 1;\r\nret = usbduxfastsub_submit_InURBs(udfs);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "comedi%d: usbduxfast_ai_inttrig: "\r\n"urbSubmit: err=%d\n", dev->minor, ret);\r\nudfs->ai_cmd_running = 0;\r\nup(&udfs->sem);\r\nreturn ret;\r\n}\r\ns->async->inttrig = NULL;\r\n} else {\r\nprintk(KERN_ERR "comedi%d: ai_inttrig but acqu is already"\r\n" running\n", dev->minor);\r\n}\r\nup(&udfs->sem);\r\nreturn 1;\r\n}\r\nstatic int usbduxfast_ai_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int chan, gain, rngmask = 0xff;\r\nint i, j, ret;\r\nstruct usbduxfastsub_s *udfs;\r\nint result;\r\nlong steps, steps_tmp;\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi%d: usbduxfast_ai_cmd\n", dev->minor);\r\n#endif\r\nudfs = dev->private;\r\nif (!udfs)\r\nreturn -EFAULT;\r\ndown(&udfs->sem);\r\nif (!udfs->probed) {\r\nup(&udfs->sem);\r\nreturn -ENODEV;\r\n}\r\nif (udfs->ai_cmd_running) {\r\nprintk(KERN_ERR "comedi%d: ai_cmd not possible. Another ai_cmd"\r\n" is running.\n", dev->minor);\r\nup(&udfs->sem);\r\nreturn -EBUSY;\r\n}\r\ns->async->cur_chan = 0;\r\nudfs->ignore = PACKETS_TO_IGNORE;\r\nif (cmd->chanlist_len > 0) {\r\ngain = CR_RANGE(cmd->chanlist[0]);\r\nfor (i = 0; i < cmd->chanlist_len; ++i) {\r\nchan = CR_CHAN(cmd->chanlist[i]);\r\nif (chan != i) {\r\nprintk(KERN_ERR "comedi%d: cmd is accepting "\r\n"only consecutive channels.\n",\r\ndev->minor);\r\nup(&udfs->sem);\r\nreturn -EINVAL;\r\n}\r\nif ((gain != CR_RANGE(cmd->chanlist[i]))\r\n&& (cmd->chanlist_len > 3)) {\r\nprintk(KERN_ERR "comedi%d: the gain must be"\r\n" the same for all channels.\n",\r\ndev->minor);\r\nup(&udfs->sem);\r\nreturn -EINVAL;\r\n}\r\nif (i >= NUMCHANNELS) {\r\nprintk(KERN_ERR "comedi%d: channel list too"\r\n" long\n", dev->minor);\r\nbreak;\r\n}\r\n}\r\n}\r\nsteps = 0;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nprintk(KERN_ERR "comedi%d: usbduxfast: "\r\n"scan_begin_src==TRIG_TIMER not valid.\n", dev->minor);\r\nup(&udfs->sem);\r\nreturn -EINVAL;\r\n}\r\nif (cmd->convert_src == TRIG_TIMER)\r\nsteps = (cmd->convert_arg * 30) / 1000;\r\nif ((steps < MIN_SAMPLING_PERIOD) && (cmd->chanlist_len != 1)) {\r\nprintk(KERN_ERR "comedi%d: usbduxfast: ai_cmd: steps=%ld, "\r\n"scan_begin_arg=%d. Not properly tested by cmdtest?\n",\r\ndev->minor, steps, cmd->scan_begin_arg);\r\nup(&udfs->sem);\r\nreturn -EINVAL;\r\n}\r\nif (steps > MAX_SAMPLING_PERIOD) {\r\nprintk(KERN_ERR "comedi%d: usbduxfast: ai_cmd: sampling rate "\r\n"too low.\n", dev->minor);\r\nup(&udfs->sem);\r\nreturn -EINVAL;\r\n}\r\nif ((cmd->start_src == TRIG_EXT) && (cmd->chanlist_len != 1)\r\n&& (cmd->chanlist_len != 16)) {\r\nprintk(KERN_ERR "comedi%d: usbduxfast: ai_cmd: TRIG_EXT only"\r\n" with 1 or 16 channels possible.\n", dev->minor);\r\nup(&udfs->sem);\r\nreturn -EINVAL;\r\n}\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi%d: usbduxfast: steps=%ld, convert_arg=%u\n",\r\ndev->minor, steps, cmd->convert_arg);\r\n#endif\r\nswitch (cmd->chanlist_len) {\r\ncase 1:\r\nif (CR_RANGE(cmd->chanlist[0]) > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nif (cmd->start_src == TRIG_EXT) {\r\nudfs->dux_commands[LENBASE + 0] = 0x01;\r\nudfs->dux_commands[OPBASE + 0] = 0x01;\r\nudfs->dux_commands[OUTBASE + 0] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 0] = 0x00;\r\n} else {\r\nudfs->dux_commands[LENBASE + 0] = 1;\r\nudfs->dux_commands[OPBASE + 0] = 0;\r\nudfs->dux_commands[OUTBASE + 0] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 0] = 0;\r\n}\r\nif (steps < MIN_SAMPLING_PERIOD) {\r\nif (steps <= 1) {\r\nudfs->dux_commands[LENBASE + 1] = 0x89;\r\nudfs->dux_commands[OPBASE + 1] = 0x03;\r\nudfs->dux_commands[OUTBASE + 1] =\r\n0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 1] = 0xFF;\r\n} else {\r\nudfs->dux_commands[LENBASE + 1] = steps - 1;\r\nudfs->dux_commands[OPBASE + 1] = 0x02;\r\nudfs->dux_commands[OUTBASE + 1] =\r\n0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 1] = 0;\r\nudfs->dux_commands[LENBASE + 2] = 0x09;\r\nudfs->dux_commands[OPBASE + 2] = 0x01;\r\nudfs->dux_commands[OUTBASE + 2] =\r\n0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 2] = 0xFF;\r\n}\r\n} else {\r\nsteps = steps - 1;\r\nudfs->dux_commands[LENBASE + 1] = steps / 2;\r\nudfs->dux_commands[OPBASE + 1] = 0;\r\nudfs->dux_commands[OUTBASE + 1] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 1] = 0;\r\nudfs->dux_commands[LENBASE + 2] = steps - steps / 2;\r\nudfs->dux_commands[OPBASE + 2] = 0;\r\nudfs->dux_commands[OUTBASE + 2] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 2] = 0;\r\nudfs->dux_commands[LENBASE + 3] = 0x09;\r\nudfs->dux_commands[OPBASE + 3] = 0x03;\r\nudfs->dux_commands[OUTBASE + 3] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 3] = 0xFF;\r\n}\r\nbreak;\r\ncase 2:\r\nif (CR_RANGE(cmd->chanlist[0]) > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nudfs->dux_commands[LENBASE + 0] = 1;\r\nudfs->dux_commands[OPBASE + 0] = 0x02;\r\nudfs->dux_commands[OUTBASE + 0] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 0] = 0;\r\nsteps_tmp = steps - 1;\r\nif (CR_RANGE(cmd->chanlist[1]) > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nudfs->dux_commands[LENBASE + 1] = steps_tmp / 2;\r\nudfs->dux_commands[OPBASE + 1] = 0;\r\nudfs->dux_commands[OUTBASE + 1] = 0xFE & rngmask;\r\nudfs->dux_commands[LOGBASE + 1] = 0;\r\nudfs->dux_commands[LENBASE + 2] = steps_tmp - steps_tmp / 2;\r\nudfs->dux_commands[OPBASE + 2] = 0;\r\nudfs->dux_commands[OUTBASE + 2] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 2] = 0;\r\nudfs->dux_commands[LENBASE + 3] = 1;\r\nudfs->dux_commands[OPBASE + 3] = 0x02;\r\nudfs->dux_commands[OUTBASE + 3] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 3] = 0;\r\nsteps_tmp = steps - 2;\r\nif (CR_RANGE(cmd->chanlist[0]) > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nudfs->dux_commands[LENBASE + 4] = steps_tmp / 2;\r\nudfs->dux_commands[OPBASE + 4] = 0;\r\nudfs->dux_commands[OUTBASE + 4] = (0xFF - 0x02) & rngmask;\r\nudfs->dux_commands[LOGBASE + 4] = 0;\r\nudfs->dux_commands[LENBASE + 5] = steps_tmp - steps_tmp / 2;\r\nudfs->dux_commands[OPBASE + 5] = 0;\r\nudfs->dux_commands[OUTBASE + 5] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 5] = 0;\r\nudfs->dux_commands[LENBASE + 6] = 1;\r\nudfs->dux_commands[OPBASE + 6] = 0;\r\nudfs->dux_commands[OUTBASE + 6] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 6] = 0;\r\nbreak;\r\ncase 3:\r\nfor (j = 0; j < 1; j++) {\r\nif (CR_RANGE(cmd->chanlist[j]) > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nudfs->dux_commands[LENBASE + j * 2] = steps / 2;\r\nudfs->dux_commands[OPBASE + j * 2] = 0x02;\r\nudfs->dux_commands[OUTBASE + j * 2] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + j * 2] = 0;\r\nif (CR_RANGE(cmd->chanlist[j + 1]) > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nudfs->dux_commands[LENBASE + j * 2 + 1] =\r\nsteps - steps / 2;\r\nudfs->dux_commands[OPBASE + j * 2 + 1] = 0;\r\nudfs->dux_commands[OUTBASE + j * 2 + 1] =\r\n0xFE & rngmask;\r\nudfs->dux_commands[LOGBASE + j * 2 + 1] = 0;\r\n}\r\nsteps_tmp = steps - 2;\r\nudfs->dux_commands[LENBASE + 4] = steps_tmp / 2;\r\nudfs->dux_commands[OPBASE + 4] = 0x02;\r\nudfs->dux_commands[OUTBASE + 4] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 4] = 0;\r\nif (CR_RANGE(cmd->chanlist[0]) > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nudfs->dux_commands[LENBASE + 5] = steps_tmp - steps_tmp / 2;\r\nudfs->dux_commands[OPBASE + 5] = 0;\r\nudfs->dux_commands[OUTBASE + 5] = (0xFF - 0x02) & rngmask;\r\nudfs->dux_commands[LOGBASE + 5] = 0;\r\nudfs->dux_commands[LENBASE + 6] = 1;\r\nudfs->dux_commands[OPBASE + 6] = 0;\r\nudfs->dux_commands[OUTBASE + 6] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 6] = 0;\r\ncase 16:\r\nif (CR_RANGE(cmd->chanlist[0]) > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nif (cmd->start_src == TRIG_EXT) {\r\nudfs->dux_commands[LENBASE + 0] = 0x01;\r\nudfs->dux_commands[OPBASE + 0] = 0x01;\r\nudfs->dux_commands[OUTBASE + 0] =\r\n(0xFF - 0x02) & rngmask;\r\nudfs->dux_commands[LOGBASE + 0] = 0x00;\r\n} else {\r\nudfs->dux_commands[LENBASE + 0] = 255;\r\nudfs->dux_commands[OPBASE + 0] = 0;\r\nudfs->dux_commands[OUTBASE + 0] =\r\n(0xFF - 0x02) & rngmask;\r\nudfs->dux_commands[LOGBASE + 0] = 0;\r\n}\r\nudfs->dux_commands[LENBASE + 1] = 1;\r\nudfs->dux_commands[OPBASE + 1] = 0x02;\r\nudfs->dux_commands[OUTBASE + 1] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 1] = 0;\r\nsteps = steps - 2;\r\nudfs->dux_commands[LENBASE + 2] = steps / 2;\r\nudfs->dux_commands[OPBASE + 2] = 0;\r\nudfs->dux_commands[OUTBASE + 2] = 0xFE & rngmask;\r\nudfs->dux_commands[LOGBASE + 2] = 0;\r\nudfs->dux_commands[LENBASE + 3] = steps - steps / 2;\r\nudfs->dux_commands[OPBASE + 3] = 0;\r\nudfs->dux_commands[OUTBASE + 3] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 3] = 0;\r\nudfs->dux_commands[LENBASE + 4] = 0x09;\r\nudfs->dux_commands[OPBASE + 4] = 0x01;\r\nudfs->dux_commands[OUTBASE + 4] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 4] = 0xFF;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "comedi %d: unsupported combination of "\r\n"channels\n", dev->minor);\r\nup(&udfs->sem);\r\nreturn -EFAULT;\r\n}\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi %d: sending commands to the usb device\n",\r\ndev->minor);\r\n#endif\r\nresult = send_dux_commands(udfs, SENDADCOMMANDS);\r\nif (result < 0) {\r\nprintk(KERN_ERR "comedi%d: adc command could not be submitted."\r\n"Aborting...\n", dev->minor);\r\nup(&udfs->sem);\r\nreturn result;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nudfs->ai_sample_count = cmd->stop_arg * cmd->scan_end_arg;\r\nif (udfs->ai_sample_count < 1) {\r\nprintk(KERN_ERR "comedi%d: "\r\n"(cmd->stop_arg)*(cmd->scan_end_arg)<1, "\r\n"aborting.\n", dev->minor);\r\nup(&udfs->sem);\r\nreturn -EFAULT;\r\n}\r\nudfs->ai_continous = 0;\r\n} else {\r\nudfs->ai_continous = 1;\r\nudfs->ai_sample_count = 0;\r\n}\r\nif ((cmd->start_src == TRIG_NOW) || (cmd->start_src == TRIG_EXT)) {\r\nudfs->ai_cmd_running = 1;\r\nret = usbduxfastsub_submit_InURBs(udfs);\r\nif (ret < 0) {\r\nudfs->ai_cmd_running = 0;\r\nup(&udfs->sem);\r\nreturn ret;\r\n}\r\ns->async->inttrig = NULL;\r\n} else {\r\ns->async->inttrig = usbduxfast_ai_inttrig;\r\n}\r\nup(&udfs->sem);\r\nreturn 0;\r\n}\r\nstatic int usbduxfast_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i, j, n, actual_length;\r\nint chan, range, rngmask;\r\nint err;\r\nstruct usbduxfastsub_s *udfs;\r\nudfs = dev->private;\r\nif (!udfs) {\r\nprintk(KERN_ERR "comedi%d: ai_insn_read: no usb dev.\n",\r\ndev->minor);\r\nreturn -ENODEV;\r\n}\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi%d: ai_insn_read, insn->n=%d, "\r\n"insn->subdev=%d\n", dev->minor, insn->n, insn->subdev);\r\n#endif\r\ndown(&udfs->sem);\r\nif (!udfs->probed) {\r\nup(&udfs->sem);\r\nreturn -ENODEV;\r\n}\r\nif (udfs->ai_cmd_running) {\r\nprintk(KERN_ERR "comedi%d: ai_insn_read not possible. Async "\r\n"Command is running.\n", dev->minor);\r\nup(&udfs->sem);\r\nreturn -EBUSY;\r\n}\r\nchan = CR_CHAN(insn->chanspec);\r\nrange = CR_RANGE(insn->chanspec);\r\nif (range > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nudfs->dux_commands[LENBASE + 0] = 1;\r\nudfs->dux_commands[OPBASE + 0] = 0x02;\r\nudfs->dux_commands[OUTBASE + 0] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 0] = 0;\r\nudfs->dux_commands[LENBASE + 1] = 12;\r\nudfs->dux_commands[OPBASE + 1] = 0;\r\nudfs->dux_commands[OUTBASE + 1] = 0xFE & rngmask;\r\nudfs->dux_commands[LOGBASE + 1] = 0;\r\nudfs->dux_commands[LENBASE + 2] = 1;\r\nudfs->dux_commands[OPBASE + 2] = 0;\r\nudfs->dux_commands[OUTBASE + 2] = 0xFE & rngmask;\r\nudfs->dux_commands[LOGBASE + 2] = 0;\r\nudfs->dux_commands[LENBASE + 3] = 1;\r\nudfs->dux_commands[OPBASE + 3] = 0;\r\nudfs->dux_commands[OUTBASE + 3] = 0xFE & rngmask;\r\nudfs->dux_commands[LOGBASE + 3] = 0;\r\nudfs->dux_commands[LENBASE + 4] = 1;\r\nudfs->dux_commands[OPBASE + 4] = 0;\r\nudfs->dux_commands[OUTBASE + 4] = 0xFE & rngmask;\r\nudfs->dux_commands[LOGBASE + 4] = 0;\r\nudfs->dux_commands[LENBASE + 5] = 12;\r\nudfs->dux_commands[OPBASE + 5] = 0;\r\nudfs->dux_commands[OUTBASE + 5] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 5] = 0;\r\nudfs->dux_commands[LENBASE + 6] = 1;\r\nudfs->dux_commands[OPBASE + 6] = 0;\r\nudfs->dux_commands[OUTBASE + 6] = 0xFF & rngmask;\r\nudfs->dux_commands[LOGBASE + 0] = 0;\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi %d: sending commands to the usb device\n",\r\ndev->minor);\r\n#endif\r\nerr = send_dux_commands(udfs, SENDADCOMMANDS);\r\nif (err < 0) {\r\nprintk(KERN_ERR "comedi%d: adc command could not be submitted."\r\n"Aborting...\n", dev->minor);\r\nup(&udfs->sem);\r\nreturn err;\r\n}\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi%d: usbduxfast: submitting in-urb: "\r\n"0x%p,0x%p\n", udfs->comedidev->minor, udfs->urbIn->context,\r\nudfs->urbIn->dev);\r\n#endif\r\nfor (i = 0; i < PACKETS_TO_IGNORE; i++) {\r\nerr = usb_bulk_msg(udfs->usbdev,\r\nusb_rcvbulkpipe(udfs->usbdev, BULKINEP),\r\nudfs->transfer_buffer, SIZEINBUF,\r\n&actual_length, 10000);\r\nif (err < 0) {\r\nprintk(KERN_ERR "comedi%d: insn timeout. No data.\n",\r\ndev->minor);\r\nup(&udfs->sem);\r\nreturn err;\r\n}\r\n}\r\nfor (i = 0; i < insn->n;) {\r\nerr = usb_bulk_msg(udfs->usbdev,\r\nusb_rcvbulkpipe(udfs->usbdev, BULKINEP),\r\nudfs->transfer_buffer, SIZEINBUF,\r\n&actual_length, 10000);\r\nif (err < 0) {\r\nprintk(KERN_ERR "comedi%d: insn data error: %d\n",\r\ndev->minor, err);\r\nup(&udfs->sem);\r\nreturn err;\r\n}\r\nn = actual_length / sizeof(uint16_t);\r\nif ((n % 16) != 0) {\r\nprintk(KERN_ERR "comedi%d: insn data packet "\r\n"corrupted.\n", dev->minor);\r\nup(&udfs->sem);\r\nreturn -EINVAL;\r\n}\r\nfor (j = chan; (j < n) && (i < insn->n); j = j + 16) {\r\ndata[i] = ((uint16_t *) (udfs->transfer_buffer))[j];\r\ni++;\r\n}\r\n}\r\nup(&udfs->sem);\r\nreturn i;\r\n}\r\nstatic int firmwareUpload(struct usbduxfastsub_s *usbduxfastsub,\r\nconst u8 *firmwareBinary, int sizeFirmware)\r\n{\r\nint ret;\r\nuint8_t *fwBuf;\r\nif (!firmwareBinary)\r\nreturn 0;\r\nif (sizeFirmware > FIRMWARE_MAX_LEN) {\r\ndev_err(&usbduxfastsub->interface->dev,\r\n"comedi_: usbduxfast firmware binary it too large for FX2.\n");\r\nreturn -ENOMEM;\r\n}\r\nfwBuf = kmemdup(firmwareBinary, sizeFirmware, GFP_KERNEL);\r\nif (!fwBuf) {\r\ndev_err(&usbduxfastsub->interface->dev,\r\n"comedi_: mem alloc for firmware failed\n");\r\nreturn -ENOMEM;\r\n}\r\nret = usbduxfastsub_stop(usbduxfastsub);\r\nif (ret < 0) {\r\ndev_err(&usbduxfastsub->interface->dev,\r\n"comedi_: can not stop firmware\n");\r\nkfree(fwBuf);\r\nreturn ret;\r\n}\r\nret = usbduxfastsub_upload(usbduxfastsub, fwBuf, 0, sizeFirmware);\r\nif (ret < 0) {\r\ndev_err(&usbduxfastsub->interface->dev,\r\n"comedi_: firmware upload failed\n");\r\nkfree(fwBuf);\r\nreturn ret;\r\n}\r\nret = usbduxfastsub_start(usbduxfastsub);\r\nif (ret < 0) {\r\ndev_err(&usbduxfastsub->interface->dev,\r\n"comedi_: can not start firmware\n");\r\nkfree(fwBuf);\r\nreturn ret;\r\n}\r\nkfree(fwBuf);\r\nreturn 0;\r\n}\r\nstatic void tidy_up(struct usbduxfastsub_s *udfs)\r\n{\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi_: usbduxfast: tiding up\n");\r\n#endif\r\nif (!udfs)\r\nreturn;\r\nif (udfs->interface)\r\nusb_set_intfdata(udfs->interface, NULL);\r\nudfs->probed = 0;\r\nif (udfs->urbIn) {\r\nusb_kill_urb(udfs->urbIn);\r\nkfree(udfs->transfer_buffer);\r\nudfs->transfer_buffer = NULL;\r\nusb_free_urb(udfs->urbIn);\r\nudfs->urbIn = NULL;\r\n}\r\nkfree(udfs->insnBuffer);\r\nudfs->insnBuffer = NULL;\r\nkfree(udfs->dux_commands);\r\nudfs->dux_commands = NULL;\r\nudfs->ai_cmd_running = 0;\r\n}\r\nstatic void usbduxfast_firmware_request_complete_handler(const struct firmware\r\n*fw, void *context)\r\n{\r\nstruct usbduxfastsub_s *usbduxfastsub_tmp = context;\r\nstruct usb_device *usbdev = usbduxfastsub_tmp->usbdev;\r\nint ret;\r\nif (fw == NULL)\r\nreturn;\r\nret = firmwareUpload(usbduxfastsub_tmp, fw->data, fw->size);\r\nif (ret) {\r\ndev_err(&usbdev->dev,\r\n"Could not upload firmware (err=%d)\n", ret);\r\ngoto out;\r\n}\r\ncomedi_usb_auto_config(usbdev, BOARDNAME);\r\nout:\r\nrelease_firmware(fw);\r\n}\r\nstatic int usbduxfastsub_probe(struct usb_interface *uinterf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(uinterf);\r\nint i;\r\nint index;\r\nint ret;\r\nif (udev->speed != USB_SPEED_HIGH) {\r\nprintk(KERN_ERR "comedi_: usbduxfast_: This driver needs"\r\n"USB 2.0 to operate. Aborting...\n");\r\nreturn -ENODEV;\r\n}\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi_: usbduxfast_: finding a free structure for "\r\n"the usb-device\n");\r\n#endif\r\ndown(&start_stop_sem);\r\nindex = -1;\r\nfor (i = 0; i < NUMUSBDUXFAST; i++) {\r\nif (!usbduxfastsub[i].probed) {\r\nindex = i;\r\nbreak;\r\n}\r\n}\r\nif (index == -1) {\r\nprintk(KERN_ERR "Too many usbduxfast-devices connected.\n");\r\nup(&start_stop_sem);\r\nreturn -EMFILE;\r\n}\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi_: usbduxfast: usbduxfastsub[%d] is ready to "\r\n"connect to comedi.\n", index);\r\n#endif\r\nsema_init(&(usbduxfastsub[index].sem), 1);\r\nusbduxfastsub[index].usbdev = udev;\r\nusbduxfastsub[index].interface = uinterf;\r\nusbduxfastsub[index].ifnum = uinterf->altsetting->desc.bInterfaceNumber;\r\nusb_set_intfdata(uinterf, &(usbduxfastsub[index]));\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi_: usbduxfast: ifnum=%d\n",\r\nusbduxfastsub[index].ifnum);\r\n#endif\r\nusbduxfastsub[index].dux_commands = kmalloc(SIZEOFDUXBUFFER,\r\nGFP_KERNEL);\r\nif (!usbduxfastsub[index].dux_commands) {\r\nprintk(KERN_ERR "comedi_: usbduxfast: error alloc space for "\r\n"dac commands\n");\r\ntidy_up(&(usbduxfastsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\nusbduxfastsub[index].insnBuffer = kmalloc(SIZEINSNBUF, GFP_KERNEL);\r\nif (!usbduxfastsub[index].insnBuffer) {\r\nprintk(KERN_ERR "comedi_: usbduxfast: could not alloc space "\r\n"for insnBuffer\n");\r\ntidy_up(&(usbduxfastsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\ni = usb_set_interface(usbduxfastsub[index].usbdev,\r\nusbduxfastsub[index].ifnum, 1);\r\nif (i < 0) {\r\nprintk(KERN_ERR "comedi_: usbduxfast%d: could not switch to "\r\n"alternate setting 1.\n", index);\r\ntidy_up(&(usbduxfastsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENODEV;\r\n}\r\nusbduxfastsub[index].urbIn = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!usbduxfastsub[index].urbIn) {\r\nprintk(KERN_ERR "comedi_: usbduxfast%d: Could not alloc."\r\n"urb\n", index);\r\ntidy_up(&(usbduxfastsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\nusbduxfastsub[index].transfer_buffer = kmalloc(SIZEINBUF, GFP_KERNEL);\r\nif (!usbduxfastsub[index].transfer_buffer) {\r\nprintk(KERN_ERR "comedi_: usbduxfast%d: could not alloc. "\r\n"transb.\n", index);\r\ntidy_up(&(usbduxfastsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\nusbduxfastsub[index].probed = 1;\r\nup(&start_stop_sem);\r\nret = request_firmware_nowait(THIS_MODULE,\r\nFW_ACTION_HOTPLUG,\r\n"usbduxfast_firmware.bin",\r\n&udev->dev,\r\nGFP_KERNEL,\r\nusbduxfastsub + index,\r\nusbduxfast_firmware_request_complete_handler);\r\nif (ret) {\r\ndev_err(&udev->dev, "could not load firmware (err=%d)\n", ret);\r\nreturn ret;\r\n}\r\nprintk(KERN_INFO "comedi_: usbduxfast%d has been successfully "\r\n"initialized.\n", index);\r\nreturn 0;\r\n}\r\nstatic void usbduxfastsub_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usbduxfastsub_s *udfs = usb_get_intfdata(intf);\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nif (!udfs) {\r\nprintk(KERN_ERR "comedi_: usbduxfast: disconnect called with "\r\n"null pointer.\n");\r\nreturn;\r\n}\r\nif (udfs->usbdev != udev) {\r\nprintk(KERN_ERR "comedi_: usbduxfast: BUG! called with wrong "\r\n"ptr!!!\n");\r\nreturn;\r\n}\r\ncomedi_usb_auto_unconfig(udev);\r\ndown(&start_stop_sem);\r\ndown(&udfs->sem);\r\ntidy_up(udfs);\r\nup(&udfs->sem);\r\nup(&start_stop_sem);\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi_: usbduxfast: disconnected from the usb\n");\r\n#endif\r\n}\r\nstatic int usbduxfast_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nint ret;\r\nint index;\r\nint i;\r\nstruct comedi_subdevice *s = NULL;\r\ndev->private = NULL;\r\ndown(&start_stop_sem);\r\nindex = -1;\r\nfor (i = 0; i < NUMUSBDUXFAST; i++) {\r\nif (usbduxfastsub[i].probed && !usbduxfastsub[i].attached) {\r\nindex = i;\r\nbreak;\r\n}\r\n}\r\nif (index < 0) {\r\nprintk(KERN_ERR "comedi%d: usbduxfast: error: attach failed, "\r\n"no usbduxfast devs connected to the usb bus.\n",\r\ndev->minor);\r\nup(&start_stop_sem);\r\nreturn -ENODEV;\r\n}\r\ndown(&(usbduxfastsub[index].sem));\r\nusbduxfastsub[index].comedidev = dev;\r\nif (comedi_aux_data(it->options, 0) &&\r\nit->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {\r\nfirmwareUpload(&usbduxfastsub[index],\r\ncomedi_aux_data(it->options, 0),\r\nit->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);\r\n}\r\ndev->board_name = BOARDNAME;\r\ndev->n_subdevices = N_SUBDEVICES;\r\nret = alloc_subdevices(dev, N_SUBDEVICES);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "comedi%d: usbduxfast: error alloc space for "\r\n"subdev\n", dev->minor);\r\nup(&(usbduxfastsub[index].sem));\r\nup(&start_stop_sem);\r\nreturn ret;\r\n}\r\nprintk(KERN_INFO "comedi%d: usbduxfast: usb-device %d is attached to "\r\n"comedi.\n", dev->minor, index);\r\ndev->private = usbduxfastsub + index;\r\ns = dev->subdevices + SUBDEV_AD;\r\ndev->read_subdev = s;\r\ns->private = NULL;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;\r\ns->n_chan = 16;\r\ns->len_chanlist = 16;\r\ns->insn_read = usbduxfast_ai_insn_read;\r\ns->do_cmdtest = usbduxfast_ai_cmdtest;\r\ns->do_cmd = usbduxfast_ai_cmd;\r\ns->cancel = usbduxfast_ai_cancel;\r\ns->maxdata = 0x1000;\r\ns->range_table = &range_usbduxfast_ai_range;\r\nusbduxfastsub[index].attached = 1;\r\nup(&(usbduxfastsub[index].sem));\r\nup(&start_stop_sem);\r\nprintk(KERN_INFO "comedi%d: successfully attached to usbduxfast.\n",\r\ndev->minor);\r\nreturn 0;\r\n}\r\nstatic int usbduxfast_detach(struct comedi_device *dev)\r\n{\r\nstruct usbduxfastsub_s *udfs;\r\nif (!dev) {\r\nprintk(KERN_ERR "comedi?: usbduxfast: detach without dev "\r\n"variable...\n");\r\nreturn -EFAULT;\r\n}\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi%d: usbduxfast: detach usb device\n",\r\ndev->minor);\r\n#endif\r\nudfs = dev->private;\r\nif (!udfs) {\r\nprintk(KERN_ERR "comedi?: usbduxfast: detach without ptr to "\r\n"usbduxfastsub[]\n");\r\nreturn -EFAULT;\r\n}\r\ndown(&udfs->sem);\r\ndown(&start_stop_sem);\r\ndev->private = NULL;\r\nudfs->attached = 0;\r\nudfs->comedidev = NULL;\r\n#ifdef CONFIG_COMEDI_DEBUG\r\nprintk(KERN_DEBUG "comedi%d: usbduxfast: detach: successfully "\r\n"removed\n", dev->minor);\r\n#endif\r\nup(&start_stop_sem);\r\nup(&udfs->sem);\r\nreturn 0;\r\n}\r\nstatic int __init init_usbduxfast(void)\r\n{\r\nprintk(KERN_INFO\r\nKBUILD_MODNAME ": " DRIVER_VERSION ":" DRIVER_DESC "\n");\r\nusb_register(&usbduxfastsub_driver);\r\ncomedi_driver_register(&driver_usbduxfast);\r\nreturn 0;\r\n}\r\nstatic void __exit exit_usbduxfast(void)\r\n{\r\ncomedi_driver_unregister(&driver_usbduxfast);\r\nusb_deregister(&usbduxfastsub_driver);\r\n}
