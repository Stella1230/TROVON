static void wait_for_scb_cmd(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < 16384; i++) {\r\nif (readb(&p->scb->cmd_cuc) == 0)\r\nbreak;\r\nudelay(4);\r\nif (i == 16383) {\r\nprintk(KERN_ERR "%s: scb_cmd timed out: %04x,%04x .. disabling i82586!!\n",\r\ndev->name, readb(&p->scb->cmd_cuc), readb(&p->scb->cus));\r\nif (!p->reset) {\r\np->reset = 1;\r\nni_reset586();\r\n}\r\n}\r\n}\r\n}\r\nstatic void wait_for_scb_cmd_ruc(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < 16384; i++) {\r\nif (readb(&p->scb->cmd_ruc) == 0)\r\nbreak;\r\nudelay(4);\r\nif (i == 16383) {\r\nprintk(KERN_ERR "%s: scb_cmd (ruc) timed out: %04x,%04x .. disabling i82586!!\n",\r\ndev->name, readb(&p->scb->cmd_ruc),\r\nreadb(&p->scb->rus));\r\nif (!p->reset) {\r\np->reset = 1;\r\nni_reset586();\r\n}\r\n}\r\n}\r\n}\r\nstatic void wait_for_stat_compl(void __iomem *p)\r\n{\r\nstruct nop_cmd_struct __iomem *addr = p;\r\nint i;\r\nfor (i = 0; i < 32767; i++) {\r\nif (readw(&((addr)->cmd_status)) & STAT_COMPL)\r\nbreak;\r\nudelay(32);\r\n}\r\n}\r\nstatic int ni52_close(struct net_device *dev)\r\n{\r\nfree_irq(dev->irq, dev);\r\nni_reset586();\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int ni52_open(struct net_device *dev)\r\n{\r\nint ret;\r\nni_disint();\r\nalloc586(dev);\r\ninit586(dev);\r\nstartrecv586(dev);\r\nni_enaint();\r\nret = request_irq(dev->irq, ni52_interrupt, 0, dev->name, dev);\r\nif (ret) {\r\nni_reset586();\r\nreturn ret;\r\n}\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int check_iscp(struct net_device *dev, void __iomem *addr)\r\n{\r\nstruct iscp_struct __iomem *iscp = addr;\r\nstruct priv *p = netdev_priv(dev);\r\nmemset_io(iscp, 0, sizeof(struct iscp_struct));\r\nwritel(make24(iscp), &p->scp->iscp);\r\nwriteb(1, &iscp->busy);\r\nni_reset586();\r\nni_attn586();\r\nmdelay(32);\r\nif (readb(&iscp->busy))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int check586(struct net_device *dev, unsigned size)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\nint i;\r\np->mapped = ioremap(dev->mem_start, size);\r\nif (!p->mapped)\r\nreturn 0;\r\np->base = p->mapped + size - 0x01000000;\r\np->memtop = p->mapped + size;\r\np->scp = (struct scp_struct __iomem *)(p->base + SCP_DEFAULT_ADDRESS);\r\np->scb = (struct scb_struct __iomem *) p->mapped;\r\np->iscp = (struct iscp_struct __iomem *)p->scp - 1;\r\nmemset_io(p->scp, 0, sizeof(struct scp_struct));\r\nfor (i = 0; i < sizeof(struct scp_struct); i++)\r\nif (readb((char __iomem *)p->scp + i))\r\ngoto Enodev;\r\nwriteb(SYSBUSVAL, &p->scp->sysbus);\r\nif (readb(&p->scp->sysbus) != SYSBUSVAL)\r\ngoto Enodev;\r\nif (!check_iscp(dev, p->mapped))\r\ngoto Enodev;\r\nif (!check_iscp(dev, p->iscp))\r\ngoto Enodev;\r\nreturn 1;\r\nEnodev:\r\niounmap(p->mapped);\r\nreturn 0;\r\n}\r\nstatic void alloc586(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\nni_reset586();\r\nmdelay(32);\r\nmemset_io(p->iscp, 0, sizeof(struct iscp_struct));\r\nmemset_io(p->scp , 0, sizeof(struct scp_struct));\r\nwritel(make24(p->iscp), &p->scp->iscp);\r\nwriteb(SYSBUSVAL, &p->scp->sysbus);\r\nwritew(make16(p->scb), &p->iscp->scb_offset);\r\nwriteb(1, &p->iscp->busy);\r\nni_reset586();\r\nni_attn586();\r\nmdelay(32);\r\nif (readb(&p->iscp->busy))\r\nprintk(KERN_ERR "%s: Init-Problems (alloc).\n", dev->name);\r\np->reset = 0;\r\nmemset_io(p->scb, 0, sizeof(struct scb_struct));\r\n}\r\nstruct net_device * __init ni52_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct priv));\r\nstatic const int ports[] = {0x300, 0x280, 0x360, 0x320, 0x340, 0};\r\nconst int *port;\r\nstruct priv *p;\r\nint err = 0;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\np = netdev_priv(dev);\r\nif (unit >= 0) {\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nio = dev->base_addr;\r\nirq = dev->irq;\r\nmemstart = dev->mem_start;\r\nmemend = dev->mem_end;\r\n}\r\nif (io > 0x1ff) {\r\nerr = ni52_probe1(dev, io);\r\n} else if (io > 0) {\r\nerr = -ENXIO;\r\n} else {\r\nfor (port = ports; *port && ni52_probe1(dev, *port) ; port++)\r\n;\r\nif (*port)\r\ngoto got_it;\r\n#ifdef FULL_IO_PROBE\r\nfor (io = 0x200; io < 0x400 && ni52_probe1(dev, io); io += 8)\r\n;\r\nif (io < 0x400)\r\ngoto got_it;\r\n#endif\r\nerr = -ENODEV;\r\n}\r\nif (err)\r\ngoto out;\r\ngot_it:\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out1;\r\nreturn dev;\r\nout1:\r\niounmap(p->mapped);\r\nrelease_region(dev->base_addr, NI52_TOTAL_SIZE);\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init ni52_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nint i, size, retval;\r\nstruct priv *priv = netdev_priv(dev);\r\ndev->base_addr = ioaddr;\r\ndev->irq = irq;\r\ndev->mem_start = memstart;\r\ndev->mem_end = memend;\r\nspin_lock_init(&priv->spinlock);\r\nif (!request_region(ioaddr, NI52_TOTAL_SIZE, DRV_NAME))\r\nreturn -EBUSY;\r\nif (!(inb(ioaddr+NI52_MAGIC1) == NI52_MAGICVAL1) ||\r\n!(inb(ioaddr+NI52_MAGIC2) == NI52_MAGICVAL2)) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nfor (i = 0; i < ETH_ALEN; i++)\r\ndev->dev_addr[i] = inb(dev->base_addr+i);\r\nif (dev->dev_addr[0] != NI52_ADDR0 || dev->dev_addr[1] != NI52_ADDR1 ||\r\ndev->dev_addr[2] != NI52_ADDR2) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nprintk(KERN_INFO "%s: NI5210 found at %#3lx, ",\r\ndev->name, dev->base_addr);\r\n#ifdef MODULE\r\nsize = dev->mem_end - dev->mem_start;\r\nif (size != 0x2000 && size != 0x4000) {\r\nprintk("\n");\r\nprintk(KERN_ERR "%s: Invalid memory size %d. Allowed is 0x2000 or 0x4000 bytes.\n", dev->name, size);\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nif (!check586(dev, size)) {\r\nprintk(KERN_ERR "?memcheck, Can't find memory at 0x%lx with size %d!\n", dev->mem_start, size);\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\n#else\r\nif (dev->mem_start != 0) {\r\nsize = 0x4000;\r\nif (!check586(dev, size)) {\r\nsize = 0x2000;\r\nif (!check586(dev, size)) {\r\nprintk(KERN_ERR "?memprobe, Can't find memory at 0x%lx!\n", dev->mem_start);\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\n}\r\n} else {\r\nstatic const unsigned long memaddrs[] = {\r\n0xc8000, 0xca000, 0xcc000, 0xce000, 0xd0000, 0xd2000,\r\n0xd4000, 0xd6000, 0xd8000, 0xda000, 0xdc000, 0\r\n};\r\nfor (i = 0;; i++) {\r\nif (!memaddrs[i]) {\r\nprintk(KERN_ERR "?memprobe, Can't find io-memory!\n");\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\ndev->mem_start = memaddrs[i];\r\nsize = 0x2000;\r\nif (check586(dev, size))\r\nbreak;\r\nsize = 0x4000;\r\nif (check586(dev, size))\r\nbreak;\r\n}\r\n}\r\ndev->mem_end = dev->mem_start + size;\r\n#endif\r\nalloc586(dev);\r\nif (size == 0x2000)\r\npriv->num_recv_buffs = NUM_RECV_BUFFS_8;\r\nelse\r\npriv->num_recv_buffs = NUM_RECV_BUFFS_16;\r\nprintk(KERN_DEBUG "Memaddr: 0x%lx, Memsize: %d, ",\r\ndev->mem_start, size);\r\nif (dev->irq < 2) {\r\nunsigned long irq_mask;\r\nirq_mask = probe_irq_on();\r\nni_reset586();\r\nni_attn586();\r\nmdelay(20);\r\ndev->irq = probe_irq_off(irq_mask);\r\nif (!dev->irq) {\r\nprintk("?autoirq, Failed to detect IRQ line!\n");\r\nretval = -EAGAIN;\r\niounmap(priv->mapped);\r\ngoto out;\r\n}\r\nprintk("IRQ %d (autodetected).\n", dev->irq);\r\n} else {\r\nif (dev->irq == 2)\r\ndev->irq = 9;\r\nprintk("IRQ %d (assigned and not checked!).\n", dev->irq);\r\n}\r\ndev->netdev_ops = &ni52_netdev_ops;\r\ndev->watchdog_timeo = HZ/20;\r\nreturn 0;\r\nout:\r\nrelease_region(ioaddr, NI52_TOTAL_SIZE);\r\nreturn retval;\r\n}\r\nstatic int init586(struct net_device *dev)\r\n{\r\nvoid __iomem *ptr;\r\nint i, result = 0;\r\nstruct priv *p = netdev_priv(dev);\r\nstruct configure_cmd_struct __iomem *cfg_cmd;\r\nstruct iasetup_cmd_struct __iomem *ias_cmd;\r\nstruct tdr_cmd_struct __iomem *tdr_cmd;\r\nstruct mcsetup_cmd_struct __iomem *mc_cmd;\r\nstruct netdev_hw_addr *ha;\r\nint num_addrs = netdev_mc_count(dev);\r\nptr = p->scb + 1;\r\ncfg_cmd = ptr;\r\nwritew(0, &cfg_cmd->cmd_status);\r\nwritew(CMD_CONFIGURE | CMD_LAST, &cfg_cmd->cmd_cmd);\r\nwritew(0xFFFF, &cfg_cmd->cmd_link);\r\nwriteb(0x0a, &cfg_cmd->byte_cnt);\r\nwriteb(fifo, &cfg_cmd->fifo);\r\nwriteb(0x40, &cfg_cmd->sav_bf);\r\nwriteb(0x2e, &cfg_cmd->adr_len);\r\nwriteb(0x00, &cfg_cmd->priority);\r\nwriteb(0x60, &cfg_cmd->ifs);\r\nwriteb(0x00, &cfg_cmd->time_low);\r\nwriteb(0xf2, &cfg_cmd->time_high);\r\nwriteb(0x00, &cfg_cmd->promisc);\r\nif (dev->flags & IFF_ALLMULTI) {\r\nint len = ((char __iomem *)p->iscp - (char __iomem *)ptr - 8) / 6;\r\nif (num_addrs > len) {\r\nprintk(KERN_ERR "%s: switching to promisc. mode\n",\r\ndev->name);\r\nwriteb(0x01, &cfg_cmd->promisc);\r\n}\r\n}\r\nif (dev->flags & IFF_PROMISC)\r\nwriteb(0x01, &cfg_cmd->promisc);\r\nwriteb(0x00, &cfg_cmd->carr_coll);\r\nwritew(make16(cfg_cmd), &p->scb->cbl_offset);\r\nwriteb(0, &p->scb->cmd_ruc);\r\nwriteb(CUC_START, &p->scb->cmd_cuc);\r\nni_attn586();\r\nwait_for_stat_compl(cfg_cmd);\r\nif ((readw(&cfg_cmd->cmd_status) & (STAT_OK|STAT_COMPL)) !=\r\n(STAT_COMPL|STAT_OK)) {\r\nprintk(KERN_ERR "%s: configure command failed: %x\n",\r\ndev->name, readw(&cfg_cmd->cmd_status));\r\nreturn 1;\r\n}\r\nias_cmd = ptr;\r\nwritew(0, &ias_cmd->cmd_status);\r\nwritew(CMD_IASETUP | CMD_LAST, &ias_cmd->cmd_cmd);\r\nwritew(0xffff, &ias_cmd->cmd_link);\r\nmemcpy_toio(&ias_cmd->iaddr, (char *)dev->dev_addr, ETH_ALEN);\r\nwritew(make16(ias_cmd), &p->scb->cbl_offset);\r\nwriteb(CUC_START, &p->scb->cmd_cuc);\r\nni_attn586();\r\nwait_for_stat_compl(ias_cmd);\r\nif ((readw(&ias_cmd->cmd_status) & (STAT_OK|STAT_COMPL)) !=\r\n(STAT_OK|STAT_COMPL)) {\r\nprintk(KERN_ERR "%s (ni52): individual address setup command failed: %04x\n", dev->name, readw(&ias_cmd->cmd_status));\r\nreturn 1;\r\n}\r\ntdr_cmd = ptr;\r\nwritew(0, &tdr_cmd->cmd_status);\r\nwritew(CMD_TDR | CMD_LAST, &tdr_cmd->cmd_cmd);\r\nwritew(0xffff, &tdr_cmd->cmd_link);\r\nwritew(0, &tdr_cmd->status);\r\nwritew(make16(tdr_cmd), &p->scb->cbl_offset);\r\nwriteb(CUC_START, &p->scb->cmd_cuc);\r\nni_attn586();\r\nwait_for_stat_compl(tdr_cmd);\r\nif (!(readw(&tdr_cmd->cmd_status) & STAT_COMPL))\r\nprintk(KERN_ERR "%s: Problems while running the TDR.\n",\r\ndev->name);\r\nelse {\r\nudelay(16);\r\nresult = readw(&tdr_cmd->status);\r\nwriteb(readb(&p->scb->cus) & STAT_MASK, &p->scb->cmd_cuc);\r\nni_attn586();\r\nif (result & TDR_LNK_OK)\r\n;\r\nelse if (result & TDR_XCVR_PRB)\r\nprintk(KERN_ERR "%s: TDR: Transceiver problem. Check the cable(s)!\n",\r\ndev->name);\r\nelse if (result & TDR_ET_OPN)\r\nprintk(KERN_ERR "%s: TDR: No correct termination %d clocks away.\n",\r\ndev->name, result & TDR_TIMEMASK);\r\nelse if (result & TDR_ET_SRT) {\r\nif (result & TDR_TIMEMASK)\r\nprintk(KERN_ERR "%s: TDR: Detected a short circuit %d clocks away.\n",\r\ndev->name, result & TDR_TIMEMASK);\r\n} else\r\nprintk(KERN_ERR "%s: TDR: Unknown status %04x\n",\r\ndev->name, result);\r\n}\r\nif (num_addrs && !(dev->flags & IFF_PROMISC)) {\r\nmc_cmd = ptr;\r\nwritew(0, &mc_cmd->cmd_status);\r\nwritew(CMD_MCSETUP | CMD_LAST, &mc_cmd->cmd_cmd);\r\nwritew(0xffff, &mc_cmd->cmd_link);\r\nwritew(num_addrs * 6, &mc_cmd->mc_cnt);\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, dev)\r\nmemcpy_toio(mc_cmd->mc_list[i++], ha->addr, 6);\r\nwritew(make16(mc_cmd), &p->scb->cbl_offset);\r\nwriteb(CUC_START, &p->scb->cmd_cuc);\r\nni_attn586();\r\nwait_for_stat_compl(mc_cmd);\r\nif ((readw(&mc_cmd->cmd_status) & (STAT_COMPL|STAT_OK))\r\n!= (STAT_COMPL|STAT_OK))\r\nprintk(KERN_ERR "%s: Can't apply multicast-address-list.\n", dev->name);\r\n}\r\n#if (NUM_XMIT_BUFFS == 1)\r\nfor (i = 0; i < 2; i++) {\r\np->nop_cmds[i] = ptr;\r\nwritew(CMD_NOP, &p->nop_cmds[i]->cmd_cmd);\r\nwritew(0, &p->nop_cmds[i]->cmd_status);\r\nwritew(make16(p->nop_cmds[i]), &p->nop_cmds[i]->cmd_link);\r\nptr = ptr + sizeof(struct nop_cmd_struct);\r\n}\r\n#else\r\nfor (i = 0; i < NUM_XMIT_BUFFS; i++) {\r\np->nop_cmds[i] = ptr;\r\nwritew(CMD_NOP, &p->nop_cmds[i]->cmd_cmd);\r\nwritew(0, &p->nop_cmds[i]->cmd_status);\r\nwritew(make16(p->nop_cmds[i]), &p->nop_cmds[i]->cmd_link);\r\nptr = ptr + sizeof(struct nop_cmd_struct);\r\n}\r\n#endif\r\nptr = alloc_rfa(dev, ptr);\r\nfor (i = 0; i < NUM_XMIT_BUFFS; i++) {\r\np->xmit_cmds[i] = ptr;\r\nptr = ptr + sizeof(struct transmit_cmd_struct);\r\np->xmit_cbuffs[i] = ptr;\r\nptr = ptr + XMIT_BUFF_SIZE;\r\np->xmit_buffs[i] = ptr;\r\nptr = ptr + sizeof(struct tbd_struct);\r\nif ((void __iomem *)ptr > (void __iomem *)p->iscp) {\r\nprintk(KERN_ERR "%s: not enough shared-mem for your configuration!\n",\r\ndev->name);\r\nreturn 1;\r\n}\r\nmemset_io(p->xmit_cmds[i], 0,\r\nsizeof(struct transmit_cmd_struct));\r\nmemset_io(p->xmit_buffs[i], 0,\r\nsizeof(struct tbd_struct));\r\nwritew(make16(p->nop_cmds[(i+1)%NUM_XMIT_BUFFS]),\r\n&p->xmit_cmds[i]->cmd_link);\r\nwritew(STAT_COMPL, &p->xmit_cmds[i]->cmd_status);\r\nwritew(CMD_XMIT|CMD_INT, &p->xmit_cmds[i]->cmd_cmd);\r\nwritew(make16(p->xmit_buffs[i]), &p->xmit_cmds[i]->tbd_offset);\r\nwritew(0xffff, &p->xmit_buffs[i]->next);\r\nwritel(make24(p->xmit_cbuffs[i]), &p->xmit_buffs[i]->buffer);\r\n}\r\np->xmit_count = 0;\r\np->xmit_last = 0;\r\n#ifndef NO_NOPCOMMANDS\r\np->nop_point = 0;\r\n#endif\r\n#ifndef NO_NOPCOMMANDS\r\nwritew(make16(p->nop_cmds[0]), &p->scb->cbl_offset);\r\nwriteb(CUC_START, &p->scb->cmd_cuc);\r\nni_attn586();\r\nwait_for_scb_cmd(dev);\r\n#else\r\nwritew(make16(p->xmit_cmds[0]), &p->xmit_cmds[0]->cmd_link);\r\nwritew(CMD_XMIT | CMD_SUSPEND | CMD_INT, &p->xmit_cmds[0]->cmd_cmd);\r\n#endif\r\nwriteb(readb(&p->scb->cus) & STAT_MASK, &p->scb->cmd_cuc);\r\nni_attn586();\r\nudelay(16);\r\nni_enaint();\r\nreturn 0;\r\n}\r\nstatic void __iomem *alloc_rfa(struct net_device *dev, void __iomem *ptr)\r\n{\r\nstruct rfd_struct __iomem *rfd = ptr;\r\nstruct rbd_struct __iomem *rbd;\r\nint i;\r\nstruct priv *p = netdev_priv(dev);\r\nmemset_io(rfd, 0,\r\nsizeof(struct rfd_struct) * (p->num_recv_buffs + rfdadd));\r\np->rfd_first = rfd;\r\nfor (i = 0; i < (p->num_recv_buffs + rfdadd); i++) {\r\nwritew(make16(rfd + (i+1) % (p->num_recv_buffs+rfdadd)),\r\n&rfd[i].next);\r\nwritew(0xffff, &rfd[i].rbd_offset);\r\n}\r\nwriteb(RFD_SUSP, &rfd[p->num_recv_buffs-1+rfdadd].last);\r\nptr = rfd + (p->num_recv_buffs + rfdadd);\r\nrbd = ptr;\r\nptr = rbd + p->num_recv_buffs;\r\nmemset_io(rbd, 0, sizeof(struct rbd_struct) * (p->num_recv_buffs));\r\nfor (i = 0; i < p->num_recv_buffs; i++) {\r\nwritew(make16(rbd + (i+1) % p->num_recv_buffs), &rbd[i].next);\r\nwritew(RECV_BUFF_SIZE, &rbd[i].size);\r\nwritel(make24(ptr), &rbd[i].buffer);\r\nptr = ptr + RECV_BUFF_SIZE;\r\n}\r\np->rfd_top = p->rfd_first;\r\np->rfd_last = p->rfd_first + (p->num_recv_buffs - 1 + rfdadd);\r\nwritew(make16(p->rfd_first), &p->scb->rfa_offset);\r\nwritew(make16(rbd), &p->rfd_first->rbd_offset);\r\nreturn ptr;\r\n}\r\nstatic irqreturn_t ni52_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nunsigned int stat;\r\nint cnt = 0;\r\nstruct priv *p;\r\np = netdev_priv(dev);\r\nif (debuglevel > 1)\r\nprintk("I");\r\nspin_lock(&p->spinlock);\r\nwait_for_scb_cmd(dev);\r\nwhile ((stat = readb(&p->scb->cus) & STAT_MASK)) {\r\nwriteb(stat, &p->scb->cmd_cuc);\r\nni_attn586();\r\nif (stat & STAT_FR)\r\nni52_rcv_int(dev);\r\nif (stat & STAT_RNR) {\r\nprintk("(R)");\r\nif (readb(&p->scb->rus) & RU_SUSPEND) {\r\nwait_for_scb_cmd(dev);\r\nwriteb(RUC_RESUME, &p->scb->cmd_ruc);\r\nni_attn586();\r\nwait_for_scb_cmd_ruc(dev);\r\n} else {\r\nprintk(KERN_ERR "%s: Receiver-Unit went 'NOT READY': %04x/%02x.\n",\r\ndev->name, stat, readb(&p->scb->rus));\r\nni52_rnr_int(dev);\r\n}\r\n}\r\nif (stat & STAT_CX)\r\nni52_xmt_int(dev);\r\n#ifndef NO_NOPCOMMANDS\r\nif (stat & STAT_CNA) {\r\nif (netif_running(dev))\r\nprintk(KERN_ERR "%s: oops! CU has left active state. stat: %04x/%02x.\n",\r\ndev->name, stat, readb(&p->scb->cus));\r\n}\r\n#endif\r\nif (debuglevel > 1)\r\nprintk("%d", cnt++);\r\nwait_for_scb_cmd(dev);\r\nif (readb(&p->scb->cmd_cuc)) {\r\nprintk(KERN_ERR "%s: Acknowledge timed out.\n",\r\ndev->name);\r\nni_disint();\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&p->spinlock);\r\nif (debuglevel > 1)\r\nprintk("i");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ni52_rcv_int(struct net_device *dev)\r\n{\r\nint status, cnt = 0;\r\nunsigned short totlen;\r\nstruct sk_buff *skb;\r\nstruct rbd_struct __iomem *rbd;\r\nstruct priv *p = netdev_priv(dev);\r\nif (debuglevel > 0)\r\nprintk("R");\r\nfor (; (status = readb(&p->rfd_top->stat_high)) & RFD_COMPL;) {\r\nrbd = make32(readw(&p->rfd_top->rbd_offset));\r\nif (status & RFD_OK) {\r\ntotlen = readw(&rbd->status);\r\nif (totlen & RBD_LAST) {\r\ntotlen &= RBD_MASK;\r\nwritew(0x00, &rbd->status);\r\nskb = (struct sk_buff *)dev_alloc_skb(totlen+2);\r\nif (skb != NULL) {\r\nskb_reserve(skb, 2);\r\nskb_put(skb, totlen);\r\nmemcpy_fromio(skb->data, p->base + readl(&rbd->buffer), totlen);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += totlen;\r\n} else\r\ndev->stats.rx_dropped++;\r\n} else {\r\nint rstat;\r\ntotlen = 0;\r\nwhile (!((rstat = readw(&rbd->status)) & RBD_LAST)) {\r\ntotlen += rstat & RBD_MASK;\r\nif (!rstat) {\r\nprintk(KERN_ERR "%s: Whoops .. no end mark in RBD list\n", dev->name);\r\nbreak;\r\n}\r\nwritew(0, &rbd->status);\r\nrbd = make32(readw(&rbd->next));\r\n}\r\ntotlen += rstat & RBD_MASK;\r\nwritew(0, &rbd->status);\r\nprintk(KERN_ERR "%s: received oversized frame! length: %d\n",\r\ndev->name, totlen);\r\ndev->stats.rx_dropped++;\r\n}\r\n} else {\r\nprintk(KERN_ERR "%s: oops! rfd-error-status: %04x\n",\r\ndev->name, status);\r\ndev->stats.rx_errors++;\r\n}\r\nwriteb(0, &p->rfd_top->stat_high);\r\nwriteb(RFD_SUSP, &p->rfd_top->last);\r\nwritew(0xffff, &p->rfd_top->rbd_offset);\r\nwriteb(0, &p->rfd_last->last);\r\np->rfd_last = p->rfd_top;\r\np->rfd_top = make32(readw(&p->rfd_top->next));\r\nwritew(make16(p->rfd_top), &p->scb->rfa_offset);\r\nif (debuglevel > 0)\r\nprintk("%d", cnt++);\r\n}\r\nif (automatic_resume) {\r\nwait_for_scb_cmd(dev);\r\nwriteb(RUC_RESUME, &p->scb->cmd_ruc);\r\nni_attn586();\r\nwait_for_scb_cmd_ruc(dev);\r\n}\r\n#ifdef WAIT_4_BUSY\r\n{\r\nint i;\r\nfor (i = 0; i < 1024; i++) {\r\nif (p->rfd_top->status)\r\nbreak;\r\nudelay(16);\r\nif (i == 1023)\r\nprintk(KERN_ERR "%s: RU hasn't fetched next RFD (not busy/complete)\n", dev->name);\r\n}\r\n}\r\n#endif\r\nif (debuglevel > 0)\r\nprintk("r");\r\n}\r\nstatic void ni52_rnr_int(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\ndev->stats.rx_errors++;\r\nwait_for_scb_cmd(dev);\r\nwriteb(RUC_ABORT, &p->scb->cmd_ruc);\r\nni_attn586();\r\nwait_for_scb_cmd_ruc(dev);\r\nalloc_rfa(dev, p->rfd_first);\r\nstartrecv586(dev);\r\nprintk(KERN_ERR "%s: Receive-Unit restarted. Status: %04x\n",\r\ndev->name, readb(&p->scb->rus));\r\n}\r\nstatic void ni52_xmt_int(struct net_device *dev)\r\n{\r\nint status;\r\nstruct priv *p = netdev_priv(dev);\r\nif (debuglevel > 0)\r\nprintk("X");\r\nstatus = readw(&p->xmit_cmds[p->xmit_last]->cmd_status);\r\nif (!(status & STAT_COMPL))\r\nprintk(KERN_ERR "%s: strange .. xmit-int without a 'COMPLETE'\n", dev->name);\r\nif (status & STAT_OK) {\r\ndev->stats.tx_packets++;\r\ndev->stats.collisions += (status & TCMD_MAXCOLLMASK);\r\n} else {\r\ndev->stats.tx_errors++;\r\nif (status & TCMD_LATECOLL) {\r\nprintk(KERN_ERR "%s: late collision detected.\n",\r\ndev->name);\r\ndev->stats.collisions++;\r\n} else if (status & TCMD_NOCARRIER) {\r\ndev->stats.tx_carrier_errors++;\r\nprintk(KERN_ERR "%s: no carrier detected.\n",\r\ndev->name);\r\n} else if (status & TCMD_LOSTCTS)\r\nprintk(KERN_ERR "%s: loss of CTS detected.\n",\r\ndev->name);\r\nelse if (status & TCMD_UNDERRUN) {\r\ndev->stats.tx_fifo_errors++;\r\nprintk(KERN_ERR "%s: DMA underrun detected.\n",\r\ndev->name);\r\n} else if (status & TCMD_MAXCOLL) {\r\nprintk(KERN_ERR "%s: Max. collisions exceeded.\n",\r\ndev->name);\r\ndev->stats.collisions += 16;\r\n}\r\n}\r\n#if (NUM_XMIT_BUFFS > 1)\r\nif ((++p->xmit_last) == NUM_XMIT_BUFFS)\r\np->xmit_last = 0;\r\n#endif\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void startrecv586(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\nwait_for_scb_cmd(dev);\r\nwait_for_scb_cmd_ruc(dev);\r\nwritew(make16(p->rfd_first), &p->scb->rfa_offset);\r\nwriteb(RUC_START, &p->scb->cmd_ruc);\r\nni_attn586();\r\nwait_for_scb_cmd_ruc(dev);\r\n}\r\nstatic void ni52_timeout(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\n#ifndef NO_NOPCOMMANDS\r\nif (readb(&p->scb->cus) & CU_ACTIVE) {\r\nnetif_wake_queue(dev);\r\n#ifdef DEBUG\r\nprintk(KERN_ERR "%s: strange ... timeout with CU active?!?\n",\r\ndev->name);\r\nprintk(KERN_ERR "%s: X0: %04x N0: %04x N1: %04x %d\n",\r\ndev->name, (int)p->xmit_cmds[0]->cmd_status,\r\nreadw(&p->nop_cmds[0]->cmd_status),\r\nreadw(&p->nop_cmds[1]->cmd_status),\r\np->nop_point);\r\n#endif\r\nwriteb(CUC_ABORT, &p->scb->cmd_cuc);\r\nni_attn586();\r\nwait_for_scb_cmd(dev);\r\nwritew(make16(p->nop_cmds[p->nop_point]), &p->scb->cbl_offset);\r\nwriteb(CUC_START, &p->scb->cmd_cuc);\r\nni_attn586();\r\nwait_for_scb_cmd(dev);\r\ndev->trans_start = jiffies;\r\nreturn 0;\r\n}\r\n#endif\r\n{\r\n#ifdef DEBUG\r\nprintk(KERN_ERR "%s: xmitter timed out, try to restart! stat: %02x\n",\r\ndev->name, readb(&p->scb->cus));\r\nprintk(KERN_ERR "%s: command-stats: %04x %04x\n",\r\ndev->name,\r\nreadw(&p->xmit_cmds[0]->cmd_status),\r\nreadw(&p->xmit_cmds[1]->cmd_status));\r\nprintk(KERN_ERR "%s: check, whether you set the right interrupt number!\n",\r\ndev->name);\r\n#endif\r\nni52_close(dev);\r\nni52_open(dev);\r\n}\r\ndev->trans_start = jiffies;\r\n}\r\nstatic netdev_tx_t ni52_send_packet(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nint len, i;\r\n#ifndef NO_NOPCOMMANDS\r\nint next_nop;\r\n#endif\r\nstruct priv *p = netdev_priv(dev);\r\nif (skb->len > XMIT_BUFF_SIZE) {\r\nprintk(KERN_ERR "%s: Sorry, max. framelength is %d bytes. The length of your frame is %d bytes.\n", dev->name, XMIT_BUFF_SIZE, skb->len);\r\nreturn NETDEV_TX_OK;\r\n}\r\nnetif_stop_queue(dev);\r\nmemcpy_toio(p->xmit_cbuffs[p->xmit_count], skb->data, skb->len);\r\nlen = skb->len;\r\nif (len < ETH_ZLEN) {\r\nlen = ETH_ZLEN;\r\nmemset_io(p->xmit_cbuffs[p->xmit_count]+skb->len, 0,\r\nlen - skb->len);\r\n}\r\n#if (NUM_XMIT_BUFFS == 1)\r\n# ifdef NO_NOPCOMMANDS\r\n#ifdef DEBUG\r\nif (readb(&p->scb->cus) & CU_ACTIVE) {\r\nprintk(KERN_ERR "%s: Hmmm .. CU is still running and we wanna send a new packet.\n", dev->name);\r\nprintk(KERN_ERR "%s: stat: %04x %04x\n",\r\ndev->name, readb(&p->scb->cus),\r\nreadw(&p->xmit_cmds[0]->cmd_status));\r\n}\r\n#endif\r\nwritew(TBD_LAST | len, &p->xmit_buffs[0]->size);\r\nfor (i = 0; i < 16; i++) {\r\nwritew(0, &p->xmit_cmds[0]->cmd_status);\r\nwait_for_scb_cmd(dev);\r\nif ((readb(&p->scb->cus) & CU_STATUS) == CU_SUSPEND)\r\nwriteb(CUC_RESUME, &p->scb->cmd_cuc);\r\nelse {\r\nwritew(make16(p->xmit_cmds[0]), &p->scb->cbl_offset);\r\nwriteb(CUC_START, &p->scb->cmd_cuc);\r\n}\r\nni_attn586();\r\nif (!i)\r\ndev_kfree_skb(skb);\r\nwait_for_scb_cmd(dev);\r\nif (readb(&p->scb->cus) & CU_ACTIVE)\r\nbreak;\r\nif (readw(&p->xmit_cmds[0]->cmd_status))\r\nbreak;\r\nif (i == 15)\r\nprintk(KERN_WARNING "%s: Can't start transmit-command.\n", dev->name);\r\n}\r\n# else\r\nnext_nop = (p->nop_point + 1) & 0x1;\r\nwritew(TBD_LAST | len, &p->xmit_buffs[0]->size);\r\nwritew(make16(p->nop_cmds[next_nop]), &p->xmit_cmds[0]->cmd_link);\r\nwritew(make16(p->nop_cmds[next_nop]),\r\n&p->nop_cmds[next_nop]->cmd_link);\r\nwritew(0, &p->xmit_cmds[0]->cmd_status);\r\nwritew(0, &p->nop_cmds[next_nop]->cmd_status);\r\nwritew(make16(p->xmit_cmds[0]), &p->nop_cmds[p->nop_point]->cmd_link);\r\np->nop_point = next_nop;\r\ndev_kfree_skb(skb);\r\n# endif\r\n#else\r\nwritew(TBD_LAST | len, &p->xmit_buffs[p->xmit_count]->size);\r\nnext_nop = p->xmit_count + 1\r\nif (next_nop == NUM_XMIT_BUFFS)\r\nnext_nop = 0;\r\nwritew(0, &p->xmit_cmds[p->xmit_count]->cmd_status);\r\nwritew(make16(p->nop_cmds[next_nop]),\r\n&p->nop_cmds[next_nop]->cmd_link);\r\nwritew(0, &p->nop_cmds[next_nop]->cmd_status);\r\nwritew(make16(p->xmit_cmds[p->xmit_count]),\r\n&p->nop_cmds[p->xmit_count]->cmd_link);\r\np->xmit_count = next_nop;\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&p->spinlock);\r\nif (p->xmit_count != p->xmit_last)\r\nnetif_wake_queue(dev);\r\nspin_unlock_irqrestore(&p->spinlock);\r\n}\r\ndev_kfree_skb(skb);\r\n#endif\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic struct net_device_stats *ni52_get_stats(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\nunsigned short crc, aln, rsc, ovrn;\r\ncrc = readw(&p->scb->crc_errs);\r\nwritew(0, &p->scb->crc_errs);\r\naln = readw(&p->scb->aln_errs);\r\nwritew(0, &p->scb->aln_errs);\r\nrsc = readw(&p->scb->rsc_errs);\r\nwritew(0, &p->scb->rsc_errs);\r\novrn = readw(&p->scb->ovrn_errs);\r\nwritew(0, &p->scb->ovrn_errs);\r\ndev->stats.rx_crc_errors += crc;\r\ndev->stats.rx_fifo_errors += ovrn;\r\ndev->stats.rx_frame_errors += aln;\r\ndev->stats.rx_dropped += rsc;\r\nreturn &dev->stats;\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nni_disint();\r\nalloc586(dev);\r\ninit586(dev);\r\nstartrecv586(dev);\r\nni_enaint();\r\nnetif_wake_queue(dev);\r\n}\r\nint __init init_module(void)\r\n{\r\nif (io <= 0x0 || !memend || !memstart || irq < 2) {\r\nprintk(KERN_ERR "ni52: Autoprobing not allowed for modules.\n");\r\nprintk(KERN_ERR "ni52: Set symbols 'io' 'irq' 'memstart' and 'memend'\n");\r\nreturn -ENODEV;\r\n}\r\ndev_ni52 = ni52_probe(-1);\r\nif (IS_ERR(dev_ni52))\r\nreturn PTR_ERR(dev_ni52);\r\nreturn 0;\r\n}\r\nvoid __exit cleanup_module(void)\r\n{\r\nstruct priv *p = netdev_priv(dev_ni52);\r\nunregister_netdev(dev_ni52);\r\niounmap(p->mapped);\r\nrelease_region(dev_ni52->base_addr, NI52_TOTAL_SIZE);\r\nfree_netdev(dev_ni52);\r\n}
