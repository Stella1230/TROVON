void pci_realloc(void)\r\n{\r\npci_realloc_enable = 1;\r\n}\r\nstatic void add_to_list(struct resource_list_x *head,\r\nstruct pci_dev *dev, struct resource *res,\r\nresource_size_t add_size, resource_size_t min_align)\r\n{\r\nstruct resource_list_x *list = head;\r\nstruct resource_list_x *ln = list->next;\r\nstruct resource_list_x *tmp;\r\ntmp = kmalloc(sizeof(*tmp), GFP_KERNEL);\r\nif (!tmp) {\r\npr_warning("add_to_list: kmalloc() failed!\n");\r\nreturn;\r\n}\r\ntmp->next = ln;\r\ntmp->res = res;\r\ntmp->dev = dev;\r\ntmp->start = res->start;\r\ntmp->end = res->end;\r\ntmp->flags = res->flags;\r\ntmp->add_size = add_size;\r\ntmp->min_align = min_align;\r\nlist->next = tmp;\r\n}\r\nstatic void add_to_failed_list(struct resource_list_x *head,\r\nstruct pci_dev *dev, struct resource *res)\r\n{\r\nadd_to_list(head, dev, res,\r\n0 ,\r\n0 );\r\n}\r\nstatic void __dev_sort_resources(struct pci_dev *dev,\r\nstruct resource_list *head)\r\n{\r\nu16 class = dev->class >> 8;\r\nif (class == PCI_CLASS_NOT_DEFINED || class == PCI_CLASS_BRIDGE_HOST)\r\nreturn;\r\nif (class == PCI_CLASS_SYSTEM_PIC) {\r\nu16 command;\r\npci_read_config_word(dev, PCI_COMMAND, &command);\r\nif (command & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY))\r\nreturn;\r\n}\r\npdev_sort_resources(dev, head);\r\n}\r\nstatic inline void reset_resource(struct resource *res)\r\n{\r\nres->start = 0;\r\nres->end = 0;\r\nres->flags = 0;\r\n}\r\nstatic void reassign_resources_sorted(struct resource_list_x *realloc_head,\r\nstruct resource_list *head)\r\n{\r\nstruct resource *res;\r\nstruct resource_list_x *list, *tmp, *prev;\r\nstruct resource_list *hlist;\r\nresource_size_t add_size;\r\nint idx;\r\nprev = realloc_head;\r\nfor (list = realloc_head->next; list;) {\r\nres = list->res;\r\nif (!res->flags)\r\ngoto out;\r\nfor (hlist = head->next; hlist && hlist->res != res;\r\nhlist = hlist->next);\r\nif (!hlist) {\r\nprev = list;\r\nlist = list->next;\r\ncontinue;\r\n}\r\nidx = res - &list->dev->resource[0];\r\nadd_size=list->add_size;\r\nif (!resource_size(res)) {\r\nres->start = list->start;\r\nres->end = res->start + add_size - 1;\r\nif(pci_assign_resource(list->dev, idx))\r\nreset_resource(res);\r\n} else {\r\nresource_size_t align = list->min_align;\r\nres->flags |= list->flags & (IORESOURCE_STARTALIGN|IORESOURCE_SIZEALIGN);\r\nif (pci_reassign_resource(list->dev, idx, add_size, align))\r\ndev_printk(KERN_DEBUG, &list->dev->dev, "failed to add optional resources res=%pR\n",\r\nres);\r\n}\r\nout:\r\ntmp = list;\r\nprev->next = list = list->next;\r\nkfree(tmp);\r\n}\r\n}\r\nstatic void assign_requested_resources_sorted(struct resource_list *head,\r\nstruct resource_list_x *fail_head)\r\n{\r\nstruct resource *res;\r\nstruct resource_list *list;\r\nint idx;\r\nfor (list = head->next; list; list = list->next) {\r\nres = list->res;\r\nidx = res - &list->dev->resource[0];\r\nif (resource_size(res) && pci_assign_resource(list->dev, idx)) {\r\nif (fail_head && !pci_is_root_bus(list->dev->bus)) {\r\nif (!((idx == PCI_ROM_RESOURCE) &&\r\n(!(res->flags & IORESOURCE_ROM_ENABLE))))\r\nadd_to_failed_list(fail_head, list->dev, res);\r\n}\r\nreset_resource(res);\r\n}\r\n}\r\n}\r\nstatic void __assign_resources_sorted(struct resource_list *head,\r\nstruct resource_list_x *realloc_head,\r\nstruct resource_list_x *fail_head)\r\n{\r\nassign_requested_resources_sorted(head, fail_head);\r\nif (realloc_head)\r\nreassign_resources_sorted(realloc_head, head);\r\nfree_list(resource_list, head);\r\n}\r\nstatic void pdev_assign_resources_sorted(struct pci_dev *dev,\r\nstruct resource_list_x *fail_head)\r\n{\r\nstruct resource_list head;\r\nhead.next = NULL;\r\n__dev_sort_resources(dev, &head);\r\n__assign_resources_sorted(&head, NULL, fail_head);\r\n}\r\nstatic void pbus_assign_resources_sorted(const struct pci_bus *bus,\r\nstruct resource_list_x *realloc_head,\r\nstruct resource_list_x *fail_head)\r\n{\r\nstruct pci_dev *dev;\r\nstruct resource_list head;\r\nhead.next = NULL;\r\nlist_for_each_entry(dev, &bus->devices, bus_list)\r\n__dev_sort_resources(dev, &head);\r\n__assign_resources_sorted(&head, realloc_head, fail_head);\r\n}\r\nvoid pci_setup_cardbus(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *res;\r\nstruct pci_bus_region region;\r\ndev_info(&bridge->dev, "CardBus bridge to [bus %02x-%02x]\n",\r\nbus->secondary, bus->subordinate);\r\nres = bus->resource[0];\r\npcibios_resource_to_bus(bridge, &region, res);\r\nif (res->flags & IORESOURCE_IO) {\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\npci_write_config_dword(bridge, PCI_CB_IO_BASE_0,\r\nregion.start);\r\npci_write_config_dword(bridge, PCI_CB_IO_LIMIT_0,\r\nregion.end);\r\n}\r\nres = bus->resource[1];\r\npcibios_resource_to_bus(bridge, &region, res);\r\nif (res->flags & IORESOURCE_IO) {\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\npci_write_config_dword(bridge, PCI_CB_IO_BASE_1,\r\nregion.start);\r\npci_write_config_dword(bridge, PCI_CB_IO_LIMIT_1,\r\nregion.end);\r\n}\r\nres = bus->resource[2];\r\npcibios_resource_to_bus(bridge, &region, res);\r\nif (res->flags & IORESOURCE_MEM) {\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\npci_write_config_dword(bridge, PCI_CB_MEMORY_BASE_0,\r\nregion.start);\r\npci_write_config_dword(bridge, PCI_CB_MEMORY_LIMIT_0,\r\nregion.end);\r\n}\r\nres = bus->resource[3];\r\npcibios_resource_to_bus(bridge, &region, res);\r\nif (res->flags & IORESOURCE_MEM) {\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\npci_write_config_dword(bridge, PCI_CB_MEMORY_BASE_1,\r\nregion.start);\r\npci_write_config_dword(bridge, PCI_CB_MEMORY_LIMIT_1,\r\nregion.end);\r\n}\r\n}\r\nstatic void pci_setup_bridge_io(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *res;\r\nstruct pci_bus_region region;\r\nu32 l, io_upper16;\r\nres = bus->resource[0];\r\npcibios_resource_to_bus(bridge, &region, res);\r\nif (res->flags & IORESOURCE_IO) {\r\npci_read_config_dword(bridge, PCI_IO_BASE, &l);\r\nl &= 0xffff0000;\r\nl |= (region.start >> 8) & 0x00f0;\r\nl |= region.end & 0xf000;\r\nio_upper16 = (region.end & 0xffff0000) | (region.start >> 16);\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\n} else {\r\nio_upper16 = 0;\r\nl = 0x00f0;\r\n}\r\npci_write_config_dword(bridge, PCI_IO_BASE_UPPER16, 0x0000ffff);\r\npci_write_config_dword(bridge, PCI_IO_BASE, l);\r\npci_write_config_dword(bridge, PCI_IO_BASE_UPPER16, io_upper16);\r\n}\r\nstatic void pci_setup_bridge_mmio(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *res;\r\nstruct pci_bus_region region;\r\nu32 l;\r\nres = bus->resource[1];\r\npcibios_resource_to_bus(bridge, &region, res);\r\nif (res->flags & IORESOURCE_MEM) {\r\nl = (region.start >> 16) & 0xfff0;\r\nl |= region.end & 0xfff00000;\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\n} else {\r\nl = 0x0000fff0;\r\n}\r\npci_write_config_dword(bridge, PCI_MEMORY_BASE, l);\r\n}\r\nstatic void pci_setup_bridge_mmio_pref(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *res;\r\nstruct pci_bus_region region;\r\nu32 l, bu, lu;\r\npci_write_config_dword(bridge, PCI_PREF_LIMIT_UPPER32, 0);\r\nbu = lu = 0;\r\nres = bus->resource[2];\r\npcibios_resource_to_bus(bridge, &region, res);\r\nif (res->flags & IORESOURCE_PREFETCH) {\r\nl = (region.start >> 16) & 0xfff0;\r\nl |= region.end & 0xfff00000;\r\nif (res->flags & IORESOURCE_MEM_64) {\r\nbu = upper_32_bits(region.start);\r\nlu = upper_32_bits(region.end);\r\n}\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\n} else {\r\nl = 0x0000fff0;\r\n}\r\npci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE, l);\r\npci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32, bu);\r\npci_write_config_dword(bridge, PCI_PREF_LIMIT_UPPER32, lu);\r\n}\r\nstatic void __pci_setup_bridge(struct pci_bus *bus, unsigned long type)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\ndev_info(&bridge->dev, "PCI bridge to [bus %02x-%02x]\n",\r\nbus->secondary, bus->subordinate);\r\nif (type & IORESOURCE_IO)\r\npci_setup_bridge_io(bus);\r\nif (type & IORESOURCE_MEM)\r\npci_setup_bridge_mmio(bus);\r\nif (type & IORESOURCE_PREFETCH)\r\npci_setup_bridge_mmio_pref(bus);\r\npci_write_config_word(bridge, PCI_BRIDGE_CONTROL, bus->bridge_ctl);\r\n}\r\nvoid pci_setup_bridge(struct pci_bus *bus)\r\n{\r\nunsigned long type = IORESOURCE_IO | IORESOURCE_MEM |\r\nIORESOURCE_PREFETCH;\r\n__pci_setup_bridge(bus, type);\r\n}\r\nstatic void pci_bridge_check_ranges(struct pci_bus *bus)\r\n{\r\nu16 io;\r\nu32 pmem;\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *b_res;\r\nb_res = &bridge->resource[PCI_BRIDGE_RESOURCES];\r\nb_res[1].flags |= IORESOURCE_MEM;\r\npci_read_config_word(bridge, PCI_IO_BASE, &io);\r\nif (!io) {\r\npci_write_config_word(bridge, PCI_IO_BASE, 0xf0f0);\r\npci_read_config_word(bridge, PCI_IO_BASE, &io);\r\npci_write_config_word(bridge, PCI_IO_BASE, 0x0);\r\n}\r\nif (io)\r\nb_res[0].flags |= IORESOURCE_IO;\r\nif (bridge->vendor == PCI_VENDOR_ID_DEC && bridge->device == 0x0001)\r\nreturn;\r\npci_read_config_dword(bridge, PCI_PREF_MEMORY_BASE, &pmem);\r\nif (!pmem) {\r\npci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE,\r\n0xfff0fff0);\r\npci_read_config_dword(bridge, PCI_PREF_MEMORY_BASE, &pmem);\r\npci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE, 0x0);\r\n}\r\nif (pmem) {\r\nb_res[2].flags |= IORESOURCE_MEM | IORESOURCE_PREFETCH;\r\nif ((pmem & PCI_PREF_RANGE_TYPE_MASK) ==\r\nPCI_PREF_RANGE_TYPE_64) {\r\nb_res[2].flags |= IORESOURCE_MEM_64;\r\nb_res[2].flags |= PCI_PREF_RANGE_TYPE_64;\r\n}\r\n}\r\nif (b_res[2].flags & IORESOURCE_MEM_64) {\r\nu32 mem_base_hi, tmp;\r\npci_read_config_dword(bridge, PCI_PREF_BASE_UPPER32,\r\n&mem_base_hi);\r\npci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32,\r\n0xffffffff);\r\npci_read_config_dword(bridge, PCI_PREF_BASE_UPPER32, &tmp);\r\nif (!tmp)\r\nb_res[2].flags &= ~IORESOURCE_MEM_64;\r\npci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32,\r\nmem_base_hi);\r\n}\r\n}\r\nstatic struct resource *find_free_bus_resource(struct pci_bus *bus, unsigned long type)\r\n{\r\nint i;\r\nstruct resource *r;\r\nunsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM |\r\nIORESOURCE_PREFETCH;\r\npci_bus_for_each_resource(bus, r, i) {\r\nif (r == &ioport_resource || r == &iomem_resource)\r\ncontinue;\r\nif (r && (r->flags & type_mask) == type && !r->parent)\r\nreturn r;\r\n}\r\nreturn NULL;\r\n}\r\nstatic resource_size_t calculate_iosize(resource_size_t size,\r\nresource_size_t min_size,\r\nresource_size_t size1,\r\nresource_size_t old_size,\r\nresource_size_t align)\r\n{\r\nif (size < min_size)\r\nsize = min_size;\r\nif (old_size == 1 )\r\nold_size = 0;\r\n#if defined(CONFIG_ISA) || defined(CONFIG_EISA)\r\nsize = (size & 0xff) + ((size & ~0xffUL) << 2);\r\n#endif\r\nsize = ALIGN(size + size1, align);\r\nif (size < old_size)\r\nsize = old_size;\r\nreturn size;\r\n}\r\nstatic resource_size_t calculate_memsize(resource_size_t size,\r\nresource_size_t min_size,\r\nresource_size_t size1,\r\nresource_size_t old_size,\r\nresource_size_t align)\r\n{\r\nif (size < min_size)\r\nsize = min_size;\r\nif (old_size == 1 )\r\nold_size = 0;\r\nif (size < old_size)\r\nsize = old_size;\r\nsize = ALIGN(size + size1, align);\r\nreturn size;\r\n}\r\nstatic resource_size_t get_res_add_size(struct resource_list_x *realloc_head,\r\nstruct resource *res)\r\n{\r\nstruct resource_list_x *list;\r\nfor (list = realloc_head->next; list && list->res != res;\r\nlist = list->next);\r\nif (list)\r\nreturn list->add_size;\r\nreturn 0;\r\n}\r\nstatic void pbus_size_io(struct pci_bus *bus, resource_size_t min_size,\r\nresource_size_t add_size, struct resource_list_x *realloc_head)\r\n{\r\nstruct pci_dev *dev;\r\nstruct resource *b_res = find_free_bus_resource(bus, IORESOURCE_IO);\r\nunsigned long size = 0, size0 = 0, size1 = 0;\r\nresource_size_t children_add_size = 0;\r\nif (!b_res)\r\nreturn;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nint i;\r\nfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\r\nstruct resource *r = &dev->resource[i];\r\nunsigned long r_size;\r\nif (r->parent || !(r->flags & IORESOURCE_IO))\r\ncontinue;\r\nr_size = resource_size(r);\r\nif (r_size < 0x400)\r\nsize += r_size;\r\nelse\r\nsize1 += r_size;\r\nif (realloc_head)\r\nchildren_add_size += get_res_add_size(realloc_head, r);\r\n}\r\n}\r\nsize0 = calculate_iosize(size, min_size, size1,\r\nresource_size(b_res), 4096);\r\nif (children_add_size > add_size)\r\nadd_size = children_add_size;\r\nsize1 = (!realloc_head || (realloc_head && !add_size)) ? size0 :\r\ncalculate_iosize(size, min_size+add_size, size1,\r\nresource_size(b_res), 4096);\r\nif (!size0 && !size1) {\r\nif (b_res->start || b_res->end)\r\ndev_info(&bus->self->dev, "disabling bridge window "\r\n"%pR to [bus %02x-%02x] (unused)\n", b_res,\r\nbus->secondary, bus->subordinate);\r\nb_res->flags = 0;\r\nreturn;\r\n}\r\nb_res->start = 4096;\r\nb_res->end = b_res->start + size0 - 1;\r\nb_res->flags |= IORESOURCE_STARTALIGN;\r\nif (size1 > size0 && realloc_head)\r\nadd_to_list(realloc_head, bus->self, b_res, size1-size0, 4096);\r\n}\r\nstatic int pbus_size_mem(struct pci_bus *bus, unsigned long mask,\r\nunsigned long type, resource_size_t min_size,\r\nresource_size_t add_size,\r\nstruct resource_list_x *realloc_head)\r\n{\r\nstruct pci_dev *dev;\r\nresource_size_t min_align, align, size, size0, size1;\r\nresource_size_t aligns[12];\r\nint order, max_order;\r\nstruct resource *b_res = find_free_bus_resource(bus, type);\r\nunsigned int mem64_mask = 0;\r\nresource_size_t children_add_size = 0;\r\nif (!b_res)\r\nreturn 0;\r\nmemset(aligns, 0, sizeof(aligns));\r\nmax_order = 0;\r\nsize = 0;\r\nmem64_mask = b_res->flags & IORESOURCE_MEM_64;\r\nb_res->flags &= ~IORESOURCE_MEM_64;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nint i;\r\nfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\r\nstruct resource *r = &dev->resource[i];\r\nresource_size_t r_size;\r\nif (r->parent || (r->flags & mask) != type)\r\ncontinue;\r\nr_size = resource_size(r);\r\n#ifdef CONFIG_PCI_IOV\r\nif (realloc_head && i >= PCI_IOV_RESOURCES &&\r\ni <= PCI_IOV_RESOURCE_END) {\r\nr->end = r->start - 1;\r\nadd_to_list(realloc_head, dev, r, r_size, 0);\r\nchildren_add_size += r_size;\r\ncontinue;\r\n}\r\n#endif\r\nalign = pci_resource_alignment(dev, r);\r\norder = __ffs(align) - 20;\r\nif (order > 11) {\r\ndev_warn(&dev->dev, "disabling BAR %d: %pR "\r\n"(bad alignment %#llx)\n", i, r,\r\n(unsigned long long) align);\r\nr->flags = 0;\r\ncontinue;\r\n}\r\nsize += r_size;\r\nif (order < 0)\r\norder = 0;\r\nif (r_size == align)\r\naligns[order] += align;\r\nif (order > max_order)\r\nmax_order = order;\r\nmem64_mask &= r->flags & IORESOURCE_MEM_64;\r\nif (realloc_head)\r\nchildren_add_size += get_res_add_size(realloc_head, r);\r\n}\r\n}\r\nalign = 0;\r\nmin_align = 0;\r\nfor (order = 0; order <= max_order; order++) {\r\nresource_size_t align1 = 1;\r\nalign1 <<= (order + 20);\r\nif (!align)\r\nmin_align = align1;\r\nelse if (ALIGN(align + min_align, min_align) < align1)\r\nmin_align = align1 >> 1;\r\nalign += aligns[order];\r\n}\r\nsize0 = calculate_memsize(size, min_size, 0, resource_size(b_res), min_align);\r\nif (children_add_size > add_size)\r\nadd_size = children_add_size;\r\nsize1 = (!realloc_head || (realloc_head && !add_size)) ? size0 :\r\ncalculate_memsize(size, min_size+add_size, 0,\r\nresource_size(b_res), min_align);\r\nif (!size0 && !size1) {\r\nif (b_res->start || b_res->end)\r\ndev_info(&bus->self->dev, "disabling bridge window "\r\n"%pR to [bus %02x-%02x] (unused)\n", b_res,\r\nbus->secondary, bus->subordinate);\r\nb_res->flags = 0;\r\nreturn 1;\r\n}\r\nb_res->start = min_align;\r\nb_res->end = size0 + min_align - 1;\r\nb_res->flags |= IORESOURCE_STARTALIGN | mem64_mask;\r\nif (size1 > size0 && realloc_head)\r\nadd_to_list(realloc_head, bus->self, b_res, size1-size0, min_align);\r\nreturn 1;\r\n}\r\nunsigned long pci_cardbus_resource_alignment(struct resource *res)\r\n{\r\nif (res->flags & IORESOURCE_IO)\r\nreturn pci_cardbus_io_size;\r\nif (res->flags & IORESOURCE_MEM)\r\nreturn pci_cardbus_mem_size;\r\nreturn 0;\r\n}\r\nstatic void pci_bus_size_cardbus(struct pci_bus *bus,\r\nstruct resource_list_x *realloc_head)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *b_res = &bridge->resource[PCI_BRIDGE_RESOURCES];\r\nu16 ctrl;\r\nb_res[0].start = 0;\r\nb_res[0].flags |= IORESOURCE_IO | IORESOURCE_SIZEALIGN;\r\nif (realloc_head)\r\nadd_to_list(realloc_head, bridge, b_res, pci_cardbus_io_size, 0 );\r\nb_res[1].start = 0;\r\nb_res[1].flags |= IORESOURCE_IO | IORESOURCE_SIZEALIGN;\r\nif (realloc_head)\r\nadd_to_list(realloc_head, bridge, b_res+1, pci_cardbus_io_size, 0 );\r\npci_read_config_word(bridge, PCI_CB_BRIDGE_CONTROL, &ctrl);\r\nif (!(ctrl & PCI_CB_BRIDGE_CTL_PREFETCH_MEM0)) {\r\nctrl |= PCI_CB_BRIDGE_CTL_PREFETCH_MEM0;\r\npci_write_config_word(bridge, PCI_CB_BRIDGE_CONTROL, ctrl);\r\npci_read_config_word(bridge, PCI_CB_BRIDGE_CONTROL, &ctrl);\r\n}\r\nif (ctrl & PCI_CB_BRIDGE_CTL_PREFETCH_MEM0) {\r\nb_res[2].start = 0;\r\nb_res[2].flags |= IORESOURCE_MEM | IORESOURCE_PREFETCH | IORESOURCE_SIZEALIGN;\r\nif (realloc_head)\r\nadd_to_list(realloc_head, bridge, b_res+2, pci_cardbus_mem_size, 0 );\r\nb_res[3].start = 0;\r\nb_res[3].flags |= IORESOURCE_MEM | IORESOURCE_SIZEALIGN;\r\nif (realloc_head)\r\nadd_to_list(realloc_head, bridge, b_res+3, pci_cardbus_mem_size, 0 );\r\n} else {\r\nb_res[3].start = 0;\r\nb_res[3].flags |= IORESOURCE_MEM | IORESOURCE_SIZEALIGN;\r\nif (realloc_head)\r\nadd_to_list(realloc_head, bridge, b_res+3, pci_cardbus_mem_size * 2, 0 );\r\n}\r\nb_res[0].start = b_res[1].start = b_res[2].start = b_res[3].start = 1;\r\nb_res[0].end = b_res[1].end = b_res[2].end = b_res[3].end = 0;\r\n}\r\nvoid __ref __pci_bus_size_bridges(struct pci_bus *bus,\r\nstruct resource_list_x *realloc_head)\r\n{\r\nstruct pci_dev *dev;\r\nunsigned long mask, prefmask;\r\nresource_size_t additional_mem_size = 0, additional_io_size = 0;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nstruct pci_bus *b = dev->subordinate;\r\nif (!b)\r\ncontinue;\r\nswitch (dev->class >> 8) {\r\ncase PCI_CLASS_BRIDGE_CARDBUS:\r\npci_bus_size_cardbus(b, realloc_head);\r\nbreak;\r\ncase PCI_CLASS_BRIDGE_PCI:\r\ndefault:\r\n__pci_bus_size_bridges(b, realloc_head);\r\nbreak;\r\n}\r\n}\r\nif (!bus->self)\r\nreturn;\r\nswitch (bus->self->class >> 8) {\r\ncase PCI_CLASS_BRIDGE_CARDBUS:\r\nbreak;\r\ncase PCI_CLASS_BRIDGE_PCI:\r\npci_bridge_check_ranges(bus);\r\nif (bus->self->is_hotplug_bridge) {\r\nadditional_io_size = pci_hotplug_io_size;\r\nadditional_mem_size = pci_hotplug_mem_size;\r\n}\r\ndefault:\r\npbus_size_io(bus, 0, additional_io_size, realloc_head);\r\nmask = IORESOURCE_MEM;\r\nprefmask = IORESOURCE_MEM | IORESOURCE_PREFETCH;\r\nif (pbus_size_mem(bus, prefmask, prefmask, 0, additional_mem_size, realloc_head))\r\nmask = prefmask;\r\nelse\r\nadditional_mem_size += additional_mem_size;\r\npbus_size_mem(bus, mask, IORESOURCE_MEM, 0, additional_mem_size, realloc_head);\r\nbreak;\r\n}\r\n}\r\nvoid __ref pci_bus_size_bridges(struct pci_bus *bus)\r\n{\r\n__pci_bus_size_bridges(bus, NULL);\r\n}\r\nstatic void __ref __pci_bus_assign_resources(const struct pci_bus *bus,\r\nstruct resource_list_x *realloc_head,\r\nstruct resource_list_x *fail_head)\r\n{\r\nstruct pci_bus *b;\r\nstruct pci_dev *dev;\r\npbus_assign_resources_sorted(bus, realloc_head, fail_head);\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nb = dev->subordinate;\r\nif (!b)\r\ncontinue;\r\n__pci_bus_assign_resources(b, realloc_head, fail_head);\r\nswitch (dev->class >> 8) {\r\ncase PCI_CLASS_BRIDGE_PCI:\r\nif (!pci_is_enabled(dev))\r\npci_setup_bridge(b);\r\nbreak;\r\ncase PCI_CLASS_BRIDGE_CARDBUS:\r\npci_setup_cardbus(b);\r\nbreak;\r\ndefault:\r\ndev_info(&dev->dev, "not setting up bridge for bus "\r\n"%04x:%02x\n", pci_domain_nr(b), b->number);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid __ref pci_bus_assign_resources(const struct pci_bus *bus)\r\n{\r\n__pci_bus_assign_resources(bus, NULL, NULL);\r\n}\r\nstatic void __ref __pci_bridge_assign_resources(const struct pci_dev *bridge,\r\nstruct resource_list_x *fail_head)\r\n{\r\nstruct pci_bus *b;\r\npdev_assign_resources_sorted((struct pci_dev *)bridge, fail_head);\r\nb = bridge->subordinate;\r\nif (!b)\r\nreturn;\r\n__pci_bus_assign_resources(b, NULL, fail_head);\r\nswitch (bridge->class >> 8) {\r\ncase PCI_CLASS_BRIDGE_PCI:\r\npci_setup_bridge(b);\r\nbreak;\r\ncase PCI_CLASS_BRIDGE_CARDBUS:\r\npci_setup_cardbus(b);\r\nbreak;\r\ndefault:\r\ndev_info(&bridge->dev, "not setting up bridge for bus "\r\n"%04x:%02x\n", pci_domain_nr(b), b->number);\r\nbreak;\r\n}\r\n}\r\nstatic void pci_bridge_release_resources(struct pci_bus *bus,\r\nunsigned long type)\r\n{\r\nint idx;\r\nbool changed = false;\r\nstruct pci_dev *dev;\r\nstruct resource *r;\r\nunsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM |\r\nIORESOURCE_PREFETCH;\r\ndev = bus->self;\r\nfor (idx = PCI_BRIDGE_RESOURCES; idx <= PCI_BRIDGE_RESOURCE_END;\r\nidx++) {\r\nr = &dev->resource[idx];\r\nif ((r->flags & type_mask) != type)\r\ncontinue;\r\nif (!r->parent)\r\ncontinue;\r\nrelease_child_resources(r);\r\nif (!release_resource(r)) {\r\ndev_printk(KERN_DEBUG, &dev->dev,\r\n"resource %d %pR released\n", idx, r);\r\nr->end = resource_size(r) - 1;\r\nr->start = 0;\r\nr->flags = 0;\r\nchanged = true;\r\n}\r\n}\r\nif (changed) {\r\nif (type & IORESOURCE_PREFETCH)\r\ntype = IORESOURCE_PREFETCH;\r\n__pci_setup_bridge(bus, type);\r\n}\r\n}\r\nstatic void __ref pci_bus_release_bridge_resources(struct pci_bus *bus,\r\nunsigned long type,\r\nenum release_type rel_type)\r\n{\r\nstruct pci_dev *dev;\r\nbool is_leaf_bridge = true;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nstruct pci_bus *b = dev->subordinate;\r\nif (!b)\r\ncontinue;\r\nis_leaf_bridge = false;\r\nif ((dev->class >> 8) != PCI_CLASS_BRIDGE_PCI)\r\ncontinue;\r\nif (rel_type == whole_subtree)\r\npci_bus_release_bridge_resources(b, type,\r\nwhole_subtree);\r\n}\r\nif (pci_is_root_bus(bus))\r\nreturn;\r\nif ((bus->self->class >> 8) != PCI_CLASS_BRIDGE_PCI)\r\nreturn;\r\nif ((rel_type == whole_subtree) || is_leaf_bridge)\r\npci_bridge_release_resources(bus, type);\r\n}\r\nstatic void pci_bus_dump_res(struct pci_bus *bus)\r\n{\r\nstruct resource *res;\r\nint i;\r\npci_bus_for_each_resource(bus, res, i) {\r\nif (!res || !res->end || !res->flags)\r\ncontinue;\r\ndev_printk(KERN_DEBUG, &bus->dev, "resource %d %pR\n", i, res);\r\n}\r\n}\r\nstatic void pci_bus_dump_resources(struct pci_bus *bus)\r\n{\r\nstruct pci_bus *b;\r\nstruct pci_dev *dev;\r\npci_bus_dump_res(bus);\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nb = dev->subordinate;\r\nif (!b)\r\ncontinue;\r\npci_bus_dump_resources(b);\r\n}\r\n}\r\nstatic int __init pci_bus_get_depth(struct pci_bus *bus)\r\n{\r\nint depth = 0;\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nint ret;\r\nstruct pci_bus *b = dev->subordinate;\r\nif (!b)\r\ncontinue;\r\nret = pci_bus_get_depth(b);\r\nif (ret + 1 > depth)\r\ndepth = ret + 1;\r\n}\r\nreturn depth;\r\n}\r\nstatic int __init pci_get_max_depth(void)\r\n{\r\nint depth = 0;\r\nstruct pci_bus *bus;\r\nlist_for_each_entry(bus, &pci_root_buses, node) {\r\nint ret;\r\nret = pci_bus_get_depth(bus);\r\nif (ret > depth)\r\ndepth = ret;\r\n}\r\nreturn depth;\r\n}\r\nvoid __init\r\npci_assign_unassigned_resources(void)\r\n{\r\nstruct pci_bus *bus;\r\nstruct resource_list_x realloc_list;\r\nint tried_times = 0;\r\nenum release_type rel_type = leaf_only;\r\nstruct resource_list_x head, *list;\r\nunsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM |\r\nIORESOURCE_PREFETCH;\r\nunsigned long failed_type;\r\nint max_depth = pci_get_max_depth();\r\nint pci_try_num;\r\nhead.next = NULL;\r\nrealloc_list.next = NULL;\r\npci_try_num = max_depth + 1;\r\nprintk(KERN_DEBUG "PCI: max bus depth: %d pci_try_num: %d\n",\r\nmax_depth, pci_try_num);\r\nagain:\r\nlist_for_each_entry(bus, &pci_root_buses, node)\r\n__pci_bus_size_bridges(bus, &realloc_list);\r\nlist_for_each_entry(bus, &pci_root_buses, node)\r\n__pci_bus_assign_resources(bus, &realloc_list, &head);\r\nBUG_ON(realloc_list.next);\r\ntried_times++;\r\nif (!head.next)\r\ngoto enable_and_dump;\r\nif (!pci_realloc_enabled()) {\r\nfree_list(resource_list_x, &head);\r\ngoto enable_and_dump;\r\n}\r\nfailed_type = 0;\r\nfor (list = head.next; list;) {\r\nfailed_type |= list->flags;\r\nlist = list->next;\r\n}\r\nfailed_type &= type_mask;\r\nif ((failed_type == IORESOURCE_IO) || (tried_times >= pci_try_num)) {\r\nfree_list(resource_list_x, &head);\r\ngoto enable_and_dump;\r\n}\r\nprintk(KERN_DEBUG "PCI: No. %d try to assign unassigned res\n",\r\ntried_times + 1);\r\nif ((tried_times + 1) > 2)\r\nrel_type = whole_subtree;\r\nfor (list = head.next; list;) {\r\nbus = list->dev->bus;\r\npci_bus_release_bridge_resources(bus, list->flags & type_mask,\r\nrel_type);\r\nlist = list->next;\r\n}\r\nfor (list = head.next; list;) {\r\nstruct resource *res = list->res;\r\nres->start = list->start;\r\nres->end = list->end;\r\nres->flags = list->flags;\r\nif (list->dev->subordinate)\r\nres->flags = 0;\r\nlist = list->next;\r\n}\r\nfree_list(resource_list_x, &head);\r\ngoto again;\r\nenable_and_dump:\r\nlist_for_each_entry(bus, &pci_root_buses, node)\r\npci_enable_bridges(bus);\r\nlist_for_each_entry(bus, &pci_root_buses, node)\r\npci_bus_dump_resources(bus);\r\n}\r\nvoid pci_assign_unassigned_bridge_resources(struct pci_dev *bridge)\r\n{\r\nstruct pci_bus *parent = bridge->subordinate;\r\nint tried_times = 0;\r\nstruct resource_list_x head, *list;\r\nint retval;\r\nunsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM |\r\nIORESOURCE_PREFETCH;\r\nhead.next = NULL;\r\nagain:\r\npci_bus_size_bridges(parent);\r\n__pci_bridge_assign_resources(bridge, &head);\r\ntried_times++;\r\nif (!head.next)\r\ngoto enable_all;\r\nif (tried_times >= 2) {\r\nfree_list(resource_list_x, &head);\r\ngoto enable_all;\r\n}\r\nprintk(KERN_DEBUG "PCI: No. %d try to assign unassigned res\n",\r\ntried_times + 1);\r\nfor (list = head.next; list;) {\r\nstruct pci_bus *bus = list->dev->bus;\r\nunsigned long flags = list->flags;\r\npci_bus_release_bridge_resources(bus, flags & type_mask,\r\nwhole_subtree);\r\nlist = list->next;\r\n}\r\nfor (list = head.next; list;) {\r\nstruct resource *res = list->res;\r\nres->start = list->start;\r\nres->end = list->end;\r\nres->flags = list->flags;\r\nif (list->dev->subordinate)\r\nres->flags = 0;\r\nlist = list->next;\r\n}\r\nfree_list(resource_list_x, &head);\r\ngoto again;\r\nenable_all:\r\nretval = pci_reenable_device(bridge);\r\npci_set_master(bridge);\r\npci_enable_bridges(parent);\r\n}
