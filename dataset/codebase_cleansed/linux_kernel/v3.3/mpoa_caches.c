static in_cache_entry *in_cache_get(__be32 dst_ip,\r\nstruct mpoa_client *client)\r\n{\r\nin_cache_entry *entry;\r\nread_lock_bh(&client->ingress_lock);\r\nentry = client->in_cache;\r\nwhile (entry != NULL) {\r\nif (entry->ctrl_info.in_dst_ip == dst_ip) {\r\natomic_inc(&entry->use);\r\nread_unlock_bh(&client->ingress_lock);\r\nreturn entry;\r\n}\r\nentry = entry->next;\r\n}\r\nread_unlock_bh(&client->ingress_lock);\r\nreturn NULL;\r\n}\r\nstatic in_cache_entry *in_cache_get_with_mask(__be32 dst_ip,\r\nstruct mpoa_client *client,\r\n__be32 mask)\r\n{\r\nin_cache_entry *entry;\r\nread_lock_bh(&client->ingress_lock);\r\nentry = client->in_cache;\r\nwhile (entry != NULL) {\r\nif ((entry->ctrl_info.in_dst_ip & mask) == (dst_ip & mask)) {\r\natomic_inc(&entry->use);\r\nread_unlock_bh(&client->ingress_lock);\r\nreturn entry;\r\n}\r\nentry = entry->next;\r\n}\r\nread_unlock_bh(&client->ingress_lock);\r\nreturn NULL;\r\n}\r\nstatic in_cache_entry *in_cache_get_by_vcc(struct atm_vcc *vcc,\r\nstruct mpoa_client *client)\r\n{\r\nin_cache_entry *entry;\r\nread_lock_bh(&client->ingress_lock);\r\nentry = client->in_cache;\r\nwhile (entry != NULL) {\r\nif (entry->shortcut == vcc) {\r\natomic_inc(&entry->use);\r\nread_unlock_bh(&client->ingress_lock);\r\nreturn entry;\r\n}\r\nentry = entry->next;\r\n}\r\nread_unlock_bh(&client->ingress_lock);\r\nreturn NULL;\r\n}\r\nstatic in_cache_entry *in_cache_add_entry(__be32 dst_ip,\r\nstruct mpoa_client *client)\r\n{\r\nin_cache_entry *entry = kzalloc(sizeof(in_cache_entry), GFP_KERNEL);\r\nif (entry == NULL) {\r\npr_info("mpoa: mpoa_caches.c: new_in_cache_entry: out of memory\n");\r\nreturn NULL;\r\n}\r\ndprintk("adding an ingress entry, ip = %pI4\n", &dst_ip);\r\natomic_set(&entry->use, 1);\r\ndprintk("new_in_cache_entry: about to lock\n");\r\nwrite_lock_bh(&client->ingress_lock);\r\nentry->next = client->in_cache;\r\nentry->prev = NULL;\r\nif (client->in_cache != NULL)\r\nclient->in_cache->prev = entry;\r\nclient->in_cache = entry;\r\nmemcpy(entry->MPS_ctrl_ATM_addr, client->mps_ctrl_addr, ATM_ESA_LEN);\r\nentry->ctrl_info.in_dst_ip = dst_ip;\r\ndo_gettimeofday(&(entry->tv));\r\nentry->retry_time = client->parameters.mpc_p4;\r\nentry->count = 1;\r\nentry->entry_state = INGRESS_INVALID;\r\nentry->ctrl_info.holding_time = HOLDING_TIME_DEFAULT;\r\natomic_inc(&entry->use);\r\nwrite_unlock_bh(&client->ingress_lock);\r\ndprintk("new_in_cache_entry: unlocked\n");\r\nreturn entry;\r\n}\r\nstatic int cache_hit(in_cache_entry *entry, struct mpoa_client *mpc)\r\n{\r\nstruct atm_mpoa_qos *qos;\r\nstruct k_message msg;\r\nentry->count++;\r\nif (entry->entry_state == INGRESS_RESOLVED && entry->shortcut != NULL)\r\nreturn OPEN;\r\nif (entry->entry_state == INGRESS_REFRESHING) {\r\nif (entry->count > mpc->parameters.mpc_p1) {\r\nmsg.type = SND_MPOA_RES_RQST;\r\nmsg.content.in_info = entry->ctrl_info;\r\nmemcpy(msg.MPS_ctrl, mpc->mps_ctrl_addr, ATM_ESA_LEN);\r\nqos = atm_mpoa_search_qos(entry->ctrl_info.in_dst_ip);\r\nif (qos != NULL)\r\nmsg.qos = qos->qos;\r\nmsg_to_mpoad(&msg, mpc);\r\ndo_gettimeofday(&(entry->reply_wait));\r\nentry->entry_state = INGRESS_RESOLVING;\r\n}\r\nif (entry->shortcut != NULL)\r\nreturn OPEN;\r\nreturn CLOSED;\r\n}\r\nif (entry->entry_state == INGRESS_RESOLVING && entry->shortcut != NULL)\r\nreturn OPEN;\r\nif (entry->count > mpc->parameters.mpc_p1 &&\r\nentry->entry_state == INGRESS_INVALID) {\r\ndprintk("(%s) threshold exceeded for ip %pI4, sending MPOA res req\n",\r\nmpc->dev->name, &entry->ctrl_info.in_dst_ip);\r\nentry->entry_state = INGRESS_RESOLVING;\r\nmsg.type = SND_MPOA_RES_RQST;\r\nmemcpy(msg.MPS_ctrl, mpc->mps_ctrl_addr, ATM_ESA_LEN);\r\nmsg.content.in_info = entry->ctrl_info;\r\nqos = atm_mpoa_search_qos(entry->ctrl_info.in_dst_ip);\r\nif (qos != NULL)\r\nmsg.qos = qos->qos;\r\nmsg_to_mpoad(&msg, mpc);\r\ndo_gettimeofday(&(entry->reply_wait));\r\n}\r\nreturn CLOSED;\r\n}\r\nstatic void in_cache_put(in_cache_entry *entry)\r\n{\r\nif (atomic_dec_and_test(&entry->use)) {\r\nmemset(entry, 0, sizeof(in_cache_entry));\r\nkfree(entry);\r\n}\r\n}\r\nstatic void in_cache_remove_entry(in_cache_entry *entry,\r\nstruct mpoa_client *client)\r\n{\r\nstruct atm_vcc *vcc;\r\nstruct k_message msg;\r\nvcc = entry->shortcut;\r\ndprintk("removing an ingress entry, ip = %pI4\n",\r\n&entry->ctrl_info.in_dst_ip);\r\nif (entry->prev != NULL)\r\nentry->prev->next = entry->next;\r\nelse\r\nclient->in_cache = entry->next;\r\nif (entry->next != NULL)\r\nentry->next->prev = entry->prev;\r\nclient->in_ops->put(entry);\r\nif (client->in_cache == NULL && client->eg_cache == NULL) {\r\nmsg.type = STOP_KEEP_ALIVE_SM;\r\nmsg_to_mpoad(&msg, client);\r\n}\r\nif (vcc != NULL) {\r\neg_cache_entry *eg_entry = client->eg_ops->get_by_vcc(vcc,\r\nclient);\r\nif (eg_entry != NULL) {\r\nclient->eg_ops->put(eg_entry);\r\nreturn;\r\n}\r\nvcc_release_async(vcc, -EPIPE);\r\n}\r\n}\r\nstatic void clear_count_and_expired(struct mpoa_client *client)\r\n{\r\nin_cache_entry *entry, *next_entry;\r\nstruct timeval now;\r\ndo_gettimeofday(&now);\r\nwrite_lock_bh(&client->ingress_lock);\r\nentry = client->in_cache;\r\nwhile (entry != NULL) {\r\nentry->count = 0;\r\nnext_entry = entry->next;\r\nif ((now.tv_sec - entry->tv.tv_sec)\r\n> entry->ctrl_info.holding_time) {\r\ndprintk("holding time expired, ip = %pI4\n",\r\n&entry->ctrl_info.in_dst_ip);\r\nclient->in_ops->remove_entry(entry, client);\r\n}\r\nentry = next_entry;\r\n}\r\nwrite_unlock_bh(&client->ingress_lock);\r\n}\r\nstatic void check_resolving_entries(struct mpoa_client *client)\r\n{\r\nstruct atm_mpoa_qos *qos;\r\nin_cache_entry *entry;\r\nstruct timeval now;\r\nstruct k_message msg;\r\ndo_gettimeofday(&now);\r\nread_lock_bh(&client->ingress_lock);\r\nentry = client->in_cache;\r\nwhile (entry != NULL) {\r\nif (entry->entry_state == INGRESS_RESOLVING) {\r\nif ((now.tv_sec - entry->hold_down.tv_sec) <\r\nclient->parameters.mpc_p6) {\r\nentry = entry->next;\r\ncontinue;\r\n}\r\nif ((now.tv_sec - entry->reply_wait.tv_sec) >\r\nentry->retry_time) {\r\nentry->retry_time = MPC_C1 * (entry->retry_time);\r\nif (entry->retry_time > client->parameters.mpc_p5) {\r\ndo_gettimeofday(&(entry->hold_down));\r\nentry->retry_time = client->parameters.mpc_p4;\r\nentry = entry->next;\r\ncontinue;\r\n}\r\nmemset(&(entry->hold_down), 0, sizeof(struct timeval));\r\nmsg.type = SND_MPOA_RES_RTRY;\r\nmemcpy(msg.MPS_ctrl, client->mps_ctrl_addr, ATM_ESA_LEN);\r\nmsg.content.in_info = entry->ctrl_info;\r\nqos = atm_mpoa_search_qos(entry->ctrl_info.in_dst_ip);\r\nif (qos != NULL)\r\nmsg.qos = qos->qos;\r\nmsg_to_mpoad(&msg, client);\r\ndo_gettimeofday(&(entry->reply_wait));\r\n}\r\n}\r\nentry = entry->next;\r\n}\r\nread_unlock_bh(&client->ingress_lock);\r\n}\r\nstatic void refresh_entries(struct mpoa_client *client)\r\n{\r\nstruct timeval now;\r\nstruct in_cache_entry *entry = client->in_cache;\r\nddprintk("refresh_entries\n");\r\ndo_gettimeofday(&now);\r\nread_lock_bh(&client->ingress_lock);\r\nwhile (entry != NULL) {\r\nif (entry->entry_state == INGRESS_RESOLVED) {\r\nif (!(entry->refresh_time))\r\nentry->refresh_time = (2 * (entry->ctrl_info.holding_time))/3;\r\nif ((now.tv_sec - entry->reply_wait.tv_sec) >\r\nentry->refresh_time) {\r\ndprintk("refreshing an entry.\n");\r\nentry->entry_state = INGRESS_REFRESHING;\r\n}\r\n}\r\nentry = entry->next;\r\n}\r\nread_unlock_bh(&client->ingress_lock);\r\n}\r\nstatic void in_destroy_cache(struct mpoa_client *mpc)\r\n{\r\nwrite_lock_irq(&mpc->ingress_lock);\r\nwhile (mpc->in_cache != NULL)\r\nmpc->in_ops->remove_entry(mpc->in_cache, mpc);\r\nwrite_unlock_irq(&mpc->ingress_lock);\r\n}\r\nstatic eg_cache_entry *eg_cache_get_by_cache_id(__be32 cache_id,\r\nstruct mpoa_client *mpc)\r\n{\r\neg_cache_entry *entry;\r\nread_lock_irq(&mpc->egress_lock);\r\nentry = mpc->eg_cache;\r\nwhile (entry != NULL) {\r\nif (entry->ctrl_info.cache_id == cache_id) {\r\natomic_inc(&entry->use);\r\nread_unlock_irq(&mpc->egress_lock);\r\nreturn entry;\r\n}\r\nentry = entry->next;\r\n}\r\nread_unlock_irq(&mpc->egress_lock);\r\nreturn NULL;\r\n}\r\nstatic eg_cache_entry *eg_cache_get_by_tag(__be32 tag, struct mpoa_client *mpc)\r\n{\r\nunsigned long flags;\r\neg_cache_entry *entry;\r\nread_lock_irqsave(&mpc->egress_lock, flags);\r\nentry = mpc->eg_cache;\r\nwhile (entry != NULL) {\r\nif (entry->ctrl_info.tag == tag) {\r\natomic_inc(&entry->use);\r\nread_unlock_irqrestore(&mpc->egress_lock, flags);\r\nreturn entry;\r\n}\r\nentry = entry->next;\r\n}\r\nread_unlock_irqrestore(&mpc->egress_lock, flags);\r\nreturn NULL;\r\n}\r\nstatic eg_cache_entry *eg_cache_get_by_vcc(struct atm_vcc *vcc,\r\nstruct mpoa_client *mpc)\r\n{\r\nunsigned long flags;\r\neg_cache_entry *entry;\r\nread_lock_irqsave(&mpc->egress_lock, flags);\r\nentry = mpc->eg_cache;\r\nwhile (entry != NULL) {\r\nif (entry->shortcut == vcc) {\r\natomic_inc(&entry->use);\r\nread_unlock_irqrestore(&mpc->egress_lock, flags);\r\nreturn entry;\r\n}\r\nentry = entry->next;\r\n}\r\nread_unlock_irqrestore(&mpc->egress_lock, flags);\r\nreturn NULL;\r\n}\r\nstatic eg_cache_entry *eg_cache_get_by_src_ip(__be32 ipaddr,\r\nstruct mpoa_client *mpc)\r\n{\r\neg_cache_entry *entry;\r\nread_lock_irq(&mpc->egress_lock);\r\nentry = mpc->eg_cache;\r\nwhile (entry != NULL) {\r\nif (entry->latest_ip_addr == ipaddr) {\r\natomic_inc(&entry->use);\r\nread_unlock_irq(&mpc->egress_lock);\r\nreturn entry;\r\n}\r\nentry = entry->next;\r\n}\r\nread_unlock_irq(&mpc->egress_lock);\r\nreturn NULL;\r\n}\r\nstatic void eg_cache_put(eg_cache_entry *entry)\r\n{\r\nif (atomic_dec_and_test(&entry->use)) {\r\nmemset(entry, 0, sizeof(eg_cache_entry));\r\nkfree(entry);\r\n}\r\n}\r\nstatic void eg_cache_remove_entry(eg_cache_entry *entry,\r\nstruct mpoa_client *client)\r\n{\r\nstruct atm_vcc *vcc;\r\nstruct k_message msg;\r\nvcc = entry->shortcut;\r\ndprintk("removing an egress entry.\n");\r\nif (entry->prev != NULL)\r\nentry->prev->next = entry->next;\r\nelse\r\nclient->eg_cache = entry->next;\r\nif (entry->next != NULL)\r\nentry->next->prev = entry->prev;\r\nclient->eg_ops->put(entry);\r\nif (client->in_cache == NULL && client->eg_cache == NULL) {\r\nmsg.type = STOP_KEEP_ALIVE_SM;\r\nmsg_to_mpoad(&msg, client);\r\n}\r\nif (vcc != NULL) {\r\nin_cache_entry *in_entry = client->in_ops->get_by_vcc(vcc, client);\r\nif (in_entry != NULL) {\r\nclient->in_ops->put(in_entry);\r\nreturn;\r\n}\r\nvcc_release_async(vcc, -EPIPE);\r\n}\r\n}\r\nstatic eg_cache_entry *eg_cache_add_entry(struct k_message *msg,\r\nstruct mpoa_client *client)\r\n{\r\neg_cache_entry *entry = kzalloc(sizeof(eg_cache_entry), GFP_KERNEL);\r\nif (entry == NULL) {\r\npr_info("out of memory\n");\r\nreturn NULL;\r\n}\r\ndprintk("adding an egress entry, ip = %pI4, this should be our IP\n",\r\n&msg->content.eg_info.eg_dst_ip);\r\natomic_set(&entry->use, 1);\r\ndprintk("new_eg_cache_entry: about to lock\n");\r\nwrite_lock_irq(&client->egress_lock);\r\nentry->next = client->eg_cache;\r\nentry->prev = NULL;\r\nif (client->eg_cache != NULL)\r\nclient->eg_cache->prev = entry;\r\nclient->eg_cache = entry;\r\nmemcpy(entry->MPS_ctrl_ATM_addr, client->mps_ctrl_addr, ATM_ESA_LEN);\r\nentry->ctrl_info = msg->content.eg_info;\r\ndo_gettimeofday(&(entry->tv));\r\nentry->entry_state = EGRESS_RESOLVED;\r\ndprintk("new_eg_cache_entry cache_id %u\n",\r\nntohl(entry->ctrl_info.cache_id));\r\ndprintk("mps_ip = %pI4\n", &entry->ctrl_info.mps_ip);\r\natomic_inc(&entry->use);\r\nwrite_unlock_irq(&client->egress_lock);\r\ndprintk("new_eg_cache_entry: unlocked\n");\r\nreturn entry;\r\n}\r\nstatic void update_eg_cache_entry(eg_cache_entry *entry, uint16_t holding_time)\r\n{\r\ndo_gettimeofday(&(entry->tv));\r\nentry->entry_state = EGRESS_RESOLVED;\r\nentry->ctrl_info.holding_time = holding_time;\r\n}\r\nstatic void clear_expired(struct mpoa_client *client)\r\n{\r\neg_cache_entry *entry, *next_entry;\r\nstruct timeval now;\r\nstruct k_message msg;\r\ndo_gettimeofday(&now);\r\nwrite_lock_irq(&client->egress_lock);\r\nentry = client->eg_cache;\r\nwhile (entry != NULL) {\r\nnext_entry = entry->next;\r\nif ((now.tv_sec - entry->tv.tv_sec)\r\n> entry->ctrl_info.holding_time) {\r\nmsg.type = SND_EGRESS_PURGE;\r\nmsg.content.eg_info = entry->ctrl_info;\r\ndprintk("egress_cache: holding time expired, cache_id = %u.\n",\r\nntohl(entry->ctrl_info.cache_id));\r\nmsg_to_mpoad(&msg, client);\r\nclient->eg_ops->remove_entry(entry, client);\r\n}\r\nentry = next_entry;\r\n}\r\nwrite_unlock_irq(&client->egress_lock);\r\n}\r\nstatic void eg_destroy_cache(struct mpoa_client *mpc)\r\n{\r\nwrite_lock_irq(&mpc->egress_lock);\r\nwhile (mpc->eg_cache != NULL)\r\nmpc->eg_ops->remove_entry(mpc->eg_cache, mpc);\r\nwrite_unlock_irq(&mpc->egress_lock);\r\n}\r\nvoid atm_mpoa_init_cache(struct mpoa_client *mpc)\r\n{\r\nmpc->in_ops = &ingress_ops;\r\nmpc->eg_ops = &egress_ops;\r\n}
