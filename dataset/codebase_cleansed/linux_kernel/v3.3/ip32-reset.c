static void ip32_machine_restart(char *cmd)\r\n{\r\ncrime->control = CRIME_CONTROL_HARD_RESET;\r\nwhile (1);\r\n}\r\nstatic inline void ip32_machine_halt(void)\r\n{\r\nip32_machine_power_off();\r\n}\r\nstatic void ip32_machine_power_off(void)\r\n{\r\nunsigned char reg_a, xctrl_a, xctrl_b;\r\ndisable_irq(MACEISA_RTC_IRQ);\r\nreg_a = CMOS_READ(RTC_REG_A);\r\nreg_a &= ~DS_REGA_DV2;\r\nreg_a |= DS_REGA_DV1;\r\nCMOS_WRITE(reg_a | DS_REGA_DV0, RTC_REG_A);\r\nwbflush();\r\nxctrl_b = CMOS_READ(DS_B1_XCTRL4B)\r\n| DS_XCTRL4B_ABE | DS_XCTRL4B_KFE;\r\nCMOS_WRITE(xctrl_b, DS_B1_XCTRL4B);\r\nxctrl_a = CMOS_READ(DS_B1_XCTRL4A) & ~DS_XCTRL4A_IFS;\r\nCMOS_WRITE(xctrl_a, DS_B1_XCTRL4A);\r\nwbflush();\r\nCMOS_WRITE(xctrl_a | DS_XCTRL4A_PAB, DS_B1_XCTRL4A);\r\nCMOS_WRITE(reg_a, RTC_REG_A);\r\nwbflush();\r\nwhile (1);\r\n}\r\nstatic void power_timeout(unsigned long data)\r\n{\r\nip32_machine_power_off();\r\n}\r\nstatic void blink_timeout(unsigned long data)\r\n{\r\nunsigned long led = mace->perif.ctrl.misc ^ MACEISA_LED_RED;\r\nmace->perif.ctrl.misc = led;\r\nmod_timer(&blink_timer, jiffies + data);\r\n}\r\nstatic void debounce(unsigned long data)\r\n{\r\nunsigned char reg_a, reg_c, xctrl_a;\r\nreg_c = CMOS_READ(RTC_INTR_FLAGS);\r\nreg_a = CMOS_READ(RTC_REG_A);\r\nCMOS_WRITE(reg_a | DS_REGA_DV0, RTC_REG_A);\r\nwbflush();\r\nxctrl_a = CMOS_READ(DS_B1_XCTRL4A);\r\nif ((xctrl_a & DS_XCTRL4A_IFS) || (reg_c & RTC_IRQF )) {\r\ndebounce_timer.expires = jiffies + 50;\r\nadd_timer(&debounce_timer);\r\nCMOS_WRITE(xctrl_a & ~DS_XCTRL4A_IFS, DS_B1_XCTRL4A);\r\nCMOS_WRITE(reg_a & ~DS_REGA_DV0, RTC_REG_A);\r\nreturn;\r\n}\r\nCMOS_WRITE(reg_a & ~DS_REGA_DV0, RTC_REG_A);\r\nif (has_panicked)\r\nip32_machine_restart(NULL);\r\nenable_irq(MACEISA_RTC_IRQ);\r\n}\r\nstatic inline void ip32_power_button(void)\r\n{\r\nif (has_panicked)\r\nreturn;\r\nif (shuting_down || kill_cad_pid(SIGINT, 1)) {\r\nip32_machine_power_off();\r\n}\r\nshuting_down = 1;\r\nblink_timer.data = POWERDOWN_FREQ;\r\nblink_timeout(POWERDOWN_FREQ);\r\ninit_timer(&power_timer);\r\npower_timer.function = power_timeout;\r\npower_timer.expires = jiffies + POWERDOWN_TIMEOUT * HZ;\r\nadd_timer(&power_timer);\r\n}\r\nstatic irqreturn_t ip32_rtc_int(int irq, void *dev_id)\r\n{\r\nunsigned char reg_c;\r\nreg_c = CMOS_READ(RTC_INTR_FLAGS);\r\nif (!(reg_c & RTC_IRQF)) {\r\nprintk(KERN_WARNING\r\n"%s: RTC IRQ without RTC_IRQF\n", __func__);\r\n}\r\ndisable_irq_nosync(MACEISA_RTC_IRQ);\r\ninit_timer(&debounce_timer);\r\ndebounce_timer.function = debounce;\r\ndebounce_timer.expires = jiffies + 50;\r\nadd_timer(&debounce_timer);\r\nprintk(KERN_DEBUG "Power button pressed\n");\r\nip32_power_button();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int panic_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nunsigned long led;\r\nif (has_panicked)\r\nreturn NOTIFY_DONE;\r\nhas_panicked = 1;\r\nled = mace->perif.ctrl.misc | MACEISA_LED_GREEN;\r\nmace->perif.ctrl.misc = led;\r\nblink_timer.data = PANIC_FREQ;\r\nblink_timeout(PANIC_FREQ);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic __init int ip32_reboot_setup(void)\r\n{\r\nunsigned long led = mace->perif.ctrl.misc;\r\nled |= MACEISA_LED_RED;\r\nled &= ~MACEISA_LED_GREEN;\r\nmace->perif.ctrl.misc = led;\r\n_machine_restart = ip32_machine_restart;\r\n_machine_halt = ip32_machine_halt;\r\npm_power_off = ip32_machine_power_off;\r\ninit_timer(&blink_timer);\r\nblink_timer.function = blink_timeout;\r\natomic_notifier_chain_register(&panic_notifier_list, &panic_block);\r\nif (request_irq(MACEISA_RTC_IRQ, ip32_rtc_int, 0, "rtc", NULL))\r\npanic("Can't allocate MACEISA RTC IRQ");\r\nreturn 0;\r\n}
