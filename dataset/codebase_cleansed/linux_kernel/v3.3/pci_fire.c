static int pci_fire_pbm_iommu_init(struct pci_pbm_info *pbm)\r\n{\r\nstruct iommu *iommu = pbm->iommu;\r\nu32 vdma[2], dma_mask;\r\nu64 control;\r\nint tsbsize, err;\r\nvdma[0] = 0xc0000000;\r\nvdma[1] = 0x40000000;\r\ndma_mask = 0xffffffff;\r\ntsbsize = 128;\r\niommu->iommu_control = pbm->pbm_regs + FIRE_IOMMU_CONTROL;\r\niommu->iommu_tsbbase = pbm->pbm_regs + FIRE_IOMMU_TSBBASE;\r\niommu->iommu_flush = pbm->pbm_regs + FIRE_IOMMU_FLUSH;\r\niommu->iommu_flushinv = pbm->pbm_regs + FIRE_IOMMU_FLUSHINV;\r\niommu->write_complete_reg = pbm->controller_regs + 0x410000UL;\r\nupa_writeq(~(u64)0, iommu->iommu_flushinv);\r\nerr = iommu_table_init(iommu, tsbsize * 8 * 1024, vdma[0], dma_mask,\r\npbm->numa_node);\r\nif (err)\r\nreturn err;\r\nupa_writeq(__pa(iommu->page_table) | 0x7UL, iommu->iommu_tsbbase);\r\ncontrol = upa_readq(iommu->iommu_control);\r\ncontrol |= (0x00000400 |\r\n0x00000300 |\r\n0x00000002 |\r\n0x00000001 );\r\nupa_writeq(control, iommu->iommu_control);\r\nreturn 0;\r\n}\r\nstatic int pci_fire_get_head(struct pci_pbm_info *pbm, unsigned long msiqid,\r\nunsigned long *head)\r\n{\r\n*head = upa_readq(pbm->pbm_regs + EVENT_QUEUE_HEAD(msiqid));\r\nreturn 0;\r\n}\r\nstatic int pci_fire_dequeue_msi(struct pci_pbm_info *pbm, unsigned long msiqid,\r\nunsigned long *head, unsigned long *msi)\r\n{\r\nunsigned long type_fmt, type, msi_num;\r\nstruct pci_msiq_entry *base, *ep;\r\nbase = (pbm->msi_queues + ((msiqid - pbm->msiq_first) * 8192));\r\nep = &base[*head];\r\nif ((ep->word0 & MSIQ_WORD0_FMT_TYPE) == 0)\r\nreturn 0;\r\ntype_fmt = ((ep->word0 & MSIQ_WORD0_FMT_TYPE) >>\r\nMSIQ_WORD0_FMT_TYPE_SHIFT);\r\ntype = (type_fmt >> 3);\r\nif (unlikely(type != MSIQ_TYPE_MSI32 &&\r\ntype != MSIQ_TYPE_MSI64))\r\nreturn -EINVAL;\r\n*msi = msi_num = ((ep->word0 & MSIQ_WORD0_DATA0) >>\r\nMSIQ_WORD0_DATA0_SHIFT);\r\nupa_writeq(MSI_CLEAR_EQWR_N, pbm->pbm_regs + MSI_CLEAR(msi_num));\r\nep->word0 &= ~MSIQ_WORD0_FMT_TYPE;\r\n(*head)++;\r\nif (*head >= pbm->msiq_ent_count)\r\n*head = 0;\r\nreturn 1;\r\n}\r\nstatic int pci_fire_set_head(struct pci_pbm_info *pbm, unsigned long msiqid,\r\nunsigned long head)\r\n{\r\nupa_writeq(head, pbm->pbm_regs + EVENT_QUEUE_HEAD(msiqid));\r\nreturn 0;\r\n}\r\nstatic int pci_fire_msi_setup(struct pci_pbm_info *pbm, unsigned long msiqid,\r\nunsigned long msi, int is_msi64)\r\n{\r\nu64 val;\r\nval = upa_readq(pbm->pbm_regs + MSI_MAP(msi));\r\nval &= ~(MSI_MAP_EQNUM);\r\nval |= msiqid;\r\nupa_writeq(val, pbm->pbm_regs + MSI_MAP(msi));\r\nupa_writeq(MSI_CLEAR_EQWR_N, pbm->pbm_regs + MSI_CLEAR(msi));\r\nval = upa_readq(pbm->pbm_regs + MSI_MAP(msi));\r\nval |= MSI_MAP_VALID;\r\nupa_writeq(val, pbm->pbm_regs + MSI_MAP(msi));\r\nreturn 0;\r\n}\r\nstatic int pci_fire_msi_teardown(struct pci_pbm_info *pbm, unsigned long msi)\r\n{\r\nu64 val;\r\nval = upa_readq(pbm->pbm_regs + MSI_MAP(msi));\r\nval &= ~MSI_MAP_VALID;\r\nupa_writeq(val, pbm->pbm_regs + MSI_MAP(msi));\r\nreturn 0;\r\n}\r\nstatic int pci_fire_msiq_alloc(struct pci_pbm_info *pbm)\r\n{\r\nunsigned long pages, order, i;\r\norder = get_order(512 * 1024);\r\npages = __get_free_pages(GFP_KERNEL | __GFP_COMP, order);\r\nif (pages == 0UL) {\r\nprintk(KERN_ERR "MSI: Cannot allocate MSI queues (o=%lu).\n",\r\norder);\r\nreturn -ENOMEM;\r\n}\r\nmemset((char *)pages, 0, PAGE_SIZE << order);\r\npbm->msi_queues = (void *) pages;\r\nupa_writeq((EVENT_QUEUE_BASE_ADDR_ALL_ONES |\r\n__pa(pbm->msi_queues)),\r\npbm->pbm_regs + EVENT_QUEUE_BASE_ADDR_REG);\r\nupa_writeq(pbm->portid << 6, pbm->pbm_regs + IMONDO_DATA0);\r\nupa_writeq(0, pbm->pbm_regs + IMONDO_DATA1);\r\nupa_writeq(pbm->msi32_start, pbm->pbm_regs + MSI_32BIT_ADDR);\r\nupa_writeq(pbm->msi64_start, pbm->pbm_regs + MSI_64BIT_ADDR);\r\nfor (i = 0; i < pbm->msiq_num; i++) {\r\nupa_writeq(0, pbm->pbm_regs + EVENT_QUEUE_HEAD(i));\r\nupa_writeq(0, pbm->pbm_regs + EVENT_QUEUE_TAIL(i));\r\n}\r\nreturn 0;\r\n}\r\nstatic void pci_fire_msiq_free(struct pci_pbm_info *pbm)\r\n{\r\nunsigned long pages, order;\r\norder = get_order(512 * 1024);\r\npages = (unsigned long) pbm->msi_queues;\r\nfree_pages(pages, order);\r\npbm->msi_queues = NULL;\r\n}\r\nstatic int pci_fire_msiq_build_irq(struct pci_pbm_info *pbm,\r\nunsigned long msiqid,\r\nunsigned long devino)\r\n{\r\nunsigned long cregs = (unsigned long) pbm->pbm_regs;\r\nunsigned long imap_reg, iclr_reg, int_ctrlr;\r\nunsigned int irq;\r\nint fixup;\r\nu64 val;\r\nimap_reg = cregs + (0x001000UL + (devino * 0x08UL));\r\niclr_reg = cregs + (0x001400UL + (devino * 0x08UL));\r\nint_ctrlr = (1UL << 6);\r\nval = upa_readq(imap_reg);\r\nval |= (1UL << 63) | int_ctrlr;\r\nupa_writeq(val, imap_reg);\r\nfixup = ((pbm->portid << 6) | devino) - int_ctrlr;\r\nirq = build_irq(fixup, iclr_reg, imap_reg);\r\nif (!irq)\r\nreturn -ENOMEM;\r\nupa_writeq(EVENT_QUEUE_CONTROL_SET_EN,\r\npbm->pbm_regs + EVENT_QUEUE_CONTROL_SET(msiqid));\r\nreturn irq;\r\n}\r\nstatic void pci_fire_msi_init(struct pci_pbm_info *pbm)\r\n{\r\nsparc64_pbm_msi_init(pbm, &pci_fire_msiq_ops);\r\n}\r\nstatic void pci_fire_msi_init(struct pci_pbm_info *pbm)\r\n{\r\n}\r\nstatic void pci_fire_hw_init(struct pci_pbm_info *pbm)\r\n{\r\nu64 val;\r\nupa_writeq(FIRE_PARITY_ENAB,\r\npbm->controller_regs + FIRE_PARITY_CONTROL);\r\nupa_writeq((FIRE_FATAL_RESET_SPARE |\r\nFIRE_FATAL_RESET_MB |\r\nFIRE_FATAL_RESET_CPE |\r\nFIRE_FATAL_RESET_APE |\r\nFIRE_FATAL_RESET_PIO |\r\nFIRE_FATAL_RESET_JW |\r\nFIRE_FATAL_RESET_JI |\r\nFIRE_FATAL_RESET_JR),\r\npbm->controller_regs + FIRE_FATAL_RESET_CTL);\r\nupa_writeq(~(u64)0, pbm->controller_regs + FIRE_CORE_INTR_ENABLE);\r\nval = upa_readq(pbm->pbm_regs + FIRE_TLU_CTRL);\r\nval |= (FIRE_TLU_CTRL_TIM |\r\nFIRE_TLU_CTRL_QDET |\r\nFIRE_TLU_CTRL_CFG);\r\nupa_writeq(val, pbm->pbm_regs + FIRE_TLU_CTRL);\r\nupa_writeq(0, pbm->pbm_regs + FIRE_TLU_DEV_CTRL);\r\nupa_writeq(FIRE_TLU_LINK_CTRL_CLK,\r\npbm->pbm_regs + FIRE_TLU_LINK_CTRL);\r\nupa_writeq(0, pbm->pbm_regs + FIRE_LPU_RESET);\r\nupa_writeq(FIRE_LPU_LLCFG_VC0, pbm->pbm_regs + FIRE_LPU_LLCFG);\r\nupa_writeq((FIRE_LPU_FCTRL_UCTRL_N | FIRE_LPU_FCTRL_UCTRL_P),\r\npbm->pbm_regs + FIRE_LPU_FCTRL_UCTRL);\r\nupa_writeq(((0xffff << 16) | (0x0000 << 0)),\r\npbm->pbm_regs + FIRE_LPU_TXL_FIFOP);\r\nupa_writeq(3000000, pbm->pbm_regs + FIRE_LPU_LTSSM_CFG2);\r\nupa_writeq(500000, pbm->pbm_regs + FIRE_LPU_LTSSM_CFG3);\r\nupa_writeq((2 << 16) | (140 << 8),\r\npbm->pbm_regs + FIRE_LPU_LTSSM_CFG4);\r\nupa_writeq(0, pbm->pbm_regs + FIRE_LPU_LTSSM_CFG5);\r\nupa_writeq(~(u64)0, pbm->pbm_regs + FIRE_DMC_IENAB);\r\nupa_writeq(0, pbm->pbm_regs + FIRE_DMC_DBG_SEL_A);\r\nupa_writeq(0, pbm->pbm_regs + FIRE_DMC_DBG_SEL_B);\r\nupa_writeq(~(u64)0, pbm->pbm_regs + FIRE_PEC_IENAB);\r\n}\r\nstatic int __devinit pci_fire_pbm_init(struct pci_pbm_info *pbm,\r\nstruct platform_device *op, u32 portid)\r\n{\r\nconst struct linux_prom64_registers *regs;\r\nstruct device_node *dp = op->dev.of_node;\r\nint err;\r\npbm->numa_node = -1;\r\npbm->pci_ops = &sun4u_pci_ops;\r\npbm->config_space_reg_bits = 12;\r\npbm->index = pci_num_pbms++;\r\npbm->portid = portid;\r\npbm->op = op;\r\npbm->name = dp->full_name;\r\nregs = of_get_property(dp, "reg", NULL);\r\npbm->pbm_regs = regs[0].phys_addr;\r\npbm->controller_regs = regs[1].phys_addr - 0x410000UL;\r\nprintk("%s: SUN4U PCIE Bus Module\n", pbm->name);\r\npci_determine_mem_io_space(pbm);\r\npci_get_pbm_props(pbm);\r\npci_fire_hw_init(pbm);\r\nerr = pci_fire_pbm_iommu_init(pbm);\r\nif (err)\r\nreturn err;\r\npci_fire_msi_init(pbm);\r\npbm->pci_bus = pci_scan_one_pbm(pbm, &op->dev);\r\npbm->next = pci_pbm_root;\r\npci_pbm_root = pbm;\r\nreturn 0;\r\n}\r\nstatic int __devinit fire_probe(struct platform_device *op)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nstruct pci_pbm_info *pbm;\r\nstruct iommu *iommu;\r\nu32 portid;\r\nint err;\r\nportid = of_getintprop_default(dp, "portid", 0xff);\r\nerr = -ENOMEM;\r\npbm = kzalloc(sizeof(*pbm), GFP_KERNEL);\r\nif (!pbm) {\r\nprintk(KERN_ERR PFX "Cannot allocate pci_pbminfo.\n");\r\ngoto out_err;\r\n}\r\niommu = kzalloc(sizeof(struct iommu), GFP_KERNEL);\r\nif (!iommu) {\r\nprintk(KERN_ERR PFX "Cannot allocate PBM iommu.\n");\r\ngoto out_free_controller;\r\n}\r\npbm->iommu = iommu;\r\nerr = pci_fire_pbm_init(pbm, op, portid);\r\nif (err)\r\ngoto out_free_iommu;\r\ndev_set_drvdata(&op->dev, pbm);\r\nreturn 0;\r\nout_free_iommu:\r\nkfree(pbm->iommu);\r\nout_free_controller:\r\nkfree(pbm);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic int __init fire_init(void)\r\n{\r\nreturn platform_driver_register(&fire_driver);\r\n}
