int drm_buffer_alloc(struct drm_buffer **buf, int size)\r\n{\r\nint nr_pages = size / PAGE_SIZE + 1;\r\nint idx;\r\n*buf = kzalloc(sizeof(struct drm_buffer) + nr_pages*sizeof(char *),\r\nGFP_KERNEL);\r\nif (*buf == NULL) {\r\nDRM_ERROR("Failed to allocate drm buffer object to hold"\r\n" %d bytes in %d pages.\n",\r\nsize, nr_pages);\r\nreturn -ENOMEM;\r\n}\r\n(*buf)->size = size;\r\nfor (idx = 0; idx < nr_pages; ++idx) {\r\n(*buf)->data[idx] =\r\nkmalloc(min(PAGE_SIZE, size - idx * PAGE_SIZE),\r\nGFP_KERNEL);\r\nif ((*buf)->data[idx] == NULL) {\r\nDRM_ERROR("Failed to allocate %dth page for drm"\r\n" buffer with %d bytes and %d pages.\n",\r\nidx + 1, size, nr_pages);\r\ngoto error_out;\r\n}\r\n}\r\nreturn 0;\r\nerror_out:\r\nif ((*buf)->data[idx])\r\nkfree((*buf)->data[idx]);\r\nfor (--idx; idx >= 0; --idx)\r\nkfree((*buf)->data[idx]);\r\nkfree(*buf);\r\nreturn -ENOMEM;\r\n}\r\nint drm_buffer_copy_from_user(struct drm_buffer *buf,\r\nvoid __user *user_data, int size)\r\n{\r\nint nr_pages = size / PAGE_SIZE + 1;\r\nint idx;\r\nif (size > buf->size) {\r\nDRM_ERROR("Requesting to copy %d bytes to a drm buffer with"\r\n" %d bytes space\n",\r\nsize, buf->size);\r\nreturn -EFAULT;\r\n}\r\nfor (idx = 0; idx < nr_pages; ++idx) {\r\nif (DRM_COPY_FROM_USER(buf->data[idx],\r\nuser_data + idx * PAGE_SIZE,\r\nmin(PAGE_SIZE, size - idx * PAGE_SIZE))) {\r\nDRM_ERROR("Failed to copy user data (%p) to drm buffer"\r\n" (%p) %dth page.\n",\r\nuser_data, buf, idx);\r\nreturn -EFAULT;\r\n}\r\n}\r\nbuf->iterator = 0;\r\nreturn 0;\r\n}\r\nvoid drm_buffer_free(struct drm_buffer *buf)\r\n{\r\nif (buf != NULL) {\r\nint nr_pages = buf->size / PAGE_SIZE + 1;\r\nint idx;\r\nfor (idx = 0; idx < nr_pages; ++idx)\r\nkfree(buf->data[idx]);\r\nkfree(buf);\r\n}\r\n}\r\nvoid *drm_buffer_read_object(struct drm_buffer *buf,\r\nint objsize, void *stack_obj)\r\n{\r\nint idx = drm_buffer_index(buf);\r\nint page = drm_buffer_page(buf);\r\nvoid *obj = NULL;\r\nif (idx + objsize <= PAGE_SIZE) {\r\nobj = &buf->data[page][idx];\r\n} else {\r\nint beginsz = PAGE_SIZE - idx;\r\nmemcpy(stack_obj, &buf->data[page][idx], beginsz);\r\nmemcpy(stack_obj + beginsz, &buf->data[page + 1][0],\r\nobjsize - beginsz);\r\nobj = stack_obj;\r\n}\r\ndrm_buffer_advance(buf, objsize);\r\nreturn obj;\r\n}
