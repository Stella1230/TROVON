STATIC int\r\nxfs_uuid_mount(\r\nstruct xfs_mount *mp)\r\n{\r\nuuid_t *uuid = &mp->m_sb.sb_uuid;\r\nint hole, i;\r\nif (mp->m_flags & XFS_MOUNT_NOUUID)\r\nreturn 0;\r\nif (uuid_is_nil(uuid)) {\r\nxfs_warn(mp, "Filesystem has nil UUID - can't mount");\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nmutex_lock(&xfs_uuid_table_mutex);\r\nfor (i = 0, hole = -1; i < xfs_uuid_table_size; i++) {\r\nif (uuid_is_nil(&xfs_uuid_table[i])) {\r\nhole = i;\r\ncontinue;\r\n}\r\nif (uuid_equal(uuid, &xfs_uuid_table[i]))\r\ngoto out_duplicate;\r\n}\r\nif (hole < 0) {\r\nxfs_uuid_table = kmem_realloc(xfs_uuid_table,\r\n(xfs_uuid_table_size + 1) * sizeof(*xfs_uuid_table),\r\nxfs_uuid_table_size * sizeof(*xfs_uuid_table),\r\nKM_SLEEP);\r\nhole = xfs_uuid_table_size++;\r\n}\r\nxfs_uuid_table[hole] = *uuid;\r\nmutex_unlock(&xfs_uuid_table_mutex);\r\nreturn 0;\r\nout_duplicate:\r\nmutex_unlock(&xfs_uuid_table_mutex);\r\nxfs_warn(mp, "Filesystem has duplicate UUID - can't mount");\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nSTATIC void\r\nxfs_uuid_unmount(\r\nstruct xfs_mount *mp)\r\n{\r\nuuid_t *uuid = &mp->m_sb.sb_uuid;\r\nint i;\r\nif (mp->m_flags & XFS_MOUNT_NOUUID)\r\nreturn;\r\nmutex_lock(&xfs_uuid_table_mutex);\r\nfor (i = 0; i < xfs_uuid_table_size; i++) {\r\nif (uuid_is_nil(&xfs_uuid_table[i]))\r\ncontinue;\r\nif (!uuid_equal(uuid, &xfs_uuid_table[i]))\r\ncontinue;\r\nmemset(&xfs_uuid_table[i], 0, sizeof(uuid_t));\r\nbreak;\r\n}\r\nASSERT(i < xfs_uuid_table_size);\r\nmutex_unlock(&xfs_uuid_table_mutex);\r\n}\r\nstruct xfs_perag *\r\nxfs_perag_get(struct xfs_mount *mp, xfs_agnumber_t agno)\r\n{\r\nstruct xfs_perag *pag;\r\nint ref = 0;\r\nrcu_read_lock();\r\npag = radix_tree_lookup(&mp->m_perag_tree, agno);\r\nif (pag) {\r\nASSERT(atomic_read(&pag->pag_ref) >= 0);\r\nref = atomic_inc_return(&pag->pag_ref);\r\n}\r\nrcu_read_unlock();\r\ntrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\r\nreturn pag;\r\n}\r\nstruct xfs_perag *\r\nxfs_perag_get_tag(\r\nstruct xfs_mount *mp,\r\nxfs_agnumber_t first,\r\nint tag)\r\n{\r\nstruct xfs_perag *pag;\r\nint found;\r\nint ref;\r\nrcu_read_lock();\r\nfound = radix_tree_gang_lookup_tag(&mp->m_perag_tree,\r\n(void **)&pag, first, 1, tag);\r\nif (found <= 0) {\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nref = atomic_inc_return(&pag->pag_ref);\r\nrcu_read_unlock();\r\ntrace_xfs_perag_get_tag(mp, pag->pag_agno, ref, _RET_IP_);\r\nreturn pag;\r\n}\r\nvoid\r\nxfs_perag_put(struct xfs_perag *pag)\r\n{\r\nint ref;\r\nASSERT(atomic_read(&pag->pag_ref) > 0);\r\nref = atomic_dec_return(&pag->pag_ref);\r\ntrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\r\n}\r\nSTATIC void\r\n__xfs_free_perag(\r\nstruct rcu_head *head)\r\n{\r\nstruct xfs_perag *pag = container_of(head, struct xfs_perag, rcu_head);\r\nASSERT(atomic_read(&pag->pag_ref) == 0);\r\nkmem_free(pag);\r\n}\r\nSTATIC void\r\nxfs_free_perag(\r\nxfs_mount_t *mp)\r\n{\r\nxfs_agnumber_t agno;\r\nstruct xfs_perag *pag;\r\nfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\r\nspin_lock(&mp->m_perag_lock);\r\npag = radix_tree_delete(&mp->m_perag_tree, agno);\r\nspin_unlock(&mp->m_perag_lock);\r\nASSERT(pag);\r\nASSERT(atomic_read(&pag->pag_ref) == 0);\r\ncall_rcu(&pag->rcu_head, __xfs_free_perag);\r\n}\r\n}\r\nint\r\nxfs_sb_validate_fsb_count(\r\nxfs_sb_t *sbp,\r\n__uint64_t nblocks)\r\n{\r\nASSERT(PAGE_SHIFT >= sbp->sb_blocklog);\r\nASSERT(sbp->sb_blocklog >= BBSHIFT);\r\n#if XFS_BIG_BLKNOS\r\nif (nblocks >> (PAGE_CACHE_SHIFT - sbp->sb_blocklog) > ULONG_MAX)\r\nreturn EFBIG;\r\n#else\r\nif (nblocks << (sbp->sb_blocklog - BBSHIFT) > UINT_MAX)\r\nreturn EFBIG;\r\n#endif\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_mount_validate_sb(\r\nxfs_mount_t *mp,\r\nxfs_sb_t *sbp,\r\nint flags)\r\n{\r\nint loud = !(flags & XFS_MFSI_QUIET);\r\nif (sbp->sb_magicnum != XFS_SB_MAGIC) {\r\nif (loud)\r\nxfs_warn(mp, "bad magic number");\r\nreturn XFS_ERROR(EWRONGFS);\r\n}\r\nif (!xfs_sb_good_version(sbp)) {\r\nif (loud)\r\nxfs_warn(mp, "bad version");\r\nreturn XFS_ERROR(EWRONGFS);\r\n}\r\nif (unlikely(\r\nsbp->sb_logstart == 0 && mp->m_logdev_targp == mp->m_ddev_targp)) {\r\nif (loud)\r\nxfs_warn(mp,\r\n"filesystem is marked as having an external log; "\r\n"specify logdev on the mount command line.");\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nif (unlikely(\r\nsbp->sb_logstart != 0 && mp->m_logdev_targp != mp->m_ddev_targp)) {\r\nif (loud)\r\nxfs_warn(mp,\r\n"filesystem is marked as having an internal log; "\r\n"do not specify logdev on the mount command line.");\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nif (unlikely(\r\nsbp->sb_agcount <= 0 ||\r\nsbp->sb_sectsize < XFS_MIN_SECTORSIZE ||\r\nsbp->sb_sectsize > XFS_MAX_SECTORSIZE ||\r\nsbp->sb_sectlog < XFS_MIN_SECTORSIZE_LOG ||\r\nsbp->sb_sectlog > XFS_MAX_SECTORSIZE_LOG ||\r\nsbp->sb_sectsize != (1 << sbp->sb_sectlog) ||\r\nsbp->sb_blocksize < XFS_MIN_BLOCKSIZE ||\r\nsbp->sb_blocksize > XFS_MAX_BLOCKSIZE ||\r\nsbp->sb_blocklog < XFS_MIN_BLOCKSIZE_LOG ||\r\nsbp->sb_blocklog > XFS_MAX_BLOCKSIZE_LOG ||\r\nsbp->sb_blocksize != (1 << sbp->sb_blocklog) ||\r\nsbp->sb_inodesize < XFS_DINODE_MIN_SIZE ||\r\nsbp->sb_inodesize > XFS_DINODE_MAX_SIZE ||\r\nsbp->sb_inodelog < XFS_DINODE_MIN_LOG ||\r\nsbp->sb_inodelog > XFS_DINODE_MAX_LOG ||\r\nsbp->sb_inodesize != (1 << sbp->sb_inodelog) ||\r\n(sbp->sb_blocklog - sbp->sb_inodelog != sbp->sb_inopblog) ||\r\n(sbp->sb_rextsize * sbp->sb_blocksize > XFS_MAX_RTEXTSIZE) ||\r\n(sbp->sb_rextsize * sbp->sb_blocksize < XFS_MIN_RTEXTSIZE) ||\r\n(sbp->sb_imax_pct > 100 ) ||\r\nsbp->sb_dblocks == 0 ||\r\nsbp->sb_dblocks > XFS_MAX_DBLOCKS(sbp) ||\r\nsbp->sb_dblocks < XFS_MIN_DBLOCKS(sbp))) {\r\nif (loud)\r\nXFS_CORRUPTION_ERROR("SB sanity check failed",\r\nXFS_ERRLEVEL_LOW, mp, sbp);\r\nreturn XFS_ERROR(EFSCORRUPTED);\r\n}\r\nif (unlikely(sbp->sb_blocksize > PAGE_SIZE)) {\r\nif (loud) {\r\nxfs_warn(mp,\r\n"File system with blocksize %d bytes. "\r\n"Only pagesize (%ld) or less will currently work.",\r\nsbp->sb_blocksize, PAGE_SIZE);\r\n}\r\nreturn XFS_ERROR(ENOSYS);\r\n}\r\nswitch (sbp->sb_inodesize) {\r\ncase 256:\r\ncase 512:\r\ncase 1024:\r\ncase 2048:\r\nbreak;\r\ndefault:\r\nif (loud)\r\nxfs_warn(mp, "inode size of %d bytes not supported",\r\nsbp->sb_inodesize);\r\nreturn XFS_ERROR(ENOSYS);\r\n}\r\nif (xfs_sb_validate_fsb_count(sbp, sbp->sb_dblocks) ||\r\nxfs_sb_validate_fsb_count(sbp, sbp->sb_rblocks)) {\r\nif (loud)\r\nxfs_warn(mp,\r\n"file system too large to be mounted on this system.");\r\nreturn XFS_ERROR(EFBIG);\r\n}\r\nif (unlikely(sbp->sb_inprogress)) {\r\nif (loud)\r\nxfs_warn(mp, "file system busy");\r\nreturn XFS_ERROR(EFSCORRUPTED);\r\n}\r\nif (unlikely(!xfs_sb_version_hasdirv2(sbp))) {\r\nif (loud)\r\nxfs_warn(mp,\r\n"file system using version 1 directory format");\r\nreturn XFS_ERROR(ENOSYS);\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxfs_initialize_perag(\r\nxfs_mount_t *mp,\r\nxfs_agnumber_t agcount,\r\nxfs_agnumber_t *maxagi)\r\n{\r\nxfs_agnumber_t index, max_metadata;\r\nxfs_agnumber_t first_initialised = 0;\r\nxfs_perag_t *pag;\r\nxfs_agino_t agino;\r\nxfs_ino_t ino;\r\nxfs_sb_t *sbp = &mp->m_sb;\r\nint error = -ENOMEM;\r\nfor (index = 0; index < agcount; index++) {\r\npag = xfs_perag_get(mp, index);\r\nif (pag) {\r\nxfs_perag_put(pag);\r\ncontinue;\r\n}\r\nif (!first_initialised)\r\nfirst_initialised = index;\r\npag = kmem_zalloc(sizeof(*pag), KM_MAYFAIL);\r\nif (!pag)\r\ngoto out_unwind;\r\npag->pag_agno = index;\r\npag->pag_mount = mp;\r\nspin_lock_init(&pag->pag_ici_lock);\r\nmutex_init(&pag->pag_ici_reclaim_lock);\r\nINIT_RADIX_TREE(&pag->pag_ici_root, GFP_ATOMIC);\r\nspin_lock_init(&pag->pag_buf_lock);\r\npag->pag_buf_tree = RB_ROOT;\r\nif (radix_tree_preload(GFP_NOFS))\r\ngoto out_unwind;\r\nspin_lock(&mp->m_perag_lock);\r\nif (radix_tree_insert(&mp->m_perag_tree, index, pag)) {\r\nBUG();\r\nspin_unlock(&mp->m_perag_lock);\r\nradix_tree_preload_end();\r\nerror = -EEXIST;\r\ngoto out_unwind;\r\n}\r\nspin_unlock(&mp->m_perag_lock);\r\nradix_tree_preload_end();\r\n}\r\nagino = XFS_OFFBNO_TO_AGINO(mp, sbp->sb_agblocks - 1, 0);\r\nino = XFS_AGINO_TO_INO(mp, agcount - 1, agino);\r\nif ((mp->m_flags & XFS_MOUNT_SMALL_INUMS) && ino > XFS_MAXINUMBER_32)\r\nmp->m_flags |= XFS_MOUNT_32BITINODES;\r\nelse\r\nmp->m_flags &= ~XFS_MOUNT_32BITINODES;\r\nif (mp->m_flags & XFS_MOUNT_32BITINODES) {\r\nif (mp->m_maxicount) {\r\n__uint64_t icount;\r\nicount = sbp->sb_dblocks * sbp->sb_imax_pct;\r\ndo_div(icount, 100);\r\nicount += sbp->sb_agblocks - 1;\r\ndo_div(icount, sbp->sb_agblocks);\r\nmax_metadata = icount;\r\n} else {\r\nmax_metadata = agcount;\r\n}\r\nfor (index = 0; index < agcount; index++) {\r\nino = XFS_AGINO_TO_INO(mp, index, agino);\r\nif (ino > XFS_MAXINUMBER_32) {\r\nindex++;\r\nbreak;\r\n}\r\npag = xfs_perag_get(mp, index);\r\npag->pagi_inodeok = 1;\r\nif (index < max_metadata)\r\npag->pagf_metadata = 1;\r\nxfs_perag_put(pag);\r\n}\r\n} else {\r\nfor (index = 0; index < agcount; index++) {\r\npag = xfs_perag_get(mp, index);\r\npag->pagi_inodeok = 1;\r\nxfs_perag_put(pag);\r\n}\r\n}\r\nif (maxagi)\r\n*maxagi = index;\r\nreturn 0;\r\nout_unwind:\r\nkmem_free(pag);\r\nfor (; index > first_initialised; index--) {\r\npag = radix_tree_delete(&mp->m_perag_tree, index);\r\nkmem_free(pag);\r\n}\r\nreturn error;\r\n}\r\nvoid\r\nxfs_sb_from_disk(\r\nxfs_sb_t *to,\r\nxfs_dsb_t *from)\r\n{\r\nto->sb_magicnum = be32_to_cpu(from->sb_magicnum);\r\nto->sb_blocksize = be32_to_cpu(from->sb_blocksize);\r\nto->sb_dblocks = be64_to_cpu(from->sb_dblocks);\r\nto->sb_rblocks = be64_to_cpu(from->sb_rblocks);\r\nto->sb_rextents = be64_to_cpu(from->sb_rextents);\r\nmemcpy(&to->sb_uuid, &from->sb_uuid, sizeof(to->sb_uuid));\r\nto->sb_logstart = be64_to_cpu(from->sb_logstart);\r\nto->sb_rootino = be64_to_cpu(from->sb_rootino);\r\nto->sb_rbmino = be64_to_cpu(from->sb_rbmino);\r\nto->sb_rsumino = be64_to_cpu(from->sb_rsumino);\r\nto->sb_rextsize = be32_to_cpu(from->sb_rextsize);\r\nto->sb_agblocks = be32_to_cpu(from->sb_agblocks);\r\nto->sb_agcount = be32_to_cpu(from->sb_agcount);\r\nto->sb_rbmblocks = be32_to_cpu(from->sb_rbmblocks);\r\nto->sb_logblocks = be32_to_cpu(from->sb_logblocks);\r\nto->sb_versionnum = be16_to_cpu(from->sb_versionnum);\r\nto->sb_sectsize = be16_to_cpu(from->sb_sectsize);\r\nto->sb_inodesize = be16_to_cpu(from->sb_inodesize);\r\nto->sb_inopblock = be16_to_cpu(from->sb_inopblock);\r\nmemcpy(&to->sb_fname, &from->sb_fname, sizeof(to->sb_fname));\r\nto->sb_blocklog = from->sb_blocklog;\r\nto->sb_sectlog = from->sb_sectlog;\r\nto->sb_inodelog = from->sb_inodelog;\r\nto->sb_inopblog = from->sb_inopblog;\r\nto->sb_agblklog = from->sb_agblklog;\r\nto->sb_rextslog = from->sb_rextslog;\r\nto->sb_inprogress = from->sb_inprogress;\r\nto->sb_imax_pct = from->sb_imax_pct;\r\nto->sb_icount = be64_to_cpu(from->sb_icount);\r\nto->sb_ifree = be64_to_cpu(from->sb_ifree);\r\nto->sb_fdblocks = be64_to_cpu(from->sb_fdblocks);\r\nto->sb_frextents = be64_to_cpu(from->sb_frextents);\r\nto->sb_uquotino = be64_to_cpu(from->sb_uquotino);\r\nto->sb_gquotino = be64_to_cpu(from->sb_gquotino);\r\nto->sb_qflags = be16_to_cpu(from->sb_qflags);\r\nto->sb_flags = from->sb_flags;\r\nto->sb_shared_vn = from->sb_shared_vn;\r\nto->sb_inoalignmt = be32_to_cpu(from->sb_inoalignmt);\r\nto->sb_unit = be32_to_cpu(from->sb_unit);\r\nto->sb_width = be32_to_cpu(from->sb_width);\r\nto->sb_dirblklog = from->sb_dirblklog;\r\nto->sb_logsectlog = from->sb_logsectlog;\r\nto->sb_logsectsize = be16_to_cpu(from->sb_logsectsize);\r\nto->sb_logsunit = be32_to_cpu(from->sb_logsunit);\r\nto->sb_features2 = be32_to_cpu(from->sb_features2);\r\nto->sb_bad_features2 = be32_to_cpu(from->sb_bad_features2);\r\n}\r\nvoid\r\nxfs_sb_to_disk(\r\nxfs_dsb_t *to,\r\nxfs_sb_t *from,\r\n__int64_t fields)\r\n{\r\nxfs_caddr_t to_ptr = (xfs_caddr_t)to;\r\nxfs_caddr_t from_ptr = (xfs_caddr_t)from;\r\nxfs_sb_field_t f;\r\nint first;\r\nint size;\r\nASSERT(fields);\r\nif (!fields)\r\nreturn;\r\nwhile (fields) {\r\nf = (xfs_sb_field_t)xfs_lowbit64((__uint64_t)fields);\r\nfirst = xfs_sb_info[f].offset;\r\nsize = xfs_sb_info[f + 1].offset - first;\r\nASSERT(xfs_sb_info[f].type == 0 || xfs_sb_info[f].type == 1);\r\nif (size == 1 || xfs_sb_info[f].type == 1) {\r\nmemcpy(to_ptr + first, from_ptr + first, size);\r\n} else {\r\nswitch (size) {\r\ncase 2:\r\n*(__be16 *)(to_ptr + first) =\r\ncpu_to_be16(*(__u16 *)(from_ptr + first));\r\nbreak;\r\ncase 4:\r\n*(__be32 *)(to_ptr + first) =\r\ncpu_to_be32(*(__u32 *)(from_ptr + first));\r\nbreak;\r\ncase 8:\r\n*(__be64 *)(to_ptr + first) =\r\ncpu_to_be64(*(__u64 *)(from_ptr + first));\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\n}\r\n}\r\nfields &= ~(1LL << f);\r\n}\r\n}\r\nint\r\nxfs_readsb(xfs_mount_t *mp, int flags)\r\n{\r\nunsigned int sector_size;\r\nxfs_buf_t *bp;\r\nint error;\r\nint loud = !(flags & XFS_MFSI_QUIET);\r\nASSERT(mp->m_sb_bp == NULL);\r\nASSERT(mp->m_ddev_targp != NULL);\r\nsector_size = xfs_getsize_buftarg(mp->m_ddev_targp);\r\nreread:\r\nbp = xfs_buf_read_uncached(mp, mp->m_ddev_targp,\r\nXFS_SB_DADDR, sector_size, 0);\r\nif (!bp) {\r\nif (loud)\r\nxfs_warn(mp, "SB buffer read failed");\r\nreturn EIO;\r\n}\r\nxfs_sb_from_disk(&mp->m_sb, XFS_BUF_TO_SBP(bp));\r\nerror = xfs_mount_validate_sb(mp, &(mp->m_sb), flags);\r\nif (error) {\r\nif (loud)\r\nxfs_warn(mp, "SB validate failed");\r\ngoto release_buf;\r\n}\r\nif (sector_size > mp->m_sb.sb_sectsize) {\r\nif (loud)\r\nxfs_warn(mp, "device supports %u byte sectors (not %u)",\r\nsector_size, mp->m_sb.sb_sectsize);\r\nerror = ENOSYS;\r\ngoto release_buf;\r\n}\r\nif (sector_size < mp->m_sb.sb_sectsize) {\r\nxfs_buf_relse(bp);\r\nsector_size = mp->m_sb.sb_sectsize;\r\ngoto reread;\r\n}\r\nxfs_icsb_reinit_counters(mp);\r\nmp->m_sb_bp = bp;\r\nxfs_buf_unlock(bp);\r\nreturn 0;\r\nrelease_buf:\r\nxfs_buf_relse(bp);\r\nreturn error;\r\n}\r\nSTATIC void\r\nxfs_mount_common(xfs_mount_t *mp, xfs_sb_t *sbp)\r\n{\r\nmp->m_agfrotor = mp->m_agirotor = 0;\r\nspin_lock_init(&mp->m_agirotor_lock);\r\nmp->m_maxagi = mp->m_sb.sb_agcount;\r\nmp->m_blkbit_log = sbp->sb_blocklog + XFS_NBBYLOG;\r\nmp->m_blkbb_log = sbp->sb_blocklog - BBSHIFT;\r\nmp->m_sectbb_log = sbp->sb_sectlog - BBSHIFT;\r\nmp->m_agno_log = xfs_highbit32(sbp->sb_agcount - 1) + 1;\r\nmp->m_agino_log = sbp->sb_inopblog + sbp->sb_agblklog;\r\nmp->m_blockmask = sbp->sb_blocksize - 1;\r\nmp->m_blockwsize = sbp->sb_blocksize >> XFS_WORDLOG;\r\nmp->m_blockwmask = mp->m_blockwsize - 1;\r\nmp->m_alloc_mxr[0] = xfs_allocbt_maxrecs(mp, sbp->sb_blocksize, 1);\r\nmp->m_alloc_mxr[1] = xfs_allocbt_maxrecs(mp, sbp->sb_blocksize, 0);\r\nmp->m_alloc_mnr[0] = mp->m_alloc_mxr[0] / 2;\r\nmp->m_alloc_mnr[1] = mp->m_alloc_mxr[1] / 2;\r\nmp->m_inobt_mxr[0] = xfs_inobt_maxrecs(mp, sbp->sb_blocksize, 1);\r\nmp->m_inobt_mxr[1] = xfs_inobt_maxrecs(mp, sbp->sb_blocksize, 0);\r\nmp->m_inobt_mnr[0] = mp->m_inobt_mxr[0] / 2;\r\nmp->m_inobt_mnr[1] = mp->m_inobt_mxr[1] / 2;\r\nmp->m_bmap_dmxr[0] = xfs_bmbt_maxrecs(mp, sbp->sb_blocksize, 1);\r\nmp->m_bmap_dmxr[1] = xfs_bmbt_maxrecs(mp, sbp->sb_blocksize, 0);\r\nmp->m_bmap_dmnr[0] = mp->m_bmap_dmxr[0] / 2;\r\nmp->m_bmap_dmnr[1] = mp->m_bmap_dmxr[1] / 2;\r\nmp->m_bsize = XFS_FSB_TO_BB(mp, 1);\r\nmp->m_ialloc_inos = (int)MAX((__uint16_t)XFS_INODES_PER_CHUNK,\r\nsbp->sb_inopblock);\r\nmp->m_ialloc_blks = mp->m_ialloc_inos >> sbp->sb_inopblog;\r\n}\r\nSTATIC int\r\nxfs_initialize_perag_data(xfs_mount_t *mp, xfs_agnumber_t agcount)\r\n{\r\nxfs_agnumber_t index;\r\nxfs_perag_t *pag;\r\nxfs_sb_t *sbp = &mp->m_sb;\r\nuint64_t ifree = 0;\r\nuint64_t ialloc = 0;\r\nuint64_t bfree = 0;\r\nuint64_t bfreelst = 0;\r\nuint64_t btree = 0;\r\nint error;\r\nfor (index = 0; index < agcount; index++) {\r\nerror = xfs_alloc_pagf_init(mp, NULL, index, 0);\r\nif (error)\r\nreturn error;\r\nerror = xfs_ialloc_pagi_init(mp, NULL, index);\r\nif (error)\r\nreturn error;\r\npag = xfs_perag_get(mp, index);\r\nifree += pag->pagi_freecount;\r\nialloc += pag->pagi_count;\r\nbfree += pag->pagf_freeblks;\r\nbfreelst += pag->pagf_flcount;\r\nbtree += pag->pagf_btreeblks;\r\nxfs_perag_put(pag);\r\n}\r\nspin_lock(&mp->m_sb_lock);\r\nsbp->sb_ifree = ifree;\r\nsbp->sb_icount = ialloc;\r\nsbp->sb_fdblocks = bfree + bfreelst + btree;\r\nspin_unlock(&mp->m_sb_lock);\r\nxfs_icsb_reinit_counters(mp);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_update_alignment(xfs_mount_t *mp)\r\n{\r\nxfs_sb_t *sbp = &(mp->m_sb);\r\nif (mp->m_dalign) {\r\nif ((BBTOB(mp->m_dalign) & mp->m_blockmask) ||\r\n(BBTOB(mp->m_swidth) & mp->m_blockmask)) {\r\nif (mp->m_flags & XFS_MOUNT_RETERR) {\r\nxfs_warn(mp, "alignment check failed: "\r\n"(sunit/swidth vs. blocksize)");\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nmp->m_dalign = mp->m_swidth = 0;\r\n} else {\r\nmp->m_dalign = XFS_BB_TO_FSBT(mp, mp->m_dalign);\r\nif (mp->m_dalign && (sbp->sb_agblocks % mp->m_dalign)) {\r\nif (mp->m_flags & XFS_MOUNT_RETERR) {\r\nxfs_warn(mp, "alignment check failed: "\r\n"(sunit/swidth vs. ag size)");\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nxfs_warn(mp,\r\n"stripe alignment turned off: sunit(%d)/swidth(%d) "\r\n"incompatible with agsize(%d)",\r\nmp->m_dalign, mp->m_swidth,\r\nsbp->sb_agblocks);\r\nmp->m_dalign = 0;\r\nmp->m_swidth = 0;\r\n} else if (mp->m_dalign) {\r\nmp->m_swidth = XFS_BB_TO_FSBT(mp, mp->m_swidth);\r\n} else {\r\nif (mp->m_flags & XFS_MOUNT_RETERR) {\r\nxfs_warn(mp, "alignment check failed: "\r\n"sunit(%d) less than bsize(%d)",\r\nmp->m_dalign,\r\nmp->m_blockmask +1);\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nmp->m_swidth = 0;\r\n}\r\n}\r\nif (xfs_sb_version_hasdalign(sbp)) {\r\nif (sbp->sb_unit != mp->m_dalign) {\r\nsbp->sb_unit = mp->m_dalign;\r\nmp->m_update_flags |= XFS_SB_UNIT;\r\n}\r\nif (sbp->sb_width != mp->m_swidth) {\r\nsbp->sb_width = mp->m_swidth;\r\nmp->m_update_flags |= XFS_SB_WIDTH;\r\n}\r\n}\r\n} else if ((mp->m_flags & XFS_MOUNT_NOALIGN) != XFS_MOUNT_NOALIGN &&\r\nxfs_sb_version_hasdalign(&mp->m_sb)) {\r\nmp->m_dalign = sbp->sb_unit;\r\nmp->m_swidth = sbp->sb_width;\r\n}\r\nreturn 0;\r\n}\r\nSTATIC void\r\nxfs_set_maxicount(xfs_mount_t *mp)\r\n{\r\nxfs_sb_t *sbp = &(mp->m_sb);\r\n__uint64_t icount;\r\nif (sbp->sb_imax_pct) {\r\nicount = sbp->sb_dblocks * sbp->sb_imax_pct;\r\ndo_div(icount, 100);\r\ndo_div(icount, mp->m_ialloc_blks);\r\nmp->m_maxicount = (icount * mp->m_ialloc_blks) <<\r\nsbp->sb_inopblog;\r\n} else {\r\nmp->m_maxicount = 0;\r\n}\r\n}\r\nSTATIC void\r\nxfs_set_rw_sizes(xfs_mount_t *mp)\r\n{\r\nxfs_sb_t *sbp = &(mp->m_sb);\r\nint readio_log, writeio_log;\r\nif (!(mp->m_flags & XFS_MOUNT_DFLT_IOSIZE)) {\r\nif (mp->m_flags & XFS_MOUNT_WSYNC) {\r\nreadio_log = XFS_WSYNC_READIO_LOG;\r\nwriteio_log = XFS_WSYNC_WRITEIO_LOG;\r\n} else {\r\nreadio_log = XFS_READIO_LOG_LARGE;\r\nwriteio_log = XFS_WRITEIO_LOG_LARGE;\r\n}\r\n} else {\r\nreadio_log = mp->m_readio_log;\r\nwriteio_log = mp->m_writeio_log;\r\n}\r\nif (sbp->sb_blocklog > readio_log) {\r\nmp->m_readio_log = sbp->sb_blocklog;\r\n} else {\r\nmp->m_readio_log = readio_log;\r\n}\r\nmp->m_readio_blocks = 1 << (mp->m_readio_log - sbp->sb_blocklog);\r\nif (sbp->sb_blocklog > writeio_log) {\r\nmp->m_writeio_log = sbp->sb_blocklog;\r\n} else {\r\nmp->m_writeio_log = writeio_log;\r\n}\r\nmp->m_writeio_blocks = 1 << (mp->m_writeio_log - sbp->sb_blocklog);\r\n}\r\nvoid\r\nxfs_set_low_space_thresholds(\r\nstruct xfs_mount *mp)\r\n{\r\nint i;\r\nfor (i = 0; i < XFS_LOWSP_MAX; i++) {\r\n__uint64_t space = mp->m_sb.sb_dblocks;\r\ndo_div(space, 100);\r\nmp->m_low_space[i] = space * (i + 1);\r\n}\r\n}\r\nSTATIC void\r\nxfs_set_inoalignment(xfs_mount_t *mp)\r\n{\r\nif (xfs_sb_version_hasalign(&mp->m_sb) &&\r\nmp->m_sb.sb_inoalignmt >=\r\nXFS_B_TO_FSBT(mp, mp->m_inode_cluster_size))\r\nmp->m_inoalign_mask = mp->m_sb.sb_inoalignmt - 1;\r\nelse\r\nmp->m_inoalign_mask = 0;\r\nif (mp->m_dalign && mp->m_inoalign_mask &&\r\n!(mp->m_dalign & mp->m_inoalign_mask))\r\nmp->m_sinoalign = mp->m_dalign;\r\nelse\r\nmp->m_sinoalign = 0;\r\n}\r\nSTATIC int\r\nxfs_check_sizes(xfs_mount_t *mp)\r\n{\r\nxfs_buf_t *bp;\r\nxfs_daddr_t d;\r\nd = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks);\r\nif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_dblocks) {\r\nxfs_warn(mp, "filesystem size mismatch detected");\r\nreturn XFS_ERROR(EFBIG);\r\n}\r\nbp = xfs_buf_read_uncached(mp, mp->m_ddev_targp,\r\nd - XFS_FSS_TO_BB(mp, 1),\r\nBBTOB(XFS_FSS_TO_BB(mp, 1)), 0);\r\nif (!bp) {\r\nxfs_warn(mp, "last sector read failed");\r\nreturn EIO;\r\n}\r\nxfs_buf_relse(bp);\r\nif (mp->m_logdev_targp != mp->m_ddev_targp) {\r\nd = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_logblocks);\r\nif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_logblocks) {\r\nxfs_warn(mp, "log size mismatch detected");\r\nreturn XFS_ERROR(EFBIG);\r\n}\r\nbp = xfs_buf_read_uncached(mp, mp->m_logdev_targp,\r\nd - XFS_FSB_TO_BB(mp, 1),\r\nXFS_FSB_TO_B(mp, 1), 0);\r\nif (!bp) {\r\nxfs_warn(mp, "log device read failed");\r\nreturn EIO;\r\n}\r\nxfs_buf_relse(bp);\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxfs_mount_reset_sbqflags(\r\nstruct xfs_mount *mp)\r\n{\r\nint error;\r\nstruct xfs_trans *tp;\r\nmp->m_qflags = 0;\r\nif (mp->m_sb.sb_qflags == 0)\r\nreturn 0;\r\nspin_lock(&mp->m_sb_lock);\r\nmp->m_sb.sb_qflags = 0;\r\nspin_unlock(&mp->m_sb_lock);\r\nif (mp->m_flags & XFS_MOUNT_RDONLY)\r\nreturn 0;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_QM_SBCHANGE);\r\nerror = xfs_trans_reserve(tp, 0, mp->m_sb.sb_sectsize + 128, 0, 0,\r\nXFS_DEFAULT_LOG_COUNT);\r\nif (error) {\r\nxfs_trans_cancel(tp, 0);\r\nxfs_alert(mp, "%s: Superblock update failed!", __func__);\r\nreturn error;\r\n}\r\nxfs_mod_sb(tp, XFS_SB_QFLAGS);\r\nreturn xfs_trans_commit(tp, 0);\r\n}\r\n__uint64_t\r\nxfs_default_resblks(xfs_mount_t *mp)\r\n{\r\n__uint64_t resblks;\r\nresblks = mp->m_sb.sb_dblocks;\r\ndo_div(resblks, 20);\r\nresblks = min_t(__uint64_t, resblks, 8192);\r\nreturn resblks;\r\n}\r\nint\r\nxfs_mountfs(\r\nxfs_mount_t *mp)\r\n{\r\nxfs_sb_t *sbp = &(mp->m_sb);\r\nxfs_inode_t *rip;\r\n__uint64_t resblks;\r\nuint quotamount = 0;\r\nuint quotaflags = 0;\r\nint error = 0;\r\nxfs_mount_common(mp, sbp);\r\nif (xfs_sb_has_mismatched_features2(sbp)) {\r\nxfs_warn(mp, "correcting sb_features alignment problem");\r\nsbp->sb_features2 |= sbp->sb_bad_features2;\r\nsbp->sb_bad_features2 = sbp->sb_features2;\r\nmp->m_update_flags |= XFS_SB_FEATURES2 | XFS_SB_BAD_FEATURES2;\r\nif (xfs_sb_version_hasattr2(&mp->m_sb) &&\r\n!(mp->m_flags & XFS_MOUNT_NOATTR2))\r\nmp->m_flags |= XFS_MOUNT_ATTR2;\r\n}\r\nif (xfs_sb_version_hasattr2(&mp->m_sb) &&\r\n(mp->m_flags & XFS_MOUNT_NOATTR2)) {\r\nxfs_sb_version_removeattr2(&mp->m_sb);\r\nmp->m_update_flags |= XFS_SB_FEATURES2;\r\nif (!sbp->sb_features2)\r\nmp->m_update_flags |= XFS_SB_VERSIONNUM;\r\n}\r\nerror = xfs_update_alignment(mp);\r\nif (error)\r\ngoto out;\r\nxfs_alloc_compute_maxlevels(mp);\r\nxfs_bmap_compute_maxlevels(mp, XFS_DATA_FORK);\r\nxfs_bmap_compute_maxlevels(mp, XFS_ATTR_FORK);\r\nxfs_ialloc_compute_maxlevels(mp);\r\nxfs_set_maxicount(mp);\r\nmp->m_maxioffset = xfs_max_file_offset(sbp->sb_blocklog);\r\nerror = xfs_uuid_mount(mp);\r\nif (error)\r\ngoto out;\r\nxfs_set_rw_sizes(mp);\r\nxfs_set_low_space_thresholds(mp);\r\nmp->m_inode_cluster_size = XFS_INODE_BIG_CLUSTER_SIZE;\r\nxfs_set_inoalignment(mp);\r\nerror = xfs_check_sizes(mp);\r\nif (error)\r\ngoto out_remove_uuid;\r\nerror = xfs_rtmount_init(mp);\r\nif (error) {\r\nxfs_warn(mp, "RT mount failed");\r\ngoto out_remove_uuid;\r\n}\r\nuuid_getnodeuniq(&sbp->sb_uuid, mp->m_fixedfsid);\r\nmp->m_dmevmask = 0;\r\nxfs_dir_mount(mp);\r\nmp->m_attr_magicpct = (mp->m_sb.sb_blocksize * 37) / 100;\r\nxfs_trans_init(mp);\r\nspin_lock_init(&mp->m_perag_lock);\r\nINIT_RADIX_TREE(&mp->m_perag_tree, GFP_ATOMIC);\r\nerror = xfs_initialize_perag(mp, sbp->sb_agcount, &mp->m_maxagi);\r\nif (error) {\r\nxfs_warn(mp, "Failed per-ag init: %d", error);\r\ngoto out_remove_uuid;\r\n}\r\nif (!sbp->sb_logblocks) {\r\nxfs_warn(mp, "no log defined");\r\nXFS_ERROR_REPORT("xfs_mountfs", XFS_ERRLEVEL_LOW, mp);\r\nerror = XFS_ERROR(EFSCORRUPTED);\r\ngoto out_free_perag;\r\n}\r\nerror = xfs_log_mount(mp, mp->m_logdev_targp,\r\nXFS_FSB_TO_DADDR(mp, sbp->sb_logstart),\r\nXFS_FSB_TO_BB(mp, sbp->sb_logblocks));\r\nif (error) {\r\nxfs_warn(mp, "log mount failed");\r\ngoto out_free_perag;\r\n}\r\nif (xfs_sb_version_haslazysbcount(&mp->m_sb) &&\r\n!XFS_LAST_UNMOUNT_WAS_CLEAN(mp) &&\r\n!mp->m_sb.sb_inprogress) {\r\nerror = xfs_initialize_perag_data(mp, sbp->sb_agcount);\r\nif (error)\r\ngoto out_free_perag;\r\n}\r\nerror = xfs_iget(mp, NULL, sbp->sb_rootino, 0, XFS_ILOCK_EXCL, &rip);\r\nif (error) {\r\nxfs_warn(mp, "failed to read root inode");\r\ngoto out_log_dealloc;\r\n}\r\nASSERT(rip != NULL);\r\nif (unlikely(!S_ISDIR(rip->i_d.di_mode))) {\r\nxfs_warn(mp, "corrupted root inode %llu: not a directory",\r\n(unsigned long long)rip->i_ino);\r\nxfs_iunlock(rip, XFS_ILOCK_EXCL);\r\nXFS_ERROR_REPORT("xfs_mountfs_int(2)", XFS_ERRLEVEL_LOW,\r\nmp);\r\nerror = XFS_ERROR(EFSCORRUPTED);\r\ngoto out_rele_rip;\r\n}\r\nmp->m_rootip = rip;\r\nxfs_iunlock(rip, XFS_ILOCK_EXCL);\r\nerror = xfs_rtmount_inodes(mp);\r\nif (error) {\r\nxfs_warn(mp, "failed to read RT inodes");\r\ngoto out_rele_rip;\r\n}\r\nif (mp->m_update_flags && !(mp->m_flags & XFS_MOUNT_RDONLY)) {\r\nerror = xfs_mount_log_sb(mp, mp->m_update_flags);\r\nif (error) {\r\nxfs_warn(mp, "failed to write sb changes");\r\ngoto out_rtunmount;\r\n}\r\n}\r\nif (XFS_IS_QUOTA_RUNNING(mp)) {\r\nerror = xfs_qm_newmount(mp, &quotamount, &quotaflags);\r\nif (error)\r\ngoto out_rtunmount;\r\n} else {\r\nASSERT(!XFS_IS_QUOTA_ON(mp));\r\nif (mp->m_sb.sb_qflags & XFS_ALL_QUOTA_ACCT) {\r\nxfs_notice(mp, "resetting quota flags");\r\nerror = xfs_mount_reset_sbqflags(mp);\r\nif (error)\r\nreturn error;\r\n}\r\n}\r\nerror = xfs_log_mount_finish(mp);\r\nif (error) {\r\nxfs_warn(mp, "log mount finish failed");\r\ngoto out_rtunmount;\r\n}\r\nif (quotamount) {\r\nASSERT(mp->m_qflags == 0);\r\nmp->m_qflags = quotaflags;\r\nxfs_qm_mount_quotas(mp);\r\n}\r\nif (!(mp->m_flags & XFS_MOUNT_RDONLY)) {\r\nresblks = xfs_default_resblks(mp);\r\nerror = xfs_reserve_blocks(mp, &resblks, NULL);\r\nif (error)\r\nxfs_warn(mp,\r\n"Unable to allocate reserve blocks. Continuing without reserve pool.");\r\n}\r\nreturn 0;\r\nout_rtunmount:\r\nxfs_rtunmount_inodes(mp);\r\nout_rele_rip:\r\nIRELE(rip);\r\nout_log_dealloc:\r\nxfs_log_unmount(mp);\r\nout_free_perag:\r\nxfs_free_perag(mp);\r\nout_remove_uuid:\r\nxfs_uuid_unmount(mp);\r\nout:\r\nreturn error;\r\n}\r\nvoid\r\nxfs_unmountfs(\r\nstruct xfs_mount *mp)\r\n{\r\n__uint64_t resblks;\r\nint error;\r\nxfs_qm_unmount_quotas(mp);\r\nxfs_rtunmount_inodes(mp);\r\nIRELE(mp->m_rootip);\r\nxfs_log_force(mp, XFS_LOG_SYNC);\r\nxfs_reclaim_inodes(mp, 0);\r\nxfs_flush_buftarg(mp->m_ddev_targp, 1);\r\nxfs_reclaim_inodes(mp, SYNC_WAIT);\r\nxfs_qm_unmount(mp);\r\nxfs_log_force(mp, XFS_LOG_SYNC);\r\nresblks = 0;\r\nerror = xfs_reserve_blocks(mp, &resblks, NULL);\r\nif (error)\r\nxfs_warn(mp, "Unable to free reserved block pool. "\r\n"Freespace may not be correct on next mount.");\r\nerror = xfs_log_sbcount(mp);\r\nif (error)\r\nxfs_warn(mp, "Unable to update superblock counters. "\r\n"Freespace may not be correct on next mount.");\r\nxfs_unmountfs_writesb(mp);\r\nerror = xfs_flush_buftarg(mp->m_ddev_targp, 1);\r\nif (error)\r\nxfs_warn(mp, "%d busy buffers during unmount.", error);\r\nxfs_wait_buftarg(mp->m_ddev_targp);\r\nxfs_log_unmount_write(mp);\r\nxfs_log_unmount(mp);\r\nxfs_uuid_unmount(mp);\r\n#if defined(DEBUG)\r\nxfs_errortag_clearall(mp, 0);\r\n#endif\r\nxfs_free_perag(mp);\r\n}\r\nint\r\nxfs_fs_writable(xfs_mount_t *mp)\r\n{\r\nreturn !(xfs_test_for_freeze(mp) || XFS_FORCED_SHUTDOWN(mp) ||\r\n(mp->m_flags & XFS_MOUNT_RDONLY));\r\n}\r\nint\r\nxfs_log_sbcount(xfs_mount_t *mp)\r\n{\r\nxfs_trans_t *tp;\r\nint error;\r\nif (!xfs_fs_writable(mp))\r\nreturn 0;\r\nxfs_icsb_sync_counters(mp, 0);\r\nif (!xfs_sb_version_haslazysbcount(&mp->m_sb))\r\nreturn 0;\r\ntp = _xfs_trans_alloc(mp, XFS_TRANS_SB_COUNT, KM_SLEEP);\r\nerror = xfs_trans_reserve(tp, 0, mp->m_sb.sb_sectsize + 128, 0, 0,\r\nXFS_DEFAULT_LOG_COUNT);\r\nif (error) {\r\nxfs_trans_cancel(tp, 0);\r\nreturn error;\r\n}\r\nxfs_mod_sb(tp, XFS_SB_IFREE | XFS_SB_ICOUNT | XFS_SB_FDBLOCKS);\r\nxfs_trans_set_sync(tp);\r\nerror = xfs_trans_commit(tp, 0);\r\nreturn error;\r\n}\r\nint\r\nxfs_unmountfs_writesb(xfs_mount_t *mp)\r\n{\r\nxfs_buf_t *sbp;\r\nint error = 0;\r\nif (!((mp->m_flags & XFS_MOUNT_RDONLY) ||\r\nXFS_FORCED_SHUTDOWN(mp))) {\r\nsbp = xfs_getsb(mp, 0);\r\nXFS_BUF_UNDONE(sbp);\r\nXFS_BUF_UNREAD(sbp);\r\nxfs_buf_delwri_dequeue(sbp);\r\nXFS_BUF_WRITE(sbp);\r\nXFS_BUF_UNASYNC(sbp);\r\nASSERT(sbp->b_target == mp->m_ddev_targp);\r\nxfsbdstrat(mp, sbp);\r\nerror = xfs_buf_iowait(sbp);\r\nif (error)\r\nxfs_buf_ioerror_alert(sbp, __func__);\r\nxfs_buf_relse(sbp);\r\n}\r\nreturn error;\r\n}\r\nvoid\r\nxfs_mod_sb(xfs_trans_t *tp, __int64_t fields)\r\n{\r\nxfs_buf_t *bp;\r\nint first;\r\nint last;\r\nxfs_mount_t *mp;\r\nxfs_sb_field_t f;\r\nASSERT(fields);\r\nif (!fields)\r\nreturn;\r\nmp = tp->t_mountp;\r\nbp = xfs_trans_getsb(tp, mp, 0);\r\nfirst = sizeof(xfs_sb_t);\r\nlast = 0;\r\nxfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb, fields);\r\nf = (xfs_sb_field_t)xfs_highbit64((__uint64_t)fields);\r\nASSERT((1LL << f) & XFS_SB_MOD_BITS);\r\nlast = xfs_sb_info[f + 1].offset - 1;\r\nf = (xfs_sb_field_t)xfs_lowbit64((__uint64_t)fields);\r\nASSERT((1LL << f) & XFS_SB_MOD_BITS);\r\nfirst = xfs_sb_info[f].offset;\r\nxfs_trans_log_buf(tp, bp, first, last);\r\n}\r\nSTATIC int\r\nxfs_mod_incore_sb_unlocked(\r\nxfs_mount_t *mp,\r\nxfs_sb_field_t field,\r\nint64_t delta,\r\nint rsvd)\r\n{\r\nint scounter;\r\nlong long lcounter;\r\nlong long res_used, rem;\r\nswitch (field) {\r\ncase XFS_SBS_ICOUNT:\r\nlcounter = (long long)mp->m_sb.sb_icount;\r\nlcounter += delta;\r\nif (lcounter < 0) {\r\nASSERT(0);\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nmp->m_sb.sb_icount = lcounter;\r\nreturn 0;\r\ncase XFS_SBS_IFREE:\r\nlcounter = (long long)mp->m_sb.sb_ifree;\r\nlcounter += delta;\r\nif (lcounter < 0) {\r\nASSERT(0);\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nmp->m_sb.sb_ifree = lcounter;\r\nreturn 0;\r\ncase XFS_SBS_FDBLOCKS:\r\nlcounter = (long long)\r\nmp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\r\nres_used = (long long)(mp->m_resblks - mp->m_resblks_avail);\r\nif (delta > 0) {\r\nif (res_used > delta) {\r\nmp->m_resblks_avail += delta;\r\n} else {\r\nrem = delta - res_used;\r\nmp->m_resblks_avail = mp->m_resblks;\r\nlcounter += rem;\r\n}\r\n} else {\r\nlcounter += delta;\r\nif (lcounter >= 0) {\r\nmp->m_sb.sb_fdblocks = lcounter +\r\nXFS_ALLOC_SET_ASIDE(mp);\r\nreturn 0;\r\n}\r\nif (!rsvd)\r\nreturn XFS_ERROR(ENOSPC);\r\nlcounter = (long long)mp->m_resblks_avail + delta;\r\nif (lcounter >= 0) {\r\nmp->m_resblks_avail = lcounter;\r\nreturn 0;\r\n}\r\nprintk_once(KERN_WARNING\r\n"Filesystem \"%s\": reserve blocks depleted! "\r\n"Consider increasing reserve pool size.",\r\nmp->m_fsname);\r\nreturn XFS_ERROR(ENOSPC);\r\n}\r\nmp->m_sb.sb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\r\nreturn 0;\r\ncase XFS_SBS_FREXTENTS:\r\nlcounter = (long long)mp->m_sb.sb_frextents;\r\nlcounter += delta;\r\nif (lcounter < 0) {\r\nreturn XFS_ERROR(ENOSPC);\r\n}\r\nmp->m_sb.sb_frextents = lcounter;\r\nreturn 0;\r\ncase XFS_SBS_DBLOCKS:\r\nlcounter = (long long)mp->m_sb.sb_dblocks;\r\nlcounter += delta;\r\nif (lcounter < 0) {\r\nASSERT(0);\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nmp->m_sb.sb_dblocks = lcounter;\r\nreturn 0;\r\ncase XFS_SBS_AGCOUNT:\r\nscounter = mp->m_sb.sb_agcount;\r\nscounter += delta;\r\nif (scounter < 0) {\r\nASSERT(0);\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nmp->m_sb.sb_agcount = scounter;\r\nreturn 0;\r\ncase XFS_SBS_IMAX_PCT:\r\nscounter = mp->m_sb.sb_imax_pct;\r\nscounter += delta;\r\nif (scounter < 0) {\r\nASSERT(0);\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nmp->m_sb.sb_imax_pct = scounter;\r\nreturn 0;\r\ncase XFS_SBS_REXTSIZE:\r\nscounter = mp->m_sb.sb_rextsize;\r\nscounter += delta;\r\nif (scounter < 0) {\r\nASSERT(0);\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nmp->m_sb.sb_rextsize = scounter;\r\nreturn 0;\r\ncase XFS_SBS_RBMBLOCKS:\r\nscounter = mp->m_sb.sb_rbmblocks;\r\nscounter += delta;\r\nif (scounter < 0) {\r\nASSERT(0);\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nmp->m_sb.sb_rbmblocks = scounter;\r\nreturn 0;\r\ncase XFS_SBS_RBLOCKS:\r\nlcounter = (long long)mp->m_sb.sb_rblocks;\r\nlcounter += delta;\r\nif (lcounter < 0) {\r\nASSERT(0);\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nmp->m_sb.sb_rblocks = lcounter;\r\nreturn 0;\r\ncase XFS_SBS_REXTENTS:\r\nlcounter = (long long)mp->m_sb.sb_rextents;\r\nlcounter += delta;\r\nif (lcounter < 0) {\r\nASSERT(0);\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nmp->m_sb.sb_rextents = lcounter;\r\nreturn 0;\r\ncase XFS_SBS_REXTSLOG:\r\nscounter = mp->m_sb.sb_rextslog;\r\nscounter += delta;\r\nif (scounter < 0) {\r\nASSERT(0);\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nmp->m_sb.sb_rextslog = scounter;\r\nreturn 0;\r\ndefault:\r\nASSERT(0);\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\n}\r\nint\r\nxfs_mod_incore_sb(\r\nstruct xfs_mount *mp,\r\nxfs_sb_field_t field,\r\nint64_t delta,\r\nint rsvd)\r\n{\r\nint status;\r\n#ifdef HAVE_PERCPU_SB\r\nASSERT(field < XFS_SBS_ICOUNT || field > XFS_SBS_FDBLOCKS);\r\n#endif\r\nspin_lock(&mp->m_sb_lock);\r\nstatus = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\r\nspin_unlock(&mp->m_sb_lock);\r\nreturn status;\r\n}\r\nint\r\nxfs_mod_incore_sb_batch(\r\nstruct xfs_mount *mp,\r\nxfs_mod_sb_t *msb,\r\nuint nmsb,\r\nint rsvd)\r\n{\r\nxfs_mod_sb_t *msbp;\r\nint error = 0;\r\nspin_lock(&mp->m_sb_lock);\r\nfor (msbp = msb; msbp < (msb + nmsb); msbp++) {\r\nASSERT(msbp->msb_field < XFS_SBS_ICOUNT ||\r\nmsbp->msb_field > XFS_SBS_FDBLOCKS);\r\nerror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\r\nmsbp->msb_delta, rsvd);\r\nif (error)\r\ngoto unwind;\r\n}\r\nspin_unlock(&mp->m_sb_lock);\r\nreturn 0;\r\nunwind:\r\nwhile (--msbp >= msb) {\r\nerror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\r\n-msbp->msb_delta, rsvd);\r\nASSERT(error == 0);\r\n}\r\nspin_unlock(&mp->m_sb_lock);\r\nreturn error;\r\n}\r\nstruct xfs_buf *\r\nxfs_getsb(\r\nstruct xfs_mount *mp,\r\nint flags)\r\n{\r\nstruct xfs_buf *bp = mp->m_sb_bp;\r\nif (!xfs_buf_trylock(bp)) {\r\nif (flags & XBF_TRYLOCK)\r\nreturn NULL;\r\nxfs_buf_lock(bp);\r\n}\r\nxfs_buf_hold(bp);\r\nASSERT(XFS_BUF_ISDONE(bp));\r\nreturn bp;\r\n}\r\nvoid\r\nxfs_freesb(\r\nstruct xfs_mount *mp)\r\n{\r\nstruct xfs_buf *bp = mp->m_sb_bp;\r\nxfs_buf_lock(bp);\r\nmp->m_sb_bp = NULL;\r\nxfs_buf_relse(bp);\r\n}\r\nint\r\nxfs_mount_log_sb(\r\nxfs_mount_t *mp,\r\n__int64_t fields)\r\n{\r\nxfs_trans_t *tp;\r\nint error;\r\nASSERT(fields & (XFS_SB_UNIT | XFS_SB_WIDTH | XFS_SB_UUID |\r\nXFS_SB_FEATURES2 | XFS_SB_BAD_FEATURES2 |\r\nXFS_SB_VERSIONNUM));\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_SB_UNIT);\r\nerror = xfs_trans_reserve(tp, 0, mp->m_sb.sb_sectsize + 128, 0, 0,\r\nXFS_DEFAULT_LOG_COUNT);\r\nif (error) {\r\nxfs_trans_cancel(tp, 0);\r\nreturn error;\r\n}\r\nxfs_mod_sb(tp, fields);\r\nerror = xfs_trans_commit(tp, 0);\r\nreturn error;\r\n}\r\nint\r\nxfs_dev_is_read_only(\r\nstruct xfs_mount *mp,\r\nchar *message)\r\n{\r\nif (xfs_readonly_buftarg(mp->m_ddev_targp) ||\r\nxfs_readonly_buftarg(mp->m_logdev_targp) ||\r\n(mp->m_rtdev_targp && xfs_readonly_buftarg(mp->m_rtdev_targp))) {\r\nxfs_notice(mp, "%s required on read-only device.", message);\r\nxfs_notice(mp, "write access unavailable, cannot proceed.");\r\nreturn EROFS;\r\n}\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_icsb_cpu_notify(\r\nstruct notifier_block *nfb,\r\nunsigned long action,\r\nvoid *hcpu)\r\n{\r\nxfs_icsb_cnts_t *cntp;\r\nxfs_mount_t *mp;\r\nmp = (xfs_mount_t *)container_of(nfb, xfs_mount_t, m_icsb_notifier);\r\ncntp = (xfs_icsb_cnts_t *)\r\nper_cpu_ptr(mp->m_sb_cnts, (unsigned long)hcpu);\r\nswitch (action) {\r\ncase CPU_UP_PREPARE:\r\ncase CPU_UP_PREPARE_FROZEN:\r\nmemset(cntp, 0, sizeof(xfs_icsb_cnts_t));\r\nbreak;\r\ncase CPU_ONLINE:\r\ncase CPU_ONLINE_FROZEN:\r\nxfs_icsb_lock(mp);\r\nxfs_icsb_balance_counter(mp, XFS_SBS_ICOUNT, 0);\r\nxfs_icsb_balance_counter(mp, XFS_SBS_IFREE, 0);\r\nxfs_icsb_balance_counter(mp, XFS_SBS_FDBLOCKS, 0);\r\nxfs_icsb_unlock(mp);\r\nbreak;\r\ncase CPU_DEAD:\r\ncase CPU_DEAD_FROZEN:\r\nxfs_icsb_lock(mp);\r\nspin_lock(&mp->m_sb_lock);\r\nxfs_icsb_disable_counter(mp, XFS_SBS_ICOUNT);\r\nxfs_icsb_disable_counter(mp, XFS_SBS_IFREE);\r\nxfs_icsb_disable_counter(mp, XFS_SBS_FDBLOCKS);\r\nmp->m_sb.sb_icount += cntp->icsb_icount;\r\nmp->m_sb.sb_ifree += cntp->icsb_ifree;\r\nmp->m_sb.sb_fdblocks += cntp->icsb_fdblocks;\r\nmemset(cntp, 0, sizeof(xfs_icsb_cnts_t));\r\nxfs_icsb_balance_counter_locked(mp, XFS_SBS_ICOUNT, 0);\r\nxfs_icsb_balance_counter_locked(mp, XFS_SBS_IFREE, 0);\r\nxfs_icsb_balance_counter_locked(mp, XFS_SBS_FDBLOCKS, 0);\r\nspin_unlock(&mp->m_sb_lock);\r\nxfs_icsb_unlock(mp);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nint\r\nxfs_icsb_init_counters(\r\nxfs_mount_t *mp)\r\n{\r\nxfs_icsb_cnts_t *cntp;\r\nint i;\r\nmp->m_sb_cnts = alloc_percpu(xfs_icsb_cnts_t);\r\nif (mp->m_sb_cnts == NULL)\r\nreturn -ENOMEM;\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nmp->m_icsb_notifier.notifier_call = xfs_icsb_cpu_notify;\r\nmp->m_icsb_notifier.priority = 0;\r\nregister_hotcpu_notifier(&mp->m_icsb_notifier);\r\n#endif\r\nfor_each_online_cpu(i) {\r\ncntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\r\nmemset(cntp, 0, sizeof(xfs_icsb_cnts_t));\r\n}\r\nmutex_init(&mp->m_icsb_mutex);\r\nmp->m_icsb_counters = -1;\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_icsb_reinit_counters(\r\nxfs_mount_t *mp)\r\n{\r\nxfs_icsb_lock(mp);\r\nmp->m_icsb_counters = -1;\r\nxfs_icsb_balance_counter(mp, XFS_SBS_ICOUNT, 0);\r\nxfs_icsb_balance_counter(mp, XFS_SBS_IFREE, 0);\r\nxfs_icsb_balance_counter(mp, XFS_SBS_FDBLOCKS, 0);\r\nxfs_icsb_unlock(mp);\r\n}\r\nvoid\r\nxfs_icsb_destroy_counters(\r\nxfs_mount_t *mp)\r\n{\r\nif (mp->m_sb_cnts) {\r\nunregister_hotcpu_notifier(&mp->m_icsb_notifier);\r\nfree_percpu(mp->m_sb_cnts);\r\n}\r\nmutex_destroy(&mp->m_icsb_mutex);\r\n}\r\nSTATIC void\r\nxfs_icsb_lock_cntr(\r\nxfs_icsb_cnts_t *icsbp)\r\n{\r\nwhile (test_and_set_bit(XFS_ICSB_FLAG_LOCK, &icsbp->icsb_flags)) {\r\nndelay(1000);\r\n}\r\n}\r\nSTATIC void\r\nxfs_icsb_unlock_cntr(\r\nxfs_icsb_cnts_t *icsbp)\r\n{\r\nclear_bit(XFS_ICSB_FLAG_LOCK, &icsbp->icsb_flags);\r\n}\r\nSTATIC void\r\nxfs_icsb_lock_all_counters(\r\nxfs_mount_t *mp)\r\n{\r\nxfs_icsb_cnts_t *cntp;\r\nint i;\r\nfor_each_online_cpu(i) {\r\ncntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\r\nxfs_icsb_lock_cntr(cntp);\r\n}\r\n}\r\nSTATIC void\r\nxfs_icsb_unlock_all_counters(\r\nxfs_mount_t *mp)\r\n{\r\nxfs_icsb_cnts_t *cntp;\r\nint i;\r\nfor_each_online_cpu(i) {\r\ncntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\r\nxfs_icsb_unlock_cntr(cntp);\r\n}\r\n}\r\nSTATIC void\r\nxfs_icsb_count(\r\nxfs_mount_t *mp,\r\nxfs_icsb_cnts_t *cnt,\r\nint flags)\r\n{\r\nxfs_icsb_cnts_t *cntp;\r\nint i;\r\nmemset(cnt, 0, sizeof(xfs_icsb_cnts_t));\r\nif (!(flags & XFS_ICSB_LAZY_COUNT))\r\nxfs_icsb_lock_all_counters(mp);\r\nfor_each_online_cpu(i) {\r\ncntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\r\ncnt->icsb_icount += cntp->icsb_icount;\r\ncnt->icsb_ifree += cntp->icsb_ifree;\r\ncnt->icsb_fdblocks += cntp->icsb_fdblocks;\r\n}\r\nif (!(flags & XFS_ICSB_LAZY_COUNT))\r\nxfs_icsb_unlock_all_counters(mp);\r\n}\r\nSTATIC int\r\nxfs_icsb_counter_disabled(\r\nxfs_mount_t *mp,\r\nxfs_sb_field_t field)\r\n{\r\nASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\r\nreturn test_bit(field, &mp->m_icsb_counters);\r\n}\r\nSTATIC void\r\nxfs_icsb_disable_counter(\r\nxfs_mount_t *mp,\r\nxfs_sb_field_t field)\r\n{\r\nxfs_icsb_cnts_t cnt;\r\nASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\r\nif (xfs_icsb_counter_disabled(mp, field))\r\nreturn;\r\nxfs_icsb_lock_all_counters(mp);\r\nif (!test_and_set_bit(field, &mp->m_icsb_counters)) {\r\nxfs_icsb_count(mp, &cnt, XFS_ICSB_LAZY_COUNT);\r\nswitch(field) {\r\ncase XFS_SBS_ICOUNT:\r\nmp->m_sb.sb_icount = cnt.icsb_icount;\r\nbreak;\r\ncase XFS_SBS_IFREE:\r\nmp->m_sb.sb_ifree = cnt.icsb_ifree;\r\nbreak;\r\ncase XFS_SBS_FDBLOCKS:\r\nmp->m_sb.sb_fdblocks = cnt.icsb_fdblocks;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nxfs_icsb_unlock_all_counters(mp);\r\n}\r\nSTATIC void\r\nxfs_icsb_enable_counter(\r\nxfs_mount_t *mp,\r\nxfs_sb_field_t field,\r\nuint64_t count,\r\nuint64_t resid)\r\n{\r\nxfs_icsb_cnts_t *cntp;\r\nint i;\r\nASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\r\nxfs_icsb_lock_all_counters(mp);\r\nfor_each_online_cpu(i) {\r\ncntp = per_cpu_ptr(mp->m_sb_cnts, i);\r\nswitch (field) {\r\ncase XFS_SBS_ICOUNT:\r\ncntp->icsb_icount = count + resid;\r\nbreak;\r\ncase XFS_SBS_IFREE:\r\ncntp->icsb_ifree = count + resid;\r\nbreak;\r\ncase XFS_SBS_FDBLOCKS:\r\ncntp->icsb_fdblocks = count + resid;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nresid = 0;\r\n}\r\nclear_bit(field, &mp->m_icsb_counters);\r\nxfs_icsb_unlock_all_counters(mp);\r\n}\r\nvoid\r\nxfs_icsb_sync_counters_locked(\r\nxfs_mount_t *mp,\r\nint flags)\r\n{\r\nxfs_icsb_cnts_t cnt;\r\nxfs_icsb_count(mp, &cnt, flags);\r\nif (!xfs_icsb_counter_disabled(mp, XFS_SBS_ICOUNT))\r\nmp->m_sb.sb_icount = cnt.icsb_icount;\r\nif (!xfs_icsb_counter_disabled(mp, XFS_SBS_IFREE))\r\nmp->m_sb.sb_ifree = cnt.icsb_ifree;\r\nif (!xfs_icsb_counter_disabled(mp, XFS_SBS_FDBLOCKS))\r\nmp->m_sb.sb_fdblocks = cnt.icsb_fdblocks;\r\n}\r\nvoid\r\nxfs_icsb_sync_counters(\r\nxfs_mount_t *mp,\r\nint flags)\r\n{\r\nspin_lock(&mp->m_sb_lock);\r\nxfs_icsb_sync_counters_locked(mp, flags);\r\nspin_unlock(&mp->m_sb_lock);\r\n}\r\nSTATIC void\r\nxfs_icsb_balance_counter_locked(\r\nxfs_mount_t *mp,\r\nxfs_sb_field_t field,\r\nint min_per_cpu)\r\n{\r\nuint64_t count, resid;\r\nint weight = num_online_cpus();\r\nuint64_t min = (uint64_t)min_per_cpu;\r\nxfs_icsb_disable_counter(mp, field);\r\nswitch (field) {\r\ncase XFS_SBS_ICOUNT:\r\ncount = mp->m_sb.sb_icount;\r\nresid = do_div(count, weight);\r\nif (count < max(min, XFS_ICSB_INO_CNTR_REENABLE))\r\nreturn;\r\nbreak;\r\ncase XFS_SBS_IFREE:\r\ncount = mp->m_sb.sb_ifree;\r\nresid = do_div(count, weight);\r\nif (count < max(min, XFS_ICSB_INO_CNTR_REENABLE))\r\nreturn;\r\nbreak;\r\ncase XFS_SBS_FDBLOCKS:\r\ncount = mp->m_sb.sb_fdblocks;\r\nresid = do_div(count, weight);\r\nif (count < max(min, XFS_ICSB_FDBLK_CNTR_REENABLE(mp)))\r\nreturn;\r\nbreak;\r\ndefault:\r\nBUG();\r\ncount = resid = 0;\r\nbreak;\r\n}\r\nxfs_icsb_enable_counter(mp, field, count, resid);\r\n}\r\nSTATIC void\r\nxfs_icsb_balance_counter(\r\nxfs_mount_t *mp,\r\nxfs_sb_field_t fields,\r\nint min_per_cpu)\r\n{\r\nspin_lock(&mp->m_sb_lock);\r\nxfs_icsb_balance_counter_locked(mp, fields, min_per_cpu);\r\nspin_unlock(&mp->m_sb_lock);\r\n}\r\nint\r\nxfs_icsb_modify_counters(\r\nxfs_mount_t *mp,\r\nxfs_sb_field_t field,\r\nint64_t delta,\r\nint rsvd)\r\n{\r\nxfs_icsb_cnts_t *icsbp;\r\nlong long lcounter;\r\nint ret = 0;\r\nmight_sleep();\r\nagain:\r\npreempt_disable();\r\nicsbp = this_cpu_ptr(mp->m_sb_cnts);\r\nif (unlikely(xfs_icsb_counter_disabled(mp, field)))\r\ngoto slow_path;\r\nxfs_icsb_lock_cntr(icsbp);\r\nif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\r\nxfs_icsb_unlock_cntr(icsbp);\r\ngoto slow_path;\r\n}\r\nswitch (field) {\r\ncase XFS_SBS_ICOUNT:\r\nlcounter = icsbp->icsb_icount;\r\nlcounter += delta;\r\nif (unlikely(lcounter < 0))\r\ngoto balance_counter;\r\nicsbp->icsb_icount = lcounter;\r\nbreak;\r\ncase XFS_SBS_IFREE:\r\nlcounter = icsbp->icsb_ifree;\r\nlcounter += delta;\r\nif (unlikely(lcounter < 0))\r\ngoto balance_counter;\r\nicsbp->icsb_ifree = lcounter;\r\nbreak;\r\ncase XFS_SBS_FDBLOCKS:\r\nBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\r\nlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\r\nlcounter += delta;\r\nif (unlikely(lcounter < 0))\r\ngoto balance_counter;\r\nicsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nxfs_icsb_unlock_cntr(icsbp);\r\npreempt_enable();\r\nreturn 0;\r\nslow_path:\r\npreempt_enable();\r\nxfs_icsb_lock(mp);\r\nif (!(xfs_icsb_counter_disabled(mp, field))) {\r\nxfs_icsb_unlock(mp);\r\ngoto again;\r\n}\r\nspin_lock(&mp->m_sb_lock);\r\nret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\r\nspin_unlock(&mp->m_sb_lock);\r\nif (ret != ENOSPC)\r\nxfs_icsb_balance_counter(mp, field, 0);\r\nxfs_icsb_unlock(mp);\r\nreturn ret;\r\nbalance_counter:\r\nxfs_icsb_unlock_cntr(icsbp);\r\npreempt_enable();\r\nxfs_icsb_lock(mp);\r\nxfs_icsb_balance_counter(mp, field, delta);\r\nxfs_icsb_unlock(mp);\r\ngoto again;\r\n}
