static void __calc_pre_post_dividers(u32 div, u32 *pre, u32 *post)\r\n{\r\nu32 min_pre, temp_pre, old_err, err;\r\nif (div >= 512) {\r\n*pre = 8;\r\n*post = 64;\r\n} else if (div >= 64) {\r\nmin_pre = (div - 1) / 64 + 1;\r\nold_err = 8;\r\nfor (temp_pre = 8; temp_pre >= min_pre; temp_pre--) {\r\nerr = div % temp_pre;\r\nif (err == 0) {\r\n*pre = temp_pre;\r\nbreak;\r\n}\r\nerr = temp_pre - err;\r\nif (err < old_err) {\r\nold_err = err;\r\n*pre = temp_pre;\r\n}\r\n}\r\n*post = (div + *pre - 1) / *pre;\r\n} else if (div <= 8) {\r\n*pre = div;\r\n*post = 1;\r\n} else {\r\n*pre = 1;\r\n*post = div;\r\n}\r\n}\r\nstatic int cgr_enable(struct clk *clk)\r\n{\r\nu32 reg;\r\nif (!clk->enable_reg)\r\nreturn 0;\r\nreg = __raw_readl(clk->enable_reg);\r\nreg |= 3 << clk->enable_shift;\r\n__raw_writel(reg, clk->enable_reg);\r\nreturn 0;\r\n}\r\nstatic void cgr_disable(struct clk *clk)\r\n{\r\nu32 reg;\r\nif (!clk->enable_reg)\r\nreturn;\r\nreg = __raw_readl(clk->enable_reg);\r\nreg &= ~(3 << clk->enable_shift);\r\nif (clk->enable_reg == MXC_CCM_CGR2 && clk->enable_shift == 8)\r\nreg |= (1 << clk->enable_shift);\r\n__raw_writel(reg, clk->enable_reg);\r\n}\r\nstatic unsigned long pll_ref_get_rate(void)\r\n{\r\nunsigned long ccmr;\r\nunsigned int prcs;\r\nccmr = __raw_readl(MXC_CCM_CCMR);\r\nprcs = (ccmr & MXC_CCM_CCMR_PRCS_MASK) >> MXC_CCM_CCMR_PRCS_OFFSET;\r\nif (prcs == 0x1)\r\nreturn CKIL_CLK_FREQ * 1024;\r\nelse\r\nreturn clk_get_rate(&ckih_clk);\r\n}\r\nstatic unsigned long usb_pll_get_rate(struct clk *clk)\r\n{\r\nunsigned long reg;\r\nreg = __raw_readl(MXC_CCM_UPCTL);\r\nreturn mxc_decode_pll(reg, pll_ref_get_rate());\r\n}\r\nstatic unsigned long serial_pll_get_rate(struct clk *clk)\r\n{\r\nunsigned long reg;\r\nreg = __raw_readl(MXC_CCM_SRPCTL);\r\nreturn mxc_decode_pll(reg, pll_ref_get_rate());\r\n}\r\nstatic unsigned long mcu_pll_get_rate(struct clk *clk)\r\n{\r\nunsigned long reg, ccmr;\r\nccmr = __raw_readl(MXC_CCM_CCMR);\r\nif (!(ccmr & MXC_CCM_CCMR_MPE) || (ccmr & MXC_CCM_CCMR_MDS))\r\nreturn clk_get_rate(&ckih_clk);\r\nreg = __raw_readl(MXC_CCM_MPCTL);\r\nreturn mxc_decode_pll(reg, pll_ref_get_rate());\r\n}\r\nstatic int usb_pll_enable(struct clk *clk)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(MXC_CCM_CCMR);\r\nreg |= MXC_CCM_CCMR_UPE;\r\n__raw_writel(reg, MXC_CCM_CCMR);\r\nudelay(80);\r\nreturn 0;\r\n}\r\nstatic void usb_pll_disable(struct clk *clk)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(MXC_CCM_CCMR);\r\nreg &= ~MXC_CCM_CCMR_UPE;\r\n__raw_writel(reg, MXC_CCM_CCMR);\r\n}\r\nstatic int serial_pll_enable(struct clk *clk)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(MXC_CCM_CCMR);\r\nreg |= MXC_CCM_CCMR_SPE;\r\n__raw_writel(reg, MXC_CCM_CCMR);\r\nudelay(80);\r\nreturn 0;\r\n}\r\nstatic void serial_pll_disable(struct clk *clk)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(MXC_CCM_CCMR);\r\nreg &= ~MXC_CCM_CCMR_SPE;\r\n__raw_writel(reg, MXC_CCM_CCMR);\r\n}\r\nstatic unsigned long mcu_main_get_rate(struct clk *clk)\r\n{\r\nu32 pmcr0 = __raw_readl(MXC_CCM_PMCR0);\r\nif ((pmcr0 & MXC_CCM_PMCR0_DFSUP1) == MXC_CCM_PMCR0_DFSUP1_SPLL)\r\nreturn clk_get_rate(&serial_pll_clk);\r\nelse\r\nreturn clk_get_rate(&mcu_pll_clk);\r\n}\r\nstatic unsigned long ahb_get_rate(struct clk *clk)\r\n{\r\nunsigned long max_pdf;\r\nmax_pdf = PDR0(MXC_CCM_PDR0_MAX_PODF_MASK,\r\nMXC_CCM_PDR0_MAX_PODF_OFFSET);\r\nreturn clk_get_rate(clk->parent) / (max_pdf + 1);\r\n}\r\nstatic unsigned long ipg_get_rate(struct clk *clk)\r\n{\r\nunsigned long ipg_pdf;\r\nipg_pdf = PDR0(MXC_CCM_PDR0_IPG_PODF_MASK,\r\nMXC_CCM_PDR0_IPG_PODF_OFFSET);\r\nreturn clk_get_rate(clk->parent) / (ipg_pdf + 1);\r\n}\r\nstatic unsigned long nfc_get_rate(struct clk *clk)\r\n{\r\nunsigned long nfc_pdf;\r\nnfc_pdf = PDR0(MXC_CCM_PDR0_NFC_PODF_MASK,\r\nMXC_CCM_PDR0_NFC_PODF_OFFSET);\r\nreturn clk_get_rate(clk->parent) / (nfc_pdf + 1);\r\n}\r\nstatic unsigned long hsp_get_rate(struct clk *clk)\r\n{\r\nunsigned long hsp_pdf;\r\nhsp_pdf = PDR0(MXC_CCM_PDR0_HSP_PODF_MASK,\r\nMXC_CCM_PDR0_HSP_PODF_OFFSET);\r\nreturn clk_get_rate(clk->parent) / (hsp_pdf + 1);\r\n}\r\nstatic unsigned long usb_get_rate(struct clk *clk)\r\n{\r\nunsigned long usb_pdf, usb_prepdf;\r\nusb_pdf = PDR1(MXC_CCM_PDR1_USB_PODF_MASK,\r\nMXC_CCM_PDR1_USB_PODF_OFFSET);\r\nusb_prepdf = PDR1(MXC_CCM_PDR1_USB_PRDF_MASK,\r\nMXC_CCM_PDR1_USB_PRDF_OFFSET);\r\nreturn clk_get_rate(clk->parent) / (usb_prepdf + 1) / (usb_pdf + 1);\r\n}\r\nstatic unsigned long csi_get_rate(struct clk *clk)\r\n{\r\nu32 reg, pre, post;\r\nreg = __raw_readl(MXC_CCM_PDR0);\r\npre = (reg & MXC_CCM_PDR0_CSI_PRDF_MASK) >>\r\nMXC_CCM_PDR0_CSI_PRDF_OFFSET;\r\npre++;\r\npost = (reg & MXC_CCM_PDR0_CSI_PODF_MASK) >>\r\nMXC_CCM_PDR0_CSI_PODF_OFFSET;\r\npost++;\r\nreturn clk_get_rate(clk->parent) / (pre * post);\r\n}\r\nstatic unsigned long csi_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 pre, post, parent = clk_get_rate(clk->parent);\r\nu32 div = parent / rate;\r\nif (parent % rate)\r\ndiv++;\r\n__calc_pre_post_dividers(div, &pre, &post);\r\nreturn parent / (pre * post);\r\n}\r\nstatic int csi_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 reg, div, pre, post, parent = clk_get_rate(clk->parent);\r\ndiv = parent / rate;\r\nif ((parent / div) != rate)\r\nreturn -EINVAL;\r\n__calc_pre_post_dividers(div, &pre, &post);\r\nreg = __raw_readl(MXC_CCM_PDR0) &\r\n~(MXC_CCM_PDR0_CSI_PODF_MASK | MXC_CCM_PDR0_CSI_PRDF_MASK);\r\nreg |= (post - 1) << MXC_CCM_PDR0_CSI_PODF_OFFSET;\r\nreg |= (pre - 1) << MXC_CCM_PDR0_CSI_PRDF_OFFSET;\r\n__raw_writel(reg, MXC_CCM_PDR0);\r\nreturn 0;\r\n}\r\nstatic unsigned long ssi1_get_rate(struct clk *clk)\r\n{\r\nunsigned long ssi1_pdf, ssi1_prepdf;\r\nssi1_pdf = PDR1(MXC_CCM_PDR1_SSI1_PODF_MASK,\r\nMXC_CCM_PDR1_SSI1_PODF_OFFSET);\r\nssi1_prepdf = PDR1(MXC_CCM_PDR1_SSI1_PRE_PODF_MASK,\r\nMXC_CCM_PDR1_SSI1_PRE_PODF_OFFSET);\r\nreturn clk_get_rate(clk->parent) / (ssi1_prepdf + 1) / (ssi1_pdf + 1);\r\n}\r\nstatic unsigned long ssi2_get_rate(struct clk *clk)\r\n{\r\nunsigned long ssi2_pdf, ssi2_prepdf;\r\nssi2_pdf = PDR1(MXC_CCM_PDR1_SSI2_PODF_MASK,\r\nMXC_CCM_PDR1_SSI2_PODF_OFFSET);\r\nssi2_prepdf = PDR1(MXC_CCM_PDR1_SSI2_PRE_PODF_MASK,\r\nMXC_CCM_PDR1_SSI2_PRE_PODF_OFFSET);\r\nreturn clk_get_rate(clk->parent) / (ssi2_prepdf + 1) / (ssi2_pdf + 1);\r\n}\r\nstatic unsigned long firi_get_rate(struct clk *clk)\r\n{\r\nunsigned long firi_pdf, firi_prepdf;\r\nfiri_pdf = PDR1(MXC_CCM_PDR1_FIRI_PODF_MASK,\r\nMXC_CCM_PDR1_FIRI_PODF_OFFSET);\r\nfiri_prepdf = PDR1(MXC_CCM_PDR1_FIRI_PRE_PODF_MASK,\r\nMXC_CCM_PDR1_FIRI_PRE_PODF_OFFSET);\r\nreturn clk_get_rate(clk->parent) / (firi_prepdf + 1) / (firi_pdf + 1);\r\n}\r\nstatic unsigned long firi_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 pre, post;\r\nu32 parent = clk_get_rate(clk->parent);\r\nu32 div = parent / rate;\r\nif (parent % rate)\r\ndiv++;\r\n__calc_pre_post_dividers(div, &pre, &post);\r\nreturn parent / (pre * post);\r\n}\r\nstatic int firi_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 reg, div, pre, post, parent = clk_get_rate(clk->parent);\r\ndiv = parent / rate;\r\nif ((parent / div) != rate)\r\nreturn -EINVAL;\r\n__calc_pre_post_dividers(div, &pre, &post);\r\nreg = __raw_readl(MXC_CCM_PDR1) &\r\n~(MXC_CCM_PDR1_FIRI_PODF_MASK | MXC_CCM_PDR1_FIRI_PRE_PODF_MASK);\r\nreg |= (pre - 1) << MXC_CCM_PDR1_FIRI_PRE_PODF_OFFSET;\r\nreg |= (post - 1) << MXC_CCM_PDR1_FIRI_PODF_OFFSET;\r\n__raw_writel(reg, MXC_CCM_PDR1);\r\nreturn 0;\r\n}\r\nstatic unsigned long mbx_get_rate(struct clk *clk)\r\n{\r\nreturn clk_get_rate(clk->parent) / 2;\r\n}\r\nstatic unsigned long mstick1_get_rate(struct clk *clk)\r\n{\r\nunsigned long msti_pdf;\r\nmsti_pdf = PDR2(MXC_CCM_PDR2_MST1_PDF_MASK,\r\nMXC_CCM_PDR2_MST1_PDF_OFFSET);\r\nreturn clk_get_rate(clk->parent) / (msti_pdf + 1);\r\n}\r\nstatic unsigned long mstick2_get_rate(struct clk *clk)\r\n{\r\nunsigned long msti_pdf;\r\nmsti_pdf = PDR2(MXC_CCM_PDR2_MST2_PDF_MASK,\r\nMXC_CCM_PDR2_MST2_PDF_OFFSET);\r\nreturn clk_get_rate(clk->parent) / (msti_pdf + 1);\r\n}\r\nstatic unsigned long clk_ckih_get_rate(struct clk *clk)\r\n{\r\nreturn ckih_rate;\r\n}\r\nstatic unsigned long clk_ckil_get_rate(struct clk *clk)\r\n{\r\nreturn CKIL_CLK_FREQ;\r\n}\r\nint __init mx31_clocks_init(unsigned long fref)\r\n{\r\nu32 reg;\r\nckih_rate = fref;\r\nclkdev_add_table(lookups, ARRAY_SIZE(lookups));\r\nreg = __raw_readl(MXC_CCM_CCMR);\r\nif (!(reg & MXC_CCM_CCMR_CSCS))\r\nif (clk_set_parent(&csi_clk, &usb_pll_clk))\r\npr_err("%s: error changing csi_clk parent\n", __func__);\r\n__raw_writel((3 << 4), MXC_CCM_CGR0);\r\n__raw_writel(0, MXC_CCM_CGR1);\r\n__raw_writel((3 << 8) | (3 << 14) | (3 << 16)|\r\n1 << 27 | 1 << 28,\r\nMXC_CCM_CGR2);\r\n__raw_writel(__raw_readl(MXC_CCM_CCMR) | (1 << 24), MXC_CCM_CCMR);\r\nusb_pll_disable(&usb_pll_clk);\r\npr_info("Clock input source is %ld\n", clk_get_rate(&ckih_clk));\r\nclk_enable(&gpt_clk);\r\nclk_enable(&emi_clk);\r\nclk_enable(&iim_clk);\r\nmx31_revision();\r\nclk_disable(&iim_clk);\r\nclk_enable(&serial_pll_clk);\r\nif (mx31_revision() >= IMX_CHIP_REVISION_2_0) {\r\nreg = __raw_readl(MXC_CCM_PMCR1);\r\nreg |= MXC_CCM_PMCR1_PLLRDIS | MXC_CCM_PMCR1_EMIRQ_EN;\r\n__raw_writel(reg, MXC_CCM_PMCR1);\r\n}\r\nmxc_timer_init(&ipg_clk, MX31_IO_ADDRESS(MX31_GPT1_BASE_ADDR),\r\nMX31_INT_GPT);\r\nreturn 0;\r\n}
