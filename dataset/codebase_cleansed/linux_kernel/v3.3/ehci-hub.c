static void ehci_handover_companion_ports(struct ehci_hcd *ehci)\r\n{\r\nu32 __iomem *reg;\r\nu32 status;\r\nint port;\r\n__le32 buf;\r\nstruct usb_hcd *hcd = ehci_to_hcd(ehci);\r\nif (!ehci->owned_ports)\r\nreturn;\r\nmsleep(20);\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nif (test_bit(port, &ehci->owned_ports)) {\r\nreg = &ehci->regs->port_status[port];\r\nstatus = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;\r\nif (status & PORT_OWNER)\r\nclear_bit(port, &ehci->owned_ports);\r\nelse if (test_bit(port, &ehci->companion_ports))\r\nehci_writel(ehci, status & ~PORT_PE, reg);\r\nelse\r\nehci_hub_control(hcd, SetPortFeature,\r\nUSB_PORT_FEAT_RESET, port + 1,\r\nNULL, 0);\r\n}\r\n}\r\nif (!ehci->owned_ports)\r\nreturn;\r\nmsleep(90);\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nif (test_bit(port, &ehci->owned_ports)) {\r\nehci_hub_control(hcd, GetPortStatus,\r\n0, port + 1,\r\n(char *) &buf, sizeof(buf));\r\nreg = &ehci->regs->port_status[port];\r\nstatus = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;\r\nif (status & PORT_OWNER)\r\nehci_writel(ehci, status | PORT_CSC, reg);\r\nelse {\r\nehci_dbg(ehci, "failed handover port %d: %x\n",\r\nport + 1, status);\r\nehci_writel(ehci, status & ~PORT_PE, reg);\r\n}\r\n}\r\n}\r\nehci->owned_ports = 0;\r\n}\r\nstatic int ehci_port_change(struct ehci_hcd *ehci)\r\n{\r\nint i = HCS_N_PORTS(ehci->hcs_params);\r\nif (ehci_readl(ehci, &ehci->regs->status) & STS_PCD)\r\nreturn 1;\r\nwhile (i--)\r\nif (ehci_readl(ehci, &ehci->regs->port_status[i]) & PORT_CSC)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic __maybe_unused void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,\r\nbool suspending, bool do_wakeup)\r\n{\r\nint port;\r\nu32 temp;\r\nunsigned long flags;\r\nif (!ehci_to_hcd(ehci)->self.root_hub->do_remote_wakeup || do_wakeup)\r\nreturn;\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nif (ehci->has_hostpc) {\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nu32 __iomem *hostpc_reg;\r\nhostpc_reg = (u32 __iomem *)((u8 *) ehci->regs\r\n+ HOSTPC0 + 4 * port);\r\ntemp = ehci_readl(ehci, hostpc_reg);\r\nehci_writel(ehci, temp & ~HOSTPC_PHCD, hostpc_reg);\r\n}\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nmsleep(5);\r\nspin_lock_irqsave(&ehci->lock, flags);\r\n}\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nu32 __iomem *reg = &ehci->regs->port_status[port];\r\nu32 t1 = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;\r\nu32 t2 = t1 & ~PORT_WAKE_BITS;\r\nif (!suspending) {\r\nif (t1 & PORT_CONNECT)\r\nt2 |= PORT_WKOC_E | PORT_WKDISC_E;\r\nelse\r\nt2 |= PORT_WKOC_E | PORT_WKCONN_E;\r\n}\r\nehci_vdbg(ehci, "port %d, %08x -> %08x\n",\r\nport + 1, t1, t2);\r\nehci_writel(ehci, t2, reg);\r\n}\r\nif (ehci->has_hostpc) {\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nu32 __iomem *hostpc_reg;\r\nhostpc_reg = (u32 __iomem *)((u8 *) ehci->regs\r\n+ HOSTPC0 + 4 * port);\r\ntemp = ehci_readl(ehci, hostpc_reg);\r\nehci_writel(ehci, temp | HOSTPC_PHCD, hostpc_reg);\r\n}\r\n}\r\nif (!suspending && ehci_port_change(ehci))\r\nusb_hcd_resume_root_hub(ehci_to_hcd(ehci));\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\n}\r\nstatic int ehci_bus_suspend (struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci (hcd);\r\nint port;\r\nint mask;\r\nint changed;\r\nehci_dbg(ehci, "suspend root hub\n");\r\nif (time_before (jiffies, ehci->next_statechange))\r\nmsleep(5);\r\ndel_timer_sync(&ehci->watchdog);\r\ndel_timer_sync(&ehci->iaa_watchdog);\r\nspin_lock_irq (&ehci->lock);\r\nif (hcd->self.root_hub->do_remote_wakeup) {\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nif (ehci->reset_done[port] != 0) {\r\nspin_unlock_irq(&ehci->lock);\r\nehci_dbg(ehci, "suspend failed because "\r\n"port %d is resuming\n",\r\nport + 1);\r\nreturn -EBUSY;\r\n}\r\n}\r\n}\r\nif (ehci->rh_state == EHCI_RH_RUNNING)\r\nehci_quiesce (ehci);\r\nehci->command = ehci_readl(ehci, &ehci->regs->command);\r\nehci_work(ehci);\r\nehci->bus_suspended = 0;\r\nehci->owned_ports = 0;\r\nchanged = 0;\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nu32 __iomem *reg = &ehci->regs->port_status [port];\r\nu32 t1 = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;\r\nu32 t2 = t1 & ~PORT_WAKE_BITS;\r\nif (t1 & PORT_OWNER)\r\nset_bit(port, &ehci->owned_ports);\r\nelse if ((t1 & PORT_PE) && !(t1 & PORT_SUSPEND)) {\r\nt2 |= PORT_SUSPEND;\r\nset_bit(port, &ehci->bus_suspended);\r\n}\r\nif (hcd->self.root_hub->do_remote_wakeup) {\r\nif (t1 & PORT_CONNECT)\r\nt2 |= PORT_WKOC_E | PORT_WKDISC_E;\r\nelse\r\nt2 |= PORT_WKOC_E | PORT_WKCONN_E;\r\n}\r\nif (t1 != t2) {\r\nehci_vdbg (ehci, "port %d, %08x -> %08x\n",\r\nport + 1, t1, t2);\r\nehci_writel(ehci, t2, reg);\r\nchanged = 1;\r\n}\r\n}\r\nif (changed && ehci->has_hostpc) {\r\nspin_unlock_irq(&ehci->lock);\r\nmsleep(5);\r\nspin_lock_irq(&ehci->lock);\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nu32 __iomem *hostpc_reg;\r\nu32 t3;\r\nhostpc_reg = (u32 __iomem *)((u8 *) ehci->regs\r\n+ HOSTPC0 + 4 * port);\r\nt3 = ehci_readl(ehci, hostpc_reg);\r\nehci_writel(ehci, t3 | HOSTPC_PHCD, hostpc_reg);\r\nt3 = ehci_readl(ehci, hostpc_reg);\r\nehci_dbg(ehci, "Port %d phy low-power mode %s\n",\r\nport, (t3 & HOSTPC_PHCD) ?\r\n"succeeded" : "failed");\r\n}\r\n}\r\nif (ehci->bus_suspended)\r\nudelay(150);\r\nehci_halt (ehci);\r\nehci->rh_state = EHCI_RH_SUSPENDED;\r\nif (ehci->reclaim)\r\nend_unlink_async(ehci);\r\nmask = INTR_MASK;\r\nif (!hcd->self.root_hub->do_remote_wakeup)\r\nmask &= ~STS_PCD;\r\nehci_writel(ehci, mask, &ehci->regs->intr_enable);\r\nehci_readl(ehci, &ehci->regs->intr_enable);\r\nehci->next_statechange = jiffies + msecs_to_jiffies(10);\r\nspin_unlock_irq (&ehci->lock);\r\ndel_timer_sync(&ehci->watchdog);\r\nreturn 0;\r\n}\r\nstatic int ehci_bus_resume (struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci (hcd);\r\nu32 temp;\r\nu32 power_okay;\r\nint i;\r\nunsigned long resume_needed = 0;\r\nif (time_before (jiffies, ehci->next_statechange))\r\nmsleep(5);\r\nspin_lock_irq (&ehci->lock);\r\nif (!HCD_HW_ACCESSIBLE(hcd)) {\r\nspin_unlock_irq(&ehci->lock);\r\nreturn -ESHUTDOWN;\r\n}\r\nif (unlikely(ehci->debug)) {\r\nif (!dbgp_reset_prep())\r\nehci->debug = NULL;\r\nelse\r\ndbgp_external_startup();\r\n}\r\npower_okay = ehci_readl(ehci, &ehci->regs->intr_enable);\r\nehci_dbg(ehci, "resume root hub%s\n",\r\npower_okay ? "" : " after power loss");\r\nehci_writel(ehci, 0, &ehci->regs->intr_enable);\r\nehci_writel(ehci, 0, &ehci->regs->segment);\r\nehci_writel(ehci, ehci->periodic_dma, &ehci->regs->frame_list);\r\nehci_writel(ehci, (u32) ehci->async->qh_dma, &ehci->regs->async_next);\r\nehci_writel(ehci, ehci->command, &ehci->regs->command);\r\nehci->rh_state = EHCI_RH_RUNNING;\r\nspin_unlock_irq(&ehci->lock);\r\nmsleep(8);\r\nspin_lock_irq(&ehci->lock);\r\nif (ehci->bus_suspended && ehci->has_hostpc) {\r\ni = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (i--) {\r\nif (test_bit(i, &ehci->bus_suspended)) {\r\nu32 __iomem *hostpc_reg;\r\nhostpc_reg = (u32 __iomem *)((u8 *) ehci->regs\r\n+ HOSTPC0 + 4 * i);\r\ntemp = ehci_readl(ehci, hostpc_reg);\r\nehci_writel(ehci, temp & ~HOSTPC_PHCD,\r\nhostpc_reg);\r\n}\r\n}\r\nspin_unlock_irq(&ehci->lock);\r\nmsleep(5);\r\nspin_lock_irq(&ehci->lock);\r\n}\r\ni = HCS_N_PORTS (ehci->hcs_params);\r\nwhile (i--) {\r\ntemp = ehci_readl(ehci, &ehci->regs->port_status [i]);\r\ntemp &= ~(PORT_RWC_BITS | PORT_WAKE_BITS);\r\nif (test_bit(i, &ehci->bus_suspended) &&\r\n(temp & PORT_SUSPEND)) {\r\ntemp |= PORT_RESUME;\r\nset_bit(i, &resume_needed);\r\n}\r\nehci_writel(ehci, temp, &ehci->regs->port_status [i]);\r\n}\r\nif (resume_needed) {\r\nspin_unlock_irq(&ehci->lock);\r\nmsleep(20);\r\nspin_lock_irq(&ehci->lock);\r\n}\r\ni = HCS_N_PORTS (ehci->hcs_params);\r\nwhile (i--) {\r\ntemp = ehci_readl(ehci, &ehci->regs->port_status [i]);\r\nif (test_bit(i, &resume_needed)) {\r\ntemp &= ~(PORT_RWC_BITS | PORT_RESUME);\r\nehci_writel(ehci, temp, &ehci->regs->port_status [i]);\r\nehci_vdbg (ehci, "resumed port %d\n", i + 1);\r\n}\r\n}\r\n(void) ehci_readl(ehci, &ehci->regs->command);\r\ntemp = 0;\r\nif (ehci->async->qh_next.qh)\r\ntemp |= CMD_ASE;\r\nif (ehci->periodic_sched)\r\ntemp |= CMD_PSE;\r\nif (temp) {\r\nehci->command |= temp;\r\nehci_writel(ehci, ehci->command, &ehci->regs->command);\r\n}\r\nehci->next_statechange = jiffies + msecs_to_jiffies(5);\r\nehci_writel(ehci, INTR_MASK, &ehci->regs->intr_enable);\r\nspin_unlock_irq (&ehci->lock);\r\nehci_handover_companion_ports(ehci);\r\nreturn 0;\r\n}\r\nstatic void set_owner(struct ehci_hcd *ehci, int portnum, int new_owner)\r\n{\r\nu32 __iomem *status_reg;\r\nu32 port_status;\r\nint try;\r\nstatus_reg = &ehci->regs->port_status[portnum];\r\nfor (try = 4; try > 0; --try) {\r\nspin_lock_irq(&ehci->lock);\r\nport_status = ehci_readl(ehci, status_reg);\r\nif ((port_status & PORT_OWNER) == new_owner\r\n|| (port_status & (PORT_OWNER | PORT_CONNECT))\r\n== 0)\r\ntry = 0;\r\nelse {\r\nport_status ^= PORT_OWNER;\r\nport_status &= ~(PORT_PE | PORT_RWC_BITS);\r\nehci_writel(ehci, port_status, status_reg);\r\n}\r\nspin_unlock_irq(&ehci->lock);\r\nif (try > 1)\r\nmsleep(5);\r\n}\r\n}\r\nstatic int check_reset_complete (\r\nstruct ehci_hcd *ehci,\r\nint index,\r\nu32 __iomem *status_reg,\r\nint port_status\r\n) {\r\nif (!(port_status & PORT_CONNECT))\r\nreturn port_status;\r\nif (!(port_status & PORT_PE)) {\r\nif (ehci_is_TDI(ehci)) {\r\nehci_dbg (ehci,\r\n"Failed to enable port %d on root hub TT\n",\r\nindex+1);\r\nreturn port_status;\r\n}\r\nehci_dbg (ehci, "port %d full speed --> companion\n",\r\nindex + 1);\r\nport_status |= PORT_OWNER;\r\nport_status &= ~PORT_RWC_BITS;\r\nehci_writel(ehci, port_status, status_reg);\r\nif (ehci->has_amcc_usb23)\r\nset_ohci_hcfs(ehci, 1);\r\n} else {\r\nehci_dbg (ehci, "port %d high speed\n", index + 1);\r\nif (ehci->has_amcc_usb23)\r\nset_ohci_hcfs(ehci, 0);\r\n}\r\nreturn port_status;\r\n}\r\nstatic int\r\nehci_hub_status_data (struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci (hcd);\r\nu32 temp, status = 0;\r\nu32 mask;\r\nint ports, i, retval = 1;\r\nunsigned long flags;\r\nu32 ppcd = 0;\r\nif (ehci->rh_state != EHCI_RH_RUNNING)\r\nreturn 0;\r\nbuf [0] = 0;\r\nports = HCS_N_PORTS (ehci->hcs_params);\r\nif (ports > 7) {\r\nbuf [1] = 0;\r\nretval++;\r\n}\r\nif (!ignore_oc)\r\nmask = PORT_CSC | PORT_PEC | PORT_OCC;\r\nelse\r\nmask = PORT_CSC | PORT_PEC;\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nif (ehci->has_ppcd)\r\nppcd = ehci_readl(ehci, &ehci->regs->status) >> 16;\r\nfor (i = 0; i < ports; i++) {\r\nif (ehci->has_ppcd && !(ppcd & (1 << i)))\r\ncontinue;\r\ntemp = ehci_readl(ehci, &ehci->regs->port_status [i]);\r\nif ((temp & mask) != 0 || test_bit(i, &ehci->port_c_suspend)\r\n|| (ehci->reset_done[i] && time_after_eq(\r\njiffies, ehci->reset_done[i]))) {\r\nif (i < 7)\r\nbuf [0] |= 1 << (i + 1);\r\nelse\r\nbuf [1] |= 1 << (i - 7);\r\nstatus = STS_PCD;\r\n}\r\n}\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\nreturn status ? retval : 0;\r\n}\r\nstatic void\r\nehci_hub_descriptor (\r\nstruct ehci_hcd *ehci,\r\nstruct usb_hub_descriptor *desc\r\n) {\r\nint ports = HCS_N_PORTS (ehci->hcs_params);\r\nu16 temp;\r\ndesc->bDescriptorType = 0x29;\r\ndesc->bPwrOn2PwrGood = 10;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->bNbrPorts = ports;\r\ntemp = 1 + (ports / 8);\r\ndesc->bDescLength = 7 + 2 * temp;\r\nmemset(&desc->u.hs.DeviceRemovable[0], 0, temp);\r\nmemset(&desc->u.hs.DeviceRemovable[temp], 0xff, temp);\r\ntemp = 0x0008;\r\nif (HCS_PPC (ehci->hcs_params))\r\ntemp |= 0x0001;\r\nelse\r\ntemp |= 0x0002;\r\n#if 0\r\nif (HCS_INDICATOR (ehci->hcs_params))\r\ntemp |= 0x0080;\r\n#endif\r\ndesc->wHubCharacteristics = cpu_to_le16(temp);\r\n}\r\nstatic int ehci_hub_control (\r\nstruct usb_hcd *hcd,\r\nu16 typeReq,\r\nu16 wValue,\r\nu16 wIndex,\r\nchar *buf,\r\nu16 wLength\r\n) {\r\nstruct ehci_hcd *ehci = hcd_to_ehci (hcd);\r\nint ports = HCS_N_PORTS (ehci->hcs_params);\r\nu32 __iomem *status_reg = &ehci->regs->port_status[\r\n(wIndex & 0xff) - 1];\r\nu32 __iomem *hostpc_reg = NULL;\r\nu32 temp, temp1, status;\r\nunsigned long flags;\r\nint retval = 0;\r\nunsigned selector;\r\nif (ehci->has_hostpc)\r\nhostpc_reg = (u32 __iomem *)((u8 *)ehci->regs\r\n+ HOSTPC0 + 4 * ((wIndex & 0xff) - 1));\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_LOCAL_POWER:\r\ncase C_HUB_OVER_CURRENT:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase ClearPortFeature:\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\ntemp = ehci_readl(ehci, status_reg);\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\nehci_writel(ehci, temp & ~PORT_PE, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\nehci_writel(ehci, (temp & ~PORT_RWC_BITS) | PORT_PEC,\r\nstatus_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif (temp & PORT_RESET)\r\ngoto error;\r\nif (ehci->no_selective_suspend)\r\nbreak;\r\n#ifdef CONFIG_USB_OTG\r\nif ((hcd->self.otg_port == (wIndex + 1))\r\n&& hcd->self.b_hnp_enable) {\r\notg_start_hnp(ehci->transceiver);\r\nbreak;\r\n}\r\n#endif\r\nif (!(temp & PORT_SUSPEND))\r\nbreak;\r\nif ((temp & PORT_PE) == 0)\r\ngoto error;\r\nif (hostpc_reg) {\r\ntemp1 = ehci_readl(ehci, hostpc_reg);\r\nehci_writel(ehci, temp1 & ~HOSTPC_PHCD,\r\nhostpc_reg);\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nmsleep(5);\r\nspin_lock_irqsave(&ehci->lock, flags);\r\n}\r\ntemp &= ~(PORT_RWC_BITS | PORT_WAKE_BITS);\r\nehci_writel(ehci, temp | PORT_RESUME, status_reg);\r\nehci->reset_done[wIndex] = jiffies\r\n+ msecs_to_jiffies(20);\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\nclear_bit(wIndex, &ehci->port_c_suspend);\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nif (HCS_PPC (ehci->hcs_params))\r\nehci_writel(ehci,\r\ntemp & ~(PORT_RWC_BITS | PORT_POWER),\r\nstatus_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\nif (ehci->has_lpm) {\r\ntemp &= ~PORT_LPM;\r\ntemp &= ~PORT_DEV_ADDR;\r\n}\r\nehci_writel(ehci, (temp & ~PORT_RWC_BITS) | PORT_CSC,\r\nstatus_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\nehci_writel(ehci, (temp & ~PORT_RWC_BITS) | PORT_OCC,\r\nstatus_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nehci_readl(ehci, &ehci->regs->command);\r\nbreak;\r\ncase GetHubDescriptor:\r\nehci_hub_descriptor (ehci, (struct usb_hub_descriptor *)\r\nbuf);\r\nbreak;\r\ncase GetHubStatus:\r\nmemset (buf, 0, 4);\r\nbreak;\r\ncase GetPortStatus:\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\nstatus = 0;\r\ntemp = ehci_readl(ehci, status_reg);\r\nif (temp & PORT_CSC)\r\nstatus |= USB_PORT_STAT_C_CONNECTION << 16;\r\nif (temp & PORT_PEC)\r\nstatus |= USB_PORT_STAT_C_ENABLE << 16;\r\nif ((temp & PORT_OCC) && !ignore_oc){\r\nstatus |= USB_PORT_STAT_C_OVERCURRENT << 16;\r\nif ((temp & PORT_OC) && HCS_PPC(ehci->hcs_params)) {\r\nehci_writel(ehci,\r\ntemp & ~(PORT_RWC_BITS | PORT_POWER),\r\nstatus_reg);\r\ntemp = ehci_readl(ehci, status_reg);\r\n}\r\n}\r\nif (temp & PORT_RESUME) {\r\nif (!ehci->reset_done[wIndex]) {\r\nehci->reset_done[wIndex] = jiffies\r\n+ msecs_to_jiffies(20);\r\nmod_timer(&ehci_to_hcd(ehci)->rh_timer,\r\nehci->reset_done[wIndex]);\r\n}\r\nelse if (time_after_eq(jiffies,\r\nehci->reset_done[wIndex])) {\r\nclear_bit(wIndex, &ehci->suspended_ports);\r\nset_bit(wIndex, &ehci->port_c_suspend);\r\nehci->reset_done[wIndex] = 0;\r\ntemp = ehci_readl(ehci, status_reg);\r\nehci_writel(ehci,\r\ntemp & ~(PORT_RWC_BITS | PORT_RESUME),\r\nstatus_reg);\r\nretval = handshake(ehci, status_reg,\r\nPORT_RESUME, 0, 2000 );\r\nif (retval != 0) {\r\nehci_err(ehci,\r\n"port %d resume error %d\n",\r\nwIndex + 1, retval);\r\ngoto error;\r\n}\r\ntemp &= ~(PORT_SUSPEND|PORT_RESUME|(3<<10));\r\n}\r\n}\r\nif ((temp & PORT_RESET)\r\n&& time_after_eq(jiffies,\r\nehci->reset_done[wIndex])) {\r\nstatus |= USB_PORT_STAT_C_RESET << 16;\r\nehci->reset_done [wIndex] = 0;\r\nehci_writel(ehci, temp & ~(PORT_RWC_BITS | PORT_RESET),\r\nstatus_reg);\r\nretval = handshake(ehci, status_reg,\r\nPORT_RESET, 0, 1000);\r\nif (retval != 0) {\r\nehci_err (ehci, "port %d reset error %d\n",\r\nwIndex + 1, retval);\r\ngoto error;\r\n}\r\ntemp = check_reset_complete (ehci, wIndex, status_reg,\r\nehci_readl(ehci, status_reg));\r\n}\r\nif (!(temp & (PORT_RESUME|PORT_RESET)))\r\nehci->reset_done[wIndex] = 0;\r\nif ((temp & PORT_CONNECT) &&\r\ntest_bit(wIndex, &ehci->companion_ports)) {\r\ntemp &= ~PORT_RWC_BITS;\r\ntemp |= PORT_OWNER;\r\nehci_writel(ehci, temp, status_reg);\r\nehci_dbg(ehci, "port %d --> companion\n", wIndex + 1);\r\ntemp = ehci_readl(ehci, status_reg);\r\n}\r\nif (temp & PORT_CONNECT) {\r\nstatus |= USB_PORT_STAT_CONNECTION;\r\nif (ehci->has_hostpc) {\r\ntemp1 = ehci_readl(ehci, hostpc_reg);\r\nstatus |= ehci_port_speed(ehci, temp1);\r\n} else\r\nstatus |= ehci_port_speed(ehci, temp);\r\n}\r\nif (temp & PORT_PE)\r\nstatus |= USB_PORT_STAT_ENABLE;\r\nif (temp & (PORT_SUSPEND|PORT_RESUME)) {\r\nstatus |= USB_PORT_STAT_SUSPEND;\r\n} else if (test_bit(wIndex, &ehci->suspended_ports)) {\r\nclear_bit(wIndex, &ehci->suspended_ports);\r\nehci->reset_done[wIndex] = 0;\r\nif (temp & PORT_PE)\r\nset_bit(wIndex, &ehci->port_c_suspend);\r\n}\r\nif (temp & PORT_OC)\r\nstatus |= USB_PORT_STAT_OVERCURRENT;\r\nif (temp & PORT_RESET)\r\nstatus |= USB_PORT_STAT_RESET;\r\nif (temp & PORT_POWER)\r\nstatus |= USB_PORT_STAT_POWER;\r\nif (test_bit(wIndex, &ehci->port_c_suspend))\r\nstatus |= USB_PORT_STAT_C_SUSPEND << 16;\r\n#ifndef VERBOSE_DEBUG\r\nif (status & ~0xffff)\r\n#endif\r\ndbg_port (ehci, "GetStatus", wIndex + 1, temp);\r\nput_unaligned_le32(status, buf);\r\nbreak;\r\ncase SetHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_LOCAL_POWER:\r\ncase C_HUB_OVER_CURRENT:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase SetPortFeature:\r\nselector = wIndex >> 8;\r\nwIndex &= 0xff;\r\nif (unlikely(ehci->debug)) {\r\nif (wIndex == HCS_DEBUG_PORT(ehci->hcs_params) &&\r\n(readl(&ehci->debug->control) & DBGP_ENABLED)) {\r\nretval = -ENODEV;\r\ngoto error_exit;\r\n}\r\n}\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\ntemp = ehci_readl(ehci, status_reg);\r\nif (temp & PORT_OWNER)\r\nbreak;\r\ntemp &= ~PORT_RWC_BITS;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif (ehci->no_selective_suspend)\r\nbreak;\r\nif ((temp & PORT_PE) == 0\r\n|| (temp & PORT_RESET) != 0)\r\ngoto error;\r\ntemp &= ~PORT_WKCONN_E;\r\ntemp |= PORT_WKDISC_E | PORT_WKOC_E;\r\nehci_writel(ehci, temp | PORT_SUSPEND, status_reg);\r\nif (hostpc_reg) {\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nmsleep(5);\r\nspin_lock_irqsave(&ehci->lock, flags);\r\ntemp1 = ehci_readl(ehci, hostpc_reg);\r\nehci_writel(ehci, temp1 | HOSTPC_PHCD,\r\nhostpc_reg);\r\ntemp1 = ehci_readl(ehci, hostpc_reg);\r\nehci_dbg(ehci, "Port%d phy low pwr mode %s\n",\r\nwIndex, (temp1 & HOSTPC_PHCD) ?\r\n"succeeded" : "failed");\r\n}\r\nset_bit(wIndex, &ehci->suspended_ports);\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nif (HCS_PPC (ehci->hcs_params))\r\nehci_writel(ehci, temp | PORT_POWER,\r\nstatus_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\nif (temp & PORT_RESUME)\r\ngoto error;\r\nif ((temp & (PORT_PE|PORT_CONNECT)) == PORT_CONNECT\r\n&& !ehci_is_TDI(ehci)\r\n&& PORT_USB11 (temp)) {\r\nehci_dbg (ehci,\r\n"port %d low speed --> companion\n",\r\nwIndex + 1);\r\ntemp |= PORT_OWNER;\r\n} else {\r\nehci_vdbg (ehci, "port %d reset\n", wIndex + 1);\r\ntemp |= PORT_RESET;\r\ntemp &= ~PORT_PE;\r\nehci->reset_done [wIndex] = jiffies\r\n+ msecs_to_jiffies (50);\r\n}\r\nehci_writel(ehci, temp, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_TEST:\r\nif (!selector || selector > 5)\r\ngoto error;\r\nehci_quiesce(ehci);\r\nwhile (ports--) {\r\nu32 __iomem *sreg =\r\n&ehci->regs->port_status[ports];\r\ntemp = ehci_readl(ehci, sreg) & ~PORT_RWC_BITS;\r\nif (temp & PORT_PE)\r\nehci_writel(ehci, temp | PORT_SUSPEND,\r\nsreg);\r\n}\r\nehci_halt(ehci);\r\ntemp = ehci_readl(ehci, status_reg);\r\ntemp |= selector << 16;\r\nehci_writel(ehci, temp, status_reg);\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nehci_readl(ehci, &ehci->regs->command);\r\nbreak;\r\ndefault:\r\nerror:\r\nretval = -EPIPE;\r\n}\r\nerror_exit:\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\nreturn retval;\r\n}\r\nstatic void ehci_relinquish_port(struct usb_hcd *hcd, int portnum)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nif (ehci_is_TDI(ehci))\r\nreturn;\r\nset_owner(ehci, --portnum, PORT_OWNER);\r\n}\r\nstatic int ehci_port_handed_over(struct usb_hcd *hcd, int portnum)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nu32 __iomem *reg;\r\nif (ehci_is_TDI(ehci))\r\nreturn 0;\r\nreg = &ehci->regs->port_status[portnum - 1];\r\nreturn ehci_readl(ehci, reg) & PORT_OWNER;\r\n}
