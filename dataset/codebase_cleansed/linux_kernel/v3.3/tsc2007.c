static inline int tsc2007_xfer(struct tsc2007 *tsc, u8 cmd)\r\n{\r\ns32 data;\r\nu16 val;\r\ndata = i2c_smbus_read_word_data(tsc->client, cmd);\r\nif (data < 0) {\r\ndev_err(&tsc->client->dev, "i2c io error: %d\n", data);\r\nreturn data;\r\n}\r\nval = swab16(data) >> 4;\r\ndev_dbg(&tsc->client->dev, "data: 0x%x, val: 0x%x\n", data, val);\r\nreturn val;\r\n}\r\nstatic void tsc2007_read_values(struct tsc2007 *tsc, struct ts_event *tc)\r\n{\r\ntc->y = tsc2007_xfer(tsc, READ_Y);\r\ntc->x = tsc2007_xfer(tsc, READ_X);\r\ntc->z1 = tsc2007_xfer(tsc, READ_Z1);\r\ntc->z2 = tsc2007_xfer(tsc, READ_Z2);\r\ntsc2007_xfer(tsc, PWRDOWN);\r\n}\r\nstatic u32 tsc2007_calculate_pressure(struct tsc2007 *tsc, struct ts_event *tc)\r\n{\r\nu32 rt = 0;\r\nif (tc->x == MAX_12BIT)\r\ntc->x = 0;\r\nif (likely(tc->x && tc->z1)) {\r\nrt = tc->z2 - tc->z1;\r\nrt *= tc->x;\r\nrt *= tsc->x_plate_ohms;\r\nrt /= tc->z1;\r\nrt = (rt + 2047) >> 12;\r\n}\r\nreturn rt;\r\n}\r\nstatic bool tsc2007_is_pen_down(struct tsc2007 *ts)\r\n{\r\nif (!ts->get_pendown_state)\r\nreturn true;\r\nreturn ts->get_pendown_state();\r\n}\r\nstatic irqreturn_t tsc2007_soft_irq(int irq, void *handle)\r\n{\r\nstruct tsc2007 *ts = handle;\r\nstruct input_dev *input = ts->input;\r\nstruct ts_event tc;\r\nu32 rt;\r\nwhile (!ts->stopped && tsc2007_is_pen_down(ts)) {\r\ntsc2007_read_values(ts, &tc);\r\nrt = tsc2007_calculate_pressure(ts, &tc);\r\nif (rt == 0 && !ts->get_pendown_state) {\r\nbreak;\r\n}\r\nif (rt <= ts->max_rt) {\r\ndev_dbg(&ts->client->dev,\r\n"DOWN point(%4d,%4d), pressure (%4u)\n",\r\ntc.x, tc.y, rt);\r\ninput_report_key(input, BTN_TOUCH, 1);\r\ninput_report_abs(input, ABS_X, tc.x);\r\ninput_report_abs(input, ABS_Y, tc.y);\r\ninput_report_abs(input, ABS_PRESSURE, rt);\r\ninput_sync(input);\r\n} else {\r\ndev_dbg(&ts->client->dev, "ignored pressure %d\n", rt);\r\n}\r\nwait_event_timeout(ts->wait, ts->stopped,\r\nmsecs_to_jiffies(ts->poll_period));\r\n}\r\ndev_dbg(&ts->client->dev, "UP\n");\r\ninput_report_key(input, BTN_TOUCH, 0);\r\ninput_report_abs(input, ABS_PRESSURE, 0);\r\ninput_sync(input);\r\nif (ts->clear_penirq)\r\nts->clear_penirq();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t tsc2007_hard_irq(int irq, void *handle)\r\n{\r\nstruct tsc2007 *ts = handle;\r\nif (!ts->get_pendown_state || likely(ts->get_pendown_state()))\r\nreturn IRQ_WAKE_THREAD;\r\nif (ts->clear_penirq)\r\nts->clear_penirq();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tsc2007_stop(struct tsc2007 *ts)\r\n{\r\nts->stopped = true;\r\nmb();\r\nwake_up(&ts->wait);\r\ndisable_irq(ts->irq);\r\n}\r\nstatic int tsc2007_open(struct input_dev *input_dev)\r\n{\r\nstruct tsc2007 *ts = input_get_drvdata(input_dev);\r\nint err;\r\nts->stopped = false;\r\nmb();\r\nenable_irq(ts->irq);\r\nerr = tsc2007_xfer(ts, PWRDOWN);\r\nif (err < 0) {\r\ntsc2007_stop(ts);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tsc2007_close(struct input_dev *input_dev)\r\n{\r\nstruct tsc2007 *ts = input_get_drvdata(input_dev);\r\ntsc2007_stop(ts);\r\n}\r\nstatic int __devinit tsc2007_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tsc2007 *ts;\r\nstruct tsc2007_platform_data *pdata = client->dev.platform_data;\r\nstruct input_dev *input_dev;\r\nint err;\r\nif (!pdata) {\r\ndev_err(&client->dev, "platform data is required!\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_WORD_DATA))\r\nreturn -EIO;\r\nts = kzalloc(sizeof(struct tsc2007), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!ts || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nts->client = client;\r\nts->irq = client->irq;\r\nts->input = input_dev;\r\ninit_waitqueue_head(&ts->wait);\r\nts->model = pdata->model;\r\nts->x_plate_ohms = pdata->x_plate_ohms;\r\nts->max_rt = pdata->max_rt ? : MAX_12BIT;\r\nts->poll_delay = pdata->poll_delay ? : 1;\r\nts->poll_period = pdata->poll_period ? : 1;\r\nts->get_pendown_state = pdata->get_pendown_state;\r\nts->clear_penirq = pdata->clear_penirq;\r\nif (pdata->x_plate_ohms == 0) {\r\ndev_err(&client->dev, "x_plate_ohms is not set up in platform data");\r\nerr = -EINVAL;\r\ngoto err_free_mem;\r\n}\r\nsnprintf(ts->phys, sizeof(ts->phys),\r\n"%s/input0", dev_name(&client->dev));\r\ninput_dev->name = "TSC2007 Touchscreen";\r\ninput_dev->phys = ts->phys;\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->open = tsc2007_open;\r\ninput_dev->close = tsc2007_close;\r\ninput_set_drvdata(input_dev, ts);\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, pdata->fuzzx, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, pdata->fuzzy, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, 0, MAX_12BIT,\r\npdata->fuzzz, 0);\r\nif (pdata->init_platform_hw)\r\npdata->init_platform_hw();\r\nerr = request_threaded_irq(ts->irq, tsc2007_hard_irq, tsc2007_soft_irq,\r\nIRQF_ONESHOT, client->dev.driver->name, ts);\r\nif (err < 0) {\r\ndev_err(&client->dev, "irq %d busy?\n", ts->irq);\r\ngoto err_free_mem;\r\n}\r\ntsc2007_stop(ts);\r\nerr = input_register_device(input_dev);\r\nif (err)\r\ngoto err_free_irq;\r\ni2c_set_clientdata(client, ts);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(ts->irq, ts);\r\nif (pdata->exit_platform_hw)\r\npdata->exit_platform_hw();\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(ts);\r\nreturn err;\r\n}\r\nstatic int __devexit tsc2007_remove(struct i2c_client *client)\r\n{\r\nstruct tsc2007 *ts = i2c_get_clientdata(client);\r\nstruct tsc2007_platform_data *pdata = client->dev.platform_data;\r\nfree_irq(ts->irq, ts);\r\nif (pdata->exit_platform_hw)\r\npdata->exit_platform_hw();\r\ninput_unregister_device(ts->input);\r\nkfree(ts);\r\nreturn 0;\r\n}\r\nstatic int __init tsc2007_init(void)\r\n{\r\nreturn i2c_add_driver(&tsc2007_driver);\r\n}\r\nstatic void __exit tsc2007_exit(void)\r\n{\r\ni2c_del_driver(&tsc2007_driver);\r\n}
