static inline sector_t nr_sects(struct partition *p)\r\n{\r\nreturn (sector_t)get_unaligned_le32(&p->nr_sects);\r\n}\r\nstatic inline sector_t start_sect(struct partition *p)\r\n{\r\nreturn (sector_t)get_unaligned_le32(&p->start_sect);\r\n}\r\nstatic inline int is_extended_partition(struct partition *p)\r\n{\r\nreturn (SYS_IND(p) == DOS_EXTENDED_PARTITION ||\r\nSYS_IND(p) == WIN98_EXTENDED_PARTITION ||\r\nSYS_IND(p) == LINUX_EXTENDED_PARTITION);\r\n}\r\nstatic inline int\r\nmsdos_magic_present(unsigned char *p)\r\n{\r\nreturn (p[0] == MSDOS_LABEL_MAGIC1 && p[1] == MSDOS_LABEL_MAGIC2);\r\n}\r\nstatic int aix_magic_present(struct parsed_partitions *state, unsigned char *p)\r\n{\r\nstruct partition *pt = (struct partition *) (p + 0x1be);\r\nSector sect;\r\nunsigned char *d;\r\nint slot, ret = 0;\r\nif (!(p[0] == AIX_LABEL_MAGIC1 &&\r\np[1] == AIX_LABEL_MAGIC2 &&\r\np[2] == AIX_LABEL_MAGIC3 &&\r\np[3] == AIX_LABEL_MAGIC4))\r\nreturn 0;\r\nfor (slot = 1; slot <= 4; slot++, pt++) {\r\nif (pt->sys_ind == LINUX_SWAP_PARTITION ||\r\npt->sys_ind == LINUX_RAID_PARTITION ||\r\npt->sys_ind == LINUX_DATA_PARTITION ||\r\npt->sys_ind == LINUX_LVM_PARTITION ||\r\nis_extended_partition(pt))\r\nreturn 0;\r\n}\r\nd = read_part_sector(state, 7, &sect);\r\nif (d) {\r\nif (d[0] == '_' && d[1] == 'L' && d[2] == 'V' && d[3] == 'M')\r\nret = 1;\r\nput_dev_sector(sect);\r\n};\r\nreturn ret;\r\n}\r\nstatic void parse_extended(struct parsed_partitions *state,\r\nsector_t first_sector, sector_t first_size)\r\n{\r\nstruct partition *p;\r\nSector sect;\r\nunsigned char *data;\r\nsector_t this_sector, this_size;\r\nsector_t sector_size = bdev_logical_block_size(state->bdev) / 512;\r\nint loopct = 0;\r\nint i;\r\nthis_sector = first_sector;\r\nthis_size = first_size;\r\nwhile (1) {\r\nif (++loopct > 100)\r\nreturn;\r\nif (state->next == state->limit)\r\nreturn;\r\ndata = read_part_sector(state, this_sector, &sect);\r\nif (!data)\r\nreturn;\r\nif (!msdos_magic_present(data + 510))\r\ngoto done;\r\np = (struct partition *) (data + 0x1be);\r\nfor (i=0; i<4; i++, p++) {\r\nsector_t offs, size, next;\r\nif (!nr_sects(p) || is_extended_partition(p))\r\ncontinue;\r\noffs = start_sect(p)*sector_size;\r\nsize = nr_sects(p)*sector_size;\r\nnext = this_sector + offs;\r\nif (i >= 2) {\r\nif (offs + size > this_size)\r\ncontinue;\r\nif (next < first_sector)\r\ncontinue;\r\nif (next + size > first_sector + first_size)\r\ncontinue;\r\n}\r\nput_partition(state, state->next, next, size);\r\nif (SYS_IND(p) == LINUX_RAID_PARTITION)\r\nstate->parts[state->next].flags = ADDPART_FLAG_RAID;\r\nloopct = 0;\r\nif (++state->next == state->limit)\r\ngoto done;\r\n}\r\np -= 4;\r\nfor (i=0; i<4; i++, p++)\r\nif (nr_sects(p) && is_extended_partition(p))\r\nbreak;\r\nif (i == 4)\r\ngoto done;\r\nthis_sector = first_sector + start_sect(p) * sector_size;\r\nthis_size = nr_sects(p) * sector_size;\r\nput_dev_sector(sect);\r\n}\r\ndone:\r\nput_dev_sector(sect);\r\n}\r\nstatic void parse_solaris_x86(struct parsed_partitions *state,\r\nsector_t offset, sector_t size, int origin)\r\n{\r\n#ifdef CONFIG_SOLARIS_X86_PARTITION\r\nSector sect;\r\nstruct solaris_x86_vtoc *v;\r\nint i;\r\nshort max_nparts;\r\nv = read_part_sector(state, offset + 1, &sect);\r\nif (!v)\r\nreturn;\r\nif (le32_to_cpu(v->v_sanity) != SOLARIS_X86_VTOC_SANE) {\r\nput_dev_sector(sect);\r\nreturn;\r\n}\r\n{\r\nchar tmp[1 + BDEVNAME_SIZE + 10 + 11 + 1];\r\nsnprintf(tmp, sizeof(tmp), " %s%d: <solaris:", state->name, origin);\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\n}\r\nif (le32_to_cpu(v->v_version) != 1) {\r\nchar tmp[64];\r\nsnprintf(tmp, sizeof(tmp), " cannot handle version %d vtoc>\n",\r\nle32_to_cpu(v->v_version));\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\nput_dev_sector(sect);\r\nreturn;\r\n}\r\nmax_nparts = le16_to_cpu (v->v_nparts) > 8 ? SOLARIS_X86_NUMSLICE : 8;\r\nfor (i=0; i<max_nparts && state->next<state->limit; i++) {\r\nstruct solaris_x86_slice *s = &v->v_slice[i];\r\nchar tmp[3 + 10 + 1 + 1];\r\nif (s->s_size == 0)\r\ncontinue;\r\nsnprintf(tmp, sizeof(tmp), " [s%d]", i);\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\nput_partition(state, state->next++,\r\nle32_to_cpu(s->s_start)+offset,\r\nle32_to_cpu(s->s_size));\r\n}\r\nput_dev_sector(sect);\r\nstrlcat(state->pp_buf, " >\n", PAGE_SIZE);\r\n#endif\r\n}\r\nstatic void parse_bsd(struct parsed_partitions *state,\r\nsector_t offset, sector_t size, int origin, char *flavour,\r\nint max_partitions)\r\n{\r\nSector sect;\r\nstruct bsd_disklabel *l;\r\nstruct bsd_partition *p;\r\nchar tmp[64];\r\nl = read_part_sector(state, offset + 1, &sect);\r\nif (!l)\r\nreturn;\r\nif (le32_to_cpu(l->d_magic) != BSD_DISKMAGIC) {\r\nput_dev_sector(sect);\r\nreturn;\r\n}\r\nsnprintf(tmp, sizeof(tmp), " %s%d: <%s:", state->name, origin, flavour);\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\nif (le16_to_cpu(l->d_npartitions) < max_partitions)\r\nmax_partitions = le16_to_cpu(l->d_npartitions);\r\nfor (p = l->d_partitions; p - l->d_partitions < max_partitions; p++) {\r\nsector_t bsd_start, bsd_size;\r\nif (state->next == state->limit)\r\nbreak;\r\nif (p->p_fstype == BSD_FS_UNUSED)\r\ncontinue;\r\nbsd_start = le32_to_cpu(p->p_offset);\r\nbsd_size = le32_to_cpu(p->p_size);\r\nif (offset == bsd_start && size == bsd_size)\r\ncontinue;\r\nif (offset > bsd_start || offset+size < bsd_start+bsd_size) {\r\nstrlcat(state->pp_buf, "bad subpartition - ignored\n", PAGE_SIZE);\r\ncontinue;\r\n}\r\nput_partition(state, state->next++, bsd_start, bsd_size);\r\n}\r\nput_dev_sector(sect);\r\nif (le16_to_cpu(l->d_npartitions) > max_partitions) {\r\nsnprintf(tmp, sizeof(tmp), " (ignored %d more)",\r\nle16_to_cpu(l->d_npartitions) - max_partitions);\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\n}\r\nstrlcat(state->pp_buf, " >\n", PAGE_SIZE);\r\n}\r\nstatic void parse_freebsd(struct parsed_partitions *state,\r\nsector_t offset, sector_t size, int origin)\r\n{\r\n#ifdef CONFIG_BSD_DISKLABEL\r\nparse_bsd(state, offset, size, origin, "bsd", BSD_MAXPARTITIONS);\r\n#endif\r\n}\r\nstatic void parse_netbsd(struct parsed_partitions *state,\r\nsector_t offset, sector_t size, int origin)\r\n{\r\n#ifdef CONFIG_BSD_DISKLABEL\r\nparse_bsd(state, offset, size, origin, "netbsd", BSD_MAXPARTITIONS);\r\n#endif\r\n}\r\nstatic void parse_openbsd(struct parsed_partitions *state,\r\nsector_t offset, sector_t size, int origin)\r\n{\r\n#ifdef CONFIG_BSD_DISKLABEL\r\nparse_bsd(state, offset, size, origin, "openbsd",\r\nOPENBSD_MAXPARTITIONS);\r\n#endif\r\n}\r\nstatic void parse_unixware(struct parsed_partitions *state,\r\nsector_t offset, sector_t size, int origin)\r\n{\r\n#ifdef CONFIG_UNIXWARE_DISKLABEL\r\nSector sect;\r\nstruct unixware_disklabel *l;\r\nstruct unixware_slice *p;\r\nl = read_part_sector(state, offset + 29, &sect);\r\nif (!l)\r\nreturn;\r\nif (le32_to_cpu(l->d_magic) != UNIXWARE_DISKMAGIC ||\r\nle32_to_cpu(l->vtoc.v_magic) != UNIXWARE_DISKMAGIC2) {\r\nput_dev_sector(sect);\r\nreturn;\r\n}\r\n{\r\nchar tmp[1 + BDEVNAME_SIZE + 10 + 12 + 1];\r\nsnprintf(tmp, sizeof(tmp), " %s%d: <unixware:", state->name, origin);\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\n}\r\np = &l->vtoc.v_slice[1];\r\nwhile (p - &l->vtoc.v_slice[0] < UNIXWARE_NUMSLICE) {\r\nif (state->next == state->limit)\r\nbreak;\r\nif (p->s_label != UNIXWARE_FS_UNUSED)\r\nput_partition(state, state->next++,\r\nle32_to_cpu(p->start_sect),\r\nle32_to_cpu(p->nr_sects));\r\np++;\r\n}\r\nput_dev_sector(sect);\r\nstrlcat(state->pp_buf, " >\n", PAGE_SIZE);\r\n#endif\r\n}\r\nstatic void parse_minix(struct parsed_partitions *state,\r\nsector_t offset, sector_t size, int origin)\r\n{\r\n#ifdef CONFIG_MINIX_SUBPARTITION\r\nSector sect;\r\nunsigned char *data;\r\nstruct partition *p;\r\nint i;\r\ndata = read_part_sector(state, offset, &sect);\r\nif (!data)\r\nreturn;\r\np = (struct partition *)(data + 0x1be);\r\nif (msdos_magic_present (data + 510) &&\r\nSYS_IND(p) == MINIX_PARTITION) {\r\nchar tmp[1 + BDEVNAME_SIZE + 10 + 9 + 1];\r\nsnprintf(tmp, sizeof(tmp), " %s%d: <minix:", state->name, origin);\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\nfor (i = 0; i < MINIX_NR_SUBPARTITIONS; i++, p++) {\r\nif (state->next == state->limit)\r\nbreak;\r\nif (SYS_IND(p) == MINIX_PARTITION)\r\nput_partition(state, state->next++,\r\nstart_sect(p), nr_sects(p));\r\n}\r\nstrlcat(state->pp_buf, " >\n", PAGE_SIZE);\r\n}\r\nput_dev_sector(sect);\r\n#endif\r\n}\r\nint msdos_partition(struct parsed_partitions *state)\r\n{\r\nsector_t sector_size = bdev_logical_block_size(state->bdev) / 512;\r\nSector sect;\r\nunsigned char *data;\r\nstruct partition *p;\r\nstruct fat_boot_sector *fb;\r\nint slot;\r\ndata = read_part_sector(state, 0, &sect);\r\nif (!data)\r\nreturn -1;\r\nif (!msdos_magic_present(data + 510)) {\r\nput_dev_sector(sect);\r\nreturn 0;\r\n}\r\nif (aix_magic_present(state, data)) {\r\nput_dev_sector(sect);\r\nstrlcat(state->pp_buf, " [AIX]", PAGE_SIZE);\r\nreturn 0;\r\n}\r\np = (struct partition *) (data + 0x1be);\r\nfor (slot = 1; slot <= 4; slot++, p++) {\r\nif (p->boot_ind != 0 && p->boot_ind != 0x80) {\r\nfb = (struct fat_boot_sector *) data;\r\nif (slot == 1 && fb->reserved && fb->fats\r\n&& fat_valid_media(fb->media)) {\r\nstrlcat(state->pp_buf, "\n", PAGE_SIZE);\r\nput_dev_sector(sect);\r\nreturn 1;\r\n} else {\r\nput_dev_sector(sect);\r\nreturn 0;\r\n}\r\n}\r\n}\r\n#ifdef CONFIG_EFI_PARTITION\r\np = (struct partition *) (data + 0x1be);\r\nfor (slot = 1 ; slot <= 4 ; slot++, p++) {\r\nif (SYS_IND(p) == EFI_PMBR_OSTYPE_EFI_GPT) {\r\nput_dev_sector(sect);\r\nreturn 0;\r\n}\r\n}\r\n#endif\r\np = (struct partition *) (data + 0x1be);\r\nstate->next = 5;\r\nfor (slot = 1 ; slot <= 4 ; slot++, p++) {\r\nsector_t start = start_sect(p)*sector_size;\r\nsector_t size = nr_sects(p)*sector_size;\r\nif (!size)\r\ncontinue;\r\nif (is_extended_partition(p)) {\r\nsector_t n = 2;\r\nn = min(size, max(sector_size, n));\r\nput_partition(state, slot, start, n);\r\nstrlcat(state->pp_buf, " <", PAGE_SIZE);\r\nparse_extended(state, start, size);\r\nstrlcat(state->pp_buf, " >", PAGE_SIZE);\r\ncontinue;\r\n}\r\nput_partition(state, slot, start, size);\r\nif (SYS_IND(p) == LINUX_RAID_PARTITION)\r\nstate->parts[slot].flags = ADDPART_FLAG_RAID;\r\nif (SYS_IND(p) == DM6_PARTITION)\r\nstrlcat(state->pp_buf, "[DM]", PAGE_SIZE);\r\nif (SYS_IND(p) == EZD_PARTITION)\r\nstrlcat(state->pp_buf, "[EZD]", PAGE_SIZE);\r\n}\r\nstrlcat(state->pp_buf, "\n", PAGE_SIZE);\r\np = (struct partition *) (0x1be + data);\r\nfor (slot = 1 ; slot <= 4 ; slot++, p++) {\r\nunsigned char id = SYS_IND(p);\r\nint n;\r\nif (!nr_sects(p))\r\ncontinue;\r\nfor (n = 0; subtypes[n].parse && id != subtypes[n].id; n++)\r\n;\r\nif (!subtypes[n].parse)\r\ncontinue;\r\nsubtypes[n].parse(state, start_sect(p) * sector_size,\r\nnr_sects(p) * sector_size, slot);\r\n}\r\nput_dev_sector(sect);\r\nreturn 1;\r\n}
