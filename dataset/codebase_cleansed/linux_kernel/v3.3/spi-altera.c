static inline struct altera_spi *altera_spi_to_hw(struct spi_device *sdev)\r\n{\r\nreturn spi_master_get_devdata(sdev->master);\r\n}\r\nstatic void altera_spi_chipsel(struct spi_device *spi, int value)\r\n{\r\nstruct altera_spi *hw = altera_spi_to_hw(spi);\r\nif (spi->mode & SPI_CS_HIGH) {\r\nswitch (value) {\r\ncase BITBANG_CS_INACTIVE:\r\nwritel(1 << spi->chip_select,\r\nhw->base + ALTERA_SPI_SLAVE_SEL);\r\nhw->imr |= ALTERA_SPI_CONTROL_SSO_MSK;\r\nwritel(hw->imr, hw->base + ALTERA_SPI_CONTROL);\r\nbreak;\r\ncase BITBANG_CS_ACTIVE:\r\nhw->imr &= ~ALTERA_SPI_CONTROL_SSO_MSK;\r\nwritel(hw->imr, hw->base + ALTERA_SPI_CONTROL);\r\nwritel(0, hw->base + ALTERA_SPI_SLAVE_SEL);\r\nbreak;\r\n}\r\n} else {\r\nswitch (value) {\r\ncase BITBANG_CS_INACTIVE:\r\nhw->imr &= ~ALTERA_SPI_CONTROL_SSO_MSK;\r\nwritel(hw->imr, hw->base + ALTERA_SPI_CONTROL);\r\nbreak;\r\ncase BITBANG_CS_ACTIVE:\r\nwritel(1 << spi->chip_select,\r\nhw->base + ALTERA_SPI_SLAVE_SEL);\r\nhw->imr |= ALTERA_SPI_CONTROL_SSO_MSK;\r\nwritel(hw->imr, hw->base + ALTERA_SPI_CONTROL);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int altera_spi_setupxfer(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nreturn 0;\r\n}\r\nstatic int altera_spi_setup(struct spi_device *spi)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline unsigned int hw_txbyte(struct altera_spi *hw, int count)\r\n{\r\nif (hw->tx) {\r\nswitch (hw->bytes_per_word) {\r\ncase 1:\r\nreturn hw->tx[count];\r\ncase 2:\r\nreturn (hw->tx[count * 2]\r\n| (hw->tx[count * 2 + 1] << 8));\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int altera_spi_txrx(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct altera_spi *hw = altera_spi_to_hw(spi);\r\nhw->tx = t->tx_buf;\r\nhw->rx = t->rx_buf;\r\nhw->count = 0;\r\nhw->bytes_per_word = (t->bits_per_word ? : spi->bits_per_word) / 8;\r\nhw->len = t->len / hw->bytes_per_word;\r\nif (hw->irq >= 0) {\r\nhw->imr |= ALTERA_SPI_CONTROL_IRRDY_MSK;\r\nwritel(hw->imr, hw->base + ALTERA_SPI_CONTROL);\r\nwritel(hw_txbyte(hw, 0), hw->base + ALTERA_SPI_TXDATA);\r\nwait_for_completion(&hw->done);\r\nhw->imr &= ~ALTERA_SPI_CONTROL_IRRDY_MSK;\r\nwritel(hw->imr, hw->base + ALTERA_SPI_CONTROL);\r\n} else {\r\nwritel(hw_txbyte(hw, 0), hw->base + ALTERA_SPI_TXDATA);\r\nwhile (1) {\r\nunsigned int rxd;\r\nwhile (!(readl(hw->base + ALTERA_SPI_STATUS) &\r\nALTERA_SPI_STATUS_RRDY_MSK))\r\ncpu_relax();\r\nrxd = readl(hw->base + ALTERA_SPI_RXDATA);\r\nif (hw->rx) {\r\nswitch (hw->bytes_per_word) {\r\ncase 1:\r\nhw->rx[hw->count] = rxd;\r\nbreak;\r\ncase 2:\r\nhw->rx[hw->count * 2] = rxd;\r\nhw->rx[hw->count * 2 + 1] = rxd >> 8;\r\nbreak;\r\n}\r\n}\r\nhw->count++;\r\nif (hw->count < hw->len)\r\nwritel(hw_txbyte(hw, hw->count),\r\nhw->base + ALTERA_SPI_TXDATA);\r\nelse\r\nbreak;\r\n}\r\n}\r\nreturn hw->count * hw->bytes_per_word;\r\n}\r\nstatic irqreturn_t altera_spi_irq(int irq, void *dev)\r\n{\r\nstruct altera_spi *hw = dev;\r\nunsigned int rxd;\r\nrxd = readl(hw->base + ALTERA_SPI_RXDATA);\r\nif (hw->rx) {\r\nswitch (hw->bytes_per_word) {\r\ncase 1:\r\nhw->rx[hw->count] = rxd;\r\nbreak;\r\ncase 2:\r\nhw->rx[hw->count * 2] = rxd;\r\nhw->rx[hw->count * 2 + 1] = rxd >> 8;\r\nbreak;\r\n}\r\n}\r\nhw->count++;\r\nif (hw->count < hw->len)\r\nwritel(hw_txbyte(hw, hw->count), hw->base + ALTERA_SPI_TXDATA);\r\nelse\r\ncomplete(&hw->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit altera_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct altera_spi_platform_data *platp = pdev->dev.platform_data;\r\nstruct altera_spi *hw;\r\nstruct spi_master *master;\r\nstruct resource *res;\r\nint err = -ENODEV;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct altera_spi));\r\nif (!master)\r\nreturn err;\r\nmaster->bus_num = pdev->id;\r\nmaster->num_chipselect = 16;\r\nmaster->mode_bits = SPI_CS_HIGH;\r\nmaster->setup = altera_spi_setup;\r\nhw = spi_master_get_devdata(master);\r\nplatform_set_drvdata(pdev, hw);\r\nhw->bitbang.master = spi_master_get(master);\r\nif (!hw->bitbang.master)\r\nreturn err;\r\nhw->bitbang.setup_transfer = altera_spi_setupxfer;\r\nhw->bitbang.chipselect = altera_spi_chipsel;\r\nhw->bitbang.txrx_bufs = altera_spi_txrx;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\ngoto exit_busy;\r\nif (!devm_request_mem_region(&pdev->dev, res->start, resource_size(res),\r\npdev->name))\r\ngoto exit_busy;\r\nhw->base = devm_ioremap_nocache(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!hw->base)\r\ngoto exit_busy;\r\nhw->imr = 0;\r\nwritel(hw->imr, hw->base + ALTERA_SPI_CONTROL);\r\nwritel(0, hw->base + ALTERA_SPI_STATUS);\r\nif (readl(hw->base + ALTERA_SPI_STATUS) & ALTERA_SPI_STATUS_RRDY_MSK)\r\nreadl(hw->base + ALTERA_SPI_RXDATA);\r\nhw->irq = platform_get_irq(pdev, 0);\r\nif (hw->irq >= 0) {\r\ninit_completion(&hw->done);\r\nerr = devm_request_irq(&pdev->dev, hw->irq, altera_spi_irq, 0,\r\npdev->name, hw);\r\nif (err)\r\ngoto exit;\r\n}\r\nif (!platp)\r\nhw->bitbang.master->dev.of_node = pdev->dev.of_node;\r\nerr = spi_bitbang_start(&hw->bitbang);\r\nif (err)\r\ngoto exit;\r\ndev_info(&pdev->dev, "base %p, irq %d\n", hw->base, hw->irq);\r\nreturn 0;\r\nexit_busy:\r\nerr = -EBUSY;\r\nexit:\r\nplatform_set_drvdata(pdev, NULL);\r\nspi_master_put(master);\r\nreturn err;\r\n}\r\nstatic int __devexit altera_spi_remove(struct platform_device *dev)\r\n{\r\nstruct altera_spi *hw = platform_get_drvdata(dev);\r\nstruct spi_master *master = hw->bitbang.master;\r\nspi_bitbang_stop(&hw->bitbang);\r\nplatform_set_drvdata(dev, NULL);\r\nspi_master_put(master);\r\nreturn 0;\r\n}
