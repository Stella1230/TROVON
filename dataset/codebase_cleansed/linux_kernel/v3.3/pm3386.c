static u16 pm3386_reg_read(int pm, int reg)\r\n{\r\nvoid *_reg;\r\nu16 value;\r\n_reg = (void *)ENP2611_PM3386_0_VIRT_BASE;\r\nif (pm == 1)\r\n_reg = (void *)ENP2611_PM3386_1_VIRT_BASE;\r\nvalue = *((volatile u16 *)(_reg + (reg << 1)));\r\nreturn value;\r\n}\r\nstatic void pm3386_reg_write(int pm, int reg, u16 value)\r\n{\r\nvoid *_reg;\r\nu16 dummy;\r\n_reg = (void *)ENP2611_PM3386_0_VIRT_BASE;\r\nif (pm == 1)\r\n_reg = (void *)ENP2611_PM3386_1_VIRT_BASE;\r\n*((volatile u16 *)(_reg + (reg << 1))) = value;\r\ndummy = *((volatile u16 *)_reg);\r\n__asm__ __volatile__("mov %0, %0" : "+r" (dummy));\r\n}\r\nstatic u16 pm3386_port_reg_read(int port, int _reg, int spacing)\r\n{\r\nint reg;\r\nreg = _reg;\r\nif (port & 1)\r\nreg += spacing;\r\nreturn pm3386_reg_read(port >> 1, reg);\r\n}\r\nstatic void pm3386_port_reg_write(int port, int _reg, int spacing, u16 value)\r\n{\r\nint reg;\r\nreg = _reg;\r\nif (port & 1)\r\nreg += spacing;\r\npm3386_reg_write(port >> 1, reg, value);\r\n}\r\nint pm3386_secondary_present(void)\r\n{\r\nreturn pm3386_reg_read(1, 0) == 0x3386;\r\n}\r\nvoid pm3386_reset(void)\r\n{\r\nu8 mac[3][6];\r\nint secondary;\r\nsecondary = pm3386_secondary_present();\r\npm3386_get_mac(0, mac[0]);\r\npm3386_get_mac(1, mac[1]);\r\nif (secondary)\r\npm3386_get_mac(2, mac[2]);\r\npm3386_reg_write(0, 0x002, 0x0060);\r\nif (secondary)\r\npm3386_reg_write(1, 0x002, 0x0060);\r\nmdelay(1);\r\npm3386_reg_write(0, 0x002, 0x0062);\r\nif (secondary)\r\npm3386_reg_write(1, 0x002, 0x0062);\r\nmdelay(10);\r\npm3386_reg_write(0, 0x002, 0x0063);\r\nif (secondary)\r\npm3386_reg_write(1, 0x002, 0x0063);\r\nmdelay(10);\r\npm3386_set_mac(0, mac[0]);\r\npm3386_set_mac(1, mac[1]);\r\nif (secondary)\r\npm3386_set_mac(2, mac[2]);\r\npm3386_set_carrier(0, 0);\r\npm3386_set_carrier(1, 0);\r\nif (secondary)\r\npm3386_set_carrier(2, 0);\r\n}\r\nstatic u16 swaph(u16 x)\r\n{\r\nreturn ((x << 8) | (x >> 8)) & 0xffff;\r\n}\r\nint pm3386_port_count(void)\r\n{\r\nreturn 2 + pm3386_secondary_present();\r\n}\r\nvoid pm3386_init_port(int port)\r\n{\r\nint pm = port >> 1;\r\nif (pm3386_port_reg_read(port, 0x30a, 0x100) == 0x0000 &&\r\n(pm3386_port_reg_read(port, 0x309, 0x100) & 0xff00) == 0x5000) {\r\nu16 temp[3];\r\ntemp[0] = pm3386_port_reg_read(port, 0x308, 0x100);\r\ntemp[1] = pm3386_port_reg_read(port, 0x309, 0x100);\r\ntemp[2] = pm3386_port_reg_read(port, 0x30a, 0x100);\r\npm3386_port_reg_write(port, 0x308, 0x100, swaph(temp[2]));\r\npm3386_port_reg_write(port, 0x309, 0x100, swaph(temp[1]));\r\npm3386_port_reg_write(port, 0x30a, 0x100, swaph(temp[0]));\r\n}\r\npm3386_port_reg_write(port, 0x708, 0x10, 0xd055);\r\nudelay(500);\r\npm3386_port_reg_write(port, 0x708, 0x10, 0x5055);\r\npm3386_port_reg_write(port, 0x122, 0x20, 0x0002);\r\npm3386_reg_write(pm, 0x103, 0x0003);\r\nwhile (!(pm3386_reg_read(pm, 0x103) & 0x80))\r\n;\r\npm3386_port_reg_write(port, 0x221, 0x20, 0x0007);\r\npm3386_reg_write(pm, 0x203, 0x000d & ~(4 << (port & 1)));\r\nwhile ((pm3386_reg_read(pm, 0x203) & 0x000c) != 0x000c)\r\n;\r\npm3386_port_reg_write(port, 0x302, 0x100, 0x0113);\r\npm3386_port_reg_write(port, 0x301, 0x100, 0x8000);\r\npm3386_port_reg_write(port, 0x301, 0x100, 0x0000);\r\npm3386_port_reg_write(port, 0x306, 0x100, 0x0100);\r\npm3386_port_reg_write(port, 0x310, 0x100, 9018);\r\npm3386_port_reg_write(port, 0x336, 0x100, 9018);\r\npm3386_port_reg_write(port, 0x31c, 0x100, 0x0020);\r\npm3386_port_reg_write(port, 0x318, 0x100, 0x0003);\r\npm3386_port_reg_write(port, 0x318, 0x100, 0x0002);\r\n}\r\nvoid pm3386_get_mac(int port, u8 *mac)\r\n{\r\nu16 temp;\r\ntemp = pm3386_port_reg_read(port, 0x308, 0x100);\r\nmac[0] = temp & 0xff;\r\nmac[1] = (temp >> 8) & 0xff;\r\ntemp = pm3386_port_reg_read(port, 0x309, 0x100);\r\nmac[2] = temp & 0xff;\r\nmac[3] = (temp >> 8) & 0xff;\r\ntemp = pm3386_port_reg_read(port, 0x30a, 0x100);\r\nmac[4] = temp & 0xff;\r\nmac[5] = (temp >> 8) & 0xff;\r\n}\r\nvoid pm3386_set_mac(int port, u8 *mac)\r\n{\r\npm3386_port_reg_write(port, 0x308, 0x100, (mac[1] << 8) | mac[0]);\r\npm3386_port_reg_write(port, 0x309, 0x100, (mac[3] << 8) | mac[2]);\r\npm3386_port_reg_write(port, 0x30a, 0x100, (mac[5] << 8) | mac[4]);\r\n}\r\nstatic u32 pm3386_get_stat(int port, u16 base)\r\n{\r\nu32 value;\r\nvalue = pm3386_port_reg_read(port, base, 0x100);\r\nvalue |= pm3386_port_reg_read(port, base + 1, 0x100) << 16;\r\nreturn value;\r\n}\r\nvoid pm3386_get_stats(int port, struct net_device_stats *stats)\r\n{\r\npm3386_port_reg_write(port, 0x500, 0x100, 0x0001);\r\nwhile (pm3386_port_reg_read(port, 0x500, 0x100) & 0x0001)\r\n;\r\nmemset(stats, 0, sizeof(*stats));\r\nstats->rx_packets = pm3386_get_stat(port, 0x510);\r\nstats->tx_packets = pm3386_get_stat(port, 0x590);\r\nstats->rx_bytes = pm3386_get_stat(port, 0x514);\r\nstats->tx_bytes = pm3386_get_stat(port, 0x594);\r\n}\r\nvoid pm3386_set_carrier(int port, int state)\r\n{\r\npm3386_port_reg_write(port, 0x703, 0x10, state ? 0x1001 : 0x0000);\r\n}\r\nint pm3386_is_link_up(int port)\r\n{\r\nu16 temp;\r\ntemp = pm3386_port_reg_read(port, 0x31a, 0x100);\r\ntemp = pm3386_port_reg_read(port, 0x31a, 0x100);\r\nreturn !!(temp & 0x0002);\r\n}\r\nvoid pm3386_enable_rx(int port)\r\n{\r\nu16 temp;\r\ntemp = pm3386_port_reg_read(port, 0x303, 0x100);\r\ntemp |= 0x1000;\r\npm3386_port_reg_write(port, 0x303, 0x100, temp);\r\n}\r\nvoid pm3386_disable_rx(int port)\r\n{\r\nu16 temp;\r\ntemp = pm3386_port_reg_read(port, 0x303, 0x100);\r\ntemp &= 0xefff;\r\npm3386_port_reg_write(port, 0x303, 0x100, temp);\r\n}\r\nvoid pm3386_enable_tx(int port)\r\n{\r\nu16 temp;\r\ntemp = pm3386_port_reg_read(port, 0x303, 0x100);\r\ntemp |= 0x4000;\r\npm3386_port_reg_write(port, 0x303, 0x100, temp);\r\n}\r\nvoid pm3386_disable_tx(int port)\r\n{\r\nu16 temp;\r\ntemp = pm3386_port_reg_read(port, 0x303, 0x100);\r\ntemp &= 0xbfff;\r\npm3386_port_reg_write(port, 0x303, 0x100, temp);\r\n}
