static void snd_hda_generic_free(struct hda_codec *codec)\r\n{\r\nstruct hda_gspec *spec = codec->spec;\r\nstruct hda_gnode *node, *n;\r\nif (! spec)\r\nreturn;\r\nlist_for_each_entry_safe(node, n, &spec->nid_list, list) {\r\nif (node->conn_list != node->slist)\r\nkfree(node->conn_list);\r\nkfree(node);\r\n}\r\nkfree(spec);\r\n}\r\nstatic int add_new_node(struct hda_codec *codec, struct hda_gspec *spec, hda_nid_t nid)\r\n{\r\nstruct hda_gnode *node;\r\nint nconns;\r\nhda_nid_t conn_list[HDA_MAX_CONNECTIONS];\r\nnode = kzalloc(sizeof(*node), GFP_KERNEL);\r\nif (node == NULL)\r\nreturn -ENOMEM;\r\nnode->nid = nid;\r\nnode->wid_caps = get_wcaps(codec, nid);\r\nnode->type = get_wcaps_type(node->wid_caps);\r\nif (node->wid_caps & AC_WCAP_CONN_LIST) {\r\nnconns = snd_hda_get_connections(codec, nid, conn_list,\r\nHDA_MAX_CONNECTIONS);\r\nif (nconns < 0) {\r\nkfree(node);\r\nreturn nconns;\r\n}\r\n} else {\r\nnconns = 0;\r\n}\r\nif (nconns <= ARRAY_SIZE(node->slist))\r\nnode->conn_list = node->slist;\r\nelse {\r\nnode->conn_list = kmalloc(sizeof(hda_nid_t) * nconns,\r\nGFP_KERNEL);\r\nif (! node->conn_list) {\r\nsnd_printk(KERN_ERR "hda-generic: cannot malloc\n");\r\nkfree(node);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmemcpy(node->conn_list, conn_list, nconns * sizeof(hda_nid_t));\r\nnode->nconns = nconns;\r\nif (node->type == AC_WID_PIN) {\r\nnode->pin_caps = snd_hda_query_pin_caps(codec, node->nid);\r\nnode->pin_ctl = snd_hda_codec_read(codec, node->nid, 0, AC_VERB_GET_PIN_WIDGET_CONTROL, 0);\r\nnode->def_cfg = snd_hda_codec_get_pincfg(codec, node->nid);\r\n}\r\nif (node->wid_caps & AC_WCAP_OUT_AMP) {\r\nif (node->wid_caps & AC_WCAP_AMP_OVRD)\r\nnode->amp_out_caps = snd_hda_param_read(codec, node->nid, AC_PAR_AMP_OUT_CAP);\r\nif (! node->amp_out_caps)\r\nnode->amp_out_caps = spec->def_amp_out_caps;\r\n}\r\nif (node->wid_caps & AC_WCAP_IN_AMP) {\r\nif (node->wid_caps & AC_WCAP_AMP_OVRD)\r\nnode->amp_in_caps = snd_hda_param_read(codec, node->nid, AC_PAR_AMP_IN_CAP);\r\nif (! node->amp_in_caps)\r\nnode->amp_in_caps = spec->def_amp_in_caps;\r\n}\r\nlist_add_tail(&node->list, &spec->nid_list);\r\nreturn 0;\r\n}\r\nstatic int build_afg_tree(struct hda_codec *codec)\r\n{\r\nstruct hda_gspec *spec = codec->spec;\r\nint i, nodes, err;\r\nhda_nid_t nid;\r\nif (snd_BUG_ON(!spec))\r\nreturn -EINVAL;\r\nspec->def_amp_out_caps = snd_hda_param_read(codec, codec->afg, AC_PAR_AMP_OUT_CAP);\r\nspec->def_amp_in_caps = snd_hda_param_read(codec, codec->afg, AC_PAR_AMP_IN_CAP);\r\nnodes = snd_hda_get_sub_nodes(codec, codec->afg, &nid);\r\nif (! nid || nodes < 0) {\r\nprintk(KERN_ERR "Invalid AFG subtree\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < nodes; i++, nid++) {\r\nif ((err = add_new_node(codec, spec, nid)) < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct hda_gnode *hda_get_node(struct hda_gspec *spec, hda_nid_t nid)\r\n{\r\nstruct hda_gnode *node;\r\nlist_for_each_entry(node, &spec->nid_list, list) {\r\nif (node->nid == nid)\r\nreturn node;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int unmute_output(struct hda_codec *codec, struct hda_gnode *node)\r\n{\r\nunsigned int val, ofs;\r\nsnd_printdd("UNMUTE OUT: NID=0x%x\n", node->nid);\r\nval = (node->amp_out_caps & AC_AMPCAP_NUM_STEPS) >> AC_AMPCAP_NUM_STEPS_SHIFT;\r\nofs = (node->amp_out_caps & AC_AMPCAP_OFFSET) >> AC_AMPCAP_OFFSET_SHIFT;\r\nif (val >= ofs)\r\nval -= ofs;\r\nsnd_hda_codec_amp_stereo(codec, node->nid, HDA_OUTPUT, 0, 0xff, val);\r\nreturn 0;\r\n}\r\nstatic int unmute_input(struct hda_codec *codec, struct hda_gnode *node, unsigned int index)\r\n{\r\nunsigned int val, ofs;\r\nsnd_printdd("UNMUTE IN: NID=0x%x IDX=0x%x\n", node->nid, index);\r\nval = (node->amp_in_caps & AC_AMPCAP_NUM_STEPS) >> AC_AMPCAP_NUM_STEPS_SHIFT;\r\nofs = (node->amp_in_caps & AC_AMPCAP_OFFSET) >> AC_AMPCAP_OFFSET_SHIFT;\r\nif (val >= ofs)\r\nval -= ofs;\r\nsnd_hda_codec_amp_stereo(codec, node->nid, HDA_INPUT, index, 0xff, val);\r\nreturn 0;\r\n}\r\nstatic int select_input_connection(struct hda_codec *codec, struct hda_gnode *node,\r\nunsigned int index)\r\n{\r\nsnd_printdd("CONNECT: NID=0x%x IDX=0x%x\n", node->nid, index);\r\nreturn snd_hda_codec_write_cache(codec, node->nid, 0,\r\nAC_VERB_SET_CONNECT_SEL, index);\r\n}\r\nstatic void clear_check_flags(struct hda_gspec *spec)\r\n{\r\nstruct hda_gnode *node;\r\nlist_for_each_entry(node, &spec->nid_list, list) {\r\nnode->checked = 0;\r\n}\r\n}\r\nstatic int parse_output_path(struct hda_codec *codec, struct hda_gspec *spec,\r\nstruct hda_gnode *node, int dac_idx)\r\n{\r\nint i, err;\r\nstruct hda_gnode *child;\r\nif (node->checked)\r\nreturn 0;\r\nnode->checked = 1;\r\nif (node->type == AC_WID_AUD_OUT) {\r\nif (node->wid_caps & AC_WCAP_DIGITAL) {\r\nsnd_printdd("Skip Digital OUT node %x\n", node->nid);\r\nreturn 0;\r\n}\r\nsnd_printdd("AUD_OUT found %x\n", node->nid);\r\nif (spec->dac_node[dac_idx]) {\r\nreturn node == spec->dac_node[dac_idx];\r\n}\r\nspec->dac_node[dac_idx] = node;\r\nif ((node->wid_caps & AC_WCAP_OUT_AMP) &&\r\nspec->pcm_vol_nodes < MAX_PCM_VOLS) {\r\nspec->pcm_vol[spec->pcm_vol_nodes].node = node;\r\nspec->pcm_vol[spec->pcm_vol_nodes].index = 0;\r\nspec->pcm_vol_nodes++;\r\n}\r\nreturn 1;\r\n}\r\nfor (i = 0; i < node->nconns; i++) {\r\nchild = hda_get_node(spec, node->conn_list[i]);\r\nif (! child)\r\ncontinue;\r\nerr = parse_output_path(codec, spec, child, dac_idx);\r\nif (err < 0)\r\nreturn err;\r\nelse if (err > 0) {\r\nif (node->nconns > 1)\r\nselect_input_connection(codec, node, i);\r\nunmute_input(codec, node, i);\r\nunmute_output(codec, node);\r\nif (spec->dac_node[dac_idx] &&\r\nspec->pcm_vol_nodes < MAX_PCM_VOLS &&\r\n!(spec->dac_node[dac_idx]->wid_caps &\r\nAC_WCAP_OUT_AMP)) {\r\nif ((node->wid_caps & AC_WCAP_IN_AMP) ||\r\n(node->wid_caps & AC_WCAP_OUT_AMP)) {\r\nint n = spec->pcm_vol_nodes;\r\nspec->pcm_vol[n].node = node;\r\nspec->pcm_vol[n].index = i;\r\nspec->pcm_vol_nodes++;\r\n}\r\n}\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct hda_gnode *parse_output_jack(struct hda_codec *codec,\r\nstruct hda_gspec *spec,\r\nint jack_type)\r\n{\r\nstruct hda_gnode *node;\r\nint err;\r\nlist_for_each_entry(node, &spec->nid_list, list) {\r\nif (node->type != AC_WID_PIN)\r\ncontinue;\r\nif (! (node->pin_caps & AC_PINCAP_OUT))\r\ncontinue;\r\nif (defcfg_port_conn(node) == AC_JACK_PORT_NONE)\r\ncontinue;\r\nif (jack_type >= 0) {\r\nif (jack_type != defcfg_type(node))\r\ncontinue;\r\nif (node->wid_caps & AC_WCAP_DIGITAL)\r\ncontinue;\r\n} else {\r\nif (! (node->pin_ctl & AC_PINCTL_OUT_EN))\r\ncontinue;\r\n}\r\nclear_check_flags(spec);\r\nerr = parse_output_path(codec, spec, node, 0);\r\nif (err < 0)\r\nreturn NULL;\r\nif (! err && spec->out_pin_node[0]) {\r\nerr = parse_output_path(codec, spec, node, 1);\r\nif (err < 0)\r\nreturn NULL;\r\n}\r\nif (err > 0) {\r\nunmute_output(codec, node);\r\nsnd_hda_codec_write_cache(codec, node->nid, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL,\r\nAC_PINCTL_OUT_EN |\r\n((node->pin_caps & AC_PINCAP_HP_DRV) ?\r\nAC_PINCTL_HP_EN : 0));\r\nreturn node;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int parse_output(struct hda_codec *codec)\r\n{\r\nstruct hda_gspec *spec = codec->spec;\r\nstruct hda_gnode *node;\r\nnode = parse_output_jack(codec, spec, AC_JACK_LINE_OUT);\r\nif (node)\r\nspec->out_pin_node[0] = node;\r\nelse {\r\nnode = parse_output_jack(codec, spec, AC_JACK_SPEAKER);\r\nif (node)\r\nspec->out_pin_node[0] = node;\r\n}\r\nnode = parse_output_jack(codec, spec, AC_JACK_HP_OUT);\r\nif (node) {\r\nif (! spec->out_pin_node[0])\r\nspec->out_pin_node[0] = node;\r\nelse\r\nspec->out_pin_node[1] = node;\r\n}\r\nif (! spec->out_pin_node[0]) {\r\nspec->out_pin_node[0] = parse_output_jack(codec, spec, -1);\r\nif (! spec->out_pin_node[0])\r\nsnd_printd("hda_generic: no proper output path found\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int capture_source_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gspec *spec = codec->spec;\r\nreturn snd_hda_input_mux_info(&spec->input_mux, uinfo);\r\n}\r\nstatic int capture_source_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gspec *spec = codec->spec;\r\nucontrol->value.enumerated.item[0] = spec->cur_cap_src;\r\nreturn 0;\r\n}\r\nstatic int capture_source_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gspec *spec = codec->spec;\r\nreturn snd_hda_input_mux_put(codec, &spec->input_mux, ucontrol,\r\nspec->adc_node->nid, &spec->cur_cap_src);\r\n}\r\nstatic const char *get_input_type(struct hda_gnode *node, unsigned int *pinctl)\r\n{\r\nunsigned int location = defcfg_location(node);\r\nswitch (defcfg_type(node)) {\r\ncase AC_JACK_LINE_IN:\r\nif ((location & 0x0f) == AC_JACK_LOC_FRONT)\r\nreturn "Front Line";\r\nreturn "Line";\r\ncase AC_JACK_CD:\r\n#if 0\r\nif (pinctl)\r\n*pinctl |= AC_PINCTL_VREF_GRD;\r\n#endif\r\nreturn "CD";\r\ncase AC_JACK_AUX:\r\nif ((location & 0x0f) == AC_JACK_LOC_FRONT)\r\nreturn "Front Aux";\r\nreturn "Aux";\r\ncase AC_JACK_MIC_IN:\r\nif (pinctl &&\r\n(node->pin_caps &\r\n(AC_PINCAP_VREF_80 << AC_PINCAP_VREF_SHIFT)))\r\n*pinctl |= AC_PINCTL_VREF_80;\r\nif ((location & 0x0f) == AC_JACK_LOC_FRONT)\r\nreturn "Front Mic";\r\nreturn "Mic";\r\ncase AC_JACK_SPDIF_IN:\r\nreturn "SPDIF";\r\ncase AC_JACK_DIG_OTHER_IN:\r\nreturn "Digital";\r\n}\r\nreturn NULL;\r\n}\r\nstatic int parse_adc_sub_nodes(struct hda_codec *codec, struct hda_gspec *spec,\r\nstruct hda_gnode *node, int idx)\r\n{\r\nint i, err;\r\nunsigned int pinctl;\r\nconst char *type;\r\nif (node->checked)\r\nreturn 0;\r\nnode->checked = 1;\r\nif (node->type != AC_WID_PIN) {\r\nfor (i = 0; i < node->nconns; i++) {\r\nstruct hda_gnode *child;\r\nchild = hda_get_node(spec, node->conn_list[i]);\r\nif (! child)\r\ncontinue;\r\nerr = parse_adc_sub_nodes(codec, spec, child, idx);\r\nif (err < 0)\r\nreturn err;\r\nif (err > 0) {\r\nif (node->nconns > 1)\r\nselect_input_connection(codec, node, i);\r\nunmute_input(codec, node, i);\r\nunmute_output(codec, node);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nif (! (node->pin_caps & AC_PINCAP_IN))\r\nreturn 0;\r\nif (defcfg_port_conn(node) == AC_JACK_PORT_NONE)\r\nreturn 0;\r\nif (node->wid_caps & AC_WCAP_DIGITAL)\r\nreturn 0;\r\nif (spec->input_mux.num_items >= HDA_MAX_NUM_INPUTS) {\r\nsnd_printk(KERN_ERR "hda_generic: Too many items for capture\n");\r\nreturn -EINVAL;\r\n}\r\npinctl = AC_PINCTL_IN_EN;\r\ntype = get_input_type(node, &pinctl);\r\nif (! type) {\r\nif (! (node->pin_ctl & AC_PINCTL_IN_EN))\r\nreturn 0;\r\ntype = "Input";\r\n}\r\nsnd_hda_add_imux_item(&spec->input_mux, type, idx, NULL);\r\nunmute_input(codec, node, 0);\r\nsnd_hda_codec_write_cache(codec, node->nid, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL, pinctl);\r\nreturn 1;\r\n}\r\nstatic int parse_input_path(struct hda_codec *codec, struct hda_gnode *adc_node)\r\n{\r\nstruct hda_gspec *spec = codec->spec;\r\nstruct hda_gnode *node;\r\nint i, err;\r\nsnd_printdd("AUD_IN = %x\n", adc_node->nid);\r\nclear_check_flags(spec);\r\nunmute_input(codec, adc_node, 0);\r\nfor (i = 0; i < adc_node->nconns; i++) {\r\nnode = hda_get_node(spec, adc_node->conn_list[i]);\r\nif (node && node->type == AC_WID_PIN) {\r\nerr = parse_adc_sub_nodes(codec, spec, node, i);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nfor (i = 0; i < adc_node->nconns; i++) {\r\nnode = hda_get_node(spec, adc_node->conn_list[i]);\r\nif (node && node->type != AC_WID_PIN) {\r\nerr = parse_adc_sub_nodes(codec, spec, node, i);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nif (! spec->input_mux.num_items)\r\nreturn 0;\r\nsnd_printdd("[Capture Source] NID=0x%x, #SRC=%d\n", adc_node->nid, spec->input_mux.num_items);\r\nfor (i = 0; i < spec->input_mux.num_items; i++)\r\nsnd_printdd(" [%s] IDX=0x%x\n", spec->input_mux.items[i].label,\r\nspec->input_mux.items[i].index);\r\nspec->adc_node = adc_node;\r\nreturn 1;\r\n}\r\nstatic int parse_input(struct hda_codec *codec)\r\n{\r\nstruct hda_gspec *spec = codec->spec;\r\nstruct hda_gnode *node;\r\nint err;\r\nlist_for_each_entry(node, &spec->nid_list, list) {\r\nif (node->wid_caps & AC_WCAP_DIGITAL)\r\ncontinue;\r\nif (node->type == AC_WID_AUD_IN) {\r\nerr = parse_input_path(codec, node);\r\nif (err < 0)\r\nreturn err;\r\nelse if (err > 0)\r\nreturn 0;\r\n}\r\n}\r\nsnd_printd("hda_generic: no proper input path found\n");\r\nreturn 0;\r\n}\r\nstatic void add_input_loopback(struct hda_codec *codec, hda_nid_t nid,\r\nint dir, int idx)\r\n{\r\nstruct hda_gspec *spec = codec->spec;\r\nstruct hda_amp_list *p;\r\nif (spec->num_loopbacks >= MAX_LOOPBACK_AMPS) {\r\nsnd_printk(KERN_ERR "hda_generic: Too many loopback ctls\n");\r\nreturn;\r\n}\r\np = &spec->loopback_list[spec->num_loopbacks++];\r\np->nid = nid;\r\np->dir = dir;\r\np->idx = idx;\r\nspec->loopback.amplist = spec->loopback_list;\r\n}\r\nstatic int create_mixer(struct hda_codec *codec, struct hda_gnode *node,\r\nunsigned int index, const char *type,\r\nconst char *dir_sfx, int is_loopback)\r\n{\r\nchar name[32];\r\nint err;\r\nint created = 0;\r\nstruct snd_kcontrol_new knew;\r\nif (type)\r\nsprintf(name, "%s %s Switch", type, dir_sfx);\r\nelse\r\nsprintf(name, "%s Switch", dir_sfx);\r\nif ((node->wid_caps & AC_WCAP_IN_AMP) &&\r\n(node->amp_in_caps & AC_AMPCAP_MUTE)) {\r\nknew = (struct snd_kcontrol_new)HDA_CODEC_MUTE(name, node->nid, index, HDA_INPUT);\r\nif (is_loopback)\r\nadd_input_loopback(codec, node->nid, HDA_INPUT, index);\r\nsnd_printdd("[%s] NID=0x%x, DIR=IN, IDX=0x%x\n", name, node->nid, index);\r\nerr = snd_hda_ctl_add(codec, node->nid,\r\nsnd_ctl_new1(&knew, codec));\r\nif (err < 0)\r\nreturn err;\r\ncreated = 1;\r\n} else if ((node->wid_caps & AC_WCAP_OUT_AMP) &&\r\n(node->amp_out_caps & AC_AMPCAP_MUTE)) {\r\nknew = (struct snd_kcontrol_new)HDA_CODEC_MUTE(name, node->nid, 0, HDA_OUTPUT);\r\nif (is_loopback)\r\nadd_input_loopback(codec, node->nid, HDA_OUTPUT, 0);\r\nsnd_printdd("[%s] NID=0x%x, DIR=OUT\n", name, node->nid);\r\nerr = snd_hda_ctl_add(codec, node->nid,\r\nsnd_ctl_new1(&knew, codec));\r\nif (err < 0)\r\nreturn err;\r\ncreated = 1;\r\n}\r\nif (type)\r\nsprintf(name, "%s %s Volume", type, dir_sfx);\r\nelse\r\nsprintf(name, "%s Volume", dir_sfx);\r\nif ((node->wid_caps & AC_WCAP_IN_AMP) &&\r\n(node->amp_in_caps & AC_AMPCAP_NUM_STEPS)) {\r\nknew = (struct snd_kcontrol_new)HDA_CODEC_VOLUME(name, node->nid, index, HDA_INPUT);\r\nsnd_printdd("[%s] NID=0x%x, DIR=IN, IDX=0x%x\n", name, node->nid, index);\r\nerr = snd_hda_ctl_add(codec, node->nid,\r\nsnd_ctl_new1(&knew, codec));\r\nif (err < 0)\r\nreturn err;\r\ncreated = 1;\r\n} else if ((node->wid_caps & AC_WCAP_OUT_AMP) &&\r\n(node->amp_out_caps & AC_AMPCAP_NUM_STEPS)) {\r\nknew = (struct snd_kcontrol_new)HDA_CODEC_VOLUME(name, node->nid, 0, HDA_OUTPUT);\r\nsnd_printdd("[%s] NID=0x%x, DIR=OUT\n", name, node->nid);\r\nerr = snd_hda_ctl_add(codec, node->nid,\r\nsnd_ctl_new1(&knew, codec));\r\nif (err < 0)\r\nreturn err;\r\ncreated = 1;\r\n}\r\nreturn created;\r\n}\r\nstatic int check_existing_control(struct hda_codec *codec, const char *type, const char *dir)\r\n{\r\nstruct snd_ctl_elem_id id;\r\nmemset(&id, 0, sizeof(id));\r\nsprintf(id.name, "%s %s Volume", type, dir);\r\nid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nif (snd_ctl_find_id(codec->bus->card, &id))\r\nreturn 1;\r\nsprintf(id.name, "%s %s Switch", type, dir);\r\nid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nif (snd_ctl_find_id(codec->bus->card, &id))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int create_output_mixers(struct hda_codec *codec,\r\nconst char * const *names)\r\n{\r\nstruct hda_gspec *spec = codec->spec;\r\nint i, err;\r\nfor (i = 0; i < spec->pcm_vol_nodes; i++) {\r\nerr = create_mixer(codec, spec->pcm_vol[i].node,\r\nspec->pcm_vol[i].index,\r\nnames[i], "Playback", 0);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int build_output_controls(struct hda_codec *codec)\r\n{\r\nstruct hda_gspec *spec = codec->spec;\r\nstatic const char * const types_speaker[] = { "Speaker", "Headphone" };\r\nstatic const char * const types_line[] = { "Front", "Headphone" };\r\nswitch (spec->pcm_vol_nodes) {\r\ncase 1:\r\nreturn create_mixer(codec, spec->pcm_vol[0].node,\r\nspec->pcm_vol[0].index,\r\n"Master", "Playback", 0);\r\ncase 2:\r\nif (defcfg_type(spec->out_pin_node[0]) == AC_JACK_SPEAKER)\r\nreturn create_output_mixers(codec, types_speaker);\r\nelse\r\nreturn create_output_mixers(codec, types_line);\r\n}\r\nreturn 0;\r\n}\r\nstatic int build_input_controls(struct hda_codec *codec)\r\n{\r\nstruct hda_gspec *spec = codec->spec;\r\nstruct hda_gnode *adc_node = spec->adc_node;\r\nint i, err;\r\nstatic struct snd_kcontrol_new cap_sel = {\r\n.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\r\n.name = "Capture Source",\r\n.info = capture_source_info,\r\n.get = capture_source_get,\r\n.put = capture_source_put,\r\n};\r\nif (! adc_node || ! spec->input_mux.num_items)\r\nreturn 0;\r\nspec->cur_cap_src = 0;\r\nselect_input_connection(codec, adc_node,\r\nspec->input_mux.items[0].index);\r\nif (spec->input_mux.num_items == 1) {\r\nerr = create_mixer(codec, adc_node,\r\nspec->input_mux.items[0].index,\r\nNULL, "Capture", 0);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nerr = snd_hda_ctl_add(codec, spec->adc_node->nid,\r\nsnd_ctl_new1(&cap_sel, codec));\r\nif (err < 0)\r\nreturn err;\r\nif (! (adc_node->wid_caps & AC_WCAP_IN_AMP) ||\r\n! (adc_node->amp_in_caps & AC_AMPCAP_NUM_STEPS))\r\nreturn 0;\r\nfor (i = 0; i < spec->input_mux.num_items; i++) {\r\nstruct snd_kcontrol_new knew;\r\nchar name[32];\r\nsprintf(name, "%s Capture Volume",\r\nspec->input_mux.items[i].label);\r\nknew = (struct snd_kcontrol_new)\r\nHDA_CODEC_VOLUME(name, adc_node->nid,\r\nspec->input_mux.items[i].index,\r\nHDA_INPUT);\r\nerr = snd_hda_ctl_add(codec, adc_node->nid,\r\nsnd_ctl_new1(&knew, codec));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_loopback_path(struct hda_codec *codec, struct hda_gspec *spec,\r\nstruct hda_gnode *node, struct hda_gnode *dest_node,\r\nconst char *type)\r\n{\r\nint i, err;\r\nif (node->checked)\r\nreturn 0;\r\nnode->checked = 1;\r\nif (node == dest_node) {\r\nreturn 1;\r\n}\r\nfor (i = 0; i < node->nconns; i++) {\r\nstruct hda_gnode *child = hda_get_node(spec, node->conn_list[i]);\r\nif (! child)\r\ncontinue;\r\nerr = parse_loopback_path(codec, spec, child, dest_node, type);\r\nif (err < 0)\r\nreturn err;\r\nelse if (err >= 1) {\r\nif (err == 1) {\r\nerr = create_mixer(codec, node, i, type,\r\n"Playback", 1);\r\nif (err < 0)\r\nreturn err;\r\nif (err > 0)\r\nreturn 2;\r\nerr = 1;\r\n}\r\nif (node->nconns > 1)\r\nselect_input_connection(codec, node, i);\r\nunmute_input(codec, node, i);\r\nunmute_output(codec, node);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int build_loopback_controls(struct hda_codec *codec)\r\n{\r\nstruct hda_gspec *spec = codec->spec;\r\nstruct hda_gnode *node;\r\nint err;\r\nconst char *type;\r\nif (! spec->out_pin_node[0])\r\nreturn 0;\r\nlist_for_each_entry(node, &spec->nid_list, list) {\r\nif (node->type != AC_WID_PIN)\r\ncontinue;\r\nif (! (node->pin_caps & AC_PINCAP_IN))\r\nreturn 0;\r\ntype = get_input_type(node, NULL);\r\nif (type) {\r\nif (check_existing_control(codec, type, "Playback"))\r\ncontinue;\r\nclear_check_flags(spec);\r\nerr = parse_loopback_path(codec, spec,\r\nspec->out_pin_node[0],\r\nnode, type);\r\nif (err < 0)\r\nreturn err;\r\nif (! err)\r\ncontinue;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int build_generic_controls(struct hda_codec *codec)\r\n{\r\nint err;\r\nif ((err = build_input_controls(codec)) < 0 ||\r\n(err = build_output_controls(codec)) < 0 ||\r\n(err = build_loopback_controls(codec)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int generic_pcm2_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hda_gspec *spec = codec->spec;\r\nsnd_hda_codec_setup_stream(codec, hinfo->nid, stream_tag, 0, format);\r\nsnd_hda_codec_setup_stream(codec, spec->dac_node[1]->nid,\r\nstream_tag, 0, format);\r\nreturn 0;\r\n}\r\nstatic int generic_pcm2_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hda_gspec *spec = codec->spec;\r\nsnd_hda_codec_cleanup_stream(codec, hinfo->nid);\r\nsnd_hda_codec_cleanup_stream(codec, spec->dac_node[1]->nid);\r\nreturn 0;\r\n}\r\nstatic int build_generic_pcms(struct hda_codec *codec)\r\n{\r\nstruct hda_gspec *spec = codec->spec;\r\nstruct hda_pcm *info = &spec->pcm_rec;\r\nif (! spec->dac_node[0] && ! spec->adc_node) {\r\nsnd_printd("hda_generic: no PCM found\n");\r\nreturn 0;\r\n}\r\ncodec->num_pcms = 1;\r\ncodec->pcm_info = info;\r\ninfo->name = "HDA Generic";\r\nif (spec->dac_node[0]) {\r\ninfo->stream[0] = generic_pcm_playback;\r\ninfo->stream[0].nid = spec->dac_node[0]->nid;\r\nif (spec->dac_node[1]) {\r\ninfo->stream[0].ops.prepare = generic_pcm2_prepare;\r\ninfo->stream[0].ops.cleanup = generic_pcm2_cleanup;\r\n}\r\n}\r\nif (spec->adc_node) {\r\ninfo->stream[1] = generic_pcm_playback;\r\ninfo->stream[1].nid = spec->adc_node->nid;\r\n}\r\nreturn 0;\r\n}\r\nstatic int generic_check_power_status(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hda_gspec *spec = codec->spec;\r\nreturn snd_hda_check_amp_list_power(codec, &spec->loopback, nid);\r\n}\r\nint snd_hda_parse_generic_codec(struct hda_codec *codec)\r\n{\r\nstruct hda_gspec *spec;\r\nint err;\r\nif(!codec->afg)\r\nreturn 0;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (spec == NULL) {\r\nprintk(KERN_ERR "hda_generic: can't allocate spec\n");\r\nreturn -ENOMEM;\r\n}\r\ncodec->spec = spec;\r\nINIT_LIST_HEAD(&spec->nid_list);\r\nif ((err = build_afg_tree(codec)) < 0)\r\ngoto error;\r\nif ((err = parse_input(codec)) < 0 ||\r\n(err = parse_output(codec)) < 0)\r\ngoto error;\r\ncodec->patch_ops = generic_patch_ops;\r\nreturn 0;\r\nerror:\r\nsnd_hda_generic_free(codec);\r\nreturn err;\r\n}
