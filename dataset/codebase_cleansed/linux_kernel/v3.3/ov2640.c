static struct ov2640_priv *to_ov2640(const struct i2c_client *client)\r\n{\r\nreturn container_of(i2c_get_clientdata(client), struct ov2640_priv,\r\nsubdev);\r\n}\r\nstatic int ov2640_write_array(struct i2c_client *client,\r\nconst struct regval_list *vals)\r\n{\r\nint ret;\r\nwhile ((vals->reg_num != 0xff) || (vals->value != 0xff)) {\r\nret = i2c_smbus_write_byte_data(client,\r\nvals->reg_num, vals->value);\r\ndev_vdbg(&client->dev, "array: 0x%02x, 0x%02x",\r\nvals->reg_num, vals->value);\r\nif (ret < 0)\r\nreturn ret;\r\nvals++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov2640_mask_set(struct i2c_client *client,\r\nu8 reg, u8 mask, u8 set)\r\n{\r\ns32 val = i2c_smbus_read_byte_data(client, reg);\r\nif (val < 0)\r\nreturn val;\r\nval &= ~mask;\r\nval |= set & mask;\r\ndev_vdbg(&client->dev, "masks: 0x%02x, 0x%02x", reg, val);\r\nreturn i2c_smbus_write_byte_data(client, reg, val);\r\n}\r\nstatic int ov2640_reset(struct i2c_client *client)\r\n{\r\nint ret;\r\nconst struct regval_list reset_seq[] = {\r\n{BANK_SEL, BANK_SEL_SENS},\r\n{COM7, COM7_SRST},\r\nENDMARKER,\r\n};\r\nret = ov2640_write_array(client, reset_seq);\r\nif (ret)\r\ngoto err;\r\nmsleep(5);\r\nerr:\r\ndev_dbg(&client->dev, "%s: (ret %d)", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int ov2640_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ov2640_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd =\r\n&container_of(ctrl->handler, struct ov2640_priv, hdl)->subdev;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 val;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_VFLIP:\r\nval = ctrl->val ? REG04_VFLIP_IMG : 0x00;\r\nreturn ov2640_mask_set(client, REG04, REG04_VFLIP_IMG, val);\r\ncase V4L2_CID_HFLIP:\r\nval = ctrl->val ? REG04_HFLIP_IMG : 0x00;\r\nreturn ov2640_mask_set(client, REG04, REG04_HFLIP_IMG, val);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ov2640_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *id)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov2640_priv *priv = to_ov2640(client);\r\nid->ident = priv->model;\r\nid->revision = 0;\r\nreturn 0;\r\n}\r\nstatic int ov2640_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nreg->size = 1;\r\nif (reg->reg > 0xff)\r\nreturn -EINVAL;\r\nret = i2c_smbus_read_byte_data(client, reg->reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreg->val = ret;\r\nreturn 0;\r\n}\r\nstatic int ov2640_s_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->reg > 0xff ||\r\nreg->val > 0xff)\r\nreturn -EINVAL;\r\nreturn i2c_smbus_write_byte_data(client, reg->reg, reg->val);\r\n}\r\nstatic const struct ov2640_win_size *ov2640_select_win(u32 *width, u32 *height)\r\n{\r\nint i, default_size = ARRAY_SIZE(ov2640_supported_win_sizes) - 1;\r\nfor (i = 0; i < ARRAY_SIZE(ov2640_supported_win_sizes); i++) {\r\nif (ov2640_supported_win_sizes[i].width >= *width &&\r\nov2640_supported_win_sizes[i].height >= *height) {\r\n*width = ov2640_supported_win_sizes[i].width;\r\n*height = ov2640_supported_win_sizes[i].height;\r\nreturn &ov2640_supported_win_sizes[i];\r\n}\r\n}\r\n*width = ov2640_supported_win_sizes[default_size].width;\r\n*height = ov2640_supported_win_sizes[default_size].height;\r\nreturn &ov2640_supported_win_sizes[default_size];\r\n}\r\nstatic int ov2640_set_params(struct i2c_client *client, u32 *width, u32 *height,\r\nenum v4l2_mbus_pixelcode code)\r\n{\r\nstruct ov2640_priv *priv = to_ov2640(client);\r\nconst struct regval_list *selected_cfmt_regs;\r\nint ret;\r\npriv->win = ov2640_select_win(width, height);\r\npriv->cfmt_code = 0;\r\nswitch (code) {\r\ncase V4L2_MBUS_FMT_RGB565_2X8_LE:\r\ndev_dbg(&client->dev, "%s: Selected cfmt RGB565", __func__);\r\nselected_cfmt_regs = ov2640_rgb565_regs;\r\nbreak;\r\ndefault:\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\ndev_dbg(&client->dev, "%s: Selected cfmt YUV422", __func__);\r\nselected_cfmt_regs = ov2640_yuv422_regs;\r\n}\r\nov2640_reset(client);\r\ndev_dbg(&client->dev, "%s: Init default", __func__);\r\nret = ov2640_write_array(client, ov2640_init_regs);\r\nif (ret < 0)\r\ngoto err;\r\ndev_dbg(&client->dev, "%s: Set size to %s", __func__, priv->win->name);\r\nret = ov2640_write_array(client, ov2640_size_change_preamble_regs);\r\nif (ret < 0)\r\ngoto err;\r\nret = ov2640_write_array(client, priv->win->regs);\r\nif (ret < 0)\r\ngoto err;\r\ndev_dbg(&client->dev, "%s: Set cfmt", __func__);\r\nret = ov2640_write_array(client, ov2640_format_change_preamble_regs);\r\nif (ret < 0)\r\ngoto err;\r\nret = ov2640_write_array(client, selected_cfmt_regs);\r\nif (ret < 0)\r\ngoto err;\r\npriv->cfmt_code = code;\r\n*width = priv->win->width;\r\n*height = priv->win->height;\r\nreturn 0;\r\nerr:\r\ndev_err(&client->dev, "%s: Error %d", __func__, ret);\r\nov2640_reset(client);\r\npriv->win = NULL;\r\nreturn ret;\r\n}\r\nstatic int ov2640_g_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov2640_priv *priv = to_ov2640(client);\r\nif (!priv->win) {\r\nu32 width = W_SVGA, height = H_SVGA;\r\nint ret = ov2640_set_params(client, &width, &height,\r\nV4L2_MBUS_FMT_UYVY8_2X8);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nmf->width = priv->win->width;\r\nmf->height = priv->win->height;\r\nmf->code = priv->cfmt_code;\r\nswitch (mf->code) {\r\ncase V4L2_MBUS_FMT_RGB565_2X8_LE:\r\nmf->colorspace = V4L2_COLORSPACE_SRGB;\r\nbreak;\r\ndefault:\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\n}\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int ov2640_s_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nswitch (mf->code) {\r\ncase V4L2_MBUS_FMT_RGB565_2X8_LE:\r\nmf->colorspace = V4L2_COLORSPACE_SRGB;\r\nbreak;\r\ndefault:\r\nmf->code = V4L2_MBUS_FMT_UYVY8_2X8;\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\n}\r\nret = ov2640_set_params(client, &mf->width, &mf->height, mf->code);\r\nreturn ret;\r\n}\r\nstatic int ov2640_try_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nconst struct ov2640_win_size *win;\r\nwin = ov2640_select_win(&mf->width, &mf->height);\r\nmf->field = V4L2_FIELD_NONE;\r\nswitch (mf->code) {\r\ncase V4L2_MBUS_FMT_RGB565_2X8_LE:\r\nmf->colorspace = V4L2_COLORSPACE_SRGB;\r\nbreak;\r\ndefault:\r\nmf->code = V4L2_MBUS_FMT_UYVY8_2X8;\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov2640_enum_fmt(struct v4l2_subdev *sd, unsigned int index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index >= ARRAY_SIZE(ov2640_codes))\r\nreturn -EINVAL;\r\n*code = ov2640_codes[index];\r\nreturn 0;\r\n}\r\nstatic int ov2640_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\na->c.left = 0;\r\na->c.top = 0;\r\na->c.width = W_UXGA;\r\na->c.height = H_UXGA;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic int ov2640_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)\r\n{\r\na->bounds.left = 0;\r\na->bounds.top = 0;\r\na->bounds.width = W_UXGA;\r\na->bounds.height = H_UXGA;\r\na->defrect = a->bounds;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\na->pixelaspect.numerator = 1;\r\na->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int ov2640_video_probe(struct i2c_client *client)\r\n{\r\nstruct ov2640_priv *priv = to_ov2640(client);\r\nu8 pid, ver, midh, midl;\r\nconst char *devname;\r\nint ret;\r\ni2c_smbus_write_byte_data(client, BANK_SEL, BANK_SEL_SENS);\r\npid = i2c_smbus_read_byte_data(client, PID);\r\nver = i2c_smbus_read_byte_data(client, VER);\r\nmidh = i2c_smbus_read_byte_data(client, MIDH);\r\nmidl = i2c_smbus_read_byte_data(client, MIDL);\r\nswitch (VERSION(pid, ver)) {\r\ncase PID_OV2640:\r\ndevname = "ov2640";\r\npriv->model = V4L2_IDENT_OV2640;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"Product ID error %x:%x\n", pid, ver);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\ndev_info(&client->dev,\r\n"%s Product ID %0x:%0x Manufacturer ID %x:%x\n",\r\ndevname, pid, ver, midh, midl);\r\nreturn v4l2_ctrl_handler_setup(&priv->hdl);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int ov2640_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\ncfg->flags = V4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_MASTER |\r\nV4L2_MBUS_VSYNC_ACTIVE_HIGH | V4L2_MBUS_HSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_DATA_ACTIVE_HIGH;\r\ncfg->type = V4L2_MBUS_PARALLEL;\r\ncfg->flags = soc_camera_apply_board_flags(icl, cfg);\r\nreturn 0;\r\n}\r\nstatic int ov2640_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct ov2640_priv *priv;\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nint ret;\r\nif (!icl) {\r\ndev_err(&adapter->dev,\r\n"OV2640: Missing platform_data for driver\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&adapter->dev,\r\n"OV2640: I2C-Adapter doesn't support SMBUS\n");\r\nreturn -EIO;\r\n}\r\npriv = kzalloc(sizeof(struct ov2640_priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&adapter->dev,\r\n"Failed to allocate memory for private data!\n");\r\nreturn -ENOMEM;\r\n}\r\nv4l2_i2c_subdev_init(&priv->subdev, client, &ov2640_subdev_ops);\r\nv4l2_ctrl_handler_init(&priv->hdl, 2);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov2640_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov2640_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\npriv->subdev.ctrl_handler = &priv->hdl;\r\nif (priv->hdl.error) {\r\nint err = priv->hdl.error;\r\nkfree(priv);\r\nreturn err;\r\n}\r\nret = ov2640_video_probe(client);\r\nif (ret) {\r\nv4l2_ctrl_handler_free(&priv->hdl);\r\nkfree(priv);\r\n} else {\r\ndev_info(&adapter->dev, "OV2640 Probed\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov2640_remove(struct i2c_client *client)\r\n{\r\nstruct ov2640_priv *priv = to_ov2640(client);\r\nv4l2_device_unregister_subdev(&priv->subdev);\r\nv4l2_ctrl_handler_free(&priv->hdl);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int __init ov2640_module_init(void)\r\n{\r\nreturn i2c_add_driver(&ov2640_i2c_driver);\r\n}\r\nstatic void __exit ov2640_module_exit(void)\r\n{\r\ni2c_del_driver(&ov2640_i2c_driver);\r\n}
