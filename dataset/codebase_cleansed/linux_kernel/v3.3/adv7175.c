static inline struct adv7175 *to_adv7175(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct adv7175, sd);\r\n}\r\nstatic inline int adv7175_write(struct v4l2_subdev *sd, u8 reg, u8 value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic inline int adv7175_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int adv7175_write_block(struct v4l2_subdev *sd,\r\nconst u8 *data, unsigned int len)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret = -1;\r\nu8 reg;\r\nif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\nu8 block_data[32];\r\nint block_len;\r\nwhile (len >= 2) {\r\nblock_len = 0;\r\nblock_data[block_len++] = reg = data[0];\r\ndo {\r\nblock_data[block_len++] = data[1];\r\nreg++;\r\nlen -= 2;\r\ndata += 2;\r\n} while (len >= 2 && data[0] == reg && block_len < 32);\r\nret = i2c_master_send(client, block_data, block_len);\r\nif (ret < 0)\r\nbreak;\r\n}\r\n} else {\r\nwhile (len >= 2) {\r\nreg = *data++;\r\nret = adv7175_write(sd, reg, *data++);\r\nif (ret < 0)\r\nbreak;\r\nlen -= 2;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void set_subcarrier_freq(struct v4l2_subdev *sd, int pass_through)\r\n{\r\nif (pass_through)\r\nadv7175_write(sd, 0x02, 0x00);\r\nelse\r\nadv7175_write(sd, 0x02, 0x55);\r\nadv7175_write(sd, 0x03, 0x55);\r\nadv7175_write(sd, 0x04, 0x55);\r\nadv7175_write(sd, 0x05, 0x25);\r\n}\r\nstatic int adv7175_init(struct v4l2_subdev *sd, u32 val)\r\n{\r\nadv7175_write_block(sd, init_common, sizeof(init_common));\r\nadv7175_write(sd, 0x07, TR0MODE | TR0RST);\r\nadv7175_write(sd, 0x07, TR0MODE);\r\nreturn 0;\r\n}\r\nstatic int adv7175_s_std_output(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct adv7175 *encoder = to_adv7175(sd);\r\nif (std & V4L2_STD_NTSC) {\r\nadv7175_write_block(sd, init_ntsc, sizeof(init_ntsc));\r\nif (encoder->input == 0)\r\nadv7175_write(sd, 0x0d, 0x4f);\r\nadv7175_write(sd, 0x07, TR0MODE | TR0RST);\r\nadv7175_write(sd, 0x07, TR0MODE);\r\n} else if (std & V4L2_STD_PAL) {\r\nadv7175_write_block(sd, init_pal, sizeof(init_pal));\r\nif (encoder->input == 0)\r\nadv7175_write(sd, 0x0d, 0x4f);\r\nadv7175_write(sd, 0x07, TR0MODE | TR0RST);\r\nadv7175_write(sd, 0x07, TR0MODE);\r\n} else if (std & V4L2_STD_SECAM) {\r\nadv7175_write_block(sd, init_pal, sizeof(init_pal));\r\nif (encoder->input == 0)\r\nadv7175_write(sd, 0x0d, 0x49);\r\nadv7175_write(sd, 0x07, TR0MODE | TR0RST);\r\nadv7175_write(sd, 0x07, TR0MODE);\r\n} else {\r\nv4l2_dbg(1, debug, sd, "illegal norm: %llx\n",\r\n(unsigned long long)std);\r\nreturn -EINVAL;\r\n}\r\nv4l2_dbg(1, debug, sd, "switched to %llx\n", (unsigned long long)std);\r\nencoder->norm = std;\r\nreturn 0;\r\n}\r\nstatic int adv7175_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct adv7175 *encoder = to_adv7175(sd);\r\nswitch (input) {\r\ncase 0:\r\nadv7175_write(sd, 0x01, 0x00);\r\nif (encoder->norm & V4L2_STD_NTSC)\r\nset_subcarrier_freq(sd, 1);\r\nadv7175_write(sd, 0x0c, TR1CAPT);\r\nif (encoder->norm & V4L2_STD_SECAM)\r\nadv7175_write(sd, 0x0d, 0x49);\r\nelse\r\nadv7175_write(sd, 0x0d, 0x4f);\r\nadv7175_write(sd, 0x07, TR0MODE | TR0RST);\r\nadv7175_write(sd, 0x07, TR0MODE);\r\nbreak;\r\ncase 1:\r\nadv7175_write(sd, 0x01, 0x00);\r\nif (encoder->norm & V4L2_STD_NTSC)\r\nset_subcarrier_freq(sd, 0);\r\nadv7175_write(sd, 0x0c, TR1PLAY);\r\nadv7175_write(sd, 0x0d, 0x49);\r\nadv7175_write(sd, 0x07, TR0MODE | TR0RST);\r\nadv7175_write(sd, 0x07, TR0MODE);\r\nbreak;\r\ncase 2:\r\nadv7175_write(sd, 0x01, 0x80);\r\nif (encoder->norm & V4L2_STD_NTSC)\r\nset_subcarrier_freq(sd, 0);\r\nadv7175_write(sd, 0x0d, 0x49);\r\nadv7175_write(sd, 0x07, TR0MODE | TR0RST);\r\nadv7175_write(sd, 0x07, TR0MODE);\r\nbreak;\r\ndefault:\r\nv4l2_dbg(1, debug, sd, "illegal input: %d\n", input);\r\nreturn -EINVAL;\r\n}\r\nv4l2_dbg(1, debug, sd, "switched to %s\n", inputs[input]);\r\nencoder->input = input;\r\nreturn 0;\r\n}\r\nstatic int adv7175_enum_fmt(struct v4l2_subdev *sd, unsigned int index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index >= ARRAY_SIZE(adv7175_codes))\r\nreturn -EINVAL;\r\n*code = adv7175_codes[index];\r\nreturn 0;\r\n}\r\nstatic int adv7175_g_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nu8 val = adv7175_read(sd, 0x7);\r\nif ((val & 0x40) == (1 << 6))\r\nmf->code = V4L2_MBUS_FMT_UYVY8_1X16;\r\nelse\r\nmf->code = V4L2_MBUS_FMT_UYVY8_2X8;\r\nmf->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nmf->width = 0;\r\nmf->height = 0;\r\nmf->field = V4L2_FIELD_ANY;\r\nreturn 0;\r\n}\r\nstatic int adv7175_s_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nu8 val = adv7175_read(sd, 0x7);\r\nint ret;\r\nswitch (mf->code) {\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\nval &= ~0x40;\r\nbreak;\r\ncase V4L2_MBUS_FMT_UYVY8_1X16:\r\nval |= 0x40;\r\nbreak;\r\ndefault:\r\nv4l2_dbg(1, debug, sd,\r\n"illegal v4l2_mbus_framefmt code: %d\n", mf->code);\r\nreturn -EINVAL;\r\n}\r\nret = adv7175_write(sd, 0x7, val);\r\nreturn ret;\r\n}\r\nstatic int adv7175_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_ADV7175, 0);\r\n}\r\nstatic int adv7175_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nif (on)\r\nadv7175_write(sd, 0x01, 0x00);\r\nelse\r\nadv7175_write(sd, 0x01, 0x78);\r\nreturn 0;\r\n}\r\nstatic int adv7175_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint i;\r\nstruct adv7175 *encoder;\r\nstruct v4l2_subdev *sd;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nencoder = kzalloc(sizeof(struct adv7175), GFP_KERNEL);\r\nif (encoder == NULL)\r\nreturn -ENOMEM;\r\nsd = &encoder->sd;\r\nv4l2_i2c_subdev_init(sd, client, &adv7175_ops);\r\nencoder->norm = V4L2_STD_NTSC;\r\nencoder->input = 0;\r\ni = adv7175_write_block(sd, init_common, sizeof(init_common));\r\nif (i >= 0) {\r\ni = adv7175_write(sd, 0x07, TR0MODE | TR0RST);\r\ni = adv7175_write(sd, 0x07, TR0MODE);\r\ni = adv7175_read(sd, 0x12);\r\nv4l2_dbg(1, debug, sd, "revision %d\n", i & 1);\r\n}\r\nif (i < 0)\r\nv4l2_dbg(1, debug, sd, "init error 0x%x\n", i);\r\nreturn 0;\r\n}\r\nstatic int adv7175_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nkfree(to_adv7175(sd));\r\nreturn 0;\r\n}\r\nstatic __init int init_adv7175(void)\r\n{\r\nreturn i2c_add_driver(&adv7175_driver);\r\n}\r\nstatic __exit void exit_adv7175(void)\r\n{\r\ni2c_del_driver(&adv7175_driver);\r\n}
