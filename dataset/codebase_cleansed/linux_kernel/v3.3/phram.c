static int phram_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nu_char *start = mtd->priv;\r\nif (instr->addr + instr->len > mtd->size)\r\nreturn -EINVAL;\r\nmemset(start + instr->addr, 0xff, instr->len);\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\n}\r\nstatic int phram_point(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, void **virt, resource_size_t *phys)\r\n{\r\nif (from + len > mtd->size)\r\nreturn -EINVAL;\r\nif (phys)\r\nreturn -EINVAL;\r\n*virt = mtd->priv + from;\r\n*retlen = len;\r\nreturn 0;\r\n}\r\nstatic void phram_unpoint(struct mtd_info *mtd, loff_t from, size_t len)\r\n{\r\n}\r\nstatic int phram_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nu_char *start = mtd->priv;\r\nif (from >= mtd->size)\r\nreturn -EINVAL;\r\nif (len > mtd->size - from)\r\nlen = mtd->size - from;\r\nmemcpy(buf, start + from, len);\r\n*retlen = len;\r\nreturn 0;\r\n}\r\nstatic int phram_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nu_char *start = mtd->priv;\r\nif (to >= mtd->size)\r\nreturn -EINVAL;\r\nif (len > mtd->size - to)\r\nlen = mtd->size - to;\r\nmemcpy(start + to, buf, len);\r\n*retlen = len;\r\nreturn 0;\r\n}\r\nstatic void unregister_devices(void)\r\n{\r\nstruct phram_mtd_list *this, *safe;\r\nlist_for_each_entry_safe(this, safe, &phram_list, list) {\r\nmtd_device_unregister(&this->mtd);\r\niounmap(this->mtd.priv);\r\nkfree(this->mtd.name);\r\nkfree(this);\r\n}\r\n}\r\nstatic int register_device(char *name, unsigned long start, unsigned long len)\r\n{\r\nstruct phram_mtd_list *new;\r\nint ret = -ENOMEM;\r\nnew = kzalloc(sizeof(*new), GFP_KERNEL);\r\nif (!new)\r\ngoto out0;\r\nret = -EIO;\r\nnew->mtd.priv = ioremap(start, len);\r\nif (!new->mtd.priv) {\r\npr_err("ioremap failed\n");\r\ngoto out1;\r\n}\r\nnew->mtd.name = name;\r\nnew->mtd.size = len;\r\nnew->mtd.flags = MTD_CAP_RAM;\r\nnew->mtd.erase = phram_erase;\r\nnew->mtd.point = phram_point;\r\nnew->mtd.unpoint = phram_unpoint;\r\nnew->mtd.read = phram_read;\r\nnew->mtd.write = phram_write;\r\nnew->mtd.owner = THIS_MODULE;\r\nnew->mtd.type = MTD_RAM;\r\nnew->mtd.erasesize = PAGE_SIZE;\r\nnew->mtd.writesize = 1;\r\nret = -EAGAIN;\r\nif (mtd_device_register(&new->mtd, NULL, 0)) {\r\npr_err("Failed to register new device\n");\r\ngoto out2;\r\n}\r\nlist_add_tail(&new->list, &phram_list);\r\nreturn 0;\r\nout2:\r\niounmap(new->mtd.priv);\r\nout1:\r\nkfree(new);\r\nout0:\r\nreturn ret;\r\n}\r\nstatic int ustrtoul(const char *cp, char **endp, unsigned int base)\r\n{\r\nunsigned long result = simple_strtoul(cp, endp, base);\r\nswitch (**endp) {\r\ncase 'G':\r\nresult *= 1024;\r\ncase 'M':\r\nresult *= 1024;\r\ncase 'k':\r\nresult *= 1024;\r\nif ((*endp)[1] == 'i')\r\n(*endp) += 2;\r\n}\r\nreturn result;\r\n}\r\nstatic int parse_num32(uint32_t *num32, const char *token)\r\n{\r\nchar *endp;\r\nunsigned long n;\r\nn = ustrtoul(token, &endp, 0);\r\nif (*endp)\r\nreturn -EINVAL;\r\n*num32 = n;\r\nreturn 0;\r\n}\r\nstatic int parse_name(char **pname, const char *token)\r\n{\r\nsize_t len;\r\nchar *name;\r\nlen = strlen(token) + 1;\r\nif (len > 64)\r\nreturn -ENOSPC;\r\nname = kmalloc(len, GFP_KERNEL);\r\nif (!name)\r\nreturn -ENOMEM;\r\nstrcpy(name, token);\r\n*pname = name;\r\nreturn 0;\r\n}\r\nstatic inline void kill_final_newline(char *str)\r\n{\r\nchar *newline = strrchr(str, '\n');\r\nif (newline && !newline[1])\r\n*newline = 0;\r\n}\r\nstatic int phram_setup(const char *val, struct kernel_param *kp)\r\n{\r\nchar buf[64+12+12], *str = buf;\r\nchar *token[3];\r\nchar *name;\r\nuint32_t start;\r\nuint32_t len;\r\nint i, ret;\r\nif (strnlen(val, sizeof(buf)) >= sizeof(buf))\r\nparse_err("parameter too long\n");\r\nstrcpy(str, val);\r\nkill_final_newline(str);\r\nfor (i=0; i<3; i++)\r\ntoken[i] = strsep(&str, ",");\r\nif (str)\r\nparse_err("too many arguments\n");\r\nif (!token[2])\r\nparse_err("not enough arguments\n");\r\nret = parse_name(&name, token[0]);\r\nif (ret)\r\nreturn ret;\r\nret = parse_num32(&start, token[1]);\r\nif (ret) {\r\nkfree(name);\r\nparse_err("illegal start address\n");\r\n}\r\nret = parse_num32(&len, token[2]);\r\nif (ret) {\r\nkfree(name);\r\nparse_err("illegal device length\n");\r\n}\r\nret = register_device(name, start, len);\r\nif (!ret)\r\npr_info("%s device: %#x at %#x\n", name, len, start);\r\nelse\r\nkfree(name);\r\nreturn ret;\r\n}\r\nstatic int __init init_phram(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_phram(void)\r\n{\r\nunregister_devices();\r\n}
