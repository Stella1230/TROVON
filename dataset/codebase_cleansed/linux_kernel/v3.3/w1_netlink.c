void w1_netlink_send(struct w1_master *dev, struct w1_netlink_msg *msg)\r\n{\r\nchar buf[sizeof(struct cn_msg) + sizeof(struct w1_netlink_msg)];\r\nstruct cn_msg *m = (struct cn_msg *)buf;\r\nstruct w1_netlink_msg *w = (struct w1_netlink_msg *)(m+1);\r\nmemset(buf, 0, sizeof(buf));\r\nm->id.idx = CN_W1_IDX;\r\nm->id.val = CN_W1_VAL;\r\nm->seq = dev->seq++;\r\nm->len = sizeof(struct w1_netlink_msg);\r\nmemcpy(w, msg, sizeof(struct w1_netlink_msg));\r\ncn_netlink_send(m, 0, GFP_KERNEL);\r\n}\r\nstatic void w1_send_slave(struct w1_master *dev, u64 rn)\r\n{\r\nstruct cn_msg *msg = dev->priv;\r\nstruct w1_netlink_msg *hdr = (struct w1_netlink_msg *)(msg + 1);\r\nstruct w1_netlink_cmd *cmd = (struct w1_netlink_cmd *)(hdr + 1);\r\nint avail;\r\nw1_slave_found(dev, rn);\r\navail = dev->priv_size - cmd->len;\r\nif (avail > 8) {\r\nu64 *data = (void *)(cmd + 1) + cmd->len;\r\n*data = rn;\r\ncmd->len += 8;\r\nhdr->len += 8;\r\nmsg->len += 8;\r\nreturn;\r\n}\r\nmsg->ack++;\r\ncn_netlink_send(msg, 0, GFP_KERNEL);\r\nmsg->len = sizeof(struct w1_netlink_msg) + sizeof(struct w1_netlink_cmd);\r\nhdr->len = sizeof(struct w1_netlink_cmd);\r\ncmd->len = 0;\r\n}\r\nstatic int w1_process_search_command(struct w1_master *dev, struct cn_msg *msg,\r\nunsigned int avail)\r\n{\r\nstruct w1_netlink_msg *hdr = (struct w1_netlink_msg *)(msg + 1);\r\nstruct w1_netlink_cmd *cmd = (struct w1_netlink_cmd *)(hdr + 1);\r\nint search_type = (cmd->cmd == W1_CMD_ALARM_SEARCH)?W1_ALARM_SEARCH:W1_SEARCH;\r\ndev->priv = msg;\r\ndev->priv_size = avail;\r\nw1_search_process_cb(dev, search_type, w1_send_slave);\r\nmsg->ack = 0;\r\ncn_netlink_send(msg, 0, GFP_KERNEL);\r\ndev->priv = NULL;\r\ndev->priv_size = 0;\r\nreturn 0;\r\n}\r\nstatic int w1_send_read_reply(struct cn_msg *msg, struct w1_netlink_msg *hdr,\r\nstruct w1_netlink_cmd *cmd)\r\n{\r\nvoid *data;\r\nstruct w1_netlink_msg *h;\r\nstruct w1_netlink_cmd *c;\r\nstruct cn_msg *cm;\r\nint err;\r\ndata = kzalloc(sizeof(struct cn_msg) +\r\nsizeof(struct w1_netlink_msg) +\r\nsizeof(struct w1_netlink_cmd) +\r\ncmd->len, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ncm = (struct cn_msg *)(data);\r\nh = (struct w1_netlink_msg *)(cm + 1);\r\nc = (struct w1_netlink_cmd *)(h + 1);\r\nmemcpy(cm, msg, sizeof(struct cn_msg));\r\nmemcpy(h, hdr, sizeof(struct w1_netlink_msg));\r\nmemcpy(c, cmd, sizeof(struct w1_netlink_cmd));\r\ncm->ack = msg->seq+1;\r\ncm->len = sizeof(struct w1_netlink_msg) +\r\nsizeof(struct w1_netlink_cmd) + cmd->len;\r\nh->len = sizeof(struct w1_netlink_cmd) + cmd->len;\r\nmemcpy(c->data, cmd->data, c->len);\r\nerr = cn_netlink_send(cm, 0, GFP_KERNEL);\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic int w1_process_command_io(struct w1_master *dev, struct cn_msg *msg,\r\nstruct w1_netlink_msg *hdr, struct w1_netlink_cmd *cmd)\r\n{\r\nint err = 0;\r\nswitch (cmd->cmd) {\r\ncase W1_CMD_TOUCH:\r\nw1_touch_block(dev, cmd->data, cmd->len);\r\nw1_send_read_reply(msg, hdr, cmd);\r\nbreak;\r\ncase W1_CMD_READ:\r\nw1_read_block(dev, cmd->data, cmd->len);\r\nw1_send_read_reply(msg, hdr, cmd);\r\nbreak;\r\ncase W1_CMD_WRITE:\r\nw1_write_block(dev, cmd->data, cmd->len);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int w1_process_command_master(struct w1_master *dev, struct cn_msg *req_msg,\r\nstruct w1_netlink_msg *req_hdr, struct w1_netlink_cmd *req_cmd)\r\n{\r\nint err = -EINVAL;\r\nstruct cn_msg *msg;\r\nstruct w1_netlink_msg *hdr;\r\nstruct w1_netlink_cmd *cmd;\r\nmsg = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->id = req_msg->id;\r\nmsg->seq = req_msg->seq;\r\nmsg->ack = 0;\r\nmsg->len = sizeof(struct w1_netlink_msg) + sizeof(struct w1_netlink_cmd);\r\nhdr = (struct w1_netlink_msg *)(msg + 1);\r\ncmd = (struct w1_netlink_cmd *)(hdr + 1);\r\nhdr->type = W1_MASTER_CMD;\r\nhdr->id = req_hdr->id;\r\nhdr->len = sizeof(struct w1_netlink_cmd);\r\ncmd->cmd = req_cmd->cmd;\r\ncmd->len = 0;\r\nswitch (cmd->cmd) {\r\ncase W1_CMD_SEARCH:\r\ncase W1_CMD_ALARM_SEARCH:\r\nerr = w1_process_search_command(dev, msg,\r\nPAGE_SIZE - msg->len - sizeof(struct cn_msg));\r\nbreak;\r\ncase W1_CMD_READ:\r\ncase W1_CMD_WRITE:\r\ncase W1_CMD_TOUCH:\r\nerr = w1_process_command_io(dev, req_msg, req_hdr, req_cmd);\r\nbreak;\r\ncase W1_CMD_RESET:\r\nerr = w1_reset_bus(dev);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nkfree(msg);\r\nreturn err;\r\n}\r\nstatic int w1_process_command_slave(struct w1_slave *sl, struct cn_msg *msg,\r\nstruct w1_netlink_msg *hdr, struct w1_netlink_cmd *cmd)\r\n{\r\ndev_dbg(&sl->master->dev, "%s: %02x.%012llx.%02x: cmd=%02x, len=%u.\n",\r\n__func__, sl->reg_num.family, (unsigned long long)sl->reg_num.id,\r\nsl->reg_num.crc, cmd->cmd, cmd->len);\r\nreturn w1_process_command_io(sl->master, msg, hdr, cmd);\r\n}\r\nstatic int w1_process_command_root(struct cn_msg *msg, struct w1_netlink_msg *mcmd)\r\n{\r\nstruct w1_master *m;\r\nstruct cn_msg *cn;\r\nstruct w1_netlink_msg *w;\r\nu32 *id;\r\nif (mcmd->type != W1_LIST_MASTERS) {\r\nprintk(KERN_NOTICE "%s: msg: %x.%x, wrong type: %u, len: %u.\n",\r\n__func__, msg->id.idx, msg->id.val, mcmd->type, mcmd->len);\r\nreturn -EPROTO;\r\n}\r\ncn = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!cn)\r\nreturn -ENOMEM;\r\ncn->id.idx = CN_W1_IDX;\r\ncn->id.val = CN_W1_VAL;\r\ncn->seq = msg->seq;\r\ncn->ack = 1;\r\ncn->len = sizeof(struct w1_netlink_msg);\r\nw = (struct w1_netlink_msg *)(cn + 1);\r\nw->type = W1_LIST_MASTERS;\r\nw->status = 0;\r\nw->len = 0;\r\nid = (u32 *)(w + 1);\r\nmutex_lock(&w1_mlock);\r\nlist_for_each_entry(m, &w1_masters, w1_master_entry) {\r\nif (cn->len + sizeof(*id) > PAGE_SIZE - sizeof(struct cn_msg)) {\r\ncn_netlink_send(cn, 0, GFP_KERNEL);\r\ncn->ack++;\r\ncn->len = sizeof(struct w1_netlink_msg);\r\nw->len = 0;\r\nid = (u32 *)(w + 1);\r\n}\r\n*id = m->id;\r\nw->len += sizeof(*id);\r\ncn->len += sizeof(*id);\r\nid++;\r\n}\r\ncn->ack = 0;\r\ncn_netlink_send(cn, 0, GFP_KERNEL);\r\nmutex_unlock(&w1_mlock);\r\nkfree(cn);\r\nreturn 0;\r\n}\r\nstatic int w1_netlink_send_error(struct cn_msg *rcmsg, struct w1_netlink_msg *rmsg,\r\nstruct w1_netlink_cmd *rcmd, int error)\r\n{\r\nstruct cn_msg *cmsg;\r\nstruct w1_netlink_msg *msg;\r\nstruct w1_netlink_cmd *cmd;\r\ncmsg = kzalloc(sizeof(*msg) + sizeof(*cmd) + sizeof(*cmsg), GFP_KERNEL);\r\nif (!cmsg)\r\nreturn -ENOMEM;\r\nmsg = (struct w1_netlink_msg *)(cmsg + 1);\r\ncmd = (struct w1_netlink_cmd *)(msg + 1);\r\nmemcpy(cmsg, rcmsg, sizeof(*cmsg));\r\ncmsg->len = sizeof(*msg);\r\nmemcpy(msg, rmsg, sizeof(*msg));\r\nmsg->len = 0;\r\nmsg->status = (short)-error;\r\nif (rcmd) {\r\nmemcpy(cmd, rcmd, sizeof(*cmd));\r\ncmd->len = 0;\r\nmsg->len += sizeof(*cmd);\r\ncmsg->len += sizeof(*cmd);\r\n}\r\nerror = cn_netlink_send(cmsg, 0, GFP_KERNEL);\r\nkfree(cmsg);\r\nreturn error;\r\n}\r\nstatic void w1_cn_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)\r\n{\r\nstruct w1_netlink_msg *m = (struct w1_netlink_msg *)(msg + 1);\r\nstruct w1_netlink_cmd *cmd;\r\nstruct w1_slave *sl;\r\nstruct w1_master *dev;\r\nint err = 0;\r\nwhile (msg->len && !err) {\r\nstruct w1_reg_num id;\r\nu16 mlen = m->len;\r\nu8 *cmd_data = m->data;\r\ndev = NULL;\r\nsl = NULL;\r\ncmd = NULL;\r\nmemcpy(&id, m->id.id, sizeof(id));\r\n#if 0\r\nprintk("%s: %02x.%012llx.%02x: type=%02x, len=%u.\n",\r\n__func__, id.family, (unsigned long long)id.id, id.crc, m->type, m->len);\r\n#endif\r\nif (m->len + sizeof(struct w1_netlink_msg) > msg->len) {\r\nerr = -E2BIG;\r\nbreak;\r\n}\r\nif (m->type == W1_MASTER_CMD) {\r\ndev = w1_search_master_id(m->id.mst.id);\r\n} else if (m->type == W1_SLAVE_CMD) {\r\nsl = w1_search_slave(&id);\r\nif (sl)\r\ndev = sl->master;\r\n} else {\r\nerr = w1_process_command_root(msg, m);\r\ngoto out_cont;\r\n}\r\nif (!dev) {\r\nerr = -ENODEV;\r\ngoto out_cont;\r\n}\r\nerr = 0;\r\nif (!mlen)\r\ngoto out_cont;\r\nmutex_lock(&dev->mutex);\r\nif (sl && w1_reset_select_slave(sl)) {\r\nerr = -ENODEV;\r\ngoto out_up;\r\n}\r\nwhile (mlen) {\r\ncmd = (struct w1_netlink_cmd *)cmd_data;\r\nif (cmd->len + sizeof(struct w1_netlink_cmd) > mlen) {\r\nerr = -E2BIG;\r\nbreak;\r\n}\r\nif (sl)\r\nerr = w1_process_command_slave(sl, msg, m, cmd);\r\nelse\r\nerr = w1_process_command_master(dev, msg, m, cmd);\r\nw1_netlink_send_error(msg, m, cmd, err);\r\nerr = 0;\r\ncmd_data += cmd->len + sizeof(struct w1_netlink_cmd);\r\nmlen -= cmd->len + sizeof(struct w1_netlink_cmd);\r\n}\r\nout_up:\r\natomic_dec(&dev->refcnt);\r\nif (sl)\r\natomic_dec(&sl->refcnt);\r\nmutex_unlock(&dev->mutex);\r\nout_cont:\r\nif (!cmd || err)\r\nw1_netlink_send_error(msg, m, cmd, err);\r\nmsg->len -= sizeof(struct w1_netlink_msg) + m->len;\r\nm = (struct w1_netlink_msg *)(((u8 *)m) + sizeof(struct w1_netlink_msg) + m->len);\r\nif (err == -ENODEV)\r\nerr = 0;\r\n}\r\n}\r\nint w1_init_netlink(void)\r\n{\r\nstruct cb_id w1_id = {.idx = CN_W1_IDX, .val = CN_W1_VAL};\r\nreturn cn_add_callback(&w1_id, "w1", &w1_cn_callback);\r\n}\r\nvoid w1_fini_netlink(void)\r\n{\r\nstruct cb_id w1_id = {.idx = CN_W1_IDX, .val = CN_W1_VAL};\r\ncn_del_callback(&w1_id);\r\n}\r\nvoid w1_netlink_send(struct w1_master *dev, struct w1_netlink_msg *msg)\r\n{\r\n}\r\nint w1_init_netlink(void)\r\n{\r\nreturn 0;\r\n}\r\nvoid w1_fini_netlink(void)\r\n{\r\n}
