static void iic_wr(struct sh_mobile_i2c_data *pd, int offs, unsigned char data)\r\n{\r\nif (offs == ICIC)\r\ndata |= pd->icic;\r\niowrite8(data, pd->reg + offs);\r\n}\r\nstatic unsigned char iic_rd(struct sh_mobile_i2c_data *pd, int offs)\r\n{\r\nreturn ioread8(pd->reg + offs);\r\n}\r\nstatic void iic_set_clr(struct sh_mobile_i2c_data *pd, int offs,\r\nunsigned char set, unsigned char clr)\r\n{\r\niic_wr(pd, offs, (iic_rd(pd, offs) | set) & ~clr);\r\n}\r\nstatic void activate_ch(struct sh_mobile_i2c_data *pd)\r\n{\r\nunsigned long i2c_clk;\r\nu_int32_t num;\r\nu_int32_t denom;\r\nu_int32_t tmp;\r\npm_runtime_get_sync(pd->dev);\r\nclk_enable(pd->clk);\r\ni2c_clk = clk_get_rate(pd->clk);\r\nnum = i2c_clk * 5;\r\ndenom = pd->bus_speed * 9;\r\ntmp = num * 10 / denom;\r\nif (tmp % 10 >= 5)\r\npd->iccl = (u_int8_t)((num/denom) + 1);\r\nelse\r\npd->iccl = (u_int8_t)(num/denom);\r\nif (pd->flags & IIC_FLAG_HAS_ICIC67) {\r\nif ((num/denom) > 0xff)\r\npd->icic |= ICIC_ICCLB8;\r\nelse\r\npd->icic &= ~ICIC_ICCLB8;\r\n}\r\nnum = i2c_clk * 4;\r\ntmp = num * 10 / denom;\r\nif (tmp % 10 >= 5)\r\npd->icch = (u_int8_t)((num/denom) + 1);\r\nelse\r\npd->icch = (u_int8_t)(num/denom);\r\nif (pd->flags & IIC_FLAG_HAS_ICIC67) {\r\nif ((num/denom) > 0xff)\r\npd->icic |= ICIC_ICCHB8;\r\nelse\r\npd->icic &= ~ICIC_ICCHB8;\r\n}\r\niic_set_clr(pd, ICCR, ICCR_ICE, 0);\r\niic_wr(pd, ICIC, 0);\r\niic_wr(pd, ICCL, pd->iccl);\r\niic_wr(pd, ICCH, pd->icch);\r\n}\r\nstatic void deactivate_ch(struct sh_mobile_i2c_data *pd)\r\n{\r\niic_wr(pd, ICSR, 0);\r\niic_wr(pd, ICIC, 0);\r\niic_set_clr(pd, ICCR, 0, ICCR_ICE);\r\nclk_disable(pd->clk);\r\npm_runtime_put_sync(pd->dev);\r\n}\r\nstatic unsigned char i2c_op(struct sh_mobile_i2c_data *pd,\r\nenum sh_mobile_i2c_op op, unsigned char data)\r\n{\r\nunsigned char ret = 0;\r\nunsigned long flags;\r\ndev_dbg(pd->dev, "op %d, data in 0x%02x\n", op, data);\r\nspin_lock_irqsave(&pd->lock, flags);\r\nswitch (op) {\r\ncase OP_START:\r\niic_wr(pd, ICCR, 0x94);\r\nbreak;\r\ncase OP_TX_FIRST:\r\niic_wr(pd, ICIC, ICIC_WAITE | ICIC_ALE | ICIC_TACKE);\r\niic_wr(pd, ICDR, data);\r\nbreak;\r\ncase OP_TX:\r\niic_wr(pd, ICDR, data);\r\nbreak;\r\ncase OP_TX_STOP:\r\niic_wr(pd, ICDR, data);\r\niic_wr(pd, ICCR, 0x90);\r\nbreak;\r\ncase OP_TX_TO_RX:\r\niic_wr(pd, ICCR, 0x81);\r\nbreak;\r\ncase OP_RX:\r\nret = iic_rd(pd, ICDR);\r\nbreak;\r\ncase OP_RX_STOP:\r\niic_wr(pd, ICIC,\r\nICIC_DTEE | ICIC_WAITE | ICIC_ALE | ICIC_TACKE);\r\niic_wr(pd, ICCR, 0xc0);\r\nbreak;\r\ncase OP_RX_STOP_DATA:\r\niic_wr(pd, ICIC,\r\nICIC_DTEE | ICIC_WAITE | ICIC_ALE | ICIC_TACKE);\r\nret = iic_rd(pd, ICDR);\r\niic_wr(pd, ICCR, 0xc0);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&pd->lock, flags);\r\ndev_dbg(pd->dev, "op %d, data out 0x%02x\n", op, ret);\r\nreturn ret;\r\n}\r\nstatic int sh_mobile_i2c_is_first_byte(struct sh_mobile_i2c_data *pd)\r\n{\r\nif (pd->pos == -1)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_i2c_is_last_byte(struct sh_mobile_i2c_data *pd)\r\n{\r\nif (pd->pos == (pd->msg->len - 1))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void sh_mobile_i2c_get_data(struct sh_mobile_i2c_data *pd,\r\nunsigned char *buf)\r\n{\r\nswitch (pd->pos) {\r\ncase -1:\r\n*buf = (pd->msg->addr & 0x7f) << 1;\r\n*buf |= (pd->msg->flags & I2C_M_RD) ? 1 : 0;\r\nbreak;\r\ndefault:\r\n*buf = pd->msg->buf[pd->pos];\r\n}\r\n}\r\nstatic int sh_mobile_i2c_isr_tx(struct sh_mobile_i2c_data *pd)\r\n{\r\nunsigned char data;\r\nif (pd->pos == pd->msg->len)\r\nreturn 1;\r\nsh_mobile_i2c_get_data(pd, &data);\r\nif (sh_mobile_i2c_is_last_byte(pd))\r\ni2c_op(pd, OP_TX_STOP, data);\r\nelse if (sh_mobile_i2c_is_first_byte(pd))\r\ni2c_op(pd, OP_TX_FIRST, data);\r\nelse\r\ni2c_op(pd, OP_TX, data);\r\npd->pos++;\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_i2c_isr_rx(struct sh_mobile_i2c_data *pd)\r\n{\r\nunsigned char data;\r\nint real_pos;\r\ndo {\r\nif (pd->pos <= -1) {\r\nsh_mobile_i2c_get_data(pd, &data);\r\nif (sh_mobile_i2c_is_first_byte(pd))\r\ni2c_op(pd, OP_TX_FIRST, data);\r\nelse\r\ni2c_op(pd, OP_TX, data);\r\nbreak;\r\n}\r\nif (pd->pos == 0) {\r\ni2c_op(pd, OP_TX_TO_RX, 0);\r\nbreak;\r\n}\r\nreal_pos = pd->pos - 2;\r\nif (pd->pos == pd->msg->len) {\r\nif (real_pos < 0) {\r\ni2c_op(pd, OP_RX_STOP, 0);\r\nbreak;\r\n}\r\ndata = i2c_op(pd, OP_RX_STOP_DATA, 0);\r\n} else\r\ndata = i2c_op(pd, OP_RX, 0);\r\nif (real_pos >= 0)\r\npd->msg->buf[real_pos] = data;\r\n} while (0);\r\npd->pos++;\r\nreturn pd->pos == (pd->msg->len + 2);\r\n}\r\nstatic irqreturn_t sh_mobile_i2c_isr(int irq, void *dev_id)\r\n{\r\nstruct platform_device *dev = dev_id;\r\nstruct sh_mobile_i2c_data *pd = platform_get_drvdata(dev);\r\nunsigned char sr;\r\nint wakeup;\r\nsr = iic_rd(pd, ICSR);\r\npd->sr |= sr;\r\ndev_dbg(pd->dev, "i2c_isr 0x%02x 0x%02x %s %d %d!\n", sr, pd->sr,\r\n(pd->msg->flags & I2C_M_RD) ? "read" : "write",\r\npd->pos, pd->msg->len);\r\nif (sr & (ICSR_AL | ICSR_TACK)) {\r\niic_wr(pd, ICSR, sr & ~(ICSR_AL | ICSR_TACK));\r\nwakeup = 0;\r\n} else if (pd->msg->flags & I2C_M_RD)\r\nwakeup = sh_mobile_i2c_isr_rx(pd);\r\nelse\r\nwakeup = sh_mobile_i2c_isr_tx(pd);\r\nif (sr & ICSR_WAIT)\r\niic_wr(pd, ICSR, sr & ~ICSR_WAIT);\r\nif (wakeup) {\r\npd->sr |= SW_DONE;\r\nwake_up(&pd->wait);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int start_ch(struct sh_mobile_i2c_data *pd, struct i2c_msg *usr_msg)\r\n{\r\nif (usr_msg->len == 0 && (usr_msg->flags & I2C_M_RD)) {\r\ndev_err(pd->dev, "Unsupported zero length i2c read\n");\r\nreturn -EIO;\r\n}\r\niic_set_clr(pd, ICCR, 0, ICCR_ICE);\r\niic_set_clr(pd, ICCR, ICCR_ICE, 0);\r\niic_wr(pd, ICCL, pd->iccl);\r\niic_wr(pd, ICCH, pd->icch);\r\npd->msg = usr_msg;\r\npd->pos = -1;\r\npd->sr = 0;\r\niic_wr(pd, ICIC, ICIC_DTEE | ICIC_WAITE | ICIC_ALE | ICIC_TACKE);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_i2c_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct sh_mobile_i2c_data *pd = i2c_get_adapdata(adapter);\r\nstruct i2c_msg *msg;\r\nint err = 0;\r\nu_int8_t val;\r\nint i, k, retry_count;\r\nactivate_ch(pd);\r\nfor (i = 0; i < num; i++) {\r\nmsg = &msgs[i];\r\nerr = start_ch(pd, msg);\r\nif (err)\r\nbreak;\r\ni2c_op(pd, OP_START, 0);\r\nk = wait_event_timeout(pd->wait,\r\npd->sr & (ICSR_TACK | SW_DONE),\r\n5 * HZ);\r\nif (!k)\r\ndev_err(pd->dev, "Transfer request timed out\n");\r\nretry_count = 1000;\r\nagain:\r\nval = iic_rd(pd, ICSR);\r\ndev_dbg(pd->dev, "val 0x%02x pd->sr 0x%02x\n", val, pd->sr);\r\nif (val & ICSR_BUSY) {\r\nudelay(10);\r\nif (retry_count--)\r\ngoto again;\r\nerr = -EIO;\r\ndev_err(pd->dev, "Polling timed out\n");\r\nbreak;\r\n}\r\nif ((val | pd->sr) & (ICSR_TACK | ICSR_AL)) {\r\nerr = -EIO;\r\nbreak;\r\n}\r\n}\r\ndeactivate_ch(pd);\r\nif (!err)\r\nerr = num;\r\nreturn err;\r\n}\r\nstatic u32 sh_mobile_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int sh_mobile_i2c_hook_irqs(struct platform_device *dev, int hook)\r\n{\r\nstruct resource *res;\r\nint ret = -ENXIO;\r\nint n, k = 0;\r\nwhile ((res = platform_get_resource(dev, IORESOURCE_IRQ, k))) {\r\nfor (n = res->start; hook && n <= res->end; n++) {\r\nif (request_irq(n, sh_mobile_i2c_isr, 0,\r\ndev_name(&dev->dev), dev)) {\r\nfor (n--; n >= res->start; n--)\r\nfree_irq(n, dev);\r\ngoto rollback;\r\n}\r\n}\r\nk++;\r\n}\r\nif (hook)\r\nreturn k > 0 ? 0 : -ENOENT;\r\nret = 0;\r\nrollback:\r\nk--;\r\nwhile (k >= 0) {\r\nres = platform_get_resource(dev, IORESOURCE_IRQ, k);\r\nfor (n = res->start; n <= res->end; n++)\r\nfree_irq(n, dev);\r\nk--;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sh_mobile_i2c_probe(struct platform_device *dev)\r\n{\r\nstruct i2c_sh_mobile_platform_data *pdata = dev->dev.platform_data;\r\nstruct sh_mobile_i2c_data *pd;\r\nstruct i2c_adapter *adap;\r\nstruct resource *res;\r\nint size;\r\nint ret;\r\npd = kzalloc(sizeof(struct sh_mobile_i2c_data), GFP_KERNEL);\r\nif (pd == NULL) {\r\ndev_err(&dev->dev, "cannot allocate private data\n");\r\nreturn -ENOMEM;\r\n}\r\npd->clk = clk_get(&dev->dev, NULL);\r\nif (IS_ERR(pd->clk)) {\r\ndev_err(&dev->dev, "cannot get clock\n");\r\nret = PTR_ERR(pd->clk);\r\ngoto err;\r\n}\r\nret = sh_mobile_i2c_hook_irqs(dev, 1);\r\nif (ret) {\r\ndev_err(&dev->dev, "cannot request IRQ\n");\r\ngoto err_clk;\r\n}\r\npd->dev = &dev->dev;\r\nplatform_set_drvdata(dev, pd);\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&dev->dev, "cannot find IO resource\n");\r\nret = -ENOENT;\r\ngoto err_irq;\r\n}\r\nsize = resource_size(res);\r\npd->reg = ioremap(res->start, size);\r\nif (pd->reg == NULL) {\r\ndev_err(&dev->dev, "cannot map IO\n");\r\nret = -ENXIO;\r\ngoto err_irq;\r\n}\r\npd->bus_speed = NORMAL_SPEED;\r\nif (pdata && pdata->bus_speed)\r\npd->bus_speed = pdata->bus_speed;\r\nif (size > 0x17)\r\npd->flags |= IIC_FLAG_HAS_ICIC67;\r\npm_suspend_ignore_children(&dev->dev, true);\r\npm_runtime_enable(&dev->dev);\r\nadap = &pd->adap;\r\ni2c_set_adapdata(adap, pd);\r\nadap->owner = THIS_MODULE;\r\nadap->algo = &sh_mobile_i2c_algorithm;\r\nadap->dev.parent = &dev->dev;\r\nadap->retries = 5;\r\nadap->nr = dev->id;\r\nstrlcpy(adap->name, dev->name, sizeof(adap->name));\r\nspin_lock_init(&pd->lock);\r\ninit_waitqueue_head(&pd->wait);\r\nret = i2c_add_numbered_adapter(adap);\r\nif (ret < 0) {\r\ndev_err(&dev->dev, "cannot add numbered adapter\n");\r\ngoto err_all;\r\n}\r\ndev_info(&dev->dev, "I2C adapter %d with bus speed %lu Hz\n",\r\nadap->nr, pd->bus_speed);\r\nreturn 0;\r\nerr_all:\r\niounmap(pd->reg);\r\nerr_irq:\r\nsh_mobile_i2c_hook_irqs(dev, 0);\r\nerr_clk:\r\nclk_put(pd->clk);\r\nerr:\r\nkfree(pd);\r\nreturn ret;\r\n}\r\nstatic int sh_mobile_i2c_remove(struct platform_device *dev)\r\n{\r\nstruct sh_mobile_i2c_data *pd = platform_get_drvdata(dev);\r\ni2c_del_adapter(&pd->adap);\r\niounmap(pd->reg);\r\nsh_mobile_i2c_hook_irqs(dev, 0);\r\nclk_put(pd->clk);\r\npm_runtime_disable(&dev->dev);\r\nkfree(pd);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_i2c_runtime_nop(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init sh_mobile_i2c_adap_init(void)\r\n{\r\nreturn platform_driver_register(&sh_mobile_i2c_driver);\r\n}\r\nstatic void __exit sh_mobile_i2c_adap_exit(void)\r\n{\r\nplatform_driver_unregister(&sh_mobile_i2c_driver);\r\n}
