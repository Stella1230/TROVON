struct mpc8xxx_spi_probe_info *to_of_pinfo(struct fsl_spi_platform_data *pdata)\r\n{\r\nreturn container_of(pdata, struct mpc8xxx_spi_probe_info, pdata);\r\n}\r\nvoid mpc8xxx_spi_work(struct work_struct *work)\r\n{\r\nstruct mpc8xxx_spi *mpc8xxx_spi = container_of(work, struct mpc8xxx_spi,\r\nwork);\r\nspin_lock_irq(&mpc8xxx_spi->lock);\r\nwhile (!list_empty(&mpc8xxx_spi->queue)) {\r\nstruct spi_message *m = container_of(mpc8xxx_spi->queue.next,\r\nstruct spi_message, queue);\r\nlist_del_init(&m->queue);\r\nspin_unlock_irq(&mpc8xxx_spi->lock);\r\nif (mpc8xxx_spi->spi_do_one_msg)\r\nmpc8xxx_spi->spi_do_one_msg(m);\r\nspin_lock_irq(&mpc8xxx_spi->lock);\r\n}\r\nspin_unlock_irq(&mpc8xxx_spi->lock);\r\n}\r\nint mpc8xxx_spi_transfer(struct spi_device *spi,\r\nstruct spi_message *m)\r\n{\r\nstruct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);\r\nunsigned long flags;\r\nm->actual_length = 0;\r\nm->status = -EINPROGRESS;\r\nspin_lock_irqsave(&mpc8xxx_spi->lock, flags);\r\nlist_add_tail(&m->queue, &mpc8xxx_spi->queue);\r\nqueue_work(mpc8xxx_spi->workqueue, &mpc8xxx_spi->work);\r\nspin_unlock_irqrestore(&mpc8xxx_spi->lock, flags);\r\nreturn 0;\r\n}\r\nvoid mpc8xxx_spi_cleanup(struct spi_device *spi)\r\n{\r\nkfree(spi->controller_state);\r\n}\r\nconst char *mpc8xxx_spi_strmode(unsigned int flags)\r\n{\r\nif (flags & SPI_QE_CPU_MODE) {\r\nreturn "QE CPU";\r\n} else if (flags & SPI_CPM_MODE) {\r\nif (flags & SPI_QE)\r\nreturn "QE";\r\nelse if (flags & SPI_CPM2)\r\nreturn "CPM2";\r\nelse\r\nreturn "CPM1";\r\n}\r\nreturn "CPU";\r\n}\r\nint mpc8xxx_spi_probe(struct device *dev, struct resource *mem,\r\nunsigned int irq)\r\n{\r\nstruct fsl_spi_platform_data *pdata = dev->platform_data;\r\nstruct spi_master *master;\r\nstruct mpc8xxx_spi *mpc8xxx_spi;\r\nint ret = 0;\r\nmaster = dev_get_drvdata(dev);\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH\r\n| SPI_LSB_FIRST | SPI_LOOP;\r\nmaster->transfer = mpc8xxx_spi_transfer;\r\nmaster->cleanup = mpc8xxx_spi_cleanup;\r\nmaster->dev.of_node = dev->of_node;\r\nmpc8xxx_spi = spi_master_get_devdata(master);\r\nmpc8xxx_spi->dev = dev;\r\nmpc8xxx_spi->get_rx = mpc8xxx_spi_rx_buf_u8;\r\nmpc8xxx_spi->get_tx = mpc8xxx_spi_tx_buf_u8;\r\nmpc8xxx_spi->flags = pdata->flags;\r\nmpc8xxx_spi->spibrg = pdata->sysclk;\r\nmpc8xxx_spi->irq = irq;\r\nmpc8xxx_spi->rx_shift = 0;\r\nmpc8xxx_spi->tx_shift = 0;\r\ninit_completion(&mpc8xxx_spi->done);\r\nmaster->bus_num = pdata->bus_num;\r\nmaster->num_chipselect = pdata->max_chipselect;\r\nspin_lock_init(&mpc8xxx_spi->lock);\r\ninit_completion(&mpc8xxx_spi->done);\r\nINIT_WORK(&mpc8xxx_spi->work, mpc8xxx_spi_work);\r\nINIT_LIST_HEAD(&mpc8xxx_spi->queue);\r\nmpc8xxx_spi->workqueue = create_singlethread_workqueue(\r\ndev_name(master->dev.parent));\r\nif (mpc8xxx_spi->workqueue == NULL) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nint __devexit mpc8xxx_spi_remove(struct device *dev)\r\n{\r\nstruct mpc8xxx_spi *mpc8xxx_spi;\r\nstruct spi_master *master;\r\nmaster = dev_get_drvdata(dev);\r\nmpc8xxx_spi = spi_master_get_devdata(master);\r\nflush_workqueue(mpc8xxx_spi->workqueue);\r\ndestroy_workqueue(mpc8xxx_spi->workqueue);\r\nspi_unregister_master(master);\r\nfree_irq(mpc8xxx_spi->irq, mpc8xxx_spi);\r\nif (mpc8xxx_spi->spi_remove)\r\nmpc8xxx_spi->spi_remove(mpc8xxx_spi);\r\nreturn 0;\r\n}\r\nint __devinit of_mpc8xxx_spi_probe(struct platform_device *ofdev)\r\n{\r\nstruct device *dev = &ofdev->dev;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct mpc8xxx_spi_probe_info *pinfo;\r\nstruct fsl_spi_platform_data *pdata;\r\nconst void *prop;\r\nint ret = -ENOMEM;\r\npinfo = kzalloc(sizeof(*pinfo), GFP_KERNEL);\r\nif (!pinfo)\r\nreturn -ENOMEM;\r\npdata = &pinfo->pdata;\r\ndev->platform_data = pdata;\r\npdata->bus_num = -1;\r\npdata->sysclk = get_brgfreq();\r\nif (pdata->sysclk == -1) {\r\npdata->sysclk = fsl_get_sys_freq();\r\nif (pdata->sysclk == -1) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\n}\r\nprop = of_get_property(np, "mode", NULL);\r\nif (prop && !strcmp(prop, "cpu-qe"))\r\npdata->flags = SPI_QE_CPU_MODE;\r\nelse if (prop && !strcmp(prop, "qe"))\r\npdata->flags = SPI_CPM_MODE | SPI_QE;\r\nelse if (of_device_is_compatible(np, "fsl,cpm2-spi"))\r\npdata->flags = SPI_CPM_MODE | SPI_CPM2;\r\nelse if (of_device_is_compatible(np, "fsl,cpm1-spi"))\r\npdata->flags = SPI_CPM_MODE | SPI_CPM1;\r\nreturn 0;\r\nerr:\r\nkfree(pinfo);\r\nreturn ret;\r\n}
