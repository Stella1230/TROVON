static void aes_ccm_prepare(struct crypto_cipher *tfm, u8 *scratch, u8 *a)\r\n{\r\nint i;\r\nu8 *b_0, *aad, *b, *s_0;\r\nb_0 = scratch + 3 * AES_BLOCK_SIZE;\r\naad = scratch + 4 * AES_BLOCK_SIZE;\r\nb = scratch;\r\ns_0 = scratch + AES_BLOCK_SIZE;\r\ncrypto_cipher_encrypt_one(tfm, b, b_0);\r\nfor (i = 0; i < AES_BLOCK_SIZE; i++)\r\naad[i] ^= b[i];\r\ncrypto_cipher_encrypt_one(tfm, b, aad);\r\naad += AES_BLOCK_SIZE;\r\nfor (i = 0; i < AES_BLOCK_SIZE; i++)\r\naad[i] ^= b[i];\r\ncrypto_cipher_encrypt_one(tfm, a, aad);\r\nb_0[0] &= 0x07;\r\nb_0[14] = 0;\r\nb_0[15] = 0;\r\ncrypto_cipher_encrypt_one(tfm, s_0, b_0);\r\n}\r\nvoid ieee80211_aes_ccm_encrypt(struct crypto_cipher *tfm, u8 *scratch,\r\nu8 *data, size_t data_len,\r\nu8 *cdata, u8 *mic)\r\n{\r\nint i, j, last_len, num_blocks;\r\nu8 *pos, *cpos, *b, *s_0, *e, *b_0;\r\nb = scratch;\r\ns_0 = scratch + AES_BLOCK_SIZE;\r\ne = scratch + 2 * AES_BLOCK_SIZE;\r\nb_0 = scratch + 3 * AES_BLOCK_SIZE;\r\nnum_blocks = DIV_ROUND_UP(data_len, AES_BLOCK_SIZE);\r\nlast_len = data_len % AES_BLOCK_SIZE;\r\naes_ccm_prepare(tfm, scratch, b);\r\npos = data;\r\ncpos = cdata;\r\nfor (j = 1; j <= num_blocks; j++) {\r\nint blen = (j == num_blocks && last_len) ?\r\nlast_len : AES_BLOCK_SIZE;\r\nfor (i = 0; i < blen; i++)\r\nb[i] ^= pos[i];\r\ncrypto_cipher_encrypt_one(tfm, b, b);\r\nb_0[14] = (j >> 8) & 0xff;\r\nb_0[15] = j & 0xff;\r\ncrypto_cipher_encrypt_one(tfm, e, b_0);\r\nfor (i = 0; i < blen; i++)\r\n*cpos++ = *pos++ ^ e[i];\r\n}\r\nfor (i = 0; i < CCMP_MIC_LEN; i++)\r\nmic[i] = b[i] ^ s_0[i];\r\n}\r\nint ieee80211_aes_ccm_decrypt(struct crypto_cipher *tfm, u8 *scratch,\r\nu8 *cdata, size_t data_len, u8 *mic, u8 *data)\r\n{\r\nint i, j, last_len, num_blocks;\r\nu8 *pos, *cpos, *b, *s_0, *a, *b_0;\r\nb = scratch;\r\ns_0 = scratch + AES_BLOCK_SIZE;\r\na = scratch + 2 * AES_BLOCK_SIZE;\r\nb_0 = scratch + 3 * AES_BLOCK_SIZE;\r\nnum_blocks = DIV_ROUND_UP(data_len, AES_BLOCK_SIZE);\r\nlast_len = data_len % AES_BLOCK_SIZE;\r\naes_ccm_prepare(tfm, scratch, a);\r\ncpos = cdata;\r\npos = data;\r\nfor (j = 1; j <= num_blocks; j++) {\r\nint blen = (j == num_blocks && last_len) ?\r\nlast_len : AES_BLOCK_SIZE;\r\nb_0[14] = (j >> 8) & 0xff;\r\nb_0[15] = j & 0xff;\r\ncrypto_cipher_encrypt_one(tfm, b, b_0);\r\nfor (i = 0; i < blen; i++) {\r\n*pos = *cpos++ ^ b[i];\r\na[i] ^= *pos++;\r\n}\r\ncrypto_cipher_encrypt_one(tfm, a, a);\r\n}\r\nfor (i = 0; i < CCMP_MIC_LEN; i++) {\r\nif ((mic[i] ^ s_0[i]) != a[i])\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstruct crypto_cipher *ieee80211_aes_key_setup_encrypt(const u8 key[])\r\n{\r\nstruct crypto_cipher *tfm;\r\ntfm = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);\r\nif (!IS_ERR(tfm))\r\ncrypto_cipher_setkey(tfm, key, ALG_CCMP_KEY_LEN);\r\nreturn tfm;\r\n}\r\nvoid ieee80211_aes_key_free(struct crypto_cipher *tfm)\r\n{\r\ncrypto_free_cipher(tfm);\r\n}
