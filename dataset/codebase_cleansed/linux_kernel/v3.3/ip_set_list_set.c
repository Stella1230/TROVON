static inline struct set_elem *\r\nlist_set_elem(const struct list_set *map, u32 id)\r\n{\r\nreturn (struct set_elem *)((void *)map->members + id * map->dsize);\r\n}\r\nstatic inline struct set_telem *\r\nlist_set_telem(const struct list_set *map, u32 id)\r\n{\r\nreturn (struct set_telem *)((void *)map->members + id * map->dsize);\r\n}\r\nstatic inline bool\r\nlist_set_timeout(const struct list_set *map, u32 id)\r\n{\r\nconst struct set_telem *elem = list_set_telem(map, id);\r\nreturn ip_set_timeout_test(elem->timeout);\r\n}\r\nstatic inline bool\r\nlist_set_expired(const struct list_set *map, u32 id)\r\n{\r\nconst struct set_telem *elem = list_set_telem(map, id);\r\nreturn ip_set_timeout_expired(elem->timeout);\r\n}\r\nstatic int\r\nlist_set_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, const struct ip_set_adt_opt *opt)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_elem *elem;\r\nu32 i;\r\nint ret;\r\nfor (i = 0; i < map->size; i++) {\r\nelem = list_set_elem(map, i);\r\nif (elem->id == IPSET_INVALID_ID)\r\nreturn 0;\r\nif (with_timeout(map->timeout) && list_set_expired(map, i))\r\ncontinue;\r\nswitch (adt) {\r\ncase IPSET_TEST:\r\nret = ip_set_test(elem->id, skb, par, opt);\r\nif (ret > 0)\r\nreturn ret;\r\nbreak;\r\ncase IPSET_ADD:\r\nret = ip_set_add(elem->id, skb, par, opt);\r\nif (ret == 0)\r\nreturn ret;\r\nbreak;\r\ncase IPSET_DEL:\r\nret = ip_set_del(elem->id, skb, par, opt);\r\nif (ret == 0)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic bool\r\nid_eq(const struct list_set *map, u32 i, ip_set_id_t id)\r\n{\r\nconst struct set_elem *elem;\r\nif (i < map->size) {\r\nelem = list_set_elem(map, i);\r\nreturn elem->id == id;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool\r\nid_eq_timeout(const struct list_set *map, u32 i, ip_set_id_t id)\r\n{\r\nconst struct set_elem *elem;\r\nif (i < map->size) {\r\nelem = list_set_elem(map, i);\r\nreturn !!(elem->id == id &&\r\n!(with_timeout(map->timeout) &&\r\nlist_set_expired(map, i)));\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlist_elem_add(struct list_set *map, u32 i, ip_set_id_t id)\r\n{\r\nstruct set_elem *e;\r\nfor (; i < map->size; i++) {\r\ne = list_set_elem(map, i);\r\nswap(e->id, id);\r\nif (e->id == IPSET_INVALID_ID)\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nlist_elem_tadd(struct list_set *map, u32 i, ip_set_id_t id,\r\nunsigned long timeout)\r\n{\r\nstruct set_telem *e;\r\nfor (; i < map->size; i++) {\r\ne = list_set_telem(map, i);\r\nswap(e->id, id);\r\nswap(e->timeout, timeout);\r\nif (e->id == IPSET_INVALID_ID)\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nlist_set_add(struct list_set *map, u32 i, ip_set_id_t id,\r\nunsigned long timeout)\r\n{\r\nconst struct set_elem *e = list_set_elem(map, i);\r\nif (i == map->size - 1 && e->id != IPSET_INVALID_ID)\r\nip_set_put_byindex(e->id);\r\nif (with_timeout(map->timeout))\r\nlist_elem_tadd(map, i, id, ip_set_timeout_set(timeout));\r\nelse\r\nlist_elem_add(map, i, id);\r\nreturn 0;\r\n}\r\nstatic int\r\nlist_set_del(struct list_set *map, u32 i)\r\n{\r\nstruct set_elem *a = list_set_elem(map, i), *b;\r\nip_set_put_byindex(a->id);\r\nfor (; i < map->size - 1; i++) {\r\nb = list_set_elem(map, i + 1);\r\na->id = b->id;\r\nif (with_timeout(map->timeout))\r\n((struct set_telem *)a)->timeout =\r\n((struct set_telem *)b)->timeout;\r\na = b;\r\nif (a->id == IPSET_INVALID_ID)\r\nbreak;\r\n}\r\na->id = IPSET_INVALID_ID;\r\nreturn 0;\r\n}\r\nstatic void\r\ncleanup_entries(struct list_set *map)\r\n{\r\nstruct set_telem *e;\r\nu32 i;\r\nfor (i = 0; i < map->size; i++) {\r\ne = list_set_telem(map, i);\r\nif (e->id != IPSET_INVALID_ID && list_set_expired(map, i))\r\nlist_set_del(map, i);\r\n}\r\n}\r\nstatic int\r\nlist_set_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nstruct list_set *map = set->data;\r\nbool with_timeout = with_timeout(map->timeout);\r\nbool flag_exist = flags & IPSET_FLAG_EXIST;\r\nint before = 0;\r\nu32 timeout = map->timeout;\r\nip_set_id_t id, refid = IPSET_INVALID_ID;\r\nconst struct set_elem *elem;\r\nstruct ip_set *s;\r\nu32 i;\r\nint ret = 0;\r\nif (unlikely(!tb[IPSET_ATTR_NAME] ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nid = ip_set_get_byname(nla_data(tb[IPSET_ATTR_NAME]), &s);\r\nif (id == IPSET_INVALID_ID)\r\nreturn -IPSET_ERR_NAME;\r\nif (s->type->features & IPSET_TYPE_NAME) {\r\nret = -IPSET_ERR_LOOP;\r\ngoto finish;\r\n}\r\nif (tb[IPSET_ATTR_CADT_FLAGS]) {\r\nu32 f = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);\r\nbefore = f & IPSET_FLAG_BEFORE;\r\n}\r\nif (before && !tb[IPSET_ATTR_NAMEREF]) {\r\nret = -IPSET_ERR_BEFORE;\r\ngoto finish;\r\n}\r\nif (tb[IPSET_ATTR_NAMEREF]) {\r\nrefid = ip_set_get_byname(nla_data(tb[IPSET_ATTR_NAMEREF]),\r\n&s);\r\nif (refid == IPSET_INVALID_ID) {\r\nret = -IPSET_ERR_NAMEREF;\r\ngoto finish;\r\n}\r\nif (!before)\r\nbefore = -1;\r\n}\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nif (!with_timeout) {\r\nret = -IPSET_ERR_TIMEOUT;\r\ngoto finish;\r\n}\r\ntimeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\n}\r\nif (with_timeout && adt != IPSET_TEST)\r\ncleanup_entries(map);\r\nswitch (adt) {\r\ncase IPSET_TEST:\r\nfor (i = 0; i < map->size && !ret; i++) {\r\nelem = list_set_elem(map, i);\r\nif (elem->id == IPSET_INVALID_ID ||\r\n(before != 0 && i + 1 >= map->size))\r\nbreak;\r\nelse if (with_timeout && list_set_expired(map, i))\r\ncontinue;\r\nelse if (before > 0 && elem->id == id)\r\nret = id_eq_timeout(map, i + 1, refid);\r\nelse if (before < 0 && elem->id == refid)\r\nret = id_eq_timeout(map, i + 1, id);\r\nelse if (before == 0 && elem->id == id)\r\nret = 1;\r\n}\r\nbreak;\r\ncase IPSET_ADD:\r\nfor (i = 0; i < map->size; i++) {\r\nelem = list_set_elem(map, i);\r\nif (elem->id != id)\r\ncontinue;\r\nif (!(with_timeout && flag_exist)) {\r\nret = -IPSET_ERR_EXIST;\r\ngoto finish;\r\n} else {\r\nstruct set_telem *e = list_set_telem(map, i);\r\nif ((before > 1 &&\r\n!id_eq(map, i + 1, refid)) ||\r\n(before < 0 &&\r\n(i == 0 || !id_eq(map, i - 1, refid)))) {\r\nret = -IPSET_ERR_EXIST;\r\ngoto finish;\r\n}\r\ne->timeout = ip_set_timeout_set(timeout);\r\nip_set_put_byindex(id);\r\nret = 0;\r\ngoto finish;\r\n}\r\n}\r\nret = -IPSET_ERR_LIST_FULL;\r\nfor (i = 0; i < map->size && ret == -IPSET_ERR_LIST_FULL; i++) {\r\nelem = list_set_elem(map, i);\r\nif (elem->id == IPSET_INVALID_ID)\r\nret = before != 0 ? -IPSET_ERR_REF_EXIST\r\n: list_set_add(map, i, id, timeout);\r\nelse if (elem->id != refid)\r\ncontinue;\r\nelse if (before > 0)\r\nret = list_set_add(map, i, id, timeout);\r\nelse if (i + 1 < map->size)\r\nret = list_set_add(map, i + 1, id, timeout);\r\n}\r\nbreak;\r\ncase IPSET_DEL:\r\nret = -IPSET_ERR_EXIST;\r\nfor (i = 0; i < map->size && ret == -IPSET_ERR_EXIST; i++) {\r\nelem = list_set_elem(map, i);\r\nif (elem->id == IPSET_INVALID_ID) {\r\nret = before != 0 ? -IPSET_ERR_REF_EXIST\r\n: -IPSET_ERR_EXIST;\r\nbreak;\r\n} else if (elem->id == id &&\r\n(before == 0 ||\r\n(before > 0 && id_eq(map, i + 1, refid))))\r\nret = list_set_del(map, i);\r\nelse if (elem->id == refid &&\r\nbefore < 0 && id_eq(map, i + 1, id))\r\nret = list_set_del(map, i + 1);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfinish:\r\nif (refid != IPSET_INVALID_ID)\r\nip_set_put_byindex(refid);\r\nif (adt != IPSET_ADD || ret)\r\nip_set_put_byindex(id);\r\nreturn ip_set_eexist(ret, flags) ? 0 : ret;\r\n}\r\nstatic void\r\nlist_set_flush(struct ip_set *set)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_elem *elem;\r\nu32 i;\r\nfor (i = 0; i < map->size; i++) {\r\nelem = list_set_elem(map, i);\r\nif (elem->id != IPSET_INVALID_ID) {\r\nip_set_put_byindex(elem->id);\r\nelem->id = IPSET_INVALID_ID;\r\n}\r\n}\r\n}\r\nstatic void\r\nlist_set_destroy(struct ip_set *set)\r\n{\r\nstruct list_set *map = set->data;\r\nif (with_timeout(map->timeout))\r\ndel_timer_sync(&map->gc);\r\nlist_set_flush(set);\r\nkfree(map);\r\nset->data = NULL;\r\n}\r\nstatic int\r\nlist_set_head(struct ip_set *set, struct sk_buff *skb)\r\n{\r\nconst struct list_set *map = set->data;\r\nstruct nlattr *nested;\r\nnested = ipset_nest_start(skb, IPSET_ATTR_DATA);\r\nif (!nested)\r\ngoto nla_put_failure;\r\nNLA_PUT_NET32(skb, IPSET_ATTR_SIZE, htonl(map->size));\r\nif (with_timeout(map->timeout))\r\nNLA_PUT_NET32(skb, IPSET_ATTR_TIMEOUT, htonl(map->timeout));\r\nNLA_PUT_NET32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref - 1));\r\nNLA_PUT_NET32(skb, IPSET_ATTR_MEMSIZE,\r\nhtonl(sizeof(*map) + map->size * map->dsize));\r\nipset_nest_end(skb, nested);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nlist_set_list(const struct ip_set *set,\r\nstruct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nconst struct list_set *map = set->data;\r\nstruct nlattr *atd, *nested;\r\nu32 i, first = cb->args[2];\r\nconst struct set_elem *e;\r\natd = ipset_nest_start(skb, IPSET_ATTR_ADT);\r\nif (!atd)\r\nreturn -EMSGSIZE;\r\nfor (; cb->args[2] < map->size; cb->args[2]++) {\r\ni = cb->args[2];\r\ne = list_set_elem(map, i);\r\nif (e->id == IPSET_INVALID_ID)\r\ngoto finish;\r\nif (with_timeout(map->timeout) && list_set_expired(map, i))\r\ncontinue;\r\nnested = ipset_nest_start(skb, IPSET_ATTR_DATA);\r\nif (!nested) {\r\nif (i == first) {\r\nnla_nest_cancel(skb, atd);\r\nreturn -EMSGSIZE;\r\n} else\r\ngoto nla_put_failure;\r\n}\r\nNLA_PUT_STRING(skb, IPSET_ATTR_NAME,\r\nip_set_name_byindex(e->id));\r\nif (with_timeout(map->timeout)) {\r\nconst struct set_telem *te =\r\n(const struct set_telem *) e;\r\nNLA_PUT_NET32(skb, IPSET_ATTR_TIMEOUT,\r\nhtonl(ip_set_timeout_get(te->timeout)));\r\n}\r\nipset_nest_end(skb, nested);\r\n}\r\nfinish:\r\nipset_nest_end(skb, atd);\r\ncb->args[2] = 0;\r\nreturn 0;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nested);\r\nipset_nest_end(skb, atd);\r\nif (unlikely(i == first)) {\r\ncb->args[2] = 0;\r\nreturn -EMSGSIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool\r\nlist_set_same_set(const struct ip_set *a, const struct ip_set *b)\r\n{\r\nconst struct list_set *x = a->data;\r\nconst struct list_set *y = b->data;\r\nreturn x->size == y->size &&\r\nx->timeout == y->timeout;\r\n}\r\nstatic void\r\nlist_set_gc(unsigned long ul_set)\r\n{\r\nstruct ip_set *set = (struct ip_set *) ul_set;\r\nstruct list_set *map = set->data;\r\nwrite_lock_bh(&set->lock);\r\ncleanup_entries(map);\r\nwrite_unlock_bh(&set->lock);\r\nmap->gc.expires = jiffies + IPSET_GC_PERIOD(map->timeout) * HZ;\r\nadd_timer(&map->gc);\r\n}\r\nstatic void\r\nlist_set_gc_init(struct ip_set *set)\r\n{\r\nstruct list_set *map = set->data;\r\ninit_timer(&map->gc);\r\nmap->gc.data = (unsigned long) set;\r\nmap->gc.function = list_set_gc;\r\nmap->gc.expires = jiffies + IPSET_GC_PERIOD(map->timeout) * HZ;\r\nadd_timer(&map->gc);\r\n}\r\nstatic bool\r\ninit_list_set(struct ip_set *set, u32 size, size_t dsize,\r\nunsigned long timeout)\r\n{\r\nstruct list_set *map;\r\nstruct set_elem *e;\r\nu32 i;\r\nmap = kzalloc(sizeof(*map) + size * dsize, GFP_KERNEL);\r\nif (!map)\r\nreturn false;\r\nmap->size = size;\r\nmap->dsize = dsize;\r\nmap->timeout = timeout;\r\nset->data = map;\r\nfor (i = 0; i < size; i++) {\r\ne = list_set_elem(map, i);\r\ne->id = IPSET_INVALID_ID;\r\n}\r\nreturn true;\r\n}\r\nstatic int\r\nlist_set_create(struct ip_set *set, struct nlattr *tb[], u32 flags)\r\n{\r\nu32 size = IP_SET_LIST_DEFAULT_SIZE;\r\nif (unlikely(!ip_set_optattr_netorder(tb, IPSET_ATTR_SIZE) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_SIZE])\r\nsize = ip_set_get_h32(tb[IPSET_ATTR_SIZE]);\r\nif (size < IP_SET_LIST_MIN_SIZE)\r\nsize = IP_SET_LIST_MIN_SIZE;\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nif (!init_list_set(set, size, sizeof(struct set_telem),\r\nip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT])))\r\nreturn -ENOMEM;\r\nlist_set_gc_init(set);\r\n} else {\r\nif (!init_list_set(set, size, sizeof(struct set_elem),\r\nIPSET_NO_TIMEOUT))\r\nreturn -ENOMEM;\r\n}\r\nset->variant = &list_set;\r\nreturn 0;\r\n}\r\nstatic int __init\r\nlist_set_init(void)\r\n{\r\nreturn ip_set_type_register(&list_set_type);\r\n}\r\nstatic void __exit\r\nlist_set_fini(void)\r\n{\r\nip_set_type_unregister(&list_set_type);\r\n}
