static int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int shash_setkey_unaligned(struct crypto_shash *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct shash_alg *shash = crypto_shash_alg(tfm);\r\nunsigned long alignmask = crypto_shash_alignmask(tfm);\r\nunsigned long absize;\r\nu8 *buffer, *alignbuffer;\r\nint err;\r\nabsize = keylen + (alignmask & ~(crypto_tfm_ctx_alignment() - 1));\r\nbuffer = kmalloc(absize, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nalignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);\r\nmemcpy(alignbuffer, key, keylen);\r\nerr = shash->setkey(tfm, alignbuffer, keylen);\r\nkzfree(buffer);\r\nreturn err;\r\n}\r\nint crypto_shash_setkey(struct crypto_shash *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct shash_alg *shash = crypto_shash_alg(tfm);\r\nunsigned long alignmask = crypto_shash_alignmask(tfm);\r\nif ((unsigned long)key & alignmask)\r\nreturn shash_setkey_unaligned(tfm, key, keylen);\r\nreturn shash->setkey(tfm, key, keylen);\r\n}\r\nstatic inline unsigned int shash_align_buffer_size(unsigned len,\r\nunsigned long mask)\r\n{\r\nreturn len + (mask & ~(__alignof__(u8 __attribute__ ((aligned))) - 1));\r\n}\r\nstatic int shash_update_unaligned(struct shash_desc *desc, const u8 *data,\r\nunsigned int len)\r\n{\r\nstruct crypto_shash *tfm = desc->tfm;\r\nstruct shash_alg *shash = crypto_shash_alg(tfm);\r\nunsigned long alignmask = crypto_shash_alignmask(tfm);\r\nunsigned int unaligned_len = alignmask + 1 -\r\n((unsigned long)data & alignmask);\r\nu8 ubuf[shash_align_buffer_size(unaligned_len, alignmask)]\r\n__attribute__ ((aligned));\r\nu8 *buf = PTR_ALIGN(&ubuf[0], alignmask + 1);\r\nint err;\r\nif (unaligned_len > len)\r\nunaligned_len = len;\r\nmemcpy(buf, data, unaligned_len);\r\nerr = shash->update(desc, buf, unaligned_len);\r\nmemset(buf, 0, unaligned_len);\r\nreturn err ?:\r\nshash->update(desc, data + unaligned_len, len - unaligned_len);\r\n}\r\nint crypto_shash_update(struct shash_desc *desc, const u8 *data,\r\nunsigned int len)\r\n{\r\nstruct crypto_shash *tfm = desc->tfm;\r\nstruct shash_alg *shash = crypto_shash_alg(tfm);\r\nunsigned long alignmask = crypto_shash_alignmask(tfm);\r\nif ((unsigned long)data & alignmask)\r\nreturn shash_update_unaligned(desc, data, len);\r\nreturn shash->update(desc, data, len);\r\n}\r\nstatic int shash_final_unaligned(struct shash_desc *desc, u8 *out)\r\n{\r\nstruct crypto_shash *tfm = desc->tfm;\r\nunsigned long alignmask = crypto_shash_alignmask(tfm);\r\nstruct shash_alg *shash = crypto_shash_alg(tfm);\r\nunsigned int ds = crypto_shash_digestsize(tfm);\r\nu8 ubuf[shash_align_buffer_size(ds, alignmask)]\r\n__attribute__ ((aligned));\r\nu8 *buf = PTR_ALIGN(&ubuf[0], alignmask + 1);\r\nint err;\r\nerr = shash->final(desc, buf);\r\nif (err)\r\ngoto out;\r\nmemcpy(out, buf, ds);\r\nout:\r\nmemset(buf, 0, ds);\r\nreturn err;\r\n}\r\nint crypto_shash_final(struct shash_desc *desc, u8 *out)\r\n{\r\nstruct crypto_shash *tfm = desc->tfm;\r\nstruct shash_alg *shash = crypto_shash_alg(tfm);\r\nunsigned long alignmask = crypto_shash_alignmask(tfm);\r\nif ((unsigned long)out & alignmask)\r\nreturn shash_final_unaligned(desc, out);\r\nreturn shash->final(desc, out);\r\n}\r\nstatic int shash_finup_unaligned(struct shash_desc *desc, const u8 *data,\r\nunsigned int len, u8 *out)\r\n{\r\nreturn crypto_shash_update(desc, data, len) ?:\r\ncrypto_shash_final(desc, out);\r\n}\r\nint crypto_shash_finup(struct shash_desc *desc, const u8 *data,\r\nunsigned int len, u8 *out)\r\n{\r\nstruct crypto_shash *tfm = desc->tfm;\r\nstruct shash_alg *shash = crypto_shash_alg(tfm);\r\nunsigned long alignmask = crypto_shash_alignmask(tfm);\r\nif (((unsigned long)data | (unsigned long)out) & alignmask)\r\nreturn shash_finup_unaligned(desc, data, len, out);\r\nreturn shash->finup(desc, data, len, out);\r\n}\r\nstatic int shash_digest_unaligned(struct shash_desc *desc, const u8 *data,\r\nunsigned int len, u8 *out)\r\n{\r\nreturn crypto_shash_init(desc) ?:\r\ncrypto_shash_finup(desc, data, len, out);\r\n}\r\nint crypto_shash_digest(struct shash_desc *desc, const u8 *data,\r\nunsigned int len, u8 *out)\r\n{\r\nstruct crypto_shash *tfm = desc->tfm;\r\nstruct shash_alg *shash = crypto_shash_alg(tfm);\r\nunsigned long alignmask = crypto_shash_alignmask(tfm);\r\nif (((unsigned long)data | (unsigned long)out) & alignmask)\r\nreturn shash_digest_unaligned(desc, data, len, out);\r\nreturn shash->digest(desc, data, len, out);\r\n}\r\nstatic int shash_default_export(struct shash_desc *desc, void *out)\r\n{\r\nmemcpy(out, shash_desc_ctx(desc), crypto_shash_descsize(desc->tfm));\r\nreturn 0;\r\n}\r\nstatic int shash_default_import(struct shash_desc *desc, const void *in)\r\n{\r\nmemcpy(shash_desc_ctx(desc), in, crypto_shash_descsize(desc->tfm));\r\nreturn 0;\r\n}\r\nstatic int shash_async_setkey(struct crypto_ahash *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_shash **ctx = crypto_ahash_ctx(tfm);\r\nreturn crypto_shash_setkey(*ctx, key, keylen);\r\n}\r\nstatic int shash_async_init(struct ahash_request *req)\r\n{\r\nstruct crypto_shash **ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));\r\nstruct shash_desc *desc = ahash_request_ctx(req);\r\ndesc->tfm = *ctx;\r\ndesc->flags = req->base.flags;\r\nreturn crypto_shash_init(desc);\r\n}\r\nint shash_ahash_update(struct ahash_request *req, struct shash_desc *desc)\r\n{\r\nstruct crypto_hash_walk walk;\r\nint nbytes;\r\nfor (nbytes = crypto_hash_walk_first(req, &walk); nbytes > 0;\r\nnbytes = crypto_hash_walk_done(&walk, nbytes))\r\nnbytes = crypto_shash_update(desc, walk.data, nbytes);\r\nreturn nbytes;\r\n}\r\nstatic int shash_async_update(struct ahash_request *req)\r\n{\r\nreturn shash_ahash_update(req, ahash_request_ctx(req));\r\n}\r\nstatic int shash_async_final(struct ahash_request *req)\r\n{\r\nreturn crypto_shash_final(ahash_request_ctx(req), req->result);\r\n}\r\nint shash_ahash_finup(struct ahash_request *req, struct shash_desc *desc)\r\n{\r\nstruct crypto_hash_walk walk;\r\nint nbytes;\r\nnbytes = crypto_hash_walk_first(req, &walk);\r\nif (!nbytes)\r\nreturn crypto_shash_final(desc, req->result);\r\ndo {\r\nnbytes = crypto_hash_walk_last(&walk) ?\r\ncrypto_shash_finup(desc, walk.data, nbytes,\r\nreq->result) :\r\ncrypto_shash_update(desc, walk.data, nbytes);\r\nnbytes = crypto_hash_walk_done(&walk, nbytes);\r\n} while (nbytes > 0);\r\nreturn nbytes;\r\n}\r\nstatic int shash_async_finup(struct ahash_request *req)\r\n{\r\nstruct crypto_shash **ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));\r\nstruct shash_desc *desc = ahash_request_ctx(req);\r\ndesc->tfm = *ctx;\r\ndesc->flags = req->base.flags;\r\nreturn shash_ahash_finup(req, desc);\r\n}\r\nint shash_ahash_digest(struct ahash_request *req, struct shash_desc *desc)\r\n{\r\nstruct scatterlist *sg = req->src;\r\nunsigned int offset = sg->offset;\r\nunsigned int nbytes = req->nbytes;\r\nint err;\r\nif (nbytes < min(sg->length, ((unsigned int)(PAGE_SIZE)) - offset)) {\r\nvoid *data;\r\ndata = crypto_kmap(sg_page(sg), 0);\r\nerr = crypto_shash_digest(desc, data + offset, nbytes,\r\nreq->result);\r\ncrypto_kunmap(data, 0);\r\ncrypto_yield(desc->flags);\r\n} else\r\nerr = crypto_shash_init(desc) ?:\r\nshash_ahash_finup(req, desc);\r\nreturn err;\r\n}\r\nstatic int shash_async_digest(struct ahash_request *req)\r\n{\r\nstruct crypto_shash **ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));\r\nstruct shash_desc *desc = ahash_request_ctx(req);\r\ndesc->tfm = *ctx;\r\ndesc->flags = req->base.flags;\r\nreturn shash_ahash_digest(req, desc);\r\n}\r\nstatic int shash_async_export(struct ahash_request *req, void *out)\r\n{\r\nreturn crypto_shash_export(ahash_request_ctx(req), out);\r\n}\r\nstatic int shash_async_import(struct ahash_request *req, const void *in)\r\n{\r\nstruct crypto_shash **ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));\r\nstruct shash_desc *desc = ahash_request_ctx(req);\r\ndesc->tfm = *ctx;\r\ndesc->flags = req->base.flags;\r\nreturn crypto_shash_import(desc, in);\r\n}\r\nstatic void crypto_exit_shash_ops_async(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_shash **ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_shash(*ctx);\r\n}\r\nint crypto_init_shash_ops_async(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_alg *calg = tfm->__crt_alg;\r\nstruct shash_alg *alg = __crypto_shash_alg(calg);\r\nstruct crypto_ahash *crt = __crypto_ahash_cast(tfm);\r\nstruct crypto_shash **ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_shash *shash;\r\nif (!crypto_mod_get(calg))\r\nreturn -EAGAIN;\r\nshash = crypto_create_tfm(calg, &crypto_shash_type);\r\nif (IS_ERR(shash)) {\r\ncrypto_mod_put(calg);\r\nreturn PTR_ERR(shash);\r\n}\r\n*ctx = shash;\r\ntfm->exit = crypto_exit_shash_ops_async;\r\ncrt->init = shash_async_init;\r\ncrt->update = shash_async_update;\r\ncrt->final = shash_async_final;\r\ncrt->finup = shash_async_finup;\r\ncrt->digest = shash_async_digest;\r\nif (alg->setkey)\r\ncrt->setkey = shash_async_setkey;\r\nif (alg->export)\r\ncrt->export = shash_async_export;\r\nif (alg->import)\r\ncrt->import = shash_async_import;\r\ncrt->reqsize = sizeof(struct shash_desc) + crypto_shash_descsize(shash);\r\nreturn 0;\r\n}\r\nstatic int shash_compat_setkey(struct crypto_hash *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct shash_desc **descp = crypto_hash_ctx(tfm);\r\nstruct shash_desc *desc = *descp;\r\nreturn crypto_shash_setkey(desc->tfm, key, keylen);\r\n}\r\nstatic int shash_compat_init(struct hash_desc *hdesc)\r\n{\r\nstruct shash_desc **descp = crypto_hash_ctx(hdesc->tfm);\r\nstruct shash_desc *desc = *descp;\r\ndesc->flags = hdesc->flags;\r\nreturn crypto_shash_init(desc);\r\n}\r\nstatic int shash_compat_update(struct hash_desc *hdesc, struct scatterlist *sg,\r\nunsigned int len)\r\n{\r\nstruct shash_desc **descp = crypto_hash_ctx(hdesc->tfm);\r\nstruct shash_desc *desc = *descp;\r\nstruct crypto_hash_walk walk;\r\nint nbytes;\r\nfor (nbytes = crypto_hash_walk_first_compat(hdesc, &walk, sg, len);\r\nnbytes > 0; nbytes = crypto_hash_walk_done(&walk, nbytes))\r\nnbytes = crypto_shash_update(desc, walk.data, nbytes);\r\nreturn nbytes;\r\n}\r\nstatic int shash_compat_final(struct hash_desc *hdesc, u8 *out)\r\n{\r\nstruct shash_desc **descp = crypto_hash_ctx(hdesc->tfm);\r\nreturn crypto_shash_final(*descp, out);\r\n}\r\nstatic int shash_compat_digest(struct hash_desc *hdesc, struct scatterlist *sg,\r\nunsigned int nbytes, u8 *out)\r\n{\r\nunsigned int offset = sg->offset;\r\nint err;\r\nif (nbytes < min(sg->length, ((unsigned int)(PAGE_SIZE)) - offset)) {\r\nstruct shash_desc **descp = crypto_hash_ctx(hdesc->tfm);\r\nstruct shash_desc *desc = *descp;\r\nvoid *data;\r\ndesc->flags = hdesc->flags;\r\ndata = crypto_kmap(sg_page(sg), 0);\r\nerr = crypto_shash_digest(desc, data + offset, nbytes, out);\r\ncrypto_kunmap(data, 0);\r\ncrypto_yield(desc->flags);\r\ngoto out;\r\n}\r\nerr = shash_compat_init(hdesc);\r\nif (err)\r\ngoto out;\r\nerr = shash_compat_update(hdesc, sg, nbytes);\r\nif (err)\r\ngoto out;\r\nerr = shash_compat_final(hdesc, out);\r\nout:\r\nreturn err;\r\n}\r\nstatic void crypto_exit_shash_ops_compat(struct crypto_tfm *tfm)\r\n{\r\nstruct shash_desc **descp = crypto_tfm_ctx(tfm);\r\nstruct shash_desc *desc = *descp;\r\ncrypto_free_shash(desc->tfm);\r\nkzfree(desc);\r\n}\r\nstatic int crypto_init_shash_ops_compat(struct crypto_tfm *tfm)\r\n{\r\nstruct hash_tfm *crt = &tfm->crt_hash;\r\nstruct crypto_alg *calg = tfm->__crt_alg;\r\nstruct shash_alg *alg = __crypto_shash_alg(calg);\r\nstruct shash_desc **descp = crypto_tfm_ctx(tfm);\r\nstruct crypto_shash *shash;\r\nstruct shash_desc *desc;\r\nif (!crypto_mod_get(calg))\r\nreturn -EAGAIN;\r\nshash = crypto_create_tfm(calg, &crypto_shash_type);\r\nif (IS_ERR(shash)) {\r\ncrypto_mod_put(calg);\r\nreturn PTR_ERR(shash);\r\n}\r\ndesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(shash),\r\nGFP_KERNEL);\r\nif (!desc) {\r\ncrypto_free_shash(shash);\r\nreturn -ENOMEM;\r\n}\r\n*descp = desc;\r\ndesc->tfm = shash;\r\ntfm->exit = crypto_exit_shash_ops_compat;\r\ncrt->init = shash_compat_init;\r\ncrt->update = shash_compat_update;\r\ncrt->final = shash_compat_final;\r\ncrt->digest = shash_compat_digest;\r\ncrt->setkey = shash_compat_setkey;\r\ncrt->digestsize = alg->digestsize;\r\nreturn 0;\r\n}\r\nstatic int crypto_init_shash_ops(struct crypto_tfm *tfm, u32 type, u32 mask)\r\n{\r\nswitch (mask & CRYPTO_ALG_TYPE_MASK) {\r\ncase CRYPTO_ALG_TYPE_HASH_MASK:\r\nreturn crypto_init_shash_ops_compat(tfm);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned int crypto_shash_ctxsize(struct crypto_alg *alg, u32 type,\r\nu32 mask)\r\n{\r\nswitch (mask & CRYPTO_ALG_TYPE_MASK) {\r\ncase CRYPTO_ALG_TYPE_HASH_MASK:\r\nreturn sizeof(struct shash_desc *);\r\n}\r\nreturn 0;\r\n}\r\nstatic int crypto_shash_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_shash *hash = __crypto_shash_cast(tfm);\r\nhash->descsize = crypto_shash_alg(hash)->descsize;\r\nreturn 0;\r\n}\r\nstatic unsigned int crypto_shash_extsize(struct crypto_alg *alg)\r\n{\r\nreturn alg->cra_ctxsize;\r\n}\r\nstatic int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nstruct crypto_report_hash rhash;\r\nstruct shash_alg *salg = __crypto_shash_alg(alg);\r\nsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, "%s", "shash");\r\nrhash.blocksize = alg->cra_blocksize;\r\nrhash.digestsize = salg->digestsize;\r\nNLA_PUT(skb, CRYPTOCFGA_REPORT_HASH,\r\nsizeof(struct crypto_report_hash), &rhash);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic void crypto_shash_show(struct seq_file *m, struct crypto_alg *alg)\r\n{\r\nstruct shash_alg *salg = __crypto_shash_alg(alg);\r\nseq_printf(m, "type : shash\n");\r\nseq_printf(m, "blocksize : %u\n", alg->cra_blocksize);\r\nseq_printf(m, "digestsize : %u\n", salg->digestsize);\r\n}\r\nstruct crypto_shash *crypto_alloc_shash(const char *alg_name, u32 type,\r\nu32 mask)\r\n{\r\nreturn crypto_alloc_tfm(alg_name, &crypto_shash_type, type, mask);\r\n}\r\nstatic int shash_prepare_alg(struct shash_alg *alg)\r\n{\r\nstruct crypto_alg *base = &alg->base;\r\nif (alg->digestsize > PAGE_SIZE / 8 ||\r\nalg->descsize > PAGE_SIZE / 8 ||\r\nalg->statesize > PAGE_SIZE / 8)\r\nreturn -EINVAL;\r\nbase->cra_type = &crypto_shash_type;\r\nbase->cra_flags &= ~CRYPTO_ALG_TYPE_MASK;\r\nbase->cra_flags |= CRYPTO_ALG_TYPE_SHASH;\r\nif (!alg->finup)\r\nalg->finup = shash_finup_unaligned;\r\nif (!alg->digest)\r\nalg->digest = shash_digest_unaligned;\r\nif (!alg->export) {\r\nalg->export = shash_default_export;\r\nalg->import = shash_default_import;\r\nalg->statesize = alg->descsize;\r\n}\r\nif (!alg->setkey)\r\nalg->setkey = shash_no_setkey;\r\nreturn 0;\r\n}\r\nint crypto_register_shash(struct shash_alg *alg)\r\n{\r\nstruct crypto_alg *base = &alg->base;\r\nint err;\r\nerr = shash_prepare_alg(alg);\r\nif (err)\r\nreturn err;\r\nreturn crypto_register_alg(base);\r\n}\r\nint crypto_unregister_shash(struct shash_alg *alg)\r\n{\r\nreturn crypto_unregister_alg(&alg->base);\r\n}\r\nint shash_register_instance(struct crypto_template *tmpl,\r\nstruct shash_instance *inst)\r\n{\r\nint err;\r\nerr = shash_prepare_alg(&inst->alg);\r\nif (err)\r\nreturn err;\r\nreturn crypto_register_instance(tmpl, shash_crypto_instance(inst));\r\n}\r\nvoid shash_free_instance(struct crypto_instance *inst)\r\n{\r\ncrypto_drop_spawn(crypto_instance_ctx(inst));\r\nkfree(shash_instance(inst));\r\n}\r\nint crypto_init_shash_spawn(struct crypto_shash_spawn *spawn,\r\nstruct shash_alg *alg,\r\nstruct crypto_instance *inst)\r\n{\r\nreturn crypto_init_spawn2(&spawn->base, &alg->base, inst,\r\n&crypto_shash_type);\r\n}\r\nstruct shash_alg *shash_attr_alg(struct rtattr *rta, u32 type, u32 mask)\r\n{\r\nstruct crypto_alg *alg;\r\nalg = crypto_attr_alg2(rta, &crypto_shash_type, type, mask);\r\nreturn IS_ERR(alg) ? ERR_CAST(alg) :\r\ncontainer_of(alg, struct shash_alg, base);\r\n}
