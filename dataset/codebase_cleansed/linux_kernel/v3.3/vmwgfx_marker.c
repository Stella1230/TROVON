void vmw_marker_queue_init(struct vmw_marker_queue *queue)\r\n{\r\nINIT_LIST_HEAD(&queue->head);\r\nqueue->lag = ns_to_timespec(0);\r\ngetrawmonotonic(&queue->lag_time);\r\nspin_lock_init(&queue->lock);\r\n}\r\nvoid vmw_marker_queue_takedown(struct vmw_marker_queue *queue)\r\n{\r\nstruct vmw_marker *marker, *next;\r\nspin_lock(&queue->lock);\r\nlist_for_each_entry_safe(marker, next, &queue->head, head) {\r\nkfree(marker);\r\n}\r\nspin_unlock(&queue->lock);\r\n}\r\nint vmw_marker_push(struct vmw_marker_queue *queue,\r\nuint32_t seqno)\r\n{\r\nstruct vmw_marker *marker = kmalloc(sizeof(*marker), GFP_KERNEL);\r\nif (unlikely(!marker))\r\nreturn -ENOMEM;\r\nmarker->seqno = seqno;\r\ngetrawmonotonic(&marker->submitted);\r\nspin_lock(&queue->lock);\r\nlist_add_tail(&marker->head, &queue->head);\r\nspin_unlock(&queue->lock);\r\nreturn 0;\r\n}\r\nint vmw_marker_pull(struct vmw_marker_queue *queue,\r\nuint32_t signaled_seqno)\r\n{\r\nstruct vmw_marker *marker, *next;\r\nstruct timespec now;\r\nbool updated = false;\r\nspin_lock(&queue->lock);\r\ngetrawmonotonic(&now);\r\nif (list_empty(&queue->head)) {\r\nqueue->lag = ns_to_timespec(0);\r\nqueue->lag_time = now;\r\nupdated = true;\r\ngoto out_unlock;\r\n}\r\nlist_for_each_entry_safe(marker, next, &queue->head, head) {\r\nif (signaled_seqno - marker->seqno > (1 << 30))\r\ncontinue;\r\nqueue->lag = timespec_sub(now, marker->submitted);\r\nqueue->lag_time = now;\r\nupdated = true;\r\nlist_del(&marker->head);\r\nkfree(marker);\r\n}\r\nout_unlock:\r\nspin_unlock(&queue->lock);\r\nreturn (updated) ? 0 : -EBUSY;\r\n}\r\nstatic struct timespec vmw_timespec_add(struct timespec t1,\r\nstruct timespec t2)\r\n{\r\nt1.tv_sec += t2.tv_sec;\r\nt1.tv_nsec += t2.tv_nsec;\r\nif (t1.tv_nsec >= 1000000000L) {\r\nt1.tv_sec += 1;\r\nt1.tv_nsec -= 1000000000L;\r\n}\r\nreturn t1;\r\n}\r\nstatic struct timespec vmw_fifo_lag(struct vmw_marker_queue *queue)\r\n{\r\nstruct timespec now;\r\nspin_lock(&queue->lock);\r\ngetrawmonotonic(&now);\r\nqueue->lag = vmw_timespec_add(queue->lag,\r\ntimespec_sub(now, queue->lag_time));\r\nqueue->lag_time = now;\r\nspin_unlock(&queue->lock);\r\nreturn queue->lag;\r\n}\r\nstatic bool vmw_lag_lt(struct vmw_marker_queue *queue,\r\nuint32_t us)\r\n{\r\nstruct timespec lag, cond;\r\ncond = ns_to_timespec((s64) us * 1000);\r\nlag = vmw_fifo_lag(queue);\r\nreturn (timespec_compare(&lag, &cond) < 1);\r\n}\r\nint vmw_wait_lag(struct vmw_private *dev_priv,\r\nstruct vmw_marker_queue *queue, uint32_t us)\r\n{\r\nstruct vmw_marker *marker;\r\nuint32_t seqno;\r\nint ret;\r\nwhile (!vmw_lag_lt(queue, us)) {\r\nspin_lock(&queue->lock);\r\nif (list_empty(&queue->head))\r\nseqno = atomic_read(&dev_priv->marker_seq);\r\nelse {\r\nmarker = list_first_entry(&queue->head,\r\nstruct vmw_marker, head);\r\nseqno = marker->seqno;\r\n}\r\nspin_unlock(&queue->lock);\r\nret = vmw_wait_seqno(dev_priv, false, seqno, true,\r\n3*HZ);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\n(void) vmw_marker_pull(queue, seqno);\r\n}\r\nreturn 0;\r\n}
