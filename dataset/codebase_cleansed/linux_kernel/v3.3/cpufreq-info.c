static unsigned int count_cpus(void)\r\n{\r\nFILE *fp;\r\nchar value[LINE_LEN];\r\nunsigned int ret = 0;\r\nunsigned int cpunr = 0;\r\nfp = fopen("/proc/stat", "r");\r\nif (!fp) {\r\nprintf(_("Couldn't count the number of CPUs (%s: %s), assuming 1\n"), "/proc/stat", strerror(errno));\r\nreturn 1;\r\n}\r\nwhile (!feof(fp)) {\r\nif (!fgets(value, LINE_LEN, fp))\r\ncontinue;\r\nvalue[LINE_LEN - 1] = '\0';\r\nif (strlen(value) < (LINE_LEN - 2))\r\ncontinue;\r\nif (strstr(value, "cpu "))\r\ncontinue;\r\nif (sscanf(value, "cpu%d ", &cpunr) != 1)\r\ncontinue;\r\nif (cpunr > ret)\r\nret = cpunr;\r\n}\r\nfclose(fp);\r\nreturn ret + 1;\r\n}\r\nstatic void proc_cpufreq_output(void)\r\n{\r\nunsigned int cpu, nr_cpus;\r\nstruct cpufreq_policy *policy;\r\nunsigned int min_pctg = 0;\r\nunsigned int max_pctg = 0;\r\nunsigned long min, max;\r\nprintf(_(" minimum CPU frequency - maximum CPU frequency - governor\n"));\r\nnr_cpus = count_cpus();\r\nfor (cpu = 0; cpu < nr_cpus; cpu++) {\r\npolicy = cpufreq_get_policy(cpu);\r\nif (!policy)\r\ncontinue;\r\nif (cpufreq_get_hardware_limits(cpu, &min, &max)) {\r\nmax = 0;\r\n} else {\r\nmin_pctg = (policy->min * 100) / max;\r\nmax_pctg = (policy->max * 100) / max;\r\n}\r\nprintf("CPU%3d %9lu kHz (%3d %%) - %9lu kHz (%3d %%) - %s\n",\r\ncpu , policy->min, max ? min_pctg : 0, policy->max,\r\nmax ? max_pctg : 0, policy->governor);\r\ncpufreq_put_policy(policy);\r\n}\r\n}\r\nstatic void print_speed(unsigned long speed)\r\n{\r\nunsigned long tmp;\r\nif (speed > 1000000) {\r\ntmp = speed % 10000;\r\nif (tmp >= 5000)\r\nspeed += 10000;\r\nprintf("%u.%02u GHz", ((unsigned int) speed/1000000),\r\n((unsigned int) (speed%1000000)/10000));\r\n} else if (speed > 100000) {\r\ntmp = speed % 1000;\r\nif (tmp >= 500)\r\nspeed += 1000;\r\nprintf("%u MHz", ((unsigned int) speed / 1000));\r\n} else if (speed > 1000) {\r\ntmp = speed % 100;\r\nif (tmp >= 50)\r\nspeed += 100;\r\nprintf("%u.%01u MHz", ((unsigned int) speed/1000),\r\n((unsigned int) (speed%1000)/100));\r\n} else\r\nprintf("%lu kHz", speed);\r\nreturn;\r\n}\r\nstatic void print_duration(unsigned long duration)\r\n{\r\nunsigned long tmp;\r\nif (duration > 1000000) {\r\ntmp = duration % 10000;\r\nif (tmp >= 5000)\r\nduration += 10000;\r\nprintf("%u.%02u ms", ((unsigned int) duration/1000000),\r\n((unsigned int) (duration%1000000)/10000));\r\n} else if (duration > 100000) {\r\ntmp = duration % 1000;\r\nif (tmp >= 500)\r\nduration += 1000;\r\nprintf("%u us", ((unsigned int) duration / 1000));\r\n} else if (duration > 1000) {\r\ntmp = duration % 100;\r\nif (tmp >= 50)\r\nduration += 100;\r\nprintf("%u.%01u us", ((unsigned int) duration/1000),\r\n((unsigned int) (duration%1000)/100));\r\n} else\r\nprintf("%lu ns", duration);\r\nreturn;\r\n}\r\nstatic int get_boost_mode(unsigned int cpu)\r\n{\r\nint support, active, b_states = 0, ret, pstate_no, i;\r\nunsigned long pstates[MAX_HW_PSTATES] = {0,};\r\nif (cpupower_cpu_info.vendor != X86_VENDOR_AMD &&\r\ncpupower_cpu_info.vendor != X86_VENDOR_INTEL)\r\nreturn 0;\r\nret = cpufreq_has_boost_support(cpu, &support, &active, &b_states);\r\nif (ret) {\r\nprintf(_("Error while evaluating Boost Capabilities"\r\n" on CPU %d -- are you root?\n"), cpu);\r\nreturn ret;\r\n}\r\nprintf(_(" boost state support:\n"));\r\nprintf(_(" Supported: %s\n"), support ? _("yes") : _("no"));\r\nprintf(_(" Active: %s\n"), active ? _("yes") : _("no"));\r\nif (cpupower_cpu_info.vendor == X86_VENDOR_AMD &&\r\ncpupower_cpu_info.family >= 0x10) {\r\nret = decode_pstates(cpu, cpupower_cpu_info.family, b_states,\r\npstates, &pstate_no);\r\nif (ret)\r\nreturn ret;\r\nprintf(_(" Boost States: %d\n"), b_states);\r\nprintf(_(" Total States: %d\n"), pstate_no);\r\nfor (i = 0; i < pstate_no; i++) {\r\nif (i < b_states)\r\nprintf(_(" Pstate-Pb%d: %luMHz (boost state)"\r\n"\n"), i, pstates[i]);\r\nelse\r\nprintf(_(" Pstate-P%d: %luMHz\n"),\r\ni - b_states, pstates[i]);\r\n}\r\n} else if (cpupower_cpu_info.caps & CPUPOWER_CAP_HAS_TURBO_RATIO) {\r\ndouble bclk;\r\nunsigned long long intel_turbo_ratio = 0;\r\nunsigned int ratio;\r\nif (cpupower_cpu_info.caps & CPUPOWER_CAP_IS_SNB)\r\nbclk = 100.00;\r\nelse\r\nbclk = 133.33;\r\nintel_turbo_ratio = msr_intel_get_turbo_ratio(cpu);\r\ndprint (" Ratio: 0x%llx - bclk: %f\n",\r\nintel_turbo_ratio, bclk);\r\nratio = (intel_turbo_ratio >> 24) & 0xFF;\r\nif (ratio)\r\nprintf(_(" %.0f MHz max turbo 4 active cores\n"),\r\nratio * bclk);\r\nratio = (intel_turbo_ratio >> 16) & 0xFF;\r\nif (ratio)\r\nprintf(_(" %.0f MHz max turbo 3 active cores\n"),\r\nratio * bclk);\r\nratio = (intel_turbo_ratio >> 8) & 0xFF;\r\nif (ratio)\r\nprintf(_(" %.0f MHz max turbo 2 active cores\n"),\r\nratio * bclk);\r\nratio = (intel_turbo_ratio >> 0) & 0xFF;\r\nif (ratio)\r\nprintf(_(" %.0f MHz max turbo 1 active cores\n"),\r\nratio * bclk);\r\n}\r\nreturn 0;\r\n}\r\nstatic void debug_output_one(unsigned int cpu)\r\n{\r\nchar *driver;\r\nstruct cpufreq_affected_cpus *cpus;\r\nstruct cpufreq_available_frequencies *freqs;\r\nunsigned long min, max, freq_kernel, freq_hardware;\r\nunsigned long total_trans, latency;\r\nunsigned long long total_time;\r\nstruct cpufreq_policy *policy;\r\nstruct cpufreq_available_governors *governors;\r\nstruct cpufreq_stats *stats;\r\nif (cpufreq_cpu_exists(cpu))\r\nreturn;\r\nfreq_kernel = cpufreq_get_freq_kernel(cpu);\r\nfreq_hardware = cpufreq_get_freq_hardware(cpu);\r\ndriver = cpufreq_get_driver(cpu);\r\nif (!driver) {\r\nprintf(_(" no or unknown cpufreq driver is active on this CPU\n"));\r\n} else {\r\nprintf(_(" driver: %s\n"), driver);\r\ncpufreq_put_driver(driver);\r\n}\r\ncpus = cpufreq_get_related_cpus(cpu);\r\nif (cpus) {\r\nprintf(_(" CPUs which run at the same hardware frequency: "));\r\nwhile (cpus->next) {\r\nprintf("%d ", cpus->cpu);\r\ncpus = cpus->next;\r\n}\r\nprintf("%d\n", cpus->cpu);\r\ncpufreq_put_related_cpus(cpus);\r\n}\r\ncpus = cpufreq_get_affected_cpus(cpu);\r\nif (cpus) {\r\nprintf(_(" CPUs which need to have their frequency coordinated by software: "));\r\nwhile (cpus->next) {\r\nprintf("%d ", cpus->cpu);\r\ncpus = cpus->next;\r\n}\r\nprintf("%d\n", cpus->cpu);\r\ncpufreq_put_affected_cpus(cpus);\r\n}\r\nlatency = cpufreq_get_transition_latency(cpu);\r\nif (latency) {\r\nprintf(_(" maximum transition latency: "));\r\nprint_duration(latency);\r\nprintf(".\n");\r\n}\r\nif (!(cpufreq_get_hardware_limits(cpu, &min, &max))) {\r\nprintf(_(" hardware limits: "));\r\nprint_speed(min);\r\nprintf(" - ");\r\nprint_speed(max);\r\nprintf("\n");\r\n}\r\nfreqs = cpufreq_get_available_frequencies(cpu);\r\nif (freqs) {\r\nprintf(_(" available frequency steps: "));\r\nwhile (freqs->next) {\r\nprint_speed(freqs->frequency);\r\nprintf(", ");\r\nfreqs = freqs->next;\r\n}\r\nprint_speed(freqs->frequency);\r\nprintf("\n");\r\ncpufreq_put_available_frequencies(freqs);\r\n}\r\ngovernors = cpufreq_get_available_governors(cpu);\r\nif (governors) {\r\nprintf(_(" available cpufreq governors: "));\r\nwhile (governors->next) {\r\nprintf("%s, ", governors->governor);\r\ngovernors = governors->next;\r\n}\r\nprintf("%s\n", governors->governor);\r\ncpufreq_put_available_governors(governors);\r\n}\r\npolicy = cpufreq_get_policy(cpu);\r\nif (policy) {\r\nprintf(_(" current policy: frequency should be within "));\r\nprint_speed(policy->min);\r\nprintf(_(" and "));\r\nprint_speed(policy->max);\r\nprintf(".\n ");\r\nprintf(_("The governor \"%s\" may"\r\n" decide which speed to use\n within this range.\n"),\r\npolicy->governor);\r\ncpufreq_put_policy(policy);\r\n}\r\nif (freq_kernel || freq_hardware) {\r\nprintf(_(" current CPU frequency is "));\r\nif (freq_hardware) {\r\nprint_speed(freq_hardware);\r\nprintf(_(" (asserted by call to hardware)"));\r\n} else\r\nprint_speed(freq_kernel);\r\nprintf(".\n");\r\n}\r\nstats = cpufreq_get_stats(cpu, &total_time);\r\nif (stats) {\r\nprintf(_(" cpufreq stats: "));\r\nwhile (stats) {\r\nprint_speed(stats->frequency);\r\nprintf(":%.2f%%", (100.0 * stats->time_in_state) / total_time);\r\nstats = stats->next;\r\nif (stats)\r\nprintf(", ");\r\n}\r\ncpufreq_put_stats(stats);\r\ntotal_trans = cpufreq_get_transitions(cpu);\r\nif (total_trans)\r\nprintf(" (%lu)\n", total_trans);\r\nelse\r\nprintf("\n");\r\n}\r\nget_boost_mode(cpu);\r\n}\r\nstatic int get_freq_kernel(unsigned int cpu, unsigned int human)\r\n{\r\nunsigned long freq = cpufreq_get_freq_kernel(cpu);\r\nif (!freq)\r\nreturn -EINVAL;\r\nif (human) {\r\nprint_speed(freq);\r\nprintf("\n");\r\n} else\r\nprintf("%lu\n", freq);\r\nreturn 0;\r\n}\r\nstatic int get_freq_hardware(unsigned int cpu, unsigned int human)\r\n{\r\nunsigned long freq = cpufreq_get_freq_hardware(cpu);\r\nif (!freq)\r\nreturn -EINVAL;\r\nif (human) {\r\nprint_speed(freq);\r\nprintf("\n");\r\n} else\r\nprintf("%lu\n", freq);\r\nreturn 0;\r\n}\r\nstatic int get_hardware_limits(unsigned int cpu)\r\n{\r\nunsigned long min, max;\r\nif (cpufreq_get_hardware_limits(cpu, &min, &max))\r\nreturn -EINVAL;\r\nprintf("%lu %lu\n", min, max);\r\nreturn 0;\r\n}\r\nstatic int get_driver(unsigned int cpu)\r\n{\r\nchar *driver = cpufreq_get_driver(cpu);\r\nif (!driver)\r\nreturn -EINVAL;\r\nprintf("%s\n", driver);\r\ncpufreq_put_driver(driver);\r\nreturn 0;\r\n}\r\nstatic int get_policy(unsigned int cpu)\r\n{\r\nstruct cpufreq_policy *policy = cpufreq_get_policy(cpu);\r\nif (!policy)\r\nreturn -EINVAL;\r\nprintf("%lu %lu %s\n", policy->min, policy->max, policy->governor);\r\ncpufreq_put_policy(policy);\r\nreturn 0;\r\n}\r\nstatic int get_available_governors(unsigned int cpu)\r\n{\r\nstruct cpufreq_available_governors *governors =\r\ncpufreq_get_available_governors(cpu);\r\nif (!governors)\r\nreturn -EINVAL;\r\nwhile (governors->next) {\r\nprintf("%s ", governors->governor);\r\ngovernors = governors->next;\r\n}\r\nprintf("%s\n", governors->governor);\r\ncpufreq_put_available_governors(governors);\r\nreturn 0;\r\n}\r\nstatic int get_affected_cpus(unsigned int cpu)\r\n{\r\nstruct cpufreq_affected_cpus *cpus = cpufreq_get_affected_cpus(cpu);\r\nif (!cpus)\r\nreturn -EINVAL;\r\nwhile (cpus->next) {\r\nprintf("%d ", cpus->cpu);\r\ncpus = cpus->next;\r\n}\r\nprintf("%d\n", cpus->cpu);\r\ncpufreq_put_affected_cpus(cpus);\r\nreturn 0;\r\n}\r\nstatic int get_related_cpus(unsigned int cpu)\r\n{\r\nstruct cpufreq_affected_cpus *cpus = cpufreq_get_related_cpus(cpu);\r\nif (!cpus)\r\nreturn -EINVAL;\r\nwhile (cpus->next) {\r\nprintf("%d ", cpus->cpu);\r\ncpus = cpus->next;\r\n}\r\nprintf("%d\n", cpus->cpu);\r\ncpufreq_put_related_cpus(cpus);\r\nreturn 0;\r\n}\r\nstatic int get_freq_stats(unsigned int cpu, unsigned int human)\r\n{\r\nunsigned long total_trans = cpufreq_get_transitions(cpu);\r\nunsigned long long total_time;\r\nstruct cpufreq_stats *stats = cpufreq_get_stats(cpu, &total_time);\r\nwhile (stats) {\r\nif (human) {\r\nprint_speed(stats->frequency);\r\nprintf(":%.2f%%",\r\n(100.0 * stats->time_in_state) / total_time);\r\n} else\r\nprintf("%lu:%llu",\r\nstats->frequency, stats->time_in_state);\r\nstats = stats->next;\r\nif (stats)\r\nprintf(", ");\r\n}\r\ncpufreq_put_stats(stats);\r\nif (total_trans)\r\nprintf(" (%lu)\n", total_trans);\r\nreturn 0;\r\n}\r\nstatic int get_latency(unsigned int cpu, unsigned int human)\r\n{\r\nunsigned long latency = cpufreq_get_transition_latency(cpu);\r\nif (!latency)\r\nreturn -EINVAL;\r\nif (human) {\r\nprint_duration(latency);\r\nprintf("\n");\r\n} else\r\nprintf("%lu\n", latency);\r\nreturn 0;\r\n}\r\nint cmd_freq_info(int argc, char **argv)\r\n{\r\nextern char *optarg;\r\nextern int optind, opterr, optopt;\r\nint ret = 0, cont = 1;\r\nunsigned int cpu = 0;\r\nunsigned int human = 0;\r\nint output_param = 0;\r\ndo {\r\nret = getopt_long(argc, argv, "oefwldpgrasmyb", info_opts, NULL);\r\nswitch (ret) {\r\ncase '?':\r\noutput_param = '?';\r\ncont = 0;\r\nbreak;\r\ncase -1:\r\ncont = 0;\r\nbreak;\r\ncase 'b':\r\ncase 'o':\r\ncase 'a':\r\ncase 'r':\r\ncase 'g':\r\ncase 'p':\r\ncase 'd':\r\ncase 'l':\r\ncase 'w':\r\ncase 'f':\r\ncase 'e':\r\ncase 's':\r\ncase 'y':\r\nif (output_param) {\r\noutput_param = -1;\r\ncont = 0;\r\nbreak;\r\n}\r\noutput_param = ret;\r\nbreak;\r\ncase 'm':\r\nif (human) {\r\noutput_param = -1;\r\ncont = 0;\r\nbreak;\r\n}\r\nhuman = 1;\r\nbreak;\r\ndefault:\r\nfprintf(stderr, "invalid or unknown argument\n");\r\nreturn EXIT_FAILURE;\r\n}\r\n} while (cont);\r\nswitch (output_param) {\r\ncase 'o':\r\nif (!bitmask_isallclear(cpus_chosen)) {\r\nprintf(_("The argument passed to this tool can't be "\r\n"combined with passing a --cpu argument\n"));\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 0:\r\noutput_param = 'e';\r\n}\r\nret = 0;\r\nif (bitmask_isallclear(cpus_chosen))\r\nbitmask_setbit(cpus_chosen, 0);\r\nswitch (output_param) {\r\ncase -1:\r\nprintf(_("You can't specify more than one --cpu parameter and/or\n"\r\n"more than one output-specific argument\n"));\r\nreturn -EINVAL;\r\ncase '?':\r\nprintf(_("invalid or unknown argument\n"));\r\nreturn -EINVAL;\r\ncase 'o':\r\nproc_cpufreq_output();\r\nreturn EXIT_SUCCESS;\r\n}\r\nfor (cpu = bitmask_first(cpus_chosen);\r\ncpu <= bitmask_last(cpus_chosen); cpu++) {\r\nif (!bitmask_isbitset(cpus_chosen, cpu))\r\ncontinue;\r\nif (cpufreq_cpu_exists(cpu)) {\r\nprintf(_("couldn't analyze CPU %d as it doesn't seem to be present\n"), cpu);\r\ncontinue;\r\n}\r\nprintf(_("analyzing CPU %d:\n"), cpu);\r\nswitch (output_param) {\r\ncase 'b':\r\nget_boost_mode(cpu);\r\nbreak;\r\ncase 'e':\r\ndebug_output_one(cpu);\r\nbreak;\r\ncase 'a':\r\nret = get_affected_cpus(cpu);\r\nbreak;\r\ncase 'r':\r\nret = get_related_cpus(cpu);\r\nbreak;\r\ncase 'g':\r\nret = get_available_governors(cpu);\r\nbreak;\r\ncase 'p':\r\nret = get_policy(cpu);\r\nbreak;\r\ncase 'd':\r\nret = get_driver(cpu);\r\nbreak;\r\ncase 'l':\r\nret = get_hardware_limits(cpu);\r\nbreak;\r\ncase 'w':\r\nret = get_freq_hardware(cpu, human);\r\nbreak;\r\ncase 'f':\r\nret = get_freq_kernel(cpu, human);\r\nbreak;\r\ncase 's':\r\nret = get_freq_stats(cpu, human);\r\nbreak;\r\ncase 'y':\r\nret = get_latency(cpu, human);\r\nbreak;\r\n}\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}
