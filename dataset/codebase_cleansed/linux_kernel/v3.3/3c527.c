static inline u16 next_rx(u16 rx) { return (rx+1)&(RX_RING_LEN-1); }\r\nstatic inline u16 prev_rx(u16 rx) { return (rx-1)&(RX_RING_LEN-1); }\r\nstatic inline u16 next_tx(u16 tx) { return (tx+1)&(TX_RING_LEN-1); }\r\nstatic void cleanup_card(struct net_device *dev)\r\n{\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nunsigned slot = lp->slot;\r\nmca_mark_as_unused(slot);\r\nmca_set_adapter_name(slot, NULL);\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->base_addr, MC32_IO_EXTENT);\r\n}\r\nstruct net_device *__init mc32_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct mc32_local));\r\nstatic int current_mca_slot = -1;\r\nint i;\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (unit >= 0)\r\nsprintf(dev->name, "eth%d", unit);\r\nfor(i = 0; (mc32_adapters[i].name != NULL); i++) {\r\ncurrent_mca_slot =\r\nmca_find_unused_adapter(mc32_adapters[i].id, 0);\r\nif(current_mca_slot != MCA_NOTFOUND) {\r\nif(!mc32_probe1(dev, current_mca_slot))\r\n{\r\nmca_set_adapter_name(current_mca_slot,\r\nmc32_adapters[i].name);\r\nmca_mark_as_used(current_mca_slot);\r\nerr = register_netdev(dev);\r\nif (err) {\r\ncleanup_card(dev);\r\nfree_netdev(dev);\r\ndev = ERR_PTR(err);\r\n}\r\nreturn dev;\r\n}\r\n}\r\n}\r\nfree_netdev(dev);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic int __init mc32_probe1(struct net_device *dev, int slot)\r\n{\r\nstatic unsigned version_printed;\r\nint i, err;\r\nu8 POS;\r\nu32 base;\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nstatic const u16 mca_io_bases[] = {\r\n0x7280,0x7290,\r\n0x7680,0x7690,\r\n0x7A80,0x7A90,\r\n0x7E80,0x7E90\r\n};\r\nstatic const u32 mca_mem_bases[] = {\r\n0x00C0000,\r\n0x00C4000,\r\n0x00C8000,\r\n0x00CC000,\r\n0x00D0000,\r\n0x00D4000,\r\n0x00D8000,\r\n0x00DC000\r\n};\r\nstatic const char * const failures[] = {\r\n"Processor instruction",\r\n"Processor data bus",\r\n"Processor data bus",\r\n"Processor data bus",\r\n"Adapter bus",\r\n"ROM checksum",\r\n"Base RAM",\r\n"Extended RAM",\r\n"82586 internal loopback",\r\n"82586 initialisation failure",\r\n"Adapter list configuration error"\r\n};\r\nif (mc32_debug && version_printed++ == 0)\r\npr_debug("%s", version);\r\npr_info("%s: %s found in slot %d: ", dev->name, cardname, slot);\r\nPOS = mca_read_stored_pos(slot, 2);\r\nif(!(POS&1))\r\n{\r\npr_cont("disabled.\n");\r\nreturn -ENODEV;\r\n}\r\ndev->base_addr = mca_io_bases[(POS>>1)&7];\r\ndev->mem_start = mca_mem_bases[(POS>>4)&7];\r\nPOS = mca_read_stored_pos(slot, 4);\r\nif(!(POS&1))\r\n{\r\npr_cont("memory window disabled.\n");\r\nreturn -ENODEV;\r\n}\r\nPOS = mca_read_stored_pos(slot, 5);\r\ni=(POS>>4)&3;\r\nif(i==3)\r\n{\r\npr_cont("invalid memory window.\n");\r\nreturn -ENODEV;\r\n}\r\ni*=16384;\r\ni+=16384;\r\ndev->mem_end=dev->mem_start + i;\r\ndev->irq = ((POS>>2)&3)+9;\r\nif(!request_region(dev->base_addr, MC32_IO_EXTENT, cardname))\r\n{\r\npr_cont("io 0x%3lX, which is busy.\n", dev->base_addr);\r\nreturn -EBUSY;\r\n}\r\npr_cont("io 0x%3lX irq %d mem 0x%lX (%dK)\n",\r\ndev->base_addr, dev->irq, dev->mem_start, i/1024);\r\nfor (i = 0; i < 6; i++)\r\n{\r\nmca_write_pos(slot, 6, i+12);\r\nmca_write_pos(slot, 7, 0);\r\ndev->dev_addr[i] = mca_read_pos(slot,3);\r\n}\r\npr_info("%s: Address %pM ", dev->name, dev->dev_addr);\r\nmca_write_pos(slot, 6, 0);\r\nmca_write_pos(slot, 7, 0);\r\nPOS = mca_read_stored_pos(slot, 4);\r\nif(POS&2)\r\npr_cont(": BNC port selected.\n");\r\nelse\r\npr_cont(": AUI port selected.\n");\r\nPOS=inb(dev->base_addr+HOST_CTRL);\r\nPOS|=HOST_CTRL_ATTN|HOST_CTRL_RESET;\r\nPOS&=~HOST_CTRL_INTE;\r\noutb(POS, dev->base_addr+HOST_CTRL);\r\nudelay(100);\r\nPOS&=~(HOST_CTRL_ATTN|HOST_CTRL_RESET);\r\noutb(POS, dev->base_addr+HOST_CTRL);\r\nudelay(300);\r\nerr = request_irq(dev->irq, mc32_interrupt, IRQF_SHARED, DRV_NAME, dev);\r\nif (err) {\r\nrelease_region(dev->base_addr, MC32_IO_EXTENT);\r\npr_err("%s: unable to get IRQ %d.\n", DRV_NAME, dev->irq);\r\ngoto err_exit_ports;\r\n}\r\nmemset(lp, 0, sizeof(struct mc32_local));\r\nlp->slot = slot;\r\ni=0;\r\nbase = inb(dev->base_addr);\r\nwhile(base == 0xFF)\r\n{\r\ni++;\r\nif(i == 1000)\r\n{\r\npr_err("%s: failed to boot adapter.\n", dev->name);\r\nerr = -ENODEV;\r\ngoto err_exit_irq;\r\n}\r\nudelay(1000);\r\nif(inb(dev->base_addr+2)&(1<<5))\r\nbase = inb(dev->base_addr);\r\n}\r\nif(base>0)\r\n{\r\nif(base < 0x0C)\r\npr_err("%s: %s%s.\n", dev->name, failures[base-1],\r\nbase<0x0A?" test failure":"");\r\nelse\r\npr_err("%s: unknown failure %d.\n", dev->name, base);\r\nerr = -ENODEV;\r\ngoto err_exit_irq;\r\n}\r\nbase=0;\r\nfor(i=0;i<4;i++)\r\n{\r\nint n=0;\r\nwhile(!(inb(dev->base_addr+2)&(1<<5)))\r\n{\r\nn++;\r\nudelay(50);\r\nif(n>100)\r\n{\r\npr_err("%s: mailbox read fail (%d).\n", dev->name, i);\r\nerr = -ENODEV;\r\ngoto err_exit_irq;\r\n}\r\n}\r\nbase|=(inb(dev->base_addr)<<(8*i));\r\n}\r\nlp->exec_box=isa_bus_to_virt(dev->mem_start+base);\r\nbase=lp->exec_box->data[1]<<16|lp->exec_box->data[0];\r\nlp->base = dev->mem_start+base;\r\nlp->rx_box=isa_bus_to_virt(lp->base + lp->exec_box->data[2]);\r\nlp->tx_box=isa_bus_to_virt(lp->base + lp->exec_box->data[3]);\r\nlp->stats = isa_bus_to_virt(lp->base + lp->exec_box->data[5]);\r\nlp->tx_chain = lp->exec_box->data[8];\r\nlp->rx_chain = lp->exec_box->data[10];\r\nlp->tx_len = lp->exec_box->data[9];\r\nlp->rx_len = lp->exec_box->data[11];\r\nsema_init(&lp->cmd_mutex, 0);\r\ninit_completion(&lp->execution_cmd);\r\ninit_completion(&lp->xceiver_cmd);\r\npr_info("%s: Firmware Rev %d. %d RX buffers, %d TX buffers. Base of 0x%08X.\n",\r\ndev->name, lp->exec_box->data[12], lp->rx_len, lp->tx_len, lp->base);\r\ndev->netdev_ops = &netdev_ops;\r\ndev->watchdog_timeo = HZ*5;\r\ndev->ethtool_ops = &netdev_ethtool_ops;\r\nreturn 0;\r\nerr_exit_irq:\r\nfree_irq(dev->irq, dev);\r\nerr_exit_ports:\r\nrelease_region(dev->base_addr, MC32_IO_EXTENT);\r\nreturn err;\r\n}\r\nstatic inline void mc32_ready_poll(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nwhile(!(inb(ioaddr+HOST_STATUS)&HOST_STATUS_CRR));\r\n}\r\nstatic int mc32_command_nowait(struct net_device *dev, u16 cmd, void *data, int len)\r\n{\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nint ret = -1;\r\nif (down_trylock(&lp->cmd_mutex) == 0)\r\n{\r\nlp->cmd_nonblocking=1;\r\nlp->exec_box->mbox=0;\r\nlp->exec_box->mbox=cmd;\r\nmemcpy((void *)lp->exec_box->data, data, len);\r\nbarrier();\r\nmc32_ready_poll(dev);\r\noutb(1<<6, ioaddr+HOST_CMD);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mc32_command(struct net_device *dev, u16 cmd, void *data, int len)\r\n{\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nint ret = 0;\r\ndown(&lp->cmd_mutex);\r\nlp->cmd_nonblocking=0;\r\nlp->exec_box->mbox=0;\r\nlp->exec_box->mbox=cmd;\r\nmemcpy((void *)lp->exec_box->data, data, len);\r\nbarrier();\r\nmc32_ready_poll(dev);\r\noutb(1<<6, ioaddr+HOST_CMD);\r\nwait_for_completion(&lp->execution_cmd);\r\nif(lp->exec_box->mbox&(1<<13))\r\nret = -1;\r\nup(&lp->cmd_mutex);\r\nif(lp->mc_reload_wait)\r\n{\r\nmc32_reset_multicast_list(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic void mc32_start_transceiver(struct net_device *dev) {\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nif (lp->xceiver_desired_state==HALTED)\r\nreturn;\r\nmc32_ready_poll(dev);\r\nlp->rx_box->mbox=0;\r\nlp->rx_box->data[0]=lp->rx_ring[prev_rx(lp->rx_ring_tail)].p->next;\r\noutb(HOST_CMD_START_RX, ioaddr+HOST_CMD);\r\nmc32_ready_poll(dev);\r\nlp->tx_box->mbox=0;\r\noutb(HOST_CMD_RESTRT_TX, ioaddr+HOST_CMD);\r\n}\r\nstatic void mc32_halt_transceiver(struct net_device *dev)\r\n{\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nmc32_ready_poll(dev);\r\nlp->rx_box->mbox=0;\r\noutb(HOST_CMD_SUSPND_RX, ioaddr+HOST_CMD);\r\nwait_for_completion(&lp->xceiver_cmd);\r\nmc32_ready_poll(dev);\r\nlp->tx_box->mbox=0;\r\noutb(HOST_CMD_SUSPND_TX, ioaddr+HOST_CMD);\r\nwait_for_completion(&lp->xceiver_cmd);\r\n}\r\nstatic int mc32_load_rx_ring(struct net_device *dev)\r\n{\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nint i;\r\nu16 rx_base;\r\nvolatile struct skb_header *p;\r\nrx_base=lp->rx_chain;\r\nfor(i=0; i<RX_RING_LEN; i++) {\r\nlp->rx_ring[i].skb=alloc_skb(1532, GFP_KERNEL);\r\nif (lp->rx_ring[i].skb==NULL) {\r\nfor (;i>=0;i--)\r\nkfree_skb(lp->rx_ring[i].skb);\r\nreturn -ENOBUFS;\r\n}\r\nskb_reserve(lp->rx_ring[i].skb, 18);\r\np=isa_bus_to_virt(lp->base+rx_base);\r\np->control=0;\r\np->data=isa_virt_to_bus(lp->rx_ring[i].skb->data);\r\np->status=0;\r\np->length=1532;\r\nlp->rx_ring[i].p=p;\r\nrx_base=p->next;\r\n}\r\nlp->rx_ring[i-1].p->control |= CONTROL_EOL;\r\nlp->rx_ring_tail=0;\r\nreturn 0;\r\n}\r\nstatic void mc32_flush_rx_ring(struct net_device *dev)\r\n{\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nint i;\r\nfor(i=0; i < RX_RING_LEN; i++)\r\n{\r\nif (lp->rx_ring[i].skb) {\r\ndev_kfree_skb(lp->rx_ring[i].skb);\r\nlp->rx_ring[i].skb = NULL;\r\n}\r\nlp->rx_ring[i].p=NULL;\r\n}\r\n}\r\nstatic void mc32_load_tx_ring(struct net_device *dev)\r\n{\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nvolatile struct skb_header *p;\r\nint i;\r\nu16 tx_base;\r\ntx_base=lp->tx_box->data[0];\r\nfor(i=0 ; i<TX_RING_LEN ; i++)\r\n{\r\np=isa_bus_to_virt(lp->base+tx_base);\r\nlp->tx_ring[i].p=p;\r\nlp->tx_ring[i].skb=NULL;\r\ntx_base=p->next;\r\n}\r\natomic_set(&lp->tx_count, TX_RING_LEN-1);\r\natomic_set(&lp->tx_ring_head, 0);\r\nlp->tx_ring_tail=0;\r\n}\r\nstatic void mc32_flush_tx_ring(struct net_device *dev)\r\n{\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nint i;\r\nfor (i=0; i < TX_RING_LEN; i++)\r\n{\r\nif (lp->tx_ring[i].skb)\r\n{\r\ndev_kfree_skb(lp->tx_ring[i].skb);\r\nlp->tx_ring[i].skb = NULL;\r\n}\r\n}\r\natomic_set(&lp->tx_count, 0);\r\natomic_set(&lp->tx_ring_head, 0);\r\nlp->tx_ring_tail=0;\r\n}\r\nstatic int mc32_open(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nu8 one=1;\r\nu8 regs;\r\nu16 descnumbuffs[2] = {TX_RING_LEN, RX_RING_LEN};\r\nregs=inb(ioaddr+HOST_CTRL);\r\nregs|=HOST_CTRL_INTE;\r\noutb(regs, ioaddr+HOST_CTRL);\r\nup(&lp->cmd_mutex);\r\nmc32_command(dev, 4, &one, 2);\r\nmc32_halt_transceiver(dev);\r\nmc32_flush_tx_ring(dev);\r\nif(mc32_command(dev, 8, descnumbuffs, 4)) {\r\npr_info("%s: %s rejected our buffer configuration!\n",\r\ndev->name, cardname);\r\nmc32_close(dev);\r\nreturn -ENOBUFS;\r\n}\r\nmc32_command(dev, 6, NULL, 0);\r\nlp->tx_chain = lp->exec_box->data[8];\r\nlp->rx_chain = lp->exec_box->data[10];\r\nlp->tx_len = lp->exec_box->data[9];\r\nlp->rx_len = lp->exec_box->data[11];\r\nmc32_command(dev, 1, dev->dev_addr, 6);\r\nmc32_set_multicast_list(dev);\r\nif (WORKAROUND_82586) {\r\nu16 zero_word=0;\r\nmc32_command(dev, 0x0D, &zero_word, 2);\r\n}\r\nmc32_load_tx_ring(dev);\r\nif(mc32_load_rx_ring(dev))\r\n{\r\nmc32_close(dev);\r\nreturn -ENOBUFS;\r\n}\r\nlp->xceiver_desired_state = RUNNING;\r\nmc32_start_transceiver(dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void mc32_timeout(struct net_device *dev)\r\n{\r\npr_warning("%s: transmit timed out?\n", dev->name);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t mc32_send_packet(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nu32 head = atomic_read(&lp->tx_ring_head);\r\nvolatile struct skb_header *p, *np;\r\nnetif_stop_queue(dev);\r\nif(atomic_read(&lp->tx_count)==0) {\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (skb_padto(skb, ETH_ZLEN)) {\r\nnetif_wake_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\natomic_dec(&lp->tx_count);\r\np=lp->tx_ring[head].p;\r\nhead = next_tx(head);\r\nnp=lp->tx_ring[head].p;\r\nlp->tx_ring[head].skb=skb;\r\nnp->length = unlikely(skb->len < ETH_ZLEN) ? ETH_ZLEN : skb->len;\r\nnp->data = isa_virt_to_bus(skb->data);\r\nnp->status = 0;\r\nnp->control = CONTROL_EOP | CONTROL_EOL;\r\nwmb();\r\natomic_set(&lp->tx_ring_head, head);\r\np->control &= ~CONTROL_EOL;\r\nnetif_wake_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void mc32_update_stats(struct net_device *dev)\r\n{\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nvolatile struct mc32_stats *st = lp->stats;\r\nu32 rx_errors=0;\r\nrx_errors+=dev->stats.rx_crc_errors +=st->rx_crc_errors;\r\nst->rx_crc_errors=0;\r\nrx_errors+=dev->stats.rx_fifo_errors +=st->rx_overrun_errors;\r\nst->rx_overrun_errors=0;\r\nrx_errors+=dev->stats.rx_frame_errors +=st->rx_alignment_errors;\r\nst->rx_alignment_errors=0;\r\nrx_errors+=dev->stats.rx_length_errors+=st->rx_tooshort_errors;\r\nst->rx_tooshort_errors=0;\r\nrx_errors+=dev->stats.rx_missed_errors+=st->rx_outofresource_errors;\r\nst->rx_outofresource_errors=0;\r\ndev->stats.rx_errors=rx_errors;\r\ndev->stats.collisions+=st->dataC[10];\r\nst->dataC[10]=0;\r\ndev->stats.collisions+=st->dataC[11];\r\nst->dataC[11]=0;\r\n}\r\nstatic void mc32_rx_ring(struct net_device *dev)\r\n{\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nvolatile struct skb_header *p;\r\nu16 rx_ring_tail;\r\nu16 rx_old_tail;\r\nint x=0;\r\nrx_old_tail = rx_ring_tail = lp->rx_ring_tail;\r\ndo\r\n{\r\np=lp->rx_ring[rx_ring_tail].p;\r\nif(!(p->status & (1<<7))) {\r\nbreak;\r\n}\r\nif(p->status & (1<<6))\r\n{\r\nu16 length=p->length;\r\nstruct sk_buff *skb;\r\nstruct sk_buff *newskb;\r\nif ((length > RX_COPYBREAK) &&\r\n((newskb=dev_alloc_skb(1532)) != NULL))\r\n{\r\nskb=lp->rx_ring[rx_ring_tail].skb;\r\nskb_put(skb, length);\r\nskb_reserve(newskb,18);\r\nlp->rx_ring[rx_ring_tail].skb=newskb;\r\np->data=isa_virt_to_bus(newskb->data);\r\n}\r\nelse\r\n{\r\nskb=dev_alloc_skb(length+2);\r\nif(skb==NULL) {\r\ndev->stats.rx_dropped++;\r\ngoto dropped;\r\n}\r\nskb_reserve(skb,2);\r\nmemcpy(skb_put(skb, length),\r\nlp->rx_ring[rx_ring_tail].skb->data, length);\r\n}\r\nskb->protocol=eth_type_trans(skb,dev);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += length;\r\nnetif_rx(skb);\r\n}\r\ndropped:\r\np->length = 1532;\r\np->status = 0;\r\nrx_ring_tail=next_rx(rx_ring_tail);\r\n}\r\nwhile(x++<48);\r\nif (rx_ring_tail != rx_old_tail)\r\n{\r\nlp->rx_ring[prev_rx(rx_ring_tail)].p->control |= CONTROL_EOL;\r\nlp->rx_ring[prev_rx(rx_old_tail)].p->control &= ~CONTROL_EOL;\r\nlp->rx_ring_tail=rx_ring_tail;\r\n}\r\n}\r\nstatic void mc32_tx_ring(struct net_device *dev)\r\n{\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nvolatile struct skb_header *np;\r\nwhile (lp->tx_ring_tail != atomic_read(&lp->tx_ring_head))\r\n{\r\nu16 t;\r\nt=next_tx(lp->tx_ring_tail);\r\nnp=lp->tx_ring[t].p;\r\nif(!(np->status & (1<<7)))\r\n{\r\nbreak;\r\n}\r\ndev->stats.tx_packets++;\r\nif(!(np->status & (1<<6)))\r\n{\r\ndev->stats.tx_errors++;\r\nswitch(np->status&0x0F)\r\n{\r\ncase 1:\r\ndev->stats.tx_aborted_errors++;\r\nbreak;\r\ncase 2:\r\ndev->stats.tx_fifo_errors++;\r\nbreak;\r\ncase 3:\r\ndev->stats.tx_carrier_errors++;\r\nbreak;\r\ncase 4:\r\ndev->stats.tx_window_errors++;\r\nbreak;\r\ncase 5:\r\ndev->stats.tx_aborted_errors++;\r\nbreak;\r\n}\r\n}\r\ndev->stats.tx_bytes+=lp->tx_ring[t].skb->len;\r\ndev_kfree_skb_irq(lp->tx_ring[t].skb);\r\nlp->tx_ring[t].skb=NULL;\r\natomic_inc(&lp->tx_count);\r\nnetif_wake_queue(dev);\r\nlp->tx_ring_tail=t;\r\n}\r\n}\r\nstatic irqreturn_t mc32_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct mc32_local *lp;\r\nint ioaddr, status, boguscount = 0;\r\nint rx_event = 0;\r\nint tx_event = 0;\r\nioaddr = dev->base_addr;\r\nlp = netdev_priv(dev);\r\nwhile((inb(ioaddr+HOST_STATUS)&HOST_STATUS_CWR) && boguscount++<2000)\r\n{\r\nstatus=inb(ioaddr+HOST_CMD);\r\npr_debug("Status TX%d RX%d EX%d OV%d BC%d\n",\r\n(status&7), (status>>3)&7, (status>>6)&1,\r\n(status>>7)&1, boguscount);\r\nswitch(status&7)\r\n{\r\ncase 0:\r\nbreak;\r\ncase 6:\r\ncase 2:\r\ntx_event = 1;\r\nbreak;\r\ncase 3:\r\ncase 4:\r\ncomplete(&lp->xceiver_cmd);\r\nbreak;\r\ndefault:\r\npr_notice("%s: strange tx ack %d\n", dev->name, status&7);\r\n}\r\nstatus>>=3;\r\nswitch(status&7)\r\n{\r\ncase 0:\r\nbreak;\r\ncase 2:\r\nrx_event=1;\r\nbreak;\r\ncase 3:\r\ncase 4:\r\ncomplete(&lp->xceiver_cmd);\r\nbreak;\r\ncase 6:\r\ndev->stats.rx_dropped++;\r\nmc32_rx_ring(dev);\r\nmc32_start_transceiver(dev);\r\nbreak;\r\ndefault:\r\npr_notice("%s: strange rx ack %d\n",\r\ndev->name, status&7);\r\n}\r\nstatus>>=3;\r\nif(status&1)\r\n{\r\nif (lp->cmd_nonblocking) {\r\nup(&lp->cmd_mutex);\r\nif (lp->mc_reload_wait)\r\nmc32_reset_multicast_list(dev);\r\n}\r\nelse complete(&lp->execution_cmd);\r\n}\r\nif(status&2)\r\n{\r\nmc32_update_stats(dev);\r\n}\r\n}\r\nif(tx_event)\r\nmc32_tx_ring(dev);\r\nif(rx_event)\r\nmc32_rx_ring(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mc32_close(struct net_device *dev)\r\n{\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nu8 regs;\r\nu16 one=1;\r\nlp->xceiver_desired_state = HALTED;\r\nnetif_stop_queue(dev);\r\nmc32_command(dev, 4, &one, 2);\r\nmc32_halt_transceiver(dev);\r\ndown(&lp->cmd_mutex);\r\nregs=inb(ioaddr+HOST_CTRL);\r\nregs&=~HOST_CTRL_INTE;\r\noutb(regs, ioaddr+HOST_CTRL);\r\nmc32_flush_rx_ring(dev);\r\nmc32_flush_tx_ring(dev);\r\nmc32_update_stats(dev);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *mc32_get_stats(struct net_device *dev)\r\n{\r\nmc32_update_stats(dev);\r\nreturn &dev->stats;\r\n}\r\nstatic void do_mc32_set_multicast_list(struct net_device *dev, int retry)\r\n{\r\nstruct mc32_local *lp = netdev_priv(dev);\r\nu16 filt = (1<<2);\r\nif ((dev->flags&IFF_PROMISC) ||\r\n(dev->flags&IFF_ALLMULTI) ||\r\nnetdev_mc_count(dev) > 10)\r\nfilt |= 1;\r\nelse if (!netdev_mc_empty(dev))\r\n{\r\nunsigned char block[62];\r\nunsigned char *bp;\r\nstruct netdev_hw_addr *ha;\r\nif(retry==0)\r\nlp->mc_list_valid = 0;\r\nif(!lp->mc_list_valid)\r\n{\r\nblock[1]=0;\r\nblock[0]=netdev_mc_count(dev);\r\nbp=block+2;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nmemcpy(bp, ha->addr, 6);\r\nbp+=6;\r\n}\r\nif(mc32_command_nowait(dev, 2, block,\r\n2+6*netdev_mc_count(dev))==-1)\r\n{\r\nlp->mc_reload_wait = 1;\r\nreturn;\r\n}\r\nlp->mc_list_valid=1;\r\n}\r\n}\r\nif(mc32_command_nowait(dev, 0, &filt, 2)==-1)\r\n{\r\nlp->mc_reload_wait = 1;\r\n}\r\nelse {\r\nlp->mc_reload_wait = 0;\r\n}\r\n}\r\nstatic void mc32_set_multicast_list(struct net_device *dev)\r\n{\r\ndo_mc32_set_multicast_list(dev,0);\r\n}\r\nstatic void mc32_reset_multicast_list(struct net_device *dev)\r\n{\r\ndo_mc32_set_multicast_list(dev,1);\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrcpy(info->driver, DRV_NAME);\r\nstrcpy(info->version, DRV_VERSION);\r\nsprintf(info->bus_info, "MCA 0x%lx", dev->base_addr);\r\n}\r\nstatic u32 netdev_get_msglevel(struct net_device *dev)\r\n{\r\nreturn mc32_debug;\r\n}\r\nstatic void netdev_set_msglevel(struct net_device *dev, u32 level)\r\n{\r\nmc32_debug = level;\r\n}\r\nint __init init_module(void)\r\n{\r\nthis_device = mc32_probe(-1);\r\nif (IS_ERR(this_device))\r\nreturn PTR_ERR(this_device);\r\nreturn 0;\r\n}\r\nvoid __exit cleanup_module(void)\r\n{\r\nunregister_netdev(this_device);\r\ncleanup_card(this_device);\r\nfree_netdev(this_device);\r\n}
