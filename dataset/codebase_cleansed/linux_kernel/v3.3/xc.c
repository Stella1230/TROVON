int xc_stop(struct xc *x)\r\n{\r\nwritel(RPU_HOLD_PC, x->xmac_base + NETX_XMAC_RPU_HOLD_PC_OFS);\r\nwritel(TPU_HOLD_PC, x->xmac_base + NETX_XMAC_TPU_HOLD_PC_OFS);\r\nwritel(XPU_HOLD_PC, x->xpec_base + NETX_XPEC_XPU_HOLD_PC_OFS);\r\nreturn 0;\r\n}\r\nint xc_start(struct xc *x)\r\n{\r\nwritel(0, x->xmac_base + NETX_XMAC_RPU_HOLD_PC_OFS);\r\nwritel(0, x->xmac_base + NETX_XMAC_TPU_HOLD_PC_OFS);\r\nwritel(0, x->xpec_base + NETX_XPEC_XPU_HOLD_PC_OFS);\r\nreturn 0;\r\n}\r\nint xc_running(struct xc *x)\r\n{\r\nreturn (readl(x->xmac_base + NETX_XMAC_RPU_HOLD_PC_OFS) & RPU_HOLD_PC)\r\n|| (readl(x->xmac_base + NETX_XMAC_TPU_HOLD_PC_OFS) & TPU_HOLD_PC)\r\n|| (readl(x->xpec_base + NETX_XPEC_XPU_HOLD_PC_OFS) & XPU_HOLD_PC) ?\r\n0 : 1;\r\n}\r\nint xc_reset(struct xc *x)\r\n{\r\nwritel(0, x->xpec_base + NETX_XPEC_PC_OFS);\r\nreturn 0;\r\n}\r\nstatic int xc_check_ptr(struct xc *x, unsigned long adr, unsigned int size)\r\n{\r\nif (adr >= NETX_PA_XMAC(x->no) &&\r\nadr + size < NETX_PA_XMAC(x->no) + XMAC_MEM_SIZE)\r\nreturn 0;\r\nif (adr >= NETX_PA_XPEC(x->no) &&\r\nadr + size < NETX_PA_XPEC(x->no) + XPEC_MEM_SIZE)\r\nreturn 0;\r\ndev_err(x->dev, "Illegal pointer in firmware found. aborting\n");\r\nreturn -1;\r\n}\r\nstatic int xc_patch(struct xc *x, const void *patch, int count)\r\n{\r\nunsigned int val, adr;\r\nconst unsigned int *data = patch;\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nadr = *data++;\r\nval = *data++;\r\nif (xc_check_ptr(x, adr, 4) < 0)\r\nreturn -EINVAL;\r\nwritel(val, (void __iomem *)io_p2v(adr));\r\n}\r\nreturn 0;\r\n}\r\nint xc_request_firmware(struct xc *x)\r\n{\r\nint ret;\r\nchar name[16];\r\nconst struct firmware *fw;\r\nstruct fw_header *head;\r\nunsigned int size;\r\nint i;\r\nconst void *src;\r\nunsigned long dst;\r\nsprintf(name, "xc%d.bin", x->no);\r\nret = request_firmware(&fw, name, x->dev);\r\nif (ret < 0) {\r\ndev_err(x->dev, "request_firmware failed\n");\r\nreturn ret;\r\n}\r\nhead = (struct fw_header *)fw->data;\r\nif (head->magic != 0x4e657458) {\r\nif (head->magic == 0x5874654e) {\r\ndev_err(x->dev,\r\n"firmware magic is 'XteN'. Endianess problems?\n");\r\nret = -ENODEV;\r\ngoto exit_release_firmware;\r\n}\r\ndev_err(x->dev, "unrecognized firmware magic 0x%08x\n",\r\nhead->magic);\r\nret = -ENODEV;\r\ngoto exit_release_firmware;\r\n}\r\nx->type = head->type;\r\nx->version = head->version;\r\nret = -EINVAL;\r\nfor (i = 0; i < 3; i++) {\r\nsrc = fw->data + head->fw_desc[i].ofs;\r\ndst = *(unsigned int *)src;\r\nsrc += sizeof (unsigned int);\r\nsize = head->fw_desc[i].size - sizeof (unsigned int);\r\nif (xc_check_ptr(x, dst, size))\r\ngoto exit_release_firmware;\r\nmemcpy((void *)io_p2v(dst), src, size);\r\nsrc = fw->data + head->fw_desc[i].patch_ofs;\r\nsize = head->fw_desc[i].patch_entries;\r\nret = xc_patch(x, src, size);\r\nif (ret < 0)\r\ngoto exit_release_firmware;\r\n}\r\nret = 0;\r\nexit_release_firmware:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstruct xc *request_xc(int xcno, struct device *dev)\r\n{\r\nstruct xc *x = NULL;\r\nmutex_lock(&xc_lock);\r\nif (xcno > 3)\r\ngoto exit;\r\nif (xc_in_use & (1 << xcno))\r\ngoto exit;\r\nx = kmalloc(sizeof (struct xc), GFP_KERNEL);\r\nif (!x)\r\ngoto exit;\r\nif (!request_mem_region\r\n(NETX_PA_XPEC(xcno), XPEC_MEM_SIZE, kobject_name(&dev->kobj)))\r\ngoto exit_free;\r\nif (!request_mem_region\r\n(NETX_PA_XMAC(xcno), XMAC_MEM_SIZE, kobject_name(&dev->kobj)))\r\ngoto exit_release_1;\r\nif (!request_mem_region\r\n(SRAM_INTERNAL_PHYS(xcno), SRAM_MEM_SIZE, kobject_name(&dev->kobj)))\r\ngoto exit_release_2;\r\nx->xpec_base = (void * __iomem)io_p2v(NETX_PA_XPEC(xcno));\r\nx->xmac_base = (void * __iomem)io_p2v(NETX_PA_XMAC(xcno));\r\nx->sram_base = ioremap(SRAM_INTERNAL_PHYS(xcno), SRAM_MEM_SIZE);\r\nif (!x->sram_base)\r\ngoto exit_release_3;\r\nx->irq = NETX_IRQ_XPEC(xcno);\r\nx->no = xcno;\r\nx->dev = dev;\r\nxc_in_use |= (1 << xcno);\r\ngoto exit;\r\nexit_release_3:\r\nrelease_mem_region(SRAM_INTERNAL_PHYS(xcno), SRAM_MEM_SIZE);\r\nexit_release_2:\r\nrelease_mem_region(NETX_PA_XMAC(xcno), XMAC_MEM_SIZE);\r\nexit_release_1:\r\nrelease_mem_region(NETX_PA_XPEC(xcno), XPEC_MEM_SIZE);\r\nexit_free:\r\nkfree(x);\r\nx = NULL;\r\nexit:\r\nmutex_unlock(&xc_lock);\r\nreturn x;\r\n}\r\nvoid free_xc(struct xc *x)\r\n{\r\nint xcno = x->no;\r\nmutex_lock(&xc_lock);\r\niounmap(x->sram_base);\r\nrelease_mem_region(SRAM_INTERNAL_PHYS(xcno), SRAM_MEM_SIZE);\r\nrelease_mem_region(NETX_PA_XMAC(xcno), XMAC_MEM_SIZE);\r\nrelease_mem_region(NETX_PA_XPEC(xcno), XPEC_MEM_SIZE);\r\nxc_in_use &= ~(1 << x->no);\r\nkfree(x);\r\nmutex_unlock(&xc_lock);\r\n}
