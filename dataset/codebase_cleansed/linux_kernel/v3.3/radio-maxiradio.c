static inline struct maxiradio *to_maxiradio(struct v4l2_device *v4l2_dev)\r\n{\r\nreturn container_of(v4l2_dev, struct maxiradio, v4l2_dev);\r\n}\r\nstatic void outbit(unsigned long bit, u16 io)\r\n{\r\nint val = power | wren | (bit ? data : 0);\r\noutb(val, io);\r\nudelay(4);\r\noutb(val | clk, io);\r\nudelay(4);\r\noutb(val, io);\r\nudelay(4);\r\n}\r\nstatic void turn_power(struct maxiradio *dev, int p)\r\n{\r\nif (p != 0) {\r\ndprintk(dev, 1, "Radio powered on\n");\r\noutb(power, dev->io);\r\n} else {\r\ndprintk(dev, 1, "Radio powered off\n");\r\noutb(0, dev->io);\r\n}\r\n}\r\nstatic void set_freq(struct maxiradio *dev, u32 freq)\r\n{\r\nunsigned long int si;\r\nint bl;\r\nint io = dev->io;\r\nint val = FREQ2BITS(freq);\r\noutbit(0, io);\r\noutbit(1, io);\r\noutbit(0, io);\r\noutbit(0, io);\r\noutbit(0, io);\r\noutbit(0, io);\r\noutbit(0, io);\r\noutbit(0, io);\r\noutbit(0, io);\r\nsi = 0x8000;\r\nfor (bl = 1; bl <= 16; bl++) {\r\noutbit(val & si, io);\r\nsi >>= 1;\r\n}\r\ndprintk(dev, 1, "Radio freq set to %d.%02d MHz\n",\r\nfreq / 16000,\r\nfreq % 16000 * 100 / 16000);\r\nturn_power(dev, 1);\r\n}\r\nstatic int get_stereo(u16 io)\r\n{\r\noutb(power,io);\r\nudelay(4);\r\nreturn !(inb(io) & mo_st);\r\n}\r\nstatic int get_tune(u16 io)\r\n{\r\noutb(power+clk,io);\r\nudelay(4);\r\nreturn !(inb(io) & mo_st);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstruct maxiradio *dev = video_drvdata(file);\r\nstrlcpy(v->driver, "radio-maxiradio", sizeof(v->driver));\r\nstrlcpy(v->card, "Maxi Radio FM2000 radio", sizeof(v->card));\r\nsnprintf(v->bus_info, sizeof(v->bus_info), "PCI:%s", pci_name(dev->pdev));\r\nv->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct maxiradio *dev = video_drvdata(file);\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\nmutex_lock(&dev->lock);\r\nstrlcpy(v->name, "FM", sizeof(v->name));\r\nv->type = V4L2_TUNER_RADIO;\r\nv->rangelow = FREQ_LO;\r\nv->rangehigh = FREQ_HI;\r\nv->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;\r\nv->capability = V4L2_TUNER_CAP_LOW;\r\nif (get_stereo(dev->io))\r\nv->audmode = V4L2_TUNER_MODE_STEREO;\r\nelse\r\nv->audmode = V4L2_TUNER_MODE_MONO;\r\nv->signal = 0xffff * get_tune(dev->io);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nreturn v->index ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *filp, void *priv, unsigned int i)\r\n{\r\nreturn i ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\na->index = 0;\r\nstrlcpy(a->name, "Radio", sizeof(a->name));\r\na->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\nreturn a->index ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct maxiradio *dev = video_drvdata(file);\r\nif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nif (f->frequency < FREQ_LO || f->frequency > FREQ_HI) {\r\ndprintk(dev, 1, "radio freq (%d.%02d MHz) out of range (%d-%d)\n",\r\nf->frequency / 16000,\r\nf->frequency % 16000 * 100 / 16000,\r\nFREQ_LO / 16000, FREQ_HI / 16000);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&dev->lock);\r\ndev->freq = f->frequency;\r\nset_freq(dev, dev->freq);\r\nmsleep(125);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct maxiradio *dev = video_drvdata(file);\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_RADIO;\r\nf->frequency = dev->freq;\r\ndprintk(dev, 4, "radio freq is %d.%02d MHz",\r\nf->frequency / 16000,\r\nf->frequency % 16000 * 100 / 16000);\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nswitch (qc->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct maxiradio *dev = video_drvdata(file);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nctrl->value = dev->muted;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct maxiradio *dev = video_drvdata(file);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nmutex_lock(&dev->lock);\r\ndev->muted = ctrl->value;\r\nif (dev->muted)\r\nturn_power(dev, 0);\r\nelse\r\nset_freq(dev, dev->freq);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __devinit maxiradio_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct maxiradio *dev;\r\nstruct v4l2_device *v4l2_dev;\r\nint retval = -ENOMEM;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\ndev_err(&pdev->dev, "not enough memory\n");\r\nreturn -ENOMEM;\r\n}\r\nv4l2_dev = &dev->v4l2_dev;\r\nmutex_init(&dev->lock);\r\ndev->pdev = pdev;\r\ndev->muted = 1;\r\ndev->freq = FREQ_LO;\r\nstrlcpy(v4l2_dev->name, "maxiradio", sizeof(v4l2_dev->name));\r\nretval = v4l2_device_register(&pdev->dev, v4l2_dev);\r\nif (retval < 0) {\r\nv4l2_err(v4l2_dev, "Could not register v4l2_device\n");\r\ngoto errfr;\r\n}\r\nif (!request_region(pci_resource_start(pdev, 0),\r\npci_resource_len(pdev, 0), "Maxi Radio FM 2000")) {\r\nv4l2_err(v4l2_dev, "can't reserve I/O ports\n");\r\ngoto err_out;\r\n}\r\nif (pci_enable_device(pdev))\r\ngoto err_out_free_region;\r\ndev->io = pci_resource_start(pdev, 0);\r\nstrlcpy(dev->vdev.name, v4l2_dev->name, sizeof(dev->vdev.name));\r\ndev->vdev.v4l2_dev = v4l2_dev;\r\ndev->vdev.fops = &maxiradio_fops;\r\ndev->vdev.ioctl_ops = &maxiradio_ioctl_ops;\r\ndev->vdev.release = video_device_release_empty;\r\nvideo_set_drvdata(&dev->vdev, dev);\r\nif (video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {\r\nv4l2_err(v4l2_dev, "can't register device!");\r\ngoto err_out_free_region;\r\n}\r\nv4l2_info(v4l2_dev, "version " DRIVER_VERSION "\n");\r\nv4l2_info(v4l2_dev, "found Guillemot MAXI Radio device (io = 0x%x)\n",\r\ndev->io);\r\nreturn 0;\r\nerr_out_free_region:\r\nrelease_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));\r\nerr_out:\r\nv4l2_device_unregister(v4l2_dev);\r\nerrfr:\r\nkfree(dev);\r\nreturn -ENODEV;\r\n}\r\nstatic void __devexit maxiradio_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);\r\nstruct maxiradio *dev = to_maxiradio(v4l2_dev);\r\nvideo_unregister_device(&dev->vdev);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nrelease_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));\r\n}\r\nstatic int __init maxiradio_radio_init(void)\r\n{\r\nreturn pci_register_driver(&maxiradio_driver);\r\n}\r\nstatic void __exit maxiradio_radio_exit(void)\r\n{\r\npci_unregister_driver(&maxiradio_driver);\r\n}
