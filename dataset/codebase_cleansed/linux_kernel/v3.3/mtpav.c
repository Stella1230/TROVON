static int translate_subdevice_to_hwport(struct mtpav *chip, int subdev)\r\n{\r\nif (subdev < 0)\r\nreturn 0x01;\r\nelse if (subdev < chip->num_ports)\r\nreturn subdev + 1;\r\nelse if (subdev < chip->num_ports * 2)\r\nreturn subdev - chip->num_ports + 0x09;\r\nelse if (subdev == chip->num_ports * 2 + MTPAV_PIDX_COMPUTER)\r\nreturn 0x11;\r\nelse if (subdev == chip->num_ports + MTPAV_PIDX_ADAT)\r\nreturn 0x63;\r\nreturn 0;\r\n}\r\nstatic int translate_hwport_to_subdevice(struct mtpav *chip, int hwport)\r\n{\r\nint p;\r\nif (hwport <= 0x00)\r\nreturn chip->num_ports + MTPAV_PIDX_BROADCAST;\r\nelse if (hwport <= 0x08) {\r\np = hwport - 1;\r\nif (p >= chip->num_ports)\r\np = 0;\r\nreturn p;\r\n} else if (hwport <= 0x10) {\r\np = hwport - 0x09 + chip->num_ports;\r\nif (p >= chip->num_ports * 2)\r\np = chip->num_ports;\r\nreturn p;\r\n} else if (hwport == 0x11)\r\nreturn chip->num_ports + MTPAV_PIDX_COMPUTER;\r\nelse\r\nreturn chip->num_ports + MTPAV_PIDX_ADAT;\r\n}\r\nstatic u8 snd_mtpav_getreg(struct mtpav *chip, u16 reg)\r\n{\r\nu8 rval = 0;\r\nif (reg == SREG) {\r\nrval = inb(chip->port + SREG);\r\nrval = (rval & 0xf8);\r\n} else if (reg == CREG) {\r\nrval = inb(chip->port + CREG);\r\nrval = (rval & 0x1c);\r\n}\r\nreturn rval;\r\n}\r\nstatic inline void snd_mtpav_mputreg(struct mtpav *chip, u16 reg, u8 val)\r\n{\r\nif (reg == DREG || reg == CREG)\r\noutb(val, chip->port + reg);\r\n}\r\nstatic void snd_mtpav_wait_rfdhi(struct mtpav *chip)\r\n{\r\nint counts = 10000;\r\nu8 sbyte;\r\nsbyte = snd_mtpav_getreg(chip, SREG);\r\nwhile (!(sbyte & SIGS_RFD) && counts--) {\r\nsbyte = snd_mtpav_getreg(chip, SREG);\r\nudelay(10);\r\n}\r\n}\r\nstatic void snd_mtpav_send_byte(struct mtpav *chip, u8 byte)\r\n{\r\nu8 tcbyt;\r\nu8 clrwrite;\r\nu8 setwrite;\r\nsnd_mtpav_wait_rfdhi(chip);\r\ntcbyt = snd_mtpav_getreg(chip, CREG);\r\nclrwrite = tcbyt & (SIGC_WRITE ^ 0xff);\r\nsetwrite = tcbyt | SIGC_WRITE;\r\nsnd_mtpav_mputreg(chip, DREG, byte);\r\nsnd_mtpav_mputreg(chip, CREG, clrwrite);\r\nsnd_mtpav_mputreg(chip, CREG, setwrite);\r\n}\r\nstatic void snd_mtpav_output_port_write(struct mtpav *mtp_card,\r\nstruct mtpav_port *portp,\r\nstruct snd_rawmidi_substream *substream)\r\n{\r\nu8 outbyte;\r\nif (snd_rawmidi_transmit(substream, &outbyte, 1) != 1)\r\nreturn;\r\nif (portp->hwport != mtp_card->outmidihwport) {\r\nmtp_card->outmidihwport = portp->hwport;\r\nsnd_mtpav_send_byte(mtp_card, 0xf5);\r\nsnd_mtpav_send_byte(mtp_card, portp->hwport);\r\nif (!(outbyte & 0x80) && portp->running_status)\r\nsnd_mtpav_send_byte(mtp_card, portp->running_status);\r\n}\r\ndo {\r\nif (outbyte & 0x80)\r\nportp->running_status = outbyte;\r\nsnd_mtpav_send_byte(mtp_card, outbyte);\r\n} while (snd_rawmidi_transmit(substream, &outbyte, 1) == 1);\r\n}\r\nstatic void snd_mtpav_output_write(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct mtpav *mtp_card = substream->rmidi->private_data;\r\nstruct mtpav_port *portp = &mtp_card->ports[substream->number];\r\nunsigned long flags;\r\nspin_lock_irqsave(&mtp_card->spinlock, flags);\r\nsnd_mtpav_output_port_write(mtp_card, portp, substream);\r\nspin_unlock_irqrestore(&mtp_card->spinlock, flags);\r\n}\r\nstatic void snd_mtpav_portscan(struct mtpav *chip)\r\n{\r\nu8 p;\r\nfor (p = 0; p < 8; p++) {\r\nsnd_mtpav_send_byte(chip, 0xf5);\r\nsnd_mtpav_send_byte(chip, p);\r\nsnd_mtpav_send_byte(chip, 0xfe);\r\n}\r\n}\r\nstatic int snd_mtpav_input_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct mtpav *mtp_card = substream->rmidi->private_data;\r\nstruct mtpav_port *portp = &mtp_card->ports[substream->number];\r\nunsigned long flags;\r\nspin_lock_irqsave(&mtp_card->spinlock, flags);\r\nportp->mode |= MTPAV_MODE_INPUT_OPENED;\r\nportp->input = substream;\r\nif (mtp_card->share_irq++ == 0)\r\nsnd_mtpav_mputreg(mtp_card, CREG, (SIGC_INTEN | SIGC_WRITE));\r\nspin_unlock_irqrestore(&mtp_card->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_mtpav_input_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct mtpav *mtp_card = substream->rmidi->private_data;\r\nstruct mtpav_port *portp = &mtp_card->ports[substream->number];\r\nunsigned long flags;\r\nspin_lock_irqsave(&mtp_card->spinlock, flags);\r\nportp->mode &= ~MTPAV_MODE_INPUT_OPENED;\r\nportp->input = NULL;\r\nif (--mtp_card->share_irq == 0)\r\nsnd_mtpav_mputreg(mtp_card, CREG, 0);\r\nspin_unlock_irqrestore(&mtp_card->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic void snd_mtpav_input_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nstruct mtpav *mtp_card = substream->rmidi->private_data;\r\nstruct mtpav_port *portp = &mtp_card->ports[substream->number];\r\nunsigned long flags;\r\nspin_lock_irqsave(&mtp_card->spinlock, flags);\r\nif (up)\r\nportp->mode |= MTPAV_MODE_INPUT_TRIGGERED;\r\nelse\r\nportp->mode &= ~MTPAV_MODE_INPUT_TRIGGERED;\r\nspin_unlock_irqrestore(&mtp_card->spinlock, flags);\r\n}\r\nstatic void snd_mtpav_output_timer(unsigned long data)\r\n{\r\nunsigned long flags;\r\nstruct mtpav *chip = (struct mtpav *)data;\r\nint p;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\nchip->timer.expires = 1 + jiffies;\r\nadd_timer(&chip->timer);\r\nfor (p = 0; p <= chip->num_ports * 2 + MTPAV_PIDX_BROADCAST; p++) {\r\nstruct mtpav_port *portp = &chip->ports[p];\r\nif ((portp->mode & MTPAV_MODE_OUTPUT_TRIGGERED) && portp->output)\r\nsnd_mtpav_output_port_write(chip, portp, portp->output);\r\n}\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\n}\r\nstatic void snd_mtpav_add_output_timer(struct mtpav *chip)\r\n{\r\nchip->timer.expires = 1 + jiffies;\r\nadd_timer(&chip->timer);\r\n}\r\nstatic void snd_mtpav_remove_output_timer(struct mtpav *chip)\r\n{\r\ndel_timer(&chip->timer);\r\n}\r\nstatic int snd_mtpav_output_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct mtpav *mtp_card = substream->rmidi->private_data;\r\nstruct mtpav_port *portp = &mtp_card->ports[substream->number];\r\nunsigned long flags;\r\nspin_lock_irqsave(&mtp_card->spinlock, flags);\r\nportp->mode |= MTPAV_MODE_OUTPUT_OPENED;\r\nportp->output = substream;\r\nspin_unlock_irqrestore(&mtp_card->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_mtpav_output_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct mtpav *mtp_card = substream->rmidi->private_data;\r\nstruct mtpav_port *portp = &mtp_card->ports[substream->number];\r\nunsigned long flags;\r\nspin_lock_irqsave(&mtp_card->spinlock, flags);\r\nportp->mode &= ~MTPAV_MODE_OUTPUT_OPENED;\r\nportp->output = NULL;\r\nspin_unlock_irqrestore(&mtp_card->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic void snd_mtpav_output_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nstruct mtpav *mtp_card = substream->rmidi->private_data;\r\nstruct mtpav_port *portp = &mtp_card->ports[substream->number];\r\nunsigned long flags;\r\nspin_lock_irqsave(&mtp_card->spinlock, flags);\r\nif (up) {\r\nif (! (portp->mode & MTPAV_MODE_OUTPUT_TRIGGERED)) {\r\nif (mtp_card->istimer++ == 0)\r\nsnd_mtpav_add_output_timer(mtp_card);\r\nportp->mode |= MTPAV_MODE_OUTPUT_TRIGGERED;\r\n}\r\n} else {\r\nportp->mode &= ~MTPAV_MODE_OUTPUT_TRIGGERED;\r\nif (--mtp_card->istimer == 0)\r\nsnd_mtpav_remove_output_timer(mtp_card);\r\n}\r\nspin_unlock_irqrestore(&mtp_card->spinlock, flags);\r\nif (up)\r\nsnd_mtpav_output_write(substream);\r\n}\r\nstatic void snd_mtpav_inmidi_process(struct mtpav *mcrd, u8 inbyte)\r\n{\r\nstruct mtpav_port *portp;\r\nif ((int)mcrd->inmidiport > mcrd->num_ports * 2 + MTPAV_PIDX_BROADCAST)\r\nreturn;\r\nportp = &mcrd->ports[mcrd->inmidiport];\r\nif (portp->mode & MTPAV_MODE_INPUT_TRIGGERED)\r\nsnd_rawmidi_receive(portp->input, &inbyte, 1);\r\n}\r\nstatic void snd_mtpav_inmidi_h(struct mtpav *mcrd, u8 inbyte)\r\n{\r\nif (inbyte >= 0xf8) {\r\nsnd_mtpav_inmidi_process(mcrd, inbyte);\r\nreturn;\r\n}\r\nif (mcrd->inmidistate == 0) {\r\nif (inbyte == 0xf5)\r\nmcrd->inmidistate = 1;\r\nelse\r\nsnd_mtpav_inmidi_process(mcrd, inbyte);\r\n} else if (mcrd->inmidistate) {\r\nmcrd->inmidiport = translate_hwport_to_subdevice(mcrd, inbyte);\r\nmcrd->inmidistate = 0;\r\n}\r\n}\r\nstatic void snd_mtpav_read_bytes(struct mtpav *mcrd)\r\n{\r\nu8 clrread, setread;\r\nu8 mtp_read_byte;\r\nu8 sr, cbyt;\r\nint i;\r\nu8 sbyt = snd_mtpav_getreg(mcrd, SREG);\r\nif (!(sbyt & SIGS_BYTE))\r\nreturn;\r\ncbyt = snd_mtpav_getreg(mcrd, CREG);\r\nclrread = cbyt & (SIGC_READ ^ 0xff);\r\nsetread = cbyt | SIGC_READ;\r\ndo {\r\nmtp_read_byte = 0;\r\nfor (i = 0; i < 4; i++) {\r\nsnd_mtpav_mputreg(mcrd, CREG, setread);\r\nsr = snd_mtpav_getreg(mcrd, SREG);\r\nsnd_mtpav_mputreg(mcrd, CREG, clrread);\r\nsr &= SIGS_IN0 | SIGS_IN1;\r\nsr >>= 4;\r\nmtp_read_byte |= sr << (i * 2);\r\n}\r\nsnd_mtpav_inmidi_h(mcrd, mtp_read_byte);\r\nsbyt = snd_mtpav_getreg(mcrd, SREG);\r\n} while (sbyt & SIGS_BYTE);\r\n}\r\nstatic irqreturn_t snd_mtpav_irqh(int irq, void *dev_id)\r\n{\r\nstruct mtpav *mcard = dev_id;\r\nspin_lock(&mcard->spinlock);\r\nsnd_mtpav_read_bytes(mcard);\r\nspin_unlock(&mcard->spinlock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit snd_mtpav_get_ISA(struct mtpav * mcard)\r\n{\r\nif ((mcard->res_port = request_region(port, 3, "MotuMTPAV MIDI")) == NULL) {\r\nsnd_printk(KERN_ERR "MTVAP port 0x%lx is busy\n", port);\r\nreturn -EBUSY;\r\n}\r\nmcard->port = port;\r\nif (request_irq(irq, snd_mtpav_irqh, 0, "MOTU MTPAV", mcard)) {\r\nsnd_printk(KERN_ERR "MTVAP IRQ %d busy\n", irq);\r\nreturn -EBUSY;\r\n}\r\nmcard->irq = irq;\r\nreturn 0;\r\n}\r\nstatic void __devinit snd_mtpav_set_name(struct mtpav *chip,\r\nstruct snd_rawmidi_substream *substream)\r\n{\r\nif (substream->number >= 0 && substream->number < chip->num_ports)\r\nsprintf(substream->name, "MTP direct %d", (substream->number % chip->num_ports) + 1);\r\nelse if (substream->number >= 8 && substream->number < chip->num_ports * 2)\r\nsprintf(substream->name, "MTP remote %d", (substream->number % chip->num_ports) + 1);\r\nelse if (substream->number == chip->num_ports * 2)\r\nstrcpy(substream->name, "MTP computer");\r\nelse if (substream->number == chip->num_ports * 2 + 1)\r\nstrcpy(substream->name, "MTP ADAT");\r\nelse\r\nstrcpy(substream->name, "MTP broadcast");\r\n}\r\nstatic int __devinit snd_mtpav_get_RAWMIDI(struct mtpav *mcard)\r\n{\r\nint rval;\r\nstruct snd_rawmidi *rawmidi;\r\nstruct snd_rawmidi_substream *substream;\r\nstruct list_head *list;\r\nif (hwports < 1)\r\nhwports = 1;\r\nelse if (hwports > 8)\r\nhwports = 8;\r\nmcard->num_ports = hwports;\r\nif ((rval = snd_rawmidi_new(mcard->card, "MotuMIDI", 0,\r\nmcard->num_ports * 2 + MTPAV_PIDX_BROADCAST + 1,\r\nmcard->num_ports * 2 + MTPAV_PIDX_BROADCAST + 1,\r\n&mcard->rmidi)) < 0)\r\nreturn rval;\r\nrawmidi = mcard->rmidi;\r\nrawmidi->private_data = mcard;\r\nlist_for_each(list, &rawmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams) {\r\nsubstream = list_entry(list, struct snd_rawmidi_substream, list);\r\nsnd_mtpav_set_name(mcard, substream);\r\nsubstream->ops = &snd_mtpav_input;\r\n}\r\nlist_for_each(list, &rawmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams) {\r\nsubstream = list_entry(list, struct snd_rawmidi_substream, list);\r\nsnd_mtpav_set_name(mcard, substream);\r\nsubstream->ops = &snd_mtpav_output;\r\nmcard->ports[substream->number].hwport = translate_subdevice_to_hwport(mcard, substream->number);\r\n}\r\nrawmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT |\r\nSNDRV_RAWMIDI_INFO_DUPLEX;\r\nsprintf(rawmidi->name, "MTP AV MIDI");\r\nreturn 0;\r\n}\r\nstatic void snd_mtpav_free(struct snd_card *card)\r\n{\r\nstruct mtpav *crd = card->private_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&crd->spinlock, flags);\r\nif (crd->istimer > 0)\r\nsnd_mtpav_remove_output_timer(crd);\r\nspin_unlock_irqrestore(&crd->spinlock, flags);\r\nif (crd->irq >= 0)\r\nfree_irq(crd->irq, (void *)crd);\r\nrelease_and_free_resource(crd->res_port);\r\n}\r\nstatic int __devinit snd_mtpav_probe(struct platform_device *dev)\r\n{\r\nstruct snd_card *card;\r\nint err;\r\nstruct mtpav *mtp_card;\r\nerr = snd_card_create(index, id, THIS_MODULE, sizeof(*mtp_card), &card);\r\nif (err < 0)\r\nreturn err;\r\nmtp_card = card->private_data;\r\nspin_lock_init(&mtp_card->spinlock);\r\ninit_timer(&mtp_card->timer);\r\nmtp_card->card = card;\r\nmtp_card->irq = -1;\r\nmtp_card->share_irq = 0;\r\nmtp_card->inmidistate = 0;\r\nmtp_card->outmidihwport = 0xffffffff;\r\ninit_timer(&mtp_card->timer);\r\nmtp_card->timer.function = snd_mtpav_output_timer;\r\nmtp_card->timer.data = (unsigned long) mtp_card;\r\ncard->private_free = snd_mtpav_free;\r\nerr = snd_mtpav_get_RAWMIDI(mtp_card);\r\nif (err < 0)\r\ngoto __error;\r\nmtp_card->inmidiport = mtp_card->num_ports + MTPAV_PIDX_BROADCAST;\r\nerr = snd_mtpav_get_ISA(mtp_card);\r\nif (err < 0)\r\ngoto __error;\r\nstrcpy(card->driver, "MTPAV");\r\nstrcpy(card->shortname, "MTPAV on parallel port");\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"MTPAV on parallel port at 0x%lx", port);\r\nsnd_mtpav_portscan(mtp_card);\r\nsnd_card_set_dev(card, &dev->dev);\r\nerr = snd_card_register(mtp_card->card);\r\nif (err < 0)\r\ngoto __error;\r\nplatform_set_drvdata(dev, card);\r\nprintk(KERN_INFO "Motu MidiTimePiece on parallel port irq: %d ioport: 0x%lx\n", irq, port);\r\nreturn 0;\r\n__error:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int __devexit snd_mtpav_remove(struct platform_device *devptr)\r\n{\r\nsnd_card_free(platform_get_drvdata(devptr));\r\nplatform_set_drvdata(devptr, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init alsa_card_mtpav_init(void)\r\n{\r\nint err;\r\nif ((err = platform_driver_register(&snd_mtpav_driver)) < 0)\r\nreturn err;\r\ndevice = platform_device_register_simple(SND_MTPAV_DRIVER, -1, NULL, 0);\r\nif (!IS_ERR(device)) {\r\nif (platform_get_drvdata(device))\r\nreturn 0;\r\nplatform_device_unregister(device);\r\nerr = -ENODEV;\r\n} else\r\nerr = PTR_ERR(device);\r\nplatform_driver_unregister(&snd_mtpav_driver);\r\nreturn err;\r\n}\r\nstatic void __exit alsa_card_mtpav_exit(void)\r\n{\r\nplatform_device_unregister(device);\r\nplatform_driver_unregister(&snd_mtpav_driver);\r\n}
