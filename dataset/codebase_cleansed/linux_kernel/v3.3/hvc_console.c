static struct hvc_struct *hvc_get_by_index(int index)\r\n{\r\nstruct hvc_struct *hp;\r\nunsigned long flags;\r\nspin_lock(&hvc_structs_lock);\r\nlist_for_each_entry(hp, &hvc_structs, next) {\r\nspin_lock_irqsave(&hp->lock, flags);\r\nif (hp->index == index) {\r\nkref_get(&hp->kref);\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nspin_unlock(&hvc_structs_lock);\r\nreturn hp;\r\n}\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\n}\r\nhp = NULL;\r\nspin_unlock(&hvc_structs_lock);\r\nreturn hp;\r\n}\r\nstatic void hvc_console_print(struct console *co, const char *b,\r\nunsigned count)\r\n{\r\nchar c[N_OUTBUF] __ALIGNED__;\r\nunsigned i = 0, n = 0;\r\nint r, donecr = 0, index = co->index;\r\nif (index >= MAX_NR_HVC_CONSOLES)\r\nreturn;\r\nif (vtermnos[index] == -1)\r\nreturn;\r\nwhile (count > 0 || i > 0) {\r\nif (count > 0 && i < sizeof(c)) {\r\nif (b[n] == '\n' && !donecr) {\r\nc[i++] = '\r';\r\ndonecr = 1;\r\n} else {\r\nc[i++] = b[n++];\r\ndonecr = 0;\r\n--count;\r\n}\r\n} else {\r\nr = cons_ops[index]->put_chars(vtermnos[index], c, i);\r\nif (r <= 0) {\r\nif (r != -EAGAIN)\r\ni = 0;\r\n} else if (r > 0) {\r\ni -= r;\r\nif (i > 0)\r\nmemmove(c, c+r, i);\r\n}\r\n}\r\n}\r\n}\r\nstatic struct tty_driver *hvc_console_device(struct console *c, int *index)\r\n{\r\nif (vtermnos[c->index] == -1)\r\nreturn NULL;\r\n*index = c->index;\r\nreturn hvc_driver;\r\n}\r\nstatic int __init hvc_console_setup(struct console *co, char *options)\r\n{\r\nif (co->index < 0 || co->index >= MAX_NR_HVC_CONSOLES)\r\nreturn -ENODEV;\r\nif (vtermnos[co->index] == -1)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int __init hvc_console_init(void)\r\n{\r\nregister_console(&hvc_console);\r\nreturn 0;\r\n}\r\nstatic void destroy_hvc_struct(struct kref *kref)\r\n{\r\nstruct hvc_struct *hp = container_of(kref, struct hvc_struct, kref);\r\nunsigned long flags;\r\nspin_lock(&hvc_structs_lock);\r\nspin_lock_irqsave(&hp->lock, flags);\r\nlist_del(&(hp->next));\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nspin_unlock(&hvc_structs_lock);\r\nkfree(hp);\r\n}\r\nint hvc_instantiate(uint32_t vtermno, int index, const struct hv_ops *ops)\r\n{\r\nstruct hvc_struct *hp;\r\nif (index < 0 || index >= MAX_NR_HVC_CONSOLES)\r\nreturn -1;\r\nif (vtermnos[index] != -1)\r\nreturn -1;\r\nhp = hvc_get_by_index(index);\r\nif (hp) {\r\nkref_put(&hp->kref, destroy_hvc_struct);\r\nreturn -1;\r\n}\r\nvtermnos[index] = vtermno;\r\ncons_ops[index] = ops;\r\nif (last_hvc < index)\r\nlast_hvc = index;\r\nif (index == hvc_console.index)\r\nregister_console(&hvc_console);\r\nreturn 0;\r\n}\r\nvoid hvc_kick(void)\r\n{\r\nhvc_kicked = 1;\r\nwake_up_process(hvc_task);\r\n}\r\nstatic void hvc_unthrottle(struct tty_struct *tty)\r\n{\r\nhvc_kick();\r\n}\r\nstatic int hvc_open(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct hvc_struct *hp;\r\nunsigned long flags;\r\nint rc = 0;\r\nif (!(hp = hvc_get_by_index(tty->index)))\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&hp->lock, flags);\r\nif (hp->count++ > 0) {\r\ntty_kref_get(tty);\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nhvc_kick();\r\nreturn 0;\r\n}\r\ntty->driver_data = hp;\r\nhp->tty = tty_kref_get(tty);\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nif (hp->ops->notifier_add)\r\nrc = hp->ops->notifier_add(hp, hp->data);\r\nif (rc) {\r\nspin_lock_irqsave(&hp->lock, flags);\r\nhp->tty = NULL;\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\ntty_kref_put(tty);\r\ntty->driver_data = NULL;\r\nkref_put(&hp->kref, destroy_hvc_struct);\r\nprintk(KERN_ERR "hvc_open: request_irq failed with rc %d.\n", rc);\r\n}\r\nhvc_kick();\r\nreturn rc;\r\n}\r\nstatic void hvc_close(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct hvc_struct *hp;\r\nunsigned long flags;\r\nif (tty_hung_up_p(filp))\r\nreturn;\r\nif (!tty->driver_data)\r\nreturn;\r\nhp = tty->driver_data;\r\nspin_lock_irqsave(&hp->lock, flags);\r\nif (--hp->count == 0) {\r\nhp->tty = NULL;\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nif (hp->ops->notifier_del)\r\nhp->ops->notifier_del(hp, hp->data);\r\ncancel_work_sync(&hp->tty_resize);\r\ntty_wait_until_sent_from_close(tty, HVC_CLOSE_WAIT);\r\n} else {\r\nif (hp->count < 0)\r\nprintk(KERN_ERR "hvc_close %X: oops, count is %d\n",\r\nhp->vtermno, hp->count);\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\n}\r\ntty_kref_put(tty);\r\nkref_put(&hp->kref, destroy_hvc_struct);\r\n}\r\nstatic void hvc_hangup(struct tty_struct *tty)\r\n{\r\nstruct hvc_struct *hp = tty->driver_data;\r\nunsigned long flags;\r\nint temp_open_count;\r\nif (!hp)\r\nreturn;\r\ncancel_work_sync(&hp->tty_resize);\r\nspin_lock_irqsave(&hp->lock, flags);\r\nif (hp->count <= 0) {\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nreturn;\r\n}\r\ntemp_open_count = hp->count;\r\nhp->count = 0;\r\nhp->n_outbuf = 0;\r\nhp->tty = NULL;\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nif (hp->ops->notifier_hangup)\r\nhp->ops->notifier_hangup(hp, hp->data);\r\nwhile(temp_open_count) {\r\n--temp_open_count;\r\ntty_kref_put(tty);\r\nkref_put(&hp->kref, destroy_hvc_struct);\r\n}\r\n}\r\nstatic int hvc_push(struct hvc_struct *hp)\r\n{\r\nint n;\r\nn = hp->ops->put_chars(hp->vtermno, hp->outbuf, hp->n_outbuf);\r\nif (n <= 0) {\r\nif (n == 0 || n == -EAGAIN) {\r\nhp->do_wakeup = 1;\r\nreturn 0;\r\n}\r\nhp->n_outbuf = 0;\r\n} else\r\nhp->n_outbuf -= n;\r\nif (hp->n_outbuf > 0)\r\nmemmove(hp->outbuf, hp->outbuf + n, hp->n_outbuf);\r\nelse\r\nhp->do_wakeup = 1;\r\nreturn n;\r\n}\r\nstatic int hvc_write(struct tty_struct *tty, const unsigned char *buf, int count)\r\n{\r\nstruct hvc_struct *hp = tty->driver_data;\r\nunsigned long flags;\r\nint rsize, written = 0;\r\nif (!hp)\r\nreturn -EPIPE;\r\nif (hp->count <= 0)\r\nreturn -EIO;\r\nspin_lock_irqsave(&hp->lock, flags);\r\nif (hp->n_outbuf > 0)\r\nhvc_push(hp);\r\nwhile (count > 0 && (rsize = hp->outbuf_size - hp->n_outbuf) > 0) {\r\nif (rsize > count)\r\nrsize = count;\r\nmemcpy(hp->outbuf + hp->n_outbuf, buf, rsize);\r\ncount -= rsize;\r\nbuf += rsize;\r\nhp->n_outbuf += rsize;\r\nwritten += rsize;\r\nhvc_push(hp);\r\n}\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nif (hp->n_outbuf)\r\nhvc_kick();\r\nreturn written;\r\n}\r\nstatic void hvc_set_winsz(struct work_struct *work)\r\n{\r\nstruct hvc_struct *hp;\r\nunsigned long hvc_flags;\r\nstruct tty_struct *tty;\r\nstruct winsize ws;\r\nhp = container_of(work, struct hvc_struct, tty_resize);\r\nspin_lock_irqsave(&hp->lock, hvc_flags);\r\nif (!hp->tty) {\r\nspin_unlock_irqrestore(&hp->lock, hvc_flags);\r\nreturn;\r\n}\r\nws = hp->ws;\r\ntty = tty_kref_get(hp->tty);\r\nspin_unlock_irqrestore(&hp->lock, hvc_flags);\r\ntty_do_resize(tty, &ws);\r\ntty_kref_put(tty);\r\n}\r\nstatic int hvc_write_room(struct tty_struct *tty)\r\n{\r\nstruct hvc_struct *hp = tty->driver_data;\r\nif (!hp)\r\nreturn -1;\r\nreturn hp->outbuf_size - hp->n_outbuf;\r\n}\r\nstatic int hvc_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct hvc_struct *hp = tty->driver_data;\r\nif (!hp)\r\nreturn 0;\r\nreturn hp->n_outbuf;\r\n}\r\nint hvc_poll(struct hvc_struct *hp)\r\n{\r\nstruct tty_struct *tty;\r\nint i, n, poll_mask = 0;\r\nchar buf[N_INBUF] __ALIGNED__;\r\nunsigned long flags;\r\nint read_total = 0;\r\nint written_total = 0;\r\nspin_lock_irqsave(&hp->lock, flags);\r\nif (hp->n_outbuf > 0)\r\nwritten_total = hvc_push(hp);\r\nif (hp->n_outbuf > 0) {\r\npoll_mask |= HVC_POLL_WRITE;\r\ntimeout = (written_total) ? 0 : MIN_TIMEOUT;\r\n}\r\ntty = tty_kref_get(hp->tty);\r\nif (tty == NULL)\r\ngoto bail;\r\nif (test_bit(TTY_THROTTLED, &tty->flags))\r\ngoto throttled;\r\nif (!hp->irq_requested)\r\npoll_mask |= HVC_POLL_READ;\r\nfor (;;) {\r\nint count = tty_buffer_request_room(tty, N_INBUF);\r\nif (count == 0) {\r\npoll_mask |= HVC_POLL_READ;\r\nbreak;\r\n}\r\nn = hp->ops->get_chars(hp->vtermno, buf, count);\r\nif (n <= 0) {\r\nif (n == -EPIPE) {\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\ntty_hangup(tty);\r\nspin_lock_irqsave(&hp->lock, flags);\r\n} else if ( n == -EAGAIN ) {\r\npoll_mask |= HVC_POLL_READ;\r\n}\r\nbreak;\r\n}\r\nfor (i = 0; i < n; ++i) {\r\n#ifdef CONFIG_MAGIC_SYSRQ\r\nif (hp->index == hvc_console.index) {\r\nif (buf[i] == '\x0f') {\r\nsysrq_pressed = !sysrq_pressed;\r\nif (sysrq_pressed)\r\ncontinue;\r\n} else if (sysrq_pressed) {\r\nhandle_sysrq(buf[i]);\r\nsysrq_pressed = 0;\r\ncontinue;\r\n}\r\n}\r\n#endif\r\ntty_insert_flip_char(tty, buf[i], 0);\r\n}\r\nread_total += n;\r\n}\r\nthrottled:\r\nif (hp->do_wakeup) {\r\nhp->do_wakeup = 0;\r\ntty_wakeup(tty);\r\n}\r\nbail:\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nif (read_total) {\r\ntimeout = MIN_TIMEOUT;\r\ntty_flip_buffer_push(tty);\r\n}\r\nif (tty)\r\ntty_kref_put(tty);\r\nreturn poll_mask;\r\n}\r\nvoid __hvc_resize(struct hvc_struct *hp, struct winsize ws)\r\n{\r\nhp->ws = ws;\r\nschedule_work(&hp->tty_resize);\r\n}\r\nstatic int khvcd(void *unused)\r\n{\r\nint poll_mask;\r\nstruct hvc_struct *hp;\r\nset_freezable();\r\ndo {\r\npoll_mask = 0;\r\nhvc_kicked = 0;\r\ntry_to_freeze();\r\nwmb();\r\nif (!cpus_are_in_xmon()) {\r\nspin_lock(&hvc_structs_lock);\r\nlist_for_each_entry(hp, &hvc_structs, next) {\r\npoll_mask |= hvc_poll(hp);\r\n}\r\nspin_unlock(&hvc_structs_lock);\r\n} else\r\npoll_mask |= HVC_POLL_READ;\r\nif (hvc_kicked)\r\ncontinue;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (!hvc_kicked) {\r\nif (poll_mask == 0)\r\nschedule();\r\nelse {\r\nif (timeout < MAX_TIMEOUT)\r\ntimeout += (timeout >> 6) + 1;\r\nmsleep_interruptible(timeout);\r\n}\r\n}\r\n__set_current_state(TASK_RUNNING);\r\n} while (!kthread_should_stop());\r\nreturn 0;\r\n}\r\nstatic int hvc_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct hvc_struct *hp = tty->driver_data;\r\nif (!hp || !hp->ops->tiocmget)\r\nreturn -EINVAL;\r\nreturn hp->ops->tiocmget(hp);\r\n}\r\nstatic int hvc_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct hvc_struct *hp = tty->driver_data;\r\nif (!hp || !hp->ops->tiocmset)\r\nreturn -EINVAL;\r\nreturn hp->ops->tiocmset(hp, set, clear);\r\n}\r\nint hvc_poll_init(struct tty_driver *driver, int line, char *options)\r\n{\r\nreturn 0;\r\n}\r\nstatic int hvc_poll_get_char(struct tty_driver *driver, int line)\r\n{\r\nstruct tty_struct *tty = driver->ttys[0];\r\nstruct hvc_struct *hp = tty->driver_data;\r\nint n;\r\nchar ch;\r\nn = hp->ops->get_chars(hp->vtermno, &ch, 1);\r\nif (n == 0)\r\nreturn NO_POLL_CHAR;\r\nreturn ch;\r\n}\r\nstatic void hvc_poll_put_char(struct tty_driver *driver, int line, char ch)\r\n{\r\nstruct tty_struct *tty = driver->ttys[0];\r\nstruct hvc_struct *hp = tty->driver_data;\r\nint n;\r\ndo {\r\nn = hp->ops->put_chars(hp->vtermno, &ch, 1);\r\n} while (n <= 0);\r\n}\r\nstruct hvc_struct *hvc_alloc(uint32_t vtermno, int data,\r\nconst struct hv_ops *ops,\r\nint outbuf_size)\r\n{\r\nstruct hvc_struct *hp;\r\nint i;\r\nif (!hvc_driver) {\r\nint err = hvc_init();\r\nif (err)\r\nreturn ERR_PTR(err);\r\n}\r\nhp = kzalloc(ALIGN(sizeof(*hp), sizeof(long)) + outbuf_size,\r\nGFP_KERNEL);\r\nif (!hp)\r\nreturn ERR_PTR(-ENOMEM);\r\nhp->vtermno = vtermno;\r\nhp->data = data;\r\nhp->ops = ops;\r\nhp->outbuf_size = outbuf_size;\r\nhp->outbuf = &((char *)hp)[ALIGN(sizeof(*hp), sizeof(long))];\r\nkref_init(&hp->kref);\r\nINIT_WORK(&hp->tty_resize, hvc_set_winsz);\r\nspin_lock_init(&hp->lock);\r\nspin_lock(&hvc_structs_lock);\r\nfor (i=0; i < MAX_NR_HVC_CONSOLES; i++)\r\nif (vtermnos[i] == hp->vtermno &&\r\ncons_ops[i] == hp->ops)\r\nbreak;\r\nif (i >= MAX_NR_HVC_CONSOLES)\r\ni = ++last_hvc;\r\nhp->index = i;\r\nlist_add_tail(&(hp->next), &hvc_structs);\r\nspin_unlock(&hvc_structs_lock);\r\nreturn hp;\r\n}\r\nint hvc_remove(struct hvc_struct *hp)\r\n{\r\nunsigned long flags;\r\nstruct tty_struct *tty;\r\nspin_lock_irqsave(&hp->lock, flags);\r\ntty = tty_kref_get(hp->tty);\r\nif (hp->index < MAX_NR_HVC_CONSOLES)\r\nvtermnos[hp->index] = -1;\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nkref_put(&hp->kref, destroy_hvc_struct);\r\nif (tty) {\r\ntty_vhangup(tty);\r\ntty_kref_put(tty);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hvc_init(void)\r\n{\r\nstruct tty_driver *drv;\r\nint err;\r\ndrv = alloc_tty_driver(HVC_ALLOC_TTY_ADAPTERS);\r\nif (!drv) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\ndrv->owner = THIS_MODULE;\r\ndrv->driver_name = "hvc";\r\ndrv->name = "hvc";\r\ndrv->major = HVC_MAJOR;\r\ndrv->minor_start = HVC_MINOR;\r\ndrv->type = TTY_DRIVER_TYPE_SYSTEM;\r\ndrv->init_termios = tty_std_termios;\r\ndrv->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_RESET_TERMIOS;\r\ntty_set_operations(drv, &hvc_ops);\r\nhvc_task = kthread_run(khvcd, NULL, "khvcd");\r\nif (IS_ERR(hvc_task)) {\r\nprintk(KERN_ERR "Couldn't create kthread for console.\n");\r\nerr = PTR_ERR(hvc_task);\r\ngoto put_tty;\r\n}\r\nerr = tty_register_driver(drv);\r\nif (err) {\r\nprintk(KERN_ERR "Couldn't register hvc console driver\n");\r\ngoto stop_thread;\r\n}\r\nsmp_mb();\r\nhvc_driver = drv;\r\nreturn 0;\r\nstop_thread:\r\nkthread_stop(hvc_task);\r\nhvc_task = NULL;\r\nput_tty:\r\nput_tty_driver(drv);\r\nout:\r\nreturn err;\r\n}\r\nstatic void __exit hvc_exit(void)\r\n{\r\nif (hvc_driver) {\r\nkthread_stop(hvc_task);\r\ntty_unregister_driver(hvc_driver);\r\nput_tty_driver(hvc_driver);\r\nunregister_console(&hvc_console);\r\n}\r\n}
