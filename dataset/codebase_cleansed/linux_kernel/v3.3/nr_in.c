static int nr_queue_rx_frame(struct sock *sk, struct sk_buff *skb, int more)\r\n{\r\nstruct sk_buff *skbo, *skbn = skb;\r\nstruct nr_sock *nr = nr_sk(sk);\r\nskb_pull(skb, NR_NETWORK_LEN + NR_TRANSPORT_LEN);\r\nnr_start_idletimer(sk);\r\nif (more) {\r\nnr->fraglen += skb->len;\r\nskb_queue_tail(&nr->frag_queue, skb);\r\nreturn 0;\r\n}\r\nif (!more && nr->fraglen > 0) {\r\nnr->fraglen += skb->len;\r\nskb_queue_tail(&nr->frag_queue, skb);\r\nif ((skbn = alloc_skb(nr->fraglen, GFP_ATOMIC)) == NULL)\r\nreturn 1;\r\nskb_reset_transport_header(skbn);\r\nwhile ((skbo = skb_dequeue(&nr->frag_queue)) != NULL) {\r\nskb_copy_from_linear_data(skbo,\r\nskb_put(skbn, skbo->len),\r\nskbo->len);\r\nkfree_skb(skbo);\r\n}\r\nnr->fraglen = 0;\r\n}\r\nreturn sock_queue_rcv_skb(sk, skbn);\r\n}\r\nstatic int nr_state1_machine(struct sock *sk, struct sk_buff *skb,\r\nint frametype)\r\n{\r\nswitch (frametype) {\r\ncase NR_CONNACK: {\r\nstruct nr_sock *nr = nr_sk(sk);\r\nnr_stop_t1timer(sk);\r\nnr_start_idletimer(sk);\r\nnr->your_index = skb->data[17];\r\nnr->your_id = skb->data[18];\r\nnr->vs = 0;\r\nnr->va = 0;\r\nnr->vr = 0;\r\nnr->vl = 0;\r\nnr->state = NR_STATE_3;\r\nnr->n2count = 0;\r\nnr->window = skb->data[20];\r\nsk->sk_state = TCP_ESTABLISHED;\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_state_change(sk);\r\nbreak;\r\n}\r\ncase NR_CONNACK | NR_CHOKE_FLAG:\r\nnr_disconnect(sk, ECONNREFUSED);\r\nbreak;\r\ncase NR_RESET:\r\nif (sysctl_netrom_reset_circuit)\r\nnr_disconnect(sk, ECONNRESET);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nr_state2_machine(struct sock *sk, struct sk_buff *skb,\r\nint frametype)\r\n{\r\nswitch (frametype) {\r\ncase NR_CONNACK | NR_CHOKE_FLAG:\r\nnr_disconnect(sk, ECONNRESET);\r\nbreak;\r\ncase NR_DISCREQ:\r\nnr_write_internal(sk, NR_DISCACK);\r\ncase NR_DISCACK:\r\nnr_disconnect(sk, 0);\r\nbreak;\r\ncase NR_RESET:\r\nif (sysctl_netrom_reset_circuit)\r\nnr_disconnect(sk, ECONNRESET);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nr_state3_machine(struct sock *sk, struct sk_buff *skb, int frametype)\r\n{\r\nstruct nr_sock *nrom = nr_sk(sk);\r\nstruct sk_buff_head temp_queue;\r\nstruct sk_buff *skbn;\r\nunsigned short save_vr;\r\nunsigned short nr, ns;\r\nint queued = 0;\r\nnr = skb->data[18];\r\nns = skb->data[17];\r\nswitch (frametype) {\r\ncase NR_CONNREQ:\r\nnr_write_internal(sk, NR_CONNACK);\r\nbreak;\r\ncase NR_DISCREQ:\r\nnr_write_internal(sk, NR_DISCACK);\r\nnr_disconnect(sk, 0);\r\nbreak;\r\ncase NR_CONNACK | NR_CHOKE_FLAG:\r\ncase NR_DISCACK:\r\nnr_disconnect(sk, ECONNRESET);\r\nbreak;\r\ncase NR_INFOACK:\r\ncase NR_INFOACK | NR_CHOKE_FLAG:\r\ncase NR_INFOACK | NR_NAK_FLAG:\r\ncase NR_INFOACK | NR_NAK_FLAG | NR_CHOKE_FLAG:\r\nif (frametype & NR_CHOKE_FLAG) {\r\nnrom->condition |= NR_COND_PEER_RX_BUSY;\r\nnr_start_t4timer(sk);\r\n} else {\r\nnrom->condition &= ~NR_COND_PEER_RX_BUSY;\r\nnr_stop_t4timer(sk);\r\n}\r\nif (!nr_validate_nr(sk, nr)) {\r\nbreak;\r\n}\r\nif (frametype & NR_NAK_FLAG) {\r\nnr_frames_acked(sk, nr);\r\nnr_send_nak_frame(sk);\r\n} else {\r\nif (nrom->condition & NR_COND_PEER_RX_BUSY) {\r\nnr_frames_acked(sk, nr);\r\n} else {\r\nnr_check_iframes_acked(sk, nr);\r\n}\r\n}\r\nbreak;\r\ncase NR_INFO:\r\ncase NR_INFO | NR_NAK_FLAG:\r\ncase NR_INFO | NR_CHOKE_FLAG:\r\ncase NR_INFO | NR_MORE_FLAG:\r\ncase NR_INFO | NR_NAK_FLAG | NR_CHOKE_FLAG:\r\ncase NR_INFO | NR_CHOKE_FLAG | NR_MORE_FLAG:\r\ncase NR_INFO | NR_NAK_FLAG | NR_MORE_FLAG:\r\ncase NR_INFO | NR_NAK_FLAG | NR_CHOKE_FLAG | NR_MORE_FLAG:\r\nif (frametype & NR_CHOKE_FLAG) {\r\nnrom->condition |= NR_COND_PEER_RX_BUSY;\r\nnr_start_t4timer(sk);\r\n} else {\r\nnrom->condition &= ~NR_COND_PEER_RX_BUSY;\r\nnr_stop_t4timer(sk);\r\n}\r\nif (nr_validate_nr(sk, nr)) {\r\nif (frametype & NR_NAK_FLAG) {\r\nnr_frames_acked(sk, nr);\r\nnr_send_nak_frame(sk);\r\n} else {\r\nif (nrom->condition & NR_COND_PEER_RX_BUSY) {\r\nnr_frames_acked(sk, nr);\r\n} else {\r\nnr_check_iframes_acked(sk, nr);\r\n}\r\n}\r\n}\r\nqueued = 1;\r\nskb_queue_head(&nrom->reseq_queue, skb);\r\nif (nrom->condition & NR_COND_OWN_RX_BUSY)\r\nbreak;\r\nskb_queue_head_init(&temp_queue);\r\ndo {\r\nsave_vr = nrom->vr;\r\nwhile ((skbn = skb_dequeue(&nrom->reseq_queue)) != NULL) {\r\nns = skbn->data[17];\r\nif (ns == nrom->vr) {\r\nif (nr_queue_rx_frame(sk, skbn, frametype & NR_MORE_FLAG) == 0) {\r\nnrom->vr = (nrom->vr + 1) % NR_MODULUS;\r\n} else {\r\nnrom->condition |= NR_COND_OWN_RX_BUSY;\r\nskb_queue_tail(&temp_queue, skbn);\r\n}\r\n} else if (nr_in_rx_window(sk, ns)) {\r\nskb_queue_tail(&temp_queue, skbn);\r\n} else {\r\nkfree_skb(skbn);\r\n}\r\n}\r\nwhile ((skbn = skb_dequeue(&temp_queue)) != NULL) {\r\nskb_queue_tail(&nrom->reseq_queue, skbn);\r\n}\r\n} while (save_vr != nrom->vr);\r\nif (((nrom->vl + nrom->window) % NR_MODULUS) == nrom->vr) {\r\nnr_enquiry_response(sk);\r\n} else {\r\nif (!(nrom->condition & NR_COND_ACK_PENDING)) {\r\nnrom->condition |= NR_COND_ACK_PENDING;\r\nnr_start_t2timer(sk);\r\n}\r\n}\r\nbreak;\r\ncase NR_RESET:\r\nif (sysctl_netrom_reset_circuit)\r\nnr_disconnect(sk, ECONNRESET);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn queued;\r\n}\r\nint nr_process_rx_frame(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct nr_sock *nr = nr_sk(sk);\r\nint queued = 0, frametype;\r\nif (nr->state == NR_STATE_0)\r\nreturn 0;\r\nframetype = skb->data[19];\r\nswitch (nr->state) {\r\ncase NR_STATE_1:\r\nqueued = nr_state1_machine(sk, skb, frametype);\r\nbreak;\r\ncase NR_STATE_2:\r\nqueued = nr_state2_machine(sk, skb, frametype);\r\nbreak;\r\ncase NR_STATE_3:\r\nqueued = nr_state3_machine(sk, skb, frametype);\r\nbreak;\r\n}\r\nnr_kick(sk);\r\nreturn queued;\r\n}
