static irqreturn_t pps_gpio_irq_handler(int irq, void *data)\r\n{\r\nconst struct pps_gpio_device_data *info;\r\nstruct pps_event_time ts;\r\nint rising_edge;\r\npps_get_ts(&ts);\r\ninfo = data;\r\nrising_edge = gpio_get_value(info->pdata->gpio_pin);\r\nif ((rising_edge && !info->pdata->assert_falling_edge) ||\r\n(!rising_edge && info->pdata->assert_falling_edge))\r\npps_event(info->pps, &ts, PPS_CAPTUREASSERT, NULL);\r\nelse if (info->pdata->capture_clear &&\r\n((rising_edge && info->pdata->assert_falling_edge) ||\r\n(!rising_edge && !info->pdata->assert_falling_edge)))\r\npps_event(info->pps, &ts, PPS_CAPTURECLEAR, NULL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pps_gpio_setup(struct platform_device *pdev)\r\n{\r\nint ret;\r\nconst struct pps_gpio_platform_data *pdata = pdev->dev.platform_data;\r\nret = gpio_request(pdata->gpio_pin, pdata->gpio_label);\r\nif (ret) {\r\npr_warning("failed to request GPIO %u\n", pdata->gpio_pin);\r\nreturn -EINVAL;\r\n}\r\nret = gpio_direction_input(pdata->gpio_pin);\r\nif (ret) {\r\npr_warning("failed to set pin direction\n");\r\ngpio_free(pdata->gpio_pin);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long\r\nget_irqf_trigger_flags(const struct pps_gpio_platform_data *pdata)\r\n{\r\nunsigned long flags = pdata->assert_falling_edge ?\r\nIRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING;\r\nif (pdata->capture_clear) {\r\nflags |= ((flags & IRQF_TRIGGER_RISING) ?\r\nIRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING);\r\n}\r\nreturn flags;\r\n}\r\nstatic int pps_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct pps_gpio_device_data *data;\r\nint irq;\r\nint ret;\r\nint err;\r\nint pps_default_params;\r\nconst struct pps_gpio_platform_data *pdata = pdev->dev.platform_data;\r\nret = pps_gpio_setup(pdev);\r\nif (ret)\r\nreturn -EINVAL;\r\nirq = gpio_to_irq(pdata->gpio_pin);\r\nif (irq < 0) {\r\npr_err("failed to map GPIO to IRQ: %d\n", irq);\r\nerr = -EINVAL;\r\ngoto return_error;\r\n}\r\ndata = kzalloc(sizeof(struct pps_gpio_device_data), GFP_KERNEL);\r\nif (data == NULL) {\r\nerr = -ENOMEM;\r\ngoto return_error;\r\n}\r\ndata->info.mode = PPS_CAPTUREASSERT | PPS_OFFSETASSERT |\r\nPPS_ECHOASSERT | PPS_CANWAIT | PPS_TSFMT_TSPEC;\r\nif (pdata->capture_clear)\r\ndata->info.mode |= PPS_CAPTURECLEAR | PPS_OFFSETCLEAR |\r\nPPS_ECHOCLEAR;\r\ndata->info.owner = THIS_MODULE;\r\nsnprintf(data->info.name, PPS_MAX_NAME_LEN - 1, "%s.%d",\r\npdev->name, pdev->id);\r\npps_default_params = PPS_CAPTUREASSERT | PPS_OFFSETASSERT;\r\nif (pdata->capture_clear)\r\npps_default_params |= PPS_CAPTURECLEAR | PPS_OFFSETCLEAR;\r\ndata->pps = pps_register_source(&data->info, pps_default_params);\r\nif (data->pps == NULL) {\r\nkfree(data);\r\npr_err("failed to register IRQ %d as PPS source\n", irq);\r\nerr = -EINVAL;\r\ngoto return_error;\r\n}\r\ndata->irq = irq;\r\ndata->pdata = pdata;\r\nret = request_irq(irq, pps_gpio_irq_handler,\r\nget_irqf_trigger_flags(pdata), data->info.name, data);\r\nif (ret) {\r\npps_unregister_source(data->pps);\r\nkfree(data);\r\npr_err("failed to acquire IRQ %d\n", irq);\r\nerr = -EINVAL;\r\ngoto return_error;\r\n}\r\nplatform_set_drvdata(pdev, data);\r\ndev_info(data->pps->dev, "Registered IRQ %d as PPS source\n", irq);\r\nreturn 0;\r\nreturn_error:\r\ngpio_free(pdata->gpio_pin);\r\nreturn err;\r\n}\r\nstatic int pps_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct pps_gpio_device_data *data = platform_get_drvdata(pdev);\r\nconst struct pps_gpio_platform_data *pdata = data->pdata;\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_irq(data->irq, data);\r\ngpio_free(pdata->gpio_pin);\r\npps_unregister_source(data->pps);\r\npr_info("removed IRQ %d as PPS source\n", data->irq);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init pps_gpio_init(void)\r\n{\r\nint ret = platform_driver_register(&pps_gpio_driver);\r\nif (ret < 0)\r\npr_err("failed to register platform driver\n");\r\nreturn ret;\r\n}\r\nstatic void __exit pps_gpio_exit(void)\r\n{\r\nplatform_driver_unregister(&pps_gpio_driver);\r\npr_debug("unregistered platform driver\n");\r\n}
