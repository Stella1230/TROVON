drm_dma_handle_t *drm_pci_alloc(struct drm_device * dev, size_t size, size_t align)\r\n{\r\ndrm_dma_handle_t *dmah;\r\n#if 1\r\nunsigned long addr;\r\nsize_t sz;\r\n#endif\r\nif (align > size)\r\nreturn NULL;\r\ndmah = kmalloc(sizeof(drm_dma_handle_t), GFP_KERNEL);\r\nif (!dmah)\r\nreturn NULL;\r\ndmah->size = size;\r\ndmah->vaddr = dma_alloc_coherent(&dev->pdev->dev, size, &dmah->busaddr, GFP_KERNEL | __GFP_COMP);\r\nif (dmah->vaddr == NULL) {\r\nkfree(dmah);\r\nreturn NULL;\r\n}\r\nmemset(dmah->vaddr, 0, size);\r\nfor (addr = (unsigned long)dmah->vaddr, sz = size;\r\nsz > 0; addr += PAGE_SIZE, sz -= PAGE_SIZE) {\r\nSetPageReserved(virt_to_page(addr));\r\n}\r\nreturn dmah;\r\n}\r\nvoid __drm_pci_free(struct drm_device * dev, drm_dma_handle_t * dmah)\r\n{\r\n#if 1\r\nunsigned long addr;\r\nsize_t sz;\r\n#endif\r\nif (dmah->vaddr) {\r\nfor (addr = (unsigned long)dmah->vaddr, sz = dmah->size;\r\nsz > 0; addr += PAGE_SIZE, sz -= PAGE_SIZE) {\r\nClearPageReserved(virt_to_page(addr));\r\n}\r\ndma_free_coherent(&dev->pdev->dev, dmah->size, dmah->vaddr,\r\ndmah->busaddr);\r\n}\r\n}\r\nvoid drm_pci_free(struct drm_device * dev, drm_dma_handle_t * dmah)\r\n{\r\n__drm_pci_free(dev, dmah);\r\nkfree(dmah);\r\n}\r\nstatic int drm_get_pci_domain(struct drm_device *dev)\r\n{\r\n#ifndef __alpha__\r\nif (dev->if_version < 0x10004)\r\nreturn 0;\r\n#endif\r\nreturn pci_domain_nr(dev->pdev->bus);\r\n}\r\nstatic int drm_pci_get_irq(struct drm_device *dev)\r\n{\r\nreturn dev->pdev->irq;\r\n}\r\nstatic const char *drm_pci_get_name(struct drm_device *dev)\r\n{\r\nstruct pci_driver *pdriver = dev->driver->kdriver.pci;\r\nreturn pdriver->name;\r\n}\r\nint drm_pci_set_busid(struct drm_device *dev, struct drm_master *master)\r\n{\r\nint len, ret;\r\nstruct pci_driver *pdriver = dev->driver->kdriver.pci;\r\nmaster->unique_len = 40;\r\nmaster->unique_size = master->unique_len;\r\nmaster->unique = kmalloc(master->unique_size, GFP_KERNEL);\r\nif (master->unique == NULL)\r\nreturn -ENOMEM;\r\nlen = snprintf(master->unique, master->unique_len,\r\n"pci:%04x:%02x:%02x.%d",\r\ndrm_get_pci_domain(dev),\r\ndev->pdev->bus->number,\r\nPCI_SLOT(dev->pdev->devfn),\r\nPCI_FUNC(dev->pdev->devfn));\r\nif (len >= master->unique_len) {\r\nDRM_ERROR("buffer overflow");\r\nret = -EINVAL;\r\ngoto err;\r\n} else\r\nmaster->unique_len = len;\r\ndev->devname =\r\nkmalloc(strlen(pdriver->name) +\r\nmaster->unique_len + 2, GFP_KERNEL);\r\nif (dev->devname == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nsprintf(dev->devname, "%s@%s", pdriver->name,\r\nmaster->unique);\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nint drm_pci_set_unique(struct drm_device *dev,\r\nstruct drm_master *master,\r\nstruct drm_unique *u)\r\n{\r\nint domain, bus, slot, func, ret;\r\nconst char *bus_name;\r\nmaster->unique_len = u->unique_len;\r\nmaster->unique_size = u->unique_len + 1;\r\nmaster->unique = kmalloc(master->unique_size, GFP_KERNEL);\r\nif (!master->unique) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nif (copy_from_user(master->unique, u->unique, master->unique_len)) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nmaster->unique[master->unique_len] = '\0';\r\nbus_name = dev->driver->bus->get_name(dev);\r\ndev->devname = kmalloc(strlen(bus_name) +\r\nstrlen(master->unique) + 2, GFP_KERNEL);\r\nif (!dev->devname) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nsprintf(dev->devname, "%s@%s", bus_name,\r\nmaster->unique);\r\nret = sscanf(master->unique, "PCI:%d:%d:%d", &bus, &slot, &func);\r\nif (ret != 3) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndomain = bus >> 8;\r\nbus &= 0xff;\r\nif ((domain != drm_get_pci_domain(dev)) ||\r\n(bus != dev->pdev->bus->number) ||\r\n(slot != PCI_SLOT(dev->pdev->devfn)) ||\r\n(func != PCI_FUNC(dev->pdev->devfn))) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int drm_pci_irq_by_busid(struct drm_device *dev, struct drm_irq_busid *p)\r\n{\r\nif ((p->busnum >> 8) != drm_get_pci_domain(dev) ||\r\n(p->busnum & 0xff) != dev->pdev->bus->number ||\r\np->devnum != PCI_SLOT(dev->pdev->devfn) || p->funcnum != PCI_FUNC(dev->pdev->devfn))\r\nreturn -EINVAL;\r\np->irq = dev->pdev->irq;\r\nDRM_DEBUG("%d:%d:%d => IRQ %d\n", p->busnum, p->devnum, p->funcnum,\r\np->irq);\r\nreturn 0;\r\n}\r\nint drm_pci_agp_init(struct drm_device *dev)\r\n{\r\nif (drm_core_has_AGP(dev)) {\r\nif (drm_pci_device_is_agp(dev))\r\ndev->agp = drm_agp_init(dev);\r\nif (drm_core_check_feature(dev, DRIVER_REQUIRE_AGP)\r\n&& (dev->agp == NULL)) {\r\nDRM_ERROR("Cannot initialize the agpgart module.\n");\r\nreturn -EINVAL;\r\n}\r\nif (drm_core_has_MTRR(dev)) {\r\nif (dev->agp)\r\ndev->agp->agp_mtrr =\r\nmtrr_add(dev->agp->agp_info.aper_base,\r\ndev->agp->agp_info.aper_size *\r\n1024 * 1024, MTRR_TYPE_WRCOMB, 1);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint drm_get_pci_dev(struct pci_dev *pdev, const struct pci_device_id *ent,\r\nstruct drm_driver *driver)\r\n{\r\nstruct drm_device *dev;\r\nint ret;\r\nDRM_DEBUG("\n");\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\ngoto err_g1;\r\npci_set_master(pdev);\r\ndev->pdev = pdev;\r\ndev->dev = &pdev->dev;\r\ndev->pci_device = pdev->device;\r\ndev->pci_vendor = pdev->vendor;\r\n#ifdef __alpha__\r\ndev->hose = pdev->sysdata;\r\n#endif\r\nmutex_lock(&drm_global_mutex);\r\nif ((ret = drm_fill_in_dev(dev, ent, driver))) {\r\nprintk(KERN_ERR "DRM: Fill_in_dev failed.\n");\r\ngoto err_g2;\r\n}\r\nif (drm_core_check_feature(dev, DRIVER_MODESET)) {\r\npci_set_drvdata(pdev, dev);\r\nret = drm_get_minor(dev, &dev->control, DRM_MINOR_CONTROL);\r\nif (ret)\r\ngoto err_g2;\r\n}\r\nif ((ret = drm_get_minor(dev, &dev->primary, DRM_MINOR_LEGACY)))\r\ngoto err_g3;\r\nif (dev->driver->load) {\r\nret = dev->driver->load(dev, ent->driver_data);\r\nif (ret)\r\ngoto err_g4;\r\n}\r\nif (drm_core_check_feature(dev, DRIVER_MODESET)) {\r\nret = drm_mode_group_init_legacy_group(dev,\r\n&dev->primary->mode_group);\r\nif (ret)\r\ngoto err_g4;\r\n}\r\nlist_add_tail(&dev->driver_item, &driver->device_list);\r\nDRM_INFO("Initialized %s %d.%d.%d %s for %s on minor %d\n",\r\ndriver->name, driver->major, driver->minor, driver->patchlevel,\r\ndriver->date, pci_name(pdev), dev->primary->index);\r\nmutex_unlock(&drm_global_mutex);\r\nreturn 0;\r\nerr_g4:\r\ndrm_put_minor(&dev->primary);\r\nerr_g3:\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\ndrm_put_minor(&dev->control);\r\nerr_g2:\r\npci_disable_device(pdev);\r\nerr_g1:\r\nkfree(dev);\r\nmutex_unlock(&drm_global_mutex);\r\nreturn ret;\r\n}\r\nint drm_pci_init(struct drm_driver *driver, struct pci_driver *pdriver)\r\n{\r\nstruct pci_dev *pdev = NULL;\r\nconst struct pci_device_id *pid;\r\nint i;\r\nDRM_DEBUG("\n");\r\nINIT_LIST_HEAD(&driver->device_list);\r\ndriver->kdriver.pci = pdriver;\r\ndriver->bus = &drm_pci_bus;\r\nif (driver->driver_features & DRIVER_MODESET)\r\nreturn pci_register_driver(pdriver);\r\nfor (i = 0; pdriver->id_table[i].vendor != 0; i++) {\r\npid = &pdriver->id_table[i];\r\npdev = NULL;\r\nwhile ((pdev =\r\npci_get_subsys(pid->vendor, pid->device, pid->subvendor,\r\npid->subdevice, pdev)) != NULL) {\r\nif ((pdev->class & pid->class_mask) != pid->class)\r\ncontinue;\r\npci_dev_get(pdev);\r\ndrm_get_pci_dev(pdev, pid, driver);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint drm_pci_init(struct drm_driver *driver, struct pci_driver *pdriver)\r\n{\r\nreturn -1;\r\n}\r\nvoid drm_pci_exit(struct drm_driver *driver, struct pci_driver *pdriver)\r\n{\r\nstruct drm_device *dev, *tmp;\r\nDRM_DEBUG("\n");\r\nif (driver->driver_features & DRIVER_MODESET) {\r\npci_unregister_driver(pdriver);\r\n} else {\r\nlist_for_each_entry_safe(dev, tmp, &driver->device_list, driver_item)\r\ndrm_put_dev(dev);\r\n}\r\nDRM_INFO("Module unloaded\n");\r\n}
