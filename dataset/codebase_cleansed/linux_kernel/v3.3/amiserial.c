static inline int serial_paranoia_check(struct async_struct *info,\r\nchar *name, const char *routine)\r\n{\r\n#ifdef SERIAL_PARANOIA_CHECK\r\nstatic const char *badmagic =\r\n"Warning: bad magic number for serial struct (%s) in %s\n";\r\nstatic const char *badinfo =\r\n"Warning: null async_struct for (%s) in %s\n";\r\nif (!info) {\r\nprintk(badinfo, name, routine);\r\nreturn 1;\r\n}\r\nif (info->magic != SERIAL_MAGIC) {\r\nprintk(badmagic, name, routine);\r\nreturn 1;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic __inline__ void rtsdtr_ctrl(int bits)\r\n{\r\nciab.pra = ((bits & (SER_RTS | SER_DTR)) ^ (SER_RTS | SER_DTR)) | (ciab.pra & ~(SER_RTS | SER_DTR));\r\n}\r\nstatic void rs_stop(struct tty_struct *tty)\r\n{\r\nstruct async_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_stop"))\r\nreturn;\r\nlocal_irq_save(flags);\r\nif (info->IER & UART_IER_THRI) {\r\ninfo->IER &= ~UART_IER_THRI;\r\ncustom.intena = IF_TBE;\r\nmb();\r\ncustom.intreq = IF_TBE;\r\nmb();\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void rs_start(struct tty_struct *tty)\r\n{\r\nstruct async_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_start"))\r\nreturn;\r\nlocal_irq_save(flags);\r\nif (info->xmit.head != info->xmit.tail\r\n&& info->xmit.buf\r\n&& !(info->IER & UART_IER_THRI)) {\r\ninfo->IER |= UART_IER_THRI;\r\ncustom.intena = IF_SETCLR | IF_TBE;\r\nmb();\r\ncustom.intreq = IF_SETCLR | IF_TBE;\r\nmb();\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void rs_sched_event(struct async_struct *info,\r\nint event)\r\n{\r\ninfo->event |= 1 << event;\r\ntasklet_schedule(&info->tlet);\r\n}\r\nstatic void receive_chars(struct async_struct *info)\r\n{\r\nint status;\r\nint serdatr;\r\nstruct tty_struct *tty = info->tty;\r\nunsigned char ch, flag;\r\nstruct async_icount *icount;\r\nint oe = 0;\r\nicount = &info->state->icount;\r\nstatus = UART_LSR_DR;\r\nserdatr = custom.serdatr;\r\nmb();\r\ncustom.intreq = IF_RBF;\r\nmb();\r\nif((serdatr & 0x1ff) == 0)\r\nstatus |= UART_LSR_BI;\r\nif(serdatr & SDR_OVRUN)\r\nstatus |= UART_LSR_OE;\r\nch = serdatr & 0xff;\r\nicount->rx++;\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("DR%02x:%02x...", ch, status);\r\n#endif\r\nflag = TTY_NORMAL;\r\nif (status & (UART_LSR_BI | UART_LSR_PE |\r\nUART_LSR_FE | UART_LSR_OE)) {\r\nif (status & UART_LSR_BI) {\r\nstatus &= ~(UART_LSR_FE | UART_LSR_PE);\r\nicount->brk++;\r\n} else if (status & UART_LSR_PE)\r\nicount->parity++;\r\nelse if (status & UART_LSR_FE)\r\nicount->frame++;\r\nif (status & UART_LSR_OE)\r\nicount->overrun++;\r\nif (status & info->ignore_status_mask)\r\ngoto out;\r\nstatus &= info->read_status_mask;\r\nif (status & (UART_LSR_BI)) {\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("handling break....");\r\n#endif\r\nflag = TTY_BREAK;\r\nif (info->flags & ASYNC_SAK)\r\ndo_SAK(tty);\r\n} else if (status & UART_LSR_PE)\r\nflag = TTY_PARITY;\r\nelse if (status & UART_LSR_FE)\r\nflag = TTY_FRAME;\r\nif (status & UART_LSR_OE) {\r\noe = 1;\r\n}\r\n}\r\ntty_insert_flip_char(tty, ch, flag);\r\nif (oe == 1)\r\ntty_insert_flip_char(tty, 0, TTY_OVERRUN);\r\ntty_flip_buffer_push(tty);\r\nout:\r\nreturn;\r\n}\r\nstatic void transmit_chars(struct async_struct *info)\r\n{\r\ncustom.intreq = IF_TBE;\r\nmb();\r\nif (info->x_char) {\r\ncustom.serdat = info->x_char | 0x100;\r\nmb();\r\ninfo->state->icount.tx++;\r\ninfo->x_char = 0;\r\nreturn;\r\n}\r\nif (info->xmit.head == info->xmit.tail\r\n|| info->tty->stopped\r\n|| info->tty->hw_stopped) {\r\ninfo->IER &= ~UART_IER_THRI;\r\ncustom.intena = IF_TBE;\r\nmb();\r\nreturn;\r\n}\r\ncustom.serdat = info->xmit.buf[info->xmit.tail++] | 0x100;\r\nmb();\r\ninfo->xmit.tail = info->xmit.tail & (SERIAL_XMIT_SIZE-1);\r\ninfo->state->icount.tx++;\r\nif (CIRC_CNT(info->xmit.head,\r\ninfo->xmit.tail,\r\nSERIAL_XMIT_SIZE) < WAKEUP_CHARS)\r\nrs_sched_event(info, RS_EVENT_WRITE_WAKEUP);\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("THRE...");\r\n#endif\r\nif (info->xmit.head == info->xmit.tail) {\r\ncustom.intena = IF_TBE;\r\nmb();\r\ninfo->IER &= ~UART_IER_THRI;\r\n}\r\n}\r\nstatic void check_modem_status(struct async_struct *info)\r\n{\r\nunsigned char status = ciab.pra & (SER_DCD | SER_CTS | SER_DSR);\r\nunsigned char dstatus;\r\nstruct async_icount *icount;\r\ndstatus = status ^ current_ctl_bits;\r\ncurrent_ctl_bits = status;\r\nif (dstatus) {\r\nicount = &info->state->icount;\r\nif (dstatus & SER_DSR)\r\nicount->dsr++;\r\nif (dstatus & SER_DCD) {\r\nicount->dcd++;\r\n#ifdef CONFIG_HARD_PPS\r\nif ((info->flags & ASYNC_HARDPPS_CD) &&\r\n!(status & SER_DCD))\r\nhardpps();\r\n#endif\r\n}\r\nif (dstatus & SER_CTS)\r\nicount->cts++;\r\nwake_up_interruptible(&info->delta_msr_wait);\r\n}\r\nif ((info->flags & ASYNC_CHECK_CD) && (dstatus & SER_DCD)) {\r\n#if (defined(SERIAL_DEBUG_OPEN) || defined(SERIAL_DEBUG_INTR))\r\nprintk("ttyS%d CD now %s...", info->line,\r\n(!(status & SER_DCD)) ? "on" : "off");\r\n#endif\r\nif (!(status & SER_DCD))\r\nwake_up_interruptible(&info->open_wait);\r\nelse {\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("doing serial hangup...");\r\n#endif\r\nif (info->tty)\r\ntty_hangup(info->tty);\r\n}\r\n}\r\nif (info->flags & ASYNC_CTS_FLOW) {\r\nif (info->tty->hw_stopped) {\r\nif (!(status & SER_CTS)) {\r\n#if (defined(SERIAL_DEBUG_INTR) || defined(SERIAL_DEBUG_FLOW))\r\nprintk("CTS tx start...");\r\n#endif\r\ninfo->tty->hw_stopped = 0;\r\ninfo->IER |= UART_IER_THRI;\r\ncustom.intena = IF_SETCLR | IF_TBE;\r\nmb();\r\ncustom.intreq = IF_SETCLR | IF_TBE;\r\nmb();\r\nrs_sched_event(info, RS_EVENT_WRITE_WAKEUP);\r\nreturn;\r\n}\r\n} else {\r\nif ((status & SER_CTS)) {\r\n#if (defined(SERIAL_DEBUG_INTR) || defined(SERIAL_DEBUG_FLOW))\r\nprintk("CTS tx stop...");\r\n#endif\r\ninfo->tty->hw_stopped = 1;\r\ninfo->IER &= ~UART_IER_THRI;\r\ncustom.intena = IF_TBE;\r\nmb();\r\ncustom.intreq = IF_TBE;\r\nmb();\r\n}\r\n}\r\n}\r\n}\r\nstatic irqreturn_t ser_vbl_int( int irq, void *data)\r\n{\r\nstruct async_struct * info = IRQ_ports;\r\nif(info->IER & UART_IER_MSI)\r\ncheck_modem_status(info);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ser_rx_int(int irq, void *dev_id)\r\n{\r\nstruct async_struct * info;\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("ser_rx_int...");\r\n#endif\r\ninfo = IRQ_ports;\r\nif (!info || !info->tty)\r\nreturn IRQ_NONE;\r\nreceive_chars(info);\r\ninfo->last_active = jiffies;\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("end.\n");\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ser_tx_int(int irq, void *dev_id)\r\n{\r\nstruct async_struct * info;\r\nif (custom.serdatr & SDR_TBE) {\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("ser_tx_int...");\r\n#endif\r\ninfo = IRQ_ports;\r\nif (!info || !info->tty)\r\nreturn IRQ_NONE;\r\ntransmit_chars(info);\r\ninfo->last_active = jiffies;\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("end.\n");\r\n#endif\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void do_softint(unsigned long private_)\r\n{\r\nstruct async_struct *info = (struct async_struct *) private_;\r\nstruct tty_struct *tty;\r\ntty = info->tty;\r\nif (!tty)\r\nreturn;\r\nif (test_and_clear_bit(RS_EVENT_WRITE_WAKEUP, &info->event))\r\ntty_wakeup(tty);\r\n}\r\nstatic int startup(struct async_struct * info)\r\n{\r\nunsigned long flags;\r\nint retval=0;\r\nunsigned long page;\r\npage = get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\nreturn -ENOMEM;\r\nlocal_irq_save(flags);\r\nif (info->flags & ASYNC_INITIALIZED) {\r\nfree_page(page);\r\ngoto errout;\r\n}\r\nif (info->xmit.buf)\r\nfree_page(page);\r\nelse\r\ninfo->xmit.buf = (unsigned char *) page;\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("starting up ttys%d ...", info->line);\r\n#endif\r\ncustom.intreq = IF_RBF;\r\nmb();\r\nretval = request_irq(IRQ_AMIGA_VERTB, ser_vbl_int, 0, "serial status", info);\r\nif (retval) {\r\nif (serial_isroot()) {\r\nif (info->tty)\r\nset_bit(TTY_IO_ERROR,\r\n&info->tty->flags);\r\nretval = 0;\r\n}\r\ngoto errout;\r\n}\r\ncustom.intena = IF_SETCLR | IF_RBF | IF_TBE;\r\nmb();\r\ninfo->IER = UART_IER_MSI;\r\ncurrent_ctl_bits = ciab.pra & (SER_DCD | SER_CTS | SER_DSR);\r\nIRQ_ports = info;\r\ninfo->MCR = 0;\r\nif (info->tty->termios->c_cflag & CBAUD)\r\ninfo->MCR = SER_DTR | SER_RTS;\r\nrtsdtr_ctrl(info->MCR);\r\nif (info->tty)\r\nclear_bit(TTY_IO_ERROR, &info->tty->flags);\r\ninfo->xmit.head = info->xmit.tail = 0;\r\nif (info->tty) {\r\nif ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)\r\ninfo->tty->alt_speed = 57600;\r\nif ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)\r\ninfo->tty->alt_speed = 115200;\r\nif ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)\r\ninfo->tty->alt_speed = 230400;\r\nif ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)\r\ninfo->tty->alt_speed = 460800;\r\n}\r\nchange_speed(info, NULL);\r\ninfo->flags |= ASYNC_INITIALIZED;\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\nerrout:\r\nlocal_irq_restore(flags);\r\nreturn retval;\r\n}\r\nstatic void shutdown(struct async_struct * info)\r\n{\r\nunsigned long flags;\r\nstruct serial_state *state;\r\nif (!(info->flags & ASYNC_INITIALIZED))\r\nreturn;\r\nstate = info->state;\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("Shutting down serial port %d ....\n", info->line);\r\n#endif\r\nlocal_irq_save(flags);\r\nwake_up_interruptible(&info->delta_msr_wait);\r\nIRQ_ports = NULL;\r\nfree_irq(IRQ_AMIGA_VERTB, info);\r\nif (info->xmit.buf) {\r\nfree_page((unsigned long) info->xmit.buf);\r\ninfo->xmit.buf = NULL;\r\n}\r\ninfo->IER = 0;\r\ncustom.intena = IF_RBF | IF_TBE;\r\nmb();\r\ncustom.adkcon = AC_UARTBRK;\r\nmb();\r\nif (!info->tty || (info->tty->termios->c_cflag & HUPCL))\r\ninfo->MCR &= ~(SER_DTR|SER_RTS);\r\nrtsdtr_ctrl(info->MCR);\r\nif (info->tty)\r\nset_bit(TTY_IO_ERROR, &info->tty->flags);\r\ninfo->flags &= ~ASYNC_INITIALIZED;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void change_speed(struct async_struct *info,\r\nstruct ktermios *old_termios)\r\n{\r\nint quot = 0, baud_base, baud;\r\nunsigned cflag, cval = 0;\r\nint bits;\r\nunsigned long flags;\r\nif (!info->tty || !info->tty->termios)\r\nreturn;\r\ncflag = info->tty->termios->c_cflag;\r\ncval = 3; bits = 10;\r\nif (cflag & CSTOPB) {\r\ncval |= 0x04;\r\nbits++;\r\n}\r\nif (cflag & PARENB) {\r\ncval |= UART_LCR_PARITY;\r\nbits++;\r\n}\r\nif (!(cflag & PARODD))\r\ncval |= UART_LCR_EPAR;\r\n#ifdef CMSPAR\r\nif (cflag & CMSPAR)\r\ncval |= UART_LCR_SPAR;\r\n#endif\r\nbaud = tty_get_baud_rate(info->tty);\r\nif (!baud)\r\nbaud = 9600;\r\nbaud_base = info->state->baud_base;\r\nif (baud == 38400 &&\r\n((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST))\r\nquot = info->state->custom_divisor;\r\nelse {\r\nif (baud == 134)\r\nquot = (2*baud_base / 269);\r\nelse if (baud)\r\nquot = baud_base / baud;\r\n}\r\nif (!quot && old_termios) {\r\ninfo->tty->termios->c_cflag &= ~CBAUD;\r\ninfo->tty->termios->c_cflag |= (old_termios->c_cflag & CBAUD);\r\nbaud = tty_get_baud_rate(info->tty);\r\nif (!baud)\r\nbaud = 9600;\r\nif (baud == 38400 &&\r\n((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST))\r\nquot = info->state->custom_divisor;\r\nelse {\r\nif (baud == 134)\r\nquot = (2*baud_base / 269);\r\nelse if (baud)\r\nquot = baud_base / baud;\r\n}\r\n}\r\nif (!quot)\r\nquot = baud_base / 9600;\r\ninfo->quot = quot;\r\ninfo->timeout = ((info->xmit_fifo_size*HZ*bits*quot) / baud_base);\r\ninfo->timeout += HZ/50;\r\ninfo->IER &= ~UART_IER_MSI;\r\nif (info->flags & ASYNC_HARDPPS_CD)\r\ninfo->IER |= UART_IER_MSI;\r\nif (cflag & CRTSCTS) {\r\ninfo->flags |= ASYNC_CTS_FLOW;\r\ninfo->IER |= UART_IER_MSI;\r\n} else\r\ninfo->flags &= ~ASYNC_CTS_FLOW;\r\nif (cflag & CLOCAL)\r\ninfo->flags &= ~ASYNC_CHECK_CD;\r\nelse {\r\ninfo->flags |= ASYNC_CHECK_CD;\r\ninfo->IER |= UART_IER_MSI;\r\n}\r\ninfo->read_status_mask = UART_LSR_OE | UART_LSR_DR;\r\nif (I_INPCK(info->tty))\r\ninfo->read_status_mask |= UART_LSR_FE | UART_LSR_PE;\r\nif (I_BRKINT(info->tty) || I_PARMRK(info->tty))\r\ninfo->read_status_mask |= UART_LSR_BI;\r\ninfo->ignore_status_mask = 0;\r\nif (I_IGNPAR(info->tty))\r\ninfo->ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\r\nif (I_IGNBRK(info->tty)) {\r\ninfo->ignore_status_mask |= UART_LSR_BI;\r\nif (I_IGNPAR(info->tty))\r\ninfo->ignore_status_mask |= UART_LSR_OE;\r\n}\r\nif ((cflag & CREAD) == 0)\r\ninfo->ignore_status_mask |= UART_LSR_DR;\r\nlocal_irq_save(flags);\r\n{\r\nshort serper;\r\nserper = quot - 1;\r\nif(cval & UART_LCR_PARITY)\r\nserper |= (SERPER_PARENB);\r\ncustom.serper = serper;\r\nmb();\r\n}\r\ninfo->LCR = cval;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int rs_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nstruct async_struct *info;\r\nunsigned long flags;\r\ninfo = tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "rs_put_char"))\r\nreturn 0;\r\nif (!info->xmit.buf)\r\nreturn 0;\r\nlocal_irq_save(flags);\r\nif (CIRC_SPACE(info->xmit.head,\r\ninfo->xmit.tail,\r\nSERIAL_XMIT_SIZE) == 0) {\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\ninfo->xmit.buf[info->xmit.head++] = ch;\r\ninfo->xmit.head &= SERIAL_XMIT_SIZE-1;\r\nlocal_irq_restore(flags);\r\nreturn 1;\r\n}\r\nstatic void rs_flush_chars(struct tty_struct *tty)\r\n{\r\nstruct async_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_flush_chars"))\r\nreturn;\r\nif (info->xmit.head == info->xmit.tail\r\n|| tty->stopped\r\n|| tty->hw_stopped\r\n|| !info->xmit.buf)\r\nreturn;\r\nlocal_irq_save(flags);\r\ninfo->IER |= UART_IER_THRI;\r\ncustom.intena = IF_SETCLR | IF_TBE;\r\nmb();\r\ncustom.intreq = IF_SETCLR | IF_TBE;\r\nmb();\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int rs_write(struct tty_struct * tty, const unsigned char *buf, int count)\r\n{\r\nint c, ret = 0;\r\nstruct async_struct *info;\r\nunsigned long flags;\r\ninfo = tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "rs_write"))\r\nreturn 0;\r\nif (!info->xmit.buf)\r\nreturn 0;\r\nlocal_irq_save(flags);\r\nwhile (1) {\r\nc = CIRC_SPACE_TO_END(info->xmit.head,\r\ninfo->xmit.tail,\r\nSERIAL_XMIT_SIZE);\r\nif (count < c)\r\nc = count;\r\nif (c <= 0) {\r\nbreak;\r\n}\r\nmemcpy(info->xmit.buf + info->xmit.head, buf, c);\r\ninfo->xmit.head = ((info->xmit.head + c) &\r\n(SERIAL_XMIT_SIZE-1));\r\nbuf += c;\r\ncount -= c;\r\nret += c;\r\n}\r\nlocal_irq_restore(flags);\r\nif (info->xmit.head != info->xmit.tail\r\n&& !tty->stopped\r\n&& !tty->hw_stopped\r\n&& !(info->IER & UART_IER_THRI)) {\r\ninfo->IER |= UART_IER_THRI;\r\nlocal_irq_disable();\r\ncustom.intena = IF_SETCLR | IF_TBE;\r\nmb();\r\ncustom.intreq = IF_SETCLR | IF_TBE;\r\nmb();\r\nlocal_irq_restore(flags);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rs_write_room(struct tty_struct *tty)\r\n{\r\nstruct async_struct *info = tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "rs_write_room"))\r\nreturn 0;\r\nreturn CIRC_SPACE(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);\r\n}\r\nstatic int rs_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct async_struct *info = tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "rs_chars_in_buffer"))\r\nreturn 0;\r\nreturn CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);\r\n}\r\nstatic void rs_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct async_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_flush_buffer"))\r\nreturn;\r\nlocal_irq_save(flags);\r\ninfo->xmit.head = info->xmit.tail = 0;\r\nlocal_irq_restore(flags);\r\ntty_wakeup(tty);\r\n}\r\nstatic void rs_send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nstruct async_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_send_char"))\r\nreturn;\r\ninfo->x_char = ch;\r\nif (ch) {\r\nlocal_irq_save(flags);\r\nif(!(custom.intenar & IF_TBE)) {\r\ncustom.intena = IF_SETCLR | IF_TBE;\r\nmb();\r\ncustom.intreq = IF_SETCLR | IF_TBE;\r\nmb();\r\n}\r\nlocal_irq_restore(flags);\r\ninfo->IER |= UART_IER_THRI;\r\n}\r\n}\r\nstatic void rs_throttle(struct tty_struct * tty)\r\n{\r\nstruct async_struct *info = tty->driver_data;\r\nunsigned long flags;\r\n#ifdef SERIAL_DEBUG_THROTTLE\r\nchar buf[64];\r\nprintk("throttle %s: %d....\n", tty_name(tty, buf),\r\ntty->ldisc.chars_in_buffer(tty));\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "rs_throttle"))\r\nreturn;\r\nif (I_IXOFF(tty))\r\nrs_send_xchar(tty, STOP_CHAR(tty));\r\nif (tty->termios->c_cflag & CRTSCTS)\r\ninfo->MCR &= ~SER_RTS;\r\nlocal_irq_save(flags);\r\nrtsdtr_ctrl(info->MCR);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void rs_unthrottle(struct tty_struct * tty)\r\n{\r\nstruct async_struct *info = tty->driver_data;\r\nunsigned long flags;\r\n#ifdef SERIAL_DEBUG_THROTTLE\r\nchar buf[64];\r\nprintk("unthrottle %s: %d....\n", tty_name(tty, buf),\r\ntty->ldisc.chars_in_buffer(tty));\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "rs_unthrottle"))\r\nreturn;\r\nif (I_IXOFF(tty)) {\r\nif (info->x_char)\r\ninfo->x_char = 0;\r\nelse\r\nrs_send_xchar(tty, START_CHAR(tty));\r\n}\r\nif (tty->termios->c_cflag & CRTSCTS)\r\ninfo->MCR |= SER_RTS;\r\nlocal_irq_save(flags);\r\nrtsdtr_ctrl(info->MCR);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int get_serial_info(struct async_struct * info,\r\nstruct serial_struct __user * retinfo)\r\n{\r\nstruct serial_struct tmp;\r\nstruct serial_state *state = info->state;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntty_lock();\r\ntmp.type = state->type;\r\ntmp.line = state->line;\r\ntmp.port = state->port;\r\ntmp.irq = state->irq;\r\ntmp.flags = state->flags;\r\ntmp.xmit_fifo_size = state->xmit_fifo_size;\r\ntmp.baud_base = state->baud_base;\r\ntmp.close_delay = state->close_delay;\r\ntmp.closing_wait = state->closing_wait;\r\ntmp.custom_divisor = state->custom_divisor;\r\ntty_unlock();\r\nif (copy_to_user(retinfo,&tmp,sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int set_serial_info(struct async_struct * info,\r\nstruct serial_struct __user * new_info)\r\n{\r\nstruct serial_struct new_serial;\r\nstruct serial_state old_state, *state;\r\nunsigned int change_irq,change_port;\r\nint retval = 0;\r\nif (copy_from_user(&new_serial,new_info,sizeof(new_serial)))\r\nreturn -EFAULT;\r\ntty_lock();\r\nstate = info->state;\r\nold_state = *state;\r\nchange_irq = new_serial.irq != state->irq;\r\nchange_port = (new_serial.port != state->port);\r\nif(change_irq || change_port || (new_serial.xmit_fifo_size != state->xmit_fifo_size)) {\r\ntty_unlock();\r\nreturn -EINVAL;\r\n}\r\nif (!serial_isroot()) {\r\nif ((new_serial.baud_base != state->baud_base) ||\r\n(new_serial.close_delay != state->close_delay) ||\r\n(new_serial.xmit_fifo_size != state->xmit_fifo_size) ||\r\n((new_serial.flags & ~ASYNC_USR_MASK) !=\r\n(state->flags & ~ASYNC_USR_MASK)))\r\nreturn -EPERM;\r\nstate->flags = ((state->flags & ~ASYNC_USR_MASK) |\r\n(new_serial.flags & ASYNC_USR_MASK));\r\ninfo->flags = ((info->flags & ~ASYNC_USR_MASK) |\r\n(new_serial.flags & ASYNC_USR_MASK));\r\nstate->custom_divisor = new_serial.custom_divisor;\r\ngoto check_and_exit;\r\n}\r\nif (new_serial.baud_base < 9600) {\r\ntty_unlock();\r\nreturn -EINVAL;\r\n}\r\nstate->baud_base = new_serial.baud_base;\r\nstate->flags = ((state->flags & ~ASYNC_FLAGS) |\r\n(new_serial.flags & ASYNC_FLAGS));\r\ninfo->flags = ((state->flags & ~ASYNC_INTERNAL_FLAGS) |\r\n(info->flags & ASYNC_INTERNAL_FLAGS));\r\nstate->custom_divisor = new_serial.custom_divisor;\r\nstate->close_delay = new_serial.close_delay * HZ/100;\r\nstate->closing_wait = new_serial.closing_wait * HZ/100;\r\ninfo->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;\r\ncheck_and_exit:\r\nif (info->flags & ASYNC_INITIALIZED) {\r\nif (((old_state.flags & ASYNC_SPD_MASK) !=\r\n(state->flags & ASYNC_SPD_MASK)) ||\r\n(old_state.custom_divisor != state->custom_divisor)) {\r\nif ((state->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)\r\ninfo->tty->alt_speed = 57600;\r\nif ((state->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)\r\ninfo->tty->alt_speed = 115200;\r\nif ((state->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)\r\ninfo->tty->alt_speed = 230400;\r\nif ((state->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)\r\ninfo->tty->alt_speed = 460800;\r\nchange_speed(info, NULL);\r\n}\r\n} else\r\nretval = startup(info);\r\ntty_unlock();\r\nreturn retval;\r\n}\r\nstatic int get_lsr_info(struct async_struct * info, unsigned int __user *value)\r\n{\r\nunsigned char status;\r\nunsigned int result;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nstatus = custom.serdatr;\r\nmb();\r\nlocal_irq_restore(flags);\r\nresult = ((status & SDR_TSRE) ? TIOCSER_TEMT : 0);\r\nif (copy_to_user(value, &result, sizeof(int)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int rs_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct async_struct * info = tty->driver_data;\r\nunsigned char control, status;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_ioctl"))\r\nreturn -ENODEV;\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\ncontrol = info->MCR;\r\nlocal_irq_save(flags);\r\nstatus = ciab.pra;\r\nlocal_irq_restore(flags);\r\nreturn ((control & SER_RTS) ? TIOCM_RTS : 0)\r\n| ((control & SER_DTR) ? TIOCM_DTR : 0)\r\n| (!(status & SER_DCD) ? TIOCM_CAR : 0)\r\n| (!(status & SER_DSR) ? TIOCM_DSR : 0)\r\n| (!(status & SER_CTS) ? TIOCM_CTS : 0);\r\n}\r\nstatic int rs_tiocmset(struct tty_struct *tty, unsigned int set,\r\nunsigned int clear)\r\n{\r\nstruct async_struct * info = tty->driver_data;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_ioctl"))\r\nreturn -ENODEV;\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\nlocal_irq_save(flags);\r\nif (set & TIOCM_RTS)\r\ninfo->MCR |= SER_RTS;\r\nif (set & TIOCM_DTR)\r\ninfo->MCR |= SER_DTR;\r\nif (clear & TIOCM_RTS)\r\ninfo->MCR &= ~SER_RTS;\r\nif (clear & TIOCM_DTR)\r\ninfo->MCR &= ~SER_DTR;\r\nrtsdtr_ctrl(info->MCR);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int rs_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct async_struct * info = tty->driver_data;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_break"))\r\nreturn -EINVAL;\r\nlocal_irq_save(flags);\r\nif (break_state == -1)\r\ncustom.adkcon = AC_SETCLR | AC_UARTBRK;\r\nelse\r\ncustom.adkcon = AC_UARTBRK;\r\nmb();\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int rs_get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nstruct async_struct *info = tty->driver_data;\r\nstruct async_icount cnow;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ncnow = info->state->icount;\r\nlocal_irq_restore(flags);\r\nicount->cts = cnow.cts;\r\nicount->dsr = cnow.dsr;\r\nicount->rng = cnow.rng;\r\nicount->dcd = cnow.dcd;\r\nicount->rx = cnow.rx;\r\nicount->tx = cnow.tx;\r\nicount->frame = cnow.frame;\r\nicount->overrun = cnow.overrun;\r\nicount->parity = cnow.parity;\r\nicount->brk = cnow.brk;\r\nicount->buf_overrun = cnow.buf_overrun;\r\nreturn 0;\r\n}\r\nstatic int rs_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct async_struct * info = tty->driver_data;\r\nstruct async_icount cprev, cnow;\r\nvoid __user *argp = (void __user *)arg;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_ioctl"))\r\nreturn -ENODEV;\r\nif ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&\r\n(cmd != TIOCSERCONFIG) && (cmd != TIOCSERGSTRUCT) &&\r\n(cmd != TIOCMIWAIT) && (cmd != TIOCGICOUNT)) {\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\n}\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nreturn get_serial_info(info, argp);\r\ncase TIOCSSERIAL:\r\nreturn set_serial_info(info, argp);\r\ncase TIOCSERCONFIG:\r\nreturn 0;\r\ncase TIOCSERGETLSR:\r\nreturn get_lsr_info(info, argp);\r\ncase TIOCSERGSTRUCT:\r\nif (copy_to_user(argp,\r\ninfo, sizeof(struct async_struct)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase TIOCMIWAIT:\r\nlocal_irq_save(flags);\r\ncprev = info->state->icount;\r\nlocal_irq_restore(flags);\r\nwhile (1) {\r\ninterruptible_sleep_on(&info->delta_msr_wait);\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nlocal_irq_save(flags);\r\ncnow = info->state->icount;\r\nlocal_irq_restore(flags);\r\nif (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&\r\ncnow.dcd == cprev.dcd && cnow.cts == cprev.cts)\r\nreturn -EIO;\r\nif ( ((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||\r\n((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||\r\n((arg & TIOCM_CD) && (cnow.dcd != cprev.dcd)) ||\r\n((arg & TIOCM_CTS) && (cnow.cts != cprev.cts)) ) {\r\nreturn 0;\r\n}\r\ncprev = cnow;\r\n}\r\ncase TIOCSERGWILD:\r\ncase TIOCSERSWILD:\r\nprintk ("TIOCSER?WILD ioctl obsolete, ignored.\n");\r\nreturn 0;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rs_set_termios(struct tty_struct *tty, struct ktermios *old_termios)\r\n{\r\nstruct async_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nunsigned int cflag = tty->termios->c_cflag;\r\nchange_speed(info, old_termios);\r\nif ((old_termios->c_cflag & CBAUD) &&\r\n!(cflag & CBAUD)) {\r\ninfo->MCR &= ~(SER_DTR|SER_RTS);\r\nlocal_irq_save(flags);\r\nrtsdtr_ctrl(info->MCR);\r\nlocal_irq_restore(flags);\r\n}\r\nif (!(old_termios->c_cflag & CBAUD) &&\r\n(cflag & CBAUD)) {\r\ninfo->MCR |= SER_DTR;\r\nif (!(tty->termios->c_cflag & CRTSCTS) ||\r\n!test_bit(TTY_THROTTLED, &tty->flags)) {\r\ninfo->MCR |= SER_RTS;\r\n}\r\nlocal_irq_save(flags);\r\nrtsdtr_ctrl(info->MCR);\r\nlocal_irq_restore(flags);\r\n}\r\nif ((old_termios->c_cflag & CRTSCTS) &&\r\n!(tty->termios->c_cflag & CRTSCTS)) {\r\ntty->hw_stopped = 0;\r\nrs_start(tty);\r\n}\r\n#if 0\r\nif (!(old_termios->c_cflag & CLOCAL) &&\r\n(tty->termios->c_cflag & CLOCAL))\r\nwake_up_interruptible(&info->open_wait);\r\n#endif\r\n}\r\nstatic void rs_close(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct async_struct * info = tty->driver_data;\r\nstruct serial_state *state;\r\nunsigned long flags;\r\nif (!info || serial_paranoia_check(info, tty->name, "rs_close"))\r\nreturn;\r\nstate = info->state;\r\nlocal_irq_save(flags);\r\nif (tty_hung_up_p(filp)) {\r\nDBG_CNT("before DEC-hung");\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("rs_close ttys%d, count = %d\n", info->line, state->count);\r\n#endif\r\nif ((tty->count == 1) && (state->count != 1)) {\r\nprintk("rs_close: bad serial port count; tty->count is 1, "\r\n"state->count is %d\n", state->count);\r\nstate->count = 1;\r\n}\r\nif (--state->count < 0) {\r\nprintk("rs_close: bad serial port count for ttys%d: %d\n",\r\ninfo->line, state->count);\r\nstate->count = 0;\r\n}\r\nif (state->count) {\r\nDBG_CNT("before DEC-2");\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\ninfo->flags |= ASYNC_CLOSING;\r\ntty->closing = 1;\r\nif (info->closing_wait != ASYNC_CLOSING_WAIT_NONE)\r\ntty_wait_until_sent(tty, info->closing_wait);\r\ninfo->read_status_mask &= ~UART_LSR_DR;\r\nif (info->flags & ASYNC_INITIALIZED) {\r\ncustom.intena = IF_RBF;\r\nmb();\r\ncustom.intreq = IF_RBF;\r\nmb();\r\nrs_wait_until_sent(tty, info->timeout);\r\n}\r\nshutdown(info);\r\nrs_flush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\ntty->closing = 0;\r\ninfo->event = 0;\r\ninfo->tty = NULL;\r\nif (info->blocked_open) {\r\nif (info->close_delay) {\r\nmsleep_interruptible(jiffies_to_msecs(info->close_delay));\r\n}\r\nwake_up_interruptible(&info->open_wait);\r\n}\r\ninfo->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);\r\nwake_up_interruptible(&info->close_wait);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void rs_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\nstruct async_struct * info = tty->driver_data;\r\nunsigned long orig_jiffies, char_time;\r\nint lsr;\r\nif (serial_paranoia_check(info, tty->name, "rs_wait_until_sent"))\r\nreturn;\r\nif (info->xmit_fifo_size == 0)\r\nreturn;\r\norig_jiffies = jiffies;\r\nchar_time = (info->timeout - HZ/50) / info->xmit_fifo_size;\r\nchar_time = char_time / 5;\r\nif (char_time == 0)\r\nchar_time = 1;\r\nif (timeout)\r\nchar_time = min_t(unsigned long, char_time, timeout);\r\nif (!timeout || timeout > 2*info->timeout)\r\ntimeout = 2*info->timeout;\r\n#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT\r\nprintk("In rs_wait_until_sent(%d) check=%lu...", timeout, char_time);\r\nprintk("jiff=%lu...", jiffies);\r\n#endif\r\nwhile(!((lsr = custom.serdatr) & SDR_TSRE)) {\r\n#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT\r\nprintk("serdatr = %d (jiff=%lu)...", lsr, jiffies);\r\n#endif\r\nmsleep_interruptible(jiffies_to_msecs(char_time));\r\nif (signal_pending(current))\r\nbreak;\r\nif (timeout && time_after(jiffies, orig_jiffies + timeout))\r\nbreak;\r\n}\r\n__set_current_state(TASK_RUNNING);\r\n#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT\r\nprintk("lsr = %d (jiff=%lu)...done\n", lsr, jiffies);\r\n#endif\r\n}\r\nstatic void rs_hangup(struct tty_struct *tty)\r\n{\r\nstruct async_struct * info = tty->driver_data;\r\nstruct serial_state *state = info->state;\r\nif (serial_paranoia_check(info, tty->name, "rs_hangup"))\r\nreturn;\r\nstate = info->state;\r\nrs_flush_buffer(tty);\r\nshutdown(info);\r\ninfo->event = 0;\r\nstate->count = 0;\r\ninfo->flags &= ~ASYNC_NORMAL_ACTIVE;\r\ninfo->tty = NULL;\r\nwake_up_interruptible(&info->open_wait);\r\n}\r\nstatic int block_til_ready(struct tty_struct *tty, struct file * filp,\r\nstruct async_struct *info)\r\n{\r\n#ifdef DECLARE_WAITQUEUE\r\nDECLARE_WAITQUEUE(wait, current);\r\n#else\r\nstruct wait_queue wait = { current, NULL };\r\n#endif\r\nstruct serial_state *state = info->state;\r\nint retval;\r\nint do_clocal = 0, extra_count = 0;\r\nunsigned long flags;\r\nif (tty_hung_up_p(filp) ||\r\n(info->flags & ASYNC_CLOSING)) {\r\nif (info->flags & ASYNC_CLOSING)\r\ninterruptible_sleep_on(&info->close_wait);\r\n#ifdef SERIAL_DO_RESTART\r\nreturn ((info->flags & ASYNC_HUP_NOTIFY) ?\r\n-EAGAIN : -ERESTARTSYS);\r\n#else\r\nreturn -EAGAIN;\r\n#endif\r\n}\r\nif ((filp->f_flags & O_NONBLOCK) ||\r\n(tty->flags & (1 << TTY_IO_ERROR))) {\r\ninfo->flags |= ASYNC_NORMAL_ACTIVE;\r\nreturn 0;\r\n}\r\nif (tty->termios->c_cflag & CLOCAL)\r\ndo_clocal = 1;\r\nretval = 0;\r\nadd_wait_queue(&info->open_wait, &wait);\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("block_til_ready before block: ttys%d, count = %d\n",\r\nstate->line, state->count);\r\n#endif\r\nlocal_irq_save(flags);\r\nif (!tty_hung_up_p(filp)) {\r\nextra_count = 1;\r\nstate->count--;\r\n}\r\nlocal_irq_restore(flags);\r\ninfo->blocked_open++;\r\nwhile (1) {\r\nlocal_irq_save(flags);\r\nif (tty->termios->c_cflag & CBAUD)\r\nrtsdtr_ctrl(SER_DTR|SER_RTS);\r\nlocal_irq_restore(flags);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (tty_hung_up_p(filp) ||\r\n!(info->flags & ASYNC_INITIALIZED)) {\r\n#ifdef SERIAL_DO_RESTART\r\nif (info->flags & ASYNC_HUP_NOTIFY)\r\nretval = -EAGAIN;\r\nelse\r\nretval = -ERESTARTSYS;\r\n#else\r\nretval = -EAGAIN;\r\n#endif\r\nbreak;\r\n}\r\nif (!(info->flags & ASYNC_CLOSING) &&\r\n(do_clocal || (!(ciab.pra & SER_DCD)) ))\r\nbreak;\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("block_til_ready blocking: ttys%d, count = %d\n",\r\ninfo->line, state->count);\r\n#endif\r\ntty_unlock();\r\nschedule();\r\ntty_lock();\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(&info->open_wait, &wait);\r\nif (extra_count)\r\nstate->count++;\r\ninfo->blocked_open--;\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("block_til_ready after blocking: ttys%d, count = %d\n",\r\ninfo->line, state->count);\r\n#endif\r\nif (retval)\r\nreturn retval;\r\ninfo->flags |= ASYNC_NORMAL_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic int get_async_struct(int line, struct async_struct **ret_info)\r\n{\r\nstruct async_struct *info;\r\nstruct serial_state *sstate;\r\nsstate = rs_table + line;\r\nsstate->count++;\r\nif (sstate->info) {\r\n*ret_info = sstate->info;\r\nreturn 0;\r\n}\r\ninfo = kzalloc(sizeof(struct async_struct), GFP_KERNEL);\r\nif (!info) {\r\nsstate->count--;\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DECLARE_WAITQUEUE\r\ninit_waitqueue_head(&info->open_wait);\r\ninit_waitqueue_head(&info->close_wait);\r\ninit_waitqueue_head(&info->delta_msr_wait);\r\n#endif\r\ninfo->magic = SERIAL_MAGIC;\r\ninfo->port = sstate->port;\r\ninfo->flags = sstate->flags;\r\ninfo->xmit_fifo_size = sstate->xmit_fifo_size;\r\ninfo->line = line;\r\ntasklet_init(&info->tlet, do_softint, (unsigned long)info);\r\ninfo->state = sstate;\r\nif (sstate->info) {\r\nkfree(info);\r\n*ret_info = sstate->info;\r\nreturn 0;\r\n}\r\n*ret_info = sstate->info = info;\r\nreturn 0;\r\n}\r\nstatic int rs_open(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct async_struct *info;\r\nint retval, line;\r\nline = tty->index;\r\nif ((line < 0) || (line >= NR_PORTS)) {\r\nreturn -ENODEV;\r\n}\r\nretval = get_async_struct(line, &info);\r\nif (retval) {\r\nreturn retval;\r\n}\r\ntty->driver_data = info;\r\ninfo->tty = tty;\r\nif (serial_paranoia_check(info, tty->name, "rs_open"))\r\nreturn -ENODEV;\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("rs_open %s, count = %d\n", tty->name, info->state->count);\r\n#endif\r\ninfo->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;\r\nif (tty_hung_up_p(filp) ||\r\n(info->flags & ASYNC_CLOSING)) {\r\nif (info->flags & ASYNC_CLOSING)\r\ninterruptible_sleep_on(&info->close_wait);\r\n#ifdef SERIAL_DO_RESTART\r\nreturn ((info->flags & ASYNC_HUP_NOTIFY) ?\r\n-EAGAIN : -ERESTARTSYS);\r\n#else\r\nreturn -EAGAIN;\r\n#endif\r\n}\r\nretval = startup(info);\r\nif (retval) {\r\nreturn retval;\r\n}\r\nretval = block_til_ready(tty, filp, info);\r\nif (retval) {\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("rs_open returning after block_til_ready with %d\n",\r\nretval);\r\n#endif\r\nreturn retval;\r\n}\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("rs_open %s successful...", tty->name);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic inline void line_info(struct seq_file *m, struct serial_state *state)\r\n{\r\nstruct async_struct *info = state->info, scr_info;\r\nchar stat_buf[30], control, status;\r\nunsigned long flags;\r\nseq_printf(m, "%d: uart:amiga_builtin",state->line);\r\nif (!info) {\r\ninfo = &scr_info;\r\ninfo->magic = SERIAL_MAGIC;\r\ninfo->flags = state->flags;\r\ninfo->quot = 0;\r\ninfo->tty = NULL;\r\n}\r\nlocal_irq_save(flags);\r\nstatus = ciab.pra;\r\ncontrol = info ? info->MCR : status;\r\nlocal_irq_restore(flags);\r\nstat_buf[0] = 0;\r\nstat_buf[1] = 0;\r\nif(!(control & SER_RTS))\r\nstrcat(stat_buf, "|RTS");\r\nif(!(status & SER_CTS))\r\nstrcat(stat_buf, "|CTS");\r\nif(!(control & SER_DTR))\r\nstrcat(stat_buf, "|DTR");\r\nif(!(status & SER_DSR))\r\nstrcat(stat_buf, "|DSR");\r\nif(!(status & SER_DCD))\r\nstrcat(stat_buf, "|CD");\r\nif (info->quot) {\r\nseq_printf(m, " baud:%d", state->baud_base / info->quot);\r\n}\r\nseq_printf(m, " tx:%d rx:%d", state->icount.tx, state->icount.rx);\r\nif (state->icount.frame)\r\nseq_printf(m, " fe:%d", state->icount.frame);\r\nif (state->icount.parity)\r\nseq_printf(m, " pe:%d", state->icount.parity);\r\nif (state->icount.brk)\r\nseq_printf(m, " brk:%d", state->icount.brk);\r\nif (state->icount.overrun)\r\nseq_printf(m, " oe:%d", state->icount.overrun);\r\nseq_printf(m, " %s\n", stat_buf+1);\r\n}\r\nstatic int rs_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "serinfo:1.0 driver:%s\n", serial_version);\r\nline_info(m, &rs_table[0]);\r\nreturn 0;\r\n}\r\nstatic int rs_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, rs_proc_show, NULL);\r\n}\r\nstatic void show_serial_version(void)\r\n{\r\nprintk(KERN_INFO "%s version %s\n", serial_name, serial_version);\r\n}\r\nstatic int __init amiga_serial_probe(struct platform_device *pdev)\r\n{\r\nunsigned long flags;\r\nstruct serial_state * state;\r\nint error;\r\nserial_driver = alloc_tty_driver(1);\r\nif (!serial_driver)\r\nreturn -ENOMEM;\r\nIRQ_ports = NULL;\r\nshow_serial_version();\r\nserial_driver->owner = THIS_MODULE;\r\nserial_driver->driver_name = "amiserial";\r\nserial_driver->name = "ttyS";\r\nserial_driver->major = TTY_MAJOR;\r\nserial_driver->minor_start = 64;\r\nserial_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nserial_driver->subtype = SERIAL_TYPE_NORMAL;\r\nserial_driver->init_termios = tty_std_termios;\r\nserial_driver->init_termios.c_cflag =\r\nB9600 | CS8 | CREAD | HUPCL | CLOCAL;\r\nserial_driver->flags = TTY_DRIVER_REAL_RAW;\r\ntty_set_operations(serial_driver, &serial_ops);\r\nerror = tty_register_driver(serial_driver);\r\nif (error)\r\ngoto fail_put_tty_driver;\r\nstate = rs_table;\r\nstate->magic = SSTATE_MAGIC;\r\nstate->port = (int)&custom.serdatr;\r\nstate->line = 0;\r\nstate->custom_divisor = 0;\r\nstate->close_delay = 5*HZ/10;\r\nstate->closing_wait = 30*HZ;\r\nstate->icount.cts = state->icount.dsr =\r\nstate->icount.rng = state->icount.dcd = 0;\r\nstate->icount.rx = state->icount.tx = 0;\r\nstate->icount.frame = state->icount.parity = 0;\r\nstate->icount.overrun = state->icount.brk = 0;\r\nprintk(KERN_INFO "ttyS%d is the amiga builtin serial port\n",\r\nstate->line);\r\nstate->baud_base = amiga_colorclock;\r\nstate->xmit_fifo_size = 1;\r\nerror = request_irq(IRQ_AMIGA_TBE, ser_tx_int, 0, "serial TX", state);\r\nif (error)\r\ngoto fail_unregister;\r\nerror = request_irq(IRQ_AMIGA_RBF, ser_rx_int, 0,\r\n"serial RX", state);\r\nif (error)\r\ngoto fail_free_irq;\r\nlocal_irq_save(flags);\r\ncustom.intena = IF_RBF | IF_TBE;\r\nmb();\r\ncustom.intreq = IF_RBF | IF_TBE;\r\nmb();\r\nlocal_irq_restore(flags);\r\nciab.ddra |= (SER_DTR | SER_RTS);\r\nciab.ddra &= ~(SER_DCD | SER_CTS | SER_DSR);\r\nplatform_set_drvdata(pdev, state);\r\nreturn 0;\r\nfail_free_irq:\r\nfree_irq(IRQ_AMIGA_TBE, state);\r\nfail_unregister:\r\ntty_unregister_driver(serial_driver);\r\nfail_put_tty_driver:\r\nput_tty_driver(serial_driver);\r\nreturn error;\r\n}\r\nstatic int __exit amiga_serial_remove(struct platform_device *pdev)\r\n{\r\nint error;\r\nstruct serial_state *state = platform_get_drvdata(pdev);\r\nstruct async_struct *info = state->info;\r\ntasklet_kill(&info->tlet);\r\nif ((error = tty_unregister_driver(serial_driver)))\r\nprintk("SERIAL: failed to unregister serial driver (%d)\n",\r\nerror);\r\nput_tty_driver(serial_driver);\r\nrs_table[0].info = NULL;\r\nkfree(info);\r\nfree_irq(IRQ_AMIGA_TBE, rs_table);\r\nfree_irq(IRQ_AMIGA_RBF, rs_table);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn error;\r\n}\r\nstatic int __init amiga_serial_init(void)\r\n{\r\nreturn platform_driver_probe(&amiga_serial_driver, amiga_serial_probe);\r\n}\r\nstatic void __exit amiga_serial_exit(void)\r\n{\r\nplatform_driver_unregister(&amiga_serial_driver);\r\n}\r\nstatic void amiga_serial_putc(char c)\r\n{\r\ncustom.serdat = (unsigned char)c | 0x100;\r\nwhile (!(custom.serdatr & 0x2000))\r\nbarrier();\r\n}\r\nstatic void serial_console_write(struct console *co, const char *s,\r\nunsigned count)\r\n{\r\nunsigned short intena = custom.intenar;\r\ncustom.intena = IF_TBE;\r\nwhile (count--) {\r\nif (*s == '\n')\r\namiga_serial_putc('\r');\r\namiga_serial_putc(*s++);\r\n}\r\ncustom.intena = IF_SETCLR | (intena & IF_TBE);\r\n}\r\nstatic struct tty_driver *serial_console_device(struct console *c, int *index)\r\n{\r\n*index = 0;\r\nreturn serial_driver;\r\n}\r\nstatic int __init amiserial_console_init(void)\r\n{\r\nregister_console(&sercons);\r\nreturn 0;\r\n}
