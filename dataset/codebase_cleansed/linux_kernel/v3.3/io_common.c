static dma_addr_t\r\nsn_default_pci_map(struct pci_dev *pdev, unsigned long paddr, size_t size, int type)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\nsn_default_pci_unmap(struct pci_dev *pdev, dma_addr_t addr, int direction)\r\n{\r\nreturn;\r\n}\r\nstatic void *\r\nsn_default_pci_bus_fixup(struct pcibus_bussoft *soft, struct pci_controller *controller)\r\n{\r\nreturn NULL;\r\n}\r\nstatic inline u64\r\nsal_get_device_dmaflush_list(u64 nasid, u64 widget_num, u64 device_num,\r\nu64 address)\r\n{\r\nstruct ia64_sal_retval ret_stuff;\r\nret_stuff.status = 0;\r\nret_stuff.v0 = 0;\r\nSAL_CALL_NOLOCK(ret_stuff,\r\n(u64) SN_SAL_IOIF_GET_DEVICE_DMAFLUSH_LIST,\r\n(u64) nasid, (u64) widget_num,\r\n(u64) device_num, (u64) address, 0, 0, 0);\r\nreturn ret_stuff.status;\r\n}\r\ninline struct pcidev_info *\r\nsn_pcidev_info_get(struct pci_dev *dev)\r\n{\r\nstruct pcidev_info *pcidev;\r\nlist_for_each_entry(pcidev,\r\n&(SN_PLATFORM_DATA(dev)->pcidev_info), pdi_list) {\r\nif (pcidev->pdi_linux_pcidev == dev)\r\nreturn pcidev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic s64 sn_device_fixup_war(u64 nasid, u64 widget, int device,\r\nstruct sn_flush_device_common *common)\r\n{\r\nstruct sn_flush_device_war *war_list;\r\nstruct sn_flush_device_war *dev_entry;\r\nstruct ia64_sal_retval isrv = {0,0,0,0};\r\nprintk_once(KERN_WARNING\r\n"PROM version < 4.50 -- implementing old PROM flush WAR\n");\r\nwar_list = kzalloc(DEV_PER_WIDGET * sizeof(*war_list), GFP_KERNEL);\r\nBUG_ON(!war_list);\r\nSAL_CALL_NOLOCK(isrv, SN_SAL_IOIF_GET_WIDGET_DMAFLUSH_LIST,\r\nnasid, widget, __pa(war_list), 0, 0, 0 ,0);\r\nif (isrv.status)\r\npanic("sn_device_fixup_war failed: %s\n",\r\nia64_sal_strerror(isrv.status));\r\ndev_entry = war_list + device;\r\nmemcpy(common,dev_entry, sizeof(*common));\r\nkfree(war_list);\r\nreturn isrv.status;\r\n}\r\nvoid __init\r\nsn_common_hubdev_init(struct hubdev_info *hubdev)\r\n{\r\nstruct sn_flush_device_kernel *sn_flush_device_kernel;\r\nstruct sn_flush_device_kernel *dev_entry;\r\ns64 status;\r\nint widget, device, size;\r\nif (hubdev->hdi_nasid & 1)\r\nice_error_init(hubdev);\r\nelse\r\nhub_error_init(hubdev);\r\nfor (widget = 0; widget <= HUB_WIDGET_ID_MAX; widget++)\r\nhubdev->hdi_xwidget_info[widget].xwi_hubinfo = hubdev;\r\nif (!hubdev->hdi_flush_nasid_list.widget_p)\r\nreturn;\r\nsize = (HUB_WIDGET_ID_MAX + 1) *\r\nsizeof(struct sn_flush_device_kernel *);\r\nhubdev->hdi_flush_nasid_list.widget_p =\r\nkzalloc(size, GFP_KERNEL);\r\nBUG_ON(!hubdev->hdi_flush_nasid_list.widget_p);\r\nfor (widget = 0; widget <= HUB_WIDGET_ID_MAX; widget++) {\r\nsize = DEV_PER_WIDGET *\r\nsizeof(struct sn_flush_device_kernel);\r\nsn_flush_device_kernel = kzalloc(size, GFP_KERNEL);\r\nBUG_ON(!sn_flush_device_kernel);\r\ndev_entry = sn_flush_device_kernel;\r\nfor (device = 0; device < DEV_PER_WIDGET;\r\ndevice++, dev_entry++) {\r\nsize = sizeof(struct sn_flush_device_common);\r\ndev_entry->common = kzalloc(size, GFP_KERNEL);\r\nBUG_ON(!dev_entry->common);\r\nif (sn_prom_feature_available(PRF_DEVICE_FLUSH_LIST))\r\nstatus = sal_get_device_dmaflush_list(\r\nhubdev->hdi_nasid, widget, device,\r\n(u64)(dev_entry->common));\r\nelse\r\nstatus = sn_device_fixup_war(hubdev->hdi_nasid,\r\nwidget, device,\r\ndev_entry->common);\r\nif (status != SALRET_OK)\r\npanic("SAL call failed: %s\n",\r\nia64_sal_strerror(status));\r\nspin_lock_init(&dev_entry->sfdl_flush_lock);\r\n}\r\nif (sn_flush_device_kernel)\r\nhubdev->hdi_flush_nasid_list.widget_p[widget] =\r\nsn_flush_device_kernel;\r\n}\r\n}\r\nvoid sn_pci_unfixup_slot(struct pci_dev *dev)\r\n{\r\nstruct pci_dev *host_pci_dev = SN_PCIDEV_INFO(dev)->host_pci_dev;\r\nsn_irq_unfixup(dev);\r\npci_dev_put(host_pci_dev);\r\npci_dev_put(dev);\r\n}\r\nvoid sn_pci_fixup_slot(struct pci_dev *dev, struct pcidev_info *pcidev_info,\r\nstruct sn_irq_info *sn_irq_info)\r\n{\r\nint segment = pci_domain_nr(dev->bus);\r\nstruct pcibus_bussoft *bs;\r\nstruct pci_bus *host_pci_bus;\r\nstruct pci_dev *host_pci_dev;\r\nunsigned int bus_no, devfn;\r\npci_dev_get(dev);\r\nlist_add_tail(&pcidev_info->pdi_list,\r\n&(SN_PLATFORM_DATA(dev->bus)->pcidev_info));\r\nbus_no = (pcidev_info->pdi_slot_host_handle >> 32) & 0xff;\r\ndevfn = pcidev_info->pdi_slot_host_handle & 0xffffffff;\r\nhost_pci_bus = pci_find_bus(segment, bus_no);\r\nhost_pci_dev = pci_get_slot(host_pci_bus, devfn);\r\npcidev_info->host_pci_dev = host_pci_dev;\r\npcidev_info->pdi_linux_pcidev = dev;\r\npcidev_info->pdi_host_pcidev_info = SN_PCIDEV_INFO(host_pci_dev);\r\nbs = SN_PCIBUS_BUSSOFT(dev->bus);\r\npcidev_info->pdi_pcibus_info = bs;\r\nif (bs && bs->bs_asic_type < PCIIO_ASIC_MAX_TYPES) {\r\nSN_PCIDEV_BUSPROVIDER(dev) = sn_pci_provider[bs->bs_asic_type];\r\n} else {\r\nSN_PCIDEV_BUSPROVIDER(dev) = &sn_pci_default_provider;\r\n}\r\nif (bs && sn_irq_info->irq_irq) {\r\npcidev_info->pdi_sn_irq_info = sn_irq_info;\r\ndev->irq = pcidev_info->pdi_sn_irq_info->irq_irq;\r\nsn_irq_fixup(dev, sn_irq_info);\r\n} else {\r\npcidev_info->pdi_sn_irq_info = NULL;\r\nkfree(sn_irq_info);\r\n}\r\n}\r\nvoid\r\nsn_common_bus_fixup(struct pci_bus *bus,\r\nstruct pcibus_bussoft *prom_bussoft_ptr)\r\n{\r\nint cnode;\r\nstruct pci_controller *controller;\r\nstruct hubdev_info *hubdev_info;\r\nint nasid;\r\nvoid *provider_soft;\r\nstruct sn_pcibus_provider *provider;\r\nstruct sn_platform_data *sn_platform_data;\r\ncontroller = PCI_CONTROLLER(bus);\r\nif (prom_bussoft_ptr->bs_asic_type >= PCIIO_ASIC_MAX_TYPES) {\r\nprintk(KERN_WARNING "sn_common_bus_fixup: Unsupported asic type, %d",\r\nprom_bussoft_ptr->bs_asic_type);\r\nreturn;\r\n}\r\nif (prom_bussoft_ptr->bs_asic_type == PCIIO_ASIC_TYPE_PPB)\r\nreturn;\r\nprovider = sn_pci_provider[prom_bussoft_ptr->bs_asic_type];\r\nif (provider == NULL)\r\npanic("sn_common_bus_fixup: No provider registered for this asic type, %d",\r\nprom_bussoft_ptr->bs_asic_type);\r\nif (provider->bus_fixup)\r\nprovider_soft = (*provider->bus_fixup) (prom_bussoft_ptr,\r\ncontroller);\r\nelse\r\nprovider_soft = NULL;\r\ncontroller->platform_data = kzalloc(sizeof(struct sn_platform_data),\r\nGFP_KERNEL);\r\nBUG_ON(controller->platform_data == NULL);\r\nsn_platform_data =\r\n(struct sn_platform_data *) controller->platform_data;\r\nsn_platform_data->provider_soft = provider_soft;\r\nINIT_LIST_HEAD(&((struct sn_platform_data *)\r\ncontroller->platform_data)->pcidev_info);\r\nnasid = NASID_GET(SN_PCIBUS_BUSSOFT(bus)->bs_base);\r\ncnode = nasid_to_cnodeid(nasid);\r\nhubdev_info = (struct hubdev_info *)(NODEPDA(cnode)->pdinfo);\r\nSN_PCIBUS_BUSSOFT(bus)->bs_xwidget_info =\r\n&(hubdev_info->hdi_xwidget_info[SN_PCIBUS_BUSSOFT(bus)->bs_xid]);\r\nif (controller->node >= num_online_nodes()) {\r\nstruct pcibus_bussoft *b = SN_PCIBUS_BUSSOFT(bus);\r\nprintk(KERN_WARNING "Device ASIC=%u XID=%u PBUSNUM=%u "\r\n"L_IO=%llx L_MEM=%llx BASE=%llx\n",\r\nb->bs_asic_type, b->bs_xid, b->bs_persist_busnum,\r\nb->bs_legacy_io, b->bs_legacy_mem, b->bs_base);\r\nprintk(KERN_WARNING "on node %d but only %d nodes online."\r\n"Association set to undetermined.\n",\r\ncontroller->node, num_online_nodes());\r\ncontroller->node = -1;\r\n}\r\n}\r\nvoid sn_bus_store_sysdata(struct pci_dev *dev)\r\n{\r\nstruct sysdata_el *element;\r\nelement = kzalloc(sizeof(struct sysdata_el), GFP_KERNEL);\r\nif (!element) {\r\ndev_dbg(&dev->dev, "%s: out of memory!\n", __func__);\r\nreturn;\r\n}\r\nelement->sysdata = SN_PCIDEV_INFO(dev);\r\nlist_add(&element->entry, &sn_sysdata_list);\r\n}\r\nvoid sn_bus_free_sysdata(void)\r\n{\r\nstruct sysdata_el *element;\r\nstruct list_head *list, *safe;\r\nlist_for_each_safe(list, safe, &sn_sysdata_list) {\r\nelement = list_entry(list, struct sysdata_el, entry);\r\nlist_del(&element->entry);\r\nlist_del(&(((struct pcidev_info *)\r\n(element->sysdata))->pdi_list));\r\nkfree(element->sysdata);\r\nkfree(element);\r\n}\r\nreturn;\r\n}\r\nvoid __init hubdev_init_node(nodepda_t * npda, cnodeid_t node)\r\n{\r\nstruct hubdev_info *hubdev_info;\r\nint size;\r\npg_data_t *pg;\r\nsize = sizeof(struct hubdev_info);\r\nif (node >= num_online_nodes())\r\npg = NODE_DATA(0);\r\nelse\r\npg = NODE_DATA(node);\r\nhubdev_info = (struct hubdev_info *)alloc_bootmem_node(pg, size);\r\nnpda->pdinfo = (void *)hubdev_info;\r\n}\r\ngeoid_t\r\ncnodeid_get_geoid(cnodeid_t cnode)\r\n{\r\nstruct hubdev_info *hubdev;\r\nhubdev = (struct hubdev_info *)(NODEPDA(cnode)->pdinfo);\r\nreturn hubdev->hdi_geoid;\r\n}\r\nvoid sn_generate_path(struct pci_bus *pci_bus, char *address)\r\n{\r\nnasid_t nasid;\r\ncnodeid_t cnode;\r\ngeoid_t geoid;\r\nmoduleid_t moduleid;\r\nu16 bricktype;\r\nnasid = NASID_GET(SN_PCIBUS_BUSSOFT(pci_bus)->bs_base);\r\ncnode = nasid_to_cnodeid(nasid);\r\ngeoid = cnodeid_get_geoid(cnode);\r\nmoduleid = geo_module(geoid);\r\nsprintf(address, "module_%c%c%c%c%.2d",\r\n'0'+RACK_GET_CLASS(MODULE_GET_RACK(moduleid)),\r\n'0'+RACK_GET_GROUP(MODULE_GET_RACK(moduleid)),\r\n'0'+RACK_GET_NUM(MODULE_GET_RACK(moduleid)),\r\nMODULE_GET_BTCHAR(moduleid), MODULE_GET_BPOS(moduleid));\r\nbricktype = MODULE_GET_BTYPE(moduleid);\r\nif ((bricktype == L1_BRICKTYPE_191010) ||\r\n(bricktype == L1_BRICKTYPE_1932))\r\nsprintf(address + strlen(address), "^%d",\r\ngeo_slot(geoid));\r\n}\r\nvoid __devinit\r\nsn_pci_fixup_bus(struct pci_bus *bus)\r\n{\r\nif (SN_ACPI_BASE_SUPPORT())\r\nsn_acpi_bus_fixup(bus);\r\nelse\r\nsn_bus_fixup(bus);\r\n}\r\nstatic int __init\r\nsn_io_early_init(void)\r\n{\r\nint i;\r\nif (!ia64_platform_is("sn2") || IS_RUNNING_ON_FAKE_PROM())\r\nreturn 0;\r\n{\r\nstruct acpi_table_header *header = NULL;\r\nacpi_get_table(ACPI_SIG_DSDT, 1, &header);\r\nBUG_ON(header == NULL);\r\nsn_acpi_rev = header->oem_revision;\r\n}\r\nfor (i = 0; i < PCIIO_ASIC_MAX_TYPES; i++)\r\nsn_pci_provider[i] = &sn_pci_default_provider;\r\npcibr_init_provider();\r\ntioca_init_provider();\r\ntioce_init_provider();\r\nia64_max_iommu_merge_mask = ~PAGE_MASK;\r\nsn_irq_lh_init();\r\nINIT_LIST_HEAD(&sn_sysdata_list);\r\nsn_init_cpei_timer();\r\n#ifdef CONFIG_PROC_FS\r\nregister_sn_procfs();\r\n#endif\r\n{\r\nstruct acpi_table_header *header;\r\n(void)acpi_get_table(ACPI_SIG_DSDT, 1, &header);\r\nprintk(KERN_INFO "ACPI DSDT OEM Rev 0x%x\n",\r\nheader->oem_revision);\r\n}\r\nif (SN_ACPI_BASE_SUPPORT())\r\nsn_io_acpi_init();\r\nelse\r\nsn_io_init();\r\nreturn 0;\r\n}\r\nint __init\r\nsn_io_late_init(void)\r\n{\r\nstruct pci_bus *bus;\r\nstruct pcibus_bussoft *bussoft;\r\ncnodeid_t cnode;\r\nnasid_t nasid;\r\ncnodeid_t near_cnode;\r\nif (!ia64_platform_is("sn2") || IS_RUNNING_ON_FAKE_PROM())\r\nreturn 0;\r\nbus = NULL;\r\nwhile ((bus = pci_find_next_bus(bus)) != NULL) {\r\nbussoft = SN_PCIBUS_BUSSOFT(bus);\r\nnasid = NASID_GET(bussoft->bs_base);\r\ncnode = nasid_to_cnodeid(nasid);\r\nif ((bussoft->bs_asic_type == PCIIO_ASIC_TYPE_TIOCP) ||\r\n(bussoft->bs_asic_type == PCIIO_ASIC_TYPE_TIOCE) ||\r\n(bussoft->bs_asic_type == PCIIO_ASIC_TYPE_PIC)) {\r\nint e = sn_hwperf_get_nearest_node(cnode, NULL,\r\n&near_cnode);\r\nif (e < 0) {\r\nnear_cnode = (cnodeid_t)-1;\r\nprintk(KERN_WARNING "sn_io_late_init: failed "\r\n"to find near node with CPUs for "\r\n"node %d, err=%d\n", cnode, e);\r\n}\r\nPCI_CONTROLLER(bus)->node = near_cnode;\r\n}\r\n}\r\nsn_ioif_inited = 1;\r\nreturn 0;\r\n}
