static inline u32 mpc8xxx_gpio2mask(unsigned int gpio)\r\n{\r\nreturn 1u << (MPC8XXX_GPIO_PINS - 1 - gpio);\r\n}\r\nstatic inline struct mpc8xxx_gpio_chip *\r\nto_mpc8xxx_gpio_chip(struct of_mm_gpio_chip *mm)\r\n{\r\nreturn container_of(mm, struct mpc8xxx_gpio_chip, mm_gc);\r\n}\r\nstatic void mpc8xxx_gpio_save_regs(struct of_mm_gpio_chip *mm)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = to_mpc8xxx_gpio_chip(mm);\r\nmpc8xxx_gc->data = in_be32(mm->regs + GPIO_DAT);\r\n}\r\nstatic int mpc8572_gpio_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nu32 val;\r\nstruct of_mm_gpio_chip *mm = to_of_mm_gpio_chip(gc);\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = to_mpc8xxx_gpio_chip(mm);\r\nval = in_be32(mm->regs + GPIO_DAT) & ~in_be32(mm->regs + GPIO_DIR);\r\nreturn (val | mpc8xxx_gc->data) & mpc8xxx_gpio2mask(gpio);\r\n}\r\nstatic int mpc8xxx_gpio_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct of_mm_gpio_chip *mm = to_of_mm_gpio_chip(gc);\r\nreturn in_be32(mm->regs + GPIO_DAT) & mpc8xxx_gpio2mask(gpio);\r\n}\r\nstatic void mpc8xxx_gpio_set(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nstruct of_mm_gpio_chip *mm = to_of_mm_gpio_chip(gc);\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = to_mpc8xxx_gpio_chip(mm);\r\nunsigned long flags;\r\nspin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\nif (val)\r\nmpc8xxx_gc->data |= mpc8xxx_gpio2mask(gpio);\r\nelse\r\nmpc8xxx_gc->data &= ~mpc8xxx_gpio2mask(gpio);\r\nout_be32(mm->regs + GPIO_DAT, mpc8xxx_gc->data);\r\nspin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\n}\r\nstatic int mpc8xxx_gpio_dir_in(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct of_mm_gpio_chip *mm = to_of_mm_gpio_chip(gc);\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = to_mpc8xxx_gpio_chip(mm);\r\nunsigned long flags;\r\nspin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\nclrbits32(mm->regs + GPIO_DIR, mpc8xxx_gpio2mask(gpio));\r\nspin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mpc8xxx_gpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nstruct of_mm_gpio_chip *mm = to_of_mm_gpio_chip(gc);\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = to_mpc8xxx_gpio_chip(mm);\r\nunsigned long flags;\r\nmpc8xxx_gpio_set(gc, gpio, val);\r\nspin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\nsetbits32(mm->regs + GPIO_DIR, mpc8xxx_gpio2mask(gpio));\r\nspin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mpc5121_gpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nif (gpio >= 28)\r\nreturn -EINVAL;\r\nreturn mpc8xxx_gpio_dir_out(gc, gpio, val);\r\n}\r\nstatic int mpc8xxx_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct of_mm_gpio_chip *mm = to_of_mm_gpio_chip(gc);\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = to_mpc8xxx_gpio_chip(mm);\r\nif (mpc8xxx_gc->irq && offset < MPC8XXX_GPIO_PINS)\r\nreturn irq_create_mapping(mpc8xxx_gc->irq, offset);\r\nelse\r\nreturn -ENXIO;\r\n}\r\nstatic void mpc8xxx_gpio_irq_cascade(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct of_mm_gpio_chip *mm = &mpc8xxx_gc->mm_gc;\r\nunsigned int mask;\r\nmask = in_be32(mm->regs + GPIO_IER) & in_be32(mm->regs + GPIO_IMR);\r\nif (mask)\r\ngeneric_handle_irq(irq_linear_revmap(mpc8xxx_gc->irq,\r\n32 - ffs(mask)));\r\nchip->irq_eoi(&desc->irq_data);\r\n}\r\nstatic void mpc8xxx_irq_unmask(struct irq_data *d)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_data_get_irq_chip_data(d);\r\nstruct of_mm_gpio_chip *mm = &mpc8xxx_gc->mm_gc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\nsetbits32(mm->regs + GPIO_IMR, mpc8xxx_gpio2mask(irqd_to_hwirq(d)));\r\nspin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\n}\r\nstatic void mpc8xxx_irq_mask(struct irq_data *d)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_data_get_irq_chip_data(d);\r\nstruct of_mm_gpio_chip *mm = &mpc8xxx_gc->mm_gc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\nclrbits32(mm->regs + GPIO_IMR, mpc8xxx_gpio2mask(irqd_to_hwirq(d)));\r\nspin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\n}\r\nstatic void mpc8xxx_irq_ack(struct irq_data *d)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_data_get_irq_chip_data(d);\r\nstruct of_mm_gpio_chip *mm = &mpc8xxx_gc->mm_gc;\r\nout_be32(mm->regs + GPIO_IER, mpc8xxx_gpio2mask(irqd_to_hwirq(d)));\r\n}\r\nstatic int mpc8xxx_irq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_data_get_irq_chip_data(d);\r\nstruct of_mm_gpio_chip *mm = &mpc8xxx_gc->mm_gc;\r\nunsigned long flags;\r\nswitch (flow_type) {\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nspin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\nsetbits32(mm->regs + GPIO_ICR,\r\nmpc8xxx_gpio2mask(irqd_to_hwirq(d)));\r\nspin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nspin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\nclrbits32(mm->regs + GPIO_ICR,\r\nmpc8xxx_gpio2mask(irqd_to_hwirq(d)));\r\nspin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpc512x_irq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_data_get_irq_chip_data(d);\r\nstruct of_mm_gpio_chip *mm = &mpc8xxx_gc->mm_gc;\r\nunsigned long gpio = irqd_to_hwirq(d);\r\nvoid __iomem *reg;\r\nunsigned int shift;\r\nunsigned long flags;\r\nif (gpio < 16) {\r\nreg = mm->regs + GPIO_ICR;\r\nshift = (15 - gpio) * 2;\r\n} else {\r\nreg = mm->regs + GPIO_ICR2;\r\nshift = (15 - (gpio % 16)) * 2;\r\n}\r\nswitch (flow_type) {\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nspin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\nclrsetbits_be32(reg, 3 << shift, 2 << shift);\r\nspin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nspin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\nclrsetbits_be32(reg, 3 << shift, 1 << shift);\r\nspin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nspin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\nclrbits32(reg, 3 << shift);\r\nspin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpc8xxx_gpio_irq_map(struct irq_host *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = h->host_data;\r\nif (mpc8xxx_gc->of_dev_id_data)\r\nmpc8xxx_irq_chip.irq_set_type = mpc8xxx_gc->of_dev_id_data;\r\nirq_set_chip_data(virq, h->host_data);\r\nirq_set_chip_and_handler(virq, &mpc8xxx_irq_chip, handle_level_irq);\r\nirq_set_irq_type(virq, IRQ_TYPE_NONE);\r\nreturn 0;\r\n}\r\nstatic int mpc8xxx_gpio_irq_xlate(struct irq_host *h, struct device_node *ct,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq,\r\nunsigned int *out_flags)\r\n{\r\n*out_hwirq = intspec[0];\r\n*out_flags = intspec[1];\r\nreturn 0;\r\n}\r\nstatic void __init mpc8xxx_add_controller(struct device_node *np)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc;\r\nstruct of_mm_gpio_chip *mm_gc;\r\nstruct gpio_chip *gc;\r\nconst struct of_device_id *id;\r\nunsigned hwirq;\r\nint ret;\r\nmpc8xxx_gc = kzalloc(sizeof(*mpc8xxx_gc), GFP_KERNEL);\r\nif (!mpc8xxx_gc) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nspin_lock_init(&mpc8xxx_gc->lock);\r\nmm_gc = &mpc8xxx_gc->mm_gc;\r\ngc = &mm_gc->gc;\r\nmm_gc->save_regs = mpc8xxx_gpio_save_regs;\r\ngc->ngpio = MPC8XXX_GPIO_PINS;\r\ngc->direction_input = mpc8xxx_gpio_dir_in;\r\ngc->direction_output = of_device_is_compatible(np, "fsl,mpc5121-gpio") ?\r\nmpc5121_gpio_dir_out : mpc8xxx_gpio_dir_out;\r\ngc->get = of_device_is_compatible(np, "fsl,mpc8572-gpio") ?\r\nmpc8572_gpio_get : mpc8xxx_gpio_get;\r\ngc->set = mpc8xxx_gpio_set;\r\ngc->to_irq = mpc8xxx_gpio_to_irq;\r\nret = of_mm_gpiochip_add(np, mm_gc);\r\nif (ret)\r\ngoto err;\r\nhwirq = irq_of_parse_and_map(np, 0);\r\nif (hwirq == NO_IRQ)\r\ngoto skip_irq;\r\nmpc8xxx_gc->irq =\r\nirq_alloc_host(np, IRQ_HOST_MAP_LINEAR, MPC8XXX_GPIO_PINS,\r\n&mpc8xxx_gpio_irq_ops, MPC8XXX_GPIO_PINS);\r\nif (!mpc8xxx_gc->irq)\r\ngoto skip_irq;\r\nid = of_match_node(mpc8xxx_gpio_ids, np);\r\nif (id)\r\nmpc8xxx_gc->of_dev_id_data = id->data;\r\nmpc8xxx_gc->irq->host_data = mpc8xxx_gc;\r\nout_be32(mm_gc->regs + GPIO_IER, 0xffffffff);\r\nout_be32(mm_gc->regs + GPIO_IMR, 0);\r\nirq_set_handler_data(hwirq, mpc8xxx_gc);\r\nirq_set_chained_handler(hwirq, mpc8xxx_gpio_irq_cascade);\r\nskip_irq:\r\nreturn;\r\nerr:\r\npr_err("%s: registration failed with status %d\n",\r\nnp->full_name, ret);\r\nkfree(mpc8xxx_gc);\r\nreturn;\r\n}\r\nstatic int __init mpc8xxx_add_gpiochips(void)\r\n{\r\nstruct device_node *np;\r\nfor_each_matching_node(np, mpc8xxx_gpio_ids)\r\nmpc8xxx_add_controller(np);\r\nreturn 0;\r\n}
