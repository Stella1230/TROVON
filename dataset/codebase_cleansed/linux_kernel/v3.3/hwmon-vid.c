int vid_from_reg(int val, u8 vrm)\r\n{\r\nint vid;\r\nswitch(vrm) {\r\ncase 100:\r\nval &= 0x3f;\r\nif((val & 0x1f) == 0x1f)\r\nreturn 0;\r\nif((val & 0x1f) <= 0x09 || val == 0x0a)\r\nvid = 1087500 - (val & 0x1f) * 25000;\r\nelse\r\nvid = 1862500 - (val & 0x1f) * 25000;\r\nif(val & 0x20)\r\nvid -= 12500;\r\nreturn((vid + 500) / 1000);\r\ncase 110:\r\nval &= 0xff;\r\nif (val < 0x02 || val > 0xb2)\r\nreturn 0;\r\nreturn((1600000 - (val - 2) * 6250 + 500) / 1000);\r\ncase 24:\r\nval &= 0x1f;\r\nif (val == 0x1f)\r\nreturn 0;\r\ncase 25:\r\nval &= 0x3f;\r\nreturn (val < 32) ? 1550 - 25 * val\r\n: 775 - (25 * (val - 31)) / 2;\r\ncase 91:\r\ncase 90:\r\nval &= 0x1f;\r\nreturn(val == 0x1f ? 0 :\r\n1850 - val * 25);\r\ncase 85:\r\nval &= 0x1f;\r\nreturn((val & 0x10 ? 25 : 0) +\r\n((val & 0x0f) > 0x04 ? 2050 : 1250) -\r\n((val & 0x0f) * 50));\r\ncase 84:\r\nval &= 0x0f;\r\ncase 82:\r\nval &= 0x1f;\r\nreturn(val == 0x1f ? 0 :\r\nval & 0x10 ? 5100 - (val) * 100 :\r\n2050 - (val) * 50);\r\ncase 17:\r\nval &= 0x1f;\r\nreturn(val & 0x10 ? 975 - (val & 0xF) * 25 :\r\n1750 - val * 50);\r\ncase 13:\r\ncase 131:\r\nval &= 0x3f;\r\nif (vrm == 131 && val == 0x3f)\r\nval++;\r\nreturn(1708 - val * 16);\r\ncase 14:\r\nval &= 0x7f;\r\nreturn(val > 0x77 ? 0 : (1500000 - (val * 12500) + 500) / 1000);\r\ndefault:\r\nif (vrm)\r\npr_warn("Requested unsupported VRM version (%u)\n",\r\n(unsigned int)vrm);\r\nreturn 0;\r\n}\r\n}\r\nstatic u8 get_via_model_d_vrm(void)\r\n{\r\nunsigned int vid, brand, dummy;\r\nstatic const char *brands[4] = {\r\n"C7-M", "C7", "Eden", "C7-D"\r\n};\r\nrdmsr(0x198, dummy, vid);\r\nvid &= 0xff;\r\nrdmsr(0x1154, brand, dummy);\r\nbrand = ((brand >> 4) ^ (brand >> 2)) & 0x03;\r\nif (vid > 0x3f) {\r\npr_info("Using %d-bit VID table for VIA %s CPU\n",\r\n7, brands[brand]);\r\nreturn 14;\r\n} else {\r\npr_info("Using %d-bit VID table for VIA %s CPU\n",\r\n6, brands[brand]);\r\nreturn brand == 2 ? 131 : 13;\r\n}\r\n}\r\nstatic u8 find_vrm(u8 eff_family, u8 eff_model, u8 eff_stepping, u8 vendor)\r\n{\r\nint i = 0;\r\nwhile (vrm_models[i].vendor!=X86_VENDOR_UNKNOWN) {\r\nif (vrm_models[i].vendor==vendor)\r\nif ((vrm_models[i].eff_family==eff_family)\r\n&& ((vrm_models[i].eff_model==eff_model) ||\r\n(vrm_models[i].eff_model >= 0x10 &&\r\neff_model <= vrm_models[i].eff_model) ||\r\n(vrm_models[i].eff_model==ANY)) &&\r\n(eff_stepping <= vrm_models[i].eff_stepping))\r\nreturn vrm_models[i].vrm_type;\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nu8 vid_which_vrm(void)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(0);\r\nu32 eax;\r\nu8 eff_family, eff_model, eff_stepping, vrm_ret;\r\nif (c->x86 < 6)\r\nreturn 0;\r\neax = cpuid_eax(1);\r\neff_family = ((eax & 0x00000F00)>>8);\r\neff_model = ((eax & 0x000000F0)>>4);\r\neff_stepping = eax & 0xF;\r\nif (eff_family == 0xF) {\r\neff_family += ((eax & 0x00F00000)>>20);\r\neff_model += ((eax & 0x000F0000)>>16)<<4;\r\n}\r\nvrm_ret = find_vrm(eff_family, eff_model, eff_stepping, c->x86_vendor);\r\nif (vrm_ret == 134)\r\nvrm_ret = get_via_model_d_vrm();\r\nif (vrm_ret == 0)\r\npr_info("Unknown VRM version of your x86 CPU\n");\r\nreturn vrm_ret;\r\n}\r\nu8 vid_which_vrm(void)\r\n{\r\npr_info("Unknown VRM version of your CPU\n");\r\nreturn 0;\r\n}
