static void\r\nlpfc_ct_ignore_hbq_buffer(struct lpfc_hba *phba, struct lpfc_iocbq *piocbq,\r\nstruct lpfc_dmabuf *mp, uint32_t size)\r\n{\r\nif (!mp) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_ELS,\r\n"0146 Ignoring unsolicited CT No HBQ "\r\n"status = x%x\n",\r\npiocbq->iocb.ulpStatus);\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_ELS,\r\n"0145 Ignoring unsolicted CT HBQ Size:%d "\r\n"status = x%x\n",\r\nsize, piocbq->iocb.ulpStatus);\r\n}\r\nstatic void\r\nlpfc_ct_unsol_buffer(struct lpfc_hba *phba, struct lpfc_iocbq *piocbq,\r\nstruct lpfc_dmabuf *mp, uint32_t size)\r\n{\r\nlpfc_ct_ignore_hbq_buffer(phba, piocbq, mp, size);\r\n}\r\nvoid\r\nlpfc_ct_unsol_event(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,\r\nstruct lpfc_iocbq *piocbq)\r\n{\r\nstruct lpfc_dmabuf *mp = NULL;\r\nIOCB_t *icmd = &piocbq->iocb;\r\nint i;\r\nstruct lpfc_iocbq *iocbq;\r\ndma_addr_t paddr;\r\nuint32_t size;\r\nstruct list_head head;\r\nstruct lpfc_dmabuf *bdeBuf;\r\nif (lpfc_bsg_ct_unsol_event(phba, pring, piocbq) == 0)\r\nreturn;\r\nif (unlikely(icmd->ulpStatus == IOSTAT_NEED_BUFFER)) {\r\nlpfc_sli_hbqbuf_add_hbqs(phba, LPFC_ELS_HBQ);\r\n} else if ((icmd->ulpStatus == IOSTAT_LOCAL_REJECT) &&\r\n((icmd->un.ulpWord[4] & 0xff) == IOERR_RCV_BUFFER_WAITING)) {\r\nphba->fc_stat.NoRcvBuf++;\r\nif (!(phba->sli3_options & LPFC_SLI3_HBQ_ENABLED))\r\nlpfc_post_buffer(phba, pring, 2);\r\nreturn;\r\n}\r\nif (icmd->ulpBdeCount == 0)\r\nreturn;\r\nif (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) {\r\nINIT_LIST_HEAD(&head);\r\nlist_add_tail(&head, &piocbq->list);\r\nlist_for_each_entry(iocbq, &head, list) {\r\nicmd = &iocbq->iocb;\r\nif (icmd->ulpBdeCount == 0)\r\ncontinue;\r\nbdeBuf = iocbq->context2;\r\niocbq->context2 = NULL;\r\nsize = icmd->un.cont64[0].tus.f.bdeSize;\r\nlpfc_ct_unsol_buffer(phba, piocbq, bdeBuf, size);\r\nlpfc_in_buf_free(phba, bdeBuf);\r\nif (icmd->ulpBdeCount == 2) {\r\nbdeBuf = iocbq->context3;\r\niocbq->context3 = NULL;\r\nsize = icmd->unsli3.rcvsli3.bde2.tus.f.bdeSize;\r\nlpfc_ct_unsol_buffer(phba, piocbq, bdeBuf,\r\nsize);\r\nlpfc_in_buf_free(phba, bdeBuf);\r\n}\r\n}\r\nlist_del(&head);\r\n} else {\r\nINIT_LIST_HEAD(&head);\r\nlist_add_tail(&head, &piocbq->list);\r\nlist_for_each_entry(iocbq, &head, list) {\r\nicmd = &iocbq->iocb;\r\nif (icmd->ulpBdeCount == 0)\r\nlpfc_ct_unsol_buffer(phba, iocbq, NULL, 0);\r\nfor (i = 0; i < icmd->ulpBdeCount; i++) {\r\npaddr = getPaddr(icmd->un.cont64[i].addrHigh,\r\nicmd->un.cont64[i].addrLow);\r\nmp = lpfc_sli_ringpostbuf_get(phba, pring,\r\npaddr);\r\nsize = icmd->un.cont64[i].tus.f.bdeSize;\r\nlpfc_ct_unsol_buffer(phba, iocbq, mp, size);\r\nlpfc_in_buf_free(phba, mp);\r\n}\r\nlpfc_post_buffer(phba, pring, i);\r\n}\r\nlist_del(&head);\r\n}\r\n}\r\nvoid\r\nlpfc_sli4_ct_abort_unsol_event(struct lpfc_hba *phba,\r\nstruct lpfc_sli_ring *pring,\r\nstruct lpfc_iocbq *piocbq)\r\n{\r\nIOCB_t *icmd = &piocbq->iocb;\r\nstruct lpfc_dmabuf *bdeBuf;\r\nuint32_t size;\r\nif (lpfc_bsg_ct_unsol_event(phba, pring, piocbq) == 0)\r\nreturn;\r\nif (icmd->ulpBdeCount == 0)\r\nreturn;\r\nbdeBuf = piocbq->context2;\r\npiocbq->context2 = NULL;\r\nsize = icmd->un.cont64[0].tus.f.bdeSize;\r\nlpfc_ct_unsol_buffer(phba, piocbq, bdeBuf, size);\r\nlpfc_in_buf_free(phba, bdeBuf);\r\n}\r\nstatic void\r\nlpfc_free_ct_rsp(struct lpfc_hba *phba, struct lpfc_dmabuf *mlist)\r\n{\r\nstruct lpfc_dmabuf *mlast, *next_mlast;\r\nlist_for_each_entry_safe(mlast, next_mlast, &mlist->list, list) {\r\nlpfc_mbuf_free(phba, mlast->virt, mlast->phys);\r\nlist_del(&mlast->list);\r\nkfree(mlast);\r\n}\r\nlpfc_mbuf_free(phba, mlist->virt, mlist->phys);\r\nkfree(mlist);\r\nreturn;\r\n}\r\nstatic struct lpfc_dmabuf *\r\nlpfc_alloc_ct_rsp(struct lpfc_hba *phba, int cmdcode, struct ulp_bde64 *bpl,\r\nuint32_t size, int *entries)\r\n{\r\nstruct lpfc_dmabuf *mlist = NULL;\r\nstruct lpfc_dmabuf *mp;\r\nint cnt, i = 0;\r\ncnt = size > FCELSSIZE ? FCELSSIZE: size;\r\nwhile (size) {\r\nmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!mp) {\r\nif (mlist)\r\nlpfc_free_ct_rsp(phba, mlist);\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&mp->list);\r\nif (cmdcode == be16_to_cpu(SLI_CTNS_GID_FT) ||\r\ncmdcode == be16_to_cpu(SLI_CTNS_GFF_ID))\r\nmp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &(mp->phys));\r\nelse\r\nmp->virt = lpfc_mbuf_alloc(phba, 0, &(mp->phys));\r\nif (!mp->virt) {\r\nkfree(mp);\r\nif (mlist)\r\nlpfc_free_ct_rsp(phba, mlist);\r\nreturn NULL;\r\n}\r\nif (!mlist)\r\nmlist = mp;\r\nelse\r\nlist_add_tail(&mp->list, &mlist->list);\r\nbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64I;\r\nbpl->addrLow = le32_to_cpu(putPaddrLow(mp->phys) );\r\nbpl->addrHigh = le32_to_cpu(putPaddrHigh(mp->phys) );\r\nbpl->tus.f.bdeSize = (uint16_t) cnt;\r\nbpl->tus.w = le32_to_cpu(bpl->tus.w);\r\nbpl++;\r\ni++;\r\nsize -= cnt;\r\n}\r\n*entries = i;\r\nreturn mlist;\r\n}\r\nint\r\nlpfc_ct_free_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *ctiocb)\r\n{\r\nstruct lpfc_dmabuf *buf_ptr;\r\nif (ctiocb->context_un.ndlp) {\r\nlpfc_nlp_put(ctiocb->context_un.ndlp);\r\nctiocb->context_un.ndlp = NULL;\r\n}\r\nif (ctiocb->context1) {\r\nbuf_ptr = (struct lpfc_dmabuf *) ctiocb->context1;\r\nlpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);\r\nkfree(buf_ptr);\r\nctiocb->context1 = NULL;\r\n}\r\nif (ctiocb->context2) {\r\nlpfc_free_ct_rsp(phba, (struct lpfc_dmabuf *) ctiocb->context2);\r\nctiocb->context2 = NULL;\r\n}\r\nif (ctiocb->context3) {\r\nbuf_ptr = (struct lpfc_dmabuf *) ctiocb->context3;\r\nlpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);\r\nkfree(buf_ptr);\r\nctiocb->context1 = NULL;\r\n}\r\nlpfc_sli_release_iocbq(phba, ctiocb);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_gen_req(struct lpfc_vport *vport, struct lpfc_dmabuf *bmp,\r\nstruct lpfc_dmabuf *inp, struct lpfc_dmabuf *outp,\r\nvoid (*cmpl) (struct lpfc_hba *, struct lpfc_iocbq *,\r\nstruct lpfc_iocbq *),\r\nstruct lpfc_nodelist *ndlp, uint32_t usr_flg, uint32_t num_entry,\r\nuint32_t tmo, uint8_t retry)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nIOCB_t *icmd;\r\nstruct lpfc_iocbq *geniocb;\r\nint rc;\r\ngeniocb = lpfc_sli_get_iocbq(phba);\r\nif (geniocb == NULL)\r\nreturn 1;\r\nicmd = &geniocb->iocb;\r\nicmd->un.genreq64.bdl.ulpIoTag32 = 0;\r\nicmd->un.genreq64.bdl.addrHigh = putPaddrHigh(bmp->phys);\r\nicmd->un.genreq64.bdl.addrLow = putPaddrLow(bmp->phys);\r\nicmd->un.genreq64.bdl.bdeFlags = BUFF_TYPE_BLP_64;\r\nicmd->un.genreq64.bdl.bdeSize = (num_entry * sizeof (struct ulp_bde64));\r\nif (usr_flg)\r\ngeniocb->context3 = NULL;\r\nelse\r\ngeniocb->context3 = (uint8_t *) bmp;\r\ngeniocb->context1 = (uint8_t *) inp;\r\ngeniocb->context2 = (uint8_t *) outp;\r\ngeniocb->context_un.ndlp = lpfc_nlp_get(ndlp);\r\nicmd->ulpCommand = CMD_GEN_REQUEST64_CR;\r\nicmd->un.genreq64.w5.hcsw.Fctl = (SI | LA);\r\nicmd->un.genreq64.w5.hcsw.Dfctl = 0;\r\nicmd->un.genreq64.w5.hcsw.Rctl = FC_RCTL_DD_UNSOL_CTL;\r\nicmd->un.genreq64.w5.hcsw.Type = FC_TYPE_CT;\r\nif (!tmo) {\r\ntmo = (3 * phba->fc_ratov);\r\n}\r\nicmd->ulpTimeout = tmo;\r\nicmd->ulpBdeCount = 1;\r\nicmd->ulpLe = 1;\r\nicmd->ulpClass = CLASS3;\r\nicmd->ulpContext = ndlp->nlp_rpi;\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nicmd->ulpContext = phba->sli4_hba.rpi_ids[ndlp->nlp_rpi];\r\nif (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) {\r\nicmd->ulpCt_h = 0;\r\nicmd->ulpCt_l = 0;\r\n}\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0119 Issue GEN REQ IOCB to NPORT x%x "\r\n"Data: x%x x%x\n",\r\nndlp->nlp_DID, icmd->ulpIoTag,\r\nvport->port_state);\r\ngeniocb->iocb_cmpl = cmpl;\r\ngeniocb->drvrTimeout = icmd->ulpTimeout + LPFC_DRVR_TIMEOUT;\r\ngeniocb->vport = vport;\r\ngeniocb->retry = retry;\r\nrc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, geniocb, 0);\r\nif (rc == IOCB_ERROR) {\r\nlpfc_sli_release_iocbq(phba, geniocb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_ct_cmd(struct lpfc_vport *vport, struct lpfc_dmabuf *inmp,\r\nstruct lpfc_dmabuf *bmp, struct lpfc_nodelist *ndlp,\r\nvoid (*cmpl) (struct lpfc_hba *, struct lpfc_iocbq *,\r\nstruct lpfc_iocbq *),\r\nuint32_t rsp_size, uint8_t retry)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct ulp_bde64 *bpl = (struct ulp_bde64 *) bmp->virt;\r\nstruct lpfc_dmabuf *outmp;\r\nint cnt = 0, status;\r\nint cmdcode = ((struct lpfc_sli_ct_request *) inmp->virt)->\r\nCommandResponse.bits.CmdRsp;\r\nbpl++;\r\noutmp = lpfc_alloc_ct_rsp(phba, cmdcode, bpl, rsp_size, &cnt);\r\nif (!outmp)\r\nreturn -ENOMEM;\r\ncnt += 1;\r\nstatus = lpfc_gen_req(vport, bmp, inmp, outmp, cmpl, ndlp, 0,\r\ncnt, 0, retry);\r\nif (status) {\r\nlpfc_free_ct_rsp(phba, outmp);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstruct lpfc_vport *\r\nlpfc_find_vport_by_did(struct lpfc_hba *phba, uint32_t did) {\r\nstruct lpfc_vport *vport_curr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&phba->hbalock, flags);\r\nlist_for_each_entry(vport_curr, &phba->port_list, listentry) {\r\nif ((vport_curr->fc_myDID) && (vport_curr->fc_myDID == did)) {\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nreturn vport_curr;\r\n}\r\n}\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nreturn NULL;\r\n}\r\nstatic int\r\nlpfc_ns_rsp(struct lpfc_vport *vport, struct lpfc_dmabuf *mp, uint32_t Size)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_sli_ct_request *Response =\r\n(struct lpfc_sli_ct_request *) mp->virt;\r\nstruct lpfc_nodelist *ndlp = NULL;\r\nstruct lpfc_dmabuf *mlast, *next_mp;\r\nuint32_t *ctptr = (uint32_t *) & Response->un.gid.PortType;\r\nuint32_t Did, CTentry;\r\nint Cnt;\r\nstruct list_head head;\r\nlpfc_set_disctmo(vport);\r\nvport->num_disc_nodes = 0;\r\nvport->fc_ns_retry = 0;\r\nlist_add_tail(&head, &mp->list);\r\nlist_for_each_entry_safe(mp, next_mp, &head, list) {\r\nmlast = mp;\r\nCnt = Size > FCELSSIZE ? FCELSSIZE : Size;\r\nSize -= Cnt;\r\nif (!ctptr) {\r\nctptr = (uint32_t *) mlast->virt;\r\n} else\r\nCnt -= 16;\r\nwhile (Cnt >= sizeof (uint32_t)) {\r\nCTentry = *ctptr++;\r\nDid = ((be32_to_cpu(CTentry)) & Mask_DID);\r\nndlp = NULL;\r\nif ((Did != vport->fc_myDID) &&\r\n((lpfc_find_vport_by_did(phba, Did) == NULL) ||\r\nvport->cfg_peer_port_login)) {\r\nif ((vport->port_type != LPFC_NPIV_PORT) ||\r\n(!(vport->ct_flags & FC_CT_RFF_ID)) ||\r\n(!vport->cfg_restrict_login)) {\r\nndlp = lpfc_setup_disc_node(vport, Did);\r\nif (ndlp && NLP_CHK_NODE_ACT(ndlp)) {\r\nlpfc_debugfs_disc_trc(vport,\r\nLPFC_DISC_TRC_CT,\r\n"Parse GID_FTrsp: "\r\n"did:x%x flg:x%x x%x",\r\nDid, ndlp->nlp_flag,\r\nvport->fc_flag);\r\nlpfc_printf_vlog(vport,\r\nKERN_INFO,\r\nLOG_DISCOVERY,\r\n"0238 Process "\r\n"x%x NameServer Rsp"\r\n"Data: x%x x%x x%x\n",\r\nDid, ndlp->nlp_flag,\r\nvport->fc_flag,\r\nvport->fc_rscn_id_cnt);\r\n} else {\r\nlpfc_debugfs_disc_trc(vport,\r\nLPFC_DISC_TRC_CT,\r\n"Skip1 GID_FTrsp: "\r\n"did:x%x flg:x%x cnt:%d",\r\nDid, vport->fc_flag,\r\nvport->fc_rscn_id_cnt);\r\nlpfc_printf_vlog(vport,\r\nKERN_INFO,\r\nLOG_DISCOVERY,\r\n"0239 Skip x%x "\r\n"NameServer Rsp Data: "\r\n"x%x x%x\n",\r\nDid, vport->fc_flag,\r\nvport->fc_rscn_id_cnt);\r\n}\r\n} else {\r\nif (!(vport->fc_flag & FC_RSCN_MODE) ||\r\n(lpfc_rscn_payload_check(vport, Did))) {\r\nlpfc_debugfs_disc_trc(vport,\r\nLPFC_DISC_TRC_CT,\r\n"Query GID_FTrsp: "\r\n"did:x%x flg:x%x cnt:%d",\r\nDid, vport->fc_flag,\r\nvport->fc_rscn_id_cnt);\r\nndlp = lpfc_findnode_did(vport,\r\nDid);\r\nif (ndlp &&\r\nNLP_CHK_NODE_ACT(ndlp)\r\n&& (ndlp->nlp_type &\r\nNLP_FCP_TARGET))\r\nlpfc_setup_disc_node\r\n(vport, Did);\r\nelse if (lpfc_ns_cmd(vport,\r\nSLI_CTNS_GFF_ID,\r\n0, Did) == 0)\r\nvport->num_disc_nodes++;\r\nelse\r\nlpfc_setup_disc_node\r\n(vport, Did);\r\n}\r\nelse {\r\nlpfc_debugfs_disc_trc(vport,\r\nLPFC_DISC_TRC_CT,\r\n"Skip2 GID_FTrsp: "\r\n"did:x%x flg:x%x cnt:%d",\r\nDid, vport->fc_flag,\r\nvport->fc_rscn_id_cnt);\r\nlpfc_printf_vlog(vport,\r\nKERN_INFO,\r\nLOG_DISCOVERY,\r\n"0245 Skip x%x "\r\n"NameServer Rsp Data: "\r\n"x%x x%x\n",\r\nDid, vport->fc_flag,\r\nvport->fc_rscn_id_cnt);\r\n}\r\n}\r\n}\r\nif (CTentry & (be32_to_cpu(SLI_CT_LAST_ENTRY)))\r\ngoto nsout1;\r\nCnt -= sizeof (uint32_t);\r\n}\r\nctptr = NULL;\r\n}\r\nnsout1:\r\nlist_del(&head);\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_gid_ft(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nIOCB_t *irsp;\r\nstruct lpfc_dmabuf *bmp;\r\nstruct lpfc_dmabuf *outp;\r\nstruct lpfc_sli_ct_request *CTrsp;\r\nstruct lpfc_nodelist *ndlp;\r\nint rc;\r\nndlp = cmdiocb->context_un.ndlp;\r\ncmdiocb->context_un.rsp_iocb = rspiocb;\r\noutp = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nbmp = (struct lpfc_dmabuf *) cmdiocb->context3;\r\nirsp = &rspiocb->iocb;\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\r\n"GID_FT cmpl: status:x%x/x%x rtry:%d",\r\nirsp->ulpStatus, irsp->un.ulpWord[4], vport->fc_ns_retry);\r\nif (vport->load_flag & FC_UNLOADING) {\r\nif (vport->fc_flag & FC_RSCN_MODE)\r\nlpfc_els_flush_rscn(vport);\r\ngoto out;\r\n}\r\nif (lpfc_els_chk_latt(vport)) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0216 Link event during NS query\n");\r\nif (vport->fc_flag & FC_RSCN_MODE)\r\nlpfc_els_flush_rscn(vport);\r\nlpfc_vport_set_state(vport, FC_VPORT_FAILED);\r\ngoto out;\r\n}\r\nif (lpfc_error_lost_link(irsp)) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0226 NS query failed due to link event\n");\r\nif (vport->fc_flag & FC_RSCN_MODE)\r\nlpfc_els_flush_rscn(vport);\r\ngoto out;\r\n}\r\nif (irsp->ulpStatus) {\r\nif (vport->fc_ns_retry < LPFC_MAX_NS_RETRY) {\r\nif (irsp->ulpStatus != IOSTAT_LOCAL_REJECT ||\r\nirsp->un.ulpWord[4] != IOERR_NO_RESOURCES)\r\nvport->fc_ns_retry++;\r\nrc = lpfc_ns_cmd(vport, SLI_CTNS_GID_FT,\r\nvport->fc_ns_retry, 0);\r\nif (rc == 0)\r\ngoto out;\r\n}\r\nif (vport->fc_flag & FC_RSCN_MODE)\r\nlpfc_els_flush_rscn(vport);\r\nlpfc_vport_set_state(vport, FC_VPORT_FAILED);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0257 GID_FT Query error: 0x%x 0x%x\n",\r\nirsp->ulpStatus, vport->fc_ns_retry);\r\n} else {\r\nCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\r\nif (CTrsp->CommandResponse.bits.CmdRsp ==\r\nbe16_to_cpu(SLI_CT_RESPONSE_FS_ACC)) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0208 NameServer Rsp Data: x%x\n",\r\nvport->fc_flag);\r\nlpfc_ns_rsp(vport, outp,\r\n(uint32_t) (irsp->un.genreq64.bdl.bdeSize));\r\n} else if (CTrsp->CommandResponse.bits.CmdRsp ==\r\nbe16_to_cpu(SLI_CT_RESPONSE_FS_RJT)) {\r\nif ((CTrsp->ReasonCode == SLI_CT_UNABLE_TO_PERFORM_REQ)\r\n&& (CTrsp->Explanation == SLI_CT_NO_FC4_TYPES)) {\r\nlpfc_printf_vlog(vport, KERN_INFO,\r\nLOG_DISCOVERY,\r\n"0269 No NameServer Entries "\r\n"Data: x%x x%x x%x x%x\n",\r\nCTrsp->CommandResponse.bits.CmdRsp,\r\n(uint32_t) CTrsp->ReasonCode,\r\n(uint32_t) CTrsp->Explanation,\r\nvport->fc_flag);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\r\n"GID_FT no entry cmd:x%x rsn:x%x exp:x%x",\r\n(uint32_t)CTrsp->CommandResponse.bits.CmdRsp,\r\n(uint32_t) CTrsp->ReasonCode,\r\n(uint32_t) CTrsp->Explanation);\r\n} else {\r\nlpfc_printf_vlog(vport, KERN_INFO,\r\nLOG_DISCOVERY,\r\n"0240 NameServer Rsp Error "\r\n"Data: x%x x%x x%x x%x\n",\r\nCTrsp->CommandResponse.bits.CmdRsp,\r\n(uint32_t) CTrsp->ReasonCode,\r\n(uint32_t) CTrsp->Explanation,\r\nvport->fc_flag);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\r\n"GID_FT rsp err1 cmd:x%x rsn:x%x exp:x%x",\r\n(uint32_t)CTrsp->CommandResponse.bits.CmdRsp,\r\n(uint32_t) CTrsp->ReasonCode,\r\n(uint32_t) CTrsp->Explanation);\r\n}\r\n} else {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,\r\n"0241 NameServer Rsp Error "\r\n"Data: x%x x%x x%x x%x\n",\r\nCTrsp->CommandResponse.bits.CmdRsp,\r\n(uint32_t) CTrsp->ReasonCode,\r\n(uint32_t) CTrsp->Explanation,\r\nvport->fc_flag);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\r\n"GID_FT rsp err2 cmd:x%x rsn:x%x exp:x%x",\r\n(uint32_t)CTrsp->CommandResponse.bits.CmdRsp,\r\n(uint32_t) CTrsp->ReasonCode,\r\n(uint32_t) CTrsp->Explanation);\r\n}\r\n}\r\nif (vport->num_disc_nodes == 0) {\r\nif (vport->port_state >= LPFC_DISC_AUTH) {\r\nif (vport->fc_flag & FC_RSCN_MODE) {\r\nlpfc_els_flush_rscn(vport);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_RSCN_MODE;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nelse\r\nlpfc_els_flush_rscn(vport);\r\n}\r\nlpfc_disc_start(vport);\r\n}\r\nout:\r\ncmdiocb->context_un.ndlp = ndlp;\r\nlpfc_ct_free_iocb(phba, cmdiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_gff_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nstruct lpfc_dmabuf *inp = (struct lpfc_dmabuf *) cmdiocb->context1;\r\nstruct lpfc_dmabuf *outp = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nstruct lpfc_sli_ct_request *CTrsp;\r\nint did, rc, retry;\r\nuint8_t fbits;\r\nstruct lpfc_nodelist *ndlp;\r\ndid = ((struct lpfc_sli_ct_request *) inp->virt)->un.gff.PortId;\r\ndid = be32_to_cpu(did);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\r\n"GFF_ID cmpl: status:x%x/x%x did:x%x",\r\nirsp->ulpStatus, irsp->un.ulpWord[4], did);\r\nif (irsp->ulpStatus == IOSTAT_SUCCESS) {\r\nCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\r\nfbits = CTrsp->un.gff_acc.fbits[FCP_TYPE_FEATURE_OFFSET];\r\nif (CTrsp->CommandResponse.bits.CmdRsp ==\r\nbe16_to_cpu(SLI_CT_RESPONSE_FS_ACC)) {\r\nif ((fbits & FC4_FEATURE_INIT) &&\r\n!(fbits & FC4_FEATURE_TARGET)) {\r\nlpfc_printf_vlog(vport, KERN_INFO,\r\nLOG_DISCOVERY,\r\n"0270 Skip x%x GFF "\r\n"NameServer Rsp Data: (init) "\r\n"x%x x%x\n", did, fbits,\r\nvport->fc_rscn_id_cnt);\r\ngoto out;\r\n}\r\n}\r\n}\r\nelse {\r\nif (cmdiocb->retry < LPFC_MAX_NS_RETRY) {\r\nretry = 1;\r\nif (irsp->ulpStatus == IOSTAT_LOCAL_REJECT) {\r\nswitch (irsp->un.ulpWord[4]) {\r\ncase IOERR_NO_RESOURCES:\r\nbreak;\r\ncase IOERR_LINK_DOWN:\r\ncase IOERR_SLI_ABORTED:\r\ncase IOERR_SLI_DOWN:\r\nretry = 0;\r\nbreak;\r\ndefault:\r\ncmdiocb->retry++;\r\n}\r\n}\r\nelse\r\ncmdiocb->retry++;\r\nif (retry) {\r\nrc = lpfc_ns_cmd(vport, SLI_CTNS_GFF_ID,\r\ncmdiocb->retry, did);\r\nif (rc == 0) {\r\nlpfc_ct_free_iocb(phba, cmdiocb);\r\nreturn;\r\n}\r\n}\r\n}\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,\r\n"0267 NameServer GFF Rsp "\r\n"x%x Error (%d %d) Data: x%x x%x\n",\r\ndid, irsp->ulpStatus, irsp->un.ulpWord[4],\r\nvport->fc_flag, vport->fc_rscn_id_cnt);\r\n}\r\nndlp = lpfc_setup_disc_node(vport, did);\r\nif (ndlp && NLP_CHK_NODE_ACT(ndlp)) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0242 Process x%x GFF "\r\n"NameServer Rsp Data: x%x x%x x%x\n",\r\ndid, ndlp->nlp_flag, vport->fc_flag,\r\nvport->fc_rscn_id_cnt);\r\n} else {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0243 Skip x%x GFF "\r\n"NameServer Rsp Data: x%x x%x\n", did,\r\nvport->fc_flag, vport->fc_rscn_id_cnt);\r\n}\r\nout:\r\nif (vport->num_disc_nodes)\r\nvport->num_disc_nodes--;\r\nif (vport->num_disc_nodes == 0) {\r\nif (vport->port_state >= LPFC_DISC_AUTH) {\r\nif (vport->fc_flag & FC_RSCN_MODE) {\r\nlpfc_els_flush_rscn(vport);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_RSCN_MODE;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nelse\r\nlpfc_els_flush_rscn(vport);\r\n}\r\nlpfc_disc_start(vport);\r\n}\r\nlpfc_ct_free_iocb(phba, cmdiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nstruct lpfc_dmabuf *inp;\r\nstruct lpfc_dmabuf *outp;\r\nIOCB_t *irsp;\r\nstruct lpfc_sli_ct_request *CTrsp;\r\nstruct lpfc_nodelist *ndlp;\r\nint cmdcode, rc;\r\nuint8_t retry;\r\nuint32_t latt;\r\nndlp = cmdiocb->context_un.ndlp;\r\ncmdiocb->context_un.rsp_iocb = rspiocb;\r\ninp = (struct lpfc_dmabuf *) cmdiocb->context1;\r\noutp = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nirsp = &rspiocb->iocb;\r\ncmdcode = be16_to_cpu(((struct lpfc_sli_ct_request *) inp->virt)->\r\nCommandResponse.bits.CmdRsp);\r\nCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\r\nlatt = lpfc_els_chk_latt(vport);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0209 CT Request completes, latt %d, "\r\n"ulpStatus x%x CmdRsp x%x, Context x%x, Tag x%x\n",\r\nlatt, irsp->ulpStatus,\r\nCTrsp->CommandResponse.bits.CmdRsp,\r\ncmdiocb->iocb.ulpContext, cmdiocb->iocb.ulpIoTag);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\r\n"CT cmd cmpl: status:x%x/x%x cmd:x%x",\r\nirsp->ulpStatus, irsp->un.ulpWord[4], cmdcode);\r\nif (irsp->ulpStatus) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,\r\n"0268 NS cmd %x Error (%d %d)\n",\r\ncmdcode, irsp->ulpStatus, irsp->un.ulpWord[4]);\r\nif ((irsp->ulpStatus == IOSTAT_LOCAL_REJECT) &&\r\n((irsp->un.ulpWord[4] == IOERR_SLI_DOWN) ||\r\n(irsp->un.ulpWord[4] == IOERR_SLI_ABORTED)))\r\ngoto out;\r\nretry = cmdiocb->retry;\r\nif (retry >= LPFC_MAX_NS_RETRY)\r\ngoto out;\r\nretry++;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0250 Retrying NS cmd %x\n", cmdcode);\r\nrc = lpfc_ns_cmd(vport, cmdcode, retry, 0);\r\nif (rc == 0)\r\ngoto out;\r\n}\r\nout:\r\ncmdiocb->context_un.ndlp = ndlp;\r\nlpfc_ct_free_iocb(phba, cmdiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_rft_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nif (irsp->ulpStatus == IOSTAT_SUCCESS) {\r\nstruct lpfc_dmabuf *outp;\r\nstruct lpfc_sli_ct_request *CTrsp;\r\noutp = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\r\nif (CTrsp->CommandResponse.bits.CmdRsp ==\r\nbe16_to_cpu(SLI_CT_RESPONSE_FS_ACC))\r\nvport->ct_flags |= FC_CT_RFT_ID;\r\n}\r\nlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_rnn_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nif (irsp->ulpStatus == IOSTAT_SUCCESS) {\r\nstruct lpfc_dmabuf *outp;\r\nstruct lpfc_sli_ct_request *CTrsp;\r\noutp = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\r\nif (CTrsp->CommandResponse.bits.CmdRsp ==\r\nbe16_to_cpu(SLI_CT_RESPONSE_FS_ACC))\r\nvport->ct_flags |= FC_CT_RNN_ID;\r\n}\r\nlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_rspn_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nif (irsp->ulpStatus == IOSTAT_SUCCESS) {\r\nstruct lpfc_dmabuf *outp;\r\nstruct lpfc_sli_ct_request *CTrsp;\r\noutp = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\r\nif (CTrsp->CommandResponse.bits.CmdRsp ==\r\nbe16_to_cpu(SLI_CT_RESPONSE_FS_ACC))\r\nvport->ct_flags |= FC_CT_RSPN_ID;\r\n}\r\nlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_rsnn_nn(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nif (irsp->ulpStatus == IOSTAT_SUCCESS) {\r\nstruct lpfc_dmabuf *outp;\r\nstruct lpfc_sli_ct_request *CTrsp;\r\noutp = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\r\nif (CTrsp->CommandResponse.bits.CmdRsp ==\r\nbe16_to_cpu(SLI_CT_RESPONSE_FS_ACC))\r\nvport->ct_flags |= FC_CT_RSNN_NN;\r\n}\r\nlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_da_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nvport->ct_flags = 0;\r\nlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_rff_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nif (irsp->ulpStatus == IOSTAT_SUCCESS) {\r\nstruct lpfc_dmabuf *outp;\r\nstruct lpfc_sli_ct_request *CTrsp;\r\noutp = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\r\nif (CTrsp->CommandResponse.bits.CmdRsp ==\r\nbe16_to_cpu(SLI_CT_RESPONSE_FS_ACC))\r\nvport->ct_flags |= FC_CT_RFF_ID;\r\n}\r\nlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\r\nreturn;\r\n}\r\nint\r\nlpfc_vport_symbolic_port_name(struct lpfc_vport *vport, char *symbol,\r\nsize_t size)\r\n{\r\nint n;\r\nuint8_t *wwn = vport->phba->wwpn;\r\nn = snprintf(symbol, size,\r\n"Emulex PPN-%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",\r\nwwn[0], wwn[1], wwn[2], wwn[3],\r\nwwn[4], wwn[5], wwn[6], wwn[7]);\r\nif (vport->port_type == LPFC_PHYSICAL_PORT)\r\nreturn n;\r\nif (n < size)\r\nn += snprintf(symbol + n, size - n, " VPort-%d", vport->vpi);\r\nif (n < size &&\r\nstrlen(vport->fc_vport->symbolic_name))\r\nn += snprintf(symbol + n, size - n, " VName-%s",\r\nvport->fc_vport->symbolic_name);\r\nreturn n;\r\n}\r\nint\r\nlpfc_vport_symbolic_node_name(struct lpfc_vport *vport, char *symbol,\r\nsize_t size)\r\n{\r\nchar fwrev[16];\r\nint n;\r\nlpfc_decode_firmware_rev(vport->phba, fwrev, 0);\r\nn = snprintf(symbol, size, "Emulex %s FV%s DV%s",\r\nvport->phba->ModelName, fwrev, lpfc_release_version);\r\nreturn n;\r\n}\r\nint\r\nlpfc_ns_cmd(struct lpfc_vport *vport, int cmdcode,\r\nuint8_t retry, uint32_t context)\r\n{\r\nstruct lpfc_nodelist * ndlp;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_dmabuf *mp, *bmp;\r\nstruct lpfc_sli_ct_request *CtReq;\r\nstruct ulp_bde64 *bpl;\r\nvoid (*cmpl) (struct lpfc_hba *, struct lpfc_iocbq *,\r\nstruct lpfc_iocbq *) = NULL;\r\nuint32_t rsp_size = 1024;\r\nsize_t size;\r\nint rc = 0;\r\nndlp = lpfc_findnode_did(vport, NameServer_DID);\r\nif (!ndlp || !NLP_CHK_NODE_ACT(ndlp)\r\n|| ndlp->nlp_state != NLP_STE_UNMAPPED_NODE) {\r\nrc=1;\r\ngoto ns_cmd_exit;\r\n}\r\nmp = kmalloc(sizeof (struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!mp) {\r\nrc=2;\r\ngoto ns_cmd_exit;\r\n}\r\nINIT_LIST_HEAD(&mp->list);\r\nmp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &(mp->phys));\r\nif (!mp->virt) {\r\nrc=3;\r\ngoto ns_cmd_free_mp;\r\n}\r\nbmp = kmalloc(sizeof (struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!bmp) {\r\nrc=4;\r\ngoto ns_cmd_free_mpvirt;\r\n}\r\nINIT_LIST_HEAD(&bmp->list);\r\nbmp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &(bmp->phys));\r\nif (!bmp->virt) {\r\nrc=5;\r\ngoto ns_cmd_free_bmp;\r\n}\r\nlpfc_printf_vlog(vport, KERN_INFO ,LOG_DISCOVERY,\r\n"0236 NameServer Req Data: x%x x%x x%x\n",\r\ncmdcode, vport->fc_flag, vport->fc_rscn_id_cnt);\r\nbpl = (struct ulp_bde64 *) bmp->virt;\r\nmemset(bpl, 0, sizeof(struct ulp_bde64));\r\nbpl->addrHigh = le32_to_cpu(putPaddrHigh(mp->phys) );\r\nbpl->addrLow = le32_to_cpu(putPaddrLow(mp->phys) );\r\nbpl->tus.f.bdeFlags = 0;\r\nif (cmdcode == SLI_CTNS_GID_FT)\r\nbpl->tus.f.bdeSize = GID_REQUEST_SZ;\r\nelse if (cmdcode == SLI_CTNS_GFF_ID)\r\nbpl->tus.f.bdeSize = GFF_REQUEST_SZ;\r\nelse if (cmdcode == SLI_CTNS_RFT_ID)\r\nbpl->tus.f.bdeSize = RFT_REQUEST_SZ;\r\nelse if (cmdcode == SLI_CTNS_RNN_ID)\r\nbpl->tus.f.bdeSize = RNN_REQUEST_SZ;\r\nelse if (cmdcode == SLI_CTNS_RSPN_ID)\r\nbpl->tus.f.bdeSize = RSPN_REQUEST_SZ;\r\nelse if (cmdcode == SLI_CTNS_RSNN_NN)\r\nbpl->tus.f.bdeSize = RSNN_REQUEST_SZ;\r\nelse if (cmdcode == SLI_CTNS_DA_ID)\r\nbpl->tus.f.bdeSize = DA_ID_REQUEST_SZ;\r\nelse if (cmdcode == SLI_CTNS_RFF_ID)\r\nbpl->tus.f.bdeSize = RFF_REQUEST_SZ;\r\nelse\r\nbpl->tus.f.bdeSize = 0;\r\nbpl->tus.w = le32_to_cpu(bpl->tus.w);\r\nCtReq = (struct lpfc_sli_ct_request *) mp->virt;\r\nmemset(CtReq, 0, sizeof (struct lpfc_sli_ct_request));\r\nCtReq->RevisionId.bits.Revision = SLI_CT_REVISION;\r\nCtReq->RevisionId.bits.InId = 0;\r\nCtReq->FsType = SLI_CT_DIRECTORY_SERVICE;\r\nCtReq->FsSubType = SLI_CT_DIRECTORY_NAME_SERVER;\r\nCtReq->CommandResponse.bits.Size = 0;\r\nswitch (cmdcode) {\r\ncase SLI_CTNS_GID_FT:\r\nCtReq->CommandResponse.bits.CmdRsp =\r\nbe16_to_cpu(SLI_CTNS_GID_FT);\r\nCtReq->un.gid.Fc4Type = SLI_CTPT_FCP;\r\nif (vport->port_state < LPFC_NS_QRY)\r\nvport->port_state = LPFC_NS_QRY;\r\nlpfc_set_disctmo(vport);\r\ncmpl = lpfc_cmpl_ct_cmd_gid_ft;\r\nrsp_size = FC_MAX_NS_RSP;\r\nbreak;\r\ncase SLI_CTNS_GFF_ID:\r\nCtReq->CommandResponse.bits.CmdRsp =\r\nbe16_to_cpu(SLI_CTNS_GFF_ID);\r\nCtReq->un.gff.PortId = cpu_to_be32(context);\r\ncmpl = lpfc_cmpl_ct_cmd_gff_id;\r\nbreak;\r\ncase SLI_CTNS_RFT_ID:\r\nvport->ct_flags &= ~FC_CT_RFT_ID;\r\nCtReq->CommandResponse.bits.CmdRsp =\r\nbe16_to_cpu(SLI_CTNS_RFT_ID);\r\nCtReq->un.rft.PortId = cpu_to_be32(vport->fc_myDID);\r\nCtReq->un.rft.fcpReg = 1;\r\ncmpl = lpfc_cmpl_ct_cmd_rft_id;\r\nbreak;\r\ncase SLI_CTNS_RNN_ID:\r\nvport->ct_flags &= ~FC_CT_RNN_ID;\r\nCtReq->CommandResponse.bits.CmdRsp =\r\nbe16_to_cpu(SLI_CTNS_RNN_ID);\r\nCtReq->un.rnn.PortId = cpu_to_be32(vport->fc_myDID);\r\nmemcpy(CtReq->un.rnn.wwnn, &vport->fc_nodename,\r\nsizeof (struct lpfc_name));\r\ncmpl = lpfc_cmpl_ct_cmd_rnn_id;\r\nbreak;\r\ncase SLI_CTNS_RSPN_ID:\r\nvport->ct_flags &= ~FC_CT_RSPN_ID;\r\nCtReq->CommandResponse.bits.CmdRsp =\r\nbe16_to_cpu(SLI_CTNS_RSPN_ID);\r\nCtReq->un.rspn.PortId = cpu_to_be32(vport->fc_myDID);\r\nsize = sizeof(CtReq->un.rspn.symbname);\r\nCtReq->un.rspn.len =\r\nlpfc_vport_symbolic_port_name(vport,\r\nCtReq->un.rspn.symbname, size);\r\ncmpl = lpfc_cmpl_ct_cmd_rspn_id;\r\nbreak;\r\ncase SLI_CTNS_RSNN_NN:\r\nvport->ct_flags &= ~FC_CT_RSNN_NN;\r\nCtReq->CommandResponse.bits.CmdRsp =\r\nbe16_to_cpu(SLI_CTNS_RSNN_NN);\r\nmemcpy(CtReq->un.rsnn.wwnn, &vport->fc_nodename,\r\nsizeof (struct lpfc_name));\r\nsize = sizeof(CtReq->un.rsnn.symbname);\r\nCtReq->un.rsnn.len =\r\nlpfc_vport_symbolic_node_name(vport,\r\nCtReq->un.rsnn.symbname, size);\r\ncmpl = lpfc_cmpl_ct_cmd_rsnn_nn;\r\nbreak;\r\ncase SLI_CTNS_DA_ID:\r\nCtReq->CommandResponse.bits.CmdRsp =\r\nbe16_to_cpu(SLI_CTNS_DA_ID);\r\nCtReq->un.da_id.port_id = cpu_to_be32(vport->fc_myDID);\r\ncmpl = lpfc_cmpl_ct_cmd_da_id;\r\nbreak;\r\ncase SLI_CTNS_RFF_ID:\r\nvport->ct_flags &= ~FC_CT_RFF_ID;\r\nCtReq->CommandResponse.bits.CmdRsp =\r\nbe16_to_cpu(SLI_CTNS_RFF_ID);\r\nCtReq->un.rff.PortId = cpu_to_be32(vport->fc_myDID);\r\nCtReq->un.rff.fbits = FC4_FEATURE_INIT;\r\nCtReq->un.rff.type_code = FC_TYPE_FCP;\r\ncmpl = lpfc_cmpl_ct_cmd_rff_id;\r\nbreak;\r\n}\r\nif (!lpfc_ct_cmd(vport, mp, bmp, ndlp, cmpl, rsp_size, retry)) {\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\r\n"Issue CT cmd: cmd:x%x did:x%x",\r\ncmdcode, ndlp->nlp_DID, 0);\r\nreturn 0;\r\n}\r\nrc=6;\r\nlpfc_nlp_put(ndlp);\r\nlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\r\nns_cmd_free_bmp:\r\nkfree(bmp);\r\nns_cmd_free_mpvirt:\r\nlpfc_mbuf_free(phba, mp->virt, mp->phys);\r\nns_cmd_free_mp:\r\nkfree(mp);\r\nns_cmd_exit:\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,\r\n"0266 Issue NameServer Req x%x err %d Data: x%x x%x\n",\r\ncmdcode, rc, vport->fc_flag, vport->fc_rscn_id_cnt);\r\nreturn 1;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_fdmi(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq * rspiocb)\r\n{\r\nstruct lpfc_dmabuf *inp = cmdiocb->context1;\r\nstruct lpfc_dmabuf *outp = cmdiocb->context2;\r\nstruct lpfc_sli_ct_request *CTrsp = outp->virt;\r\nstruct lpfc_sli_ct_request *CTcmd = inp->virt;\r\nstruct lpfc_nodelist *ndlp;\r\nuint16_t fdmi_cmd = CTcmd->CommandResponse.bits.CmdRsp;\r\nuint16_t fdmi_rsp = CTrsp->CommandResponse.bits.CmdRsp;\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nuint32_t latt;\r\nlatt = lpfc_els_chk_latt(vport);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\r\n"FDMI cmpl: status:x%x/x%x latt:%d",\r\nirsp->ulpStatus, irsp->un.ulpWord[4], latt);\r\nif (latt || irsp->ulpStatus) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0229 FDMI cmd %04x failed, latt = %d "\r\n"ulpStatus: x%x, rid x%x\n",\r\nbe16_to_cpu(fdmi_cmd), latt, irsp->ulpStatus,\r\nirsp->un.ulpWord[4]);\r\nlpfc_ct_free_iocb(phba, cmdiocb);\r\nreturn;\r\n}\r\nndlp = lpfc_findnode_did(vport, FDMI_DID);\r\nif (!ndlp || !NLP_CHK_NODE_ACT(ndlp))\r\ngoto fail_out;\r\nif (fdmi_rsp == be16_to_cpu(SLI_CT_RESPONSE_FS_RJT)) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0220 FDMI rsp failed Data: x%x\n",\r\nbe16_to_cpu(fdmi_cmd));\r\n}\r\nswitch (be16_to_cpu(fdmi_cmd)) {\r\ncase SLI_MGMT_RHBA:\r\nlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_RPA);\r\nbreak;\r\ncase SLI_MGMT_RPA:\r\nbreak;\r\ncase SLI_MGMT_DHBA:\r\nlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_DPRT);\r\nbreak;\r\ncase SLI_MGMT_DPRT:\r\nlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_RHBA);\r\nbreak;\r\n}\r\nfail_out:\r\nlpfc_ct_free_iocb(phba, cmdiocb);\r\nreturn;\r\n}\r\nint\r\nlpfc_fdmi_cmd(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp, int cmdcode)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_dmabuf *mp, *bmp;\r\nstruct lpfc_sli_ct_request *CtReq;\r\nstruct ulp_bde64 *bpl;\r\nuint32_t size;\r\nREG_HBA *rh;\r\nPORT_ENTRY *pe;\r\nREG_PORT_ATTRIBUTE *pab;\r\nATTRIBUTE_BLOCK *ab;\r\nATTRIBUTE_ENTRY *ae;\r\nvoid (*cmpl) (struct lpfc_hba *, struct lpfc_iocbq *,\r\nstruct lpfc_iocbq *);\r\nmp = kmalloc(sizeof (struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!mp)\r\ngoto fdmi_cmd_exit;\r\nmp->virt = lpfc_mbuf_alloc(phba, 0, &(mp->phys));\r\nif (!mp->virt)\r\ngoto fdmi_cmd_free_mp;\r\nbmp = kmalloc(sizeof (struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!bmp)\r\ngoto fdmi_cmd_free_mpvirt;\r\nbmp->virt = lpfc_mbuf_alloc(phba, 0, &(bmp->phys));\r\nif (!bmp->virt)\r\ngoto fdmi_cmd_free_bmp;\r\nINIT_LIST_HEAD(&mp->list);\r\nINIT_LIST_HEAD(&bmp->list);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0218 FDMI Request Data: x%x x%x x%x\n",\r\nvport->fc_flag, vport->port_state, cmdcode);\r\nCtReq = (struct lpfc_sli_ct_request *) mp->virt;\r\nmemset(CtReq, 0, sizeof(struct lpfc_sli_ct_request));\r\nCtReq->RevisionId.bits.Revision = SLI_CT_REVISION;\r\nCtReq->RevisionId.bits.InId = 0;\r\nCtReq->FsType = SLI_CT_MANAGEMENT_SERVICE;\r\nCtReq->FsSubType = SLI_CT_FDMI_Subtypes;\r\nsize = 0;\r\nswitch (cmdcode) {\r\ncase SLI_MGMT_RHBA:\r\n{\r\nlpfc_vpd_t *vp = &phba->vpd;\r\nuint32_t i, j, incr;\r\nint len;\r\nCtReq->CommandResponse.bits.CmdRsp =\r\nbe16_to_cpu(SLI_MGMT_RHBA);\r\nCtReq->CommandResponse.bits.Size = 0;\r\nrh = (REG_HBA *) & CtReq->un.PortID;\r\nmemcpy(&rh->hi.PortName, &vport->fc_sparam.portName,\r\nsizeof (struct lpfc_name));\r\nrh->rpl.EntryCnt = be32_to_cpu(1);\r\nmemcpy(&rh->rpl.pe, &vport->fc_sparam.portName,\r\nsizeof (struct lpfc_name));\r\nsize = 2 * sizeof (struct lpfc_name) + FOURBYTES;\r\nab = (ATTRIBUTE_BLOCK *) ((uint8_t *) rh + size);\r\nab->EntryCnt = 0;\r\nsize += FOURBYTES;\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);\r\nae->ad.bits.AttrType = be16_to_cpu(NODE_NAME);\r\nae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES\r\n+ sizeof (struct lpfc_name));\r\nmemcpy(&ae->un.NodeName, &vport->fc_sparam.nodeName,\r\nsizeof (struct lpfc_name));\r\nab->EntryCnt++;\r\nsize += FOURBYTES + sizeof (struct lpfc_name);\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);\r\nae->ad.bits.AttrType = be16_to_cpu(MANUFACTURER);\r\nstrcpy(ae->un.Manufacturer, "Emulex Corporation");\r\nlen = strlen(ae->un.Manufacturer);\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);\r\nab->EntryCnt++;\r\nsize += FOURBYTES + len;\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);\r\nae->ad.bits.AttrType = be16_to_cpu(SERIAL_NUMBER);\r\nstrcpy(ae->un.SerialNumber, phba->SerialNumber);\r\nlen = strlen(ae->un.SerialNumber);\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);\r\nab->EntryCnt++;\r\nsize += FOURBYTES + len;\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);\r\nae->ad.bits.AttrType = be16_to_cpu(MODEL);\r\nstrcpy(ae->un.Model, phba->ModelName);\r\nlen = strlen(ae->un.Model);\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);\r\nab->EntryCnt++;\r\nsize += FOURBYTES + len;\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);\r\nae->ad.bits.AttrType = be16_to_cpu(MODEL_DESCRIPTION);\r\nstrcpy(ae->un.ModelDescription, phba->ModelDesc);\r\nlen = strlen(ae->un.ModelDescription);\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);\r\nab->EntryCnt++;\r\nsize += FOURBYTES + len;\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);\r\nae->ad.bits.AttrType = be16_to_cpu(HARDWARE_VERSION);\r\nae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + 8);\r\nincr = vp->rev.biuRev;\r\nfor (i = 0; i < 8; i++) {\r\nj = (incr & 0xf);\r\nif (j <= 9)\r\nae->un.HardwareVersion[7 - i] =\r\n(char)((uint8_t) 0x30 +\r\n(uint8_t) j);\r\nelse\r\nae->un.HardwareVersion[7 - i] =\r\n(char)((uint8_t) 0x61 +\r\n(uint8_t) (j - 10));\r\nincr = (incr >> 4);\r\n}\r\nab->EntryCnt++;\r\nsize += FOURBYTES + 8;\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);\r\nae->ad.bits.AttrType = be16_to_cpu(DRIVER_VERSION);\r\nstrcpy(ae->un.DriverVersion, lpfc_release_version);\r\nlen = strlen(ae->un.DriverVersion);\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);\r\nab->EntryCnt++;\r\nsize += FOURBYTES + len;\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);\r\nae->ad.bits.AttrType = be16_to_cpu(OPTION_ROM_VERSION);\r\nstrcpy(ae->un.OptionROMVersion, phba->OptionROMVersion);\r\nlen = strlen(ae->un.OptionROMVersion);\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);\r\nab->EntryCnt++;\r\nsize += FOURBYTES + len;\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);\r\nae->ad.bits.AttrType = be16_to_cpu(FIRMWARE_VERSION);\r\nlpfc_decode_firmware_rev(phba, ae->un.FirmwareVersion,\r\n1);\r\nlen = strlen(ae->un.FirmwareVersion);\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);\r\nab->EntryCnt++;\r\nsize += FOURBYTES + len;\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);\r\nae->ad.bits.AttrType = be16_to_cpu(OS_NAME_VERSION);\r\nsprintf(ae->un.OsNameVersion, "%s %s %s",\r\ninit_utsname()->sysname,\r\ninit_utsname()->release,\r\ninit_utsname()->version);\r\nlen = strlen(ae->un.OsNameVersion);\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);\r\nab->EntryCnt++;\r\nsize += FOURBYTES + len;\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);\r\nae->ad.bits.AttrType = be16_to_cpu(MAX_CT_PAYLOAD_LEN);\r\nae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + 4);\r\nae->un.MaxCTPayloadLen = (65 * 4096);\r\nab->EntryCnt++;\r\nsize += FOURBYTES + 4;\r\nab->EntryCnt = be32_to_cpu(ab->EntryCnt);\r\nsize = GID_REQUEST_SZ - 4 + size;\r\n}\r\nbreak;\r\ncase SLI_MGMT_RPA:\r\n{\r\nlpfc_vpd_t *vp;\r\nstruct serv_parm *hsp;\r\nint len;\r\nvp = &phba->vpd;\r\nCtReq->CommandResponse.bits.CmdRsp =\r\nbe16_to_cpu(SLI_MGMT_RPA);\r\nCtReq->CommandResponse.bits.Size = 0;\r\npab = (REG_PORT_ATTRIBUTE *) & CtReq->un.PortID;\r\nsize = sizeof (struct lpfc_name) + FOURBYTES;\r\nmemcpy((uint8_t *) & pab->PortName,\r\n(uint8_t *) & vport->fc_sparam.portName,\r\nsizeof (struct lpfc_name));\r\npab->ab.EntryCnt = 0;\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) pab + size);\r\nae->ad.bits.AttrType = be16_to_cpu(SUPPORTED_FC4_TYPES);\r\nae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + 32);\r\nae->un.SupportFC4Types[2] = 1;\r\nae->un.SupportFC4Types[7] = 1;\r\npab->ab.EntryCnt++;\r\nsize += FOURBYTES + 32;\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) pab + size);\r\nae->ad.bits.AttrType = be16_to_cpu(SUPPORTED_SPEED);\r\nae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + 4);\r\nae->un.SupportSpeed = 0;\r\nif (phba->lmt & LMT_16Gb)\r\nae->un.SupportSpeed |= HBA_PORTSPEED_16GBIT;\r\nif (phba->lmt & LMT_10Gb)\r\nae->un.SupportSpeed |= HBA_PORTSPEED_10GBIT;\r\nif (phba->lmt & LMT_8Gb)\r\nae->un.SupportSpeed |= HBA_PORTSPEED_8GBIT;\r\nif (phba->lmt & LMT_4Gb)\r\nae->un.SupportSpeed |= HBA_PORTSPEED_4GBIT;\r\nif (phba->lmt & LMT_2Gb)\r\nae->un.SupportSpeed |= HBA_PORTSPEED_2GBIT;\r\nif (phba->lmt & LMT_1Gb)\r\nae->un.SupportSpeed |= HBA_PORTSPEED_1GBIT;\r\npab->ab.EntryCnt++;\r\nsize += FOURBYTES + 4;\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) pab + size);\r\nae->ad.bits.AttrType = be16_to_cpu(PORT_SPEED);\r\nae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + 4);\r\nswitch(phba->fc_linkspeed) {\r\ncase LPFC_LINK_SPEED_1GHZ:\r\nae->un.PortSpeed = HBA_PORTSPEED_1GBIT;\r\nbreak;\r\ncase LPFC_LINK_SPEED_2GHZ:\r\nae->un.PortSpeed = HBA_PORTSPEED_2GBIT;\r\nbreak;\r\ncase LPFC_LINK_SPEED_4GHZ:\r\nae->un.PortSpeed = HBA_PORTSPEED_4GBIT;\r\nbreak;\r\ncase LPFC_LINK_SPEED_8GHZ:\r\nae->un.PortSpeed = HBA_PORTSPEED_8GBIT;\r\nbreak;\r\ncase LPFC_LINK_SPEED_10GHZ:\r\nae->un.PortSpeed = HBA_PORTSPEED_10GBIT;\r\nbreak;\r\ncase LPFC_LINK_SPEED_16GHZ:\r\nae->un.PortSpeed = HBA_PORTSPEED_16GBIT;\r\nbreak;\r\ndefault:\r\nae->un.PortSpeed = HBA_PORTSPEED_UNKNOWN;\r\nbreak;\r\n}\r\npab->ab.EntryCnt++;\r\nsize += FOURBYTES + 4;\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) pab + size);\r\nae->ad.bits.AttrType = be16_to_cpu(MAX_FRAME_SIZE);\r\nae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + 4);\r\nhsp = (struct serv_parm *) & vport->fc_sparam;\r\nae->un.MaxFrameSize =\r\n(((uint32_t) hsp->cmn.\r\nbbRcvSizeMsb) << 8) | (uint32_t) hsp->cmn.\r\nbbRcvSizeLsb;\r\npab->ab.EntryCnt++;\r\nsize += FOURBYTES + 4;\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) pab + size);\r\nae->ad.bits.AttrType = be16_to_cpu(OS_DEVICE_NAME);\r\nstrcpy((char *)ae->un.OsDeviceName, LPFC_DRIVER_NAME);\r\nlen = strlen((char *)ae->un.OsDeviceName);\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);\r\npab->ab.EntryCnt++;\r\nsize += FOURBYTES + len;\r\nif (vport->cfg_fdmi_on == 2) {\r\nae = (ATTRIBUTE_ENTRY *) ((uint8_t *) pab +\r\nsize);\r\nae->ad.bits.AttrType = be16_to_cpu(HOST_NAME);\r\nsprintf(ae->un.HostName, "%s",\r\ninit_utsname()->nodename);\r\nlen = strlen(ae->un.HostName);\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nae->ad.bits.AttrLen =\r\nbe16_to_cpu(FOURBYTES + len);\r\npab->ab.EntryCnt++;\r\nsize += FOURBYTES + len;\r\n}\r\npab->ab.EntryCnt = be32_to_cpu(pab->ab.EntryCnt);\r\nsize = GID_REQUEST_SZ - 4 + size;\r\n}\r\nbreak;\r\ncase SLI_MGMT_DHBA:\r\nCtReq->CommandResponse.bits.CmdRsp = be16_to_cpu(SLI_MGMT_DHBA);\r\nCtReq->CommandResponse.bits.Size = 0;\r\npe = (PORT_ENTRY *) & CtReq->un.PortID;\r\nmemcpy((uint8_t *) & pe->PortName,\r\n(uint8_t *) & vport->fc_sparam.portName,\r\nsizeof (struct lpfc_name));\r\nsize = GID_REQUEST_SZ - 4 + sizeof (struct lpfc_name);\r\nbreak;\r\ncase SLI_MGMT_DPRT:\r\nCtReq->CommandResponse.bits.CmdRsp = be16_to_cpu(SLI_MGMT_DPRT);\r\nCtReq->CommandResponse.bits.Size = 0;\r\npe = (PORT_ENTRY *) & CtReq->un.PortID;\r\nmemcpy((uint8_t *) & pe->PortName,\r\n(uint8_t *) & vport->fc_sparam.portName,\r\nsizeof (struct lpfc_name));\r\nsize = GID_REQUEST_SZ - 4 + sizeof (struct lpfc_name);\r\nbreak;\r\n}\r\nbpl = (struct ulp_bde64 *) bmp->virt;\r\nbpl->addrHigh = le32_to_cpu(putPaddrHigh(mp->phys) );\r\nbpl->addrLow = le32_to_cpu(putPaddrLow(mp->phys) );\r\nbpl->tus.f.bdeFlags = 0;\r\nbpl->tus.f.bdeSize = size;\r\nbpl->tus.w = le32_to_cpu(bpl->tus.w);\r\ncmpl = lpfc_cmpl_ct_cmd_fdmi;\r\nif (!lpfc_ct_cmd(vport, mp, bmp, ndlp, cmpl, FC_MAX_NS_RSP, 0))\r\nreturn 0;\r\nlpfc_nlp_put(ndlp);\r\nlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\r\nfdmi_cmd_free_bmp:\r\nkfree(bmp);\r\nfdmi_cmd_free_mpvirt:\r\nlpfc_mbuf_free(phba, mp->virt, mp->phys);\r\nfdmi_cmd_free_mp:\r\nkfree(mp);\r\nfdmi_cmd_exit:\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0244 Issue FDMI request failed Data: x%x\n",\r\ncmdcode);\r\nreturn 1;\r\n}\r\nvoid\r\nlpfc_delayed_disc_tmo(unsigned long ptr)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)ptr;\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint32_t tmo_posted;\r\nunsigned long iflag;\r\nspin_lock_irqsave(&vport->work_port_lock, iflag);\r\ntmo_posted = vport->work_port_events & WORKER_DELAYED_DISC_TMO;\r\nif (!tmo_posted)\r\nvport->work_port_events |= WORKER_DELAYED_DISC_TMO;\r\nspin_unlock_irqrestore(&vport->work_port_lock, iflag);\r\nif (!tmo_posted)\r\nlpfc_worker_wake_up(phba);\r\nreturn;\r\n}\r\nvoid\r\nlpfc_delayed_disc_timeout_handler(struct lpfc_vport *vport)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nspin_lock_irq(shost->host_lock);\r\nif (!(vport->fc_flag & FC_DISC_DELAYED)) {\r\nspin_unlock_irq(shost->host_lock);\r\nreturn;\r\n}\r\nvport->fc_flag &= ~FC_DISC_DELAYED;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_do_scr_ns_plogi(vport->phba, vport);\r\n}\r\nvoid\r\nlpfc_fdmi_tmo(unsigned long ptr)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)ptr;\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint32_t tmo_posted;\r\nunsigned long iflag;\r\nspin_lock_irqsave(&vport->work_port_lock, iflag);\r\ntmo_posted = vport->work_port_events & WORKER_FDMI_TMO;\r\nif (!tmo_posted)\r\nvport->work_port_events |= WORKER_FDMI_TMO;\r\nspin_unlock_irqrestore(&vport->work_port_lock, iflag);\r\nif (!tmo_posted)\r\nlpfc_worker_wake_up(phba);\r\nreturn;\r\n}\r\nvoid\r\nlpfc_fdmi_timeout_handler(struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_nodelist *ndlp;\r\nndlp = lpfc_findnode_did(vport, FDMI_DID);\r\nif (ndlp && NLP_CHK_NODE_ACT(ndlp)) {\r\nif (init_utsname()->nodename[0] != '\0')\r\nlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_DHBA);\r\nelse\r\nmod_timer(&vport->fc_fdmitmo, jiffies + HZ * 60);\r\n}\r\nreturn;\r\n}\r\nvoid\r\nlpfc_decode_firmware_rev(struct lpfc_hba *phba, char *fwrevision, int flag)\r\n{\r\nstruct lpfc_sli *psli = &phba->sli;\r\nlpfc_vpd_t *vp = &phba->vpd;\r\nuint32_t b1, b2, b3, b4, i, rev;\r\nchar c;\r\nuint32_t *ptr, str[4];\r\nuint8_t *fwname;\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nsprintf(fwrevision, "%s", vp->rev.opFwName);\r\nelse if (vp->rev.rBit) {\r\nif (psli->sli_flag & LPFC_SLI_ACTIVE)\r\nrev = vp->rev.sli2FwRev;\r\nelse\r\nrev = vp->rev.sli1FwRev;\r\nb1 = (rev & 0x0000f000) >> 12;\r\nb2 = (rev & 0x00000f00) >> 8;\r\nb3 = (rev & 0x000000c0) >> 6;\r\nb4 = (rev & 0x00000030) >> 4;\r\nswitch (b4) {\r\ncase 0:\r\nc = 'N';\r\nbreak;\r\ncase 1:\r\nc = 'A';\r\nbreak;\r\ncase 2:\r\nc = 'B';\r\nbreak;\r\ncase 3:\r\nc = 'X';\r\nbreak;\r\ndefault:\r\nc = 0;\r\nbreak;\r\n}\r\nb4 = (rev & 0x0000000f);\r\nif (psli->sli_flag & LPFC_SLI_ACTIVE)\r\nfwname = vp->rev.sli2FwName;\r\nelse\r\nfwname = vp->rev.sli1FwName;\r\nfor (i = 0; i < 16; i++)\r\nif (fwname[i] == 0x20)\r\nfwname[i] = 0;\r\nptr = (uint32_t*)fwname;\r\nfor (i = 0; i < 3; i++)\r\nstr[i] = be32_to_cpu(*ptr++);\r\nif (c == 0) {\r\nif (flag)\r\nsprintf(fwrevision, "%d.%d%d (%s)",\r\nb1, b2, b3, (char *)str);\r\nelse\r\nsprintf(fwrevision, "%d.%d%d", b1,\r\nb2, b3);\r\n} else {\r\nif (flag)\r\nsprintf(fwrevision, "%d.%d%d%c%d (%s)",\r\nb1, b2, b3, c,\r\nb4, (char *)str);\r\nelse\r\nsprintf(fwrevision, "%d.%d%d%c%d",\r\nb1, b2, b3, c, b4);\r\n}\r\n} else {\r\nrev = vp->rev.smFwRev;\r\nb1 = (rev & 0xff000000) >> 24;\r\nb2 = (rev & 0x00f00000) >> 20;\r\nb3 = (rev & 0x000f0000) >> 16;\r\nc = (rev & 0x0000ff00) >> 8;\r\nb4 = (rev & 0x000000ff);\r\nsprintf(fwrevision, "%d.%d%d%c%d", b1, b2, b3, c, b4);\r\n}\r\nreturn;\r\n}
