static int __init dma_fn(char *str)\r\n{\r\ng_cs89x0_dma = simple_strtol(str,NULL,0);\r\nreturn 1;\r\n}\r\nstatic int __init media_fn(char *str)\r\n{\r\nif (!strcmp(str, "rj45")) g_cs89x0_media__force = FORCE_RJ45;\r\nelse if (!strcmp(str, "aui")) g_cs89x0_media__force = FORCE_AUI;\r\nelse if (!strcmp(str, "bnc")) g_cs89x0_media__force = FORCE_BNC;\r\nreturn 1;\r\n}\r\nstruct net_device * __init cs89x0_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct net_local));\r\nunsigned *port;\r\nint err = 0;\r\nint irq;\r\nint io;\r\nif (!dev)\r\nreturn ERR_PTR(-ENODEV);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nio = dev->base_addr;\r\nirq = dev->irq;\r\nif (net_debug)\r\nprintk("cs89x0:cs89x0_probe(0x%x)\n", io);\r\nif (io > 0x1ff) {\r\nerr = cs89x0_probe1(dev, io, 0);\r\n} else if (io != 0) {\r\nerr = -ENXIO;\r\n} else {\r\nfor (port = netcard_portlist; *port; port++) {\r\nif (cs89x0_probe1(dev, *port, 0) == 0)\r\nbreak;\r\ndev->irq = irq;\r\n}\r\nif (!*port)\r\nerr = -ENODEV;\r\n}\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nprintk(KERN_WARNING "cs89x0: no cs8900 or cs8920 detected. Be sure to disable PnP with SETUP\n");\r\nreturn ERR_PTR(err);\r\n}\r\nstatic u16\r\nreadword(unsigned long base_addr, int portno)\r\n{\r\nreturn __raw_readw(base_addr + (portno << 1));\r\n}\r\nstatic void\r\nwriteword(unsigned long base_addr, int portno, u16 value)\r\n{\r\n__raw_writew(value, base_addr + (portno << 1));\r\n}\r\nstatic u16\r\nreadword(unsigned long base_addr, int portno)\r\n{\r\nreturn __raw_readl(base_addr + (portno << 1));\r\n}\r\nstatic void\r\nwriteword(unsigned long base_addr, int portno, u16 value)\r\n{\r\n__raw_writel(value, base_addr + (portno << 1));\r\n}\r\nstatic u16\r\nreadword(unsigned long base_addr, int portno)\r\n{\r\nreturn inw(base_addr + portno);\r\n}\r\nstatic void\r\nwriteword(unsigned long base_addr, int portno, u16 value)\r\n{\r\noutw(value, base_addr + portno);\r\n}\r\nstatic void\r\nreadwords(unsigned long base_addr, int portno, void *buf, int length)\r\n{\r\nu8 *buf8 = (u8 *)buf;\r\ndo {\r\nu16 tmp16;\r\ntmp16 = readword(base_addr, portno);\r\n*buf8++ = (u8)tmp16;\r\n*buf8++ = (u8)(tmp16 >> 8);\r\n} while (--length);\r\n}\r\nstatic void\r\nwritewords(unsigned long base_addr, int portno, void *buf, int length)\r\n{\r\nu8 *buf8 = (u8 *)buf;\r\ndo {\r\nu16 tmp16;\r\ntmp16 = *buf8++;\r\ntmp16 |= (*buf8++) << 8;\r\nwriteword(base_addr, portno, tmp16);\r\n} while (--length);\r\n}\r\nstatic u16\r\nreadreg(struct net_device *dev, u16 regno)\r\n{\r\nwriteword(dev->base_addr, ADD_PORT, regno);\r\nreturn readword(dev->base_addr, DATA_PORT);\r\n}\r\nstatic void\r\nwritereg(struct net_device *dev, u16 regno, u16 value)\r\n{\r\nwriteword(dev->base_addr, ADD_PORT, regno);\r\nwriteword(dev->base_addr, DATA_PORT, value);\r\n}\r\nstatic int __init\r\nwait_eeprom_ready(struct net_device *dev)\r\n{\r\nint timeout = jiffies;\r\nwhile(readreg(dev, PP_SelfST) & SI_BUSY)\r\nif (jiffies - timeout >= 40)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int __init\r\nget_eeprom_data(struct net_device *dev, int off, int len, int *buffer)\r\n{\r\nint i;\r\nif (net_debug > 3) printk("EEPROM data from %x for %x:\n",off,len);\r\nfor (i = 0; i < len; i++) {\r\nif (wait_eeprom_ready(dev) < 0) return -1;\r\nwritereg(dev, PP_EECMD, (off + i) | EEPROM_READ_CMD);\r\nif (wait_eeprom_ready(dev) < 0) return -1;\r\nbuffer[i] = readreg(dev, PP_EEData);\r\nif (net_debug > 3) printk("%04x ", buffer[i]);\r\n}\r\nif (net_debug > 3) printk("\n");\r\nreturn 0;\r\n}\r\nstatic int __init\r\nget_eeprom_cksum(int off, int len, int *buffer)\r\n{\r\nint i, cksum;\r\ncksum = 0;\r\nfor (i = 0; i < len; i++)\r\ncksum += buffer[i];\r\ncksum &= 0xffff;\r\nif (cksum == 0)\r\nreturn 0;\r\nreturn -1;\r\n}\r\nstatic void net_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\nnet_interrupt(dev->irq, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic int __init\r\ncs89x0_probe1(struct net_device *dev, int ioaddr, int modular)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nstatic unsigned version_printed;\r\nint i;\r\nint tmp;\r\nunsigned rev_type = 0;\r\nint eeprom_buff[CHKSUM_LEN];\r\nint retval;\r\nif (!modular) {\r\nmemset(lp, 0, sizeof(*lp));\r\nspin_lock_init(&lp->lock);\r\n#ifndef MODULE\r\n#if ALLOW_DMA\r\nif (g_cs89x0_dma) {\r\nlp->use_dma = 1;\r\nlp->dma = g_cs89x0_dma;\r\nlp->dmasize = 16;\r\n}\r\n#endif\r\nlp->force = g_cs89x0_media__force;\r\n#endif\r\n#if defined(CONFIG_MACH_QQ2440)\r\nlp->force |= FORCE_RJ45 | FORCE_FULL;\r\n#endif\r\n}\r\nif (!request_region(ioaddr & ~3, NETCARD_IO_EXTENT, DRV_NAME)) {\r\nprintk(KERN_ERR "%s: request_region(0x%x, 0x%x) failed\n",\r\nDRV_NAME, ioaddr, NETCARD_IO_EXTENT);\r\nretval = -EBUSY;\r\ngoto out1;\r\n}\r\nif (ioaddr & 1) {\r\nif (net_debug > 1)\r\nprintk(KERN_INFO "%s: odd ioaddr 0x%x\n", dev->name, ioaddr);\r\nif ((ioaddr & 2) != 2)\r\nif ((readword(ioaddr & ~3, ADD_PORT) & ADD_MASK) != ADD_SIG) {\r\nprintk(KERN_ERR "%s: bad signature 0x%x\n",\r\ndev->name, readword(ioaddr & ~3, ADD_PORT));\r\nretval = -ENODEV;\r\ngoto out2;\r\n}\r\n}\r\nioaddr &= ~3;\r\nprintk(KERN_DEBUG "PP_addr at %x[%x]: 0x%x\n",\r\nioaddr, ADD_PORT, readword(ioaddr, ADD_PORT));\r\nwriteword(ioaddr, ADD_PORT, PP_ChipID);\r\ntmp = readword(ioaddr, DATA_PORT);\r\nif (tmp != CHIP_EISA_ID_SIG) {\r\nprintk(KERN_DEBUG "%s: incorrect signature at %x[%x]: 0x%x!="\r\nCHIP_EISA_ID_SIG_STR "\n",\r\ndev->name, ioaddr, DATA_PORT, tmp);\r\nretval = -ENODEV;\r\ngoto out2;\r\n}\r\ndev->base_addr = ioaddr;\r\nrev_type = readreg(dev, PRODUCT_ID_ADD);\r\nlp->chip_type = rev_type &~ REVISON_BITS;\r\nlp->chip_revision = ((rev_type & REVISON_BITS) >> 8) + 'A';\r\nlp->send_cmd = TX_AFTER_381;\r\nif (lp->chip_type == CS8900 && lp->chip_revision >= 'F')\r\nlp->send_cmd = TX_NOW;\r\nif (lp->chip_type != CS8900 && lp->chip_revision >= 'C')\r\nlp->send_cmd = TX_NOW;\r\nif (net_debug && version_printed++ == 0)\r\nprintk(version);\r\nprintk(KERN_INFO "%s: cs89%c0%s rev %c found at %#3lx ",\r\ndev->name,\r\nlp->chip_type==CS8900?'0':'2',\r\nlp->chip_type==CS8920M?"M":"",\r\nlp->chip_revision,\r\ndev->base_addr);\r\nreset_chip(dev);\r\nif ((readreg(dev, PP_SelfST) & (EEPROM_OK | EEPROM_PRESENT)) ==\r\n(EEPROM_OK|EEPROM_PRESENT)) {\r\nfor (i=0; i < ETH_ALEN/2; i++) {\r\nunsigned int Addr;\r\nAddr = readreg(dev, PP_IA+i*2);\r\ndev->dev_addr[i*2] = Addr & 0xFF;\r\ndev->dev_addr[i*2+1] = Addr >> 8;\r\n}\r\nlp->adapter_cnf = 0;\r\ni = readreg(dev, PP_LineCTL);\r\nif ((i & (HCB1 | HCB1_ENBL)) == (HCB1 | HCB1_ENBL))\r\nlp->adapter_cnf |= A_CNF_DC_DC_POLARITY;\r\nif ((i & LOW_RX_SQUELCH) == LOW_RX_SQUELCH)\r\nlp->adapter_cnf |= A_CNF_EXTND_10B_2 | A_CNF_LOW_RX_SQUELCH;\r\nif ((i & (AUI_ONLY | AUTO_AUI_10BASET)) == 0)\r\nlp->adapter_cnf |= A_CNF_10B_T | A_CNF_MEDIA_10B_T;\r\nif ((i & (AUI_ONLY | AUTO_AUI_10BASET)) == AUI_ONLY)\r\nlp->adapter_cnf |= A_CNF_AUI | A_CNF_MEDIA_AUI;\r\nif ((i & (AUI_ONLY | AUTO_AUI_10BASET)) == AUTO_AUI_10BASET)\r\nlp->adapter_cnf |= A_CNF_AUI | A_CNF_10B_T |\r\nA_CNF_MEDIA_AUI | A_CNF_MEDIA_10B_T | A_CNF_MEDIA_AUTO;\r\nif (net_debug > 1)\r\nprintk(KERN_INFO "%s: PP_LineCTL=0x%x, adapter_cnf=0x%x\n",\r\ndev->name, i, lp->adapter_cnf);\r\nif (lp->chip_type == CS8900)\r\nlp->isa_config = readreg(dev, PP_CS8900_ISAINT) & INT_NO_MASK;\r\nprintk( "[Cirrus EEPROM] ");\r\n}\r\nprintk("\n");\r\nif ((readreg(dev, PP_SelfST) & EEPROM_PRESENT) == 0)\r\nprintk(KERN_WARNING "cs89x0: No EEPROM, relying on command line....\n");\r\nelse if (get_eeprom_data(dev, START_EEPROM_DATA,CHKSUM_LEN,eeprom_buff) < 0) {\r\nprintk(KERN_WARNING "\ncs89x0: EEPROM read failed, relying on command line.\n");\r\n} else if (get_eeprom_cksum(START_EEPROM_DATA,CHKSUM_LEN,eeprom_buff) < 0) {\r\nif ((readreg(dev, PP_SelfST) & (EEPROM_OK | EEPROM_PRESENT)) !=\r\n(EEPROM_OK|EEPROM_PRESENT))\r\nprintk(KERN_WARNING "cs89x0: Extended EEPROM checksum bad and no Cirrus EEPROM, relying on command line\n");\r\n} else {\r\nif (!lp->auto_neg_cnf) lp->auto_neg_cnf = eeprom_buff[AUTO_NEG_CNF_OFFSET/2];\r\nif (!lp->adapter_cnf) lp->adapter_cnf = eeprom_buff[ADAPTER_CNF_OFFSET/2];\r\nlp->isa_config = eeprom_buff[ISA_CNF_OFFSET/2];\r\ndev->mem_start = eeprom_buff[PACKET_PAGE_OFFSET/2] << 8;\r\nfor (i = 0; i < ETH_ALEN/2; i++) {\r\ndev->dev_addr[i*2] = eeprom_buff[i];\r\ndev->dev_addr[i*2+1] = eeprom_buff[i] >> 8;\r\n}\r\nif (net_debug > 1)\r\nprintk(KERN_DEBUG "%s: new adapter_cnf: 0x%x\n",\r\ndev->name, lp->adapter_cnf);\r\n}\r\n{\r\nint count = 0;\r\nif (lp->force & FORCE_RJ45) {lp->adapter_cnf |= A_CNF_10B_T; count++; }\r\nif (lp->force & FORCE_AUI) {lp->adapter_cnf |= A_CNF_AUI; count++; }\r\nif (lp->force & FORCE_BNC) {lp->adapter_cnf |= A_CNF_10B_2; count++; }\r\nif (count > 1) {lp->adapter_cnf |= A_CNF_MEDIA_AUTO; }\r\nelse if (lp->force & FORCE_RJ45){lp->adapter_cnf |= A_CNF_MEDIA_10B_T; }\r\nelse if (lp->force & FORCE_AUI) {lp->adapter_cnf |= A_CNF_MEDIA_AUI; }\r\nelse if (lp->force & FORCE_BNC) {lp->adapter_cnf |= A_CNF_MEDIA_10B_2; }\r\n}\r\nif (net_debug > 1)\r\nprintk(KERN_DEBUG "%s: after force 0x%x, adapter_cnf=0x%x\n",\r\ndev->name, lp->force, lp->adapter_cnf);\r\nprintk(KERN_INFO "cs89x0 media %s%s%s",\r\n(lp->adapter_cnf & A_CNF_10B_T)?"RJ-45,":"",\r\n(lp->adapter_cnf & A_CNF_AUI)?"AUI,":"",\r\n(lp->adapter_cnf & A_CNF_10B_2)?"BNC,":"");\r\nlp->irq_map = 0xffff;\r\nif (lp->chip_type != CS8900 &&\r\n(i = readreg(dev, PP_CS8920_ISAINT) & 0xff,\r\n(i != 0 && i < CS8920_NO_INTS))) {\r\nif (!dev->irq)\r\ndev->irq = i;\r\n} else {\r\ni = lp->isa_config & INT_NO_MASK;\r\nif (lp->chip_type == CS8900) {\r\n#ifdef CONFIG_CS89x0_NONISA_IRQ\r\ni = cs8900_irq_map[0];\r\n#else\r\nif (i >= ARRAY_SIZE(cs8900_irq_map))\r\nprintk("\ncs89x0: invalid ISA interrupt number %d\n", i);\r\nelse\r\ni = cs8900_irq_map[i];\r\nlp->irq_map = CS8900_IRQ_MAP;\r\n} else {\r\nint irq_map_buff[IRQ_MAP_LEN/2];\r\nif (get_eeprom_data(dev, IRQ_MAP_EEPROM_DATA,\r\nIRQ_MAP_LEN/2,\r\nirq_map_buff) >= 0) {\r\nif ((irq_map_buff[0] & 0xff) == PNP_IRQ_FRMT)\r\nlp->irq_map = (irq_map_buff[0]>>8) | (irq_map_buff[1] << 8);\r\n}\r\n#endif\r\n}\r\nif (!dev->irq)\r\ndev->irq = i;\r\n}\r\nprintk(" IRQ %d", dev->irq);\r\n#if ALLOW_DMA\r\nif (lp->use_dma) {\r\nget_dma_channel(dev);\r\nprintk(", DMA %d", dev->dma);\r\n}\r\nelse\r\n#endif\r\n{\r\nprintk(", programmed I/O");\r\n}\r\nprintk(", MAC %pM", dev->dev_addr);\r\ndev->netdev_ops = &net_ops;\r\ndev->watchdog_timeo = HZ;\r\nprintk("\n");\r\nif (net_debug)\r\nprintk("cs89x0_probe1() successful\n");\r\nretval = register_netdev(dev);\r\nif (retval)\r\ngoto out3;\r\nreturn 0;\r\nout3:\r\nwriteword(dev->base_addr, ADD_PORT, PP_ChipID);\r\nout2:\r\nrelease_region(ioaddr & ~3, NETCARD_IO_EXTENT);\r\nout1:\r\nreturn retval;\r\n}\r\nstatic void\r\nget_dma_channel(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nif (lp->dma) {\r\ndev->dma = lp->dma;\r\nlp->isa_config |= ISA_RxDMA;\r\n} else {\r\nif ((lp->isa_config & ANY_ISA_DMA) == 0)\r\nreturn;\r\ndev->dma = lp->isa_config & DMA_NO_MASK;\r\nif (lp->chip_type == CS8900)\r\ndev->dma += 5;\r\nif (dev->dma < 5 || dev->dma > 7) {\r\nlp->isa_config &= ~ANY_ISA_DMA;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void\r\nwrite_dma(struct net_device *dev, int chip_type, int dma)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nif ((lp->isa_config & ANY_ISA_DMA) == 0)\r\nreturn;\r\nif (chip_type == CS8900) {\r\nwritereg(dev, PP_CS8900_ISADMA, dma-5);\r\n} else {\r\nwritereg(dev, PP_CS8920_ISADMA, dma);\r\n}\r\n}\r\nstatic void\r\nset_dma_cfg(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nif (lp->use_dma) {\r\nif ((lp->isa_config & ANY_ISA_DMA) == 0) {\r\nif (net_debug > 3)\r\nprintk("set_dma_cfg(): no DMA\n");\r\nreturn;\r\n}\r\nif (lp->isa_config & ISA_RxDMA) {\r\nlp->curr_rx_cfg |= RX_DMA_ONLY;\r\nif (net_debug > 3)\r\nprintk("set_dma_cfg(): RX_DMA_ONLY\n");\r\n} else {\r\nlp->curr_rx_cfg |= AUTO_RX_DMA;\r\nif (net_debug > 3)\r\nprintk("set_dma_cfg(): AUTO_RX_DMA\n");\r\n}\r\n}\r\n}\r\nstatic int\r\ndma_bufcfg(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nif (lp->use_dma)\r\nreturn (lp->isa_config & ANY_ISA_DMA)? RX_DMA_ENBL : 0;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int\r\ndma_busctl(struct net_device *dev)\r\n{\r\nint retval = 0;\r\nstruct net_local *lp = netdev_priv(dev);\r\nif (lp->use_dma) {\r\nif (lp->isa_config & ANY_ISA_DMA)\r\nretval |= RESET_RX_DMA;\r\nif (lp->isa_config & DMA_BURST)\r\nretval |= DMA_BURST_MODE;\r\nif (lp->dmasize == 64)\r\nretval |= RX_DMA_SIZE_64K;\r\nretval |= MEMORY_ON;\r\n}\r\nreturn retval;\r\n}\r\nstatic void\r\ndma_rx(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nint status, length;\r\nunsigned char *bp = lp->rx_dma_ptr;\r\nstatus = bp[0] + (bp[1]<<8);\r\nlength = bp[2] + (bp[3]<<8);\r\nbp += 4;\r\nif (net_debug > 5) {\r\nprintk( "%s: receiving DMA packet at %lx, status %x, length %x\n",\r\ndev->name, (unsigned long)bp, status, length);\r\n}\r\nif ((status & RX_OK) == 0) {\r\ncount_rx_errors(status, dev);\r\ngoto skip_this_frame;\r\n}\r\nskb = dev_alloc_skb(length + 2);\r\nif (skb == NULL) {\r\nif (net_debug)\r\nprintk("%s: Memory squeeze, dropping packet.\n", dev->name);\r\ndev->stats.rx_dropped++;\r\nskip_this_frame:\r\nbp += (length + 3) & ~3;\r\nif (bp >= lp->end_dma_buff) bp -= lp->dmasize*1024;\r\nlp->rx_dma_ptr = bp;\r\nreturn;\r\n}\r\nskb_reserve(skb, 2);\r\nif (bp + length > lp->end_dma_buff) {\r\nint semi_cnt = lp->end_dma_buff - bp;\r\nmemcpy(skb_put(skb,semi_cnt), bp, semi_cnt);\r\nmemcpy(skb_put(skb,length - semi_cnt), lp->dma_buff,\r\nlength - semi_cnt);\r\n} else {\r\nmemcpy(skb_put(skb,length), bp, length);\r\n}\r\nbp += (length + 3) & ~3;\r\nif (bp >= lp->end_dma_buff) bp -= lp->dmasize*1024;\r\nlp->rx_dma_ptr = bp;\r\nif (net_debug > 3) {\r\nprintk( "%s: received %d byte DMA packet of type %x\n",\r\ndev->name, length,\r\n(skb->data[ETH_ALEN+ETH_ALEN] << 8) | skb->data[ETH_ALEN+ETH_ALEN+1]);\r\n}\r\nskb->protocol=eth_type_trans(skb,dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += length;\r\n}\r\nstatic void __init reset_chip(struct net_device *dev)\r\n{\r\n#if !defined(CONFIG_MACH_MX31ADS)\r\n#if !defined(CS89x0_NONISA_IRQ)\r\nstruct net_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\n#endif\r\nint reset_start_time;\r\nwritereg(dev, PP_SelfCTL, readreg(dev, PP_SelfCTL) | POWER_ON_RESET);\r\nmsleep(30);\r\n#if !defined(CS89x0_NONISA_IRQ)\r\nif (lp->chip_type != CS8900) {\r\nwriteword(ioaddr, ADD_PORT, PP_CS8920_ISAINT);\r\noutb(dev->irq, ioaddr + DATA_PORT);\r\noutb(0, ioaddr + DATA_PORT + 1);\r\nwriteword(ioaddr, ADD_PORT, PP_CS8920_ISAMemB);\r\noutb((dev->mem_start >> 16) & 0xff, ioaddr + DATA_PORT);\r\noutb((dev->mem_start >> 8) & 0xff, ioaddr + DATA_PORT + 1);\r\n}\r\n#endif\r\nreset_start_time = jiffies;\r\nwhile( (readreg(dev, PP_SelfST) & INIT_DONE) == 0 && jiffies - reset_start_time < 2)\r\n;\r\n#endif\r\n}\r\nstatic void\r\ncontrol_dc_dc(struct net_device *dev, int on_not_off)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned int selfcontrol;\r\nint timenow = jiffies;\r\nselfcontrol = HCB1_ENBL;\r\nif (((lp->adapter_cnf & A_CNF_DC_DC_POLARITY) != 0) ^ on_not_off)\r\nselfcontrol |= HCB1;\r\nelse\r\nselfcontrol &= ~HCB1;\r\nwritereg(dev, PP_SelfCTL, selfcontrol);\r\nwhile (jiffies - timenow < HZ)\r\n;\r\n}\r\nstatic int\r\ndetect_tp(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint timenow = jiffies;\r\nint fdx;\r\nif (net_debug > 1) printk("%s: Attempting TP\n", dev->name);\r\nwritereg(dev, PP_LineCTL, lp->linectl &~ AUI_ONLY);\r\ncontrol_dc_dc(dev, 0);\r\nfor (timenow = jiffies; jiffies - timenow < 15; )\r\n;\r\nif ((readreg(dev, PP_LineST) & LINK_OK) == 0)\r\nreturn DETECTED_NONE;\r\nif (lp->chip_type == CS8900) {\r\nswitch (lp->force & 0xf0) {\r\n#if 0\r\ncase FORCE_AUTO:\r\nprintk("%s: cs8900 doesn't autonegotiate\n",dev->name);\r\nreturn DETECTED_NONE;\r\n#endif\r\ncase FORCE_AUTO:\r\nlp->force &= ~FORCE_AUTO;\r\nlp->force |= FORCE_HALF;\r\nbreak;\r\ncase FORCE_HALF:\r\nbreak;\r\ncase FORCE_FULL:\r\nwritereg(dev, PP_TestCTL, readreg(dev, PP_TestCTL) | FDX_8900);\r\nbreak;\r\n}\r\nfdx = readreg(dev, PP_TestCTL) & FDX_8900;\r\n} else {\r\nswitch (lp->force & 0xf0) {\r\ncase FORCE_AUTO:\r\nlp->auto_neg_cnf = AUTO_NEG_ENABLE;\r\nbreak;\r\ncase FORCE_HALF:\r\nlp->auto_neg_cnf = 0;\r\nbreak;\r\ncase FORCE_FULL:\r\nlp->auto_neg_cnf = RE_NEG_NOW | ALLOW_FDX;\r\nbreak;\r\n}\r\nwritereg(dev, PP_AutoNegCTL, lp->auto_neg_cnf & AUTO_NEG_MASK);\r\nif ((lp->auto_neg_cnf & AUTO_NEG_BITS) == AUTO_NEG_ENABLE) {\r\nprintk(KERN_INFO "%s: negotiating duplex...\n",dev->name);\r\nwhile (readreg(dev, PP_AutoNegST) & AUTO_NEG_BUSY) {\r\nif (jiffies - timenow > 4000) {\r\nprintk(KERN_ERR "**** Full / half duplex auto-negotiation timed out ****\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nfdx = readreg(dev, PP_AutoNegST) & FDX_ACTIVE;\r\n}\r\nif (fdx)\r\nreturn DETECTED_RJ45F;\r\nelse\r\nreturn DETECTED_RJ45H;\r\n}\r\nstatic int\r\nsend_test_pkt(struct net_device *dev)\r\n{\r\nchar test_packet[] = { 0,0,0,0,0,0, 0,0,0,0,0,0,\r\n0, 46,\r\n0, 0,\r\n0xf3, 0 };\r\nlong timenow = jiffies;\r\nwritereg(dev, PP_LineCTL, readreg(dev, PP_LineCTL) | SERIAL_TX_ON);\r\nmemcpy(test_packet, dev->dev_addr, ETH_ALEN);\r\nmemcpy(test_packet+ETH_ALEN, dev->dev_addr, ETH_ALEN);\r\nwriteword(dev->base_addr, TX_CMD_PORT, TX_AFTER_ALL);\r\nwriteword(dev->base_addr, TX_LEN_PORT, ETH_ZLEN);\r\nwhile (jiffies - timenow < 5)\r\nif (readreg(dev, PP_BusST) & READY_FOR_TX_NOW)\r\nbreak;\r\nif (jiffies - timenow >= 5)\r\nreturn 0;\r\nwritewords(dev->base_addr, TX_FRAME_PORT,test_packet,(ETH_ZLEN+1) >>1);\r\nif (net_debug > 1) printk("Sending test packet ");\r\nfor (timenow = jiffies; jiffies - timenow < 3; )\r\n;\r\nif ((readreg(dev, PP_TxEvent) & TX_SEND_OK_BITS) == TX_OK) {\r\nif (net_debug > 1) printk("succeeded\n");\r\nreturn 1;\r\n}\r\nif (net_debug > 1) printk("failed\n");\r\nreturn 0;\r\n}\r\nstatic int\r\ndetect_aui(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nif (net_debug > 1) printk("%s: Attempting AUI\n", dev->name);\r\ncontrol_dc_dc(dev, 0);\r\nwritereg(dev, PP_LineCTL, (lp->linectl &~ AUTO_AUI_10BASET) | AUI_ONLY);\r\nif (send_test_pkt(dev))\r\nreturn DETECTED_AUI;\r\nelse\r\nreturn DETECTED_NONE;\r\n}\r\nstatic int\r\ndetect_bnc(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nif (net_debug > 1) printk("%s: Attempting BNC\n", dev->name);\r\ncontrol_dc_dc(dev, 1);\r\nwritereg(dev, PP_LineCTL, (lp->linectl &~ AUTO_AUI_10BASET) | AUI_ONLY);\r\nif (send_test_pkt(dev))\r\nreturn DETECTED_BNC;\r\nelse\r\nreturn DETECTED_NONE;\r\n}\r\nstatic void\r\nwrite_irq(struct net_device *dev, int chip_type, int irq)\r\n{\r\nint i;\r\nif (chip_type == CS8900) {\r\nfor (i = 0; i != ARRAY_SIZE(cs8900_irq_map); i++)\r\nif (cs8900_irq_map[i] == irq)\r\nbreak;\r\nif (i == ARRAY_SIZE(cs8900_irq_map))\r\ni = 3;\r\nwritereg(dev, PP_CS8900_ISAINT, i);\r\n} else {\r\nwritereg(dev, PP_CS8920_ISAINT, irq);\r\n}\r\n}\r\nstatic int\r\nnet_open(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint result = 0;\r\nint i;\r\nint ret;\r\nif (dev->irq < 2) {\r\n#if 0\r\nwritereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ );\r\n#endif\r\nwritereg(dev, PP_BusCTL, ENABLE_IRQ | MEMORY_ON);\r\nfor (i = 2; i < CS8920_NO_INTS; i++) {\r\nif ((1 << i) & lp->irq_map) {\r\nif (request_irq(i, net_interrupt, 0, dev->name, dev) == 0) {\r\ndev->irq = i;\r\nwrite_irq(dev, lp->chip_type, i);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (i >= CS8920_NO_INTS) {\r\nwritereg(dev, PP_BusCTL, 0);\r\nprintk(KERN_ERR "cs89x0: can't get an interrupt\n");\r\nret = -EAGAIN;\r\ngoto bad_out;\r\n}\r\n}\r\nelse\r\n{\r\n#ifndef CONFIG_CS89x0_NONISA_IRQ\r\nif (((1 << dev->irq) & lp->irq_map) == 0) {\r\nprintk(KERN_ERR "%s: IRQ %d is not in our map of allowable IRQs, which is %x\n",\r\ndev->name, dev->irq, lp->irq_map);\r\nret = -EAGAIN;\r\ngoto bad_out;\r\n}\r\n#endif\r\nwritereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ );\r\n#if 0\r\nwritereg(dev, PP_BusCTL, ENABLE_IRQ | MEMORY_ON);\r\n#endif\r\nwrite_irq(dev, lp->chip_type, dev->irq);\r\nret = request_irq(dev->irq, net_interrupt, 0, dev->name, dev);\r\nif (ret) {\r\nprintk(KERN_ERR "cs89x0: request_irq(%d) failed\n", dev->irq);\r\ngoto bad_out;\r\n}\r\n}\r\n#if ALLOW_DMA\r\nif (lp->use_dma) {\r\nif (lp->isa_config & ANY_ISA_DMA) {\r\nunsigned long flags;\r\nlp->dma_buff = (unsigned char *)__get_dma_pages(GFP_KERNEL,\r\nget_order(lp->dmasize * 1024));\r\nif (!lp->dma_buff) {\r\nprintk(KERN_ERR "%s: cannot get %dK memory for DMA\n", dev->name, lp->dmasize);\r\ngoto release_irq;\r\n}\r\nif (net_debug > 1) {\r\nprintk( "%s: dma %lx %lx\n",\r\ndev->name,\r\n(unsigned long)lp->dma_buff,\r\n(unsigned long)isa_virt_to_bus(lp->dma_buff));\r\n}\r\nif ((unsigned long) lp->dma_buff >= MAX_DMA_ADDRESS ||\r\n!dma_page_eq(lp->dma_buff, lp->dma_buff+lp->dmasize*1024-1)) {\r\nprintk(KERN_ERR "%s: not usable as DMA buffer\n", dev->name);\r\ngoto release_irq;\r\n}\r\nmemset(lp->dma_buff, 0, lp->dmasize * 1024);\r\nif (request_dma(dev->dma, dev->name)) {\r\nprintk(KERN_ERR "%s: cannot get dma channel %d\n", dev->name, dev->dma);\r\ngoto release_irq;\r\n}\r\nwrite_dma(dev, lp->chip_type, dev->dma);\r\nlp->rx_dma_ptr = lp->dma_buff;\r\nlp->end_dma_buff = lp->dma_buff + lp->dmasize*1024;\r\nspin_lock_irqsave(&lp->lock, flags);\r\ndisable_dma(dev->dma);\r\nclear_dma_ff(dev->dma);\r\nset_dma_mode(dev->dma, DMA_RX_MODE);\r\nset_dma_addr(dev->dma, isa_virt_to_bus(lp->dma_buff));\r\nset_dma_count(dev->dma, lp->dmasize*1024);\r\nenable_dma(dev->dma);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\n}\r\n#endif\r\nfor (i=0; i < ETH_ALEN/2; i++)\r\nwritereg(dev, PP_IA+i*2, dev->dev_addr[i*2] | (dev->dev_addr[i*2+1] << 8));\r\nwritereg(dev, PP_BusCTL, MEMORY_ON);\r\nif ((lp->adapter_cnf & A_CNF_EXTND_10B_2) && (lp->adapter_cnf & A_CNF_LOW_RX_SQUELCH))\r\nlp->linectl = LOW_RX_SQUELCH;\r\nelse\r\nlp->linectl = 0;\r\nswitch(lp->adapter_cnf & A_CNF_MEDIA_TYPE) {\r\ncase A_CNF_MEDIA_10B_T: result = lp->adapter_cnf & A_CNF_10B_T; break;\r\ncase A_CNF_MEDIA_AUI: result = lp->adapter_cnf & A_CNF_AUI; break;\r\ncase A_CNF_MEDIA_10B_2: result = lp->adapter_cnf & A_CNF_10B_2; break;\r\ndefault: result = lp->adapter_cnf & (A_CNF_10B_T | A_CNF_AUI | A_CNF_10B_2);\r\n}\r\nif (!result) {\r\nprintk(KERN_ERR "%s: EEPROM is configured for unavailable media\n", dev->name);\r\nrelease_dma:\r\n#if ALLOW_DMA\r\nfree_dma(dev->dma);\r\nrelease_irq:\r\nrelease_dma_buff(lp);\r\n#endif\r\nwritereg(dev, PP_LineCTL, readreg(dev, PP_LineCTL) & ~(SERIAL_TX_ON | SERIAL_RX_ON));\r\nfree_irq(dev->irq, dev);\r\nret = -EAGAIN;\r\ngoto bad_out;\r\n}\r\nswitch(lp->adapter_cnf & A_CNF_MEDIA_TYPE) {\r\ncase A_CNF_MEDIA_10B_T:\r\nresult = detect_tp(dev);\r\nif (result==DETECTED_NONE) {\r\nprintk(KERN_WARNING "%s: 10Base-T (RJ-45) has no cable\n", dev->name);\r\nif (lp->auto_neg_cnf & IMM_BIT)\r\nresult = DETECTED_RJ45H;\r\n}\r\nbreak;\r\ncase A_CNF_MEDIA_AUI:\r\nresult = detect_aui(dev);\r\nif (result==DETECTED_NONE) {\r\nprintk(KERN_WARNING "%s: 10Base-5 (AUI) has no cable\n", dev->name);\r\nif (lp->auto_neg_cnf & IMM_BIT)\r\nresult = DETECTED_AUI;\r\n}\r\nbreak;\r\ncase A_CNF_MEDIA_10B_2:\r\nresult = detect_bnc(dev);\r\nif (result==DETECTED_NONE) {\r\nprintk(KERN_WARNING "%s: 10Base-2 (BNC) has no cable\n", dev->name);\r\nif (lp->auto_neg_cnf & IMM_BIT)\r\nresult = DETECTED_BNC;\r\n}\r\nbreak;\r\ncase A_CNF_MEDIA_AUTO:\r\nwritereg(dev, PP_LineCTL, lp->linectl | AUTO_AUI_10BASET);\r\nif (lp->adapter_cnf & A_CNF_10B_T)\r\nif ((result = detect_tp(dev)) != DETECTED_NONE)\r\nbreak;\r\nif (lp->adapter_cnf & A_CNF_AUI)\r\nif ((result = detect_aui(dev)) != DETECTED_NONE)\r\nbreak;\r\nif (lp->adapter_cnf & A_CNF_10B_2)\r\nif ((result = detect_bnc(dev)) != DETECTED_NONE)\r\nbreak;\r\nprintk(KERN_ERR "%s: no media detected\n", dev->name);\r\ngoto release_dma;\r\n}\r\nswitch(result) {\r\ncase DETECTED_NONE:\r\nprintk(KERN_ERR "%s: no network cable attached to configured media\n", dev->name);\r\ngoto release_dma;\r\ncase DETECTED_RJ45H:\r\nprintk(KERN_INFO "%s: using half-duplex 10Base-T (RJ-45)\n", dev->name);\r\nbreak;\r\ncase DETECTED_RJ45F:\r\nprintk(KERN_INFO "%s: using full-duplex 10Base-T (RJ-45)\n", dev->name);\r\nbreak;\r\ncase DETECTED_AUI:\r\nprintk(KERN_INFO "%s: using 10Base-5 (AUI)\n", dev->name);\r\nbreak;\r\ncase DETECTED_BNC:\r\nprintk(KERN_INFO "%s: using 10Base-2 (BNC)\n", dev->name);\r\nbreak;\r\n}\r\nwritereg(dev, PP_LineCTL, readreg(dev, PP_LineCTL) | SERIAL_RX_ON | SERIAL_TX_ON);\r\nlp->rx_mode = 0;\r\nwritereg(dev, PP_RxCTL, DEF_RX_ACCEPT);\r\nlp->curr_rx_cfg = RX_OK_ENBL | RX_CRC_ERROR_ENBL;\r\nif (lp->isa_config & STREAM_TRANSFER)\r\nlp->curr_rx_cfg |= RX_STREAM_ENBL;\r\n#if ALLOW_DMA\r\nset_dma_cfg(dev);\r\n#endif\r\nwritereg(dev, PP_RxCFG, lp->curr_rx_cfg);\r\nwritereg(dev, PP_TxCFG, TX_LOST_CRS_ENBL | TX_SQE_ERROR_ENBL | TX_OK_ENBL |\r\nTX_LATE_COL_ENBL | TX_JBR_ENBL | TX_ANY_COL_ENBL | TX_16_COL_ENBL);\r\nwritereg(dev, PP_BufCFG, READY_FOR_TX_ENBL | RX_MISS_COUNT_OVRFLOW_ENBL |\r\n#if ALLOW_DMA\r\ndma_bufcfg(dev) |\r\n#endif\r\nTX_COL_COUNT_OVRFLOW_ENBL | TX_UNDERRUN_ENBL);\r\nwritereg(dev, PP_BusCTL, ENABLE_IRQ\r\n| (dev->mem_start?MEMORY_ON : 0)\r\n#if ALLOW_DMA\r\n| dma_busctl(dev)\r\n#endif\r\n);\r\nnetif_start_queue(dev);\r\nif (net_debug > 1)\r\nprintk("cs89x0: net_open() succeeded\n");\r\nreturn 0;\r\nbad_out:\r\nreturn ret;\r\n}\r\nstatic void net_timeout(struct net_device *dev)\r\n{\r\nif (net_debug > 0) printk("%s: transmit timed out, %s?\n", dev->name,\r\ntx_done(dev) ? "IRQ conflict ?" : "network cable problem");\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t net_send_packet(struct sk_buff *skb,struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nif (net_debug > 3) {\r\nprintk("%s: sent %d byte packet of type %x\n",\r\ndev->name, skb->len,\r\n(skb->data[ETH_ALEN+ETH_ALEN] << 8) | skb->data[ETH_ALEN+ETH_ALEN+1]);\r\n}\r\nspin_lock_irqsave(&lp->lock, flags);\r\nnetif_stop_queue(dev);\r\nwriteword(dev->base_addr, TX_CMD_PORT, lp->send_cmd);\r\nwriteword(dev->base_addr, TX_LEN_PORT, skb->len);\r\nif ((readreg(dev, PP_BusST) & READY_FOR_TX_NOW) == 0) {\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nif (net_debug) printk("cs89x0: Tx buffer not free!\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nwritewords(dev->base_addr, TX_FRAME_PORT,skb->data,(skb->len+1) >>1);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\ndev->stats.tx_bytes += skb->len;\r\ndev_kfree_skb (skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t net_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct net_local *lp;\r\nint ioaddr, status;\r\nint handled = 0;\r\nioaddr = dev->base_addr;\r\nlp = netdev_priv(dev);\r\nwhile ((status = readword(dev->base_addr, ISQ_PORT))) {\r\nif (net_debug > 4)printk("%s: event=%04x\n", dev->name, status);\r\nhandled = 1;\r\nswitch(status & ISQ_EVENT_MASK) {\r\ncase ISQ_RECEIVER_EVENT:\r\nnet_rx(dev);\r\nbreak;\r\ncase ISQ_TRANSMITTER_EVENT:\r\ndev->stats.tx_packets++;\r\nnetif_wake_queue(dev);\r\nif ((status & ( TX_OK |\r\nTX_LOST_CRS |\r\nTX_SQE_ERROR |\r\nTX_LATE_COL |\r\nTX_16_COL)) != TX_OK) {\r\nif ((status & TX_OK) == 0)\r\ndev->stats.tx_errors++;\r\nif (status & TX_LOST_CRS)\r\ndev->stats.tx_carrier_errors++;\r\nif (status & TX_SQE_ERROR)\r\ndev->stats.tx_heartbeat_errors++;\r\nif (status & TX_LATE_COL)\r\ndev->stats.tx_window_errors++;\r\nif (status & TX_16_COL)\r\ndev->stats.tx_aborted_errors++;\r\n}\r\nbreak;\r\ncase ISQ_BUFFER_EVENT:\r\nif (status & READY_FOR_TX) {\r\nnetif_wake_queue(dev);\r\n}\r\nif (status & TX_UNDERRUN) {\r\nif (net_debug > 0) printk("%s: transmit underrun\n", dev->name);\r\nlp->send_underrun++;\r\nif (lp->send_underrun == 3) lp->send_cmd = TX_AFTER_381;\r\nelse if (lp->send_underrun == 6) lp->send_cmd = TX_AFTER_ALL;\r\nnetif_wake_queue(dev);\r\n}\r\n#if ALLOW_DMA\r\nif (lp->use_dma && (status & RX_DMA)) {\r\nint count = readreg(dev, PP_DmaFrameCnt);\r\nwhile(count) {\r\nif (net_debug > 5)\r\nprintk("%s: receiving %d DMA frames\n", dev->name, count);\r\nif (net_debug > 2 && count >1)\r\nprintk("%s: receiving %d DMA frames\n", dev->name, count);\r\ndma_rx(dev);\r\nif (--count == 0)\r\ncount = readreg(dev, PP_DmaFrameCnt);\r\nif (net_debug > 2 && count > 0)\r\nprintk("%s: continuing with %d DMA frames\n", dev->name, count);\r\n}\r\n}\r\n#endif\r\nbreak;\r\ncase ISQ_RX_MISS_EVENT:\r\ndev->stats.rx_missed_errors += (status >> 6);\r\nbreak;\r\ncase ISQ_TX_COL_EVENT:\r\ndev->stats.collisions += (status >> 6);\r\nbreak;\r\n}\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void\r\ncount_rx_errors(int status, struct net_device *dev)\r\n{\r\ndev->stats.rx_errors++;\r\nif (status & RX_RUNT)\r\ndev->stats.rx_length_errors++;\r\nif (status & RX_EXTRA_DATA)\r\ndev->stats.rx_length_errors++;\r\nif ((status & RX_CRC_ERROR) && !(status & (RX_EXTRA_DATA|RX_RUNT)))\r\ndev->stats.rx_crc_errors++;\r\nif (status & RX_DRIBBLE)\r\ndev->stats.rx_frame_errors++;\r\n}\r\nstatic void\r\nnet_rx(struct net_device *dev)\r\n{\r\nstruct sk_buff *skb;\r\nint status, length;\r\nint ioaddr = dev->base_addr;\r\nstatus = readword(ioaddr, RX_FRAME_PORT);\r\nlength = readword(ioaddr, RX_FRAME_PORT);\r\nif ((status & RX_OK) == 0) {\r\ncount_rx_errors(status, dev);\r\nreturn;\r\n}\r\nskb = dev_alloc_skb(length + 2);\r\nif (skb == NULL) {\r\n#if 0\r\nprintk(KERN_WARNING "%s: Memory squeeze, dropping packet.\n", dev->name);\r\n#endif\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb_reserve(skb, 2);\r\nreadwords(ioaddr, RX_FRAME_PORT, skb_put(skb, length), length >> 1);\r\nif (length & 1)\r\nskb->data[length-1] = readword(ioaddr, RX_FRAME_PORT);\r\nif (net_debug > 3) {\r\nprintk( "%s: received %d byte packet of type %x\n",\r\ndev->name, length,\r\n(skb->data[ETH_ALEN+ETH_ALEN] << 8) | skb->data[ETH_ALEN+ETH_ALEN+1]);\r\n}\r\nskb->protocol=eth_type_trans(skb,dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += length;\r\n}\r\nstatic void release_dma_buff(struct net_local *lp)\r\n{\r\nif (lp->dma_buff) {\r\nfree_pages((unsigned long)(lp->dma_buff), get_order(lp->dmasize * 1024));\r\nlp->dma_buff = NULL;\r\n}\r\n}\r\nstatic int\r\nnet_close(struct net_device *dev)\r\n{\r\n#if ALLOW_DMA\r\nstruct net_local *lp = netdev_priv(dev);\r\n#endif\r\nnetif_stop_queue(dev);\r\nwritereg(dev, PP_RxCFG, 0);\r\nwritereg(dev, PP_TxCFG, 0);\r\nwritereg(dev, PP_BufCFG, 0);\r\nwritereg(dev, PP_BusCTL, 0);\r\nfree_irq(dev->irq, dev);\r\n#if ALLOW_DMA\r\nif (lp->use_dma && lp->dma) {\r\nfree_dma(dev->dma);\r\nrelease_dma_buff(lp);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *\r\nnet_get_stats(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->lock, flags);\r\ndev->stats.rx_missed_errors += (readreg(dev, PP_RxMiss) >> 6);\r\ndev->stats.collisions += (readreg(dev, PP_TxCol) >> 6);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn &dev->stats;\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif(dev->flags&IFF_PROMISC)\r\n{\r\nlp->rx_mode = RX_ALL_ACCEPT;\r\n}\r\nelse if ((dev->flags & IFF_ALLMULTI) || !netdev_mc_empty(dev))\r\n{\r\nlp->rx_mode = RX_MULTCAST_ACCEPT;\r\n}\r\nelse\r\nlp->rx_mode = 0;\r\nwritereg(dev, PP_RxCTL, DEF_RX_ACCEPT | lp->rx_mode);\r\nwritereg(dev, PP_RxCFG, lp->curr_rx_cfg |\r\n(lp->rx_mode == RX_ALL_ACCEPT? (RX_CRC_ERROR_ENBL|RX_RUNT_ENBL|RX_EXTRA_DATA_ENBL) : 0));\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic int set_mac_address(struct net_device *dev, void *p)\r\n{\r\nint i;\r\nstruct sockaddr *addr = p;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nif (net_debug)\r\nprintk("%s: Setting MAC address to %pM.\n",\r\ndev->name, dev->dev_addr);\r\nfor (i=0; i < ETH_ALEN/2; i++)\r\nwritereg(dev, PP_IA+i*2, dev->dev_addr[i*2] | (dev->dev_addr[i*2+1] << 8));\r\nreturn 0;\r\n}\r\nint __init init_module(void)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct net_local));\r\nstruct net_local *lp;\r\nint ret = 0;\r\n#if DEBUGGING\r\nnet_debug = debug;\r\n#else\r\ndebug = 0;\r\n#endif\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->irq = irq;\r\ndev->base_addr = io;\r\nlp = netdev_priv(dev);\r\n#if ALLOW_DMA\r\nif (use_dma) {\r\nlp->use_dma = use_dma;\r\nlp->dma = dma;\r\nlp->dmasize = dmasize;\r\n}\r\n#endif\r\nspin_lock_init(&lp->lock);\r\nif (!strcmp(media, "rj45"))\r\nlp->adapter_cnf = A_CNF_MEDIA_10B_T | A_CNF_10B_T;\r\nelse if (!strcmp(media, "aui"))\r\nlp->adapter_cnf = A_CNF_MEDIA_AUI | A_CNF_AUI;\r\nelse if (!strcmp(media, "bnc"))\r\nlp->adapter_cnf = A_CNF_MEDIA_10B_2 | A_CNF_10B_2;\r\nelse\r\nlp->adapter_cnf = A_CNF_MEDIA_10B_T | A_CNF_10B_T;\r\nif (duplex==-1)\r\nlp->auto_neg_cnf = AUTO_NEG_ENABLE;\r\nif (io == 0) {\r\nprintk(KERN_ERR "cs89x0.c: Module autoprobing not allowed.\n");\r\nprintk(KERN_ERR "cs89x0.c: Append io=0xNNN\n");\r\nret = -EPERM;\r\ngoto out;\r\n} else if (io <= 0x1ff) {\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\n#if ALLOW_DMA\r\nif (use_dma && dmasize != 16 && dmasize != 64) {\r\nprintk(KERN_ERR "cs89x0.c: dma size must be either 16K or 64K, not %dK\n", dmasize);\r\nret = -EPERM;\r\ngoto out;\r\n}\r\n#endif\r\nret = cs89x0_probe1(dev, io, 1);\r\nif (ret)\r\ngoto out;\r\ndev_cs89x0 = dev;\r\nreturn 0;\r\nout:\r\nfree_netdev(dev);\r\nreturn ret;\r\n}\r\nvoid __exit\r\ncleanup_module(void)\r\n{\r\nunregister_netdev(dev_cs89x0);\r\nwriteword(dev_cs89x0->base_addr, ADD_PORT, PP_ChipID);\r\nrelease_region(dev_cs89x0->base_addr, NETCARD_IO_EXTENT);\r\nfree_netdev(dev_cs89x0);\r\n}
