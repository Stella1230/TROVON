void cx18_dma_free(struct videobuf_queue *q,\r\nstruct cx18_stream *s, struct cx18_videobuf_buffer *buf)\r\n{\r\nvideobuf_waiton(q, &buf->vb, 0, 0);\r\nvideobuf_vmalloc_free(&buf->vb);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int cx18_prepare_buffer(struct videobuf_queue *q,\r\nstruct cx18_stream *s,\r\nstruct cx18_videobuf_buffer *buf,\r\nu32 pixelformat,\r\nunsigned int width, unsigned int height,\r\nenum v4l2_field field)\r\n{\r\nstruct cx18 *cx = s->cx;\r\nint rc = 0;\r\nbuf->bytes_used = 0;\r\nif ((width < 48) || (height < 32))\r\nreturn -EINVAL;\r\nbuf->vb.size = (width * height * 2);\r\nif ((buf->vb.baddr != 0) && (buf->vb.bsize < buf->vb.size))\r\nreturn -EINVAL;\r\nif (buf->vb.width != width || buf->vb.height != height ||\r\nbuf->vb.field != field || s->pixelformat != pixelformat ||\r\nbuf->tvnorm != cx->std) {\r\nbuf->vb.width = width;\r\nbuf->vb.height = height;\r\nbuf->vb.field = field;\r\nbuf->tvnorm = cx->std;\r\ns->pixelformat = pixelformat;\r\nif (s->pixelformat == V4L2_PIX_FMT_HM12)\r\ns->vb_bytes_per_frame = height * 720 * 3 / 2;\r\nelse\r\ns->vb_bytes_per_frame = height * 720 * 2;\r\ncx18_dma_free(q, s, buf);\r\n}\r\nif ((buf->vb.baddr != 0) && (buf->vb.bsize < buf->vb.size))\r\nreturn -EINVAL;\r\nif (buf->vb.field == 0)\r\nbuf->vb.field = V4L2_FIELD_INTERLACED;\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\nbuf->vb.width = width;\r\nbuf->vb.height = height;\r\nbuf->vb.field = field;\r\nbuf->tvnorm = cx->std;\r\ns->pixelformat = pixelformat;\r\nif (s->pixelformat == V4L2_PIX_FMT_HM12)\r\ns->vb_bytes_per_frame = height * 720 * 3 / 2;\r\nelse\r\ns->vb_bytes_per_frame = height * 720 * 2;\r\nrc = videobuf_iolock(q, &buf->vb, NULL);\r\nif (rc != 0)\r\ngoto fail;\r\n}\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\ncx18_dma_free(q, s, buf);\r\nreturn rc;\r\n}\r\nstatic int buffer_setup(struct videobuf_queue *q,\r\nunsigned int *count, unsigned int *size)\r\n{\r\nstruct cx18_stream *s = q->priv_data;\r\nstruct cx18 *cx = s->cx;\r\n*size = 2 * cx->cxhdl.width * cx->cxhdl.height;\r\nif (*count == 0)\r\n*count = VB_MIN_BUFFERS;\r\nwhile (*size * *count > VB_MIN_BUFFERS * VB_MIN_BUFSIZE)\r\n(*count)--;\r\nq->field = V4L2_FIELD_INTERLACED;\r\nq->last = V4L2_FIELD_INTERLACED;\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct cx18_videobuf_buffer *buf =\r\ncontainer_of(vb, struct cx18_videobuf_buffer, vb);\r\nstruct cx18_stream *s = q->priv_data;\r\nstruct cx18 *cx = s->cx;\r\nreturn cx18_prepare_buffer(q, s, buf, s->pixelformat,\r\ncx->cxhdl.width, cx->cxhdl.height, field);\r\n}\r\nstatic void buffer_release(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct cx18_videobuf_buffer *buf =\r\ncontainer_of(vb, struct cx18_videobuf_buffer, vb);\r\nstruct cx18_stream *s = q->priv_data;\r\ncx18_dma_free(q, s, buf);\r\n}\r\nstatic void buffer_queue(struct videobuf_queue *q, struct videobuf_buffer *vb)\r\n{\r\nstruct cx18_videobuf_buffer *buf =\r\ncontainer_of(vb, struct cx18_videobuf_buffer, vb);\r\nstruct cx18_stream *s = q->priv_data;\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&buf->vb.queue, &s->vb_capture);\r\n}\r\nstatic void cx18_stream_init(struct cx18 *cx, int type)\r\n{\r\nstruct cx18_stream *s = &cx->streams[type];\r\nstruct video_device *video_dev = s->video_dev;\r\nmemset(s, 0, sizeof(*s));\r\ns->video_dev = video_dev;\r\ns->dvb = NULL;\r\ns->cx = cx;\r\ns->type = type;\r\ns->name = cx18_stream_info[type].name;\r\ns->handle = CX18_INVALID_TASK_HANDLE;\r\ns->dma = cx18_stream_info[type].dma;\r\ns->buffers = cx->stream_buffers[type];\r\ns->buf_size = cx->stream_buf_size[type];\r\nINIT_LIST_HEAD(&s->buf_pool);\r\ns->bufs_per_mdl = 1;\r\ns->mdl_size = s->buf_size * s->bufs_per_mdl;\r\ninit_waitqueue_head(&s->waitq);\r\ns->id = -1;\r\nspin_lock_init(&s->q_free.lock);\r\ncx18_queue_init(&s->q_free);\r\nspin_lock_init(&s->q_busy.lock);\r\ncx18_queue_init(&s->q_busy);\r\nspin_lock_init(&s->q_full.lock);\r\ncx18_queue_init(&s->q_full);\r\nspin_lock_init(&s->q_idle.lock);\r\ncx18_queue_init(&s->q_idle);\r\nINIT_WORK(&s->out_work_order, cx18_out_work_handler);\r\nINIT_LIST_HEAD(&s->vb_capture);\r\ns->vb_timeout.function = cx18_vb_timeout;\r\ns->vb_timeout.data = (unsigned long)s;\r\ninit_timer(&s->vb_timeout);\r\nspin_lock_init(&s->vb_lock);\r\nif (type == CX18_ENC_STREAM_TYPE_YUV) {\r\nspin_lock_init(&s->vbuf_q_lock);\r\ns->vb_type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nvideobuf_queue_vmalloc_init(&s->vbuf_q, &cx18_videobuf_qops,\r\n&cx->pci_dev->dev, &s->vbuf_q_lock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_INTERLACED,\r\nsizeof(struct cx18_videobuf_buffer),\r\ns, &cx->serialize_lock);\r\ns->pixelformat = V4L2_PIX_FMT_HM12;\r\ns->vb_bytes_per_frame = cx->cxhdl.height * 720 * 3 / 2;\r\n}\r\n}\r\nstatic int cx18_prep_dev(struct cx18 *cx, int type)\r\n{\r\nstruct cx18_stream *s = &cx->streams[type];\r\nu32 cap = cx->v4l2_cap;\r\nint num_offset = cx18_stream_info[type].num_offset;\r\nint num = cx->instance + cx18_first_minor + num_offset;\r\ns->video_dev = NULL;\r\ns->dvb = NULL;\r\ns->cx = cx;\r\ns->type = type;\r\ns->name = cx18_stream_info[type].name;\r\nif (type == CX18_ENC_STREAM_TYPE_RAD && !(cap & V4L2_CAP_RADIO))\r\nreturn 0;\r\nif (type == CX18_ENC_STREAM_TYPE_VBI &&\r\n!(cap & (V4L2_CAP_VBI_CAPTURE | V4L2_CAP_SLICED_VBI_CAPTURE)))\r\nreturn 0;\r\nif (cx18_stream_info[type].dma != PCI_DMA_NONE &&\r\ncx->stream_buffers[type] == 0) {\r\nCX18_INFO("Disabled %s device\n", cx18_stream_info[type].name);\r\nreturn 0;\r\n}\r\ncx18_stream_init(cx, type);\r\nif (type == CX18_ENC_STREAM_TYPE_TS) {\r\nif (cx->card->hw_all & CX18_HW_DVB) {\r\ns->dvb = kzalloc(sizeof(struct cx18_dvb), GFP_KERNEL);\r\nif (s->dvb == NULL) {\r\nCX18_ERR("Couldn't allocate cx18_dvb structure"\r\n" for %s\n", s->name);\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\ns->buffers = 0;\r\n}\r\n}\r\nif (num_offset == -1)\r\nreturn 0;\r\ns->video_dev = video_device_alloc();\r\nif (s->video_dev == NULL) {\r\nCX18_ERR("Couldn't allocate v4l2 video_device for %s\n",\r\ns->name);\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(s->video_dev->name, sizeof(s->video_dev->name), "%s %s",\r\ncx->v4l2_dev.name, s->name);\r\ns->video_dev->num = num;\r\ns->video_dev->v4l2_dev = &cx->v4l2_dev;\r\ns->video_dev->fops = &cx18_v4l2_enc_fops;\r\ns->video_dev->release = video_device_release;\r\ns->video_dev->tvnorms = V4L2_STD_ALL;\r\nset_bit(V4L2_FL_USE_FH_PRIO, &s->video_dev->flags);\r\ncx18_set_funcs(s->video_dev);\r\nreturn 0;\r\n}\r\nint cx18_streams_setup(struct cx18 *cx)\r\n{\r\nint type, ret;\r\nfor (type = 0; type < CX18_MAX_STREAMS; type++) {\r\nret = cx18_prep_dev(cx, type);\r\nif (ret < 0)\r\nbreak;\r\nret = cx18_stream_alloc(&cx->streams[type]);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nif (type == CX18_MAX_STREAMS)\r\nreturn 0;\r\ncx18_streams_cleanup(cx, 0);\r\nreturn ret;\r\n}\r\nstatic int cx18_reg_dev(struct cx18 *cx, int type)\r\n{\r\nstruct cx18_stream *s = &cx->streams[type];\r\nint vfl_type = cx18_stream_info[type].vfl_type;\r\nconst char *name;\r\nint num, ret;\r\nif (type == CX18_ENC_STREAM_TYPE_TS && s->dvb != NULL) {\r\nret = cx18_dvb_register(s);\r\nif (ret < 0) {\r\nCX18_ERR("DVB failed to register\n");\r\nreturn ret;\r\n}\r\n}\r\nif (s->video_dev == NULL)\r\nreturn 0;\r\nnum = s->video_dev->num;\r\nif (type != CX18_ENC_STREAM_TYPE_MPG) {\r\nstruct cx18_stream *s_mpg = &cx->streams[CX18_ENC_STREAM_TYPE_MPG];\r\nif (s_mpg->video_dev)\r\nnum = s_mpg->video_dev->num\r\n+ cx18_stream_info[type].num_offset;\r\n}\r\nvideo_set_drvdata(s->video_dev, s);\r\nret = video_register_device_no_warn(s->video_dev, vfl_type, num);\r\nif (ret < 0) {\r\nCX18_ERR("Couldn't register v4l2 device for %s (device node number %d)\n",\r\ns->name, num);\r\nvideo_device_release(s->video_dev);\r\ns->video_dev = NULL;\r\nreturn ret;\r\n}\r\nname = video_device_node_name(s->video_dev);\r\nswitch (vfl_type) {\r\ncase VFL_TYPE_GRABBER:\r\nCX18_INFO("Registered device %s for %s (%d x %d.%02d kB)\n",\r\nname, s->name, cx->stream_buffers[type],\r\ncx->stream_buf_size[type] / 1024,\r\n(cx->stream_buf_size[type] * 100 / 1024) % 100);\r\nbreak;\r\ncase VFL_TYPE_RADIO:\r\nCX18_INFO("Registered device %s for %s\n", name, s->name);\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\nif (cx->stream_buffers[type])\r\nCX18_INFO("Registered device %s for %s "\r\n"(%d x %d bytes)\n",\r\nname, s->name, cx->stream_buffers[type],\r\ncx->stream_buf_size[type]);\r\nelse\r\nCX18_INFO("Registered device %s for %s\n",\r\nname, s->name);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint cx18_streams_register(struct cx18 *cx)\r\n{\r\nint type;\r\nint err;\r\nint ret = 0;\r\nfor (type = 0; type < CX18_MAX_STREAMS; type++) {\r\nerr = cx18_reg_dev(cx, type);\r\nif (err && ret == 0)\r\nret = err;\r\n}\r\nif (ret == 0)\r\nreturn 0;\r\ncx18_streams_cleanup(cx, 1);\r\nreturn ret;\r\n}\r\nvoid cx18_streams_cleanup(struct cx18 *cx, int unregister)\r\n{\r\nstruct video_device *vdev;\r\nint type;\r\nfor (type = 0; type < CX18_MAX_STREAMS; type++) {\r\nif (type == CX18_ENC_STREAM_TYPE_TS) {\r\nif (cx->streams[type].dvb != NULL) {\r\nif (unregister)\r\ncx18_dvb_unregister(&cx->streams[type]);\r\nkfree(cx->streams[type].dvb);\r\ncx->streams[type].dvb = NULL;\r\ncx18_stream_free(&cx->streams[type]);\r\n}\r\ncontinue;\r\n}\r\nif (type == CX18_ENC_STREAM_TYPE_IDX) {\r\nif (cx->stream_buffers[type] != 0) {\r\ncx->stream_buffers[type] = 0;\r\nif (cx->streams[type].buffers != 0)\r\ncx18_stream_free(&cx->streams[type]);\r\n}\r\ncontinue;\r\n}\r\nvdev = cx->streams[type].video_dev;\r\ncx->streams[type].video_dev = NULL;\r\nif (vdev == NULL)\r\ncontinue;\r\nif (type == CX18_ENC_STREAM_TYPE_YUV)\r\nvideobuf_mmap_free(&cx->streams[type].vbuf_q);\r\ncx18_stream_free(&cx->streams[type]);\r\nif (unregister)\r\nvideo_unregister_device(vdev);\r\nelse\r\nvideo_device_release(vdev);\r\n}\r\n}\r\nstatic void cx18_vbi_setup(struct cx18_stream *s)\r\n{\r\nstruct cx18 *cx = s->cx;\r\nint raw = cx18_raw_vbi(cx);\r\nu32 data[CX2341X_MBOX_MAX_DATA];\r\nint lines;\r\nif (cx->is_60hz) {\r\ncx->vbi.count = 12;\r\ncx->vbi.start[0] = 10;\r\ncx->vbi.start[1] = 273;\r\n} else {\r\ncx->vbi.count = 18;\r\ncx->vbi.start[0] = 6;\r\ncx->vbi.start[1] = 318;\r\n}\r\nif (raw)\r\nv4l2_subdev_call(cx->sd_av, vbi, s_raw_fmt, &cx->vbi.in.fmt.vbi);\r\nelse\r\nv4l2_subdev_call(cx->sd_av, vbi, s_sliced_fmt, &cx->vbi.in.fmt.sliced);\r\nif (raw) {\r\nlines = cx->vbi.count * 2;\r\n} else {\r\nlines = cx->is_60hz ? (21 - 4 + 1) * 2 : (23 - 2 + 1) * 2;\r\n}\r\ndata[0] = s->handle;\r\ndata[1] = (lines / 2) | ((lines / 2) << 16);\r\ndata[2] = (raw ? vbi_active_samples\r\n: (cx->is_60hz ? vbi_hblank_samples_60Hz\r\n: vbi_hblank_samples_50Hz));\r\ndata[3] = 1;\r\nif (raw) {\r\ndata[4] = 0x20602060;\r\ndata[5] = 0x307090d0;\r\n} else {\r\ndata[4] = 0xB0F0B0F0;\r\ndata[5] = 0xA0E0A0E0;\r\n}\r\nCX18_DEBUG_INFO("Setup VBI h: %d lines %x bpl %d fr %d %x %x\n",\r\ndata[0], data[1], data[2], data[3], data[4], data[5]);\r\ncx18_api(cx, CX18_CPU_SET_RAW_VBI_PARAM, 6, data);\r\n}\r\nvoid cx18_stream_rotate_idx_mdls(struct cx18 *cx)\r\n{\r\nstruct cx18_stream *s = &cx->streams[CX18_ENC_STREAM_TYPE_IDX];\r\nstruct cx18_mdl *mdl;\r\nif (!cx18_stream_enabled(s))\r\nreturn;\r\nif ((atomic_read(&s->q_free.depth) + atomic_read(&s->q_busy.depth)) >=\r\nCX18_ENC_STREAM_TYPE_IDX_FW_MDL_MIN)\r\nreturn;\r\nif (atomic_read(&s->q_full.depth) < 2)\r\nreturn;\r\nmdl = cx18_dequeue(s, &s->q_full);\r\nif (mdl != NULL)\r\ncx18_enqueue(s, mdl, &s->q_free);\r\n}\r\nstatic\r\nstruct cx18_queue *_cx18_stream_put_mdl_fw(struct cx18_stream *s,\r\nstruct cx18_mdl *mdl)\r\n{\r\nstruct cx18 *cx = s->cx;\r\nstruct cx18_queue *q;\r\nif (s->handle == CX18_INVALID_TASK_HANDLE ||\r\ntest_bit(CX18_F_S_STOPPING, &s->s_flags) ||\r\n!test_bit(CX18_F_S_STREAMING, &s->s_flags))\r\nreturn cx18_enqueue(s, mdl, &s->q_free);\r\nq = cx18_enqueue(s, mdl, &s->q_busy);\r\nif (q != &s->q_busy)\r\nreturn q;\r\ncx18_mdl_sync_for_device(s, mdl);\r\ncx18_vapi(cx, CX18_CPU_DE_SET_MDL, 5, s->handle,\r\n(void __iomem *) &cx->scb->cpu_mdl[mdl->id] - cx->enc_mem,\r\ns->bufs_per_mdl, mdl->id, s->mdl_size);\r\nreturn q;\r\n}\r\nstatic\r\nvoid _cx18_stream_load_fw_queue(struct cx18_stream *s)\r\n{\r\nstruct cx18_queue *q;\r\nstruct cx18_mdl *mdl;\r\nif (atomic_read(&s->q_free.depth) == 0 ||\r\natomic_read(&s->q_busy.depth) >= CX18_MAX_FW_MDLS_PER_STREAM)\r\nreturn;\r\ndo {\r\nmdl = cx18_dequeue(s, &s->q_free);\r\nif (mdl == NULL)\r\nbreak;\r\nq = _cx18_stream_put_mdl_fw(s, mdl);\r\n} while (atomic_read(&s->q_busy.depth) < CX18_MAX_FW_MDLS_PER_STREAM\r\n&& q == &s->q_busy);\r\n}\r\nvoid cx18_out_work_handler(struct work_struct *work)\r\n{\r\nstruct cx18_stream *s =\r\ncontainer_of(work, struct cx18_stream, out_work_order);\r\n_cx18_stream_load_fw_queue(s);\r\n}\r\nstatic void cx18_stream_configure_mdls(struct cx18_stream *s)\r\n{\r\ncx18_unload_queues(s);\r\nswitch (s->type) {\r\ncase CX18_ENC_STREAM_TYPE_YUV:\r\nif (s->pixelformat == V4L2_PIX_FMT_HM12)\r\ns->mdl_size = 720 * s->cx->cxhdl.height * 3 / 2;\r\nelse\r\ns->mdl_size = 720 * s->cx->cxhdl.height * 2;\r\ns->bufs_per_mdl = s->mdl_size / s->buf_size;\r\nif (s->mdl_size % s->buf_size)\r\ns->bufs_per_mdl++;\r\nbreak;\r\ncase CX18_ENC_STREAM_TYPE_VBI:\r\ns->bufs_per_mdl = 1;\r\nif (cx18_raw_vbi(s->cx)) {\r\ns->mdl_size = (s->cx->is_60hz ? 12 : 18)\r\n* 2 * vbi_active_samples;\r\n} else {\r\ns->mdl_size = s->cx->is_60hz\r\n? (21 - 4 + 1) * 2 * vbi_hblank_samples_60Hz\r\n: (23 - 2 + 1) * 2 * vbi_hblank_samples_50Hz;\r\n}\r\nbreak;\r\ndefault:\r\ns->bufs_per_mdl = 1;\r\ns->mdl_size = s->buf_size * s->bufs_per_mdl;\r\nbreak;\r\n}\r\ncx18_load_queues(s);\r\n}\r\nint cx18_start_v4l2_encode_stream(struct cx18_stream *s)\r\n{\r\nu32 data[MAX_MB_ARGUMENTS];\r\nstruct cx18 *cx = s->cx;\r\nint captype = 0;\r\nstruct cx18_stream *s_idx;\r\nif (!cx18_stream_enabled(s))\r\nreturn -EINVAL;\r\nCX18_DEBUG_INFO("Start encoder stream %s\n", s->name);\r\nswitch (s->type) {\r\ncase CX18_ENC_STREAM_TYPE_MPG:\r\ncaptype = CAPTURE_CHANNEL_TYPE_MPEG;\r\ncx->mpg_data_received = cx->vbi_data_inserted = 0;\r\ncx->dualwatch_jiffies = jiffies;\r\ncx->dualwatch_stereo_mode = v4l2_ctrl_g_ctrl(cx->cxhdl.audio_mode);\r\ncx->search_pack_header = 0;\r\nbreak;\r\ncase CX18_ENC_STREAM_TYPE_IDX:\r\ncaptype = CAPTURE_CHANNEL_TYPE_INDEX;\r\nbreak;\r\ncase CX18_ENC_STREAM_TYPE_TS:\r\ncaptype = CAPTURE_CHANNEL_TYPE_TS;\r\nbreak;\r\ncase CX18_ENC_STREAM_TYPE_YUV:\r\ncaptype = CAPTURE_CHANNEL_TYPE_YUV;\r\nbreak;\r\ncase CX18_ENC_STREAM_TYPE_PCM:\r\ncaptype = CAPTURE_CHANNEL_TYPE_PCM;\r\nbreak;\r\ncase CX18_ENC_STREAM_TYPE_VBI:\r\n#ifdef CX18_ENCODER_PARSES_SLICED\r\ncaptype = cx18_raw_vbi(cx) ?\r\nCAPTURE_CHANNEL_TYPE_VBI : CAPTURE_CHANNEL_TYPE_SLICED_VBI;\r\n#else\r\ncaptype = CAPTURE_CHANNEL_TYPE_VBI;\r\n#endif\r\ncx->vbi.frame = 0;\r\ncx->vbi.inserted_frame = 0;\r\nmemset(cx->vbi.sliced_mpeg_size,\r\n0, sizeof(cx->vbi.sliced_mpeg_size));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nclear_bit(CX18_F_S_STREAMOFF, &s->s_flags);\r\ncx18_vapi_result(cx, data, CX18_CREATE_TASK, 1, CPU_CMD_MASK_CAPTURE);\r\ns->handle = data[0];\r\ncx18_vapi(cx, CX18_CPU_SET_CHANNEL_TYPE, 2, s->handle, captype);\r\nif (captype != CAPTURE_CHANNEL_TYPE_TS) {\r\ncx18_vapi(cx, CX18_CPU_SET_VER_CROP_LINE, 2, s->handle, 0);\r\ncx18_vapi(cx, CX18_CPU_SET_MISC_PARAMETERS, 3, s->handle, 3, 1);\r\ncx18_vapi(cx, CX18_CPU_SET_MISC_PARAMETERS, 3, s->handle, 8, 0);\r\ncx18_vapi(cx, CX18_CPU_SET_MISC_PARAMETERS, 3, s->handle, 4, 1);\r\nif (atomic_read(&cx->ana_capturing) == 0)\r\ncx18_vapi(cx, CX18_CPU_SET_MISC_PARAMETERS, 2,\r\ns->handle, 12);\r\ncx18_vapi(cx, CX18_CPU_SET_CAPTURE_LINE_NO, 3,\r\ns->handle, 312, 313);\r\nif (cx->v4l2_cap & V4L2_CAP_VBI_CAPTURE)\r\ncx18_vbi_setup(s);\r\ns_idx = &cx->streams[CX18_ENC_STREAM_TYPE_IDX];\r\ncx18_vapi_result(cx, data, CX18_CPU_SET_INDEXTABLE, 2,\r\ns->handle, cx18_stream_enabled(s_idx) ? 7 : 0);\r\ncx->cxhdl.priv = s;\r\ncx2341x_handler_setup(&cx->cxhdl);\r\nif (!cx->cxhdl.video_mute &&\r\ntest_bit(CX18_F_I_RADIO_USER, &cx->i_flags))\r\ncx18_vapi(cx, CX18_CPU_SET_VIDEO_MUTE, 2, s->handle,\r\n(v4l2_ctrl_g_ctrl(cx->cxhdl.video_mute_yuv) << 8) | 1);\r\nif (captype == CAPTURE_CHANNEL_TYPE_YUV) {\r\nif (s->pixelformat == V4L2_PIX_FMT_UYVY)\r\ncx18_vapi(cx, CX18_CPU_SET_VFC_PARAM, 2,\r\ns->handle, 1);\r\nelse\r\ncx18_vapi(cx, CX18_CPU_SET_VFC_PARAM, 2,\r\ns->handle, 0);\r\n}\r\n}\r\nif (atomic_read(&cx->tot_capturing) == 0) {\r\ncx2341x_handler_set_busy(&cx->cxhdl, 1);\r\nclear_bit(CX18_F_I_EOS, &cx->i_flags);\r\ncx18_write_reg(cx, 7, CX18_DSP0_INTERRUPT_MASK);\r\n}\r\ncx18_vapi(cx, CX18_CPU_DE_SET_MDL_ACK, 3, s->handle,\r\n(void __iomem *)&cx->scb->cpu_mdl_ack[s->type][0] - cx->enc_mem,\r\n(void __iomem *)&cx->scb->cpu_mdl_ack[s->type][1] - cx->enc_mem);\r\ncx18_stream_configure_mdls(s);\r\n_cx18_stream_load_fw_queue(s);\r\nif (cx18_vapi(cx, CX18_CPU_CAPTURE_START, 1, s->handle)) {\r\nCX18_DEBUG_WARN("Error starting capture!\n");\r\nset_bit(CX18_F_S_STOPPING, &s->s_flags);\r\nif (s->type == CX18_ENC_STREAM_TYPE_MPG)\r\ncx18_vapi(cx, CX18_CPU_CAPTURE_STOP, 2, s->handle, 1);\r\nelse\r\ncx18_vapi(cx, CX18_CPU_CAPTURE_STOP, 1, s->handle);\r\nclear_bit(CX18_F_S_STREAMING, &s->s_flags);\r\ncx18_vapi(cx, CX18_CPU_DE_RELEASE_MDL, 1, s->handle);\r\ncx18_vapi(cx, CX18_DESTROY_TASK, 1, s->handle);\r\ns->handle = CX18_INVALID_TASK_HANDLE;\r\nclear_bit(CX18_F_S_STOPPING, &s->s_flags);\r\nif (atomic_read(&cx->tot_capturing) == 0) {\r\nset_bit(CX18_F_I_EOS, &cx->i_flags);\r\ncx18_write_reg(cx, 5, CX18_DSP0_INTERRUPT_MASK);\r\n}\r\nreturn -EINVAL;\r\n}\r\nif (captype != CAPTURE_CHANNEL_TYPE_TS)\r\natomic_inc(&cx->ana_capturing);\r\natomic_inc(&cx->tot_capturing);\r\nreturn 0;\r\n}\r\nvoid cx18_stop_all_captures(struct cx18 *cx)\r\n{\r\nint i;\r\nfor (i = CX18_MAX_STREAMS - 1; i >= 0; i--) {\r\nstruct cx18_stream *s = &cx->streams[i];\r\nif (!cx18_stream_enabled(s))\r\ncontinue;\r\nif (test_bit(CX18_F_S_STREAMING, &s->s_flags))\r\ncx18_stop_v4l2_encode_stream(s, 0);\r\n}\r\n}\r\nint cx18_stop_v4l2_encode_stream(struct cx18_stream *s, int gop_end)\r\n{\r\nstruct cx18 *cx = s->cx;\r\nunsigned long then;\r\nif (!cx18_stream_enabled(s))\r\nreturn -EINVAL;\r\nCX18_DEBUG_INFO("Stop Capture\n");\r\nif (atomic_read(&cx->tot_capturing) == 0)\r\nreturn 0;\r\nset_bit(CX18_F_S_STOPPING, &s->s_flags);\r\nif (s->type == CX18_ENC_STREAM_TYPE_MPG)\r\ncx18_vapi(cx, CX18_CPU_CAPTURE_STOP, 2, s->handle, !gop_end);\r\nelse\r\ncx18_vapi(cx, CX18_CPU_CAPTURE_STOP, 1, s->handle);\r\nthen = jiffies;\r\nif (s->type == CX18_ENC_STREAM_TYPE_MPG && gop_end) {\r\nCX18_INFO("ignoring gop_end: not (yet?) supported by the firmware\n");\r\n}\r\nif (s->type != CX18_ENC_STREAM_TYPE_TS)\r\natomic_dec(&cx->ana_capturing);\r\natomic_dec(&cx->tot_capturing);\r\nclear_bit(CX18_F_S_STREAMING, &s->s_flags);\r\ncx18_vapi(cx, CX18_CPU_DE_RELEASE_MDL, 1, s->handle);\r\ncx18_vapi(cx, CX18_DESTROY_TASK, 1, s->handle);\r\ns->handle = CX18_INVALID_TASK_HANDLE;\r\nclear_bit(CX18_F_S_STOPPING, &s->s_flags);\r\nif (atomic_read(&cx->tot_capturing) > 0)\r\nreturn 0;\r\ncx2341x_handler_set_busy(&cx->cxhdl, 0);\r\ncx18_write_reg(cx, 5, CX18_DSP0_INTERRUPT_MASK);\r\nwake_up(&s->waitq);\r\nreturn 0;\r\n}\r\nu32 cx18_find_handle(struct cx18 *cx)\r\n{\r\nint i;\r\nfor (i = 0; i < CX18_MAX_STREAMS; i++) {\r\nstruct cx18_stream *s = &cx->streams[i];\r\nif (s->video_dev && (s->handle != CX18_INVALID_TASK_HANDLE))\r\nreturn s->handle;\r\n}\r\nreturn CX18_INVALID_TASK_HANDLE;\r\n}\r\nstruct cx18_stream *cx18_handle_to_stream(struct cx18 *cx, u32 handle)\r\n{\r\nint i;\r\nstruct cx18_stream *s;\r\nif (handle == CX18_INVALID_TASK_HANDLE)\r\nreturn NULL;\r\nfor (i = 0; i < CX18_MAX_STREAMS; i++) {\r\ns = &cx->streams[i];\r\nif (s->handle != handle)\r\ncontinue;\r\nif (cx18_stream_enabled(s))\r\nreturn s;\r\n}\r\nreturn NULL;\r\n}
