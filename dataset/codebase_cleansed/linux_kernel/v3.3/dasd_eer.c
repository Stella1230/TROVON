static int dasd_eer_get_free_bytes(struct eerbuffer *eerb)\r\n{\r\nif (eerb->head < eerb->tail)\r\nreturn eerb->tail - eerb->head - 1;\r\nreturn eerb->buffersize - eerb->head + eerb->tail -1;\r\n}\r\nstatic int dasd_eer_get_filled_bytes(struct eerbuffer *eerb)\r\n{\r\nif (eerb->head >= eerb->tail)\r\nreturn eerb->head - eerb->tail;\r\nreturn eerb->buffersize - eerb->tail + eerb->head;\r\n}\r\nstatic void dasd_eer_write_buffer(struct eerbuffer *eerb,\r\nchar *data, int count)\r\n{\r\nunsigned long headindex,localhead;\r\nunsigned long rest, len;\r\nchar *nextdata;\r\nnextdata = data;\r\nrest = count;\r\nwhile (rest > 0) {\r\nheadindex = eerb->head / PAGE_SIZE;\r\nlocalhead = eerb->head % PAGE_SIZE;\r\nlen = min(rest, PAGE_SIZE - localhead);\r\nmemcpy(eerb->buffer[headindex]+localhead, nextdata, len);\r\nnextdata += len;\r\nrest -= len;\r\neerb->head += len;\r\nif (eerb->head == eerb->buffersize)\r\neerb->head = 0;\r\nBUG_ON(eerb->head > eerb->buffersize);\r\n}\r\n}\r\nstatic int dasd_eer_read_buffer(struct eerbuffer *eerb, char *data, int count)\r\n{\r\nunsigned long tailindex,localtail;\r\nunsigned long rest, len, finalcount;\r\nchar *nextdata;\r\nfinalcount = min(count, dasd_eer_get_filled_bytes(eerb));\r\nnextdata = data;\r\nrest = finalcount;\r\nwhile (rest > 0) {\r\ntailindex = eerb->tail / PAGE_SIZE;\r\nlocaltail = eerb->tail % PAGE_SIZE;\r\nlen = min(rest, PAGE_SIZE - localtail);\r\nmemcpy(nextdata, eerb->buffer[tailindex] + localtail, len);\r\nnextdata += len;\r\nrest -= len;\r\neerb->tail += len;\r\nif (eerb->tail == eerb->buffersize)\r\neerb->tail = 0;\r\nBUG_ON(eerb->tail > eerb->buffersize);\r\n}\r\nreturn finalcount;\r\n}\r\nstatic int dasd_eer_start_record(struct eerbuffer *eerb, int count)\r\n{\r\nint tailcount;\r\nif (count + sizeof(count) > eerb->buffersize)\r\nreturn -ENOMEM;\r\nwhile (dasd_eer_get_free_bytes(eerb) < count + sizeof(count)) {\r\nif (eerb->residual > 0) {\r\neerb->tail += eerb->residual;\r\nif (eerb->tail >= eerb->buffersize)\r\neerb->tail -= eerb->buffersize;\r\neerb->residual = -1;\r\n}\r\ndasd_eer_read_buffer(eerb, (char *) &tailcount,\r\nsizeof(tailcount));\r\neerb->tail += tailcount;\r\nif (eerb->tail >= eerb->buffersize)\r\neerb->tail -= eerb->buffersize;\r\n}\r\ndasd_eer_write_buffer(eerb, (char*) &count, sizeof(count));\r\nreturn 0;\r\n}\r\nstatic void dasd_eer_free_buffer_pages(char **buf, int no_pages)\r\n{\r\nint i;\r\nfor (i = 0; i < no_pages; i++)\r\nfree_page((unsigned long) buf[i]);\r\n}\r\nstatic int dasd_eer_allocate_buffer_pages(char **buf, int no_pages)\r\n{\r\nint i;\r\nfor (i = 0; i < no_pages; i++) {\r\nbuf[i] = (char *) get_zeroed_page(GFP_KERNEL);\r\nif (!buf[i]) {\r\ndasd_eer_free_buffer_pages(buf, i);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void dasd_eer_write_standard_trigger(struct dasd_device *device,\r\nstruct dasd_ccw_req *cqr,\r\nint trigger)\r\n{\r\nstruct dasd_ccw_req *temp_cqr;\r\nint data_size;\r\nstruct timeval tv;\r\nstruct dasd_eer_header header;\r\nunsigned long flags;\r\nstruct eerbuffer *eerb;\r\nchar *sense;\r\ndata_size = 0;\r\nfor (temp_cqr = cqr; temp_cqr; temp_cqr = temp_cqr->refers)\r\nif (dasd_get_sense(&temp_cqr->irb))\r\ndata_size += 32;\r\nheader.total_size = sizeof(header) + data_size + 4;\r\nheader.trigger = trigger;\r\ndo_gettimeofday(&tv);\r\nheader.tv_sec = tv.tv_sec;\r\nheader.tv_usec = tv.tv_usec;\r\nstrncpy(header.busid, dev_name(&device->cdev->dev),\r\nDASD_EER_BUSID_SIZE);\r\nspin_lock_irqsave(&bufferlock, flags);\r\nlist_for_each_entry(eerb, &bufferlist, list) {\r\ndasd_eer_start_record(eerb, header.total_size);\r\ndasd_eer_write_buffer(eerb, (char *) &header, sizeof(header));\r\nfor (temp_cqr = cqr; temp_cqr; temp_cqr = temp_cqr->refers) {\r\nsense = dasd_get_sense(&temp_cqr->irb);\r\nif (sense)\r\ndasd_eer_write_buffer(eerb, sense, 32);\r\n}\r\ndasd_eer_write_buffer(eerb, "EOR", 4);\r\n}\r\nspin_unlock_irqrestore(&bufferlock, flags);\r\nwake_up_interruptible(&dasd_eer_read_wait_queue);\r\n}\r\nstatic void dasd_eer_write_snss_trigger(struct dasd_device *device,\r\nstruct dasd_ccw_req *cqr,\r\nint trigger)\r\n{\r\nint data_size;\r\nint snss_rc;\r\nstruct timeval tv;\r\nstruct dasd_eer_header header;\r\nunsigned long flags;\r\nstruct eerbuffer *eerb;\r\nsnss_rc = (cqr->status == DASD_CQR_DONE) ? 0 : -EIO;\r\nif (snss_rc)\r\ndata_size = 0;\r\nelse\r\ndata_size = SNSS_DATA_SIZE;\r\nheader.total_size = sizeof(header) + data_size + 4;\r\nheader.trigger = DASD_EER_STATECHANGE;\r\ndo_gettimeofday(&tv);\r\nheader.tv_sec = tv.tv_sec;\r\nheader.tv_usec = tv.tv_usec;\r\nstrncpy(header.busid, dev_name(&device->cdev->dev),\r\nDASD_EER_BUSID_SIZE);\r\nspin_lock_irqsave(&bufferlock, flags);\r\nlist_for_each_entry(eerb, &bufferlist, list) {\r\ndasd_eer_start_record(eerb, header.total_size);\r\ndasd_eer_write_buffer(eerb, (char *) &header , sizeof(header));\r\nif (!snss_rc)\r\ndasd_eer_write_buffer(eerb, cqr->data, SNSS_DATA_SIZE);\r\ndasd_eer_write_buffer(eerb, "EOR", 4);\r\n}\r\nspin_unlock_irqrestore(&bufferlock, flags);\r\nwake_up_interruptible(&dasd_eer_read_wait_queue);\r\n}\r\nvoid dasd_eer_write(struct dasd_device *device, struct dasd_ccw_req *cqr,\r\nunsigned int id)\r\n{\r\nif (!device->eer_cqr)\r\nreturn;\r\nswitch (id) {\r\ncase DASD_EER_FATALERROR:\r\ncase DASD_EER_PPRCSUSPEND:\r\ndasd_eer_write_standard_trigger(device, cqr, id);\r\nbreak;\r\ncase DASD_EER_NOPATH:\r\ndasd_eer_write_standard_trigger(device, NULL, id);\r\nbreak;\r\ncase DASD_EER_STATECHANGE:\r\ndasd_eer_write_snss_trigger(device, cqr, id);\r\nbreak;\r\ndefault:\r\ndasd_eer_write_standard_trigger(device, NULL, id);\r\nbreak;\r\n}\r\n}\r\nvoid dasd_eer_snss(struct dasd_device *device)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\ncqr = device->eer_cqr;\r\nif (!cqr)\r\nreturn;\r\nif (test_and_set_bit(DASD_FLAG_EER_IN_USE, &device->flags)) {\r\nset_bit(DASD_FLAG_EER_SNSS, &device->flags);\r\nreturn;\r\n}\r\nclear_bit(DASD_FLAG_EER_SNSS, &device->flags);\r\ncqr->status = DASD_CQR_QUEUED;\r\nlist_add(&cqr->devlist, &device->ccw_queue);\r\ndasd_schedule_device_bh(device);\r\n}\r\nstatic void dasd_eer_snss_cb(struct dasd_ccw_req *cqr, void *data)\r\n{\r\nstruct dasd_device *device = cqr->startdev;\r\nunsigned long flags;\r\ndasd_eer_write(device, cqr, DASD_EER_STATECHANGE);\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\nif (device->eer_cqr == cqr) {\r\nclear_bit(DASD_FLAG_EER_IN_USE, &device->flags);\r\nif (test_bit(DASD_FLAG_EER_SNSS, &device->flags))\r\ndasd_eer_snss(device);\r\ncqr = NULL;\r\n}\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\nif (cqr)\r\ndasd_kfree_request(cqr, device);\r\n}\r\nint dasd_eer_enable(struct dasd_device *device)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nunsigned long flags;\r\nstruct ccw1 *ccw;\r\nif (device->eer_cqr)\r\nreturn 0;\r\nif (!device->discipline || strcmp(device->discipline->name, "ECKD"))\r\nreturn -EPERM;\r\ncqr = dasd_kmalloc_request(DASD_ECKD_MAGIC, 1 ,\r\nSNSS_DATA_SIZE, device);\r\nif (IS_ERR(cqr))\r\nreturn -ENOMEM;\r\ncqr->startdev = device;\r\ncqr->retries = 255;\r\ncqr->expires = 10 * HZ;\r\nclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\r\nset_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags);\r\nccw = cqr->cpaddr;\r\nccw->cmd_code = DASD_ECKD_CCW_SNSS;\r\nccw->count = SNSS_DATA_SIZE;\r\nccw->flags = 0;\r\nccw->cda = (__u32)(addr_t) cqr->data;\r\ncqr->buildclk = get_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\ncqr->callback = dasd_eer_snss_cb;\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\nif (!device->eer_cqr) {\r\ndevice->eer_cqr = cqr;\r\ncqr = NULL;\r\n}\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\nif (cqr)\r\ndasd_kfree_request(cqr, device);\r\nreturn 0;\r\n}\r\nvoid dasd_eer_disable(struct dasd_device *device)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nunsigned long flags;\r\nint in_use;\r\nif (!device->eer_cqr)\r\nreturn;\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\ncqr = device->eer_cqr;\r\ndevice->eer_cqr = NULL;\r\nclear_bit(DASD_FLAG_EER_SNSS, &device->flags);\r\nin_use = test_and_clear_bit(DASD_FLAG_EER_IN_USE, &device->flags);\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\nif (cqr && !in_use)\r\ndasd_kfree_request(cqr, device);\r\n}\r\nstatic int dasd_eer_open(struct inode *inp, struct file *filp)\r\n{\r\nstruct eerbuffer *eerb;\r\nunsigned long flags;\r\neerb = kzalloc(sizeof(struct eerbuffer), GFP_KERNEL);\r\nif (!eerb)\r\nreturn -ENOMEM;\r\neerb->buffer_page_count = eer_pages;\r\nif (eerb->buffer_page_count < 1 ||\r\neerb->buffer_page_count > INT_MAX / PAGE_SIZE) {\r\nkfree(eerb);\r\nDBF_EVENT(DBF_WARNING, "can't open device since module "\r\n"parameter eer_pages is smaller than 1 or"\r\n" bigger than %d", (int)(INT_MAX / PAGE_SIZE));\r\nreturn -EINVAL;\r\n}\r\neerb->buffersize = eerb->buffer_page_count * PAGE_SIZE;\r\neerb->buffer = kmalloc(eerb->buffer_page_count * sizeof(char *),\r\nGFP_KERNEL);\r\nif (!eerb->buffer) {\r\nkfree(eerb);\r\nreturn -ENOMEM;\r\n}\r\nif (dasd_eer_allocate_buffer_pages(eerb->buffer,\r\neerb->buffer_page_count)) {\r\nkfree(eerb->buffer);\r\nkfree(eerb);\r\nreturn -ENOMEM;\r\n}\r\nfilp->private_data = eerb;\r\nspin_lock_irqsave(&bufferlock, flags);\r\nlist_add(&eerb->list, &bufferlist);\r\nspin_unlock_irqrestore(&bufferlock, flags);\r\nreturn nonseekable_open(inp,filp);\r\n}\r\nstatic int dasd_eer_close(struct inode *inp, struct file *filp)\r\n{\r\nstruct eerbuffer *eerb;\r\nunsigned long flags;\r\neerb = (struct eerbuffer *) filp->private_data;\r\nspin_lock_irqsave(&bufferlock, flags);\r\nlist_del(&eerb->list);\r\nspin_unlock_irqrestore(&bufferlock, flags);\r\ndasd_eer_free_buffer_pages(eerb->buffer, eerb->buffer_page_count);\r\nkfree(eerb->buffer);\r\nkfree(eerb);\r\nreturn 0;\r\n}\r\nstatic ssize_t dasd_eer_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint tc,rc;\r\nint tailcount,effective_count;\r\nunsigned long flags;\r\nstruct eerbuffer *eerb;\r\neerb = (struct eerbuffer *) filp->private_data;\r\nif (mutex_lock_interruptible(&readbuffer_mutex))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irqsave(&bufferlock, flags);\r\nif (eerb->residual < 0) {\r\neerb->residual = 0;\r\nspin_unlock_irqrestore(&bufferlock, flags);\r\nmutex_unlock(&readbuffer_mutex);\r\nreturn -EIO;\r\n} else if (eerb->residual > 0) {\r\neffective_count = min(eerb->residual, (int) count);\r\neerb->residual -= effective_count;\r\n} else {\r\ntc = 0;\r\nwhile (!tc) {\r\ntc = dasd_eer_read_buffer(eerb, (char *) &tailcount,\r\nsizeof(tailcount));\r\nif (!tc) {\r\nspin_unlock_irqrestore(&bufferlock, flags);\r\nmutex_unlock(&readbuffer_mutex);\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nrc = wait_event_interruptible(\r\ndasd_eer_read_wait_queue,\r\neerb->head != eerb->tail);\r\nif (rc)\r\nreturn rc;\r\nif (mutex_lock_interruptible(&readbuffer_mutex))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irqsave(&bufferlock, flags);\r\n}\r\n}\r\nWARN_ON(tc != sizeof(tailcount));\r\neffective_count = min(tailcount,(int)count);\r\neerb->residual = tailcount - effective_count;\r\n}\r\ntc = dasd_eer_read_buffer(eerb, readbuffer, effective_count);\r\nWARN_ON(tc != effective_count);\r\nspin_unlock_irqrestore(&bufferlock, flags);\r\nif (copy_to_user(buf, readbuffer, effective_count)) {\r\nmutex_unlock(&readbuffer_mutex);\r\nreturn -EFAULT;\r\n}\r\nmutex_unlock(&readbuffer_mutex);\r\nreturn effective_count;\r\n}\r\nstatic unsigned int dasd_eer_poll(struct file *filp, poll_table *ptable)\r\n{\r\nunsigned int mask;\r\nunsigned long flags;\r\nstruct eerbuffer *eerb;\r\neerb = (struct eerbuffer *) filp->private_data;\r\npoll_wait(filp, &dasd_eer_read_wait_queue, ptable);\r\nspin_lock_irqsave(&bufferlock, flags);\r\nif (eerb->head != eerb->tail)\r\nmask = POLLIN | POLLRDNORM ;\r\nelse\r\nmask = 0;\r\nspin_unlock_irqrestore(&bufferlock, flags);\r\nreturn mask;\r\n}\r\nint __init dasd_eer_init(void)\r\n{\r\nint rc;\r\ndasd_eer_dev = kzalloc(sizeof(*dasd_eer_dev), GFP_KERNEL);\r\nif (!dasd_eer_dev)\r\nreturn -ENOMEM;\r\ndasd_eer_dev->minor = MISC_DYNAMIC_MINOR;\r\ndasd_eer_dev->name = "dasd_eer";\r\ndasd_eer_dev->fops = &dasd_eer_fops;\r\nrc = misc_register(dasd_eer_dev);\r\nif (rc) {\r\nkfree(dasd_eer_dev);\r\ndasd_eer_dev = NULL;\r\nDBF_EVENT(DBF_ERR, "%s", "dasd_eer_init could not "\r\n"register misc device");\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nvoid dasd_eer_exit(void)\r\n{\r\nif (dasd_eer_dev) {\r\nmisc_deregister(dasd_eer_dev);\r\nkfree(dasd_eer_dev);\r\ndasd_eer_dev = NULL;\r\n}\r\n}
