static irqreturn_t line_interrupt(int irq, void *data)\r\n{\r\nstruct chan *chan = data;\r\nstruct line *line = chan->line;\r\nif (line)\r\nchan_interrupt(&line->chan_list, &line->task, line->tty, irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void line_timer_cb(struct work_struct *work)\r\n{\r\nstruct line *line = container_of(work, struct line, task.work);\r\nif (!line->throttled)\r\nchan_interrupt(&line->chan_list, &line->task, line->tty,\r\nline->driver->read_irq);\r\n}\r\nstatic int write_room(struct line *line)\r\n{\r\nint n;\r\nif (line->buffer == NULL)\r\nreturn LINE_BUFSIZE - 1;\r\nn = line->head - line->tail;\r\nif (n <= 0)\r\nn += LINE_BUFSIZE;\r\nreturn n - 1;\r\n}\r\nint line_write_room(struct tty_struct *tty)\r\n{\r\nstruct line *line = tty->driver_data;\r\nunsigned long flags;\r\nint room;\r\nspin_lock_irqsave(&line->lock, flags);\r\nroom = write_room(line);\r\nspin_unlock_irqrestore(&line->lock, flags);\r\nreturn room;\r\n}\r\nint line_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct line *line = tty->driver_data;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&line->lock, flags);\r\nret = LINE_BUFSIZE - (write_room(line) + 1);\r\nspin_unlock_irqrestore(&line->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int buffer_data(struct line *line, const char *buf, int len)\r\n{\r\nint end, room;\r\nif (line->buffer == NULL) {\r\nline->buffer = kmalloc(LINE_BUFSIZE, GFP_ATOMIC);\r\nif (line->buffer == NULL) {\r\nprintk(KERN_ERR "buffer_data - atomic allocation "\r\n"failed\n");\r\nreturn 0;\r\n}\r\nline->head = line->buffer;\r\nline->tail = line->buffer;\r\n}\r\nroom = write_room(line);\r\nlen = (len > room) ? room : len;\r\nend = line->buffer + LINE_BUFSIZE - line->tail;\r\nif (len < end) {\r\nmemcpy(line->tail, buf, len);\r\nline->tail += len;\r\n}\r\nelse {\r\nmemcpy(line->tail, buf, end);\r\nbuf += end;\r\nmemcpy(line->buffer, buf, len - end);\r\nline->tail = line->buffer + len - end;\r\n}\r\nreturn len;\r\n}\r\nstatic int flush_buffer(struct line *line)\r\n{\r\nint n, count;\r\nif ((line->buffer == NULL) || (line->head == line->tail))\r\nreturn 1;\r\nif (line->tail < line->head) {\r\ncount = line->buffer + LINE_BUFSIZE - line->head;\r\nn = write_chan(&line->chan_list, line->head, count,\r\nline->driver->write_irq);\r\nif (n < 0)\r\nreturn n;\r\nif (n == count) {\r\nline->head = line->buffer;\r\n} else {\r\nline->head += n;\r\nreturn 0;\r\n}\r\n}\r\ncount = line->tail - line->head;\r\nn = write_chan(&line->chan_list, line->head, count,\r\nline->driver->write_irq);\r\nif (n < 0)\r\nreturn n;\r\nline->head += n;\r\nreturn line->head == line->tail;\r\n}\r\nvoid line_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct line *line = tty->driver_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&line->lock, flags);\r\nflush_buffer(line);\r\nspin_unlock_irqrestore(&line->lock, flags);\r\n}\r\nvoid line_flush_chars(struct tty_struct *tty)\r\n{\r\nline_flush_buffer(tty);\r\n}\r\nint line_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nreturn line_write(tty, &ch, sizeof(ch));\r\n}\r\nint line_write(struct tty_struct *tty, const unsigned char *buf, int len)\r\n{\r\nstruct line *line = tty->driver_data;\r\nunsigned long flags;\r\nint n, ret = 0;\r\nspin_lock_irqsave(&line->lock, flags);\r\nif (line->head != line->tail)\r\nret = buffer_data(line, buf, len);\r\nelse {\r\nn = write_chan(&line->chan_list, buf, len,\r\nline->driver->write_irq);\r\nif (n < 0) {\r\nret = n;\r\ngoto out_up;\r\n}\r\nlen -= n;\r\nret += n;\r\nif (len > 0)\r\nret += buffer_data(line, buf + n, len);\r\n}\r\nout_up:\r\nspin_unlock_irqrestore(&line->lock, flags);\r\nreturn ret;\r\n}\r\nvoid line_set_termios(struct tty_struct *tty, struct ktermios * old)\r\n{\r\n}\r\nint line_ioctl(struct tty_struct *tty, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret;\r\nint i;\r\nret = 0;\r\nswitch(cmd) {\r\n#ifdef TIOCGETP\r\ncase TIOCGETP:\r\ncase TIOCSETP:\r\ncase TIOCSETN:\r\n#endif\r\n#ifdef TIOCGETC\r\ncase TIOCGETC:\r\ncase TIOCSETC:\r\n#endif\r\n#ifdef TIOCGLTC\r\ncase TIOCGLTC:\r\ncase TIOCSLTC:\r\n#endif\r\ncase TCGETS:\r\ncase TCSETSF:\r\ncase TCSETSW:\r\ncase TCSETS:\r\ncase TCGETA:\r\ncase TCSETAF:\r\ncase TCSETAW:\r\ncase TCSETA:\r\ncase TCXONC:\r\ncase TCFLSH:\r\ncase TIOCOUTQ:\r\ncase TIOCINQ:\r\ncase TIOCGLCKTRMIOS:\r\ncase TIOCSLCKTRMIOS:\r\ncase TIOCPKT:\r\ncase TIOCGSOFTCAR:\r\ncase TIOCSSOFTCAR:\r\nreturn -ENOIOCTLCMD;\r\n#if 0\r\ncase TCwhatever:\r\nbreak;\r\n#endif\r\ndefault:\r\nfor (i = 0; i < ARRAY_SIZE(tty_ioctls); i++)\r\nif (cmd == tty_ioctls[i].cmd)\r\nbreak;\r\nif (i == ARRAY_SIZE(tty_ioctls)) {\r\nprintk(KERN_ERR "%s: %s: unknown ioctl: 0x%x\n",\r\n__func__, tty->name, cmd);\r\n}\r\nret = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid line_throttle(struct tty_struct *tty)\r\n{\r\nstruct line *line = tty->driver_data;\r\ndeactivate_chan(&line->chan_list, line->driver->read_irq);\r\nline->throttled = 1;\r\n}\r\nvoid line_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct line *line = tty->driver_data;\r\nline->throttled = 0;\r\nchan_interrupt(&line->chan_list, &line->task, tty,\r\nline->driver->read_irq);\r\nif (!line->throttled)\r\nreactivate_chan(&line->chan_list, line->driver->read_irq);\r\n}\r\nstatic irqreturn_t line_write_interrupt(int irq, void *data)\r\n{\r\nstruct chan *chan = data;\r\nstruct line *line = chan->line;\r\nstruct tty_struct *tty = line->tty;\r\nint err;\r\nspin_lock(&line->lock);\r\nerr = flush_buffer(line);\r\nif (err == 0) {\r\nreturn IRQ_NONE;\r\n} else if (err < 0) {\r\nline->head = line->buffer;\r\nline->tail = line->buffer;\r\n}\r\nspin_unlock(&line->lock);\r\nif (tty == NULL)\r\nreturn IRQ_NONE;\r\ntty_wakeup(tty);\r\nreturn IRQ_HANDLED;\r\n}\r\nint line_setup_irq(int fd, int input, int output, struct line *line, void *data)\r\n{\r\nconst struct line_driver *driver = line->driver;\r\nint err = 0, flags = IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM;\r\nif (input)\r\nerr = um_request_irq(driver->read_irq, fd, IRQ_READ,\r\nline_interrupt, flags,\r\ndriver->read_irq_name, data);\r\nif (err)\r\nreturn err;\r\nif (output)\r\nerr = um_request_irq(driver->write_irq, fd, IRQ_WRITE,\r\nline_write_interrupt, flags,\r\ndriver->write_irq_name, data);\r\nline->have_irq = 1;\r\nreturn err;\r\n}\r\nint line_open(struct line *lines, struct tty_struct *tty)\r\n{\r\nstruct line *line = &lines[tty->index];\r\nint err = -ENODEV;\r\nspin_lock(&line->count_lock);\r\nif (!line->valid)\r\ngoto out_unlock;\r\nerr = 0;\r\nif (line->count++)\r\ngoto out_unlock;\r\nBUG_ON(tty->driver_data);\r\ntty->driver_data = line;\r\nline->tty = tty;\r\nspin_unlock(&line->count_lock);\r\nerr = enable_chan(line);\r\nif (err)\r\nreturn err;\r\nINIT_DELAYED_WORK(&line->task, line_timer_cb);\r\nif (!line->sigio) {\r\nchan_enable_winch(&line->chan_list, tty);\r\nline->sigio = 1;\r\n}\r\nchan_window_size(&line->chan_list, &tty->winsize.ws_row,\r\n&tty->winsize.ws_col);\r\nreturn 0;\r\nout_unlock:\r\nspin_unlock(&line->count_lock);\r\nreturn err;\r\n}\r\nvoid line_close(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct line *line = tty->driver_data;\r\nif (line == NULL)\r\nreturn;\r\nflush_buffer(line);\r\nspin_lock(&line->count_lock);\r\nBUG_ON(!line->valid);\r\nif (--line->count)\r\ngoto out_unlock;\r\nline->tty = NULL;\r\ntty->driver_data = NULL;\r\nspin_unlock(&line->count_lock);\r\nif (line->sigio) {\r\nunregister_winch(tty);\r\nline->sigio = 0;\r\n}\r\nreturn;\r\nout_unlock:\r\nspin_unlock(&line->count_lock);\r\n}\r\nvoid close_lines(struct line *lines, int nlines)\r\n{\r\nint i;\r\nfor(i = 0; i < nlines; i++)\r\nclose_chan(&lines[i].chan_list, 0);\r\n}\r\nstatic int setup_one_line(struct line *lines, int n, char *init, int init_prio,\r\nchar **error_out)\r\n{\r\nstruct line *line = &lines[n];\r\nint err = -EINVAL;\r\nspin_lock(&line->count_lock);\r\nif (line->count) {\r\n*error_out = "Device is already open";\r\ngoto out;\r\n}\r\nif (line->init_pri <= init_prio) {\r\nline->init_pri = init_prio;\r\nif (!strcmp(init, "none"))\r\nline->valid = 0;\r\nelse {\r\nline->init_str = init;\r\nline->valid = 1;\r\n}\r\n}\r\nerr = 0;\r\nout:\r\nspin_unlock(&line->count_lock);\r\nreturn err;\r\n}\r\nint line_setup(struct line *lines, unsigned int num, char *init,\r\nchar **error_out)\r\n{\r\nint i, n, err;\r\nchar *end;\r\nif (*init == '=') {\r\nn = -1;\r\n}\r\nelse {\r\nn = simple_strtoul(init, &end, 0);\r\nif (*end != '=') {\r\n*error_out = "Couldn't parse device number";\r\nreturn -EINVAL;\r\n}\r\ninit = end;\r\n}\r\ninit++;\r\nif (n >= (signed int) num) {\r\n*error_out = "Device number out of range";\r\nreturn -EINVAL;\r\n}\r\nelse if (n >= 0) {\r\nerr = setup_one_line(lines, n, init, INIT_ONE, error_out);\r\nif (err)\r\nreturn err;\r\n}\r\nelse {\r\nfor(i = 0; i < num; i++) {\r\nerr = setup_one_line(lines, i, init, INIT_ALL,\r\nerror_out);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nreturn n == -1 ? num : n;\r\n}\r\nint line_config(struct line *lines, unsigned int num, char *str,\r\nconst struct chan_opts *opts, char **error_out)\r\n{\r\nstruct line *line;\r\nchar *new;\r\nint n;\r\nif (*str == '=') {\r\n*error_out = "Can't configure all devices from mconsole";\r\nreturn -EINVAL;\r\n}\r\nnew = kstrdup(str, GFP_KERNEL);\r\nif (new == NULL) {\r\n*error_out = "Failed to allocate memory";\r\nreturn -ENOMEM;\r\n}\r\nn = line_setup(lines, num, new, error_out);\r\nif (n < 0)\r\nreturn n;\r\nline = &lines[n];\r\nreturn parse_chan_pair(line->init_str, line, n, opts, error_out);\r\n}\r\nint line_get_config(char *name, struct line *lines, unsigned int num, char *str,\r\nint size, char **error_out)\r\n{\r\nstruct line *line;\r\nchar *end;\r\nint dev, n = 0;\r\ndev = simple_strtoul(name, &end, 0);\r\nif ((*end != '\0') || (end == name)) {\r\n*error_out = "line_get_config failed to parse device number";\r\nreturn 0;\r\n}\r\nif ((dev < 0) || (dev >= num)) {\r\n*error_out = "device number out of range";\r\nreturn 0;\r\n}\r\nline = &lines[dev];\r\nspin_lock(&line->count_lock);\r\nif (!line->valid)\r\nCONFIG_CHUNK(str, size, n, "none", 1);\r\nelse if (line->tty == NULL)\r\nCONFIG_CHUNK(str, size, n, line->init_str, 1);\r\nelse n = chan_config_string(&line->chan_list, str, size, error_out);\r\nspin_unlock(&line->count_lock);\r\nreturn n;\r\n}\r\nint line_id(char **str, int *start_out, int *end_out)\r\n{\r\nchar *end;\r\nint n;\r\nn = simple_strtoul(*str, &end, 0);\r\nif ((*end != '\0') || (end == *str))\r\nreturn -1;\r\n*str = end;\r\n*start_out = n;\r\n*end_out = n;\r\nreturn n;\r\n}\r\nint line_remove(struct line *lines, unsigned int num, int n, char **error_out)\r\n{\r\nint err;\r\nchar config[sizeof("conxxxx=none\0")];\r\nsprintf(config, "%d=none", n);\r\nerr = line_setup(lines, num, config, error_out);\r\nif (err >= 0)\r\nerr = 0;\r\nreturn err;\r\n}\r\nstruct tty_driver *register_lines(struct line_driver *line_driver,\r\nconst struct tty_operations *ops,\r\nstruct line *lines, int nlines)\r\n{\r\nint i;\r\nstruct tty_driver *driver = alloc_tty_driver(nlines);\r\nif (!driver)\r\nreturn NULL;\r\ndriver->driver_name = line_driver->name;\r\ndriver->name = line_driver->device_name;\r\ndriver->major = line_driver->major;\r\ndriver->minor_start = line_driver->minor_start;\r\ndriver->type = line_driver->type;\r\ndriver->subtype = line_driver->subtype;\r\ndriver->flags = TTY_DRIVER_REAL_RAW;\r\ndriver->init_termios = tty_std_termios;\r\ntty_set_operations(driver, ops);\r\nif (tty_register_driver(driver)) {\r\nprintk(KERN_ERR "register_lines : can't register %s driver\n",\r\nline_driver->name);\r\nput_tty_driver(driver);\r\nreturn NULL;\r\n}\r\nfor(i = 0; i < nlines; i++) {\r\nif (!lines[i].valid)\r\ntty_unregister_device(driver, i);\r\n}\r\nmconsole_register_dev(&line_driver->mc);\r\nreturn driver;\r\n}\r\nvoid lines_init(struct line *lines, int nlines, struct chan_opts *opts)\r\n{\r\nstruct line *line;\r\nchar *error;\r\nint i;\r\nfor(i = 0; i < nlines; i++) {\r\nline = &lines[i];\r\nINIT_LIST_HEAD(&line->chan_list);\r\nif (line->init_str == NULL)\r\ncontinue;\r\nline->init_str = kstrdup(line->init_str, GFP_KERNEL);\r\nif (line->init_str == NULL)\r\nprintk(KERN_ERR "lines_init - kstrdup returned NULL\n");\r\nif (parse_chan_pair(line->init_str, line, i, opts, &error)) {\r\nprintk(KERN_ERR "parse_chan_pair failed for "\r\n"device %d : %s\n", i, error);\r\nline->valid = 0;\r\n}\r\n}\r\n}\r\nstatic void __free_winch(struct work_struct *work)\r\n{\r\nstruct winch *winch = container_of(work, struct winch, work);\r\nfree_irq(WINCH_IRQ, winch);\r\nif (winch->pid != -1)\r\nos_kill_process(winch->pid, 1);\r\nif (winch->stack != 0)\r\nfree_stack(winch->stack, 0);\r\nkfree(winch);\r\n}\r\nstatic void free_winch(struct winch *winch)\r\n{\r\nint fd = winch->fd;\r\nwinch->fd = -1;\r\nif (fd != -1)\r\nos_close_file(fd);\r\nlist_del(&winch->list);\r\n__free_winch(&winch->work);\r\n}\r\nstatic irqreturn_t winch_interrupt(int irq, void *data)\r\n{\r\nstruct winch *winch = data;\r\nstruct tty_struct *tty;\r\nstruct line *line;\r\nint fd = winch->fd;\r\nint err;\r\nchar c;\r\nif (fd != -1) {\r\nerr = generic_read(fd, &c, NULL);\r\nif (err < 0) {\r\nif (err != -EAGAIN) {\r\nwinch->fd = -1;\r\nlist_del(&winch->list);\r\nos_close_file(fd);\r\nprintk(KERN_ERR "winch_interrupt : "\r\n"read failed, errno = %d\n", -err);\r\nprintk(KERN_ERR "fd %d is losing SIGWINCH "\r\n"support\n", winch->tty_fd);\r\nINIT_WORK(&winch->work, __free_winch);\r\nschedule_work(&winch->work);\r\nreturn IRQ_HANDLED;\r\n}\r\ngoto out;\r\n}\r\n}\r\ntty = winch->tty;\r\nif (tty != NULL) {\r\nline = tty->driver_data;\r\nif (line != NULL) {\r\nchan_window_size(&line->chan_list, &tty->winsize.ws_row,\r\n&tty->winsize.ws_col);\r\nkill_pgrp(tty->pgrp, SIGWINCH, 1);\r\n}\r\n}\r\nout:\r\nif (winch->fd != -1)\r\nreactivate_fd(winch->fd, WINCH_IRQ);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid register_winch_irq(int fd, int tty_fd, int pid, struct tty_struct *tty,\r\nunsigned long stack)\r\n{\r\nstruct winch *winch;\r\nwinch = kmalloc(sizeof(*winch), GFP_KERNEL);\r\nif (winch == NULL) {\r\nprintk(KERN_ERR "register_winch_irq - kmalloc failed\n");\r\ngoto cleanup;\r\n}\r\n*winch = ((struct winch) { .list = LIST_HEAD_INIT(winch->list),\r\n.fd = fd,\r\n.tty_fd = tty_fd,\r\n.pid = pid,\r\n.tty = tty,\r\n.stack = stack });\r\nif (um_request_irq(WINCH_IRQ, fd, IRQ_READ, winch_interrupt,\r\nIRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM,\r\n"winch", winch) < 0) {\r\nprintk(KERN_ERR "register_winch_irq - failed to register "\r\n"IRQ\n");\r\ngoto out_free;\r\n}\r\nspin_lock(&winch_handler_lock);\r\nlist_add(&winch->list, &winch_handlers);\r\nspin_unlock(&winch_handler_lock);\r\nreturn;\r\nout_free:\r\nkfree(winch);\r\ncleanup:\r\nos_kill_process(pid, 1);\r\nos_close_file(fd);\r\nif (stack != 0)\r\nfree_stack(stack, 0);\r\n}\r\nstatic void unregister_winch(struct tty_struct *tty)\r\n{\r\nstruct list_head *ele, *next;\r\nstruct winch *winch;\r\nspin_lock(&winch_handler_lock);\r\nlist_for_each_safe(ele, next, &winch_handlers) {\r\nwinch = list_entry(ele, struct winch, list);\r\nif (winch->tty == tty) {\r\nfree_winch(winch);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&winch_handler_lock);\r\n}\r\nstatic void winch_cleanup(void)\r\n{\r\nstruct list_head *ele, *next;\r\nstruct winch *winch;\r\nspin_lock(&winch_handler_lock);\r\nlist_for_each_safe(ele, next, &winch_handlers) {\r\nwinch = list_entry(ele, struct winch, list);\r\nfree_winch(winch);\r\n}\r\nspin_unlock(&winch_handler_lock);\r\n}\r\nchar *add_xterm_umid(char *base)\r\n{\r\nchar *umid, *title;\r\nint len;\r\numid = get_umid();\r\nif (*umid == '\0')\r\nreturn base;\r\nlen = strlen(base) + strlen(" ()") + strlen(umid) + 1;\r\ntitle = kmalloc(len, GFP_KERNEL);\r\nif (title == NULL) {\r\nprintk(KERN_ERR "Failed to allocate buffer for xterm title\n");\r\nreturn base;\r\n}\r\nsnprintf(title, len, "%s (%s)", base, umid);\r\nreturn title;\r\n}
