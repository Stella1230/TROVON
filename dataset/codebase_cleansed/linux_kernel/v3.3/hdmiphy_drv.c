const u8 *hdmiphy_preset2conf(u32 preset)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(hdmiphy_conf); ++i)\r\nif (hdmiphy_conf[i].preset == preset)\r\nreturn hdmiphy_conf[i].data;\r\nreturn NULL;\r\n}\r\nstatic int hdmiphy_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nreturn 0;\r\n}\r\nstatic int hdmiphy_s_dv_preset(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_preset *preset)\r\n{\r\nconst u8 *data;\r\nu8 buffer[32];\r\nint ret;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct device *dev = &client->dev;\r\ndev_info(dev, "s_dv_preset(preset = %d)\n", preset->preset);\r\ndata = hdmiphy_preset2conf(preset->preset);\r\nif (!data) {\r\ndev_err(dev, "format not supported\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(buffer, data, 32);\r\nret = i2c_master_send(client, buffer, 32);\r\nif (ret != 32) {\r\ndev_err(dev, "failed to configure HDMIPHY via I2C\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdmiphy_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct device *dev = &client->dev;\r\nu8 buffer[2];\r\nint ret;\r\ndev_info(dev, "s_stream(%d)\n", enable);\r\nbuffer[0] = 0x1f;\r\nbuffer[1] = enable ? 0x80 : 0x00;\r\nret = i2c_master_send(client, buffer, 2);\r\nif (ret != 2) {\r\ndev_err(dev, "stream (%d) failed\n", enable);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit hdmiphy_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstatic struct v4l2_subdev sd;\r\nv4l2_i2c_subdev_init(&sd, client, &hdmiphy_ops);\r\ndev_info(&client->dev, "probe successful\n");\r\nreturn 0;\r\n}\r\nstatic int __devexit hdmiphy_remove(struct i2c_client *client)\r\n{\r\ndev_info(&client->dev, "remove successful\n");\r\nreturn 0;\r\n}\r\nstatic int __init hdmiphy_init(void)\r\n{\r\nreturn i2c_add_driver(&hdmiphy_driver);\r\n}\r\nstatic void __exit hdmiphy_exit(void)\r\n{\r\ni2c_del_driver(&hdmiphy_driver);\r\n}
