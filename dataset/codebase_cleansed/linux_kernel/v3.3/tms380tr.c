int tms380tr_open(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint err;\r\nspin_lock_init(&tp->lock);\r\ninit_timer(&tp->timer);\r\n#ifdef CONFIG_ISA\r\nif(dev->dma > 0)\r\n{\r\nunsigned long flags=claim_dma_lock();\r\ndisable_dma(dev->dma);\r\nset_dma_mode(dev->dma, DMA_MODE_CASCADE);\r\nenable_dma(dev->dma);\r\nrelease_dma_lock(flags);\r\n}\r\n#endif\r\nerr = tms380tr_chipset_init(dev);\r\nif(err)\r\n{\r\nprintk(KERN_INFO "%s: Chipset initialization error\n",\r\ndev->name);\r\nreturn -1;\r\n}\r\ntp->timer.expires = jiffies + 30*HZ;\r\ntp->timer.function = tms380tr_timer_end_wait;\r\ntp->timer.data = (unsigned long)dev;\r\nadd_timer(&tp->timer);\r\nprintk(KERN_DEBUG "%s: Adapter RAM size: %dK\n",\r\ndev->name, tms380tr_read_ptr(dev));\r\ntms380tr_enable_interrupts(dev);\r\ntms380tr_open_adapter(dev);\r\nnetif_start_queue(dev);\r\ntp->Sleeping = 1;\r\ninterruptible_sleep_on(&tp->wait_for_tok_int);\r\ndel_timer(&tp->timer);\r\nif(tp->AdapterVirtOpenFlag == 0)\r\n{\r\ntms380tr_disable_interrupts(dev);\r\nreturn -1;\r\n}\r\ntp->StartTime = jiffies;\r\ntp->timer.expires = jiffies + 2*HZ;\r\ntp->timer.function = tms380tr_timer_chk;\r\ntp->timer.data = (unsigned long)dev;\r\nadd_timer(&tp->timer);\r\nreturn 0;\r\n}\r\nstatic void tms380tr_timer_end_wait(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device*)data;\r\nstruct net_local *tp = netdev_priv(dev);\r\nif(tp->Sleeping)\r\n{\r\ntp->Sleeping = 0;\r\nwake_up_interruptible(&tp->wait_for_tok_int);\r\n}\r\n}\r\nstatic int tms380tr_chipset_init(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint err;\r\ntms380tr_init_ipb(tp);\r\ntms380tr_init_opb(dev);\r\ntms380tr_init_net_local(dev);\r\nif(tms380tr_debug > 3)\r\nprintk(KERN_DEBUG "%s: Resetting adapter...\n", dev->name);\r\nerr = tms380tr_reset_adapter(dev);\r\nif(err < 0)\r\nreturn -1;\r\nif(tms380tr_debug > 3)\r\nprintk(KERN_DEBUG "%s: Bringup diags...\n", dev->name);\r\nerr = tms380tr_bringup_diags(dev);\r\nif(err < 0)\r\nreturn -1;\r\nif(tms380tr_debug > 3)\r\nprintk(KERN_DEBUG "%s: Init adapter...\n", dev->name);\r\nerr = tms380tr_init_adapter(dev);\r\nif(err < 0)\r\nreturn -1;\r\nif(tms380tr_debug > 3)\r\nprintk(KERN_DEBUG "%s: Done!\n", dev->name);\r\nreturn 0;\r\n}\r\nstatic void tms380tr_init_net_local(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint i;\r\ndma_addr_t dmabuf;\r\ntp->scb.CMD = 0;\r\ntp->scb.Parm[0] = 0;\r\ntp->scb.Parm[1] = 0;\r\ntp->ssb.STS = 0;\r\ntp->ssb.Parm[0] = 0;\r\ntp->ssb.Parm[1] = 0;\r\ntp->ssb.Parm[2] = 0;\r\ntp->CMDqueue = 0;\r\ntp->AdapterOpenFlag = 0;\r\ntp->AdapterVirtOpenFlag = 0;\r\ntp->ScbInUse = 0;\r\ntp->OpenCommandIssued = 0;\r\ntp->ReOpenInProgress = 0;\r\ntp->HaltInProgress = 0;\r\ntp->TransmitHaltScheduled = 0;\r\ntp->LobeWireFaultLogged = 0;\r\ntp->LastOpenStatus = 0;\r\ntp->MaxPacketSize = DEFAULT_PACKET_SIZE;\r\nfor (i = 0; i < TPL_NUM; i++)\r\n{\r\ntp->Tpl[i].NextTPLAddr = htonl(((char *)(&tp->Tpl[(i+1) % TPL_NUM]) - (char *)tp) + tp->dmabuffer);\r\ntp->Tpl[i].Status = 0;\r\ntp->Tpl[i].FrameSize = 0;\r\ntp->Tpl[i].FragList[0].DataCount = 0;\r\ntp->Tpl[i].FragList[0].DataAddr = 0;\r\ntp->Tpl[i].NextTPLPtr = &tp->Tpl[(i+1) % TPL_NUM];\r\ntp->Tpl[i].MData = NULL;\r\ntp->Tpl[i].TPLIndex = i;\r\ntp->Tpl[i].DMABuff = 0;\r\ntp->Tpl[i].BusyFlag = 0;\r\n}\r\ntp->TplFree = tp->TplBusy = &tp->Tpl[0];\r\nfor (i = 0; i < RPL_NUM; i++)\r\n{\r\ntp->Rpl[i].NextRPLAddr = htonl(((char *)(&tp->Rpl[(i+1) % RPL_NUM]) - (char *)tp) + tp->dmabuffer);\r\ntp->Rpl[i].Status = (RX_VALID | RX_START_FRAME | RX_END_FRAME | RX_FRAME_IRQ);\r\ntp->Rpl[i].FrameSize = 0;\r\ntp->Rpl[i].FragList[0].DataCount = cpu_to_be16((unsigned short)tp->MaxPacketSize);\r\ntp->Rpl[i].Skb = dev_alloc_skb(tp->MaxPacketSize);\r\ntp->Rpl[i].DMABuff = 0;\r\nif(tp->Rpl[i].Skb == NULL)\r\n{\r\ntp->Rpl[i].SkbStat = SKB_UNAVAILABLE;\r\ntp->Rpl[i].FragList[0].DataAddr = htonl(((char *)tp->LocalRxBuffers[i] - (char *)tp) + tp->dmabuffer);\r\ntp->Rpl[i].MData = tp->LocalRxBuffers[i];\r\n}\r\nelse\r\n{\r\ntp->Rpl[i].Skb->dev = dev;\r\nskb_put(tp->Rpl[i].Skb, tp->MaxPacketSize);\r\ndmabuf = dma_map_single(tp->pdev, tp->Rpl[i].Skb->data, tp->MaxPacketSize, DMA_FROM_DEVICE);\r\nif(tp->dmalimit && (dmabuf + tp->MaxPacketSize > tp->dmalimit))\r\n{\r\ntp->Rpl[i].SkbStat = SKB_DATA_COPY;\r\ntp->Rpl[i].FragList[0].DataAddr = htonl(((char *)tp->LocalRxBuffers[i] - (char *)tp) + tp->dmabuffer);\r\ntp->Rpl[i].MData = tp->LocalRxBuffers[i];\r\n}\r\nelse\r\n{\r\ntp->Rpl[i].SkbStat = SKB_DMA_DIRECT;\r\ntp->Rpl[i].FragList[0].DataAddr = htonl(dmabuf);\r\ntp->Rpl[i].MData = tp->Rpl[i].Skb->data;\r\ntp->Rpl[i].DMABuff = dmabuf;\r\n}\r\n}\r\ntp->Rpl[i].NextRPLPtr = &tp->Rpl[(i+1) % RPL_NUM];\r\ntp->Rpl[i].RPLIndex = i;\r\n}\r\ntp->RplHead = &tp->Rpl[0];\r\ntp->RplTail = &tp->Rpl[RPL_NUM-1];\r\ntp->RplTail->Status = (RX_START_FRAME | RX_END_FRAME | RX_FRAME_IRQ);\r\n}\r\nstatic void tms380tr_init_ipb(struct net_local *tp)\r\n{\r\ntp->ipb.Init_Options = BURST_MODE;\r\ntp->ipb.CMD_Status_IV = 0;\r\ntp->ipb.TX_IV = 0;\r\ntp->ipb.RX_IV = 0;\r\ntp->ipb.Ring_Status_IV = 0;\r\ntp->ipb.SCB_Clear_IV = 0;\r\ntp->ipb.Adapter_CHK_IV = 0;\r\ntp->ipb.RX_Burst_Size = BURST_SIZE;\r\ntp->ipb.TX_Burst_Size = BURST_SIZE;\r\ntp->ipb.DMA_Abort_Thrhld = DMA_RETRIES;\r\ntp->ipb.SCB_Addr = 0;\r\ntp->ipb.SSB_Addr = 0;\r\n}\r\nstatic void tms380tr_init_opb(struct net_device *dev)\r\n{\r\nstruct net_local *tp;\r\nunsigned long Addr;\r\nunsigned short RplSize = RPL_SIZE;\r\nunsigned short TplSize = TPL_SIZE;\r\nunsigned short BufferSize = BUFFER_SIZE;\r\nint i;\r\ntp = netdev_priv(dev);\r\ntp->ocpl.OPENOptions = 0;\r\ntp->ocpl.OPENOptions |= ENABLE_FULL_DUPLEX_SELECTION;\r\ntp->ocpl.FullDuplex = 0;\r\ntp->ocpl.FullDuplex |= OPEN_FULL_DUPLEX_OFF;\r\nfor (i=0;i<6;i++)\r\ntp->ocpl.NodeAddr[i] = ((unsigned char *)dev->dev_addr)[i];\r\ntp->ocpl.GroupAddr = 0;\r\ntp->ocpl.FunctAddr = 0;\r\ntp->ocpl.RxListSize = cpu_to_be16((unsigned short)RplSize);\r\ntp->ocpl.TxListSize = cpu_to_be16((unsigned short)TplSize);\r\ntp->ocpl.BufSize = cpu_to_be16((unsigned short)BufferSize);\r\ntp->ocpl.Reserved = 0;\r\ntp->ocpl.TXBufMin = TX_BUF_MIN;\r\ntp->ocpl.TXBufMax = TX_BUF_MAX;\r\nAddr = htonl(((char *)tp->ProductID - (char *)tp) + tp->dmabuffer);\r\ntp->ocpl.ProdIDAddr[0] = LOWORD(Addr);\r\ntp->ocpl.ProdIDAddr[1] = HIWORD(Addr);\r\n}\r\nstatic void tms380tr_open_adapter(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nif(tp->OpenCommandIssued)\r\nreturn;\r\ntp->OpenCommandIssued = 1;\r\ntms380tr_exec_cmd(dev, OC_OPEN);\r\n}\r\nstatic void tms380tr_disable_interrupts(struct net_device *dev)\r\n{\r\nSIFWRITEB(0, SIFACL);\r\n}\r\nstatic void tms380tr_enable_interrupts(struct net_device *dev)\r\n{\r\nSIFWRITEB(ACL_SINTEN, SIFACL);\r\n}\r\nstatic void tms380tr_exec_cmd(struct net_device *dev, unsigned short Command)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\ntp->CMDqueue |= Command;\r\ntms380tr_chk_outstanding_cmds(dev);\r\n}\r\nstatic void tms380tr_timeout(struct net_device *dev)\r\n{\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t tms380tr_send_packet(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nnetdev_tx_t rc;\r\nrc = tms380tr_hardware_send_packet(skb, dev);\r\nif(tp->TplFree->NextTPLPtr->BusyFlag)\r\nnetif_stop_queue(dev);\r\nreturn rc;\r\n}\r\nstatic netdev_tx_t tms380tr_hardware_send_packet(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nTPL *tpl;\r\nshort length;\r\nunsigned char *buf;\r\nunsigned long flags;\r\nint i;\r\ndma_addr_t dmabuf, newbuf;\r\nstruct net_local *tp = netdev_priv(dev);\r\nspin_lock_irqsave(&tp->lock, flags);\r\nif(tp->TplFree->NextTPLPtr->BusyFlag) {\r\nif (tms380tr_debug > 0)\r\nprintk(KERN_DEBUG "%s: No free TPL\n", dev->name);\r\nspin_unlock_irqrestore(&tp->lock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ndmabuf = 0;\r\nlength = skb->len;\r\ndmabuf = dma_map_single(tp->pdev, skb->data, length, DMA_TO_DEVICE);\r\nif(tp->dmalimit && (dmabuf + length > tp->dmalimit)) {\r\ndma_unmap_single(tp->pdev, dmabuf, length, DMA_TO_DEVICE);\r\ndmabuf = 0;\r\ni = tp->TplFree->TPLIndex;\r\nbuf = tp->LocalTxBuffers[i];\r\nskb_copy_from_linear_data(skb, buf, length);\r\nnewbuf = ((char *)buf - (char *)tp) + tp->dmabuffer;\r\n}\r\nelse {\r\nnewbuf = dmabuf;\r\nbuf = skb->data;\r\n}\r\ntms380tr_chk_src_addr(buf, dev->dev_addr);\r\ntp->LastSendTime = jiffies;\r\ntpl = tp->TplFree;\r\ntpl->BusyFlag = 1;\r\ntp->TplFree = tpl->NextTPLPtr;\r\ntpl->Skb = skb;\r\ntpl->DMABuff = dmabuf;\r\ntpl->FragList[0].DataCount = cpu_to_be16((unsigned short)length);\r\ntpl->FragList[0].DataAddr = htonl(newbuf);\r\ntpl->FrameSize = cpu_to_be16((unsigned short)length);\r\ntpl->MData = buf;\r\ntms380tr_write_tpl_status(tpl, TX_VALID | TX_START_FRAME\r\n| TX_END_FRAME | TX_PASS_SRC_ADDR\r\n| TX_FRAME_IRQ);\r\ntms380tr_exec_sifcmd(dev, CMD_TX_VALID);\r\nspin_unlock_irqrestore(&tp->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void tms380tr_write_tpl_status(TPL *tpl, unsigned int Status)\r\n{\r\ntpl->Status = Status;\r\n}\r\nstatic void tms380tr_chk_src_addr(unsigned char *frame, unsigned char *hw_addr)\r\n{\r\nunsigned char SRBit;\r\nif((((unsigned long)frame[8]) & ~0x80) != 0)\r\nreturn;\r\nif((unsigned short)frame[12] != 0)\r\nreturn;\r\nSRBit = frame[8] & 0x80;\r\nmemcpy(&frame[8], hw_addr, 6);\r\nframe[8] |= SRBit;\r\n}\r\nstatic void tms380tr_timer_chk(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device*)data;\r\nstruct net_local *tp = netdev_priv(dev);\r\nif(tp->HaltInProgress)\r\nreturn;\r\ntms380tr_chk_outstanding_cmds(dev);\r\nif(time_before(tp->LastSendTime + SEND_TIMEOUT, jiffies) &&\r\n(tp->TplFree != tp->TplBusy))\r\n{\r\ntp->LastSendTime = jiffies;\r\ntms380tr_exec_cmd(dev, OC_CLOSE);\r\n}\r\ntp->timer.expires = jiffies + 2*HZ;\r\nadd_timer(&tp->timer);\r\nif(tp->AdapterOpenFlag || tp->ReOpenInProgress)\r\nreturn;\r\ntp->ReOpenInProgress = 1;\r\ntms380tr_open_adapter(dev);\r\n}\r\nirqreturn_t tms380tr_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct net_local *tp;\r\nunsigned short irq_type;\r\nint handled = 0;\r\ntp = netdev_priv(dev);\r\nirq_type = SIFREADW(SIFSTS);\r\nwhile(irq_type & STS_SYSTEM_IRQ) {\r\nhandled = 1;\r\nirq_type &= STS_IRQ_MASK;\r\nif(!tms380tr_chk_ssb(tp, irq_type)) {\r\nprintk(KERN_DEBUG "%s: DATA LATE occurred\n", dev->name);\r\nbreak;\r\n}\r\nswitch(irq_type) {\r\ncase STS_IRQ_RECEIVE_STATUS:\r\ntms380tr_reset_interrupt(dev);\r\ntms380tr_rcv_status_irq(dev);\r\nbreak;\r\ncase STS_IRQ_TRANSMIT_STATUS:\r\nif(tp->ssb.Parm[0] & COMMAND_COMPLETE) {\r\ntp->TransmitCommandActive = 0;\r\ntp->TransmitHaltScheduled = 0;\r\ntms380tr_exec_cmd(dev, OC_TRANSMIT);\r\n}\r\ntms380tr_reset_interrupt(dev);\r\ntms380tr_tx_status_irq(dev);\r\nbreak;\r\ncase STS_IRQ_COMMAND_STATUS:\r\ntms380tr_cmd_status_irq(dev);\r\nbreak;\r\ncase STS_IRQ_SCB_CLEAR:\r\ntp->ScbInUse = 0;\r\ntms380tr_chk_outstanding_cmds(dev);\r\nbreak;\r\ncase STS_IRQ_RING_STATUS:\r\ntms380tr_ring_status_irq(dev);\r\nbreak;\r\ncase STS_IRQ_ADAPTER_CHECK:\r\ntms380tr_chk_irq(dev);\r\nbreak;\r\ncase STS_IRQ_LLC_STATUS:\r\nprintk(KERN_DEBUG "tms380tr: unexpected LLC status IRQ\n");\r\nbreak;\r\ncase STS_IRQ_TIMER:\r\nprintk(KERN_DEBUG "tms380tr: unexpected Timer IRQ\n");\r\nbreak;\r\ncase STS_IRQ_RECEIVE_PENDING:\r\nprintk(KERN_DEBUG "tms380tr: unexpected Receive Pending IRQ\n");\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "Unknown Token Ring IRQ (0x%04x)\n", irq_type);\r\nbreak;\r\n}\r\nif(irq_type != STS_IRQ_TRANSMIT_STATUS &&\r\nirq_type != STS_IRQ_RECEIVE_STATUS) {\r\ntms380tr_reset_interrupt(dev);\r\n}\r\nirq_type = SIFREADW(SIFSTS);\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void tms380tr_reset_interrupt(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nSSB *ssb = &tp->ssb;\r\nssb->STS = (unsigned short) -1;\r\nssb->Parm[0] = (unsigned short) -1;\r\nssb->Parm[1] = (unsigned short) -1;\r\nssb->Parm[2] = (unsigned short) -1;\r\ntms380tr_exec_sifcmd(dev, CMD_SSB_CLEAR | CMD_CLEAR_SYSTEM_IRQ);\r\n}\r\nstatic unsigned char tms380tr_chk_ssb(struct net_local *tp, unsigned short IrqType)\r\n{\r\nSSB *ssb = &tp->ssb;\r\nif(IrqType != STS_IRQ_TRANSMIT_STATUS &&\r\nIrqType != STS_IRQ_RECEIVE_STATUS &&\r\nIrqType != STS_IRQ_COMMAND_STATUS &&\r\nIrqType != STS_IRQ_RING_STATUS)\r\n{\r\nreturn 1;\r\n}\r\nif(ssb->STS == (unsigned short) -1)\r\nreturn 0;\r\nif(IrqType == STS_IRQ_COMMAND_STATUS)\r\nreturn 1;\r\nif(ssb->Parm[0] == (unsigned short) -1)\r\nreturn 0;\r\nif(IrqType == STS_IRQ_RING_STATUS)\r\nreturn 1;\r\nif(ssb->Parm[1] == (unsigned short) -1)\r\nreturn 0;\r\nif(ssb->Parm[2] == (unsigned short) -1)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void tms380tr_cmd_status_irq(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned short ssb_cmd, ssb_parm_0;\r\nunsigned short ssb_parm_1;\r\nchar *open_err = "Open error -";\r\nchar *code_err = "Open code -";\r\nssb_cmd = tp->ssb.STS;\r\nssb_parm_0 = tp->ssb.Parm[0];\r\nssb_parm_1 = tp->ssb.Parm[1];\r\nif(ssb_cmd == OPEN)\r\n{\r\ntp->Sleeping = 0;\r\nif(!tp->ReOpenInProgress)\r\nwake_up_interruptible(&tp->wait_for_tok_int);\r\ntp->OpenCommandIssued = 0;\r\ntp->ScbInUse = 0;\r\nif((ssb_parm_0 & 0x00FF) == GOOD_COMPLETION)\r\n{\r\ntp->LobeWireFaultLogged = 0;\r\ntp->AdapterOpenFlag = 1;\r\ntp->AdapterVirtOpenFlag = 1;\r\ntp->TransmitCommandActive = 0;\r\ntms380tr_exec_cmd(dev, OC_TRANSMIT);\r\ntms380tr_exec_cmd(dev, OC_RECEIVE);\r\nif(tp->ReOpenInProgress)\r\ntp->ReOpenInProgress = 0;\r\nreturn;\r\n}\r\nelse\r\n{\r\nif(ssb_parm_0 & NODE_ADDR_ERROR)\r\nprintk(KERN_INFO "%s: Node address error\n",\r\ndev->name);\r\nif(ssb_parm_0 & LIST_SIZE_ERROR)\r\nprintk(KERN_INFO "%s: List size error\n",\r\ndev->name);\r\nif(ssb_parm_0 & BUF_SIZE_ERROR)\r\nprintk(KERN_INFO "%s: Buffer size error\n",\r\ndev->name);\r\nif(ssb_parm_0 & TX_BUF_COUNT_ERROR)\r\nprintk(KERN_INFO "%s: Tx buffer count error\n",\r\ndev->name);\r\nif(ssb_parm_0 & INVALID_OPEN_OPTION)\r\nprintk(KERN_INFO "%s: Invalid open option\n",\r\ndev->name);\r\nif(ssb_parm_0 & OPEN_ERROR)\r\n{\r\nswitch(ssb_parm_0 & OPEN_PHASES_MASK)\r\n{\r\ncase LOBE_MEDIA_TEST:\r\nif(!tp->LobeWireFaultLogged)\r\n{\r\ntp->LobeWireFaultLogged = 1;\r\nprintk(KERN_INFO "%s: %s Lobe wire fault (check cable !).\n", dev->name, open_err);\r\n}\r\ntp->ReOpenInProgress = 1;\r\ntp->AdapterOpenFlag = 0;\r\ntp->AdapterVirtOpenFlag = 1;\r\ntms380tr_open_adapter(dev);\r\nreturn;\r\ncase PHYSICAL_INSERTION:\r\nprintk(KERN_INFO "%s: %s Physical insertion.\n", dev->name, open_err);\r\nbreak;\r\ncase ADDRESS_VERIFICATION:\r\nprintk(KERN_INFO "%s: %s Address verification.\n", dev->name, open_err);\r\nbreak;\r\ncase PARTICIPATION_IN_RING_POLL:\r\nprintk(KERN_INFO "%s: %s Participation in ring poll.\n", dev->name, open_err);\r\nbreak;\r\ncase REQUEST_INITIALISATION:\r\nprintk(KERN_INFO "%s: %s Request initialisation.\n", dev->name, open_err);\r\nbreak;\r\ncase FULLDUPLEX_CHECK:\r\nprintk(KERN_INFO "%s: %s Full duplex check.\n", dev->name, open_err);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "%s: %s Unknown open phase\n", dev->name, open_err);\r\nbreak;\r\n}\r\nswitch(ssb_parm_0 & OPEN_ERROR_CODES_MASK)\r\n{\r\ncase OPEN_FUNCTION_FAILURE:\r\nprintk(KERN_INFO "%s: %s OPEN_FUNCTION_FAILURE", dev->name, code_err);\r\ntp->LastOpenStatus =\r\nOPEN_FUNCTION_FAILURE;\r\nbreak;\r\ncase OPEN_SIGNAL_LOSS:\r\nprintk(KERN_INFO "%s: %s OPEN_SIGNAL_LOSS\n", dev->name, code_err);\r\ntp->LastOpenStatus =\r\nOPEN_SIGNAL_LOSS;\r\nbreak;\r\ncase OPEN_TIMEOUT:\r\nprintk(KERN_INFO "%s: %s OPEN_TIMEOUT\n", dev->name, code_err);\r\ntp->LastOpenStatus =\r\nOPEN_TIMEOUT;\r\nbreak;\r\ncase OPEN_RING_FAILURE:\r\nprintk(KERN_INFO "%s: %s OPEN_RING_FAILURE\n", dev->name, code_err);\r\ntp->LastOpenStatus =\r\nOPEN_RING_FAILURE;\r\nbreak;\r\ncase OPEN_RING_BEACONING:\r\nprintk(KERN_INFO "%s: %s OPEN_RING_BEACONING\n", dev->name, code_err);\r\ntp->LastOpenStatus =\r\nOPEN_RING_BEACONING;\r\nbreak;\r\ncase OPEN_DUPLICATE_NODEADDR:\r\nprintk(KERN_INFO "%s: %s OPEN_DUPLICATE_NODEADDR\n", dev->name, code_err);\r\ntp->LastOpenStatus =\r\nOPEN_DUPLICATE_NODEADDR;\r\nbreak;\r\ncase OPEN_REQUEST_INIT:\r\nprintk(KERN_INFO "%s: %s OPEN_REQUEST_INIT\n", dev->name, code_err);\r\ntp->LastOpenStatus =\r\nOPEN_REQUEST_INIT;\r\nbreak;\r\ncase OPEN_REMOVE_RECEIVED:\r\nprintk(KERN_INFO "%s: %s OPEN_REMOVE_RECEIVED", dev->name, code_err);\r\ntp->LastOpenStatus =\r\nOPEN_REMOVE_RECEIVED;\r\nbreak;\r\ncase OPEN_FULLDUPLEX_SET:\r\nprintk(KERN_INFO "%s: %s OPEN_FULLDUPLEX_SET\n", dev->name, code_err);\r\ntp->LastOpenStatus =\r\nOPEN_FULLDUPLEX_SET;\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "%s: %s Unknown open err code", dev->name, code_err);\r\ntp->LastOpenStatus =\r\nOPEN_FUNCTION_FAILURE;\r\nbreak;\r\n}\r\n}\r\ntp->AdapterOpenFlag = 0;\r\ntp->AdapterVirtOpenFlag = 0;\r\nreturn;\r\n}\r\n}\r\nelse\r\n{\r\nif(ssb_cmd != READ_ERROR_LOG)\r\nreturn;\r\ntp->MacStat.line_errors += tp->errorlogtable.Line_Error;\r\ntp->MacStat.burst_errors += tp->errorlogtable.Burst_Error;\r\ntp->MacStat.A_C_errors += tp->errorlogtable.ARI_FCI_Error;\r\ntp->MacStat.lost_frames += tp->errorlogtable.Lost_Frame_Error;\r\ntp->MacStat.recv_congest_count += tp->errorlogtable.Rx_Congest_Error;\r\ntp->MacStat.rx_errors += tp->errorlogtable.Rx_Congest_Error;\r\ntp->MacStat.frame_copied_errors += tp->errorlogtable.Frame_Copied_Error;\r\ntp->MacStat.token_errors += tp->errorlogtable.Token_Error;\r\ntp->MacStat.dummy1 += tp->errorlogtable.DMA_Bus_Error;\r\ntp->MacStat.dummy1 += tp->errorlogtable.DMA_Parity_Error;\r\ntp->MacStat.abort_delimiters += tp->errorlogtable.AbortDelimeters;\r\ntp->MacStat.frequency_errors += tp->errorlogtable.Frequency_Error;\r\ntp->MacStat.internal_errors += tp->errorlogtable.Internal_Error;\r\n}\r\n}\r\nint tms380tr_close(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\ndel_timer(&tp->timer);\r\ntp->HaltInProgress = 1;\r\ntms380tr_exec_cmd(dev, OC_CLOSE);\r\ntp->timer.expires = jiffies + 1*HZ;\r\ntp->timer.function = tms380tr_timer_end_wait;\r\ntp->timer.data = (unsigned long)dev;\r\nadd_timer(&tp->timer);\r\ntms380tr_enable_interrupts(dev);\r\ntp->Sleeping = 1;\r\ninterruptible_sleep_on(&tp->wait_for_tok_int);\r\ntp->TransmitCommandActive = 0;\r\ndel_timer(&tp->timer);\r\ntms380tr_disable_interrupts(dev);\r\n#ifdef CONFIG_ISA\r\nif(dev->dma > 0)\r\n{\r\nunsigned long flags=claim_dma_lock();\r\ndisable_dma(dev->dma);\r\nrelease_dma_lock(flags);\r\n}\r\n#endif\r\nSIFWRITEW(0xFF00, SIFCMD);\r\n#if 0\r\nif(dev->dma > 0)\r\nSIFWRITEB(0xff, POSREG);\r\n#endif\r\ntms380tr_cancel_tx_queue(tp);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *tms380tr_get_stats(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nreturn (struct net_device_stats *)&tp->MacStat;\r\n}\r\nstatic void tms380tr_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int OpenOptions;\r\nOpenOptions = tp->ocpl.OPENOptions &\r\n~(PASS_ADAPTER_MAC_FRAMES\r\n| PASS_ATTENTION_FRAMES\r\n| PASS_BEACON_MAC_FRAMES\r\n| COPY_ALL_MAC_FRAMES\r\n| COPY_ALL_NON_MAC_FRAMES);\r\ntp->ocpl.FunctAddr = 0;\r\nif(dev->flags & IFF_PROMISC)\r\nOpenOptions |= COPY_ALL_NON_MAC_FRAMES |\r\nCOPY_ALL_MAC_FRAMES;\r\nelse\r\n{\r\nif(dev->flags & IFF_ALLMULTI)\r\n{\r\ntp->ocpl.FunctAddr = 0xFFFFFFFF;\r\n}\r\nelse\r\n{\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\n((char *)(&tp->ocpl.FunctAddr))[0] |=\r\nha->addr[2];\r\n((char *)(&tp->ocpl.FunctAddr))[1] |=\r\nha->addr[3];\r\n((char *)(&tp->ocpl.FunctAddr))[2] |=\r\nha->addr[4];\r\n((char *)(&tp->ocpl.FunctAddr))[3] |=\r\nha->addr[5];\r\n}\r\n}\r\ntms380tr_exec_cmd(dev, OC_SET_FUNCT_ADDR);\r\n}\r\ntp->ocpl.OPENOptions = OpenOptions;\r\ntms380tr_exec_cmd(dev, OC_MODIFY_OPEN_PARMS);\r\n}\r\nvoid tms380tr_wait(unsigned long time)\r\n{\r\n#if 0\r\nlong tmp;\r\ntmp = jiffies + time/(1000000/HZ);\r\ndo {\r\ntmp = schedule_timeout_interruptible(tmp);\r\n} while(time_after(tmp, jiffies));\r\n#else\r\nmdelay(time / 1000);\r\n#endif\r\n}\r\nstatic void tms380tr_exec_sifcmd(struct net_device *dev, unsigned int WriteValue)\r\n{\r\nunsigned short cmd;\r\nunsigned short SifStsValue;\r\nunsigned long loop_counter;\r\nWriteValue = ((WriteValue ^ CMD_SYSTEM_IRQ) | CMD_INTERRUPT_ADAPTER);\r\ncmd = (unsigned short)WriteValue;\r\nloop_counter = 0,5 * 800000;\r\ndo {\r\nSifStsValue = SIFREADW(SIFSTS);\r\n} while((SifStsValue & CMD_INTERRUPT_ADAPTER) && loop_counter--);\r\nSIFWRITEW(cmd, SIFCMD);\r\n}\r\nstatic int tms380tr_reset_adapter(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned short *fw_ptr;\r\nunsigned short count, c, count2;\r\nconst struct firmware *fw_entry = NULL;\r\nif (request_firmware(&fw_entry, "tms380tr.bin", tp->pdev) != 0) {\r\nprintk(KERN_ALERT "%s: firmware %s is missing, cannot start.\n",\r\ndev->name, "tms380tr.bin");\r\nreturn -1;\r\n}\r\nfw_ptr = (unsigned short *)fw_entry->data;\r\ncount2 = fw_entry->size / 2;\r\nSIFWRITEW(ACL_ARESET, SIFACL);\r\ntms380tr_wait(40);\r\nc = SIFREADW(SIFACL);\r\ntms380tr_wait(20);\r\nif(dev->dma == 0)\r\n{\r\nc &= ~(ACL_NSELOUT0 | ACL_NSELOUT1);\r\nif(tp->setnselout)\r\nc |= (*tp->setnselout)(dev);\r\n}\r\ntp->ScbInUse = 0;\r\nc &= ~ACL_ARESET;\r\nc |= ACL_CPHALT;\r\nc |= ACL_BOOT;\r\nc |= ACL_SINTEN;\r\nc &= ~ACL_PSDMAEN;\r\nSIFWRITEW(c, SIFACL);\r\ntms380tr_wait(40);\r\ncount = 0;\r\ndo {\r\nif (count2 < 3) continue;\r\nSIFWRITEW(*fw_ptr, SIFADX);\r\nfw_ptr++;\r\ncount2--;\r\nSIFWRITEW(*fw_ptr, SIFADD);\r\nfw_ptr++;\r\ncount2--;\r\nif((count = *fw_ptr) != 0)\r\n{\r\nfw_ptr++;\r\ncount2--;\r\nif (count > count2) continue;\r\nfor(; count > 0; count--)\r\n{\r\nSIFWRITEW(*fw_ptr, SIFINC);\r\nfw_ptr++;\r\ncount2--;\r\n}\r\n}\r\nelse\r\n{\r\nc = SIFREADW(SIFACL);\r\nc &= (~ACL_CPHALT | ACL_SINTEN);\r\nSIFWRITEW(c, SIFACL);\r\nrelease_firmware(fw_entry);\r\nreturn 1;\r\n}\r\n} while(count == 0);\r\nrelease_firmware(fw_entry);\r\nprintk(KERN_INFO "%s: Adapter Download Failed\n", dev->name);\r\nreturn -1;\r\n}\r\nstatic int tms380tr_bringup_diags(struct net_device *dev)\r\n{\r\nint loop_cnt, retry_cnt;\r\nunsigned short Status;\r\ntms380tr_wait(HALF_SECOND);\r\ntms380tr_exec_sifcmd(dev, EXEC_SOFT_RESET);\r\ntms380tr_wait(HALF_SECOND);\r\nretry_cnt = BUD_MAX_RETRIES;\r\ndo {\r\nretry_cnt--;\r\nif(tms380tr_debug > 3)\r\nprintk(KERN_DEBUG "BUD-Status: ");\r\nloop_cnt = BUD_MAX_LOOPCNT;\r\ndo {\r\nloop_cnt--;\r\ntms380tr_wait(HALF_SECOND);\r\nStatus = SIFREADW(SIFSTS);\r\nStatus &= STS_MASK;\r\nif(tms380tr_debug > 3)\r\nprintk(KERN_DEBUG " %04X\n", Status);\r\nif(Status == STS_INITIALIZE)\r\nreturn 1;\r\n} while((loop_cnt > 0) && ((Status & (STS_ERROR | STS_TEST))\r\n!= (STS_ERROR | STS_TEST)));\r\nif(retry_cnt > 0)\r\n{\r\nprintk(KERN_INFO "%s: Adapter Software Reset.\n",\r\ndev->name);\r\ntms380tr_exec_sifcmd(dev, EXEC_SOFT_RESET);\r\ntms380tr_wait(HALF_SECOND);\r\n}\r\n} while(retry_cnt > 0);\r\nStatus = SIFREADW(SIFSTS);\r\nprintk(KERN_INFO "%s: Hardware error\n", dev->name);\r\nStatus &= 0x001f;\r\nif (Status & 0x0010)\r\nprintk(KERN_INFO "%s: BUD Error: Timeout\n", dev->name);\r\nelse if ((Status & 0x000f) > 6)\r\nprintk(KERN_INFO "%s: BUD Error: Illegal Failure\n", dev->name);\r\nelse\r\nprintk(KERN_INFO "%s: Bring Up Diagnostics Error (%04X) occurred\n", dev->name, Status & 0x000f);\r\nreturn -1;\r\n}\r\nstatic int tms380tr_init_adapter(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nconst unsigned char SCB_Test[6] = {0x00, 0x00, 0xC1, 0xE2, 0xD4, 0x8B};\r\nconst unsigned char SSB_Test[8] = {0xFF, 0xFF, 0xD1, 0xD7,\r\n0xC5, 0xD9, 0xC3, 0xD4};\r\nvoid *ptr = (void *)&tp->ipb;\r\nunsigned short *ipb_ptr = (unsigned short *)ptr;\r\nunsigned char *cb_ptr = (unsigned char *) &tp->scb;\r\nunsigned char *sb_ptr = (unsigned char *) &tp->ssb;\r\nunsigned short Status;\r\nint i, loop_cnt, retry_cnt;\r\ntp->ipb.SCB_Addr = SWAPW(((char *)&tp->scb - (char *)tp) + tp->dmabuffer);\r\ntp->ipb.SSB_Addr = SWAPW(((char *)&tp->ssb - (char *)tp) + tp->dmabuffer);\r\nif(tms380tr_debug > 3)\r\n{\r\nprintk(KERN_DEBUG "%s: buffer (real): %lx\n", dev->name, (long) &tp->scb);\r\nprintk(KERN_DEBUG "%s: buffer (virt): %lx\n", dev->name, (long) ((char *)&tp->scb - (char *)tp) + (long) tp->dmabuffer);\r\nprintk(KERN_DEBUG "%s: buffer (DMA) : %lx\n", dev->name, (long) tp->dmabuffer);\r\nprintk(KERN_DEBUG "%s: buffer (tp) : %lx\n", dev->name, (long) tp);\r\n}\r\nretry_cnt = INIT_MAX_RETRIES;\r\ndo {\r\nretry_cnt--;\r\nSIFWRITEW(0x0001, SIFADX);\r\nSIFWRITEW(0x0A00, SIFADD);\r\nfor(i = 0; i < 11; i++)\r\nSIFWRITEW(ipb_ptr[i], SIFINC);\r\ntms380tr_exec_sifcmd(dev, CMD_EXECUTE);\r\nloop_cnt = INIT_MAX_LOOPCNT;\r\ndo {\r\nStatus = 0;\r\nloop_cnt--;\r\ntms380tr_wait(HALF_SECOND);\r\nStatus = SIFREADW(SIFSTS);\r\nStatus &= STS_MASK;\r\n} while(((Status &(STS_INITIALIZE | STS_ERROR | STS_TEST)) != 0) &&\r\n((Status & STS_ERROR) == 0) && (loop_cnt != 0));\r\nif((Status & (STS_INITIALIZE | STS_ERROR | STS_TEST)) == 0)\r\n{\r\ni = 0;\r\ndo {\r\nif(SCB_Test[i] != *(cb_ptr + i))\r\n{\r\nprintk(KERN_INFO "%s: DMA failed\n", dev->name);\r\nreturn -1;\r\n}\r\ni++;\r\n} while(i < 6);\r\ni = 0;\r\ndo {\r\nif(SSB_Test[i] != *(sb_ptr + i))\r\nreturn -1;\r\ni++;\r\n} while (i < 8);\r\nreturn 1;\r\n}\r\nelse\r\n{\r\nif((Status & STS_ERROR) != 0)\r\n{\r\nStatus = SIFREADW(SIFSTS);\r\nStatus &= STS_ERROR_MASK;\r\nprintk(KERN_INFO "%s: Status error: %d\n", dev->name, Status);\r\nreturn -1;\r\n}\r\nelse\r\n{\r\nif(retry_cnt > 0)\r\n{\r\ntms380tr_exec_sifcmd(dev, EXEC_SOFT_RESET);\r\ntms380tr_wait(HALF_SECOND);\r\n}\r\n}\r\n}\r\n} while(retry_cnt > 0);\r\nprintk(KERN_INFO "%s: Retry exceeded\n", dev->name);\r\nreturn -1;\r\n}\r\nstatic void tms380tr_chk_outstanding_cmds(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned long Addr = 0;\r\nif(tp->CMDqueue == 0)\r\nreturn;\r\nif(tp->ScbInUse == 1)\r\nreturn;\r\nif(tp->AdapterOpenFlag == 0)\r\n{\r\nif(tp->CMDqueue & OC_OPEN)\r\n{\r\ntp->CMDqueue ^= OC_OPEN;\r\nAddr = htonl(((char *)&tp->ocpl - (char *)tp) + tp->dmabuffer);\r\ntp->scb.Parm[0] = LOWORD(Addr);\r\ntp->scb.Parm[1] = HIWORD(Addr);\r\ntp->scb.CMD = OPEN;\r\n}\r\nelse\r\nreturn;\r\n}\r\nelse\r\n{\r\nif(tp->CMDqueue & OC_CLOSE)\r\n{\r\ntp->CMDqueue ^= OC_CLOSE;\r\ntp->AdapterOpenFlag = 0;\r\ntp->scb.Parm[0] = 0;\r\ntp->scb.Parm[1] = 0;\r\ntp->scb.CMD = CLOSE;\r\nif(!tp->HaltInProgress)\r\ntp->CMDqueue |= OC_OPEN;\r\nelse\r\ntp->CMDqueue = 0;\r\n}\r\nelse\r\n{\r\nif(tp->CMDqueue & OC_RECEIVE)\r\n{\r\ntp->CMDqueue ^= OC_RECEIVE;\r\nAddr = htonl(((char *)tp->RplHead - (char *)tp) + tp->dmabuffer);\r\ntp->scb.Parm[0] = LOWORD(Addr);\r\ntp->scb.Parm[1] = HIWORD(Addr);\r\ntp->scb.CMD = RECEIVE;\r\n}\r\nelse\r\n{\r\nif(tp->CMDqueue & OC_TRANSMIT_HALT)\r\n{\r\ntp->CMDqueue ^= OC_TRANSMIT_HALT;\r\ntp->scb.CMD = TRANSMIT_HALT;\r\ntp->scb.Parm[0] = 0;\r\ntp->scb.Parm[1] = 0;\r\n}\r\nelse\r\n{\r\nif(tp->CMDqueue & OC_TRANSMIT)\r\n{\r\nif(tp->TransmitCommandActive)\r\n{\r\nif(!tp->TransmitHaltScheduled)\r\n{\r\ntp->TransmitHaltScheduled = 1;\r\ntms380tr_exec_cmd(dev, OC_TRANSMIT_HALT) ;\r\n}\r\ntp->TransmitCommandActive = 0;\r\nreturn;\r\n}\r\ntp->CMDqueue ^= OC_TRANSMIT;\r\ntms380tr_cancel_tx_queue(tp);\r\nAddr = htonl(((char *)tp->TplBusy - (char *)tp) + tp->dmabuffer);\r\ntp->scb.Parm[0] = LOWORD(Addr);\r\ntp->scb.Parm[1] = HIWORD(Addr);\r\ntp->scb.CMD = TRANSMIT;\r\ntp->TransmitCommandActive = 1;\r\n}\r\nelse\r\n{\r\nif(tp->CMDqueue & OC_MODIFY_OPEN_PARMS)\r\n{\r\ntp->CMDqueue ^= OC_MODIFY_OPEN_PARMS;\r\ntp->scb.Parm[0] = tp->ocpl.OPENOptions;\r\ntp->scb.Parm[0] |= ENABLE_FULL_DUPLEX_SELECTION;\r\ntp->scb.Parm[1] = 0;\r\ntp->scb.CMD = MODIFY_OPEN_PARMS;\r\n}\r\nelse\r\n{\r\nif(tp->CMDqueue & OC_SET_FUNCT_ADDR)\r\n{\r\ntp->CMDqueue ^= OC_SET_FUNCT_ADDR;\r\ntp->scb.Parm[0] = LOWORD(tp->ocpl.FunctAddr);\r\ntp->scb.Parm[1] = HIWORD(tp->ocpl.FunctAddr);\r\ntp->scb.CMD = SET_FUNCT_ADDR;\r\n}\r\nelse\r\n{\r\nif(tp->CMDqueue & OC_SET_GROUP_ADDR)\r\n{\r\ntp->CMDqueue ^= OC_SET_GROUP_ADDR;\r\ntp->scb.Parm[0] = LOWORD(tp->ocpl.GroupAddr);\r\ntp->scb.Parm[1] = HIWORD(tp->ocpl.GroupAddr);\r\ntp->scb.CMD = SET_GROUP_ADDR;\r\n}\r\nelse\r\n{\r\nif(tp->CMDqueue & OC_READ_ERROR_LOG)\r\n{\r\ntp->CMDqueue ^= OC_READ_ERROR_LOG;\r\nAddr = htonl(((char *)&tp->errorlogtable - (char *)tp) + tp->dmabuffer);\r\ntp->scb.Parm[0] = LOWORD(Addr);\r\ntp->scb.Parm[1] = HIWORD(Addr);\r\ntp->scb.CMD = READ_ERROR_LOG;\r\n}\r\nelse\r\n{\r\nprintk(KERN_WARNING "CheckForOutstandingCommand: unknown Command\n");\r\ntp->CMDqueue = 0;\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\ntp->ScbInUse = 1;\r\ntms380tr_exec_sifcmd(dev, CMD_EXECUTE | CMD_SCB_REQUEST);\r\n}\r\nstatic void tms380tr_ring_status_irq(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\ntp->CurrentRingStatus = be16_to_cpu((unsigned short)tp->ssb.Parm[0]);\r\nif(tp->ssb.Parm[0] & SIGNAL_LOSS)\r\n{\r\nprintk(KERN_INFO "%s: Signal Loss\n", dev->name);\r\ntp->MacStat.line_errors++;\r\n}\r\nif(tp->ssb.Parm[0] & LOBE_WIRE_FAULT)\r\n{\r\nprintk(KERN_INFO "%s: Lobe Wire Fault, Reopen Adapter\n",\r\ndev->name);\r\ntp->MacStat.line_errors++;\r\n}\r\nif(tp->ssb.Parm[0] & RING_RECOVERY)\r\nprintk(KERN_INFO "%s: Ring Recovery\n", dev->name);\r\nif(tp->ssb.Parm[0] & COUNTER_OVERFLOW)\r\n{\r\nprintk(KERN_INFO "%s: Counter Overflow\n", dev->name);\r\ntms380tr_exec_cmd(dev, OC_READ_ERROR_LOG);\r\n}\r\nif(tp->ssb.Parm[0] & REMOVE_RECEIVED)\r\nprintk(KERN_INFO "%s: Remove Received, Reopen Adapter\n",\r\ndev->name);\r\nif(tp->ssb.Parm[0] & AUTO_REMOVAL_ERROR)\r\nprintk(KERN_INFO "%s: Auto Removal Error, Reopen Adapter\n",\r\ndev->name);\r\nif(tp->ssb.Parm[0] & HARD_ERROR)\r\nprintk(KERN_INFO "%s: Hard Error\n", dev->name);\r\nif(tp->ssb.Parm[0] & SOFT_ERROR)\r\nprintk(KERN_INFO "%s: Soft Error\n", dev->name);\r\nif(tp->ssb.Parm[0] & TRANSMIT_BEACON)\r\nprintk(KERN_INFO "%s: Transmit Beacon\n", dev->name);\r\nif(tp->ssb.Parm[0] & SINGLE_STATION)\r\nprintk(KERN_INFO "%s: Single Station\n", dev->name);\r\nif(tp->ssb.Parm[0] & ADAPTER_CLOSED)\r\n{\r\nprintk(KERN_INFO "%s: Adapter closed (Reopening),"\r\n"CurrentRingStat %x\n",\r\ndev->name, tp->CurrentRingStatus);\r\ntp->AdapterOpenFlag = 0;\r\ntms380tr_open_adapter(dev);\r\n}\r\n}\r\nstatic void tms380tr_chk_irq(struct net_device *dev)\r\n{\r\nint i;\r\nunsigned short AdapterCheckBlock[4];\r\nstruct net_local *tp = netdev_priv(dev);\r\ntp->AdapterOpenFlag = 0;\r\nSIFWRITEW(0x0001, SIFADX);\r\nSIFWRITEW(CHECKADDR, SIFADR);\r\nfor(i = 0; i < 4; i++)\r\nAdapterCheckBlock[i] = SIFREADW(SIFINC);\r\nif(tms380tr_debug > 3)\r\n{\r\nprintk(KERN_DEBUG "%s: AdapterCheckBlock: ", dev->name);\r\nfor (i = 0; i < 4; i++)\r\nprintk("%04X", AdapterCheckBlock[i]);\r\nprintk("\n");\r\n}\r\nswitch(AdapterCheckBlock[0])\r\n{\r\ncase DIO_PARITY:\r\nprintk(KERN_INFO "%s: DIO parity error\n", dev->name);\r\nbreak;\r\ncase DMA_READ_ABORT:\r\nprintk(KERN_INFO "%s DMA read operation aborted:\n",\r\ndev->name);\r\nswitch (AdapterCheckBlock[1])\r\n{\r\ncase 0:\r\nprintk(KERN_INFO "Timeout\n");\r\nprintk(KERN_INFO "Address: %04X %04X\n",\r\nAdapterCheckBlock[2],\r\nAdapterCheckBlock[3]);\r\nbreak;\r\ncase 1:\r\nprintk(KERN_INFO "Parity error\n");\r\nprintk(KERN_INFO "Address: %04X %04X\n",\r\nAdapterCheckBlock[2],\r\nAdapterCheckBlock[3]);\r\nbreak;\r\ncase 2:\r\nprintk(KERN_INFO "Bus error\n");\r\nprintk(KERN_INFO "Address: %04X %04X\n",\r\nAdapterCheckBlock[2],\r\nAdapterCheckBlock[3]);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "Unknown error.\n");\r\nbreak;\r\n}\r\nbreak;\r\ncase DMA_WRITE_ABORT:\r\nprintk(KERN_INFO "%s: DMA write operation aborted:\n",\r\ndev->name);\r\nswitch (AdapterCheckBlock[1])\r\n{\r\ncase 0:\r\nprintk(KERN_INFO "Timeout\n");\r\nprintk(KERN_INFO "Address: %04X %04X\n",\r\nAdapterCheckBlock[2],\r\nAdapterCheckBlock[3]);\r\nbreak;\r\ncase 1:\r\nprintk(KERN_INFO "Parity error\n");\r\nprintk(KERN_INFO "Address: %04X %04X\n",\r\nAdapterCheckBlock[2],\r\nAdapterCheckBlock[3]);\r\nbreak;\r\ncase 2:\r\nprintk(KERN_INFO "Bus error\n");\r\nprintk(KERN_INFO "Address: %04X %04X\n",\r\nAdapterCheckBlock[2],\r\nAdapterCheckBlock[3]);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "Unknown error.\n");\r\nbreak;\r\n}\r\nbreak;\r\ncase ILLEGAL_OP_CODE:\r\nprintk(KERN_INFO "%s: Illegal operation code in firmware\n",\r\ndev->name);\r\nbreak;\r\ncase PARITY_ERRORS:\r\nprintk(KERN_INFO "%s: Adapter internal bus parity error\n",\r\ndev->name);\r\nbreak;\r\ncase RAM_DATA_ERROR:\r\nprintk(KERN_INFO "%s: RAM data error\n", dev->name);\r\nbreak;\r\ncase RAM_PARITY_ERROR:\r\nprintk(KERN_INFO "%s: RAM parity error\n", dev->name);\r\nbreak;\r\ncase RING_UNDERRUN:\r\nprintk(KERN_INFO "%s: Internal DMA underrun detected\n",\r\ndev->name);\r\nbreak;\r\ncase INVALID_IRQ:\r\nprintk(KERN_INFO "%s: Unrecognized interrupt detected\n",\r\ndev->name);\r\nbreak;\r\ncase INVALID_ERROR_IRQ:\r\nprintk(KERN_INFO "%s: Unrecognized error interrupt detected\n",\r\ndev->name);\r\nbreak;\r\ncase INVALID_XOP:\r\nprintk(KERN_INFO "%s: Unrecognized XOP request detected\n",\r\ndev->name);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "%s: Unknown status", dev->name);\r\nbreak;\r\n}\r\nif(tms380tr_chipset_init(dev) == 1)\r\n{\r\ntp->AdapterOpenFlag = 1;\r\n}\r\n}\r\nstatic int tms380tr_read_ptr(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned short adapterram;\r\ntms380tr_read_ram(dev, (unsigned char *)&tp->intptrs.BurnedInAddrPtr,\r\nADAPTER_INT_PTRS, 16);\r\ntms380tr_read_ram(dev, (unsigned char *)&adapterram,\r\ncpu_to_be16((unsigned short)tp->intptrs.AdapterRAMPtr), 2);\r\nreturn be16_to_cpu(adapterram);\r\n}\r\nstatic void tms380tr_read_ram(struct net_device *dev, unsigned char *Data,\r\nunsigned short Address, int Length)\r\n{\r\nint i;\r\nunsigned short old_sifadx, old_sifadr, InWord;\r\nold_sifadx = SIFREADW(SIFADX);\r\nold_sifadr = SIFREADW(SIFADR);\r\nSIFWRITEW(0x0001, SIFADX);\r\nSIFWRITEW(Address, SIFADR);\r\ni = 0;\r\nfor(;;)\r\n{\r\nInWord = SIFREADW(SIFINC);\r\n*(Data + i) = HIBYTE(InWord);\r\nif(++i == Length)\r\nbreak;\r\n*(Data + i) = LOBYTE(InWord);\r\nif (++i == Length)\r\nbreak;\r\n}\r\nSIFWRITEW(old_sifadx, SIFADX);\r\nSIFWRITEW(old_sifadr, SIFADR);\r\n}\r\nstatic void tms380tr_cancel_tx_queue(struct net_local* tp)\r\n{\r\nTPL *tpl;\r\nif(tp->TransmitCommandActive)\r\nreturn;\r\nfor(;;)\r\n{\r\ntpl = tp->TplBusy;\r\nif(!tpl->BusyFlag)\r\nbreak;\r\ntp->TplBusy = tpl->NextTPLPtr;\r\ntms380tr_write_tpl_status(tpl, 0);\r\ntpl->BusyFlag = 0;\r\nprintk(KERN_INFO "Cancel tx (%08lXh).\n", (unsigned long)tpl);\r\nif (tpl->DMABuff)\r\ndma_unmap_single(tp->pdev, tpl->DMABuff, tpl->Skb->len, DMA_TO_DEVICE);\r\ndev_kfree_skb_any(tpl->Skb);\r\n}\r\n}\r\nstatic void tms380tr_tx_status_irq(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned char HighByte, HighAc, LowAc;\r\nTPL *tpl;\r\nfor(;;)\r\n{\r\ntpl = tp->TplBusy;\r\nif(!tpl->BusyFlag || (tpl->Status\r\n& (TX_VALID | TX_FRAME_COMPLETE))\r\n!= TX_FRAME_COMPLETE)\r\n{\r\nbreak;\r\n}\r\ntp->TplBusy = tpl->NextTPLPtr ;\r\nif(DIRECTED_FRAME(tpl) && (tpl->Status & TX_ERROR) == 0)\r\n{\r\nHighByte = GET_TRANSMIT_STATUS_HIGH_BYTE(tpl->Status);\r\nHighAc = GET_FRAME_STATUS_HIGH_AC(HighByte);\r\nLowAc = GET_FRAME_STATUS_LOW_AC(HighByte);\r\nif((HighAc != LowAc) || (HighAc == AC_NOT_RECOGNIZED))\r\n{\r\nprintk(KERN_DEBUG "%s: (DA=%08lX not recognized)\n",\r\ndev->name,\r\n*(unsigned long *)&tpl->MData[2+2]);\r\n}\r\nelse\r\n{\r\nif(tms380tr_debug > 3)\r\nprintk(KERN_DEBUG "%s: Directed frame tx'd\n",\r\ndev->name);\r\n}\r\n}\r\nelse\r\n{\r\nif(!DIRECTED_FRAME(tpl))\r\n{\r\nif(tms380tr_debug > 3)\r\nprintk(KERN_DEBUG "%s: Broadcast frame tx'd\n",\r\ndev->name);\r\n}\r\n}\r\ntp->MacStat.tx_packets++;\r\nif (tpl->DMABuff)\r\ndma_unmap_single(tp->pdev, tpl->DMABuff, tpl->Skb->len, DMA_TO_DEVICE);\r\ndev_kfree_skb_irq(tpl->Skb);\r\ntpl->BusyFlag = 0;\r\n}\r\nif(!tp->TplFree->NextTPLPtr->BusyFlag)\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void tms380tr_rcv_status_irq(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned char *ReceiveDataPtr;\r\nstruct sk_buff *skb;\r\nunsigned int Length, Length2;\r\nRPL *rpl;\r\nRPL *SaveHead;\r\ndma_addr_t dmabuf;\r\nfor(;;)\r\n{\r\nrpl = tp->RplHead;\r\nif(rpl->Status & RX_VALID)\r\nbreak;\r\nSaveHead = tp->RplHead;\r\ntp->RplHead = rpl->NextRPLPtr;\r\nLength = be16_to_cpu(rpl->FrameSize);\r\nif((rpl->Status & VALID_SINGLE_BUFFER_FRAME)\r\n== VALID_SINGLE_BUFFER_FRAME)\r\n{\r\nReceiveDataPtr = rpl->MData;\r\nLength2 = be16_to_cpu(rpl->FrameSize);\r\nif(Length == 0 || Length != Length2)\r\n{\r\ntp->RplHead = SaveHead;\r\nbreak;\r\n}\r\ntms380tr_update_rcv_stats(tp,ReceiveDataPtr,Length);\r\nif(tms380tr_debug > 3)\r\nprintk(KERN_DEBUG "%s: Packet Length %04X (%d)\n",\r\ndev->name, Length, Length);\r\nskb = rpl->Skb;\r\nif(rpl->SkbStat == SKB_UNAVAILABLE)\r\n{\r\nskb = dev_alloc_skb(tp->MaxPacketSize);\r\nif(skb == NULL)\r\n{\r\n}\r\nelse\r\n{\r\nskb_put(skb, tp->MaxPacketSize);\r\nrpl->SkbStat = SKB_DATA_COPY;\r\nReceiveDataPtr = rpl->MData;\r\n}\r\n}\r\nif(skb && (rpl->SkbStat == SKB_DATA_COPY ||\r\nrpl->SkbStat == SKB_DMA_DIRECT))\r\n{\r\nif(rpl->SkbStat == SKB_DATA_COPY)\r\nskb_copy_to_linear_data(skb, ReceiveDataPtr,\r\nLength);\r\nrpl->Skb = NULL;\r\nskb_trim(skb,Length);\r\nskb->protocol = tr_type_trans(skb,dev);\r\nnetif_rx(skb);\r\n}\r\n}\r\nelse\r\n{\r\nif(rpl->Skb != NULL)\r\ndev_kfree_skb_irq(rpl->Skb);\r\nif(rpl->Status & RX_START_FRAME)\r\ntp->MacStat.rx_errors++;\r\n}\r\nif (rpl->DMABuff)\r\ndma_unmap_single(tp->pdev, rpl->DMABuff, tp->MaxPacketSize, DMA_TO_DEVICE);\r\nrpl->DMABuff = 0;\r\nrpl->Skb = dev_alloc_skb(tp->MaxPacketSize);\r\nif(rpl->Skb == NULL)\r\n{\r\nrpl->SkbStat = SKB_UNAVAILABLE;\r\nrpl->FragList[0].DataAddr = htonl(((char *)tp->LocalRxBuffers[rpl->RPLIndex] - (char *)tp) + tp->dmabuffer);\r\nrpl->MData = tp->LocalRxBuffers[rpl->RPLIndex];\r\n}\r\nelse\r\n{\r\nrpl->Skb->dev = dev;\r\nskb_put(rpl->Skb, tp->MaxPacketSize);\r\ndmabuf = dma_map_single(tp->pdev, rpl->Skb->data, tp->MaxPacketSize, DMA_FROM_DEVICE);\r\nif(tp->dmalimit && (dmabuf + tp->MaxPacketSize > tp->dmalimit))\r\n{\r\nrpl->SkbStat = SKB_DATA_COPY;\r\nrpl->FragList[0].DataAddr = htonl(((char *)tp->LocalRxBuffers[rpl->RPLIndex] - (char *)tp) + tp->dmabuffer);\r\nrpl->MData = tp->LocalRxBuffers[rpl->RPLIndex];\r\n}\r\nelse\r\n{\r\nrpl->SkbStat = SKB_DMA_DIRECT;\r\nrpl->FragList[0].DataAddr = htonl(dmabuf);\r\nrpl->MData = rpl->Skb->data;\r\nrpl->DMABuff = dmabuf;\r\n}\r\n}\r\nrpl->FragList[0].DataCount = cpu_to_be16((unsigned short)tp->MaxPacketSize);\r\nrpl->FrameSize = 0;\r\ntp->RplTail->FrameSize = 0;\r\ntms380tr_write_rpl_status(tp->RplTail, RX_VALID | RX_FRAME_IRQ);\r\ntp->RplTail = tp->RplTail->NextRPLPtr;\r\ntms380tr_exec_sifcmd(dev, CMD_RX_VALID);\r\n}\r\n}\r\nstatic void tms380tr_write_rpl_status(RPL *rpl, unsigned int Status)\r\n{\r\nrpl->Status = Status;\r\n}\r\nstatic void tms380tr_update_rcv_stats(struct net_local *tp, unsigned char DataPtr[],\r\nunsigned int Length)\r\n{\r\ntp->MacStat.rx_packets++;\r\ntp->MacStat.rx_bytes += Length;\r\nif(DataPtr[2] & GROUP_BIT)\r\ntp->MacStat.multicast++;\r\n}\r\nstatic int tms380tr_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nstruct sockaddr *saddr = addr;\r\nif (tp->AdapterOpenFlag || tp->AdapterVirtOpenFlag) {\r\nprintk(KERN_WARNING "%s: Cannot set MAC/LAA address while card is open\n", dev->name);\r\nreturn -EIO;\r\n}\r\nmemcpy(dev->dev_addr, saddr->sa_data, dev->addr_len);\r\nreturn 0;\r\n}\r\nstatic void tms380tr_dump(unsigned char *Data, int length)\r\n{\r\nint i, j;\r\nfor (i = 0, j = 0; i < length / 8; i++, j += 8)\r\n{\r\nprintk(KERN_DEBUG "%02x %02x %02x %02x %02x %02x %02x %02x\n",\r\nData[j+0],Data[j+1],Data[j+2],Data[j+3],\r\nData[j+4],Data[j+5],Data[j+6],Data[j+7]);\r\n}\r\n}\r\nvoid tmsdev_term(struct net_device *dev)\r\n{\r\nstruct net_local *tp;\r\ntp = netdev_priv(dev);\r\ndma_unmap_single(tp->pdev, tp->dmabuffer, sizeof(struct net_local),\r\nDMA_BIDIRECTIONAL);\r\n}\r\nint tmsdev_init(struct net_device *dev, struct device *pdev)\r\n{\r\nstruct net_local *tms_local;\r\nmemset(netdev_priv(dev), 0, sizeof(struct net_local));\r\ntms_local = netdev_priv(dev);\r\ninit_waitqueue_head(&tms_local->wait_for_tok_int);\r\nif (pdev->dma_mask)\r\ntms_local->dmalimit = *pdev->dma_mask;\r\nelse\r\nreturn -ENOMEM;\r\ntms_local->pdev = pdev;\r\ntms_local->dmabuffer = dma_map_single(pdev, (void *)tms_local,\r\nsizeof(struct net_local), DMA_BIDIRECTIONAL);\r\nif (tms_local->dmabuffer + sizeof(struct net_local) >\r\ntms_local->dmalimit)\r\n{\r\nprintk(KERN_INFO "%s: Memory not accessible for DMA\n",\r\ndev->name);\r\ntmsdev_term(dev);\r\nreturn -ENOMEM;\r\n}\r\ndev->netdev_ops = &tms380tr_netdev_ops;\r\ndev->watchdog_timeo = HZ;\r\nreturn 0;\r\n}\r\nint init_module(void)\r\n{\r\nprintk(KERN_DEBUG "%s", version);\r\nTMS380_module = &__this_module;\r\nreturn 0;\r\n}\r\nvoid cleanup_module(void)\r\n{\r\nTMS380_module = NULL;\r\n}
