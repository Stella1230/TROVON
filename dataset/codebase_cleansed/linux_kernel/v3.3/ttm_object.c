static inline struct ttm_object_file *\r\nttm_object_file_ref(struct ttm_object_file *tfile)\r\n{\r\nkref_get(&tfile->refcount);\r\nreturn tfile;\r\n}\r\nstatic void ttm_object_file_destroy(struct kref *kref)\r\n{\r\nstruct ttm_object_file *tfile =\r\ncontainer_of(kref, struct ttm_object_file, refcount);\r\nkfree(tfile);\r\n}\r\nstatic inline void ttm_object_file_unref(struct ttm_object_file **p_tfile)\r\n{\r\nstruct ttm_object_file *tfile = *p_tfile;\r\n*p_tfile = NULL;\r\nkref_put(&tfile->refcount, ttm_object_file_destroy);\r\n}\r\nint ttm_base_object_init(struct ttm_object_file *tfile,\r\nstruct ttm_base_object *base,\r\nbool shareable,\r\nenum ttm_object_type object_type,\r\nvoid (*refcount_release) (struct ttm_base_object **),\r\nvoid (*ref_obj_release) (struct ttm_base_object *,\r\nenum ttm_ref_type ref_type))\r\n{\r\nstruct ttm_object_device *tdev = tfile->tdev;\r\nint ret;\r\nbase->shareable = shareable;\r\nbase->tfile = ttm_object_file_ref(tfile);\r\nbase->refcount_release = refcount_release;\r\nbase->ref_obj_release = ref_obj_release;\r\nbase->object_type = object_type;\r\nwrite_lock(&tdev->object_lock);\r\nkref_init(&base->refcount);\r\nret = drm_ht_just_insert_please(&tdev->object_hash,\r\n&base->hash,\r\n(unsigned long)base, 31, 0, 0);\r\nwrite_unlock(&tdev->object_lock);\r\nif (unlikely(ret != 0))\r\ngoto out_err0;\r\nret = ttm_ref_object_add(tfile, base, TTM_REF_USAGE, NULL);\r\nif (unlikely(ret != 0))\r\ngoto out_err1;\r\nttm_base_object_unref(&base);\r\nreturn 0;\r\nout_err1:\r\n(void)drm_ht_remove_item(&tdev->object_hash, &base->hash);\r\nout_err0:\r\nreturn ret;\r\n}\r\nstatic void ttm_release_base(struct kref *kref)\r\n{\r\nstruct ttm_base_object *base =\r\ncontainer_of(kref, struct ttm_base_object, refcount);\r\nstruct ttm_object_device *tdev = base->tfile->tdev;\r\n(void)drm_ht_remove_item(&tdev->object_hash, &base->hash);\r\nwrite_unlock(&tdev->object_lock);\r\nif (base->refcount_release) {\r\nttm_object_file_unref(&base->tfile);\r\nbase->refcount_release(&base);\r\n}\r\nwrite_lock(&tdev->object_lock);\r\n}\r\nvoid ttm_base_object_unref(struct ttm_base_object **p_base)\r\n{\r\nstruct ttm_base_object *base = *p_base;\r\nstruct ttm_object_device *tdev = base->tfile->tdev;\r\n*p_base = NULL;\r\nwrite_lock(&tdev->object_lock);\r\nkref_put(&base->refcount, ttm_release_base);\r\nwrite_unlock(&tdev->object_lock);\r\n}\r\nstruct ttm_base_object *ttm_base_object_lookup(struct ttm_object_file *tfile,\r\nuint32_t key)\r\n{\r\nstruct ttm_object_device *tdev = tfile->tdev;\r\nstruct ttm_base_object *base;\r\nstruct drm_hash_item *hash;\r\nint ret;\r\nread_lock(&tdev->object_lock);\r\nret = drm_ht_find_item(&tdev->object_hash, key, &hash);\r\nif (likely(ret == 0)) {\r\nbase = drm_hash_entry(hash, struct ttm_base_object, hash);\r\nkref_get(&base->refcount);\r\n}\r\nread_unlock(&tdev->object_lock);\r\nif (unlikely(ret != 0))\r\nreturn NULL;\r\nif (tfile != base->tfile && !base->shareable) {\r\nprintk(KERN_ERR TTM_PFX\r\n"Attempted access of non-shareable object.\n");\r\nttm_base_object_unref(&base);\r\nreturn NULL;\r\n}\r\nreturn base;\r\n}\r\nint ttm_ref_object_add(struct ttm_object_file *tfile,\r\nstruct ttm_base_object *base,\r\nenum ttm_ref_type ref_type, bool *existed)\r\n{\r\nstruct drm_open_hash *ht = &tfile->ref_hash[ref_type];\r\nstruct ttm_ref_object *ref;\r\nstruct drm_hash_item *hash;\r\nstruct ttm_mem_global *mem_glob = tfile->tdev->mem_glob;\r\nint ret = -EINVAL;\r\nif (existed != NULL)\r\n*existed = true;\r\nwhile (ret == -EINVAL) {\r\nread_lock(&tfile->lock);\r\nret = drm_ht_find_item(ht, base->hash.key, &hash);\r\nif (ret == 0) {\r\nref = drm_hash_entry(hash, struct ttm_ref_object, hash);\r\nkref_get(&ref->kref);\r\nread_unlock(&tfile->lock);\r\nbreak;\r\n}\r\nread_unlock(&tfile->lock);\r\nret = ttm_mem_global_alloc(mem_glob, sizeof(*ref),\r\nfalse, false);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nref = kmalloc(sizeof(*ref), GFP_KERNEL);\r\nif (unlikely(ref == NULL)) {\r\nttm_mem_global_free(mem_glob, sizeof(*ref));\r\nreturn -ENOMEM;\r\n}\r\nref->hash.key = base->hash.key;\r\nref->obj = base;\r\nref->tfile = tfile;\r\nref->ref_type = ref_type;\r\nkref_init(&ref->kref);\r\nwrite_lock(&tfile->lock);\r\nret = drm_ht_insert_item(ht, &ref->hash);\r\nif (likely(ret == 0)) {\r\nlist_add_tail(&ref->head, &tfile->ref_list);\r\nkref_get(&base->refcount);\r\nwrite_unlock(&tfile->lock);\r\nif (existed != NULL)\r\n*existed = false;\r\nbreak;\r\n}\r\nwrite_unlock(&tfile->lock);\r\nBUG_ON(ret != -EINVAL);\r\nttm_mem_global_free(mem_glob, sizeof(*ref));\r\nkfree(ref);\r\n}\r\nreturn ret;\r\n}\r\nstatic void ttm_ref_object_release(struct kref *kref)\r\n{\r\nstruct ttm_ref_object *ref =\r\ncontainer_of(kref, struct ttm_ref_object, kref);\r\nstruct ttm_base_object *base = ref->obj;\r\nstruct ttm_object_file *tfile = ref->tfile;\r\nstruct drm_open_hash *ht;\r\nstruct ttm_mem_global *mem_glob = tfile->tdev->mem_glob;\r\nht = &tfile->ref_hash[ref->ref_type];\r\n(void)drm_ht_remove_item(ht, &ref->hash);\r\nlist_del(&ref->head);\r\nwrite_unlock(&tfile->lock);\r\nif (ref->ref_type != TTM_REF_USAGE && base->ref_obj_release)\r\nbase->ref_obj_release(base, ref->ref_type);\r\nttm_base_object_unref(&ref->obj);\r\nttm_mem_global_free(mem_glob, sizeof(*ref));\r\nkfree(ref);\r\nwrite_lock(&tfile->lock);\r\n}\r\nint ttm_ref_object_base_unref(struct ttm_object_file *tfile,\r\nunsigned long key, enum ttm_ref_type ref_type)\r\n{\r\nstruct drm_open_hash *ht = &tfile->ref_hash[ref_type];\r\nstruct ttm_ref_object *ref;\r\nstruct drm_hash_item *hash;\r\nint ret;\r\nwrite_lock(&tfile->lock);\r\nret = drm_ht_find_item(ht, key, &hash);\r\nif (unlikely(ret != 0)) {\r\nwrite_unlock(&tfile->lock);\r\nreturn -EINVAL;\r\n}\r\nref = drm_hash_entry(hash, struct ttm_ref_object, hash);\r\nkref_put(&ref->kref, ttm_ref_object_release);\r\nwrite_unlock(&tfile->lock);\r\nreturn 0;\r\n}\r\nvoid ttm_object_file_release(struct ttm_object_file **p_tfile)\r\n{\r\nstruct ttm_ref_object *ref;\r\nstruct list_head *list;\r\nunsigned int i;\r\nstruct ttm_object_file *tfile = *p_tfile;\r\n*p_tfile = NULL;\r\nwrite_lock(&tfile->lock);\r\nwhile (!list_empty(&tfile->ref_list)) {\r\nlist = tfile->ref_list.next;\r\nref = list_entry(list, struct ttm_ref_object, head);\r\nttm_ref_object_release(&ref->kref);\r\n}\r\nfor (i = 0; i < TTM_REF_NUM; ++i)\r\ndrm_ht_remove(&tfile->ref_hash[i]);\r\nwrite_unlock(&tfile->lock);\r\nttm_object_file_unref(&tfile);\r\n}\r\nstruct ttm_object_file *ttm_object_file_init(struct ttm_object_device *tdev,\r\nunsigned int hash_order)\r\n{\r\nstruct ttm_object_file *tfile = kmalloc(sizeof(*tfile), GFP_KERNEL);\r\nunsigned int i;\r\nunsigned int j = 0;\r\nint ret;\r\nif (unlikely(tfile == NULL))\r\nreturn NULL;\r\nrwlock_init(&tfile->lock);\r\ntfile->tdev = tdev;\r\nkref_init(&tfile->refcount);\r\nINIT_LIST_HEAD(&tfile->ref_list);\r\nfor (i = 0; i < TTM_REF_NUM; ++i) {\r\nret = drm_ht_create(&tfile->ref_hash[i], hash_order);\r\nif (ret) {\r\nj = i;\r\ngoto out_err;\r\n}\r\n}\r\nreturn tfile;\r\nout_err:\r\nfor (i = 0; i < j; ++i)\r\ndrm_ht_remove(&tfile->ref_hash[i]);\r\nkfree(tfile);\r\nreturn NULL;\r\n}\r\nstruct ttm_object_device *ttm_object_device_init(struct ttm_mem_global\r\n*mem_glob,\r\nunsigned int hash_order)\r\n{\r\nstruct ttm_object_device *tdev = kmalloc(sizeof(*tdev), GFP_KERNEL);\r\nint ret;\r\nif (unlikely(tdev == NULL))\r\nreturn NULL;\r\ntdev->mem_glob = mem_glob;\r\nrwlock_init(&tdev->object_lock);\r\natomic_set(&tdev->object_count, 0);\r\nret = drm_ht_create(&tdev->object_hash, hash_order);\r\nif (likely(ret == 0))\r\nreturn tdev;\r\nkfree(tdev);\r\nreturn NULL;\r\n}\r\nvoid ttm_object_device_release(struct ttm_object_device **p_tdev)\r\n{\r\nstruct ttm_object_device *tdev = *p_tdev;\r\n*p_tdev = NULL;\r\nwrite_lock(&tdev->object_lock);\r\ndrm_ht_remove(&tdev->object_hash);\r\nwrite_unlock(&tdev->object_lock);\r\nkfree(tdev);\r\n}
