int mgr_create(struct mgr_object **mgr_obj,\r\nstruct cfg_devnode *dev_node_obj)\r\n{\r\nint status = 0;\r\nstruct mgr_object *pmgr_obj = NULL;\r\nstruct drv_data *drv_datap = dev_get_drvdata(bridge);\r\nDBC_REQUIRE(mgr_obj != NULL);\r\nDBC_REQUIRE(refs > 0);\r\npmgr_obj = kzalloc(sizeof(struct mgr_object), GFP_KERNEL);\r\nif (pmgr_obj) {\r\nstatus = dcd_create_manager(ZLDLLNAME, &pmgr_obj->dcd_mgr);\r\nif (!status) {\r\nif (drv_datap) {\r\ndrv_datap->mgr_object = (void *)pmgr_obj;\r\n} else {\r\nstatus = -EPERM;\r\npr_err("%s: Failed to store MGR object\n",\r\n__func__);\r\n}\r\nif (!status) {\r\n*mgr_obj = pmgr_obj;\r\n} else {\r\ndcd_destroy_manager(pmgr_obj->dcd_mgr);\r\nkfree(pmgr_obj);\r\n}\r\n} else {\r\nkfree(pmgr_obj);\r\n}\r\n} else {\r\nstatus = -ENOMEM;\r\n}\r\nDBC_ENSURE(status || pmgr_obj);\r\nreturn status;\r\n}\r\nint mgr_destroy(struct mgr_object *hmgr_obj)\r\n{\r\nint status = 0;\r\nstruct mgr_object *pmgr_obj = (struct mgr_object *)hmgr_obj;\r\nstruct drv_data *drv_datap = dev_get_drvdata(bridge);\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(hmgr_obj);\r\nif (hmgr_obj->dcd_mgr)\r\ndcd_destroy_manager(hmgr_obj->dcd_mgr);\r\nkfree(pmgr_obj);\r\nif (drv_datap) {\r\ndrv_datap->mgr_object = NULL;\r\n} else {\r\nstatus = -EPERM;\r\npr_err("%s: Failed to store MGR object\n", __func__);\r\n}\r\nreturn status;\r\n}\r\nint mgr_enum_node_info(u32 node_id, struct dsp_ndbprops *pndb_props,\r\nu32 undb_props_size, u32 *pu_num_nodes)\r\n{\r\nint status = 0;\r\nstruct dsp_uuid node_uuid;\r\nu32 node_index = 0;\r\nstruct dcd_genericobj gen_obj;\r\nstruct mgr_object *pmgr_obj = NULL;\r\nstruct drv_data *drv_datap = dev_get_drvdata(bridge);\r\nDBC_REQUIRE(pndb_props != NULL);\r\nDBC_REQUIRE(pu_num_nodes != NULL);\r\nDBC_REQUIRE(undb_props_size >= sizeof(struct dsp_ndbprops));\r\nDBC_REQUIRE(refs > 0);\r\n*pu_num_nodes = 0;\r\nif (!drv_datap || !drv_datap->mgr_object) {\r\npr_err("%s: Failed to retrieve the object handle\n", __func__);\r\nreturn -ENODATA;\r\n}\r\npmgr_obj = drv_datap->mgr_object;\r\nDBC_ASSERT(pmgr_obj);\r\nwhile (!status) {\r\nstatus = dcd_enumerate_object(node_index++, DSP_DCDNODETYPE,\r\n&node_uuid);\r\nif (status)\r\nbreak;\r\n*pu_num_nodes = node_index;\r\nif (node_id == (node_index - 1)) {\r\nstatus = dcd_get_object_def(pmgr_obj->dcd_mgr,\r\n&node_uuid, DSP_DCDNODETYPE, &gen_obj);\r\nif (status)\r\nbreak;\r\n*pndb_props = gen_obj.obj_data.node_obj.ndb_props;\r\n}\r\n}\r\nif (status > 0)\r\nstatus = 0;\r\nreturn status;\r\n}\r\nint mgr_enum_processor_info(u32 processor_id,\r\nstruct dsp_processorinfo *\r\nprocessor_info, u32 processor_info_size,\r\nu8 *pu_num_procs)\r\n{\r\nint status = 0;\r\nint status1 = 0;\r\nint status2 = 0;\r\nstruct dsp_uuid temp_uuid;\r\nu32 temp_index = 0;\r\nu32 proc_index = 0;\r\nstruct dcd_genericobj gen_obj;\r\nstruct mgr_object *pmgr_obj = NULL;\r\nstruct mgr_processorextinfo *ext_info;\r\nstruct dev_object *hdev_obj;\r\nstruct drv_object *hdrv_obj;\r\nu8 dev_type;\r\nstruct cfg_devnode *dev_node;\r\nstruct drv_data *drv_datap = dev_get_drvdata(bridge);\r\nbool proc_detect = false;\r\nDBC_REQUIRE(processor_info != NULL);\r\nDBC_REQUIRE(pu_num_procs != NULL);\r\nDBC_REQUIRE(processor_info_size >= sizeof(struct dsp_processorinfo));\r\nDBC_REQUIRE(refs > 0);\r\n*pu_num_procs = 0;\r\nif (!drv_datap || !drv_datap->drv_object) {\r\nstatus = -ENODATA;\r\npr_err("%s: Failed to retrieve the object handle\n", __func__);\r\n} else {\r\nhdrv_obj = drv_datap->drv_object;\r\n}\r\nif (!status) {\r\nstatus = drv_get_dev_object(processor_id, hdrv_obj, &hdev_obj);\r\nif (!status) {\r\nstatus = dev_get_dev_type(hdev_obj, (u8 *) &dev_type);\r\nstatus = dev_get_dev_node(hdev_obj, &dev_node);\r\nif (dev_type != DSP_UNIT)\r\nstatus = -EPERM;\r\nif (!status)\r\nprocessor_info->processor_type = DSPTYPE64;\r\n}\r\n}\r\nif (status)\r\ngoto func_end;\r\nif (drv_datap && drv_datap->mgr_object) {\r\npmgr_obj = drv_datap->mgr_object;\r\n} else {\r\ndev_dbg(bridge, "%s: Failed to get MGR Object\n", __func__);\r\ngoto func_end;\r\n}\r\nDBC_ASSERT(pmgr_obj);\r\nwhile (status1 == 0) {\r\nstatus1 = dcd_enumerate_object(temp_index++,\r\nDSP_DCDPROCESSORTYPE,\r\n&temp_uuid);\r\nif (status1 != 0)\r\nbreak;\r\nproc_index++;\r\nif (proc_detect != false)\r\ncontinue;\r\nstatus2 = dcd_get_object_def(pmgr_obj->dcd_mgr,\r\n(struct dsp_uuid *)&temp_uuid,\r\nDSP_DCDPROCESSORTYPE, &gen_obj);\r\nif (!status2) {\r\nif (processor_info_size <\r\nsizeof(struct mgr_processorextinfo)) {\r\n*processor_info = gen_obj.obj_data.proc_info;\r\n} else {\r\next_info = (struct mgr_processorextinfo *)\r\nprocessor_info;\r\n*ext_info = gen_obj.obj_data.ext_proc_obj;\r\n}\r\ndev_dbg(bridge, "%s: Got proctype from DCD %x\n",\r\n__func__, processor_info->processor_type);\r\nif (dev_type == DSP_UNIT) {\r\nif (processor_info->processor_type ==\r\nDSPPROCTYPE_C64)\r\nproc_detect = true;\r\n} else if (dev_type == IVA_UNIT) {\r\nif (processor_info->processor_type ==\r\nIVAPROCTYPE_ARM7)\r\nproc_detect = true;\r\n}\r\nprocessor_info->processor_type = DSPTYPE64;\r\n} else {\r\ndev_dbg(bridge, "%s: Failed to get DCD processor info "\r\n"%x\n", __func__, status2);\r\nstatus = -EPERM;\r\n}\r\n}\r\n*pu_num_procs = proc_index;\r\nif (proc_detect == false) {\r\ndev_dbg(bridge, "%s: Failed to get proc info from DCD, so use "\r\n"CFG registry\n", __func__);\r\nprocessor_info->processor_type = DSPTYPE64;\r\n}\r\nfunc_end:\r\nreturn status;\r\n}\r\nvoid mgr_exit(void)\r\n{\r\nDBC_REQUIRE(refs > 0);\r\nrefs--;\r\nif (refs == 0)\r\ndcd_exit();\r\nDBC_ENSURE(refs >= 0);\r\n}\r\nint mgr_get_dcd_handle(struct mgr_object *mgr_handle,\r\nu32 *dcd_handle)\r\n{\r\nint status = -EPERM;\r\nstruct mgr_object *pmgr_obj = (struct mgr_object *)mgr_handle;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(dcd_handle != NULL);\r\n*dcd_handle = (u32) NULL;\r\nif (pmgr_obj) {\r\n*dcd_handle = (u32) pmgr_obj->dcd_mgr;\r\nstatus = 0;\r\n}\r\nDBC_ENSURE((!status && *dcd_handle != (u32) NULL) ||\r\n(status && *dcd_handle == (u32) NULL));\r\nreturn status;\r\n}\r\nbool mgr_init(void)\r\n{\r\nbool ret = true;\r\nbool init_dcd = false;\r\nDBC_REQUIRE(refs >= 0);\r\nif (refs == 0) {\r\ninit_dcd = dcd_init();\r\nif (!init_dcd)\r\nret = false;\r\n}\r\nif (ret)\r\nrefs++;\r\nDBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));\r\nreturn ret;\r\n}\r\nint mgr_wait_for_bridge_events(struct dsp_notification **anotifications,\r\nu32 count, u32 *pu_index,\r\nu32 utimeout)\r\n{\r\nint status;\r\nstruct sync_object *sync_events[MAX_EVENTS];\r\nu32 i;\r\nDBC_REQUIRE(count < MAX_EVENTS);\r\nfor (i = 0; i < count; i++)\r\nsync_events[i] = anotifications[i]->handle;\r\nstatus = sync_wait_on_multiple_events(sync_events, count, utimeout,\r\npu_index);\r\nreturn status;\r\n}
