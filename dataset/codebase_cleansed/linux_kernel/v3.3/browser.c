static int ui_browser__percent_color(struct ui_browser *browser,\r\ndouble percent, bool current)\r\n{\r\nif (current && (!browser->use_navkeypressed || browser->navkeypressed))\r\nreturn HE_COLORSET_SELECTED;\r\nif (percent >= MIN_RED)\r\nreturn HE_COLORSET_TOP;\r\nif (percent >= MIN_GREEN)\r\nreturn HE_COLORSET_MEDIUM;\r\nreturn HE_COLORSET_NORMAL;\r\n}\r\nvoid ui_browser__set_color(struct ui_browser *self __used, int color)\r\n{\r\nSLsmg_set_color(color);\r\n}\r\nvoid ui_browser__set_percent_color(struct ui_browser *self,\r\ndouble percent, bool current)\r\n{\r\nint color = ui_browser__percent_color(self, percent, current);\r\nui_browser__set_color(self, color);\r\n}\r\nvoid ui_browser__gotorc(struct ui_browser *self, int y, int x)\r\n{\r\nSLsmg_gotorc(self->y + y, self->x + x);\r\n}\r\nstatic struct list_head *\r\nui_browser__list_head_filter_entries(struct ui_browser *browser,\r\nstruct list_head *pos)\r\n{\r\ndo {\r\nif (!browser->filter || !browser->filter(browser, pos))\r\nreturn pos;\r\npos = pos->next;\r\n} while (pos != browser->entries);\r\nreturn NULL;\r\n}\r\nstatic struct list_head *\r\nui_browser__list_head_filter_prev_entries(struct ui_browser *browser,\r\nstruct list_head *pos)\r\n{\r\ndo {\r\nif (!browser->filter || !browser->filter(browser, pos))\r\nreturn pos;\r\npos = pos->prev;\r\n} while (pos != browser->entries);\r\nreturn NULL;\r\n}\r\nvoid ui_browser__list_head_seek(struct ui_browser *self, off_t offset, int whence)\r\n{\r\nstruct list_head *head = self->entries;\r\nstruct list_head *pos;\r\nif (self->nr_entries == 0)\r\nreturn;\r\nswitch (whence) {\r\ncase SEEK_SET:\r\npos = ui_browser__list_head_filter_entries(self, head->next);\r\nbreak;\r\ncase SEEK_CUR:\r\npos = self->top;\r\nbreak;\r\ncase SEEK_END:\r\npos = ui_browser__list_head_filter_prev_entries(self, head->prev);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nassert(pos != NULL);\r\nif (offset > 0) {\r\nwhile (offset-- != 0)\r\npos = ui_browser__list_head_filter_entries(self, pos->next);\r\n} else {\r\nwhile (offset++ != 0)\r\npos = ui_browser__list_head_filter_prev_entries(self, pos->prev);\r\n}\r\nself->top = pos;\r\n}\r\nvoid ui_browser__rb_tree_seek(struct ui_browser *self, off_t offset, int whence)\r\n{\r\nstruct rb_root *root = self->entries;\r\nstruct rb_node *nd;\r\nswitch (whence) {\r\ncase SEEK_SET:\r\nnd = rb_first(root);\r\nbreak;\r\ncase SEEK_CUR:\r\nnd = self->top;\r\nbreak;\r\ncase SEEK_END:\r\nnd = rb_last(root);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (offset > 0) {\r\nwhile (offset-- != 0)\r\nnd = rb_next(nd);\r\n} else {\r\nwhile (offset++ != 0)\r\nnd = rb_prev(nd);\r\n}\r\nself->top = nd;\r\n}\r\nunsigned int ui_browser__rb_tree_refresh(struct ui_browser *self)\r\n{\r\nstruct rb_node *nd;\r\nint row = 0;\r\nif (self->top == NULL)\r\nself->top = rb_first(self->entries);\r\nnd = self->top;\r\nwhile (nd != NULL) {\r\nui_browser__gotorc(self, row, 0);\r\nself->write(self, nd, row);\r\nif (++row == self->height)\r\nbreak;\r\nnd = rb_next(nd);\r\n}\r\nreturn row;\r\n}\r\nbool ui_browser__is_current_entry(struct ui_browser *self, unsigned row)\r\n{\r\nreturn self->top_idx + row == self->index;\r\n}\r\nvoid ui_browser__refresh_dimensions(struct ui_browser *self)\r\n{\r\nself->width = SLtt_Screen_Cols - 1;\r\nself->height = SLtt_Screen_Rows - 2;\r\nself->y = 1;\r\nself->x = 0;\r\n}\r\nvoid ui_browser__handle_resize(struct ui_browser *browser)\r\n{\r\nui__refresh_dimensions(false);\r\nui_browser__show(browser, browser->title, ui_helpline__current);\r\nui_browser__refresh(browser);\r\n}\r\nint ui_browser__warning(struct ui_browser *browser, int timeout,\r\nconst char *format, ...)\r\n{\r\nva_list args;\r\nchar *text;\r\nint key = 0, err;\r\nva_start(args, format);\r\nerr = vasprintf(&text, format, args);\r\nva_end(args);\r\nif (err < 0) {\r\nva_start(args, format);\r\nui_helpline__vpush(format, args);\r\nva_end(args);\r\n} else {\r\nwhile ((key == ui__question_window("Warning!", text,\r\n"Press any key...",\r\ntimeout)) == K_RESIZE)\r\nui_browser__handle_resize(browser);\r\nfree(text);\r\n}\r\nreturn key;\r\n}\r\nint ui_browser__help_window(struct ui_browser *browser, const char *text)\r\n{\r\nint key;\r\nwhile ((key = ui__help_window(text)) == K_RESIZE)\r\nui_browser__handle_resize(browser);\r\nreturn key;\r\n}\r\nbool ui_browser__dialog_yesno(struct ui_browser *browser, const char *text)\r\n{\r\nint key;\r\nwhile ((key = ui__dialog_yesno(text)) == K_RESIZE)\r\nui_browser__handle_resize(browser);\r\nreturn key == K_ENTER || toupper(key) == 'Y';\r\n}\r\nvoid ui_browser__reset_index(struct ui_browser *self)\r\n{\r\nself->index = self->top_idx = 0;\r\nself->seek(self, 0, SEEK_SET);\r\n}\r\nvoid __ui_browser__show_title(struct ui_browser *browser, const char *title)\r\n{\r\nSLsmg_gotorc(0, 0);\r\nui_browser__set_color(browser, NEWT_COLORSET_ROOT);\r\nslsmg_write_nstring(title, browser->width + 1);\r\n}\r\nvoid ui_browser__show_title(struct ui_browser *browser, const char *title)\r\n{\r\npthread_mutex_lock(&ui__lock);\r\n__ui_browser__show_title(browser, title);\r\npthread_mutex_unlock(&ui__lock);\r\n}\r\nint ui_browser__show(struct ui_browser *self, const char *title,\r\nconst char *helpline, ...)\r\n{\r\nint err;\r\nva_list ap;\r\nui_browser__refresh_dimensions(self);\r\npthread_mutex_lock(&ui__lock);\r\n__ui_browser__show_title(self, title);\r\nself->title = title;\r\nfree(self->helpline);\r\nself->helpline = NULL;\r\nva_start(ap, helpline);\r\nerr = vasprintf(&self->helpline, helpline, ap);\r\nva_end(ap);\r\nif (err > 0)\r\nui_helpline__push(self->helpline);\r\npthread_mutex_unlock(&ui__lock);\r\nreturn err ? 0 : -1;\r\n}\r\nvoid ui_browser__hide(struct ui_browser *browser __used)\r\n{\r\npthread_mutex_lock(&ui__lock);\r\nui_helpline__pop();\r\npthread_mutex_unlock(&ui__lock);\r\n}\r\nstatic void ui_browser__scrollbar_set(struct ui_browser *browser)\r\n{\r\nint height = browser->height, h = 0, pct = 0,\r\ncol = browser->width,\r\nrow = browser->y - 1;\r\nif (browser->nr_entries > 1) {\r\npct = ((browser->index * (browser->height - 1)) /\r\n(browser->nr_entries - 1));\r\n}\r\nSLsmg_set_char_set(1);\r\nwhile (h < height) {\r\nui_browser__gotorc(browser, row++, col);\r\nSLsmg_write_char(h == pct ? SLSMG_DIAMOND_CHAR : SLSMG_CKBRD_CHAR);\r\n++h;\r\n}\r\nSLsmg_set_char_set(0);\r\n}\r\nstatic int __ui_browser__refresh(struct ui_browser *browser)\r\n{\r\nint row;\r\nint width = browser->width;\r\nrow = browser->refresh(browser);\r\nui_browser__set_color(browser, HE_COLORSET_NORMAL);\r\nif (!browser->use_navkeypressed || browser->navkeypressed)\r\nui_browser__scrollbar_set(browser);\r\nelse\r\nwidth += 1;\r\nSLsmg_fill_region(browser->y + row, browser->x,\r\nbrowser->height - row, width, ' ');\r\nreturn 0;\r\n}\r\nint ui_browser__refresh(struct ui_browser *browser)\r\n{\r\npthread_mutex_lock(&ui__lock);\r\n__ui_browser__refresh(browser);\r\npthread_mutex_unlock(&ui__lock);\r\nreturn 0;\r\n}\r\nvoid ui_browser__update_nr_entries(struct ui_browser *browser, u32 nr_entries)\r\n{\r\noff_t offset = nr_entries - browser->nr_entries;\r\nbrowser->nr_entries = nr_entries;\r\nif (offset < 0) {\r\nif (browser->top_idx < (u64)-offset)\r\noffset = -browser->top_idx;\r\nbrowser->index += offset;\r\nbrowser->top_idx += offset;\r\n}\r\nbrowser->top = NULL;\r\nbrowser->seek(browser, browser->top_idx, SEEK_SET);\r\n}\r\nint ui_browser__run(struct ui_browser *self, int delay_secs)\r\n{\r\nint err, key;\r\nwhile (1) {\r\noff_t offset;\r\npthread_mutex_lock(&ui__lock);\r\nerr = __ui_browser__refresh(self);\r\nSLsmg_refresh();\r\npthread_mutex_unlock(&ui__lock);\r\nif (err < 0)\r\nbreak;\r\nkey = ui__getch(delay_secs);\r\nif (key == K_RESIZE) {\r\nui__refresh_dimensions(false);\r\nui_browser__refresh_dimensions(self);\r\n__ui_browser__show_title(self, self->title);\r\nui_helpline__puts(self->helpline);\r\ncontinue;\r\n}\r\nif (self->use_navkeypressed && !self->navkeypressed) {\r\nif (key == K_DOWN || key == K_UP ||\r\nkey == K_PGDN || key == K_PGUP ||\r\nkey == K_HOME || key == K_END ||\r\nkey == ' ') {\r\nself->navkeypressed = true;\r\ncontinue;\r\n} else\r\nreturn key;\r\n}\r\nswitch (key) {\r\ncase K_DOWN:\r\nif (self->index == self->nr_entries - 1)\r\nbreak;\r\n++self->index;\r\nif (self->index == self->top_idx + self->height) {\r\n++self->top_idx;\r\nself->seek(self, +1, SEEK_CUR);\r\n}\r\nbreak;\r\ncase K_UP:\r\nif (self->index == 0)\r\nbreak;\r\n--self->index;\r\nif (self->index < self->top_idx) {\r\n--self->top_idx;\r\nself->seek(self, -1, SEEK_CUR);\r\n}\r\nbreak;\r\ncase K_PGDN:\r\ncase ' ':\r\nif (self->top_idx + self->height > self->nr_entries - 1)\r\nbreak;\r\noffset = self->height;\r\nif (self->index + offset > self->nr_entries - 1)\r\noffset = self->nr_entries - 1 - self->index;\r\nself->index += offset;\r\nself->top_idx += offset;\r\nself->seek(self, +offset, SEEK_CUR);\r\nbreak;\r\ncase K_PGUP:\r\nif (self->top_idx == 0)\r\nbreak;\r\nif (self->top_idx < self->height)\r\noffset = self->top_idx;\r\nelse\r\noffset = self->height;\r\nself->index -= offset;\r\nself->top_idx -= offset;\r\nself->seek(self, -offset, SEEK_CUR);\r\nbreak;\r\ncase K_HOME:\r\nui_browser__reset_index(self);\r\nbreak;\r\ncase K_END:\r\noffset = self->height - 1;\r\nif (offset >= self->nr_entries)\r\noffset = self->nr_entries - 1;\r\nself->index = self->nr_entries - 1;\r\nself->top_idx = self->index - offset;\r\nself->seek(self, -offset, SEEK_END);\r\nbreak;\r\ndefault:\r\nreturn key;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nunsigned int ui_browser__list_head_refresh(struct ui_browser *self)\r\n{\r\nstruct list_head *pos;\r\nstruct list_head *head = self->entries;\r\nint row = 0;\r\nif (self->top == NULL || self->top == self->entries)\r\nself->top = ui_browser__list_head_filter_entries(self, head->next);\r\npos = self->top;\r\nlist_for_each_from(pos, head) {\r\nif (!self->filter || !self->filter(self, pos)) {\r\nui_browser__gotorc(self, row, 0);\r\nself->write(self, pos, row);\r\nif (++row == self->height)\r\nbreak;\r\n}\r\n}\r\nreturn row;\r\n}\r\nstatic int ui_browser__color_config(const char *var, const char *value,\r\nvoid *data __used)\r\n{\r\nchar *fg = NULL, *bg;\r\nint i;\r\nif (prefixcmp(var, "colors.") != 0)\r\nreturn 0;\r\nfor (i = 0; ui_browser__colorsets[i].name != NULL; ++i) {\r\nconst char *name = var + 7;\r\nif (strcmp(ui_browser__colorsets[i].name, name) != 0)\r\ncontinue;\r\nfg = strdup(value);\r\nif (fg == NULL)\r\nbreak;\r\nbg = strchr(fg, ',');\r\nif (bg == NULL)\r\nbreak;\r\n*bg = '\0';\r\nwhile (isspace(*++bg));\r\nui_browser__colorsets[i].bg = bg;\r\nui_browser__colorsets[i].fg = fg;\r\nreturn 0;\r\n}\r\nfree(fg);\r\nreturn -1;\r\n}\r\nvoid ui_browser__argv_seek(struct ui_browser *browser, off_t offset, int whence)\r\n{\r\nswitch (whence) {\r\ncase SEEK_SET:\r\nbrowser->top = browser->entries;\r\nbreak;\r\ncase SEEK_CUR:\r\nbrowser->top = browser->top + browser->top_idx + offset;\r\nbreak;\r\ncase SEEK_END:\r\nbrowser->top = browser->top + browser->nr_entries + offset;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nunsigned int ui_browser__argv_refresh(struct ui_browser *browser)\r\n{\r\nunsigned int row = 0, idx = browser->top_idx;\r\nchar **pos;\r\nif (browser->top == NULL)\r\nbrowser->top = browser->entries;\r\npos = (char **)browser->top;\r\nwhile (idx < browser->nr_entries) {\r\nif (!browser->filter || !browser->filter(browser, *pos)) {\r\nui_browser__gotorc(browser, row, 0);\r\nbrowser->write(browser, pos, row);\r\nif (++row == browser->height)\r\nbreak;\r\n}\r\n++idx;\r\n++pos;\r\n}\r\nreturn row;\r\n}\r\nvoid ui_browser__init(void)\r\n{\r\nint i = 0;\r\nperf_config(ui_browser__color_config, NULL);\r\nwhile (ui_browser__colorsets[i].name) {\r\nstruct ui_browser__colorset *c = &ui_browser__colorsets[i++];\r\nsltt_set_color(c->colorset, c->name, c->fg, c->bg);\r\n}\r\n}
