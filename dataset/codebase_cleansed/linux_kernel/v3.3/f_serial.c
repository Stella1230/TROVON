static inline struct f_gser *func_to_gser(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_gser, port.func);\r\n}\r\nstatic int gser_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_gser *gser = func_to_gser(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nif (gser->port.in->driver_data) {\r\nDBG(cdev, "reset generic ttyGS%d\n", gser->port_num);\r\ngserial_disconnect(&gser->port);\r\n}\r\nif (!gser->port.in->desc || !gser->port.out->desc) {\r\nDBG(cdev, "activate generic ttyGS%d\n", gser->port_num);\r\nif (config_ep_by_speed(cdev->gadget, f, gser->port.in) ||\r\nconfig_ep_by_speed(cdev->gadget, f, gser->port.out)) {\r\ngser->port.in->desc = NULL;\r\ngser->port.out->desc = NULL;\r\nreturn -EINVAL;\r\n}\r\n}\r\ngserial_connect(&gser->port, gser->port_num);\r\nreturn 0;\r\n}\r\nstatic void gser_disable(struct usb_function *f)\r\n{\r\nstruct f_gser *gser = func_to_gser(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nDBG(cdev, "generic ttyGS%d deactivated\n", gser->port_num);\r\ngserial_disconnect(&gser->port);\r\n}\r\nstatic int __init\r\ngser_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct f_gser *gser = func_to_gser(f);\r\nint status;\r\nstruct usb_ep *ep;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\ngser->data_id = status;\r\ngser_interface_desc.bInterfaceNumber = status;\r\nstatus = -ENODEV;\r\nep = usb_ep_autoconfig(cdev->gadget, &gser_fs_in_desc);\r\nif (!ep)\r\ngoto fail;\r\ngser->port.in = ep;\r\nep->driver_data = cdev;\r\nep = usb_ep_autoconfig(cdev->gadget, &gser_fs_out_desc);\r\nif (!ep)\r\ngoto fail;\r\ngser->port.out = ep;\r\nep->driver_data = cdev;\r\nf->descriptors = usb_copy_descriptors(gser_fs_function);\r\nif (gadget_is_dualspeed(c->cdev->gadget)) {\r\ngser_hs_in_desc.bEndpointAddress =\r\ngser_fs_in_desc.bEndpointAddress;\r\ngser_hs_out_desc.bEndpointAddress =\r\ngser_fs_out_desc.bEndpointAddress;\r\nf->hs_descriptors = usb_copy_descriptors(gser_hs_function);\r\n}\r\nDBG(cdev, "generic ttyGS%d: %s speed IN/%s OUT/%s\n",\r\ngser->port_num,\r\ngadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",\r\ngser->port.in->name, gser->port.out->name);\r\nreturn 0;\r\nfail:\r\nif (gser->port.out)\r\ngser->port.out->driver_data = NULL;\r\nif (gser->port.in)\r\ngser->port.in->driver_data = NULL;\r\nERROR(cdev, "%s: can't bind, err %d\n", f->name, status);\r\nreturn status;\r\n}\r\nstatic void\r\ngser_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nif (gadget_is_dualspeed(c->cdev->gadget))\r\nusb_free_descriptors(f->hs_descriptors);\r\nusb_free_descriptors(f->descriptors);\r\nkfree(func_to_gser(f));\r\n}\r\nint __init gser_bind_config(struct usb_configuration *c, u8 port_num)\r\n{\r\nstruct f_gser *gser;\r\nint status;\r\nif (gser_string_defs[0].id == 0) {\r\nstatus = usb_string_id(c->cdev);\r\nif (status < 0)\r\nreturn status;\r\ngser_string_defs[0].id = status;\r\n}\r\ngser = kzalloc(sizeof *gser, GFP_KERNEL);\r\nif (!gser)\r\nreturn -ENOMEM;\r\ngser->port_num = port_num;\r\ngser->port.func.name = "gser";\r\ngser->port.func.strings = gser_strings;\r\ngser->port.func.bind = gser_bind;\r\ngser->port.func.unbind = gser_unbind;\r\ngser->port.func.set_alt = gser_set_alt;\r\ngser->port.func.disable = gser_disable;\r\nstatus = usb_add_function(c, &gser->port.func);\r\nif (status)\r\nkfree(gser);\r\nreturn status;\r\n}
