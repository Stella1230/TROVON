static inline void __init show_version (void) {\r\nprintk ("%s version %s\n", description_string, version_string);\r\n}\r\nstatic inline void wr_plain (const amb_dev * dev, size_t addr, u32 data) {\r\nPRINTD (DBG_FLOW|DBG_REGS, "wr: %08zx <- %08x", addr, data);\r\n#ifdef AMB_MMIO\r\ndev->membase[addr / sizeof(u32)] = data;\r\n#else\r\noutl (data, dev->iobase + addr);\r\n#endif\r\n}\r\nstatic inline u32 rd_plain (const amb_dev * dev, size_t addr) {\r\n#ifdef AMB_MMIO\r\nu32 data = dev->membase[addr / sizeof(u32)];\r\n#else\r\nu32 data = inl (dev->iobase + addr);\r\n#endif\r\nPRINTD (DBG_FLOW|DBG_REGS, "rd: %08zx -> %08x", addr, data);\r\nreturn data;\r\n}\r\nstatic inline void wr_mem (const amb_dev * dev, size_t addr, u32 data) {\r\n__be32 be = cpu_to_be32 (data);\r\nPRINTD (DBG_FLOW|DBG_REGS, "wr: %08zx <- %08x b[%08x]", addr, data, be);\r\n#ifdef AMB_MMIO\r\ndev->membase[addr / sizeof(u32)] = be;\r\n#else\r\noutl (be, dev->iobase + addr);\r\n#endif\r\n}\r\nstatic inline u32 rd_mem (const amb_dev * dev, size_t addr) {\r\n#ifdef AMB_MMIO\r\n__be32 be = dev->membase[addr / sizeof(u32)];\r\n#else\r\n__be32 be = inl (dev->iobase + addr);\r\n#endif\r\nu32 data = be32_to_cpu (be);\r\nPRINTD (DBG_FLOW|DBG_REGS, "rd: %08zx -> %08x b[%08x]", addr, data, be);\r\nreturn data;\r\n}\r\nstatic inline void dump_registers (const amb_dev * dev) {\r\n#ifdef DEBUG_AMBASSADOR\r\nif (debug & DBG_REGS) {\r\nsize_t i;\r\nPRINTD (DBG_REGS, "reading PLX control: ");\r\nfor (i = 0x00; i < 0x30; i += sizeof(u32))\r\nrd_mem (dev, i);\r\nPRINTD (DBG_REGS, "reading mailboxes: ");\r\nfor (i = 0x40; i < 0x60; i += sizeof(u32))\r\nrd_mem (dev, i);\r\nPRINTD (DBG_REGS, "reading doorb irqev irqen reset:");\r\nfor (i = 0x60; i < 0x70; i += sizeof(u32))\r\nrd_mem (dev, i);\r\n}\r\n#else\r\n(void) dev;\r\n#endif\r\nreturn;\r\n}\r\nstatic inline void dump_loader_block (volatile loader_block * lb) {\r\n#ifdef DEBUG_AMBASSADOR\r\nunsigned int i;\r\nPRINTDB (DBG_LOAD, "lb @ %p; res: %d, cmd: %d, pay:",\r\nlb, be32_to_cpu (lb->result), be32_to_cpu (lb->command));\r\nfor (i = 0; i < MAX_COMMAND_DATA; ++i)\r\nPRINTDM (DBG_LOAD, " %08x", be32_to_cpu (lb->payload.data[i]));\r\nPRINTDE (DBG_LOAD, ", vld: %08x", be32_to_cpu (lb->valid));\r\n#else\r\n(void) lb;\r\n#endif\r\nreturn;\r\n}\r\nstatic inline void dump_command (command * cmd) {\r\n#ifdef DEBUG_AMBASSADOR\r\nunsigned int i;\r\nPRINTDB (DBG_CMD, "cmd @ %p, req: %08x, pars:",\r\ncmd, (cmd->request));\r\nfor (i = 0; i < 3; ++i)\r\nPRINTDM (DBG_CMD, " %08x", (cmd->args.par[i]));\r\nPRINTDE (DBG_CMD, "");\r\n#else\r\n(void) cmd;\r\n#endif\r\nreturn;\r\n}\r\nstatic inline void dump_skb (char * prefix, unsigned int vc, struct sk_buff * skb) {\r\n#ifdef DEBUG_AMBASSADOR\r\nunsigned int i;\r\nunsigned char * data = skb->data;\r\nPRINTDB (DBG_DATA, "%s(%u) ", prefix, vc);\r\nfor (i=0; i<skb->len && i < 256;i++)\r\nPRINTDM (DBG_DATA, "%02x ", data[i]);\r\nPRINTDE (DBG_DATA,"");\r\n#else\r\n(void) prefix;\r\n(void) vc;\r\n(void) skb;\r\n#endif\r\nreturn;\r\n}\r\nstatic int check_area (void * start, size_t length) {\r\nconst u32 fourmegmask = -1 << 22;\r\nconst u32 twofivesixmask = -1 << 8;\r\nconst u32 starthole = 0xE0000000;\r\nu32 startaddress = virt_to_bus (start);\r\nu32 lastaddress = startaddress+length-1;\r\nif ((startaddress ^ lastaddress) & fourmegmask ||\r\n(startaddress & twofivesixmask) == starthole) {\r\nPRINTK (KERN_ERR, "check_area failure: [%x,%x] - mail maintainer!",\r\nstartaddress, lastaddress);\r\nreturn -1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic void amb_kfree_skb (struct sk_buff * skb) {\r\nif (ATM_SKB(skb)->vcc->pop) {\r\nATM_SKB(skb)->vcc->pop (ATM_SKB(skb)->vcc, skb);\r\n} else {\r\ndev_kfree_skb_any (skb);\r\n}\r\n}\r\nstatic void tx_complete (amb_dev * dev, tx_out * tx) {\r\ntx_simple * tx_descr = bus_to_virt (tx->handle);\r\nstruct sk_buff * skb = tx_descr->skb;\r\nPRINTD (DBG_FLOW|DBG_TX, "tx_complete %p %p", dev, tx);\r\natomic_inc(&ATM_SKB(skb)->vcc->stats->tx);\r\nkfree (tx_descr);\r\namb_kfree_skb (skb);\r\ndev->stats.tx_ok++;\r\nreturn;\r\n}\r\nstatic void rx_complete (amb_dev * dev, rx_out * rx) {\r\nstruct sk_buff * skb = bus_to_virt (rx->handle);\r\nu16 vc = be16_to_cpu (rx->vc);\r\nu16 status = be16_to_cpu (rx->status);\r\nu16 rx_len = be16_to_cpu (rx->length);\r\nPRINTD (DBG_FLOW|DBG_RX, "rx_complete %p %p (len=%hu)", dev, rx, rx_len);\r\nif (!status) {\r\nstruct atm_vcc * atm_vcc = dev->rxer[vc];\r\ndev->stats.rx.ok++;\r\nif (atm_vcc) {\r\nif (rx_len <= atm_vcc->qos.rxtp.max_sdu) {\r\nif (atm_charge (atm_vcc, skb->truesize)) {\r\nATM_SKB(skb)->vcc = atm_vcc;\r\nskb_put (skb, rx_len);\r\ndump_skb ("<<<", vc, skb);\r\natomic_inc(&atm_vcc->stats->rx);\r\n__net_timestamp(skb);\r\natm_vcc->push (atm_vcc, skb);\r\nreturn;\r\n} else {\r\nPRINTD (DBG_INFO|DBG_RX, "dropped thanks to atm_charge (vc %hu, truesize %u)", vc, skb->truesize);\r\n}\r\n} else {\r\nPRINTK (KERN_INFO, "dropped over-size frame");\r\natomic_inc(&atm_vcc->stats->rx_drop);\r\n}\r\n} else {\r\nPRINTD (DBG_WARN|DBG_RX, "got frame but RX closed for channel %hu", vc);\r\n}\r\n} else {\r\ndev->stats.rx.error++;\r\nif (status & CRC_ERR)\r\ndev->stats.rx.badcrc++;\r\nif (status & LEN_ERR)\r\ndev->stats.rx.toolong++;\r\nif (status & ABORT_ERR)\r\ndev->stats.rx.aborted++;\r\nif (status & UNUSED_ERR)\r\ndev->stats.rx.unused++;\r\n}\r\ndev_kfree_skb_any (skb);\r\nreturn;\r\n}\r\nstatic int command_do (amb_dev * dev, command * cmd) {\r\namb_cq * cq = &dev->cq;\r\nvolatile amb_cq_ptrs * ptrs = &cq->ptrs;\r\ncommand * my_slot;\r\nPRINTD (DBG_FLOW|DBG_CMD, "command_do %p", dev);\r\nif (test_bit (dead, &dev->flags))\r\nreturn 0;\r\nspin_lock (&cq->lock);\r\nif (cq->pending < cq->maximum) {\r\nmy_slot = ptrs->in;\r\nPRINTD (DBG_CMD, "command in slot %p", my_slot);\r\ndump_command (cmd);\r\n*ptrs->in = *cmd;\r\ncq->pending++;\r\nptrs->in = NEXTQ (ptrs->in, ptrs->start, ptrs->limit);\r\nwr_mem (dev, offsetof(amb_mem, mb.adapter.cmd_address), virt_to_bus (ptrs->in));\r\nif (cq->pending > cq->high)\r\ncq->high = cq->pending;\r\nspin_unlock (&cq->lock);\r\nmsleep(cq->pending);\r\nwhile (ptrs->out != my_slot) {\r\nPRINTD (DBG_CMD, "wait: command slot (now at %p)", ptrs->out);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule();\r\n}\r\nwhile (ptrs->out->request != cpu_to_be32 (SRB_COMPLETE)) {\r\nPRINTD (DBG_CMD, "wait: command slot completion");\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule();\r\n}\r\nPRINTD (DBG_CMD, "command complete");\r\nspin_lock (&cq->lock);\r\ncq->pending--;\r\n*cmd = *ptrs->out;\r\nptrs->out = NEXTQ (ptrs->out, ptrs->start, ptrs->limit);\r\nspin_unlock (&cq->lock);\r\nreturn 0;\r\n} else {\r\ncq->filled++;\r\nspin_unlock (&cq->lock);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic int tx_give (amb_dev * dev, tx_in * tx) {\r\namb_txq * txq = &dev->txq;\r\nunsigned long flags;\r\nPRINTD (DBG_FLOW|DBG_TX, "tx_give %p", dev);\r\nif (test_bit (dead, &dev->flags))\r\nreturn 0;\r\nspin_lock_irqsave (&txq->lock, flags);\r\nif (txq->pending < txq->maximum) {\r\nPRINTD (DBG_TX, "TX in slot %p", txq->in.ptr);\r\n*txq->in.ptr = *tx;\r\ntxq->pending++;\r\ntxq->in.ptr = NEXTQ (txq->in.ptr, txq->in.start, txq->in.limit);\r\nwr_mem (dev, offsetof(amb_mem, mb.adapter.tx_address), virt_to_bus (txq->in.ptr));\r\nwr_mem (dev, offsetof(amb_mem, doorbell), TX_FRAME);\r\nif (txq->pending > txq->high)\r\ntxq->high = txq->pending;\r\nspin_unlock_irqrestore (&txq->lock, flags);\r\nreturn 0;\r\n} else {\r\ntxq->filled++;\r\nspin_unlock_irqrestore (&txq->lock, flags);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic int tx_take (amb_dev * dev) {\r\namb_txq * txq = &dev->txq;\r\nunsigned long flags;\r\nPRINTD (DBG_FLOW|DBG_TX, "tx_take %p", dev);\r\nspin_lock_irqsave (&txq->lock, flags);\r\nif (txq->pending && txq->out.ptr->handle) {\r\ntx_complete (dev, txq->out.ptr);\r\ntxq->out.ptr->handle = 0;\r\ntxq->pending--;\r\ntxq->out.ptr = NEXTQ (txq->out.ptr, txq->out.start, txq->out.limit);\r\nspin_unlock_irqrestore (&txq->lock, flags);\r\nreturn 0;\r\n} else {\r\nspin_unlock_irqrestore (&txq->lock, flags);\r\nreturn -1;\r\n}\r\n}\r\nstatic int rx_give (amb_dev * dev, rx_in * rx, unsigned char pool) {\r\namb_rxq * rxq = &dev->rxq[pool];\r\nunsigned long flags;\r\nPRINTD (DBG_FLOW|DBG_RX, "rx_give %p[%hu]", dev, pool);\r\nspin_lock_irqsave (&rxq->lock, flags);\r\nif (rxq->pending < rxq->maximum) {\r\nPRINTD (DBG_RX, "RX in slot %p", rxq->in.ptr);\r\n*rxq->in.ptr = *rx;\r\nrxq->pending++;\r\nrxq->in.ptr = NEXTQ (rxq->in.ptr, rxq->in.start, rxq->in.limit);\r\nwr_mem (dev, offsetof(amb_mem, mb.adapter.rx_address[pool]), virt_to_bus (rxq->in.ptr));\r\nspin_unlock_irqrestore (&rxq->lock, flags);\r\nreturn 0;\r\n} else {\r\nspin_unlock_irqrestore (&rxq->lock, flags);\r\nreturn -1;\r\n}\r\n}\r\nstatic int rx_take (amb_dev * dev, unsigned char pool) {\r\namb_rxq * rxq = &dev->rxq[pool];\r\nunsigned long flags;\r\nPRINTD (DBG_FLOW|DBG_RX, "rx_take %p[%hu]", dev, pool);\r\nspin_lock_irqsave (&rxq->lock, flags);\r\nif (rxq->pending && (rxq->out.ptr->status || rxq->out.ptr->length)) {\r\nrx_complete (dev, rxq->out.ptr);\r\nrxq->out.ptr->status = 0;\r\nrxq->out.ptr->length = 0;\r\nrxq->pending--;\r\nrxq->out.ptr = NEXTQ (rxq->out.ptr, rxq->out.start, rxq->out.limit);\r\nif (rxq->pending < rxq->low)\r\nrxq->low = rxq->pending;\r\nspin_unlock_irqrestore (&rxq->lock, flags);\r\nreturn 0;\r\n} else {\r\nif (!rxq->pending && rxq->buffers_wanted)\r\nrxq->emptied++;\r\nspin_unlock_irqrestore (&rxq->lock, flags);\r\nreturn -1;\r\n}\r\n}\r\nstatic void drain_rx_pool (amb_dev * dev, unsigned char pool) {\r\namb_rxq * rxq = &dev->rxq[pool];\r\nPRINTD (DBG_FLOW|DBG_POOL, "drain_rx_pool %p %hu", dev, pool);\r\nif (test_bit (dead, &dev->flags))\r\nreturn;\r\nif (rxq->pending > rxq->buffers_wanted) {\r\ncommand cmd;\r\ncmd.request = cpu_to_be32 (SRB_FLUSH_BUFFER_Q);\r\ncmd.args.flush.flags = cpu_to_be32 (pool << SRB_POOL_SHIFT);\r\nwhile (command_do (dev, &cmd))\r\nschedule();\r\nwhile (rxq->pending > rxq->buffers_wanted)\r\nif (rx_take (dev, pool))\r\nschedule();\r\n}\r\nreturn;\r\n}\r\nstatic void drain_rx_pools (amb_dev * dev) {\r\nunsigned char pool;\r\nPRINTD (DBG_FLOW|DBG_POOL, "drain_rx_pools %p", dev);\r\nfor (pool = 0; pool < NUM_RX_POOLS; ++pool)\r\ndrain_rx_pool (dev, pool);\r\n}\r\nstatic void fill_rx_pool (amb_dev * dev, unsigned char pool,\r\ngfp_t priority)\r\n{\r\nrx_in rx;\r\namb_rxq * rxq;\r\nPRINTD (DBG_FLOW|DBG_POOL, "fill_rx_pool %p %hu %x", dev, pool, priority);\r\nif (test_bit (dead, &dev->flags))\r\nreturn;\r\nrxq = &dev->rxq[pool];\r\nwhile (rxq->pending < rxq->maximum && rxq->pending < rxq->buffers_wanted) {\r\nstruct sk_buff * skb = alloc_skb (rxq->buffer_size, priority);\r\nif (!skb) {\r\nPRINTD (DBG_SKB|DBG_POOL, "failed to allocate skb for RX pool %hu", pool);\r\nreturn;\r\n}\r\nif (check_area (skb->data, skb->truesize)) {\r\ndev_kfree_skb_any (skb);\r\nreturn;\r\n}\r\nPRINTD (DBG_SKB, "allocated skb at %p, head %p, area %li",\r\nskb, skb->head, (long) (skb_end_pointer(skb) - skb->head));\r\nrx.handle = virt_to_bus (skb);\r\nrx.host_address = cpu_to_be32 (virt_to_bus (skb->data));\r\nif (rx_give (dev, &rx, pool))\r\ndev_kfree_skb_any (skb);\r\n}\r\nreturn;\r\n}\r\nstatic void fill_rx_pools (amb_dev * dev) {\r\nunsigned char pool;\r\nPRINTD (DBG_FLOW|DBG_POOL, "fill_rx_pools %p", dev);\r\nfor (pool = 0; pool < NUM_RX_POOLS; ++pool)\r\nfill_rx_pool (dev, pool, GFP_ATOMIC);\r\nreturn;\r\n}\r\nstatic void interrupts_on (amb_dev * dev) {\r\nwr_plain (dev, offsetof(amb_mem, interrupt_control),\r\nrd_plain (dev, offsetof(amb_mem, interrupt_control))\r\n| AMB_INTERRUPT_BITS);\r\n}\r\nstatic void interrupts_off (amb_dev * dev) {\r\nwr_plain (dev, offsetof(amb_mem, interrupt_control),\r\nrd_plain (dev, offsetof(amb_mem, interrupt_control))\r\n&~ AMB_INTERRUPT_BITS);\r\n}\r\nstatic irqreturn_t interrupt_handler(int irq, void *dev_id) {\r\namb_dev * dev = dev_id;\r\nPRINTD (DBG_IRQ|DBG_FLOW, "interrupt_handler: %p", dev_id);\r\n{\r\nu32 interrupt = rd_plain (dev, offsetof(amb_mem, interrupt));\r\nif (!interrupt) {\r\nPRINTD (DBG_IRQ, "irq not for me: %d", irq);\r\nreturn IRQ_NONE;\r\n}\r\nPRINTD (DBG_IRQ, "FYI: interrupt was %08x", interrupt);\r\nwr_plain (dev, offsetof(amb_mem, interrupt), -1);\r\n}\r\n{\r\nunsigned int irq_work = 0;\r\nunsigned char pool;\r\nfor (pool = 0; pool < NUM_RX_POOLS; ++pool)\r\nwhile (!rx_take (dev, pool))\r\n++irq_work;\r\nwhile (!tx_take (dev))\r\n++irq_work;\r\nif (irq_work) {\r\nfill_rx_pools (dev);\r\nPRINTD (DBG_IRQ, "work done: %u", irq_work);\r\n} else {\r\nPRINTD (DBG_IRQ|DBG_WARN, "no work done");\r\n}\r\n}\r\nPRINTD (DBG_IRQ|DBG_FLOW, "interrupt_handler done: %p", dev_id);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int make_rate (unsigned int rate, rounding r,\r\nu16 * bits, unsigned int * actual) {\r\nunsigned char exp = -1;\r\nunsigned int man = -1;\r\nPRINTD (DBG_FLOW|DBG_QOS, "make_rate %u", rate);\r\nif (rate > 0xffc00000U) {\r\nif (r == round_up) {\r\nreturn -EINVAL;\r\n} else {\r\nexp = 31;\r\nman = 511;\r\n}\r\n} else if (rate) {\r\nexp = 31;\r\nman = rate;\r\nwhile (!(man & (1<<31))) {\r\nexp = exp - 1;\r\nman = man<<1;\r\n}\r\nman = man<<1;\r\nman &= 0xffffffffU;\r\nswitch (r) {\r\ncase round_down: {\r\nman = man>>(32-9);\r\nbreak;\r\n}\r\ncase round_up: {\r\nif (man & (~0U>>9)) {\r\nman = (man>>(32-9)) + 1;\r\nif (man == (1<<9)) {\r\nman = 0;\r\nexp += 1;\r\n}\r\n} else {\r\nman = (man>>(32-9));\r\n}\r\nbreak;\r\n}\r\ncase round_nearest: {\r\nif (man & (1<<(32-9-1))) {\r\nman = (man>>(32-9)) + 1;\r\nif (man == (1<<9)) {\r\nman = 0;\r\nexp += 1;\r\n}\r\n} else {\r\nman = (man>>(32-9));\r\n}\r\nbreak;\r\n}\r\n}\r\n} else {\r\nif (r == round_down) {\r\nreturn -EINVAL;\r\n} else {\r\nexp = 0;\r\nman = 0;\r\n}\r\n}\r\nPRINTD (DBG_QOS, "rate: man=%u, exp=%hu", man, exp);\r\nif (bits)\r\n*bits = (exp<<9) | man;\r\nif (actual)\r\n*actual = (exp >= 9)\r\n? (1 << exp) + (man << (exp-9))\r\n: (1 << exp) + ((man + (1<<(9-exp-1))) >> (9-exp));\r\nreturn 0;\r\n}\r\nstatic int amb_open (struct atm_vcc * atm_vcc)\r\n{\r\nint error;\r\nstruct atm_qos * qos;\r\nstruct atm_trafprm * txtp;\r\nstruct atm_trafprm * rxtp;\r\nu16 tx_rate_bits = -1;\r\nu16 tx_vc_bits = -1;\r\nu16 tx_frame_bits = -1;\r\namb_dev * dev = AMB_DEV(atm_vcc->dev);\r\namb_vcc * vcc;\r\nunsigned char pool = -1;\r\nshort vpi = atm_vcc->vpi;\r\nint vci = atm_vcc->vci;\r\nPRINTD (DBG_FLOW|DBG_VCC, "amb_open %x %x", vpi, vci);\r\n#ifdef ATM_VPI_UNSPEC\r\nif (vpi == ATM_VPI_UNSPEC || vci == ATM_VCI_UNSPEC) {\r\nPRINTK (KERN_WARNING, "rejecting open with unspecified VPI/VCI (deprecated)");\r\nreturn -EINVAL;\r\n}\r\n#endif\r\nif (!(0 <= vpi && vpi < (1<<NUM_VPI_BITS) &&\r\n0 <= vci && vci < (1<<NUM_VCI_BITS))) {\r\nPRINTD (DBG_WARN|DBG_VCC, "VPI/VCI out of range: %hd/%d", vpi, vci);\r\nreturn -EINVAL;\r\n}\r\nqos = &atm_vcc->qos;\r\nif (qos->aal != ATM_AAL5) {\r\nPRINTD (DBG_QOS, "AAL not supported");\r\nreturn -EINVAL;\r\n}\r\nPRINTD (DBG_QOS, "TX:");\r\ntxtp = &qos->txtp;\r\nif (txtp->traffic_class != ATM_NONE) {\r\nswitch (txtp->traffic_class) {\r\ncase ATM_UBR: {\r\nint pcr = atm_pcr_goal (txtp);\r\nif (!pcr) {\r\ntx_rate_bits = 0;\r\ntx_vc_bits = TX_UBR;\r\ntx_frame_bits = TX_FRAME_NOTCAP;\r\n} else {\r\nrounding r;\r\nif (pcr < 0) {\r\nr = round_down;\r\npcr = -pcr;\r\n} else {\r\nr = round_up;\r\n}\r\nerror = make_rate (pcr, r, &tx_rate_bits, NULL);\r\nif (error)\r\nreturn error;\r\ntx_vc_bits = TX_UBR_CAPPED;\r\ntx_frame_bits = TX_FRAME_CAPPED;\r\n}\r\nbreak;\r\n}\r\n#if 0\r\ncase ATM_ABR: {\r\npcr = atm_pcr_goal (txtp);\r\nPRINTD (DBG_QOS, "pcr goal = %d", pcr);\r\nbreak;\r\n}\r\n#endif\r\ndefault: {\r\nPRINTD (DBG_QOS, "request for non-UBR denied");\r\nreturn -EINVAL;\r\n}\r\n}\r\nPRINTD (DBG_QOS, "tx_rate_bits=%hx, tx_vc_bits=%hx",\r\ntx_rate_bits, tx_vc_bits);\r\n}\r\nPRINTD (DBG_QOS, "RX:");\r\nrxtp = &qos->rxtp;\r\nif (rxtp->traffic_class == ATM_NONE) {\r\n} else {\r\nfor (pool = 0; pool < NUM_RX_POOLS; ++pool)\r\nif ((unsigned int) rxtp->max_sdu <= dev->rxq[pool].buffer_size) {\r\nPRINTD (DBG_VCC|DBG_QOS|DBG_POOL, "chose pool %hu (max_sdu %u <= %u)",\r\npool, rxtp->max_sdu, dev->rxq[pool].buffer_size);\r\nbreak;\r\n}\r\nif (pool == NUM_RX_POOLS) {\r\nPRINTD (DBG_WARN|DBG_VCC|DBG_QOS|DBG_POOL,\r\n"no pool suitable for VC (RX max_sdu %d is too large)",\r\nrxtp->max_sdu);\r\nreturn -EINVAL;\r\n}\r\nswitch (rxtp->traffic_class) {\r\ncase ATM_UBR: {\r\nbreak;\r\n}\r\n#if 0\r\ncase ATM_ABR: {\r\npcr = atm_pcr_goal (rxtp);\r\nPRINTD (DBG_QOS, "pcr goal = %d", pcr);\r\nbreak;\r\n}\r\n#endif\r\ndefault: {\r\nPRINTD (DBG_QOS, "request for non-UBR denied");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nvcc = kmalloc (sizeof(amb_vcc), GFP_KERNEL);\r\nif (!vcc) {\r\nPRINTK (KERN_ERR, "out of memory!");\r\nreturn -ENOMEM;\r\n}\r\natm_vcc->dev_data = (void *) vcc;\r\nset_bit(ATM_VF_ADDR,&atm_vcc->flags);\r\nif (txtp->traffic_class != ATM_NONE) {\r\ncommand cmd;\r\nvcc->tx_frame_bits = tx_frame_bits;\r\nmutex_lock(&dev->vcc_sf);\r\nif (dev->rxer[vci]) {\r\ncmd.request = cpu_to_be32 (SRB_MODIFY_VC_RATE);\r\ncmd.args.modify_rate.vc = cpu_to_be32 (vci);\r\ncmd.args.modify_rate.rate = cpu_to_be32 (tx_rate_bits << SRB_RATE_SHIFT);\r\nwhile (command_do (dev, &cmd))\r\nschedule();\r\ncmd.request = cpu_to_be32 (SRB_MODIFY_VC_FLAGS);\r\ncmd.args.modify_flags.vc = cpu_to_be32 (vci);\r\ncmd.args.modify_flags.flags = cpu_to_be32\r\n( (AMB_VCC(dev->rxer[vci])->rx_info.pool << SRB_POOL_SHIFT)\r\n| (tx_vc_bits << SRB_FLAGS_SHIFT) );\r\nwhile (command_do (dev, &cmd))\r\nschedule();\r\n} else {\r\ncmd.request = cpu_to_be32 (SRB_OPEN_VC);\r\ncmd.args.open.vc = cpu_to_be32 (vci);\r\ncmd.args.open.flags = cpu_to_be32 (tx_vc_bits << SRB_FLAGS_SHIFT);\r\ncmd.args.open.rate = cpu_to_be32 (tx_rate_bits << SRB_RATE_SHIFT);\r\nwhile (command_do (dev, &cmd))\r\nschedule();\r\n}\r\ndev->txer[vci].tx_present = 1;\r\nmutex_unlock(&dev->vcc_sf);\r\n}\r\nif (rxtp->traffic_class != ATM_NONE) {\r\ncommand cmd;\r\nvcc->rx_info.pool = pool;\r\nmutex_lock(&dev->vcc_sf);\r\nif (!dev->rxq[pool].buffers_wanted)\r\ndev->rxq[pool].buffers_wanted = rx_lats;\r\ndev->rxq[pool].buffers_wanted += 1;\r\nfill_rx_pool (dev, pool, GFP_KERNEL);\r\nif (dev->txer[vci].tx_present) {\r\ncmd.request = cpu_to_be32 (SRB_MODIFY_VC_FLAGS);\r\ncmd.args.modify_flags.vc = cpu_to_be32 (vci);\r\ncmd.args.modify_flags.flags = cpu_to_be32\r\n( (pool << SRB_POOL_SHIFT)\r\n| (dev->txer[vci].tx_vc_bits << SRB_FLAGS_SHIFT) );\r\n} else {\r\ncmd.request = cpu_to_be32 (SRB_OPEN_VC);\r\ncmd.args.open.vc = cpu_to_be32 (vci);\r\ncmd.args.open.flags = cpu_to_be32 (pool << SRB_POOL_SHIFT);\r\ncmd.args.open.rate = cpu_to_be32 (0);\r\n}\r\nwhile (command_do (dev, &cmd))\r\nschedule();\r\ndev->rxer[vci] = atm_vcc;\r\nmutex_unlock(&dev->vcc_sf);\r\n}\r\nset_bit(ATM_VF_READY,&atm_vcc->flags);\r\nreturn 0;\r\n}\r\nstatic void amb_close (struct atm_vcc * atm_vcc) {\r\namb_dev * dev = AMB_DEV (atm_vcc->dev);\r\namb_vcc * vcc = AMB_VCC (atm_vcc);\r\nu16 vci = atm_vcc->vci;\r\nPRINTD (DBG_VCC|DBG_FLOW, "amb_close");\r\nclear_bit(ATM_VF_READY,&atm_vcc->flags);\r\nif (atm_vcc->qos.txtp.traffic_class != ATM_NONE) {\r\ncommand cmd;\r\nmutex_lock(&dev->vcc_sf);\r\nif (dev->rxer[vci]) {\r\ncmd.request = cpu_to_be32 (SRB_MODIFY_VC_RATE);\r\ncmd.args.modify_rate.vc = cpu_to_be32 (vci);\r\ncmd.args.modify_rate.rate = cpu_to_be32 (0);\r\n} else {\r\ncmd.request = cpu_to_be32 (SRB_CLOSE_VC);\r\ncmd.args.close.vc = cpu_to_be32 (vci);\r\n}\r\ndev->txer[vci].tx_present = 0;\r\nwhile (command_do (dev, &cmd))\r\nschedule();\r\nmutex_unlock(&dev->vcc_sf);\r\n}\r\nif (atm_vcc->qos.rxtp.traffic_class != ATM_NONE) {\r\ncommand cmd;\r\nunsigned char pool = vcc->rx_info.pool;\r\nmutex_lock(&dev->vcc_sf);\r\nif (dev->txer[vci].tx_present) {\r\ncmd.request = cpu_to_be32 (SRB_MODIFY_VC_FLAGS);\r\ncmd.args.modify_flags.vc = cpu_to_be32 (vci);\r\ncmd.args.modify_flags.flags = cpu_to_be32\r\n(dev->txer[vci].tx_vc_bits << SRB_FLAGS_SHIFT);\r\n} else {\r\ncmd.request = cpu_to_be32 (SRB_CLOSE_VC);\r\ncmd.args.close.vc = cpu_to_be32 (vci);\r\n}\r\nif (atm_vcc != dev->rxer[vci])\r\nPRINTK (KERN_ERR, "%s vcc=%p rxer[vci]=%p",\r\n"arghhh! we're going to die!",\r\nvcc, dev->rxer[vci]);\r\ndev->rxer[vci] = NULL;\r\nwhile (command_do (dev, &cmd))\r\nschedule();\r\ndev->rxq[pool].buffers_wanted -= 1;\r\nif (dev->rxq[pool].buffers_wanted == rx_lats) {\r\ndev->rxq[pool].buffers_wanted = 0;\r\ndrain_rx_pool (dev, pool);\r\n}\r\nmutex_unlock(&dev->vcc_sf);\r\n}\r\nkfree (vcc);\r\nclear_bit(ATM_VF_ADDR,&atm_vcc->flags);\r\nreturn;\r\n}\r\nstatic int amb_send (struct atm_vcc * atm_vcc, struct sk_buff * skb) {\r\namb_dev * dev = AMB_DEV(atm_vcc->dev);\r\namb_vcc * vcc = AMB_VCC(atm_vcc);\r\nu16 vc = atm_vcc->vci;\r\nunsigned int tx_len = skb->len;\r\nunsigned char * tx_data = skb->data;\r\ntx_simple * tx_descr;\r\ntx_in tx;\r\nif (test_bit (dead, &dev->flags))\r\nreturn -EIO;\r\nPRINTD (DBG_FLOW|DBG_TX, "amb_send vc %x data %p len %u",\r\nvc, tx_data, tx_len);\r\ndump_skb (">>>", vc, skb);\r\nif (!dev->txer[vc].tx_present) {\r\nPRINTK (KERN_ERR, "attempt to send on RX-only VC %x", vc);\r\nreturn -EBADFD;\r\n}\r\nATM_SKB(skb)->vcc = atm_vcc;\r\nif (skb->len > (size_t) atm_vcc->qos.txtp.max_sdu) {\r\nPRINTK (KERN_ERR, "sk_buff length greater than agreed max_sdu, dropping...");\r\nreturn -EIO;\r\n}\r\nif (check_area (skb->data, skb->len)) {\r\natomic_inc(&atm_vcc->stats->tx_err);\r\nreturn -ENOMEM;\r\n}\r\ntx_descr = kmalloc (sizeof(tx_simple), GFP_KERNEL);\r\nif (!tx_descr) {\r\nPRINTK (KERN_ERR, "could not allocate TX descriptor");\r\nreturn -ENOMEM;\r\n}\r\nif (check_area (tx_descr, sizeof(tx_simple))) {\r\nkfree (tx_descr);\r\nreturn -ENOMEM;\r\n}\r\nPRINTD (DBG_TX, "fragment list allocated at %p", tx_descr);\r\ntx_descr->skb = skb;\r\ntx_descr->tx_frag.bytes = cpu_to_be32 (tx_len);\r\ntx_descr->tx_frag.address = cpu_to_be32 (virt_to_bus (tx_data));\r\ntx_descr->tx_frag_end.handle = virt_to_bus (tx_descr);\r\ntx_descr->tx_frag_end.vc = 0;\r\ntx_descr->tx_frag_end.next_descriptor_length = 0;\r\ntx_descr->tx_frag_end.next_descriptor = 0;\r\n#ifdef AMB_NEW_MICROCODE\r\ntx_descr->tx_frag_end.cpcs_uu = 0;\r\ntx_descr->tx_frag_end.cpi = 0;\r\ntx_descr->tx_frag_end.pad = 0;\r\n#endif\r\ntx.vc = cpu_to_be16 (vcc->tx_frame_bits | vc);\r\ntx.tx_descr_length = cpu_to_be16 (sizeof(tx_frag)+sizeof(tx_frag_end));\r\ntx.tx_descr_addr = cpu_to_be32 (virt_to_bus (&tx_descr->tx_frag));\r\nwhile (tx_give (dev, &tx))\r\nschedule();\r\nreturn 0;\r\n}\r\nstatic int amb_proc_read (struct atm_dev * atm_dev, loff_t * pos, char * page) {\r\namb_dev * dev = AMB_DEV (atm_dev);\r\nint left = *pos;\r\nunsigned char pool;\r\nPRINTD (DBG_FLOW, "amb_proc_read");\r\nif (!left--) {\r\namb_stats * s = &dev->stats;\r\nreturn sprintf (page,\r\n"frames: TX OK %lu, RX OK %lu, RX bad %lu "\r\n"(CRC %lu, long %lu, aborted %lu, unused %lu).\n",\r\ns->tx_ok, s->rx.ok, s->rx.error,\r\ns->rx.badcrc, s->rx.toolong,\r\ns->rx.aborted, s->rx.unused);\r\n}\r\nif (!left--) {\r\namb_cq * c = &dev->cq;\r\nreturn sprintf (page, "cmd queue [cur/hi/max]: %u/%u/%u. ",\r\nc->pending, c->high, c->maximum);\r\n}\r\nif (!left--) {\r\namb_txq * t = &dev->txq;\r\nreturn sprintf (page, "TX queue [cur/max high full]: %u/%u %u %u.\n",\r\nt->pending, t->maximum, t->high, t->filled);\r\n}\r\nif (!left--) {\r\nunsigned int count = sprintf (page, "RX queues [cur/max/req low empty]:");\r\nfor (pool = 0; pool < NUM_RX_POOLS; ++pool) {\r\namb_rxq * r = &dev->rxq[pool];\r\ncount += sprintf (page+count, " %u/%u/%u %u %u",\r\nr->pending, r->maximum, r->buffers_wanted, r->low, r->emptied);\r\n}\r\ncount += sprintf (page+count, ".\n");\r\nreturn count;\r\n}\r\nif (!left--) {\r\nunsigned int count = sprintf (page, "RX buffer sizes:");\r\nfor (pool = 0; pool < NUM_RX_POOLS; ++pool) {\r\namb_rxq * r = &dev->rxq[pool];\r\ncount += sprintf (page+count, " %u", r->buffer_size);\r\n}\r\ncount += sprintf (page+count, ".\n");\r\nreturn count;\r\n}\r\n#if 0\r\nif (!left--) {\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void do_housekeeping (unsigned long arg) {\r\namb_dev * dev = (amb_dev *) arg;\r\nfill_rx_pools (dev);\r\nmod_timer(&dev->housekeeping, jiffies + 10*HZ);\r\nreturn;\r\n}\r\nstatic int __devinit create_queues (amb_dev * dev, unsigned int cmds,\r\nunsigned int txs, unsigned int * rxs,\r\nunsigned int * rx_buffer_sizes) {\r\nunsigned char pool;\r\nsize_t total = 0;\r\nvoid * memory;\r\nvoid * limit;\r\nPRINTD (DBG_FLOW, "create_queues %p", dev);\r\ntotal += cmds * sizeof(command);\r\ntotal += txs * (sizeof(tx_in) + sizeof(tx_out));\r\nfor (pool = 0; pool < NUM_RX_POOLS; ++pool)\r\ntotal += rxs[pool] * (sizeof(rx_in) + sizeof(rx_out));\r\nmemory = kmalloc (total, GFP_KERNEL);\r\nif (!memory) {\r\nPRINTK (KERN_ERR, "could not allocate queues");\r\nreturn -ENOMEM;\r\n}\r\nif (check_area (memory, total)) {\r\nPRINTK (KERN_ERR, "queues allocated in nasty area");\r\nkfree (memory);\r\nreturn -ENOMEM;\r\n}\r\nlimit = memory + total;\r\nPRINTD (DBG_INIT, "queues from %p to %p", memory, limit);\r\nPRINTD (DBG_CMD, "command queue at %p", memory);\r\n{\r\ncommand * cmd = memory;\r\namb_cq * cq = &dev->cq;\r\ncq->pending = 0;\r\ncq->high = 0;\r\ncq->maximum = cmds - 1;\r\ncq->ptrs.start = cmd;\r\ncq->ptrs.in = cmd;\r\ncq->ptrs.out = cmd;\r\ncq->ptrs.limit = cmd + cmds;\r\nmemory = cq->ptrs.limit;\r\n}\r\nPRINTD (DBG_TX, "TX queue pair at %p", memory);\r\n{\r\ntx_in * in = memory;\r\ntx_out * out;\r\namb_txq * txq = &dev->txq;\r\ntxq->pending = 0;\r\ntxq->high = 0;\r\ntxq->filled = 0;\r\ntxq->maximum = txs - 1;\r\ntxq->in.start = in;\r\ntxq->in.ptr = in;\r\ntxq->in.limit = in + txs;\r\nmemory = txq->in.limit;\r\nout = memory;\r\ntxq->out.start = out;\r\ntxq->out.ptr = out;\r\ntxq->out.limit = out + txs;\r\nmemory = txq->out.limit;\r\n}\r\nPRINTD (DBG_RX, "RX queue pairs at %p", memory);\r\nfor (pool = 0; pool < NUM_RX_POOLS; ++pool) {\r\nrx_in * in = memory;\r\nrx_out * out;\r\namb_rxq * rxq = &dev->rxq[pool];\r\nrxq->buffer_size = rx_buffer_sizes[pool];\r\nrxq->buffers_wanted = 0;\r\nrxq->pending = 0;\r\nrxq->low = rxs[pool] - 1;\r\nrxq->emptied = 0;\r\nrxq->maximum = rxs[pool] - 1;\r\nrxq->in.start = in;\r\nrxq->in.ptr = in;\r\nrxq->in.limit = in + rxs[pool];\r\nmemory = rxq->in.limit;\r\nout = memory;\r\nrxq->out.start = out;\r\nrxq->out.ptr = out;\r\nrxq->out.limit = out + rxs[pool];\r\nmemory = rxq->out.limit;\r\n}\r\nif (memory == limit) {\r\nreturn 0;\r\n} else {\r\nPRINTK (KERN_ERR, "bad queue alloc %p != %p (tell maintainer)", memory, limit);\r\nkfree (limit - total);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nstatic void destroy_queues (amb_dev * dev) {\r\nvoid * memory = dev->cq.ptrs.start;\r\nPRINTD (DBG_FLOW, "destroy_queues %p", dev);\r\nPRINTD (DBG_INIT, "freeing queues at %p", memory);\r\nkfree (memory);\r\nreturn;\r\n}\r\nstatic int decode_loader_result (loader_command cmd, u32 result)\r\n{\r\nint res;\r\nconst char *msg;\r\nif (result == command_successes[cmd])\r\nreturn 0;\r\nswitch (result) {\r\ncase BAD_COMMAND:\r\nres = -EINVAL;\r\nmsg = "bad command";\r\nbreak;\r\ncase COMMAND_IN_PROGRESS:\r\nres = -ETIMEDOUT;\r\nmsg = "command in progress";\r\nbreak;\r\ncase COMMAND_PASSED_TEST:\r\nres = 0;\r\nmsg = "command passed test";\r\nbreak;\r\ncase COMMAND_FAILED_TEST:\r\nres = -EIO;\r\nmsg = "command failed test";\r\nbreak;\r\ncase COMMAND_READ_DATA_OK:\r\nres = 0;\r\nmsg = "command read data ok";\r\nbreak;\r\ncase COMMAND_READ_BAD_ADDRESS:\r\nres = -EINVAL;\r\nmsg = "command read bad address";\r\nbreak;\r\ncase COMMAND_WRITE_DATA_OK:\r\nres = 0;\r\nmsg = "command write data ok";\r\nbreak;\r\ncase COMMAND_WRITE_BAD_ADDRESS:\r\nres = -EINVAL;\r\nmsg = "command write bad address";\r\nbreak;\r\ncase COMMAND_WRITE_FLASH_FAILURE:\r\nres = -EIO;\r\nmsg = "command write flash failure";\r\nbreak;\r\ncase COMMAND_COMPLETE:\r\nres = 0;\r\nmsg = "command complete";\r\nbreak;\r\ncase COMMAND_FLASH_ERASE_FAILURE:\r\nres = -EIO;\r\nmsg = "command flash erase failure";\r\nbreak;\r\ncase COMMAND_WRITE_BAD_DATA:\r\nres = -EINVAL;\r\nmsg = "command write bad data";\r\nbreak;\r\ndefault:\r\nres = -EINVAL;\r\nmsg = "unknown error";\r\nPRINTD (DBG_LOAD|DBG_ERR,\r\n"decode_loader_result got %d=%x !",\r\nresult, result);\r\nbreak;\r\n}\r\nPRINTK (KERN_ERR, "%s", msg);\r\nreturn res;\r\n}\r\nstatic int __devinit do_loader_command (volatile loader_block * lb,\r\nconst amb_dev * dev, loader_command cmd) {\r\nunsigned long timeout;\r\nPRINTD (DBG_FLOW|DBG_LOAD, "do_loader_command");\r\nlb->result = 0;\r\nlb->command = cpu_to_be32 (cmd);\r\nlb->valid = cpu_to_be32 (DMA_VALID);\r\nwr_mem (dev, offsetof(amb_mem, doorbell), virt_to_bus (lb) & ~onegigmask);\r\ntimeout = command_timeouts[cmd] * 10;\r\nwhile (!lb->result || lb->result == cpu_to_be32 (COMMAND_IN_PROGRESS))\r\nif (timeout) {\r\ntimeout = msleep_interruptible(timeout);\r\n} else {\r\nPRINTD (DBG_LOAD|DBG_ERR, "command %d timed out", cmd);\r\ndump_registers (dev);\r\ndump_loader_block (lb);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (cmd == adapter_start) {\r\ntimeout = 100;\r\nwhile (rd_plain (dev, offsetof(amb_mem, doorbell)))\r\nif (timeout) {\r\ntimeout = msleep_interruptible(timeout);\r\n} else {\r\nPRINTD (DBG_LOAD|DBG_ERR, "start command did not clear doorbell, res=%08x",\r\nbe32_to_cpu (lb->result));\r\ndump_registers (dev);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n} else {\r\nreturn decode_loader_result (cmd, be32_to_cpu (lb->result));\r\n}\r\n}\r\nstatic int __devinit get_loader_version (loader_block * lb,\r\nconst amb_dev * dev, u32 * version) {\r\nint res;\r\nPRINTD (DBG_FLOW|DBG_LOAD, "get_loader_version");\r\nres = do_loader_command (lb, dev, get_version_number);\r\nif (res)\r\nreturn res;\r\nif (version)\r\n*version = be32_to_cpu (lb->payload.version);\r\nreturn 0;\r\n}\r\nstatic int __devinit loader_write (loader_block* lb,\r\nconst amb_dev *dev,\r\nconst struct ihex_binrec *rec) {\r\ntransfer_block * tb = &lb->payload.transfer;\r\nPRINTD (DBG_FLOW|DBG_LOAD, "loader_write");\r\ntb->address = rec->addr;\r\ntb->count = cpu_to_be32(be16_to_cpu(rec->len) / 4);\r\nmemcpy(tb->data, rec->data, be16_to_cpu(rec->len));\r\nreturn do_loader_command (lb, dev, write_adapter_memory);\r\n}\r\nstatic int __devinit loader_verify (loader_block * lb,\r\nconst amb_dev *dev,\r\nconst struct ihex_binrec *rec) {\r\ntransfer_block * tb = &lb->payload.transfer;\r\nint res;\r\nPRINTD (DBG_FLOW|DBG_LOAD, "loader_verify");\r\ntb->address = rec->addr;\r\ntb->count = cpu_to_be32(be16_to_cpu(rec->len) / 4);\r\nres = do_loader_command (lb, dev, read_adapter_memory);\r\nif (!res && memcmp(tb->data, rec->data, be16_to_cpu(rec->len)))\r\nres = -EINVAL;\r\nreturn res;\r\n}\r\nstatic int __devinit loader_start (loader_block * lb,\r\nconst amb_dev * dev, u32 address) {\r\nPRINTD (DBG_FLOW|DBG_LOAD, "loader_start");\r\nlb->payload.start = cpu_to_be32 (address);\r\nreturn do_loader_command (lb, dev, adapter_start);\r\n}\r\nstatic inline void sf (const char * msg)\r\n{\r\nPRINTK (KERN_ERR, "self-test failed: %s", msg);\r\n}\r\nstatic int amb_reset (amb_dev * dev, int diags) {\r\nu32 word;\r\nPRINTD (DBG_FLOW|DBG_LOAD, "amb_reset");\r\nword = rd_plain (dev, offsetof(amb_mem, reset_control));\r\nwr_plain (dev, offsetof(amb_mem, reset_control), word | AMB_RESET_BITS);\r\nudelay (10);\r\n#if 1\r\nwr_plain (dev, offsetof(amb_mem, interrupt_control), AMB_DOORBELL_BITS);\r\nwr_plain (dev, offsetof(amb_mem, interrupt), -1);\r\n#endif\r\nwr_plain (dev, offsetof(amb_mem, mb.loader.ready), 0);\r\nwr_plain (dev, offsetof(amb_mem, reset_control), word &~ AMB_RESET_BITS);\r\nif (diags) {\r\nunsigned long timeout;\r\nmsleep(4200);\r\ntimeout = 500;\r\nwhile (!rd_plain (dev, offsetof(amb_mem, mb.loader.ready)))\r\nif (timeout) {\r\ntimeout = msleep_interruptible(timeout);\r\n} else {\r\nPRINTD (DBG_LOAD|DBG_ERR, "reset timed out");\r\nreturn -ETIMEDOUT;\r\n}\r\nword = rd_mem (dev, offsetof(amb_mem, mb.loader.result));\r\nif (word & SELF_TEST_FAILURE) {\r\nif (word & GPINT_TST_FAILURE)\r\nsf ("interrupt");\r\nif (word & SUNI_DATA_PATTERN_FAILURE)\r\nsf ("SUNI data pattern");\r\nif (word & SUNI_DATA_BITS_FAILURE)\r\nsf ("SUNI data bits");\r\nif (word & SUNI_UTOPIA_FAILURE)\r\nsf ("SUNI UTOPIA interface");\r\nif (word & SUNI_FIFO_FAILURE)\r\nsf ("SUNI cell buffer FIFO");\r\nif (word & SRAM_FAILURE)\r\nsf ("bad SRAM");\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit ucode_init (loader_block * lb, amb_dev * dev) {\r\nconst struct firmware *fw;\r\nunsigned long start_address;\r\nconst struct ihex_binrec *rec;\r\nconst char *errmsg = 0;\r\nint res;\r\nres = request_ihex_firmware(&fw, "atmsar11.fw", &dev->pci_dev->dev);\r\nif (res) {\r\nPRINTK (KERN_ERR, "Cannot load microcode data");\r\nreturn res;\r\n}\r\nrec = (const struct ihex_binrec *)fw->data;\r\nif (be16_to_cpu(rec->len) != sizeof(__be32) || be32_to_cpu(rec->addr)) {\r\nerrmsg = "no start record";\r\ngoto fail;\r\n}\r\nstart_address = be32_to_cpup((__be32 *)rec->data);\r\nrec = ihex_next_binrec(rec);\r\nPRINTD (DBG_FLOW|DBG_LOAD, "ucode_init");\r\nwhile (rec) {\r\nPRINTD (DBG_LOAD, "starting region (%x, %u)", be32_to_cpu(rec->addr),\r\nbe16_to_cpu(rec->len));\r\nif (be16_to_cpu(rec->len) > 4 * MAX_TRANSFER_DATA) {\r\nerrmsg = "record too long";\r\ngoto fail;\r\n}\r\nif (be16_to_cpu(rec->len) & 3) {\r\nerrmsg = "odd number of bytes";\r\ngoto fail;\r\n}\r\nres = loader_write(lb, dev, rec);\r\nif (res)\r\nbreak;\r\nres = loader_verify(lb, dev, rec);\r\nif (res)\r\nbreak;\r\n}\r\nrelease_firmware(fw);\r\nif (!res)\r\nres = loader_start(lb, dev, start_address);\r\nreturn res;\r\nfail:\r\nrelease_firmware(fw);\r\nPRINTK(KERN_ERR, "Bad microcode data (%s)", errmsg);\r\nreturn -EINVAL;\r\n}\r\nstatic inline __be32 bus_addr(void * addr) {\r\nreturn cpu_to_be32 (virt_to_bus (addr));\r\n}\r\nstatic int __devinit amb_talk (amb_dev * dev) {\r\nadap_talk_block a;\r\nunsigned char pool;\r\nunsigned long timeout;\r\nPRINTD (DBG_FLOW, "amb_talk %p", dev);\r\na.command_start = bus_addr (dev->cq.ptrs.start);\r\na.command_end = bus_addr (dev->cq.ptrs.limit);\r\na.tx_start = bus_addr (dev->txq.in.start);\r\na.tx_end = bus_addr (dev->txq.in.limit);\r\na.txcom_start = bus_addr (dev->txq.out.start);\r\na.txcom_end = bus_addr (dev->txq.out.limit);\r\nfor (pool = 0; pool < NUM_RX_POOLS; ++pool) {\r\na.rec_struct[pool].buffer_start = bus_addr (dev->rxq[pool].in.start);\r\na.rec_struct[pool].buffer_end = bus_addr (dev->rxq[pool].in.limit);\r\na.rec_struct[pool].rx_start = bus_addr (dev->rxq[pool].out.start);\r\na.rec_struct[pool].rx_end = bus_addr (dev->rxq[pool].out.limit);\r\na.rec_struct[pool].buffer_size = cpu_to_be32 (dev->rxq[pool].buffer_size);\r\n}\r\n#ifdef AMB_NEW_MICROCODE\r\na.init_flags = 0;\r\n#endif\r\nwr_mem (dev, offsetof(amb_mem, doorbell), virt_to_bus (&a));\r\nmsleep(2200);\r\ntimeout = 500;\r\nwhile (rd_plain (dev, offsetof(amb_mem, doorbell)))\r\nif (timeout) {\r\ntimeout = msleep_interruptible(timeout);\r\n} else {\r\nPRINTD (DBG_INIT|DBG_ERR, "adapter init timed out");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __devinit amb_ucode_version (amb_dev * dev) {\r\nu32 major;\r\nu32 minor;\r\ncommand cmd;\r\ncmd.request = cpu_to_be32 (SRB_GET_VERSION);\r\nwhile (command_do (dev, &cmd)) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule();\r\n}\r\nmajor = be32_to_cpu (cmd.args.version.major);\r\nminor = be32_to_cpu (cmd.args.version.minor);\r\nPRINTK (KERN_INFO, "microcode version is %u.%u", major, minor);\r\n}\r\nstatic void __devinit amb_esi (amb_dev * dev, u8 * esi) {\r\nu32 lower4;\r\nu16 upper2;\r\ncommand cmd;\r\ncmd.request = cpu_to_be32 (SRB_GET_BIA);\r\nwhile (command_do (dev, &cmd)) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule();\r\n}\r\nlower4 = be32_to_cpu (cmd.args.bia.lower4);\r\nupper2 = be32_to_cpu (cmd.args.bia.upper2);\r\nPRINTD (DBG_LOAD, "BIA: lower4: %08x, upper2 %04x", lower4, upper2);\r\nif (esi) {\r\nunsigned int i;\r\nPRINTDB (DBG_INIT, "ESI:");\r\nfor (i = 0; i < ESI_LEN; ++i) {\r\nif (i < 4)\r\nesi[i] = bitrev8(lower4>>(8*i));\r\nelse\r\nesi[i] = bitrev8(upper2>>(8*(i-4)));\r\nPRINTDM (DBG_INIT, " %02x", esi[i]);\r\n}\r\nPRINTDE (DBG_INIT, "");\r\n}\r\nreturn;\r\n}\r\nstatic void fixup_plx_window (amb_dev *dev, loader_block *lb)\r\n{\r\nunsigned long blb;\r\nu32 mapreg;\r\nblb = virt_to_bus(lb);\r\nmapreg = rd_plain (dev, offsetof(amb_mem, stuff[10]));\r\nmapreg &= ~onegigmask;\r\nmapreg |= blb & onegigmask;\r\nwr_plain (dev, offsetof(amb_mem, stuff[10]), mapreg);\r\nreturn;\r\n}\r\nstatic int __devinit amb_init (amb_dev * dev)\r\n{\r\nloader_block lb;\r\nu32 version;\r\nif (amb_reset (dev, 1)) {\r\nPRINTK (KERN_ERR, "card reset failed!");\r\n} else {\r\nfixup_plx_window (dev, &lb);\r\nif (get_loader_version (&lb, dev, &version)) {\r\nPRINTK (KERN_INFO, "failed to get loader version");\r\n} else {\r\nPRINTK (KERN_INFO, "loader version is %08x", version);\r\nif (ucode_init (&lb, dev)) {\r\nPRINTK (KERN_ERR, "microcode failure");\r\n} else if (create_queues (dev, cmds, txs, rxs, rxs_bs)) {\r\nPRINTK (KERN_ERR, "failed to get memory for queues");\r\n} else {\r\nif (amb_talk (dev)) {\r\nPRINTK (KERN_ERR, "adapter did not accept queues");\r\n} else {\r\namb_ucode_version (dev);\r\nreturn 0;\r\n}\r\ndestroy_queues (dev);\r\n}\r\namb_reset (dev, 0);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void setup_dev(amb_dev *dev, struct pci_dev *pci_dev)\r\n{\r\nunsigned char pool;\r\ndev->pci_dev = pci_dev;\r\npci_set_drvdata(pci_dev, dev);\r\ndev->iobase = pci_resource_start (pci_dev, 1);\r\ndev->irq = pci_dev->irq;\r\ndev->membase = bus_to_virt(pci_resource_start(pci_dev, 0));\r\ndev->flags = 0;\r\ndev->tx_avail = ATM_OC3_PCR;\r\ndev->rx_avail = ATM_OC3_PCR;\r\nmutex_init(&dev->vcc_sf);\r\nspin_lock_init (&dev->cq.lock);\r\nspin_lock_init (&dev->txq.lock);\r\nfor (pool = 0; pool < NUM_RX_POOLS; ++pool)\r\nspin_lock_init (&dev->rxq[pool].lock);\r\n}\r\nstatic void setup_pci_dev(struct pci_dev *pci_dev)\r\n{\r\nunsigned char lat;\r\npci_set_master(pci_dev);\r\npci_read_config_byte (pci_dev, PCI_LATENCY_TIMER, &lat);\r\nif (!pci_lat)\r\npci_lat = (lat < MIN_PCI_LATENCY) ? MIN_PCI_LATENCY : lat;\r\nif (lat != pci_lat) {\r\nPRINTK (KERN_INFO, "Changing PCI latency timer from %hu to %hu",\r\nlat, pci_lat);\r\npci_write_config_byte(pci_dev, PCI_LATENCY_TIMER, pci_lat);\r\n}\r\n}\r\nstatic int __devinit amb_probe(struct pci_dev *pci_dev, const struct pci_device_id *pci_ent)\r\n{\r\namb_dev * dev;\r\nint err;\r\nunsigned int irq;\r\nerr = pci_enable_device(pci_dev);\r\nif (err < 0) {\r\nPRINTK (KERN_ERR, "skipped broken (PLX rev 2) card");\r\ngoto out;\r\n}\r\nirq = pci_dev->irq;\r\nif (pci_dev->device == PCI_DEVICE_ID_MADGE_AMBASSADOR_BAD) {\r\nPRINTK (KERN_ERR, "skipped broken (PLX rev 2) card");\r\nerr = -EINVAL;\r\ngoto out_disable;\r\n}\r\nPRINTD (DBG_INFO, "found Madge ATM adapter (amb) at"\r\n" IO %llx, IRQ %u, MEM %p",\r\n(unsigned long long)pci_resource_start(pci_dev, 1),\r\nirq, bus_to_virt(pci_resource_start(pci_dev, 0)));\r\nerr = pci_request_region(pci_dev, 1, DEV_LABEL);\r\nif (err < 0) {\r\nPRINTK (KERN_ERR, "IO range already in use!");\r\ngoto out_disable;\r\n}\r\ndev = kzalloc(sizeof(amb_dev), GFP_KERNEL);\r\nif (!dev) {\r\nPRINTK (KERN_ERR, "out of memory!");\r\nerr = -ENOMEM;\r\ngoto out_release;\r\n}\r\nsetup_dev(dev, pci_dev);\r\nerr = amb_init(dev);\r\nif (err < 0) {\r\nPRINTK (KERN_ERR, "adapter initialisation failure");\r\ngoto out_free;\r\n}\r\nsetup_pci_dev(pci_dev);\r\nerr = request_irq(irq, interrupt_handler, IRQF_SHARED, DEV_LABEL, dev);\r\nif (err < 0) {\r\nPRINTK (KERN_ERR, "request IRQ failed!");\r\ngoto out_reset;\r\n}\r\ndev->atm_dev = atm_dev_register (DEV_LABEL, &pci_dev->dev, &amb_ops, -1,\r\nNULL);\r\nif (!dev->atm_dev) {\r\nPRINTD (DBG_ERR, "failed to register Madge ATM adapter");\r\nerr = -EINVAL;\r\ngoto out_free_irq;\r\n}\r\nPRINTD (DBG_INFO, "registered Madge ATM adapter (no. %d) (%p) at %p",\r\ndev->atm_dev->number, dev, dev->atm_dev);\r\ndev->atm_dev->dev_data = (void *) dev;\r\namb_esi (dev, dev->atm_dev->esi);\r\ndev->atm_dev->ci_range.vpi_bits = NUM_VPI_BITS;\r\ndev->atm_dev->ci_range.vci_bits = NUM_VCI_BITS;\r\ninit_timer(&dev->housekeeping);\r\ndev->housekeeping.function = do_housekeeping;\r\ndev->housekeeping.data = (unsigned long) dev;\r\nmod_timer(&dev->housekeeping, jiffies);\r\ninterrupts_on (dev);\r\nout:\r\nreturn err;\r\nout_free_irq:\r\nfree_irq(irq, dev);\r\nout_reset:\r\namb_reset(dev, 0);\r\nout_free:\r\nkfree(dev);\r\nout_release:\r\npci_release_region(pci_dev, 1);\r\nout_disable:\r\npci_disable_device(pci_dev);\r\ngoto out;\r\n}\r\nstatic void __devexit amb_remove_one(struct pci_dev *pci_dev)\r\n{\r\nstruct amb_dev *dev;\r\ndev = pci_get_drvdata(pci_dev);\r\nPRINTD(DBG_INFO|DBG_INIT, "closing %p (atm_dev = %p)", dev, dev->atm_dev);\r\ndel_timer_sync(&dev->housekeeping);\r\ndrain_rx_pools(dev);\r\ninterrupts_off(dev);\r\namb_reset(dev, 0);\r\nfree_irq(dev->irq, dev);\r\npci_disable_device(pci_dev);\r\ndestroy_queues(dev);\r\natm_dev_deregister(dev->atm_dev);\r\nkfree(dev);\r\npci_release_region(pci_dev, 1);\r\n}\r\nstatic void __init amb_check_args (void) {\r\nunsigned char pool;\r\nunsigned int max_rx_size;\r\n#ifdef DEBUG_AMBASSADOR\r\nPRINTK (KERN_NOTICE, "debug bitmap is %hx", debug &= DBG_MASK);\r\n#else\r\nif (debug)\r\nPRINTK (KERN_NOTICE, "no debugging support");\r\n#endif\r\nif (cmds < MIN_QUEUE_SIZE)\r\nPRINTK (KERN_NOTICE, "cmds has been raised to %u",\r\ncmds = MIN_QUEUE_SIZE);\r\nif (txs < MIN_QUEUE_SIZE)\r\nPRINTK (KERN_NOTICE, "txs has been raised to %u",\r\ntxs = MIN_QUEUE_SIZE);\r\nfor (pool = 0; pool < NUM_RX_POOLS; ++pool)\r\nif (rxs[pool] < MIN_QUEUE_SIZE)\r\nPRINTK (KERN_NOTICE, "rxs[%hu] has been raised to %u",\r\npool, rxs[pool] = MIN_QUEUE_SIZE);\r\nmax_rx_size = 0;\r\nfor (pool = 0; pool < NUM_RX_POOLS; ++pool)\r\nif (rxs_bs[pool] <= max_rx_size)\r\nPRINTK (KERN_NOTICE, "useless pool (rxs_bs[%hu] = %u)",\r\npool, rxs_bs[pool]);\r\nelse\r\nmax_rx_size = rxs_bs[pool];\r\nif (rx_lats < MIN_RX_BUFFERS)\r\nPRINTK (KERN_NOTICE, "rx_lats has been raised to %u",\r\nrx_lats = MIN_RX_BUFFERS);\r\nreturn;\r\n}\r\nstatic int __init amb_module_init (void)\r\n{\r\nPRINTD (DBG_FLOW|DBG_INIT, "init_module");\r\nif (sizeof(amb_mem) != 4*16 + 4*12) {\r\nPRINTK (KERN_ERR, "Fix amb_mem (is %lu words).",\r\n(unsigned long) sizeof(amb_mem));\r\nreturn -ENOMEM;\r\n}\r\nshow_version();\r\namb_check_args();\r\nreturn pci_register_driver(&amb_driver);\r\n}\r\nstatic void __exit amb_module_exit (void)\r\n{\r\nPRINTD (DBG_FLOW|DBG_INIT, "cleanup_module");\r\npci_unregister_driver(&amb_driver);\r\n}
