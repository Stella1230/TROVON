static const char *get_err_from_table(const char *table[], int size, int pos)\r\n{\r\nif (unlikely(pos >= size))\r\nreturn "Reserved";\r\nif (unlikely(!table[pos]))\r\nreturn "Reserved";\r\nreturn table[pos];\r\n}\r\nstatic void i7300_process_error_global(struct mem_ctl_info *mci)\r\n{\r\nstruct i7300_pvt *pvt;\r\nu32 errnum, error_reg;\r\nunsigned long errors;\r\nconst char *specific;\r\nbool is_fatal;\r\npvt = mci->pvt_info;\r\npci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\r\nFERR_GLOBAL_HI, &error_reg);\r\nif (unlikely(error_reg)) {\r\nerrors = error_reg;\r\nerrnum = find_first_bit(&errors,\r\nARRAY_SIZE(ferr_global_hi_name));\r\nspecific = GET_ERR_FROM_TABLE(ferr_global_hi_name, errnum);\r\nis_fatal = ferr_global_hi_is_fatal(errnum);\r\npci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\r\nFERR_GLOBAL_HI, error_reg);\r\ngoto error_global;\r\n}\r\npci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\r\nFERR_GLOBAL_LO, &error_reg);\r\nif (unlikely(error_reg)) {\r\nerrors = error_reg;\r\nerrnum = find_first_bit(&errors,\r\nARRAY_SIZE(ferr_global_lo_name));\r\nspecific = GET_ERR_FROM_TABLE(ferr_global_lo_name, errnum);\r\nis_fatal = ferr_global_lo_is_fatal(errnum);\r\npci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\r\nFERR_GLOBAL_LO, error_reg);\r\ngoto error_global;\r\n}\r\nreturn;\r\nerror_global:\r\ni7300_mc_printk(mci, KERN_EMERG, "%s misc error: %s\n",\r\nis_fatal ? "Fatal" : "NOT fatal", specific);\r\n}\r\nstatic void i7300_process_fbd_error(struct mem_ctl_info *mci)\r\n{\r\nstruct i7300_pvt *pvt;\r\nu32 errnum, value, error_reg;\r\nu16 val16;\r\nunsigned branch, channel, bank, rank, cas, ras;\r\nu32 syndrome;\r\nunsigned long errors;\r\nconst char *specific;\r\nbool is_wr;\r\npvt = mci->pvt_info;\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nFERR_FAT_FBD, &error_reg);\r\nif (unlikely(error_reg & FERR_FAT_FBD_ERR_MASK)) {\r\nerrors = error_reg & FERR_FAT_FBD_ERR_MASK ;\r\nerrnum = find_first_bit(&errors,\r\nARRAY_SIZE(ferr_fat_fbd_name));\r\nspecific = GET_ERR_FROM_TABLE(ferr_fat_fbd_name, errnum);\r\nbranch = (GET_FBD_FAT_IDX(error_reg) == 2) ? 1 : 0;\r\npci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,\r\nNRECMEMA, &val16);\r\nbank = NRECMEMA_BANK(val16);\r\nrank = NRECMEMA_RANK(val16);\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nNRECMEMB, &value);\r\nis_wr = NRECMEMB_IS_WR(value);\r\ncas = NRECMEMB_CAS(value);\r\nras = NRECMEMB_RAS(value);\r\npci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nFERR_FAT_FBD, error_reg);\r\nsnprintf(pvt->tmp_prt_buffer, PAGE_SIZE,\r\n"FATAL (Branch=%d DRAM-Bank=%d %s "\r\n"RAS=%d CAS=%d Err=0x%lx (%s))",\r\nbranch, bank,\r\nis_wr ? "RDWR" : "RD",\r\nras, cas,\r\nerrors, specific);\r\nedac_mc_handle_fbd_ue(mci, rank, branch << 1,\r\n(branch << 1) + 1,\r\npvt->tmp_prt_buffer);\r\n}\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nFERR_NF_FBD, &error_reg);\r\nif (unlikely(error_reg & FERR_NF_FBD_ERR_MASK)) {\r\nerrors = error_reg & FERR_NF_FBD_ERR_MASK;\r\nerrnum = find_first_bit(&errors,\r\nARRAY_SIZE(ferr_nf_fbd_name));\r\nspecific = GET_ERR_FROM_TABLE(ferr_nf_fbd_name, errnum);\r\nbranch = (GET_FBD_FAT_IDX(error_reg) == 2) ? 1 : 0;\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nREDMEMA, &syndrome);\r\npci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,\r\nRECMEMA, &val16);\r\nbank = RECMEMA_BANK(val16);\r\nrank = RECMEMA_RANK(val16);\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nRECMEMB, &value);\r\nis_wr = RECMEMB_IS_WR(value);\r\ncas = RECMEMB_CAS(value);\r\nras = RECMEMB_RAS(value);\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nREDMEMB, &value);\r\nchannel = (branch << 1);\r\nif (IS_SECOND_CH(value))\r\nchannel++;\r\npci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nFERR_NF_FBD, error_reg);\r\nsnprintf(pvt->tmp_prt_buffer, PAGE_SIZE,\r\n"Corrected error (Branch=%d, Channel %d), "\r\n" DRAM-Bank=%d %s "\r\n"RAS=%d CAS=%d, CE Err=0x%lx, Syndrome=0x%08x(%s))",\r\nbranch, channel,\r\nbank,\r\nis_wr ? "RDWR" : "RD",\r\nras, cas,\r\nerrors, syndrome, specific);\r\nedac_mc_handle_fbd_ce(mci, rank, channel,\r\npvt->tmp_prt_buffer);\r\n}\r\nreturn;\r\n}\r\nstatic void i7300_check_error(struct mem_ctl_info *mci)\r\n{\r\ni7300_process_error_global(mci);\r\ni7300_process_fbd_error(mci);\r\n}\r\nstatic void i7300_clear_error(struct mem_ctl_info *mci)\r\n{\r\nstruct i7300_pvt *pvt = mci->pvt_info;\r\nu32 value;\r\npci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\r\nFERR_GLOBAL_HI, &value);\r\npci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\r\nFERR_GLOBAL_HI, value);\r\npci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\r\nFERR_GLOBAL_LO, &value);\r\npci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\r\nFERR_GLOBAL_LO, value);\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nFERR_FAT_FBD, &value);\r\npci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nFERR_FAT_FBD, value);\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nFERR_NF_FBD, &value);\r\npci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nFERR_NF_FBD, value);\r\n}\r\nstatic void i7300_enable_error_reporting(struct mem_ctl_info *mci)\r\n{\r\nstruct i7300_pvt *pvt = mci->pvt_info;\r\nu32 fbd_error_mask;\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nEMASK_FBD, &fbd_error_mask);\r\nfbd_error_mask &= ~(EMASK_FBD_ERR_MASK);\r\npci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nEMASK_FBD, fbd_error_mask);\r\n}\r\nstatic int decode_mtr(struct i7300_pvt *pvt,\r\nint slot, int ch, int branch,\r\nstruct i7300_dimm_info *dinfo,\r\nstruct csrow_info *p_csrow,\r\nu32 *nr_pages)\r\n{\r\nint mtr, ans, addrBits, channel;\r\nchannel = to_channel(ch, branch);\r\nmtr = pvt->mtr[slot][branch];\r\nans = MTR_DIMMS_PRESENT(mtr) ? 1 : 0;\r\ndebugf2("\tMTR%d CH%d: DIMMs are %s (mtr)\n",\r\nslot, channel,\r\nans ? "Present" : "NOT Present");\r\nif (!ans)\r\nreturn 0;\r\naddrBits = MTR_DRAM_BANKS_ADDR_BITS;\r\naddrBits += MTR_DIMM_ROWS_ADDR_BITS(mtr);\r\naddrBits += MTR_DIMM_COLS_ADDR_BITS(mtr);\r\naddrBits += MTR_DIMM_RANKS(mtr);\r\naddrBits += 6;\r\naddrBits -= 20;\r\naddrBits -= 3;\r\ndinfo->megabytes = 1 << addrBits;\r\n*nr_pages = dinfo->megabytes << 8;\r\ndebugf2("\t\tWIDTH: x%d\n", MTR_DRAM_WIDTH(mtr));\r\ndebugf2("\t\tELECTRICAL THROTTLING is %s\n",\r\nMTR_DIMMS_ETHROTTLE(mtr) ? "enabled" : "disabled");\r\ndebugf2("\t\tNUMBANK: %d bank(s)\n", MTR_DRAM_BANKS(mtr));\r\ndebugf2("\t\tNUMRANK: %s\n", MTR_DIMM_RANKS(mtr) ? "double" : "single");\r\ndebugf2("\t\tNUMROW: %s\n", numrow_toString[MTR_DIMM_ROWS(mtr)]);\r\ndebugf2("\t\tNUMCOL: %s\n", numcol_toString[MTR_DIMM_COLS(mtr)]);\r\ndebugf2("\t\tSIZE: %d MB\n", dinfo->megabytes);\r\np_csrow->grain = 8;\r\np_csrow->mtype = MEM_FB_DDR2;\r\np_csrow->csrow_idx = slot;\r\np_csrow->page_mask = 0;\r\nif (IS_SINGLE_MODE(pvt->mc_settings_a)) {\r\np_csrow->edac_mode = EDAC_SECDED;\r\ndebugf2("\t\tECC code is 8-byte-over-32-byte SECDED+ code\n");\r\n} else {\r\ndebugf2("\t\tECC code is on Lockstep mode\n");\r\nif (MTR_DRAM_WIDTH(mtr) == 8)\r\np_csrow->edac_mode = EDAC_S8ECD8ED;\r\nelse\r\np_csrow->edac_mode = EDAC_S4ECD4ED;\r\n}\r\nif (MTR_DRAM_WIDTH(mtr) == 8) {\r\ndebugf2("\t\tScrub algorithm for x8 is on %s mode\n",\r\nIS_SCRBALGO_ENHANCED(pvt->mc_settings) ?\r\n"enhanced" : "normal");\r\np_csrow->dtype = DEV_X8;\r\n} else\r\np_csrow->dtype = DEV_X4;\r\nreturn mtr;\r\n}\r\nstatic void print_dimm_size(struct i7300_pvt *pvt)\r\n{\r\n#ifdef CONFIG_EDAC_DEBUG\r\nstruct i7300_dimm_info *dinfo;\r\nchar *p;\r\nint space, n;\r\nint channel, slot;\r\nspace = PAGE_SIZE;\r\np = pvt->tmp_prt_buffer;\r\nn = snprintf(p, space, " ");\r\np += n;\r\nspace -= n;\r\nfor (channel = 0; channel < MAX_CHANNELS; channel++) {\r\nn = snprintf(p, space, "channel %d | ", channel);\r\np += n;\r\nspace -= n;\r\n}\r\ndebugf2("%s\n", pvt->tmp_prt_buffer);\r\np = pvt->tmp_prt_buffer;\r\nspace = PAGE_SIZE;\r\nn = snprintf(p, space, "-------------------------------"\r\n"------------------------------");\r\np += n;\r\nspace -= n;\r\ndebugf2("%s\n", pvt->tmp_prt_buffer);\r\np = pvt->tmp_prt_buffer;\r\nspace = PAGE_SIZE;\r\nfor (slot = 0; slot < MAX_SLOTS; slot++) {\r\nn = snprintf(p, space, "csrow/SLOT %d ", slot);\r\np += n;\r\nspace -= n;\r\nfor (channel = 0; channel < MAX_CHANNELS; channel++) {\r\ndinfo = &pvt->dimm_info[slot][channel];\r\nn = snprintf(p, space, "%4d MB | ", dinfo->megabytes);\r\np += n;\r\nspace -= n;\r\n}\r\ndebugf2("%s\n", pvt->tmp_prt_buffer);\r\np = pvt->tmp_prt_buffer;\r\nspace = PAGE_SIZE;\r\n}\r\nn = snprintf(p, space, "-------------------------------"\r\n"------------------------------");\r\np += n;\r\nspace -= n;\r\ndebugf2("%s\n", pvt->tmp_prt_buffer);\r\np = pvt->tmp_prt_buffer;\r\nspace = PAGE_SIZE;\r\n#endif\r\n}\r\nstatic int i7300_init_csrows(struct mem_ctl_info *mci)\r\n{\r\nstruct i7300_pvt *pvt;\r\nstruct i7300_dimm_info *dinfo;\r\nstruct csrow_info *p_csrow;\r\nint rc = -ENODEV;\r\nint mtr;\r\nint ch, branch, slot, channel;\r\nu32 last_page = 0, nr_pages;\r\npvt = mci->pvt_info;\r\ndebugf2("Memory Technology Registers:\n");\r\nfor (branch = 0; branch < MAX_BRANCHES; branch++) {\r\nchannel = to_channel(0, branch);\r\npci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],\r\nAMBPRESENT_0,\r\n&pvt->ambpresent[channel]);\r\ndebugf2("\t\tAMB-present CH%d = 0x%x:\n",\r\nchannel, pvt->ambpresent[channel]);\r\nchannel = to_channel(1, branch);\r\npci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],\r\nAMBPRESENT_1,\r\n&pvt->ambpresent[channel]);\r\ndebugf2("\t\tAMB-present CH%d = 0x%x:\n",\r\nchannel, pvt->ambpresent[channel]);\r\n}\r\nfor (slot = 0; slot < MAX_SLOTS; slot++) {\r\nint where = mtr_regs[slot];\r\nfor (branch = 0; branch < MAX_BRANCHES; branch++) {\r\npci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],\r\nwhere,\r\n&pvt->mtr[slot][branch]);\r\nfor (ch = 0; ch < MAX_BRANCHES; ch++) {\r\nint channel = to_channel(ch, branch);\r\ndinfo = &pvt->dimm_info[slot][channel];\r\np_csrow = &mci->csrows[slot];\r\nmtr = decode_mtr(pvt, slot, ch, branch,\r\ndinfo, p_csrow, &nr_pages);\r\nif (!MTR_DIMMS_PRESENT(mtr))\r\ncontinue;\r\np_csrow->nr_pages += nr_pages;\r\np_csrow->first_page = last_page;\r\nlast_page += nr_pages;\r\np_csrow->last_page = last_page;\r\nrc = 0;\r\n}\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic void decode_mir(int mir_no, u16 mir[MAX_MIR])\r\n{\r\nif (mir[mir_no] & 3)\r\ndebugf2("MIR%d: limit= 0x%x Branch(es) that participate:"\r\n" %s %s\n",\r\nmir_no,\r\n(mir[mir_no] >> 4) & 0xfff,\r\n(mir[mir_no] & 1) ? "B0" : "",\r\n(mir[mir_no] & 2) ? "B1" : "");\r\n}\r\nstatic int i7300_get_mc_regs(struct mem_ctl_info *mci)\r\n{\r\nstruct i7300_pvt *pvt;\r\nu32 actual_tolm;\r\nint i, rc;\r\npvt = mci->pvt_info;\r\npci_read_config_dword(pvt->pci_dev_16_0_fsb_ctlr, AMBASE,\r\n(u32 *) &pvt->ambase);\r\ndebugf2("AMBASE= 0x%lx\n", (long unsigned int)pvt->ambase);\r\npci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, TOLM, &pvt->tolm);\r\npvt->tolm >>= 12;\r\ndebugf2("TOLM (number of 256M regions) =%u (0x%x)\n", pvt->tolm,\r\npvt->tolm);\r\nactual_tolm = (u32) ((1000l * pvt->tolm) >> (30 - 28));\r\ndebugf2("Actual TOLM byte addr=%u.%03u GB (0x%x)\n",\r\nactual_tolm/1000, actual_tolm % 1000, pvt->tolm << 28);\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, MC_SETTINGS,\r\n&pvt->mc_settings);\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, MC_SETTINGS_A,\r\n&pvt->mc_settings_a);\r\nif (IS_SINGLE_MODE(pvt->mc_settings_a))\r\ndebugf0("Memory controller operating on single mode\n");\r\nelse\r\ndebugf0("Memory controller operating on %s mode\n",\r\nIS_MIRRORED(pvt->mc_settings) ? "mirrored" : "non-mirrored");\r\ndebugf0("Error detection is %s\n",\r\nIS_ECC_ENABLED(pvt->mc_settings) ? "enabled" : "disabled");\r\ndebugf0("Retry is %s\n",\r\nIS_RETRY_ENABLED(pvt->mc_settings) ? "enabled" : "disabled");\r\npci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR0,\r\n&pvt->mir[0]);\r\npci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR1,\r\n&pvt->mir[1]);\r\npci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR2,\r\n&pvt->mir[2]);\r\nfor (i = 0; i < MAX_MIR; i++)\r\ndecode_mir(i, pvt->mir);\r\nrc = i7300_init_csrows(mci);\r\nif (rc < 0)\r\nreturn rc;\r\nprint_dimm_size(pvt);\r\nreturn 0;\r\n}\r\nstatic void i7300_put_devices(struct mem_ctl_info *mci)\r\n{\r\nstruct i7300_pvt *pvt;\r\nint branch;\r\npvt = mci->pvt_info;\r\nfor (branch = 0; branch < MAX_CH_PER_BRANCH; branch++)\r\npci_dev_put(pvt->pci_dev_2x_0_fbd_branch[branch]);\r\npci_dev_put(pvt->pci_dev_16_2_fsb_err_regs);\r\npci_dev_put(pvt->pci_dev_16_1_fsb_addr_map);\r\n}\r\nstatic int __devinit i7300_get_devices(struct mem_ctl_info *mci)\r\n{\r\nstruct i7300_pvt *pvt;\r\nstruct pci_dev *pdev;\r\npvt = mci->pvt_info;\r\npdev = NULL;\r\nwhile (!pvt->pci_dev_16_1_fsb_addr_map ||\r\n!pvt->pci_dev_16_2_fsb_err_regs) {\r\npdev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_I7300_MCH_ERR, pdev);\r\nif (!pdev) {\r\ni7300_printk(KERN_ERR,\r\n"'system address,Process Bus' "\r\n"device not found:"\r\n"vendor 0x%x device 0x%x ERR funcs "\r\n"(broken BIOS?)\n",\r\nPCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_I7300_MCH_ERR);\r\ngoto error;\r\n}\r\nswitch (PCI_FUNC(pdev->devfn)) {\r\ncase 1:\r\npvt->pci_dev_16_1_fsb_addr_map = pdev;\r\nbreak;\r\ncase 2:\r\npvt->pci_dev_16_2_fsb_err_regs = pdev;\r\nbreak;\r\n}\r\n}\r\ndebugf1("System Address, processor bus- PCI Bus ID: %s %x:%x\n",\r\npci_name(pvt->pci_dev_16_0_fsb_ctlr),\r\npvt->pci_dev_16_0_fsb_ctlr->vendor,\r\npvt->pci_dev_16_0_fsb_ctlr->device);\r\ndebugf1("Branchmap, control and errors - PCI Bus ID: %s %x:%x\n",\r\npci_name(pvt->pci_dev_16_1_fsb_addr_map),\r\npvt->pci_dev_16_1_fsb_addr_map->vendor,\r\npvt->pci_dev_16_1_fsb_addr_map->device);\r\ndebugf1("FSB Error Regs - PCI Bus ID: %s %x:%x\n",\r\npci_name(pvt->pci_dev_16_2_fsb_err_regs),\r\npvt->pci_dev_16_2_fsb_err_regs->vendor,\r\npvt->pci_dev_16_2_fsb_err_regs->device);\r\npvt->pci_dev_2x_0_fbd_branch[0] = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_I7300_MCH_FB0,\r\nNULL);\r\nif (!pvt->pci_dev_2x_0_fbd_branch[0]) {\r\ni7300_printk(KERN_ERR,\r\n"MC: 'BRANCH 0' device not found:"\r\n"vendor 0x%x device 0x%x Func 0 (broken BIOS?)\n",\r\nPCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7300_MCH_FB0);\r\ngoto error;\r\n}\r\npvt->pci_dev_2x_0_fbd_branch[1] = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_I7300_MCH_FB1,\r\nNULL);\r\nif (!pvt->pci_dev_2x_0_fbd_branch[1]) {\r\ni7300_printk(KERN_ERR,\r\n"MC: 'BRANCH 1' device not found:"\r\n"vendor 0x%x device 0x%x Func 0 "\r\n"(broken BIOS?)\n",\r\nPCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_I7300_MCH_FB1);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\ni7300_put_devices(mci);\r\nreturn -ENODEV;\r\n}\r\nstatic int __devinit i7300_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct i7300_pvt *pvt;\r\nint num_channels;\r\nint num_dimms_per_channel;\r\nint num_csrows;\r\nint rc;\r\nrc = pci_enable_device(pdev);\r\nif (rc == -EIO)\r\nreturn rc;\r\ndebugf0("MC: " __FILE__ ": %s(), pdev bus %u dev=0x%x fn=0x%x\n",\r\n__func__,\r\npdev->bus->number,\r\nPCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));\r\nif (PCI_FUNC(pdev->devfn) != 0)\r\nreturn -ENODEV;\r\nnum_dimms_per_channel = MAX_SLOTS;\r\nnum_channels = MAX_CHANNELS;\r\nnum_csrows = MAX_SLOTS * MAX_CHANNELS;\r\ndebugf0("MC: %s(): Number of - Channels= %d DIMMS= %d CSROWS= %d\n",\r\n__func__, num_channels, num_dimms_per_channel, num_csrows);\r\nmci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels, 0);\r\nif (mci == NULL)\r\nreturn -ENOMEM;\r\ndebugf0("MC: " __FILE__ ": %s(): mci = %p\n", __func__, mci);\r\nmci->dev = &pdev->dev;\r\npvt = mci->pvt_info;\r\npvt->pci_dev_16_0_fsb_ctlr = pdev;\r\npvt->tmp_prt_buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!pvt->tmp_prt_buffer) {\r\nedac_mc_free(mci);\r\nreturn -ENOMEM;\r\n}\r\nif (i7300_get_devices(mci))\r\ngoto fail0;\r\nmci->mc_idx = 0;\r\nmci->mtype_cap = MEM_FLAG_FB_DDR2;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE;\r\nmci->edac_cap = EDAC_FLAG_NONE;\r\nmci->mod_name = "i7300_edac.c";\r\nmci->mod_ver = I7300_REVISION;\r\nmci->ctl_name = i7300_devs[0].ctl_name;\r\nmci->dev_name = pci_name(pdev);\r\nmci->ctl_page_to_phys = NULL;\r\nmci->edac_check = i7300_check_error;\r\nif (i7300_get_mc_regs(mci)) {\r\ndebugf0("MC: Setting mci->edac_cap to EDAC_FLAG_NONE\n"\r\n" because i7300_init_csrows() returned nonzero "\r\n"value\n");\r\nmci->edac_cap = EDAC_FLAG_NONE;\r\n} else {\r\ndebugf1("MC: Enable error reporting now\n");\r\ni7300_enable_error_reporting(mci);\r\n}\r\nif (edac_mc_add_mc(mci)) {\r\ndebugf0("MC: " __FILE__\r\n": %s(): failed edac_mc_add_mc()\n", __func__);\r\ngoto fail1;\r\n}\r\ni7300_clear_error(mci);\r\ni7300_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\r\nif (!i7300_pci) {\r\nprintk(KERN_WARNING\r\n"%s(): Unable to create PCI control\n",\r\n__func__);\r\nprintk(KERN_WARNING\r\n"%s(): PCI error report via EDAC not setup\n",\r\n__func__);\r\n}\r\nreturn 0;\r\nfail1:\r\ni7300_put_devices(mci);\r\nfail0:\r\nkfree(pvt->tmp_prt_buffer);\r\nedac_mc_free(mci);\r\nreturn -ENODEV;\r\n}\r\nstatic void __devexit i7300_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nchar *tmp;\r\ndebugf0(__FILE__ ": %s()\n", __func__);\r\nif (i7300_pci)\r\nedac_pci_release_generic_ctl(i7300_pci);\r\nmci = edac_mc_del_mc(&pdev->dev);\r\nif (!mci)\r\nreturn;\r\ntmp = ((struct i7300_pvt *)mci->pvt_info)->tmp_prt_buffer;\r\ni7300_put_devices(mci);\r\nkfree(tmp);\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init i7300_init(void)\r\n{\r\nint pci_rc;\r\ndebugf2("MC: " __FILE__ ": %s()\n", __func__);\r\nopstate_init();\r\npci_rc = pci_register_driver(&i7300_driver);\r\nreturn (pci_rc < 0) ? pci_rc : 0;\r\n}\r\nstatic void __exit i7300_exit(void)\r\n{\r\ndebugf2("MC: " __FILE__ ": %s()\n", __func__);\r\npci_unregister_driver(&i7300_driver);\r\n}
