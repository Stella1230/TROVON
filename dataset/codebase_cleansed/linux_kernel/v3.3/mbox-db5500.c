static struct mbox *get_mbox_with_id(u8 id)\r\n{\r\nu8 i;\r\nstruct list_head *pos = &mboxs;\r\nfor (i = 0; i <= id; i++)\r\npos = pos->next;\r\nreturn (struct mbox *) list_entry(pos, struct mbox, list);\r\n}\r\nint mbox_send(struct mbox *mbox, u32 mbox_msg, bool block)\r\n{\r\nint res = 0;\r\nspin_lock(&mbox->lock);\r\ndev_dbg(&(mbox->pdev->dev),\r\n"About to buffer 0x%X to mailbox 0x%X."\r\n" ri = %d, wi = %d\n",\r\nmbox_msg, (u32)mbox, mbox->read_index,\r\nmbox->write_index);\r\nwhile (((mbox->write_index + 1) % MBOX_BUF_SIZE) == mbox->read_index) {\r\nif (!block) {\r\ndev_dbg(&(mbox->pdev->dev),\r\n"Buffer full in non-blocking call! "\r\n"Returning -ENOMEM!\n");\r\nres = -ENOMEM;\r\ngoto exit;\r\n}\r\nspin_unlock(&mbox->lock);\r\ndev_dbg(&(mbox->pdev->dev),\r\n"Buffer full in blocking call! Sleeping...\n");\r\nmbox->client_blocked = 1;\r\nwait_for_completion(&mbox->buffer_available);\r\ndev_dbg(&(mbox->pdev->dev),\r\n"Blocking send was woken up! Trying again...\n");\r\nspin_lock(&mbox->lock);\r\n}\r\nmbox->buffer[mbox->write_index] = mbox_msg;\r\nmbox->write_index = (mbox->write_index + 1) % MBOX_BUF_SIZE;\r\nwritel(MBOX_ENABLE_IRQ, mbox->virtbase_peer + MBOX_FIFO_THRES_FREE);\r\nexit:\r\nspin_unlock(&mbox->lock);\r\nreturn res;\r\n}\r\nstatic ssize_t mbox_write_fifo(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nunsigned long mbox_mess;\r\nunsigned long nbr_sends;\r\nunsigned long i;\r\nchar int_buf[16];\r\nchar *token;\r\nchar *val;\r\nstruct mbox *mbox = (struct mbox *) dev->platform_data;\r\nstrncpy((char *) &int_buf, buf, sizeof(int_buf));\r\ntoken = (char *) &int_buf;\r\nval = strsep(&token, " ");\r\nif ((val == NULL) || (strict_strtoul(val, 16, &mbox_mess) != 0))\r\nmbox_mess = 0xDEADBEEF;\r\nval = strsep(&token, " ");\r\nif ((val == NULL) || (strict_strtoul(val, 10, &nbr_sends) != 0))\r\nnbr_sends = 1;\r\ndev_dbg(dev, "Will write 0x%lX %ld times using data struct at 0x%X\n",\r\nmbox_mess, nbr_sends, (u32) mbox);\r\nfor (i = 0; i < nbr_sends; i++)\r\nmbox_send(mbox, mbox_mess, true);\r\nreturn count;\r\n}\r\nstatic ssize_t mbox_read_fifo(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint mbox_value;\r\nstruct mbox *mbox = (struct mbox *) dev->platform_data;\r\nif ((readl(mbox->virtbase_local + MBOX_FIFO_STATUS) & 0x7) <= 0)\r\nreturn sprintf(buf, "Mailbox is empty\n");\r\nmbox_value = readl(mbox->virtbase_local + MBOX_FIFO_DATA);\r\nwritel(MBOX_LATCH, (mbox->virtbase_local + MBOX_FIFO_REMOVE));\r\nreturn sprintf(buf, "0x%X\n", mbox_value);\r\n}\r\nstatic int mbox_show(struct seq_file *s, void *data)\r\n{\r\nstruct list_head *pos;\r\nu8 mbox_index = 0;\r\nlist_for_each(pos, &mboxs) {\r\nstruct mbox *m =\r\n(struct mbox *) list_entry(pos, struct mbox, list);\r\nif (m == NULL) {\r\nseq_printf(s,\r\n"Unable to retrieve mailbox %d\n",\r\nmbox_index);\r\ncontinue;\r\n}\r\nspin_lock(&m->lock);\r\nif ((m->virtbase_peer == NULL) || (m->virtbase_local == NULL)) {\r\nseq_printf(s, "MAILBOX %d not setup or corrupt\n",\r\nmbox_index);\r\nspin_unlock(&m->lock);\r\ncontinue;\r\n}\r\nseq_printf(s,\r\n"===========================\n"\r\n" MAILBOX %d\n"\r\n" PEER MAILBOX DUMP\n"\r\n"---------------------------\n"\r\n"FIFO: 0x%X (%d)\n"\r\n"Free Threshold: 0x%.2X (%d)\n"\r\n"Occupied Threshold: 0x%.2X (%d)\n"\r\n"Status: 0x%.2X (%d)\n"\r\n" Free spaces (ot): %d (%d)\n"\r\n" Occup spaces (ot): %d (%d)\n"\r\n"===========================\n"\r\n" LOCAL MAILBOX DUMP\n"\r\n"---------------------------\n"\r\n"FIFO: 0x%.X (%d)\n"\r\n"Free Threshold: 0x%.2X (%d)\n"\r\n"Occupied Threshold: 0x%.2X (%d)\n"\r\n"Status: 0x%.2X (%d)\n"\r\n" Free spaces (ot): %d (%d)\n"\r\n" Occup spaces (ot): %d (%d)\n"\r\n"===========================\n"\r\n"write_index: %d\n"\r\n"read_index : %d\n"\r\n"===========================\n"\r\n"\n",\r\nmbox_index,\r\nreadl(m->virtbase_peer + MBOX_FIFO_DATA),\r\nreadl(m->virtbase_peer + MBOX_FIFO_DATA),\r\nreadl(m->virtbase_peer + MBOX_FIFO_THRES_FREE),\r\nreadl(m->virtbase_peer + MBOX_FIFO_THRES_FREE),\r\nreadl(m->virtbase_peer + MBOX_FIFO_THRES_OCCUP),\r\nreadl(m->virtbase_peer + MBOX_FIFO_THRES_OCCUP),\r\nreadl(m->virtbase_peer + MBOX_FIFO_STATUS),\r\nreadl(m->virtbase_peer + MBOX_FIFO_STATUS),\r\n(readl(m->virtbase_peer + MBOX_FIFO_STATUS) >> 4) & 0x7,\r\n(readl(m->virtbase_peer + MBOX_FIFO_STATUS) >> 7) & 0x1,\r\n(readl(m->virtbase_peer + MBOX_FIFO_STATUS) >> 0) & 0x7,\r\n(readl(m->virtbase_peer + MBOX_FIFO_STATUS) >> 3) & 0x1,\r\nreadl(m->virtbase_local + MBOX_FIFO_DATA),\r\nreadl(m->virtbase_local + MBOX_FIFO_DATA),\r\nreadl(m->virtbase_local + MBOX_FIFO_THRES_FREE),\r\nreadl(m->virtbase_local + MBOX_FIFO_THRES_FREE),\r\nreadl(m->virtbase_local + MBOX_FIFO_THRES_OCCUP),\r\nreadl(m->virtbase_local + MBOX_FIFO_THRES_OCCUP),\r\nreadl(m->virtbase_local + MBOX_FIFO_STATUS),\r\nreadl(m->virtbase_local + MBOX_FIFO_STATUS),\r\n(readl(m->virtbase_local + MBOX_FIFO_STATUS) >> 4) & 0x7,\r\n(readl(m->virtbase_local + MBOX_FIFO_STATUS) >> 7) & 0x1,\r\n(readl(m->virtbase_local + MBOX_FIFO_STATUS) >> 0) & 0x7,\r\n(readl(m->virtbase_local + MBOX_FIFO_STATUS) >> 3) & 0x1,\r\nm->write_index, m->read_index);\r\nmbox_index++;\r\nspin_unlock(&m->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mbox_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mbox_show, NULL);\r\n}\r\nstatic irqreturn_t mbox_irq(int irq, void *arg)\r\n{\r\nu32 mbox_value;\r\nint nbr_occup;\r\nint nbr_free;\r\nstruct mbox *mbox = (struct mbox *) arg;\r\nspin_lock(&mbox->lock);\r\ndev_dbg(&(mbox->pdev->dev),\r\n"mbox IRQ [%d] received. ri = %d, wi = %d\n",\r\nirq, mbox->read_index, mbox->write_index);\r\nif (mbox->read_index != mbox->write_index) {\r\nnbr_free = (readl(mbox->virtbase_local + MBOX_FIFO_STATUS)\r\n>> 4) & 0x7;\r\ndev_dbg(&(mbox->pdev->dev),\r\n"Status indicates %d empty spaces in the FIFO!\n",\r\nnbr_free);\r\nwhile ((nbr_free > 0) &&\r\n(mbox->read_index != mbox->write_index)) {\r\nwritel(mbox->buffer[mbox->read_index],\r\n(mbox->virtbase_peer + MBOX_FIFO_DATA));\r\nwritel(MBOX_LATCH,\r\n(mbox->virtbase_peer + MBOX_FIFO_ADD));\r\ndev_dbg(&(mbox->pdev->dev),\r\n"Wrote message 0x%X to addr 0x%X\n",\r\nmbox->buffer[mbox->read_index],\r\n(u32) (mbox->virtbase_peer + MBOX_FIFO_DATA));\r\nnbr_free--;\r\nmbox->read_index =\r\n(mbox->read_index + 1) % MBOX_BUF_SIZE;\r\n}\r\nif (mbox->read_index != mbox->write_index) {\r\ndev_dbg(&(mbox->pdev->dev),\r\n"Still have messages to send, but FIFO full. "\r\n"Request IRQ again!\n");\r\nwritel(MBOX_ENABLE_IRQ,\r\nmbox->virtbase_peer + MBOX_FIFO_THRES_FREE);\r\n} else {\r\ndev_dbg(&(mbox->pdev->dev),\r\n"No more messages to send. "\r\n"Do not request IRQ again!\n");\r\nwritel(MBOX_DISABLE_IRQ,\r\nmbox->virtbase_peer + MBOX_FIFO_THRES_FREE);\r\n}\r\nif (mbox->client_blocked &&\r\n(((mbox->write_index + 1) % MBOX_BUF_SIZE)\r\n!= mbox->read_index)) {\r\ndev_dbg(&(mbox->pdev->dev),\r\n"Waking up blocked client\n");\r\ncomplete(&mbox->buffer_available);\r\nmbox->client_blocked = 0;\r\n}\r\n}\r\nnbr_occup = readl(mbox->virtbase_local + MBOX_FIFO_STATUS) & 0x7;\r\nif (nbr_occup == 0)\r\ngoto exit;\r\nif (mbox->cb == NULL) {\r\ndev_dbg(&(mbox->pdev->dev), "No receive callback registered, "\r\n"leaving %d incoming messages in fifo!\n", nbr_occup);\r\ngoto exit;\r\n}\r\nmbox_value = readl(mbox->virtbase_local + MBOX_FIFO_DATA);\r\nwritel(MBOX_LATCH, (mbox->virtbase_local + MBOX_FIFO_REMOVE));\r\ndev_dbg(&(mbox->pdev->dev), "Calling callback for message 0x%X!\n",\r\nmbox_value);\r\nmbox->cb(mbox_value, mbox->client_data);\r\nexit:\r\ndev_dbg(&(mbox->pdev->dev), "Exit mbox IRQ. ri = %d, wi = %d\n",\r\nmbox->read_index, mbox->write_index);\r\nspin_unlock(&mbox->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct mbox *mbox_setup(u8 mbox_id, mbox_recv_cb_t *mbox_cb, void *priv)\r\n{\r\nstruct resource *resource;\r\nint irq;\r\nint res;\r\nstruct mbox *mbox;\r\nmbox = get_mbox_with_id(mbox_id);\r\nif (mbox == NULL) {\r\ndev_err(&(mbox->pdev->dev), "Incorrect mailbox id: %d!\n",\r\nmbox_id);\r\ngoto exit;\r\n}\r\nif (mbox->allocated) {\r\ndev_err(&(mbox->pdev->dev), "Mailbox number %d is busy!\n",\r\nmbox_id);\r\nmbox = NULL;\r\ngoto exit;\r\n}\r\nmbox->allocated = true;\r\ndev_dbg(&(mbox->pdev->dev), "Initiating mailbox number %d: 0x%X...\n",\r\nmbox_id, (u32)mbox);\r\nmbox->client_data = priv;\r\nmbox->cb = mbox_cb;\r\nresource = platform_get_resource_byname(mbox->pdev,\r\nIORESOURCE_MEM,\r\n"mbox_peer");\r\nif (resource == NULL) {\r\ndev_err(&(mbox->pdev->dev),\r\n"Unable to retrieve mbox peer resource\n");\r\nmbox = NULL;\r\ngoto exit;\r\n}\r\ndev_dbg(&(mbox->pdev->dev),\r\n"Resource name: %s start: 0x%X, end: 0x%X\n",\r\nresource->name, resource->start, resource->end);\r\nmbox->virtbase_peer = ioremap(resource->start, resource_size(resource));\r\nif (!mbox->virtbase_peer) {\r\ndev_err(&(mbox->pdev->dev), "Unable to ioremap peer mbox\n");\r\nmbox = NULL;\r\ngoto exit;\r\n}\r\ndev_dbg(&(mbox->pdev->dev),\r\n"ioremapped peer physical: (0x%X-0x%X) to virtual: 0x%X\n",\r\nresource->start, resource->end, (u32) mbox->virtbase_peer);\r\nresource = platform_get_resource_byname(mbox->pdev,\r\nIORESOURCE_MEM,\r\n"mbox_local");\r\nif (resource == NULL) {\r\ndev_err(&(mbox->pdev->dev),\r\n"Unable to retrieve mbox local resource\n");\r\nmbox = NULL;\r\ngoto exit;\r\n}\r\ndev_dbg(&(mbox->pdev->dev),\r\n"Resource name: %s start: 0x%X, end: 0x%X\n",\r\nresource->name, resource->start, resource->end);\r\nmbox->virtbase_local = ioremap(resource->start, resource_size(resource));\r\nif (!mbox->virtbase_local) {\r\ndev_err(&(mbox->pdev->dev), "Unable to ioremap local mbox\n");\r\nmbox = NULL;\r\ngoto exit;\r\n}\r\ndev_dbg(&(mbox->pdev->dev),\r\n"ioremapped local physical: (0x%X-0x%X) to virtual: 0x%X\n",\r\nresource->start, resource->end, (u32) mbox->virtbase_peer);\r\ninit_completion(&mbox->buffer_available);\r\nmbox->client_blocked = 0;\r\nirq = platform_get_irq_byname(mbox->pdev, "mbox_irq");\r\nif (irq < 0) {\r\ndev_err(&(mbox->pdev->dev),\r\n"Unable to retrieve mbox irq resource\n");\r\nmbox = NULL;\r\ngoto exit;\r\n}\r\ndev_dbg(&(mbox->pdev->dev), "Allocating irq %d...\n", irq);\r\nres = request_irq(irq, mbox_irq, 0, mbox->name, (void *) mbox);\r\nif (res < 0) {\r\ndev_err(&(mbox->pdev->dev),\r\n"Unable to allocate mbox irq %d\n", irq);\r\nmbox = NULL;\r\ngoto exit;\r\n}\r\nwritel(MBOX_DISABLE_IRQ, mbox->virtbase_peer + MBOX_FIFO_THRES_FREE);\r\nif (mbox_cb != NULL)\r\nwritel(MBOX_ENABLE_IRQ,\r\nmbox->virtbase_local + MBOX_FIFO_THRES_OCCUP);\r\nelse\r\nwritel(MBOX_DISABLE_IRQ,\r\nmbox->virtbase_local + MBOX_FIFO_THRES_OCCUP);\r\n#if defined(CONFIG_DEBUG_FS)\r\nres = device_create_file(&(mbox->pdev->dev), &dev_attr_fifo);\r\nif (res != 0)\r\ndev_warn(&(mbox->pdev->dev),\r\n"Unable to create mbox sysfs entry");\r\n(void) debugfs_create_file("mbox", S_IFREG | S_IRUGO, NULL,\r\nNULL, &mbox_operations);\r\n#endif\r\ndev_info(&(mbox->pdev->dev),\r\n"Mailbox driver with index %d initiated!\n", mbox_id);\r\nexit:\r\nreturn mbox;\r\n}\r\nint __init mbox_probe(struct platform_device *pdev)\r\n{\r\nstruct mbox local_mbox;\r\nstruct mbox *mbox;\r\nint res = 0;\r\ndev_dbg(&(pdev->dev), "Probing mailbox (pdev = 0x%X)...\n", (u32) pdev);\r\nmemset(&local_mbox, 0x0, sizeof(struct mbox));\r\nres = platform_device_add_data(pdev,\r\n(void *) &local_mbox,\r\nsizeof(struct mbox));\r\nif (res != 0) {\r\ndev_err(&(pdev->dev),\r\n"Unable to allocate driver platform data!\n");\r\ngoto exit;\r\n}\r\nmbox = (struct mbox *) pdev->dev.platform_data;\r\nmbox->pdev = pdev;\r\nmbox->write_index = 0;\r\nmbox->read_index = 0;\r\nINIT_LIST_HEAD(&(mbox->list));\r\nlist_add_tail(&(mbox->list), &mboxs);\r\nsprintf(mbox->name, "%s", MBOX_NAME);\r\nspin_lock_init(&mbox->lock);\r\ndev_info(&(pdev->dev), "Mailbox driver loaded\n");\r\nexit:\r\nreturn res;\r\n}\r\nstatic int __init mbox_init(void)\r\n{\r\nreturn platform_driver_probe(&mbox_driver, mbox_probe);\r\n}\r\nvoid __exit mbox_exit(void)\r\n{\r\nplatform_driver_unregister(&mbox_driver);\r\n}
