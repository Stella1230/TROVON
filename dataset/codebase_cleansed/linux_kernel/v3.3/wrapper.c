static void hfsplus_end_io_sync(struct bio *bio, int err)\r\n{\r\nif (err)\r\nclear_bit(BIO_UPTODATE, &bio->bi_flags);\r\ncomplete(bio->bi_private);\r\n}\r\nint hfsplus_submit_bio(struct super_block *sb, sector_t sector,\r\nvoid *buf, void **data, int rw)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(wait);\r\nstruct bio *bio;\r\nint ret = 0;\r\nunsigned int io_size;\r\nloff_t start;\r\nint offset;\r\nio_size = hfsplus_min_io_size(sb);\r\nstart = (loff_t)sector << HFSPLUS_SECTOR_SHIFT;\r\noffset = start & (io_size - 1);\r\nsector &= ~((io_size >> HFSPLUS_SECTOR_SHIFT) - 1);\r\nbio = bio_alloc(GFP_NOIO, 1);\r\nbio->bi_sector = sector;\r\nbio->bi_bdev = sb->s_bdev;\r\nbio->bi_end_io = hfsplus_end_io_sync;\r\nbio->bi_private = &wait;\r\nif (!(rw & WRITE) && data)\r\n*data = (u8 *)buf + offset;\r\nwhile (io_size > 0) {\r\nunsigned int page_offset = offset_in_page(buf);\r\nunsigned int len = min_t(unsigned int, PAGE_SIZE - page_offset,\r\nio_size);\r\nret = bio_add_page(bio, virt_to_page(buf), len, page_offset);\r\nif (ret != len) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nio_size -= len;\r\nbuf = (u8 *)buf + len;\r\n}\r\nsubmit_bio(rw, bio);\r\nwait_for_completion(&wait);\r\nif (!bio_flagged(bio, BIO_UPTODATE))\r\nret = -EIO;\r\nout:\r\nbio_put(bio);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int hfsplus_read_mdb(void *bufptr, struct hfsplus_wd *wd)\r\n{\r\nu32 extent;\r\nu16 attrib;\r\n__be16 sig;\r\nsig = *(__be16 *)(bufptr + HFSP_WRAPOFF_EMBEDSIG);\r\nif (sig != cpu_to_be16(HFSPLUS_VOLHEAD_SIG) &&\r\nsig != cpu_to_be16(HFSPLUS_VOLHEAD_SIGX))\r\nreturn 0;\r\nattrib = be16_to_cpu(*(__be16 *)(bufptr + HFSP_WRAPOFF_ATTRIB));\r\nif (!(attrib & HFSP_WRAP_ATTRIB_SLOCK) ||\r\n!(attrib & HFSP_WRAP_ATTRIB_SPARED))\r\nreturn 0;\r\nwd->ablk_size =\r\nbe32_to_cpu(*(__be32 *)(bufptr + HFSP_WRAPOFF_ABLKSIZE));\r\nif (wd->ablk_size < HFSPLUS_SECTOR_SIZE)\r\nreturn 0;\r\nif (wd->ablk_size % HFSPLUS_SECTOR_SIZE)\r\nreturn 0;\r\nwd->ablk_start =\r\nbe16_to_cpu(*(__be16 *)(bufptr + HFSP_WRAPOFF_ABLKSTART));\r\nextent = get_unaligned_be32(bufptr + HFSP_WRAPOFF_EMBEDEXT);\r\nwd->embed_start = (extent >> 16) & 0xFFFF;\r\nwd->embed_count = extent & 0xFFFF;\r\nreturn 1;\r\n}\r\nstatic int hfsplus_get_last_session(struct super_block *sb,\r\nsector_t *start, sector_t *size)\r\n{\r\nstruct cdrom_multisession ms_info;\r\nstruct cdrom_tocentry te;\r\nint res;\r\n*start = 0;\r\n*size = sb->s_bdev->bd_inode->i_size >> 9;\r\nif (HFSPLUS_SB(sb)->session >= 0) {\r\nte.cdte_track = HFSPLUS_SB(sb)->session;\r\nte.cdte_format = CDROM_LBA;\r\nres = ioctl_by_bdev(sb->s_bdev,\r\nCDROMREADTOCENTRY, (unsigned long)&te);\r\nif (!res && (te.cdte_ctrl & CDROM_DATA_TRACK) == 4) {\r\n*start = (sector_t)te.cdte_addr.lba << 2;\r\nreturn 0;\r\n}\r\nprintk(KERN_ERR "hfs: invalid session number or type of track\n");\r\nreturn -EINVAL;\r\n}\r\nms_info.addr_format = CDROM_LBA;\r\nres = ioctl_by_bdev(sb->s_bdev, CDROMMULTISESSION,\r\n(unsigned long)&ms_info);\r\nif (!res && ms_info.xa_flag)\r\n*start = (sector_t)ms_info.addr.lba << 2;\r\nreturn 0;\r\n}\r\nint hfsplus_read_wrapper(struct super_block *sb)\r\n{\r\nstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\r\nstruct hfsplus_wd wd;\r\nsector_t part_start, part_size;\r\nu32 blocksize;\r\nint error = 0;\r\nerror = -EINVAL;\r\nblocksize = sb_min_blocksize(sb, HFSPLUS_SECTOR_SIZE);\r\nif (!blocksize)\r\ngoto out;\r\nif (hfsplus_get_last_session(sb, &part_start, &part_size))\r\ngoto out;\r\nerror = -ENOMEM;\r\nsbi->s_vhdr_buf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\r\nif (!sbi->s_vhdr_buf)\r\ngoto out;\r\nsbi->s_backup_vhdr_buf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\r\nif (!sbi->s_backup_vhdr_buf)\r\ngoto out_free_vhdr;\r\nreread:\r\nerror = hfsplus_submit_bio(sb, part_start + HFSPLUS_VOLHEAD_SECTOR,\r\nsbi->s_vhdr_buf, (void **)&sbi->s_vhdr,\r\nREAD);\r\nif (error)\r\ngoto out_free_backup_vhdr;\r\nerror = -EINVAL;\r\nswitch (sbi->s_vhdr->signature) {\r\ncase cpu_to_be16(HFSPLUS_VOLHEAD_SIGX):\r\nset_bit(HFSPLUS_SB_HFSX, &sbi->flags);\r\ncase cpu_to_be16(HFSPLUS_VOLHEAD_SIG):\r\nbreak;\r\ncase cpu_to_be16(HFSP_WRAP_MAGIC):\r\nif (!hfsplus_read_mdb(sbi->s_vhdr, &wd))\r\ngoto out_free_backup_vhdr;\r\nwd.ablk_size >>= HFSPLUS_SECTOR_SHIFT;\r\npart_start += (sector_t)wd.ablk_start +\r\n(sector_t)wd.embed_start * wd.ablk_size;\r\npart_size = (sector_t)wd.embed_count * wd.ablk_size;\r\ngoto reread;\r\ndefault:\r\nif (hfs_part_find(sb, &part_start, &part_size))\r\ngoto out_free_backup_vhdr;\r\ngoto reread;\r\n}\r\nerror = hfsplus_submit_bio(sb, part_start + part_size - 2,\r\nsbi->s_backup_vhdr_buf,\r\n(void **)&sbi->s_backup_vhdr, READ);\r\nif (error)\r\ngoto out_free_backup_vhdr;\r\nerror = -EINVAL;\r\nif (sbi->s_backup_vhdr->signature != sbi->s_vhdr->signature) {\r\nprintk(KERN_WARNING\r\n"hfs: invalid secondary volume header\n");\r\ngoto out_free_backup_vhdr;\r\n}\r\nblocksize = be32_to_cpu(sbi->s_vhdr->blocksize);\r\nif (blocksize < HFSPLUS_SECTOR_SIZE || ((blocksize - 1) & blocksize))\r\ngoto out_free_backup_vhdr;\r\nsbi->alloc_blksz = blocksize;\r\nsbi->alloc_blksz_shift = 0;\r\nwhile ((blocksize >>= 1) != 0)\r\nsbi->alloc_blksz_shift++;\r\nblocksize = min(sbi->alloc_blksz, (u32)PAGE_SIZE);\r\nwhile (part_start & ((blocksize >> HFSPLUS_SECTOR_SHIFT) - 1))\r\nblocksize >>= 1;\r\nif (sb_set_blocksize(sb, blocksize) != blocksize) {\r\nprintk(KERN_ERR "hfs: unable to set blocksize to %u!\n",\r\nblocksize);\r\ngoto out_free_backup_vhdr;\r\n}\r\nsbi->blockoffset =\r\npart_start >> (sb->s_blocksize_bits - HFSPLUS_SECTOR_SHIFT);\r\nsbi->part_start = part_start;\r\nsbi->sect_count = part_size;\r\nsbi->fs_shift = sbi->alloc_blksz_shift - sb->s_blocksize_bits;\r\nreturn 0;\r\nout_free_backup_vhdr:\r\nkfree(sbi->s_backup_vhdr_buf);\r\nout_free_vhdr:\r\nkfree(sbi->s_vhdr_buf);\r\nout:\r\nreturn error;\r\n}
