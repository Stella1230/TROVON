void proc_sys_poll_notify(struct ctl_table_poll *poll)\r\n{\r\nif (!poll)\r\nreturn;\r\natomic_inc(&poll->event);\r\nwake_up_interruptible(&poll->wait);\r\n}\r\nstatic struct inode *proc_sys_make_inode(struct super_block *sb,\r\nstruct ctl_table_header *head, struct ctl_table *table)\r\n{\r\nstruct inode *inode;\r\nstruct proc_inode *ei;\r\ninode = new_inode(sb);\r\nif (!inode)\r\ngoto out;\r\ninode->i_ino = get_next_ino();\r\nsysctl_head_get(head);\r\nei = PROC_I(inode);\r\nei->sysctl = head;\r\nei->sysctl_entry = table;\r\ninode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\r\ninode->i_mode = table->mode;\r\nif (!table->child) {\r\ninode->i_mode |= S_IFREG;\r\ninode->i_op = &proc_sys_inode_operations;\r\ninode->i_fop = &proc_sys_file_operations;\r\n} else {\r\ninode->i_mode |= S_IFDIR;\r\nclear_nlink(inode);\r\ninode->i_op = &proc_sys_dir_operations;\r\ninode->i_fop = &proc_sys_dir_file_operations;\r\n}\r\nout:\r\nreturn inode;\r\n}\r\nstatic struct ctl_table *find_in_table(struct ctl_table *p, struct qstr *name)\r\n{\r\nint len;\r\nfor ( ; p->procname; p++) {\r\nif (!p->procname)\r\ncontinue;\r\nlen = strlen(p->procname);\r\nif (len != name->len)\r\ncontinue;\r\nif (memcmp(p->procname, name->name, len) != 0)\r\ncontinue;\r\nreturn p;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ctl_table_header *grab_header(struct inode *inode)\r\n{\r\nif (PROC_I(inode)->sysctl)\r\nreturn sysctl_head_grab(PROC_I(inode)->sysctl);\r\nelse\r\nreturn sysctl_head_next(NULL);\r\n}\r\nstatic struct dentry *proc_sys_lookup(struct inode *dir, struct dentry *dentry,\r\nstruct nameidata *nd)\r\n{\r\nstruct ctl_table_header *head = grab_header(dir);\r\nstruct ctl_table *table = PROC_I(dir)->sysctl_entry;\r\nstruct ctl_table_header *h = NULL;\r\nstruct qstr *name = &dentry->d_name;\r\nstruct ctl_table *p;\r\nstruct inode *inode;\r\nstruct dentry *err = ERR_PTR(-ENOENT);\r\nif (IS_ERR(head))\r\nreturn ERR_CAST(head);\r\nif (table && !table->child) {\r\nWARN_ON(1);\r\ngoto out;\r\n}\r\ntable = table ? table->child : head->ctl_table;\r\np = find_in_table(table, name);\r\nif (!p) {\r\nfor (h = sysctl_head_next(NULL); h; h = sysctl_head_next(h)) {\r\nif (h->attached_to != table)\r\ncontinue;\r\np = find_in_table(h->attached_by, name);\r\nif (p)\r\nbreak;\r\n}\r\n}\r\nif (!p)\r\ngoto out;\r\nerr = ERR_PTR(-ENOMEM);\r\ninode = proc_sys_make_inode(dir->i_sb, h ? h : head, p);\r\nif (h)\r\nsysctl_head_finish(h);\r\nif (!inode)\r\ngoto out;\r\nerr = NULL;\r\nd_set_d_op(dentry, &proc_sys_dentry_operations);\r\nd_add(dentry, inode);\r\nout:\r\nsysctl_head_finish(head);\r\nreturn err;\r\n}\r\nstatic ssize_t proc_sys_call_handler(struct file *filp, void __user *buf,\r\nsize_t count, loff_t *ppos, int write)\r\n{\r\nstruct inode *inode = filp->f_path.dentry->d_inode;\r\nstruct ctl_table_header *head = grab_header(inode);\r\nstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\r\nssize_t error;\r\nsize_t res;\r\nif (IS_ERR(head))\r\nreturn PTR_ERR(head);\r\nerror = -EPERM;\r\nif (sysctl_perm(head->root, table, write ? MAY_WRITE : MAY_READ))\r\ngoto out;\r\nerror = -EINVAL;\r\nif (!table->proc_handler)\r\ngoto out;\r\nres = count;\r\nerror = table->proc_handler(table, write, buf, &res, ppos);\r\nif (!error)\r\nerror = res;\r\nout:\r\nsysctl_head_finish(head);\r\nreturn error;\r\n}\r\nstatic ssize_t proc_sys_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn proc_sys_call_handler(filp, (void __user *)buf, count, ppos, 0);\r\n}\r\nstatic ssize_t proc_sys_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn proc_sys_call_handler(filp, (void __user *)buf, count, ppos, 1);\r\n}\r\nstatic int proc_sys_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\r\nif (table->poll)\r\nfilp->private_data = proc_sys_poll_event(table->poll);\r\nreturn 0;\r\n}\r\nstatic unsigned int proc_sys_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct inode *inode = filp->f_path.dentry->d_inode;\r\nstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\r\nunsigned long event = (unsigned long)filp->private_data;\r\nunsigned int ret = DEFAULT_POLLMASK;\r\nif (!table->proc_handler)\r\ngoto out;\r\nif (!table->poll)\r\ngoto out;\r\npoll_wait(filp, &table->poll->wait, wait);\r\nif (event != atomic_read(&table->poll->event)) {\r\nfilp->private_data = proc_sys_poll_event(table->poll);\r\nret = POLLIN | POLLRDNORM | POLLERR | POLLPRI;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int proc_sys_fill_cache(struct file *filp, void *dirent,\r\nfilldir_t filldir,\r\nstruct ctl_table_header *head,\r\nstruct ctl_table *table)\r\n{\r\nstruct dentry *child, *dir = filp->f_path.dentry;\r\nstruct inode *inode;\r\nstruct qstr qname;\r\nino_t ino = 0;\r\nunsigned type = DT_UNKNOWN;\r\nqname.name = table->procname;\r\nqname.len = strlen(table->procname);\r\nqname.hash = full_name_hash(qname.name, qname.len);\r\nchild = d_lookup(dir, &qname);\r\nif (!child) {\r\nchild = d_alloc(dir, &qname);\r\nif (child) {\r\ninode = proc_sys_make_inode(dir->d_sb, head, table);\r\nif (!inode) {\r\ndput(child);\r\nreturn -ENOMEM;\r\n} else {\r\nd_set_d_op(child, &proc_sys_dentry_operations);\r\nd_add(child, inode);\r\n}\r\n} else {\r\nreturn -ENOMEM;\r\n}\r\n}\r\ninode = child->d_inode;\r\nino = inode->i_ino;\r\ntype = inode->i_mode >> 12;\r\ndput(child);\r\nreturn !!filldir(dirent, qname.name, qname.len, filp->f_pos, ino, type);\r\n}\r\nstatic int scan(struct ctl_table_header *head, ctl_table *table,\r\nunsigned long *pos, struct file *file,\r\nvoid *dirent, filldir_t filldir)\r\n{\r\nfor (; table->procname; table++, (*pos)++) {\r\nint res;\r\nif (!table->procname)\r\ncontinue;\r\nif (*pos < file->f_pos)\r\ncontinue;\r\nres = proc_sys_fill_cache(file, dirent, filldir, head, table);\r\nif (res)\r\nreturn res;\r\nfile->f_pos = *pos + 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int proc_sys_readdir(struct file *filp, void *dirent, filldir_t filldir)\r\n{\r\nstruct dentry *dentry = filp->f_path.dentry;\r\nstruct inode *inode = dentry->d_inode;\r\nstruct ctl_table_header *head = grab_header(inode);\r\nstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\r\nstruct ctl_table_header *h = NULL;\r\nunsigned long pos;\r\nint ret = -EINVAL;\r\nif (IS_ERR(head))\r\nreturn PTR_ERR(head);\r\nif (table && !table->child) {\r\nWARN_ON(1);\r\ngoto out;\r\n}\r\ntable = table ? table->child : head->ctl_table;\r\nret = 0;\r\nif (filp->f_pos == 0) {\r\nif (filldir(dirent, ".", 1, filp->f_pos,\r\ninode->i_ino, DT_DIR) < 0)\r\ngoto out;\r\nfilp->f_pos++;\r\n}\r\nif (filp->f_pos == 1) {\r\nif (filldir(dirent, "..", 2, filp->f_pos,\r\nparent_ino(dentry), DT_DIR) < 0)\r\ngoto out;\r\nfilp->f_pos++;\r\n}\r\npos = 2;\r\nret = scan(head, table, &pos, filp, dirent, filldir);\r\nif (ret)\r\ngoto out;\r\nfor (h = sysctl_head_next(NULL); h; h = sysctl_head_next(h)) {\r\nif (h->attached_to != table)\r\ncontinue;\r\nret = scan(h, h->attached_by, &pos, filp, dirent, filldir);\r\nif (ret) {\r\nsysctl_head_finish(h);\r\nbreak;\r\n}\r\n}\r\nret = 1;\r\nout:\r\nsysctl_head_finish(head);\r\nreturn ret;\r\n}\r\nstatic int proc_sys_permission(struct inode *inode, int mask)\r\n{\r\nstruct ctl_table_header *head;\r\nstruct ctl_table *table;\r\nint error;\r\nif ((mask & MAY_EXEC) && S_ISREG(inode->i_mode))\r\nreturn -EACCES;\r\nhead = grab_header(inode);\r\nif (IS_ERR(head))\r\nreturn PTR_ERR(head);\r\ntable = PROC_I(inode)->sysctl_entry;\r\nif (!table)\r\nerror = mask & MAY_WRITE ? -EACCES : 0;\r\nelse\r\nerror = sysctl_perm(head->root, table, mask & ~MAY_NOT_BLOCK);\r\nsysctl_head_finish(head);\r\nreturn error;\r\n}\r\nstatic int proc_sys_setattr(struct dentry *dentry, struct iattr *attr)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nint error;\r\nif (attr->ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID))\r\nreturn -EPERM;\r\nerror = inode_change_ok(inode, attr);\r\nif (error)\r\nreturn error;\r\nif ((attr->ia_valid & ATTR_SIZE) &&\r\nattr->ia_size != i_size_read(inode)) {\r\nerror = vmtruncate(inode, attr->ia_size);\r\nif (error)\r\nreturn error;\r\n}\r\nsetattr_copy(inode, attr);\r\nmark_inode_dirty(inode);\r\nreturn 0;\r\n}\r\nstatic int proc_sys_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct ctl_table_header *head = grab_header(inode);\r\nstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\r\nif (IS_ERR(head))\r\nreturn PTR_ERR(head);\r\ngeneric_fillattr(inode, stat);\r\nif (table)\r\nstat->mode = (stat->mode & S_IFMT) | table->mode;\r\nsysctl_head_finish(head);\r\nreturn 0;\r\n}\r\nstatic int proc_sys_revalidate(struct dentry *dentry, struct nameidata *nd)\r\n{\r\nif (nd->flags & LOOKUP_RCU)\r\nreturn -ECHILD;\r\nreturn !PROC_I(dentry->d_inode)->sysctl->unregistering;\r\n}\r\nstatic int proc_sys_delete(const struct dentry *dentry)\r\n{\r\nreturn !!PROC_I(dentry->d_inode)->sysctl->unregistering;\r\n}\r\nstatic int proc_sys_compare(const struct dentry *parent,\r\nconst struct inode *pinode,\r\nconst struct dentry *dentry, const struct inode *inode,\r\nunsigned int len, const char *str, const struct qstr *name)\r\n{\r\nstruct ctl_table_header *head;\r\nif (!inode)\r\nreturn 1;\r\nif (name->len != len)\r\nreturn 1;\r\nif (memcmp(name->name, str, len))\r\nreturn 1;\r\nhead = rcu_dereference(PROC_I(inode)->sysctl);\r\nreturn !head || !sysctl_is_seen(head);\r\n}\r\nint __init proc_sys_init(void)\r\n{\r\nstruct proc_dir_entry *proc_sys_root;\r\nproc_sys_root = proc_mkdir("sys", NULL);\r\nproc_sys_root->proc_iops = &proc_sys_dir_operations;\r\nproc_sys_root->proc_fops = &proc_sys_dir_file_operations;\r\nproc_sys_root->nlink = 0;\r\nreturn 0;\r\n}
