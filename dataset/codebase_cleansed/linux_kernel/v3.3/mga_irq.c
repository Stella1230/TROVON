u32 mga_get_vblank_counter(struct drm_device *dev, int crtc)\r\n{\r\nconst drm_mga_private_t *const dev_priv =\r\n(drm_mga_private_t *) dev->dev_private;\r\nif (crtc != 0)\r\nreturn 0;\r\nreturn atomic_read(&dev_priv->vbl_received);\r\n}\r\nirqreturn_t mga_driver_irq_handler(DRM_IRQ_ARGS)\r\n{\r\nstruct drm_device *dev = (struct drm_device *) arg;\r\ndrm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;\r\nint status;\r\nint handled = 0;\r\nstatus = MGA_READ(MGA_STATUS);\r\nif (status & MGA_VLINEPEN) {\r\nMGA_WRITE(MGA_ICLEAR, MGA_VLINEICLR);\r\natomic_inc(&dev_priv->vbl_received);\r\ndrm_handle_vblank(dev, 0);\r\nhandled = 1;\r\n}\r\nif (status & MGA_SOFTRAPEN) {\r\nconst u32 prim_start = MGA_READ(MGA_PRIMADDRESS);\r\nconst u32 prim_end = MGA_READ(MGA_PRIMEND);\r\nMGA_WRITE(MGA_ICLEAR, MGA_SOFTRAPICLR);\r\nif ((prim_start & ~0x03) != (prim_end & ~0x03))\r\nMGA_WRITE(MGA_PRIMEND, prim_end);\r\natomic_inc(&dev_priv->last_fence_retired);\r\nDRM_WAKEUP(&dev_priv->fence_queue);\r\nhandled = 1;\r\n}\r\nif (handled)\r\nreturn IRQ_HANDLED;\r\nreturn IRQ_NONE;\r\n}\r\nint mga_enable_vblank(struct drm_device *dev, int crtc)\r\n{\r\ndrm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;\r\nif (crtc != 0) {\r\nDRM_ERROR("tried to enable vblank on non-existent crtc %d\n",\r\ncrtc);\r\nreturn 0;\r\n}\r\nMGA_WRITE(MGA_IEN, MGA_VLINEIEN | MGA_SOFTRAPEN);\r\nreturn 0;\r\n}\r\nvoid mga_disable_vblank(struct drm_device *dev, int crtc)\r\n{\r\nif (crtc != 0) {\r\nDRM_ERROR("tried to disable vblank on non-existent crtc %d\n",\r\ncrtc);\r\n}\r\n}\r\nint mga_driver_fence_wait(struct drm_device *dev, unsigned int *sequence)\r\n{\r\ndrm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;\r\nunsigned int cur_fence;\r\nint ret = 0;\r\nDRM_WAIT_ON(ret, dev_priv->fence_queue, 3 * DRM_HZ,\r\n(((cur_fence = atomic_read(&dev_priv->last_fence_retired))\r\n- *sequence) <= (1 << 23)));\r\n*sequence = cur_fence;\r\nreturn ret;\r\n}\r\nvoid mga_driver_irq_preinstall(struct drm_device *dev)\r\n{\r\ndrm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;\r\nMGA_WRITE(MGA_IEN, 0);\r\nMGA_WRITE(MGA_ICLEAR, ~0);\r\n}\r\nint mga_driver_irq_postinstall(struct drm_device *dev)\r\n{\r\ndrm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;\r\nDRM_INIT_WAITQUEUE(&dev_priv->fence_queue);\r\nMGA_WRITE(MGA_IEN, MGA_SOFTRAPEN);\r\nreturn 0;\r\n}\r\nvoid mga_driver_irq_uninstall(struct drm_device *dev)\r\n{\r\ndrm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;\r\nif (!dev_priv)\r\nreturn;\r\nMGA_WRITE(MGA_IEN, 0);\r\ndev->irq_enabled = 0;\r\n}
