static inline unsigned long\r\nnilfs_cpfile_checkpoints_per_block(const struct inode *cpfile)\r\n{\r\nreturn NILFS_MDT(cpfile)->mi_entries_per_block;\r\n}\r\nstatic unsigned long\r\nnilfs_cpfile_get_blkoff(const struct inode *cpfile, __u64 cno)\r\n{\r\n__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\r\ndo_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\r\nreturn (unsigned long)tcno;\r\n}\r\nstatic unsigned long\r\nnilfs_cpfile_get_offset(const struct inode *cpfile, __u64 cno)\r\n{\r\n__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\r\nreturn do_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\r\n}\r\nstatic unsigned long\r\nnilfs_cpfile_checkpoints_in_block(const struct inode *cpfile,\r\n__u64 curr,\r\n__u64 max)\r\n{\r\nreturn min_t(__u64,\r\nnilfs_cpfile_checkpoints_per_block(cpfile) -\r\nnilfs_cpfile_get_offset(cpfile, curr),\r\nmax - curr);\r\n}\r\nstatic inline int nilfs_cpfile_is_in_first(const struct inode *cpfile,\r\n__u64 cno)\r\n{\r\nreturn nilfs_cpfile_get_blkoff(cpfile, cno) == 0;\r\n}\r\nstatic unsigned int\r\nnilfs_cpfile_block_add_valid_checkpoints(const struct inode *cpfile,\r\nstruct buffer_head *bh,\r\nvoid *kaddr,\r\nunsigned int n)\r\n{\r\nstruct nilfs_checkpoint *cp = kaddr + bh_offset(bh);\r\nunsigned int count;\r\ncount = le32_to_cpu(cp->cp_checkpoints_count) + n;\r\ncp->cp_checkpoints_count = cpu_to_le32(count);\r\nreturn count;\r\n}\r\nstatic unsigned int\r\nnilfs_cpfile_block_sub_valid_checkpoints(const struct inode *cpfile,\r\nstruct buffer_head *bh,\r\nvoid *kaddr,\r\nunsigned int n)\r\n{\r\nstruct nilfs_checkpoint *cp = kaddr + bh_offset(bh);\r\nunsigned int count;\r\nWARN_ON(le32_to_cpu(cp->cp_checkpoints_count) < n);\r\ncount = le32_to_cpu(cp->cp_checkpoints_count) - n;\r\ncp->cp_checkpoints_count = cpu_to_le32(count);\r\nreturn count;\r\n}\r\nstatic inline struct nilfs_cpfile_header *\r\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\r\nstruct buffer_head *bh,\r\nvoid *kaddr)\r\n{\r\nreturn kaddr + bh_offset(bh);\r\n}\r\nstatic struct nilfs_checkpoint *\r\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\r\nstruct buffer_head *bh,\r\nvoid *kaddr)\r\n{\r\nreturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\r\nNILFS_MDT(cpfile)->mi_entry_size;\r\n}\r\nstatic void nilfs_cpfile_block_init(struct inode *cpfile,\r\nstruct buffer_head *bh,\r\nvoid *kaddr)\r\n{\r\nstruct nilfs_checkpoint *cp = kaddr + bh_offset(bh);\r\nsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\r\nint n = nilfs_cpfile_checkpoints_per_block(cpfile);\r\nwhile (n-- > 0) {\r\nnilfs_checkpoint_set_invalid(cp);\r\ncp = (void *)cp + cpsz;\r\n}\r\n}\r\nstatic inline int nilfs_cpfile_get_header_block(struct inode *cpfile,\r\nstruct buffer_head **bhp)\r\n{\r\nreturn nilfs_mdt_get_block(cpfile, 0, 0, NULL, bhp);\r\n}\r\nstatic inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\r\n__u64 cno,\r\nint create,\r\nstruct buffer_head **bhp)\r\n{\r\nreturn nilfs_mdt_get_block(cpfile,\r\nnilfs_cpfile_get_blkoff(cpfile, cno),\r\ncreate, nilfs_cpfile_block_init, bhp);\r\n}\r\nstatic inline int nilfs_cpfile_delete_checkpoint_block(struct inode *cpfile,\r\n__u64 cno)\r\n{\r\nreturn nilfs_mdt_delete_block(cpfile,\r\nnilfs_cpfile_get_blkoff(cpfile, cno));\r\n}\r\nint nilfs_cpfile_get_checkpoint(struct inode *cpfile,\r\n__u64 cno,\r\nint create,\r\nstruct nilfs_checkpoint **cpp,\r\nstruct buffer_head **bhp)\r\n{\r\nstruct buffer_head *header_bh, *cp_bh;\r\nstruct nilfs_cpfile_header *header;\r\nstruct nilfs_checkpoint *cp;\r\nvoid *kaddr;\r\nint ret;\r\nif (unlikely(cno < 1 || cno > nilfs_mdt_cno(cpfile) ||\r\n(cno < nilfs_mdt_cno(cpfile) && create)))\r\nreturn -EINVAL;\r\ndown_write(&NILFS_MDT(cpfile)->mi_sem);\r\nret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\r\nif (ret < 0)\r\ngoto out_sem;\r\nret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, create, &cp_bh);\r\nif (ret < 0)\r\ngoto out_header;\r\nkaddr = kmap(cp_bh->b_page);\r\ncp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\r\nif (nilfs_checkpoint_invalid(cp)) {\r\nif (!create) {\r\nkunmap(cp_bh->b_page);\r\nbrelse(cp_bh);\r\nret = -ENOENT;\r\ngoto out_header;\r\n}\r\nnilfs_checkpoint_clear_invalid(cp);\r\nif (!nilfs_cpfile_is_in_first(cpfile, cno))\r\nnilfs_cpfile_block_add_valid_checkpoints(cpfile, cp_bh,\r\nkaddr, 1);\r\nmark_buffer_dirty(cp_bh);\r\nkaddr = kmap_atomic(header_bh->b_page, KM_USER0);\r\nheader = nilfs_cpfile_block_get_header(cpfile, header_bh,\r\nkaddr);\r\nle64_add_cpu(&header->ch_ncheckpoints, 1);\r\nkunmap_atomic(kaddr, KM_USER0);\r\nmark_buffer_dirty(header_bh);\r\nnilfs_mdt_mark_dirty(cpfile);\r\n}\r\nif (cpp != NULL)\r\n*cpp = cp;\r\n*bhp = cp_bh;\r\nout_header:\r\nbrelse(header_bh);\r\nout_sem:\r\nup_write(&NILFS_MDT(cpfile)->mi_sem);\r\nreturn ret;\r\n}\r\nvoid nilfs_cpfile_put_checkpoint(struct inode *cpfile, __u64 cno,\r\nstruct buffer_head *bh)\r\n{\r\nkunmap(bh->b_page);\r\nbrelse(bh);\r\n}\r\nint nilfs_cpfile_delete_checkpoints(struct inode *cpfile,\r\n__u64 start,\r\n__u64 end)\r\n{\r\nstruct buffer_head *header_bh, *cp_bh;\r\nstruct nilfs_cpfile_header *header;\r\nstruct nilfs_checkpoint *cp;\r\nsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\r\n__u64 cno;\r\nvoid *kaddr;\r\nunsigned long tnicps;\r\nint ret, ncps, nicps, count, i;\r\nif (unlikely(start == 0 || start > end)) {\r\nprintk(KERN_ERR "%s: invalid range of checkpoint numbers: "\r\n"[%llu, %llu)\n", __func__,\r\n(unsigned long long)start, (unsigned long long)end);\r\nreturn -EINVAL;\r\n}\r\ndown_write(&NILFS_MDT(cpfile)->mi_sem);\r\nret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\r\nif (ret < 0)\r\ngoto out_sem;\r\ntnicps = 0;\r\nfor (cno = start; cno < end; cno += ncps) {\r\nncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, end);\r\nret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\r\nif (ret < 0) {\r\nif (ret != -ENOENT)\r\nbreak;\r\nret = 0;\r\ncontinue;\r\n}\r\nkaddr = kmap_atomic(cp_bh->b_page, KM_USER0);\r\ncp = nilfs_cpfile_block_get_checkpoint(\r\ncpfile, cno, cp_bh, kaddr);\r\nnicps = 0;\r\nfor (i = 0; i < ncps; i++, cp = (void *)cp + cpsz) {\r\nWARN_ON(nilfs_checkpoint_snapshot(cp));\r\nif (!nilfs_checkpoint_invalid(cp)) {\r\nnilfs_checkpoint_set_invalid(cp);\r\nnicps++;\r\n}\r\n}\r\nif (nicps > 0) {\r\ntnicps += nicps;\r\nmark_buffer_dirty(cp_bh);\r\nnilfs_mdt_mark_dirty(cpfile);\r\nif (!nilfs_cpfile_is_in_first(cpfile, cno)) {\r\ncount =\r\nnilfs_cpfile_block_sub_valid_checkpoints(\r\ncpfile, cp_bh, kaddr, nicps);\r\nif (count == 0) {\r\nkunmap_atomic(kaddr, KM_USER0);\r\nbrelse(cp_bh);\r\nret =\r\nnilfs_cpfile_delete_checkpoint_block(\r\ncpfile, cno);\r\nif (ret == 0)\r\ncontinue;\r\nprintk(KERN_ERR\r\n"%s: cannot delete block\n",\r\n__func__);\r\nbreak;\r\n}\r\n}\r\n}\r\nkunmap_atomic(kaddr, KM_USER0);\r\nbrelse(cp_bh);\r\n}\r\nif (tnicps > 0) {\r\nkaddr = kmap_atomic(header_bh->b_page, KM_USER0);\r\nheader = nilfs_cpfile_block_get_header(cpfile, header_bh,\r\nkaddr);\r\nle64_add_cpu(&header->ch_ncheckpoints, -(u64)tnicps);\r\nmark_buffer_dirty(header_bh);\r\nnilfs_mdt_mark_dirty(cpfile);\r\nkunmap_atomic(kaddr, KM_USER0);\r\n}\r\nbrelse(header_bh);\r\nout_sem:\r\nup_write(&NILFS_MDT(cpfile)->mi_sem);\r\nreturn ret;\r\n}\r\nstatic void nilfs_cpfile_checkpoint_to_cpinfo(struct inode *cpfile,\r\nstruct nilfs_checkpoint *cp,\r\nstruct nilfs_cpinfo *ci)\r\n{\r\nci->ci_flags = le32_to_cpu(cp->cp_flags);\r\nci->ci_cno = le64_to_cpu(cp->cp_cno);\r\nci->ci_create = le64_to_cpu(cp->cp_create);\r\nci->ci_nblk_inc = le64_to_cpu(cp->cp_nblk_inc);\r\nci->ci_inodes_count = le64_to_cpu(cp->cp_inodes_count);\r\nci->ci_blocks_count = le64_to_cpu(cp->cp_blocks_count);\r\nci->ci_next = le64_to_cpu(cp->cp_snapshot_list.ssl_next);\r\n}\r\nstatic ssize_t nilfs_cpfile_do_get_cpinfo(struct inode *cpfile, __u64 *cnop,\r\nvoid *buf, unsigned cisz, size_t nci)\r\n{\r\nstruct nilfs_checkpoint *cp;\r\nstruct nilfs_cpinfo *ci = buf;\r\nstruct buffer_head *bh;\r\nsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\r\n__u64 cur_cno = nilfs_mdt_cno(cpfile), cno = *cnop;\r\nvoid *kaddr;\r\nint n, ret;\r\nint ncps, i;\r\nif (cno == 0)\r\nreturn -ENOENT;\r\ndown_read(&NILFS_MDT(cpfile)->mi_sem);\r\nfor (n = 0; cno < cur_cno && n < nci; cno += ncps) {\r\nncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, cur_cno);\r\nret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &bh);\r\nif (ret < 0) {\r\nif (ret != -ENOENT)\r\ngoto out;\r\ncontinue;\r\n}\r\nkaddr = kmap_atomic(bh->b_page, KM_USER0);\r\ncp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\r\nfor (i = 0; i < ncps && n < nci; i++, cp = (void *)cp + cpsz) {\r\nif (!nilfs_checkpoint_invalid(cp)) {\r\nnilfs_cpfile_checkpoint_to_cpinfo(cpfile, cp,\r\nci);\r\nci = (void *)ci + cisz;\r\nn++;\r\n}\r\n}\r\nkunmap_atomic(kaddr, KM_USER0);\r\nbrelse(bh);\r\n}\r\nret = n;\r\nif (n > 0) {\r\nci = (void *)ci - cisz;\r\n*cnop = ci->ci_cno + 1;\r\n}\r\nout:\r\nup_read(&NILFS_MDT(cpfile)->mi_sem);\r\nreturn ret;\r\n}\r\nstatic ssize_t nilfs_cpfile_do_get_ssinfo(struct inode *cpfile, __u64 *cnop,\r\nvoid *buf, unsigned cisz, size_t nci)\r\n{\r\nstruct buffer_head *bh;\r\nstruct nilfs_cpfile_header *header;\r\nstruct nilfs_checkpoint *cp;\r\nstruct nilfs_cpinfo *ci = buf;\r\n__u64 curr = *cnop, next;\r\nunsigned long curr_blkoff, next_blkoff;\r\nvoid *kaddr;\r\nint n = 0, ret;\r\ndown_read(&NILFS_MDT(cpfile)->mi_sem);\r\nif (curr == 0) {\r\nret = nilfs_cpfile_get_header_block(cpfile, &bh);\r\nif (ret < 0)\r\ngoto out;\r\nkaddr = kmap_atomic(bh->b_page, KM_USER0);\r\nheader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\r\ncurr = le64_to_cpu(header->ch_snapshot_list.ssl_next);\r\nkunmap_atomic(kaddr, KM_USER0);\r\nbrelse(bh);\r\nif (curr == 0) {\r\nret = 0;\r\ngoto out;\r\n}\r\n} else if (unlikely(curr == ~(__u64)0)) {\r\nret = 0;\r\ngoto out;\r\n}\r\ncurr_blkoff = nilfs_cpfile_get_blkoff(cpfile, curr);\r\nret = nilfs_cpfile_get_checkpoint_block(cpfile, curr, 0, &bh);\r\nif (unlikely(ret < 0)) {\r\nif (ret == -ENOENT)\r\nret = 0;\r\ngoto out;\r\n}\r\nkaddr = kmap_atomic(bh->b_page, KM_USER0);\r\nwhile (n < nci) {\r\ncp = nilfs_cpfile_block_get_checkpoint(cpfile, curr, bh, kaddr);\r\ncurr = ~(__u64)0;\r\nif (unlikely(nilfs_checkpoint_invalid(cp) ||\r\n!nilfs_checkpoint_snapshot(cp)))\r\nbreak;\r\nnilfs_cpfile_checkpoint_to_cpinfo(cpfile, cp, ci);\r\nci = (void *)ci + cisz;\r\nn++;\r\nnext = le64_to_cpu(cp->cp_snapshot_list.ssl_next);\r\nif (next == 0)\r\nbreak;\r\nnext_blkoff = nilfs_cpfile_get_blkoff(cpfile, next);\r\nif (curr_blkoff != next_blkoff) {\r\nkunmap_atomic(kaddr, KM_USER0);\r\nbrelse(bh);\r\nret = nilfs_cpfile_get_checkpoint_block(cpfile, next,\r\n0, &bh);\r\nif (unlikely(ret < 0)) {\r\nWARN_ON(ret == -ENOENT);\r\ngoto out;\r\n}\r\nkaddr = kmap_atomic(bh->b_page, KM_USER0);\r\n}\r\ncurr = next;\r\ncurr_blkoff = next_blkoff;\r\n}\r\nkunmap_atomic(kaddr, KM_USER0);\r\nbrelse(bh);\r\n*cnop = curr;\r\nret = n;\r\nout:\r\nup_read(&NILFS_MDT(cpfile)->mi_sem);\r\nreturn ret;\r\n}\r\nssize_t nilfs_cpfile_get_cpinfo(struct inode *cpfile, __u64 *cnop, int mode,\r\nvoid *buf, unsigned cisz, size_t nci)\r\n{\r\nswitch (mode) {\r\ncase NILFS_CHECKPOINT:\r\nreturn nilfs_cpfile_do_get_cpinfo(cpfile, cnop, buf, cisz, nci);\r\ncase NILFS_SNAPSHOT:\r\nreturn nilfs_cpfile_do_get_ssinfo(cpfile, cnop, buf, cisz, nci);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint nilfs_cpfile_delete_checkpoint(struct inode *cpfile, __u64 cno)\r\n{\r\nstruct nilfs_cpinfo ci;\r\n__u64 tcno = cno;\r\nssize_t nci;\r\nnci = nilfs_cpfile_do_get_cpinfo(cpfile, &tcno, &ci, sizeof(ci), 1);\r\nif (nci < 0)\r\nreturn nci;\r\nelse if (nci == 0 || ci.ci_cno != cno)\r\nreturn -ENOENT;\r\nelse if (nilfs_cpinfo_snapshot(&ci))\r\nreturn -EBUSY;\r\nreturn nilfs_cpfile_delete_checkpoints(cpfile, cno, cno + 1);\r\n}\r\nstatic struct nilfs_snapshot_list *\r\nnilfs_cpfile_block_get_snapshot_list(const struct inode *cpfile,\r\n__u64 cno,\r\nstruct buffer_head *bh,\r\nvoid *kaddr)\r\n{\r\nstruct nilfs_cpfile_header *header;\r\nstruct nilfs_checkpoint *cp;\r\nstruct nilfs_snapshot_list *list;\r\nif (cno != 0) {\r\ncp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\r\nlist = &cp->cp_snapshot_list;\r\n} else {\r\nheader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\r\nlist = &header->ch_snapshot_list;\r\n}\r\nreturn list;\r\n}\r\nstatic int nilfs_cpfile_set_snapshot(struct inode *cpfile, __u64 cno)\r\n{\r\nstruct buffer_head *header_bh, *curr_bh, *prev_bh, *cp_bh;\r\nstruct nilfs_cpfile_header *header;\r\nstruct nilfs_checkpoint *cp;\r\nstruct nilfs_snapshot_list *list;\r\n__u64 curr, prev;\r\nunsigned long curr_blkoff, prev_blkoff;\r\nvoid *kaddr;\r\nint ret;\r\nif (cno == 0)\r\nreturn -ENOENT;\r\ndown_write(&NILFS_MDT(cpfile)->mi_sem);\r\nret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\r\nif (ret < 0)\r\ngoto out_sem;\r\nkaddr = kmap_atomic(cp_bh->b_page, KM_USER0);\r\ncp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\r\nif (nilfs_checkpoint_invalid(cp)) {\r\nret = -ENOENT;\r\nkunmap_atomic(kaddr, KM_USER0);\r\ngoto out_cp;\r\n}\r\nif (nilfs_checkpoint_snapshot(cp)) {\r\nret = 0;\r\nkunmap_atomic(kaddr, KM_USER0);\r\ngoto out_cp;\r\n}\r\nkunmap_atomic(kaddr, KM_USER0);\r\nret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\r\nif (ret < 0)\r\ngoto out_cp;\r\nkaddr = kmap_atomic(header_bh->b_page, KM_USER0);\r\nheader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\r\nlist = &header->ch_snapshot_list;\r\ncurr_bh = header_bh;\r\nget_bh(curr_bh);\r\ncurr = 0;\r\ncurr_blkoff = 0;\r\nprev = le64_to_cpu(list->ssl_prev);\r\nwhile (prev > cno) {\r\nprev_blkoff = nilfs_cpfile_get_blkoff(cpfile, prev);\r\ncurr = prev;\r\nif (curr_blkoff != prev_blkoff) {\r\nkunmap_atomic(kaddr, KM_USER0);\r\nbrelse(curr_bh);\r\nret = nilfs_cpfile_get_checkpoint_block(cpfile, curr,\r\n0, &curr_bh);\r\nif (ret < 0)\r\ngoto out_header;\r\nkaddr = kmap_atomic(curr_bh->b_page, KM_USER0);\r\n}\r\ncurr_blkoff = prev_blkoff;\r\ncp = nilfs_cpfile_block_get_checkpoint(\r\ncpfile, curr, curr_bh, kaddr);\r\nlist = &cp->cp_snapshot_list;\r\nprev = le64_to_cpu(list->ssl_prev);\r\n}\r\nkunmap_atomic(kaddr, KM_USER0);\r\nif (prev != 0) {\r\nret = nilfs_cpfile_get_checkpoint_block(cpfile, prev, 0,\r\n&prev_bh);\r\nif (ret < 0)\r\ngoto out_curr;\r\n} else {\r\nprev_bh = header_bh;\r\nget_bh(prev_bh);\r\n}\r\nkaddr = kmap_atomic(curr_bh->b_page, KM_USER0);\r\nlist = nilfs_cpfile_block_get_snapshot_list(\r\ncpfile, curr, curr_bh, kaddr);\r\nlist->ssl_prev = cpu_to_le64(cno);\r\nkunmap_atomic(kaddr, KM_USER0);\r\nkaddr = kmap_atomic(cp_bh->b_page, KM_USER0);\r\ncp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\r\ncp->cp_snapshot_list.ssl_next = cpu_to_le64(curr);\r\ncp->cp_snapshot_list.ssl_prev = cpu_to_le64(prev);\r\nnilfs_checkpoint_set_snapshot(cp);\r\nkunmap_atomic(kaddr, KM_USER0);\r\nkaddr = kmap_atomic(prev_bh->b_page, KM_USER0);\r\nlist = nilfs_cpfile_block_get_snapshot_list(\r\ncpfile, prev, prev_bh, kaddr);\r\nlist->ssl_next = cpu_to_le64(cno);\r\nkunmap_atomic(kaddr, KM_USER0);\r\nkaddr = kmap_atomic(header_bh->b_page, KM_USER0);\r\nheader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\r\nle64_add_cpu(&header->ch_nsnapshots, 1);\r\nkunmap_atomic(kaddr, KM_USER0);\r\nmark_buffer_dirty(prev_bh);\r\nmark_buffer_dirty(curr_bh);\r\nmark_buffer_dirty(cp_bh);\r\nmark_buffer_dirty(header_bh);\r\nnilfs_mdt_mark_dirty(cpfile);\r\nbrelse(prev_bh);\r\nout_curr:\r\nbrelse(curr_bh);\r\nout_header:\r\nbrelse(header_bh);\r\nout_cp:\r\nbrelse(cp_bh);\r\nout_sem:\r\nup_write(&NILFS_MDT(cpfile)->mi_sem);\r\nreturn ret;\r\n}\r\nstatic int nilfs_cpfile_clear_snapshot(struct inode *cpfile, __u64 cno)\r\n{\r\nstruct buffer_head *header_bh, *next_bh, *prev_bh, *cp_bh;\r\nstruct nilfs_cpfile_header *header;\r\nstruct nilfs_checkpoint *cp;\r\nstruct nilfs_snapshot_list *list;\r\n__u64 next, prev;\r\nvoid *kaddr;\r\nint ret;\r\nif (cno == 0)\r\nreturn -ENOENT;\r\ndown_write(&NILFS_MDT(cpfile)->mi_sem);\r\nret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\r\nif (ret < 0)\r\ngoto out_sem;\r\nkaddr = kmap_atomic(cp_bh->b_page, KM_USER0);\r\ncp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\r\nif (nilfs_checkpoint_invalid(cp)) {\r\nret = -ENOENT;\r\nkunmap_atomic(kaddr, KM_USER0);\r\ngoto out_cp;\r\n}\r\nif (!nilfs_checkpoint_snapshot(cp)) {\r\nret = 0;\r\nkunmap_atomic(kaddr, KM_USER0);\r\ngoto out_cp;\r\n}\r\nlist = &cp->cp_snapshot_list;\r\nnext = le64_to_cpu(list->ssl_next);\r\nprev = le64_to_cpu(list->ssl_prev);\r\nkunmap_atomic(kaddr, KM_USER0);\r\nret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\r\nif (ret < 0)\r\ngoto out_cp;\r\nif (next != 0) {\r\nret = nilfs_cpfile_get_checkpoint_block(cpfile, next, 0,\r\n&next_bh);\r\nif (ret < 0)\r\ngoto out_header;\r\n} else {\r\nnext_bh = header_bh;\r\nget_bh(next_bh);\r\n}\r\nif (prev != 0) {\r\nret = nilfs_cpfile_get_checkpoint_block(cpfile, prev, 0,\r\n&prev_bh);\r\nif (ret < 0)\r\ngoto out_next;\r\n} else {\r\nprev_bh = header_bh;\r\nget_bh(prev_bh);\r\n}\r\nkaddr = kmap_atomic(next_bh->b_page, KM_USER0);\r\nlist = nilfs_cpfile_block_get_snapshot_list(\r\ncpfile, next, next_bh, kaddr);\r\nlist->ssl_prev = cpu_to_le64(prev);\r\nkunmap_atomic(kaddr, KM_USER0);\r\nkaddr = kmap_atomic(prev_bh->b_page, KM_USER0);\r\nlist = nilfs_cpfile_block_get_snapshot_list(\r\ncpfile, prev, prev_bh, kaddr);\r\nlist->ssl_next = cpu_to_le64(next);\r\nkunmap_atomic(kaddr, KM_USER0);\r\nkaddr = kmap_atomic(cp_bh->b_page, KM_USER0);\r\ncp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\r\ncp->cp_snapshot_list.ssl_next = cpu_to_le64(0);\r\ncp->cp_snapshot_list.ssl_prev = cpu_to_le64(0);\r\nnilfs_checkpoint_clear_snapshot(cp);\r\nkunmap_atomic(kaddr, KM_USER0);\r\nkaddr = kmap_atomic(header_bh->b_page, KM_USER0);\r\nheader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\r\nle64_add_cpu(&header->ch_nsnapshots, -1);\r\nkunmap_atomic(kaddr, KM_USER0);\r\nmark_buffer_dirty(next_bh);\r\nmark_buffer_dirty(prev_bh);\r\nmark_buffer_dirty(cp_bh);\r\nmark_buffer_dirty(header_bh);\r\nnilfs_mdt_mark_dirty(cpfile);\r\nbrelse(prev_bh);\r\nout_next:\r\nbrelse(next_bh);\r\nout_header:\r\nbrelse(header_bh);\r\nout_cp:\r\nbrelse(cp_bh);\r\nout_sem:\r\nup_write(&NILFS_MDT(cpfile)->mi_sem);\r\nreturn ret;\r\n}\r\nint nilfs_cpfile_is_snapshot(struct inode *cpfile, __u64 cno)\r\n{\r\nstruct buffer_head *bh;\r\nstruct nilfs_checkpoint *cp;\r\nvoid *kaddr;\r\nint ret;\r\nif (cno == 0 || cno >= nilfs_mdt_cno(cpfile))\r\nreturn -ENOENT;\r\ndown_read(&NILFS_MDT(cpfile)->mi_sem);\r\nret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &bh);\r\nif (ret < 0)\r\ngoto out;\r\nkaddr = kmap_atomic(bh->b_page, KM_USER0);\r\ncp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\r\nif (nilfs_checkpoint_invalid(cp))\r\nret = -ENOENT;\r\nelse\r\nret = nilfs_checkpoint_snapshot(cp);\r\nkunmap_atomic(kaddr, KM_USER0);\r\nbrelse(bh);\r\nout:\r\nup_read(&NILFS_MDT(cpfile)->mi_sem);\r\nreturn ret;\r\n}\r\nint nilfs_cpfile_change_cpmode(struct inode *cpfile, __u64 cno, int mode)\r\n{\r\nint ret;\r\nswitch (mode) {\r\ncase NILFS_CHECKPOINT:\r\nif (nilfs_checkpoint_is_mounted(cpfile->i_sb, cno))\r\nret = -EBUSY;\r\nelse\r\nret = nilfs_cpfile_clear_snapshot(cpfile, cno);\r\nreturn ret;\r\ncase NILFS_SNAPSHOT:\r\nreturn nilfs_cpfile_set_snapshot(cpfile, cno);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint nilfs_cpfile_get_stat(struct inode *cpfile, struct nilfs_cpstat *cpstat)\r\n{\r\nstruct buffer_head *bh;\r\nstruct nilfs_cpfile_header *header;\r\nvoid *kaddr;\r\nint ret;\r\ndown_read(&NILFS_MDT(cpfile)->mi_sem);\r\nret = nilfs_cpfile_get_header_block(cpfile, &bh);\r\nif (ret < 0)\r\ngoto out_sem;\r\nkaddr = kmap_atomic(bh->b_page, KM_USER0);\r\nheader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\r\ncpstat->cs_cno = nilfs_mdt_cno(cpfile);\r\ncpstat->cs_ncps = le64_to_cpu(header->ch_ncheckpoints);\r\ncpstat->cs_nsss = le64_to_cpu(header->ch_nsnapshots);\r\nkunmap_atomic(kaddr, KM_USER0);\r\nbrelse(bh);\r\nout_sem:\r\nup_read(&NILFS_MDT(cpfile)->mi_sem);\r\nreturn ret;\r\n}\r\nint nilfs_cpfile_read(struct super_block *sb, size_t cpsize,\r\nstruct nilfs_inode *raw_inode, struct inode **inodep)\r\n{\r\nstruct inode *cpfile;\r\nint err;\r\ncpfile = nilfs_iget_locked(sb, NULL, NILFS_CPFILE_INO);\r\nif (unlikely(!cpfile))\r\nreturn -ENOMEM;\r\nif (!(cpfile->i_state & I_NEW))\r\ngoto out;\r\nerr = nilfs_mdt_init(cpfile, NILFS_MDT_GFP, 0);\r\nif (err)\r\ngoto failed;\r\nnilfs_mdt_set_entry_size(cpfile, cpsize,\r\nsizeof(struct nilfs_cpfile_header));\r\nerr = nilfs_read_inode_common(cpfile, raw_inode);\r\nif (err)\r\ngoto failed;\r\nunlock_new_inode(cpfile);\r\nout:\r\n*inodep = cpfile;\r\nreturn 0;\r\nfailed:\r\niget_failed(cpfile);\r\nreturn err;\r\n}
