unsigned int\r\n_GetXid(void)\r\n{\r\nunsigned int xid;\r\nspin_lock(&GlobalMid_Lock);\r\nGlobalTotalActiveXid++;\r\nif (GlobalTotalActiveXid > GlobalMaxActiveXid)\r\nGlobalMaxActiveXid = GlobalTotalActiveXid;\r\nif (GlobalTotalActiveXid > 65000)\r\ncFYI(1, "warning: more than 65000 requests active");\r\nxid = GlobalCurrentXid++;\r\nspin_unlock(&GlobalMid_Lock);\r\nreturn xid;\r\n}\r\nvoid\r\n_FreeXid(unsigned int xid)\r\n{\r\nspin_lock(&GlobalMid_Lock);\r\nGlobalTotalActiveXid--;\r\nspin_unlock(&GlobalMid_Lock);\r\n}\r\nstruct cifs_ses *\r\nsesInfoAlloc(void)\r\n{\r\nstruct cifs_ses *ret_buf;\r\nret_buf = kzalloc(sizeof(struct cifs_ses), GFP_KERNEL);\r\nif (ret_buf) {\r\natomic_inc(&sesInfoAllocCount);\r\nret_buf->status = CifsNew;\r\n++ret_buf->ses_count;\r\nINIT_LIST_HEAD(&ret_buf->smb_ses_list);\r\nINIT_LIST_HEAD(&ret_buf->tcon_list);\r\nmutex_init(&ret_buf->session_mutex);\r\n}\r\nreturn ret_buf;\r\n}\r\nvoid\r\nsesInfoFree(struct cifs_ses *buf_to_free)\r\n{\r\nif (buf_to_free == NULL) {\r\ncFYI(1, "Null buffer passed to sesInfoFree");\r\nreturn;\r\n}\r\natomic_dec(&sesInfoAllocCount);\r\nkfree(buf_to_free->serverOS);\r\nkfree(buf_to_free->serverDomain);\r\nkfree(buf_to_free->serverNOS);\r\nif (buf_to_free->password) {\r\nmemset(buf_to_free->password, 0, strlen(buf_to_free->password));\r\nkfree(buf_to_free->password);\r\n}\r\nkfree(buf_to_free->user_name);\r\nkfree(buf_to_free->domainName);\r\nkfree(buf_to_free);\r\n}\r\nstruct cifs_tcon *\r\ntconInfoAlloc(void)\r\n{\r\nstruct cifs_tcon *ret_buf;\r\nret_buf = kzalloc(sizeof(struct cifs_tcon), GFP_KERNEL);\r\nif (ret_buf) {\r\natomic_inc(&tconInfoAllocCount);\r\nret_buf->tidStatus = CifsNew;\r\n++ret_buf->tc_count;\r\nINIT_LIST_HEAD(&ret_buf->openFileList);\r\nINIT_LIST_HEAD(&ret_buf->tcon_list);\r\n#ifdef CONFIG_CIFS_STATS\r\nspin_lock_init(&ret_buf->stat_lock);\r\n#endif\r\n}\r\nreturn ret_buf;\r\n}\r\nvoid\r\ntconInfoFree(struct cifs_tcon *buf_to_free)\r\n{\r\nif (buf_to_free == NULL) {\r\ncFYI(1, "Null buffer passed to tconInfoFree");\r\nreturn;\r\n}\r\natomic_dec(&tconInfoAllocCount);\r\nkfree(buf_to_free->nativeFileSystem);\r\nif (buf_to_free->password) {\r\nmemset(buf_to_free->password, 0, strlen(buf_to_free->password));\r\nkfree(buf_to_free->password);\r\n}\r\nkfree(buf_to_free);\r\n}\r\nstruct smb_hdr *\r\ncifs_buf_get(void)\r\n{\r\nstruct smb_hdr *ret_buf = NULL;\r\nret_buf = mempool_alloc(cifs_req_poolp, GFP_NOFS);\r\nif (ret_buf) {\r\nmemset(ret_buf, 0, sizeof(struct smb_hdr) + 3);\r\natomic_inc(&bufAllocCount);\r\n#ifdef CONFIG_CIFS_STATS2\r\natomic_inc(&totBufAllocCount);\r\n#endif\r\n}\r\nreturn ret_buf;\r\n}\r\nvoid\r\ncifs_buf_release(void *buf_to_free)\r\n{\r\nif (buf_to_free == NULL) {\r\nreturn;\r\n}\r\nmempool_free(buf_to_free, cifs_req_poolp);\r\natomic_dec(&bufAllocCount);\r\nreturn;\r\n}\r\nstruct smb_hdr *\r\ncifs_small_buf_get(void)\r\n{\r\nstruct smb_hdr *ret_buf = NULL;\r\nret_buf = mempool_alloc(cifs_sm_req_poolp, GFP_NOFS);\r\nif (ret_buf) {\r\natomic_inc(&smBufAllocCount);\r\n#ifdef CONFIG_CIFS_STATS2\r\natomic_inc(&totSmBufAllocCount);\r\n#endif\r\n}\r\nreturn ret_buf;\r\n}\r\nvoid\r\ncifs_small_buf_release(void *buf_to_free)\r\n{\r\nif (buf_to_free == NULL) {\r\ncFYI(1, "Null buffer passed to cifs_small_buf_release");\r\nreturn;\r\n}\r\nmempool_free(buf_to_free, cifs_sm_req_poolp);\r\natomic_dec(&smBufAllocCount);\r\nreturn;\r\n}\r\n__u16 GetNextMid(struct TCP_Server_Info *server)\r\n{\r\n__u16 mid = 0;\r\n__u16 last_mid;\r\nbool collision;\r\nspin_lock(&GlobalMid_Lock);\r\nlast_mid = server->CurrentMid;\r\nserver->CurrentMid++;\r\nwhile (server->CurrentMid != last_mid) {\r\nstruct mid_q_entry *mid_entry;\r\nunsigned int num_mids;\r\ncollision = false;\r\nif (server->CurrentMid == 0)\r\nserver->CurrentMid++;\r\nnum_mids = 0;\r\nlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\r\n++num_mids;\r\nif (mid_entry->mid == server->CurrentMid &&\r\nmid_entry->midState == MID_REQUEST_SUBMITTED) {\r\ncollision = true;\r\nbreak;\r\n}\r\n}\r\nif (num_mids > 32768)\r\nserver->tcpStatus = CifsNeedReconnect;\r\nif (!collision) {\r\nmid = server->CurrentMid;\r\nbreak;\r\n}\r\nserver->CurrentMid++;\r\n}\r\nspin_unlock(&GlobalMid_Lock);\r\nreturn mid;\r\n}\r\nvoid\r\nheader_assemble(struct smb_hdr *buffer, char smb_command ,\r\nconst struct cifs_tcon *treeCon, int word_count\r\n)\r\n{\r\nstruct list_head *temp_item;\r\nstruct cifs_ses *ses;\r\nchar *temp = (char *) buffer;\r\nmemset(temp, 0, 256);\r\nbuffer->smb_buf_length = cpu_to_be32(\r\n(2 * word_count) + sizeof(struct smb_hdr) -\r\n4 +\r\n2 ) ;\r\nbuffer->Protocol[0] = 0xFF;\r\nbuffer->Protocol[1] = 'S';\r\nbuffer->Protocol[2] = 'M';\r\nbuffer->Protocol[3] = 'B';\r\nbuffer->Command = smb_command;\r\nbuffer->Flags = 0x00;\r\nbuffer->Flags2 = SMBFLG2_KNOWS_LONG_NAMES;\r\nbuffer->Pid = cpu_to_le16((__u16)current->tgid);\r\nbuffer->PidHigh = cpu_to_le16((__u16)(current->tgid >> 16));\r\nif (treeCon) {\r\nbuffer->Tid = treeCon->tid;\r\nif (treeCon->ses) {\r\nif (treeCon->ses->capabilities & CAP_UNICODE)\r\nbuffer->Flags2 |= SMBFLG2_UNICODE;\r\nif (treeCon->ses->capabilities & CAP_STATUS32)\r\nbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\r\nbuffer->Uid = treeCon->ses->Suid;\r\nbuffer->Mid = GetNextMid(treeCon->ses->server);\r\nif (multiuser_mount != 0) {\r\nif (current_fsuid() != treeCon->ses->linux_uid) {\r\ncFYI(1, "Multiuser mode and UID "\r\n"did not match tcon uid");\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_for_each(temp_item, &treeCon->ses->server->smb_ses_list) {\r\nses = list_entry(temp_item, struct cifs_ses, smb_ses_list);\r\nif (ses->linux_uid == current_fsuid()) {\r\nif (ses->server == treeCon->ses->server) {\r\ncFYI(1, "found matching uid substitute right smb_uid");\r\nbuffer->Uid = ses->Suid;\r\nbreak;\r\n} else {\r\ncFYI(1, "local UID found but no smb sess with this server exists");\r\n}\r\n}\r\n}\r\nspin_unlock(&cifs_tcp_ses_lock);\r\n}\r\n}\r\n}\r\nif (treeCon->Flags & SMB_SHARE_IS_IN_DFS)\r\nbuffer->Flags2 |= SMBFLG2_DFS;\r\nif (treeCon->nocase)\r\nbuffer->Flags |= SMBFLG_CASELESS;\r\nif ((treeCon->ses) && (treeCon->ses->server))\r\nif (treeCon->ses->server->sec_mode &\r\n(SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))\r\nbuffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\r\n}\r\nbuffer->WordCount = (char) word_count;\r\nreturn;\r\n}\r\nstatic int\r\ncheck_smb_hdr(struct smb_hdr *smb, __u16 mid)\r\n{\r\nif (*(__le32 *) smb->Protocol != cpu_to_le32(0x424d53ff)) {\r\ncERROR(1, "Bad protocol string signature header 0x%x",\r\n*(unsigned int *)smb->Protocol);\r\nreturn 1;\r\n}\r\nif (mid != smb->Mid) {\r\ncERROR(1, "Mids do not match. received=%u expected=%u",\r\nsmb->Mid, mid);\r\nreturn 1;\r\n}\r\nif (smb->Flags & SMBFLG_RESPONSE)\r\nreturn 0;\r\nif (smb->Command == SMB_COM_LOCKING_ANDX)\r\nreturn 0;\r\ncERROR(1, "Server sent request, not response. mid=%u", smb->Mid);\r\nreturn 1;\r\n}\r\nint\r\ncheckSMB(struct smb_hdr *smb, __u16 mid, unsigned int total_read)\r\n{\r\n__u32 rfclen = be32_to_cpu(smb->smb_buf_length);\r\n__u32 clc_len;\r\ncFYI(0, "checkSMB Length: 0x%x, smb_buf_length: 0x%x",\r\ntotal_read, rfclen);\r\nif (total_read < 2 + sizeof(struct smb_hdr)) {\r\nif ((total_read >= sizeof(struct smb_hdr) - 1)\r\n&& (smb->Status.CifsError != 0)) {\r\nsmb->WordCount = 0;\r\nreturn 0;\r\n} else if ((total_read == sizeof(struct smb_hdr) + 1) &&\r\n(smb->WordCount == 0)) {\r\nchar *tmp = (char *)smb;\r\nif (tmp[sizeof(struct smb_hdr)] == 0) {\r\ntmp[sizeof(struct smb_hdr)+1] = 0;\r\nreturn 0;\r\n}\r\ncERROR(1, "rcvd invalid byte count (bcc)");\r\n} else {\r\ncERROR(1, "Length less than smb header size");\r\n}\r\nreturn -EIO;\r\n}\r\nif (check_smb_hdr(smb, mid))\r\nreturn -EIO;\r\nclc_len = smbCalcSize(smb);\r\nif (4 + rfclen != total_read) {\r\ncERROR(1, "Length read does not match RFC1001 length %d",\r\nrfclen);\r\nreturn -EIO;\r\n}\r\nif (4 + rfclen != clc_len) {\r\nif ((rfclen > 64 * 1024) && (rfclen > clc_len)) {\r\nif (((4 + rfclen) & 0xFFFF) == (clc_len & 0xFFFF))\r\nreturn 0;\r\n}\r\ncFYI(1, "Calculated size %u vs length %u mismatch for mid=%u",\r\nclc_len, 4 + rfclen, smb->Mid);\r\nif (4 + rfclen < clc_len) {\r\ncERROR(1, "RFC1001 size %u smaller than SMB for mid=%u",\r\nrfclen, smb->Mid);\r\nreturn -EIO;\r\n} else if (rfclen > clc_len + 512) {\r\ncERROR(1, "RFC1001 size %u more than 512 bytes larger "\r\n"than SMB for mid=%u", rfclen, smb->Mid);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nbool\r\nis_valid_oplock_break(struct smb_hdr *buf, struct TCP_Server_Info *srv)\r\n{\r\nstruct smb_com_lock_req *pSMB = (struct smb_com_lock_req *)buf;\r\nstruct list_head *tmp, *tmp1, *tmp2;\r\nstruct cifs_ses *ses;\r\nstruct cifs_tcon *tcon;\r\nstruct cifsInodeInfo *pCifsInode;\r\nstruct cifsFileInfo *netfile;\r\ncFYI(1, "Checking for oplock break or dnotify response");\r\nif ((pSMB->hdr.Command == SMB_COM_NT_TRANSACT) &&\r\n(pSMB->hdr.Flags & SMBFLG_RESPONSE)) {\r\nstruct smb_com_transaction_change_notify_rsp *pSMBr =\r\n(struct smb_com_transaction_change_notify_rsp *)buf;\r\nstruct file_notify_information *pnotify;\r\n__u32 data_offset = 0;\r\nif (get_bcc(buf) > sizeof(struct file_notify_information)) {\r\ndata_offset = le32_to_cpu(pSMBr->DataOffset);\r\npnotify = (struct file_notify_information *)\r\n((char *)&pSMBr->hdr.Protocol + data_offset);\r\ncFYI(1, "dnotify on %s Action: 0x%x",\r\npnotify->FileName, pnotify->Action);\r\nreturn true;\r\n}\r\nif (pSMBr->hdr.Status.CifsError) {\r\ncFYI(1, "notify err 0x%d",\r\npSMBr->hdr.Status.CifsError);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nif (pSMB->hdr.Command != SMB_COM_LOCKING_ANDX)\r\nreturn false;\r\nif (pSMB->hdr.Flags & SMBFLG_RESPONSE) {\r\nif ((NT_STATUS_INVALID_HANDLE) ==\r\nle32_to_cpu(pSMB->hdr.Status.CifsError)) {\r\ncFYI(1, "invalid handle on oplock break");\r\nreturn true;\r\n} else if (ERRbadfid ==\r\nle16_to_cpu(pSMB->hdr.Status.DosError.Error)) {\r\nreturn true;\r\n} else {\r\nreturn false;\r\n}\r\n}\r\nif (pSMB->hdr.WordCount != 8)\r\nreturn false;\r\ncFYI(1, "oplock type 0x%d level 0x%d",\r\npSMB->LockType, pSMB->OplockLevel);\r\nif (!(pSMB->LockType & LOCKING_ANDX_OPLOCK_RELEASE))\r\nreturn false;\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_for_each(tmp, &srv->smb_ses_list) {\r\nses = list_entry(tmp, struct cifs_ses, smb_ses_list);\r\nlist_for_each(tmp1, &ses->tcon_list) {\r\ntcon = list_entry(tmp1, struct cifs_tcon, tcon_list);\r\nif (tcon->tid != buf->Tid)\r\ncontinue;\r\ncifs_stats_inc(&tcon->num_oplock_brks);\r\nspin_lock(&cifs_file_list_lock);\r\nlist_for_each(tmp2, &tcon->openFileList) {\r\nnetfile = list_entry(tmp2, struct cifsFileInfo,\r\ntlist);\r\nif (pSMB->Fid != netfile->netfid)\r\ncontinue;\r\ncFYI(1, "file id match, oplock break");\r\npCifsInode = CIFS_I(netfile->dentry->d_inode);\r\ncifs_set_oplock_level(pCifsInode,\r\npSMB->OplockLevel ? OPLOCK_READ : 0);\r\nqueue_work(system_nrt_wq,\r\n&netfile->oplock_break);\r\nnetfile->oplock_break_cancelled = false;\r\nspin_unlock(&cifs_file_list_lock);\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn true;\r\n}\r\nspin_unlock(&cifs_file_list_lock);\r\nspin_unlock(&cifs_tcp_ses_lock);\r\ncFYI(1, "No matching file for oplock break");\r\nreturn true;\r\n}\r\n}\r\nspin_unlock(&cifs_tcp_ses_lock);\r\ncFYI(1, "Can not process oplock break for non-existent connection");\r\nreturn true;\r\n}\r\nvoid\r\ndump_smb(struct smb_hdr *smb_buf, int smb_buf_length)\r\n{\r\nint i, j;\r\nchar debug_line[17];\r\nunsigned char *buffer;\r\nif (traceSMB == 0)\r\nreturn;\r\nbuffer = (unsigned char *) smb_buf;\r\nfor (i = 0, j = 0; i < smb_buf_length; i++, j++) {\r\nif (i % 8 == 0) {\r\nprintk(KERN_DEBUG "| ");\r\nj = 0;\r\n}\r\nprintk("%0#4x ", buffer[i]);\r\ndebug_line[2 * j] = ' ';\r\nif (isprint(buffer[i]))\r\ndebug_line[1 + (2 * j)] = buffer[i];\r\nelse\r\ndebug_line[1 + (2 * j)] = '_';\r\nif (i % 8 == 7) {\r\ndebug_line[16] = 0;\r\nprintk(" | %s\n", debug_line);\r\n}\r\n}\r\nfor (; j < 8; j++) {\r\nprintk(" ");\r\ndebug_line[2 * j] = ' ';\r\ndebug_line[1 + (2 * j)] = ' ';\r\n}\r\nprintk(" | %s\n", debug_line);\r\nreturn;\r\n}\r\nvoid\r\ncifs_autodisable_serverino(struct cifs_sb_info *cifs_sb)\r\n{\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\r\ncifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\r\ncERROR(1, "Autodisabling the use of server inode numbers on "\r\n"%s. This server doesn't seem to support them "\r\n"properly. Hardlinks will not be recognized on this "\r\n"mount. Consider mounting with the \"noserverino\" "\r\n"option to silence this message.",\r\ncifs_sb_master_tcon(cifs_sb)->treeName);\r\n}\r\n}\r\nvoid cifs_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)\r\n{\r\noplock &= 0xF;\r\nif (oplock == OPLOCK_EXCLUSIVE) {\r\ncinode->clientCanCacheAll = true;\r\ncinode->clientCanCacheRead = true;\r\ncFYI(1, "Exclusive Oplock granted on inode %p",\r\n&cinode->vfs_inode);\r\n} else if (oplock == OPLOCK_READ) {\r\ncinode->clientCanCacheAll = false;\r\ncinode->clientCanCacheRead = true;\r\ncFYI(1, "Level II Oplock granted on inode %p",\r\n&cinode->vfs_inode);\r\n} else {\r\ncinode->clientCanCacheAll = false;\r\ncinode->clientCanCacheRead = false;\r\n}\r\n}\r\nbool\r\nbackup_cred(struct cifs_sb_info *cifs_sb)\r\n{\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\r\nif (cifs_sb->mnt_backupuid == current_fsuid())\r\nreturn true;\r\n}\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\r\nif (in_group_p(cifs_sb->mnt_backupgid))\r\nreturn true;\r\n}\r\nreturn false;\r\n}
