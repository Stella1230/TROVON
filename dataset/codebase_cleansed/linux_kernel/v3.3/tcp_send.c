static void rds_tcp_cork(struct socket *sock, int val)\r\n{\r\nmm_segment_t oldfs;\r\noldfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nsock->ops->setsockopt(sock, SOL_TCP, TCP_CORK, (char __user *)&val,\r\nsizeof(val));\r\nset_fs(oldfs);\r\n}\r\nvoid rds_tcp_xmit_prepare(struct rds_connection *conn)\r\n{\r\nstruct rds_tcp_connection *tc = conn->c_transport_data;\r\nrds_tcp_cork(tc->t_sock, 1);\r\n}\r\nvoid rds_tcp_xmit_complete(struct rds_connection *conn)\r\n{\r\nstruct rds_tcp_connection *tc = conn->c_transport_data;\r\nrds_tcp_cork(tc->t_sock, 0);\r\n}\r\nstatic int rds_tcp_sendmsg(struct socket *sock, void *data, unsigned int len)\r\n{\r\nstruct kvec vec = {\r\n.iov_base = data,\r\n.iov_len = len,\r\n};\r\nstruct msghdr msg = {\r\n.msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL,\r\n};\r\nreturn kernel_sendmsg(sock, &msg, &vec, 1, vec.iov_len);\r\n}\r\nint rds_tcp_xmit(struct rds_connection *conn, struct rds_message *rm,\r\nunsigned int hdr_off, unsigned int sg, unsigned int off)\r\n{\r\nstruct rds_tcp_connection *tc = conn->c_transport_data;\r\nint done = 0;\r\nint ret = 0;\r\nif (hdr_off == 0) {\r\ntc->t_last_sent_nxt = rds_tcp_snd_nxt(tc);\r\nrm->m_ack_seq = tc->t_last_sent_nxt +\r\nsizeof(struct rds_header) +\r\nbe32_to_cpu(rm->m_inc.i_hdr.h_len) - 1;\r\nsmp_mb__before_clear_bit();\r\nset_bit(RDS_MSG_HAS_ACK_SEQ, &rm->m_flags);\r\ntc->t_last_expected_una = rm->m_ack_seq + 1;\r\nrdsdebug("rm %p tcp nxt %u ack_seq %llu\n",\r\nrm, rds_tcp_snd_nxt(tc),\r\n(unsigned long long)rm->m_ack_seq);\r\n}\r\nif (hdr_off < sizeof(struct rds_header)) {\r\nset_bit(SOCK_NOSPACE, &tc->t_sock->sk->sk_socket->flags);\r\nret = rds_tcp_sendmsg(tc->t_sock,\r\n(void *)&rm->m_inc.i_hdr + hdr_off,\r\nsizeof(rm->m_inc.i_hdr) - hdr_off);\r\nif (ret < 0)\r\ngoto out;\r\ndone += ret;\r\nif (hdr_off + done != sizeof(struct rds_header))\r\ngoto out;\r\n}\r\nwhile (sg < rm->data.op_nents) {\r\nret = tc->t_sock->ops->sendpage(tc->t_sock,\r\nsg_page(&rm->data.op_sg[sg]),\r\nrm->data.op_sg[sg].offset + off,\r\nrm->data.op_sg[sg].length - off,\r\nMSG_DONTWAIT|MSG_NOSIGNAL);\r\nrdsdebug("tcp sendpage %p:%u:%u ret %d\n", (void *)sg_page(&rm->data.op_sg[sg]),\r\nrm->data.op_sg[sg].offset + off, rm->data.op_sg[sg].length - off,\r\nret);\r\nif (ret <= 0)\r\nbreak;\r\noff += ret;\r\ndone += ret;\r\nif (off == rm->data.op_sg[sg].length) {\r\noff = 0;\r\nsg++;\r\n}\r\n}\r\nout:\r\nif (ret <= 0) {\r\nif (ret == -EAGAIN) {\r\nrds_tcp_stats_inc(s_tcp_sndbuf_full);\r\nret = 0;\r\n} else {\r\nprintk(KERN_WARNING "RDS/tcp: send to %pI4 "\r\n"returned %d, disconnecting and reconnecting\n",\r\n&conn->c_faddr, ret);\r\nrds_conn_drop(conn);\r\n}\r\n}\r\nif (done == 0)\r\ndone = ret;\r\nreturn done;\r\n}\r\nstatic int rds_tcp_is_acked(struct rds_message *rm, uint64_t ack)\r\n{\r\nif (!test_bit(RDS_MSG_HAS_ACK_SEQ, &rm->m_flags))\r\nreturn 0;\r\nreturn (__s32)((u32)rm->m_ack_seq - (u32)ack) < 0;\r\n}\r\nvoid rds_tcp_write_space(struct sock *sk)\r\n{\r\nvoid (*write_space)(struct sock *sk);\r\nstruct rds_connection *conn;\r\nstruct rds_tcp_connection *tc;\r\nread_lock_bh(&sk->sk_callback_lock);\r\nconn = sk->sk_user_data;\r\nif (!conn) {\r\nwrite_space = sk->sk_write_space;\r\ngoto out;\r\n}\r\ntc = conn->c_transport_data;\r\nrdsdebug("write_space for tc %p\n", tc);\r\nwrite_space = tc->t_orig_write_space;\r\nrds_tcp_stats_inc(s_tcp_write_space_calls);\r\nrdsdebug("tcp una %u\n", rds_tcp_snd_una(tc));\r\ntc->t_last_seen_una = rds_tcp_snd_una(tc);\r\nrds_send_drop_acked(conn, rds_tcp_snd_una(tc), rds_tcp_is_acked);\r\nif ((atomic_read(&sk->sk_wmem_alloc) << 1) <= sk->sk_sndbuf)\r\nqueue_delayed_work(rds_wq, &conn->c_send_w, 0);\r\nout:\r\nread_unlock_bh(&sk->sk_callback_lock);\r\nwrite_space(sk);\r\nif (sk->sk_socket)\r\nset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\r\n}
