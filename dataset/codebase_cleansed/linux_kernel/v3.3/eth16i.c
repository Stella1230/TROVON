static int __init do_eth16i_probe(struct net_device *dev)\r\n{\r\nint i;\r\nint ioaddr;\r\nint base_addr = dev->base_addr;\r\nif(eth16i_debug > 4)\r\nprintk(KERN_DEBUG "Probing started for %s\n", cardname);\r\nif(base_addr > 0x1ff)\r\nreturn eth16i_probe1(dev, base_addr);\r\nelse if(base_addr != 0)\r\nreturn -ENXIO;\r\nfor(i = 0; (ioaddr = eth16i_portlist[i]) ; i++)\r\nif(eth16i_probe1(dev, ioaddr) == 0)\r\nreturn 0;\r\nfor(i = 0; (ioaddr = eth32i_portlist[i]) ; i++)\r\nif(eth16i_probe1(dev, ioaddr) == 0)\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nstruct net_device * __init eth16i_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct eth16i_local));\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nerr = do_eth16i_probe(dev);\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init eth16i_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nstruct eth16i_local *lp = netdev_priv(dev);\r\nstatic unsigned version_printed;\r\nint retval;\r\nif (!request_region(ioaddr, ETH16I_IO_EXTENT, cardname))\r\nreturn -EBUSY;\r\nif(ioaddr < 0x1000) {\r\nif(eth16i_portlist[(inb(ioaddr + JUMPERLESS_CONFIG) & 0x07)]\r\n!= ioaddr) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\n}\r\nif(eth16i_check_signature(ioaddr) != 0) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\neth16i_select_regbank(TRANSCEIVER_MODE_RB, ioaddr);\r\noutb(0x00, ioaddr + TRANSCEIVER_MODE_REG);\r\noutb(0x00, ioaddr + RESET);\r\nBITSET(ioaddr + CONFIG_REG_0, BIT(7));\r\nif( (eth16i_debug & version_printed++) == 0)\r\nprintk(KERN_INFO "%s", version);\r\ndev->base_addr = ioaddr;\r\ndev->irq = eth16i_get_irq(ioaddr);\r\nif ((retval = request_irq(dev->irq, (void *)&eth16i_interrupt, 0, cardname, dev))) {\r\nprintk(KERN_WARNING "%s at %#3x, but is unusable due to conflicting IRQ %d.\n",\r\ncardname, ioaddr, dev->irq);\r\ngoto out;\r\n}\r\nprintk(KERN_INFO "%s: %s at %#3x, IRQ %d, ",\r\ndev->name, cardname, ioaddr, dev->irq);\r\neth16i_select_regbank(TRANSCEIVER_MODE_RB, ioaddr);\r\noutb(0x38, ioaddr + TRANSCEIVER_MODE_REG);\r\neth16i_initialize(dev, 1);\r\nBITCLR(ioaddr + CONFIG_REG_1, POWERUP);\r\ndev->netdev_ops = &eth16i_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nspin_lock_init(&lp->lock);\r\nretval = register_netdev(dev);\r\nif (retval)\r\ngoto out1;\r\nreturn 0;\r\nout1:\r\nfree_irq(dev->irq, dev);\r\nout:\r\nrelease_region(ioaddr, ETH16I_IO_EXTENT);\r\nreturn retval;\r\n}\r\nstatic void eth16i_initialize(struct net_device *dev, int boot)\r\n{\r\nint ioaddr = dev->base_addr;\r\nint i, node_w = 0;\r\nunsigned char node_byte = 0;\r\neth16i_select_regbank(NODE_ID_RB, ioaddr);\r\nfor(i = 0 ; i < 3 ; i++) {\r\nunsigned short node_val = eth16i_read_eeprom(ioaddr, E_NODEID_0 + i);\r\n((unsigned short *)dev->dev_addr)[i] = ntohs(node_val);\r\n}\r\nfor(i = 0; i < 6; i++) {\r\noutb( ((unsigned char *)dev->dev_addr)[i], ioaddr + NODE_ID_0 + i);\r\nif(boot) {\r\nprintk("%02x", inb(ioaddr + NODE_ID_0 + i));\r\nif(i != 5)\r\nprintk(":");\r\n}\r\n}\r\neth16i_select_regbank(HASH_TABLE_RB, ioaddr);\r\nfor(i = 0; i < 8; i++)\r\noutb(0x00, ioaddr + HASH_TABLE_0 + i);\r\neth16i_select_regbank(2, ioaddr);\r\nnode_byte = 0;\r\nnode_w = eth16i_read_eeprom(ioaddr, E_PRODUCT_CFG);\r\nif( (node_w & 0xFF00) == 0x0800)\r\nnode_byte |= BUFFER_WIDTH_8;\r\nnode_byte |= SRAM_BS1;\r\nif( (node_w & 0x00FF) == 64)\r\nnode_byte |= SRAM_BS0;\r\nnode_byte |= DLC_EN | SRAM_CYCLE_TIME_100NS | (ETH16I_TX_BUF_SIZE << 2);\r\noutb(node_byte, ioaddr + CONFIG_REG_0);\r\noutb(HALT_ON_16, ioaddr + COL_16_REG);\r\n#ifdef MODULE\r\n#else\r\ndev->if_port = (dev->mem_start < E_PORT_FROM_EPROM) ?\r\ndev->mem_start : E_PORT_FROM_EPROM;\r\n#endif\r\nif(boot) {\r\nstatic const char * const porttype[] = {\r\n"BNC", "DIX", "TP", "AUTO", "FROM_EPROM"\r\n};\r\nswitch(dev->if_port)\r\n{\r\ncase E_PORT_FROM_EPROM:\r\ndev->if_port = eth16i_read_eeprom(ioaddr, E_PORT_SELECT);\r\nbreak;\r\ncase E_PORT_AUTO:\r\ndev->if_port = eth16i_probe_port(ioaddr);\r\nbreak;\r\ncase E_PORT_BNC:\r\ncase E_PORT_TP:\r\ncase E_PORT_DIX:\r\nbreak;\r\n}\r\nprintk(" %s interface.\n", porttype[dev->if_port]);\r\neth16i_set_port(ioaddr, dev->if_port);\r\n}\r\noutb(MODE_2, ioaddr + RECEIVE_MODE_REG);\r\n}\r\nstatic int eth16i_probe_port(int ioaddr)\r\n{\r\nint i;\r\nint retcode;\r\nunsigned char dummy_packet[64];\r\noutb(0xc0 | POWERUP, ioaddr + CONFIG_REG_1);\r\nBITSET(ioaddr + CONFIG_REG_0, DLC_EN);\r\neth16i_select_regbank(NODE_ID_RB, ioaddr);\r\nfor(i = 0; i < 6; i++) {\r\ndummy_packet[i] = inb(ioaddr + NODE_ID_0 + i);\r\ndummy_packet[i+6] = inb(ioaddr + NODE_ID_0 + i);\r\n}\r\ndummy_packet[12] = 0x00;\r\ndummy_packet[13] = 0x04;\r\nmemset(dummy_packet + 14, 0, sizeof(dummy_packet) - 14);\r\neth16i_select_regbank(2, ioaddr);\r\nfor(i = 0; i < 3; i++) {\r\nBITSET(ioaddr + CONFIG_REG_0, DLC_EN);\r\nBITCLR(ioaddr + CONFIG_REG_0, DLC_EN);\r\neth16i_set_port(ioaddr, i);\r\nif(eth16i_debug > 1)\r\nprintk(KERN_DEBUG "Set port number %d\n", i);\r\nretcode = eth16i_send_probe_packet(ioaddr, dummy_packet, 64);\r\nif(retcode == 0) {\r\nretcode = eth16i_receive_probe_packet(ioaddr);\r\nif(retcode != -1) {\r\nif(eth16i_debug > 1)\r\nprintk(KERN_DEBUG "Eth16i interface port found at %d\n", i);\r\nreturn i;\r\n}\r\n}\r\nelse {\r\nif(eth16i_debug > 1)\r\nprintk(KERN_DEBUG "TRANSMIT_DONE timeout when probing interface port\n");\r\n}\r\n}\r\nif( eth16i_debug > 1)\r\nprintk(KERN_DEBUG "Using default port\n");\r\nreturn E_PORT_BNC;\r\n}\r\nstatic void eth16i_set_port(int ioaddr, int porttype)\r\n{\r\nunsigned short temp = 0;\r\neth16i_select_regbank(TRANSCEIVER_MODE_RB, ioaddr);\r\noutb(LOOPBACK_CONTROL, ioaddr + TRANSMIT_MODE_REG);\r\ntemp |= DIS_AUTO_PORT_SEL;\r\nswitch(porttype) {\r\ncase E_PORT_BNC :\r\ntemp |= AUI_SELECT;\r\nbreak;\r\ncase E_PORT_TP :\r\nbreak;\r\ncase E_PORT_DIX :\r\ntemp |= AUI_SELECT;\r\nBITSET(ioaddr + TRANSMIT_MODE_REG, CONTROL_OUTPUT);\r\nbreak;\r\n}\r\noutb(temp, ioaddr + TRANSCEIVER_MODE_REG);\r\nif(eth16i_debug > 1) {\r\nprintk(KERN_DEBUG "TRANSMIT_MODE_REG = %x\n", inb(ioaddr + TRANSMIT_MODE_REG));\r\nprintk(KERN_DEBUG "TRANSCEIVER_MODE_REG = %x\n",\r\ninb(ioaddr+TRANSCEIVER_MODE_REG));\r\n}\r\n}\r\nstatic int eth16i_send_probe_packet(int ioaddr, unsigned char *b, int l)\r\n{\r\nunsigned long starttime;\r\noutb(0xff, ioaddr + TX_STATUS_REG);\r\noutw(l, ioaddr + DATAPORT);\r\noutsw(ioaddr + DATAPORT, (unsigned short *)b, (l + 1) >> 1);\r\nstarttime = jiffies;\r\noutb(TX_START | 1, ioaddr + TRANSMIT_START_REG);\r\nwhile( (inb(ioaddr + TX_STATUS_REG) & 0x80) == 0) {\r\nif( time_after(jiffies, starttime + TX_TIMEOUT)) {\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int eth16i_receive_probe_packet(int ioaddr)\r\n{\r\nunsigned long starttime;\r\nstarttime = jiffies;\r\nwhile((inb(ioaddr + TX_STATUS_REG) & 0x20) == 0) {\r\nif( time_after(jiffies, starttime + TX_TIMEOUT)) {\r\nif(eth16i_debug > 1)\r\nprintk(KERN_DEBUG "Timeout occurred waiting transmit packet received\n");\r\nstarttime = jiffies;\r\nwhile((inb(ioaddr + RX_STATUS_REG) & 0x80) == 0) {\r\nif( time_after(jiffies, starttime + TX_TIMEOUT)) {\r\nif(eth16i_debug > 1)\r\nprintk(KERN_DEBUG "Timeout occurred waiting receive packet\n");\r\nreturn -1;\r\n}\r\n}\r\nif(eth16i_debug > 1)\r\nprintk(KERN_DEBUG "RECEIVE_PACKET\n");\r\nreturn 0;\r\n}\r\n}\r\nif(eth16i_debug > 1) {\r\nprintk(KERN_DEBUG "TRANSMIT_PACKET_RECEIVED %x\n", inb(ioaddr + TX_STATUS_REG));\r\nprintk(KERN_DEBUG "RX_STATUS_REG = %x\n", inb(ioaddr + RX_STATUS_REG));\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init eth16i_get_irq(int ioaddr)\r\n{\r\nunsigned char cbyte;\r\nif( ioaddr < 0x1000) {\r\ncbyte = inb(ioaddr + JUMPERLESS_CONFIG);\r\nreturn eth16i_irqmap[((cbyte & 0xC0) >> 6)];\r\n} else {\r\nunsigned short index = 0;\r\ncbyte = inb(ioaddr + EISA_IRQ_REG);\r\nwhile( (cbyte & 0x01) == 0) {\r\ncbyte = cbyte >> 1;\r\nindex++;\r\n}\r\nreturn eth32i_irqmap[index];\r\n}\r\n}\r\nstatic int __init eth16i_check_signature(int ioaddr)\r\n{\r\nint i;\r\nunsigned char creg[4] = { 0 };\r\nfor(i = 0; i < 4 ; i++) {\r\ncreg[i] = inb(ioaddr + TRANSMIT_MODE_REG + i);\r\nif(eth16i_debug > 1)\r\nprintk("eth16i: read signature byte %x at %x\n",\r\ncreg[i],\r\nioaddr + TRANSMIT_MODE_REG + i);\r\n}\r\ncreg[0] &= 0x0F;\r\ncreg[2] &= 0x7F;\r\n#if 0\r\nif( ! ((creg[0] == 0x06) && (creg[1] == 0x41)) ) {\r\nif(creg[1] != 0x42)\r\nreturn -1;\r\n}\r\n#endif\r\nif( !((creg[2] == 0x36) && (creg[3] == 0xE0)) ) {\r\ncreg[2] &= 0x40;\r\ncreg[3] &= 0x03;\r\nif( !((creg[2] == 0x40) && (creg[3] == 0x00)) )\r\nreturn -1;\r\n}\r\nif(eth16i_read_eeprom(ioaddr, E_NODEID_0) != 0)\r\nreturn -1;\r\nif((eth16i_read_eeprom(ioaddr, E_NODEID_1) & 0xFF00) != 0x4B00)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int eth16i_read_eeprom(int ioaddr, int offset)\r\n{\r\nint data = 0;\r\neth16i_eeprom_cmd(ioaddr, EEPROM_READ | offset);\r\noutb(CS_1, ioaddr + EEPROM_CTRL_REG);\r\ndata = eth16i_read_eeprom_word(ioaddr);\r\noutb(CS_0 | SK_0, ioaddr + EEPROM_CTRL_REG);\r\nreturn data;\r\n}\r\nstatic int eth16i_read_eeprom_word(int ioaddr)\r\n{\r\nint i;\r\nint data = 0;\r\nfor(i = 16; i > 0; i--) {\r\noutb(CS_1 | SK_0, ioaddr + EEPROM_CTRL_REG);\r\neeprom_slow_io();\r\noutb(CS_1 | SK_1, ioaddr + EEPROM_CTRL_REG);\r\neeprom_slow_io();\r\ndata = (data << 1) |\r\n((inb(ioaddr + EEPROM_DATA_REG) & DI_1) ? 1 : 0);\r\neeprom_slow_io();\r\n}\r\nreturn data;\r\n}\r\nstatic void eth16i_eeprom_cmd(int ioaddr, unsigned char command)\r\n{\r\nint i;\r\noutb(CS_0 | SK_0, ioaddr + EEPROM_CTRL_REG);\r\noutb(DI_0, ioaddr + EEPROM_DATA_REG);\r\noutb(CS_1 | SK_0, ioaddr + EEPROM_CTRL_REG);\r\noutb(DI_1, ioaddr + EEPROM_DATA_REG);\r\noutb(CS_1 | SK_1, ioaddr + EEPROM_CTRL_REG);\r\nfor(i = 7; i >= 0; i--) {\r\nshort cmd = ( (command & (1 << i)) ? DI_1 : DI_0 );\r\noutb(cmd, ioaddr + EEPROM_DATA_REG);\r\noutb(CS_1 | SK_0, ioaddr + EEPROM_CTRL_REG);\r\neeprom_slow_io();\r\noutb(CS_1 | SK_1, ioaddr + EEPROM_CTRL_REG);\r\neeprom_slow_io();\r\n}\r\n}\r\nstatic int eth16i_open(struct net_device *dev)\r\n{\r\nstruct eth16i_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\noutb(0xc0 | POWERUP, ioaddr + CONFIG_REG_1);\r\neth16i_initialize(dev, 0);\r\nlp->tx_buf_size = eth16i_tx_buf_map[ETH16I_TX_BUF_SIZE & 0x03];\r\nif(eth16i_debug > 0)\r\nprintk(KERN_DEBUG "%s: transmit buffer size %d\n",\r\ndev->name, lp->tx_buf_size);\r\nBITCLR(ioaddr + CONFIG_REG_0, DLC_EN);\r\neth16i_select_regbank(2, ioaddr);\r\nlp->open_time = jiffies;\r\nlp->tx_started = 0;\r\nlp->tx_queue = 0;\r\nlp->tx_queue_len = 0;\r\noutw(ETH16I_INTR_ON, ioaddr + TX_INTR_REG);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int eth16i_close(struct net_device *dev)\r\n{\r\nstruct eth16i_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\neth16i_reset(dev);\r\noutw(ETH16I_INTR_OFF, ioaddr + TX_INTR_REG);\r\nnetif_stop_queue(dev);\r\nlp->open_time = 0;\r\nBITSET(ioaddr + CONFIG_REG_0, DLC_EN);\r\noutb(0x00, ioaddr + CONFIG_REG_1);\r\nreturn 0;\r\n}\r\nstatic void eth16i_timeout(struct net_device *dev)\r\n{\r\nstruct eth16i_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\noutw(ETH16I_INTR_OFF, ioaddr + TX_INTR_REG);\r\nprintk(KERN_WARNING "%s: transmit timed out with status %04x, %s ?\n",\r\ndev->name,\r\ninw(ioaddr + TX_STATUS_REG), (inb(ioaddr + TX_STATUS_REG) & TX_DONE) ?\r\n"IRQ conflict" : "network cable problem");\r\ndev->trans_start = jiffies;\r\nif(eth16i_debug > 0) {\r\nprintk(KERN_DEBUG "%s: timeout: %02x %02x %02x %02x %02x %02x %02x %02x.\n",\r\ndev->name, inb(ioaddr + 0),\r\ninb(ioaddr + 1), inb(ioaddr + 2),\r\ninb(ioaddr + 3), inb(ioaddr + 4),\r\ninb(ioaddr + 5),\r\ninb(ioaddr + 6), inb(ioaddr + 7));\r\nprintk(KERN_DEBUG "%s: transmit start reg: %02x. collision reg %02x\n",\r\ndev->name, inb(ioaddr + TRANSMIT_START_REG),\r\ninb(ioaddr + COL_16_REG));\r\nprintk(KERN_DEBUG "lp->tx_queue = %d\n", lp->tx_queue);\r\nprintk(KERN_DEBUG "lp->tx_queue_len = %d\n", lp->tx_queue_len);\r\nprintk(KERN_DEBUG "lp->tx_started = %d\n", lp->tx_started);\r\n}\r\ndev->stats.tx_errors++;\r\neth16i_reset(dev);\r\ndev->trans_start = jiffies;\r\noutw(ETH16I_INTR_ON, ioaddr + TX_INTR_REG);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t eth16i_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct eth16i_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nint status = 0;\r\nushort length = skb->len;\r\nunsigned char *buf;\r\nunsigned long flags;\r\nif (length < ETH_ZLEN) {\r\nif (skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nlength = ETH_ZLEN;\r\n}\r\nbuf = skb->data;\r\nnetif_stop_queue(dev);\r\noutw(ETH16I_INTR_OFF, ioaddr + TX_INTR_REG);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif( (length + 2) > (lp->tx_buf_size - lp->tx_queue_len)) {\r\nif(eth16i_debug > 0)\r\nprintk(KERN_WARNING "%s: Transmit buffer full.\n", dev->name);\r\n}\r\nelse {\r\noutw(length, ioaddr + DATAPORT);\r\nif( ioaddr < 0x1000 )\r\noutsw(ioaddr + DATAPORT, buf, (length + 1) >> 1);\r\nelse {\r\nunsigned char frag = length % 4;\r\noutsl(ioaddr + DATAPORT, buf, length >> 2);\r\nif( frag != 0 ) {\r\noutsw(ioaddr + DATAPORT, (buf + (length & 0xFFFC)), 1);\r\nif( frag == 3 )\r\noutsw(ioaddr + DATAPORT,\r\n(buf + (length & 0xFFFC) + 2), 1);\r\n}\r\n}\r\nlp->tx_buffered_packets++;\r\nlp->tx_buffered_bytes = length;\r\nlp->tx_queue++;\r\nlp->tx_queue_len += length + 2;\r\n}\r\nlp->tx_buf_busy = 0;\r\nif(lp->tx_started == 0) {\r\noutb(TX_START | lp->tx_queue, ioaddr + TRANSMIT_START_REG);\r\nlp->tx_queue = 0;\r\nlp->tx_queue_len = 0;\r\nlp->tx_started = 1;\r\nnetif_wake_queue(dev);\r\n}\r\nelse if(lp->tx_queue_len < lp->tx_buf_size - (ETH_FRAME_LEN + 2)) {\r\nnetif_wake_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\noutw(ETH16I_INTR_ON, ioaddr + TX_INTR_REG);\r\nstatus = 0;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void eth16i_rx(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nint boguscount = MAX_RX_LOOP;\r\nwhile( (inb(ioaddr + RECEIVE_MODE_REG) & RX_BUFFER_EMPTY) == 0) {\r\nushort status = inw(ioaddr + DATAPORT);\r\nushort pkt_len = inw(ioaddr + DATAPORT);\r\nif(eth16i_debug > 4)\r\nprintk(KERN_DEBUG "%s: Receiving packet mode %02x status %04x.\n",\r\ndev->name,\r\ninb(ioaddr + RECEIVE_MODE_REG), status);\r\nif( !(status & PKT_GOOD) ) {\r\ndev->stats.rx_errors++;\r\nif( (pkt_len < ETH_ZLEN) || (pkt_len > ETH_FRAME_LEN) ) {\r\ndev->stats.rx_length_errors++;\r\neth16i_reset(dev);\r\nreturn;\r\n}\r\nelse {\r\neth16i_skip_packet(dev);\r\ndev->stats.rx_dropped++;\r\n}\r\n}\r\nelse {\r\nstruct sk_buff *skb;\r\nskb = dev_alloc_skb(pkt_len + 3);\r\nif( skb == NULL ) {\r\nprintk(KERN_WARNING "%s: Could'n allocate memory for packet (len %d)\n",\r\ndev->name, pkt_len);\r\neth16i_skip_packet(dev);\r\ndev->stats.rx_dropped++;\r\nbreak;\r\n}\r\nskb_reserve(skb,2);\r\nif(ioaddr < 0x1000)\r\ninsw(ioaddr + DATAPORT, skb_put(skb, pkt_len),\r\n(pkt_len + 1) >> 1);\r\nelse {\r\nunsigned char *buf = skb_put(skb, pkt_len);\r\nunsigned char frag = pkt_len % 4;\r\ninsl(ioaddr + DATAPORT, buf, pkt_len >> 2);\r\nif(frag != 0) {\r\nunsigned short rest[2];\r\nrest[0] = inw( ioaddr + DATAPORT );\r\nif(frag == 3)\r\nrest[1] = inw( ioaddr + DATAPORT );\r\nmemcpy(buf + (pkt_len & 0xfffc), (char *)rest, frag);\r\n}\r\n}\r\nskb->protocol=eth_type_trans(skb, dev);\r\nif( eth16i_debug > 5 ) {\r\nint i;\r\nprintk(KERN_DEBUG "%s: Received packet of length %d.\n",\r\ndev->name, pkt_len);\r\nfor(i = 0; i < 14; i++)\r\nprintk(KERN_DEBUG " %02x", skb->data[i]);\r\nprintk(KERN_DEBUG ".\n");\r\n}\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n}\r\nif(--boguscount <= 0)\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t eth16i_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct eth16i_local *lp;\r\nint ioaddr = 0, status;\r\nint handled = 0;\r\nioaddr = dev->base_addr;\r\nlp = netdev_priv(dev);\r\noutw(ETH16I_INTR_OFF, ioaddr + TX_INTR_REG);\r\nspin_lock(&lp->lock);\r\nstatus = inw(ioaddr + TX_STATUS_REG);\r\noutw(status, ioaddr + TX_STATUS_REG);\r\nif (status)\r\nhandled = 1;\r\nif(eth16i_debug > 3)\r\nprintk(KERN_DEBUG "%s: Interrupt with status %04x.\n", dev->name, status);\r\nif( status & 0x7f00 ) {\r\ndev->stats.rx_errors++;\r\nif(status & (BUS_RD_ERR << 8) )\r\nprintk(KERN_WARNING "%s: Bus read error.\n",dev->name);\r\nif(status & (SHORT_PKT_ERR << 8) ) dev->stats.rx_length_errors++;\r\nif(status & (ALIGN_ERR << 8) ) dev->stats.rx_frame_errors++;\r\nif(status & (CRC_ERR << 8) ) dev->stats.rx_crc_errors++;\r\nif(status & (RX_BUF_OVERFLOW << 8) ) dev->stats.rx_over_errors++;\r\n}\r\nif( status & 0x001a) {\r\ndev->stats.tx_errors++;\r\nif(status & CR_LOST) dev->stats.tx_carrier_errors++;\r\nif(status & TX_JABBER_ERR) dev->stats.tx_window_errors++;\r\n#if 0\r\nif(status & COLLISION) {\r\ndev->stats.collisions +=\r\n((inb(ioaddr+TRANSMIT_MODE_REG) & 0xF0) >> 4);\r\n}\r\n#endif\r\nif(status & COLLISIONS_16) {\r\nif(lp->col_16 < MAX_COL_16) {\r\nlp->col_16++;\r\ndev->stats.collisions++;\r\noutb(0x02, ioaddr + COL_16_REG);\r\n}\r\nelse {\r\nprintk(KERN_WARNING "%s: bailing out due to many consecutive 16-in-a-row collisions. Network cable problem?\n", dev->name);\r\n}\r\n}\r\n}\r\nif( status & 0x00ff ) {\r\nif(status & TX_DONE) {\r\ndev->stats.tx_packets = lp->tx_buffered_packets;\r\ndev->stats.tx_bytes += lp->tx_buffered_bytes;\r\nlp->col_16 = 0;\r\nif(lp->tx_queue) {\r\noutb(TX_START | lp->tx_queue, ioaddr + TRANSMIT_START_REG);\r\nlp->tx_queue = 0;\r\nlp->tx_queue_len = 0;\r\nlp->tx_started = 1;\r\n}\r\nelse {\r\nlp->tx_started = 0;\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nif( ( status & 0x8000 ) ||\r\n( (inb(ioaddr + RECEIVE_MODE_REG) & RX_BUFFER_EMPTY) == 0) ) {\r\neth16i_rx(dev);\r\n}\r\noutw(ETH16I_INTR_ON, ioaddr + TX_INTR_REG);\r\nif(lp->tx_queue_len < lp->tx_buf_size - (ETH_FRAME_LEN + 2)) {\r\nnetif_wake_queue(dev);\r\n}\r\nspin_unlock(&lp->lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void eth16i_skip_packet(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\ninw(ioaddr + DATAPORT);\r\ninw(ioaddr + DATAPORT);\r\ninw(ioaddr + DATAPORT);\r\noutb(SKIP_RX_PACKET, ioaddr + FILTER_SELF_RX_REG);\r\nwhile( inb( ioaddr + FILTER_SELF_RX_REG ) != 0);\r\n}\r\nstatic void eth16i_reset(struct net_device *dev)\r\n{\r\nstruct eth16i_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nif(eth16i_debug > 1)\r\nprintk(KERN_DEBUG "%s: Resetting device.\n", dev->name);\r\nBITSET(ioaddr + CONFIG_REG_0, DLC_EN);\r\noutw(0xffff, ioaddr + TX_STATUS_REG);\r\neth16i_select_regbank(2, ioaddr);\r\nlp->tx_started = 0;\r\nlp->tx_buf_busy = 0;\r\nlp->tx_queue = 0;\r\nlp->tx_queue_len = 0;\r\nBITCLR(ioaddr + CONFIG_REG_0, DLC_EN);\r\n}\r\nstatic void eth16i_multicast(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nif (!netdev_mc_empty(dev) || dev->flags&(IFF_ALLMULTI|IFF_PROMISC))\r\n{\r\noutb(3, ioaddr + RECEIVE_MODE_REG);\r\n} else {\r\noutb(2, ioaddr + RECEIVE_MODE_REG);\r\n}\r\n}\r\nstatic void eth16i_select_regbank(unsigned char banknbr, int ioaddr)\r\n{\r\nunsigned char data;\r\ndata = inb(ioaddr + CONFIG_REG_1);\r\noutb( ((data & 0xF3) | ( (banknbr & 0x03) << 2)), ioaddr + CONFIG_REG_1);\r\n}\r\nstatic ushort eth16i_parse_mediatype(const char* s)\r\n{\r\nif(!s)\r\nreturn E_PORT_FROM_EPROM;\r\nif (!strncmp(s, "bnc", 3))\r\nreturn E_PORT_BNC;\r\nelse if (!strncmp(s, "tp", 2))\r\nreturn E_PORT_TP;\r\nelse if (!strncmp(s, "dix", 3))\r\nreturn E_PORT_DIX;\r\nelse if (!strncmp(s, "auto", 4))\r\nreturn E_PORT_AUTO;\r\nelse\r\nreturn E_PORT_FROM_EPROM;\r\n}\r\nint __init init_module(void)\r\n{\r\nint this_dev, found = 0;\r\nstruct net_device *dev;\r\nfor (this_dev = 0; this_dev < MAX_ETH16I_CARDS; this_dev++) {\r\ndev = alloc_etherdev(sizeof(struct eth16i_local));\r\nif (!dev)\r\nbreak;\r\ndev->base_addr = io[this_dev];\r\nif(debug != -1)\r\neth16i_debug = debug;\r\nif(eth16i_debug > 1)\r\nprintk(KERN_NOTICE "eth16i(%d): interface type %s\n", this_dev, mediatype[this_dev] ? mediatype[this_dev] : "none" );\r\ndev->if_port = eth16i_parse_mediatype(mediatype[this_dev]);\r\nif(io[this_dev] == 0) {\r\nif (this_dev != 0) {\r\nfree_netdev(dev);\r\nbreak;\r\n}\r\nprintk(KERN_NOTICE "eth16i.c: Presently autoprobing (not recommended) for a single card.\n");\r\n}\r\nif (do_eth16i_probe(dev) == 0) {\r\ndev_eth16i[found++] = dev;\r\ncontinue;\r\n}\r\nprintk(KERN_WARNING "eth16i.c No Eth16i card found (i/o = 0x%x).\n",\r\nio[this_dev]);\r\nfree_netdev(dev);\r\nbreak;\r\n}\r\nif (found)\r\nreturn 0;\r\nreturn -ENXIO;\r\n}\r\nvoid __exit cleanup_module(void)\r\n{\r\nint this_dev;\r\nfor(this_dev = 0; this_dev < MAX_ETH16I_CARDS; this_dev++) {\r\nstruct net_device *dev = dev_eth16i[this_dev];\r\nif (netdev_priv(dev)) {\r\nunregister_netdev(dev);\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->base_addr, ETH16I_IO_EXTENT);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}
