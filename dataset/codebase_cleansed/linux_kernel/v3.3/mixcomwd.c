static void mixcomwd_ping(void)\r\n{\r\noutb_p(55, watchdog_port);\r\nreturn;\r\n}\r\nstatic void mixcomwd_timerfun(unsigned long d)\r\n{\r\nmixcomwd_ping();\r\nmod_timer(&mixcomwd_timer, jiffies + 5 * HZ);\r\n}\r\nstatic int mixcomwd_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &mixcomwd_opened))\r\nreturn -EBUSY;\r\nmixcomwd_ping();\r\nif (nowayout)\r\n__module_get(THIS_MODULE);\r\nelse {\r\nif (mixcomwd_timer_alive) {\r\ndel_timer(&mixcomwd_timer);\r\nmixcomwd_timer_alive = 0;\r\n}\r\n}\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int mixcomwd_release(struct inode *inode, struct file *file)\r\n{\r\nif (expect_close == 42) {\r\nif (mixcomwd_timer_alive) {\r\nprintk(KERN_ERR PFX\r\n"release called while internal timer alive");\r\nreturn -EBUSY;\r\n}\r\nmixcomwd_timer_alive = 1;\r\nmod_timer(&mixcomwd_timer, jiffies + 5 * HZ);\r\n} else\r\nprintk(KERN_CRIT PFX\r\n"WDT device closed unexpectedly. WDT will not stop!\n");\r\nclear_bit(0, &mixcomwd_opened);\r\nexpect_close = 0;\r\nreturn 0;\r\n}\r\nstatic ssize_t mixcomwd_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_close = 0;\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_close = 42;\r\n}\r\n}\r\nmixcomwd_ping();\r\n}\r\nreturn len;\r\n}\r\nstatic long mixcomwd_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nint status;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\r\n.firmware_version = 1,\r\n.identity = "MixCOM watchdog",\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user(argp, &ident, sizeof(ident)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\nstatus = mixcomwd_opened;\r\nif (!nowayout)\r\nstatus |= mixcomwd_timer_alive;\r\nreturn put_user(status, p);\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_KEEPALIVE:\r\nmixcomwd_ping();\r\nbreak;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init checkcard(int port, int card_id)\r\n{\r\nint id;\r\nif (!request_region(port, 1, "MixCOM watchdog"))\r\nreturn 0;\r\nid = inb_p(port);\r\nif (card_id == MIXCOM_ID)\r\nid &= 0x3f;\r\nif (id != card_id) {\r\nrelease_region(port, 1);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init mixcomwd_init(void)\r\n{\r\nint i, ret, found = 0;\r\nfor (i = 0; !found && mixcomwd_io_info[i].ioport != 0; i++) {\r\nif (checkcard(mixcomwd_io_info[i].ioport,\r\nmixcomwd_io_info[i].id)) {\r\nfound = 1;\r\nwatchdog_port = mixcomwd_io_info[i].ioport;\r\n}\r\n}\r\nif (!found) {\r\nprintk(KERN_ERR PFX\r\n"No card detected, or port not available.\n");\r\nreturn -ENODEV;\r\n}\r\nret = misc_register(&mixcomwd_miscdev);\r\nif (ret) {\r\nprintk(KERN_ERR PFX\r\n"cannot register miscdev on minor=%d (err=%d)\n",\r\nWATCHDOG_MINOR, ret);\r\ngoto error_misc_register_watchdog;\r\n}\r\nprintk(KERN_INFO\r\n"MixCOM watchdog driver v%s, watchdog port at 0x%3x\n",\r\nVERSION, watchdog_port);\r\nreturn 0;\r\nerror_misc_register_watchdog:\r\nrelease_region(watchdog_port, 1);\r\nwatchdog_port = 0x0000;\r\nreturn ret;\r\n}\r\nstatic void __exit mixcomwd_exit(void)\r\n{\r\nif (!nowayout) {\r\nif (mixcomwd_timer_alive) {\r\nprintk(KERN_WARNING PFX "I quit now, hardware will"\r\n" probably reboot!\n");\r\ndel_timer_sync(&mixcomwd_timer);\r\nmixcomwd_timer_alive = 0;\r\n}\r\n}\r\nmisc_deregister(&mixcomwd_miscdev);\r\nrelease_region(watchdog_port, 1);\r\n}
