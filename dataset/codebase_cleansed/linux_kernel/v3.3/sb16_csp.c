int snd_sb_csp_new(struct snd_sb *chip, int device, struct snd_hwdep ** rhwdep)\r\n{\r\nstruct snd_sb_csp *p;\r\nint uninitialized_var(version);\r\nint err;\r\nstruct snd_hwdep *hw;\r\nif (rhwdep)\r\n*rhwdep = NULL;\r\nif (csp_detect(chip, &version))\r\nreturn -ENODEV;\r\nif ((err = snd_hwdep_new(chip->card, "SB16-CSP", device, &hw)) < 0)\r\nreturn err;\r\nif ((p = kzalloc(sizeof(*p), GFP_KERNEL)) == NULL) {\r\nsnd_device_free(chip->card, hw);\r\nreturn -ENOMEM;\r\n}\r\np->chip = chip;\r\np->version = version;\r\np->ops.csp_use = snd_sb_csp_use;\r\np->ops.csp_unuse = snd_sb_csp_unuse;\r\np->ops.csp_autoload = snd_sb_csp_autoload;\r\np->ops.csp_start = snd_sb_csp_start;\r\np->ops.csp_stop = snd_sb_csp_stop;\r\np->ops.csp_qsound_transfer = snd_sb_csp_qsound_transfer;\r\nmutex_init(&p->access_mutex);\r\nsprintf(hw->name, "CSP v%d.%d", (version >> 4), (version & 0x0f));\r\nhw->iface = SNDRV_HWDEP_IFACE_SB16CSP;\r\nhw->private_data = p;\r\nhw->private_free = snd_sb_csp_free;\r\nhw->ops.open = snd_sb_csp_open;\r\nhw->ops.ioctl = snd_sb_csp_ioctl;\r\nhw->ops.release = snd_sb_csp_release;\r\ninit_proc_entry(p, device);\r\nif (rhwdep)\r\n*rhwdep = hw;\r\nreturn 0;\r\n}\r\nstatic void snd_sb_csp_free(struct snd_hwdep *hwdep)\r\n{\r\nint i;\r\nstruct snd_sb_csp *p = hwdep->private_data;\r\nif (p) {\r\nif (p->running & SNDRV_SB_CSP_ST_RUNNING)\r\nsnd_sb_csp_stop(p);\r\nfor (i = 0; i < ARRAY_SIZE(p->csp_programs); ++i)\r\nrelease_firmware(p->csp_programs[i]);\r\nkfree(p);\r\n}\r\n}\r\nstatic int snd_sb_csp_open(struct snd_hwdep * hw, struct file *file)\r\n{\r\nstruct snd_sb_csp *p = hw->private_data;\r\nreturn (snd_sb_csp_use(p));\r\n}\r\nstatic int snd_sb_csp_ioctl(struct snd_hwdep * hw, struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct snd_sb_csp *p = hw->private_data;\r\nstruct snd_sb_csp_info info;\r\nstruct snd_sb_csp_start start_info;\r\nint err;\r\nif (snd_BUG_ON(!p))\r\nreturn -EINVAL;\r\nif (snd_sb_csp_check_version(p))\r\nreturn -ENODEV;\r\nswitch (cmd) {\r\ncase SNDRV_SB_CSP_IOCTL_INFO:\r\n*info.codec_name = *p->codec_name;\r\ninfo.func_nr = p->func_nr;\r\ninfo.acc_format = p->acc_format;\r\ninfo.acc_channels = p->acc_channels;\r\ninfo.acc_width = p->acc_width;\r\ninfo.acc_rates = p->acc_rates;\r\ninfo.csp_mode = p->mode;\r\ninfo.run_channels = p->run_channels;\r\ninfo.run_width = p->run_width;\r\ninfo.version = p->version;\r\ninfo.state = p->running;\r\nif (copy_to_user((void __user *)arg, &info, sizeof(info)))\r\nerr = -EFAULT;\r\nelse\r\nerr = 0;\r\nbreak;\r\ncase SNDRV_SB_CSP_IOCTL_LOAD_CODE:\r\nerr = (p->running & SNDRV_SB_CSP_ST_RUNNING ?\r\n-EBUSY : snd_sb_csp_riff_load(p, (struct snd_sb_csp_microcode __user *) arg));\r\nbreak;\r\ncase SNDRV_SB_CSP_IOCTL_UNLOAD_CODE:\r\nerr = (p->running & SNDRV_SB_CSP_ST_RUNNING ?\r\n-EBUSY : snd_sb_csp_unload(p));\r\nbreak;\r\ncase SNDRV_SB_CSP_IOCTL_START:\r\nif (copy_from_user(&start_info, (void __user *) arg, sizeof(start_info)))\r\nerr = -EFAULT;\r\nelse\r\nerr = snd_sb_csp_start(p, start_info.sample_width, start_info.channels);\r\nbreak;\r\ncase SNDRV_SB_CSP_IOCTL_STOP:\r\nerr = snd_sb_csp_stop(p);\r\nbreak;\r\ncase SNDRV_SB_CSP_IOCTL_PAUSE:\r\nerr = snd_sb_csp_pause(p);\r\nbreak;\r\ncase SNDRV_SB_CSP_IOCTL_RESTART:\r\nerr = snd_sb_csp_restart(p);\r\nbreak;\r\ndefault:\r\nerr = -ENOTTY;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int snd_sb_csp_release(struct snd_hwdep * hw, struct file *file)\r\n{\r\nstruct snd_sb_csp *p = hw->private_data;\r\nreturn (snd_sb_csp_unuse(p));\r\n}\r\nstatic int snd_sb_csp_use(struct snd_sb_csp * p)\r\n{\r\nmutex_lock(&p->access_mutex);\r\nif (p->used) {\r\nmutex_unlock(&p->access_mutex);\r\nreturn -EAGAIN;\r\n}\r\np->used++;\r\nmutex_unlock(&p->access_mutex);\r\nreturn 0;\r\n}\r\nstatic int snd_sb_csp_unuse(struct snd_sb_csp * p)\r\n{\r\nmutex_lock(&p->access_mutex);\r\np->used--;\r\nmutex_unlock(&p->access_mutex);\r\nreturn 0;\r\n}\r\nstatic int snd_sb_csp_riff_load(struct snd_sb_csp * p,\r\nstruct snd_sb_csp_microcode __user * mcode)\r\n{\r\nstruct snd_sb_csp_mc_header info;\r\nunsigned char __user *data_ptr;\r\nunsigned char __user *data_end;\r\nunsigned short func_nr = 0;\r\nstruct riff_header file_h, item_h, code_h;\r\n__u32 item_type;\r\nstruct desc_header funcdesc_h;\r\nunsigned long flags;\r\nint err;\r\nif (copy_from_user(&info, mcode, sizeof(info)))\r\nreturn -EFAULT;\r\ndata_ptr = mcode->data;\r\nif (copy_from_user(&file_h, data_ptr, sizeof(file_h)))\r\nreturn -EFAULT;\r\nif ((file_h.name != RIFF_HEADER) ||\r\n(le32_to_cpu(file_h.len) >= SNDRV_SB_CSP_MAX_MICROCODE_FILE_SIZE - sizeof(file_h))) {\r\nsnd_printd("%s: Invalid RIFF header\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndata_ptr += sizeof(file_h);\r\ndata_end = data_ptr + le32_to_cpu(file_h.len);\r\nif (copy_from_user(&item_type, data_ptr, sizeof(item_type)))\r\nreturn -EFAULT;\r\nif (item_type != CSP__HEADER) {\r\nsnd_printd("%s: Invalid RIFF file type\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndata_ptr += sizeof (item_type);\r\nfor (; data_ptr < data_end; data_ptr += le32_to_cpu(item_h.len)) {\r\nif (copy_from_user(&item_h, data_ptr, sizeof(item_h)))\r\nreturn -EFAULT;\r\ndata_ptr += sizeof(item_h);\r\nif (item_h.name != LIST_HEADER)\r\ncontinue;\r\nif (copy_from_user(&item_type, data_ptr, sizeof(item_type)))\r\nreturn -EFAULT;\r\nswitch (item_type) {\r\ncase FUNC_HEADER:\r\nif (copy_from_user(&funcdesc_h, data_ptr + sizeof(item_type), sizeof(funcdesc_h)))\r\nreturn -EFAULT;\r\nfunc_nr = le16_to_cpu(funcdesc_h.func_nr);\r\nbreak;\r\ncase CODE_HEADER:\r\nif (func_nr != info.func_req)\r\nbreak;\r\ndata_ptr += sizeof(item_type);\r\nif (p->mode == SNDRV_SB_CSP_MODE_QSOUND) {\r\nsnd_sb_qsound_destroy(p);\r\n}\r\np->running = 0;\r\np->mode = 0;\r\nfor (;;) {\r\nif (data_ptr >= data_end)\r\nreturn -EINVAL;\r\nif (copy_from_user(&code_h, data_ptr, sizeof(code_h)))\r\nreturn -EFAULT;\r\nif (code_h.name != INIT_HEADER)\r\nbreak;\r\ndata_ptr += sizeof(code_h);\r\nerr = snd_sb_csp_load_user(p, data_ptr, le32_to_cpu(code_h.len),\r\nSNDRV_SB_CSP_LOAD_INITBLOCK);\r\nif (err)\r\nreturn err;\r\ndata_ptr += le32_to_cpu(code_h.len);\r\n}\r\nif (copy_from_user(&code_h, data_ptr, sizeof(code_h)))\r\nreturn -EFAULT;\r\nif (code_h.name != MAIN_HEADER) {\r\nsnd_printd("%s: Missing 'main' microcode\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndata_ptr += sizeof(code_h);\r\nerr = snd_sb_csp_load_user(p, data_ptr,\r\nle32_to_cpu(code_h.len), 0);\r\nif (err)\r\nreturn err;\r\nstrlcpy(p->codec_name, info.codec_name, sizeof(p->codec_name));\r\np->func_nr = func_nr;\r\np->mode = le16_to_cpu(funcdesc_h.flags_play_rec);\r\nswitch (le16_to_cpu(funcdesc_h.VOC_type)) {\r\ncase 0x0001:\r\nif (le16_to_cpu(funcdesc_h.flags_play_rec) == SNDRV_SB_CSP_MODE_DSP_WRITE) {\r\nif (snd_sb_qsound_build(p) == 0)\r\np->mode = SNDRV_SB_CSP_MODE_QSOUND;\r\n}\r\np->acc_format = 0;\r\nbreak;\r\ncase 0x0006:\r\np->acc_format = SNDRV_PCM_FMTBIT_A_LAW;\r\nbreak;\r\ncase 0x0007:\r\np->acc_format = SNDRV_PCM_FMTBIT_MU_LAW;\r\nbreak;\r\ncase 0x0011:\r\ncase 0x0200:\r\np->acc_format = SNDRV_PCM_FMTBIT_IMA_ADPCM;\r\nbreak;\r\ncase 201:\r\np->acc_format = 0;\r\nbreak;\r\ncase 0x0202:\r\ncase 0x0203:\r\np->acc_format = SNDRV_PCM_FMTBIT_SPECIAL;\r\nbreak;\r\ndefault:\r\np->acc_format = p->acc_width = p->acc_rates = 0;\r\np->mode = 0;\r\nsnd_printd("%s: Unsupported CSP codec type: 0x%04x\n",\r\n__func__,\r\nle16_to_cpu(funcdesc_h.VOC_type));\r\nreturn -EINVAL;\r\n}\r\np->acc_channels = le16_to_cpu(funcdesc_h.flags_stereo_mono);\r\np->acc_width = le16_to_cpu(funcdesc_h.flags_16bit_8bit);\r\np->acc_rates = le16_to_cpu(funcdesc_h.flags_rates);\r\nspin_lock_irqsave(&p->chip->reg_lock, flags);\r\nset_mode_register(p->chip, 0xfc);\r\nset_mode_register(p->chip, 0x00);\r\nspin_unlock_irqrestore(&p->chip->reg_lock, flags);\r\np->running = SNDRV_SB_CSP_ST_LOADED;\r\nreturn 0;\r\n}\r\n}\r\nsnd_printd("%s: Function #%d not found\n", __func__, info.func_req);\r\nreturn -EINVAL;\r\n}\r\nstatic int snd_sb_csp_unload(struct snd_sb_csp * p)\r\n{\r\nif (p->running & SNDRV_SB_CSP_ST_RUNNING)\r\nreturn -EBUSY;\r\nif (!(p->running & SNDRV_SB_CSP_ST_LOADED))\r\nreturn -ENXIO;\r\np->acc_format = 0;\r\np->acc_channels = p->acc_width = p->acc_rates = 0;\r\nif (p->mode == SNDRV_SB_CSP_MODE_QSOUND) {\r\nsnd_sb_qsound_destroy(p);\r\n}\r\np->running = 0;\r\np->mode = 0;\r\nreturn 0;\r\n}\r\nstatic inline int command_seq(struct snd_sb *chip, const unsigned char *seq, int size)\r\n{\r\nint i;\r\nfor (i = 0; i < size; i++) {\r\nif (!snd_sbdsp_command(chip, seq[i]))\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_codec_parameter(struct snd_sb *chip, unsigned char par, unsigned char val)\r\n{\r\nunsigned char dsp_cmd[3];\r\ndsp_cmd[0] = 0x05;\r\ndsp_cmd[1] = val;\r\ndsp_cmd[2] = par;\r\ncommand_seq(chip, dsp_cmd, 3);\r\nsnd_sbdsp_command(chip, 0x03);\r\nif (snd_sbdsp_get_byte(chip) != par)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int set_register(struct snd_sb *chip, unsigned char reg, unsigned char val)\r\n{\r\nunsigned char dsp_cmd[3];\r\ndsp_cmd[0] = 0x0e;\r\ndsp_cmd[1] = reg;\r\ndsp_cmd[2] = val;\r\nreturn command_seq(chip, dsp_cmd, 3);\r\n}\r\nstatic int read_register(struct snd_sb *chip, unsigned char reg)\r\n{\r\nunsigned char dsp_cmd[2];\r\ndsp_cmd[0] = 0x0f;\r\ndsp_cmd[1] = reg;\r\ncommand_seq(chip, dsp_cmd, 2);\r\nreturn snd_sbdsp_get_byte(chip);\r\n}\r\nstatic int set_mode_register(struct snd_sb *chip, unsigned char mode)\r\n{\r\nunsigned char dsp_cmd[2];\r\ndsp_cmd[0] = 0x04;\r\ndsp_cmd[1] = mode;\r\nreturn command_seq(chip, dsp_cmd, 2);\r\n}\r\nstatic int csp_detect(struct snd_sb *chip, int *version)\r\n{\r\nunsigned char csp_test1, csp_test2;\r\nunsigned long flags;\r\nint result = -ENODEV;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nset_codec_parameter(chip, 0x00, 0x00);\r\nset_mode_register(chip, 0xfc);\r\ncsp_test1 = read_register(chip, 0x83);\r\nset_register(chip, 0x83, ~csp_test1);\r\ncsp_test2 = read_register(chip, 0x83);\r\nif (csp_test2 != (csp_test1 ^ 0xff))\r\ngoto __fail;\r\nset_register(chip, 0x83, csp_test1);\r\ncsp_test2 = read_register(chip, 0x83);\r\nif (csp_test2 != csp_test1)\r\ngoto __fail;\r\nset_mode_register(chip, 0x00);\r\n*version = get_version(chip);\r\nsnd_sbdsp_reset(chip);\r\nif (*version >= 0x10 && *version <= 0x1f)\r\nresult = 0;\r\n__fail:\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn result;\r\n}\r\nstatic int get_version(struct snd_sb *chip)\r\n{\r\nunsigned char dsp_cmd[2];\r\ndsp_cmd[0] = 0x08;\r\ndsp_cmd[1] = 0x03;\r\ncommand_seq(chip, dsp_cmd, 2);\r\nreturn (snd_sbdsp_get_byte(chip));\r\n}\r\nstatic int snd_sb_csp_check_version(struct snd_sb_csp * p)\r\n{\r\nif (p->version < 0x10 || p->version > 0x1f) {\r\nsnd_printd("%s: Invalid CSP version: 0x%x\n", __func__, p->version);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_sb_csp_load(struct snd_sb_csp * p, const unsigned char *buf, int size, int load_flags)\r\n{\r\nint status, i;\r\nint err;\r\nint result = -EIO;\r\nunsigned long flags;\r\nspin_lock_irqsave(&p->chip->reg_lock, flags);\r\nsnd_sbdsp_command(p->chip, 0x01);\r\nif (snd_sbdsp_get_byte(p->chip)) {\r\nsnd_printd("%s: Download command failed\n", __func__);\r\ngoto __fail;\r\n}\r\nsnd_sbdsp_command(p->chip, (unsigned char)(size - 1));\r\nsnd_sbdsp_command(p->chip, (unsigned char)((size - 1) >> 8));\r\nwhile (size--) {\r\nif (!snd_sbdsp_command(p->chip, *buf++))\r\ngoto __fail;\r\n}\r\nif (snd_sbdsp_get_byte(p->chip))\r\ngoto __fail;\r\nif (load_flags & SNDRV_SB_CSP_LOAD_INITBLOCK) {\r\ni = 0;\r\nwhile (1) {\r\nsnd_sbdsp_command(p->chip, 0x03);\r\nstatus = snd_sbdsp_get_byte(p->chip);\r\nif (status == 0x55 || ++i >= 10)\r\nbreak;\r\nudelay (10);\r\n}\r\nif (status != 0x55) {\r\nsnd_printd("%s: Microcode initialization failed\n", __func__);\r\ngoto __fail;\r\n}\r\n} else {\r\nspin_lock(&p->chip->mixer_lock);\r\nstatus = snd_sbmixer_read(p->chip, SB_DSP4_DMASETUP);\r\nspin_unlock(&p->chip->mixer_lock);\r\nif (!(status & (SB_DMASETUP_DMA7 | SB_DMASETUP_DMA6 | SB_DMASETUP_DMA5))) {\r\nerr = (set_codec_parameter(p->chip, 0xaa, 0x00) ||\r\nset_codec_parameter(p->chip, 0xff, 0x00));\r\nsnd_sbdsp_reset(p->chip);\r\nif (err)\r\ngoto __fail;\r\nset_mode_register(p->chip, 0xc0);\r\nset_mode_register(p->chip, 0x70);\r\n}\r\n}\r\nresult = 0;\r\n__fail:\r\nspin_unlock_irqrestore(&p->chip->reg_lock, flags);\r\nreturn result;\r\n}\r\nstatic int snd_sb_csp_load_user(struct snd_sb_csp * p, const unsigned char __user *buf, int size, int load_flags)\r\n{\r\nint err;\r\nunsigned char *kbuf;\r\nkbuf = memdup_user(buf, size);\r\nif (IS_ERR(kbuf))\r\nreturn PTR_ERR(kbuf);\r\nerr = snd_sb_csp_load(p, kbuf, size, load_flags);\r\nkfree(kbuf);\r\nreturn err;\r\n}\r\nstatic int snd_sb_csp_firmware_load(struct snd_sb_csp *p, int index, int flags)\r\n{\r\nstatic const char *const names[] = {\r\n"sb16/mulaw_main.csp",\r\n"sb16/alaw_main.csp",\r\n"sb16/ima_adpcm_init.csp",\r\n"sb16/ima_adpcm_playback.csp",\r\n"sb16/ima_adpcm_capture.csp",\r\n};\r\nconst struct firmware *program;\r\nBUILD_BUG_ON(ARRAY_SIZE(names) != CSP_PROGRAM_COUNT);\r\nprogram = p->csp_programs[index];\r\nif (!program) {\r\nint err = request_firmware(&program, names[index],\r\np->chip->card->dev);\r\nif (err < 0)\r\nreturn err;\r\np->csp_programs[index] = program;\r\n}\r\nreturn snd_sb_csp_load(p, program->data, program->size, flags);\r\n}\r\nstatic int snd_sb_csp_autoload(struct snd_sb_csp * p, int pcm_sfmt, int play_rec_mode)\r\n{\r\nunsigned long flags;\r\nint err = 0;\r\nif (p->running & (SNDRV_SB_CSP_ST_RUNNING | SNDRV_SB_CSP_ST_LOADED))\r\nreturn -EBUSY;\r\nif (((1 << pcm_sfmt) & p->acc_format) && (play_rec_mode & p->mode)) {\r\np->running = SNDRV_SB_CSP_ST_AUTO;\r\n} else {\r\nswitch (pcm_sfmt) {\r\ncase SNDRV_PCM_FORMAT_MU_LAW:\r\nerr = snd_sb_csp_firmware_load(p, CSP_PROGRAM_MULAW, 0);\r\np->acc_format = SNDRV_PCM_FMTBIT_MU_LAW;\r\np->mode = SNDRV_SB_CSP_MODE_DSP_READ | SNDRV_SB_CSP_MODE_DSP_WRITE;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_A_LAW:\r\nerr = snd_sb_csp_firmware_load(p, CSP_PROGRAM_ALAW, 0);\r\np->acc_format = SNDRV_PCM_FMTBIT_A_LAW;\r\np->mode = SNDRV_SB_CSP_MODE_DSP_READ | SNDRV_SB_CSP_MODE_DSP_WRITE;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_IMA_ADPCM:\r\nerr = snd_sb_csp_firmware_load(p, CSP_PROGRAM_ADPCM_INIT,\r\nSNDRV_SB_CSP_LOAD_INITBLOCK);\r\nif (err)\r\nbreak;\r\nif (play_rec_mode == SNDRV_SB_CSP_MODE_DSP_WRITE) {\r\nerr = snd_sb_csp_firmware_load\r\n(p, CSP_PROGRAM_ADPCM_PLAYBACK, 0);\r\np->mode = SNDRV_SB_CSP_MODE_DSP_WRITE;\r\n} else {\r\nerr = snd_sb_csp_firmware_load\r\n(p, CSP_PROGRAM_ADPCM_CAPTURE, 0);\r\np->mode = SNDRV_SB_CSP_MODE_DSP_READ;\r\n}\r\np->acc_format = SNDRV_PCM_FMTBIT_IMA_ADPCM;\r\nbreak;\r\ndefault:\r\nif (p->running & SNDRV_SB_CSP_ST_AUTO) {\r\nspin_lock_irqsave(&p->chip->reg_lock, flags);\r\nset_mode_register(p->chip, 0xfc);\r\nset_mode_register(p->chip, 0x00);\r\nspin_unlock_irqrestore(&p->chip->reg_lock, flags);\r\np->running = 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nif (err) {\r\np->acc_format = 0;\r\np->acc_channels = p->acc_width = p->acc_rates = 0;\r\np->running = 0;\r\np->mode = 0;\r\nreturn (err);\r\n} else {\r\np->running = SNDRV_SB_CSP_ST_AUTO;\r\np->acc_width = SNDRV_SB_CSP_SAMPLE_16BIT;\r\np->acc_channels = SNDRV_SB_CSP_MONO | SNDRV_SB_CSP_STEREO;\r\np->acc_rates = SNDRV_SB_CSP_RATE_ALL;\r\n}\r\n}\r\nreturn (p->running & SNDRV_SB_CSP_ST_AUTO) ? 0 : -ENXIO;\r\n}\r\nstatic int snd_sb_csp_start(struct snd_sb_csp * p, int sample_width, int channels)\r\n{\r\nunsigned char s_type;\r\nunsigned char mixL, mixR;\r\nint result = -EIO;\r\nunsigned long flags;\r\nif (!(p->running & (SNDRV_SB_CSP_ST_LOADED | SNDRV_SB_CSP_ST_AUTO))) {\r\nsnd_printd("%s: Microcode not loaded\n", __func__);\r\nreturn -ENXIO;\r\n}\r\nif (p->running & SNDRV_SB_CSP_ST_RUNNING) {\r\nsnd_printd("%s: CSP already running\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nif (!(sample_width & p->acc_width)) {\r\nsnd_printd("%s: Unsupported PCM sample width\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (!(channels & p->acc_channels)) {\r\nsnd_printd("%s: Invalid number of channels\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&p->chip->mixer_lock, flags);\r\nmixL = snd_sbmixer_read(p->chip, SB_DSP4_PCM_DEV);\r\nmixR = snd_sbmixer_read(p->chip, SB_DSP4_PCM_DEV + 1);\r\nsnd_sbmixer_write(p->chip, SB_DSP4_PCM_DEV, mixL & 0x7);\r\nsnd_sbmixer_write(p->chip, SB_DSP4_PCM_DEV + 1, mixR & 0x7);\r\nspin_lock(&p->chip->reg_lock);\r\nset_mode_register(p->chip, 0xc0);\r\nset_mode_register(p->chip, 0x70);\r\ns_type = 0x00;\r\nif (channels == SNDRV_SB_CSP_MONO)\r\ns_type = 0x11;\r\nif (sample_width == SNDRV_SB_CSP_SAMPLE_8BIT)\r\ns_type |= 0x22;\r\nif (set_codec_parameter(p->chip, 0x81, s_type)) {\r\nsnd_printd("%s: Set sample type command failed\n", __func__);\r\ngoto __fail;\r\n}\r\nif (set_codec_parameter(p->chip, 0x80, 0x00)) {\r\nsnd_printd("%s: Codec start command failed\n", __func__);\r\ngoto __fail;\r\n}\r\np->run_width = sample_width;\r\np->run_channels = channels;\r\np->running |= SNDRV_SB_CSP_ST_RUNNING;\r\nif (p->mode & SNDRV_SB_CSP_MODE_QSOUND) {\r\nset_codec_parameter(p->chip, 0xe0, 0x01);\r\nset_codec_parameter(p->chip, 0x00, 0xff);\r\nset_codec_parameter(p->chip, 0x01, 0xff);\r\np->running |= SNDRV_SB_CSP_ST_QSOUND;\r\nsnd_sb_csp_qsound_transfer(p);\r\n}\r\nresult = 0;\r\n__fail:\r\nspin_unlock(&p->chip->reg_lock);\r\nsnd_sbmixer_write(p->chip, SB_DSP4_PCM_DEV, mixL);\r\nsnd_sbmixer_write(p->chip, SB_DSP4_PCM_DEV + 1, mixR);\r\nspin_unlock_irqrestore(&p->chip->mixer_lock, flags);\r\nreturn result;\r\n}\r\nstatic int snd_sb_csp_stop(struct snd_sb_csp * p)\r\n{\r\nint result;\r\nunsigned char mixL, mixR;\r\nunsigned long flags;\r\nif (!(p->running & SNDRV_SB_CSP_ST_RUNNING))\r\nreturn 0;\r\nspin_lock_irqsave(&p->chip->mixer_lock, flags);\r\nmixL = snd_sbmixer_read(p->chip, SB_DSP4_PCM_DEV);\r\nmixR = snd_sbmixer_read(p->chip, SB_DSP4_PCM_DEV + 1);\r\nsnd_sbmixer_write(p->chip, SB_DSP4_PCM_DEV, mixL & 0x7);\r\nsnd_sbmixer_write(p->chip, SB_DSP4_PCM_DEV + 1, mixR & 0x7);\r\nspin_lock(&p->chip->reg_lock);\r\nif (p->running & SNDRV_SB_CSP_ST_QSOUND) {\r\nset_codec_parameter(p->chip, 0xe0, 0x01);\r\nset_codec_parameter(p->chip, 0x00, 0x00);\r\nset_codec_parameter(p->chip, 0x01, 0x00);\r\np->running &= ~SNDRV_SB_CSP_ST_QSOUND;\r\n}\r\nresult = set_mode_register(p->chip, 0xc0);\r\nspin_unlock(&p->chip->reg_lock);\r\nsnd_sbmixer_write(p->chip, SB_DSP4_PCM_DEV, mixL);\r\nsnd_sbmixer_write(p->chip, SB_DSP4_PCM_DEV + 1, mixR);\r\nspin_unlock_irqrestore(&p->chip->mixer_lock, flags);\r\nif (!(result))\r\np->running &= ~(SNDRV_SB_CSP_ST_PAUSED | SNDRV_SB_CSP_ST_RUNNING);\r\nreturn result;\r\n}\r\nstatic int snd_sb_csp_pause(struct snd_sb_csp * p)\r\n{\r\nint result;\r\nunsigned long flags;\r\nif (!(p->running & SNDRV_SB_CSP_ST_RUNNING))\r\nreturn -EBUSY;\r\nspin_lock_irqsave(&p->chip->reg_lock, flags);\r\nresult = set_codec_parameter(p->chip, 0x80, 0xff);\r\nspin_unlock_irqrestore(&p->chip->reg_lock, flags);\r\nif (!(result))\r\np->running |= SNDRV_SB_CSP_ST_PAUSED;\r\nreturn result;\r\n}\r\nstatic int snd_sb_csp_restart(struct snd_sb_csp * p)\r\n{\r\nint result;\r\nunsigned long flags;\r\nif (!(p->running & SNDRV_SB_CSP_ST_PAUSED))\r\nreturn -EBUSY;\r\nspin_lock_irqsave(&p->chip->reg_lock, flags);\r\nresult = set_codec_parameter(p->chip, 0x80, 0x00);\r\nspin_unlock_irqrestore(&p->chip->reg_lock, flags);\r\nif (!(result))\r\np->running &= ~SNDRV_SB_CSP_ST_PAUSED;\r\nreturn result;\r\n}\r\nstatic int snd_sb_qsound_switch_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_sb_csp *p = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = p->q_enabled ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snd_sb_qsound_switch_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_sb_csp *p = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint change;\r\nunsigned char nval;\r\nnval = ucontrol->value.integer.value[0] & 0x01;\r\nspin_lock_irqsave(&p->q_lock, flags);\r\nchange = p->q_enabled != nval;\r\np->q_enabled = nval;\r\nspin_unlock_irqrestore(&p->q_lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_sb_qsound_space_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = SNDRV_SB_CSP_QSOUND_MAX_RIGHT;\r\nreturn 0;\r\n}\r\nstatic int snd_sb_qsound_space_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_sb_csp *p = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nspin_lock_irqsave(&p->q_lock, flags);\r\nucontrol->value.integer.value[0] = p->qpos_left;\r\nucontrol->value.integer.value[1] = p->qpos_right;\r\nspin_unlock_irqrestore(&p->q_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_sb_qsound_space_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_sb_csp *p = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint change;\r\nunsigned char nval1, nval2;\r\nnval1 = ucontrol->value.integer.value[0];\r\nif (nval1 > SNDRV_SB_CSP_QSOUND_MAX_RIGHT)\r\nnval1 = SNDRV_SB_CSP_QSOUND_MAX_RIGHT;\r\nnval2 = ucontrol->value.integer.value[1];\r\nif (nval2 > SNDRV_SB_CSP_QSOUND_MAX_RIGHT)\r\nnval2 = SNDRV_SB_CSP_QSOUND_MAX_RIGHT;\r\nspin_lock_irqsave(&p->q_lock, flags);\r\nchange = p->qpos_left != nval1 || p->qpos_right != nval2;\r\np->qpos_left = nval1;\r\np->qpos_right = nval2;\r\np->qpos_changed = change;\r\nspin_unlock_irqrestore(&p->q_lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_sb_qsound_build(struct snd_sb_csp * p)\r\n{\r\nstruct snd_card *card;\r\nint err;\r\nif (snd_BUG_ON(!p))\r\nreturn -EINVAL;\r\ncard = p->chip->card;\r\np->qpos_left = p->qpos_right = SNDRV_SB_CSP_QSOUND_MAX_RIGHT / 2;\r\np->qpos_changed = 0;\r\nspin_lock_init(&p->q_lock);\r\nif ((err = snd_ctl_add(card, p->qsound_switch = snd_ctl_new1(&snd_sb_qsound_switch, p))) < 0)\r\ngoto __error;\r\nif ((err = snd_ctl_add(card, p->qsound_space = snd_ctl_new1(&snd_sb_qsound_space, p))) < 0)\r\ngoto __error;\r\nreturn 0;\r\n__error:\r\nsnd_sb_qsound_destroy(p);\r\nreturn err;\r\n}\r\nstatic void snd_sb_qsound_destroy(struct snd_sb_csp * p)\r\n{\r\nstruct snd_card *card;\r\nunsigned long flags;\r\nif (snd_BUG_ON(!p))\r\nreturn;\r\ncard = p->chip->card;\r\ndown_write(&card->controls_rwsem);\r\nif (p->qsound_switch)\r\nsnd_ctl_remove(card, p->qsound_switch);\r\nif (p->qsound_space)\r\nsnd_ctl_remove(card, p->qsound_space);\r\nup_write(&card->controls_rwsem);\r\nspin_lock_irqsave (&p->q_lock, flags);\r\np->qpos_changed = 0;\r\nspin_unlock_irqrestore (&p->q_lock, flags);\r\n}\r\nstatic int snd_sb_csp_qsound_transfer(struct snd_sb_csp * p)\r\n{\r\nint err = -ENXIO;\r\nspin_lock(&p->q_lock);\r\nif (p->running & SNDRV_SB_CSP_ST_QSOUND) {\r\nset_codec_parameter(p->chip, 0xe0, 0x01);\r\nset_codec_parameter(p->chip, 0x00, p->qpos_left);\r\nset_codec_parameter(p->chip, 0x02, 0x00);\r\nset_codec_parameter(p->chip, 0x00, p->qpos_right);\r\nset_codec_parameter(p->chip, 0x03, 0x00);\r\nerr = 0;\r\n}\r\np->qpos_changed = 0;\r\nspin_unlock(&p->q_lock);\r\nreturn err;\r\n}\r\nstatic int init_proc_entry(struct snd_sb_csp * p, int device)\r\n{\r\nchar name[16];\r\nstruct snd_info_entry *entry;\r\nsprintf(name, "cspD%d", device);\r\nif (! snd_card_proc_new(p->chip->card, name, &entry))\r\nsnd_info_set_text_ops(entry, p, info_read);\r\nreturn 0;\r\n}\r\nstatic void info_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\r\n{\r\nstruct snd_sb_csp *p = entry->private_data;\r\nsnd_iprintf(buffer, "Creative Signal Processor [v%d.%d]\n", (p->version >> 4), (p->version & 0x0f));\r\nsnd_iprintf(buffer, "State: %cx%c%c%c\n", ((p->running & SNDRV_SB_CSP_ST_QSOUND) ? 'Q' : '-'),\r\n((p->running & SNDRV_SB_CSP_ST_PAUSED) ? 'P' : '-'),\r\n((p->running & SNDRV_SB_CSP_ST_RUNNING) ? 'R' : '-'),\r\n((p->running & SNDRV_SB_CSP_ST_LOADED) ? 'L' : '-'));\r\nif (p->running & SNDRV_SB_CSP_ST_LOADED) {\r\nsnd_iprintf(buffer, "Codec: %s [func #%d]\n", p->codec_name, p->func_nr);\r\nsnd_iprintf(buffer, "Sample rates: ");\r\nif (p->acc_rates == SNDRV_SB_CSP_RATE_ALL) {\r\nsnd_iprintf(buffer, "All\n");\r\n} else {\r\nsnd_iprintf(buffer, "%s%s%s%s\n",\r\n((p->acc_rates & SNDRV_SB_CSP_RATE_8000) ? "8000Hz " : ""),\r\n((p->acc_rates & SNDRV_SB_CSP_RATE_11025) ? "11025Hz " : ""),\r\n((p->acc_rates & SNDRV_SB_CSP_RATE_22050) ? "22050Hz " : ""),\r\n((p->acc_rates & SNDRV_SB_CSP_RATE_44100) ? "44100Hz" : ""));\r\n}\r\nif (p->mode == SNDRV_SB_CSP_MODE_QSOUND) {\r\nsnd_iprintf(buffer, "QSound decoder %sabled\n",\r\np->q_enabled ? "en" : "dis");\r\n} else {\r\nsnd_iprintf(buffer, "PCM format ID: 0x%x (%s/%s) [%s/%s] [%s/%s]\n",\r\np->acc_format,\r\n((p->acc_width & SNDRV_SB_CSP_SAMPLE_16BIT) ? "16bit" : "-"),\r\n((p->acc_width & SNDRV_SB_CSP_SAMPLE_8BIT) ? "8bit" : "-"),\r\n((p->acc_channels & SNDRV_SB_CSP_MONO) ? "mono" : "-"),\r\n((p->acc_channels & SNDRV_SB_CSP_STEREO) ? "stereo" : "-"),\r\n((p->mode & SNDRV_SB_CSP_MODE_DSP_WRITE) ? "playback" : "-"),\r\n((p->mode & SNDRV_SB_CSP_MODE_DSP_READ) ? "capture" : "-"));\r\n}\r\n}\r\nif (p->running & SNDRV_SB_CSP_ST_AUTO) {\r\nsnd_iprintf(buffer, "Autoloaded Mu-Law, A-Law or Ima-ADPCM hardware codec\n");\r\n}\r\nif (p->running & SNDRV_SB_CSP_ST_RUNNING) {\r\nsnd_iprintf(buffer, "Processing %dbit %s PCM samples\n",\r\n((p->run_width & SNDRV_SB_CSP_SAMPLE_16BIT) ? 16 : 8),\r\n((p->run_channels & SNDRV_SB_CSP_MONO) ? "mono" : "stereo"));\r\n}\r\nif (p->running & SNDRV_SB_CSP_ST_QSOUND) {\r\nsnd_iprintf(buffer, "Qsound position: left = 0x%x, right = 0x%x\n",\r\np->qpos_left, p->qpos_right);\r\n}\r\n}\r\nstatic int __init alsa_sb_csp_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_sb_csp_exit(void)\r\n{\r\n}
