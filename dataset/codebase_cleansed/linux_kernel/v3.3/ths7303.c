static int ths7303_setvalue(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nint err = 0;\r\nu8 val;\r\nstruct i2c_client *client;\r\nclient = v4l2_get_subdevdata(sd);\r\nif (std & (V4L2_STD_ALL & ~V4L2_STD_SECAM)) {\r\nval = 0x02;\r\nv4l2_dbg(1, debug, sd, "setting value for SDTV format\n");\r\n} else {\r\nval = 0x00;\r\nv4l2_dbg(1, debug, sd, "disabling all channels\n");\r\n}\r\nerr |= i2c_smbus_write_byte_data(client, 0x01, val);\r\nerr |= i2c_smbus_write_byte_data(client, 0x02, val);\r\nerr |= i2c_smbus_write_byte_data(client, 0x03, val);\r\nif (err)\r\nv4l2_err(sd, "write failed\n");\r\nreturn err;\r\n}\r\nstatic int ths7303_s_std_output(struct v4l2_subdev *sd, v4l2_std_id norm)\r\n{\r\nreturn ths7303_setvalue(sd, norm);\r\n}\r\nstatic int ths7303_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_THS7303, 0);\r\n}\r\nstatic int ths7303_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct v4l2_subdev *sd;\r\nv4l2_std_id std_id = V4L2_STD_NTSC;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nsd = kzalloc(sizeof(struct v4l2_subdev), GFP_KERNEL);\r\nif (sd == NULL)\r\nreturn -ENOMEM;\r\nv4l2_i2c_subdev_init(sd, client, &ths7303_ops);\r\nreturn ths7303_setvalue(sd, std_id);\r\n}\r\nstatic int ths7303_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nkfree(sd);\r\nreturn 0;\r\n}\r\nstatic int __init ths7303_init(void)\r\n{\r\nreturn i2c_add_driver(&ths7303_driver);\r\n}\r\nstatic void __exit ths7303_exit(void)\r\n{\r\ni2c_del_driver(&ths7303_driver);\r\n}
