static void calc_dividers(u32 div, u32 *pre, u32 *post, u32 maxpost)\r\n{\r\nu32 min_pre, temp_pre, old_err, err;\r\nmin_pre = (div - 1) / maxpost + 1;\r\nold_err = 8;\r\nfor (temp_pre = 8; temp_pre >= min_pre; temp_pre--) {\r\nif (div > (temp_pre * maxpost))\r\nbreak;\r\nif (div < (temp_pre * temp_pre))\r\ncontinue;\r\nerr = div % temp_pre;\r\nif (err == 0) {\r\n*pre = temp_pre;\r\nbreak;\r\n}\r\nerr = temp_pre - err;\r\nif (err < old_err) {\r\nold_err = err;\r\n*pre = temp_pre;\r\n}\r\n}\r\n*post = (div + *pre - 1) / *pre;\r\n}\r\nstatic void calc_dividers_3_6(u32 div, u32 *pre, u32 *post)\r\n{\r\nif (div >= 512) {\r\n*pre = 8;\r\n*post = 64;\r\n} else if (div >= 64) {\r\ncalc_dividers(div, pre, post, 64);\r\n} else if (div <= 8) {\r\n*pre = div;\r\n*post = 1;\r\n} else {\r\n*pre = 1;\r\n*post = div;\r\n}\r\n}\r\nstatic void calc_dividers_3_3(u32 div, u32 *pre, u32 *post)\r\n{\r\nif (div >= 64) {\r\n*pre = *post = 8;\r\n} else if (div > 8) {\r\ncalc_dividers(div, pre, post, 8);\r\n} else {\r\n*pre = 1;\r\n*post = div;\r\n}\r\n}\r\nstatic unsigned long get_rate_mpll(void)\r\n{\r\nulong mpctl = __raw_readl(CCM_BASE + CCM_MPCTL);\r\nreturn mxc_decode_pll(mpctl, 24000000);\r\n}\r\nstatic unsigned long get_rate_ppll(void)\r\n{\r\nulong ppctl = __raw_readl(CCM_BASE + CCM_PPCTL);\r\nreturn mxc_decode_pll(ppctl, 24000000);\r\n}\r\nstatic unsigned long get_rate_arm(void)\r\n{\r\nunsigned long pdr0 = __raw_readl(CCM_BASE + CCM_PDR0);\r\nstruct arm_ahb_div *aad;\r\nunsigned long fref = get_rate_mpll();\r\naad = &clk_consumer[(pdr0 >> 16) & 0xf];\r\nif (aad->sel)\r\nfref = fref * 3 / 4;\r\nreturn fref / aad->arm;\r\n}\r\nstatic unsigned long get_rate_ahb(struct clk *clk)\r\n{\r\nunsigned long pdr0 = __raw_readl(CCM_BASE + CCM_PDR0);\r\nstruct arm_ahb_div *aad;\r\nunsigned long fref = get_rate_arm();\r\naad = &clk_consumer[(pdr0 >> 16) & 0xf];\r\nreturn fref / aad->ahb;\r\n}\r\nstatic unsigned long get_rate_ipg(struct clk *clk)\r\n{\r\nreturn get_rate_ahb(NULL) >> 1;\r\n}\r\nstatic unsigned long get_rate_uart(struct clk *clk)\r\n{\r\nunsigned long pdr3 = __raw_readl(CCM_BASE + CCM_PDR3);\r\nunsigned long pdr4 = __raw_readl(CCM_BASE + CCM_PDR4);\r\nunsigned long div = ((pdr4 >> 10) & 0x3f) + 1;\r\nif (pdr3 & (1 << 14))\r\nreturn get_rate_arm() / div;\r\nelse\r\nreturn get_rate_ppll() / div;\r\n}\r\nstatic unsigned long get_rate_sdhc(struct clk *clk)\r\n{\r\nunsigned long pdr3 = __raw_readl(CCM_BASE + CCM_PDR3);\r\nunsigned long div, rate;\r\nif (pdr3 & (1 << 6))\r\nrate = get_rate_arm();\r\nelse\r\nrate = get_rate_ppll();\r\nswitch (clk->id) {\r\ndefault:\r\ncase 0:\r\ndiv = pdr3 & 0x3f;\r\nbreak;\r\ncase 1:\r\ndiv = (pdr3 >> 8) & 0x3f;\r\nbreak;\r\ncase 2:\r\ndiv = (pdr3 >> 16) & 0x3f;\r\nbreak;\r\n}\r\nreturn rate / (div + 1);\r\n}\r\nstatic unsigned long get_rate_mshc(struct clk *clk)\r\n{\r\nunsigned long pdr1 = __raw_readl(CCM_BASE + CCM_PDR1);\r\nunsigned long div1, div2, rate;\r\nif (pdr1 & (1 << 7))\r\nrate = get_rate_arm();\r\nelse\r\nrate = get_rate_ppll();\r\ndiv1 = (pdr1 >> 29) & 0x7;\r\ndiv2 = (pdr1 >> 22) & 0x3f;\r\nreturn rate / ((div1 + 1) * (div2 + 1));\r\n}\r\nstatic unsigned long get_rate_ssi(struct clk *clk)\r\n{\r\nunsigned long pdr2 = __raw_readl(CCM_BASE + CCM_PDR2);\r\nunsigned long div1, div2, rate;\r\nif (pdr2 & (1 << 6))\r\nrate = get_rate_arm();\r\nelse\r\nrate = get_rate_ppll();\r\nswitch (clk->id) {\r\ndefault:\r\ncase 0:\r\ndiv1 = pdr2 & 0x3f;\r\ndiv2 = (pdr2 >> 24) & 0x7;\r\nbreak;\r\ncase 1:\r\ndiv1 = (pdr2 >> 8) & 0x3f;\r\ndiv2 = (pdr2 >> 27) & 0x7;\r\nbreak;\r\n}\r\nreturn rate / ((div1 + 1) * (div2 + 1));\r\n}\r\nstatic unsigned long get_rate_csi(struct clk *clk)\r\n{\r\nunsigned long pdr2 = __raw_readl(CCM_BASE + CCM_PDR2);\r\nunsigned long rate;\r\nif (pdr2 & (1 << 7))\r\nrate = get_rate_arm();\r\nelse\r\nrate = get_rate_ppll();\r\nreturn rate / (((pdr2 >> 16) & 0x3f) + 1);\r\n}\r\nstatic unsigned long get_rate_otg(struct clk *clk)\r\n{\r\nunsigned long pdr4 = __raw_readl(CCM_BASE + CCM_PDR4);\r\nunsigned long rate;\r\nif (pdr4 & (1 << 9))\r\nrate = get_rate_arm();\r\nelse\r\nrate = get_rate_ppll();\r\nreturn rate / (((pdr4 >> 22) & 0x3f) + 1);\r\n}\r\nstatic unsigned long get_rate_ipg_per(struct clk *clk)\r\n{\r\nunsigned long pdr0 = __raw_readl(CCM_BASE + CCM_PDR0);\r\nunsigned long pdr4 = __raw_readl(CCM_BASE + CCM_PDR4);\r\nunsigned long div;\r\nif (pdr0 & (1 << 26)) {\r\ndiv = (pdr4 >> 16) & 0x3f;\r\nreturn get_rate_arm() / (div + 1);\r\n} else {\r\ndiv = (pdr0 >> 12) & 0x7;\r\nreturn get_rate_ahb(NULL) / (div + 1);\r\n}\r\n}\r\nstatic unsigned long get_rate_hsp(struct clk *clk)\r\n{\r\nunsigned long hsp_podf = (__raw_readl(CCM_BASE + CCM_PDR0) >> 20) & 0x03;\r\nunsigned long fref = get_rate_mpll();\r\nif (fref > 400 * 1000 * 1000) {\r\nswitch (hsp_podf) {\r\ncase 0:\r\nreturn fref >> 2;\r\ncase 1:\r\nreturn fref >> 3;\r\ncase 2:\r\nreturn fref / 3;\r\n}\r\n} else {\r\nswitch (hsp_podf) {\r\ncase 0:\r\ncase 2:\r\nreturn fref / 3;\r\ncase 1:\r\nreturn fref / 6;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int clk_cgr_enable(struct clk *clk)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(clk->enable_reg);\r\nreg |= 3 << clk->enable_shift;\r\n__raw_writel(reg, clk->enable_reg);\r\nreturn 0;\r\n}\r\nstatic void clk_cgr_disable(struct clk *clk)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(clk->enable_reg);\r\nreg &= ~(3 << clk->enable_shift);\r\n__raw_writel(reg, clk->enable_reg);\r\n}\r\nstatic int clk_dummy_enable(struct clk *clk)\r\n{\r\nreturn 0;\r\n}\r\nstatic void clk_dummy_disable(struct clk *clk)\r\n{\r\n}\r\nstatic unsigned long get_rate_nfc(struct clk *clk)\r\n{\r\nunsigned long div1;\r\ndiv1 = (__raw_readl(CCM_BASE + CCM_PDR4) >> 28) + 1;\r\nreturn get_rate_ahb(NULL) / div1;\r\n}\r\nint __init mx35_clocks_init()\r\n{\r\nunsigned int cgr2 = 3 << 26;\r\n#if defined(CONFIG_DEBUG_LL) && !defined(CONFIG_DEBUG_ICEDCC)\r\ncgr2 |= 3 << 16;\r\n#endif\r\nclkdev_add_table(lookups, ARRAY_SIZE(lookups));\r\n__raw_writel((3 << 18), CCM_BASE + CCM_CGR0);\r\n__raw_writel((3 << 2) | (3 << 4) | (3 << 6) | (3 << 8) | (3 << 16),\r\nCCM_BASE + CCM_CGR1);\r\n__raw_writel(cgr2, CCM_BASE + CCM_CGR2);\r\n__raw_writel(0, CCM_BASE + CCM_CGR3);\r\nclk_enable(&iim_clk);\r\nimx_print_silicon_rev("i.MX35", mx35_revision());\r\nclk_disable(&iim_clk);\r\nif (!(__raw_readl(CCM_BASE + CCM_RCSR) & (3 << 10))) {\r\nclk_enable(&iim_clk);\r\nclk_enable(&uart1_clk);\r\nclk_enable(&scc_clk);\r\n}\r\n#ifdef CONFIG_MXC_USE_EPIT\r\nepit_timer_init(&epit1_clk,\r\nMX35_IO_ADDRESS(MX35_EPIT1_BASE_ADDR), MX35_INT_EPIT1);\r\n#else\r\nmxc_timer_init(&gpt_clk,\r\nMX35_IO_ADDRESS(MX35_GPT1_BASE_ADDR), MX35_INT_GPT);\r\n#endif\r\nreturn 0;\r\n}
