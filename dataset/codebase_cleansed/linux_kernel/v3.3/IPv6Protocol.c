static UCHAR * GetNextIPV6ChainedHeader(UCHAR **ppucPayload,UCHAR *pucNextHeader,BOOLEAN *bParseDone,USHORT *pusPayloadLength)\r\n{\r\nUCHAR *pucRetHeaderPtr = NULL;\r\nUCHAR *pucPayloadPtr = NULL;\r\nUSHORT usNextHeaderOffset = 0 ;\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nif((NULL == ppucPayload) || (*pusPayloadLength == 0) || (*bParseDone))\r\n{\r\n*bParseDone = TRUE;\r\nreturn NULL;\r\n}\r\npucRetHeaderPtr = *ppucPayload;\r\npucPayloadPtr = *ppucPayload;\r\nif(!pucRetHeaderPtr || !pucPayloadPtr)\r\n{\r\n*bParseDone = TRUE;\r\nreturn NULL;\r\n}\r\n*bParseDone = FALSE;\r\nswitch(*pucNextHeader)\r\n{\r\ncase IPV6HDR_TYPE_HOPBYHOP:\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\nIPv6 HopByHop Header");\r\nusNextHeaderOffset+=sizeof(IPV6HopByHopOptionsHeader);\r\n}\r\nbreak;\r\ncase IPV6HDR_TYPE_ROUTING:\r\n{\r\nIPV6RoutingHeader *pstIpv6RoutingHeader;\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\nIPv6 Routing Header");\r\npstIpv6RoutingHeader = (IPV6RoutingHeader *)pucPayloadPtr;\r\nusNextHeaderOffset += sizeof(IPV6RoutingHeader);\r\nusNextHeaderOffset += pstIpv6RoutingHeader->ucNumAddresses * IPV6_ADDRESS_SIZEINBYTES;\r\n}\r\nbreak;\r\ncase IPV6HDR_TYPE_FRAGMENTATION:\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\nIPv6 Fragmentation Header");\r\nusNextHeaderOffset+= sizeof(IPV6FragmentHeader);\r\n}\r\nbreak;\r\ncase IPV6HDR_TYPE_DESTOPTS:\r\n{\r\nIPV6DestOptionsHeader *pstIpv6DestOptsHdr = (IPV6DestOptionsHeader *)pucPayloadPtr;\r\nint nTotalOptions = pstIpv6DestOptsHdr->ucHdrExtLen;\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\nIPv6 DestOpts Header Header");\r\nusNextHeaderOffset+= sizeof(IPV6DestOptionsHeader);\r\nusNextHeaderOffset+= nTotalOptions * IPV6_DESTOPTS_HDR_OPTIONSIZE ;\r\n}\r\nbreak;\r\ncase IPV6HDR_TYPE_AUTHENTICATION:\r\n{\r\nIPV6AuthenticationHeader *pstIpv6AuthHdr = (IPV6AuthenticationHeader *)pucPayloadPtr;\r\nint nHdrLen = pstIpv6AuthHdr->ucLength;\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\nIPv6 Authentication Header");\r\nusNextHeaderOffset+= nHdrLen * 4;\r\n}\r\nbreak;\r\ncase IPV6HDR_TYPE_ENCRYPTEDSECURITYPAYLOAD:\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\nIPv6 Encrypted Security Payload Header");\r\n*bParseDone = TRUE;\r\n}\r\nbreak;\r\ncase IPV6_ICMP_HDR_TYPE:\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, " ICMP Header");\r\n*bParseDone = TRUE;\r\n}\r\nbreak;\r\ncase TCP_HEADER_TYPE:\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, " \nTCP Header");\r\n*bParseDone = TRUE;\r\n}\r\nbreak;\r\ncase UDP_HEADER_TYPE:\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, " \nUDP Header");\r\n*bParseDone = TRUE;\r\n}\r\nbreak;\r\ndefault :\r\n{\r\n*bParseDone = TRUE;\r\n}\r\nbreak;\r\n}\r\nif(*bParseDone == FALSE)\r\n{\r\nif(*pusPayloadLength <= usNextHeaderOffset)\r\n{\r\n*bParseDone = TRUE;\r\n}\r\nelse\r\n{\r\n*pucNextHeader = *pucPayloadPtr;\r\npucPayloadPtr+=usNextHeaderOffset;\r\n(*pusPayloadLength)-=usNextHeaderOffset;\r\n}\r\n}\r\n*ppucPayload = pucPayloadPtr;\r\nreturn pucRetHeaderPtr;\r\n}\r\nstatic UCHAR GetIpv6ProtocolPorts(UCHAR *pucPayload,USHORT *pusSrcPort,USHORT *pusDestPort,USHORT usPayloadLength,UCHAR ucNextHeader)\r\n{\r\nUCHAR *pIpv6HdrScanContext = pucPayload;\r\nBOOLEAN bDone = FALSE;\r\nUCHAR ucHeaderType =0;\r\nUCHAR *pucNextHeader = NULL;\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nif( !pucPayload || (usPayloadLength == 0))\r\n{\r\nreturn 0;\r\n}\r\n*pusSrcPort = *pusDestPort = 0;\r\nucHeaderType = ucNextHeader;\r\nwhile(!bDone)\r\n{\r\npucNextHeader = GetNextIPV6ChainedHeader(&pIpv6HdrScanContext,&ucHeaderType,&bDone,&usPayloadLength);\r\nif(bDone)\r\n{\r\nif((ucHeaderType==TCP_HEADER_TYPE) || (ucHeaderType == UDP_HEADER_TYPE))\r\n{\r\n*pusSrcPort=*((PUSHORT)(pucNextHeader));\r\n*pusDestPort=*((PUSHORT)(pucNextHeader+2));\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, " \nProtocol Ports - Src Port :0x%x Dest Port : 0x%x",ntohs(*pusSrcPort),ntohs(*pusDestPort));\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn ucHeaderType;\r\n}\r\nUSHORT IpVersion6(PMINI_ADAPTER Adapter,\r\nPVOID pcIpHeader,\r\nS_CLASSIFIER_RULE *pstClassifierRule )\r\n{\r\nUSHORT ushDestPort = 0;\r\nUSHORT ushSrcPort = 0;\r\nUCHAR ucNextProtocolAboveIP =0;\r\nIPV6Header *pstIpv6Header = NULL;\r\nBOOLEAN bClassificationSucceed = FALSE;\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "IpVersion6 ==========>\n");\r\npstIpv6Header = (IPV6Header *)pcIpHeader;\r\nDumpIpv6Header(pstIpv6Header);\r\nucNextProtocolAboveIP = GetIpv6ProtocolPorts((UCHAR *)(pcIpHeader + sizeof(IPV6Header)),\r\n&ushSrcPort,\r\n&ushDestPort,\r\npstIpv6Header->usPayloadLength,\r\npstIpv6Header->ucNextHeader);\r\ndo\r\n{\r\nif(0 == pstClassifierRule->ucDirection)\r\n{\r\nbreak;\r\n}\r\nif(!pstClassifierRule->bIpv6Protocol)\r\n{\r\nbreak;\r\n}\r\nbClassificationSucceed=MatchSrcIpv6Address(pstClassifierRule,pstIpv6Header);\r\nif(!bClassificationSucceed)\r\nbreak;\r\nbClassificationSucceed=MatchDestIpv6Address(pstClassifierRule,pstIpv6Header);\r\nif(!bClassificationSucceed)\r\nbreak;\r\nbClassificationSucceed=MatchProtocol(pstClassifierRule,ucNextProtocolAboveIP);\r\nif(!bClassificationSucceed)\r\nbreak;\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\nIPv6 Protocol Matched");\r\nif((ucNextProtocolAboveIP == TCP_HEADER_TYPE) || (ucNextProtocolAboveIP == UDP_HEADER_TYPE))\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\nIPv6 Source Port:%x\n",ntohs(ushSrcPort));\r\nbClassificationSucceed=MatchSrcPort(pstClassifierRule,ntohs(ushSrcPort));\r\nif(!bClassificationSucceed)\r\nbreak;\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\nIPv6 Src Port Matched");\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\nIPv6 Destination Port:%x\n",ntohs(ushDestPort));\r\nbClassificationSucceed=MatchDestPort(pstClassifierRule,ntohs(ushDestPort));\r\nif(!bClassificationSucceed)\r\nbreak;\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\nIPv6 Dest Port Matched");\r\n}\r\n}while(0);\r\nif(TRUE==bClassificationSucceed)\r\n{\r\nINT iMatchedSFQueueIndex = 0;\r\niMatchedSFQueueIndex = SearchSfid(Adapter,pstClassifierRule->ulSFID);\r\nif(iMatchedSFQueueIndex >= NO_OF_QUEUES)\r\n{\r\nbClassificationSucceed = FALSE;\r\n}\r\nelse\r\n{\r\nif(FALSE == Adapter->PackInfo[iMatchedSFQueueIndex].bActive)\r\n{\r\nbClassificationSucceed = FALSE;\r\n}\r\n}\r\n}\r\nreturn bClassificationSucceed;\r\n}\r\nstatic BOOLEAN MatchSrcIpv6Address(S_CLASSIFIER_RULE *pstClassifierRule,IPV6Header *pstIpv6Header)\r\n{\r\nUINT uiLoopIndex=0;\r\nUINT uiIpv6AddIndex=0;\r\nUINT uiIpv6AddrNoLongWords = 4;\r\nULONG aulSrcIP[4];\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nUINT uiCountIPSrcAddresses = (UINT)pstClassifierRule->ucIPSourceAddressLength;\r\nif(0 == uiCountIPSrcAddresses)\r\nreturn TRUE;\r\nfor(uiIpv6AddIndex=0;uiIpv6AddIndex<uiIpv6AddrNoLongWords;uiIpv6AddIndex++)\r\n{\r\naulSrcIP[uiIpv6AddIndex]=ntohl(pstIpv6Header->ulSrcIpAddress[uiIpv6AddIndex]);\r\n}\r\nfor(uiLoopIndex=0;uiLoopIndex<uiCountIPSrcAddresses;uiLoopIndex+=uiIpv6AddrNoLongWords)\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\n Src Ipv6 Address In Received Packet : \n ");\r\nDumpIpv6Address(aulSrcIP);\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\n Src Ipv6 Mask In Classifier Rule: \n");\r\nDumpIpv6Address(&pstClassifierRule->stSrcIpAddress.ulIpv6Mask[uiLoopIndex]);\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\n Src Ipv6 Address In Classifier Rule : \n");\r\nDumpIpv6Address(&pstClassifierRule->stSrcIpAddress.ulIpv6Addr[uiLoopIndex]);\r\nfor(uiIpv6AddIndex=0;uiIpv6AddIndex<uiIpv6AddrNoLongWords;uiIpv6AddIndex++)\r\n{\r\nif((pstClassifierRule->stSrcIpAddress.ulIpv6Mask[uiLoopIndex+uiIpv6AddIndex] & aulSrcIP[uiIpv6AddIndex])\r\n!= pstClassifierRule->stSrcIpAddress.ulIpv6Addr[uiLoopIndex+uiIpv6AddIndex])\r\n{\r\nbreak;\r\n}\r\nif(uiIpv6AddIndex == uiIpv6AddrNoLongWords-1)\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "Ipv6 Src Ip Address Matched\n");\r\nreturn TRUE;\r\n}\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nstatic BOOLEAN MatchDestIpv6Address(S_CLASSIFIER_RULE *pstClassifierRule,IPV6Header *pstIpv6Header)\r\n{\r\nUINT uiLoopIndex=0;\r\nUINT uiIpv6AddIndex=0;\r\nUINT uiIpv6AddrNoLongWords = 4;\r\nULONG aulDestIP[4];\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nUINT uiCountIPDestinationAddresses = (UINT)pstClassifierRule->ucIPDestinationAddressLength;\r\nif(0 == uiCountIPDestinationAddresses)\r\nreturn TRUE;\r\nfor(uiIpv6AddIndex=0;uiIpv6AddIndex<uiIpv6AddrNoLongWords;uiIpv6AddIndex++)\r\n{\r\naulDestIP[uiIpv6AddIndex]=ntohl(pstIpv6Header->ulDestIpAddress[uiIpv6AddIndex]);\r\n}\r\nfor(uiLoopIndex=0;uiLoopIndex<uiCountIPDestinationAddresses;uiLoopIndex+=uiIpv6AddrNoLongWords)\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\n Destination Ipv6 Address In Received Packet : \n ");\r\nDumpIpv6Address(aulDestIP);\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\n Destination Ipv6 Mask In Classifier Rule: \n");\r\nDumpIpv6Address(&pstClassifierRule->stDestIpAddress.ulIpv6Mask[uiLoopIndex]);\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\n Destination Ipv6 Address In Classifier Rule : \n");\r\nDumpIpv6Address(&pstClassifierRule->stDestIpAddress.ulIpv6Addr[uiLoopIndex]);\r\nfor(uiIpv6AddIndex=0;uiIpv6AddIndex<uiIpv6AddrNoLongWords;uiIpv6AddIndex++)\r\n{\r\nif((pstClassifierRule->stDestIpAddress.ulIpv6Mask[uiLoopIndex+uiIpv6AddIndex] & aulDestIP[uiIpv6AddIndex])\r\n!= pstClassifierRule->stDestIpAddress.ulIpv6Addr[uiLoopIndex+uiIpv6AddIndex])\r\n{\r\nbreak;\r\n}\r\nif(uiIpv6AddIndex == uiIpv6AddrNoLongWords-1)\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "Ipv6 Destination Ip Address Matched\n");\r\nreturn TRUE;\r\n}\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nVOID DumpIpv6Address(ULONG *puIpv6Address)\r\n{\r\nUINT uiIpv6AddrNoLongWords = 4;\r\nUINT uiIpv6AddIndex=0;\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nfor(uiIpv6AddIndex=0;uiIpv6AddIndex<uiIpv6AddrNoLongWords;uiIpv6AddIndex++)\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, ":%lx",puIpv6Address[uiIpv6AddIndex]);\r\n}\r\n}\r\nstatic VOID DumpIpv6Header(IPV6Header *pstIpv6Header)\r\n{\r\nUCHAR ucVersion;\r\nUCHAR ucPrio ;\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "----Ipv6 Header---");\r\nucVersion = pstIpv6Header->ucVersionPrio & 0xf0;\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "Version : %x \n",ucVersion);\r\nucPrio = pstIpv6Header->ucVersionPrio & 0x0f;\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "Priority : %x \n",ucPrio);\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "Payload Length : %x \n",ntohs(pstIpv6Header->usPayloadLength));\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "Next Header : %x \n",pstIpv6Header->ucNextHeader);\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "Hop Limit : %x \n",pstIpv6Header->ucHopLimit);\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "Src Address :\n");\r\nDumpIpv6Address(pstIpv6Header->ulSrcIpAddress);\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "Dest Address :\n");\r\nDumpIpv6Address(pstIpv6Header->ulDestIpAddress);\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "----Ipv6 Header End---");\r\n}
