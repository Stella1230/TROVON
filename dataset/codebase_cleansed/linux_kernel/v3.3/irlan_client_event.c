void irlan_do_client_event(struct irlan_cb *self, IRLAN_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\n(*state[ self->client.state]) (self, event, skb);\r\n}\r\nstatic int irlan_client_state_idle(struct irlan_cb *self, IRLAN_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return -1;);\r\nswitch (event) {\r\ncase IRLAN_DISCOVERY_INDICATION:\r\nif (self->client.iriap) {\r\nIRDA_WARNING("%s(), busy with a previous query\n",\r\n__func__);\r\nreturn -EBUSY;\r\n}\r\nself->client.iriap = iriap_open(LSAP_ANY, IAS_CLIENT, self,\r\nirlan_client_get_value_confirm);\r\nirlan_next_client_state(self, IRLAN_QUERY);\r\niriap_getvaluebyclass_request(self->client.iriap,\r\nself->saddr, self->daddr,\r\n"IrLAN", "IrDA:TinyTP:LsapSel");\r\nbreak;\r\ncase IRLAN_WATCHDOG_TIMEOUT:\r\nIRDA_DEBUG(2, "%s(), IRLAN_WATCHDOG_TIMEOUT\n", __func__ );\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(4, "%s(), Unknown event %d\n", __func__ , event);\r\nbreak;\r\n}\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int irlan_client_state_query(struct irlan_cb *self, IRLAN_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return -1;);\r\nswitch(event) {\r\ncase IRLAN_IAS_PROVIDER_AVAIL:\r\nIRDA_ASSERT(self->dtsap_sel_ctrl != 0, return -1;);\r\nself->client.open_retries = 0;\r\nirttp_connect_request(self->client.tsap_ctrl,\r\nself->dtsap_sel_ctrl,\r\nself->saddr, self->daddr, NULL,\r\nIRLAN_MTU, NULL);\r\nirlan_next_client_state(self, IRLAN_CONN);\r\nbreak;\r\ncase IRLAN_IAS_PROVIDER_NOT_AVAIL:\r\nIRDA_DEBUG(2, "%s(), IAS_PROVIDER_NOT_AVAIL\n", __func__ );\r\nirlan_next_client_state(self, IRLAN_IDLE);\r\nif ((self->provider.access_type == ACCESS_PEER) &&\r\n(self->provider.state != IRLAN_IDLE))\r\nirlan_client_wakeup(self, self->saddr, self->daddr);\r\nbreak;\r\ncase IRLAN_LMP_DISCONNECT:\r\ncase IRLAN_LAP_DISCONNECT:\r\nirlan_next_client_state(self, IRLAN_IDLE);\r\nbreak;\r\ncase IRLAN_WATCHDOG_TIMEOUT:\r\nIRDA_DEBUG(2, "%s(), IRLAN_WATCHDOG_TIMEOUT\n", __func__ );\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), Unknown event %d\n", __func__ , event);\r\nbreak;\r\n}\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int irlan_client_state_conn(struct irlan_cb *self, IRLAN_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nswitch (event) {\r\ncase IRLAN_CONNECT_COMPLETE:\r\nirlan_get_provider_info(self);\r\nirlan_next_client_state(self, IRLAN_INFO);\r\nbreak;\r\ncase IRLAN_LMP_DISCONNECT:\r\ncase IRLAN_LAP_DISCONNECT:\r\nirlan_next_client_state(self, IRLAN_IDLE);\r\nbreak;\r\ncase IRLAN_WATCHDOG_TIMEOUT:\r\nIRDA_DEBUG(2, "%s(), IRLAN_WATCHDOG_TIMEOUT\n", __func__ );\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), Unknown event %d\n", __func__ , event);\r\nbreak;\r\n}\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int irlan_client_state_info(struct irlan_cb *self, IRLAN_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nswitch (event) {\r\ncase IRLAN_DATA_INDICATION:\r\nIRDA_ASSERT(skb != NULL, return -1;);\r\nirlan_client_parse_response(self, skb);\r\nirlan_next_client_state(self, IRLAN_MEDIA);\r\nirlan_get_media_char(self);\r\nbreak;\r\ncase IRLAN_LMP_DISCONNECT:\r\ncase IRLAN_LAP_DISCONNECT:\r\nirlan_next_client_state(self, IRLAN_IDLE);\r\nbreak;\r\ncase IRLAN_WATCHDOG_TIMEOUT:\r\nIRDA_DEBUG(2, "%s(), IRLAN_WATCHDOG_TIMEOUT\n", __func__ );\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), Unknown event %d\n", __func__ , event);\r\nbreak;\r\n}\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int irlan_client_state_media(struct irlan_cb *self, IRLAN_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nswitch(event) {\r\ncase IRLAN_DATA_INDICATION:\r\nirlan_client_parse_response(self, skb);\r\nirlan_open_data_channel(self);\r\nirlan_next_client_state(self, IRLAN_OPEN);\r\nbreak;\r\ncase IRLAN_LMP_DISCONNECT:\r\ncase IRLAN_LAP_DISCONNECT:\r\nirlan_next_client_state(self, IRLAN_IDLE);\r\nbreak;\r\ncase IRLAN_WATCHDOG_TIMEOUT:\r\nIRDA_DEBUG(2, "%s(), IRLAN_WATCHDOG_TIMEOUT\n", __func__ );\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), Unknown event %d\n", __func__ , event);\r\nbreak;\r\n}\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int irlan_client_state_open(struct irlan_cb *self, IRLAN_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nstruct qos_info qos;\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nswitch(event) {\r\ncase IRLAN_DATA_INDICATION:\r\nirlan_client_parse_response(self, skb);\r\nIRDA_ASSERT(self->dtsap_sel_data != 0, return -1;);\r\nswitch (self->client.access_type) {\r\ncase ACCESS_PEER:\r\nif (self->provider.state == IRLAN_OPEN) {\r\nirlan_next_client_state(self, IRLAN_ARB);\r\nirlan_do_client_event(self, IRLAN_CHECK_CON_ARB,\r\nNULL);\r\n} else {\r\nirlan_next_client_state(self, IRLAN_WAIT);\r\n}\r\nbreak;\r\ncase ACCESS_DIRECT:\r\ncase ACCESS_HOSTED:\r\nqos.link_disc_time.bits = 0x01;\r\nirttp_connect_request(self->tsap_data,\r\nself->dtsap_sel_data,\r\nself->saddr, self->daddr, &qos,\r\nIRLAN_MTU, NULL);\r\nirlan_next_client_state(self, IRLAN_DATA);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), unknown access type!\n", __func__ );\r\nbreak;\r\n}\r\nbreak;\r\ncase IRLAN_LMP_DISCONNECT:\r\ncase IRLAN_LAP_DISCONNECT:\r\nirlan_next_client_state(self, IRLAN_IDLE);\r\nbreak;\r\ncase IRLAN_WATCHDOG_TIMEOUT:\r\nIRDA_DEBUG(2, "%s(), IRLAN_WATCHDOG_TIMEOUT\n", __func__ );\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), Unknown event %d\n", __func__ , event);\r\nbreak;\r\n}\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int irlan_client_state_wait(struct irlan_cb *self, IRLAN_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nswitch(event) {\r\ncase IRLAN_PROVIDER_SIGNAL:\r\nirlan_next_client_state(self, IRLAN_ARB);\r\nirlan_do_client_event(self, IRLAN_CHECK_CON_ARB, NULL);\r\nbreak;\r\ncase IRLAN_LMP_DISCONNECT:\r\ncase IRLAN_LAP_DISCONNECT:\r\nirlan_next_client_state(self, IRLAN_IDLE);\r\nbreak;\r\ncase IRLAN_WATCHDOG_TIMEOUT:\r\nIRDA_DEBUG(2, "%s(), IRLAN_WATCHDOG_TIMEOUT\n", __func__ );\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), Unknown event %d\n", __func__ , event);\r\nbreak;\r\n}\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int irlan_client_state_arb(struct irlan_cb *self, IRLAN_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nstruct qos_info qos;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nswitch(event) {\r\ncase IRLAN_CHECK_CON_ARB:\r\nif (self->client.recv_arb_val == self->provider.send_arb_val) {\r\nirlan_next_client_state(self, IRLAN_CLOSE);\r\nirlan_close_data_channel(self);\r\n} else if (self->client.recv_arb_val <\r\nself->provider.send_arb_val)\r\n{\r\nqos.link_disc_time.bits = 0x01;\r\nirlan_next_client_state(self, IRLAN_DATA);\r\nirttp_connect_request(self->tsap_data,\r\nself->dtsap_sel_data,\r\nself->saddr, self->daddr, &qos,\r\nIRLAN_MTU, NULL);\r\n} else if (self->client.recv_arb_val >\r\nself->provider.send_arb_val)\r\n{\r\nIRDA_DEBUG(2, "%s(), lost the battle :-(\n", __func__ );\r\n}\r\nbreak;\r\ncase IRLAN_DATA_CONNECT_INDICATION:\r\nirlan_next_client_state(self, IRLAN_DATA);\r\nbreak;\r\ncase IRLAN_LMP_DISCONNECT:\r\ncase IRLAN_LAP_DISCONNECT:\r\nirlan_next_client_state(self, IRLAN_IDLE);\r\nbreak;\r\ncase IRLAN_WATCHDOG_TIMEOUT:\r\nIRDA_DEBUG(2, "%s(), IRLAN_WATCHDOG_TIMEOUT\n", __func__ );\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), Unknown event %d\n", __func__ , event);\r\nbreak;\r\n}\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int irlan_client_state_data(struct irlan_cb *self, IRLAN_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return -1;);\r\nswitch(event) {\r\ncase IRLAN_DATA_INDICATION:\r\nirlan_client_parse_response(self, skb);\r\nbreak;\r\ncase IRLAN_LMP_DISCONNECT:\r\ncase IRLAN_LAP_DISCONNECT:\r\nirlan_next_client_state(self, IRLAN_IDLE);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), Unknown event %d\n", __func__ , event);\r\nbreak;\r\n}\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int irlan_client_state_close(struct irlan_cb *self, IRLAN_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int irlan_client_state_sync(struct irlan_cb *self, IRLAN_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}
