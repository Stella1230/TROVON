static int __devinit\r\ntgafb_pci_register(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nreturn tgafb_register(&pdev->dev);\r\n}\r\nstatic void __devexit\r\ntgafb_pci_unregister(struct pci_dev *pdev)\r\n{\r\ntgafb_unregister(&pdev->dev);\r\n}\r\nstatic int __devinit\r\ntgafb_tc_register(struct device *dev)\r\n{\r\nint status = tgafb_register(dev);\r\nif (!status)\r\nget_device(dev);\r\nreturn status;\r\n}\r\nstatic int __devexit\r\ntgafb_tc_unregister(struct device *dev)\r\n{\r\nput_device(dev);\r\ntgafb_unregister(dev);\r\nreturn 0;\r\n}\r\nstatic int\r\ntgafb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct tga_par *par = (struct tga_par *)info->par;\r\nif (par->tga_type == TGA_TYPE_8PLANE) {\r\nif (var->bits_per_pixel != 8)\r\nreturn -EINVAL;\r\n} else {\r\nif (var->bits_per_pixel != 32)\r\nreturn -EINVAL;\r\n}\r\nvar->red.length = var->green.length = var->blue.length = 8;\r\nif (var->bits_per_pixel == 32) {\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\n}\r\nif (var->xres_virtual != var->xres || var->yres_virtual != var->yres)\r\nreturn -EINVAL;\r\nif (var->nonstd)\r\nreturn -EINVAL;\r\nif (1000000000 / var->pixclock > TGA_PLL_MAX_FREQ)\r\nreturn -EINVAL;\r\nif ((var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)\r\nreturn -EINVAL;\r\nif (var->xres * (par->tga_type == TGA_TYPE_8PLANE ? 1 : 4) % 64)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void\r\ntgafb_set_pll(struct tga_par *par, int f)\r\n{\r\nint n, shift, base, min_diff, target;\r\nint r,a,m,vm = 34, va = 1, vr = 30;\r\nfor (r = 0 ; r < 12 ; r++)\r\nTGA_WRITE_REG(par, !r, TGA_CLOCK_REG);\r\nif (f > TGA_PLL_MAX_FREQ)\r\nf = TGA_PLL_MAX_FREQ;\r\nif (f >= TGA_PLL_MAX_FREQ / 2)\r\nshift = 0;\r\nelse if (f >= TGA_PLL_MAX_FREQ / 4)\r\nshift = 1;\r\nelse\r\nshift = 2;\r\nTGA_WRITE_REG(par, shift & 1, TGA_CLOCK_REG);\r\nTGA_WRITE_REG(par, shift >> 1, TGA_CLOCK_REG);\r\nfor (r = 0 ; r < 10 ; r++)\r\nTGA_WRITE_REG(par, 0, TGA_CLOCK_REG);\r\nif (f <= 120000) {\r\nTGA_WRITE_REG(par, 0, TGA_CLOCK_REG);\r\nTGA_WRITE_REG(par, 0, TGA_CLOCK_REG);\r\n}\r\nelse if (f <= 200000) {\r\nTGA_WRITE_REG(par, 1, TGA_CLOCK_REG);\r\nTGA_WRITE_REG(par, 0, TGA_CLOCK_REG);\r\n}\r\nelse {\r\nTGA_WRITE_REG(par, 0, TGA_CLOCK_REG);\r\nTGA_WRITE_REG(par, 1, TGA_CLOCK_REG);\r\n}\r\nTGA_WRITE_REG(par, 1, TGA_CLOCK_REG);\r\nTGA_WRITE_REG(par, 0, TGA_CLOCK_REG);\r\nTGA_WRITE_REG(par, 0, TGA_CLOCK_REG);\r\nTGA_WRITE_REG(par, 1, TGA_CLOCK_REG);\r\nTGA_WRITE_REG(par, 0, TGA_CLOCK_REG);\r\nTGA_WRITE_REG(par, 1, TGA_CLOCK_REG);\r\ntarget = (f << shift) / TGA_PLL_BASE_FREQ;\r\nmin_diff = TGA_PLL_MAX_FREQ;\r\nr = 7 / target;\r\nif (!r) r = 1;\r\nbase = target * r;\r\nwhile (base < 449) {\r\nfor (n = base < 7 ? 7 : base; n < base + target && n < 449; n++) {\r\nm = ((n + 3) / 7) - 1;\r\na = 0;\r\nDIFFCHECK((m + 1) * 7);\r\nm++;\r\nDIFFCHECK((m + 1) * 7);\r\nm = (n / 6) - 1;\r\nif ((a = n % 6))\r\nDIFFCHECK(n);\r\n}\r\nr++;\r\nbase += target;\r\n}\r\nvr--;\r\nfor (r = 0; r < 8; r++)\r\nTGA_WRITE_REG(par, (vm >> r) & 1, TGA_CLOCK_REG);\r\nfor (r = 0; r < 8 ; r++)\r\nTGA_WRITE_REG(par, (va >> r) & 1, TGA_CLOCK_REG);\r\nfor (r = 0; r < 7 ; r++)\r\nTGA_WRITE_REG(par, (vr >> r) & 1, TGA_CLOCK_REG);\r\nTGA_WRITE_REG(par, ((vr >> 7) & 1)|2, TGA_CLOCK_REG);\r\n}\r\nstatic int\r\ntgafb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue,\r\nunsigned transp, struct fb_info *info)\r\n{\r\nstruct tga_par *par = (struct tga_par *) info->par;\r\nint tga_bus_pci = TGA_BUS_PCI(par->dev);\r\nint tga_bus_tc = TGA_BUS_TC(par->dev);\r\nif (regno > 255)\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nif (par->tga_type == TGA_TYPE_8PLANE && tga_bus_pci) {\r\nBT485_WRITE(par, regno, BT485_ADDR_PAL_WRITE);\r\nTGA_WRITE_REG(par, BT485_DATA_PAL, TGA_RAMDAC_SETUP_REG);\r\nTGA_WRITE_REG(par, red|(BT485_DATA_PAL<<8),TGA_RAMDAC_REG);\r\nTGA_WRITE_REG(par, green|(BT485_DATA_PAL<<8),TGA_RAMDAC_REG);\r\nTGA_WRITE_REG(par, blue|(BT485_DATA_PAL<<8),TGA_RAMDAC_REG);\r\n} else if (par->tga_type == TGA_TYPE_8PLANE && tga_bus_tc) {\r\nBT459_LOAD_ADDR(par, regno);\r\nTGA_WRITE_REG(par, BT459_PALETTE << 2, TGA_RAMDAC_SETUP_REG);\r\nTGA_WRITE_REG(par, red, TGA_RAMDAC_REG);\r\nTGA_WRITE_REG(par, green, TGA_RAMDAC_REG);\r\nTGA_WRITE_REG(par, blue, TGA_RAMDAC_REG);\r\n} else {\r\nif (regno < 16) {\r\nu32 value = (regno << 16) | (regno << 8) | regno;\r\n((u32 *)info->pseudo_palette)[regno] = value;\r\n}\r\nBT463_LOAD_ADDR(par, regno);\r\nTGA_WRITE_REG(par, BT463_PALETTE << 2, TGA_RAMDAC_SETUP_REG);\r\nTGA_WRITE_REG(par, red, TGA_RAMDAC_REG);\r\nTGA_WRITE_REG(par, green, TGA_RAMDAC_REG);\r\nTGA_WRITE_REG(par, blue, TGA_RAMDAC_REG);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ntgafb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct tga_par *par = (struct tga_par *) info->par;\r\nu32 vhcr, vvcr, vvvr;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nvhcr = TGA_READ_REG(par, TGA_HORIZ_REG);\r\nvvcr = TGA_READ_REG(par, TGA_VERT_REG);\r\nvvvr = TGA_READ_REG(par, TGA_VALID_REG);\r\nvvvr &= ~(TGA_VALID_VIDEO | TGA_VALID_BLANK);\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\nif (par->vesa_blanked) {\r\nTGA_WRITE_REG(par, vhcr & 0xbfffffff, TGA_HORIZ_REG);\r\nTGA_WRITE_REG(par, vvcr & 0xbfffffff, TGA_VERT_REG);\r\npar->vesa_blanked = 0;\r\n}\r\nTGA_WRITE_REG(par, vvvr | TGA_VALID_VIDEO, TGA_VALID_REG);\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\nTGA_WRITE_REG(par, vvvr | TGA_VALID_VIDEO | TGA_VALID_BLANK,\r\nTGA_VALID_REG);\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nTGA_WRITE_REG(par, vvcr | 0x40000000, TGA_VERT_REG);\r\nTGA_WRITE_REG(par, vvvr | TGA_VALID_BLANK, TGA_VALID_REG);\r\npar->vesa_blanked = 1;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nTGA_WRITE_REG(par, vhcr | 0x40000000, TGA_HORIZ_REG);\r\nTGA_WRITE_REG(par, vvvr | TGA_VALID_BLANK, TGA_VALID_REG);\r\npar->vesa_blanked = 1;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nTGA_WRITE_REG(par, vhcr | 0x40000000, TGA_HORIZ_REG);\r\nTGA_WRITE_REG(par, vvcr | 0x40000000, TGA_VERT_REG);\r\nTGA_WRITE_REG(par, vvvr | TGA_VALID_BLANK, TGA_VALID_REG);\r\npar->vesa_blanked = 1;\r\nbreak;\r\n}\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic void\r\ntgafb_mono_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct tga_par *par = (struct tga_par *) info->par;\r\nu32 fgcolor, bgcolor, dx, dy, width, height, vxres, vyres, pixelmask;\r\nunsigned long rincr, line_length, shift, pos, is8bpp;\r\nunsigned long i, j;\r\nconst unsigned char *data;\r\nvoid __iomem *regs_base;\r\nvoid __iomem *fb_base;\r\nis8bpp = info->var.bits_per_pixel == 8;\r\ndx = image->dx;\r\ndy = image->dy;\r\nwidth = image->width;\r\nheight = image->height;\r\nvxres = info->var.xres_virtual;\r\nvyres = info->var.yres_virtual;\r\nline_length = info->fix.line_length;\r\nrincr = (width + 7) / 8;\r\nif (unlikely(width == 0))\r\nreturn;\r\nif (dx > vxres || dy > vyres)\r\nreturn;\r\nif (dx + width > vxres)\r\nwidth = vxres - dx;\r\nif (dy + height > vyres)\r\nheight = vyres - dy;\r\nregs_base = par->tga_regs_base;\r\nfb_base = par->tga_fb_base;\r\nfgcolor = image->fg_color;\r\nbgcolor = image->bg_color;\r\nif (is8bpp) {\r\nfgcolor |= fgcolor << 8;\r\nfgcolor |= fgcolor << 16;\r\nbgcolor |= bgcolor << 8;\r\nbgcolor |= bgcolor << 16;\r\n} else {\r\nif (fgcolor < 16)\r\nfgcolor = ((u32 *)info->pseudo_palette)[fgcolor];\r\nif (bgcolor < 16)\r\nbgcolor = ((u32 *)info->pseudo_palette)[bgcolor];\r\n}\r\n__raw_writel(fgcolor, regs_base + TGA_FOREGROUND_REG);\r\n__raw_writel(bgcolor, regs_base + TGA_BACKGROUND_REG);\r\npos = dy * line_length;\r\nif (is8bpp) {\r\npos += dx;\r\nshift = pos & 3;\r\npos &= -4;\r\n} else {\r\npos += dx * 4;\r\nshift = (pos & 7) >> 2;\r\npos &= -8;\r\n}\r\ndata = (const unsigned char *) image->data;\r\n__raw_writel((is8bpp\r\n? TGA_MODE_SBM_8BPP | TGA_MODE_OPAQUE_STIPPLE\r\n: TGA_MODE_SBM_24BPP | TGA_MODE_OPAQUE_STIPPLE),\r\nregs_base + TGA_MODE_REG);\r\nif (width + shift <= 32) {\r\nunsigned long bwidth;\r\npixelmask = (2ul << (width - 1)) - 1;\r\npixelmask <<= shift;\r\n__raw_writel(pixelmask, regs_base + TGA_PIXELMASK_REG);\r\nwmb();\r\nbwidth = (width + 7) / 8;\r\nfor (i = 0; i < height; ++i) {\r\nu32 mask = 0;\r\nfor (j = 0; j < bwidth; ++j)\r\nmask |= bitrev8(data[j]) << (j * 8);\r\n__raw_writel(mask << shift, fb_base + pos);\r\npos += line_length;\r\ndata += rincr;\r\n}\r\nwmb();\r\n__raw_writel(0xffffffff, regs_base + TGA_PIXELMASK_REG);\r\n} else if (shift == 0) {\r\nunsigned long pos0 = pos;\r\nconst unsigned char *data0 = data;\r\nunsigned long bincr = (is8bpp ? 8 : 8*4);\r\nunsigned long bwidth;\r\nwmb();\r\nbwidth = (width / 8) & -4;\r\nfor (i = 0; i < height; ++i) {\r\nfor (j = 0; j < bwidth; j += 4) {\r\nu32 mask = 0;\r\nmask |= bitrev8(data[j+0]) << (0 * 8);\r\nmask |= bitrev8(data[j+1]) << (1 * 8);\r\nmask |= bitrev8(data[j+2]) << (2 * 8);\r\nmask |= bitrev8(data[j+3]) << (3 * 8);\r\n__raw_writel(mask, fb_base + pos + j*bincr);\r\n}\r\npos += line_length;\r\ndata += rincr;\r\n}\r\nwmb();\r\npixelmask = (1ul << (width & 31)) - 1;\r\nif (pixelmask) {\r\n__raw_writel(pixelmask, regs_base + TGA_PIXELMASK_REG);\r\nwmb();\r\npos = pos0 + bwidth*bincr;\r\ndata = data0 + bwidth;\r\nbwidth = ((width & 31) + 7) / 8;\r\nfor (i = 0; i < height; ++i) {\r\nu32 mask = 0;\r\nfor (j = 0; j < bwidth; ++j)\r\nmask |= bitrev8(data[j]) << (j * 8);\r\n__raw_writel(mask, fb_base + pos);\r\npos += line_length;\r\ndata += rincr;\r\n}\r\nwmb();\r\n__raw_writel(0xffffffff, regs_base + TGA_PIXELMASK_REG);\r\n}\r\n} else {\r\nunsigned long pos0 = pos;\r\nconst unsigned char *data0 = data;\r\nunsigned long bincr = (is8bpp ? 8 : 8*4);\r\nunsigned long bwidth;\r\npixelmask = 0xffff << shift;\r\n__raw_writel(pixelmask, regs_base + TGA_PIXELMASK_REG);\r\nwmb();\r\nbwidth = (width / 8) & -2;\r\nfor (i = 0; i < height; ++i) {\r\nfor (j = 0; j < bwidth; j += 2) {\r\nu32 mask = 0;\r\nmask |= bitrev8(data[j+0]) << (0 * 8);\r\nmask |= bitrev8(data[j+1]) << (1 * 8);\r\nmask <<= shift;\r\n__raw_writel(mask, fb_base + pos + j*bincr);\r\n}\r\npos += line_length;\r\ndata += rincr;\r\n}\r\nwmb();\r\npixelmask = ((1ul << (width & 15)) - 1) << shift;\r\nif (pixelmask) {\r\n__raw_writel(pixelmask, regs_base + TGA_PIXELMASK_REG);\r\nwmb();\r\npos = pos0 + bwidth*bincr;\r\ndata = data0 + bwidth;\r\nbwidth = (width & 15) > 8;\r\nfor (i = 0; i < height; ++i) {\r\nu32 mask = bitrev8(data[0]);\r\nif (bwidth)\r\nmask |= bitrev8(data[1]) << 8;\r\nmask <<= shift;\r\n__raw_writel(mask, fb_base + pos);\r\npos += line_length;\r\ndata += rincr;\r\n}\r\nwmb();\r\n}\r\n__raw_writel(0xffffffff, regs_base + TGA_PIXELMASK_REG);\r\n}\r\n__raw_writel((is8bpp\r\n? TGA_MODE_SBM_8BPP | TGA_MODE_SIMPLE\r\n: TGA_MODE_SBM_24BPP | TGA_MODE_SIMPLE),\r\nregs_base + TGA_MODE_REG);\r\n}\r\nstatic void\r\ntgafb_clut_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct tga_par *par = (struct tga_par *) info->par;\r\nu32 color, dx, dy, width, height, vxres, vyres;\r\nu32 *palette = ((u32 *)info->pseudo_palette);\r\nunsigned long pos, line_length, i, j;\r\nconst unsigned char *data;\r\nvoid __iomem *regs_base, *fb_base;\r\ndx = image->dx;\r\ndy = image->dy;\r\nwidth = image->width;\r\nheight = image->height;\r\nvxres = info->var.xres_virtual;\r\nvyres = info->var.yres_virtual;\r\nline_length = info->fix.line_length;\r\nif (dx > vxres || dy > vyres)\r\nreturn;\r\nif (dx + width > vxres)\r\nwidth = vxres - dx;\r\nif (dy + height > vyres)\r\nheight = vyres - dy;\r\nregs_base = par->tga_regs_base;\r\nfb_base = par->tga_fb_base;\r\npos = dy * line_length + (dx * 4);\r\ndata = image->data;\r\nfor (i = 0; i < height; i++) {\r\nfor (j = 0; j < width; j++) {\r\ncolor = palette[*data++];\r\n__raw_writel(color, fb_base + pos + j*4);\r\n}\r\npos += line_length;\r\n}\r\n}\r\nstatic void\r\ntgafb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nunsigned int is8bpp = info->var.bits_per_pixel == 8;\r\nif (image->depth == 1) {\r\ntgafb_mono_imageblit(info, image);\r\nreturn;\r\n}\r\nif (image->depth == info->var.bits_per_pixel) {\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\nif (!is8bpp && image->depth == 8) {\r\ntgafb_clut_imageblit(info, image);\r\nreturn;\r\n}\r\n}\r\nstatic void\r\ntgafb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nstruct tga_par *par = (struct tga_par *) info->par;\r\nint is8bpp = info->var.bits_per_pixel == 8;\r\nu32 dx, dy, width, height, vxres, vyres, color;\r\nunsigned long pos, align, line_length, i, j;\r\nvoid __iomem *regs_base;\r\nvoid __iomem *fb_base;\r\ndx = rect->dx;\r\ndy = rect->dy;\r\nwidth = rect->width;\r\nheight = rect->height;\r\nvxres = info->var.xres_virtual;\r\nvyres = info->var.yres_virtual;\r\nline_length = info->fix.line_length;\r\nregs_base = par->tga_regs_base;\r\nfb_base = par->tga_fb_base;\r\nif (dx > vxres || dy > vyres || !width || !height)\r\nreturn;\r\nif (dx + width > vxres)\r\nwidth = vxres - dx;\r\nif (dy + height > vyres)\r\nheight = vyres - dy;\r\npos = dy * line_length + dx * (is8bpp ? 1 : 4);\r\nif (rect->rop != ROP_COPY) {\r\ncfb_fillrect(info, rect);\r\nreturn;\r\n}\r\ncolor = rect->color;\r\nif (is8bpp) {\r\ncolor |= color << 8;\r\ncolor |= color << 16;\r\n__raw_writel(color, regs_base + TGA_BLOCK_COLOR0_REG);\r\n__raw_writel(color, regs_base + TGA_BLOCK_COLOR1_REG);\r\n} else {\r\nif (color < 16)\r\ncolor = ((u32 *)info->pseudo_palette)[color];\r\n__raw_writel(color, regs_base + TGA_BLOCK_COLOR0_REG);\r\n__raw_writel(color, regs_base + TGA_BLOCK_COLOR1_REG);\r\n__raw_writel(color, regs_base + TGA_BLOCK_COLOR2_REG);\r\n__raw_writel(color, regs_base + TGA_BLOCK_COLOR3_REG);\r\n__raw_writel(color, regs_base + TGA_BLOCK_COLOR4_REG);\r\n__raw_writel(color, regs_base + TGA_BLOCK_COLOR5_REG);\r\n__raw_writel(color, regs_base + TGA_BLOCK_COLOR6_REG);\r\n__raw_writel(color, regs_base + TGA_BLOCK_COLOR7_REG);\r\n}\r\n__raw_writel(0xffffffff, regs_base + TGA_DATA_REG);\r\n__raw_writel((is8bpp\r\n? TGA_MODE_SBM_8BPP | TGA_MODE_BLOCK_FILL\r\n: TGA_MODE_SBM_24BPP | TGA_MODE_BLOCK_FILL),\r\nregs_base + TGA_MODE_REG);\r\nwmb();\r\nif (width == line_length)\r\nwidth *= height, height = 1;\r\nalign = (pos & 3) << 16;\r\npos &= -4;\r\nif (width <= 2048) {\r\nu32 data;\r\ndata = (width - 1) | align;\r\nfor (i = 0; i < height; ++i) {\r\n__raw_writel(data, fb_base + pos);\r\npos += line_length;\r\n}\r\n} else {\r\nunsigned long Bpp = (is8bpp ? 1 : 4);\r\nunsigned long nwidth = width & -2048;\r\nu32 fdata, ldata;\r\nfdata = (2048 - 1) | align;\r\nldata = ((width & 2047) - 1) | align;\r\nfor (i = 0; i < height; ++i) {\r\nfor (j = 0; j < nwidth; j += 2048)\r\n__raw_writel(fdata, fb_base + pos + j*Bpp);\r\nif (j < width)\r\n__raw_writel(ldata, fb_base + pos + j*Bpp);\r\npos += line_length;\r\n}\r\n}\r\nwmb();\r\n__raw_writel((is8bpp\r\n? TGA_MODE_SBM_8BPP | TGA_MODE_SIMPLE\r\n: TGA_MODE_SBM_24BPP | TGA_MODE_SIMPLE),\r\nregs_base + TGA_MODE_REG);\r\n}\r\nstatic inline void\r\ncopyarea_line_8bpp(struct fb_info *info, u32 dy, u32 sy,\r\nu32 height, u32 width)\r\n{\r\nstruct tga_par *par = (struct tga_par *) info->par;\r\nvoid __iomem *tga_regs = par->tga_regs_base;\r\nunsigned long dpos, spos, i, n64;\r\n__raw_writel(TGA_MODE_SBM_8BPP | TGA_MODE_COPY, tga_regs+TGA_MODE_REG);\r\n__raw_writel(0, tga_regs+TGA_PIXELSHIFT_REG);\r\nwmb();\r\nn64 = (height * width) / 64;\r\nif (sy < dy) {\r\nspos = (sy + height) * width;\r\ndpos = (dy + height) * width;\r\nfor (i = 0; i < n64; ++i) {\r\nspos -= 64;\r\ndpos -= 64;\r\n__raw_writel(spos, tga_regs+TGA_COPY64_SRC);\r\nwmb();\r\n__raw_writel(dpos, tga_regs+TGA_COPY64_DST);\r\nwmb();\r\n}\r\n} else {\r\nspos = sy * width;\r\ndpos = dy * width;\r\nfor (i = 0; i < n64; ++i) {\r\n__raw_writel(spos, tga_regs+TGA_COPY64_SRC);\r\nwmb();\r\n__raw_writel(dpos, tga_regs+TGA_COPY64_DST);\r\nwmb();\r\nspos += 64;\r\ndpos += 64;\r\n}\r\n}\r\n__raw_writel(TGA_MODE_SBM_8BPP|TGA_MODE_SIMPLE, tga_regs+TGA_MODE_REG);\r\n}\r\nstatic inline void\r\ncopyarea_line_32bpp(struct fb_info *info, u32 dy, u32 sy,\r\nu32 height, u32 width)\r\n{\r\nstruct tga_par *par = (struct tga_par *) info->par;\r\nvoid __iomem *tga_regs = par->tga_regs_base;\r\nvoid __iomem *tga_fb = par->tga_fb_base;\r\nvoid __iomem *src;\r\nvoid __iomem *dst;\r\nunsigned long i, n16;\r\n__raw_writel(TGA_MODE_SBM_24BPP | TGA_MODE_COPY, tga_regs+TGA_MODE_REG);\r\n__raw_writel(0, tga_regs+TGA_PIXELSHIFT_REG);\r\nwmb();\r\nn16 = (height * width) / 16;\r\nif (sy < dy) {\r\nsrc = tga_fb + (sy + height) * width * 4;\r\ndst = tga_fb + (dy + height) * width * 4;\r\nfor (i = 0; i < n16; ++i) {\r\nsrc -= 64;\r\ndst -= 64;\r\n__raw_writel(0xffff, src);\r\nwmb();\r\n__raw_writel(0xffff, dst);\r\nwmb();\r\n}\r\n} else {\r\nsrc = tga_fb + sy * width * 4;\r\ndst = tga_fb + dy * width * 4;\r\nfor (i = 0; i < n16; ++i) {\r\n__raw_writel(0xffff, src);\r\nwmb();\r\n__raw_writel(0xffff, dst);\r\nwmb();\r\nsrc += 64;\r\ndst += 64;\r\n}\r\n}\r\n__raw_writel(TGA_MODE_SBM_24BPP|TGA_MODE_SIMPLE, tga_regs+TGA_MODE_REG);\r\n}\r\nstatic inline void\r\ncopyarea_foreward_8bpp(struct fb_info *info, u32 dx, u32 dy, u32 sx, u32 sy,\r\nu32 height, u32 width, u32 line_length)\r\n{\r\nstruct tga_par *par = (struct tga_par *) info->par;\r\nunsigned long i, copied, left;\r\nunsigned long dpos, spos, dalign, salign, yincr;\r\nu32 smask_first, dmask_first, dmask_last;\r\nint pixel_shift, need_prime, need_second;\r\nunsigned long n64, n32, xincr_first;\r\nvoid __iomem *tga_regs;\r\nvoid __iomem *tga_fb;\r\nyincr = line_length;\r\nif (dy > sy) {\r\ndy += height - 1;\r\nsy += height - 1;\r\nyincr = -yincr;\r\n}\r\ndpos = dy * line_length + dx;\r\nspos = sy * line_length + sx;\r\ndalign = dpos & 7;\r\nsalign = spos & 7;\r\ndpos &= -8;\r\nspos &= -8;\r\nif (dalign >= salign)\r\npixel_shift = dalign - salign;\r\nelse\r\npixel_shift = 8 - (salign - dalign);\r\nneed_prime = (salign > dalign);\r\nif (need_prime)\r\ndpos -= 8;\r\ncopied = 32 - (dalign + (dpos & 31));\r\nif (copied == 32)\r\ncopied = 0;\r\nxincr_first = (copied + 7) & -8;\r\nsmask_first = dmask_first = (1ul << copied) - 1;\r\nsmask_first <<= salign;\r\ndmask_first <<= dalign + need_prime*8;\r\nif (need_prime && copied > 24)\r\ncopied -= 8;\r\nleft = width - copied;\r\nif (copied > width) {\r\nu32 t;\r\nt = (1ul << width) - 1;\r\nt <<= dalign + need_prime*8;\r\ndmask_first &= t;\r\nleft = 0;\r\n}\r\nn64 = need_second = 0;\r\nif ((dpos & 63) == (spos & 63)\r\n&& (height == 1 || line_length % 64 == 0)) {\r\nneed_second = (dpos + xincr_first) & 63;\r\nif ((need_second & 32) != need_second)\r\nprintk(KERN_ERR "tgafb: need_second wrong\n");\r\nif (left >= need_second + 64) {\r\nleft -= need_second;\r\nn64 = left / 64;\r\nleft %= 64;\r\n} else\r\nneed_second = 0;\r\n}\r\nn32 = left / 32;\r\nleft %= 32;\r\ndmask_last = (1ul << left) - 1;\r\ntga_regs = par->tga_regs_base;\r\ntga_fb = par->tga_fb_base;\r\n__raw_writel(TGA_MODE_SBM_8BPP|TGA_MODE_COPY, tga_regs+TGA_MODE_REG);\r\n__raw_writel(pixel_shift, tga_regs+TGA_PIXELSHIFT_REG);\r\nwmb();\r\nfor (i = 0; i < height; ++i) {\r\nunsigned long j;\r\nvoid __iomem *sfb;\r\nvoid __iomem *dfb;\r\nsfb = tga_fb + spos;\r\ndfb = tga_fb + dpos;\r\nif (dmask_first) {\r\n__raw_writel(smask_first, sfb);\r\nwmb();\r\n__raw_writel(dmask_first, dfb);\r\nwmb();\r\nsfb += xincr_first;\r\ndfb += xincr_first;\r\n}\r\nif (need_second) {\r\n__raw_writel(0xffffffff, sfb);\r\nwmb();\r\n__raw_writel(0xffffffff, dfb);\r\nwmb();\r\nsfb += 32;\r\ndfb += 32;\r\n}\r\nif (n64 && (((unsigned long)sfb | (unsigned long)dfb) & 63))\r\nprintk(KERN_ERR\r\n"tgafb: misaligned copy64 (s:%p, d:%p)\n",\r\nsfb, dfb);\r\nfor (j = 0; j < n64; ++j) {\r\n__raw_writel(sfb - tga_fb, tga_regs+TGA_COPY64_SRC);\r\nwmb();\r\n__raw_writel(dfb - tga_fb, tga_regs+TGA_COPY64_DST);\r\nwmb();\r\nsfb += 64;\r\ndfb += 64;\r\n}\r\nfor (j = 0; j < n32; ++j) {\r\n__raw_writel(0xffffffff, sfb);\r\nwmb();\r\n__raw_writel(0xffffffff, dfb);\r\nwmb();\r\nsfb += 32;\r\ndfb += 32;\r\n}\r\nif (dmask_last) {\r\n__raw_writel(0xffffffff, sfb);\r\nwmb();\r\n__raw_writel(dmask_last, dfb);\r\nwmb();\r\n}\r\nspos += yincr;\r\ndpos += yincr;\r\n}\r\n__raw_writel(TGA_MODE_SBM_8BPP|TGA_MODE_SIMPLE, tga_regs+TGA_MODE_REG);\r\n}\r\nstatic inline void\r\ncopyarea_backward_8bpp(struct fb_info *info, u32 dx, u32 dy, u32 sx, u32 sy,\r\nu32 height, u32 width, u32 line_length,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct tga_par *par = (struct tga_par *) info->par;\r\nunsigned long i, left, yincr;\r\nunsigned long depos, sepos, dealign, sealign;\r\nu32 mask_first, mask_last;\r\nunsigned long n32;\r\nvoid __iomem *tga_regs;\r\nvoid __iomem *tga_fb;\r\nyincr = line_length;\r\nif (dy > sy) {\r\ndy += height - 1;\r\nsy += height - 1;\r\nyincr = -yincr;\r\n}\r\ndepos = dy * line_length + dx + width;\r\nsepos = sy * line_length + sx + width;\r\ndealign = depos & 7;\r\nsealign = sepos & 7;\r\nif (dealign != sealign) {\r\ncfb_copyarea(info, area);\r\nreturn;\r\n}\r\nmask_first = (1ul << dealign) - 1;\r\nleft = width - dealign;\r\nif (dealign > width) {\r\nmask_first ^= (1ul << (dealign - width)) - 1;\r\nleft = 0;\r\n}\r\nn32 = left / 32;\r\nleft %= 32;\r\nmask_last = -1 << (32 - left);\r\ntga_regs = par->tga_regs_base;\r\ntga_fb = par->tga_fb_base;\r\n__raw_writel(TGA_MODE_SBM_8BPP|TGA_MODE_COPY, tga_regs+TGA_MODE_REG);\r\n__raw_writel(0, tga_regs+TGA_PIXELSHIFT_REG);\r\nwmb();\r\nfor (i = 0; i < height; ++i) {\r\nunsigned long j;\r\nvoid __iomem *sfb;\r\nvoid __iomem *dfb;\r\nsfb = tga_fb + sepos;\r\ndfb = tga_fb + depos;\r\nif (mask_first) {\r\n__raw_writel(mask_first, sfb);\r\nwmb();\r\n__raw_writel(mask_first, dfb);\r\nwmb();\r\n}\r\nfor (j = 0; j < n32; ++j) {\r\nsfb -= 32;\r\ndfb -= 32;\r\n__raw_writel(0xffffffff, sfb);\r\nwmb();\r\n__raw_writel(0xffffffff, dfb);\r\nwmb();\r\n}\r\nif (mask_last) {\r\nsfb -= 32;\r\ndfb -= 32;\r\n__raw_writel(mask_last, sfb);\r\nwmb();\r\n__raw_writel(mask_last, dfb);\r\nwmb();\r\n}\r\nsepos += yincr;\r\ndepos += yincr;\r\n}\r\n__raw_writel(TGA_MODE_SBM_8BPP|TGA_MODE_SIMPLE, tga_regs+TGA_MODE_REG);\r\n}\r\nstatic void\r\ntgafb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\r\n{\r\nunsigned long dx, dy, width, height, sx, sy, vxres, vyres;\r\nunsigned long line_length, bpp;\r\ndx = area->dx;\r\ndy = area->dy;\r\nwidth = area->width;\r\nheight = area->height;\r\nsx = area->sx;\r\nsy = area->sy;\r\nvxres = info->var.xres_virtual;\r\nvyres = info->var.yres_virtual;\r\nline_length = info->fix.line_length;\r\nif (dx > vxres || sx > vxres || dy > vyres || sy > vyres)\r\nreturn;\r\nif (dx + width > vxres)\r\nwidth = vxres - dx;\r\nif (dy + height > vyres)\r\nheight = vyres - dy;\r\nif (sx + width > vxres || sy + height > vyres)\r\nreturn;\r\nbpp = info->var.bits_per_pixel;\r\nif (width * (bpp >> 3) == line_length) {\r\nif (bpp == 8)\r\ncopyarea_line_8bpp(info, dy, sy, height, width);\r\nelse\r\ncopyarea_line_32bpp(info, dy, sy, height, width);\r\n}\r\nelse if (bpp == 32)\r\ncfb_copyarea(info, area);\r\nelse if (dy == sy && dx > sx && dx < sx + width)\r\ncopyarea_backward_8bpp(info, dx, dy, sx, sy, height,\r\nwidth, line_length, area);\r\nelse\r\ncopyarea_foreward_8bpp(info, dx, dy, sx, sy, height,\r\nwidth, line_length);\r\n}\r\nstatic void\r\ntgafb_init_fix(struct fb_info *info)\r\n{\r\nstruct tga_par *par = (struct tga_par *)info->par;\r\nint tga_bus_pci = TGA_BUS_PCI(par->dev);\r\nint tga_bus_tc = TGA_BUS_TC(par->dev);\r\nu8 tga_type = par->tga_type;\r\nconst char *tga_type_name = NULL;\r\nswitch (tga_type) {\r\ncase TGA_TYPE_8PLANE:\r\nif (tga_bus_pci)\r\ntga_type_name = "Digital ZLXp-E1";\r\nif (tga_bus_tc)\r\ntga_type_name = "Digital ZLX-E1";\r\nbreak;\r\ncase TGA_TYPE_24PLANE:\r\nif (tga_bus_pci)\r\ntga_type_name = "Digital ZLXp-E2";\r\nif (tga_bus_tc)\r\ntga_type_name = "Digital ZLX-E2";\r\nbreak;\r\ncase TGA_TYPE_24PLUSZ:\r\nif (tga_bus_pci)\r\ntga_type_name = "Digital ZLXp-E3";\r\nif (tga_bus_tc)\r\ntga_type_name = "Digital ZLX-E3";\r\nbreak;\r\ndefault:\r\ntga_type_name = "Unknown";\r\nbreak;\r\n}\r\nstrlcpy(info->fix.id, tga_type_name, sizeof(info->fix.id));\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.visual = (tga_type == TGA_TYPE_8PLANE\r\n? FB_VISUAL_PSEUDOCOLOR\r\n: FB_VISUAL_DIRECTCOLOR);\r\ninfo->fix.line_length = par->xres * (par->bits_per_pixel >> 3);\r\ninfo->fix.smem_start = (size_t) par->tga_fb_base;\r\ninfo->fix.smem_len = info->fix.line_length * par->yres;\r\ninfo->fix.mmio_start = (size_t) par->tga_regs_base;\r\ninfo->fix.mmio_len = 512;\r\ninfo->fix.xpanstep = 0;\r\ninfo->fix.ypanstep = 0;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.accel = FB_ACCEL_DEC_TGA;\r\nif (tga_type != TGA_TYPE_8PLANE) {\r\ninfo->var.red.length = 8;\r\ninfo->var.green.length = 8;\r\ninfo->var.blue.length = 8;\r\ninfo->var.red.offset = 16;\r\ninfo->var.green.offset = 8;\r\ninfo->var.blue.offset = 0;\r\n}\r\n}\r\nstatic int tgafb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\ntgafb_set_par(info);\r\nreturn 0;\r\n}\r\nstatic int __devinit\r\ntgafb_register(struct device *dev)\r\n{\r\nstatic const struct fb_videomode modedb_tc = {\r\n"1280x1024@72", 0, 1280, 1024, 7645, 224, 28, 33, 3, 160, 3,\r\nFB_SYNC_ON_GREEN, FB_VMODE_NONINTERLACED\r\n};\r\nstatic unsigned int const fb_offset_presets[4] = {\r\nTGA_8PLANE_FB_OFFSET,\r\nTGA_24PLANE_FB_OFFSET,\r\n0xffffffff,\r\nTGA_24PLUSZ_FB_OFFSET\r\n};\r\nconst struct fb_videomode *modedb_tga = NULL;\r\nresource_size_t bar0_start = 0, bar0_len = 0;\r\nconst char *mode_option_tga = NULL;\r\nint tga_bus_pci = TGA_BUS_PCI(dev);\r\nint tga_bus_tc = TGA_BUS_TC(dev);\r\nunsigned int modedbsize_tga = 0;\r\nvoid __iomem *mem_base;\r\nstruct fb_info *info;\r\nstruct tga_par *par;\r\nu8 tga_type;\r\nint ret = 0;\r\nif (tga_bus_pci && pci_enable_device(to_pci_dev(dev))) {\r\nprintk(KERN_ERR "tgafb: Cannot enable PCI device\n");\r\nreturn -ENODEV;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct tga_par), dev);\r\nif (!info) {\r\nprintk(KERN_ERR "tgafb: Cannot allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\npar = info->par;\r\ndev_set_drvdata(dev, info);\r\nret = -ENODEV;\r\nif (tga_bus_pci) {\r\nbar0_start = pci_resource_start(to_pci_dev(dev), 0);\r\nbar0_len = pci_resource_len(to_pci_dev(dev), 0);\r\n}\r\nif (tga_bus_tc) {\r\nbar0_start = to_tc_dev(dev)->resource.start;\r\nbar0_len = to_tc_dev(dev)->resource.end - bar0_start + 1;\r\n}\r\nif (!request_mem_region (bar0_start, bar0_len, "tgafb")) {\r\nprintk(KERN_ERR "tgafb: cannot reserve FB region\n");\r\ngoto err0;\r\n}\r\nmem_base = ioremap_nocache(bar0_start, bar0_len);\r\nif (!mem_base) {\r\nprintk(KERN_ERR "tgafb: Cannot map MMIO\n");\r\ngoto err1;\r\n}\r\ntga_type = (readl(mem_base) >> 12) & 0x0f;\r\npar->dev = dev;\r\npar->tga_mem_base = mem_base;\r\npar->tga_fb_base = mem_base + fb_offset_presets[tga_type];\r\npar->tga_regs_base = mem_base + TGA_REGS_OFFSET;\r\npar->tga_type = tga_type;\r\nif (tga_bus_pci)\r\npar->tga_chip_rev = (to_pci_dev(dev))->revision;\r\nif (tga_bus_tc)\r\npar->tga_chip_rev = TGA_READ_REG(par, TGA_START_REG) & 0xff;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_COPYAREA |\r\nFBINFO_HWACCEL_IMAGEBLIT | FBINFO_HWACCEL_FILLRECT;\r\ninfo->fbops = &tgafb_ops;\r\ninfo->screen_base = par->tga_fb_base;\r\ninfo->pseudo_palette = par->palette;\r\nif (tga_bus_pci) {\r\nmode_option_tga = mode_option_pci;\r\n}\r\nif (tga_bus_tc) {\r\nmode_option_tga = mode_option_tc;\r\nmodedb_tga = &modedb_tc;\r\nmodedbsize_tga = 1;\r\n}\r\nret = fb_find_mode(&info->var, info,\r\nmode_option ? mode_option : mode_option_tga,\r\nmodedb_tga, modedbsize_tga, NULL,\r\ntga_type == TGA_TYPE_8PLANE ? 8 : 32);\r\nif (ret == 0 || ret == 4) {\r\nprintk(KERN_ERR "tgafb: Could not find valid video mode\n");\r\nret = -EINVAL;\r\ngoto err1;\r\n}\r\nif (fb_alloc_cmap(&info->cmap, 256, 0)) {\r\nprintk(KERN_ERR "tgafb: Could not allocate color map\n");\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\ntgafb_set_par(info);\r\ntgafb_init_fix(info);\r\nif (register_framebuffer(info) < 0) {\r\nprintk(KERN_ERR "tgafb: Could not register framebuffer\n");\r\nret = -EINVAL;\r\ngoto err2;\r\n}\r\nif (tga_bus_pci) {\r\npr_info("tgafb: DC21030 [TGA] detected, rev=0x%02x\n",\r\npar->tga_chip_rev);\r\npr_info("tgafb: at PCI bus %d, device %d, function %d\n",\r\nto_pci_dev(dev)->bus->number,\r\nPCI_SLOT(to_pci_dev(dev)->devfn),\r\nPCI_FUNC(to_pci_dev(dev)->devfn));\r\n}\r\nif (tga_bus_tc)\r\npr_info("tgafb: SFB+ detected, rev=0x%02x\n",\r\npar->tga_chip_rev);\r\npr_info("fb%d: %s frame buffer device at 0x%lx\n",\r\ninfo->node, info->fix.id, (long)bar0_start);\r\nreturn 0;\r\nerr2:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr1:\r\nif (mem_base)\r\niounmap(mem_base);\r\nrelease_mem_region(bar0_start, bar0_len);\r\nerr0:\r\nframebuffer_release(info);\r\nreturn ret;\r\n}\r\nstatic void __devexit\r\ntgafb_unregister(struct device *dev)\r\n{\r\nresource_size_t bar0_start = 0, bar0_len = 0;\r\nint tga_bus_pci = TGA_BUS_PCI(dev);\r\nint tga_bus_tc = TGA_BUS_TC(dev);\r\nstruct fb_info *info = NULL;\r\nstruct tga_par *par;\r\ninfo = dev_get_drvdata(dev);\r\nif (!info)\r\nreturn;\r\npar = info->par;\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\niounmap(par->tga_mem_base);\r\nif (tga_bus_pci) {\r\nbar0_start = pci_resource_start(to_pci_dev(dev), 0);\r\nbar0_len = pci_resource_len(to_pci_dev(dev), 0);\r\n}\r\nif (tga_bus_tc) {\r\nbar0_start = to_tc_dev(dev)->resource.start;\r\nbar0_len = to_tc_dev(dev)->resource.end - bar0_start + 1;\r\n}\r\nrelease_mem_region(bar0_start, bar0_len);\r\nframebuffer_release(info);\r\n}\r\nstatic void __devexit\r\ntgafb_exit(void)\r\n{\r\ntc_unregister_driver(&tgafb_tc_driver);\r\npci_unregister_driver(&tgafb_pci_driver);\r\n}\r\nstatic int __devinit\r\ntgafb_setup(char *arg)\r\n{\r\nchar *this_opt;\r\nif (arg && *arg) {\r\nwhile ((this_opt = strsep(&arg, ","))) {\r\nif (!*this_opt)\r\ncontinue;\r\nif (!strncmp(this_opt, "mode:", 5))\r\nmode_option = this_opt+5;\r\nelse\r\nprintk(KERN_ERR\r\n"tgafb: unknown parameter %s\n",\r\nthis_opt);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit\r\ntgafb_init(void)\r\n{\r\nint status;\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("tgafb", &option))\r\nreturn -ENODEV;\r\ntgafb_setup(option);\r\n#endif\r\nstatus = pci_register_driver(&tgafb_pci_driver);\r\nif (!status)\r\nstatus = tc_register_driver(&tgafb_tc_driver);\r\nreturn status;\r\n}
