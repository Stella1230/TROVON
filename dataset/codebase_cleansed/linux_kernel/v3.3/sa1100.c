static void sa1100_mctrl_check(struct sa1100_port *sport)\r\n{\r\nunsigned int status, changed;\r\nstatus = sport->port.ops->get_mctrl(&sport->port);\r\nchanged = status ^ sport->old_status;\r\nif (changed == 0)\r\nreturn;\r\nsport->old_status = status;\r\nif (changed & TIOCM_RI)\r\nsport->port.icount.rng++;\r\nif (changed & TIOCM_DSR)\r\nsport->port.icount.dsr++;\r\nif (changed & TIOCM_CAR)\r\nuart_handle_dcd_change(&sport->port, status & TIOCM_CAR);\r\nif (changed & TIOCM_CTS)\r\nuart_handle_cts_change(&sport->port, status & TIOCM_CTS);\r\nwake_up_interruptible(&sport->port.state->port.delta_msr_wait);\r\n}\r\nstatic void sa1100_timeout(unsigned long data)\r\n{\r\nstruct sa1100_port *sport = (struct sa1100_port *)data;\r\nunsigned long flags;\r\nif (sport->port.state) {\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nsa1100_mctrl_check(sport);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nmod_timer(&sport->timer, jiffies + MCTRL_TIMEOUT);\r\n}\r\n}\r\nstatic void sa1100_stop_tx(struct uart_port *port)\r\n{\r\nstruct sa1100_port *sport = (struct sa1100_port *)port;\r\nu32 utcr3;\r\nutcr3 = UART_GET_UTCR3(sport);\r\nUART_PUT_UTCR3(sport, utcr3 & ~UTCR3_TIE);\r\nsport->port.read_status_mask &= ~UTSR0_TO_SM(UTSR0_TFS);\r\n}\r\nstatic void sa1100_start_tx(struct uart_port *port)\r\n{\r\nstruct sa1100_port *sport = (struct sa1100_port *)port;\r\nu32 utcr3;\r\nutcr3 = UART_GET_UTCR3(sport);\r\nsport->port.read_status_mask |= UTSR0_TO_SM(UTSR0_TFS);\r\nUART_PUT_UTCR3(sport, utcr3 | UTCR3_TIE);\r\n}\r\nstatic void sa1100_stop_rx(struct uart_port *port)\r\n{\r\nstruct sa1100_port *sport = (struct sa1100_port *)port;\r\nu32 utcr3;\r\nutcr3 = UART_GET_UTCR3(sport);\r\nUART_PUT_UTCR3(sport, utcr3 & ~UTCR3_RIE);\r\n}\r\nstatic void sa1100_enable_ms(struct uart_port *port)\r\n{\r\nstruct sa1100_port *sport = (struct sa1100_port *)port;\r\nmod_timer(&sport->timer, jiffies);\r\n}\r\nstatic void\r\nsa1100_rx_chars(struct sa1100_port *sport)\r\n{\r\nstruct tty_struct *tty = sport->port.state->port.tty;\r\nunsigned int status, ch, flg;\r\nstatus = UTSR1_TO_SM(UART_GET_UTSR1(sport)) |\r\nUTSR0_TO_SM(UART_GET_UTSR0(sport));\r\nwhile (status & UTSR1_TO_SM(UTSR1_RNE)) {\r\nch = UART_GET_CHAR(sport);\r\nsport->port.icount.rx++;\r\nflg = TTY_NORMAL;\r\nif (status & UTSR1_TO_SM(UTSR1_PRE | UTSR1_FRE | UTSR1_ROR)) {\r\nif (status & UTSR1_TO_SM(UTSR1_PRE))\r\nsport->port.icount.parity++;\r\nelse if (status & UTSR1_TO_SM(UTSR1_FRE))\r\nsport->port.icount.frame++;\r\nif (status & UTSR1_TO_SM(UTSR1_ROR))\r\nsport->port.icount.overrun++;\r\nstatus &= sport->port.read_status_mask;\r\nif (status & UTSR1_TO_SM(UTSR1_PRE))\r\nflg = TTY_PARITY;\r\nelse if (status & UTSR1_TO_SM(UTSR1_FRE))\r\nflg = TTY_FRAME;\r\n#ifdef SUPPORT_SYSRQ\r\nsport->port.sysrq = 0;\r\n#endif\r\n}\r\nif (uart_handle_sysrq_char(&sport->port, ch))\r\ngoto ignore_char;\r\nuart_insert_char(&sport->port, status, UTSR1_TO_SM(UTSR1_ROR), ch, flg);\r\nignore_char:\r\nstatus = UTSR1_TO_SM(UART_GET_UTSR1(sport)) |\r\nUTSR0_TO_SM(UART_GET_UTSR0(sport));\r\n}\r\ntty_flip_buffer_push(tty);\r\n}\r\nstatic void sa1100_tx_chars(struct sa1100_port *sport)\r\n{\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nif (sport->port.x_char) {\r\nUART_PUT_CHAR(sport, sport->port.x_char);\r\nsport->port.icount.tx++;\r\nsport->port.x_char = 0;\r\nreturn;\r\n}\r\nsa1100_mctrl_check(sport);\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&sport->port)) {\r\nsa1100_stop_tx(&sport->port);\r\nreturn;\r\n}\r\nwhile (UART_GET_UTSR1(sport) & UTSR1_TNF) {\r\nUART_PUT_CHAR(sport, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nsport->port.icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&sport->port);\r\nif (uart_circ_empty(xmit))\r\nsa1100_stop_tx(&sport->port);\r\n}\r\nstatic irqreturn_t sa1100_int(int irq, void *dev_id)\r\n{\r\nstruct sa1100_port *sport = dev_id;\r\nunsigned int status, pass_counter = 0;\r\nspin_lock(&sport->port.lock);\r\nstatus = UART_GET_UTSR0(sport);\r\nstatus &= SM_TO_UTSR0(sport->port.read_status_mask) | ~UTSR0_TFS;\r\ndo {\r\nif (status & (UTSR0_RFS | UTSR0_RID)) {\r\nif (status & UTSR0_RID)\r\nUART_PUT_UTSR0(sport, UTSR0_RID);\r\nsa1100_rx_chars(sport);\r\n}\r\nif (status & (UTSR0_RBB | UTSR0_REB))\r\nUART_PUT_UTSR0(sport, status & (UTSR0_RBB | UTSR0_REB));\r\nif (status & UTSR0_RBB)\r\nsport->port.icount.brk++;\r\nif (status & UTSR0_REB)\r\nuart_handle_break(&sport->port);\r\nif (status & UTSR0_TFS)\r\nsa1100_tx_chars(sport);\r\nif (pass_counter++ > SA1100_ISR_PASS_LIMIT)\r\nbreak;\r\nstatus = UART_GET_UTSR0(sport);\r\nstatus &= SM_TO_UTSR0(sport->port.read_status_mask) |\r\n~UTSR0_TFS;\r\n} while (status & (UTSR0_TFS | UTSR0_RFS | UTSR0_RID));\r\nspin_unlock(&sport->port.lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int sa1100_tx_empty(struct uart_port *port)\r\n{\r\nstruct sa1100_port *sport = (struct sa1100_port *)port;\r\nreturn UART_GET_UTSR1(sport) & UTSR1_TBY ? 0 : TIOCSER_TEMT;\r\n}\r\nstatic unsigned int sa1100_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void sa1100_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void sa1100_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct sa1100_port *sport = (struct sa1100_port *)port;\r\nunsigned long flags;\r\nunsigned int utcr3;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nutcr3 = UART_GET_UTCR3(sport);\r\nif (break_state == -1)\r\nutcr3 |= UTCR3_BRK;\r\nelse\r\nutcr3 &= ~UTCR3_BRK;\r\nUART_PUT_UTCR3(sport, utcr3);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic int sa1100_startup(struct uart_port *port)\r\n{\r\nstruct sa1100_port *sport = (struct sa1100_port *)port;\r\nint retval;\r\nretval = request_irq(sport->port.irq, sa1100_int, 0,\r\n"sa11x0-uart", sport);\r\nif (retval)\r\nreturn retval;\r\nUART_PUT_UTSR0(sport, -1);\r\nUART_PUT_UTCR3(sport, UTCR3_RXE | UTCR3_TXE | UTCR3_RIE);\r\nspin_lock_irq(&sport->port.lock);\r\nsa1100_enable_ms(&sport->port);\r\nspin_unlock_irq(&sport->port.lock);\r\nreturn 0;\r\n}\r\nstatic void sa1100_shutdown(struct uart_port *port)\r\n{\r\nstruct sa1100_port *sport = (struct sa1100_port *)port;\r\ndel_timer_sync(&sport->timer);\r\nfree_irq(sport->port.irq, sport);\r\nUART_PUT_UTCR3(sport, 0);\r\n}\r\nstatic void\r\nsa1100_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct sa1100_port *sport = (struct sa1100_port *)port;\r\nunsigned long flags;\r\nunsigned int utcr0, old_utcr3, baud, quot;\r\nunsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;\r\nwhile ((termios->c_cflag & CSIZE) != CS7 &&\r\n(termios->c_cflag & CSIZE) != CS8) {\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= old_csize;\r\nold_csize = CS8;\r\n}\r\nif ((termios->c_cflag & CSIZE) == CS8)\r\nutcr0 = UTCR0_DSS;\r\nelse\r\nutcr0 = 0;\r\nif (termios->c_cflag & CSTOPB)\r\nutcr0 |= UTCR0_SBS;\r\nif (termios->c_cflag & PARENB) {\r\nutcr0 |= UTCR0_PE;\r\nif (!(termios->c_cflag & PARODD))\r\nutcr0 |= UTCR0_OES;\r\n}\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);\r\nquot = uart_get_divisor(port, baud);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nsport->port.read_status_mask &= UTSR0_TO_SM(UTSR0_TFS);\r\nsport->port.read_status_mask |= UTSR1_TO_SM(UTSR1_ROR);\r\nif (termios->c_iflag & INPCK)\r\nsport->port.read_status_mask |=\r\nUTSR1_TO_SM(UTSR1_FRE | UTSR1_PRE);\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nsport->port.read_status_mask |=\r\nUTSR0_TO_SM(UTSR0_RBB | UTSR0_REB);\r\nsport->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nsport->port.ignore_status_mask |=\r\nUTSR1_TO_SM(UTSR1_FRE | UTSR1_PRE);\r\nif (termios->c_iflag & IGNBRK) {\r\nsport->port.ignore_status_mask |=\r\nUTSR0_TO_SM(UTSR0_RBB | UTSR0_REB);\r\nif (termios->c_iflag & IGNPAR)\r\nsport->port.ignore_status_mask |=\r\nUTSR1_TO_SM(UTSR1_ROR);\r\n}\r\ndel_timer_sync(&sport->timer);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nold_utcr3 = UART_GET_UTCR3(sport);\r\nUART_PUT_UTCR3(sport, old_utcr3 & ~(UTCR3_RIE | UTCR3_TIE));\r\nwhile (UART_GET_UTSR1(sport) & UTSR1_TBY)\r\nbarrier();\r\nUART_PUT_UTCR3(sport, 0);\r\nUART_PUT_UTCR0(sport, utcr0);\r\nquot -= 1;\r\nUART_PUT_UTCR1(sport, ((quot & 0xf00) >> 8));\r\nUART_PUT_UTCR2(sport, (quot & 0xff));\r\nUART_PUT_UTSR0(sport, -1);\r\nUART_PUT_UTCR3(sport, old_utcr3);\r\nif (UART_ENABLE_MS(&sport->port, termios->c_cflag))\r\nsa1100_enable_ms(&sport->port);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic const char *sa1100_type(struct uart_port *port)\r\n{\r\nstruct sa1100_port *sport = (struct sa1100_port *)port;\r\nreturn sport->port.type == PORT_SA1100 ? "SA1100" : NULL;\r\n}\r\nstatic void sa1100_release_port(struct uart_port *port)\r\n{\r\nstruct sa1100_port *sport = (struct sa1100_port *)port;\r\nrelease_mem_region(sport->port.mapbase, UART_PORT_SIZE);\r\n}\r\nstatic int sa1100_request_port(struct uart_port *port)\r\n{\r\nstruct sa1100_port *sport = (struct sa1100_port *)port;\r\nreturn request_mem_region(sport->port.mapbase, UART_PORT_SIZE,\r\n"sa11x0-uart") != NULL ? 0 : -EBUSY;\r\n}\r\nstatic void sa1100_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct sa1100_port *sport = (struct sa1100_port *)port;\r\nif (flags & UART_CONFIG_TYPE &&\r\nsa1100_request_port(&sport->port) == 0)\r\nsport->port.type = PORT_SA1100;\r\n}\r\nstatic int\r\nsa1100_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nstruct sa1100_port *sport = (struct sa1100_port *)port;\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_SA1100)\r\nret = -EINVAL;\r\nif (sport->port.irq != ser->irq)\r\nret = -EINVAL;\r\nif (ser->io_type != SERIAL_IO_MEM)\r\nret = -EINVAL;\r\nif (sport->port.uartclk / 16 != ser->baud_base)\r\nret = -EINVAL;\r\nif ((void *)sport->port.mapbase != ser->iomem_base)\r\nret = -EINVAL;\r\nif (sport->port.iobase != ser->port)\r\nret = -EINVAL;\r\nif (ser->hub6 != 0)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic void __init sa1100_init_ports(void)\r\n{\r\nstatic int first = 1;\r\nint i;\r\nif (!first)\r\nreturn;\r\nfirst = 0;\r\nfor (i = 0; i < NR_PORTS; i++) {\r\nsa1100_ports[i].port.uartclk = 3686400;\r\nsa1100_ports[i].port.ops = &sa1100_pops;\r\nsa1100_ports[i].port.fifosize = 8;\r\nsa1100_ports[i].port.line = i;\r\nsa1100_ports[i].port.iotype = UPIO_MEM;\r\ninit_timer(&sa1100_ports[i].timer);\r\nsa1100_ports[i].timer.function = sa1100_timeout;\r\nsa1100_ports[i].timer.data = (unsigned long)&sa1100_ports[i];\r\n}\r\nPPDR |= PPC_TXD1 | PPC_TXD3;\r\nPPSR |= PPC_TXD1 | PPC_TXD3;\r\n}\r\nvoid __devinit sa1100_register_uart_fns(struct sa1100_port_fns *fns)\r\n{\r\nif (fns->get_mctrl)\r\nsa1100_pops.get_mctrl = fns->get_mctrl;\r\nif (fns->set_mctrl)\r\nsa1100_pops.set_mctrl = fns->set_mctrl;\r\nsa1100_pops.pm = fns->pm;\r\nsa1100_pops.set_wake = fns->set_wake;\r\n}\r\nvoid __init sa1100_register_uart(int idx, int port)\r\n{\r\nif (idx >= NR_PORTS) {\r\nprintk(KERN_ERR "%s: bad index number %d\n", __func__, idx);\r\nreturn;\r\n}\r\nswitch (port) {\r\ncase 1:\r\nsa1100_ports[idx].port.membase = (void __iomem *)&Ser1UTCR0;\r\nsa1100_ports[idx].port.mapbase = _Ser1UTCR0;\r\nsa1100_ports[idx].port.irq = IRQ_Ser1UART;\r\nsa1100_ports[idx].port.flags = UPF_BOOT_AUTOCONF;\r\nbreak;\r\ncase 2:\r\nsa1100_ports[idx].port.membase = (void __iomem *)&Ser2UTCR0;\r\nsa1100_ports[idx].port.mapbase = _Ser2UTCR0;\r\nsa1100_ports[idx].port.irq = IRQ_Ser2ICP;\r\nsa1100_ports[idx].port.flags = UPF_BOOT_AUTOCONF;\r\nbreak;\r\ncase 3:\r\nsa1100_ports[idx].port.membase = (void __iomem *)&Ser3UTCR0;\r\nsa1100_ports[idx].port.mapbase = _Ser3UTCR0;\r\nsa1100_ports[idx].port.irq = IRQ_Ser3UART;\r\nsa1100_ports[idx].port.flags = UPF_BOOT_AUTOCONF;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: bad port number %d\n", __func__, port);\r\n}\r\n}\r\nstatic void sa1100_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct sa1100_port *sport = (struct sa1100_port *)port;\r\nwhile (!(UART_GET_UTSR1(sport) & UTSR1_TNF))\r\nbarrier();\r\nUART_PUT_CHAR(sport, ch);\r\n}\r\nstatic void\r\nsa1100_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct sa1100_port *sport = &sa1100_ports[co->index];\r\nunsigned int old_utcr3, status;\r\nold_utcr3 = UART_GET_UTCR3(sport);\r\nUART_PUT_UTCR3(sport, (old_utcr3 & ~(UTCR3_RIE | UTCR3_TIE)) |\r\nUTCR3_TXE);\r\nuart_console_write(&sport->port, s, count, sa1100_console_putchar);\r\ndo {\r\nstatus = UART_GET_UTSR1(sport);\r\n} while (status & UTSR1_TBY);\r\nUART_PUT_UTCR3(sport, old_utcr3);\r\n}\r\nstatic void __init\r\nsa1100_console_get_options(struct sa1100_port *sport, int *baud,\r\nint *parity, int *bits)\r\n{\r\nunsigned int utcr3;\r\nutcr3 = UART_GET_UTCR3(sport) & (UTCR3_RXE | UTCR3_TXE);\r\nif (utcr3 == (UTCR3_RXE | UTCR3_TXE)) {\r\nunsigned int utcr0, quot;\r\nutcr0 = UART_GET_UTCR0(sport);\r\n*parity = 'n';\r\nif (utcr0 & UTCR0_PE) {\r\nif (utcr0 & UTCR0_OES)\r\n*parity = 'e';\r\nelse\r\n*parity = 'o';\r\n}\r\nif (utcr0 & UTCR0_DSS)\r\n*bits = 8;\r\nelse\r\n*bits = 7;\r\nquot = UART_GET_UTCR2(sport) | UART_GET_UTCR1(sport) << 8;\r\nquot &= 0xfff;\r\n*baud = sport->port.uartclk / (16 * (quot + 1));\r\n}\r\n}\r\nstatic int __init\r\nsa1100_console_setup(struct console *co, char *options)\r\n{\r\nstruct sa1100_port *sport;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index == -1 || co->index >= NR_PORTS)\r\nco->index = 0;\r\nsport = &sa1100_ports[co->index];\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\nsa1100_console_get_options(sport, &baud, &parity, &bits);\r\nreturn uart_set_options(&sport->port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init sa1100_rs_console_init(void)\r\n{\r\nsa1100_init_ports();\r\nregister_console(&sa1100_console);\r\nreturn 0;\r\n}\r\nstatic int sa1100_serial_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct sa1100_port *sport = platform_get_drvdata(dev);\r\nif (sport)\r\nuart_suspend_port(&sa1100_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int sa1100_serial_resume(struct platform_device *dev)\r\n{\r\nstruct sa1100_port *sport = platform_get_drvdata(dev);\r\nif (sport)\r\nuart_resume_port(&sa1100_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int sa1100_serial_probe(struct platform_device *dev)\r\n{\r\nstruct resource *res = dev->resource;\r\nint i;\r\nfor (i = 0; i < dev->num_resources; i++, res++)\r\nif (res->flags & IORESOURCE_MEM)\r\nbreak;\r\nif (i < dev->num_resources) {\r\nfor (i = 0; i < NR_PORTS; i++) {\r\nif (sa1100_ports[i].port.mapbase != res->start)\r\ncontinue;\r\nsa1100_ports[i].port.dev = &dev->dev;\r\nuart_add_one_port(&sa1100_reg, &sa1100_ports[i].port);\r\nplatform_set_drvdata(dev, &sa1100_ports[i]);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sa1100_serial_remove(struct platform_device *pdev)\r\n{\r\nstruct sa1100_port *sport = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nif (sport)\r\nuart_remove_one_port(&sa1100_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int __init sa1100_serial_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "Serial: SA11x0 driver\n");\r\nsa1100_init_ports();\r\nret = uart_register_driver(&sa1100_reg);\r\nif (ret == 0) {\r\nret = platform_driver_register(&sa11x0_serial_driver);\r\nif (ret)\r\nuart_unregister_driver(&sa1100_reg);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit sa1100_serial_exit(void)\r\n{\r\nplatform_driver_unregister(&sa11x0_serial_driver);\r\nuart_unregister_driver(&sa1100_reg);\r\n}
