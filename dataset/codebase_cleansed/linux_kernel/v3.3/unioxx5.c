static int __init unioxx5_driver_init_module(void)\r\n{\r\nreturn comedi_driver_register(&unioxx5_driver);\r\n}\r\nstatic void __exit unioxx5_driver_cleanup_module(void)\r\n{\r\ncomedi_driver_unregister(&unioxx5_driver);\r\n}\r\nstatic int unioxx5_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nint iobase, i, n_subd;\r\nint id, num, ba;\r\niobase = it->options[0];\r\ndev->board_name = DRIVER_NAME;\r\ndev->iobase = iobase;\r\niobase += UNIOXX5_SUBDEV_BASE;\r\nfor (i = n_subd = 0, ba = iobase; i < 4; i++, ba += UNIOXX5_SUBDEV_ODDS) {\r\nid = inb(ba + 0xE);\r\nnum = inb(ba + 0xF);\r\nif (id != 'g' || num != 1)\r\ncontinue;\r\nn_subd++;\r\n}\r\nif (n_subd < 2) {\r\nprintk(KERN_ERR\r\n"your card must has at least 2 'g01' subdevices\n");\r\nreturn -1;\r\n}\r\nif (alloc_subdevices(dev, n_subd) < 0) {\r\nprintk(KERN_ERR "out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < n_subd; i++, iobase += UNIOXX5_SUBDEV_ODDS) {\r\nif (__unioxx5_subdev_init(&dev->subdevices[i], iobase,\r\ndev->minor) < 0)\r\nreturn -1;\r\n}\r\nprintk(KERN_INFO "attached\n");\r\nreturn 0;\r\n}\r\nstatic int unioxx5_subdev_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *subdev,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct unioxx5_subd_priv *usp = subdev->private;\r\nint channel, type;\r\nchannel = CR_CHAN(insn->chanspec);\r\ntype = usp->usp_module_type[channel / 2];\r\nif (type == MODULE_DIGITAL) {\r\nif (!__unioxx5_digital_read(usp, data, channel, dev->minor))\r\nreturn -1;\r\n} else {\r\nif (!__unioxx5_analog_read(usp, data, channel, dev->minor))\r\nreturn -1;\r\n}\r\nreturn 1;\r\n}\r\nstatic int unioxx5_subdev_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *subdev,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct unioxx5_subd_priv *usp = subdev->private;\r\nint channel, type;\r\nchannel = CR_CHAN(insn->chanspec);\r\ntype = usp->usp_module_type[channel / 2];\r\nif (type == MODULE_DIGITAL) {\r\nif (!__unioxx5_digital_write(usp, data, channel, dev->minor))\r\nreturn -1;\r\n} else {\r\nif (!__unioxx5_analog_write(usp, data, channel, dev->minor))\r\nreturn -1;\r\n}\r\nreturn 1;\r\n}\r\nstatic int unioxx5_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *subdev,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint channel_offset, flags, channel = CR_CHAN(insn->chanspec), type;\r\nstruct unioxx5_subd_priv *usp = subdev->private;\r\nint mask = 1 << (channel & 0x07);\r\ntype = usp->usp_module_type[channel / 2];\r\nif (type != MODULE_DIGITAL) {\r\nprintk(KERN_ERR\r\n"comedi%d: channel configuration accessible only for digital modules\n",\r\ndev->minor);\r\nreturn -1;\r\n}\r\nchannel_offset = __unioxx5_define_chan_offset(channel);\r\nif (channel_offset < 0) {\r\nprintk(KERN_ERR\r\n"comedi%d: undefined channel %d. channel range is 0 .. 23\n",\r\ndev->minor, channel);\r\nreturn -1;\r\n}\r\nflags = usp->usp_prev_cn_val[channel_offset - 1];\r\nswitch (*data) {\r\ncase COMEDI_INPUT:\r\nflags &= ~mask;\r\nbreak;\r\ncase COMEDI_OUTPUT:\r\nflags |= mask;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "comedi%d: unknown flag\n", dev->minor);\r\nreturn -1;\r\n}\r\noutb(1, usp->usp_iobase + 0);\r\noutb(flags, usp->usp_iobase + channel_offset);\r\noutb(0, usp->usp_iobase + 0);\r\nusp->usp_prev_cn_val[channel_offset - 1] = flags;\r\nreturn 0;\r\n}\r\nstatic int unioxx5_detach(struct comedi_device *dev)\r\n{\r\nint i;\r\nstruct comedi_subdevice *subdev;\r\nstruct unioxx5_subd_priv *usp;\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\nsubdev = &dev->subdevices[i];\r\nusp = subdev->private;\r\nrelease_region(usp->usp_iobase, UNIOXX5_SIZE);\r\nkfree(subdev->private);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __unioxx5_subdev_init(struct comedi_subdevice *subdev,\r\nint subdev_iobase, int minor)\r\n{\r\nstruct unioxx5_subd_priv *usp;\r\nint i, to, ndef_flag = 0;\r\nif (!request_region(subdev_iobase, UNIOXX5_SIZE, DRIVER_NAME)) {\r\nprintk(KERN_ERR "comedi%d: I/O port conflict\n", minor);\r\nreturn -EIO;\r\n}\r\nusp = kzalloc(sizeof(*usp), GFP_KERNEL);\r\nif (usp == NULL) {\r\nprintk(KERN_ERR "comedi%d: erorr! --> out of memory!\n", minor);\r\nreturn -1;\r\n}\r\nusp->usp_iobase = subdev_iobase;\r\nprintk(KERN_INFO "comedi%d: |", minor);\r\nfor (i = 0; i < 12; i++) {\r\nto = 10000;\r\n__unioxx5_analog_config(usp, i * 2);\r\noutb(i + 1, subdev_iobase + 5);\r\noutb('H', subdev_iobase + 6);\r\nwhile (!(inb(subdev_iobase + 0) & TxBE))\r\n;\r\noutb(0, subdev_iobase + 6);\r\nwhile (!(inb(subdev_iobase + 0) & Rx2CA)) {\r\nif (--to <= 0) {\r\nndef_flag = 1;\r\nbreak;\r\n}\r\n}\r\nif (ndef_flag) {\r\nusp->usp_module_type[i] = 0;\r\nndef_flag = 0;\r\n} else\r\nusp->usp_module_type[i] = inb(subdev_iobase + 6);\r\nprintk(" [%d] 0x%02x |", i, usp->usp_module_type[i]);\r\nudelay(1);\r\n}\r\nprintk("\n");\r\nsubdev->type = COMEDI_SUBD_DIO;\r\nsubdev->private = usp;\r\nsubdev->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\nsubdev->n_chan = UNIOXX5_NUM_OF_CHANS;\r\nsubdev->maxdata = 0xFFF;\r\nsubdev->range_table = &range_digital;\r\nsubdev->insn_read = unioxx5_subdev_read;\r\nsubdev->insn_write = unioxx5_subdev_write;\r\nsubdev->insn_config = unioxx5_insn_config;\r\nprintk(KERN_INFO "subdevice configured\n");\r\nreturn 0;\r\n}\r\nstatic int __unioxx5_digital_write(struct unioxx5_subd_priv *usp,\r\nunsigned int *data, int channel, int minor)\r\n{\r\nint channel_offset, val;\r\nint mask = 1 << (channel & 0x07);\r\nchannel_offset = __unioxx5_define_chan_offset(channel);\r\nif (channel_offset < 0) {\r\nprintk(KERN_ERR\r\n"comedi%d: undefined channel %d. channel range is 0 .. 23\n",\r\nminor, channel);\r\nreturn 0;\r\n}\r\nval = usp->usp_prev_wr_val[channel_offset - 1];\r\nif (*data)\r\nval |= mask;\r\nelse\r\nval &= ~mask;\r\noutb(val, usp->usp_iobase + channel_offset);\r\nusp->usp_prev_wr_val[channel_offset - 1] = val;\r\nreturn 1;\r\n}\r\nstatic int __unioxx5_digital_read(struct unioxx5_subd_priv *usp,\r\nunsigned int *data, int channel, int minor)\r\n{\r\nint channel_offset, mask = 1 << (channel & 0x07);\r\nchannel_offset = __unioxx5_define_chan_offset(channel);\r\nif (channel_offset < 0) {\r\nprintk(KERN_ERR\r\n"comedi%d: undefined channel %d. channel range is 0 .. 23\n",\r\nminor, channel);\r\nreturn 0;\r\n}\r\n*data = inb(usp->usp_iobase + channel_offset);\r\n*data &= mask;\r\nif (channel_offset > 1)\r\nchannel -= 2 << channel_offset;\r\n*data >>= channel;\r\nreturn 1;\r\n}\r\nstatic int __unioxx5_analog_write(struct unioxx5_subd_priv *usp,\r\nunsigned int *data, int channel, int minor)\r\n{\r\nint module, i;\r\nmodule = channel / 2;\r\ni = (channel % 2) << 1;\r\nif (!(usp->usp_module_type[module] & MODULE_OUTPUT_MASK)) {\r\nprintk(KERN_ERR\r\n"comedi%d: module in position %d with id 0x%0x is for input only!\n",\r\nminor, module, usp->usp_module_type[module]);\r\nreturn 0;\r\n}\r\n__unioxx5_analog_config(usp, channel);\r\nusp->usp_extra_data[module][i++] = (unsigned char)(*data & 0x00FF);\r\nusp->usp_extra_data[module][i] = (unsigned char)((*data & 0xFF00) >> 8);\r\noutb(module + 1, usp->usp_iobase + 5);\r\noutb('W', usp->usp_iobase + 6);\r\nfor (i = 0; i < 4; i++) {\r\nwhile (!((inb(usp->usp_iobase + 0)) & TxBE))\r\n;\r\noutb(usp->usp_extra_data[module][i], usp->usp_iobase + 6);\r\n}\r\nreturn 1;\r\n}\r\nstatic int __unioxx5_analog_read(struct unioxx5_subd_priv *usp,\r\nunsigned int *data, int channel, int minor)\r\n{\r\nint module_no, read_ch;\r\nchar control;\r\nmodule_no = channel / 2;\r\nread_ch = channel % 2;\r\nif (usp->usp_module_type[module_no] & MODULE_OUTPUT_MASK) {\r\nprintk(KERN_ERR\r\n"comedi%d: module in position %d with id 0x%02x is for output only",\r\nminor, module_no, usp->usp_module_type[module_no]);\r\nreturn 0;\r\n}\r\n__unioxx5_analog_config(usp, channel);\r\noutb(module_no + 1, usp->usp_iobase + 5);\r\noutb('V', usp->usp_iobase + 6);\r\ncontrol = inb(usp->usp_iobase);\r\nwhile (!((control = inb(usp->usp_iobase + 0)) & Rx4CA))\r\n;\r\nif ((control & Rx4CA_ERR_MASK)) {\r\nprintk("COMEDI: 4 bytes error\n");\r\nreturn 0;\r\n}\r\nif (read_ch)\r\n*data = inw(usp->usp_iobase + 6);\r\nelse\r\n*data = inw(usp->usp_iobase + 4);\r\nreturn 1;\r\n}\r\nstatic void __unioxx5_analog_config(struct unioxx5_subd_priv *usp, int channel)\r\n{\r\nint chan_a, chan_b, conf, channel_offset;\r\nchannel_offset = __unioxx5_define_chan_offset(channel);\r\nconf = usp->usp_prev_cn_val[channel_offset - 1];\r\nchan_a = chan_b = 1;\r\nif (channel % 2 == 0) {\r\nchan_a <<= channel & 0x07;\r\nchan_b <<= (channel + 1) & 0x07;\r\n} else {\r\nchan_a <<= (channel - 1) & 0x07;\r\nchan_b <<= channel & 0x07;\r\n}\r\nconf |= chan_a;\r\nconf &= ~chan_b;\r\noutb(1, usp->usp_iobase + 0);\r\noutb(conf, usp->usp_iobase + channel_offset);\r\noutb(0, usp->usp_iobase + 0);\r\nusp->usp_prev_cn_val[channel_offset - 1] = conf;\r\n}\r\nstatic int __unioxx5_define_chan_offset(int chan_num)\r\n{\r\nif (chan_num < 0 || chan_num > 23)\r\nreturn -1;\r\nreturn (chan_num >> 3) + 1;\r\n}
