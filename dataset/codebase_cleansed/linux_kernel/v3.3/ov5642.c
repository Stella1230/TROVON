static struct ov5642 *to_ov5642(const struct i2c_client *client)\r\n{\r\nreturn container_of(i2c_get_clientdata(client), struct ov5642, subdev);\r\n}\r\nstatic const struct ov5642_datafmt\r\n*ov5642_find_datafmt(enum v4l2_mbus_pixelcode code)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ov5642_colour_fmts); i++)\r\nif (ov5642_colour_fmts[i].code == code)\r\nreturn ov5642_colour_fmts + i;\r\nreturn NULL;\r\n}\r\nstatic int reg_read(struct i2c_client *client, u16 reg, u8 *val)\r\n{\r\nint ret;\r\nunsigned char data[2] = { reg >> 8, reg & 0xff };\r\nret = i2c_master_send(client, data, 2);\r\nif (ret < 2) {\r\ndev_err(&client->dev, "%s: i2c read error, reg: %x\n",\r\n__func__, reg);\r\nreturn ret < 0 ? ret : -EIO;\r\n}\r\nret = i2c_master_recv(client, val, 1);\r\nif (ret < 1) {\r\ndev_err(&client->dev, "%s: i2c read error, reg: %x\n",\r\n__func__, reg);\r\nreturn ret < 0 ? ret : -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int reg_write(struct i2c_client *client, u16 reg, u8 val)\r\n{\r\nint ret;\r\nunsigned char data[3] = { reg >> 8, reg & 0xff, val };\r\nret = i2c_master_send(client, data, 3);\r\nif (ret < 3) {\r\ndev_err(&client->dev, "%s: i2c write error, reg: %x\n",\r\n__func__, reg);\r\nreturn ret < 0 ? ret : -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int reg_write16(struct i2c_client *client, u16 reg, u16 val16)\r\n{\r\nint ret;\r\nret = reg_write(client, reg, val16 >> 8);\r\nif (ret)\r\nreturn ret;\r\nreturn reg_write(client, reg + 1, val16 & 0x00ff);\r\n}\r\nstatic int ov5642_get_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nu8 val;\r\nif (reg->reg & ~0xffff)\r\nreturn -EINVAL;\r\nreg->size = 1;\r\nret = reg_read(client, reg->reg, &val);\r\nif (!ret)\r\nreg->val = (__u64)val;\r\nreturn ret;\r\n}\r\nstatic int ov5642_set_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->reg & ~0xffff || reg->val & ~0xff)\r\nreturn -EINVAL;\r\nreturn reg_write(client, reg->reg, reg->val);\r\n}\r\nstatic int ov5642_write_array(struct i2c_client *client,\r\nstruct regval_list *vals)\r\n{\r\nwhile (vals->reg_num != 0xffff || vals->value != 0xff) {\r\nint ret = reg_write(client, vals->reg_num, vals->value);\r\nif (ret < 0)\r\nreturn ret;\r\nvals++;\r\n}\r\ndev_dbg(&client->dev, "Register list loaded\n");\r\nreturn 0;\r\n}\r\nstatic int ov5642_set_resolution(struct v4l2_subdev *sd)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov5642 *priv = to_ov5642(client);\r\nint width = priv->crop_rect.width;\r\nint height = priv->crop_rect.height;\r\nint total_width = priv->total_width;\r\nint total_height = priv->total_height;\r\nint start_x = (OV5642_SENSOR_SIZE_X - width) / 2;\r\nint start_y = (OV5642_SENSOR_SIZE_Y - height) / 2;\r\nint ret;\r\nret = reg_write16(client, REG_WINDOW_START_X_HIGH, start_x);\r\nif (!ret)\r\nret = reg_write16(client, REG_WINDOW_START_Y_HIGH, start_y);\r\nif (!ret) {\r\npriv->crop_rect.left = start_x;\r\npriv->crop_rect.top = start_y;\r\n}\r\nif (!ret)\r\nret = reg_write16(client, REG_WINDOW_WIDTH_HIGH, width);\r\nif (!ret)\r\nret = reg_write16(client, REG_WINDOW_HEIGHT_HIGH, height);\r\nif (ret)\r\nreturn ret;\r\npriv->crop_rect.width = width;\r\npriv->crop_rect.height = height;\r\nret = reg_write16(client, REG_OUT_WIDTH_HIGH, width);\r\nif (!ret)\r\nret = reg_write16(client, REG_OUT_HEIGHT_HIGH, height);\r\nif (!ret)\r\nret = reg_write16(client, REG_OUT_TOTAL_WIDTH_HIGH, total_width);\r\nif (!ret)\r\nret = reg_write16(client, REG_OUT_TOTAL_HEIGHT_HIGH, total_height);\r\nif (!ret)\r\nret = reg_write16(client, REG_AVG_WINDOW_END_X_HIGH, width);\r\nif (!ret)\r\nret = reg_write16(client, REG_AVG_WINDOW_END_Y_HIGH, height);\r\nreturn ret;\r\n}\r\nstatic int ov5642_try_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov5642 *priv = to_ov5642(client);\r\nconst struct ov5642_datafmt *fmt = ov5642_find_datafmt(mf->code);\r\nmf->width = priv->crop_rect.width;\r\nmf->height = priv->crop_rect.height;\r\nif (!fmt) {\r\nmf->code = ov5642_colour_fmts[0].code;\r\nmf->colorspace = ov5642_colour_fmts[0].colorspace;\r\n}\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int ov5642_s_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov5642 *priv = to_ov5642(client);\r\nif (!ov5642_find_datafmt(mf->code))\r\nreturn -EINVAL;\r\nov5642_try_fmt(sd, mf);\r\npriv->fmt = ov5642_find_datafmt(mf->code);\r\nreturn 0;\r\n}\r\nstatic int ov5642_g_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov5642 *priv = to_ov5642(client);\r\nconst struct ov5642_datafmt *fmt = priv->fmt;\r\nmf->code = fmt->code;\r\nmf->colorspace = fmt->colorspace;\r\nmf->width = priv->crop_rect.width;\r\nmf->height = priv->crop_rect.height;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int ov5642_enum_fmt(struct v4l2_subdev *sd, unsigned int index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index >= ARRAY_SIZE(ov5642_colour_fmts))\r\nreturn -EINVAL;\r\n*code = ov5642_colour_fmts[index].code;\r\nreturn 0;\r\n}\r\nstatic int ov5642_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *id)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)\r\nreturn -EINVAL;\r\nif (id->match.addr != client->addr)\r\nreturn -ENODEV;\r\nid->ident = V4L2_IDENT_OV5642;\r\nid->revision = 0;\r\nreturn 0;\r\n}\r\nstatic int ov5642_s_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov5642 *priv = to_ov5642(client);\r\nstruct v4l2_rect *rect = &a->c;\r\nint ret;\r\nv4l_bound_align_image(&rect->width, 48, OV5642_MAX_WIDTH, 1,\r\n&rect->height, 32, OV5642_MAX_HEIGHT, 1, 0);\r\npriv->crop_rect.width = rect->width;\r\npriv->crop_rect.height = rect->height;\r\npriv->total_width = rect->width + BLANKING_EXTRA_WIDTH;\r\npriv->total_height = max_t(int, rect->height +\r\nBLANKING_EXTRA_HEIGHT,\r\nBLANKING_MIN_HEIGHT);\r\npriv->crop_rect.width = rect->width;\r\npriv->crop_rect.height = rect->height;\r\nret = ov5642_write_array(client, ov5642_default_regs_init);\r\nif (!ret)\r\nret = ov5642_set_resolution(sd);\r\nif (!ret)\r\nret = ov5642_write_array(client, ov5642_default_regs_finalise);\r\nreturn ret;\r\n}\r\nstatic int ov5642_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov5642 *priv = to_ov5642(client);\r\nstruct v4l2_rect *rect = &a->c;\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\n*rect = priv->crop_rect;\r\nreturn 0;\r\n}\r\nstatic int ov5642_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)\r\n{\r\na->bounds.left = 0;\r\na->bounds.top = 0;\r\na->bounds.width = OV5642_MAX_WIDTH;\r\na->bounds.height = OV5642_MAX_HEIGHT;\r\na->defrect = a->bounds;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\na->pixelaspect.numerator = 1;\r\na->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int ov5642_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\ncfg->type = V4L2_MBUS_CSI2;\r\ncfg->flags = V4L2_MBUS_CSI2_2_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |\r\nV4L2_MBUS_CSI2_CONTINUOUS_CLOCK;\r\nreturn 0;\r\n}\r\nstatic int ov5642_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct i2c_client *client;\r\nint ret;\r\nif (!on)\r\nreturn 0;\r\nclient = v4l2_get_subdevdata(sd);\r\nret = ov5642_write_array(client, ov5642_default_regs_init);\r\nif (!ret)\r\nret = ov5642_set_resolution(sd);\r\nif (!ret)\r\nret = ov5642_write_array(client, ov5642_default_regs_finalise);\r\nreturn ret;\r\n}\r\nstatic int ov5642_video_probe(struct i2c_client *client)\r\n{\r\nint ret;\r\nu8 id_high, id_low;\r\nu16 id;\r\nret = reg_read(client, REG_CHIP_ID_HIGH, &id_high);\r\nif (ret < 0)\r\nreturn ret;\r\nid = id_high << 8;\r\nret = reg_read(client, REG_CHIP_ID_LOW, &id_low);\r\nif (ret < 0)\r\nreturn ret;\r\nid |= id_low;\r\ndev_info(&client->dev, "Chip ID 0x%04x detected\n", id);\r\nif (id != 0x5642)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int ov5642_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct ov5642 *priv;\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nint ret;\r\nif (!icl) {\r\ndev_err(&client->dev, "OV5642: missing platform data!\n");\r\nreturn -EINVAL;\r\n}\r\npriv = kzalloc(sizeof(struct ov5642), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nv4l2_i2c_subdev_init(&priv->subdev, client, &ov5642_subdev_ops);\r\npriv->fmt = &ov5642_colour_fmts[0];\r\npriv->crop_rect.width = OV5642_DEFAULT_WIDTH;\r\npriv->crop_rect.height = OV5642_DEFAULT_HEIGHT;\r\npriv->crop_rect.left = (OV5642_MAX_WIDTH - OV5642_DEFAULT_WIDTH) / 2;\r\npriv->crop_rect.top = (OV5642_MAX_HEIGHT - OV5642_DEFAULT_HEIGHT) / 2;\r\npriv->crop_rect.width = OV5642_DEFAULT_WIDTH;\r\npriv->crop_rect.height = OV5642_DEFAULT_HEIGHT;\r\npriv->total_width = OV5642_DEFAULT_WIDTH + BLANKING_EXTRA_WIDTH;\r\npriv->total_height = BLANKING_MIN_HEIGHT;\r\nret = ov5642_video_probe(client);\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nstatic int ov5642_remove(struct i2c_client *client)\r\n{\r\nstruct ov5642 *priv = to_ov5642(client);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nif (icl->free_bus)\r\nicl->free_bus(icl);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int __init ov5642_mod_init(void)\r\n{\r\nreturn i2c_add_driver(&ov5642_i2c_driver);\r\n}\r\nstatic void __exit ov5642_mod_exit(void)\r\n{\r\ni2c_del_driver(&ov5642_i2c_driver);\r\n}
