static int irtty_chars_in_buffer(struct sir_dev *dev)\r\n{\r\nstruct sirtty_cb *priv = dev->priv;\r\nIRDA_ASSERT(priv != NULL, return -1;);\r\nIRDA_ASSERT(priv->magic == IRTTY_MAGIC, return -1;);\r\nreturn tty_chars_in_buffer(priv->tty);\r\n}\r\nstatic void irtty_wait_until_sent(struct sir_dev *dev)\r\n{\r\nstruct sirtty_cb *priv = dev->priv;\r\nstruct tty_struct *tty;\r\nIRDA_ASSERT(priv != NULL, return;);\r\nIRDA_ASSERT(priv->magic == IRTTY_MAGIC, return;);\r\ntty = priv->tty;\r\nif (tty->ops->wait_until_sent) {\r\ntty->ops->wait_until_sent(tty, msecs_to_jiffies(100));\r\n}\r\nelse {\r\nmsleep(USBSERIAL_TX_DONE_DELAY);\r\n}\r\n}\r\nstatic int irtty_change_speed(struct sir_dev *dev, unsigned speed)\r\n{\r\nstruct sirtty_cb *priv = dev->priv;\r\nstruct tty_struct *tty;\r\nstruct ktermios old_termios;\r\nint cflag;\r\nIRDA_ASSERT(priv != NULL, return -1;);\r\nIRDA_ASSERT(priv->magic == IRTTY_MAGIC, return -1;);\r\ntty = priv->tty;\r\nmutex_lock(&tty->termios_mutex);\r\nold_termios = *(tty->termios);\r\ncflag = tty->termios->c_cflag;\r\ntty_encode_baud_rate(tty, speed, speed);\r\nif (tty->ops->set_termios)\r\ntty->ops->set_termios(tty, &old_termios);\r\npriv->io.speed = speed;\r\nmutex_unlock(&tty->termios_mutex);\r\nreturn 0;\r\n}\r\nstatic int irtty_set_dtr_rts(struct sir_dev *dev, int dtr, int rts)\r\n{\r\nstruct sirtty_cb *priv = dev->priv;\r\nint set = 0;\r\nint clear = 0;\r\nIRDA_ASSERT(priv != NULL, return -1;);\r\nIRDA_ASSERT(priv->magic == IRTTY_MAGIC, return -1;);\r\nif (rts)\r\nset |= TIOCM_RTS;\r\nelse\r\nclear |= TIOCM_RTS;\r\nif (dtr)\r\nset |= TIOCM_DTR;\r\nelse\r\nclear |= TIOCM_DTR;\r\nIRDA_ASSERT(priv->tty->ops->tiocmset != NULL, return -1;);\r\npriv->tty->ops->tiocmset(priv->tty, set, clear);\r\nreturn 0;\r\n}\r\nstatic int irtty_do_write(struct sir_dev *dev, const unsigned char *ptr, size_t len)\r\n{\r\nstruct sirtty_cb *priv = dev->priv;\r\nstruct tty_struct *tty;\r\nint writelen;\r\nIRDA_ASSERT(priv != NULL, return -1;);\r\nIRDA_ASSERT(priv->magic == IRTTY_MAGIC, return -1;);\r\ntty = priv->tty;\r\nif (!tty->ops->write)\r\nreturn 0;\r\nset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nwritelen = tty_write_room(tty);\r\nif (writelen > len)\r\nwritelen = len;\r\nreturn tty->ops->write(tty, ptr, writelen);\r\n}\r\nstatic void irtty_receive_buf(struct tty_struct *tty, const unsigned char *cp,\r\nchar *fp, int count)\r\n{\r\nstruct sir_dev *dev;\r\nstruct sirtty_cb *priv = tty->disc_data;\r\nint i;\r\nIRDA_ASSERT(priv != NULL, return;);\r\nIRDA_ASSERT(priv->magic == IRTTY_MAGIC, return;);\r\nif (unlikely(count==0))\r\nreturn;\r\ndev = priv->dev;\r\nif (!dev) {\r\nIRDA_WARNING("%s(), not ready yet!\n", __func__);\r\nreturn;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nif (fp && *fp++) {\r\nIRDA_DEBUG(0, "Framing or parity error!\n");\r\nsirdev_receive(dev, NULL, 0);\r\nreturn;\r\n}\r\n}\r\nsirdev_receive(dev, cp, count);\r\n}\r\nstatic void irtty_write_wakeup(struct tty_struct *tty)\r\n{\r\nstruct sirtty_cb *priv = tty->disc_data;\r\nIRDA_ASSERT(priv != NULL, return;);\r\nIRDA_ASSERT(priv->magic == IRTTY_MAGIC, return;);\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nif (priv->dev)\r\nsirdev_write_complete(priv->dev);\r\n}\r\nstatic inline void irtty_stop_receiver(struct tty_struct *tty, int stop)\r\n{\r\nstruct ktermios old_termios;\r\nint cflag;\r\nmutex_lock(&tty->termios_mutex);\r\nold_termios = *(tty->termios);\r\ncflag = tty->termios->c_cflag;\r\nif (stop)\r\ncflag &= ~CREAD;\r\nelse\r\ncflag |= CREAD;\r\ntty->termios->c_cflag = cflag;\r\nif (tty->ops->set_termios)\r\ntty->ops->set_termios(tty, &old_termios);\r\nmutex_unlock(&tty->termios_mutex);\r\n}\r\nstatic int irtty_start_dev(struct sir_dev *dev)\r\n{\r\nstruct sirtty_cb *priv;\r\nstruct tty_struct *tty;\r\nmutex_lock(&irtty_mutex);\r\npriv = dev->priv;\r\nif (unlikely(!priv || priv->magic!=IRTTY_MAGIC)) {\r\nmutex_unlock(&irtty_mutex);\r\nreturn -ESTALE;\r\n}\r\ntty = priv->tty;\r\nif (tty->ops->start)\r\ntty->ops->start(tty);\r\nirtty_stop_receiver(tty, FALSE);\r\nmutex_unlock(&irtty_mutex);\r\nreturn 0;\r\n}\r\nstatic int irtty_stop_dev(struct sir_dev *dev)\r\n{\r\nstruct sirtty_cb *priv;\r\nstruct tty_struct *tty;\r\nmutex_lock(&irtty_mutex);\r\npriv = dev->priv;\r\nif (unlikely(!priv || priv->magic!=IRTTY_MAGIC)) {\r\nmutex_unlock(&irtty_mutex);\r\nreturn -ESTALE;\r\n}\r\ntty = priv->tty;\r\nirtty_stop_receiver(tty, TRUE);\r\nif (tty->ops->stop)\r\ntty->ops->stop(tty);\r\nmutex_unlock(&irtty_mutex);\r\nreturn 0;\r\n}\r\nstatic int irtty_ioctl(struct tty_struct *tty, struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct irtty_info { char name[6]; } info;\r\nstruct sir_dev *dev;\r\nstruct sirtty_cb *priv = tty->disc_data;\r\nint err = 0;\r\nIRDA_ASSERT(priv != NULL, return -ENODEV;);\r\nIRDA_ASSERT(priv->magic == IRTTY_MAGIC, return -EBADR;);\r\nIRDA_DEBUG(3, "%s(cmd=0x%X)\n", __func__, cmd);\r\ndev = priv->dev;\r\nIRDA_ASSERT(dev != NULL, return -1;);\r\nswitch (cmd) {\r\ncase IRTTY_IOCTDONGLE:\r\nerr = sirdev_set_dongle(dev, (IRDA_DONGLE) arg);\r\nbreak;\r\ncase IRTTY_IOCGET:\r\nIRDA_ASSERT(dev->netdev != NULL, return -1;);\r\nmemset(&info, 0, sizeof(info));\r\nstrncpy(info.name, dev->netdev->name, sizeof(info.name)-1);\r\nif (copy_to_user((void __user *)arg, &info, sizeof(info)))\r\nerr = -EFAULT;\r\nbreak;\r\ndefault:\r\nerr = tty_mode_ioctl(tty, file, cmd, arg);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int irtty_open(struct tty_struct *tty)\r\n{\r\nstruct sir_dev *dev;\r\nstruct sirtty_cb *priv;\r\nint ret = 0;\r\nif (tty->disc_data != NULL) {\r\npriv = tty->disc_data;\r\nif (priv && priv->magic == IRTTY_MAGIC) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\ntty->disc_data = NULL;\r\n}\r\nirtty_stop_receiver(tty, TRUE);\r\nif (tty->ops->stop)\r\ntty->ops->stop(tty);\r\ntty_driver_flush_buffer(tty);\r\nsir_tty_drv.qos_mtt_bits = qos_mtt_bits;\r\ndev = sirdev_get_instance(&sir_tty_drv, tty->name);\r\nif (!dev) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\ngoto out_put;\r\npriv->magic = IRTTY_MAGIC;\r\npriv->tty = tty;\r\npriv->dev = dev;\r\nmutex_lock(&irtty_mutex);\r\ndev->priv = priv;\r\ntty->disc_data = priv;\r\ntty->receive_room = 65536;\r\nmutex_unlock(&irtty_mutex);\r\nIRDA_DEBUG(0, "%s - %s: irda line discipline opened\n", __func__, tty->name);\r\nreturn 0;\r\nout_put:\r\nsirdev_put_instance(dev);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void irtty_close(struct tty_struct *tty)\r\n{\r\nstruct sirtty_cb *priv = tty->disc_data;\r\nIRDA_ASSERT(priv != NULL, return;);\r\nIRDA_ASSERT(priv->magic == IRTTY_MAGIC, return;);\r\ntty->disc_data = NULL;\r\nsirdev_put_instance(priv->dev);\r\nirtty_stop_receiver(tty, TRUE);\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nif (tty->ops->stop)\r\ntty->ops->stop(tty);\r\nkfree(priv);\r\nIRDA_DEBUG(0, "%s - %s: irda line discipline closed\n", __func__, tty->name);\r\n}\r\nstatic int __init irtty_sir_init(void)\r\n{\r\nint err;\r\nif ((err = tty_register_ldisc(N_IRDA, &irda_ldisc)) != 0)\r\nIRDA_ERROR("IrDA: can't register line discipline (err = %d)\n",\r\nerr);\r\nreturn err;\r\n}\r\nstatic void __exit irtty_sir_cleanup(void)\r\n{\r\nint err;\r\nif ((err = tty_unregister_ldisc(N_IRDA))) {\r\nIRDA_ERROR("%s(), can't unregister line discipline (err = %d)\n",\r\n__func__, err);\r\n}\r\n}
