static void print_tx_state(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv = netdev_priv(dev);\r\nstruct xl_tx_desc *txd ;\r\nu8 __iomem *xl_mmio = xl_priv->xl_mmio ;\r\nint i ;\r\nprintk("tx_ring_head: %d, tx_ring_tail: %d, free_ent: %d\n",xl_priv->tx_ring_head,\r\nxl_priv->tx_ring_tail, xl_priv->free_ring_entries) ;\r\nprintk("Ring , Address , FSH , DnNextPtr, Buffer, Buffer_Len\n");\r\nfor (i = 0; i < 16; i++) {\r\ntxd = &(xl_priv->xl_tx_ring[i]) ;\r\nprintk("%d, %08lx, %08x, %08x, %08x, %08x\n", i, virt_to_bus(txd),\r\ntxd->framestartheader, txd->dnnextptr, txd->buffer, txd->buffer_length ) ;\r\n}\r\nprintk("DNLISTPTR = %04x\n", readl(xl_mmio + MMIO_DNLISTPTR) );\r\nprintk("DmaCtl = %04x\n", readl(xl_mmio + MMIO_DMA_CTRL) );\r\nprintk("Queue status = %0x\n",netif_running(dev) ) ;\r\n}\r\nstatic void print_rx_state(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv = netdev_priv(dev);\r\nstruct xl_rx_desc *rxd ;\r\nu8 __iomem *xl_mmio = xl_priv->xl_mmio ;\r\nint i ;\r\nprintk("rx_ring_tail: %d\n", xl_priv->rx_ring_tail);\r\nprintk("Ring , Address , FrameState , UPNextPtr, FragAddr, Frag_Len\n");\r\nfor (i = 0; i < 16; i++) {\r\nrxd = &(xl_priv->xl_rx_ring[i]) ;\r\nprintk("%d, %08lx, %08x, %08x, %08x, %08x\n", i, virt_to_bus(rxd),\r\nrxd->framestatus, rxd->upnextptr, rxd->upfragaddr, rxd->upfraglen ) ;\r\n}\r\nprintk("UPLISTPTR = %04x\n", readl(xl_mmio + MMIO_UPLISTPTR));\r\nprintk("DmaCtl = %04x\n", readl(xl_mmio + MMIO_DMA_CTRL));\r\nprintk("Queue status = %0x\n",netif_running(dev));\r\n}\r\nstatic u16 xl_ee_read(struct net_device *dev, int ee_addr)\r\n{\r\nstruct xl_private *xl_priv = netdev_priv(dev);\r\nu8 __iomem *xl_mmio = xl_priv->xl_mmio ;\r\nwritel(IO_WORD_READ | EECONTROL, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwhile ( readw(xl_mmio + MMIO_MACDATA) & EEBUSY ) ;\r\nwritel(IO_WORD_WRITE | EECONTROL, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwritew(EEREAD + ee_addr, xl_mmio + MMIO_MACDATA) ;\r\nwritel(IO_WORD_READ | EECONTROL, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwhile ( readw(xl_mmio + MMIO_MACDATA) & EEBUSY ) ;\r\nwritel(IO_WORD_WRITE | EECONTROL , xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwritew(EEREAD + ee_addr, xl_mmio + MMIO_MACDATA) ;\r\nwritel(IO_WORD_READ | EEDATA , xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nreturn readw(xl_mmio + MMIO_MACDATA) ;\r\n}\r\nstatic void xl_ee_write(struct net_device *dev, int ee_addr, u16 ee_value)\r\n{\r\nstruct xl_private *xl_priv = netdev_priv(dev);\r\nu8 __iomem *xl_mmio = xl_priv->xl_mmio ;\r\nwritel(IO_WORD_READ | EECONTROL, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwhile ( readw(xl_mmio + MMIO_MACDATA) & EEBUSY ) ;\r\nwritel(IO_WORD_WRITE | EECONTROL, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwritew(EE_ENABLE_WRITE, xl_mmio + MMIO_MACDATA) ;\r\nwritel(IO_WORD_READ | EECONTROL, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwhile ( readw(xl_mmio + MMIO_MACDATA) & EEBUSY ) ;\r\nwritel(IO_WORD_WRITE | EEDATA, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwritew(ee_value, xl_mmio + MMIO_MACDATA) ;\r\nwritel(IO_WORD_WRITE | EECONTROL, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwritew(EEWRITE + ee_addr, xl_mmio + MMIO_MACDATA) ;\r\nwritel(IO_WORD_READ | EECONTROL, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwhile ( readw(xl_mmio + MMIO_MACDATA) & EEBUSY ) ;\r\nreturn ;\r\n}\r\nstatic int __devinit xl_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev ;\r\nstruct xl_private *xl_priv ;\r\nstatic int card_no = -1 ;\r\nint i ;\r\ncard_no++ ;\r\nif (pci_enable_device(pdev)) {\r\nreturn -ENODEV ;\r\n}\r\npci_set_master(pdev);\r\nif ((i = pci_request_regions(pdev,"3c359"))) {\r\nreturn i ;\r\n}\r\ndev = alloc_trdev(sizeof(struct xl_private)) ;\r\nif (!dev) {\r\npci_release_regions(pdev) ;\r\nreturn -ENOMEM ;\r\n}\r\nxl_priv = netdev_priv(dev);\r\n#if XL_DEBUG\r\nprintk("pci_device: %p, dev:%p, dev->priv: %p, ba[0]: %10x, ba[1]:%10x\n",\r\npdev, dev, netdev_priv(dev), (unsigned int)pdev->resource[0].start, (unsigned int)pdev->resource[1].start);\r\n#endif\r\ndev->irq=pdev->irq;\r\ndev->base_addr=pci_resource_start(pdev,0) ;\r\nxl_priv->xl_card_name = pci_name(pdev);\r\nxl_priv->xl_mmio=ioremap(pci_resource_start(pdev,1), XL_IO_SPACE);\r\nxl_priv->pdev = pdev ;\r\nif ((pkt_buf_sz[card_no] < 100) || (pkt_buf_sz[card_no] > 18000) )\r\nxl_priv->pkt_buf_sz = PKT_BUF_SZ ;\r\nelse\r\nxl_priv->pkt_buf_sz = pkt_buf_sz[card_no] ;\r\ndev->mtu = xl_priv->pkt_buf_sz - TR_HLEN ;\r\nxl_priv->xl_ring_speed = ringspeed[card_no] ;\r\nxl_priv->xl_message_level = message_level[card_no] ;\r\nxl_priv->xl_functional_addr[0] = xl_priv->xl_functional_addr[1] = xl_priv->xl_functional_addr[2] = xl_priv->xl_functional_addr[3] = 0 ;\r\nxl_priv->xl_copy_all_options = 0 ;\r\nif((i = xl_init(dev))) {\r\niounmap(xl_priv->xl_mmio) ;\r\nfree_netdev(dev) ;\r\npci_release_regions(pdev) ;\r\nreturn i ;\r\n}\r\ndev->netdev_ops = &xl_netdev_ops;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\npci_set_drvdata(pdev,dev) ;\r\nif ((i = register_netdev(dev))) {\r\nprintk(KERN_ERR "3C359, register netdev failed\n") ;\r\npci_set_drvdata(pdev,NULL) ;\r\niounmap(xl_priv->xl_mmio) ;\r\nfree_netdev(dev) ;\r\npci_release_regions(pdev) ;\r\nreturn i ;\r\n}\r\nprintk(KERN_INFO "3C359: %s registered as: %s\n",xl_priv->xl_card_name,dev->name) ;\r\nreturn 0;\r\n}\r\nstatic int xl_init_firmware(struct xl_private *xl_priv)\r\n{\r\nint err;\r\nerr = request_firmware(&xl_priv->fw, FW_NAME, &xl_priv->pdev->dev);\r\nif (err) {\r\nprintk(KERN_ERR "Failed to load firmware \"%s\"\n", FW_NAME);\r\nreturn err;\r\n}\r\nif (xl_priv->fw->size < 16) {\r\nprintk(KERN_ERR "Bogus length %zu in \"%s\"\n",\r\nxl_priv->fw->size, FW_NAME);\r\nrelease_firmware(xl_priv->fw);\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int __devinit xl_init(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv = netdev_priv(dev);\r\nint err;\r\nprintk(KERN_INFO "%s\n", version);\r\nprintk(KERN_INFO "%s: I/O at %hx, MMIO at %p, using irq %d\n",\r\nxl_priv->xl_card_name, (unsigned int)dev->base_addr ,xl_priv->xl_mmio, dev->irq);\r\nspin_lock_init(&xl_priv->xl_lock) ;\r\nerr = xl_init_firmware(xl_priv);\r\nif (err == 0)\r\nerr = xl_hw_reset(dev);\r\nreturn err;\r\n}\r\nstatic int xl_hw_reset(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv = netdev_priv(dev);\r\nu8 __iomem *xl_mmio = xl_priv->xl_mmio ;\r\nunsigned long t ;\r\nu16 i ;\r\nu16 result_16 ;\r\nu8 result_8 ;\r\nu16 start ;\r\nint j ;\r\nif (xl_priv->fw == NULL)\r\nreturn -EINVAL;\r\nwritew( GLOBAL_RESET, xl_mmio + MMIO_COMMAND ) ;\r\nt=jiffies;\r\nwhile (readw(xl_mmio + MMIO_INTSTATUS) & INTSTAT_CMD_IN_PROGRESS) {\r\nschedule();\r\nif (time_after(jiffies, t + 40 * HZ)) {\r\nprintk(KERN_ERR "%s: 3COM 3C359 Velocity XL card not responding to global reset.\n", dev->name);\r\nreturn -ENODEV;\r\n}\r\n}\r\nwritel( (IO_BYTE_READ | CPATTENTION), xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nresult_8 = readb(xl_mmio + MMIO_MACDATA) ;\r\nresult_8 = result_8 | CPA_PMBARVIS ;\r\nwritel( (IO_BYTE_WRITE | CPATTENTION), xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(result_8, xl_mmio + MMIO_MACDATA) ;\r\nwritel( (IO_WORD_READ | PMBAR),xl_mmio + MMIO_MAC_ACCESS_CMD);\r\n#if XL_DEBUG\r\nprintk(KERN_INFO "Read from PMBAR = %04x\n", readw(xl_mmio + MMIO_MACDATA));\r\n#endif\r\nif ( readw( (xl_mmio + MMIO_MACDATA)) & PMB_CPHOLD ) {\r\nwritel( (IO_WORD_READ | PMBAR),xl_mmio + MMIO_MAC_ACCESS_CMD);\r\nresult_16 = readw(xl_mmio + MMIO_MACDATA) ;\r\nresult_16 = result_16 & ~((0x7F) << 2) ;\r\nwritel( (IO_WORD_WRITE | PMBAR), xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwritew(result_16,xl_mmio + MMIO_MACDATA) ;\r\nwritel( (IO_BYTE_READ | CPATTENTION), xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nresult_8 = readb(xl_mmio + MMIO_MACDATA) ;\r\nresult_8 = result_8 | CPA_MEMWREN ;\r\nwritel( (IO_BYTE_WRITE | CPATTENTION), xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(result_8, xl_mmio + MMIO_MACDATA) ;\r\nstart = (0xFFFF - (xl_priv->fw->size) + 1) ;\r\nprintk(KERN_INFO "3C359: Uploading Microcode: ");\r\nfor (i = start, j = 0; j < xl_priv->fw->size; i++, j++) {\r\nwritel(MEM_BYTE_WRITE | 0XD0000 | i,\r\nxl_mmio + MMIO_MAC_ACCESS_CMD);\r\nwriteb(xl_priv->fw->data[j], xl_mmio + MMIO_MACDATA);\r\nif (j % 1024 == 0)\r\nprintk(".");\r\n}\r\nprintk("\n") ;\r\nfor (i = 0; i < 16; i++) {\r\nwritel((MEM_BYTE_WRITE | 0xDFFF0) + i,\r\nxl_mmio + MMIO_MAC_ACCESS_CMD);\r\nwriteb(xl_priv->fw->data[xl_priv->fw->size - 16 + i],\r\nxl_mmio + MMIO_MACDATA);\r\n}\r\nwritel(MEM_WORD_WRITE | 0xDFFF4, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwritew(start >> 4, xl_mmio + MMIO_MACDATA);\r\nwritel( (IO_BYTE_READ | CPATTENTION), xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nresult_8 = readb(xl_mmio + MMIO_MACDATA) ;\r\nresult_8 = result_8 & ~CPA_MEMWREN ;\r\nwritel( (IO_BYTE_WRITE | CPATTENTION), xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(result_8, xl_mmio + MMIO_MACDATA) ;\r\nwritel( (IO_WORD_READ | PMBAR),xl_mmio + MMIO_MAC_ACCESS_CMD);\r\nresult_16 = readw(xl_mmio + MMIO_MACDATA) ;\r\nresult_16 = result_16 & ~PMB_CPHOLD ;\r\nwritel( (IO_WORD_WRITE | PMBAR), xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwritew(result_16,xl_mmio + MMIO_MACDATA) ;\r\n}\r\n#if XL_DEBUG\r\nprintk(KERN_INFO "%s: Microcode uploaded, must wait for the self test to complete\n", dev->name);\r\n#endif\r\nwritew(SETINDENABLE | 0xFFF, xl_mmio + MMIO_COMMAND) ;\r\nt=jiffies;\r\nwhile ( !(readw(xl_mmio + MMIO_INTSTATUS_AUTO) & INTSTAT_SRB) ) {\r\nschedule();\r\nif (time_after(jiffies, t + 15 * HZ)) {\r\nprintk(KERN_ERR "3COM 3C359 Velocity XL card not responding.\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nwritel(MMIO_WORD_WRITE | RXBUFAREA, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwritew(0xD000, xl_mmio + MMIO_MACDATA) ;\r\nwritel(MMIO_WORD_WRITE | RXEARLYTHRESH, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwritew(0X0020, xl_mmio + MMIO_MACDATA) ;\r\nwritew( SETTXSTARTTHRESH | 0x40 , xl_mmio + MMIO_COMMAND) ;\r\nwriteb(0x04, xl_mmio + MMIO_DNBURSTTHRESH) ;\r\nwriteb(0x04, xl_mmio + DNPRIREQTHRESH) ;\r\nwritel(MMIO_BYTE_READ | WRBR, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nxl_priv->srb = readb(xl_mmio + MMIO_MACDATA) << 8 ;\r\nwritel( (MMIO_BYTE_READ | WRBR) + 1, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nxl_priv->srb = xl_priv->srb | readb(xl_mmio + MMIO_MACDATA) ;\r\n#if XL_DEBUG\r\nwritel(IO_WORD_READ | SWITCHSETTINGS, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nif ( readw(xl_mmio + MMIO_MACDATA) & 2) {\r\nprintk(KERN_INFO "Default ring speed 4 mbps\n");\r\n} else {\r\nprintk(KERN_INFO "Default ring speed 16 mbps\n");\r\n}\r\nprintk(KERN_INFO "%s: xl_priv->srb = %04x\n",xl_priv->xl_card_name, xl_priv->srb);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int xl_open(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv=netdev_priv(dev);\r\nu8 __iomem *xl_mmio = xl_priv->xl_mmio ;\r\nu8 i ;\r\n__le16 hwaddr[3] ;\r\nint open_err ;\r\nu16 switchsettings, switchsettings_eeprom ;\r\nif (request_irq(dev->irq, xl_interrupt, IRQF_SHARED , "3c359", dev))\r\nreturn -EAGAIN;\r\nhwaddr[0] = cpu_to_le16(xl_ee_read(dev,0x10));\r\nhwaddr[1] = cpu_to_le16(xl_ee_read(dev,0x11));\r\nhwaddr[2] = cpu_to_le16(xl_ee_read(dev,0x12));\r\nswitchsettings_eeprom = xl_ee_read(dev,0x08) ;\r\nswitchsettings = switchsettings_eeprom ;\r\nif (xl_priv->xl_ring_speed != 0) {\r\nif (xl_priv->xl_ring_speed == 4)\r\nswitchsettings = switchsettings | 0x02 ;\r\nelse\r\nswitchsettings = switchsettings & ~0x02 ;\r\n}\r\nif (switchsettings != switchsettings_eeprom) {\r\nxl_ee_write(dev,0x08,switchsettings) ;\r\nxl_hw_reset(dev) ;\r\n}\r\nmemcpy(dev->dev_addr,hwaddr,dev->addr_len) ;\r\nopen_err = xl_open_hw(dev) ;\r\nif (open_err != 0) {\r\nif (open_err & 0x07) {\r\nprintk(KERN_WARNING "%s: Open Error, retrying at different ringspeed\n", dev->name);\r\nswitchsettings = switchsettings ^ 2 ;\r\nxl_ee_write(dev,0x08,switchsettings) ;\r\nxl_hw_reset(dev) ;\r\nopen_err = xl_open_hw(dev) ;\r\nif (open_err != 0) {\r\nprintk(KERN_WARNING "%s: Open error returned a second time, we're bombing out now\n", dev->name);\r\nfree_irq(dev->irq,dev) ;\r\nreturn -ENODEV ;\r\n}\r\n} else {\r\nprintk(KERN_WARNING "%s: Open Error = %04x\n", dev->name, open_err) ;\r\nfree_irq(dev->irq,dev) ;\r\nreturn -ENODEV ;\r\n}\r\n}\r\nxl_priv->xl_tx_ring = kzalloc((sizeof(struct xl_tx_desc) * XL_TX_RING_SIZE) + 7, GFP_DMA | GFP_KERNEL);\r\nif (xl_priv->xl_tx_ring == NULL) {\r\nprintk(KERN_WARNING "%s: Not enough memory to allocate tx buffers.\n",\r\ndev->name);\r\nfree_irq(dev->irq,dev);\r\nreturn -ENOMEM;\r\n}\r\nxl_priv->xl_rx_ring = kzalloc((sizeof(struct xl_rx_desc) * XL_RX_RING_SIZE) +7, GFP_DMA | GFP_KERNEL);\r\nif (xl_priv->xl_rx_ring == NULL) {\r\nprintk(KERN_WARNING "%s: Not enough memory to allocate rx buffers.\n",\r\ndev->name);\r\nfree_irq(dev->irq,dev);\r\nkfree(xl_priv->xl_tx_ring);\r\nreturn -ENOMEM;\r\n}\r\nfor (i=0 ; i < XL_RX_RING_SIZE ; i++) {\r\nstruct sk_buff *skb ;\r\nskb = dev_alloc_skb(xl_priv->pkt_buf_sz) ;\r\nif (skb==NULL)\r\nbreak ;\r\nskb->dev = dev ;\r\nxl_priv->xl_rx_ring[i].upfragaddr = cpu_to_le32(pci_map_single(xl_priv->pdev, skb->data,xl_priv->pkt_buf_sz, PCI_DMA_FROMDEVICE));\r\nxl_priv->xl_rx_ring[i].upfraglen = cpu_to_le32(xl_priv->pkt_buf_sz) | RXUPLASTFRAG;\r\nxl_priv->rx_ring_skb[i] = skb ;\r\n}\r\nif (i==0) {\r\nprintk(KERN_WARNING "%s: Not enough memory to allocate rx buffers. Adapter disabled\n",dev->name);\r\nfree_irq(dev->irq,dev) ;\r\nkfree(xl_priv->xl_tx_ring);\r\nkfree(xl_priv->xl_rx_ring);\r\nreturn -EIO ;\r\n}\r\nxl_priv->rx_ring_no = i ;\r\nxl_priv->rx_ring_tail = 0 ;\r\nxl_priv->rx_ring_dma_addr = pci_map_single(xl_priv->pdev,xl_priv->xl_rx_ring, sizeof(struct xl_rx_desc) * XL_RX_RING_SIZE, PCI_DMA_TODEVICE) ;\r\nfor (i=0;i<(xl_priv->rx_ring_no-1);i++) {\r\nxl_priv->xl_rx_ring[i].upnextptr = cpu_to_le32(xl_priv->rx_ring_dma_addr + (sizeof (struct xl_rx_desc) * (i+1)));\r\n}\r\nxl_priv->xl_rx_ring[i].upnextptr = 0 ;\r\nwritel(xl_priv->rx_ring_dma_addr, xl_mmio + MMIO_UPLISTPTR) ;\r\nxl_priv->tx_ring_dma_addr = pci_map_single(xl_priv->pdev,xl_priv->xl_tx_ring, sizeof(struct xl_tx_desc) * XL_TX_RING_SIZE,PCI_DMA_TODEVICE) ;\r\nxl_priv->tx_ring_head = 1 ;\r\nxl_priv->tx_ring_tail = 255 ;\r\nxl_priv->free_ring_entries = XL_TX_RING_SIZE ;\r\nxl_priv->xl_tx_ring[0].framestartheader = TXDPDEMPTY;\r\nxl_priv->xl_tx_ring[0].buffer = 0 ;\r\nxl_priv->xl_tx_ring[0].buffer_length = 0 ;\r\nxl_priv->xl_tx_ring[0].dnnextptr = 0 ;\r\nwritel(xl_priv->tx_ring_dma_addr, xl_mmio + MMIO_DNLISTPTR) ;\r\nwritel(DNUNSTALL, xl_mmio + MMIO_COMMAND) ;\r\nwritel(UPUNSTALL, xl_mmio + MMIO_COMMAND) ;\r\nwritel(DNENABLE, xl_mmio + MMIO_COMMAND) ;\r\nwriteb(0x40, xl_mmio + MMIO_DNPOLL) ;\r\nwritel(SETINTENABLE | INT_MASK, xl_mmio + MMIO_COMMAND) ;\r\nwritel(SETINDENABLE | INT_MASK, xl_mmio + MMIO_COMMAND) ;\r\nnetif_start_queue(dev) ;\r\nreturn 0;\r\n}\r\nstatic int xl_open_hw(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv=netdev_priv(dev);\r\nu8 __iomem *xl_mmio = xl_priv->xl_mmio ;\r\nu16 vsoff ;\r\nchar ver_str[33];\r\nint open_err ;\r\nint i ;\r\nunsigned long t ;\r\nwritel( (MEM_BYTE_WRITE | 0xD0000 | xl_priv->srb), xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(OPEN_NIC, xl_mmio + MMIO_MACDATA) ;\r\nwritel( (MEM_BYTE_WRITE | 0xD0000 | xl_priv->srb)+ 2, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(0xff,xl_mmio + MMIO_MACDATA) ;\r\nwritel( (MEM_BYTE_WRITE | 0xD0000 | xl_priv->srb) + 8, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(0x00, xl_mmio + MMIO_MACDATA) ;\r\nwritel( (MEM_BYTE_WRITE | 0xD0000 | xl_priv->srb) + 9, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(0x00, xl_mmio + MMIO_MACDATA) ;\r\nif (xl_priv->xl_laa[0]) {\r\nfor (i=10;i<16;i++) {\r\nwritel( (MEM_BYTE_WRITE | 0xD0000 | xl_priv->srb) + i, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(xl_priv->xl_laa[i-10],xl_mmio + MMIO_MACDATA) ;\r\n}\r\nmemcpy(dev->dev_addr,xl_priv->xl_laa,dev->addr_len) ;\r\n} else {\r\nfor (i=10;i<16;i++) {\r\nwritel( (MEM_BYTE_WRITE | 0xD0000 | xl_priv->srb) + i, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(dev->dev_addr[i-10], xl_mmio + MMIO_MACDATA) ;\r\n}\r\n}\r\nfor (i = 16; i < 34; i++) {\r\nwritel( (MEM_BYTE_WRITE | 0xD0000 | xl_priv->srb) + i, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(0x00,xl_mmio + MMIO_MACDATA) ;\r\n}\r\nxl_wait_misr_flags(dev) ;\r\nwritel(MEM_BYTE_WRITE | MF_CSRB, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(0xFF, xl_mmio + MMIO_MACDATA) ;\r\nwritel(MMIO_BYTE_WRITE | MISR_SET, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(MISR_CSRB , xl_mmio + MMIO_MACDATA) ;\r\nt=jiffies;\r\nwhile (! (readw(xl_mmio + MMIO_INTSTATUS) & INTSTAT_SRB)) {\r\nschedule();\r\nif (time_after(jiffies, t + 40 * HZ)) {\r\nprintk(KERN_ERR "3COM 3C359 Velocity XL card not responding.\n");\r\nbreak ;\r\n}\r\n}\r\nwritel( (MEM_BYTE_READ | 0xD0000 | xl_priv->srb)+2, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nif (readb(xl_mmio + MMIO_MACDATA)!=0) {\r\nopen_err = readb(xl_mmio + MMIO_MACDATA) << 8 ;\r\nwritel( (MEM_BYTE_READ | 0xD0000 | xl_priv->srb) + 7, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nopen_err |= readb(xl_mmio + MMIO_MACDATA) ;\r\nreturn open_err ;\r\n} else {\r\nwritel( (MEM_WORD_READ | 0xD0000 | xl_priv->srb) + 8, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nxl_priv->asb = swab16(readw(xl_mmio + MMIO_MACDATA)) ;\r\nprintk(KERN_INFO "%s: Adapter Opened Details: ",dev->name) ;\r\nprintk("ASB: %04x",xl_priv->asb ) ;\r\nwritel( (MEM_WORD_READ | 0xD0000 | xl_priv->srb) + 10, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nprintk(", SRB: %04x",swab16(readw(xl_mmio + MMIO_MACDATA)) ) ;\r\nwritel( (MEM_WORD_READ | 0xD0000 | xl_priv->srb) + 12, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nxl_priv->arb = swab16(readw(xl_mmio + MMIO_MACDATA)) ;\r\nprintk(", ARB: %04x\n",xl_priv->arb );\r\nwritel( (MEM_WORD_READ | 0xD0000 | xl_priv->srb) + 14, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nvsoff = swab16(readw(xl_mmio + MMIO_MACDATA)) ;\r\nfor (i=0;i<0x20;i++) {\r\nwritel( (MEM_BYTE_READ | 0xD0000 | vsoff) + i, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nver_str[i] = readb(xl_mmio + MMIO_MACDATA) ;\r\n}\r\nver_str[i] = '\0' ;\r\nprintk(KERN_INFO "%s: Microcode version String: %s\n",dev->name,ver_str);\r\n}\r\nwritew(ACK_INTERRUPT | SRBRACK | LATCH_ACK, xl_mmio + MMIO_COMMAND) ;\r\nreturn 0 ;\r\n}\r\nstatic void adv_rx_ring(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv=netdev_priv(dev);\r\nint n = xl_priv->rx_ring_tail;\r\nint prev_ring_loc;\r\nprev_ring_loc = (n + XL_RX_RING_SIZE - 1) & (XL_RX_RING_SIZE - 1);\r\nxl_priv->xl_rx_ring[prev_ring_loc].upnextptr = cpu_to_le32(xl_priv->rx_ring_dma_addr + (sizeof (struct xl_rx_desc) * n));\r\nxl_priv->xl_rx_ring[n].framestatus = 0;\r\nxl_priv->xl_rx_ring[n].upnextptr = 0;\r\nxl_priv->rx_ring_tail++;\r\nxl_priv->rx_ring_tail &= (XL_RX_RING_SIZE-1);\r\n}\r\nstatic void xl_rx(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv=netdev_priv(dev);\r\nu8 __iomem * xl_mmio = xl_priv->xl_mmio ;\r\nstruct sk_buff *skb, *skb2 ;\r\nint frame_length = 0, copy_len = 0 ;\r\nint temp_ring_loc ;\r\nwhile (xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].framestatus & (RXUPDCOMPLETE | RXUPDFULL) ) {\r\nif (xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].framestatus & RXUPDFULL ) {\r\ntemp_ring_loc = xl_priv->rx_ring_tail ;\r\nwhile (xl_priv->xl_rx_ring[temp_ring_loc].framestatus & RXUPDFULL ) {\r\ntemp_ring_loc++ ;\r\ntemp_ring_loc &= (XL_RX_RING_SIZE-1) ;\r\n}\r\nframe_length = le32_to_cpu(xl_priv->xl_rx_ring[temp_ring_loc].framestatus) & 0x7FFF;\r\nskb = dev_alloc_skb(frame_length) ;\r\nif (skb==NULL) {\r\nprintk(KERN_WARNING "%s: dev_alloc_skb failed - multi buffer !\n", dev->name) ;\r\nwhile (xl_priv->rx_ring_tail != temp_ring_loc)\r\nadv_rx_ring(dev) ;\r\nadv_rx_ring(dev) ;\r\ndev->stats.rx_dropped++ ;\r\nwritel(ACK_INTERRUPT | UPCOMPACK | LATCH_ACK , xl_mmio + MMIO_COMMAND) ;\r\nreturn ;\r\n}\r\nwhile (xl_priv->rx_ring_tail != temp_ring_loc) {\r\ncopy_len = le32_to_cpu(xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].upfraglen) & 0x7FFF;\r\nframe_length -= copy_len ;\r\npci_dma_sync_single_for_cpu(xl_priv->pdev,le32_to_cpu(xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].upfragaddr),xl_priv->pkt_buf_sz,PCI_DMA_FROMDEVICE);\r\nskb_copy_from_linear_data(xl_priv->rx_ring_skb[xl_priv->rx_ring_tail],\r\nskb_put(skb, copy_len),\r\ncopy_len);\r\npci_dma_sync_single_for_device(xl_priv->pdev,le32_to_cpu(xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].upfragaddr),xl_priv->pkt_buf_sz,PCI_DMA_FROMDEVICE);\r\nadv_rx_ring(dev) ;\r\n}\r\npci_dma_sync_single_for_cpu(xl_priv->pdev,le32_to_cpu(xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].upfragaddr),xl_priv->pkt_buf_sz,PCI_DMA_FROMDEVICE);\r\nskb_copy_from_linear_data(xl_priv->rx_ring_skb[xl_priv->rx_ring_tail],\r\nskb_put(skb,copy_len), frame_length);\r\npci_dma_sync_single_for_device(xl_priv->pdev,le32_to_cpu(xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].upfragaddr),xl_priv->pkt_buf_sz,PCI_DMA_FROMDEVICE);\r\nadv_rx_ring(dev) ;\r\nskb->protocol = tr_type_trans(skb,dev) ;\r\nnetif_rx(skb) ;\r\n} else {\r\nframe_length = le32_to_cpu(xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].framestatus) & 0x7FFF;\r\nskb = dev_alloc_skb(xl_priv->pkt_buf_sz) ;\r\nif (skb==NULL) {\r\nprintk(KERN_WARNING "%s: dev_alloc_skb failed in rx, single buffer\n",dev->name);\r\nadv_rx_ring(dev) ;\r\ndev->stats.rx_dropped++ ;\r\nwritel(ACK_INTERRUPT | UPCOMPACK | LATCH_ACK , xl_mmio + MMIO_COMMAND) ;\r\nreturn ;\r\n}\r\nskb2 = xl_priv->rx_ring_skb[xl_priv->rx_ring_tail] ;\r\npci_unmap_single(xl_priv->pdev, le32_to_cpu(xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].upfragaddr), xl_priv->pkt_buf_sz,PCI_DMA_FROMDEVICE) ;\r\nskb_put(skb2, frame_length) ;\r\nskb2->protocol = tr_type_trans(skb2,dev) ;\r\nxl_priv->rx_ring_skb[xl_priv->rx_ring_tail] = skb ;\r\nxl_priv->xl_rx_ring[xl_priv->rx_ring_tail].upfragaddr = cpu_to_le32(pci_map_single(xl_priv->pdev,skb->data,xl_priv->pkt_buf_sz, PCI_DMA_FROMDEVICE));\r\nxl_priv->xl_rx_ring[xl_priv->rx_ring_tail].upfraglen = cpu_to_le32(xl_priv->pkt_buf_sz) | RXUPLASTFRAG;\r\nadv_rx_ring(dev) ;\r\ndev->stats.rx_packets++ ;\r\ndev->stats.rx_bytes += frame_length ;\r\nnetif_rx(skb2) ;\r\n}\r\n}\r\nwritel(ACK_INTERRUPT | UPCOMPACK | LATCH_ACK , xl_mmio + MMIO_COMMAND) ;\r\nreturn ;\r\n}\r\nstatic void xl_reset(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv=netdev_priv(dev);\r\nu8 __iomem * xl_mmio = xl_priv->xl_mmio ;\r\nunsigned long t;\r\nwritew( GLOBAL_RESET, xl_mmio + MMIO_COMMAND ) ;\r\nt=jiffies;\r\nwhile (readw(xl_mmio + MMIO_INTSTATUS) & INTSTAT_CMD_IN_PROGRESS) {\r\nif (time_after(jiffies, t + 40 * HZ)) {\r\nprintk(KERN_ERR "3COM 3C359 Velocity XL card not responding.\n");\r\nbreak ;\r\n}\r\n}\r\n}\r\nstatic void xl_freemem(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv=netdev_priv(dev);\r\nint i ;\r\nfor (i=0;i<XL_RX_RING_SIZE;i++) {\r\ndev_kfree_skb_irq(xl_priv->rx_ring_skb[xl_priv->rx_ring_tail]) ;\r\npci_unmap_single(xl_priv->pdev,le32_to_cpu(xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].upfragaddr),xl_priv->pkt_buf_sz, PCI_DMA_FROMDEVICE);\r\nxl_priv->rx_ring_tail++ ;\r\nxl_priv->rx_ring_tail &= XL_RX_RING_SIZE-1;\r\n}\r\npci_unmap_single(xl_priv->pdev,xl_priv->rx_ring_dma_addr, sizeof(struct xl_rx_desc) * XL_RX_RING_SIZE, PCI_DMA_FROMDEVICE) ;\r\npci_unmap_single(xl_priv->pdev,xl_priv->tx_ring_dma_addr, sizeof(struct xl_tx_desc) * XL_TX_RING_SIZE, PCI_DMA_TODEVICE) ;\r\nkfree(xl_priv->xl_rx_ring) ;\r\nkfree(xl_priv->xl_tx_ring) ;\r\nreturn ;\r\n}\r\nstatic irqreturn_t xl_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct xl_private *xl_priv =netdev_priv(dev);\r\nu8 __iomem * xl_mmio = xl_priv->xl_mmio ;\r\nu16 intstatus, macstatus ;\r\nintstatus = readw(xl_mmio + MMIO_INTSTATUS) ;\r\nif (!(intstatus & 1))\r\nreturn IRQ_NONE;\r\nspin_lock(&xl_priv->xl_lock) ;\r\nif (intstatus == 0x0001) {\r\nwritel(ACK_INTERRUPT | LATCH_ACK, xl_mmio + MMIO_COMMAND) ;\r\nprintk(KERN_INFO "%s: 00001 int received\n",dev->name);\r\n} else {\r\nif (intstatus & (HOSTERRINT | SRBRINT | ARBCINT | UPCOMPINT | DNCOMPINT | HARDERRINT | (1<<8) | TXUNDERRUN | ASBFINT)) {\r\nif (intstatus & HOSTERRINT) {\r\nprintk(KERN_WARNING "%s: Host Error, performing global reset, intstatus = %04x\n",dev->name,intstatus);\r\nwritew( GLOBAL_RESET, xl_mmio + MMIO_COMMAND ) ;\r\nprintk(KERN_WARNING "%s: Resetting hardware:\n", dev->name);\r\nnetif_stop_queue(dev) ;\r\nxl_freemem(dev) ;\r\nfree_irq(dev->irq,dev);\r\nxl_reset(dev) ;\r\nwritel(ACK_INTERRUPT | LATCH_ACK, xl_mmio + MMIO_COMMAND) ;\r\nspin_unlock(&xl_priv->xl_lock) ;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (intstatus & SRBRINT ) {\r\nwritel(ACK_INTERRUPT | SRBRACK | LATCH_ACK, xl_mmio + MMIO_COMMAND) ;\r\nif (xl_priv->srb_queued)\r\nxl_srb_bh(dev) ;\r\n}\r\nif (intstatus & TXUNDERRUN) {\r\nwritel(DNRESET, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwhile (readw(xl_mmio + MMIO_INTSTATUS) & INTSTAT_CMD_IN_PROGRESS) {\r\n}\r\nprintk(KERN_WARNING "%s: TX Underrun received\n",dev->name);\r\nwritel(ACK_INTERRUPT | LATCH_ACK, xl_mmio + MMIO_COMMAND) ;\r\n}\r\nif (intstatus & ARBCINT ) {\r\nxl_arb_cmd(dev) ;\r\n}\r\nif (intstatus & ASBFINT) {\r\nif (xl_priv->asb_queued == 1) {\r\nxl_asb_cmd(dev) ;\r\n} else if (xl_priv->asb_queued == 2) {\r\nxl_asb_bh(dev) ;\r\n} else {\r\nwritel(ACK_INTERRUPT | LATCH_ACK | ASBFACK, xl_mmio + MMIO_COMMAND) ;\r\n}\r\n}\r\nif (intstatus & UPCOMPINT )\r\nxl_rx(dev) ;\r\nif (intstatus & DNCOMPINT )\r\nxl_dn_comp(dev) ;\r\nif (intstatus & HARDERRINT ) {\r\nwritel(MMIO_WORD_READ | MACSTATUS, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nmacstatus = readw(xl_mmio + MMIO_MACDATA) ;\r\nprintk(KERN_WARNING "%s: MacStatusError, details: ", dev->name);\r\nif (macstatus & (1<<14))\r\nprintk(KERN_WARNING "tchk error: Unrecoverable error\n");\r\nif (macstatus & (1<<3))\r\nprintk(KERN_WARNING "eint error: Internal watchdog timer expired\n");\r\nif (macstatus & (1<<2))\r\nprintk(KERN_WARNING "aint error: Host tried to perform invalid operation\n");\r\nprintk(KERN_WARNING "Instatus = %02x, macstatus = %02x\n",intstatus,macstatus) ;\r\nprintk(KERN_WARNING "%s: Resetting hardware:\n", dev->name);\r\nnetif_stop_queue(dev) ;\r\nxl_freemem(dev) ;\r\nfree_irq(dev->irq,dev);\r\nunregister_netdev(dev) ;\r\nfree_netdev(dev) ;\r\nxl_reset(dev) ;\r\nwritel(ACK_INTERRUPT | LATCH_ACK, xl_mmio + MMIO_COMMAND) ;\r\nspin_unlock(&xl_priv->xl_lock) ;\r\nreturn IRQ_HANDLED;\r\n}\r\n} else {\r\nprintk(KERN_WARNING "%s: Received Unknown interrupt : %04x\n", dev->name, intstatus);\r\nwritel(ACK_INTERRUPT | LATCH_ACK, xl_mmio + MMIO_COMMAND) ;\r\n}\r\n}\r\nwritel( SETINDENABLE | INT_MASK, xl_mmio + MMIO_COMMAND) ;\r\nwritel( SETINTENABLE | INT_MASK, xl_mmio + MMIO_COMMAND) ;\r\nspin_unlock(&xl_priv->xl_lock) ;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic netdev_tx_t xl_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv=netdev_priv(dev);\r\nstruct xl_tx_desc *txd ;\r\nint tx_head, tx_tail, tx_prev ;\r\nunsigned long flags ;\r\nspin_lock_irqsave(&xl_priv->xl_lock,flags) ;\r\nnetif_stop_queue(dev) ;\r\nif (xl_priv->free_ring_entries > 1 ) {\r\ntx_head = xl_priv->tx_ring_head ;\r\ntx_tail = xl_priv->tx_ring_tail ;\r\ntxd = &(xl_priv->xl_tx_ring[tx_head]) ;\r\ntxd->dnnextptr = 0 ;\r\ntxd->framestartheader = cpu_to_le32(skb->len) | TXDNINDICATE;\r\ntxd->buffer = cpu_to_le32(pci_map_single(xl_priv->pdev, skb->data, skb->len, PCI_DMA_TODEVICE));\r\ntxd->buffer_length = cpu_to_le32(skb->len) | TXDNFRAGLAST;\r\nxl_priv->tx_ring_skb[tx_head] = skb ;\r\ndev->stats.tx_packets++ ;\r\ndev->stats.tx_bytes += skb->len ;\r\ntx_prev = (xl_priv->tx_ring_head + XL_TX_RING_SIZE - 1) & (XL_TX_RING_SIZE - 1) ;\r\nxl_priv->tx_ring_head++ ;\r\nxl_priv->tx_ring_head &= (XL_TX_RING_SIZE - 1) ;\r\nxl_priv->free_ring_entries-- ;\r\nxl_priv->xl_tx_ring[tx_prev].dnnextptr = cpu_to_le32(xl_priv->tx_ring_dma_addr + (sizeof (struct xl_tx_desc) * tx_head));\r\nnetif_wake_queue(dev) ;\r\nspin_unlock_irqrestore(&xl_priv->xl_lock,flags) ;\r\nreturn NETDEV_TX_OK;\r\n} else {\r\nspin_unlock_irqrestore(&xl_priv->xl_lock,flags) ;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\n}\r\nstatic void xl_dn_comp(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv=netdev_priv(dev);\r\nu8 __iomem * xl_mmio = xl_priv->xl_mmio ;\r\nstruct xl_tx_desc *txd ;\r\nif (xl_priv->tx_ring_tail == 255) {\r\nxl_priv->xl_tx_ring[0].framestartheader = 0 ;\r\nxl_priv->xl_tx_ring[0].dnnextptr = 0 ;\r\nxl_priv->tx_ring_tail = 1 ;\r\n}\r\nwhile (xl_priv->xl_tx_ring[xl_priv->tx_ring_tail].framestartheader & TXDNCOMPLETE ) {\r\ntxd = &(xl_priv->xl_tx_ring[xl_priv->tx_ring_tail]) ;\r\npci_unmap_single(xl_priv->pdev, le32_to_cpu(txd->buffer), xl_priv->tx_ring_skb[xl_priv->tx_ring_tail]->len, PCI_DMA_TODEVICE);\r\ntxd->framestartheader = 0 ;\r\ntxd->buffer = cpu_to_le32(0xdeadbeef);\r\ntxd->buffer_length = 0 ;\r\ndev_kfree_skb_irq(xl_priv->tx_ring_skb[xl_priv->tx_ring_tail]) ;\r\nxl_priv->tx_ring_tail++ ;\r\nxl_priv->tx_ring_tail &= (XL_TX_RING_SIZE - 1) ;\r\nxl_priv->free_ring_entries++ ;\r\n}\r\nnetif_wake_queue(dev) ;\r\nwritel(ACK_INTERRUPT | DNCOMPACK | LATCH_ACK , xl_mmio + MMIO_COMMAND) ;\r\n}\r\nstatic int xl_close(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv = netdev_priv(dev);\r\nu8 __iomem * xl_mmio = xl_priv->xl_mmio ;\r\nunsigned long t ;\r\nnetif_stop_queue(dev) ;\r\nwritew(DNSTALL, xl_mmio + MMIO_COMMAND) ;\r\nt=jiffies;\r\nwhile (readw(xl_mmio + MMIO_INTSTATUS) & INTSTAT_CMD_IN_PROGRESS) {\r\nschedule();\r\nif (time_after(jiffies, t + 10 * HZ)) {\r\nprintk(KERN_ERR "%s: 3COM 3C359 Velocity XL-DNSTALL not responding.\n", dev->name);\r\nbreak ;\r\n}\r\n}\r\nwritew(DNDISABLE, xl_mmio + MMIO_COMMAND) ;\r\nt=jiffies;\r\nwhile (readw(xl_mmio + MMIO_INTSTATUS) & INTSTAT_CMD_IN_PROGRESS) {\r\nschedule();\r\nif (time_after(jiffies, t + 10 * HZ)) {\r\nprintk(KERN_ERR "%s: 3COM 3C359 Velocity XL-DNDISABLE not responding.\n", dev->name);\r\nbreak ;\r\n}\r\n}\r\nwritew(UPSTALL, xl_mmio + MMIO_COMMAND) ;\r\nt=jiffies;\r\nwhile (readw(xl_mmio + MMIO_INTSTATUS) & INTSTAT_CMD_IN_PROGRESS) {\r\nschedule();\r\nif (time_after(jiffies, t + 10 * HZ)) {\r\nprintk(KERN_ERR "%s: 3COM 3C359 Velocity XL-UPSTALL not responding.\n", dev->name);\r\nbreak ;\r\n}\r\n}\r\nwritel(SETINTENABLE, xl_mmio + MMIO_COMMAND) ;\r\nxl_srb_cmd(dev,CLOSE_NIC) ;\r\nt=jiffies;\r\nwhile (!(readw(xl_mmio + MMIO_INTSTATUS) & INTSTAT_SRB)) {\r\nschedule();\r\nif (time_after(jiffies, t + 10 * HZ)) {\r\nprintk(KERN_ERR "%s: 3COM 3C359 Velocity XL-CLOSENIC not responding.\n", dev->name);\r\nbreak ;\r\n}\r\n}\r\nwritel(MEM_BYTE_READ | 0xd0000 | xl_priv->srb, xl_mmio + MMIO_MAC_ACCESS_CMD);\r\nif (readb(xl_mmio + MMIO_MACDATA) != CLOSE_NIC) {\r\nprintk(KERN_INFO "%s: CLOSE_NIC did not get a CLOSE_NIC response\n",dev->name);\r\n} else {\r\nwritel((MEM_BYTE_READ | 0xd0000 | xl_priv->srb) +2, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nif (readb(xl_mmio + MMIO_MACDATA)==0) {\r\nprintk(KERN_INFO "%s: Adapter has been closed\n",dev->name);\r\nwritew(ACK_INTERRUPT | SRBRACK | LATCH_ACK, xl_mmio + MMIO_COMMAND) ;\r\nxl_freemem(dev) ;\r\nfree_irq(dev->irq,dev) ;\r\n} else {\r\nprintk(KERN_INFO "%s: Close nic command returned error code %02x\n",dev->name, readb(xl_mmio + MMIO_MACDATA)) ;\r\n}\r\n}\r\nwritew(UPRESET, xl_mmio + MMIO_COMMAND) ;\r\nt=jiffies;\r\nwhile (readw(xl_mmio + MMIO_INTSTATUS) & INTSTAT_CMD_IN_PROGRESS) {\r\nschedule();\r\nif (time_after(jiffies, t + 10 * HZ)) {\r\nprintk(KERN_ERR "%s: 3COM 3C359 Velocity XL-UPRESET not responding.\n", dev->name);\r\nbreak ;\r\n}\r\n}\r\nwritew(DNRESET, xl_mmio + MMIO_COMMAND) ;\r\nt=jiffies;\r\nwhile (readw(xl_mmio + MMIO_INTSTATUS) & INTSTAT_CMD_IN_PROGRESS) {\r\nschedule();\r\nif (time_after(jiffies, t + 10 * HZ)) {\r\nprintk(KERN_ERR "%s: 3COM 3C359 Velocity XL-DNRESET not responding.\n", dev->name);\r\nbreak ;\r\n}\r\n}\r\nxl_hw_reset(dev) ;\r\nreturn 0 ;\r\n}\r\nstatic void xl_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv = netdev_priv(dev);\r\nstruct netdev_hw_addr *ha;\r\nunsigned char dev_mc_address[4] ;\r\nu16 options ;\r\nif (dev->flags & IFF_PROMISC)\r\noptions = 0x0004 ;\r\nelse\r\noptions = 0x0000 ;\r\nif (options ^ xl_priv->xl_copy_all_options) {\r\nxl_priv->xl_copy_all_options = options ;\r\nxl_srb_cmd(dev, SET_RECEIVE_MODE) ;\r\nreturn ;\r\n}\r\ndev_mc_address[0] = dev_mc_address[1] = dev_mc_address[2] = dev_mc_address[3] = 0 ;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ndev_mc_address[0] |= ha->addr[2];\r\ndev_mc_address[1] |= ha->addr[3];\r\ndev_mc_address[2] |= ha->addr[4];\r\ndev_mc_address[3] |= ha->addr[5];\r\n}\r\nif (memcmp(xl_priv->xl_functional_addr,dev_mc_address,4) != 0) {\r\nmemcpy(xl_priv->xl_functional_addr, dev_mc_address,4) ;\r\nxl_srb_cmd(dev, SET_FUNC_ADDRESS) ;\r\n}\r\nreturn ;\r\n}\r\nstatic void xl_srb_bh(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv = netdev_priv(dev);\r\nu8 __iomem * xl_mmio = xl_priv->xl_mmio ;\r\nu8 srb_cmd, ret_code ;\r\nint i ;\r\nwritel(MEM_BYTE_READ | 0xd0000 | xl_priv->srb, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nsrb_cmd = readb(xl_mmio + MMIO_MACDATA) ;\r\nwritel((MEM_BYTE_READ | 0xd0000 | xl_priv->srb) +2, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nret_code = readb(xl_mmio + MMIO_MACDATA) ;\r\nswitch (ret_code) {\r\ncase 1:\r\nprintk(KERN_INFO "%s: Command: %d - Invalid Command code\n",dev->name,srb_cmd) ;\r\nbreak ;\r\ncase 4:\r\nprintk(KERN_INFO "%s: Command: %d - Adapter is closed, must be open for this command\n",dev->name,srb_cmd);\r\nbreak ;\r\ncase 6:\r\nprintk(KERN_INFO "%s: Command: %d - Options Invalid for command\n",dev->name,srb_cmd);\r\nbreak ;\r\ncase 0:\r\nswitch (srb_cmd) {\r\ncase READ_LOG:\r\nif(xl_priv->xl_message_level)\r\nprintk(KERN_INFO "%s: READ.LOG 14 bytes of data ",dev->name) ;\r\nfor (i=0;i<14;i++) {\r\nwritel(MEM_BYTE_READ | 0xd0000 | xl_priv->srb | i, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nif(xl_priv->xl_message_level)\r\nprintk("%02x:",readb(xl_mmio + MMIO_MACDATA)) ;\r\n}\r\nprintk("\n") ;\r\nbreak ;\r\ncase SET_FUNC_ADDRESS:\r\nif(xl_priv->xl_message_level)\r\nprintk(KERN_INFO "%s: Functional Address Set\n",dev->name);\r\nbreak ;\r\ncase CLOSE_NIC:\r\nif(xl_priv->xl_message_level)\r\nprintk(KERN_INFO "%s: Received CLOSE_NIC interrupt in interrupt handler\n",dev->name);\r\nbreak ;\r\ncase SET_MULTICAST_MODE:\r\nif(xl_priv->xl_message_level)\r\nprintk(KERN_INFO "%s: Multicast options successfully changed\n",dev->name) ;\r\nbreak ;\r\ncase SET_RECEIVE_MODE:\r\nif(xl_priv->xl_message_level) {\r\nif (xl_priv->xl_copy_all_options == 0x0004)\r\nprintk(KERN_INFO "%s: Entering promiscuous mode\n", dev->name);\r\nelse\r\nprintk(KERN_INFO "%s: Entering normal receive mode\n",dev->name);\r\n}\r\nbreak ;\r\n}\r\nbreak ;\r\n}\r\nreturn ;\r\n}\r\nstatic int xl_set_mac_address (struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *saddr = addr ;\r\nstruct xl_private *xl_priv = netdev_priv(dev);\r\nif (netif_running(dev)) {\r\nprintk(KERN_WARNING "%s: Cannot set mac/laa address while card is open\n", dev->name) ;\r\nreturn -EIO ;\r\n}\r\nmemcpy(xl_priv->xl_laa, saddr->sa_data,dev->addr_len) ;\r\nif (xl_priv->xl_message_level) {\r\nprintk(KERN_INFO "%s: MAC/LAA Set to = %x.%x.%x.%x.%x.%x\n",dev->name, xl_priv->xl_laa[0],\r\nxl_priv->xl_laa[1], xl_priv->xl_laa[2],\r\nxl_priv->xl_laa[3], xl_priv->xl_laa[4],\r\nxl_priv->xl_laa[5]);\r\n}\r\nreturn 0 ;\r\n}\r\nstatic void xl_arb_cmd(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv = netdev_priv(dev);\r\nu8 __iomem * xl_mmio = xl_priv->xl_mmio ;\r\nu8 arb_cmd ;\r\nu16 lan_status, lan_status_diff ;\r\nwritel( ( MEM_BYTE_READ | 0xD0000 | xl_priv->arb), xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\narb_cmd = readb(xl_mmio + MMIO_MACDATA) ;\r\nif (arb_cmd == RING_STATUS_CHANGE) {\r\nwritel( ( (MEM_WORD_READ | 0xD0000 | xl_priv->arb) + 6), xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nprintk(KERN_INFO "%s: Ring Status Change: New Status = %04x\n", dev->name, swab16(readw(xl_mmio + MMIO_MACDATA) )) ;\r\nlan_status = swab16(readw(xl_mmio + MMIO_MACDATA));\r\nwritel(ACK_INTERRUPT | ARBCACK | LATCH_ACK, xl_mmio + MMIO_COMMAND) ;\r\nlan_status_diff = xl_priv->xl_lan_status ^ lan_status ;\r\nif (lan_status_diff & (LSC_LWF | LSC_ARW | LSC_FPE | LSC_RR) ) {\r\nif (lan_status_diff & LSC_LWF)\r\nprintk(KERN_WARNING "%s: Short circuit detected on the lobe\n",dev->name);\r\nif (lan_status_diff & LSC_ARW)\r\nprintk(KERN_WARNING "%s: Auto removal error\n",dev->name);\r\nif (lan_status_diff & LSC_FPE)\r\nprintk(KERN_WARNING "%s: FDX Protocol Error\n",dev->name);\r\nif (lan_status_diff & LSC_RR)\r\nprintk(KERN_WARNING "%s: Force remove MAC frame received\n",dev->name);\r\nnetif_stop_queue(dev);\r\nxl_freemem(dev) ;\r\nfree_irq(dev->irq,dev);\r\nprintk(KERN_WARNING "%s: Adapter has been closed\n", dev->name);\r\n}\r\nif (xl_priv->xl_message_level) {\r\nif (lan_status_diff & LSC_SIG_LOSS)\r\nprintk(KERN_WARNING "%s: No receive signal detected\n", dev->name);\r\nif (lan_status_diff & LSC_HARD_ERR)\r\nprintk(KERN_INFO "%s: Beaconing\n",dev->name);\r\nif (lan_status_diff & LSC_SOFT_ERR)\r\nprintk(KERN_WARNING "%s: Adapter transmitted Soft Error Report Mac Frame\n",dev->name);\r\nif (lan_status_diff & LSC_TRAN_BCN)\r\nprintk(KERN_INFO "%s: We are transmitting the beacon, aaah\n",dev->name);\r\nif (lan_status_diff & LSC_SS)\r\nprintk(KERN_INFO "%s: Single Station on the ring\n", dev->name);\r\nif (lan_status_diff & LSC_RING_REC)\r\nprintk(KERN_INFO "%s: Ring recovery ongoing\n",dev->name);\r\nif (lan_status_diff & LSC_FDX_MODE)\r\nprintk(KERN_INFO "%s: Operating in FDX mode\n",dev->name);\r\n}\r\nif (lan_status_diff & LSC_CO) {\r\nif (xl_priv->xl_message_level)\r\nprintk(KERN_INFO "%s: Counter Overflow\n", dev->name);\r\nxl_srb_cmd(dev, READ_LOG) ;\r\n}\r\nif (lan_status_diff & LSC_SR_CO) {\r\nif (xl_priv->xl_message_level)\r\nprintk(KERN_INFO "%s: Source routing counters overflow\n", dev->name);\r\n}\r\nxl_priv->xl_lan_status = lan_status ;\r\n}\r\nelse if ( arb_cmd == RECEIVE_DATA) {\r\n#if XL_DEBUG\r\nprintk(KERN_INFO "Received.Data\n");\r\n#endif\r\nwritel( ((MEM_WORD_READ | 0xD0000 | xl_priv->arb) + 6), xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nxl_priv->mac_buffer = swab16(readw(xl_mmio + MMIO_MACDATA)) ;\r\nwritel(ACK_INTERRUPT | ARBCACK | LATCH_ACK, xl_mmio + MMIO_COMMAND) ;\r\nxl_priv->asb_queued = 0 ;\r\nwritel( ((MEM_BYTE_READ | 0xD0000 | xl_priv->asb) + 2), xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nif (readb(xl_mmio + MMIO_MACDATA) != 0xff) {\r\nxl_priv->asb_queued = 1 ;\r\nxl_wait_misr_flags(dev) ;\r\nwritel(MEM_BYTE_WRITE | MF_ASBFR, xl_mmio + MMIO_MAC_ACCESS_CMD);\r\nwriteb(0xff, xl_mmio + MMIO_MACDATA) ;\r\nwritel(MMIO_BYTE_WRITE | MISR_SET, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(MISR_ASBFR, xl_mmio + MMIO_MACDATA) ;\r\nreturn ;\r\n}\r\nxl_asb_cmd(dev) ;\r\n} else {\r\nprintk(KERN_WARNING "%s: Received unknown arb (xl_priv) command: %02x\n",dev->name,arb_cmd);\r\n}\r\nwritel(ACK_INTERRUPT | ARBCACK | LATCH_ACK , xl_mmio + MMIO_COMMAND) ;\r\nreturn ;\r\n}\r\nstatic void xl_asb_cmd(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv = netdev_priv(dev);\r\nu8 __iomem * xl_mmio = xl_priv->xl_mmio ;\r\nif (xl_priv->asb_queued == 1)\r\nwritel(ACK_INTERRUPT | LATCH_ACK | ASBFACK, xl_mmio + MMIO_COMMAND) ;\r\nwritel(MEM_BYTE_WRITE | 0xd0000 | xl_priv->asb, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(0x81, xl_mmio + MMIO_MACDATA) ;\r\nwritel(MEM_WORD_WRITE | 0xd0000 | xl_priv->asb | 6, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwritew(swab16(xl_priv->mac_buffer), xl_mmio + MMIO_MACDATA) ;\r\nxl_wait_misr_flags(dev) ;\r\nwritel(MEM_BYTE_WRITE | MF_RASB, xl_mmio + MMIO_MAC_ACCESS_CMD);\r\nwriteb(0xff, xl_mmio + MMIO_MACDATA) ;\r\nwritel(MMIO_BYTE_WRITE | MISR_SET, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(MISR_RASB, xl_mmio + MMIO_MACDATA) ;\r\nxl_priv->asb_queued = 2 ;\r\nreturn ;\r\n}\r\nstatic void xl_asb_bh(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv = netdev_priv(dev);\r\nu8 __iomem * xl_mmio = xl_priv->xl_mmio ;\r\nu8 ret_code ;\r\nwritel(MMIO_BYTE_READ | 0xd0000 | xl_priv->asb | 2, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nret_code = readb(xl_mmio + MMIO_MACDATA) ;\r\nswitch (ret_code) {\r\ncase 0x01:\r\nprintk(KERN_INFO "%s: ASB Command, unrecognized command code\n",dev->name);\r\nbreak ;\r\ncase 0x26:\r\nprintk(KERN_INFO "%s: ASB Command, unexpected receive buffer\n", dev->name);\r\nbreak ;\r\ncase 0x40:\r\nprintk(KERN_INFO "%s: ASB Command, Invalid Station ID\n", dev->name);\r\nbreak ;\r\n}\r\nxl_priv->asb_queued = 0 ;\r\nwritel(ACK_INTERRUPT | LATCH_ACK | ASBFACK, xl_mmio + MMIO_COMMAND) ;\r\nreturn ;\r\n}\r\nstatic void xl_srb_cmd(struct net_device *dev, int srb_cmd)\r\n{\r\nstruct xl_private *xl_priv = netdev_priv(dev);\r\nu8 __iomem * xl_mmio = xl_priv->xl_mmio ;\r\nswitch (srb_cmd) {\r\ncase READ_LOG:\r\nwritel(MEM_BYTE_WRITE | 0xD0000 | xl_priv->srb, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(READ_LOG, xl_mmio + MMIO_MACDATA) ;\r\nbreak;\r\ncase CLOSE_NIC:\r\nwritel(MEM_BYTE_WRITE | 0xD0000 | xl_priv->srb, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(CLOSE_NIC, xl_mmio + MMIO_MACDATA) ;\r\nbreak ;\r\ncase SET_RECEIVE_MODE:\r\nwritel(MEM_BYTE_WRITE | 0xD0000 | xl_priv->srb, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(SET_RECEIVE_MODE, xl_mmio + MMIO_MACDATA) ;\r\nwritel(MEM_WORD_WRITE | 0xD0000 | xl_priv->srb | 4, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwritew(xl_priv->xl_copy_all_options, xl_mmio + MMIO_MACDATA) ;\r\nbreak ;\r\ncase SET_FUNC_ADDRESS:\r\nwritel(MEM_BYTE_WRITE | 0xD0000 | xl_priv->srb, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(SET_FUNC_ADDRESS, xl_mmio + MMIO_MACDATA) ;\r\nwritel(MEM_BYTE_WRITE | 0xD0000 | xl_priv->srb | 6 , xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(xl_priv->xl_functional_addr[0], xl_mmio + MMIO_MACDATA) ;\r\nwritel(MEM_BYTE_WRITE | 0xD0000 | xl_priv->srb | 7 , xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(xl_priv->xl_functional_addr[1], xl_mmio + MMIO_MACDATA) ;\r\nwritel(MEM_BYTE_WRITE | 0xD0000 | xl_priv->srb | 8 , xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(xl_priv->xl_functional_addr[2], xl_mmio + MMIO_MACDATA) ;\r\nwritel(MEM_BYTE_WRITE | 0xD0000 | xl_priv->srb | 9 , xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(xl_priv->xl_functional_addr[3], xl_mmio + MMIO_MACDATA) ;\r\nbreak ;\r\n}\r\nxl_wait_misr_flags(dev) ;\r\nwritel(MEM_BYTE_WRITE | MF_CSRB , xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(0xFF, xl_mmio + MMIO_MACDATA) ;\r\nwritel(MMIO_BYTE_WRITE | MISR_SET, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(MISR_CSRB, xl_mmio + MMIO_MACDATA) ;\r\nxl_priv->srb_queued = 1 ;\r\nreturn ;\r\n}\r\nstatic void xl_wait_misr_flags(struct net_device *dev)\r\n{\r\nstruct xl_private *xl_priv = netdev_priv(dev);\r\nu8 __iomem * xl_mmio = xl_priv->xl_mmio ;\r\nint i ;\r\nwritel(MMIO_BYTE_READ | MISR_RW, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nif (readb(xl_mmio + MMIO_MACDATA) != 0) {\r\nfor (i=0; i<6; i++) {\r\nwritel(MEM_BYTE_READ | 0xDFFE0 | i, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwhile (readb(xl_mmio + MMIO_MACDATA) != 0) {\r\n;\r\n}\r\n}\r\n}\r\nwritel(MMIO_BYTE_WRITE | MISR_AND, xl_mmio + MMIO_MAC_ACCESS_CMD) ;\r\nwriteb(0x80, xl_mmio + MMIO_MACDATA) ;\r\nreturn ;\r\n}\r\nstatic int xl_change_mtu(struct net_device *dev, int mtu)\r\n{\r\nstruct xl_private *xl_priv = netdev_priv(dev);\r\nu16 max_mtu ;\r\nif (xl_priv->xl_ring_speed == 4)\r\nmax_mtu = 4500 ;\r\nelse\r\nmax_mtu = 18000 ;\r\nif (mtu > max_mtu)\r\nreturn -EINVAL ;\r\nif (mtu < 100)\r\nreturn -EINVAL ;\r\ndev->mtu = mtu ;\r\nxl_priv->pkt_buf_sz = mtu + TR_HLEN ;\r\nreturn 0 ;\r\n}\r\nstatic void __devexit xl_remove_one (struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct xl_private *xl_priv=netdev_priv(dev);\r\nrelease_firmware(xl_priv->fw);\r\nunregister_netdev(dev);\r\niounmap(xl_priv->xl_mmio) ;\r\npci_release_regions(pdev) ;\r\npci_set_drvdata(pdev,NULL) ;\r\nfree_netdev(dev);\r\nreturn ;\r\n}\r\nstatic int __init xl_pci_init (void)\r\n{\r\nreturn pci_register_driver(&xl_3c359_driver);\r\n}\r\nstatic void __exit xl_pci_cleanup (void)\r\n{\r\npci_unregister_driver (&xl_3c359_driver);\r\n}
