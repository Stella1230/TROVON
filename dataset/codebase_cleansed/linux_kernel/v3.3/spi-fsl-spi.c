static void fsl_spi_change_mode(struct spi_device *spi)\r\n{\r\nstruct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);\r\nstruct spi_mpc8xxx_cs *cs = spi->controller_state;\r\nstruct fsl_spi_reg *reg_base = mspi->reg_base;\r\n__be32 __iomem *mode = &reg_base->mode;\r\nunsigned long flags;\r\nif (cs->hw_mode == mpc8xxx_spi_read_reg(mode))\r\nreturn;\r\nlocal_irq_save(flags);\r\nmpc8xxx_spi_write_reg(mode, cs->hw_mode & ~SPMODE_ENABLE);\r\nif (mspi->flags & SPI_CPM_MODE) {\r\nif (mspi->flags & SPI_QE) {\r\nqe_issue_cmd(QE_INIT_TX_RX, mspi->subblock,\r\nQE_CR_PROTOCOL_UNSPECIFIED, 0);\r\n} else {\r\ncpm_command(CPM_SPI_CMD, CPM_CR_INIT_TRX);\r\nif (mspi->flags & SPI_CPM1) {\r\nout_be16(&mspi->pram->rbptr,\r\nin_be16(&mspi->pram->rbase));\r\nout_be16(&mspi->pram->tbptr,\r\nin_be16(&mspi->pram->tbase));\r\n}\r\n}\r\n}\r\nmpc8xxx_spi_write_reg(mode, cs->hw_mode);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void fsl_spi_chipselect(struct spi_device *spi, int value)\r\n{\r\nstruct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);\r\nstruct fsl_spi_platform_data *pdata = spi->dev.parent->platform_data;\r\nbool pol = spi->mode & SPI_CS_HIGH;\r\nstruct spi_mpc8xxx_cs *cs = spi->controller_state;\r\nif (value == BITBANG_CS_INACTIVE) {\r\nif (pdata->cs_control)\r\npdata->cs_control(spi, !pol);\r\n}\r\nif (value == BITBANG_CS_ACTIVE) {\r\nmpc8xxx_spi->rx_shift = cs->rx_shift;\r\nmpc8xxx_spi->tx_shift = cs->tx_shift;\r\nmpc8xxx_spi->get_rx = cs->get_rx;\r\nmpc8xxx_spi->get_tx = cs->get_tx;\r\nfsl_spi_change_mode(spi);\r\nif (pdata->cs_control)\r\npdata->cs_control(spi, pol);\r\n}\r\n}\r\nstatic int mspi_apply_cpu_mode_quirks(struct spi_mpc8xxx_cs *cs,\r\nstruct spi_device *spi,\r\nstruct mpc8xxx_spi *mpc8xxx_spi,\r\nint bits_per_word)\r\n{\r\ncs->rx_shift = 0;\r\ncs->tx_shift = 0;\r\nif (bits_per_word <= 8) {\r\ncs->get_rx = mpc8xxx_spi_rx_buf_u8;\r\ncs->get_tx = mpc8xxx_spi_tx_buf_u8;\r\nif (mpc8xxx_spi->flags & SPI_QE_CPU_MODE) {\r\ncs->rx_shift = 16;\r\ncs->tx_shift = 24;\r\n}\r\n} else if (bits_per_word <= 16) {\r\ncs->get_rx = mpc8xxx_spi_rx_buf_u16;\r\ncs->get_tx = mpc8xxx_spi_tx_buf_u16;\r\nif (mpc8xxx_spi->flags & SPI_QE_CPU_MODE) {\r\ncs->rx_shift = 16;\r\ncs->tx_shift = 16;\r\n}\r\n} else if (bits_per_word <= 32) {\r\ncs->get_rx = mpc8xxx_spi_rx_buf_u32;\r\ncs->get_tx = mpc8xxx_spi_tx_buf_u32;\r\n} else\r\nreturn -EINVAL;\r\nif (mpc8xxx_spi->flags & SPI_QE_CPU_MODE &&\r\nspi->mode & SPI_LSB_FIRST) {\r\ncs->tx_shift = 0;\r\nif (bits_per_word <= 8)\r\ncs->rx_shift = 8;\r\nelse\r\ncs->rx_shift = 0;\r\n}\r\nmpc8xxx_spi->rx_shift = cs->rx_shift;\r\nmpc8xxx_spi->tx_shift = cs->tx_shift;\r\nmpc8xxx_spi->get_rx = cs->get_rx;\r\nmpc8xxx_spi->get_tx = cs->get_tx;\r\nreturn bits_per_word;\r\n}\r\nstatic int mspi_apply_qe_mode_quirks(struct spi_mpc8xxx_cs *cs,\r\nstruct spi_device *spi,\r\nint bits_per_word)\r\n{\r\nif (spi->mode & SPI_LSB_FIRST &&\r\nbits_per_word > 8)\r\nreturn -EINVAL;\r\nif (bits_per_word > 8)\r\nreturn 8;\r\nreturn bits_per_word;\r\n}\r\nstatic int fsl_spi_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct mpc8xxx_spi *mpc8xxx_spi;\r\nint bits_per_word = 0;\r\nu8 pm;\r\nu32 hz = 0;\r\nstruct spi_mpc8xxx_cs *cs = spi->controller_state;\r\nmpc8xxx_spi = spi_master_get_devdata(spi->master);\r\nif (t) {\r\nbits_per_word = t->bits_per_word;\r\nhz = t->speed_hz;\r\n}\r\nif (!bits_per_word)\r\nbits_per_word = spi->bits_per_word;\r\nif ((bits_per_word < 4)\r\n|| ((bits_per_word > 16) && (bits_per_word != 32)))\r\nreturn -EINVAL;\r\nif (!hz)\r\nhz = spi->max_speed_hz;\r\nif (!(mpc8xxx_spi->flags & SPI_CPM_MODE))\r\nbits_per_word = mspi_apply_cpu_mode_quirks(cs, spi,\r\nmpc8xxx_spi,\r\nbits_per_word);\r\nelse if (mpc8xxx_spi->flags & SPI_QE)\r\nbits_per_word = mspi_apply_qe_mode_quirks(cs, spi,\r\nbits_per_word);\r\nif (bits_per_word < 0)\r\nreturn bits_per_word;\r\nif (bits_per_word == 32)\r\nbits_per_word = 0;\r\nelse\r\nbits_per_word = bits_per_word - 1;\r\ncs->hw_mode &= ~(SPMODE_LEN(0xF) | SPMODE_DIV16\r\n| SPMODE_PM(0xF));\r\ncs->hw_mode |= SPMODE_LEN(bits_per_word);\r\nif ((mpc8xxx_spi->spibrg / hz) > 64) {\r\ncs->hw_mode |= SPMODE_DIV16;\r\npm = (mpc8xxx_spi->spibrg - 1) / (hz * 64) + 1;\r\nWARN_ONCE(pm > 16, "%s: Requested speed is too low: %d Hz. "\r\n"Will use %d Hz instead.\n", dev_name(&spi->dev),\r\nhz, mpc8xxx_spi->spibrg / 1024);\r\nif (pm > 16)\r\npm = 16;\r\n} else {\r\npm = (mpc8xxx_spi->spibrg - 1) / (hz * 4) + 1;\r\n}\r\nif (pm)\r\npm--;\r\ncs->hw_mode |= SPMODE_PM(pm);\r\nfsl_spi_change_mode(spi);\r\nreturn 0;\r\n}\r\nstatic void fsl_spi_cpm_bufs_start(struct mpc8xxx_spi *mspi)\r\n{\r\nstruct cpm_buf_desc __iomem *tx_bd = mspi->tx_bd;\r\nstruct cpm_buf_desc __iomem *rx_bd = mspi->rx_bd;\r\nunsigned int xfer_len = min(mspi->count, SPI_MRBLR);\r\nunsigned int xfer_ofs;\r\nstruct fsl_spi_reg *reg_base = mspi->reg_base;\r\nxfer_ofs = mspi->xfer_in_progress->len - mspi->count;\r\nif (mspi->rx_dma == mspi->dma_dummy_rx)\r\nout_be32(&rx_bd->cbd_bufaddr, mspi->rx_dma);\r\nelse\r\nout_be32(&rx_bd->cbd_bufaddr, mspi->rx_dma + xfer_ofs);\r\nout_be16(&rx_bd->cbd_datlen, 0);\r\nout_be16(&rx_bd->cbd_sc, BD_SC_EMPTY | BD_SC_INTRPT | BD_SC_WRAP);\r\nif (mspi->tx_dma == mspi->dma_dummy_tx)\r\nout_be32(&tx_bd->cbd_bufaddr, mspi->tx_dma);\r\nelse\r\nout_be32(&tx_bd->cbd_bufaddr, mspi->tx_dma + xfer_ofs);\r\nout_be16(&tx_bd->cbd_datlen, xfer_len);\r\nout_be16(&tx_bd->cbd_sc, BD_SC_READY | BD_SC_INTRPT | BD_SC_WRAP |\r\nBD_SC_LAST);\r\nmpc8xxx_spi_write_reg(&reg_base->command, SPCOM_STR);\r\n}\r\nstatic int fsl_spi_cpm_bufs(struct mpc8xxx_spi *mspi,\r\nstruct spi_transfer *t, bool is_dma_mapped)\r\n{\r\nstruct device *dev = mspi->dev;\r\nstruct fsl_spi_reg *reg_base = mspi->reg_base;\r\nif (is_dma_mapped) {\r\nmspi->map_tx_dma = 0;\r\nmspi->map_rx_dma = 0;\r\n} else {\r\nmspi->map_tx_dma = 1;\r\nmspi->map_rx_dma = 1;\r\n}\r\nif (!t->tx_buf) {\r\nmspi->tx_dma = mspi->dma_dummy_tx;\r\nmspi->map_tx_dma = 0;\r\n}\r\nif (!t->rx_buf) {\r\nmspi->rx_dma = mspi->dma_dummy_rx;\r\nmspi->map_rx_dma = 0;\r\n}\r\nif (mspi->map_tx_dma) {\r\nvoid *nonconst_tx = (void *)mspi->tx;\r\nmspi->tx_dma = dma_map_single(dev, nonconst_tx, t->len,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, mspi->tx_dma)) {\r\ndev_err(dev, "unable to map tx dma\n");\r\nreturn -ENOMEM;\r\n}\r\n} else if (t->tx_buf) {\r\nmspi->tx_dma = t->tx_dma;\r\n}\r\nif (mspi->map_rx_dma) {\r\nmspi->rx_dma = dma_map_single(dev, mspi->rx, t->len,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(dev, mspi->rx_dma)) {\r\ndev_err(dev, "unable to map rx dma\n");\r\ngoto err_rx_dma;\r\n}\r\n} else if (t->rx_buf) {\r\nmspi->rx_dma = t->rx_dma;\r\n}\r\nmpc8xxx_spi_write_reg(&reg_base->mask, SPIE_RXB);\r\nmspi->xfer_in_progress = t;\r\nmspi->count = t->len;\r\nfsl_spi_cpm_bufs_start(mspi);\r\nreturn 0;\r\nerr_rx_dma:\r\nif (mspi->map_tx_dma)\r\ndma_unmap_single(dev, mspi->tx_dma, t->len, DMA_TO_DEVICE);\r\nreturn -ENOMEM;\r\n}\r\nstatic void fsl_spi_cpm_bufs_complete(struct mpc8xxx_spi *mspi)\r\n{\r\nstruct device *dev = mspi->dev;\r\nstruct spi_transfer *t = mspi->xfer_in_progress;\r\nif (mspi->map_tx_dma)\r\ndma_unmap_single(dev, mspi->tx_dma, t->len, DMA_TO_DEVICE);\r\nif (mspi->map_rx_dma)\r\ndma_unmap_single(dev, mspi->rx_dma, t->len, DMA_FROM_DEVICE);\r\nmspi->xfer_in_progress = NULL;\r\n}\r\nstatic int fsl_spi_cpu_bufs(struct mpc8xxx_spi *mspi,\r\nstruct spi_transfer *t, unsigned int len)\r\n{\r\nu32 word;\r\nstruct fsl_spi_reg *reg_base = mspi->reg_base;\r\nmspi->count = len;\r\nmpc8xxx_spi_write_reg(&reg_base->mask, SPIM_NE);\r\nword = mspi->get_tx(mspi);\r\nmpc8xxx_spi_write_reg(&reg_base->transmit, word);\r\nreturn 0;\r\n}\r\nstatic int fsl_spi_bufs(struct spi_device *spi, struct spi_transfer *t,\r\nbool is_dma_mapped)\r\n{\r\nstruct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);\r\nstruct fsl_spi_reg *reg_base;\r\nunsigned int len = t->len;\r\nu8 bits_per_word;\r\nint ret;\r\nreg_base = mpc8xxx_spi->reg_base;\r\nbits_per_word = spi->bits_per_word;\r\nif (t->bits_per_word)\r\nbits_per_word = t->bits_per_word;\r\nif (bits_per_word > 8) {\r\nif (len & 1)\r\nreturn -EINVAL;\r\nlen /= 2;\r\n}\r\nif (bits_per_word > 16) {\r\nif (len & 1)\r\nreturn -EINVAL;\r\nlen /= 2;\r\n}\r\nmpc8xxx_spi->tx = t->tx_buf;\r\nmpc8xxx_spi->rx = t->rx_buf;\r\nINIT_COMPLETION(mpc8xxx_spi->done);\r\nif (mpc8xxx_spi->flags & SPI_CPM_MODE)\r\nret = fsl_spi_cpm_bufs(mpc8xxx_spi, t, is_dma_mapped);\r\nelse\r\nret = fsl_spi_cpu_bufs(mpc8xxx_spi, t, len);\r\nif (ret)\r\nreturn ret;\r\nwait_for_completion(&mpc8xxx_spi->done);\r\nmpc8xxx_spi_write_reg(&reg_base->mask, 0);\r\nif (mpc8xxx_spi->flags & SPI_CPM_MODE)\r\nfsl_spi_cpm_bufs_complete(mpc8xxx_spi);\r\nreturn mpc8xxx_spi->count;\r\n}\r\nstatic void fsl_spi_do_one_msg(struct spi_message *m)\r\n{\r\nstruct spi_device *spi = m->spi;\r\nstruct spi_transfer *t;\r\nunsigned int cs_change;\r\nconst int nsecs = 50;\r\nint status;\r\ncs_change = 1;\r\nstatus = 0;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (t->bits_per_word || t->speed_hz) {\r\nstatus = -EINVAL;\r\nif (cs_change)\r\nstatus = fsl_spi_setup_transfer(spi, t);\r\nif (status < 0)\r\nbreak;\r\n}\r\nif (cs_change) {\r\nfsl_spi_chipselect(spi, BITBANG_CS_ACTIVE);\r\nndelay(nsecs);\r\n}\r\ncs_change = t->cs_change;\r\nif (t->len)\r\nstatus = fsl_spi_bufs(spi, t, m->is_dma_mapped);\r\nif (status) {\r\nstatus = -EMSGSIZE;\r\nbreak;\r\n}\r\nm->actual_length += t->len;\r\nif (t->delay_usecs)\r\nudelay(t->delay_usecs);\r\nif (cs_change) {\r\nndelay(nsecs);\r\nfsl_spi_chipselect(spi, BITBANG_CS_INACTIVE);\r\nndelay(nsecs);\r\n}\r\n}\r\nm->status = status;\r\nm->complete(m->context);\r\nif (status || !cs_change) {\r\nndelay(nsecs);\r\nfsl_spi_chipselect(spi, BITBANG_CS_INACTIVE);\r\n}\r\nfsl_spi_setup_transfer(spi, NULL);\r\n}\r\nstatic int fsl_spi_setup(struct spi_device *spi)\r\n{\r\nstruct mpc8xxx_spi *mpc8xxx_spi;\r\nstruct fsl_spi_reg *reg_base;\r\nint retval;\r\nu32 hw_mode;\r\nstruct spi_mpc8xxx_cs *cs = spi->controller_state;\r\nif (!spi->max_speed_hz)\r\nreturn -EINVAL;\r\nif (!cs) {\r\ncs = kzalloc(sizeof *cs, GFP_KERNEL);\r\nif (!cs)\r\nreturn -ENOMEM;\r\nspi->controller_state = cs;\r\n}\r\nmpc8xxx_spi = spi_master_get_devdata(spi->master);\r\nreg_base = mpc8xxx_spi->reg_base;\r\nhw_mode = cs->hw_mode;\r\ncs->hw_mode = mpc8xxx_spi_read_reg(&reg_base->mode);\r\ncs->hw_mode &= ~(SPMODE_CP_BEGIN_EDGECLK | SPMODE_CI_INACTIVEHIGH\r\n| SPMODE_REV | SPMODE_LOOP);\r\nif (spi->mode & SPI_CPHA)\r\ncs->hw_mode |= SPMODE_CP_BEGIN_EDGECLK;\r\nif (spi->mode & SPI_CPOL)\r\ncs->hw_mode |= SPMODE_CI_INACTIVEHIGH;\r\nif (!(spi->mode & SPI_LSB_FIRST))\r\ncs->hw_mode |= SPMODE_REV;\r\nif (spi->mode & SPI_LOOP)\r\ncs->hw_mode |= SPMODE_LOOP;\r\nretval = fsl_spi_setup_transfer(spi, NULL);\r\nif (retval < 0) {\r\ncs->hw_mode = hw_mode;\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fsl_spi_cpm_irq(struct mpc8xxx_spi *mspi, u32 events)\r\n{\r\nu16 len;\r\nstruct fsl_spi_reg *reg_base = mspi->reg_base;\r\ndev_dbg(mspi->dev, "%s: bd datlen %d, count %d\n", __func__,\r\nin_be16(&mspi->rx_bd->cbd_datlen), mspi->count);\r\nlen = in_be16(&mspi->rx_bd->cbd_datlen);\r\nif (len > mspi->count) {\r\nWARN_ON(1);\r\nlen = mspi->count;\r\n}\r\nmpc8xxx_spi_write_reg(&reg_base->event, events);\r\nmspi->count -= len;\r\nif (mspi->count)\r\nfsl_spi_cpm_bufs_start(mspi);\r\nelse\r\ncomplete(&mspi->done);\r\n}\r\nstatic void fsl_spi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)\r\n{\r\nstruct fsl_spi_reg *reg_base = mspi->reg_base;\r\nif (events & SPIE_NE) {\r\nu32 rx_data = mpc8xxx_spi_read_reg(&reg_base->receive);\r\nif (mspi->rx)\r\nmspi->get_rx(rx_data, mspi);\r\n}\r\nif ((events & SPIE_NF) == 0)\r\nwhile (((events =\r\nmpc8xxx_spi_read_reg(&reg_base->event)) &\r\nSPIE_NF) == 0)\r\ncpu_relax();\r\nmpc8xxx_spi_write_reg(&reg_base->event, events);\r\nmspi->count -= 1;\r\nif (mspi->count) {\r\nu32 word = mspi->get_tx(mspi);\r\nmpc8xxx_spi_write_reg(&reg_base->transmit, word);\r\n} else {\r\ncomplete(&mspi->done);\r\n}\r\n}\r\nstatic irqreturn_t fsl_spi_irq(s32 irq, void *context_data)\r\n{\r\nstruct mpc8xxx_spi *mspi = context_data;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 events;\r\nstruct fsl_spi_reg *reg_base = mspi->reg_base;\r\nevents = mpc8xxx_spi_read_reg(&reg_base->event);\r\nif (events)\r\nret = IRQ_HANDLED;\r\ndev_dbg(mspi->dev, "%s: events %x\n", __func__, events);\r\nif (mspi->flags & SPI_CPM_MODE)\r\nfsl_spi_cpm_irq(mspi, events);\r\nelse\r\nfsl_spi_cpu_irq(mspi, events);\r\nreturn ret;\r\n}\r\nstatic void *fsl_spi_alloc_dummy_rx(void)\r\n{\r\nmutex_lock(&fsl_dummy_rx_lock);\r\nif (!fsl_dummy_rx)\r\nfsl_dummy_rx = kmalloc(SPI_MRBLR, GFP_KERNEL);\r\nif (fsl_dummy_rx)\r\nfsl_dummy_rx_refcnt++;\r\nmutex_unlock(&fsl_dummy_rx_lock);\r\nreturn fsl_dummy_rx;\r\n}\r\nstatic void fsl_spi_free_dummy_rx(void)\r\n{\r\nmutex_lock(&fsl_dummy_rx_lock);\r\nswitch (fsl_dummy_rx_refcnt) {\r\ncase 0:\r\nWARN_ON(1);\r\nbreak;\r\ncase 1:\r\nkfree(fsl_dummy_rx);\r\nfsl_dummy_rx = NULL;\r\ndefault:\r\nfsl_dummy_rx_refcnt--;\r\nbreak;\r\n}\r\nmutex_unlock(&fsl_dummy_rx_lock);\r\n}\r\nstatic unsigned long fsl_spi_cpm_get_pram(struct mpc8xxx_spi *mspi)\r\n{\r\nstruct device *dev = mspi->dev;\r\nstruct device_node *np = dev->of_node;\r\nconst u32 *iprop;\r\nint size;\r\nvoid __iomem *spi_base;\r\nunsigned long pram_ofs = -ENOMEM;\r\niprop = of_get_property(np, "reg", &size);\r\nif (mspi->flags & SPI_QE && iprop && size == sizeof(*iprop) * 4)\r\nreturn cpm_muram_alloc_fixed(iprop[2], SPI_PRAM_SIZE);\r\nif (mspi->flags & SPI_QE) {\r\npram_ofs = cpm_muram_alloc(SPI_PRAM_SIZE, 64);\r\nqe_issue_cmd(QE_ASSIGN_PAGE_TO_DEVICE, mspi->subblock,\r\nQE_CR_PROTOCOL_UNSPECIFIED, pram_ofs);\r\nreturn pram_ofs;\r\n}\r\nspi_base = of_iomap(np, 1);\r\nif (spi_base == NULL)\r\nreturn -EINVAL;\r\nif (mspi->flags & SPI_CPM2) {\r\npram_ofs = cpm_muram_alloc(SPI_PRAM_SIZE, 64);\r\nout_be16(spi_base, pram_ofs);\r\n} else {\r\nstruct spi_pram __iomem *pram = spi_base;\r\nu16 rpbase = in_be16(&pram->rpbase);\r\nif (rpbase)\r\npram_ofs = rpbase;\r\nelse {\r\npram_ofs = cpm_muram_alloc(SPI_PRAM_SIZE, 64);\r\nout_be16(spi_base, pram_ofs);\r\n}\r\n}\r\niounmap(spi_base);\r\nreturn pram_ofs;\r\n}\r\nstatic int fsl_spi_cpm_init(struct mpc8xxx_spi *mspi)\r\n{\r\nstruct device *dev = mspi->dev;\r\nstruct device_node *np = dev->of_node;\r\nconst u32 *iprop;\r\nint size;\r\nunsigned long pram_ofs;\r\nunsigned long bds_ofs;\r\nif (!(mspi->flags & SPI_CPM_MODE))\r\nreturn 0;\r\nif (!fsl_spi_alloc_dummy_rx())\r\nreturn -ENOMEM;\r\nif (mspi->flags & SPI_QE) {\r\niprop = of_get_property(np, "cell-index", &size);\r\nif (iprop && size == sizeof(*iprop))\r\nmspi->subblock = *iprop;\r\nswitch (mspi->subblock) {\r\ndefault:\r\ndev_warn(dev, "cell-index unspecified, assuming SPI1");\r\ncase 0:\r\nmspi->subblock = QE_CR_SUBBLOCK_SPI1;\r\nbreak;\r\ncase 1:\r\nmspi->subblock = QE_CR_SUBBLOCK_SPI2;\r\nbreak;\r\n}\r\n}\r\npram_ofs = fsl_spi_cpm_get_pram(mspi);\r\nif (IS_ERR_VALUE(pram_ofs)) {\r\ndev_err(dev, "can't allocate spi parameter ram\n");\r\ngoto err_pram;\r\n}\r\nbds_ofs = cpm_muram_alloc(sizeof(*mspi->tx_bd) +\r\nsizeof(*mspi->rx_bd), 8);\r\nif (IS_ERR_VALUE(bds_ofs)) {\r\ndev_err(dev, "can't allocate bds\n");\r\ngoto err_bds;\r\n}\r\nmspi->dma_dummy_tx = dma_map_single(dev, empty_zero_page, PAGE_SIZE,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, mspi->dma_dummy_tx)) {\r\ndev_err(dev, "unable to map dummy tx buffer\n");\r\ngoto err_dummy_tx;\r\n}\r\nmspi->dma_dummy_rx = dma_map_single(dev, fsl_dummy_rx, SPI_MRBLR,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(dev, mspi->dma_dummy_rx)) {\r\ndev_err(dev, "unable to map dummy rx buffer\n");\r\ngoto err_dummy_rx;\r\n}\r\nmspi->pram = cpm_muram_addr(pram_ofs);\r\nmspi->tx_bd = cpm_muram_addr(bds_ofs);\r\nmspi->rx_bd = cpm_muram_addr(bds_ofs + sizeof(*mspi->tx_bd));\r\nout_be16(&mspi->pram->tbase, cpm_muram_offset(mspi->tx_bd));\r\nout_be16(&mspi->pram->rbase, cpm_muram_offset(mspi->rx_bd));\r\nout_8(&mspi->pram->tfcr, CPMFCR_EB | CPMFCR_GBL);\r\nout_8(&mspi->pram->rfcr, CPMFCR_EB | CPMFCR_GBL);\r\nout_be16(&mspi->pram->mrblr, SPI_MRBLR);\r\nout_be32(&mspi->pram->rstate, 0);\r\nout_be32(&mspi->pram->rdp, 0);\r\nout_be16(&mspi->pram->rbptr, 0);\r\nout_be16(&mspi->pram->rbc, 0);\r\nout_be32(&mspi->pram->rxtmp, 0);\r\nout_be32(&mspi->pram->tstate, 0);\r\nout_be32(&mspi->pram->tdp, 0);\r\nout_be16(&mspi->pram->tbptr, 0);\r\nout_be16(&mspi->pram->tbc, 0);\r\nout_be32(&mspi->pram->txtmp, 0);\r\nreturn 0;\r\nerr_dummy_rx:\r\ndma_unmap_single(dev, mspi->dma_dummy_tx, PAGE_SIZE, DMA_TO_DEVICE);\r\nerr_dummy_tx:\r\ncpm_muram_free(bds_ofs);\r\nerr_bds:\r\ncpm_muram_free(pram_ofs);\r\nerr_pram:\r\nfsl_spi_free_dummy_rx();\r\nreturn -ENOMEM;\r\n}\r\nstatic void fsl_spi_cpm_free(struct mpc8xxx_spi *mspi)\r\n{\r\nstruct device *dev = mspi->dev;\r\nif (!(mspi->flags & SPI_CPM_MODE))\r\nreturn;\r\ndma_unmap_single(dev, mspi->dma_dummy_rx, SPI_MRBLR, DMA_FROM_DEVICE);\r\ndma_unmap_single(dev, mspi->dma_dummy_tx, PAGE_SIZE, DMA_TO_DEVICE);\r\ncpm_muram_free(cpm_muram_offset(mspi->tx_bd));\r\ncpm_muram_free(cpm_muram_offset(mspi->pram));\r\nfsl_spi_free_dummy_rx();\r\n}\r\nstatic void fsl_spi_remove(struct mpc8xxx_spi *mspi)\r\n{\r\niounmap(mspi->reg_base);\r\nfsl_spi_cpm_free(mspi);\r\n}\r\nstatic struct spi_master * __devinit fsl_spi_probe(struct device *dev,\r\nstruct resource *mem, unsigned int irq)\r\n{\r\nstruct fsl_spi_platform_data *pdata = dev->platform_data;\r\nstruct spi_master *master;\r\nstruct mpc8xxx_spi *mpc8xxx_spi;\r\nstruct fsl_spi_reg *reg_base;\r\nu32 regval;\r\nint ret = 0;\r\nmaster = spi_alloc_master(dev, sizeof(struct mpc8xxx_spi));\r\nif (master == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev_set_drvdata(dev, master);\r\nret = mpc8xxx_spi_probe(dev, mem, irq);\r\nif (ret)\r\ngoto err_probe;\r\nmaster->setup = fsl_spi_setup;\r\nmpc8xxx_spi = spi_master_get_devdata(master);\r\nmpc8xxx_spi->spi_do_one_msg = fsl_spi_do_one_msg;\r\nmpc8xxx_spi->spi_remove = fsl_spi_remove;\r\nret = fsl_spi_cpm_init(mpc8xxx_spi);\r\nif (ret)\r\ngoto err_cpm_init;\r\nif (mpc8xxx_spi->flags & SPI_QE_CPU_MODE) {\r\nmpc8xxx_spi->rx_shift = 16;\r\nmpc8xxx_spi->tx_shift = 24;\r\n}\r\nmpc8xxx_spi->reg_base = ioremap(mem->start, resource_size(mem));\r\nif (mpc8xxx_spi->reg_base == NULL) {\r\nret = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nret = request_irq(mpc8xxx_spi->irq, fsl_spi_irq,\r\n0, "fsl_spi", mpc8xxx_spi);\r\nif (ret != 0)\r\ngoto free_irq;\r\nreg_base = mpc8xxx_spi->reg_base;\r\nmpc8xxx_spi_write_reg(&reg_base->mode, 0);\r\nmpc8xxx_spi_write_reg(&reg_base->mask, 0);\r\nmpc8xxx_spi_write_reg(&reg_base->command, 0);\r\nmpc8xxx_spi_write_reg(&reg_base->event, 0xffffffff);\r\nregval = pdata->initial_spmode | SPMODE_INIT_VAL | SPMODE_ENABLE;\r\nif (mpc8xxx_spi->flags & SPI_QE_CPU_MODE)\r\nregval |= SPMODE_OP;\r\nmpc8xxx_spi_write_reg(&reg_base->mode, regval);\r\nret = spi_register_master(master);\r\nif (ret < 0)\r\ngoto unreg_master;\r\ndev_info(dev, "at 0x%p (irq = %d), %s mode\n", reg_base,\r\nmpc8xxx_spi->irq, mpc8xxx_spi_strmode(mpc8xxx_spi->flags));\r\nreturn master;\r\nunreg_master:\r\nfree_irq(mpc8xxx_spi->irq, mpc8xxx_spi);\r\nfree_irq:\r\niounmap(mpc8xxx_spi->reg_base);\r\nerr_ioremap:\r\nfsl_spi_cpm_free(mpc8xxx_spi);\r\nerr_cpm_init:\r\nerr_probe:\r\nspi_master_put(master);\r\nerr:\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void fsl_spi_cs_control(struct spi_device *spi, bool on)\r\n{\r\nstruct device *dev = spi->dev.parent;\r\nstruct mpc8xxx_spi_probe_info *pinfo = to_of_pinfo(dev->platform_data);\r\nu16 cs = spi->chip_select;\r\nint gpio = pinfo->gpios[cs];\r\nbool alow = pinfo->alow_flags[cs];\r\ngpio_set_value(gpio, on ^ alow);\r\n}\r\nstatic int of_fsl_spi_get_chipselects(struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct fsl_spi_platform_data *pdata = dev->platform_data;\r\nstruct mpc8xxx_spi_probe_info *pinfo = to_of_pinfo(pdata);\r\nunsigned int ngpios;\r\nint i = 0;\r\nint ret;\r\nngpios = of_gpio_count(np);\r\nif (!ngpios) {\r\npdata->max_chipselect = 1;\r\nreturn 0;\r\n}\r\npinfo->gpios = kmalloc(ngpios * sizeof(*pinfo->gpios), GFP_KERNEL);\r\nif (!pinfo->gpios)\r\nreturn -ENOMEM;\r\nmemset(pinfo->gpios, -1, ngpios * sizeof(*pinfo->gpios));\r\npinfo->alow_flags = kzalloc(ngpios * sizeof(*pinfo->alow_flags),\r\nGFP_KERNEL);\r\nif (!pinfo->alow_flags) {\r\nret = -ENOMEM;\r\ngoto err_alloc_flags;\r\n}\r\nfor (; i < ngpios; i++) {\r\nint gpio;\r\nenum of_gpio_flags flags;\r\ngpio = of_get_gpio_flags(np, i, &flags);\r\nif (!gpio_is_valid(gpio)) {\r\ndev_err(dev, "invalid gpio #%d: %d\n", i, gpio);\r\nret = gpio;\r\ngoto err_loop;\r\n}\r\nret = gpio_request(gpio, dev_name(dev));\r\nif (ret) {\r\ndev_err(dev, "can't request gpio #%d: %d\n", i, ret);\r\ngoto err_loop;\r\n}\r\npinfo->gpios[i] = gpio;\r\npinfo->alow_flags[i] = flags & OF_GPIO_ACTIVE_LOW;\r\nret = gpio_direction_output(pinfo->gpios[i],\r\npinfo->alow_flags[i]);\r\nif (ret) {\r\ndev_err(dev, "can't set output direction for gpio "\r\n"#%d: %d\n", i, ret);\r\ngoto err_loop;\r\n}\r\n}\r\npdata->max_chipselect = ngpios;\r\npdata->cs_control = fsl_spi_cs_control;\r\nreturn 0;\r\nerr_loop:\r\nwhile (i >= 0) {\r\nif (gpio_is_valid(pinfo->gpios[i]))\r\ngpio_free(pinfo->gpios[i]);\r\ni--;\r\n}\r\nkfree(pinfo->alow_flags);\r\npinfo->alow_flags = NULL;\r\nerr_alloc_flags:\r\nkfree(pinfo->gpios);\r\npinfo->gpios = NULL;\r\nreturn ret;\r\n}\r\nstatic int of_fsl_spi_free_chipselects(struct device *dev)\r\n{\r\nstruct fsl_spi_platform_data *pdata = dev->platform_data;\r\nstruct mpc8xxx_spi_probe_info *pinfo = to_of_pinfo(pdata);\r\nint i;\r\nif (!pinfo->gpios)\r\nreturn 0;\r\nfor (i = 0; i < pdata->max_chipselect; i++) {\r\nif (gpio_is_valid(pinfo->gpios[i]))\r\ngpio_free(pinfo->gpios[i]);\r\n}\r\nkfree(pinfo->gpios);\r\nkfree(pinfo->alow_flags);\r\nreturn 0;\r\n}\r\nstatic int __devinit of_fsl_spi_probe(struct platform_device *ofdev)\r\n{\r\nstruct device *dev = &ofdev->dev;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct spi_master *master;\r\nstruct resource mem;\r\nstruct resource irq;\r\nint ret = -ENOMEM;\r\nret = of_mpc8xxx_spi_probe(ofdev);\r\nif (ret)\r\nreturn ret;\r\nret = of_fsl_spi_get_chipselects(dev);\r\nif (ret)\r\ngoto err;\r\nret = of_address_to_resource(np, 0, &mem);\r\nif (ret)\r\ngoto err;\r\nret = of_irq_to_resource(np, 0, &irq);\r\nif (!ret) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nmaster = fsl_spi_probe(dev, &mem, irq.start);\r\nif (IS_ERR(master)) {\r\nret = PTR_ERR(master);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nof_fsl_spi_free_chipselects(dev);\r\nreturn ret;\r\n}\r\nstatic int __devexit of_fsl_spi_remove(struct platform_device *ofdev)\r\n{\r\nint ret;\r\nret = mpc8xxx_spi_remove(&ofdev->dev);\r\nif (ret)\r\nreturn ret;\r\nof_fsl_spi_free_chipselects(&ofdev->dev);\r\nreturn 0;\r\n}\r\nstatic int __devinit plat_mpc8xxx_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *mem;\r\nint irq;\r\nstruct spi_master *master;\r\nif (!pdev->dev.platform_data)\r\nreturn -EINVAL;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem)\r\nreturn -EINVAL;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0)\r\nreturn -EINVAL;\r\nmaster = fsl_spi_probe(&pdev->dev, mem, irq);\r\nif (IS_ERR(master))\r\nreturn PTR_ERR(master);\r\nreturn 0;\r\n}\r\nstatic int __devexit plat_mpc8xxx_spi_remove(struct platform_device *pdev)\r\n{\r\nreturn mpc8xxx_spi_remove(&pdev->dev);\r\n}\r\nstatic void __init legacy_driver_register(void)\r\n{\r\nlegacy_driver_failed = platform_driver_register(&mpc8xxx_spi_driver);\r\n}\r\nstatic void __exit legacy_driver_unregister(void)\r\n{\r\nif (legacy_driver_failed)\r\nreturn;\r\nplatform_driver_unregister(&mpc8xxx_spi_driver);\r\n}\r\nstatic void __init legacy_driver_register(void) {}\r\nstatic void __exit legacy_driver_unregister(void) {}\r\nstatic int __init fsl_spi_init(void)\r\n{\r\nlegacy_driver_register();\r\nreturn platform_driver_register(&of_fsl_spi_driver);\r\n}\r\nstatic void __exit fsl_spi_exit(void)\r\n{\r\nplatform_driver_unregister(&of_fsl_spi_driver);\r\nlegacy_driver_unregister();\r\n}
