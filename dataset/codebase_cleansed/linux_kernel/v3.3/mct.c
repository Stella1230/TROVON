static void exynos4_mct_write(unsigned int value, void *addr)\r\n{\r\nvoid __iomem *stat_addr;\r\nu32 mask;\r\nu32 i;\r\n__raw_writel(value, addr);\r\nif (likely(addr >= EXYNOS4_MCT_L_BASE(0))) {\r\nu32 base = (u32) addr & EXYNOS4_MCT_L_MASK;\r\nswitch ((u32) addr & ~EXYNOS4_MCT_L_MASK) {\r\ncase (u32) MCT_L_TCON_OFFSET:\r\nstat_addr = (void __iomem *) base + MCT_L_WSTAT_OFFSET;\r\nmask = 1 << 3;\r\nbreak;\r\ncase (u32) MCT_L_ICNTB_OFFSET:\r\nstat_addr = (void __iomem *) base + MCT_L_WSTAT_OFFSET;\r\nmask = 1 << 1;\r\nbreak;\r\ncase (u32) MCT_L_TCNTB_OFFSET:\r\nstat_addr = (void __iomem *) base + MCT_L_WSTAT_OFFSET;\r\nmask = 1 << 0;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\n} else {\r\nswitch ((u32) addr) {\r\ncase (u32) EXYNOS4_MCT_G_TCON:\r\nstat_addr = EXYNOS4_MCT_G_WSTAT;\r\nmask = 1 << 16;\r\nbreak;\r\ncase (u32) EXYNOS4_MCT_G_COMP0_L:\r\nstat_addr = EXYNOS4_MCT_G_WSTAT;\r\nmask = 1 << 0;\r\nbreak;\r\ncase (u32) EXYNOS4_MCT_G_COMP0_U:\r\nstat_addr = EXYNOS4_MCT_G_WSTAT;\r\nmask = 1 << 1;\r\nbreak;\r\ncase (u32) EXYNOS4_MCT_G_COMP0_ADD_INCR:\r\nstat_addr = EXYNOS4_MCT_G_WSTAT;\r\nmask = 1 << 2;\r\nbreak;\r\ncase (u32) EXYNOS4_MCT_G_CNT_L:\r\nstat_addr = EXYNOS4_MCT_G_CNT_WSTAT;\r\nmask = 1 << 0;\r\nbreak;\r\ncase (u32) EXYNOS4_MCT_G_CNT_U:\r\nstat_addr = EXYNOS4_MCT_G_CNT_WSTAT;\r\nmask = 1 << 1;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nfor (i = 0; i < loops_per_jiffy / 1000 * HZ; i++)\r\nif (__raw_readl(stat_addr) & mask) {\r\n__raw_writel(mask, stat_addr);\r\nreturn;\r\n}\r\npanic("MCT hangs after writing %d (addr:0x%08x)\n", value, (u32)addr);\r\n}\r\nstatic void exynos4_mct_frc_start(u32 hi, u32 lo)\r\n{\r\nu32 reg;\r\nexynos4_mct_write(lo, EXYNOS4_MCT_G_CNT_L);\r\nexynos4_mct_write(hi, EXYNOS4_MCT_G_CNT_U);\r\nreg = __raw_readl(EXYNOS4_MCT_G_TCON);\r\nreg |= MCT_G_TCON_START;\r\nexynos4_mct_write(reg, EXYNOS4_MCT_G_TCON);\r\n}\r\nstatic cycle_t exynos4_frc_read(struct clocksource *cs)\r\n{\r\nunsigned int lo, hi;\r\nu32 hi2 = __raw_readl(EXYNOS4_MCT_G_CNT_U);\r\ndo {\r\nhi = hi2;\r\nlo = __raw_readl(EXYNOS4_MCT_G_CNT_L);\r\nhi2 = __raw_readl(EXYNOS4_MCT_G_CNT_U);\r\n} while (hi != hi2);\r\nreturn ((cycle_t)hi << 32) | lo;\r\n}\r\nstatic void exynos4_frc_resume(struct clocksource *cs)\r\n{\r\nexynos4_mct_frc_start(0, 0);\r\n}\r\nstatic void __init exynos4_clocksource_init(void)\r\n{\r\nexynos4_mct_frc_start(0, 0);\r\nif (clocksource_register_hz(&mct_frc, clk_rate))\r\npanic("%s: can't register clocksource\n", mct_frc.name);\r\n}\r\nstatic void exynos4_mct_comp0_stop(void)\r\n{\r\nunsigned int tcon;\r\ntcon = __raw_readl(EXYNOS4_MCT_G_TCON);\r\ntcon &= ~(MCT_G_TCON_COMP0_ENABLE | MCT_G_TCON_COMP0_AUTO_INC);\r\nexynos4_mct_write(tcon, EXYNOS4_MCT_G_TCON);\r\nexynos4_mct_write(0, EXYNOS4_MCT_G_INT_ENB);\r\n}\r\nstatic void exynos4_mct_comp0_start(enum clock_event_mode mode,\r\nunsigned long cycles)\r\n{\r\nunsigned int tcon;\r\ncycle_t comp_cycle;\r\ntcon = __raw_readl(EXYNOS4_MCT_G_TCON);\r\nif (mode == CLOCK_EVT_MODE_PERIODIC) {\r\ntcon |= MCT_G_TCON_COMP0_AUTO_INC;\r\nexynos4_mct_write(cycles, EXYNOS4_MCT_G_COMP0_ADD_INCR);\r\n}\r\ncomp_cycle = exynos4_frc_read(&mct_frc) + cycles;\r\nexynos4_mct_write((u32)comp_cycle, EXYNOS4_MCT_G_COMP0_L);\r\nexynos4_mct_write((u32)(comp_cycle >> 32), EXYNOS4_MCT_G_COMP0_U);\r\nexynos4_mct_write(0x1, EXYNOS4_MCT_G_INT_ENB);\r\ntcon |= MCT_G_TCON_COMP0_ENABLE;\r\nexynos4_mct_write(tcon , EXYNOS4_MCT_G_TCON);\r\n}\r\nstatic int exynos4_comp_set_next_event(unsigned long cycles,\r\nstruct clock_event_device *evt)\r\n{\r\nexynos4_mct_comp0_start(evt->mode, cycles);\r\nreturn 0;\r\n}\r\nstatic void exynos4_comp_set_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *evt)\r\n{\r\nexynos4_mct_comp0_stop();\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\nexynos4_mct_comp0_start(mode, clk_cnt_per_tick);\r\nbreak;\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\ncase CLOCK_EVT_MODE_UNUSED:\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\ncase CLOCK_EVT_MODE_RESUME:\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t exynos4_mct_comp_isr(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nexynos4_mct_write(0x1, EXYNOS4_MCT_G_INT_CSTAT);\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void exynos4_clockevent_init(void)\r\n{\r\nclk_cnt_per_tick = clk_rate / 2 / HZ;\r\nclockevents_calc_mult_shift(&mct_comp_device, clk_rate / 2, 5);\r\nmct_comp_device.max_delta_ns =\r\nclockevent_delta2ns(0xffffffff, &mct_comp_device);\r\nmct_comp_device.min_delta_ns =\r\nclockevent_delta2ns(0xf, &mct_comp_device);\r\nmct_comp_device.cpumask = cpumask_of(0);\r\nclockevents_register_device(&mct_comp_device);\r\nsetup_irq(IRQ_MCT_G0, &mct_comp_event_irq);\r\n}\r\nstatic void exynos4_mct_tick_stop(struct mct_clock_event_device *mevt)\r\n{\r\nunsigned long tmp;\r\nunsigned long mask = MCT_L_TCON_INT_START | MCT_L_TCON_TIMER_START;\r\nvoid __iomem *addr = mevt->base + MCT_L_TCON_OFFSET;\r\ntmp = __raw_readl(addr);\r\nif (tmp & mask) {\r\ntmp &= ~mask;\r\nexynos4_mct_write(tmp, addr);\r\n}\r\n}\r\nstatic void exynos4_mct_tick_start(unsigned long cycles,\r\nstruct mct_clock_event_device *mevt)\r\n{\r\nunsigned long tmp;\r\nexynos4_mct_tick_stop(mevt);\r\ntmp = (1 << 31) | cycles;\r\nexynos4_mct_write(tmp, mevt->base + MCT_L_ICNTB_OFFSET);\r\nexynos4_mct_write(0x1, mevt->base + MCT_L_INT_ENB_OFFSET);\r\ntmp = __raw_readl(mevt->base + MCT_L_TCON_OFFSET);\r\ntmp |= MCT_L_TCON_INT_START | MCT_L_TCON_TIMER_START |\r\nMCT_L_TCON_INTERVAL_MODE;\r\nexynos4_mct_write(tmp, mevt->base + MCT_L_TCON_OFFSET);\r\n}\r\nstatic int exynos4_tick_set_next_event(unsigned long cycles,\r\nstruct clock_event_device *evt)\r\n{\r\nstruct mct_clock_event_device *mevt = this_cpu_ptr(&percpu_mct_tick);\r\nexynos4_mct_tick_start(cycles, mevt);\r\nreturn 0;\r\n}\r\nstatic inline void exynos4_tick_set_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *evt)\r\n{\r\nstruct mct_clock_event_device *mevt = this_cpu_ptr(&percpu_mct_tick);\r\nexynos4_mct_tick_stop(mevt);\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\nexynos4_mct_tick_start(clk_cnt_per_tick, mevt);\r\nbreak;\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\ncase CLOCK_EVT_MODE_UNUSED:\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\ncase CLOCK_EVT_MODE_RESUME:\r\nbreak;\r\n}\r\n}\r\nstatic int exynos4_mct_tick_clear(struct mct_clock_event_device *mevt)\r\n{\r\nstruct clock_event_device *evt = mevt->evt;\r\nif (evt->mode != CLOCK_EVT_MODE_PERIODIC)\r\nexynos4_mct_tick_stop(mevt);\r\nif (__raw_readl(mevt->base + MCT_L_INT_CSTAT_OFFSET) & 1) {\r\nexynos4_mct_write(0x1, mevt->base + MCT_L_INT_CSTAT_OFFSET);\r\nreturn 1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic irqreturn_t exynos4_mct_tick_isr(int irq, void *dev_id)\r\n{\r\nstruct mct_clock_event_device *mevt = dev_id;\r\nstruct clock_event_device *evt = mevt->evt;\r\nexynos4_mct_tick_clear(mevt);\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void exynos4_mct_tick_init(struct clock_event_device *evt)\r\n{\r\nstruct mct_clock_event_device *mevt;\r\nunsigned int cpu = smp_processor_id();\r\nmevt = this_cpu_ptr(&percpu_mct_tick);\r\nmevt->evt = evt;\r\nmevt->base = EXYNOS4_MCT_L_BASE(cpu);\r\nsprintf(mevt->name, "mct_tick%d", cpu);\r\nevt->name = mevt->name;\r\nevt->cpumask = cpumask_of(cpu);\r\nevt->set_next_event = exynos4_tick_set_next_event;\r\nevt->set_mode = exynos4_tick_set_mode;\r\nevt->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;\r\nevt->rating = 450;\r\nclockevents_calc_mult_shift(evt, clk_rate / 2, 5);\r\nevt->max_delta_ns =\r\nclockevent_delta2ns(0x7fffffff, evt);\r\nevt->min_delta_ns =\r\nclockevent_delta2ns(0xf, evt);\r\nclockevents_register_device(evt);\r\nexynos4_mct_write(0x1, mevt->base + MCT_L_TCNTB_OFFSET);\r\nif (mct_int_type == MCT_INT_SPI) {\r\nif (cpu == 0) {\r\nmct_tick0_event_irq.dev_id = mevt;\r\nevt->irq = IRQ_MCT_L0;\r\nsetup_irq(IRQ_MCT_L0, &mct_tick0_event_irq);\r\n} else {\r\nmct_tick1_event_irq.dev_id = mevt;\r\nevt->irq = IRQ_MCT_L1;\r\nsetup_irq(IRQ_MCT_L1, &mct_tick1_event_irq);\r\nirq_set_affinity(IRQ_MCT_L1, cpumask_of(1));\r\n}\r\n} else {\r\nenable_percpu_irq(IRQ_MCT_LOCALTIMER, 0);\r\n}\r\n}\r\nint __cpuinit local_timer_setup(struct clock_event_device *evt)\r\n{\r\nexynos4_mct_tick_init(evt);\r\nreturn 0;\r\n}\r\nvoid local_timer_stop(struct clock_event_device *evt)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nevt->set_mode(CLOCK_EVT_MODE_UNUSED, evt);\r\nif (mct_int_type == MCT_INT_SPI)\r\nif (cpu == 0)\r\nremove_irq(evt->irq, &mct_tick0_event_irq);\r\nelse\r\nremove_irq(evt->irq, &mct_tick1_event_irq);\r\nelse\r\ndisable_percpu_irq(IRQ_MCT_LOCALTIMER);\r\n}\r\nstatic void __init exynos4_timer_resources(void)\r\n{\r\nstruct clk *mct_clk;\r\nmct_clk = clk_get(NULL, "xtal");\r\nclk_rate = clk_get_rate(mct_clk);\r\n#ifdef CONFIG_LOCAL_TIMERS\r\nif (mct_int_type == MCT_INT_PPI) {\r\nint err;\r\nerr = request_percpu_irq(IRQ_MCT_LOCALTIMER,\r\nexynos4_mct_tick_isr, "MCT",\r\n&percpu_mct_tick);\r\nWARN(err, "MCT: can't request IRQ %d (%d)\n",\r\nIRQ_MCT_LOCALTIMER, err);\r\n}\r\n#endif\r\n}\r\nstatic void __init exynos4_timer_init(void)\r\n{\r\nif (soc_is_exynos4210())\r\nmct_int_type = MCT_INT_SPI;\r\nelse\r\nmct_int_type = MCT_INT_PPI;\r\nexynos4_timer_resources();\r\nexynos4_clocksource_init();\r\nexynos4_clockevent_init();\r\n}
