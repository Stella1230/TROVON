void irlmp_add_discovery(hashbin_t *cachelog, discovery_t *new)\r\n{\r\ndiscovery_t *discovery, *node;\r\nunsigned long flags;\r\nnew->firststamp = new->timestamp;\r\nspin_lock_irqsave(&cachelog->hb_spinlock, flags);\r\ndiscovery = (discovery_t *) hashbin_get_first(cachelog);\r\nwhile (discovery != NULL ) {\r\nnode = discovery;\r\ndiscovery = (discovery_t *) hashbin_get_next(cachelog);\r\nif ((node->data.saddr == new->data.saddr) &&\r\n((node->data.daddr == new->data.daddr) ||\r\n(strcmp(node->data.info, new->data.info) == 0)))\r\n{\r\nhashbin_remove_this(cachelog, (irda_queue_t *) node);\r\nif (get_unaligned((__u16 *)node->data.hints) == get_unaligned((__u16 *)new->data.hints))\r\nnew->firststamp = node->firststamp;\r\nkfree(node);\r\n}\r\n}\r\nhashbin_insert(cachelog, (irda_queue_t *) new, new->data.daddr, NULL);\r\nspin_unlock_irqrestore(&cachelog->hb_spinlock, flags);\r\n}\r\nvoid irlmp_add_discovery_log(hashbin_t *cachelog, hashbin_t *log)\r\n{\r\ndiscovery_t *discovery;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nif (log == NULL) {\r\nreturn;\r\n}\r\ndiscovery = (discovery_t *) hashbin_remove_first(log);\r\nwhile (discovery != NULL) {\r\nirlmp_add_discovery(cachelog, discovery);\r\ndiscovery = (discovery_t *) hashbin_remove_first(log);\r\n}\r\nhashbin_delete(log, (FREE_FUNC) kfree);\r\n}\r\nvoid irlmp_expire_discoveries(hashbin_t *log, __u32 saddr, int force)\r\n{\r\ndiscovery_t * discovery;\r\ndiscovery_t * curr;\r\nunsigned long flags;\r\ndiscinfo_t * buffer = NULL;\r\nint n;\r\nint i = 0;\r\nIRDA_ASSERT(log != NULL, return;);\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nspin_lock_irqsave(&log->hb_spinlock, flags);\r\ndiscovery = (discovery_t *) hashbin_get_first(log);\r\nwhile (discovery != NULL) {\r\ncurr = discovery;\r\ndiscovery = (discovery_t *) hashbin_get_next(log);\r\nif ((curr->data.saddr == saddr) &&\r\n(force ||\r\n((jiffies - curr->timestamp) > DISCOVERY_EXPIRE_TIMEOUT)))\r\n{\r\nif(buffer == NULL) {\r\nn = HASHBIN_GET_SIZE(log);\r\nbuffer = kmalloc(n * sizeof(struct irda_device_info), GFP_ATOMIC);\r\nif (buffer == NULL) {\r\nspin_unlock_irqrestore(&log->hb_spinlock, flags);\r\nreturn;\r\n}\r\n}\r\nmemcpy(&(buffer[i]), &(curr->data),\r\nsizeof(discinfo_t));\r\ni++;\r\ncurr = hashbin_remove_this(log, (irda_queue_t *) curr);\r\nkfree(curr);\r\n}\r\n}\r\nspin_unlock_irqrestore(&log->hb_spinlock, flags);\r\nif(buffer == NULL)\r\nreturn;\r\nirlmp_discovery_expiry(buffer, i);\r\nkfree(buffer);\r\n}\r\nstruct irda_device_info *irlmp_copy_discoveries(hashbin_t *log, int *pn,\r\n__u16 mask, int old_entries)\r\n{\r\ndiscovery_t * discovery;\r\nunsigned long flags;\r\ndiscinfo_t * buffer = NULL;\r\nint j_timeout = (sysctl_discovery_timeout * HZ);\r\nint n;\r\nint i = 0;\r\nIRDA_ASSERT(pn != NULL, return NULL;);\r\nIRDA_ASSERT(log != NULL, return NULL;);\r\nspin_lock_irqsave(&log->hb_spinlock, flags);\r\ndiscovery = (discovery_t *) hashbin_get_first(log);\r\nwhile (discovery != NULL) {\r\nif ((get_unaligned((__u16 *)discovery->data.hints) & mask) &&\r\n((old_entries) ||\r\n((jiffies - discovery->firststamp) < j_timeout))) {\r\nif(buffer == NULL) {\r\nn = HASHBIN_GET_SIZE(log);\r\nbuffer = kmalloc(n * sizeof(struct irda_device_info), GFP_ATOMIC);\r\nif (buffer == NULL) {\r\nspin_unlock_irqrestore(&log->hb_spinlock, flags);\r\nreturn NULL;\r\n}\r\n}\r\nmemcpy(&(buffer[i]), &(discovery->data),\r\nsizeof(discinfo_t));\r\ni++;\r\n}\r\ndiscovery = (discovery_t *) hashbin_get_next(log);\r\n}\r\nspin_unlock_irqrestore(&log->hb_spinlock, flags);\r\n*pn = i;\r\nreturn buffer;\r\n}\r\nstatic inline discovery_t *discovery_seq_idx(loff_t pos)\r\n{\r\ndiscovery_t *discovery;\r\nfor (discovery = (discovery_t *) hashbin_get_first(irlmp->cachelog);\r\ndiscovery != NULL;\r\ndiscovery = (discovery_t *) hashbin_get_next(irlmp->cachelog)) {\r\nif (pos-- == 0)\r\nbreak;\r\n}\r\nreturn discovery;\r\n}\r\nstatic void *discovery_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nspin_lock_irq(&irlmp->cachelog->hb_spinlock);\r\nreturn *pos ? discovery_seq_idx(*pos - 1) : SEQ_START_TOKEN;\r\n}\r\nstatic void *discovery_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn (v == SEQ_START_TOKEN)\r\n? (void *) hashbin_get_first(irlmp->cachelog)\r\n: (void *) hashbin_get_next(irlmp->cachelog);\r\n}\r\nstatic void discovery_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nspin_unlock_irq(&irlmp->cachelog->hb_spinlock);\r\n}\r\nstatic int discovery_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq, "IrLMP: Discovery log:\n\n");\r\nelse {\r\nconst discovery_t *discovery = v;\r\nseq_printf(seq, "nickname: %s, hint: 0x%02x%02x",\r\ndiscovery->data.info,\r\ndiscovery->data.hints[0],\r\ndiscovery->data.hints[1]);\r\n#if 0\r\nif ( discovery->data.hints[0] & HINT_PNP)\r\nseq_puts(seq, "PnP Compatible ");\r\nif ( discovery->data.hints[0] & HINT_PDA)\r\nseq_puts(seq, "PDA/Palmtop ");\r\nif ( discovery->data.hints[0] & HINT_COMPUTER)\r\nseq_puts(seq, "Computer ");\r\nif ( discovery->data.hints[0] & HINT_PRINTER)\r\nseq_puts(seq, "Printer ");\r\nif ( discovery->data.hints[0] & HINT_MODEM)\r\nseq_puts(seq, "Modem ");\r\nif ( discovery->data.hints[0] & HINT_FAX)\r\nseq_puts(seq, "Fax ");\r\nif ( discovery->data.hints[0] & HINT_LAN)\r\nseq_puts(seq, "LAN Access ");\r\nif ( discovery->data.hints[1] & HINT_TELEPHONY)\r\nseq_puts(seq, "Telephony ");\r\nif ( discovery->data.hints[1] & HINT_FILE_SERVER)\r\nseq_puts(seq, "File Server ");\r\nif ( discovery->data.hints[1] & HINT_COMM)\r\nseq_puts(seq, "IrCOMM ");\r\nif ( discovery->data.hints[1] & HINT_OBEX)\r\nseq_puts(seq, "IrOBEX ");\r\n#endif\r\nseq_printf(seq,", saddr: 0x%08x, daddr: 0x%08x\n\n",\r\ndiscovery->data.saddr,\r\ndiscovery->data.daddr);\r\nseq_putc(seq, '\n');\r\n}\r\nreturn 0;\r\n}\r\nstatic int discovery_seq_open(struct inode *inode, struct file *file)\r\n{\r\nIRDA_ASSERT(irlmp != NULL, return -EINVAL;);\r\nreturn seq_open(file, &discovery_seq_ops);\r\n}
