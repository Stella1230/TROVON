static int copy_packages(__le16 *dest, u16 *src, int pkg_cnt, int space)\r\n{\r\nint i, cnt = pkg_cnt * 32;\r\nif (space < cnt)\r\nreturn -1;\r\nfor (i = 0; i < cnt; ++i)\r\ndest[i] = cpu_to_le16p(src + i);\r\nreturn cnt;\r\n}\r\nstatic int mjpeg_frame_header(struct go7007 *go, unsigned char *buf, int q)\r\n{\r\nint i, p = 0;\r\nbuf[p++] = 0xff;\r\nbuf[p++] = 0xd8;\r\nbuf[p++] = 0xff;\r\nbuf[p++] = 0xdb;\r\nbuf[p++] = 0;\r\nbuf[p++] = 2 + 65;\r\nbuf[p++] = 0;\r\nbuf[p++] = default_intra_quant_table[0];\r\nfor (i = 1; i < 64; ++i)\r\nbuf[p++] = (default_intra_quant_table[zz[i]] * q) >> 3;\r\nbuf[p++] = 0xff;\r\nbuf[p++] = 0xc0;\r\nbuf[p++] = 0;\r\nbuf[p++] = 17;\r\nbuf[p++] = 8;\r\nbuf[p++] = go->height >> 8;\r\nbuf[p++] = go->height & 0xff;\r\nbuf[p++] = go->width >> 8;\r\nbuf[p++] = go->width & 0xff;\r\nbuf[p++] = 3;\r\nbuf[p++] = 1;\r\nbuf[p++] = 0x22;\r\nbuf[p++] = 0;\r\nbuf[p++] = 2;\r\nbuf[p++] = 0x11;\r\nbuf[p++] = 0;\r\nbuf[p++] = 3;\r\nbuf[p++] = 0x11;\r\nbuf[p++] = 0;\r\nbuf[p++] = 0xff;\r\nbuf[p++] = 0xc4;\r\nbuf[p++] = 418 >> 8;\r\nbuf[p++] = 418 & 0xff;\r\nbuf[p++] = 0x00;\r\nmemcpy(buf + p, bits_dc_luminance + 1, 16);\r\np += 16;\r\nmemcpy(buf + p, val_dc_luminance, sizeof(val_dc_luminance));\r\np += sizeof(val_dc_luminance);\r\nbuf[p++] = 0x01;\r\nmemcpy(buf + p, bits_dc_chrominance + 1, 16);\r\np += 16;\r\nmemcpy(buf + p, val_dc_chrominance, sizeof(val_dc_chrominance));\r\np += sizeof(val_dc_chrominance);\r\nbuf[p++] = 0x10;\r\nmemcpy(buf + p, bits_ac_luminance + 1, 16);\r\np += 16;\r\nmemcpy(buf + p, val_ac_luminance, sizeof(val_ac_luminance));\r\np += sizeof(val_ac_luminance);\r\nbuf[p++] = 0x11;\r\nmemcpy(buf + p, bits_ac_chrominance + 1, 16);\r\np += 16;\r\nmemcpy(buf + p, val_ac_chrominance, sizeof(val_ac_chrominance));\r\np += sizeof(val_ac_chrominance);\r\nbuf[p++] = 0xff;\r\nbuf[p++] = 0xda;\r\nbuf[p++] = 0;\r\nbuf[p++] = 12;\r\nbuf[p++] = 3;\r\nbuf[p++] = 1;\r\nbuf[p++] = 0x00;\r\nbuf[p++] = 2;\r\nbuf[p++] = 0x11;\r\nbuf[p++] = 3;\r\nbuf[p++] = 0x11;\r\nbuf[p++] = 0;\r\nbuf[p++] = 63;\r\nbuf[p++] = 0;\r\nreturn p;\r\n}\r\nstatic int gen_mjpeghdr_to_package(struct go7007 *go, __le16 *code, int space)\r\n{\r\nu8 *buf;\r\nu16 mem = 0x3e00;\r\nunsigned int addr = 0x19;\r\nint size = 0, i, off = 0, chunk;\r\nbuf = kzalloc(4096, GFP_KERNEL);\r\nif (buf == NULL) {\r\nprintk(KERN_ERR "go7007: unable to allocate 4096 bytes for "\r\n"firmware construction\n");\r\nreturn -1;\r\n}\r\nfor (i = 1; i < 32; ++i) {\r\nmjpeg_frame_header(go, buf + size, i);\r\nsize += 80;\r\n}\r\nchunk = mjpeg_frame_header(go, buf + size, 1);\r\nmemmove(buf + size, buf + size + 80, chunk - 80);\r\nsize += chunk - 80;\r\nfor (i = 0; i < size; i += chunk * 2) {\r\nif (space - off < 32) {\r\noff = -1;\r\ngoto done;\r\n}\r\ncode[off + 1] = __cpu_to_le16(0x8000 | mem);\r\nchunk = 28;\r\nif (mem + chunk > 0x4000)\r\nchunk = 0x4000 - mem;\r\nif (i + 2 * chunk > size)\r\nchunk = (size - i) / 2;\r\nif (chunk < 28) {\r\ncode[off] = __cpu_to_le16(0x4000 | chunk);\r\ncode[off + 31] = __cpu_to_le16(addr++);\r\nmem = 0x3e00;\r\n} else {\r\ncode[off] = __cpu_to_le16(0x1000 | 28);\r\ncode[off + 31] = 0;\r\nmem += 28;\r\n}\r\nmemcpy(&code[off + 2], buf + i, chunk * 2);\r\noff += 32;\r\n}\r\ndone:\r\nkfree(buf);\r\nreturn off;\r\n}\r\nstatic int mpeg1_frame_header(struct go7007 *go, unsigned char *buf,\r\nint modulo, int pict_struct, enum mpeg_frame_type frame)\r\n{\r\nint i, j, mb_code, mb_len;\r\nint rows = go->interlace_coding ? go->height / 32 : go->height / 16;\r\nCODE_GEN(c, buf + 6);\r\nswitch (frame) {\r\ncase PFRAME:\r\nmb_code = 0x1;\r\nmb_len = 3;\r\nbreak;\r\ncase BFRAME_PRE:\r\nmb_code = 0x2;\r\nmb_len = 4;\r\nbreak;\r\ncase BFRAME_POST:\r\nmb_code = 0x2;\r\nmb_len = 3;\r\nbreak;\r\ncase BFRAME_BIDIR:\r\nmb_code = 0x2;\r\nmb_len = 2;\r\nbreak;\r\ndefault:\r\nmb_code = mb_len = 0;\r\nbreak;\r\n}\r\nCODE_ADD(c, frame == PFRAME ? 0x2 : 0x3, 13);\r\nCODE_ADD(c, 0xffff, 16);\r\nCODE_ADD(c, go->format == GO7007_FORMAT_MPEG2 ? 0x7 : 0x4, 4);\r\nif (frame != PFRAME)\r\nCODE_ADD(c, go->format == GO7007_FORMAT_MPEG2 ? 0x7 : 0x4, 4);\r\nelse\r\nCODE_ADD(c, 0, 4);\r\nCODE_ADD(c, 0, 3);\r\nj = 8 - (CODE_LENGTH(c) % 8);\r\nif (j != 8)\r\nCODE_ADD(c, 0, j);\r\nif (go->format == GO7007_FORMAT_MPEG2) {\r\nCODE_ADD(c, 0x1, 24);\r\nCODE_ADD(c, 0xb5, 8);\r\nCODE_ADD(c, 0x844, 12);\r\nCODE_ADD(c, frame == PFRAME ? 0xff : 0x44, 8);\r\nif (go->interlace_coding) {\r\nCODE_ADD(c, pict_struct, 4);\r\nif (go->dvd_mode)\r\nCODE_ADD(c, 0x000, 11);\r\nelse\r\nCODE_ADD(c, 0x200, 11);\r\n} else {\r\nCODE_ADD(c, 0x3, 4);\r\nCODE_ADD(c, 0x20c, 11);\r\n}\r\nj = 8 - (CODE_LENGTH(c) % 8);\r\nif (j != 8)\r\nCODE_ADD(c, 0, j);\r\n}\r\nfor (i = 0; i < rows; ++i) {\r\nCODE_ADD(c, 1, 24);\r\nCODE_ADD(c, i + 1, 8);\r\nCODE_ADD(c, 0x2, 6);\r\nCODE_ADD(c, 0x1, 1);\r\nCODE_ADD(c, mb_code, mb_len);\r\nif (go->interlace_coding) {\r\nCODE_ADD(c, 0x1, 2);\r\nCODE_ADD(c, pict_struct == 1 ? 0x0 : 0x1, 1);\r\n}\r\nif (frame == BFRAME_BIDIR) {\r\nCODE_ADD(c, 0x3, 2);\r\nif (go->interlace_coding)\r\nCODE_ADD(c, pict_struct == 1 ? 0x0 : 0x1, 1);\r\n}\r\nCODE_ADD(c, 0x3, 2);\r\nfor (j = (go->width >> 4) - 2; j >= 33; j -= 33)\r\nCODE_ADD(c, 0x8, 11);\r\nCODE_ADD(c, addrinctab[j][0], addrinctab[j][1]);\r\nCODE_ADD(c, mb_code, mb_len);\r\nif (go->interlace_coding) {\r\nCODE_ADD(c, 0x1, 2);\r\nCODE_ADD(c, pict_struct == 1 ? 0x0 : 0x1, 1);\r\n}\r\nif (frame == BFRAME_BIDIR) {\r\nCODE_ADD(c, 0x3, 2);\r\nif (go->interlace_coding)\r\nCODE_ADD(c, pict_struct == 1 ? 0x0 : 0x1, 1);\r\n}\r\nCODE_ADD(c, 0x3, 2);\r\nj = 8 - (CODE_LENGTH(c) % 8);\r\nif (j != 8)\r\nCODE_ADD(c, 0, j);\r\n}\r\ni = CODE_LENGTH(c) + 4 * 8;\r\nbuf[2] = 0x00;\r\nbuf[3] = 0x00;\r\nbuf[4] = 0x01;\r\nbuf[5] = 0x00;\r\nreturn i;\r\n}\r\nstatic int mpeg1_sequence_header(struct go7007 *go, unsigned char *buf, int ext)\r\n{\r\nint i, aspect_ratio, picture_rate;\r\nCODE_GEN(c, buf + 6);\r\nif (go->format == GO7007_FORMAT_MPEG1) {\r\nswitch (go->aspect_ratio) {\r\ncase GO7007_RATIO_4_3:\r\naspect_ratio = go->standard == GO7007_STD_NTSC ? 3 : 2;\r\nbreak;\r\ncase GO7007_RATIO_16_9:\r\naspect_ratio = go->standard == GO7007_STD_NTSC ? 5 : 4;\r\nbreak;\r\ndefault:\r\naspect_ratio = 1;\r\nbreak;\r\n}\r\n} else {\r\nswitch (go->aspect_ratio) {\r\ncase GO7007_RATIO_4_3:\r\naspect_ratio = 2;\r\nbreak;\r\ncase GO7007_RATIO_16_9:\r\naspect_ratio = 3;\r\nbreak;\r\ndefault:\r\naspect_ratio = 1;\r\nbreak;\r\n}\r\n}\r\nswitch (go->sensor_framerate) {\r\ncase 24000:\r\npicture_rate = 1;\r\nbreak;\r\ncase 24024:\r\npicture_rate = 2;\r\nbreak;\r\ncase 25025:\r\npicture_rate = go->interlace_coding ? 6 : 3;\r\nbreak;\r\ncase 30000:\r\npicture_rate = go->interlace_coding ? 7 : 4;\r\nbreak;\r\ncase 30030:\r\npicture_rate = go->interlace_coding ? 8 : 5;\r\nbreak;\r\ndefault:\r\npicture_rate = 5;\r\nbreak;\r\n}\r\nCODE_ADD(c, go->width, 12);\r\nCODE_ADD(c, go->height, 12);\r\nCODE_ADD(c, aspect_ratio, 4);\r\nCODE_ADD(c, picture_rate, 4);\r\nCODE_ADD(c, go->format == GO7007_FORMAT_MPEG2 ? 20000 : 0x3ffff, 18);\r\nCODE_ADD(c, 1, 1);\r\nCODE_ADD(c, go->format == GO7007_FORMAT_MPEG2 ? 112 : 20, 10);\r\nCODE_ADD(c, 0, 3);\r\ni = 8 - (CODE_LENGTH(c) % 8);\r\nif (i != 8)\r\nCODE_ADD(c, 0, i);\r\nif (go->format == GO7007_FORMAT_MPEG2) {\r\nCODE_ADD(c, 0x1, 24);\r\nCODE_ADD(c, 0xb5, 8);\r\nCODE_ADD(c, 0x148, 12);\r\nif (go->interlace_coding)\r\nCODE_ADD(c, 0x20001, 20);\r\nelse\r\nCODE_ADD(c, 0xa0001, 20);\r\nCODE_ADD(c, 0, 16);\r\ni = 8 - (CODE_LENGTH(c) % 8);\r\nif (i != 8)\r\nCODE_ADD(c, 0, i);\r\nif (ext) {\r\nCODE_ADD(c, 0x1, 24);\r\nCODE_ADD(c, 0xb52, 12);\r\nCODE_ADD(c, go->standard == GO7007_STD_NTSC ? 2 : 1, 3);\r\nCODE_ADD(c, 0x105, 9);\r\nCODE_ADD(c, 0x505, 16);\r\nCODE_ADD(c, go->width, 14);\r\nCODE_ADD(c, 1, 1);\r\nCODE_ADD(c, go->height, 14);\r\ni = 8 - (CODE_LENGTH(c) % 8);\r\nif (i != 8)\r\nCODE_ADD(c, 0, i);\r\n}\r\n}\r\ni = CODE_LENGTH(c) + 4 * 8;\r\nbuf[0] = i & 0xff;\r\nbuf[1] = i >> 8;\r\nbuf[2] = 0x00;\r\nbuf[3] = 0x00;\r\nbuf[4] = 0x01;\r\nbuf[5] = 0xb3;\r\nreturn i;\r\n}\r\nstatic int gen_mpeg1hdr_to_package(struct go7007 *go,\r\n__le16 *code, int space, int *framelen)\r\n{\r\nu8 *buf;\r\nu16 mem = 0x3e00;\r\nunsigned int addr = 0x19;\r\nint i, off = 0, chunk;\r\nbuf = kzalloc(5120, GFP_KERNEL);\r\nif (buf == NULL) {\r\nprintk(KERN_ERR "go7007: unable to allocate 5120 bytes for "\r\n"firmware construction\n");\r\nreturn -1;\r\n}\r\nframelen[0] = mpeg1_frame_header(go, buf, 0, 1, PFRAME);\r\nif (go->interlace_coding)\r\nframelen[0] += mpeg1_frame_header(go, buf + framelen[0] / 8,\r\n0, 2, PFRAME);\r\nbuf[0] = framelen[0] & 0xff;\r\nbuf[1] = framelen[0] >> 8;\r\ni = 368;\r\nframelen[1] = mpeg1_frame_header(go, buf + i, 0, 1, BFRAME_PRE);\r\nif (go->interlace_coding)\r\nframelen[1] += mpeg1_frame_header(go, buf + i + framelen[1] / 8,\r\n0, 2, BFRAME_PRE);\r\nbuf[i] = framelen[1] & 0xff;\r\nbuf[i + 1] = framelen[1] >> 8;\r\ni += 1632;\r\nframelen[2] = mpeg1_frame_header(go, buf + i, 0, 1, BFRAME_POST);\r\nif (go->interlace_coding)\r\nframelen[2] += mpeg1_frame_header(go, buf + i + framelen[2] / 8,\r\n0, 2, BFRAME_POST);\r\nbuf[i] = framelen[2] & 0xff;\r\nbuf[i + 1] = framelen[2] >> 8;\r\ni += 1432;\r\nframelen[3] = mpeg1_frame_header(go, buf + i, 0, 1, BFRAME_BIDIR);\r\nif (go->interlace_coding)\r\nframelen[3] += mpeg1_frame_header(go, buf + i + framelen[3] / 8,\r\n0, 2, BFRAME_BIDIR);\r\nbuf[i] = framelen[3] & 0xff;\r\nbuf[i + 1] = framelen[3] >> 8;\r\ni += 1632 + 16;\r\nmpeg1_sequence_header(go, buf + i, 0);\r\ni += 40;\r\nfor (i = 0; i < 5120; i += chunk * 2) {\r\nif (space - off < 32) {\r\noff = -1;\r\ngoto done;\r\n}\r\ncode[off + 1] = __cpu_to_le16(0x8000 | mem);\r\nchunk = 28;\r\nif (mem + chunk > 0x4000)\r\nchunk = 0x4000 - mem;\r\nif (i + 2 * chunk > 5120)\r\nchunk = (5120 - i) / 2;\r\nif (chunk < 28) {\r\ncode[off] = __cpu_to_le16(0x4000 | chunk);\r\ncode[off + 31] = __cpu_to_le16(addr);\r\nif (mem + chunk == 0x4000) {\r\nmem = 0x3e00;\r\n++addr;\r\n}\r\n} else {\r\ncode[off] = __cpu_to_le16(0x1000 | 28);\r\ncode[off + 31] = 0;\r\nmem += 28;\r\n}\r\nmemcpy(&code[off + 2], buf + i, chunk * 2);\r\noff += 32;\r\n}\r\ndone:\r\nkfree(buf);\r\nreturn off;\r\n}\r\nstatic int vti_bitlen(struct go7007 *go)\r\n{\r\nunsigned int i, max_time_incr = go->sensor_framerate / go->fps_scale;\r\nfor (i = 31; (max_time_incr & ((1 << i) - 1)) == max_time_incr; --i);\r\nreturn i + 1;\r\n}\r\nstatic int mpeg4_frame_header(struct go7007 *go, unsigned char *buf,\r\nint modulo, enum mpeg_frame_type frame)\r\n{\r\nint i;\r\nCODE_GEN(c, buf + 6);\r\nint mb_count = (go->width >> 4) * (go->height >> 4);\r\nCODE_ADD(c, frame == PFRAME ? 0x1 : 0x2, 2);\r\nif (modulo)\r\nCODE_ADD(c, 0x1, 1);\r\nCODE_ADD(c, 0x1, 2);\r\nCODE_ADD(c, 0, vti_bitlen(go));\r\nCODE_ADD(c, 0x3, 2);\r\nif (frame == PFRAME)\r\nCODE_ADD(c, 0, 1);\r\nCODE_ADD(c, 0xc, 11);\r\nif (frame != PFRAME)\r\nCODE_ADD(c, 0x4, 3);\r\nif (frame != BFRAME_EMPTY) {\r\nfor (i = 0; i < mb_count; ++i) {\r\nswitch (frame) {\r\ncase PFRAME:\r\nCODE_ADD(c, 0x1, 1);\r\nbreak;\r\ncase BFRAME_PRE:\r\nCODE_ADD(c, 0x47, 8);\r\nbreak;\r\ncase BFRAME_POST:\r\nCODE_ADD(c, 0x27, 7);\r\nbreak;\r\ncase BFRAME_BIDIR:\r\nCODE_ADD(c, 0x5f, 8);\r\nbreak;\r\ncase BFRAME_EMPTY:\r\nbreak;\r\n}\r\n}\r\n}\r\ni = 8 - (CODE_LENGTH(c) % 8);\r\nCODE_ADD(c, 0, 1);\r\nCODE_ADD(c, (1 << (i - 1)) - 1, i - 1);\r\ni = CODE_LENGTH(c) + 4 * 8;\r\nbuf[0] = i & 0xff;\r\nbuf[1] = i >> 8;\r\nbuf[2] = 0x00;\r\nbuf[3] = 0x00;\r\nbuf[4] = 0x01;\r\nbuf[5] = 0xb6;\r\nreturn i;\r\n}\r\nstatic int mpeg4_sequence_header(struct go7007 *go, unsigned char *buf, int ext)\r\n{\r\nconst unsigned char head[] = { 0x00, 0x00, 0x01, 0xb0, go->pali,\r\n0x00, 0x00, 0x01, 0xb5, 0x09,\r\n0x00, 0x00, 0x01, 0x00,\r\n0x00, 0x00, 0x01, 0x20, };\r\nint i, aspect_ratio;\r\nint fps = go->sensor_framerate / go->fps_scale;\r\nCODE_GEN(c, buf + 2 + sizeof(head));\r\nswitch (go->aspect_ratio) {\r\ncase GO7007_RATIO_4_3:\r\naspect_ratio = go->standard == GO7007_STD_NTSC ? 3 : 2;\r\nbreak;\r\ncase GO7007_RATIO_16_9:\r\naspect_ratio = go->standard == GO7007_STD_NTSC ? 5 : 4;\r\nbreak;\r\ndefault:\r\naspect_ratio = 1;\r\nbreak;\r\n}\r\nmemcpy(buf + 2, head, sizeof(head));\r\nCODE_ADD(c, 0x191, 17);\r\nCODE_ADD(c, aspect_ratio, 4);\r\nCODE_ADD(c, 0x1, 4);\r\nCODE_ADD(c, fps, 16);\r\nCODE_ADD(c, 0x3, 2);\r\nCODE_ADD(c, 1001, vti_bitlen(go));\r\nCODE_ADD(c, 1, 1);\r\nCODE_ADD(c, go->width, 13);\r\nCODE_ADD(c, 1, 1);\r\nCODE_ADD(c, go->height, 13);\r\nCODE_ADD(c, 0x2830, 14);\r\ni = 8 - (CODE_LENGTH(c) % 8);\r\nCODE_ADD(c, 0, 1);\r\nCODE_ADD(c, (1 << (i - 1)) - 1, i - 1);\r\ni = CODE_LENGTH(c) + sizeof(head) * 8;\r\nbuf[0] = i & 0xff;\r\nbuf[1] = i >> 8;\r\nreturn i;\r\n}\r\nstatic int gen_mpeg4hdr_to_package(struct go7007 *go,\r\n__le16 *code, int space, int *framelen)\r\n{\r\nu8 *buf;\r\nu16 mem = 0x3e00;\r\nunsigned int addr = 0x19;\r\nint i, off = 0, chunk;\r\nbuf = kzalloc(5120, GFP_KERNEL);\r\nif (buf == NULL) {\r\nprintk(KERN_ERR "go7007: unable to allocate 5120 bytes for "\r\n"firmware construction\n");\r\nreturn -1;\r\n}\r\nframelen[0] = mpeg4_frame_header(go, buf, 0, PFRAME);\r\ni = 368;\r\nframelen[1] = mpeg4_frame_header(go, buf + i, 0, BFRAME_PRE);\r\ni += 1632;\r\nframelen[2] = mpeg4_frame_header(go, buf + i, 0, BFRAME_POST);\r\ni += 1432;\r\nframelen[3] = mpeg4_frame_header(go, buf + i, 0, BFRAME_BIDIR);\r\ni += 1632;\r\nmpeg4_frame_header(go, buf + i, 0, BFRAME_EMPTY);\r\ni += 16;\r\nmpeg4_sequence_header(go, buf + i, 0);\r\ni += 40;\r\nfor (i = 0; i < 5120; i += chunk * 2) {\r\nif (space - off < 32) {\r\noff = -1;\r\ngoto done;\r\n}\r\ncode[off + 1] = __cpu_to_le16(0x8000 | mem);\r\nchunk = 28;\r\nif (mem + chunk > 0x4000)\r\nchunk = 0x4000 - mem;\r\nif (i + 2 * chunk > 5120)\r\nchunk = (5120 - i) / 2;\r\nif (chunk < 28) {\r\ncode[off] = __cpu_to_le16(0x4000 | chunk);\r\ncode[off + 31] = __cpu_to_le16(addr);\r\nif (mem + chunk == 0x4000) {\r\nmem = 0x3e00;\r\n++addr;\r\n}\r\n} else {\r\ncode[off] = __cpu_to_le16(0x1000 | 28);\r\ncode[off + 31] = 0;\r\nmem += 28;\r\n}\r\nmemcpy(&code[off + 2], buf + i, chunk * 2);\r\noff += 32;\r\n}\r\nmem = 0x3e00;\r\naddr = go->ipb ? 0x14f9 : 0x0af9;\r\nmemset(buf, 0, 5120);\r\nframelen[4] = mpeg4_frame_header(go, buf, 1, PFRAME);\r\ni = 368;\r\nframelen[5] = mpeg4_frame_header(go, buf + i, 1, BFRAME_PRE);\r\ni += 1632;\r\nframelen[6] = mpeg4_frame_header(go, buf + i, 1, BFRAME_POST);\r\ni += 1432;\r\nframelen[7] = mpeg4_frame_header(go, buf + i, 1, BFRAME_BIDIR);\r\ni += 1632;\r\nmpeg4_frame_header(go, buf + i, 1, BFRAME_EMPTY);\r\ni += 16;\r\nfor (i = 0; i < 5120; i += chunk * 2) {\r\nif (space - off < 32) {\r\noff = -1;\r\ngoto done;\r\n}\r\ncode[off + 1] = __cpu_to_le16(0x8000 | mem);\r\nchunk = 28;\r\nif (mem + chunk > 0x4000)\r\nchunk = 0x4000 - mem;\r\nif (i + 2 * chunk > 5120)\r\nchunk = (5120 - i) / 2;\r\nif (chunk < 28) {\r\ncode[off] = __cpu_to_le16(0x4000 | chunk);\r\ncode[off + 31] = __cpu_to_le16(addr);\r\nif (mem + chunk == 0x4000) {\r\nmem = 0x3e00;\r\n++addr;\r\n}\r\n} else {\r\ncode[off] = __cpu_to_le16(0x1000 | 28);\r\ncode[off + 31] = 0;\r\nmem += 28;\r\n}\r\nmemcpy(&code[off + 2], buf + i, chunk * 2);\r\noff += 32;\r\n}\r\ndone:\r\nkfree(buf);\r\nreturn off;\r\n}\r\nstatic int brctrl_to_package(struct go7007 *go,\r\n__le16 *code, int space, int *framelen)\r\n{\r\nint converge_speed = 0;\r\nint lambda = (go->format == GO7007_FORMAT_MJPEG || go->dvd_mode) ?\r\n100 : 0;\r\nint peak_rate = 6 * go->bitrate / 5;\r\nint vbv_buffer = go->format == GO7007_FORMAT_MJPEG ?\r\ngo->bitrate :\r\n(go->dvd_mode ? 900000 : peak_rate);\r\nint fps = go->sensor_framerate / go->fps_scale;\r\nint q = 0;\r\nu32 sgop_expt_addr = go->bitrate / 32 * (go->ipb ? 3 : 1) * 1001 / fps;\r\nu32 sgop_peak_addr = peak_rate / 32 * 1001 / fps;\r\nu32 total_expt_addr = go->bitrate / 32 * 1000 / fps * (fps / 1000);\r\nu32 vbv_alert_addr = vbv_buffer * 3 / (4 * 32);\r\nu32 cplx[] = {\r\nq > 0 ? sgop_expt_addr * q :\r\n2 * go->width * go->height * (go->ipb ? 6 : 4) / 32,\r\nq > 0 ? sgop_expt_addr * q :\r\n2 * go->width * go->height * (go->ipb ? 6 : 4) / 32,\r\nq > 0 ? sgop_expt_addr * q :\r\n2 * go->width * go->height * (go->ipb ? 6 : 4) / 32,\r\nq > 0 ? sgop_expt_addr * q :\r\n2 * go->width * go->height * (go->ipb ? 6 : 4) / 32,\r\n};\r\nu32 calc_q = q > 0 ? q : cplx[0] / sgop_expt_addr;\r\nu16 pack[] = {\r\n0x200e, 0x0000,\r\n0xBF20, go->ipb ? converge_speed_ipb[converge_speed]\r\n: converge_speed_ip[converge_speed],\r\n0xBF21, go->ipb ? 2 : 0,\r\n0xBF22, go->ipb ? LAMBDA_table[0][lambda / 2 + 50]\r\n: 32767,\r\n0xBF23, go->ipb ? LAMBDA_table[1][lambda] : 32767,\r\n0xBF24, 32767,\r\n0xBF25, lambda > 99 ? 32767 : LAMBDA_table[3][lambda],\r\n0xBF26, sgop_expt_addr & 0x0000FFFF,\r\n0xBF27, sgop_expt_addr >> 16,\r\n0xBF28, sgop_peak_addr & 0x0000FFFF,\r\n0xBF29, sgop_peak_addr >> 16,\r\n0xBF2A, vbv_alert_addr & 0x0000FFFF,\r\n0xBF2B, vbv_alert_addr >> 16,\r\n0xBF2C, 0,\r\n0xBF2D, 0,\r\n0, 0,\r\n0x200e, 0x0000,\r\n0xBF2E, vbv_alert_addr & 0x0000FFFF,\r\n0xBF2F, vbv_alert_addr >> 16,\r\n0xBF30, cplx[0] & 0x0000FFFF,\r\n0xBF31, cplx[0] >> 16,\r\n0xBF32, cplx[1] & 0x0000FFFF,\r\n0xBF33, cplx[1] >> 16,\r\n0xBF34, cplx[2] & 0x0000FFFF,\r\n0xBF35, cplx[2] >> 16,\r\n0xBF36, cplx[3] & 0x0000FFFF,\r\n0xBF37, cplx[3] >> 16,\r\n0xBF38, 0,\r\n0xBF39, 0,\r\n0xBF3A, total_expt_addr & 0x0000FFFF,\r\n0xBF3B, total_expt_addr >> 16,\r\n0, 0,\r\n0x200e, 0x0000,\r\n0xBF3C, total_expt_addr & 0x0000FFFF,\r\n0xBF3D, total_expt_addr >> 16,\r\n0xBF3E, 0,\r\n0xBF3F, 0,\r\n0xBF48, 0,\r\n0xBF49, 0,\r\n0xBF4A, calc_q < 4 ? 4 : (calc_q > 124 ? 124 : calc_q),\r\n0xBF4B, 4,\r\n0xBF4C, 0,\r\n0xBF4D, 0,\r\n0xBF4E, 0,\r\n0xBF4F, 0,\r\n0xBF50, 0,\r\n0xBF51, 0,\r\n0, 0,\r\n0x200e, 0x0000,\r\n0xBF40, sgop_expt_addr & 0x0000FFFF,\r\n0xBF41, sgop_expt_addr >> 16,\r\n0xBF42, 0,\r\n0xBF43, 0,\r\n0xBF44, 0,\r\n0xBF45, 0,\r\n0xBF46, (go->width >> 4) * (go->height >> 4),\r\n0xBF47, 0,\r\n0xBF64, 0,\r\n0xBF65, 0,\r\n0xBF18, framelen[4],\r\n0xBF19, framelen[5],\r\n0xBF1A, framelen[6],\r\n0xBF1B, framelen[7],\r\n0, 0,\r\n#if 0\r\n0x200e, 0x0000,\r\n0xBF56, 4,\r\n0xBF57, 0,\r\n0xBF58, 5,\r\n0xBF59, 0,\r\n0xBF5A, 6,\r\n0xBF5B, 0,\r\n0xBF5C, 8,\r\n0xBF5D, 0,\r\n0xBF5E, 1,\r\n0xBF5F, 0,\r\n0xBF60, 1,\r\n0xBF61, 0,\r\n0xBF62, 0,\r\n0xBF63, 0,\r\n0, 0,\r\n#else\r\n0x2008, 0x0000,\r\n0xBF56, 4,\r\n0xBF57, 0,\r\n0xBF58, 5,\r\n0xBF59, 0,\r\n0xBF5A, 6,\r\n0xBF5B, 0,\r\n0xBF5C, 8,\r\n0xBF5D, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n#endif\r\n0x200e, 0x0000,\r\n0xBF10, 0,\r\n0xBF11, 0,\r\n0xBF12, 0,\r\n0xBF13, 0,\r\n0xBF14, 0,\r\n0xBF15, 0,\r\n0xBF16, 0,\r\n0xBF17, 0,\r\n0xBF7E, 0,\r\n0xBF7F, 1,\r\n0xBF52, framelen[0],\r\n0xBF53, framelen[1],\r\n0xBF54, framelen[2],\r\n0xBF55, framelen[3],\r\n0, 0,\r\n};\r\nreturn copy_packages(code, pack, 6, space);\r\n}\r\nstatic int config_package(struct go7007 *go, __le16 *code, int space)\r\n{\r\nint fps = go->sensor_framerate / go->fps_scale / 1000;\r\nint rows = go->interlace_coding ? go->height / 32 : go->height / 16;\r\nint brc_window_size = fps;\r\nint q_min = 2, q_max = 31;\r\nint THACCoeffSet0 = 0;\r\nu16 pack[] = {\r\n0x200e, 0x0000,\r\n0xc002, 0x14b4,\r\n0xc003, 0x28b4,\r\n0xc004, 0x3c5a,\r\n0xdc05, 0x2a77,\r\n0xc6c3, go->format == GO7007_FORMAT_MPEG4 ? 0 :\r\n(go->format == GO7007_FORMAT_H263 ? 0 : 1),\r\n0xc680, go->format == GO7007_FORMAT_MPEG4 ? 0xf1 :\r\n(go->format == GO7007_FORMAT_H263 ? 0x61 :\r\n0xd3),\r\n0xc780, 0x0140,\r\n0xe009, 0x0001,\r\n0xc60f, 0x0008,\r\n0xd4ff, 0x0002,\r\n0xe403, 2340,\r\n0xe406, 75,\r\n0xd411, 0x0001,\r\n0xd410, 0xa1d6,\r\n0x0001, 0x2801,\r\n0x200d, 0x0000,\r\n0xe402, 0x018b,\r\n0xe401, 0x8b01,\r\n0xd472, (go->board_info->sensor_flags &\r\nGO7007_SENSOR_TV) &&\r\n(!go->interlace_coding) ?\r\n0x01b0 : 0x0170,\r\n0xd475, (go->board_info->sensor_flags &\r\nGO7007_SENSOR_TV) &&\r\n(!go->interlace_coding) ?\r\n0x0008 : 0x0009,\r\n0xc404, go->interlace_coding ? 0x44 :\r\n(go->format == GO7007_FORMAT_MPEG4 ? 0x11 :\r\n(go->format == GO7007_FORMAT_MPEG1 ? 0x02 :\r\n(go->format == GO7007_FORMAT_MPEG2 ? 0x04 :\r\n(go->format == GO7007_FORMAT_H263 ? 0x08 :\r\n0x20)))),\r\n0xbf0a, (go->format == GO7007_FORMAT_MPEG4 ? 8 :\r\n(go->format == GO7007_FORMAT_MPEG1 ? 1 :\r\n(go->format == GO7007_FORMAT_MPEG2 ? 2 :\r\n(go->format == GO7007_FORMAT_H263 ? 4 : 16)))) |\r\n((go->repeat_seqhead ? 1 : 0) << 6) |\r\n((go->dvd_mode ? 1 : 0) << 9) |\r\n((go->gop_header_enable ? 1 : 0) << 10),\r\n0xbf0b, 0,\r\n0xdd5a, go->ipb ? 0x14 : 0x0a,\r\n0xbf0c, 0,\r\n0xbf0d, 0,\r\n0xc683, THACCoeffSet0,\r\n0xc40a, (go->width << 4) | rows,\r\n0xe01a, go->board_info->hpi_buffer_cap,\r\n0, 0,\r\n0, 0,\r\n0x2008, 0,\r\n0xe402, 0x88,\r\n0xe401, 0x8f01,\r\n0xbf6a, 0,\r\n0xbf6b, 0,\r\n0xbf6c, 0,\r\n0xbf6d, 0,\r\n0xbf6e, 0,\r\n0xbf6f, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0x200e, 0,\r\n0xbf66, brc_window_size,\r\n0xbf67, 0,\r\n0xbf68, q_min,\r\n0xbf69, q_max,\r\n0xbfe0, 0,\r\n0xbfe1, 0,\r\n0xbfe2, 0,\r\n0xbfe3, go->ipb ? 3 : 1,\r\n0xc031, go->board_info->sensor_flags &\r\nGO7007_SENSOR_VBI ? 1 : 0,\r\n0xc01c, 0x1f,\r\n0xdd8c, 0x15,\r\n0xdd94, 0x15,\r\n0xdd88, go->ipb ? 0x1401 : 0x0a01,\r\n0xdd90, go->ipb ? 0x1401 : 0x0a01,\r\n0, 0,\r\n0x200e, 0,\r\n0xbfe4, 0,\r\n0xbfe5, 0,\r\n0xbfe6, 0,\r\n0xbfe7, fps << 8,\r\n0xbfe8, 0x3a00,\r\n0xbfe9, 0,\r\n0xbfea, 0,\r\n0xbfeb, 0,\r\n0xbfec, (go->interlace_coding ? 1 << 15 : 0) |\r\n(go->modet_enable ? 0xa : 0) |\r\n(go->board_info->sensor_flags &\r\nGO7007_SENSOR_VBI ? 1 : 0),\r\n0xbfed, 0,\r\n0xbfee, 0,\r\n0xbfef, 0,\r\n0xbff0, go->board_info->sensor_flags &\r\nGO7007_SENSOR_TV ? 0xf060 : 0xb060,\r\n0xbff1, 0,\r\n0, 0,\r\n};\r\nreturn copy_packages(code, pack, 5, space);\r\n}\r\nstatic int seqhead_to_package(struct go7007 *go, __le16 *code, int space,\r\nint (*sequence_header_func)(struct go7007 *go,\r\nunsigned char *buf, int ext))\r\n{\r\nint vop_time_increment_bitlength = vti_bitlen(go);\r\nint fps = go->sensor_framerate / go->fps_scale *\r\n(go->interlace_coding ? 2 : 1);\r\nunsigned char buf[40] = { };\r\nint len = sequence_header_func(go, buf, 1);\r\nu16 pack[] = {\r\n0x2006, 0,\r\n0xbf08, fps,\r\n0xbf09, 0,\r\n0xbff2, vop_time_increment_bitlength,\r\n0xbff3, (1 << vop_time_increment_bitlength) - 1,\r\n0xbfe6, 0,\r\n0xbfe7, (fps / 1000) << 8,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0x2007, 0,\r\n0xc800, buf[2] << 8 | buf[3],\r\n0xc801, buf[4] << 8 | buf[5],\r\n0xc802, buf[6] << 8 | buf[7],\r\n0xc803, buf[8] << 8 | buf[9],\r\n0xc406, 64,\r\n0xc407, len - 64,\r\n0xc61b, 1,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0x200e, 0,\r\n0xc808, buf[10] << 8 | buf[11],\r\n0xc809, buf[12] << 8 | buf[13],\r\n0xc80a, buf[14] << 8 | buf[15],\r\n0xc80b, buf[16] << 8 | buf[17],\r\n0xc80c, buf[18] << 8 | buf[19],\r\n0xc80d, buf[20] << 8 | buf[21],\r\n0xc80e, buf[22] << 8 | buf[23],\r\n0xc80f, buf[24] << 8 | buf[25],\r\n0xc810, buf[26] << 8 | buf[27],\r\n0xc811, buf[28] << 8 | buf[29],\r\n0xc812, buf[30] << 8 | buf[31],\r\n0xc813, buf[32] << 8 | buf[33],\r\n0xc814, buf[34] << 8 | buf[35],\r\n0xc815, buf[36] << 8 | buf[37],\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n};\r\nreturn copy_packages(code, pack, 3, space);\r\n}\r\nstatic int relative_prime(int big, int little)\r\n{\r\nint remainder;\r\nwhile (little != 0) {\r\nremainder = big % little;\r\nbig = little;\r\nlittle = remainder;\r\n}\r\nreturn big;\r\n}\r\nstatic int avsync_to_package(struct go7007 *go, __le16 *code, int space)\r\n{\r\nint arate = go->board_info->audio_rate * 1001 * go->fps_scale;\r\nint ratio = arate / go->sensor_framerate;\r\nint adjratio = ratio * 215 / 100;\r\nint rprime = relative_prime(go->sensor_framerate,\r\narate % go->sensor_framerate);\r\nint f1 = (arate % go->sensor_framerate) / rprime;\r\nint f2 = (go->sensor_framerate - arate % go->sensor_framerate) / rprime;\r\nu16 pack[] = {\r\n0x200e, 0,\r\n0xbf98, (u16)((-adjratio) & 0xffff),\r\n0xbf99, (u16)((-adjratio) >> 16),\r\n0xbf92, 0,\r\n0xbf93, 0,\r\n0xbff4, f1 > f2 ? f1 : f2,\r\n0xbff5, f1 < f2 ? f1 : f2,\r\n0xbff6, f1 < f2 ? ratio : ratio + 1,\r\n0xbff7, f1 > f2 ? ratio : ratio + 1,\r\n0xbff8, 0,\r\n0xbff9, 0,\r\n0xbffa, adjratio & 0xffff,\r\n0xbffb, adjratio >> 16,\r\n0xbf94, 0,\r\n0xbf95, 0,\r\n0, 0,\r\n};\r\nreturn copy_packages(code, pack, 1, space);\r\n}\r\nstatic int final_package(struct go7007 *go, __le16 *code, int space)\r\n{\r\nint rows = go->interlace_coding ? go->height / 32 : go->height / 16;\r\nu16 pack[] = {\r\n0x8000,\r\n0,\r\n0,\r\n0,\r\n0,\r\n0,\r\n0,\r\n2,\r\n((go->board_info->sensor_flags & GO7007_SENSOR_TV) &&\r\n(!go->interlace_coding) ?\r\n(1 << 14) | (1 << 9) : 0) |\r\n((go->encoder_subsample ? 1 : 0) << 8) |\r\n(go->board_info->sensor_flags &\r\nGO7007_SENSOR_CONFIG_MASK),\r\n((go->encoder_v_halve ? 1 : 0) << 14) |\r\n(go->encoder_v_halve ? rows << 9 : rows << 8) |\r\n(go->encoder_h_halve ? 1 << 6 : 0) |\r\n(go->encoder_h_halve ? go->width >> 3 : go->width >> 4),\r\n(1 << 15) | (go->encoder_v_offset << 6) |\r\n(1 << 7) | (go->encoder_h_offset >> 2),\r\n(1 << 6),\r\n0,\r\n0,\r\n((go->fps_scale - 1) << 8) |\r\n(go->board_info->sensor_flags & GO7007_SENSOR_TV ?\r\n(1 << 7) : 0) |\r\n0x41,\r\ngo->ipb ? 0xd4c : 0x36b,\r\n(rows << 8) | (go->width >> 4),\r\ngo->format == GO7007_FORMAT_MPEG4 ? 0x0404 : 0,\r\n(1 << 15) | ((go->interlace_coding ? 1 : 0) << 13) |\r\n((go->closed_gop ? 1 : 0) << 12) |\r\n((go->format == GO7007_FORMAT_MPEG4 ? 1 : 0) << 11) |\r\n((go->ipb ? 3 : 0) << 7) |\r\n((go->modet_enable ? 1 : 0) << 2) |\r\n((go->dvd_mode ? 1 : 0) << 1) | 1,\r\n(go->format == GO7007_FORMAT_MPEG1 ? 0x89a0 :\r\n(go->format == GO7007_FORMAT_MPEG2 ? 0x89a0 :\r\n(go->format == GO7007_FORMAT_MJPEG ? 0x89a0 :\r\n(go->format == GO7007_FORMAT_MPEG4 ? 0x8920 :\r\n(go->format == GO7007_FORMAT_H263 ? 0x8920 : 0))))),\r\ngo->ipb ? 0x1f15 : 0x1f0b,\r\ngo->ipb ? 0x0015 : 0x000b,\r\ngo->ipb ? 0xa800 : 0x5800,\r\n0xffff,\r\n0x0020 + 0x034b * 0,\r\n0x0020 + 0x034b * 1,\r\n0x0020 + 0x034b * 2,\r\n0x0020 + 0x034b * 3,\r\n0x0020 + 0x034b * 4,\r\n0x0020 + 0x034b * 5,\r\ngo->ipb ? (go->gop_size / 3) : go->gop_size,\r\n(go->height >> 4) * (go->width >> 4) * 110 / 100,\r\n};\r\nreturn copy_packages(code, pack, 1, space);\r\n}\r\nstatic int audio_to_package(struct go7007 *go, __le16 *code, int space)\r\n{\r\nint clock_config = ((go->board_info->audio_flags &\r\nGO7007_AUDIO_I2S_MASTER ? 1 : 0) << 11) |\r\n((go->board_info->audio_flags &\r\nGO7007_AUDIO_OKI_MODE ? 1 : 0) << 8) |\r\n(((go->board_info->audio_bclk_div / 4) - 1) << 4) |\r\n(go->board_info->audio_main_div - 1);\r\nu16 pack[] = {\r\n0x200d, 0,\r\n0x9002, 0,\r\n0x9002, 0,\r\n0x9031, 0,\r\n0x9032, 0,\r\n0x9033, 0,\r\n0x9034, 0,\r\n0x9035, 0,\r\n0x9036, 0,\r\n0x9037, 0,\r\n0x9040, 0,\r\n0x9000, clock_config,\r\n0x9001, (go->board_info->audio_flags & 0xffff) |\r\n(1 << 9),\r\n0x9000, ((go->board_info->audio_flags &\r\nGO7007_AUDIO_I2S_MASTER ?\r\n1 : 0) << 10) |\r\nclock_config,\r\n0, 0,\r\n0, 0,\r\n0x2005, 0,\r\n0x9041, 0,\r\n0x9042, 256,\r\n0x9043, 0,\r\n0x9044, 16,\r\n0x9045, 16,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n0, 0,\r\n};\r\nreturn copy_packages(code, pack, 2, space);\r\n}\r\nstatic int modet_to_package(struct go7007 *go, __le16 *code, int space)\r\n{\r\nint ret, mb, i, addr, cnt = 0;\r\nu16 pack[32];\r\nu16 thresholds[] = {\r\n0x200e, 0,\r\n0xbf82, go->modet[0].pixel_threshold,\r\n0xbf83, go->modet[1].pixel_threshold,\r\n0xbf84, go->modet[2].pixel_threshold,\r\n0xbf85, go->modet[3].pixel_threshold,\r\n0xbf86, go->modet[0].motion_threshold,\r\n0xbf87, go->modet[1].motion_threshold,\r\n0xbf88, go->modet[2].motion_threshold,\r\n0xbf89, go->modet[3].motion_threshold,\r\n0xbf8a, go->modet[0].mb_threshold,\r\n0xbf8b, go->modet[1].mb_threshold,\r\n0xbf8c, go->modet[2].mb_threshold,\r\n0xbf8d, go->modet[3].mb_threshold,\r\n0xbf8e, 0,\r\n0xbf8f, 0,\r\n0, 0,\r\n};\r\nret = copy_packages(code, thresholds, 1, space);\r\nif (ret < 0)\r\nreturn -1;\r\ncnt += ret;\r\naddr = 0xbac0;\r\nmemset(pack, 0, 64);\r\ni = 0;\r\nfor (mb = 0; mb < 1624; ++mb) {\r\npack[i * 2 + 3] <<= 2;\r\npack[i * 2 + 3] |= go->modet_map[mb];\r\nif (mb % 8 != 7)\r\ncontinue;\r\npack[i * 2 + 2] = addr++;\r\n++i;\r\nif (i == 10 || mb == 1623) {\r\npack[0] = 0x2000 | i;\r\nret = copy_packages(code + cnt, pack, 1, space - cnt);\r\nif (ret < 0)\r\nreturn -1;\r\ncnt += ret;\r\ni = 0;\r\nmemset(pack, 0, 64);\r\n}\r\npack[i * 2 + 3] = 0;\r\n}\r\nmemset(pack, 0, 64);\r\ni = 0;\r\nfor (addr = 0xbb90; addr < 0xbbfa; ++addr) {\r\npack[i * 2 + 2] = addr;\r\npack[i * 2 + 3] = 0;\r\n++i;\r\nif (i == 10 || addr == 0xbbf9) {\r\npack[0] = 0x2000 | i;\r\nret = copy_packages(code + cnt, pack, 1, space - cnt);\r\nif (ret < 0)\r\nreturn -1;\r\ncnt += ret;\r\ni = 0;\r\nmemset(pack, 0, 64);\r\n}\r\n}\r\nreturn cnt;\r\n}\r\nstatic int do_special(struct go7007 *go, u16 type, __le16 *code, int space,\r\nint *framelen)\r\n{\r\nswitch (type) {\r\ncase SPECIAL_FRM_HEAD:\r\nswitch (go->format) {\r\ncase GO7007_FORMAT_MJPEG:\r\nreturn gen_mjpeghdr_to_package(go, code, space);\r\ncase GO7007_FORMAT_MPEG1:\r\ncase GO7007_FORMAT_MPEG2:\r\nreturn gen_mpeg1hdr_to_package(go, code, space,\r\nframelen);\r\ncase GO7007_FORMAT_MPEG4:\r\nreturn gen_mpeg4hdr_to_package(go, code, space,\r\nframelen);\r\n}\r\ncase SPECIAL_BRC_CTRL:\r\nreturn brctrl_to_package(go, code, space, framelen);\r\ncase SPECIAL_CONFIG:\r\nreturn config_package(go, code, space);\r\ncase SPECIAL_SEQHEAD:\r\nswitch (go->format) {\r\ncase GO7007_FORMAT_MPEG1:\r\ncase GO7007_FORMAT_MPEG2:\r\nreturn seqhead_to_package(go, code, space,\r\nmpeg1_sequence_header);\r\ncase GO7007_FORMAT_MPEG4:\r\nreturn seqhead_to_package(go, code, space,\r\nmpeg4_sequence_header);\r\ndefault:\r\nreturn 0;\r\n}\r\ncase SPECIAL_AV_SYNC:\r\nreturn avsync_to_package(go, code, space);\r\ncase SPECIAL_FINAL:\r\nreturn final_package(go, code, space);\r\ncase SPECIAL_AUDIO:\r\nreturn audio_to_package(go, code, space);\r\ncase SPECIAL_MODET:\r\nreturn modet_to_package(go, code, space);\r\n}\r\nprintk(KERN_ERR\r\n"go7007: firmware file contains unsupported feature %04x\n",\r\ntype);\r\nreturn -1;\r\n}\r\nint go7007_construct_fw_image(struct go7007 *go, u8 **fw, int *fwlen)\r\n{\r\nconst struct firmware *fw_entry;\r\n__le16 *code, *src;\r\nint framelen[8] = { };\r\nint codespace = 64 * 1024, i = 0, srclen, chunk_len, chunk_flags;\r\nint mode_flag;\r\nint ret;\r\nswitch (go->format) {\r\ncase GO7007_FORMAT_MJPEG:\r\nmode_flag = FLAG_MODE_MJPEG;\r\nbreak;\r\ncase GO7007_FORMAT_MPEG1:\r\nmode_flag = FLAG_MODE_MPEG1;\r\nbreak;\r\ncase GO7007_FORMAT_MPEG2:\r\nmode_flag = FLAG_MODE_MPEG2;\r\nbreak;\r\ncase GO7007_FORMAT_MPEG4:\r\nmode_flag = FLAG_MODE_MPEG4;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nif (request_firmware(&fw_entry, go->board_info->firmware, go->dev)) {\r\nprintk(KERN_ERR\r\n"go7007: unable to load firmware from file \"%s\"\n",\r\ngo->board_info->firmware);\r\nreturn -1;\r\n}\r\ncode = kzalloc(codespace * 2, GFP_KERNEL);\r\nif (code == NULL) {\r\nprintk(KERN_ERR "go7007: unable to allocate %d bytes for "\r\n"firmware construction\n", codespace * 2);\r\ngoto fw_failed;\r\n}\r\nsrc = (__le16 *)fw_entry->data;\r\nsrclen = fw_entry->size / 2;\r\nwhile (srclen >= 2) {\r\nchunk_flags = __le16_to_cpu(src[0]);\r\nchunk_len = __le16_to_cpu(src[1]);\r\nif (chunk_len + 2 > srclen) {\r\nprintk(KERN_ERR "go7007: firmware file \"%s\" "\r\n"appears to be corrupted\n",\r\ngo->board_info->firmware);\r\ngoto fw_failed;\r\n}\r\nif (chunk_flags & mode_flag) {\r\nif (chunk_flags & FLAG_SPECIAL) {\r\nret = do_special(go, __le16_to_cpu(src[2]),\r\n&code[i], codespace - i, framelen);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "go7007: insufficient "\r\n"memory for firmware "\r\n"construction\n");\r\ngoto fw_failed;\r\n}\r\ni += ret;\r\n} else {\r\nif (codespace - i < chunk_len) {\r\nprintk(KERN_ERR "go7007: insufficient "\r\n"memory for firmware "\r\n"construction\n");\r\ngoto fw_failed;\r\n}\r\nmemcpy(&code[i], &src[2], chunk_len * 2);\r\ni += chunk_len;\r\n}\r\n}\r\nsrclen -= chunk_len + 2;\r\nsrc += chunk_len + 2;\r\n}\r\nrelease_firmware(fw_entry);\r\n*fw = (u8 *)code;\r\n*fwlen = i * 2;\r\nreturn 0;\r\nfw_failed:\r\nkfree(code);\r\nrelease_firmware(fw_entry);\r\nreturn -1;\r\n}
