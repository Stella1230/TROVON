static inline long lock_hpte(unsigned long *hpte, unsigned long bits)\r\n{\r\nunsigned long tmp, old;\r\nasm volatile(" ldarx %0,0,%2\n"\r\n" and. %1,%0,%3\n"\r\n" bne 2f\n"\r\n" ori %0,%0,%4\n"\r\n" stdcx. %0,0,%2\n"\r\n" beq+ 2f\n"\r\n" li %1,%3\n"\r\n"2: isync"\r\n: "=&r" (tmp), "=&r" (old)\r\n: "r" (hpte), "r" (bits), "i" (HPTE_V_HVLOCK)\r\n: "cc", "memory");\r\nreturn old == 0;\r\n}\r\nlong kvmppc_h_enter(struct kvm_vcpu *vcpu, unsigned long flags,\r\nlong pte_index, unsigned long pteh, unsigned long ptel)\r\n{\r\nunsigned long porder;\r\nstruct kvm *kvm = vcpu->kvm;\r\nunsigned long i, lpn, pa;\r\nunsigned long *hpte;\r\nporder = 12;\r\nif (pteh & HPTE_V_LARGE) {\r\nif (cpu_has_feature(CPU_FTR_ARCH_206) &&\r\n(ptel & 0xf000) == 0x1000) {\r\nporder = 16;\r\n} else if ((ptel & 0xff000) == 0) {\r\nporder = 24;\r\nif (pteh & 0x80)\r\nreturn H_PARAMETER;\r\n} else\r\nreturn H_PARAMETER;\r\n}\r\nlpn = (ptel & HPTE_R_RPN) >> kvm->arch.ram_porder;\r\nif (lpn >= kvm->arch.ram_npages || porder > kvm->arch.ram_porder)\r\nreturn H_PARAMETER;\r\npa = kvm->arch.ram_pginfo[lpn].pfn << PAGE_SHIFT;\r\nif (!pa)\r\nreturn H_PARAMETER;\r\nif ((ptel & HPTE_R_WIMG) != HPTE_R_M &&\r\n(ptel & HPTE_R_WIMG) != (HPTE_R_W | HPTE_R_I | HPTE_R_M))\r\nreturn H_PARAMETER;\r\npteh &= ~0x60UL;\r\nptel &= ~(HPTE_R_PP0 - kvm->arch.ram_psize);\r\nptel |= pa;\r\nif (pte_index >= (HPT_NPTEG << 3))\r\nreturn H_PARAMETER;\r\nif (likely((flags & H_EXACT) == 0)) {\r\npte_index &= ~7UL;\r\nhpte = (unsigned long *)(kvm->arch.hpt_virt + (pte_index << 4));\r\nfor (i = 0; ; ++i) {\r\nif (i == 8)\r\nreturn H_PTEG_FULL;\r\nif ((*hpte & HPTE_V_VALID) == 0 &&\r\nlock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID))\r\nbreak;\r\nhpte += 2;\r\n}\r\n} else {\r\ni = 0;\r\nhpte = (unsigned long *)(kvm->arch.hpt_virt + (pte_index << 4));\r\nif (!lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID))\r\nreturn H_PTEG_FULL;\r\n}\r\nhpte[1] = ptel;\r\neieio();\r\nhpte[0] = pteh;\r\nasm volatile("ptesync" : : : "memory");\r\natomic_inc(&kvm->arch.ram_pginfo[lpn].refcnt);\r\nvcpu->arch.gpr[4] = pte_index + i;\r\nreturn H_SUCCESS;\r\n}\r\nstatic inline int try_lock_tlbie(unsigned int *lock)\r\n{\r\nunsigned int tmp, old;\r\nunsigned int token = LOCK_TOKEN;\r\nasm volatile("1:lwarx %1,0,%2\n"\r\n" cmpwi cr0,%1,0\n"\r\n" bne 2f\n"\r\n" stwcx. %3,0,%2\n"\r\n" bne- 1b\n"\r\n" isync\n"\r\n"2:"\r\n: "=&r" (tmp), "=&r" (old)\r\n: "r" (lock), "r" (token)\r\n: "cc", "memory");\r\nreturn old == 0;\r\n}\r\nlong kvmppc_h_remove(struct kvm_vcpu *vcpu, unsigned long flags,\r\nunsigned long pte_index, unsigned long avpn,\r\nunsigned long va)\r\n{\r\nstruct kvm *kvm = vcpu->kvm;\r\nunsigned long *hpte;\r\nunsigned long v, r, rb;\r\nif (pte_index >= (HPT_NPTEG << 3))\r\nreturn H_PARAMETER;\r\nhpte = (unsigned long *)(kvm->arch.hpt_virt + (pte_index << 4));\r\nwhile (!lock_hpte(hpte, HPTE_V_HVLOCK))\r\ncpu_relax();\r\nif ((hpte[0] & HPTE_V_VALID) == 0 ||\r\n((flags & H_AVPN) && (hpte[0] & ~0x7fUL) != avpn) ||\r\n((flags & H_ANDCOND) && (hpte[0] & avpn) != 0)) {\r\nhpte[0] &= ~HPTE_V_HVLOCK;\r\nreturn H_NOT_FOUND;\r\n}\r\nif (atomic_read(&kvm->online_vcpus) == 1)\r\nflags |= H_LOCAL;\r\nvcpu->arch.gpr[4] = v = hpte[0] & ~HPTE_V_HVLOCK;\r\nvcpu->arch.gpr[5] = r = hpte[1];\r\nrb = compute_tlbie_rb(v, r, pte_index);\r\nhpte[0] = 0;\r\nif (!(flags & H_LOCAL)) {\r\nwhile(!try_lock_tlbie(&kvm->arch.tlbie_lock))\r\ncpu_relax();\r\nasm volatile("ptesync" : : : "memory");\r\nasm volatile(PPC_TLBIE(%1,%0)"; eieio; tlbsync"\r\n: : "r" (rb), "r" (kvm->arch.lpid));\r\nasm volatile("ptesync" : : : "memory");\r\nkvm->arch.tlbie_lock = 0;\r\n} else {\r\nasm volatile("ptesync" : : : "memory");\r\nasm volatile("tlbiel %0" : : "r" (rb));\r\nasm volatile("ptesync" : : : "memory");\r\n}\r\nreturn H_SUCCESS;\r\n}\r\nlong kvmppc_h_bulk_remove(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm *kvm = vcpu->kvm;\r\nunsigned long *args = &vcpu->arch.gpr[4];\r\nunsigned long *hp, tlbrb[4];\r\nlong int i, found;\r\nlong int n_inval = 0;\r\nunsigned long flags, req, pte_index;\r\nlong int local = 0;\r\nlong int ret = H_SUCCESS;\r\nif (atomic_read(&kvm->online_vcpus) == 1)\r\nlocal = 1;\r\nfor (i = 0; i < 4; ++i) {\r\npte_index = args[i * 2];\r\nflags = pte_index >> 56;\r\npte_index &= ((1ul << 56) - 1);\r\nreq = flags >> 6;\r\nflags &= 3;\r\nif (req == 3)\r\nbreak;\r\nif (req != 1 || flags == 3 ||\r\npte_index >= (HPT_NPTEG << 3)) {\r\nargs[i * 2] = ((0xa0 | flags) << 56) + pte_index;\r\nret = H_PARAMETER;\r\nbreak;\r\n}\r\nhp = (unsigned long *)(kvm->arch.hpt_virt + (pte_index << 4));\r\nwhile (!lock_hpte(hp, HPTE_V_HVLOCK))\r\ncpu_relax();\r\nfound = 0;\r\nif (hp[0] & HPTE_V_VALID) {\r\nswitch (flags & 3) {\r\ncase 0:\r\nfound = 1;\r\nbreak;\r\ncase 1:\r\nif (!(hp[0] & args[i * 2 + 1]))\r\nfound = 1;\r\nbreak;\r\ncase 2:\r\nif ((hp[0] & ~0x7fUL) == args[i * 2 + 1])\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nhp[0] &= ~HPTE_V_HVLOCK;\r\nargs[i * 2] = ((0x90 | flags) << 56) + pte_index;\r\ncontinue;\r\n}\r\nflags |= (hp[1] >> 5) & 0x0c;\r\nargs[i * 2] = ((0x80 | flags) << 56) + pte_index;\r\ntlbrb[n_inval++] = compute_tlbie_rb(hp[0], hp[1], pte_index);\r\nhp[0] = 0;\r\n}\r\nif (n_inval == 0)\r\nreturn ret;\r\nif (!local) {\r\nwhile(!try_lock_tlbie(&kvm->arch.tlbie_lock))\r\ncpu_relax();\r\nasm volatile("ptesync" : : : "memory");\r\nfor (i = 0; i < n_inval; ++i)\r\nasm volatile(PPC_TLBIE(%1,%0)\r\n: : "r" (tlbrb[i]), "r" (kvm->arch.lpid));\r\nasm volatile("eieio; tlbsync; ptesync" : : : "memory");\r\nkvm->arch.tlbie_lock = 0;\r\n} else {\r\nasm volatile("ptesync" : : : "memory");\r\nfor (i = 0; i < n_inval; ++i)\r\nasm volatile("tlbiel %0" : : "r" (tlbrb[i]));\r\nasm volatile("ptesync" : : : "memory");\r\n}\r\nreturn ret;\r\n}\r\nlong kvmppc_h_protect(struct kvm_vcpu *vcpu, unsigned long flags,\r\nunsigned long pte_index, unsigned long avpn,\r\nunsigned long va)\r\n{\r\nstruct kvm *kvm = vcpu->kvm;\r\nunsigned long *hpte;\r\nunsigned long v, r, rb;\r\nif (pte_index >= (HPT_NPTEG << 3))\r\nreturn H_PARAMETER;\r\nhpte = (unsigned long *)(kvm->arch.hpt_virt + (pte_index << 4));\r\nwhile (!lock_hpte(hpte, HPTE_V_HVLOCK))\r\ncpu_relax();\r\nif ((hpte[0] & HPTE_V_VALID) == 0 ||\r\n((flags & H_AVPN) && (hpte[0] & ~0x7fUL) != avpn)) {\r\nhpte[0] &= ~HPTE_V_HVLOCK;\r\nreturn H_NOT_FOUND;\r\n}\r\nif (atomic_read(&kvm->online_vcpus) == 1)\r\nflags |= H_LOCAL;\r\nv = hpte[0];\r\nr = hpte[1] & ~(HPTE_R_PP0 | HPTE_R_PP | HPTE_R_N |\r\nHPTE_R_KEY_HI | HPTE_R_KEY_LO);\r\nr |= (flags << 55) & HPTE_R_PP0;\r\nr |= (flags << 48) & HPTE_R_KEY_HI;\r\nr |= flags & (HPTE_R_PP | HPTE_R_N | HPTE_R_KEY_LO);\r\nrb = compute_tlbie_rb(v, r, pte_index);\r\nhpte[0] = v & ~HPTE_V_VALID;\r\nif (!(flags & H_LOCAL)) {\r\nwhile(!try_lock_tlbie(&kvm->arch.tlbie_lock))\r\ncpu_relax();\r\nasm volatile("ptesync" : : : "memory");\r\nasm volatile(PPC_TLBIE(%1,%0)"; eieio; tlbsync"\r\n: : "r" (rb), "r" (kvm->arch.lpid));\r\nasm volatile("ptesync" : : : "memory");\r\nkvm->arch.tlbie_lock = 0;\r\n} else {\r\nasm volatile("ptesync" : : : "memory");\r\nasm volatile("tlbiel %0" : : "r" (rb));\r\nasm volatile("ptesync" : : : "memory");\r\n}\r\nhpte[1] = r;\r\neieio();\r\nhpte[0] = v & ~HPTE_V_HVLOCK;\r\nasm volatile("ptesync" : : : "memory");\r\nreturn H_SUCCESS;\r\n}\r\nstatic unsigned long reverse_xlate(struct kvm *kvm, unsigned long realaddr)\r\n{\r\nlong int i;\r\nunsigned long offset, rpn;\r\noffset = realaddr & (kvm->arch.ram_psize - 1);\r\nrpn = (realaddr - offset) >> PAGE_SHIFT;\r\nfor (i = 0; i < kvm->arch.ram_npages; ++i)\r\nif (rpn == kvm->arch.ram_pginfo[i].pfn)\r\nreturn (i << PAGE_SHIFT) + offset;\r\nreturn HPTE_R_RPN;\r\n}\r\nlong kvmppc_h_read(struct kvm_vcpu *vcpu, unsigned long flags,\r\nunsigned long pte_index)\r\n{\r\nstruct kvm *kvm = vcpu->kvm;\r\nunsigned long *hpte, r;\r\nint i, n = 1;\r\nif (pte_index >= (HPT_NPTEG << 3))\r\nreturn H_PARAMETER;\r\nif (flags & H_READ_4) {\r\npte_index &= ~3;\r\nn = 4;\r\n}\r\nfor (i = 0; i < n; ++i, ++pte_index) {\r\nhpte = (unsigned long *)(kvm->arch.hpt_virt + (pte_index << 4));\r\nr = hpte[1];\r\nif ((flags & H_R_XLATE) && (hpte[0] & HPTE_V_VALID))\r\nr = reverse_xlate(kvm, r & HPTE_R_RPN) |\r\n(r & ~HPTE_R_RPN);\r\nvcpu->arch.gpr[4 + i * 2] = hpte[0];\r\nvcpu->arch.gpr[5 + i * 2] = r;\r\n}\r\nreturn H_SUCCESS;\r\n}
