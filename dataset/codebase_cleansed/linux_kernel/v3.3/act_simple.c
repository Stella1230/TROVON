static int tcf_simp(struct sk_buff *skb, const struct tc_action *a,\r\nstruct tcf_result *res)\r\n{\r\nstruct tcf_defact *d = a->priv;\r\nspin_lock(&d->tcf_lock);\r\nd->tcf_tm.lastuse = jiffies;\r\nbstats_update(&d->tcf_bstats, skb);\r\npr_info("simple: %s_%d\n",\r\n(char *)d->tcfd_defdata, d->tcf_bstats.packets);\r\nspin_unlock(&d->tcf_lock);\r\nreturn d->tcf_action;\r\n}\r\nstatic int tcf_simp_release(struct tcf_defact *d, int bind)\r\n{\r\nint ret = 0;\r\nif (d) {\r\nif (bind)\r\nd->tcf_bindcnt--;\r\nd->tcf_refcnt--;\r\nif (d->tcf_bindcnt <= 0 && d->tcf_refcnt <= 0) {\r\nkfree(d->tcfd_defdata);\r\ntcf_hash_destroy(&d->common, &simp_hash_info);\r\nret = 1;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int alloc_defdata(struct tcf_defact *d, char *defdata)\r\n{\r\nd->tcfd_defdata = kzalloc(SIMP_MAX_DATA, GFP_KERNEL);\r\nif (unlikely(!d->tcfd_defdata))\r\nreturn -ENOMEM;\r\nstrlcpy(d->tcfd_defdata, defdata, SIMP_MAX_DATA);\r\nreturn 0;\r\n}\r\nstatic void reset_policy(struct tcf_defact *d, char *defdata,\r\nstruct tc_defact *p)\r\n{\r\nspin_lock_bh(&d->tcf_lock);\r\nd->tcf_action = p->action;\r\nmemset(d->tcfd_defdata, 0, SIMP_MAX_DATA);\r\nstrlcpy(d->tcfd_defdata, defdata, SIMP_MAX_DATA);\r\nspin_unlock_bh(&d->tcf_lock);\r\n}\r\nstatic int tcf_simp_init(struct nlattr *nla, struct nlattr *est,\r\nstruct tc_action *a, int ovr, int bind)\r\n{\r\nstruct nlattr *tb[TCA_DEF_MAX + 1];\r\nstruct tc_defact *parm;\r\nstruct tcf_defact *d;\r\nstruct tcf_common *pc;\r\nchar *defdata;\r\nint ret = 0, err;\r\nif (nla == NULL)\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(tb, TCA_DEF_MAX, nla, simple_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[TCA_DEF_PARMS] == NULL)\r\nreturn -EINVAL;\r\nif (tb[TCA_DEF_DATA] == NULL)\r\nreturn -EINVAL;\r\nparm = nla_data(tb[TCA_DEF_PARMS]);\r\ndefdata = nla_data(tb[TCA_DEF_DATA]);\r\npc = tcf_hash_check(parm->index, a, bind, &simp_hash_info);\r\nif (!pc) {\r\npc = tcf_hash_create(parm->index, est, a, sizeof(*d), bind,\r\n&simp_idx_gen, &simp_hash_info);\r\nif (IS_ERR(pc))\r\nreturn PTR_ERR(pc);\r\nd = to_defact(pc);\r\nret = alloc_defdata(d, defdata);\r\nif (ret < 0) {\r\nkfree(pc);\r\nreturn ret;\r\n}\r\nd->tcf_action = parm->action;\r\nret = ACT_P_CREATED;\r\n} else {\r\nd = to_defact(pc);\r\nif (!ovr) {\r\ntcf_simp_release(d, bind);\r\nreturn -EEXIST;\r\n}\r\nreset_policy(d, defdata, parm);\r\n}\r\nif (ret == ACT_P_CREATED)\r\ntcf_hash_insert(pc, &simp_hash_info);\r\nreturn ret;\r\n}\r\nstatic int tcf_simp_cleanup(struct tc_action *a, int bind)\r\n{\r\nstruct tcf_defact *d = a->priv;\r\nif (d)\r\nreturn tcf_simp_release(d, bind);\r\nreturn 0;\r\n}\r\nstatic int tcf_simp_dump(struct sk_buff *skb, struct tc_action *a,\r\nint bind, int ref)\r\n{\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tcf_defact *d = a->priv;\r\nstruct tc_defact opt = {\r\n.index = d->tcf_index,\r\n.refcnt = d->tcf_refcnt - ref,\r\n.bindcnt = d->tcf_bindcnt - bind,\r\n.action = d->tcf_action,\r\n};\r\nstruct tcf_t t;\r\nNLA_PUT(skb, TCA_DEF_PARMS, sizeof(opt), &opt);\r\nNLA_PUT_STRING(skb, TCA_DEF_DATA, d->tcfd_defdata);\r\nt.install = jiffies_to_clock_t(jiffies - d->tcf_tm.install);\r\nt.lastuse = jiffies_to_clock_t(jiffies - d->tcf_tm.lastuse);\r\nt.expires = jiffies_to_clock_t(d->tcf_tm.expires);\r\nNLA_PUT(skb, TCA_DEF_TM, sizeof(t), &t);\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int __init simp_init_module(void)\r\n{\r\nint ret = tcf_register_action(&act_simp_ops);\r\nif (!ret)\r\npr_info("Simple TC action Loaded\n");\r\nreturn ret;\r\n}\r\nstatic void __exit simp_cleanup_module(void)\r\n{\r\ntcf_unregister_action(&act_simp_ops);\r\n}
