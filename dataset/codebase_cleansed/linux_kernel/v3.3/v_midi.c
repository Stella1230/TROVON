static int v_midi_open (int dev, int mode,\r\nvoid (*input) (int dev, unsigned char data),\r\nvoid (*output) (int dev)\r\n)\r\n{\r\nvmidi_devc *devc = midi_devs[dev]->devc;\r\nunsigned long flags;\r\nif (devc == NULL)\r\nreturn -(ENXIO);\r\nspin_lock_irqsave(&devc->lock,flags);\r\nif (devc->opened)\r\n{\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\nreturn -(EBUSY);\r\n}\r\ndevc->opened = 1;\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\ndevc->intr_active = 1;\r\nif (mode & OPEN_READ)\r\n{\r\ndevc->input_opened = 1;\r\ndevc->midi_input_intr = input;\r\n}\r\nreturn 0;\r\n}\r\nstatic void v_midi_close (int dev)\r\n{\r\nvmidi_devc *devc = midi_devs[dev]->devc;\r\nunsigned long flags;\r\nif (devc == NULL)\r\nreturn;\r\nspin_lock_irqsave(&devc->lock,flags);\r\ndevc->intr_active = 0;\r\ndevc->input_opened = 0;\r\ndevc->opened = 0;\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\n}\r\nstatic int v_midi_out (int dev, unsigned char midi_byte)\r\n{\r\nvmidi_devc *devc = midi_devs[dev]->devc;\r\nvmidi_devc *pdevc;\r\nif (devc == NULL)\r\nreturn -ENXIO;\r\npdevc = midi_devs[devc->pair_mididev]->devc;\r\nif (pdevc->input_opened > 0){\r\nif (MIDIbuf_avail(pdevc->my_mididev) > 500)\r\nreturn 0;\r\npdevc->midi_input_intr (pdevc->my_mididev, midi_byte);\r\n}\r\nreturn 1;\r\n}\r\nstatic inline int v_midi_start_read (int dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int v_midi_end_read (int dev)\r\n{\r\nvmidi_devc *devc = midi_devs[dev]->devc;\r\nif (devc == NULL)\r\nreturn -ENXIO;\r\ndevc->intr_active = 0;\r\nreturn 0;\r\n}\r\nstatic inline int v_midi_ioctl (int dev, unsigned cmd, void __user *arg)\r\n{\r\nreturn -EPERM;\r\n}\r\nstatic void __init attach_v_midi (struct address_info *hw_config)\r\n{\r\nstruct vmidi_memory *m;\r\nmidi1 = sound_alloc_mididev();\r\nif (midi1 == -1)\r\n{\r\nprintk(KERN_ERR "v_midi: Too many midi devices detected\n");\r\nreturn;\r\n}\r\nm = kmalloc(sizeof(struct vmidi_memory), GFP_KERNEL);\r\nif (m == NULL)\r\n{\r\nprintk(KERN_WARNING "Loopback MIDI: Failed to allocate memory\n");\r\nsound_unload_mididev(midi1);\r\nreturn;\r\n}\r\nmidi_mem = m;\r\nmidi_devs[midi1] = &m->m_ops[0];\r\nmidi2 = sound_alloc_mididev();\r\nif (midi2 == -1)\r\n{\r\nprintk (KERN_ERR "v_midi: Too many midi devices detected\n");\r\nkfree(m);\r\nsound_unload_mididev(midi1);\r\nreturn;\r\n}\r\nmidi_devs[midi2] = &m->m_ops[1];\r\nv_devc[0] = &m->v_ops[0];\r\nmemcpy ((char *) midi_devs[midi1], (char *) &v_midi_operations,\r\nsizeof (struct midi_operations));\r\nv_devc[0]->my_mididev = midi1;\r\nv_devc[0]->pair_mididev = midi2;\r\nv_devc[0]->opened = v_devc[0]->input_opened = 0;\r\nv_devc[0]->intr_active = 0;\r\nv_devc[0]->midi_input_intr = NULL;\r\nspin_lock_init(&v_devc[0]->lock);\r\nmidi_devs[midi1]->devc = v_devc[0];\r\nmidi_devs[midi1]->converter = &m->s_ops[0];\r\nstd_midi_synth.midi_dev = midi1;\r\nmemcpy ((char *) midi_devs[midi1]->converter, (char *) &std_midi_synth,\r\nsizeof (struct synth_operations));\r\nmidi_devs[midi1]->converter->id = "V_MIDI 1";\r\nv_devc[1] = &m->v_ops[1];\r\nmemcpy ((char *) midi_devs[midi2], (char *) &v_midi_operations2,\r\nsizeof (struct midi_operations));\r\nv_devc[1]->my_mididev = midi2;\r\nv_devc[1]->pair_mididev = midi1;\r\nv_devc[1]->opened = v_devc[1]->input_opened = 0;\r\nv_devc[1]->intr_active = 0;\r\nv_devc[1]->midi_input_intr = NULL;\r\nspin_lock_init(&v_devc[1]->lock);\r\nmidi_devs[midi2]->devc = v_devc[1];\r\nmidi_devs[midi2]->converter = &m->s_ops[1];\r\nstd_midi_synth.midi_dev = midi2;\r\nmemcpy ((char *) midi_devs[midi2]->converter, (char *) &std_midi_synth,\r\nsizeof (struct synth_operations));\r\nmidi_devs[midi2]->converter->id = "V_MIDI 2";\r\nsequencer_init();\r\n}\r\nstatic inline int __init probe_v_midi(struct address_info *hw_config)\r\n{\r\nreturn(1);\r\n}\r\nstatic void __exit unload_v_midi(struct address_info *hw_config)\r\n{\r\nsound_unload_mididev(midi1);\r\nsound_unload_mididev(midi2);\r\nkfree(midi_mem);\r\n}\r\nstatic int __init init_vmidi(void)\r\n{\r\nprintk("MIDI Loopback device driver\n");\r\nif (!probe_v_midi(&cfg))\r\nreturn -ENODEV;\r\nattach_v_midi(&cfg);\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_vmidi(void)\r\n{\r\nunload_v_midi(&cfg);\r\n}
