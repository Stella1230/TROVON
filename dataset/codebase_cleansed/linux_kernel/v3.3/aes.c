static inline\r\nu32 generic_rotr32 (const u32 x, const unsigned bits)\r\n{\r\nconst unsigned n = bits % 32;\r\nreturn (x >> n) | (x << (32 - n));\r\n}\r\nstatic inline\r\nu32 generic_rotl32 (const u32 x, const unsigned bits)\r\n{\r\nconst unsigned n = bits % 32;\r\nreturn (x << n) | (x >> (32 - n));\r\n}\r\ninline static u8\r\nbyte(const u32 x, const unsigned n)\r\n{\r\nreturn x >> (n << 3);\r\n}\r\nstatic inline u8 __init\r\nf_mult (u8 a, u8 b)\r\n{\r\nu8 aa = log_tab[a], cc = aa + log_tab[b];\r\nreturn pow_tab[cc + (cc < aa ? 1 : 0)];\r\n}\r\nstatic void __init\r\ngen_tabs (void)\r\n{\r\nu32 i, t;\r\nu8 p, q;\r\nfor (i = 0, p = 1; i < 256; ++i) {\r\npow_tab[i] = (u8) p;\r\nlog_tab[p] = (u8) i;\r\np ^= (p << 1) ^ (p & 0x80 ? 0x01b : 0);\r\n}\r\nlog_tab[1] = 0;\r\nfor (i = 0, p = 1; i < 10; ++i) {\r\nrco_tab[i] = p;\r\np = (p << 1) ^ (p & 0x80 ? 0x01b : 0);\r\n}\r\nfor (i = 0; i < 256; ++i) {\r\np = (i ? pow_tab[255 - log_tab[i]] : 0);\r\nq = ((p >> 7) | (p << 1)) ^ ((p >> 6) | (p << 2));\r\np ^= 0x63 ^ q ^ ((q >> 6) | (q << 2));\r\nsbx_tab[i] = p;\r\nisb_tab[p] = (u8) i;\r\n}\r\nfor (i = 0; i < 256; ++i) {\r\np = sbx_tab[i];\r\nt = p;\r\nfl_tab[0][i] = t;\r\nfl_tab[1][i] = rotl (t, 8);\r\nfl_tab[2][i] = rotl (t, 16);\r\nfl_tab[3][i] = rotl (t, 24);\r\nt = ((u32) ff_mult (2, p)) |\r\n((u32) p << 8) |\r\n((u32) p << 16) | ((u32) ff_mult (3, p) << 24);\r\nft_tab[0][i] = t;\r\nft_tab[1][i] = rotl (t, 8);\r\nft_tab[2][i] = rotl (t, 16);\r\nft_tab[3][i] = rotl (t, 24);\r\np = isb_tab[i];\r\nt = p;\r\nil_tab[0][i] = t;\r\nil_tab[1][i] = rotl (t, 8);\r\nil_tab[2][i] = rotl (t, 16);\r\nil_tab[3][i] = rotl (t, 24);\r\nt = ((u32) ff_mult (14, p)) |\r\n((u32) ff_mult (9, p) << 8) |\r\n((u32) ff_mult (13, p) << 16) |\r\n((u32) ff_mult (11, p) << 24);\r\nit_tab[0][i] = t;\r\nit_tab[1][i] = rotl (t, 8);\r\nit_tab[2][i] = rotl (t, 16);\r\nit_tab[3][i] = rotl (t, 24);\r\n}\r\n}\r\nstatic int\r\naes_set_key(void *ctx_arg, const u8 *in_key, unsigned int key_len, u32 *flags)\r\n{\r\nstruct aes_ctx *ctx = ctx_arg;\r\nu32 i, t, u, v, w;\r\nif (key_len != 16 && key_len != 24 && key_len != 32) {\r\n*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;\r\nreturn -EINVAL;\r\n}\r\nctx->key_length = key_len;\r\nE_KEY[0] = u32_in (in_key);\r\nE_KEY[1] = u32_in (in_key + 4);\r\nE_KEY[2] = u32_in (in_key + 8);\r\nE_KEY[3] = u32_in (in_key + 12);\r\nswitch (key_len) {\r\ncase 16:\r\nt = E_KEY[3];\r\nfor (i = 0; i < 10; ++i)\r\nloop4 (i);\r\nbreak;\r\ncase 24:\r\nE_KEY[4] = u32_in (in_key + 16);\r\nt = E_KEY[5] = u32_in (in_key + 20);\r\nfor (i = 0; i < 8; ++i)\r\nloop6 (i);\r\nbreak;\r\ncase 32:\r\nE_KEY[4] = u32_in (in_key + 16);\r\nE_KEY[5] = u32_in (in_key + 20);\r\nE_KEY[6] = u32_in (in_key + 24);\r\nt = E_KEY[7] = u32_in (in_key + 28);\r\nfor (i = 0; i < 7; ++i)\r\nloop8 (i);\r\nbreak;\r\n}\r\nD_KEY[0] = E_KEY[0];\r\nD_KEY[1] = E_KEY[1];\r\nD_KEY[2] = E_KEY[2];\r\nD_KEY[3] = E_KEY[3];\r\nfor (i = 4; i < key_len + 24; ++i) {\r\nimix_col (D_KEY[i], E_KEY[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void aes_encrypt(void *ctx_arg, u8 *out, const u8 *in)\r\n{\r\nconst struct aes_ctx *ctx = ctx_arg;\r\nu32 b0[4], b1[4];\r\nconst u32 *kp = E_KEY + 4;\r\nb0[0] = u32_in (in) ^ E_KEY[0];\r\nb0[1] = u32_in (in + 4) ^ E_KEY[1];\r\nb0[2] = u32_in (in + 8) ^ E_KEY[2];\r\nb0[3] = u32_in (in + 12) ^ E_KEY[3];\r\nif (ctx->key_length > 24) {\r\nf_nround (b1, b0, kp);\r\nf_nround (b0, b1, kp);\r\n}\r\nif (ctx->key_length > 16) {\r\nf_nround (b1, b0, kp);\r\nf_nround (b0, b1, kp);\r\n}\r\nf_nround (b1, b0, kp);\r\nf_nround (b0, b1, kp);\r\nf_nround (b1, b0, kp);\r\nf_nround (b0, b1, kp);\r\nf_nround (b1, b0, kp);\r\nf_nround (b0, b1, kp);\r\nf_nround (b1, b0, kp);\r\nf_nround (b0, b1, kp);\r\nf_nround (b1, b0, kp);\r\nf_lround (b0, b1, kp);\r\nu32_out (out, b0[0]);\r\nu32_out (out + 4, b0[1]);\r\nu32_out (out + 8, b0[2]);\r\nu32_out (out + 12, b0[3]);\r\n}\r\nstatic void aes_decrypt(void *ctx_arg, u8 *out, const u8 *in)\r\n{\r\nconst struct aes_ctx *ctx = ctx_arg;\r\nu32 b0[4], b1[4];\r\nconst int key_len = ctx->key_length;\r\nconst u32 *kp = D_KEY + key_len + 20;\r\nb0[0] = u32_in (in) ^ E_KEY[key_len + 24];\r\nb0[1] = u32_in (in + 4) ^ E_KEY[key_len + 25];\r\nb0[2] = u32_in (in + 8) ^ E_KEY[key_len + 26];\r\nb0[3] = u32_in (in + 12) ^ E_KEY[key_len + 27];\r\nif (key_len > 24) {\r\ni_nround (b1, b0, kp);\r\ni_nround (b0, b1, kp);\r\n}\r\nif (key_len > 16) {\r\ni_nround (b1, b0, kp);\r\ni_nround (b0, b1, kp);\r\n}\r\ni_nround (b1, b0, kp);\r\ni_nround (b0, b1, kp);\r\ni_nround (b1, b0, kp);\r\ni_nround (b0, b1, kp);\r\ni_nround (b1, b0, kp);\r\ni_nround (b0, b1, kp);\r\ni_nround (b1, b0, kp);\r\ni_nround (b0, b1, kp);\r\ni_nround (b1, b0, kp);\r\ni_lround (b0, b1, kp);\r\nu32_out (out, b0[0]);\r\nu32_out (out + 4, b0[1]);\r\nu32_out (out + 8, b0[2]);\r\nu32_out (out + 12, b0[3]);\r\n}\r\nstatic int __init aes_init(void)\r\n{\r\ngen_tabs();\r\nreturn crypto_register_alg(&aes_alg);\r\n}\r\nstatic void __exit aes_fini(void)\r\n{\r\ncrypto_unregister_alg(&aes_alg);\r\n}
