int ipath_alloc_lkey(struct ipath_lkey_table *rkt, struct ipath_mregion *mr)\r\n{\r\nunsigned long flags;\r\nu32 r;\r\nu32 n;\r\nint ret;\r\nspin_lock_irqsave(&rkt->lock, flags);\r\nr = n = rkt->next;\r\nfor (;;) {\r\nif (rkt->table[r] == NULL)\r\nbreak;\r\nr = (r + 1) & (rkt->max - 1);\r\nif (r == n) {\r\nspin_unlock_irqrestore(&rkt->lock, flags);\r\nipath_dbg("LKEY table full\n");\r\nret = 0;\r\ngoto bail;\r\n}\r\n}\r\nrkt->next = (r + 1) & (rkt->max - 1);\r\nrkt->gen++;\r\nmr->lkey = (r << (32 - ib_ipath_lkey_table_size)) |\r\n((((1 << (24 - ib_ipath_lkey_table_size)) - 1) & rkt->gen)\r\n<< 8);\r\nif (mr->lkey == 0) {\r\nmr->lkey |= 1 << 8;\r\nrkt->gen++;\r\n}\r\nrkt->table[r] = mr;\r\nspin_unlock_irqrestore(&rkt->lock, flags);\r\nret = 1;\r\nbail:\r\nreturn ret;\r\n}\r\nvoid ipath_free_lkey(struct ipath_lkey_table *rkt, u32 lkey)\r\n{\r\nunsigned long flags;\r\nu32 r;\r\nif (lkey == 0)\r\nreturn;\r\nr = lkey >> (32 - ib_ipath_lkey_table_size);\r\nspin_lock_irqsave(&rkt->lock, flags);\r\nrkt->table[r] = NULL;\r\nspin_unlock_irqrestore(&rkt->lock, flags);\r\n}\r\nint ipath_lkey_ok(struct ipath_qp *qp, struct ipath_sge *isge,\r\nstruct ib_sge *sge, int acc)\r\n{\r\nstruct ipath_lkey_table *rkt = &to_idev(qp->ibqp.device)->lk_table;\r\nstruct ipath_mregion *mr;\r\nunsigned n, m;\r\nsize_t off;\r\nint ret;\r\nif (sge->lkey == 0) {\r\nstruct ipath_pd *pd = to_ipd(qp->ibqp.pd);\r\nif (pd->user) {\r\nret = 0;\r\ngoto bail;\r\n}\r\nisge->mr = NULL;\r\nisge->vaddr = (void *) sge->addr;\r\nisge->length = sge->length;\r\nisge->sge_length = sge->length;\r\nret = 1;\r\ngoto bail;\r\n}\r\nmr = rkt->table[(sge->lkey >> (32 - ib_ipath_lkey_table_size))];\r\nif (unlikely(mr == NULL || mr->lkey != sge->lkey ||\r\nqp->ibqp.pd != mr->pd)) {\r\nret = 0;\r\ngoto bail;\r\n}\r\noff = sge->addr - mr->user_base;\r\nif (unlikely(sge->addr < mr->user_base ||\r\noff + sge->length > mr->length ||\r\n(mr->access_flags & acc) != acc)) {\r\nret = 0;\r\ngoto bail;\r\n}\r\noff += mr->offset;\r\nm = 0;\r\nn = 0;\r\nwhile (off >= mr->map[m]->segs[n].length) {\r\noff -= mr->map[m]->segs[n].length;\r\nn++;\r\nif (n >= IPATH_SEGSZ) {\r\nm++;\r\nn = 0;\r\n}\r\n}\r\nisge->mr = mr;\r\nisge->vaddr = mr->map[m]->segs[n].vaddr + off;\r\nisge->length = mr->map[m]->segs[n].length - off;\r\nisge->sge_length = sge->length;\r\nisge->m = m;\r\nisge->n = n;\r\nret = 1;\r\nbail:\r\nreturn ret;\r\n}\r\nint ipath_rkey_ok(struct ipath_qp *qp, struct ipath_sge_state *ss,\r\nu32 len, u64 vaddr, u32 rkey, int acc)\r\n{\r\nstruct ipath_ibdev *dev = to_idev(qp->ibqp.device);\r\nstruct ipath_lkey_table *rkt = &dev->lk_table;\r\nstruct ipath_sge *sge = &ss->sge;\r\nstruct ipath_mregion *mr;\r\nunsigned n, m;\r\nsize_t off;\r\nint ret;\r\nif (rkey == 0) {\r\nstruct ipath_pd *pd = to_ipd(qp->ibqp.pd);\r\nif (pd->user) {\r\nret = 0;\r\ngoto bail;\r\n}\r\nsge->mr = NULL;\r\nsge->vaddr = (void *) vaddr;\r\nsge->length = len;\r\nsge->sge_length = len;\r\nss->sg_list = NULL;\r\nss->num_sge = 1;\r\nret = 1;\r\ngoto bail;\r\n}\r\nmr = rkt->table[(rkey >> (32 - ib_ipath_lkey_table_size))];\r\nif (unlikely(mr == NULL || mr->lkey != rkey ||\r\nqp->ibqp.pd != mr->pd)) {\r\nret = 0;\r\ngoto bail;\r\n}\r\noff = vaddr - mr->iova;\r\nif (unlikely(vaddr < mr->iova || off + len > mr->length ||\r\n(mr->access_flags & acc) == 0)) {\r\nret = 0;\r\ngoto bail;\r\n}\r\noff += mr->offset;\r\nm = 0;\r\nn = 0;\r\nwhile (off >= mr->map[m]->segs[n].length) {\r\noff -= mr->map[m]->segs[n].length;\r\nn++;\r\nif (n >= IPATH_SEGSZ) {\r\nm++;\r\nn = 0;\r\n}\r\n}\r\nsge->mr = mr;\r\nsge->vaddr = mr->map[m]->segs[n].vaddr + off;\r\nsge->length = mr->map[m]->segs[n].length - off;\r\nsge->sge_length = len;\r\nsge->m = m;\r\nsge->n = n;\r\nss->sg_list = NULL;\r\nss->num_sge = 1;\r\nret = 1;\r\nbail:\r\nreturn ret;\r\n}
