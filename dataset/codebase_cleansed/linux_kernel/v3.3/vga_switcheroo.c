int vga_switcheroo_register_handler(struct vga_switcheroo_handler *handler)\r\n{\r\nmutex_lock(&vgasr_mutex);\r\nif (vgasr_priv.handler) {\r\nmutex_unlock(&vgasr_mutex);\r\nreturn -EINVAL;\r\n}\r\nvgasr_priv.handler = handler;\r\nmutex_unlock(&vgasr_mutex);\r\nreturn 0;\r\n}\r\nvoid vga_switcheroo_unregister_handler(void)\r\n{\r\nmutex_lock(&vgasr_mutex);\r\nvgasr_priv.handler = NULL;\r\nmutex_unlock(&vgasr_mutex);\r\n}\r\nstatic void vga_switcheroo_enable(void)\r\n{\r\nint i;\r\nint ret;\r\nvgasr_priv.handler->init();\r\nfor (i = 0; i < VGA_SWITCHEROO_MAX_CLIENTS; i++) {\r\nret = vgasr_priv.handler->get_client_id(vgasr_priv.clients[i].pdev);\r\nif (ret < 0)\r\nreturn;\r\nvgasr_priv.clients[i].id = ret;\r\n}\r\nvga_switcheroo_debugfs_init(&vgasr_priv);\r\nvgasr_priv.active = true;\r\n}\r\nint vga_switcheroo_register_client(struct pci_dev *pdev,\r\nvoid (*set_gpu_state)(struct pci_dev *pdev, enum vga_switcheroo_state),\r\nvoid (*reprobe)(struct pci_dev *pdev),\r\nbool (*can_switch)(struct pci_dev *pdev))\r\n{\r\nint index;\r\nmutex_lock(&vgasr_mutex);\r\nif (vgasr_priv.registered_clients & 1)\r\nindex = 1;\r\nelse\r\nindex = 0;\r\nvgasr_priv.clients[index].pwr_state = VGA_SWITCHEROO_ON;\r\nvgasr_priv.clients[index].pdev = pdev;\r\nvgasr_priv.clients[index].set_gpu_state = set_gpu_state;\r\nvgasr_priv.clients[index].reprobe = reprobe;\r\nvgasr_priv.clients[index].can_switch = can_switch;\r\nvgasr_priv.clients[index].id = -1;\r\nif (pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW)\r\nvgasr_priv.clients[index].active = true;\r\nvgasr_priv.registered_clients |= (1 << index);\r\nif (vgasr_priv.registered_clients == 0x3 && vgasr_priv.handler) {\r\nprintk(KERN_INFO "vga_switcheroo: enabled\n");\r\nvga_switcheroo_enable();\r\n}\r\nmutex_unlock(&vgasr_mutex);\r\nreturn 0;\r\n}\r\nvoid vga_switcheroo_unregister_client(struct pci_dev *pdev)\r\n{\r\nint i;\r\nmutex_lock(&vgasr_mutex);\r\nfor (i = 0; i < VGA_SWITCHEROO_MAX_CLIENTS; i++) {\r\nif (vgasr_priv.clients[i].pdev == pdev) {\r\nvgasr_priv.registered_clients &= ~(1 << i);\r\nbreak;\r\n}\r\n}\r\nprintk(KERN_INFO "vga_switcheroo: disabled\n");\r\nvga_switcheroo_debugfs_fini(&vgasr_priv);\r\nvgasr_priv.active = false;\r\nmutex_unlock(&vgasr_mutex);\r\n}\r\nvoid vga_switcheroo_client_fb_set(struct pci_dev *pdev,\r\nstruct fb_info *info)\r\n{\r\nint i;\r\nmutex_lock(&vgasr_mutex);\r\nfor (i = 0; i < VGA_SWITCHEROO_MAX_CLIENTS; i++) {\r\nif (vgasr_priv.clients[i].pdev == pdev) {\r\nvgasr_priv.clients[i].fb_info = info;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&vgasr_mutex);\r\n}\r\nstatic int vga_switcheroo_show(struct seq_file *m, void *v)\r\n{\r\nint i;\r\nmutex_lock(&vgasr_mutex);\r\nfor (i = 0; i < VGA_SWITCHEROO_MAX_CLIENTS; i++) {\r\nseq_printf(m, "%d:%s:%c:%s:%s\n", i,\r\nvgasr_priv.clients[i].id == VGA_SWITCHEROO_DIS ? "DIS" : "IGD",\r\nvgasr_priv.clients[i].active ? '+' : ' ',\r\nvgasr_priv.clients[i].pwr_state ? "Pwr" : "Off",\r\npci_name(vgasr_priv.clients[i].pdev));\r\n}\r\nmutex_unlock(&vgasr_mutex);\r\nreturn 0;\r\n}\r\nstatic int vga_switcheroo_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, vga_switcheroo_show, NULL);\r\n}\r\nstatic int vga_switchon(struct vga_switcheroo_client *client)\r\n{\r\nif (vgasr_priv.handler->power_state)\r\nvgasr_priv.handler->power_state(client->id, VGA_SWITCHEROO_ON);\r\nclient->set_gpu_state(client->pdev, VGA_SWITCHEROO_ON);\r\nclient->pwr_state = VGA_SWITCHEROO_ON;\r\nreturn 0;\r\n}\r\nstatic int vga_switchoff(struct vga_switcheroo_client *client)\r\n{\r\nclient->set_gpu_state(client->pdev, VGA_SWITCHEROO_OFF);\r\nif (vgasr_priv.handler->power_state)\r\nvgasr_priv.handler->power_state(client->id, VGA_SWITCHEROO_OFF);\r\nclient->pwr_state = VGA_SWITCHEROO_OFF;\r\nreturn 0;\r\n}\r\nstatic int vga_switchto_stage1(struct vga_switcheroo_client *new_client)\r\n{\r\nint i;\r\nstruct vga_switcheroo_client *active = NULL;\r\nfor (i = 0; i < VGA_SWITCHEROO_MAX_CLIENTS; i++) {\r\nif (vgasr_priv.clients[i].active == true) {\r\nactive = &vgasr_priv.clients[i];\r\nbreak;\r\n}\r\n}\r\nif (!active)\r\nreturn 0;\r\nif (new_client->pwr_state == VGA_SWITCHEROO_OFF)\r\nvga_switchon(new_client);\r\nactive->pdev->resource[PCI_ROM_RESOURCE].flags &= ~IORESOURCE_ROM_SHADOW;\r\nnew_client->pdev->resource[PCI_ROM_RESOURCE].flags |= IORESOURCE_ROM_SHADOW;\r\nreturn 0;\r\n}\r\nstatic int vga_switchto_stage2(struct vga_switcheroo_client *new_client)\r\n{\r\nint ret;\r\nint i;\r\nstruct vga_switcheroo_client *active = NULL;\r\nfor (i = 0; i < VGA_SWITCHEROO_MAX_CLIENTS; i++) {\r\nif (vgasr_priv.clients[i].active == true) {\r\nactive = &vgasr_priv.clients[i];\r\nbreak;\r\n}\r\n}\r\nif (!active)\r\nreturn 0;\r\nactive->active = false;\r\nif (new_client->fb_info) {\r\nstruct fb_event event;\r\nevent.info = new_client->fb_info;\r\nfb_notifier_call_chain(FB_EVENT_REMAP_ALL_CONSOLE, &event);\r\n}\r\nret = vgasr_priv.handler->switchto(new_client->id);\r\nif (ret)\r\nreturn ret;\r\nif (new_client->reprobe)\r\nnew_client->reprobe(new_client->pdev);\r\nif (active->pwr_state == VGA_SWITCHEROO_ON)\r\nvga_switchoff(active);\r\nnew_client->active = true;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nvga_switcheroo_debugfs_write(struct file *filp, const char __user *ubuf,\r\nsize_t cnt, loff_t *ppos)\r\n{\r\nchar usercmd[64];\r\nconst char *pdev_name;\r\nint i, ret;\r\nbool delay = false, can_switch;\r\nbool just_mux = false;\r\nint client_id = -1;\r\nstruct vga_switcheroo_client *client = NULL;\r\nif (cnt > 63)\r\ncnt = 63;\r\nif (copy_from_user(usercmd, ubuf, cnt))\r\nreturn -EFAULT;\r\nmutex_lock(&vgasr_mutex);\r\nif (!vgasr_priv.active) {\r\ncnt = -EINVAL;\r\ngoto out;\r\n}\r\nif (strncmp(usercmd, "OFF", 3) == 0) {\r\nfor (i = 0; i < VGA_SWITCHEROO_MAX_CLIENTS; i++) {\r\nif (vgasr_priv.clients[i].active)\r\ncontinue;\r\nif (vgasr_priv.clients[i].pwr_state == VGA_SWITCHEROO_ON)\r\nvga_switchoff(&vgasr_priv.clients[i]);\r\n}\r\ngoto out;\r\n}\r\nif (strncmp(usercmd, "ON", 2) == 0) {\r\nfor (i = 0; i < VGA_SWITCHEROO_MAX_CLIENTS; i++) {\r\nif (vgasr_priv.clients[i].active)\r\ncontinue;\r\nif (vgasr_priv.clients[i].pwr_state == VGA_SWITCHEROO_OFF)\r\nvga_switchon(&vgasr_priv.clients[i]);\r\n}\r\ngoto out;\r\n}\r\nif (strncmp(usercmd, "DIGD", 4) == 0) {\r\nclient_id = VGA_SWITCHEROO_IGD;\r\ndelay = true;\r\n}\r\nif (strncmp(usercmd, "DDIS", 4) == 0) {\r\nclient_id = VGA_SWITCHEROO_DIS;\r\ndelay = true;\r\n}\r\nif (strncmp(usercmd, "IGD", 3) == 0)\r\nclient_id = VGA_SWITCHEROO_IGD;\r\nif (strncmp(usercmd, "DIS", 3) == 0)\r\nclient_id = VGA_SWITCHEROO_DIS;\r\nif (strncmp(usercmd, "MIGD", 4) == 0) {\r\njust_mux = true;\r\nclient_id = VGA_SWITCHEROO_IGD;\r\n}\r\nif (strncmp(usercmd, "MDIS", 4) == 0) {\r\njust_mux = true;\r\nclient_id = VGA_SWITCHEROO_DIS;\r\n}\r\nif (client_id == -1)\r\ngoto out;\r\nfor (i = 0; i < VGA_SWITCHEROO_MAX_CLIENTS; i++) {\r\nif (vgasr_priv.clients[i].id == client_id) {\r\nclient = &vgasr_priv.clients[i];\r\nbreak;\r\n}\r\n}\r\nvgasr_priv.delayed_switch_active = false;\r\nif (just_mux) {\r\nret = vgasr_priv.handler->switchto(client_id);\r\ngoto out;\r\n}\r\nif (client->active == true)\r\ngoto out;\r\ncan_switch = true;\r\nfor (i = 0; i < VGA_SWITCHEROO_MAX_CLIENTS; i++) {\r\ncan_switch = vgasr_priv.clients[i].can_switch(vgasr_priv.clients[i].pdev);\r\nif (can_switch == false) {\r\nprintk(KERN_ERR "vga_switcheroo: client %d refused switch\n", i);\r\nbreak;\r\n}\r\n}\r\nif (can_switch == false && delay == false)\r\ngoto out;\r\nif (can_switch == true) {\r\npdev_name = pci_name(client->pdev);\r\nret = vga_switchto_stage1(client);\r\nif (ret)\r\nprintk(KERN_ERR "vga_switcheroo: switching failed stage 1 %d\n", ret);\r\nret = vga_switchto_stage2(client);\r\nif (ret)\r\nprintk(KERN_ERR "vga_switcheroo: switching failed stage 2 %d\n", ret);\r\n} else {\r\nprintk(KERN_INFO "vga_switcheroo: setting delayed switch to client %d\n", client->id);\r\nvgasr_priv.delayed_switch_active = true;\r\nvgasr_priv.delayed_client_id = client_id;\r\nret = vga_switchto_stage1(client);\r\nif (ret)\r\nprintk(KERN_ERR "vga_switcheroo: delayed switching stage 1 failed %d\n", ret);\r\n}\r\nout:\r\nmutex_unlock(&vgasr_mutex);\r\nreturn cnt;\r\n}\r\nstatic void vga_switcheroo_debugfs_fini(struct vgasr_priv *priv)\r\n{\r\nif (priv->switch_file) {\r\ndebugfs_remove(priv->switch_file);\r\npriv->switch_file = NULL;\r\n}\r\nif (priv->debugfs_root) {\r\ndebugfs_remove(priv->debugfs_root);\r\npriv->debugfs_root = NULL;\r\n}\r\n}\r\nstatic int vga_switcheroo_debugfs_init(struct vgasr_priv *priv)\r\n{\r\nif (priv->debugfs_root)\r\nreturn 0;\r\npriv->debugfs_root = debugfs_create_dir("vgaswitcheroo", NULL);\r\nif (!priv->debugfs_root) {\r\nprintk(KERN_ERR "vga_switcheroo: Cannot create /sys/kernel/debug/vgaswitcheroo\n");\r\ngoto fail;\r\n}\r\npriv->switch_file = debugfs_create_file("switch", 0644,\r\npriv->debugfs_root, NULL, &vga_switcheroo_debugfs_fops);\r\nif (!priv->switch_file) {\r\nprintk(KERN_ERR "vga_switcheroo: cannot create /sys/kernel/debug/vgaswitcheroo/switch\n");\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nvga_switcheroo_debugfs_fini(priv);\r\nreturn -1;\r\n}\r\nint vga_switcheroo_process_delayed_switch(void)\r\n{\r\nstruct vga_switcheroo_client *client = NULL;\r\nconst char *pdev_name;\r\nbool can_switch = true;\r\nint i;\r\nint ret;\r\nint err = -EINVAL;\r\nmutex_lock(&vgasr_mutex);\r\nif (!vgasr_priv.delayed_switch_active)\r\ngoto err;\r\nprintk(KERN_INFO "vga_switcheroo: processing delayed switch to %d\n", vgasr_priv.delayed_client_id);\r\nfor (i = 0; i < VGA_SWITCHEROO_MAX_CLIENTS; i++) {\r\nif (vgasr_priv.clients[i].id == vgasr_priv.delayed_client_id)\r\nclient = &vgasr_priv.clients[i];\r\ncan_switch = vgasr_priv.clients[i].can_switch(vgasr_priv.clients[i].pdev);\r\nif (can_switch == false) {\r\nprintk(KERN_ERR "vga_switcheroo: client %d refused switch\n", i);\r\nbreak;\r\n}\r\n}\r\nif (can_switch == false || client == NULL)\r\ngoto err;\r\npdev_name = pci_name(client->pdev);\r\nret = vga_switchto_stage2(client);\r\nif (ret)\r\nprintk(KERN_ERR "vga_switcheroo: delayed switching failed stage 2 %d\n", ret);\r\nvgasr_priv.delayed_switch_active = false;\r\nerr = 0;\r\nerr:\r\nmutex_unlock(&vgasr_mutex);\r\nreturn err;\r\n}
