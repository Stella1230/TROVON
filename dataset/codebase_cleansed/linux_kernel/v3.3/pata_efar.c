static int efar_pre_reset(struct ata_link *link, unsigned long deadline)\r\n{\r\nstatic const struct pci_bits efar_enable_bits[] = {\r\n{ 0x41U, 1U, 0x80UL, 0x80UL },\r\n{ 0x43U, 1U, 0x80UL, 0x80UL },\r\n};\r\nstruct ata_port *ap = link->ap;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nif (!pci_test_config_bits(pdev, &efar_enable_bits[ap->port_no]))\r\nreturn -ENOENT;\r\nreturn ata_sff_prereset(link, deadline);\r\n}\r\nstatic int efar_cable_detect(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu8 tmp;\r\npci_read_config_byte(pdev, 0x47, &tmp);\r\nif (tmp & (2 >> ap->port_no))\r\nreturn ATA_CBL_PATA40;\r\nreturn ATA_CBL_PATA80;\r\n}\r\nstatic void efar_set_piomode (struct ata_port *ap, struct ata_device *adev)\r\n{\r\nunsigned int pio = adev->pio_mode - XFER_PIO_0;\r\nstruct pci_dev *dev = to_pci_dev(ap->host->dev);\r\nunsigned int master_port = ap->port_no ? 0x42 : 0x40;\r\nunsigned long flags;\r\nu16 master_data;\r\nu8 udma_enable;\r\nint control = 0;\r\nstatic const\r\nu8 timings[][2] = { { 0, 0 },\r\n{ 0, 0 },\r\n{ 1, 0 },\r\n{ 2, 1 },\r\n{ 2, 3 }, };\r\nif (pio > 1)\r\ncontrol |= 1;\r\nif (ata_pio_need_iordy(adev))\r\ncontrol |= 2;\r\nif (adev->class == ATA_DEV_ATA)\r\ncontrol |= 4;\r\nspin_lock_irqsave(&efar_lock, flags);\r\npci_read_config_word(dev, master_port, &master_data);\r\nif (adev->devno == 0) {\r\nmaster_data &= 0xCCF0;\r\nmaster_data |= control;\r\nmaster_data |= (timings[pio][0] << 12) |\r\n(timings[pio][1] << 8);\r\n} else {\r\nint shift = 4 * ap->port_no;\r\nu8 slave_data;\r\nmaster_data &= 0xFF0F;\r\nmaster_data |= (control << 4);\r\npci_read_config_byte(dev, 0x44, &slave_data);\r\nslave_data &= ap->port_no ? 0x0F : 0xF0;\r\nslave_data |= ((timings[pio][0] << 2) | timings[pio][1]) << shift;\r\npci_write_config_byte(dev, 0x44, slave_data);\r\n}\r\nmaster_data |= 0x4000;\r\npci_write_config_word(dev, master_port, master_data);\r\npci_read_config_byte(dev, 0x48, &udma_enable);\r\nudma_enable &= ~(1 << (2 * ap->port_no + adev->devno));\r\npci_write_config_byte(dev, 0x48, udma_enable);\r\nspin_unlock_irqrestore(&efar_lock, flags);\r\n}\r\nstatic void efar_set_dmamode (struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(ap->host->dev);\r\nu8 master_port = ap->port_no ? 0x42 : 0x40;\r\nu16 master_data;\r\nu8 speed = adev->dma_mode;\r\nint devid = adev->devno + 2 * ap->port_no;\r\nunsigned long flags;\r\nu8 udma_enable;\r\nstatic const\r\nu8 timings[][2] = { { 0, 0 },\r\n{ 0, 0 },\r\n{ 1, 0 },\r\n{ 2, 1 },\r\n{ 2, 3 }, };\r\nspin_lock_irqsave(&efar_lock, flags);\r\npci_read_config_word(dev, master_port, &master_data);\r\npci_read_config_byte(dev, 0x48, &udma_enable);\r\nif (speed >= XFER_UDMA_0) {\r\nunsigned int udma = adev->dma_mode - XFER_UDMA_0;\r\nu16 udma_timing;\r\nudma_enable |= (1 << devid);\r\npci_read_config_word(dev, 0x4A, &udma_timing);\r\nudma_timing &= ~(7 << (4 * devid));\r\nudma_timing |= udma << (4 * devid);\r\npci_write_config_word(dev, 0x4A, udma_timing);\r\n} else {\r\nunsigned int mwdma = adev->dma_mode - XFER_MW_DMA_0;\r\nunsigned int control;\r\nu8 slave_data;\r\nconst unsigned int needed_pio[3] = {\r\nXFER_PIO_0, XFER_PIO_3, XFER_PIO_4\r\n};\r\nint pio = needed_pio[mwdma] - XFER_PIO_0;\r\ncontrol = 3;\r\nif (adev->pio_mode < needed_pio[mwdma])\r\ncontrol |= 8;\r\nif (adev->devno) {\r\nmaster_data &= 0xFF4F;\r\nmaster_data |= control << 4;\r\npci_read_config_byte(dev, 0x44, &slave_data);\r\nslave_data &= ap->port_no ? 0x0F : 0xF0;\r\nslave_data |= ((timings[pio][0] << 2) | timings[pio][1]) << (ap->port_no ? 4 : 0);\r\npci_write_config_byte(dev, 0x44, slave_data);\r\n} else {\r\nmaster_data &= 0xCCF4;\r\nmaster_data |= control;\r\nmaster_data |=\r\n(timings[pio][0] << 12) |\r\n(timings[pio][1] << 8);\r\n}\r\nudma_enable &= ~(1 << devid);\r\npci_write_config_word(dev, master_port, master_data);\r\n}\r\npci_write_config_byte(dev, 0x48, udma_enable);\r\nspin_unlock_irqrestore(&efar_lock, flags);\r\n}\r\nstatic int efar_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstatic const struct ata_port_info info = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA12_ONLY,\r\n.udma_mask = ATA_UDMA4,\r\n.port_ops = &efar_ops,\r\n};\r\nconst struct ata_port_info *ppi[] = { &info, &info };\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nreturn ata_pci_bmdma_init_one(pdev, ppi, &efar_sht, NULL,\r\nATA_HOST_PARALLEL_SCAN);\r\n}\r\nstatic int __init efar_init(void)\r\n{\r\nreturn pci_register_driver(&efar_pci_driver);\r\n}\r\nstatic void __exit efar_exit(void)\r\n{\r\npci_unregister_driver(&efar_pci_driver);\r\n}
