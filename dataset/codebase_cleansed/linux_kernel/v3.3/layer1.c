static void\r\nl1m_debug(struct FsmInst *fi, char *fmt, ...)\r\n{\r\nstruct layer1 *l1 = fi->userdata;\r\nstruct va_format vaf;\r\nva_list va;\r\nva_start(va, fmt);\r\nvaf.fmt = fmt;\r\nvaf.va = &va;\r\nprintk(KERN_DEBUG "%s: %pV\n", dev_name(&l1->dch->dev.dev), &vaf);\r\nva_end(va);\r\n}\r\nstatic void\r\nl1_reset(struct FsmInst *fi, int event, void *arg)\r\n{\r\nmISDN_FsmChangeState(fi, ST_L1_F3);\r\n}\r\nstatic void\r\nl1_deact_cnf(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer1 *l1 = fi->userdata;\r\nmISDN_FsmChangeState(fi, ST_L1_F3);\r\nif (test_bit(FLG_L1_ACTIVATING, &l1->Flags))\r\nl1->dcb(l1->dch, HW_POWERUP_REQ);\r\n}\r\nstatic void\r\nl1_deact_req_s(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer1 *l1 = fi->userdata;\r\nmISDN_FsmChangeState(fi, ST_L1_F3);\r\nmISDN_FsmRestartTimer(&l1->timer, 550, EV_TIMER_DEACT, NULL, 2);\r\ntest_and_set_bit(FLG_L1_DEACTTIMER, &l1->Flags);\r\n}\r\nstatic void\r\nl1_power_up_s(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer1 *l1 = fi->userdata;\r\nif (test_bit(FLG_L1_ACTIVATING, &l1->Flags)) {\r\nmISDN_FsmChangeState(fi, ST_L1_F4);\r\nl1->dcb(l1->dch, INFO3_P8);\r\n} else\r\nmISDN_FsmChangeState(fi, ST_L1_F3);\r\n}\r\nstatic void\r\nl1_go_F5(struct FsmInst *fi, int event, void *arg)\r\n{\r\nmISDN_FsmChangeState(fi, ST_L1_F5);\r\n}\r\nstatic void\r\nl1_go_F8(struct FsmInst *fi, int event, void *arg)\r\n{\r\nmISDN_FsmChangeState(fi, ST_L1_F8);\r\n}\r\nstatic void\r\nl1_info2_ind(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer1 *l1 = fi->userdata;\r\nmISDN_FsmChangeState(fi, ST_L1_F6);\r\nl1->dcb(l1->dch, INFO3_P8);\r\n}\r\nstatic void\r\nl1_info4_ind(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer1 *l1 = fi->userdata;\r\nmISDN_FsmChangeState(fi, ST_L1_F7);\r\nl1->dcb(l1->dch, INFO3_P8);\r\nif (test_and_clear_bit(FLG_L1_DEACTTIMER, &l1->Flags))\r\nmISDN_FsmDelTimer(&l1->timer, 4);\r\nif (!test_bit(FLG_L1_ACTIVATED, &l1->Flags)) {\r\nif (test_and_clear_bit(FLG_L1_T3RUN, &l1->Flags))\r\nmISDN_FsmDelTimer(&l1->timer, 3);\r\nmISDN_FsmRestartTimer(&l1->timer, 110, EV_TIMER_ACT, NULL, 2);\r\ntest_and_set_bit(FLG_L1_ACTTIMER, &l1->Flags);\r\n}\r\n}\r\nstatic void\r\nl1_timer3(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer1 *l1 = fi->userdata;\r\ntest_and_clear_bit(FLG_L1_T3RUN, &l1->Flags);\r\nif (test_and_clear_bit(FLG_L1_ACTIVATING, &l1->Flags)) {\r\nif (test_and_clear_bit(FLG_L1_DBLOCKED, &l1->Flags))\r\nl1->dcb(l1->dch, HW_D_NOBLOCKED);\r\nl1->dcb(l1->dch, PH_DEACTIVATE_IND);\r\n}\r\nif (l1->l1m.state != ST_L1_F6) {\r\nmISDN_FsmChangeState(fi, ST_L1_F3);\r\nl1->dcb(l1->dch, HW_POWERUP_REQ);\r\n}\r\n}\r\nstatic void\r\nl1_timer_act(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer1 *l1 = fi->userdata;\r\ntest_and_clear_bit(FLG_L1_ACTTIMER, &l1->Flags);\r\ntest_and_set_bit(FLG_L1_ACTIVATED, &l1->Flags);\r\nl1->dcb(l1->dch, PH_ACTIVATE_IND);\r\n}\r\nstatic void\r\nl1_timer_deact(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer1 *l1 = fi->userdata;\r\ntest_and_clear_bit(FLG_L1_DEACTTIMER, &l1->Flags);\r\ntest_and_clear_bit(FLG_L1_ACTIVATED, &l1->Flags);\r\nif (test_and_clear_bit(FLG_L1_DBLOCKED, &l1->Flags))\r\nl1->dcb(l1->dch, HW_D_NOBLOCKED);\r\nl1->dcb(l1->dch, PH_DEACTIVATE_IND);\r\nl1->dcb(l1->dch, HW_DEACT_REQ);\r\n}\r\nstatic void\r\nl1_activate_s(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer1 *l1 = fi->userdata;\r\nmISDN_FsmRestartTimer(&l1->timer, TIMER3_VALUE, EV_TIMER3, NULL, 2);\r\ntest_and_set_bit(FLG_L1_T3RUN, &l1->Flags);\r\nl1->dcb(l1->dch, HW_RESET_REQ);\r\n}\r\nstatic void\r\nl1_activate_no(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer1 *l1 = fi->userdata;\r\nif ((!test_bit(FLG_L1_DEACTTIMER, &l1->Flags)) &&\r\n(!test_bit(FLG_L1_T3RUN, &l1->Flags))) {\r\ntest_and_clear_bit(FLG_L1_ACTIVATING, &l1->Flags);\r\nif (test_and_clear_bit(FLG_L1_DBLOCKED, &l1->Flags))\r\nl1->dcb(l1->dch, HW_D_NOBLOCKED);\r\nl1->dcb(l1->dch, PH_DEACTIVATE_IND);\r\n}\r\n}\r\nstatic void\r\nrelease_l1(struct layer1 *l1) {\r\nmISDN_FsmDelTimer(&l1->timer, 0);\r\nif (l1->dch)\r\nl1->dch->l1 = NULL;\r\nmodule_put(THIS_MODULE);\r\nkfree(l1);\r\n}\r\nint\r\nl1_event(struct layer1 *l1, u_int event)\r\n{\r\nint err = 0;\r\nif (!l1)\r\nreturn -EINVAL;\r\nswitch (event) {\r\ncase HW_RESET_IND:\r\nmISDN_FsmEvent(&l1->l1m, EV_RESET_IND, NULL);\r\nbreak;\r\ncase HW_DEACT_IND:\r\nmISDN_FsmEvent(&l1->l1m, EV_DEACT_IND, NULL);\r\nbreak;\r\ncase HW_POWERUP_IND:\r\nmISDN_FsmEvent(&l1->l1m, EV_POWER_UP, NULL);\r\nbreak;\r\ncase HW_DEACT_CNF:\r\nmISDN_FsmEvent(&l1->l1m, EV_DEACT_CNF, NULL);\r\nbreak;\r\ncase ANYSIGNAL:\r\nmISDN_FsmEvent(&l1->l1m, EV_ANYSIG_IND, NULL);\r\nbreak;\r\ncase LOSTFRAMING:\r\nmISDN_FsmEvent(&l1->l1m, EV_ANYSIG_IND, NULL);\r\nbreak;\r\ncase INFO2:\r\nmISDN_FsmEvent(&l1->l1m, EV_INFO2_IND, NULL);\r\nbreak;\r\ncase INFO4_P8:\r\nmISDN_FsmEvent(&l1->l1m, EV_INFO4_IND, NULL);\r\nbreak;\r\ncase INFO4_P10:\r\nmISDN_FsmEvent(&l1->l1m, EV_INFO4_IND, NULL);\r\nbreak;\r\ncase PH_ACTIVATE_REQ:\r\nif (test_bit(FLG_L1_ACTIVATED, &l1->Flags))\r\nl1->dcb(l1->dch, PH_ACTIVATE_IND);\r\nelse {\r\ntest_and_set_bit(FLG_L1_ACTIVATING, &l1->Flags);\r\nmISDN_FsmEvent(&l1->l1m, EV_PH_ACTIVATE, NULL);\r\n}\r\nbreak;\r\ncase CLOSE_CHANNEL:\r\nrelease_l1(l1);\r\nbreak;\r\ndefault:\r\nif (*debug & DEBUG_L1)\r\nprintk(KERN_DEBUG "%s %x unhandled\n",\r\n__func__, event);\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nint\r\ncreate_l1(struct dchannel *dch, dchannel_l1callback *dcb) {\r\nstruct layer1 *nl1;\r\nnl1 = kzalloc(sizeof(struct layer1), GFP_ATOMIC);\r\nif (!nl1) {\r\nprintk(KERN_ERR "kmalloc struct layer1 failed\n");\r\nreturn -ENOMEM;\r\n}\r\nnl1->l1m.fsm = &l1fsm_s;\r\nnl1->l1m.state = ST_L1_F3;\r\nnl1->Flags = 0;\r\nnl1->l1m.debug = *debug & DEBUG_L1_FSM;\r\nnl1->l1m.userdata = nl1;\r\nnl1->l1m.userint = 0;\r\nnl1->l1m.printdebug = l1m_debug;\r\nnl1->dch = dch;\r\nnl1->dcb = dcb;\r\nmISDN_FsmInitTimer(&nl1->l1m, &nl1->timer);\r\n__module_get(THIS_MODULE);\r\ndch->l1 = nl1;\r\nreturn 0;\r\n}\r\nint\r\nl1_init(u_int *deb)\r\n{\r\ndebug = deb;\r\nl1fsm_s.state_count = L1S_STATE_COUNT;\r\nl1fsm_s.event_count = L1_EVENT_COUNT;\r\nl1fsm_s.strEvent = strL1Event;\r\nl1fsm_s.strState = strL1SState;\r\nmISDN_FsmNew(&l1fsm_s, L1SFnList, ARRAY_SIZE(L1SFnList));\r\nreturn 0;\r\n}\r\nvoid\r\nl1_cleanup(void)\r\n{\r\nmISDN_FsmFree(&l1fsm_s);\r\n}
