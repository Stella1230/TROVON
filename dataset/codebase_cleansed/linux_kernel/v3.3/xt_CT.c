static unsigned int xt_ct_target(struct sk_buff *skb,\r\nconst struct xt_action_param *par)\r\n{\r\nconst struct xt_ct_target_info *info = par->targinfo;\r\nstruct nf_conn *ct = info->ct;\r\nif (skb->nfct != NULL)\r\nreturn XT_CONTINUE;\r\natomic_inc(&ct->ct_general.use);\r\nskb->nfct = &ct->ct_general;\r\nskb->nfctinfo = IP_CT_NEW;\r\nreturn XT_CONTINUE;\r\n}\r\nstatic u8 xt_ct_find_proto(const struct xt_tgchk_param *par)\r\n{\r\nif (par->family == NFPROTO_IPV4) {\r\nconst struct ipt_entry *e = par->entryinfo;\r\nif (e->ip.invflags & IPT_INV_PROTO)\r\nreturn 0;\r\nreturn e->ip.proto;\r\n} else if (par->family == NFPROTO_IPV6) {\r\nconst struct ip6t_entry *e = par->entryinfo;\r\nif (e->ipv6.invflags & IP6T_INV_PROTO)\r\nreturn 0;\r\nreturn e->ipv6.proto;\r\n} else\r\nreturn 0;\r\n}\r\nstatic int xt_ct_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nstruct xt_ct_target_info *info = par->targinfo;\r\nstruct nf_conntrack_tuple t;\r\nstruct nf_conn_help *help;\r\nstruct nf_conn *ct;\r\nint ret = 0;\r\nu8 proto;\r\nif (info->flags & ~XT_CT_NOTRACK)\r\nreturn -EINVAL;\r\nif (info->flags & XT_CT_NOTRACK) {\r\nct = nf_ct_untracked_get();\r\natomic_inc(&ct->ct_general.use);\r\ngoto out;\r\n}\r\n#ifndef CONFIG_NF_CONNTRACK_ZONES\r\nif (info->zone)\r\ngoto err1;\r\n#endif\r\nret = nf_ct_l3proto_try_module_get(par->family);\r\nif (ret < 0)\r\ngoto err1;\r\nmemset(&t, 0, sizeof(t));\r\nct = nf_conntrack_alloc(par->net, info->zone, &t, &t, GFP_KERNEL);\r\nret = PTR_ERR(ct);\r\nif (IS_ERR(ct))\r\ngoto err2;\r\nret = 0;\r\nif ((info->ct_events || info->exp_events) &&\r\n!nf_ct_ecache_ext_add(ct, info->ct_events, info->exp_events,\r\nGFP_KERNEL))\r\ngoto err3;\r\nif (info->helper[0]) {\r\nret = -ENOENT;\r\nproto = xt_ct_find_proto(par);\r\nif (!proto) {\r\npr_info("You must specify a L4 protocol, "\r\n"and not use inversions on it.\n");\r\ngoto err3;\r\n}\r\nret = -ENOMEM;\r\nhelp = nf_ct_helper_ext_add(ct, GFP_KERNEL);\r\nif (help == NULL)\r\ngoto err3;\r\nret = -ENOENT;\r\nhelp->helper = nf_conntrack_helper_try_module_get(info->helper,\r\npar->family,\r\nproto);\r\nif (help->helper == NULL) {\r\npr_info("No such helper \"%s\"\n", info->helper);\r\ngoto err3;\r\n}\r\n}\r\n__set_bit(IPS_TEMPLATE_BIT, &ct->status);\r\n__set_bit(IPS_CONFIRMED_BIT, &ct->status);\r\nout:\r\ninfo->ct = ct;\r\nreturn 0;\r\nerr3:\r\nnf_conntrack_free(ct);\r\nerr2:\r\nnf_ct_l3proto_module_put(par->family);\r\nerr1:\r\nreturn ret;\r\n}\r\nstatic void xt_ct_tg_destroy(const struct xt_tgdtor_param *par)\r\n{\r\nstruct xt_ct_target_info *info = par->targinfo;\r\nstruct nf_conn *ct = info->ct;\r\nstruct nf_conn_help *help;\r\nif (!nf_ct_is_untracked(ct)) {\r\nhelp = nfct_help(ct);\r\nif (help)\r\nmodule_put(help->helper->me);\r\nnf_ct_l3proto_module_put(par->family);\r\n}\r\nnf_ct_put(info->ct);\r\n}\r\nstatic int __init xt_ct_tg_init(void)\r\n{\r\nreturn xt_register_target(&xt_ct_tg);\r\n}\r\nstatic void __exit xt_ct_tg_exit(void)\r\n{\r\nxt_unregister_target(&xt_ct_tg);\r\n}
