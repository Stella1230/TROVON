static int mxs_gpio_set_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nu32 gpio = irq_to_gpio(d->irq);\r\nu32 pin_mask = 1 << (gpio & 31);\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mxs_gpio_port *port = gc->private;\r\nvoid __iomem *pin_addr;\r\nint edge;\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nedge = GPIO_INT_RISE_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nedge = GPIO_INT_FALL_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nedge = GPIO_INT_LOW_LEV;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nedge = GPIO_INT_HIGH_LEV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npin_addr = port->base + PINCTRL_IRQLEV(port->id);\r\nif (edge & GPIO_INT_LEV_MASK)\r\nwritel(pin_mask, pin_addr + MXS_SET);\r\nelse\r\nwritel(pin_mask, pin_addr + MXS_CLR);\r\npin_addr = port->base + PINCTRL_IRQPOL(port->id);\r\nif (edge & GPIO_INT_POL_MASK)\r\nwritel(pin_mask, pin_addr + MXS_SET);\r\nelse\r\nwritel(pin_mask, pin_addr + MXS_CLR);\r\nwritel(1 << (gpio & 0x1f),\r\nport->base + PINCTRL_IRQSTAT(port->id) + MXS_CLR);\r\nreturn 0;\r\n}\r\nstatic void mxs_gpio_irq_handler(u32 irq, struct irq_desc *desc)\r\n{\r\nu32 irq_stat;\r\nstruct mxs_gpio_port *port = irq_get_handler_data(irq);\r\nu32 gpio_irq_no_base = port->virtual_irq_start;\r\ndesc->irq_data.chip->irq_ack(&desc->irq_data);\r\nirq_stat = readl(port->base + PINCTRL_IRQSTAT(port->id)) &\r\nreadl(port->base + PINCTRL_IRQEN(port->id));\r\nwhile (irq_stat != 0) {\r\nint irqoffset = fls(irq_stat) - 1;\r\ngeneric_handle_irq(gpio_irq_no_base + irqoffset);\r\nirq_stat &= ~(1 << irqoffset);\r\n}\r\n}\r\nstatic int mxs_gpio_set_wake_irq(struct irq_data *d, unsigned int enable)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mxs_gpio_port *port = gc->private;\r\nif (enable)\r\nenable_irq_wake(port->irq);\r\nelse\r\ndisable_irq_wake(port->irq);\r\nreturn 0;\r\n}\r\nstatic void __init mxs_gpio_init_gc(struct mxs_gpio_port *port)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\ngc = irq_alloc_generic_chip("gpio-mxs", 1, port->virtual_irq_start,\r\nport->base, handle_level_irq);\r\ngc->private = port;\r\nct = gc->chip_types;\r\nct->chip.irq_ack = irq_gc_ack_set_bit;\r\nct->chip.irq_mask = irq_gc_mask_clr_bit;\r\nct->chip.irq_unmask = irq_gc_mask_set_bit;\r\nct->chip.irq_set_type = mxs_gpio_set_irq_type;\r\nct->chip.irq_set_wake = mxs_gpio_set_wake_irq;\r\nct->regs.ack = PINCTRL_IRQSTAT(port->id) + MXS_CLR;\r\nct->regs.mask = PINCTRL_IRQEN(port->id);\r\nirq_setup_generic_chip(gc, IRQ_MSK(32), 0, IRQ_NOREQUEST, 0);\r\n}\r\nstatic int mxs_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(gc);\r\nstruct mxs_gpio_port *port =\r\ncontainer_of(bgc, struct mxs_gpio_port, bgc);\r\nreturn port->virtual_irq_start + offset;\r\n}\r\nstatic int __devinit mxs_gpio_probe(struct platform_device *pdev)\r\n{\r\nstatic void __iomem *base;\r\nstruct mxs_gpio_port *port;\r\nstruct resource *iores = NULL;\r\nint err;\r\nport = kzalloc(sizeof(struct mxs_gpio_port), GFP_KERNEL);\r\nif (!port)\r\nreturn -ENOMEM;\r\nport->id = pdev->id;\r\nport->virtual_irq_start = MXS_GPIO_IRQ_START + port->id * 32;\r\nif (!base) {\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!iores) {\r\nerr = -ENODEV;\r\ngoto out_kfree;\r\n}\r\nif (!request_mem_region(iores->start, resource_size(iores),\r\npdev->name)) {\r\nerr = -EBUSY;\r\ngoto out_kfree;\r\n}\r\nbase = ioremap(iores->start, resource_size(iores));\r\nif (!base) {\r\nerr = -ENOMEM;\r\ngoto out_release_mem;\r\n}\r\n}\r\nport->base = base;\r\nport->irq = platform_get_irq(pdev, 0);\r\nif (port->irq < 0) {\r\nerr = -EINVAL;\r\ngoto out_iounmap;\r\n}\r\nwritel(~0U, port->base + PINCTRL_PIN2IRQ(port->id));\r\nwritel(0, port->base + PINCTRL_IRQEN(port->id));\r\nwritel(~0U, port->base + PINCTRL_IRQSTAT(port->id) + MXS_CLR);\r\nmxs_gpio_init_gc(port);\r\nirq_set_chained_handler(port->irq, mxs_gpio_irq_handler);\r\nirq_set_handler_data(port->irq, port);\r\nerr = bgpio_init(&port->bgc, &pdev->dev, 4,\r\nport->base + PINCTRL_DIN(port->id),\r\nport->base + PINCTRL_DOUT(port->id), NULL,\r\nport->base + PINCTRL_DOE(port->id), NULL, false);\r\nif (err)\r\ngoto out_iounmap;\r\nport->bgc.gc.to_irq = mxs_gpio_to_irq;\r\nport->bgc.gc.base = port->id * 32;\r\nerr = gpiochip_add(&port->bgc.gc);\r\nif (err)\r\ngoto out_bgpio_remove;\r\nreturn 0;\r\nout_bgpio_remove:\r\nbgpio_remove(&port->bgc);\r\nout_iounmap:\r\nif (iores)\r\niounmap(port->base);\r\nout_release_mem:\r\nif (iores)\r\nrelease_mem_region(iores->start, resource_size(iores));\r\nout_kfree:\r\nkfree(port);\r\ndev_info(&pdev->dev, "%s failed with errno %d\n", __func__, err);\r\nreturn err;\r\n}\r\nstatic int __init mxs_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&mxs_gpio_driver);\r\n}
