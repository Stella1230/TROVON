struct dpram_blk *ft1000_get_buffer(struct list_head *bufflist)\r\n{\r\nunsigned long flags;\r\nstruct dpram_blk *ptr;\r\nspin_lock_irqsave(&free_buff_lock, flags);\r\nif ( list_empty(bufflist) ) {\r\nDEBUG("ft1000_get_buffer: No more buffer - %d\n", numofmsgbuf);\r\nptr = NULL;\r\n}\r\nelse {\r\nnumofmsgbuf--;\r\nptr = list_entry(bufflist->next, struct dpram_blk, list);\r\nlist_del(&ptr->list);\r\n}\r\nspin_unlock_irqrestore(&free_buff_lock, flags);\r\nreturn ptr;\r\n}\r\nvoid ft1000_free_buffer(struct dpram_blk *pdpram_blk, struct list_head *plist)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&free_buff_lock, flags);\r\nlist_add_tail(&pdpram_blk->list, plist);\r\nnumofmsgbuf++;\r\nspin_unlock_irqrestore(&free_buff_lock, flags);\r\n}\r\nint ft1000_create_dev(struct ft1000_device *dev)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev->net);\r\nint result;\r\nint i;\r\nstruct dentry *dir, *file;\r\nstruct ft1000_debug_dirs *tmp;\r\nsprintf(info->DeviceName, "%s%d", "FT1000_", info->CardNumber);\r\nDEBUG("%s: number of instance = %d\n", __func__, ft1000_flarion_cnt);\r\nDEBUG("DeviceCreated = %x\n", info->DeviceCreated);\r\nif (info->DeviceCreated)\r\n{\r\nDEBUG("%s: \"%s\" already registered\n", __func__, info->DeviceName);\r\nreturn -EIO;\r\n}\r\nDEBUG("%s: \"%s\" debugfs device registration\n", __func__, info->DeviceName);\r\ntmp = kmalloc(sizeof(struct ft1000_debug_dirs), GFP_KERNEL);\r\nif (tmp == NULL) {\r\nresult = -1;\r\ngoto fail;\r\n}\r\ndir = debugfs_create_dir(info->DeviceName, 0);\r\nif (IS_ERR(dir)) {\r\nresult = PTR_ERR(dir);\r\ngoto debug_dir_fail;\r\n}\r\nfile = debugfs_create_file("device", S_IRUGO | S_IWUSR, dir,\r\ndev, &ft1000fops);\r\nif (IS_ERR(file)) {\r\nresult = PTR_ERR(file);\r\ngoto debug_file_fail;\r\n}\r\ntmp->dent = dir;\r\ntmp->file = file;\r\ntmp->int_number = info->CardNumber;\r\nlist_add(&(tmp->list), &(info->nodes.list));\r\nDEBUG("%s: registered debugfs directory \"%s\"\n", __func__, info->DeviceName);\r\ninfo->appcnt = 0;\r\nfor (i=0; i<MAX_NUM_APP; i++) {\r\ninfo->app_info[i].nTxMsg = 0;\r\ninfo->app_info[i].nRxMsg = 0;\r\ninfo->app_info[i].nTxMsgReject = 0;\r\ninfo->app_info[i].nRxMsgMiss = 0;\r\ninfo->app_info[i].fileobject = NULL;\r\ninfo->app_info[i].app_id = i+1;\r\ninfo->app_info[i].DspBCMsgFlag = 0;\r\ninfo->app_info[i].NumOfMsg = 0;\r\ninit_waitqueue_head(&info->app_info[i].wait_dpram_msg);\r\nINIT_LIST_HEAD (&info->app_info[i].app_sqlist);\r\n}\r\ninfo->DeviceCreated = TRUE;\r\nft1000_flarion_cnt++;\r\nreturn 0;\r\ndebug_file_fail:\r\ndebugfs_remove(dir);\r\ndebug_dir_fail:\r\nkfree(tmp);\r\nfail:\r\nreturn result;\r\n}\r\nvoid ft1000_destroy_dev(struct net_device *dev)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nint i;\r\nstruct dpram_blk *pdpram_blk;\r\nstruct dpram_blk *ptr;\r\nstruct list_head *pos, *q;\r\nstruct ft1000_debug_dirs *dir;\r\nDEBUG("%s called\n", __func__);\r\nif (info->DeviceCreated)\r\n{\r\nft1000_flarion_cnt--;\r\nlist_for_each_safe(pos, q, &info->nodes.list) {\r\ndir = list_entry(pos, struct ft1000_debug_dirs, list);\r\nif (dir->int_number == info->CardNumber) {\r\ndebugfs_remove(dir->file);\r\ndebugfs_remove(dir->dent);\r\nlist_del(pos);\r\nkfree(dir);\r\n}\r\n}\r\nDEBUG("%s: unregistered device \"%s\"\n", __func__,\r\ninfo->DeviceName);\r\nfor (i=0; i<MAX_NUM_APP; i++) {\r\nwhile (list_empty(&info->app_info[i].app_sqlist) == 0) {\r\npdpram_blk = list_entry(info->app_info[i].app_sqlist.next, struct dpram_blk, list);\r\nlist_del(&pdpram_blk->list);\r\nft1000_free_buffer(pdpram_blk, &freercvpool);\r\n}\r\nwake_up_interruptible(&info->app_info[i].wait_dpram_msg);\r\n}\r\nif (ft1000_flarion_cnt == 0) {\r\nwhile (list_empty(&freercvpool) == 0) {\r\nptr = list_entry(freercvpool.next, struct dpram_blk, list);\r\nlist_del(&ptr->list);\r\nkfree(ptr->pbuffer);\r\nkfree(ptr);\r\n}\r\n}\r\ninfo->DeviceCreated = FALSE;\r\n}\r\n}\r\nstatic int ft1000_open (struct inode *inode, struct file *file)\r\n{\r\nstruct ft1000_info *info;\r\nstruct ft1000_device *dev = (struct ft1000_device *)inode->i_private;\r\nint i,num;\r\nDEBUG("%s called\n", __func__);\r\nnum = (MINOR(inode->i_rdev) & 0xf);\r\nDEBUG("ft1000_open: minor number=%d\n", num);\r\ninfo = file->private_data = netdev_priv(dev->net);\r\nDEBUG("f_owner = %p number of application = %d\n", (&file->f_owner), info->appcnt );\r\nif (info->appcnt > MAX_NUM_APP) {\r\nDEBUG("Maximum number of application exceeded\n");\r\nreturn -EACCES;\r\n}\r\nfor (i=0; i<MAX_NUM_APP; i++) {\r\nif ( (info->app_info[i].fileobject == NULL) ) {\r\nbreak;\r\n}\r\n}\r\nif (i == MAX_NUM_APP) {\r\nDEBUG("Could not find an application info block\n");\r\nreturn -EACCES;\r\n}\r\ninfo->appcnt++;\r\ninfo->app_info[i].fileobject = &file->f_owner;\r\ninfo->app_info[i].nTxMsg = 0;\r\ninfo->app_info[i].nRxMsg = 0;\r\ninfo->app_info[i].nTxMsgReject = 0;\r\ninfo->app_info[i].nRxMsgMiss = 0;\r\nnonseekable_open(inode, file);\r\nreturn 0;\r\n}\r\nstatic unsigned int ft1000_poll_dev(struct file *file, poll_table *wait)\r\n{\r\nstruct net_device *dev = file->private_data;\r\nstruct ft1000_info *info;\r\nint i;\r\nif (ft1000_flarion_cnt == 0) {\r\nDEBUG("FT1000:ft1000_poll_dev called when ft1000_flarion_cnt is zero\n");\r\nreturn (-EBADF);\r\n}\r\ninfo = netdev_priv(dev);\r\nfor (i=0; i<MAX_NUM_APP; i++) {\r\nif ( info->app_info[i].fileobject == &file->f_owner) {\r\nbreak;\r\n}\r\n}\r\nif (i == MAX_NUM_APP) {\r\nDEBUG("FT1000:ft1000_ioctl:Could not find application info block\n");\r\nreturn ( -EACCES );\r\n}\r\nif (list_empty(&info->app_info[i].app_sqlist) == 0) {\r\nDEBUG("FT1000:ft1000_poll_dev:Message detected in slow queue\n");\r\nreturn(POLLIN | POLLRDNORM | POLLPRI);\r\n}\r\npoll_wait (file, &info->app_info[i].wait_dpram_msg, wait);\r\nreturn (0);\r\n}\r\nstatic long ft1000_ioctl (struct file *file, unsigned int command,\r\nunsigned long argument)\r\n{\r\nvoid __user *argp = (void __user *)argument;\r\nstruct ft1000_info *info;\r\nstruct ft1000_device *ft1000dev;\r\nint result=0;\r\nint cmd;\r\nint i;\r\nu16 tempword;\r\nunsigned long flags;\r\nstruct timeval tv;\r\nIOCTL_GET_VER get_ver_data;\r\nIOCTL_GET_DSP_STAT get_stat_data;\r\nu8 ConnectionMsg[] = {0x00,0x44,0x10,0x20,0x80,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x93,0x64,\r\n0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0a,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x02,0x37,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x01,0x00,0x01,0x7f,0x00,\r\n0x00,0x01,0x00,0x00};\r\nunsigned short ledStat=0;\r\nunsigned short conStat=0;\r\nif (ft1000_flarion_cnt == 0) {\r\nDEBUG("FT1000:ft1000_ioctl called when ft1000_flarion_cnt is zero\n");\r\nreturn (-EBADF);\r\n}\r\ninfo = file->private_data;\r\nft1000dev = info->pFt1000Dev;\r\ncmd = _IOC_NR(command);\r\nswitch (cmd) {\r\ncase IOCTL_REGISTER_CMD:\r\nDEBUG("FT1000:ft1000_ioctl: IOCTL_FT1000_REGISTER called\n");\r\nresult = get_user(tempword, (__u16 __user*)argp);\r\nif (result) {\r\nDEBUG("result = %d failed to get_user\n", result);\r\nbreak;\r\n}\r\nif (tempword == DSPBCMSGID) {\r\nfor (i=0; i<MAX_NUM_APP; i++) {\r\nif ( info->app_info[i].fileobject == &file->f_owner) {\r\ninfo->app_info[i].DspBCMsgFlag = 1;\r\nDEBUG("FT1000:ft1000_ioctl:Registered for broadcast messages\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase IOCTL_GET_VER_CMD:\r\nDEBUG("FT1000:ft1000_ioctl: IOCTL_FT1000_GET_VER called\n");\r\nget_ver_data.drv_ver = FT1000_DRV_VER;\r\nif (copy_to_user(argp, &get_ver_data, sizeof(get_ver_data)) ) {\r\nDEBUG("FT1000:ft1000_ioctl: copy fault occurred\n");\r\nresult = -EFAULT;\r\nbreak;\r\n}\r\nDEBUG("FT1000:ft1000_ioctl:driver version = 0x%x\n",(unsigned int)get_ver_data.drv_ver);\r\nbreak;\r\ncase IOCTL_CONNECT:\r\nDEBUG("FT1000:ft1000_ioctl: IOCTL_FT1000_CONNECT\n");\r\nConnectionMsg[79] = 0xfc;\r\ncard_send_command(ft1000dev, (unsigned short *)ConnectionMsg, 0x4c);\r\nbreak;\r\ncase IOCTL_DISCONNECT:\r\nDEBUG("FT1000:ft1000_ioctl: IOCTL_FT1000_DISCONNECT\n");\r\nConnectionMsg[79] = 0xfd;\r\ncard_send_command(ft1000dev, (unsigned short *)ConnectionMsg, 0x4c);\r\nbreak;\r\ncase IOCTL_GET_DSP_STAT_CMD:\r\nmemset(&get_stat_data, 0, sizeof(get_stat_data));\r\nmemcpy(get_stat_data.DspVer, info->DspVer, DSPVERSZ);\r\nmemcpy(get_stat_data.HwSerNum, info->HwSerNum, HWSERNUMSZ);\r\nmemcpy(get_stat_data.Sku, info->Sku, SKUSZ);\r\nmemcpy(get_stat_data.eui64, info->eui64, EUISZ);\r\nif (info->ProgConStat != 0xFF) {\r\nft1000_read_dpram16(ft1000dev, FT1000_MAG_DSP_LED, (u8 *)&ledStat, FT1000_MAG_DSP_LED_INDX);\r\nget_stat_data.LedStat = ntohs(ledStat);\r\nDEBUG("FT1000:ft1000_ioctl: LedStat = 0x%x\n", get_stat_data.LedStat);\r\nft1000_read_dpram16(ft1000dev, FT1000_MAG_DSP_CON_STATE, (u8 *)&conStat, FT1000_MAG_DSP_CON_STATE_INDX);\r\nget_stat_data.ConStat = ntohs(conStat);\r\nDEBUG("FT1000:ft1000_ioctl: ConStat = 0x%x\n", get_stat_data.ConStat);\r\n}\r\nelse {\r\nget_stat_data.ConStat = 0x0f;\r\n}\r\nget_stat_data.nTxPkts = info->stats.tx_packets;\r\nget_stat_data.nRxPkts = info->stats.rx_packets;\r\nget_stat_data.nTxBytes = info->stats.tx_bytes;\r\nget_stat_data.nRxBytes = info->stats.rx_bytes;\r\ndo_gettimeofday ( &tv );\r\nget_stat_data.ConTm = (u32)(tv.tv_sec - info->ConTm);\r\nDEBUG("Connection Time = %d\n", (int)get_stat_data.ConTm);\r\nif (copy_to_user(argp, &get_stat_data, sizeof(get_stat_data)) ) {\r\nDEBUG("FT1000:ft1000_ioctl: copy fault occurred\n");\r\nresult = -EFAULT;\r\nbreak;\r\n}\r\nDEBUG("ft1000_chioctl: GET_DSP_STAT succeed\n");\r\nbreak;\r\ncase IOCTL_SET_DPRAM_CMD:\r\n{\r\nIOCTL_DPRAM_BLK *dpram_data = NULL;\r\nu16 qtype;\r\nu16 msgsz;\r\nstruct pseudo_hdr *ppseudo_hdr;\r\nu16 *pmsg;\r\nu16 total_len;\r\nu16 app_index;\r\nu16 status;\r\nif (ft1000_flarion_cnt == 0) {\r\nreturn (-EBADF);\r\n}\r\nif (info->DrvMsgPend) {\r\nreturn (-ENOTTY);\r\n}\r\nif ( (info->DspAsicReset) || (info->fProvComplete == 0) ) {\r\nreturn (-EACCES);\r\n}\r\ninfo->fAppMsgPend = 1;\r\nif (info->CardReady) {\r\nresult = get_user(msgsz, (__u16 __user *)argp);\r\nmsgsz = ntohs (msgsz);\r\nif (msgsz > MAX_CMD_SQSIZE) {\r\nDEBUG("FT1000:ft1000_ioctl: bad message length = %d\n", msgsz);\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nresult = -ENOMEM;\r\ndpram_data = kmalloc(msgsz + 2, GFP_KERNEL);\r\nif (!dpram_data)\r\nbreak;\r\nif ( copy_from_user(dpram_data, argp, msgsz+2) ) {\r\nDEBUG("FT1000:ft1000_ChIoctl: copy fault occurred\n");\r\nresult = -EFAULT;\r\n}\r\nelse {\r\nfor (i=0; i<MAX_NUM_APP; i++) {\r\nif ( info->app_info[i].fileobject == &file->f_owner) {\r\nbreak;\r\n}\r\n}\r\nif (i==MAX_NUM_APP) {\r\nDEBUG("FT1000:No matching application fileobject\n");\r\nresult = -EINVAL;\r\nkfree(dpram_data);\r\nbreak;\r\n}\r\napp_index = i;\r\nqtype = ntohs(dpram_data->pseudohdr.qos_class) & 0xff;\r\nif (qtype) {\r\n}\r\nelse {\r\nstatus = ft1000_read_register(ft1000dev, &tempword, FT1000_REG_DOORBELL);\r\nif (tempword & FT1000_DB_DPRAM_TX) {\r\nmdelay(2);\r\nstatus = ft1000_read_register(ft1000dev, &tempword, FT1000_REG_DOORBELL);\r\nif (tempword & FT1000_DB_DPRAM_TX) {\r\nmdelay(1);\r\nstatus = ft1000_read_register(ft1000dev, &tempword, FT1000_REG_DOORBELL);\r\nif (tempword & FT1000_DB_DPRAM_TX) {\r\nstatus = ft1000_read_register(ft1000dev, &tempword, FT1000_REG_DOORBELL);\r\nif (tempword & FT1000_DB_DPRAM_TX) {\r\nmdelay(3);\r\nstatus = ft1000_read_register(ft1000dev, &tempword, FT1000_REG_DOORBELL);\r\nif (tempword & FT1000_DB_DPRAM_TX) {\r\nDEBUG("FT1000:ft1000_ioctl:Doorbell not available\n");\r\nresult = -ENOTTY;\r\nkfree(dpram_data);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif ( (msgsz < MAX_CMD_SQSIZE) && (msgsz > PSEUDOSZ) ) {\r\npmsg = (u16 *)&dpram_data->pseudohdr;\r\nppseudo_hdr = (struct pseudo_hdr *)pmsg;\r\ntotal_len = msgsz+2;\r\nif (total_len & 0x1) {\r\ntotal_len++;\r\n}\r\nppseudo_hdr->seq_num = info->squeseqnum++;\r\nppseudo_hdr->portsrc = info->app_info[app_index].app_id;\r\nppseudo_hdr->checksum = *pmsg++;\r\nfor (i=1; i<7; i++) {\r\nppseudo_hdr->checksum ^= *pmsg++;\r\n}\r\npmsg++;\r\nppseudo_hdr = (struct pseudo_hdr *)pmsg;\r\ncard_send_command(ft1000dev,(unsigned short*)dpram_data,total_len+2);\r\ninfo->app_info[app_index].nTxMsg++;\r\n}\r\nelse {\r\nresult = -EINVAL;\r\n}\r\n}\r\n}\r\n}\r\nelse {\r\nDEBUG("FT1000:ft1000_ioctl: Card not ready take messages\n");\r\nresult = -EACCES;\r\n}\r\nkfree(dpram_data);\r\n}\r\nbreak;\r\ncase IOCTL_GET_DPRAM_CMD:\r\n{\r\nstruct dpram_blk *pdpram_blk;\r\nIOCTL_DPRAM_BLK __user *pioctl_dpram;\r\nint msglen;\r\nif (ft1000_flarion_cnt == 0) {\r\nreturn (-EBADF);\r\n}\r\nfor (i=0; i<MAX_NUM_APP; i++) {\r\nif ( info->app_info[i].fileobject == &file->f_owner) {\r\nbreak;\r\n}\r\n}\r\nif (i == MAX_NUM_APP) {\r\nDEBUG("FT1000:ft1000_ioctl:Could not find application info block\n");\r\nresult = -EBADF;\r\nbreak;\r\n}\r\nresult = 0;\r\npioctl_dpram = argp;\r\nif (list_empty(&info->app_info[i].app_sqlist) == 0) {\r\nspin_lock_irqsave(&free_buff_lock, flags);\r\npdpram_blk = list_entry(info->app_info[i].app_sqlist.next, struct dpram_blk, list);\r\nlist_del(&pdpram_blk->list);\r\ninfo->app_info[i].NumOfMsg--;\r\nspin_unlock_irqrestore(&free_buff_lock, flags);\r\nmsglen = ntohs(*(u16 *)pdpram_blk->pbuffer) + PSEUDOSZ;\r\nresult = get_user(msglen, &pioctl_dpram->total_len);\r\nif (result)\r\nbreak;\r\nmsglen = htons(msglen);\r\nif(copy_to_user (&pioctl_dpram->pseudohdr, pdpram_blk->pbuffer, msglen))\r\n{\r\nDEBUG("FT1000:ft1000_ioctl: copy fault occurred\n");\r\nresult = -EFAULT;\r\nbreak;\r\n}\r\nft1000_free_buffer(pdpram_blk, &freercvpool);\r\nresult = msglen;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nDEBUG("FT1000:ft1000_ioctl:unknown command: 0x%x\n", command);\r\nresult = -ENOTTY;\r\nbreak;\r\n}\r\ninfo->fAppMsgPend = 0;\r\nreturn result;\r\n}\r\nstatic int ft1000_release (struct inode *inode, struct file *file)\r\n{\r\nstruct ft1000_info *info;\r\nstruct net_device *dev;\r\nint i;\r\nstruct dpram_blk *pdpram_blk;\r\nDEBUG("ft1000_release called\n");\r\ndev = file->private_data;\r\ninfo = netdev_priv(dev);\r\nif (ft1000_flarion_cnt == 0) {\r\ninfo->appcnt--;\r\nreturn (-EBADF);\r\n}\r\nfor (i=0; i<MAX_NUM_APP; i++) {\r\nif ( info->app_info[i].fileobject == &file->f_owner) {\r\nbreak;\r\n}\r\n}\r\nif (i==MAX_NUM_APP)\r\nreturn 0;\r\nwhile (list_empty(&info->app_info[i].app_sqlist) == 0) {\r\nDEBUG("Remove and free memory queue up on slow queue\n");\r\npdpram_blk = list_entry(info->app_info[i].app_sqlist.next, struct dpram_blk, list);\r\nlist_del(&pdpram_blk->list);\r\nft1000_free_buffer(pdpram_blk, &freercvpool);\r\n}\r\ninfo->appcnt--;\r\nDEBUG("ft1000_chdev:%s:appcnt = %d\n", __FUNCTION__, info->appcnt);\r\ninfo->app_info[i].fileobject = NULL;\r\nreturn 0;\r\n}
