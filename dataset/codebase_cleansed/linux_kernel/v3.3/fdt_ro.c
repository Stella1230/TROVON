static int _fdt_nodename_eq(const void *fdt, int offset,\r\nconst char *s, int len)\r\n{\r\nconst char *p = fdt_offset_ptr(fdt, offset + FDT_TAGSIZE, len+1);\r\nif (! p)\r\nreturn 0;\r\nif (memcmp(p, s, len) != 0)\r\nreturn 0;\r\nif (p[len] == '\0')\r\nreturn 1;\r\nelse if (!memchr(s, '@', len) && (p[len] == '@'))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nconst char *fdt_string(const void *fdt, int stroffset)\r\n{\r\nreturn (const char *)fdt + fdt_off_dt_strings(fdt) + stroffset;\r\n}\r\nint fdt_get_mem_rsv(const void *fdt, int n, uint64_t *address, uint64_t *size)\r\n{\r\nFDT_CHECK_HEADER(fdt);\r\n*address = fdt64_to_cpu(_fdt_mem_rsv(fdt, n)->address);\r\n*size = fdt64_to_cpu(_fdt_mem_rsv(fdt, n)->size);\r\nreturn 0;\r\n}\r\nint fdt_num_mem_rsv(const void *fdt)\r\n{\r\nint i = 0;\r\nwhile (fdt64_to_cpu(_fdt_mem_rsv(fdt, i)->size) != 0)\r\ni++;\r\nreturn i;\r\n}\r\nint fdt_subnode_offset_namelen(const void *fdt, int offset,\r\nconst char *name, int namelen)\r\n{\r\nint depth;\r\nFDT_CHECK_HEADER(fdt);\r\nfor (depth = 0, offset = fdt_next_node(fdt, offset, &depth);\r\n(offset >= 0) && (depth > 0);\r\noffset = fdt_next_node(fdt, offset, &depth)) {\r\nif (depth < 0)\r\nreturn -FDT_ERR_NOTFOUND;\r\nelse if ((depth == 1)\r\n&& _fdt_nodename_eq(fdt, offset, name, namelen))\r\nreturn offset;\r\n}\r\nif (offset < 0)\r\nreturn offset;\r\nelse\r\nreturn -FDT_ERR_NOTFOUND;\r\n}\r\nint fdt_subnode_offset(const void *fdt, int parentoffset,\r\nconst char *name)\r\n{\r\nreturn fdt_subnode_offset_namelen(fdt, parentoffset, name, strlen(name));\r\n}\r\nint fdt_path_offset(const void *fdt, const char *path)\r\n{\r\nconst char *end = path + strlen(path);\r\nconst char *p = path;\r\nint offset = 0;\r\nFDT_CHECK_HEADER(fdt);\r\nif (*path != '/')\r\nreturn -FDT_ERR_BADPATH;\r\nwhile (*p) {\r\nconst char *q;\r\nwhile (*p == '/')\r\np++;\r\nif (! *p)\r\nreturn offset;\r\nq = strchr(p, '/');\r\nif (! q)\r\nq = end;\r\noffset = fdt_subnode_offset_namelen(fdt, offset, p, q-p);\r\nif (offset < 0)\r\nreturn offset;\r\np = q;\r\n}\r\nreturn offset;\r\n}\r\nconst char *fdt_get_name(const void *fdt, int nodeoffset, int *len)\r\n{\r\nconst struct fdt_node_header *nh = _fdt_offset_ptr(fdt, nodeoffset);\r\nint err;\r\nif (((err = fdt_check_header(fdt)) != 0)\r\n|| ((err = _fdt_check_node_offset(fdt, nodeoffset)) < 0))\r\ngoto fail;\r\nif (len)\r\n*len = strlen(nh->name);\r\nreturn nh->name;\r\nfail:\r\nif (len)\r\n*len = err;\r\nreturn NULL;\r\n}\r\nconst struct fdt_property *fdt_get_property(const void *fdt,\r\nint nodeoffset,\r\nconst char *name, int *lenp)\r\n{\r\nuint32_t tag;\r\nconst struct fdt_property *prop;\r\nint namestroff;\r\nint offset, nextoffset;\r\nint err;\r\nif (((err = fdt_check_header(fdt)) != 0)\r\n|| ((err = _fdt_check_node_offset(fdt, nodeoffset)) < 0))\r\ngoto fail;\r\nnextoffset = err;\r\ndo {\r\noffset = nextoffset;\r\ntag = fdt_next_tag(fdt, offset, &nextoffset);\r\nswitch (tag) {\r\ncase FDT_END:\r\nerr = -FDT_ERR_TRUNCATED;\r\ngoto fail;\r\ncase FDT_BEGIN_NODE:\r\ncase FDT_END_NODE:\r\ncase FDT_NOP:\r\nbreak;\r\ncase FDT_PROP:\r\nerr = -FDT_ERR_BADSTRUCTURE;\r\nprop = fdt_offset_ptr(fdt, offset, sizeof(*prop));\r\nif (! prop)\r\ngoto fail;\r\nnamestroff = fdt32_to_cpu(prop->nameoff);\r\nif (strcmp(fdt_string(fdt, namestroff), name) == 0) {\r\nint len = fdt32_to_cpu(prop->len);\r\nprop = fdt_offset_ptr(fdt, offset,\r\nsizeof(*prop)+len);\r\nif (! prop)\r\ngoto fail;\r\nif (lenp)\r\n*lenp = len;\r\nreturn prop;\r\n}\r\nbreak;\r\ndefault:\r\nerr = -FDT_ERR_BADSTRUCTURE;\r\ngoto fail;\r\n}\r\n} while ((tag != FDT_BEGIN_NODE) && (tag != FDT_END_NODE));\r\nerr = -FDT_ERR_NOTFOUND;\r\nfail:\r\nif (lenp)\r\n*lenp = err;\r\nreturn NULL;\r\n}\r\nconst void *fdt_getprop(const void *fdt, int nodeoffset,\r\nconst char *name, int *lenp)\r\n{\r\nconst struct fdt_property *prop;\r\nprop = fdt_get_property(fdt, nodeoffset, name, lenp);\r\nif (! prop)\r\nreturn NULL;\r\nreturn prop->data;\r\n}\r\nuint32_t fdt_get_phandle(const void *fdt, int nodeoffset)\r\n{\r\nconst uint32_t *php;\r\nint len;\r\nphp = fdt_getprop(fdt, nodeoffset, "linux,phandle", &len);\r\nif (!php || (len != sizeof(*php)))\r\nreturn 0;\r\nreturn fdt32_to_cpu(*php);\r\n}\r\nint fdt_get_path(const void *fdt, int nodeoffset, char *buf, int buflen)\r\n{\r\nint pdepth = 0, p = 0;\r\nint offset, depth, namelen;\r\nconst char *name;\r\nFDT_CHECK_HEADER(fdt);\r\nif (buflen < 2)\r\nreturn -FDT_ERR_NOSPACE;\r\nfor (offset = 0, depth = 0;\r\n(offset >= 0) && (offset <= nodeoffset);\r\noffset = fdt_next_node(fdt, offset, &depth)) {\r\nif (pdepth < depth)\r\ncontinue;\r\nwhile (pdepth > depth) {\r\ndo {\r\np--;\r\n} while (buf[p-1] != '/');\r\npdepth--;\r\n}\r\nname = fdt_get_name(fdt, offset, &namelen);\r\nif (!name)\r\nreturn namelen;\r\nif ((p + namelen + 1) <= buflen) {\r\nmemcpy(buf + p, name, namelen);\r\np += namelen;\r\nbuf[p++] = '/';\r\npdepth++;\r\n}\r\nif (offset == nodeoffset) {\r\nif (pdepth < (depth + 1))\r\nreturn -FDT_ERR_NOSPACE;\r\nif (p > 1)\r\np--;\r\nbuf[p] = '\0';\r\nreturn p;\r\n}\r\n}\r\nif ((offset == -FDT_ERR_NOTFOUND) || (offset >= 0))\r\nreturn -FDT_ERR_BADOFFSET;\r\nelse if (offset == -FDT_ERR_BADOFFSET)\r\nreturn -FDT_ERR_BADSTRUCTURE;\r\nreturn offset;\r\n}\r\nint fdt_supernode_atdepth_offset(const void *fdt, int nodeoffset,\r\nint supernodedepth, int *nodedepth)\r\n{\r\nint offset, depth;\r\nint supernodeoffset = -FDT_ERR_INTERNAL;\r\nFDT_CHECK_HEADER(fdt);\r\nif (supernodedepth < 0)\r\nreturn -FDT_ERR_NOTFOUND;\r\nfor (offset = 0, depth = 0;\r\n(offset >= 0) && (offset <= nodeoffset);\r\noffset = fdt_next_node(fdt, offset, &depth)) {\r\nif (depth == supernodedepth)\r\nsupernodeoffset = offset;\r\nif (offset == nodeoffset) {\r\nif (nodedepth)\r\n*nodedepth = depth;\r\nif (supernodedepth > depth)\r\nreturn -FDT_ERR_NOTFOUND;\r\nelse\r\nreturn supernodeoffset;\r\n}\r\n}\r\nif ((offset == -FDT_ERR_NOTFOUND) || (offset >= 0))\r\nreturn -FDT_ERR_BADOFFSET;\r\nelse if (offset == -FDT_ERR_BADOFFSET)\r\nreturn -FDT_ERR_BADSTRUCTURE;\r\nreturn offset;\r\n}\r\nint fdt_node_depth(const void *fdt, int nodeoffset)\r\n{\r\nint nodedepth;\r\nint err;\r\nerr = fdt_supernode_atdepth_offset(fdt, nodeoffset, 0, &nodedepth);\r\nif (err)\r\nreturn (err < 0) ? err : -FDT_ERR_INTERNAL;\r\nreturn nodedepth;\r\n}\r\nint fdt_parent_offset(const void *fdt, int nodeoffset)\r\n{\r\nint nodedepth = fdt_node_depth(fdt, nodeoffset);\r\nif (nodedepth < 0)\r\nreturn nodedepth;\r\nreturn fdt_supernode_atdepth_offset(fdt, nodeoffset,\r\nnodedepth - 1, NULL);\r\n}\r\nint fdt_node_offset_by_prop_value(const void *fdt, int startoffset,\r\nconst char *propname,\r\nconst void *propval, int proplen)\r\n{\r\nint offset;\r\nconst void *val;\r\nint len;\r\nFDT_CHECK_HEADER(fdt);\r\nfor (offset = fdt_next_node(fdt, startoffset, NULL);\r\noffset >= 0;\r\noffset = fdt_next_node(fdt, offset, NULL)) {\r\nval = fdt_getprop(fdt, offset, propname, &len);\r\nif (val && (len == proplen)\r\n&& (memcmp(val, propval, len) == 0))\r\nreturn offset;\r\n}\r\nreturn offset;\r\n}\r\nint fdt_node_offset_by_phandle(const void *fdt, uint32_t phandle)\r\n{\r\nif ((phandle == 0) || (phandle == -1))\r\nreturn -FDT_ERR_BADPHANDLE;\r\nphandle = cpu_to_fdt32(phandle);\r\nreturn fdt_node_offset_by_prop_value(fdt, -1, "linux,phandle",\r\n&phandle, sizeof(phandle));\r\n}\r\nstatic int _stringlist_contains(const char *strlist, int listlen, const char *str)\r\n{\r\nint len = strlen(str);\r\nconst char *p;\r\nwhile (listlen >= len) {\r\nif (memcmp(str, strlist, len+1) == 0)\r\nreturn 1;\r\np = memchr(strlist, '\0', listlen);\r\nif (!p)\r\nreturn 0;\r\nlistlen -= (p-strlist) + 1;\r\nstrlist = p + 1;\r\n}\r\nreturn 0;\r\n}\r\nint fdt_node_check_compatible(const void *fdt, int nodeoffset,\r\nconst char *compatible)\r\n{\r\nconst void *prop;\r\nint len;\r\nprop = fdt_getprop(fdt, nodeoffset, "compatible", &len);\r\nif (!prop)\r\nreturn len;\r\nif (_stringlist_contains(prop, len, compatible))\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nint fdt_node_offset_by_compatible(const void *fdt, int startoffset,\r\nconst char *compatible)\r\n{\r\nint offset, err;\r\nFDT_CHECK_HEADER(fdt);\r\nfor (offset = fdt_next_node(fdt, startoffset, NULL);\r\noffset >= 0;\r\noffset = fdt_next_node(fdt, offset, NULL)) {\r\nerr = fdt_node_check_compatible(fdt, offset, compatible);\r\nif ((err < 0) && (err != -FDT_ERR_NOTFOUND))\r\nreturn err;\r\nelse if (err == 0)\r\nreturn offset;\r\n}\r\nreturn offset;\r\n}
