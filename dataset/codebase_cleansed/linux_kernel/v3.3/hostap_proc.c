static int prism2_debug_proc_read(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nchar *p = page;\r\nlocal_info_t *local = (local_info_t *) data;\r\nint i;\r\nif (off != 0) {\r\n*eof = 1;\r\nreturn 0;\r\n}\r\np += sprintf(p, "next_txfid=%d next_alloc=%d\n",\r\nlocal->next_txfid, local->next_alloc);\r\nfor (i = 0; i < PRISM2_TXFID_COUNT; i++)\r\np += sprintf(p, "FID: tx=%04X intransmit=%04X\n",\r\nlocal->txfid[i], local->intransmitfid[i]);\r\np += sprintf(p, "FW TX rate control: %d\n", local->fw_tx_rate_control);\r\np += sprintf(p, "beacon_int=%d\n", local->beacon_int);\r\np += sprintf(p, "dtim_period=%d\n", local->dtim_period);\r\np += sprintf(p, "wds_max_connections=%d\n",\r\nlocal->wds_max_connections);\r\np += sprintf(p, "dev_enabled=%d\n", local->dev_enabled);\r\np += sprintf(p, "sw_tick_stuck=%d\n", local->sw_tick_stuck);\r\nfor (i = 0; i < WEP_KEYS; i++) {\r\nif (local->crypt_info.crypt[i] &&\r\nlocal->crypt_info.crypt[i]->ops) {\r\np += sprintf(p, "crypt[%d]=%s\n", i,\r\nlocal->crypt_info.crypt[i]->ops->name);\r\n}\r\n}\r\np += sprintf(p, "pri_only=%d\n", local->pri_only);\r\np += sprintf(p, "pci=%d\n", local->func->hw_type == HOSTAP_HW_PCI);\r\np += sprintf(p, "sram_type=%d\n", local->sram_type);\r\np += sprintf(p, "no_pri=%d\n", local->no_pri);\r\nreturn (p - page);\r\n}\r\nstatic int prism2_stats_proc_read(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nchar *p = page;\r\nlocal_info_t *local = (local_info_t *) data;\r\nstruct comm_tallies_sums *sums = (struct comm_tallies_sums *)\r\n&local->comm_tallies;\r\nif (off != 0) {\r\n*eof = 1;\r\nreturn 0;\r\n}\r\np += sprintf(p, "TxUnicastFrames=%u\n", sums->tx_unicast_frames);\r\np += sprintf(p, "TxMulticastframes=%u\n", sums->tx_multicast_frames);\r\np += sprintf(p, "TxFragments=%u\n", sums->tx_fragments);\r\np += sprintf(p, "TxUnicastOctets=%u\n", sums->tx_unicast_octets);\r\np += sprintf(p, "TxMulticastOctets=%u\n", sums->tx_multicast_octets);\r\np += sprintf(p, "TxDeferredTransmissions=%u\n",\r\nsums->tx_deferred_transmissions);\r\np += sprintf(p, "TxSingleRetryFrames=%u\n",\r\nsums->tx_single_retry_frames);\r\np += sprintf(p, "TxMultipleRetryFrames=%u\n",\r\nsums->tx_multiple_retry_frames);\r\np += sprintf(p, "TxRetryLimitExceeded=%u\n",\r\nsums->tx_retry_limit_exceeded);\r\np += sprintf(p, "TxDiscards=%u\n", sums->tx_discards);\r\np += sprintf(p, "RxUnicastFrames=%u\n", sums->rx_unicast_frames);\r\np += sprintf(p, "RxMulticastFrames=%u\n", sums->rx_multicast_frames);\r\np += sprintf(p, "RxFragments=%u\n", sums->rx_fragments);\r\np += sprintf(p, "RxUnicastOctets=%u\n", sums->rx_unicast_octets);\r\np += sprintf(p, "RxMulticastOctets=%u\n", sums->rx_multicast_octets);\r\np += sprintf(p, "RxFCSErrors=%u\n", sums->rx_fcs_errors);\r\np += sprintf(p, "RxDiscardsNoBuffer=%u\n",\r\nsums->rx_discards_no_buffer);\r\np += sprintf(p, "TxDiscardsWrongSA=%u\n", sums->tx_discards_wrong_sa);\r\np += sprintf(p, "RxDiscardsWEPUndecryptable=%u\n",\r\nsums->rx_discards_wep_undecryptable);\r\np += sprintf(p, "RxMessageInMsgFragments=%u\n",\r\nsums->rx_message_in_msg_fragments);\r\np += sprintf(p, "RxMessageInBadMsgFragments=%u\n",\r\nsums->rx_message_in_bad_msg_fragments);\r\nreturn (p - page);\r\n}\r\nstatic int prism2_wds_proc_read(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nchar *p = page;\r\nlocal_info_t *local = (local_info_t *) data;\r\nstruct list_head *ptr;\r\nstruct hostap_interface *iface;\r\nif (off > PROC_LIMIT) {\r\n*eof = 1;\r\nreturn 0;\r\n}\r\nread_lock_bh(&local->iface_lock);\r\nlist_for_each(ptr, &local->hostap_interfaces) {\r\niface = list_entry(ptr, struct hostap_interface, list);\r\nif (iface->type != HOSTAP_INTERFACE_WDS)\r\ncontinue;\r\np += sprintf(p, "%s\t%pM\n",\r\niface->dev->name,\r\niface->u.wds.remote_addr);\r\nif ((p - page) > PROC_LIMIT) {\r\nprintk(KERN_DEBUG "%s: wds proc did not fit\n",\r\nlocal->dev->name);\r\nbreak;\r\n}\r\n}\r\nread_unlock_bh(&local->iface_lock);\r\nif ((p - page) <= off) {\r\n*eof = 1;\r\nreturn 0;\r\n}\r\n*start = page + off;\r\nreturn (p - page - off);\r\n}\r\nstatic int prism2_bss_list_proc_read(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nchar *p = page;\r\nlocal_info_t *local = (local_info_t *) data;\r\nstruct list_head *ptr;\r\nstruct hostap_bss_info *bss;\r\nint i;\r\nif (off > PROC_LIMIT) {\r\n*eof = 1;\r\nreturn 0;\r\n}\r\np += sprintf(p, "#BSSID\tlast_update\tcount\tcapab_info\tSSID(txt)\t"\r\n"SSID(hex)\tWPA IE\n");\r\nspin_lock_bh(&local->lock);\r\nlist_for_each(ptr, &local->bss_list) {\r\nbss = list_entry(ptr, struct hostap_bss_info, list);\r\np += sprintf(p, "%pM\t%lu\t%u\t0x%x\t",\r\nbss->bssid, bss->last_update,\r\nbss->count, bss->capab_info);\r\nfor (i = 0; i < bss->ssid_len; i++) {\r\np += sprintf(p, "%c",\r\nbss->ssid[i] >= 32 && bss->ssid[i] < 127 ?\r\nbss->ssid[i] : '_');\r\n}\r\np += sprintf(p, "\t");\r\nfor (i = 0; i < bss->ssid_len; i++) {\r\np += sprintf(p, "%02x", bss->ssid[i]);\r\n}\r\np += sprintf(p, "\t");\r\nfor (i = 0; i < bss->wpa_ie_len; i++) {\r\np += sprintf(p, "%02x", bss->wpa_ie[i]);\r\n}\r\np += sprintf(p, "\n");\r\nif ((p - page) > PROC_LIMIT) {\r\nprintk(KERN_DEBUG "%s: BSS proc did not fit\n",\r\nlocal->dev->name);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&local->lock);\r\nif ((p - page) <= off) {\r\n*eof = 1;\r\nreturn 0;\r\n}\r\n*start = page + off;\r\nreturn (p - page - off);\r\n}\r\nstatic int prism2_crypt_proc_read(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nchar *p = page;\r\nlocal_info_t *local = (local_info_t *) data;\r\nint i;\r\nif (off > PROC_LIMIT) {\r\n*eof = 1;\r\nreturn 0;\r\n}\r\np += sprintf(p, "tx_keyidx=%d\n", local->crypt_info.tx_keyidx);\r\nfor (i = 0; i < WEP_KEYS; i++) {\r\nif (local->crypt_info.crypt[i] &&\r\nlocal->crypt_info.crypt[i]->ops &&\r\nlocal->crypt_info.crypt[i]->ops->print_stats) {\r\np = local->crypt_info.crypt[i]->ops->print_stats(\r\np, local->crypt_info.crypt[i]->priv);\r\n}\r\n}\r\nif ((p - page) <= off) {\r\n*eof = 1;\r\nreturn 0;\r\n}\r\n*start = page + off;\r\nreturn (p - page - off);\r\n}\r\nstatic int prism2_pda_proc_read(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nlocal_info_t *local = (local_info_t *) data;\r\nif (local->pda == NULL || off >= PRISM2_PDA_SIZE) {\r\n*eof = 1;\r\nreturn 0;\r\n}\r\nif (off + count > PRISM2_PDA_SIZE)\r\ncount = PRISM2_PDA_SIZE - off;\r\nmemcpy(page, local->pda + off, count);\r\nreturn count;\r\n}\r\nstatic int prism2_aux_dump_proc_read(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nlocal_info_t *local = (local_info_t *) data;\r\nif (local->func->read_aux == NULL) {\r\n*eof = 1;\r\nreturn 0;\r\n}\r\nif (local->func->read_aux(local->dev, off, count, page)) {\r\n*eof = 1;\r\nreturn 0;\r\n}\r\n*start = page;\r\nreturn count;\r\n}\r\nstatic int prism2_io_debug_proc_read(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nlocal_info_t *local = (local_info_t *) data;\r\nint head = local->io_debug_head;\r\nint start_bytes, left, copy, copied;\r\nif (off + count > PRISM2_IO_DEBUG_SIZE * 4) {\r\n*eof = 1;\r\nif (off >= PRISM2_IO_DEBUG_SIZE * 4)\r\nreturn 0;\r\ncount = PRISM2_IO_DEBUG_SIZE * 4 - off;\r\n}\r\ncopied = 0;\r\nstart_bytes = (PRISM2_IO_DEBUG_SIZE - head) * 4;\r\nleft = count;\r\nif (off < start_bytes) {\r\ncopy = start_bytes - off;\r\nif (copy > count)\r\ncopy = count;\r\nmemcpy(page, ((u8 *) &local->io_debug[head]) + off, copy);\r\nleft -= copy;\r\nif (left > 0)\r\nmemcpy(&page[copy], local->io_debug, left);\r\n} else {\r\nmemcpy(page, ((u8 *) local->io_debug) + (off - start_bytes),\r\nleft);\r\n}\r\n*start = page;\r\nreturn count;\r\n}\r\nstatic int prism2_scan_results_proc_read(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nchar *p = page;\r\nlocal_info_t *local = (local_info_t *) data;\r\nint entry, i, len, total = 0;\r\nstruct hfa384x_hostscan_result *scanres;\r\nu8 *pos;\r\np += sprintf(p, "CHID ANL SL BcnInt Capab Rate BSSID ATIM SupRates "\r\n"SSID\n");\r\nspin_lock_bh(&local->lock);\r\nfor (entry = 0; entry < local->last_scan_results_count; entry++) {\r\nscanres = &local->last_scan_results[entry];\r\nif (total + (p - page) <= off) {\r\ntotal += p - page;\r\np = page;\r\n}\r\nif (total + (p - page) > off + count)\r\nbreak;\r\nif ((p - page) > (PAGE_SIZE - 200))\r\nbreak;\r\np += sprintf(p, "%d %d %d %d 0x%02x %d %pM %d ",\r\nle16_to_cpu(scanres->chid),\r\n(s16) le16_to_cpu(scanres->anl),\r\n(s16) le16_to_cpu(scanres->sl),\r\nle16_to_cpu(scanres->beacon_interval),\r\nle16_to_cpu(scanres->capability),\r\nle16_to_cpu(scanres->rate),\r\nscanres->bssid,\r\nle16_to_cpu(scanres->atim));\r\npos = scanres->sup_rates;\r\nfor (i = 0; i < sizeof(scanres->sup_rates); i++) {\r\nif (pos[i] == 0)\r\nbreak;\r\np += sprintf(p, "<%02x>", pos[i]);\r\n}\r\np += sprintf(p, " ");\r\npos = scanres->ssid;\r\nlen = le16_to_cpu(scanres->ssid_len);\r\nif (len > 32)\r\nlen = 32;\r\nfor (i = 0; i < len; i++) {\r\nunsigned char c = pos[i];\r\nif (c >= 32 && c < 127)\r\np += sprintf(p, "%c", c);\r\nelse\r\np += sprintf(p, "<%02x>", c);\r\n}\r\np += sprintf(p, "\n");\r\n}\r\nspin_unlock_bh(&local->lock);\r\ntotal += (p - page);\r\nif (total >= off + count)\r\n*eof = 1;\r\nif (total < off) {\r\n*eof = 1;\r\nreturn 0;\r\n}\r\nlen = total - off;\r\nif (len > (p - page))\r\nlen = p - page;\r\n*start = p - len;\r\nif (len > count)\r\nlen = count;\r\nreturn len;\r\n}\r\nvoid hostap_init_proc(local_info_t *local)\r\n{\r\nlocal->proc = NULL;\r\nif (hostap_proc == NULL) {\r\nprintk(KERN_WARNING "%s: hostap proc directory not created\n",\r\nlocal->dev->name);\r\nreturn;\r\n}\r\nlocal->proc = proc_mkdir(local->ddev->name, hostap_proc);\r\nif (local->proc == NULL) {\r\nprintk(KERN_INFO "/proc/net/hostap/%s creation failed\n",\r\nlocal->ddev->name);\r\nreturn;\r\n}\r\n#ifndef PRISM2_NO_PROCFS_DEBUG\r\ncreate_proc_read_entry("debug", 0, local->proc,\r\nprism2_debug_proc_read, local);\r\n#endif\r\ncreate_proc_read_entry("stats", 0, local->proc,\r\nprism2_stats_proc_read, local);\r\ncreate_proc_read_entry("wds", 0, local->proc,\r\nprism2_wds_proc_read, local);\r\ncreate_proc_read_entry("pda", 0, local->proc,\r\nprism2_pda_proc_read, local);\r\ncreate_proc_read_entry("aux_dump", 0, local->proc,\r\nprism2_aux_dump_proc_read, local);\r\ncreate_proc_read_entry("bss_list", 0, local->proc,\r\nprism2_bss_list_proc_read, local);\r\ncreate_proc_read_entry("crypt", 0, local->proc,\r\nprism2_crypt_proc_read, local);\r\n#ifdef PRISM2_IO_DEBUG\r\ncreate_proc_read_entry("io_debug", 0, local->proc,\r\nprism2_io_debug_proc_read, local);\r\n#endif\r\n#ifndef PRISM2_NO_STATION_MODES\r\ncreate_proc_read_entry("scan_results", 0, local->proc,\r\nprism2_scan_results_proc_read, local);\r\n#endif\r\n}\r\nvoid hostap_remove_proc(local_info_t *local)\r\n{\r\nif (local->proc != NULL) {\r\n#ifndef PRISM2_NO_STATION_MODES\r\nremove_proc_entry("scan_results", local->proc);\r\n#endif\r\n#ifdef PRISM2_IO_DEBUG\r\nremove_proc_entry("io_debug", local->proc);\r\n#endif\r\nremove_proc_entry("pda", local->proc);\r\nremove_proc_entry("aux_dump", local->proc);\r\nremove_proc_entry("wds", local->proc);\r\nremove_proc_entry("stats", local->proc);\r\nremove_proc_entry("bss_list", local->proc);\r\nremove_proc_entry("crypt", local->proc);\r\n#ifndef PRISM2_NO_PROCFS_DEBUG\r\nremove_proc_entry("debug", local->proc);\r\n#endif\r\nif (hostap_proc != NULL)\r\nremove_proc_entry(local->proc->name, hostap_proc);\r\n}\r\n}
