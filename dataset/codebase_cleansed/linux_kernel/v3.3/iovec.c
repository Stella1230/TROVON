int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode)\r\n{\r\nint size, ct, err;\r\nif (m->msg_namelen) {\r\nif (mode == VERIFY_READ) {\r\nvoid __user *namep;\r\nnamep = (void __user __force *) m->msg_name;\r\nerr = move_addr_to_kernel(namep, m->msg_namelen,\r\naddress);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nm->msg_name = address;\r\n} else {\r\nm->msg_name = NULL;\r\n}\r\nsize = m->msg_iovlen * sizeof(struct iovec);\r\nif (copy_from_user(iov, (void __user __force *) m->msg_iov, size))\r\nreturn -EFAULT;\r\nm->msg_iov = iov;\r\nerr = 0;\r\nfor (ct = 0; ct < m->msg_iovlen; ct++) {\r\nsize_t len = iov[ct].iov_len;\r\nif (len > INT_MAX - err) {\r\nlen = INT_MAX - err;\r\niov[ct].iov_len = len;\r\n}\r\nerr += len;\r\n}\r\nreturn err;\r\n}\r\nint memcpy_toiovec(struct iovec *iov, unsigned char *kdata, int len)\r\n{\r\nwhile (len > 0) {\r\nif (iov->iov_len) {\r\nint copy = min_t(unsigned int, iov->iov_len, len);\r\nif (copy_to_user(iov->iov_base, kdata, copy))\r\nreturn -EFAULT;\r\nkdata += copy;\r\nlen -= copy;\r\niov->iov_len -= copy;\r\niov->iov_base += copy;\r\n}\r\niov++;\r\n}\r\nreturn 0;\r\n}\r\nint memcpy_toiovecend(const struct iovec *iov, unsigned char *kdata,\r\nint offset, int len)\r\n{\r\nint copy;\r\nfor (; len > 0; ++iov) {\r\nif (unlikely(offset >= iov->iov_len)) {\r\noffset -= iov->iov_len;\r\ncontinue;\r\n}\r\ncopy = min_t(unsigned int, iov->iov_len - offset, len);\r\nif (copy_to_user(iov->iov_base + offset, kdata, copy))\r\nreturn -EFAULT;\r\noffset = 0;\r\nkdata += copy;\r\nlen -= copy;\r\n}\r\nreturn 0;\r\n}\r\nint memcpy_fromiovec(unsigned char *kdata, struct iovec *iov, int len)\r\n{\r\nwhile (len > 0) {\r\nif (iov->iov_len) {\r\nint copy = min_t(unsigned int, len, iov->iov_len);\r\nif (copy_from_user(kdata, iov->iov_base, copy))\r\nreturn -EFAULT;\r\nlen -= copy;\r\nkdata += copy;\r\niov->iov_base += copy;\r\niov->iov_len -= copy;\r\n}\r\niov++;\r\n}\r\nreturn 0;\r\n}\r\nint memcpy_fromiovecend(unsigned char *kdata, const struct iovec *iov,\r\nint offset, int len)\r\n{\r\nwhile (offset >= iov->iov_len) {\r\noffset -= iov->iov_len;\r\niov++;\r\n}\r\nwhile (len > 0) {\r\nu8 __user *base = iov->iov_base + offset;\r\nint copy = min_t(unsigned int, len, iov->iov_len - offset);\r\noffset = 0;\r\nif (copy_from_user(kdata, base, copy))\r\nreturn -EFAULT;\r\nlen -= copy;\r\nkdata += copy;\r\niov++;\r\n}\r\nreturn 0;\r\n}\r\nint csum_partial_copy_fromiovecend(unsigned char *kdata, struct iovec *iov,\r\nint offset, unsigned int len, __wsum *csump)\r\n{\r\n__wsum csum = *csump;\r\nint partial_cnt = 0, err = 0;\r\nwhile (offset >= iov->iov_len) {\r\noffset -= iov->iov_len;\r\niov++;\r\n}\r\nwhile (len > 0) {\r\nu8 __user *base = iov->iov_base + offset;\r\nint copy = min_t(unsigned int, len, iov->iov_len - offset);\r\noffset = 0;\r\nif (partial_cnt) {\r\nint par_len = 4 - partial_cnt;\r\nif (par_len > copy) {\r\nif (copy_from_user(kdata, base, copy))\r\ngoto out_fault;\r\nkdata += copy;\r\nbase += copy;\r\npartial_cnt += copy;\r\nlen -= copy;\r\niov++;\r\nif (len)\r\ncontinue;\r\n*csump = csum_partial(kdata - partial_cnt,\r\npartial_cnt, csum);\r\ngoto out;\r\n}\r\nif (copy_from_user(kdata, base, par_len))\r\ngoto out_fault;\r\ncsum = csum_partial(kdata - partial_cnt, 4, csum);\r\nkdata += par_len;\r\nbase += par_len;\r\ncopy -= par_len;\r\nlen -= par_len;\r\npartial_cnt = 0;\r\n}\r\nif (len > copy) {\r\npartial_cnt = copy % 4;\r\nif (partial_cnt) {\r\ncopy -= partial_cnt;\r\nif (copy_from_user(kdata + copy, base + copy,\r\npartial_cnt))\r\ngoto out_fault;\r\n}\r\n}\r\nif (copy) {\r\ncsum = csum_and_copy_from_user(base, kdata, copy,\r\ncsum, &err);\r\nif (err)\r\ngoto out;\r\n}\r\nlen -= copy + partial_cnt;\r\nkdata += copy + partial_cnt;\r\niov++;\r\n}\r\n*csump = csum;\r\nout:\r\nreturn err;\r\nout_fault:\r\nerr = -EFAULT;\r\ngoto out;\r\n}
