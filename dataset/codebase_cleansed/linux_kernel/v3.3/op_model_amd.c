static unsigned int lfsr_random(void)\r\n{\r\nstatic unsigned int lfsr_value = 0xF00D;\r\nunsigned int bit;\r\nbit = ((lfsr_value >> 0) ^\r\n(lfsr_value >> 2) ^\r\n(lfsr_value >> 3) ^\r\n(lfsr_value >> 5)) & 0x0001;\r\nlfsr_value = (lfsr_value >> 1) | (bit << 15);\r\nreturn lfsr_value;\r\n}\r\nstatic inline u64 op_amd_randomize_ibs_op(u64 val)\r\n{\r\nunsigned int random = lfsr_random();\r\nif (!(ibs_caps & IBS_CAPS_RDWROPCNT))\r\nval += (s8)(random >> 4);\r\nelse\r\nval |= (u64)(random & IBS_RANDOM_MASK) << 32;\r\nreturn val;\r\n}\r\nstatic inline void\r\nop_amd_handle_ibs(struct pt_regs * const regs,\r\nstruct op_msrs const * const msrs)\r\n{\r\nu64 val, ctl;\r\nstruct op_entry entry;\r\nif (!ibs_caps)\r\nreturn;\r\nif (ibs_config.fetch_enabled) {\r\nrdmsrl(MSR_AMD64_IBSFETCHCTL, ctl);\r\nif (ctl & IBS_FETCH_VAL) {\r\nrdmsrl(MSR_AMD64_IBSFETCHLINAD, val);\r\noprofile_write_reserve(&entry, regs, val,\r\nIBS_FETCH_CODE, IBS_FETCH_SIZE);\r\noprofile_add_data64(&entry, val);\r\noprofile_add_data64(&entry, ctl);\r\nrdmsrl(MSR_AMD64_IBSFETCHPHYSAD, val);\r\noprofile_add_data64(&entry, val);\r\noprofile_write_commit(&entry);\r\nctl &= ~(IBS_FETCH_VAL | IBS_FETCH_CNT);\r\nctl |= IBS_FETCH_ENABLE;\r\nwrmsrl(MSR_AMD64_IBSFETCHCTL, ctl);\r\n}\r\n}\r\nif (ibs_config.op_enabled) {\r\nrdmsrl(MSR_AMD64_IBSOPCTL, ctl);\r\nif (ctl & IBS_OP_VAL) {\r\nrdmsrl(MSR_AMD64_IBSOPRIP, val);\r\noprofile_write_reserve(&entry, regs, val, IBS_OP_CODE,\r\nibs_state.sample_size);\r\noprofile_add_data64(&entry, val);\r\nrdmsrl(MSR_AMD64_IBSOPDATA, val);\r\noprofile_add_data64(&entry, val);\r\nrdmsrl(MSR_AMD64_IBSOPDATA2, val);\r\noprofile_add_data64(&entry, val);\r\nrdmsrl(MSR_AMD64_IBSOPDATA3, val);\r\noprofile_add_data64(&entry, val);\r\nrdmsrl(MSR_AMD64_IBSDCLINAD, val);\r\noprofile_add_data64(&entry, val);\r\nrdmsrl(MSR_AMD64_IBSDCPHYSAD, val);\r\noprofile_add_data64(&entry, val);\r\nif (ibs_state.branch_target) {\r\nrdmsrl(MSR_AMD64_IBSBRTARGET, val);\r\noprofile_add_data(&entry, (unsigned long)val);\r\n}\r\noprofile_write_commit(&entry);\r\nctl = op_amd_randomize_ibs_op(ibs_state.ibs_op_ctl);\r\nwrmsrl(MSR_AMD64_IBSOPCTL, ctl);\r\n}\r\n}\r\n}\r\nstatic inline void op_amd_start_ibs(void)\r\n{\r\nu64 val;\r\nif (!ibs_caps)\r\nreturn;\r\nmemset(&ibs_state, 0, sizeof(ibs_state));\r\nif (ibs_config.fetch_enabled) {\r\nval = ibs_config.max_cnt_fetch >> 4;\r\nval = min(val, IBS_FETCH_MAX_CNT);\r\nibs_config.max_cnt_fetch = val << 4;\r\nval |= ibs_config.rand_en ? IBS_FETCH_RAND_EN : 0;\r\nval |= IBS_FETCH_ENABLE;\r\nwrmsrl(MSR_AMD64_IBSFETCHCTL, val);\r\n}\r\nif (ibs_config.op_enabled) {\r\nval = ibs_config.max_cnt_op >> 4;\r\nif (!(ibs_caps & IBS_CAPS_RDWROPCNT)) {\r\nval = clamp(val, 0x0081ULL, 0xFF80ULL);\r\nibs_config.max_cnt_op = val << 4;\r\n} else {\r\nval += IBS_RANDOM_MAXCNT_OFFSET;\r\nif (ibs_caps & IBS_CAPS_OPCNTEXT)\r\nval = min(val, IBS_OP_MAX_CNT_EXT);\r\nelse\r\nval = min(val, IBS_OP_MAX_CNT);\r\nibs_config.max_cnt_op =\r\n(val - IBS_RANDOM_MAXCNT_OFFSET) << 4;\r\n}\r\nval = ((val & ~IBS_OP_MAX_CNT) << 4) | (val & IBS_OP_MAX_CNT);\r\nval |= ibs_config.dispatched_ops ? IBS_OP_CNT_CTL : 0;\r\nval |= IBS_OP_ENABLE;\r\nibs_state.ibs_op_ctl = val;\r\nibs_state.sample_size = IBS_OP_SIZE;\r\nif (ibs_config.branch_target) {\r\nibs_state.branch_target = 1;\r\nibs_state.sample_size++;\r\n}\r\nval = op_amd_randomize_ibs_op(ibs_state.ibs_op_ctl);\r\nwrmsrl(MSR_AMD64_IBSOPCTL, val);\r\n}\r\n}\r\nstatic void op_amd_stop_ibs(void)\r\n{\r\nif (!ibs_caps)\r\nreturn;\r\nif (ibs_config.fetch_enabled)\r\nwrmsrl(MSR_AMD64_IBSFETCHCTL, 0);\r\nif (ibs_config.op_enabled)\r\nwrmsrl(MSR_AMD64_IBSOPCTL, 0);\r\n}\r\nstatic void op_mux_switch_ctrl(struct op_x86_model_spec const *model,\r\nstruct op_msrs const * const msrs)\r\n{\r\nu64 val;\r\nint i;\r\nfor (i = 0; i < num_counters; ++i) {\r\nint virt = op_x86_phys_to_virt(i);\r\nif (!reset_value[virt])\r\ncontinue;\r\nrdmsrl(msrs->controls[i].addr, val);\r\nval &= model->reserved;\r\nval |= op_x86_get_ctrl(model, &counter_config[virt]);\r\nwrmsrl(msrs->controls[i].addr, val);\r\n}\r\n}\r\nstatic void op_amd_shutdown(struct op_msrs const * const msrs)\r\n{\r\nint i;\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (!msrs->counters[i].addr)\r\ncontinue;\r\nrelease_perfctr_nmi(MSR_K7_PERFCTR0 + i);\r\nrelease_evntsel_nmi(MSR_K7_EVNTSEL0 + i);\r\n}\r\n}\r\nstatic int op_amd_fill_in_addresses(struct op_msrs * const msrs)\r\n{\r\nint i;\r\nfor (i = 0; i < num_counters; i++) {\r\nif (!reserve_perfctr_nmi(MSR_K7_PERFCTR0 + i))\r\ngoto fail;\r\nif (!reserve_evntsel_nmi(MSR_K7_EVNTSEL0 + i)) {\r\nrelease_perfctr_nmi(MSR_K7_PERFCTR0 + i);\r\ngoto fail;\r\n}\r\nif (num_counters == AMD64_NUM_COUNTERS_F15H) {\r\nmsrs->counters[i].addr = MSR_F15H_PERF_CTR + (i << 1);\r\nmsrs->controls[i].addr = MSR_F15H_PERF_CTL + (i << 1);\r\n} else {\r\nmsrs->controls[i].addr = MSR_K7_EVNTSEL0 + i;\r\nmsrs->counters[i].addr = MSR_K7_PERFCTR0 + i;\r\n}\r\ncontinue;\r\nfail:\r\nif (!counter_config[i].enabled)\r\ncontinue;\r\nop_x86_warn_reserved(i);\r\nop_amd_shutdown(msrs);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void op_amd_setup_ctrs(struct op_x86_model_spec const *model,\r\nstruct op_msrs const * const msrs)\r\n{\r\nu64 val;\r\nint i;\r\nfor (i = 0; i < OP_MAX_COUNTER; ++i) {\r\nif (counter_config[i].enabled\r\n&& msrs->counters[op_x86_virt_to_phys(i)].addr)\r\nreset_value[i] = counter_config[i].count;\r\nelse\r\nreset_value[i] = 0;\r\n}\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (!msrs->controls[i].addr)\r\ncontinue;\r\nrdmsrl(msrs->controls[i].addr, val);\r\nif (val & ARCH_PERFMON_EVENTSEL_ENABLE)\r\nop_x86_warn_in_use(i);\r\nval &= model->reserved;\r\nwrmsrl(msrs->controls[i].addr, val);\r\nwrmsrl(msrs->counters[i].addr, -1LL);\r\n}\r\nfor (i = 0; i < num_counters; ++i) {\r\nint virt = op_x86_phys_to_virt(i);\r\nif (!reset_value[virt])\r\ncontinue;\r\nwrmsrl(msrs->counters[i].addr, -(u64)reset_value[virt]);\r\nrdmsrl(msrs->controls[i].addr, val);\r\nval &= model->reserved;\r\nval |= op_x86_get_ctrl(model, &counter_config[virt]);\r\nwrmsrl(msrs->controls[i].addr, val);\r\n}\r\n}\r\nstatic int op_amd_check_ctrs(struct pt_regs * const regs,\r\nstruct op_msrs const * const msrs)\r\n{\r\nu64 val;\r\nint i;\r\nfor (i = 0; i < num_counters; ++i) {\r\nint virt = op_x86_phys_to_virt(i);\r\nif (!reset_value[virt])\r\ncontinue;\r\nrdmsrl(msrs->counters[i].addr, val);\r\nif (val & OP_CTR_OVERFLOW)\r\ncontinue;\r\noprofile_add_sample(regs, virt);\r\nwrmsrl(msrs->counters[i].addr, -(u64)reset_value[virt]);\r\n}\r\nop_amd_handle_ibs(regs, msrs);\r\nreturn 1;\r\n}\r\nstatic void op_amd_start(struct op_msrs const * const msrs)\r\n{\r\nu64 val;\r\nint i;\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (!reset_value[op_x86_phys_to_virt(i)])\r\ncontinue;\r\nrdmsrl(msrs->controls[i].addr, val);\r\nval |= ARCH_PERFMON_EVENTSEL_ENABLE;\r\nwrmsrl(msrs->controls[i].addr, val);\r\n}\r\nop_amd_start_ibs();\r\n}\r\nstatic void op_amd_stop(struct op_msrs const * const msrs)\r\n{\r\nu64 val;\r\nint i;\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (!reset_value[op_x86_phys_to_virt(i)])\r\ncontinue;\r\nrdmsrl(msrs->controls[i].addr, val);\r\nval &= ~ARCH_PERFMON_EVENTSEL_ENABLE;\r\nwrmsrl(msrs->controls[i].addr, val);\r\n}\r\nop_amd_stop_ibs();\r\n}\r\nstatic void init_ibs(void)\r\n{\r\nibs_caps = get_ibs_caps();\r\nif (!ibs_caps)\r\nreturn;\r\nprintk(KERN_INFO "oprofile: AMD IBS detected (0x%08x)\n", ibs_caps);\r\n}\r\nstatic int setup_ibs_files(struct super_block *sb, struct dentry *root)\r\n{\r\nstruct dentry *dir;\r\nint ret = 0;\r\nif (create_arch_files)\r\nret = create_arch_files(sb, root);\r\nif (ret)\r\nreturn ret;\r\nif (!ibs_caps)\r\nreturn ret;\r\nmemset(&ibs_config, 0, sizeof(ibs_config));\r\nibs_config.max_cnt_fetch = 250000;\r\nibs_config.max_cnt_op = 250000;\r\nif (ibs_caps & IBS_CAPS_FETCHSAM) {\r\ndir = oprofilefs_mkdir(sb, root, "ibs_fetch");\r\noprofilefs_create_ulong(sb, dir, "enable",\r\n&ibs_config.fetch_enabled);\r\noprofilefs_create_ulong(sb, dir, "max_count",\r\n&ibs_config.max_cnt_fetch);\r\noprofilefs_create_ulong(sb, dir, "rand_enable",\r\n&ibs_config.rand_en);\r\n}\r\nif (ibs_caps & IBS_CAPS_OPSAM) {\r\ndir = oprofilefs_mkdir(sb, root, "ibs_op");\r\noprofilefs_create_ulong(sb, dir, "enable",\r\n&ibs_config.op_enabled);\r\noprofilefs_create_ulong(sb, dir, "max_count",\r\n&ibs_config.max_cnt_op);\r\nif (ibs_caps & IBS_CAPS_OPCNT)\r\noprofilefs_create_ulong(sb, dir, "dispatched_ops",\r\n&ibs_config.dispatched_ops);\r\nif (ibs_caps & IBS_CAPS_BRNTRGT)\r\noprofilefs_create_ulong(sb, dir, "branch_target",\r\n&ibs_config.branch_target);\r\n}\r\nreturn 0;\r\n}\r\nstatic int op_amd_init(struct oprofile_operations *ops)\r\n{\r\ninit_ibs();\r\ncreate_arch_files = ops->create_files;\r\nops->create_files = setup_ibs_files;\r\nif (boot_cpu_data.x86 == 0x15) {\r\nnum_counters = AMD64_NUM_COUNTERS_F15H;\r\n} else {\r\nnum_counters = AMD64_NUM_COUNTERS;\r\n}\r\nop_amd_spec.num_counters = num_counters;\r\nop_amd_spec.num_controls = num_counters;\r\nop_amd_spec.num_virt_counters = max(num_counters, NUM_VIRT_COUNTERS);\r\nreturn 0;\r\n}
