static char *get_usb_rcmsg(int rc)\r\n{\r\nstatic char unkmsg[28];\r\nswitch (rc) {\r\ncase 0:\r\nreturn "success";\r\ncase -ENOMEM:\r\nreturn "out of memory";\r\ncase -ENODEV:\r\nreturn "device not present";\r\ncase -ENOENT:\r\nreturn "endpoint not present";\r\ncase -ENXIO:\r\nreturn "URB type not supported";\r\ncase -EINVAL:\r\nreturn "invalid argument";\r\ncase -EAGAIN:\r\nreturn "start frame too early or too much scheduled";\r\ncase -EFBIG:\r\nreturn "too many isoc frames requested";\r\ncase -EPIPE:\r\nreturn "endpoint stalled";\r\ncase -EMSGSIZE:\r\nreturn "invalid packet size";\r\ncase -ENOSPC:\r\nreturn "would overcommit USB bandwidth";\r\ncase -ESHUTDOWN:\r\nreturn "device shut down";\r\ncase -EPERM:\r\nreturn "reject flag set";\r\ncase -EHOSTUNREACH:\r\nreturn "device suspended";\r\ndefault:\r\nsnprintf(unkmsg, sizeof(unkmsg), "unknown error %d", rc);\r\nreturn unkmsg;\r\n}\r\n}\r\nstatic char *get_usb_statmsg(int status)\r\n{\r\nstatic char unkmsg[28];\r\nswitch (status) {\r\ncase 0:\r\nreturn "success";\r\ncase -ENOENT:\r\nreturn "unlinked (sync)";\r\ncase -EINPROGRESS:\r\nreturn "URB still pending";\r\ncase -EPROTO:\r\nreturn "bitstuff error, timeout, or unknown USB error";\r\ncase -EILSEQ:\r\nreturn "CRC mismatch, timeout, or unknown USB error";\r\ncase -ETIME:\r\nreturn "USB response timeout";\r\ncase -EPIPE:\r\nreturn "endpoint stalled";\r\ncase -ECOMM:\r\nreturn "IN buffer overrun";\r\ncase -ENOSR:\r\nreturn "OUT buffer underrun";\r\ncase -EOVERFLOW:\r\nreturn "endpoint babble";\r\ncase -EREMOTEIO:\r\nreturn "short packet";\r\ncase -ENODEV:\r\nreturn "device removed";\r\ncase -EXDEV:\r\nreturn "partial isoc transfer";\r\ncase -EINVAL:\r\nreturn "ISO madness";\r\ncase -ECONNRESET:\r\nreturn "unlinked (async)";\r\ncase -ESHUTDOWN:\r\nreturn "device shut down";\r\ndefault:\r\nsnprintf(unkmsg, sizeof(unkmsg), "unknown status %d", status);\r\nreturn unkmsg;\r\n}\r\n}\r\nstatic inline char *usb_pipetype_str(int pipe)\r\n{\r\nif (usb_pipeisoc(pipe))\r\nreturn "Isoc";\r\nif (usb_pipeint(pipe))\r\nreturn "Int";\r\nif (usb_pipecontrol(pipe))\r\nreturn "Ctrl";\r\nif (usb_pipebulk(pipe))\r\nreturn "Bulk";\r\nreturn "?";\r\n}\r\nstatic inline void dump_urb(enum debuglevel level, const char *tag,\r\nstruct urb *urb)\r\n{\r\n#ifdef CONFIG_GIGASET_DEBUG\r\nint i;\r\ngig_dbg(level, "%s urb(0x%08lx)->{", tag, (unsigned long) urb);\r\nif (urb) {\r\ngig_dbg(level,\r\n" dev=0x%08lx, pipe=%s:EP%d/DV%d:%s, "\r\n"hcpriv=0x%08lx, transfer_flags=0x%x,",\r\n(unsigned long) urb->dev,\r\nusb_pipetype_str(urb->pipe),\r\nusb_pipeendpoint(urb->pipe), usb_pipedevice(urb->pipe),\r\nusb_pipein(urb->pipe) ? "in" : "out",\r\n(unsigned long) urb->hcpriv,\r\nurb->transfer_flags);\r\ngig_dbg(level,\r\n" transfer_buffer=0x%08lx[%d], actual_length=%d, "\r\n"setup_packet=0x%08lx,",\r\n(unsigned long) urb->transfer_buffer,\r\nurb->transfer_buffer_length, urb->actual_length,\r\n(unsigned long) urb->setup_packet);\r\ngig_dbg(level,\r\n" start_frame=%d, number_of_packets=%d, interval=%d, "\r\n"error_count=%d,",\r\nurb->start_frame, urb->number_of_packets, urb->interval,\r\nurb->error_count);\r\ngig_dbg(level,\r\n" context=0x%08lx, complete=0x%08lx, "\r\n"iso_frame_desc[]={",\r\n(unsigned long) urb->context,\r\n(unsigned long) urb->complete);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nstruct usb_iso_packet_descriptor *pifd\r\n= &urb->iso_frame_desc[i];\r\ngig_dbg(level,\r\n" {offset=%u, length=%u, actual_length=%u, "\r\n"status=%u}",\r\npifd->offset, pifd->length, pifd->actual_length,\r\npifd->status);\r\n}\r\n}\r\ngig_dbg(level, "}}");\r\n#endif\r\n}\r\nstatic int gigaset_set_modem_ctrl(struct cardstate *cs, unsigned old_state,\r\nunsigned new_state)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int gigaset_baud_rate(struct cardstate *cs, unsigned cflag)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int gigaset_set_line_ctrl(struct cardstate *cs, unsigned cflag)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic inline int update_basstate(struct bas_cardstate *ucs,\r\nint set, int clear)\r\n{\r\nunsigned long flags;\r\nint state;\r\nspin_lock_irqsave(&ucs->lock, flags);\r\nstate = ucs->basstate;\r\nucs->basstate = (state & ~clear) | set;\r\nspin_unlock_irqrestore(&ucs->lock, flags);\r\nreturn state;\r\n}\r\nstatic inline void error_hangup(struct bc_state *bcs)\r\n{\r\nstruct cardstate *cs = bcs->cs;\r\ngigaset_add_event(cs, &bcs->at_state, EV_HUP, NULL, 0, NULL);\r\ngigaset_schedule_event(cs);\r\n}\r\nstatic inline void error_reset(struct cardstate *cs)\r\n{\r\nupdate_basstate(cs->hw.bas, BS_RESETTING, 0);\r\nif (req_submit(cs->bcs, HD_RESET_INTERRUPT_PIPE, 0, BAS_TIMEOUT))\r\nusb_queue_reset_device(cs->hw.bas->interface);\r\n}\r\nstatic void check_pending(struct bas_cardstate *ucs)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ucs->lock, flags);\r\nswitch (ucs->pending) {\r\ncase 0:\r\nbreak;\r\ncase HD_OPEN_ATCHANNEL:\r\nif (ucs->basstate & BS_ATOPEN)\r\nucs->pending = 0;\r\nbreak;\r\ncase HD_OPEN_B1CHANNEL:\r\nif (ucs->basstate & BS_B1OPEN)\r\nucs->pending = 0;\r\nbreak;\r\ncase HD_OPEN_B2CHANNEL:\r\nif (ucs->basstate & BS_B2OPEN)\r\nucs->pending = 0;\r\nbreak;\r\ncase HD_CLOSE_ATCHANNEL:\r\nif (!(ucs->basstate & BS_ATOPEN))\r\nucs->pending = 0;\r\nbreak;\r\ncase HD_CLOSE_B1CHANNEL:\r\nif (!(ucs->basstate & BS_B1OPEN))\r\nucs->pending = 0;\r\nbreak;\r\ncase HD_CLOSE_B2CHANNEL:\r\nif (!(ucs->basstate & BS_B2OPEN))\r\nucs->pending = 0;\r\nbreak;\r\ncase HD_DEVICE_INIT_ACK:\r\nucs->pending = 0;\r\nbreak;\r\ncase HD_RESET_INTERRUPT_PIPE:\r\nif (!(ucs->basstate & BS_RESETTING))\r\nucs->pending = 0;\r\nbreak;\r\ndefault:\r\ndev_warn(&ucs->interface->dev,\r\n"unknown pending request 0x%02x cleared\n",\r\nucs->pending);\r\nucs->pending = 0;\r\n}\r\nif (!ucs->pending)\r\ndel_timer(&ucs->timer_ctrl);\r\nspin_unlock_irqrestore(&ucs->lock, flags);\r\n}\r\nstatic void cmd_in_timeout(unsigned long data)\r\n{\r\nstruct cardstate *cs = (struct cardstate *) data;\r\nstruct bas_cardstate *ucs = cs->hw.bas;\r\nint rc;\r\nif (!ucs->rcvbuf_size) {\r\ngig_dbg(DEBUG_USBREQ, "%s: no receive in progress", __func__);\r\nreturn;\r\n}\r\nif (ucs->retry_cmd_in++ >= BAS_RETRY) {\r\ndev_err(cs->dev,\r\n"control read: timeout, giving up after %d tries\n",\r\nucs->retry_cmd_in);\r\nkfree(ucs->rcvbuf);\r\nucs->rcvbuf = NULL;\r\nucs->rcvbuf_size = 0;\r\nerror_reset(cs);\r\nreturn;\r\n}\r\ngig_dbg(DEBUG_USBREQ, "%s: timeout, retry %d",\r\n__func__, ucs->retry_cmd_in);\r\nrc = atread_submit(cs, BAS_TIMEOUT);\r\nif (rc < 0) {\r\nkfree(ucs->rcvbuf);\r\nucs->rcvbuf = NULL;\r\nucs->rcvbuf_size = 0;\r\nif (rc != -ENODEV)\r\nerror_reset(cs);\r\n}\r\n}\r\nstatic void read_ctrl_callback(struct urb *urb)\r\n{\r\nstruct inbuf_t *inbuf = urb->context;\r\nstruct cardstate *cs = inbuf->cs;\r\nstruct bas_cardstate *ucs = cs->hw.bas;\r\nint status = urb->status;\r\nunsigned numbytes;\r\nint rc;\r\nupdate_basstate(ucs, 0, BS_ATRDPEND);\r\nwake_up(&ucs->waitqueue);\r\ndel_timer(&ucs->timer_cmd_in);\r\nswitch (status) {\r\ncase 0:\r\nnumbytes = urb->actual_length;\r\nif (unlikely(numbytes != ucs->rcvbuf_size)) {\r\ndev_warn(cs->dev,\r\n"control read: received %d chars, expected %d\n",\r\nnumbytes, ucs->rcvbuf_size);\r\nif (numbytes > ucs->rcvbuf_size)\r\nnumbytes = ucs->rcvbuf_size;\r\n}\r\nif (gigaset_fill_inbuf(inbuf, ucs->rcvbuf, numbytes)) {\r\ngig_dbg(DEBUG_INTR, "%s-->BH", __func__);\r\ngigaset_schedule_event(cs);\r\n}\r\nbreak;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -EINPROGRESS:\r\ncase -ENODEV:\r\ncase -ESHUTDOWN:\r\ngig_dbg(DEBUG_USBREQ, "%s: %s",\r\n__func__, get_usb_statmsg(status));\r\nbreak;\r\ndefault:\r\nif (ucs->retry_cmd_in++ < BAS_RETRY) {\r\ngig_dbg(DEBUG_USBREQ, "%s: %s, retry %d", __func__,\r\nget_usb_statmsg(status), ucs->retry_cmd_in);\r\nrc = atread_submit(cs, BAS_TIMEOUT);\r\nif (rc >= 0)\r\nreturn;\r\nif (rc == -ENODEV)\r\nbreak;\r\n}\r\ndev_err(cs->dev, "control read: %s, giving up after %d tries\n",\r\nget_usb_statmsg(status), ucs->retry_cmd_in);\r\nerror_reset(cs);\r\n}\r\nkfree(ucs->rcvbuf);\r\nucs->rcvbuf = NULL;\r\nucs->rcvbuf_size = 0;\r\n}\r\nstatic int atread_submit(struct cardstate *cs, int timeout)\r\n{\r\nstruct bas_cardstate *ucs = cs->hw.bas;\r\nint basstate;\r\nint ret;\r\ngig_dbg(DEBUG_USBREQ, "-------> HD_READ_ATMESSAGE (%d)",\r\nucs->rcvbuf_size);\r\nbasstate = update_basstate(ucs, BS_ATRDPEND, 0);\r\nif (basstate & BS_ATRDPEND) {\r\ndev_err(cs->dev,\r\n"could not submit HD_READ_ATMESSAGE: URB busy\n");\r\nreturn -EBUSY;\r\n}\r\nif (basstate & BS_SUSPEND) {\r\ndev_notice(cs->dev,\r\n"HD_READ_ATMESSAGE not submitted, "\r\n"suspend in progress\n");\r\nupdate_basstate(ucs, 0, BS_ATRDPEND);\r\nreturn -ENODEV;\r\n}\r\nucs->dr_cmd_in.bRequestType = IN_VENDOR_REQ;\r\nucs->dr_cmd_in.bRequest = HD_READ_ATMESSAGE;\r\nucs->dr_cmd_in.wValue = 0;\r\nucs->dr_cmd_in.wIndex = 0;\r\nucs->dr_cmd_in.wLength = cpu_to_le16(ucs->rcvbuf_size);\r\nusb_fill_control_urb(ucs->urb_cmd_in, ucs->udev,\r\nusb_rcvctrlpipe(ucs->udev, 0),\r\n(unsigned char *) &ucs->dr_cmd_in,\r\nucs->rcvbuf, ucs->rcvbuf_size,\r\nread_ctrl_callback, cs->inbuf);\r\nret = usb_submit_urb(ucs->urb_cmd_in, GFP_ATOMIC);\r\nif (ret != 0) {\r\nupdate_basstate(ucs, 0, BS_ATRDPEND);\r\ndev_err(cs->dev, "could not submit HD_READ_ATMESSAGE: %s\n",\r\nget_usb_rcmsg(ret));\r\nreturn ret;\r\n}\r\nif (timeout > 0) {\r\ngig_dbg(DEBUG_USBREQ, "setting timeout of %d/10 secs", timeout);\r\nmod_timer(&ucs->timer_cmd_in, jiffies + timeout * HZ / 10);\r\n}\r\nreturn 0;\r\n}\r\nstatic void int_in_work(struct work_struct *work)\r\n{\r\nstruct bas_cardstate *ucs =\r\ncontainer_of(work, struct bas_cardstate, int_in_wq);\r\nstruct urb *urb = ucs->urb_int_in;\r\nstruct cardstate *cs = urb->context;\r\nint rc;\r\nrc = usb_clear_halt(ucs->udev, urb->pipe);\r\ngig_dbg(DEBUG_USBREQ, "clear_halt: %s", get_usb_rcmsg(rc));\r\nif (rc == 0)\r\nrc = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (rc != 0 && rc != -ENODEV) {\r\ndev_err(cs->dev, "clear halt failed: %s\n", get_usb_rcmsg(rc));\r\nrc = usb_lock_device_for_reset(ucs->udev, ucs->interface);\r\nif (rc == 0) {\r\nrc = usb_reset_device(ucs->udev);\r\nusb_unlock_device(ucs->udev);\r\n}\r\n}\r\nucs->retry_int_in = 0;\r\n}\r\nstatic void int_in_resubmit(unsigned long data)\r\n{\r\nstruct cardstate *cs = (struct cardstate *) data;\r\nstruct bas_cardstate *ucs = cs->hw.bas;\r\nint rc;\r\nif (ucs->retry_int_in++ >= BAS_RETRY) {\r\ndev_err(cs->dev, "interrupt read: giving up after %d tries\n",\r\nucs->retry_int_in);\r\nusb_queue_reset_device(ucs->interface);\r\nreturn;\r\n}\r\ngig_dbg(DEBUG_USBREQ, "%s: retry %d", __func__, ucs->retry_int_in);\r\nrc = usb_submit_urb(ucs->urb_int_in, GFP_ATOMIC);\r\nif (rc != 0 && rc != -ENODEV) {\r\ndev_err(cs->dev, "could not resubmit interrupt URB: %s\n",\r\nget_usb_rcmsg(rc));\r\nusb_queue_reset_device(ucs->interface);\r\n}\r\n}\r\nstatic void read_int_callback(struct urb *urb)\r\n{\r\nstruct cardstate *cs = urb->context;\r\nstruct bas_cardstate *ucs = cs->hw.bas;\r\nstruct bc_state *bcs;\r\nint status = urb->status;\r\nunsigned long flags;\r\nint rc;\r\nunsigned l;\r\nint channel;\r\nswitch (status) {\r\ncase 0:\r\nucs->retry_int_in = 0;\r\nbreak;\r\ncase -EPIPE:\r\nschedule_work(&ucs->int_in_wq);\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -EINPROGRESS:\r\ncase -ENODEV:\r\ncase -ESHUTDOWN:\r\ngig_dbg(DEBUG_USBREQ, "%s: %s",\r\n__func__, get_usb_statmsg(status));\r\nreturn;\r\ncase -EPROTO:\r\ncase -EILSEQ:\r\ncase -ETIME:\r\ngig_dbg(DEBUG_USBREQ, "%s: %s",\r\n__func__, get_usb_statmsg(status));\r\nmod_timer(&ucs->timer_int_in, jiffies + HZ / 10);\r\nreturn;\r\ndefault:\r\ndev_warn(cs->dev, "interrupt read: %s\n",\r\nget_usb_statmsg(status));\r\ngoto resubmit;\r\n}\r\nif (unlikely(urb->actual_length < IP_MSGSIZE)) {\r\ndev_warn(cs->dev, "incomplete interrupt packet (%d bytes)\n",\r\nurb->actual_length);\r\ngoto resubmit;\r\n}\r\nl = (unsigned) ucs->int_in_buf[1] +\r\n(((unsigned) ucs->int_in_buf[2]) << 8);\r\ngig_dbg(DEBUG_USBREQ, "<-------%d: 0x%02x (%u [0x%02x 0x%02x])",\r\nurb->actual_length, (int)ucs->int_in_buf[0], l,\r\n(int)ucs->int_in_buf[1], (int)ucs->int_in_buf[2]);\r\nchannel = 0;\r\nswitch (ucs->int_in_buf[0]) {\r\ncase HD_DEVICE_INIT_OK:\r\nupdate_basstate(ucs, BS_INIT, 0);\r\nbreak;\r\ncase HD_READY_SEND_ATDATA:\r\ndel_timer(&ucs->timer_atrdy);\r\nupdate_basstate(ucs, BS_ATREADY, BS_ATTIMER);\r\nstart_cbsend(cs);\r\nbreak;\r\ncase HD_OPEN_B2CHANNEL_ACK:\r\n++channel;\r\ncase HD_OPEN_B1CHANNEL_ACK:\r\nbcs = cs->bcs + channel;\r\nupdate_basstate(ucs, BS_B1OPEN << channel, 0);\r\ngigaset_bchannel_up(bcs);\r\nbreak;\r\ncase HD_OPEN_ATCHANNEL_ACK:\r\nupdate_basstate(ucs, BS_ATOPEN, 0);\r\nstart_cbsend(cs);\r\nbreak;\r\ncase HD_CLOSE_B2CHANNEL_ACK:\r\n++channel;\r\ncase HD_CLOSE_B1CHANNEL_ACK:\r\nbcs = cs->bcs + channel;\r\nupdate_basstate(ucs, 0, BS_B1OPEN << channel);\r\nstopurbs(bcs->hw.bas);\r\ngigaset_bchannel_down(bcs);\r\nbreak;\r\ncase HD_CLOSE_ATCHANNEL_ACK:\r\nupdate_basstate(ucs, 0, BS_ATOPEN);\r\nbreak;\r\ncase HD_B2_FLOW_CONTROL:\r\n++channel;\r\ncase HD_B1_FLOW_CONTROL:\r\nbcs = cs->bcs + channel;\r\natomic_add((l - BAS_NORMFRAME) * BAS_CORRFRAMES,\r\n&bcs->hw.bas->corrbytes);\r\ngig_dbg(DEBUG_ISO,\r\n"Flow control (channel %d, sub %d): 0x%02x => %d",\r\nchannel, bcs->hw.bas->numsub, l,\r\natomic_read(&bcs->hw.bas->corrbytes));\r\nbreak;\r\ncase HD_RECEIVEATDATA_ACK:\r\nif (!l) {\r\ndev_warn(cs->dev,\r\n"HD_RECEIVEATDATA_ACK with length 0 ignored\n");\r\nbreak;\r\n}\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (ucs->basstate & BS_ATRDPEND) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ndev_warn(cs->dev,\r\n"HD_RECEIVEATDATA_ACK(%d) during HD_READ_ATMESSAGE(%d) ignored\n",\r\nl, ucs->rcvbuf_size);\r\nbreak;\r\n}\r\nif (ucs->rcvbuf_size) {\r\ndev_err(cs->dev,\r\n"receive AT data overrun, %d bytes lost\n",\r\nucs->rcvbuf_size);\r\nkfree(ucs->rcvbuf);\r\nucs->rcvbuf_size = 0;\r\n}\r\nucs->rcvbuf = kmalloc(l, GFP_ATOMIC);\r\nif (ucs->rcvbuf == NULL) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ndev_err(cs->dev, "out of memory receiving AT data\n");\r\nbreak;\r\n}\r\nucs->rcvbuf_size = l;\r\nucs->retry_cmd_in = 0;\r\nrc = atread_submit(cs, BAS_TIMEOUT);\r\nif (rc < 0) {\r\nkfree(ucs->rcvbuf);\r\nucs->rcvbuf = NULL;\r\nucs->rcvbuf_size = 0;\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nif (rc < 0 && rc != -ENODEV)\r\nerror_reset(cs);\r\nbreak;\r\ncase HD_RESET_INTERRUPT_PIPE_ACK:\r\nupdate_basstate(ucs, 0, BS_RESETTING);\r\ndev_notice(cs->dev, "interrupt pipe reset\n");\r\nbreak;\r\ncase HD_SUSPEND_END:\r\ngig_dbg(DEBUG_USBREQ, "HD_SUSPEND_END");\r\nbreak;\r\ndefault:\r\ndev_warn(cs->dev,\r\n"unknown Gigaset signal 0x%02x (%u) ignored\n",\r\n(int) ucs->int_in_buf[0], l);\r\n}\r\ncheck_pending(ucs);\r\nwake_up(&ucs->waitqueue);\r\nresubmit:\r\nrc = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (unlikely(rc != 0 && rc != -ENODEV)) {\r\ndev_err(cs->dev, "could not resubmit interrupt URB: %s\n",\r\nget_usb_rcmsg(rc));\r\nerror_reset(cs);\r\n}\r\n}\r\nstatic void read_iso_callback(struct urb *urb)\r\n{\r\nstruct bc_state *bcs;\r\nstruct bas_bc_state *ubc;\r\nint status = urb->status;\r\nunsigned long flags;\r\nint i, rc;\r\nif (unlikely(status == -ENOENT ||\r\nstatus == -ECONNRESET ||\r\nstatus == -EINPROGRESS ||\r\nstatus == -ENODEV ||\r\nstatus == -ESHUTDOWN)) {\r\ngig_dbg(DEBUG_ISO, "%s: %s",\r\n__func__, get_usb_statmsg(status));\r\nreturn;\r\n}\r\nbcs = urb->context;\r\nubc = bcs->hw.bas;\r\nspin_lock_irqsave(&ubc->isoinlock, flags);\r\nif (likely(ubc->isoindone == NULL)) {\r\nubc->isoindone = urb;\r\nubc->isoinstatus = status;\r\ntasklet_hi_schedule(&ubc->rcvd_tasklet);\r\n} else {\r\ngig_dbg(DEBUG_ISO, "%s: overrun", __func__);\r\nubc->loststatus = status;\r\nfor (i = 0; i < BAS_NUMFRAMES; i++) {\r\nubc->isoinlost += urb->iso_frame_desc[i].actual_length;\r\nif (unlikely(urb->iso_frame_desc[i].status != 0 &&\r\nurb->iso_frame_desc[i].status !=\r\n-EINPROGRESS))\r\nubc->loststatus = urb->iso_frame_desc[i].status;\r\nurb->iso_frame_desc[i].status = 0;\r\nurb->iso_frame_desc[i].actual_length = 0;\r\n}\r\nif (likely(ubc->running)) {\r\nurb->dev = bcs->cs->hw.bas->udev;\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->number_of_packets = BAS_NUMFRAMES;\r\nrc = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (unlikely(rc != 0 && rc != -ENODEV)) {\r\ndev_err(bcs->cs->dev,\r\n"could not resubmit isoc read URB: %s\n",\r\nget_usb_rcmsg(rc));\r\ndump_urb(DEBUG_ISO, "isoc read", urb);\r\nerror_hangup(bcs);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&ubc->isoinlock, flags);\r\n}\r\nstatic void write_iso_callback(struct urb *urb)\r\n{\r\nstruct isow_urbctx_t *ucx;\r\nstruct bas_bc_state *ubc;\r\nint status = urb->status;\r\nunsigned long flags;\r\nif (unlikely(status == -ENOENT ||\r\nstatus == -ECONNRESET ||\r\nstatus == -EINPROGRESS ||\r\nstatus == -ENODEV ||\r\nstatus == -ESHUTDOWN)) {\r\ngig_dbg(DEBUG_ISO, "%s: %s",\r\n__func__, get_usb_statmsg(status));\r\nreturn;\r\n}\r\nucx = urb->context;\r\nubc = ucx->bcs->hw.bas;\r\nucx->status = status;\r\nspin_lock_irqsave(&ubc->isooutlock, flags);\r\nubc->isooutovfl = ubc->isooutdone;\r\nubc->isooutdone = ucx;\r\nspin_unlock_irqrestore(&ubc->isooutlock, flags);\r\ntasklet_hi_schedule(&ubc->sent_tasklet);\r\n}\r\nstatic int starturbs(struct bc_state *bcs)\r\n{\r\nstruct bas_bc_state *ubc = bcs->hw.bas;\r\nstruct urb *urb;\r\nint j, k;\r\nint rc;\r\nif (bcs->proto2 == L2_HDLC)\r\nbcs->inputstate |= INS_flag_hunt;\r\nubc->running = 1;\r\nfor (k = 0; k < BAS_INURBS; k++) {\r\nurb = ubc->isoinurbs[k];\r\nif (!urb) {\r\nrc = -EFAULT;\r\ngoto error;\r\n}\r\nurb->dev = bcs->cs->hw.bas->udev;\r\nurb->pipe = usb_rcvisocpipe(urb->dev, 3 + 2 * bcs->channel);\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->transfer_buffer = ubc->isoinbuf + k * BAS_INBUFSIZE;\r\nurb->transfer_buffer_length = BAS_INBUFSIZE;\r\nurb->number_of_packets = BAS_NUMFRAMES;\r\nurb->interval = BAS_FRAMETIME;\r\nurb->complete = read_iso_callback;\r\nurb->context = bcs;\r\nfor (j = 0; j < BAS_NUMFRAMES; j++) {\r\nurb->iso_frame_desc[j].offset = j * BAS_MAXFRAME;\r\nurb->iso_frame_desc[j].length = BAS_MAXFRAME;\r\nurb->iso_frame_desc[j].status = 0;\r\nurb->iso_frame_desc[j].actual_length = 0;\r\n}\r\ndump_urb(DEBUG_ISO, "Initial isoc read", urb);\r\nrc = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (rc != 0)\r\ngoto error;\r\n}\r\ngigaset_isowbuf_init(ubc->isooutbuf, PPP_FLAG);\r\nfor (k = 0; k < BAS_OUTURBS; ++k) {\r\nurb = ubc->isoouturbs[k].urb;\r\nif (!urb) {\r\nrc = -EFAULT;\r\ngoto error;\r\n}\r\nurb->dev = bcs->cs->hw.bas->udev;\r\nurb->pipe = usb_sndisocpipe(urb->dev, 4 + 2 * bcs->channel);\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->transfer_buffer = ubc->isooutbuf->data;\r\nurb->transfer_buffer_length = sizeof(ubc->isooutbuf->data);\r\nurb->number_of_packets = BAS_NUMFRAMES;\r\nurb->interval = BAS_FRAMETIME;\r\nurb->complete = write_iso_callback;\r\nurb->context = &ubc->isoouturbs[k];\r\nfor (j = 0; j < BAS_NUMFRAMES; ++j) {\r\nurb->iso_frame_desc[j].offset = BAS_OUTBUFSIZE;\r\nurb->iso_frame_desc[j].length = BAS_NORMFRAME;\r\nurb->iso_frame_desc[j].status = 0;\r\nurb->iso_frame_desc[j].actual_length = 0;\r\n}\r\nubc->isoouturbs[k].limit = -1;\r\n}\r\nfor (k = 0; k < BAS_OUTURBS-1; ++k) {\r\ndump_urb(DEBUG_ISO, "Initial isoc write", urb);\r\nrc = usb_submit_urb(ubc->isoouturbs[k].urb, GFP_ATOMIC);\r\nif (rc != 0)\r\ngoto error;\r\n}\r\ndump_urb(DEBUG_ISO, "Initial isoc write (free)", urb);\r\nubc->isooutfree = &ubc->isoouturbs[BAS_OUTURBS-1];\r\nubc->isooutdone = ubc->isooutovfl = NULL;\r\nreturn 0;\r\nerror:\r\nstopurbs(ubc);\r\nreturn rc;\r\n}\r\nstatic void stopurbs(struct bas_bc_state *ubc)\r\n{\r\nint k, rc;\r\nubc->running = 0;\r\nfor (k = 0; k < BAS_INURBS; ++k) {\r\nrc = usb_unlink_urb(ubc->isoinurbs[k]);\r\ngig_dbg(DEBUG_ISO,\r\n"%s: isoc input URB %d unlinked, result = %s",\r\n__func__, k, get_usb_rcmsg(rc));\r\n}\r\nfor (k = 0; k < BAS_OUTURBS; ++k) {\r\nrc = usb_unlink_urb(ubc->isoouturbs[k].urb);\r\ngig_dbg(DEBUG_ISO,\r\n"%s: isoc output URB %d unlinked, result = %s",\r\n__func__, k, get_usb_rcmsg(rc));\r\n}\r\n}\r\nstatic int submit_iso_write_urb(struct isow_urbctx_t *ucx)\r\n{\r\nstruct urb *urb = ucx->urb;\r\nstruct bas_bc_state *ubc = ucx->bcs->hw.bas;\r\nstruct usb_iso_packet_descriptor *ifd;\r\nint corrbytes, nframe, rc;\r\nurb->dev = ucx->bcs->cs->hw.bas->udev;\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->transfer_buffer = ubc->isooutbuf->data;\r\nurb->transfer_buffer_length = sizeof(ubc->isooutbuf->data);\r\nfor (nframe = 0; nframe < BAS_NUMFRAMES; nframe++) {\r\nifd = &urb->iso_frame_desc[nframe];\r\nifd->length = BAS_NORMFRAME;\r\ncorrbytes = atomic_read(&ubc->corrbytes);\r\nif (corrbytes != 0) {\r\ngig_dbg(DEBUG_ISO, "%s: corrbytes=%d",\r\n__func__, corrbytes);\r\nif (corrbytes > BAS_HIGHFRAME - BAS_NORMFRAME)\r\ncorrbytes = BAS_HIGHFRAME - BAS_NORMFRAME;\r\nelse if (corrbytes < BAS_LOWFRAME - BAS_NORMFRAME)\r\ncorrbytes = BAS_LOWFRAME - BAS_NORMFRAME;\r\nifd->length += corrbytes;\r\natomic_add(-corrbytes, &ubc->corrbytes);\r\n}\r\nrc = gigaset_isowbuf_getbytes(ubc->isooutbuf, ifd->length);\r\nif (rc < 0) {\r\nif (rc == -EBUSY) {\r\ngig_dbg(DEBUG_ISO,\r\n"%s: buffer busy at frame %d",\r\n__func__, nframe);\r\n} else {\r\ndev_err(ucx->bcs->cs->dev,\r\n"%s: buffer error %d at frame %d\n",\r\n__func__, rc, nframe);\r\nreturn rc;\r\n}\r\nbreak;\r\n}\r\nifd->offset = rc;\r\nucx->limit = ubc->isooutbuf->nextread;\r\nifd->status = 0;\r\nifd->actual_length = 0;\r\n}\r\nif (unlikely(nframe == 0))\r\nreturn 0;\r\nurb->number_of_packets = nframe;\r\nrc = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (unlikely(rc)) {\r\nif (rc == -ENODEV)\r\ngig_dbg(DEBUG_ISO, "%s: disconnected", __func__);\r\nelse\r\ndev_err(ucx->bcs->cs->dev,\r\n"could not submit isoc write URB: %s\n",\r\nget_usb_rcmsg(rc));\r\nreturn rc;\r\n}\r\n++ubc->numsub;\r\nreturn nframe;\r\n}\r\nstatic void write_iso_tasklet(unsigned long data)\r\n{\r\nstruct bc_state *bcs = (struct bc_state *) data;\r\nstruct bas_bc_state *ubc = bcs->hw.bas;\r\nstruct cardstate *cs = bcs->cs;\r\nstruct isow_urbctx_t *done, *next, *ovfl;\r\nstruct urb *urb;\r\nint status;\r\nstruct usb_iso_packet_descriptor *ifd;\r\nunsigned long flags;\r\nint i;\r\nstruct sk_buff *skb;\r\nint len;\r\nint rc;\r\nfor (;;) {\r\nif (unlikely(!(ubc->running))) {\r\ngig_dbg(DEBUG_ISO, "%s: not running", __func__);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&ubc->isooutlock, flags);\r\ndone = ubc->isooutdone;\r\nubc->isooutdone = NULL;\r\novfl = ubc->isooutovfl;\r\nubc->isooutovfl = NULL;\r\nspin_unlock_irqrestore(&ubc->isooutlock, flags);\r\nif (ovfl) {\r\ndev_err(cs->dev, "isoc write underrun\n");\r\nerror_hangup(bcs);\r\nbreak;\r\n}\r\nif (!done)\r\nbreak;\r\nspin_lock_irqsave(&ubc->isooutlock, flags);\r\nnext = ubc->isooutfree;\r\nubc->isooutfree = NULL;\r\nspin_unlock_irqrestore(&ubc->isooutlock, flags);\r\nif (next) {\r\nrc = submit_iso_write_urb(next);\r\nif (unlikely(rc <= 0 && rc != -ENODEV)) {\r\nspin_lock_irqsave(&ubc->isooutlock, flags);\r\nif (ubc->isooutfree == NULL) {\r\nubc->isooutfree = next;\r\nnext = NULL;\r\n}\r\nspin_unlock_irqrestore(&ubc->isooutlock, flags);\r\nif (next) {\r\ndev_err(cs->dev,\r\n"losing isoc write URB\n");\r\nerror_hangup(bcs);\r\n}\r\n}\r\n}\r\nurb = done->urb;\r\nstatus = done->status;\r\nswitch (status) {\r\ncase -EXDEV:\r\ngig_dbg(DEBUG_ISO, "%s: URB partially completed",\r\n__func__);\r\ncase 0:\r\nfor (i = 0; i < BAS_NUMFRAMES; i++) {\r\nifd = &urb->iso_frame_desc[i];\r\nif (ifd->status ||\r\nifd->actual_length != ifd->length) {\r\ndev_warn(cs->dev,\r\n"isoc write: frame %d[%d/%d]: %s\n",\r\ni, ifd->actual_length,\r\nifd->length,\r\nget_usb_statmsg(ifd->status));\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase -EPIPE:\r\ndev_err(cs->dev, "isoc write: stalled\n");\r\nerror_hangup(bcs);\r\nbreak;\r\ndefault:\r\ndev_warn(cs->dev, "isoc write: %s\n",\r\nget_usb_statmsg(status));\r\n}\r\nif (done->limit >= 0)\r\nubc->isooutbuf->read = done->limit;\r\nspin_lock_irqsave(&ubc->isooutlock, flags);\r\nnext = ubc->isooutfree;\r\nubc->isooutfree = done;\r\nspin_unlock_irqrestore(&ubc->isooutlock, flags);\r\nif (next) {\r\nrc = submit_iso_write_urb(next);\r\nif (unlikely(rc <= 0 && rc != -ENODEV)) {\r\nerror_hangup(bcs);\r\n}\r\n}\r\n}\r\nwhile ((skb = skb_dequeue(&bcs->squeue))) {\r\nlen = skb->len;\r\nif (gigaset_isoc_buildframe(bcs, skb->data, len) == -EAGAIN) {\r\nskb_queue_head(&bcs->squeue, skb);\r\ngig_dbg(DEBUG_ISO, "%s: skb requeued, qlen=%d",\r\n__func__, skb_queue_len(&bcs->squeue));\r\nbreak;\r\n}\r\nskb_pull(skb, len);\r\ngigaset_skb_sent(bcs, skb);\r\ndev_kfree_skb_any(skb);\r\n}\r\n}\r\nstatic void read_iso_tasklet(unsigned long data)\r\n{\r\nstruct bc_state *bcs = (struct bc_state *) data;\r\nstruct bas_bc_state *ubc = bcs->hw.bas;\r\nstruct cardstate *cs = bcs->cs;\r\nstruct urb *urb;\r\nint status;\r\nstruct usb_iso_packet_descriptor *ifd;\r\nchar *rcvbuf;\r\nunsigned long flags;\r\nint totleft, numbytes, offset, frame, rc;\r\nfor (;;) {\r\nspin_lock_irqsave(&ubc->isoinlock, flags);\r\nurb = ubc->isoindone;\r\nif (!urb) {\r\nspin_unlock_irqrestore(&ubc->isoinlock, flags);\r\nreturn;\r\n}\r\nstatus = ubc->isoinstatus;\r\nubc->isoindone = NULL;\r\nif (unlikely(ubc->loststatus != -EINPROGRESS)) {\r\ndev_warn(cs->dev,\r\n"isoc read overrun, URB dropped (status: %s, %d bytes)\n",\r\nget_usb_statmsg(ubc->loststatus),\r\nubc->isoinlost);\r\nubc->loststatus = -EINPROGRESS;\r\n}\r\nspin_unlock_irqrestore(&ubc->isoinlock, flags);\r\nif (unlikely(!(ubc->running))) {\r\ngig_dbg(DEBUG_ISO,\r\n"%s: channel not running, "\r\n"dropped URB with status: %s",\r\n__func__, get_usb_statmsg(status));\r\nreturn;\r\n}\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -EXDEV:\r\ngig_dbg(DEBUG_ISO, "%s: URB partially completed",\r\n__func__);\r\nbreak;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -EINPROGRESS:\r\ngig_dbg(DEBUG_ISO, "%s: %s",\r\n__func__, get_usb_statmsg(status));\r\ncontinue;\r\ncase -EPIPE:\r\ndev_err(cs->dev, "isoc read: stalled\n");\r\nerror_hangup(bcs);\r\ncontinue;\r\ndefault:\r\ndev_warn(cs->dev, "isoc read: %s\n",\r\nget_usb_statmsg(status));\r\ngoto error;\r\n}\r\nrcvbuf = urb->transfer_buffer;\r\ntotleft = urb->actual_length;\r\nfor (frame = 0; totleft > 0 && frame < BAS_NUMFRAMES; frame++) {\r\nifd = &urb->iso_frame_desc[frame];\r\nnumbytes = ifd->actual_length;\r\nswitch (ifd->status) {\r\ncase 0:\r\nbreak;\r\ncase -EPROTO:\r\ncase -EILSEQ:\r\ncase -ETIME:\r\ngig_dbg(DEBUG_ISO,\r\n"isoc read: frame %d[%d]: %s\n",\r\nframe, numbytes,\r\nget_usb_statmsg(ifd->status));\r\nbreak;\r\ndefault:\r\ndev_warn(cs->dev,\r\n"isoc read: frame %d[%d]: %s\n",\r\nframe, numbytes,\r\nget_usb_statmsg(ifd->status));\r\n}\r\nif (unlikely(numbytes > BAS_MAXFRAME))\r\ndev_warn(cs->dev,\r\n"isoc read: frame %d[%d]: %s\n",\r\nframe, numbytes,\r\n"exceeds max frame size");\r\nif (unlikely(numbytes > totleft)) {\r\ndev_warn(cs->dev,\r\n"isoc read: frame %d[%d]: %s\n",\r\nframe, numbytes,\r\n"exceeds total transfer length");\r\nnumbytes = totleft;\r\n}\r\noffset = ifd->offset;\r\nif (unlikely(offset + numbytes > BAS_INBUFSIZE)) {\r\ndev_warn(cs->dev,\r\n"isoc read: frame %d[%d]: %s\n",\r\nframe, numbytes,\r\n"exceeds end of buffer");\r\nnumbytes = BAS_INBUFSIZE - offset;\r\n}\r\ngigaset_isoc_receive(rcvbuf + offset, numbytes, bcs);\r\ntotleft -= numbytes;\r\n}\r\nif (unlikely(totleft > 0))\r\ndev_warn(cs->dev, "isoc read: %d data bytes missing\n",\r\ntotleft);\r\nerror:\r\nfor (frame = 0; frame < BAS_NUMFRAMES; frame++) {\r\nurb->iso_frame_desc[frame].status = 0;\r\nurb->iso_frame_desc[frame].actual_length = 0;\r\n}\r\nurb->dev = bcs->cs->hw.bas->udev;\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->number_of_packets = BAS_NUMFRAMES;\r\nrc = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (unlikely(rc != 0 && rc != -ENODEV)) {\r\ndev_err(cs->dev,\r\n"could not resubmit isoc read URB: %s\n",\r\nget_usb_rcmsg(rc));\r\ndump_urb(DEBUG_ISO, "resubmit isoc read", urb);\r\nerror_hangup(bcs);\r\n}\r\n}\r\n}\r\nstatic void req_timeout(unsigned long data)\r\n{\r\nstruct cardstate *cs = (struct cardstate *) data;\r\nstruct bas_cardstate *ucs = cs->hw.bas;\r\nint pending;\r\nunsigned long flags;\r\ncheck_pending(ucs);\r\nspin_lock_irqsave(&ucs->lock, flags);\r\npending = ucs->pending;\r\nucs->pending = 0;\r\nspin_unlock_irqrestore(&ucs->lock, flags);\r\nswitch (pending) {\r\ncase 0:\r\ngig_dbg(DEBUG_USBREQ, "%s: no request pending", __func__);\r\nbreak;\r\ncase HD_OPEN_ATCHANNEL:\r\ndev_err(cs->dev, "timeout opening AT channel\n");\r\nerror_reset(cs);\r\nbreak;\r\ncase HD_OPEN_B1CHANNEL:\r\ndev_err(cs->dev, "timeout opening channel 1\n");\r\nerror_hangup(&cs->bcs[0]);\r\nbreak;\r\ncase HD_OPEN_B2CHANNEL:\r\ndev_err(cs->dev, "timeout opening channel 2\n");\r\nerror_hangup(&cs->bcs[1]);\r\nbreak;\r\ncase HD_CLOSE_ATCHANNEL:\r\ndev_err(cs->dev, "timeout closing AT channel\n");\r\nerror_reset(cs);\r\nbreak;\r\ncase HD_CLOSE_B1CHANNEL:\r\ndev_err(cs->dev, "timeout closing channel 1\n");\r\nerror_reset(cs);\r\nbreak;\r\ncase HD_CLOSE_B2CHANNEL:\r\ndev_err(cs->dev, "timeout closing channel 2\n");\r\nerror_reset(cs);\r\nbreak;\r\ncase HD_RESET_INTERRUPT_PIPE:\r\ndev_err(cs->dev,\r\n"reset interrupt pipe timeout, attempting USB reset\n");\r\nusb_queue_reset_device(ucs->interface);\r\nbreak;\r\ndefault:\r\ndev_warn(cs->dev, "request 0x%02x timed out, clearing\n",\r\npending);\r\n}\r\nwake_up(&ucs->waitqueue);\r\n}\r\nstatic void write_ctrl_callback(struct urb *urb)\r\n{\r\nstruct bas_cardstate *ucs = urb->context;\r\nint status = urb->status;\r\nint rc;\r\nunsigned long flags;\r\nswitch (status) {\r\ncase 0:\r\nspin_lock_irqsave(&ucs->lock, flags);\r\nswitch (ucs->pending) {\r\ncase HD_DEVICE_INIT_ACK:\r\ndel_timer(&ucs->timer_ctrl);\r\nucs->pending = 0;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ucs->lock, flags);\r\nreturn;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -EINPROGRESS:\r\ncase -ENODEV:\r\ncase -ESHUTDOWN:\r\ngig_dbg(DEBUG_USBREQ, "%s: %s",\r\n__func__, get_usb_statmsg(status));\r\nbreak;\r\ndefault:\r\nif (++ucs->retry_ctrl > BAS_RETRY ||\r\n(ucs->basstate & BS_SUSPEND)) {\r\ndev_err(&ucs->interface->dev,\r\n"control request 0x%02x failed: %s\n",\r\nucs->dr_ctrl.bRequest,\r\nget_usb_statmsg(status));\r\nbreak;\r\n}\r\ndev_notice(&ucs->interface->dev,\r\n"control request 0x%02x: %s, retry %d\n",\r\nucs->dr_ctrl.bRequest, get_usb_statmsg(status),\r\nucs->retry_ctrl);\r\nurb->dev = ucs->udev;\r\nrc = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (unlikely(rc)) {\r\ndev_err(&ucs->interface->dev,\r\n"could not resubmit request 0x%02x: %s\n",\r\nucs->dr_ctrl.bRequest, get_usb_rcmsg(rc));\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nspin_lock_irqsave(&ucs->lock, flags);\r\ndel_timer(&ucs->timer_ctrl);\r\nucs->pending = 0;\r\nspin_unlock_irqrestore(&ucs->lock, flags);\r\nwake_up(&ucs->waitqueue);\r\n}\r\nstatic int req_submit(struct bc_state *bcs, int req, int val, int timeout)\r\n{\r\nstruct bas_cardstate *ucs = bcs->cs->hw.bas;\r\nint ret;\r\nunsigned long flags;\r\ngig_dbg(DEBUG_USBREQ, "-------> 0x%02x (%d)", req, val);\r\nspin_lock_irqsave(&ucs->lock, flags);\r\nif (ucs->pending) {\r\nspin_unlock_irqrestore(&ucs->lock, flags);\r\ndev_err(bcs->cs->dev,\r\n"submission of request 0x%02x failed: "\r\n"request 0x%02x still pending\n",\r\nreq, ucs->pending);\r\nreturn -EBUSY;\r\n}\r\nucs->dr_ctrl.bRequestType = OUT_VENDOR_REQ;\r\nucs->dr_ctrl.bRequest = req;\r\nucs->dr_ctrl.wValue = cpu_to_le16(val);\r\nucs->dr_ctrl.wIndex = 0;\r\nucs->dr_ctrl.wLength = 0;\r\nusb_fill_control_urb(ucs->urb_ctrl, ucs->udev,\r\nusb_sndctrlpipe(ucs->udev, 0),\r\n(unsigned char *) &ucs->dr_ctrl, NULL, 0,\r\nwrite_ctrl_callback, ucs);\r\nucs->retry_ctrl = 0;\r\nret = usb_submit_urb(ucs->urb_ctrl, GFP_ATOMIC);\r\nif (unlikely(ret)) {\r\ndev_err(bcs->cs->dev, "could not submit request 0x%02x: %s\n",\r\nreq, get_usb_rcmsg(ret));\r\nspin_unlock_irqrestore(&ucs->lock, flags);\r\nreturn ret;\r\n}\r\nucs->pending = req;\r\nif (timeout > 0) {\r\ngig_dbg(DEBUG_USBREQ, "setting timeout of %d/10 secs", timeout);\r\nmod_timer(&ucs->timer_ctrl, jiffies + timeout * HZ / 10);\r\n}\r\nspin_unlock_irqrestore(&ucs->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int gigaset_init_bchannel(struct bc_state *bcs)\r\n{\r\nstruct cardstate *cs = bcs->cs;\r\nint req, ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (unlikely(!cs->connected)) {\r\ngig_dbg(DEBUG_USBREQ, "%s: not connected", __func__);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn -ENODEV;\r\n}\r\nif (cs->hw.bas->basstate & BS_SUSPEND) {\r\ndev_notice(cs->dev,\r\n"not starting isoc I/O, suspend in progress\n");\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn -EHOSTUNREACH;\r\n}\r\nret = starturbs(bcs);\r\nif (ret < 0) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ndev_err(cs->dev,\r\n"could not start isoc I/O for channel B%d: %s\n",\r\nbcs->channel + 1,\r\nret == -EFAULT ? "null URB" : get_usb_rcmsg(ret));\r\nif (ret != -ENODEV)\r\nerror_hangup(bcs);\r\nreturn ret;\r\n}\r\nreq = bcs->channel ? HD_OPEN_B2CHANNEL : HD_OPEN_B1CHANNEL;\r\nret = req_submit(bcs, req, 0, BAS_TIMEOUT);\r\nif (ret < 0) {\r\ndev_err(cs->dev, "could not open channel B%d\n",\r\nbcs->channel + 1);\r\nstopurbs(bcs->hw.bas);\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nif (ret < 0 && ret != -ENODEV)\r\nerror_hangup(bcs);\r\nreturn ret;\r\n}\r\nstatic int gigaset_close_bchannel(struct bc_state *bcs)\r\n{\r\nstruct cardstate *cs = bcs->cs;\r\nint req, ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (unlikely(!cs->connected)) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ngig_dbg(DEBUG_USBREQ, "%s: not connected", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (!(cs->hw.bas->basstate & (bcs->channel ? BS_B2OPEN : BS_B1OPEN))) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ngigaset_bchannel_down(bcs);\r\nreturn 0;\r\n}\r\nreq = bcs->channel ? HD_CLOSE_B2CHANNEL : HD_CLOSE_B1CHANNEL;\r\nret = req_submit(bcs, req, 0, BAS_TIMEOUT);\r\nif (ret < 0)\r\ndev_err(cs->dev, "closing channel B%d failed\n",\r\nbcs->channel + 1);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void complete_cb(struct cardstate *cs)\r\n{\r\nstruct cmdbuf_t *cb = cs->cmdbuf;\r\ncs->cmdbytes -= cs->curlen;\r\ngig_dbg(DEBUG_OUTPUT, "write_command: sent %u bytes, %u left",\r\ncs->curlen, cs->cmdbytes);\r\nif (cb->next != NULL) {\r\ncs->cmdbuf = cb->next;\r\ncs->cmdbuf->prev = NULL;\r\ncs->curlen = cs->cmdbuf->len;\r\n} else {\r\ncs->cmdbuf = NULL;\r\ncs->lastcmdbuf = NULL;\r\ncs->curlen = 0;\r\n}\r\nif (cb->wake_tasklet)\r\ntasklet_schedule(cb->wake_tasklet);\r\nkfree(cb);\r\n}\r\nstatic void write_command_callback(struct urb *urb)\r\n{\r\nstruct cardstate *cs = urb->context;\r\nstruct bas_cardstate *ucs = cs->hw.bas;\r\nint status = urb->status;\r\nunsigned long flags;\r\nupdate_basstate(ucs, 0, BS_ATWRPEND);\r\nwake_up(&ucs->waitqueue);\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -EINPROGRESS:\r\ncase -ENODEV:\r\ncase -ESHUTDOWN:\r\ngig_dbg(DEBUG_USBREQ, "%s: %s",\r\n__func__, get_usb_statmsg(status));\r\nreturn;\r\ndefault:\r\nif (++ucs->retry_cmd_out > BAS_RETRY) {\r\ndev_warn(cs->dev,\r\n"command write: %s, "\r\n"giving up after %d retries\n",\r\nget_usb_statmsg(status),\r\nucs->retry_cmd_out);\r\nbreak;\r\n}\r\nif (ucs->basstate & BS_SUSPEND) {\r\ndev_warn(cs->dev,\r\n"command write: %s, "\r\n"won't retry - suspend requested\n",\r\nget_usb_statmsg(status));\r\nbreak;\r\n}\r\nif (cs->cmdbuf == NULL) {\r\ndev_warn(cs->dev,\r\n"command write: %s, "\r\n"cannot retry - cmdbuf gone\n",\r\nget_usb_statmsg(status));\r\nbreak;\r\n}\r\ndev_notice(cs->dev, "command write: %s, retry %d\n",\r\nget_usb_statmsg(status), ucs->retry_cmd_out);\r\nif (atwrite_submit(cs, cs->cmdbuf->buf, cs->cmdbuf->len) >= 0)\r\nreturn;\r\nupdate_basstate(ucs, BS_ATREADY, 0);\r\n}\r\nspin_lock_irqsave(&cs->cmdlock, flags);\r\nif (cs->cmdbuf != NULL)\r\ncomplete_cb(cs);\r\nspin_unlock_irqrestore(&cs->cmdlock, flags);\r\n}\r\nstatic void atrdy_timeout(unsigned long data)\r\n{\r\nstruct cardstate *cs = (struct cardstate *) data;\r\nstruct bas_cardstate *ucs = cs->hw.bas;\r\ndev_warn(cs->dev, "timeout waiting for HD_READY_SEND_ATDATA\n");\r\nupdate_basstate(ucs, BS_ATREADY, BS_ATTIMER);\r\nstart_cbsend(cs);\r\n}\r\nstatic int atwrite_submit(struct cardstate *cs, unsigned char *buf, int len)\r\n{\r\nstruct bas_cardstate *ucs = cs->hw.bas;\r\nint rc;\r\ngig_dbg(DEBUG_USBREQ, "-------> HD_WRITE_ATMESSAGE (%d)", len);\r\nif (update_basstate(ucs, BS_ATWRPEND, 0) & BS_ATWRPEND) {\r\ndev_err(cs->dev,\r\n"could not submit HD_WRITE_ATMESSAGE: URB busy\n");\r\nreturn -EBUSY;\r\n}\r\nucs->dr_cmd_out.bRequestType = OUT_VENDOR_REQ;\r\nucs->dr_cmd_out.bRequest = HD_WRITE_ATMESSAGE;\r\nucs->dr_cmd_out.wValue = 0;\r\nucs->dr_cmd_out.wIndex = 0;\r\nucs->dr_cmd_out.wLength = cpu_to_le16(len);\r\nusb_fill_control_urb(ucs->urb_cmd_out, ucs->udev,\r\nusb_sndctrlpipe(ucs->udev, 0),\r\n(unsigned char *) &ucs->dr_cmd_out, buf, len,\r\nwrite_command_callback, cs);\r\nrc = usb_submit_urb(ucs->urb_cmd_out, GFP_ATOMIC);\r\nif (unlikely(rc)) {\r\nupdate_basstate(ucs, 0, BS_ATWRPEND);\r\ndev_err(cs->dev, "could not submit HD_WRITE_ATMESSAGE: %s\n",\r\nget_usb_rcmsg(rc));\r\nreturn rc;\r\n}\r\nif (!(update_basstate(ucs, BS_ATTIMER, BS_ATREADY) & BS_ATTIMER)) {\r\ngig_dbg(DEBUG_OUTPUT, "setting ATREADY timeout of %d/10 secs",\r\nATRDY_TIMEOUT);\r\nmod_timer(&ucs->timer_atrdy, jiffies + ATRDY_TIMEOUT * HZ / 10);\r\n}\r\nreturn 0;\r\n}\r\nstatic int start_cbsend(struct cardstate *cs)\r\n{\r\nstruct cmdbuf_t *cb;\r\nstruct bas_cardstate *ucs = cs->hw.bas;\r\nunsigned long flags;\r\nint rc;\r\nint retval = 0;\r\nif (ucs->basstate & BS_SUSPEND) {\r\ngig_dbg(DEBUG_OUTPUT, "suspending");\r\nreturn -EHOSTUNREACH;\r\n}\r\nif (!(ucs->basstate & BS_ATOPEN)) {\r\ngig_dbg(DEBUG_OUTPUT, "AT channel not open");\r\nrc = req_submit(cs->bcs, HD_OPEN_ATCHANNEL, 0, BAS_TIMEOUT);\r\nif (rc < 0) {\r\nspin_lock_irqsave(&cs->cmdlock, flags);\r\nwhile (cs->cmdbuf != NULL)\r\ncomplete_cb(cs);\r\nspin_unlock_irqrestore(&cs->cmdlock, flags);\r\n}\r\nreturn rc;\r\n}\r\nspin_lock_irqsave(&cs->cmdlock, flags);\r\nwhile ((cb = cs->cmdbuf) != NULL && (ucs->basstate & BS_ATREADY)) {\r\nucs->retry_cmd_out = 0;\r\nrc = atwrite_submit(cs, cb->buf, cb->len);\r\nif (unlikely(rc)) {\r\nretval = rc;\r\ncomplete_cb(cs);\r\n}\r\n}\r\nspin_unlock_irqrestore(&cs->cmdlock, flags);\r\nreturn retval;\r\n}\r\nstatic int gigaset_write_cmd(struct cardstate *cs, struct cmdbuf_t *cb)\r\n{\r\nunsigned long flags;\r\nint rc;\r\ngigaset_dbg_buffer(cs->mstate != MS_LOCKED ?\r\nDEBUG_TRANSCMD : DEBUG_LOCKCMD,\r\n"CMD Transmit", cb->len, cb->buf);\r\nif (cb->len == 3 && !memcmp(cb->buf, "+++", 3)) {\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (!(cs->hw.bas->basstate & BS_ATRDPEND)) {\r\nkfree(cs->hw.bas->rcvbuf);\r\ncs->hw.bas->rcvbuf = NULL;\r\ncs->hw.bas->rcvbuf_size = 0;\r\ncs->hw.bas->retry_cmd_in = 0;\r\natread_submit(cs, 0);\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nrc = req_submit(cs->bcs, HD_CLOSE_ATCHANNEL, 0, BAS_TIMEOUT);\r\nif (cb->wake_tasklet)\r\ntasklet_schedule(cb->wake_tasklet);\r\nif (!rc)\r\nrc = cb->len;\r\nkfree(cb);\r\nreturn rc;\r\n}\r\nspin_lock_irqsave(&cs->cmdlock, flags);\r\ncb->prev = cs->lastcmdbuf;\r\nif (cs->lastcmdbuf)\r\ncs->lastcmdbuf->next = cb;\r\nelse {\r\ncs->cmdbuf = cb;\r\ncs->curlen = cb->len;\r\n}\r\ncs->cmdbytes += cb->len;\r\ncs->lastcmdbuf = cb;\r\nspin_unlock_irqrestore(&cs->cmdlock, flags);\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (unlikely(!cs->connected)) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ngig_dbg(DEBUG_USBREQ, "%s: not connected", __func__);\r\nspin_lock_irqsave(&cs->cmdlock, flags);\r\nwhile (cs->cmdbuf != NULL)\r\ncomplete_cb(cs);\r\nspin_unlock_irqrestore(&cs->cmdlock, flags);\r\nreturn -ENODEV;\r\n}\r\nrc = start_cbsend(cs);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn rc < 0 ? rc : cb->len;\r\n}\r\nstatic int gigaset_write_room(struct cardstate *cs)\r\n{\r\nreturn IF_WRITEBUF;\r\n}\r\nstatic int gigaset_chars_in_buffer(struct cardstate *cs)\r\n{\r\nreturn cs->cmdbytes;\r\n}\r\nstatic int gigaset_brkchars(struct cardstate *cs, const unsigned char buf[6])\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int gigaset_freebcshw(struct bc_state *bcs)\r\n{\r\nstruct bas_bc_state *ubc = bcs->hw.bas;\r\nint i;\r\nif (!ubc)\r\nreturn 0;\r\nubc->running = 0;\r\ngig_dbg(DEBUG_INIT, "%s: killing isoc URBs", __func__);\r\nfor (i = 0; i < BAS_OUTURBS; ++i) {\r\nusb_kill_urb(ubc->isoouturbs[i].urb);\r\nusb_free_urb(ubc->isoouturbs[i].urb);\r\n}\r\nfor (i = 0; i < BAS_INURBS; ++i) {\r\nusb_kill_urb(ubc->isoinurbs[i]);\r\nusb_free_urb(ubc->isoinurbs[i]);\r\n}\r\ntasklet_kill(&ubc->sent_tasklet);\r\ntasklet_kill(&ubc->rcvd_tasklet);\r\nkfree(ubc->isooutbuf);\r\nkfree(ubc);\r\nbcs->hw.bas = NULL;\r\nreturn 1;\r\n}\r\nstatic int gigaset_initbcshw(struct bc_state *bcs)\r\n{\r\nint i;\r\nstruct bas_bc_state *ubc;\r\nbcs->hw.bas = ubc = kmalloc(sizeof(struct bas_bc_state), GFP_KERNEL);\r\nif (!ubc) {\r\npr_err("out of memory\n");\r\nreturn 0;\r\n}\r\nubc->running = 0;\r\natomic_set(&ubc->corrbytes, 0);\r\nspin_lock_init(&ubc->isooutlock);\r\nfor (i = 0; i < BAS_OUTURBS; ++i) {\r\nubc->isoouturbs[i].urb = NULL;\r\nubc->isoouturbs[i].bcs = bcs;\r\n}\r\nubc->isooutdone = ubc->isooutfree = ubc->isooutovfl = NULL;\r\nubc->numsub = 0;\r\nubc->isooutbuf = kmalloc(sizeof(struct isowbuf_t), GFP_KERNEL);\r\nif (!ubc->isooutbuf) {\r\npr_err("out of memory\n");\r\nkfree(ubc);\r\nbcs->hw.bas = NULL;\r\nreturn 0;\r\n}\r\ntasklet_init(&ubc->sent_tasklet,\r\nwrite_iso_tasklet, (unsigned long) bcs);\r\nspin_lock_init(&ubc->isoinlock);\r\nfor (i = 0; i < BAS_INURBS; ++i)\r\nubc->isoinurbs[i] = NULL;\r\nubc->isoindone = NULL;\r\nubc->loststatus = -EINPROGRESS;\r\nubc->isoinlost = 0;\r\nubc->seqlen = 0;\r\nubc->inbyte = 0;\r\nubc->inbits = 0;\r\nubc->goodbytes = 0;\r\nubc->alignerrs = 0;\r\nubc->fcserrs = 0;\r\nubc->frameerrs = 0;\r\nubc->giants = 0;\r\nubc->runts = 0;\r\nubc->aborts = 0;\r\nubc->shared0s = 0;\r\nubc->stolen0s = 0;\r\ntasklet_init(&ubc->rcvd_tasklet,\r\nread_iso_tasklet, (unsigned long) bcs);\r\nreturn 1;\r\n}\r\nstatic void gigaset_reinitbcshw(struct bc_state *bcs)\r\n{\r\nstruct bas_bc_state *ubc = bcs->hw.bas;\r\nbcs->hw.bas->running = 0;\r\natomic_set(&bcs->hw.bas->corrbytes, 0);\r\nbcs->hw.bas->numsub = 0;\r\nspin_lock_init(&ubc->isooutlock);\r\nspin_lock_init(&ubc->isoinlock);\r\nubc->loststatus = -EINPROGRESS;\r\n}\r\nstatic void gigaset_freecshw(struct cardstate *cs)\r\n{\r\nkfree(cs->hw.bas->int_in_buf);\r\nkfree(cs->hw.bas);\r\ncs->hw.bas = NULL;\r\n}\r\nstatic int gigaset_initcshw(struct cardstate *cs)\r\n{\r\nstruct bas_cardstate *ucs;\r\ncs->hw.bas = ucs = kmalloc(sizeof *ucs, GFP_KERNEL);\r\nif (!ucs) {\r\npr_err("out of memory\n");\r\nreturn 0;\r\n}\r\nucs->int_in_buf = kmalloc(IP_MSGSIZE, GFP_KERNEL);\r\nif (!ucs->int_in_buf) {\r\nkfree(ucs);\r\npr_err("out of memory\n");\r\nreturn 0;\r\n}\r\nucs->urb_cmd_in = NULL;\r\nucs->urb_cmd_out = NULL;\r\nucs->rcvbuf = NULL;\r\nucs->rcvbuf_size = 0;\r\nspin_lock_init(&ucs->lock);\r\nucs->pending = 0;\r\nucs->basstate = 0;\r\nsetup_timer(&ucs->timer_ctrl, req_timeout, (unsigned long) cs);\r\nsetup_timer(&ucs->timer_atrdy, atrdy_timeout, (unsigned long) cs);\r\nsetup_timer(&ucs->timer_cmd_in, cmd_in_timeout, (unsigned long) cs);\r\nsetup_timer(&ucs->timer_int_in, int_in_resubmit, (unsigned long) cs);\r\ninit_waitqueue_head(&ucs->waitqueue);\r\nINIT_WORK(&ucs->int_in_wq, int_in_work);\r\nreturn 1;\r\n}\r\nstatic void freeurbs(struct cardstate *cs)\r\n{\r\nstruct bas_cardstate *ucs = cs->hw.bas;\r\nstruct bas_bc_state *ubc;\r\nint i, j;\r\ngig_dbg(DEBUG_INIT, "%s: killing URBs", __func__);\r\nfor (j = 0; j < BAS_CHANNELS; ++j) {\r\nubc = cs->bcs[j].hw.bas;\r\nfor (i = 0; i < BAS_OUTURBS; ++i) {\r\nusb_kill_urb(ubc->isoouturbs[i].urb);\r\nusb_free_urb(ubc->isoouturbs[i].urb);\r\nubc->isoouturbs[i].urb = NULL;\r\n}\r\nfor (i = 0; i < BAS_INURBS; ++i) {\r\nusb_kill_urb(ubc->isoinurbs[i]);\r\nusb_free_urb(ubc->isoinurbs[i]);\r\nubc->isoinurbs[i] = NULL;\r\n}\r\n}\r\nusb_kill_urb(ucs->urb_int_in);\r\nusb_free_urb(ucs->urb_int_in);\r\nucs->urb_int_in = NULL;\r\nusb_kill_urb(ucs->urb_cmd_out);\r\nusb_free_urb(ucs->urb_cmd_out);\r\nucs->urb_cmd_out = NULL;\r\nusb_kill_urb(ucs->urb_cmd_in);\r\nusb_free_urb(ucs->urb_cmd_in);\r\nucs->urb_cmd_in = NULL;\r\nusb_kill_urb(ucs->urb_ctrl);\r\nusb_free_urb(ucs->urb_ctrl);\r\nucs->urb_ctrl = NULL;\r\n}\r\nstatic int gigaset_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_host_interface *hostif;\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct cardstate *cs = NULL;\r\nstruct bas_cardstate *ucs = NULL;\r\nstruct bas_bc_state *ubc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint i, j;\r\nint rc;\r\ngig_dbg(DEBUG_INIT,\r\n"%s: Check if device matches .. (Vendor: 0x%x, Product: 0x%x)",\r\n__func__, le16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct));\r\nhostif = interface->cur_altsetting;\r\nif (hostif->desc.bAlternateSetting != 3) {\r\ngig_dbg(DEBUG_INIT,\r\n"%s: wrong alternate setting %d - trying to switch",\r\n__func__, hostif->desc.bAlternateSetting);\r\nif (usb_set_interface(udev, hostif->desc.bInterfaceNumber, 3)\r\n< 0) {\r\ndev_warn(&udev->dev, "usb_set_interface failed, "\r\n"device %d interface %d altsetting %d\n",\r\nudev->devnum, hostif->desc.bInterfaceNumber,\r\nhostif->desc.bAlternateSetting);\r\nreturn -ENODEV;\r\n}\r\nhostif = interface->cur_altsetting;\r\n}\r\nif (hostif->desc.bInterfaceClass != 255) {\r\ndev_warn(&udev->dev, "%s: bInterfaceClass == %d\n",\r\n__func__, hostif->desc.bInterfaceClass);\r\nreturn -ENODEV;\r\n}\r\ndev_info(&udev->dev,\r\n"%s: Device matched (Vendor: 0x%x, Product: 0x%x)\n",\r\n__func__, le16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct));\r\ncs = gigaset_initcs(driver, BAS_CHANNELS, 0, 0, cidmode,\r\nGIGASET_MODULENAME);\r\nif (!cs)\r\nreturn -ENODEV;\r\nucs = cs->hw.bas;\r\nusb_get_dev(udev);\r\nucs->udev = udev;\r\nucs->interface = interface;\r\ncs->dev = &interface->dev;\r\nif (!(ucs->urb_int_in = usb_alloc_urb(0, GFP_KERNEL)) ||\r\n!(ucs->urb_cmd_in = usb_alloc_urb(0, GFP_KERNEL)) ||\r\n!(ucs->urb_cmd_out = usb_alloc_urb(0, GFP_KERNEL)) ||\r\n!(ucs->urb_ctrl = usb_alloc_urb(0, GFP_KERNEL)))\r\ngoto allocerr;\r\nfor (j = 0; j < BAS_CHANNELS; ++j) {\r\nubc = cs->bcs[j].hw.bas;\r\nfor (i = 0; i < BAS_OUTURBS; ++i)\r\nif (!(ubc->isoouturbs[i].urb =\r\nusb_alloc_urb(BAS_NUMFRAMES, GFP_KERNEL)))\r\ngoto allocerr;\r\nfor (i = 0; i < BAS_INURBS; ++i)\r\nif (!(ubc->isoinurbs[i] =\r\nusb_alloc_urb(BAS_NUMFRAMES, GFP_KERNEL)))\r\ngoto allocerr;\r\n}\r\nucs->rcvbuf = NULL;\r\nucs->rcvbuf_size = 0;\r\nendpoint = &hostif->endpoint[0].desc;\r\nusb_fill_int_urb(ucs->urb_int_in, udev,\r\nusb_rcvintpipe(udev,\r\n(endpoint->bEndpointAddress) & 0x0f),\r\nucs->int_in_buf, IP_MSGSIZE, read_int_callback, cs,\r\nendpoint->bInterval);\r\nrc = usb_submit_urb(ucs->urb_int_in, GFP_KERNEL);\r\nif (rc != 0) {\r\ndev_err(cs->dev, "could not submit interrupt URB: %s\n",\r\nget_usb_rcmsg(rc));\r\ngoto error;\r\n}\r\nucs->retry_int_in = 0;\r\nrc = req_submit(cs->bcs, HD_DEVICE_INIT_ACK, 0, 0);\r\nif (rc != 0)\r\ngoto error;\r\nif (startmode == SM_LOCKED)\r\ncs->mstate = MS_LOCKED;\r\nusb_set_intfdata(interface, cs);\r\nif (!gigaset_start(cs))\r\ngoto error;\r\nreturn 0;\r\nallocerr:\r\ndev_err(cs->dev, "could not allocate URBs\n");\r\nerror:\r\nfreeurbs(cs);\r\nusb_set_intfdata(interface, NULL);\r\ngigaset_freecs(cs);\r\nreturn -ENODEV;\r\n}\r\nstatic void gigaset_disconnect(struct usb_interface *interface)\r\n{\r\nstruct cardstate *cs;\r\nstruct bas_cardstate *ucs;\r\nint j;\r\ncs = usb_get_intfdata(interface);\r\nucs = cs->hw.bas;\r\ndev_info(cs->dev, "disconnecting Gigaset base\n");\r\nucs->basstate = 0;\r\nfor (j = 0; j < BAS_CHANNELS; ++j)\r\ngigaset_bchannel_down(cs->bcs + j);\r\ngigaset_stop(cs);\r\ndel_timer_sync(&ucs->timer_ctrl);\r\ndel_timer_sync(&ucs->timer_atrdy);\r\ndel_timer_sync(&ucs->timer_cmd_in);\r\ndel_timer_sync(&ucs->timer_int_in);\r\ncancel_work_sync(&ucs->int_in_wq);\r\nfreeurbs(cs);\r\nusb_set_intfdata(interface, NULL);\r\nkfree(ucs->rcvbuf);\r\nucs->rcvbuf = NULL;\r\nucs->rcvbuf_size = 0;\r\nusb_put_dev(ucs->udev);\r\nucs->interface = NULL;\r\nucs->udev = NULL;\r\ncs->dev = NULL;\r\ngigaset_freecs(cs);\r\n}\r\nstatic int gigaset_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct cardstate *cs = usb_get_intfdata(intf);\r\nstruct bas_cardstate *ucs = cs->hw.bas;\r\nint rc;\r\nif (update_basstate(ucs, BS_SUSPEND, 0) & BS_SUSPEND) {\r\ngig_dbg(DEBUG_SUSPEND, "already suspended");\r\nreturn 0;\r\n}\r\nrc = wait_event_timeout(ucs->waitqueue,\r\n!(ucs->basstate &\r\n(BS_B1OPEN|BS_B2OPEN|BS_ATRDPEND|BS_ATWRPEND)),\r\nBAS_TIMEOUT*HZ/10);\r\ngig_dbg(DEBUG_SUSPEND, "wait_event_timeout() -> %d", rc);\r\nif (ucs->basstate & (BS_B1OPEN|BS_B2OPEN|BS_ATRDPEND|BS_ATWRPEND)) {\r\ndev_warn(cs->dev, "cannot suspend:\n");\r\nif (ucs->basstate & BS_B1OPEN)\r\ndev_warn(cs->dev, " B channel 1 open\n");\r\nif (ucs->basstate & BS_B2OPEN)\r\ndev_warn(cs->dev, " B channel 2 open\n");\r\nif (ucs->basstate & BS_ATRDPEND)\r\ndev_warn(cs->dev, " receiving AT reply\n");\r\nif (ucs->basstate & BS_ATWRPEND)\r\ndev_warn(cs->dev, " sending AT command\n");\r\nupdate_basstate(ucs, 0, BS_SUSPEND);\r\nreturn -EBUSY;\r\n}\r\nif (ucs->basstate & BS_ATOPEN) {\r\ngig_dbg(DEBUG_SUSPEND, "closing AT channel");\r\nrc = req_submit(cs->bcs, HD_CLOSE_ATCHANNEL, 0, 0);\r\nif (rc) {\r\nupdate_basstate(ucs, 0, BS_SUSPEND);\r\nreturn rc;\r\n}\r\nwait_event_timeout(ucs->waitqueue, !ucs->pending,\r\nBAS_TIMEOUT*HZ/10);\r\n}\r\nusb_kill_urb(ucs->urb_ctrl);\r\nusb_kill_urb(ucs->urb_int_in);\r\ndel_timer_sync(&ucs->timer_ctrl);\r\ndel_timer_sync(&ucs->timer_atrdy);\r\ndel_timer_sync(&ucs->timer_cmd_in);\r\ndel_timer_sync(&ucs->timer_int_in);\r\ncancel_work_sync(&ucs->int_in_wq);\r\ngig_dbg(DEBUG_SUSPEND, "suspend complete");\r\nreturn 0;\r\n}\r\nstatic int gigaset_resume(struct usb_interface *intf)\r\n{\r\nstruct cardstate *cs = usb_get_intfdata(intf);\r\nstruct bas_cardstate *ucs = cs->hw.bas;\r\nint rc;\r\nrc = usb_submit_urb(ucs->urb_int_in, GFP_KERNEL);\r\nif (rc) {\r\ndev_err(cs->dev, "could not resubmit interrupt URB: %s\n",\r\nget_usb_rcmsg(rc));\r\nreturn rc;\r\n}\r\nucs->retry_int_in = 0;\r\nupdate_basstate(ucs, 0, BS_SUSPEND);\r\ngig_dbg(DEBUG_SUSPEND, "resume complete");\r\nreturn 0;\r\n}\r\nstatic int gigaset_pre_reset(struct usb_interface *intf)\r\n{\r\nreturn gigaset_suspend(intf, PMSG_ON);\r\n}\r\nstatic int gigaset_post_reset(struct usb_interface *intf)\r\n{\r\nreturn gigaset_resume(intf);\r\n}\r\nstatic int __init bas_gigaset_init(void)\r\n{\r\nint result;\r\ndriver = gigaset_initdriver(GIGASET_MINOR, GIGASET_MINORS,\r\nGIGASET_MODULENAME, GIGASET_DEVNAME,\r\n&gigops, THIS_MODULE);\r\nif (driver == NULL)\r\ngoto error;\r\nresult = usb_register(&gigaset_usb_driver);\r\nif (result < 0) {\r\npr_err("error %d registering USB driver\n", -result);\r\ngoto error;\r\n}\r\npr_info(DRIVER_DESC "\n");\r\nreturn 0;\r\nerror:\r\nif (driver)\r\ngigaset_freedriver(driver);\r\ndriver = NULL;\r\nreturn -1;\r\n}\r\nstatic void __exit bas_gigaset_exit(void)\r\n{\r\nstruct bas_cardstate *ucs;\r\nint i;\r\ngigaset_blockdriver(driver);\r\nfor (i = 0; i < driver->minors; i++) {\r\nif (gigaset_shutdown(driver->cs + i) < 0)\r\ncontinue;\r\nucs = driver->cs[i].hw.bas;\r\nif (ucs->basstate & BS_B1OPEN) {\r\ngig_dbg(DEBUG_INIT, "closing B1 channel");\r\nusb_control_msg(ucs->udev,\r\nusb_sndctrlpipe(ucs->udev, 0),\r\nHD_CLOSE_B1CHANNEL, OUT_VENDOR_REQ,\r\n0, 0, NULL, 0, BAS_TIMEOUT);\r\n}\r\nif (ucs->basstate & BS_B2OPEN) {\r\ngig_dbg(DEBUG_INIT, "closing B2 channel");\r\nusb_control_msg(ucs->udev,\r\nusb_sndctrlpipe(ucs->udev, 0),\r\nHD_CLOSE_B2CHANNEL, OUT_VENDOR_REQ,\r\n0, 0, NULL, 0, BAS_TIMEOUT);\r\n}\r\nif (ucs->basstate & BS_ATOPEN) {\r\ngig_dbg(DEBUG_INIT, "closing AT channel");\r\nusb_control_msg(ucs->udev,\r\nusb_sndctrlpipe(ucs->udev, 0),\r\nHD_CLOSE_ATCHANNEL, OUT_VENDOR_REQ,\r\n0, 0, NULL, 0, BAS_TIMEOUT);\r\n}\r\nucs->basstate = 0;\r\n}\r\nusb_deregister(&gigaset_usb_driver);\r\ngigaset_freedriver(driver);\r\ndriver = NULL;\r\n}
