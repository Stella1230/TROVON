static bool mxt_object_readable(unsigned int type)\r\n{\r\nswitch (type) {\r\ncase MXT_GEN_MESSAGE_T5:\r\ncase MXT_GEN_COMMAND_T6:\r\ncase MXT_GEN_POWER_T7:\r\ncase MXT_GEN_ACQUIRE_T8:\r\ncase MXT_GEN_DATASOURCE_T53:\r\ncase MXT_TOUCH_MULTI_T9:\r\ncase MXT_TOUCH_KEYARRAY_T15:\r\ncase MXT_TOUCH_PROXIMITY_T23:\r\ncase MXT_TOUCH_PROXKEY_T52:\r\ncase MXT_PROCI_GRIPFACE_T20:\r\ncase MXT_PROCG_NOISE_T22:\r\ncase MXT_PROCI_ONETOUCH_T24:\r\ncase MXT_PROCI_TWOTOUCH_T27:\r\ncase MXT_PROCI_GRIP_T40:\r\ncase MXT_PROCI_PALM_T41:\r\ncase MXT_PROCI_TOUCHSUPPRESSION_T42:\r\ncase MXT_PROCI_STYLUS_T47:\r\ncase MXT_PROCG_NOISESUPPRESSION_T48:\r\ncase MXT_SPT_COMMSCONFIG_T18:\r\ncase MXT_SPT_GPIOPWM_T19:\r\ncase MXT_SPT_SELFTEST_T25:\r\ncase MXT_SPT_CTECONFIG_T28:\r\ncase MXT_SPT_USERDATA_T38:\r\ncase MXT_SPT_DIGITIZER_T43:\r\ncase MXT_SPT_CTECONFIG_T46:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool mxt_object_writable(unsigned int type)\r\n{\r\nswitch (type) {\r\ncase MXT_GEN_COMMAND_T6:\r\ncase MXT_GEN_POWER_T7:\r\ncase MXT_GEN_ACQUIRE_T8:\r\ncase MXT_TOUCH_MULTI_T9:\r\ncase MXT_TOUCH_KEYARRAY_T15:\r\ncase MXT_TOUCH_PROXIMITY_T23:\r\ncase MXT_TOUCH_PROXKEY_T52:\r\ncase MXT_PROCI_GRIPFACE_T20:\r\ncase MXT_PROCG_NOISE_T22:\r\ncase MXT_PROCI_ONETOUCH_T24:\r\ncase MXT_PROCI_TWOTOUCH_T27:\r\ncase MXT_PROCI_GRIP_T40:\r\ncase MXT_PROCI_PALM_T41:\r\ncase MXT_PROCI_TOUCHSUPPRESSION_T42:\r\ncase MXT_PROCI_STYLUS_T47:\r\ncase MXT_PROCG_NOISESUPPRESSION_T48:\r\ncase MXT_SPT_COMMSCONFIG_T18:\r\ncase MXT_SPT_GPIOPWM_T19:\r\ncase MXT_SPT_SELFTEST_T25:\r\ncase MXT_SPT_CTECONFIG_T28:\r\ncase MXT_SPT_DIGITIZER_T43:\r\ncase MXT_SPT_CTECONFIG_T46:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic void mxt_dump_message(struct device *dev,\r\nstruct mxt_message *message)\r\n{\r\ndev_dbg(dev, "reportid:\t0x%x\n", message->reportid);\r\ndev_dbg(dev, "message1:\t0x%x\n", message->message[0]);\r\ndev_dbg(dev, "message2:\t0x%x\n", message->message[1]);\r\ndev_dbg(dev, "message3:\t0x%x\n", message->message[2]);\r\ndev_dbg(dev, "message4:\t0x%x\n", message->message[3]);\r\ndev_dbg(dev, "message5:\t0x%x\n", message->message[4]);\r\ndev_dbg(dev, "message6:\t0x%x\n", message->message[5]);\r\ndev_dbg(dev, "message7:\t0x%x\n", message->message[6]);\r\ndev_dbg(dev, "checksum:\t0x%x\n", message->checksum);\r\n}\r\nstatic int mxt_check_bootloader(struct i2c_client *client,\r\nunsigned int state)\r\n{\r\nu8 val;\r\nrecheck:\r\nif (i2c_master_recv(client, &val, 1) != 1) {\r\ndev_err(&client->dev, "%s: i2c recv failed\n", __func__);\r\nreturn -EIO;\r\n}\r\nswitch (state) {\r\ncase MXT_WAITING_BOOTLOAD_CMD:\r\ncase MXT_WAITING_FRAME_DATA:\r\nval &= ~MXT_BOOT_STATUS_MASK;\r\nbreak;\r\ncase MXT_FRAME_CRC_PASS:\r\nif (val == MXT_FRAME_CRC_CHECK)\r\ngoto recheck;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (val != state) {\r\ndev_err(&client->dev, "Unvalid bootloader mode state\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxt_unlock_bootloader(struct i2c_client *client)\r\n{\r\nu8 buf[2];\r\nbuf[0] = MXT_UNLOCK_CMD_LSB;\r\nbuf[1] = MXT_UNLOCK_CMD_MSB;\r\nif (i2c_master_send(client, buf, 2) != 2) {\r\ndev_err(&client->dev, "%s: i2c send failed\n", __func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxt_fw_write(struct i2c_client *client,\r\nconst u8 *data, unsigned int frame_size)\r\n{\r\nif (i2c_master_send(client, data, frame_size) != frame_size) {\r\ndev_err(&client->dev, "%s: i2c send failed\n", __func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __mxt_read_reg(struct i2c_client *client,\r\nu16 reg, u16 len, void *val)\r\n{\r\nstruct i2c_msg xfer[2];\r\nu8 buf[2];\r\nbuf[0] = reg & 0xff;\r\nbuf[1] = (reg >> 8) & 0xff;\r\nxfer[0].addr = client->addr;\r\nxfer[0].flags = 0;\r\nxfer[0].len = 2;\r\nxfer[0].buf = buf;\r\nxfer[1].addr = client->addr;\r\nxfer[1].flags = I2C_M_RD;\r\nxfer[1].len = len;\r\nxfer[1].buf = val;\r\nif (i2c_transfer(client->adapter, xfer, 2) != 2) {\r\ndev_err(&client->dev, "%s: i2c transfer failed\n", __func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxt_read_reg(struct i2c_client *client, u16 reg, u8 *val)\r\n{\r\nreturn __mxt_read_reg(client, reg, 1, val);\r\n}\r\nstatic int mxt_write_reg(struct i2c_client *client, u16 reg, u8 val)\r\n{\r\nu8 buf[3];\r\nbuf[0] = reg & 0xff;\r\nbuf[1] = (reg >> 8) & 0xff;\r\nbuf[2] = val;\r\nif (i2c_master_send(client, buf, 3) != 3) {\r\ndev_err(&client->dev, "%s: i2c send failed\n", __func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxt_read_object_table(struct i2c_client *client,\r\nu16 reg, u8 *object_buf)\r\n{\r\nreturn __mxt_read_reg(client, reg, MXT_OBJECT_SIZE,\r\nobject_buf);\r\n}\r\nstatic struct mxt_object *\r\nmxt_get_object(struct mxt_data *data, u8 type)\r\n{\r\nstruct mxt_object *object;\r\nint i;\r\nfor (i = 0; i < data->info.object_num; i++) {\r\nobject = data->object_table + i;\r\nif (object->type == type)\r\nreturn object;\r\n}\r\ndev_err(&data->client->dev, "Invalid object type\n");\r\nreturn NULL;\r\n}\r\nstatic int mxt_read_message(struct mxt_data *data,\r\nstruct mxt_message *message)\r\n{\r\nstruct mxt_object *object;\r\nu16 reg;\r\nobject = mxt_get_object(data, MXT_GEN_MESSAGE_T5);\r\nif (!object)\r\nreturn -EINVAL;\r\nreg = object->start_address;\r\nreturn __mxt_read_reg(data->client, reg,\r\nsizeof(struct mxt_message), message);\r\n}\r\nstatic int mxt_read_object(struct mxt_data *data,\r\nu8 type, u8 offset, u8 *val)\r\n{\r\nstruct mxt_object *object;\r\nu16 reg;\r\nobject = mxt_get_object(data, type);\r\nif (!object)\r\nreturn -EINVAL;\r\nreg = object->start_address;\r\nreturn __mxt_read_reg(data->client, reg + offset, 1, val);\r\n}\r\nstatic int mxt_write_object(struct mxt_data *data,\r\nu8 type, u8 offset, u8 val)\r\n{\r\nstruct mxt_object *object;\r\nu16 reg;\r\nobject = mxt_get_object(data, type);\r\nif (!object)\r\nreturn -EINVAL;\r\nreg = object->start_address;\r\nreturn mxt_write_reg(data->client, reg + offset, val);\r\n}\r\nstatic void mxt_input_report(struct mxt_data *data, int single_id)\r\n{\r\nstruct mxt_finger *finger = data->finger;\r\nstruct input_dev *input_dev = data->input_dev;\r\nint status = finger[single_id].status;\r\nint finger_num = 0;\r\nint id;\r\nfor (id = 0; id < MXT_MAX_FINGER; id++) {\r\nif (!finger[id].status)\r\ncontinue;\r\ninput_mt_slot(input_dev, id);\r\ninput_mt_report_slot_state(input_dev, MT_TOOL_FINGER,\r\nfinger[id].status != MXT_RELEASE);\r\nif (finger[id].status != MXT_RELEASE) {\r\nfinger_num++;\r\ninput_report_abs(input_dev, ABS_MT_TOUCH_MAJOR,\r\nfinger[id].area);\r\ninput_report_abs(input_dev, ABS_MT_POSITION_X,\r\nfinger[id].x);\r\ninput_report_abs(input_dev, ABS_MT_POSITION_Y,\r\nfinger[id].y);\r\ninput_report_abs(input_dev, ABS_MT_PRESSURE,\r\nfinger[id].pressure);\r\n} else {\r\nfinger[id].status = 0;\r\n}\r\n}\r\ninput_report_key(input_dev, BTN_TOUCH, finger_num > 0);\r\nif (status != MXT_RELEASE) {\r\ninput_report_abs(input_dev, ABS_X, finger[single_id].x);\r\ninput_report_abs(input_dev, ABS_Y, finger[single_id].y);\r\ninput_report_abs(input_dev,\r\nABS_PRESSURE, finger[single_id].pressure);\r\n}\r\ninput_sync(input_dev);\r\n}\r\nstatic void mxt_input_touchevent(struct mxt_data *data,\r\nstruct mxt_message *message, int id)\r\n{\r\nstruct mxt_finger *finger = data->finger;\r\nstruct device *dev = &data->client->dev;\r\nu8 status = message->message[0];\r\nint x;\r\nint y;\r\nint area;\r\nint pressure;\r\nif (!(status & MXT_DETECT)) {\r\nif (status & MXT_RELEASE) {\r\ndev_dbg(dev, "[%d] released\n", id);\r\nfinger[id].status = MXT_RELEASE;\r\nmxt_input_report(data, id);\r\n}\r\nreturn;\r\n}\r\nif (!(status & (MXT_PRESS | MXT_MOVE)))\r\nreturn;\r\nx = (message->message[1] << 4) | ((message->message[3] >> 4) & 0xf);\r\ny = (message->message[2] << 4) | ((message->message[3] & 0xf));\r\nif (data->max_x < 1024)\r\nx = x >> 2;\r\nif (data->max_y < 1024)\r\ny = y >> 2;\r\narea = message->message[4];\r\npressure = message->message[5];\r\ndev_dbg(dev, "[%d] %s x: %d, y: %d, area: %d\n", id,\r\nstatus & MXT_MOVE ? "moved" : "pressed",\r\nx, y, area);\r\nfinger[id].status = status & MXT_MOVE ?\r\nMXT_MOVE : MXT_PRESS;\r\nfinger[id].x = x;\r\nfinger[id].y = y;\r\nfinger[id].area = area;\r\nfinger[id].pressure = pressure;\r\nmxt_input_report(data, id);\r\n}\r\nstatic irqreturn_t mxt_interrupt(int irq, void *dev_id)\r\n{\r\nstruct mxt_data *data = dev_id;\r\nstruct mxt_message message;\r\nstruct mxt_object *object;\r\nstruct device *dev = &data->client->dev;\r\nint id;\r\nu8 reportid;\r\nu8 max_reportid;\r\nu8 min_reportid;\r\ndo {\r\nif (mxt_read_message(data, &message)) {\r\ndev_err(dev, "Failed to read message\n");\r\ngoto end;\r\n}\r\nreportid = message.reportid;\r\nobject = mxt_get_object(data, MXT_TOUCH_MULTI_T9);\r\nif (!object)\r\ngoto end;\r\nmax_reportid = object->max_reportid;\r\nmin_reportid = max_reportid - object->num_report_ids + 1;\r\nid = reportid - min_reportid;\r\nif (reportid >= min_reportid && reportid <= max_reportid)\r\nmxt_input_touchevent(data, &message, id);\r\nelse\r\nmxt_dump_message(dev, &message);\r\n} while (reportid != 0xff);\r\nend:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mxt_check_reg_init(struct mxt_data *data)\r\n{\r\nconst struct mxt_platform_data *pdata = data->pdata;\r\nstruct mxt_object *object;\r\nstruct device *dev = &data->client->dev;\r\nint index = 0;\r\nint i, j, config_offset;\r\nif (!pdata->config) {\r\ndev_dbg(dev, "No cfg data defined, skipping reg init\n");\r\nreturn 0;\r\n}\r\nfor (i = 0; i < data->info.object_num; i++) {\r\nobject = data->object_table + i;\r\nif (!mxt_object_writable(object->type))\r\ncontinue;\r\nfor (j = 0;\r\nj < (object->size + 1) * (object->instances + 1);\r\nj++) {\r\nconfig_offset = index + j;\r\nif (config_offset > pdata->config_length) {\r\ndev_err(dev, "Not enough config data!\n");\r\nreturn -EINVAL;\r\n}\r\nmxt_write_object(data, object->type, j,\r\npdata->config[config_offset]);\r\n}\r\nindex += (object->size + 1) * (object->instances + 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxt_make_highchg(struct mxt_data *data)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nstruct mxt_message message;\r\nint count = 10;\r\nint error;\r\ndo {\r\nerror = mxt_read_message(data, &message);\r\nif (error)\r\nreturn error;\r\n} while (message.reportid != 0xff && --count);\r\nif (!count) {\r\ndev_err(dev, "CHG pin isn't cleared\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mxt_handle_pdata(struct mxt_data *data)\r\n{\r\nconst struct mxt_platform_data *pdata = data->pdata;\r\nu8 voltage;\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9, MXT_TOUCH_XSIZE,\r\npdata->x_line);\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9, MXT_TOUCH_YSIZE,\r\npdata->y_line);\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9, MXT_TOUCH_ORIENT,\r\npdata->orient);\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9,\r\nMXT_TOUCH_BLEN, pdata->blen);\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9,\r\nMXT_TOUCH_TCHTHR, pdata->threshold);\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9,\r\nMXT_TOUCH_XRANGE_LSB, (pdata->x_size - 1) & 0xff);\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9,\r\nMXT_TOUCH_XRANGE_MSB, (pdata->x_size - 1) >> 8);\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9,\r\nMXT_TOUCH_YRANGE_LSB, (pdata->y_size - 1) & 0xff);\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9,\r\nMXT_TOUCH_YRANGE_MSB, (pdata->y_size - 1) >> 8);\r\nif (pdata->voltage) {\r\nif (pdata->voltage < MXT_VOLTAGE_DEFAULT) {\r\nvoltage = (MXT_VOLTAGE_DEFAULT - pdata->voltage) /\r\nMXT_VOLTAGE_STEP;\r\nvoltage = 0xff - voltage + 1;\r\n} else\r\nvoltage = (pdata->voltage - MXT_VOLTAGE_DEFAULT) /\r\nMXT_VOLTAGE_STEP;\r\nmxt_write_object(data, MXT_SPT_CTECONFIG_T28,\r\nMXT_CTE_VOLTAGE, voltage);\r\n}\r\n}\r\nstatic int mxt_get_info(struct mxt_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nstruct mxt_info *info = &data->info;\r\nint error;\r\nu8 val;\r\nerror = mxt_read_reg(client, MXT_FAMILY_ID, &val);\r\nif (error)\r\nreturn error;\r\ninfo->family_id = val;\r\nerror = mxt_read_reg(client, MXT_VARIANT_ID, &val);\r\nif (error)\r\nreturn error;\r\ninfo->variant_id = val;\r\nerror = mxt_read_reg(client, MXT_VERSION, &val);\r\nif (error)\r\nreturn error;\r\ninfo->version = val;\r\nerror = mxt_read_reg(client, MXT_BUILD, &val);\r\nif (error)\r\nreturn error;\r\ninfo->build = val;\r\nerror = mxt_read_reg(client, MXT_OBJECT_NUM, &val);\r\nif (error)\r\nreturn error;\r\ninfo->object_num = val;\r\nreturn 0;\r\n}\r\nstatic int mxt_get_object_table(struct mxt_data *data)\r\n{\r\nint error;\r\nint i;\r\nu16 reg;\r\nu8 reportid = 0;\r\nu8 buf[MXT_OBJECT_SIZE];\r\nfor (i = 0; i < data->info.object_num; i++) {\r\nstruct mxt_object *object = data->object_table + i;\r\nreg = MXT_OBJECT_START + MXT_OBJECT_SIZE * i;\r\nerror = mxt_read_object_table(data->client, reg, buf);\r\nif (error)\r\nreturn error;\r\nobject->type = buf[0];\r\nobject->start_address = (buf[2] << 8) | buf[1];\r\nobject->size = buf[3];\r\nobject->instances = buf[4];\r\nobject->num_report_ids = buf[5];\r\nif (object->num_report_ids) {\r\nreportid += object->num_report_ids *\r\n(object->instances + 1);\r\nobject->max_reportid = reportid;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxt_initialize(struct mxt_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nstruct mxt_info *info = &data->info;\r\nint error;\r\nu8 val;\r\nerror = mxt_get_info(data);\r\nif (error)\r\nreturn error;\r\ndata->object_table = kcalloc(info->object_num,\r\nsizeof(struct mxt_object),\r\nGFP_KERNEL);\r\nif (!data->object_table) {\r\ndev_err(&client->dev, "Failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nerror = mxt_get_object_table(data);\r\nif (error)\r\nreturn error;\r\nerror = mxt_check_reg_init(data);\r\nif (error)\r\nreturn error;\r\nmxt_handle_pdata(data);\r\nmxt_write_object(data, MXT_GEN_COMMAND_T6,\r\nMXT_COMMAND_BACKUPNV,\r\nMXT_BACKUP_VALUE);\r\nmsleep(MXT_BACKUP_TIME);\r\nmxt_write_object(data, MXT_GEN_COMMAND_T6,\r\nMXT_COMMAND_RESET, 1);\r\nmsleep(MXT_RESET_TIME);\r\nerror = mxt_read_reg(client, MXT_MATRIX_X_SIZE, &val);\r\nif (error)\r\nreturn error;\r\ninfo->matrix_xsize = val;\r\nerror = mxt_read_reg(client, MXT_MATRIX_Y_SIZE, &val);\r\nif (error)\r\nreturn error;\r\ninfo->matrix_ysize = val;\r\ndev_info(&client->dev,\r\n"Family ID: %d Variant ID: %d Version: %d Build: %d\n",\r\ninfo->family_id, info->variant_id, info->version,\r\ninfo->build);\r\ndev_info(&client->dev,\r\n"Matrix X Size: %d Matrix Y Size: %d Object Num: %d\n",\r\ninfo->matrix_xsize, info->matrix_ysize,\r\ninfo->object_num);\r\nreturn 0;\r\n}\r\nstatic void mxt_calc_resolution(struct mxt_data *data)\r\n{\r\nunsigned int max_x = data->pdata->x_size - 1;\r\nunsigned int max_y = data->pdata->y_size - 1;\r\nif (data->pdata->orient & MXT_XY_SWITCH) {\r\ndata->max_x = max_y;\r\ndata->max_y = max_x;\r\n} else {\r\ndata->max_x = max_x;\r\ndata->max_y = max_y;\r\n}\r\n}\r\nstatic ssize_t mxt_object_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mxt_data *data = dev_get_drvdata(dev);\r\nstruct mxt_object *object;\r\nint count = 0;\r\nint i, j;\r\nint error;\r\nu8 val;\r\nfor (i = 0; i < data->info.object_num; i++) {\r\nobject = data->object_table + i;\r\ncount += snprintf(buf + count, PAGE_SIZE - count,\r\n"Object[%d] (Type %d)\n",\r\ni + 1, object->type);\r\nif (count >= PAGE_SIZE)\r\nreturn PAGE_SIZE - 1;\r\nif (!mxt_object_readable(object->type)) {\r\ncount += snprintf(buf + count, PAGE_SIZE - count,\r\n"\n");\r\nif (count >= PAGE_SIZE)\r\nreturn PAGE_SIZE - 1;\r\ncontinue;\r\n}\r\nfor (j = 0; j < object->size + 1; j++) {\r\nerror = mxt_read_object(data,\r\nobject->type, j, &val);\r\nif (error)\r\nreturn error;\r\ncount += snprintf(buf + count, PAGE_SIZE - count,\r\n"\t[%2d]: %02x (%d)\n", j, val, val);\r\nif (count >= PAGE_SIZE)\r\nreturn PAGE_SIZE - 1;\r\n}\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "\n");\r\nif (count >= PAGE_SIZE)\r\nreturn PAGE_SIZE - 1;\r\n}\r\nreturn count;\r\n}\r\nstatic int mxt_load_fw(struct device *dev, const char *fn)\r\n{\r\nstruct mxt_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nconst struct firmware *fw = NULL;\r\nunsigned int frame_size;\r\nunsigned int pos = 0;\r\nint ret;\r\nret = request_firmware(&fw, fn, dev);\r\nif (ret) {\r\ndev_err(dev, "Unable to open firmware %s\n", fn);\r\nreturn ret;\r\n}\r\nmxt_write_object(data, MXT_GEN_COMMAND_T6,\r\nMXT_COMMAND_RESET, MXT_BOOT_VALUE);\r\nmsleep(MXT_RESET_TIME);\r\nif (client->addr == MXT_APP_LOW)\r\nclient->addr = MXT_BOOT_LOW;\r\nelse\r\nclient->addr = MXT_BOOT_HIGH;\r\nret = mxt_check_bootloader(client, MXT_WAITING_BOOTLOAD_CMD);\r\nif (ret)\r\ngoto out;\r\nmxt_unlock_bootloader(client);\r\nwhile (pos < fw->size) {\r\nret = mxt_check_bootloader(client,\r\nMXT_WAITING_FRAME_DATA);\r\nif (ret)\r\ngoto out;\r\nframe_size = ((*(fw->data + pos) << 8) | *(fw->data + pos + 1));\r\nframe_size += 2;\r\nmxt_fw_write(client, fw->data + pos, frame_size);\r\nret = mxt_check_bootloader(client,\r\nMXT_FRAME_CRC_PASS);\r\nif (ret)\r\ngoto out;\r\npos += frame_size;\r\ndev_dbg(dev, "Updated %d bytes / %zd bytes\n", pos, fw->size);\r\n}\r\nout:\r\nrelease_firmware(fw);\r\nif (client->addr == MXT_BOOT_LOW)\r\nclient->addr = MXT_APP_LOW;\r\nelse\r\nclient->addr = MXT_APP_HIGH;\r\nreturn ret;\r\n}\r\nstatic ssize_t mxt_update_fw_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct mxt_data *data = dev_get_drvdata(dev);\r\nint error;\r\ndisable_irq(data->irq);\r\nerror = mxt_load_fw(dev, MXT_FW_NAME);\r\nif (error) {\r\ndev_err(dev, "The firmware update failed(%d)\n", error);\r\ncount = error;\r\n} else {\r\ndev_dbg(dev, "The firmware update succeeded\n");\r\nmsleep(MXT_FWRESET_TIME);\r\nkfree(data->object_table);\r\ndata->object_table = NULL;\r\nmxt_initialize(data);\r\n}\r\nenable_irq(data->irq);\r\nerror = mxt_make_highchg(data);\r\nif (error)\r\nreturn error;\r\nreturn count;\r\n}\r\nstatic void mxt_start(struct mxt_data *data)\r\n{\r\nmxt_write_object(data,\r\nMXT_TOUCH_MULTI_T9, MXT_TOUCH_CTRL, 0x83);\r\n}\r\nstatic void mxt_stop(struct mxt_data *data)\r\n{\r\nmxt_write_object(data,\r\nMXT_TOUCH_MULTI_T9, MXT_TOUCH_CTRL, 0);\r\n}\r\nstatic int mxt_input_open(struct input_dev *dev)\r\n{\r\nstruct mxt_data *data = input_get_drvdata(dev);\r\nmxt_start(data);\r\nreturn 0;\r\n}\r\nstatic void mxt_input_close(struct input_dev *dev)\r\n{\r\nstruct mxt_data *data = input_get_drvdata(dev);\r\nmxt_stop(data);\r\n}\r\nstatic int __devinit mxt_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct mxt_platform_data *pdata = client->dev.platform_data;\r\nstruct mxt_data *data;\r\nstruct input_dev *input_dev;\r\nint error;\r\nif (!pdata)\r\nreturn -EINVAL;\r\ndata = kzalloc(sizeof(struct mxt_data), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!data || !input_dev) {\r\ndev_err(&client->dev, "Failed to allocate memory\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ninput_dev->name = "Atmel maXTouch Touchscreen";\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->dev.parent = &client->dev;\r\ninput_dev->open = mxt_input_open;\r\ninput_dev->close = mxt_input_close;\r\ndata->client = client;\r\ndata->input_dev = input_dev;\r\ndata->pdata = pdata;\r\ndata->irq = client->irq;\r\nmxt_calc_resolution(data);\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_X,\r\n0, data->max_x, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y,\r\n0, data->max_y, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE,\r\n0, 255, 0, 0);\r\ninput_mt_init_slots(input_dev, MXT_MAX_FINGER);\r\ninput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,\r\n0, MXT_MAX_AREA, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_X,\r\n0, data->max_x, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_Y,\r\n0, data->max_y, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_PRESSURE,\r\n0, 255, 0, 0);\r\ninput_set_drvdata(input_dev, data);\r\ni2c_set_clientdata(client, data);\r\nerror = mxt_initialize(data);\r\nif (error)\r\ngoto err_free_object;\r\nerror = request_threaded_irq(client->irq, NULL, mxt_interrupt,\r\npdata->irqflags, client->dev.driver->name, data);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to register interrupt\n");\r\ngoto err_free_object;\r\n}\r\nerror = mxt_make_highchg(data);\r\nif (error)\r\ngoto err_free_irq;\r\nerror = input_register_device(input_dev);\r\nif (error)\r\ngoto err_free_irq;\r\nerror = sysfs_create_group(&client->dev.kobj, &mxt_attr_group);\r\nif (error)\r\ngoto err_unregister_device;\r\nreturn 0;\r\nerr_unregister_device:\r\ninput_unregister_device(input_dev);\r\ninput_dev = NULL;\r\nerr_free_irq:\r\nfree_irq(client->irq, data);\r\nerr_free_object:\r\nkfree(data->object_table);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(data);\r\nreturn error;\r\n}\r\nstatic int __devexit mxt_remove(struct i2c_client *client)\r\n{\r\nstruct mxt_data *data = i2c_get_clientdata(client);\r\nsysfs_remove_group(&client->dev.kobj, &mxt_attr_group);\r\nfree_irq(data->irq, data);\r\ninput_unregister_device(data->input_dev);\r\nkfree(data->object_table);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int mxt_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mxt_data *data = i2c_get_clientdata(client);\r\nstruct input_dev *input_dev = data->input_dev;\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\nmxt_stop(data);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int mxt_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mxt_data *data = i2c_get_clientdata(client);\r\nstruct input_dev *input_dev = data->input_dev;\r\nmxt_write_object(data, MXT_GEN_COMMAND_T6,\r\nMXT_COMMAND_RESET, 1);\r\nmsleep(MXT_RESET_TIME);\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\nmxt_start(data);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int __init mxt_init(void)\r\n{\r\nreturn i2c_add_driver(&mxt_driver);\r\n}\r\nstatic void __exit mxt_exit(void)\r\n{\r\ni2c_del_driver(&mxt_driver);\r\n}
