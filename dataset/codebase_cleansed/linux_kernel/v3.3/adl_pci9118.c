static int __devinit driver_pci9118_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, driver_pci9118.driver_name);\r\n}\r\nstatic void __devexit driver_pci9118_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init driver_pci9118_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&driver_pci9118);\r\nif (retval < 0)\r\nreturn retval;\r\ndriver_pci9118_pci_driver.name = (char *)driver_pci9118.driver_name;\r\nreturn pci_register_driver(&driver_pci9118_pci_driver);\r\n}\r\nstatic void __exit driver_pci9118_cleanup_module(void)\r\n{\r\npci_unregister_driver(&driver_pci9118_pci_driver);\r\ncomedi_driver_unregister(&driver_pci9118);\r\n}\r\nstatic int pci9118_insn_read_ai(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n, timeout;\r\ndevpriv->AdControlReg = AdControl_Int & 0xff;\r\ndevpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;\r\noutl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);\r\nif (!setup_channel_list(dev, s, 1, &insn->chanspec, 0, 0, 0, 0, 0))\r\nreturn -EINVAL;\r\noutl(0, dev->iobase + PCI9118_DELFIFO);\r\nfor (n = 0; n < insn->n; n++) {\r\noutw(0, dev->iobase + PCI9118_SOFTTRG);\r\nudelay(2);\r\ntimeout = 100;\r\nwhile (timeout--) {\r\nif (inl(dev->iobase + PCI9118_ADSTAT) & AdStatus_ADrdy)\r\ngoto conv_finish;\r\nudelay(1);\r\n}\r\ncomedi_error(dev, "A/D insn timeout");\r\ndata[n] = 0;\r\noutl(0, dev->iobase + PCI9118_DELFIFO);\r\nreturn -ETIME;\r\nconv_finish:\r\nif (devpriv->ai16bits) {\r\ndata[n] =\r\n(inl(dev->iobase +\r\nPCI9118_AD_DATA) & 0xffff) ^ 0x8000;\r\n} else {\r\ndata[n] =\r\n(inw(dev->iobase + PCI9118_AD_DATA) >> 4) & 0xfff;\r\n}\r\n}\r\noutl(0, dev->iobase + PCI9118_DELFIFO);\r\nreturn n;\r\n}\r\nstatic int pci9118_insn_write_ao(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n, chanreg, ch;\r\nch = CR_CHAN(insn->chanspec);\r\nif (ch)\r\nchanreg = PCI9118_DA2;\r\nelse\r\nchanreg = PCI9118_DA1;\r\nfor (n = 0; n < insn->n; n++) {\r\noutl(data[n], dev->iobase + chanreg);\r\ndevpriv->ao_data[ch] = data[n];\r\n}\r\nreturn n;\r\n}\r\nstatic int pci9118_insn_read_ao(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n, chan;\r\nchan = CR_CHAN(insn->chanspec);\r\nfor (n = 0; n < insn->n; n++)\r\ndata[n] = devpriv->ao_data[chan];\r\nreturn n;\r\n}\r\nstatic int pci9118_insn_bits_di(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[1] = inl(dev->iobase + PCI9118_DI) & 0xf;\r\nreturn 2;\r\n}\r\nstatic int pci9118_insn_bits_do(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= (data[0] & data[1]);\r\noutl(s->state & 0x0f, dev->iobase + PCI9118_DO);\r\n}\r\ndata[1] = s->state;\r\nreturn 2;\r\n}\r\nstatic void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)\r\n{\r\ndevpriv->AdFunctionReg =\r\nAdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;\r\noutl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);\r\noutl(0x30, dev->iobase + PCI9118_CNTCTRL);\r\noutl((devpriv->dmabuf_hw[1 - devpriv->dma_actbuf] >> 1) & 0xff,\r\ndev->iobase + PCI9118_CNT0);\r\noutl((devpriv->dmabuf_hw[1 - devpriv->dma_actbuf] >> 9) & 0xff,\r\ndev->iobase + PCI9118_CNT0);\r\ndevpriv->AdFunctionReg |= AdFunction_Start;\r\noutl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);\r\n}\r\nstatic unsigned int defragment_dma_buffer(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nshort *dma_buffer,\r\nunsigned int num_samples)\r\n{\r\nunsigned int i = 0, j = 0;\r\nunsigned int start_pos = devpriv->ai_add_front,\r\nstop_pos = devpriv->ai_add_front + devpriv->ai_n_chan;\r\nunsigned int raw_scanlen = devpriv->ai_add_front + devpriv->ai_n_chan +\r\ndevpriv->ai_add_back;\r\nfor (i = 0; i < num_samples; i++) {\r\nif (devpriv->ai_act_dmapos >= start_pos &&\r\ndevpriv->ai_act_dmapos < stop_pos) {\r\ndma_buffer[j++] = dma_buffer[i];\r\n}\r\ndevpriv->ai_act_dmapos++;\r\ndevpriv->ai_act_dmapos %= raw_scanlen;\r\n}\r\nreturn j;\r\n}\r\nstatic int move_block_from_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nshort *dma_buffer,\r\nunsigned int num_samples)\r\n{\r\nunsigned int num_bytes;\r\nnum_samples = defragment_dma_buffer(dev, s, dma_buffer, num_samples);\r\ndevpriv->ai_act_scan +=\r\n(s->async->cur_chan + num_samples) / devpriv->ai_n_scanlen;\r\ns->async->cur_chan += num_samples;\r\ns->async->cur_chan %= devpriv->ai_n_scanlen;\r\nnum_bytes =\r\ncfc_write_array_to_buffer(s, dma_buffer,\r\nnum_samples * sizeof(short));\r\nif (num_bytes < num_samples * sizeof(short))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic char pci9118_decode_error_status(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned char m)\r\n{\r\nif (m & 0x100) {\r\ncomedi_error(dev, "A/D FIFO Full status (Fatal Error!)");\r\ndevpriv->ai_maskerr &= ~0x100L;\r\n}\r\nif (m & 0x008) {\r\ncomedi_error(dev,\r\n"A/D Burst Mode Overrun Status (Fatal Error!)");\r\ndevpriv->ai_maskerr &= ~0x008L;\r\n}\r\nif (m & 0x004) {\r\ncomedi_error(dev, "A/D Over Speed Status (Warning!)");\r\ndevpriv->ai_maskerr &= ~0x004L;\r\n}\r\nif (m & 0x002) {\r\ncomedi_error(dev, "A/D Overrun Status (Fatal Error!)");\r\ndevpriv->ai_maskerr &= ~0x002L;\r\n}\r\nif (m & devpriv->ai_maskharderr) {\r\ns->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\npci9118_ai_cancel(dev, s);\r\ncomedi_event(dev, s);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pci9118_ai_munge(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, void *data,\r\nunsigned int num_bytes,\r\nunsigned int start_chan_index)\r\n{\r\nunsigned int i, num_samples = num_bytes / sizeof(short);\r\nshort *array = data;\r\nfor (i = 0; i < num_samples; i++) {\r\nif (devpriv->usedma)\r\narray[i] = be16_to_cpu(array[i]);\r\nif (devpriv->ai16bits)\r\narray[i] ^= 0x8000;\r\nelse\r\narray[i] = (array[i] >> 4) & 0x0fff;\r\n}\r\n}\r\nstatic void interrupt_pci9118_ai_onesample(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned short int_adstat,\r\nunsigned int int_amcc,\r\nunsigned short int_daq)\r\n{\r\nregister short sampl;\r\ns->async->events = 0;\r\nif (int_adstat & devpriv->ai_maskerr)\r\nif (pci9118_decode_error_status(dev, s, int_adstat))\r\nreturn;\r\nsampl = inw(dev->iobase + PCI9118_AD_DATA);\r\n#ifdef PCI9118_PARANOIDCHECK\r\nif (devpriv->ai16bits == 0) {\r\nif ((sampl & 0x000f) != devpriv->chanlist[s->async->cur_chan]) {\r\nprintk\r\n("comedi: A/D SAMPL - data dropout: "\r\n"received channel %d, expected %d!\n",\r\nsampl & 0x000f,\r\ndevpriv->chanlist[s->async->cur_chan]);\r\ns->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\npci9118_ai_cancel(dev, s);\r\ncomedi_event(dev, s);\r\nreturn;\r\n}\r\n}\r\n#endif\r\ncfc_write_to_buffer(s, sampl);\r\ns->async->cur_chan++;\r\nif (s->async->cur_chan >= devpriv->ai_n_scanlen) {\r\ns->async->cur_chan %= devpriv->ai_n_scanlen;\r\ndevpriv->ai_act_scan++;\r\nif (!(devpriv->ai_neverending))\r\nif (devpriv->ai_act_scan >= devpriv->ai_scans) {\r\npci9118_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA;\r\n}\r\n}\r\nif (s->async->events)\r\ncomedi_event(dev, s);\r\n}\r\nstatic void interrupt_pci9118_ai_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned short int_adstat,\r\nunsigned int int_amcc,\r\nunsigned short int_daq)\r\n{\r\nunsigned int next_dma_buf, samplesinbuf, sampls, m;\r\nif (int_amcc & MASTER_ABORT_INT) {\r\ncomedi_error(dev, "AMCC IRQ - MASTER DMA ABORT!");\r\ns->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\npci9118_ai_cancel(dev, s);\r\ncomedi_event(dev, s);\r\nreturn;\r\n}\r\nif (int_amcc & TARGET_ABORT_INT) {\r\ncomedi_error(dev, "AMCC IRQ - TARGET DMA ABORT!");\r\ns->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\npci9118_ai_cancel(dev, s);\r\ncomedi_event(dev, s);\r\nreturn;\r\n}\r\nif (int_adstat & devpriv->ai_maskerr)\r\nif (pci9118_decode_error_status(dev, s, int_adstat))\r\nreturn;\r\nsamplesinbuf = devpriv->dmabuf_use_size[devpriv->dma_actbuf] >> 1;\r\nif (devpriv->dma_doublebuf) {\r\nnext_dma_buf = 1 - devpriv->dma_actbuf;\r\noutl(devpriv->dmabuf_hw[next_dma_buf],\r\ndevpriv->iobase_a + AMCC_OP_REG_MWAR);\r\noutl(devpriv->dmabuf_use_size[next_dma_buf],\r\ndevpriv->iobase_a + AMCC_OP_REG_MWTC);\r\ndevpriv->dmabuf_used_size[next_dma_buf] =\r\ndevpriv->dmabuf_use_size[next_dma_buf];\r\nif (devpriv->ai_do == 4)\r\ninterrupt_pci9118_ai_mode4_switch(dev);\r\n}\r\nif (samplesinbuf) {\r\nm = devpriv->ai_data_len >> 1;\r\nsampls = m;\r\nmove_block_from_dma(dev, s,\r\ndevpriv->dmabuf_virt[devpriv->dma_actbuf],\r\nsamplesinbuf);\r\nm = m - sampls;\r\n}\r\nif (!devpriv->ai_neverending)\r\nif (devpriv->ai_act_scan >= devpriv->ai_scans) {\r\npci9118_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA;\r\n}\r\nif (devpriv->dma_doublebuf) {\r\ndevpriv->dma_actbuf = 1 - devpriv->dma_actbuf;\r\n} else {\r\noutl(devpriv->dmabuf_hw[0],\r\ndevpriv->iobase_a + AMCC_OP_REG_MWAR);\r\noutl(devpriv->dmabuf_use_size[0],\r\ndevpriv->iobase_a + AMCC_OP_REG_MWTC);\r\nif (devpriv->ai_do == 4)\r\ninterrupt_pci9118_ai_mode4_switch(dev);\r\n}\r\ncomedi_event(dev, s);\r\n}\r\nstatic irqreturn_t interrupt_pci9118(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nunsigned int int_daq = 0, int_amcc, int_adstat;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\nint_daq = inl(dev->iobase + PCI9118_INTSRC) & 0xf;\r\nint_amcc = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);\r\nif ((!int_daq) && (!(int_amcc & ANY_S593X_INT)))\r\nreturn IRQ_NONE;\r\noutl(int_amcc | 0x00ff0000, devpriv->iobase_a + AMCC_OP_REG_INTCSR);\r\nint_adstat = inw(dev->iobase + PCI9118_ADSTAT) & 0x1ff;\r\nif (devpriv->ai_do) {\r\nif (devpriv->ai12_startstop)\r\nif ((int_adstat & AdStatus_DTH) &&\r\n(int_daq & Int_DTrg)) {\r\nif (devpriv->ai12_startstop & START_AI_EXT) {\r\ndevpriv->ai12_startstop &=\r\n~START_AI_EXT;\r\nif (!(devpriv->ai12_startstop &\r\nSTOP_AI_EXT))\r\npci9118_exttrg_del\r\n(dev, EXTTRG_AI);\r\nstart_pacer(dev, devpriv->ai_do,\r\ndevpriv->ai_divisor1,\r\ndevpriv->ai_divisor2);\r\noutl(devpriv->AdControlReg,\r\ndev->iobase + PCI9118_ADCNTRL);\r\n} else {\r\nif (devpriv->ai12_startstop &\r\nSTOP_AI_EXT) {\r\ndevpriv->ai12_startstop &=\r\n~STOP_AI_EXT;\r\npci9118_exttrg_del\r\n(dev, EXTTRG_AI);\r\ndevpriv->ai_neverending = 0;\r\n}\r\n}\r\n}\r\n(devpriv->int_ai_func) (dev, dev->subdevices + 0, int_adstat,\r\nint_amcc, int_daq);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pci9118_ai_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, unsigned int trignum)\r\n{\r\nif (trignum != devpriv->ai_inttrig_start)\r\nreturn -EINVAL;\r\ndevpriv->ai12_startstop &= ~START_AI_INT;\r\ns->async->inttrig = NULL;\r\noutl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);\r\noutl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);\r\nif (devpriv->ai_do != 3) {\r\nstart_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1,\r\ndevpriv->ai_divisor2);\r\ndevpriv->AdControlReg |= AdControl_SoftG;\r\n}\r\noutl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);\r\nreturn 1;\r\n}\r\nstatic int pci9118_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\nunsigned int divisor1 = 0, divisor2 = 0;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW | TRIG_EXT | TRIG_INT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\nif (devpriv->master)\r\ncmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT | TRIG_FOLLOW;\r\nelse\r\ncmd->scan_begin_src &= TRIG_FOLLOW;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\nif (devpriv->master)\r\ncmd->convert_src &= TRIG_TIMER | TRIG_EXT | TRIG_NOW;\r\nelse\r\ncmd->convert_src &= TRIG_TIMER | TRIG_EXT;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE | TRIG_EXT;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->start_src != TRIG_NOW &&\r\ncmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT) {\r\ncmd->start_src = TRIG_NOW;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src != TRIG_TIMER &&\r\ncmd->scan_begin_src != TRIG_EXT &&\r\ncmd->scan_begin_src != TRIG_INT &&\r\ncmd->scan_begin_src != TRIG_FOLLOW) {\r\ncmd->scan_begin_src = TRIG_FOLLOW;\r\nerr++;\r\n}\r\nif (cmd->convert_src != TRIG_TIMER &&\r\ncmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW) {\r\ncmd->convert_src = TRIG_TIMER;\r\nerr++;\r\n}\r\nif (cmd->scan_end_src != TRIG_COUNT) {\r\ncmd->scan_end_src = TRIG_COUNT;\r\nerr++;\r\n}\r\nif (cmd->stop_src != TRIG_NONE &&\r\ncmd->stop_src != TRIG_COUNT &&\r\ncmd->stop_src != TRIG_INT && cmd->stop_src != TRIG_EXT) {\r\ncmd->stop_src = TRIG_COUNT;\r\nerr++;\r\n}\r\nif (cmd->start_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT) {\r\ncmd->start_src = TRIG_NOW;\r\nerr++;\r\n}\r\nif (cmd->start_src == TRIG_INT && cmd->scan_begin_src == TRIG_INT) {\r\ncmd->start_src = TRIG_NOW;\r\nerr++;\r\n}\r\nif ((cmd->scan_begin_src & (TRIG_TIMER | TRIG_EXT)) &&\r\n(!(cmd->convert_src & (TRIG_TIMER | TRIG_NOW)))) {\r\ncmd->convert_src = TRIG_TIMER;\r\nerr++;\r\n}\r\nif ((cmd->scan_begin_src == TRIG_FOLLOW) &&\r\n(!(cmd->convert_src & (TRIG_TIMER | TRIG_EXT)))) {\r\ncmd->convert_src = TRIG_TIMER;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT) {\r\ncmd->stop_src = TRIG_COUNT;\r\nerr++;\r\n}\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_src & (TRIG_NOW | TRIG_EXT))\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src & (TRIG_FOLLOW | TRIG_EXT))\r\nif (cmd->scan_begin_arg != 0) {\r\ncmd->scan_begin_arg = 0;\r\nerr++;\r\n}\r\nif ((cmd->scan_begin_src == TRIG_TIMER) &&\r\n(cmd->convert_src == TRIG_TIMER) && (cmd->scan_end_arg == 1)) {\r\ncmd->scan_begin_src = TRIG_FOLLOW;\r\ncmd->convert_arg = cmd->scan_begin_arg;\r\ncmd->scan_begin_arg = 0;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER)\r\nif (cmd->scan_begin_arg < this_board->ai_ns_min) {\r\ncmd->scan_begin_arg = this_board->ai_ns_min;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src == TRIG_EXT)\r\nif (cmd->scan_begin_arg) {\r\ncmd->scan_begin_arg = 0;\r\nerr++;\r\nif (cmd->scan_end_arg > 65535) {\r\ncmd->scan_end_arg = 65535;\r\nerr++;\r\n}\r\n}\r\nif (cmd->convert_src & (TRIG_TIMER | TRIG_NOW))\r\nif (cmd->convert_arg < this_board->ai_ns_min) {\r\ncmd->convert_arg = this_board->ai_ns_min;\r\nerr++;\r\n}\r\nif (cmd->convert_src == TRIG_EXT)\r\nif (cmd->convert_arg) {\r\ncmd->convert_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (!cmd->stop_arg) {\r\ncmd->stop_arg = 1;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (!cmd->chanlist_len) {\r\ncmd->chanlist_len = 1;\r\nerr++;\r\n}\r\nif (cmd->chanlist_len > this_board->n_aichanlist) {\r\ncmd->chanlist_len = this_board->n_aichanlist;\r\nerr++;\r\n}\r\nif (cmd->scan_end_arg < cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif ((cmd->scan_end_arg % cmd->chanlist_len)) {\r\ncmd->scan_end_arg =\r\ncmd->chanlist_len * (cmd->scan_end_arg / cmd->chanlist_len);\r\nerr++;\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp = cmd->scan_begin_arg;\r\ni8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,\r\n&divisor2, &cmd->scan_begin_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (cmd->scan_begin_arg < this_board->ai_ns_min)\r\ncmd->scan_begin_arg = this_board->ai_ns_min;\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (cmd->convert_src & (TRIG_TIMER | TRIG_NOW)) {\r\ntmp = cmd->convert_arg;\r\ni8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,\r\n&divisor2, &cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (cmd->convert_arg < this_board->ai_ns_min)\r\ncmd->convert_arg = this_board->ai_ns_min;\r\nif (tmp != cmd->convert_arg)\r\nerr++;\r\nif (cmd->scan_begin_src == TRIG_TIMER\r\n&& cmd->convert_src == TRIG_NOW) {\r\nif (cmd->convert_arg == 0) {\r\nif (cmd->scan_begin_arg <\r\nthis_board->ai_ns_min *\r\n(cmd->scan_end_arg + 2)) {\r\ncmd->scan_begin_arg =\r\nthis_board->ai_ns_min *\r\n(cmd->scan_end_arg + 2);\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->scan_begin_arg <\r\ncmd->convert_arg * cmd->chanlist_len) {\r\ncmd->scan_begin_arg =\r\ncmd->convert_arg *\r\ncmd->chanlist_len;\r\nerr++;\r\n}\r\n}\r\n}\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist)\r\nif (!check_channel_list(dev, s, cmd->chanlist_len,\r\ncmd->chanlist, 0, 0))\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int Compute_and_setup_dma(struct comedi_device *dev)\r\n{\r\nunsigned int dmalen0, dmalen1, i;\r\nDPRINTK("adl_pci9118 EDBG: BGN: Compute_and_setup_dma()\n");\r\ndmalen0 = devpriv->dmabuf_size[0];\r\ndmalen1 = devpriv->dmabuf_size[1];\r\nDPRINTK("1 dmalen0=%d dmalen1=%d ai_data_len=%d\n", dmalen0, dmalen1,\r\ndevpriv->ai_data_len);\r\nif (dmalen0 > (devpriv->ai_data_len)) {\r\ndmalen0 = devpriv->ai_data_len & ~3L;\r\n}\r\nif (dmalen1 > (devpriv->ai_data_len)) {\r\ndmalen1 = devpriv->ai_data_len & ~3L;\r\n}\r\nDPRINTK("2 dmalen0=%d dmalen1=%d\n", dmalen0, dmalen1);\r\nif (devpriv->ai_flags & TRIG_WAKE_EOS) {\r\nif (dmalen0 < (devpriv->ai_n_realscanlen << 1)) {\r\ndevpriv->ai_flags &= (~TRIG_WAKE_EOS);\r\nprintk\r\n("comedi%d: WAR: DMA0 buf too short, can't "\r\n"support TRIG_WAKE_EOS (%d<%d)\n",\r\ndev->minor, dmalen0,\r\ndevpriv->ai_n_realscanlen << 1);\r\n} else {\r\ndmalen0 = devpriv->ai_n_realscanlen << 1;\r\nDPRINTK\r\n("21 dmalen0=%d ai_n_realscanlen=%d "\r\n"useeoshandle=%d\n",\r\ndmalen0, devpriv->ai_n_realscanlen,\r\ndevpriv->useeoshandle);\r\nif (devpriv->useeoshandle)\r\ndmalen0 += 2;\r\nif (dmalen0 < 4) {\r\nprintk\r\n("comedi%d: ERR: DMA0 buf len bug? "\r\n"(%d<4)\n",\r\ndev->minor, dmalen0);\r\ndmalen0 = 4;\r\n}\r\n}\r\n}\r\nif (devpriv->ai_flags & TRIG_WAKE_EOS) {\r\nif (dmalen1 < (devpriv->ai_n_realscanlen << 1)) {\r\ndevpriv->ai_flags &= (~TRIG_WAKE_EOS);\r\nprintk\r\n("comedi%d: WAR: DMA1 buf too short, "\r\n"can't support TRIG_WAKE_EOS (%d<%d)\n",\r\ndev->minor, dmalen1,\r\ndevpriv->ai_n_realscanlen << 1);\r\n} else {\r\ndmalen1 = devpriv->ai_n_realscanlen << 1;\r\nDPRINTK\r\n("22 dmalen1=%d ai_n_realscanlen=%d "\r\n"useeoshandle=%d\n",\r\ndmalen1, devpriv->ai_n_realscanlen,\r\ndevpriv->useeoshandle);\r\nif (devpriv->useeoshandle)\r\ndmalen1 -= 2;\r\nif (dmalen1 < 4) {\r\nprintk\r\n("comedi%d: ERR: DMA1 buf len bug? "\r\n"(%d<4)\n",\r\ndev->minor, dmalen1);\r\ndmalen1 = 4;\r\n}\r\n}\r\n}\r\nDPRINTK("3 dmalen0=%d dmalen1=%d\n", dmalen0, dmalen1);\r\nif (!(devpriv->ai_flags & TRIG_WAKE_EOS)) {\r\ni = dmalen0;\r\ndmalen0 =\r\n(dmalen0 / (devpriv->ai_n_realscanlen << 1)) *\r\n(devpriv->ai_n_realscanlen << 1);\r\ndmalen0 &= ~3L;\r\nif (!dmalen0)\r\ndmalen0 = i;\r\ni = dmalen1;\r\ndmalen1 =\r\n(dmalen1 / (devpriv->ai_n_realscanlen << 1)) *\r\n(devpriv->ai_n_realscanlen << 1);\r\ndmalen1 &= ~3L;\r\nif (!dmalen1)\r\ndmalen1 = i;\r\nif (!devpriv->ai_neverending) {\r\nif (dmalen0 >\r\n((devpriv->ai_n_realscanlen << 1) *\r\ndevpriv->ai_scans)) {\r\nDPRINTK\r\n("3.0 ai_n_realscanlen=%d ai_scans=%d\n",\r\ndevpriv->ai_n_realscanlen,\r\ndevpriv->ai_scans);\r\ndmalen0 =\r\n(devpriv->ai_n_realscanlen << 1) *\r\ndevpriv->ai_scans;\r\nDPRINTK("3.1 dmalen0=%d dmalen1=%d\n", dmalen0,\r\ndmalen1);\r\ndmalen0 &= ~3L;\r\n} else {\r\nif (dmalen1 >\r\n((devpriv->ai_n_realscanlen << 1) *\r\ndevpriv->ai_scans - dmalen0))\r\ndmalen1 =\r\n(devpriv->ai_n_realscanlen << 1) *\r\ndevpriv->ai_scans - dmalen0;\r\nDPRINTK("3.2 dmalen0=%d dmalen1=%d\n", dmalen0,\r\ndmalen1);\r\ndmalen1 &= ~3L;\r\n}\r\n}\r\n}\r\nDPRINTK("4 dmalen0=%d dmalen1=%d\n", dmalen0, dmalen1);\r\ndevpriv->dma_actbuf = 0;\r\ndevpriv->dmabuf_use_size[0] = dmalen0;\r\ndevpriv->dmabuf_use_size[1] = dmalen1;\r\nDPRINTK("5 dmalen0=%d dmalen1=%d\n", dmalen0, dmalen1);\r\n#if 0\r\nif (devpriv->ai_n_scanlen < this_board->half_fifo_size) {\r\ndevpriv->dmabuf_panic_size[0] =\r\n(this_board->half_fifo_size / devpriv->ai_n_scanlen +\r\n1) * devpriv->ai_n_scanlen * sizeof(short);\r\ndevpriv->dmabuf_panic_size[1] =\r\n(this_board->half_fifo_size / devpriv->ai_n_scanlen +\r\n1) * devpriv->ai_n_scanlen * sizeof(short);\r\n} else {\r\ndevpriv->dmabuf_panic_size[0] =\r\n(devpriv->ai_n_scanlen << 1) % devpriv->dmabuf_size[0];\r\ndevpriv->dmabuf_panic_size[1] =\r\n(devpriv->ai_n_scanlen << 1) % devpriv->dmabuf_size[1];\r\n}\r\n#endif\r\noutl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS),\r\ndevpriv->iobase_a + AMCC_OP_REG_MCSR);\r\noutl(devpriv->dmabuf_hw[0], devpriv->iobase_a + AMCC_OP_REG_MWAR);\r\noutl(devpriv->dmabuf_use_size[0], devpriv->iobase_a + AMCC_OP_REG_MWTC);\r\noutl(0x00000000 | AINT_WRITE_COMPL,\r\ndevpriv->iobase_a + AMCC_OP_REG_INTCSR);\r\noutl(inl(devpriv->iobase_a +\r\nAMCC_OP_REG_MCSR) | RESET_A2P_FLAGS | A2P_HI_PRIORITY |\r\nEN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_MCSR);\r\noutl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | EN_A2P_TRANSFERS,\r\ndevpriv->iobase_a + AMCC_OP_REG_INTCSR);\r\nDPRINTK("adl_pci9118 EDBG: END: Compute_and_setup_dma()\n");\r\nreturn 0;\r\n}\r\nstatic int pci9118_ai_docmd_sampl(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nDPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_sampl(%d,) [%d]\n",\r\ndev->minor, devpriv->ai_do);\r\nswitch (devpriv->ai_do) {\r\ncase 1:\r\ndevpriv->AdControlReg |= AdControl_TmrTr;\r\nbreak;\r\ncase 2:\r\ncomedi_error(dev, "pci9118_ai_docmd_sampl() mode 2 bug!\n");\r\nreturn -EIO;\r\ncase 3:\r\ndevpriv->AdControlReg |= AdControl_ExtM;\r\nbreak;\r\ncase 4:\r\ncomedi_error(dev, "pci9118_ai_docmd_sampl() mode 4 bug!\n");\r\nreturn -EIO;\r\ndefault:\r\ncomedi_error(dev,\r\n"pci9118_ai_docmd_sampl() mode number bug!\n");\r\nreturn -EIO;\r\n}\r\ndevpriv->int_ai_func = interrupt_pci9118_ai_onesample;\r\nif (devpriv->ai12_startstop)\r\npci9118_exttrg_add(dev, EXTTRG_AI);\r\nif ((devpriv->ai_do == 1) || (devpriv->ai_do == 2))\r\ndevpriv->IntControlReg |= Int_Timer;\r\ndevpriv->AdControlReg |= AdControl_Int;\r\noutl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,\r\ndevpriv->iobase_a + AMCC_OP_REG_INTCSR);\r\nif (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {\r\noutl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);\r\noutl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);\r\nif (devpriv->ai_do != 3) {\r\nstart_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1,\r\ndevpriv->ai_divisor2);\r\ndevpriv->AdControlReg |= AdControl_SoftG;\r\n}\r\noutl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);\r\n}\r\nDPRINTK("adl_pci9118 EDBG: END: pci9118_ai_docmd_sampl()\n");\r\nreturn 0;\r\n}\r\nstatic int pci9118_ai_docmd_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nDPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_dma(%d,) [%d,%d]\n",\r\ndev->minor, devpriv->ai_do, devpriv->usedma);\r\nCompute_and_setup_dma(dev);\r\nswitch (devpriv->ai_do) {\r\ncase 1:\r\ndevpriv->AdControlReg |=\r\n((AdControl_TmrTr | AdControl_Dma) & 0xff);\r\nbreak;\r\ncase 2:\r\ndevpriv->AdControlReg |=\r\n((AdControl_TmrTr | AdControl_Dma) & 0xff);\r\ndevpriv->AdFunctionReg =\r\nAdFunction_PDTrg | AdFunction_PETrg | AdFunction_BM |\r\nAdFunction_BS;\r\nif (devpriv->usessh && (!devpriv->softsshdelay))\r\ndevpriv->AdFunctionReg |= AdFunction_BSSH;\r\noutl(devpriv->ai_n_realscanlen, dev->iobase + PCI9118_BURST);\r\nbreak;\r\ncase 3:\r\ndevpriv->AdControlReg |=\r\n((AdControl_ExtM | AdControl_Dma) & 0xff);\r\ndevpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;\r\nbreak;\r\ncase 4:\r\ndevpriv->AdControlReg |=\r\n((AdControl_TmrTr | AdControl_Dma) & 0xff);\r\ndevpriv->AdFunctionReg =\r\nAdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;\r\noutl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);\r\noutl(0x30, dev->iobase + PCI9118_CNTCTRL);\r\noutl((devpriv->dmabuf_hw[0] >> 1) & 0xff,\r\ndev->iobase + PCI9118_CNT0);\r\noutl((devpriv->dmabuf_hw[0] >> 9) & 0xff,\r\ndev->iobase + PCI9118_CNT0);\r\ndevpriv->AdFunctionReg |= AdFunction_Start;\r\nbreak;\r\ndefault:\r\ncomedi_error(dev, "pci9118_ai_docmd_dma() mode number bug!\n");\r\nreturn -EIO;\r\n}\r\nif (devpriv->ai12_startstop) {\r\npci9118_exttrg_add(dev, EXTTRG_AI);\r\n}\r\ndevpriv->int_ai_func = interrupt_pci9118_ai_dma;\r\noutl(0x02000000 | AINT_WRITE_COMPL,\r\ndevpriv->iobase_a + AMCC_OP_REG_INTCSR);\r\nif (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {\r\noutl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);\r\noutl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);\r\nif (devpriv->ai_do != 3) {\r\nstart_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1,\r\ndevpriv->ai_divisor2);\r\ndevpriv->AdControlReg |= AdControl_SoftG;\r\n}\r\noutl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);\r\n}\r\nDPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_dma()\n");\r\nreturn 0;\r\n}\r\nstatic int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int addchans = 0;\r\nint ret = 0;\r\nDPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_cmd(%d,)\n", dev->minor);\r\ndevpriv->ai12_startstop = 0;\r\ndevpriv->ai_flags = cmd->flags;\r\ndevpriv->ai_n_chan = cmd->chanlist_len;\r\ndevpriv->ai_n_scanlen = cmd->scan_end_arg;\r\ndevpriv->ai_chanlist = cmd->chanlist;\r\ndevpriv->ai_data = s->async->prealloc_buf;\r\ndevpriv->ai_data_len = s->async->prealloc_bufsz;\r\ndevpriv->ai_timer1 = 0;\r\ndevpriv->ai_timer2 = 0;\r\ndevpriv->ai_add_front = 0;\r\ndevpriv->ai_add_back = 0;\r\ndevpriv->ai_maskerr = 0x10e;\r\nif (cmd->start_src == TRIG_EXT)\r\ndevpriv->ai12_startstop |= START_AI_EXT;\r\nif (cmd->stop_src == TRIG_EXT) {\r\ndevpriv->ai_neverending = 1;\r\ndevpriv->ai12_startstop |= STOP_AI_EXT;\r\n}\r\nif (cmd->start_src == TRIG_INT) {\r\ndevpriv->ai12_startstop |= START_AI_INT;\r\ndevpriv->ai_inttrig_start = cmd->start_arg;\r\ns->async->inttrig = pci9118_ai_inttrig;\r\n}\r\n#if 0\r\nif (cmd->stop_src == TRIG_INT) {\r\ndevpriv->ai_neverending = 1;\r\ndevpriv->ai12_startstop |= STOP_AI_INT;\r\n}\r\n#endif\r\nif (cmd->stop_src == TRIG_NONE)\r\ndevpriv->ai_neverending = 1;\r\nif (cmd->stop_src == TRIG_COUNT) {\r\ndevpriv->ai_scans = cmd->stop_arg;\r\ndevpriv->ai_neverending = 0;\r\n} else {\r\ndevpriv->ai_scans = 0;\r\n}\r\nif (cmd->convert_src == TRIG_NOW)\r\ndevpriv->usessh = 1;\r\nelse\r\ndevpriv->usessh = 0;\r\nDPRINTK("1 neverending=%d scans=%u usessh=%d ai_startstop=0x%2x\n",\r\ndevpriv->ai_neverending, devpriv->ai_scans, devpriv->usessh,\r\ndevpriv->ai12_startstop);\r\ndevpriv->ai_add_front = 0;\r\ndevpriv->ai_add_back = 0;\r\ndevpriv->useeoshandle = 0;\r\nif (devpriv->master) {\r\ndevpriv->usedma = 1;\r\nif ((cmd->flags & TRIG_WAKE_EOS) &&\r\n(devpriv->ai_n_scanlen == 1)) {\r\nif (cmd->convert_src == TRIG_NOW)\r\ndevpriv->ai_add_back = 1;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ndevpriv->usedma = 0;\r\n}\r\n}\r\nif ((cmd->flags & TRIG_WAKE_EOS) &&\r\n(devpriv->ai_n_scanlen & 1) &&\r\n(devpriv->ai_n_scanlen > 1)) {\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\ndevpriv->usedma = 0;\r\n} else {\r\ndevpriv->ai_add_back = 1;\r\n}\r\n}\r\n} else {\r\ndevpriv->usedma = 0;\r\n}\r\nif (devpriv->usessh && devpriv->softsshdelay) {\r\ndevpriv->ai_add_front = 2;\r\nif ((devpriv->usedma == 1) && (devpriv->ai_add_back == 1)) {\r\ndevpriv->ai_add_front++;\r\ndevpriv->ai_add_back = 0;\r\n}\r\nif (cmd->convert_arg < this_board->ai_ns_min)\r\ncmd->convert_arg = this_board->ai_ns_min;\r\naddchans = devpriv->softsshdelay / cmd->convert_arg;\r\nif (devpriv->softsshdelay % cmd->convert_arg)\r\naddchans++;\r\nif (addchans > (devpriv->ai_add_front - 1)) {\r\ndevpriv->ai_add_front = addchans + 1;\r\nif (devpriv->usedma == 1)\r\nif ((devpriv->ai_add_front +\r\ndevpriv->ai_n_chan +\r\ndevpriv->ai_add_back) & 1)\r\ndevpriv->ai_add_front++;\r\n}\r\n}\r\ndevpriv->ai_n_realscanlen =\r\n(devpriv->ai_add_front + devpriv->ai_n_chan +\r\ndevpriv->ai_add_back) * (devpriv->ai_n_scanlen /\r\ndevpriv->ai_n_chan);\r\nDPRINTK("2 usedma=%d realscan=%d af=%u n_chan=%d ab=%d n_scanlen=%d\n",\r\ndevpriv->usedma,\r\ndevpriv->ai_n_realscanlen, devpriv->ai_add_front,\r\ndevpriv->ai_n_chan, devpriv->ai_add_back,\r\ndevpriv->ai_n_scanlen);\r\nif (!check_channel_list(dev, s, devpriv->ai_n_chan,\r\ndevpriv->ai_chanlist, devpriv->ai_add_front,\r\ndevpriv->ai_add_back))\r\nreturn -EINVAL;\r\nif (!setup_channel_list(dev, s, devpriv->ai_n_chan,\r\ndevpriv->ai_chanlist, 0, devpriv->ai_add_front,\r\ndevpriv->ai_add_back, devpriv->usedma,\r\ndevpriv->useeoshandle))\r\nreturn -EINVAL;\r\nif (((cmd->scan_begin_src == TRIG_FOLLOW) ||\r\n(cmd->scan_begin_src == TRIG_EXT) ||\r\n(cmd->scan_begin_src == TRIG_INT)) &&\r\n(cmd->convert_src == TRIG_TIMER)) {\r\nif (cmd->scan_begin_src == TRIG_EXT)\r\ndevpriv->ai_do = 4;\r\nelse\r\ndevpriv->ai_do = 1;\r\npci9118_calc_divisors(devpriv->ai_do, dev, s,\r\n&cmd->scan_begin_arg, &cmd->convert_arg,\r\ndevpriv->ai_flags,\r\ndevpriv->ai_n_realscanlen,\r\n&devpriv->ai_divisor1,\r\n&devpriv->ai_divisor2, devpriv->usessh,\r\ndevpriv->ai_add_front);\r\ndevpriv->ai_timer2 = cmd->convert_arg;\r\n}\r\nif ((cmd->scan_begin_src == TRIG_TIMER) &&\r\n((cmd->convert_src == TRIG_TIMER) ||\r\n(cmd->convert_src == TRIG_NOW))) {\r\nif (!devpriv->usedma) {\r\ncomedi_error(dev,\r\n"cmd->scan_begin_src=TRIG_TIMER works "\r\n"only with bus mastering!");\r\nreturn -EIO;\r\n}\r\ndevpriv->ai_do = 2;\r\npci9118_calc_divisors(devpriv->ai_do, dev, s,\r\n&cmd->scan_begin_arg, &cmd->convert_arg,\r\ndevpriv->ai_flags,\r\ndevpriv->ai_n_realscanlen,\r\n&devpriv->ai_divisor1,\r\n&devpriv->ai_divisor2, devpriv->usessh,\r\ndevpriv->ai_add_front);\r\ndevpriv->ai_timer1 = cmd->scan_begin_arg;\r\ndevpriv->ai_timer2 = cmd->convert_arg;\r\n}\r\nif ((cmd->scan_begin_src == TRIG_FOLLOW)\r\n&& (cmd->convert_src == TRIG_EXT)) {\r\ndevpriv->ai_do = 3;\r\n}\r\nstart_pacer(dev, -1, 0, 0);\r\ndevpriv->AdControlReg = 0;\r\noutl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);\r\ndevpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;\r\noutl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);\r\nudelay(1);\r\noutl(0, dev->iobase + PCI9118_DELFIFO);\r\ninl(dev->iobase + PCI9118_ADSTAT);\r\ninl(dev->iobase + PCI9118_INTSRC);\r\ndevpriv->ai_act_scan = 0;\r\ndevpriv->ai_act_dmapos = 0;\r\ns->async->cur_chan = 0;\r\ndevpriv->ai_buf_ptr = 0;\r\nif (devpriv->usedma)\r\nret = pci9118_ai_docmd_dma(dev, s);\r\nelse\r\nret = pci9118_ai_docmd_sampl(dev, s);\r\nDPRINTK("adl_pci9118 EDBG: END: pci9118_ai_cmd()\n");\r\nreturn ret;\r\n}\r\nstatic int check_channel_list(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, int n_chan,\r\nunsigned int *chanlist, int frontadd, int backadd)\r\n{\r\nunsigned int i, differencial = 0, bipolar = 0;\r\nif (n_chan < 1) {\r\ncomedi_error(dev, "range/channel list is empty!");\r\nreturn 0;\r\n}\r\nif ((frontadd + n_chan + backadd) > s->len_chanlist) {\r\nprintk\r\n("comedi%d: range/channel list is too long for "\r\n"actual configuration (%d>%d)!",\r\ndev->minor, n_chan, s->len_chanlist - frontadd - backadd);\r\nreturn 0;\r\n}\r\nif (CR_AREF(chanlist[0]) == AREF_DIFF)\r\ndifferencial = 1;\r\nif (CR_RANGE(chanlist[0]) < PCI9118_BIPOLAR_RANGES)\r\nbipolar = 1;\r\nif (n_chan > 1)\r\nfor (i = 1; i < n_chan; i++) {\r\nif ((CR_AREF(chanlist[i]) == AREF_DIFF) !=\r\n(differencial)) {\r\ncomedi_error(dev,\r\n"Differencial and single ended "\r\n"inputs can't be mixtured!");\r\nreturn 0;\r\n}\r\nif ((CR_RANGE(chanlist[i]) < PCI9118_BIPOLAR_RANGES) !=\r\n(bipolar)) {\r\ncomedi_error(dev,\r\n"Bipolar and unipolar ranges "\r\n"can't be mixtured!");\r\nreturn 0;\r\n}\r\nif ((!devpriv->usemux) & (differencial) &\r\n(CR_CHAN(chanlist[i]) >= this_board->n_aichand)) {\r\ncomedi_error(dev,\r\n"If AREF_DIFF is used then is "\r\n"available only first 8 channels!");\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int setup_channel_list(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, int n_chan,\r\nunsigned int *chanlist, int rot, int frontadd,\r\nint backadd, int usedma, char useeos)\r\n{\r\nunsigned int i, differencial = 0, bipolar = 0;\r\nunsigned int scanquad, gain, ssh = 0x00;\r\nDPRINTK\r\n("adl_pci9118 EDBG: BGN: setup_channel_list"\r\n"(%d,.,%d,.,%d,%d,%d,%d)\n",\r\ndev->minor, n_chan, rot, frontadd, backadd, usedma);\r\nif (usedma == 1) {\r\nrot = 8;\r\nusedma = 0;\r\n}\r\nif (CR_AREF(chanlist[0]) == AREF_DIFF)\r\ndifferencial = 1;\r\nif (CR_RANGE(chanlist[0]) < PCI9118_BIPOLAR_RANGES)\r\nbipolar = 1;\r\nif (!bipolar) {\r\ndevpriv->AdControlReg |= AdControl_UniP;\r\n} else {\r\ndevpriv->AdControlReg &= ((~AdControl_UniP) & 0xff);\r\n}\r\nif (differencial) {\r\ndevpriv->AdControlReg |= AdControl_Diff;\r\n} else {\r\ndevpriv->AdControlReg &= ((~AdControl_Diff) & 0xff);\r\n}\r\noutl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);\r\noutl(2, dev->iobase + PCI9118_SCANMOD);\r\noutl(0, dev->iobase + PCI9118_SCANMOD);\r\noutl(1, dev->iobase + PCI9118_SCANMOD);\r\n#ifdef PCI9118_PARANOIDCHECK\r\ndevpriv->chanlistlen = n_chan;\r\nfor (i = 0; i < (PCI9118_CHANLEN + 1); i++)\r\ndevpriv->chanlist[i] = 0x55aa;\r\n#endif\r\nif (frontadd) {\r\nssh = devpriv->softsshsample;\r\nDPRINTK("FA: %04x: ", ssh);\r\nfor (i = 0; i < frontadd; i++) {\r\nscanquad = CR_CHAN(chanlist[0]);\r\ngain = CR_RANGE(chanlist[0]);\r\nscanquad |= ((gain & 0x03) << 8);\r\noutl(scanquad | ssh, dev->iobase + PCI9118_GAIN);\r\nDPRINTK("%02x ", scanquad | ssh);\r\nssh = devpriv->softsshhold;\r\n}\r\nDPRINTK("\n ");\r\n}\r\nDPRINTK("SL: ", ssh);\r\nfor (i = 0; i < n_chan; i++) {\r\nscanquad = CR_CHAN(chanlist[i]);\r\n#ifdef PCI9118_PARANOIDCHECK\r\ndevpriv->chanlist[i ^ usedma] = (scanquad & 0xf) << rot;\r\n#endif\r\ngain = CR_RANGE(chanlist[i]);\r\nscanquad |= ((gain & 0x03) << 8);\r\noutl(scanquad | ssh, dev->iobase + PCI9118_GAIN);\r\nDPRINTK("%02x ", scanquad | ssh);\r\n}\r\nDPRINTK("\n ");\r\nif (backadd) {\r\nDPRINTK("BA: %04x: ", ssh);\r\nfor (i = 0; i < backadd; i++) {\r\nscanquad = CR_CHAN(chanlist[0]);\r\ngain = CR_RANGE(chanlist[0]);\r\nscanquad |= ((gain & 0x03) << 8);\r\noutl(scanquad | ssh, dev->iobase + PCI9118_GAIN);\r\nDPRINTK("%02x ", scanquad | ssh);\r\n}\r\nDPRINTK("\n ");\r\n}\r\n#ifdef PCI9118_PARANOIDCHECK\r\ndevpriv->chanlist[n_chan ^ usedma] = devpriv->chanlist[0 ^ usedma];\r\nif (useeos) {\r\nfor (i = 1; i < n_chan; i++) {\r\ndevpriv->chanlist[(n_chan + i) ^ usedma] =\r\n(CR_CHAN(chanlist[i]) & 0xf) << rot;\r\n}\r\ndevpriv->chanlist[(2 * n_chan) ^ usedma] =\r\ndevpriv->chanlist[0 ^ usedma];\r\nuseeos = 2;\r\n} else {\r\nuseeos = 1;\r\n}\r\n#ifdef PCI9118_EXTDEBUG\r\nDPRINTK("CHL: ");\r\nfor (i = 0; i <= (useeos * n_chan); i++)\r\nDPRINTK("%04x ", devpriv->chanlist[i]);\r\nDPRINTK("\n ");\r\n#endif\r\n#endif\r\noutl(0, dev->iobase + PCI9118_SCANMOD);\r\nDPRINTK("adl_pci9118 EDBG: END: setup_channel_list()\n");\r\nreturn 1;\r\n}\r\nstatic void pci9118_calc_divisors(char mode, struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int *tim1, unsigned int *tim2,\r\nunsigned int flags, int chans,\r\nunsigned int *div1, unsigned int *div2,\r\nchar usessh, unsigned int chnsshfront)\r\n{\r\nDPRINTK\r\n("adl_pci9118 EDBG: BGN: pci9118_calc_divisors"\r\n"(%d,%d,.,%u,%u,%u,%d,.,.,,%u,%u)\n",\r\nmode, dev->minor, *tim1, *tim2, flags, chans, usessh, chnsshfront);\r\nswitch (mode) {\r\ncase 1:\r\ncase 4:\r\nif (*tim2 < this_board->ai_ns_min)\r\n*tim2 = this_board->ai_ns_min;\r\ni8253_cascade_ns_to_timer(devpriv->i8254_osc_base, div1, div2,\r\ntim2, flags & TRIG_ROUND_NEAREST);\r\nDPRINTK("OSC base=%u div1=%u div2=%u timer1=%u\n",\r\ndevpriv->i8254_osc_base, *div1, *div2, *tim1);\r\nbreak;\r\ncase 2:\r\nif (*tim2 < this_board->ai_ns_min)\r\n*tim2 = this_board->ai_ns_min;\r\nDPRINTK("1 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,\r\n*tim1, *tim2);\r\n*div1 = *tim2 / devpriv->i8254_osc_base;\r\nDPRINTK("2 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,\r\n*tim1, *tim2);\r\nif (*div1 < this_board->ai_pacer_min)\r\n*div1 = this_board->ai_pacer_min;\r\nDPRINTK("3 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,\r\n*tim1, *tim2);\r\n*div2 = *tim1 / devpriv->i8254_osc_base;\r\nDPRINTK("4 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,\r\n*tim1, *tim2);\r\n*div2 = *div2 / *div1;\r\nDPRINTK("5 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,\r\n*tim1, *tim2);\r\nif (*div2 < chans)\r\n*div2 = chans;\r\nDPRINTK("6 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,\r\n*tim1, *tim2);\r\n*tim2 = *div1 * devpriv->i8254_osc_base;\r\nif (usessh & (chnsshfront == 0))\r\nif (*div2 < (chans + 2))\r\n*div2 = chans + 2;\r\nDPRINTK("7 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,\r\n*tim1, *tim2);\r\n*tim1 = *div1 * *div2 * devpriv->i8254_osc_base;\r\nDPRINTK("OSC base=%u div1=%u div2=%u timer1=%u timer2=%u\n",\r\ndevpriv->i8254_osc_base, *div1, *div2, *tim1, *tim2);\r\nbreak;\r\n}\r\nDPRINTK("adl_pci9118 EDBG: END: pci9118_calc_divisors(%u,%u)\n",\r\n*div1, *div2);\r\n}\r\nstatic void start_pacer(struct comedi_device *dev, int mode,\r\nunsigned int divisor1, unsigned int divisor2)\r\n{\r\noutl(0x74, dev->iobase + PCI9118_CNTCTRL);\r\noutl(0xb4, dev->iobase + PCI9118_CNTCTRL);\r\nudelay(1);\r\nif ((mode == 1) || (mode == 2) || (mode == 4)) {\r\noutl(divisor2 & 0xff, dev->iobase + PCI9118_CNT2);\r\noutl((divisor2 >> 8) & 0xff, dev->iobase + PCI9118_CNT2);\r\noutl(divisor1 & 0xff, dev->iobase + PCI9118_CNT1);\r\noutl((divisor1 >> 8) & 0xff, dev->iobase + PCI9118_CNT1);\r\n}\r\n}\r\nstatic int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source)\r\n{\r\nif (source > 3)\r\nreturn -1;\r\ndevpriv->exttrg_users |= (1 << source);\r\ndevpriv->IntControlReg |= Int_DTrg;\r\noutl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);\r\noutl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,\r\ndevpriv->iobase_a + AMCC_OP_REG_INTCSR);\r\nreturn 0;\r\n}\r\nstatic int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source)\r\n{\r\nif (source > 3)\r\nreturn -1;\r\ndevpriv->exttrg_users &= ~(1 << source);\r\nif (!devpriv->exttrg_users) {\r\ndevpriv->IntControlReg &= ~Int_DTrg;\r\nif (!devpriv->IntControlReg)\r\noutl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) &\r\n(~0x00001f00),\r\ndevpriv->iobase_a + AMCC_OP_REG_INTCSR);\r\noutl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci9118_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nif (devpriv->usedma)\r\noutl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) &\r\n(~EN_A2P_TRANSFERS),\r\ndevpriv->iobase_a + AMCC_OP_REG_MCSR);\r\npci9118_exttrg_del(dev, EXTTRG_AI);\r\nstart_pacer(dev, 0, 0, 0);\r\ndevpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;\r\noutl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);\r\ndevpriv->AdControlReg = 0x00;\r\noutl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);\r\noutl(0, dev->iobase + PCI9118_BURST);\r\noutl(1, dev->iobase + PCI9118_SCANMOD);\r\noutl(2, dev->iobase + PCI9118_SCANMOD);\r\noutl(0, dev->iobase + PCI9118_DELFIFO);\r\ndevpriv->ai_do = 0;\r\ndevpriv->usedma = 0;\r\ndevpriv->ai_act_scan = 0;\r\ndevpriv->ai_act_dmapos = 0;\r\ns->async->cur_chan = 0;\r\ns->async->inttrig = NULL;\r\ndevpriv->ai_buf_ptr = 0;\r\ndevpriv->ai_neverending = 0;\r\ndevpriv->dma_actbuf = 0;\r\nif (!devpriv->IntControlReg)\r\noutl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,\r\ndevpriv->iobase_a + AMCC_OP_REG_INTCSR);\r\nreturn 0;\r\n}\r\nstatic int pci9118_reset(struct comedi_device *dev)\r\n{\r\ndevpriv->IntControlReg = 0;\r\ndevpriv->exttrg_users = 0;\r\ninl(dev->iobase + PCI9118_INTCTRL);\r\noutl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);\r\noutl(0x30, dev->iobase + PCI9118_CNTCTRL);\r\nstart_pacer(dev, 0, 0, 0);\r\ndevpriv->AdControlReg = 0;\r\noutl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);\r\noutl(0, dev->iobase + PCI9118_BURST);\r\noutl(1, dev->iobase + PCI9118_SCANMOD);\r\noutl(2, dev->iobase + PCI9118_SCANMOD);\r\ndevpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;\r\noutl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);\r\ndevpriv->ao_data[0] = 2047;\r\ndevpriv->ao_data[1] = 2047;\r\noutl(devpriv->ao_data[0], dev->iobase + PCI9118_DA1);\r\noutl(devpriv->ao_data[1], dev->iobase + PCI9118_DA2);\r\noutl(0, dev->iobase + PCI9118_DO);\r\nudelay(10);\r\ninl(dev->iobase + PCI9118_AD_DATA);\r\noutl(0, dev->iobase + PCI9118_DELFIFO);\r\noutl(0, dev->iobase + PCI9118_INTSRC);\r\ninl(dev->iobase + PCI9118_ADSTAT);\r\ninl(dev->iobase + PCI9118_INTSRC);\r\ndevpriv->AdControlReg = 0;\r\noutl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);\r\ndevpriv->cnt0_users = 0;\r\ndevpriv->exttrg_users = 0;\r\nreturn 0;\r\n}\r\nstatic int pci9118_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nint ret, pages, i;\r\nunsigned short master;\r\nunsigned int irq;\r\nunsigned long iobase_a, iobase_9;\r\nstruct pci_dev *pcidev;\r\nint opt_bus, opt_slot;\r\nconst char *errstr;\r\nunsigned char pci_bus, pci_slot, pci_func;\r\nu16 u16w;\r\nprintk("comedi%d: adl_pci9118: board=%s", dev->minor, this_board->name);\r\nopt_bus = it->options[0];\r\nopt_slot = it->options[1];\r\nif (it->options[3] & 1)\r\nmaster = 0;\r\nelse\r\nmaster = 1;\r\nret = alloc_private(dev, sizeof(struct pci9118_private));\r\nif (ret < 0) {\r\nprintk(" - Allocation failed!\n");\r\nreturn -ENOMEM;\r\n}\r\nerrstr = "not found!";\r\npcidev = NULL;\r\nwhile (NULL != (pcidev = pci_get_device(PCI_VENDOR_ID_AMCC,\r\nthis_board->device_id,\r\npcidev))) {\r\nif (opt_bus || opt_slot) {\r\nif (opt_bus != pcidev->bus->number\r\n|| opt_slot != PCI_SLOT(pcidev->devfn))\r\ncontinue;\r\n}\r\nif (comedi_pci_enable(pcidev, "adl_pci9118")) {\r\nerrstr =\r\n"failed to enable PCI device and request regions!";\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (!pcidev) {\r\nif (opt_bus || opt_slot) {\r\nprintk(KERN_ERR " - Card at b:s %d:%d %s\n",\r\nopt_bus, opt_slot, errstr);\r\n} else {\r\nprintk(KERN_ERR " - Card %s\n", errstr);\r\n}\r\nreturn -EIO;\r\n}\r\nif (master)\r\npci_set_master(pcidev);\r\npci_bus = pcidev->bus->number;\r\npci_slot = PCI_SLOT(pcidev->devfn);\r\npci_func = PCI_FUNC(pcidev->devfn);\r\nirq = pcidev->irq;\r\niobase_a = pci_resource_start(pcidev, 0);\r\niobase_9 = pci_resource_start(pcidev, 2);\r\nprintk(KERN_ERR ", b:s:f=%d:%d:%d, io=0x%4lx, 0x%4lx", pci_bus,\r\npci_slot, pci_func, iobase_9, iobase_a);\r\ndev->iobase = iobase_9;\r\ndev->board_name = this_board->name;\r\ndevpriv->pcidev = pcidev;\r\ndevpriv->iobase_a = iobase_a;\r\npci9118_reset(dev);\r\nif (it->options[3] & 2)\r\nirq = 0;\r\nif (irq > 0) {\r\nif (request_irq(irq, interrupt_pci9118, IRQF_SHARED,\r\n"ADLink PCI-9118", dev)) {\r\nprintk(", unable to allocate IRQ %d, DISABLING IT",\r\nirq);\r\nirq = 0;\r\n} else {\r\nprintk(", irq=%u", irq);\r\n}\r\n} else {\r\nprintk(", IRQ disabled");\r\n}\r\ndev->irq = irq;\r\nif (master) {\r\ndevpriv->dma_doublebuf = 0;\r\nfor (i = 0; i < 2; i++) {\r\nfor (pages = 4; pages >= 0; pages--) {\r\ndevpriv->dmabuf_virt[i] =\r\n(short *)__get_free_pages(GFP_KERNEL,\r\npages);\r\nif (devpriv->dmabuf_virt[i])\r\nbreak;\r\n}\r\nif (devpriv->dmabuf_virt[i]) {\r\ndevpriv->dmabuf_pages[i] = pages;\r\ndevpriv->dmabuf_size[i] = PAGE_SIZE * pages;\r\ndevpriv->dmabuf_samples[i] =\r\ndevpriv->dmabuf_size[i] >> 1;\r\ndevpriv->dmabuf_hw[i] =\r\nvirt_to_bus((void *)\r\ndevpriv->dmabuf_virt[i]);\r\n}\r\n}\r\nif (!devpriv->dmabuf_virt[0]) {\r\nprintk(", Can't allocate DMA buffer, DMA disabled!");\r\nmaster = 0;\r\n}\r\nif (devpriv->dmabuf_virt[1])\r\ndevpriv->dma_doublebuf = 1;\r\n}\r\ndevpriv->master = master;\r\nif (devpriv->master)\r\nprintk(", bus master");\r\nelse\r\nprintk(", no bus master");\r\ndevpriv->usemux = 0;\r\nif (it->options[2] > 0) {\r\ndevpriv->usemux = it->options[2];\r\nif (devpriv->usemux > 256)\r\ndevpriv->usemux = 256;\r\nif (it->options[4] > 0)\r\nif (devpriv->usemux > 128) {\r\ndevpriv->usemux = 128;\r\n}\r\nprintk(", ext. mux %d channels", devpriv->usemux);\r\n}\r\ndevpriv->softsshdelay = it->options[4];\r\nif (devpriv->softsshdelay < 0) {\r\ndevpriv->softsshdelay = -devpriv->softsshdelay;\r\ndevpriv->softsshsample = 0x80;\r\ndevpriv->softsshhold = 0x00;\r\n} else {\r\ndevpriv->softsshsample = 0x00;\r\ndevpriv->softsshhold = 0x80;\r\n}\r\nprintk(".\n");\r\npci_read_config_word(devpriv->pcidev, PCI_COMMAND, &u16w);\r\npci_write_config_word(devpriv->pcidev, PCI_COMMAND, u16w | 64);\r\nret = alloc_subdevices(dev, 4);\r\nif (ret < 0)\r\nreturn ret;\r\ns = dev->subdevices + 0;\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;\r\nif (devpriv->usemux)\r\ns->n_chan = devpriv->usemux;\r\nelse\r\ns->n_chan = this_board->n_aichan;\r\ns->maxdata = this_board->ai_maxdata;\r\ns->len_chanlist = this_board->n_aichanlist;\r\ns->range_table = this_board->rangelist_ai;\r\ns->cancel = pci9118_ai_cancel;\r\ns->insn_read = pci9118_insn_read_ai;\r\nif (dev->irq) {\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->do_cmdtest = pci9118_ai_cmdtest;\r\ns->do_cmd = pci9118_ai_cmd;\r\ns->munge = pci9118_ai_munge;\r\n}\r\ns = dev->subdevices + 1;\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;\r\ns->n_chan = this_board->n_aochan;\r\ns->maxdata = this_board->ao_maxdata;\r\ns->len_chanlist = this_board->n_aochan;\r\ns->range_table = this_board->rangelist_ao;\r\ns->insn_write = pci9118_insn_write_ao;\r\ns->insn_read = pci9118_insn_read_ao;\r\ns = dev->subdevices + 2;\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_COMMON;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->len_chanlist = 4;\r\ns->range_table = &range_digital;\r\ns->io_bits = 0;\r\ns->insn_bits = pci9118_insn_bits_di;\r\ns = dev->subdevices + 3;\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->len_chanlist = 4;\r\ns->range_table = &range_digital;\r\ns->io_bits = 0xf;\r\ns->insn_bits = pci9118_insn_bits_do;\r\ndevpriv->valid = 1;\r\ndevpriv->i8254_osc_base = 250;\r\ndevpriv->ai_maskharderr = 0x10a;\r\nif (it->options[5])\r\ndevpriv->ai_maskharderr &= ~it->options[5];\r\nswitch (this_board->ai_maxdata) {\r\ncase 0xffff:\r\ndevpriv->ai16bits = 1;\r\nbreak;\r\ndefault:\r\ndevpriv->ai16bits = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci9118_detach(struct comedi_device *dev)\r\n{\r\nif (dev->private) {\r\nif (devpriv->valid)\r\npci9118_reset(dev);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (devpriv->pcidev) {\r\nif (dev->iobase)\r\ncomedi_pci_disable(devpriv->pcidev);\r\npci_dev_put(devpriv->pcidev);\r\n}\r\nif (devpriv->dmabuf_virt[0])\r\nfree_pages((unsigned long)devpriv->dmabuf_virt[0],\r\ndevpriv->dmabuf_pages[0]);\r\nif (devpriv->dmabuf_virt[1])\r\nfree_pages((unsigned long)devpriv->dmabuf_virt[1],\r\ndevpriv->dmabuf_pages[1]);\r\n}\r\nreturn 0;\r\n}
