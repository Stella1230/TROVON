static int slave_update(struct link_slave *slave)\r\n{\r\nstruct snd_ctl_elem_value *uctl;\r\nint err, ch;\r\nuctl = kmalloc(sizeof(*uctl), GFP_KERNEL);\r\nif (!uctl)\r\nreturn -ENOMEM;\r\nuctl->id = slave->slave.id;\r\nerr = slave->slave.get(&slave->slave, uctl);\r\nfor (ch = 0; ch < slave->info.count; ch++)\r\nslave->vals[ch] = uctl->value.integer.value[ch];\r\nkfree(uctl);\r\nreturn 0;\r\n}\r\nstatic int slave_init(struct link_slave *slave)\r\n{\r\nstruct snd_ctl_elem_info *uinfo;\r\nint err;\r\nif (slave->info.count) {\r\nif (slave->flags & SND_CTL_SLAVE_NEED_UPDATE)\r\nreturn slave_update(slave);\r\nreturn 0;\r\n}\r\nuinfo = kmalloc(sizeof(*uinfo), GFP_KERNEL);\r\nif (!uinfo)\r\nreturn -ENOMEM;\r\nuinfo->id = slave->slave.id;\r\nerr = slave->slave.info(&slave->slave, uinfo);\r\nif (err < 0) {\r\nkfree(uinfo);\r\nreturn err;\r\n}\r\nslave->info.type = uinfo->type;\r\nslave->info.count = uinfo->count;\r\nif (slave->info.count > 2 ||\r\n(slave->info.type != SNDRV_CTL_ELEM_TYPE_INTEGER &&\r\nslave->info.type != SNDRV_CTL_ELEM_TYPE_BOOLEAN)) {\r\nsnd_printk(KERN_ERR "invalid slave element\n");\r\nkfree(uinfo);\r\nreturn -EINVAL;\r\n}\r\nslave->info.min_val = uinfo->value.integer.min;\r\nslave->info.max_val = uinfo->value.integer.max;\r\nkfree(uinfo);\r\nreturn slave_update(slave);\r\n}\r\nstatic int master_init(struct link_master *master)\r\n{\r\nstruct link_slave *slave;\r\nif (master->info.count)\r\nreturn 0;\r\nlist_for_each_entry(slave, &master->slaves, list) {\r\nint err = slave_init(slave);\r\nif (err < 0)\r\nreturn err;\r\nmaster->info = slave->info;\r\nmaster->info.count = 1;\r\nmaster->val = master->info.max_val;\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int slave_get_val(struct link_slave *slave,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint err, ch;\r\nerr = slave_init(slave);\r\nif (err < 0)\r\nreturn err;\r\nfor (ch = 0; ch < slave->info.count; ch++)\r\nucontrol->value.integer.value[ch] = slave->vals[ch];\r\nreturn 0;\r\n}\r\nstatic int slave_put_val(struct link_slave *slave,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint err, ch, vol;\r\nerr = master_init(slave->master);\r\nif (err < 0)\r\nreturn err;\r\nswitch (slave->info.type) {\r\ncase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\r\nfor (ch = 0; ch < slave->info.count; ch++)\r\nucontrol->value.integer.value[ch] &=\r\n!!slave->master->val;\r\nbreak;\r\ncase SNDRV_CTL_ELEM_TYPE_INTEGER:\r\nfor (ch = 0; ch < slave->info.count; ch++) {\r\nvol = ucontrol->value.integer.value[ch];\r\nvol += slave->master->val - slave->master->info.max_val;\r\nif (vol < slave->info.min_val)\r\nvol = slave->info.min_val;\r\nelse if (vol > slave->info.max_val)\r\nvol = slave->info.max_val;\r\nucontrol->value.integer.value[ch] = vol;\r\n}\r\nbreak;\r\n}\r\nreturn slave->slave.put(&slave->slave, ucontrol);\r\n}\r\nstatic int slave_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct link_slave *slave = snd_kcontrol_chip(kcontrol);\r\nreturn slave->slave.info(&slave->slave, uinfo);\r\n}\r\nstatic int slave_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct link_slave *slave = snd_kcontrol_chip(kcontrol);\r\nreturn slave_get_val(slave, ucontrol);\r\n}\r\nstatic int slave_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct link_slave *slave = snd_kcontrol_chip(kcontrol);\r\nint err, ch, changed = 0;\r\nerr = slave_init(slave);\r\nif (err < 0)\r\nreturn err;\r\nfor (ch = 0; ch < slave->info.count; ch++) {\r\nif (slave->vals[ch] != ucontrol->value.integer.value[ch]) {\r\nchanged = 1;\r\nslave->vals[ch] = ucontrol->value.integer.value[ch];\r\n}\r\n}\r\nif (!changed)\r\nreturn 0;\r\nreturn slave_put_val(slave, ucontrol);\r\n}\r\nstatic int slave_tlv_cmd(struct snd_kcontrol *kcontrol,\r\nint op_flag, unsigned int size,\r\nunsigned int __user *tlv)\r\n{\r\nstruct link_slave *slave = snd_kcontrol_chip(kcontrol);\r\nreturn slave->slave.tlv.c(&slave->slave, op_flag, size, tlv);\r\n}\r\nstatic void slave_free(struct snd_kcontrol *kcontrol)\r\n{\r\nstruct link_slave *slave = snd_kcontrol_chip(kcontrol);\r\nif (slave->slave.private_free)\r\nslave->slave.private_free(&slave->slave);\r\nif (slave->master)\r\nlist_del(&slave->list);\r\nkfree(slave);\r\n}\r\nint _snd_ctl_add_slave(struct snd_kcontrol *master, struct snd_kcontrol *slave,\r\nunsigned int flags)\r\n{\r\nstruct link_master *master_link = snd_kcontrol_chip(master);\r\nstruct link_slave *srec;\r\nsrec = kzalloc(sizeof(*srec) +\r\nslave->count * sizeof(*slave->vd), GFP_KERNEL);\r\nif (!srec)\r\nreturn -ENOMEM;\r\nsrec->kctl = slave;\r\nsrec->slave = *slave;\r\nmemcpy(srec->slave.vd, slave->vd, slave->count * sizeof(*slave->vd));\r\nsrec->master = master_link;\r\nsrec->flags = flags;\r\nslave->info = slave_info;\r\nslave->get = slave_get;\r\nslave->put = slave_put;\r\nif (slave->vd[0].access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK)\r\nslave->tlv.c = slave_tlv_cmd;\r\nslave->private_data = srec;\r\nslave->private_free = slave_free;\r\nlist_add_tail(&srec->list, &master_link->slaves);\r\nreturn 0;\r\n}\r\nstatic int master_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct link_master *master = snd_kcontrol_chip(kcontrol);\r\nint ret;\r\nret = master_init(master);\r\nif (ret < 0)\r\nreturn ret;\r\nuinfo->type = master->info.type;\r\nuinfo->count = master->info.count;\r\nuinfo->value.integer.min = master->info.min_val;\r\nuinfo->value.integer.max = master->info.max_val;\r\nreturn 0;\r\n}\r\nstatic int master_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct link_master *master = snd_kcontrol_chip(kcontrol);\r\nint err = master_init(master);\r\nif (err < 0)\r\nreturn err;\r\nucontrol->value.integer.value[0] = master->val;\r\nreturn 0;\r\n}\r\nstatic int master_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct link_master *master = snd_kcontrol_chip(kcontrol);\r\nstruct link_slave *slave;\r\nstruct snd_ctl_elem_value *uval;\r\nint err, old_val;\r\nerr = master_init(master);\r\nif (err < 0)\r\nreturn err;\r\nold_val = master->val;\r\nif (ucontrol->value.integer.value[0] == old_val)\r\nreturn 0;\r\nuval = kmalloc(sizeof(*uval), GFP_KERNEL);\r\nif (!uval)\r\nreturn -ENOMEM;\r\nlist_for_each_entry(slave, &master->slaves, list) {\r\nmaster->val = old_val;\r\nuval->id = slave->slave.id;\r\nslave_get_val(slave, uval);\r\nmaster->val = ucontrol->value.integer.value[0];\r\nslave_put_val(slave, uval);\r\n}\r\nkfree(uval);\r\nreturn 1;\r\n}\r\nstatic void master_free(struct snd_kcontrol *kcontrol)\r\n{\r\nstruct link_master *master = snd_kcontrol_chip(kcontrol);\r\nstruct link_slave *slave, *n;\r\nlist_for_each_entry_safe(slave, n, &master->slaves, list) {\r\nstruct snd_kcontrol *sctl = slave->kctl;\r\nstruct list_head olist = sctl->list;\r\nmemcpy(sctl, &slave->slave, sizeof(*sctl));\r\nmemcpy(sctl->vd, slave->slave.vd,\r\nsctl->count * sizeof(*sctl->vd));\r\nsctl->list = olist;\r\nkfree(slave);\r\n}\r\nkfree(master);\r\n}\r\nstruct snd_kcontrol *snd_ctl_make_virtual_master(char *name,\r\nconst unsigned int *tlv)\r\n{\r\nstruct link_master *master;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_kcontrol_new knew;\r\nmemset(&knew, 0, sizeof(knew));\r\nknew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nknew.name = name;\r\nknew.info = master_info;\r\nmaster = kzalloc(sizeof(*master), GFP_KERNEL);\r\nif (!master)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&master->slaves);\r\nkctl = snd_ctl_new1(&knew, master);\r\nif (!kctl) {\r\nkfree(master);\r\nreturn NULL;\r\n}\r\nkctl->info = master_info;\r\nkctl->get = master_get;\r\nkctl->put = master_put;\r\nkctl->private_free = master_free;\r\nif (tlv &&\r\n(tlv[0] == SNDRV_CTL_TLVT_DB_SCALE ||\r\ntlv[0] == SNDRV_CTL_TLVT_DB_MINMAX ||\r\ntlv[0] == SNDRV_CTL_TLVT_DB_MINMAX_MUTE)) {\r\nkctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;\r\nmemcpy(master->tlv, tlv, sizeof(master->tlv));\r\nkctl->tlv.p = master->tlv;\r\n}\r\nreturn kctl;\r\n}
