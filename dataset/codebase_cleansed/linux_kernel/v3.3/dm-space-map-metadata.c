static int add_bop(struct sm_metadata *smm, enum block_op_type type, dm_block_t b)\r\n{\r\nstruct block_op *op;\r\nif (smm->nr_uncommitted == MAX_RECURSIVE_ALLOCATIONS) {\r\nDMERR("too many recursive allocations");\r\nreturn -ENOMEM;\r\n}\r\nop = smm->uncommitted + smm->nr_uncommitted++;\r\nop->type = type;\r\nop->block = b;\r\nreturn 0;\r\n}\r\nstatic int commit_bop(struct sm_metadata *smm, struct block_op *op)\r\n{\r\nint r = 0;\r\nenum allocation_event ev;\r\nswitch (op->type) {\r\ncase BOP_INC:\r\nr = sm_ll_inc(&smm->ll, op->block, &ev);\r\nbreak;\r\ncase BOP_DEC:\r\nr = sm_ll_dec(&smm->ll, op->block, &ev);\r\nbreak;\r\n}\r\nreturn r;\r\n}\r\nstatic void in(struct sm_metadata *smm)\r\n{\r\nsmm->recursion_count++;\r\n}\r\nstatic int out(struct sm_metadata *smm)\r\n{\r\nint r = 0;\r\nif (!smm->recursion_count) {\r\nDMERR("lost track of recursion depth");\r\nreturn -ENOMEM;\r\n}\r\nif (smm->recursion_count == 1 && smm->nr_uncommitted) {\r\nwhile (smm->nr_uncommitted && !r) {\r\nsmm->nr_uncommitted--;\r\nr = commit_bop(smm, smm->uncommitted +\r\nsmm->nr_uncommitted);\r\nif (r)\r\nbreak;\r\n}\r\n}\r\nsmm->recursion_count--;\r\nreturn r;\r\n}\r\nstatic int combine_errors(int r1, int r2)\r\n{\r\nreturn r1 ? r1 : r2;\r\n}\r\nstatic int recursing(struct sm_metadata *smm)\r\n{\r\nreturn smm->recursion_count;\r\n}\r\nstatic void sm_metadata_destroy(struct dm_space_map *sm)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nkfree(smm);\r\n}\r\nstatic int sm_metadata_extend(struct dm_space_map *sm, dm_block_t extra_blocks)\r\n{\r\nDMERR("doesn't support extend");\r\nreturn -EINVAL;\r\n}\r\nstatic int sm_metadata_get_nr_blocks(struct dm_space_map *sm, dm_block_t *count)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\n*count = smm->ll.nr_blocks;\r\nreturn 0;\r\n}\r\nstatic int sm_metadata_get_nr_free(struct dm_space_map *sm, dm_block_t *count)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\n*count = smm->old_ll.nr_blocks - smm->old_ll.nr_allocated -\r\nsmm->allocated_this_transaction;\r\nreturn 0;\r\n}\r\nstatic int sm_metadata_get_count(struct dm_space_map *sm, dm_block_t b,\r\nuint32_t *result)\r\n{\r\nint r, i;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nunsigned adjustment = 0;\r\nfor (i = 0; i < smm->nr_uncommitted; i++) {\r\nstruct block_op *op = smm->uncommitted + i;\r\nif (op->block != b)\r\ncontinue;\r\nswitch (op->type) {\r\ncase BOP_INC:\r\nadjustment++;\r\nbreak;\r\ncase BOP_DEC:\r\nadjustment--;\r\nbreak;\r\n}\r\n}\r\nr = sm_ll_lookup(&smm->ll, b, result);\r\nif (r)\r\nreturn r;\r\n*result += adjustment;\r\nreturn 0;\r\n}\r\nstatic int sm_metadata_count_is_more_than_one(struct dm_space_map *sm,\r\ndm_block_t b, int *result)\r\n{\r\nint r, i, adjustment = 0;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nuint32_t rc;\r\nfor (i = 0; i < smm->nr_uncommitted; i++) {\r\nstruct block_op *op = smm->uncommitted + i;\r\nif (op->block != b)\r\ncontinue;\r\nswitch (op->type) {\r\ncase BOP_INC:\r\nadjustment++;\r\nbreak;\r\ncase BOP_DEC:\r\nadjustment--;\r\nbreak;\r\n}\r\n}\r\nif (adjustment > 1) {\r\n*result = 1;\r\nreturn 0;\r\n}\r\nr = sm_ll_lookup_bitmap(&smm->ll, b, &rc);\r\nif (r)\r\nreturn r;\r\nif (rc == 3)\r\n*result = 1;\r\nelse\r\n*result = rc + adjustment > 1;\r\nreturn 0;\r\n}\r\nstatic int sm_metadata_set_count(struct dm_space_map *sm, dm_block_t b,\r\nuint32_t count)\r\n{\r\nint r, r2;\r\nenum allocation_event ev;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nif (smm->recursion_count) {\r\nDMERR("cannot recurse set_count()");\r\nreturn -EINVAL;\r\n}\r\nin(smm);\r\nr = sm_ll_insert(&smm->ll, b, count, &ev);\r\nr2 = out(smm);\r\nreturn combine_errors(r, r2);\r\n}\r\nstatic int sm_metadata_inc_block(struct dm_space_map *sm, dm_block_t b)\r\n{\r\nint r, r2 = 0;\r\nenum allocation_event ev;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nif (recursing(smm))\r\nr = add_bop(smm, BOP_INC, b);\r\nelse {\r\nin(smm);\r\nr = sm_ll_inc(&smm->ll, b, &ev);\r\nr2 = out(smm);\r\n}\r\nreturn combine_errors(r, r2);\r\n}\r\nstatic int sm_metadata_dec_block(struct dm_space_map *sm, dm_block_t b)\r\n{\r\nint r, r2 = 0;\r\nenum allocation_event ev;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nif (recursing(smm))\r\nr = add_bop(smm, BOP_DEC, b);\r\nelse {\r\nin(smm);\r\nr = sm_ll_dec(&smm->ll, b, &ev);\r\nr2 = out(smm);\r\n}\r\nreturn combine_errors(r, r2);\r\n}\r\nstatic int sm_metadata_new_block_(struct dm_space_map *sm, dm_block_t *b)\r\n{\r\nint r, r2 = 0;\r\nenum allocation_event ev;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nr = sm_ll_find_free_block(&smm->old_ll, smm->begin, smm->old_ll.nr_blocks, b);\r\nif (r)\r\nreturn r;\r\nsmm->begin = *b + 1;\r\nif (recursing(smm))\r\nr = add_bop(smm, BOP_INC, *b);\r\nelse {\r\nin(smm);\r\nr = sm_ll_inc(&smm->ll, *b, &ev);\r\nr2 = out(smm);\r\n}\r\nif (!r)\r\nsmm->allocated_this_transaction++;\r\nreturn combine_errors(r, r2);\r\n}\r\nstatic int sm_metadata_new_block(struct dm_space_map *sm, dm_block_t *b)\r\n{\r\nint r = sm_metadata_new_block_(sm, b);\r\nif (r)\r\nDMERR("out of metadata space");\r\nreturn r;\r\n}\r\nstatic int sm_metadata_commit(struct dm_space_map *sm)\r\n{\r\nint r;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nr = sm_ll_commit(&smm->ll);\r\nif (r)\r\nreturn r;\r\nmemcpy(&smm->old_ll, &smm->ll, sizeof(smm->old_ll));\r\nsmm->begin = 0;\r\nsmm->allocated_this_transaction = 0;\r\nreturn 0;\r\n}\r\nstatic int sm_metadata_root_size(struct dm_space_map *sm, size_t *result)\r\n{\r\n*result = sizeof(struct disk_sm_root);\r\nreturn 0;\r\n}\r\nstatic int sm_metadata_copy_root(struct dm_space_map *sm, void *where_le, size_t max)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nstruct disk_sm_root root_le;\r\nroot_le.nr_blocks = cpu_to_le64(smm->ll.nr_blocks);\r\nroot_le.nr_allocated = cpu_to_le64(smm->ll.nr_allocated);\r\nroot_le.bitmap_root = cpu_to_le64(smm->ll.bitmap_root);\r\nroot_le.ref_count_root = cpu_to_le64(smm->ll.ref_count_root);\r\nif (max < sizeof(root_le))\r\nreturn -ENOSPC;\r\nmemcpy(where_le, &root_le, sizeof(root_le));\r\nreturn 0;\r\n}\r\nstatic void sm_bootstrap_destroy(struct dm_space_map *sm)\r\n{\r\n}\r\nstatic int sm_bootstrap_extend(struct dm_space_map *sm, dm_block_t extra_blocks)\r\n{\r\nDMERR("boostrap doesn't support extend");\r\nreturn -EINVAL;\r\n}\r\nstatic int sm_bootstrap_get_nr_blocks(struct dm_space_map *sm, dm_block_t *count)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nreturn smm->ll.nr_blocks;\r\n}\r\nstatic int sm_bootstrap_get_nr_free(struct dm_space_map *sm, dm_block_t *count)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\n*count = smm->ll.nr_blocks - smm->begin;\r\nreturn 0;\r\n}\r\nstatic int sm_bootstrap_get_count(struct dm_space_map *sm, dm_block_t b,\r\nuint32_t *result)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nreturn b < smm->begin ? 1 : 0;\r\n}\r\nstatic int sm_bootstrap_count_is_more_than_one(struct dm_space_map *sm,\r\ndm_block_t b, int *result)\r\n{\r\n*result = 0;\r\nreturn 0;\r\n}\r\nstatic int sm_bootstrap_set_count(struct dm_space_map *sm, dm_block_t b,\r\nuint32_t count)\r\n{\r\nDMERR("boostrap doesn't support set_count");\r\nreturn -EINVAL;\r\n}\r\nstatic int sm_bootstrap_new_block(struct dm_space_map *sm, dm_block_t *b)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nif (smm->begin == smm->ll.nr_blocks)\r\nreturn -ENOSPC;\r\n*b = smm->begin++;\r\nreturn 0;\r\n}\r\nstatic int sm_bootstrap_inc_block(struct dm_space_map *sm, dm_block_t b)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nreturn add_bop(smm, BOP_INC, b);\r\n}\r\nstatic int sm_bootstrap_dec_block(struct dm_space_map *sm, dm_block_t b)\r\n{\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nreturn add_bop(smm, BOP_DEC, b);\r\n}\r\nstatic int sm_bootstrap_commit(struct dm_space_map *sm)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sm_bootstrap_root_size(struct dm_space_map *sm, size_t *result)\r\n{\r\nDMERR("boostrap doesn't support root_size");\r\nreturn -EINVAL;\r\n}\r\nstatic int sm_bootstrap_copy_root(struct dm_space_map *sm, void *where,\r\nsize_t max)\r\n{\r\nDMERR("boostrap doesn't support copy_root");\r\nreturn -EINVAL;\r\n}\r\nstruct dm_space_map *dm_sm_metadata_init(void)\r\n{\r\nstruct sm_metadata *smm;\r\nsmm = kmalloc(sizeof(*smm), GFP_KERNEL);\r\nif (!smm)\r\nreturn ERR_PTR(-ENOMEM);\r\nmemcpy(&smm->sm, &ops, sizeof(smm->sm));\r\nreturn &smm->sm;\r\n}\r\nint dm_sm_metadata_create(struct dm_space_map *sm,\r\nstruct dm_transaction_manager *tm,\r\ndm_block_t nr_blocks,\r\ndm_block_t superblock)\r\n{\r\nint r;\r\ndm_block_t i;\r\nenum allocation_event ev;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nsmm->begin = superblock + 1;\r\nsmm->recursion_count = 0;\r\nsmm->allocated_this_transaction = 0;\r\nsmm->nr_uncommitted = 0;\r\nmemcpy(&smm->sm, &bootstrap_ops, sizeof(smm->sm));\r\nr = sm_ll_new_metadata(&smm->ll, tm);\r\nif (r)\r\nreturn r;\r\nr = sm_ll_extend(&smm->ll, nr_blocks);\r\nif (r)\r\nreturn r;\r\nmemcpy(&smm->sm, &ops, sizeof(smm->sm));\r\nfor (i = superblock; !r && i < smm->begin; i++)\r\nr = sm_ll_inc(&smm->ll, i, &ev);\r\nif (r)\r\nreturn r;\r\nreturn sm_metadata_commit(sm);\r\n}\r\nint dm_sm_metadata_open(struct dm_space_map *sm,\r\nstruct dm_transaction_manager *tm,\r\nvoid *root_le, size_t len)\r\n{\r\nint r;\r\nstruct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);\r\nr = sm_ll_open_metadata(&smm->ll, tm, root_le, len);\r\nif (r)\r\nreturn r;\r\nsmm->begin = 0;\r\nsmm->recursion_count = 0;\r\nsmm->allocated_this_transaction = 0;\r\nsmm->nr_uncommitted = 0;\r\nmemcpy(&smm->old_ll, &smm->ll, sizeof(smm->old_ll));\r\nreturn 0;\r\n}
