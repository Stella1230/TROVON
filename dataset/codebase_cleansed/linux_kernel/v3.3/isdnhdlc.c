void isdnhdlc_rcv_init(struct isdnhdlc_vars *hdlc, u32 features)\r\n{\r\nmemset(hdlc, 0, sizeof(struct isdnhdlc_vars));\r\nhdlc->state = HDLC_GET_DATA;\r\nif (features & HDLC_56KBIT)\r\nhdlc->do_adapt56 = 1;\r\nif (features & HDLC_BITREVERSE)\r\nhdlc->do_bitreverse = 1;\r\n}\r\nvoid isdnhdlc_out_init(struct isdnhdlc_vars *hdlc, u32 features)\r\n{\r\nmemset(hdlc, 0, sizeof(struct isdnhdlc_vars));\r\nif (features & HDLC_DCHANNEL) {\r\nhdlc->dchannel = 1;\r\nhdlc->state = HDLC_SEND_FIRST_FLAG;\r\n} else {\r\nhdlc->dchannel = 0;\r\nhdlc->state = HDLC_SEND_FAST_FLAG;\r\nhdlc->ffvalue = 0x7e;\r\n}\r\nhdlc->cbin = 0x7e;\r\nif (features & HDLC_56KBIT) {\r\nhdlc->do_adapt56 = 1;\r\nhdlc->state = HDLC_SENDFLAG_B0;\r\n} else\r\nhdlc->data_bits = 8;\r\nif (features & HDLC_BITREVERSE)\r\nhdlc->do_bitreverse = 1;\r\n}\r\nstatic int\r\ncheck_frame(struct isdnhdlc_vars *hdlc)\r\n{\r\nint status;\r\nif (hdlc->dstpos < 2)\r\nstatus = -HDLC_FRAMING_ERROR;\r\nelse if (hdlc->crc != 0xf0b8)\r\nstatus = -HDLC_CRC_ERROR;\r\nelse {\r\nhdlc->dstpos -= 2;\r\nstatus = hdlc->dstpos;\r\n}\r\nreturn status;\r\n}\r\nint isdnhdlc_decode(struct isdnhdlc_vars *hdlc, const u8 *src, int slen,\r\nint *count, u8 *dst, int dsize)\r\n{\r\nint status = 0;\r\nstatic const unsigned char fast_flag[] = {\r\n0x00, 0x00, 0x00, 0x20, 0x30, 0x38, 0x3c, 0x3e, 0x3f\r\n};\r\nstatic const unsigned char fast_flag_value[] = {\r\n0x00, 0x7e, 0xfc, 0xf9, 0xf3, 0xe7, 0xcf, 0x9f, 0x3f\r\n};\r\nstatic const unsigned char fast_abort[] = {\r\n0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff\r\n};\r\n#define handle_fast_flag(h) \\r\ndo {\\r\nif (h->cbin == fast_flag[h->bit_shift]) {\\r\nh->ffvalue = fast_flag_value[h->bit_shift];\\r\nh->state = HDLC_FAST_FLAG;\\r\nh->ffbit_shift = h->bit_shift;\\r\nh->bit_shift = 1;\\r\n} else {\\r\nh->state = HDLC_GET_DATA;\\r\nh->data_received = 0;\\r\n} \\r\n} while (0)\r\n#define handle_abort(h) \\r\ndo {\\r\nh->shift_reg = fast_abort[h->ffbit_shift - 1];\\r\nh->hdlc_bits1 = h->ffbit_shift - 2;\\r\nif (h->hdlc_bits1 < 0)\\r\nh->hdlc_bits1 = 0;\\r\nh->data_bits = h->ffbit_shift - 1;\\r\nh->state = HDLC_GET_DATA;\\r\nh->data_received = 0;\\r\n} while (0)\r\n*count = slen;\r\nwhile (slen > 0) {\r\nif (hdlc->bit_shift == 0) {\r\nif (hdlc->do_bitreverse == 0)\r\nhdlc->cbin = bitrev8(*src++);\r\nelse\r\nhdlc->cbin = *src++;\r\nslen--;\r\nhdlc->bit_shift = 8;\r\nif (hdlc->do_adapt56)\r\nhdlc->bit_shift--;\r\n}\r\nswitch (hdlc->state) {\r\ncase STOPPED:\r\nreturn 0;\r\ncase HDLC_FAST_IDLE:\r\nif (hdlc->cbin == 0xff) {\r\nhdlc->bit_shift = 0;\r\nbreak;\r\n}\r\nhdlc->state = HDLC_GET_FLAG_B0;\r\nhdlc->hdlc_bits1 = 0;\r\nhdlc->bit_shift = 8;\r\nbreak;\r\ncase HDLC_GET_FLAG_B0:\r\nif (!(hdlc->cbin & 0x80)) {\r\nhdlc->state = HDLC_GETFLAG_B1A6;\r\nhdlc->hdlc_bits1 = 0;\r\n} else {\r\nif ((!hdlc->do_adapt56) &&\r\n(++hdlc->hdlc_bits1 >= 8) &&\r\n(hdlc->bit_shift == 1))\r\nhdlc->state = HDLC_FAST_IDLE;\r\n}\r\nhdlc->cbin <<= 1;\r\nhdlc->bit_shift--;\r\nbreak;\r\ncase HDLC_GETFLAG_B1A6:\r\nif (hdlc->cbin & 0x80) {\r\nhdlc->hdlc_bits1++;\r\nif (hdlc->hdlc_bits1 == 6)\r\nhdlc->state = HDLC_GETFLAG_B7;\r\n} else\r\nhdlc->hdlc_bits1 = 0;\r\nhdlc->cbin <<= 1;\r\nhdlc->bit_shift--;\r\nbreak;\r\ncase HDLC_GETFLAG_B7:\r\nif (hdlc->cbin & 0x80) {\r\nhdlc->state = HDLC_GET_FLAG_B0;\r\n} else {\r\nhdlc->state = HDLC_GET_DATA;\r\nhdlc->crc = 0xffff;\r\nhdlc->shift_reg = 0;\r\nhdlc->hdlc_bits1 = 0;\r\nhdlc->data_bits = 0;\r\nhdlc->data_received = 0;\r\n}\r\nhdlc->cbin <<= 1;\r\nhdlc->bit_shift--;\r\nbreak;\r\ncase HDLC_GET_DATA:\r\nif (hdlc->cbin & 0x80) {\r\nhdlc->hdlc_bits1++;\r\nswitch (hdlc->hdlc_bits1) {\r\ncase 6:\r\nbreak;\r\ncase 7:\r\nif (hdlc->data_received)\r\nstatus = -HDLC_FRAMING_ERROR;\r\nif (!hdlc->do_adapt56) {\r\nif (hdlc->cbin == fast_abort\r\n[hdlc->bit_shift + 1]) {\r\nhdlc->state =\r\nHDLC_FAST_IDLE;\r\nhdlc->bit_shift = 1;\r\nbreak;\r\n}\r\n} else\r\nhdlc->state = HDLC_GET_FLAG_B0;\r\nbreak;\r\ndefault:\r\nhdlc->shift_reg >>= 1;\r\nhdlc->shift_reg |= 0x80;\r\nhdlc->data_bits++;\r\nbreak;\r\n}\r\n} else {\r\nswitch (hdlc->hdlc_bits1) {\r\ncase 5:\r\nbreak;\r\ncase 6:\r\nif (hdlc->data_received)\r\nstatus = check_frame(hdlc);\r\nhdlc->crc = 0xffff;\r\nhdlc->shift_reg = 0;\r\nhdlc->data_bits = 0;\r\nif (!hdlc->do_adapt56)\r\nhandle_fast_flag(hdlc);\r\nelse {\r\nhdlc->state = HDLC_GET_DATA;\r\nhdlc->data_received = 0;\r\n}\r\nbreak;\r\ndefault:\r\nhdlc->shift_reg >>= 1;\r\nhdlc->data_bits++;\r\nbreak;\r\n}\r\nhdlc->hdlc_bits1 = 0;\r\n}\r\nif (status) {\r\nhdlc->dstpos = 0;\r\n*count -= slen;\r\nhdlc->cbin <<= 1;\r\nhdlc->bit_shift--;\r\nreturn status;\r\n}\r\nif (hdlc->data_bits == 8) {\r\nhdlc->data_bits = 0;\r\nhdlc->data_received = 1;\r\nhdlc->crc = crc_ccitt_byte(hdlc->crc,\r\nhdlc->shift_reg);\r\nif (hdlc->dstpos < dsize)\r\ndst[hdlc->dstpos++] = hdlc->shift_reg;\r\nelse {\r\nstatus = -HDLC_LENGTH_ERROR;\r\nhdlc->dstpos = 0;\r\n}\r\n}\r\nhdlc->cbin <<= 1;\r\nhdlc->bit_shift--;\r\nbreak;\r\ncase HDLC_FAST_FLAG:\r\nif (hdlc->cbin == hdlc->ffvalue) {\r\nhdlc->bit_shift = 0;\r\nbreak;\r\n} else {\r\nif (hdlc->cbin == 0xff) {\r\nhdlc->state = HDLC_FAST_IDLE;\r\nhdlc->bit_shift = 0;\r\n} else if (hdlc->ffbit_shift == 8) {\r\nhdlc->state = HDLC_GETFLAG_B7;\r\nbreak;\r\n} else\r\nhandle_abort(hdlc);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n*count -= slen;\r\nreturn 0;\r\n}\r\nint isdnhdlc_encode(struct isdnhdlc_vars *hdlc, const u8 *src, u16 slen,\r\nint *count, u8 *dst, int dsize)\r\n{\r\nstatic const unsigned char xfast_flag_value[] = {\r\n0x7e, 0x3f, 0x9f, 0xcf, 0xe7, 0xf3, 0xf9, 0xfc, 0x7e\r\n};\r\nint len = 0;\r\n*count = slen;\r\nif ((slen == 1) && (hdlc->state == HDLC_SEND_FAST_FLAG))\r\nhdlc->state = HDLC_SENDFLAG_ONE;\r\nwhile (dsize > 0) {\r\nif (hdlc->bit_shift == 0) {\r\nif (slen && !hdlc->do_closing) {\r\nhdlc->shift_reg = *src++;\r\nslen--;\r\nif (slen == 0)\r\nhdlc->do_closing = 1;\r\nhdlc->bit_shift = 8;\r\n} else {\r\nif (hdlc->state == HDLC_SEND_DATA) {\r\nif (hdlc->data_received) {\r\nhdlc->state = HDLC_SEND_CRC1;\r\nhdlc->crc ^= 0xffff;\r\nhdlc->bit_shift = 8;\r\nhdlc->shift_reg =\r\nhdlc->crc & 0xff;\r\n} else if (!hdlc->do_adapt56)\r\nhdlc->state =\r\nHDLC_SEND_FAST_FLAG;\r\nelse\r\nhdlc->state =\r\nHDLC_SENDFLAG_B0;\r\n}\r\n}\r\n}\r\nswitch (hdlc->state) {\r\ncase STOPPED:\r\nwhile (dsize--)\r\n*dst++ = 0xff;\r\nreturn dsize;\r\ncase HDLC_SEND_FAST_FLAG:\r\nhdlc->do_closing = 0;\r\nif (slen == 0) {\r\nif (hdlc->do_bitreverse == 0)\r\n*dst++ = bitrev8(hdlc->ffvalue);\r\nelse\r\n*dst++ = hdlc->ffvalue;\r\nlen++;\r\ndsize--;\r\nbreak;\r\n}\r\ncase HDLC_SENDFLAG_ONE:\r\nif (hdlc->bit_shift == 8) {\r\nhdlc->cbin = hdlc->ffvalue >>\r\n(8 - hdlc->data_bits);\r\nhdlc->state = HDLC_SEND_DATA;\r\nhdlc->crc = 0xffff;\r\nhdlc->hdlc_bits1 = 0;\r\nhdlc->data_received = 1;\r\n}\r\nbreak;\r\ncase HDLC_SENDFLAG_B0:\r\nhdlc->do_closing = 0;\r\nhdlc->cbin <<= 1;\r\nhdlc->data_bits++;\r\nhdlc->hdlc_bits1 = 0;\r\nhdlc->state = HDLC_SENDFLAG_B1A6;\r\nbreak;\r\ncase HDLC_SENDFLAG_B1A6:\r\nhdlc->cbin <<= 1;\r\nhdlc->data_bits++;\r\nhdlc->cbin++;\r\nif (++hdlc->hdlc_bits1 == 6)\r\nhdlc->state = HDLC_SENDFLAG_B7;\r\nbreak;\r\ncase HDLC_SENDFLAG_B7:\r\nhdlc->cbin <<= 1;\r\nhdlc->data_bits++;\r\nif (slen == 0) {\r\nhdlc->state = HDLC_SENDFLAG_B0;\r\nbreak;\r\n}\r\nif (hdlc->bit_shift == 8) {\r\nhdlc->state = HDLC_SEND_DATA;\r\nhdlc->crc = 0xffff;\r\nhdlc->hdlc_bits1 = 0;\r\nhdlc->data_received = 1;\r\n}\r\nbreak;\r\ncase HDLC_SEND_FIRST_FLAG:\r\nhdlc->data_received = 1;\r\nif (hdlc->data_bits == 8) {\r\nhdlc->state = HDLC_SEND_DATA;\r\nhdlc->crc = 0xffff;\r\nhdlc->hdlc_bits1 = 0;\r\nbreak;\r\n}\r\nhdlc->cbin <<= 1;\r\nhdlc->data_bits++;\r\nif (hdlc->shift_reg & 0x01)\r\nhdlc->cbin++;\r\nhdlc->shift_reg >>= 1;\r\nhdlc->bit_shift--;\r\nif (hdlc->bit_shift == 0) {\r\nhdlc->state = HDLC_SEND_DATA;\r\nhdlc->crc = 0xffff;\r\nhdlc->hdlc_bits1 = 0;\r\n}\r\nbreak;\r\ncase HDLC_SEND_DATA:\r\nhdlc->cbin <<= 1;\r\nhdlc->data_bits++;\r\nif (hdlc->hdlc_bits1 == 5) {\r\nhdlc->hdlc_bits1 = 0;\r\nbreak;\r\n}\r\nif (hdlc->bit_shift == 8)\r\nhdlc->crc = crc_ccitt_byte(hdlc->crc,\r\nhdlc->shift_reg);\r\nif (hdlc->shift_reg & 0x01) {\r\nhdlc->hdlc_bits1++;\r\nhdlc->cbin++;\r\nhdlc->shift_reg >>= 1;\r\nhdlc->bit_shift--;\r\n} else {\r\nhdlc->hdlc_bits1 = 0;\r\nhdlc->shift_reg >>= 1;\r\nhdlc->bit_shift--;\r\n}\r\nbreak;\r\ncase HDLC_SEND_CRC1:\r\nhdlc->cbin <<= 1;\r\nhdlc->data_bits++;\r\nif (hdlc->hdlc_bits1 == 5) {\r\nhdlc->hdlc_bits1 = 0;\r\nbreak;\r\n}\r\nif (hdlc->shift_reg & 0x01) {\r\nhdlc->hdlc_bits1++;\r\nhdlc->cbin++;\r\nhdlc->shift_reg >>= 1;\r\nhdlc->bit_shift--;\r\n} else {\r\nhdlc->hdlc_bits1 = 0;\r\nhdlc->shift_reg >>= 1;\r\nhdlc->bit_shift--;\r\n}\r\nif (hdlc->bit_shift == 0) {\r\nhdlc->shift_reg = (hdlc->crc >> 8);\r\nhdlc->state = HDLC_SEND_CRC2;\r\nhdlc->bit_shift = 8;\r\n}\r\nbreak;\r\ncase HDLC_SEND_CRC2:\r\nhdlc->cbin <<= 1;\r\nhdlc->data_bits++;\r\nif (hdlc->hdlc_bits1 == 5) {\r\nhdlc->hdlc_bits1 = 0;\r\nbreak;\r\n}\r\nif (hdlc->shift_reg & 0x01) {\r\nhdlc->hdlc_bits1++;\r\nhdlc->cbin++;\r\nhdlc->shift_reg >>= 1;\r\nhdlc->bit_shift--;\r\n} else {\r\nhdlc->hdlc_bits1 = 0;\r\nhdlc->shift_reg >>= 1;\r\nhdlc->bit_shift--;\r\n}\r\nif (hdlc->bit_shift == 0) {\r\nhdlc->shift_reg = 0x7e;\r\nhdlc->state = HDLC_SEND_CLOSING_FLAG;\r\nhdlc->bit_shift = 8;\r\n}\r\nbreak;\r\ncase HDLC_SEND_CLOSING_FLAG:\r\nhdlc->cbin <<= 1;\r\nhdlc->data_bits++;\r\nif (hdlc->hdlc_bits1 == 5) {\r\nhdlc->hdlc_bits1 = 0;\r\nbreak;\r\n}\r\nif (hdlc->shift_reg & 0x01)\r\nhdlc->cbin++;\r\nhdlc->shift_reg >>= 1;\r\nhdlc->bit_shift--;\r\nif (hdlc->bit_shift == 0) {\r\nhdlc->ffvalue =\r\nxfast_flag_value[hdlc->data_bits];\r\nif (hdlc->dchannel) {\r\nhdlc->ffvalue = 0x7e;\r\nhdlc->state = HDLC_SEND_IDLE1;\r\nhdlc->bit_shift = 8-hdlc->data_bits;\r\nif (hdlc->bit_shift == 0)\r\nhdlc->state =\r\nHDLC_SEND_FAST_IDLE;\r\n} else {\r\nif (!hdlc->do_adapt56) {\r\nhdlc->state =\r\nHDLC_SEND_FAST_FLAG;\r\nhdlc->data_received = 0;\r\n} else {\r\nhdlc->state = HDLC_SENDFLAG_B0;\r\nhdlc->data_received = 0;\r\n}\r\nif (dsize > 1)\r\ndsize = 1;\r\n}\r\n}\r\nbreak;\r\ncase HDLC_SEND_IDLE1:\r\nhdlc->do_closing = 0;\r\nhdlc->cbin <<= 1;\r\nhdlc->cbin++;\r\nhdlc->data_bits++;\r\nhdlc->bit_shift--;\r\nif (hdlc->bit_shift == 0) {\r\nhdlc->state = HDLC_SEND_FAST_IDLE;\r\nhdlc->bit_shift = 0;\r\n}\r\nbreak;\r\ncase HDLC_SEND_FAST_IDLE:\r\nhdlc->do_closing = 0;\r\nhdlc->cbin = 0xff;\r\nhdlc->data_bits = 8;\r\nif (hdlc->bit_shift == 8) {\r\nhdlc->cbin = 0x7e;\r\nhdlc->state = HDLC_SEND_FIRST_FLAG;\r\n} else {\r\nif (hdlc->do_bitreverse == 0)\r\n*dst++ = bitrev8(hdlc->cbin);\r\nelse\r\n*dst++ = hdlc->cbin;\r\nhdlc->bit_shift = 0;\r\nhdlc->data_bits = 0;\r\nlen++;\r\ndsize = 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (hdlc->do_adapt56) {\r\nif (hdlc->data_bits == 7) {\r\nhdlc->cbin <<= 1;\r\nhdlc->cbin++;\r\nhdlc->data_bits++;\r\n}\r\n}\r\nif (hdlc->data_bits == 8) {\r\nif (hdlc->do_bitreverse == 0)\r\n*dst++ = bitrev8(hdlc->cbin);\r\nelse\r\n*dst++ = hdlc->cbin;\r\nhdlc->data_bits = 0;\r\nlen++;\r\ndsize--;\r\n}\r\n}\r\n*count -= slen;\r\nreturn len;\r\n}
