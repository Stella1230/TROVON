static void rtsx_calibration(struct rtsx_chip *chip)\r\n{\r\nrtsx_write_phy_register(chip, 0x1B, 0x135E);\r\nwait_timeout(10);\r\nrtsx_write_phy_register(chip, 0x00, 0x0280);\r\nrtsx_write_phy_register(chip, 0x01, 0x7112);\r\nrtsx_write_phy_register(chip, 0x01, 0x7110);\r\nrtsx_write_phy_register(chip, 0x01, 0x7112);\r\nrtsx_write_phy_register(chip, 0x01, 0x7113);\r\nrtsx_write_phy_register(chip, 0x00, 0x0288);\r\n}\r\nvoid rtsx_disable_card_int(struct rtsx_chip *chip)\r\n{\r\nu32 reg = rtsx_readl(chip, RTSX_BIER);\r\nreg &= ~(XD_INT_EN | SD_INT_EN | MS_INT_EN);\r\nrtsx_writel(chip, RTSX_BIER, reg);\r\n}\r\nvoid rtsx_enable_card_int(struct rtsx_chip *chip)\r\n{\r\nu32 reg = rtsx_readl(chip, RTSX_BIER);\r\nint i;\r\nfor (i = 0; i <= chip->max_lun; i++) {\r\nif (chip->lun2card[i] & XD_CARD)\r\nreg |= XD_INT_EN;\r\nif (chip->lun2card[i] & SD_CARD)\r\nreg |= SD_INT_EN;\r\nif (chip->lun2card[i] & MS_CARD)\r\nreg |= MS_INT_EN;\r\n}\r\nif (chip->hw_bypass_sd)\r\nreg &= ~((u32)SD_INT_EN);\r\nrtsx_writel(chip, RTSX_BIER, reg);\r\n}\r\nvoid rtsx_enable_bus_int(struct rtsx_chip *chip)\r\n{\r\nu32 reg = 0;\r\n#ifndef DISABLE_CARD_INT\r\nint i;\r\n#endif\r\nreg = TRANS_OK_INT_EN | TRANS_FAIL_INT_EN;\r\n#ifndef DISABLE_CARD_INT\r\nfor (i = 0; i <= chip->max_lun; i++) {\r\nRTSX_DEBUGP("lun2card[%d] = 0x%02x\n", i, chip->lun2card[i]);\r\nif (chip->lun2card[i] & XD_CARD)\r\nreg |= XD_INT_EN;\r\nif (chip->lun2card[i] & SD_CARD)\r\nreg |= SD_INT_EN;\r\nif (chip->lun2card[i] & MS_CARD)\r\nreg |= MS_INT_EN;\r\n}\r\nif (chip->hw_bypass_sd)\r\nreg &= ~((u32)SD_INT_EN);\r\n#endif\r\nif (chip->ic_version >= IC_VER_C)\r\nreg |= DELINK_INT_EN;\r\n#ifdef SUPPORT_OCP\r\nif (CHECK_PID(chip, 0x5209)) {\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\r\nreg |= MS_OC_INT_EN | SD_OC_INT_EN;\r\n} else {\r\nreg |= SD_OC_INT_EN;\r\n}\r\n} else {\r\nreg |= OC_INT_EN;\r\n}\r\n#endif\r\nif (!chip->adma_mode)\r\nreg |= DATA_DONE_INT_EN;\r\nrtsx_writel(chip, RTSX_BIER, reg);\r\nRTSX_DEBUGP("RTSX_BIER: 0x%08x\n", reg);\r\n}\r\nvoid rtsx_disable_bus_int(struct rtsx_chip *chip)\r\n{\r\nrtsx_writel(chip, RTSX_BIER, 0);\r\n}\r\nstatic int rtsx_pre_handle_sdio_old(struct rtsx_chip *chip)\r\n{\r\nif (chip->ignore_sd && CHK_SDIO_EXIST(chip)) {\r\nif (chip->asic_code) {\r\nRTSX_WRITE_REG(chip, CARD_PULL_CTL5, 0xFF,\r\nMS_INS_PU | SD_WP_PU | SD_CD_PU | SD_CMD_PU);\r\n} else {\r\nRTSX_WRITE_REG(chip, FPGA_PULL_CTL, 0xFF, FPGA_SD_PULL_CTL_EN);\r\n}\r\nRTSX_WRITE_REG(chip, CARD_SHARE_MODE, 0xFF, CARD_SHARE_48_SD);\r\nRTSX_WRITE_REG(chip, 0xFF2C, 0x01, 0x01);\r\nRTSX_WRITE_REG(chip, SDIO_CTRL, 0xFF, SDIO_BUS_CTRL | SDIO_CD_CTRL);\r\nchip->sd_int = 1;\r\nchip->sd_io = 1;\r\n} else {\r\nchip->need_reset |= SD_CARD;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int rtsx_pre_handle_sdio_new(struct rtsx_chip *chip)\r\n{\r\nu8 tmp;\r\nint sw_bypass_sd = 0;\r\nint retval;\r\nif (chip->driver_first_load) {\r\nif (CHECK_PID(chip, 0x5288)) {\r\nRTSX_READ_REG(chip, 0xFE5A, &tmp);\r\nif (tmp & 0x08)\r\nsw_bypass_sd = 1;\r\n} else if (CHECK_PID(chip, 0x5208)) {\r\nRTSX_READ_REG(chip, 0xFE70, &tmp);\r\nif (tmp & 0x80)\r\nsw_bypass_sd = 1;\r\n} else if (CHECK_PID(chip, 0x5209)) {\r\nRTSX_READ_REG(chip, SDIO_CFG, &tmp);\r\nif (tmp & SDIO_BUS_AUTO_SWITCH)\r\nsw_bypass_sd = 1;\r\n}\r\n} else {\r\nif (chip->sdio_in_charge)\r\nsw_bypass_sd = 1;\r\n}\r\nRTSX_DEBUGP("chip->sdio_in_charge = %d\n", chip->sdio_in_charge);\r\nRTSX_DEBUGP("chip->driver_first_load = %d\n", chip->driver_first_load);\r\nRTSX_DEBUGP("sw_bypass_sd = %d\n", sw_bypass_sd);\r\nif (sw_bypass_sd) {\r\nu8 cd_toggle_mask = 0;\r\nRTSX_READ_REG(chip, TLPTISTAT, &tmp);\r\nif (CHECK_PID(chip, 0x5209)) {\r\ncd_toggle_mask = 0x10;\r\n} else {\r\ncd_toggle_mask = 0x08;\r\n}\r\nif (tmp & cd_toggle_mask) {\r\nif (CHECK_PID(chip, 0x5288)) {\r\nRTSX_WRITE_REG(chip, 0xFE5A, 0x08, 0x00);\r\n} else if (CHECK_PID(chip, 0x5208)) {\r\nRTSX_WRITE_REG(chip, 0xFE70, 0x80, 0x00);\r\n} else {\r\nRTSX_WRITE_REG(chip, SDIO_CFG, SDIO_BUS_AUTO_SWITCH, 0);\r\n}\r\nRTSX_WRITE_REG(chip, TLPTISTAT, 0xFF, tmp);\r\nchip->need_reset |= SD_CARD;\r\n} else {\r\nRTSX_DEBUGP("Chip inserted with SDIO!\n");\r\nif (chip->asic_code) {\r\nretval = sd_pull_ctl_enable(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n} else {\r\nRTSX_WRITE_REG(chip, FPGA_PULL_CTL, FPGA_SD_PULL_CTL_BIT | 0x20, 0);\r\n}\r\nretval = card_share_mode(chip, SD_CARD);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nif (CHECK_PID(chip, 0x5288)) {\r\nRTSX_WRITE_REG(chip, 0xFE5A, 0x08, 0x08);\r\n} else if (CHECK_PID(chip, 0x5208)) {\r\nRTSX_WRITE_REG(chip, 0xFE70, 0x80, 0x80);\r\n} else {\r\nRTSX_WRITE_REG(chip, SDIO_CFG,\r\nSDIO_BUS_AUTO_SWITCH, SDIO_BUS_AUTO_SWITCH);\r\n}\r\nchip->chip_insert_with_sdio = 1;\r\nchip->sd_io = 1;\r\n}\r\n} else {\r\nif (CHECK_PID(chip, 0x5209)) {\r\nRTSX_WRITE_REG(chip, TLPTISTAT, 0x10, 0x10);\r\n} else {\r\nRTSX_WRITE_REG(chip, TLPTISTAT, 0x08, 0x08);\r\n}\r\nchip->need_reset |= SD_CARD;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_reset_chip(struct rtsx_chip *chip)\r\n{\r\nint retval;\r\nrtsx_writel(chip, RTSX_HCBAR, chip->host_cmds_addr);\r\nrtsx_disable_aspm(chip);\r\nif (CHECK_PID(chip, 0x5209) && chip->asic_code) {\r\nu16 val;\r\nretval = rtsx_write_phy_register(chip, 0x00, 0xB966);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nretval = rtsx_write_phy_register(chip, 0x01, 0x713F);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nretval = rtsx_write_phy_register(chip, 0x03, 0xA549);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nretval = rtsx_write_phy_register(chip, 0x06, 0xB235);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nretval = rtsx_write_phy_register(chip, 0x07, 0xEF40);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nretval = rtsx_write_phy_register(chip, 0x1E, 0xF8EB);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nretval = rtsx_write_phy_register(chip, 0x19, 0xFE6C);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nwait_timeout(1);\r\nretval = rtsx_write_phy_register(chip, 0x0A, 0x05C0);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nretval = rtsx_write_cfg_dw(chip, 1, 0x110, 0xFFFF, 0xFFFF);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nretval = rtsx_read_phy_register(chip, 0x08, &val);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nRTSX_DEBUGP("Read from phy 0x08: 0x%04x\n", val);\r\nif (chip->phy_voltage) {\r\nchip->phy_voltage &= 0x3F;\r\nRTSX_DEBUGP("chip->phy_voltage = 0x%x\n", chip->phy_voltage);\r\nval &= ~0x3F;\r\nval |= chip->phy_voltage;\r\nRTSX_DEBUGP("Write to phy 0x08: 0x%04x\n", val);\r\nretval = rtsx_write_phy_register(chip, 0x08, val);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n} else {\r\nchip->phy_voltage = (u8)(val & 0x3F);\r\nRTSX_DEBUGP("Default, chip->phy_voltage = 0x%x\n", chip->phy_voltage);\r\n}\r\n}\r\nRTSX_WRITE_REG(chip, HOST_SLEEP_STATE, 0x03, 0x00);\r\nRTSX_WRITE_REG(chip, CARD_CLK_EN, 0x1E, 0);\r\n#ifdef SUPPORT_OCP\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\r\nRTSX_WRITE_REG(chip, FPDCTL, OC_POWER_DOWN, 0);\r\n} else {\r\nRTSX_WRITE_REG(chip, FPDCTL, OC_POWER_DOWN, MS_OC_POWER_DOWN);\r\n}\r\nif (CHECK_PID(chip, 0x5209)) {\r\nRTSX_WRITE_REG(chip, OCPPARA1, SD_OCP_TIME_MASK | MS_OCP_TIME_MASK,\r\nSD_OCP_TIME_800 | MS_OCP_TIME_800);\r\nRTSX_WRITE_REG(chip, OCPPARA2, SD_OCP_THD_MASK | MS_OCP_THD_MASK,\r\nchip->sd_400mA_ocp_thd | (chip->ms_ocp_thd << 4));\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\r\nRTSX_WRITE_REG(chip, OCPGLITCH, SD_OCP_GLITCH_MASK | MS_OCP_GLITCH_MASK,\r\nSD_OCP_GLITCH_10000 | MS_OCP_GLITCH_10000);\r\n} else {\r\nRTSX_WRITE_REG(chip, OCPGLITCH, SD_OCP_GLITCH_MASK, SD_OCP_GLITCH_10000);\r\n}\r\nRTSX_WRITE_REG(chip, OCPCTL, 0xFF,\r\nSD_OCP_INT_EN | SD_DETECT_EN | MS_OCP_INT_EN | MS_DETECT_EN);\r\n} else {\r\nRTSX_WRITE_REG(chip, OCPPARA1, OCP_TIME_MASK, OCP_TIME_800);\r\nRTSX_WRITE_REG(chip, OCPPARA2, OCP_THD_MASK, OCP_THD_244_946);\r\nRTSX_WRITE_REG(chip, OCPCTL, 0xFF, CARD_OC_INT_EN | CARD_DETECT_EN);\r\n}\r\n#else\r\nRTSX_WRITE_REG(chip, FPDCTL, OC_POWER_DOWN, OC_POWER_DOWN);\r\n#endif\r\nif (!CHECK_PID(chip, 0x5288)) {\r\nRTSX_WRITE_REG(chip, CARD_GPIO_DIR, 0xFF, 0x03);\r\n}\r\nRTSX_WRITE_REG(chip, CARD_GPIO, 0xFF, 0x03);\r\nRTSX_WRITE_REG(chip, CHANGE_LINK_STATE, 0x0A, 0);\r\nRTSX_WRITE_REG(chip, CARD_DRIVE_SEL, 0xFF, chip->card_drive_sel);\r\nif (CHECK_PID(chip, 0x5209)) {\r\nRTSX_WRITE_REG(chip, SD30_DRIVE_SEL, 0x07, chip->sd30_drive_sel_3v3);\r\n}\r\n#ifdef LED_AUTO_BLINK\r\nRTSX_WRITE_REG(chip, CARD_AUTO_BLINK, 0xFF,\r\nLED_BLINK_SPEED | BLINK_EN | LED_GPIO0);\r\n#endif\r\nif (chip->asic_code) {\r\nRTSX_WRITE_REG(chip, SSC_CTL1, 0xFF, SSC_8X_EN | SSC_SEL_4M);\r\nRTSX_WRITE_REG(chip, SSC_CTL2, 0xFF, 0x12);\r\n}\r\nRTSX_WRITE_REG(chip, CHANGE_LINK_STATE, 0x16, 0x10);\r\nif (chip->aspm_l0s_l1_en) {\r\nif (chip->dynamic_aspm) {\r\nif (CHK_SDIO_EXIST(chip)) {\r\nif (CHECK_PID(chip, 0x5209)) {\r\nretval = rtsx_write_cfg_dw(chip, 1, 0xC0, 0xFF, chip->aspm_l0s_l1_en);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n} else if (CHECK_PID(chip, 0x5288)) {\r\nretval = rtsx_write_cfg_dw(chip, 2, 0xC0, 0xFF, chip->aspm_l0s_l1_en);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\n}\r\n} else {\r\nif (CHECK_PID(chip, 0x5208)) {\r\nRTSX_WRITE_REG(chip, ASPM_FORCE_CTL, 0xFF, 0x3F);\r\n}\r\nretval = rtsx_write_config_byte(chip, LCTLR, chip->aspm_l0s_l1_en);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nchip->aspm_level[0] = chip->aspm_l0s_l1_en;\r\nif (CHK_SDIO_EXIST(chip)) {\r\nchip->aspm_level[1] = chip->aspm_l0s_l1_en;\r\nif (CHECK_PID(chip, 0x5288)) {\r\nretval = rtsx_write_cfg_dw(chip, 2, 0xC0, 0xFF, chip->aspm_l0s_l1_en);\r\n} else {\r\nretval = rtsx_write_cfg_dw(chip, 1, 0xC0, 0xFF, chip->aspm_l0s_l1_en);\r\n}\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nchip->aspm_enabled = 1;\r\n}\r\n} else {\r\nif (chip->asic_code && CHECK_PID(chip, 0x5208)) {\r\nretval = rtsx_write_phy_register(chip, 0x07, 0x0129);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nretval = rtsx_write_config_byte(chip, LCTLR, chip->aspm_l0s_l1_en);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nretval = rtsx_write_config_byte(chip, 0x81, 1);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nif (CHK_SDIO_EXIST(chip)) {\r\nif (CHECK_PID(chip, 0x5288)) {\r\nretval = rtsx_write_cfg_dw(chip, 2, 0xC0, 0xFF00, 0x0100);\r\n} else {\r\nretval = rtsx_write_cfg_dw(chip, 1, 0xC0, 0xFF00, 0x0100);\r\n}\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nif (CHECK_PID(chip, 0x5209)) {\r\nretval = rtsx_write_cfg_dw(chip, 0, 0x70C, 0xFF000000, 0x5B);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nif (CHECK_PID(chip, 0x5288)) {\r\nif (!CHK_SDIO_EXIST(chip)) {\r\nretval = rtsx_write_cfg_dw(chip, 2, 0xC0, 0xFFFF, 0x0103);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nretval = rtsx_write_cfg_dw(chip, 2, 0x84, 0xFF, 0x03);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\n}\r\nRTSX_WRITE_REG(chip, IRQSTAT0, LINK_RDY_INT, LINK_RDY_INT);\r\nRTSX_WRITE_REG(chip, PERST_GLITCH_WIDTH, 0xFF, 0x80);\r\nif (CHECK_PID(chip, 0x5209)) {\r\nRTSX_WRITE_REG(chip, PWD_SUSPEND_EN, 0xFF, 0xFF);\r\nRTSX_WRITE_REG(chip, PWR_GATE_CTRL, PWR_GATE_EN, PWR_GATE_EN);\r\n}\r\nif (chip->asic_code) {\r\nif (CHECK_PID(chip, 0x5208)) {\r\nif (chip->phy_debug_mode) {\r\nRTSX_WRITE_REG(chip, CDRESUMECTL, 0x77, 0);\r\nrtsx_disable_bus_int(chip);\r\n} else {\r\nrtsx_enable_bus_int(chip);\r\n}\r\nif (chip->ic_version >= IC_VER_D) {\r\nu16 reg;\r\nretval = rtsx_read_phy_register(chip, 0x00, &reg);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nreg &= 0xFE7F;\r\nreg |= 0x80;\r\nretval = rtsx_write_phy_register(chip, 0x00, reg);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nretval = rtsx_read_phy_register(chip, 0x1C, &reg);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nreg &= 0xFFF7;\r\nretval = rtsx_write_phy_register(chip, 0x1C, reg);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nif (chip->driver_first_load && (chip->ic_version < IC_VER_C)) {\r\nrtsx_calibration(chip);\r\n}\r\n} else {\r\nrtsx_enable_bus_int(chip);\r\n}\r\n} else {\r\nrtsx_enable_bus_int(chip);\r\n}\r\n#ifdef HW_INT_WRITE_CLR\r\nif (CHECK_PID(chip, 0x5209)) {\r\nRTSX_WRITE_REG(chip, NFTS_TX_CTRL, 0x02, 0);\r\n}\r\n#endif\r\nchip->need_reset = 0;\r\nchip->int_reg = rtsx_readl(chip, RTSX_BIPR);\r\n#ifdef HW_INT_WRITE_CLR\r\nif (CHECK_PID(chip, 0x5209)) {\r\nrtsx_writel(chip, RTSX_BIPR, chip->int_reg);\r\n}\r\n#endif\r\nif (chip->hw_bypass_sd)\r\ngoto NextCard;\r\nRTSX_DEBUGP("In rtsx_reset_chip, chip->int_reg = 0x%x\n", chip->int_reg);\r\nif (chip->int_reg & SD_EXIST) {\r\n#ifdef HW_AUTO_SWITCH_SD_BUS\r\nif (CHECK_PID(chip, 0x5208) && (chip->ic_version < IC_VER_C)) {\r\nretval = rtsx_pre_handle_sdio_old(chip);\r\n} else {\r\nretval = rtsx_pre_handle_sdio_new(chip);\r\n}\r\nRTSX_DEBUGP("chip->need_reset = 0x%x (rtsx_reset_chip)\n", (unsigned int)(chip->need_reset));\r\n#else\r\nretval = rtsx_pre_handle_sdio_old(chip);\r\n#endif\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n} else {\r\nchip->sd_io = 0;\r\nRTSX_WRITE_REG(chip, SDIO_CTRL, SDIO_BUS_CTRL | SDIO_CD_CTRL, 0);\r\n}\r\nNextCard:\r\nif (chip->int_reg & XD_EXIST)\r\nchip->need_reset |= XD_CARD;\r\nif (chip->int_reg & MS_EXIST)\r\nchip->need_reset |= MS_CARD;\r\nif (chip->int_reg & CARD_EXIST) {\r\nRTSX_WRITE_REG(chip, SSC_CTL1, SSC_RSTB, SSC_RSTB);\r\n}\r\nRTSX_DEBUGP("In rtsx_init_chip, chip->need_reset = 0x%x\n", (unsigned int)(chip->need_reset));\r\nRTSX_WRITE_REG(chip, RCCTL, 0x01, 0x00);\r\nif (CHECK_PID(chip, 0x5208) || CHECK_PID(chip, 0x5288)) {\r\nRTSX_WRITE_REG(chip, MAIN_PWR_OFF_CTL, 0x03, 0x03);\r\n}\r\nif (chip->remote_wakeup_en && !chip->auto_delink_en) {\r\nRTSX_WRITE_REG(chip, WAKE_SEL_CTL, 0x07, 0x07);\r\nif (chip->aux_pwr_exist) {\r\nRTSX_WRITE_REG(chip, PME_FORCE_CTL, 0xFF, 0x33);\r\n}\r\n} else {\r\nRTSX_WRITE_REG(chip, WAKE_SEL_CTL, 0x07, 0x04);\r\nRTSX_WRITE_REG(chip, PME_FORCE_CTL, 0xFF, 0x30);\r\n}\r\nif (CHECK_PID(chip, 0x5208) && (chip->ic_version >= IC_VER_D)) {\r\nRTSX_WRITE_REG(chip, PETXCFG, 0x1C, 0x14);\r\n} else if (CHECK_PID(chip, 0x5209)) {\r\nif (chip->force_clkreq_0) {\r\nRTSX_WRITE_REG(chip, PETXCFG, 0x08, 0x08);\r\n} else {\r\nRTSX_WRITE_REG(chip, PETXCFG, 0x08, 0x00);\r\n}\r\n}\r\nif (chip->asic_code && CHECK_PID(chip, 0x5208)) {\r\nretval = rtsx_clr_phy_reg_bit(chip, 0x1C, 2);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nif (chip->ft2_fast_mode) {\r\nRTSX_WRITE_REG(chip, CARD_PWR_CTL, 0xFF, MS_PARTIAL_POWER_ON | SD_PARTIAL_POWER_ON);\r\nudelay(chip->pmos_pwr_on_interval);\r\nRTSX_WRITE_REG(chip, CARD_PWR_CTL, 0xFF, MS_POWER_ON | SD_POWER_ON);\r\nwait_timeout(200);\r\n}\r\nrtsx_reset_detected_cards(chip, 0);\r\nchip->driver_first_load = 0;\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic inline int check_sd_speed_prior(u32 sd_speed_prior)\r\n{\r\nint i, fake_para = 0;\r\nfor (i = 0; i < 4; i++) {\r\nu8 tmp = (u8)(sd_speed_prior >> (i*8));\r\nif ((tmp < 0x01) || (tmp > 0x04)) {\r\nfake_para = 1;\r\nbreak;\r\n}\r\n}\r\nreturn !fake_para;\r\n}\r\nstatic inline int check_sd_current_prior(u32 sd_current_prior)\r\n{\r\nint i, fake_para = 0;\r\nfor (i = 0; i < 4; i++) {\r\nu8 tmp = (u8)(sd_current_prior >> (i*8));\r\nif (tmp > 0x03) {\r\nfake_para = 1;\r\nbreak;\r\n}\r\n}\r\nreturn !fake_para;\r\n}\r\nstatic int rts5209_init(struct rtsx_chip *chip)\r\n{\r\nint retval;\r\nu32 lval = 0;\r\nu8 val = 0;\r\nval = rtsx_readb(chip, 0x1C);\r\nif ((val & 0x10) == 0) {\r\nchip->asic_code = 1;\r\n} else {\r\nchip->asic_code = 0;\r\n}\r\nchip->ic_version = val & 0x0F;\r\nchip->phy_debug_mode = 0;\r\nchip->aux_pwr_exist = 0;\r\nchip->ms_power_class_en = 0x03;\r\nretval = rtsx_read_cfg_dw(chip, 0, 0x724, &lval);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nRTSX_DEBUGP("dw in 0x724: 0x%x\n", lval);\r\nval = (u8)lval;\r\nif (!(val & 0x80)) {\r\nif (val & 0x08)\r\nchip->lun_mode = DEFAULT_SINGLE;\r\nelse\r\nchip->lun_mode = SD_MS_2LUN;\r\nif (val & 0x04) {\r\nSET_SDIO_EXIST(chip);\r\n} else {\r\nCLR_SDIO_EXIST(chip);\r\n}\r\nif (val & 0x02) {\r\nchip->hw_bypass_sd = 0;\r\n} else {\r\nchip->hw_bypass_sd = 1;\r\n}\r\n} else {\r\nSET_SDIO_EXIST(chip);\r\nchip->hw_bypass_sd = 0;\r\n}\r\nif (chip->use_hw_setting) {\r\nu8 clk;\r\nchip->aspm_l0s_l1_en = (val >> 5) & 0x03;\r\nval = (u8)(lval >> 8);\r\nclk = (val >> 5) & 0x07;\r\nif (clk != 0x07) {\r\nchip->asic_sd_sdr50_clk = 98 - clk * 2;\r\n}\r\nif (val & 0x10) {\r\nchip->auto_delink_en = 1;\r\n} else {\r\nchip->auto_delink_en = 0;\r\n}\r\nif (chip->ss_en == 2) {\r\nchip->ss_en = 0;\r\n} else {\r\nif (val & 0x08) {\r\nchip->ss_en = 1;\r\n} else {\r\nchip->ss_en = 0;\r\n}\r\n}\r\nclk = val & 0x07;\r\nif (clk != 0x07)\r\nchip->asic_ms_hg_clk = (59 - clk) * 2;\r\nval = (u8)(lval >> 16);\r\nclk = (val >> 6) & 0x03;\r\nif (clk != 0x03) {\r\nchip->asic_sd_hs_clk = (49 - clk * 2) * 2;\r\nchip->asic_mmc_52m_clk = (49 - clk * 2) * 2;\r\n}\r\nclk = (val >> 4) & 0x03;\r\nif (clk != 0x03)\r\nchip->asic_sd_ddr50_clk = (48 - clk * 2) * 2;\r\nif (val & 0x01) {\r\nchip->sdr104_en = 1;\r\n} else {\r\nchip->sdr104_en = 0;\r\n}\r\nif (val & 0x02) {\r\nchip->ddr50_en = 1;\r\n} else {\r\nchip->ddr50_en = 0;\r\n}\r\nif (val & 0x04) {\r\nchip->sdr50_en = 1;\r\n} else {\r\nchip->sdr50_en = 0;\r\n}\r\nval = (u8)(lval >> 24);\r\nclk = (val >> 5) & 0x07;\r\nif (clk != 0x07)\r\nchip->asic_sd_sdr104_clk = 206 - clk * 3;\r\nif (val & 0x10) {\r\nchip->power_down_in_ss = 1;\r\n} else {\r\nchip->power_down_in_ss = 0;\r\n}\r\nchip->ms_power_class_en = val & 0x03;\r\n}\r\nif (chip->hp_watch_bios_hotplug && chip->auto_delink_en) {\r\nu8 reg58, reg5b;\r\nretval = rtsx_read_pci_cfg_byte(0x00,\r\n0x1C, 0x02, 0x58, &reg58);\r\nif (retval < 0) {\r\nreturn STATUS_SUCCESS;\r\n}\r\nretval = rtsx_read_pci_cfg_byte(0x00,\r\n0x1C, 0x02, 0x5B, &reg5b);\r\nif (retval < 0) {\r\nreturn STATUS_SUCCESS;\r\n}\r\nRTSX_DEBUGP("reg58 = 0x%x, reg5b = 0x%x\n", reg58, reg5b);\r\nif ((reg58 == 0x00) && (reg5b == 0x01)) {\r\nchip->auto_delink_en = 0;\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int rts5208_init(struct rtsx_chip *chip)\r\n{\r\nint retval;\r\nu16 reg = 0;\r\nu8 val = 0;\r\nRTSX_WRITE_REG(chip, CLK_SEL, 0x03, 0x03);\r\nRTSX_READ_REG(chip, CLK_SEL, &val);\r\nif (val == 0) {\r\nchip->asic_code = 1;\r\n} else {\r\nchip->asic_code = 0;\r\n}\r\nif (chip->asic_code) {\r\nretval = rtsx_read_phy_register(chip, 0x1C, &reg);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nRTSX_DEBUGP("Value of phy register 0x1C is 0x%x\n", reg);\r\nchip->ic_version = (reg >> 4) & 0x07;\r\nif (reg & PHY_DEBUG_MODE) {\r\nchip->phy_debug_mode = 1;\r\n} else {\r\nchip->phy_debug_mode = 0;\r\n}\r\n} else {\r\nRTSX_READ_REG(chip, 0xFE80, &val);\r\nchip->ic_version = val;\r\nchip->phy_debug_mode = 0;\r\n}\r\nRTSX_READ_REG(chip, PDINFO, &val);\r\nRTSX_DEBUGP("PDINFO: 0x%x\n", val);\r\nif (val & AUX_PWR_DETECTED) {\r\nchip->aux_pwr_exist = 1;\r\n} else {\r\nchip->aux_pwr_exist = 0;\r\n}\r\nRTSX_READ_REG(chip, 0xFE50, &val);\r\nif (val & 0x01) {\r\nchip->hw_bypass_sd = 1;\r\n} else {\r\nchip->hw_bypass_sd = 0;\r\n}\r\nrtsx_read_config_byte(chip, 0x0E, &val);\r\nif (val & 0x80) {\r\nSET_SDIO_EXIST(chip);\r\n} else {\r\nCLR_SDIO_EXIST(chip);\r\n}\r\nif (chip->use_hw_setting) {\r\nRTSX_READ_REG(chip, CHANGE_LINK_STATE, &val);\r\nif (val & 0x80) {\r\nchip->auto_delink_en = 1;\r\n} else {\r\nchip->auto_delink_en = 0;\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int rts5288_init(struct rtsx_chip *chip)\r\n{\r\nint retval;\r\nu8 val = 0, max_func;\r\nu32 lval = 0;\r\nRTSX_WRITE_REG(chip, CLK_SEL, 0x03, 0x03);\r\nRTSX_READ_REG(chip, CLK_SEL, &val);\r\nif (val == 0) {\r\nchip->asic_code = 1;\r\n} else {\r\nchip->asic_code = 0;\r\n}\r\nchip->ic_version = 0;\r\nchip->phy_debug_mode = 0;\r\nRTSX_READ_REG(chip, PDINFO, &val);\r\nRTSX_DEBUGP("PDINFO: 0x%x\n", val);\r\nif (val & AUX_PWR_DETECTED) {\r\nchip->aux_pwr_exist = 1;\r\n} else {\r\nchip->aux_pwr_exist = 0;\r\n}\r\nRTSX_READ_REG(chip, CARD_SHARE_MODE, &val);\r\nRTSX_DEBUGP("CARD_SHARE_MODE: 0x%x\n", val);\r\nif (val & 0x04) {\r\nchip->baro_pkg = QFN;\r\n} else {\r\nchip->baro_pkg = LQFP;\r\n}\r\nRTSX_READ_REG(chip, 0xFE5A, &val);\r\nif (val & 0x10) {\r\nchip->hw_bypass_sd = 1;\r\n} else {\r\nchip->hw_bypass_sd = 0;\r\n}\r\nretval = rtsx_read_cfg_dw(chip, 0, 0x718, &lval);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nmax_func = (u8)((lval >> 29) & 0x07);\r\nRTSX_DEBUGP("Max function number: %d\n", max_func);\r\nif (max_func == 0x02) {\r\nSET_SDIO_EXIST(chip);\r\n} else {\r\nCLR_SDIO_EXIST(chip);\r\n}\r\nif (chip->use_hw_setting) {\r\nRTSX_READ_REG(chip, CHANGE_LINK_STATE, &val);\r\nif (val & 0x80) {\r\nchip->auto_delink_en = 1;\r\n} else {\r\nchip->auto_delink_en = 0;\r\n}\r\nif (CHECK_BARO_PKG(chip, LQFP)) {\r\nchip->lun_mode = SD_MS_1LUN;\r\n} else {\r\nchip->lun_mode = DEFAULT_SINGLE;\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_init_chip(struct rtsx_chip *chip)\r\n{\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nint retval;\r\nunsigned int i;\r\nRTSX_DEBUGP("Vendor ID: 0x%04x, Product ID: 0x%04x\n",\r\nchip->vendor_id, chip->product_id);\r\nchip->ic_version = 0;\r\n#ifdef _MSG_TRACE\r\nchip->msg_idx = 0;\r\n#endif\r\nmemset(xd_card, 0, sizeof(struct xd_info));\r\nmemset(sd_card, 0, sizeof(struct sd_info));\r\nmemset(ms_card, 0, sizeof(struct ms_info));\r\nchip->xd_reset_counter = 0;\r\nchip->sd_reset_counter = 0;\r\nchip->ms_reset_counter = 0;\r\nchip->xd_show_cnt = MAX_SHOW_CNT;\r\nchip->sd_show_cnt = MAX_SHOW_CNT;\r\nchip->ms_show_cnt = MAX_SHOW_CNT;\r\nchip->sd_io = 0;\r\nchip->auto_delink_cnt = 0;\r\nchip->auto_delink_allowed = 1;\r\nrtsx_set_stat(chip, RTSX_STAT_INIT);\r\nchip->aspm_enabled = 0;\r\nchip->chip_insert_with_sdio = 0;\r\nchip->sdio_aspm = 0;\r\nchip->sdio_idle = 0;\r\nchip->sdio_counter = 0;\r\nchip->cur_card = 0;\r\nchip->phy_debug_mode = 0;\r\nchip->sdio_func_exist = 0;\r\nmemset(chip->sdio_raw_data, 0, 12);\r\nfor (i = 0; i < MAX_ALLOWED_LUN_CNT; i++) {\r\nset_sense_type(chip, i, SENSE_TYPE_NO_SENSE);\r\nchip->rw_fail_cnt[i] = 0;\r\n}\r\nif (!check_sd_speed_prior(chip->sd_speed_prior)) {\r\nchip->sd_speed_prior = 0x01040203;\r\n}\r\nRTSX_DEBUGP("sd_speed_prior = 0x%08x\n", chip->sd_speed_prior);\r\nif (!check_sd_current_prior(chip->sd_current_prior)) {\r\nchip->sd_current_prior = 0x00010203;\r\n}\r\nRTSX_DEBUGP("sd_current_prior = 0x%08x\n", chip->sd_current_prior);\r\nif ((chip->sd_ddr_tx_phase > 31) || (chip->sd_ddr_tx_phase < 0)) {\r\nchip->sd_ddr_tx_phase = 0;\r\n}\r\nif ((chip->mmc_ddr_tx_phase > 31) || (chip->mmc_ddr_tx_phase < 0)) {\r\nchip->mmc_ddr_tx_phase = 0;\r\n}\r\nRTSX_WRITE_REG(chip, FPDCTL, SSC_POWER_DOWN, 0);\r\nwait_timeout(200);\r\nRTSX_WRITE_REG(chip, CLK_DIV, 0x07, 0x07);\r\nRTSX_DEBUGP("chip->use_hw_setting = %d\n", chip->use_hw_setting);\r\nif (CHECK_PID(chip, 0x5209)) {\r\nretval = rts5209_init(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n} else if (CHECK_PID(chip, 0x5208)) {\r\nretval = rts5208_init(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n} else if (CHECK_PID(chip, 0x5288)) {\r\nretval = rts5288_init(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nif (chip->ss_en == 2) {\r\nchip->ss_en = 0;\r\n}\r\nRTSX_DEBUGP("chip->asic_code = %d\n", chip->asic_code);\r\nRTSX_DEBUGP("chip->ic_version = 0x%x\n", chip->ic_version);\r\nRTSX_DEBUGP("chip->phy_debug_mode = %d\n", chip->phy_debug_mode);\r\nRTSX_DEBUGP("chip->aux_pwr_exist = %d\n", chip->aux_pwr_exist);\r\nRTSX_DEBUGP("chip->sdio_func_exist = %d\n", chip->sdio_func_exist);\r\nRTSX_DEBUGP("chip->hw_bypass_sd = %d\n", chip->hw_bypass_sd);\r\nRTSX_DEBUGP("chip->aspm_l0s_l1_en = %d\n", chip->aspm_l0s_l1_en);\r\nRTSX_DEBUGP("chip->lun_mode = %d\n", chip->lun_mode);\r\nRTSX_DEBUGP("chip->auto_delink_en = %d\n", chip->auto_delink_en);\r\nRTSX_DEBUGP("chip->ss_en = %d\n", chip->ss_en);\r\nRTSX_DEBUGP("chip->baro_pkg = %d\n", chip->baro_pkg);\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\r\nchip->card2lun[SD_CARD] = 0;\r\nchip->card2lun[MS_CARD] = 1;\r\nchip->card2lun[XD_CARD] = 0xFF;\r\nchip->lun2card[0] = SD_CARD;\r\nchip->lun2card[1] = MS_CARD;\r\nchip->max_lun = 1;\r\nSET_SDIO_IGNORED(chip);\r\n} else if (CHECK_LUN_MODE(chip, SD_MS_1LUN)) {\r\nchip->card2lun[SD_CARD] = 0;\r\nchip->card2lun[MS_CARD] = 0;\r\nchip->card2lun[XD_CARD] = 0xFF;\r\nchip->lun2card[0] = SD_CARD | MS_CARD;\r\nchip->max_lun = 0;\r\n} else {\r\nchip->card2lun[XD_CARD] = 0;\r\nchip->card2lun[SD_CARD] = 0;\r\nchip->card2lun[MS_CARD] = 0;\r\nchip->lun2card[0] = XD_CARD | SD_CARD | MS_CARD;\r\nchip->max_lun = 0;\r\n}\r\nretval = rtsx_reset_chip(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nvoid rtsx_release_chip(struct rtsx_chip *chip)\r\n{\r\nxd_free_l2p_tbl(chip);\r\nms_free_l2p_tbl(chip);\r\nchip->card_exist = 0;\r\nchip->card_ready = 0;\r\n}\r\nstatic inline void rtsx_blink_led(struct rtsx_chip *chip)\r\n{\r\nif (chip->card_exist && chip->blink_led) {\r\nif (chip->led_toggle_counter < LED_TOGGLE_INTERVAL) {\r\nchip->led_toggle_counter++;\r\n} else {\r\nchip->led_toggle_counter = 0;\r\ntoggle_gpio(chip, LED_GPIO);\r\n}\r\n}\r\n}\r\nstatic void rtsx_monitor_aspm_config(struct rtsx_chip *chip)\r\n{\r\nint maybe_support_aspm, reg_changed;\r\nu32 tmp = 0;\r\nu8 reg0 = 0, reg1 = 0;\r\nmaybe_support_aspm = 0;\r\nreg_changed = 0;\r\nrtsx_read_config_byte(chip, LCTLR, &reg0);\r\nif (chip->aspm_level[0] != reg0) {\r\nreg_changed = 1;\r\nchip->aspm_level[0] = reg0;\r\n}\r\nif (CHK_SDIO_EXIST(chip) && !CHK_SDIO_IGNORED(chip)) {\r\nrtsx_read_cfg_dw(chip, 1, 0xC0, &tmp);\r\nreg1 = (u8)tmp;\r\nif (chip->aspm_level[1] != reg1) {\r\nreg_changed = 1;\r\nchip->aspm_level[1] = reg1;\r\n}\r\nif ((reg0 & 0x03) && (reg1 & 0x03)) {\r\nmaybe_support_aspm = 1;\r\n}\r\n} else {\r\nif (reg0 & 0x03) {\r\nmaybe_support_aspm = 1;\r\n}\r\n}\r\nif (reg_changed) {\r\nif (maybe_support_aspm) {\r\nchip->aspm_l0s_l1_en = 0x03;\r\n}\r\nRTSX_DEBUGP("aspm_level[0] = 0x%02x, aspm_level[1] = 0x%02x\n",\r\nchip->aspm_level[0], chip->aspm_level[1]);\r\nif (chip->aspm_l0s_l1_en) {\r\nchip->aspm_enabled = 1;\r\n} else {\r\nchip->aspm_enabled = 0;\r\nchip->sdio_aspm = 0;\r\n}\r\nrtsx_write_register(chip, ASPM_FORCE_CTL, 0xFF,\r\n0x30 | chip->aspm_level[0] | (chip->aspm_level[1] << 2));\r\n}\r\n}\r\nvoid rtsx_polling_func(struct rtsx_chip *chip)\r\n{\r\n#ifdef SUPPORT_SD_LOCK\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\n#endif\r\nint ss_allowed;\r\nif (rtsx_chk_stat(chip, RTSX_STAT_SUSPEND))\r\nreturn;\r\nif (rtsx_chk_stat(chip, RTSX_STAT_DELINK))\r\ngoto Delink_Stage;\r\nif (chip->polling_config) {\r\nu8 val;\r\nrtsx_read_config_byte(chip, 0, &val);\r\n}\r\nif (rtsx_chk_stat(chip, RTSX_STAT_SS))\r\nreturn;\r\n#ifdef SUPPORT_OCP\r\nif (chip->ocp_int) {\r\nrtsx_read_register(chip, OCPSTAT, &(chip->ocp_stat));\r\nif (CHECK_PID(chip, 0x5209) &&\r\nCHECK_LUN_MODE(chip, SD_MS_2LUN)) {\r\nif (chip->ocp_int & SD_OC_INT)\r\nsd_power_off_card3v3(chip);\r\nif (chip->ocp_int & MS_OC_INT)\r\nms_power_off_card3v3(chip);\r\n} else {\r\nif (chip->card_exist & SD_CARD) {\r\nsd_power_off_card3v3(chip);\r\n} else if (chip->card_exist & MS_CARD) {\r\nms_power_off_card3v3(chip);\r\n} else if (chip->card_exist & XD_CARD) {\r\nxd_power_off_card3v3(chip);\r\n}\r\n}\r\nchip->ocp_int = 0;\r\n}\r\n#endif\r\n#ifdef SUPPORT_SD_LOCK\r\nif (sd_card->sd_erase_status) {\r\nif (chip->card_exist & SD_CARD) {\r\nu8 val;\r\nif (CHECK_PID(chip, 0x5209)) {\r\nrtsx_read_register(chip, SD_BUS_STAT, &val);\r\nif (val & SD_DAT0_STATUS) {\r\nsd_card->sd_erase_status = SD_NOT_ERASE;\r\nsd_card->sd_lock_notify = 1;\r\nchip->need_reinit |= SD_CARD;\r\n}\r\n} else {\r\nrtsx_read_register(chip, 0xFD30, &val);\r\nif (val & 0x02) {\r\nsd_card->sd_erase_status = SD_NOT_ERASE;\r\nsd_card->sd_lock_notify = 1;\r\nchip->need_reinit |= SD_CARD;\r\n}\r\n}\r\n} else {\r\nsd_card->sd_erase_status = SD_NOT_ERASE;\r\n}\r\n}\r\n#endif\r\nrtsx_init_cards(chip);\r\nif (chip->ss_en) {\r\nss_allowed = 1;\r\nif (CHECK_PID(chip, 0x5288)) {\r\nss_allowed = 0;\r\n} else {\r\nif (CHK_SDIO_EXIST(chip) && !CHK_SDIO_IGNORED(chip)) {\r\nu32 val;\r\nrtsx_read_cfg_dw(chip, 1, 0x04, &val);\r\nif (val & 0x07) {\r\nss_allowed = 0;\r\n}\r\n}\r\n}\r\n} else {\r\nss_allowed = 0;\r\n}\r\nif (ss_allowed && !chip->sd_io) {\r\nif (rtsx_get_stat(chip) != RTSX_STAT_IDLE) {\r\nchip->ss_counter = 0;\r\n} else {\r\nif (chip->ss_counter <\r\n(chip->ss_idle_period / POLLING_INTERVAL)) {\r\nchip->ss_counter++;\r\n} else {\r\nrtsx_exclusive_enter_ss(chip);\r\nreturn;\r\n}\r\n}\r\n}\r\nif (CHECK_PID(chip, 0x5208)) {\r\nrtsx_monitor_aspm_config(chip);\r\n#ifdef SUPPORT_SDIO_ASPM\r\nif (CHK_SDIO_EXIST(chip) && !CHK_SDIO_IGNORED(chip) &&\r\nchip->aspm_l0s_l1_en && chip->dynamic_aspm) {\r\nif (chip->sd_io) {\r\ndynamic_configure_sdio_aspm(chip);\r\n} else {\r\nif (!chip->sdio_aspm) {\r\nRTSX_DEBUGP("SDIO enter ASPM!\n");\r\nrtsx_write_register(chip,\r\nASPM_FORCE_CTL, 0xFC,\r\n0x30 | (chip->aspm_level[1] << 2));\r\nchip->sdio_aspm = 1;\r\n}\r\n}\r\n}\r\n#endif\r\n}\r\nif (chip->idle_counter < IDLE_MAX_COUNT) {\r\nchip->idle_counter++;\r\n} else {\r\nif (rtsx_get_stat(chip) != RTSX_STAT_IDLE) {\r\nRTSX_DEBUGP("Idle state!\n");\r\nrtsx_set_stat(chip, RTSX_STAT_IDLE);\r\n#if !defined(LED_AUTO_BLINK) && defined(REGULAR_BLINK)\r\nchip->led_toggle_counter = 0;\r\n#endif\r\nrtsx_force_power_on(chip, SSC_PDCTL);\r\nturn_off_led(chip, LED_GPIO);\r\nif (chip->auto_power_down && !chip->card_ready && !chip->sd_io) {\r\nrtsx_force_power_down(chip, SSC_PDCTL | OC_PDCTL);\r\n}\r\n}\r\n}\r\nswitch (rtsx_get_stat(chip)) {\r\ncase RTSX_STAT_RUN:\r\n#if !defined(LED_AUTO_BLINK) && defined(REGULAR_BLINK)\r\nrtsx_blink_led(chip);\r\n#endif\r\ndo_remaining_work(chip);\r\nbreak;\r\ncase RTSX_STAT_IDLE:\r\nif (chip->sd_io && !chip->sd_int) {\r\ntry_to_switch_sdio_ctrl(chip);\r\n}\r\nrtsx_enable_aspm(chip);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n#ifdef SUPPORT_OCP\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\r\n#ifdef CONFIG_RTS_PSTOR_DEBUG\r\nif (chip->ocp_stat & (SD_OC_NOW | SD_OC_EVER | MS_OC_NOW | MS_OC_EVER)) {\r\nRTSX_DEBUGP("Over current, OCPSTAT is 0x%x\n", chip->ocp_stat);\r\n}\r\n#endif\r\nif (chip->ocp_stat & (SD_OC_NOW | SD_OC_EVER)) {\r\nif (chip->card_exist & SD_CARD) {\r\nrtsx_write_register(chip, CARD_OE, SD_OUTPUT_EN, 0);\r\ncard_power_off(chip, SD_CARD);\r\nchip->card_fail |= SD_CARD;\r\n}\r\n}\r\nif (chip->ocp_stat & (MS_OC_NOW | MS_OC_EVER)) {\r\nif (chip->card_exist & MS_CARD) {\r\nrtsx_write_register(chip, CARD_OE, MS_OUTPUT_EN, 0);\r\ncard_power_off(chip, MS_CARD);\r\nchip->card_fail |= MS_CARD;\r\n}\r\n}\r\n} else {\r\nif (chip->ocp_stat & (SD_OC_NOW | SD_OC_EVER)) {\r\nRTSX_DEBUGP("Over current, OCPSTAT is 0x%x\n", chip->ocp_stat);\r\nif (chip->card_exist & SD_CARD) {\r\nrtsx_write_register(chip, CARD_OE, SD_OUTPUT_EN, 0);\r\nchip->card_fail |= SD_CARD;\r\n} else if (chip->card_exist & MS_CARD) {\r\nrtsx_write_register(chip, CARD_OE, MS_OUTPUT_EN, 0);\r\nchip->card_fail |= MS_CARD;\r\n} else if (chip->card_exist & XD_CARD) {\r\nrtsx_write_register(chip, CARD_OE, XD_OUTPUT_EN, 0);\r\nchip->card_fail |= XD_CARD;\r\n}\r\ncard_power_off(chip, SD_CARD);\r\n}\r\n}\r\n#endif\r\nDelink_Stage:\r\nif (chip->auto_delink_en && chip->auto_delink_allowed &&\r\n!chip->card_ready && !chip->card_ejected && !chip->sd_io) {\r\nint enter_L1 = chip->auto_delink_in_L1 && (chip->aspm_l0s_l1_en || chip->ss_en);\r\nint delink_stage1_cnt = chip->delink_stage1_step;\r\nint delink_stage2_cnt = delink_stage1_cnt + chip->delink_stage2_step;\r\nint delink_stage3_cnt = delink_stage2_cnt + chip->delink_stage3_step;\r\nif (chip->auto_delink_cnt <= delink_stage3_cnt) {\r\nif (chip->auto_delink_cnt == delink_stage1_cnt) {\r\nrtsx_set_stat(chip, RTSX_STAT_DELINK);\r\nif (chip->asic_code && CHECK_PID(chip, 0x5208)) {\r\nrtsx_set_phy_reg_bit(chip, 0x1C, 2);\r\n}\r\nif (chip->card_exist) {\r\nRTSX_DEBUGP("False card inserted, do force delink\n");\r\nif (enter_L1) {\r\nrtsx_write_register(chip, HOST_SLEEP_STATE, 0x03, 1);\r\n}\r\nrtsx_write_register(chip, CHANGE_LINK_STATE, 0x0A, 0x0A);\r\nif (enter_L1) {\r\nrtsx_enter_L1(chip);\r\n}\r\nchip->auto_delink_cnt = delink_stage3_cnt + 1;\r\n} else {\r\nRTSX_DEBUGP("No card inserted, do delink\n");\r\nif (enter_L1) {\r\nrtsx_write_register(chip, HOST_SLEEP_STATE, 0x03, 1);\r\n}\r\n#ifdef HW_INT_WRITE_CLR\r\nif (CHECK_PID(chip, 0x5209)) {\r\nrtsx_writel(chip, RTSX_BIPR, 0xFFFFFFFF);\r\nRTSX_DEBUGP("RTSX_BIPR: 0x%x\n", rtsx_readl(chip, RTSX_BIPR));\r\n}\r\n#endif\r\nrtsx_write_register(chip, CHANGE_LINK_STATE, 0x02, 0x02);\r\nif (enter_L1) {\r\nrtsx_enter_L1(chip);\r\n}\r\n}\r\n}\r\nif (chip->auto_delink_cnt == delink_stage2_cnt) {\r\nRTSX_DEBUGP("Try to do force delink\n");\r\nif (enter_L1) {\r\nrtsx_exit_L1(chip);\r\n}\r\nif (chip->asic_code && CHECK_PID(chip, 0x5208)) {\r\nrtsx_set_phy_reg_bit(chip, 0x1C, 2);\r\n}\r\nrtsx_write_register(chip, CHANGE_LINK_STATE, 0x0A, 0x0A);\r\n}\r\nchip->auto_delink_cnt++;\r\n}\r\n} else {\r\nchip->auto_delink_cnt = 0;\r\n}\r\n}\r\nvoid rtsx_undo_delink(struct rtsx_chip *chip)\r\n{\r\nchip->auto_delink_allowed = 0;\r\nrtsx_write_register(chip, CHANGE_LINK_STATE, 0x0A, 0x00);\r\n}\r\nvoid rtsx_stop_cmd(struct rtsx_chip *chip, int card)\r\n{\r\nint i;\r\nfor (i = 0; i <= 8; i++) {\r\nint addr = RTSX_HCBAR + i * 4;\r\nu32 reg;\r\nreg = rtsx_readl(chip, addr);\r\nRTSX_DEBUGP("BAR (0x%02x): 0x%08x\n", addr, reg);\r\n}\r\nrtsx_writel(chip, RTSX_HCBCTLR, STOP_CMD);\r\nrtsx_writel(chip, RTSX_HDBCTLR, STOP_DMA);\r\nfor (i = 0; i < 16; i++) {\r\nu16 addr = 0xFE20 + (u16)i;\r\nu8 val;\r\nrtsx_read_register(chip, addr, &val);\r\nRTSX_DEBUGP("0x%04X: 0x%02x\n", addr, val);\r\n}\r\nrtsx_write_register(chip, DMACTL, 0x80, 0x80);\r\nrtsx_write_register(chip, RBCTL, 0x80, 0x80);\r\n}\r\nint rtsx_write_register(struct rtsx_chip *chip, u16 addr, u8 mask, u8 data)\r\n{\r\nint i;\r\nu32 val = 3 << 30;\r\nval |= (u32)(addr & 0x3FFF) << 16;\r\nval |= (u32)mask << 8;\r\nval |= (u32)data;\r\nrtsx_writel(chip, RTSX_HAIMR, val);\r\nfor (i = 0; i < MAX_RW_REG_CNT; i++) {\r\nval = rtsx_readl(chip, RTSX_HAIMR);\r\nif ((val & (1 << 31)) == 0) {\r\nif (data != (u8)val) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\n}\r\nTRACE_RET(chip, STATUS_TIMEDOUT);\r\n}\r\nint rtsx_read_register(struct rtsx_chip *chip, u16 addr, u8 *data)\r\n{\r\nu32 val = 2 << 30;\r\nint i;\r\nif (data) {\r\n*data = 0;\r\n}\r\nval |= (u32)(addr & 0x3FFF) << 16;\r\nrtsx_writel(chip, RTSX_HAIMR, val);\r\nfor (i = 0; i < MAX_RW_REG_CNT; i++) {\r\nval = rtsx_readl(chip, RTSX_HAIMR);\r\nif ((val & (1 << 31)) == 0) {\r\nbreak;\r\n}\r\n}\r\nif (i >= MAX_RW_REG_CNT) {\r\nTRACE_RET(chip, STATUS_TIMEDOUT);\r\n}\r\nif (data) {\r\n*data = (u8)(val & 0xFF);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_write_cfg_dw(struct rtsx_chip *chip, u8 func_no, u16 addr, u32 mask, u32 val)\r\n{\r\nu8 mode = 0, tmp;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nif (mask & 0xFF) {\r\nRTSX_WRITE_REG(chip, CFGDATA0 + i,\r\n0xFF, (u8)(val & mask & 0xFF));\r\nmode |= (1 << i);\r\n}\r\nmask >>= 8;\r\nval >>= 8;\r\n}\r\nif (mode) {\r\nRTSX_WRITE_REG(chip, CFGADDR0, 0xFF, (u8)addr);\r\nRTSX_WRITE_REG(chip, CFGADDR1, 0xFF, (u8)(addr >> 8));\r\nRTSX_WRITE_REG(chip, CFGRWCTL, 0xFF,\r\n0x80 | mode | ((func_no & 0x03) << 4));\r\nfor (i = 0; i < MAX_RW_REG_CNT; i++) {\r\nRTSX_READ_REG(chip, CFGRWCTL, &tmp);\r\nif ((tmp & 0x80) == 0) {\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_read_cfg_dw(struct rtsx_chip *chip, u8 func_no, u16 addr, u32 *val)\r\n{\r\nint i;\r\nu8 tmp;\r\nu32 data = 0;\r\nRTSX_WRITE_REG(chip, CFGADDR0, 0xFF, (u8)addr);\r\nRTSX_WRITE_REG(chip, CFGADDR1, 0xFF, (u8)(addr >> 8));\r\nRTSX_WRITE_REG(chip, CFGRWCTL, 0xFF, 0x80 | ((func_no & 0x03) << 4));\r\nfor (i = 0; i < MAX_RW_REG_CNT; i++) {\r\nRTSX_READ_REG(chip, CFGRWCTL, &tmp);\r\nif ((tmp & 0x80) == 0) {\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nRTSX_READ_REG(chip, CFGDATA0 + i, &tmp);\r\ndata |= (u32)tmp << (i * 8);\r\n}\r\nif (val) {\r\n*val = data;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_write_cfg_seq(struct rtsx_chip *chip, u8 func, u16 addr, u8 *buf, int len)\r\n{\r\nu32 *data, *mask;\r\nu16 offset = addr % 4;\r\nu16 aligned_addr = addr - offset;\r\nint dw_len, i, j;\r\nint retval;\r\nRTSX_DEBUGP("%s\n", __func__);\r\nif (!buf) {\r\nTRACE_RET(chip, STATUS_NOMEM);\r\n}\r\nif ((len + offset) % 4) {\r\ndw_len = (len + offset) / 4 + 1;\r\n} else {\r\ndw_len = (len + offset) / 4;\r\n}\r\nRTSX_DEBUGP("dw_len = %d\n", dw_len);\r\ndata = vzalloc(dw_len * 4);\r\nif (!data) {\r\nTRACE_RET(chip, STATUS_NOMEM);\r\n}\r\nmask = vzalloc(dw_len * 4);\r\nif (!mask) {\r\nvfree(data);\r\nTRACE_RET(chip, STATUS_NOMEM);\r\n}\r\nj = 0;\r\nfor (i = 0; i < len; i++) {\r\nmask[j] |= 0xFF << (offset * 8);\r\ndata[j] |= buf[i] << (offset * 8);\r\nif (++offset == 4) {\r\nj++;\r\noffset = 0;\r\n}\r\n}\r\nRTSX_DUMP(mask, dw_len * 4);\r\nRTSX_DUMP(data, dw_len * 4);\r\nfor (i = 0; i < dw_len; i++) {\r\nretval = rtsx_write_cfg_dw(chip, func, aligned_addr + i * 4, mask[i], data[i]);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(data);\r\nvfree(mask);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nvfree(data);\r\nvfree(mask);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_read_cfg_seq(struct rtsx_chip *chip, u8 func, u16 addr, u8 *buf, int len)\r\n{\r\nu32 *data;\r\nu16 offset = addr % 4;\r\nu16 aligned_addr = addr - offset;\r\nint dw_len, i, j;\r\nint retval;\r\nRTSX_DEBUGP("%s\n", __func__);\r\nif ((len + offset) % 4) {\r\ndw_len = (len + offset) / 4 + 1;\r\n} else {\r\ndw_len = (len + offset) / 4;\r\n}\r\nRTSX_DEBUGP("dw_len = %d\n", dw_len);\r\ndata = (u32 *)vmalloc(dw_len * 4);\r\nif (!data) {\r\nTRACE_RET(chip, STATUS_NOMEM);\r\n}\r\nfor (i = 0; i < dw_len; i++) {\r\nretval = rtsx_read_cfg_dw(chip, func, aligned_addr + i * 4, data + i);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(data);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nif (buf) {\r\nj = 0;\r\nfor (i = 0; i < len; i++) {\r\nbuf[i] = (u8)(data[j] >> (offset * 8));\r\nif (++offset == 4) {\r\nj++;\r\noffset = 0;\r\n}\r\n}\r\n}\r\nvfree(data);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_write_phy_register(struct rtsx_chip *chip, u8 addr, u16 val)\r\n{\r\nint i, finished = 0;\r\nu8 tmp;\r\nRTSX_WRITE_REG(chip, PHYDATA0, 0xFF, (u8)val);\r\nRTSX_WRITE_REG(chip, PHYDATA1, 0xFF, (u8)(val >> 8));\r\nRTSX_WRITE_REG(chip, PHYADDR, 0xFF, addr);\r\nRTSX_WRITE_REG(chip, PHYRWCTL, 0xFF, 0x81);\r\nfor (i = 0; i < 100000; i++) {\r\nRTSX_READ_REG(chip, PHYRWCTL, &tmp);\r\nif (!(tmp & 0x80)) {\r\nfinished = 1;\r\nbreak;\r\n}\r\n}\r\nif (!finished) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_read_phy_register(struct rtsx_chip *chip, u8 addr, u16 *val)\r\n{\r\nint i, finished = 0;\r\nu16 data = 0;\r\nu8 tmp;\r\nRTSX_WRITE_REG(chip, PHYADDR, 0xFF, addr);\r\nRTSX_WRITE_REG(chip, PHYRWCTL, 0xFF, 0x80);\r\nfor (i = 0; i < 100000; i++) {\r\nRTSX_READ_REG(chip, PHYRWCTL, &tmp);\r\nif (!(tmp & 0x80)) {\r\nfinished = 1;\r\nbreak;\r\n}\r\n}\r\nif (!finished) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nRTSX_READ_REG(chip, PHYDATA0, &tmp);\r\ndata = tmp;\r\nRTSX_READ_REG(chip, PHYDATA1, &tmp);\r\ndata |= (u16)tmp << 8;\r\nif (val)\r\n*val = data;\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_read_efuse(struct rtsx_chip *chip, u8 addr, u8 *val)\r\n{\r\nint i;\r\nu8 data = 0;\r\nRTSX_WRITE_REG(chip, EFUSE_CTRL, 0xFF, 0x80|addr);\r\nfor (i = 0; i < 100; i++) {\r\nRTSX_READ_REG(chip, EFUSE_CTRL, &data);\r\nif (!(data & 0x80))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (data & 0x80) {\r\nTRACE_RET(chip, STATUS_TIMEDOUT);\r\n}\r\nRTSX_READ_REG(chip, EFUSE_DATA, &data);\r\nif (val)\r\n*val = data;\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_write_efuse(struct rtsx_chip *chip, u8 addr, u8 val)\r\n{\r\nint i, j;\r\nu8 data = 0, tmp = 0xFF;\r\nfor (i = 0; i < 8; i++) {\r\nif (val & (u8)(1 << i))\r\ncontinue;\r\ntmp &= (~(u8)(1 << i));\r\nRTSX_DEBUGP("Write 0x%x to 0x%x\n", tmp, addr);\r\nRTSX_WRITE_REG(chip, EFUSE_DATA, 0xFF, tmp);\r\nRTSX_WRITE_REG(chip, EFUSE_CTRL, 0xFF, 0xA0|addr);\r\nfor (j = 0; j < 100; j++) {\r\nRTSX_READ_REG(chip, EFUSE_CTRL, &data);\r\nif (!(data & 0x80))\r\nbreak;\r\nwait_timeout(3);\r\n}\r\nif (data & 0x80) {\r\nTRACE_RET(chip, STATUS_TIMEDOUT);\r\n}\r\nwait_timeout(5);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_clr_phy_reg_bit(struct rtsx_chip *chip, u8 reg, u8 bit)\r\n{\r\nint retval;\r\nu16 value;\r\nretval = rtsx_read_phy_register(chip, reg, &value);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nif (value & (1 << bit)) {\r\nvalue &= ~(1 << bit);\r\nretval = rtsx_write_phy_register(chip, reg, value);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_set_phy_reg_bit(struct rtsx_chip *chip, u8 reg, u8 bit)\r\n{\r\nint retval;\r\nu16 value;\r\nretval = rtsx_read_phy_register(chip, reg, &value);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nif (0 == (value & (1 << bit))) {\r\nvalue |= (1 << bit);\r\nretval = rtsx_write_phy_register(chip, reg, value);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_check_link_ready(struct rtsx_chip *chip)\r\n{\r\nu8 val;\r\nRTSX_READ_REG(chip, IRQSTAT0, &val);\r\nRTSX_DEBUGP("IRQSTAT0: 0x%x\n", val);\r\nif (val & LINK_RDY_INT) {\r\nRTSX_DEBUGP("Delinked!\n");\r\nrtsx_write_register(chip, IRQSTAT0, LINK_RDY_INT, LINK_RDY_INT);\r\nreturn STATUS_FAIL;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic void rtsx_handle_pm_dstate(struct rtsx_chip *chip, u8 dstate)\r\n{\r\nu32 ultmp;\r\nRTSX_DEBUGP("%04x set pm_dstate to %d\n", chip->product_id, dstate);\r\nif (CHK_SDIO_EXIST(chip)) {\r\nu8 func_no;\r\nif (CHECK_PID(chip, 0x5288)) {\r\nfunc_no = 2;\r\n} else {\r\nfunc_no = 1;\r\n}\r\nrtsx_read_cfg_dw(chip, func_no, 0x84, &ultmp);\r\nRTSX_DEBUGP("pm_dstate of function %d: 0x%x\n", (int)func_no, ultmp);\r\nrtsx_write_cfg_dw(chip, func_no, 0x84, 0xFF, dstate);\r\n}\r\nrtsx_write_config_byte(chip, 0x44, dstate);\r\nrtsx_write_config_byte(chip, 0x45, 0);\r\n}\r\nvoid rtsx_enter_L1(struct rtsx_chip *chip)\r\n{\r\nrtsx_handle_pm_dstate(chip, 2);\r\n}\r\nvoid rtsx_exit_L1(struct rtsx_chip *chip)\r\n{\r\nrtsx_write_config_byte(chip, 0x44, 0);\r\nrtsx_write_config_byte(chip, 0x45, 0);\r\n}\r\nvoid rtsx_enter_ss(struct rtsx_chip *chip)\r\n{\r\nRTSX_DEBUGP("Enter Selective Suspend State!\n");\r\nrtsx_write_register(chip, IRQSTAT0, LINK_RDY_INT, LINK_RDY_INT);\r\nif (chip->power_down_in_ss) {\r\nrtsx_power_off_card(chip);\r\nrtsx_force_power_down(chip, SSC_PDCTL | OC_PDCTL);\r\n}\r\nif (CHK_SDIO_EXIST(chip)) {\r\nif (CHECK_PID(chip, 0x5288)) {\r\nrtsx_write_cfg_dw(chip, 2, 0xC0, 0xFF00, 0x0100);\r\n} else {\r\nrtsx_write_cfg_dw(chip, 1, 0xC0, 0xFF00, 0x0100);\r\n}\r\n}\r\nif (chip->auto_delink_en) {\r\nrtsx_write_register(chip, HOST_SLEEP_STATE, 0x01, 0x01);\r\n} else {\r\nif (!chip->phy_debug_mode) {\r\nu32 tmp;\r\ntmp = rtsx_readl(chip, RTSX_BIER);\r\ntmp |= CARD_INT;\r\nrtsx_writel(chip, RTSX_BIER, tmp);\r\n}\r\nrtsx_write_register(chip, CHANGE_LINK_STATE, 0x02, 0);\r\n}\r\nrtsx_enter_L1(chip);\r\nRTSX_CLR_DELINK(chip);\r\nrtsx_set_stat(chip, RTSX_STAT_SS);\r\n}\r\nvoid rtsx_exit_ss(struct rtsx_chip *chip)\r\n{\r\nRTSX_DEBUGP("Exit Selective Suspend State!\n");\r\nrtsx_exit_L1(chip);\r\nif (chip->power_down_in_ss) {\r\nrtsx_force_power_on(chip, SSC_PDCTL | OC_PDCTL);\r\nudelay(1000);\r\n}\r\nif (RTSX_TST_DELINK(chip)) {\r\nchip->need_reinit = SD_CARD | MS_CARD | XD_CARD;\r\nrtsx_reinit_cards(chip, 1);\r\nRTSX_CLR_DELINK(chip);\r\n} else if (chip->power_down_in_ss) {\r\nchip->need_reinit = SD_CARD | MS_CARD | XD_CARD;\r\nrtsx_reinit_cards(chip, 0);\r\n}\r\n}\r\nint rtsx_pre_handle_interrupt(struct rtsx_chip *chip)\r\n{\r\nu32 status, int_enable;\r\nint exit_ss = 0;\r\n#ifdef SUPPORT_OCP\r\nu32 ocp_int = 0;\r\nif (CHECK_PID(chip, 0x5209)) {\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\r\nocp_int = MS_OC_INT | SD_OC_INT;\r\n} else {\r\nocp_int = SD_OC_INT;\r\n}\r\n} else {\r\nocp_int = OC_INT;\r\n}\r\n#endif\r\nif (chip->ss_en) {\r\nchip->ss_counter = 0;\r\nif (rtsx_get_stat(chip) == RTSX_STAT_SS) {\r\nexit_ss = 1;\r\nrtsx_exit_L1(chip);\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\n}\r\n}\r\nint_enable = rtsx_readl(chip, RTSX_BIER);\r\nchip->int_reg = rtsx_readl(chip, RTSX_BIPR);\r\n#ifdef HW_INT_WRITE_CLR\r\nif (CHECK_PID(chip, 0x5209)) {\r\nrtsx_writel(chip, RTSX_BIPR, chip->int_reg);\r\n}\r\n#endif\r\nif (((chip->int_reg & int_enable) == 0) || (chip->int_reg == 0xFFFFFFFF))\r\nreturn STATUS_FAIL;\r\nif (!chip->msi_en) {\r\nif (CHECK_PID(chip, 0x5209)) {\r\nu8 val;\r\nrtsx_read_config_byte(chip, 0x05, &val);\r\nif (val & 0x04) {\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\n}\r\nstatus = chip->int_reg &= (int_enable | 0x7FFFFF);\r\nif (status & CARD_INT) {\r\nchip->auto_delink_cnt = 0;\r\nif (status & SD_INT) {\r\nif (status & SD_EXIST) {\r\nset_bit(SD_NR, &(chip->need_reset));\r\n} else {\r\nset_bit(SD_NR, &(chip->need_release));\r\nchip->sd_reset_counter = 0;\r\nchip->sd_show_cnt = 0;\r\nclear_bit(SD_NR, &(chip->need_reset));\r\n}\r\n} else {\r\nif (exit_ss && (status & SD_EXIST))\r\nset_bit(SD_NR, &(chip->need_reinit));\r\n}\r\nif (!CHECK_PID(chip, 0x5288) || CHECK_BARO_PKG(chip, QFN)) {\r\nif (status & XD_INT) {\r\nif (status & XD_EXIST) {\r\nset_bit(XD_NR, &(chip->need_reset));\r\n} else {\r\nset_bit(XD_NR, &(chip->need_release));\r\nchip->xd_reset_counter = 0;\r\nchip->xd_show_cnt = 0;\r\nclear_bit(XD_NR, &(chip->need_reset));\r\n}\r\n} else {\r\nif (exit_ss && (status & XD_EXIST))\r\nset_bit(XD_NR, &(chip->need_reinit));\r\n}\r\n}\r\nif (status & MS_INT) {\r\nif (status & MS_EXIST) {\r\nset_bit(MS_NR, &(chip->need_reset));\r\n} else {\r\nset_bit(MS_NR, &(chip->need_release));\r\nchip->ms_reset_counter = 0;\r\nchip->ms_show_cnt = 0;\r\nclear_bit(MS_NR, &(chip->need_reset));\r\n}\r\n} else {\r\nif (exit_ss && (status & MS_EXIST))\r\nset_bit(MS_NR, &(chip->need_reinit));\r\n}\r\n}\r\n#ifdef SUPPORT_OCP\r\nchip->ocp_int = ocp_int & status;\r\n#endif\r\nif (chip->sd_io) {\r\nif (chip->int_reg & DATA_DONE_INT)\r\nchip->int_reg &= ~(u32)DATA_DONE_INT;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nvoid rtsx_do_before_power_down(struct rtsx_chip *chip, int pm_stat)\r\n{\r\nint retval;\r\nRTSX_DEBUGP("rtsx_do_before_power_down, pm_stat = %d\n", pm_stat);\r\nrtsx_set_stat(chip, RTSX_STAT_SUSPEND);\r\nretval = rtsx_force_power_on(chip, SSC_PDCTL);\r\nif (retval != STATUS_SUCCESS)\r\nreturn;\r\nrtsx_release_cards(chip);\r\nrtsx_disable_bus_int(chip);\r\nturn_off_led(chip, LED_GPIO);\r\n#ifdef HW_AUTO_SWITCH_SD_BUS\r\nif (chip->sd_io) {\r\nchip->sdio_in_charge = 1;\r\nif (CHECK_PID(chip, 0x5208)) {\r\nrtsx_write_register(chip, TLPTISTAT, 0x08, 0x08);\r\nrtsx_write_register(chip, 0xFE70, 0x80, 0x80);\r\n} else if (CHECK_PID(chip, 0x5288)) {\r\nrtsx_write_register(chip, TLPTISTAT, 0x08, 0x08);\r\nrtsx_write_register(chip, 0xFE5A, 0x08, 0x08);\r\n} else if (CHECK_PID(chip, 0x5209)) {\r\nrtsx_write_register(chip, TLPTISTAT, 0x10, 0x10);\r\nrtsx_write_register(chip, SDIO_CFG, SDIO_BUS_AUTO_SWITCH, SDIO_BUS_AUTO_SWITCH);\r\n}\r\n}\r\n#endif\r\nif (CHECK_PID(chip, 0x5208) && (chip->ic_version >= IC_VER_D)) {\r\nrtsx_write_register(chip, PETXCFG, 0x08, 0x08);\r\n} else if (CHECK_PID(chip, 0x5209)) {\r\nrtsx_write_register(chip, PETXCFG, 0x08, 0x08);\r\n}\r\nif (pm_stat == PM_S1) {\r\nRTSX_DEBUGP("Host enter S1\n");\r\nrtsx_write_register(chip, HOST_SLEEP_STATE, 0x03, HOST_ENTER_S1);\r\n} else if (pm_stat == PM_S3) {\r\nif (chip->s3_pwr_off_delay > 0) {\r\nwait_timeout(chip->s3_pwr_off_delay);\r\n}\r\nRTSX_DEBUGP("Host enter S3\n");\r\nrtsx_write_register(chip, HOST_SLEEP_STATE, 0x03, HOST_ENTER_S3);\r\n}\r\nif (chip->do_delink_before_power_down && chip->auto_delink_en) {\r\nrtsx_write_register(chip, CHANGE_LINK_STATE, 0x02, 2);\r\n}\r\nrtsx_force_power_down(chip, SSC_PDCTL | OC_PDCTL);\r\nchip->cur_clk = 0;\r\nchip->cur_card = 0;\r\nchip->card_exist = 0;\r\n}\r\nvoid rtsx_enable_aspm(struct rtsx_chip *chip)\r\n{\r\nif (chip->aspm_l0s_l1_en && chip->dynamic_aspm) {\r\nif (!chip->aspm_enabled) {\r\nRTSX_DEBUGP("Try to enable ASPM\n");\r\nchip->aspm_enabled = 1;\r\nif (chip->asic_code && CHECK_PID(chip, 0x5208))\r\nrtsx_write_phy_register(chip, 0x07, 0);\r\nif (CHECK_PID(chip, 0x5208)) {\r\nrtsx_write_register(chip, ASPM_FORCE_CTL, 0xF3,\r\n0x30 | chip->aspm_level[0]);\r\n} else {\r\nrtsx_write_config_byte(chip, LCTLR, chip->aspm_l0s_l1_en);\r\n}\r\nif (CHK_SDIO_EXIST(chip)) {\r\nu16 val = chip->aspm_l0s_l1_en | 0x0100;\r\nif (CHECK_PID(chip, 0x5288)) {\r\nrtsx_write_cfg_dw(chip, 2, 0xC0, 0xFFFF, val);\r\n} else {\r\nrtsx_write_cfg_dw(chip, 1, 0xC0, 0xFFFF, val);\r\n}\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nvoid rtsx_disable_aspm(struct rtsx_chip *chip)\r\n{\r\nif (CHECK_PID(chip, 0x5208))\r\nrtsx_monitor_aspm_config(chip);\r\nif (chip->aspm_l0s_l1_en && chip->dynamic_aspm) {\r\nif (chip->aspm_enabled) {\r\nRTSX_DEBUGP("Try to disable ASPM\n");\r\nchip->aspm_enabled = 0;\r\nif (chip->asic_code && CHECK_PID(chip, 0x5208))\r\nrtsx_write_phy_register(chip, 0x07, 0x0129);\r\nif (CHECK_PID(chip, 0x5208)) {\r\nrtsx_write_register(chip, ASPM_FORCE_CTL, 0xF3, 0x30);\r\n} else {\r\nrtsx_write_config_byte(chip, LCTLR, 0x00);\r\n}\r\nwait_timeout(1);\r\n}\r\n}\r\nreturn;\r\n}\r\nint rtsx_read_ppbuf(struct rtsx_chip *chip, u8 *buf, int buf_len)\r\n{\r\nint retval;\r\nint i, j;\r\nu16 reg_addr;\r\nu8 *ptr;\r\nif (!buf) {\r\nTRACE_RET(chip, STATUS_ERROR);\r\n}\r\nptr = buf;\r\nreg_addr = PPBUF_BASE2;\r\nfor (i = 0; i < buf_len/256; i++) {\r\nrtsx_init_cmd(chip);\r\nfor (j = 0; j < 256; j++)\r\nrtsx_add_cmd(chip, READ_REG_CMD, reg_addr++, 0, 0);\r\nretval = rtsx_send_cmd(chip, 0, 250);\r\nif (retval < 0) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nmemcpy(ptr, rtsx_get_cmd_data(chip), 256);\r\nptr += 256;\r\n}\r\nif (buf_len%256) {\r\nrtsx_init_cmd(chip);\r\nfor (j = 0; j < buf_len%256; j++)\r\nrtsx_add_cmd(chip, READ_REG_CMD, reg_addr++, 0, 0);\r\nretval = rtsx_send_cmd(chip, 0, 250);\r\nif (retval < 0) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nmemcpy(ptr, rtsx_get_cmd_data(chip), buf_len%256);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_write_ppbuf(struct rtsx_chip *chip, u8 *buf, int buf_len)\r\n{\r\nint retval;\r\nint i, j;\r\nu16 reg_addr;\r\nu8 *ptr;\r\nif (!buf) {\r\nTRACE_RET(chip, STATUS_ERROR);\r\n}\r\nptr = buf;\r\nreg_addr = PPBUF_BASE2;\r\nfor (i = 0; i < buf_len/256; i++) {\r\nrtsx_init_cmd(chip);\r\nfor (j = 0; j < 256; j++) {\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, reg_addr++, 0xFF, *ptr);\r\nptr++;\r\n}\r\nretval = rtsx_send_cmd(chip, 0, 250);\r\nif (retval < 0) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nif (buf_len%256) {\r\nrtsx_init_cmd(chip);\r\nfor (j = 0; j < buf_len%256; j++) {\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, reg_addr++, 0xFF, *ptr);\r\nptr++;\r\n}\r\nretval = rtsx_send_cmd(chip, 0, 250);\r\nif (retval < 0) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_check_chip_exist(struct rtsx_chip *chip)\r\n{\r\nif (rtsx_readl(chip, 0) == 0xFFFFFFFF) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_force_power_on(struct rtsx_chip *chip, u8 ctl)\r\n{\r\nint retval;\r\nu8 mask = 0;\r\nif (ctl & SSC_PDCTL)\r\nmask |= SSC_POWER_DOWN;\r\n#ifdef SUPPORT_OCP\r\nif (ctl & OC_PDCTL) {\r\nmask |= SD_OC_POWER_DOWN;\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\r\nmask |= MS_OC_POWER_DOWN;\r\n}\r\n}\r\n#endif\r\nif (mask) {\r\nretval = rtsx_write_register(chip, FPDCTL, mask, 0);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nif (CHECK_PID(chip, 0x5288))\r\nwait_timeout(200);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_force_power_down(struct rtsx_chip *chip, u8 ctl)\r\n{\r\nint retval;\r\nu8 mask = 0, val = 0;\r\nif (ctl & SSC_PDCTL)\r\nmask |= SSC_POWER_DOWN;\r\n#ifdef SUPPORT_OCP\r\nif (ctl & OC_PDCTL) {\r\nmask |= SD_OC_POWER_DOWN;\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN))\r\nmask |= MS_OC_POWER_DOWN;\r\n}\r\n#endif\r\nif (mask) {\r\nval = mask;\r\nretval = rtsx_write_register(chip, FPDCTL, mask, val);\r\nif (retval != STATUS_SUCCESS) {\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}
