static int smctr_alloc_shared_memory(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_alloc_shared_memory\n", dev->name);\r\ntp->iscpb_ptr = (ISCPBlock *)(tp->ram_access + ((__u32)64 * 0x400)\r\n- (long)ISCP_BLOCK_SIZE);\r\ntp->scgb_ptr = (SCGBlock *)smctr_malloc(dev, sizeof(SCGBlock));\r\nPARAGRAPH_BOUNDRY(tp->sh_mem_used);\r\ntp->sclb_ptr = (SCLBlock *)smctr_malloc(dev, sizeof(SCLBlock));\r\nPARAGRAPH_BOUNDRY(tp->sh_mem_used);\r\ntp->acb_head = (ACBlock *)smctr_malloc(dev,\r\nsizeof(ACBlock)*tp->num_acbs);\r\nPARAGRAPH_BOUNDRY(tp->sh_mem_used);\r\ntp->isb_ptr = (ISBlock *)smctr_malloc(dev, sizeof(ISBlock));\r\nPARAGRAPH_BOUNDRY(tp->sh_mem_used);\r\ntp->misc_command_data = (__u16 *)smctr_malloc(dev, MISC_DATA_SIZE);\r\nPARAGRAPH_BOUNDRY(tp->sh_mem_used);\r\ntp->tx_fcb_head[MAC_QUEUE] = (FCBlock *)smctr_malloc(dev,\r\nsizeof(FCBlock) * tp->num_tx_fcbs[MAC_QUEUE]);\r\ntp->tx_fcb_head[NON_MAC_QUEUE] = (FCBlock *)smctr_malloc(dev,\r\nsizeof(FCBlock) * tp->num_tx_fcbs[NON_MAC_QUEUE]);\r\ntp->tx_fcb_head[BUG_QUEUE] = (FCBlock *)smctr_malloc(dev,\r\nsizeof(FCBlock) * tp->num_tx_fcbs[BUG_QUEUE]);\r\ntp->tx_bdb_head[MAC_QUEUE] = (BDBlock *)smctr_malloc(dev,\r\nsizeof(BDBlock) * tp->num_tx_bdbs[MAC_QUEUE]);\r\ntp->tx_bdb_head[NON_MAC_QUEUE] = (BDBlock *)smctr_malloc(dev,\r\nsizeof(BDBlock) * tp->num_tx_bdbs[NON_MAC_QUEUE]);\r\ntp->tx_bdb_head[BUG_QUEUE] = (BDBlock *)smctr_malloc(dev,\r\nsizeof(BDBlock) * tp->num_tx_bdbs[BUG_QUEUE]);\r\ntp->rx_fcb_head[MAC_QUEUE] = (FCBlock *)smctr_malloc(dev,\r\nsizeof(FCBlock) * tp->num_rx_fcbs[MAC_QUEUE]);\r\ntp->rx_fcb_head[NON_MAC_QUEUE] = (FCBlock *)smctr_malloc(dev,\r\nsizeof(FCBlock) * tp->num_rx_fcbs[NON_MAC_QUEUE]);\r\ntp->rx_bdb_head[MAC_QUEUE] = (BDBlock *)smctr_malloc(dev,\r\nsizeof(BDBlock) * tp->num_rx_bdbs[MAC_QUEUE]);\r\ntp->rx_bdb_end[MAC_QUEUE] = (BDBlock *)smctr_malloc(dev, 0);\r\ntp->rx_bdb_head[NON_MAC_QUEUE] = (BDBlock *)smctr_malloc(dev,\r\nsizeof(BDBlock) * tp->num_rx_bdbs[NON_MAC_QUEUE]);\r\ntp->rx_bdb_end[NON_MAC_QUEUE] = (BDBlock *)smctr_malloc(dev, 0);\r\ntp->tx_buff_head[MAC_QUEUE]\r\n= (__u16 *)smctr_malloc(dev, tp->tx_buff_size[MAC_QUEUE]);\r\ntp->tx_buff_curr[MAC_QUEUE] = tp->tx_buff_head[MAC_QUEUE];\r\ntp->tx_buff_end [MAC_QUEUE] = (__u16 *)smctr_malloc(dev, 0);\r\ntp->tx_buff_head[BUG_QUEUE]\r\n= (__u16 *)smctr_malloc(dev, tp->tx_buff_size[BUG_QUEUE]);\r\ntp->tx_buff_curr[BUG_QUEUE] = tp->tx_buff_head[BUG_QUEUE];\r\ntp->tx_buff_end[BUG_QUEUE] = (__u16 *)smctr_malloc(dev, 0);\r\ntp->rx_buff_head[MAC_QUEUE] = (__u16 *)smctr_malloc(dev,\r\nRX_DATA_BUFFER_SIZE * tp->num_rx_bdbs[MAC_QUEUE]);\r\ntp->rx_buff_end[MAC_QUEUE] = (__u16 *)smctr_malloc(dev, 0);\r\nsmctr_malloc(dev, 1L);\r\ntp->tx_buff_head[NON_MAC_QUEUE]\r\n= (__u16 *)smctr_malloc(dev, tp->tx_buff_size[NON_MAC_QUEUE]);\r\ntp->tx_buff_curr[NON_MAC_QUEUE] = tp->tx_buff_head[NON_MAC_QUEUE];\r\ntp->tx_buff_end [NON_MAC_QUEUE] = (__u16 *)smctr_malloc(dev, 0);\r\nsmctr_malloc(dev, 1L);\r\nsmctr_malloc(dev, TO_256_BYTE_BOUNDRY(tp->sh_mem_used));\r\ntp->rx_buff_head[NON_MAC_QUEUE] = (__u16 *)smctr_malloc(dev,\r\nRX_DATA_BUFFER_SIZE * tp->num_rx_bdbs[NON_MAC_QUEUE]);\r\ntp->rx_buff_end[NON_MAC_QUEUE] = (__u16 *)smctr_malloc(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int smctr_bypass_state(struct net_device *dev)\r\n{\r\nint err;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_bypass_state\n", dev->name);\r\nerr = smctr_setup_single_cmd(dev, ACB_CMD_CHANGE_JOIN_STATE, JS_BYPASS_STATE);\r\nreturn err;\r\n}\r\nstatic int smctr_checksum_firmware(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\n__u16 i, checksum = 0;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_checksum_firmware\n", dev->name);\r\nsmctr_enable_adapter_ctrl_store(dev);\r\nfor(i = 0; i < CS_RAM_SIZE; i += 2)\r\nchecksum += *((__u16 *)(tp->ram_access + i));\r\ntp->microcode_version = *(__u16 *)(tp->ram_access\r\n+ CS_RAM_VERSION_OFFSET);\r\ntp->microcode_version >>= 8;\r\nsmctr_disable_adapter_ctrl_store(dev);\r\nif(checksum)\r\nreturn checksum;\r\nreturn 0;\r\n}\r\nstatic int __init smctr_chk_mca(struct net_device *dev)\r\n{\r\n#ifdef CONFIG_MCA_LEGACY\r\nstruct net_local *tp = netdev_priv(dev);\r\nint current_slot;\r\n__u8 r1, r2, r3, r4, r5;\r\ncurrent_slot = mca_find_unused_adapter(smctr_posid, 0);\r\nif(current_slot == MCA_NOTFOUND)\r\nreturn -ENODEV;\r\nmca_set_adapter_name(current_slot, smctr_name);\r\nmca_mark_as_used(current_slot);\r\ntp->slot_num = current_slot;\r\nr1 = mca_read_stored_pos(tp->slot_num, 2);\r\nr2 = mca_read_stored_pos(tp->slot_num, 3);\r\nif(tp->slot_num)\r\noutb(CNFG_POS_CONTROL_REG, (__u8)((tp->slot_num - 1) | CNFG_SLOT_ENABLE_BIT));\r\nelse\r\noutb(CNFG_POS_CONTROL_REG, (__u8)((tp->slot_num) | CNFG_SLOT_ENABLE_BIT));\r\nr1 = inb(CNFG_POS_REG1);\r\nr2 = inb(CNFG_POS_REG0);\r\ntp->bic_type = BIC_594_CHIP;\r\nr2 = mca_read_stored_pos(tp->slot_num, 2);\r\nr2 &= 0xF0;\r\ndev->base_addr = ((__u16)r2 << 8) + (__u16)0x800;\r\nrequest_region(dev->base_addr, SMCTR_IO_EXTENT, smctr_name);\r\nr5 = mca_read_stored_pos(tp->slot_num, 5);\r\nr5 &= 0xC;\r\nswitch(r5)\r\n{\r\ncase 0:\r\ndev->irq = 3;\r\nbreak;\r\ncase 0x4:\r\ndev->irq = 4;\r\nbreak;\r\ncase 0x8:\r\ndev->irq = 10;\r\nbreak;\r\ndefault:\r\ndev->irq = 15;\r\nbreak;\r\n}\r\nif (request_irq(dev->irq, smctr_interrupt, IRQF_SHARED, smctr_name, dev)) {\r\nrelease_region(dev->base_addr, SMCTR_IO_EXTENT);\r\nreturn -ENODEV;\r\n}\r\nr3 = mca_read_stored_pos(tp->slot_num, 3);\r\ntp->ram_base = ((__u32)(r3 & 0x7) << 13) + 0x0C0000;\r\nif (r3 & 0x8)\r\ntp->ram_base += 0x010000;\r\nif (r3 & 0x80)\r\ntp->ram_base += 0xF00000;\r\nr3 &= 0x30;\r\nr3 >>= 4;\r\ntp->ram_usable = (__u16)CNFG_SIZE_8KB << r3;\r\ntp->ram_size = (__u16)CNFG_SIZE_64KB;\r\ntp->board_id |= TOKEN_MEDIA;\r\nr4 = mca_read_stored_pos(tp->slot_num, 4);\r\ntp->rom_base = ((__u32)(r4 & 0x7) << 13) + 0x0C0000;\r\nif (r4 & 0x8)\r\ntp->rom_base += 0x010000;\r\nr4 >>= 4;\r\nswitch (r4) {\r\ncase 0:\r\ntp->rom_size = CNFG_SIZE_8KB;\r\nbreak;\r\ncase 1:\r\ntp->rom_size = CNFG_SIZE_16KB;\r\nbreak;\r\ncase 2:\r\ntp->rom_size = CNFG_SIZE_32KB;\r\nbreak;\r\ndefault:\r\ntp->rom_size = ROM_DISABLE;\r\n}\r\nr5 = mca_read_stored_pos(tp->slot_num, 5);\r\nr5 &= CNFG_MEDIA_TYPE_MASK;\r\nswitch(r5)\r\n{\r\ncase (0):\r\ntp->media_type = MEDIA_STP_4;\r\nbreak;\r\ncase (1):\r\ntp->media_type = MEDIA_STP_16;\r\nbreak;\r\ncase (3):\r\ntp->media_type = MEDIA_UTP_16;\r\nbreak;\r\ndefault:\r\ntp->media_type = MEDIA_UTP_4;\r\nbreak;\r\n}\r\ntp->media_menu = 14;\r\nr2 = mca_read_stored_pos(tp->slot_num, 2);\r\nif(!(r2 & 0x02))\r\ntp->mode_bits |= EARLY_TOKEN_REL;\r\noutb(CNFG_POS_CONTROL_REG, 0);\r\ntp->board_id = smctr_get_boardid(dev, 1);\r\nswitch(tp->board_id & 0xffff)\r\n{\r\ncase WD8115TA:\r\nsmctr_model = "8115T/A";\r\nbreak;\r\ncase WD8115T:\r\nif(tp->extra_info & CHIP_REV_MASK)\r\nsmctr_model = "8115T rev XE";\r\nelse\r\nsmctr_model = "8115T rev XD";\r\nbreak;\r\ndefault:\r\nsmctr_model = "Unknown";\r\nbreak;\r\n}\r\nreturn 0;\r\n#else\r\nreturn -1;\r\n#endif\r\n}\r\nstatic int smctr_chg_rx_mask(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint err = 0;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_chg_rx_mask\n", dev->name);\r\nsmctr_enable_16bit(dev);\r\nsmctr_set_page(dev, (__u8 *)tp->ram_access);\r\nif(tp->mode_bits & LOOPING_MODE_MASK)\r\ntp->config_word0 |= RX_OWN_BIT;\r\nelse\r\ntp->config_word0 &= ~RX_OWN_BIT;\r\nif(tp->receive_mask & PROMISCUOUS_MODE)\r\ntp->config_word0 |= PROMISCUOUS_BIT;\r\nelse\r\ntp->config_word0 &= ~PROMISCUOUS_BIT;\r\nif(tp->receive_mask & ACCEPT_ERR_PACKETS)\r\ntp->config_word0 |= SAVBAD_BIT;\r\nelse\r\ntp->config_word0 &= ~SAVBAD_BIT;\r\nif(tp->receive_mask & ACCEPT_ATT_MAC_FRAMES)\r\ntp->config_word0 |= RXATMAC;\r\nelse\r\ntp->config_word0 &= ~RXATMAC;\r\nif(tp->receive_mask & ACCEPT_MULTI_PROM)\r\ntp->config_word1 |= MULTICAST_ADDRESS_BIT;\r\nelse\r\ntp->config_word1 &= ~MULTICAST_ADDRESS_BIT;\r\nif(tp->receive_mask & ACCEPT_SOURCE_ROUTING_SPANNING)\r\ntp->config_word1 |= SOURCE_ROUTING_SPANNING_BITS;\r\nelse\r\n{\r\nif(tp->receive_mask & ACCEPT_SOURCE_ROUTING)\r\ntp->config_word1 |= SOURCE_ROUTING_EXPLORER_BIT;\r\nelse\r\ntp->config_word1 &= ~SOURCE_ROUTING_SPANNING_BITS;\r\n}\r\nif((err = smctr_issue_write_word_cmd(dev, RW_CONFIG_REGISTER_0,\r\n&tp->config_word0)))\r\n{\r\nreturn err;\r\n}\r\nif((err = smctr_issue_write_word_cmd(dev, RW_CONFIG_REGISTER_1,\r\n&tp->config_word1)))\r\n{\r\nreturn err;\r\n}\r\nsmctr_disable_16bit(dev);\r\nreturn 0;\r\n}\r\nstatic int smctr_clear_int(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\noutb((tp->trc_mask | CSR_CLRTINT), dev->base_addr + CSR);\r\nreturn 0;\r\n}\r\nstatic int smctr_clear_trc_reset(int ioaddr)\r\n{\r\n__u8 r;\r\nr = inb(ioaddr + MSR);\r\noutb(~MSR_RST & r, ioaddr + MSR);\r\nreturn 0;\r\n}\r\nstatic int smctr_close(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nint err;\r\nnetif_stop_queue(dev);\r\ntp->cleanup = 1;\r\nif(tp->status != OPEN)\r\nreturn 0;\r\nsmctr_enable_16bit(dev);\r\nsmctr_set_page(dev, (__u8 *)tp->ram_access);\r\nif((err = smctr_issue_remove_cmd(dev)))\r\n{\r\nsmctr_disable_16bit(dev);\r\nreturn err;\r\n}\r\nfor(;;)\r\n{\r\nskb = skb_dequeue(&tp->SendSkbQueue);\r\nif(skb == NULL)\r\nbreak;\r\ntp->QueueSkb++;\r\ndev_kfree_skb(skb);\r\n}\r\nreturn 0;\r\n}\r\nstatic int smctr_decode_firmware(struct net_device *dev,\r\nconst struct firmware *fw)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nshort bit = 0x80, shift = 12;\r\nDECODE_TREE_NODE *tree;\r\nshort branch, tsize;\r\n__u16 buff = 0;\r\nlong weight;\r\n__u8 *ucode;\r\n__u16 *mem;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_decode_firmware\n", dev->name);\r\nweight = *(long *)(fw->data + WEIGHT_OFFSET);\r\ntsize = *(__u8 *)(fw->data + TREE_SIZE_OFFSET);\r\ntree = (DECODE_TREE_NODE *)(fw->data + TREE_OFFSET);\r\nucode = (__u8 *)(fw->data + TREE_OFFSET\r\n+ (tsize * sizeof(DECODE_TREE_NODE)));\r\nmem = (__u16 *)(tp->ram_access);\r\nwhile(weight)\r\n{\r\nbranch = ROOT;\r\nwhile((tree + branch)->tag != LEAF && weight)\r\n{\r\nbranch = *ucode & bit ? (tree + branch)->llink\r\n: (tree + branch)->rlink;\r\nbit >>= 1;\r\nweight--;\r\nif(bit == 0)\r\n{\r\nbit = 0x80;\r\nucode++;\r\n}\r\n}\r\nbuff |= (tree + branch)->info << shift;\r\nshift -= 4;\r\nif(shift < 0)\r\n{\r\n*(mem++) = SWAP_BYTES(buff);\r\nbuff = 0;\r\nshift = 12;\r\n}\r\n}\r\nif(buff)\r\n*(mem++) = SWAP_BYTES(buff);\r\nreturn 0;\r\n}\r\nstatic int smctr_disable_16bit(struct net_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int smctr_disable_adapter_ctrl_store(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_disable_adapter_ctrl_store\n", dev->name);\r\ntp->trc_mask |= CSR_WCSS;\r\noutb(tp->trc_mask, ioaddr + CSR);\r\nreturn 0;\r\n}\r\nstatic int smctr_disable_bic_int(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\ntp->trc_mask = CSR_MSK_ALL | CSR_MSKCBUSY\r\n| CSR_MSKTINT | CSR_WCSS;\r\noutb(tp->trc_mask, ioaddr + CSR);\r\nreturn 0;\r\n}\r\nstatic int smctr_enable_16bit(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\n__u8 r;\r\nif(tp->adapter_bus == BUS_ISA16_TYPE)\r\n{\r\nr = inb(dev->base_addr + LAAR);\r\noutb((r | LAAR_MEM16ENB), dev->base_addr + LAAR);\r\n}\r\nreturn 0;\r\n}\r\nstatic int smctr_enable_adapter_ctrl_store(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_enable_adapter_ctrl_store\n", dev->name);\r\nsmctr_set_trc_reset(ioaddr);\r\nsmctr_enable_adapter_ram(dev);\r\ntp->trc_mask &= ~CSR_WCSS;\r\noutb(tp->trc_mask, ioaddr + CSR);\r\nreturn 0;\r\n}\r\nstatic int smctr_enable_adapter_ram(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\n__u8 r;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_enable_adapter_ram\n", dev->name);\r\nr = inb(ioaddr + MSR);\r\noutb(MSR_MEMB | r, ioaddr + MSR);\r\nreturn 0;\r\n}\r\nstatic int smctr_enable_bic_int(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\n__u8 r;\r\nswitch(tp->bic_type)\r\n{\r\ncase (BIC_584_CHIP):\r\ntp->trc_mask = CSR_MSKCBUSY | CSR_WCSS;\r\noutb(tp->trc_mask, ioaddr + CSR);\r\nr = inb(ioaddr + IRR);\r\noutb(r | IRR_IEN, ioaddr + IRR);\r\nbreak;\r\ncase (BIC_594_CHIP):\r\ntp->trc_mask = CSR_MSKCBUSY | CSR_WCSS;\r\noutb(tp->trc_mask, ioaddr + CSR);\r\nr = inb(ioaddr + IMCCR);\r\noutb(r | IMCCR_EIL, ioaddr + IMCCR);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init smctr_chk_isa(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\n__u8 r1, r2, b, chksum = 0;\r\n__u16 r;\r\nint i;\r\nint err = -ENODEV;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_chk_isa %#4x\n", dev->name, ioaddr);\r\nif((ioaddr & 0x1F) != 0)\r\ngoto out;\r\nif (!request_region(ioaddr, SMCTR_IO_EXTENT, smctr_name)) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nfor(i = 0; i < 8; i++)\r\n{\r\nb = inb(ioaddr + LAR0 + i);\r\nchksum += b;\r\n}\r\nif (chksum != NODE_ADDR_CKSUM)\r\ngoto out2;\r\nb = inb(ioaddr + BDID);\r\nif(b != BRD_ID_8115T)\r\n{\r\nprintk(KERN_ERR "%s: The adapter found is not supported\n", dev->name);\r\ngoto out2;\r\n}\r\nr2 = 0;\r\nfor(r = 0; r < 8; r++)\r\n{\r\nr1 = inb(ioaddr + 0x8 + r);\r\nr2 += r1;\r\n}\r\nif((r2 != 0xFF) && (r2 != 0xEE))\r\ngoto out2;\r\ntp->board_id = smctr_get_boardid(dev, 0);\r\nswitch(tp->board_id & 0xffff)\r\n{\r\ncase WD8115TA:\r\nsmctr_model = "8115T/A";\r\nbreak;\r\ncase WD8115T:\r\nif(tp->extra_info & CHIP_REV_MASK)\r\nsmctr_model = "8115T rev XE";\r\nelse\r\nsmctr_model = "8115T rev XD";\r\nbreak;\r\ndefault:\r\nsmctr_model = "Unknown";\r\nbreak;\r\n}\r\ntp->bic_type = BIC_584_CHIP;\r\ntp->nic_type = NIC_825_CHIP;\r\ntp->ram_usable = CNFG_SIZE_16KB;\r\ntp->ram_size = CNFG_SIZE_64KB;\r\nr1 = inb(ioaddr);\r\nr1 &= 0x3F;\r\nr2 = inb(ioaddr + CNFG_LAAR_584);\r\nr2 &= CNFG_LAAR_MASK;\r\nr2 <<= 3;\r\nr2 |= ((r1 & 0x38) >> 3);\r\ntp->ram_base = ((__u32)r2 << 16) + (((__u32)(r1 & 0x7)) << 13);\r\nr1 = 0;\r\nr1 = inb(ioaddr + CNFG_ICR_583);\r\nr1 &= CNFG_ICR_IR2_584;\r\nr2 = inb(ioaddr + CNFG_IRR_583);\r\nr2 &= CNFG_IRR_IRQS;\r\nr2 >>= 5;\r\nswitch(r2)\r\n{\r\ncase 0:\r\nif(r1 == 0)\r\ndev->irq = 2;\r\nelse\r\ndev->irq = 10;\r\nbreak;\r\ncase 1:\r\nif(r1 == 0)\r\ndev->irq = 3;\r\nelse\r\ndev->irq = 11;\r\nbreak;\r\ncase 2:\r\nif(r1 == 0)\r\n{\r\nif(tp->extra_info & ALTERNATE_IRQ_BIT)\r\ndev->irq = 5;\r\nelse\r\ndev->irq = 4;\r\n}\r\nelse\r\ndev->irq = 15;\r\nbreak;\r\ncase 3:\r\nif(r1 == 0)\r\ndev->irq = 7;\r\nelse\r\ndev->irq = 4;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: No IRQ found aborting\n", dev->name);\r\ngoto out2;\r\n}\r\nif (request_irq(dev->irq, smctr_interrupt, IRQF_SHARED, smctr_name, dev))\r\ngoto out2;\r\nr1 = inb(ioaddr + CNFG_BIO_583);\r\nr1 &= 0x3E;\r\nr1 |= 0x40;\r\ntp->rom_base = (__u32)r1 << 13;\r\nr1 = inb(ioaddr + CNFG_BIO_583);\r\nr1 &= 0xC0;\r\nif(r1 == 0)\r\ntp->rom_size = ROM_DISABLE;\r\nelse\r\n{\r\nr1 >>= 6;\r\ntp->rom_size = (__u16)CNFG_SIZE_8KB << r1;\r\n}\r\nr1 = inb(ioaddr + CNFG_GP2);\r\ntp->mode_bits &= (~BOOT_STATUS_MASK);\r\nif(r1 & CNFG_GP2_BOOT_NIBBLE)\r\ntp->mode_bits |= BOOT_TYPE_1;\r\ntp->mode_bits &= (~ZERO_WAIT_STATE_MASK);\r\nr1 = inb(ioaddr + CNFG_IRR_583);\r\nif(r1 & CNFG_IRR_ZWS)\r\ntp->mode_bits |= ZERO_WAIT_STATE_8_BIT;\r\nif(tp->board_id & BOARD_16BIT)\r\n{\r\nr1 = inb(ioaddr + CNFG_LAAR_584);\r\nif(r1 & CNFG_LAAR_ZWS)\r\ntp->mode_bits |= ZERO_WAIT_STATE_16_BIT;\r\n}\r\ntp->media_menu = 14;\r\nr1 = inb(ioaddr + CNFG_IRR_583);\r\ntp->mode_bits &= 0xf8ff;\r\nif((tp->board_id & TOKEN_MEDIA) == TOKEN_MEDIA)\r\n{\r\nif(((r1 & 0x6) >> 1) == 0x3)\r\ntp->media_type |= MEDIA_UTP_16;\r\nelse\r\n{\r\nif(((r1 & 0x6) >> 1) == 0x2)\r\ntp->media_type |= MEDIA_STP_16;\r\nelse\r\n{\r\nif(((r1 & 0x6) >> 1) == 0x1)\r\ntp->media_type |= MEDIA_UTP_4;\r\nelse\r\ntp->media_type |= MEDIA_STP_4;\r\n}\r\n}\r\nr1 = inb(ioaddr + CNFG_GP2);\r\nif(!(r1 & 0x2) )\r\ntp->mode_bits |= EARLY_TOKEN_REL;\r\n}\r\nreturn 0;\r\nout2:\r\nrelease_region(ioaddr, SMCTR_IO_EXTENT);\r\nout:\r\nreturn err;\r\n}\r\nstatic int __init smctr_get_boardid(struct net_device *dev, int mca)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\n__u8 r, r1, IdByte;\r\n__u16 BoardIdMask;\r\ntp->board_id = BoardIdMask = 0;\r\nif(mca)\r\n{\r\nBoardIdMask |= (MICROCHANNEL+INTERFACE_CHIP+TOKEN_MEDIA+PAGED_RAM+BOARD_16BIT);\r\ntp->extra_info |= (INTERFACE_594_CHIP+RAM_SIZE_64K+NIC_825_BIT+ALTERNATE_IRQ_BIT+SLOT_16BIT);\r\n}\r\nelse\r\n{\r\nBoardIdMask|=(INTERFACE_CHIP+TOKEN_MEDIA+PAGED_RAM+BOARD_16BIT);\r\ntp->extra_info |= (INTERFACE_584_CHIP + RAM_SIZE_64K\r\n+ NIC_825_BIT + ALTERNATE_IRQ_BIT);\r\n}\r\nif(!mca)\r\n{\r\nr = inb(ioaddr + BID_REG_1);\r\nr &= 0x0c;\r\noutb(r, ioaddr + BID_REG_1);\r\nr = inb(ioaddr + BID_REG_1);\r\nif(r & BID_SIXTEEN_BIT_BIT)\r\n{\r\ntp->extra_info |= SLOT_16BIT;\r\ntp->adapter_bus = BUS_ISA16_TYPE;\r\n}\r\nelse\r\ntp->adapter_bus = BUS_ISA8_TYPE;\r\n}\r\nelse\r\ntp->adapter_bus = BUS_MCA_TYPE;\r\nIdByte = inb(ioaddr + BID_BOARD_ID_BYTE);\r\nif(IdByte & 0xF8)\r\nreturn -1;\r\nr1 = inb(ioaddr + BID_REG_1);\r\nr1 &= BID_ICR_MASK;\r\nr1 |= BID_OTHER_BIT;\r\noutb(r1, ioaddr + BID_REG_1);\r\nr1 = inb(ioaddr + BID_REG_3);\r\nr1 &= BID_EAR_MASK;\r\nr1 |= BID_ENGR_PAGE;\r\noutb(r1, ioaddr + BID_REG_3);\r\nr1 = inb(ioaddr + BID_REG_1);\r\nr1 &= BID_ICR_MASK;\r\nr1 |= (BID_RLA | BID_OTHER_BIT);\r\noutb(r1, ioaddr + BID_REG_1);\r\nr1 = inb(ioaddr + BID_REG_1);\r\nwhile(r1 & BID_RECALL_DONE_MASK)\r\nr1 = inb(ioaddr + BID_REG_1);\r\nr = inb(ioaddr + BID_LAR_0 + BID_REG_6);\r\ntp->extra_info &= ~CHIP_REV_MASK;\r\ntp->extra_info |= ((r & BID_EEPROM_CHIP_REV_MASK) << 6);\r\nr1 = inb(ioaddr + BID_REG_1);\r\nr1 &= BID_ICR_MASK;\r\nr1 |= BID_OTHER_BIT;\r\noutb(r1, ioaddr + BID_REG_1);\r\nr1 = inb(ioaddr + BID_REG_3);\r\nr1 &= BID_EAR_MASK;\r\nr1 |= BID_EA6;\r\noutb(r1, ioaddr + BID_REG_3);\r\nr1 = inb(ioaddr + BID_REG_1);\r\nr1 &= BID_ICR_MASK;\r\nr1 |= BID_RLA;\r\noutb(r1, ioaddr + BID_REG_1);\r\nr1 = inb(ioaddr + BID_REG_1);\r\nwhile(r1 & BID_RECALL_DONE_MASK)\r\nr1 = inb(ioaddr + BID_REG_1);\r\nreturn BoardIdMask;\r\n}\r\nstatic int smctr_get_group_address(struct net_device *dev)\r\n{\r\nsmctr_issue_read_word_cmd(dev, RW_INDIVIDUAL_GROUP_ADDR);\r\nreturn smctr_wait_cmd(dev);\r\n}\r\nstatic int smctr_get_functional_address(struct net_device *dev)\r\n{\r\nsmctr_issue_read_word_cmd(dev, RW_FUNCTIONAL_ADDR);\r\nreturn smctr_wait_cmd(dev);\r\n}\r\nstatic unsigned int smctr_get_num_rx_bdbs(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int mem_used = 0;\r\nmem_used += sizeof(SCGBlock);\r\nmem_used += TO_PARAGRAPH_BOUNDRY(mem_used);\r\nmem_used += sizeof(SCLBlock);\r\nmem_used += TO_PARAGRAPH_BOUNDRY(mem_used);\r\nmem_used += sizeof(ACBlock) * tp->num_acbs;\r\nmem_used += TO_PARAGRAPH_BOUNDRY(mem_used);\r\nmem_used += sizeof(ISBlock);\r\nmem_used += TO_PARAGRAPH_BOUNDRY(mem_used);\r\nmem_used += MISC_DATA_SIZE;\r\nmem_used += TO_PARAGRAPH_BOUNDRY(mem_used);\r\nmem_used += sizeof(FCBlock) * tp->num_tx_fcbs[MAC_QUEUE];\r\nmem_used += sizeof(FCBlock) * tp->num_tx_fcbs[NON_MAC_QUEUE];\r\nmem_used += sizeof(FCBlock) * tp->num_tx_fcbs[BUG_QUEUE];\r\nmem_used += sizeof(BDBlock) * tp->num_tx_bdbs[MAC_QUEUE];\r\nmem_used += sizeof(BDBlock) * tp->num_tx_bdbs[NON_MAC_QUEUE];\r\nmem_used += sizeof(BDBlock) * tp->num_tx_bdbs[BUG_QUEUE];\r\nmem_used += sizeof(FCBlock) * tp->num_rx_fcbs[MAC_QUEUE];\r\nmem_used += sizeof(FCBlock) * tp->num_rx_fcbs[NON_MAC_QUEUE];\r\nmem_used += sizeof(BDBlock) * tp->num_rx_bdbs[MAC_QUEUE];\r\nmem_used += tp->tx_buff_size[MAC_QUEUE];\r\nmem_used += tp->tx_buff_size[BUG_QUEUE];\r\nmem_used += RX_DATA_BUFFER_SIZE * tp->num_rx_bdbs[MAC_QUEUE];\r\nmem_used += 1L;\r\nmem_used += tp->tx_buff_size[NON_MAC_QUEUE];\r\nmem_used += 1L;\r\nmem_used += 0x100;\r\nreturn (0xffff - mem_used) / (RX_DATA_BUFFER_SIZE + sizeof(BDBlock));\r\n}\r\nstatic int smctr_get_physical_drop_number(struct net_device *dev)\r\n{\r\nsmctr_issue_read_word_cmd(dev, RW_PHYSICAL_DROP_NUMBER);\r\nreturn smctr_wait_cmd(dev);\r\n}\r\nstatic __u8 * smctr_get_rx_pointer(struct net_device *dev, short queue)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nBDBlock *bdb;\r\nbdb = (BDBlock *)((__u32)tp->ram_access\r\n+ (__u32)(tp->rx_fcb_curr[queue]->trc_bdb_ptr));\r\ntp->rx_fcb_curr[queue]->bdb_ptr = bdb;\r\nreturn (__u8 *)bdb->data_block_ptr;\r\n}\r\nstatic int smctr_get_station_id(struct net_device *dev)\r\n{\r\nsmctr_issue_read_word_cmd(dev, RW_INDIVIDUAL_MAC_ADDRESS);\r\nreturn smctr_wait_cmd(dev);\r\n}\r\nstatic struct net_device_stats *smctr_get_stats(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nreturn (struct net_device_stats *)&tp->MacStat;\r\n}\r\nstatic FCBlock *smctr_get_tx_fcb(struct net_device *dev, __u16 queue,\r\n__u16 bytes_count)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nFCBlock *pFCB;\r\nBDBlock *pbdb;\r\nunsigned short alloc_size;\r\nunsigned short *temp;\r\nif(smctr_debug > 20)\r\nprintk(KERN_DEBUG "smctr_get_tx_fcb\n");\r\nif(tp->num_tx_fcbs_used[queue] >= tp->num_tx_fcbs[queue])\r\nreturn (FCBlock *)(-1L);\r\nalloc_size = (bytes_count + 1) & 0xfffe;\r\nif((tp->tx_buff_used[queue] + alloc_size) > tp->tx_buff_size[queue])\r\nreturn (FCBlock *)(-1L);\r\nif(((unsigned long)(tp->tx_buff_curr[queue]) + alloc_size)\r\n>= (unsigned long)(tp->tx_buff_end[queue]))\r\n{\r\nalloc_size = alloc_size +\r\n(__u16)((__u32)tp->tx_buff_end[queue]\r\n- (__u32)tp->tx_buff_curr[queue]);\r\nif((tp->tx_buff_used[queue] + alloc_size)\r\n> tp->tx_buff_size[queue])\r\n{\r\nreturn (FCBlock *)(-1L);\r\n}\r\ntp->tx_buff_curr[queue] = tp->tx_buff_head[queue];\r\n}\r\ntp->tx_buff_used[queue] += alloc_size;\r\ntp->num_tx_fcbs_used[queue]++;\r\ntp->tx_fcb_curr[queue]->frame_length = bytes_count;\r\ntp->tx_fcb_curr[queue]->memory_alloc = alloc_size;\r\ntemp = tp->tx_buff_curr[queue];\r\ntp->tx_buff_curr[queue]\r\n= (__u16 *)((__u32)temp + (__u32)((bytes_count + 1) & 0xfffe));\r\npbdb = tp->tx_fcb_curr[queue]->bdb_ptr;\r\npbdb->buffer_length = bytes_count;\r\npbdb->data_block_ptr = temp;\r\npbdb->trc_data_block_ptr = TRC_POINTER(temp);\r\npFCB = tp->tx_fcb_curr[queue];\r\ntp->tx_fcb_curr[queue] = tp->tx_fcb_curr[queue]->next_ptr;\r\nreturn pFCB;\r\n}\r\nstatic int smctr_get_upstream_neighbor_addr(struct net_device *dev)\r\n{\r\nsmctr_issue_read_word_cmd(dev, RW_UPSTREAM_NEIGHBOR_ADDRESS);\r\nreturn smctr_wait_cmd(dev);\r\n}\r\nstatic int smctr_hardware_send_packet(struct net_device *dev,\r\nstruct net_local *tp)\r\n{\r\nstruct tr_statistics *tstat = &tp->MacStat;\r\nstruct sk_buff *skb;\r\nFCBlock *fcb;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG"%s: smctr_hardware_send_packet\n", dev->name);\r\nif(tp->status != OPEN)\r\nreturn -1;\r\nif(tp->monitor_state_ready != 1)\r\nreturn -1;\r\nfor(;;)\r\n{\r\nskb = skb_dequeue(&tp->SendSkbQueue);\r\nif(skb == NULL)\r\nreturn -1;\r\ntp->QueueSkb++;\r\nif(skb->len < SMC_HEADER_SIZE || skb->len > tp->max_packet_size)\r\nreturn -1;\r\nsmctr_enable_16bit(dev);\r\nsmctr_set_page(dev, (__u8 *)tp->ram_access);\r\nif((fcb = smctr_get_tx_fcb(dev, NON_MAC_QUEUE, skb->len))\r\n== (FCBlock *)(-1L))\r\n{\r\nsmctr_disable_16bit(dev);\r\nreturn -1;\r\n}\r\nsmctr_tx_move_frame(dev, skb,\r\n(__u8 *)fcb->bdb_ptr->data_block_ptr, skb->len);\r\nsmctr_set_page(dev, (__u8 *)fcb);\r\nsmctr_trc_send_packet(dev, fcb, NON_MAC_QUEUE);\r\ndev_kfree_skb(skb);\r\ntstat->tx_packets++;\r\nsmctr_disable_16bit(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int smctr_init_acbs(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int i;\r\nACBlock *acb;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_init_acbs\n", dev->name);\r\nacb = tp->acb_head;\r\nacb->cmd_done_status = (ACB_COMMAND_DONE | ACB_COMMAND_SUCCESSFUL);\r\nacb->cmd_info = ACB_CHAIN_END;\r\nacb->cmd = 0;\r\nacb->subcmd = 0;\r\nacb->data_offset_lo = 0;\r\nacb->data_offset_hi = 0;\r\nacb->next_ptr\r\n= (ACBlock *)(((char *)acb) + sizeof(ACBlock));\r\nacb->trc_next_ptr = TRC_POINTER(acb->next_ptr);\r\nfor(i = 1; i < tp->num_acbs; i++)\r\n{\r\nacb = acb->next_ptr;\r\nacb->cmd_done_status\r\n= (ACB_COMMAND_DONE | ACB_COMMAND_SUCCESSFUL);\r\nacb->cmd_info = ACB_CHAIN_END;\r\nacb->cmd = 0;\r\nacb->subcmd = 0;\r\nacb->data_offset_lo = 0;\r\nacb->data_offset_hi = 0;\r\nacb->next_ptr\r\n= (ACBlock *)(((char *)acb) + sizeof(ACBlock));\r\nacb->trc_next_ptr = TRC_POINTER(acb->next_ptr);\r\n}\r\nacb->next_ptr = tp->acb_head;\r\nacb->trc_next_ptr = TRC_POINTER(tp->acb_head);\r\ntp->acb_next = tp->acb_head->next_ptr;\r\ntp->acb_curr = tp->acb_head->next_ptr;\r\ntp->num_acbs_used = 0;\r\nreturn 0;\r\n}\r\nstatic int smctr_init_adapter(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint err;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_init_adapter\n", dev->name);\r\ntp->status = CLOSED;\r\ntp->page_offset_mask = (tp->ram_usable * 1024) - 1;\r\nskb_queue_head_init(&tp->SendSkbQueue);\r\ntp->QueueSkb = MAX_TX_QUEUE;\r\nif(!(tp->group_address_0 & 0x0080))\r\ntp->group_address_0 |= 0x00C0;\r\nif(!(tp->functional_address_0 & 0x00C0))\r\ntp->functional_address_0 |= 0x00C0;\r\ntp->functional_address[0] &= 0xFF7F;\r\nif(tp->authorized_function_classes == 0)\r\ntp->authorized_function_classes = 0x7FFF;\r\nif(tp->authorized_access_priority == 0)\r\ntp->authorized_access_priority = 0x06;\r\nsmctr_disable_bic_int(dev);\r\nsmctr_set_trc_reset(dev->base_addr);\r\nsmctr_enable_16bit(dev);\r\nsmctr_set_page(dev, (__u8 *)tp->ram_access);\r\nif(smctr_checksum_firmware(dev))\r\n{\r\nprintk(KERN_ERR "%s: Previously loaded firmware is missing\n",dev->name);\r\nreturn -ENOENT;\r\n}\r\nif((err = smctr_ram_memory_test(dev)))\r\n{\r\nprintk(KERN_ERR "%s: RAM memory test failed.\n", dev->name);\r\nreturn -EIO;\r\n}\r\nsmctr_set_rx_look_ahead(dev);\r\nsmctr_load_node_addr(dev);\r\nsmctr_reset_adapter(dev);\r\nif((err = smctr_init_card_real(dev)))\r\n{\r\nprintk(KERN_ERR "%s: Initialization of card failed (%d)\n",\r\ndev->name, err);\r\nreturn -EINVAL;\r\n}\r\nif((err = smctr_internal_self_test(dev)))\r\n{\r\nprintk(KERN_ERR "%s: Card failed internal self test (%d)\n",\r\ndev->name, err);\r\nreturn -EINVAL;\r\n}\r\nsmctr_reset_adapter(dev);\r\nif((err = smctr_init_card_real(dev)))\r\n{\r\nprintk(KERN_ERR "%s: Initialization of card failed (%d)\n",\r\ndev->name, err);\r\nreturn -EINVAL;\r\n}\r\nsmctr_enable_bic_int(dev);\r\nif((err = smctr_issue_enable_int_cmd(dev, TRC_INTERRUPT_ENABLE_MASK)))\r\nreturn err;\r\nsmctr_disable_16bit(dev);\r\nreturn 0;\r\n}\r\nstatic int smctr_init_card_real(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint err = 0;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_init_card_real\n", dev->name);\r\ntp->sh_mem_used = 0;\r\ntp->num_acbs = NUM_OF_ACBS;\r\nif(tp->max_packet_size < 256)\r\ntp->max_packet_size = 256;\r\nelse\r\n{\r\nif(tp->max_packet_size > NON_MAC_TX_BUFFER_MEMORY)\r\ntp->max_packet_size = NON_MAC_TX_BUFFER_MEMORY;\r\n}\r\ntp->num_of_tx_buffs = (NON_MAC_TX_BUFFER_MEMORY\r\n/ tp->max_packet_size) - 1;\r\nif(tp->num_of_tx_buffs > NUM_NON_MAC_TX_FCBS)\r\ntp->num_of_tx_buffs = NUM_NON_MAC_TX_FCBS;\r\nelse\r\n{\r\nif(tp->num_of_tx_buffs == 0)\r\ntp->num_of_tx_buffs = 1;\r\n}\r\ntp->num_tx_fcbs [BUG_QUEUE] = NUM_BUG_TX_FCBS;\r\ntp->num_tx_bdbs [BUG_QUEUE] = NUM_BUG_TX_BDBS;\r\ntp->tx_buff_size [BUG_QUEUE] = BUG_TX_BUFFER_MEMORY;\r\ntp->tx_buff_used [BUG_QUEUE] = 0;\r\ntp->tx_queue_status [BUG_QUEUE] = NOT_TRANSMITING;\r\ntp->num_tx_fcbs [MAC_QUEUE] = NUM_MAC_TX_FCBS;\r\ntp->num_tx_bdbs [MAC_QUEUE] = NUM_MAC_TX_BDBS;\r\ntp->tx_buff_size [MAC_QUEUE] = MAC_TX_BUFFER_MEMORY;\r\ntp->tx_buff_used [MAC_QUEUE] = 0;\r\ntp->tx_queue_status [MAC_QUEUE] = NOT_TRANSMITING;\r\ntp->num_tx_fcbs [NON_MAC_QUEUE] = NUM_NON_MAC_TX_FCBS;\r\ntp->num_tx_bdbs [NON_MAC_QUEUE] = NUM_NON_MAC_TX_BDBS;\r\ntp->tx_buff_size [NON_MAC_QUEUE] = NON_MAC_TX_BUFFER_MEMORY;\r\ntp->tx_buff_used [NON_MAC_QUEUE] = 0;\r\ntp->tx_queue_status [NON_MAC_QUEUE] = NOT_TRANSMITING;\r\ntp->num_rx_fcbs[MAC_QUEUE] = NUM_MAC_RX_FCBS;\r\ntp->num_rx_bdbs[MAC_QUEUE] = NUM_MAC_RX_BDBS;\r\nif(tp->extra_info & CHIP_REV_MASK)\r\ntp->num_rx_fcbs[NON_MAC_QUEUE] = 78;\r\nelse\r\ntp->num_rx_fcbs[NON_MAC_QUEUE] = 7;\r\ntp->num_rx_bdbs[NON_MAC_QUEUE] = smctr_get_num_rx_bdbs(dev);\r\nsmctr_alloc_shared_memory(dev);\r\nsmctr_init_shared_memory(dev);\r\nif((err = smctr_issue_init_timers_cmd(dev)))\r\nreturn err;\r\nif((err = smctr_issue_init_txrx_cmd(dev)))\r\n{\r\nprintk(KERN_ERR "%s: Hardware failure\n", dev->name);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smctr_init_rx_bdbs(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int i, j;\r\nBDBlock *bdb;\r\n__u16 *buf;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_init_rx_bdbs\n", dev->name);\r\nfor(i = 0; i < NUM_RX_QS_USED; i++)\r\n{\r\nbdb = tp->rx_bdb_head[i];\r\nbuf = tp->rx_buff_head[i];\r\nbdb->info = (BDB_CHAIN_END | BDB_NO_WARNING);\r\nbdb->buffer_length = RX_DATA_BUFFER_SIZE;\r\nbdb->next_ptr = (BDBlock *)(((char *)bdb) + sizeof(BDBlock));\r\nbdb->data_block_ptr = buf;\r\nbdb->trc_next_ptr = TRC_POINTER(bdb->next_ptr);\r\nif(i == NON_MAC_QUEUE)\r\nbdb->trc_data_block_ptr = RX_BUFF_TRC_POINTER(buf);\r\nelse\r\nbdb->trc_data_block_ptr = TRC_POINTER(buf);\r\nfor(j = 1; j < tp->num_rx_bdbs[i]; j++)\r\n{\r\nbdb->next_ptr->back_ptr = bdb;\r\nbdb = bdb->next_ptr;\r\nbuf = (__u16 *)((char *)buf + RX_DATA_BUFFER_SIZE);\r\nbdb->info = (BDB_NOT_CHAIN_END | BDB_NO_WARNING);\r\nbdb->buffer_length = RX_DATA_BUFFER_SIZE;\r\nbdb->next_ptr = (BDBlock *)(((char *)bdb) + sizeof(BDBlock));\r\nbdb->data_block_ptr = buf;\r\nbdb->trc_next_ptr = TRC_POINTER(bdb->next_ptr);\r\nif(i == NON_MAC_QUEUE)\r\nbdb->trc_data_block_ptr = RX_BUFF_TRC_POINTER(buf);\r\nelse\r\nbdb->trc_data_block_ptr = TRC_POINTER(buf);\r\n}\r\nbdb->next_ptr = tp->rx_bdb_head[i];\r\nbdb->trc_next_ptr = TRC_POINTER(tp->rx_bdb_head[i]);\r\ntp->rx_bdb_head[i]->back_ptr = bdb;\r\ntp->rx_bdb_curr[i] = tp->rx_bdb_head[i]->next_ptr;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smctr_init_rx_fcbs(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int i, j;\r\nFCBlock *fcb;\r\nfor(i = 0; i < NUM_RX_QS_USED; i++)\r\n{\r\nfcb = tp->rx_fcb_head[i];\r\nfcb->frame_status = 0;\r\nfcb->frame_length = 0;\r\nfcb->info = FCB_CHAIN_END;\r\nfcb->next_ptr = (FCBlock *)(((char*)fcb) + sizeof(FCBlock));\r\nif(i == NON_MAC_QUEUE)\r\nfcb->trc_next_ptr = RX_FCB_TRC_POINTER(fcb->next_ptr);\r\nelse\r\nfcb->trc_next_ptr = TRC_POINTER(fcb->next_ptr);\r\nfor(j = 1; j < tp->num_rx_fcbs[i]; j++)\r\n{\r\nfcb->next_ptr->back_ptr = fcb;\r\nfcb = fcb->next_ptr;\r\nfcb->frame_status = 0;\r\nfcb->frame_length = 0;\r\nfcb->info = FCB_WARNING;\r\nfcb->next_ptr\r\n= (FCBlock *)(((char *)fcb) + sizeof(FCBlock));\r\nif(i == NON_MAC_QUEUE)\r\nfcb->trc_next_ptr\r\n= RX_FCB_TRC_POINTER(fcb->next_ptr);\r\nelse\r\nfcb->trc_next_ptr\r\n= TRC_POINTER(fcb->next_ptr);\r\n}\r\nfcb->next_ptr = tp->rx_fcb_head[i];\r\nif(i == NON_MAC_QUEUE)\r\nfcb->trc_next_ptr = RX_FCB_TRC_POINTER(fcb->next_ptr);\r\nelse\r\nfcb->trc_next_ptr = TRC_POINTER(fcb->next_ptr);\r\ntp->rx_fcb_head[i]->back_ptr = fcb;\r\ntp->rx_fcb_curr[i] = tp->rx_fcb_head[i]->next_ptr;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smctr_init_shared_memory(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int i;\r\n__u32 *iscpb;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_init_shared_memory\n", dev->name);\r\nsmctr_set_page(dev, (__u8 *)(unsigned int)tp->iscpb_ptr);\r\niscpb = (__u32 *)PAGE_POINTER(&tp->iscpb_ptr->trc_scgb_ptr);\r\n*iscpb = (__u32)(SWAP_WORDS(TRC_POINTER(tp->scgb_ptr)));\r\nsmctr_set_page(dev, (__u8 *)tp->ram_access);\r\ntp->scgb_ptr->config = (SCGB_ADDRESS_POINTER_FORMAT\r\n| SCGB_MULTI_WORD_CONTROL | SCGB_DATA_FORMAT\r\n| SCGB_BURST_LENGTH);\r\ntp->scgb_ptr->trc_sclb_ptr = TRC_POINTER(tp->sclb_ptr);\r\ntp->scgb_ptr->trc_acb_ptr = TRC_POINTER(tp->acb_head);\r\ntp->scgb_ptr->trc_isb_ptr = TRC_POINTER(tp->isb_ptr);\r\ntp->scgb_ptr->isbsiz = (sizeof(ISBlock)) - 2;\r\ntp->sclb_ptr->valid_command = SCLB_VALID | SCLB_CMD_NOP;\r\ntp->sclb_ptr->iack_code = 0;\r\ntp->sclb_ptr->resume_control = 0;\r\ntp->sclb_ptr->int_mask_control = 0;\r\ntp->sclb_ptr->int_mask_state = 0;\r\nfor(i = 0; i < NUM_OF_INTERRUPTS; i++)\r\n{\r\ntp->isb_ptr->IStatus[i].IType = 0xf0;\r\ntp->isb_ptr->IStatus[i].ISubtype = 0;\r\n}\r\ntp->current_isb_index = 0;\r\nsmctr_init_acbs(dev);\r\nsmctr_link_tx_fcbs_to_bdbs(dev);\r\nsmctr_init_tx_bdbs(dev);\r\nsmctr_init_tx_fcbs(dev);\r\nsmctr_init_rx_bdbs(dev);\r\nsmctr_init_rx_fcbs(dev);\r\nreturn 0;\r\n}\r\nstatic int smctr_init_tx_bdbs(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int i, j;\r\nBDBlock *bdb;\r\nfor(i = 0; i < NUM_TX_QS_USED; i++)\r\n{\r\nbdb = tp->tx_bdb_head[i];\r\nbdb->info = (BDB_NOT_CHAIN_END | BDB_NO_WARNING);\r\nbdb->next_ptr = (BDBlock *)(((char *)bdb) + sizeof(BDBlock));\r\nbdb->trc_next_ptr = TRC_POINTER(bdb->next_ptr);\r\nfor(j = 1; j < tp->num_tx_bdbs[i]; j++)\r\n{\r\nbdb->next_ptr->back_ptr = bdb;\r\nbdb = bdb->next_ptr;\r\nbdb->info = (BDB_NOT_CHAIN_END | BDB_NO_WARNING);\r\nbdb->next_ptr\r\n= (BDBlock *)(((char *)bdb) + sizeof( BDBlock)); bdb->trc_next_ptr = TRC_POINTER(bdb->next_ptr);\r\n}\r\nbdb->next_ptr = tp->tx_bdb_head[i];\r\nbdb->trc_next_ptr = TRC_POINTER(tp->tx_bdb_head[i]);\r\ntp->tx_bdb_head[i]->back_ptr = bdb;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smctr_init_tx_fcbs(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int i, j;\r\nFCBlock *fcb;\r\nfor(i = 0; i < NUM_TX_QS_USED; i++)\r\n{\r\nfcb = tp->tx_fcb_head[i];\r\nfcb->frame_status = 0;\r\nfcb->frame_length = 0;\r\nfcb->info = FCB_CHAIN_END;\r\nfcb->next_ptr = (FCBlock *)(((char *)fcb) + sizeof(FCBlock));\r\nfcb->trc_next_ptr = TRC_POINTER(fcb->next_ptr);\r\nfor(j = 1; j < tp->num_tx_fcbs[i]; j++)\r\n{\r\nfcb->next_ptr->back_ptr = fcb;\r\nfcb = fcb->next_ptr;\r\nfcb->frame_status = 0;\r\nfcb->frame_length = 0;\r\nfcb->info = FCB_CHAIN_END;\r\nfcb->next_ptr\r\n= (FCBlock *)(((char *)fcb) + sizeof(FCBlock));\r\nfcb->trc_next_ptr = TRC_POINTER(fcb->next_ptr);\r\n}\r\nfcb->next_ptr = tp->tx_fcb_head[i];\r\nfcb->trc_next_ptr = TRC_POINTER(tp->tx_fcb_head[i]);\r\ntp->tx_fcb_head[i]->back_ptr = fcb;\r\ntp->tx_fcb_end[i] = tp->tx_fcb_head[i]->next_ptr;\r\ntp->tx_fcb_curr[i] = tp->tx_fcb_head[i]->next_ptr;\r\ntp->num_tx_fcbs_used[i] = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smctr_internal_self_test(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint err;\r\nif((err = smctr_issue_test_internal_rom_cmd(dev)))\r\nreturn err;\r\nif((err = smctr_wait_cmd(dev)))\r\nreturn err;\r\nif(tp->acb_head->cmd_done_status & 0xff)\r\nreturn -1;\r\nif((err = smctr_issue_test_hic_cmd(dev)))\r\nreturn err;\r\nif((err = smctr_wait_cmd(dev)))\r\nreturn err;\r\nif(tp->acb_head->cmd_done_status & 0xff)\r\nreturn -1;\r\nif((err = smctr_issue_test_mac_reg_cmd(dev)))\r\nreturn err;\r\nif((err = smctr_wait_cmd(dev)))\r\nreturn err;\r\nif(tp->acb_head->cmd_done_status & 0xff)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t smctr_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct net_local *tp;\r\nint ioaddr;\r\n__u16 interrupt_unmask_bits = 0, interrupt_ack_code = 0xff00;\r\n__u16 err1, err = NOT_MY_INTERRUPT;\r\n__u8 isb_type, isb_subtype;\r\n__u16 isb_index;\r\nioaddr = dev->base_addr;\r\ntp = netdev_priv(dev);\r\nif(tp->status == NOT_INITIALIZED)\r\nreturn IRQ_NONE;\r\nspin_lock(&tp->lock);\r\nsmctr_disable_bic_int(dev);\r\nsmctr_enable_16bit(dev);\r\nsmctr_clear_int(dev);\r\nwhile((tp->isb_ptr->IStatus[tp->current_isb_index].IType & 0xf0) == 0)\r\n{\r\nisb_index = tp->current_isb_index;\r\nisb_type = tp->isb_ptr->IStatus[isb_index].IType;\r\nisb_subtype = tp->isb_ptr->IStatus[isb_index].ISubtype;\r\n(tp->current_isb_index)++;\r\nif(tp->current_isb_index == NUM_OF_INTERRUPTS)\r\ntp->current_isb_index = 0;\r\nif(isb_type >= 0x10)\r\n{\r\nsmctr_disable_16bit(dev);\r\nspin_unlock(&tp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nerr = HARDWARE_FAILED;\r\ninterrupt_ack_code = isb_index;\r\ntp->isb_ptr->IStatus[isb_index].IType |= 0xf0;\r\ninterrupt_unmask_bits |= (1 << (__u16)isb_type);\r\nswitch(isb_type)\r\n{\r\ncase ISB_IMC_MAC_TYPE_3:\r\nsmctr_disable_16bit(dev);\r\nswitch(isb_subtype)\r\n{\r\ncase 0:\r\ntp->monitor_state = MS_MONITOR_FSM_INACTIVE;\r\nbreak;\r\ncase 1:\r\ntp->monitor_state = MS_REPEAT_BEACON_STATE;\r\nbreak;\r\ncase 2:\r\ntp->monitor_state = MS_REPEAT_CLAIM_TOKEN_STATE;\r\nbreak;\r\ncase 3:\r\ntp->monitor_state = MS_TRANSMIT_CLAIM_TOKEN_STATE; break;\r\ncase 4:\r\ntp->monitor_state = MS_STANDBY_MONITOR_STATE;\r\nbreak;\r\ncase 5:\r\ntp->monitor_state = MS_TRANSMIT_BEACON_STATE;\r\nbreak;\r\ncase 6:\r\ntp->monitor_state = MS_ACTIVE_MONITOR_STATE;\r\nbreak;\r\ncase 7:\r\ntp->monitor_state = MS_TRANSMIT_RING_PURGE_STATE;\r\nbreak;\r\ncase 8:\r\nbreak;\r\ncase 9:\r\ntp->monitor_state = MS_BEACON_TEST_STATE;\r\nif(smctr_lobe_media_test(dev))\r\n{\r\ntp->ring_status_flags = RING_STATUS_CHANGED;\r\ntp->ring_status = AUTO_REMOVAL_ERROR;\r\nsmctr_ring_status_chg(dev);\r\nsmctr_bypass_state(dev);\r\n}\r\nelse\r\nsmctr_issue_insert_cmd(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntp->ring_status_flags = MONITOR_STATE_CHANGED;\r\nerr = smctr_ring_status_chg(dev);\r\nsmctr_enable_16bit(dev);\r\nbreak;\r\ncase ISB_IMC_MAC_ERROR_COUNTERS:\r\nerr = smctr_issue_read_ring_status_cmd(dev);\r\nbreak;\r\ncase ISB_IMC_MAC_TYPE_2:\r\nerr = smctr_issue_read_ring_status_cmd(dev);\r\nbreak;\r\ncase ISB_IMC_TX_FRAME:\r\nif(isb_subtype & TX_PENDING_PRIORITY_2)\r\n{\r\nif((err = smctr_tx_complete(dev, BUG_QUEUE)) != SUCCESS)\r\nbreak;\r\n}\r\nif(isb_subtype & TX_PENDING_PRIORITY_1)\r\n{\r\nif((err = smctr_tx_complete(dev, NON_MAC_QUEUE)) != SUCCESS)\r\nbreak;\r\n}\r\nif(isb_subtype & TX_PENDING_PRIORITY_0)\r\nerr = smctr_tx_complete(dev, MAC_QUEUE); break;\r\ncase ISB_IMC_END_OF_TX_QUEUE:\r\nif(isb_subtype & TX_PENDING_PRIORITY_2)\r\n{\r\ninterrupt_unmask_bits |= 0x800;\r\ntp->tx_queue_status[BUG_QUEUE] = NOT_TRANSMITING;\r\nif((err = smctr_tx_complete(dev, BUG_QUEUE)) != SUCCESS)\r\nbreak;\r\nif((err = smctr_restart_tx_chain(dev, BUG_QUEUE)) != SUCCESS)\r\nbreak;\r\n}\r\nif(isb_subtype & TX_PENDING_PRIORITY_1)\r\n{\r\ntp->tx_queue_status[NON_MAC_QUEUE] = NOT_TRANSMITING;\r\nif((err = smctr_tx_complete(dev, NON_MAC_QUEUE)) != SUCCESS)\r\nbreak;\r\nif((err = smctr_restart_tx_chain(dev, NON_MAC_QUEUE)) != SUCCESS)\r\nbreak;\r\n}\r\nif(isb_subtype & TX_PENDING_PRIORITY_0)\r\n{\r\ntp->tx_queue_status[MAC_QUEUE] = NOT_TRANSMITING;\r\nif((err = smctr_tx_complete(dev, MAC_QUEUE)) != SUCCESS)\r\nbreak;\r\nerr = smctr_restart_tx_chain(dev, MAC_QUEUE);\r\n}\r\nbreak;\r\ncase ISB_IMC_NON_MAC_RX_RESOURCE:\r\ntp->rx_fifo_overrun_count = 0;\r\ntp->receive_queue_number = NON_MAC_QUEUE;\r\nerr1 = smctr_rx_frame(dev);\r\nif(isb_subtype & NON_MAC_RX_RESOURCE_FE)\r\n{\r\nif((err = smctr_issue_resume_rx_fcb_cmd( dev, NON_MAC_QUEUE)) != SUCCESS) break;\r\nif(tp->ptr_rx_fcb_overruns)\r\n(*tp->ptr_rx_fcb_overruns)++;\r\n}\r\nif(isb_subtype & NON_MAC_RX_RESOURCE_BE)\r\n{\r\nif((err = smctr_issue_resume_rx_bdb_cmd( dev, NON_MAC_QUEUE)) != SUCCESS) break;\r\nif(tp->ptr_rx_bdb_overruns)\r\n(*tp->ptr_rx_bdb_overruns)++;\r\n}\r\nerr = err1;\r\nbreak;\r\ncase ISB_IMC_MAC_RX_RESOURCE:\r\ntp->receive_queue_number = MAC_QUEUE;\r\nerr1 = smctr_rx_frame(dev);\r\nif(isb_subtype & MAC_RX_RESOURCE_FE)\r\n{\r\nif((err = smctr_issue_resume_rx_fcb_cmd( dev, MAC_QUEUE)) != SUCCESS)\r\nbreak;\r\nif(tp->ptr_rx_fcb_overruns)\r\n(*tp->ptr_rx_fcb_overruns)++;\r\n}\r\nif(isb_subtype & MAC_RX_RESOURCE_BE)\r\n{\r\nif((err = smctr_issue_resume_rx_bdb_cmd( dev, MAC_QUEUE)) != SUCCESS)\r\nbreak;\r\nif(tp->ptr_rx_bdb_overruns)\r\n(*tp->ptr_rx_bdb_overruns)++;\r\n}\r\nerr = err1;\r\nbreak;\r\ncase ISB_IMC_NON_MAC_RX_FRAME:\r\ntp->rx_fifo_overrun_count = 0;\r\ntp->receive_queue_number = NON_MAC_QUEUE;\r\nerr = smctr_rx_frame(dev);\r\nbreak;\r\ncase ISB_IMC_MAC_RX_FRAME:\r\ntp->receive_queue_number = MAC_QUEUE;\r\nerr = smctr_rx_frame(dev);\r\nbreak;\r\ncase ISB_IMC_TRC_FIFO_STATUS:\r\nif(isb_subtype & TRC_FIFO_STATUS_TX_UNDERRUN)\r\n{\r\nif(tp->ptr_tx_fifo_underruns)\r\n(*tp->ptr_tx_fifo_underruns)++;\r\n}\r\nif(isb_subtype & TRC_FIFO_STATUS_RX_OVERRUN)\r\n{\r\ntp->rx_fifo_overrun_count++;\r\nif(tp->rx_fifo_overrun_count >= 3)\r\n{\r\ntp->rx_fifo_overrun_count = 0;\r\ninterrupt_unmask_bits &= (~0x800);\r\nprintk(KERN_CRIT "Jay please send bug\n");\r\n}\r\nif(tp->ptr_rx_fifo_overruns)\r\n(*tp->ptr_rx_fifo_overruns)++;\r\n}\r\nerr = SUCCESS;\r\nbreak;\r\ncase ISB_IMC_COMMAND_STATUS:\r\nerr = SUCCESS;\r\nif(tp->acb_head->cmd == ACB_CMD_HIC_NOP)\r\n{\r\nprintk(KERN_ERR "i1\n");\r\nsmctr_disable_16bit(dev);\r\nsmctr_enable_16bit(dev);\r\n}\r\nelse\r\n{\r\nif((tp->acb_head->cmd\r\n== ACB_CMD_READ_TRC_STATUS) &&\r\n(tp->acb_head->subcmd\r\n== RW_TRC_STATUS_BLOCK))\r\n{\r\nif(tp->ptr_bcn_type)\r\n{\r\n*(tp->ptr_bcn_type)\r\n= (__u32)((SBlock *)tp->misc_command_data)->BCN_Type;\r\n}\r\nif(((SBlock *)tp->misc_command_data)->Status_CHG_Indicate & ERROR_COUNTERS_CHANGED)\r\n{\r\nsmctr_update_err_stats(dev);\r\n}\r\nif(((SBlock *)tp->misc_command_data)->Status_CHG_Indicate & TI_NDIS_RING_STATUS_CHANGED)\r\n{\r\ntp->ring_status\r\n= ((SBlock*)tp->misc_command_data)->TI_NDIS_Ring_Status;\r\nsmctr_disable_16bit(dev);\r\nerr = smctr_ring_status_chg(dev);\r\nsmctr_enable_16bit(dev);\r\nif((tp->ring_status & REMOVE_RECEIVED) &&\r\n(tp->config_word0 & NO_AUTOREMOVE))\r\n{\r\nsmctr_issue_remove_cmd(dev);\r\n}\r\nif(err != SUCCESS)\r\n{\r\ntp->acb_pending = 0;\r\nbreak;\r\n}\r\n}\r\nif(((SBlock *)tp->misc_command_data)->Status_CHG_Indicate & UNA_CHANGED)\r\n{\r\nif(tp->ptr_una)\r\n{\r\ntp->ptr_una[0] = SWAP_BYTES(((SBlock *)tp->misc_command_data)->UNA[0]);\r\ntp->ptr_una[1] = SWAP_BYTES(((SBlock *)tp->misc_command_data)->UNA[1]);\r\ntp->ptr_una[2] = SWAP_BYTES(((SBlock *)tp->misc_command_data)->UNA[2]);\r\n}\r\n}\r\nif(((SBlock *)tp->misc_command_data)->Status_CHG_Indicate & READY_TO_SEND_RQ_INIT) {\r\nerr = smctr_send_rq_init(dev);\r\n}\r\n}\r\n}\r\ntp->acb_pending = 0;\r\nbreak;\r\ncase ISB_IMC_MAC_TYPE_1:\r\nif(isb_subtype > 8)\r\n{\r\nerr = HARDWARE_FAILED;\r\nbreak;\r\n}\r\nerr = SUCCESS;\r\nswitch(isb_subtype)\r\n{\r\ncase 0:\r\ntp->join_state = JS_BYPASS_STATE;\r\nif(tp->status != CLOSED)\r\n{\r\ntp->status = CLOSED;\r\nerr = smctr_status_chg(dev);\r\n}\r\nbreak;\r\ncase 1:\r\ntp->join_state = JS_LOBE_TEST_STATE;\r\nbreak;\r\ncase 2:\r\ntp->join_state = JS_DETECT_MONITOR_PRESENT_STATE;\r\nbreak;\r\ncase 3:\r\ntp->join_state = JS_AWAIT_NEW_MONITOR_STATE;\r\nbreak;\r\ncase 4:\r\ntp->join_state = JS_DUPLICATE_ADDRESS_TEST_STATE;\r\nbreak;\r\ncase 5:\r\ntp->join_state = JS_NEIGHBOR_NOTIFICATION_STATE;\r\nbreak;\r\ncase 6:\r\ntp->join_state = JS_REQUEST_INITIALIZATION_STATE;\r\nbreak;\r\ncase 7:\r\ntp->join_state = JS_JOIN_COMPLETE_STATE;\r\ntp->status = OPEN;\r\nerr = smctr_status_chg(dev);\r\nbreak;\r\ncase 8:\r\ntp->join_state = JS_BYPASS_WAIT_STATE;\r\nbreak;\r\n}\r\nbreak ;\r\ncase ISB_IMC_TRC_INTRNL_TST_STATUS:\r\ntp->status = INITIALIZED;\r\nsmctr_disable_16bit(dev);\r\nerr = smctr_status_chg(dev);\r\nsmctr_enable_16bit(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif(err != SUCCESS)\r\nbreak;\r\n}\r\nif(!(interrupt_ack_code & 0xff00))\r\nsmctr_issue_int_ack(dev, interrupt_ack_code, interrupt_unmask_bits);\r\nsmctr_disable_16bit(dev);\r\nsmctr_enable_bic_int(dev);\r\nspin_unlock(&tp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int smctr_issue_enable_int_cmd(struct net_device *dev,\r\n__u16 interrupt_enable_mask)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint err;\r\nif((err = smctr_wait_while_cbusy(dev)))\r\nreturn err;\r\ntp->sclb_ptr->int_mask_control = interrupt_enable_mask;\r\ntp->sclb_ptr->valid_command = SCLB_VALID | SCLB_CMD_CLEAR_INTERRUPT_MASK;\r\nsmctr_set_ctrl_attention(dev);\r\nreturn 0;\r\n}\r\nstatic int smctr_issue_int_ack(struct net_device *dev, __u16 iack_code, __u16 ibits)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nif(smctr_wait_while_cbusy(dev))\r\nreturn -1;\r\ntp->sclb_ptr->int_mask_control = ibits;\r\ntp->sclb_ptr->iack_code = iack_code << 1; tp->sclb_ptr->resume_control = 0;\r\ntp->sclb_ptr->valid_command = SCLB_VALID | SCLB_IACK_CODE_VALID | SCLB_CMD_CLEAR_INTERRUPT_MASK;\r\nsmctr_set_ctrl_attention(dev);\r\nreturn 0;\r\n}\r\nstatic int smctr_issue_init_timers_cmd(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int i;\r\nint err;\r\n__u16 *pTimer_Struc = (__u16 *)tp->misc_command_data;\r\nif((err = smctr_wait_while_cbusy(dev)))\r\nreturn err;\r\nif((err = smctr_wait_cmd(dev)))\r\nreturn err;\r\ntp->config_word0 = THDREN | DMA_TRIGGER | USETPT | NO_AUTOREMOVE;\r\ntp->config_word1 = 0;\r\nif((tp->media_type == MEDIA_STP_16) ||\r\n(tp->media_type == MEDIA_UTP_16) ||\r\n(tp->media_type == MEDIA_STP_16_UTP_16))\r\n{\r\ntp->config_word0 |= FREQ_16MB_BIT;\r\n}\r\nif(tp->mode_bits & EARLY_TOKEN_REL)\r\ntp->config_word0 |= ETREN;\r\nif(tp->mode_bits & LOOPING_MODE_MASK)\r\ntp->config_word0 |= RX_OWN_BIT;\r\nelse\r\ntp->config_word0 &= ~RX_OWN_BIT;\r\nif(tp->receive_mask & PROMISCUOUS_MODE)\r\ntp->config_word0 |= PROMISCUOUS_BIT;\r\nelse\r\ntp->config_word0 &= ~PROMISCUOUS_BIT;\r\nif(tp->receive_mask & ACCEPT_ERR_PACKETS)\r\ntp->config_word0 |= SAVBAD_BIT;\r\nelse\r\ntp->config_word0 &= ~SAVBAD_BIT;\r\nif(tp->receive_mask & ACCEPT_ATT_MAC_FRAMES)\r\ntp->config_word0 |= RXATMAC;\r\nelse\r\ntp->config_word0 &= ~RXATMAC;\r\nif(tp->receive_mask & ACCEPT_MULTI_PROM)\r\ntp->config_word1 |= MULTICAST_ADDRESS_BIT;\r\nelse\r\ntp->config_word1 &= ~MULTICAST_ADDRESS_BIT;\r\nif(tp->receive_mask & ACCEPT_SOURCE_ROUTING_SPANNING)\r\ntp->config_word1 |= SOURCE_ROUTING_SPANNING_BITS;\r\nelse\r\n{\r\nif(tp->receive_mask & ACCEPT_SOURCE_ROUTING)\r\ntp->config_word1 |= SOURCE_ROUTING_EXPLORER_BIT;\r\nelse\r\ntp->config_word1 &= ~SOURCE_ROUTING_SPANNING_BITS;\r\n}\r\nif((tp->media_type == MEDIA_STP_16) ||\r\n(tp->media_type == MEDIA_UTP_16) ||\r\n(tp->media_type == MEDIA_STP_16_UTP_16))\r\n{\r\ntp->config_word1 |= INTERFRAME_SPACING_16;\r\n}\r\nelse\r\ntp->config_word1 |= INTERFRAME_SPACING_4;\r\n*pTimer_Struc++ = tp->config_word0;\r\n*pTimer_Struc++ = tp->config_word1;\r\nif((tp->media_type == MEDIA_STP_4) ||\r\n(tp->media_type == MEDIA_UTP_4) ||\r\n(tp->media_type == MEDIA_STP_4_UTP_4))\r\n{\r\n*pTimer_Struc++ = 0x00FA;\r\n*pTimer_Struc++ = 0x2710;\r\n*pTimer_Struc++ = 0x2710;\r\n*pTimer_Struc++ = 0x0A28;\r\n*pTimer_Struc++ = 0x3E80;\r\n*pTimer_Struc++ = 0x3A98;\r\n*pTimer_Struc++ = 0x1B58;\r\n*pTimer_Struc++ = 0x00C8;\r\n*pTimer_Struc++ = 0x07D0;\r\n*pTimer_Struc++ = 0x000A;\r\n*pTimer_Struc++ = 0x1162;\r\n*pTimer_Struc++ = 0x07D0;\r\n*pTimer_Struc++ = 0x1388;\r\n*pTimer_Struc++ = 0x0000;\r\n}\r\nelse\r\n{\r\n*pTimer_Struc++ = 0x03E8;\r\n*pTimer_Struc++ = 0x9C40;\r\n*pTimer_Struc++ = 0x9C40;\r\n*pTimer_Struc++ = 0x0A28;\r\n*pTimer_Struc++ = 0x3E80;\r\n*pTimer_Struc++ = 0x3A98;\r\n*pTimer_Struc++ = 0x1B58;\r\n*pTimer_Struc++ = 0x00C8;\r\n*pTimer_Struc++ = 0x07D0;\r\n*pTimer_Struc++ = 0x000A;\r\n*pTimer_Struc++ = 0x4588;\r\n*pTimer_Struc++ = 0x1F40;\r\n*pTimer_Struc++ = 0x4E20;\r\n*pTimer_Struc++ = 0x0000;\r\n}\r\n*pTimer_Struc++ = dev->dev_addr[0] << 8\r\n| (dev->dev_addr[1] & 0xFF);\r\n*pTimer_Struc++ = dev->dev_addr[2] << 8\r\n| (dev->dev_addr[3] & 0xFF);\r\n*pTimer_Struc++ = dev->dev_addr[4] << 8\r\n| (dev->dev_addr[5] & 0xFF);\r\n*pTimer_Struc++ = tp->group_address_0 << 8\r\n| tp->group_address_0 >> 8;\r\n*pTimer_Struc++ = tp->group_address[0] << 8\r\n| tp->group_address[0] >> 8;\r\n*pTimer_Struc++ = tp->group_address[1] << 8\r\n| tp->group_address[1] >> 8;\r\n*pTimer_Struc++ = tp->functional_address_0 << 8\r\n| tp->functional_address_0 >> 8;\r\n*pTimer_Struc++ = tp->functional_address[0] << 8\r\n| tp->functional_address[0] >> 8;\r\n*pTimer_Struc++ = tp->functional_address[1] << 8\r\n| tp->functional_address[1] >> 8;\r\n*pTimer_Struc++ = tp->bitwise_group_address[0] << 8\r\n| tp->bitwise_group_address[0] >> 8;\r\n*pTimer_Struc++ = tp->bitwise_group_address[1] << 8\r\n| tp->bitwise_group_address[1] >> 8;\r\n*pTimer_Struc++ = tp->source_ring_number;\r\n*pTimer_Struc++ = tp->target_ring_number;\r\n*pTimer_Struc++ = (unsigned short)0;\r\n*pTimer_Struc++ = (unsigned short)0;\r\nfor(i = 0; i < 9; i++)\r\n*pTimer_Struc++ = (unsigned short)0;\r\nerr = smctr_setup_single_cmd_w_data(dev, ACB_CMD_INIT_TRC_TIMERS, 0);\r\nreturn err;\r\n}\r\nstatic int smctr_issue_init_txrx_cmd(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int i;\r\nint err;\r\nvoid **txrx_ptrs = (void *)tp->misc_command_data;\r\nif((err = smctr_wait_while_cbusy(dev)))\r\nreturn err;\r\nif((err = smctr_wait_cmd(dev)))\r\n{\r\nprintk(KERN_ERR "%s: Hardware failure\n", dev->name);\r\nreturn err;\r\n}\r\nfor(i = 0; i < NUM_TX_QS_USED; i++)\r\n*txrx_ptrs++ = (void *)TRC_POINTER(tp->tx_fcb_head[i]);\r\nfor(; i < MAX_TX_QS; i++)\r\n*txrx_ptrs++ = (void *)0;\r\nfor(i = 0; i < NUM_RX_QS_USED; i++)\r\n{\r\n*txrx_ptrs++ = (void *)TRC_POINTER(tp->rx_fcb_head[i]);\r\n*txrx_ptrs++ = (void *)TRC_POINTER(tp->rx_bdb_head[i]);\r\n}\r\nfor(; i < MAX_RX_QS; i++)\r\n{\r\n*txrx_ptrs++ = (void *)0;\r\n*txrx_ptrs++ = (void *)0;\r\n}\r\nerr = smctr_setup_single_cmd_w_data(dev, ACB_CMD_INIT_TX_RX, 0);\r\nreturn err;\r\n}\r\nstatic int smctr_issue_insert_cmd(struct net_device *dev)\r\n{\r\nint err;\r\nerr = smctr_setup_single_cmd(dev, ACB_CMD_INSERT, ACB_SUB_CMD_NOP);\r\nreturn err;\r\n}\r\nstatic int smctr_issue_read_ring_status_cmd(struct net_device *dev)\r\n{\r\nint err;\r\nif((err = smctr_wait_while_cbusy(dev)))\r\nreturn err;\r\nif((err = smctr_wait_cmd(dev)))\r\nreturn err;\r\nerr = smctr_setup_single_cmd_w_data(dev, ACB_CMD_READ_TRC_STATUS,\r\nRW_TRC_STATUS_BLOCK);\r\nreturn err;\r\n}\r\nstatic int smctr_issue_read_word_cmd(struct net_device *dev, __u16 aword_cnt)\r\n{\r\nint err;\r\nif((err = smctr_wait_while_cbusy(dev)))\r\nreturn err;\r\nif((err = smctr_wait_cmd(dev)))\r\nreturn err;\r\nerr = smctr_setup_single_cmd_w_data(dev, ACB_CMD_MCT_READ_VALUE,\r\naword_cnt);\r\nreturn err;\r\n}\r\nstatic int smctr_issue_remove_cmd(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint err;\r\nif((err = smctr_wait_while_cbusy(dev)))\r\nreturn err;\r\ntp->sclb_ptr->resume_control = 0;\r\ntp->sclb_ptr->valid_command = SCLB_VALID | SCLB_CMD_REMOVE;\r\nsmctr_set_ctrl_attention(dev);\r\nreturn 0;\r\n}\r\nstatic int smctr_issue_resume_acb_cmd(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint err;\r\nif((err = smctr_wait_while_cbusy(dev)))\r\nreturn err;\r\ntp->sclb_ptr->resume_control = SCLB_RC_ACB;\r\ntp->sclb_ptr->valid_command = SCLB_VALID | SCLB_RESUME_CONTROL_VALID;\r\ntp->acb_pending = 1;\r\nsmctr_set_ctrl_attention(dev);\r\nreturn 0;\r\n}\r\nstatic int smctr_issue_resume_rx_bdb_cmd(struct net_device *dev, __u16 queue)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint err;\r\nif((err = smctr_wait_while_cbusy(dev)))\r\nreturn err;\r\nif(queue == MAC_QUEUE)\r\ntp->sclb_ptr->resume_control = SCLB_RC_RX_MAC_BDB;\r\nelse\r\ntp->sclb_ptr->resume_control = SCLB_RC_RX_NON_MAC_BDB;\r\ntp->sclb_ptr->valid_command = SCLB_VALID | SCLB_RESUME_CONTROL_VALID;\r\nsmctr_set_ctrl_attention(dev);\r\nreturn 0;\r\n}\r\nstatic int smctr_issue_resume_rx_fcb_cmd(struct net_device *dev, __u16 queue)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_issue_resume_rx_fcb_cmd\n", dev->name);\r\nif(smctr_wait_while_cbusy(dev))\r\nreturn -1;\r\nif(queue == MAC_QUEUE)\r\ntp->sclb_ptr->resume_control = SCLB_RC_RX_MAC_FCB;\r\nelse\r\ntp->sclb_ptr->resume_control = SCLB_RC_RX_NON_MAC_FCB;\r\ntp->sclb_ptr->valid_command = SCLB_VALID | SCLB_RESUME_CONTROL_VALID;\r\nsmctr_set_ctrl_attention(dev);\r\nreturn 0;\r\n}\r\nstatic int smctr_issue_resume_tx_fcb_cmd(struct net_device *dev, __u16 queue)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_issue_resume_tx_fcb_cmd\n", dev->name);\r\nif(smctr_wait_while_cbusy(dev))\r\nreturn -1;\r\ntp->sclb_ptr->resume_control = (SCLB_RC_TFCB0 << queue);\r\ntp->sclb_ptr->valid_command = SCLB_RESUME_CONTROL_VALID | SCLB_VALID;\r\nsmctr_set_ctrl_attention(dev);\r\nreturn 0;\r\n}\r\nstatic int smctr_issue_test_internal_rom_cmd(struct net_device *dev)\r\n{\r\nint err;\r\nerr = smctr_setup_single_cmd(dev, ACB_CMD_MCT_TEST,\r\nTRC_INTERNAL_ROM_TEST);\r\nreturn err;\r\n}\r\nstatic int smctr_issue_test_hic_cmd(struct net_device *dev)\r\n{\r\nint err;\r\nerr = smctr_setup_single_cmd(dev, ACB_CMD_HIC_TEST,\r\nTRC_HOST_INTERFACE_REG_TEST);\r\nreturn err;\r\n}\r\nstatic int smctr_issue_test_mac_reg_cmd(struct net_device *dev)\r\n{\r\nint err;\r\nerr = smctr_setup_single_cmd(dev, ACB_CMD_MCT_TEST,\r\nTRC_MAC_REGISTERS_TEST);\r\nreturn err;\r\n}\r\nstatic int smctr_issue_trc_loopback_cmd(struct net_device *dev)\r\n{\r\nint err;\r\nerr = smctr_setup_single_cmd(dev, ACB_CMD_MCT_TEST,\r\nTRC_INTERNAL_LOOPBACK);\r\nreturn err;\r\n}\r\nstatic int smctr_issue_tri_loopback_cmd(struct net_device *dev)\r\n{\r\nint err;\r\nerr = smctr_setup_single_cmd(dev, ACB_CMD_MCT_TEST,\r\nTRC_TRI_LOOPBACK);\r\nreturn err;\r\n}\r\nstatic int smctr_issue_write_byte_cmd(struct net_device *dev,\r\nshort aword_cnt, void *byte)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int iword, ibyte;\r\nint err;\r\nif((err = smctr_wait_while_cbusy(dev)))\r\nreturn err;\r\nif((err = smctr_wait_cmd(dev)))\r\nreturn err;\r\nfor(iword = 0, ibyte = 0; iword < (unsigned int)(aword_cnt & 0xff);\r\niword++, ibyte += 2)\r\n{\r\ntp->misc_command_data[iword] = (*((__u8 *)byte + ibyte) << 8)\r\n| (*((__u8 *)byte + ibyte + 1));\r\n}\r\nreturn smctr_setup_single_cmd_w_data(dev, ACB_CMD_MCT_WRITE_VALUE,\r\naword_cnt);\r\n}\r\nstatic int smctr_issue_write_word_cmd(struct net_device *dev,\r\nshort aword_cnt, void *word)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int i, err;\r\nif((err = smctr_wait_while_cbusy(dev)))\r\nreturn err;\r\nif((err = smctr_wait_cmd(dev)))\r\nreturn err;\r\nfor(i = 0; i < (unsigned int)(aword_cnt & 0xff); i++)\r\ntp->misc_command_data[i] = *((__u16 *)word + i);\r\nerr = smctr_setup_single_cmd_w_data(dev, ACB_CMD_MCT_WRITE_VALUE,\r\naword_cnt);\r\nreturn err;\r\n}\r\nstatic int smctr_join_complete_state(struct net_device *dev)\r\n{\r\nint err;\r\nerr = smctr_setup_single_cmd(dev, ACB_CMD_CHANGE_JOIN_STATE,\r\nJS_JOIN_COMPLETE_STATE);\r\nreturn err;\r\n}\r\nstatic int smctr_link_tx_fcbs_to_bdbs(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int i, j;\r\nFCBlock *fcb;\r\nBDBlock *bdb;\r\nfor(i = 0; i < NUM_TX_QS_USED; i++)\r\n{\r\nfcb = tp->tx_fcb_head[i];\r\nbdb = tp->tx_bdb_head[i];\r\nfor(j = 0; j < tp->num_tx_fcbs[i]; j++)\r\n{\r\nfcb->bdb_ptr = bdb;\r\nfcb->trc_bdb_ptr = TRC_POINTER(bdb);\r\nfcb = (FCBlock *)((char *)fcb + sizeof(FCBlock));\r\nbdb = (BDBlock *)((char *)bdb + sizeof(BDBlock));\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int smctr_load_firmware(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nconst struct firmware *fw;\r\n__u16 i, checksum = 0;\r\nint err = 0;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_load_firmware\n", dev->name);\r\nif (request_firmware(&fw, "tr_smctr.bin", &dev->dev)) {\r\nprintk(KERN_ERR "%s: firmware not found\n", dev->name);\r\nreturn UCODE_NOT_PRESENT;\r\n}\r\ntp->num_of_tx_buffs = 4;\r\ntp->mode_bits |= UMAC;\r\ntp->receive_mask = 0;\r\ntp->max_packet_size = 4177;\r\nif (tp->microcode_version != 0) {\r\nerr = (UCODE_PRESENT);\r\ngoto out;\r\n}\r\nif (!fw->data ||\r\n(*(fw->data + UCODE_VERSION_OFFSET) < UCODE_VERSION))\r\n{\r\nerr = (UCODE_NOT_PRESENT);\r\ngoto out;\r\n}\r\nfor(i = 0; i < *((__u16 *)(fw->data + UCODE_SIZE_OFFSET)); i += 2)\r\nchecksum += *((__u16 *)(fw->data + 2 + i));\r\nif (checksum) {\r\nerr = (UCODE_NOT_PRESENT);\r\ngoto out;\r\n}\r\nsmctr_enable_adapter_ram(dev);\r\nsmctr_enable_16bit(dev);\r\nsmctr_set_page(dev, (__u8 *)tp->ram_access);\r\nif((smctr_checksum_firmware(dev)) ||\r\n(*(fw->data + UCODE_VERSION_OFFSET) > tp->microcode_version))\r\n{\r\nsmctr_enable_adapter_ctrl_store(dev);\r\nfor(i = 0; i < CS_RAM_SIZE; i += 2)\r\n*((__u16 *)(tp->ram_access + i)) = 0;\r\nsmctr_decode_firmware(dev, fw);\r\ntp->microcode_version = *(fw->data + UCODE_VERSION_OFFSET); *((__u16 *)(tp->ram_access + CS_RAM_VERSION_OFFSET))\r\n= (tp->microcode_version << 8);\r\n*((__u16 *)(tp->ram_access + CS_RAM_CHECKSUM_OFFSET))\r\n= ~(tp->microcode_version << 8) + 1;\r\nsmctr_disable_adapter_ctrl_store(dev);\r\nif(smctr_checksum_firmware(dev))\r\nerr = HARDWARE_FAILED;\r\n}\r\nelse\r\nerr = UCODE_PRESENT;\r\nsmctr_disable_16bit(dev);\r\nout:\r\nrelease_firmware(fw);\r\nreturn err;\r\n}\r\nstatic int smctr_load_node_addr(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nunsigned int i;\r\n__u8 r;\r\nfor(i = 0; i < 6; i++)\r\n{\r\nr = inb(ioaddr + LAR0 + i);\r\ndev->dev_addr[i] = (char)r;\r\n}\r\ndev->addr_len = 6;\r\nreturn 0;\r\n}\r\nstatic int smctr_lobe_media_test(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int i, perror = 0;\r\nunsigned short saved_rcv_mask;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_lobe_media_test\n", dev->name);\r\nsaved_rcv_mask = tp->receive_mask;\r\ntp->receive_mask = 0;\r\nsmctr_chg_rx_mask(dev);\r\nsmctr_lobe_media_test_cmd(dev);\r\nif(smctr_wait_cmd(dev))\r\ngoto err;\r\nfor(i = 0; i < 1500; ++i)\r\n{\r\nif(smctr_send_lobe_media_test(dev))\r\n{\r\nif(perror)\r\ngoto err;\r\nelse\r\n{\r\nperror = 1;\r\nif(smctr_lobe_media_test_cmd(dev))\r\ngoto err;\r\n}\r\n}\r\n}\r\nif(smctr_send_dat(dev))\r\n{\r\nif(smctr_send_dat(dev))\r\ngoto err;\r\n}\r\nif((tp->rx_fcb_curr[MAC_QUEUE]->frame_status) ||\r\n(tp->rx_fcb_curr[NON_MAC_QUEUE]->frame_status))\r\ngoto err;\r\ntp->receive_mask = saved_rcv_mask;\r\nsmctr_chg_rx_mask(dev);\r\nreturn 0;\r\nerr:\r\nsmctr_reset_adapter(dev);\r\ntp->status = CLOSED;\r\nreturn LOBE_MEDIA_TEST_FAILED;\r\n}\r\nstatic int smctr_lobe_media_test_cmd(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint err;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_lobe_media_test_cmd\n", dev->name);\r\nif(tp->monitor_state != MS_BEACON_TEST_STATE)\r\n{\r\nsmctr_lobe_media_test_state(dev);\r\nif(smctr_wait_cmd(dev))\r\n{\r\nprintk(KERN_ERR "Lobe Failed test state\n");\r\nreturn LOBE_MEDIA_TEST_FAILED;\r\n}\r\n}\r\nerr = smctr_setup_single_cmd(dev, ACB_CMD_MCT_TEST,\r\nTRC_LOBE_MEDIA_TEST);\r\nreturn err;\r\n}\r\nstatic int smctr_lobe_media_test_state(struct net_device *dev)\r\n{\r\nint err;\r\nerr = smctr_setup_single_cmd(dev, ACB_CMD_CHANGE_JOIN_STATE,\r\nJS_LOBE_TEST_STATE);\r\nreturn err;\r\n}\r\nstatic int smctr_make_8025_hdr(struct net_device *dev,\r\nMAC_HEADER *rmf, MAC_HEADER *tmf, __u16 ac_fc)\r\n{\r\ntmf->ac = MSB(ac_fc);\r\ntmf->fc = LSB(ac_fc);\r\ntmf->sa[0] = dev->dev_addr[0];\r\ntmf->sa[1] = dev->dev_addr[1];\r\ntmf->sa[2] = dev->dev_addr[2];\r\ntmf->sa[3] = dev->dev_addr[3];\r\ntmf->sa[4] = dev->dev_addr[4];\r\ntmf->sa[5] = dev->dev_addr[5];\r\nswitch(tmf->vc)\r\n{\r\ncase RQ_INIT:\r\ntmf->da[0] = 0xc0;\r\ntmf->da[1] = 0x00;\r\ntmf->da[2] = 0x00;\r\ntmf->da[3] = 0x00;\r\ntmf->da[4] = 0x00;\r\ntmf->da[5] = 0x02;\r\nbreak;\r\ncase RPT_TX_FORWARD:\r\ntmf->da[0] = 0xc0;\r\ntmf->da[1] = 0x00;\r\ntmf->da[2] = 0x00;\r\ntmf->da[3] = 0x00;\r\ntmf->da[4] = 0x00;\r\ntmf->da[5] = 0x10;\r\nbreak;\r\ndefault:\r\ntmf->da[0] = rmf->sa[0];\r\ntmf->da[1] = rmf->sa[1];\r\ntmf->da[2] = rmf->sa[2];\r\ntmf->da[3] = rmf->sa[3];\r\ntmf->da[4] = rmf->sa[4];\r\ntmf->da[5] = rmf->sa[5];\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smctr_make_access_pri(struct net_device *dev, MAC_SUB_VECTOR *tsv)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\ntsv->svi = AUTHORIZED_ACCESS_PRIORITY;\r\ntsv->svl = S_AUTHORIZED_ACCESS_PRIORITY;\r\ntsv->svv[0] = MSB(tp->authorized_access_priority);\r\ntsv->svv[1] = LSB(tp->authorized_access_priority);\r\nreturn 0;\r\n}\r\nstatic int smctr_make_addr_mod(struct net_device *dev, MAC_SUB_VECTOR *tsv)\r\n{\r\ntsv->svi = ADDRESS_MODIFER;\r\ntsv->svl = S_ADDRESS_MODIFER;\r\ntsv->svv[0] = 0;\r\ntsv->svv[1] = 0;\r\nreturn 0;\r\n}\r\nstatic int smctr_make_auth_funct_class(struct net_device *dev,\r\nMAC_SUB_VECTOR *tsv)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\ntsv->svi = AUTHORIZED_FUNCTION_CLASS;\r\ntsv->svl = S_AUTHORIZED_FUNCTION_CLASS;\r\ntsv->svv[0] = MSB(tp->authorized_function_classes);\r\ntsv->svv[1] = LSB(tp->authorized_function_classes);\r\nreturn 0;\r\n}\r\nstatic int smctr_make_corr(struct net_device *dev,\r\nMAC_SUB_VECTOR *tsv, __u16 correlator)\r\n{\r\ntsv->svi = CORRELATOR;\r\ntsv->svl = S_CORRELATOR;\r\ntsv->svv[0] = MSB(correlator);\r\ntsv->svv[1] = LSB(correlator);\r\nreturn 0;\r\n}\r\nstatic int smctr_make_funct_addr(struct net_device *dev, MAC_SUB_VECTOR *tsv)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nsmctr_get_functional_address(dev);\r\ntsv->svi = FUNCTIONAL_ADDRESS;\r\ntsv->svl = S_FUNCTIONAL_ADDRESS;\r\ntsv->svv[0] = MSB(tp->misc_command_data[0]);\r\ntsv->svv[1] = LSB(tp->misc_command_data[0]);\r\ntsv->svv[2] = MSB(tp->misc_command_data[1]);\r\ntsv->svv[3] = LSB(tp->misc_command_data[1]);\r\nreturn 0;\r\n}\r\nstatic int smctr_make_group_addr(struct net_device *dev, MAC_SUB_VECTOR *tsv)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nsmctr_get_group_address(dev);\r\ntsv->svi = GROUP_ADDRESS;\r\ntsv->svl = S_GROUP_ADDRESS;\r\ntsv->svv[0] = MSB(tp->misc_command_data[0]);\r\ntsv->svv[1] = LSB(tp->misc_command_data[0]);\r\ntsv->svv[2] = MSB(tp->misc_command_data[1]);\r\ntsv->svv[3] = LSB(tp->misc_command_data[1]);\r\nif(tsv->svv[0] == 0x80 && tsv->svv[1] == 0x00 &&\r\ntsv->svv[2] == 0x00 && tsv->svv[3] == 0x00)\r\ntsv->svv[0] = 0x00;\r\nreturn 0;\r\n}\r\nstatic int smctr_make_phy_drop_num(struct net_device *dev,\r\nMAC_SUB_VECTOR *tsv)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nsmctr_get_physical_drop_number(dev);\r\ntsv->svi = PHYSICAL_DROP;\r\ntsv->svl = S_PHYSICAL_DROP;\r\ntsv->svv[0] = MSB(tp->misc_command_data[0]);\r\ntsv->svv[1] = LSB(tp->misc_command_data[0]);\r\ntsv->svv[2] = MSB(tp->misc_command_data[1]);\r\ntsv->svv[3] = LSB(tp->misc_command_data[1]);\r\nreturn 0;\r\n}\r\nstatic int smctr_make_product_id(struct net_device *dev, MAC_SUB_VECTOR *tsv)\r\n{\r\nint i;\r\ntsv->svi = PRODUCT_INSTANCE_ID;\r\ntsv->svl = S_PRODUCT_INSTANCE_ID;\r\nfor(i = 0; i < 18; i++)\r\ntsv->svv[i] = 0xF0;\r\nreturn 0;\r\n}\r\nstatic int smctr_make_station_id(struct net_device *dev, MAC_SUB_VECTOR *tsv)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nsmctr_get_station_id(dev);\r\ntsv->svi = STATION_IDENTIFER;\r\ntsv->svl = S_STATION_IDENTIFER;\r\ntsv->svv[0] = MSB(tp->misc_command_data[0]);\r\ntsv->svv[1] = LSB(tp->misc_command_data[0]);\r\ntsv->svv[2] = MSB(tp->misc_command_data[1]);\r\ntsv->svv[3] = LSB(tp->misc_command_data[1]);\r\ntsv->svv[4] = MSB(tp->misc_command_data[2]);\r\ntsv->svv[5] = LSB(tp->misc_command_data[2]);\r\nreturn 0;\r\n}\r\nstatic int smctr_make_ring_station_status(struct net_device *dev,\r\nMAC_SUB_VECTOR * tsv)\r\n{\r\ntsv->svi = RING_STATION_STATUS;\r\ntsv->svl = S_RING_STATION_STATUS;\r\ntsv->svv[0] = 0;\r\ntsv->svv[1] = 0;\r\ntsv->svv[2] = 0;\r\ntsv->svv[3] = 0;\r\ntsv->svv[4] = 0;\r\ntsv->svv[5] = 0;\r\nreturn 0;\r\n}\r\nstatic int smctr_make_ring_station_version(struct net_device *dev,\r\nMAC_SUB_VECTOR *tsv)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\ntsv->svi = RING_STATION_VERSION_NUMBER;\r\ntsv->svl = S_RING_STATION_VERSION_NUMBER;\r\ntsv->svv[0] = 0xe2;\r\ntsv->svv[1] = 0xd4;\r\ntsv->svv[2] = 0xc3;\r\ntsv->svv[3] = 0x40;\r\ntsv->svv[4] = 0xe5;\r\ntsv->svv[5] = 0xF0 + (tp->microcode_version >> 4);\r\ntsv->svv[6] = 0xF0 + (tp->microcode_version & 0x0f);\r\ntsv->svv[7] = 0x40;\r\ntsv->svv[8] = 0xe7;\r\nif(tp->extra_info & CHIP_REV_MASK)\r\ntsv->svv[9] = 0xc5;\r\nelse\r\ntsv->svv[9] = 0xc4;\r\nreturn 0;\r\n}\r\nstatic int smctr_make_tx_status_code(struct net_device *dev,\r\nMAC_SUB_VECTOR *tsv, __u16 tx_fstatus)\r\n{\r\ntsv->svi = TRANSMIT_STATUS_CODE;\r\ntsv->svl = S_TRANSMIT_STATUS_CODE;\r\ntsv->svv[0] = ((tx_fstatus & 0x0100 >> 6) | IBM_PASS_SOURCE_ADDR);\r\ntsv->svv[1] = tx_fstatus & 0xff;\r\nreturn 0;\r\n}\r\nstatic int smctr_make_upstream_neighbor_addr(struct net_device *dev,\r\nMAC_SUB_VECTOR *tsv)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nsmctr_get_upstream_neighbor_addr(dev);\r\ntsv->svi = UPSTREAM_NEIGHBOR_ADDRESS;\r\ntsv->svl = S_UPSTREAM_NEIGHBOR_ADDRESS;\r\ntsv->svv[0] = MSB(tp->misc_command_data[0]);\r\ntsv->svv[1] = LSB(tp->misc_command_data[0]);\r\ntsv->svv[2] = MSB(tp->misc_command_data[1]);\r\ntsv->svv[3] = LSB(tp->misc_command_data[1]);\r\ntsv->svv[4] = MSB(tp->misc_command_data[2]);\r\ntsv->svv[5] = LSB(tp->misc_command_data[2]);\r\nreturn 0;\r\n}\r\nstatic int smctr_make_wrap_data(struct net_device *dev, MAC_SUB_VECTOR *tsv)\r\n{\r\ntsv->svi = WRAP_DATA;\r\ntsv->svl = S_WRAP_DATA;\r\nreturn 0;\r\n}\r\nstatic int smctr_open(struct net_device *dev)\r\n{\r\nint err;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_open\n", dev->name);\r\nerr = smctr_init_adapter(dev);\r\nif(err < 0)\r\nreturn err;\r\nreturn err;\r\n}\r\nstatic int smctr_open_tr(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned long flags;\r\nint err;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_open_tr\n", dev->name);\r\nif(tp->status == OPEN)\r\nreturn 0;\r\nif(tp->status != INITIALIZED)\r\nreturn -1;\r\nspin_lock_irqsave(&tp->lock, flags);\r\nsmctr_set_page(dev, (__u8 *)tp->ram_access);\r\nif((err = smctr_issue_resume_rx_fcb_cmd(dev, (short)MAC_QUEUE)))\r\ngoto out;\r\nif((err = smctr_issue_resume_rx_bdb_cmd(dev, (short)MAC_QUEUE)))\r\ngoto out;\r\nif((err = smctr_issue_resume_rx_fcb_cmd(dev, (short)NON_MAC_QUEUE)))\r\ngoto out;\r\nif((err = smctr_issue_resume_rx_bdb_cmd(dev, (short)NON_MAC_QUEUE)))\r\ngoto out;\r\ntp->status = CLOSED;\r\nif((tp->mode_bits & LOOPING_MODE_MASK) == LOOPBACK_MODE_1)\r\n{\r\ntp->status = CLOSED;\r\nif(!(err = smctr_issue_trc_loopback_cmd(dev)))\r\n{\r\nif(!(err = smctr_wait_cmd(dev)))\r\ntp->status = OPEN;\r\n}\r\nsmctr_status_chg(dev);\r\n}\r\nelse\r\n{\r\nif((tp->mode_bits & LOOPING_MODE_MASK) == LOOPBACK_MODE_2)\r\n{\r\ntp->status = CLOSED;\r\nif(!(err = smctr_issue_tri_loopback_cmd(dev)))\r\n{\r\nif(!(err = smctr_wait_cmd(dev)))\r\ntp->status = OPEN;\r\n}\r\nsmctr_status_chg(dev);\r\n}\r\nelse\r\n{\r\nif((tp->mode_bits & LOOPING_MODE_MASK)\r\n== LOOPBACK_MODE_3)\r\n{\r\ntp->status = CLOSED;\r\nif(!(err = smctr_lobe_media_test_cmd(dev)))\r\n{\r\nif(!(err = smctr_wait_cmd(dev)))\r\ntp->status = OPEN;\r\n}\r\nsmctr_status_chg(dev);\r\n}\r\nelse\r\n{\r\nif(!(err = smctr_lobe_media_test(dev)))\r\nerr = smctr_issue_insert_cmd(dev);\r\nelse\r\n{\r\nif(err == LOBE_MEDIA_TEST_FAILED)\r\nprintk(KERN_WARNING "%s: Lobe Media Test Failure - Check cable?\n", dev->name);\r\n}\r\n}\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&tp->lock, flags);\r\nreturn err;\r\n}\r\nstruct net_device __init *smctr_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_trdev(sizeof(struct net_local));\r\nstatic const unsigned ports[] = {\r\n0x200, 0x220, 0x240, 0x260, 0x280, 0x2A0, 0x2C0, 0x2E0, 0x300,\r\n0x320, 0x340, 0x360, 0x380, 0\r\n};\r\nconst unsigned *port;\r\nint err = 0;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (unit >= 0) {\r\nsprintf(dev->name, "tr%d", unit);\r\nnetdev_boot_setup_check(dev);\r\n}\r\nif (dev->base_addr > 0x1ff)\r\nerr = smctr_probe1(dev, dev->base_addr);\r\nelse if(dev->base_addr != 0)\r\nerr =-ENXIO;\r\nelse {\r\nfor (port = ports; *port; port++) {\r\nerr = smctr_probe1(dev, *port);\r\nif (!err)\r\nbreak;\r\n}\r\n}\r\nif (err)\r\ngoto out;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out1;\r\nreturn dev;\r\nout1:\r\n#ifdef CONFIG_MCA_LEGACY\r\n{ struct net_local *tp = netdev_priv(dev);\r\nif (tp->slot_num)\r\nmca_mark_as_unused(tp->slot_num);\r\n}\r\n#endif\r\nrelease_region(dev->base_addr, SMCTR_IO_EXTENT);\r\nfree_irq(dev->irq, dev);\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init smctr_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nstatic unsigned version_printed;\r\nstruct net_local *tp = netdev_priv(dev);\r\nint err;\r\n__u32 *ram;\r\nif(smctr_debug && version_printed++ == 0)\r\nprintk(version);\r\nspin_lock_init(&tp->lock);\r\ndev->base_addr = ioaddr;\r\nerr = smctr_chk_isa(dev);\r\nif(err < 0)\r\n{\r\nif ((err = smctr_chk_mca(dev)) < 0) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\n}\r\ntp = netdev_priv(dev);\r\ndev->mem_start = tp->ram_base;\r\ndev->mem_end = dev->mem_start + 0x10000;\r\nram = (__u32 *)phys_to_virt(dev->mem_start);\r\ntp->ram_access = *(__u32 *)&ram;\r\ntp->status = NOT_INITIALIZED;\r\nerr = smctr_load_firmware(dev);\r\nif(err != UCODE_PRESENT && err != SUCCESS)\r\n{\r\nprintk(KERN_ERR "%s: Firmware load failed (%d)\n", dev->name, err);\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nif(ringspeed == 4)\r\ntp->media_type = MEDIA_UTP_4;\r\nelse\r\ntp->media_type = MEDIA_UTP_16;\r\nprintk(KERN_INFO "%s: %s %s at Io %#4x, Irq %d, Rom %#4x, Ram %#4x.\n",\r\ndev->name, smctr_name, smctr_model,\r\n(unsigned int)dev->base_addr,\r\ndev->irq, tp->rom_base, tp->ram_base);\r\ndev->netdev_ops = &smctr_netdev_ops;\r\ndev->watchdog_timeo = HZ;\r\nreturn 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int smctr_process_rx_packet(MAC_HEADER *rmf, __u16 size,\r\nstruct net_device *dev, __u16 rx_status)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\n__u16 rcode, correlator;\r\nint err = 0;\r\n__u8 xframe = 1;\r\nrmf->vl = SWAP_BYTES(rmf->vl);\r\nif(rx_status & FCB_RX_STATUS_DA_MATCHED)\r\n{\r\nswitch(rmf->vc)\r\n{\r\ncase INIT:\r\nif((rcode = smctr_rcv_init(dev, rmf, &correlator)) == HARDWARE_FAILED)\r\n{\r\nreturn rcode;\r\n}\r\nif((err = smctr_send_rsp(dev, rmf, rcode,\r\ncorrelator)))\r\n{\r\nreturn err;\r\n}\r\nbreak;\r\ncase CHG_PARM:\r\nif((rcode = smctr_rcv_chg_param(dev, rmf,\r\n&correlator)) ==HARDWARE_FAILED)\r\n{\r\nreturn rcode;\r\n}\r\nif((err = smctr_send_rsp(dev, rmf, rcode,\r\ncorrelator)))\r\n{\r\nreturn err;\r\n}\r\nbreak;\r\ncase RQ_ADDR:\r\nif((rcode = smctr_rcv_rq_addr_state_attch(dev,\r\nrmf, &correlator)) != POSITIVE_ACK)\r\n{\r\nif(rcode == HARDWARE_FAILED)\r\nreturn rcode;\r\nelse\r\nreturn smctr_send_rsp(dev, rmf,\r\nrcode, correlator);\r\n}\r\nif((err = smctr_send_rpt_addr(dev, rmf,\r\ncorrelator)))\r\n{\r\nreturn err;\r\n}\r\nbreak;\r\ncase RQ_ATTCH:\r\nif((rcode = smctr_rcv_rq_addr_state_attch(dev,\r\nrmf, &correlator)) != POSITIVE_ACK)\r\n{\r\nif(rcode == HARDWARE_FAILED)\r\nreturn rcode;\r\nelse\r\nreturn smctr_send_rsp(dev, rmf,\r\nrcode,\r\ncorrelator);\r\n}\r\nif((err = smctr_send_rpt_attch(dev, rmf,\r\ncorrelator)))\r\n{\r\nreturn err;\r\n}\r\nbreak;\r\ncase RQ_STATE:\r\nif((rcode = smctr_rcv_rq_addr_state_attch(dev,\r\nrmf, &correlator)) != POSITIVE_ACK)\r\n{\r\nif(rcode == HARDWARE_FAILED)\r\nreturn rcode;\r\nelse\r\nreturn smctr_send_rsp(dev, rmf,\r\nrcode,\r\ncorrelator);\r\n}\r\nif((err = smctr_send_rpt_state(dev, rmf,\r\ncorrelator)))\r\n{\r\nreturn err;\r\n}\r\nbreak;\r\ncase TX_FORWARD: {\r\n__u16 uninitialized_var(tx_fstatus);\r\nif((rcode = smctr_rcv_tx_forward(dev, rmf))\r\n!= POSITIVE_ACK)\r\n{\r\nif(rcode == HARDWARE_FAILED)\r\nreturn rcode;\r\nelse\r\nreturn smctr_send_rsp(dev, rmf,\r\nrcode,\r\ncorrelator);\r\n}\r\nif((err = smctr_send_tx_forward(dev, rmf,\r\n&tx_fstatus)) == HARDWARE_FAILED)\r\n{\r\nreturn err;\r\n}\r\nif(err == A_FRAME_WAS_FORWARDED)\r\n{\r\nif((err = smctr_send_rpt_tx_forward(dev,\r\nrmf, tx_fstatus))\r\n== HARDWARE_FAILED)\r\n{\r\nreturn err;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase RSP:\r\ncase RQ_INIT:\r\ncase RPT_NEW_MON:\r\ncase RPT_SUA_CHG:\r\ncase RPT_ACTIVE_ERR:\r\ncase RPT_NN_INCMP:\r\ncase RPT_ERROR:\r\ncase RPT_ATTCH:\r\ncase RPT_STATE:\r\ncase RPT_ADDR:\r\nbreak;\r\ndefault:\r\nxframe = 0;\r\nif(!(tp->receive_mask & ACCEPT_ATT_MAC_FRAMES))\r\n{\r\nrcode = smctr_rcv_unknown(dev, rmf,\r\n&correlator);\r\nif((err = smctr_send_rsp(dev, rmf,rcode,\r\ncorrelator)))\r\n{\r\nreturn err;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nelse\r\n{\r\nswitch(rmf->vc)\r\n{\r\ncase RSP:\r\ncase INIT:\r\ncase RQ_INIT:\r\ncase RQ_ADDR:\r\ncase RQ_ATTCH:\r\ncase RQ_STATE:\r\ncase CHG_PARM:\r\ncase RPT_ADDR:\r\ncase RPT_ERROR:\r\ncase RPT_ATTCH:\r\ncase RPT_STATE:\r\ncase RPT_NEW_MON:\r\ncase RPT_SUA_CHG:\r\ncase RPT_NN_INCMP:\r\ncase RPT_ACTIVE_ERR:\r\nbreak;\r\ndefault:\r\nxframe = 0;\r\nbreak;\r\n}\r\n}\r\nif(((tp->receive_mask & ACCEPT_ATT_MAC_FRAMES) &&\r\n(xframe == (__u8)0)) ||\r\n((tp->receive_mask & ACCEPT_EXT_MAC_FRAMES) &&\r\n(xframe == (__u8)1)))\r\n{\r\nrmf->vl = SWAP_BYTES(rmf->vl);\r\nif (!(skb = dev_alloc_skb(size)))\r\nreturn -ENOMEM;\r\nskb->len = size;\r\nskb_put(skb, skb->len);\r\nskb_copy_to_linear_data(skb, rmf, skb->len);\r\ntp->MacStat.rx_packets++;\r\ntp->MacStat.rx_bytes += skb->len;\r\nskb->protocol = tr_type_trans(skb, dev);\r\nnetif_rx(skb);\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int smctr_ram_memory_test(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\n__u16 page, pages_of_ram, start_pattern = 0, word_pattern = 0,\r\nword_read = 0, err_word = 0, err_pattern = 0;\r\nunsigned int err_offset;\r\n__u32 j, pword;\r\n__u8 err = 0;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_ram_memory_test\n", dev->name);\r\nstart_pattern = 0x0001;\r\npages_of_ram = tp->ram_size / tp->ram_usable;\r\npword = tp->ram_access;\r\nfor(page = 0; (page < pages_of_ram) && (~err);\r\npage++, start_pattern += 0x8000)\r\n{\r\nsmctr_set_page(dev, (__u8 *)(tp->ram_access\r\n+ (page * tp->ram_usable * 1024) + 1));\r\nword_pattern = start_pattern;\r\nfor(j = 1; j < (__u32)(tp->ram_usable * 1024) - 1; j += 2)\r\n*(__u16 *)(pword + j) = word_pattern++;\r\nword_pattern = start_pattern;\r\nfor(j = 1; j < (__u32)(tp->ram_usable * 1024) - 1 && (~err);\r\nj += 2, word_pattern++)\r\n{\r\nword_read = *(__u16 *)(pword + j);\r\nif(word_read != word_pattern)\r\n{\r\nerr = (__u8)1;\r\nerr_offset = j;\r\nerr_word = word_read;\r\nerr_pattern = word_pattern;\r\nreturn RAM_TEST_FAILED;\r\n}\r\n}\r\n}\r\nfor(page = 0; page < pages_of_ram && (~err); page++)\r\n{\r\nsmctr_set_page(dev, (__u8 *)(tp->ram_access\r\n+ (page * tp->ram_usable * 1024)));\r\nword_pattern = 0;\r\nfor(j = 0; j < (__u32)tp->ram_usable * 1024; j +=2)\r\n*(__u16 *)(pword + j) = word_pattern;\r\nfor(j =0; j < (__u32)tp->ram_usable * 1024 && (~err); j += 2)\r\n{\r\nword_read = *(__u16 *)(pword + j);\r\nif(word_read != word_pattern)\r\n{\r\nerr = (__u8)1;\r\nerr_offset = j;\r\nerr_word = word_read;\r\nerr_pattern = word_pattern;\r\nreturn RAM_TEST_FAILED;\r\n}\r\n}\r\n}\r\nsmctr_set_page(dev, (__u8 *)tp->ram_access);\r\nreturn 0;\r\n}\r\nstatic int smctr_rcv_chg_param(struct net_device *dev, MAC_HEADER *rmf,\r\n__u16 *correlator)\r\n{\r\nMAC_SUB_VECTOR *rsv;\r\nsigned short vlen;\r\n__u16 rcode = POSITIVE_ACK;\r\nunsigned int svectors = F_NO_SUB_VECTORS_FOUND;\r\nif((rmf->dc_sc & SC_MASK) != SC_CRS)\r\nreturn E_INAPPROPRIATE_SOURCE_CLASS;\r\nvlen = (signed short)rmf->vl - 4;\r\nrsv = (MAC_SUB_VECTOR *)((__u32)rmf + sizeof(MAC_HEADER));\r\nwhile((vlen > 0) && (rcode == POSITIVE_ACK))\r\n{\r\nswitch(rsv->svi)\r\n{\r\ncase CORRELATOR:\r\nsvectors |= F_CORRELATOR;\r\nrcode = smctr_set_corr(dev, rsv, correlator);\r\nbreak;\r\ncase LOCAL_RING_NUMBER:\r\nsvectors |= F_LOCAL_RING_NUMBER;\r\nrcode = smctr_set_local_ring_num(dev, rsv);\r\nbreak;\r\ncase ASSIGN_PHYSICAL_DROP:\r\nsvectors |= F_ASSIGN_PHYSICAL_DROP;\r\nrcode = smctr_set_phy_drop(dev, rsv);\r\nbreak;\r\ncase ERROR_TIMER_VALUE:\r\nsvectors |= F_ERROR_TIMER_VALUE;\r\nrcode = smctr_set_error_timer_value(dev, rsv);\r\nbreak;\r\ncase AUTHORIZED_FUNCTION_CLASS:\r\nsvectors |= F_AUTHORIZED_FUNCTION_CLASS;\r\nrcode = smctr_set_auth_funct_class(dev, rsv);\r\nbreak;\r\ncase AUTHORIZED_ACCESS_PRIORITY:\r\nsvectors |= F_AUTHORIZED_ACCESS_PRIORITY;\r\nrcode = smctr_set_auth_access_pri(dev, rsv);\r\nbreak;\r\ndefault:\r\nrcode = E_SUB_VECTOR_UNKNOWN;\r\nbreak;\r\n}\r\nif((vlen -= rsv->svl) < 0)\r\nrcode = E_VECTOR_LENGTH_ERROR;\r\nrsv = (MAC_SUB_VECTOR *)((__u32)rsv + rsv->svl);\r\n}\r\nif(rcode == POSITIVE_ACK)\r\n{\r\nif(vlen != 0)\r\nrcode = E_VECTOR_LENGTH_ERROR;\r\nelse\r\n{\r\nif((svectors & R_CHG_PARM) ^ R_CHG_PARM)\r\nrcode = E_MISSING_SUB_VECTOR;\r\n}\r\n}\r\nreturn rcode;\r\n}\r\nstatic int smctr_rcv_init(struct net_device *dev, MAC_HEADER *rmf,\r\n__u16 *correlator)\r\n{\r\nMAC_SUB_VECTOR *rsv;\r\nsigned short vlen;\r\n__u16 rcode = POSITIVE_ACK;\r\nunsigned int svectors = F_NO_SUB_VECTORS_FOUND;\r\nif((rmf->dc_sc & SC_MASK) != SC_RPS)\r\nreturn E_INAPPROPRIATE_SOURCE_CLASS;\r\nvlen = (signed short)rmf->vl - 4;\r\nrsv = (MAC_SUB_VECTOR *)((__u32)rmf + sizeof(MAC_HEADER));\r\nwhile((vlen > 0) && (rcode == POSITIVE_ACK))\r\n{\r\nswitch(rsv->svi)\r\n{\r\ncase CORRELATOR:\r\nsvectors |= F_CORRELATOR;\r\nrcode = smctr_set_corr(dev, rsv, correlator);\r\nbreak;\r\ncase LOCAL_RING_NUMBER:\r\nsvectors |= F_LOCAL_RING_NUMBER;\r\nrcode = smctr_set_local_ring_num(dev, rsv);\r\nbreak;\r\ncase ASSIGN_PHYSICAL_DROP:\r\nsvectors |= F_ASSIGN_PHYSICAL_DROP;\r\nrcode = smctr_set_phy_drop(dev, rsv);\r\nbreak;\r\ncase ERROR_TIMER_VALUE:\r\nsvectors |= F_ERROR_TIMER_VALUE;\r\nrcode = smctr_set_error_timer_value(dev, rsv);\r\nbreak;\r\ndefault:\r\nrcode = E_SUB_VECTOR_UNKNOWN;\r\nbreak;\r\n}\r\nif((vlen -= rsv->svl) < 0)\r\nrcode = E_VECTOR_LENGTH_ERROR;\r\nrsv = (MAC_SUB_VECTOR *)((__u32)rsv + rsv->svl);\r\n}\r\nif(rcode == POSITIVE_ACK)\r\n{\r\nif(vlen != 0)\r\nrcode = E_VECTOR_LENGTH_ERROR;\r\nelse\r\n{\r\nif((svectors & R_INIT) ^ R_INIT)\r\nrcode = E_MISSING_SUB_VECTOR;\r\n}\r\n}\r\nreturn rcode;\r\n}\r\nstatic int smctr_rcv_tx_forward(struct net_device *dev, MAC_HEADER *rmf)\r\n{\r\nMAC_SUB_VECTOR *rsv;\r\nsigned short vlen;\r\n__u16 rcode = POSITIVE_ACK;\r\nunsigned int svectors = F_NO_SUB_VECTORS_FOUND;\r\nif((rmf->dc_sc & SC_MASK) != SC_CRS)\r\nreturn E_INAPPROPRIATE_SOURCE_CLASS;\r\nvlen = (signed short)rmf->vl - 4;\r\nrsv = (MAC_SUB_VECTOR *)((__u32)rmf + sizeof(MAC_HEADER));\r\nwhile((vlen > 0) && (rcode == POSITIVE_ACK))\r\n{\r\nswitch(rsv->svi)\r\n{\r\ncase FRAME_FORWARD:\r\nsvectors |= F_FRAME_FORWARD;\r\nrcode = smctr_set_frame_forward(dev, rsv,\r\nrmf->dc_sc);\r\nbreak;\r\ndefault:\r\nrcode = E_SUB_VECTOR_UNKNOWN;\r\nbreak;\r\n}\r\nif((vlen -= rsv->svl) < 0)\r\nrcode = E_VECTOR_LENGTH_ERROR;\r\nrsv = (MAC_SUB_VECTOR *)((__u32)rsv + rsv->svl);\r\n}\r\nif(rcode == POSITIVE_ACK)\r\n{\r\nif(vlen != 0)\r\nrcode = E_VECTOR_LENGTH_ERROR;\r\nelse\r\n{\r\nif((svectors & R_TX_FORWARD) ^ R_TX_FORWARD)\r\nrcode = E_MISSING_SUB_VECTOR;\r\n}\r\n}\r\nreturn rcode;\r\n}\r\nstatic int smctr_rcv_rq_addr_state_attch(struct net_device *dev,\r\nMAC_HEADER *rmf, __u16 *correlator)\r\n{\r\nMAC_SUB_VECTOR *rsv;\r\nsigned short vlen;\r\n__u16 rcode = POSITIVE_ACK;\r\nunsigned int svectors = F_NO_SUB_VECTORS_FOUND;\r\nvlen = (signed short)rmf->vl - 4;\r\nrsv = (MAC_SUB_VECTOR *)((__u32)rmf + sizeof(MAC_HEADER));\r\nwhile((vlen > 0) && (rcode == POSITIVE_ACK))\r\n{\r\nswitch(rsv->svi)\r\n{\r\ncase CORRELATOR:\r\nsvectors |= F_CORRELATOR;\r\nrcode = smctr_set_corr(dev, rsv, correlator);\r\nbreak;\r\ndefault:\r\nrcode = E_SUB_VECTOR_UNKNOWN;\r\nbreak;\r\n}\r\nif((vlen -= rsv->svl) < 0)\r\nrcode = E_VECTOR_LENGTH_ERROR;\r\nrsv = (MAC_SUB_VECTOR *)((__u32)rsv + rsv->svl);\r\n}\r\nif(rcode == POSITIVE_ACK)\r\n{\r\nif(vlen != 0)\r\nrcode = E_VECTOR_LENGTH_ERROR;\r\nelse\r\n{\r\nif((svectors & R_RQ_ATTCH_STATE_ADDR)\r\n^ R_RQ_ATTCH_STATE_ADDR)\r\nrcode = E_MISSING_SUB_VECTOR;\r\n}\r\n}\r\nreturn rcode;\r\n}\r\nstatic int smctr_rcv_unknown(struct net_device *dev, MAC_HEADER *rmf,\r\n__u16 *correlator)\r\n{\r\nMAC_SUB_VECTOR *rsv;\r\nsigned short vlen;\r\n*correlator = 0;\r\nvlen = (signed short)rmf->vl - 4;\r\nrsv = (MAC_SUB_VECTOR *)((__u32)rmf + sizeof(MAC_HEADER));\r\nwhile((vlen > 0) && (*correlator == 0))\r\n{\r\nswitch(rsv->svi)\r\n{\r\ncase CORRELATOR:\r\nsmctr_set_corr(dev, rsv, correlator);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nvlen -= rsv->svl;\r\nrsv = (MAC_SUB_VECTOR *)((__u32)rsv + rsv->svl);\r\n}\r\nreturn E_UNRECOGNIZED_VECTOR_ID;\r\n}\r\nstatic int smctr_reset_adapter(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nsmctr_set_trc_reset(ioaddr);\r\nmdelay(200);\r\nsmctr_clear_trc_reset(ioaddr);\r\nmdelay(200);\r\noutb(tp->trc_mask | CSR_CLRTINT | CSR_CLRCBUSY, ioaddr + CSR);\r\nreturn 0;\r\n}\r\nstatic int smctr_restart_tx_chain(struct net_device *dev, short queue)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint err = 0;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_restart_tx_chain\n", dev->name);\r\nif(tp->num_tx_fcbs_used[queue] != 0 &&\r\ntp->tx_queue_status[queue] == NOT_TRANSMITING)\r\n{\r\ntp->tx_queue_status[queue] = TRANSMITING;\r\nerr = smctr_issue_resume_tx_fcb_cmd(dev, queue);\r\n}\r\nreturn err;\r\n}\r\nstatic int smctr_ring_status_chg(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_ring_status_chg\n", dev->name);\r\nif(tp->ring_status_flags == MONITOR_STATE_CHANGED)\r\n{\r\nif((tp->monitor_state == MS_ACTIVE_MONITOR_STATE) ||\r\n(tp->monitor_state == MS_STANDBY_MONITOR_STATE))\r\n{\r\ntp->monitor_state_ready = 1;\r\n}\r\nelse\r\n{\r\ntp->monitor_state_ready = 0;\r\nif(tp->monitor_state == MS_MONITOR_FSM_INACTIVE &&\r\n!tp->cleanup)\r\n{\r\nprintk(KERN_INFO "%s: Incorrect ring speed switching.\n",\r\ndev->name);\r\nsmctr_set_ring_speed(dev);\r\n}\r\n}\r\n}\r\nif(!(tp->ring_status_flags & RING_STATUS_CHANGED))\r\nreturn 0;\r\nswitch(tp->ring_status)\r\n{\r\ncase RING_RECOVERY:\r\nprintk(KERN_INFO "%s: Ring Recovery\n", dev->name);\r\nbreak;\r\ncase SINGLE_STATION:\r\nprintk(KERN_INFO "%s: Single Statinon\n", dev->name);\r\nbreak;\r\ncase COUNTER_OVERFLOW:\r\nprintk(KERN_INFO "%s: Counter Overflow\n", dev->name);\r\nbreak;\r\ncase REMOVE_RECEIVED:\r\nprintk(KERN_INFO "%s: Remove Received\n", dev->name);\r\nbreak;\r\ncase AUTO_REMOVAL_ERROR:\r\nprintk(KERN_INFO "%s: Auto Remove Error\n", dev->name);\r\nbreak;\r\ncase LOBE_WIRE_FAULT:\r\nprintk(KERN_INFO "%s: Lobe Wire Fault\n", dev->name);\r\nbreak;\r\ncase TRANSMIT_BEACON:\r\nprintk(KERN_INFO "%s: Transmit Beacon\n", dev->name);\r\nbreak;\r\ncase SOFT_ERROR:\r\nprintk(KERN_INFO "%s: Soft Error\n", dev->name);\r\nbreak;\r\ncase HARD_ERROR:\r\nprintk(KERN_INFO "%s: Hard Error\n", dev->name);\r\nbreak;\r\ncase SIGNAL_LOSS:\r\nprintk(KERN_INFO "%s: Signal Loss\n", dev->name);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "%s: Unknown ring status change\n",\r\ndev->name);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smctr_rx_frame(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\n__u16 queue, status, rx_size, err = 0;\r\n__u8 *pbuff;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_rx_frame\n", dev->name);\r\nqueue = tp->receive_queue_number;\r\nwhile((status = tp->rx_fcb_curr[queue]->frame_status) != SUCCESS)\r\n{\r\nerr = HARDWARE_FAILED;\r\nif(((status & 0x007f) == 0) ||\r\n((tp->receive_mask & ACCEPT_ERR_PACKETS) != 0))\r\n{\r\nrx_size = tp->rx_fcb_curr[queue]->frame_length - 5;\r\npbuff = smctr_get_rx_pointer(dev, queue);\r\nsmctr_set_page(dev, pbuff);\r\nsmctr_disable_16bit(dev);\r\npbuff = (__u8 *)PAGE_POINTER(pbuff);\r\nif(queue == NON_MAC_QUEUE)\r\n{\r\nstruct sk_buff *skb;\r\nskb = dev_alloc_skb(rx_size);\r\nif (skb) {\r\nskb_put(skb, rx_size);\r\nskb_copy_to_linear_data(skb, pbuff, rx_size);\r\ntp->MacStat.rx_packets++;\r\ntp->MacStat.rx_bytes += skb->len;\r\nskb->protocol = tr_type_trans(skb, dev);\r\nnetif_rx(skb);\r\n} else {\r\n}\r\n}\r\nelse\r\nsmctr_process_rx_packet((MAC_HEADER *)pbuff,\r\nrx_size, dev, status);\r\n}\r\nsmctr_enable_16bit(dev);\r\nsmctr_set_page(dev, (__u8 *)tp->ram_access);\r\nsmctr_update_rx_chain(dev, queue);\r\nif(err != SUCCESS)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int smctr_send_dat(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int i, err;\r\nMAC_HEADER *tmf;\r\nFCBlock *fcb;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_send_dat\n", dev->name);\r\nif((fcb = smctr_get_tx_fcb(dev, MAC_QUEUE,\r\nsizeof(MAC_HEADER))) == (FCBlock *)(-1L))\r\n{\r\nreturn OUT_OF_RESOURCES;\r\n}\r\ntmf = (MAC_HEADER *)fcb->bdb_ptr->data_block_ptr;\r\ntmf->ac = MSB(AC_FC_DAT);\r\ntmf->fc = LSB(AC_FC_DAT);\r\nfor(i = 0; i < 6; i++)\r\n{\r\ntmf->sa[i] = dev->dev_addr[i];\r\ntmf->da[i] = dev->dev_addr[i];\r\n}\r\ntmf->vc = DAT;\r\ntmf->dc_sc = DC_RS | SC_RS;\r\ntmf->vl = 4;\r\ntmf->vl = SWAP_BYTES(tmf->vl);\r\nif((err = smctr_trc_send_packet(dev, fcb, MAC_QUEUE)))\r\nreturn err;\r\nfor(i = 0; i < 10000; i++)\r\n{\r\nif(fcb->frame_status & FCB_COMMAND_DONE)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif(!(fcb->frame_status & FCB_COMMAND_DONE) ||\r\nfcb->frame_status & (FCB_TX_STATUS_E | FCB_TX_AC_BITS))\r\n{\r\nreturn INITIALIZE_FAILED;\r\n}\r\ntp->tx_queue_status[MAC_QUEUE] = NOT_TRANSMITING;\r\nsmctr_update_tx_chain(dev, fcb, MAC_QUEUE);\r\nreturn 0;\r\n}\r\nstatic void smctr_timeout(struct net_device *dev)\r\n{\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t smctr_send_packet(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_send_packet\n", dev->name);\r\nnetif_stop_queue(dev);\r\nif(tp->QueueSkb == 0)\r\nreturn NETDEV_TX_BUSY;\r\ntp->QueueSkb--;\r\nskb_queue_tail(&tp->SendSkbQueue, skb);\r\nsmctr_hardware_send_packet(dev, tp);\r\nif(tp->QueueSkb > 0)\r\nnetif_wake_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int smctr_send_lobe_media_test(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nMAC_SUB_VECTOR *tsv;\r\nMAC_HEADER *tmf;\r\nFCBlock *fcb;\r\n__u32 i;\r\nint err;\r\nif(smctr_debug > 15)\r\nprintk(KERN_DEBUG "%s: smctr_send_lobe_media_test\n", dev->name);\r\nif((fcb = smctr_get_tx_fcb(dev, MAC_QUEUE, sizeof(struct trh_hdr)\r\n+ S_WRAP_DATA + S_WRAP_DATA)) == (FCBlock *)(-1L))\r\n{\r\nreturn OUT_OF_RESOURCES;\r\n}\r\ntmf = (MAC_HEADER *)fcb->bdb_ptr->data_block_ptr;\r\ntmf->ac = MSB(AC_FC_LOBE_MEDIA_TEST);\r\ntmf->fc = LSB(AC_FC_LOBE_MEDIA_TEST);\r\nfor(i = 0; i < 6; i++)\r\n{\r\ntmf->da[i] = 0;\r\ntmf->sa[i] = dev->dev_addr[i];\r\n}\r\ntmf->vc = LOBE_MEDIA_TEST;\r\ntmf->dc_sc = DC_RS | SC_RS;\r\ntmf->vl = 4;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tmf + sizeof(MAC_HEADER));\r\nsmctr_make_wrap_data(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tsv + tsv->svl);\r\nsmctr_make_wrap_data(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntmf->vl = SWAP_BYTES(tmf->vl);\r\nif((err = smctr_trc_send_packet(dev, fcb, MAC_QUEUE)))\r\nreturn err;\r\nfor(i=0; i < 10000; i++)\r\n{\r\nif(fcb->frame_status & FCB_COMMAND_DONE)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif(!(fcb->frame_status & FCB_COMMAND_DONE) ||\r\nfcb->frame_status & (FCB_TX_STATUS_E | FCB_TX_AC_BITS))\r\n{\r\nreturn LOBE_MEDIA_TEST_FAILED;\r\n}\r\ntp->tx_queue_status[MAC_QUEUE] = NOT_TRANSMITING;\r\nsmctr_update_tx_chain(dev, fcb, MAC_QUEUE);\r\nreturn 0;\r\n}\r\nstatic int smctr_send_rpt_addr(struct net_device *dev, MAC_HEADER *rmf,\r\n__u16 correlator)\r\n{\r\nMAC_HEADER *tmf;\r\nMAC_SUB_VECTOR *tsv;\r\nFCBlock *fcb;\r\nif((fcb = smctr_get_tx_fcb(dev, MAC_QUEUE, sizeof(MAC_HEADER)\r\n+ S_CORRELATOR + S_PHYSICAL_DROP + S_UPSTREAM_NEIGHBOR_ADDRESS\r\n+ S_ADDRESS_MODIFER + S_GROUP_ADDRESS + S_FUNCTIONAL_ADDRESS))\r\n== (FCBlock *)(-1L))\r\n{\r\nreturn 0;\r\n}\r\ntmf = (MAC_HEADER *)fcb->bdb_ptr->data_block_ptr;\r\ntmf->vc = RPT_ADDR;\r\ntmf->dc_sc = (rmf->dc_sc & SC_MASK) << 4;\r\ntmf->vl = 4;\r\nsmctr_make_8025_hdr(dev, rmf, tmf, AC_FC_RPT_ADDR);\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tmf + sizeof(MAC_HEADER));\r\nsmctr_make_corr(dev, tsv, correlator);\r\ntmf->vl += tsv->svl;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tsv + tsv->svl);\r\nsmctr_make_phy_drop_num(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tsv + tsv->svl);\r\nsmctr_make_upstream_neighbor_addr(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tsv + tsv->svl);\r\nsmctr_make_addr_mod(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tsv + tsv->svl);\r\nsmctr_make_group_addr(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tsv + tsv->svl);\r\nsmctr_make_funct_addr(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntmf->vl = SWAP_BYTES(tmf->vl);\r\nreturn smctr_trc_send_packet(dev, fcb, MAC_QUEUE);\r\n}\r\nstatic int smctr_send_rpt_attch(struct net_device *dev, MAC_HEADER *rmf,\r\n__u16 correlator)\r\n{\r\nMAC_HEADER *tmf;\r\nMAC_SUB_VECTOR *tsv;\r\nFCBlock *fcb;\r\nif((fcb = smctr_get_tx_fcb(dev, MAC_QUEUE, sizeof(MAC_HEADER)\r\n+ S_CORRELATOR + S_PRODUCT_INSTANCE_ID + S_FUNCTIONAL_ADDRESS\r\n+ S_AUTHORIZED_FUNCTION_CLASS + S_AUTHORIZED_ACCESS_PRIORITY))\r\n== (FCBlock *)(-1L))\r\n{\r\nreturn 0;\r\n}\r\ntmf = (MAC_HEADER *)fcb->bdb_ptr->data_block_ptr;\r\ntmf->vc = RPT_ATTCH;\r\ntmf->dc_sc = (rmf->dc_sc & SC_MASK) << 4;\r\ntmf->vl = 4;\r\nsmctr_make_8025_hdr(dev, rmf, tmf, AC_FC_RPT_ATTCH);\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tmf + sizeof(MAC_HEADER));\r\nsmctr_make_corr(dev, tsv, correlator);\r\ntmf->vl += tsv->svl;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tsv + tsv->svl);\r\nsmctr_make_product_id(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tsv + tsv->svl);\r\nsmctr_make_funct_addr(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tsv + tsv->svl);\r\nsmctr_make_auth_funct_class(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tsv + tsv->svl);\r\nsmctr_make_access_pri(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntmf->vl = SWAP_BYTES(tmf->vl);\r\nreturn smctr_trc_send_packet(dev, fcb, MAC_QUEUE);\r\n}\r\nstatic int smctr_send_rpt_state(struct net_device *dev, MAC_HEADER *rmf,\r\n__u16 correlator)\r\n{\r\nMAC_HEADER *tmf;\r\nMAC_SUB_VECTOR *tsv;\r\nFCBlock *fcb;\r\nif((fcb = smctr_get_tx_fcb(dev, MAC_QUEUE, sizeof(MAC_HEADER)\r\n+ S_CORRELATOR + S_RING_STATION_VERSION_NUMBER\r\n+ S_RING_STATION_STATUS + S_STATION_IDENTIFER))\r\n== (FCBlock *)(-1L))\r\n{\r\nreturn 0;\r\n}\r\ntmf = (MAC_HEADER *)fcb->bdb_ptr->data_block_ptr;\r\ntmf->vc = RPT_STATE;\r\ntmf->dc_sc = (rmf->dc_sc & SC_MASK) << 4;\r\ntmf->vl = 4;\r\nsmctr_make_8025_hdr(dev, rmf, tmf, AC_FC_RPT_STATE);\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tmf + sizeof(MAC_HEADER));\r\nsmctr_make_corr(dev, tsv, correlator);\r\ntmf->vl += tsv->svl;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tsv + tsv->svl);\r\nsmctr_make_ring_station_version(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tsv + tsv->svl);\r\nsmctr_make_ring_station_status(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tsv + tsv->svl);\r\nsmctr_make_station_id(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntmf->vl = SWAP_BYTES(tmf->vl);\r\nreturn smctr_trc_send_packet(dev, fcb, MAC_QUEUE);\r\n}\r\nstatic int smctr_send_rpt_tx_forward(struct net_device *dev,\r\nMAC_HEADER *rmf, __u16 tx_fstatus)\r\n{\r\nMAC_HEADER *tmf;\r\nMAC_SUB_VECTOR *tsv;\r\nFCBlock *fcb;\r\nif((fcb = smctr_get_tx_fcb(dev, MAC_QUEUE, sizeof(MAC_HEADER)\r\n+ S_TRANSMIT_STATUS_CODE)) == (FCBlock *)(-1L))\r\n{\r\nreturn 0;\r\n}\r\ntmf = (MAC_HEADER *)fcb->bdb_ptr->data_block_ptr;\r\ntmf->vc = RPT_TX_FORWARD;\r\ntmf->dc_sc = (rmf->dc_sc & SC_MASK) << 4;\r\ntmf->vl = 4;\r\nsmctr_make_8025_hdr(dev, rmf, tmf, AC_FC_RPT_TX_FORWARD);\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tmf + sizeof(MAC_HEADER));\r\nsmctr_make_tx_status_code(dev, tsv, tx_fstatus);\r\ntmf->vl += tsv->svl;\r\ntmf->vl = SWAP_BYTES(tmf->vl);\r\nreturn smctr_trc_send_packet(dev, fcb, MAC_QUEUE);\r\n}\r\nstatic int smctr_send_rsp(struct net_device *dev, MAC_HEADER *rmf,\r\n__u16 rcode, __u16 correlator)\r\n{\r\nMAC_HEADER *tmf;\r\nMAC_SUB_VECTOR *tsv;\r\nFCBlock *fcb;\r\nif((fcb = smctr_get_tx_fcb(dev, MAC_QUEUE, sizeof(MAC_HEADER)\r\n+ S_CORRELATOR + S_RESPONSE_CODE)) == (FCBlock *)(-1L))\r\n{\r\nreturn 0;\r\n}\r\ntmf = (MAC_HEADER *)fcb->bdb_ptr->data_block_ptr;\r\ntmf->vc = RSP;\r\ntmf->dc_sc = (rmf->dc_sc & SC_MASK) << 4;\r\ntmf->vl = 4;\r\nsmctr_make_8025_hdr(dev, rmf, tmf, AC_FC_RSP);\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tmf + sizeof(MAC_HEADER));\r\nsmctr_make_corr(dev, tsv, correlator);\r\nreturn 0;\r\n}\r\nstatic int smctr_send_rq_init(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nMAC_HEADER *tmf;\r\nMAC_SUB_VECTOR *tsv;\r\nFCBlock *fcb;\r\nunsigned int i, count = 0;\r\n__u16 fstatus;\r\nint err;\r\ndo {\r\nif(((fcb = smctr_get_tx_fcb(dev, MAC_QUEUE, sizeof(MAC_HEADER)\r\n+ S_PRODUCT_INSTANCE_ID + S_UPSTREAM_NEIGHBOR_ADDRESS\r\n+ S_RING_STATION_VERSION_NUMBER + S_ADDRESS_MODIFER))\r\n== (FCBlock *)(-1L)))\r\n{\r\nreturn 0;\r\n}\r\ntmf = (MAC_HEADER *)fcb->bdb_ptr->data_block_ptr;\r\ntmf->vc = RQ_INIT;\r\ntmf->dc_sc = DC_RPS | SC_RS;\r\ntmf->vl = 4;\r\nsmctr_make_8025_hdr(dev, NULL, tmf, AC_FC_RQ_INIT);\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tmf + sizeof(MAC_HEADER));\r\nsmctr_make_product_id(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tsv + tsv->svl);\r\nsmctr_make_upstream_neighbor_addr(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tsv + tsv->svl);\r\nsmctr_make_ring_station_version(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntsv = (MAC_SUB_VECTOR *)((__u32)tsv + tsv->svl);\r\nsmctr_make_addr_mod(dev, tsv);\r\ntmf->vl += tsv->svl;\r\ntmf->vl = SWAP_BYTES(tmf->vl);\r\nif((err = smctr_trc_send_packet(dev, fcb, MAC_QUEUE)))\r\nreturn err;\r\nfor(i = 0; i < 10000; i++)\r\n{\r\nif(fcb->frame_status & FCB_COMMAND_DONE)\r\nbreak;\r\nmdelay(1);\r\n}\r\nfstatus = fcb->frame_status;\r\nif(!(fstatus & FCB_COMMAND_DONE))\r\nreturn HARDWARE_FAILED;\r\nif(!(fstatus & FCB_TX_STATUS_E))\r\ncount++;\r\ntp->tx_queue_status[MAC_QUEUE] = NOT_TRANSMITING;\r\nsmctr_update_tx_chain(dev, fcb, MAC_QUEUE);\r\n} while(count < 4 && ((fstatus & FCB_TX_AC_BITS) ^ FCB_TX_AC_BITS));\r\nreturn smctr_join_complete_state(dev);\r\n}\r\nstatic int smctr_send_tx_forward(struct net_device *dev, MAC_HEADER *rmf,\r\n__u16 *tx_fstatus)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nFCBlock *fcb;\r\nunsigned int i;\r\nint err;\r\nif(rmf->vl <= 18)\r\nreturn 0;\r\nif((fcb = smctr_get_tx_fcb(dev, MAC_QUEUE, 0)) == (FCBlock *)(-1L))\r\nreturn 0;\r\nfcb->bdb_ptr->trc_data_block_ptr = TRC_POINTER((__u32)rmf\r\n+ sizeof(MAC_HEADER) + 2);\r\nfcb->bdb_ptr->data_block_ptr = (__u16 *)((__u32)rmf\r\n+ sizeof(MAC_HEADER) + 2);\r\nfcb->frame_length = rmf->vl - 4 - 2;\r\nfcb->bdb_ptr->buffer_length = rmf->vl - 4 - 2;\r\nif((err = smctr_trc_send_packet(dev, fcb, MAC_QUEUE)))\r\nreturn err;\r\nfor(i = 0; i < 10000; i++)\r\n{\r\nif(fcb->frame_status & FCB_COMMAND_DONE)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif(!(fcb->frame_status & FCB_COMMAND_DONE))\r\n{\r\nif((err = smctr_issue_resume_tx_fcb_cmd(dev, MAC_QUEUE)))\r\nreturn err;\r\nfor(i = 0; i < 10000; i++)\r\n{\r\nif(fcb->frame_status & FCB_COMMAND_DONE)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif(!(fcb->frame_status & FCB_COMMAND_DONE))\r\nreturn HARDWARE_FAILED;\r\n}\r\n*tx_fstatus = fcb->frame_status;\r\nreturn A_FRAME_WAS_FORWARDED;\r\n}\r\nstatic int smctr_set_auth_access_pri(struct net_device *dev,\r\nMAC_SUB_VECTOR *rsv)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nif(rsv->svl != S_AUTHORIZED_ACCESS_PRIORITY)\r\nreturn E_SUB_VECTOR_LENGTH_ERROR;\r\ntp->authorized_access_priority = (rsv->svv[0] << 8 | rsv->svv[1]);\r\nreturn POSITIVE_ACK;\r\n}\r\nstatic int smctr_set_auth_funct_class(struct net_device *dev,\r\nMAC_SUB_VECTOR *rsv)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nif(rsv->svl != S_AUTHORIZED_FUNCTION_CLASS)\r\nreturn E_SUB_VECTOR_LENGTH_ERROR;\r\ntp->authorized_function_classes = (rsv->svv[0] << 8 | rsv->svv[1]);\r\nreturn POSITIVE_ACK;\r\n}\r\nstatic int smctr_set_corr(struct net_device *dev, MAC_SUB_VECTOR *rsv,\r\n__u16 *correlator)\r\n{\r\nif(rsv->svl != S_CORRELATOR)\r\nreturn E_SUB_VECTOR_LENGTH_ERROR;\r\n*correlator = (rsv->svv[0] << 8 | rsv->svv[1]);\r\nreturn POSITIVE_ACK;\r\n}\r\nstatic int smctr_set_error_timer_value(struct net_device *dev,\r\nMAC_SUB_VECTOR *rsv)\r\n{\r\n__u16 err_tval;\r\nint err;\r\nif(rsv->svl != S_ERROR_TIMER_VALUE)\r\nreturn E_SUB_VECTOR_LENGTH_ERROR;\r\nerr_tval = (rsv->svv[0] << 8 | rsv->svv[1])*10;\r\nsmctr_issue_write_word_cmd(dev, RW_TER_THRESHOLD, &err_tval);\r\nif((err = smctr_wait_cmd(dev)))\r\nreturn err;\r\nreturn POSITIVE_ACK;\r\n}\r\nstatic int smctr_set_frame_forward(struct net_device *dev,\r\nMAC_SUB_VECTOR *rsv, __u8 dc_sc)\r\n{\r\nif((rsv->svl < 2) || (rsv->svl > S_FRAME_FORWARD))\r\nreturn E_SUB_VECTOR_LENGTH_ERROR;\r\nif((dc_sc & DC_MASK) != DC_CRS)\r\n{\r\nif(rsv->svl >= 2 && rsv->svl < 20)\r\nreturn E_TRANSMIT_FORWARD_INVALID;\r\nif((rsv->svv[0] != 0) || (rsv->svv[1] != 0))\r\nreturn E_TRANSMIT_FORWARD_INVALID;\r\n}\r\nreturn POSITIVE_ACK;\r\n}\r\nstatic int smctr_set_local_ring_num(struct net_device *dev,\r\nMAC_SUB_VECTOR *rsv)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nif(rsv->svl != S_LOCAL_RING_NUMBER)\r\nreturn E_SUB_VECTOR_LENGTH_ERROR;\r\nif(tp->ptr_local_ring_num)\r\n*(__u16 *)(tp->ptr_local_ring_num)\r\n= (rsv->svv[0] << 8 | rsv->svv[1]);\r\nreturn POSITIVE_ACK;\r\n}\r\nstatic unsigned short smctr_set_ctrl_attention(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nif(tp->bic_type == BIC_585_CHIP)\r\noutb((tp->trc_mask | HWR_CA), ioaddr + HWR);\r\nelse\r\n{\r\noutb((tp->trc_mask | CSR_CA), ioaddr + CSR);\r\noutb(tp->trc_mask, ioaddr + CSR);\r\n}\r\nreturn 0;\r\n}\r\nstatic void smctr_set_multicast_list(struct net_device *dev)\r\n{\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_set_multicast_list\n", dev->name);\r\n}\r\nstatic int smctr_set_page(struct net_device *dev, __u8 *buf)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\n__u8 amask;\r\n__u32 tptr;\r\ntptr = (__u32)buf - (__u32)tp->ram_access;\r\namask = (__u8)((tptr & PR_PAGE_MASK) >> 8);\r\noutb(amask, dev->base_addr + PR);\r\nreturn 0;\r\n}\r\nstatic int smctr_set_phy_drop(struct net_device *dev, MAC_SUB_VECTOR *rsv)\r\n{\r\nint err;\r\nif(rsv->svl != S_PHYSICAL_DROP)\r\nreturn E_SUB_VECTOR_LENGTH_ERROR;\r\nsmctr_issue_write_byte_cmd(dev, RW_PHYSICAL_DROP_NUMBER, &rsv->svv[0]);\r\nif((err = smctr_wait_cmd(dev)))\r\nreturn err;\r\nreturn POSITIVE_ACK;\r\n}\r\nstatic int smctr_set_ring_speed(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint err;\r\nif(tp->media_type == MEDIA_UTP_16)\r\ntp->media_type = MEDIA_UTP_4;\r\nelse\r\ntp->media_type = MEDIA_UTP_16;\r\nsmctr_enable_16bit(dev);\r\nsmctr_reset_adapter(dev);\r\nif((err = smctr_init_card_real(dev)))\r\nreturn err;\r\nsmctr_enable_bic_int(dev);\r\nif((err = smctr_issue_enable_int_cmd(dev, TRC_INTERRUPT_ENABLE_MASK)))\r\nreturn err;\r\nsmctr_disable_16bit(dev);\r\nreturn 0;\r\n}\r\nstatic int smctr_set_rx_look_ahead(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\n__u16 sword, rword;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_set_rx_look_ahead_flag\n", dev->name);\r\ntp->adapter_flags &= ~(FORCED_16BIT_MODE);\r\ntp->adapter_flags |= RX_VALID_LOOKAHEAD;\r\nif(tp->adapter_bus == BUS_ISA16_TYPE)\r\n{\r\nsword = *((__u16 *)(tp->ram_access));\r\n*((__u16 *)(tp->ram_access)) = 0x1234;\r\nsmctr_disable_16bit(dev);\r\nrword = *((__u16 *)(tp->ram_access));\r\nsmctr_enable_16bit(dev);\r\nif(rword != 0x1234)\r\ntp->adapter_flags |= FORCED_16BIT_MODE;\r\n*((__u16 *)(tp->ram_access)) = sword;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smctr_set_trc_reset(int ioaddr)\r\n{\r\n__u8 r;\r\nr = inb(ioaddr + MSR);\r\noutb(MSR_RST | r, ioaddr + MSR);\r\nreturn 0;\r\n}\r\nstatic int smctr_setup_single_cmd(struct net_device *dev,\r\n__u16 command, __u16 subcommand)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int err;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_setup_single_cmd\n", dev->name);\r\nif((err = smctr_wait_while_cbusy(dev)))\r\nreturn err;\r\nif((err = (unsigned int)smctr_wait_cmd(dev)))\r\nreturn err;\r\ntp->acb_head->cmd_done_status = 0;\r\ntp->acb_head->cmd = command;\r\ntp->acb_head->subcmd = subcommand;\r\nerr = smctr_issue_resume_acb_cmd(dev);\r\nreturn err;\r\n}\r\nstatic int smctr_setup_single_cmd_w_data(struct net_device *dev,\r\n__u16 command, __u16 subcommand)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\ntp->acb_head->cmd_done_status = ACB_COMMAND_NOT_DONE;\r\ntp->acb_head->cmd = command;\r\ntp->acb_head->subcmd = subcommand;\r\ntp->acb_head->data_offset_lo\r\n= (__u16)TRC_POINTER(tp->misc_command_data);\r\nreturn smctr_issue_resume_acb_cmd(dev);\r\n}\r\nstatic char *smctr_malloc(struct net_device *dev, __u16 size)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nchar *m;\r\nm = (char *)(tp->ram_access + tp->sh_mem_used);\r\ntp->sh_mem_used += (__u32)size;\r\nreturn m;\r\n}\r\nstatic int smctr_status_chg(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_status_chg\n", dev->name);\r\nswitch(tp->status)\r\n{\r\ncase OPEN:\r\nbreak;\r\ncase CLOSED:\r\nbreak;\r\ncase INITIALIZED:\r\ntp->group_address_0 = 0;\r\ntp->group_address[0] = 0;\r\ntp->group_address[1] = 0;\r\ntp->functional_address_0 = 0;\r\ntp->functional_address[0] = 0;\r\ntp->functional_address[1] = 0;\r\nsmctr_open_tr(dev);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "%s: status change unknown %x\n",\r\ndev->name, tp->status);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smctr_trc_send_packet(struct net_device *dev, FCBlock *fcb,\r\n__u16 queue)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nint err = 0;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_trc_send_packet\n", dev->name);\r\nfcb->info = FCB_CHAIN_END | FCB_ENABLE_TFS;\r\nif(tp->num_tx_fcbs[queue] != 1)\r\nfcb->back_ptr->info = FCB_INTERRUPT_ENABLE | FCB_ENABLE_TFS;\r\nif(tp->tx_queue_status[queue] == NOT_TRANSMITING)\r\n{\r\ntp->tx_queue_status[queue] = TRANSMITING;\r\nerr = smctr_issue_resume_tx_fcb_cmd(dev, queue);\r\n}\r\nreturn err;\r\n}\r\nstatic __u16 smctr_tx_complete(struct net_device *dev, __u16 queue)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\n__u16 status, err = 0;\r\nint cstatus;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_tx_complete\n", dev->name);\r\nwhile((status = tp->tx_fcb_end[queue]->frame_status) != SUCCESS)\r\n{\r\nif(status & 0x7e00 )\r\n{\r\nerr = HARDWARE_FAILED;\r\nbreak;\r\n}\r\nif((err = smctr_update_tx_chain(dev, tp->tx_fcb_end[queue],\r\nqueue)) != SUCCESS)\r\nbreak;\r\nsmctr_disable_16bit(dev);\r\nif(tp->mode_bits & UMAC)\r\n{\r\nif(!(status & (FCB_TX_STATUS_AR1 | FCB_TX_STATUS_AR2)))\r\ncstatus = NO_SUCH_DESTINATION;\r\nelse\r\n{\r\nif(!(status & (FCB_TX_STATUS_CR1 | FCB_TX_STATUS_CR2)))\r\ncstatus = DEST_OUT_OF_RESOURCES;\r\nelse\r\n{\r\nif(status & FCB_TX_STATUS_E)\r\ncstatus = MAX_COLLISIONS;\r\nelse\r\ncstatus = SUCCESS;\r\n}\r\n}\r\n}\r\nelse\r\ncstatus = SUCCESS;\r\nif(queue == BUG_QUEUE)\r\nerr = SUCCESS;\r\nsmctr_enable_16bit(dev);\r\nif(err != SUCCESS)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic unsigned short smctr_tx_move_frame(struct net_device *dev,\r\nstruct sk_buff *skb, __u8 *pbuff, unsigned int bytes)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int ram_usable;\r\n__u32 flen, len, offset = 0;\r\n__u8 *frag, *page;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_tx_move_frame\n", dev->name);\r\nram_usable = ((unsigned int)tp->ram_usable) << 10;\r\nfrag = skb->data;\r\nflen = skb->len;\r\nwhile(flen > 0 && bytes > 0)\r\n{\r\nsmctr_set_page(dev, pbuff);\r\noffset = SMC_PAGE_OFFSET(pbuff);\r\nif(offset + flen > ram_usable)\r\nlen = ram_usable - offset;\r\nelse\r\nlen = flen;\r\nif(len > bytes)\r\nlen = bytes;\r\npage = (char *) (offset + tp->ram_access);\r\nmemcpy(page, frag, len);\r\nflen -=len;\r\nbytes -= len;\r\nfrag += len;\r\npbuff += len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smctr_update_err_stats(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nstruct tr_statistics *tstat = &tp->MacStat;\r\nif(tstat->internal_errors)\r\ntstat->internal_errors\r\n+= *(tp->misc_command_data + 0) & 0x00ff;\r\nif(tstat->line_errors)\r\ntstat->line_errors += *(tp->misc_command_data + 0) >> 8;\r\nif(tstat->A_C_errors)\r\ntstat->A_C_errors += *(tp->misc_command_data + 1) & 0x00ff;\r\nif(tstat->burst_errors)\r\ntstat->burst_errors += *(tp->misc_command_data + 1) >> 8;\r\nif(tstat->abort_delimiters)\r\ntstat->abort_delimiters += *(tp->misc_command_data + 2) >> 8;\r\nif(tstat->recv_congest_count)\r\ntstat->recv_congest_count\r\n+= *(tp->misc_command_data + 3) & 0x00ff;\r\nif(tstat->lost_frames)\r\ntstat->lost_frames\r\n+= *(tp->misc_command_data + 3) >> 8;\r\nif(tstat->frequency_errors)\r\ntstat->frequency_errors += *(tp->misc_command_data + 4) & 0x00ff;\r\nif(tstat->frame_copied_errors)\r\ntstat->frame_copied_errors\r\n+= *(tp->misc_command_data + 4) >> 8;\r\nif(tstat->token_errors)\r\ntstat->token_errors += *(tp->misc_command_data + 5) >> 8;\r\nreturn 0;\r\n}\r\nstatic int smctr_update_rx_chain(struct net_device *dev, __u16 queue)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nFCBlock *fcb;\r\nBDBlock *bdb;\r\n__u16 size, len;\r\nfcb = tp->rx_fcb_curr[queue];\r\nlen = fcb->frame_length;\r\nfcb->frame_status = 0;\r\nfcb->info = FCB_CHAIN_END;\r\nfcb->back_ptr->info = FCB_WARNING;\r\ntp->rx_fcb_curr[queue] = tp->rx_fcb_curr[queue]->next_ptr;\r\nsize = (len >> RX_BDB_SIZE_SHIFT);\r\nif(len & RX_DATA_BUFFER_SIZE_MASK)\r\nsize += sizeof(BDBlock);\r\nsize &= (~RX_BDB_SIZE_MASK);\r\nbdb = (BDBlock *)((__u32)(tp->rx_bdb_curr[queue]) + (__u32)(size));\r\nif((__u32)bdb >= (__u32)tp->rx_bdb_end[queue])\r\n{\r\nbdb = (BDBlock *)((__u32)(tp->rx_bdb_head[queue])\r\n+ (__u32)(bdb) - (__u32)(tp->rx_bdb_end[queue]));\r\n}\r\nbdb->back_ptr->info = BDB_CHAIN_END;\r\ntp->rx_bdb_curr[queue]->back_ptr->info = BDB_NOT_CHAIN_END;\r\ntp->rx_bdb_curr[queue] = bdb;\r\nreturn 0;\r\n}\r\nstatic int smctr_update_tx_chain(struct net_device *dev, FCBlock *fcb,\r\n__u16 queue)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nif(smctr_debug > 20)\r\nprintk(KERN_DEBUG "smctr_update_tx_chain\n");\r\nif(tp->num_tx_fcbs_used[queue] <= 0)\r\nreturn HARDWARE_FAILED;\r\nelse\r\n{\r\nif(tp->tx_buff_used[queue] < fcb->memory_alloc)\r\n{\r\ntp->tx_buff_used[queue] = 0;\r\nreturn HARDWARE_FAILED;\r\n}\r\ntp->tx_buff_used[queue] -= fcb->memory_alloc;\r\nif(tp->tx_buff_used[queue] == 0)\r\ntp->tx_buff_curr[queue] = tp->tx_buff_head[queue];\r\ntp->num_tx_fcbs_used[queue]--;\r\nfcb->frame_status = 0;\r\ntp->tx_fcb_end[queue] = fcb->next_ptr;\r\nnetif_wake_queue(dev);\r\nreturn 0;\r\n}\r\n}\r\nstatic int smctr_wait_cmd(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int loop_count = 0x20000;\r\nif(smctr_debug > 10)\r\nprintk(KERN_DEBUG "%s: smctr_wait_cmd\n", dev->name);\r\nwhile(loop_count)\r\n{\r\nif(tp->acb_head->cmd_done_status & ACB_COMMAND_DONE)\r\nbreak;\r\nudelay(1);\r\nloop_count--;\r\n}\r\nif(loop_count == 0)\r\nreturn HARDWARE_FAILED;\r\nif(tp->acb_head->cmd_done_status & 0xff)\r\nreturn HARDWARE_FAILED;\r\nreturn 0;\r\n}\r\nstatic int smctr_wait_while_cbusy(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned int timeout = 0x20000;\r\nint ioaddr = dev->base_addr;\r\n__u8 r;\r\nif(tp->bic_type == BIC_585_CHIP)\r\n{\r\nwhile(timeout)\r\n{\r\nr = inb(ioaddr + HWR);\r\nif((r & HWR_CBUSY) == 0)\r\nbreak;\r\ntimeout--;\r\n}\r\n}\r\nelse\r\n{\r\nwhile(timeout)\r\n{\r\nr = inb(ioaddr + CSR);\r\nif((r & CSR_CBUSY) == 0)\r\nbreak;\r\ntimeout--;\r\n}\r\n}\r\nif(timeout)\r\nreturn 0;\r\nelse\r\nreturn HARDWARE_FAILED;\r\n}\r\nstatic struct net_device * __init setup_card(int n)\r\n{\r\nstruct net_device *dev = alloc_trdev(sizeof(struct net_local));\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\ndev->irq = irq[n];\r\nerr = smctr_probe1(dev, io[n]);\r\nif (err)\r\ngoto out;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out1;\r\nreturn dev;\r\nout1:\r\n#ifdef CONFIG_MCA_LEGACY\r\n{ struct net_local *tp = netdev_priv(dev);\r\nif (tp->slot_num)\r\nmca_mark_as_unused(tp->slot_num);\r\n}\r\n#endif\r\nrelease_region(dev->base_addr, SMCTR_IO_EXTENT);\r\nfree_irq(dev->irq, dev);\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nint __init init_module(void)\r\n{\r\nint i, found = 0;\r\nstruct net_device *dev;\r\nfor(i = 0; i < SMCTR_MAX_ADAPTERS; i++) {\r\ndev = io[0]? setup_card(i) : smctr_probe(-1);\r\nif (!IS_ERR(dev)) {\r\n++found;\r\ndev_smctr[i] = dev;\r\n}\r\n}\r\nreturn found ? 0 : -ENODEV;\r\n}\r\nvoid __exit cleanup_module(void)\r\n{\r\nint i;\r\nfor(i = 0; i < SMCTR_MAX_ADAPTERS; i++) {\r\nstruct net_device *dev = dev_smctr[i];\r\nif (dev) {\r\nunregister_netdev(dev);\r\n#ifdef CONFIG_MCA_LEGACY\r\n{ struct net_local *tp = netdev_priv(dev);\r\nif (tp->slot_num)\r\nmca_mark_as_unused(tp->slot_num);\r\n}\r\n#endif\r\nrelease_region(dev->base_addr, SMCTR_IO_EXTENT);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}
