static void rpc_register_client(struct rpc_clnt *clnt)\r\n{\r\nspin_lock(&rpc_client_lock);\r\nlist_add(&clnt->cl_clients, &all_clients);\r\nspin_unlock(&rpc_client_lock);\r\n}\r\nstatic void rpc_unregister_client(struct rpc_clnt *clnt)\r\n{\r\nspin_lock(&rpc_client_lock);\r\nlist_del(&clnt->cl_clients);\r\nspin_unlock(&rpc_client_lock);\r\n}\r\nstatic int\r\nrpc_setup_pipedir(struct rpc_clnt *clnt, char *dir_name)\r\n{\r\nstatic uint32_t clntid;\r\nstruct path path, dir;\r\nchar name[15];\r\nstruct qstr q = {\r\n.name = name,\r\n};\r\nint error;\r\nclnt->cl_path.mnt = ERR_PTR(-ENOENT);\r\nclnt->cl_path.dentry = ERR_PTR(-ENOENT);\r\nif (dir_name == NULL)\r\nreturn 0;\r\npath.mnt = rpc_get_mount();\r\nif (IS_ERR(path.mnt))\r\nreturn PTR_ERR(path.mnt);\r\nerror = vfs_path_lookup(path.mnt->mnt_root, path.mnt, dir_name, 0, &dir);\r\nif (error)\r\ngoto err;\r\nfor (;;) {\r\nq.len = snprintf(name, sizeof(name), "clnt%x", (unsigned int)clntid++);\r\nname[sizeof(name) - 1] = '\0';\r\nq.hash = full_name_hash(q.name, q.len);\r\npath.dentry = rpc_create_client_dir(dir.dentry, &q, clnt);\r\nif (!IS_ERR(path.dentry))\r\nbreak;\r\nerror = PTR_ERR(path.dentry);\r\nif (error != -EEXIST) {\r\nprintk(KERN_INFO "RPC: Couldn't create pipefs entry"\r\n" %s/%s, error %d\n",\r\ndir_name, name, error);\r\ngoto err_path_put;\r\n}\r\n}\r\npath_put(&dir);\r\nclnt->cl_path = path;\r\nreturn 0;\r\nerr_path_put:\r\npath_put(&dir);\r\nerr:\r\nrpc_put_mount();\r\nreturn error;\r\n}\r\nstatic struct rpc_clnt * rpc_new_client(const struct rpc_create_args *args, struct rpc_xprt *xprt)\r\n{\r\nstruct rpc_program *program = args->program;\r\nstruct rpc_version *version;\r\nstruct rpc_clnt *clnt = NULL;\r\nstruct rpc_auth *auth;\r\nint err;\r\nsize_t len;\r\nerr = -EINVAL;\r\nlen = strlen(args->servername);\r\nif (len > RPC_MAXNETNAMELEN)\r\ngoto out_no_rpciod;\r\nlen++;\r\ndprintk("RPC: creating %s client for %s (xprt %p)\n",\r\nprogram->name, args->servername, xprt);\r\nerr = rpciod_up();\r\nif (err)\r\ngoto out_no_rpciod;\r\nerr = -EINVAL;\r\nif (!xprt)\r\ngoto out_no_xprt;\r\nif (args->version >= program->nrvers)\r\ngoto out_err;\r\nversion = program->version[args->version];\r\nif (version == NULL)\r\ngoto out_err;\r\nerr = -ENOMEM;\r\nclnt = kzalloc(sizeof(*clnt), GFP_KERNEL);\r\nif (!clnt)\r\ngoto out_err;\r\nclnt->cl_parent = clnt;\r\nclnt->cl_server = clnt->cl_inline_name;\r\nif (len > sizeof(clnt->cl_inline_name)) {\r\nchar *buf = kmalloc(len, GFP_KERNEL);\r\nif (buf != NULL)\r\nclnt->cl_server = buf;\r\nelse\r\nlen = sizeof(clnt->cl_inline_name);\r\n}\r\nstrlcpy(clnt->cl_server, args->servername, len);\r\nclnt->cl_xprt = xprt;\r\nclnt->cl_procinfo = version->procs;\r\nclnt->cl_maxproc = version->nrprocs;\r\nclnt->cl_protname = program->name;\r\nclnt->cl_prog = args->prognumber ? : program->number;\r\nclnt->cl_vers = version->number;\r\nclnt->cl_stats = program->stats;\r\nclnt->cl_metrics = rpc_alloc_iostats(clnt);\r\nerr = -ENOMEM;\r\nif (clnt->cl_metrics == NULL)\r\ngoto out_no_stats;\r\nclnt->cl_program = program;\r\nINIT_LIST_HEAD(&clnt->cl_tasks);\r\nspin_lock_init(&clnt->cl_lock);\r\nif (!xprt_bound(clnt->cl_xprt))\r\nclnt->cl_autobind = 1;\r\nclnt->cl_timeout = xprt->timeout;\r\nif (args->timeout != NULL) {\r\nmemcpy(&clnt->cl_timeout_default, args->timeout,\r\nsizeof(clnt->cl_timeout_default));\r\nclnt->cl_timeout = &clnt->cl_timeout_default;\r\n}\r\nclnt->cl_rtt = &clnt->cl_rtt_default;\r\nrpc_init_rtt(&clnt->cl_rtt_default, clnt->cl_timeout->to_initval);\r\nclnt->cl_principal = NULL;\r\nif (args->client_name) {\r\nclnt->cl_principal = kstrdup(args->client_name, GFP_KERNEL);\r\nif (!clnt->cl_principal)\r\ngoto out_no_principal;\r\n}\r\natomic_set(&clnt->cl_count, 1);\r\nerr = rpc_setup_pipedir(clnt, program->pipe_dir_name);\r\nif (err < 0)\r\ngoto out_no_path;\r\nauth = rpcauth_create(args->authflavor, clnt);\r\nif (IS_ERR(auth)) {\r\nprintk(KERN_INFO "RPC: Couldn't create auth handle (flavor %u)\n",\r\nargs->authflavor);\r\nerr = PTR_ERR(auth);\r\ngoto out_no_auth;\r\n}\r\nclnt->cl_nodelen = strlen(init_utsname()->nodename);\r\nif (clnt->cl_nodelen > UNX_MAXNODENAME)\r\nclnt->cl_nodelen = UNX_MAXNODENAME;\r\nmemcpy(clnt->cl_nodename, init_utsname()->nodename, clnt->cl_nodelen);\r\nrpc_register_client(clnt);\r\nreturn clnt;\r\nout_no_auth:\r\nif (!IS_ERR(clnt->cl_path.dentry)) {\r\nrpc_remove_client_dir(clnt->cl_path.dentry);\r\nrpc_put_mount();\r\n}\r\nout_no_path:\r\nkfree(clnt->cl_principal);\r\nout_no_principal:\r\nrpc_free_iostats(clnt->cl_metrics);\r\nout_no_stats:\r\nif (clnt->cl_server != clnt->cl_inline_name)\r\nkfree(clnt->cl_server);\r\nkfree(clnt);\r\nout_err:\r\nxprt_put(xprt);\r\nout_no_xprt:\r\nrpciod_down();\r\nout_no_rpciod:\r\nreturn ERR_PTR(err);\r\n}\r\nstruct rpc_clnt *rpc_create(struct rpc_create_args *args)\r\n{\r\nstruct rpc_xprt *xprt;\r\nstruct rpc_clnt *clnt;\r\nstruct xprt_create xprtargs = {\r\n.net = args->net,\r\n.ident = args->protocol,\r\n.srcaddr = args->saddress,\r\n.dstaddr = args->address,\r\n.addrlen = args->addrsize,\r\n.bc_xprt = args->bc_xprt,\r\n};\r\nchar servername[48];\r\nif (args->servername == NULL) {\r\nstruct sockaddr_un *sun =\r\n(struct sockaddr_un *)args->address;\r\nstruct sockaddr_in *sin =\r\n(struct sockaddr_in *)args->address;\r\nstruct sockaddr_in6 *sin6 =\r\n(struct sockaddr_in6 *)args->address;\r\nservername[0] = '\0';\r\nswitch (args->address->sa_family) {\r\ncase AF_LOCAL:\r\nsnprintf(servername, sizeof(servername), "%s",\r\nsun->sun_path);\r\nbreak;\r\ncase AF_INET:\r\nsnprintf(servername, sizeof(servername), "%pI4",\r\n&sin->sin_addr.s_addr);\r\nbreak;\r\ncase AF_INET6:\r\nsnprintf(servername, sizeof(servername), "%pI6",\r\n&sin6->sin6_addr);\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nargs->servername = servername;\r\n}\r\nxprt = xprt_create_transport(&xprtargs);\r\nif (IS_ERR(xprt))\r\nreturn (struct rpc_clnt *)xprt;\r\nxprt->resvport = 1;\r\nif (args->flags & RPC_CLNT_CREATE_NONPRIVPORT)\r\nxprt->resvport = 0;\r\nclnt = rpc_new_client(args, xprt);\r\nif (IS_ERR(clnt))\r\nreturn clnt;\r\nif (!(args->flags & RPC_CLNT_CREATE_NOPING)) {\r\nint err = rpc_ping(clnt);\r\nif (err != 0) {\r\nrpc_shutdown_client(clnt);\r\nreturn ERR_PTR(err);\r\n}\r\n}\r\nclnt->cl_softrtry = 1;\r\nif (args->flags & RPC_CLNT_CREATE_HARDRTRY)\r\nclnt->cl_softrtry = 0;\r\nif (args->flags & RPC_CLNT_CREATE_AUTOBIND)\r\nclnt->cl_autobind = 1;\r\nif (args->flags & RPC_CLNT_CREATE_DISCRTRY)\r\nclnt->cl_discrtry = 1;\r\nif (!(args->flags & RPC_CLNT_CREATE_QUIET))\r\nclnt->cl_chatty = 1;\r\nreturn clnt;\r\n}\r\nstruct rpc_clnt *\r\nrpc_clone_client(struct rpc_clnt *clnt)\r\n{\r\nstruct rpc_clnt *new;\r\nint err = -ENOMEM;\r\nnew = kmemdup(clnt, sizeof(*new), GFP_KERNEL);\r\nif (!new)\r\ngoto out_no_clnt;\r\nnew->cl_parent = clnt;\r\nnew->cl_autobind = 0;\r\nINIT_LIST_HEAD(&new->cl_tasks);\r\nspin_lock_init(&new->cl_lock);\r\nrpc_init_rtt(&new->cl_rtt_default, clnt->cl_timeout->to_initval);\r\nnew->cl_metrics = rpc_alloc_iostats(clnt);\r\nif (new->cl_metrics == NULL)\r\ngoto out_no_stats;\r\nif (clnt->cl_principal) {\r\nnew->cl_principal = kstrdup(clnt->cl_principal, GFP_KERNEL);\r\nif (new->cl_principal == NULL)\r\ngoto out_no_principal;\r\n}\r\natomic_set(&new->cl_count, 1);\r\nerr = rpc_setup_pipedir(new, clnt->cl_program->pipe_dir_name);\r\nif (err != 0)\r\ngoto out_no_path;\r\nif (new->cl_auth)\r\natomic_inc(&new->cl_auth->au_count);\r\nxprt_get(clnt->cl_xprt);\r\natomic_inc(&clnt->cl_count);\r\nrpc_register_client(new);\r\nrpciod_up();\r\nreturn new;\r\nout_no_path:\r\nkfree(new->cl_principal);\r\nout_no_principal:\r\nrpc_free_iostats(new->cl_metrics);\r\nout_no_stats:\r\nkfree(new);\r\nout_no_clnt:\r\ndprintk("RPC: %s: returned error %d\n", __func__, err);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid rpc_killall_tasks(struct rpc_clnt *clnt)\r\n{\r\nstruct rpc_task *rovr;\r\nif (list_empty(&clnt->cl_tasks))\r\nreturn;\r\ndprintk("RPC: killing all tasks for client %p\n", clnt);\r\nspin_lock(&clnt->cl_lock);\r\nlist_for_each_entry(rovr, &clnt->cl_tasks, tk_task) {\r\nif (!RPC_IS_ACTIVATED(rovr))\r\ncontinue;\r\nif (!(rovr->tk_flags & RPC_TASK_KILLED)) {\r\nrovr->tk_flags |= RPC_TASK_KILLED;\r\nrpc_exit(rovr, -EIO);\r\nif (RPC_IS_QUEUED(rovr))\r\nrpc_wake_up_queued_task(rovr->tk_waitqueue,\r\nrovr);\r\n}\r\n}\r\nspin_unlock(&clnt->cl_lock);\r\n}\r\nvoid rpc_shutdown_client(struct rpc_clnt *clnt)\r\n{\r\ndprintk("RPC: shutting down %s client for %s\n",\r\nclnt->cl_protname, clnt->cl_server);\r\nwhile (!list_empty(&clnt->cl_tasks)) {\r\nrpc_killall_tasks(clnt);\r\nwait_event_timeout(destroy_wait,\r\nlist_empty(&clnt->cl_tasks), 1*HZ);\r\n}\r\nrpc_release_client(clnt);\r\n}\r\nstatic void\r\nrpc_free_client(struct rpc_clnt *clnt)\r\n{\r\ndprintk("RPC: destroying %s client for %s\n",\r\nclnt->cl_protname, clnt->cl_server);\r\nif (!IS_ERR(clnt->cl_path.dentry)) {\r\nrpc_remove_client_dir(clnt->cl_path.dentry);\r\nrpc_put_mount();\r\n}\r\nif (clnt->cl_parent != clnt) {\r\nrpc_release_client(clnt->cl_parent);\r\ngoto out_free;\r\n}\r\nif (clnt->cl_server != clnt->cl_inline_name)\r\nkfree(clnt->cl_server);\r\nout_free:\r\nrpc_unregister_client(clnt);\r\nrpc_free_iostats(clnt->cl_metrics);\r\nkfree(clnt->cl_principal);\r\nclnt->cl_metrics = NULL;\r\nxprt_put(clnt->cl_xprt);\r\nrpciod_down();\r\nkfree(clnt);\r\n}\r\nstatic void\r\nrpc_free_auth(struct rpc_clnt *clnt)\r\n{\r\nif (clnt->cl_auth == NULL) {\r\nrpc_free_client(clnt);\r\nreturn;\r\n}\r\natomic_inc(&clnt->cl_count);\r\nrpcauth_release(clnt->cl_auth);\r\nclnt->cl_auth = NULL;\r\nif (atomic_dec_and_test(&clnt->cl_count))\r\nrpc_free_client(clnt);\r\n}\r\nvoid\r\nrpc_release_client(struct rpc_clnt *clnt)\r\n{\r\ndprintk("RPC: rpc_release_client(%p)\n", clnt);\r\nif (list_empty(&clnt->cl_tasks))\r\nwake_up(&destroy_wait);\r\nif (atomic_dec_and_test(&clnt->cl_count))\r\nrpc_free_auth(clnt);\r\n}\r\nstruct rpc_clnt *rpc_bind_new_program(struct rpc_clnt *old,\r\nstruct rpc_program *program,\r\nu32 vers)\r\n{\r\nstruct rpc_clnt *clnt;\r\nstruct rpc_version *version;\r\nint err;\r\nBUG_ON(vers >= program->nrvers || !program->version[vers]);\r\nversion = program->version[vers];\r\nclnt = rpc_clone_client(old);\r\nif (IS_ERR(clnt))\r\ngoto out;\r\nclnt->cl_procinfo = version->procs;\r\nclnt->cl_maxproc = version->nrprocs;\r\nclnt->cl_protname = program->name;\r\nclnt->cl_prog = program->number;\r\nclnt->cl_vers = version->number;\r\nclnt->cl_stats = program->stats;\r\nerr = rpc_ping(clnt);\r\nif (err != 0) {\r\nrpc_shutdown_client(clnt);\r\nclnt = ERR_PTR(err);\r\n}\r\nout:\r\nreturn clnt;\r\n}\r\nvoid rpc_task_release_client(struct rpc_task *task)\r\n{\r\nstruct rpc_clnt *clnt = task->tk_client;\r\nif (clnt != NULL) {\r\nspin_lock(&clnt->cl_lock);\r\nlist_del(&task->tk_task);\r\nspin_unlock(&clnt->cl_lock);\r\ntask->tk_client = NULL;\r\nrpc_release_client(clnt);\r\n}\r\n}\r\nstatic\r\nvoid rpc_task_set_client(struct rpc_task *task, struct rpc_clnt *clnt)\r\n{\r\nif (clnt != NULL) {\r\nrpc_task_release_client(task);\r\ntask->tk_client = clnt;\r\natomic_inc(&clnt->cl_count);\r\nif (clnt->cl_softrtry)\r\ntask->tk_flags |= RPC_TASK_SOFT;\r\nspin_lock(&clnt->cl_lock);\r\nlist_add_tail(&task->tk_task, &clnt->cl_tasks);\r\nspin_unlock(&clnt->cl_lock);\r\n}\r\n}\r\nvoid rpc_task_reset_client(struct rpc_task *task, struct rpc_clnt *clnt)\r\n{\r\nrpc_task_release_client(task);\r\nrpc_task_set_client(task, clnt);\r\n}\r\nstatic void\r\nrpc_task_set_rpc_message(struct rpc_task *task, const struct rpc_message *msg)\r\n{\r\nif (msg != NULL) {\r\ntask->tk_msg.rpc_proc = msg->rpc_proc;\r\ntask->tk_msg.rpc_argp = msg->rpc_argp;\r\ntask->tk_msg.rpc_resp = msg->rpc_resp;\r\nif (msg->rpc_cred != NULL)\r\ntask->tk_msg.rpc_cred = get_rpccred(msg->rpc_cred);\r\n}\r\n}\r\nstatic void\r\nrpc_default_callback(struct rpc_task *task, void *data)\r\n{\r\n}\r\nstruct rpc_task *rpc_run_task(const struct rpc_task_setup *task_setup_data)\r\n{\r\nstruct rpc_task *task;\r\ntask = rpc_new_task(task_setup_data);\r\nif (IS_ERR(task))\r\ngoto out;\r\nrpc_task_set_client(task, task_setup_data->rpc_client);\r\nrpc_task_set_rpc_message(task, task_setup_data->rpc_message);\r\nif (task->tk_action == NULL)\r\nrpc_call_start(task);\r\natomic_inc(&task->tk_count);\r\nrpc_execute(task);\r\nout:\r\nreturn task;\r\n}\r\nint rpc_call_sync(struct rpc_clnt *clnt, const struct rpc_message *msg, int flags)\r\n{\r\nstruct rpc_task *task;\r\nstruct rpc_task_setup task_setup_data = {\r\n.rpc_client = clnt,\r\n.rpc_message = msg,\r\n.callback_ops = &rpc_default_ops,\r\n.flags = flags,\r\n};\r\nint status;\r\nBUG_ON(flags & RPC_TASK_ASYNC);\r\ntask = rpc_run_task(&task_setup_data);\r\nif (IS_ERR(task))\r\nreturn PTR_ERR(task);\r\nstatus = task->tk_status;\r\nrpc_put_task(task);\r\nreturn status;\r\n}\r\nint\r\nrpc_call_async(struct rpc_clnt *clnt, const struct rpc_message *msg, int flags,\r\nconst struct rpc_call_ops *tk_ops, void *data)\r\n{\r\nstruct rpc_task *task;\r\nstruct rpc_task_setup task_setup_data = {\r\n.rpc_client = clnt,\r\n.rpc_message = msg,\r\n.callback_ops = tk_ops,\r\n.callback_data = data,\r\n.flags = flags|RPC_TASK_ASYNC,\r\n};\r\ntask = rpc_run_task(&task_setup_data);\r\nif (IS_ERR(task))\r\nreturn PTR_ERR(task);\r\nrpc_put_task(task);\r\nreturn 0;\r\n}\r\nstruct rpc_task *rpc_run_bc_task(struct rpc_rqst *req,\r\nconst struct rpc_call_ops *tk_ops)\r\n{\r\nstruct rpc_task *task;\r\nstruct xdr_buf *xbufp = &req->rq_snd_buf;\r\nstruct rpc_task_setup task_setup_data = {\r\n.callback_ops = tk_ops,\r\n};\r\ndprintk("RPC: rpc_run_bc_task req= %p\n", req);\r\ntask = rpc_new_task(&task_setup_data);\r\nif (IS_ERR(task)) {\r\nxprt_free_bc_request(req);\r\ngoto out;\r\n}\r\ntask->tk_rqstp = req;\r\nxbufp->len = xbufp->head[0].iov_len + xbufp->page_len +\r\nxbufp->tail[0].iov_len;\r\ntask->tk_action = call_bc_transmit;\r\natomic_inc(&task->tk_count);\r\nBUG_ON(atomic_read(&task->tk_count) != 2);\r\nrpc_execute(task);\r\nout:\r\ndprintk("RPC: rpc_run_bc_task: task= %p\n", task);\r\nreturn task;\r\n}\r\nvoid\r\nrpc_call_start(struct rpc_task *task)\r\n{\r\ntask->tk_action = call_start;\r\n}\r\nsize_t rpc_peeraddr(struct rpc_clnt *clnt, struct sockaddr *buf, size_t bufsize)\r\n{\r\nsize_t bytes;\r\nstruct rpc_xprt *xprt = clnt->cl_xprt;\r\nbytes = sizeof(xprt->addr);\r\nif (bytes > bufsize)\r\nbytes = bufsize;\r\nmemcpy(buf, &clnt->cl_xprt->addr, bytes);\r\nreturn xprt->addrlen;\r\n}\r\nconst char *rpc_peeraddr2str(struct rpc_clnt *clnt,\r\nenum rpc_display_format_t format)\r\n{\r\nstruct rpc_xprt *xprt = clnt->cl_xprt;\r\nif (xprt->address_strings[format] != NULL)\r\nreturn xprt->address_strings[format];\r\nelse\r\nreturn "unprintable";\r\n}\r\nvoid\r\nrpc_setbufsize(struct rpc_clnt *clnt, unsigned int sndsize, unsigned int rcvsize)\r\n{\r\nstruct rpc_xprt *xprt = clnt->cl_xprt;\r\nif (xprt->ops->set_buffer_size)\r\nxprt->ops->set_buffer_size(xprt, sndsize, rcvsize);\r\n}\r\nsize_t rpc_max_payload(struct rpc_clnt *clnt)\r\n{\r\nreturn clnt->cl_xprt->max_payload;\r\n}\r\nvoid rpc_force_rebind(struct rpc_clnt *clnt)\r\n{\r\nif (clnt->cl_autobind)\r\nxprt_clear_bound(clnt->cl_xprt);\r\n}\r\nint\r\nrpc_restart_call_prepare(struct rpc_task *task)\r\n{\r\nif (RPC_ASSASSINATED(task))\r\nreturn 0;\r\ntask->tk_action = call_start;\r\nif (task->tk_ops->rpc_call_prepare != NULL)\r\ntask->tk_action = rpc_prepare_task;\r\nreturn 1;\r\n}\r\nint\r\nrpc_restart_call(struct rpc_task *task)\r\n{\r\nif (RPC_ASSASSINATED(task))\r\nreturn 0;\r\ntask->tk_action = call_start;\r\nreturn 1;\r\n}\r\nstatic const char *rpc_proc_name(const struct rpc_task *task)\r\n{\r\nconst struct rpc_procinfo *proc = task->tk_msg.rpc_proc;\r\nif (proc) {\r\nif (proc->p_name)\r\nreturn proc->p_name;\r\nelse\r\nreturn "NULL";\r\n} else\r\nreturn "no proc";\r\n}\r\nstatic void\r\ncall_start(struct rpc_task *task)\r\n{\r\nstruct rpc_clnt *clnt = task->tk_client;\r\ndprintk("RPC: %5u call_start %s%d proc %s (%s)\n", task->tk_pid,\r\nclnt->cl_protname, clnt->cl_vers,\r\nrpc_proc_name(task),\r\n(RPC_IS_ASYNC(task) ? "async" : "sync"));\r\ntask->tk_msg.rpc_proc->p_count++;\r\nclnt->cl_stats->rpccnt++;\r\ntask->tk_action = call_reserve;\r\n}\r\nstatic void\r\ncall_reserve(struct rpc_task *task)\r\n{\r\ndprint_status(task);\r\ntask->tk_status = 0;\r\ntask->tk_action = call_reserveresult;\r\nxprt_reserve(task);\r\n}\r\nstatic void\r\ncall_reserveresult(struct rpc_task *task)\r\n{\r\nint status = task->tk_status;\r\ndprint_status(task);\r\ntask->tk_status = 0;\r\nif (status >= 0) {\r\nif (task->tk_rqstp) {\r\ntask->tk_action = call_refresh;\r\nreturn;\r\n}\r\nprintk(KERN_ERR "%s: status=%d, but no request slot, exiting\n",\r\n__func__, status);\r\nrpc_exit(task, -EIO);\r\nreturn;\r\n}\r\nif (task->tk_rqstp) {\r\nprintk(KERN_ERR "%s: status=%d, request allocated anyway\n",\r\n__func__, status);\r\nxprt_release(task);\r\n}\r\nswitch (status) {\r\ncase -EAGAIN:\r\ntask->tk_action = call_reserve;\r\nreturn;\r\ncase -EIO:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: unrecognized error %d, exiting\n",\r\n__func__, status);\r\nbreak;\r\n}\r\nrpc_exit(task, status);\r\n}\r\nstatic void\r\ncall_refresh(struct rpc_task *task)\r\n{\r\ndprint_status(task);\r\ntask->tk_action = call_refreshresult;\r\ntask->tk_status = 0;\r\ntask->tk_client->cl_stats->rpcauthrefresh++;\r\nrpcauth_refreshcred(task);\r\n}\r\nstatic void\r\ncall_refreshresult(struct rpc_task *task)\r\n{\r\nint status = task->tk_status;\r\ndprint_status(task);\r\ntask->tk_status = 0;\r\ntask->tk_action = call_refresh;\r\nswitch (status) {\r\ncase 0:\r\nif (rpcauth_uptodatecred(task))\r\ntask->tk_action = call_allocate;\r\nreturn;\r\ncase -ETIMEDOUT:\r\nrpc_delay(task, 3*HZ);\r\ncase -EAGAIN:\r\nstatus = -EACCES;\r\nif (!task->tk_cred_retry)\r\nbreak;\r\ntask->tk_cred_retry--;\r\ndprintk("RPC: %5u %s: retry refresh creds\n",\r\ntask->tk_pid, __func__);\r\nreturn;\r\n}\r\ndprintk("RPC: %5u %s: refresh creds failed with error %d\n",\r\ntask->tk_pid, __func__, status);\r\nrpc_exit(task, status);\r\n}\r\nstatic void\r\ncall_allocate(struct rpc_task *task)\r\n{\r\nunsigned int slack = task->tk_rqstp->rq_cred->cr_auth->au_cslack;\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nstruct rpc_xprt *xprt = task->tk_xprt;\r\nstruct rpc_procinfo *proc = task->tk_msg.rpc_proc;\r\ndprint_status(task);\r\ntask->tk_status = 0;\r\ntask->tk_action = call_bind;\r\nif (req->rq_buffer)\r\nreturn;\r\nif (proc->p_proc != 0) {\r\nBUG_ON(proc->p_arglen == 0);\r\nif (proc->p_decode != NULL)\r\nBUG_ON(proc->p_replen == 0);\r\n}\r\nreq->rq_callsize = RPC_CALLHDRSIZE + (slack << 1) + proc->p_arglen;\r\nreq->rq_callsize <<= 2;\r\nreq->rq_rcvsize = RPC_REPHDRSIZE + slack + proc->p_replen;\r\nreq->rq_rcvsize <<= 2;\r\nreq->rq_buffer = xprt->ops->buf_alloc(task,\r\nreq->rq_callsize + req->rq_rcvsize);\r\nif (req->rq_buffer != NULL)\r\nreturn;\r\ndprintk("RPC: %5u rpc_buffer allocation failed\n", task->tk_pid);\r\nif (RPC_IS_ASYNC(task) || !fatal_signal_pending(current)) {\r\ntask->tk_action = call_allocate;\r\nrpc_delay(task, HZ>>4);\r\nreturn;\r\n}\r\nrpc_exit(task, -ERESTARTSYS);\r\n}\r\nstatic inline int\r\nrpc_task_need_encode(struct rpc_task *task)\r\n{\r\nreturn task->tk_rqstp->rq_snd_buf.len == 0;\r\n}\r\nstatic inline void\r\nrpc_task_force_reencode(struct rpc_task *task)\r\n{\r\ntask->tk_rqstp->rq_snd_buf.len = 0;\r\ntask->tk_rqstp->rq_bytes_sent = 0;\r\n}\r\nstatic inline void\r\nrpc_xdr_buf_init(struct xdr_buf *buf, void *start, size_t len)\r\n{\r\nbuf->head[0].iov_base = start;\r\nbuf->head[0].iov_len = len;\r\nbuf->tail[0].iov_len = 0;\r\nbuf->page_len = 0;\r\nbuf->flags = 0;\r\nbuf->len = 0;\r\nbuf->buflen = len;\r\n}\r\nstatic void\r\nrpc_xdr_encode(struct rpc_task *task)\r\n{\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nkxdreproc_t encode;\r\n__be32 *p;\r\ndprint_status(task);\r\nrpc_xdr_buf_init(&req->rq_snd_buf,\r\nreq->rq_buffer,\r\nreq->rq_callsize);\r\nrpc_xdr_buf_init(&req->rq_rcv_buf,\r\n(char *)req->rq_buffer + req->rq_callsize,\r\nreq->rq_rcvsize);\r\np = rpc_encode_header(task);\r\nif (p == NULL) {\r\nprintk(KERN_INFO "RPC: couldn't encode RPC header, exit EIO\n");\r\nrpc_exit(task, -EIO);\r\nreturn;\r\n}\r\nencode = task->tk_msg.rpc_proc->p_encode;\r\nif (encode == NULL)\r\nreturn;\r\ntask->tk_status = rpcauth_wrap_req(task, encode, req, p,\r\ntask->tk_msg.rpc_argp);\r\n}\r\nstatic void\r\ncall_bind(struct rpc_task *task)\r\n{\r\nstruct rpc_xprt *xprt = task->tk_xprt;\r\ndprint_status(task);\r\ntask->tk_action = call_connect;\r\nif (!xprt_bound(xprt)) {\r\ntask->tk_action = call_bind_status;\r\ntask->tk_timeout = xprt->bind_timeout;\r\nxprt->ops->rpcbind(task);\r\n}\r\n}\r\nstatic void\r\ncall_bind_status(struct rpc_task *task)\r\n{\r\nint status = -EIO;\r\nif (task->tk_status >= 0) {\r\ndprint_status(task);\r\ntask->tk_status = 0;\r\ntask->tk_action = call_connect;\r\nreturn;\r\n}\r\nswitch (task->tk_status) {\r\ncase -ENOMEM:\r\ndprintk("RPC: %5u rpcbind out of memory\n", task->tk_pid);\r\nrpc_delay(task, HZ >> 2);\r\ngoto retry_timeout;\r\ncase -EACCES:\r\ndprintk("RPC: %5u remote rpcbind: RPC program/version "\r\n"unavailable\n", task->tk_pid);\r\nif (task->tk_msg.rpc_proc->p_proc == 0) {\r\nstatus = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (task->tk_rebind_retry == 0)\r\nbreak;\r\ntask->tk_rebind_retry--;\r\nrpc_delay(task, 3*HZ);\r\ngoto retry_timeout;\r\ncase -ETIMEDOUT:\r\ndprintk("RPC: %5u rpcbind request timed out\n",\r\ntask->tk_pid);\r\ngoto retry_timeout;\r\ncase -EPFNOSUPPORT:\r\ndprintk("RPC: %5u unrecognized remote rpcbind service\n",\r\ntask->tk_pid);\r\nbreak;\r\ncase -EPROTONOSUPPORT:\r\ndprintk("RPC: %5u remote rpcbind version unavailable, retrying\n",\r\ntask->tk_pid);\r\ntask->tk_status = 0;\r\ntask->tk_action = call_bind;\r\nreturn;\r\ncase -ECONNREFUSED:\r\ncase -ECONNRESET:\r\ncase -ENOTCONN:\r\ncase -EHOSTDOWN:\r\ncase -EHOSTUNREACH:\r\ncase -ENETUNREACH:\r\ncase -EPIPE:\r\ndprintk("RPC: %5u remote rpcbind unreachable: %d\n",\r\ntask->tk_pid, task->tk_status);\r\nif (!RPC_IS_SOFTCONN(task)) {\r\nrpc_delay(task, 5*HZ);\r\ngoto retry_timeout;\r\n}\r\nstatus = task->tk_status;\r\nbreak;\r\ndefault:\r\ndprintk("RPC: %5u unrecognized rpcbind error (%d)\n",\r\ntask->tk_pid, -task->tk_status);\r\n}\r\nrpc_exit(task, status);\r\nreturn;\r\nretry_timeout:\r\ntask->tk_action = call_timeout;\r\n}\r\nstatic void\r\ncall_connect(struct rpc_task *task)\r\n{\r\nstruct rpc_xprt *xprt = task->tk_xprt;\r\ndprintk("RPC: %5u call_connect xprt %p %s connected\n",\r\ntask->tk_pid, xprt,\r\n(xprt_connected(xprt) ? "is" : "is not"));\r\ntask->tk_action = call_transmit;\r\nif (!xprt_connected(xprt)) {\r\ntask->tk_action = call_connect_status;\r\nif (task->tk_status < 0)\r\nreturn;\r\nxprt_connect(task);\r\n}\r\n}\r\nstatic void\r\ncall_connect_status(struct rpc_task *task)\r\n{\r\nstruct rpc_clnt *clnt = task->tk_client;\r\nint status = task->tk_status;\r\ndprint_status(task);\r\ntask->tk_status = 0;\r\nif (status >= 0 || status == -EAGAIN) {\r\nclnt->cl_stats->netreconn++;\r\ntask->tk_action = call_transmit;\r\nreturn;\r\n}\r\nswitch (status) {\r\ncase -ETIMEDOUT:\r\ntask->tk_action = call_timeout;\r\nbreak;\r\ndefault:\r\nrpc_exit(task, -EIO);\r\n}\r\n}\r\nstatic void\r\ncall_transmit(struct rpc_task *task)\r\n{\r\ndprint_status(task);\r\ntask->tk_action = call_status;\r\nif (task->tk_status < 0)\r\nreturn;\r\ntask->tk_status = xprt_prepare_transmit(task);\r\nif (task->tk_status != 0)\r\nreturn;\r\ntask->tk_action = call_transmit_status;\r\nif (rpc_task_need_encode(task)) {\r\nBUG_ON(task->tk_rqstp->rq_bytes_sent != 0);\r\nrpc_xdr_encode(task);\r\nif (task->tk_status != 0) {\r\nif (task->tk_status == -EAGAIN)\r\nrpc_delay(task, HZ >> 4);\r\nelse\r\nrpc_exit(task, task->tk_status);\r\nreturn;\r\n}\r\n}\r\nxprt_transmit(task);\r\nif (task->tk_status < 0)\r\nreturn;\r\ncall_transmit_status(task);\r\nif (rpc_reply_expected(task))\r\nreturn;\r\ntask->tk_action = rpc_exit_task;\r\nrpc_wake_up_queued_task(&task->tk_xprt->pending, task);\r\n}\r\nstatic void\r\ncall_transmit_status(struct rpc_task *task)\r\n{\r\ntask->tk_action = call_status;\r\nif (task->tk_status == 0) {\r\nxprt_end_transmit(task);\r\nrpc_task_force_reencode(task);\r\nreturn;\r\n}\r\nswitch (task->tk_status) {\r\ncase -EAGAIN:\r\nbreak;\r\ndefault:\r\ndprint_status(task);\r\nxprt_end_transmit(task);\r\nrpc_task_force_reencode(task);\r\nbreak;\r\ncase -ECONNREFUSED:\r\ncase -EHOSTDOWN:\r\ncase -EHOSTUNREACH:\r\ncase -ENETUNREACH:\r\nif (RPC_IS_SOFTCONN(task)) {\r\nxprt_end_transmit(task);\r\nrpc_exit(task, task->tk_status);\r\nbreak;\r\n}\r\ncase -ECONNRESET:\r\ncase -ENOTCONN:\r\ncase -EPIPE:\r\nrpc_task_force_reencode(task);\r\n}\r\n}\r\nstatic void\r\ncall_bc_transmit(struct rpc_task *task)\r\n{\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nBUG_ON(task->tk_status != 0);\r\ntask->tk_status = xprt_prepare_transmit(task);\r\nif (task->tk_status == -EAGAIN) {\r\ntask->tk_status = 0;\r\ntask->tk_action = call_bc_transmit;\r\nreturn;\r\n}\r\ntask->tk_action = rpc_exit_task;\r\nif (task->tk_status < 0) {\r\nprintk(KERN_NOTICE "RPC: Could not send backchannel reply "\r\n"error: %d\n", task->tk_status);\r\nreturn;\r\n}\r\nxprt_transmit(task);\r\nxprt_end_transmit(task);\r\ndprint_status(task);\r\nswitch (task->tk_status) {\r\ncase 0:\r\nbreak;\r\ncase -EHOSTDOWN:\r\ncase -EHOSTUNREACH:\r\ncase -ENETUNREACH:\r\ncase -ETIMEDOUT:\r\nprintk(KERN_NOTICE "RPC: Could not send backchannel reply "\r\n"error: %d\n", task->tk_status);\r\nxprt_conditional_disconnect(task->tk_xprt,\r\nreq->rq_connect_cookie);\r\nbreak;\r\ndefault:\r\nBUG_ON(task->tk_status == -EAGAIN);\r\nprintk(KERN_NOTICE "RPC: Could not send backchannel reply "\r\n"error: %d\n", task->tk_status);\r\nbreak;\r\n}\r\nrpc_wake_up_queued_task(&req->rq_xprt->pending, task);\r\n}\r\nstatic void\r\ncall_status(struct rpc_task *task)\r\n{\r\nstruct rpc_clnt *clnt = task->tk_client;\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nint status;\r\nif (req->rq_reply_bytes_recvd > 0 && !req->rq_bytes_sent)\r\ntask->tk_status = req->rq_reply_bytes_recvd;\r\ndprint_status(task);\r\nstatus = task->tk_status;\r\nif (status >= 0) {\r\ntask->tk_action = call_decode;\r\nreturn;\r\n}\r\ntask->tk_status = 0;\r\nswitch(status) {\r\ncase -EHOSTDOWN:\r\ncase -EHOSTUNREACH:\r\ncase -ENETUNREACH:\r\nrpc_delay(task, 3*HZ);\r\ncase -ETIMEDOUT:\r\ntask->tk_action = call_timeout;\r\nif (task->tk_client->cl_discrtry)\r\nxprt_conditional_disconnect(task->tk_xprt,\r\nreq->rq_connect_cookie);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ECONNREFUSED:\r\nrpc_force_rebind(clnt);\r\nrpc_delay(task, 3*HZ);\r\ncase -EPIPE:\r\ncase -ENOTCONN:\r\ntask->tk_action = call_bind;\r\nbreak;\r\ncase -EAGAIN:\r\ntask->tk_action = call_transmit;\r\nbreak;\r\ncase -EIO:\r\nrpc_exit(task, status);\r\nbreak;\r\ndefault:\r\nif (clnt->cl_chatty)\r\nprintk("%s: RPC call returned error %d\n",\r\nclnt->cl_protname, -status);\r\nrpc_exit(task, status);\r\n}\r\n}\r\nstatic void\r\ncall_timeout(struct rpc_task *task)\r\n{\r\nstruct rpc_clnt *clnt = task->tk_client;\r\nif (xprt_adjust_timeout(task->tk_rqstp) == 0) {\r\ndprintk("RPC: %5u call_timeout (minor)\n", task->tk_pid);\r\ngoto retry;\r\n}\r\ndprintk("RPC: %5u call_timeout (major)\n", task->tk_pid);\r\ntask->tk_timeouts++;\r\nif (RPC_IS_SOFTCONN(task)) {\r\nrpc_exit(task, -ETIMEDOUT);\r\nreturn;\r\n}\r\nif (RPC_IS_SOFT(task)) {\r\nif (clnt->cl_chatty)\r\nprintk(KERN_NOTICE "%s: server %s not responding, timed out\n",\r\nclnt->cl_protname, clnt->cl_server);\r\nif (task->tk_flags & RPC_TASK_TIMEOUT)\r\nrpc_exit(task, -ETIMEDOUT);\r\nelse\r\nrpc_exit(task, -EIO);\r\nreturn;\r\n}\r\nif (!(task->tk_flags & RPC_CALL_MAJORSEEN)) {\r\ntask->tk_flags |= RPC_CALL_MAJORSEEN;\r\nif (clnt->cl_chatty)\r\nprintk(KERN_NOTICE "%s: server %s not responding, still trying\n",\r\nclnt->cl_protname, clnt->cl_server);\r\n}\r\nrpc_force_rebind(clnt);\r\nrpcauth_invalcred(task);\r\nretry:\r\nclnt->cl_stats->rpcretrans++;\r\ntask->tk_action = call_bind;\r\ntask->tk_status = 0;\r\n}\r\nstatic void\r\ncall_decode(struct rpc_task *task)\r\n{\r\nstruct rpc_clnt *clnt = task->tk_client;\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nkxdrdproc_t decode = task->tk_msg.rpc_proc->p_decode;\r\n__be32 *p;\r\ndprint_status(task);\r\nif (task->tk_flags & RPC_CALL_MAJORSEEN) {\r\nif (clnt->cl_chatty)\r\nprintk(KERN_NOTICE "%s: server %s OK\n",\r\nclnt->cl_protname, clnt->cl_server);\r\ntask->tk_flags &= ~RPC_CALL_MAJORSEEN;\r\n}\r\nsmp_rmb();\r\nreq->rq_rcv_buf.len = req->rq_private_buf.len;\r\nWARN_ON(memcmp(&req->rq_rcv_buf, &req->rq_private_buf,\r\nsizeof(req->rq_rcv_buf)) != 0);\r\nif (req->rq_rcv_buf.len < 12) {\r\nif (!RPC_IS_SOFT(task)) {\r\ntask->tk_action = call_bind;\r\nclnt->cl_stats->rpcretrans++;\r\ngoto out_retry;\r\n}\r\ndprintk("RPC: %s: too small RPC reply size (%d bytes)\n",\r\nclnt->cl_protname, task->tk_status);\r\ntask->tk_action = call_timeout;\r\ngoto out_retry;\r\n}\r\np = rpc_verify_header(task);\r\nif (IS_ERR(p)) {\r\nif (p == ERR_PTR(-EAGAIN))\r\ngoto out_retry;\r\nreturn;\r\n}\r\ntask->tk_action = rpc_exit_task;\r\nif (decode) {\r\ntask->tk_status = rpcauth_unwrap_resp(task, decode, req, p,\r\ntask->tk_msg.rpc_resp);\r\n}\r\ndprintk("RPC: %5u call_decode result %d\n", task->tk_pid,\r\ntask->tk_status);\r\nreturn;\r\nout_retry:\r\ntask->tk_status = 0;\r\nif (task->tk_rqstp == req) {\r\nreq->rq_reply_bytes_recvd = req->rq_rcv_buf.len = 0;\r\nif (task->tk_client->cl_discrtry)\r\nxprt_conditional_disconnect(task->tk_xprt,\r\nreq->rq_connect_cookie);\r\n}\r\n}\r\nstatic __be32 *\r\nrpc_encode_header(struct rpc_task *task)\r\n{\r\nstruct rpc_clnt *clnt = task->tk_client;\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\n__be32 *p = req->rq_svec[0].iov_base;\r\np = xprt_skip_transport_header(task->tk_xprt, p);\r\n*p++ = req->rq_xid;\r\n*p++ = htonl(RPC_CALL);\r\n*p++ = htonl(RPC_VERSION);\r\n*p++ = htonl(clnt->cl_prog);\r\n*p++ = htonl(clnt->cl_vers);\r\n*p++ = htonl(task->tk_msg.rpc_proc->p_proc);\r\np = rpcauth_marshcred(task, p);\r\nreq->rq_slen = xdr_adjust_iovec(&req->rq_svec[0], p);\r\nreturn p;\r\n}\r\nstatic __be32 *\r\nrpc_verify_header(struct rpc_task *task)\r\n{\r\nstruct kvec *iov = &task->tk_rqstp->rq_rcv_buf.head[0];\r\nint len = task->tk_rqstp->rq_rcv_buf.len >> 2;\r\n__be32 *p = iov->iov_base;\r\nu32 n;\r\nint error = -EACCES;\r\nif ((task->tk_rqstp->rq_rcv_buf.len & 3) != 0) {\r\ndprintk("RPC: %5u %s: XDR representation not a multiple of"\r\n" 4 bytes: 0x%x\n", task->tk_pid, __func__,\r\ntask->tk_rqstp->rq_rcv_buf.len);\r\ngoto out_eio;\r\n}\r\nif ((len -= 3) < 0)\r\ngoto out_overflow;\r\np += 1;\r\nif ((n = ntohl(*p++)) != RPC_REPLY) {\r\ndprintk("RPC: %5u %s: not an RPC reply: %x\n",\r\ntask->tk_pid, __func__, n);\r\ngoto out_garbage;\r\n}\r\nif ((n = ntohl(*p++)) != RPC_MSG_ACCEPTED) {\r\nif (--len < 0)\r\ngoto out_overflow;\r\nswitch ((n = ntohl(*p++))) {\r\ncase RPC_AUTH_ERROR:\r\nbreak;\r\ncase RPC_MISMATCH:\r\ndprintk("RPC: %5u %s: RPC call version mismatch!\n",\r\ntask->tk_pid, __func__);\r\nerror = -EPROTONOSUPPORT;\r\ngoto out_err;\r\ndefault:\r\ndprintk("RPC: %5u %s: RPC call rejected, "\r\n"unknown error: %x\n",\r\ntask->tk_pid, __func__, n);\r\ngoto out_eio;\r\n}\r\nif (--len < 0)\r\ngoto out_overflow;\r\nswitch ((n = ntohl(*p++))) {\r\ncase RPC_AUTH_REJECTEDCRED:\r\ncase RPC_AUTH_REJECTEDVERF:\r\ncase RPCSEC_GSS_CREDPROBLEM:\r\ncase RPCSEC_GSS_CTXPROBLEM:\r\nif (!task->tk_cred_retry)\r\nbreak;\r\ntask->tk_cred_retry--;\r\ndprintk("RPC: %5u %s: retry stale creds\n",\r\ntask->tk_pid, __func__);\r\nrpcauth_invalcred(task);\r\nxprt_release(task);\r\ntask->tk_action = call_reserve;\r\ngoto out_retry;\r\ncase RPC_AUTH_BADCRED:\r\ncase RPC_AUTH_BADVERF:\r\nif (!task->tk_garb_retry)\r\nbreak;\r\ntask->tk_garb_retry--;\r\ndprintk("RPC: %5u %s: retry garbled creds\n",\r\ntask->tk_pid, __func__);\r\ntask->tk_action = call_bind;\r\ngoto out_retry;\r\ncase RPC_AUTH_TOOWEAK:\r\nprintk(KERN_NOTICE "RPC: server %s requires stronger "\r\n"authentication.\n", task->tk_client->cl_server);\r\nbreak;\r\ndefault:\r\ndprintk("RPC: %5u %s: unknown auth error: %x\n",\r\ntask->tk_pid, __func__, n);\r\nerror = -EIO;\r\n}\r\ndprintk("RPC: %5u %s: call rejected %d\n",\r\ntask->tk_pid, __func__, n);\r\ngoto out_err;\r\n}\r\nif (!(p = rpcauth_checkverf(task, p))) {\r\ndprintk("RPC: %5u %s: auth check failed\n",\r\ntask->tk_pid, __func__);\r\ngoto out_garbage;\r\n}\r\nlen = p - (__be32 *)iov->iov_base - 1;\r\nif (len < 0)\r\ngoto out_overflow;\r\nswitch ((n = ntohl(*p++))) {\r\ncase RPC_SUCCESS:\r\nreturn p;\r\ncase RPC_PROG_UNAVAIL:\r\ndprintk("RPC: %5u %s: program %u is unsupported by server %s\n",\r\ntask->tk_pid, __func__,\r\n(unsigned int)task->tk_client->cl_prog,\r\ntask->tk_client->cl_server);\r\nerror = -EPFNOSUPPORT;\r\ngoto out_err;\r\ncase RPC_PROG_MISMATCH:\r\ndprintk("RPC: %5u %s: program %u, version %u unsupported by "\r\n"server %s\n", task->tk_pid, __func__,\r\n(unsigned int)task->tk_client->cl_prog,\r\n(unsigned int)task->tk_client->cl_vers,\r\ntask->tk_client->cl_server);\r\nerror = -EPROTONOSUPPORT;\r\ngoto out_err;\r\ncase RPC_PROC_UNAVAIL:\r\ndprintk("RPC: %5u %s: proc %s unsupported by program %u, "\r\n"version %u on server %s\n",\r\ntask->tk_pid, __func__,\r\nrpc_proc_name(task),\r\ntask->tk_client->cl_prog,\r\ntask->tk_client->cl_vers,\r\ntask->tk_client->cl_server);\r\nerror = -EOPNOTSUPP;\r\ngoto out_err;\r\ncase RPC_GARBAGE_ARGS:\r\ndprintk("RPC: %5u %s: server saw garbage\n",\r\ntask->tk_pid, __func__);\r\nbreak;\r\ndefault:\r\ndprintk("RPC: %5u %s: server accept status: %x\n",\r\ntask->tk_pid, __func__, n);\r\n}\r\nout_garbage:\r\ntask->tk_client->cl_stats->rpcgarbage++;\r\nif (task->tk_garb_retry) {\r\ntask->tk_garb_retry--;\r\ndprintk("RPC: %5u %s: retrying\n",\r\ntask->tk_pid, __func__);\r\ntask->tk_action = call_bind;\r\nout_retry:\r\nreturn ERR_PTR(-EAGAIN);\r\n}\r\nout_eio:\r\nerror = -EIO;\r\nout_err:\r\nrpc_exit(task, error);\r\ndprintk("RPC: %5u %s: call failed with error %d\n", task->tk_pid,\r\n__func__, error);\r\nreturn ERR_PTR(error);\r\nout_overflow:\r\ndprintk("RPC: %5u %s: server reply was truncated.\n", task->tk_pid,\r\n__func__);\r\ngoto out_garbage;\r\n}\r\nstatic void rpcproc_encode_null(void *rqstp, struct xdr_stream *xdr, void *obj)\r\n{\r\n}\r\nstatic int rpcproc_decode_null(void *rqstp, struct xdr_stream *xdr, void *obj)\r\n{\r\nreturn 0;\r\n}\r\nstatic int rpc_ping(struct rpc_clnt *clnt)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_proc = &rpcproc_null,\r\n};\r\nint err;\r\nmsg.rpc_cred = authnull_ops.lookup_cred(NULL, NULL, 0);\r\nerr = rpc_call_sync(clnt, &msg, RPC_TASK_SOFT | RPC_TASK_SOFTCONN);\r\nput_rpccred(msg.rpc_cred);\r\nreturn err;\r\n}\r\nstruct rpc_task *rpc_call_null(struct rpc_clnt *clnt, struct rpc_cred *cred, int flags)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_proc = &rpcproc_null,\r\n.rpc_cred = cred,\r\n};\r\nstruct rpc_task_setup task_setup_data = {\r\n.rpc_client = clnt,\r\n.rpc_message = &msg,\r\n.callback_ops = &rpc_default_ops,\r\n.flags = flags,\r\n};\r\nreturn rpc_run_task(&task_setup_data);\r\n}\r\nstatic void rpc_show_header(void)\r\n{\r\nprintk(KERN_INFO "-pid- flgs status -client- --rqstp- "\r\n"-timeout ---ops--\n");\r\n}\r\nstatic void rpc_show_task(const struct rpc_clnt *clnt,\r\nconst struct rpc_task *task)\r\n{\r\nconst char *rpc_waitq = "none";\r\nif (RPC_IS_QUEUED(task))\r\nrpc_waitq = rpc_qname(task->tk_waitqueue);\r\nprintk(KERN_INFO "%5u %04x %6d %8p %8p %8ld %8p %sv%u %s a:%ps q:%s\n",\r\ntask->tk_pid, task->tk_flags, task->tk_status,\r\nclnt, task->tk_rqstp, task->tk_timeout, task->tk_ops,\r\nclnt->cl_protname, clnt->cl_vers, rpc_proc_name(task),\r\ntask->tk_action, rpc_waitq);\r\n}\r\nvoid rpc_show_tasks(void)\r\n{\r\nstruct rpc_clnt *clnt;\r\nstruct rpc_task *task;\r\nint header = 0;\r\nspin_lock(&rpc_client_lock);\r\nlist_for_each_entry(clnt, &all_clients, cl_clients) {\r\nspin_lock(&clnt->cl_lock);\r\nlist_for_each_entry(task, &clnt->cl_tasks, tk_task) {\r\nif (!header) {\r\nrpc_show_header();\r\nheader++;\r\n}\r\nrpc_show_task(clnt, task);\r\n}\r\nspin_unlock(&clnt->cl_lock);\r\n}\r\nspin_unlock(&rpc_client_lock);\r\n}
