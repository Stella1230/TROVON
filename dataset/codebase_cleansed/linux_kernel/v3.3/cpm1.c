static void cpm_mask_irq(struct irq_data *d)\r\n{\r\nunsigned int cpm_vec = (unsigned int)irqd_to_hwirq(d);\r\nclrbits32(&cpic_reg->cpic_cimr, (1 << cpm_vec));\r\n}\r\nstatic void cpm_unmask_irq(struct irq_data *d)\r\n{\r\nunsigned int cpm_vec = (unsigned int)irqd_to_hwirq(d);\r\nsetbits32(&cpic_reg->cpic_cimr, (1 << cpm_vec));\r\n}\r\nstatic void cpm_end_irq(struct irq_data *d)\r\n{\r\nunsigned int cpm_vec = (unsigned int)irqd_to_hwirq(d);\r\nout_be32(&cpic_reg->cpic_cisr, (1 << cpm_vec));\r\n}\r\nint cpm_get_irq(void)\r\n{\r\nint cpm_vec;\r\nout_be16(&cpic_reg->cpic_civr, 1);\r\ncpm_vec = in_be16(&cpic_reg->cpic_civr);\r\ncpm_vec >>= 11;\r\nreturn irq_linear_revmap(cpm_pic_host, cpm_vec);\r\n}\r\nstatic int cpm_pic_host_map(struct irq_host *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\npr_debug("cpm_pic_host_map(%d, 0x%lx)\n", virq, hw);\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nirq_set_chip_and_handler(virq, &cpm_pic, handle_fasteoi_irq);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t cpm_error_interrupt(int irq, void *dev)\r\n{\r\nreturn IRQ_HANDLED;\r\n}\r\nunsigned int cpm_pic_init(void)\r\n{\r\nstruct device_node *np = NULL;\r\nstruct resource res;\r\nunsigned int sirq = NO_IRQ, hwirq, eirq;\r\nint ret;\r\npr_debug("cpm_pic_init\n");\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,cpm1-pic");\r\nif (np == NULL)\r\nnp = of_find_compatible_node(NULL, "cpm-pic", "CPM");\r\nif (np == NULL) {\r\nprintk(KERN_ERR "CPM PIC init: can not find cpm-pic node\n");\r\nreturn sirq;\r\n}\r\nret = of_address_to_resource(np, 0, &res);\r\nif (ret)\r\ngoto end;\r\ncpic_reg = ioremap(res.start, resource_size(&res));\r\nif (cpic_reg == NULL)\r\ngoto end;\r\nsirq = irq_of_parse_and_map(np, 0);\r\nif (sirq == NO_IRQ)\r\ngoto end;\r\nhwirq = (unsigned int)virq_to_hw(sirq);\r\nout_be32(&cpic_reg->cpic_cicr,\r\n(CICR_SCD_SCC4 | CICR_SCC_SCC3 | CICR_SCB_SCC2 | CICR_SCA_SCC1) |\r\n((hwirq/2) << 13) | CICR_HP_MASK);\r\nout_be32(&cpic_reg->cpic_cimr, 0);\r\ncpm_pic_host = irq_alloc_host(np, IRQ_HOST_MAP_LINEAR,\r\n64, &cpm_pic_host_ops, 64);\r\nif (cpm_pic_host == NULL) {\r\nprintk(KERN_ERR "CPM2 PIC: failed to allocate irq host!\n");\r\nsirq = NO_IRQ;\r\ngoto end;\r\n}\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,cpm1");\r\nif (np == NULL)\r\nnp = of_find_node_by_type(NULL, "cpm");\r\nif (np == NULL) {\r\nprintk(KERN_ERR "CPM PIC init: can not find cpm node\n");\r\ngoto end;\r\n}\r\neirq = irq_of_parse_and_map(np, 0);\r\nif (eirq == NO_IRQ)\r\ngoto end;\r\nif (setup_irq(eirq, &cpm_error_irqaction))\r\nprintk(KERN_ERR "Could not allocate CPM error IRQ!");\r\nsetbits32(&cpic_reg->cpic_cicr, CICR_IEN);\r\nend:\r\nof_node_put(np);\r\nreturn sirq;\r\n}\r\nvoid __init cpm_reset(void)\r\n{\r\nsysconf8xx_t __iomem *siu_conf;\r\nmpc8xx_immr = ioremap(get_immrbase(), 0x4000);\r\nif (!mpc8xx_immr) {\r\nprintk(KERN_CRIT "Could not map IMMR\n");\r\nreturn;\r\n}\r\ncpmp = &mpc8xx_immr->im_cpm;\r\n#ifndef CONFIG_PPC_EARLY_DEBUG_CPM\r\nout_be16(&cpmp->cp_cpcr, CPM_CR_RST | CPM_CR_FLG);\r\nwhile (in_be16(&cpmp->cp_cpcr) & CPM_CR_FLG);\r\n#endif\r\n#ifdef CONFIG_UCODE_PATCH\r\ncpm_load_patch(cpmp);\r\n#endif\r\nsiu_conf = immr_map(im_siu_conf);\r\nout_be32(&siu_conf->sc_sdcr, 1);\r\nimmr_unmap(siu_conf);\r\ncpm_muram_init();\r\n}\r\nint cpm_command(u32 command, u8 opcode)\r\n{\r\nint i, ret;\r\nunsigned long flags;\r\nif (command & 0xffffff0f)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&cmd_lock, flags);\r\nret = 0;\r\nout_be16(&cpmp->cp_cpcr, command | CPM_CR_FLG | (opcode << 8));\r\nfor (i = 0; i < MAX_CR_CMD_LOOPS; i++)\r\nif ((in_be16(&cpmp->cp_cpcr) & CPM_CR_FLG) == 0)\r\ngoto out;\r\nprintk(KERN_ERR "%s(): Not able to issue CPM command\n", __func__);\r\nret = -EIO;\r\nout:\r\nspin_unlock_irqrestore(&cmd_lock, flags);\r\nreturn ret;\r\n}\r\nvoid\r\ncpm_setbrg(uint brg, uint rate)\r\n{\r\nu32 __iomem *bp;\r\nbp = &cpmp->cp_brgc1;\r\nbp += brg;\r\nif (((BRG_UART_CLK / rate) - 1) < 4096)\r\nout_be32(bp, (((BRG_UART_CLK / rate) - 1) << 1) | CPM_BRG_EN);\r\nelse\r\nout_be32(bp, (((BRG_UART_CLK_DIV16 / rate) - 1) << 1) |\r\nCPM_BRG_EN | CPM_BRG_DIV16);\r\n}\r\nstatic void cpm1_set_pin32(int port, int pin, int flags)\r\n{\r\nstruct cpm_ioport32e __iomem *iop;\r\npin = 1 << (31 - pin);\r\nif (port == CPM_PORTB)\r\niop = (struct cpm_ioport32e __iomem *)\r\n&mpc8xx_immr->im_cpm.cp_pbdir;\r\nelse\r\niop = (struct cpm_ioport32e __iomem *)\r\n&mpc8xx_immr->im_cpm.cp_pedir;\r\nif (flags & CPM_PIN_OUTPUT)\r\nsetbits32(&iop->dir, pin);\r\nelse\r\nclrbits32(&iop->dir, pin);\r\nif (!(flags & CPM_PIN_GPIO))\r\nsetbits32(&iop->par, pin);\r\nelse\r\nclrbits32(&iop->par, pin);\r\nif (port == CPM_PORTB) {\r\nif (flags & CPM_PIN_OPENDRAIN)\r\nsetbits16(&mpc8xx_immr->im_cpm.cp_pbodr, pin);\r\nelse\r\nclrbits16(&mpc8xx_immr->im_cpm.cp_pbodr, pin);\r\n}\r\nif (port == CPM_PORTE) {\r\nif (flags & CPM_PIN_SECONDARY)\r\nsetbits32(&iop->sor, pin);\r\nelse\r\nclrbits32(&iop->sor, pin);\r\nif (flags & CPM_PIN_OPENDRAIN)\r\nsetbits32(&mpc8xx_immr->im_cpm.cp_peodr, pin);\r\nelse\r\nclrbits32(&mpc8xx_immr->im_cpm.cp_peodr, pin);\r\n}\r\n}\r\nstatic void cpm1_set_pin16(int port, int pin, int flags)\r\n{\r\nstruct cpm_ioport16 __iomem *iop =\r\n(struct cpm_ioport16 __iomem *)&mpc8xx_immr->im_ioport;\r\npin = 1 << (15 - pin);\r\nif (port != 0)\r\niop += port - 1;\r\nif (flags & CPM_PIN_OUTPUT)\r\nsetbits16(&iop->dir, pin);\r\nelse\r\nclrbits16(&iop->dir, pin);\r\nif (!(flags & CPM_PIN_GPIO))\r\nsetbits16(&iop->par, pin);\r\nelse\r\nclrbits16(&iop->par, pin);\r\nif (port == CPM_PORTA) {\r\nif (flags & CPM_PIN_OPENDRAIN)\r\nsetbits16(&iop->odr_sor, pin);\r\nelse\r\nclrbits16(&iop->odr_sor, pin);\r\n}\r\nif (port == CPM_PORTC) {\r\nif (flags & CPM_PIN_SECONDARY)\r\nsetbits16(&iop->odr_sor, pin);\r\nelse\r\nclrbits16(&iop->odr_sor, pin);\r\n}\r\n}\r\nvoid cpm1_set_pin(enum cpm_port port, int pin, int flags)\r\n{\r\nif (port == CPM_PORTB || port == CPM_PORTE)\r\ncpm1_set_pin32(port, pin, flags);\r\nelse\r\ncpm1_set_pin16(port, pin, flags);\r\n}\r\nint cpm1_clk_setup(enum cpm_clk_target target, int clock, int mode)\r\n{\r\nint shift;\r\nint i, bits = 0;\r\nu32 __iomem *reg;\r\nu32 mask = 7;\r\nu8 clk_map[][3] = {\r\n{CPM_CLK_SCC1, CPM_BRG1, 0},\r\n{CPM_CLK_SCC1, CPM_BRG2, 1},\r\n{CPM_CLK_SCC1, CPM_BRG3, 2},\r\n{CPM_CLK_SCC1, CPM_BRG4, 3},\r\n{CPM_CLK_SCC1, CPM_CLK1, 4},\r\n{CPM_CLK_SCC1, CPM_CLK2, 5},\r\n{CPM_CLK_SCC1, CPM_CLK3, 6},\r\n{CPM_CLK_SCC1, CPM_CLK4, 7},\r\n{CPM_CLK_SCC2, CPM_BRG1, 0},\r\n{CPM_CLK_SCC2, CPM_BRG2, 1},\r\n{CPM_CLK_SCC2, CPM_BRG3, 2},\r\n{CPM_CLK_SCC2, CPM_BRG4, 3},\r\n{CPM_CLK_SCC2, CPM_CLK1, 4},\r\n{CPM_CLK_SCC2, CPM_CLK2, 5},\r\n{CPM_CLK_SCC2, CPM_CLK3, 6},\r\n{CPM_CLK_SCC2, CPM_CLK4, 7},\r\n{CPM_CLK_SCC3, CPM_BRG1, 0},\r\n{CPM_CLK_SCC3, CPM_BRG2, 1},\r\n{CPM_CLK_SCC3, CPM_BRG3, 2},\r\n{CPM_CLK_SCC3, CPM_BRG4, 3},\r\n{CPM_CLK_SCC3, CPM_CLK5, 4},\r\n{CPM_CLK_SCC3, CPM_CLK6, 5},\r\n{CPM_CLK_SCC3, CPM_CLK7, 6},\r\n{CPM_CLK_SCC3, CPM_CLK8, 7},\r\n{CPM_CLK_SCC4, CPM_BRG1, 0},\r\n{CPM_CLK_SCC4, CPM_BRG2, 1},\r\n{CPM_CLK_SCC4, CPM_BRG3, 2},\r\n{CPM_CLK_SCC4, CPM_BRG4, 3},\r\n{CPM_CLK_SCC4, CPM_CLK5, 4},\r\n{CPM_CLK_SCC4, CPM_CLK6, 5},\r\n{CPM_CLK_SCC4, CPM_CLK7, 6},\r\n{CPM_CLK_SCC4, CPM_CLK8, 7},\r\n{CPM_CLK_SMC1, CPM_BRG1, 0},\r\n{CPM_CLK_SMC1, CPM_BRG2, 1},\r\n{CPM_CLK_SMC1, CPM_BRG3, 2},\r\n{CPM_CLK_SMC1, CPM_BRG4, 3},\r\n{CPM_CLK_SMC1, CPM_CLK1, 4},\r\n{CPM_CLK_SMC1, CPM_CLK2, 5},\r\n{CPM_CLK_SMC1, CPM_CLK3, 6},\r\n{CPM_CLK_SMC1, CPM_CLK4, 7},\r\n{CPM_CLK_SMC2, CPM_BRG1, 0},\r\n{CPM_CLK_SMC2, CPM_BRG2, 1},\r\n{CPM_CLK_SMC2, CPM_BRG3, 2},\r\n{CPM_CLK_SMC2, CPM_BRG4, 3},\r\n{CPM_CLK_SMC2, CPM_CLK5, 4},\r\n{CPM_CLK_SMC2, CPM_CLK6, 5},\r\n{CPM_CLK_SMC2, CPM_CLK7, 6},\r\n{CPM_CLK_SMC2, CPM_CLK8, 7},\r\n};\r\nswitch (target) {\r\ncase CPM_CLK_SCC1:\r\nreg = &mpc8xx_immr->im_cpm.cp_sicr;\r\nshift = 0;\r\nbreak;\r\ncase CPM_CLK_SCC2:\r\nreg = &mpc8xx_immr->im_cpm.cp_sicr;\r\nshift = 8;\r\nbreak;\r\ncase CPM_CLK_SCC3:\r\nreg = &mpc8xx_immr->im_cpm.cp_sicr;\r\nshift = 16;\r\nbreak;\r\ncase CPM_CLK_SCC4:\r\nreg = &mpc8xx_immr->im_cpm.cp_sicr;\r\nshift = 24;\r\nbreak;\r\ncase CPM_CLK_SMC1:\r\nreg = &mpc8xx_immr->im_cpm.cp_simode;\r\nshift = 12;\r\nbreak;\r\ncase CPM_CLK_SMC2:\r\nreg = &mpc8xx_immr->im_cpm.cp_simode;\r\nshift = 28;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "cpm1_clock_setup: invalid clock target\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(clk_map); i++) {\r\nif (clk_map[i][0] == target && clk_map[i][1] == clock) {\r\nbits = clk_map[i][2];\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(clk_map)) {\r\nprintk(KERN_ERR "cpm1_clock_setup: invalid clock combination\n");\r\nreturn -EINVAL;\r\n}\r\nbits <<= shift;\r\nmask <<= shift;\r\nif (reg == &mpc8xx_immr->im_cpm.cp_sicr) {\r\nif (mode == CPM_CLK_RTX) {\r\nbits |= bits << 3;\r\nmask |= mask << 3;\r\n} else if (mode == CPM_CLK_RX) {\r\nbits <<= 3;\r\nmask <<= 3;\r\n}\r\n}\r\nout_be32(reg, (in_be32(reg) & ~mask) | bits);\r\nreturn 0;\r\n}\r\nstatic inline struct cpm1_gpio16_chip *\r\nto_cpm1_gpio16_chip(struct of_mm_gpio_chip *mm_gc)\r\n{\r\nreturn container_of(mm_gc, struct cpm1_gpio16_chip, mm_gc);\r\n}\r\nstatic void cpm1_gpio16_save_regs(struct of_mm_gpio_chip *mm_gc)\r\n{\r\nstruct cpm1_gpio16_chip *cpm1_gc = to_cpm1_gpio16_chip(mm_gc);\r\nstruct cpm_ioport16 __iomem *iop = mm_gc->regs;\r\ncpm1_gc->cpdata = in_be16(&iop->dat);\r\n}\r\nstatic int cpm1_gpio16_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct cpm_ioport16 __iomem *iop = mm_gc->regs;\r\nu16 pin_mask;\r\npin_mask = 1 << (15 - gpio);\r\nreturn !!(in_be16(&iop->dat) & pin_mask);\r\n}\r\nstatic void __cpm1_gpio16_set(struct of_mm_gpio_chip *mm_gc, u16 pin_mask,\r\nint value)\r\n{\r\nstruct cpm1_gpio16_chip *cpm1_gc = to_cpm1_gpio16_chip(mm_gc);\r\nstruct cpm_ioport16 __iomem *iop = mm_gc->regs;\r\nif (value)\r\ncpm1_gc->cpdata |= pin_mask;\r\nelse\r\ncpm1_gc->cpdata &= ~pin_mask;\r\nout_be16(&iop->dat, cpm1_gc->cpdata);\r\n}\r\nstatic void cpm1_gpio16_set(struct gpio_chip *gc, unsigned int gpio, int value)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct cpm1_gpio16_chip *cpm1_gc = to_cpm1_gpio16_chip(mm_gc);\r\nunsigned long flags;\r\nu16 pin_mask = 1 << (15 - gpio);\r\nspin_lock_irqsave(&cpm1_gc->lock, flags);\r\n__cpm1_gpio16_set(mm_gc, pin_mask, value);\r\nspin_unlock_irqrestore(&cpm1_gc->lock, flags);\r\n}\r\nstatic int cpm1_gpio16_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct cpm1_gpio16_chip *cpm1_gc = to_cpm1_gpio16_chip(mm_gc);\r\nstruct cpm_ioport16 __iomem *iop = mm_gc->regs;\r\nunsigned long flags;\r\nu16 pin_mask = 1 << (15 - gpio);\r\nspin_lock_irqsave(&cpm1_gc->lock, flags);\r\nsetbits16(&iop->dir, pin_mask);\r\n__cpm1_gpio16_set(mm_gc, pin_mask, val);\r\nspin_unlock_irqrestore(&cpm1_gc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cpm1_gpio16_dir_in(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct cpm1_gpio16_chip *cpm1_gc = to_cpm1_gpio16_chip(mm_gc);\r\nstruct cpm_ioport16 __iomem *iop = mm_gc->regs;\r\nunsigned long flags;\r\nu16 pin_mask = 1 << (15 - gpio);\r\nspin_lock_irqsave(&cpm1_gc->lock, flags);\r\nclrbits16(&iop->dir, pin_mask);\r\nspin_unlock_irqrestore(&cpm1_gc->lock, flags);\r\nreturn 0;\r\n}\r\nint cpm1_gpiochip_add16(struct device_node *np)\r\n{\r\nstruct cpm1_gpio16_chip *cpm1_gc;\r\nstruct of_mm_gpio_chip *mm_gc;\r\nstruct gpio_chip *gc;\r\ncpm1_gc = kzalloc(sizeof(*cpm1_gc), GFP_KERNEL);\r\nif (!cpm1_gc)\r\nreturn -ENOMEM;\r\nspin_lock_init(&cpm1_gc->lock);\r\nmm_gc = &cpm1_gc->mm_gc;\r\ngc = &mm_gc->gc;\r\nmm_gc->save_regs = cpm1_gpio16_save_regs;\r\ngc->ngpio = 16;\r\ngc->direction_input = cpm1_gpio16_dir_in;\r\ngc->direction_output = cpm1_gpio16_dir_out;\r\ngc->get = cpm1_gpio16_get;\r\ngc->set = cpm1_gpio16_set;\r\nreturn of_mm_gpiochip_add(np, mm_gc);\r\n}\r\nstatic inline struct cpm1_gpio32_chip *\r\nto_cpm1_gpio32_chip(struct of_mm_gpio_chip *mm_gc)\r\n{\r\nreturn container_of(mm_gc, struct cpm1_gpio32_chip, mm_gc);\r\n}\r\nstatic void cpm1_gpio32_save_regs(struct of_mm_gpio_chip *mm_gc)\r\n{\r\nstruct cpm1_gpio32_chip *cpm1_gc = to_cpm1_gpio32_chip(mm_gc);\r\nstruct cpm_ioport32b __iomem *iop = mm_gc->regs;\r\ncpm1_gc->cpdata = in_be32(&iop->dat);\r\n}\r\nstatic int cpm1_gpio32_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct cpm_ioport32b __iomem *iop = mm_gc->regs;\r\nu32 pin_mask;\r\npin_mask = 1 << (31 - gpio);\r\nreturn !!(in_be32(&iop->dat) & pin_mask);\r\n}\r\nstatic void __cpm1_gpio32_set(struct of_mm_gpio_chip *mm_gc, u32 pin_mask,\r\nint value)\r\n{\r\nstruct cpm1_gpio32_chip *cpm1_gc = to_cpm1_gpio32_chip(mm_gc);\r\nstruct cpm_ioport32b __iomem *iop = mm_gc->regs;\r\nif (value)\r\ncpm1_gc->cpdata |= pin_mask;\r\nelse\r\ncpm1_gc->cpdata &= ~pin_mask;\r\nout_be32(&iop->dat, cpm1_gc->cpdata);\r\n}\r\nstatic void cpm1_gpio32_set(struct gpio_chip *gc, unsigned int gpio, int value)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct cpm1_gpio32_chip *cpm1_gc = to_cpm1_gpio32_chip(mm_gc);\r\nunsigned long flags;\r\nu32 pin_mask = 1 << (31 - gpio);\r\nspin_lock_irqsave(&cpm1_gc->lock, flags);\r\n__cpm1_gpio32_set(mm_gc, pin_mask, value);\r\nspin_unlock_irqrestore(&cpm1_gc->lock, flags);\r\n}\r\nstatic int cpm1_gpio32_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct cpm1_gpio32_chip *cpm1_gc = to_cpm1_gpio32_chip(mm_gc);\r\nstruct cpm_ioport32b __iomem *iop = mm_gc->regs;\r\nunsigned long flags;\r\nu32 pin_mask = 1 << (31 - gpio);\r\nspin_lock_irqsave(&cpm1_gc->lock, flags);\r\nsetbits32(&iop->dir, pin_mask);\r\n__cpm1_gpio32_set(mm_gc, pin_mask, val);\r\nspin_unlock_irqrestore(&cpm1_gc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cpm1_gpio32_dir_in(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct cpm1_gpio32_chip *cpm1_gc = to_cpm1_gpio32_chip(mm_gc);\r\nstruct cpm_ioport32b __iomem *iop = mm_gc->regs;\r\nunsigned long flags;\r\nu32 pin_mask = 1 << (31 - gpio);\r\nspin_lock_irqsave(&cpm1_gc->lock, flags);\r\nclrbits32(&iop->dir, pin_mask);\r\nspin_unlock_irqrestore(&cpm1_gc->lock, flags);\r\nreturn 0;\r\n}\r\nint cpm1_gpiochip_add32(struct device_node *np)\r\n{\r\nstruct cpm1_gpio32_chip *cpm1_gc;\r\nstruct of_mm_gpio_chip *mm_gc;\r\nstruct gpio_chip *gc;\r\ncpm1_gc = kzalloc(sizeof(*cpm1_gc), GFP_KERNEL);\r\nif (!cpm1_gc)\r\nreturn -ENOMEM;\r\nspin_lock_init(&cpm1_gc->lock);\r\nmm_gc = &cpm1_gc->mm_gc;\r\ngc = &mm_gc->gc;\r\nmm_gc->save_regs = cpm1_gpio32_save_regs;\r\ngc->ngpio = 32;\r\ngc->direction_input = cpm1_gpio32_dir_in;\r\ngc->direction_output = cpm1_gpio32_dir_out;\r\ngc->get = cpm1_gpio32_get;\r\ngc->set = cpm1_gpio32_set;\r\nreturn of_mm_gpiochip_add(np, mm_gc);\r\n}\r\nstatic int cpm_init_par_io(void)\r\n{\r\nstruct device_node *np;\r\nfor_each_compatible_node(np, NULL, "fsl,cpm1-pario-bank-a")\r\ncpm1_gpiochip_add16(np);\r\nfor_each_compatible_node(np, NULL, "fsl,cpm1-pario-bank-b")\r\ncpm1_gpiochip_add32(np);\r\nfor_each_compatible_node(np, NULL, "fsl,cpm1-pario-bank-c")\r\ncpm1_gpiochip_add16(np);\r\nfor_each_compatible_node(np, NULL, "fsl,cpm1-pario-bank-d")\r\ncpm1_gpiochip_add16(np);\r\nfor_each_compatible_node(np, NULL, "fsl,cpm1-pario-bank-e")\r\ncpm2_gpiochip_add32(np);\r\nreturn 0;\r\n}
