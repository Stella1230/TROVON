static struct v4l2_m2m_queue_ctx *get_queue_ctx(struct v4l2_m2m_ctx *m2m_ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nif (V4L2_TYPE_IS_OUTPUT(type))\r\nreturn &m2m_ctx->out_q_ctx;\r\nelse\r\nreturn &m2m_ctx->cap_q_ctx;\r\n}\r\nstruct vb2_queue *v4l2_m2m_get_vq(struct v4l2_m2m_ctx *m2m_ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct v4l2_m2m_queue_ctx *q_ctx;\r\nq_ctx = get_queue_ctx(m2m_ctx, type);\r\nif (!q_ctx)\r\nreturn NULL;\r\nreturn &q_ctx->q;\r\n}\r\nvoid *v4l2_m2m_next_buf(struct v4l2_m2m_queue_ctx *q_ctx)\r\n{\r\nstruct v4l2_m2m_buffer *b = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&q_ctx->rdy_spinlock, flags);\r\nif (list_empty(&q_ctx->rdy_queue)) {\r\nspin_unlock_irqrestore(&q_ctx->rdy_spinlock, flags);\r\nreturn NULL;\r\n}\r\nb = list_entry(q_ctx->rdy_queue.next, struct v4l2_m2m_buffer, list);\r\nspin_unlock_irqrestore(&q_ctx->rdy_spinlock, flags);\r\nreturn &b->vb;\r\n}\r\nvoid *v4l2_m2m_buf_remove(struct v4l2_m2m_queue_ctx *q_ctx)\r\n{\r\nstruct v4l2_m2m_buffer *b = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&q_ctx->rdy_spinlock, flags);\r\nif (list_empty(&q_ctx->rdy_queue)) {\r\nspin_unlock_irqrestore(&q_ctx->rdy_spinlock, flags);\r\nreturn NULL;\r\n}\r\nb = list_entry(q_ctx->rdy_queue.next, struct v4l2_m2m_buffer, list);\r\nlist_del(&b->list);\r\nq_ctx->num_rdy--;\r\nspin_unlock_irqrestore(&q_ctx->rdy_spinlock, flags);\r\nreturn &b->vb;\r\n}\r\nvoid *v4l2_m2m_get_curr_priv(struct v4l2_m2m_dev *m2m_dev)\r\n{\r\nunsigned long flags;\r\nvoid *ret = NULL;\r\nspin_lock_irqsave(&m2m_dev->job_spinlock, flags);\r\nif (m2m_dev->curr_ctx)\r\nret = m2m_dev->curr_ctx->priv;\r\nspin_unlock_irqrestore(&m2m_dev->job_spinlock, flags);\r\nreturn ret;\r\n}\r\nstatic void v4l2_m2m_try_run(struct v4l2_m2m_dev *m2m_dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&m2m_dev->job_spinlock, flags);\r\nif (NULL != m2m_dev->curr_ctx) {\r\nspin_unlock_irqrestore(&m2m_dev->job_spinlock, flags);\r\ndprintk("Another instance is running, won't run now\n");\r\nreturn;\r\n}\r\nif (list_empty(&m2m_dev->job_queue)) {\r\nspin_unlock_irqrestore(&m2m_dev->job_spinlock, flags);\r\ndprintk("No job pending\n");\r\nreturn;\r\n}\r\nm2m_dev->curr_ctx = list_entry(m2m_dev->job_queue.next,\r\nstruct v4l2_m2m_ctx, queue);\r\nm2m_dev->curr_ctx->job_flags |= TRANS_RUNNING;\r\nspin_unlock_irqrestore(&m2m_dev->job_spinlock, flags);\r\nm2m_dev->m2m_ops->device_run(m2m_dev->curr_ctx->priv);\r\n}\r\nstatic void v4l2_m2m_try_schedule(struct v4l2_m2m_ctx *m2m_ctx)\r\n{\r\nstruct v4l2_m2m_dev *m2m_dev;\r\nunsigned long flags_job, flags;\r\nm2m_dev = m2m_ctx->m2m_dev;\r\ndprintk("Trying to schedule a job for m2m_ctx: %p\n", m2m_ctx);\r\nif (!m2m_ctx->out_q_ctx.q.streaming\r\n|| !m2m_ctx->cap_q_ctx.q.streaming) {\r\ndprintk("Streaming needs to be on for both queues\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&m2m_dev->job_spinlock, flags_job);\r\nif (m2m_ctx->job_flags & TRANS_QUEUED) {\r\nspin_unlock_irqrestore(&m2m_dev->job_spinlock, flags_job);\r\ndprintk("On job queue already\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&m2m_ctx->out_q_ctx.rdy_spinlock, flags);\r\nif (list_empty(&m2m_ctx->out_q_ctx.rdy_queue)) {\r\nspin_unlock_irqrestore(&m2m_ctx->out_q_ctx.rdy_spinlock, flags);\r\nspin_unlock_irqrestore(&m2m_dev->job_spinlock, flags_job);\r\ndprintk("No input buffers available\n");\r\nreturn;\r\n}\r\nif (list_empty(&m2m_ctx->cap_q_ctx.rdy_queue)) {\r\nspin_unlock_irqrestore(&m2m_ctx->out_q_ctx.rdy_spinlock, flags);\r\nspin_unlock_irqrestore(&m2m_dev->job_spinlock, flags_job);\r\ndprintk("No output buffers available\n");\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&m2m_ctx->out_q_ctx.rdy_spinlock, flags);\r\nif (m2m_dev->m2m_ops->job_ready\r\n&& (!m2m_dev->m2m_ops->job_ready(m2m_ctx->priv))) {\r\nspin_unlock_irqrestore(&m2m_dev->job_spinlock, flags_job);\r\ndprintk("Driver not ready\n");\r\nreturn;\r\n}\r\nlist_add_tail(&m2m_ctx->queue, &m2m_dev->job_queue);\r\nm2m_ctx->job_flags |= TRANS_QUEUED;\r\nspin_unlock_irqrestore(&m2m_dev->job_spinlock, flags_job);\r\nv4l2_m2m_try_run(m2m_dev);\r\n}\r\nvoid v4l2_m2m_job_finish(struct v4l2_m2m_dev *m2m_dev,\r\nstruct v4l2_m2m_ctx *m2m_ctx)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&m2m_dev->job_spinlock, flags);\r\nif (!m2m_dev->curr_ctx || m2m_dev->curr_ctx != m2m_ctx) {\r\nspin_unlock_irqrestore(&m2m_dev->job_spinlock, flags);\r\ndprintk("Called by an instance not currently running\n");\r\nreturn;\r\n}\r\nlist_del(&m2m_dev->curr_ctx->queue);\r\nm2m_dev->curr_ctx->job_flags &= ~(TRANS_QUEUED | TRANS_RUNNING);\r\nwake_up(&m2m_dev->curr_ctx->finished);\r\nm2m_dev->curr_ctx = NULL;\r\nspin_unlock_irqrestore(&m2m_dev->job_spinlock, flags);\r\nv4l2_m2m_try_schedule(m2m_ctx);\r\nv4l2_m2m_try_run(m2m_dev);\r\n}\r\nint v4l2_m2m_reqbufs(struct file *file, struct v4l2_m2m_ctx *m2m_ctx,\r\nstruct v4l2_requestbuffers *reqbufs)\r\n{\r\nstruct vb2_queue *vq;\r\nvq = v4l2_m2m_get_vq(m2m_ctx, reqbufs->type);\r\nreturn vb2_reqbufs(vq, reqbufs);\r\n}\r\nint v4l2_m2m_querybuf(struct file *file, struct v4l2_m2m_ctx *m2m_ctx,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct vb2_queue *vq;\r\nint ret = 0;\r\nunsigned int i;\r\nvq = v4l2_m2m_get_vq(m2m_ctx, buf->type);\r\nret = vb2_querybuf(vq, buf);\r\nif (buf->memory == V4L2_MEMORY_MMAP && !V4L2_TYPE_IS_OUTPUT(vq->type)) {\r\nif (V4L2_TYPE_IS_MULTIPLANAR(vq->type)) {\r\nfor (i = 0; i < buf->length; ++i)\r\nbuf->m.planes[i].m.mem_offset\r\n+= DST_QUEUE_OFF_BASE;\r\n} else {\r\nbuf->m.offset += DST_QUEUE_OFF_BASE;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint v4l2_m2m_qbuf(struct file *file, struct v4l2_m2m_ctx *m2m_ctx,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct vb2_queue *vq;\r\nint ret;\r\nvq = v4l2_m2m_get_vq(m2m_ctx, buf->type);\r\nret = vb2_qbuf(vq, buf);\r\nif (!ret)\r\nv4l2_m2m_try_schedule(m2m_ctx);\r\nreturn ret;\r\n}\r\nint v4l2_m2m_dqbuf(struct file *file, struct v4l2_m2m_ctx *m2m_ctx,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct vb2_queue *vq;\r\nvq = v4l2_m2m_get_vq(m2m_ctx, buf->type);\r\nreturn vb2_dqbuf(vq, buf, file->f_flags & O_NONBLOCK);\r\n}\r\nint v4l2_m2m_streamon(struct file *file, struct v4l2_m2m_ctx *m2m_ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct vb2_queue *vq;\r\nint ret;\r\nvq = v4l2_m2m_get_vq(m2m_ctx, type);\r\nret = vb2_streamon(vq, type);\r\nif (!ret)\r\nv4l2_m2m_try_schedule(m2m_ctx);\r\nreturn ret;\r\n}\r\nint v4l2_m2m_streamoff(struct file *file, struct v4l2_m2m_ctx *m2m_ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct vb2_queue *vq;\r\nvq = v4l2_m2m_get_vq(m2m_ctx, type);\r\nreturn vb2_streamoff(vq, type);\r\n}\r\nunsigned int v4l2_m2m_poll(struct file *file, struct v4l2_m2m_ctx *m2m_ctx,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct vb2_queue *src_q, *dst_q;\r\nstruct vb2_buffer *src_vb = NULL, *dst_vb = NULL;\r\nunsigned int rc = 0;\r\nunsigned long flags;\r\nsrc_q = v4l2_m2m_get_src_vq(m2m_ctx);\r\ndst_q = v4l2_m2m_get_dst_vq(m2m_ctx);\r\nif ((!src_q->streaming || list_empty(&src_q->queued_list))\r\n&& (!dst_q->streaming || list_empty(&dst_q->queued_list))) {\r\nrc = POLLERR;\r\ngoto end;\r\n}\r\nif (m2m_ctx->m2m_dev->m2m_ops->unlock)\r\nm2m_ctx->m2m_dev->m2m_ops->unlock(m2m_ctx->priv);\r\npoll_wait(file, &src_q->done_wq, wait);\r\npoll_wait(file, &dst_q->done_wq, wait);\r\nif (m2m_ctx->m2m_dev->m2m_ops->lock)\r\nm2m_ctx->m2m_dev->m2m_ops->lock(m2m_ctx->priv);\r\nspin_lock_irqsave(&src_q->done_lock, flags);\r\nif (!list_empty(&src_q->done_list))\r\nsrc_vb = list_first_entry(&src_q->done_list, struct vb2_buffer,\r\ndone_entry);\r\nif (src_vb && (src_vb->state == VB2_BUF_STATE_DONE\r\n|| src_vb->state == VB2_BUF_STATE_ERROR))\r\nrc |= POLLOUT | POLLWRNORM;\r\nspin_unlock_irqrestore(&src_q->done_lock, flags);\r\nspin_lock_irqsave(&dst_q->done_lock, flags);\r\nif (!list_empty(&dst_q->done_list))\r\ndst_vb = list_first_entry(&dst_q->done_list, struct vb2_buffer,\r\ndone_entry);\r\nif (dst_vb && (dst_vb->state == VB2_BUF_STATE_DONE\r\n|| dst_vb->state == VB2_BUF_STATE_ERROR))\r\nrc |= POLLIN | POLLRDNORM;\r\nspin_unlock_irqrestore(&dst_q->done_lock, flags);\r\nend:\r\nreturn rc;\r\n}\r\nint v4l2_m2m_mmap(struct file *file, struct v4l2_m2m_ctx *m2m_ctx,\r\nstruct vm_area_struct *vma)\r\n{\r\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\r\nstruct vb2_queue *vq;\r\nif (offset < DST_QUEUE_OFF_BASE) {\r\nvq = v4l2_m2m_get_src_vq(m2m_ctx);\r\n} else {\r\nvq = v4l2_m2m_get_dst_vq(m2m_ctx);\r\nvma->vm_pgoff -= (DST_QUEUE_OFF_BASE >> PAGE_SHIFT);\r\n}\r\nreturn vb2_mmap(vq, vma);\r\n}\r\nstruct v4l2_m2m_dev *v4l2_m2m_init(struct v4l2_m2m_ops *m2m_ops)\r\n{\r\nstruct v4l2_m2m_dev *m2m_dev;\r\nif (!m2m_ops)\r\nreturn ERR_PTR(-EINVAL);\r\nBUG_ON(!m2m_ops->device_run);\r\nBUG_ON(!m2m_ops->job_abort);\r\nm2m_dev = kzalloc(sizeof *m2m_dev, GFP_KERNEL);\r\nif (!m2m_dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nm2m_dev->curr_ctx = NULL;\r\nm2m_dev->m2m_ops = m2m_ops;\r\nINIT_LIST_HEAD(&m2m_dev->job_queue);\r\nspin_lock_init(&m2m_dev->job_spinlock);\r\nreturn m2m_dev;\r\n}\r\nvoid v4l2_m2m_release(struct v4l2_m2m_dev *m2m_dev)\r\n{\r\nkfree(m2m_dev);\r\n}\r\nstruct v4l2_m2m_ctx *v4l2_m2m_ctx_init(struct v4l2_m2m_dev *m2m_dev,\r\nvoid *drv_priv,\r\nint (*queue_init)(void *priv, struct vb2_queue *src_vq, struct vb2_queue *dst_vq))\r\n{\r\nstruct v4l2_m2m_ctx *m2m_ctx;\r\nstruct v4l2_m2m_queue_ctx *out_q_ctx, *cap_q_ctx;\r\nint ret;\r\nm2m_ctx = kzalloc(sizeof *m2m_ctx, GFP_KERNEL);\r\nif (!m2m_ctx)\r\nreturn ERR_PTR(-ENOMEM);\r\nm2m_ctx->priv = drv_priv;\r\nm2m_ctx->m2m_dev = m2m_dev;\r\ninit_waitqueue_head(&m2m_ctx->finished);\r\nout_q_ctx = &m2m_ctx->out_q_ctx;\r\ncap_q_ctx = &m2m_ctx->cap_q_ctx;\r\nINIT_LIST_HEAD(&out_q_ctx->rdy_queue);\r\nINIT_LIST_HEAD(&cap_q_ctx->rdy_queue);\r\nspin_lock_init(&out_q_ctx->rdy_spinlock);\r\nspin_lock_init(&cap_q_ctx->rdy_spinlock);\r\nINIT_LIST_HEAD(&m2m_ctx->queue);\r\nret = queue_init(drv_priv, &out_q_ctx->q, &cap_q_ctx->q);\r\nif (ret)\r\ngoto err;\r\nreturn m2m_ctx;\r\nerr:\r\nkfree(m2m_ctx);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid v4l2_m2m_ctx_release(struct v4l2_m2m_ctx *m2m_ctx)\r\n{\r\nstruct v4l2_m2m_dev *m2m_dev;\r\nunsigned long flags;\r\nm2m_dev = m2m_ctx->m2m_dev;\r\nspin_lock_irqsave(&m2m_dev->job_spinlock, flags);\r\nif (m2m_ctx->job_flags & TRANS_RUNNING) {\r\nspin_unlock_irqrestore(&m2m_dev->job_spinlock, flags);\r\nm2m_dev->m2m_ops->job_abort(m2m_ctx->priv);\r\ndprintk("m2m_ctx %p running, will wait to complete", m2m_ctx);\r\nwait_event(m2m_ctx->finished, !(m2m_ctx->job_flags & TRANS_RUNNING));\r\n} else if (m2m_ctx->job_flags & TRANS_QUEUED) {\r\nlist_del(&m2m_ctx->queue);\r\nm2m_ctx->job_flags &= ~(TRANS_QUEUED | TRANS_RUNNING);\r\nspin_unlock_irqrestore(&m2m_dev->job_spinlock, flags);\r\ndprintk("m2m_ctx: %p had been on queue and was removed\n",\r\nm2m_ctx);\r\n} else {\r\nspin_unlock_irqrestore(&m2m_dev->job_spinlock, flags);\r\n}\r\nvb2_queue_release(&m2m_ctx->cap_q_ctx.q);\r\nvb2_queue_release(&m2m_ctx->out_q_ctx.q);\r\nkfree(m2m_ctx);\r\n}\r\nvoid v4l2_m2m_buf_queue(struct v4l2_m2m_ctx *m2m_ctx, struct vb2_buffer *vb)\r\n{\r\nstruct v4l2_m2m_buffer *b = container_of(vb, struct v4l2_m2m_buffer, vb);\r\nstruct v4l2_m2m_queue_ctx *q_ctx;\r\nunsigned long flags;\r\nq_ctx = get_queue_ctx(m2m_ctx, vb->vb2_queue->type);\r\nif (!q_ctx)\r\nreturn;\r\nspin_lock_irqsave(&q_ctx->rdy_spinlock, flags);\r\nlist_add_tail(&b->list, &q_ctx->rdy_queue);\r\nq_ctx->num_rdy++;\r\nspin_unlock_irqrestore(&q_ctx->rdy_spinlock, flags);\r\n}
