int ivtv_buf_copy_from_user(struct ivtv_stream *s, struct ivtv_buffer *buf, const char __user *src, int copybytes)\r\n{\r\nif (s->buf_size - buf->bytesused < copybytes)\r\ncopybytes = s->buf_size - buf->bytesused;\r\nif (copy_from_user(buf->buf + buf->bytesused, src, copybytes)) {\r\nreturn -EFAULT;\r\n}\r\nbuf->bytesused += copybytes;\r\nreturn copybytes;\r\n}\r\nvoid ivtv_buf_swap(struct ivtv_buffer *buf)\r\n{\r\nint i;\r\nfor (i = 0; i < buf->bytesused; i += 4)\r\nswab32s((u32 *)(buf->buf + i));\r\n}\r\nvoid ivtv_queue_init(struct ivtv_queue *q)\r\n{\r\nINIT_LIST_HEAD(&q->list);\r\nq->buffers = 0;\r\nq->length = 0;\r\nq->bytesused = 0;\r\n}\r\nvoid ivtv_enqueue(struct ivtv_stream *s, struct ivtv_buffer *buf, struct ivtv_queue *q)\r\n{\r\nunsigned long flags;\r\nif (q == &s->q_free) {\r\nbuf->bytesused = 0;\r\nbuf->readpos = 0;\r\nbuf->b_flags = 0;\r\nbuf->dma_xfer_cnt = 0;\r\n}\r\nspin_lock_irqsave(&s->qlock, flags);\r\nlist_add_tail(&buf->list, &q->list);\r\nq->buffers++;\r\nq->length += s->buf_size;\r\nq->bytesused += buf->bytesused - buf->readpos;\r\nspin_unlock_irqrestore(&s->qlock, flags);\r\n}\r\nstruct ivtv_buffer *ivtv_dequeue(struct ivtv_stream *s, struct ivtv_queue *q)\r\n{\r\nstruct ivtv_buffer *buf = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->qlock, flags);\r\nif (!list_empty(&q->list)) {\r\nbuf = list_entry(q->list.next, struct ivtv_buffer, list);\r\nlist_del_init(q->list.next);\r\nq->buffers--;\r\nq->length -= s->buf_size;\r\nq->bytesused -= buf->bytesused - buf->readpos;\r\n}\r\nspin_unlock_irqrestore(&s->qlock, flags);\r\nreturn buf;\r\n}\r\nstatic void ivtv_queue_move_buf(struct ivtv_stream *s, struct ivtv_queue *from,\r\nstruct ivtv_queue *to, int clear)\r\n{\r\nstruct ivtv_buffer *buf = list_entry(from->list.next, struct ivtv_buffer, list);\r\nlist_move_tail(from->list.next, &to->list);\r\nfrom->buffers--;\r\nfrom->length -= s->buf_size;\r\nfrom->bytesused -= buf->bytesused - buf->readpos;\r\nif (clear)\r\nbuf->bytesused = buf->readpos = buf->b_flags = buf->dma_xfer_cnt = 0;\r\nto->buffers++;\r\nto->length += s->buf_size;\r\nto->bytesused += buf->bytesused - buf->readpos;\r\n}\r\nint ivtv_queue_move(struct ivtv_stream *s, struct ivtv_queue *from, struct ivtv_queue *steal,\r\nstruct ivtv_queue *to, int needed_bytes)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\nint from_free = from == &s->q_free;\r\nint to_free = to == &s->q_free;\r\nint bytes_available, bytes_steal;\r\nspin_lock_irqsave(&s->qlock, flags);\r\nif (needed_bytes == 0) {\r\nfrom_free = 1;\r\nneeded_bytes = from->length;\r\n}\r\nbytes_available = from_free ? from->length : from->bytesused;\r\nbytes_steal = (from_free && steal) ? steal->length : 0;\r\nif (bytes_available + bytes_steal < needed_bytes) {\r\nspin_unlock_irqrestore(&s->qlock, flags);\r\nreturn -ENOMEM;\r\n}\r\nwhile (bytes_available < needed_bytes) {\r\nstruct ivtv_buffer *buf = list_entry(steal->list.prev, struct ivtv_buffer, list);\r\nu16 dma_xfer_cnt = buf->dma_xfer_cnt;\r\nwhile (dma_xfer_cnt == buf->dma_xfer_cnt) {\r\nlist_move_tail(steal->list.prev, &from->list);\r\nrc++;\r\nsteal->buffers--;\r\nsteal->length -= s->buf_size;\r\nsteal->bytesused -= buf->bytesused - buf->readpos;\r\nbuf->bytesused = buf->readpos = buf->b_flags = buf->dma_xfer_cnt = 0;\r\nfrom->buffers++;\r\nfrom->length += s->buf_size;\r\nbytes_available += s->buf_size;\r\nif (list_empty(&steal->list))\r\nbreak;\r\nbuf = list_entry(steal->list.prev, struct ivtv_buffer, list);\r\n}\r\n}\r\nif (from_free) {\r\nu32 old_length = to->length;\r\nwhile (to->length - old_length < needed_bytes) {\r\nivtv_queue_move_buf(s, from, to, 1);\r\n}\r\n}\r\nelse {\r\nu32 old_bytesused = to->bytesused;\r\nwhile (to->bytesused - old_bytesused < needed_bytes) {\r\nivtv_queue_move_buf(s, from, to, to_free);\r\n}\r\n}\r\nspin_unlock_irqrestore(&s->qlock, flags);\r\nreturn rc;\r\n}\r\nvoid ivtv_flush_queues(struct ivtv_stream *s)\r\n{\r\nivtv_queue_move(s, &s->q_io, NULL, &s->q_free, 0);\r\nivtv_queue_move(s, &s->q_full, NULL, &s->q_free, 0);\r\nivtv_queue_move(s, &s->q_dma, NULL, &s->q_free, 0);\r\nivtv_queue_move(s, &s->q_predma, NULL, &s->q_free, 0);\r\n}\r\nint ivtv_stream_alloc(struct ivtv_stream *s)\r\n{\r\nstruct ivtv *itv = s->itv;\r\nint SGsize = sizeof(struct ivtv_sg_host_element) * s->buffers;\r\nint i;\r\nif (s->buffers == 0)\r\nreturn 0;\r\nIVTV_DEBUG_INFO("Allocate %s%s stream: %d x %d buffers (%dkB total)\n",\r\ns->dma != PCI_DMA_NONE ? "DMA " : "",\r\ns->name, s->buffers, s->buf_size, s->buffers * s->buf_size / 1024);\r\ns->sg_pending = kzalloc(SGsize, GFP_KERNEL|__GFP_NOWARN);\r\nif (s->sg_pending == NULL) {\r\nIVTV_ERR("Could not allocate sg_pending for %s stream\n", s->name);\r\nreturn -ENOMEM;\r\n}\r\ns->sg_pending_size = 0;\r\ns->sg_processing = kzalloc(SGsize, GFP_KERNEL|__GFP_NOWARN);\r\nif (s->sg_processing == NULL) {\r\nIVTV_ERR("Could not allocate sg_processing for %s stream\n", s->name);\r\nkfree(s->sg_pending);\r\ns->sg_pending = NULL;\r\nreturn -ENOMEM;\r\n}\r\ns->sg_processing_size = 0;\r\ns->sg_dma = kzalloc(sizeof(struct ivtv_sg_element),\r\nGFP_KERNEL|__GFP_NOWARN);\r\nif (s->sg_dma == NULL) {\r\nIVTV_ERR("Could not allocate sg_dma for %s stream\n", s->name);\r\nkfree(s->sg_pending);\r\ns->sg_pending = NULL;\r\nkfree(s->sg_processing);\r\ns->sg_processing = NULL;\r\nreturn -ENOMEM;\r\n}\r\nif (ivtv_might_use_dma(s)) {\r\ns->sg_handle = pci_map_single(itv->pdev, s->sg_dma,\r\nsizeof(struct ivtv_sg_element), PCI_DMA_TODEVICE);\r\nivtv_stream_sync_for_cpu(s);\r\n}\r\nfor (i = 0; i < s->buffers; i++) {\r\nstruct ivtv_buffer *buf = kzalloc(sizeof(struct ivtv_buffer),\r\nGFP_KERNEL|__GFP_NOWARN);\r\nif (buf == NULL)\r\nbreak;\r\nbuf->buf = kmalloc(s->buf_size + 256, GFP_KERNEL|__GFP_NOWARN);\r\nif (buf->buf == NULL) {\r\nkfree(buf);\r\nbreak;\r\n}\r\nINIT_LIST_HEAD(&buf->list);\r\nif (ivtv_might_use_dma(s)) {\r\nbuf->dma_handle = pci_map_single(s->itv->pdev,\r\nbuf->buf, s->buf_size + 256, s->dma);\r\nivtv_buf_sync_for_cpu(s, buf);\r\n}\r\nivtv_enqueue(s, buf, &s->q_free);\r\n}\r\nif (i == s->buffers)\r\nreturn 0;\r\nIVTV_ERR("Couldn't allocate buffers for %s stream\n", s->name);\r\nivtv_stream_free(s);\r\nreturn -ENOMEM;\r\n}\r\nvoid ivtv_stream_free(struct ivtv_stream *s)\r\n{\r\nstruct ivtv_buffer *buf;\r\nivtv_flush_queues(s);\r\nwhile ((buf = ivtv_dequeue(s, &s->q_free))) {\r\nif (ivtv_might_use_dma(s))\r\npci_unmap_single(s->itv->pdev, buf->dma_handle,\r\ns->buf_size + 256, s->dma);\r\nkfree(buf->buf);\r\nkfree(buf);\r\n}\r\nif (s->sg_dma != NULL) {\r\nif (s->sg_handle != IVTV_DMA_UNMAPPED) {\r\npci_unmap_single(s->itv->pdev, s->sg_handle,\r\nsizeof(struct ivtv_sg_element), PCI_DMA_TODEVICE);\r\ns->sg_handle = IVTV_DMA_UNMAPPED;\r\n}\r\nkfree(s->sg_pending);\r\nkfree(s->sg_processing);\r\nkfree(s->sg_dma);\r\ns->sg_pending = NULL;\r\ns->sg_processing = NULL;\r\ns->sg_dma = NULL;\r\ns->sg_pending_size = 0;\r\ns->sg_processing_size = 0;\r\n}\r\n}
