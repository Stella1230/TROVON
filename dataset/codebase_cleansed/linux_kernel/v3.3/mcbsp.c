static void omap_mcbsp_write(struct omap_mcbsp *mcbsp, u16 reg, u32 val)\r\n{\r\nvoid __iomem *addr = mcbsp->io_base + reg * mcbsp->pdata->reg_step;\r\nif (mcbsp->pdata->reg_size == 2) {\r\n((u16 *)mcbsp->reg_cache)[reg] = (u16)val;\r\n__raw_writew((u16)val, addr);\r\n} else {\r\n((u32 *)mcbsp->reg_cache)[reg] = val;\r\n__raw_writel(val, addr);\r\n}\r\n}\r\nstatic int omap_mcbsp_read(struct omap_mcbsp *mcbsp, u16 reg, bool from_cache)\r\n{\r\nvoid __iomem *addr = mcbsp->io_base + reg * mcbsp->pdata->reg_step;\r\nif (mcbsp->pdata->reg_size == 2) {\r\nreturn !from_cache ? __raw_readw(addr) :\r\n((u16 *)mcbsp->reg_cache)[reg];\r\n} else {\r\nreturn !from_cache ? __raw_readl(addr) :\r\n((u32 *)mcbsp->reg_cache)[reg];\r\n}\r\n}\r\nstatic void omap_mcbsp_st_write(struct omap_mcbsp *mcbsp, u16 reg, u32 val)\r\n{\r\n__raw_writel(val, mcbsp->st_data->io_base_st + reg);\r\n}\r\nstatic int omap_mcbsp_st_read(struct omap_mcbsp *mcbsp, u16 reg)\r\n{\r\nreturn __raw_readl(mcbsp->st_data->io_base_st + reg);\r\n}\r\nstatic void omap_mcbsp_dump_reg(u8 id)\r\n{\r\nstruct omap_mcbsp *mcbsp = id_to_mcbsp_ptr(id);\r\ndev_dbg(mcbsp->dev, "**** McBSP%d regs ****\n", mcbsp->id);\r\ndev_dbg(mcbsp->dev, "DRR2: 0x%04x\n",\r\nMCBSP_READ(mcbsp, DRR2));\r\ndev_dbg(mcbsp->dev, "DRR1: 0x%04x\n",\r\nMCBSP_READ(mcbsp, DRR1));\r\ndev_dbg(mcbsp->dev, "DXR2: 0x%04x\n",\r\nMCBSP_READ(mcbsp, DXR2));\r\ndev_dbg(mcbsp->dev, "DXR1: 0x%04x\n",\r\nMCBSP_READ(mcbsp, DXR1));\r\ndev_dbg(mcbsp->dev, "SPCR2: 0x%04x\n",\r\nMCBSP_READ(mcbsp, SPCR2));\r\ndev_dbg(mcbsp->dev, "SPCR1: 0x%04x\n",\r\nMCBSP_READ(mcbsp, SPCR1));\r\ndev_dbg(mcbsp->dev, "RCR2: 0x%04x\n",\r\nMCBSP_READ(mcbsp, RCR2));\r\ndev_dbg(mcbsp->dev, "RCR1: 0x%04x\n",\r\nMCBSP_READ(mcbsp, RCR1));\r\ndev_dbg(mcbsp->dev, "XCR2: 0x%04x\n",\r\nMCBSP_READ(mcbsp, XCR2));\r\ndev_dbg(mcbsp->dev, "XCR1: 0x%04x\n",\r\nMCBSP_READ(mcbsp, XCR1));\r\ndev_dbg(mcbsp->dev, "SRGR2: 0x%04x\n",\r\nMCBSP_READ(mcbsp, SRGR2));\r\ndev_dbg(mcbsp->dev, "SRGR1: 0x%04x\n",\r\nMCBSP_READ(mcbsp, SRGR1));\r\ndev_dbg(mcbsp->dev, "PCR0: 0x%04x\n",\r\nMCBSP_READ(mcbsp, PCR0));\r\ndev_dbg(mcbsp->dev, "***********************\n");\r\n}\r\nstatic irqreturn_t omap_mcbsp_tx_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct omap_mcbsp *mcbsp_tx = dev_id;\r\nu16 irqst_spcr2;\r\nirqst_spcr2 = MCBSP_READ(mcbsp_tx, SPCR2);\r\ndev_dbg(mcbsp_tx->dev, "TX IRQ callback : 0x%x\n", irqst_spcr2);\r\nif (irqst_spcr2 & XSYNC_ERR) {\r\ndev_err(mcbsp_tx->dev, "TX Frame Sync Error! : 0x%x\n",\r\nirqst_spcr2);\r\nMCBSP_WRITE(mcbsp_tx, SPCR2, MCBSP_READ_CACHE(mcbsp_tx, SPCR2));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t omap_mcbsp_rx_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct omap_mcbsp *mcbsp_rx = dev_id;\r\nu16 irqst_spcr1;\r\nirqst_spcr1 = MCBSP_READ(mcbsp_rx, SPCR1);\r\ndev_dbg(mcbsp_rx->dev, "RX IRQ callback : 0x%x\n", irqst_spcr1);\r\nif (irqst_spcr1 & RSYNC_ERR) {\r\ndev_err(mcbsp_rx->dev, "RX Frame Sync Error! : 0x%x\n",\r\nirqst_spcr1);\r\nMCBSP_WRITE(mcbsp_rx, SPCR1, MCBSP_READ_CACHE(mcbsp_rx, SPCR1));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid omap_mcbsp_config(unsigned int id, const struct omap_mcbsp_reg_cfg *config)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\ndev_dbg(mcbsp->dev, "Configuring McBSP%d phys_base: 0x%08lx\n",\r\nmcbsp->id, mcbsp->phys_base);\r\nMCBSP_WRITE(mcbsp, SPCR2, config->spcr2);\r\nMCBSP_WRITE(mcbsp, SPCR1, config->spcr1);\r\nMCBSP_WRITE(mcbsp, RCR2, config->rcr2);\r\nMCBSP_WRITE(mcbsp, RCR1, config->rcr1);\r\nMCBSP_WRITE(mcbsp, XCR2, config->xcr2);\r\nMCBSP_WRITE(mcbsp, XCR1, config->xcr1);\r\nMCBSP_WRITE(mcbsp, SRGR2, config->srgr2);\r\nMCBSP_WRITE(mcbsp, SRGR1, config->srgr1);\r\nMCBSP_WRITE(mcbsp, MCR2, config->mcr2);\r\nMCBSP_WRITE(mcbsp, MCR1, config->mcr1);\r\nMCBSP_WRITE(mcbsp, PCR0, config->pcr0);\r\nif (mcbsp->pdata->has_ccr) {\r\nMCBSP_WRITE(mcbsp, XCCR, config->xccr);\r\nMCBSP_WRITE(mcbsp, RCCR, config->rccr);\r\n}\r\n}\r\nint omap_mcbsp_dma_ch_params(unsigned int id, unsigned int stream)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn -ENODEV;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nif (stream)\r\nreturn mcbsp->dma_rx_sync;\r\nelse\r\nreturn mcbsp->dma_tx_sync;\r\n}\r\nint omap_mcbsp_dma_reg_params(unsigned int id, unsigned int stream)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nint data_reg;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn -ENODEV;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nif (mcbsp->pdata->reg_size == 2) {\r\nif (stream)\r\ndata_reg = OMAP_MCBSP_REG_DRR1;\r\nelse\r\ndata_reg = OMAP_MCBSP_REG_DXR1;\r\n} else {\r\nif (stream)\r\ndata_reg = OMAP_MCBSP_REG_DRR;\r\nelse\r\ndata_reg = OMAP_MCBSP_REG_DXR;\r\n}\r\nreturn mcbsp->phys_dma_base + data_reg * mcbsp->pdata->reg_step;\r\n}\r\nstatic void omap_st_on(struct omap_mcbsp *mcbsp)\r\n{\r\nunsigned int w;\r\nif (mcbsp->pdata->enable_st_clock)\r\nmcbsp->pdata->enable_st_clock(mcbsp->id, 1);\r\nw = MCBSP_READ(mcbsp, SSELCR);\r\nMCBSP_WRITE(mcbsp, SSELCR, w | SIDETONEEN);\r\nw = MCBSP_ST_READ(mcbsp, SSELCR);\r\nMCBSP_ST_WRITE(mcbsp, SSELCR, w | ST_SIDETONEEN);\r\n}\r\nstatic void omap_st_off(struct omap_mcbsp *mcbsp)\r\n{\r\nunsigned int w;\r\nw = MCBSP_ST_READ(mcbsp, SSELCR);\r\nMCBSP_ST_WRITE(mcbsp, SSELCR, w & ~(ST_SIDETONEEN));\r\nw = MCBSP_READ(mcbsp, SSELCR);\r\nMCBSP_WRITE(mcbsp, SSELCR, w & ~(SIDETONEEN));\r\nif (mcbsp->pdata->enable_st_clock)\r\nmcbsp->pdata->enable_st_clock(mcbsp->id, 0);\r\n}\r\nstatic void omap_st_fir_write(struct omap_mcbsp *mcbsp, s16 *fir)\r\n{\r\nu16 val, i;\r\nval = MCBSP_ST_READ(mcbsp, SSELCR);\r\nif (val & ST_COEFFWREN)\r\nMCBSP_ST_WRITE(mcbsp, SSELCR, val & ~(ST_COEFFWREN));\r\nMCBSP_ST_WRITE(mcbsp, SSELCR, val | ST_COEFFWREN);\r\nfor (i = 0; i < 128; i++)\r\nMCBSP_ST_WRITE(mcbsp, SFIRCR, fir[i]);\r\ni = 0;\r\nval = MCBSP_ST_READ(mcbsp, SSELCR);\r\nwhile (!(val & ST_COEFFWRDONE) && (++i < 1000))\r\nval = MCBSP_ST_READ(mcbsp, SSELCR);\r\nMCBSP_ST_WRITE(mcbsp, SSELCR, val & ~(ST_COEFFWREN));\r\nif (i == 1000)\r\ndev_err(mcbsp->dev, "McBSP FIR load error!\n");\r\n}\r\nstatic void omap_st_chgain(struct omap_mcbsp *mcbsp)\r\n{\r\nu16 w;\r\nstruct omap_mcbsp_st_data *st_data = mcbsp->st_data;\r\nw = MCBSP_ST_READ(mcbsp, SSELCR);\r\nMCBSP_ST_WRITE(mcbsp, SGAINCR, ST_CH0GAIN(st_data->ch0gain) | \\r\nST_CH1GAIN(st_data->ch1gain));\r\n}\r\nint omap_st_set_chgain(unsigned int id, int channel, s16 chgain)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nstruct omap_mcbsp_st_data *st_data;\r\nint ret = 0;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn -ENODEV;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nst_data = mcbsp->st_data;\r\nif (!st_data)\r\nreturn -ENOENT;\r\nspin_lock_irq(&mcbsp->lock);\r\nif (channel == 0)\r\nst_data->ch0gain = chgain;\r\nelse if (channel == 1)\r\nst_data->ch1gain = chgain;\r\nelse\r\nret = -EINVAL;\r\nif (st_data->enabled)\r\nomap_st_chgain(mcbsp);\r\nspin_unlock_irq(&mcbsp->lock);\r\nreturn ret;\r\n}\r\nint omap_st_get_chgain(unsigned int id, int channel, s16 *chgain)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nstruct omap_mcbsp_st_data *st_data;\r\nint ret = 0;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn -ENODEV;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nst_data = mcbsp->st_data;\r\nif (!st_data)\r\nreturn -ENOENT;\r\nspin_lock_irq(&mcbsp->lock);\r\nif (channel == 0)\r\n*chgain = st_data->ch0gain;\r\nelse if (channel == 1)\r\n*chgain = st_data->ch1gain;\r\nelse\r\nret = -EINVAL;\r\nspin_unlock_irq(&mcbsp->lock);\r\nreturn ret;\r\n}\r\nstatic int omap_st_start(struct omap_mcbsp *mcbsp)\r\n{\r\nstruct omap_mcbsp_st_data *st_data = mcbsp->st_data;\r\nif (st_data && st_data->enabled && !st_data->running) {\r\nomap_st_fir_write(mcbsp, st_data->taps);\r\nomap_st_chgain(mcbsp);\r\nif (!mcbsp->free) {\r\nomap_st_on(mcbsp);\r\nst_data->running = 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint omap_st_enable(unsigned int id)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nstruct omap_mcbsp_st_data *st_data;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn -ENODEV;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nst_data = mcbsp->st_data;\r\nif (!st_data)\r\nreturn -ENODEV;\r\nspin_lock_irq(&mcbsp->lock);\r\nst_data->enabled = 1;\r\nomap_st_start(mcbsp);\r\nspin_unlock_irq(&mcbsp->lock);\r\nreturn 0;\r\n}\r\nstatic int omap_st_stop(struct omap_mcbsp *mcbsp)\r\n{\r\nstruct omap_mcbsp_st_data *st_data = mcbsp->st_data;\r\nif (st_data && st_data->running) {\r\nif (!mcbsp->free) {\r\nomap_st_off(mcbsp);\r\nst_data->running = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint omap_st_disable(unsigned int id)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nstruct omap_mcbsp_st_data *st_data;\r\nint ret = 0;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn -ENODEV;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nst_data = mcbsp->st_data;\r\nif (!st_data)\r\nreturn -ENODEV;\r\nspin_lock_irq(&mcbsp->lock);\r\nomap_st_stop(mcbsp);\r\nst_data->enabled = 0;\r\nspin_unlock_irq(&mcbsp->lock);\r\nreturn ret;\r\n}\r\nint omap_st_is_enabled(unsigned int id)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nstruct omap_mcbsp_st_data *st_data;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn -ENODEV;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nst_data = mcbsp->st_data;\r\nif (!st_data)\r\nreturn -ENODEV;\r\nreturn st_data->enabled;\r\n}\r\nvoid omap_mcbsp_set_tx_threshold(unsigned int id, u16 threshold)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nif (mcbsp->pdata->buffer_size == 0)\r\nreturn;\r\nif (threshold && threshold <= mcbsp->max_tx_thres)\r\nMCBSP_WRITE(mcbsp, THRSH2, threshold - 1);\r\n}\r\nvoid omap_mcbsp_set_rx_threshold(unsigned int id, u16 threshold)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nif (mcbsp->pdata->buffer_size == 0)\r\nreturn;\r\nif (threshold && threshold <= mcbsp->max_rx_thres)\r\nMCBSP_WRITE(mcbsp, THRSH1, threshold - 1);\r\n}\r\nu16 omap_mcbsp_get_max_tx_threshold(unsigned int id)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn -ENODEV;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nreturn mcbsp->max_tx_thres;\r\n}\r\nu16 omap_mcbsp_get_max_rx_threshold(unsigned int id)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn -ENODEV;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nreturn mcbsp->max_rx_thres;\r\n}\r\nu16 omap_mcbsp_get_fifo_size(unsigned int id)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn -ENODEV;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nreturn mcbsp->pdata->buffer_size;\r\n}\r\nu16 omap_mcbsp_get_tx_delay(unsigned int id)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nu16 buffstat;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn -ENODEV;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nif (mcbsp->pdata->buffer_size == 0)\r\nreturn 0;\r\nbuffstat = MCBSP_READ(mcbsp, XBUFFSTAT);\r\nreturn mcbsp->pdata->buffer_size - buffstat;\r\n}\r\nu16 omap_mcbsp_get_rx_delay(unsigned int id)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nu16 buffstat, threshold;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn -ENODEV;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nif (mcbsp->pdata->buffer_size == 0)\r\nreturn 0;\r\nbuffstat = MCBSP_READ(mcbsp, RBUFFSTAT);\r\nthreshold = MCBSP_READ(mcbsp, THRSH1);\r\nif (threshold <= buffstat)\r\nreturn 0;\r\nelse\r\nreturn threshold - buffstat;\r\n}\r\nint omap_mcbsp_get_dma_op_mode(unsigned int id)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nint dma_op_mode;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%u)\n", __func__, id + 1);\r\nreturn -ENODEV;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\ndma_op_mode = mcbsp->dma_op_mode;\r\nreturn dma_op_mode;\r\n}\r\nint omap_mcbsp_request(unsigned int id)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nvoid *reg_cache;\r\nint err;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn -ENODEV;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nreg_cache = kzalloc(mcbsp->reg_cache_size, GFP_KERNEL);\r\nif (!reg_cache) {\r\nreturn -ENOMEM;\r\n}\r\nspin_lock(&mcbsp->lock);\r\nif (!mcbsp->free) {\r\ndev_err(mcbsp->dev, "McBSP%d is currently in use\n",\r\nmcbsp->id);\r\nerr = -EBUSY;\r\ngoto err_kfree;\r\n}\r\nmcbsp->free = false;\r\nmcbsp->reg_cache = reg_cache;\r\nspin_unlock(&mcbsp->lock);\r\nif (mcbsp->pdata && mcbsp->pdata->ops && mcbsp->pdata->ops->request)\r\nmcbsp->pdata->ops->request(id);\r\npm_runtime_get_sync(mcbsp->dev);\r\nif (mcbsp->pdata->has_wakeup)\r\nMCBSP_WRITE(mcbsp, WAKEUPEN, XRDYEN | RRDYEN);\r\nMCBSP_WRITE(mcbsp, SPCR1, 0);\r\nMCBSP_WRITE(mcbsp, SPCR2, 0);\r\nerr = request_irq(mcbsp->tx_irq, omap_mcbsp_tx_irq_handler,\r\n0, "McBSP", (void *)mcbsp);\r\nif (err != 0) {\r\ndev_err(mcbsp->dev, "Unable to request TX IRQ %d "\r\n"for McBSP%d\n", mcbsp->tx_irq,\r\nmcbsp->id);\r\ngoto err_clk_disable;\r\n}\r\nif (mcbsp->rx_irq) {\r\nerr = request_irq(mcbsp->rx_irq,\r\nomap_mcbsp_rx_irq_handler,\r\n0, "McBSP", (void *)mcbsp);\r\nif (err != 0) {\r\ndev_err(mcbsp->dev, "Unable to request RX IRQ %d "\r\n"for McBSP%d\n", mcbsp->rx_irq,\r\nmcbsp->id);\r\ngoto err_free_irq;\r\n}\r\n}\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(mcbsp->tx_irq, (void *)mcbsp);\r\nerr_clk_disable:\r\nif (mcbsp->pdata && mcbsp->pdata->ops && mcbsp->pdata->ops->free)\r\nmcbsp->pdata->ops->free(id);\r\nif (mcbsp->pdata->has_wakeup)\r\nMCBSP_WRITE(mcbsp, WAKEUPEN, 0);\r\npm_runtime_put_sync(mcbsp->dev);\r\nspin_lock(&mcbsp->lock);\r\nmcbsp->free = true;\r\nmcbsp->reg_cache = NULL;\r\nerr_kfree:\r\nspin_unlock(&mcbsp->lock);\r\nkfree(reg_cache);\r\nreturn err;\r\n}\r\nvoid omap_mcbsp_free(unsigned int id)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nvoid *reg_cache;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nif (mcbsp->pdata && mcbsp->pdata->ops && mcbsp->pdata->ops->free)\r\nmcbsp->pdata->ops->free(id);\r\nif (mcbsp->pdata->has_wakeup)\r\nMCBSP_WRITE(mcbsp, WAKEUPEN, 0);\r\npm_runtime_put_sync(mcbsp->dev);\r\nif (mcbsp->rx_irq)\r\nfree_irq(mcbsp->rx_irq, (void *)mcbsp);\r\nfree_irq(mcbsp->tx_irq, (void *)mcbsp);\r\nreg_cache = mcbsp->reg_cache;\r\nspin_lock(&mcbsp->lock);\r\nif (mcbsp->free)\r\ndev_err(mcbsp->dev, "McBSP%d was not reserved\n", mcbsp->id);\r\nelse\r\nmcbsp->free = true;\r\nmcbsp->reg_cache = NULL;\r\nspin_unlock(&mcbsp->lock);\r\nif (reg_cache)\r\nkfree(reg_cache);\r\n}\r\nvoid omap_mcbsp_start(unsigned int id, int tx, int rx)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nint enable_srg = 0;\r\nu16 w;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nif (mcbsp->st_data)\r\nomap_st_start(mcbsp);\r\nw = MCBSP_READ_CACHE(mcbsp, PCR0);\r\nif (w & (FSXM | FSRM | CLKXM | CLKRM))\r\nenable_srg = !((MCBSP_READ_CACHE(mcbsp, SPCR2) |\r\nMCBSP_READ_CACHE(mcbsp, SPCR1)) & 1);\r\nif (enable_srg) {\r\nw = MCBSP_READ_CACHE(mcbsp, SPCR2);\r\nMCBSP_WRITE(mcbsp, SPCR2, w | (1 << 6));\r\n}\r\ntx &= 1;\r\nw = MCBSP_READ_CACHE(mcbsp, SPCR2);\r\nMCBSP_WRITE(mcbsp, SPCR2, w | tx);\r\nrx &= 1;\r\nw = MCBSP_READ_CACHE(mcbsp, SPCR1);\r\nMCBSP_WRITE(mcbsp, SPCR1, w | rx);\r\nudelay(500);\r\nif (enable_srg) {\r\nw = MCBSP_READ_CACHE(mcbsp, SPCR2);\r\nMCBSP_WRITE(mcbsp, SPCR2, w | (1 << 7));\r\n}\r\nif (mcbsp->pdata->has_ccr) {\r\nw = MCBSP_READ_CACHE(mcbsp, XCCR);\r\nw &= ~(tx ? XDISABLE : 0);\r\nMCBSP_WRITE(mcbsp, XCCR, w);\r\nw = MCBSP_READ_CACHE(mcbsp, RCCR);\r\nw &= ~(rx ? RDISABLE : 0);\r\nMCBSP_WRITE(mcbsp, RCCR, w);\r\n}\r\nomap_mcbsp_dump_reg(id);\r\n}\r\nvoid omap_mcbsp_stop(unsigned int id, int tx, int rx)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nint idle;\r\nu16 w;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\nprintk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\ntx &= 1;\r\nif (mcbsp->pdata->has_ccr) {\r\nw = MCBSP_READ_CACHE(mcbsp, XCCR);\r\nw |= (tx ? XDISABLE : 0);\r\nMCBSP_WRITE(mcbsp, XCCR, w);\r\n}\r\nw = MCBSP_READ_CACHE(mcbsp, SPCR2);\r\nMCBSP_WRITE(mcbsp, SPCR2, w & ~tx);\r\nrx &= 1;\r\nif (mcbsp->pdata->has_ccr) {\r\nw = MCBSP_READ_CACHE(mcbsp, RCCR);\r\nw |= (rx ? RDISABLE : 0);\r\nMCBSP_WRITE(mcbsp, RCCR, w);\r\n}\r\nw = MCBSP_READ_CACHE(mcbsp, SPCR1);\r\nMCBSP_WRITE(mcbsp, SPCR1, w & ~rx);\r\nidle = !((MCBSP_READ_CACHE(mcbsp, SPCR2) |\r\nMCBSP_READ_CACHE(mcbsp, SPCR1)) & 1);\r\nif (idle) {\r\nw = MCBSP_READ_CACHE(mcbsp, SPCR2);\r\nMCBSP_WRITE(mcbsp, SPCR2, w & ~(1 << 6));\r\n}\r\nif (mcbsp->st_data)\r\nomap_st_stop(mcbsp);\r\n}\r\nint omap2_mcbsp_set_clks_src(u8 id, u8 fck_src_id)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nconst char *src;\r\nif (!omap_mcbsp_check_valid_id(id)) {\r\npr_err("%s: Invalid id (%d)\n", __func__, id + 1);\r\nreturn -EINVAL;\r\n}\r\nmcbsp = id_to_mcbsp_ptr(id);\r\nif (fck_src_id == MCBSP_CLKS_PAD_SRC)\r\nsrc = "clks_ext";\r\nelse if (fck_src_id == MCBSP_CLKS_PRCM_SRC)\r\nsrc = "clks_fclk";\r\nelse\r\nreturn -EINVAL;\r\nif (mcbsp->pdata->set_clk_src)\r\nreturn mcbsp->pdata->set_clk_src(mcbsp->dev, mcbsp->fclk, src);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nvoid omap2_mcbsp1_mux_clkr_src(u8 mux)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nconst char *src;\r\nif (mux == CLKR_SRC_CLKR)\r\nsrc = "clkr";\r\nelse if (mux == CLKR_SRC_CLKX)\r\nsrc = "clkx";\r\nelse\r\nreturn;\r\nmcbsp = id_to_mcbsp_ptr(0);\r\nif (mcbsp->pdata->mux_signal)\r\nmcbsp->pdata->mux_signal(mcbsp->dev, "clkr", src);\r\n}\r\nvoid omap2_mcbsp1_mux_fsr_src(u8 mux)\r\n{\r\nstruct omap_mcbsp *mcbsp;\r\nconst char *src;\r\nif (mux == FSR_SRC_FSR)\r\nsrc = "fsr";\r\nelse if (mux == FSR_SRC_FSX)\r\nsrc = "fsx";\r\nelse\r\nreturn;\r\nmcbsp = id_to_mcbsp_ptr(0);\r\nif (mcbsp->pdata->mux_signal)\r\nmcbsp->pdata->mux_signal(mcbsp->dev, "fsr", src);\r\n}\r\nstatic ssize_t dma_op_mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct omap_mcbsp *mcbsp = dev_get_drvdata(dev);\r\nint dma_op_mode, i = 0;\r\nssize_t len = 0;\r\nconst char * const *s;\r\ndma_op_mode = mcbsp->dma_op_mode;\r\nfor (s = &dma_op_modes[i]; i < ARRAY_SIZE(dma_op_modes); s++, i++) {\r\nif (dma_op_mode == i)\r\nlen += sprintf(buf + len, "[%s] ", *s);\r\nelse\r\nlen += sprintf(buf + len, "%s ", *s);\r\n}\r\nlen += sprintf(buf + len, "\n");\r\nreturn len;\r\n}\r\nstatic ssize_t dma_op_mode_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct omap_mcbsp *mcbsp = dev_get_drvdata(dev);\r\nconst char * const *s;\r\nint i = 0;\r\nfor (s = &dma_op_modes[i]; i < ARRAY_SIZE(dma_op_modes); s++, i++)\r\nif (sysfs_streq(buf, *s))\r\nbreak;\r\nif (i == ARRAY_SIZE(dma_op_modes))\r\nreturn -EINVAL;\r\nspin_lock_irq(&mcbsp->lock);\r\nif (!mcbsp->free) {\r\nsize = -EBUSY;\r\ngoto unlock;\r\n}\r\nmcbsp->dma_op_mode = i;\r\nunlock:\r\nspin_unlock_irq(&mcbsp->lock);\r\nreturn size;\r\n}\r\nstatic ssize_t st_taps_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct omap_mcbsp *mcbsp = dev_get_drvdata(dev);\r\nstruct omap_mcbsp_st_data *st_data = mcbsp->st_data;\r\nssize_t status = 0;\r\nint i;\r\nspin_lock_irq(&mcbsp->lock);\r\nfor (i = 0; i < st_data->nr_taps; i++)\r\nstatus += sprintf(&buf[status], (i ? ", %d" : "%d"),\r\nst_data->taps[i]);\r\nif (i)\r\nstatus += sprintf(&buf[status], "\n");\r\nspin_unlock_irq(&mcbsp->lock);\r\nreturn status;\r\n}\r\nstatic ssize_t st_taps_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct omap_mcbsp *mcbsp = dev_get_drvdata(dev);\r\nstruct omap_mcbsp_st_data *st_data = mcbsp->st_data;\r\nint val, tmp, status, i = 0;\r\nspin_lock_irq(&mcbsp->lock);\r\nmemset(st_data->taps, 0, sizeof(st_data->taps));\r\nst_data->nr_taps = 0;\r\ndo {\r\nstatus = sscanf(buf, "%d%n", &val, &tmp);\r\nif (status < 0 || status == 0) {\r\nsize = -EINVAL;\r\ngoto out;\r\n}\r\nif (val < -32768 || val > 32767) {\r\nsize = -EINVAL;\r\ngoto out;\r\n}\r\nst_data->taps[i++] = val;\r\nbuf += tmp;\r\nif (*buf != ',')\r\nbreak;\r\nbuf++;\r\n} while (1);\r\nst_data->nr_taps = i;\r\nout:\r\nspin_unlock_irq(&mcbsp->lock);\r\nreturn size;\r\n}\r\nstatic int __devinit omap_st_add(struct omap_mcbsp *mcbsp,\r\nstruct resource *res)\r\n{\r\nstruct omap_mcbsp_st_data *st_data;\r\nint err;\r\nst_data = kzalloc(sizeof(*mcbsp->st_data), GFP_KERNEL);\r\nif (!st_data) {\r\nerr = -ENOMEM;\r\ngoto err1;\r\n}\r\nst_data->io_base_st = ioremap(res->start, resource_size(res));\r\nif (!st_data->io_base_st) {\r\nerr = -ENOMEM;\r\ngoto err2;\r\n}\r\nerr = sysfs_create_group(&mcbsp->dev->kobj, &sidetone_attr_group);\r\nif (err)\r\ngoto err3;\r\nmcbsp->st_data = st_data;\r\nreturn 0;\r\nerr3:\r\niounmap(st_data->io_base_st);\r\nerr2:\r\nkfree(st_data);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void __devexit omap_st_remove(struct omap_mcbsp *mcbsp)\r\n{\r\nstruct omap_mcbsp_st_data *st_data = mcbsp->st_data;\r\nsysfs_remove_group(&mcbsp->dev->kobj, &sidetone_attr_group);\r\niounmap(st_data->io_base_st);\r\nkfree(st_data);\r\n}\r\nstatic int __devinit omap_mcbsp_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_mcbsp_platform_data *pdata = pdev->dev.platform_data;\r\nstruct omap_mcbsp *mcbsp;\r\nint id = pdev->id - 1;\r\nstruct resource *res;\r\nint ret = 0;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "McBSP device initialized without"\r\n"platform data\n");\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\ndev_dbg(&pdev->dev, "Initializing OMAP McBSP (%d).\n", pdev->id);\r\nif (id >= omap_mcbsp_count) {\r\ndev_err(&pdev->dev, "Invalid McBSP device id (%d)\n", id);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nmcbsp = kzalloc(sizeof(struct omap_mcbsp), GFP_KERNEL);\r\nif (!mcbsp) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nspin_lock_init(&mcbsp->lock);\r\nmcbsp->id = id + 1;\r\nmcbsp->free = true;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mpu");\r\nif (!res) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "%s:mcbsp%d has invalid memory"\r\n"resource\n", __func__, pdev->id);\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\n}\r\nmcbsp->phys_base = res->start;\r\nmcbsp->reg_cache_size = resource_size(res);\r\nmcbsp->io_base = ioremap(res->start, resource_size(res));\r\nif (!mcbsp->io_base) {\r\nret = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dma");\r\nif (!res)\r\nmcbsp->phys_dma_base = mcbsp->phys_base;\r\nelse\r\nmcbsp->phys_dma_base = res->start;\r\nmcbsp->tx_irq = platform_get_irq_byname(pdev, "tx");\r\nmcbsp->rx_irq = platform_get_irq_byname(pdev, "rx");\r\nif (mcbsp->tx_irq == -ENXIO)\r\nmcbsp->tx_irq = platform_get_irq(pdev, 0);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_DMA, "rx");\r\nif (!res) {\r\ndev_err(&pdev->dev, "%s:mcbsp%d has invalid rx DMA channel\n",\r\n__func__, pdev->id);\r\nret = -ENODEV;\r\ngoto err_res;\r\n}\r\nmcbsp->dma_rx_sync = res->start;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_DMA, "tx");\r\nif (!res) {\r\ndev_err(&pdev->dev, "%s:mcbsp%d has invalid tx DMA channel\n",\r\n__func__, pdev->id);\r\nret = -ENODEV;\r\ngoto err_res;\r\n}\r\nmcbsp->dma_tx_sync = res->start;\r\nmcbsp->fclk = clk_get(&pdev->dev, "fck");\r\nif (IS_ERR(mcbsp->fclk)) {\r\nret = PTR_ERR(mcbsp->fclk);\r\ndev_err(&pdev->dev, "unable to get fck: %d\n", ret);\r\ngoto err_res;\r\n}\r\nmcbsp->pdata = pdata;\r\nmcbsp->dev = &pdev->dev;\r\nmcbsp_ptr[id] = mcbsp;\r\nplatform_set_drvdata(pdev, mcbsp);\r\npm_runtime_enable(mcbsp->dev);\r\nmcbsp->dma_op_mode = MCBSP_DMA_MODE_ELEMENT;\r\nif (mcbsp->pdata->buffer_size) {\r\nmcbsp->max_tx_thres = max_thres(mcbsp) - 0x10;\r\nmcbsp->max_rx_thres = max_thres(mcbsp) - 0x10;\r\nret = sysfs_create_group(&mcbsp->dev->kobj,\r\n&additional_attr_group);\r\nif (ret) {\r\ndev_err(mcbsp->dev,\r\n"Unable to create additional controls\n");\r\ngoto err_thres;\r\n}\r\n} else {\r\nmcbsp->max_tx_thres = -EINVAL;\r\nmcbsp->max_rx_thres = -EINVAL;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "sidetone");\r\nif (res) {\r\nret = omap_st_add(mcbsp, res);\r\nif (ret) {\r\ndev_err(mcbsp->dev,\r\n"Unable to create sidetone controls\n");\r\ngoto err_st;\r\n}\r\n}\r\nreturn 0;\r\nerr_st:\r\nif (mcbsp->pdata->buffer_size)\r\nsysfs_remove_group(&mcbsp->dev->kobj,\r\n&additional_attr_group);\r\nerr_thres:\r\nclk_put(mcbsp->fclk);\r\nerr_res:\r\niounmap(mcbsp->io_base);\r\nerr_ioremap:\r\nkfree(mcbsp);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int __devexit omap_mcbsp_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_mcbsp *mcbsp = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nif (mcbsp) {\r\nif (mcbsp->pdata && mcbsp->pdata->ops &&\r\nmcbsp->pdata->ops->free)\r\nmcbsp->pdata->ops->free(mcbsp->id);\r\nif (mcbsp->pdata->buffer_size)\r\nsysfs_remove_group(&mcbsp->dev->kobj,\r\n&additional_attr_group);\r\nif (mcbsp->st_data)\r\nomap_st_remove(mcbsp);\r\nclk_put(mcbsp->fclk);\r\niounmap(mcbsp->io_base);\r\nkfree(mcbsp);\r\n}\r\nreturn 0;\r\n}\r\nint __init omap_mcbsp_init(void)\r\n{\r\nreturn platform_driver_register(&omap_mcbsp_driver);\r\n}
