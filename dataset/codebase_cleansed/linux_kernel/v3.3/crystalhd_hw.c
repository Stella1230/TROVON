static void crystalhd_enable_uarts(struct crystalhd_adp *adp)\r\n{\r\nbc_dec_reg_wr(adp, UartSelectA, BSVS_UART_STREAM);\r\nbc_dec_reg_wr(adp, UartSelectB, BSVS_UART_DEC_OUTER);\r\n}\r\nstatic void crystalhd_start_dram(struct crystalhd_adp *adp)\r\n{\r\nbc_dec_reg_wr(adp, SDRAM_PARAM, ((40 / 5 - 1) << 0) |\r\n((15 / 5 - 1) << 7) |\r\n((10 / 5 - 1) << 10) |\r\n((15 / 5 + 1) << 12) |\r\n((2 + 1) << 16) |\r\n((70 / 5 - 2) << 19) |\r\n(0 << 23));\r\nbc_dec_reg_wr(adp, SDRAM_PRECHARGE, 0);\r\nbc_dec_reg_wr(adp, SDRAM_EXT_MODE, 2);\r\nbc_dec_reg_wr(adp, SDRAM_MODE, 0x132);\r\nbc_dec_reg_wr(adp, SDRAM_PRECHARGE, 0);\r\nbc_dec_reg_wr(adp, SDRAM_REFRESH, 0);\r\nbc_dec_reg_wr(adp, SDRAM_REFRESH, 0);\r\nbc_dec_reg_wr(adp, SDRAM_MODE, 0x32);\r\nbc_dec_reg_wr(adp, SDRAM_REF_PARAM, ((1 << 12) | 96));\r\n}\r\nstatic bool crystalhd_bring_out_of_rst(struct crystalhd_adp *adp)\r\n{\r\nunion link_misc_perst_deco_ctrl rst_deco_cntrl;\r\nunion link_misc_perst_clk_ctrl rst_clk_cntrl;\r\nuint32_t temp;\r\nrst_clk_cntrl.whole_reg = crystalhd_reg_rd(adp, MISC_PERST_CLOCK_CTRL);\r\nrst_clk_cntrl.pll_pwr_dn = 0;\r\ncrystalhd_reg_wr(adp, MISC_PERST_CLOCK_CTRL, rst_clk_cntrl.whole_reg);\r\nmsleep_interruptible(50);\r\nrst_clk_cntrl.whole_reg = crystalhd_reg_rd(adp, MISC_PERST_CLOCK_CTRL);\r\nrst_clk_cntrl.stop_core_clk = 0;\r\nrst_clk_cntrl.sel_alt_clk = 0;\r\ncrystalhd_reg_wr(adp, MISC_PERST_CLOCK_CTRL, rst_clk_cntrl.whole_reg);\r\nmsleep_interruptible(50);\r\ncrystalhd_reg_wr(adp, GISB_ARBITER_TIMER, 0x9D8);\r\nrst_deco_cntrl.whole_reg = crystalhd_reg_rd(adp, MISC_PERST_DECODER_CTRL);\r\nrst_deco_cntrl.stop_bcm_7412_clk = 0;\r\nrst_deco_cntrl.bcm7412_rst = 1;\r\ncrystalhd_reg_wr(adp, MISC_PERST_DECODER_CTRL, rst_deco_cntrl.whole_reg);\r\nmsleep_interruptible(10);\r\nrst_deco_cntrl.whole_reg = crystalhd_reg_rd(adp, MISC_PERST_DECODER_CTRL);\r\nrst_deco_cntrl.bcm7412_rst = 0;\r\ncrystalhd_reg_wr(adp, MISC_PERST_DECODER_CTRL, rst_deco_cntrl.whole_reg);\r\nmsleep_interruptible(50);\r\ncrystalhd_reg_wr(adp, OTP_CONTENT_MISC, 0);\r\ntemp = crystalhd_reg_rd(adp, PCIE_TL_TRANSACTION_CONFIGURATION);\r\ntemp &= ~BC_BIT(29);\r\ncrystalhd_reg_wr(adp, PCIE_TL_TRANSACTION_CONFIGURATION, temp);\r\ntemp = crystalhd_reg_rd(adp, MISC_PERST_VREG_CTRL);\r\ncrystalhd_reg_wr(adp, MISC_PERST_VREG_CTRL, 0xF3);\r\nreturn true;\r\n}\r\nstatic bool crystalhd_put_in_reset(struct crystalhd_adp *adp)\r\n{\r\nunion link_misc_perst_deco_ctrl rst_deco_cntrl;\r\nunion link_misc_perst_clk_ctrl rst_clk_cntrl;\r\nuint32_t temp;\r\nrst_deco_cntrl.whole_reg = crystalhd_reg_rd(adp, MISC_PERST_DECODER_CTRL);\r\nrst_deco_cntrl.stop_bcm_7412_clk = 1;\r\ncrystalhd_reg_wr(adp, MISC_PERST_DECODER_CTRL, rst_deco_cntrl.whole_reg);\r\nmsleep_interruptible(50);\r\ncrystalhd_reg_wr(adp, GISB_ARBITER_TIMER, 0x10E);\r\nrst_clk_cntrl.whole_reg = crystalhd_reg_rd(adp, MISC_PERST_CLOCK_CTRL);\r\nrst_clk_cntrl.stop_core_clk = 1;\r\nrst_clk_cntrl.sel_alt_clk = 1;\r\ncrystalhd_reg_wr(adp, MISC_PERST_CLOCK_CTRL, rst_clk_cntrl.whole_reg);\r\nmsleep_interruptible(50);\r\nrst_clk_cntrl.whole_reg = crystalhd_reg_rd(adp, MISC_PERST_CLOCK_CTRL);\r\nrst_clk_cntrl.pll_pwr_dn = 1;\r\ncrystalhd_reg_wr(adp, MISC_PERST_CLOCK_CTRL, rst_clk_cntrl.whole_reg);\r\ntemp = crystalhd_reg_rd(adp, PCIE_TL_TRANSACTION_CONFIGURATION);\r\ncrystalhd_reg_wr(adp, MISC3_RESET_CTRL, 1);\r\nrst_deco_cntrl.whole_reg = crystalhd_reg_rd(adp, MISC3_RESET_CTRL);\r\nmsleep_interruptible(50);\r\ncrystalhd_reg_wr(adp, PCIE_TL_TRANSACTION_CONFIGURATION, temp);\r\nreturn true;\r\n}\r\nstatic void crystalhd_disable_interrupts(struct crystalhd_adp *adp)\r\n{\r\nunion intr_mask_reg intr_mask;\r\nintr_mask.whole_reg = crystalhd_reg_rd(adp, INTR_INTR_MSK_STS_REG);\r\nintr_mask.mask_pcie_err = 1;\r\nintr_mask.mask_pcie_rbusmast_err = 1;\r\nintr_mask.mask_pcie_rgr_bridge = 1;\r\nintr_mask.mask_rx_done = 1;\r\nintr_mask.mask_rx_err = 1;\r\nintr_mask.mask_tx_done = 1;\r\nintr_mask.mask_tx_err = 1;\r\ncrystalhd_reg_wr(adp, INTR_INTR_MSK_SET_REG, intr_mask.whole_reg);\r\nreturn;\r\n}\r\nstatic void crystalhd_enable_interrupts(struct crystalhd_adp *adp)\r\n{\r\nunion intr_mask_reg intr_mask;\r\nintr_mask.whole_reg = crystalhd_reg_rd(adp, INTR_INTR_MSK_STS_REG);\r\nintr_mask.mask_pcie_err = 1;\r\nintr_mask.mask_pcie_rbusmast_err = 1;\r\nintr_mask.mask_pcie_rgr_bridge = 1;\r\nintr_mask.mask_rx_done = 1;\r\nintr_mask.mask_rx_err = 1;\r\nintr_mask.mask_tx_done = 1;\r\nintr_mask.mask_tx_err = 1;\r\ncrystalhd_reg_wr(adp, INTR_INTR_MSK_CLR_REG, intr_mask.whole_reg);\r\nreturn;\r\n}\r\nstatic void crystalhd_clear_errors(struct crystalhd_adp *adp)\r\n{\r\nuint32_t reg;\r\nreg = crystalhd_reg_rd(adp, MISC1_Y_RX_ERROR_STATUS);\r\nif (reg)\r\ncrystalhd_reg_wr(adp, MISC1_Y_RX_ERROR_STATUS, reg);\r\nreg = crystalhd_reg_rd(adp, MISC1_UV_RX_ERROR_STATUS);\r\nif (reg)\r\ncrystalhd_reg_wr(adp, MISC1_UV_RX_ERROR_STATUS, reg);\r\nreg = crystalhd_reg_rd(adp, MISC1_TX_DMA_ERROR_STATUS);\r\nif (reg)\r\ncrystalhd_reg_wr(adp, MISC1_TX_DMA_ERROR_STATUS, reg);\r\n}\r\nstatic void crystalhd_clear_interrupts(struct crystalhd_adp *adp)\r\n{\r\nuint32_t intr_sts = crystalhd_reg_rd(adp, INTR_INTR_STATUS);\r\nif (intr_sts) {\r\ncrystalhd_reg_wr(adp, INTR_INTR_CLR_REG, intr_sts);\r\ncrystalhd_reg_wr(adp, INTR_EOI_CTRL, 1);\r\n}\r\n}\r\nstatic void crystalhd_soft_rst(struct crystalhd_adp *adp)\r\n{\r\nuint32_t val;\r\nbc_dec_reg_wr(adp, DecHt_HostSwReset, 0x00000001);\r\nmsleep_interruptible(50);\r\nbc_dec_reg_wr(adp, DecHt_HostSwReset, 0x00000000);\r\nval = crystalhd_reg_rd(adp, MISC2_GLOBAL_CTRL);\r\nval |= BC_BIT(8);\r\ncrystalhd_reg_wr(adp, MISC2_GLOBAL_CTRL, val);\r\n}\r\nstatic bool crystalhd_load_firmware_config(struct crystalhd_adp *adp)\r\n{\r\nuint32_t i = 0, reg;\r\ncrystalhd_reg_wr(adp, DCI_DRAM_BASE_ADDR, (BC_DRAM_FW_CFG_ADDR >> 19));\r\ncrystalhd_reg_wr(adp, AES_CMD, 0);\r\ncrystalhd_reg_wr(adp, AES_CONFIG_INFO, (BC_DRAM_FW_CFG_ADDR & 0x7FFFF));\r\ncrystalhd_reg_wr(adp, AES_CMD, 0x1);\r\nfor (i = 0; i < 100; ++i) {\r\nreg = crystalhd_reg_rd(adp, AES_STATUS);\r\nif (reg & 0x1)\r\nreturn true;\r\nmsleep_interruptible(10);\r\n}\r\nreturn false;\r\n}\r\nstatic bool crystalhd_start_device(struct crystalhd_adp *adp)\r\n{\r\nuint32_t dbg_options, glb_cntrl = 0, reg_pwrmgmt = 0;\r\nBCMLOG(BCMLOG_INFO, "Starting BCM70012 Device\n");\r\nreg_pwrmgmt = crystalhd_reg_rd(adp, PCIE_DLL_DATA_LINK_CONTROL);\r\nreg_pwrmgmt &= ~ASPM_L1_ENABLE;\r\ncrystalhd_reg_wr(adp, PCIE_DLL_DATA_LINK_CONTROL, reg_pwrmgmt);\r\nif (!crystalhd_bring_out_of_rst(adp)) {\r\nBCMLOG_ERR("Failed To Bring Link Out Of Reset\n");\r\nreturn false;\r\n}\r\ncrystalhd_disable_interrupts(adp);\r\ncrystalhd_clear_errors(adp);\r\ncrystalhd_clear_interrupts(adp);\r\ncrystalhd_enable_interrupts(adp);\r\ndbg_options = crystalhd_reg_rd(adp, MISC1_DMA_DEBUG_OPTIONS_REG);\r\ndbg_options |= 0x10;\r\ncrystalhd_reg_wr(adp, MISC1_DMA_DEBUG_OPTIONS_REG, dbg_options);\r\nglb_cntrl = crystalhd_reg_rd(adp, MISC2_GLOBAL_CTRL);\r\nglb_cntrl |= 0x100;\r\nglb_cntrl |= 0x8000;\r\ncrystalhd_reg_wr(adp, MISC2_GLOBAL_CTRL, glb_cntrl);\r\ncrystalhd_enable_interrupts(adp);\r\ncrystalhd_soft_rst(adp);\r\ncrystalhd_start_dram(adp);\r\ncrystalhd_enable_uarts(adp);\r\nreturn true;\r\n}\r\nstatic bool crystalhd_stop_device(struct crystalhd_adp *adp)\r\n{\r\nuint32_t reg;\r\nBCMLOG(BCMLOG_INFO, "Stopping BCM70012 Device\n");\r\ncrystalhd_disable_interrupts(adp);\r\ncrystalhd_clear_errors(adp);\r\ncrystalhd_clear_interrupts(adp);\r\nif (!crystalhd_put_in_reset(adp))\r\nBCMLOG_ERR("Failed to Put Link To Reset State\n");\r\nreg = crystalhd_reg_rd(adp, PCIE_DLL_DATA_LINK_CONTROL);\r\nreg |= ASPM_L1_ENABLE;\r\ncrystalhd_reg_wr(adp, PCIE_DLL_DATA_LINK_CONTROL, reg);\r\nreg = crystalhd_reg_rd(adp, PCIE_CLK_REQ_REG);\r\nreg |= PCI_CLK_REQ_ENABLE;\r\ncrystalhd_reg_wr(adp, PCIE_CLK_REQ_REG, reg);\r\nreturn true;\r\n}\r\nstatic struct crystalhd_rx_dma_pkt *crystalhd_hw_alloc_rx_pkt(struct crystalhd_hw *hw)\r\n{\r\nunsigned long flags = 0;\r\nstruct crystalhd_rx_dma_pkt *temp = NULL;\r\nif (!hw)\r\nreturn NULL;\r\nspin_lock_irqsave(&hw->lock, flags);\r\ntemp = hw->rx_pkt_pool_head;\r\nif (temp) {\r\nhw->rx_pkt_pool_head = hw->rx_pkt_pool_head->next;\r\ntemp->dio_req = NULL;\r\ntemp->pkt_tag = 0;\r\ntemp->flags = 0;\r\n}\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nreturn temp;\r\n}\r\nstatic void crystalhd_hw_free_rx_pkt(struct crystalhd_hw *hw,\r\nstruct crystalhd_rx_dma_pkt *pkt)\r\n{\r\nunsigned long flags = 0;\r\nif (!hw || !pkt)\r\nreturn;\r\nspin_lock_irqsave(&hw->lock, flags);\r\npkt->next = hw->rx_pkt_pool_head;\r\nhw->rx_pkt_pool_head = pkt;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\n}\r\nstatic void crystalhd_tx_desc_rel_call_back(void *context, void *data)\r\n{\r\n}\r\nstatic void crystalhd_rx_pkt_rel_call_back(void *context, void *data)\r\n{\r\nstruct crystalhd_hw *hw = (struct crystalhd_hw *)context;\r\nstruct crystalhd_rx_dma_pkt *pkt = (struct crystalhd_rx_dma_pkt *)data;\r\nif (!pkt || !hw) {\r\nBCMLOG_ERR("Invalid arg - %p %p\n", hw, pkt);\r\nreturn;\r\n}\r\nif (pkt->dio_req)\r\ncrystalhd_unmap_dio(hw->adp, pkt->dio_req);\r\nelse\r\nBCMLOG_ERR("Missing dio_req: 0x%x\n", pkt->pkt_tag);\r\ncrystalhd_hw_free_rx_pkt(hw, pkt);\r\n}\r\nstatic void crystalhd_hw_delete_ioqs(struct crystalhd_hw *hw)\r\n{\r\nif (!hw)\r\nreturn;\r\nBCMLOG(BCMLOG_DBG, "Deleting IOQs\n");\r\ncrystalhd_hw_delete_ioq(hw->adp, hw->tx_actq);\r\ncrystalhd_hw_delete_ioq(hw->adp, hw->tx_freeq);\r\ncrystalhd_hw_delete_ioq(hw->adp, hw->rx_actq);\r\ncrystalhd_hw_delete_ioq(hw->adp, hw->rx_freeq);\r\ncrystalhd_hw_delete_ioq(hw->adp, hw->rx_rdyq);\r\n}\r\nstatic enum BC_STATUS crystalhd_hw_create_ioqs(struct crystalhd_hw *hw)\r\n{\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nif (!hw) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\ncrystalhd_hw_create_ioq(sts, hw, hw->tx_freeq,\r\ncrystalhd_tx_desc_rel_call_back);\r\ncrystalhd_hw_create_ioq(sts, hw, hw->tx_actq,\r\ncrystalhd_tx_desc_rel_call_back);\r\ncrystalhd_hw_create_ioq(sts, hw, hw->rx_freeq,\r\ncrystalhd_rx_pkt_rel_call_back);\r\ncrystalhd_hw_create_ioq(sts, hw, hw->rx_rdyq,\r\ncrystalhd_rx_pkt_rel_call_back);\r\ncrystalhd_hw_create_ioq(sts, hw, hw->rx_actq,\r\ncrystalhd_rx_pkt_rel_call_back);\r\nreturn sts;\r\nhw_create_ioq_err:\r\ncrystalhd_hw_delete_ioqs(hw);\r\nreturn sts;\r\n}\r\nstatic bool crystalhd_code_in_full(struct crystalhd_adp *adp, uint32_t needed_sz,\r\nbool b_188_byte_pkts, uint8_t flags)\r\n{\r\nuint32_t base, end, writep, readp;\r\nuint32_t cpbSize, cpbFullness, fifoSize;\r\nif (flags & 0x02) {\r\nbase = bc_dec_reg_rd(adp, REG_Dec_TsAudCDB2Base);\r\nend = bc_dec_reg_rd(adp, REG_Dec_TsAudCDB2End);\r\nwritep = bc_dec_reg_rd(adp, REG_Dec_TsAudCDB2Wrptr);\r\nreadp = bc_dec_reg_rd(adp, REG_Dec_TsAudCDB2Rdptr);\r\n} else if (b_188_byte_pkts) {\r\nbase = bc_dec_reg_rd(adp, REG_Dec_TsUser0Base);\r\nend = bc_dec_reg_rd(adp, REG_Dec_TsUser0End);\r\nwritep = bc_dec_reg_rd(adp, REG_Dec_TsUser0Wrptr);\r\nreadp = bc_dec_reg_rd(adp, REG_Dec_TsUser0Rdptr);\r\n} else {\r\nbase = bc_dec_reg_rd(adp, REG_DecCA_RegCinBase);\r\nend = bc_dec_reg_rd(adp, REG_DecCA_RegCinEnd);\r\nwritep = bc_dec_reg_rd(adp, REG_DecCA_RegCinWrPtr);\r\nreadp = bc_dec_reg_rd(adp, REG_DecCA_RegCinRdPtr);\r\n}\r\ncpbSize = end - base;\r\nif (writep >= readp)\r\ncpbFullness = writep - readp;\r\nelse\r\ncpbFullness = (end - base) - (readp - writep);\r\nfifoSize = cpbSize - cpbFullness;\r\nif (fifoSize < BC_INFIFO_THRESHOLD)\r\nreturn true;\r\nif (needed_sz > (fifoSize - BC_INFIFO_THRESHOLD))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic enum BC_STATUS crystalhd_hw_tx_req_complete(struct crystalhd_hw *hw,\r\nuint32_t list_id, enum BC_STATUS cs)\r\n{\r\nstruct tx_dma_pkt *tx_req;\r\nif (!hw || !list_id) {\r\nBCMLOG_ERR("Invalid Arg..\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nhw->pwr_lock--;\r\ntx_req = (struct tx_dma_pkt *)crystalhd_dioq_find_and_fetch(hw->tx_actq, list_id);\r\nif (!tx_req) {\r\nif (cs != BC_STS_IO_USER_ABORT)\r\nBCMLOG_ERR("Find and Fetch Did not find req\n");\r\nreturn BC_STS_NO_DATA;\r\n}\r\nif (tx_req->call_back) {\r\ntx_req->call_back(tx_req->dio_req, tx_req->cb_event, cs);\r\ntx_req->dio_req = NULL;\r\ntx_req->cb_event = NULL;\r\ntx_req->call_back = NULL;\r\n} else {\r\nBCMLOG(BCMLOG_DBG, "Missing Tx Callback - %X\n",\r\ntx_req->list_tag);\r\n}\r\ntx_req->list_tag = 0;\r\nreturn crystalhd_dioq_add(hw->tx_freeq, tx_req, false, 0);\r\n}\r\nstatic bool crystalhd_tx_list0_handler(struct crystalhd_hw *hw, uint32_t err_sts)\r\n{\r\nuint32_t err_mask, tmp;\r\nunsigned long flags = 0;\r\nerr_mask = MISC1_TX_DMA_ERROR_STATUS_TX_L0_DESC_TX_ABORT_ERRORS_MASK |\r\nMISC1_TX_DMA_ERROR_STATUS_TX_L0_DMA_DATA_TX_ABORT_ERRORS_MASK |\r\nMISC1_TX_DMA_ERROR_STATUS_TX_L0_FIFO_FULL_ERRORS_MASK;\r\nif (!(err_sts & err_mask))\r\nreturn false;\r\nBCMLOG_ERR("Error on Tx-L0 %x\n", err_sts);\r\ntmp = err_mask;\r\nif (err_sts & MISC1_TX_DMA_ERROR_STATUS_TX_L0_FIFO_FULL_ERRORS_MASK)\r\ntmp &= ~MISC1_TX_DMA_ERROR_STATUS_TX_L0_FIFO_FULL_ERRORS_MASK;\r\nif (tmp) {\r\nspin_lock_irqsave(&hw->lock, flags);\r\nhw->tx_list_post_index = 0;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\n}\r\ntmp = err_sts & err_mask;\r\ncrystalhd_reg_wr(hw->adp, MISC1_TX_DMA_ERROR_STATUS, tmp);\r\nreturn true;\r\n}\r\nstatic bool crystalhd_tx_list1_handler(struct crystalhd_hw *hw, uint32_t err_sts)\r\n{\r\nuint32_t err_mask, tmp;\r\nunsigned long flags = 0;\r\nerr_mask = MISC1_TX_DMA_ERROR_STATUS_TX_L1_DESC_TX_ABORT_ERRORS_MASK |\r\nMISC1_TX_DMA_ERROR_STATUS_TX_L1_DMA_DATA_TX_ABORT_ERRORS_MASK |\r\nMISC1_TX_DMA_ERROR_STATUS_TX_L1_FIFO_FULL_ERRORS_MASK;\r\nif (!(err_sts & err_mask))\r\nreturn false;\r\nBCMLOG_ERR("Error on Tx-L1 %x\n", err_sts);\r\ntmp = err_mask;\r\nif (err_sts & MISC1_TX_DMA_ERROR_STATUS_TX_L1_FIFO_FULL_ERRORS_MASK)\r\ntmp &= ~MISC1_TX_DMA_ERROR_STATUS_TX_L1_FIFO_FULL_ERRORS_MASK;\r\nif (tmp) {\r\nspin_lock_irqsave(&hw->lock, flags);\r\nhw->tx_list_post_index = 0;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\n}\r\ntmp = err_sts & err_mask;\r\ncrystalhd_reg_wr(hw->adp, MISC1_TX_DMA_ERROR_STATUS, tmp);\r\nreturn true;\r\n}\r\nstatic void crystalhd_tx_isr(struct crystalhd_hw *hw, uint32_t int_sts)\r\n{\r\nuint32_t err_sts;\r\nif (int_sts & INTR_INTR_STATUS_L0_TX_DMA_DONE_INTR_MASK)\r\ncrystalhd_hw_tx_req_complete(hw, hw->tx_ioq_tag_seed + 0,\r\nBC_STS_SUCCESS);\r\nif (int_sts & INTR_INTR_STATUS_L1_TX_DMA_DONE_INTR_MASK)\r\ncrystalhd_hw_tx_req_complete(hw, hw->tx_ioq_tag_seed + 1,\r\nBC_STS_SUCCESS);\r\nif (!(int_sts & (INTR_INTR_STATUS_L0_TX_DMA_ERR_INTR_MASK |\r\nINTR_INTR_STATUS_L1_TX_DMA_ERR_INTR_MASK))) {\r\nreturn;\r\n}\r\nerr_sts = crystalhd_reg_rd(hw->adp, MISC1_TX_DMA_ERROR_STATUS);\r\nif (crystalhd_tx_list0_handler(hw, err_sts))\r\ncrystalhd_hw_tx_req_complete(hw, hw->tx_ioq_tag_seed + 0,\r\nBC_STS_ERROR);\r\nif (crystalhd_tx_list1_handler(hw, err_sts))\r\ncrystalhd_hw_tx_req_complete(hw, hw->tx_ioq_tag_seed + 1,\r\nBC_STS_ERROR);\r\nhw->stats.tx_errors++;\r\n}\r\nstatic void crystalhd_hw_dump_desc(struct dma_descriptor *p_dma_desc,\r\nuint32_t ul_desc_index, uint32_t cnt)\r\n{\r\nuint32_t ix, ll = 0;\r\nif (!p_dma_desc || !cnt)\r\nreturn;\r\nif (!ll)\r\nreturn;\r\nfor (ix = ul_desc_index; ix < (ul_desc_index + cnt); ix++) {\r\nBCMLOG(ll, "%s[%d] Buff[%x:%x] Next:[%x:%x] XferSz:%x Intr:%x,Last:%x\n",\r\n((p_dma_desc[ul_desc_index].dma_dir) ? "TDesc" : "RDesc"),\r\nul_desc_index,\r\np_dma_desc[ul_desc_index].buff_addr_high,\r\np_dma_desc[ul_desc_index].buff_addr_low,\r\np_dma_desc[ul_desc_index].next_desc_addr_high,\r\np_dma_desc[ul_desc_index].next_desc_addr_low,\r\np_dma_desc[ul_desc_index].xfer_size,\r\np_dma_desc[ul_desc_index].intr_enable,\r\np_dma_desc[ul_desc_index].last_rec_indicator);\r\n}\r\n}\r\nstatic enum BC_STATUS crystalhd_hw_fill_desc(struct crystalhd_dio_req *ioreq,\r\nstruct dma_descriptor *desc,\r\ndma_addr_t desc_paddr_base,\r\nuint32_t sg_cnt, uint32_t sg_st_ix,\r\nuint32_t sg_st_off, uint32_t xfr_sz)\r\n{\r\nuint32_t count = 0, ix = 0, sg_ix = 0, len = 0, last_desc_ix = 0;\r\ndma_addr_t desc_phy_addr = desc_paddr_base;\r\nunion addr_64 addr_temp;\r\nif (!ioreq || !desc || !desc_paddr_base || !xfr_sz ||\r\n(!sg_cnt && !ioreq->uinfo.dir_tx)) {\r\nBCMLOG_ERR("Invalid Args\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nfor (ix = 0; ix < sg_cnt; ix++) {\r\nsg_ix = ix + sg_st_ix;\r\nlen = crystalhd_get_sgle_len(ioreq, sg_ix);\r\nif (len % 4) {\r\nBCMLOG_ERR(" len in sg %d %d %d\n", len, sg_ix, sg_cnt);\r\nreturn BC_STS_NOT_IMPL;\r\n}\r\naddr_temp.full_addr = crystalhd_get_sgle_paddr(ioreq, sg_ix);\r\nif (sg_ix == sg_st_ix) {\r\naddr_temp.full_addr += sg_st_off;\r\nlen -= sg_st_off;\r\n}\r\nmemset(&desc[ix], 0, sizeof(desc[ix]));\r\ndesc[ix].buff_addr_low = addr_temp.low_part;\r\ndesc[ix].buff_addr_high = addr_temp.high_part;\r\ndesc[ix].dma_dir = ioreq->uinfo.dir_tx;\r\naddr_temp.full_addr = desc_phy_addr + sizeof(struct dma_descriptor);\r\ndesc[ix].next_desc_addr_low = addr_temp.low_part;\r\ndesc[ix].next_desc_addr_high = addr_temp.high_part;\r\nif ((count + len) > xfr_sz)\r\nlen = xfr_sz - count;\r\nif ((!len) || (len > crystalhd_get_sgle_len(ioreq, sg_ix))) {\r\nBCMLOG_ERR("inv-len(%x) Ix(%d) count:%x xfr_sz:%x sg_cnt:%d\n",\r\nlen, ix, count, xfr_sz, sg_cnt);\r\nreturn BC_STS_ERROR;\r\n}\r\ndesc[ix].xfer_size = (len / 4);\r\ncrystalhd_hw_dump_desc(desc, ix, 1);\r\ncount += len;\r\ndesc_phy_addr += sizeof(struct dma_descriptor);\r\n}\r\nlast_desc_ix = ix - 1;\r\nif (ioreq->fb_size) {\r\nmemset(&desc[ix], 0, sizeof(desc[ix]));\r\naddr_temp.full_addr = ioreq->fb_pa;\r\ndesc[ix].buff_addr_low = addr_temp.low_part;\r\ndesc[ix].buff_addr_high = addr_temp.high_part;\r\ndesc[ix].dma_dir = ioreq->uinfo.dir_tx;\r\ndesc[ix].xfer_size = 1;\r\ndesc[ix].fill_bytes = 4 - ioreq->fb_size;\r\ncount += ioreq->fb_size;\r\nlast_desc_ix++;\r\n}\r\ndesc[last_desc_ix].last_rec_indicator = 1;\r\ndesc[last_desc_ix].next_desc_addr_low = 0;\r\ndesc[last_desc_ix].next_desc_addr_high = 0;\r\ndesc[last_desc_ix].intr_enable = 1;\r\ncrystalhd_hw_dump_desc(desc, last_desc_ix, 1);\r\nif (count != xfr_sz) {\r\nBCMLOG_ERR("interal error sz curr:%x exp:%x\n", count, xfr_sz);\r\nreturn BC_STS_ERROR;\r\n}\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic enum BC_STATUS crystalhd_xlat_sgl_to_dma_desc(struct crystalhd_dio_req *ioreq,\r\nstruct dma_desc_mem *pdesc_mem,\r\nuint32_t *uv_desc_index)\r\n{\r\nstruct dma_descriptor *desc = NULL;\r\ndma_addr_t desc_paddr_base = 0;\r\nuint32_t sg_cnt = 0, sg_st_ix = 0, sg_st_off = 0;\r\nuint32_t xfr_sz = 0;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nif (!ioreq || !pdesc_mem || !uv_desc_index) {\r\nBCMLOG_ERR("Invalid Args\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nif (!pdesc_mem->sz || !pdesc_mem->pdma_desc_start ||\r\n!ioreq->sg || (!ioreq->sg_cnt && !ioreq->uinfo.dir_tx)) {\r\nBCMLOG_ERR("Invalid Args\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nif ((ioreq->uinfo.dir_tx) && (ioreq->uinfo.uv_offset)) {\r\nBCMLOG_ERR("UV offset for TX??\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\ndesc = pdesc_mem->pdma_desc_start;\r\ndesc_paddr_base = pdesc_mem->phy_addr;\r\nif (ioreq->uinfo.dir_tx || (ioreq->uinfo.uv_offset == 0)) {\r\nsg_cnt = ioreq->sg_cnt;\r\nxfr_sz = ioreq->uinfo.xfr_len;\r\n} else {\r\nsg_cnt = ioreq->uinfo.uv_sg_ix + 1;\r\nxfr_sz = ioreq->uinfo.uv_offset;\r\n}\r\nsts = crystalhd_hw_fill_desc(ioreq, desc, desc_paddr_base, sg_cnt,\r\nsg_st_ix, sg_st_off, xfr_sz);\r\nif ((sts != BC_STS_SUCCESS) || !ioreq->uinfo.uv_offset)\r\nreturn sts;\r\ndesc = &pdesc_mem->pdma_desc_start[sg_cnt];\r\ndesc_paddr_base = pdesc_mem->phy_addr +\r\n(sg_cnt * sizeof(struct dma_descriptor));\r\nsg_cnt = ioreq->sg_cnt - ioreq->uinfo.uv_sg_ix;\r\nxfr_sz = ioreq->uinfo.xfr_len - ioreq->uinfo.uv_offset;\r\nsg_st_ix = ioreq->uinfo.uv_sg_ix;\r\nsg_st_off = ioreq->uinfo.uv_sg_off;\r\nsts = crystalhd_hw_fill_desc(ioreq, desc, desc_paddr_base, sg_cnt,\r\nsg_st_ix, sg_st_off, xfr_sz);\r\nif (sts != BC_STS_SUCCESS)\r\nreturn sts;\r\n*uv_desc_index = sg_st_ix;\r\nreturn sts;\r\n}\r\nstatic void crystalhd_start_tx_dma_engine(struct crystalhd_hw *hw)\r\n{\r\nuint32_t dma_cntrl;\r\ndma_cntrl = crystalhd_reg_rd(hw->adp, MISC1_TX_SW_DESC_LIST_CTRL_STS);\r\nif (!(dma_cntrl & DMA_START_BIT)) {\r\ndma_cntrl |= DMA_START_BIT;\r\ncrystalhd_reg_wr(hw->adp, MISC1_TX_SW_DESC_LIST_CTRL_STS,\r\ndma_cntrl);\r\n}\r\nreturn;\r\n}\r\nstatic enum BC_STATUS crystalhd_stop_tx_dma_engine(struct crystalhd_hw *hw)\r\n{\r\nuint32_t dma_cntrl, cnt = 30;\r\nuint32_t l1 = 1, l2 = 1;\r\nunsigned long flags = 0;\r\ndma_cntrl = crystalhd_reg_rd(hw->adp, MISC1_TX_SW_DESC_LIST_CTRL_STS);\r\nBCMLOG(BCMLOG_DBG, "Stopping TX DMA Engine..\n");\r\nif (!dma_cntrl & DMA_START_BIT) {\r\nBCMLOG(BCMLOG_DBG, "Already Stopped\n");\r\nreturn BC_STS_SUCCESS;\r\n}\r\ncrystalhd_disable_interrupts(hw->adp);\r\ndma_cntrl &= ~DMA_START_BIT;\r\ncrystalhd_reg_wr(hw->adp, MISC1_TX_SW_DESC_LIST_CTRL_STS, dma_cntrl);\r\nBCMLOG(BCMLOG_DBG, "Cleared the DMA Start bit\n");\r\nwhile ((l1 || l2) && cnt) {\r\nif (l1) {\r\nl1 = crystalhd_reg_rd(hw->adp, MISC1_TX_FIRST_DESC_L_ADDR_LIST0);\r\nl1 &= DMA_START_BIT;\r\n}\r\nif (l2) {\r\nl2 = crystalhd_reg_rd(hw->adp, MISC1_TX_FIRST_DESC_L_ADDR_LIST1);\r\nl2 &= DMA_START_BIT;\r\n}\r\nmsleep_interruptible(100);\r\ncnt--;\r\n}\r\nif (!cnt) {\r\nBCMLOG_ERR("Failed to stop TX DMA.. l1 %d, l2 %d\n", l1, l2);\r\ncrystalhd_enable_interrupts(hw->adp);\r\nreturn BC_STS_ERROR;\r\n}\r\nspin_lock_irqsave(&hw->lock, flags);\r\nhw->tx_list_post_index = 0;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nBCMLOG(BCMLOG_DBG, "stopped TX DMA..\n");\r\ncrystalhd_enable_interrupts(hw->adp);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic uint32_t crystalhd_get_pib_avail_cnt(struct crystalhd_hw *hw)\r\n{\r\nuint32_t Q_addr;\r\nuint32_t pib_cnt, r_offset, w_offset;\r\nQ_addr = hw->pib_del_Q_addr;\r\ncrystalhd_mem_rd(hw->adp, Q_addr, 1, &r_offset);\r\ncrystalhd_mem_rd(hw->adp, Q_addr + sizeof(uint32_t), 1, &w_offset);\r\nif (r_offset == w_offset)\r\nreturn 0;\r\nif (w_offset > r_offset)\r\npib_cnt = w_offset - r_offset;\r\nelse\r\npib_cnt = (w_offset + MAX_PIB_Q_DEPTH) -\r\n(r_offset + MIN_PIB_Q_DEPTH);\r\nif (pib_cnt > MAX_PIB_Q_DEPTH) {\r\nBCMLOG_ERR("Invalid PIB Count (%u)\n", pib_cnt);\r\nreturn 0;\r\n}\r\nreturn pib_cnt;\r\n}\r\nstatic uint32_t crystalhd_get_addr_from_pib_Q(struct crystalhd_hw *hw)\r\n{\r\nuint32_t Q_addr;\r\nuint32_t addr_entry, r_offset, w_offset;\r\nQ_addr = hw->pib_del_Q_addr;\r\ncrystalhd_mem_rd(hw->adp, Q_addr, 1, &r_offset);\r\ncrystalhd_mem_rd(hw->adp, Q_addr + sizeof(uint32_t), 1, &w_offset);\r\nif (r_offset == w_offset)\r\nreturn 0;\r\nif ((r_offset < MIN_PIB_Q_DEPTH) || (r_offset >= MAX_PIB_Q_DEPTH))\r\nreturn 0;\r\ncrystalhd_mem_rd(hw->adp, Q_addr + (r_offset * sizeof(uint32_t)),\r\n1, &addr_entry);\r\nr_offset++;\r\nif (MAX_PIB_Q_DEPTH == r_offset)\r\nr_offset = MIN_PIB_Q_DEPTH;\r\ncrystalhd_mem_wr(hw->adp, Q_addr, 1, &r_offset);\r\nreturn addr_entry;\r\n}\r\nstatic bool crystalhd_rel_addr_to_pib_Q(struct crystalhd_hw *hw, uint32_t addr_to_rel)\r\n{\r\nuint32_t Q_addr;\r\nuint32_t r_offset, w_offset, n_offset;\r\nQ_addr = hw->pib_rel_Q_addr;\r\ncrystalhd_mem_rd(hw->adp, Q_addr, 1, &r_offset);\r\ncrystalhd_mem_rd(hw->adp, Q_addr + sizeof(uint32_t), 1, &w_offset);\r\nif ((r_offset < MIN_PIB_Q_DEPTH) ||\r\n(r_offset >= MAX_PIB_Q_DEPTH))\r\nreturn false;\r\nn_offset = w_offset + 1;\r\nif (MAX_PIB_Q_DEPTH == n_offset)\r\nn_offset = MIN_PIB_Q_DEPTH;\r\nif (r_offset == n_offset)\r\nreturn false;\r\ncrystalhd_mem_wr(hw->adp, Q_addr + (w_offset * sizeof(uint32_t)),\r\n1, &addr_to_rel);\r\ncrystalhd_mem_wr(hw->adp, Q_addr + sizeof(uint32_t), 1, &n_offset);\r\nreturn true;\r\n}\r\nstatic void cpy_pib_to_app(struct c011_pib *src_pib, struct BC_PIC_INFO_BLOCK *dst_pib)\r\n{\r\nif (!src_pib || !dst_pib) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn;\r\n}\r\ndst_pib->timeStamp = 0;\r\ndst_pib->picture_number = src_pib->ppb.picture_number;\r\ndst_pib->width = src_pib->ppb.width;\r\ndst_pib->height = src_pib->ppb.height;\r\ndst_pib->chroma_format = src_pib->ppb.chroma_format;\r\ndst_pib->pulldown = src_pib->ppb.pulldown;\r\ndst_pib->flags = src_pib->ppb.flags;\r\ndst_pib->sess_num = src_pib->ptsStcOffset;\r\ndst_pib->aspect_ratio = src_pib->ppb.aspect_ratio;\r\ndst_pib->colour_primaries = src_pib->ppb.colour_primaries;\r\ndst_pib->picture_meta_payload = src_pib->ppb.picture_meta_payload;\r\ndst_pib->frame_rate = src_pib->resolution ;\r\nreturn;\r\n}\r\nstatic void crystalhd_hw_proc_pib(struct crystalhd_hw *hw)\r\n{\r\nunsigned int cnt;\r\nstruct c011_pib src_pib;\r\nuint32_t pib_addr, pib_cnt;\r\nstruct BC_PIC_INFO_BLOCK *AppPib;\r\nstruct crystalhd_rx_dma_pkt *rx_pkt = NULL;\r\npib_cnt = crystalhd_get_pib_avail_cnt(hw);\r\nif (!pib_cnt)\r\nreturn;\r\nfor (cnt = 0; cnt < pib_cnt; cnt++) {\r\npib_addr = crystalhd_get_addr_from_pib_Q(hw);\r\ncrystalhd_mem_rd(hw->adp, pib_addr, sizeof(struct c011_pib) / 4,\r\n(uint32_t *)&src_pib);\r\nif (src_pib.bFormatChange) {\r\nrx_pkt = (struct crystalhd_rx_dma_pkt *)crystalhd_dioq_fetch(hw->rx_freeq);\r\nif (!rx_pkt)\r\nreturn;\r\nrx_pkt->flags = 0;\r\nrx_pkt->flags |= COMP_FLAG_PIB_VALID | COMP_FLAG_FMT_CHANGE;\r\nAppPib = &rx_pkt->pib;\r\ncpy_pib_to_app(&src_pib, AppPib);\r\nBCMLOG(BCMLOG_DBG,\r\n"App PIB:%x %x %x %x %x %x %x %x %x %x\n",\r\nrx_pkt->pib.picture_number,\r\nrx_pkt->pib.aspect_ratio,\r\nrx_pkt->pib.chroma_format,\r\nrx_pkt->pib.colour_primaries,\r\nrx_pkt->pib.frame_rate,\r\nrx_pkt->pib.height,\r\nrx_pkt->pib.height,\r\nrx_pkt->pib.n_drop,\r\nrx_pkt->pib.pulldown,\r\nrx_pkt->pib.ycom);\r\ncrystalhd_dioq_add(hw->rx_rdyq, (void *)rx_pkt, true, rx_pkt->pkt_tag);\r\n}\r\ncrystalhd_rel_addr_to_pib_Q(hw, pib_addr);\r\n}\r\n}\r\nstatic void crystalhd_start_rx_dma_engine(struct crystalhd_hw *hw)\r\n{\r\nuint32_t dma_cntrl;\r\ndma_cntrl = crystalhd_reg_rd(hw->adp, MISC1_Y_RX_SW_DESC_LIST_CTRL_STS);\r\nif (!(dma_cntrl & DMA_START_BIT)) {\r\ndma_cntrl |= DMA_START_BIT;\r\ncrystalhd_reg_wr(hw->adp, MISC1_Y_RX_SW_DESC_LIST_CTRL_STS, dma_cntrl);\r\n}\r\ndma_cntrl = crystalhd_reg_rd(hw->adp, MISC1_UV_RX_SW_DESC_LIST_CTRL_STS);\r\nif (!(dma_cntrl & DMA_START_BIT)) {\r\ndma_cntrl |= DMA_START_BIT;\r\ncrystalhd_reg_wr(hw->adp, MISC1_UV_RX_SW_DESC_LIST_CTRL_STS, dma_cntrl);\r\n}\r\nreturn;\r\n}\r\nstatic void crystalhd_stop_rx_dma_engine(struct crystalhd_hw *hw)\r\n{\r\nuint32_t dma_cntrl = 0, count = 30;\r\nuint32_t l0y = 1, l0uv = 1, l1y = 1, l1uv = 1;\r\ndma_cntrl = crystalhd_reg_rd(hw->adp, MISC1_Y_RX_SW_DESC_LIST_CTRL_STS);\r\nif ((dma_cntrl & DMA_START_BIT)) {\r\ndma_cntrl &= ~DMA_START_BIT;\r\ncrystalhd_reg_wr(hw->adp, MISC1_Y_RX_SW_DESC_LIST_CTRL_STS, dma_cntrl);\r\n}\r\ndma_cntrl = crystalhd_reg_rd(hw->adp, MISC1_UV_RX_SW_DESC_LIST_CTRL_STS);\r\nif ((dma_cntrl & DMA_START_BIT)) {\r\ndma_cntrl &= ~DMA_START_BIT;\r\ncrystalhd_reg_wr(hw->adp, MISC1_UV_RX_SW_DESC_LIST_CTRL_STS, dma_cntrl);\r\n}\r\nwhile ((l0y || l0uv || l1y || l1uv) && count) {\r\nif (l0y) {\r\nl0y = crystalhd_reg_rd(hw->adp, MISC1_Y_RX_FIRST_DESC_L_ADDR_LIST0);\r\nl0y &= DMA_START_BIT;\r\nif (!l0y)\r\nhw->rx_list_sts[0] &= ~rx_waiting_y_intr;\r\n}\r\nif (l1y) {\r\nl1y = crystalhd_reg_rd(hw->adp, MISC1_Y_RX_FIRST_DESC_L_ADDR_LIST1);\r\nl1y &= DMA_START_BIT;\r\nif (!l1y)\r\nhw->rx_list_sts[1] &= ~rx_waiting_y_intr;\r\n}\r\nif (l0uv) {\r\nl0uv = crystalhd_reg_rd(hw->adp, MISC1_UV_RX_FIRST_DESC_L_ADDR_LIST0);\r\nl0uv &= DMA_START_BIT;\r\nif (!l0uv)\r\nhw->rx_list_sts[0] &= ~rx_waiting_uv_intr;\r\n}\r\nif (l1uv) {\r\nl1uv = crystalhd_reg_rd(hw->adp, MISC1_UV_RX_FIRST_DESC_L_ADDR_LIST1);\r\nl1uv &= DMA_START_BIT;\r\nif (!l1uv)\r\nhw->rx_list_sts[1] &= ~rx_waiting_uv_intr;\r\n}\r\nmsleep_interruptible(100);\r\ncount--;\r\n}\r\nhw->rx_list_post_index = 0;\r\nBCMLOG(BCMLOG_SSTEP, "Capture Stop: %d List0:Sts:%x List1:Sts:%x\n",\r\ncount, hw->rx_list_sts[0], hw->rx_list_sts[1]);\r\n}\r\nstatic enum BC_STATUS crystalhd_hw_prog_rxdma(struct crystalhd_hw *hw, struct crystalhd_rx_dma_pkt *rx_pkt)\r\n{\r\nuint32_t y_low_addr_reg, y_high_addr_reg;\r\nuint32_t uv_low_addr_reg, uv_high_addr_reg;\r\nunion addr_64 desc_addr;\r\nunsigned long flags;\r\nif (!hw || !rx_pkt) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nif (hw->rx_list_post_index >= DMA_ENGINE_CNT) {\r\nBCMLOG_ERR("List Out Of bounds %x\n", hw->rx_list_post_index);\r\nreturn BC_STS_INV_ARG;\r\n}\r\nspin_lock_irqsave(&hw->rx_lock, flags);\r\nif (sts_free != hw->rx_list_sts[hw->rx_list_post_index]) {\r\nspin_unlock_irqrestore(&hw->rx_lock, flags);\r\nreturn BC_STS_BUSY;\r\n}\r\nif (!hw->rx_list_post_index) {\r\ny_low_addr_reg = MISC1_Y_RX_FIRST_DESC_L_ADDR_LIST0;\r\ny_high_addr_reg = MISC1_Y_RX_FIRST_DESC_U_ADDR_LIST0;\r\nuv_low_addr_reg = MISC1_UV_RX_FIRST_DESC_L_ADDR_LIST0;\r\nuv_high_addr_reg = MISC1_UV_RX_FIRST_DESC_U_ADDR_LIST0;\r\n} else {\r\ny_low_addr_reg = MISC1_Y_RX_FIRST_DESC_L_ADDR_LIST1;\r\ny_high_addr_reg = MISC1_Y_RX_FIRST_DESC_U_ADDR_LIST1;\r\nuv_low_addr_reg = MISC1_UV_RX_FIRST_DESC_L_ADDR_LIST1;\r\nuv_high_addr_reg = MISC1_UV_RX_FIRST_DESC_U_ADDR_LIST1;\r\n}\r\nrx_pkt->pkt_tag = hw->rx_pkt_tag_seed + hw->rx_list_post_index;\r\nhw->rx_list_sts[hw->rx_list_post_index] |= rx_waiting_y_intr;\r\nif (rx_pkt->uv_phy_addr)\r\nhw->rx_list_sts[hw->rx_list_post_index] |= rx_waiting_uv_intr;\r\nhw->rx_list_post_index = (hw->rx_list_post_index + 1) % DMA_ENGINE_CNT;\r\nspin_unlock_irqrestore(&hw->rx_lock, flags);\r\ncrystalhd_dioq_add(hw->rx_actq, (void *)rx_pkt, false, rx_pkt->pkt_tag);\r\ncrystalhd_start_rx_dma_engine(hw);\r\ndesc_addr.full_addr = rx_pkt->desc_mem.phy_addr;\r\ncrystalhd_reg_wr(hw->adp, y_high_addr_reg, desc_addr.high_part);\r\ncrystalhd_reg_wr(hw->adp, y_low_addr_reg, desc_addr.low_part | 0x01);\r\nif (rx_pkt->uv_phy_addr) {\r\ndesc_addr.full_addr = rx_pkt->uv_phy_addr;\r\ncrystalhd_reg_wr(hw->adp, uv_high_addr_reg, desc_addr.high_part);\r\ncrystalhd_reg_wr(hw->adp, uv_low_addr_reg, desc_addr.low_part | 0x01);\r\n}\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic enum BC_STATUS crystalhd_hw_post_cap_buff(struct crystalhd_hw *hw,\r\nstruct crystalhd_rx_dma_pkt *rx_pkt)\r\n{\r\nenum BC_STATUS sts = crystalhd_hw_prog_rxdma(hw, rx_pkt);\r\nif (sts == BC_STS_BUSY)\r\ncrystalhd_dioq_add(hw->rx_freeq, (void *)rx_pkt,\r\nfalse, rx_pkt->pkt_tag);\r\nreturn sts;\r\n}\r\nstatic void crystalhd_get_dnsz(struct crystalhd_hw *hw, uint32_t list_index,\r\nuint32_t *y_dw_dnsz, uint32_t *uv_dw_dnsz)\r\n{\r\nuint32_t y_dn_sz_reg, uv_dn_sz_reg;\r\nif (!list_index) {\r\ny_dn_sz_reg = MISC1_Y_RX_LIST0_CUR_BYTE_CNT;\r\nuv_dn_sz_reg = MISC1_UV_RX_LIST0_CUR_BYTE_CNT;\r\n} else {\r\ny_dn_sz_reg = MISC1_Y_RX_LIST1_CUR_BYTE_CNT;\r\nuv_dn_sz_reg = MISC1_UV_RX_LIST1_CUR_BYTE_CNT;\r\n}\r\n*y_dw_dnsz = crystalhd_reg_rd(hw->adp, y_dn_sz_reg);\r\n*uv_dw_dnsz = crystalhd_reg_rd(hw->adp, uv_dn_sz_reg);\r\n}\r\nstatic void crystalhd_hw_finalize_pause(struct crystalhd_hw *hw)\r\n{\r\nuint32_t dma_cntrl, aspm;\r\nhw->stop_pending = 0;\r\ndma_cntrl = crystalhd_reg_rd(hw->adp, MISC1_Y_RX_SW_DESC_LIST_CTRL_STS);\r\nif (dma_cntrl & DMA_START_BIT) {\r\ndma_cntrl &= ~DMA_START_BIT;\r\ncrystalhd_reg_wr(hw->adp, MISC1_Y_RX_SW_DESC_LIST_CTRL_STS, dma_cntrl);\r\n}\r\ndma_cntrl = crystalhd_reg_rd(hw->adp, MISC1_UV_RX_SW_DESC_LIST_CTRL_STS);\r\nif (dma_cntrl & DMA_START_BIT) {\r\ndma_cntrl &= ~DMA_START_BIT;\r\ncrystalhd_reg_wr(hw->adp, MISC1_UV_RX_SW_DESC_LIST_CTRL_STS, dma_cntrl);\r\n}\r\nhw->rx_list_post_index = 0;\r\naspm = crystalhd_reg_rd(hw->adp, PCIE_DLL_DATA_LINK_CONTROL);\r\naspm |= ASPM_L1_ENABLE;\r\ncrystalhd_reg_wr(hw->adp, PCIE_DLL_DATA_LINK_CONTROL, aspm);\r\n}\r\nstatic enum BC_STATUS crystalhd_rx_pkt_done(struct crystalhd_hw *hw, uint32_t list_index,\r\nenum BC_STATUS comp_sts)\r\n{\r\nstruct crystalhd_rx_dma_pkt *rx_pkt = NULL;\r\nuint32_t y_dw_dnsz, uv_dw_dnsz;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nif (!hw || list_index >= DMA_ENGINE_CNT) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nrx_pkt = crystalhd_dioq_find_and_fetch(hw->rx_actq,\r\nhw->rx_pkt_tag_seed + list_index);\r\nif (!rx_pkt) {\r\nBCMLOG_ERR("Act-Q:PostIx:%x L0Sts:%x L1Sts:%x current L:%x tag:%x comp:%x\n",\r\nhw->rx_list_post_index, hw->rx_list_sts[0],\r\nhw->rx_list_sts[1], list_index,\r\nhw->rx_pkt_tag_seed + list_index, comp_sts);\r\nreturn BC_STS_INV_ARG;\r\n}\r\nif (comp_sts == BC_STS_SUCCESS) {\r\ncrystalhd_get_dnsz(hw, list_index, &y_dw_dnsz, &uv_dw_dnsz);\r\nrx_pkt->dio_req->uinfo.y_done_sz = y_dw_dnsz;\r\nrx_pkt->flags = COMP_FLAG_DATA_VALID;\r\nif (rx_pkt->uv_phy_addr)\r\nrx_pkt->dio_req->uinfo.uv_done_sz = uv_dw_dnsz;\r\ncrystalhd_dioq_add(hw->rx_rdyq, rx_pkt, true,\r\nhw->rx_pkt_tag_seed + list_index);\r\nreturn sts;\r\n}\r\nreturn crystalhd_hw_post_cap_buff(hw, rx_pkt);\r\n}\r\nstatic bool crystalhd_rx_list0_handler(struct crystalhd_hw *hw, uint32_t int_sts,\r\nuint32_t y_err_sts, uint32_t uv_err_sts)\r\n{\r\nuint32_t tmp;\r\nenum list_sts tmp_lsts;\r\nif (!(y_err_sts & GET_Y0_ERR_MSK) && !(uv_err_sts & GET_UV0_ERR_MSK))\r\nreturn false;\r\ntmp_lsts = hw->rx_list_sts[0];\r\ntmp = y_err_sts & GET_Y0_ERR_MSK;\r\nif (int_sts & INTR_INTR_STATUS_L0_Y_RX_DMA_DONE_INTR_MASK)\r\nhw->rx_list_sts[0] &= ~rx_waiting_y_intr;\r\nif (y_err_sts & MISC1_Y_RX_ERROR_STATUS_RX_L0_UNDERRUN_ERROR_MASK) {\r\nhw->rx_list_sts[0] &= ~rx_waiting_y_intr;\r\ntmp &= ~MISC1_Y_RX_ERROR_STATUS_RX_L0_UNDERRUN_ERROR_MASK;\r\n}\r\nif (y_err_sts & MISC1_Y_RX_ERROR_STATUS_RX_L0_FIFO_FULL_ERRORS_MASK) {\r\nhw->rx_list_sts[0] &= ~rx_y_mask;\r\nhw->rx_list_sts[0] |= rx_y_error;\r\ntmp &= ~MISC1_Y_RX_ERROR_STATUS_RX_L0_FIFO_FULL_ERRORS_MASK;\r\n}\r\nif (tmp) {\r\nhw->rx_list_sts[0] &= ~rx_y_mask;\r\nhw->rx_list_sts[0] |= rx_y_error;\r\nhw->rx_list_post_index = 0;\r\n}\r\ntmp = uv_err_sts & GET_UV0_ERR_MSK;\r\nif (int_sts & INTR_INTR_STATUS_L0_UV_RX_DMA_DONE_INTR_MASK)\r\nhw->rx_list_sts[0] &= ~rx_waiting_uv_intr;\r\nif (uv_err_sts & MISC1_UV_RX_ERROR_STATUS_RX_L0_UNDERRUN_ERROR_MASK) {\r\nhw->rx_list_sts[0] &= ~rx_waiting_uv_intr;\r\ntmp &= ~MISC1_UV_RX_ERROR_STATUS_RX_L0_UNDERRUN_ERROR_MASK;\r\n}\r\nif (uv_err_sts & MISC1_UV_RX_ERROR_STATUS_RX_L0_FIFO_FULL_ERRORS_MASK) {\r\nhw->rx_list_sts[0] &= ~rx_uv_mask;\r\nhw->rx_list_sts[0] |= rx_uv_error;\r\ntmp &= ~MISC1_UV_RX_ERROR_STATUS_RX_L0_FIFO_FULL_ERRORS_MASK;\r\n}\r\nif (tmp) {\r\nhw->rx_list_sts[0] &= ~rx_uv_mask;\r\nhw->rx_list_sts[0] |= rx_uv_error;\r\nhw->rx_list_post_index = 0;\r\n}\r\nif (y_err_sts & GET_Y0_ERR_MSK) {\r\ntmp = y_err_sts & GET_Y0_ERR_MSK;\r\ncrystalhd_reg_wr(hw->adp, MISC1_Y_RX_ERROR_STATUS, tmp);\r\n}\r\nif (uv_err_sts & GET_UV0_ERR_MSK) {\r\ntmp = uv_err_sts & GET_UV0_ERR_MSK;\r\ncrystalhd_reg_wr(hw->adp, MISC1_UV_RX_ERROR_STATUS, tmp);\r\n}\r\nreturn (tmp_lsts != hw->rx_list_sts[0]);\r\n}\r\nstatic bool crystalhd_rx_list1_handler(struct crystalhd_hw *hw, uint32_t int_sts,\r\nuint32_t y_err_sts, uint32_t uv_err_sts)\r\n{\r\nuint32_t tmp;\r\nenum list_sts tmp_lsts;\r\nif (!(y_err_sts & GET_Y1_ERR_MSK) && !(uv_err_sts & GET_UV1_ERR_MSK))\r\nreturn false;\r\ntmp_lsts = hw->rx_list_sts[1];\r\ntmp = y_err_sts & GET_Y1_ERR_MSK;\r\nif (int_sts & INTR_INTR_STATUS_L1_Y_RX_DMA_DONE_INTR_MASK)\r\nhw->rx_list_sts[1] &= ~rx_waiting_y_intr;\r\nif (y_err_sts & MISC1_Y_RX_ERROR_STATUS_RX_L1_UNDERRUN_ERROR_MASK) {\r\nhw->rx_list_sts[1] &= ~rx_waiting_y_intr;\r\ntmp &= ~MISC1_Y_RX_ERROR_STATUS_RX_L1_UNDERRUN_ERROR_MASK;\r\n}\r\nif (y_err_sts & MISC1_Y_RX_ERROR_STATUS_RX_L1_FIFO_FULL_ERRORS_MASK) {\r\nhw->rx_list_sts[1] &= ~rx_y_mask;\r\nhw->rx_list_sts[1] |= rx_y_error;\r\ntmp &= ~MISC1_Y_RX_ERROR_STATUS_RX_L1_FIFO_FULL_ERRORS_MASK;\r\n}\r\nif (tmp) {\r\nhw->rx_list_sts[1] &= ~rx_y_mask;\r\nhw->rx_list_sts[1] |= rx_y_error;\r\nhw->rx_list_post_index = 0;\r\n}\r\ntmp = uv_err_sts & GET_UV1_ERR_MSK;\r\nif (int_sts & INTR_INTR_STATUS_L1_UV_RX_DMA_DONE_INTR_MASK)\r\nhw->rx_list_sts[1] &= ~rx_waiting_uv_intr;\r\nif (uv_err_sts & MISC1_UV_RX_ERROR_STATUS_RX_L1_UNDERRUN_ERROR_MASK) {\r\nhw->rx_list_sts[1] &= ~rx_waiting_uv_intr;\r\ntmp &= ~MISC1_UV_RX_ERROR_STATUS_RX_L1_UNDERRUN_ERROR_MASK;\r\n}\r\nif (uv_err_sts & MISC1_UV_RX_ERROR_STATUS_RX_L1_FIFO_FULL_ERRORS_MASK) {\r\nhw->rx_list_sts[1] &= ~rx_uv_mask;\r\nhw->rx_list_sts[1] |= rx_uv_error;\r\ntmp &= ~MISC1_UV_RX_ERROR_STATUS_RX_L1_FIFO_FULL_ERRORS_MASK;\r\n}\r\nif (tmp) {\r\nhw->rx_list_sts[1] &= ~rx_uv_mask;\r\nhw->rx_list_sts[1] |= rx_uv_error;\r\nhw->rx_list_post_index = 0;\r\n}\r\nif (y_err_sts & GET_Y1_ERR_MSK) {\r\ntmp = y_err_sts & GET_Y1_ERR_MSK;\r\ncrystalhd_reg_wr(hw->adp, MISC1_Y_RX_ERROR_STATUS, tmp);\r\n}\r\nif (uv_err_sts & GET_UV1_ERR_MSK) {\r\ntmp = uv_err_sts & GET_UV1_ERR_MSK;\r\ncrystalhd_reg_wr(hw->adp, MISC1_UV_RX_ERROR_STATUS, tmp);\r\n}\r\nreturn (tmp_lsts != hw->rx_list_sts[1]);\r\n}\r\nstatic void crystalhd_rx_isr(struct crystalhd_hw *hw, uint32_t intr_sts)\r\n{\r\nunsigned long flags;\r\nuint32_t i, list_avail = 0;\r\nenum BC_STATUS comp_sts = BC_STS_NO_DATA;\r\nuint32_t y_err_sts, uv_err_sts, y_dn_sz = 0, uv_dn_sz = 0;\r\nbool ret = 0;\r\nif (!hw) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn;\r\n}\r\nif (!(intr_sts & GET_RX_INTR_MASK))\r\nreturn;\r\ny_err_sts = crystalhd_reg_rd(hw->adp, MISC1_Y_RX_ERROR_STATUS);\r\nuv_err_sts = crystalhd_reg_rd(hw->adp, MISC1_UV_RX_ERROR_STATUS);\r\nfor (i = 0; i < DMA_ENGINE_CNT; i++) {\r\nspin_lock_irqsave(&hw->rx_lock, flags);\r\nif (i == 0)\r\nret = crystalhd_rx_list0_handler(hw, intr_sts, y_err_sts, uv_err_sts);\r\nelse\r\nret = crystalhd_rx_list1_handler(hw, intr_sts, y_err_sts, uv_err_sts);\r\nif (ret) {\r\nswitch (hw->rx_list_sts[i]) {\r\ncase sts_free:\r\ncomp_sts = BC_STS_SUCCESS;\r\nlist_avail = 1;\r\nbreak;\r\ncase rx_y_error:\r\ncase rx_uv_error:\r\ncase rx_sts_error:\r\nhw->stats.rx_errors++;\r\ncrystalhd_get_dnsz(hw, i, &y_dn_sz, &uv_dn_sz);\r\nBCMLOG(BCMLOG_DBG, "list_index:%x rx[%d] Y:%x "\r\n"UV:%x Int:%x YDnSz:%x UVDnSz:%x\n",\r\ni, hw->stats.rx_errors, y_err_sts,\r\nuv_err_sts, intr_sts, y_dn_sz, uv_dn_sz);\r\nhw->rx_list_sts[i] = sts_free;\r\ncomp_sts = BC_STS_ERROR;\r\nbreak;\r\ndefault:\r\ncomp_sts = BC_STS_NO_DATA;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&hw->rx_lock, flags);\r\nif (comp_sts != BC_STS_NO_DATA) {\r\ncrystalhd_rx_pkt_done(hw, i, comp_sts);\r\ncomp_sts = BC_STS_NO_DATA;\r\n}\r\n}\r\nif (list_avail) {\r\nif (hw->stop_pending) {\r\nif ((hw->rx_list_sts[0] == sts_free) &&\r\n(hw->rx_list_sts[1] == sts_free))\r\ncrystalhd_hw_finalize_pause(hw);\r\n} else {\r\ncrystalhd_hw_start_capture(hw);\r\n}\r\n}\r\n}\r\nstatic enum BC_STATUS crystalhd_fw_cmd_post_proc(struct crystalhd_hw *hw,\r\nstruct BC_FW_CMD *fw_cmd)\r\n{\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nstruct dec_rsp_channel_start_video *st_rsp = NULL;\r\nswitch (fw_cmd->cmd[0]) {\r\ncase eCMD_C011_DEC_CHAN_START_VIDEO:\r\nst_rsp = (struct dec_rsp_channel_start_video *)fw_cmd->rsp;\r\nhw->pib_del_Q_addr = st_rsp->picInfoDeliveryQ;\r\nhw->pib_rel_Q_addr = st_rsp->picInfoReleaseQ;\r\nBCMLOG(BCMLOG_DBG, "DelQAddr:%x RelQAddr:%x\n",\r\nhw->pib_del_Q_addr, hw->pib_rel_Q_addr);\r\nbreak;\r\ncase eCMD_C011_INIT:\r\nif (!(crystalhd_load_firmware_config(hw->adp))) {\r\nBCMLOG_ERR("Invalid Params.\n");\r\nsts = BC_STS_FW_AUTH_FAILED;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn sts;\r\n}\r\nstatic enum BC_STATUS crystalhd_put_ddr2sleep(struct crystalhd_hw *hw)\r\n{\r\nuint32_t reg;\r\nunion link_misc_perst_decoder_ctrl rst_cntrl_reg;\r\nrst_cntrl_reg.whole_reg = crystalhd_reg_rd(hw->adp, MISC_PERST_DECODER_CTRL);\r\nrst_cntrl_reg.bcm_7412_rst = 1;\r\ncrystalhd_reg_wr(hw->adp, MISC_PERST_DECODER_CTRL, rst_cntrl_reg.whole_reg);\r\nmsleep_interruptible(50);\r\nrst_cntrl_reg.bcm_7412_rst = 0;\r\ncrystalhd_reg_wr(hw->adp, MISC_PERST_DECODER_CTRL, rst_cntrl_reg.whole_reg);\r\nbc_dec_reg_wr(hw->adp, SDRAM_PRECHARGE, 0);\r\nreg = bc_dec_reg_rd(hw->adp, SDRAM_PARAM);\r\nreg |= 0x02000000;\r\nbc_dec_reg_wr(hw->adp, SDRAM_PARAM, reg);\r\nbc_dec_reg_wr(hw->adp, AUD_DSP_MISC_SOFT_RESET, 0x1);\r\nreg = bc_dec_reg_rd(hw->adp, DecHt_PllCCtl);\r\nreg |= 0x00008000;\r\nbc_dec_reg_wr(hw->adp, DecHt_PllCCtl, reg);\r\nbc_dec_reg_wr(hw->adp, AIO_MISC_PLL_RESET, 0x1);\r\nreg = bc_dec_reg_rd(hw->adp, DecHt_PllECtl);\r\nreg |= 0x00008000;\r\nbc_dec_reg_wr(hw->adp, DecHt_PllECtl, reg);\r\nreg = bc_dec_reg_rd(hw->adp, DecHt_PllDCtl);\r\nreg |= 0x00008000;\r\nbc_dec_reg_wr(hw->adp, DecHt_PllDCtl, reg);\r\nreg = bc_dec_reg_rd(hw->adp, DecHt_PllACtl);\r\nreg |= 0x00008000;\r\nbc_dec_reg_wr(hw->adp, DecHt_PllACtl, reg);\r\nreg = bc_dec_reg_rd(hw->adp, DecHt_PllBCtl);\r\nreg |= 0x00008000;\r\nbc_dec_reg_wr(hw->adp, DecHt_PllBCtl, reg);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_download_fw(struct crystalhd_adp *adp, void *buffer, uint32_t sz)\r\n{\r\nuint32_t reg_data, cnt, *temp_buff;\r\nuint32_t fw_sig_len = 36;\r\nuint32_t dram_offset = BC_FWIMG_ST_ADDR, sig_reg;\r\nBCMLOG_ENTER;\r\nif (!adp || !buffer || !sz) {\r\nBCMLOG_ERR("Invalid Params.\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nreg_data = crystalhd_reg_rd(adp, OTP_CMD);\r\nif (!(reg_data & 0x02)) {\r\nBCMLOG_ERR("Invalid hw config.. otp not programmed\n");\r\nreturn BC_STS_ERROR;\r\n}\r\nreg_data = 0;\r\ncrystalhd_reg_wr(adp, DCI_CMD, 0);\r\nreg_data |= BC_BIT(0);\r\ncrystalhd_reg_wr(adp, DCI_CMD, reg_data);\r\nreg_data = 0;\r\ncnt = 1000;\r\nmsleep_interruptible(10);\r\nwhile (reg_data != BC_BIT(4)) {\r\nreg_data = crystalhd_reg_rd(adp, DCI_STATUS);\r\nreg_data &= BC_BIT(4);\r\nif (--cnt == 0) {\r\nBCMLOG_ERR("Firmware Download RDY Timeout.\n");\r\nreturn BC_STS_TIMEOUT;\r\n}\r\n}\r\nmsleep_interruptible(10);\r\ncrystalhd_reg_wr(adp, DCI_FIRMWARE_ADDR, dram_offset);\r\ntemp_buff = (uint32_t *)buffer;\r\nfor (cnt = 0; cnt < (sz - fw_sig_len); cnt += 4) {\r\ncrystalhd_reg_wr(adp, DCI_DRAM_BASE_ADDR, (dram_offset >> 19));\r\ncrystalhd_reg_wr(adp, DCI_FIRMWARE_DATA, *temp_buff);\r\ndram_offset += 4;\r\ntemp_buff++;\r\n}\r\nmsleep_interruptible(10);\r\ntemp_buff++;\r\nsig_reg = (uint32_t)DCI_SIGNATURE_DATA_7;\r\nfor (cnt = 0; cnt < 8; cnt++) {\r\nuint32_t swapped_data = *temp_buff;\r\nswapped_data = bswap_32_1(swapped_data);\r\ncrystalhd_reg_wr(adp, sig_reg, swapped_data);\r\nsig_reg -= 4;\r\ntemp_buff++;\r\n}\r\nmsleep_interruptible(10);\r\nreg_data = 0;\r\nreg_data |= BC_BIT(1);\r\ncrystalhd_reg_wr(adp, DCI_CMD, reg_data);\r\nmsleep_interruptible(10);\r\nreg_data = 0;\r\nreg_data = crystalhd_reg_rd(adp, DCI_STATUS);\r\nif ((reg_data & BC_BIT(9)) == BC_BIT(9)) {\r\ncnt = 1000;\r\nwhile ((reg_data & BC_BIT(0)) != BC_BIT(0)) {\r\nreg_data = crystalhd_reg_rd(adp, DCI_STATUS);\r\nreg_data &= BC_BIT(0);\r\nif (!(--cnt))\r\nbreak;\r\nmsleep_interruptible(10);\r\n}\r\nreg_data = 0;\r\nreg_data = crystalhd_reg_rd(adp, DCI_CMD);\r\nreg_data |= BC_BIT(4);\r\ncrystalhd_reg_wr(adp, DCI_CMD, reg_data);\r\n} else {\r\nBCMLOG_ERR("F/w Signature mismatch\n");\r\nreturn BC_STS_FW_AUTH_FAILED;\r\n}\r\nBCMLOG(BCMLOG_INFO, "Firmware Downloaded Successfully\n");\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_do_fw_cmd(struct crystalhd_hw *hw,\r\nstruct BC_FW_CMD *fw_cmd)\r\n{\r\nuint32_t cnt = 0, cmd_res_addr;\r\nuint32_t *cmd_buff, *res_buff;\r\nwait_queue_head_t fw_cmd_event;\r\nint rc = 0;\r\nenum BC_STATUS sts;\r\ncrystalhd_create_event(&fw_cmd_event);\r\nBCMLOG_ENTER;\r\nif (!hw || !fw_cmd) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\ncmd_buff = fw_cmd->cmd;\r\nres_buff = fw_cmd->rsp;\r\nif (!cmd_buff || !res_buff) {\r\nBCMLOG_ERR("Invalid Parameters for F/W Command\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nhw->pwr_lock++;\r\nhw->fwcmd_evt_sts = 0;\r\nhw->pfw_cmd_event = &fw_cmd_event;\r\ncrystalhd_mem_wr(hw->adp, TS_Host2CpuSnd, FW_CMD_BUFF_SZ, cmd_buff);\r\ncrystalhd_mem_rd(hw->adp, TS_Host2CpuSnd, 1, &cnt);\r\nbc_dec_reg_wr(hw->adp, Hst2CpuMbx1, TS_Host2CpuSnd);\r\nmsleep_interruptible(50);\r\ncrystalhd_wait_on_event(&fw_cmd_event, hw->fwcmd_evt_sts, 20000, rc, 0);\r\nif (!rc) {\r\nsts = BC_STS_SUCCESS;\r\n} else if (rc == -EBUSY) {\r\nBCMLOG_ERR("Firmware command T/O\n");\r\nsts = BC_STS_TIMEOUT;\r\n} else if (rc == -EINTR) {\r\nBCMLOG(BCMLOG_DBG, "FwCmd Wait Signal int.\n");\r\nsts = BC_STS_IO_USER_ABORT;\r\n} else {\r\nBCMLOG_ERR("FwCmd IO Error.\n");\r\nsts = BC_STS_IO_ERROR;\r\n}\r\nif (sts != BC_STS_SUCCESS) {\r\nBCMLOG_ERR("FwCmd Failed.\n");\r\nhw->pwr_lock--;\r\nreturn sts;\r\n}\r\ncmd_res_addr = bc_dec_reg_rd(hw->adp, Cpu2HstMbx1);\r\ncrystalhd_mem_rd(hw->adp, cmd_res_addr, FW_CMD_BUFF_SZ, res_buff);\r\nhw->pwr_lock--;\r\nif (res_buff[2] != C011_RET_SUCCESS) {\r\nBCMLOG_ERR("res_buff[2] != C011_RET_SUCCESS\n");\r\nreturn BC_STS_FW_CMD_ERR;\r\n}\r\nsts = crystalhd_fw_cmd_post_proc(hw, fw_cmd);\r\nif (sts != BC_STS_SUCCESS)\r\nBCMLOG_ERR("crystalhd_fw_cmd_post_proc Failed.\n");\r\nreturn sts;\r\n}\r\nbool crystalhd_hw_interrupt(struct crystalhd_adp *adp, struct crystalhd_hw *hw)\r\n{\r\nuint32_t intr_sts = 0;\r\nuint32_t deco_intr = 0;\r\nbool rc = 0;\r\nif (!adp || !hw->dev_started)\r\nreturn rc;\r\nhw->stats.num_interrupts++;\r\nhw->pwr_lock++;\r\ndeco_intr = bc_dec_reg_rd(adp, Stream2Host_Intr_Sts);\r\nintr_sts = crystalhd_reg_rd(adp, INTR_INTR_STATUS);\r\nif (intr_sts) {\r\nrc = 1;\r\nhw->stats.dev_interrupts++;\r\n}\r\nif (deco_intr && (deco_intr != 0xdeaddead)) {\r\nif (deco_intr & 0x80000000) {\r\nif (hw->pfw_cmd_event) {\r\nhw->fwcmd_evt_sts = 1;\r\ncrystalhd_set_event(hw->pfw_cmd_event);\r\n}\r\n}\r\nif (deco_intr & BC_BIT(1))\r\ncrystalhd_hw_proc_pib(hw);\r\nbc_dec_reg_wr(adp, Stream2Host_Intr_Sts, deco_intr);\r\nbc_dec_reg_wr(adp, Stream2Host_Intr_Sts, 0);\r\nrc = 1;\r\n}\r\ncrystalhd_rx_isr(hw, intr_sts);\r\ncrystalhd_tx_isr(hw, intr_sts);\r\nif (rc) {\r\nif (intr_sts)\r\ncrystalhd_reg_wr(adp, INTR_INTR_CLR_REG, intr_sts);\r\ncrystalhd_reg_wr(adp, INTR_EOI_CTRL, 1);\r\n}\r\nhw->pwr_lock--;\r\nreturn rc;\r\n}\r\nenum BC_STATUS crystalhd_hw_open(struct crystalhd_hw *hw, struct crystalhd_adp *adp)\r\n{\r\nif (!hw || !adp) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nif (hw->dev_started)\r\nreturn BC_STS_SUCCESS;\r\nmemset(hw, 0, sizeof(struct crystalhd_hw));\r\nhw->adp = adp;\r\nspin_lock_init(&hw->lock);\r\nspin_lock_init(&hw->rx_lock);\r\nhw->tx_ioq_tag_seed = 0x70023070;\r\nhw->rx_pkt_tag_seed = 0x70029070;\r\nhw->stop_pending = 0;\r\ncrystalhd_start_device(hw->adp);\r\nhw->dev_started = true;\r\nhw->core_clock_mhz = CLOCK_PRESET;\r\nhw->prev_n = 0;\r\nhw->pwr_lock = 0;\r\ncrystalhd_hw_set_core_clock(hw);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_hw_close(struct crystalhd_hw *hw)\r\n{\r\nif (!hw) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nif (!hw->dev_started)\r\nreturn BC_STS_SUCCESS;\r\ncrystalhd_hw_suspend(hw);\r\nhw->dev_started = false;\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_hw_setup_dma_rings(struct crystalhd_hw *hw)\r\n{\r\nunsigned int i;\r\nvoid *mem;\r\nsize_t mem_len;\r\ndma_addr_t phy_addr;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nstruct crystalhd_rx_dma_pkt *rpkt;\r\nif (!hw || !hw->adp) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nsts = crystalhd_hw_create_ioqs(hw);\r\nif (sts != BC_STS_SUCCESS) {\r\nBCMLOG_ERR("Failed to create IOQs..\n");\r\nreturn sts;\r\n}\r\nmem_len = BC_LINK_MAX_SGLS * sizeof(struct dma_descriptor);\r\nfor (i = 0; i < BC_TX_LIST_CNT; i++) {\r\nmem = bc_kern_dma_alloc(hw->adp, mem_len, &phy_addr);\r\nif (mem) {\r\nmemset(mem, 0, mem_len);\r\n} else {\r\nBCMLOG_ERR("Insufficient Memory For TX\n");\r\ncrystalhd_hw_free_dma_rings(hw);\r\nreturn BC_STS_INSUFF_RES;\r\n}\r\nhw->tx_pkt_pool[i].desc_mem.pdma_desc_start = mem;\r\nhw->tx_pkt_pool[i].desc_mem.phy_addr = phy_addr;\r\nhw->tx_pkt_pool[i].desc_mem.sz = BC_LINK_MAX_SGLS *\r\nsizeof(struct dma_descriptor);\r\nhw->tx_pkt_pool[i].list_tag = 0;\r\nsts = crystalhd_dioq_add(hw->tx_freeq,\r\n&hw->tx_pkt_pool[i], false, 0);\r\nif (sts != BC_STS_SUCCESS) {\r\ncrystalhd_hw_free_dma_rings(hw);\r\nreturn sts;\r\n}\r\n}\r\nfor (i = 0; i < BC_RX_LIST_CNT; i++) {\r\nrpkt = kzalloc(sizeof(*rpkt), GFP_KERNEL);\r\nif (!rpkt) {\r\nBCMLOG_ERR("Insufficient Memory For RX\n");\r\ncrystalhd_hw_free_dma_rings(hw);\r\nreturn BC_STS_INSUFF_RES;\r\n}\r\nmem = bc_kern_dma_alloc(hw->adp, mem_len, &phy_addr);\r\nif (mem) {\r\nmemset(mem, 0, mem_len);\r\n} else {\r\nBCMLOG_ERR("Insufficient Memory For RX\n");\r\ncrystalhd_hw_free_dma_rings(hw);\r\nkfree(rpkt);\r\nreturn BC_STS_INSUFF_RES;\r\n}\r\nrpkt->desc_mem.pdma_desc_start = mem;\r\nrpkt->desc_mem.phy_addr = phy_addr;\r\nrpkt->desc_mem.sz = BC_LINK_MAX_SGLS * sizeof(struct dma_descriptor);\r\nrpkt->pkt_tag = hw->rx_pkt_tag_seed + i;\r\ncrystalhd_hw_free_rx_pkt(hw, rpkt);\r\n}\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_hw_free_dma_rings(struct crystalhd_hw *hw)\r\n{\r\nunsigned int i;\r\nstruct crystalhd_rx_dma_pkt *rpkt = NULL;\r\nif (!hw || !hw->adp) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\ncrystalhd_hw_delete_ioqs(hw);\r\nfor (i = 0; i < BC_TX_LIST_CNT; i++) {\r\nif (hw->tx_pkt_pool[i].desc_mem.pdma_desc_start) {\r\nbc_kern_dma_free(hw->adp,\r\nhw->tx_pkt_pool[i].desc_mem.sz,\r\nhw->tx_pkt_pool[i].desc_mem.pdma_desc_start,\r\nhw->tx_pkt_pool[i].desc_mem.phy_addr);\r\nhw->tx_pkt_pool[i].desc_mem.pdma_desc_start = NULL;\r\n}\r\n}\r\nBCMLOG(BCMLOG_DBG, "Releasing RX Pkt pool\n");\r\ndo {\r\nrpkt = crystalhd_hw_alloc_rx_pkt(hw);\r\nif (!rpkt)\r\nbreak;\r\nbc_kern_dma_free(hw->adp, rpkt->desc_mem.sz,\r\nrpkt->desc_mem.pdma_desc_start,\r\nrpkt->desc_mem.phy_addr);\r\nkfree(rpkt);\r\n} while (rpkt);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_hw_post_tx(struct crystalhd_hw *hw, struct crystalhd_dio_req *ioreq,\r\nhw_comp_callback call_back,\r\nwait_queue_head_t *cb_event, uint32_t *list_id,\r\nuint8_t data_flags)\r\n{\r\nstruct tx_dma_pkt *tx_dma_packet = NULL;\r\nuint32_t first_desc_u_addr, first_desc_l_addr;\r\nuint32_t low_addr, high_addr;\r\nunion addr_64 desc_addr;\r\nenum BC_STATUS sts, add_sts;\r\nuint32_t dummy_index = 0;\r\nunsigned long flags;\r\nbool rc;\r\nif (!hw || !ioreq || !call_back || !cb_event || !list_id) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nrc = crystalhd_code_in_full(hw->adp, ioreq->uinfo.xfr_len,\r\nfalse, data_flags);\r\nif (rc) {\r\nhw->stats.cin_busy++;\r\nreturn BC_STS_BUSY;\r\n}\r\ntx_dma_packet = (struct tx_dma_pkt *)crystalhd_dioq_fetch(hw->tx_freeq);\r\nif (!tx_dma_packet) {\r\nBCMLOG_ERR("No empty elements..\n");\r\nreturn BC_STS_ERR_USAGE;\r\n}\r\nsts = crystalhd_xlat_sgl_to_dma_desc(ioreq,\r\n&tx_dma_packet->desc_mem,\r\n&dummy_index);\r\nif (sts != BC_STS_SUCCESS) {\r\nadd_sts = crystalhd_dioq_add(hw->tx_freeq, tx_dma_packet,\r\nfalse, 0);\r\nif (add_sts != BC_STS_SUCCESS)\r\nBCMLOG_ERR("double fault..\n");\r\nreturn sts;\r\n}\r\nhw->pwr_lock++;\r\ndesc_addr.full_addr = tx_dma_packet->desc_mem.phy_addr;\r\nlow_addr = desc_addr.low_part;\r\nhigh_addr = desc_addr.high_part;\r\ntx_dma_packet->call_back = call_back;\r\ntx_dma_packet->cb_event = cb_event;\r\ntx_dma_packet->dio_req = ioreq;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nif (hw->tx_list_post_index == 0) {\r\nfirst_desc_u_addr = MISC1_TX_FIRST_DESC_U_ADDR_LIST0;\r\nfirst_desc_l_addr = MISC1_TX_FIRST_DESC_L_ADDR_LIST0;\r\n} else {\r\nfirst_desc_u_addr = MISC1_TX_FIRST_DESC_U_ADDR_LIST1;\r\nfirst_desc_l_addr = MISC1_TX_FIRST_DESC_L_ADDR_LIST1;\r\n}\r\n*list_id = tx_dma_packet->list_tag = hw->tx_ioq_tag_seed +\r\nhw->tx_list_post_index;\r\nhw->tx_list_post_index = (hw->tx_list_post_index + 1) % DMA_ENGINE_CNT;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\ncrystalhd_dioq_add(hw->tx_actq, tx_dma_packet, false,\r\ntx_dma_packet->list_tag);\r\ncrystalhd_start_tx_dma_engine(hw);\r\ncrystalhd_reg_wr(hw->adp, first_desc_u_addr, desc_addr.high_part);\r\ncrystalhd_reg_wr(hw->adp, first_desc_l_addr, desc_addr.low_part | 0x01);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_hw_cancel_tx(struct crystalhd_hw *hw, uint32_t list_id)\r\n{\r\nif (!hw || !list_id) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\ncrystalhd_stop_tx_dma_engine(hw);\r\ncrystalhd_hw_tx_req_complete(hw, list_id, BC_STS_IO_USER_ABORT);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_hw_add_cap_buffer(struct crystalhd_hw *hw,\r\nstruct crystalhd_dio_req *ioreq, bool en_post)\r\n{\r\nstruct crystalhd_rx_dma_pkt *rpkt;\r\nuint32_t tag, uv_desc_ix = 0;\r\nenum BC_STATUS sts;\r\nif (!hw || !ioreq) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nrpkt = crystalhd_hw_alloc_rx_pkt(hw);\r\nif (!rpkt) {\r\nBCMLOG_ERR("Insufficient resources\n");\r\nreturn BC_STS_INSUFF_RES;\r\n}\r\nrpkt->dio_req = ioreq;\r\ntag = rpkt->pkt_tag;\r\nsts = crystalhd_xlat_sgl_to_dma_desc(ioreq, &rpkt->desc_mem, &uv_desc_ix);\r\nif (sts != BC_STS_SUCCESS)\r\nreturn sts;\r\nrpkt->uv_phy_addr = 0;\r\nif (uv_desc_ix)\r\nrpkt->uv_phy_addr = rpkt->desc_mem.phy_addr +\r\n(sizeof(struct dma_descriptor) * (uv_desc_ix + 1));\r\nif (en_post)\r\nsts = crystalhd_hw_post_cap_buff(hw, rpkt);\r\nelse\r\nsts = crystalhd_dioq_add(hw->rx_freeq, rpkt, false, tag);\r\nreturn sts;\r\n}\r\nenum BC_STATUS crystalhd_hw_get_cap_buffer(struct crystalhd_hw *hw,\r\nstruct BC_PIC_INFO_BLOCK *pib,\r\nstruct crystalhd_dio_req **ioreq)\r\n{\r\nstruct crystalhd_rx_dma_pkt *rpkt;\r\nuint32_t timeout = BC_PROC_OUTPUT_TIMEOUT / 1000;\r\nuint32_t sig_pending = 0;\r\nif (!hw || !ioreq || !pib) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nrpkt = crystalhd_dioq_fetch_wait(hw->rx_rdyq, timeout, &sig_pending);\r\nif (!rpkt) {\r\nif (sig_pending) {\r\nBCMLOG(BCMLOG_INFO, "wait on frame time out %d\n", sig_pending);\r\nreturn BC_STS_IO_USER_ABORT;\r\n} else {\r\nreturn BC_STS_TIMEOUT;\r\n}\r\n}\r\nrpkt->dio_req->uinfo.comp_flags = rpkt->flags;\r\nif (rpkt->flags & COMP_FLAG_PIB_VALID)\r\nmemcpy(pib, &rpkt->pib, sizeof(*pib));\r\n*ioreq = rpkt->dio_req;\r\ncrystalhd_hw_free_rx_pkt(hw, rpkt);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_hw_start_capture(struct crystalhd_hw *hw)\r\n{\r\nstruct crystalhd_rx_dma_pkt *rx_pkt;\r\nenum BC_STATUS sts;\r\nuint32_t i;\r\nif (!hw) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nfor (i = 0; i < DMA_ENGINE_CNT; i++) {\r\nrx_pkt = crystalhd_dioq_fetch(hw->rx_freeq);\r\nif (!rx_pkt)\r\nreturn BC_STS_NO_DATA;\r\nsts = crystalhd_hw_post_cap_buff(hw, rx_pkt);\r\nif (BC_STS_SUCCESS != sts)\r\nbreak;\r\n}\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_hw_stop_capture(struct crystalhd_hw *hw)\r\n{\r\nvoid *temp = NULL;\r\nif (!hw) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\ncrystalhd_stop_rx_dma_engine(hw);\r\ndo {\r\ntemp = crystalhd_dioq_fetch(hw->rx_freeq);\r\nif (temp)\r\ncrystalhd_rx_pkt_rel_call_back(hw, temp);\r\n} while (temp);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_hw_pause(struct crystalhd_hw *hw)\r\n{\r\nhw->stats.pause_cnt++;\r\nhw->stop_pending = 1;\r\nif ((hw->rx_list_sts[0] == sts_free) &&\r\n(hw->rx_list_sts[1] == sts_free))\r\ncrystalhd_hw_finalize_pause(hw);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_hw_unpause(struct crystalhd_hw *hw)\r\n{\r\nenum BC_STATUS sts;\r\nuint32_t aspm;\r\nhw->stop_pending = 0;\r\naspm = crystalhd_reg_rd(hw->adp, PCIE_DLL_DATA_LINK_CONTROL);\r\naspm &= ~ASPM_L1_ENABLE;\r\ncrystalhd_reg_wr(hw->adp, PCIE_DLL_DATA_LINK_CONTROL, aspm);\r\nsts = crystalhd_hw_start_capture(hw);\r\nreturn sts;\r\n}\r\nenum BC_STATUS crystalhd_hw_suspend(struct crystalhd_hw *hw)\r\n{\r\nenum BC_STATUS sts;\r\nif (!hw) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nsts = crystalhd_put_ddr2sleep(hw);\r\nif (sts != BC_STS_SUCCESS) {\r\nBCMLOG_ERR("Failed to Put DDR To Sleep!!\n");\r\nreturn BC_STS_ERROR;\r\n}\r\nif (!crystalhd_stop_device(hw->adp)) {\r\nBCMLOG_ERR("Failed to Stop Device!!\n");\r\nreturn BC_STS_ERROR;\r\n}\r\nreturn BC_STS_SUCCESS;\r\n}\r\nvoid crystalhd_hw_stats(struct crystalhd_hw *hw, struct crystalhd_hw_stats *stats)\r\n{\r\nif (!hw) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn;\r\n}\r\nif (!stats) {\r\nmemset(&hw->stats, 0, sizeof(hw->stats));\r\nreturn;\r\n}\r\nhw->stats.freeq_count = crystalhd_dioq_count(hw->rx_freeq);\r\nhw->stats.rdyq_count = crystalhd_dioq_count(hw->rx_rdyq);\r\nmemcpy(stats, &hw->stats, sizeof(*stats));\r\n}\r\nenum BC_STATUS crystalhd_hw_set_core_clock(struct crystalhd_hw *hw)\r\n{\r\nuint32_t reg, n, i;\r\nuint32_t vco_mg, refresh_reg;\r\nif (!hw) {\r\nBCMLOG_ERR("Invalid Arguments\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nn = hw->core_clock_mhz/5;\r\nif (n == hw->prev_n)\r\nreturn BC_STS_CLK_NOCHG;\r\nif (hw->pwr_lock > 0) {\r\nreturn BC_STS_CLK_NOCHG;\r\n}\r\ni = n * 27;\r\nif (i < 560)\r\nvco_mg = 0;\r\nelse if (i < 900)\r\nvco_mg = 1;\r\nelse if (i < 1030)\r\nvco_mg = 2;\r\nelse\r\nvco_mg = 3;\r\nreg = bc_dec_reg_rd(hw->adp, DecHt_PllACtl);\r\nreg &= 0xFFFFCFC0;\r\nreg |= n;\r\nreg |= vco_mg << 12;\r\nBCMLOG(BCMLOG_INFO, "clock is moving to %d with n %d with vco_mg %d\n",\r\nhw->core_clock_mhz, n, vco_mg);\r\nrefresh_reg = (7 * hw->core_clock_mhz / 16);\r\nbc_dec_reg_wr(hw->adp, SDRAM_REF_PARAM, ((1 << 12) | refresh_reg));\r\nbc_dec_reg_wr(hw->adp, DecHt_PllACtl, reg);\r\ni = 0;\r\nfor (i = 0; i < 10; i++) {\r\nreg = bc_dec_reg_rd(hw->adp, DecHt_PllACtl);\r\nif (reg & 0x00020000) {\r\nhw->prev_n = n;\r\nBCMLOG(BCMLOG_INFO, "C");\r\nreturn BC_STS_SUCCESS;\r\n} else {\r\nmsleep_interruptible(10);\r\n}\r\n}\r\nBCMLOG(BCMLOG_INFO, "clk change failed\n");\r\nreturn BC_STS_CLK_NOCHG;\r\n}
