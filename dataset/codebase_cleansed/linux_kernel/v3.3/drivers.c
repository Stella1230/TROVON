static void cleanup_device(struct comedi_device *dev)\r\n{\r\nint i;\r\nstruct comedi_subdevice *s;\r\nif (dev->subdevices) {\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\ns = dev->subdevices + i;\r\ncomedi_free_subdevice_minor(s);\r\nif (s->async) {\r\ncomedi_buf_alloc(dev, s, 0);\r\nkfree(s->async);\r\n}\r\n}\r\nkfree(dev->subdevices);\r\ndev->subdevices = NULL;\r\ndev->n_subdevices = 0;\r\n}\r\nkfree(dev->private);\r\ndev->private = NULL;\r\ndev->driver = NULL;\r\ndev->board_name = NULL;\r\ndev->board_ptr = NULL;\r\ndev->iobase = 0;\r\ndev->irq = 0;\r\ndev->read_subdev = NULL;\r\ndev->write_subdev = NULL;\r\ndev->open = NULL;\r\ndev->close = NULL;\r\ncomedi_set_hw_dev(dev, NULL);\r\n}\r\nstatic void __comedi_device_detach(struct comedi_device *dev)\r\n{\r\ndev->attached = 0;\r\nif (dev->driver)\r\ndev->driver->detach(dev);\r\nelse\r\nprintk(KERN_WARNING\r\n"BUG: dev->driver=NULL in comedi_device_detach()\n");\r\ncleanup_device(dev);\r\n}\r\nvoid comedi_device_detach(struct comedi_device *dev)\r\n{\r\nif (!dev->attached)\r\nreturn;\r\n__comedi_device_detach(dev);\r\n}\r\nint comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct comedi_driver *driv;\r\nint ret;\r\nif (dev->attached)\r\nreturn -EBUSY;\r\nfor (driv = comedi_drivers; driv; driv = driv->next) {\r\nif (!try_module_get(driv->module)) {\r\nprintk(KERN_INFO "comedi: failed to increment module count, skipping\n");\r\ncontinue;\r\n}\r\nif (driv->num_names) {\r\ndev->board_ptr = comedi_recognize(driv, it->board_name);\r\nif (dev->board_ptr == NULL) {\r\nmodule_put(driv->module);\r\ncontinue;\r\n}\r\n} else {\r\nif (strcmp(driv->driver_name, it->board_name)) {\r\nmodule_put(driv->module);\r\ncontinue;\r\n}\r\n}\r\ndev->driver = driv;\r\nret = driv->attach(dev, it);\r\nif (ret < 0) {\r\nmodule_put(dev->driver->module);\r\n__comedi_device_detach(dev);\r\nreturn ret;\r\n}\r\ngoto attached;\r\n}\r\nfor (driv = comedi_drivers; driv; driv = driv->next) {\r\nif (!try_module_get(driv->module)) {\r\nprintk(KERN_INFO\r\n"comedi: failed to increment module count\n");\r\ncontinue;\r\n}\r\ncomedi_report_boards(driv);\r\nmodule_put(driv->module);\r\n}\r\nreturn -EIO;\r\nattached:\r\nret = postconfig(dev);\r\nmodule_put(dev->driver->module);\r\nif (ret < 0) {\r\n__comedi_device_detach(dev);\r\nreturn ret;\r\n}\r\nif (!dev->board_name) {\r\nprintk(KERN_WARNING "BUG: dev->board_name=<%p>\n",\r\ndev->board_name);\r\ndev->board_name = "BUG";\r\n}\r\nsmp_wmb();\r\ndev->attached = 1;\r\nreturn 0;\r\n}\r\nint comedi_driver_register(struct comedi_driver *driver)\r\n{\r\ndriver->next = comedi_drivers;\r\ncomedi_drivers = driver;\r\nreturn 0;\r\n}\r\nint comedi_driver_unregister(struct comedi_driver *driver)\r\n{\r\nstruct comedi_driver *prev;\r\nint i;\r\nfor (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {\r\nstruct comedi_device_file_info *dev_file_info =\r\ncomedi_get_device_file_info(i);\r\nstruct comedi_device *dev;\r\nif (dev_file_info == NULL)\r\ncontinue;\r\ndev = dev_file_info->device;\r\nmutex_lock(&dev->mutex);\r\nif (dev->attached && dev->driver == driver) {\r\nif (dev->use_count)\r\nprintk(KERN_WARNING "BUG! detaching device with use_count=%d\n",\r\ndev->use_count);\r\ncomedi_device_detach(dev);\r\n}\r\nmutex_unlock(&dev->mutex);\r\n}\r\nif (comedi_drivers == driver) {\r\ncomedi_drivers = driver->next;\r\nreturn 0;\r\n}\r\nfor (prev = comedi_drivers; prev->next; prev = prev->next) {\r\nif (prev->next == driver) {\r\nprev->next = driver->next;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int postconfig(struct comedi_device *dev)\r\n{\r\nint i;\r\nstruct comedi_subdevice *s;\r\nstruct comedi_async *async = NULL;\r\nint ret;\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\ns = dev->subdevices + i;\r\nif (s->type == COMEDI_SUBD_UNUSED)\r\ncontinue;\r\nif (s->len_chanlist == 0)\r\ns->len_chanlist = 1;\r\nif (s->do_cmd) {\r\nBUG_ON((s->subdev_flags & (SDF_CMD_READ |\r\nSDF_CMD_WRITE)) == 0);\r\nBUG_ON(!s->do_cmdtest);\r\nasync =\r\nkzalloc(sizeof(struct comedi_async), GFP_KERNEL);\r\nif (async == NULL) {\r\nprintk(KERN_INFO\r\n"failed to allocate async struct\n");\r\nreturn -ENOMEM;\r\n}\r\ninit_waitqueue_head(&async->wait_head);\r\nasync->subdevice = s;\r\ns->async = async;\r\n#define DEFAULT_BUF_MAXSIZE (64*1024)\r\n#define DEFAULT_BUF_SIZE (64*1024)\r\nasync->max_bufsize = DEFAULT_BUF_MAXSIZE;\r\nasync->prealloc_buf = NULL;\r\nasync->prealloc_bufsz = 0;\r\nif (comedi_buf_alloc(dev, s, DEFAULT_BUF_SIZE) < 0) {\r\nprintk(KERN_INFO "Buffer allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nif (s->buf_change) {\r\nret = s->buf_change(dev, s, DEFAULT_BUF_SIZE);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\ncomedi_alloc_subdevice_minor(dev, s);\r\n}\r\nif (!s->range_table && !s->range_table_list)\r\ns->range_table = &range_unknown;\r\nif (!s->insn_read && s->insn_bits)\r\ns->insn_read = insn_rw_emulate_bits;\r\nif (!s->insn_write && s->insn_bits)\r\ns->insn_write = insn_rw_emulate_bits;\r\nif (!s->insn_read)\r\ns->insn_read = insn_inval;\r\nif (!s->insn_write)\r\ns->insn_write = insn_inval;\r\nif (!s->insn_bits)\r\ns->insn_bits = insn_inval;\r\nif (!s->insn_config)\r\ns->insn_config = insn_inval;\r\nif (!s->poll)\r\ns->poll = poll_invalid;\r\n}\r\nreturn 0;\r\n}\r\nstatic void *comedi_recognize(struct comedi_driver *driv, const char *name)\r\n{\r\nunsigned i;\r\nconst char *const *name_ptr = driv->board_name;\r\nfor (i = 0; i < driv->num_names; i++) {\r\nif (strcmp(*name_ptr, name) == 0)\r\nreturn (void *)name_ptr;\r\nname_ptr =\r\n(const char *const *)((const char *)name_ptr +\r\ndriv->offset);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void comedi_report_boards(struct comedi_driver *driv)\r\n{\r\nunsigned int i;\r\nconst char *const *name_ptr;\r\nprintk(KERN_INFO "comedi: valid board names for %s driver are:\n",\r\ndriv->driver_name);\r\nname_ptr = driv->board_name;\r\nfor (i = 0; i < driv->num_names; i++) {\r\nprintk(KERN_INFO " %s\n", *name_ptr);\r\nname_ptr = (const char **)((char *)name_ptr + driv->offset);\r\n}\r\nif (driv->num_names == 0)\r\nprintk(KERN_INFO " %s\n", driv->driver_name);\r\n}\r\nstatic int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int insn_rw_emulate_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct comedi_insn new_insn;\r\nint ret;\r\nstatic const unsigned channels_per_bitfield = 32;\r\nunsigned chan = CR_CHAN(insn->chanspec);\r\nconst unsigned base_bitfield_channel =\r\n(chan < channels_per_bitfield) ? 0 : chan;\r\nunsigned int new_data[2];\r\nmemset(new_data, 0, sizeof(new_data));\r\nmemset(&new_insn, 0, sizeof(new_insn));\r\nnew_insn.insn = INSN_BITS;\r\nnew_insn.chanspec = base_bitfield_channel;\r\nnew_insn.n = 2;\r\nnew_insn.data = new_data;\r\nnew_insn.subdev = insn->subdev;\r\nif (insn->insn == INSN_WRITE) {\r\nif (!(s->subdev_flags & SDF_WRITABLE))\r\nreturn -EINVAL;\r\nnew_data[0] = 1 << (chan - base_bitfield_channel);\r\nnew_data[1] = data[0] ? (1 << (chan - base_bitfield_channel))\r\n: 0;\r\n}\r\nret = s->insn_bits(dev, s, &new_insn, new_data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (insn->insn == INSN_READ)\r\ndata[0] = (new_data[1] >> (chan - base_bitfield_channel)) & 1;\r\nreturn 1;\r\n}\r\nstatic inline unsigned long uvirt_to_kva(pgd_t *pgd, unsigned long adr)\r\n{\r\nunsigned long ret = 0UL;\r\npmd_t *pmd;\r\npte_t *ptep, pte;\r\npud_t *pud;\r\nif (!pgd_none(*pgd)) {\r\npud = pud_offset(pgd, adr);\r\npmd = pmd_offset(pud, adr);\r\nif (!pmd_none(*pmd)) {\r\nptep = pte_offset_kernel(pmd, adr);\r\npte = *ptep;\r\nif (pte_present(pte)) {\r\nret = (unsigned long)\r\npage_address(pte_page(pte));\r\nret |= (adr & (PAGE_SIZE - 1));\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic inline unsigned long kvirt_to_kva(unsigned long adr)\r\n{\r\nunsigned long va, kva;\r\nva = adr;\r\nkva = uvirt_to_kva(pgd_offset_k(va), va);\r\nreturn kva;\r\n}\r\nint comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,\r\nunsigned long new_size)\r\n{\r\nstruct comedi_async *async = s->async;\r\nnew_size = (new_size + PAGE_SIZE - 1) & PAGE_MASK;\r\nif (async->prealloc_buf && async->prealloc_bufsz == new_size)\r\nreturn 0;\r\nif (async->prealloc_buf) {\r\nvunmap(async->prealloc_buf);\r\nasync->prealloc_buf = NULL;\r\nasync->prealloc_bufsz = 0;\r\n}\r\nif (async->buf_page_list) {\r\nunsigned i;\r\nfor (i = 0; i < async->n_buf_pages; ++i) {\r\nif (async->buf_page_list[i].virt_addr) {\r\nclear_bit(PG_reserved,\r\n&(virt_to_page(async->buf_page_list[i].\r\nvirt_addr)->flags));\r\nif (s->async_dma_dir != DMA_NONE) {\r\ndma_free_coherent(dev->hw_dev,\r\nPAGE_SIZE,\r\nasync->\r\nbuf_page_list\r\n[i].virt_addr,\r\nasync->\r\nbuf_page_list\r\n[i].dma_addr);\r\n} else {\r\nfree_page((unsigned long)\r\nasync->buf_page_list[i].\r\nvirt_addr);\r\n}\r\n}\r\n}\r\nvfree(async->buf_page_list);\r\nasync->buf_page_list = NULL;\r\nasync->n_buf_pages = 0;\r\n}\r\nif (new_size) {\r\nunsigned i = 0;\r\nunsigned n_pages = new_size >> PAGE_SHIFT;\r\nstruct page **pages = NULL;\r\nasync->buf_page_list =\r\nvzalloc(sizeof(struct comedi_buf_page) * n_pages);\r\nif (async->buf_page_list)\r\npages = vmalloc(sizeof(struct page *) * n_pages);\r\nif (pages) {\r\nfor (i = 0; i < n_pages; i++) {\r\nif (s->async_dma_dir != DMA_NONE) {\r\nasync->buf_page_list[i].virt_addr =\r\ndma_alloc_coherent(dev->hw_dev,\r\nPAGE_SIZE,\r\n&async->\r\nbuf_page_list\r\n[i].dma_addr,\r\nGFP_KERNEL |\r\n__GFP_COMP);\r\n} else {\r\nasync->buf_page_list[i].virt_addr =\r\n(void *)\r\nget_zeroed_page(GFP_KERNEL);\r\n}\r\nif (async->buf_page_list[i].virt_addr == NULL)\r\nbreak;\r\nset_bit(PG_reserved,\r\n&(virt_to_page(async->buf_page_list[i].\r\nvirt_addr)->flags));\r\npages[i] = virt_to_page(async->buf_page_list[i].\r\nvirt_addr);\r\n}\r\n}\r\nif (i == n_pages) {\r\nasync->prealloc_buf =\r\n#ifdef PAGE_KERNEL_NOCACHE\r\nvmap(pages, n_pages, VM_MAP, PAGE_KERNEL_NOCACHE);\r\n#else\r\nvmap(pages, n_pages, VM_MAP, PAGE_KERNEL);\r\n#endif\r\n}\r\nvfree(pages);\r\nif (async->prealloc_buf == NULL) {\r\nif (async->buf_page_list) {\r\nfor (i = 0; i < n_pages; i++) {\r\nif (async->buf_page_list[i].virt_addr ==\r\nNULL) {\r\nbreak;\r\n}\r\nclear_bit(PG_reserved,\r\n&(virt_to_page(async->\r\nbuf_page_list[i].\r\nvirt_addr)->flags));\r\nif (s->async_dma_dir != DMA_NONE) {\r\ndma_free_coherent(dev->hw_dev,\r\nPAGE_SIZE,\r\nasync->\r\nbuf_page_list\r\n[i].virt_addr,\r\nasync->\r\nbuf_page_list\r\n[i].dma_addr);\r\n} else {\r\nfree_page((unsigned long)\r\nasync->buf_page_list\r\n[i].virt_addr);\r\n}\r\n}\r\nvfree(async->buf_page_list);\r\nasync->buf_page_list = NULL;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nasync->n_buf_pages = n_pages;\r\n}\r\nasync->prealloc_bufsz = new_size;\r\nreturn 0;\r\n}\r\nstatic unsigned int comedi_buf_munge(struct comedi_async *async,\r\nunsigned int num_bytes)\r\n{\r\nstruct comedi_subdevice *s = async->subdevice;\r\nunsigned int count = 0;\r\nconst unsigned num_sample_bytes = bytes_per_sample(s);\r\nif (s->munge == NULL || (async->cmd.flags & CMDF_RAWDATA)) {\r\nasync->munge_count += num_bytes;\r\nBUG_ON((int)(async->munge_count - async->buf_write_count) > 0);\r\nreturn num_bytes;\r\n}\r\nnum_bytes -= num_bytes % num_sample_bytes;\r\nwhile (count < num_bytes) {\r\nint block_size;\r\nblock_size = num_bytes - count;\r\nif (block_size < 0) {\r\nprintk(KERN_WARNING\r\n"%s: %s: bug! block_size is negative\n",\r\n__FILE__, __func__);\r\nbreak;\r\n}\r\nif ((int)(async->munge_ptr + block_size -\r\nasync->prealloc_bufsz) > 0)\r\nblock_size = async->prealloc_bufsz - async->munge_ptr;\r\ns->munge(s->device, s, async->prealloc_buf + async->munge_ptr,\r\nblock_size, async->munge_chan);\r\nsmp_wmb();\r\nasync->munge_chan += block_size / num_sample_bytes;\r\nasync->munge_chan %= async->cmd.chanlist_len;\r\nasync->munge_count += block_size;\r\nasync->munge_ptr += block_size;\r\nasync->munge_ptr %= async->prealloc_bufsz;\r\ncount += block_size;\r\n}\r\nBUG_ON((int)(async->munge_count - async->buf_write_count) > 0);\r\nreturn count;\r\n}\r\nunsigned int comedi_buf_write_n_available(struct comedi_async *async)\r\n{\r\nunsigned int free_end;\r\nunsigned int nbytes;\r\nif (async == NULL)\r\nreturn 0;\r\nfree_end = async->buf_read_count + async->prealloc_bufsz;\r\nnbytes = free_end - async->buf_write_alloc_count;\r\nnbytes -= nbytes % bytes_per_sample(async->subdevice);\r\nsmp_mb();\r\nreturn nbytes;\r\n}\r\nunsigned int comedi_buf_write_alloc(struct comedi_async *async,\r\nunsigned int nbytes)\r\n{\r\nunsigned int free_end = async->buf_read_count + async->prealloc_bufsz;\r\nif ((int)(async->buf_write_alloc_count + nbytes - free_end) > 0)\r\nnbytes = free_end - async->buf_write_alloc_count;\r\nasync->buf_write_alloc_count += nbytes;\r\nsmp_mb();\r\nreturn nbytes;\r\n}\r\nunsigned int comedi_buf_write_alloc_strict(struct comedi_async *async,\r\nunsigned int nbytes)\r\n{\r\nunsigned int free_end = async->buf_read_count + async->prealloc_bufsz;\r\nif ((int)(async->buf_write_alloc_count + nbytes - free_end) > 0)\r\nnbytes = 0;\r\nasync->buf_write_alloc_count += nbytes;\r\nsmp_mb();\r\nreturn nbytes;\r\n}\r\nunsigned comedi_buf_write_free(struct comedi_async *async, unsigned int nbytes)\r\n{\r\nif ((int)(async->buf_write_count + nbytes -\r\nasync->buf_write_alloc_count) > 0) {\r\nprintk(KERN_INFO "comedi: attempted to write-free more bytes than have been write-allocated.\n");\r\nnbytes = async->buf_write_alloc_count - async->buf_write_count;\r\n}\r\nasync->buf_write_count += nbytes;\r\nasync->buf_write_ptr += nbytes;\r\ncomedi_buf_munge(async, async->buf_write_count - async->munge_count);\r\nif (async->buf_write_ptr >= async->prealloc_bufsz)\r\nasync->buf_write_ptr %= async->prealloc_bufsz;\r\nreturn nbytes;\r\n}\r\nunsigned comedi_buf_read_alloc(struct comedi_async *async, unsigned nbytes)\r\n{\r\nif ((int)(async->buf_read_alloc_count + nbytes - async->munge_count) >\r\n0) {\r\nnbytes = async->munge_count - async->buf_read_alloc_count;\r\n}\r\nasync->buf_read_alloc_count += nbytes;\r\nsmp_rmb();\r\nreturn nbytes;\r\n}\r\nunsigned comedi_buf_read_free(struct comedi_async *async, unsigned int nbytes)\r\n{\r\nsmp_mb();\r\nif ((int)(async->buf_read_count + nbytes -\r\nasync->buf_read_alloc_count) > 0) {\r\nprintk(KERN_INFO\r\n"comedi: attempted to read-free more bytes than have been read-allocated.\n");\r\nnbytes = async->buf_read_alloc_count - async->buf_read_count;\r\n}\r\nasync->buf_read_count += nbytes;\r\nasync->buf_read_ptr += nbytes;\r\nasync->buf_read_ptr %= async->prealloc_bufsz;\r\nreturn nbytes;\r\n}\r\nvoid comedi_buf_memcpy_to(struct comedi_async *async, unsigned int offset,\r\nconst void *data, unsigned int num_bytes)\r\n{\r\nunsigned int write_ptr = async->buf_write_ptr + offset;\r\nif (write_ptr >= async->prealloc_bufsz)\r\nwrite_ptr %= async->prealloc_bufsz;\r\nwhile (num_bytes) {\r\nunsigned int block_size;\r\nif (write_ptr + num_bytes > async->prealloc_bufsz)\r\nblock_size = async->prealloc_bufsz - write_ptr;\r\nelse\r\nblock_size = num_bytes;\r\nmemcpy(async->prealloc_buf + write_ptr, data, block_size);\r\ndata += block_size;\r\nnum_bytes -= block_size;\r\nwrite_ptr = 0;\r\n}\r\n}\r\nvoid comedi_buf_memcpy_from(struct comedi_async *async, unsigned int offset,\r\nvoid *dest, unsigned int nbytes)\r\n{\r\nvoid *src;\r\nunsigned int read_ptr = async->buf_read_ptr + offset;\r\nif (read_ptr >= async->prealloc_bufsz)\r\nread_ptr %= async->prealloc_bufsz;\r\nwhile (nbytes) {\r\nunsigned int block_size;\r\nsrc = async->prealloc_buf + read_ptr;\r\nif (nbytes >= async->prealloc_bufsz - read_ptr)\r\nblock_size = async->prealloc_bufsz - read_ptr;\r\nelse\r\nblock_size = nbytes;\r\nmemcpy(dest, src, block_size);\r\nnbytes -= block_size;\r\ndest += block_size;\r\nread_ptr = 0;\r\n}\r\n}\r\nunsigned int comedi_buf_read_n_available(struct comedi_async *async)\r\n{\r\nunsigned num_bytes;\r\nif (async == NULL)\r\nreturn 0;\r\nnum_bytes = async->munge_count - async->buf_read_count;\r\nsmp_rmb();\r\nreturn num_bytes;\r\n}\r\nint comedi_buf_get(struct comedi_async *async, short *x)\r\n{\r\nunsigned int n = comedi_buf_read_n_available(async);\r\nif (n < sizeof(short))\r\nreturn 0;\r\ncomedi_buf_read_alloc(async, sizeof(short));\r\n*x = *(short *)(async->prealloc_buf + async->buf_read_ptr);\r\ncomedi_buf_read_free(async, sizeof(short));\r\nreturn 1;\r\n}\r\nint comedi_buf_put(struct comedi_async *async, short x)\r\n{\r\nunsigned int n = comedi_buf_write_alloc_strict(async, sizeof(short));\r\nif (n < sizeof(short)) {\r\nasync->events |= COMEDI_CB_ERROR;\r\nreturn 0;\r\n}\r\n*(short *)(async->prealloc_buf + async->buf_write_ptr) = x;\r\ncomedi_buf_write_free(async, sizeof(short));\r\nreturn 1;\r\n}\r\nvoid comedi_reset_async_buf(struct comedi_async *async)\r\n{\r\nasync->buf_write_alloc_count = 0;\r\nasync->buf_write_count = 0;\r\nasync->buf_read_alloc_count = 0;\r\nasync->buf_read_count = 0;\r\nasync->buf_write_ptr = 0;\r\nasync->buf_read_ptr = 0;\r\nasync->cur_chan = 0;\r\nasync->scan_progress = 0;\r\nasync->munge_chan = 0;\r\nasync->munge_count = 0;\r\nasync->munge_ptr = 0;\r\nasync->events = 0;\r\n}\r\nstatic int comedi_auto_config(struct device *hardware_device,\r\nconst char *board_name, const int *options,\r\nunsigned num_options)\r\n{\r\nstruct comedi_devconfig it;\r\nint minor;\r\nstruct comedi_device_file_info *dev_file_info;\r\nint retval;\r\nunsigned *private_data = NULL;\r\nif (!comedi_autoconfig) {\r\ndev_set_drvdata(hardware_device, NULL);\r\nreturn 0;\r\n}\r\nminor = comedi_alloc_board_minor(hardware_device);\r\nif (minor < 0)\r\nreturn minor;\r\nprivate_data = kmalloc(sizeof(unsigned), GFP_KERNEL);\r\nif (private_data == NULL) {\r\nretval = -ENOMEM;\r\ngoto cleanup;\r\n}\r\n*private_data = minor;\r\ndev_set_drvdata(hardware_device, private_data);\r\ndev_file_info = comedi_get_device_file_info(minor);\r\nmemset(&it, 0, sizeof(it));\r\nstrncpy(it.board_name, board_name, COMEDI_NAMELEN);\r\nit.board_name[COMEDI_NAMELEN - 1] = '\0';\r\nBUG_ON(num_options > COMEDI_NDEVCONFOPTS);\r\nmemcpy(it.options, options, num_options * sizeof(int));\r\nmutex_lock(&dev_file_info->device->mutex);\r\nretval = comedi_device_attach(dev_file_info->device, &it);\r\nmutex_unlock(&dev_file_info->device->mutex);\r\ncleanup:\r\nif (retval < 0) {\r\nkfree(private_data);\r\ncomedi_free_board_minor(minor);\r\n}\r\nreturn retval;\r\n}\r\nstatic void comedi_auto_unconfig(struct device *hardware_device)\r\n{\r\nunsigned *minor = (unsigned *)dev_get_drvdata(hardware_device);\r\nif (minor == NULL)\r\nreturn;\r\nBUG_ON(*minor >= COMEDI_NUM_BOARD_MINORS);\r\ncomedi_free_board_minor(*minor);\r\ndev_set_drvdata(hardware_device, NULL);\r\nkfree(minor);\r\n}\r\nint comedi_pci_auto_config(struct pci_dev *pcidev, const char *board_name)\r\n{\r\nint options[2];\r\noptions[0] = pcidev->bus->number;\r\noptions[1] = PCI_SLOT(pcidev->devfn);\r\nreturn comedi_auto_config(&pcidev->dev, board_name,\r\noptions, ARRAY_SIZE(options));\r\n}\r\nvoid comedi_pci_auto_unconfig(struct pci_dev *pcidev)\r\n{\r\ncomedi_auto_unconfig(&pcidev->dev);\r\n}\r\nint comedi_usb_auto_config(struct usb_device *usbdev, const char *board_name)\r\n{\r\nBUG_ON(usbdev == NULL);\r\nreturn comedi_auto_config(&usbdev->dev, board_name, NULL, 0);\r\n}\r\nvoid comedi_usb_auto_unconfig(struct usb_device *usbdev)\r\n{\r\nBUG_ON(usbdev == NULL);\r\ncomedi_auto_unconfig(&usbdev->dev);\r\n}
