static void\r\nnvc0_fifo_playlist_update(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_instmem_engine *pinstmem = &dev_priv->engine.instmem;\r\nstruct nouveau_fifo_engine *pfifo = &dev_priv->engine.fifo;\r\nstruct nvc0_fifo_priv *priv = pfifo->priv;\r\nstruct nouveau_gpuobj *cur;\r\nint i, p;\r\ncur = priv->playlist[priv->cur_playlist];\r\npriv->cur_playlist = !priv->cur_playlist;\r\nfor (i = 0, p = 0; i < 128; i++) {\r\nif (!(nv_rd32(dev, 0x3004 + (i * 8)) & 1))\r\ncontinue;\r\nnv_wo32(cur, p + 0, i);\r\nnv_wo32(cur, p + 4, 0x00000004);\r\np += 8;\r\n}\r\npinstmem->flush(dev);\r\nnv_wr32(dev, 0x002270, cur->vinst >> 12);\r\nnv_wr32(dev, 0x002274, 0x01f00000 | (p >> 3));\r\nif (!nv_wait(dev, 0x00227c, 0x00100000, 0x00000000))\r\nNV_ERROR(dev, "PFIFO - playlist update failed\n");\r\n}\r\nvoid\r\nnvc0_fifo_disable(struct drm_device *dev)\r\n{\r\n}\r\nvoid\r\nnvc0_fifo_enable(struct drm_device *dev)\r\n{\r\n}\r\nbool\r\nnvc0_fifo_reassign(struct drm_device *dev, bool enable)\r\n{\r\nreturn false;\r\n}\r\nbool\r\nnvc0_fifo_cache_pull(struct drm_device *dev, bool enable)\r\n{\r\nreturn false;\r\n}\r\nint\r\nnvc0_fifo_channel_id(struct drm_device *dev)\r\n{\r\nreturn 127;\r\n}\r\nint\r\nnvc0_fifo_create_context(struct nouveau_channel *chan)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_instmem_engine *pinstmem = &dev_priv->engine.instmem;\r\nstruct nouveau_fifo_engine *pfifo = &dev_priv->engine.fifo;\r\nstruct nvc0_fifo_priv *priv = pfifo->priv;\r\nstruct nvc0_fifo_chan *fifoch;\r\nu64 ib_virt = chan->pushbuf_base + chan->dma.ib_base * 4;\r\nint ret;\r\nchan->fifo_priv = kzalloc(sizeof(*fifoch), GFP_KERNEL);\r\nif (!chan->fifo_priv)\r\nreturn -ENOMEM;\r\nfifoch = chan->fifo_priv;\r\nret = nouveau_gpuobj_new(dev, NULL, 0x1000, 0x1000,\r\nNVOBJ_FLAG_ZERO_ALLOC, &fifoch->user);\r\nif (ret)\r\ngoto error;\r\nnouveau_vm_map_at(&priv->user_vma, chan->id * 0x1000,\r\n*(struct nouveau_mem **)fifoch->user->node);\r\nchan->user = ioremap_wc(pci_resource_start(dev->pdev, 1) +\r\npriv->user_vma.offset + (chan->id * 0x1000),\r\nPAGE_SIZE);\r\nif (!chan->user) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nret = nouveau_gpuobj_new_fake(dev, chan->ramin->pinst,\r\nchan->ramin->vinst, 0x100,\r\nNVOBJ_FLAG_ZERO_ALLOC, &fifoch->ramfc);\r\nif (ret)\r\ngoto error;\r\nnv_wo32(fifoch->ramfc, 0x08, lower_32_bits(fifoch->user->vinst));\r\nnv_wo32(fifoch->ramfc, 0x0c, upper_32_bits(fifoch->user->vinst));\r\nnv_wo32(fifoch->ramfc, 0x10, 0x0000face);\r\nnv_wo32(fifoch->ramfc, 0x30, 0xfffff902);\r\nnv_wo32(fifoch->ramfc, 0x48, lower_32_bits(ib_virt));\r\nnv_wo32(fifoch->ramfc, 0x4c, drm_order(chan->dma.ib_max + 1) << 16 |\r\nupper_32_bits(ib_virt));\r\nnv_wo32(fifoch->ramfc, 0x54, 0x00000002);\r\nnv_wo32(fifoch->ramfc, 0x84, 0x20400000);\r\nnv_wo32(fifoch->ramfc, 0x94, 0x30000001);\r\nnv_wo32(fifoch->ramfc, 0x9c, 0x00000100);\r\nnv_wo32(fifoch->ramfc, 0xa4, 0x1f1f1f1f);\r\nnv_wo32(fifoch->ramfc, 0xa8, 0x1f1f1f1f);\r\nnv_wo32(fifoch->ramfc, 0xac, 0x0000001f);\r\nnv_wo32(fifoch->ramfc, 0xb8, 0xf8000000);\r\nnv_wo32(fifoch->ramfc, 0xf8, 0x10003080);\r\nnv_wo32(fifoch->ramfc, 0xfc, 0x10000010);\r\npinstmem->flush(dev);\r\nnv_wr32(dev, 0x003000 + (chan->id * 8), 0xc0000000 |\r\n(chan->ramin->vinst >> 12));\r\nnv_wr32(dev, 0x003004 + (chan->id * 8), 0x001f0001);\r\nnvc0_fifo_playlist_update(dev);\r\nreturn 0;\r\nerror:\r\npfifo->destroy_context(chan);\r\nreturn ret;\r\n}\r\nvoid\r\nnvc0_fifo_destroy_context(struct nouveau_channel *chan)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct nvc0_fifo_chan *fifoch;\r\nnv_mask(dev, 0x003004 + (chan->id * 8), 0x00000001, 0x00000000);\r\nnv_wr32(dev, 0x002634, chan->id);\r\nif (!nv_wait(dev, 0x0002634, 0xffffffff, chan->id))\r\nNV_WARN(dev, "0x2634 != chid: 0x%08x\n", nv_rd32(dev, 0x2634));\r\nnvc0_fifo_playlist_update(dev);\r\nnv_wr32(dev, 0x003000 + (chan->id * 8), 0x00000000);\r\nif (chan->user) {\r\niounmap(chan->user);\r\nchan->user = NULL;\r\n}\r\nfifoch = chan->fifo_priv;\r\nchan->fifo_priv = NULL;\r\nif (!fifoch)\r\nreturn;\r\nnouveau_gpuobj_ref(NULL, &fifoch->ramfc);\r\nnouveau_gpuobj_ref(NULL, &fifoch->user);\r\nkfree(fifoch);\r\n}\r\nint\r\nnvc0_fifo_load_context(struct nouveau_channel *chan)\r\n{\r\nreturn 0;\r\n}\r\nint\r\nnvc0_fifo_unload_context(struct drm_device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < 128; i++) {\r\nif (!(nv_rd32(dev, 0x003004 + (i * 8)) & 1))\r\ncontinue;\r\nnv_mask(dev, 0x003004 + (i * 8), 0x00000001, 0x00000000);\r\nnv_wr32(dev, 0x002634, i);\r\nif (!nv_wait(dev, 0x002634, 0xffffffff, i)) {\r\nNV_INFO(dev, "PFIFO: kick ch %d failed: 0x%08x\n",\r\ni, nv_rd32(dev, 0x002634));\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nnvc0_fifo_destroy(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_fifo_engine *pfifo = &dev_priv->engine.fifo;\r\nstruct nvc0_fifo_priv *priv;\r\npriv = pfifo->priv;\r\nif (!priv)\r\nreturn;\r\nnouveau_vm_put(&priv->user_vma);\r\nnouveau_gpuobj_ref(NULL, &priv->playlist[1]);\r\nnouveau_gpuobj_ref(NULL, &priv->playlist[0]);\r\nkfree(priv);\r\n}\r\nvoid\r\nnvc0_fifo_takedown(struct drm_device *dev)\r\n{\r\nnv_wr32(dev, 0x002140, 0x00000000);\r\nnvc0_fifo_destroy(dev);\r\n}\r\nstatic int\r\nnvc0_fifo_create(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_fifo_engine *pfifo = &dev_priv->engine.fifo;\r\nstruct nvc0_fifo_priv *priv;\r\nint ret;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npfifo->priv = priv;\r\nret = nouveau_gpuobj_new(dev, NULL, 0x1000, 0x1000, 0,\r\n&priv->playlist[0]);\r\nif (ret)\r\ngoto error;\r\nret = nouveau_gpuobj_new(dev, NULL, 0x1000, 0x1000, 0,\r\n&priv->playlist[1]);\r\nif (ret)\r\ngoto error;\r\nret = nouveau_vm_get(dev_priv->bar1_vm, pfifo->channels * 0x1000,\r\n12, NV_MEM_ACCESS_RW, &priv->user_vma);\r\nif (ret)\r\ngoto error;\r\nnouveau_irq_register(dev, 8, nvc0_fifo_isr);\r\nNVOBJ_CLASS(dev, 0x506e, SW);\r\nreturn 0;\r\nerror:\r\nnvc0_fifo_destroy(dev);\r\nreturn ret;\r\n}\r\nint\r\nnvc0_fifo_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_fifo_engine *pfifo = &dev_priv->engine.fifo;\r\nstruct nouveau_channel *chan;\r\nstruct nvc0_fifo_priv *priv;\r\nint ret, i;\r\nif (!pfifo->priv) {\r\nret = nvc0_fifo_create(dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\npriv = pfifo->priv;\r\nnv_mask(dev, 0x000200, 0x00000100, 0x00000000);\r\nnv_mask(dev, 0x000200, 0x00000100, 0x00000100);\r\nnv_wr32(dev, 0x000204, 0xffffffff);\r\nnv_wr32(dev, 0x002204, 0xffffffff);\r\npriv->spoon_nr = hweight32(nv_rd32(dev, 0x002204));\r\nNV_DEBUG(dev, "PFIFO: %d subfifo(s)\n", priv->spoon_nr);\r\nif (priv->spoon_nr >= 3) {\r\nnv_wr32(dev, 0x002208, ~(1 << 0));\r\nnv_wr32(dev, 0x00220c, ~(1 << 1));\r\nnv_wr32(dev, 0x002210, ~(1 << 1));\r\nnv_wr32(dev, 0x002214, ~(1 << 1));\r\nnv_wr32(dev, 0x002218, ~(1 << 2));\r\nnv_wr32(dev, 0x00221c, ~(1 << 1));\r\n}\r\nfor (i = 0; i < priv->spoon_nr; i++) {\r\nnv_mask(dev, 0x04013c + (i * 0x2000), 0x10000100, 0x00000000);\r\nnv_wr32(dev, 0x040108 + (i * 0x2000), 0xffffffff);\r\nnv_wr32(dev, 0x04010c + (i * 0x2000), 0xfffffeff);\r\n}\r\nnv_mask(dev, 0x002200, 0x00000001, 0x00000001);\r\nnv_wr32(dev, 0x002254, 0x10000000 | priv->user_vma.offset >> 12);\r\nnv_wr32(dev, 0x002a00, 0xffffffff);\r\nnv_wr32(dev, 0x002100, 0xffffffff);\r\nnv_wr32(dev, 0x002140, 0xbfffffff);\r\nfor (i = 0; i < 128; i++) {\r\nchan = dev_priv->channels.ptr[i];\r\nif (!chan || !chan->fifo_priv)\r\ncontinue;\r\nnv_wr32(dev, 0x003000 + (i * 8), 0xc0000000 |\r\n(chan->ramin->vinst >> 12));\r\nnv_wr32(dev, 0x003004 + (i * 8), 0x001f0001);\r\n}\r\nnvc0_fifo_playlist_update(dev);\r\nreturn 0;\r\n}\r\nstatic void\r\nnvc0_fifo_isr_vm_fault(struct drm_device *dev, int unit)\r\n{\r\nu32 inst = nv_rd32(dev, 0x2800 + (unit * 0x10));\r\nu32 valo = nv_rd32(dev, 0x2804 + (unit * 0x10));\r\nu32 vahi = nv_rd32(dev, 0x2808 + (unit * 0x10));\r\nu32 stat = nv_rd32(dev, 0x280c + (unit * 0x10));\r\nu32 client = (stat & 0x00001f00) >> 8;\r\nNV_INFO(dev, "PFIFO: %s fault at 0x%010llx [",\r\n(stat & 0x00000080) ? "write" : "read", (u64)vahi << 32 | valo);\r\nnouveau_enum_print(nvc0_fifo_fault_reason, stat & 0x0000000f);\r\nprintk("] from ");\r\nnouveau_enum_print(nvc0_fifo_fault_unit, unit);\r\nif (stat & 0x00000040) {\r\nprintk("/");\r\nnouveau_enum_print(nvc0_fifo_fault_hubclient, client);\r\n} else {\r\nprintk("/GPC%d/", (stat & 0x1f000000) >> 24);\r\nnouveau_enum_print(nvc0_fifo_fault_gpcclient, client);\r\n}\r\nprintk(" on channel 0x%010llx\n", (u64)inst << 12);\r\n}\r\nstatic void\r\nnvc0_fifo_isr_subfifo_intr(struct drm_device *dev, int unit)\r\n{\r\nu32 stat = nv_rd32(dev, 0x040108 + (unit * 0x2000));\r\nu32 addr = nv_rd32(dev, 0x0400c0 + (unit * 0x2000));\r\nu32 data = nv_rd32(dev, 0x0400c4 + (unit * 0x2000));\r\nu32 chid = nv_rd32(dev, 0x040120 + (unit * 0x2000)) & 0x7f;\r\nu32 subc = (addr & 0x00070000);\r\nu32 mthd = (addr & 0x00003ffc);\r\nNV_INFO(dev, "PSUBFIFO %d:", unit);\r\nnouveau_bitfield_print(nvc0_fifo_subfifo_intr, stat);\r\nNV_INFO(dev, "PSUBFIFO %d: ch %d subc %d mthd 0x%04x data 0x%08x\n",\r\nunit, chid, subc, mthd, data);\r\nnv_wr32(dev, 0x0400c0 + (unit * 0x2000), 0x80600008);\r\nnv_wr32(dev, 0x040108 + (unit * 0x2000), stat);\r\n}\r\nstatic void\r\nnvc0_fifo_isr(struct drm_device *dev)\r\n{\r\nu32 stat = nv_rd32(dev, 0x002100);\r\nif (stat & 0x00000100) {\r\nNV_INFO(dev, "PFIFO: unknown status 0x00000100\n");\r\nnv_wr32(dev, 0x002100, 0x00000100);\r\nstat &= ~0x00000100;\r\n}\r\nif (stat & 0x10000000) {\r\nu32 units = nv_rd32(dev, 0x00259c);\r\nu32 u = units;\r\nwhile (u) {\r\nint i = ffs(u) - 1;\r\nnvc0_fifo_isr_vm_fault(dev, i);\r\nu &= ~(1 << i);\r\n}\r\nnv_wr32(dev, 0x00259c, units);\r\nstat &= ~0x10000000;\r\n}\r\nif (stat & 0x20000000) {\r\nu32 units = nv_rd32(dev, 0x0025a0);\r\nu32 u = units;\r\nwhile (u) {\r\nint i = ffs(u) - 1;\r\nnvc0_fifo_isr_subfifo_intr(dev, i);\r\nu &= ~(1 << i);\r\n}\r\nnv_wr32(dev, 0x0025a0, units);\r\nstat &= ~0x20000000;\r\n}\r\nif (stat & 0x40000000) {\r\nNV_INFO(dev, "PFIFO: unknown status 0x40000000\n");\r\nnv_mask(dev, 0x002a00, 0x00000000, 0x00000000);\r\nstat &= ~0x40000000;\r\n}\r\nif (stat) {\r\nNV_INFO(dev, "PFIFO: unhandled status 0x%08x\n", stat);\r\nnv_wr32(dev, 0x002100, stat);\r\nnv_wr32(dev, 0x002140, 0);\r\n}\r\n}
