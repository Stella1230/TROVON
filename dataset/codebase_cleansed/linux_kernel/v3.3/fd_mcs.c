static int __init fd_mcs_setup(char *str)\r\n{\r\nstatic int done_setup = 0;\r\nint ints[3];\r\nget_options(str, 3, ints);\r\nif (done_setup++ || ints[0] < 1 || ints[0] > 2 || ints[1] < 1 || ints[1] > 16) {\r\nprintk("fd_mcs: usage: fd_mcs=FIFO_COUNT, FIFO_SIZE\n");\r\nreturn 0;\r\n}\r\nuser_fifo_count = ints[0] >= 1 ? ints[1] : 0;\r\nuser_fifo_size = ints[0] >= 2 ? ints[2] : 0;\r\nreturn 1;\r\n}\r\nstatic void print_banner(struct Scsi_Host *shpnt)\r\n{\r\nprintk("scsi%d <fd_mcs>: ", shpnt->host_no);\r\nif (bios_base) {\r\nprintk("BIOS at 0x%lX", bios_base);\r\n} else {\r\nprintk("No BIOS");\r\n}\r\nprintk(", HostID %d, %s Chip, IRQ %d, IO 0x%lX\n", shpnt->this_id, chip == tmc18c50 ? "TMC-18C50" : (chip == tmc18c30 ? "TMC-18C30" : (chip == tmc1800 ? "TMC-1800" : "Unknown")), shpnt->irq, shpnt->io_port);\r\n}\r\nstatic void do_pause(unsigned amount)\r\n{\r\ndo {\r\nmdelay(10);\r\n} while (--amount);\r\n}\r\nstatic void fd_mcs_make_bus_idle(struct Scsi_Host *shpnt)\r\n{\r\noutb(0, SCSI_Cntl_port);\r\noutb(0, SCSI_Mode_Cntl_port);\r\nif (chip == tmc18c50 || chip == tmc18c30)\r\noutb(0x21 | PARITY_MASK, TMC_Cntl_port);\r\nelse\r\noutb(0x01 | PARITY_MASK, TMC_Cntl_port);\r\n}\r\nstatic int fd_mcs_detect(struct scsi_host_template * tpnt)\r\n{\r\nint loop;\r\nstruct Scsi_Host *shpnt;\r\nint slot;\r\nu_char pos2, pos3, pos4;\r\nint id, port, irq;\r\nunsigned long bios;\r\nif (!MCA_bus)\r\nreturn 0;\r\nid = 7;\r\nfor (loop = 0; loop < FD_BRDS; loop++) {\r\nslot = 0;\r\nwhile (MCA_NOTFOUND != (slot = mca_find_adapter(fd_mcs_adapters[loop].id, slot))) {\r\nprintk(KERN_INFO "scsi <fd_mcs>: %s at slot %d\n", fd_mcs_adapters[loop].name, slot + 1);\r\npos2 = mca_read_stored_pos(slot, 2);\r\npos3 = mca_read_stored_pos(slot, 3);\r\npos4 = mca_read_stored_pos(slot, 4);\r\nslot++;\r\nif (fd_mcs_adapters[loop].id == REPLY_ID) {\r\nstatic int reply_irq[] = { 10, 11, 14, 15 };\r\nbios = 0;\r\nif (pos2 & 0x2)\r\nport = ports[pos4 & 0x3];\r\nelse\r\ncontinue;\r\nirq = reply_irq[((pos4 >> 2) & 0x1) + 2 * ((pos4 >> 4) & 0x1)];\r\n} else {\r\nbios = addresses[pos2 >> 6];\r\nport = ports[(pos2 >> 4) & 0x03];\r\nirq = interrupts[(pos2 >> 1) & 0x07];\r\n}\r\nif (irq) {\r\nmca_set_adapter_name(slot - 1, fd_mcs_adapters[loop].name);\r\nif (request_irq(irq, fd_mcs_intr, IRQF_SHARED, "fd_mcs", hosts)) {\r\nprintk(KERN_ERR "fd_mcs: interrupt is not available, skipping...\n");\r\ncontinue;\r\n}\r\nif (request_region(port, 0x10, "fd_mcs")) {\r\nprintk(KERN_ERR "fd_mcs: I/O region is already in use, skipping...\n");\r\ncontinue;\r\n}\r\nif (!(shpnt = scsi_register(tpnt, sizeof(struct fd_hostdata)))) {\r\nprintk(KERN_ERR "fd_mcs: scsi_register() failed\n");\r\nrelease_region(port, 0x10);\r\nfree_irq(irq, hosts);\r\ncontinue;\r\n}\r\nstrcpy(adapter_name, fd_mcs_adapters[loop].name);\r\nchip = fd_mcs_adapters[loop].fd_chip;\r\nFIFO_COUNT = user_fifo_count ? user_fifo_count : fd_mcs_adapters[loop].fifo_count;\r\nFIFO_Size = user_fifo_size ? user_fifo_size : fd_mcs_adapters[loop].fifo_size;\r\n#ifdef NOT_USED\r\noutb(0x80, port + IO_Control);\r\nif ((inb(port + Configuration2) & 0x80) == 0x80) {\r\noutb(0x00, port + IO_Control);\r\nif ((inb(port + Configuration2) & 0x80) == 0x00) {\r\nchip = tmc18c30;\r\nFIFO_Size = 0x800;\r\nprintk("FIRST: chip=%s, fifo_size=0x%x\n", (chip == tmc18c30) ? "tmc18c30" : "tmc18c50", FIFO_Size);\r\n}\r\n}\r\nif (inb(port + Configuration2) & 0x02) {\r\nchip = tmc18c30;\r\nFIFO_Size = 0x800;\r\nprintk("SECOND: chip=%s, fifo_size=0x%x\n", (chip == tmc18c30) ? "tmc18c30" : "tmc18c50", FIFO_Size);\r\n}\r\n#endif\r\nshpnt->reverse_ordering = 1;\r\nhosts[found++] = shpnt;\r\nshpnt->this_id = id;\r\nshpnt->irq = irq;\r\nshpnt->io_port = port;\r\nshpnt->n_io_port = 0x10;\r\nbios_base = bios;\r\nadapter_mask = (1 << id);\r\nSCSI_Mode_Cntl_port = port + SCSI_Mode_Cntl;\r\nFIFO_Data_Count_port = port + FIFO_Data_Count;\r\nInterrupt_Cntl_port = port + Interrupt_Cntl;\r\nInterrupt_Status_port = port + Interrupt_Status;\r\nInterrupt_Cond_port = port + Interrupt_Cond;\r\nRead_FIFO_port = port + Read_FIFO;\r\nRead_SCSI_Data_port = port + Read_SCSI_Data;\r\nSCSI_Cntl_port = port + SCSI_Cntl;\r\nSCSI_Data_NoACK_port = port + SCSI_Data_NoACK;\r\nSCSI_Status_port = port + SCSI_Status;\r\nTMC_Cntl_port = port + TMC_Cntl;\r\nTMC_Status_port = port + TMC_Status;\r\nWrite_FIFO_port = port + Write_FIFO;\r\nWrite_SCSI_Data_port = port + Write_SCSI_Data;\r\nBytes_Read = 0;\r\nBytes_Written = 0;\r\nINTR_Processed = 0;\r\nprint_banner(shpnt);\r\noutb(1, SCSI_Cntl_port);\r\ndo_pause(2);\r\noutb(0, SCSI_Cntl_port);\r\ndo_pause(115);\r\noutb(0, SCSI_Mode_Cntl_port);\r\noutb(PARITY_MASK, TMC_Cntl_port);\r\n}\r\n}\r\nif (found == FD_MAX_HOSTS) {\r\nprintk("fd_mcs: detecting reached max=%d host adapters.\n", FD_MAX_HOSTS);\r\nbreak;\r\n}\r\n}\r\nreturn found;\r\n}\r\nstatic const char *fd_mcs_info(struct Scsi_Host *shpnt)\r\n{\r\nreturn adapter_name;\r\n}\r\nstatic int fd_mcs_proc_info(struct Scsi_Host *shpnt, char *buffer, char **start, off_t offset, int length, int inout)\r\n{\r\nint len = 0;\r\nif (inout)\r\nreturn (-ENOSYS);\r\n*start = buffer + offset;\r\nlen += sprintf(buffer + len, "Future Domain MCS-600/700 Driver %s\n", DRIVER_VERSION);\r\nlen += sprintf(buffer + len, "HOST #%d: %s\n", shpnt->host_no, adapter_name);\r\nlen += sprintf(buffer + len, "FIFO Size=0x%x, FIFO Count=%d\n", FIFO_Size, FIFO_COUNT);\r\nlen += sprintf(buffer + len, "DriverCalls=%d, Interrupts=%d, BytesRead=%d, BytesWrite=%d\n\n", TOTAL_INTR, INTR_Processed, Bytes_Read, Bytes_Written);\r\nif ((len -= offset) <= 0)\r\nreturn 0;\r\nif (len > length)\r\nlen = length;\r\nreturn len;\r\n}\r\nstatic int fd_mcs_select(struct Scsi_Host *shpnt, int target)\r\n{\r\nint status;\r\nunsigned long timeout;\r\noutb(0x82, SCSI_Cntl_port);\r\noutb(adapter_mask | (1 << target), SCSI_Data_NoACK_port);\r\noutb(PARITY_MASK, TMC_Cntl_port);\r\ntimeout = 350;\r\ndo {\r\nstatus = inb(SCSI_Status_port);\r\nif (status & 1) {\r\noutb(0x80, SCSI_Cntl_port);\r\nreturn 0;\r\n}\r\nudelay(1000);\r\n} while (--timeout);\r\nfd_mcs_make_bus_idle(shpnt);\r\n#if EVERY_ACCESS\r\nif (!target)\r\nprintk("Selection failed\n");\r\n#endif\r\n#if ERRORS_ONLY\r\nif (!target) {\r\nstatic int flag = 0;\r\nif (!flag)\r\n++flag;\r\nelse\r\nprintk("fd_mcs: Selection failed\n");\r\n}\r\n#endif\r\nreturn 1;\r\n}\r\nstatic void my_done(struct Scsi_Host *shpnt, int error)\r\n{\r\nif (in_command) {\r\nin_command = 0;\r\noutb(0x00, Interrupt_Cntl_port);\r\nfd_mcs_make_bus_idle(shpnt);\r\ncurrent_SC->result = error;\r\ncurrent_SC->scsi_done(current_SC);\r\n} else {\r\npanic("fd_mcs: my_done() called outside of command\n");\r\n}\r\n#if DEBUG_RACE\r\nin_interrupt_flag = 0;\r\n#endif\r\n}\r\nstatic irqreturn_t fd_mcs_intr(int irq, void *dev_id)\r\n{\r\nunsigned long flags;\r\nint status;\r\nint done = 0;\r\nunsigned data_count, tmp_count;\r\nint i = 0;\r\nstruct Scsi_Host *shpnt;\r\nTOTAL_INTR++;\r\nwhile ((shpnt = hosts[i++])) {\r\nif ((inb(TMC_Status_port)) & 1)\r\nbreak;\r\n}\r\nif (!shpnt) {\r\nreturn IRQ_NONE;\r\n}\r\nINTR_Processed++;\r\noutb(0x00, Interrupt_Cntl_port);\r\nif (current_SC->SCp.phase & aborted) {\r\n#if DEBUG_ABORT\r\nprintk("Interrupt after abort, ignoring\n");\r\n#endif\r\n}\r\n#if DEBUG_RACE\r\n++in_interrupt_flag;\r\n#endif\r\nif (current_SC->SCp.phase & in_arbitration) {\r\nstatus = inb(TMC_Status_port);\r\nif (!(status & 0x02)) {\r\n#if EVERY_ACCESS\r\nprintk(" AFAIL ");\r\n#endif\r\nspin_lock_irqsave(shpnt->host_lock, flags);\r\nmy_done(shpnt, DID_BUS_BUSY << 16);\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\ncurrent_SC->SCp.phase = in_selection;\r\noutb(0x40 | FIFO_COUNT, Interrupt_Cntl_port);\r\noutb(0x82, SCSI_Cntl_port);\r\noutb(adapter_mask | (1 << scmd_id(current_SC)), SCSI_Data_NoACK_port);\r\noutb(0x10 | PARITY_MASK, TMC_Cntl_port);\r\n#if DEBUG_RACE\r\nin_interrupt_flag = 0;\r\n#endif\r\nreturn IRQ_HANDLED;\r\n} else if (current_SC->SCp.phase & in_selection) {\r\nstatus = inb(SCSI_Status_port);\r\nif (!(status & 0x01)) {\r\nif (fd_mcs_select(shpnt, scmd_id(current_SC))) {\r\n#if EVERY_ACCESS\r\nprintk(" SFAIL ");\r\n#endif\r\nspin_lock_irqsave(shpnt->host_lock, flags);\r\nmy_done(shpnt, DID_NO_CONNECT << 16);\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n} else {\r\n#if EVERY_ACCESS\r\nprintk(" AltSel ");\r\n#endif\r\noutb(0x10 | PARITY_MASK, TMC_Cntl_port);\r\n}\r\n}\r\ncurrent_SC->SCp.phase = in_other;\r\noutb(0x90 | FIFO_COUNT, Interrupt_Cntl_port);\r\noutb(0x80, SCSI_Cntl_port);\r\n#if DEBUG_RACE\r\nin_interrupt_flag = 0;\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatus = inb(SCSI_Status_port);\r\nif (status & 0x10) {\r\nswitch (status & 0x0e) {\r\ncase 0x08:\r\noutb(current_SC->cmnd[current_SC->SCp.sent_command++], Write_SCSI_Data_port);\r\n#if EVERY_ACCESS\r\nprintk("CMD = %x,", current_SC->cmnd[current_SC->SCp.sent_command - 1]);\r\n#endif\r\nbreak;\r\ncase 0x00:\r\nif (chip != tmc1800 && !current_SC->SCp.have_data_in) {\r\ncurrent_SC->SCp.have_data_in = -1;\r\noutb(0xd0 | PARITY_MASK, TMC_Cntl_port);\r\n}\r\nbreak;\r\ncase 0x04:\r\nif (chip != tmc1800 && !current_SC->SCp.have_data_in) {\r\ncurrent_SC->SCp.have_data_in = 1;\r\noutb(0x90 | PARITY_MASK, TMC_Cntl_port);\r\n}\r\nbreak;\r\ncase 0x0c:\r\ncurrent_SC->SCp.Status = inb(Read_SCSI_Data_port);\r\n#if EVERY_ACCESS\r\nprintk("Status = %x, ", current_SC->SCp.Status);\r\n#endif\r\n#if ERRORS_ONLY\r\nif (current_SC->SCp.Status && current_SC->SCp.Status != 2 && current_SC->SCp.Status != 8) {\r\nprintk("ERROR fd_mcs: target = %d, command = %x, status = %x\n", current_SC->device->id, current_SC->cmnd[0], current_SC->SCp.Status);\r\n}\r\n#endif\r\nbreak;\r\ncase 0x0a:\r\noutb(MESSAGE_REJECT, Write_SCSI_Data_port);\r\nbreak;\r\ncase 0x0e:\r\ncurrent_SC->SCp.Message = inb(Read_SCSI_Data_port);\r\n#if EVERY_ACCESS\r\nprintk("Message = %x, ", current_SC->SCp.Message);\r\n#endif\r\nif (!current_SC->SCp.Message)\r\n++done;\r\n#if DEBUG_MESSAGES || EVERY_ACCESS\r\nif (current_SC->SCp.Message) {\r\nprintk("fd_mcs: message = %x\n", current_SC->SCp.Message);\r\n}\r\n#endif\r\nbreak;\r\n}\r\n}\r\nif (chip == tmc1800 && !current_SC->SCp.have_data_in && (current_SC->SCp.sent_command >= current_SC->cmd_len)) {\r\nswitch (current_SC->cmnd[0]) {\r\ncase CHANGE_DEFINITION:\r\ncase COMPARE:\r\ncase COPY:\r\ncase COPY_VERIFY:\r\ncase LOG_SELECT:\r\ncase MODE_SELECT:\r\ncase MODE_SELECT_10:\r\ncase SEND_DIAGNOSTIC:\r\ncase WRITE_BUFFER:\r\ncase FORMAT_UNIT:\r\ncase REASSIGN_BLOCKS:\r\ncase RESERVE:\r\ncase SEARCH_EQUAL:\r\ncase SEARCH_HIGH:\r\ncase SEARCH_LOW:\r\ncase WRITE_6:\r\ncase WRITE_10:\r\ncase WRITE_VERIFY:\r\ncase 0x3f:\r\ncase 0x41:\r\ncase 0xb1:\r\ncase 0xb0:\r\ncase 0xb2:\r\ncase 0xaa:\r\ncase 0xae:\r\ncase 0x24:\r\ncase 0x38:\r\ncase 0x3d:\r\ncase 0xb6:\r\ncase 0xea:\r\ncurrent_SC->SCp.have_data_in = -1;\r\noutb(0xd0 | PARITY_MASK, TMC_Cntl_port);\r\nbreak;\r\ncase 0x00:\r\ndefault:\r\ncurrent_SC->SCp.have_data_in = 1;\r\noutb(0x90 | PARITY_MASK, TMC_Cntl_port);\r\nbreak;\r\n}\r\n}\r\nif (current_SC->SCp.have_data_in == -1) {\r\nwhile ((data_count = FIFO_Size - inw(FIFO_Data_Count_port)) > 512) {\r\n#if EVERY_ACCESS\r\nprintk("DC=%d, ", data_count);\r\n#endif\r\nif (data_count > current_SC->SCp.this_residual)\r\ndata_count = current_SC->SCp.this_residual;\r\nif (data_count > 0) {\r\n#if EVERY_ACCESS\r\nprintk("%d OUT, ", data_count);\r\n#endif\r\nif (data_count == 1) {\r\nBytes_Written++;\r\noutb(*current_SC->SCp.ptr++, Write_FIFO_port);\r\n--current_SC->SCp.this_residual;\r\n} else {\r\ndata_count >>= 1;\r\ntmp_count = data_count << 1;\r\noutsw(Write_FIFO_port, current_SC->SCp.ptr, data_count);\r\ncurrent_SC->SCp.ptr += tmp_count;\r\nBytes_Written += tmp_count;\r\ncurrent_SC->SCp.this_residual -= tmp_count;\r\n}\r\n}\r\nif (!current_SC->SCp.this_residual) {\r\nif (current_SC->SCp.buffers_residual) {\r\n--current_SC->SCp.buffers_residual;\r\n++current_SC->SCp.buffer;\r\ncurrent_SC->SCp.ptr = sg_virt(current_SC->SCp.buffer);\r\ncurrent_SC->SCp.this_residual = current_SC->SCp.buffer->length;\r\n} else\r\nbreak;\r\n}\r\n}\r\n} else if (current_SC->SCp.have_data_in == 1) {\r\nwhile ((data_count = inw(FIFO_Data_Count_port)) > 0) {\r\n#if EVERY_ACCESS\r\nprintk("DC=%d, ", data_count);\r\n#endif\r\nif (data_count > current_SC->SCp.this_residual)\r\ndata_count = current_SC->SCp.this_residual;\r\nif (data_count) {\r\n#if EVERY_ACCESS\r\nprintk("%d IN, ", data_count);\r\n#endif\r\nif (data_count == 1) {\r\nBytes_Read++;\r\n*current_SC->SCp.ptr++ = inb(Read_FIFO_port);\r\n--current_SC->SCp.this_residual;\r\n} else {\r\ndata_count >>= 1;\r\ntmp_count = data_count << 1;\r\ninsw(Read_FIFO_port, current_SC->SCp.ptr, data_count);\r\ncurrent_SC->SCp.ptr += tmp_count;\r\nBytes_Read += tmp_count;\r\ncurrent_SC->SCp.this_residual -= tmp_count;\r\n}\r\n}\r\nif (!current_SC->SCp.this_residual && current_SC->SCp.buffers_residual) {\r\n--current_SC->SCp.buffers_residual;\r\n++current_SC->SCp.buffer;\r\ncurrent_SC->SCp.ptr = sg_virt(current_SC->SCp.buffer);\r\ncurrent_SC->SCp.this_residual = current_SC->SCp.buffer->length;\r\n}\r\n}\r\n}\r\nif (done) {\r\n#if EVERY_ACCESS\r\nprintk(" ** IN DONE %d ** ", current_SC->SCp.have_data_in);\r\n#endif\r\n#if EVERY_ACCESS\r\nprintk("BEFORE MY_DONE. . .");\r\n#endif\r\nspin_lock_irqsave(shpnt->host_lock, flags);\r\nmy_done(shpnt, (current_SC->SCp.Status & 0xff)\r\n| ((current_SC->SCp.Message & 0xff) << 8) | (DID_OK << 16));\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\n#if EVERY_ACCESS\r\nprintk("RETURNING.\n");\r\n#endif\r\n} else {\r\nif (current_SC->SCp.phase & disconnect) {\r\noutb(0xd0 | FIFO_COUNT, Interrupt_Cntl_port);\r\noutb(0x00, SCSI_Cntl_port);\r\n} else {\r\noutb(0x90 | FIFO_COUNT, Interrupt_Cntl_port);\r\n}\r\n}\r\n#if DEBUG_RACE\r\nin_interrupt_flag = 0;\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fd_mcs_release(struct Scsi_Host *shpnt)\r\n{\r\nint i, this_host, irq_usage;\r\nrelease_region(shpnt->io_port, shpnt->n_io_port);\r\nthis_host = -1;\r\nirq_usage = 0;\r\nfor (i = 0; i < found; i++) {\r\nif (shpnt == hosts[i])\r\nthis_host = i;\r\nif (shpnt->irq == hosts[i]->irq)\r\nirq_usage++;\r\n}\r\nif (1 == irq_usage)\r\nfree_irq(shpnt->irq, hosts);\r\nfound--;\r\nfor (i = this_host; i < found; i++)\r\nhosts[i] = hosts[i + 1];\r\nhosts[found] = NULL;\r\nreturn 0;\r\n}\r\nstatic int fd_mcs_queue_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))\r\n{\r\nstruct Scsi_Host *shpnt = SCpnt->device->host;\r\nif (in_command) {\r\npanic("fd_mcs: fd_mcs_queue() NOT REENTRANT!\n");\r\n}\r\n#if EVERY_ACCESS\r\nprintk("queue: target = %d cmnd = 0x%02x pieces = %d size = %u\n",\r\nSCpnt->target, *(unsigned char *) SCpnt->cmnd,\r\nscsi_sg_count(SCpnt), scsi_bufflen(SCpnt));\r\n#endif\r\nfd_mcs_make_bus_idle(shpnt);\r\nSCpnt->scsi_done = done;\r\ncurrent_SC = SCpnt;\r\nif (scsi_bufflen(current_SC)) {\r\ncurrent_SC->SCp.buffer = scsi_sglist(current_SC);\r\ncurrent_SC->SCp.ptr = sg_virt(current_SC->SCp.buffer);\r\ncurrent_SC->SCp.this_residual = current_SC->SCp.buffer->length;\r\ncurrent_SC->SCp.buffers_residual = scsi_sg_count(current_SC) - 1;\r\n} else {\r\ncurrent_SC->SCp.ptr = NULL;\r\ncurrent_SC->SCp.this_residual = 0;\r\ncurrent_SC->SCp.buffer = NULL;\r\ncurrent_SC->SCp.buffers_residual = 0;\r\n}\r\ncurrent_SC->SCp.Status = 0;\r\ncurrent_SC->SCp.Message = 0;\r\ncurrent_SC->SCp.have_data_in = 0;\r\ncurrent_SC->SCp.sent_command = 0;\r\ncurrent_SC->SCp.phase = in_arbitration;\r\noutb(0x00, Interrupt_Cntl_port);\r\noutb(0x00, SCSI_Cntl_port);\r\noutb(adapter_mask, SCSI_Data_NoACK_port);\r\nin_command = 1;\r\noutb(0x20, Interrupt_Cntl_port);\r\noutb(0x14 | PARITY_MASK, TMC_Cntl_port);\r\nreturn 0;\r\n}\r\nint fd_mcs_abort(Scsi_Cmnd * SCpnt)\r\n{\r\nstruct Scsi_Host *shpnt = SCpnt->device->host;\r\nunsigned long flags;\r\n#if EVERY_ACCESS || ERRORS_ONLY || DEBUG_ABORT\r\nprintk("fd_mcs: abort ");\r\n#endif\r\nspin_lock_irqsave(shpnt->host_lock, flags);\r\nif (!in_command) {\r\n#if EVERY_ACCESS || ERRORS_ONLY\r\nprintk(" (not in command)\n");\r\n#endif\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\nreturn FAILED;\r\n} else\r\nprintk("\n");\r\n#if DEBUG_ABORT\r\nfd_mcs_print_info(SCpnt);\r\n#endif\r\nfd_mcs_make_bus_idle(shpnt);\r\ncurrent_SC->SCp.phase |= aborted;\r\ncurrent_SC->result = DID_ABORT << 16;\r\nmy_done(shpnt, DID_ABORT << 16);\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\nreturn SUCCESS;\r\n}\r\nstatic int fd_mcs_bus_reset(Scsi_Cmnd * SCpnt) {\r\nstruct Scsi_Host *shpnt = SCpnt->device->host;\r\nunsigned long flags;\r\n#if DEBUG_RESET\r\nstatic int called_once = 0;\r\n#endif\r\n#if ERRORS_ONLY\r\nif (SCpnt)\r\nprintk("fd_mcs: SCSI Bus Reset\n");\r\n#endif\r\n#if DEBUG_RESET\r\nif (called_once)\r\nfd_mcs_print_info(current_SC);\r\ncalled_once = 1;\r\n#endif\r\nspin_lock_irqsave(shpnt->host_lock, flags);\r\noutb(1, SCSI_Cntl_port);\r\ndo_pause(2);\r\noutb(0, SCSI_Cntl_port);\r\ndo_pause(115);\r\noutb(0, SCSI_Mode_Cntl_port);\r\noutb(PARITY_MASK, TMC_Cntl_port);\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\nreturn SUCCESS;\r\n}\r\nstatic int fd_mcs_biosparam(struct scsi_device * disk, struct block_device *bdev,\r\nsector_t capacity, int *info_array)\r\n{\r\nunsigned char *p = scsi_bios_ptable(bdev);\r\nint size = capacity;\r\nif (p && p[65] == 0xaa && p[64] == 0x55\r\n&& p[4]) {\r\ninfo_array[0] = p[5] + 1;\r\ninfo_array[1] = p[6] & 0x3f;\r\n} else {\r\nif ((unsigned int) size >= 0x7e0000U)\r\n{\r\ninfo_array[0] = 0xff;\r\ninfo_array[1] = 0x3f;\r\n} else if ((unsigned int) size >= 0x200000U) {\r\ninfo_array[0] = 0x80;\r\ninfo_array[1] = 0x3f;\r\n} else {\r\ninfo_array[0] = 0x40;\r\ninfo_array[1] = 0x20;\r\n}\r\n}\r\ninfo_array[2] = (unsigned int) size / (info_array[0] * info_array[1]);\r\nkfree(p);\r\nreturn 0;\r\n}
