static int ehci_ppc_of_setup(struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nint retval;\r\nretval = ehci_halt(ehci);\r\nif (retval)\r\nreturn retval;\r\nretval = ehci_init(hcd);\r\nif (retval)\r\nreturn retval;\r\nehci->sbrn = 0x20;\r\nreturn ehci_reset(ehci);\r\n}\r\nstatic int __devinit\r\nppc44x_enable_bmt(struct device_node *dn)\r\n{\r\n__iomem u32 *insreg_virt;\r\ninsreg_virt = of_iomap(dn, 1);\r\nif (!insreg_virt)\r\nreturn -EINVAL;\r\nout_be32(insreg_virt + 3, PPC440EPX_EHCI0_INSREG_BMT);\r\niounmap(insreg_virt);\r\nreturn 0;\r\n}\r\nstatic int __devinit ehci_hcd_ppc_of_probe(struct platform_device *op)\r\n{\r\nstruct device_node *dn = op->dev.of_node;\r\nstruct usb_hcd *hcd;\r\nstruct ehci_hcd *ehci = NULL;\r\nstruct resource res;\r\nint irq;\r\nint rv;\r\nstruct device_node *np;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\ndev_dbg(&op->dev, "initializing PPC-OF USB Controller\n");\r\nrv = of_address_to_resource(dn, 0, &res);\r\nif (rv)\r\nreturn rv;\r\nhcd = usb_create_hcd(&ehci_ppc_of_hc_driver, &op->dev, "PPC-OF USB");\r\nif (!hcd)\r\nreturn -ENOMEM;\r\nhcd->rsrc_start = res.start;\r\nhcd->rsrc_len = resource_size(&res);\r\nif (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {\r\nprintk(KERN_ERR "%s: request_mem_region failed\n", __FILE__);\r\nrv = -EBUSY;\r\ngoto err_rmr;\r\n}\r\nirq = irq_of_parse_and_map(dn, 0);\r\nif (irq == NO_IRQ) {\r\nprintk(KERN_ERR "%s: irq_of_parse_and_map failed\n", __FILE__);\r\nrv = -EBUSY;\r\ngoto err_irq;\r\n}\r\nhcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);\r\nif (!hcd->regs) {\r\nprintk(KERN_ERR "%s: ioremap failed\n", __FILE__);\r\nrv = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nehci = hcd_to_ehci(hcd);\r\nnp = of_find_compatible_node(NULL, NULL, "ibm,usb-ohci-440epx");\r\nif (np != NULL) {\r\nif (!of_address_to_resource(np, 0, &res))\r\nehci->ohci_hcctrl_reg = ioremap(res.start +\r\nOHCI_HCCTRL_OFFSET, OHCI_HCCTRL_LEN);\r\nelse\r\npr_debug("%s: no ohci offset in fdt\n", __FILE__);\r\nif (!ehci->ohci_hcctrl_reg) {\r\npr_debug("%s: ioremap for ohci hcctrl failed\n", __FILE__);\r\n} else {\r\nehci->has_amcc_usb23 = 1;\r\n}\r\n}\r\nif (of_get_property(dn, "big-endian", NULL)) {\r\nehci->big_endian_mmio = 1;\r\nehci->big_endian_desc = 1;\r\n}\r\nif (of_get_property(dn, "big-endian-regs", NULL))\r\nehci->big_endian_mmio = 1;\r\nif (of_get_property(dn, "big-endian-desc", NULL))\r\nehci->big_endian_desc = 1;\r\nehci->caps = hcd->regs;\r\nehci->regs = hcd->regs +\r\nHC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));\r\nehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);\r\nif (of_device_is_compatible(dn, "ibm,usb-ehci-440epx")) {\r\nrv = ppc44x_enable_bmt(dn);\r\nehci_dbg(ehci, "Break Memory Transfer (BMT) is %senabled!\n",\r\nrv ? "NOT ": "");\r\n}\r\nrv = usb_add_hcd(hcd, irq, 0);\r\nif (rv)\r\ngoto err_ehci;\r\nreturn 0;\r\nerr_ehci:\r\nif (ehci->has_amcc_usb23)\r\niounmap(ehci->ohci_hcctrl_reg);\r\niounmap(hcd->regs);\r\nerr_ioremap:\r\nirq_dispose_mapping(irq);\r\nerr_irq:\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nerr_rmr:\r\nusb_put_hcd(hcd);\r\nreturn rv;\r\n}\r\nstatic int ehci_hcd_ppc_of_remove(struct platform_device *op)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(&op->dev);\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct device_node *np;\r\nstruct resource res;\r\ndev_set_drvdata(&op->dev, NULL);\r\ndev_dbg(&op->dev, "stopping PPC-OF USB Controller\n");\r\nusb_remove_hcd(hcd);\r\niounmap(hcd->regs);\r\nirq_dispose_mapping(hcd->irq);\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nif (ehci->has_amcc_usb23) {\r\nnp = of_find_compatible_node(NULL, NULL, "ibm,usb-ohci-440epx");\r\nif (np != NULL) {\r\nif (!of_address_to_resource(np, 0, &res))\r\nif (!request_mem_region(res.start,\r\n0x4, hcd_name))\r\nset_ohci_hcfs(ehci, 1);\r\nelse\r\nrelease_mem_region(res.start, 0x4);\r\nelse\r\npr_debug("%s: no ohci offset in fdt\n", __FILE__);\r\nof_node_put(np);\r\n}\r\niounmap(ehci->ohci_hcctrl_reg);\r\n}\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}\r\nstatic void ehci_hcd_ppc_of_shutdown(struct platform_device *op)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(&op->dev);\r\nif (hcd->driver->shutdown)\r\nhcd->driver->shutdown(hcd);\r\n}
