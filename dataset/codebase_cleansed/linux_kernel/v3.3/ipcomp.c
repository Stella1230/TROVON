static void ipcomp4_err(struct sk_buff *skb, u32 info)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\n__be32 spi;\r\nconst struct iphdr *iph = (const struct iphdr *)skb->data;\r\nstruct ip_comp_hdr *ipch = (struct ip_comp_hdr *)(skb->data+(iph->ihl<<2));\r\nstruct xfrm_state *x;\r\nif (icmp_hdr(skb)->type != ICMP_DEST_UNREACH ||\r\nicmp_hdr(skb)->code != ICMP_FRAG_NEEDED)\r\nreturn;\r\nspi = htonl(ntohs(ipch->cpi));\r\nx = xfrm_state_lookup(net, skb->mark, (const xfrm_address_t *)&iph->daddr,\r\nspi, IPPROTO_COMP, AF_INET);\r\nif (!x)\r\nreturn;\r\nNETDEBUG(KERN_DEBUG "pmtu discovery on SA IPCOMP/%08x/%pI4\n",\r\nspi, &iph->daddr);\r\nxfrm_state_put(x);\r\n}\r\nstatic struct xfrm_state *ipcomp_tunnel_create(struct xfrm_state *x)\r\n{\r\nstruct net *net = xs_net(x);\r\nstruct xfrm_state *t;\r\nt = xfrm_state_alloc(net);\r\nif (t == NULL)\r\ngoto out;\r\nt->id.proto = IPPROTO_IPIP;\r\nt->id.spi = x->props.saddr.a4;\r\nt->id.daddr.a4 = x->id.daddr.a4;\r\nmemcpy(&t->sel, &x->sel, sizeof(t->sel));\r\nt->props.family = AF_INET;\r\nt->props.mode = x->props.mode;\r\nt->props.saddr.a4 = x->props.saddr.a4;\r\nt->props.flags = x->props.flags;\r\nmemcpy(&t->mark, &x->mark, sizeof(t->mark));\r\nif (xfrm_init_state(t))\r\ngoto error;\r\natomic_set(&t->tunnel_users, 1);\r\nout:\r\nreturn t;\r\nerror:\r\nt->km.state = XFRM_STATE_DEAD;\r\nxfrm_state_put(t);\r\nt = NULL;\r\ngoto out;\r\n}\r\nstatic int ipcomp_tunnel_attach(struct xfrm_state *x)\r\n{\r\nstruct net *net = xs_net(x);\r\nint err = 0;\r\nstruct xfrm_state *t;\r\nu32 mark = x->mark.v & x->mark.m;\r\nt = xfrm_state_lookup(net, mark, (xfrm_address_t *)&x->id.daddr.a4,\r\nx->props.saddr.a4, IPPROTO_IPIP, AF_INET);\r\nif (!t) {\r\nt = ipcomp_tunnel_create(x);\r\nif (!t) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nxfrm_state_insert(t);\r\nxfrm_state_hold(t);\r\n}\r\nx->tunnel = t;\r\natomic_inc(&t->tunnel_users);\r\nout:\r\nreturn err;\r\n}\r\nstatic int ipcomp4_init_state(struct xfrm_state *x)\r\n{\r\nint err = -EINVAL;\r\nx->props.header_len = 0;\r\nswitch (x->props.mode) {\r\ncase XFRM_MODE_TRANSPORT:\r\nbreak;\r\ncase XFRM_MODE_TUNNEL:\r\nx->props.header_len += sizeof(struct iphdr);\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nerr = ipcomp_init_state(x);\r\nif (err)\r\ngoto out;\r\nif (x->props.mode == XFRM_MODE_TUNNEL) {\r\nerr = ipcomp_tunnel_attach(x);\r\nif (err)\r\ngoto out;\r\n}\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int __init ipcomp4_init(void)\r\n{\r\nif (xfrm_register_type(&ipcomp_type, AF_INET) < 0) {\r\nprintk(KERN_INFO "ipcomp init: can't add xfrm type\n");\r\nreturn -EAGAIN;\r\n}\r\nif (inet_add_protocol(&ipcomp4_protocol, IPPROTO_COMP) < 0) {\r\nprintk(KERN_INFO "ipcomp init: can't add protocol\n");\r\nxfrm_unregister_type(&ipcomp_type, AF_INET);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit ipcomp4_fini(void)\r\n{\r\nif (inet_del_protocol(&ipcomp4_protocol, IPPROTO_COMP) < 0)\r\nprintk(KERN_INFO "ip ipcomp close: can't remove protocol\n");\r\nif (xfrm_unregister_type(&ipcomp_type, AF_INET) < 0)\r\nprintk(KERN_INFO "ip ipcomp close: can't remove xfrm type\n");\r\n}
