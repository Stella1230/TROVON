static void\r\nmwifiex_init_cmd_node(struct mwifiex_private *priv,\r\nstruct cmd_ctrl_node *cmd_node,\r\nu32 cmd_oid, void *data_buf)\r\n{\r\ncmd_node->priv = priv;\r\ncmd_node->cmd_oid = cmd_oid;\r\nif (priv->adapter->cmd_wait_q_required) {\r\ncmd_node->wait_q_enabled = priv->adapter->cmd_wait_q_required;\r\npriv->adapter->cmd_wait_q_required = false;\r\ncmd_node->cmd_wait_q_woken = false;\r\ncmd_node->condition = &cmd_node->cmd_wait_q_woken;\r\n}\r\ncmd_node->data_buf = data_buf;\r\ncmd_node->cmd_skb = cmd_node->skb;\r\n}\r\nstatic struct cmd_ctrl_node *\r\nmwifiex_get_cmd_node(struct mwifiex_adapter *adapter)\r\n{\r\nstruct cmd_ctrl_node *cmd_node;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->cmd_free_q_lock, flags);\r\nif (list_empty(&adapter->cmd_free_q)) {\r\ndev_err(adapter->dev, "GET_CMD_NODE: cmd node not available\n");\r\nspin_unlock_irqrestore(&adapter->cmd_free_q_lock, flags);\r\nreturn NULL;\r\n}\r\ncmd_node = list_first_entry(&adapter->cmd_free_q,\r\nstruct cmd_ctrl_node, list);\r\nlist_del(&cmd_node->list);\r\nspin_unlock_irqrestore(&adapter->cmd_free_q_lock, flags);\r\nreturn cmd_node;\r\n}\r\nstatic void\r\nmwifiex_clean_cmd_node(struct mwifiex_adapter *adapter,\r\nstruct cmd_ctrl_node *cmd_node)\r\n{\r\ncmd_node->cmd_oid = 0;\r\ncmd_node->cmd_flag = 0;\r\ncmd_node->data_buf = NULL;\r\ncmd_node->wait_q_enabled = false;\r\nif (cmd_node->cmd_skb)\r\nskb_trim(cmd_node->cmd_skb, 0);\r\nif (cmd_node->resp_skb) {\r\nadapter->if_ops.cmdrsp_complete(adapter, cmd_node->resp_skb);\r\ncmd_node->resp_skb = NULL;\r\n}\r\n}\r\nstatic int mwifiex_cmd_host_cmd(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nstruct mwifiex_ds_misc_cmd *pcmd_ptr)\r\n{\r\nmemcpy(cmd, pcmd_ptr->cmd, pcmd_ptr->len);\r\ndev_dbg(priv->adapter->dev, "cmd: host cmd size = %d\n", pcmd_ptr->len);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_dnld_cmd_to_fw(struct mwifiex_private *priv,\r\nstruct cmd_ctrl_node *cmd_node)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nint ret;\r\nstruct host_cmd_ds_command *host_cmd;\r\nuint16_t cmd_code;\r\nuint16_t cmd_size;\r\nstruct timeval tstamp;\r\nunsigned long flags;\r\nif (!adapter || !cmd_node)\r\nreturn -1;\r\nhost_cmd = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\r\nif (host_cmd == NULL || host_cmd->size == 0) {\r\ndev_err(adapter->dev, "DNLD_CMD: host_cmd is null"\r\n" or cmd size is 0, not sending\n");\r\nif (cmd_node->wait_q_enabled)\r\nadapter->cmd_wait_q.status = -1;\r\nmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\r\nreturn -1;\r\n}\r\nadapter->seq_num++;\r\nhost_cmd->seq_num = cpu_to_le16(HostCmd_SET_SEQ_NO_BSS_INFO\r\n(adapter->seq_num, cmd_node->priv->bss_num,\r\ncmd_node->priv->bss_type));\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->curr_cmd = cmd_node;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\ncmd_code = le16_to_cpu(host_cmd->command);\r\ncmd_size = le16_to_cpu(host_cmd->size);\r\nskb_trim(cmd_node->cmd_skb, cmd_size);\r\ndo_gettimeofday(&tstamp);\r\ndev_dbg(adapter->dev, "cmd: DNLD_CMD: (%lu.%lu): %#x, act %#x, len %d,"\r\n" seqno %#x\n",\r\ntstamp.tv_sec, tstamp.tv_usec, cmd_code,\r\nle16_to_cpu(*(__le16 *) ((u8 *) host_cmd + S_DS_GEN)), cmd_size,\r\nle16_to_cpu(host_cmd->seq_num));\r\nskb_push(cmd_node->cmd_skb, INTF_HEADER_LEN);\r\nret = adapter->if_ops.host_to_card(adapter, MWIFIEX_TYPE_CMD,\r\ncmd_node->cmd_skb, NULL);\r\nskb_pull(cmd_node->cmd_skb, INTF_HEADER_LEN);\r\nif (ret == -1) {\r\ndev_err(adapter->dev, "DNLD_CMD: host to card failed\n");\r\nif (cmd_node->wait_q_enabled)\r\nadapter->cmd_wait_q.status = -1;\r\nmwifiex_insert_cmd_to_free_q(adapter, adapter->curr_cmd);\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->curr_cmd = NULL;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->dbg.num_cmd_host_to_card_failure++;\r\nreturn -1;\r\n}\r\nadapter->dbg.last_cmd_index =\r\n(adapter->dbg.last_cmd_index + 1) % DBG_CMD_NUM;\r\nadapter->dbg.last_cmd_id[adapter->dbg.last_cmd_index] = cmd_code;\r\nadapter->dbg.last_cmd_act[adapter->dbg.last_cmd_index] =\r\nle16_to_cpu(*(__le16 *) ((u8 *) host_cmd + S_DS_GEN));\r\ncmd_code &= HostCmd_CMD_ID_MASK;\r\nmod_timer(&adapter->cmd_timer,\r\njiffies + (MWIFIEX_TIMER_10S * HZ) / 1000);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_dnld_sleep_confirm_cmd(struct mwifiex_adapter *adapter)\r\n{\r\nint ret;\r\nstruct mwifiex_private *priv;\r\nstruct mwifiex_opt_sleep_confirm *sleep_cfm_buf =\r\n(struct mwifiex_opt_sleep_confirm *)\r\nadapter->sleep_cfm->data;\r\npriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\r\nsleep_cfm_buf->seq_num =\r\ncpu_to_le16((HostCmd_SET_SEQ_NO_BSS_INFO\r\n(adapter->seq_num, priv->bss_num,\r\npriv->bss_type)));\r\nadapter->seq_num++;\r\nskb_push(adapter->sleep_cfm, INTF_HEADER_LEN);\r\nret = adapter->if_ops.host_to_card(adapter, MWIFIEX_TYPE_CMD,\r\nadapter->sleep_cfm, NULL);\r\nskb_pull(adapter->sleep_cfm, INTF_HEADER_LEN);\r\nif (ret == -1) {\r\ndev_err(adapter->dev, "SLEEP_CFM: failed\n");\r\nadapter->dbg.num_cmd_sleep_cfm_host_to_card_failure++;\r\nreturn -1;\r\n}\r\nif (GET_BSS_ROLE(mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY))\r\n== MWIFIEX_BSS_ROLE_STA) {\r\nif (!sleep_cfm_buf->resp_ctrl)\r\nadapter->ps_state = PS_STATE_SLEEP;\r\nelse\r\nadapter->ps_state = PS_STATE_SLEEP_CFM;\r\nif (!sleep_cfm_buf->resp_ctrl\r\n&& (adapter->is_hs_configured\r\n&& !adapter->sleep_period.period)) {\r\nadapter->pm_wakeup_card_req = true;\r\nmwifiex_hs_activated_event(mwifiex_get_priv(adapter,\r\nMWIFIEX_BSS_ROLE_STA), true);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint mwifiex_alloc_cmd_buffer(struct mwifiex_adapter *adapter)\r\n{\r\nstruct cmd_ctrl_node *cmd_array;\r\nu32 buf_size;\r\nu32 i;\r\nbuf_size = sizeof(struct cmd_ctrl_node) * MWIFIEX_NUM_OF_CMD_BUFFER;\r\ncmd_array = kzalloc(buf_size, GFP_KERNEL);\r\nif (!cmd_array) {\r\ndev_err(adapter->dev, "%s: failed to alloc cmd_array\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nadapter->cmd_pool = cmd_array;\r\nmemset(adapter->cmd_pool, 0, buf_size);\r\nfor (i = 0; i < MWIFIEX_NUM_OF_CMD_BUFFER; i++) {\r\ncmd_array[i].skb = dev_alloc_skb(MWIFIEX_SIZE_OF_CMD_BUFFER);\r\nif (!cmd_array[i].skb) {\r\ndev_err(adapter->dev, "ALLOC_CMD_BUF: out of memory\n");\r\nreturn -1;\r\n}\r\n}\r\nfor (i = 0; i < MWIFIEX_NUM_OF_CMD_BUFFER; i++)\r\nmwifiex_insert_cmd_to_free_q(adapter, &cmd_array[i]);\r\nreturn 0;\r\n}\r\nint mwifiex_free_cmd_buffer(struct mwifiex_adapter *adapter)\r\n{\r\nstruct cmd_ctrl_node *cmd_array;\r\nu32 i;\r\nif (!adapter->cmd_pool) {\r\ndev_dbg(adapter->dev, "info: FREE_CMD_BUF: cmd_pool is null\n");\r\nreturn 0;\r\n}\r\ncmd_array = adapter->cmd_pool;\r\nfor (i = 0; i < MWIFIEX_NUM_OF_CMD_BUFFER; i++) {\r\nif (cmd_array[i].skb) {\r\ndev_dbg(adapter->dev, "cmd: free cmd buffer %d\n", i);\r\ndev_kfree_skb_any(cmd_array[i].skb);\r\n}\r\nif (!cmd_array[i].resp_skb)\r\ncontinue;\r\ndev_kfree_skb_any(cmd_array[i].resp_skb);\r\n}\r\nif (adapter->cmd_pool) {\r\ndev_dbg(adapter->dev, "cmd: free cmd pool\n");\r\nkfree(adapter->cmd_pool);\r\nadapter->cmd_pool = NULL;\r\n}\r\nreturn 0;\r\n}\r\nint mwifiex_process_event(struct mwifiex_adapter *adapter)\r\n{\r\nint ret;\r\nstruct mwifiex_private *priv =\r\nmwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\r\nstruct sk_buff *skb = adapter->event_skb;\r\nu32 eventcause = adapter->event_cause;\r\nstruct timeval tstamp;\r\nstruct mwifiex_rxinfo *rx_info;\r\nadapter->dbg.last_event_index =\r\n(adapter->dbg.last_event_index + 1) % DBG_CMD_NUM;\r\nadapter->dbg.last_event[adapter->dbg.last_event_index] =\r\n(u16) eventcause;\r\npriv = mwifiex_get_priv_by_id(adapter, EVENT_GET_BSS_NUM(eventcause),\r\nEVENT_GET_BSS_TYPE(eventcause));\r\nif (!priv)\r\npriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\r\neventcause &= EVENT_ID_MASK;\r\nadapter->event_cause = eventcause;\r\nif (skb) {\r\nrx_info = MWIFIEX_SKB_RXCB(skb);\r\nrx_info->bss_index = priv->bss_index;\r\n}\r\nif (eventcause != EVENT_PS_SLEEP && eventcause != EVENT_PS_AWAKE) {\r\ndo_gettimeofday(&tstamp);\r\ndev_dbg(adapter->dev, "event: %lu.%lu: cause: %#x\n",\r\ntstamp.tv_sec, tstamp.tv_usec, eventcause);\r\n}\r\nret = mwifiex_process_sta_event(priv);\r\nadapter->event_cause = 0;\r\nadapter->event_skb = NULL;\r\nadapter->if_ops.event_complete(adapter, skb);\r\nreturn ret;\r\n}\r\nint mwifiex_send_cmd_sync(struct mwifiex_private *priv, uint16_t cmd_no,\r\nu16 cmd_action, u32 cmd_oid, void *data_buf)\r\n{\r\nint ret = 0;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nadapter->cmd_wait_q_required = true;\r\nret = mwifiex_send_cmd_async(priv, cmd_no, cmd_action, cmd_oid,\r\ndata_buf);\r\nif (!ret)\r\nret = mwifiex_wait_queue_complete(adapter);\r\nreturn ret;\r\n}\r\nint mwifiex_send_cmd_async(struct mwifiex_private *priv, uint16_t cmd_no,\r\nu16 cmd_action, u32 cmd_oid, void *data_buf)\r\n{\r\nint ret;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct cmd_ctrl_node *cmd_node;\r\nstruct host_cmd_ds_command *cmd_ptr;\r\nif (!adapter) {\r\npr_err("PREP_CMD: adapter is NULL\n");\r\nreturn -1;\r\n}\r\nif (adapter->is_suspended) {\r\ndev_err(adapter->dev, "PREP_CMD: device in suspended state\n");\r\nreturn -1;\r\n}\r\nif (adapter->surprise_removed) {\r\ndev_err(adapter->dev, "PREP_CMD: card is removed\n");\r\nreturn -1;\r\n}\r\nif (adapter->hw_status == MWIFIEX_HW_STATUS_RESET) {\r\nif (cmd_no != HostCmd_CMD_FUNC_INIT) {\r\ndev_err(adapter->dev, "PREP_CMD: FW in reset state\n");\r\nreturn -1;\r\n}\r\n}\r\ncmd_node = mwifiex_get_cmd_node(adapter);\r\nif (!cmd_node) {\r\ndev_err(adapter->dev, "PREP_CMD: no free cmd node\n");\r\nreturn -1;\r\n}\r\nmwifiex_init_cmd_node(priv, cmd_node, cmd_oid, data_buf);\r\nif (!cmd_node->cmd_skb) {\r\ndev_err(adapter->dev, "PREP_CMD: no free cmd buf\n");\r\nreturn -1;\r\n}\r\nmemset(skb_put(cmd_node->cmd_skb, sizeof(struct host_cmd_ds_command)),\r\n0, sizeof(struct host_cmd_ds_command));\r\ncmd_ptr = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\r\ncmd_ptr->command = cpu_to_le16(cmd_no);\r\ncmd_ptr->result = 0;\r\nif (cmd_no) {\r\nret = mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\r\ncmd_oid, data_buf, cmd_ptr);\r\n} else {\r\nret = mwifiex_cmd_host_cmd(priv, cmd_ptr, data_buf);\r\ncmd_node->cmd_flag |= CMD_F_HOSTCMD;\r\n}\r\nif (ret) {\r\ndev_err(adapter->dev, "PREP_CMD: cmd %#x preparation failed\n",\r\ncmd_no);\r\nmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\r\nreturn -1;\r\n}\r\nif (cmd_no == HostCmd_CMD_802_11_SCAN) {\r\nmwifiex_queue_scan_cmd(priv, cmd_node);\r\n} else {\r\nadapter->cmd_queued = cmd_node;\r\nmwifiex_insert_cmd_to_pending_q(adapter, cmd_node, true);\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nmwifiex_insert_cmd_to_free_q(struct mwifiex_adapter *adapter,\r\nstruct cmd_ctrl_node *cmd_node)\r\n{\r\nunsigned long flags;\r\nif (!cmd_node)\r\nreturn;\r\nif (cmd_node->wait_q_enabled)\r\nmwifiex_complete_cmd(adapter, cmd_node);\r\nmwifiex_clean_cmd_node(adapter, cmd_node);\r\nspin_lock_irqsave(&adapter->cmd_free_q_lock, flags);\r\nlist_add_tail(&cmd_node->list, &adapter->cmd_free_q);\r\nspin_unlock_irqrestore(&adapter->cmd_free_q_lock, flags);\r\n}\r\nvoid\r\nmwifiex_insert_cmd_to_pending_q(struct mwifiex_adapter *adapter,\r\nstruct cmd_ctrl_node *cmd_node, u32 add_tail)\r\n{\r\nstruct host_cmd_ds_command *host_cmd = NULL;\r\nu16 command;\r\nunsigned long flags;\r\nhost_cmd = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\r\nif (!host_cmd) {\r\ndev_err(adapter->dev, "QUEUE_CMD: host_cmd is NULL\n");\r\nreturn;\r\n}\r\ncommand = le16_to_cpu(host_cmd->command);\r\nif (command == HostCmd_CMD_802_11_PS_MODE_ENH) {\r\nstruct host_cmd_ds_802_11_ps_mode_enh *pm =\r\n&host_cmd->params.psmode_enh;\r\nif ((le16_to_cpu(pm->action) == DIS_PS)\r\n|| (le16_to_cpu(pm->action) == DIS_AUTO_PS)) {\r\nif (adapter->ps_state != PS_STATE_AWAKE)\r\nadd_tail = false;\r\n}\r\n}\r\nspin_lock_irqsave(&adapter->cmd_pending_q_lock, flags);\r\nif (add_tail)\r\nlist_add_tail(&cmd_node->list, &adapter->cmd_pending_q);\r\nelse\r\nlist_add(&cmd_node->list, &adapter->cmd_pending_q);\r\nspin_unlock_irqrestore(&adapter->cmd_pending_q_lock, flags);\r\ndev_dbg(adapter->dev, "cmd: QUEUE_CMD: cmd=%#x is queued\n", command);\r\n}\r\nint mwifiex_exec_next_cmd(struct mwifiex_adapter *adapter)\r\n{\r\nstruct mwifiex_private *priv;\r\nstruct cmd_ctrl_node *cmd_node;\r\nint ret = 0;\r\nstruct host_cmd_ds_command *host_cmd;\r\nunsigned long cmd_flags;\r\nunsigned long cmd_pending_q_flags;\r\nif (adapter->curr_cmd) {\r\ndev_err(adapter->dev, "EXEC_NEXT_CMD: cmd in processing\n");\r\nreturn -1;\r\n}\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nspin_lock_irqsave(&adapter->cmd_pending_q_lock, cmd_pending_q_flags);\r\nif (list_empty(&adapter->cmd_pending_q)) {\r\nspin_unlock_irqrestore(&adapter->cmd_pending_q_lock,\r\ncmd_pending_q_flags);\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nreturn 0;\r\n}\r\ncmd_node = list_first_entry(&adapter->cmd_pending_q,\r\nstruct cmd_ctrl_node, list);\r\nspin_unlock_irqrestore(&adapter->cmd_pending_q_lock,\r\ncmd_pending_q_flags);\r\nhost_cmd = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\r\npriv = cmd_node->priv;\r\nif (adapter->ps_state != PS_STATE_AWAKE) {\r\ndev_err(adapter->dev, "%s: cannot send cmd in sleep state,"\r\n" this should not happen\n", __func__);\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&adapter->cmd_pending_q_lock, cmd_pending_q_flags);\r\nlist_del(&cmd_node->list);\r\nspin_unlock_irqrestore(&adapter->cmd_pending_q_lock,\r\ncmd_pending_q_flags);\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nret = mwifiex_dnld_cmd_to_fw(priv, cmd_node);\r\npriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\r\nif (priv && (host_cmd->command !=\r\ncpu_to_le16(HostCmd_CMD_802_11_HS_CFG_ENH))) {\r\nif (adapter->hs_activated) {\r\nadapter->is_hs_configured = false;\r\nmwifiex_hs_activated_event(priv, false);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint mwifiex_process_cmdresp(struct mwifiex_adapter *adapter)\r\n{\r\nstruct host_cmd_ds_command *resp;\r\nstruct mwifiex_private *priv =\r\nmwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\r\nint ret = 0;\r\nuint16_t orig_cmdresp_no;\r\nuint16_t cmdresp_no;\r\nuint16_t cmdresp_result;\r\nstruct timeval tstamp;\r\nunsigned long flags;\r\ndel_timer(&adapter->cmd_timer);\r\nif (!adapter->curr_cmd || !adapter->curr_cmd->resp_skb) {\r\nresp = (struct host_cmd_ds_command *) adapter->upld_buf;\r\ndev_err(adapter->dev, "CMD_RESP: NULL curr_cmd, %#x\n",\r\nle16_to_cpu(resp->command));\r\nreturn -1;\r\n}\r\nadapter->num_cmd_timeout = 0;\r\nresp = (struct host_cmd_ds_command *) adapter->curr_cmd->resp_skb->data;\r\nif (adapter->curr_cmd->cmd_flag & CMD_F_CANCELED) {\r\ndev_err(adapter->dev, "CMD_RESP: %#x been canceled\n",\r\nle16_to_cpu(resp->command));\r\nmwifiex_insert_cmd_to_free_q(adapter, adapter->curr_cmd);\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->curr_cmd = NULL;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\nreturn -1;\r\n}\r\nif (adapter->curr_cmd->cmd_flag & CMD_F_HOSTCMD) {\r\nstruct mwifiex_ds_misc_cmd *hostcmd;\r\nuint16_t size = le16_to_cpu(resp->size);\r\ndev_dbg(adapter->dev, "info: host cmd resp size = %d\n", size);\r\nsize = min_t(u16, size, MWIFIEX_SIZE_OF_CMD_BUFFER);\r\nif (adapter->curr_cmd->data_buf) {\r\nhostcmd = adapter->curr_cmd->data_buf;\r\nhostcmd->len = size;\r\nmemcpy(hostcmd->cmd, resp, size);\r\n}\r\n}\r\norig_cmdresp_no = le16_to_cpu(resp->command);\r\npriv = mwifiex_get_priv_by_id(adapter,\r\nHostCmd_GET_BSS_NO(le16_to_cpu(resp->seq_num)),\r\nHostCmd_GET_BSS_TYPE(le16_to_cpu(resp->seq_num)));\r\nif (!priv)\r\npriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\r\nresp->command = cpu_to_le16(orig_cmdresp_no & HostCmd_CMD_ID_MASK);\r\ncmdresp_no = le16_to_cpu(resp->command);\r\ncmdresp_result = le16_to_cpu(resp->result);\r\nadapter->dbg.last_cmd_resp_index =\r\n(adapter->dbg.last_cmd_resp_index + 1) % DBG_CMD_NUM;\r\nadapter->dbg.last_cmd_resp_id[adapter->dbg.last_cmd_resp_index] =\r\norig_cmdresp_no;\r\ndo_gettimeofday(&tstamp);\r\ndev_dbg(adapter->dev, "cmd: CMD_RESP: (%lu.%lu): 0x%x, result %d,"\r\n" len %d, seqno 0x%x\n",\r\ntstamp.tv_sec, tstamp.tv_usec, orig_cmdresp_no, cmdresp_result,\r\nle16_to_cpu(resp->size), le16_to_cpu(resp->seq_num));\r\nif (!(orig_cmdresp_no & HostCmd_RET_BIT)) {\r\ndev_err(adapter->dev, "CMD_RESP: invalid cmd resp\n");\r\nif (adapter->curr_cmd->wait_q_enabled)\r\nadapter->cmd_wait_q.status = -1;\r\nmwifiex_insert_cmd_to_free_q(adapter, adapter->curr_cmd);\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->curr_cmd = NULL;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\nreturn -1;\r\n}\r\nif (adapter->curr_cmd->cmd_flag & CMD_F_HOSTCMD) {\r\nadapter->curr_cmd->cmd_flag &= ~CMD_F_HOSTCMD;\r\nif ((cmdresp_result == HostCmd_RESULT_OK)\r\n&& (cmdresp_no == HostCmd_CMD_802_11_HS_CFG_ENH))\r\nret = mwifiex_ret_802_11_hs_cfg(priv, resp);\r\n} else {\r\nret = mwifiex_process_sta_cmdresp(priv, cmdresp_no, resp);\r\n}\r\nif (adapter->hw_status == MWIFIEX_HW_STATUS_INITIALIZING) {\r\nif (ret == -1) {\r\ndev_err(adapter->dev, "%s: cmd %#x failed during "\r\n"initialization\n", __func__, cmdresp_no);\r\nmwifiex_init_fw_complete(adapter);\r\nreturn -1;\r\n} else if (adapter->last_init_cmd == cmdresp_no)\r\nadapter->hw_status = MWIFIEX_HW_STATUS_INIT_DONE;\r\n}\r\nif (adapter->curr_cmd) {\r\nif (adapter->curr_cmd->wait_q_enabled && (!ret))\r\nadapter->cmd_wait_q.status = 0;\r\nelse if (adapter->curr_cmd->wait_q_enabled && (ret == -1))\r\nadapter->cmd_wait_q.status = -1;\r\nmwifiex_insert_cmd_to_free_q(adapter, adapter->curr_cmd);\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->curr_cmd = NULL;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nmwifiex_cmd_timeout_func(unsigned long function_context)\r\n{\r\nstruct mwifiex_adapter *adapter =\r\n(struct mwifiex_adapter *) function_context;\r\nstruct cmd_ctrl_node *cmd_node;\r\nstruct timeval tstamp;\r\nadapter->num_cmd_timeout++;\r\nadapter->dbg.num_cmd_timeout++;\r\nif (!adapter->curr_cmd) {\r\ndev_dbg(adapter->dev, "cmd: empty curr_cmd\n");\r\nreturn;\r\n}\r\ncmd_node = adapter->curr_cmd;\r\nif (cmd_node->wait_q_enabled)\r\nadapter->cmd_wait_q.status = -ETIMEDOUT;\r\nif (cmd_node) {\r\nadapter->dbg.timeout_cmd_id =\r\nadapter->dbg.last_cmd_id[adapter->dbg.last_cmd_index];\r\nadapter->dbg.timeout_cmd_act =\r\nadapter->dbg.last_cmd_act[adapter->dbg.last_cmd_index];\r\ndo_gettimeofday(&tstamp);\r\ndev_err(adapter->dev, "%s: Timeout cmd id (%lu.%lu) = %#x,"\r\n" act = %#x\n", __func__,\r\ntstamp.tv_sec, tstamp.tv_usec,\r\nadapter->dbg.timeout_cmd_id,\r\nadapter->dbg.timeout_cmd_act);\r\ndev_err(adapter->dev, "num_data_h2c_failure = %d\n",\r\nadapter->dbg.num_tx_host_to_card_failure);\r\ndev_err(adapter->dev, "num_cmd_h2c_failure = %d\n",\r\nadapter->dbg.num_cmd_host_to_card_failure);\r\ndev_err(adapter->dev, "num_cmd_timeout = %d\n",\r\nadapter->dbg.num_cmd_timeout);\r\ndev_err(adapter->dev, "num_tx_timeout = %d\n",\r\nadapter->dbg.num_tx_timeout);\r\ndev_err(adapter->dev, "last_cmd_index = %d\n",\r\nadapter->dbg.last_cmd_index);\r\nprint_hex_dump_bytes("last_cmd_id: ", DUMP_PREFIX_OFFSET,\r\nadapter->dbg.last_cmd_id, DBG_CMD_NUM);\r\nprint_hex_dump_bytes("last_cmd_act: ", DUMP_PREFIX_OFFSET,\r\nadapter->dbg.last_cmd_act, DBG_CMD_NUM);\r\ndev_err(adapter->dev, "last_cmd_resp_index = %d\n",\r\nadapter->dbg.last_cmd_resp_index);\r\nprint_hex_dump_bytes("last_cmd_resp_id: ", DUMP_PREFIX_OFFSET,\r\nadapter->dbg.last_cmd_resp_id, DBG_CMD_NUM);\r\ndev_err(adapter->dev, "last_event_index = %d\n",\r\nadapter->dbg.last_event_index);\r\nprint_hex_dump_bytes("last_event: ", DUMP_PREFIX_OFFSET,\r\nadapter->dbg.last_event, DBG_CMD_NUM);\r\ndev_err(adapter->dev, "data_sent=%d cmd_sent=%d\n",\r\nadapter->data_sent, adapter->cmd_sent);\r\ndev_err(adapter->dev, "ps_mode=%d ps_state=%d\n",\r\nadapter->ps_mode, adapter->ps_state);\r\n}\r\nif (adapter->hw_status == MWIFIEX_HW_STATUS_INITIALIZING)\r\nmwifiex_init_fw_complete(adapter);\r\n}\r\nvoid\r\nmwifiex_cancel_all_pending_cmd(struct mwifiex_adapter *adapter)\r\n{\r\nstruct cmd_ctrl_node *cmd_node = NULL, *tmp_node;\r\nunsigned long flags;\r\nif ((adapter->curr_cmd) && (adapter->curr_cmd->wait_q_enabled)) {\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->curr_cmd->wait_q_enabled = false;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->cmd_wait_q.status = -1;\r\nmwifiex_complete_cmd(adapter, adapter->curr_cmd);\r\n}\r\nspin_lock_irqsave(&adapter->cmd_pending_q_lock, flags);\r\nlist_for_each_entry_safe(cmd_node, tmp_node,\r\n&adapter->cmd_pending_q, list) {\r\nlist_del(&cmd_node->list);\r\nspin_unlock_irqrestore(&adapter->cmd_pending_q_lock, flags);\r\nif (cmd_node->wait_q_enabled) {\r\nadapter->cmd_wait_q.status = -1;\r\nmwifiex_complete_cmd(adapter, cmd_node);\r\ncmd_node->wait_q_enabled = false;\r\n}\r\nmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\r\nspin_lock_irqsave(&adapter->cmd_pending_q_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&adapter->cmd_pending_q_lock, flags);\r\nspin_lock_irqsave(&adapter->scan_pending_q_lock, flags);\r\nlist_for_each_entry_safe(cmd_node, tmp_node,\r\n&adapter->scan_pending_q, list) {\r\nlist_del(&cmd_node->list);\r\nspin_unlock_irqrestore(&adapter->scan_pending_q_lock, flags);\r\ncmd_node->wait_q_enabled = false;\r\nmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\r\nspin_lock_irqsave(&adapter->scan_pending_q_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&adapter->scan_pending_q_lock, flags);\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->scan_processing = false;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\n}\r\nvoid\r\nmwifiex_cancel_pending_ioctl(struct mwifiex_adapter *adapter)\r\n{\r\nstruct cmd_ctrl_node *cmd_node = NULL, *tmp_node = NULL;\r\nunsigned long cmd_flags;\r\nunsigned long scan_pending_q_flags;\r\nuint16_t cancel_scan_cmd = false;\r\nif ((adapter->curr_cmd) &&\r\n(adapter->curr_cmd->wait_q_enabled)) {\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, cmd_flags);\r\ncmd_node = adapter->curr_cmd;\r\ncmd_node->wait_q_enabled = false;\r\ncmd_node->cmd_flag |= CMD_F_CANCELED;\r\nmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\r\nmwifiex_complete_cmd(adapter, adapter->curr_cmd);\r\nadapter->curr_cmd = NULL;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, cmd_flags);\r\n}\r\nspin_lock_irqsave(&adapter->scan_pending_q_lock,\r\nscan_pending_q_flags);\r\nlist_for_each_entry_safe(cmd_node, tmp_node,\r\n&adapter->scan_pending_q, list) {\r\nlist_del(&cmd_node->list);\r\nspin_unlock_irqrestore(&adapter->scan_pending_q_lock,\r\nscan_pending_q_flags);\r\ncmd_node->wait_q_enabled = false;\r\nmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\r\nspin_lock_irqsave(&adapter->scan_pending_q_lock,\r\nscan_pending_q_flags);\r\ncancel_scan_cmd = true;\r\n}\r\nspin_unlock_irqrestore(&adapter->scan_pending_q_lock,\r\nscan_pending_q_flags);\r\nif (cancel_scan_cmd) {\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nadapter->scan_processing = false;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, cmd_flags);\r\n}\r\nadapter->cmd_wait_q.status = -1;\r\n}\r\nvoid\r\nmwifiex_check_ps_cond(struct mwifiex_adapter *adapter)\r\n{\r\nif (!adapter->cmd_sent &&\r\n!adapter->curr_cmd && !IS_CARD_RX_RCVD(adapter))\r\nmwifiex_dnld_sleep_confirm_cmd(adapter);\r\nelse\r\ndev_dbg(adapter->dev,\r\n"cmd: Delay Sleep Confirm (%s%s%s)\n",\r\n(adapter->cmd_sent) ? "D" : "",\r\n(adapter->curr_cmd) ? "C" : "",\r\n(IS_CARD_RX_RCVD(adapter)) ? "R" : "");\r\n}\r\nvoid\r\nmwifiex_hs_activated_event(struct mwifiex_private *priv, u8 activated)\r\n{\r\nif (activated) {\r\nif (priv->adapter->is_hs_configured) {\r\npriv->adapter->hs_activated = true;\r\ndev_dbg(priv->adapter->dev, "event: hs_activated\n");\r\npriv->adapter->hs_activate_wait_q_woken = true;\r\nwake_up_interruptible(\r\n&priv->adapter->hs_activate_wait_q);\r\n} else {\r\ndev_dbg(priv->adapter->dev, "event: HS not configured\n");\r\n}\r\n} else {\r\ndev_dbg(priv->adapter->dev, "event: hs_deactivated\n");\r\npriv->adapter->hs_activated = false;\r\n}\r\n}\r\nint mwifiex_ret_802_11_hs_cfg(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct host_cmd_ds_802_11_hs_cfg_enh *phs_cfg =\r\n&resp->params.opt_hs_cfg;\r\nuint32_t conditions = le32_to_cpu(phs_cfg->params.hs_config.conditions);\r\nif (phs_cfg->action == cpu_to_le16(HS_ACTIVATE)) {\r\nmwifiex_hs_activated_event(priv, true);\r\nreturn 0;\r\n} else {\r\ndev_dbg(adapter->dev, "cmd: CMD_RESP: HS_CFG cmd reply"\r\n" result=%#x, conditions=0x%x gpio=0x%x gap=0x%x\n",\r\nresp->result, conditions,\r\nphs_cfg->params.hs_config.gpio,\r\nphs_cfg->params.hs_config.gap);\r\n}\r\nif (conditions != HOST_SLEEP_CFG_CANCEL) {\r\nadapter->is_hs_configured = true;\r\n} else {\r\nadapter->is_hs_configured = false;\r\nif (adapter->hs_activated)\r\nmwifiex_hs_activated_event(priv, false);\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nmwifiex_process_hs_config(struct mwifiex_adapter *adapter)\r\n{\r\ndev_dbg(adapter->dev, "info: %s: auto cancelling host sleep"\r\n" since there is interrupt from the firmware\n", __func__);\r\nadapter->if_ops.wakeup(adapter);\r\nadapter->hs_activated = false;\r\nadapter->is_hs_configured = false;\r\nmwifiex_hs_activated_event(mwifiex_get_priv(adapter,\r\nMWIFIEX_BSS_ROLE_ANY), false);\r\n}\r\nvoid\r\nmwifiex_process_sleep_confirm_resp(struct mwifiex_adapter *adapter,\r\nu8 *pbuf, u32 upld_len)\r\n{\r\nstruct host_cmd_ds_command *cmd = (struct host_cmd_ds_command *) pbuf;\r\nstruct mwifiex_private *priv =\r\nmwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\r\nuint16_t result = le16_to_cpu(cmd->result);\r\nuint16_t command = le16_to_cpu(cmd->command);\r\nuint16_t seq_num = le16_to_cpu(cmd->seq_num);\r\nif (!upld_len) {\r\ndev_err(adapter->dev, "%s: cmd size is 0\n", __func__);\r\nreturn;\r\n}\r\npriv = mwifiex_get_priv_by_id(adapter, HostCmd_GET_BSS_NO(seq_num),\r\nHostCmd_GET_BSS_TYPE(seq_num));\r\nif (!priv)\r\npriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\r\nseq_num = HostCmd_GET_SEQ_NO(seq_num);\r\ncommand &= HostCmd_CMD_ID_MASK;\r\nif (command != HostCmd_CMD_802_11_PS_MODE_ENH) {\r\ndev_err(adapter->dev, "%s: received unexpected response for"\r\n" cmd %x, result = %x\n", __func__, command, result);\r\nreturn;\r\n}\r\nif (result) {\r\ndev_err(adapter->dev, "%s: sleep confirm cmd failed\n",\r\n__func__);\r\nadapter->pm_wakeup_card_req = false;\r\nadapter->ps_state = PS_STATE_AWAKE;\r\nreturn;\r\n}\r\nadapter->pm_wakeup_card_req = true;\r\nif (adapter->is_hs_configured)\r\nmwifiex_hs_activated_event(mwifiex_get_priv(adapter,\r\nMWIFIEX_BSS_ROLE_ANY), true);\r\nadapter->ps_state = PS_STATE_SLEEP;\r\ncmd->command = cpu_to_le16(command);\r\ncmd->seq_num = cpu_to_le16(seq_num);\r\n}\r\nint mwifiex_cmd_enh_power_mode(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nu16 cmd_action, uint16_t ps_bitmap,\r\nstruct mwifiex_ds_auto_ds *auto_ds)\r\n{\r\nstruct host_cmd_ds_802_11_ps_mode_enh *psmode_enh =\r\n&cmd->params.psmode_enh;\r\nu8 *tlv;\r\nu16 cmd_size = 0;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_PS_MODE_ENH);\r\nif (cmd_action == DIS_AUTO_PS) {\r\npsmode_enh->action = cpu_to_le16(DIS_AUTO_PS);\r\npsmode_enh->params.ps_bitmap = cpu_to_le16(ps_bitmap);\r\ncmd->size = cpu_to_le16(S_DS_GEN + sizeof(psmode_enh->action) +\r\nsizeof(psmode_enh->params.ps_bitmap));\r\n} else if (cmd_action == GET_PS) {\r\npsmode_enh->action = cpu_to_le16(GET_PS);\r\npsmode_enh->params.ps_bitmap = cpu_to_le16(ps_bitmap);\r\ncmd->size = cpu_to_le16(S_DS_GEN + sizeof(psmode_enh->action) +\r\nsizeof(psmode_enh->params.ps_bitmap));\r\n} else if (cmd_action == EN_AUTO_PS) {\r\npsmode_enh->action = cpu_to_le16(EN_AUTO_PS);\r\npsmode_enh->params.ps_bitmap = cpu_to_le16(ps_bitmap);\r\ncmd_size = S_DS_GEN + sizeof(psmode_enh->action) +\r\nsizeof(psmode_enh->params.ps_bitmap);\r\ntlv = (u8 *) cmd + cmd_size;\r\nif (ps_bitmap & BITMAP_STA_PS) {\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct mwifiex_ie_types_ps_param *ps_tlv =\r\n(struct mwifiex_ie_types_ps_param *) tlv;\r\nstruct mwifiex_ps_param *ps_mode = &ps_tlv->param;\r\nps_tlv->header.type = cpu_to_le16(TLV_TYPE_PS_PARAM);\r\nps_tlv->header.len = cpu_to_le16(sizeof(*ps_tlv) -\r\nsizeof(struct mwifiex_ie_types_header));\r\ncmd_size += sizeof(*ps_tlv);\r\ntlv += sizeof(*ps_tlv);\r\ndev_dbg(adapter->dev, "cmd: PS Command: Enter PS\n");\r\nps_mode->null_pkt_interval =\r\ncpu_to_le16(adapter->null_pkt_interval);\r\nps_mode->multiple_dtims =\r\ncpu_to_le16(adapter->multiple_dtim);\r\nps_mode->bcn_miss_timeout =\r\ncpu_to_le16(adapter->bcn_miss_time_out);\r\nps_mode->local_listen_interval =\r\ncpu_to_le16(adapter->local_listen_interval);\r\nps_mode->adhoc_wake_period =\r\ncpu_to_le16(adapter->adhoc_awake_period);\r\nps_mode->delay_to_ps =\r\ncpu_to_le16(adapter->delay_to_ps);\r\nps_mode->mode =\r\ncpu_to_le16(adapter->enhanced_ps_mode);\r\n}\r\nif (ps_bitmap & BITMAP_AUTO_DS) {\r\nstruct mwifiex_ie_types_auto_ds_param *auto_ds_tlv =\r\n(struct mwifiex_ie_types_auto_ds_param *) tlv;\r\nu16 idletime = 0;\r\nauto_ds_tlv->header.type =\r\ncpu_to_le16(TLV_TYPE_AUTO_DS_PARAM);\r\nauto_ds_tlv->header.len =\r\ncpu_to_le16(sizeof(*auto_ds_tlv) -\r\nsizeof(struct mwifiex_ie_types_header));\r\ncmd_size += sizeof(*auto_ds_tlv);\r\ntlv += sizeof(*auto_ds_tlv);\r\nif (auto_ds)\r\nidletime = auto_ds->idle_time;\r\ndev_dbg(priv->adapter->dev,\r\n"cmd: PS Command: Enter Auto Deep Sleep\n");\r\nauto_ds_tlv->deep_sleep_timeout = cpu_to_le16(idletime);\r\n}\r\ncmd->size = cpu_to_le16(cmd_size);\r\n}\r\nreturn 0;\r\n}\r\nint mwifiex_ret_enh_power_mode(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp,\r\nstruct mwifiex_ds_pm_cfg *pm_cfg)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct host_cmd_ds_802_11_ps_mode_enh *ps_mode =\r\n&resp->params.psmode_enh;\r\nuint16_t action = le16_to_cpu(ps_mode->action);\r\nuint16_t ps_bitmap = le16_to_cpu(ps_mode->params.ps_bitmap);\r\nuint16_t auto_ps_bitmap =\r\nle16_to_cpu(ps_mode->params.ps_bitmap);\r\ndev_dbg(adapter->dev, "info: %s: PS_MODE cmd reply result=%#x action=%#X\n",\r\n__func__, resp->result, action);\r\nif (action == EN_AUTO_PS) {\r\nif (auto_ps_bitmap & BITMAP_AUTO_DS) {\r\ndev_dbg(adapter->dev, "cmd: Enabled auto deep sleep\n");\r\npriv->adapter->is_deep_sleep = true;\r\n}\r\nif (auto_ps_bitmap & BITMAP_STA_PS) {\r\ndev_dbg(adapter->dev, "cmd: Enabled STA power save\n");\r\nif (adapter->sleep_period.period)\r\ndev_dbg(adapter->dev, "cmd: set to uapsd/pps mode\n");\r\n}\r\n} else if (action == DIS_AUTO_PS) {\r\nif (ps_bitmap & BITMAP_AUTO_DS) {\r\npriv->adapter->is_deep_sleep = false;\r\ndev_dbg(adapter->dev, "cmd: Disabled auto deep sleep\n");\r\n}\r\nif (ps_bitmap & BITMAP_STA_PS) {\r\ndev_dbg(adapter->dev, "cmd: Disabled STA power save\n");\r\nif (adapter->sleep_period.period) {\r\nadapter->delay_null_pkt = false;\r\nadapter->tx_lock_flag = false;\r\nadapter->pps_uapsd_mode = false;\r\n}\r\n}\r\n} else if (action == GET_PS) {\r\nif (ps_bitmap & BITMAP_STA_PS)\r\nadapter->ps_mode = MWIFIEX_802_11_POWER_MODE_PSP;\r\nelse\r\nadapter->ps_mode = MWIFIEX_802_11_POWER_MODE_CAM;\r\ndev_dbg(adapter->dev, "cmd: ps_bitmap=%#x\n", ps_bitmap);\r\nif (pm_cfg) {\r\nif (ps_bitmap & BITMAP_STA_PS)\r\npm_cfg->param.ps_mode = 1;\r\nelse\r\npm_cfg->param.ps_mode = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint mwifiex_cmd_get_hw_spec(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd)\r\n{\r\nstruct host_cmd_ds_get_hw_spec *hw_spec = &cmd->params.hw_spec;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_GET_HW_SPEC);\r\ncmd->size =\r\ncpu_to_le16(sizeof(struct host_cmd_ds_get_hw_spec) + S_DS_GEN);\r\nmemcpy(hw_spec->permanent_addr, priv->curr_addr, ETH_ALEN);\r\nreturn 0;\r\n}\r\nint mwifiex_ret_get_hw_spec(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct host_cmd_ds_get_hw_spec *hw_spec = &resp->params.hw_spec;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nint i;\r\nadapter->fw_cap_info = le32_to_cpu(hw_spec->fw_cap_info);\r\nif (IS_SUPPORT_MULTI_BANDS(adapter))\r\nadapter->fw_bands = (u8) GET_FW_DEFAULT_BANDS(adapter);\r\nelse\r\nadapter->fw_bands = BAND_B;\r\nadapter->config_bands = adapter->fw_bands;\r\nif (adapter->fw_bands & BAND_A) {\r\nif (adapter->fw_bands & BAND_GN) {\r\nadapter->config_bands |= BAND_AN;\r\nadapter->fw_bands |= BAND_AN;\r\n}\r\nif (adapter->fw_bands & BAND_AN) {\r\nadapter->adhoc_start_band = BAND_A | BAND_AN;\r\nadapter->adhoc_11n_enabled = true;\r\n} else {\r\nadapter->adhoc_start_band = BAND_A;\r\n}\r\npriv->adhoc_channel = DEFAULT_AD_HOC_CHANNEL_A;\r\n} else if (adapter->fw_bands & BAND_GN) {\r\nadapter->adhoc_start_band = BAND_G | BAND_B | BAND_GN;\r\npriv->adhoc_channel = DEFAULT_AD_HOC_CHANNEL;\r\nadapter->adhoc_11n_enabled = true;\r\n} else if (adapter->fw_bands & BAND_G) {\r\nadapter->adhoc_start_band = BAND_G | BAND_B;\r\npriv->adhoc_channel = DEFAULT_AD_HOC_CHANNEL;\r\n} else if (adapter->fw_bands & BAND_B) {\r\nadapter->adhoc_start_band = BAND_B;\r\npriv->adhoc_channel = DEFAULT_AD_HOC_CHANNEL;\r\n}\r\nadapter->fw_release_number = le32_to_cpu(hw_spec->fw_release_number);\r\nadapter->number_of_antenna = le16_to_cpu(hw_spec->number_of_antenna);\r\ndev_dbg(adapter->dev, "info: GET_HW_SPEC: fw_release_number- %#x\n",\r\nadapter->fw_release_number);\r\ndev_dbg(adapter->dev, "info: GET_HW_SPEC: permanent addr: %pM\n",\r\nhw_spec->permanent_addr);\r\ndev_dbg(adapter->dev, "info: GET_HW_SPEC: hw_if_version=%#x version=%#x\n",\r\nle16_to_cpu(hw_spec->hw_if_version),\r\nle16_to_cpu(hw_spec->version));\r\nif (priv->curr_addr[0] == 0xff)\r\nmemmove(priv->curr_addr, hw_spec->permanent_addr, ETH_ALEN);\r\nadapter->region_code = le16_to_cpu(hw_spec->region_code);\r\nfor (i = 0; i < MWIFIEX_MAX_REGION_CODE; i++)\r\nif (adapter->region_code == region_code_index[i])\r\nbreak;\r\nif (i >= MWIFIEX_MAX_REGION_CODE) {\r\nadapter->region_code = 0x10;\r\ndev_dbg(adapter->dev, "cmd: unknown region code, use default (USA)\n");\r\n}\r\nadapter->hw_dot_11n_dev_cap = le32_to_cpu(hw_spec->dot_11n_dev_cap);\r\nadapter->hw_dev_mcs_support = hw_spec->dev_mcs_support;\r\nif (adapter->if_ops.update_mp_end_port)\r\nadapter->if_ops.update_mp_end_port(adapter,\r\nle16_to_cpu(hw_spec->mp_end_port));\r\nreturn 0;\r\n}
