static inline u32 omap_dm_timer_read_reg(struct omap_dm_timer *timer, u32 reg)\r\n{\r\nWARN_ON((reg & 0xff) < _OMAP_TIMER_WAKEUP_EN_OFFSET);\r\nreturn __omap_dm_timer_read(timer, reg, timer->posted);\r\n}\r\nstatic void omap_dm_timer_write_reg(struct omap_dm_timer *timer, u32 reg,\r\nu32 value)\r\n{\r\nWARN_ON((reg & 0xff) < _OMAP_TIMER_WAKEUP_EN_OFFSET);\r\n__omap_dm_timer_write(timer, reg, value, timer->posted);\r\n}\r\nstatic void omap_timer_restore_context(struct omap_dm_timer *timer)\r\n{\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_OCP_CFG_OFFSET,\r\ntimer->context.tiocp_cfg);\r\nif (timer->revision > 1)\r\n__raw_writel(timer->context.tistat, timer->sys_stat);\r\n__raw_writel(timer->context.tisr, timer->irq_stat);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_WAKEUP_EN_REG,\r\ntimer->context.twer);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_COUNTER_REG,\r\ntimer->context.tcrr);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_LOAD_REG,\r\ntimer->context.tldr);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_MATCH_REG,\r\ntimer->context.tmar);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_IF_CTRL_REG,\r\ntimer->context.tsicr);\r\n__raw_writel(timer->context.tier, timer->irq_ena);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_CTRL_REG,\r\ntimer->context.tclr);\r\n}\r\nstatic void omap_dm_timer_wait_for_reset(struct omap_dm_timer *timer)\r\n{\r\nint c;\r\nif (!timer->sys_stat)\r\nreturn;\r\nc = 0;\r\nwhile (!(__raw_readl(timer->sys_stat) & 1)) {\r\nc++;\r\nif (c > 100000) {\r\nprintk(KERN_ERR "Timer failed to reset\n");\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void omap_dm_timer_reset(struct omap_dm_timer *timer)\r\n{\r\nomap_dm_timer_enable(timer);\r\nif (timer->pdev->id != 1) {\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_IF_CTRL_REG, 0x06);\r\nomap_dm_timer_wait_for_reset(timer);\r\n}\r\n__omap_dm_timer_reset(timer, 0, 0);\r\nomap_dm_timer_disable(timer);\r\ntimer->posted = 1;\r\n}\r\nint omap_dm_timer_prepare(struct omap_dm_timer *timer)\r\n{\r\nstruct dmtimer_platform_data *pdata = timer->pdev->dev.platform_data;\r\nint ret;\r\ntimer->fclk = clk_get(&timer->pdev->dev, "fck");\r\nif (WARN_ON_ONCE(IS_ERR_OR_NULL(timer->fclk))) {\r\ntimer->fclk = NULL;\r\ndev_err(&timer->pdev->dev, ": No fclk handle.\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdata->needs_manual_reset)\r\nomap_dm_timer_reset(timer);\r\nret = omap_dm_timer_set_source(timer, OMAP_TIMER_SRC_32_KHZ);\r\ntimer->posted = 1;\r\nreturn ret;\r\n}\r\nstruct omap_dm_timer *omap_dm_timer_request(void)\r\n{\r\nstruct omap_dm_timer *timer = NULL, *t;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&dm_timer_lock, flags);\r\nlist_for_each_entry(t, &omap_timer_list, node) {\r\nif (t->reserved)\r\ncontinue;\r\ntimer = t;\r\ntimer->reserved = 1;\r\nbreak;\r\n}\r\nif (timer) {\r\nret = omap_dm_timer_prepare(timer);\r\nif (ret) {\r\ntimer->reserved = 0;\r\ntimer = NULL;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dm_timer_lock, flags);\r\nif (!timer)\r\npr_debug("%s: timer request failed!\n", __func__);\r\nreturn timer;\r\n}\r\nstruct omap_dm_timer *omap_dm_timer_request_specific(int id)\r\n{\r\nstruct omap_dm_timer *timer = NULL, *t;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&dm_timer_lock, flags);\r\nlist_for_each_entry(t, &omap_timer_list, node) {\r\nif (t->pdev->id == id && !t->reserved) {\r\ntimer = t;\r\ntimer->reserved = 1;\r\nbreak;\r\n}\r\n}\r\nif (timer) {\r\nret = omap_dm_timer_prepare(timer);\r\nif (ret) {\r\ntimer->reserved = 0;\r\ntimer = NULL;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dm_timer_lock, flags);\r\nif (!timer)\r\npr_debug("%s: timer%d request failed!\n", __func__, id);\r\nreturn timer;\r\n}\r\nint omap_dm_timer_free(struct omap_dm_timer *timer)\r\n{\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nclk_put(timer->fclk);\r\nWARN_ON(!timer->reserved);\r\ntimer->reserved = 0;\r\nreturn 0;\r\n}\r\nvoid omap_dm_timer_enable(struct omap_dm_timer *timer)\r\n{\r\npm_runtime_get_sync(&timer->pdev->dev);\r\n}\r\nvoid omap_dm_timer_disable(struct omap_dm_timer *timer)\r\n{\r\npm_runtime_put(&timer->pdev->dev);\r\n}\r\nint omap_dm_timer_get_irq(struct omap_dm_timer *timer)\r\n{\r\nif (timer)\r\nreturn timer->irq;\r\nreturn -EINVAL;\r\n}\r\n__u32 omap_dm_timer_modify_idlect_mask(__u32 inputmask)\r\n{\r\nint i = 0;\r\nstruct omap_dm_timer *timer = NULL;\r\nunsigned long flags;\r\nif (!(inputmask & (1 << 1)))\r\nreturn inputmask;\r\nspin_lock_irqsave(&dm_timer_lock, flags);\r\nlist_for_each_entry(timer, &omap_timer_list, node) {\r\nu32 l;\r\nl = omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);\r\nif (l & OMAP_TIMER_CTRL_ST) {\r\nif (((omap_readl(MOD_CONF_CTRL_1) >> (i * 2)) & 0x03) == 0)\r\ninputmask &= ~(1 << 1);\r\nelse\r\ninputmask &= ~(1 << 2);\r\n}\r\ni++;\r\n}\r\nspin_unlock_irqrestore(&dm_timer_lock, flags);\r\nreturn inputmask;\r\n}\r\nstruct clk *omap_dm_timer_get_fclk(struct omap_dm_timer *timer)\r\n{\r\nif (timer)\r\nreturn timer->fclk;\r\nreturn NULL;\r\n}\r\n__u32 omap_dm_timer_modify_idlect_mask(__u32 inputmask)\r\n{\r\nBUG();\r\nreturn 0;\r\n}\r\nint omap_dm_timer_trigger(struct omap_dm_timer *timer)\r\n{\r\nif (unlikely(!timer || pm_runtime_suspended(&timer->pdev->dev))) {\r\npr_err("%s: timer not available or enabled.\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_TRIGGER_REG, 0);\r\nreturn 0;\r\n}\r\nint omap_dm_timer_start(struct omap_dm_timer *timer)\r\n{\r\nu32 l;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nomap_dm_timer_enable(timer);\r\nif (timer->loses_context) {\r\nu32 ctx_loss_cnt_after =\r\ntimer->get_context_loss_count(&timer->pdev->dev);\r\nif (ctx_loss_cnt_after != timer->ctx_loss_count)\r\nomap_timer_restore_context(timer);\r\n}\r\nl = omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);\r\nif (!(l & OMAP_TIMER_CTRL_ST)) {\r\nl |= OMAP_TIMER_CTRL_ST;\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_CTRL_REG, l);\r\n}\r\ntimer->context.tclr = l;\r\nreturn 0;\r\n}\r\nint omap_dm_timer_stop(struct omap_dm_timer *timer)\r\n{\r\nunsigned long rate = 0;\r\nstruct dmtimer_platform_data *pdata = timer->pdev->dev.platform_data;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nif (!pdata->needs_manual_reset)\r\nrate = clk_get_rate(timer->fclk);\r\n__omap_dm_timer_stop(timer, timer->posted, rate);\r\nreturn 0;\r\n}\r\nint omap_dm_timer_set_source(struct omap_dm_timer *timer, int source)\r\n{\r\nint ret;\r\nstruct dmtimer_platform_data *pdata;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\npdata = timer->pdev->dev.platform_data;\r\nif (source < 0 || source >= 3)\r\nreturn -EINVAL;\r\nret = pdata->set_timer_src(timer->pdev, source);\r\nreturn ret;\r\n}\r\nint omap_dm_timer_set_load(struct omap_dm_timer *timer, int autoreload,\r\nunsigned int load)\r\n{\r\nu32 l;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nomap_dm_timer_enable(timer);\r\nl = omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);\r\nif (autoreload)\r\nl |= OMAP_TIMER_CTRL_AR;\r\nelse\r\nl &= ~OMAP_TIMER_CTRL_AR;\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_CTRL_REG, l);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_LOAD_REG, load);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_TRIGGER_REG, 0);\r\ntimer->context.tclr = l;\r\ntimer->context.tldr = load;\r\nomap_dm_timer_disable(timer);\r\nreturn 0;\r\n}\r\nint omap_dm_timer_set_load_start(struct omap_dm_timer *timer, int autoreload,\r\nunsigned int load)\r\n{\r\nu32 l;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nomap_dm_timer_enable(timer);\r\nif (timer->loses_context) {\r\nu32 ctx_loss_cnt_after =\r\ntimer->get_context_loss_count(&timer->pdev->dev);\r\nif (ctx_loss_cnt_after != timer->ctx_loss_count)\r\nomap_timer_restore_context(timer);\r\n}\r\nl = omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);\r\nif (autoreload) {\r\nl |= OMAP_TIMER_CTRL_AR;\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_LOAD_REG, load);\r\n} else {\r\nl &= ~OMAP_TIMER_CTRL_AR;\r\n}\r\nl |= OMAP_TIMER_CTRL_ST;\r\n__omap_dm_timer_load_start(timer, l, load, timer->posted);\r\ntimer->context.tclr = l;\r\ntimer->context.tldr = load;\r\ntimer->context.tcrr = load;\r\nreturn 0;\r\n}\r\nint omap_dm_timer_set_match(struct omap_dm_timer *timer, int enable,\r\nunsigned int match)\r\n{\r\nu32 l;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nomap_dm_timer_enable(timer);\r\nl = omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);\r\nif (enable)\r\nl |= OMAP_TIMER_CTRL_CE;\r\nelse\r\nl &= ~OMAP_TIMER_CTRL_CE;\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_CTRL_REG, l);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_MATCH_REG, match);\r\ntimer->context.tclr = l;\r\ntimer->context.tmar = match;\r\nomap_dm_timer_disable(timer);\r\nreturn 0;\r\n}\r\nint omap_dm_timer_set_pwm(struct omap_dm_timer *timer, int def_on,\r\nint toggle, int trigger)\r\n{\r\nu32 l;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nomap_dm_timer_enable(timer);\r\nl = omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);\r\nl &= ~(OMAP_TIMER_CTRL_GPOCFG | OMAP_TIMER_CTRL_SCPWM |\r\nOMAP_TIMER_CTRL_PT | (0x03 << 10));\r\nif (def_on)\r\nl |= OMAP_TIMER_CTRL_SCPWM;\r\nif (toggle)\r\nl |= OMAP_TIMER_CTRL_PT;\r\nl |= trigger << 10;\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_CTRL_REG, l);\r\ntimer->context.tclr = l;\r\nomap_dm_timer_disable(timer);\r\nreturn 0;\r\n}\r\nint omap_dm_timer_set_prescaler(struct omap_dm_timer *timer, int prescaler)\r\n{\r\nu32 l;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nomap_dm_timer_enable(timer);\r\nl = omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);\r\nl &= ~(OMAP_TIMER_CTRL_PRE | (0x07 << 2));\r\nif (prescaler >= 0x00 && prescaler <= 0x07) {\r\nl |= OMAP_TIMER_CTRL_PRE;\r\nl |= prescaler << 2;\r\n}\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_CTRL_REG, l);\r\ntimer->context.tclr = l;\r\nomap_dm_timer_disable(timer);\r\nreturn 0;\r\n}\r\nint omap_dm_timer_set_int_enable(struct omap_dm_timer *timer,\r\nunsigned int value)\r\n{\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nomap_dm_timer_enable(timer);\r\n__omap_dm_timer_int_enable(timer, value);\r\ntimer->context.tier = value;\r\ntimer->context.twer = value;\r\nomap_dm_timer_disable(timer);\r\nreturn 0;\r\n}\r\nunsigned int omap_dm_timer_read_status(struct omap_dm_timer *timer)\r\n{\r\nunsigned int l;\r\nif (unlikely(!timer || pm_runtime_suspended(&timer->pdev->dev))) {\r\npr_err("%s: timer not available or enabled.\n", __func__);\r\nreturn 0;\r\n}\r\nl = __raw_readl(timer->irq_stat);\r\nreturn l;\r\n}\r\nint omap_dm_timer_write_status(struct omap_dm_timer *timer, unsigned int value)\r\n{\r\nif (unlikely(!timer || pm_runtime_suspended(&timer->pdev->dev)))\r\nreturn -EINVAL;\r\n__omap_dm_timer_write_status(timer, value);\r\ntimer->context.tisr = value;\r\nreturn 0;\r\n}\r\nunsigned int omap_dm_timer_read_counter(struct omap_dm_timer *timer)\r\n{\r\nif (unlikely(!timer || pm_runtime_suspended(&timer->pdev->dev))) {\r\npr_err("%s: timer not iavailable or enabled.\n", __func__);\r\nreturn 0;\r\n}\r\nreturn __omap_dm_timer_read_counter(timer, timer->posted);\r\n}\r\nint omap_dm_timer_write_counter(struct omap_dm_timer *timer, unsigned int value)\r\n{\r\nif (unlikely(!timer || pm_runtime_suspended(&timer->pdev->dev))) {\r\npr_err("%s: timer not available or enabled.\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_COUNTER_REG, value);\r\ntimer->context.tcrr = value;\r\nreturn 0;\r\n}\r\nint omap_dm_timers_active(void)\r\n{\r\nstruct omap_dm_timer *timer;\r\nlist_for_each_entry(timer, &omap_timer_list, node) {\r\nif (!timer->reserved)\r\ncontinue;\r\nif (omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG) &\r\nOMAP_TIMER_CTRL_ST) {\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit omap_dm_timer_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nstruct omap_dm_timer *timer;\r\nstruct resource *mem, *irq, *ioarea;\r\nstruct dmtimer_platform_data *pdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "%s: no platform data.\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (unlikely(!irq)) {\r\ndev_err(&pdev->dev, "%s: no IRQ resource.\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!mem)) {\r\ndev_err(&pdev->dev, "%s: no memory resource.\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nioarea = request_mem_region(mem->start, resource_size(mem),\r\npdev->name);\r\nif (!ioarea) {\r\ndev_err(&pdev->dev, "%s: region already claimed.\n", __func__);\r\nreturn -EBUSY;\r\n}\r\ntimer = kzalloc(sizeof(struct omap_dm_timer), GFP_KERNEL);\r\nif (!timer) {\r\ndev_err(&pdev->dev, "%s: no memory for omap_dm_timer.\n",\r\n__func__);\r\nret = -ENOMEM;\r\ngoto err_free_ioregion;\r\n}\r\ntimer->io_base = ioremap(mem->start, resource_size(mem));\r\nif (!timer->io_base) {\r\ndev_err(&pdev->dev, "%s: ioremap failed.\n", __func__);\r\nret = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ntimer->id = pdev->id;\r\ntimer->irq = irq->start;\r\ntimer->reserved = pdata->reserved;\r\ntimer->pdev = pdev;\r\ntimer->loses_context = pdata->loses_context;\r\ntimer->get_context_loss_count = pdata->get_context_loss_count;\r\nif (!pdata->needs_manual_reset) {\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_irq_safe(&pdev->dev);\r\n}\r\nif (!timer->reserved) {\r\npm_runtime_get_sync(&pdev->dev);\r\n__omap_dm_timer_init_regs(timer);\r\npm_runtime_put(&pdev->dev);\r\n}\r\nspin_lock_irqsave(&dm_timer_lock, flags);\r\nlist_add_tail(&timer->node, &omap_timer_list);\r\nspin_unlock_irqrestore(&dm_timer_lock, flags);\r\ndev_dbg(&pdev->dev, "Device Probed.\n");\r\nreturn 0;\r\nerr_free_mem:\r\nkfree(timer);\r\nerr_free_ioregion:\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nreturn ret;\r\n}\r\nstatic int __devexit omap_dm_timer_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_dm_timer *timer;\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nspin_lock_irqsave(&dm_timer_lock, flags);\r\nlist_for_each_entry(timer, &omap_timer_list, node)\r\nif (timer->pdev->id == pdev->id) {\r\nlist_del(&timer->node);\r\nkfree(timer);\r\nret = 0;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&dm_timer_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int __init omap_dm_timer_driver_init(void)\r\n{\r\nreturn platform_driver_register(&omap_dm_timer_driver);\r\n}\r\nstatic void __exit omap_dm_timer_driver_exit(void)\r\n{\r\nplatform_driver_unregister(&omap_dm_timer_driver);\r\n}
