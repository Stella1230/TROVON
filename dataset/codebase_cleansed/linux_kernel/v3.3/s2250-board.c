static inline struct s2250 *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct s2250, sd);\r\n}\r\nstatic int go7007_usb_vendor_request(struct go7007 *go, u16 request,\r\nu16 value, u16 index, void *transfer_buffer, int length, int in)\r\n{\r\nstruct go7007_usb *usb = go->hpi_context;\r\nint timeout = 5000;\r\nif (in) {\r\nreturn usb_control_msg(usb->usbdev,\r\nusb_rcvctrlpipe(usb->usbdev, 0), request,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\nvalue, index, transfer_buffer, length, timeout);\r\n} else {\r\nreturn usb_control_msg(usb->usbdev,\r\nusb_sndctrlpipe(usb->usbdev, 0), request,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, transfer_buffer, length, timeout);\r\n}\r\n}\r\nstatic int write_reg(struct i2c_client *client, u8 reg, u8 value)\r\n{\r\nstruct go7007 *go = i2c_get_adapdata(client->adapter);\r\nstruct go7007_usb *usb;\r\nint rc;\r\nint dev_addr = client->addr << 1;\r\nu8 *buf;\r\nif (go == NULL)\r\nreturn -ENODEV;\r\nif (go->status == STATUS_SHUTDOWN)\r\nreturn -EBUSY;\r\nbuf = kzalloc(16, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nusb = go->hpi_context;\r\nif (mutex_lock_interruptible(&usb->i2c_lock) != 0) {\r\nprintk(KERN_INFO "i2c lock failed\n");\r\nkfree(buf);\r\nreturn -EINTR;\r\n}\r\nrc = go7007_usb_vendor_request(go, 0x55, dev_addr,\r\n(reg<<8 | value),\r\nbuf,\r\n16, 1);\r\nmutex_unlock(&usb->i2c_lock);\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nstatic int write_reg_fp(struct i2c_client *client, u16 addr, u16 val)\r\n{\r\nstruct go7007 *go = i2c_get_adapdata(client->adapter);\r\nstruct go7007_usb *usb;\r\nu8 *buf;\r\nstruct s2250 *dec = i2c_get_clientdata(client);\r\nif (go == NULL)\r\nreturn -ENODEV;\r\nif (go->status == STATUS_SHUTDOWN)\r\nreturn -EBUSY;\r\nbuf = kzalloc(16, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nmemset(buf, 0xcd, 6);\r\nusb = go->hpi_context;\r\nif (mutex_lock_interruptible(&usb->i2c_lock) != 0) {\r\nprintk(KERN_INFO "i2c lock failed\n");\r\nkfree(buf);\r\nreturn -EINTR;\r\n}\r\nif (go7007_usb_vendor_request(go, 0x57, addr, val, buf, 16, 1) < 0) {\r\nkfree(buf);\r\nreturn -EFAULT;\r\n}\r\nmutex_unlock(&usb->i2c_lock);\r\nif (buf[0] == 0) {\r\nunsigned int subaddr, val_read;\r\nsubaddr = (buf[4] << 8) + buf[5];\r\nval_read = (buf[2] << 8) + buf[3];\r\nkfree(buf);\r\nif (val_read != val) {\r\nprintk(KERN_INFO "invalid fp write %x %x\n",\r\nval_read, val);\r\nreturn -EFAULT;\r\n}\r\nif (subaddr != addr) {\r\nprintk(KERN_INFO "invalid fp write addr %x %x\n",\r\nsubaddr, addr);\r\nreturn -EFAULT;\r\n}\r\n} else {\r\nkfree(buf);\r\nreturn -EFAULT;\r\n}\r\nif (addr == 0x12b)\r\ndec->reg12b_val = val;\r\nreturn 0;\r\n}\r\nstatic int read_reg_fp(struct i2c_client *client, u16 addr, u16 *val)\r\n{\r\nstruct go7007 *go = i2c_get_adapdata(client->adapter);\r\nstruct go7007_usb *usb;\r\nu8 *buf;\r\nif (go == NULL)\r\nreturn -ENODEV;\r\nif (go->status == STATUS_SHUTDOWN)\r\nreturn -EBUSY;\r\nbuf = kzalloc(16, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nmemset(buf, 0xcd, 6);\r\nusb = go->hpi_context;\r\nif (mutex_lock_interruptible(&usb->i2c_lock) != 0) {\r\nprintk(KERN_INFO "i2c lock failed\n");\r\nkfree(buf);\r\nreturn -EINTR;\r\n}\r\nif (go7007_usb_vendor_request(go, 0x58, addr, 0, buf, 16, 1) < 0) {\r\nkfree(buf);\r\nreturn -EFAULT;\r\n}\r\nmutex_unlock(&usb->i2c_lock);\r\n*val = (buf[0] << 8) | buf[1];\r\nkfree(buf);\r\nreturn 0;\r\n}\r\nstatic int write_regs(struct i2c_client *client, u8 *regs)\r\n{\r\nint i;\r\nfor (i = 0; !((regs[i] == 0x00) && (regs[i+1] == 0x00)); i += 2) {\r\nif (write_reg(client, regs[i], regs[i+1]) < 0) {\r\nprintk(KERN_INFO "s2250: failed\n");\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int write_regs_fp(struct i2c_client *client, u16 *regs)\r\n{\r\nint i;\r\nfor (i = 0; !((regs[i] == 0x00) && (regs[i+1] == 0x00)); i += 2) {\r\nif (write_reg_fp(client, regs[i], regs[i+1]) < 0) {\r\nprintk(KERN_INFO "s2250: failed fp\n");\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int s2250_s_video_routing(struct v4l2_subdev *sd, u32 input, u32 output,\r\nu32 config)\r\n{\r\nstruct s2250 *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint vidsys;\r\nvidsys = (state->std == V4L2_STD_NTSC) ? 0x01 : 0x00;\r\nif (input == 0) {\r\nwrite_reg_fp(client, 0x20, 0x020 | vidsys);\r\nwrite_reg_fp(client, 0x21, 0x662);\r\nwrite_reg_fp(client, 0x140, 0x060);\r\n} else if (input == 1) {\r\nwrite_reg_fp(client, 0x20, 0x040 | vidsys);\r\nwrite_reg_fp(client, 0x21, 0x666);\r\nwrite_reg_fp(client, 0x140, 0x060);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nstate->input = input;\r\nreturn 0;\r\n}\r\nstatic int s2250_s_std(struct v4l2_subdev *sd, v4l2_std_id norm)\r\n{\r\nstruct s2250 *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu16 vidsource;\r\nvidsource = (state->input == 1) ? 0x040 : 0x020;\r\nswitch (norm) {\r\ncase V4L2_STD_NTSC:\r\nwrite_regs_fp(client, vid_regs_fp);\r\nwrite_reg_fp(client, 0x20, vidsource | 1);\r\nbreak;\r\ncase V4L2_STD_PAL:\r\nwrite_regs_fp(client, vid_regs_fp);\r\nwrite_regs_fp(client, vid_regs_fp_pal);\r\nwrite_reg_fp(client, 0x20, vidsource);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstate->std = norm;\r\nreturn 0;\r\n}\r\nstatic int s2250_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *query)\r\n{\r\nswitch (query->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nreturn v4l2_ctrl_query_fill(query, 0, 100, 1, 50);\r\ncase V4L2_CID_CONTRAST:\r\nreturn v4l2_ctrl_query_fill(query, 0, 100, 1, 50);\r\ncase V4L2_CID_SATURATION:\r\nreturn v4l2_ctrl_query_fill(query, 0, 100, 1, 50);\r\ncase V4L2_CID_HUE:\r\nreturn v4l2_ctrl_query_fill(query, -50, 50, 1, 0);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s2250_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)\r\n{\r\nstruct s2250 *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint value1;\r\nu16 oldvalue;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nif (ctrl->value > 100)\r\nstate->brightness = 100;\r\nelse if (ctrl->value < 0)\r\nstate->brightness = 0;\r\nelse\r\nstate->brightness = ctrl->value;\r\nvalue1 = (state->brightness - 50) * 255 / 100;\r\nread_reg_fp(client, VPX322_ADDR_BRIGHTNESS0, &oldvalue);\r\nwrite_reg_fp(client, VPX322_ADDR_BRIGHTNESS0,\r\nvalue1 | (oldvalue & ~0xff));\r\nread_reg_fp(client, VPX322_ADDR_BRIGHTNESS1, &oldvalue);\r\nwrite_reg_fp(client, VPX322_ADDR_BRIGHTNESS1,\r\nvalue1 | (oldvalue & ~0xff));\r\nwrite_reg_fp(client, 0x140, 0x60);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nif (ctrl->value > 100)\r\nstate->contrast = 100;\r\nelse if (ctrl->value < 0)\r\nstate->contrast = 0;\r\nelse\r\nstate->contrast = ctrl->value;\r\nvalue1 = state->contrast * 0x40 / 100;\r\nif (value1 > 0x3f)\r\nvalue1 = 0x3f;\r\nread_reg_fp(client, VPX322_ADDR_CONTRAST0, &oldvalue);\r\nwrite_reg_fp(client, VPX322_ADDR_CONTRAST0,\r\nvalue1 | (oldvalue & ~0x3f));\r\nread_reg_fp(client, VPX322_ADDR_CONTRAST1, &oldvalue);\r\nwrite_reg_fp(client, VPX322_ADDR_CONTRAST1,\r\nvalue1 | (oldvalue & ~0x3f));\r\nwrite_reg_fp(client, 0x140, 0x60);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nif (ctrl->value > 100)\r\nstate->saturation = 100;\r\nelse if (ctrl->value < 0)\r\nstate->saturation = 0;\r\nelse\r\nstate->saturation = ctrl->value;\r\nvalue1 = state->saturation * 4140 / 100;\r\nif (value1 > 4094)\r\nvalue1 = 4094;\r\nwrite_reg_fp(client, VPX322_ADDR_SAT, value1);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nif (ctrl->value > 50)\r\nstate->hue = 50;\r\nelse if (ctrl->value < -50)\r\nstate->hue = -50;\r\nelse\r\nstate->hue = ctrl->value;\r\nvalue1 = state->hue * 280 / 50;\r\nwrite_reg_fp(client, VPX322_ADDR_HUE, value1);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s2250_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)\r\n{\r\nstruct s2250 *state = to_state(sd);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nctrl->value = state->brightness;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nctrl->value = state->contrast;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nctrl->value = state->saturation;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nctrl->value = state->hue;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s2250_s_mbus_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *fmt)\r\n{\r\nstruct s2250 *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (fmt->height < 640) {\r\nwrite_reg_fp(client, 0x12b, state->reg12b_val | 0x400);\r\nwrite_reg_fp(client, 0x140, 0x060);\r\n} else {\r\nwrite_reg_fp(client, 0x12b, state->reg12b_val & ~0x400);\r\nwrite_reg_fp(client, 0x140, 0x060);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s2250_s_audio_routing(struct v4l2_subdev *sd, u32 input, u32 output,\r\nu32 config)\r\n{\r\nstruct s2250 *state = to_state(sd);\r\nswitch (input) {\r\ncase 0:\r\nwrite_reg(state->audio, 0x08, 0x02);\r\nbreak;\r\ncase 1:\r\nwrite_reg(state->audio, 0x08, 0x04);\r\nbreak;\r\ncase 2:\r\nwrite_reg(state->audio, 0x08, 0x05);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstate->audio_input = input;\r\nreturn 0;\r\n}\r\nstatic int s2250_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct s2250 *state = to_state(sd);\r\nv4l2_info(sd, "Standard: %s\n", state->std == V4L2_STD_NTSC ? "NTSC" :\r\nstate->std == V4L2_STD_PAL ? "PAL" :\r\nstate->std == V4L2_STD_SECAM ? "SECAM" :\r\n"unknown");\r\nv4l2_info(sd, "Input: %s\n", state->input == 0 ? "Composite" :\r\nstate->input == 1 ? "S-video" :\r\n"error");\r\nv4l2_info(sd, "Brightness: %d\n", state->brightness);\r\nv4l2_info(sd, "Contrast: %d\n", state->contrast);\r\nv4l2_info(sd, "Saturation: %d\n", state->saturation);\r\nv4l2_info(sd, "Hue: %d\n", state->hue); return 0;\r\nv4l2_info(sd, "Audio input: %s\n", state->audio_input == 0 ? "Line In" :\r\nstate->audio_input == 1 ? "Mic" :\r\nstate->audio_input == 2 ? "Mic Boost" :\r\n"error");\r\nreturn 0;\r\n}\r\nstatic int s2250_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_client *audio;\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct s2250 *state;\r\nstruct v4l2_subdev *sd;\r\nu8 *data;\r\nstruct go7007 *go = i2c_get_adapdata(adapter);\r\nstruct go7007_usb *usb = go->hpi_context;\r\naudio = i2c_new_dummy(adapter, TLV320_ADDRESS >> 1);\r\nif (audio == NULL)\r\nreturn -ENOMEM;\r\nstate = kmalloc(sizeof(struct s2250), GFP_KERNEL);\r\nif (state == NULL) {\r\ni2c_unregister_device(audio);\r\nreturn -ENOMEM;\r\n}\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &s2250_ops);\r\nv4l2_info(sd, "initializing %s at address 0x%x on %s\n",\r\n"Sensoray 2250/2251", client->addr, client->adapter->name);\r\nstate->std = V4L2_STD_NTSC;\r\nstate->brightness = 50;\r\nstate->contrast = 50;\r\nstate->saturation = 50;\r\nstate->hue = 0;\r\nstate->audio = audio;\r\nif (write_regs(audio, aud_regs) < 0) {\r\nprintk(KERN_ERR\r\n"s2250: error initializing audio\n");\r\ni2c_unregister_device(audio);\r\nkfree(state);\r\nreturn 0;\r\n}\r\nif (write_regs(client, vid_regs) < 0) {\r\nprintk(KERN_ERR\r\n"s2250: error initializing decoder\n");\r\ni2c_unregister_device(audio);\r\nkfree(state);\r\nreturn 0;\r\n}\r\nif (write_regs_fp(client, vid_regs_fp) < 0) {\r\nprintk(KERN_ERR\r\n"s2250: error initializing decoder\n");\r\ni2c_unregister_device(audio);\r\nkfree(state);\r\nreturn 0;\r\n}\r\nwrite_reg_fp(client, 0x20, 0x020 | 1);\r\nwrite_reg_fp(client, 0x21, 0x662);\r\nwrite_reg_fp(client, 0x140, 0x060);\r\nstate->audio_input = 0;\r\nwrite_reg(client, 0x08, 0x02);\r\nif (mutex_lock_interruptible(&usb->i2c_lock) == 0) {\r\ndata = kzalloc(16, GFP_KERNEL);\r\nif (data != NULL) {\r\nint rc;\r\nrc = go7007_usb_vendor_request(go, 0x41, 0, 0,\r\ndata, 16, 1);\r\nif (rc > 0) {\r\nu8 mask;\r\ndata[0] = 0;\r\nmask = 1<<5;\r\ndata[0] &= ~mask;\r\ndata[1] |= mask;\r\ngo7007_usb_vendor_request(go, 0x40, 0,\r\n(data[1]<<8)\r\n+ data[1],\r\ndata, 16, 0);\r\n}\r\nkfree(data);\r\n}\r\nmutex_unlock(&usb->i2c_lock);\r\n}\r\nv4l2_info(sd, "initialized successfully\n");\r\nreturn 0;\r\n}\r\nstatic int s2250_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nkfree(to_state(sd));\r\nreturn 0;\r\n}\r\nstatic __init int init_s2250(void)\r\n{\r\nreturn i2c_add_driver(&s2250_driver);\r\n}\r\nstatic __exit void exit_s2250(void)\r\n{\r\ni2c_del_driver(&s2250_driver);\r\n}
