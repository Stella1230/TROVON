static struct overlay_registers *\r\nintel_overlay_map_regs(struct intel_overlay *overlay)\r\n{\r\ndrm_i915_private_t *dev_priv = overlay->dev->dev_private;\r\nstruct overlay_registers *regs;\r\nif (OVERLAY_NEEDS_PHYSICAL(overlay->dev))\r\nregs = overlay->reg_bo->phys_obj->handle->vaddr;\r\nelse\r\nregs = io_mapping_map_wc(dev_priv->mm.gtt_mapping,\r\noverlay->reg_bo->gtt_offset);\r\nreturn regs;\r\n}\r\nstatic void intel_overlay_unmap_regs(struct intel_overlay *overlay,\r\nstruct overlay_registers *regs)\r\n{\r\nif (!OVERLAY_NEEDS_PHYSICAL(overlay->dev))\r\nio_mapping_unmap(regs);\r\n}\r\nstatic int intel_overlay_do_wait_request(struct intel_overlay *overlay,\r\nstruct drm_i915_gem_request *request,\r\nvoid (*tail)(struct intel_overlay *))\r\n{\r\nstruct drm_device *dev = overlay->dev;\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nint ret;\r\nBUG_ON(overlay->last_flip_req);\r\nret = i915_add_request(LP_RING(dev_priv), NULL, request);\r\nif (ret) {\r\nkfree(request);\r\nreturn ret;\r\n}\r\noverlay->last_flip_req = request->seqno;\r\noverlay->flip_tail = tail;\r\nret = i915_wait_request(LP_RING(dev_priv), overlay->last_flip_req);\r\nif (ret)\r\nreturn ret;\r\noverlay->last_flip_req = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\ni830_activate_pipe_a(struct drm_device *dev)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nstruct intel_crtc *crtc;\r\nstruct drm_crtc_helper_funcs *crtc_funcs;\r\nstruct drm_display_mode vesa_640x480 = {\r\nDRM_MODE("640x480", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,\r\n752, 800, 0, 480, 489, 492, 525, 0,\r\nDRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC)\r\n}, *mode;\r\ncrtc = to_intel_crtc(dev_priv->pipe_to_crtc_mapping[0]);\r\nif (crtc->dpms_mode == DRM_MODE_DPMS_ON)\r\nreturn 0;\r\nif (I915_READ(_PIPEACONF) & PIPECONF_ENABLE)\r\nreturn 0;\r\ncrtc_funcs = crtc->base.helper_private;\r\nif (crtc_funcs->dpms == NULL)\r\nreturn 0;\r\nDRM_DEBUG_DRIVER("Enabling pipe A in order to enable overlay\n");\r\nmode = drm_mode_duplicate(dev, &vesa_640x480);\r\ndrm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);\r\nif (!drm_crtc_helper_set_mode(&crtc->base, mode,\r\ncrtc->base.x, crtc->base.y,\r\ncrtc->base.fb))\r\nreturn 0;\r\ncrtc_funcs->dpms(&crtc->base, DRM_MODE_DPMS_ON);\r\nreturn 1;\r\n}\r\nstatic void\r\ni830_deactivate_pipe_a(struct drm_device *dev)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nstruct drm_crtc *crtc = dev_priv->pipe_to_crtc_mapping[0];\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\ncrtc_funcs->dpms(crtc, DRM_MODE_DPMS_OFF);\r\n}\r\nstatic int intel_overlay_on(struct intel_overlay *overlay)\r\n{\r\nstruct drm_device *dev = overlay->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct drm_i915_gem_request *request;\r\nint pipe_a_quirk = 0;\r\nint ret;\r\nBUG_ON(overlay->active);\r\noverlay->active = 1;\r\nif (IS_I830(dev)) {\r\npipe_a_quirk = i830_activate_pipe_a(dev);\r\nif (pipe_a_quirk < 0)\r\nreturn pipe_a_quirk;\r\n}\r\nrequest = kzalloc(sizeof(*request), GFP_KERNEL);\r\nif (request == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = BEGIN_LP_RING(4);\r\nif (ret) {\r\nkfree(request);\r\ngoto out;\r\n}\r\nOUT_RING(MI_OVERLAY_FLIP | MI_OVERLAY_ON);\r\nOUT_RING(overlay->flip_addr | OFC_UPDATE);\r\nOUT_RING(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);\r\nOUT_RING(MI_NOOP);\r\nADVANCE_LP_RING();\r\nret = intel_overlay_do_wait_request(overlay, request, NULL);\r\nout:\r\nif (pipe_a_quirk)\r\ni830_deactivate_pipe_a(dev);\r\nreturn ret;\r\n}\r\nstatic int intel_overlay_continue(struct intel_overlay *overlay,\r\nbool load_polyphase_filter)\r\n{\r\nstruct drm_device *dev = overlay->dev;\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nstruct drm_i915_gem_request *request;\r\nu32 flip_addr = overlay->flip_addr;\r\nu32 tmp;\r\nint ret;\r\nBUG_ON(!overlay->active);\r\nrequest = kzalloc(sizeof(*request), GFP_KERNEL);\r\nif (request == NULL)\r\nreturn -ENOMEM;\r\nif (load_polyphase_filter)\r\nflip_addr |= OFC_UPDATE;\r\ntmp = I915_READ(DOVSTA);\r\nif (tmp & (1 << 17))\r\nDRM_DEBUG("overlay underrun, DOVSTA: %x\n", tmp);\r\nret = BEGIN_LP_RING(2);\r\nif (ret) {\r\nkfree(request);\r\nreturn ret;\r\n}\r\nOUT_RING(MI_OVERLAY_FLIP | MI_OVERLAY_CONTINUE);\r\nOUT_RING(flip_addr);\r\nADVANCE_LP_RING();\r\nret = i915_add_request(LP_RING(dev_priv), NULL, request);\r\nif (ret) {\r\nkfree(request);\r\nreturn ret;\r\n}\r\noverlay->last_flip_req = request->seqno;\r\nreturn 0;\r\n}\r\nstatic void intel_overlay_release_old_vid_tail(struct intel_overlay *overlay)\r\n{\r\nstruct drm_i915_gem_object *obj = overlay->old_vid_bo;\r\ni915_gem_object_unpin(obj);\r\ndrm_gem_object_unreference(&obj->base);\r\noverlay->old_vid_bo = NULL;\r\n}\r\nstatic void intel_overlay_off_tail(struct intel_overlay *overlay)\r\n{\r\nstruct drm_i915_gem_object *obj = overlay->vid_bo;\r\nBUG_ON(!overlay->vid_bo);\r\ni915_gem_object_unpin(obj);\r\ndrm_gem_object_unreference(&obj->base);\r\noverlay->vid_bo = NULL;\r\noverlay->crtc->overlay = NULL;\r\noverlay->crtc = NULL;\r\noverlay->active = 0;\r\n}\r\nstatic int intel_overlay_off(struct intel_overlay *overlay)\r\n{\r\nstruct drm_device *dev = overlay->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nu32 flip_addr = overlay->flip_addr;\r\nstruct drm_i915_gem_request *request;\r\nint ret;\r\nBUG_ON(!overlay->active);\r\nrequest = kzalloc(sizeof(*request), GFP_KERNEL);\r\nif (request == NULL)\r\nreturn -ENOMEM;\r\nflip_addr |= OFC_UPDATE;\r\nret = BEGIN_LP_RING(6);\r\nif (ret) {\r\nkfree(request);\r\nreturn ret;\r\n}\r\nOUT_RING(MI_OVERLAY_FLIP | MI_OVERLAY_CONTINUE);\r\nOUT_RING(flip_addr);\r\nOUT_RING(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);\r\nOUT_RING(MI_OVERLAY_FLIP | MI_OVERLAY_OFF);\r\nOUT_RING(flip_addr);\r\nOUT_RING(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);\r\nADVANCE_LP_RING();\r\nreturn intel_overlay_do_wait_request(overlay, request,\r\nintel_overlay_off_tail);\r\n}\r\nstatic int intel_overlay_recover_from_interrupt(struct intel_overlay *overlay)\r\n{\r\nstruct drm_device *dev = overlay->dev;\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nint ret;\r\nif (overlay->last_flip_req == 0)\r\nreturn 0;\r\nret = i915_wait_request(LP_RING(dev_priv), overlay->last_flip_req);\r\nif (ret)\r\nreturn ret;\r\nif (overlay->flip_tail)\r\noverlay->flip_tail(overlay);\r\noverlay->last_flip_req = 0;\r\nreturn 0;\r\n}\r\nstatic int intel_overlay_release_old_vid(struct intel_overlay *overlay)\r\n{\r\nstruct drm_device *dev = overlay->dev;\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nint ret;\r\nif (!overlay->old_vid_bo)\r\nreturn 0;\r\nif (I915_READ(ISR) & I915_OVERLAY_PLANE_FLIP_PENDING_INTERRUPT) {\r\nstruct drm_i915_gem_request *request;\r\nrequest = kzalloc(sizeof(*request), GFP_KERNEL);\r\nif (request == NULL)\r\nreturn -ENOMEM;\r\nret = BEGIN_LP_RING(2);\r\nif (ret) {\r\nkfree(request);\r\nreturn ret;\r\n}\r\nOUT_RING(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);\r\nOUT_RING(MI_NOOP);\r\nADVANCE_LP_RING();\r\nret = intel_overlay_do_wait_request(overlay, request,\r\nintel_overlay_release_old_vid_tail);\r\nif (ret)\r\nreturn ret;\r\n}\r\nintel_overlay_release_old_vid_tail(overlay);\r\nreturn 0;\r\n}\r\nstatic int packed_depth_bytes(u32 format)\r\n{\r\nswitch (format & I915_OVERLAY_DEPTH_MASK) {\r\ncase I915_OVERLAY_YUV422:\r\nreturn 4;\r\ncase I915_OVERLAY_YUV411:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int packed_width_bytes(u32 format, short width)\r\n{\r\nswitch (format & I915_OVERLAY_DEPTH_MASK) {\r\ncase I915_OVERLAY_YUV422:\r\nreturn width << 1;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int uv_hsubsampling(u32 format)\r\n{\r\nswitch (format & I915_OVERLAY_DEPTH_MASK) {\r\ncase I915_OVERLAY_YUV422:\r\ncase I915_OVERLAY_YUV420:\r\nreturn 2;\r\ncase I915_OVERLAY_YUV411:\r\ncase I915_OVERLAY_YUV410:\r\nreturn 4;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int uv_vsubsampling(u32 format)\r\n{\r\nswitch (format & I915_OVERLAY_DEPTH_MASK) {\r\ncase I915_OVERLAY_YUV420:\r\ncase I915_OVERLAY_YUV410:\r\nreturn 2;\r\ncase I915_OVERLAY_YUV422:\r\ncase I915_OVERLAY_YUV411:\r\nreturn 1;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic u32 calc_swidthsw(struct drm_device *dev, u32 offset, u32 width)\r\n{\r\nu32 mask, shift, ret;\r\nif (IS_GEN2(dev)) {\r\nmask = 0x1f;\r\nshift = 5;\r\n} else {\r\nmask = 0x3f;\r\nshift = 6;\r\n}\r\nret = ((offset + width + mask) >> shift) - (offset >> shift);\r\nif (!IS_GEN2(dev))\r\nret <<= 1;\r\nret -= 1;\r\nreturn ret << 2;\r\n}\r\nstatic void update_polyphase_filter(struct overlay_registers *regs)\r\n{\r\nmemcpy(regs->Y_HCOEFS, y_static_hcoeffs, sizeof(y_static_hcoeffs));\r\nmemcpy(regs->UV_HCOEFS, uv_static_hcoeffs, sizeof(uv_static_hcoeffs));\r\n}\r\nstatic bool update_scaling_factors(struct intel_overlay *overlay,\r\nstruct overlay_registers *regs,\r\nstruct put_image_params *params)\r\n{\r\nu32 xscale, yscale, xscale_UV, yscale_UV;\r\n#define FP_SHIFT 12\r\n#define FRACT_MASK 0xfff\r\nbool scale_changed = false;\r\nint uv_hscale = uv_hsubsampling(params->format);\r\nint uv_vscale = uv_vsubsampling(params->format);\r\nif (params->dst_w > 1)\r\nxscale = ((params->src_scan_w - 1) << FP_SHIFT)\r\n/(params->dst_w);\r\nelse\r\nxscale = 1 << FP_SHIFT;\r\nif (params->dst_h > 1)\r\nyscale = ((params->src_scan_h - 1) << FP_SHIFT)\r\n/(params->dst_h);\r\nelse\r\nyscale = 1 << FP_SHIFT;\r\nxscale_UV = xscale/uv_hscale;\r\nyscale_UV = yscale/uv_vscale;\r\nxscale = xscale_UV * uv_hscale;\r\nyscale = yscale_UV * uv_vscale;\r\nif (xscale != overlay->old_xscale || yscale != overlay->old_yscale)\r\nscale_changed = true;\r\noverlay->old_xscale = xscale;\r\noverlay->old_yscale = yscale;\r\nregs->YRGBSCALE = (((yscale & FRACT_MASK) << 20) |\r\n((xscale >> FP_SHIFT) << 16) |\r\n((xscale & FRACT_MASK) << 3));\r\nregs->UVSCALE = (((yscale_UV & FRACT_MASK) << 20) |\r\n((xscale_UV >> FP_SHIFT) << 16) |\r\n((xscale_UV & FRACT_MASK) << 3));\r\nregs->UVSCALEV = ((((yscale >> FP_SHIFT) << 16) |\r\n((yscale_UV >> FP_SHIFT) << 0)));\r\nif (scale_changed)\r\nupdate_polyphase_filter(regs);\r\nreturn scale_changed;\r\n}\r\nstatic void update_colorkey(struct intel_overlay *overlay,\r\nstruct overlay_registers *regs)\r\n{\r\nu32 key = overlay->color_key;\r\nswitch (overlay->crtc->base.fb->bits_per_pixel) {\r\ncase 8:\r\nregs->DCLRKV = 0;\r\nregs->DCLRKM = CLK_RGB8I_MASK | DST_KEY_ENABLE;\r\nbreak;\r\ncase 16:\r\nif (overlay->crtc->base.fb->depth == 15) {\r\nregs->DCLRKV = RGB15_TO_COLORKEY(key);\r\nregs->DCLRKM = CLK_RGB15_MASK | DST_KEY_ENABLE;\r\n} else {\r\nregs->DCLRKV = RGB16_TO_COLORKEY(key);\r\nregs->DCLRKM = CLK_RGB16_MASK | DST_KEY_ENABLE;\r\n}\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nregs->DCLRKV = key;\r\nregs->DCLRKM = CLK_RGB24_MASK | DST_KEY_ENABLE;\r\nbreak;\r\n}\r\n}\r\nstatic u32 overlay_cmd_reg(struct put_image_params *params)\r\n{\r\nu32 cmd = OCMD_ENABLE | OCMD_BUF_TYPE_FRAME | OCMD_BUFFER0;\r\nif (params->format & I915_OVERLAY_YUV_PLANAR) {\r\nswitch (params->format & I915_OVERLAY_DEPTH_MASK) {\r\ncase I915_OVERLAY_YUV422:\r\ncmd |= OCMD_YUV_422_PLANAR;\r\nbreak;\r\ncase I915_OVERLAY_YUV420:\r\ncmd |= OCMD_YUV_420_PLANAR;\r\nbreak;\r\ncase I915_OVERLAY_YUV411:\r\ncase I915_OVERLAY_YUV410:\r\ncmd |= OCMD_YUV_410_PLANAR;\r\nbreak;\r\n}\r\n} else {\r\nswitch (params->format & I915_OVERLAY_DEPTH_MASK) {\r\ncase I915_OVERLAY_YUV422:\r\ncmd |= OCMD_YUV_422_PACKED;\r\nbreak;\r\ncase I915_OVERLAY_YUV411:\r\ncmd |= OCMD_YUV_411_PACKED;\r\nbreak;\r\n}\r\nswitch (params->format & I915_OVERLAY_SWAP_MASK) {\r\ncase I915_OVERLAY_NO_SWAP:\r\nbreak;\r\ncase I915_OVERLAY_UV_SWAP:\r\ncmd |= OCMD_UV_SWAP;\r\nbreak;\r\ncase I915_OVERLAY_Y_SWAP:\r\ncmd |= OCMD_Y_SWAP;\r\nbreak;\r\ncase I915_OVERLAY_Y_AND_UV_SWAP:\r\ncmd |= OCMD_Y_AND_UV_SWAP;\r\nbreak;\r\n}\r\n}\r\nreturn cmd;\r\n}\r\nstatic int intel_overlay_do_put_image(struct intel_overlay *overlay,\r\nstruct drm_i915_gem_object *new_bo,\r\nstruct put_image_params *params)\r\n{\r\nint ret, tmp_width;\r\nstruct overlay_registers *regs;\r\nbool scale_changed = false;\r\nstruct drm_device *dev = overlay->dev;\r\nBUG_ON(!mutex_is_locked(&dev->struct_mutex));\r\nBUG_ON(!mutex_is_locked(&dev->mode_config.mutex));\r\nBUG_ON(!overlay);\r\nret = intel_overlay_release_old_vid(overlay);\r\nif (ret != 0)\r\nreturn ret;\r\nret = i915_gem_object_pin_to_display_plane(new_bo, 0, NULL);\r\nif (ret != 0)\r\nreturn ret;\r\nret = i915_gem_object_put_fence(new_bo);\r\nif (ret)\r\ngoto out_unpin;\r\nif (!overlay->active) {\r\nregs = intel_overlay_map_regs(overlay);\r\nif (!regs) {\r\nret = -ENOMEM;\r\ngoto out_unpin;\r\n}\r\nregs->OCONFIG = OCONF_CC_OUT_8BIT;\r\nif (IS_GEN4(overlay->dev))\r\nregs->OCONFIG |= OCONF_CSC_MODE_BT709;\r\nregs->OCONFIG |= overlay->crtc->pipe == 0 ?\r\nOCONF_PIPE_A : OCONF_PIPE_B;\r\nintel_overlay_unmap_regs(overlay, regs);\r\nret = intel_overlay_on(overlay);\r\nif (ret != 0)\r\ngoto out_unpin;\r\n}\r\nregs = intel_overlay_map_regs(overlay);\r\nif (!regs) {\r\nret = -ENOMEM;\r\ngoto out_unpin;\r\n}\r\nregs->DWINPOS = (params->dst_y << 16) | params->dst_x;\r\nregs->DWINSZ = (params->dst_h << 16) | params->dst_w;\r\nif (params->format & I915_OVERLAY_YUV_PACKED)\r\ntmp_width = packed_width_bytes(params->format, params->src_w);\r\nelse\r\ntmp_width = params->src_w;\r\nregs->SWIDTH = params->src_w;\r\nregs->SWIDTHSW = calc_swidthsw(overlay->dev,\r\nparams->offset_Y, tmp_width);\r\nregs->SHEIGHT = params->src_h;\r\nregs->OBUF_0Y = new_bo->gtt_offset + params->offset_Y;\r\nregs->OSTRIDE = params->stride_Y;\r\nif (params->format & I915_OVERLAY_YUV_PLANAR) {\r\nint uv_hscale = uv_hsubsampling(params->format);\r\nint uv_vscale = uv_vsubsampling(params->format);\r\nu32 tmp_U, tmp_V;\r\nregs->SWIDTH |= (params->src_w/uv_hscale) << 16;\r\ntmp_U = calc_swidthsw(overlay->dev, params->offset_U,\r\nparams->src_w/uv_hscale);\r\ntmp_V = calc_swidthsw(overlay->dev, params->offset_V,\r\nparams->src_w/uv_hscale);\r\nregs->SWIDTHSW |= max_t(u32, tmp_U, tmp_V) << 16;\r\nregs->SHEIGHT |= (params->src_h/uv_vscale) << 16;\r\nregs->OBUF_0U = new_bo->gtt_offset + params->offset_U;\r\nregs->OBUF_0V = new_bo->gtt_offset + params->offset_V;\r\nregs->OSTRIDE |= params->stride_UV << 16;\r\n}\r\nscale_changed = update_scaling_factors(overlay, regs, params);\r\nupdate_colorkey(overlay, regs);\r\nregs->OCMD = overlay_cmd_reg(params);\r\nintel_overlay_unmap_regs(overlay, regs);\r\nret = intel_overlay_continue(overlay, scale_changed);\r\nif (ret)\r\ngoto out_unpin;\r\noverlay->old_vid_bo = overlay->vid_bo;\r\noverlay->vid_bo = new_bo;\r\nreturn 0;\r\nout_unpin:\r\ni915_gem_object_unpin(new_bo);\r\nreturn ret;\r\n}\r\nint intel_overlay_switch_off(struct intel_overlay *overlay)\r\n{\r\nstruct overlay_registers *regs;\r\nstruct drm_device *dev = overlay->dev;\r\nint ret;\r\nBUG_ON(!mutex_is_locked(&dev->struct_mutex));\r\nBUG_ON(!mutex_is_locked(&dev->mode_config.mutex));\r\nret = intel_overlay_recover_from_interrupt(overlay);\r\nif (ret != 0)\r\nreturn ret;\r\nif (!overlay->active)\r\nreturn 0;\r\nret = intel_overlay_release_old_vid(overlay);\r\nif (ret != 0)\r\nreturn ret;\r\nregs = intel_overlay_map_regs(overlay);\r\nregs->OCMD = 0;\r\nintel_overlay_unmap_regs(overlay, regs);\r\nret = intel_overlay_off(overlay);\r\nif (ret != 0)\r\nreturn ret;\r\nintel_overlay_off_tail(overlay);\r\nreturn 0;\r\n}\r\nstatic int check_overlay_possible_on_crtc(struct intel_overlay *overlay,\r\nstruct intel_crtc *crtc)\r\n{\r\ndrm_i915_private_t *dev_priv = overlay->dev->dev_private;\r\nif (!crtc->active)\r\nreturn -EINVAL;\r\nif (INTEL_INFO(overlay->dev)->gen < 4 &&\r\n(I915_READ(PIPECONF(crtc->pipe)) & (PIPECONF_DOUBLE_WIDE | PIPECONF_ENABLE)) != PIPECONF_ENABLE)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void update_pfit_vscale_ratio(struct intel_overlay *overlay)\r\n{\r\nstruct drm_device *dev = overlay->dev;\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nu32 pfit_control = I915_READ(PFIT_CONTROL);\r\nu32 ratio;\r\nif (INTEL_INFO(dev)->gen >= 4) {\r\nratio = I915_READ(PFIT_PGM_RATIOS) >> PFIT_VERT_SCALE_SHIFT_965;\r\n} else {\r\nif (pfit_control & VERT_AUTO_SCALE)\r\nratio = I915_READ(PFIT_AUTO_RATIOS);\r\nelse\r\nratio = I915_READ(PFIT_PGM_RATIOS);\r\nratio >>= PFIT_VERT_SCALE_SHIFT;\r\n}\r\noverlay->pfit_vscale_ratio = ratio;\r\n}\r\nstatic int check_overlay_dst(struct intel_overlay *overlay,\r\nstruct drm_intel_overlay_put_image *rec)\r\n{\r\nstruct drm_display_mode *mode = &overlay->crtc->base.mode;\r\nif (rec->dst_x < mode->crtc_hdisplay &&\r\nrec->dst_x + rec->dst_width <= mode->crtc_hdisplay &&\r\nrec->dst_y < mode->crtc_vdisplay &&\r\nrec->dst_y + rec->dst_height <= mode->crtc_vdisplay)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int check_overlay_scaling(struct put_image_params *rec)\r\n{\r\nu32 tmp;\r\ntmp = ((rec->src_scan_h << 16) / rec->dst_h) >> 16;\r\nif (tmp > 7)\r\nreturn -EINVAL;\r\ntmp = ((rec->src_scan_w << 16) / rec->dst_w) >> 16;\r\nif (tmp > 7)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int check_overlay_src(struct drm_device *dev,\r\nstruct drm_intel_overlay_put_image *rec,\r\nstruct drm_i915_gem_object *new_bo)\r\n{\r\nint uv_hscale = uv_hsubsampling(rec->flags);\r\nint uv_vscale = uv_vsubsampling(rec->flags);\r\nu32 stride_mask;\r\nint depth;\r\nu32 tmp;\r\nif (IS_845G(dev) || IS_I830(dev)) {\r\nif (rec->src_height > IMAGE_MAX_HEIGHT_LEGACY ||\r\nrec->src_width > IMAGE_MAX_WIDTH_LEGACY)\r\nreturn -EINVAL;\r\n} else {\r\nif (rec->src_height > IMAGE_MAX_HEIGHT ||\r\nrec->src_width > IMAGE_MAX_WIDTH)\r\nreturn -EINVAL;\r\n}\r\nif (rec->src_height < N_VERT_Y_TAPS*4 ||\r\nrec->src_width < N_HORIZ_Y_TAPS*4)\r\nreturn -EINVAL;\r\nswitch (rec->flags & I915_OVERLAY_TYPE_MASK) {\r\ncase I915_OVERLAY_RGB:\r\nreturn -EINVAL;\r\ncase I915_OVERLAY_YUV_PACKED:\r\nif (uv_vscale != 1)\r\nreturn -EINVAL;\r\ndepth = packed_depth_bytes(rec->flags);\r\nif (depth < 0)\r\nreturn depth;\r\nrec->stride_UV = 0;\r\nrec->offset_U = 0;\r\nrec->offset_V = 0;\r\nif (rec->offset_Y % depth)\r\nreturn -EINVAL;\r\nbreak;\r\ncase I915_OVERLAY_YUV_PLANAR:\r\nif (uv_vscale < 0 || uv_hscale < 0)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (rec->src_width % uv_hscale)\r\nreturn -EINVAL;\r\nif (IS_I830(dev) || IS_845G(dev))\r\nstride_mask = 255;\r\nelse\r\nstride_mask = 63;\r\nif (rec->stride_Y & stride_mask || rec->stride_UV & stride_mask)\r\nreturn -EINVAL;\r\nif (IS_GEN4(dev) && rec->stride_Y < 512)\r\nreturn -EINVAL;\r\ntmp = (rec->flags & I915_OVERLAY_TYPE_MASK) == I915_OVERLAY_YUV_PLANAR ?\r\n4096 : 8192;\r\nif (rec->stride_Y > tmp || rec->stride_UV > 2*1024)\r\nreturn -EINVAL;\r\nswitch (rec->flags & I915_OVERLAY_TYPE_MASK) {\r\ncase I915_OVERLAY_RGB:\r\ncase I915_OVERLAY_YUV_PACKED:\r\nif (packed_width_bytes(rec->flags, rec->src_width) > rec->stride_Y)\r\nreturn -EINVAL;\r\ntmp = rec->stride_Y*rec->src_height;\r\nif (rec->offset_Y + tmp > new_bo->base.size)\r\nreturn -EINVAL;\r\nbreak;\r\ncase I915_OVERLAY_YUV_PLANAR:\r\nif (rec->src_width > rec->stride_Y)\r\nreturn -EINVAL;\r\nif (rec->src_width/uv_hscale > rec->stride_UV)\r\nreturn -EINVAL;\r\ntmp = rec->stride_Y * rec->src_height;\r\nif (rec->offset_Y + tmp > new_bo->base.size)\r\nreturn -EINVAL;\r\ntmp = rec->stride_UV * (rec->src_height / uv_vscale);\r\nif (rec->offset_U + tmp > new_bo->base.size ||\r\nrec->offset_V + tmp > new_bo->base.size)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int intel_panel_fitter_pipe(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nu32 pfit_control;\r\nif (IS_I830(dev))\r\nreturn -1;\r\npfit_control = I915_READ(PFIT_CONTROL);\r\nif ((pfit_control & PFIT_ENABLE) == 0)\r\nreturn -1;\r\nif (IS_GEN4(dev))\r\nreturn (pfit_control >> 29) & 0x3;\r\nreturn 1;\r\n}\r\nint intel_overlay_put_image(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_intel_overlay_put_image *put_image_rec = data;\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nstruct intel_overlay *overlay;\r\nstruct drm_mode_object *drmmode_obj;\r\nstruct intel_crtc *crtc;\r\nstruct drm_i915_gem_object *new_bo;\r\nstruct put_image_params *params;\r\nint ret;\r\nif (!dev_priv) {\r\nDRM_ERROR("called with no initialization\n");\r\nreturn -EINVAL;\r\n}\r\noverlay = dev_priv->overlay;\r\nif (!overlay) {\r\nDRM_DEBUG("userspace bug: no overlay\n");\r\nreturn -ENODEV;\r\n}\r\nif (!(put_image_rec->flags & I915_OVERLAY_ENABLE)) {\r\nmutex_lock(&dev->mode_config.mutex);\r\nmutex_lock(&dev->struct_mutex);\r\nret = intel_overlay_switch_off(overlay);\r\nmutex_unlock(&dev->struct_mutex);\r\nmutex_unlock(&dev->mode_config.mutex);\r\nreturn ret;\r\n}\r\nparams = kmalloc(sizeof(struct put_image_params), GFP_KERNEL);\r\nif (!params)\r\nreturn -ENOMEM;\r\ndrmmode_obj = drm_mode_object_find(dev, put_image_rec->crtc_id,\r\nDRM_MODE_OBJECT_CRTC);\r\nif (!drmmode_obj) {\r\nret = -ENOENT;\r\ngoto out_free;\r\n}\r\ncrtc = to_intel_crtc(obj_to_crtc(drmmode_obj));\r\nnew_bo = to_intel_bo(drm_gem_object_lookup(dev, file_priv,\r\nput_image_rec->bo_handle));\r\nif (&new_bo->base == NULL) {\r\nret = -ENOENT;\r\ngoto out_free;\r\n}\r\nmutex_lock(&dev->mode_config.mutex);\r\nmutex_lock(&dev->struct_mutex);\r\nif (new_bo->tiling_mode) {\r\nDRM_ERROR("buffer used for overlay image can not be tiled\n");\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nret = intel_overlay_recover_from_interrupt(overlay);\r\nif (ret != 0)\r\ngoto out_unlock;\r\nif (overlay->crtc != crtc) {\r\nstruct drm_display_mode *mode = &crtc->base.mode;\r\nret = intel_overlay_switch_off(overlay);\r\nif (ret != 0)\r\ngoto out_unlock;\r\nret = check_overlay_possible_on_crtc(overlay, crtc);\r\nif (ret != 0)\r\ngoto out_unlock;\r\noverlay->crtc = crtc;\r\ncrtc->overlay = overlay;\r\nif (mode->hdisplay > 1024 &&\r\nintel_panel_fitter_pipe(dev) == crtc->pipe) {\r\noverlay->pfit_active = 1;\r\nupdate_pfit_vscale_ratio(overlay);\r\n} else\r\noverlay->pfit_active = 0;\r\n}\r\nret = check_overlay_dst(overlay, put_image_rec);\r\nif (ret != 0)\r\ngoto out_unlock;\r\nif (overlay->pfit_active) {\r\nparams->dst_y = ((((u32)put_image_rec->dst_y) << 12) /\r\noverlay->pfit_vscale_ratio);\r\nparams->dst_h = ((((u32)put_image_rec->dst_height) << 12) /\r\noverlay->pfit_vscale_ratio) + 1;\r\n} else {\r\nparams->dst_y = put_image_rec->dst_y;\r\nparams->dst_h = put_image_rec->dst_height;\r\n}\r\nparams->dst_x = put_image_rec->dst_x;\r\nparams->dst_w = put_image_rec->dst_width;\r\nparams->src_w = put_image_rec->src_width;\r\nparams->src_h = put_image_rec->src_height;\r\nparams->src_scan_w = put_image_rec->src_scan_width;\r\nparams->src_scan_h = put_image_rec->src_scan_height;\r\nif (params->src_scan_h > params->src_h ||\r\nparams->src_scan_w > params->src_w) {\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nret = check_overlay_src(dev, put_image_rec, new_bo);\r\nif (ret != 0)\r\ngoto out_unlock;\r\nparams->format = put_image_rec->flags & ~I915_OVERLAY_FLAGS_MASK;\r\nparams->stride_Y = put_image_rec->stride_Y;\r\nparams->stride_UV = put_image_rec->stride_UV;\r\nparams->offset_Y = put_image_rec->offset_Y;\r\nparams->offset_U = put_image_rec->offset_U;\r\nparams->offset_V = put_image_rec->offset_V;\r\nret = check_overlay_scaling(params);\r\nif (ret != 0)\r\ngoto out_unlock;\r\nret = intel_overlay_do_put_image(overlay, new_bo, params);\r\nif (ret != 0)\r\ngoto out_unlock;\r\nmutex_unlock(&dev->struct_mutex);\r\nmutex_unlock(&dev->mode_config.mutex);\r\nkfree(params);\r\nreturn 0;\r\nout_unlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nmutex_unlock(&dev->mode_config.mutex);\r\ndrm_gem_object_unreference_unlocked(&new_bo->base);\r\nout_free:\r\nkfree(params);\r\nreturn ret;\r\n}\r\nstatic void update_reg_attrs(struct intel_overlay *overlay,\r\nstruct overlay_registers *regs)\r\n{\r\nregs->OCLRC0 = (overlay->contrast << 18) | (overlay->brightness & 0xff);\r\nregs->OCLRC1 = overlay->saturation;\r\n}\r\nstatic bool check_gamma_bounds(u32 gamma1, u32 gamma2)\r\n{\r\nint i;\r\nif (gamma1 & 0xff000000 || gamma2 & 0xff000000)\r\nreturn false;\r\nfor (i = 0; i < 3; i++) {\r\nif (((gamma1 >> i*8) & 0xff) >= ((gamma2 >> i*8) & 0xff))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool check_gamma5_errata(u32 gamma5)\r\n{\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nif (((gamma5 >> i*8) & 0xff) == 0x80)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int check_gamma(struct drm_intel_overlay_attrs *attrs)\r\n{\r\nif (!check_gamma_bounds(0, attrs->gamma0) ||\r\n!check_gamma_bounds(attrs->gamma0, attrs->gamma1) ||\r\n!check_gamma_bounds(attrs->gamma1, attrs->gamma2) ||\r\n!check_gamma_bounds(attrs->gamma2, attrs->gamma3) ||\r\n!check_gamma_bounds(attrs->gamma3, attrs->gamma4) ||\r\n!check_gamma_bounds(attrs->gamma4, attrs->gamma5) ||\r\n!check_gamma_bounds(attrs->gamma5, 0x00ffffff))\r\nreturn -EINVAL;\r\nif (!check_gamma5_errata(attrs->gamma5))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint intel_overlay_attrs(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_intel_overlay_attrs *attrs = data;\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nstruct intel_overlay *overlay;\r\nstruct overlay_registers *regs;\r\nint ret;\r\nif (!dev_priv) {\r\nDRM_ERROR("called with no initialization\n");\r\nreturn -EINVAL;\r\n}\r\noverlay = dev_priv->overlay;\r\nif (!overlay) {\r\nDRM_DEBUG("userspace bug: no overlay\n");\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&dev->mode_config.mutex);\r\nmutex_lock(&dev->struct_mutex);\r\nret = -EINVAL;\r\nif (!(attrs->flags & I915_OVERLAY_UPDATE_ATTRS)) {\r\nattrs->color_key = overlay->color_key;\r\nattrs->brightness = overlay->brightness;\r\nattrs->contrast = overlay->contrast;\r\nattrs->saturation = overlay->saturation;\r\nif (!IS_GEN2(dev)) {\r\nattrs->gamma0 = I915_READ(OGAMC0);\r\nattrs->gamma1 = I915_READ(OGAMC1);\r\nattrs->gamma2 = I915_READ(OGAMC2);\r\nattrs->gamma3 = I915_READ(OGAMC3);\r\nattrs->gamma4 = I915_READ(OGAMC4);\r\nattrs->gamma5 = I915_READ(OGAMC5);\r\n}\r\n} else {\r\nif (attrs->brightness < -128 || attrs->brightness > 127)\r\ngoto out_unlock;\r\nif (attrs->contrast > 255)\r\ngoto out_unlock;\r\nif (attrs->saturation > 1023)\r\ngoto out_unlock;\r\noverlay->color_key = attrs->color_key;\r\noverlay->brightness = attrs->brightness;\r\noverlay->contrast = attrs->contrast;\r\noverlay->saturation = attrs->saturation;\r\nregs = intel_overlay_map_regs(overlay);\r\nif (!regs) {\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nupdate_reg_attrs(overlay, regs);\r\nintel_overlay_unmap_regs(overlay, regs);\r\nif (attrs->flags & I915_OVERLAY_UPDATE_GAMMA) {\r\nif (IS_GEN2(dev))\r\ngoto out_unlock;\r\nif (overlay->active) {\r\nret = -EBUSY;\r\ngoto out_unlock;\r\n}\r\nret = check_gamma(attrs);\r\nif (ret)\r\ngoto out_unlock;\r\nI915_WRITE(OGAMC0, attrs->gamma0);\r\nI915_WRITE(OGAMC1, attrs->gamma1);\r\nI915_WRITE(OGAMC2, attrs->gamma2);\r\nI915_WRITE(OGAMC3, attrs->gamma3);\r\nI915_WRITE(OGAMC4, attrs->gamma4);\r\nI915_WRITE(OGAMC5, attrs->gamma5);\r\n}\r\n}\r\nret = 0;\r\nout_unlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nmutex_unlock(&dev->mode_config.mutex);\r\nreturn ret;\r\n}\r\nvoid intel_setup_overlay(struct drm_device *dev)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nstruct intel_overlay *overlay;\r\nstruct drm_i915_gem_object *reg_bo;\r\nstruct overlay_registers *regs;\r\nint ret;\r\nif (!HAS_OVERLAY(dev))\r\nreturn;\r\noverlay = kzalloc(sizeof(struct intel_overlay), GFP_KERNEL);\r\nif (!overlay)\r\nreturn;\r\nmutex_lock(&dev->struct_mutex);\r\nif (WARN_ON(dev_priv->overlay))\r\ngoto out_free;\r\noverlay->dev = dev;\r\nreg_bo = i915_gem_alloc_object(dev, PAGE_SIZE);\r\nif (!reg_bo)\r\ngoto out_free;\r\noverlay->reg_bo = reg_bo;\r\nif (OVERLAY_NEEDS_PHYSICAL(dev)) {\r\nret = i915_gem_attach_phys_object(dev, reg_bo,\r\nI915_GEM_PHYS_OVERLAY_REGS,\r\nPAGE_SIZE);\r\nif (ret) {\r\nDRM_ERROR("failed to attach phys overlay regs\n");\r\ngoto out_free_bo;\r\n}\r\noverlay->flip_addr = reg_bo->phys_obj->handle->busaddr;\r\n} else {\r\nret = i915_gem_object_pin(reg_bo, PAGE_SIZE, true);\r\nif (ret) {\r\nDRM_ERROR("failed to pin overlay register bo\n");\r\ngoto out_free_bo;\r\n}\r\noverlay->flip_addr = reg_bo->gtt_offset;\r\nret = i915_gem_object_set_to_gtt_domain(reg_bo, true);\r\nif (ret) {\r\nDRM_ERROR("failed to move overlay register bo into the GTT\n");\r\ngoto out_unpin_bo;\r\n}\r\n}\r\noverlay->color_key = 0x0101fe;\r\noverlay->brightness = -19;\r\noverlay->contrast = 75;\r\noverlay->saturation = 146;\r\nregs = intel_overlay_map_regs(overlay);\r\nif (!regs)\r\ngoto out_unpin_bo;\r\nmemset(regs, 0, sizeof(struct overlay_registers));\r\nupdate_polyphase_filter(regs);\r\nupdate_reg_attrs(overlay, regs);\r\nintel_overlay_unmap_regs(overlay, regs);\r\ndev_priv->overlay = overlay;\r\nmutex_unlock(&dev->struct_mutex);\r\nDRM_INFO("initialized overlay support\n");\r\nreturn;\r\nout_unpin_bo:\r\nif (!OVERLAY_NEEDS_PHYSICAL(dev))\r\ni915_gem_object_unpin(reg_bo);\r\nout_free_bo:\r\ndrm_gem_object_unreference(&reg_bo->base);\r\nout_free:\r\nmutex_unlock(&dev->struct_mutex);\r\nkfree(overlay);\r\nreturn;\r\n}\r\nvoid intel_cleanup_overlay(struct drm_device *dev)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nif (!dev_priv->overlay)\r\nreturn;\r\nBUG_ON(dev_priv->overlay->active);\r\ndrm_gem_object_unreference_unlocked(&dev_priv->overlay->reg_bo->base);\r\nkfree(dev_priv->overlay);\r\n}\r\nstatic struct overlay_registers *\r\nintel_overlay_map_regs_atomic(struct intel_overlay *overlay)\r\n{\r\ndrm_i915_private_t *dev_priv = overlay->dev->dev_private;\r\nstruct overlay_registers *regs;\r\nif (OVERLAY_NEEDS_PHYSICAL(overlay->dev))\r\nregs = overlay->reg_bo->phys_obj->handle->vaddr;\r\nelse\r\nregs = io_mapping_map_atomic_wc(dev_priv->mm.gtt_mapping,\r\noverlay->reg_bo->gtt_offset);\r\nreturn regs;\r\n}\r\nstatic void intel_overlay_unmap_regs_atomic(struct intel_overlay *overlay,\r\nstruct overlay_registers *regs)\r\n{\r\nif (!OVERLAY_NEEDS_PHYSICAL(overlay->dev))\r\nio_mapping_unmap_atomic(regs);\r\n}\r\nstruct intel_overlay_error_state *\r\nintel_overlay_capture_error_state(struct drm_device *dev)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nstruct intel_overlay *overlay = dev_priv->overlay;\r\nstruct intel_overlay_error_state *error;\r\nstruct overlay_registers __iomem *regs;\r\nif (!overlay || !overlay->active)\r\nreturn NULL;\r\nerror = kmalloc(sizeof(*error), GFP_ATOMIC);\r\nif (error == NULL)\r\nreturn NULL;\r\nerror->dovsta = I915_READ(DOVSTA);\r\nerror->isr = I915_READ(ISR);\r\nif (OVERLAY_NEEDS_PHYSICAL(overlay->dev))\r\nerror->base = (long) overlay->reg_bo->phys_obj->handle->vaddr;\r\nelse\r\nerror->base = (long) overlay->reg_bo->gtt_offset;\r\nregs = intel_overlay_map_regs_atomic(overlay);\r\nif (!regs)\r\ngoto err;\r\nmemcpy_fromio(&error->regs, regs, sizeof(struct overlay_registers));\r\nintel_overlay_unmap_regs_atomic(overlay, regs);\r\nreturn error;\r\nerr:\r\nkfree(error);\r\nreturn NULL;\r\n}\r\nvoid\r\nintel_overlay_print_error_state(struct seq_file *m, struct intel_overlay_error_state *error)\r\n{\r\nseq_printf(m, "Overlay, status: 0x%08x, interrupt: 0x%08x\n",\r\nerror->dovsta, error->isr);\r\nseq_printf(m, " Register file at 0x%08lx:\n",\r\nerror->base);\r\n#define P(x) seq_printf(m, " " #x ": 0x%08x\n", error->regs.x)\r\nP(OBUF_0Y);\r\nP(OBUF_1Y);\r\nP(OBUF_0U);\r\nP(OBUF_0V);\r\nP(OBUF_1U);\r\nP(OBUF_1V);\r\nP(OSTRIDE);\r\nP(YRGB_VPH);\r\nP(UV_VPH);\r\nP(HORZ_PH);\r\nP(INIT_PHS);\r\nP(DWINPOS);\r\nP(DWINSZ);\r\nP(SWIDTH);\r\nP(SWIDTHSW);\r\nP(SHEIGHT);\r\nP(YRGBSCALE);\r\nP(UVSCALE);\r\nP(OCLRC0);\r\nP(OCLRC1);\r\nP(DCLRKV);\r\nP(DCLRKM);\r\nP(SCLRKVH);\r\nP(SCLRKVL);\r\nP(SCLRKEN);\r\nP(OCONFIG);\r\nP(OCMD);\r\nP(OSTART_0Y);\r\nP(OSTART_1Y);\r\nP(OSTART_0U);\r\nP(OSTART_0V);\r\nP(OSTART_1U);\r\nP(OSTART_1V);\r\nP(OTILEOFF_0Y);\r\nP(OTILEOFF_1Y);\r\nP(OTILEOFF_0U);\r\nP(OTILEOFF_0V);\r\nP(OTILEOFF_1U);\r\nP(OTILEOFF_1V);\r\nP(FASTHSCALE);\r\nP(UVSCALEV);\r\n#undef P\r\n}
