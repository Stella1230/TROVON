static int\r\nsrmcons_do_receive_chars(struct tty_struct *tty)\r\n{\r\nsrmcons_result result;\r\nint count = 0, loops = 0;\r\ndo {\r\nresult.as_long = callback_getc(0);\r\nif (result.bits.status < 2) {\r\ntty_insert_flip_char(tty, (char)result.bits.c, 0);\r\ncount++;\r\n}\r\n} while((result.bits.status & 1) && (++loops < 10));\r\nif (count)\r\ntty_schedule_flip(tty);\r\nreturn count;\r\n}\r\nstatic void\r\nsrmcons_receive_chars(unsigned long data)\r\n{\r\nstruct srmcons_private *srmconsp = (struct srmcons_private *)data;\r\nunsigned long flags;\r\nint incr = 10;\r\nlocal_irq_save(flags);\r\nif (spin_trylock(&srmcons_callback_lock)) {\r\nif (!srmcons_do_receive_chars(srmconsp->tty))\r\nincr = 100;\r\nspin_unlock(&srmcons_callback_lock);\r\n}\r\nspin_lock(&srmconsp->lock);\r\nif (srmconsp->tty) {\r\nsrmconsp->timer.expires = jiffies + incr;\r\nadd_timer(&srmconsp->timer);\r\n}\r\nspin_unlock(&srmconsp->lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int\r\nsrmcons_do_write(struct tty_struct *tty, const char *buf, int count)\r\n{\r\nstatic char str_cr[1] = "\r";\r\nlong c, remaining = count;\r\nsrmcons_result result;\r\nchar *cur;\r\nint need_cr;\r\nfor (cur = (char *)buf; remaining > 0; ) {\r\nneed_cr = 0;\r\nfor (c = 0; c < min_t(long, 128L, remaining) && !need_cr; c++)\r\nif (cur[c] == '\n')\r\nneed_cr = 1;\r\nwhile (c > 0) {\r\nresult.as_long = callback_puts(0, cur, c);\r\nc -= result.bits.c;\r\nremaining -= result.bits.c;\r\ncur += result.bits.c;\r\nif (tty)\r\nsrmcons_do_receive_chars(tty);\r\n}\r\nwhile (need_cr) {\r\nresult.as_long = callback_puts(0, str_cr, 1);\r\nif (result.bits.c > 0)\r\nneed_cr = 0;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic int\r\nsrmcons_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&srmcons_callback_lock, flags);\r\nsrmcons_do_write(tty, (const char *) buf, count);\r\nspin_unlock_irqrestore(&srmcons_callback_lock, flags);\r\nreturn count;\r\n}\r\nstatic int\r\nsrmcons_write_room(struct tty_struct *tty)\r\n{\r\nreturn 512;\r\n}\r\nstatic int\r\nsrmcons_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\nsrmcons_get_private_struct(struct srmcons_private **ps)\r\n{\r\nstatic struct srmcons_private *srmconsp = NULL;\r\nstatic DEFINE_SPINLOCK(srmconsp_lock);\r\nunsigned long flags;\r\nint retval = 0;\r\nif (srmconsp == NULL) {\r\nsrmconsp = kmalloc(sizeof(*srmconsp), GFP_KERNEL);\r\nspin_lock_irqsave(&srmconsp_lock, flags);\r\nif (srmconsp == NULL)\r\nretval = -ENOMEM;\r\nelse {\r\nsrmconsp->tty = NULL;\r\nspin_lock_init(&srmconsp->lock);\r\ninit_timer(&srmconsp->timer);\r\n}\r\nspin_unlock_irqrestore(&srmconsp_lock, flags);\r\n}\r\n*ps = srmconsp;\r\nreturn retval;\r\n}\r\nstatic int\r\nsrmcons_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct srmcons_private *srmconsp;\r\nunsigned long flags;\r\nint retval;\r\nretval = srmcons_get_private_struct(&srmconsp);\r\nif (retval)\r\nreturn retval;\r\nspin_lock_irqsave(&srmconsp->lock, flags);\r\nif (!srmconsp->tty) {\r\ntty->driver_data = srmconsp;\r\nsrmconsp->tty = tty;\r\nsrmconsp->timer.function = srmcons_receive_chars;\r\nsrmconsp->timer.data = (unsigned long)srmconsp;\r\nsrmconsp->timer.expires = jiffies + 10;\r\nadd_timer(&srmconsp->timer);\r\n}\r\nspin_unlock_irqrestore(&srmconsp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void\r\nsrmcons_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct srmcons_private *srmconsp = tty->driver_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&srmconsp->lock, flags);\r\nif (tty->count == 1) {\r\nsrmconsp->tty = NULL;\r\ndel_timer(&srmconsp->timer);\r\n}\r\nspin_unlock_irqrestore(&srmconsp->lock, flags);\r\n}\r\nstatic int __init\r\nsrmcons_init(void)\r\n{\r\nif (srm_is_registered_console) {\r\nstruct tty_driver *driver;\r\nint err;\r\ndriver = alloc_tty_driver(MAX_SRM_CONSOLE_DEVICES);\r\nif (!driver)\r\nreturn -ENOMEM;\r\ndriver->driver_name = "srm";\r\ndriver->name = "srm";\r\ndriver->major = 0;\r\ndriver->minor_start = 0;\r\ndriver->type = TTY_DRIVER_TYPE_SYSTEM;\r\ndriver->subtype = SYSTEM_TYPE_SYSCONS;\r\ndriver->init_termios = tty_std_termios;\r\ntty_set_operations(driver, &srmcons_ops);\r\nerr = tty_register_driver(driver);\r\nif (err) {\r\nput_tty_driver(driver);\r\nreturn err;\r\n}\r\nsrmcons_driver = driver;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void\r\nsrm_console_write(struct console *co, const char *s, unsigned count)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&srmcons_callback_lock, flags);\r\nsrmcons_do_write(NULL, s, count);\r\nspin_unlock_irqrestore(&srmcons_callback_lock, flags);\r\n}\r\nstatic struct tty_driver *\r\nsrm_console_device(struct console *co, int *index)\r\n{\r\n*index = co->index;\r\nreturn srmcons_driver;\r\n}\r\nstatic int\r\nsrm_console_setup(struct console *co, char *options)\r\n{\r\nreturn 0;\r\n}\r\nvoid __init\r\nregister_srm_console(void)\r\n{\r\nif (!srm_is_registered_console) {\r\ncallback_open_console();\r\nregister_console(&srmcons);\r\nsrm_is_registered_console = 1;\r\n}\r\n}\r\nvoid __init\r\nunregister_srm_console(void)\r\n{\r\nif (srm_is_registered_console) {\r\ncallback_close_console();\r\nunregister_console(&srmcons);\r\nsrm_is_registered_console = 0;\r\n}\r\n}
