static int snt_poll_getc(void)\r\n{\r\nint ch;\r\nia64_sn_console_getc(&ch);\r\nreturn ch;\r\n}\r\nstatic int snt_poll_input_pending(void)\r\n{\r\nint status, input;\r\nstatus = ia64_sn_console_check(&input);\r\nreturn !status && input;\r\n}\r\nstatic int snt_intr_getc(void)\r\n{\r\nreturn ia64_sn_console_readc();\r\n}\r\nstatic int snt_intr_input_pending(void)\r\n{\r\nreturn ia64_sn_console_intr_status() & SAL_CONSOLE_INTR_RECV;\r\n}\r\nstatic int snt_hw_puts_raw(const char *s, int len)\r\n{\r\nreturn ia64_sn_console_putb(s, len);\r\n}\r\nstatic int snt_hw_puts_buffered(const char *s, int len)\r\n{\r\nreturn ia64_sn_console_xmit_chars((char *)s, len);\r\n}\r\nstatic const char *snp_type(struct uart_port *port)\r\n{\r\nreturn ("SGI SN L1");\r\n}\r\nstatic unsigned int snp_tx_empty(struct uart_port *port)\r\n{\r\nreturn 1;\r\n}\r\nstatic void snp_stop_tx(struct uart_port *port)\r\n{\r\n}\r\nstatic void snp_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic void snp_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic void snp_shutdown(struct uart_port *port)\r\n{\r\n}\r\nstatic void snp_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic unsigned int snp_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CAR | TIOCM_RNG | TIOCM_DSR | TIOCM_CTS;\r\n}\r\nstatic void snp_stop_rx(struct uart_port *port)\r\n{\r\n}\r\nstatic void snp_start_tx(struct uart_port *port)\r\n{\r\nif (sal_console_port.sc_ops->sal_wakeup_transmit)\r\nsal_console_port.sc_ops->sal_wakeup_transmit(&sal_console_port,\r\nTRANSMIT_BUFFERED);\r\n}\r\nstatic void snp_break_ctl(struct uart_port *port, int break_state)\r\n{\r\n}\r\nstatic int snp_startup(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\nsnp_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\n}\r\nstatic int snp_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void snp_config_port(struct uart_port *port, int flags)\r\n{\r\n}\r\nstatic int sn_debug_printf(const char *fmt, ...)\r\n{\r\nstatic char printk_buf[1024];\r\nint printed_len;\r\nva_list args;\r\nva_start(args, fmt);\r\nprinted_len = vsnprintf(printk_buf, sizeof(printk_buf), fmt, args);\r\nif (!sal_console_port.sc_ops) {\r\nsal_console_port.sc_ops = &poll_ops;\r\nearly_sn_setup();\r\n}\r\nsal_console_port.sc_ops->sal_puts_raw(printk_buf, printed_len);\r\nva_end(args);\r\nreturn printed_len;\r\n}\r\nstatic void\r\nsn_receive_chars(struct sn_cons_port *port, unsigned long flags)\r\n{\r\nint ch;\r\nstruct tty_struct *tty;\r\nif (!port) {\r\nprintk(KERN_ERR "sn_receive_chars - port NULL so can't receieve\n");\r\nreturn;\r\n}\r\nif (!port->sc_ops) {\r\nprintk(KERN_ERR "sn_receive_chars - port->sc_ops NULL so can't receieve\n");\r\nreturn;\r\n}\r\nif (port->sc_port.state) {\r\ntty = port->sc_port.state->port.tty;\r\n}\r\nelse {\r\ntty = NULL;\r\n}\r\nwhile (port->sc_ops->sal_input_pending()) {\r\nch = port->sc_ops->sal_getc();\r\nif (ch < 0) {\r\nprintk(KERN_ERR "sn_console: An error occurred while "\r\n"obtaining data from the console (0x%0x)\n", ch);\r\nbreak;\r\n}\r\n#ifdef CONFIG_MAGIC_SYSRQ\r\nif (sysrq_requested) {\r\nunsigned long sysrq_timeout = sysrq_requested + HZ*5;\r\nsysrq_requested = 0;\r\nif (ch && time_before(jiffies, sysrq_timeout)) {\r\nspin_unlock_irqrestore(&port->sc_port.lock, flags);\r\nhandle_sysrq(ch);\r\nspin_lock_irqsave(&port->sc_port.lock, flags);\r\ncontinue;\r\n}\r\n}\r\nif (ch == *sysrq_serial_ptr) {\r\nif (!(*++sysrq_serial_ptr)) {\r\nsysrq_requested = jiffies;\r\nsysrq_serial_ptr = sysrq_serial_str;\r\n}\r\nif (ch != '\e')\r\ncontinue;\r\n}\r\nelse\r\nsysrq_serial_ptr = sysrq_serial_str;\r\n#endif\r\nif (tty) {\r\nif(tty_insert_flip_char(tty, ch, TTY_NORMAL) == 0)\r\nbreak;\r\n}\r\nport->sc_port.icount.rx++;\r\n}\r\nif (tty)\r\ntty_flip_buffer_push(tty);\r\n}\r\nstatic void sn_transmit_chars(struct sn_cons_port *port, int raw)\r\n{\r\nint xmit_count, tail, head, loops, ii;\r\nint result;\r\nchar *start;\r\nstruct circ_buf *xmit;\r\nif (!port)\r\nreturn;\r\nBUG_ON(!port->sc_is_asynch);\r\nif (port->sc_port.state) {\r\nxmit = &port->sc_port.state->xmit;\r\n} else {\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&port->sc_port)) {\r\nia64_sn_console_intr_disable(SAL_CONSOLE_INTR_XMIT);\r\nreturn;\r\n}\r\nhead = xmit->head;\r\ntail = xmit->tail;\r\nstart = &xmit->buf[tail];\r\nloops = (head < tail) ? 2 : 1;\r\nfor (ii = 0; ii < loops; ii++) {\r\nxmit_count = (head < tail) ?\r\n(UART_XMIT_SIZE - tail) : (head - tail);\r\nif (xmit_count > 0) {\r\nif (raw == TRANSMIT_RAW)\r\nresult =\r\nport->sc_ops->sal_puts_raw(start,\r\nxmit_count);\r\nelse\r\nresult =\r\nport->sc_ops->sal_puts(start, xmit_count);\r\n#ifdef DEBUG\r\nif (!result)\r\nDPRINTF("`");\r\n#endif\r\nif (result > 0) {\r\nxmit_count -= result;\r\nport->sc_port.icount.tx += result;\r\ntail += result;\r\ntail &= UART_XMIT_SIZE - 1;\r\nxmit->tail = tail;\r\nstart = &xmit->buf[tail];\r\n}\r\n}\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&port->sc_port);\r\nif (uart_circ_empty(xmit))\r\nsnp_stop_tx(&port->sc_port);\r\n}\r\nstatic irqreturn_t sn_sal_interrupt(int irq, void *dev_id)\r\n{\r\nstruct sn_cons_port *port = (struct sn_cons_port *)dev_id;\r\nunsigned long flags;\r\nint status = ia64_sn_console_intr_status();\r\nif (!port)\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&port->sc_port.lock, flags);\r\nif (status & SAL_CONSOLE_INTR_RECV) {\r\nsn_receive_chars(port, flags);\r\n}\r\nif (status & SAL_CONSOLE_INTR_XMIT) {\r\nsn_transmit_chars(port, TRANSMIT_BUFFERED);\r\n}\r\nspin_unlock_irqrestore(&port->sc_port.lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sn_sal_timer_poll(unsigned long data)\r\n{\r\nstruct sn_cons_port *port = (struct sn_cons_port *)data;\r\nunsigned long flags;\r\nif (!port)\r\nreturn;\r\nif (!port->sc_port.irq) {\r\nspin_lock_irqsave(&port->sc_port.lock, flags);\r\nif (sn_process_input)\r\nsn_receive_chars(port, flags);\r\nsn_transmit_chars(port, TRANSMIT_RAW);\r\nspin_unlock_irqrestore(&port->sc_port.lock, flags);\r\nmod_timer(&port->sc_timer,\r\njiffies + port->sc_interrupt_timeout);\r\n}\r\n}\r\nstatic void __init sn_sal_switch_to_asynch(struct sn_cons_port *port)\r\n{\r\nunsigned long flags;\r\nif (!port)\r\nreturn;\r\nDPRINTF("sn_console: about to switch to asynchronous console\n");\r\nspin_lock_irqsave(&port->sc_port.lock, flags);\r\nif (!port->sc_ops)\r\nport->sc_ops = &poll_ops;\r\ninit_timer(&port->sc_timer);\r\nport->sc_timer.function = sn_sal_timer_poll;\r\nport->sc_timer.data = (unsigned long)port;\r\nif (IS_RUNNING_ON_SIMULATOR())\r\nport->sc_interrupt_timeout = 6;\r\nelse {\r\nport->sc_interrupt_timeout =\r\nHZ * SN_SAL_UART_FIFO_DEPTH / SN_SAL_UART_FIFO_SPEED_CPS;\r\n}\r\nmod_timer(&port->sc_timer, jiffies + port->sc_interrupt_timeout);\r\nport->sc_is_asynch = 1;\r\nspin_unlock_irqrestore(&port->sc_port.lock, flags);\r\n}\r\nstatic void __init sn_sal_switch_to_interrupts(struct sn_cons_port *port)\r\n{\r\nunsigned long flags;\r\nif (port) {\r\nDPRINTF("sn_console: switching to interrupt driven console\n");\r\nif (request_irq(SGI_UART_VECTOR, sn_sal_interrupt,\r\nIRQF_SHARED,\r\n"SAL console driver", port) >= 0) {\r\nspin_lock_irqsave(&port->sc_port.lock, flags);\r\nport->sc_port.irq = SGI_UART_VECTOR;\r\nport->sc_ops = &intr_ops;\r\nia64_sn_console_intr_enable(SAL_CONSOLE_INTR_RECV);\r\nspin_unlock_irqrestore(&port->sc_port.lock, flags);\r\n}\r\nelse {\r\nprintk(KERN_INFO\r\n"sn_console: console proceeding in polled mode\n");\r\n}\r\n}\r\n}\r\nstatic int __init sn_sal_module_init(void)\r\n{\r\nint retval;\r\nif (!ia64_platform_is("sn2"))\r\nreturn 0;\r\nprintk(KERN_INFO "sn_console: Console driver init\n");\r\nif (USE_DYNAMIC_MINOR == 1) {\r\nmisc.minor = MISC_DYNAMIC_MINOR;\r\nmisc.name = DEVICE_NAME_DYNAMIC;\r\nretval = misc_register(&misc);\r\nif (retval != 0) {\r\nprintk(KERN_WARNING "Failed to register console "\r\n"device using misc_register.\n");\r\nreturn -ENODEV;\r\n}\r\nsal_console_uart.major = MISC_MAJOR;\r\nsal_console_uart.minor = misc.minor;\r\n} else {\r\nsal_console_uart.major = DEVICE_MAJOR;\r\nsal_console_uart.minor = DEVICE_MINOR;\r\n}\r\nif (uart_register_driver(&sal_console_uart) < 0) {\r\nprintk\r\n("ERROR sn_sal_module_init failed uart_register_driver, line %d\n",\r\n__LINE__);\r\nreturn -ENODEV;\r\n}\r\nspin_lock_init(&sal_console_port.sc_port.lock);\r\nsal_console_port.sc_port.membase = (char *)1;\r\nsal_console_port.sc_port.type = PORT_16550A;\r\nsal_console_port.sc_port.fifosize = SN_SAL_MAX_CHARS;\r\nsal_console_port.sc_port.ops = &sn_console_ops;\r\nsal_console_port.sc_port.line = 0;\r\nif (uart_add_one_port(&sal_console_uart, &sal_console_port.sc_port) < 0) {\r\nprintk(KERN_ERR "%s: unable to add port\n", __func__);\r\n}\r\nif (!sal_console_port.sc_is_asynch) {\r\nsn_sal_switch_to_asynch(&sal_console_port);\r\n}\r\nif (!IS_RUNNING_ON_SIMULATOR()) {\r\nsn_sal_switch_to_interrupts(&sal_console_port);\r\n}\r\nsn_process_input = 1;\r\nreturn 0;\r\n}\r\nstatic void __exit sn_sal_module_exit(void)\r\n{\r\ndel_timer_sync(&sal_console_port.sc_timer);\r\nuart_remove_one_port(&sal_console_uart, &sal_console_port.sc_port);\r\nuart_unregister_driver(&sal_console_uart);\r\nmisc_deregister(&misc);\r\n}\r\nstatic void puts_raw_fixed(int (*puts_raw) (const char *s, int len),\r\nconst char *s, int count)\r\n{\r\nconst char *s1;\r\nwhile ((s1 = memchr(s, '\n', count)) != NULL) {\r\nputs_raw(s, s1 - s);\r\nputs_raw("\r\n", 2);\r\ncount -= s1 + 1 - s;\r\ns = s1 + 1;\r\n}\r\nputs_raw(s, count);\r\n}\r\nstatic void\r\nsn_sal_console_write(struct console *co, const char *s, unsigned count)\r\n{\r\nunsigned long flags = 0;\r\nstruct sn_cons_port *port = &sal_console_port;\r\nstatic int stole_lock = 0;\r\nBUG_ON(!port->sc_is_asynch);\r\nif (!port->sc_port.state) {\r\nputs_raw_fixed(port->sc_ops->sal_puts_raw, s, count);\r\nreturn;\r\n}\r\nif (spin_is_locked(&port->sc_port.lock)) {\r\nint lhead = port->sc_port.state->xmit.head;\r\nint ltail = port->sc_port.state->xmit.tail;\r\nint counter, got_lock = 0;\r\nfor (counter = 0; counter < 150; mdelay(125), counter++) {\r\nif (!spin_is_locked(&port->sc_port.lock)\r\n|| stole_lock) {\r\nif (!stole_lock) {\r\nspin_lock_irqsave(&port->sc_port.lock,\r\nflags);\r\ngot_lock = 1;\r\n}\r\nbreak;\r\n} else {\r\nif ((lhead != port->sc_port.state->xmit.head)\r\n|| (ltail !=\r\nport->sc_port.state->xmit.tail)) {\r\nlhead =\r\nport->sc_port.state->xmit.head;\r\nltail =\r\nport->sc_port.state->xmit.tail;\r\ncounter = 0;\r\n}\r\n}\r\n}\r\nsn_transmit_chars(port, 1);\r\nif (got_lock) {\r\nspin_unlock_irqrestore(&port->sc_port.lock, flags);\r\nstole_lock = 0;\r\n} else {\r\nstole_lock = 1;\r\n}\r\nputs_raw_fixed(port->sc_ops->sal_puts_raw, s, count);\r\n} else {\r\nstole_lock = 0;\r\nspin_lock_irqsave(&port->sc_port.lock, flags);\r\nsn_transmit_chars(port, 1);\r\nspin_unlock_irqrestore(&port->sc_port.lock, flags);\r\nputs_raw_fixed(port->sc_ops->sal_puts_raw, s, count);\r\n}\r\n}\r\nstatic int sn_sal_console_setup(struct console *co, char *options)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __init\r\nsn_sal_console_write_early(struct console *co, const char *s, unsigned count)\r\n{\r\nputs_raw_fixed(sal_console_port.sc_ops->sal_puts_raw, s, count);\r\n}\r\nint __init sn_serial_console_early_setup(void)\r\n{\r\nif (!ia64_platform_is("sn2"))\r\nreturn -1;\r\nsal_console_port.sc_ops = &poll_ops;\r\nspin_lock_init(&sal_console_port.sc_port.lock);\r\nearly_sn_setup();\r\nregister_console(&sal_console_early);\r\nreturn 0;\r\n}\r\nstatic int __init sn_sal_serial_console_init(void)\r\n{\r\nif (ia64_platform_is("sn2")) {\r\nsn_sal_switch_to_asynch(&sal_console_port);\r\nDPRINTF("sn_sal_serial_console_init : register console\n");\r\nregister_console(&sal_console);\r\nunregister_console(&sal_console_early);\r\n}\r\nreturn 0;\r\n}
