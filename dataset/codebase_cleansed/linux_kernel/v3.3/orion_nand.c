static void orion_nand_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)\r\n{\r\nstruct nand_chip *nc = mtd->priv;\r\nstruct orion_nand_data *board = nc->priv;\r\nu32 offs;\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\noffs = (1 << board->cle);\r\nelse if (ctrl & NAND_ALE)\r\noffs = (1 << board->ale);\r\nelse\r\nreturn;\r\nif (nc->options & NAND_BUSWIDTH_16)\r\noffs <<= 1;\r\nwriteb(cmd, nc->IO_ADDR_W + offs);\r\n}\r\nstatic void orion_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nvoid __iomem *io_base = chip->IO_ADDR_R;\r\nuint64_t *buf64;\r\nint i = 0;\r\nwhile (len && (unsigned long)buf & 7) {\r\n*buf++ = readb(io_base);\r\nlen--;\r\n}\r\nbuf64 = (uint64_t *)buf;\r\nwhile (i < len/8) {\r\nregister uint64_t x asm ("r2");\r\nasm volatile ("ldrd\t%0, [%1]" : "=&r" (x) : "r" (io_base));\r\nbuf64[i++] = x;\r\n}\r\ni *= 8;\r\nwhile (i < len)\r\nbuf[i++] = readb(io_base);\r\n}\r\nstatic int __init orion_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *nc;\r\nstruct orion_nand_data *board;\r\nstruct resource *res;\r\nvoid __iomem *io_base;\r\nint ret = 0;\r\nnc = kzalloc(sizeof(struct nand_chip) + sizeof(struct mtd_info), GFP_KERNEL);\r\nif (!nc) {\r\nprintk(KERN_ERR "orion_nand: failed to allocate device structure.\n");\r\nret = -ENOMEM;\r\ngoto no_res;\r\n}\r\nmtd = (struct mtd_info *)(nc + 1);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENODEV;\r\ngoto no_res;\r\n}\r\nio_base = ioremap(res->start, resource_size(res));\r\nif (!io_base) {\r\nprintk(KERN_ERR "orion_nand: ioremap failed\n");\r\nret = -EIO;\r\ngoto no_res;\r\n}\r\nboard = pdev->dev.platform_data;\r\nmtd->priv = nc;\r\nmtd->owner = THIS_MODULE;\r\nnc->priv = board;\r\nnc->IO_ADDR_R = nc->IO_ADDR_W = io_base;\r\nnc->cmd_ctrl = orion_nand_cmd_ctrl;\r\nnc->read_buf = orion_nand_read_buf;\r\nnc->ecc.mode = NAND_ECC_SOFT;\r\nif (board->chip_delay)\r\nnc->chip_delay = board->chip_delay;\r\nif (board->width == 16)\r\nnc->options |= NAND_BUSWIDTH_16;\r\nif (board->dev_ready)\r\nnc->dev_ready = board->dev_ready;\r\nplatform_set_drvdata(pdev, mtd);\r\nif (nand_scan(mtd, 1)) {\r\nret = -ENXIO;\r\ngoto no_dev;\r\n}\r\nmtd->name = "orion_nand";\r\nret = mtd_device_parse_register(mtd, NULL, 0,\r\nboard->parts, board->nr_parts);\r\nif (ret) {\r\nnand_release(mtd);\r\ngoto no_dev;\r\n}\r\nreturn 0;\r\nno_dev:\r\nplatform_set_drvdata(pdev, NULL);\r\niounmap(io_base);\r\nno_res:\r\nkfree(nc);\r\nreturn ret;\r\n}\r\nstatic int __devexit orion_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct mtd_info *mtd = platform_get_drvdata(pdev);\r\nstruct nand_chip *nc = mtd->priv;\r\nnand_release(mtd);\r\niounmap(nc->IO_ADDR_W);\r\nkfree(nc);\r\nreturn 0;\r\n}\r\nstatic int __init orion_nand_init(void)\r\n{\r\nreturn platform_driver_probe(&orion_nand_driver, orion_nand_probe);\r\n}\r\nstatic void __exit orion_nand_exit(void)\r\n{\r\nplatform_driver_unregister(&orion_nand_driver);\r\n}
