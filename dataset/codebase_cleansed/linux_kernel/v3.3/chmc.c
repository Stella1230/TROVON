static void mc_list_add(struct list_head *list)\r\n{\r\nspin_lock(&mctrl_list_lock);\r\nlist_add(list, &mctrl_list);\r\nspin_unlock(&mctrl_list_lock);\r\n}\r\nstatic void mc_list_del(struct list_head *list)\r\n{\r\nspin_lock(&mctrl_list_lock);\r\nlist_del_init(list);\r\nspin_unlock(&mctrl_list_lock);\r\n}\r\nstatic int syndrome_to_qword_code(int syndrome_code)\r\n{\r\nif (syndrome_code < 128)\r\nsyndrome_code += 16;\r\nelse if (syndrome_code < 128 + 9)\r\nsyndrome_code -= (128 - 7);\r\nelse if (syndrome_code < (128 + 9 + 3))\r\nsyndrome_code -= (128 + 9 - 4);\r\nelse\r\nsyndrome_code -= (128 + 9 + 3);\r\nreturn syndrome_code;\r\n}\r\nstatic void get_pin_and_dimm_str(int syndrome_code, unsigned long paddr,\r\nint *pin_p, char **dimm_str_p, void *_prop,\r\nint base_dimm_offset)\r\n{\r\nint qword_code = syndrome_to_qword_code(syndrome_code);\r\nint cache_line_offset;\r\nint offset_inverse;\r\nint dimm_map_index;\r\nint map_val;\r\nif (mc_type == MC_TYPE_JBUS) {\r\nstruct jbusmc_obp_mem_layout *p = _prop;\r\ncache_line_offset = qword_code;\r\noffset_inverse = (JBUS_LAST_BIT - cache_line_offset);\r\ndimm_map_index = offset_inverse / 8;\r\nmap_val = p->map.dimm_map[dimm_map_index];\r\nmap_val = ((map_val >> ((7 - (offset_inverse & 7)))) & 1);\r\n*dimm_str_p = p->dimm_labels[base_dimm_offset + map_val];\r\n*pin_p = p->map.pin_map[cache_line_offset];\r\n} else {\r\nstruct chmc_obp_mem_layout *p = _prop;\r\nstruct chmc_obp_map *mp;\r\nint qword;\r\nif (p->symmetric)\r\nmp = &p->map[0];\r\nelse\r\nmp = &p->map[1];\r\nqword = (paddr & L2_LINE_ADDR_MSK) / QW_BYTES;\r\ncache_line_offset = ((3 - qword) * QW_BITS) + qword_code;\r\noffset_inverse = (SAFARI_LAST_BIT - cache_line_offset);\r\ndimm_map_index = offset_inverse >> 2;\r\nmap_val = mp->dimm_map[dimm_map_index];\r\nmap_val = ((map_val >> ((3 - (offset_inverse & 3)) << 1)) & 0x3);\r\n*dimm_str_p = p->dimm_labels[base_dimm_offset + map_val];\r\n*pin_p = mp->pin_map[cache_line_offset];\r\n}\r\n}\r\nstatic struct jbusmc_dimm_group *jbusmc_find_dimm_group(unsigned long phys_addr)\r\n{\r\nstruct jbusmc *p;\r\nlist_for_each_entry(p, &mctrl_list, list) {\r\nint i;\r\nfor (i = 0; i < p->num_dimm_groups; i++) {\r\nstruct jbusmc_dimm_group *dp = &p->dimm_groups[i];\r\nif (phys_addr < dp->base_addr ||\r\n(dp->base_addr + dp->size) <= phys_addr)\r\ncontinue;\r\nreturn dp;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int jbusmc_print_dimm(int syndrome_code,\r\nunsigned long phys_addr,\r\nchar *buf, int buflen)\r\n{\r\nstruct jbusmc_obp_mem_layout *prop;\r\nstruct jbusmc_dimm_group *dp;\r\nstruct jbusmc *p;\r\nint first_dimm;\r\ndp = jbusmc_find_dimm_group(phys_addr);\r\nif (dp == NULL ||\r\nsyndrome_code < SYNDROME_MIN ||\r\nsyndrome_code > SYNDROME_MAX) {\r\nbuf[0] = '?';\r\nbuf[1] = '?';\r\nbuf[2] = '?';\r\nbuf[3] = '\0';\r\nreturn 0;\r\n}\r\np = dp->controller;\r\nprop = &p->layout;\r\nfirst_dimm = dp->index * JB_NUM_DIMMS_PER_GROUP;\r\nif (syndrome_code != SYNDROME_MIN) {\r\nchar *dimm_str;\r\nint pin;\r\nget_pin_and_dimm_str(syndrome_code, phys_addr, &pin,\r\n&dimm_str, prop, first_dimm);\r\nsprintf(buf, "%s, pin %3d", dimm_str, pin);\r\n} else {\r\nint dimm;\r\nfor (dimm = 0; dimm < JB_NUM_DIMMS_PER_GROUP; dimm++) {\r\nsprintf(buf, "%s ",\r\nprop->dimm_labels[first_dimm + dimm]);\r\nbuf += strlen(buf);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u64 __devinit jbusmc_dimm_group_size(u64 base,\r\nconst struct linux_prom64_registers *mem_regs,\r\nint num_mem_regs)\r\n{\r\nu64 max = base + (8UL * 1024 * 1024 * 1024);\r\nu64 max_seen = base;\r\nint i;\r\nfor (i = 0; i < num_mem_regs; i++) {\r\nconst struct linux_prom64_registers *ent;\r\nu64 this_base;\r\nu64 this_end;\r\nent = &mem_regs[i];\r\nthis_base = ent->phys_addr;\r\nthis_end = this_base + ent->reg_size;\r\nif (base < this_base || base >= this_end)\r\ncontinue;\r\nif (this_end > max)\r\nthis_end = max;\r\nif (this_end > max_seen)\r\nmax_seen = this_end;\r\n}\r\nreturn max_seen - base;\r\n}\r\nstatic void __devinit jbusmc_construct_one_dimm_group(struct jbusmc *p,\r\nunsigned long index,\r\nconst struct linux_prom64_registers *mem_regs,\r\nint num_mem_regs)\r\n{\r\nstruct jbusmc_dimm_group *dp = &p->dimm_groups[index];\r\ndp->controller = p;\r\ndp->index = index;\r\ndp->base_addr = (p->portid * (64UL * 1024 * 1024 * 1024));\r\ndp->base_addr += (index * (8UL * 1024 * 1024 * 1024));\r\ndp->size = jbusmc_dimm_group_size(dp->base_addr, mem_regs, num_mem_regs);\r\n}\r\nstatic void __devinit jbusmc_construct_dimm_groups(struct jbusmc *p,\r\nconst struct linux_prom64_registers *mem_regs,\r\nint num_mem_regs)\r\n{\r\nif (p->mc_reg_1 & JB_MC_REG1_DIMM1_BANK0) {\r\njbusmc_construct_one_dimm_group(p, 0, mem_regs, num_mem_regs);\r\np->num_dimm_groups++;\r\n}\r\nif (p->mc_reg_1 & JB_MC_REG1_DIMM2_BANK2) {\r\njbusmc_construct_one_dimm_group(p, 1, mem_regs, num_mem_regs);\r\np->num_dimm_groups++;\r\n}\r\n}\r\nstatic int __devinit jbusmc_probe(struct platform_device *op)\r\n{\r\nconst struct linux_prom64_registers *mem_regs;\r\nstruct device_node *mem_node;\r\nint err, len, num_mem_regs;\r\nstruct jbusmc *p;\r\nconst u32 *prop;\r\nconst void *ml;\r\nerr = -ENODEV;\r\nmem_node = of_find_node_by_path("/memory");\r\nif (!mem_node) {\r\nprintk(KERN_ERR PFX "Cannot find /memory node.\n");\r\ngoto out;\r\n}\r\nmem_regs = of_get_property(mem_node, "reg", &len);\r\nif (!mem_regs) {\r\nprintk(KERN_ERR PFX "Cannot get reg property of /memory node.\n");\r\ngoto out;\r\n}\r\nnum_mem_regs = len / sizeof(*mem_regs);\r\nerr = -ENOMEM;\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p) {\r\nprintk(KERN_ERR PFX "Cannot allocate struct jbusmc.\n");\r\ngoto out;\r\n}\r\nINIT_LIST_HEAD(&p->list);\r\nerr = -ENODEV;\r\nprop = of_get_property(op->dev.of_node, "portid", &len);\r\nif (!prop || len != 4) {\r\nprintk(KERN_ERR PFX "Cannot find portid.\n");\r\ngoto out_free;\r\n}\r\np->portid = *prop;\r\nprop = of_get_property(op->dev.of_node, "memory-control-register-1", &len);\r\nif (!prop || len != 8) {\r\nprintk(KERN_ERR PFX "Cannot get memory control register 1.\n");\r\ngoto out_free;\r\n}\r\np->mc_reg_1 = ((u64)prop[0] << 32) | (u64) prop[1];\r\nerr = -ENOMEM;\r\np->regs = of_ioremap(&op->resource[0], 0, JBUSMC_REGS_SIZE, "jbusmc");\r\nif (!p->regs) {\r\nprintk(KERN_ERR PFX "Cannot map jbusmc regs.\n");\r\ngoto out_free;\r\n}\r\nerr = -ENODEV;\r\nml = of_get_property(op->dev.of_node, "memory-layout", &p->layout_len);\r\nif (!ml) {\r\nprintk(KERN_ERR PFX "Cannot get memory layout property.\n");\r\ngoto out_iounmap;\r\n}\r\nif (p->layout_len > sizeof(p->layout)) {\r\nprintk(KERN_ERR PFX "Unexpected memory-layout size %d\n",\r\np->layout_len);\r\ngoto out_iounmap;\r\n}\r\nmemcpy(&p->layout, ml, p->layout_len);\r\njbusmc_construct_dimm_groups(p, mem_regs, num_mem_regs);\r\nmc_list_add(&p->list);\r\nprintk(KERN_INFO PFX "UltraSPARC-IIIi memory controller at %s\n",\r\nop->dev.of_node->full_name);\r\ndev_set_drvdata(&op->dev, p);\r\nerr = 0;\r\nout:\r\nreturn err;\r\nout_iounmap:\r\nof_iounmap(&op->resource[0], p->regs, JBUSMC_REGS_SIZE);\r\nout_free:\r\nkfree(p);\r\ngoto out;\r\n}\r\nstatic int chmc_bank_match(struct chmc_bank_info *bp, unsigned long phys_addr)\r\n{\r\nunsigned long upper_bits = (phys_addr & PA_UPPER_BITS) >> PA_UPPER_BITS_SHIFT;\r\nunsigned long lower_bits = (phys_addr & PA_LOWER_BITS) >> PA_LOWER_BITS_SHIFT;\r\nif (bp->valid == 0)\r\nreturn 0;\r\nupper_bits ^= bp->um;\r\nupper_bits = ~upper_bits;\r\nupper_bits |= bp->uk;\r\nupper_bits = ~upper_bits;\r\nif (upper_bits)\r\nreturn 0;\r\nlower_bits ^= bp->lm;\r\nlower_bits = ~lower_bits;\r\nlower_bits |= bp->lk;\r\nlower_bits = ~lower_bits;\r\nif (lower_bits)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic struct chmc_bank_info *chmc_find_bank(unsigned long phys_addr)\r\n{\r\nstruct chmc *p;\r\nlist_for_each_entry(p, &mctrl_list, list) {\r\nint bank_no;\r\nfor (bank_no = 0; bank_no < CHMCTRL_NBANKS; bank_no++) {\r\nstruct chmc_bank_info *bp;\r\nbp = &p->logical_banks[bank_no];\r\nif (chmc_bank_match(bp, phys_addr))\r\nreturn bp;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int chmc_print_dimm(int syndrome_code,\r\nunsigned long phys_addr,\r\nchar *buf, int buflen)\r\n{\r\nstruct chmc_bank_info *bp;\r\nstruct chmc_obp_mem_layout *prop;\r\nint bank_in_controller, first_dimm;\r\nbp = chmc_find_bank(phys_addr);\r\nif (bp == NULL ||\r\nsyndrome_code < SYNDROME_MIN ||\r\nsyndrome_code > SYNDROME_MAX) {\r\nbuf[0] = '?';\r\nbuf[1] = '?';\r\nbuf[2] = '?';\r\nbuf[3] = '\0';\r\nreturn 0;\r\n}\r\nprop = &bp->p->layout_prop;\r\nbank_in_controller = bp->bank_id & (CHMCTRL_NBANKS - 1);\r\nfirst_dimm = (bank_in_controller & (CHMCTRL_NDGRPS - 1));\r\nfirst_dimm *= CHMCTRL_NDIMMS;\r\nif (syndrome_code != SYNDROME_MIN) {\r\nchar *dimm_str;\r\nint pin;\r\nget_pin_and_dimm_str(syndrome_code, phys_addr, &pin,\r\n&dimm_str, prop, first_dimm);\r\nsprintf(buf, "%s, pin %3d", dimm_str, pin);\r\n} else {\r\nint dimm;\r\nfor (dimm = 0; dimm < CHMCTRL_NDIMMS; dimm++) {\r\nsprintf(buf, "%s ",\r\nprop->dimm_labels[first_dimm + dimm]);\r\nbuf += strlen(buf);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u64 chmc_read_mcreg(struct chmc *p, unsigned long offset)\r\n{\r\nunsigned long ret, this_cpu;\r\npreempt_disable();\r\nthis_cpu = real_hard_smp_processor_id();\r\nif (p->portid == this_cpu) {\r\n__asm__ __volatile__("ldxa [%1] %2, %0"\r\n: "=r" (ret)\r\n: "r" (offset), "i" (ASI_MCU_CTRL_REG));\r\n} else {\r\n__asm__ __volatile__("ldxa [%1] %2, %0"\r\n: "=r" (ret)\r\n: "r" (p->regs + offset),\r\n"i" (ASI_PHYS_BYPASS_EC_E));\r\n}\r\npreempt_enable();\r\nreturn ret;\r\n}\r\nstatic void chmc_interpret_one_decode_reg(struct chmc *p, int which_bank, u64 val)\r\n{\r\nstruct chmc_bank_info *bp = &p->logical_banks[which_bank];\r\nbp->p = p;\r\nbp->bank_id = (CHMCTRL_NBANKS * p->portid) + which_bank;\r\nbp->raw_reg = val;\r\nbp->valid = (val & MEM_DECODE_VALID) >> MEM_DECODE_VALID_SHIFT;\r\nbp->uk = (val & MEM_DECODE_UK) >> MEM_DECODE_UK_SHIFT;\r\nbp->um = (val & MEM_DECODE_UM) >> MEM_DECODE_UM_SHIFT;\r\nbp->lk = (val & MEM_DECODE_LK) >> MEM_DECODE_LK_SHIFT;\r\nbp->lm = (val & MEM_DECODE_LM) >> MEM_DECODE_LM_SHIFT;\r\nbp->base = (bp->um);\r\nbp->base &= ~(bp->uk);\r\nbp->base <<= PA_UPPER_BITS_SHIFT;\r\nswitch(bp->lk) {\r\ncase 0xf:\r\ndefault:\r\nbp->interleave = 1;\r\nbreak;\r\ncase 0xe:\r\nbp->interleave = 2;\r\nbreak;\r\ncase 0xc:\r\nbp->interleave = 4;\r\nbreak;\r\ncase 0x8:\r\nbp->interleave = 8;\r\nbreak;\r\ncase 0x0:\r\nbp->interleave = 16;\r\nbreak;\r\n}\r\nbp->size = (((unsigned long)bp->uk &\r\n((1UL << 10UL) - 1UL)) + 1UL) << PA_UPPER_BITS_SHIFT;\r\nbp->size /= bp->interleave;\r\n}\r\nstatic void chmc_fetch_decode_regs(struct chmc *p)\r\n{\r\nif (p->layout_size == 0)\r\nreturn;\r\nchmc_interpret_one_decode_reg(p, 0,\r\nchmc_read_mcreg(p, CHMCTRL_DECODE1));\r\nchmc_interpret_one_decode_reg(p, 1,\r\nchmc_read_mcreg(p, CHMCTRL_DECODE2));\r\nchmc_interpret_one_decode_reg(p, 2,\r\nchmc_read_mcreg(p, CHMCTRL_DECODE3));\r\nchmc_interpret_one_decode_reg(p, 3,\r\nchmc_read_mcreg(p, CHMCTRL_DECODE4));\r\n}\r\nstatic int __devinit chmc_probe(struct platform_device *op)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nunsigned long ver;\r\nconst void *pval;\r\nint len, portid;\r\nstruct chmc *p;\r\nint err;\r\nerr = -ENODEV;\r\n__asm__ ("rdpr %%ver, %0" : "=r" (ver));\r\nif ((ver >> 32UL) == __JALAPENO_ID ||\r\n(ver >> 32UL) == __SERRANO_ID)\r\ngoto out;\r\nportid = of_getintprop_default(dp, "portid", -1);\r\nif (portid == -1)\r\ngoto out;\r\npval = of_get_property(dp, "memory-layout", &len);\r\nif (pval && len > sizeof(p->layout_prop)) {\r\nprintk(KERN_ERR PFX "Unexpected memory-layout property "\r\n"size %d.\n", len);\r\ngoto out;\r\n}\r\nerr = -ENOMEM;\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p) {\r\nprintk(KERN_ERR PFX "Could not allocate struct chmc.\n");\r\ngoto out;\r\n}\r\np->portid = portid;\r\np->layout_size = len;\r\nif (!pval)\r\np->layout_size = 0;\r\nelse\r\nmemcpy(&p->layout_prop, pval, len);\r\np->regs = of_ioremap(&op->resource[0], 0, 0x48, "chmc");\r\nif (!p->regs) {\r\nprintk(KERN_ERR PFX "Could not map registers.\n");\r\ngoto out_free;\r\n}\r\nif (p->layout_size != 0UL) {\r\np->timing_control1 = chmc_read_mcreg(p, CHMCTRL_TCTRL1);\r\np->timing_control2 = chmc_read_mcreg(p, CHMCTRL_TCTRL2);\r\np->timing_control3 = chmc_read_mcreg(p, CHMCTRL_TCTRL3);\r\np->timing_control4 = chmc_read_mcreg(p, CHMCTRL_TCTRL4);\r\np->memaddr_control = chmc_read_mcreg(p, CHMCTRL_MACTRL);\r\n}\r\nchmc_fetch_decode_regs(p);\r\nmc_list_add(&p->list);\r\nprintk(KERN_INFO PFX "UltraSPARC-III memory controller at %s [%s]\n",\r\ndp->full_name,\r\n(p->layout_size ? "ACTIVE" : "INACTIVE"));\r\ndev_set_drvdata(&op->dev, p);\r\nerr = 0;\r\nout:\r\nreturn err;\r\nout_free:\r\nkfree(p);\r\ngoto out;\r\n}\r\nstatic int __devinit us3mc_probe(struct platform_device *op)\r\n{\r\nif (mc_type == MC_TYPE_SAFARI)\r\nreturn chmc_probe(op);\r\nelse if (mc_type == MC_TYPE_JBUS)\r\nreturn jbusmc_probe(op);\r\nreturn -ENODEV;\r\n}\r\nstatic void __devexit chmc_destroy(struct platform_device *op, struct chmc *p)\r\n{\r\nlist_del(&p->list);\r\nof_iounmap(&op->resource[0], p->regs, 0x48);\r\nkfree(p);\r\n}\r\nstatic void __devexit jbusmc_destroy(struct platform_device *op, struct jbusmc *p)\r\n{\r\nmc_list_del(&p->list);\r\nof_iounmap(&op->resource[0], p->regs, JBUSMC_REGS_SIZE);\r\nkfree(p);\r\n}\r\nstatic int __devexit us3mc_remove(struct platform_device *op)\r\n{\r\nvoid *p = dev_get_drvdata(&op->dev);\r\nif (p) {\r\nif (mc_type == MC_TYPE_SAFARI)\r\nchmc_destroy(op, p);\r\nelse if (mc_type == MC_TYPE_JBUS)\r\njbusmc_destroy(op, p);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline bool us3mc_platform(void)\r\n{\r\nif (tlb_type == cheetah || tlb_type == cheetah_plus)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int __init us3mc_init(void)\r\n{\r\nunsigned long ver;\r\nint ret;\r\nif (!us3mc_platform())\r\nreturn -ENODEV;\r\n__asm__ __volatile__("rdpr %%ver, %0" : "=r" (ver));\r\nif ((ver >> 32UL) == __JALAPENO_ID ||\r\n(ver >> 32UL) == __SERRANO_ID) {\r\nmc_type = MC_TYPE_JBUS;\r\nus3mc_dimm_printer = jbusmc_print_dimm;\r\n} else {\r\nmc_type = MC_TYPE_SAFARI;\r\nus3mc_dimm_printer = chmc_print_dimm;\r\n}\r\nret = register_dimm_printer(us3mc_dimm_printer);\r\nif (!ret) {\r\nret = platform_driver_register(&us3mc_driver);\r\nif (ret)\r\nunregister_dimm_printer(us3mc_dimm_printer);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit us3mc_cleanup(void)\r\n{\r\nif (us3mc_platform()) {\r\nunregister_dimm_printer(us3mc_dimm_printer);\r\nplatform_driver_unregister(&us3mc_driver);\r\n}\r\n}
