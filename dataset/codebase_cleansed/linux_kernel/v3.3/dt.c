static unsigned char __init e2a(unsigned char x)\r\n{\r\nswitch (x) {\r\ncase 0x81 ... 0x89:\r\nreturn x - 0x81 + 'a';\r\ncase 0x91 ... 0x99:\r\nreturn x - 0x91 + 'j';\r\ncase 0xA2 ... 0xA9:\r\nreturn x - 0xA2 + 's';\r\ncase 0xC1 ... 0xC9:\r\nreturn x - 0xC1 + 'A';\r\ncase 0xD1 ... 0xD9:\r\nreturn x - 0xD1 + 'J';\r\ncase 0xE2 ... 0xE9:\r\nreturn x - 0xE2 + 'S';\r\ncase 0xF0 ... 0xF9:\r\nreturn x - 0xF0 + '0';\r\n}\r\nreturn ' ';\r\n}\r\nstatic unsigned char * __init strne2a(unsigned char *dest,\r\nconst unsigned char *src, size_t n)\r\n{\r\nint i;\r\nn = strnlen(src, n);\r\nfor (i = 0; i < n; i++)\r\ndest[i] = e2a(src[i]);\r\nreturn dest;\r\n}\r\nstatic struct iseries_flat_dt * __init dt_init(void)\r\n{\r\nstruct iseries_flat_dt *dt;\r\nunsigned long str_len;\r\nstr_len = __dt_strings_end - __dt_strings_start;\r\ndt = (struct iseries_flat_dt *)ALIGN(klimit, 8);\r\ndt->header.off_mem_rsvmap =\r\noffsetof(struct iseries_flat_dt, reserve_map);\r\ndt->header.off_dt_strings = ALIGN(sizeof(*dt), 8);\r\ndt->header.off_dt_struct = dt->header.off_dt_strings\r\n+ ALIGN(str_len, 8);\r\ndt_data = (void *)((unsigned long)dt + dt->header.off_dt_struct);\r\ndt->header.dt_strings_size = str_len;\r\ndt->header.boot_cpuid_phys = smp_processor_id();\r\nmemcpy((char *)dt + dt->header.off_dt_strings, __dt_strings_start,\r\nstr_len);\r\ndt->header.magic = OF_DT_HEADER;\r\ndt->header.version = 0x10;\r\ndt->header.last_comp_version = 0x10;\r\ndt->reserve_map[0] = 0;\r\ndt->reserve_map[1] = 0;\r\nreturn dt;\r\n}\r\nstatic void __init dt_push_u32(struct iseries_flat_dt *dt, u32 value)\r\n{\r\n*((u32 *)dt_data) = value;\r\ndt_data += sizeof(u32);\r\n}\r\nstatic void __init dt_push_u64(struct iseries_flat_dt *dt, u64 value)\r\n{\r\n*((u64 *)dt_data) = value;\r\ndt_data += sizeof(u64);\r\n}\r\nstatic void __init dt_push_bytes(struct iseries_flat_dt *dt, const char *data,\r\nint len)\r\n{\r\nmemcpy(dt_data, data, len);\r\ndt_data += ALIGN(len, 4);\r\n}\r\nstatic void __init dt_start_node(struct iseries_flat_dt *dt, const char *name)\r\n{\r\ndt_push_u32(dt, OF_DT_BEGIN_NODE);\r\ndt_push_bytes(dt, name, strlen(name) + 1);\r\n}\r\nstatic void __init __dt_prop(struct iseries_flat_dt *dt, const char *name,\r\nconst void *data, int len)\r\n{\r\nunsigned long offset;\r\ndt_push_u32(dt, OF_DT_PROP);\r\ndt_push_u32(dt, len);\r\noffset = name - __dt_strings_start;\r\ndt_push_u32(dt, (u32)offset);\r\ndt_push_bytes(dt, data, len);\r\n}\r\nstatic void __init __dt_prop_u32(struct iseries_flat_dt *dt, const char *name,\r\nu32 data)\r\n{\r\n__dt_prop(dt, name, &data, sizeof(u32));\r\n}\r\nstatic void __init __maybe_unused __dt_prop_u64(struct iseries_flat_dt *dt,\r\nconst char *name, u64 data)\r\n{\r\n__dt_prop(dt, name, &data, sizeof(u64));\r\n}\r\nstatic void __init dt_cpus(struct iseries_flat_dt *dt)\r\n{\r\nunsigned char buf[32];\r\nunsigned char *p;\r\nunsigned int i, index;\r\nstruct IoHriProcessorVpd *d;\r\nu32 pft_size[2];\r\nsnprintf(buf, 32, "PowerPC,%s", cur_cpu_spec->cpu_name);\r\np = strchr(buf, ' ');\r\nif (!p) p = buf + strlen(buf);\r\ndt_start_node(dt, "cpus");\r\ndt_prop_u32(dt, "#address-cells", 1);\r\ndt_prop_u32(dt, "#size-cells", 0);\r\npft_size[0] = 0;\r\npft_size[1] = __ilog2(HvCallHpt_getHptPages() * HW_PAGE_SIZE);\r\nfor (i = 0; i < NR_LPPACAS; i++) {\r\nif (lppaca[i].dyn_proc_status >= 2)\r\ncontinue;\r\nsnprintf(p, 32 - (p - buf), "@%d", i);\r\ndt_start_node(dt, buf);\r\ndt_prop_str(dt, "device_type", device_type_cpu);\r\nindex = lppaca[i].dyn_hv_phys_proc_index;\r\nd = &xIoHriProcessorVpd[index];\r\ndt_prop_u32(dt, "i-cache-size", d->xInstCacheSize * 1024);\r\ndt_prop_u32(dt, "i-cache-line-size", d->xInstCacheOperandSize);\r\ndt_prop_u32(dt, "d-cache-size", d->xDataL1CacheSizeKB * 1024);\r\ndt_prop_u32(dt, "d-cache-line-size", d->xDataCacheOperandSize);\r\ndt_prop_u32(dt, "clock-frequency",\r\n((1UL << 34) * 1000000) / d->xProcFreq);\r\ndt_prop_u32(dt, "timebase-frequency",\r\n((1UL << 32) * 1000000) / d->xTimeBaseFreq);\r\ndt_prop_u32(dt, "reg", i);\r\ndt_prop_u32_list(dt, "ibm,pft-size", pft_size, 2);\r\ndt_end_node(dt);\r\n}\r\ndt_end_node(dt);\r\n}\r\nstatic void __init dt_model(struct iseries_flat_dt *dt)\r\n{\r\nchar buf[16] = "IBM,";\r\nstrne2a(buf + 4, xItExtVpdPanel.mfgID + 2, 2);\r\nstrne2a(buf + 6, xItExtVpdPanel.systemSerial + 1, 5);\r\nbuf[11] = '\0';\r\ndt_prop_str(dt, "system-id", buf);\r\nstrne2a(buf + 4, xItExtVpdPanel.machineType, 4);\r\nbuf[8] = '\0';\r\ndt_prop_str(dt, "model", buf);\r\ndt_prop_str(dt, "compatible", "IBM,iSeries");\r\ndt_prop_u32(dt, "ibm,partition-no", HvLpConfig_getLpIndex());\r\n}\r\nstatic void __init dt_initrd(struct iseries_flat_dt *dt)\r\n{\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\nif (naca.xRamDisk) {\r\ndt_prop_u64(dt, "linux,initrd-start", (u64)naca.xRamDisk);\r\ndt_prop_u64(dt, "linux,initrd-end",\r\n(u64)naca.xRamDisk + naca.xRamDiskSize * HW_PAGE_SIZE);\r\n}\r\n#endif\r\n}\r\nstatic void __init dt_do_vdevice(struct iseries_flat_dt *dt,\r\nconst char *name, u32 reg, int unit,\r\nconst char *type, const char *compat, int end)\r\n{\r\nchar buf[32];\r\nsnprintf(buf, 32, "%s@%08x", name, reg + ((unit >= 0) ? unit : 0));\r\ndt_start_node(dt, buf);\r\ndt_prop_str(dt, "device_type", type);\r\nif (compat)\r\ndt_prop_str(dt, "compatible", compat);\r\ndt_prop_u32(dt, "reg", reg + ((unit >= 0) ? unit : 0));\r\nif (unit >= 0)\r\ndt_prop_u32(dt, "linux,unit_address", unit);\r\nif (end)\r\ndt_end_node(dt);\r\n}\r\nstatic void __init dt_vdevices(struct iseries_flat_dt *dt)\r\n{\r\nu32 reg = 0;\r\nHvLpIndexMap vlan_map;\r\nint i;\r\ndt_start_node(dt, "vdevice");\r\ndt_prop_str(dt, "device_type", device_type_vdevice);\r\ndt_prop_str(dt, "compatible", "IBM,iSeries-vdevice");\r\ndt_prop_u32(dt, "#address-cells", 1);\r\ndt_prop_u32(dt, "#size-cells", 0);\r\ndt_do_vdevice(dt, "vty", reg, -1, device_type_serial,\r\n"IBM,iSeries-vty", 1);\r\nreg++;\r\ndt_do_vdevice(dt, "v-scsi", reg, -1, device_type_vscsi,\r\n"IBM,v-scsi", 1);\r\nreg++;\r\nvlan_map = HvLpConfig_getVirtualLanIndexMap();\r\nfor (i = 0; i < HVMAXARCHITECTEDVIRTUALLANS; i++) {\r\nunsigned char mac_addr[ETH_ALEN];\r\nif ((vlan_map & (0x8000 >> i)) == 0)\r\ncontinue;\r\ndt_do_vdevice(dt, "l-lan", reg, i, device_type_network,\r\n"IBM,iSeries-l-lan", 0);\r\nmac_addr[0] = 0x02;\r\nmac_addr[1] = 0x01;\r\nmac_addr[2] = 0xff;\r\nmac_addr[3] = i;\r\nmac_addr[4] = 0xff;\r\nmac_addr[5] = HvLpConfig_getLpIndex_outline();\r\ndt_prop(dt, "local-mac-address", (char *)mac_addr, ETH_ALEN);\r\ndt_prop(dt, "mac-address", (char *)mac_addr, ETH_ALEN);\r\ndt_prop_u32(dt, "max-frame-size", 9000);\r\ndt_prop_u32(dt, "address-bits", 48);\r\ndt_end_node(dt);\r\n}\r\ndt_end_node(dt);\r\n}\r\nstatic struct pci_class_name * __init dt_find_pci_class_name(u16 class_code)\r\n{\r\nstruct pci_class_name *cp;\r\nfor (cp = pci_class_name;\r\ncp < &pci_class_name[ARRAY_SIZE(pci_class_name)]; cp++)\r\nif (cp->code == class_code)\r\nreturn cp;\r\nreturn NULL;\r\n}\r\nstatic void __init scan_bridge_slot(struct iseries_flat_dt *dt,\r\nHvBusNumber bus, struct HvCallPci_BridgeInfo *bridge_info)\r\n{\r\nHvSubBusNumber sub_bus = bridge_info->subBusNumber;\r\nu16 vendor_id;\r\nu16 device_id;\r\nu32 class_id;\r\nint err;\r\nchar buf[32];\r\nu32 reg[5];\r\nint id_sel = ISERIES_GET_DEVICE_FROM_SUBBUS(sub_bus);\r\nint function = ISERIES_GET_FUNCTION_FROM_SUBBUS(sub_bus);\r\nHvAgentId eads_id_sel = ISERIES_PCI_AGENTID(id_sel, function);\r\nu8 devfn;\r\nstruct pci_class_name *cp;\r\nfor (id_sel = 1; id_sel <= bridge_info->maxAgents; id_sel++) {\r\nfor (function = 0; function < 8; function++) {\r\nHvAgentId agent_id = ISERIES_PCI_AGENTID(id_sel,\r\nfunction);\r\nerr = HvCallXm_connectBusUnit(bus, sub_bus,\r\nagent_id, 0);\r\nif (err) {\r\nif (err != 0x302)\r\nDBG("connectBusUnit(%x, %x, %x) %x\n",\r\nbus, sub_bus, agent_id, err);\r\ncontinue;\r\n}\r\nerr = HvCallPci_configLoad16(bus, sub_bus, agent_id,\r\nPCI_VENDOR_ID, &vendor_id);\r\nif (err) {\r\nDBG("ReadVendor(%x, %x, %x) %x\n",\r\nbus, sub_bus, agent_id, err);\r\ncontinue;\r\n}\r\nerr = HvCallPci_configLoad16(bus, sub_bus, agent_id,\r\nPCI_DEVICE_ID, &device_id);\r\nif (err) {\r\nDBG("ReadDevice(%x, %x, %x) %x\n",\r\nbus, sub_bus, agent_id, err);\r\ncontinue;\r\n}\r\nerr = HvCallPci_configLoad32(bus, sub_bus, agent_id,\r\nPCI_CLASS_REVISION , &class_id);\r\nif (err) {\r\nDBG("ReadClass(%x, %x, %x) %x\n",\r\nbus, sub_bus, agent_id, err);\r\ncontinue;\r\n}\r\ndevfn = PCI_DEVFN(ISERIES_ENCODE_DEVICE(eads_id_sel),\r\nfunction);\r\ncp = dt_find_pci_class_name(class_id >> 16);\r\nif (cp && cp->name)\r\nstrncpy(buf, cp->name, sizeof(buf) - 1);\r\nelse\r\nsnprintf(buf, sizeof(buf), "pci%x,%x",\r\nvendor_id, device_id);\r\nbuf[sizeof(buf) - 1] = '\0';\r\nsnprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\r\n"@%x", PCI_SLOT(devfn));\r\nbuf[sizeof(buf) - 1] = '\0';\r\nif (function != 0)\r\nsnprintf(buf + strlen(buf),\r\nsizeof(buf) - strlen(buf),\r\n",%x", function);\r\ndt_start_node(dt, buf);\r\nreg[0] = (bus << 16) | (devfn << 8);\r\nreg[1] = 0;\r\nreg[2] = 0;\r\nreg[3] = 0;\r\nreg[4] = 0;\r\ndt_prop_u32_list(dt, "reg", reg, 5);\r\nif (cp && (cp->type || cp->name))\r\ndt_prop_str(dt, "device_type",\r\ncp->type ? cp->type : cp->name);\r\ndt_prop_u32(dt, "vendor-id", vendor_id);\r\ndt_prop_u32(dt, "device-id", device_id);\r\ndt_prop_u32(dt, "class-code", class_id >> 8);\r\ndt_prop_u32(dt, "revision-id", class_id & 0xff);\r\ndt_prop_u32(dt, "linux,subbus", sub_bus);\r\ndt_prop_u32(dt, "linux,agent-id", agent_id);\r\ndt_prop_u32(dt, "linux,logical-slot-number",\r\nbridge_info->logicalSlotNumber);\r\ndt_end_node(dt);\r\n}\r\n}\r\n}\r\nstatic void __init scan_bridge(struct iseries_flat_dt *dt, HvBusNumber bus,\r\nHvSubBusNumber sub_bus, int id_sel)\r\n{\r\nstruct HvCallPci_BridgeInfo bridge_info;\r\nHvAgentId agent_id;\r\nint function;\r\nint ret;\r\nfor (function = 0; function < 8; ++function) {\r\nagent_id = ISERIES_PCI_AGENTID(id_sel, function);\r\nret = HvCallXm_connectBusUnit(bus, sub_bus, agent_id, 0);\r\nif (ret != 0) {\r\nif (ret != 0xb)\r\nDBG("connectBusUnit(%x, %x, %x) %x\n",\r\nbus, sub_bus, agent_id, ret);\r\ncontinue;\r\n}\r\nDBG("found device at bus %d idsel %d func %d (AgentId %x)\n",\r\nbus, id_sel, function, agent_id);\r\nret = HvCallPci_getBusUnitInfo(bus, sub_bus, agent_id,\r\niseries_hv_addr(&bridge_info),\r\nsizeof(struct HvCallPci_BridgeInfo));\r\nif (ret != 0)\r\ncontinue;\r\nDBG("bridge info: type %x subbus %x "\r\n"maxAgents %x maxsubbus %x logslot %x\n",\r\nbridge_info.busUnitInfo.deviceType,\r\nbridge_info.subBusNumber,\r\nbridge_info.maxAgents,\r\nbridge_info.maxSubBusNumber,\r\nbridge_info.logicalSlotNumber);\r\nif (bridge_info.busUnitInfo.deviceType ==\r\nHvCallPci_BridgeDevice)\r\nscan_bridge_slot(dt, bus, &bridge_info);\r\nelse\r\nDBG("PCI: Invalid Bridge Configuration(0x%02X)",\r\nbridge_info.busUnitInfo.deviceType);\r\n}\r\n}\r\nstatic void __init scan_phb(struct iseries_flat_dt *dt, HvBusNumber bus)\r\n{\r\nstruct HvCallPci_DeviceInfo dev_info;\r\nconst HvSubBusNumber sub_bus = 0;\r\nint err;\r\nint id_sel;\r\nconst int max_agents = 8;\r\nfor (id_sel = 1; id_sel < max_agents; ++id_sel) {\r\nerr = HvCallPci_getDeviceInfo(bus, sub_bus, id_sel,\r\niseries_hv_addr(&dev_info),\r\nsizeof(struct HvCallPci_DeviceInfo));\r\nif (err) {\r\nif (err != 0x302)\r\nDBG("getDeviceInfo(%x, %x, %x) %x\n",\r\nbus, sub_bus, id_sel, err);\r\ncontinue;\r\n}\r\nif (dev_info.deviceType != HvCallPci_NodeDevice) {\r\nDBG("PCI: Invalid System Configuration"\r\n"(0x%02X) for bus 0x%02x id 0x%02x.\n",\r\ndev_info.deviceType, bus, id_sel);\r\ncontinue;\r\n}\r\nscan_bridge(dt, bus, sub_bus, id_sel);\r\n}\r\n}\r\nstatic void __init dt_pci_devices(struct iseries_flat_dt *dt)\r\n{\r\nHvBusNumber bus;\r\nchar buf[32];\r\nu32 buses[2];\r\nint phb_num = 0;\r\nfor (bus = 0; bus < 256; bus++) {\r\nint err = HvCallXm_testBus(bus);\r\nif (err) {\r\nif (err != 0x0301)\r\nDBG("Unexpected Return on Probe(0x%02X) "\r\n"0x%04X\n", bus, err);\r\ncontinue;\r\n}\r\nDBG("bus %d appears to exist\n", bus);\r\nsnprintf(buf, 32, "pci@%d", phb_num);\r\ndt_start_node(dt, buf);\r\ndt_prop_str(dt, "device_type", device_type_pci);\r\ndt_prop_str(dt, "compatible", "IBM,iSeries-Logical-PHB");\r\ndt_prop_u32(dt, "#address-cells", 3);\r\ndt_prop_u32(dt, "#size-cells", 2);\r\nbuses[0] = buses[1] = bus;\r\ndt_prop_u32_list(dt, "bus-range", buses, 2);\r\nscan_phb(dt, bus);\r\ndt_end_node(dt);\r\nphb_num++;\r\n}\r\n}\r\nstatic void dt_finish(struct iseries_flat_dt *dt)\r\n{\r\ndt_push_u32(dt, OF_DT_END);\r\ndt->header.totalsize = (unsigned long)dt_data - (unsigned long)dt;\r\nklimit = ALIGN((unsigned long)dt_data, 8);\r\n}\r\nvoid * __init build_flat_dt(unsigned long phys_mem_size)\r\n{\r\nstruct iseries_flat_dt *iseries_dt;\r\nu64 tmp[2];\r\niseries_dt = dt_init();\r\ndt_start_node(iseries_dt, "");\r\ndt_prop_u32(iseries_dt, "#address-cells", 2);\r\ndt_prop_u32(iseries_dt, "#size-cells", 2);\r\ndt_model(iseries_dt);\r\ndt_start_node(iseries_dt, "memory@0");\r\ndt_prop_str(iseries_dt, "device_type", device_type_memory);\r\ntmp[0] = 0;\r\ntmp[1] = phys_mem_size;\r\ndt_prop_u64_list(iseries_dt, "reg", tmp, 2);\r\ndt_end_node(iseries_dt);\r\ndt_start_node(iseries_dt, "chosen");\r\ndt_prop_str(iseries_dt, "bootargs", cmd_line);\r\ndt_initrd(iseries_dt);\r\ndt_end_node(iseries_dt);\r\ndt_cpus(iseries_dt);\r\ndt_vdevices(iseries_dt);\r\ndt_pci_devices(iseries_dt);\r\ndt_end_node(iseries_dt);\r\ndt_finish(iseries_dt);\r\nreturn iseries_dt;\r\n}
