static int ehci_mxc_setup(struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nint retval;\r\ndbg_hcs_params(ehci, "reset");\r\ndbg_hcc_params(ehci, "reset");\r\nehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);\r\nhcd->has_tt = 1;\r\nretval = ehci_halt(ehci);\r\nif (retval)\r\nreturn retval;\r\nretval = ehci_init(hcd);\r\nif (retval)\r\nreturn retval;\r\nehci->sbrn = 0x20;\r\nehci_reset(ehci);\r\nehci_port_power(ehci, 0);\r\nreturn 0;\r\n}\r\nstatic int ehci_mxc_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct mxc_usbh_platform_data *pdata = pdev->dev.platform_data;\r\nstruct usb_hcd *hcd;\r\nstruct resource *res;\r\nint irq, ret;\r\nunsigned int flags;\r\nstruct ehci_mxc_priv *priv;\r\nstruct device *dev = &pdev->dev;\r\nstruct ehci_hcd *ehci;\r\ndev_info(&pdev->dev, "initializing i.MX USB Controller\n");\r\nif (!pdata) {\r\ndev_err(dev, "No platform data given, bailing out.\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nhcd = usb_create_hcd(&ehci_mxc_hc_driver, dev, dev_name(dev));\r\nif (!hcd)\r\nreturn -ENOMEM;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "Found HC with no register addr. Check setup!\n");\r\nret = -ENODEV;\r\ngoto err_get_resource;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nif (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {\r\ndev_dbg(dev, "controller already in use\n");\r\nret = -EBUSY;\r\ngoto err_request_mem;\r\n}\r\nhcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);\r\nif (!hcd->regs) {\r\ndev_err(dev, "error mapping memory\n");\r\nret = -EFAULT;\r\ngoto err_ioremap;\r\n}\r\npriv->usbclk = clk_get(dev, "usb");\r\nif (IS_ERR(priv->usbclk)) {\r\nret = PTR_ERR(priv->usbclk);\r\ngoto err_clk;\r\n}\r\nclk_enable(priv->usbclk);\r\nif (!cpu_is_mx35() && !cpu_is_mx25()) {\r\npriv->ahbclk = clk_get(dev, "usb_ahb");\r\nif (IS_ERR(priv->ahbclk)) {\r\nret = PTR_ERR(priv->ahbclk);\r\ngoto err_clk_ahb;\r\n}\r\nclk_enable(priv->ahbclk);\r\n}\r\nif (cpu_is_mx51() && (pdev->id == 0)) {\r\npriv->phy1clk = clk_get(dev, "usb_phy1");\r\nif (IS_ERR(priv->phy1clk)) {\r\nret = PTR_ERR(priv->phy1clk);\r\ngoto err_clk_phy;\r\n}\r\nclk_enable(priv->phy1clk);\r\n}\r\nif (pdata->init) {\r\nret = pdata->init(pdev);\r\nif (ret) {\r\ndev_err(dev, "platform init failed\n");\r\ngoto err_init;\r\n}\r\nmdelay(10);\r\n}\r\nehci = hcd_to_ehci(hcd);\r\nehci->caps = hcd->regs + 0x100;\r\nehci->regs = hcd->regs + 0x100 +\r\nHC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));\r\nehci_writel(ehci, pdata->portsc, &ehci->regs->port_status[0]);\r\nmsleep(10);\r\nif (pdata->otg) {\r\npdata->otg->io_priv = hcd->regs + ULPI_VIEWPORT_OFFSET;\r\nret = otg_init(pdata->otg);\r\nif (ret) {\r\ndev_err(dev, "unable to init transceiver, probably missing\n");\r\nret = -ENODEV;\r\ngoto err_add;\r\n}\r\nret = otg_set_vbus(pdata->otg, 1);\r\nif (ret) {\r\ndev_err(dev, "unable to enable vbus on transceiver\n");\r\ngoto err_add;\r\n}\r\n}\r\npriv->hcd = hcd;\r\nplatform_set_drvdata(pdev, priv);\r\nret = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (ret)\r\ngoto err_add;\r\nif (pdata->otg) {\r\nif (machine_is_mx51_efikamx() || machine_is_mx51_efikasb()) {\r\nflags = otg_io_read(pdata->otg, ULPI_OTG_CTRL);\r\nflags |= ULPI_OTG_CTRL_CHRGVBUS;\r\nret = otg_io_write(pdata->otg, flags, ULPI_OTG_CTRL);\r\nif (ret) {\r\ndev_err(dev, "unable to set CHRVBUS\n");\r\ngoto err_add;\r\n}\r\n}\r\n}\r\nreturn 0;\r\nerr_add:\r\nif (pdata && pdata->exit)\r\npdata->exit(pdev);\r\nerr_init:\r\nif (priv->phy1clk) {\r\nclk_disable(priv->phy1clk);\r\nclk_put(priv->phy1clk);\r\n}\r\nerr_clk_phy:\r\nif (priv->ahbclk) {\r\nclk_disable(priv->ahbclk);\r\nclk_put(priv->ahbclk);\r\n}\r\nerr_clk_ahb:\r\nclk_disable(priv->usbclk);\r\nclk_put(priv->usbclk);\r\nerr_clk:\r\niounmap(hcd->regs);\r\nerr_ioremap:\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nerr_request_mem:\r\nerr_get_resource:\r\nkfree(priv);\r\nerr_alloc:\r\nusb_put_hcd(hcd);\r\nreturn ret;\r\n}\r\nstatic int __exit ehci_mxc_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct mxc_usbh_platform_data *pdata = pdev->dev.platform_data;\r\nstruct ehci_mxc_priv *priv = platform_get_drvdata(pdev);\r\nstruct usb_hcd *hcd = priv->hcd;\r\nif (pdata && pdata->exit)\r\npdata->exit(pdev);\r\nif (pdata->otg)\r\notg_shutdown(pdata->otg);\r\nusb_remove_hcd(hcd);\r\niounmap(hcd->regs);\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nusb_put_hcd(hcd);\r\nplatform_set_drvdata(pdev, NULL);\r\nclk_disable(priv->usbclk);\r\nclk_put(priv->usbclk);\r\nif (priv->ahbclk) {\r\nclk_disable(priv->ahbclk);\r\nclk_put(priv->ahbclk);\r\n}\r\nif (priv->phy1clk) {\r\nclk_disable(priv->phy1clk);\r\nclk_put(priv->phy1clk);\r\n}\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic void ehci_mxc_drv_shutdown(struct platform_device *pdev)\r\n{\r\nstruct ehci_mxc_priv *priv = platform_get_drvdata(pdev);\r\nstruct usb_hcd *hcd = priv->hcd;\r\nif (hcd->driver->shutdown)\r\nhcd->driver->shutdown(hcd);\r\n}
