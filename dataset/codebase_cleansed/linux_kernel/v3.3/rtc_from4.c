static void rtc_from4_hwcontrol(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *chip = (mtd->priv);\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\nwriteb(cmd, chip->IO_ADDR_W | RTC_FROM4_CLE);\r\nelse\r\nwriteb(cmd, chip->IO_ADDR_W | RTC_FROM4_ALE);\r\n}\r\nstatic void rtc_from4_nand_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nthis->IO_ADDR_R = (void __iomem *)((unsigned long)this->IO_ADDR_R & ~RTC_FROM4_NAND_ADDR_MASK);\r\nthis->IO_ADDR_W = (void __iomem *)((unsigned long)this->IO_ADDR_W & ~RTC_FROM4_NAND_ADDR_MASK);\r\nswitch (chip) {\r\ncase 0:\r\nthis->IO_ADDR_R = (void __iomem *)((unsigned long)this->IO_ADDR_R | RTC_FROM4_NAND_ADDR_SLOT3);\r\nthis->IO_ADDR_W = (void __iomem *)((unsigned long)this->IO_ADDR_W | RTC_FROM4_NAND_ADDR_SLOT3);\r\nbreak;\r\ncase 1:\r\nthis->IO_ADDR_R = (void __iomem *)((unsigned long)this->IO_ADDR_R | RTC_FROM4_NAND_ADDR_SLOT4);\r\nthis->IO_ADDR_W = (void __iomem *)((unsigned long)this->IO_ADDR_W | RTC_FROM4_NAND_ADDR_SLOT4);\r\nbreak;\r\n}\r\n}\r\nstatic int rtc_from4_nand_device_ready(struct mtd_info *mtd)\r\n{\r\nunsigned short status;\r\nstatus = *((volatile unsigned short *)(rtc_from4_fio_base + RTC_FROM4_FPGA_SR));\r\nreturn (status & RTC_FROM4_DEVICE_READY);\r\n}\r\nstatic void deplete(struct mtd_info *mtd, int chip)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nwhile (!this->dev_ready(mtd)) ;\r\nthis->select_chip(mtd, chip);\r\nthis->cmdfunc(mtd, NAND_CMD_DEPLETE1, 0x0000, 0x0000);\r\nthis->cmdfunc(mtd, NAND_CMD_DEPLETE2, -1, -1);\r\nthis->cmdfunc(mtd, NAND_CMD_DEPLETE1, 0x0000, 0x0004);\r\nthis->cmdfunc(mtd, NAND_CMD_DEPLETE2, -1, -1);\r\n}\r\nstatic void rtc_from4_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nvolatile unsigned short *rs_ecc_ctl = (volatile unsigned short *)(rtc_from4_fio_base + RTC_FROM4_RS_ECC_CTL);\r\nunsigned short status;\r\nswitch (mode) {\r\ncase NAND_ECC_READ:\r\nstatus = RTC_FROM4_RS_ECC_CTL_CLR | RTC_FROM4_RS_ECC_CTL_FD_E;\r\n*rs_ecc_ctl = status;\r\nbreak;\r\ncase NAND_ECC_READSYN:\r\nstatus = 0x00;\r\n*rs_ecc_ctl = status;\r\nbreak;\r\ncase NAND_ECC_WRITE:\r\nstatus = RTC_FROM4_RS_ECC_CTL_CLR | RTC_FROM4_RS_ECC_CTL_GEN | RTC_FROM4_RS_ECC_CTL_FD_E;\r\n*rs_ecc_ctl = status;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nstatic void rtc_from4_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)\r\n{\r\nvolatile unsigned short *rs_eccn = (volatile unsigned short *)(rtc_from4_fio_base + RTC_FROM4_RS_ECCN);\r\nunsigned short value;\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nvalue = *rs_eccn;\r\necc_code[i] = (unsigned char)value;\r\nrs_eccn++;\r\n}\r\necc_code[7] |= 0x0f;\r\n}\r\nstatic int rtc_from4_correct_data(struct mtd_info *mtd, const u_char *buf, u_char *ecc1, u_char *ecc2)\r\n{\r\nint i, j, res;\r\nunsigned short status;\r\nuint16_t par[6], syn[6];\r\nuint8_t ecc[8];\r\nvolatile unsigned short *rs_ecc;\r\nstatus = *((volatile unsigned short *)(rtc_from4_fio_base + RTC_FROM4_RS_ECC_CHK));\r\nif (!(status & RTC_FROM4_RS_ECC_CHK_ERROR)) {\r\nreturn 0;\r\n}\r\nrs_ecc = (volatile unsigned short *)(rtc_from4_fio_base + RTC_FROM4_RS_ECC);\r\nfor (i = 0; i < 8; i++) {\r\necc[i] = bitrev8(*rs_ecc);\r\nrs_ecc++;\r\n}\r\npar[5] = rs_decoder->index_of[(((uint16_t) ecc[0] >> 0) & 0x0ff) | (((uint16_t) ecc[1] << 8) & 0x300)];\r\npar[4] = rs_decoder->index_of[(((uint16_t) ecc[1] >> 2) & 0x03f) | (((uint16_t) ecc[2] << 6) & 0x3c0)];\r\npar[3] = rs_decoder->index_of[(((uint16_t) ecc[2] >> 4) & 0x00f) | (((uint16_t) ecc[3] << 4) & 0x3f0)];\r\npar[2] = rs_decoder->index_of[(((uint16_t) ecc[3] >> 6) & 0x003) | (((uint16_t) ecc[4] << 2) & 0x3fc)];\r\npar[1] = rs_decoder->index_of[(((uint16_t) ecc[5] >> 0) & 0x0ff) | (((uint16_t) ecc[6] << 8) & 0x300)];\r\npar[0] = (((uint16_t) ecc[6] >> 2) & 0x03f) | (((uint16_t) ecc[7] << 6) & 0x3c0);\r\nfor (i = 0; i < 6; i++) {\r\nsyn[i] = par[0];\r\nfor (j = 1; j < 6; j++)\r\nif (par[j] != rs_decoder->nn)\r\nsyn[i] ^= rs_decoder->alpha_to[rs_modnn(rs_decoder, par[j] + i * j)];\r\nsyn[i] = rs_decoder->index_of[syn[i]];\r\n}\r\nres = decode_rs8(rs_decoder, (uint8_t *) buf, par, 512, syn, 0, NULL, 0xff, NULL);\r\nif (res > 0) {\r\npr_debug("rtc_from4_correct_data: " "ECC corrected %d errors on read\n", res);\r\n}\r\nreturn res;\r\n}\r\nstatic int rtc_from4_errstat(struct mtd_info *mtd, struct nand_chip *this,\r\nint state, int status, int page)\r\n{\r\nint er_stat = 0;\r\nint rtn, retlen;\r\nsize_t len;\r\nuint8_t *buf;\r\nint i;\r\nthis->cmdfunc(mtd, NAND_CMD_STATUS_CLEAR, -1, -1);\r\nif (state == FL_ERASING) {\r\nfor (i = 0; i < 4; i++) {\r\nif (!(status & 1 << (i + 1)))\r\ncontinue;\r\nthis->cmdfunc(mtd, (NAND_CMD_STATUS_ERROR + i + 1),\r\n-1, -1);\r\nrtn = this->read_byte(mtd);\r\nthis->cmdfunc(mtd, NAND_CMD_STATUS_RESET, -1, -1);\r\nif (!(rtn & ERR_STAT_ECC_AVAILABLE))\r\ner_stat |= 1 << (i + 1);\r\n}\r\n} else if (state == FL_WRITING) {\r\nunsigned long corrected = mtd->ecc_stats.corrected;\r\nthis->cmdfunc(mtd, NAND_CMD_STATUS_ERROR, -1, -1);\r\nrtn = this->read_byte(mtd);\r\nthis->cmdfunc(mtd, NAND_CMD_STATUS_RESET, -1, -1);\r\nif (!(rtn & ERR_STAT_ECC_AVAILABLE)) {\r\ner_stat |= 1 << 1;\r\ngoto out;\r\n}\r\nlen = mtd->writesize;\r\nbuf = kmalloc(len, GFP_KERNEL);\r\nif (!buf) {\r\ner_stat = 1;\r\ngoto out;\r\n}\r\nrtn = nand_do_read(mtd, page, len, &retlen, buf);\r\nif (rtn || (mtd->ecc_stats.corrected - corrected) > 1)\r\ner_stat |= 1 << 1;\r\nkfree(buf);\r\n}\r\nout:\r\nrtn = status;\r\nif (er_stat == 0) {\r\nrtn = (status & ~NAND_STATUS_FAIL);\r\n}\r\nreturn rtn;\r\n}\r\nstatic int __init rtc_from4_init(void)\r\n{\r\nstruct nand_chip *this;\r\nunsigned short bcr1, bcr2, wcr2;\r\nint i;\r\nint ret;\r\nrtc_from4_mtd = kmalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip), GFP_KERNEL);\r\nif (!rtc_from4_mtd) {\r\nprintk("Unable to allocate Renesas NAND MTD device structure.\n");\r\nreturn -ENOMEM;\r\n}\r\nthis = (struct nand_chip *)(&rtc_from4_mtd[1]);\r\nmemset(rtc_from4_mtd, 0, sizeof(struct mtd_info));\r\nmemset(this, 0, sizeof(struct nand_chip));\r\nrtc_from4_mtd->priv = this;\r\nrtc_from4_mtd->owner = THIS_MODULE;\r\nbcr1 = *SH77X9_BCR1 & ~0x0002;\r\nbcr1 |= 0x0002;\r\n*SH77X9_BCR1 = bcr1;\r\nbcr2 = *SH77X9_BCR2 & ~0x0c00;\r\nbcr2 |= 0x0800;\r\n*SH77X9_BCR2 = bcr2;\r\nwcr2 = *SH77X9_WCR2 & ~0x1c00;\r\nwcr2 |= 0x1c00;\r\n*SH77X9_WCR2 = wcr2;\r\nthis->IO_ADDR_R = rtc_from4_fio_base;\r\nthis->IO_ADDR_W = rtc_from4_fio_base;\r\nthis->cmd_ctrl = rtc_from4_hwcontrol;\r\nthis->select_chip = rtc_from4_nand_select_chip;\r\nthis->chip_delay = 100;\r\nthis->dev_ready = rtc_from4_nand_device_ready;\r\n#ifdef RTC_FROM4_HWECC\r\nprintk(KERN_INFO "rtc_from4_init: using hardware ECC detection.\n");\r\nthis->ecc.mode = NAND_ECC_HW_SYNDROME;\r\nthis->ecc.size = 512;\r\nthis->ecc.bytes = 8;\r\nthis->errstat = rtc_from4_errstat;\r\nthis->ecc.layout = &rtc_from4_nand_oobinfo;\r\nthis->ecc.hwctl = rtc_from4_enable_hwecc;\r\nthis->ecc.calculate = rtc_from4_calculate_ecc;\r\nthis->ecc.correct = rtc_from4_correct_data;\r\nrs_decoder = init_rs(10, 0x409, 0, 1, 6);\r\nif (!rs_decoder) {\r\nprintk(KERN_ERR "Could not create a RS decoder\n");\r\nret = -ENOMEM;\r\ngoto err_1;\r\n}\r\n#else\r\nprintk(KERN_INFO "rtc_from4_init: using software ECC detection.\n");\r\nthis->ecc.mode = NAND_ECC_SOFT;\r\n#endif\r\nthis->bbt_td = &rtc_from4_bbt_main_descr;\r\nthis->bbt_md = &rtc_from4_bbt_mirror_descr;\r\nif (nand_scan(rtc_from4_mtd, RTC_FROM4_MAX_CHIPS)) {\r\nret = -ENXIO;\r\ngoto err_2;\r\n}\r\nfor (i = 0; i < this->numchips; i++) {\r\ndeplete(rtc_from4_mtd, i);\r\n}\r\n#if RTC_FROM4_NO_VIRTBLOCKS\r\nrtc_from4_mtd->flags |= MTD_NO_VIRTBLOCKS;\r\n#endif\r\nret = mtd_device_register(rtc_from4_mtd, partition_info,\r\nNUM_PARTITIONS);\r\nif (ret)\r\ngoto err_3;\r\nreturn 0;\r\nerr_3:\r\nnand_release(rtc_from4_mtd);\r\nerr_2:\r\nfree_rs(rs_decoder);\r\nerr_1:\r\nkfree(rtc_from4_mtd);\r\nreturn ret;\r\n}\r\nstatic void __exit rtc_from4_cleanup(void)\r\n{\r\nnand_release(rtc_from4_mtd);\r\nkfree(rtc_from4_mtd);\r\n#ifdef RTC_FROM4_HWECC\r\nif (rs_decoder) {\r\nfree_rs(rs_decoder);\r\n}\r\n#endif\r\n}
