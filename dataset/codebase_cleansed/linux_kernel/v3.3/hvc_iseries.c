static void hvlog(char *fmt, ...)\r\n{\r\nint i;\r\nunsigned long flags;\r\nva_list args;\r\nstatic char buf[256];\r\nspin_lock_irqsave(&consoleloglock, flags);\r\nva_start(args, fmt);\r\ni = vscnprintf(buf, sizeof(buf) - 1, fmt, args);\r\nva_end(args);\r\nbuf[i++] = '\r';\r\nHvCall_writeLogBuffer(buf, i);\r\nspin_unlock_irqrestore(&consoleloglock, flags);\r\n}\r\nstatic void init_data_event(struct viocharlpevent *viochar, HvLpIndex lp)\r\n{\r\nstruct HvLpEvent *hev = &viochar->event;\r\nmemset(viochar, 0, sizeof(struct viocharlpevent));\r\nhev->flags = HV_LP_EVENT_VALID | HV_LP_EVENT_DEFERRED_ACK |\r\nHV_LP_EVENT_INT;\r\nhev->xType = HvLpEvent_Type_VirtualIo;\r\nhev->xSubtype = viomajorsubtype_chario | viochardata;\r\nhev->xSourceLp = HvLpConfig_getLpIndex();\r\nhev->xTargetLp = lp;\r\nhev->xSizeMinus1 = sizeof(struct viocharlpevent);\r\nhev->xSourceInstanceId = viopath_sourceinst(lp);\r\nhev->xTargetInstanceId = viopath_targetinst(lp);\r\n}\r\nstatic int get_chars(uint32_t vtermno, char *buf, int count)\r\n{\r\nstruct port_info *pi;\r\nint n = 0;\r\nunsigned long flags;\r\nif (vtermno >= VTTY_PORTS)\r\nreturn -EINVAL;\r\nif (count == 0)\r\nreturn 0;\r\npi = &port_info[vtermno];\r\nspin_lock_irqsave(&consolelock, flags);\r\nif (pi->in_end == 0)\r\ngoto done;\r\nn = pi->in_end - pi->in_start;\r\nif (n > count)\r\nn = count;\r\nmemcpy(buf, &pi->in_buf[pi->in_start], n);\r\npi->in_start += n;\r\nif (pi->in_start == pi->in_end) {\r\npi->in_start = 0;\r\npi->in_end = 0;\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&consolelock, flags);\r\nreturn n;\r\n}\r\nstatic int put_chars(uint32_t vtermno, const char *buf, int count)\r\n{\r\nstruct viocharlpevent *viochar;\r\nstruct port_info *pi;\r\nHvLpEvent_Rc hvrc;\r\nunsigned long flags;\r\nint sent = 0;\r\nif (vtermno >= VTTY_PORTS)\r\nreturn -EINVAL;\r\npi = &port_info[vtermno];\r\nspin_lock_irqsave(&consolelock, flags);\r\nif (viochar_is_console(pi) && !viopath_isactive(pi->lp)) {\r\nHvCall_writeLogBuffer(buf, count);\r\nsent = count;\r\ngoto done;\r\n}\r\nviochar = vio_get_event_buffer(viomajorsubtype_chario);\r\nif (viochar == NULL) {\r\nhvlog("\n\rviocons: Can't get viochar buffer.");\r\ngoto done;\r\n}\r\nwhile ((count > 0) && ((pi->seq - pi->ack) < VIOCHAR_WINDOW)) {\r\nint len;\r\nlen = (count > VIOCHAR_MAX_DATA) ? VIOCHAR_MAX_DATA : count;\r\nif (viochar_is_console(pi))\r\nHvCall_writeLogBuffer(buf, len);\r\ninit_data_event(viochar, pi->lp);\r\nviochar->len = len;\r\nviochar->event.xCorrelationToken = pi->seq++;\r\nviochar->event.xSizeMinus1 =\r\noffsetof(struct viocharlpevent, data) + len;\r\nmemcpy(viochar->data, buf, len);\r\nhvrc = HvCallEvent_signalLpEvent(&viochar->event);\r\nif (hvrc)\r\nhvlog("\n\rerror sending event! return code %d\n\r",\r\n(int)hvrc);\r\nsent += len;\r\ncount -= len;\r\nbuf += len;\r\n}\r\nvio_free_event_buffer(viomajorsubtype_chario, viochar);\r\ndone:\r\nspin_unlock_irqrestore(&consolelock, flags);\r\nreturn sent;\r\n}\r\nstatic int __devinit hvc_vio_probe(struct vio_dev *vdev,\r\nconst struct vio_device_id *id)\r\n{\r\nstruct hvc_struct *hp;\r\nstruct port_info *pi;\r\nif (!vdev || !id)\r\nreturn -EPERM;\r\nif (vdev->unit_address >= VTTY_PORTS)\r\nreturn -ENODEV;\r\npi = &port_info[vdev->unit_address];\r\nhp = hvc_alloc(vdev->unit_address, vdev->irq, &hvc_get_put_ops,\r\nVIOCHAR_MAX_DATA);\r\nif (IS_ERR(hp))\r\nreturn PTR_ERR(hp);\r\npi->hp = hp;\r\ndev_set_drvdata(&vdev->dev, pi);\r\nreturn 0;\r\n}\r\nstatic int __devexit hvc_vio_remove(struct vio_dev *vdev)\r\n{\r\nstruct port_info *pi = dev_get_drvdata(&vdev->dev);\r\nstruct hvc_struct *hp = pi->hp;\r\nreturn hvc_remove(hp);\r\n}\r\nstatic void hvc_open_event(struct HvLpEvent *event)\r\n{\r\nunsigned long flags;\r\nstruct viocharlpevent *cevent = (struct viocharlpevent *)event;\r\nu8 port = cevent->virtual_device;\r\nstruct port_info *pi;\r\nint reject = 0;\r\nif (hvlpevent_is_ack(event)) {\r\nif (port >= VTTY_PORTS)\r\nreturn;\r\nspin_lock_irqsave(&consolelock, flags);\r\npi = &port_info[port];\r\nif (event->xRc == HvLpEvent_Rc_Good) {\r\npi->seq = pi->ack = 0;\r\npi->lp = event->xTargetLp;\r\n}\r\nspin_unlock_irqrestore(&consolelock, flags);\r\nif (event->xRc != HvLpEvent_Rc_Good)\r\nprintk(KERN_WARNING\r\n"hvc: handle_open_event: event->xRc == (%d).\n",\r\nevent->xRc);\r\nif (event->xCorrelationToken != 0) {\r\natomic_t *aptr= (atomic_t *)event->xCorrelationToken;\r\natomic_set(aptr, 1);\r\n} else\r\nprintk(KERN_WARNING\r\n"hvc: weird...got open ack without atomic\n");\r\nreturn;\r\n}\r\nif (!hvlpevent_need_ack(event)) {\r\nprintk(KERN_WARNING "hvc: viocharopen without ack bit!\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&consolelock, flags);\r\nif (port >= VTTY_PORTS) {\r\nevent->xRc = HvLpEvent_Rc_SubtypeError;\r\ncevent->subtype_result_code = viorc_openRejected;\r\nreject = 1;\r\n} else {\r\npi = &port_info[port];\r\nif ((pi->lp != HvLpIndexInvalid) &&\r\n(pi->lp != event->xSourceLp)) {\r\nevent->xRc = HvLpEvent_Rc_SubtypeError;\r\ncevent->subtype_result_code = viorc_openRejected;\r\nreject = 2;\r\n} else {\r\npi->lp = event->xSourceLp;\r\nevent->xRc = HvLpEvent_Rc_Good;\r\ncevent->subtype_result_code = viorc_good;\r\npi->seq = pi->ack = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&consolelock, flags);\r\nif (reject == 1)\r\nprintk(KERN_WARNING "hvc: open rejected: bad virtual tty.\n");\r\nelse if (reject == 2)\r\nprintk(KERN_WARNING "hvc: open rejected: console in exclusive "\r\n"use by another partition.\n");\r\nHvCallEvent_ackLpEvent(event);\r\n}\r\nstatic void hvc_close_event(struct HvLpEvent *event)\r\n{\r\nunsigned long flags;\r\nstruct viocharlpevent *cevent = (struct viocharlpevent *)event;\r\nu8 port = cevent->virtual_device;\r\nif (!hvlpevent_is_int(event)) {\r\nprintk(KERN_WARNING\r\n"hvc: got unexpected close acknowledgement\n");\r\nreturn;\r\n}\r\nif (port >= VTTY_PORTS) {\r\nprintk(KERN_WARNING\r\n"hvc: close message from invalid virtual device.\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&consolelock, flags);\r\nif (port_info[port].lp == event->xSourceLp)\r\nport_info[port].lp = HvLpIndexInvalid;\r\nspin_unlock_irqrestore(&consolelock, flags);\r\n}\r\nstatic void hvc_data_event(struct HvLpEvent *event)\r\n{\r\nunsigned long flags;\r\nstruct viocharlpevent *cevent = (struct viocharlpevent *)event;\r\nstruct port_info *pi;\r\nint n;\r\nu8 port = cevent->virtual_device;\r\nif (port >= VTTY_PORTS) {\r\nprintk(KERN_WARNING "hvc: data on invalid virtual device %d\n",\r\nport);\r\nreturn;\r\n}\r\nif (cevent->len == 0)\r\nreturn;\r\npi = &port_info[port];\r\nif (pi->lp != event->xSourceLp)\r\nreturn;\r\nspin_lock_irqsave(&consolelock, flags);\r\nn = IN_BUF_SIZE - pi->in_end;\r\nif (n > cevent->len)\r\nn = cevent->len;\r\nif (n > 0) {\r\nmemcpy(&pi->in_buf[pi->in_end], cevent->data, n);\r\npi->in_end += n;\r\n}\r\nspin_unlock_irqrestore(&consolelock, flags);\r\nif (n == 0)\r\nprintk(KERN_WARNING "hvc: input buffer overflow\n");\r\n}\r\nstatic void hvc_ack_event(struct HvLpEvent *event)\r\n{\r\nstruct viocharlpevent *cevent = (struct viocharlpevent *)event;\r\nunsigned long flags;\r\nu8 port = cevent->virtual_device;\r\nif (port >= VTTY_PORTS) {\r\nprintk(KERN_WARNING "hvc: data on invalid virtual device\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&consolelock, flags);\r\nport_info[port].ack = event->xCorrelationToken;\r\nspin_unlock_irqrestore(&consolelock, flags);\r\n}\r\nstatic void hvc_config_event(struct HvLpEvent *event)\r\n{\r\nstruct viocharlpevent *cevent = (struct viocharlpevent *)event;\r\nif (cevent->data[0] == 0x01)\r\nprintk(KERN_INFO "hvc: window resized to %d: %d: %d: %d\n",\r\ncevent->data[1], cevent->data[2],\r\ncevent->data[3], cevent->data[4]);\r\nelse\r\nprintk(KERN_WARNING "hvc: unknown config event\n");\r\n}\r\nstatic void hvc_handle_event(struct HvLpEvent *event)\r\n{\r\nint charminor;\r\nif (event == NULL)\r\nreturn;\r\ncharminor = event->xSubtype & VIOMINOR_SUBTYPE_MASK;\r\nswitch (charminor) {\r\ncase viocharopen:\r\nhvc_open_event(event);\r\nbreak;\r\ncase viocharclose:\r\nhvc_close_event(event);\r\nbreak;\r\ncase viochardata:\r\nhvc_data_event(event);\r\nbreak;\r\ncase viocharack:\r\nhvc_ack_event(event);\r\nbreak;\r\ncase viocharconfig:\r\nhvc_config_event(event);\r\nbreak;\r\ndefault:\r\nif (hvlpevent_is_int(event) && hvlpevent_need_ack(event)) {\r\nevent->xRc = HvLpEvent_Rc_InvalidSubtype;\r\nHvCallEvent_ackLpEvent(event);\r\n}\r\n}\r\n}\r\nstatic int __init send_open(HvLpIndex remoteLp, void *sem)\r\n{\r\nreturn HvCallEvent_signalLpEventFast(remoteLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_chario | viocharopen,\r\nHvLpEvent_AckInd_DoAck, HvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(remoteLp),\r\nviopath_targetinst(remoteLp),\r\n(u64)(unsigned long)sem, VIOVERSION << 16,\r\n0, 0, 0, 0);\r\n}\r\nstatic int __init hvc_vio_init(void)\r\n{\r\natomic_t wait_flag;\r\nint rc;\r\nif (!firmware_has_feature(FW_FEATURE_ISERIES))\r\nreturn -EIO;\r\nrc = viopath_open(HvLpConfig_getPrimaryLpIndex(),\r\nviomajorsubtype_chario, VIOCHAR_WINDOW + 2);\r\nif (rc)\r\nprintk(KERN_WARNING "hvc: error opening to primary %d\n", rc);\r\nif (viopath_hostLp == HvLpIndexInvalid)\r\nvio_set_hostlp();\r\nif ((viopath_hostLp != HvLpIndexInvalid) &&\r\n(viopath_hostLp != HvLpConfig_getPrimaryLpIndex())) {\r\nprintk(KERN_INFO "hvc: open path to hosting (%d)\n",\r\nviopath_hostLp);\r\nrc = viopath_open(viopath_hostLp, viomajorsubtype_chario,\r\nVIOCHAR_WINDOW + 2);\r\nif (rc)\r\nprintk(KERN_WARNING\r\n"error opening to partition %d: %d\n",\r\nviopath_hostLp, rc);\r\n}\r\nif (vio_setHandler(viomajorsubtype_chario, hvc_handle_event) < 0)\r\nprintk(KERN_WARNING\r\n"hvc: error seting handler for console events!\n");\r\natomic_set(&wait_flag, 0);\r\nif ((viopath_isactive(viopath_hostLp)) &&\r\n(send_open(viopath_hostLp, &wait_flag) == 0)) {\r\nprintk(KERN_INFO "hvc: hosting partition %d\n", viopath_hostLp);\r\nwhile (atomic_read(&wait_flag) == 0)\r\nmb();\r\natomic_set(&wait_flag, 0);\r\n}\r\nif ((!viopath_isactive(port_info[0].lp)) &&\r\n(viopath_isactive(HvLpConfig_getPrimaryLpIndex())) &&\r\n(send_open(HvLpConfig_getPrimaryLpIndex(), &wait_flag) == 0)) {\r\nprintk(KERN_INFO "hvc: opening console to primary partition\n");\r\nwhile (atomic_read(&wait_flag) == 0)\r\nmb();\r\n}\r\nrc = vio_register_driver(&hvc_vio_driver);\r\nreturn rc;\r\n}\r\nstatic void __exit hvc_vio_exit(void)\r\n{\r\nvio_unregister_driver(&hvc_vio_driver);\r\n}\r\nstatic int __init hvc_find_vtys(void)\r\n{\r\nstruct device_node *vty;\r\nint num_found = 0;\r\nfor (vty = of_find_node_by_name(NULL, "vty"); vty != NULL;\r\nvty = of_find_node_by_name(vty, "vty")) {\r\nconst uint32_t *vtermno;\r\nif ((num_found >= MAX_NR_HVC_CONSOLES) ||\r\n(num_found >= VTTY_PORTS)) {\r\nof_node_put(vty);\r\nbreak;\r\n}\r\nvtermno = of_get_property(vty, "reg", NULL);\r\nif (!vtermno)\r\ncontinue;\r\nif (!of_device_is_compatible(vty, "IBM,iSeries-vty"))\r\ncontinue;\r\nif (num_found == 0)\r\nadd_preferred_console("hvc", 0, NULL);\r\nhvc_instantiate(*vtermno, num_found, &hvc_get_put_ops);\r\n++num_found;\r\n}\r\nreturn num_found;\r\n}
