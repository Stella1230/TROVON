struct gh_t_hash_tab *gh_create(u16 max_bucket, u16 val_size,\r\nu16(*hash) (void *, u16), bool(*match) (void *,\r\nvoid *),\r\nvoid (*delete) (void *))\r\n{\r\nstruct gh_t_hash_tab *hash_tab;\r\nu16 i;\r\nhash_tab = kzalloc(sizeof(struct gh_t_hash_tab), GFP_KERNEL);\r\nif (hash_tab == NULL)\r\nreturn NULL;\r\nhash_tab->max_bucket = max_bucket;\r\nhash_tab->val_size = val_size;\r\nhash_tab->hash = hash;\r\nhash_tab->match = match;\r\nhash_tab->delete = delete == NULL ? noop : delete;\r\nhash_tab->buckets =\r\nkzalloc(sizeof(struct element *) * max_bucket, GFP_KERNEL);\r\nif (hash_tab->buckets == NULL) {\r\ngh_delete(hash_tab);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < max_bucket; i++)\r\nhash_tab->buckets[i] = NULL;\r\nreturn hash_tab;\r\n}\r\nvoid gh_delete(struct gh_t_hash_tab *hash_tab)\r\n{\r\nstruct element *elem, *next;\r\nu16 i;\r\nif (hash_tab != NULL) {\r\nif (hash_tab->buckets != NULL) {\r\nfor (i = 0; i < hash_tab->max_bucket; i++) {\r\nfor (elem = hash_tab->buckets[i]; elem != NULL;\r\nelem = next) {\r\nnext = elem->next;\r\n(*hash_tab->delete) (elem->data);\r\nkfree(elem);\r\n}\r\n}\r\nkfree(hash_tab->buckets);\r\n}\r\nkfree(hash_tab);\r\n}\r\n}\r\nvoid gh_exit(void)\r\n{\r\n}\r\nvoid *gh_find(struct gh_t_hash_tab *hash_tab, void *key)\r\n{\r\nstruct element *elem;\r\nelem = hash_tab->buckets[(*hash_tab->hash) (key, hash_tab->max_bucket)];\r\nfor (; elem; elem = elem->next) {\r\nif ((*hash_tab->match) (key, elem->data))\r\nreturn elem->data;\r\n}\r\nreturn NULL;\r\n}\r\nvoid gh_init(void)\r\n{\r\n}\r\nvoid *gh_insert(struct gh_t_hash_tab *hash_tab, void *key, void *value)\r\n{\r\nstruct element *elem;\r\nu16 i;\r\nchar *src, *dst;\r\nelem = kzalloc(sizeof(struct element) - 1 + hash_tab->val_size,\r\nGFP_KERNEL);\r\nif (elem != NULL) {\r\ndst = (char *)elem->data;\r\nsrc = (char *)value;\r\nfor (i = 0; i < hash_tab->val_size; i++)\r\n*dst++ = *src++;\r\ni = (*hash_tab->hash) (key, hash_tab->max_bucket);\r\nelem->next = hash_tab->buckets[i];\r\nhash_tab->buckets[i] = elem;\r\nreturn elem->data;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void noop(void *p)\r\n{\r\np = p;\r\n}\r\nvoid gh_iterate(struct gh_t_hash_tab *hash_tab,\r\nvoid (*callback)(void *, void *), void *user_data)\r\n{\r\nstruct element *elem;\r\nu32 i;\r\nif (hash_tab && hash_tab->buckets)\r\nfor (i = 0; i < hash_tab->max_bucket; i++) {\r\nelem = hash_tab->buckets[i];\r\nwhile (elem) {\r\ncallback(&elem->data, user_data);\r\nelem = elem->next;\r\n}\r\n}\r\n}
