static int x25_queue_rx_frame(struct sock *sk, struct sk_buff *skb, int more)\r\n{\r\nstruct sk_buff *skbo, *skbn = skb;\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nif (more) {\r\nx25->fraglen += skb->len;\r\nskb_queue_tail(&x25->fragment_queue, skb);\r\nskb_set_owner_r(skb, sk);\r\nreturn 0;\r\n}\r\nif (!more && x25->fraglen > 0) {\r\nint len = x25->fraglen + skb->len;\r\nif ((skbn = alloc_skb(len, GFP_ATOMIC)) == NULL){\r\nkfree_skb(skb);\r\nreturn 1;\r\n}\r\nskb_queue_tail(&x25->fragment_queue, skb);\r\nskb_reset_transport_header(skbn);\r\nskbo = skb_dequeue(&x25->fragment_queue);\r\nskb_copy_from_linear_data(skbo, skb_put(skbn, skbo->len),\r\nskbo->len);\r\nkfree_skb(skbo);\r\nwhile ((skbo =\r\nskb_dequeue(&x25->fragment_queue)) != NULL) {\r\nskb_pull(skbo, (x25->neighbour->extended) ?\r\nX25_EXT_MIN_LEN : X25_STD_MIN_LEN);\r\nskb_copy_from_linear_data(skbo,\r\nskb_put(skbn, skbo->len),\r\nskbo->len);\r\nkfree_skb(skbo);\r\n}\r\nx25->fraglen = 0;\r\n}\r\nskb_set_owner_r(skbn, sk);\r\nskb_queue_tail(&sk->sk_receive_queue, skbn);\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_data_ready(sk, skbn->len);\r\nreturn 0;\r\n}\r\nstatic int x25_state1_machine(struct sock *sk, struct sk_buff *skb, int frametype)\r\n{\r\nstruct x25_address source_addr, dest_addr;\r\nint len;\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nswitch (frametype) {\r\ncase X25_CALL_ACCEPTED: {\r\nx25_stop_timer(sk);\r\nx25->condition = 0x00;\r\nx25->vs = 0;\r\nx25->va = 0;\r\nx25->vr = 0;\r\nx25->vl = 0;\r\nx25->state = X25_STATE_3;\r\nsk->sk_state = TCP_ESTABLISHED;\r\nif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\r\ngoto out_clear;\r\nskb_pull(skb, X25_STD_MIN_LEN);\r\nlen = x25_parse_address_block(skb, &source_addr,\r\n&dest_addr);\r\nif (len > 0)\r\nskb_pull(skb, len);\r\nelse if (len < 0)\r\ngoto out_clear;\r\nlen = x25_parse_facilities(skb, &x25->facilities,\r\n&x25->dte_facilities,\r\n&x25->vc_facil_mask);\r\nif (len > 0)\r\nskb_pull(skb, len);\r\nelse if (len < 0)\r\ngoto out_clear;\r\nif (skb->len > 0) {\r\nif (skb->len > X25_MAX_CUD_LEN)\r\ngoto out_clear;\r\nskb_copy_bits(skb, 0, x25->calluserdata.cuddata,\r\nskb->len);\r\nx25->calluserdata.cudlength = skb->len;\r\n}\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_state_change(sk);\r\nbreak;\r\n}\r\ncase X25_CLEAR_REQUEST:\r\nif (!pskb_may_pull(skb, X25_STD_MIN_LEN + 2))\r\ngoto out_clear;\r\nx25_write_internal(sk, X25_CLEAR_CONFIRMATION);\r\nx25_disconnect(sk, ECONNREFUSED, skb->data[3], skb->data[4]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\nout_clear:\r\nx25_write_internal(sk, X25_CLEAR_REQUEST);\r\nx25->state = X25_STATE_2;\r\nx25_start_t23timer(sk);\r\nreturn 0;\r\n}\r\nstatic int x25_state2_machine(struct sock *sk, struct sk_buff *skb, int frametype)\r\n{\r\nswitch (frametype) {\r\ncase X25_CLEAR_REQUEST:\r\nif (!pskb_may_pull(skb, X25_STD_MIN_LEN + 2))\r\ngoto out_clear;\r\nx25_write_internal(sk, X25_CLEAR_CONFIRMATION);\r\nx25_disconnect(sk, 0, skb->data[3], skb->data[4]);\r\nbreak;\r\ncase X25_CLEAR_CONFIRMATION:\r\nx25_disconnect(sk, 0, 0, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\nout_clear:\r\nx25_write_internal(sk, X25_CLEAR_REQUEST);\r\nx25_start_t23timer(sk);\r\nreturn 0;\r\n}\r\nstatic int x25_state3_machine(struct sock *sk, struct sk_buff *skb, int frametype, int ns, int nr, int q, int d, int m)\r\n{\r\nint queued = 0;\r\nint modulus;\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nmodulus = (x25->neighbour->extended) ? X25_EMODULUS : X25_SMODULUS;\r\nswitch (frametype) {\r\ncase X25_RESET_REQUEST:\r\nx25_write_internal(sk, X25_RESET_CONFIRMATION);\r\nx25_stop_timer(sk);\r\nx25->condition = 0x00;\r\nx25->vs = 0;\r\nx25->vr = 0;\r\nx25->va = 0;\r\nx25->vl = 0;\r\nx25_requeue_frames(sk);\r\nbreak;\r\ncase X25_CLEAR_REQUEST:\r\nif (!pskb_may_pull(skb, X25_STD_MIN_LEN + 2))\r\ngoto out_clear;\r\nx25_write_internal(sk, X25_CLEAR_CONFIRMATION);\r\nx25_disconnect(sk, 0, skb->data[3], skb->data[4]);\r\nbreak;\r\ncase X25_RR:\r\ncase X25_RNR:\r\nif (!x25_validate_nr(sk, nr)) {\r\nx25_clear_queues(sk);\r\nx25_write_internal(sk, X25_RESET_REQUEST);\r\nx25_start_t22timer(sk);\r\nx25->condition = 0x00;\r\nx25->vs = 0;\r\nx25->vr = 0;\r\nx25->va = 0;\r\nx25->vl = 0;\r\nx25->state = X25_STATE_4;\r\n} else {\r\nx25_frames_acked(sk, nr);\r\nif (frametype == X25_RNR) {\r\nx25->condition |= X25_COND_PEER_RX_BUSY;\r\n} else {\r\nx25->condition &= ~X25_COND_PEER_RX_BUSY;\r\n}\r\n}\r\nbreak;\r\ncase X25_DATA:\r\nx25->condition &= ~X25_COND_PEER_RX_BUSY;\r\nif ((ns != x25->vr) || !x25_validate_nr(sk, nr)) {\r\nx25_clear_queues(sk);\r\nx25_write_internal(sk, X25_RESET_REQUEST);\r\nx25_start_t22timer(sk);\r\nx25->condition = 0x00;\r\nx25->vs = 0;\r\nx25->vr = 0;\r\nx25->va = 0;\r\nx25->vl = 0;\r\nx25->state = X25_STATE_4;\r\nbreak;\r\n}\r\nx25_frames_acked(sk, nr);\r\nif (ns == x25->vr) {\r\nif (x25_queue_rx_frame(sk, skb, m) == 0) {\r\nx25->vr = (x25->vr + 1) % modulus;\r\nqueued = 1;\r\n} else {\r\nx25_clear_queues(sk);\r\nx25_write_internal(sk, X25_RESET_REQUEST);\r\nx25_start_t22timer(sk);\r\nx25->condition = 0x00;\r\nx25->vs = 0;\r\nx25->vr = 0;\r\nx25->va = 0;\r\nx25->vl = 0;\r\nx25->state = X25_STATE_4;\r\nbreak;\r\n}\r\nif (atomic_read(&sk->sk_rmem_alloc) >\r\n(sk->sk_rcvbuf >> 1))\r\nx25->condition |= X25_COND_OWN_RX_BUSY;\r\n}\r\nif (((x25->vl + x25->facilities.winsize_in) % modulus) == x25->vr) {\r\nx25->condition &= ~X25_COND_ACK_PENDING;\r\nx25_stop_timer(sk);\r\nx25_enquiry_response(sk);\r\n} else {\r\nx25->condition |= X25_COND_ACK_PENDING;\r\nx25_start_t2timer(sk);\r\n}\r\nbreak;\r\ncase X25_INTERRUPT_CONFIRMATION:\r\nclear_bit(X25_INTERRUPT_FLAG, &x25->flags);\r\nbreak;\r\ncase X25_INTERRUPT:\r\nif (sock_flag(sk, SOCK_URGINLINE))\r\nqueued = !sock_queue_rcv_skb(sk, skb);\r\nelse {\r\nskb_set_owner_r(skb, sk);\r\nskb_queue_tail(&x25->interrupt_in_queue, skb);\r\nqueued = 1;\r\n}\r\nsk_send_sigurg(sk);\r\nx25_write_internal(sk, X25_INTERRUPT_CONFIRMATION);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "x25: unknown %02X in state 3\n", frametype);\r\nbreak;\r\n}\r\nreturn queued;\r\nout_clear:\r\nx25_write_internal(sk, X25_CLEAR_REQUEST);\r\nx25->state = X25_STATE_2;\r\nx25_start_t23timer(sk);\r\nreturn 0;\r\n}\r\nstatic int x25_state4_machine(struct sock *sk, struct sk_buff *skb, int frametype)\r\n{\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nswitch (frametype) {\r\ncase X25_RESET_REQUEST:\r\nx25_write_internal(sk, X25_RESET_CONFIRMATION);\r\ncase X25_RESET_CONFIRMATION: {\r\nx25_stop_timer(sk);\r\nx25->condition = 0x00;\r\nx25->va = 0;\r\nx25->vr = 0;\r\nx25->vs = 0;\r\nx25->vl = 0;\r\nx25->state = X25_STATE_3;\r\nx25_requeue_frames(sk);\r\nbreak;\r\n}\r\ncase X25_CLEAR_REQUEST:\r\nif (!pskb_may_pull(skb, X25_STD_MIN_LEN + 2))\r\ngoto out_clear;\r\nx25_write_internal(sk, X25_CLEAR_CONFIRMATION);\r\nx25_disconnect(sk, 0, skb->data[3], skb->data[4]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\nout_clear:\r\nx25_write_internal(sk, X25_CLEAR_REQUEST);\r\nx25->state = X25_STATE_2;\r\nx25_start_t23timer(sk);\r\nreturn 0;\r\n}\r\nint x25_process_rx_frame(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nint queued = 0, frametype, ns, nr, q, d, m;\r\nif (x25->state == X25_STATE_0)\r\nreturn 0;\r\nframetype = x25_decode(sk, skb, &ns, &nr, &q, &d, &m);\r\nswitch (x25->state) {\r\ncase X25_STATE_1:\r\nqueued = x25_state1_machine(sk, skb, frametype);\r\nbreak;\r\ncase X25_STATE_2:\r\nqueued = x25_state2_machine(sk, skb, frametype);\r\nbreak;\r\ncase X25_STATE_3:\r\nqueued = x25_state3_machine(sk, skb, frametype, ns, nr, q, d, m);\r\nbreak;\r\ncase X25_STATE_4:\r\nqueued = x25_state4_machine(sk, skb, frametype);\r\nbreak;\r\n}\r\nx25_kick(sk);\r\nreturn queued;\r\n}\r\nint x25_backlog_rcv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nint queued = x25_process_rx_frame(sk, skb);\r\nif (!queued)\r\nkfree_skb(skb);\r\nreturn 0;\r\n}
