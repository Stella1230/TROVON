void snd_emu8000_poke(struct snd_emu8000 *emu, unsigned int port, unsigned int reg, unsigned int val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nif (reg != emu->last_reg) {\r\noutw((unsigned short)reg, EMU8000_PTR(emu));\r\nemu->last_reg = reg;\r\n}\r\noutw((unsigned short)val, port);\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\n}\r\nunsigned short snd_emu8000_peek(struct snd_emu8000 *emu, unsigned int port, unsigned int reg)\r\n{\r\nunsigned short res;\r\nunsigned long flags;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nif (reg != emu->last_reg) {\r\noutw((unsigned short)reg, EMU8000_PTR(emu));\r\nemu->last_reg = reg;\r\n}\r\nres = inw(port);\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn res;\r\n}\r\nvoid snd_emu8000_poke_dw(struct snd_emu8000 *emu, unsigned int port, unsigned int reg, unsigned int val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nif (reg != emu->last_reg) {\r\noutw((unsigned short)reg, EMU8000_PTR(emu));\r\nemu->last_reg = reg;\r\n}\r\noutw((unsigned short)val, port);\r\noutw((unsigned short)(val>>16), port+2);\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\n}\r\nunsigned int snd_emu8000_peek_dw(struct snd_emu8000 *emu, unsigned int port, unsigned int reg)\r\n{\r\nunsigned short low;\r\nunsigned int res;\r\nunsigned long flags;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nif (reg != emu->last_reg) {\r\noutw((unsigned short)reg, EMU8000_PTR(emu));\r\nemu->last_reg = reg;\r\n}\r\nlow = inw(port);\r\nres = low + (inw(port+2) << 16);\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn res;\r\n}\r\nvoid\r\nsnd_emu8000_dma_chan(struct snd_emu8000 *emu, int ch, int mode)\r\n{\r\nunsigned right_bit = (mode & EMU8000_RAM_RIGHT) ? 0x01000000 : 0;\r\nmode &= EMU8000_RAM_MODE_MASK;\r\nif (mode == EMU8000_RAM_CLOSE) {\r\nEMU8000_CCCA_WRITE(emu, ch, 0);\r\nEMU8000_DCYSUSV_WRITE(emu, ch, 0x807F);\r\nreturn;\r\n}\r\nEMU8000_DCYSUSV_WRITE(emu, ch, 0x80);\r\nEMU8000_VTFT_WRITE(emu, ch, 0);\r\nEMU8000_CVCF_WRITE(emu, ch, 0);\r\nEMU8000_PTRX_WRITE(emu, ch, 0x40000000);\r\nEMU8000_CPF_WRITE(emu, ch, 0x40000000);\r\nEMU8000_PSST_WRITE(emu, ch, 0);\r\nEMU8000_CSL_WRITE(emu, ch, 0);\r\nif (mode == EMU8000_RAM_WRITE)\r\nEMU8000_CCCA_WRITE(emu, ch, 0x06000000 | right_bit);\r\nelse\r\nEMU8000_CCCA_WRITE(emu, ch, 0x04000000 | right_bit);\r\n}\r\nstatic void __devinit\r\nsnd_emu8000_read_wait(struct snd_emu8000 *emu)\r\n{\r\nwhile ((EMU8000_SMALR_READ(emu) & 0x80000000) != 0) {\r\nschedule_timeout_interruptible(1);\r\nif (signal_pending(current))\r\nbreak;\r\n}\r\n}\r\nstatic void __devinit\r\nsnd_emu8000_write_wait(struct snd_emu8000 *emu)\r\n{\r\nwhile ((EMU8000_SMALW_READ(emu) & 0x80000000) != 0) {\r\nschedule_timeout_interruptible(1);\r\nif (signal_pending(current))\r\nbreak;\r\n}\r\n}\r\nstatic int __devinit\r\nsnd_emu8000_detect(struct snd_emu8000 *emu)\r\n{\r\nEMU8000_HWCF1_WRITE(emu, 0x0059);\r\nEMU8000_HWCF2_WRITE(emu, 0x0020);\r\nEMU8000_HWCF3_WRITE(emu, 0x0000);\r\nif ((EMU8000_HWCF1_READ(emu) & 0x007e) != 0x0058)\r\nreturn -ENODEV;\r\nif ((EMU8000_HWCF2_READ(emu) & 0x0003) != 0x0003)\r\nreturn -ENODEV;\r\nsnd_printdd("EMU8000 [0x%lx]: Synth chip found\n",\r\nemu->port1);\r\nreturn 0;\r\n}\r\nstatic void __devinit\r\ninit_audio(struct snd_emu8000 *emu)\r\n{\r\nint ch;\r\nfor (ch = 0; ch < EMU8000_CHANNELS; ch++)\r\nEMU8000_DCYSUSV_WRITE(emu, ch, 0x80);\r\nfor (ch = 0; ch < EMU8000_CHANNELS; ch++) {\r\nEMU8000_ENVVOL_WRITE(emu, ch, 0);\r\nEMU8000_ENVVAL_WRITE(emu, ch, 0);\r\nEMU8000_DCYSUS_WRITE(emu, ch, 0);\r\nEMU8000_ATKHLDV_WRITE(emu, ch, 0);\r\nEMU8000_LFO1VAL_WRITE(emu, ch, 0);\r\nEMU8000_ATKHLD_WRITE(emu, ch, 0);\r\nEMU8000_LFO2VAL_WRITE(emu, ch, 0);\r\nEMU8000_IP_WRITE(emu, ch, 0);\r\nEMU8000_IFATN_WRITE(emu, ch, 0);\r\nEMU8000_PEFE_WRITE(emu, ch, 0);\r\nEMU8000_FMMOD_WRITE(emu, ch, 0);\r\nEMU8000_TREMFRQ_WRITE(emu, ch, 0);\r\nEMU8000_FM2FRQ2_WRITE(emu, ch, 0);\r\nEMU8000_PTRX_WRITE(emu, ch, 0);\r\nEMU8000_VTFT_WRITE(emu, ch, 0);\r\nEMU8000_PSST_WRITE(emu, ch, 0);\r\nEMU8000_CSL_WRITE(emu, ch, 0);\r\nEMU8000_CCCA_WRITE(emu, ch, 0);\r\n}\r\nfor (ch = 0; ch < EMU8000_CHANNELS; ch++) {\r\nEMU8000_CPF_WRITE(emu, ch, 0);\r\nEMU8000_CVCF_WRITE(emu, ch, 0);\r\n}\r\n}\r\nstatic void __devinit\r\ninit_dma(struct snd_emu8000 *emu)\r\n{\r\nEMU8000_SMALR_WRITE(emu, 0);\r\nEMU8000_SMARR_WRITE(emu, 0);\r\nEMU8000_SMALW_WRITE(emu, 0);\r\nEMU8000_SMARW_WRITE(emu, 0);\r\n}\r\nstatic void __devinit\r\nsend_array(struct snd_emu8000 *emu, unsigned short *data, int size)\r\n{\r\nint i;\r\nunsigned short *p;\r\np = data;\r\nfor (i = 0; i < size; i++, p++)\r\nEMU8000_INIT1_WRITE(emu, i, *p);\r\nfor (i = 0; i < size; i++, p++)\r\nEMU8000_INIT2_WRITE(emu, i, *p);\r\nfor (i = 0; i < size; i++, p++)\r\nEMU8000_INIT3_WRITE(emu, i, *p);\r\nfor (i = 0; i < size; i++, p++)\r\nEMU8000_INIT4_WRITE(emu, i, *p);\r\n}\r\nstatic void __devinit\r\ninit_arrays(struct snd_emu8000 *emu)\r\n{\r\nsend_array(emu, init1, ARRAY_SIZE(init1)/4);\r\nmsleep((1024 * 1000) / 44100);\r\nsend_array(emu, init2, ARRAY_SIZE(init2)/4);\r\nsend_array(emu, init3, ARRAY_SIZE(init3)/4);\r\nEMU8000_HWCF4_WRITE(emu, 0);\r\nEMU8000_HWCF5_WRITE(emu, 0x83);\r\nEMU8000_HWCF6_WRITE(emu, 0x8000);\r\nsend_array(emu, init4, ARRAY_SIZE(init4)/4);\r\n}\r\nstatic void __devinit\r\nsize_dram(struct snd_emu8000 *emu)\r\n{\r\nint i, size, detected_size;\r\nif (emu->dram_checked)\r\nreturn;\r\nsize = 0;\r\ndetected_size = 0;\r\nsnd_emu8000_dma_chan(emu, 0, EMU8000_RAM_WRITE);\r\nsnd_emu8000_dma_chan(emu, 1, EMU8000_RAM_READ);\r\nEMU8000_SMALW_WRITE(emu, EMU8000_DRAM_OFFSET);\r\nEMU8000_SMLD_WRITE(emu, UNIQUE_ID1);\r\nsnd_emu8000_init_fm(emu);\r\nwhile (size < EMU8000_MAX_DRAM) {\r\nsize += 512 * 1024;\r\nEMU8000_SMALW_WRITE(emu, EMU8000_DRAM_OFFSET + (size>>1));\r\nEMU8000_SMLD_WRITE(emu, UNIQUE_ID2);\r\nsnd_emu8000_write_wait(emu);\r\nEMU8000_SMALR_WRITE(emu, EMU8000_DRAM_OFFSET + (size>>1));\r\nEMU8000_SMLD_READ(emu);\r\nif (EMU8000_SMLD_READ(emu) != UNIQUE_ID2)\r\nbreak;\r\ndetected_size = size;\r\nsnd_emu8000_read_wait(emu);\r\nEMU8000_SMALR_WRITE(emu, EMU8000_DRAM_OFFSET);\r\nEMU8000_SMLD_READ(emu);\r\nif (EMU8000_SMLD_READ(emu) != UNIQUE_ID1)\r\nbreak;\r\nsnd_emu8000_read_wait(emu);\r\n}\r\nfor (i = 0; i < 10000; i++) {\r\nif ((EMU8000_SMALW_READ(emu) & 0x80000000) == 0)\r\nbreak;\r\nschedule_timeout_interruptible(1);\r\nif (signal_pending(current))\r\nbreak;\r\n}\r\nsnd_emu8000_dma_chan(emu, 0, EMU8000_RAM_CLOSE);\r\nsnd_emu8000_dma_chan(emu, 1, EMU8000_RAM_CLOSE);\r\nsnd_printdd("EMU8000 [0x%lx]: %d Kb on-board memory detected\n",\r\nemu->port1, detected_size/1024);\r\nemu->mem_size = detected_size;\r\nemu->dram_checked = 1;\r\n}\r\nvoid\r\nsnd_emu8000_init_fm(struct snd_emu8000 *emu)\r\n{\r\nunsigned long flags;\r\nEMU8000_DCYSUSV_WRITE(emu, 30, 0x80);\r\nEMU8000_PSST_WRITE(emu, 30, 0xFFFFFFE0);\r\nEMU8000_CSL_WRITE(emu, 30, 0x00FFFFE8 | (emu->fm_chorus_depth << 24));\r\nEMU8000_PTRX_WRITE(emu, 30, (emu->fm_reverb_depth << 8));\r\nEMU8000_CPF_WRITE(emu, 30, 0);\r\nEMU8000_CCCA_WRITE(emu, 30, 0x00FFFFE3);\r\nEMU8000_DCYSUSV_WRITE(emu, 31, 0x80);\r\nEMU8000_PSST_WRITE(emu, 31, 0x00FFFFF0);\r\nEMU8000_CSL_WRITE(emu, 31, 0x00FFFFF8 | (emu->fm_chorus_depth << 24));\r\nEMU8000_PTRX_WRITE(emu, 31, (emu->fm_reverb_depth << 8));\r\nEMU8000_CPF_WRITE(emu, 31, 0x8000);\r\nEMU8000_CCCA_WRITE(emu, 31, 0x00FFFFF3);\r\nsnd_emu8000_poke((emu), EMU8000_DATA0(emu), EMU8000_CMD(1, (30)), 0);\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nwhile (!(inw(EMU8000_PTR(emu)) & 0x1000))\r\n;\r\nwhile ((inw(EMU8000_PTR(emu)) & 0x1000))\r\n;\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nsnd_emu8000_poke((emu), EMU8000_DATA0(emu), EMU8000_CMD(1, (30)), 0x4828);\r\noutb(0x3C, EMU8000_PTR(emu));\r\noutb(0, EMU8000_DATA1(emu));\r\nEMU8000_VTFT_WRITE(emu, 30, 0x8000FFFF);\r\nEMU8000_VTFT_WRITE(emu, 31, 0x8000FFFF);\r\n}\r\nstatic void __devinit\r\nsnd_emu8000_init_hw(struct snd_emu8000 *emu)\r\n{\r\nint i;\r\nemu->last_reg = 0xffff;\r\nEMU8000_HWCF1_WRITE(emu, 0x0059);\r\nEMU8000_HWCF2_WRITE(emu, 0x0020);\r\nEMU8000_HWCF3_WRITE(emu, 0);\r\ninit_audio(emu);\r\ninit_dma(emu);\r\ninit_arrays(emu);\r\nsnd_emu8000_init_fm(emu);\r\nfor (i = 0; i < EMU8000_DRAM_VOICES; i++)\r\nEMU8000_DCYSUSV_WRITE(emu, 0, 0x807F);\r\nsize_dram(emu);\r\nEMU8000_HWCF3_WRITE(emu, 0x4);\r\nsnd_emu8000_update_equalizer(emu);\r\nsnd_emu8000_update_chorus_mode(emu);\r\nsnd_emu8000_update_reverb_mode(emu);\r\n}\r\nvoid\r\nsnd_emu8000_update_equalizer(struct snd_emu8000 *emu)\r\n{\r\nunsigned short w;\r\nint bass = emu->bass_level;\r\nint treble = emu->treble_level;\r\nif (bass < 0 || bass > 11 || treble < 0 || treble > 11)\r\nreturn;\r\nEMU8000_INIT4_WRITE(emu, 0x01, bass_parm[bass][0]);\r\nEMU8000_INIT4_WRITE(emu, 0x11, bass_parm[bass][1]);\r\nEMU8000_INIT3_WRITE(emu, 0x11, treble_parm[treble][0]);\r\nEMU8000_INIT3_WRITE(emu, 0x13, treble_parm[treble][1]);\r\nEMU8000_INIT3_WRITE(emu, 0x1b, treble_parm[treble][2]);\r\nEMU8000_INIT4_WRITE(emu, 0x07, treble_parm[treble][3]);\r\nEMU8000_INIT4_WRITE(emu, 0x0b, treble_parm[treble][4]);\r\nEMU8000_INIT4_WRITE(emu, 0x0d, treble_parm[treble][5]);\r\nEMU8000_INIT4_WRITE(emu, 0x17, treble_parm[treble][6]);\r\nEMU8000_INIT4_WRITE(emu, 0x19, treble_parm[treble][7]);\r\nw = bass_parm[bass][2] + treble_parm[treble][8];\r\nEMU8000_INIT4_WRITE(emu, 0x15, (unsigned short)(w + 0x0262));\r\nEMU8000_INIT4_WRITE(emu, 0x1d, (unsigned short)(w + 0x8362));\r\n}\r\nint\r\nsnd_emu8000_load_chorus_fx(struct snd_emu8000 *emu, int mode, const void __user *buf, long len)\r\n{\r\nstruct soundfont_chorus_fx rec;\r\nif (mode < SNDRV_EMU8000_CHORUS_PREDEFINED || mode >= SNDRV_EMU8000_CHORUS_NUMBERS) {\r\nsnd_printk(KERN_WARNING "invalid chorus mode %d for uploading\n", mode);\r\nreturn -EINVAL;\r\n}\r\nif (len < (long)sizeof(rec) || copy_from_user(&rec, buf, sizeof(rec)))\r\nreturn -EFAULT;\r\nchorus_parm[mode] = rec;\r\nchorus_defined[mode] = 1;\r\nreturn 0;\r\n}\r\nvoid\r\nsnd_emu8000_update_chorus_mode(struct snd_emu8000 *emu)\r\n{\r\nint effect = emu->chorus_mode;\r\nif (effect < 0 || effect >= SNDRV_EMU8000_CHORUS_NUMBERS ||\r\n(effect >= SNDRV_EMU8000_CHORUS_PREDEFINED && !chorus_defined[effect]))\r\nreturn;\r\nEMU8000_INIT3_WRITE(emu, 0x09, chorus_parm[effect].feedback);\r\nEMU8000_INIT3_WRITE(emu, 0x0c, chorus_parm[effect].delay_offset);\r\nEMU8000_INIT4_WRITE(emu, 0x03, chorus_parm[effect].lfo_depth);\r\nEMU8000_HWCF4_WRITE(emu, chorus_parm[effect].delay);\r\nEMU8000_HWCF5_WRITE(emu, chorus_parm[effect].lfo_freq);\r\nEMU8000_HWCF6_WRITE(emu, 0x8000);\r\nEMU8000_HWCF7_WRITE(emu, 0x0000);\r\n}\r\nint\r\nsnd_emu8000_load_reverb_fx(struct snd_emu8000 *emu, int mode, const void __user *buf, long len)\r\n{\r\nstruct soundfont_reverb_fx rec;\r\nif (mode < SNDRV_EMU8000_REVERB_PREDEFINED || mode >= SNDRV_EMU8000_REVERB_NUMBERS) {\r\nsnd_printk(KERN_WARNING "invalid reverb mode %d for uploading\n", mode);\r\nreturn -EINVAL;\r\n}\r\nif (len < (long)sizeof(rec) || copy_from_user(&rec, buf, sizeof(rec)))\r\nreturn -EFAULT;\r\nreverb_parm[mode] = rec;\r\nreverb_defined[mode] = 1;\r\nreturn 0;\r\n}\r\nvoid\r\nsnd_emu8000_update_reverb_mode(struct snd_emu8000 *emu)\r\n{\r\nint effect = emu->reverb_mode;\r\nint i;\r\nif (effect < 0 || effect >= SNDRV_EMU8000_REVERB_NUMBERS ||\r\n(effect >= SNDRV_EMU8000_REVERB_PREDEFINED && !reverb_defined[effect]))\r\nreturn;\r\nfor (i = 0; i < 28; i++) {\r\nint port;\r\nif (reverb_cmds[i].port == DATA1)\r\nport = EMU8000_DATA1(emu);\r\nelse\r\nport = EMU8000_DATA2(emu);\r\nsnd_emu8000_poke(emu, port, reverb_cmds[i].cmd, reverb_parm[effect].parms[i]);\r\n}\r\n}\r\nstatic int mixer_bass_treble_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 11;\r\nreturn 0;\r\n}\r\nstatic int mixer_bass_treble_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu8000 *emu = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = kcontrol->private_value ? emu->treble_level : emu->bass_level;\r\nreturn 0;\r\n}\r\nstatic int mixer_bass_treble_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu8000 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint change;\r\nunsigned short val1;\r\nval1 = ucontrol->value.integer.value[0] % 12;\r\nspin_lock_irqsave(&emu->control_lock, flags);\r\nif (kcontrol->private_value) {\r\nchange = val1 != emu->treble_level;\r\nemu->treble_level = val1;\r\n} else {\r\nchange = val1 != emu->bass_level;\r\nemu->bass_level = val1;\r\n}\r\nspin_unlock_irqrestore(&emu->control_lock, flags);\r\nsnd_emu8000_update_equalizer(emu);\r\nreturn change;\r\n}\r\nstatic int mixer_chorus_reverb_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = kcontrol->private_value ? (SNDRV_EMU8000_CHORUS_NUMBERS-1) : (SNDRV_EMU8000_REVERB_NUMBERS-1);\r\nreturn 0;\r\n}\r\nstatic int mixer_chorus_reverb_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu8000 *emu = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = kcontrol->private_value ? emu->chorus_mode : emu->reverb_mode;\r\nreturn 0;\r\n}\r\nstatic int mixer_chorus_reverb_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu8000 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint change;\r\nunsigned short val1;\r\nspin_lock_irqsave(&emu->control_lock, flags);\r\nif (kcontrol->private_value) {\r\nval1 = ucontrol->value.integer.value[0] % SNDRV_EMU8000_CHORUS_NUMBERS;\r\nchange = val1 != emu->chorus_mode;\r\nemu->chorus_mode = val1;\r\n} else {\r\nval1 = ucontrol->value.integer.value[0] % SNDRV_EMU8000_REVERB_NUMBERS;\r\nchange = val1 != emu->reverb_mode;\r\nemu->reverb_mode = val1;\r\n}\r\nspin_unlock_irqrestore(&emu->control_lock, flags);\r\nif (change) {\r\nif (kcontrol->private_value)\r\nsnd_emu8000_update_chorus_mode(emu);\r\nelse\r\nsnd_emu8000_update_reverb_mode(emu);\r\n}\r\nreturn change;\r\n}\r\nstatic int mixer_fm_depth_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 255;\r\nreturn 0;\r\n}\r\nstatic int mixer_fm_depth_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu8000 *emu = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = kcontrol->private_value ? emu->fm_chorus_depth : emu->fm_reverb_depth;\r\nreturn 0;\r\n}\r\nstatic int mixer_fm_depth_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu8000 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint change;\r\nunsigned short val1;\r\nval1 = ucontrol->value.integer.value[0] % 256;\r\nspin_lock_irqsave(&emu->control_lock, flags);\r\nif (kcontrol->private_value) {\r\nchange = val1 != emu->fm_chorus_depth;\r\nemu->fm_chorus_depth = val1;\r\n} else {\r\nchange = val1 != emu->fm_reverb_depth;\r\nemu->fm_reverb_depth = val1;\r\n}\r\nspin_unlock_irqrestore(&emu->control_lock, flags);\r\nif (change)\r\nsnd_emu8000_init_fm(emu);\r\nreturn change;\r\n}\r\nstatic int __devinit\r\nsnd_emu8000_create_mixer(struct snd_card *card, struct snd_emu8000 *emu)\r\n{\r\nint i, err = 0;\r\nif (snd_BUG_ON(!emu || !card))\r\nreturn -EINVAL;\r\nspin_lock_init(&emu->control_lock);\r\nmemset(emu->controls, 0, sizeof(emu->controls));\r\nfor (i = 0; i < EMU8000_NUM_CONTROLS; i++) {\r\nif ((err = snd_ctl_add(card, emu->controls[i] = snd_ctl_new1(mixer_defs[i], emu))) < 0)\r\ngoto __error;\r\n}\r\nreturn 0;\r\n__error:\r\nfor (i = 0; i < EMU8000_NUM_CONTROLS; i++) {\r\ndown_write(&card->controls_rwsem);\r\nif (emu->controls[i])\r\nsnd_ctl_remove(card, emu->controls[i]);\r\nup_write(&card->controls_rwsem);\r\n}\r\nreturn err;\r\n}\r\nstatic int snd_emu8000_free(struct snd_emu8000 *hw)\r\n{\r\nrelease_and_free_resource(hw->res_port1);\r\nrelease_and_free_resource(hw->res_port2);\r\nrelease_and_free_resource(hw->res_port3);\r\nkfree(hw);\r\nreturn 0;\r\n}\r\nstatic int snd_emu8000_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_emu8000 *hw = device->device_data;\r\nreturn snd_emu8000_free(hw);\r\n}\r\nint __devinit\r\nsnd_emu8000_new(struct snd_card *card, int index, long port, int seq_ports,\r\nstruct snd_seq_device **awe_ret)\r\n{\r\nstruct snd_seq_device *awe;\r\nstruct snd_emu8000 *hw;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_emu8000_dev_free,\r\n};\r\nif (awe_ret)\r\n*awe_ret = NULL;\r\nif (seq_ports <= 0)\r\nreturn 0;\r\nhw = kzalloc(sizeof(*hw), GFP_KERNEL);\r\nif (hw == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&hw->reg_lock);\r\nhw->index = index;\r\nhw->port1 = port;\r\nhw->port2 = port + 0x400;\r\nhw->port3 = port + 0x800;\r\nif (!(hw->res_port1 = request_region(hw->port1, 4, "Emu8000-1")) ||\r\n!(hw->res_port2 = request_region(hw->port2, 4, "Emu8000-2")) ||\r\n!(hw->res_port3 = request_region(hw->port3, 4, "Emu8000-3"))) {\r\nsnd_printk(KERN_ERR "sbawe: can't grab ports 0x%lx, 0x%lx, 0x%lx\n", hw->port1, hw->port2, hw->port3);\r\nsnd_emu8000_free(hw);\r\nreturn -EBUSY;\r\n}\r\nhw->mem_size = 0;\r\nhw->card = card;\r\nhw->seq_ports = seq_ports;\r\nhw->bass_level = 5;\r\nhw->treble_level = 9;\r\nhw->chorus_mode = 2;\r\nhw->reverb_mode = 4;\r\nhw->fm_chorus_depth = 0;\r\nhw->fm_reverb_depth = 0;\r\nif (snd_emu8000_detect(hw) < 0) {\r\nsnd_emu8000_free(hw);\r\nreturn -ENODEV;\r\n}\r\nsnd_emu8000_init_hw(hw);\r\nif ((err = snd_emu8000_create_mixer(card, hw)) < 0) {\r\nsnd_emu8000_free(hw);\r\nreturn err;\r\n}\r\nif ((err = snd_device_new(card, SNDRV_DEV_CODEC, hw, &ops)) < 0) {\r\nsnd_emu8000_free(hw);\r\nreturn err;\r\n}\r\n#if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))\r\nif (snd_seq_device_new(card, index, SNDRV_SEQ_DEV_ID_EMU8000,\r\nsizeof(struct snd_emu8000*), &awe) >= 0) {\r\nstrcpy(awe->name, "EMU-8000");\r\n*(struct snd_emu8000 **)SNDRV_SEQ_DEVICE_ARGPTR(awe) = hw;\r\n}\r\n#else\r\nawe = NULL;\r\n#endif\r\nif (awe_ret)\r\n*awe_ret = awe;\r\nreturn 0;\r\n}
