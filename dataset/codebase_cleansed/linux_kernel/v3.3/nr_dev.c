int nr_rx_ip(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct net_device_stats *stats = &dev->stats;\r\nif (!netif_running(dev)) {\r\nstats->rx_dropped++;\r\nreturn 0;\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += skb->len;\r\nskb->protocol = htons(ETH_P_IP);\r\nskb->dev = dev;\r\nskb->mac_header = skb->network_header;\r\nskb_reset_network_header(skb);\r\nskb->pkt_type = PACKET_HOST;\r\nnetif_rx(skb);\r\nreturn 1;\r\n}\r\nstatic int nr_rebuild_header(struct sk_buff *skb)\r\n{\r\nunsigned char *bp = skb->data;\r\nif (arp_find(bp + 7, skb))\r\nreturn 1;\r\nbp[6] &= ~AX25_CBIT;\r\nbp[6] &= ~AX25_EBIT;\r\nbp[6] |= AX25_SSSID_SPARE;\r\nbp += AX25_ADDR_LEN;\r\nbp[6] &= ~AX25_CBIT;\r\nbp[6] |= AX25_EBIT;\r\nbp[6] |= AX25_SSSID_SPARE;\r\nreturn 0;\r\n}\r\nstatic int nr_rebuild_header(struct sk_buff *skb)\r\n{\r\nreturn 1;\r\n}\r\nstatic int nr_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type,\r\nconst void *daddr, const void *saddr, unsigned len)\r\n{\r\nunsigned char *buff = skb_push(skb, NR_NETWORK_LEN + NR_TRANSPORT_LEN);\r\nmemcpy(buff, (saddr != NULL) ? saddr : dev->dev_addr, dev->addr_len);\r\nbuff[6] &= ~AX25_CBIT;\r\nbuff[6] &= ~AX25_EBIT;\r\nbuff[6] |= AX25_SSSID_SPARE;\r\nbuff += AX25_ADDR_LEN;\r\nif (daddr != NULL)\r\nmemcpy(buff, daddr, dev->addr_len);\r\nbuff[6] &= ~AX25_CBIT;\r\nbuff[6] |= AX25_EBIT;\r\nbuff[6] |= AX25_SSSID_SPARE;\r\nbuff += AX25_ADDR_LEN;\r\n*buff++ = sysctl_netrom_network_ttl_initialiser;\r\n*buff++ = NR_PROTO_IP;\r\n*buff++ = NR_PROTO_IP;\r\n*buff++ = 0;\r\n*buff++ = 0;\r\n*buff++ = NR_PROTOEXT;\r\nif (daddr != NULL)\r\nreturn 37;\r\nreturn -37;\r\n}\r\nstatic int __must_check nr_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *sa = addr;\r\nint err;\r\nif (!memcmp(dev->dev_addr, sa->sa_data, dev->addr_len))\r\nreturn 0;\r\nif (dev->flags & IFF_UP) {\r\nerr = ax25_listen_register((ax25_address *)sa->sa_data, NULL);\r\nif (err)\r\nreturn err;\r\nax25_listen_release((ax25_address *)dev->dev_addr, NULL);\r\n}\r\nmemcpy(dev->dev_addr, sa->sa_data, dev->addr_len);\r\nreturn 0;\r\n}\r\nstatic int nr_open(struct net_device *dev)\r\n{\r\nint err;\r\nerr = ax25_listen_register((ax25_address *)dev->dev_addr, NULL);\r\nif (err)\r\nreturn err;\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int nr_close(struct net_device *dev)\r\n{\r\nax25_listen_release((ax25_address *)dev->dev_addr, NULL);\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t nr_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct net_device_stats *stats = &dev->stats;\r\nunsigned int len = skb->len;\r\nif (!nr_route_frame(skb, NULL)) {\r\nkfree_skb(skb);\r\nstats->tx_errors++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstats->tx_packets++;\r\nstats->tx_bytes += len;\r\nreturn NETDEV_TX_OK;\r\n}\r\nvoid nr_setup(struct net_device *dev)\r\n{\r\ndev->mtu = NR_MAX_PACKET_SIZE;\r\ndev->netdev_ops = &nr_netdev_ops;\r\ndev->header_ops = &nr_header_ops;\r\ndev->hard_header_len = NR_NETWORK_LEN + NR_TRANSPORT_LEN;\r\ndev->addr_len = AX25_ADDR_LEN;\r\ndev->type = ARPHRD_NETROM;\r\ndev->flags = IFF_NOARP;\r\n}
