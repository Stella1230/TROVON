int __init tfrc_tx_packet_history_init(void)\r\n{\r\ntfrc_tx_hist_slab = kmem_cache_create("tfrc_tx_hist",\r\nsizeof(struct tfrc_tx_hist_entry),\r\n0, SLAB_HWCACHE_ALIGN, NULL);\r\nreturn tfrc_tx_hist_slab == NULL ? -ENOBUFS : 0;\r\n}\r\nvoid tfrc_tx_packet_history_exit(void)\r\n{\r\nif (tfrc_tx_hist_slab != NULL) {\r\nkmem_cache_destroy(tfrc_tx_hist_slab);\r\ntfrc_tx_hist_slab = NULL;\r\n}\r\n}\r\nint tfrc_tx_hist_add(struct tfrc_tx_hist_entry **headp, u64 seqno)\r\n{\r\nstruct tfrc_tx_hist_entry *entry = kmem_cache_alloc(tfrc_tx_hist_slab, gfp_any());\r\nif (entry == NULL)\r\nreturn -ENOBUFS;\r\nentry->seqno = seqno;\r\nentry->stamp = ktime_get_real();\r\nentry->next = *headp;\r\n*headp = entry;\r\nreturn 0;\r\n}\r\nvoid tfrc_tx_hist_purge(struct tfrc_tx_hist_entry **headp)\r\n{\r\nstruct tfrc_tx_hist_entry *head = *headp;\r\nwhile (head != NULL) {\r\nstruct tfrc_tx_hist_entry *next = head->next;\r\nkmem_cache_free(tfrc_tx_hist_slab, head);\r\nhead = next;\r\n}\r\n*headp = NULL;\r\n}\r\nint __init tfrc_rx_packet_history_init(void)\r\n{\r\ntfrc_rx_hist_slab = kmem_cache_create("tfrc_rxh_cache",\r\nsizeof(struct tfrc_rx_hist_entry),\r\n0, SLAB_HWCACHE_ALIGN, NULL);\r\nreturn tfrc_rx_hist_slab == NULL ? -ENOBUFS : 0;\r\n}\r\nvoid tfrc_rx_packet_history_exit(void)\r\n{\r\nif (tfrc_rx_hist_slab != NULL) {\r\nkmem_cache_destroy(tfrc_rx_hist_slab);\r\ntfrc_rx_hist_slab = NULL;\r\n}\r\n}\r\nstatic inline void tfrc_rx_hist_entry_from_skb(struct tfrc_rx_hist_entry *entry,\r\nconst struct sk_buff *skb,\r\nconst u64 ndp)\r\n{\r\nconst struct dccp_hdr *dh = dccp_hdr(skb);\r\nentry->tfrchrx_seqno = DCCP_SKB_CB(skb)->dccpd_seq;\r\nentry->tfrchrx_ccval = dh->dccph_ccval;\r\nentry->tfrchrx_type = dh->dccph_type;\r\nentry->tfrchrx_ndp = ndp;\r\nentry->tfrchrx_tstamp = ktime_get_real();\r\n}\r\nvoid tfrc_rx_hist_add_packet(struct tfrc_rx_hist *h,\r\nconst struct sk_buff *skb,\r\nconst u64 ndp)\r\n{\r\nstruct tfrc_rx_hist_entry *entry = tfrc_rx_hist_last_rcv(h);\r\ntfrc_rx_hist_entry_from_skb(entry, skb, ndp);\r\n}\r\nint tfrc_rx_hist_duplicate(struct tfrc_rx_hist *h, struct sk_buff *skb)\r\n{\r\nconst u64 seq = DCCP_SKB_CB(skb)->dccpd_seq;\r\nint i;\r\nif (dccp_delta_seqno(tfrc_rx_hist_loss_prev(h)->tfrchrx_seqno, seq) <= 0)\r\nreturn 1;\r\nfor (i = 1; i <= h->loss_count; i++)\r\nif (tfrc_rx_hist_entry(h, i)->tfrchrx_seqno == seq)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void tfrc_rx_hist_swap(struct tfrc_rx_hist *h, const u8 a, const u8 b)\r\n{\r\nconst u8 idx_a = tfrc_rx_hist_index(h, a),\r\nidx_b = tfrc_rx_hist_index(h, b);\r\nstruct tfrc_rx_hist_entry *tmp = h->ring[idx_a];\r\nh->ring[idx_a] = h->ring[idx_b];\r\nh->ring[idx_b] = tmp;\r\n}\r\nstatic void __do_track_loss(struct tfrc_rx_hist *h, struct sk_buff *skb, u64 n1)\r\n{\r\nu64 s0 = tfrc_rx_hist_loss_prev(h)->tfrchrx_seqno,\r\ns1 = DCCP_SKB_CB(skb)->dccpd_seq;\r\nif (!dccp_loss_free(s0, s1, n1)) {\r\nh->loss_count = 1;\r\ntfrc_rx_hist_entry_from_skb(tfrc_rx_hist_entry(h, 1), skb, n1);\r\n}\r\n}\r\nstatic void __one_after_loss(struct tfrc_rx_hist *h, struct sk_buff *skb, u32 n2)\r\n{\r\nu64 s0 = tfrc_rx_hist_loss_prev(h)->tfrchrx_seqno,\r\ns1 = tfrc_rx_hist_entry(h, 1)->tfrchrx_seqno,\r\ns2 = DCCP_SKB_CB(skb)->dccpd_seq;\r\nif (likely(dccp_delta_seqno(s1, s2) > 0)) {\r\nh->loss_count = 2;\r\ntfrc_rx_hist_entry_from_skb(tfrc_rx_hist_entry(h, 2), skb, n2);\r\nreturn;\r\n}\r\nif (dccp_loss_free(s0, s2, n2)) {\r\nu64 n1 = tfrc_rx_hist_entry(h, 1)->tfrchrx_ndp;\r\nif (dccp_loss_free(s2, s1, n1)) {\r\nh->loss_count = 0;\r\nh->loss_start = tfrc_rx_hist_index(h, 1);\r\n} else\r\ntfrc_rx_hist_entry_from_skb(tfrc_rx_hist_loss_prev(h), skb, n2);\r\n} else {\r\ntfrc_rx_hist_swap(h, 0, 3);\r\nh->loss_start = tfrc_rx_hist_index(h, 3);\r\ntfrc_rx_hist_entry_from_skb(tfrc_rx_hist_entry(h, 1), skb, n2);\r\nh->loss_count = 2;\r\n}\r\n}\r\nstatic int __two_after_loss(struct tfrc_rx_hist *h, struct sk_buff *skb, u32 n3)\r\n{\r\nu64 s0 = tfrc_rx_hist_loss_prev(h)->tfrchrx_seqno,\r\ns1 = tfrc_rx_hist_entry(h, 1)->tfrchrx_seqno,\r\ns2 = tfrc_rx_hist_entry(h, 2)->tfrchrx_seqno,\r\ns3 = DCCP_SKB_CB(skb)->dccpd_seq;\r\nif (likely(dccp_delta_seqno(s2, s3) > 0)) {\r\nh->loss_count = 3;\r\ntfrc_rx_hist_entry_from_skb(tfrc_rx_hist_entry(h, 3), skb, n3);\r\nreturn 1;\r\n}\r\nif (dccp_delta_seqno(s1, s3) > 0) {\r\ntfrc_rx_hist_swap(h, 2, 3);\r\ntfrc_rx_hist_entry_from_skb(tfrc_rx_hist_entry(h, 2), skb, n3);\r\nh->loss_count = 3;\r\nreturn 1;\r\n}\r\nif (dccp_loss_free(s0, s3, n3)) {\r\nu64 n1 = tfrc_rx_hist_entry(h, 1)->tfrchrx_ndp;\r\nif (dccp_loss_free(s3, s1, n1)) {\r\nu64 n2 = tfrc_rx_hist_entry(h, 2)->tfrchrx_ndp;\r\nif (dccp_loss_free(s1, s2, n2)) {\r\nh->loss_start = tfrc_rx_hist_index(h, 2);\r\nh->loss_count = 0;\r\n} else {\r\nh->loss_start = tfrc_rx_hist_index(h, 1);\r\nh->loss_count = 1;\r\n}\r\n} else\r\ntfrc_rx_hist_entry_from_skb(tfrc_rx_hist_loss_prev(h), skb, n3);\r\nreturn 0;\r\n}\r\ntfrc_rx_hist_swap(h, 0, 3);\r\nh->loss_start = tfrc_rx_hist_index(h, 3);\r\ntfrc_rx_hist_entry_from_skb(tfrc_rx_hist_entry(h, 1), skb, n3);\r\nh->loss_count = 3;\r\nreturn 1;\r\n}\r\nstatic void __three_after_loss(struct tfrc_rx_hist *h)\r\n{\r\nu64 s1 = tfrc_rx_hist_entry(h, 1)->tfrchrx_seqno,\r\ns2 = tfrc_rx_hist_entry(h, 2)->tfrchrx_seqno,\r\ns3 = tfrc_rx_hist_entry(h, 3)->tfrchrx_seqno;\r\nu64 n2 = tfrc_rx_hist_entry(h, 2)->tfrchrx_ndp,\r\nn3 = tfrc_rx_hist_entry(h, 3)->tfrchrx_ndp;\r\nif (dccp_loss_free(s1, s2, n2)) {\r\nif (dccp_loss_free(s2, s3, n3)) {\r\nh->loss_start = tfrc_rx_hist_index(h, 3);\r\nh->loss_count = 0;\r\n} else {\r\nh->loss_start = tfrc_rx_hist_index(h, 2);\r\nh->loss_count = 1;\r\n}\r\n} else {\r\nh->loss_start = tfrc_rx_hist_index(h, 1);\r\nh->loss_count = 2;\r\n}\r\n}\r\nint tfrc_rx_handle_loss(struct tfrc_rx_hist *h,\r\nstruct tfrc_loss_hist *lh,\r\nstruct sk_buff *skb, const u64 ndp,\r\nu32 (*calc_first_li)(struct sock *), struct sock *sk)\r\n{\r\nint is_new_loss = 0;\r\nif (h->loss_count == 0) {\r\n__do_track_loss(h, skb, ndp);\r\n} else if (h->loss_count == 1) {\r\n__one_after_loss(h, skb, ndp);\r\n} else if (h->loss_count != 2) {\r\nDCCP_BUG("invalid loss_count %d", h->loss_count);\r\n} else if (__two_after_loss(h, skb, ndp)) {\r\nis_new_loss = tfrc_lh_interval_add(lh, h, calc_first_li, sk);\r\n__three_after_loss(h);\r\n}\r\nreturn is_new_loss;\r\n}\r\nint tfrc_rx_hist_alloc(struct tfrc_rx_hist *h)\r\n{\r\nint i;\r\nfor (i = 0; i <= TFRC_NDUPACK; i++) {\r\nh->ring[i] = kmem_cache_alloc(tfrc_rx_hist_slab, GFP_ATOMIC);\r\nif (h->ring[i] == NULL)\r\ngoto out_free;\r\n}\r\nh->loss_count = h->loss_start = 0;\r\nreturn 0;\r\nout_free:\r\nwhile (i-- != 0) {\r\nkmem_cache_free(tfrc_rx_hist_slab, h->ring[i]);\r\nh->ring[i] = NULL;\r\n}\r\nreturn -ENOBUFS;\r\n}\r\nvoid tfrc_rx_hist_purge(struct tfrc_rx_hist *h)\r\n{\r\nint i;\r\nfor (i = 0; i <= TFRC_NDUPACK; ++i)\r\nif (h->ring[i] != NULL) {\r\nkmem_cache_free(tfrc_rx_hist_slab, h->ring[i]);\r\nh->ring[i] = NULL;\r\n}\r\n}\r\nstatic inline struct tfrc_rx_hist_entry *\r\ntfrc_rx_hist_rtt_last_s(const struct tfrc_rx_hist *h)\r\n{\r\nreturn h->ring[0];\r\n}\r\nstatic inline struct tfrc_rx_hist_entry *\r\ntfrc_rx_hist_rtt_prev_s(const struct tfrc_rx_hist *h)\r\n{\r\nreturn h->ring[h->rtt_sample_prev];\r\n}\r\nu32 tfrc_rx_hist_sample_rtt(struct tfrc_rx_hist *h, const struct sk_buff *skb)\r\n{\r\nu32 sample = 0,\r\ndelta_v = SUB16(dccp_hdr(skb)->dccph_ccval,\r\ntfrc_rx_hist_rtt_last_s(h)->tfrchrx_ccval);\r\nif (delta_v < 1 || delta_v > 4) {\r\nif (h->rtt_sample_prev == 2) {\r\nsample = SUB16(tfrc_rx_hist_rtt_prev_s(h)->tfrchrx_ccval,\r\ntfrc_rx_hist_rtt_last_s(h)->tfrchrx_ccval);\r\nif (sample)\r\nsample = 4 / sample *\r\nktime_us_delta(tfrc_rx_hist_rtt_prev_s(h)->tfrchrx_tstamp,\r\ntfrc_rx_hist_rtt_last_s(h)->tfrchrx_tstamp);\r\nelse\r\nDCCP_BUG("please report to dccp@vger.kernel.org"\r\n" => prev = %u, last = %u",\r\ntfrc_rx_hist_rtt_prev_s(h)->tfrchrx_ccval,\r\ntfrc_rx_hist_rtt_last_s(h)->tfrchrx_ccval);\r\n} else if (delta_v < 1) {\r\nh->rtt_sample_prev = 1;\r\ngoto keep_ref_for_next_time;\r\n}\r\n} else if (delta_v == 4)\r\nsample = ktime_to_us(net_timedelta(tfrc_rx_hist_rtt_last_s(h)->tfrchrx_tstamp));\r\nelse {\r\nh->rtt_sample_prev = 2;\r\ngoto keep_ref_for_next_time;\r\n}\r\nif (unlikely(sample > DCCP_SANE_RTT_MAX)) {\r\nDCCP_WARN("RTT sample %u too large, using max\n", sample);\r\nsample = DCCP_SANE_RTT_MAX;\r\n}\r\nh->rtt_sample_prev = 0;\r\nkeep_ref_for_next_time:\r\nreturn sample;\r\n}
