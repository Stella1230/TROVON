static void\r\ntitan_update_irq_hw(unsigned long mask)\r\n{\r\nregister titan_cchip *cchip = TITAN_cchip;\r\nunsigned long isa_enable = 1UL << 55;\r\nregister int bcpu = boot_cpuid;\r\n#ifdef CONFIG_SMP\r\ncpumask_t cpm;\r\nvolatile unsigned long *dim0, *dim1, *dim2, *dim3;\r\nunsigned long mask0, mask1, mask2, mask3, dummy;\r\ncpumask_copy(&cpm, cpu_present_mask);\r\nmask &= ~isa_enable;\r\nmask0 = mask & titan_cpu_irq_affinity[0];\r\nmask1 = mask & titan_cpu_irq_affinity[1];\r\nmask2 = mask & titan_cpu_irq_affinity[2];\r\nmask3 = mask & titan_cpu_irq_affinity[3];\r\nif (bcpu == 0) mask0 |= isa_enable;\r\nelse if (bcpu == 1) mask1 |= isa_enable;\r\nelse if (bcpu == 2) mask2 |= isa_enable;\r\nelse mask3 |= isa_enable;\r\ndim0 = &cchip->dim0.csr;\r\ndim1 = &cchip->dim1.csr;\r\ndim2 = &cchip->dim2.csr;\r\ndim3 = &cchip->dim3.csr;\r\nif (!cpumask_test_cpu(0, &cpm)) dim0 = &dummy;\r\nif (!cpumask_test_cpu(1, &cpm)) dim1 = &dummy;\r\nif (!cpumask_test_cpu(2, &cpm)) dim2 = &dummy;\r\nif (!cpumask_test_cpu(3, &cpm)) dim3 = &dummy;\r\n*dim0 = mask0;\r\n*dim1 = mask1;\r\n*dim2 = mask2;\r\n*dim3 = mask3;\r\nmb();\r\n*dim0;\r\n*dim1;\r\n*dim2;\r\n*dim3;\r\n#else\r\nvolatile unsigned long *dimB;\r\ndimB = &cchip->dim0.csr;\r\nif (bcpu == 1) dimB = &cchip->dim1.csr;\r\nelse if (bcpu == 2) dimB = &cchip->dim2.csr;\r\nelse if (bcpu == 3) dimB = &cchip->dim3.csr;\r\n*dimB = mask | isa_enable;\r\nmb();\r\n*dimB;\r\n#endif\r\n}\r\nstatic inline void\r\ntitan_enable_irq(struct irq_data *d)\r\n{\r\nunsigned int irq = d->irq;\r\nspin_lock(&titan_irq_lock);\r\ntitan_cached_irq_mask |= 1UL << (irq - 16);\r\ntitan_update_irq_hw(titan_cached_irq_mask);\r\nspin_unlock(&titan_irq_lock);\r\n}\r\nstatic inline void\r\ntitan_disable_irq(struct irq_data *d)\r\n{\r\nunsigned int irq = d->irq;\r\nspin_lock(&titan_irq_lock);\r\ntitan_cached_irq_mask &= ~(1UL << (irq - 16));\r\ntitan_update_irq_hw(titan_cached_irq_mask);\r\nspin_unlock(&titan_irq_lock);\r\n}\r\nstatic void\r\ntitan_cpu_set_irq_affinity(unsigned int irq, cpumask_t affinity)\r\n{\r\nint cpu;\r\nfor (cpu = 0; cpu < 4; cpu++) {\r\nif (cpumask_test_cpu(cpu, &affinity))\r\ntitan_cpu_irq_affinity[cpu] |= 1UL << irq;\r\nelse\r\ntitan_cpu_irq_affinity[cpu] &= ~(1UL << irq);\r\n}\r\n}\r\nstatic int\r\ntitan_set_irq_affinity(struct irq_data *d, const struct cpumask *affinity,\r\nbool force)\r\n{\r\nunsigned int irq = d->irq;\r\nspin_lock(&titan_irq_lock);\r\ntitan_cpu_set_irq_affinity(irq - 16, *affinity);\r\ntitan_update_irq_hw(titan_cached_irq_mask);\r\nspin_unlock(&titan_irq_lock);\r\nreturn 0;\r\n}\r\nstatic void\r\ntitan_device_interrupt(unsigned long vector)\r\n{\r\nprintk("titan_device_interrupt: NOT IMPLEMENTED YET!!\n");\r\n}\r\nstatic void\r\ntitan_srm_device_interrupt(unsigned long vector)\r\n{\r\nint irq;\r\nirq = (vector - 0x800) >> 4;\r\nhandle_irq(irq);\r\n}\r\nstatic void __init\r\ninit_titan_irqs(struct irq_chip * ops, int imin, int imax)\r\n{\r\nlong i;\r\nfor (i = imin; i <= imax; ++i) {\r\nirq_set_chip_and_handler(i, ops, handle_level_irq);\r\nirq_set_status_flags(i, IRQ_LEVEL);\r\n}\r\n}\r\nstatic irqreturn_t\r\ntitan_intr_nop(int irq, void *dev_id)\r\n{\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __init\r\ntitan_init_irq(void)\r\n{\r\nif (alpha_using_srm && !alpha_mv.device_interrupt)\r\nalpha_mv.device_interrupt = titan_srm_device_interrupt;\r\nif (!alpha_mv.device_interrupt)\r\nalpha_mv.device_interrupt = titan_device_interrupt;\r\ntitan_update_irq_hw(0);\r\ninit_titan_irqs(&titan_irq_type, 16, 63 + 16);\r\n}\r\nstatic void __init\r\ntitan_legacy_init_irq(void)\r\n{\r\noutb(0, DMA1_RESET_REG);\r\noutb(0, DMA2_RESET_REG);\r\noutb(DMA_MODE_CASCADE, DMA2_MODE_REG);\r\noutb(0, DMA2_MASK_REG);\r\ninit_i8259a_irqs();\r\ntitan_init_irq();\r\n}\r\nvoid\r\ntitan_dispatch_irqs(u64 mask)\r\n{\r\nunsigned long vector;\r\nmask &= titan_cpu_irq_affinity[smp_processor_id()];\r\nwhile (mask) {\r\nvector = 63 - __kernel_ctlz(mask);\r\nmask &= ~(1UL << vector);\r\nvector = 0x900 + (vector << 4);\r\nalpha_mv.device_interrupt(vector);\r\n}\r\n}\r\nstatic void __init\r\ntitan_request_irq(unsigned int irq, irq_handler_t handler,\r\nunsigned long irqflags, const char *devname,\r\nvoid *dev_id)\r\n{\r\nint err;\r\nerr = request_irq(irq, handler, irqflags, devname, dev_id);\r\nif (err) {\r\nprintk("titan_request_irq for IRQ %d returned %d; ignoring\n",\r\nirq, err);\r\n}\r\n}\r\nstatic void __init\r\ntitan_late_init(void)\r\n{\r\ntitan_request_irq(63+16, titan_intr_nop, IRQF_DISABLED,\r\n"CChip Error", NULL);\r\ntitan_request_irq(62+16, titan_intr_nop, IRQF_DISABLED,\r\n"PChip 0 H_Error", NULL);\r\ntitan_request_irq(61+16, titan_intr_nop, IRQF_DISABLED,\r\n"PChip 1 H_Error", NULL);\r\ntitan_request_irq(60+16, titan_intr_nop, IRQF_DISABLED,\r\n"PChip 0 C_Error", NULL);\r\ntitan_request_irq(59+16, titan_intr_nop, IRQF_DISABLED,\r\n"PChip 1 C_Error", NULL);\r\ntitan_register_error_handlers();\r\ncdl_check_console_data_log();\r\n}\r\nstatic int __devinit\r\ntitan_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nu8 intline;\r\nint irq;\r\npci_read_config_byte(dev, PCI_INTERRUPT_LINE, &intline);\r\nirq = intline;\r\nif ((irq & 0xF0) == 0xE0)\r\nreturn irq;\r\nreturn irq + 16;\r\n}\r\nstatic void __init\r\ntitan_init_pci(void)\r\n{\r\ntitan_late_init();\r\npci_probe_only = 1;\r\ncommon_init_pci();\r\nSMC669_Init(0);\r\nlocate_and_init_vga(NULL);\r\n}\r\nstatic void __init\r\nprivateer_init_pci(void)\r\n{\r\ntitan_request_irq(53+16, titan_intr_nop, IRQF_DISABLED,\r\n"NMI", NULL);\r\ntitan_request_irq(50+16, titan_intr_nop, IRQF_DISABLED,\r\n"Temperature Warning", NULL);\r\nreturn titan_init_pci();\r\n}
