unsigned long profile_pc(struct pt_regs *regs)\r\n{\r\nextern char __copy_user_begin[], __copy_user_end[];\r\nextern char __atomic_begin[], __atomic_end[];\r\nextern char __bzero_begin[], __bzero_end[];\r\nunsigned long pc = regs->pc;\r\nif (in_lock_functions(pc) ||\r\n(pc >= (unsigned long) __copy_user_begin &&\r\npc < (unsigned long) __copy_user_end) ||\r\n(pc >= (unsigned long) __atomic_begin &&\r\npc < (unsigned long) __atomic_end) ||\r\n(pc >= (unsigned long) __bzero_begin &&\r\npc < (unsigned long) __bzero_end))\r\npc = regs->u_regs[UREG_RETPC];\r\nreturn pc;\r\n}\r\nint update_persistent_clock(struct timespec now)\r\n{\r\nreturn set_rtc_mmss(now.tv_sec);\r\n}\r\nstatic irqreturn_t timer_interrupt(int dummy, void *dev_id)\r\n{\r\n#ifndef CONFIG_SMP\r\nprofile_tick(CPU_PROFILING);\r\n#endif\r\nclear_clock_irq();\r\nxtime_update(1);\r\n#ifndef CONFIG_SMP\r\nupdate_process_times(user_mode(get_irq_regs()));\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned char mostek_read_byte(struct device *dev, u32 ofs)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct m48t59_plat_data *pdata = pdev->dev.platform_data;\r\nreturn readb(pdata->ioaddr + ofs);\r\n}\r\nstatic void mostek_write_byte(struct device *dev, u32 ofs, u8 val)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct m48t59_plat_data *pdata = pdev->dev.platform_data;\r\nwriteb(val, pdata->ioaddr + ofs);\r\n}\r\nstatic int __devinit clock_probe(struct platform_device *op)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nconst char *model = of_get_property(dp, "model", NULL);\r\nif (!model)\r\nreturn -ENODEV;\r\nif (!of_find_property(dp, "address", NULL))\r\nreturn -ENODEV;\r\nm48t59_rtc.resource = &op->resource[0];\r\nif (!strcmp(model, "mk48t02")) {\r\nm48t59_data.ioaddr = of_ioremap(&op->resource[0], 0,\r\n2048, "rtc-m48t59");\r\nm48t59_data.type = M48T59RTC_TYPE_M48T02;\r\n} else if (!strcmp(model, "mk48t08")) {\r\nm48t59_data.ioaddr = of_ioremap(&op->resource[0], 0,\r\n8192, "rtc-m48t59");\r\nm48t59_data.type = M48T59RTC_TYPE_M48T08;\r\n} else\r\nreturn -ENODEV;\r\nif (platform_device_register(&m48t59_rtc) < 0)\r\nprintk(KERN_ERR "Registering RTC device failed\n");\r\nreturn 0;\r\n}\r\nstatic int __init clock_init(void)\r\n{\r\nreturn platform_driver_register(&clock_driver);\r\n}\r\nu32 sbus_do_gettimeoffset(void)\r\n{\r\nunsigned long val = *master_l10_counter;\r\nunsigned long usec = (val >> 10) & 0x1fffff;\r\nif (val & 0x80000000)\r\nusec += 1000000 / HZ;\r\nreturn usec * 1000;\r\n}\r\nu32 arch_gettimeoffset(void)\r\n{\r\nif (unlikely(!do_arch_gettimeoffset))\r\nreturn 0;\r\nreturn do_arch_gettimeoffset();\r\n}\r\nstatic void __init sbus_time_init(void)\r\n{\r\ndo_arch_gettimeoffset = sbus_do_gettimeoffset;\r\nbtfixup();\r\nsparc_irq_config.init_timers(timer_interrupt);\r\n}\r\nvoid __init time_init(void)\r\n{\r\nif (pcic_present())\r\npci_time_init();\r\nelse\r\nsbus_time_init();\r\n}\r\nstatic int set_rtc_mmss(unsigned long secs)\r\n{\r\nstruct rtc_device *rtc = rtc_class_open("rtc0");\r\nint err = -1;\r\nif (rtc) {\r\nerr = rtc_set_mmss(rtc, secs);\r\nrtc_class_close(rtc);\r\n}\r\nreturn err;\r\n}
