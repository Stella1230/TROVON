static int alc_ch_mode_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct alc_spec *spec = codec->spec;\r\nreturn snd_hda_ch_mode_info(codec, uinfo, spec->channel_mode,\r\nspec->num_channel_mode);\r\n}\r\nstatic int alc_ch_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct alc_spec *spec = codec->spec;\r\nreturn snd_hda_ch_mode_get(codec, ucontrol, spec->channel_mode,\r\nspec->num_channel_mode,\r\nspec->ext_channel_count);\r\n}\r\nstatic int alc_ch_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct alc_spec *spec = codec->spec;\r\nint err = snd_hda_ch_mode_put(codec, ucontrol, spec->channel_mode,\r\nspec->num_channel_mode,\r\n&spec->ext_channel_count);\r\nif (err >= 0 && !spec->const_channel_count) {\r\nspec->multiout.max_channels = spec->ext_channel_count;\r\nif (spec->need_dac_fix)\r\nspec->multiout.num_dacs = spec->multiout.max_channels / 2;\r\n}\r\nreturn err;\r\n}\r\nstatic int alc_pin_mode_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nunsigned int item_num = uinfo->value.enumerated.item;\r\nunsigned char dir = (kcontrol->private_value >> 16) & 0xff;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = alc_pin_mode_n_items(dir);\r\nif (item_num<alc_pin_mode_min(dir) || item_num>alc_pin_mode_max(dir))\r\nitem_num = alc_pin_mode_min(dir);\r\nstrcpy(uinfo->value.enumerated.name, alc_pin_mode_names[item_num]);\r\nreturn 0;\r\n}\r\nstatic int alc_pin_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned int i;\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value & 0xffff;\r\nunsigned char dir = (kcontrol->private_value >> 16) & 0xff;\r\nlong *valp = ucontrol->value.integer.value;\r\nunsigned int pinctl = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_PIN_WIDGET_CONTROL,\r\n0x00);\r\ni = alc_pin_mode_min(dir);\r\nwhile (i <= alc_pin_mode_max(dir) && alc_pin_mode_values[i] != pinctl)\r\ni++;\r\n*valp = i <= alc_pin_mode_max(dir) ? i: alc_pin_mode_min(dir);\r\nreturn 0;\r\n}\r\nstatic int alc_pin_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nsigned int change;\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value & 0xffff;\r\nunsigned char dir = (kcontrol->private_value >> 16) & 0xff;\r\nlong val = *ucontrol->value.integer.value;\r\nunsigned int pinctl = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_PIN_WIDGET_CONTROL,\r\n0x00);\r\nif (val < alc_pin_mode_min(dir) || val > alc_pin_mode_max(dir))\r\nval = alc_pin_mode_min(dir);\r\nchange = pinctl != alc_pin_mode_values[val];\r\nif (change) {\r\nsnd_hda_codec_write_cache(codec, nid, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL,\r\nalc_pin_mode_values[val]);\r\nif (val <= 2) {\r\nsnd_hda_codec_amp_stereo(codec, nid, HDA_OUTPUT, 0,\r\nHDA_AMP_MUTE, HDA_AMP_MUTE);\r\nsnd_hda_codec_amp_stereo(codec, nid, HDA_INPUT, 0,\r\nHDA_AMP_MUTE, 0);\r\n} else {\r\nsnd_hda_codec_amp_stereo(codec, nid, HDA_INPUT, 0,\r\nHDA_AMP_MUTE, HDA_AMP_MUTE);\r\nsnd_hda_codec_amp_stereo(codec, nid, HDA_OUTPUT, 0,\r\nHDA_AMP_MUTE, 0);\r\n}\r\n}\r\nreturn change;\r\n}\r\nstatic int alc_gpio_data_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value & 0xffff;\r\nunsigned char mask = (kcontrol->private_value >> 16) & 0xff;\r\nlong *valp = ucontrol->value.integer.value;\r\nunsigned int val = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_GPIO_DATA, 0x00);\r\n*valp = (val & mask) != 0;\r\nreturn 0;\r\n}\r\nstatic int alc_gpio_data_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nsigned int change;\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value & 0xffff;\r\nunsigned char mask = (kcontrol->private_value >> 16) & 0xff;\r\nlong val = *ucontrol->value.integer.value;\r\nunsigned int gpio_data = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_GPIO_DATA,\r\n0x00);\r\nchange = (val == 0 ? 0 : mask) != (gpio_data & mask);\r\nif (val == 0)\r\ngpio_data &= ~mask;\r\nelse\r\ngpio_data |= mask;\r\nsnd_hda_codec_write_cache(codec, nid, 0,\r\nAC_VERB_SET_GPIO_DATA, gpio_data);\r\nreturn change;\r\n}\r\nstatic int alc_spdif_ctrl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value & 0xffff;\r\nunsigned char mask = (kcontrol->private_value >> 16) & 0xff;\r\nlong *valp = ucontrol->value.integer.value;\r\nunsigned int val = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_DIGI_CONVERT_1, 0x00);\r\n*valp = (val & mask) != 0;\r\nreturn 0;\r\n}\r\nstatic int alc_spdif_ctrl_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nsigned int change;\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value & 0xffff;\r\nunsigned char mask = (kcontrol->private_value >> 16) & 0xff;\r\nlong val = *ucontrol->value.integer.value;\r\nunsigned int ctrl_data = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_DIGI_CONVERT_1,\r\n0x00);\r\nchange = (val == 0 ? 0 : mask) != (ctrl_data & mask);\r\nif (val==0)\r\nctrl_data &= ~mask;\r\nelse\r\nctrl_data |= mask;\r\nsnd_hda_codec_write_cache(codec, nid, 0, AC_VERB_SET_DIGI_CONVERT_1,\r\nctrl_data);\r\nreturn change;\r\n}\r\nstatic int alc_eapd_ctrl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value & 0xffff;\r\nunsigned char mask = (kcontrol->private_value >> 16) & 0xff;\r\nlong *valp = ucontrol->value.integer.value;\r\nunsigned int val = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_EAPD_BTLENABLE, 0x00);\r\n*valp = (val & mask) != 0;\r\nreturn 0;\r\n}\r\nstatic int alc_eapd_ctrl_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint change;\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value & 0xffff;\r\nunsigned char mask = (kcontrol->private_value >> 16) & 0xff;\r\nlong val = *ucontrol->value.integer.value;\r\nunsigned int ctrl_data = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_EAPD_BTLENABLE,\r\n0x00);\r\nchange = (!val ? 0 : mask) != (ctrl_data & mask);\r\nif (!val)\r\nctrl_data &= ~mask;\r\nelse\r\nctrl_data |= mask;\r\nsnd_hda_codec_write_cache(codec, nid, 0, AC_VERB_SET_EAPD_BTLENABLE,\r\nctrl_data);\r\nreturn change;\r\n}\r\nstatic void alc_fixup_autocfg_pin_nums(struct hda_codec *codec)\r\n{\r\nstruct alc_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nif (!cfg->line_outs) {\r\nwhile (cfg->line_outs < AUTO_CFG_MAX_OUTS &&\r\ncfg->line_out_pins[cfg->line_outs])\r\ncfg->line_outs++;\r\n}\r\nif (!cfg->speaker_outs) {\r\nwhile (cfg->speaker_outs < AUTO_CFG_MAX_OUTS &&\r\ncfg->speaker_pins[cfg->speaker_outs])\r\ncfg->speaker_outs++;\r\n}\r\nif (!cfg->hp_outs) {\r\nwhile (cfg->hp_outs < AUTO_CFG_MAX_OUTS &&\r\ncfg->hp_pins[cfg->hp_outs])\r\ncfg->hp_outs++;\r\n}\r\n}\r\nstatic void setup_preset(struct hda_codec *codec,\r\nconst struct alc_config_preset *preset)\r\n{\r\nstruct alc_spec *spec = codec->spec;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(preset->mixers) && preset->mixers[i]; i++)\r\nadd_mixer(spec, preset->mixers[i]);\r\nspec->cap_mixer = preset->cap_mixer;\r\nfor (i = 0; i < ARRAY_SIZE(preset->init_verbs) && preset->init_verbs[i];\r\ni++)\r\nadd_verb(spec, preset->init_verbs[i]);\r\nspec->channel_mode = preset->channel_mode;\r\nspec->num_channel_mode = preset->num_channel_mode;\r\nspec->need_dac_fix = preset->need_dac_fix;\r\nspec->const_channel_count = preset->const_channel_count;\r\nif (preset->const_channel_count)\r\nspec->multiout.max_channels = preset->const_channel_count;\r\nelse\r\nspec->multiout.max_channels = spec->channel_mode[0].channels;\r\nspec->ext_channel_count = spec->channel_mode[0].channels;\r\nspec->multiout.num_dacs = preset->num_dacs;\r\nspec->multiout.dac_nids = preset->dac_nids;\r\nspec->multiout.dig_out_nid = preset->dig_out_nid;\r\nspec->multiout.slave_dig_outs = preset->slave_dig_outs;\r\nspec->multiout.hp_nid = preset->hp_nid;\r\nspec->num_mux_defs = preset->num_mux_defs;\r\nif (!spec->num_mux_defs)\r\nspec->num_mux_defs = 1;\r\nspec->input_mux = preset->input_mux;\r\nspec->num_adc_nids = preset->num_adc_nids;\r\nspec->adc_nids = preset->adc_nids;\r\nspec->capsrc_nids = preset->capsrc_nids;\r\nspec->dig_in_nid = preset->dig_in_nid;\r\nspec->unsol_event = preset->unsol_event;\r\nspec->init_hook = preset->init_hook;\r\n#ifdef CONFIG_SND_HDA_POWER_SAVE\r\nspec->power_hook = preset->power_hook;\r\nspec->loopback.amplist = preset->loopbacks;\r\n#endif\r\nif (preset->setup)\r\npreset->setup(codec);\r\nalc_fixup_autocfg_pin_nums(codec);\r\n}\r\nstatic void alc_simple_setup_automute(struct alc_spec *spec, int mode)\r\n{\r\nint lo_pin = spec->autocfg.line_out_pins[0];\r\nif (lo_pin == spec->autocfg.speaker_pins[0] ||\r\nlo_pin == spec->autocfg.hp_pins[0])\r\nlo_pin = 0;\r\nspec->automute_mode = mode;\r\nspec->detect_hp = !!spec->autocfg.hp_pins[0];\r\nspec->detect_lo = !!lo_pin;\r\nspec->automute_lo = spec->automute_lo_possible = !!lo_pin;\r\nspec->automute_speaker = spec->automute_speaker_possible = !!spec->autocfg.speaker_pins[0];\r\n}\r\nstatic void alc88x_simple_mic_automute(struct hda_codec *codec)\r\n{\r\nunsigned int present;\r\nunsigned char bits;\r\npresent = snd_hda_jack_detect(codec, 0x18);\r\nbits = present ? HDA_AMP_MUTE : 0;\r\nsnd_hda_codec_amp_stereo(codec, 0x0b, HDA_INPUT, 1, HDA_AMP_MUTE, bits);\r\n}
