static inline u8 sca_get_page(card_t *card)\r\n{\r\nreturn card->page;\r\n}\r\nstatic inline void openwin(card_t *card, u8 page)\r\n{\r\ncard->page = page;\r\nwriteb(page, card->win0base + C101_PAGE);\r\n}\r\nstatic inline void set_carrier(port_t *port)\r\n{\r\nif (!(sca_in(MSCI1_OFFSET + ST3, port) & ST3_DCD))\r\nnetif_carrier_on(port_to_dev(port));\r\nelse\r\nnetif_carrier_off(port_to_dev(port));\r\n}\r\nstatic void sca_msci_intr(port_t *port)\r\n{\r\nu8 stat = sca_in(MSCI0_OFFSET + ST1, port);\r\nsca_out(stat & (ST1_UDRN | ST1_CDCD), MSCI0_OFFSET + ST1, port);\r\nif (stat & ST1_UDRN) {\r\nport_to_dev(port)->stats.tx_errors++;\r\nport_to_dev(port)->stats.tx_fifo_errors++;\r\n}\r\nstat = sca_in(MSCI1_OFFSET + ST1, port);\r\nsca_out(stat & ST1_CDCD, MSCI1_OFFSET + ST1, port);\r\nif (stat & ST1_CDCD)\r\nset_carrier(port);\r\n}\r\nstatic void c101_set_iface(port_t *port)\r\n{\r\nu8 rxs = port->rxs & CLK_BRG_MASK;\r\nu8 txs = port->txs & CLK_BRG_MASK;\r\nswitch(port->settings.clock_type) {\r\ncase CLOCK_INT:\r\nrxs |= CLK_BRG_RX;\r\ntxs |= CLK_RXCLK_TX;\r\nbreak;\r\ncase CLOCK_TXINT:\r\nrxs |= CLK_LINE_RX;\r\ntxs |= CLK_BRG_TX;\r\nbreak;\r\ncase CLOCK_TXFROMRX:\r\nrxs |= CLK_LINE_RX;\r\ntxs |= CLK_RXCLK_TX;\r\nbreak;\r\ndefault:\r\nrxs |= CLK_LINE_RX;\r\ntxs |= CLK_LINE_TX;\r\n}\r\nport->rxs = rxs;\r\nport->txs = txs;\r\nsca_out(rxs, MSCI1_OFFSET + RXS, port);\r\nsca_out(txs, MSCI1_OFFSET + TXS, port);\r\nsca_set_port(port);\r\n}\r\nstatic int c101_open(struct net_device *dev)\r\n{\r\nport_t *port = dev_to_port(dev);\r\nint result;\r\nresult = hdlc_open(dev);\r\nif (result)\r\nreturn result;\r\nwriteb(1, port->win0base + C101_DTR);\r\nsca_out(0, MSCI1_OFFSET + CTL, port);\r\nsca_open(dev);\r\nsca_out(IE1_UDRN, MSCI0_OFFSET + IE1, port);\r\nsca_out(IE0_TXINT, MSCI0_OFFSET + IE0, port);\r\nset_carrier(port);\r\nsca_out(IE1_CDCD, MSCI1_OFFSET + IE1, port);\r\nsca_out(IE0_RXINTA, MSCI1_OFFSET + IE0, port);\r\nsca_out(0x48, IER0, port);\r\nc101_set_iface(port);\r\nreturn 0;\r\n}\r\nstatic int c101_close(struct net_device *dev)\r\n{\r\nport_t *port = dev_to_port(dev);\r\nsca_close(dev);\r\nwriteb(0, port->win0base + C101_DTR);\r\nsca_out(CTL_NORTS, MSCI1_OFFSET + CTL, port);\r\nhdlc_close(dev);\r\nreturn 0;\r\n}\r\nstatic int c101_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nconst size_t size = sizeof(sync_serial_settings);\r\nsync_serial_settings new_line;\r\nsync_serial_settings __user *line = ifr->ifr_settings.ifs_ifsu.sync;\r\nport_t *port = dev_to_port(dev);\r\n#ifdef DEBUG_RINGS\r\nif (cmd == SIOCDEVPRIVATE) {\r\nsca_dump_rings(dev);\r\nprintk(KERN_DEBUG "MSCI1: ST: %02x %02x %02x %02x\n",\r\nsca_in(MSCI1_OFFSET + ST0, port),\r\nsca_in(MSCI1_OFFSET + ST1, port),\r\nsca_in(MSCI1_OFFSET + ST2, port),\r\nsca_in(MSCI1_OFFSET + ST3, port));\r\nreturn 0;\r\n}\r\n#endif\r\nif (cmd != SIOCWANDEV)\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\nswitch(ifr->ifr_settings.type) {\r\ncase IF_GET_IFACE:\r\nifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\r\nif (ifr->ifr_settings.size < size) {\r\nifr->ifr_settings.size = size;\r\nreturn -ENOBUFS;\r\n}\r\nif (copy_to_user(line, &port->settings, size))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IF_IFACE_SYNC_SERIAL:\r\nif(!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&new_line, line, size))\r\nreturn -EFAULT;\r\nif (new_line.clock_type != CLOCK_EXT &&\r\nnew_line.clock_type != CLOCK_TXFROMRX &&\r\nnew_line.clock_type != CLOCK_INT &&\r\nnew_line.clock_type != CLOCK_TXINT)\r\nreturn -EINVAL;\r\nif (new_line.loopback != 0 && new_line.loopback != 1)\r\nreturn -EINVAL;\r\nmemcpy(&port->settings, &new_line, size);\r\nc101_set_iface(port);\r\nreturn 0;\r\ndefault:\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\n}\r\n}\r\nstatic void c101_destroy_card(card_t *card)\r\n{\r\nreadb(card->win0base + C101_PAGE);\r\nif (card->irq)\r\nfree_irq(card->irq, card);\r\nif (card->win0base) {\r\niounmap(card->win0base);\r\nrelease_mem_region(card->phy_winbase, C101_MAPPED_RAM_SIZE);\r\n}\r\nfree_netdev(card->dev);\r\nkfree(card);\r\n}\r\nstatic int __init c101_run(unsigned long irq, unsigned long winbase)\r\n{\r\nstruct net_device *dev;\r\nhdlc_device *hdlc;\r\ncard_t *card;\r\nint result;\r\nif (irq<3 || irq>15 || irq == 6) {\r\npr_err("invalid IRQ value\n");\r\nreturn -ENODEV;\r\n}\r\nif (winbase < 0xC0000 || winbase > 0xDFFFF || (winbase & 0x3FFF) !=0) {\r\npr_err("invalid RAM value\n");\r\nreturn -ENODEV;\r\n}\r\ncard = kzalloc(sizeof(card_t), GFP_KERNEL);\r\nif (card == NULL) {\r\npr_err("unable to allocate memory\n");\r\nreturn -ENOBUFS;\r\n}\r\ncard->dev = alloc_hdlcdev(card);\r\nif (!card->dev) {\r\npr_err("unable to allocate memory\n");\r\nkfree(card);\r\nreturn -ENOBUFS;\r\n}\r\nif (request_irq(irq, sca_intr, 0, devname, card)) {\r\npr_err("could not allocate IRQ\n");\r\nc101_destroy_card(card);\r\nreturn -EBUSY;\r\n}\r\ncard->irq = irq;\r\nif (!request_mem_region(winbase, C101_MAPPED_RAM_SIZE, devname)) {\r\npr_err("could not request RAM window\n");\r\nc101_destroy_card(card);\r\nreturn -EBUSY;\r\n}\r\ncard->phy_winbase = winbase;\r\ncard->win0base = ioremap(winbase, C101_MAPPED_RAM_SIZE);\r\nif (!card->win0base) {\r\npr_err("could not map I/O address\n");\r\nc101_destroy_card(card);\r\nreturn -EFAULT;\r\n}\r\ncard->tx_ring_buffers = TX_RING_BUFFERS;\r\ncard->rx_ring_buffers = RX_RING_BUFFERS;\r\ncard->buff_offset = C101_WINDOW_SIZE;\r\nreadb(card->win0base + C101_PAGE);\r\nudelay(100);\r\nwriteb(0, card->win0base + C101_PAGE);\r\nwriteb(0, card->win0base + C101_DTR);\r\nsca_init(card, 0);\r\ndev = port_to_dev(card);\r\nhdlc = dev_to_hdlc(dev);\r\nspin_lock_init(&card->lock);\r\ndev->irq = irq;\r\ndev->mem_start = winbase;\r\ndev->mem_end = winbase + C101_MAPPED_RAM_SIZE - 1;\r\ndev->tx_queue_len = 50;\r\ndev->netdev_ops = &c101_ops;\r\nhdlc->attach = sca_attach;\r\nhdlc->xmit = sca_xmit;\r\ncard->settings.clock_type = CLOCK_EXT;\r\nresult = register_hdlc_device(dev);\r\nif (result) {\r\npr_warn("unable to register hdlc device\n");\r\nc101_destroy_card(card);\r\nreturn result;\r\n}\r\nsca_init_port(card);\r\nset_carrier(card);\r\nnetdev_info(dev, "Moxa C101 on IRQ%u, using %u TX + %u RX packets rings\n",\r\ncard->irq, card->tx_ring_buffers, card->rx_ring_buffers);\r\n*new_card = card;\r\nnew_card = &card->next_card;\r\nreturn 0;\r\n}\r\nstatic int __init c101_init(void)\r\n{\r\nif (hw == NULL) {\r\n#ifdef MODULE\r\npr_info("no card initialized\n");\r\n#endif\r\nreturn -EINVAL;\r\n}\r\npr_info("%s\n", version);\r\ndo {\r\nunsigned long irq, ram;\r\nirq = simple_strtoul(hw, &hw, 0);\r\nif (*hw++ != ',')\r\nbreak;\r\nram = simple_strtoul(hw, &hw, 0);\r\nif (*hw == ':' || *hw == '\x0')\r\nc101_run(irq, ram);\r\nif (*hw == '\x0')\r\nreturn first_card ? 0 : -EINVAL;\r\n}while(*hw++ == ':');\r\npr_err("invalid hardware parameters\n");\r\nreturn first_card ? 0 : -EINVAL;\r\n}\r\nstatic void __exit c101_cleanup(void)\r\n{\r\ncard_t *card = first_card;\r\nwhile (card) {\r\ncard_t *ptr = card;\r\ncard = card->next_card;\r\nunregister_hdlc_device(port_to_dev(ptr));\r\nc101_destroy_card(ptr);\r\n}\r\n}
