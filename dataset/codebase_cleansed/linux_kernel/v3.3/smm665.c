static int smm665_read16(struct i2c_client *client, int reg)\r\n{\r\nint rv, val;\r\nrv = i2c_smbus_read_byte_data(client, reg);\r\nif (rv < 0)\r\nreturn rv;\r\nval = rv << 8;\r\nrv = i2c_smbus_read_byte_data(client, reg + 1);\r\nif (rv < 0)\r\nreturn rv;\r\nval |= rv;\r\nreturn val;\r\n}\r\nstatic int smm665_read_adc(struct smm665_data *data, int adc)\r\n{\r\nstruct i2c_client *client = data->cmdreg;\r\nint rv;\r\nint radc;\r\nrv = i2c_smbus_read_byte_data(client, adc << 3);\r\nif (rv != -ENXIO) {\r\ndev_dbg(&client->dev,\r\n"Unexpected return code %d when setting ADC index", rv);\r\nreturn (rv < 0) ? rv : -EIO;\r\n}\r\nudelay(data->conversion_time);\r\nrv = i2c_smbus_read_word_swapped(client, 0);\r\nif (rv < 0) {\r\ndev_dbg(&client->dev, "Failed to read ADC value: error %d", rv);\r\nreturn -1;\r\n}\r\nradc = (rv >> 11) & 0x0f;\r\nif (radc != adc) {\r\ndev_dbg(&client->dev, "Unexpected RADC: Expected %d got %d",\r\nadc, radc);\r\nreturn -EIO;\r\n}\r\nreturn rv & SMM665_ADC_MASK;\r\n}\r\nstatic struct smm665_data *smm665_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct smm665_data *data = i2c_get_clientdata(client);\r\nstruct smm665_data *ret = data;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\r\nint i, val;\r\nval = smm665_read16(client, SMM665_MISC8_STATUS1);\r\nif (unlikely(val < 0)) {\r\nret = ERR_PTR(val);\r\ngoto abort;\r\n}\r\ndata->faults = val;\r\nfor (i = 0; i < SMM665_NUM_ADC; i++) {\r\nval = smm665_read_adc(data, i);\r\nif (unlikely(val < 0)) {\r\nret = ERR_PTR(val);\r\ngoto abort;\r\n}\r\ndata->adc[i] = val;\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nabort:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int smm665_convert(u16 adcval, int index)\r\n{\r\nint val = 0;\r\nswitch (index) {\r\ncase SMM665_MISC16_ADC_DATA_12V:\r\nval = SMM665_12VIN_ADC_TO_VOLTS(adcval & SMM665_ADC_MASK);\r\nbreak;\r\ncase SMM665_MISC16_ADC_DATA_VDD:\r\ncase SMM665_MISC16_ADC_DATA_A:\r\ncase SMM665_MISC16_ADC_DATA_B:\r\ncase SMM665_MISC16_ADC_DATA_C:\r\ncase SMM665_MISC16_ADC_DATA_D:\r\ncase SMM665_MISC16_ADC_DATA_E:\r\ncase SMM665_MISC16_ADC_DATA_F:\r\nval = SMM665_VMON_ADC_TO_VOLTS(adcval & SMM665_ADC_MASK);\r\nbreak;\r\ncase SMM665_MISC16_ADC_DATA_AIN1:\r\ncase SMM665_MISC16_ADC_DATA_AIN2:\r\nval = SMM665_AIN_ADC_TO_VOLTS(adcval & SMM665_ADC_MASK);\r\nbreak;\r\ncase SMM665_MISC16_ADC_DATA_INT_TEMP:\r\nval = SMM665_TEMP_ADC_TO_CELSIUS(adcval & SMM665_ADC_MASK);\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nstatic int smm665_get_min(struct device *dev, int index)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct smm665_data *data = i2c_get_clientdata(client);\r\nreturn data->alarm_min_limit[index];\r\n}\r\nstatic int smm665_get_max(struct device *dev, int index)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct smm665_data *data = i2c_get_clientdata(client);\r\nreturn data->alarm_max_limit[index];\r\n}\r\nstatic int smm665_get_lcrit(struct device *dev, int index)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct smm665_data *data = i2c_get_clientdata(client);\r\nreturn data->critical_min_limit[index];\r\n}\r\nstatic int smm665_get_crit(struct device *dev, int index)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct smm665_data *data = i2c_get_clientdata(client);\r\nreturn data->critical_max_limit[index];\r\n}\r\nstatic ssize_t smm665_show_crit_alarm(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct smm665_data *data = smm665_update_device(dev);\r\nint val = 0;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nif (data->faults & (1 << attr->index))\r\nval = 1;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", val);\r\n}\r\nstatic ssize_t smm665_show_input(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct smm665_data *data = smm665_update_device(dev);\r\nint adc = attr->index;\r\nint val;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nval = smm665_convert(data->adc[adc], adc);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", val);\r\n}\r\nstatic int smm665_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct smm665_data *data;\r\nint i, ret;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA\r\n| I2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -ENODEV;\r\nif (i2c_smbus_read_byte_data(client, SMM665_ADOC_ENABLE) < 0)\r\nreturn -ENODEV;\r\nret = -ENOMEM;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\ngoto out_return;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\ndata->type = id->driver_data;\r\ndata->cmdreg = i2c_new_dummy(adapter, (client->addr & ~SMM665_REGMASK)\r\n| SMM665_CMDREG_BASE);\r\nif (!data->cmdreg)\r\ngoto out_kfree;\r\nswitch (data->type) {\r\ncase smm465:\r\ncase smm665:\r\ndata->conversion_time = SMM665_ADC_WAIT_SMM665;\r\nbreak;\r\ncase smm665c:\r\ncase smm764:\r\ncase smm766:\r\ndata->conversion_time = SMM665_ADC_WAIT_SMM766;\r\nbreak;\r\n}\r\nret = -ENODEV;\r\nif (i2c_smbus_read_byte_data(data->cmdreg, SMM665_MISC8_CMD_STS) < 0)\r\ngoto out_unregister;\r\nfor (i = 0; i < SMM665_NUM_ADC; i++) {\r\nint val;\r\nval = smm665_read16(client, SMM665_LIMIT_BASE + i * 8);\r\nif (unlikely(val < 0))\r\ngoto out_unregister;\r\ndata->critical_min_limit[i] = data->alarm_min_limit[i]\r\n= smm665_convert(val, i);\r\nval = smm665_read16(client, SMM665_LIMIT_BASE + i * 8 + 2);\r\nif (unlikely(val < 0))\r\ngoto out_unregister;\r\nif (smm665_is_critical(val))\r\ndata->critical_min_limit[i] = smm665_convert(val, i);\r\nelse\r\ndata->alarm_min_limit[i] = smm665_convert(val, i);\r\nval = smm665_read16(client, SMM665_LIMIT_BASE + i * 8 + 4);\r\nif (unlikely(val < 0))\r\ngoto out_unregister;\r\ndata->critical_max_limit[i] = data->alarm_max_limit[i]\r\n= smm665_convert(val, i);\r\nval = smm665_read16(client, SMM665_LIMIT_BASE + i * 8 + 6);\r\nif (unlikely(val < 0))\r\ngoto out_unregister;\r\nif (smm665_is_critical(val))\r\ndata->critical_max_limit[i] = smm665_convert(val, i);\r\nelse\r\ndata->alarm_max_limit[i] = smm665_convert(val, i);\r\n}\r\nret = sysfs_create_group(&client->dev.kobj, &smm665_group);\r\nif (ret)\r\ngoto out_unregister;\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nret = PTR_ERR(data->hwmon_dev);\r\ngoto out_remove_group;\r\n}\r\nreturn 0;\r\nout_remove_group:\r\nsysfs_remove_group(&client->dev.kobj, &smm665_group);\r\nout_unregister:\r\ni2c_unregister_device(data->cmdreg);\r\nout_kfree:\r\nkfree(data);\r\nout_return:\r\nreturn ret;\r\n}\r\nstatic int smm665_remove(struct i2c_client *client)\r\n{\r\nstruct smm665_data *data = i2c_get_clientdata(client);\r\ni2c_unregister_device(data->cmdreg);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &smm665_group);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init smm665_init(void)\r\n{\r\nreturn i2c_add_driver(&smm665_driver);\r\n}\r\nstatic void __exit smm665_exit(void)\r\n{\r\ni2c_del_driver(&smm665_driver);\r\n}
