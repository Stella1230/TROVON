static inline bool\r\nspi_match(u_int32_t min, u_int32_t max, u_int32_t spi, bool invert)\r\n{\r\nbool r;\r\npr_debug("spi_match:%c 0x%x <= 0x%x <= 0x%x\n",\r\ninvert ? '!' : ' ', min, spi, max);\r\nr=(spi >= min && spi <= max) ^ invert;\r\npr_debug(" result %s\n", r ? "PASS" : "FAILED");\r\nreturn r;\r\n}\r\nstatic bool ah_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstruct ip_auth_hdr _ahdr;\r\nconst struct ip_auth_hdr *ah;\r\nconst struct ipt_ah *ahinfo = par->matchinfo;\r\nif (par->fragoff != 0)\r\nreturn false;\r\nah = skb_header_pointer(skb, par->thoff, sizeof(_ahdr), &_ahdr);\r\nif (ah == NULL) {\r\npr_debug("Dropping evil AH tinygram.\n");\r\npar->hotdrop = true;\r\nreturn 0;\r\n}\r\nreturn spi_match(ahinfo->spis[0], ahinfo->spis[1],\r\nntohl(ah->spi),\r\n!!(ahinfo->invflags & IPT_AH_INV_SPI));\r\n}\r\nstatic int ah_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct ipt_ah *ahinfo = par->matchinfo;\r\nif (ahinfo->invflags & ~IPT_AH_INV_MASK) {\r\npr_debug("unknown flags %X\n", ahinfo->invflags);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ah_mt_init(void)\r\n{\r\nreturn xt_register_match(&ah_mt_reg);\r\n}\r\nstatic void __exit ah_mt_exit(void)\r\n{\r\nxt_unregister_match(&ah_mt_reg);\r\n}
