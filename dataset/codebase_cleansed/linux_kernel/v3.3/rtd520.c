static int rtd_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nstruct pci_dev *pcidev;\r\nint ret;\r\nresource_size_t physLas0;\r\nresource_size_t physLas1;\r\nresource_size_t physLcfg;\r\n#ifdef USE_DMA\r\nint index;\r\n#endif\r\nprintk(KERN_INFO "comedi%d: rtd520 attaching.\n", dev->minor);\r\n#if defined(CONFIG_COMEDI_DEBUG) && defined(USE_DMA)\r\nif (0 == comedi_debug)\r\ncomedi_debug = 1;\r\n#endif\r\nif (alloc_private(dev, sizeof(struct rtdPrivate)) < 0)\r\nreturn -ENOMEM;\r\nfor (pcidev = pci_get_device(PCI_VENDOR_ID_RTD, PCI_ANY_ID, NULL);\r\npcidev != NULL;\r\npcidev = pci_get_device(PCI_VENDOR_ID_RTD, PCI_ANY_ID, pcidev)) {\r\nint i;\r\nif (it->options[0] || it->options[1]) {\r\nif (pcidev->bus->number != it->options[0]\r\n|| PCI_SLOT(pcidev->devfn) != it->options[1]) {\r\ncontinue;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(rtd520Boards); ++i) {\r\nif (pcidev->device == rtd520Boards[i].device_id) {\r\ndev->board_ptr = &rtd520Boards[i];\r\nbreak;\r\n}\r\n}\r\nif (dev->board_ptr)\r\nbreak;\r\n}\r\nif (!pcidev) {\r\nif (it->options[0] && it->options[1]) {\r\nprintk(KERN_INFO "No RTD card at bus=%d slot=%d.\n",\r\nit->options[0], it->options[1]);\r\n} else {\r\nprintk(KERN_INFO "No RTD card found.\n");\r\n}\r\nreturn -EIO;\r\n}\r\ndevpriv->pci_dev = pcidev;\r\ndev->board_name = thisboard->name;\r\nret = comedi_pci_enable(pcidev, DRV_NAME);\r\nif (ret < 0) {\r\nprintk(KERN_INFO "Failed to enable PCI device and request regions.\n");\r\nreturn ret;\r\n}\r\ndevpriv->got_regions = 1;\r\nphysLas0 = pci_resource_start(devpriv->pci_dev, LAS0_PCIINDEX);\r\nphysLas1 = pci_resource_start(devpriv->pci_dev, LAS1_PCIINDEX);\r\nphysLcfg = pci_resource_start(devpriv->pci_dev, LCFG_PCIINDEX);\r\ndevpriv->las0 = ioremap_nocache(physLas0, LAS0_PCISIZE);\r\ndevpriv->las1 = ioremap_nocache(physLas1, LAS1_PCISIZE);\r\ndevpriv->lcfg = ioremap_nocache(physLcfg, LCFG_PCISIZE);\r\nif (!devpriv->las0 || !devpriv->las1 || !devpriv->lcfg)\r\nreturn -ENOMEM;\r\nDPRINTK("%s: LAS0=%llx, LAS1=%llx, CFG=%llx.\n", dev->board_name,\r\n(unsigned long long)physLas0, (unsigned long long)physLas1,\r\n(unsigned long long)physLcfg);\r\n{\r\nunsigned char pci_latency;\r\nu16 revision;\r\npci_read_config_word(devpriv->pci_dev, PCI_REVISION_ID,\r\n&revision);\r\nDPRINTK("%s: PCI revision %d.\n", dev->board_name, revision);\r\npci_read_config_byte(devpriv->pci_dev,\r\nPCI_LATENCY_TIMER, &pci_latency);\r\nif (pci_latency < 32) {\r\nprintk(KERN_INFO "%s: PCI latency changed from %d to %d\n",\r\ndev->board_name, pci_latency, 32);\r\npci_write_config_byte(devpriv->pci_dev,\r\nPCI_LATENCY_TIMER, 32);\r\n} else {\r\nDPRINTK("rtd520: PCI latency = %d\n", pci_latency);\r\n}\r\n}\r\nprintk(KERN_INFO "%s:", dev->board_name);\r\nif (alloc_subdevices(dev, 4) < 0)\r\nreturn -ENOMEM;\r\ns = dev->subdevices + 0;\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags =\r\nSDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF | SDF_CMD_READ;\r\ns->n_chan = thisboard->aiChans;\r\ns->maxdata = (1 << thisboard->aiBits) - 1;\r\nif (thisboard->aiMaxGain <= 32)\r\ns->range_table = &rtd_ai_7520_range;\r\nelse\r\ns->range_table = &rtd_ai_4520_range;\r\ns->len_chanlist = RTD_MAX_CHANLIST;\r\ns->insn_read = rtd_ai_rinsn;\r\ns->do_cmd = rtd_ai_cmd;\r\ns->do_cmdtest = rtd_ai_cmdtest;\r\ns->cancel = rtd_ai_cancel;\r\ns = dev->subdevices + 1;\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 2;\r\ns->maxdata = (1 << thisboard->aiBits) - 1;\r\ns->range_table = &rtd_ao_range;\r\ns->insn_write = rtd_ao_winsn;\r\ns->insn_read = rtd_ao_rinsn;\r\ns = dev->subdevices + 2;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = rtd_dio_insn_bits;\r\ns->insn_config = rtd_dio_insn_config;\r\ns = dev->subdevices + 3;\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 3;\r\ns->maxdata = 0xffff;\r\nRtdResetBoard(dev);\r\nudelay(100);\r\nRtdPlxInterruptWrite(dev, 0);\r\nRtdInterruptMask(dev, 0);\r\nRtdInterruptClearMask(dev, ~0);\r\nRtdInterruptClear(dev);\r\nRtdInterruptOverrunClear(dev);\r\nRtdClearCGT(dev);\r\nRtdAdcClearFifo(dev);\r\nRtdDacClearFifo(dev, 0);\r\nRtdDacClearFifo(dev, 1);\r\nRtdDioStatusWrite(dev, 0);\r\nRtdUtcCtrlPut(dev, 0, 0x30);\r\nRtdUtcCtrlPut(dev, 1, 0x30);\r\nRtdUtcCtrlPut(dev, 2, 0x30);\r\nRtdUtcCtrlPut(dev, 3, 0);\r\nret = request_irq(devpriv->pci_dev->irq, rtd_interrupt,\r\nIRQF_SHARED, DRV_NAME, dev);\r\nif (ret < 0) {\r\nprintk("Could not get interrupt! (%u)\n",\r\ndevpriv->pci_dev->irq);\r\nreturn ret;\r\n}\r\ndev->irq = devpriv->pci_dev->irq;\r\nprintk(KERN_INFO "( irq=%u )", dev->irq);\r\nret = rtd520_probe_fifo_depth(dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndevpriv->fifoLen = ret;\r\nprintk("( fifoLen=%d )", devpriv->fifoLen);\r\n#ifdef USE_DMA\r\nif (dev->irq > 0) {\r\nprintk("( DMA buff=%d )\n", DMA_CHAIN_COUNT);\r\ndevpriv->dma0Offset = 0;\r\nfor (index = 0; index < DMA_CHAIN_COUNT; index++) {\r\ndevpriv->dma0Buff[index] =\r\npci_alloc_consistent(devpriv->pci_dev,\r\nsizeof(u16) *\r\ndevpriv->fifoLen / 2,\r\n&devpriv->\r\ndma0BuffPhysAddr[index]);\r\nif (devpriv->dma0Buff[index] == NULL) {\r\nret = -ENOMEM;\r\ngoto rtd_attach_die_error;\r\n}\r\n}\r\ndevpriv->dma0Chain =\r\npci_alloc_consistent(devpriv->pci_dev,\r\nsizeof(struct plx_dma_desc) *\r\nDMA_CHAIN_COUNT,\r\n&devpriv->dma0ChainPhysAddr);\r\nfor (index = 0; index < DMA_CHAIN_COUNT; index++) {\r\ndevpriv->dma0Chain[index].pci_start_addr =\r\ndevpriv->dma0BuffPhysAddr[index];\r\ndevpriv->dma0Chain[index].local_start_addr =\r\nDMALADDR_ADC;\r\ndevpriv->dma0Chain[index].transfer_size =\r\nsizeof(u16) * devpriv->fifoLen / 2;\r\ndevpriv->dma0Chain[index].next =\r\n(devpriv->dma0ChainPhysAddr + ((index +\r\n1) %\r\n(DMA_CHAIN_COUNT))\r\n* sizeof(devpriv->dma0Chain[0]))\r\n| DMA_TRANSFER_BITS;\r\n}\r\nif (devpriv->dma0Chain == NULL) {\r\nret = -ENOMEM;\r\ngoto rtd_attach_die_error;\r\n}\r\nRtdDma0Mode(dev, DMA_MODE_BITS);\r\nRtdDma0Source(dev, DMAS_ADFIFO_HALF_FULL);\r\n} else {\r\nprintk(KERN_INFO "( no IRQ->no DMA )");\r\n}\r\n#endif\r\nif (dev->irq) {\r\nRtdPlxInterruptWrite(dev, ICS_PIE | ICS_PLIE);\r\n}\r\nprintk("\ncomedi%d: rtd520 driver attached.\n", dev->minor);\r\nreturn 1;\r\n#if 0\r\n#ifdef USE_DMA\r\nfor (index = 0; index < DMA_CHAIN_COUNT; index++) {\r\nif (NULL != devpriv->dma0Buff[index]) {\r\npci_free_consistent(devpriv->pci_dev,\r\nsizeof(u16) * devpriv->fifoLen / 2,\r\ndevpriv->dma0Buff[index],\r\ndevpriv->dma0BuffPhysAddr[index]);\r\ndevpriv->dma0Buff[index] = NULL;\r\n}\r\n}\r\nif (NULL != devpriv->dma0Chain) {\r\npci_free_consistent(devpriv->pci_dev,\r\nsizeof(struct plx_dma_desc)\r\n* DMA_CHAIN_COUNT,\r\ndevpriv->dma0Chain,\r\ndevpriv->dma0ChainPhysAddr);\r\ndevpriv->dma0Chain = NULL;\r\n}\r\n#endif\r\nif (dev->irq) {\r\nRtdPlxInterruptWrite(dev, RtdPlxInterruptRead(dev)\r\n& ~(ICS_PLIE | ICS_DMA0_E | ICS_DMA1_E));\r\nfree_irq(dev->irq, dev);\r\n}\r\nif (devpriv->las0)\r\niounmap(devpriv->las0);\r\nif (devpriv->las1)\r\niounmap(devpriv->las1);\r\nif (devpriv->lcfg)\r\niounmap(devpriv->lcfg);\r\nif (devpriv->pci_dev)\r\npci_dev_put(devpriv->pci_dev);\r\nreturn ret;\r\n#endif\r\n}\r\nstatic int rtd_detach(struct comedi_device *dev)\r\n{\r\n#ifdef USE_DMA\r\nint index;\r\n#endif\r\nDPRINTK("comedi%d: rtd520: removing (%ld ints)\n",\r\ndev->minor, (devpriv ? devpriv->intCount : 0L));\r\nif (devpriv && devpriv->lcfg) {\r\nDPRINTK\r\n("(int status 0x%x, overrun status 0x%x, fifo status 0x%x)...\n",\r\n0xffff & RtdInterruptStatus(dev),\r\n0xffff & RtdInterruptOverrunStatus(dev),\r\n(0xffff & RtdFifoStatus(dev)) ^ 0x6666);\r\n}\r\nif (devpriv) {\r\n#ifdef USE_DMA\r\nif (devpriv->lcfg) {\r\nRtdDma0Control(dev, 0);\r\nRtdDma1Control(dev, 0);\r\nRtdPlxInterruptWrite(dev, ICS_PIE | ICS_PLIE);\r\n}\r\n#endif\r\nif (devpriv->las0) {\r\nRtdResetBoard(dev);\r\nRtdInterruptMask(dev, 0);\r\nRtdInterruptClearMask(dev, ~0);\r\nRtdInterruptClear(dev);\r\n}\r\n#ifdef USE_DMA\r\nfor (index = 0; index < DMA_CHAIN_COUNT; index++) {\r\nif (NULL != devpriv->dma0Buff[index]) {\r\npci_free_consistent(devpriv->pci_dev,\r\nsizeof(u16) *\r\ndevpriv->fifoLen / 2,\r\ndevpriv->dma0Buff[index],\r\ndevpriv->\r\ndma0BuffPhysAddr[index]);\r\ndevpriv->dma0Buff[index] = NULL;\r\n}\r\n}\r\nif (NULL != devpriv->dma0Chain) {\r\npci_free_consistent(devpriv->pci_dev,\r\nsizeof(struct plx_dma_desc) *\r\nDMA_CHAIN_COUNT, devpriv->dma0Chain,\r\ndevpriv->dma0ChainPhysAddr);\r\ndevpriv->dma0Chain = NULL;\r\n}\r\n#endif\r\nif (dev->irq) {\r\nRtdPlxInterruptWrite(dev, RtdPlxInterruptRead(dev)\r\n& ~(ICS_PLIE | ICS_DMA0_E |\r\nICS_DMA1_E));\r\nfree_irq(dev->irq, dev);\r\n}\r\nif (devpriv->las0)\r\niounmap(devpriv->las0);\r\nif (devpriv->las1)\r\niounmap(devpriv->las1);\r\nif (devpriv->lcfg)\r\niounmap(devpriv->lcfg);\r\nif (devpriv->pci_dev) {\r\nif (devpriv->got_regions)\r\ncomedi_pci_disable(devpriv->pci_dev);\r\npci_dev_put(devpriv->pci_dev);\r\n}\r\n}\r\nprintk(KERN_INFO "comedi%d: rtd520: removed.\n", dev->minor);\r\nreturn 0;\r\n}\r\nstatic unsigned short rtdConvertChanGain(struct comedi_device *dev,\r\nunsigned int comediChan, int chanIndex)\r\n{\r\nunsigned int chan, range, aref;\r\nunsigned short r = 0;\r\nchan = CR_CHAN(comediChan);\r\nrange = CR_RANGE(comediChan);\r\naref = CR_AREF(comediChan);\r\nr |= chan & 0xf;\r\nif (range < thisboard->range10Start) {\r\nr |= 0x000;\r\nr |= (range & 0x7) << 4;\r\nCHAN_ARRAY_SET(devpriv->chanBipolar, chanIndex);\r\n} else if (range < thisboard->rangeUniStart) {\r\nr |= 0x100;\r\nr |= ((range - thisboard->range10Start) & 0x7) << 4;\r\nCHAN_ARRAY_SET(devpriv->chanBipolar, chanIndex);\r\n} else {\r\nr |= 0x200;\r\nr |= ((range - thisboard->rangeUniStart) & 0x7) << 4;\r\nCHAN_ARRAY_CLEAR(devpriv->chanBipolar, chanIndex);\r\n}\r\nswitch (aref) {\r\ncase AREF_GROUND:\r\nbreak;\r\ncase AREF_COMMON:\r\nr |= 0x80;\r\nbreak;\r\ncase AREF_DIFF:\r\nr |= 0x400;\r\nbreak;\r\ncase AREF_OTHER:\r\nbreak;\r\n}\r\nreturn r;\r\n}\r\nstatic void rtd_load_channelgain_list(struct comedi_device *dev,\r\nunsigned int n_chan, unsigned int *list)\r\n{\r\nif (n_chan > 1) {\r\nint ii;\r\nRtdClearCGT(dev);\r\nRtdEnableCGT(dev, 1);\r\nfor (ii = 0; ii < n_chan; ii++) {\r\nRtdWriteCGTable(dev, rtdConvertChanGain(dev, list[ii],\r\nii));\r\n}\r\n} else {\r\nRtdEnableCGT(dev, 0);\r\nRtdWriteCGLatch(dev, rtdConvertChanGain(dev, list[0], 0));\r\n}\r\n}\r\nstatic int rtd520_probe_fifo_depth(struct comedi_device *dev)\r\n{\r\nunsigned int chanspec = CR_PACK(0, 0, AREF_GROUND);\r\nunsigned i;\r\nstatic const unsigned limit = 0x2000;\r\nunsigned fifo_size = 0;\r\nRtdAdcClearFifo(dev);\r\nrtd_load_channelgain_list(dev, 1, &chanspec);\r\nRtdAdcConversionSource(dev, 0);\r\nfor (i = 0; i < limit; ++i) {\r\nunsigned fifo_status;\r\nRtdAdcStart(dev);\r\nudelay(1);\r\nfifo_status = RtdFifoStatus(dev);\r\nif ((fifo_status & FS_ADC_HEMPTY) == 0) {\r\nfifo_size = 2 * i;\r\nbreak;\r\n}\r\n}\r\nif (i == limit) {\r\nprintk(KERN_INFO "\ncomedi: %s: failed to probe fifo size.\n", DRV_NAME);\r\nreturn -EIO;\r\n}\r\nRtdAdcClearFifo(dev);\r\nif (fifo_size != 0x400 && fifo_size != 0x2000) {\r\nprintk\r\n(KERN_INFO "\ncomedi: %s: unexpected fifo size of %i, expected 1024 or 8192.\n",\r\nDRV_NAME, fifo_size);\r\nreturn -EIO;\r\n}\r\nreturn fifo_size;\r\n}\r\nstatic int rtd_ai_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint n, ii;\r\nint stat;\r\nRtdAdcClearFifo(dev);\r\nrtd_load_channelgain_list(dev, 1, &insn->chanspec);\r\nRtdAdcConversionSource(dev, 0);\r\nfor (n = 0; n < insn->n; n++) {\r\ns16 d;\r\nRtdAdcStart(dev);\r\nfor (ii = 0; ii < RTD_ADC_TIMEOUT; ++ii) {\r\nstat = RtdFifoStatus(dev);\r\nif (stat & FS_ADC_NOT_EMPTY)\r\nbreak;\r\nWAIT_QUIETLY;\r\n}\r\nif (ii >= RTD_ADC_TIMEOUT) {\r\nDPRINTK\r\n("rtd520: Error: ADC never finished! FifoStatus=0x%x\n",\r\nstat ^ 0x6666);\r\nreturn -ETIMEDOUT;\r\n}\r\nd = RtdAdcFifoGet(dev);\r\nd = d >> 3;\r\nif (CHAN_ARRAY_TEST(devpriv->chanBipolar, 0))\r\ndata[n] = d + 2048;\r\nelse\r\ndata[n] = d;\r\n}\r\nreturn n;\r\n}\r\nstatic int ai_read_n(struct comedi_device *dev, struct comedi_subdevice *s,\r\nint count)\r\n{\r\nint ii;\r\nfor (ii = 0; ii < count; ii++) {\r\nshort sample;\r\ns16 d;\r\nif (0 == devpriv->aiCount) {\r\nd = RtdAdcFifoGet(dev);\r\ncontinue;\r\n}\r\n#if 0\r\nif (0 == (RtdFifoStatus(dev) & FS_ADC_NOT_EMPTY)) {\r\nDPRINTK("comedi: READ OOPS on %d of %d\n", ii + 1,\r\ncount);\r\nbreak;\r\n}\r\n#endif\r\nd = RtdAdcFifoGet(dev);\r\nd = d >> 3;\r\nif (CHAN_ARRAY_TEST(devpriv->chanBipolar, s->async->cur_chan))\r\nsample = d + 2048;\r\nelse\r\nsample = d;\r\nif (!comedi_buf_put(s->async, sample))\r\nreturn -1;\r\nif (devpriv->aiCount > 0)\r\ndevpriv->aiCount--;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ai_read_dregs(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nwhile (RtdFifoStatus(dev) & FS_ADC_NOT_EMPTY) {\r\nshort sample;\r\ns16 d = RtdAdcFifoGet(dev);\r\nif (0 == devpriv->aiCount) {\r\ncontinue;\r\n}\r\nd = d >> 3;\r\nif (CHAN_ARRAY_TEST(devpriv->chanBipolar, s->async->cur_chan))\r\nsample = d + 2048;\r\nelse\r\nsample = d;\r\nif (!comedi_buf_put(s->async, sample))\r\nreturn -1;\r\nif (devpriv->aiCount > 0)\r\ndevpriv->aiCount--;\r\n}\r\nreturn 0;\r\n}\r\nvoid abort_dma(struct comedi_device *dev, unsigned int channel)\r\n{\r\nunsigned long dma_cs_addr;\r\nuint8_t status;\r\nunsigned int ii;\r\ndma_cs_addr = (unsigned long)devpriv->lcfg\r\n+ ((channel == 0) ? LCFG_DMACSR0 : LCFG_DMACSR1);\r\nstatus = readb(dma_cs_addr);\r\nif ((status & PLX_DMA_EN_BIT) == 0) {\r\nDPRINTK("rtd520: AbortDma on non-active channel %d (0x%x)\n",\r\nchannel, status);\r\ngoto abortDmaExit;\r\n}\r\nfor (ii = 0; (status & PLX_DMA_DONE_BIT) && ii < RTD_DMA_TIMEOUT; ii++) {\r\nWAIT_QUIETLY;\r\nstatus = readb(dma_cs_addr);\r\n}\r\nif (status & PLX_DMA_DONE_BIT) {\r\nprintk("rtd520: Timeout waiting for dma %i done clear\n",\r\nchannel);\r\ngoto abortDmaExit;\r\n}\r\nwriteb(0, dma_cs_addr);\r\nudelay(1);\r\nwriteb(PLX_DMA_ABORT_BIT, dma_cs_addr);\r\nstatus = readb(dma_cs_addr);\r\nfor (ii = 0;\r\n(status & PLX_DMA_DONE_BIT) == 0 && ii < RTD_DMA_TIMEOUT; ii++) {\r\nstatus = readb(dma_cs_addr);\r\nWAIT_QUIETLY;\r\n}\r\nif ((status & PLX_DMA_DONE_BIT) == 0) {\r\nprintk("rtd520: Timeout waiting for dma %i done set\n",\r\nchannel);\r\n}\r\nabortDmaExit:\r\n}\r\nstatic irqreturn_t rtd_interrupt(int irq,\r\nvoid *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nu16 status;\r\nu16 fifoStatus;\r\nstruct comedi_subdevice *s = dev->subdevices + 0;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\ndevpriv->intCount++;\r\nfifoStatus = RtdFifoStatus(dev);\r\nif (!(fifoStatus & FS_ADC_NOT_FULL)) {\r\nDPRINTK("rtd520: FIFO full! fifo_status=0x%x\n", (fifoStatus ^ 0x6666) & 0x7777);\r\ngoto abortTransfer;\r\n}\r\n#ifdef USE_DMA\r\nif (devpriv->flags & DMA0_ACTIVE) {\r\nu32 istatus = RtdPlxInterruptRead(dev);\r\nif (istatus & ICS_DMA0_A) {\r\nif (ai_process_dma(dev, s) < 0) {\r\nDPRINTK\r\n("rtd520: comedi read buffer overflow (DMA) with %ld to go!\n",\r\ndevpriv->aiCount);\r\nRtdDma0Control(dev,\r\n(devpriv->dma0Control &\r\n~PLX_DMA_START_BIT)\r\n| PLX_CLEAR_DMA_INTR_BIT);\r\ngoto abortTransfer;\r\n}\r\nRtdDma0Control(dev,\r\n(devpriv->\r\ndma0Control & ~PLX_DMA_START_BIT)\r\n| PLX_CLEAR_DMA_INTR_BIT);\r\nif (0 == devpriv->aiCount) {\r\nDPRINTK("rtd520: Samples Done (DMA).\n");\r\ngoto transferDone;\r\n}\r\ncomedi_event(dev, s);\r\n} else {\r\n}\r\n}\r\n#endif\r\nstatus = RtdInterruptStatus(dev);\r\nif (0 == status)\r\nreturn IRQ_HANDLED;\r\nif (status & IRQM_ADC_ABOUT_CNT) {\r\nif (!(fifoStatus & FS_ADC_HEMPTY)) {\r\nif (ai_read_n(dev, s, devpriv->fifoLen / 2) < 0) {\r\nDPRINTK\r\n("rtd520: comedi read buffer overflow (1/2FIFO) with %ld to go!\n",\r\ndevpriv->aiCount);\r\ngoto abortTransfer;\r\n}\r\nif (0 == devpriv->aiCount) {\r\nDPRINTK("rtd520: Samples Done (1/2). fifo_status was 0x%x\n", (fifoStatus ^ 0x6666) & 0x7777);\r\ngoto transferDone;\r\n}\r\ncomedi_event(dev, s);\r\n} else if (devpriv->transCount > 0) {\r\nif (fifoStatus & FS_ADC_NOT_EMPTY) {\r\nif (ai_read_n(dev, s, devpriv->transCount) < 0) {\r\nDPRINTK\r\n("rtd520: comedi read buffer overflow (N) with %ld to go!\n",\r\ndevpriv->aiCount);\r\ngoto abortTransfer;\r\n}\r\nif (0 == devpriv->aiCount) {\r\nDPRINTK\r\n("rtd520: Samples Done (N). fifo_status was 0x%x\n",\r\n(fifoStatus ^ 0x6666) & 0x7777);\r\ngoto transferDone;\r\n}\r\ncomedi_event(dev, s);\r\n}\r\n} else {\r\nDPRINTK\r\n("rtd520: Sample int. Wait for 1/2. fifo_status 0x%x\n",\r\n(fifoStatus ^ 0x6666) & 0x7777);\r\n}\r\n} else {\r\nDPRINTK("rtd520: unknown interrupt source!\n");\r\n}\r\nif (0xffff & RtdInterruptOverrunStatus(dev)) {\r\nDPRINTK\r\n("rtd520: Interrupt overrun with %ld to go! over_status=0x%x\n",\r\ndevpriv->aiCount, 0xffff & RtdInterruptOverrunStatus(dev));\r\ngoto abortTransfer;\r\n}\r\nRtdInterruptClearMask(dev, status);\r\nRtdInterruptClear(dev);\r\nreturn IRQ_HANDLED;\r\nabortTransfer:\r\nRtdAdcClearFifo(dev);\r\ns->async->events |= COMEDI_CB_ERROR;\r\ndevpriv->aiCount = 0;\r\ntransferDone:\r\nRtdPacerStopSource(dev, 0);\r\nRtdPacerStop(dev);\r\nRtdAdcConversionSource(dev, 0);\r\nRtdInterruptMask(dev, 0);\r\n#ifdef USE_DMA\r\nif (devpriv->flags & DMA0_ACTIVE) {\r\nRtdPlxInterruptWrite(dev,\r\nRtdPlxInterruptRead(dev) & ~ICS_DMA0_E);\r\nabort_dma(dev, 0);\r\ndevpriv->flags &= ~DMA0_ACTIVE;\r\nif (devpriv->aiCount > 0) {\r\nDPRINTK("rtd520: Lost DMA data! %ld remain\n",\r\ndevpriv->aiCount);\r\n}\r\n}\r\n#endif\r\nif (devpriv->aiCount > 0) {\r\nfifoStatus = RtdFifoStatus(dev);\r\nDPRINTK("rtd520: Finishing up. %ld remain, fifoStat=%x\n", devpriv->aiCount, (fifoStatus ^ 0x6666) & 0x7777);\r\nai_read_dregs(dev, s);\r\n}\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_event(dev, s);\r\nstatus = RtdInterruptStatus(dev);\r\nRtdInterruptClearMask(dev, status);\r\nRtdInterruptClear(dev);\r\nfifoStatus = RtdFifoStatus(dev);\r\nDPRINTK\r\n("rtd520: Acquisition complete. %ld ints, intStat=%x, overStat=%x\n",\r\ndevpriv->intCount, status,\r\n0xffff & RtdInterruptOverrunStatus(dev));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rtd_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_TIMER | TRIG_EXT;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->scan_begin_src != TRIG_TIMER &&\r\ncmd->scan_begin_src != TRIG_EXT) {\r\nerr++;\r\n}\r\nif (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (1 == cmd->chanlist_len) {\r\nif (cmd->scan_begin_arg < RTD_MAX_SPEED_1) {\r\ncmd->scan_begin_arg = RTD_MAX_SPEED_1;\r\nrtd_ns_to_timer(&cmd->scan_begin_arg,\r\nTRIG_ROUND_UP);\r\nerr++;\r\n}\r\nif (cmd->scan_begin_arg > RTD_MIN_SPEED_1) {\r\ncmd->scan_begin_arg = RTD_MIN_SPEED_1;\r\nrtd_ns_to_timer(&cmd->scan_begin_arg,\r\nTRIG_ROUND_DOWN);\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->scan_begin_arg < RTD_MAX_SPEED) {\r\ncmd->scan_begin_arg = RTD_MAX_SPEED;\r\nrtd_ns_to_timer(&cmd->scan_begin_arg,\r\nTRIG_ROUND_UP);\r\nerr++;\r\n}\r\nif (cmd->scan_begin_arg > RTD_MIN_SPEED) {\r\ncmd->scan_begin_arg = RTD_MIN_SPEED;\r\nrtd_ns_to_timer(&cmd->scan_begin_arg,\r\nTRIG_ROUND_DOWN);\r\nerr++;\r\n}\r\n}\r\n} else {\r\nif (cmd->scan_begin_arg > 9) {\r\ncmd->scan_begin_arg = 9;\r\nerr++;\r\n}\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (1 == cmd->chanlist_len) {\r\nif (cmd->convert_arg < RTD_MAX_SPEED_1) {\r\ncmd->convert_arg = RTD_MAX_SPEED_1;\r\nrtd_ns_to_timer(&cmd->convert_arg,\r\nTRIG_ROUND_UP);\r\nerr++;\r\n}\r\nif (cmd->convert_arg > RTD_MIN_SPEED_1) {\r\ncmd->convert_arg = RTD_MIN_SPEED_1;\r\nrtd_ns_to_timer(&cmd->convert_arg,\r\nTRIG_ROUND_DOWN);\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->convert_arg < RTD_MAX_SPEED) {\r\ncmd->convert_arg = RTD_MAX_SPEED;\r\nrtd_ns_to_timer(&cmd->convert_arg,\r\nTRIG_ROUND_UP);\r\nerr++;\r\n}\r\nif (cmd->convert_arg > RTD_MIN_SPEED) {\r\ncmd->convert_arg = RTD_MIN_SPEED;\r\nrtd_ns_to_timer(&cmd->convert_arg,\r\nTRIG_ROUND_DOWN);\r\nerr++;\r\n}\r\n}\r\n} else {\r\nif (cmd->convert_arg > 9) {\r\ncmd->convert_arg = 9;\r\nerr++;\r\n}\r\n}\r\n#if 0\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\n#endif\r\nif (cmd->stop_src == TRIG_COUNT) {\r\n} else {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->chanlist_len > RTD_MAX_CHANLIST) {\r\ncmd->chanlist_len = RTD_MAX_CHANLIST;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp = cmd->scan_begin_arg;\r\nrtd_ns_to_timer(&cmd->scan_begin_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ntmp = cmd->convert_arg;\r\nrtd_ns_to_timer(&cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->convert_arg)\r\nerr++;\r\nif (cmd->scan_begin_src == TRIG_TIMER\r\n&& (cmd->scan_begin_arg\r\n< (cmd->convert_arg * cmd->scan_end_arg))) {\r\ncmd->scan_begin_arg =\r\ncmd->convert_arg * cmd->scan_end_arg;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int rtd_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint timer;\r\nRtdPacerStopSource(dev, 0);\r\nRtdPacerStop(dev);\r\nRtdAdcConversionSource(dev, 0);\r\nRtdInterruptMask(dev, 0);\r\n#ifdef USE_DMA\r\nif (devpriv->flags & DMA0_ACTIVE) {\r\nRtdPlxInterruptWrite(dev,\r\nRtdPlxInterruptRead(dev) & ~ICS_DMA0_E);\r\nabort_dma(dev, 0);\r\ndevpriv->flags &= ~DMA0_ACTIVE;\r\nif (RtdPlxInterruptRead(dev) & ICS_DMA0_A) {\r\nRtdDma0Control(dev, PLX_CLEAR_DMA_INTR_BIT);\r\n}\r\n}\r\nRtdDma0Reset(dev);\r\n#endif\r\nRtdAdcClearFifo(dev);\r\nRtdInterruptOverrunClear(dev);\r\ndevpriv->intCount = 0;\r\nif (!dev->irq) {\r\nDPRINTK("rtd520: ERROR! No interrupt available!\n");\r\nreturn -ENXIO;\r\n}\r\nrtd_load_channelgain_list(dev, cmd->chanlist_len, cmd->chanlist);\r\nif (cmd->chanlist_len > 1) {\r\nRtdPacerStartSource(dev, 0);\r\nRtdBurstStartSource(dev, 1);\r\nRtdAdcConversionSource(dev, 2);\r\n} else {\r\nRtdPacerStartSource(dev, 0);\r\nRtdAdcConversionSource(dev, 1);\r\n}\r\nRtdAboutCounter(dev, devpriv->fifoLen / 2 - 1);\r\nif (TRIG_TIMER == cmd->scan_begin_src) {\r\nif (cmd->flags & TRIG_WAKE_EOS) {\r\ndevpriv->transCount = cmd->chanlist_len;\r\ndevpriv->flags |= SEND_EOS;\r\n} else {\r\ndevpriv->transCount\r\n=\r\n(TRANS_TARGET_PERIOD * cmd->chanlist_len) /\r\ncmd->scan_begin_arg;\r\nif (devpriv->transCount < cmd->chanlist_len) {\r\ndevpriv->transCount = cmd->chanlist_len;\r\n} else {\r\ndevpriv->transCount =\r\n(devpriv->transCount +\r\ncmd->chanlist_len - 1)\r\n/ cmd->chanlist_len;\r\ndevpriv->transCount *= cmd->chanlist_len;\r\n}\r\ndevpriv->flags |= SEND_EOS;\r\n}\r\nif (devpriv->transCount >= (devpriv->fifoLen / 2)) {\r\ndevpriv->transCount = 0;\r\ndevpriv->flags &= ~SEND_EOS;\r\n} else {\r\nRtdAboutCounter(dev, devpriv->transCount - 1);\r\n}\r\nDPRINTK\r\n("rtd520: scanLen=%d tranferCount=%d fifoLen=%d\n scanTime(ns)=%d flags=0x%x\n",\r\ncmd->chanlist_len, devpriv->transCount, devpriv->fifoLen,\r\ncmd->scan_begin_arg, devpriv->flags);\r\n} else {\r\ndevpriv->transCount = 0;\r\ndevpriv->flags &= ~SEND_EOS;\r\n}\r\nRtdPacerClockSource(dev, 1);\r\nRtdAboutStopEnable(dev, 1);\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\ndevpriv->aiCount = cmd->stop_arg * cmd->chanlist_len;\r\nif ((devpriv->transCount > 0)\r\n&& (devpriv->transCount > devpriv->aiCount)) {\r\ndevpriv->transCount = devpriv->aiCount;\r\n}\r\nbreak;\r\ncase TRIG_NONE:\r\ndevpriv->aiCount = -1;\r\nbreak;\r\ndefault:\r\nDPRINTK("rtd520: Warning! ignoring stop_src mode %d\n",\r\ncmd->stop_src);\r\n}\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\ntimer = rtd_ns_to_timer(&cmd->scan_begin_arg,\r\nTRIG_ROUND_NEAREST);\r\nRtdPacerCounter(dev, timer);\r\nbreak;\r\ncase TRIG_EXT:\r\nRtdPacerStartSource(dev, 1);\r\nbreak;\r\ndefault:\r\nDPRINTK("rtd520: Warning! ignoring scan_begin_src mode %d\n",\r\ncmd->scan_begin_src);\r\n}\r\nswitch (cmd->convert_src) {\r\ncase TRIG_TIMER:\r\nif (cmd->chanlist_len > 1) {\r\ntimer = rtd_ns_to_timer(&cmd->convert_arg,\r\nTRIG_ROUND_NEAREST);\r\nRtdBurstCounter(dev, timer);\r\n}\r\nbreak;\r\ncase TRIG_EXT:\r\nRtdBurstStartSource(dev, 2);\r\nbreak;\r\ndefault:\r\nDPRINTK("rtd520: Warning! ignoring convert_src mode %d\n",\r\ncmd->convert_src);\r\n}\r\nRtdInterruptClearMask(dev, ~0);\r\nRtdInterruptClear(dev);\r\nif (devpriv->transCount > 0) {\r\nRtdInterruptMask(dev, IRQM_ADC_ABOUT_CNT);\r\nDPRINTK("rtd520: Transferring every %d\n", devpriv->transCount);\r\n} else {\r\n#ifdef USE_DMA\r\ndevpriv->flags |= DMA0_ACTIVE;\r\ndevpriv->dma0Offset = 0;\r\nRtdDma0Mode(dev, DMA_MODE_BITS);\r\nRtdDma0Next(dev,\r\ndevpriv->dma0Chain[DMA_CHAIN_COUNT - 1].next);\r\nRtdDma0Source(dev, DMAS_ADFIFO_HALF_FULL);\r\nRtdPlxInterruptWrite(dev,\r\nRtdPlxInterruptRead(dev) | ICS_DMA0_E);\r\nRtdDma0Control(dev, PLX_DMA_EN_BIT);\r\nRtdDma0Control(dev, PLX_DMA_EN_BIT | PLX_DMA_START_BIT);\r\nDPRINTK("rtd520: Using DMA0 transfers. plxInt %x RtdInt %x\n",\r\nRtdPlxInterruptRead(dev), devpriv->intMask);\r\n#else\r\nRtdInterruptMask(dev, IRQM_ADC_ABOUT_CNT);\r\nDPRINTK("rtd520: Transferring every 1/2 FIFO\n");\r\n#endif\r\n}\r\nRtdPacerStart(dev);\r\nreturn 0;\r\n}\r\nstatic int rtd_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nu16 status;\r\nRtdPacerStopSource(dev, 0);\r\nRtdPacerStop(dev);\r\nRtdAdcConversionSource(dev, 0);\r\nRtdInterruptMask(dev, 0);\r\ndevpriv->aiCount = 0;\r\n#ifdef USE_DMA\r\nif (devpriv->flags & DMA0_ACTIVE) {\r\nRtdPlxInterruptWrite(dev,\r\nRtdPlxInterruptRead(dev) & ~ICS_DMA0_E);\r\nabort_dma(dev, 0);\r\ndevpriv->flags &= ~DMA0_ACTIVE;\r\n}\r\n#endif\r\nstatus = RtdInterruptStatus(dev);\r\nDPRINTK\r\n("rtd520: Acquisition canceled. %ld ints, intStat=%x, overStat=%x\n",\r\ndevpriv->intCount, status,\r\n0xffff & RtdInterruptOverrunStatus(dev));\r\nreturn 0;\r\n}\r\nstatic int rtd_ns_to_timer_base(unsigned int *nanosec,\r\nint round_mode, int base)\r\n{\r\nint divider;\r\nswitch (round_mode) {\r\ncase TRIG_ROUND_NEAREST:\r\ndefault:\r\ndivider = (*nanosec + base / 2) / base;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\ndivider = (*nanosec) / base;\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\ndivider = (*nanosec + base - 1) / base;\r\nbreak;\r\n}\r\nif (divider < 2)\r\ndivider = 2;\r\n*nanosec = base * divider;\r\nreturn divider - 1;\r\n}\r\nstatic int rtd_ns_to_timer(unsigned int *ns, int round_mode)\r\n{\r\nreturn rtd_ns_to_timer_base(ns, round_mode, RTD_CLOCK_BASE);\r\n}\r\nstatic int rtd_ao_winsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint i;\r\nint chan = CR_CHAN(insn->chanspec);\r\nint range = CR_RANGE(insn->chanspec);\r\nRtdDacRange(dev, chan, range);\r\nfor (i = 0; i < insn->n; ++i) {\r\nint val = data[i] << 3;\r\nint stat = 0;\r\nint ii;\r\nif ((range > 1)\r\n&& (data[i] < 2048)) {\r\nval = (((int)data[i]) - 2048) << 3;\r\n} else {\r\nval = data[i] << 3;\r\n}\r\nDPRINTK\r\n("comedi: rtd520 DAC chan=%d range=%d writing %d as 0x%x\n",\r\nchan, range, data[i], val);\r\nRtdDacFifoPut(dev, chan, val);\r\nRtdDacUpdate(dev, chan);\r\ndevpriv->aoValue[chan] = data[i];\r\nfor (ii = 0; ii < RTD_DAC_TIMEOUT; ++ii) {\r\nstat = RtdFifoStatus(dev);\r\nif (stat & ((0 == chan) ? FS_DAC1_NOT_EMPTY :\r\nFS_DAC2_NOT_EMPTY))\r\nbreak;\r\nWAIT_QUIETLY;\r\n}\r\nif (ii >= RTD_DAC_TIMEOUT) {\r\nDPRINTK\r\n("rtd520: Error: DAC never finished! FifoStatus=0x%x\n",\r\nstat ^ 0x6666);\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic int rtd_ao_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint i;\r\nint chan = CR_CHAN(insn->chanspec);\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->aoValue[chan];\r\nreturn i;\r\n}\r\nstatic int rtd_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif (insn->n != 2)\r\nreturn -EINVAL;\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= data[0] & data[1];\r\nRtdDio0Write(dev, s->state);\r\n}\r\ndata[1] = RtdDio0Read(dev);\r\nreturn 2;\r\n}\r\nstatic int rtd_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint chan = CR_CHAN(insn->chanspec);\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\ns->io_bits |= 1 << chan;\r\nbreak;\r\ncase INSN_CONFIG_DIO_INPUT:\r\ns->io_bits &= ~(1 << chan);\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] =\r\n(s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;\r\nreturn insn->n;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nDPRINTK("rtd520: port_0_direction=0x%x (1 means out)\n", s->io_bits);\r\nRtdDioStatusWrite(dev, 0x01);\r\nRtdDio0CtrlWrite(dev, s->io_bits);\r\nRtdDioStatusWrite(dev, 0);\r\nreturn 1;\r\n}\r\nstatic int __devinit rtd520Driver_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, rtd520Driver.driver_name);\r\n}\r\nstatic void __devexit rtd520Driver_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init rtd520Driver_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&rtd520Driver);\r\nif (retval < 0)\r\nreturn retval;\r\nrtd520Driver_pci_driver.name = (char *)rtd520Driver.driver_name;\r\nreturn pci_register_driver(&rtd520Driver_pci_driver);\r\n}\r\nstatic void __exit rtd520Driver_cleanup_module(void)\r\n{\r\npci_unregister_driver(&rtd520Driver_pci_driver);\r\ncomedi_driver_unregister(&rtd520Driver);\r\n}
