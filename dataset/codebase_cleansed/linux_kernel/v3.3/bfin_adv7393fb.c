static int dma_desc_list(struct adv7393fb_device *fbdev, u16 arg)\r\n{\r\nif (arg == BUILD) {\r\nfbdev->vb1 = l1_data_sram_zalloc(sizeof(struct dmasg));\r\nif (fbdev->vb1 == NULL)\r\ngoto error;\r\nfbdev->av1 = l1_data_sram_zalloc(sizeof(struct dmasg));\r\nif (fbdev->av1 == NULL)\r\ngoto error;\r\nfbdev->vb2 = l1_data_sram_zalloc(sizeof(struct dmasg));\r\nif (fbdev->vb2 == NULL)\r\ngoto error;\r\nfbdev->av2 = l1_data_sram_zalloc(sizeof(struct dmasg));\r\nif (fbdev->av2 == NULL)\r\ngoto error;\r\nfbdev->vb1->next_desc_addr = fbdev->av1;\r\nfbdev->av1->next_desc_addr = fbdev->vb2;\r\nfbdev->vb2->next_desc_addr = fbdev->av2;\r\nfbdev->av2->next_desc_addr = fbdev->vb1;\r\nfbdev->descriptor_list_head = fbdev->av2;\r\nfbdev->vb1->start_addr = VB_DUMMY_MEMORY_SOURCE;\r\nfbdev->vb1->cfg = DMA_CFG_VAL;\r\nfbdev->vb1->x_count =\r\nfbdev->modes[mode].xres + fbdev->modes[mode].boeft_blank;\r\nfbdev->vb1->x_modify = 0;\r\nfbdev->vb1->y_count = fbdev->modes[mode].vb1_lines;\r\nfbdev->vb1->y_modify = 0;\r\nfbdev->av1->start_addr = (unsigned long)fbdev->fb_mem;\r\nfbdev->av1->cfg = DMA_CFG_VAL;\r\nfbdev->av1->x_count =\r\nfbdev->modes[mode].xres + fbdev->modes[mode].boeft_blank;\r\nfbdev->av1->x_modify = fbdev->modes[mode].bpp / 8;\r\nfbdev->av1->y_count = fbdev->modes[mode].a_lines;\r\nfbdev->av1->y_modify =\r\n(fbdev->modes[mode].xres - fbdev->modes[mode].boeft_blank +\r\n1) * (fbdev->modes[mode].bpp / 8);\r\nfbdev->vb2->start_addr = VB_DUMMY_MEMORY_SOURCE;\r\nfbdev->vb2->cfg = DMA_CFG_VAL;\r\nfbdev->vb2->x_count =\r\nfbdev->modes[mode].xres + fbdev->modes[mode].boeft_blank;\r\nfbdev->vb2->x_modify = 0;\r\nfbdev->vb2->y_count = fbdev->modes[mode].vb2_lines;\r\nfbdev->vb2->y_modify = 0;\r\nfbdev->av2->start_addr =\r\n(unsigned long)fbdev->fb_mem + fbdev->line_len;\r\nfbdev->av2->cfg = DMA_CFG_VAL;\r\nfbdev->av2->x_count =\r\nfbdev->modes[mode].xres + fbdev->modes[mode].boeft_blank;\r\nfbdev->av2->x_modify = (fbdev->modes[mode].bpp / 8);\r\nfbdev->av2->y_count = fbdev->modes[mode].a_lines;\r\nfbdev->av2->y_modify =\r\n(fbdev->modes[mode].xres - fbdev->modes[mode].boeft_blank +\r\n1) * (fbdev->modes[mode].bpp / 8);\r\nreturn 1;\r\n}\r\nerror:\r\nl1_data_sram_free(fbdev->vb1);\r\nl1_data_sram_free(fbdev->av1);\r\nl1_data_sram_free(fbdev->vb2);\r\nl1_data_sram_free(fbdev->av2);\r\nreturn 0;\r\n}\r\nstatic int bfin_config_dma(struct adv7393fb_device *fbdev)\r\n{\r\nBUG_ON(!(fbdev->fb_mem));\r\nset_dma_x_count(CH_PPI, fbdev->descriptor_list_head->x_count);\r\nset_dma_x_modify(CH_PPI, fbdev->descriptor_list_head->x_modify);\r\nset_dma_y_count(CH_PPI, fbdev->descriptor_list_head->y_count);\r\nset_dma_y_modify(CH_PPI, fbdev->descriptor_list_head->y_modify);\r\nset_dma_start_addr(CH_PPI, fbdev->descriptor_list_head->start_addr);\r\nset_dma_next_desc_addr(CH_PPI,\r\nfbdev->descriptor_list_head->next_desc_addr);\r\nset_dma_config(CH_PPI, fbdev->descriptor_list_head->cfg);\r\nreturn 1;\r\n}\r\nstatic void bfin_disable_dma(void)\r\n{\r\nbfin_write_DMA0_CONFIG(bfin_read_DMA0_CONFIG() & ~DMAEN);\r\n}\r\nstatic void bfin_config_ppi(struct adv7393fb_device *fbdev)\r\n{\r\nif (ANOMALY_05000183) {\r\nbfin_write_TIMER2_CONFIG(WDTH_CAP);\r\nbfin_write_TIMER_ENABLE(TIMEN2);\r\n}\r\nbfin_write_PPI_CONTROL(0x381E);\r\nbfin_write_PPI_FRAME(fbdev->modes[mode].tot_lines);\r\nbfin_write_PPI_COUNT(fbdev->modes[mode].xres +\r\nfbdev->modes[mode].boeft_blank - 1);\r\nbfin_write_PPI_DELAY(fbdev->modes[mode].aoeft_blank - 1);\r\n}\r\nstatic void bfin_enable_ppi(void)\r\n{\r\nbfin_write_PPI_CONTROL(bfin_read_PPI_CONTROL() | PORT_EN);\r\n}\r\nstatic void bfin_disable_ppi(void)\r\n{\r\nbfin_write_PPI_CONTROL(bfin_read_PPI_CONTROL() & ~PORT_EN);\r\n}\r\nstatic inline int adv7393_write(struct i2c_client *client, u8 reg, u8 value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic inline int adv7393_read(struct i2c_client *client, u8 reg)\r\n{\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int\r\nadv7393_write_block(struct i2c_client *client,\r\nconst u8 *data, unsigned int len)\r\n{\r\nint ret = -1;\r\nu8 reg;\r\nwhile (len >= 2) {\r\nreg = *data++;\r\nret = adv7393_write(client, reg, *data++);\r\nif (ret < 0)\r\nbreak;\r\nlen -= 2;\r\n}\r\nreturn ret;\r\n}\r\nstatic int adv7393_mode(struct i2c_client *client, u16 mode)\r\n{\r\nswitch (mode) {\r\ncase POWER_ON:\r\nadv7393_write(client, 0x00, 0x1E);\r\nbreak;\r\ncase POWER_DOWN:\r\nadv7393_write(client, 0x00, 0x1F);\r\nbreak;\r\ncase BLANK_OFF:\r\nadv7393_write(client, 0x82, 0xCB);\r\nbreak;\r\ncase BLANK_ON:\r\nadv7393_write(client, 0x82, 0x8B);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ppi_irq_error(int irq, void *dev_id)\r\n{\r\nstruct adv7393fb_device *fbdev = (struct adv7393fb_device *)dev_id;\r\nu16 status = bfin_read_PPI_STATUS();\r\npr_debug("%s: PPI Status = 0x%X\n", __func__, status);\r\nif (status) {\r\nbfin_disable_dma();\r\nbfin_disable_ppi();\r\nbfin_clear_PPI_STATUS();\r\nbfin_config_dma(fbdev);\r\nbfin_enable_ppi();\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int proc_output(char *buf)\r\n{\r\nchar *p = buf;\r\np += sprintf(p,\r\n"Usage:\n"\r\n"echo 0x[REG][Value] > adv7393\n"\r\n"example: echo 0x1234 >adv7393\n"\r\n"writes 0x34 into Register 0x12\n");\r\nreturn p - buf;\r\n}\r\nstatic int\r\nadv7393_read_proc(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nint len;\r\nlen = proc_output(page);\r\nif (len <= off + count)\r\n*eof = 1;\r\n*start = page + off;\r\nlen -= off;\r\nif (len > count)\r\nlen = count;\r\nif (len < 0)\r\nlen = 0;\r\nreturn len;\r\n}\r\nstatic int\r\nadv7393_write_proc(struct file *file, const char __user * buffer,\r\nunsigned long count, void *data)\r\n{\r\nstruct adv7393fb_device *fbdev = data;\r\nchar line[8];\r\nunsigned int val;\r\nint ret;\r\nret = copy_from_user(line, buffer, count);\r\nif (ret)\r\nreturn -EFAULT;\r\nval = simple_strtoul(line, NULL, 0);\r\nadv7393_write(fbdev->client, val >> 8, val & 0xff);\r\nreturn count;\r\n}\r\nstatic int __devinit bfin_adv7393_fb_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret = 0;\r\nstruct proc_dir_entry *entry;\r\nint num_modes = ARRAY_SIZE(known_modes);\r\nstruct adv7393fb_device *fbdev = NULL;\r\nif (mem > 2) {\r\ndev_err(&client->dev, "mem out of allowed range [1;2]\n");\r\nreturn -EINVAL;\r\n}\r\nif (mode > num_modes) {\r\ndev_err(&client->dev, "mode %d: not supported", mode);\r\nreturn -EFAULT;\r\n}\r\nfbdev = kzalloc(sizeof(*fbdev), GFP_KERNEL);\r\nif (!fbdev) {\r\ndev_err(&client->dev, "failed to allocate device private record");\r\nreturn -ENOMEM;\r\n}\r\ni2c_set_clientdata(client, fbdev);\r\nfbdev->modes = known_modes;\r\nfbdev->client = client;\r\nfbdev->fb_len =\r\nmem * fbdev->modes[mode].xres * fbdev->modes[mode].xres *\r\n(fbdev->modes[mode].bpp / 8);\r\nfbdev->line_len =\r\nfbdev->modes[mode].xres * (fbdev->modes[mode].bpp / 8);\r\nif (ANOMALY_05000400) {\r\nif (gpio_request(P_IDENT(P_PPI0_FS3), "PPI0_FS3")) {\r\ndev_err(&client->dev, "PPI0_FS3 GPIO request failed\n");\r\nret = -EBUSY;\r\ngoto out_8;\r\n}\r\ngpio_direction_output(P_IDENT(P_PPI0_FS3), 0);\r\n}\r\nif (peripheral_request_list(ppi_pins, DRIVER_NAME)) {\r\ndev_err(&client->dev, "requesting PPI peripheral failed\n");\r\nret = -EFAULT;\r\ngoto out_8;\r\n}\r\nfbdev->fb_mem =\r\ndma_alloc_coherent(NULL, fbdev->fb_len, &fbdev->dma_handle,\r\nGFP_KERNEL);\r\nif (NULL == fbdev->fb_mem) {\r\ndev_err(&client->dev, "couldn't allocate dma buffer (%d bytes)\n",\r\n(u32) fbdev->fb_len);\r\nret = -ENOMEM;\r\ngoto out_7;\r\n}\r\nfbdev->info.screen_base = (void *)fbdev->fb_mem;\r\nbfin_adv7393_fb_fix.smem_start = (int)fbdev->fb_mem;\r\nbfin_adv7393_fb_fix.smem_len = fbdev->fb_len;\r\nbfin_adv7393_fb_fix.line_length = fbdev->line_len;\r\nif (mem > 1)\r\nbfin_adv7393_fb_fix.ypanstep = 1;\r\nbfin_adv7393_fb_defined.red.length = 5;\r\nbfin_adv7393_fb_defined.green.length = 6;\r\nbfin_adv7393_fb_defined.blue.length = 5;\r\nbfin_adv7393_fb_defined.xres = fbdev->modes[mode].xres;\r\nbfin_adv7393_fb_defined.yres = fbdev->modes[mode].yres;\r\nbfin_adv7393_fb_defined.xres_virtual = fbdev->modes[mode].xres;\r\nbfin_adv7393_fb_defined.yres_virtual = mem * fbdev->modes[mode].yres;\r\nbfin_adv7393_fb_defined.bits_per_pixel = fbdev->modes[mode].bpp;\r\nfbdev->info.fbops = &bfin_adv7393_fb_ops;\r\nfbdev->info.var = bfin_adv7393_fb_defined;\r\nfbdev->info.fix = bfin_adv7393_fb_fix;\r\nfbdev->info.par = &bfin_par;\r\nfbdev->info.flags = FBINFO_DEFAULT;\r\nfbdev->info.pseudo_palette = kzalloc(sizeof(u32) * 16, GFP_KERNEL);\r\nif (!fbdev->info.pseudo_palette) {\r\ndev_err(&client->dev, "failed to allocate pseudo_palette\n");\r\nret = -ENOMEM;\r\ngoto out_6;\r\n}\r\nif (fb_alloc_cmap(&fbdev->info.cmap, BFIN_LCD_NBR_PALETTE_ENTRIES, 0) < 0) {\r\ndev_err(&client->dev, "failed to allocate colormap (%d entries)\n",\r\nBFIN_LCD_NBR_PALETTE_ENTRIES);\r\nret = -EFAULT;\r\ngoto out_5;\r\n}\r\nif (request_dma(CH_PPI, "BF5xx_PPI_DMA") < 0) {\r\ndev_err(&client->dev, "unable to request PPI DMA\n");\r\nret = -EFAULT;\r\ngoto out_4;\r\n}\r\nif (request_irq(IRQ_PPI_ERROR, ppi_irq_error, 0,\r\n"PPI ERROR", fbdev) < 0) {\r\ndev_err(&client->dev, "unable to request PPI ERROR IRQ\n");\r\nret = -EFAULT;\r\ngoto out_3;\r\n}\r\nfbdev->open = 0;\r\nret = adv7393_write_block(client, fbdev->modes[mode].adv7393_i2c_initd,\r\nfbdev->modes[mode].adv7393_i2c_initd_len);\r\nif (ret) {\r\ndev_err(&client->dev, "i2c attach: init error\n");\r\ngoto out_1;\r\n}\r\nif (register_framebuffer(&fbdev->info) < 0) {\r\ndev_err(&client->dev, "unable to register framebuffer\n");\r\nret = -EFAULT;\r\ngoto out_1;\r\n}\r\ndev_info(&client->dev, "fb%d: %s frame buffer device\n",\r\nfbdev->info.node, fbdev->info.fix.id);\r\ndev_info(&client->dev, "fb memory address : 0x%p\n", fbdev->fb_mem);\r\nentry = create_proc_entry("driver/adv7393", 0, NULL);\r\nif (!entry) {\r\ndev_err(&client->dev, "unable to create /proc entry\n");\r\nret = -EFAULT;\r\ngoto out_0;\r\n}\r\nentry->read_proc = adv7393_read_proc;\r\nentry->write_proc = adv7393_write_proc;\r\nentry->data = fbdev;\r\nreturn 0;\r\nout_0:\r\nunregister_framebuffer(&fbdev->info);\r\nout_1:\r\nfree_irq(IRQ_PPI_ERROR, fbdev);\r\nout_3:\r\nfree_dma(CH_PPI);\r\nout_4:\r\ndma_free_coherent(NULL, fbdev->fb_len, fbdev->fb_mem,\r\nfbdev->dma_handle);\r\nout_5:\r\nfb_dealloc_cmap(&fbdev->info.cmap);\r\nout_6:\r\nkfree(fbdev->info.pseudo_palette);\r\nout_7:\r\nperipheral_free_list(ppi_pins);\r\nout_8:\r\nkfree(fbdev);\r\nreturn ret;\r\n}\r\nstatic int bfin_adv7393_fb_open(struct fb_info *info, int user)\r\n{\r\nstruct adv7393fb_device *fbdev = to_adv7393fb_device(info);\r\nfbdev->info.screen_base = (void *)fbdev->fb_mem;\r\nif (!fbdev->info.screen_base) {\r\ndev_err(&fbdev->client->dev, "unable to map device\n");\r\nreturn -ENOMEM;\r\n}\r\nfbdev->open = 1;\r\ndma_desc_list(fbdev, BUILD);\r\nadv7393_mode(fbdev->client, BLANK_OFF);\r\nbfin_config_ppi(fbdev);\r\nbfin_config_dma(fbdev);\r\nbfin_enable_ppi();\r\nreturn 0;\r\n}\r\nstatic int bfin_adv7393_fb_release(struct fb_info *info, int user)\r\n{\r\nstruct adv7393fb_device *fbdev = to_adv7393fb_device(info);\r\nadv7393_mode(fbdev->client, BLANK_ON);\r\nbfin_disable_dma();\r\nbfin_disable_ppi();\r\ndma_desc_list(fbdev, DESTRUCT);\r\nfbdev->open = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nbfin_adv7393_fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nswitch (var->bits_per_pixel) {\r\ncase 16:\r\nvar->red.offset = info->var.red.offset;\r\nvar->green.offset = info->var.green.offset;\r\nvar->blue.offset = info->var.blue.offset;\r\nvar->red.length = info->var.red.length;\r\nvar->green.length = info->var.green.length;\r\nvar->blue.length = info->var.blue.length;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->transp.msb_right = 0;\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nbreak;\r\ndefault:\r\npr_debug("%s: depth not supported: %u BPP\n", __func__,\r\nvar->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nif (info->var.xres != var->xres ||\r\ninfo->var.yres != var->yres ||\r\ninfo->var.xres_virtual != var->xres_virtual ||\r\ninfo->var.yres_virtual != var->yres_virtual) {\r\npr_debug("%s: Resolution not supported: X%u x Y%u\n",\r\n__func__, var->xres, var->yres);\r\nreturn -EINVAL;\r\n}\r\nif ((info->fix.line_length * var->yres_virtual) > info->fix.smem_len) {\r\npr_debug("%s: Memory Limit requested yres_virtual = %u\n",\r\n__func__, var->yres_virtual);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbfin_adv7393_fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nint dy;\r\nu32 dmaaddr;\r\nstruct adv7393fb_device *fbdev = to_adv7393fb_device(info);\r\nif (!var || !info)\r\nreturn -EINVAL;\r\nif (var->xoffset - info->var.xoffset) {\r\nreturn -EINVAL;\r\n}\r\ndy = var->yoffset - info->var.yoffset;\r\nif (dy) {\r\npr_debug("%s: Panning screen of %d lines\n", __func__, dy);\r\ndmaaddr = fbdev->av1->start_addr;\r\ndmaaddr += (info->fix.line_length * dy);\r\nfbdev->av1->start_addr = (unsigned long)dmaaddr;\r\nfbdev->av2->start_addr = (unsigned long)dmaaddr + fbdev->line_len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bfin_adv7393_fb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct adv7393fb_device *fbdev = to_adv7393fb_device(info);\r\nswitch (blank) {\r\ncase VESA_NO_BLANKING:\r\nadv7393_mode(fbdev->client, BLANK_OFF);\r\nbreak;\r\ncase VESA_VSYNC_SUSPEND:\r\ncase VESA_HSYNC_SUSPEND:\r\ncase VESA_POWERDOWN:\r\nadv7393_mode(fbdev->client, BLANK_ON);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint bfin_adv7393_fb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nif (nocursor)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int bfin_adv7393_fb_setcolreg(u_int regno, u_int red, u_int green,\r\nu_int blue, u_int transp,\r\nstruct fb_info *info)\r\n{\r\nif (regno >= BFIN_LCD_NBR_PALETTE_ENTRIES)\r\nreturn -EINVAL;\r\nif (info->var.grayscale)\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nu32 value;\r\nif (regno > 16)\r\nreturn -EINVAL;\r\nred >>= (16 - info->var.red.length);\r\ngreen >>= (16 - info->var.green.length);\r\nblue >>= (16 - info->var.blue.length);\r\nvalue = (red << info->var.red.offset) |\r\n(green << info->var.green.offset)|\r\n(blue << info->var.blue.offset);\r\nvalue &= 0xFFFF;\r\n((u32 *) (info->pseudo_palette))[regno] = value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devexit bfin_adv7393_fb_remove(struct i2c_client *client)\r\n{\r\nstruct adv7393fb_device *fbdev = i2c_get_clientdata(client);\r\nadv7393_mode(client, POWER_DOWN);\r\nif (fbdev->fb_mem)\r\ndma_free_coherent(NULL, fbdev->fb_len, fbdev->fb_mem, fbdev->dma_handle);\r\nfree_dma(CH_PPI);\r\nfree_irq(IRQ_PPI_ERROR, fbdev);\r\nunregister_framebuffer(&fbdev->info);\r\nremove_proc_entry("driver/adv7393", NULL);\r\nfb_dealloc_cmap(&fbdev->info.cmap);\r\nkfree(fbdev->info.pseudo_palette);\r\nif (ANOMALY_05000400)\r\ngpio_free(P_IDENT(P_PPI0_FS3));\r\nperipheral_free_list(ppi_pins);\r\nkfree(fbdev);\r\nreturn 0;\r\n}\r\nstatic int bfin_adv7393_fb_suspend(struct device *dev)\r\n{\r\nstruct adv7393fb_device *fbdev = dev_get_drvdata(dev);\r\nif (fbdev->open) {\r\nbfin_disable_dma();\r\nbfin_disable_ppi();\r\ndma_desc_list(fbdev, DESTRUCT);\r\n}\r\nadv7393_mode(fbdev->client, POWER_DOWN);\r\nreturn 0;\r\n}\r\nstatic int bfin_adv7393_fb_resume(struct device *dev)\r\n{\r\nstruct adv7393fb_device *fbdev = dev_get_drvdata(dev);\r\nadv7393_mode(fbdev->client, POWER_ON);\r\nif (fbdev->open) {\r\ndma_desc_list(fbdev, BUILD);\r\nbfin_config_ppi(fbdev);\r\nbfin_config_dma(fbdev);\r\nbfin_enable_ppi();\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init bfin_adv7393_fb_driver_init(void)\r\n{\r\n#if defined(CONFIG_I2C_BLACKFIN_TWI) || defined(CONFIG_I2C_BLACKFIN_TWI_MODULE)\r\nrequest_module("i2c-bfin-twi");\r\n#else\r\nrequest_module("i2c-gpio");\r\n#endif\r\nreturn i2c_add_driver(&bfin_adv7393_fb_driver);\r\n}\r\nstatic void __exit bfin_adv7393_fb_driver_cleanup(void)\r\n{\r\ni2c_del_driver(&bfin_adv7393_fb_driver);\r\n}
