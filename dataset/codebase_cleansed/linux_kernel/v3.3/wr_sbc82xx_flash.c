static int __init init_sbc82xx_flash(void)\r\n{\r\nvolatile memctl_cpm2_t *mc = &cpm2_immr->im_memctl;\r\nint bigflash;\r\nint i;\r\n#ifdef CONFIG_SBC8560\r\nmc = ioremap(0xff700000 + 0x5000, sizeof(memctl_cpm2_t));\r\n#else\r\nmc = &cpm2_immr->im_memctl;\r\n#endif\r\nbigflash = 1;\r\nif ((mc->memc_br0 & 0x00001800) == 0x00001800)\r\nbigflash = 0;\r\ninit_sbc82xx_one_flash(sbc82xx_flash_map[0], mc->memc_br0, mc->memc_or0);\r\ninit_sbc82xx_one_flash(sbc82xx_flash_map[1], mc->memc_br6, mc->memc_or6);\r\ninit_sbc82xx_one_flash(sbc82xx_flash_map[2], mc->memc_br1, mc->memc_or1);\r\n#ifdef CONFIG_SBC8560\r\niounmap((void *) mc);\r\n#endif\r\nfor (i=0; i<3; i++) {\r\nint8_t flashcs[3] = { 0, 6, 1 };\r\nint nr_parts;\r\nstruct mtd_partition *defparts;\r\nprintk(KERN_NOTICE "PowerQUICC II %s (%ld MiB on CS%d",\r\nsbc82xx_flash_map[i].name,\r\n(sbc82xx_flash_map[i].size >> 20),\r\nflashcs[i]);\r\nif (!sbc82xx_flash_map[i].phys) {\r\nprintk("): disabled by bootloader.\n");\r\ncontinue;\r\n}\r\nprintk(" at %08lx)\n", sbc82xx_flash_map[i].phys);\r\nsbc82xx_flash_map[i].virt = ioremap(sbc82xx_flash_map[i].phys,\r\nsbc82xx_flash_map[i].size);\r\nif (!sbc82xx_flash_map[i].virt) {\r\nprintk("Failed to ioremap\n");\r\ncontinue;\r\n}\r\nsimple_map_init(&sbc82xx_flash_map[i]);\r\nsbcmtd[i] = do_map_probe("cfi_probe", &sbc82xx_flash_map[i]);\r\nif (!sbcmtd[i])\r\ncontinue;\r\nsbcmtd[i]->owner = THIS_MODULE;\r\nif (i == 2) {\r\ndefparts = NULL;\r\nnr_parts = 0;\r\n} else if (i == bigflash) {\r\ndefparts = bigflash_parts;\r\nnr_parts = ARRAY_SIZE(bigflash_parts);\r\n} else {\r\ndefparts = smallflash_parts;\r\nnr_parts = ARRAY_SIZE(smallflash_parts);\r\n}\r\nmtd_device_parse_register(sbcmtd[i], part_probes, 0,\r\ndefparts, nr_parts);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_sbc82xx_flash(void)\r\n{\r\nint i;\r\nfor (i=0; i<3; i++) {\r\nif (!sbcmtd[i])\r\ncontinue;\r\nmtd_device_unregister(sbcmtd[i]);\r\nmap_destroy(sbcmtd[i]);\r\niounmap((void *)sbc82xx_flash_map[i].virt);\r\nsbc82xx_flash_map[i].virt = 0;\r\n}\r\n}
