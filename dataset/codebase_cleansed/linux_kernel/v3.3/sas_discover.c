void sas_init_dev(struct domain_device *dev)\r\n{\r\nINIT_LIST_HEAD(&dev->siblings);\r\nINIT_LIST_HEAD(&dev->dev_list_node);\r\nswitch (dev->dev_type) {\r\ncase SAS_END_DEV:\r\nbreak;\r\ncase EDGE_DEV:\r\ncase FANOUT_DEV:\r\nINIT_LIST_HEAD(&dev->ex_dev.children);\r\nbreak;\r\ncase SATA_DEV:\r\ncase SATA_PM:\r\ncase SATA_PM_PORT:\r\nINIT_LIST_HEAD(&dev->sata_dev.children);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int sas_get_port_device(struct asd_sas_port *port)\r\n{\r\nunsigned long flags;\r\nstruct asd_sas_phy *phy;\r\nstruct sas_rphy *rphy;\r\nstruct domain_device *dev;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&port->phy_list_lock, flags);\r\nif (list_empty(&port->phy_list)) {\r\nspin_unlock_irqrestore(&port->phy_list_lock, flags);\r\nkfree(dev);\r\nreturn -ENODEV;\r\n}\r\nphy = container_of(port->phy_list.next, struct asd_sas_phy, port_phy_el);\r\nspin_lock(&phy->frame_rcvd_lock);\r\nmemcpy(dev->frame_rcvd, phy->frame_rcvd, min(sizeof(dev->frame_rcvd),\r\n(size_t)phy->frame_rcvd_size));\r\nspin_unlock(&phy->frame_rcvd_lock);\r\nspin_unlock_irqrestore(&port->phy_list_lock, flags);\r\nif (dev->frame_rcvd[0] == 0x34 && port->oob_mode == SATA_OOB_MODE) {\r\nstruct dev_to_host_fis *fis =\r\n(struct dev_to_host_fis *) dev->frame_rcvd;\r\nif (fis->interrupt_reason == 1 && fis->lbal == 1 &&\r\nfis->byte_count_low==0x69 && fis->byte_count_high == 0x96\r\n&& (fis->device & ~0x10) == 0)\r\ndev->dev_type = SATA_PM;\r\nelse\r\ndev->dev_type = SATA_DEV;\r\ndev->tproto = SAS_PROTOCOL_SATA;\r\n} else {\r\nstruct sas_identify_frame *id =\r\n(struct sas_identify_frame *) dev->frame_rcvd;\r\ndev->dev_type = id->dev_type;\r\ndev->iproto = id->initiator_bits;\r\ndev->tproto = id->target_bits;\r\n}\r\nsas_init_dev(dev);\r\nswitch (dev->dev_type) {\r\ncase SAS_END_DEV:\r\ncase SATA_DEV:\r\nrphy = sas_end_device_alloc(port->port);\r\nbreak;\r\ncase EDGE_DEV:\r\nrphy = sas_expander_alloc(port->port,\r\nSAS_EDGE_EXPANDER_DEVICE);\r\nbreak;\r\ncase FANOUT_DEV:\r\nrphy = sas_expander_alloc(port->port,\r\nSAS_FANOUT_EXPANDER_DEVICE);\r\nbreak;\r\ndefault:\r\nprintk("ERROR: Unidentified device type %d\n", dev->dev_type);\r\nrphy = NULL;\r\nbreak;\r\n}\r\nif (!rphy) {\r\nkfree(dev);\r\nreturn -ENODEV;\r\n}\r\nrphy->identify.phy_identifier = phy->phy->identify.phy_identifier;\r\nmemcpy(dev->sas_addr, port->attached_sas_addr, SAS_ADDR_SIZE);\r\nsas_fill_in_rphy(dev, rphy);\r\nsas_hash_addr(dev->hashed_sas_addr, dev->sas_addr);\r\nport->port_dev = dev;\r\ndev->port = port;\r\ndev->linkrate = port->linkrate;\r\ndev->min_linkrate = port->linkrate;\r\ndev->max_linkrate = port->linkrate;\r\ndev->pathways = port->num_phys;\r\nmemset(port->disc.fanout_sas_addr, 0, SAS_ADDR_SIZE);\r\nmemset(port->disc.eeds_a, 0, SAS_ADDR_SIZE);\r\nmemset(port->disc.eeds_b, 0, SAS_ADDR_SIZE);\r\nport->disc.max_level = 0;\r\ndev->rphy = rphy;\r\nspin_lock_irq(&port->dev_list_lock);\r\nlist_add_tail(&dev->dev_list_node, &port->dev_list);\r\nspin_unlock_irq(&port->dev_list_lock);\r\nreturn 0;\r\n}\r\nint sas_notify_lldd_dev_found(struct domain_device *dev)\r\n{\r\nint res = 0;\r\nstruct sas_ha_struct *sas_ha = dev->port->ha;\r\nstruct Scsi_Host *shost = sas_ha->core.shost;\r\nstruct sas_internal *i = to_sas_internal(shost->transportt);\r\nif (i->dft->lldd_dev_found) {\r\nres = i->dft->lldd_dev_found(dev);\r\nif (res) {\r\nprintk("sas: driver on pcidev %s cannot handle "\r\n"device %llx, error:%d\n",\r\ndev_name(sas_ha->dev),\r\nSAS_ADDR(dev->sas_addr), res);\r\n}\r\n}\r\nreturn res;\r\n}\r\nvoid sas_notify_lldd_dev_gone(struct domain_device *dev)\r\n{\r\nstruct sas_ha_struct *sas_ha = dev->port->ha;\r\nstruct Scsi_Host *shost = sas_ha->core.shost;\r\nstruct sas_internal *i = to_sas_internal(shost->transportt);\r\nif (i->dft->lldd_dev_gone)\r\ni->dft->lldd_dev_gone(dev);\r\n}\r\nint sas_discover_end_dev(struct domain_device *dev)\r\n{\r\nint res;\r\nres = sas_notify_lldd_dev_found(dev);\r\nif (res)\r\ngoto out_err2;\r\nres = sas_rphy_add(dev->rphy);\r\nif (res)\r\ngoto out_err;\r\nreturn 0;\r\nout_err:\r\nsas_notify_lldd_dev_gone(dev);\r\nout_err2:\r\nreturn res;\r\n}\r\nstatic void sas_unregister_common_dev(struct asd_sas_port *port, struct domain_device *dev)\r\n{\r\nsas_notify_lldd_dev_gone(dev);\r\nif (!dev->parent)\r\ndev->port->port_dev = NULL;\r\nelse\r\nlist_del_init(&dev->siblings);\r\nspin_lock_irq(&port->dev_list_lock);\r\nlist_del_init(&dev->dev_list_node);\r\nspin_unlock_irq(&port->dev_list_lock);\r\n}\r\nvoid sas_unregister_dev(struct asd_sas_port *port, struct domain_device *dev)\r\n{\r\nif (dev->rphy) {\r\nsas_remove_children(&dev->rphy->dev);\r\nsas_rphy_delete(dev->rphy);\r\ndev->rphy = NULL;\r\n}\r\nif (dev->dev_type == EDGE_DEV || dev->dev_type == FANOUT_DEV) {\r\nkfree(dev->ex_dev.ex_phy);\r\ndev->ex_dev.ex_phy = NULL;\r\n}\r\nsas_unregister_common_dev(port, dev);\r\n}\r\nvoid sas_unregister_domain_devices(struct asd_sas_port *port)\r\n{\r\nstruct domain_device *dev, *n;\r\nlist_for_each_entry_safe_reverse(dev, n, &port->dev_list, dev_list_node)\r\nsas_unregister_dev(port, dev);\r\nport->port->rphy = NULL;\r\n}\r\nstatic void sas_discover_domain(struct work_struct *work)\r\n{\r\nstruct domain_device *dev;\r\nint error = 0;\r\nstruct sas_discovery_event *ev =\r\ncontainer_of(work, struct sas_discovery_event, work);\r\nstruct asd_sas_port *port = ev->port;\r\nsas_begin_event(DISCE_DISCOVER_DOMAIN, &port->disc.disc_event_lock,\r\n&port->disc.pending);\r\nif (port->port_dev)\r\nreturn;\r\nerror = sas_get_port_device(port);\r\nif (error)\r\nreturn;\r\ndev = port->port_dev;\r\nSAS_DPRINTK("DOING DISCOVERY on port %d, pid:%d\n", port->id,\r\ntask_pid_nr(current));\r\nswitch (dev->dev_type) {\r\ncase SAS_END_DEV:\r\nerror = sas_discover_end_dev(dev);\r\nbreak;\r\ncase EDGE_DEV:\r\ncase FANOUT_DEV:\r\nerror = sas_discover_root_expander(dev);\r\nbreak;\r\ncase SATA_DEV:\r\ncase SATA_PM:\r\n#ifdef CONFIG_SCSI_SAS_ATA\r\nerror = sas_discover_sata(dev);\r\nbreak;\r\n#else\r\nSAS_DPRINTK("ATA device seen but CONFIG_SCSI_SAS_ATA=N so cannot attach\n");\r\n#endif\r\ndefault:\r\nerror = -ENXIO;\r\nSAS_DPRINTK("unhandled device %d\n", dev->dev_type);\r\nbreak;\r\n}\r\nif (error) {\r\nsas_rphy_free(dev->rphy);\r\ndev->rphy = NULL;\r\nspin_lock_irq(&port->dev_list_lock);\r\nlist_del_init(&dev->dev_list_node);\r\nspin_unlock_irq(&port->dev_list_lock);\r\nkfree(dev);\r\nport->port_dev = NULL;\r\n}\r\nSAS_DPRINTK("DONE DISCOVERY on port %d, pid:%d, result:%d\n", port->id,\r\ntask_pid_nr(current), error);\r\n}\r\nstatic void sas_revalidate_domain(struct work_struct *work)\r\n{\r\nint res = 0;\r\nstruct sas_discovery_event *ev =\r\ncontainer_of(work, struct sas_discovery_event, work);\r\nstruct asd_sas_port *port = ev->port;\r\nsas_begin_event(DISCE_REVALIDATE_DOMAIN, &port->disc.disc_event_lock,\r\n&port->disc.pending);\r\nSAS_DPRINTK("REVALIDATING DOMAIN on port %d, pid:%d\n", port->id,\r\ntask_pid_nr(current));\r\nif (port->port_dev)\r\nres = sas_ex_revalidate_domain(port->port_dev);\r\nSAS_DPRINTK("done REVALIDATING DOMAIN on port %d, pid:%d, res 0x%x\n",\r\nport->id, task_pid_nr(current), res);\r\n}\r\nint sas_discover_event(struct asd_sas_port *port, enum discover_event ev)\r\n{\r\nstruct sas_discovery *disc;\r\nif (!port)\r\nreturn 0;\r\ndisc = &port->disc;\r\nBUG_ON(ev >= DISC_NUM_EVENTS);\r\nsas_queue_event(ev, &disc->disc_event_lock, &disc->pending,\r\n&disc->disc_work[ev].work, port->ha);\r\nreturn 0;\r\n}\r\nvoid sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\r\n{\r\nint i;\r\nstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\r\n[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\r\n[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\r\n};\r\nspin_lock_init(&disc->disc_event_lock);\r\ndisc->pending = 0;\r\nfor (i = 0; i < DISC_NUM_EVENTS; i++) {\r\nINIT_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\r\ndisc->disc_work[i].port = port;\r\n}\r\n}
