static unsigned ehci_read_frame_index(struct ehci_hcd *ehci)\r\n{\r\nunsigned uf;\r\nuf = ehci_readl(ehci, &ehci->regs->frame_index);\r\nif (unlikely(ehci->frame_index_bug && ((uf & 7) == 0)))\r\nuf = ehci_readl(ehci, &ehci->regs->frame_index);\r\nreturn uf;\r\n}\r\nstatic union ehci_shadow *\r\nperiodic_next_shadow(struct ehci_hcd *ehci, union ehci_shadow *periodic,\r\n__hc32 tag)\r\n{\r\nswitch (hc32_to_cpu(ehci, tag)) {\r\ncase Q_TYPE_QH:\r\nreturn &periodic->qh->qh_next;\r\ncase Q_TYPE_FSTN:\r\nreturn &periodic->fstn->fstn_next;\r\ncase Q_TYPE_ITD:\r\nreturn &periodic->itd->itd_next;\r\ndefault:\r\nreturn &periodic->sitd->sitd_next;\r\n}\r\n}\r\nstatic __hc32 *\r\nshadow_next_periodic(struct ehci_hcd *ehci, union ehci_shadow *periodic,\r\n__hc32 tag)\r\n{\r\nswitch (hc32_to_cpu(ehci, tag)) {\r\ncase Q_TYPE_QH:\r\nreturn &periodic->qh->hw->hw_next;\r\ndefault:\r\nreturn periodic->hw_next;\r\n}\r\n}\r\nstatic void periodic_unlink (struct ehci_hcd *ehci, unsigned frame, void *ptr)\r\n{\r\nunion ehci_shadow *prev_p = &ehci->pshadow[frame];\r\n__hc32 *hw_p = &ehci->periodic[frame];\r\nunion ehci_shadow here = *prev_p;\r\nwhile (here.ptr && here.ptr != ptr) {\r\nprev_p = periodic_next_shadow(ehci, prev_p,\r\nQ_NEXT_TYPE(ehci, *hw_p));\r\nhw_p = shadow_next_periodic(ehci, &here,\r\nQ_NEXT_TYPE(ehci, *hw_p));\r\nhere = *prev_p;\r\n}\r\nif (!here.ptr)\r\nreturn;\r\n*prev_p = *periodic_next_shadow(ehci, &here,\r\nQ_NEXT_TYPE(ehci, *hw_p));\r\nif (!ehci->use_dummy_qh ||\r\n*shadow_next_periodic(ehci, &here, Q_NEXT_TYPE(ehci, *hw_p))\r\n!= EHCI_LIST_END(ehci))\r\n*hw_p = *shadow_next_periodic(ehci, &here,\r\nQ_NEXT_TYPE(ehci, *hw_p));\r\nelse\r\n*hw_p = ehci->dummy->qh_dma;\r\n}\r\nstatic unsigned short\r\nperiodic_usecs (struct ehci_hcd *ehci, unsigned frame, unsigned uframe)\r\n{\r\n__hc32 *hw_p = &ehci->periodic [frame];\r\nunion ehci_shadow *q = &ehci->pshadow [frame];\r\nunsigned usecs = 0;\r\nstruct ehci_qh_hw *hw;\r\nwhile (q->ptr) {\r\nswitch (hc32_to_cpu(ehci, Q_NEXT_TYPE(ehci, *hw_p))) {\r\ncase Q_TYPE_QH:\r\nhw = q->qh->hw;\r\nif (hw->hw_info2 & cpu_to_hc32(ehci, 1 << uframe))\r\nusecs += q->qh->usecs;\r\nif (hw->hw_info2 & cpu_to_hc32(ehci,\r\n1 << (8 + uframe)))\r\nusecs += q->qh->c_usecs;\r\nhw_p = &hw->hw_next;\r\nq = &q->qh->qh_next;\r\nbreak;\r\ndefault:\r\nif (q->fstn->hw_prev != EHCI_LIST_END(ehci)) {\r\nehci_dbg (ehci, "ignoring FSTN cost ...\n");\r\n}\r\nhw_p = &q->fstn->hw_next;\r\nq = &q->fstn->fstn_next;\r\nbreak;\r\ncase Q_TYPE_ITD:\r\nif (q->itd->hw_transaction[uframe])\r\nusecs += q->itd->stream->usecs;\r\nhw_p = &q->itd->hw_next;\r\nq = &q->itd->itd_next;\r\nbreak;\r\ncase Q_TYPE_SITD:\r\nif (q->sitd->hw_uframe & cpu_to_hc32(ehci,\r\n1 << uframe)) {\r\nif (q->sitd->hw_fullspeed_ep &\r\ncpu_to_hc32(ehci, 1<<31))\r\nusecs += q->sitd->stream->usecs;\r\nelse\r\nusecs += HS_USECS_ISO (188);\r\n}\r\nif (q->sitd->hw_uframe &\r\ncpu_to_hc32(ehci, 1 << (8 + uframe))) {\r\nusecs += q->sitd->stream->c_usecs;\r\n}\r\nhw_p = &q->sitd->hw_next;\r\nq = &q->sitd->sitd_next;\r\nbreak;\r\n}\r\n}\r\n#ifdef DEBUG\r\nif (usecs > ehci->uframe_periodic_max)\r\nehci_err (ehci, "uframe %d sched overrun: %d usecs\n",\r\nframe * 8 + uframe, usecs);\r\n#endif\r\nreturn usecs;\r\n}\r\nstatic int same_tt (struct usb_device *dev1, struct usb_device *dev2)\r\n{\r\nif (!dev1->tt || !dev2->tt)\r\nreturn 0;\r\nif (dev1->tt != dev2->tt)\r\nreturn 0;\r\nif (dev1->tt->multi)\r\nreturn dev1->ttport == dev2->ttport;\r\nelse\r\nreturn 1;\r\n}\r\nstatic inline unsigned char tt_start_uframe(struct ehci_hcd *ehci, __hc32 mask)\r\n{\r\nunsigned char smask = QH_SMASK & hc32_to_cpu(ehci, mask);\r\nif (!smask) {\r\nehci_err(ehci, "invalid empty smask!\n");\r\nreturn 7;\r\n}\r\nreturn ffs(smask) - 1;\r\n}\r\nstatic inline void carryover_tt_bandwidth(unsigned short tt_usecs[8])\r\n{\r\nint i;\r\nfor (i=0; i<7; i++) {\r\nif (max_tt_usecs[i] < tt_usecs[i]) {\r\ntt_usecs[i+1] += tt_usecs[i] - max_tt_usecs[i];\r\ntt_usecs[i] = max_tt_usecs[i];\r\n}\r\n}\r\n}\r\nstatic void\r\nperiodic_tt_usecs (\r\nstruct ehci_hcd *ehci,\r\nstruct usb_device *dev,\r\nunsigned frame,\r\nunsigned short tt_usecs[8]\r\n)\r\n{\r\n__hc32 *hw_p = &ehci->periodic [frame];\r\nunion ehci_shadow *q = &ehci->pshadow [frame];\r\nunsigned char uf;\r\nmemset(tt_usecs, 0, 16);\r\nwhile (q->ptr) {\r\nswitch (hc32_to_cpu(ehci, Q_NEXT_TYPE(ehci, *hw_p))) {\r\ncase Q_TYPE_ITD:\r\nhw_p = &q->itd->hw_next;\r\nq = &q->itd->itd_next;\r\ncontinue;\r\ncase Q_TYPE_QH:\r\nif (same_tt(dev, q->qh->dev)) {\r\nuf = tt_start_uframe(ehci, q->qh->hw->hw_info2);\r\ntt_usecs[uf] += q->qh->tt_usecs;\r\n}\r\nhw_p = &q->qh->hw->hw_next;\r\nq = &q->qh->qh_next;\r\ncontinue;\r\ncase Q_TYPE_SITD:\r\nif (same_tt(dev, q->sitd->urb->dev)) {\r\nuf = tt_start_uframe(ehci, q->sitd->hw_uframe);\r\ntt_usecs[uf] += q->sitd->stream->tt_usecs;\r\n}\r\nhw_p = &q->sitd->hw_next;\r\nq = &q->sitd->sitd_next;\r\ncontinue;\r\ndefault:\r\nehci_dbg(ehci, "ignoring periodic frame %d FSTN\n",\r\nframe);\r\nhw_p = &q->fstn->hw_next;\r\nq = &q->fstn->fstn_next;\r\n}\r\n}\r\ncarryover_tt_bandwidth(tt_usecs);\r\nif (max_tt_usecs[7] < tt_usecs[7])\r\nehci_err(ehci, "frame %d tt sched overrun: %d usecs\n",\r\nframe, tt_usecs[7] - max_tt_usecs[7]);\r\n}\r\nstatic int tt_available (\r\nstruct ehci_hcd *ehci,\r\nunsigned period,\r\nstruct usb_device *dev,\r\nunsigned frame,\r\nunsigned uframe,\r\nu16 usecs\r\n)\r\n{\r\nif ((period == 0) || (uframe >= 7))\r\nreturn 0;\r\nfor (; frame < ehci->periodic_size; frame += period) {\r\nunsigned short tt_usecs[8];\r\nperiodic_tt_usecs (ehci, dev, frame, tt_usecs);\r\nehci_vdbg(ehci, "tt frame %d check %d usecs start uframe %d in"\r\n" schedule %d/%d/%d/%d/%d/%d/%d/%d\n",\r\nframe, usecs, uframe,\r\ntt_usecs[0], tt_usecs[1], tt_usecs[2], tt_usecs[3],\r\ntt_usecs[4], tt_usecs[5], tt_usecs[6], tt_usecs[7]);\r\nif (max_tt_usecs[uframe] <= tt_usecs[uframe]) {\r\nehci_vdbg(ehci, "frame %d uframe %d fully scheduled\n",\r\nframe, uframe);\r\nreturn 0;\r\n}\r\nif (125 < usecs) {\r\nint ufs = (usecs / 125);\r\nint i;\r\nfor (i = uframe; i < (uframe + ufs) && i < 8; i++)\r\nif (0 < tt_usecs[i]) {\r\nehci_vdbg(ehci,\r\n"multi-uframe xfer can't fit "\r\n"in frame %d uframe %d\n",\r\nframe, i);\r\nreturn 0;\r\n}\r\n}\r\ntt_usecs[uframe] += usecs;\r\ncarryover_tt_bandwidth(tt_usecs);\r\nif (max_tt_usecs[7] < tt_usecs[7]) {\r\nehci_vdbg(ehci,\r\n"tt unavailable usecs %d frame %d uframe %d\n",\r\nusecs, frame, uframe);\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int tt_no_collision (\r\nstruct ehci_hcd *ehci,\r\nunsigned period,\r\nstruct usb_device *dev,\r\nunsigned frame,\r\nu32 uf_mask\r\n)\r\n{\r\nif (period == 0)\r\nreturn 0;\r\nfor (; frame < ehci->periodic_size; frame += period) {\r\nunion ehci_shadow here;\r\n__hc32 type;\r\nstruct ehci_qh_hw *hw;\r\nhere = ehci->pshadow [frame];\r\ntype = Q_NEXT_TYPE(ehci, ehci->periodic [frame]);\r\nwhile (here.ptr) {\r\nswitch (hc32_to_cpu(ehci, type)) {\r\ncase Q_TYPE_ITD:\r\ntype = Q_NEXT_TYPE(ehci, here.itd->hw_next);\r\nhere = here.itd->itd_next;\r\ncontinue;\r\ncase Q_TYPE_QH:\r\nhw = here.qh->hw;\r\nif (same_tt (dev, here.qh->dev)) {\r\nu32 mask;\r\nmask = hc32_to_cpu(ehci,\r\nhw->hw_info2);\r\nmask |= mask >> 8;\r\nif (mask & uf_mask)\r\nbreak;\r\n}\r\ntype = Q_NEXT_TYPE(ehci, hw->hw_next);\r\nhere = here.qh->qh_next;\r\ncontinue;\r\ncase Q_TYPE_SITD:\r\nif (same_tt (dev, here.sitd->urb->dev)) {\r\nu16 mask;\r\nmask = hc32_to_cpu(ehci, here.sitd\r\n->hw_uframe);\r\nmask |= mask >> 8;\r\nif (mask & uf_mask)\r\nbreak;\r\n}\r\ntype = Q_NEXT_TYPE(ehci, here.sitd->hw_next);\r\nhere = here.sitd->sitd_next;\r\ncontinue;\r\ndefault:\r\nehci_dbg (ehci,\r\n"periodic frame %d bogus type %d\n",\r\nframe, type);\r\n}\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int enable_periodic (struct ehci_hcd *ehci)\r\n{\r\nu32 cmd;\r\nint status;\r\nif (ehci->periodic_sched++)\r\nreturn 0;\r\nstatus = handshake_on_error_set_halt(ehci, &ehci->regs->status,\r\nSTS_PSS, 0, 9 * 125);\r\nif (status) {\r\nusb_hc_died(ehci_to_hcd(ehci));\r\nreturn status;\r\n}\r\ncmd = ehci_readl(ehci, &ehci->regs->command) | CMD_PSE;\r\nehci_writel(ehci, cmd, &ehci->regs->command);\r\nehci->next_uframe = ehci_read_frame_index(ehci)\r\n% (ehci->periodic_size << 3);\r\nif (unlikely(ehci->broken_periodic))\r\nehci->last_periodic_enable = ktime_get_real();\r\nreturn 0;\r\n}\r\nstatic int disable_periodic (struct ehci_hcd *ehci)\r\n{\r\nu32 cmd;\r\nint status;\r\nif (--ehci->periodic_sched)\r\nreturn 0;\r\nif (unlikely(ehci->broken_periodic)) {\r\nktime_t safe = ktime_add_us(ehci->last_periodic_enable, 1000);\r\nktime_t now = ktime_get_real();\r\ns64 delay = ktime_us_delta(safe, now);\r\nif (unlikely(delay > 0))\r\nudelay(delay);\r\n}\r\nstatus = handshake_on_error_set_halt(ehci, &ehci->regs->status,\r\nSTS_PSS, STS_PSS, 9 * 125);\r\nif (status) {\r\nusb_hc_died(ehci_to_hcd(ehci));\r\nreturn status;\r\n}\r\ncmd = ehci_readl(ehci, &ehci->regs->command) & ~CMD_PSE;\r\nehci_writel(ehci, cmd, &ehci->regs->command);\r\nfree_cached_lists(ehci);\r\nehci->next_uframe = -1;\r\nreturn 0;\r\n}\r\nstatic int qh_link_periodic (struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nunsigned i;\r\nunsigned period = qh->period;\r\ndev_dbg (&qh->dev->dev,\r\n"link qh%d-%04x/%p start %d [%d/%d us]\n",\r\nperiod, hc32_to_cpup(ehci, &qh->hw->hw_info2)\r\n& (QH_CMASK | QH_SMASK),\r\nqh, qh->start, qh->usecs, qh->c_usecs);\r\nif (period == 0)\r\nperiod = 1;\r\nfor (i = qh->start; i < ehci->periodic_size; i += period) {\r\nunion ehci_shadow *prev = &ehci->pshadow[i];\r\n__hc32 *hw_p = &ehci->periodic[i];\r\nunion ehci_shadow here = *prev;\r\n__hc32 type = 0;\r\nwhile (here.ptr) {\r\ntype = Q_NEXT_TYPE(ehci, *hw_p);\r\nif (type == cpu_to_hc32(ehci, Q_TYPE_QH))\r\nbreak;\r\nprev = periodic_next_shadow(ehci, prev, type);\r\nhw_p = shadow_next_periodic(ehci, &here, type);\r\nhere = *prev;\r\n}\r\nwhile (here.ptr && qh != here.qh) {\r\nif (qh->period > here.qh->period)\r\nbreak;\r\nprev = &here.qh->qh_next;\r\nhw_p = &here.qh->hw->hw_next;\r\nhere = *prev;\r\n}\r\nif (qh != here.qh) {\r\nqh->qh_next = here;\r\nif (here.qh)\r\nqh->hw->hw_next = *hw_p;\r\nwmb ();\r\nprev->qh = qh;\r\n*hw_p = QH_NEXT (ehci, qh->qh_dma);\r\n}\r\n}\r\nqh->qh_state = QH_STATE_LINKED;\r\nqh->xacterrs = 0;\r\nqh_get (qh);\r\nehci_to_hcd(ehci)->self.bandwidth_allocated += qh->period\r\n? ((qh->usecs + qh->c_usecs) / qh->period)\r\n: (qh->usecs * 8);\r\nreturn enable_periodic(ehci);\r\n}\r\nstatic int qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nunsigned i;\r\nunsigned period;\r\nif ((period = qh->period) == 0)\r\nperiod = 1;\r\nfor (i = qh->start; i < ehci->periodic_size; i += period)\r\nperiodic_unlink (ehci, i, qh);\r\nehci_to_hcd(ehci)->self.bandwidth_allocated -= qh->period\r\n? ((qh->usecs + qh->c_usecs) / qh->period)\r\n: (qh->usecs * 8);\r\ndev_dbg (&qh->dev->dev,\r\n"unlink qh%d-%04x/%p start %d [%d/%d us]\n",\r\nqh->period,\r\nhc32_to_cpup(ehci, &qh->hw->hw_info2) & (QH_CMASK | QH_SMASK),\r\nqh, qh->start, qh->usecs, qh->c_usecs);\r\nqh->qh_state = QH_STATE_UNLINK;\r\nqh->qh_next.ptr = NULL;\r\nqh_put (qh);\r\nreturn disable_periodic(ehci);\r\n}\r\nstatic void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nunsigned wait;\r\nstruct ehci_qh_hw *hw = qh->hw;\r\nint rc;\r\nif (qh->qh_state != QH_STATE_LINKED) {\r\nif (qh->qh_state == QH_STATE_COMPLETING)\r\nqh->needs_rescan = 1;\r\nreturn;\r\n}\r\nqh_unlink_periodic (ehci, qh);\r\nif (list_empty (&qh->qtd_list)\r\n|| (cpu_to_hc32(ehci, QH_CMASK)\r\n& hw->hw_info2) != 0)\r\nwait = 2;\r\nelse\r\nwait = 55;\r\nudelay (wait);\r\nqh->qh_state = QH_STATE_IDLE;\r\nhw->hw_next = EHCI_LIST_END(ehci);\r\nwmb ();\r\nqh_completions(ehci, qh);\r\nif (!list_empty(&qh->qtd_list) &&\r\nehci->rh_state == EHCI_RH_RUNNING) {\r\nrc = qh_schedule(ehci, qh);\r\nif (rc != 0)\r\nehci_err(ehci, "can't reschedule qh %p, err %d\n",\r\nqh, rc);\r\n}\r\n}\r\nstatic int check_period (\r\nstruct ehci_hcd *ehci,\r\nunsigned frame,\r\nunsigned uframe,\r\nunsigned period,\r\nunsigned usecs\r\n) {\r\nint claimed;\r\nif (uframe >= 8)\r\nreturn 0;\r\nusecs = ehci->uframe_periodic_max - usecs;\r\nif (unlikely (period == 0)) {\r\ndo {\r\nfor (uframe = 0; uframe < 7; uframe++) {\r\nclaimed = periodic_usecs (ehci, frame, uframe);\r\nif (claimed > usecs)\r\nreturn 0;\r\n}\r\n} while ((frame += 1) < ehci->periodic_size);\r\n} else {\r\ndo {\r\nclaimed = periodic_usecs (ehci, frame, uframe);\r\nif (claimed > usecs)\r\nreturn 0;\r\n} while ((frame += period) < ehci->periodic_size);\r\n}\r\nreturn 1;\r\n}\r\nstatic int check_intr_schedule (\r\nstruct ehci_hcd *ehci,\r\nunsigned frame,\r\nunsigned uframe,\r\nconst struct ehci_qh *qh,\r\n__hc32 *c_maskp\r\n)\r\n{\r\nint retval = -ENOSPC;\r\nu8 mask = 0;\r\nif (qh->c_usecs && uframe >= 6)\r\ngoto done;\r\nif (!check_period (ehci, frame, uframe, qh->period, qh->usecs))\r\ngoto done;\r\nif (!qh->c_usecs) {\r\nretval = 0;\r\n*c_maskp = 0;\r\ngoto done;\r\n}\r\n#ifdef CONFIG_USB_EHCI_TT_NEWSCHED\r\nif (tt_available (ehci, qh->period, qh->dev, frame, uframe,\r\nqh->tt_usecs)) {\r\nunsigned i;\r\nfor (i=uframe+1; i<8 && i<uframe+4; i++)\r\nif (!check_period (ehci, frame, i,\r\nqh->period, qh->c_usecs))\r\ngoto done;\r\nelse\r\nmask |= 1 << i;\r\nretval = 0;\r\n*c_maskp = cpu_to_hc32(ehci, mask << 8);\r\n}\r\n#else\r\nmask = 0x03 << (uframe + qh->gap_uf);\r\n*c_maskp = cpu_to_hc32(ehci, mask << 8);\r\nmask |= 1 << uframe;\r\nif (tt_no_collision (ehci, qh->period, qh->dev, frame, mask)) {\r\nif (!check_period (ehci, frame, uframe + qh->gap_uf + 1,\r\nqh->period, qh->c_usecs))\r\ngoto done;\r\nif (!check_period (ehci, frame, uframe + qh->gap_uf,\r\nqh->period, qh->c_usecs))\r\ngoto done;\r\nretval = 0;\r\n}\r\n#endif\r\ndone:\r\nreturn retval;\r\n}\r\nstatic int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nint status;\r\nunsigned uframe;\r\n__hc32 c_mask;\r\nunsigned frame;\r\nstruct ehci_qh_hw *hw = qh->hw;\r\nqh_refresh(ehci, qh);\r\nhw->hw_next = EHCI_LIST_END(ehci);\r\nframe = qh->start;\r\nif (frame < qh->period) {\r\nuframe = ffs(hc32_to_cpup(ehci, &hw->hw_info2) & QH_SMASK);\r\nstatus = check_intr_schedule (ehci, frame, --uframe,\r\nqh, &c_mask);\r\n} else {\r\nuframe = 0;\r\nc_mask = 0;\r\nstatus = -ENOSPC;\r\n}\r\nif (status) {\r\nif (qh->period) {\r\nint i;\r\nfor (i = qh->period; status && i > 0; --i) {\r\nframe = ++ehci->random_frame % qh->period;\r\nfor (uframe = 0; uframe < 8; uframe++) {\r\nstatus = check_intr_schedule (ehci,\r\nframe, uframe, qh,\r\n&c_mask);\r\nif (status == 0)\r\nbreak;\r\n}\r\n}\r\n} else {\r\nframe = 0;\r\nstatus = check_intr_schedule (ehci, 0, 0, qh, &c_mask);\r\n}\r\nif (status)\r\ngoto done;\r\nqh->start = frame;\r\nhw->hw_info2 &= cpu_to_hc32(ehci, ~(QH_CMASK | QH_SMASK));\r\nhw->hw_info2 |= qh->period\r\n? cpu_to_hc32(ehci, 1 << uframe)\r\n: cpu_to_hc32(ehci, QH_SMASK);\r\nhw->hw_info2 |= c_mask;\r\n} else\r\nehci_dbg (ehci, "reused qh %p schedule\n", qh);\r\nstatus = qh_link_periodic (ehci, qh);\r\ndone:\r\nreturn status;\r\n}\r\nstatic int intr_submit (\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nstruct list_head *qtd_list,\r\ngfp_t mem_flags\r\n) {\r\nunsigned epnum;\r\nunsigned long flags;\r\nstruct ehci_qh *qh;\r\nint status;\r\nstruct list_head empty;\r\nepnum = urb->ep->desc.bEndpointAddress;\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {\r\nstatus = -ESHUTDOWN;\r\ngoto done_not_linked;\r\n}\r\nstatus = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);\r\nif (unlikely(status))\r\ngoto done_not_linked;\r\nINIT_LIST_HEAD (&empty);\r\nqh = qh_append_tds(ehci, urb, &empty, epnum, &urb->ep->hcpriv);\r\nif (qh == NULL) {\r\nstatus = -ENOMEM;\r\ngoto done;\r\n}\r\nif (qh->qh_state == QH_STATE_IDLE) {\r\nif ((status = qh_schedule (ehci, qh)) != 0)\r\ngoto done;\r\n}\r\nqh = qh_append_tds(ehci, urb, qtd_list, epnum, &urb->ep->hcpriv);\r\nBUG_ON (qh == NULL);\r\nehci_to_hcd(ehci)->self.bandwidth_int_reqs++;\r\ndone:\r\nif (unlikely(status))\r\nusb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);\r\ndone_not_linked:\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\nif (status)\r\nqtd_list_free (ehci, urb, qtd_list);\r\nreturn status;\r\n}\r\nstatic struct ehci_iso_stream *\r\niso_stream_alloc (gfp_t mem_flags)\r\n{\r\nstruct ehci_iso_stream *stream;\r\nstream = kzalloc(sizeof *stream, mem_flags);\r\nif (likely (stream != NULL)) {\r\nINIT_LIST_HEAD(&stream->td_list);\r\nINIT_LIST_HEAD(&stream->free_list);\r\nstream->next_uframe = -1;\r\nstream->refcount = 1;\r\n}\r\nreturn stream;\r\n}\r\nstatic void\r\niso_stream_init (\r\nstruct ehci_hcd *ehci,\r\nstruct ehci_iso_stream *stream,\r\nstruct usb_device *dev,\r\nint pipe,\r\nunsigned interval\r\n)\r\n{\r\nstatic const u8 smask_out [] = { 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f };\r\nu32 buf1;\r\nunsigned epnum, maxp;\r\nint is_input;\r\nlong bandwidth;\r\nepnum = usb_pipeendpoint (pipe);\r\nis_input = usb_pipein (pipe) ? USB_DIR_IN : 0;\r\nmaxp = usb_maxpacket(dev, pipe, !is_input);\r\nif (is_input) {\r\nbuf1 = (1 << 11);\r\n} else {\r\nbuf1 = 0;\r\n}\r\nif (dev->speed == USB_SPEED_HIGH) {\r\nunsigned multi = hb_mult(maxp);\r\nstream->highspeed = 1;\r\nmaxp = max_packet(maxp);\r\nbuf1 |= maxp;\r\nmaxp *= multi;\r\nstream->buf0 = cpu_to_hc32(ehci, (epnum << 8) | dev->devnum);\r\nstream->buf1 = cpu_to_hc32(ehci, buf1);\r\nstream->buf2 = cpu_to_hc32(ehci, multi);\r\nstream->usecs = HS_USECS_ISO (maxp);\r\nbandwidth = stream->usecs * 8;\r\nbandwidth /= interval;\r\n} else {\r\nu32 addr;\r\nint think_time;\r\nint hs_transfers;\r\naddr = dev->ttport << 24;\r\nif (!ehci_is_TDI(ehci)\r\n|| (dev->tt->hub !=\r\nehci_to_hcd(ehci)->self.root_hub))\r\naddr |= dev->tt->hub->devnum << 16;\r\naddr |= epnum << 8;\r\naddr |= dev->devnum;\r\nstream->usecs = HS_USECS_ISO (maxp);\r\nthink_time = dev->tt ? dev->tt->think_time : 0;\r\nstream->tt_usecs = NS_TO_US (think_time + usb_calc_bus_time (\r\ndev->speed, is_input, 1, maxp));\r\nhs_transfers = max (1u, (maxp + 187) / 188);\r\nif (is_input) {\r\nu32 tmp;\r\naddr |= 1 << 31;\r\nstream->c_usecs = stream->usecs;\r\nstream->usecs = HS_USECS_ISO (1);\r\nstream->raw_mask = 1;\r\ntmp = (1 << (hs_transfers + 2)) - 1;\r\nstream->raw_mask |= tmp << (8 + 2);\r\n} else\r\nstream->raw_mask = smask_out [hs_transfers - 1];\r\nbandwidth = stream->usecs + stream->c_usecs;\r\nbandwidth /= interval << 3;\r\nstream->address = cpu_to_hc32(ehci, addr);\r\n}\r\nstream->bandwidth = bandwidth;\r\nstream->udev = dev;\r\nstream->bEndpointAddress = is_input | epnum;\r\nstream->interval = interval;\r\nstream->maxp = maxp;\r\n}\r\nstatic void\r\niso_stream_put(struct ehci_hcd *ehci, struct ehci_iso_stream *stream)\r\n{\r\nstream->refcount--;\r\nif (stream->refcount == 1) {\r\nwhile (!list_empty (&stream->free_list)) {\r\nstruct list_head *entry;\r\nentry = stream->free_list.next;\r\nlist_del (entry);\r\nif (stream->highspeed) {\r\nstruct ehci_itd *itd;\r\nitd = list_entry (entry, struct ehci_itd,\r\nitd_list);\r\ndma_pool_free (ehci->itd_pool, itd,\r\nitd->itd_dma);\r\n} else {\r\nstruct ehci_sitd *sitd;\r\nsitd = list_entry (entry, struct ehci_sitd,\r\nsitd_list);\r\ndma_pool_free (ehci->sitd_pool, sitd,\r\nsitd->sitd_dma);\r\n}\r\n}\r\nstream->bEndpointAddress &= 0x0f;\r\nif (stream->ep)\r\nstream->ep->hcpriv = NULL;\r\nkfree(stream);\r\n}\r\n}\r\nstatic inline struct ehci_iso_stream *\r\niso_stream_get (struct ehci_iso_stream *stream)\r\n{\r\nif (likely (stream != NULL))\r\nstream->refcount++;\r\nreturn stream;\r\n}\r\nstatic struct ehci_iso_stream *\r\niso_stream_find (struct ehci_hcd *ehci, struct urb *urb)\r\n{\r\nunsigned epnum;\r\nstruct ehci_iso_stream *stream;\r\nstruct usb_host_endpoint *ep;\r\nunsigned long flags;\r\nepnum = usb_pipeendpoint (urb->pipe);\r\nif (usb_pipein(urb->pipe))\r\nep = urb->dev->ep_in[epnum];\r\nelse\r\nep = urb->dev->ep_out[epnum];\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nstream = ep->hcpriv;\r\nif (unlikely (stream == NULL)) {\r\nstream = iso_stream_alloc(GFP_ATOMIC);\r\nif (likely (stream != NULL)) {\r\nep->hcpriv = stream;\r\nstream->ep = ep;\r\niso_stream_init(ehci, stream, urb->dev, urb->pipe,\r\nurb->interval);\r\n}\r\n} else if (unlikely (stream->hw != NULL)) {\r\nehci_dbg (ehci, "dev %s ep%d%s, not iso??\n",\r\nurb->dev->devpath, epnum,\r\nusb_pipein(urb->pipe) ? "in" : "out");\r\nstream = NULL;\r\n}\r\nstream = iso_stream_get (stream);\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\nreturn stream;\r\n}\r\nstatic struct ehci_iso_sched *\r\niso_sched_alloc (unsigned packets, gfp_t mem_flags)\r\n{\r\nstruct ehci_iso_sched *iso_sched;\r\nint size = sizeof *iso_sched;\r\nsize += packets * sizeof (struct ehci_iso_packet);\r\niso_sched = kzalloc(size, mem_flags);\r\nif (likely (iso_sched != NULL)) {\r\nINIT_LIST_HEAD (&iso_sched->td_list);\r\n}\r\nreturn iso_sched;\r\n}\r\nstatic inline void\r\nitd_sched_init(\r\nstruct ehci_hcd *ehci,\r\nstruct ehci_iso_sched *iso_sched,\r\nstruct ehci_iso_stream *stream,\r\nstruct urb *urb\r\n)\r\n{\r\nunsigned i;\r\ndma_addr_t dma = urb->transfer_dma;\r\niso_sched->span = urb->number_of_packets * stream->interval;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nstruct ehci_iso_packet *uframe = &iso_sched->packet [i];\r\nunsigned length;\r\ndma_addr_t buf;\r\nu32 trans;\r\nlength = urb->iso_frame_desc [i].length;\r\nbuf = dma + urb->iso_frame_desc [i].offset;\r\ntrans = EHCI_ISOC_ACTIVE;\r\ntrans |= buf & 0x0fff;\r\nif (unlikely (((i + 1) == urb->number_of_packets))\r\n&& !(urb->transfer_flags & URB_NO_INTERRUPT))\r\ntrans |= EHCI_ITD_IOC;\r\ntrans |= length << 16;\r\nuframe->transaction = cpu_to_hc32(ehci, trans);\r\nuframe->bufp = (buf & ~(u64)0x0fff);\r\nbuf += length;\r\nif (unlikely ((uframe->bufp != (buf & ~(u64)0x0fff))))\r\nuframe->cross = 1;\r\n}\r\n}\r\nstatic void\r\niso_sched_free (\r\nstruct ehci_iso_stream *stream,\r\nstruct ehci_iso_sched *iso_sched\r\n)\r\n{\r\nif (!iso_sched)\r\nreturn;\r\nlist_splice (&iso_sched->td_list, &stream->free_list);\r\nkfree (iso_sched);\r\n}\r\nstatic int\r\nitd_urb_transaction (\r\nstruct ehci_iso_stream *stream,\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\ngfp_t mem_flags\r\n)\r\n{\r\nstruct ehci_itd *itd;\r\ndma_addr_t itd_dma;\r\nint i;\r\nunsigned num_itds;\r\nstruct ehci_iso_sched *sched;\r\nunsigned long flags;\r\nsched = iso_sched_alloc (urb->number_of_packets, mem_flags);\r\nif (unlikely (sched == NULL))\r\nreturn -ENOMEM;\r\nitd_sched_init(ehci, sched, stream, urb);\r\nif (urb->interval < 8)\r\nnum_itds = 1 + (sched->span + 7) / 8;\r\nelse\r\nnum_itds = urb->number_of_packets;\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nfor (i = 0; i < num_itds; i++) {\r\nif (likely (!list_empty(&stream->free_list))) {\r\nitd = list_entry (stream->free_list.prev,\r\nstruct ehci_itd, itd_list);\r\nlist_del (&itd->itd_list);\r\nitd_dma = itd->itd_dma;\r\n} else {\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\nitd = dma_pool_alloc (ehci->itd_pool, mem_flags,\r\n&itd_dma);\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nif (!itd) {\r\niso_sched_free(stream, sched);\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmemset (itd, 0, sizeof *itd);\r\nitd->itd_dma = itd_dma;\r\nlist_add (&itd->itd_list, &sched->td_list);\r\n}\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\nurb->hcpriv = sched;\r\nurb->error_count = 0;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nitd_slot_ok (\r\nstruct ehci_hcd *ehci,\r\nu32 mod,\r\nu32 uframe,\r\nu8 usecs,\r\nu32 period\r\n)\r\n{\r\nuframe %= period;\r\ndo {\r\nif (periodic_usecs (ehci, uframe >> 3, uframe & 0x7)\r\n> (ehci->uframe_periodic_max - usecs))\r\nreturn 0;\r\nuframe += period;\r\n} while (uframe < mod);\r\nreturn 1;\r\n}\r\nstatic inline int\r\nsitd_slot_ok (\r\nstruct ehci_hcd *ehci,\r\nu32 mod,\r\nstruct ehci_iso_stream *stream,\r\nu32 uframe,\r\nstruct ehci_iso_sched *sched,\r\nu32 period_uframes\r\n)\r\n{\r\nu32 mask, tmp;\r\nu32 frame, uf;\r\nmask = stream->raw_mask << (uframe & 7);\r\nif (mask & ~0xffff)\r\nreturn 0;\r\nuframe %= period_uframes;\r\ndo {\r\nu32 max_used;\r\nframe = uframe >> 3;\r\nuf = uframe & 7;\r\n#ifdef CONFIG_USB_EHCI_TT_NEWSCHED\r\nif (!tt_available (ehci, period_uframes << 3,\r\nstream->udev, frame, uf, stream->tt_usecs))\r\nreturn 0;\r\n#else\r\nif (!tt_no_collision (ehci, period_uframes << 3,\r\nstream->udev, frame, mask))\r\nreturn 0;\r\n#endif\r\nmax_used = ehci->uframe_periodic_max - stream->usecs;\r\nfor (tmp = stream->raw_mask & 0xff; tmp; tmp >>= 1, uf++) {\r\nif (periodic_usecs (ehci, frame, uf) > max_used)\r\nreturn 0;\r\n}\r\nif (stream->c_usecs) {\r\nuf = uframe & 7;\r\nmax_used = ehci->uframe_periodic_max - stream->c_usecs;\r\ndo {\r\ntmp = 1 << uf;\r\ntmp <<= 8;\r\nif ((stream->raw_mask & tmp) == 0)\r\ncontinue;\r\nif (periodic_usecs (ehci, frame, uf)\r\n> max_used)\r\nreturn 0;\r\n} while (++uf < 8);\r\n}\r\nuframe += period_uframes;\r\n} while (uframe < mod);\r\nstream->splits = cpu_to_hc32(ehci, stream->raw_mask << (uframe & 7));\r\nreturn 1;\r\n}\r\nstatic int\r\niso_stream_schedule (\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nstruct ehci_iso_stream *stream\r\n)\r\n{\r\nu32 now, next, start, period, span;\r\nint status;\r\nunsigned mod = ehci->periodic_size << 3;\r\nstruct ehci_iso_sched *sched = urb->hcpriv;\r\nperiod = urb->interval;\r\nspan = sched->span;\r\nif (!stream->highspeed) {\r\nperiod <<= 3;\r\nspan <<= 3;\r\n}\r\nif (span > mod - SCHEDULE_SLOP) {\r\nehci_dbg (ehci, "iso request %p too long\n", urb);\r\nstatus = -EFBIG;\r\ngoto fail;\r\n}\r\nnow = ehci_read_frame_index(ehci) & (mod - 1);\r\nif (likely (!list_empty (&stream->td_list))) {\r\nu32 excess;\r\nif (!stream->highspeed && ehci->fs_i_thresh)\r\nnext = now + ehci->i_thresh;\r\nelse\r\nnext = now;\r\nexcess = (stream->next_uframe - period - next) & (mod - 1);\r\nif (excess >= mod - 2 * SCHEDULE_SLOP)\r\nstart = next + excess - mod + period *\r\nDIV_ROUND_UP(mod - excess, period);\r\nelse\r\nstart = next + excess + period;\r\nif (start - now >= mod) {\r\nehci_dbg(ehci, "request %p would overflow (%d+%d >= %d)\n",\r\nurb, start - now - period, period,\r\nmod);\r\nstatus = -EFBIG;\r\ngoto fail;\r\n}\r\n}\r\nelse {\r\nint done = 0;\r\nstart = SCHEDULE_SLOP + (now & ~0x07);\r\nnext = start;\r\nstart += period;\r\ndo {\r\nstart--;\r\nif (stream->highspeed) {\r\nif (itd_slot_ok(ehci, mod, start,\r\nstream->usecs, period))\r\ndone = 1;\r\n} else {\r\nif ((start % 8) >= 6)\r\ncontinue;\r\nif (sitd_slot_ok(ehci, mod, stream,\r\nstart, sched, period))\r\ndone = 1;\r\n}\r\n} while (start > next && !done);\r\nif (!done) {\r\nehci_dbg(ehci, "iso resched full %p (now %d max %d)\n",\r\nurb, now, now + mod);\r\nstatus = -ENOSPC;\r\ngoto fail;\r\n}\r\n}\r\nif (unlikely(start - now + span - period\r\n>= mod - 2 * SCHEDULE_SLOP)) {\r\nehci_dbg(ehci, "request %p would overflow (%d+%d >= %d)\n",\r\nurb, start - now, span - period,\r\nmod - 2 * SCHEDULE_SLOP);\r\nstatus = -EFBIG;\r\ngoto fail;\r\n}\r\nstream->next_uframe = start & (mod - 1);\r\nurb->start_frame = stream->next_uframe;\r\nif (!stream->highspeed)\r\nurb->start_frame >>= 3;\r\nreturn 0;\r\nfail:\r\niso_sched_free(stream, sched);\r\nurb->hcpriv = NULL;\r\nreturn status;\r\n}\r\nstatic inline void\r\nitd_init(struct ehci_hcd *ehci, struct ehci_iso_stream *stream,\r\nstruct ehci_itd *itd)\r\n{\r\nint i;\r\nitd->hw_next = EHCI_LIST_END(ehci);\r\nitd->hw_bufp [0] = stream->buf0;\r\nitd->hw_bufp [1] = stream->buf1;\r\nitd->hw_bufp [2] = stream->buf2;\r\nfor (i = 0; i < 8; i++)\r\nitd->index[i] = -1;\r\n}\r\nstatic inline void\r\nitd_patch(\r\nstruct ehci_hcd *ehci,\r\nstruct ehci_itd *itd,\r\nstruct ehci_iso_sched *iso_sched,\r\nunsigned index,\r\nu16 uframe\r\n)\r\n{\r\nstruct ehci_iso_packet *uf = &iso_sched->packet [index];\r\nunsigned pg = itd->pg;\r\nuframe &= 0x07;\r\nitd->index [uframe] = index;\r\nitd->hw_transaction[uframe] = uf->transaction;\r\nitd->hw_transaction[uframe] |= cpu_to_hc32(ehci, pg << 12);\r\nitd->hw_bufp[pg] |= cpu_to_hc32(ehci, uf->bufp & ~(u32)0);\r\nitd->hw_bufp_hi[pg] |= cpu_to_hc32(ehci, (u32)(uf->bufp >> 32));\r\nif (unlikely (uf->cross)) {\r\nu64 bufp = uf->bufp + 4096;\r\nitd->pg = ++pg;\r\nitd->hw_bufp[pg] |= cpu_to_hc32(ehci, bufp & ~(u32)0);\r\nitd->hw_bufp_hi[pg] |= cpu_to_hc32(ehci, (u32)(bufp >> 32));\r\n}\r\n}\r\nstatic inline void\r\nitd_link (struct ehci_hcd *ehci, unsigned frame, struct ehci_itd *itd)\r\n{\r\nunion ehci_shadow *prev = &ehci->pshadow[frame];\r\n__hc32 *hw_p = &ehci->periodic[frame];\r\nunion ehci_shadow here = *prev;\r\n__hc32 type = 0;\r\nwhile (here.ptr) {\r\ntype = Q_NEXT_TYPE(ehci, *hw_p);\r\nif (type == cpu_to_hc32(ehci, Q_TYPE_QH))\r\nbreak;\r\nprev = periodic_next_shadow(ehci, prev, type);\r\nhw_p = shadow_next_periodic(ehci, &here, type);\r\nhere = *prev;\r\n}\r\nitd->itd_next = here;\r\nitd->hw_next = *hw_p;\r\nprev->itd = itd;\r\nitd->frame = frame;\r\nwmb ();\r\n*hw_p = cpu_to_hc32(ehci, itd->itd_dma | Q_TYPE_ITD);\r\n}\r\nstatic int\r\nitd_link_urb (\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nunsigned mod,\r\nstruct ehci_iso_stream *stream\r\n)\r\n{\r\nint packet;\r\nunsigned next_uframe, uframe, frame;\r\nstruct ehci_iso_sched *iso_sched = urb->hcpriv;\r\nstruct ehci_itd *itd;\r\nnext_uframe = stream->next_uframe & (mod - 1);\r\nif (unlikely (list_empty(&stream->td_list))) {\r\nehci_to_hcd(ehci)->self.bandwidth_allocated\r\n+= stream->bandwidth;\r\nehci_vdbg (ehci,\r\n"schedule devp %s ep%d%s-iso period %d start %d.%d\n",\r\nurb->dev->devpath, stream->bEndpointAddress & 0x0f,\r\n(stream->bEndpointAddress & USB_DIR_IN) ? "in" : "out",\r\nurb->interval,\r\nnext_uframe >> 3, next_uframe & 0x7);\r\n}\r\nif (ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs == 0) {\r\nif (ehci->amd_pll_fix == 1)\r\nusb_amd_quirk_pll_disable();\r\n}\r\nehci_to_hcd(ehci)->self.bandwidth_isoc_reqs++;\r\nfor (packet = 0, itd = NULL; packet < urb->number_of_packets; ) {\r\nif (itd == NULL) {\r\nitd = list_entry (iso_sched->td_list.next,\r\nstruct ehci_itd, itd_list);\r\nlist_move_tail (&itd->itd_list, &stream->td_list);\r\nitd->stream = iso_stream_get (stream);\r\nitd->urb = urb;\r\nitd_init (ehci, stream, itd);\r\n}\r\nuframe = next_uframe & 0x07;\r\nframe = next_uframe >> 3;\r\nitd_patch(ehci, itd, iso_sched, packet, uframe);\r\nnext_uframe += stream->interval;\r\nnext_uframe &= mod - 1;\r\npacket++;\r\nif (((next_uframe >> 3) != frame)\r\n|| packet == urb->number_of_packets) {\r\nitd_link(ehci, frame & (ehci->periodic_size - 1), itd);\r\nitd = NULL;\r\n}\r\n}\r\nstream->next_uframe = next_uframe;\r\niso_sched_free (stream, iso_sched);\r\nurb->hcpriv = NULL;\r\ntimer_action (ehci, TIMER_IO_WATCHDOG);\r\nreturn enable_periodic(ehci);\r\n}\r\nstatic unsigned\r\nitd_complete (\r\nstruct ehci_hcd *ehci,\r\nstruct ehci_itd *itd\r\n) {\r\nstruct urb *urb = itd->urb;\r\nstruct usb_iso_packet_descriptor *desc;\r\nu32 t;\r\nunsigned uframe;\r\nint urb_index = -1;\r\nstruct ehci_iso_stream *stream = itd->stream;\r\nstruct usb_device *dev;\r\nunsigned retval = false;\r\nfor (uframe = 0; uframe < 8; uframe++) {\r\nif (likely (itd->index[uframe] == -1))\r\ncontinue;\r\nurb_index = itd->index[uframe];\r\ndesc = &urb->iso_frame_desc [urb_index];\r\nt = hc32_to_cpup(ehci, &itd->hw_transaction [uframe]);\r\nitd->hw_transaction [uframe] = 0;\r\nif (unlikely (t & ISO_ERRS)) {\r\nurb->error_count++;\r\nif (t & EHCI_ISOC_BUF_ERR)\r\ndesc->status = usb_pipein (urb->pipe)\r\n? -ENOSR\r\n: -ECOMM;\r\nelse if (t & EHCI_ISOC_BABBLE)\r\ndesc->status = -EOVERFLOW;\r\nelse\r\ndesc->status = -EPROTO;\r\nif (!(t & EHCI_ISOC_BABBLE)) {\r\ndesc->actual_length = EHCI_ITD_LENGTH(t);\r\nurb->actual_length += desc->actual_length;\r\n}\r\n} else if (likely ((t & EHCI_ISOC_ACTIVE) == 0)) {\r\ndesc->status = 0;\r\ndesc->actual_length = EHCI_ITD_LENGTH(t);\r\nurb->actual_length += desc->actual_length;\r\n} else {\r\ndesc->status = -EXDEV;\r\n}\r\n}\r\nif (likely ((urb_index + 1) != urb->number_of_packets))\r\ngoto done;\r\ndev = urb->dev;\r\nehci_urb_done(ehci, urb, 0);\r\nretval = true;\r\nurb = NULL;\r\n(void) disable_periodic(ehci);\r\nehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;\r\nif (ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs == 0) {\r\nif (ehci->amd_pll_fix == 1)\r\nusb_amd_quirk_pll_enable();\r\n}\r\nif (unlikely(list_is_singular(&stream->td_list))) {\r\nehci_to_hcd(ehci)->self.bandwidth_allocated\r\n-= stream->bandwidth;\r\nehci_vdbg (ehci,\r\n"deschedule devp %s ep%d%s-iso\n",\r\ndev->devpath, stream->bEndpointAddress & 0x0f,\r\n(stream->bEndpointAddress & USB_DIR_IN) ? "in" : "out");\r\n}\r\niso_stream_put (ehci, stream);\r\ndone:\r\nitd->urb = NULL;\r\nif (ehci->clock_frame != itd->frame || itd->index[7] != -1) {\r\nitd->stream = NULL;\r\nlist_move(&itd->itd_list, &stream->free_list);\r\niso_stream_put(ehci, stream);\r\n} else {\r\nlist_move(&itd->itd_list, &ehci->cached_itd_list);\r\nif (stream->refcount == 2) {\r\nstream->ep->hcpriv = NULL;\r\nstream->ep = NULL;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic int itd_submit (struct ehci_hcd *ehci, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nint status = -EINVAL;\r\nunsigned long flags;\r\nstruct ehci_iso_stream *stream;\r\nstream = iso_stream_find (ehci, urb);\r\nif (unlikely (stream == NULL)) {\r\nehci_dbg (ehci, "can't get iso stream\n");\r\nreturn -ENOMEM;\r\n}\r\nif (unlikely (urb->interval != stream->interval)) {\r\nehci_dbg (ehci, "can't change iso interval %d --> %d\n",\r\nstream->interval, urb->interval);\r\ngoto done;\r\n}\r\n#ifdef EHCI_URB_TRACE\r\nehci_dbg (ehci,\r\n"%s %s urb %p ep%d%s len %d, %d pkts %d uframes [%p]\n",\r\n__func__, urb->dev->devpath, urb,\r\nusb_pipeendpoint (urb->pipe),\r\nusb_pipein (urb->pipe) ? "in" : "out",\r\nurb->transfer_buffer_length,\r\nurb->number_of_packets, urb->interval,\r\nstream);\r\n#endif\r\nstatus = itd_urb_transaction (stream, ehci, urb, mem_flags);\r\nif (unlikely (status < 0)) {\r\nehci_dbg (ehci, "can't init itds\n");\r\ngoto done;\r\n}\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {\r\nstatus = -ESHUTDOWN;\r\ngoto done_not_linked;\r\n}\r\nstatus = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);\r\nif (unlikely(status))\r\ngoto done_not_linked;\r\nstatus = iso_stream_schedule(ehci, urb, stream);\r\nif (likely (status == 0))\r\nitd_link_urb (ehci, urb, ehci->periodic_size << 3, stream);\r\nelse\r\nusb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);\r\ndone_not_linked:\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\ndone:\r\nif (unlikely (status < 0))\r\niso_stream_put (ehci, stream);\r\nreturn status;\r\n}\r\nstatic inline void\r\nsitd_sched_init(\r\nstruct ehci_hcd *ehci,\r\nstruct ehci_iso_sched *iso_sched,\r\nstruct ehci_iso_stream *stream,\r\nstruct urb *urb\r\n)\r\n{\r\nunsigned i;\r\ndma_addr_t dma = urb->transfer_dma;\r\niso_sched->span = urb->number_of_packets * stream->interval;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nstruct ehci_iso_packet *packet = &iso_sched->packet [i];\r\nunsigned length;\r\ndma_addr_t buf;\r\nu32 trans;\r\nlength = urb->iso_frame_desc [i].length & 0x03ff;\r\nbuf = dma + urb->iso_frame_desc [i].offset;\r\ntrans = SITD_STS_ACTIVE;\r\nif (((i + 1) == urb->number_of_packets)\r\n&& !(urb->transfer_flags & URB_NO_INTERRUPT))\r\ntrans |= SITD_IOC;\r\ntrans |= length << 16;\r\npacket->transaction = cpu_to_hc32(ehci, trans);\r\npacket->bufp = buf;\r\npacket->buf1 = (buf + length) & ~0x0fff;\r\nif (packet->buf1 != (buf & ~(u64)0x0fff))\r\npacket->cross = 1;\r\nif (stream->bEndpointAddress & USB_DIR_IN)\r\ncontinue;\r\nlength = (length + 187) / 188;\r\nif (length > 1)\r\nlength |= 1 << 3;\r\npacket->buf1 |= length;\r\n}\r\n}\r\nstatic int\r\nsitd_urb_transaction (\r\nstruct ehci_iso_stream *stream,\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\ngfp_t mem_flags\r\n)\r\n{\r\nstruct ehci_sitd *sitd;\r\ndma_addr_t sitd_dma;\r\nint i;\r\nstruct ehci_iso_sched *iso_sched;\r\nunsigned long flags;\r\niso_sched = iso_sched_alloc (urb->number_of_packets, mem_flags);\r\nif (iso_sched == NULL)\r\nreturn -ENOMEM;\r\nsitd_sched_init(ehci, iso_sched, stream, urb);\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nif (!list_empty(&stream->free_list)) {\r\nsitd = list_entry (stream->free_list.prev,\r\nstruct ehci_sitd, sitd_list);\r\nlist_del (&sitd->sitd_list);\r\nsitd_dma = sitd->sitd_dma;\r\n} else {\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\nsitd = dma_pool_alloc (ehci->sitd_pool, mem_flags,\r\n&sitd_dma);\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nif (!sitd) {\r\niso_sched_free(stream, iso_sched);\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmemset (sitd, 0, sizeof *sitd);\r\nsitd->sitd_dma = sitd_dma;\r\nlist_add (&sitd->sitd_list, &iso_sched->td_list);\r\n}\r\nurb->hcpriv = iso_sched;\r\nurb->error_count = 0;\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nsitd_patch(\r\nstruct ehci_hcd *ehci,\r\nstruct ehci_iso_stream *stream,\r\nstruct ehci_sitd *sitd,\r\nstruct ehci_iso_sched *iso_sched,\r\nunsigned index\r\n)\r\n{\r\nstruct ehci_iso_packet *uf = &iso_sched->packet [index];\r\nu64 bufp = uf->bufp;\r\nsitd->hw_next = EHCI_LIST_END(ehci);\r\nsitd->hw_fullspeed_ep = stream->address;\r\nsitd->hw_uframe = stream->splits;\r\nsitd->hw_results = uf->transaction;\r\nsitd->hw_backpointer = EHCI_LIST_END(ehci);\r\nbufp = uf->bufp;\r\nsitd->hw_buf[0] = cpu_to_hc32(ehci, bufp);\r\nsitd->hw_buf_hi[0] = cpu_to_hc32(ehci, bufp >> 32);\r\nsitd->hw_buf[1] = cpu_to_hc32(ehci, uf->buf1);\r\nif (uf->cross)\r\nbufp += 4096;\r\nsitd->hw_buf_hi[1] = cpu_to_hc32(ehci, bufp >> 32);\r\nsitd->index = index;\r\n}\r\nstatic inline void\r\nsitd_link (struct ehci_hcd *ehci, unsigned frame, struct ehci_sitd *sitd)\r\n{\r\nsitd->sitd_next = ehci->pshadow [frame];\r\nsitd->hw_next = ehci->periodic [frame];\r\nehci->pshadow [frame].sitd = sitd;\r\nsitd->frame = frame;\r\nwmb ();\r\nehci->periodic[frame] = cpu_to_hc32(ehci, sitd->sitd_dma | Q_TYPE_SITD);\r\n}\r\nstatic int\r\nsitd_link_urb (\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nunsigned mod,\r\nstruct ehci_iso_stream *stream\r\n)\r\n{\r\nint packet;\r\nunsigned next_uframe;\r\nstruct ehci_iso_sched *sched = urb->hcpriv;\r\nstruct ehci_sitd *sitd;\r\nnext_uframe = stream->next_uframe;\r\nif (list_empty(&stream->td_list)) {\r\nehci_to_hcd(ehci)->self.bandwidth_allocated\r\n+= stream->bandwidth;\r\nehci_vdbg (ehci,\r\n"sched devp %s ep%d%s-iso [%d] %dms/%04x\n",\r\nurb->dev->devpath, stream->bEndpointAddress & 0x0f,\r\n(stream->bEndpointAddress & USB_DIR_IN) ? "in" : "out",\r\n(next_uframe >> 3) & (ehci->periodic_size - 1),\r\nstream->interval, hc32_to_cpu(ehci, stream->splits));\r\n}\r\nif (ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs == 0) {\r\nif (ehci->amd_pll_fix == 1)\r\nusb_amd_quirk_pll_disable();\r\n}\r\nehci_to_hcd(ehci)->self.bandwidth_isoc_reqs++;\r\nfor (packet = 0, sitd = NULL;\r\npacket < urb->number_of_packets;\r\npacket++) {\r\nBUG_ON (list_empty (&sched->td_list));\r\nsitd = list_entry (sched->td_list.next,\r\nstruct ehci_sitd, sitd_list);\r\nlist_move_tail (&sitd->sitd_list, &stream->td_list);\r\nsitd->stream = iso_stream_get (stream);\r\nsitd->urb = urb;\r\nsitd_patch(ehci, stream, sitd, sched, packet);\r\nsitd_link(ehci, (next_uframe >> 3) & (ehci->periodic_size - 1),\r\nsitd);\r\nnext_uframe += stream->interval << 3;\r\n}\r\nstream->next_uframe = next_uframe & (mod - 1);\r\niso_sched_free (stream, sched);\r\nurb->hcpriv = NULL;\r\ntimer_action (ehci, TIMER_IO_WATCHDOG);\r\nreturn enable_periodic(ehci);\r\n}\r\nstatic unsigned\r\nsitd_complete (\r\nstruct ehci_hcd *ehci,\r\nstruct ehci_sitd *sitd\r\n) {\r\nstruct urb *urb = sitd->urb;\r\nstruct usb_iso_packet_descriptor *desc;\r\nu32 t;\r\nint urb_index = -1;\r\nstruct ehci_iso_stream *stream = sitd->stream;\r\nstruct usb_device *dev;\r\nunsigned retval = false;\r\nurb_index = sitd->index;\r\ndesc = &urb->iso_frame_desc [urb_index];\r\nt = hc32_to_cpup(ehci, &sitd->hw_results);\r\nif (t & SITD_ERRS) {\r\nurb->error_count++;\r\nif (t & SITD_STS_DBE)\r\ndesc->status = usb_pipein (urb->pipe)\r\n? -ENOSR\r\n: -ECOMM;\r\nelse if (t & SITD_STS_BABBLE)\r\ndesc->status = -EOVERFLOW;\r\nelse\r\ndesc->status = -EPROTO;\r\n} else {\r\ndesc->status = 0;\r\ndesc->actual_length = desc->length - SITD_LENGTH(t);\r\nurb->actual_length += desc->actual_length;\r\n}\r\nif ((urb_index + 1) != urb->number_of_packets)\r\ngoto done;\r\ndev = urb->dev;\r\nehci_urb_done(ehci, urb, 0);\r\nretval = true;\r\nurb = NULL;\r\n(void) disable_periodic(ehci);\r\nehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;\r\nif (ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs == 0) {\r\nif (ehci->amd_pll_fix == 1)\r\nusb_amd_quirk_pll_enable();\r\n}\r\nif (list_is_singular(&stream->td_list)) {\r\nehci_to_hcd(ehci)->self.bandwidth_allocated\r\n-= stream->bandwidth;\r\nehci_vdbg (ehci,\r\n"deschedule devp %s ep%d%s-iso\n",\r\ndev->devpath, stream->bEndpointAddress & 0x0f,\r\n(stream->bEndpointAddress & USB_DIR_IN) ? "in" : "out");\r\n}\r\niso_stream_put (ehci, stream);\r\ndone:\r\nsitd->urb = NULL;\r\nif (ehci->clock_frame != sitd->frame) {\r\nsitd->stream = NULL;\r\nlist_move(&sitd->sitd_list, &stream->free_list);\r\niso_stream_put(ehci, stream);\r\n} else {\r\nlist_move(&sitd->sitd_list, &ehci->cached_sitd_list);\r\nif (stream->refcount == 2) {\r\nstream->ep->hcpriv = NULL;\r\nstream->ep = NULL;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nint status = -EINVAL;\r\nunsigned long flags;\r\nstruct ehci_iso_stream *stream;\r\nstream = iso_stream_find (ehci, urb);\r\nif (stream == NULL) {\r\nehci_dbg (ehci, "can't get iso stream\n");\r\nreturn -ENOMEM;\r\n}\r\nif (urb->interval != stream->interval) {\r\nehci_dbg (ehci, "can't change iso interval %d --> %d\n",\r\nstream->interval, urb->interval);\r\ngoto done;\r\n}\r\n#ifdef EHCI_URB_TRACE\r\nehci_dbg (ehci,\r\n"submit %p dev%s ep%d%s-iso len %d\n",\r\nurb, urb->dev->devpath,\r\nusb_pipeendpoint (urb->pipe),\r\nusb_pipein (urb->pipe) ? "in" : "out",\r\nurb->transfer_buffer_length);\r\n#endif\r\nstatus = sitd_urb_transaction (stream, ehci, urb, mem_flags);\r\nif (status < 0) {\r\nehci_dbg (ehci, "can't init sitds\n");\r\ngoto done;\r\n}\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {\r\nstatus = -ESHUTDOWN;\r\ngoto done_not_linked;\r\n}\r\nstatus = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);\r\nif (unlikely(status))\r\ngoto done_not_linked;\r\nstatus = iso_stream_schedule(ehci, urb, stream);\r\nif (status == 0)\r\nsitd_link_urb (ehci, urb, ehci->periodic_size << 3, stream);\r\nelse\r\nusb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);\r\ndone_not_linked:\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\ndone:\r\nif (status < 0)\r\niso_stream_put (ehci, stream);\r\nreturn status;\r\n}\r\nstatic void free_cached_lists(struct ehci_hcd *ehci)\r\n{\r\nstruct ehci_itd *itd, *n;\r\nstruct ehci_sitd *sitd, *sn;\r\nlist_for_each_entry_safe(itd, n, &ehci->cached_itd_list, itd_list) {\r\nstruct ehci_iso_stream *stream = itd->stream;\r\nitd->stream = NULL;\r\nlist_move(&itd->itd_list, &stream->free_list);\r\niso_stream_put(ehci, stream);\r\n}\r\nlist_for_each_entry_safe(sitd, sn, &ehci->cached_sitd_list, sitd_list) {\r\nstruct ehci_iso_stream *stream = sitd->stream;\r\nsitd->stream = NULL;\r\nlist_move(&sitd->sitd_list, &stream->free_list);\r\niso_stream_put(ehci, stream);\r\n}\r\n}\r\nstatic void\r\nscan_periodic (struct ehci_hcd *ehci)\r\n{\r\nunsigned now_uframe, frame, clock, clock_frame, mod;\r\nunsigned modified;\r\nmod = ehci->periodic_size << 3;\r\nnow_uframe = ehci->next_uframe;\r\nif (ehci->rh_state == EHCI_RH_RUNNING) {\r\nclock = ehci_read_frame_index(ehci);\r\nclock_frame = (clock >> 3) & (ehci->periodic_size - 1);\r\n} else {\r\nclock = now_uframe + mod - 1;\r\nclock_frame = -1;\r\n}\r\nif (ehci->clock_frame != clock_frame) {\r\nfree_cached_lists(ehci);\r\nehci->clock_frame = clock_frame;\r\n}\r\nclock &= mod - 1;\r\nclock_frame = clock >> 3;\r\n++ehci->periodic_stamp;\r\nfor (;;) {\r\nunion ehci_shadow q, *q_p;\r\n__hc32 type, *hw_p;\r\nunsigned incomplete = false;\r\nframe = now_uframe >> 3;\r\nrestart:\r\nq_p = &ehci->pshadow [frame];\r\nhw_p = &ehci->periodic [frame];\r\nq.ptr = q_p->ptr;\r\ntype = Q_NEXT_TYPE(ehci, *hw_p);\r\nmodified = 0;\r\nwhile (q.ptr != NULL) {\r\nunsigned uf;\r\nunion ehci_shadow temp;\r\nint live;\r\nlive = (ehci->rh_state == EHCI_RH_RUNNING);\r\nswitch (hc32_to_cpu(ehci, type)) {\r\ncase Q_TYPE_QH:\r\ntemp.qh = qh_get (q.qh);\r\ntype = Q_NEXT_TYPE(ehci, q.qh->hw->hw_next);\r\nq = q.qh->qh_next;\r\nif (temp.qh->stamp != ehci->periodic_stamp) {\r\nmodified = qh_completions(ehci, temp.qh);\r\nif (!modified)\r\ntemp.qh->stamp = ehci->periodic_stamp;\r\nif (unlikely(list_empty(&temp.qh->qtd_list) ||\r\ntemp.qh->needs_rescan))\r\nintr_deschedule(ehci, temp.qh);\r\n}\r\nqh_put (temp.qh);\r\nbreak;\r\ncase Q_TYPE_FSTN:\r\nif (q.fstn->hw_prev != EHCI_LIST_END(ehci)) {\r\ndbg ("ignoring completions from FSTNs");\r\n}\r\ntype = Q_NEXT_TYPE(ehci, q.fstn->hw_next);\r\nq = q.fstn->fstn_next;\r\nbreak;\r\ncase Q_TYPE_ITD:\r\nif (frame == clock_frame && live) {\r\nrmb();\r\nfor (uf = 0; uf < 8; uf++) {\r\nif (q.itd->hw_transaction[uf] &\r\nITD_ACTIVE(ehci))\r\nbreak;\r\n}\r\nif (uf < 8) {\r\nincomplete = true;\r\nq_p = &q.itd->itd_next;\r\nhw_p = &q.itd->hw_next;\r\ntype = Q_NEXT_TYPE(ehci,\r\nq.itd->hw_next);\r\nq = *q_p;\r\nbreak;\r\n}\r\n}\r\n*q_p = q.itd->itd_next;\r\nif (!ehci->use_dummy_qh ||\r\nq.itd->hw_next != EHCI_LIST_END(ehci))\r\n*hw_p = q.itd->hw_next;\r\nelse\r\n*hw_p = ehci->dummy->qh_dma;\r\ntype = Q_NEXT_TYPE(ehci, q.itd->hw_next);\r\nwmb();\r\nmodified = itd_complete (ehci, q.itd);\r\nq = *q_p;\r\nbreak;\r\ncase Q_TYPE_SITD:\r\nif (((frame == clock_frame) ||\r\n(((frame + 1) & (ehci->periodic_size - 1))\r\n== clock_frame))\r\n&& live\r\n&& (q.sitd->hw_results &\r\nSITD_ACTIVE(ehci))) {\r\nincomplete = true;\r\nq_p = &q.sitd->sitd_next;\r\nhw_p = &q.sitd->hw_next;\r\ntype = Q_NEXT_TYPE(ehci,\r\nq.sitd->hw_next);\r\nq = *q_p;\r\nbreak;\r\n}\r\n*q_p = q.sitd->sitd_next;\r\nif (!ehci->use_dummy_qh ||\r\nq.sitd->hw_next != EHCI_LIST_END(ehci))\r\n*hw_p = q.sitd->hw_next;\r\nelse\r\n*hw_p = ehci->dummy->qh_dma;\r\ntype = Q_NEXT_TYPE(ehci, q.sitd->hw_next);\r\nwmb();\r\nmodified = sitd_complete (ehci, q.sitd);\r\nq = *q_p;\r\nbreak;\r\ndefault:\r\ndbg ("corrupt type %d frame %d shadow %p",\r\ntype, frame, q.ptr);\r\nq.ptr = NULL;\r\n}\r\nif (unlikely (modified)) {\r\nif (likely(ehci->periodic_sched > 0))\r\ngoto restart;\r\nnow_uframe = clock;\r\nbreak;\r\n}\r\n}\r\nif (incomplete && ehci->rh_state == EHCI_RH_RUNNING) {\r\nehci->next_uframe = now_uframe;\r\nbreak;\r\n}\r\nif (now_uframe == clock) {\r\nunsigned now;\r\nif (ehci->rh_state != EHCI_RH_RUNNING\r\n|| ehci->periodic_sched == 0)\r\nbreak;\r\nehci->next_uframe = now_uframe;\r\nnow = ehci_read_frame_index(ehci) & (mod - 1);\r\nif (now_uframe == now)\r\nbreak;\r\nclock = now;\r\nclock_frame = clock >> 3;\r\nif (ehci->clock_frame != clock_frame) {\r\nfree_cached_lists(ehci);\r\nehci->clock_frame = clock_frame;\r\n++ehci->periodic_stamp;\r\n}\r\n} else {\r\nnow_uframe++;\r\nnow_uframe &= mod - 1;\r\n}\r\n}\r\n}
