static void\r\nStartDecryption(struct boot_data *boot)\r\n{\r\nboot->Cryptor = CRYPT_STARTTERM;\r\n}\r\nstatic void\r\nDecryptBuf(struct boot_data *boot, int cnt)\r\n{\r\nunsigned char *bufp = boot->buf.BootBuf;\r\nwhile (cnt--) {\r\nboot->Cryptor = (boot->Cryptor >> 1) ^ ((boot->Cryptor & 1U) ? CRYPT_FEEDTERM : 0);\r\n*bufp++ ^= (unsigned char)boot->Cryptor;\r\n}\r\n}\r\nstatic int\r\npof_handle_data(hysdn_card * card, int datlen)\r\n{\r\nstruct boot_data *boot = card->boot;\r\nlong l;\r\nunsigned char *imgp;\r\nint img_len;\r\nswitch (boot->pof_recid) {\r\ncase TAG_TIMESTMP:\r\nif (card->debug_flags & LOG_POF_RECORD)\r\nhysdn_addlog(card, "POF created %s", boot->buf.PofTime.DateTimeText);\r\nbreak;\r\ncase TAG_CBOOTDTA:\r\nDecryptBuf(boot, datlen);\r\ncase TAG_BOOTDTA:\r\nif (card->debug_flags & LOG_POF_RECORD)\r\nhysdn_addlog(card, "POF got %s len=%d offs=0x%lx",\r\n(boot->pof_recid == TAG_CBOOTDTA) ? "CBOOTDATA" : "BOOTDTA",\r\ndatlen, boot->pof_recoffset);\r\nif (boot->pof_reclen != POF_BOOT_LOADER_TOTAL_SIZE) {\r\nboot->last_error = EPOF_BAD_IMG_SIZE;\r\nreturn (boot->last_error);\r\n}\r\nimgp = boot->buf.BootBuf;\r\nimg_len = datlen;\r\nl = POF_BOOT_LOADER_OFF_IN_PAGE -\r\n(boot->pof_recoffset & (POF_BOOT_LOADER_PAGE_SIZE - 1));\r\nif (l > 0) {\r\nimgp += l;\r\nimg_len -= l;\r\n}\r\nif (img_len > 0) {\r\nif ((boot->last_error =\r\ncard->writebootimg(card, imgp,\r\n(boot->pof_recoffset > POF_BOOT_LOADER_PAGE_SIZE) ? 2 : 0)) < 0)\r\nreturn (boot->last_error);\r\n}\r\nbreak;\r\ncase TAG_CABSDATA:\r\nDecryptBuf(boot, datlen);\r\ncase TAG_ABSDATA:\r\nif (card->debug_flags & LOG_POF_RECORD)\r\nhysdn_addlog(card, "POF got %s len=%d offs=0x%lx",\r\n(boot->pof_recid == TAG_CABSDATA) ? "CABSDATA" : "ABSDATA",\r\ndatlen, boot->pof_recoffset);\r\nif ((boot->last_error = card->writebootseq(card, boot->buf.BootBuf, datlen)) < 0)\r\nreturn (boot->last_error);\r\nif (boot->pof_recoffset + datlen >= boot->pof_reclen)\r\nreturn (card->waitpofready(card));\r\nbreak;\r\ndefault:\r\nif (card->debug_flags & LOG_POF_RECORD)\r\nhysdn_addlog(card, "POF got data(id=0x%lx) len=%d offs=0x%lx", boot->pof_recid,\r\ndatlen, boot->pof_recoffset);\r\nbreak;\r\n}\r\nreturn (0);\r\n}\r\nint\r\npof_write_buffer(hysdn_card * card, int datlen)\r\n{\r\nstruct boot_data *boot = card->boot;\r\nif (!boot)\r\nreturn (-EFAULT);\r\nif (boot->last_error < 0)\r\nreturn (boot->last_error);\r\nif (card->debug_flags & LOG_POF_WRITE)\r\nhysdn_addlog(card, "POF write: got %d bytes ", datlen);\r\nswitch (boot->pof_state) {\r\ncase POF_READ_FILE_HEAD:\r\nif (card->debug_flags & LOG_POF_WRITE)\r\nhysdn_addlog(card, "POF write: checking file header");\r\nif (datlen != sizeof(tPofFileHdr)) {\r\nboot->last_error = -EPOF_INTERNAL;\r\nbreak;\r\n}\r\nif (boot->buf.PofFileHdr.Magic != TAGFILEMAGIC) {\r\nboot->last_error = -EPOF_BAD_MAGIC;\r\nbreak;\r\n}\r\nboot->Nrecs = (unsigned short)(boot->buf.PofFileHdr.N_PofRecs);\r\nboot->pof_state = POF_READ_TAG_HEAD;\r\nboot->last_error = sizeof(tPofRecHdr);\r\nbreak;\r\ncase POF_READ_TAG_HEAD:\r\nif (card->debug_flags & LOG_POF_WRITE)\r\nhysdn_addlog(card, "POF write: checking tag header");\r\nif (datlen != sizeof(tPofRecHdr)) {\r\nboot->last_error = -EPOF_INTERNAL;\r\nbreak;\r\n}\r\nboot->pof_recid = boot->buf.PofRecHdr.PofRecId;\r\nboot->pof_reclen = boot->buf.PofRecHdr.PofRecDataLen;\r\nboot->pof_recoffset = 0;\r\nif (card->debug_flags & LOG_POF_RECORD)\r\nhysdn_addlog(card, "POF: got record id=0x%lx length=%ld ",\r\nboot->pof_recid, boot->pof_reclen);\r\nboot->pof_state = POF_READ_TAG_DATA;\r\nif (boot->pof_reclen < BOOT_BUF_SIZE)\r\nboot->last_error = boot->pof_reclen;\r\nelse\r\nboot->last_error = BOOT_BUF_SIZE;\r\nif (!boot->last_error) {\r\nboot->pof_state = POF_READ_TAG_HEAD;\r\nboot->last_error = sizeof(tPofRecHdr);\r\n}\r\nbreak;\r\ncase POF_READ_TAG_DATA:\r\nif (card->debug_flags & LOG_POF_WRITE)\r\nhysdn_addlog(card, "POF write: getting tag data");\r\nif (datlen != boot->last_error) {\r\nboot->last_error = -EPOF_INTERNAL;\r\nbreak;\r\n}\r\nif ((boot->last_error = pof_handle_data(card, datlen)) < 0)\r\nreturn (boot->last_error);\r\nboot->pof_recoffset += datlen;\r\nif (boot->pof_recoffset >= boot->pof_reclen) {\r\nboot->pof_state = POF_READ_TAG_HEAD;\r\nboot->last_error = sizeof(tPofRecHdr);\r\n} else {\r\nif (boot->pof_reclen - boot->pof_recoffset < BOOT_BUF_SIZE)\r\nboot->last_error = boot->pof_reclen - boot->pof_recoffset;\r\nelse\r\nboot->last_error = BOOT_BUF_SIZE;\r\n}\r\nbreak;\r\ndefault:\r\nboot->last_error = -EPOF_INTERNAL;\r\nbreak;\r\n}\r\nreturn (boot->last_error);\r\n}\r\nint\r\npof_write_open(hysdn_card * card, unsigned char **bufp)\r\n{\r\nstruct boot_data *boot;\r\nif (card->boot) {\r\nif (card->debug_flags & LOG_POF_OPEN)\r\nhysdn_addlog(card, "POF open: already opened for boot");\r\nreturn (-ERR_ALREADY_BOOT);\r\n}\r\nif (!(boot = kzalloc(sizeof(struct boot_data), GFP_KERNEL))) {\r\nif (card->debug_flags & LOG_MEM_ERR)\r\nhysdn_addlog(card, "POF open: unable to allocate mem");\r\nreturn (-EFAULT);\r\n}\r\ncard->boot = boot;\r\ncard->state = CARD_STATE_BOOTING;\r\ncard->stopcard(card);\r\nif (card->testram(card)) {\r\nif (card->debug_flags & LOG_POF_OPEN)\r\nhysdn_addlog(card, "POF open: DPRAM test failure");\r\nboot->last_error = -ERR_BOARD_DPRAM;\r\ncard->state = CARD_STATE_BOOTERR;\r\nreturn (boot->last_error);\r\n}\r\nboot->BufSize = 0;\r\nboot->pof_state = POF_READ_FILE_HEAD;\r\nStartDecryption(boot);\r\nif (card->debug_flags & LOG_POF_OPEN)\r\nhysdn_addlog(card, "POF open: success");\r\n*bufp = boot->buf.BootBuf;\r\nreturn (sizeof(tPofFileHdr));\r\n}\r\nint\r\npof_write_close(hysdn_card * card)\r\n{\r\nstruct boot_data *boot = card->boot;\r\nif (!boot)\r\nreturn (-EFAULT);\r\ncard->boot = NULL;\r\nkfree(boot);\r\nif (card->state == CARD_STATE_RUN)\r\ncard->set_errlog_state(card, 1);\r\nif (card->debug_flags & LOG_POF_OPEN)\r\nhysdn_addlog(card, "POF close: success");\r\nreturn (0);\r\n}\r\nint\r\nEvalSysrTokData(hysdn_card *card, unsigned char *cp, int len)\r\n{\r\nu_char *p;\r\nu_char crc;\r\nif (card->debug_flags & LOG_POF_RECORD)\r\nhysdn_addlog(card, "SysReady Token data length %d", len);\r\nif (len < 2) {\r\nhysdn_addlog(card, "SysReady Token Data to short");\r\nreturn (1);\r\n}\r\nfor (p = cp, crc = 0; p < (cp + len - 2); p++)\r\nif ((crc & 0x80))\r\ncrc = (((u_char) (crc << 1)) + 1) + *p;\r\nelse\r\ncrc = ((u_char) (crc << 1)) + *p;\r\ncrc = ~crc;\r\nif (crc != *(cp + len - 1)) {\r\nhysdn_addlog(card, "SysReady Token Data invalid CRC");\r\nreturn (1);\r\n}\r\nlen--;\r\nwhile (len > 0) {\r\nif (*cp == SYSR_TOK_END)\r\nreturn (0);\r\nif (len < (*(cp + 1) + 2)) {\r\nhysdn_addlog(card, "token 0x%x invalid length %d", *cp, *(cp + 1));\r\nreturn (1);\r\n}\r\nswitch (*cp) {\r\ncase SYSR_TOK_B_CHAN:\r\nif (*(cp + 1) != 1)\r\nreturn (1);\r\ncard->bchans = *(cp + 2);\r\nbreak;\r\ncase SYSR_TOK_FAX_CHAN:\r\nif (*(cp + 1) != 1)\r\nreturn (1);\r\ncard->faxchans = *(cp + 2);\r\nbreak;\r\ncase SYSR_TOK_MAC_ADDR:\r\nif (*(cp + 1) != 6)\r\nreturn (1);\r\nmemcpy(card->mac_addr, cp + 2, 6);\r\nbreak;\r\ndefault:\r\nhysdn_addlog(card, "unknown token 0x%02x length %d", *cp, *(cp + 1));\r\nbreak;\r\n}\r\nlen -= (*(cp + 1) + 2);\r\ncp += (*(cp + 1) + 2);\r\n}\r\nhysdn_addlog(card, "no end token found");\r\nreturn (1);\r\n}
