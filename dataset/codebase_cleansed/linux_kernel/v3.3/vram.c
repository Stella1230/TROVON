static inline int region_mem_type(unsigned long paddr)\r\n{\r\nif (paddr >= OMAP2_SRAM_START &&\r\npaddr < OMAP2_SRAM_START + OMAP2_SRAM_SIZE)\r\nreturn OMAP_VRAM_MEMTYPE_SRAM;\r\nelse\r\nreturn OMAP_VRAM_MEMTYPE_SDRAM;\r\n}\r\nstatic struct vram_region *omap_vram_create_region(unsigned long paddr,\r\nunsigned pages)\r\n{\r\nstruct vram_region *rm;\r\nrm = kzalloc(sizeof(*rm), GFP_KERNEL);\r\nif (rm) {\r\nINIT_LIST_HEAD(&rm->alloc_list);\r\nrm->paddr = paddr;\r\nrm->pages = pages;\r\n}\r\nreturn rm;\r\n}\r\nstatic struct vram_alloc *omap_vram_create_allocation(struct vram_region *vr,\r\nunsigned long paddr, unsigned pages)\r\n{\r\nstruct vram_alloc *va;\r\nstruct vram_alloc *new;\r\nnew = kzalloc(sizeof(*va), GFP_KERNEL);\r\nif (!new)\r\nreturn NULL;\r\nnew->paddr = paddr;\r\nnew->pages = pages;\r\nlist_for_each_entry(va, &vr->alloc_list, list) {\r\nif (va->paddr > new->paddr)\r\nbreak;\r\n}\r\nlist_add_tail(&new->list, &va->list);\r\nreturn new;\r\n}\r\nstatic void omap_vram_free_allocation(struct vram_alloc *va)\r\n{\r\nlist_del(&va->list);\r\nkfree(va);\r\n}\r\nint omap_vram_add_region(unsigned long paddr, size_t size)\r\n{\r\nstruct vram_region *rm;\r\nunsigned pages;\r\nif (vram_initialized) {\r\nDBG("adding region paddr %08lx size %d\n",\r\npaddr, size);\r\nsize &= PAGE_MASK;\r\npages = size >> PAGE_SHIFT;\r\nrm = omap_vram_create_region(paddr, pages);\r\nif (rm == NULL)\r\nreturn -ENOMEM;\r\nlist_add(&rm->list, &region_list);\r\n} else {\r\nif (postponed_cnt == MAX_POSTPONED_REGIONS)\r\nreturn -ENOMEM;\r\npostponed_regions[postponed_cnt].paddr = paddr;\r\npostponed_regions[postponed_cnt].size = size;\r\n++postponed_cnt;\r\n}\r\nreturn 0;\r\n}\r\nint omap_vram_free(unsigned long paddr, size_t size)\r\n{\r\nstruct vram_region *rm;\r\nstruct vram_alloc *alloc;\r\nunsigned start, end;\r\nDBG("free mem paddr %08lx size %d\n", paddr, size);\r\nsize = PAGE_ALIGN(size);\r\nmutex_lock(&region_mutex);\r\nlist_for_each_entry(rm, &region_list, list) {\r\nlist_for_each_entry(alloc, &rm->alloc_list, list) {\r\nstart = alloc->paddr;\r\nend = alloc->paddr + (alloc->pages >> PAGE_SHIFT);\r\nif (start >= paddr && end < paddr + size)\r\ngoto found;\r\n}\r\n}\r\nmutex_unlock(&region_mutex);\r\nreturn -EINVAL;\r\nfound:\r\nomap_vram_free_allocation(alloc);\r\nmutex_unlock(&region_mutex);\r\nreturn 0;\r\n}\r\nstatic int _omap_vram_reserve(unsigned long paddr, unsigned pages)\r\n{\r\nstruct vram_region *rm;\r\nstruct vram_alloc *alloc;\r\nsize_t size;\r\nsize = pages << PAGE_SHIFT;\r\nlist_for_each_entry(rm, &region_list, list) {\r\nunsigned long start, end;\r\nDBG("checking region %lx %d\n", rm->paddr, rm->pages);\r\nif (region_mem_type(rm->paddr) != region_mem_type(paddr))\r\ncontinue;\r\nstart = rm->paddr;\r\nend = start + (rm->pages << PAGE_SHIFT) - 1;\r\nif (start > paddr || end < paddr + size - 1)\r\ncontinue;\r\nDBG("block ok, checking allocs\n");\r\nlist_for_each_entry(alloc, &rm->alloc_list, list) {\r\nend = alloc->paddr - 1;\r\nif (start <= paddr && end >= paddr + size - 1)\r\ngoto found;\r\nstart = alloc->paddr + (alloc->pages << PAGE_SHIFT);\r\n}\r\nend = rm->paddr + (rm->pages << PAGE_SHIFT) - 1;\r\nif (!(start <= paddr && end >= paddr + size - 1))\r\ncontinue;\r\nfound:\r\nDBG("found area start %lx, end %lx\n", start, end);\r\nif (omap_vram_create_allocation(rm, paddr, pages) == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nint omap_vram_reserve(unsigned long paddr, size_t size)\r\n{\r\nunsigned pages;\r\nint r;\r\nDBG("reserve mem paddr %08lx size %d\n", paddr, size);\r\nsize = PAGE_ALIGN(size);\r\npages = size >> PAGE_SHIFT;\r\nmutex_lock(&region_mutex);\r\nr = _omap_vram_reserve(paddr, pages);\r\nmutex_unlock(&region_mutex);\r\nreturn r;\r\n}\r\nstatic void _omap_vram_dma_cb(int lch, u16 ch_status, void *data)\r\n{\r\nstruct completion *compl = data;\r\ncomplete(compl);\r\n}\r\nstatic int _omap_vram_clear(u32 paddr, unsigned pages)\r\n{\r\nstruct completion compl;\r\nunsigned elem_count;\r\nunsigned frame_count;\r\nint r;\r\nint lch;\r\ninit_completion(&compl);\r\nr = omap_request_dma(OMAP_DMA_NO_DEVICE, "VRAM DMA",\r\n_omap_vram_dma_cb,\r\n&compl, &lch);\r\nif (r) {\r\npr_err("VRAM: request_dma failed for memory clear\n");\r\nreturn -EBUSY;\r\n}\r\nelem_count = pages * PAGE_SIZE / 4;\r\nframe_count = 1;\r\nomap_set_dma_transfer_params(lch, OMAP_DMA_DATA_TYPE_S32,\r\nelem_count, frame_count,\r\nOMAP_DMA_SYNC_ELEMENT,\r\n0, 0);\r\nomap_set_dma_dest_params(lch, 0, OMAP_DMA_AMODE_POST_INC,\r\npaddr, 0, 0);\r\nomap_set_dma_color_mode(lch, OMAP_DMA_CONSTANT_FILL, 0x000000);\r\nomap_start_dma(lch);\r\nif (wait_for_completion_timeout(&compl, msecs_to_jiffies(1000)) == 0) {\r\nomap_stop_dma(lch);\r\npr_err("VRAM: dma timeout while clearing memory\n");\r\nr = -EIO;\r\ngoto err;\r\n}\r\nr = 0;\r\nerr:\r\nomap_free_dma(lch);\r\nreturn r;\r\n}\r\nstatic int _omap_vram_alloc(int mtype, unsigned pages, unsigned long *paddr)\r\n{\r\nstruct vram_region *rm;\r\nstruct vram_alloc *alloc;\r\nlist_for_each_entry(rm, &region_list, list) {\r\nunsigned long start, end;\r\nDBG("checking region %lx %d\n", rm->paddr, rm->pages);\r\nif (region_mem_type(rm->paddr) != mtype)\r\ncontinue;\r\nstart = rm->paddr;\r\nlist_for_each_entry(alloc, &rm->alloc_list, list) {\r\nend = alloc->paddr;\r\nif (end - start >= pages << PAGE_SHIFT)\r\ngoto found;\r\nstart = alloc->paddr + (alloc->pages << PAGE_SHIFT);\r\n}\r\nend = rm->paddr + (rm->pages << PAGE_SHIFT);\r\nfound:\r\nif (end - start < pages << PAGE_SHIFT)\r\ncontinue;\r\nDBG("found %lx, end %lx\n", start, end);\r\nalloc = omap_vram_create_allocation(rm, start, pages);\r\nif (alloc == NULL)\r\nreturn -ENOMEM;\r\n*paddr = start;\r\n_omap_vram_clear(start, pages);\r\nreturn 0;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nint omap_vram_alloc(int mtype, size_t size, unsigned long *paddr)\r\n{\r\nunsigned pages;\r\nint r;\r\nBUG_ON(mtype > OMAP_VRAM_MEMTYPE_MAX || !size);\r\nDBG("alloc mem type %d size %d\n", mtype, size);\r\nsize = PAGE_ALIGN(size);\r\npages = size >> PAGE_SHIFT;\r\nmutex_lock(&region_mutex);\r\nr = _omap_vram_alloc(mtype, pages, paddr);\r\nmutex_unlock(&region_mutex);\r\nreturn r;\r\n}\r\nvoid omap_vram_get_info(unsigned long *vram,\r\nunsigned long *free_vram,\r\nunsigned long *largest_free_block)\r\n{\r\nstruct vram_region *vr;\r\nstruct vram_alloc *va;\r\n*vram = 0;\r\n*free_vram = 0;\r\n*largest_free_block = 0;\r\nmutex_lock(&region_mutex);\r\nlist_for_each_entry(vr, &region_list, list) {\r\nunsigned free;\r\nunsigned long pa;\r\npa = vr->paddr;\r\n*vram += vr->pages << PAGE_SHIFT;\r\nlist_for_each_entry(va, &vr->alloc_list, list) {\r\nfree = va->paddr - pa;\r\n*free_vram += free;\r\nif (free > *largest_free_block)\r\n*largest_free_block = free;\r\npa = va->paddr + (va->pages << PAGE_SHIFT);\r\n}\r\nfree = vr->paddr + (vr->pages << PAGE_SHIFT) - pa;\r\n*free_vram += free;\r\nif (free > *largest_free_block)\r\n*largest_free_block = free;\r\n}\r\nmutex_unlock(&region_mutex);\r\n}\r\nstatic int vram_debug_show(struct seq_file *s, void *unused)\r\n{\r\nstruct vram_region *vr;\r\nstruct vram_alloc *va;\r\nunsigned size;\r\nmutex_lock(&region_mutex);\r\nlist_for_each_entry(vr, &region_list, list) {\r\nsize = vr->pages << PAGE_SHIFT;\r\nseq_printf(s, "%08lx-%08lx (%d bytes)\n",\r\nvr->paddr, vr->paddr + size - 1,\r\nsize);\r\nlist_for_each_entry(va, &vr->alloc_list, list) {\r\nsize = va->pages << PAGE_SHIFT;\r\nseq_printf(s, " %08lx-%08lx (%d bytes)\n",\r\nva->paddr, va->paddr + size - 1,\r\nsize);\r\n}\r\n}\r\nmutex_unlock(&region_mutex);\r\nreturn 0;\r\n}\r\nstatic int vram_debug_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, vram_debug_show, inode->i_private);\r\n}\r\nstatic int __init omap_vram_create_debugfs(void)\r\n{\r\nstruct dentry *d;\r\nd = debugfs_create_file("vram", S_IRUGO, NULL,\r\nNULL, &vram_debug_fops);\r\nif (IS_ERR(d))\r\nreturn PTR_ERR(d);\r\nreturn 0;\r\n}\r\nstatic __init int omap_vram_init(void)\r\n{\r\nint i;\r\nvram_initialized = 1;\r\nfor (i = 0; i < postponed_cnt; i++)\r\nomap_vram_add_region(postponed_regions[i].paddr,\r\npostponed_regions[i].size);\r\n#ifdef CONFIG_DEBUG_FS\r\nif (omap_vram_create_debugfs())\r\npr_err("VRAM: Failed to create debugfs file\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __init omap_vram_early_vram(char *p)\r\n{\r\nomap_vram_def_sdram_size = memparse(p, &p);\r\nif (*p == ',')\r\nomap_vram_def_sdram_start = simple_strtoul(p + 1, &p, 16);\r\nreturn 0;\r\n}\r\nvoid __init omap_vram_reserve_sdram_memblock(void)\r\n{\r\nu32 paddr;\r\nu32 size = 0;\r\nif (omap_vram_def_sdram_size) {\r\nsize = omap_vram_def_sdram_size;\r\npaddr = omap_vram_def_sdram_start;\r\n}\r\nif (!size) {\r\nsize = omap_vram_sdram_size;\r\npaddr = omap_vram_sdram_start;\r\n}\r\n#ifdef CONFIG_OMAP2_VRAM_SIZE\r\nif (!size) {\r\nsize = CONFIG_OMAP2_VRAM_SIZE * 1024 * 1024;\r\npaddr = 0;\r\n}\r\n#endif\r\nif (!size)\r\nreturn;\r\nsize = ALIGN(size, SZ_2M);\r\nif (paddr) {\r\nif (paddr & ~PAGE_MASK) {\r\npr_err("VRAM start address 0x%08x not page aligned\n",\r\npaddr);\r\nreturn;\r\n}\r\nif (!memblock_is_region_memory(paddr, size)) {\r\npr_err("Illegal SDRAM region 0x%08x..0x%08x for VRAM\n",\r\npaddr, paddr + size - 1);\r\nreturn;\r\n}\r\nif (memblock_is_region_reserved(paddr, size)) {\r\npr_err("FB: failed to reserve VRAM - busy\n");\r\nreturn;\r\n}\r\nif (memblock_reserve(paddr, size) < 0) {\r\npr_err("FB: failed to reserve VRAM - no memory\n");\r\nreturn;\r\n}\r\n} else {\r\npaddr = memblock_alloc(size, SZ_2M);\r\n}\r\nmemblock_free(paddr, size);\r\nmemblock_remove(paddr, size);\r\nomap_vram_add_region(paddr, size);\r\npr_info("Reserving %u bytes SDRAM for VRAM\n", size);\r\n}\r\nunsigned long __init omap_vram_reserve_sram(unsigned long sram_pstart,\r\nunsigned long sram_vstart,\r\nunsigned long sram_size,\r\nunsigned long pstart_avail,\r\nunsigned long size_avail)\r\n{\r\nunsigned long pend_avail;\r\nunsigned long reserved;\r\nu32 paddr;\r\nu32 size;\r\npaddr = omap_vram_sram_start;\r\nsize = omap_vram_sram_size;\r\nif (!size)\r\nreturn 0;\r\nreserved = 0;\r\npend_avail = pstart_avail + size_avail;\r\nif (!paddr) {\r\nif ((size_avail & PAGE_MASK) < size) {\r\npr_err("Not enough SRAM for VRAM\n");\r\nreturn 0;\r\n}\r\nsize_avail = (size_avail - size) & PAGE_MASK;\r\npaddr = pstart_avail + size_avail;\r\n}\r\nif (paddr < sram_pstart ||\r\npaddr + size > sram_pstart + sram_size) {\r\npr_err("Illegal SRAM region for VRAM\n");\r\nreturn 0;\r\n}\r\nif (pend_avail - paddr > reserved)\r\nreserved = pend_avail - paddr;\r\nsize_avail = pend_avail - reserved - pstart_avail;\r\nomap_vram_add_region(paddr, size);\r\nif (reserved)\r\npr_info("Reserving %lu bytes SRAM for VRAM\n", reserved);\r\nreturn reserved;\r\n}\r\nvoid __init omap_vram_set_sdram_vram(u32 size, u32 start)\r\n{\r\nomap_vram_sdram_start = start;\r\nomap_vram_sdram_size = size;\r\n}\r\nvoid __init omap_vram_set_sram_vram(u32 size, u32 start)\r\n{\r\nomap_vram_sram_start = start;\r\nomap_vram_sram_size = size;\r\n}
