static inline struct noon010_info *to_noon010(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct noon010_info, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct noon010_info, hdl)->sd;\r\n}\r\nstatic inline int set_i2c_page(struct noon010_info *info,\r\nstruct i2c_client *client, unsigned int reg)\r\n{\r\nu32 page = reg >> 8 & 0xFF;\r\nint ret = 0;\r\nif (info->i2c_reg_page != page && (reg & 0xFF) != 0x03) {\r\nret = i2c_smbus_write_byte_data(client, PAGEMODE_REG, page);\r\nif (!ret)\r\ninfo->i2c_reg_page = page;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cam_i2c_read(struct v4l2_subdev *sd, u32 reg_addr)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct noon010_info *info = to_noon010(sd);\r\nint ret = set_i2c_page(info, client, reg_addr);\r\nif (ret)\r\nreturn ret;\r\nreturn i2c_smbus_read_byte_data(client, reg_addr & 0xFF);\r\n}\r\nstatic int cam_i2c_write(struct v4l2_subdev *sd, u32 reg_addr, u32 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct noon010_info *info = to_noon010(sd);\r\nint ret = set_i2c_page(info, client, reg_addr);\r\nif (ret)\r\nreturn ret;\r\nreturn i2c_smbus_write_byte_data(client, reg_addr & 0xFF, val);\r\n}\r\nstatic inline int noon010_bulk_write_reg(struct v4l2_subdev *sd,\r\nconst struct i2c_regval *msg)\r\n{\r\nwhile (msg->addr != REG_TERM) {\r\nint ret = cam_i2c_write(sd, msg->addr, msg->val);\r\nif (ret)\r\nreturn ret;\r\nmsg++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int noon010_power_ctrl(struct v4l2_subdev *sd, bool reset, bool sleep)\r\n{\r\nstruct noon010_info *info = to_noon010(sd);\r\nu8 reg = sleep ? 0xF1 : 0xF0;\r\nint ret = 0;\r\nif (reset) {\r\nret = cam_i2c_write(sd, POWER_CTRL_REG, reg | 0x02);\r\nudelay(20);\r\n}\r\nif (!ret) {\r\nret = cam_i2c_write(sd, POWER_CTRL_REG, reg);\r\nif (reset && !ret)\r\ninfo->i2c_reg_page = -1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int noon010_enable_autowhitebalance(struct v4l2_subdev *sd, int on)\r\n{\r\nint ret;\r\nret = cam_i2c_write(sd, AWB_CTL_REG(1), on ? 0x2E : 0x2F);\r\nif (!ret)\r\nret = cam_i2c_write(sd, AWB_CTL_REG(0), on ? 0xFB : 0x7B);\r\nreturn ret;\r\n}\r\nstatic int noon010_set_flip(struct v4l2_subdev *sd, int hflip, int vflip)\r\n{\r\nstruct noon010_info *info = to_noon010(sd);\r\nint reg, ret;\r\nreg = cam_i2c_read(sd, VDO_CTL_REG(1));\r\nif (reg < 0)\r\nreturn reg;\r\nreg &= 0x7C;\r\nif (hflip)\r\nreg |= 0x01;\r\nif (vflip)\r\nreg |= 0x02;\r\nret = cam_i2c_write(sd, VDO_CTL_REG(1), reg | 0x80);\r\nif (!ret) {\r\ninfo->hflip = hflip;\r\ninfo->vflip = vflip;\r\n}\r\nreturn ret;\r\n}\r\nstatic int noon010_set_params(struct v4l2_subdev *sd)\r\n{\r\nstruct noon010_info *info = to_noon010(sd);\r\nint ret = cam_i2c_write(sd, VDO_CTL_REG(0),\r\ninfo->curr_win->vid_ctl1);\r\nif (ret)\r\nreturn ret;\r\nreturn cam_i2c_write(sd, ISP_CTL_REG(0),\r\ninfo->curr_fmt->ispctl1_reg);\r\n}\r\nstatic int noon010_try_frame_size(struct v4l2_mbus_framefmt *mf,\r\nconst struct noon010_frmsize **size)\r\n{\r\nunsigned int min_err = ~0;\r\nint i = ARRAY_SIZE(noon010_sizes);\r\nconst struct noon010_frmsize *fsize = &noon010_sizes[0],\r\n*match = NULL;\r\nwhile (i--) {\r\nint err = abs(fsize->width - mf->width)\r\n+ abs(fsize->height - mf->height);\r\nif (err < min_err) {\r\nmin_err = err;\r\nmatch = fsize;\r\n}\r\nfsize++;\r\n}\r\nif (match) {\r\nmf->width = match->width;\r\nmf->height = match->height;\r\nif (size)\r\n*size = match;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int power_enable(struct noon010_info *info)\r\n{\r\nint ret;\r\nif (info->power) {\r\nv4l2_info(&info->sd, "%s: sensor is already on\n", __func__);\r\nreturn 0;\r\n}\r\nif (gpio_is_valid(info->gpio_nstby))\r\ngpio_set_value(info->gpio_nstby, 0);\r\nif (gpio_is_valid(info->gpio_nreset))\r\ngpio_set_value(info->gpio_nreset, 0);\r\nret = regulator_bulk_enable(NOON010_NUM_SUPPLIES, info->supply);\r\nif (ret)\r\nreturn ret;\r\nif (gpio_is_valid(info->gpio_nreset)) {\r\nmsleep(50);\r\ngpio_set_value(info->gpio_nreset, 1);\r\n}\r\nif (gpio_is_valid(info->gpio_nstby)) {\r\nudelay(1000);\r\ngpio_set_value(info->gpio_nstby, 1);\r\n}\r\nif (gpio_is_valid(info->gpio_nreset)) {\r\nudelay(1000);\r\ngpio_set_value(info->gpio_nreset, 0);\r\nmsleep(100);\r\ngpio_set_value(info->gpio_nreset, 1);\r\nmsleep(20);\r\n}\r\ninfo->power = 1;\r\nv4l2_dbg(1, debug, &info->sd, "%s: sensor is on\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int power_disable(struct noon010_info *info)\r\n{\r\nint ret;\r\nif (!info->power) {\r\nv4l2_info(&info->sd, "%s: sensor is already off\n", __func__);\r\nreturn 0;\r\n}\r\nret = regulator_bulk_disable(NOON010_NUM_SUPPLIES, info->supply);\r\nif (ret)\r\nreturn ret;\r\nif (gpio_is_valid(info->gpio_nstby))\r\ngpio_set_value(info->gpio_nstby, 0);\r\nif (gpio_is_valid(info->gpio_nreset))\r\ngpio_set_value(info->gpio_nreset, 0);\r\ninfo->power = 0;\r\nv4l2_dbg(1, debug, &info->sd, "%s: sensor is off\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int noon010_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct noon010_info *info = to_noon010(sd);\r\nint ret = 0;\r\nv4l2_dbg(1, debug, sd, "%s: ctrl_id: %d, value: %d\n",\r\n__func__, ctrl->id, ctrl->val);\r\nmutex_lock(&info->lock);\r\nif (!info->power)\r\ngoto unlock;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\nret = noon010_enable_autowhitebalance(sd, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_BLUE_BALANCE:\r\nret = cam_i2c_write(sd, MWB_BGAIN_REG, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_RED_BALANCE:\r\nret = cam_i2c_write(sd, MWB_RGAIN_REG, ctrl->val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nunlock:\r\nmutex_unlock(&info->lock);\r\nreturn ret;\r\n}\r\nstatic int noon010_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index >= ARRAY_SIZE(noon010_formats))\r\nreturn -EINVAL;\r\ncode->code = noon010_formats[code->index].code;\r\nreturn 0;\r\n}\r\nstatic int noon010_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct noon010_info *info = to_noon010(sd);\r\nstruct v4l2_mbus_framefmt *mf;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nif (fh) {\r\nmf = v4l2_subdev_get_try_format(fh, 0);\r\nfmt->format = *mf;\r\n}\r\nreturn 0;\r\n}\r\nmf = &fmt->format;\r\nmutex_lock(&info->lock);\r\nmf->width = info->curr_win->width;\r\nmf->height = info->curr_win->height;\r\nmf->code = info->curr_fmt->code;\r\nmf->colorspace = info->curr_fmt->colorspace;\r\nmf->field = V4L2_FIELD_NONE;\r\nmutex_unlock(&info->lock);\r\nreturn 0;\r\n}\r\nstatic const struct noon010_format *noon010_try_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nint i = ARRAY_SIZE(noon010_formats);\r\nwhile (--i)\r\nif (mf->code == noon010_formats[i].code)\r\nbreak;\r\nmf->code = noon010_formats[i].code;\r\nreturn &noon010_formats[i];\r\n}\r\nstatic int noon010_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct noon010_info *info = to_noon010(sd);\r\nconst struct noon010_frmsize *size = NULL;\r\nconst struct noon010_format *nf;\r\nstruct v4l2_mbus_framefmt *mf;\r\nint ret = 0;\r\nnf = noon010_try_fmt(sd, &fmt->format);\r\nnoon010_try_frame_size(&fmt->format, &size);\r\nfmt->format.colorspace = V4L2_COLORSPACE_JPEG;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nif (fh) {\r\nmf = v4l2_subdev_get_try_format(fh, 0);\r\n*mf = fmt->format;\r\n}\r\nreturn 0;\r\n}\r\nmutex_lock(&info->lock);\r\nif (!info->streaming) {\r\ninfo->apply_new_cfg = 1;\r\ninfo->curr_fmt = nf;\r\ninfo->curr_win = size;\r\n} else {\r\nret = -EBUSY;\r\n}\r\nmutex_unlock(&info->lock);\r\nreturn ret;\r\n}\r\nstatic int noon010_base_config(struct v4l2_subdev *sd)\r\n{\r\nint ret = noon010_bulk_write_reg(sd, noon010_base_regs);\r\nif (!ret)\r\nret = noon010_set_params(sd);\r\nif (!ret)\r\nret = noon010_set_flip(sd, 1, 0);\r\nreturn ret;\r\n}\r\nstatic int noon010_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct noon010_info *info = to_noon010(sd);\r\nint ret;\r\nmutex_lock(&info->lock);\r\nif (on) {\r\nret = power_enable(info);\r\nif (!ret)\r\nret = noon010_base_config(sd);\r\n} else {\r\nnoon010_power_ctrl(sd, false, true);\r\nret = power_disable(info);\r\n}\r\nmutex_unlock(&info->lock);\r\nif (!ret && on)\r\nret = v4l2_ctrl_handler_setup(&info->hdl);\r\nreturn ret;\r\n}\r\nstatic int noon010_s_stream(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct noon010_info *info = to_noon010(sd);\r\nint ret = 0;\r\nmutex_lock(&info->lock);\r\nif (!info->streaming != !on) {\r\nret = noon010_power_ctrl(sd, false, !on);\r\nif (!ret)\r\ninfo->streaming = on;\r\n}\r\nif (!ret && on && info->apply_new_cfg) {\r\nret = noon010_set_params(sd);\r\nif (!ret)\r\ninfo->apply_new_cfg = 0;\r\n}\r\nmutex_unlock(&info->lock);\r\nreturn ret;\r\n}\r\nstatic int noon010_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct noon010_info *info = to_noon010(sd);\r\nv4l2_ctrl_handler_log_status(&info->hdl, sd->name);\r\nreturn 0;\r\n}\r\nstatic int noon010_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = v4l2_subdev_get_try_format(fh, 0);\r\nmf->width = noon010_sizes[0].width;\r\nmf->height = noon010_sizes[0].height;\r\nmf->code = noon010_formats[0].code;\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int noon010_detect(struct i2c_client *client, struct noon010_info *info)\r\n{\r\nint ret;\r\nret = power_enable(info);\r\nif (ret)\r\nreturn ret;\r\nret = i2c_smbus_read_byte_data(client, DEVICE_ID_REG);\r\nif (ret < 0)\r\ndev_err(&client->dev, "I2C read failed: 0x%X\n", ret);\r\npower_disable(info);\r\nreturn ret == NOON010PC30_ID ? 0 : -ENODEV;\r\n}\r\nstatic int noon010_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct noon010_info *info;\r\nstruct v4l2_subdev *sd;\r\nconst struct noon010pc30_platform_data *pdata\r\n= client->dev.platform_data;\r\nint ret;\r\nint i;\r\nif (!pdata) {\r\ndev_err(&client->dev, "No platform data!\n");\r\nreturn -EIO;\r\n}\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nmutex_init(&info->lock);\r\nsd = &info->sd;\r\nstrlcpy(sd->name, MODULE_NAME, sizeof(sd->name));\r\nv4l2_i2c_subdev_init(sd, client, &noon010_ops);\r\nsd->internal_ops = &noon010_subdev_internal_ops;\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nv4l2_ctrl_handler_init(&info->hdl, 3);\r\nv4l2_ctrl_new_std(&info->hdl, &noon010_ctrl_ops,\r\nV4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 1);\r\nv4l2_ctrl_new_std(&info->hdl, &noon010_ctrl_ops,\r\nV4L2_CID_RED_BALANCE, 0, 127, 1, 64);\r\nv4l2_ctrl_new_std(&info->hdl, &noon010_ctrl_ops,\r\nV4L2_CID_BLUE_BALANCE, 0, 127, 1, 64);\r\nsd->ctrl_handler = &info->hdl;\r\nret = info->hdl.error;\r\nif (ret)\r\ngoto np_err;\r\ninfo->i2c_reg_page = -1;\r\ninfo->gpio_nreset = -EINVAL;\r\ninfo->gpio_nstby = -EINVAL;\r\ninfo->curr_fmt = &noon010_formats[0];\r\ninfo->curr_win = &noon010_sizes[0];\r\nif (gpio_is_valid(pdata->gpio_nreset)) {\r\nret = gpio_request(pdata->gpio_nreset, "NOON010PC30 NRST");\r\nif (ret) {\r\ndev_err(&client->dev, "GPIO request error: %d\n", ret);\r\ngoto np_err;\r\n}\r\ninfo->gpio_nreset = pdata->gpio_nreset;\r\ngpio_direction_output(info->gpio_nreset, 0);\r\ngpio_export(info->gpio_nreset, 0);\r\n}\r\nif (gpio_is_valid(pdata->gpio_nstby)) {\r\nret = gpio_request(pdata->gpio_nstby, "NOON010PC30 NSTBY");\r\nif (ret) {\r\ndev_err(&client->dev, "GPIO request error: %d\n", ret);\r\ngoto np_gpio_err;\r\n}\r\ninfo->gpio_nstby = pdata->gpio_nstby;\r\ngpio_direction_output(info->gpio_nstby, 0);\r\ngpio_export(info->gpio_nstby, 0);\r\n}\r\nfor (i = 0; i < NOON010_NUM_SUPPLIES; i++)\r\ninfo->supply[i].supply = noon010_supply_name[i];\r\nret = regulator_bulk_get(&client->dev, NOON010_NUM_SUPPLIES,\r\ninfo->supply);\r\nif (ret)\r\ngoto np_reg_err;\r\ninfo->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nsd->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;\r\nret = media_entity_init(&sd->entity, 1, &info->pad, 0);\r\nif (ret < 0)\r\ngoto np_me_err;\r\nret = noon010_detect(client, info);\r\nif (!ret)\r\nreturn 0;\r\nnp_me_err:\r\nregulator_bulk_free(NOON010_NUM_SUPPLIES, info->supply);\r\nnp_reg_err:\r\nif (gpio_is_valid(info->gpio_nstby))\r\ngpio_free(info->gpio_nstby);\r\nnp_gpio_err:\r\nif (gpio_is_valid(info->gpio_nreset))\r\ngpio_free(info->gpio_nreset);\r\nnp_err:\r\nv4l2_ctrl_handler_free(&info->hdl);\r\nv4l2_device_unregister_subdev(sd);\r\nkfree(info);\r\nreturn ret;\r\n}\r\nstatic int noon010_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct noon010_info *info = to_noon010(sd);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&info->hdl);\r\nregulator_bulk_free(NOON010_NUM_SUPPLIES, info->supply);\r\nif (gpio_is_valid(info->gpio_nreset))\r\ngpio_free(info->gpio_nreset);\r\nif (gpio_is_valid(info->gpio_nstby))\r\ngpio_free(info->gpio_nstby);\r\nmedia_entity_cleanup(&sd->entity);\r\nkfree(info);\r\nreturn 0;\r\n}\r\nstatic int __init noon010_init(void)\r\n{\r\nreturn i2c_add_driver(&noon010_i2c_driver);\r\n}\r\nstatic void __exit noon010_exit(void)\r\n{\r\ni2c_del_driver(&noon010_i2c_driver);\r\n}
