static void\r\ndcssblk_release_segment(struct device *dev)\r\n{\r\nstruct dcssblk_dev_info *dev_info;\r\nstruct segment_info *entry, *temp;\r\ndev_info = container_of(dev, struct dcssblk_dev_info, dev);\r\nlist_for_each_entry_safe(entry, temp, &dev_info->seg_list, lh) {\r\nlist_del(&entry->lh);\r\nkfree(entry);\r\n}\r\nkfree(dev_info);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic int\r\ndcssblk_assign_free_minor(struct dcssblk_dev_info *dev_info)\r\n{\r\nint minor, found;\r\nstruct dcssblk_dev_info *entry;\r\nif (dev_info == NULL)\r\nreturn -EINVAL;\r\nfor (minor = 0; minor < (1<<MINORBITS); minor++) {\r\nfound = 0;\r\nlist_for_each_entry(entry, &dcssblk_devices, lh)\r\nif (minor == entry->gd->first_minor)\r\nfound++;\r\nif (!found) break;\r\n}\r\nif (found)\r\nreturn -EBUSY;\r\ndev_info->gd->first_minor = minor;\r\nreturn 0;\r\n}\r\nstatic struct dcssblk_dev_info *\r\ndcssblk_get_device_by_name(char *name)\r\n{\r\nstruct dcssblk_dev_info *entry;\r\nlist_for_each_entry(entry, &dcssblk_devices, lh) {\r\nif (!strcmp(name, entry->segment_name)) {\r\nreturn entry;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct segment_info *\r\ndcssblk_get_segment_by_name(char *name)\r\n{\r\nstruct dcssblk_dev_info *dev_info;\r\nstruct segment_info *entry;\r\nlist_for_each_entry(dev_info, &dcssblk_devices, lh) {\r\nlist_for_each_entry(entry, &dev_info->seg_list, lh) {\r\nif (!strcmp(name, entry->segment_name))\r\nreturn entry;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned long\r\ndcssblk_find_highest_addr(struct dcssblk_dev_info *dev_info)\r\n{\r\nunsigned long highest_addr;\r\nstruct segment_info *entry;\r\nhighest_addr = 0;\r\nlist_for_each_entry(entry, &dev_info->seg_list, lh) {\r\nif (highest_addr < entry->end)\r\nhighest_addr = entry->end;\r\n}\r\nreturn highest_addr;\r\n}\r\nstatic unsigned long\r\ndcssblk_find_lowest_addr(struct dcssblk_dev_info *dev_info)\r\n{\r\nint set_first;\r\nunsigned long lowest_addr;\r\nstruct segment_info *entry;\r\nset_first = 0;\r\nlowest_addr = 0;\r\nlist_for_each_entry(entry, &dev_info->seg_list, lh) {\r\nif (set_first == 0) {\r\nlowest_addr = entry->start;\r\nset_first = 1;\r\n} else {\r\nif (lowest_addr > entry->start)\r\nlowest_addr = entry->start;\r\n}\r\n}\r\nreturn lowest_addr;\r\n}\r\nstatic int\r\ndcssblk_is_continuous(struct dcssblk_dev_info *dev_info)\r\n{\r\nint i, j, rc;\r\nstruct segment_info *sort_list, *entry, temp;\r\nif (dev_info->num_of_segments <= 1)\r\nreturn 0;\r\nsort_list = kzalloc(\r\nsizeof(struct segment_info) * dev_info->num_of_segments,\r\nGFP_KERNEL);\r\nif (sort_list == NULL)\r\nreturn -ENOMEM;\r\ni = 0;\r\nlist_for_each_entry(entry, &dev_info->seg_list, lh) {\r\nmemcpy(&sort_list[i], entry, sizeof(struct segment_info));\r\ni++;\r\n}\r\nfor (i = 0; i < dev_info->num_of_segments; i++)\r\nfor (j = 0; j < dev_info->num_of_segments; j++)\r\nif (sort_list[j].start > sort_list[i].start) {\r\nmemcpy(&temp, &sort_list[i],\r\nsizeof(struct segment_info));\r\nmemcpy(&sort_list[i], &sort_list[j],\r\nsizeof(struct segment_info));\r\nmemcpy(&sort_list[j], &temp,\r\nsizeof(struct segment_info));\r\n}\r\nfor (i = 0; i < dev_info->num_of_segments - 1; i++) {\r\nif ((sort_list[i].end + 1) != sort_list[i+1].start) {\r\npr_err("Adjacent DCSSs %s and %s are not "\r\n"contiguous\n", sort_list[i].segment_name,\r\nsort_list[i+1].segment_name);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (sort_list[i].segment_type != sort_list[i+1].segment_type) {\r\nif (!(sort_list[i].segment_type & SEGMENT_EXCLUSIVE) ||\r\n(sort_list[i].segment_type == SEG_TYPE_ER) ||\r\n!(sort_list[i+1].segment_type &\r\nSEGMENT_EXCLUSIVE) ||\r\n(sort_list[i+1].segment_type == SEG_TYPE_ER)) {\r\npr_err("DCSS %s and DCSS %s have "\r\n"incompatible types\n",\r\nsort_list[i].segment_name,\r\nsort_list[i+1].segment_name);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\n}\r\nrc = 0;\r\nout:\r\nkfree(sort_list);\r\nreturn rc;\r\n}\r\nstatic int\r\ndcssblk_load_segment(char *name, struct segment_info **seg_info)\r\n{\r\nint rc;\r\ndown_read(&dcssblk_devices_sem);\r\n*seg_info = dcssblk_get_segment_by_name(name);\r\nup_read(&dcssblk_devices_sem);\r\nif (*seg_info != NULL)\r\nreturn -EEXIST;\r\n*seg_info = kzalloc(sizeof(struct segment_info), GFP_KERNEL);\r\nif (*seg_info == NULL)\r\nreturn -ENOMEM;\r\nstrcpy((*seg_info)->segment_name, name);\r\nrc = segment_load(name, SEGMENT_SHARED,\r\n&(*seg_info)->start, &(*seg_info)->end);\r\nif (rc < 0) {\r\nsegment_warning(rc, (*seg_info)->segment_name);\r\nkfree(*seg_info);\r\n} else {\r\nINIT_LIST_HEAD(&(*seg_info)->lh);\r\n(*seg_info)->segment_type = rc;\r\n}\r\nreturn rc;\r\n}\r\nstatic void dcssblk_unregister_callback(struct device *dev)\r\n{\r\ndevice_unregister(dev);\r\nput_device(dev);\r\n}\r\nstatic ssize_t\r\ndcssblk_shared_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct dcssblk_dev_info *dev_info;\r\ndev_info = container_of(dev, struct dcssblk_dev_info, dev);\r\nreturn sprintf(buf, dev_info->is_shared ? "1\n" : "0\n");\r\n}\r\nstatic ssize_t\r\ndcssblk_shared_store(struct device *dev, struct device_attribute *attr, const char *inbuf, size_t count)\r\n{\r\nstruct dcssblk_dev_info *dev_info;\r\nstruct segment_info *entry, *temp;\r\nint rc;\r\nif ((count > 1) && (inbuf[1] != '\n') && (inbuf[1] != '\0'))\r\nreturn -EINVAL;\r\ndown_write(&dcssblk_devices_sem);\r\ndev_info = container_of(dev, struct dcssblk_dev_info, dev);\r\nif (atomic_read(&dev_info->use_count)) {\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nif (inbuf[0] == '1') {\r\nlist_for_each_entry(entry, &dev_info->seg_list, lh) {\r\nrc = segment_modify_shared(entry->segment_name,\r\nSEGMENT_SHARED);\r\nif (rc < 0) {\r\nBUG_ON(rc == -EINVAL);\r\nif (rc != -EAGAIN)\r\ngoto removeseg;\r\n}\r\n}\r\ndev_info->is_shared = 1;\r\nswitch (dev_info->segment_type) {\r\ncase SEG_TYPE_SR:\r\ncase SEG_TYPE_ER:\r\ncase SEG_TYPE_SC:\r\nset_disk_ro(dev_info->gd, 1);\r\n}\r\n} else if (inbuf[0] == '0') {\r\nif (dev_info->segment_type == SEG_TYPE_SC) {\r\npr_err("DCSS %s is of type SC and cannot be "\r\n"loaded as exclusive-writable\n",\r\ndev_info->segment_name);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nlist_for_each_entry(entry, &dev_info->seg_list, lh) {\r\nrc = segment_modify_shared(entry->segment_name,\r\nSEGMENT_EXCLUSIVE);\r\nif (rc < 0) {\r\nBUG_ON(rc == -EINVAL);\r\nif (rc != -EAGAIN)\r\ngoto removeseg;\r\n}\r\n}\r\ndev_info->is_shared = 0;\r\nset_disk_ro(dev_info->gd, 0);\r\n} else {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = count;\r\ngoto out;\r\nremoveseg:\r\npr_err("DCSS device %s is removed after a failed access mode "\r\n"change\n", dev_info->segment_name);\r\ntemp = entry;\r\nlist_for_each_entry(entry, &dev_info->seg_list, lh) {\r\nif (entry != temp)\r\nsegment_unload(entry->segment_name);\r\n}\r\nlist_del(&dev_info->lh);\r\ndel_gendisk(dev_info->gd);\r\nblk_cleanup_queue(dev_info->dcssblk_queue);\r\ndev_info->gd->queue = NULL;\r\nput_disk(dev_info->gd);\r\nrc = device_schedule_callback(dev, dcssblk_unregister_callback);\r\nout:\r\nup_write(&dcssblk_devices_sem);\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\ndcssblk_save_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct dcssblk_dev_info *dev_info;\r\ndev_info = container_of(dev, struct dcssblk_dev_info, dev);\r\nreturn sprintf(buf, dev_info->save_pending ? "1\n" : "0\n");\r\n}\r\nstatic ssize_t\r\ndcssblk_save_store(struct device *dev, struct device_attribute *attr, const char *inbuf, size_t count)\r\n{\r\nstruct dcssblk_dev_info *dev_info;\r\nstruct segment_info *entry;\r\nif ((count > 1) && (inbuf[1] != '\n') && (inbuf[1] != '\0'))\r\nreturn -EINVAL;\r\ndev_info = container_of(dev, struct dcssblk_dev_info, dev);\r\ndown_write(&dcssblk_devices_sem);\r\nif (inbuf[0] == '1') {\r\nif (atomic_read(&dev_info->use_count) == 0) {\r\npr_info("All DCSSs that map to device %s are "\r\n"saved\n", dev_info->segment_name);\r\nlist_for_each_entry(entry, &dev_info->seg_list, lh) {\r\nsegment_save(entry->segment_name);\r\n}\r\n} else {\r\npr_info("Device %s is in use, its DCSSs will be "\r\n"saved when it becomes idle\n",\r\ndev_info->segment_name);\r\ndev_info->save_pending = 1;\r\n}\r\n} else if (inbuf[0] == '0') {\r\nif (dev_info->save_pending) {\r\ndev_info->save_pending = 0;\r\npr_info("A pending save request for device %s "\r\n"has been canceled\n",\r\ndev_info->segment_name);\r\n}\r\n} else {\r\nup_write(&dcssblk_devices_sem);\r\nreturn -EINVAL;\r\n}\r\nup_write(&dcssblk_devices_sem);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\ndcssblk_seglist_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint i;\r\nstruct dcssblk_dev_info *dev_info;\r\nstruct segment_info *entry;\r\ndown_read(&dcssblk_devices_sem);\r\ndev_info = container_of(dev, struct dcssblk_dev_info, dev);\r\ni = 0;\r\nbuf[0] = '\0';\r\nlist_for_each_entry(entry, &dev_info->seg_list, lh) {\r\nstrcpy(&buf[i], entry->segment_name);\r\ni += strlen(entry->segment_name);\r\nbuf[i] = '\n';\r\ni++;\r\n}\r\nup_read(&dcssblk_devices_sem);\r\nreturn i;\r\n}\r\nstatic ssize_t\r\ndcssblk_add_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint rc, i, j, num_of_segments;\r\nstruct dcssblk_dev_info *dev_info;\r\nstruct segment_info *seg_info, *temp;\r\nchar *local_buf;\r\nunsigned long seg_byte_size;\r\ndev_info = NULL;\r\nseg_info = NULL;\r\nif (dev != dcssblk_root_dev) {\r\nrc = -EINVAL;\r\ngoto out_nobuf;\r\n}\r\nif ((count < 1) || (buf[0] == '\0') || (buf[0] == '\n')) {\r\nrc = -ENAMETOOLONG;\r\ngoto out_nobuf;\r\n}\r\nlocal_buf = kmalloc(count + 1, GFP_KERNEL);\r\nif (local_buf == NULL) {\r\nrc = -ENOMEM;\r\ngoto out_nobuf;\r\n}\r\nnum_of_segments = 0;\r\nfor (i = 0; ((buf[i] != '\0') && (buf[i] != '\n') && i < count); i++) {\r\nfor (j = i; (buf[j] != ':') &&\r\n(buf[j] != '\0') &&\r\n(buf[j] != '\n') &&\r\nj < count; j++) {\r\nlocal_buf[j-i] = toupper(buf[j]);\r\n}\r\nlocal_buf[j-i] = '\0';\r\nif (((j - i) == 0) || ((j - i) > 8)) {\r\nrc = -ENAMETOOLONG;\r\ngoto seg_list_del;\r\n}\r\nrc = dcssblk_load_segment(local_buf, &seg_info);\r\nif (rc < 0)\r\ngoto seg_list_del;\r\nif (num_of_segments == 0) {\r\ndev_info = kzalloc(sizeof(struct dcssblk_dev_info),\r\nGFP_KERNEL);\r\nif (dev_info == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nstrcpy(dev_info->segment_name, local_buf);\r\ndev_info->segment_type = seg_info->segment_type;\r\nINIT_LIST_HEAD(&dev_info->seg_list);\r\n}\r\nlist_add_tail(&seg_info->lh, &dev_info->seg_list);\r\nnum_of_segments++;\r\ni = j;\r\nif ((buf[j] == '\0') || (buf[j] == '\n'))\r\nbreak;\r\n}\r\nif ((i > 0) && (buf[i-1] == ':')) {\r\nrc = -ENAMETOOLONG;\r\ngoto seg_list_del;\r\n}\r\nstrlcpy(local_buf, buf, i + 1);\r\ndev_info->num_of_segments = num_of_segments;\r\nrc = dcssblk_is_continuous(dev_info);\r\nif (rc < 0)\r\ngoto seg_list_del;\r\ndev_info->start = dcssblk_find_lowest_addr(dev_info);\r\ndev_info->end = dcssblk_find_highest_addr(dev_info);\r\ndev_set_name(&dev_info->dev, dev_info->segment_name);\r\ndev_info->dev.release = dcssblk_release_segment;\r\nINIT_LIST_HEAD(&dev_info->lh);\r\ndev_info->gd = alloc_disk(DCSSBLK_MINORS_PER_DISK);\r\nif (dev_info->gd == NULL) {\r\nrc = -ENOMEM;\r\ngoto seg_list_del;\r\n}\r\ndev_info->gd->major = dcssblk_major;\r\ndev_info->gd->fops = &dcssblk_devops;\r\ndev_info->dcssblk_queue = blk_alloc_queue(GFP_KERNEL);\r\ndev_info->gd->queue = dev_info->dcssblk_queue;\r\ndev_info->gd->private_data = dev_info;\r\ndev_info->gd->driverfs_dev = &dev_info->dev;\r\nblk_queue_make_request(dev_info->dcssblk_queue, dcssblk_make_request);\r\nblk_queue_logical_block_size(dev_info->dcssblk_queue, 4096);\r\nseg_byte_size = (dev_info->end - dev_info->start + 1);\r\nset_capacity(dev_info->gd, seg_byte_size >> 9);\r\npr_info("Loaded %s with total size %lu bytes and capacity %lu "\r\n"sectors\n", local_buf, seg_byte_size, seg_byte_size >> 9);\r\ndev_info->save_pending = 0;\r\ndev_info->is_shared = 1;\r\ndev_info->dev.parent = dcssblk_root_dev;\r\ndown_write(&dcssblk_devices_sem);\r\nif (dcssblk_get_segment_by_name(local_buf)) {\r\nrc = -EEXIST;\r\ngoto release_gd;\r\n}\r\nrc = dcssblk_assign_free_minor(dev_info);\r\nif (rc)\r\ngoto release_gd;\r\nsprintf(dev_info->gd->disk_name, "dcssblk%d",\r\ndev_info->gd->first_minor);\r\nlist_add_tail(&dev_info->lh, &dcssblk_devices);\r\nif (!try_module_get(THIS_MODULE)) {\r\nrc = -ENODEV;\r\ngoto dev_list_del;\r\n}\r\nrc = device_register(&dev_info->dev);\r\nif (rc) {\r\nmodule_put(THIS_MODULE);\r\ngoto dev_list_del;\r\n}\r\nget_device(&dev_info->dev);\r\nrc = device_create_file(&dev_info->dev, &dev_attr_shared);\r\nif (rc)\r\ngoto unregister_dev;\r\nrc = device_create_file(&dev_info->dev, &dev_attr_save);\r\nif (rc)\r\ngoto unregister_dev;\r\nrc = device_create_file(&dev_info->dev, &dev_attr_seglist);\r\nif (rc)\r\ngoto unregister_dev;\r\nadd_disk(dev_info->gd);\r\nswitch (dev_info->segment_type) {\r\ncase SEG_TYPE_SR:\r\ncase SEG_TYPE_ER:\r\ncase SEG_TYPE_SC:\r\nset_disk_ro(dev_info->gd,1);\r\nbreak;\r\ndefault:\r\nset_disk_ro(dev_info->gd,0);\r\nbreak;\r\n}\r\nup_write(&dcssblk_devices_sem);\r\nrc = count;\r\ngoto out;\r\nunregister_dev:\r\nlist_del(&dev_info->lh);\r\nblk_cleanup_queue(dev_info->dcssblk_queue);\r\ndev_info->gd->queue = NULL;\r\nput_disk(dev_info->gd);\r\ndevice_unregister(&dev_info->dev);\r\nlist_for_each_entry(seg_info, &dev_info->seg_list, lh) {\r\nsegment_unload(seg_info->segment_name);\r\n}\r\nput_device(&dev_info->dev);\r\nup_write(&dcssblk_devices_sem);\r\ngoto out;\r\ndev_list_del:\r\nlist_del(&dev_info->lh);\r\nrelease_gd:\r\nblk_cleanup_queue(dev_info->dcssblk_queue);\r\ndev_info->gd->queue = NULL;\r\nput_disk(dev_info->gd);\r\nup_write(&dcssblk_devices_sem);\r\nseg_list_del:\r\nif (dev_info == NULL)\r\ngoto out;\r\nlist_for_each_entry_safe(seg_info, temp, &dev_info->seg_list, lh) {\r\nlist_del(&seg_info->lh);\r\nsegment_unload(seg_info->segment_name);\r\nkfree(seg_info);\r\n}\r\nkfree(dev_info);\r\nout:\r\nkfree(local_buf);\r\nout_nobuf:\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\ndcssblk_remove_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct dcssblk_dev_info *dev_info;\r\nstruct segment_info *entry;\r\nint rc, i;\r\nchar *local_buf;\r\nif (dev != dcssblk_root_dev) {\r\nreturn -EINVAL;\r\n}\r\nlocal_buf = kmalloc(count + 1, GFP_KERNEL);\r\nif (local_buf == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; ((*(buf+i)!='\0') && (*(buf+i)!='\n') && i < count); i++) {\r\nlocal_buf[i] = toupper(buf[i]);\r\n}\r\nlocal_buf[i] = '\0';\r\nif ((i == 0) || (i > 8)) {\r\nrc = -ENAMETOOLONG;\r\ngoto out_buf;\r\n}\r\ndown_write(&dcssblk_devices_sem);\r\ndev_info = dcssblk_get_device_by_name(local_buf);\r\nif (dev_info == NULL) {\r\nup_write(&dcssblk_devices_sem);\r\npr_warning("Device %s cannot be removed because it is not a "\r\n"known device\n", local_buf);\r\nrc = -ENODEV;\r\ngoto out_buf;\r\n}\r\nif (atomic_read(&dev_info->use_count) != 0) {\r\nup_write(&dcssblk_devices_sem);\r\npr_warning("Device %s cannot be removed while it is in "\r\n"use\n", local_buf);\r\nrc = -EBUSY;\r\ngoto out_buf;\r\n}\r\nlist_del(&dev_info->lh);\r\ndel_gendisk(dev_info->gd);\r\nblk_cleanup_queue(dev_info->dcssblk_queue);\r\ndev_info->gd->queue = NULL;\r\nput_disk(dev_info->gd);\r\ndevice_unregister(&dev_info->dev);\r\nlist_for_each_entry(entry, &dev_info->seg_list, lh)\r\nsegment_unload(entry->segment_name);\r\nput_device(&dev_info->dev);\r\nup_write(&dcssblk_devices_sem);\r\nrc = count;\r\nout_buf:\r\nkfree(local_buf);\r\nreturn rc;\r\n}\r\nstatic int\r\ndcssblk_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct dcssblk_dev_info *dev_info;\r\nint rc;\r\ndev_info = bdev->bd_disk->private_data;\r\nif (NULL == dev_info) {\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\natomic_inc(&dev_info->use_count);\r\nbdev->bd_block_size = 4096;\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int\r\ndcssblk_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct dcssblk_dev_info *dev_info = disk->private_data;\r\nstruct segment_info *entry;\r\nint rc;\r\nif (!dev_info) {\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\ndown_write(&dcssblk_devices_sem);\r\nif (atomic_dec_and_test(&dev_info->use_count)\r\n&& (dev_info->save_pending)) {\r\npr_info("Device %s has become idle and is being saved "\r\n"now\n", dev_info->segment_name);\r\nlist_for_each_entry(entry, &dev_info->seg_list, lh) {\r\nsegment_save(entry->segment_name);\r\n}\r\ndev_info->save_pending = 0;\r\n}\r\nup_write(&dcssblk_devices_sem);\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic void\r\ndcssblk_make_request(struct request_queue *q, struct bio *bio)\r\n{\r\nstruct dcssblk_dev_info *dev_info;\r\nstruct bio_vec *bvec;\r\nunsigned long index;\r\nunsigned long page_addr;\r\nunsigned long source_addr;\r\nunsigned long bytes_done;\r\nint i;\r\nbytes_done = 0;\r\ndev_info = bio->bi_bdev->bd_disk->private_data;\r\nif (dev_info == NULL)\r\ngoto fail;\r\nif ((bio->bi_sector & 7) != 0 || (bio->bi_size & 4095) != 0)\r\ngoto fail;\r\nif (((bio->bi_size >> 9) + bio->bi_sector)\r\n> get_capacity(bio->bi_bdev->bd_disk)) {\r\ngoto fail;\r\n}\r\nif (dev_info->is_shared) {\r\nswitch (dev_info->segment_type) {\r\ncase SEG_TYPE_SR:\r\ncase SEG_TYPE_ER:\r\ncase SEG_TYPE_SC:\r\nif (bio_data_dir(bio) == WRITE) {\r\npr_warning("Writing to %s failed because it "\r\n"is a read-only device\n",\r\ndev_name(&dev_info->dev));\r\ngoto fail;\r\n}\r\n}\r\n}\r\nindex = (bio->bi_sector >> 3);\r\nbio_for_each_segment(bvec, bio, i) {\r\npage_addr = (unsigned long)\r\npage_address(bvec->bv_page) + bvec->bv_offset;\r\nsource_addr = dev_info->start + (index<<12) + bytes_done;\r\nif (unlikely((page_addr & 4095) != 0) || (bvec->bv_len & 4095) != 0)\r\ngoto fail;\r\nif (bio_data_dir(bio) == READ) {\r\nmemcpy((void*)page_addr, (void*)source_addr,\r\nbvec->bv_len);\r\n} else {\r\nmemcpy((void*)source_addr, (void*)page_addr,\r\nbvec->bv_len);\r\n}\r\nbytes_done += bvec->bv_len;\r\n}\r\nbio_endio(bio, 0);\r\nreturn;\r\nfail:\r\nbio_io_error(bio);\r\n}\r\nstatic int\r\ndcssblk_direct_access (struct block_device *bdev, sector_t secnum,\r\nvoid **kaddr, unsigned long *pfn)\r\n{\r\nstruct dcssblk_dev_info *dev_info;\r\nunsigned long pgoff;\r\ndev_info = bdev->bd_disk->private_data;\r\nif (!dev_info)\r\nreturn -ENODEV;\r\nif (secnum % (PAGE_SIZE/512))\r\nreturn -EINVAL;\r\npgoff = secnum / (PAGE_SIZE / 512);\r\nif ((pgoff+1)*PAGE_SIZE-1 > dev_info->end - dev_info->start)\r\nreturn -ERANGE;\r\n*kaddr = (void *) (dev_info->start+pgoff*PAGE_SIZE);\r\n*pfn = virt_to_phys(*kaddr) >> PAGE_SHIFT;\r\nreturn 0;\r\n}\r\nstatic void\r\ndcssblk_check_params(void)\r\n{\r\nint rc, i, j, k;\r\nchar buf[DCSSBLK_PARM_LEN + 1];\r\nstruct dcssblk_dev_info *dev_info;\r\nfor (i = 0; (i < DCSSBLK_PARM_LEN) && (dcssblk_segments[i] != '\0');\r\ni++) {\r\nfor (j = i; (dcssblk_segments[j] != ',') &&\r\n(dcssblk_segments[j] != '\0') &&\r\n(dcssblk_segments[j] != '(') &&\r\n(j < DCSSBLK_PARM_LEN); j++)\r\n{\r\nbuf[j-i] = dcssblk_segments[j];\r\n}\r\nbuf[j-i] = '\0';\r\nrc = dcssblk_add_store(dcssblk_root_dev, NULL, buf, j-i);\r\nif ((rc >= 0) && (dcssblk_segments[j] == '(')) {\r\nfor (k = 0; (buf[k] != ':') && (buf[k] != '\0'); k++)\r\nbuf[k] = toupper(buf[k]);\r\nbuf[k] = '\0';\r\nif (!strncmp(&dcssblk_segments[j], "(local)", 7)) {\r\ndown_read(&dcssblk_devices_sem);\r\ndev_info = dcssblk_get_device_by_name(buf);\r\nup_read(&dcssblk_devices_sem);\r\nif (dev_info)\r\ndcssblk_shared_store(&dev_info->dev,\r\nNULL, "0\n", 2);\r\n}\r\n}\r\nwhile ((dcssblk_segments[j] != ',') &&\r\n(dcssblk_segments[j] != '\0'))\r\n{\r\nj++;\r\n}\r\nif (dcssblk_segments[j] == '\0')\r\nbreak;\r\ni = j;\r\n}\r\n}\r\nstatic int dcssblk_freeze(struct device *dev)\r\n{\r\nstruct dcssblk_dev_info *dev_info;\r\nint rc = 0;\r\nlist_for_each_entry(dev_info, &dcssblk_devices, lh) {\r\nswitch (dev_info->segment_type) {\r\ncase SEG_TYPE_SR:\r\ncase SEG_TYPE_ER:\r\ncase SEG_TYPE_SC:\r\nif (!dev_info->is_shared)\r\nrc = -EINVAL;\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nif (rc)\r\nbreak;\r\n}\r\nif (rc)\r\npr_err("Suspending the system failed because DCSS device %s "\r\n"is writable\n",\r\ndev_info->segment_name);\r\nreturn rc;\r\n}\r\nstatic int dcssblk_restore(struct device *dev)\r\n{\r\nstruct dcssblk_dev_info *dev_info;\r\nstruct segment_info *entry;\r\nunsigned long start, end;\r\nint rc = 0;\r\nlist_for_each_entry(dev_info, &dcssblk_devices, lh) {\r\nlist_for_each_entry(entry, &dev_info->seg_list, lh) {\r\nsegment_unload(entry->segment_name);\r\nrc = segment_load(entry->segment_name, SEGMENT_SHARED,\r\n&start, &end);\r\nif (rc < 0) {\r\nsegment_warning(rc, entry->segment_name);\r\ngoto out_panic;\r\n}\r\nif (start != entry->start || end != entry->end) {\r\npr_err("The address range of DCSS %s changed "\r\n"while the system was suspended\n",\r\nentry->segment_name);\r\ngoto out_panic;\r\n}\r\n}\r\n}\r\nreturn 0;\r\nout_panic:\r\npanic("fatal dcssblk resume error\n");\r\n}\r\nstatic int dcssblk_thaw(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit\r\ndcssblk_exit(void)\r\n{\r\nplatform_device_unregister(dcssblk_pdev);\r\nplatform_driver_unregister(&dcssblk_pdrv);\r\nroot_device_unregister(dcssblk_root_dev);\r\nunregister_blkdev(dcssblk_major, DCSSBLK_NAME);\r\n}\r\nstatic int __init\r\ndcssblk_init(void)\r\n{\r\nint rc;\r\nrc = platform_driver_register(&dcssblk_pdrv);\r\nif (rc)\r\nreturn rc;\r\ndcssblk_pdev = platform_device_register_simple("dcssblk", -1, NULL,\r\n0);\r\nif (IS_ERR(dcssblk_pdev)) {\r\nrc = PTR_ERR(dcssblk_pdev);\r\ngoto out_pdrv;\r\n}\r\ndcssblk_root_dev = root_device_register("dcssblk");\r\nif (IS_ERR(dcssblk_root_dev)) {\r\nrc = PTR_ERR(dcssblk_root_dev);\r\ngoto out_pdev;\r\n}\r\nrc = device_create_file(dcssblk_root_dev, &dev_attr_add);\r\nif (rc)\r\ngoto out_root;\r\nrc = device_create_file(dcssblk_root_dev, &dev_attr_remove);\r\nif (rc)\r\ngoto out_root;\r\nrc = register_blkdev(0, DCSSBLK_NAME);\r\nif (rc < 0)\r\ngoto out_root;\r\ndcssblk_major = rc;\r\ninit_rwsem(&dcssblk_devices_sem);\r\ndcssblk_check_params();\r\nreturn 0;\r\nout_root:\r\nroot_device_unregister(dcssblk_root_dev);\r\nout_pdev:\r\nplatform_device_unregister(dcssblk_pdev);\r\nout_pdrv:\r\nplatform_driver_unregister(&dcssblk_pdrv);\r\nreturn rc;\r\n}
