static inline u8 IN_TO_REG(unsigned long val)\r\n{\r\nunsigned long nval = SENSORS_LIMIT(val, 0, 4080);\r\nreturn (nval + 8) / 16;\r\n}\r\nstatic inline u8 FAN_TO_REG(long rpm, int div)\r\n{\r\nif (rpm <= 0)\r\nreturn 255;\r\nreturn SENSORS_LIMIT((1350000 + rpm * div / 2) / (rpm * div), 1, 254);\r\n}\r\nstatic inline int FAN_FROM_REG(u8 val, int div)\r\n{\r\nreturn val==0 ? -1 : val==255 ? 0 : 1350000/(val*div);\r\n}\r\nstatic inline int TEMP_FROM_REG(s8 val)\r\n{\r\nreturn val * 830 + 52120;\r\n}\r\nstatic inline s8 TEMP_TO_REG(int val)\r\n{\r\nint nval = SENSORS_LIMIT(val, -54120, 157530) ;\r\nreturn nval<0 ? (nval-5212-415)/830 : (nval-5212+415)/830;\r\n}\r\nstatic inline u8 DIV_TO_REG(int val)\r\n{\r\nreturn val==8 ? 3 : val==4 ? 2 : val==1 ? 0 : 1;\r\n}\r\nstatic ssize_t show_in(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sis5595_data *data = sis5595_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%d\n", IN_FROM_REG(data->in[nr]));\r\n}\r\nstatic ssize_t show_in_min(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sis5595_data *data = sis5595_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%d\n", IN_FROM_REG(data->in_min[nr]));\r\n}\r\nstatic ssize_t show_in_max(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sis5595_data *data = sis5595_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%d\n", IN_FROM_REG(data->in_max[nr]));\r\n}\r\nstatic ssize_t set_in_min(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sis5595_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nint nr = attr->index;\r\nunsigned long val = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->in_min[nr] = IN_TO_REG(val);\r\nsis5595_write_value(data, SIS5595_REG_IN_MIN(nr), data->in_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_in_max(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sis5595_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nint nr = attr->index;\r\nunsigned long val = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->in_max[nr] = IN_TO_REG(val);\r\nsis5595_write_value(data, SIS5595_REG_IN_MAX(nr), data->in_max[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sis5595_data *data = sis5595_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp));\r\n}\r\nstatic ssize_t show_temp_over(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sis5595_data *data = sis5595_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_over));\r\n}\r\nstatic ssize_t set_temp_over(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct sis5595_data *data = dev_get_drvdata(dev);\r\nlong val = simple_strtol(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->temp_over = TEMP_TO_REG(val);\r\nsis5595_write_value(data, SIS5595_REG_TEMP_OVER, data->temp_over);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_hyst(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sis5595_data *data = sis5595_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_hyst));\r\n}\r\nstatic ssize_t set_temp_hyst(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct sis5595_data *data = dev_get_drvdata(dev);\r\nlong val = simple_strtol(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->temp_hyst = TEMP_TO_REG(val);\r\nsis5595_write_value(data, SIS5595_REG_TEMP_HYST, data->temp_hyst);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sis5595_data *data = sis5595_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%d\n", FAN_FROM_REG(data->fan[nr],\r\nDIV_FROM_REG(data->fan_div[nr])) );\r\n}\r\nstatic ssize_t show_fan_min(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sis5595_data *data = sis5595_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nint nr = attr->index;\r\nreturn sprintf(buf,"%d\n", FAN_FROM_REG(data->fan_min[nr],\r\nDIV_FROM_REG(data->fan_div[nr])) );\r\n}\r\nstatic ssize_t set_fan_min(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sis5595_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nint nr = attr->index;\r\nunsigned long val = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->fan_min[nr] = FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));\r\nsis5595_write_value(data, SIS5595_REG_FAN_MIN(nr), data->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan_div(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sis5595_data *data = sis5595_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%d\n", DIV_FROM_REG(data->fan_div[nr]) );\r\n}\r\nstatic ssize_t set_fan_div(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sis5595_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nint nr = attr->index;\r\nunsigned long min;\r\nunsigned long val = simple_strtoul(buf, NULL, 10);\r\nint reg;\r\nmutex_lock(&data->update_lock);\r\nmin = FAN_FROM_REG(data->fan_min[nr],\r\nDIV_FROM_REG(data->fan_div[nr]));\r\nreg = sis5595_read_value(data, SIS5595_REG_FANDIV);\r\nswitch (val) {\r\ncase 1: data->fan_div[nr] = 0; break;\r\ncase 2: data->fan_div[nr] = 1; break;\r\ncase 4: data->fan_div[nr] = 2; break;\r\ncase 8: data->fan_div[nr] = 3; break;\r\ndefault:\r\ndev_err(dev, "fan_div value %ld not "\r\n"supported. Choose one of 1, 2, 4 or 8!\n", val);\r\nmutex_unlock(&data->update_lock);\r\nreturn -EINVAL;\r\n}\r\nswitch (nr) {\r\ncase 0:\r\nreg = (reg & 0xcf) | (data->fan_div[nr] << 4);\r\nbreak;\r\ncase 1:\r\nreg = (reg & 0x3f) | (data->fan_div[nr] << 6);\r\nbreak;\r\n}\r\nsis5595_write_value(data, SIS5595_REG_FANDIV, reg);\r\ndata->fan_min[nr] =\r\nFAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));\r\nsis5595_write_value(data, SIS5595_REG_FAN_MIN(nr), data->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_alarms(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sis5595_data *data = sis5595_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->alarms);\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sis5595_data *data = sis5595_update_device(dev);\r\nint nr = to_sensor_dev_attr(da)->index;\r\nreturn sprintf(buf, "%u\n", (data->alarms >> nr) & 1);\r\n}\r\nstatic ssize_t show_name(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sis5595_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", data->name);\r\n}\r\nstatic int __devinit sis5595_probe(struct platform_device *pdev)\r\n{\r\nint err = 0;\r\nint i;\r\nstruct sis5595_data *data;\r\nstruct resource *res;\r\nchar val;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!request_region(res->start, SIS5595_EXTENT,\r\nsis5595_driver.driver.name)) {\r\nerr = -EBUSY;\r\ngoto exit;\r\n}\r\nif (!(data = kzalloc(sizeof(struct sis5595_data), GFP_KERNEL))) {\r\nerr = -ENOMEM;\r\ngoto exit_release;\r\n}\r\nmutex_init(&data->lock);\r\nmutex_init(&data->update_lock);\r\ndata->addr = res->start;\r\ndata->name = "sis5595";\r\nplatform_set_drvdata(pdev, data);\r\ndata->revision = s_bridge->revision;\r\ndata->maxins = 3;\r\nif (data->revision >= REV2MIN) {\r\npci_read_config_byte(s_bridge, SIS5595_PIN_REG, &val);\r\nif (!(val & 0x80))\r\ndata->maxins = 4;\r\n}\r\nsis5595_init_device(data);\r\nfor (i = 0; i < 2; i++) {\r\ndata->fan_min[i] = sis5595_read_value(data,\r\nSIS5595_REG_FAN_MIN(i));\r\n}\r\nif ((err = sysfs_create_group(&pdev->dev.kobj, &sis5595_group)))\r\ngoto exit_free;\r\nif (data->maxins == 4) {\r\nif ((err = sysfs_create_group(&pdev->dev.kobj,\r\n&sis5595_group_in4)))\r\ngoto exit_remove_files;\r\n} else {\r\nif ((err = sysfs_create_group(&pdev->dev.kobj,\r\n&sis5595_group_temp1)))\r\ngoto exit_remove_files;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&pdev->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove_files;\r\n}\r\nreturn 0;\r\nexit_remove_files:\r\nsysfs_remove_group(&pdev->dev.kobj, &sis5595_group);\r\nsysfs_remove_group(&pdev->dev.kobj, &sis5595_group_in4);\r\nsysfs_remove_group(&pdev->dev.kobj, &sis5595_group_temp1);\r\nexit_free:\r\nkfree(data);\r\nexit_release:\r\nrelease_region(res->start, SIS5595_EXTENT);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __devexit sis5595_remove(struct platform_device *pdev)\r\n{\r\nstruct sis5595_data *data = platform_get_drvdata(pdev);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&pdev->dev.kobj, &sis5595_group);\r\nsysfs_remove_group(&pdev->dev.kobj, &sis5595_group_in4);\r\nsysfs_remove_group(&pdev->dev.kobj, &sis5595_group_temp1);\r\nrelease_region(data->addr, SIS5595_EXTENT);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int sis5595_read_value(struct sis5595_data *data, u8 reg)\r\n{\r\nint res;\r\nmutex_lock(&data->lock);\r\noutb_p(reg, data->addr + SIS5595_ADDR_REG_OFFSET);\r\nres = inb_p(data->addr + SIS5595_DATA_REG_OFFSET);\r\nmutex_unlock(&data->lock);\r\nreturn res;\r\n}\r\nstatic void sis5595_write_value(struct sis5595_data *data, u8 reg, u8 value)\r\n{\r\nmutex_lock(&data->lock);\r\noutb_p(reg, data->addr + SIS5595_ADDR_REG_OFFSET);\r\noutb_p(value, data->addr + SIS5595_DATA_REG_OFFSET);\r\nmutex_unlock(&data->lock);\r\n}\r\nstatic void __devinit sis5595_init_device(struct sis5595_data *data)\r\n{\r\nu8 config = sis5595_read_value(data, SIS5595_REG_CONFIG);\r\nif (!(config & 0x01))\r\nsis5595_write_value(data, SIS5595_REG_CONFIG,\r\n(config & 0xf7) | 0x01);\r\n}\r\nstatic struct sis5595_data *sis5595_update_device(struct device *dev)\r\n{\r\nstruct sis5595_data *data = dev_get_drvdata(dev);\r\nint i;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\r\n|| !data->valid) {\r\nfor (i = 0; i <= data->maxins; i++) {\r\ndata->in[i] =\r\nsis5595_read_value(data, SIS5595_REG_IN(i));\r\ndata->in_min[i] =\r\nsis5595_read_value(data,\r\nSIS5595_REG_IN_MIN(i));\r\ndata->in_max[i] =\r\nsis5595_read_value(data,\r\nSIS5595_REG_IN_MAX(i));\r\n}\r\nfor (i = 0; i < 2; i++) {\r\ndata->fan[i] =\r\nsis5595_read_value(data, SIS5595_REG_FAN(i));\r\ndata->fan_min[i] =\r\nsis5595_read_value(data,\r\nSIS5595_REG_FAN_MIN(i));\r\n}\r\nif (data->maxins == 3) {\r\ndata->temp =\r\nsis5595_read_value(data, SIS5595_REG_TEMP);\r\ndata->temp_over =\r\nsis5595_read_value(data, SIS5595_REG_TEMP_OVER);\r\ndata->temp_hyst =\r\nsis5595_read_value(data, SIS5595_REG_TEMP_HYST);\r\n}\r\ni = sis5595_read_value(data, SIS5595_REG_FANDIV);\r\ndata->fan_div[0] = (i >> 4) & 0x03;\r\ndata->fan_div[1] = i >> 6;\r\ndata->alarms =\r\nsis5595_read_value(data, SIS5595_REG_ALARM1) |\r\n(sis5595_read_value(data, SIS5595_REG_ALARM2) << 8);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic int __devinit sis5595_device_add(unsigned short address)\r\n{\r\nstruct resource res = {\r\n.start = address,\r\n.end = address + SIS5595_EXTENT - 1,\r\n.name = "sis5595",\r\n.flags = IORESOURCE_IO,\r\n};\r\nint err;\r\nerr = acpi_check_resource_conflict(&res);\r\nif (err)\r\ngoto exit;\r\npdev = platform_device_alloc("sis5595", address);\r\nif (!pdev) {\r\nerr = -ENOMEM;\r\npr_err("Device allocation failed\n");\r\ngoto exit;\r\n}\r\nerr = platform_device_add_resources(pdev, &res, 1);\r\nif (err) {\r\npr_err("Device resource addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add(pdev);\r\nif (err) {\r\npr_err("Device addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(pdev);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __devinit sis5595_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nu16 address;\r\nu8 enable;\r\nint *i;\r\nfor (i = blacklist; *i != 0; i++) {\r\nstruct pci_dev *d;\r\nif ((d = pci_get_device(PCI_VENDOR_ID_SI, *i, NULL))) {\r\ndev_err(&d->dev, "Looked for SIS5595 but found unsupported device %.4x\n", *i);\r\npci_dev_put(d);\r\nreturn -ENODEV;\r\n}\r\n}\r\nforce_addr &= ~(SIS5595_EXTENT - 1);\r\nif (force_addr) {\r\ndev_warn(&dev->dev, "Forcing ISA address 0x%x\n", force_addr);\r\npci_write_config_word(dev, SIS5595_BASE_REG, force_addr);\r\n}\r\nif (PCIBIOS_SUCCESSFUL !=\r\npci_read_config_word(dev, SIS5595_BASE_REG, &address)) {\r\ndev_err(&dev->dev, "Failed to read ISA address\n");\r\nreturn -ENODEV;\r\n}\r\naddress &= ~(SIS5595_EXTENT - 1);\r\nif (!address) {\r\ndev_err(&dev->dev, "Base address not set - upgrade BIOS or use force_addr=0xaddr\n");\r\nreturn -ENODEV;\r\n}\r\nif (force_addr && address != force_addr) {\r\ndev_err(&dev->dev, "Failed to force ISA address\n");\r\nreturn -ENODEV;\r\n}\r\nif (PCIBIOS_SUCCESSFUL !=\r\npci_read_config_byte(dev, SIS5595_ENABLE_REG, &enable)) {\r\ndev_err(&dev->dev, "Failed to read enable register\n");\r\nreturn -ENODEV;\r\n}\r\nif (!(enable & 0x80)) {\r\nif ((PCIBIOS_SUCCESSFUL !=\r\npci_write_config_byte(dev, SIS5595_ENABLE_REG,\r\nenable | 0x80))\r\n|| (PCIBIOS_SUCCESSFUL !=\r\npci_read_config_byte(dev, SIS5595_ENABLE_REG, &enable))\r\n|| (!(enable & 0x80))) {\r\ndev_err(&dev->dev, "Failed to enable HWM device\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (platform_driver_register(&sis5595_driver)) {\r\ndev_dbg(&dev->dev, "Failed to register sis5595 driver\n");\r\ngoto exit;\r\n}\r\ns_bridge = pci_dev_get(dev);\r\nif (sis5595_device_add(address))\r\ngoto exit_unregister;\r\nreturn -ENODEV;\r\nexit_unregister:\r\npci_dev_put(dev);\r\nplatform_driver_unregister(&sis5595_driver);\r\nexit:\r\nreturn -ENODEV;\r\n}\r\nstatic int __init sm_sis5595_init(void)\r\n{\r\nreturn pci_register_driver(&sis5595_pci_driver);\r\n}\r\nstatic void __exit sm_sis5595_exit(void)\r\n{\r\npci_unregister_driver(&sis5595_pci_driver);\r\nif (s_bridge != NULL) {\r\nplatform_device_unregister(pdev);\r\nplatform_driver_unregister(&sis5595_driver);\r\npci_dev_put(s_bridge);\r\ns_bridge = NULL;\r\n}\r\n}
