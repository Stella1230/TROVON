void\r\nput_info_buffer(char *cp)\r\n{\r\nstruct divert_info *ib;\r\nunsigned long flags;\r\nif (if_used <= 0)\r\nreturn;\r\nif (!cp)\r\nreturn;\r\nif (!*cp)\r\nreturn;\r\nif (!(ib = kmalloc(sizeof(struct divert_info) + strlen(cp), GFP_ATOMIC)))\r\nreturn;\r\nstrcpy(ib->info_start, cp);\r\nib->next = NULL;\r\nspin_lock_irqsave( &divert_info_lock, flags );\r\nib->usage_cnt = if_used;\r\nif (!divert_info_head)\r\ndivert_info_head = ib;\r\nelse\r\ndivert_info_tail->next = ib;\r\ndivert_info_tail = ib;\r\nwhile (divert_info_head->next) {\r\nif ((divert_info_head->usage_cnt <= 0) &&\r\n(divert_info_head->next->usage_cnt <= 0)) {\r\nib = divert_info_head;\r\ndivert_info_head = divert_info_head->next;\r\nkfree(ib);\r\n} else\r\nbreak;\r\n}\r\nspin_unlock_irqrestore( &divert_info_lock, flags );\r\nwake_up_interruptible(&(rd_queue));\r\n}\r\nstatic ssize_t\r\nisdn_divert_read(struct file *file, char __user *buf, size_t count, loff_t * off)\r\n{\r\nstruct divert_info *inf;\r\nint len;\r\nif (!*((struct divert_info **) file->private_data)) {\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\ninterruptible_sleep_on(&(rd_queue));\r\n}\r\nif (!(inf = *((struct divert_info **) file->private_data)))\r\nreturn (0);\r\ninf->usage_cnt--;\r\nfile->private_data = &inf->next;\r\nif ((len = strlen(inf->info_start)) <= count) {\r\nif (copy_to_user(buf, inf->info_start, len))\r\nreturn -EFAULT;\r\n*off += len;\r\nreturn (len);\r\n}\r\nreturn (0);\r\n}\r\nstatic ssize_t\r\nisdn_divert_write(struct file *file, const char __user *buf, size_t count, loff_t * off)\r\n{\r\nreturn (-ENODEV);\r\n}\r\nstatic unsigned int\r\nisdn_divert_poll(struct file *file, poll_table * wait)\r\n{\r\nunsigned int mask = 0;\r\npoll_wait(file, &(rd_queue), wait);\r\nif (*((struct divert_info **) file->private_data)) {\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\nreturn mask;\r\n}\r\nstatic int\r\nisdn_divert_open(struct inode *ino, struct file *filep)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave( &divert_info_lock, flags );\r\nif_used++;\r\nif (divert_info_head)\r\nfilep->private_data = &(divert_info_tail->next);\r\nelse\r\nfilep->private_data = &divert_info_head;\r\nspin_unlock_irqrestore( &divert_info_lock, flags );\r\nreturn nonseekable_open(ino, filep);\r\n}\r\nstatic int\r\nisdn_divert_close(struct inode *ino, struct file *filep)\r\n{\r\nstruct divert_info *inf;\r\nunsigned long flags;\r\nspin_lock_irqsave( &divert_info_lock, flags );\r\nif_used--;\r\ninf = *((struct divert_info **) filep->private_data);\r\nwhile (inf) {\r\ninf->usage_cnt--;\r\ninf = inf->next;\r\n}\r\nif (if_used <= 0)\r\nwhile (divert_info_head) {\r\ninf = divert_info_head;\r\ndivert_info_head = divert_info_head->next;\r\nkfree(inf);\r\n}\r\nspin_unlock_irqrestore( &divert_info_lock, flags );\r\nreturn (0);\r\n}\r\nstatic int isdn_divert_ioctl_unlocked(struct file *file, uint cmd, ulong arg)\r\n{\r\ndivert_ioctl dioctl;\r\nint i;\r\nunsigned long flags;\r\ndivert_rule *rulep;\r\nchar *cp;\r\nif (copy_from_user(&dioctl, (void __user *) arg, sizeof(dioctl)))\r\nreturn -EFAULT;\r\nswitch (cmd) {\r\ncase IIOCGETVER:\r\ndioctl.drv_version = DIVERT_IIOC_VERSION;\r\nbreak;\r\ncase IIOCGETDRV:\r\nif ((dioctl.getid.drvid = divert_if.name_to_drv(dioctl.getid.drvnam)) < 0)\r\nreturn (-EINVAL);\r\nbreak;\r\ncase IIOCGETNAM:\r\ncp = divert_if.drv_to_name(dioctl.getid.drvid);\r\nif (!cp)\r\nreturn (-EINVAL);\r\nif (!*cp)\r\nreturn (-EINVAL);\r\nstrcpy(dioctl.getid.drvnam, cp);\r\nbreak;\r\ncase IIOCGETRULE:\r\nif (!(rulep = getruleptr(dioctl.getsetrule.ruleidx)))\r\nreturn (-EINVAL);\r\ndioctl.getsetrule.rule = *rulep;\r\nbreak;\r\ncase IIOCMODRULE:\r\nif (!(rulep = getruleptr(dioctl.getsetrule.ruleidx)))\r\nreturn (-EINVAL);\r\nspin_lock_irqsave(&divert_lock, flags);\r\n*rulep = dioctl.getsetrule.rule;\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\nreturn (0);\r\nbreak;\r\ncase IIOCINSRULE:\r\nreturn (insertrule(dioctl.getsetrule.ruleidx, &dioctl.getsetrule.rule));\r\nbreak;\r\ncase IIOCDELRULE:\r\nreturn (deleterule(dioctl.getsetrule.ruleidx));\r\nbreak;\r\ncase IIOCDODFACT:\r\nreturn (deflect_extern_action(dioctl.fwd_ctrl.subcmd,\r\ndioctl.fwd_ctrl.callid,\r\ndioctl.fwd_ctrl.to_nr));\r\ncase IIOCDOCFACT:\r\ncase IIOCDOCFDIS:\r\ncase IIOCDOCFINT:\r\nif (!divert_if.drv_to_name(dioctl.cf_ctrl.drvid))\r\nreturn (-EINVAL);\r\nif (strnlen(dioctl.cf_ctrl.msn, sizeof(dioctl.cf_ctrl.msn)) ==\r\nsizeof(dioctl.cf_ctrl.msn))\r\nreturn -EINVAL;\r\nif (strnlen(dioctl.cf_ctrl.fwd_nr, sizeof(dioctl.cf_ctrl.fwd_nr)) ==\r\nsizeof(dioctl.cf_ctrl.fwd_nr))\r\nreturn -EINVAL;\r\nif ((i = cf_command(dioctl.cf_ctrl.drvid,\r\n(cmd == IIOCDOCFACT) ? 1 : (cmd == IIOCDOCFDIS) ? 0 : 2,\r\ndioctl.cf_ctrl.cfproc,\r\ndioctl.cf_ctrl.msn,\r\ndioctl.cf_ctrl.service,\r\ndioctl.cf_ctrl.fwd_nr,\r\n&dioctl.cf_ctrl.procid)))\r\nreturn (i);\r\nbreak;\r\ndefault:\r\nreturn (-EINVAL);\r\n}\r\nreturn copy_to_user((void __user *)arg, &dioctl, sizeof(dioctl)) ? -EFAULT : 0;\r\n}\r\nstatic long isdn_divert_ioctl(struct file *file, uint cmd, ulong arg)\r\n{\r\nlong ret;\r\nmutex_lock(&isdn_divert_mutex);\r\nret = isdn_divert_ioctl_unlocked(file, cmd, arg);\r\nmutex_unlock(&isdn_divert_mutex);\r\nreturn ret;\r\n}\r\nint\r\ndivert_dev_init(void)\r\n{\r\ninit_waitqueue_head(&rd_queue);\r\n#ifdef CONFIG_PROC_FS\r\nisdn_proc_entry = proc_mkdir("isdn", init_net.proc_net);\r\nif (!isdn_proc_entry)\r\nreturn (-1);\r\nisdn_divert_entry = proc_create("divert", S_IFREG | S_IRUGO,\r\nisdn_proc_entry, &isdn_fops);\r\nif (!isdn_divert_entry) {\r\nremove_proc_entry("isdn", init_net.proc_net);\r\nreturn (-1);\r\n}\r\n#endif\r\nreturn (0);\r\n}\r\nint\r\ndivert_dev_deinit(void)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("divert", isdn_proc_entry);\r\nremove_proc_entry("isdn", init_net.proc_net);\r\n#endif\r\nreturn (0);\r\n}
