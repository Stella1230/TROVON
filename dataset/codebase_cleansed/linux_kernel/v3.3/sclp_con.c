static void\r\nsclp_conbuf_callback(struct sclp_buffer *buffer, int rc)\r\n{\r\nunsigned long flags;\r\nvoid *page;\r\ndo {\r\npage = sclp_unmake_buffer(buffer);\r\nspin_lock_irqsave(&sclp_con_lock, flags);\r\nlist_del(&buffer->list);\r\nlist_add_tail((struct list_head *) page, &sclp_con_pages);\r\nbuffer = NULL;\r\nif (!list_empty(&sclp_con_outqueue))\r\nbuffer = list_first_entry(&sclp_con_outqueue,\r\nstruct sclp_buffer, list);\r\nif (!buffer || sclp_con_suspended) {\r\nsclp_con_queue_running = 0;\r\nspin_unlock_irqrestore(&sclp_con_lock, flags);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&sclp_con_lock, flags);\r\n} while (sclp_emit_buffer(buffer, sclp_conbuf_callback));\r\n}\r\nstatic void sclp_conbuf_emit(void)\r\n{\r\nstruct sclp_buffer* buffer;\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&sclp_con_lock, flags);\r\nif (sclp_conbuf)\r\nlist_add_tail(&sclp_conbuf->list, &sclp_con_outqueue);\r\nsclp_conbuf = NULL;\r\nif (sclp_con_queue_running || sclp_con_suspended)\r\ngoto out_unlock;\r\nif (list_empty(&sclp_con_outqueue))\r\ngoto out_unlock;\r\nbuffer = list_first_entry(&sclp_con_outqueue, struct sclp_buffer,\r\nlist);\r\nsclp_con_queue_running = 1;\r\nspin_unlock_irqrestore(&sclp_con_lock, flags);\r\nrc = sclp_emit_buffer(buffer, sclp_conbuf_callback);\r\nif (rc)\r\nsclp_conbuf_callback(buffer, rc);\r\nreturn;\r\nout_unlock:\r\nspin_unlock_irqrestore(&sclp_con_lock, flags);\r\n}\r\nstatic void sclp_console_sync_queue(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sclp_con_lock, flags);\r\nif (timer_pending(&sclp_con_timer))\r\ndel_timer(&sclp_con_timer);\r\nwhile (sclp_con_queue_running) {\r\nspin_unlock_irqrestore(&sclp_con_lock, flags);\r\nsclp_sync_wait();\r\nspin_lock_irqsave(&sclp_con_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&sclp_con_lock, flags);\r\n}\r\nstatic void\r\nsclp_console_timeout(unsigned long data)\r\n{\r\nsclp_conbuf_emit();\r\n}\r\nstatic void\r\nsclp_console_write(struct console *console, const char *message,\r\nunsigned int count)\r\n{\r\nunsigned long flags;\r\nvoid *page;\r\nint written;\r\nif (count == 0)\r\nreturn;\r\nspin_lock_irqsave(&sclp_con_lock, flags);\r\ndo {\r\nif (sclp_conbuf == NULL) {\r\nwhile (list_empty(&sclp_con_pages)) {\r\nif (sclp_con_suspended)\r\ngoto out;\r\nspin_unlock_irqrestore(&sclp_con_lock, flags);\r\nsclp_sync_wait();\r\nspin_lock_irqsave(&sclp_con_lock, flags);\r\n}\r\npage = sclp_con_pages.next;\r\nlist_del((struct list_head *) page);\r\nsclp_conbuf = sclp_make_buffer(page, sclp_con_columns,\r\nsclp_con_width_htab);\r\n}\r\nwritten = sclp_write(sclp_conbuf, (const unsigned char *)\r\nmessage, count);\r\nif (written == count)\r\nbreak;\r\nspin_unlock_irqrestore(&sclp_con_lock, flags);\r\nsclp_conbuf_emit();\r\nspin_lock_irqsave(&sclp_con_lock, flags);\r\nmessage += written;\r\ncount -= written;\r\n} while (count > 0);\r\nif (sclp_conbuf != NULL && sclp_chars_in_buffer(sclp_conbuf) != 0 &&\r\n!timer_pending(&sclp_con_timer)) {\r\ninit_timer(&sclp_con_timer);\r\nsclp_con_timer.function = sclp_console_timeout;\r\nsclp_con_timer.data = 0UL;\r\nsclp_con_timer.expires = jiffies + HZ/10;\r\nadd_timer(&sclp_con_timer);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&sclp_con_lock, flags);\r\n}\r\nstatic struct tty_driver *\r\nsclp_console_device(struct console *c, int *index)\r\n{\r\n*index = c->index;\r\nreturn sclp_tty_driver;\r\n}\r\nstatic void\r\nsclp_console_flush(void)\r\n{\r\nsclp_conbuf_emit();\r\nsclp_console_sync_queue();\r\n}\r\nstatic void sclp_console_resume(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sclp_con_lock, flags);\r\nsclp_con_suspended = 0;\r\nspin_unlock_irqrestore(&sclp_con_lock, flags);\r\nsclp_conbuf_emit();\r\n}\r\nstatic void sclp_console_suspend(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sclp_con_lock, flags);\r\nsclp_con_suspended = 1;\r\nspin_unlock_irqrestore(&sclp_con_lock, flags);\r\nsclp_console_flush();\r\n}\r\nstatic int sclp_console_notify(struct notifier_block *self,\r\nunsigned long event, void *data)\r\n{\r\nsclp_console_flush();\r\nreturn NOTIFY_OK;\r\n}\r\nvoid sclp_console_pm_event(enum sclp_pm_event sclp_pm_event)\r\n{\r\nswitch (sclp_pm_event) {\r\ncase SCLP_PM_EVENT_FREEZE:\r\nsclp_console_suspend();\r\nbreak;\r\ncase SCLP_PM_EVENT_RESTORE:\r\ncase SCLP_PM_EVENT_THAW:\r\nsclp_console_resume();\r\nbreak;\r\n}\r\n}\r\nstatic int __init\r\nsclp_console_init(void)\r\n{\r\nvoid *page;\r\nint i;\r\nint rc;\r\nif (!CONSOLE_IS_SCLP)\r\nreturn 0;\r\nrc = sclp_rw_init();\r\nif (rc)\r\nreturn rc;\r\nINIT_LIST_HEAD(&sclp_con_pages);\r\nfor (i = 0; i < MAX_CONSOLE_PAGES; i++) {\r\npage = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nlist_add_tail(page, &sclp_con_pages);\r\n}\r\nINIT_LIST_HEAD(&sclp_con_outqueue);\r\nspin_lock_init(&sclp_con_lock);\r\nsclp_conbuf = NULL;\r\ninit_timer(&sclp_con_timer);\r\nif (MACHINE_IS_VM)\r\nsclp_con_columns = 76;\r\nelse\r\nsclp_con_columns = 80;\r\nsclp_con_width_htab = 8;\r\natomic_notifier_chain_register(&panic_notifier_list, &on_panic_nb);\r\nregister_reboot_notifier(&on_reboot_nb);\r\nregister_console(&sclp_console);\r\nreturn 0;\r\n}
