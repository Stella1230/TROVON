static inline struct bt819 *to_bt819(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct bt819, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct bt819, hdl)->sd;\r\n}\r\nstatic inline int bt819_write(struct bt819 *decoder, u8 reg, u8 value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&decoder->sd);\r\ndecoder->reg[reg] = value;\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic inline int bt819_setbit(struct bt819 *decoder, u8 reg, u8 bit, u8 value)\r\n{\r\nreturn bt819_write(decoder, reg,\r\n(decoder->reg[reg] & ~(1 << bit)) | (value ? (1 << bit) : 0));\r\n}\r\nstatic int bt819_write_block(struct bt819 *decoder, const u8 *data, unsigned int len)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&decoder->sd);\r\nint ret = -1;\r\nu8 reg;\r\nif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\nu8 block_data[32];\r\nint block_len;\r\nwhile (len >= 2) {\r\nblock_len = 0;\r\nblock_data[block_len++] = reg = data[0];\r\ndo {\r\nblock_data[block_len++] =\r\ndecoder->reg[reg++] = data[1];\r\nlen -= 2;\r\ndata += 2;\r\n} while (len >= 2 && data[0] == reg && block_len < 32);\r\nret = i2c_master_send(client, block_data, block_len);\r\nif (ret < 0)\r\nbreak;\r\n}\r\n} else {\r\nwhile (len >= 2) {\r\nreg = *data++;\r\nret = bt819_write(decoder, reg, *data++);\r\nif (ret < 0)\r\nbreak;\r\nlen -= 2;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic inline int bt819_read(struct bt819 *decoder, u8 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&decoder->sd);\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int bt819_init(struct v4l2_subdev *sd)\r\n{\r\nstatic unsigned char init[] = {\r\n0x01, 0x59,\r\n0x02, 0x00,\r\n0x03, 0x12,\r\n0x04, 0x16,\r\n0x05, 0xe0,\r\n0x06, 0x80,\r\n0x07, 0xd0,\r\n0x08, 0x00,\r\n0x09, 0xf8,\r\n0x0a, 0x00,\r\n0x0b, 0x30,\r\n0x0c, 0xd8,\r\n0x0d, 0xfe,\r\n0x0e, 0xb4,\r\n0x0f, 0x00,\r\n0x12, 0x04,\r\n0x13, 0x20,\r\n0x14, 0x00,\r\n0x16, 0x07,\r\n0x18, 0x68,\r\n0x19, 0x5d,\r\n0x1a, 0x80,\r\n};\r\nstruct bt819 *decoder = to_bt819(sd);\r\nstruct timing *timing = &timing_data[(decoder->norm & V4L2_STD_525_60) ? 1 : 0];\r\ninit[0x03 * 2 - 1] =\r\n(((timing->vdelay >> 8) & 0x03) << 6) |\r\n(((timing->vactive >> 8) & 0x03) << 4) |\r\n(((timing->hdelay >> 8) & 0x03) << 2) |\r\n((timing->hactive >> 8) & 0x03);\r\ninit[0x04 * 2 - 1] = timing->vdelay & 0xff;\r\ninit[0x05 * 2 - 1] = timing->vactive & 0xff;\r\ninit[0x06 * 2 - 1] = timing->hdelay & 0xff;\r\ninit[0x07 * 2 - 1] = timing->hactive & 0xff;\r\ninit[0x08 * 2 - 1] = timing->hscale >> 8;\r\ninit[0x09 * 2 - 1] = timing->hscale & 0xff;\r\ninit[0x15 * 2 - 1] = (decoder->norm & V4L2_STD_625_50) ? 115 : 93;\r\nbt819_write(decoder, 0x1f, 0x00);\r\nmdelay(1);\r\nreturn bt819_write_block(decoder, init, sizeof(init));\r\n}\r\nstatic int bt819_status(struct v4l2_subdev *sd, u32 *pstatus, v4l2_std_id *pstd)\r\n{\r\nstruct bt819 *decoder = to_bt819(sd);\r\nint status = bt819_read(decoder, 0x00);\r\nint res = V4L2_IN_ST_NO_SIGNAL;\r\nv4l2_std_id std;\r\nif ((status & 0x80))\r\nres = 0;\r\nif ((status & 0x10))\r\nstd = V4L2_STD_PAL;\r\nelse\r\nstd = V4L2_STD_NTSC;\r\nif (pstd)\r\n*pstd = std;\r\nif (pstatus)\r\n*pstatus = res;\r\nv4l2_dbg(1, debug, sd, "get status %x\n", status);\r\nreturn 0;\r\n}\r\nstatic int bt819_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\r\n{\r\nreturn bt819_status(sd, NULL, std);\r\n}\r\nstatic int bt819_g_input_status(struct v4l2_subdev *sd, u32 *status)\r\n{\r\nreturn bt819_status(sd, status, NULL);\r\n}\r\nstatic int bt819_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct bt819 *decoder = to_bt819(sd);\r\nstruct timing *timing = NULL;\r\nv4l2_dbg(1, debug, sd, "set norm %llx\n", (unsigned long long)std);\r\nif (sd->v4l2_dev == NULL || sd->v4l2_dev->notify == NULL)\r\nv4l2_err(sd, "no notify found!\n");\r\nif (std & V4L2_STD_NTSC) {\r\nv4l2_subdev_notify(sd, BT819_FIFO_RESET_LOW, NULL);\r\nbt819_setbit(decoder, 0x01, 0, 1);\r\nbt819_setbit(decoder, 0x01, 1, 0);\r\nbt819_setbit(decoder, 0x01, 5, 0);\r\nbt819_write(decoder, 0x18, 0x68);\r\nbt819_write(decoder, 0x19, 0x5d);\r\ntiming = &timing_data[1];\r\n} else if (std & V4L2_STD_PAL) {\r\nv4l2_subdev_notify(sd, BT819_FIFO_RESET_LOW, NULL);\r\nbt819_setbit(decoder, 0x01, 0, 1);\r\nbt819_setbit(decoder, 0x01, 1, 1);\r\nbt819_setbit(decoder, 0x01, 5, 1);\r\nbt819_write(decoder, 0x18, 0x7f);\r\nbt819_write(decoder, 0x19, 0x72);\r\ntiming = &timing_data[0];\r\n} else {\r\nv4l2_dbg(1, debug, sd, "unsupported norm %llx\n",\r\n(unsigned long long)std);\r\nreturn -EINVAL;\r\n}\r\nbt819_write(decoder, 0x03,\r\n(((timing->vdelay >> 8) & 0x03) << 6) |\r\n(((timing->vactive >> 8) & 0x03) << 4) |\r\n(((timing->hdelay >> 8) & 0x03) << 2) |\r\n((timing->hactive >> 8) & 0x03));\r\nbt819_write(decoder, 0x04, timing->vdelay & 0xff);\r\nbt819_write(decoder, 0x05, timing->vactive & 0xff);\r\nbt819_write(decoder, 0x06, timing->hdelay & 0xff);\r\nbt819_write(decoder, 0x07, timing->hactive & 0xff);\r\nbt819_write(decoder, 0x08, (timing->hscale >> 8) & 0xff);\r\nbt819_write(decoder, 0x09, timing->hscale & 0xff);\r\ndecoder->norm = std;\r\nv4l2_subdev_notify(sd, BT819_FIFO_RESET_HIGH, NULL);\r\nreturn 0;\r\n}\r\nstatic int bt819_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct bt819 *decoder = to_bt819(sd);\r\nv4l2_dbg(1, debug, sd, "set input %x\n", input);\r\nif (input > 7)\r\nreturn -EINVAL;\r\nif (sd->v4l2_dev == NULL || sd->v4l2_dev->notify == NULL)\r\nv4l2_err(sd, "no notify found!\n");\r\nif (decoder->input != input) {\r\nv4l2_subdev_notify(sd, BT819_FIFO_RESET_LOW, NULL);\r\ndecoder->input = input;\r\nif (decoder->input == 0) {\r\nbt819_setbit(decoder, 0x0b, 6, 0);\r\nbt819_setbit(decoder, 0x1a, 1, 1);\r\n} else {\r\nbt819_setbit(decoder, 0x0b, 6, 1);\r\nbt819_setbit(decoder, 0x1a, 1, 0);\r\n}\r\nv4l2_subdev_notify(sd, BT819_FIFO_RESET_HIGH, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bt819_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct bt819 *decoder = to_bt819(sd);\r\nv4l2_dbg(1, debug, sd, "enable output %x\n", enable);\r\nif (decoder->enable != enable) {\r\ndecoder->enable = enable;\r\nbt819_setbit(decoder, 0x16, 7, !enable);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bt819_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct bt819 *decoder = to_bt819(sd);\r\nint temp;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nbt819_write(decoder, 0x0a, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nbt819_write(decoder, 0x0c, ctrl->val & 0xff);\r\nbt819_setbit(decoder, 0x0b, 2, ((ctrl->val >> 8) & 0x01));\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nbt819_write(decoder, 0x0d, (ctrl->val >> 7) & 0xff);\r\nbt819_setbit(decoder, 0x0b, 1, ((ctrl->val >> 15) & 0x01));\r\ntemp = (ctrl->val * 180) / 254;\r\nbt819_write(decoder, 0x0e, (temp >> 7) & 0xff);\r\nbt819_setbit(decoder, 0x0b, 0, (temp >> 15) & 0x01);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nbt819_write(decoder, 0x0f, ctrl->val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bt819_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct bt819 *decoder = to_bt819(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, decoder->ident, 0);\r\n}\r\nstatic int bt819_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint i, ver;\r\nstruct bt819 *decoder;\r\nstruct v4l2_subdev *sd;\r\nconst char *name;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\ndecoder = kzalloc(sizeof(struct bt819), GFP_KERNEL);\r\nif (decoder == NULL)\r\nreturn -ENOMEM;\r\nsd = &decoder->sd;\r\nv4l2_i2c_subdev_init(sd, client, &bt819_ops);\r\nver = bt819_read(decoder, 0x17);\r\nswitch (ver & 0xf0) {\r\ncase 0x70:\r\nname = "bt819a";\r\ndecoder->ident = V4L2_IDENT_BT819A;\r\nbreak;\r\ncase 0x60:\r\nname = "bt817a";\r\ndecoder->ident = V4L2_IDENT_BT817A;\r\nbreak;\r\ncase 0x20:\r\nname = "bt815a";\r\ndecoder->ident = V4L2_IDENT_BT815A;\r\nbreak;\r\ndefault:\r\nv4l2_dbg(1, debug, sd,\r\n"unknown chip version 0x%02x\n", ver);\r\nreturn -ENODEV;\r\n}\r\nv4l_info(client, "%s found @ 0x%x (%s)\n", name,\r\nclient->addr << 1, client->adapter->name);\r\ndecoder->norm = V4L2_STD_NTSC;\r\ndecoder->input = 0;\r\ndecoder->enable = 1;\r\ni = bt819_init(sd);\r\nif (i < 0)\r\nv4l2_dbg(1, debug, sd, "init status %d\n", i);\r\nv4l2_ctrl_handler_init(&decoder->hdl, 4);\r\nv4l2_ctrl_new_std(&decoder->hdl, &bt819_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(&decoder->hdl, &bt819_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 511, 1, 0xd8);\r\nv4l2_ctrl_new_std(&decoder->hdl, &bt819_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 511, 1, 0xfe);\r\nv4l2_ctrl_new_std(&decoder->hdl, &bt819_ctrl_ops,\r\nV4L2_CID_HUE, -128, 127, 1, 0);\r\nsd->ctrl_handler = &decoder->hdl;\r\nif (decoder->hdl.error) {\r\nint err = decoder->hdl.error;\r\nv4l2_ctrl_handler_free(&decoder->hdl);\r\nkfree(decoder);\r\nreturn err;\r\n}\r\nv4l2_ctrl_handler_setup(&decoder->hdl);\r\nreturn 0;\r\n}\r\nstatic int bt819_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct bt819 *decoder = to_bt819(sd);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&decoder->hdl);\r\nkfree(decoder);\r\nreturn 0;\r\n}\r\nstatic __init int init_bt819(void)\r\n{\r\nreturn i2c_add_driver(&bt819_driver);\r\n}\r\nstatic __exit void exit_bt819(void)\r\n{\r\ni2c_del_driver(&bt819_driver);\r\n}
