static int xfrm4_tunnel_check_size(struct sk_buff *skb)\r\n{\r\nint mtu, ret = 0;\r\nstruct dst_entry *dst;\r\nif (IPCB(skb)->flags & IPSKB_XFRM_TUNNEL_SIZE)\r\ngoto out;\r\nif (!(ip_hdr(skb)->frag_off & htons(IP_DF)) || skb->local_df)\r\ngoto out;\r\ndst = skb_dst(skb);\r\nmtu = dst_mtu(dst);\r\nif (skb->len > mtu) {\r\nif (skb->sk)\r\nip_local_error(skb->sk, EMSGSIZE, ip_hdr(skb)->daddr,\r\ninet_sk(skb->sk)->inet_dport, mtu);\r\nelse\r\nicmp_send(skb, ICMP_DEST_UNREACH,\r\nICMP_FRAG_NEEDED, htonl(mtu));\r\nret = -EMSGSIZE;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nint xfrm4_extract_output(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nint err;\r\nerr = xfrm4_tunnel_check_size(skb);\r\nif (err)\r\nreturn err;\r\nXFRM_MODE_SKB_CB(skb)->protocol = ip_hdr(skb)->protocol;\r\nreturn xfrm4_extract_header(skb);\r\n}\r\nint xfrm4_prepare_output(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nint err;\r\nerr = xfrm_inner_extract_output(x, skb);\r\nif (err)\r\nreturn err;\r\nmemset(IPCB(skb), 0, sizeof(*IPCB(skb)));\r\nIPCB(skb)->flags |= IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED;\r\nskb->protocol = htons(ETH_P_IP);\r\nreturn x->outer_mode->output2(x, skb);\r\n}\r\nint xfrm4_output_finish(struct sk_buff *skb)\r\n{\r\n#ifdef CONFIG_NETFILTER\r\nif (!skb_dst(skb)->xfrm) {\r\nIPCB(skb)->flags |= IPSKB_REROUTED;\r\nreturn dst_output(skb);\r\n}\r\nIPCB(skb)->flags |= IPSKB_XFRM_TRANSFORMED;\r\n#endif\r\nskb->protocol = htons(ETH_P_IP);\r\nreturn xfrm_output(skb);\r\n}\r\nint xfrm4_output(struct sk_buff *skb)\r\n{\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct xfrm_state *x = dst->xfrm;\r\nreturn NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING, skb,\r\nNULL, dst->dev,\r\nx->outer_mode->afinfo->output_finish,\r\n!(IPCB(skb)->flags & IPSKB_REROUTED));\r\n}
