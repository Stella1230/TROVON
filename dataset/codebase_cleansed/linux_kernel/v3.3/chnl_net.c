static void robust_list_del(struct list_head *delete_node)\r\n{\r\nstruct list_head *list_node;\r\nstruct list_head *n;\r\nASSERT_RTNL();\r\nlist_for_each_safe(list_node, n, &chnl_net_list) {\r\nif (list_node == delete_node) {\r\nlist_del(list_node);\r\nreturn;\r\n}\r\n}\r\nWARN_ON(1);\r\n}\r\nstatic int chnl_recv_cb(struct cflayer *layr, struct cfpkt *pkt)\r\n{\r\nstruct sk_buff *skb;\r\nstruct chnl_net *priv = container_of(layr, struct chnl_net, chnl);\r\nint pktlen;\r\nint err = 0;\r\nconst u8 *ip_version;\r\nu8 buf;\r\npriv = container_of(layr, struct chnl_net, chnl);\r\nif (!priv)\r\nreturn -EINVAL;\r\nskb = (struct sk_buff *) cfpkt_tonative(pkt);\r\npktlen = skb->len;\r\nskb->dev = priv->netdev;\r\nip_version = skb_header_pointer(skb, 0, 1, &buf);\r\nif (!ip_version)\r\nreturn -EINVAL;\r\nswitch (*ip_version >> 4) {\r\ncase 4:\r\nskb->protocol = htons(ETH_P_IP);\r\nbreak;\r\ncase 6:\r\nskb->protocol = htons(ETH_P_IPV6);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (priv->conn_req.protocol == CAIFPROTO_DATAGRAM_LOOP)\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nelse\r\nskb->ip_summed = CHECKSUM_NONE;\r\nif (in_interrupt())\r\nnetif_rx(skb);\r\nelse\r\nnetif_rx_ni(skb);\r\npriv->netdev->stats.rx_packets++;\r\npriv->netdev->stats.rx_bytes += pktlen;\r\nreturn err;\r\n}\r\nstatic int delete_device(struct chnl_net *dev)\r\n{\r\nASSERT_RTNL();\r\nif (dev->netdev)\r\nunregister_netdevice(dev->netdev);\r\nreturn 0;\r\n}\r\nstatic void close_work(struct work_struct *work)\r\n{\r\nstruct chnl_net *dev = NULL;\r\nstruct list_head *list_node;\r\nstruct list_head *_tmp;\r\nrtnl_lock();\r\nlist_for_each_safe(list_node, _tmp, &chnl_net_list) {\r\ndev = list_entry(list_node, struct chnl_net, list_field);\r\nif (dev->state == CAIF_SHUTDOWN)\r\ndev_close(dev->netdev);\r\n}\r\nrtnl_unlock();\r\n}\r\nstatic void chnl_hold(struct cflayer *lyr)\r\n{\r\nstruct chnl_net *priv = container_of(lyr, struct chnl_net, chnl);\r\ndev_hold(priv->netdev);\r\n}\r\nstatic void chnl_put(struct cflayer *lyr)\r\n{\r\nstruct chnl_net *priv = container_of(lyr, struct chnl_net, chnl);\r\ndev_put(priv->netdev);\r\n}\r\nstatic void chnl_flowctrl_cb(struct cflayer *layr, enum caif_ctrlcmd flow,\r\nint phyid)\r\n{\r\nstruct chnl_net *priv = container_of(layr, struct chnl_net, chnl);\r\npr_debug("NET flowctrl func called flow: %s\n",\r\nflow == CAIF_CTRLCMD_FLOW_ON_IND ? "ON" :\r\nflow == CAIF_CTRLCMD_INIT_RSP ? "INIT" :\r\nflow == CAIF_CTRLCMD_FLOW_OFF_IND ? "OFF" :\r\nflow == CAIF_CTRLCMD_DEINIT_RSP ? "CLOSE/DEINIT" :\r\nflow == CAIF_CTRLCMD_INIT_FAIL_RSP ? "OPEN_FAIL" :\r\nflow == CAIF_CTRLCMD_REMOTE_SHUTDOWN_IND ?\r\n"REMOTE_SHUTDOWN" : "UKNOWN CTRL COMMAND");\r\nswitch (flow) {\r\ncase CAIF_CTRLCMD_FLOW_OFF_IND:\r\npriv->flowenabled = false;\r\nnetif_stop_queue(priv->netdev);\r\nbreak;\r\ncase CAIF_CTRLCMD_DEINIT_RSP:\r\npriv->state = CAIF_DISCONNECTED;\r\nbreak;\r\ncase CAIF_CTRLCMD_INIT_FAIL_RSP:\r\npriv->state = CAIF_DISCONNECTED;\r\nwake_up_interruptible(&priv->netmgmt_wq);\r\nbreak;\r\ncase CAIF_CTRLCMD_REMOTE_SHUTDOWN_IND:\r\npriv->state = CAIF_SHUTDOWN;\r\nnetif_tx_disable(priv->netdev);\r\nschedule_work(&close_worker);\r\nbreak;\r\ncase CAIF_CTRLCMD_FLOW_ON_IND:\r\npriv->flowenabled = true;\r\nnetif_wake_queue(priv->netdev);\r\nbreak;\r\ncase CAIF_CTRLCMD_INIT_RSP:\r\ncaif_client_register_refcnt(&priv->chnl, chnl_hold, chnl_put);\r\npriv->state = CAIF_CONNECTED;\r\npriv->flowenabled = true;\r\nnetif_wake_queue(priv->netdev);\r\nwake_up_interruptible(&priv->netmgmt_wq);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int chnl_net_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct chnl_net *priv;\r\nstruct cfpkt *pkt = NULL;\r\nint len;\r\nint result = -1;\r\npriv = netdev_priv(dev);\r\nif (skb->len > priv->netdev->mtu) {\r\npr_warn("Size of skb exceeded MTU\n");\r\nreturn -ENOSPC;\r\n}\r\nif (!priv->flowenabled) {\r\npr_debug("dropping packets flow off\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (priv->conn_req.protocol == CAIFPROTO_DATAGRAM_LOOP)\r\nswap(ip_hdr(skb)->saddr, ip_hdr(skb)->daddr);\r\nlen = skb->len;\r\npkt = cfpkt_fromnative(CAIF_DIR_OUT, (void *) skb);\r\nresult = priv->chnl.dn->transmit(priv->chnl.dn, pkt);\r\nif (result) {\r\nif (result == -EAGAIN)\r\nresult = NETDEV_TX_BUSY;\r\nreturn result;\r\n}\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += len;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int chnl_net_open(struct net_device *dev)\r\n{\r\nstruct chnl_net *priv = NULL;\r\nint result = -1;\r\nint llifindex, headroom, tailroom, mtu;\r\nstruct net_device *lldev;\r\nASSERT_RTNL();\r\npriv = netdev_priv(dev);\r\nif (!priv) {\r\npr_debug("chnl_net_open: no priv\n");\r\nreturn -ENODEV;\r\n}\r\nif (priv->state != CAIF_CONNECTING) {\r\npriv->state = CAIF_CONNECTING;\r\nresult = caif_connect_client(dev_net(dev), &priv->conn_req,\r\n&priv->chnl, &llifindex,\r\n&headroom, &tailroom);\r\nif (result != 0) {\r\npr_debug("err: "\r\n"Unable to register and open device,"\r\n" Err:%d\n",\r\nresult);\r\ngoto error;\r\n}\r\nlldev = dev_get_by_index(dev_net(dev), llifindex);\r\nif (lldev == NULL) {\r\npr_debug("no interface?\n");\r\nresult = -ENODEV;\r\ngoto error;\r\n}\r\ndev->needed_tailroom = tailroom + lldev->needed_tailroom;\r\ndev->hard_header_len = headroom + lldev->hard_header_len +\r\nlldev->needed_tailroom;\r\nmtu = min_t(int, dev->mtu, lldev->mtu - (headroom + tailroom));\r\nmtu = min_t(int, GPRS_PDP_MTU, mtu);\r\ndev_set_mtu(dev, mtu);\r\ndev_put(lldev);\r\nif (mtu < 100) {\r\npr_warn("CAIF Interface MTU too small (%d)\n", mtu);\r\nresult = -ENODEV;\r\ngoto error;\r\n}\r\n}\r\nrtnl_unlock();\r\nresult = wait_event_interruptible_timeout(priv->netmgmt_wq,\r\npriv->state != CAIF_CONNECTING,\r\nCONNECT_TIMEOUT);\r\nrtnl_lock();\r\nif (result == -ERESTARTSYS) {\r\npr_debug("wait_event_interruptible woken by a signal\n");\r\nresult = -ERESTARTSYS;\r\ngoto error;\r\n}\r\nif (result == 0) {\r\npr_debug("connect timeout\n");\r\ncaif_disconnect_client(dev_net(dev), &priv->chnl);\r\npriv->state = CAIF_DISCONNECTED;\r\npr_debug("state disconnected\n");\r\nresult = -ETIMEDOUT;\r\ngoto error;\r\n}\r\nif (priv->state != CAIF_CONNECTED) {\r\npr_debug("connect failed\n");\r\nresult = -ECONNREFUSED;\r\ngoto error;\r\n}\r\npr_debug("CAIF Netdevice connected\n");\r\nreturn 0;\r\nerror:\r\ncaif_disconnect_client(dev_net(dev), &priv->chnl);\r\npriv->state = CAIF_DISCONNECTED;\r\npr_debug("state disconnected\n");\r\nreturn result;\r\n}\r\nstatic int chnl_net_stop(struct net_device *dev)\r\n{\r\nstruct chnl_net *priv;\r\nASSERT_RTNL();\r\npriv = netdev_priv(dev);\r\npriv->state = CAIF_DISCONNECTED;\r\ncaif_disconnect_client(dev_net(dev), &priv->chnl);\r\nreturn 0;\r\n}\r\nstatic int chnl_net_init(struct net_device *dev)\r\n{\r\nstruct chnl_net *priv;\r\nASSERT_RTNL();\r\npriv = netdev_priv(dev);\r\nstrncpy(priv->name, dev->name, sizeof(priv->name));\r\nreturn 0;\r\n}\r\nstatic void chnl_net_uninit(struct net_device *dev)\r\n{\r\nstruct chnl_net *priv;\r\nASSERT_RTNL();\r\npriv = netdev_priv(dev);\r\nrobust_list_del(&priv->list_field);\r\n}\r\nstatic void chnl_net_destructor(struct net_device *dev)\r\n{\r\nstruct chnl_net *priv = netdev_priv(dev);\r\ncaif_free_client(&priv->chnl);\r\nfree_netdev(dev);\r\n}\r\nstatic void ipcaif_net_setup(struct net_device *dev)\r\n{\r\nstruct chnl_net *priv;\r\ndev->netdev_ops = &netdev_ops;\r\ndev->destructor = chnl_net_destructor;\r\ndev->flags |= IFF_NOARP;\r\ndev->flags |= IFF_POINTOPOINT;\r\ndev->mtu = GPRS_PDP_MTU;\r\ndev->tx_queue_len = CAIF_NET_DEFAULT_QUEUE_LEN;\r\npriv = netdev_priv(dev);\r\npriv->chnl.receive = chnl_recv_cb;\r\npriv->chnl.ctrlcmd = chnl_flowctrl_cb;\r\npriv->netdev = dev;\r\npriv->conn_req.protocol = CAIFPROTO_DATAGRAM;\r\npriv->conn_req.link_selector = CAIF_LINK_HIGH_BANDW;\r\npriv->conn_req.priority = CAIF_PRIO_LOW;\r\npriv->conn_req.sockaddr.u.dgm.connection_id = 0;\r\npriv->flowenabled = false;\r\ninit_waitqueue_head(&priv->netmgmt_wq);\r\n}\r\nstatic int ipcaif_fill_info(struct sk_buff *skb, const struct net_device *dev)\r\n{\r\nstruct chnl_net *priv;\r\nu8 loop;\r\npriv = netdev_priv(dev);\r\nNLA_PUT_U32(skb, IFLA_CAIF_IPV4_CONNID,\r\npriv->conn_req.sockaddr.u.dgm.connection_id);\r\nNLA_PUT_U32(skb, IFLA_CAIF_IPV6_CONNID,\r\npriv->conn_req.sockaddr.u.dgm.connection_id);\r\nloop = priv->conn_req.protocol == CAIFPROTO_DATAGRAM_LOOP;\r\nNLA_PUT_U8(skb, IFLA_CAIF_LOOPBACK, loop);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic void caif_netlink_parms(struct nlattr *data[],\r\nstruct caif_connect_request *conn_req)\r\n{\r\nif (!data) {\r\npr_warn("no params data found\n");\r\nreturn;\r\n}\r\nif (data[IFLA_CAIF_IPV4_CONNID])\r\nconn_req->sockaddr.u.dgm.connection_id =\r\nnla_get_u32(data[IFLA_CAIF_IPV4_CONNID]);\r\nif (data[IFLA_CAIF_IPV6_CONNID])\r\nconn_req->sockaddr.u.dgm.connection_id =\r\nnla_get_u32(data[IFLA_CAIF_IPV6_CONNID]);\r\nif (data[IFLA_CAIF_LOOPBACK]) {\r\nif (nla_get_u8(data[IFLA_CAIF_LOOPBACK]))\r\nconn_req->protocol = CAIFPROTO_DATAGRAM_LOOP;\r\nelse\r\nconn_req->protocol = CAIFPROTO_DATAGRAM;\r\n}\r\n}\r\nstatic int ipcaif_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nint ret;\r\nstruct chnl_net *caifdev;\r\nASSERT_RTNL();\r\ncaifdev = netdev_priv(dev);\r\ncaif_netlink_parms(data, &caifdev->conn_req);\r\ndev_net_set(caifdev->netdev, src_net);\r\nret = register_netdevice(dev);\r\nif (ret)\r\npr_warn("device rtml registration failed\n");\r\nelse\r\nlist_add(&caifdev->list_field, &chnl_net_list);\r\nif (caifdev->conn_req.sockaddr.u.dgm.connection_id == 0)\r\ncaifdev->conn_req.sockaddr.u.dgm.connection_id = dev->ifindex;\r\nreturn ret;\r\n}\r\nstatic int ipcaif_changelink(struct net_device *dev, struct nlattr *tb[],\r\nstruct nlattr *data[])\r\n{\r\nstruct chnl_net *caifdev;\r\nASSERT_RTNL();\r\ncaifdev = netdev_priv(dev);\r\ncaif_netlink_parms(data, &caifdev->conn_req);\r\nnetdev_state_change(dev);\r\nreturn 0;\r\n}\r\nstatic size_t ipcaif_get_size(const struct net_device *dev)\r\n{\r\nreturn\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(2) +\r\n0;\r\n}\r\nstatic int __init chnl_init_module(void)\r\n{\r\nreturn rtnl_link_register(&ipcaif_link_ops);\r\n}\r\nstatic void __exit chnl_exit_module(void)\r\n{\r\nstruct chnl_net *dev = NULL;\r\nstruct list_head *list_node;\r\nstruct list_head *_tmp;\r\nrtnl_link_unregister(&ipcaif_link_ops);\r\nrtnl_lock();\r\nlist_for_each_safe(list_node, _tmp, &chnl_net_list) {\r\ndev = list_entry(list_node, struct chnl_net, list_field);\r\nlist_del(list_node);\r\ndelete_device(dev);\r\n}\r\nrtnl_unlock();\r\n}
