static int amixer_master(struct rsc *rsc)\r\n{\r\nrsc->conj = 0;\r\nreturn rsc->idx = container_of(rsc, struct amixer, rsc)->idx[0];\r\n}\r\nstatic int amixer_next_conj(struct rsc *rsc)\r\n{\r\nrsc->conj++;\r\nreturn container_of(rsc, struct amixer, rsc)->idx[rsc->conj];\r\n}\r\nstatic int amixer_index(const struct rsc *rsc)\r\n{\r\nreturn container_of(rsc, struct amixer, rsc)->idx[rsc->conj];\r\n}\r\nstatic int amixer_output_slot(const struct rsc *rsc)\r\n{\r\nreturn (amixer_index(rsc) << 4) + 0x4;\r\n}\r\nstatic int amixer_set_input(struct amixer *amixer, struct rsc *rsc)\r\n{\r\nstruct hw *hw;\r\nhw = amixer->rsc.hw;\r\nhw->amixer_set_mode(amixer->rsc.ctrl_blk, AMIXER_Y_IMMEDIATE);\r\namixer->input = rsc;\r\nif (!rsc)\r\nhw->amixer_set_x(amixer->rsc.ctrl_blk, BLANK_SLOT);\r\nelse\r\nhw->amixer_set_x(amixer->rsc.ctrl_blk,\r\nrsc->ops->output_slot(rsc));\r\nreturn 0;\r\n}\r\nstatic int amixer_set_y(struct amixer *amixer, unsigned int y)\r\n{\r\nstruct hw *hw;\r\nhw = amixer->rsc.hw;\r\nhw->amixer_set_y(amixer->rsc.ctrl_blk, y);\r\nreturn 0;\r\n}\r\nstatic int amixer_set_invalid_squash(struct amixer *amixer, unsigned int iv)\r\n{\r\nstruct hw *hw;\r\nhw = amixer->rsc.hw;\r\nhw->amixer_set_iv(amixer->rsc.ctrl_blk, iv);\r\nreturn 0;\r\n}\r\nstatic int amixer_set_sum(struct amixer *amixer, struct sum *sum)\r\n{\r\nstruct hw *hw;\r\nhw = amixer->rsc.hw;\r\namixer->sum = sum;\r\nif (!sum) {\r\nhw->amixer_set_se(amixer->rsc.ctrl_blk, 0);\r\n} else {\r\nhw->amixer_set_se(amixer->rsc.ctrl_blk, 1);\r\nhw->amixer_set_sadr(amixer->rsc.ctrl_blk,\r\nsum->rsc.ops->index(&sum->rsc));\r\n}\r\nreturn 0;\r\n}\r\nstatic int amixer_commit_write(struct amixer *amixer)\r\n{\r\nstruct hw *hw;\r\nunsigned int index;\r\nint i;\r\nstruct rsc *input;\r\nstruct sum *sum;\r\nhw = amixer->rsc.hw;\r\ninput = amixer->input;\r\nsum = amixer->sum;\r\namixer->rsc.ops->master(&amixer->rsc);\r\nif (input)\r\ninput->ops->master(input);\r\nif (sum)\r\nsum->rsc.ops->master(&sum->rsc);\r\nfor (i = 0; i < amixer->rsc.msr; i++) {\r\nhw->amixer_set_dirty_all(amixer->rsc.ctrl_blk);\r\nif (input) {\r\nhw->amixer_set_x(amixer->rsc.ctrl_blk,\r\ninput->ops->output_slot(input));\r\ninput->ops->next_conj(input);\r\n}\r\nif (sum) {\r\nhw->amixer_set_sadr(amixer->rsc.ctrl_blk,\r\nsum->rsc.ops->index(&sum->rsc));\r\nsum->rsc.ops->next_conj(&sum->rsc);\r\n}\r\nindex = amixer->rsc.ops->output_slot(&amixer->rsc);\r\nhw->amixer_commit_write(hw, index, amixer->rsc.ctrl_blk);\r\namixer->rsc.ops->next_conj(&amixer->rsc);\r\n}\r\namixer->rsc.ops->master(&amixer->rsc);\r\nif (input)\r\ninput->ops->master(input);\r\nif (sum)\r\nsum->rsc.ops->master(&sum->rsc);\r\nreturn 0;\r\n}\r\nstatic int amixer_commit_raw_write(struct amixer *amixer)\r\n{\r\nstruct hw *hw;\r\nunsigned int index;\r\nhw = amixer->rsc.hw;\r\nindex = amixer->rsc.ops->output_slot(&amixer->rsc);\r\nhw->amixer_commit_write(hw, index, amixer->rsc.ctrl_blk);\r\nreturn 0;\r\n}\r\nstatic int amixer_get_y(struct amixer *amixer)\r\n{\r\nstruct hw *hw;\r\nhw = amixer->rsc.hw;\r\nreturn hw->amixer_get_y(amixer->rsc.ctrl_blk);\r\n}\r\nstatic int amixer_setup(struct amixer *amixer, struct rsc *input,\r\nunsigned int scale, struct sum *sum)\r\n{\r\namixer_set_input(amixer, input);\r\namixer_set_y(amixer, scale);\r\namixer_set_sum(amixer, sum);\r\namixer_commit_write(amixer);\r\nreturn 0;\r\n}\r\nstatic int amixer_rsc_init(struct amixer *amixer,\r\nconst struct amixer_desc *desc,\r\nstruct amixer_mgr *mgr)\r\n{\r\nint err;\r\nerr = rsc_init(&amixer->rsc, amixer->idx[0],\r\nAMIXER, desc->msr, mgr->mgr.hw);\r\nif (err)\r\nreturn err;\r\namixer->rsc.ops = &amixer_basic_rsc_ops;\r\namixer->ops = &amixer_ops;\r\namixer->input = NULL;\r\namixer->sum = NULL;\r\namixer_setup(amixer, NULL, 0, NULL);\r\nreturn 0;\r\n}\r\nstatic int amixer_rsc_uninit(struct amixer *amixer)\r\n{\r\namixer_setup(amixer, NULL, 0, NULL);\r\nrsc_uninit(&amixer->rsc);\r\namixer->ops = NULL;\r\namixer->input = NULL;\r\namixer->sum = NULL;\r\nreturn 0;\r\n}\r\nstatic int get_amixer_rsc(struct amixer_mgr *mgr,\r\nconst struct amixer_desc *desc,\r\nstruct amixer **ramixer)\r\n{\r\nint err, i;\r\nunsigned int idx;\r\nstruct amixer *amixer;\r\nunsigned long flags;\r\n*ramixer = NULL;\r\namixer = kzalloc(sizeof(*amixer), GFP_KERNEL);\r\nif (!amixer)\r\nreturn -ENOMEM;\r\nerr = 0;\r\nspin_lock_irqsave(&mgr->mgr_lock, flags);\r\nfor (i = 0; i < desc->msr; i++) {\r\nerr = mgr_get_resource(&mgr->mgr, 1, &idx);\r\nif (err)\r\nbreak;\r\namixer->idx[i] = idx;\r\n}\r\nspin_unlock_irqrestore(&mgr->mgr_lock, flags);\r\nif (err) {\r\nprintk(KERN_ERR "ctxfi: Can't meet AMIXER resource request!\n");\r\ngoto error;\r\n}\r\nerr = amixer_rsc_init(amixer, desc, mgr);\r\nif (err)\r\ngoto error;\r\n*ramixer = amixer;\r\nreturn 0;\r\nerror:\r\nspin_lock_irqsave(&mgr->mgr_lock, flags);\r\nfor (i--; i >= 0; i--)\r\nmgr_put_resource(&mgr->mgr, 1, amixer->idx[i]);\r\nspin_unlock_irqrestore(&mgr->mgr_lock, flags);\r\nkfree(amixer);\r\nreturn err;\r\n}\r\nstatic int put_amixer_rsc(struct amixer_mgr *mgr, struct amixer *amixer)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&mgr->mgr_lock, flags);\r\nfor (i = 0; i < amixer->rsc.msr; i++)\r\nmgr_put_resource(&mgr->mgr, 1, amixer->idx[i]);\r\nspin_unlock_irqrestore(&mgr->mgr_lock, flags);\r\namixer_rsc_uninit(amixer);\r\nkfree(amixer);\r\nreturn 0;\r\n}\r\nint amixer_mgr_create(void *hw, struct amixer_mgr **ramixer_mgr)\r\n{\r\nint err;\r\nstruct amixer_mgr *amixer_mgr;\r\n*ramixer_mgr = NULL;\r\namixer_mgr = kzalloc(sizeof(*amixer_mgr), GFP_KERNEL);\r\nif (!amixer_mgr)\r\nreturn -ENOMEM;\r\nerr = rsc_mgr_init(&amixer_mgr->mgr, AMIXER, AMIXER_RESOURCE_NUM, hw);\r\nif (err)\r\ngoto error;\r\nspin_lock_init(&amixer_mgr->mgr_lock);\r\namixer_mgr->get_amixer = get_amixer_rsc;\r\namixer_mgr->put_amixer = put_amixer_rsc;\r\n*ramixer_mgr = amixer_mgr;\r\nreturn 0;\r\nerror:\r\nkfree(amixer_mgr);\r\nreturn err;\r\n}\r\nint amixer_mgr_destroy(struct amixer_mgr *amixer_mgr)\r\n{\r\nrsc_mgr_uninit(&amixer_mgr->mgr);\r\nkfree(amixer_mgr);\r\nreturn 0;\r\n}\r\nstatic int sum_master(struct rsc *rsc)\r\n{\r\nrsc->conj = 0;\r\nreturn rsc->idx = container_of(rsc, struct sum, rsc)->idx[0];\r\n}\r\nstatic int sum_next_conj(struct rsc *rsc)\r\n{\r\nrsc->conj++;\r\nreturn container_of(rsc, struct sum, rsc)->idx[rsc->conj];\r\n}\r\nstatic int sum_index(const struct rsc *rsc)\r\n{\r\nreturn container_of(rsc, struct sum, rsc)->idx[rsc->conj];\r\n}\r\nstatic int sum_output_slot(const struct rsc *rsc)\r\n{\r\nreturn (sum_index(rsc) << 4) + 0xc;\r\n}\r\nstatic int sum_rsc_init(struct sum *sum,\r\nconst struct sum_desc *desc,\r\nstruct sum_mgr *mgr)\r\n{\r\nint err;\r\nerr = rsc_init(&sum->rsc, sum->idx[0], SUM, desc->msr, mgr->mgr.hw);\r\nif (err)\r\nreturn err;\r\nsum->rsc.ops = &sum_basic_rsc_ops;\r\nreturn 0;\r\n}\r\nstatic int sum_rsc_uninit(struct sum *sum)\r\n{\r\nrsc_uninit(&sum->rsc);\r\nreturn 0;\r\n}\r\nstatic int get_sum_rsc(struct sum_mgr *mgr,\r\nconst struct sum_desc *desc,\r\nstruct sum **rsum)\r\n{\r\nint err, i;\r\nunsigned int idx;\r\nstruct sum *sum;\r\nunsigned long flags;\r\n*rsum = NULL;\r\nsum = kzalloc(sizeof(*sum), GFP_KERNEL);\r\nif (!sum)\r\nreturn -ENOMEM;\r\nerr = 0;\r\nspin_lock_irqsave(&mgr->mgr_lock, flags);\r\nfor (i = 0; i < desc->msr; i++) {\r\nerr = mgr_get_resource(&mgr->mgr, 1, &idx);\r\nif (err)\r\nbreak;\r\nsum->idx[i] = idx;\r\n}\r\nspin_unlock_irqrestore(&mgr->mgr_lock, flags);\r\nif (err) {\r\nprintk(KERN_ERR "ctxfi: Can't meet SUM resource request!\n");\r\ngoto error;\r\n}\r\nerr = sum_rsc_init(sum, desc, mgr);\r\nif (err)\r\ngoto error;\r\n*rsum = sum;\r\nreturn 0;\r\nerror:\r\nspin_lock_irqsave(&mgr->mgr_lock, flags);\r\nfor (i--; i >= 0; i--)\r\nmgr_put_resource(&mgr->mgr, 1, sum->idx[i]);\r\nspin_unlock_irqrestore(&mgr->mgr_lock, flags);\r\nkfree(sum);\r\nreturn err;\r\n}\r\nstatic int put_sum_rsc(struct sum_mgr *mgr, struct sum *sum)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&mgr->mgr_lock, flags);\r\nfor (i = 0; i < sum->rsc.msr; i++)\r\nmgr_put_resource(&mgr->mgr, 1, sum->idx[i]);\r\nspin_unlock_irqrestore(&mgr->mgr_lock, flags);\r\nsum_rsc_uninit(sum);\r\nkfree(sum);\r\nreturn 0;\r\n}\r\nint sum_mgr_create(void *hw, struct sum_mgr **rsum_mgr)\r\n{\r\nint err;\r\nstruct sum_mgr *sum_mgr;\r\n*rsum_mgr = NULL;\r\nsum_mgr = kzalloc(sizeof(*sum_mgr), GFP_KERNEL);\r\nif (!sum_mgr)\r\nreturn -ENOMEM;\r\nerr = rsc_mgr_init(&sum_mgr->mgr, SUM, SUM_RESOURCE_NUM, hw);\r\nif (err)\r\ngoto error;\r\nspin_lock_init(&sum_mgr->mgr_lock);\r\nsum_mgr->get_sum = get_sum_rsc;\r\nsum_mgr->put_sum = put_sum_rsc;\r\n*rsum_mgr = sum_mgr;\r\nreturn 0;\r\nerror:\r\nkfree(sum_mgr);\r\nreturn err;\r\n}\r\nint sum_mgr_destroy(struct sum_mgr *sum_mgr)\r\n{\r\nrsc_mgr_uninit(&sum_mgr->mgr);\r\nkfree(sum_mgr);\r\nreturn 0;\r\n}
