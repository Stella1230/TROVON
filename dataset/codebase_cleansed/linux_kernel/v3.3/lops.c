static void gfs2_pin(struct gfs2_sbd *sdp, struct buffer_head *bh)\r\n{\r\nstruct gfs2_bufdata *bd;\r\nBUG_ON(!current->journal_info);\r\nclear_buffer_dirty(bh);\r\nif (test_set_buffer_pinned(bh))\r\ngfs2_assert_withdraw(sdp, 0);\r\nif (!buffer_uptodate(bh))\r\ngfs2_io_error_bh(sdp, bh);\r\nbd = bh->b_private;\r\nspin_lock(&sdp->sd_ail_lock);\r\nif (bd->bd_ail)\r\nlist_move(&bd->bd_ail_st_list, &bd->bd_ail->ai_ail2_list);\r\nspin_unlock(&sdp->sd_ail_lock);\r\nget_bh(bh);\r\natomic_inc(&sdp->sd_log_pinned);\r\ntrace_gfs2_pin(bd, 1);\r\n}\r\nstatic bool buffer_is_rgrp(const struct gfs2_bufdata *bd)\r\n{\r\nreturn bd->bd_gl->gl_name.ln_type == LM_TYPE_RGRP;\r\n}\r\nstatic void maybe_release_space(struct gfs2_bufdata *bd)\r\n{\r\nstruct gfs2_glock *gl = bd->bd_gl;\r\nstruct gfs2_sbd *sdp = gl->gl_sbd;\r\nstruct gfs2_rgrpd *rgd = gl->gl_object;\r\nunsigned int index = bd->bd_bh->b_blocknr - gl->gl_name.ln_number;\r\nstruct gfs2_bitmap *bi = rgd->rd_bits + index;\r\nif (bi->bi_clone == 0)\r\nreturn;\r\nif (sdp->sd_args.ar_discard)\r\ngfs2_rgrp_send_discards(sdp, rgd->rd_data0, bd->bd_bh, bi);\r\nmemcpy(bi->bi_clone + bi->bi_offset,\r\nbd->bd_bh->b_data + bi->bi_offset, bi->bi_len);\r\nclear_bit(GBF_FULL, &bi->bi_flags);\r\nrgd->rd_free_clone = rgd->rd_free;\r\n}\r\nstatic void gfs2_unpin(struct gfs2_sbd *sdp, struct buffer_head *bh,\r\nstruct gfs2_ail *ai)\r\n{\r\nstruct gfs2_bufdata *bd = bh->b_private;\r\nBUG_ON(!buffer_uptodate(bh));\r\nBUG_ON(!buffer_pinned(bh));\r\nlock_buffer(bh);\r\nmark_buffer_dirty(bh);\r\nclear_buffer_pinned(bh);\r\nif (buffer_is_rgrp(bd))\r\nmaybe_release_space(bd);\r\nspin_lock(&sdp->sd_ail_lock);\r\nif (bd->bd_ail) {\r\nlist_del(&bd->bd_ail_st_list);\r\nbrelse(bh);\r\n} else {\r\nstruct gfs2_glock *gl = bd->bd_gl;\r\nlist_add(&bd->bd_ail_gl_list, &gl->gl_ail_list);\r\natomic_inc(&gl->gl_ail_count);\r\n}\r\nbd->bd_ail = ai;\r\nlist_add(&bd->bd_ail_st_list, &ai->ai_ail1_list);\r\nspin_unlock(&sdp->sd_ail_lock);\r\nclear_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\r\ntrace_gfs2_pin(bd, 0);\r\nunlock_buffer(bh);\r\natomic_dec(&sdp->sd_log_pinned);\r\n}\r\nstatic inline struct gfs2_log_descriptor *bh_log_desc(struct buffer_head *bh)\r\n{\r\nreturn (struct gfs2_log_descriptor *)bh->b_data;\r\n}\r\nstatic inline __be64 *bh_log_ptr(struct buffer_head *bh)\r\n{\r\nstruct gfs2_log_descriptor *ld = bh_log_desc(bh);\r\nreturn (__force __be64 *)(ld + 1);\r\n}\r\nstatic inline __be64 *bh_ptr_end(struct buffer_head *bh)\r\n{\r\nreturn (__force __be64 *)(bh->b_data + bh->b_size);\r\n}\r\nstatic struct buffer_head *gfs2_get_log_desc(struct gfs2_sbd *sdp, u32 ld_type)\r\n{\r\nstruct buffer_head *bh = gfs2_log_get_buf(sdp);\r\nstruct gfs2_log_descriptor *ld = bh_log_desc(bh);\r\nld->ld_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\r\nld->ld_header.mh_type = cpu_to_be32(GFS2_METATYPE_LD);\r\nld->ld_header.mh_format = cpu_to_be32(GFS2_FORMAT_LD);\r\nld->ld_type = cpu_to_be32(ld_type);\r\nld->ld_length = 0;\r\nld->ld_data1 = 0;\r\nld->ld_data2 = 0;\r\nmemset(ld->ld_reserved, 0, sizeof(ld->ld_reserved));\r\nreturn bh;\r\n}\r\nstatic void buf_lo_add(struct gfs2_sbd *sdp, struct gfs2_log_element *le)\r\n{\r\nstruct gfs2_bufdata *bd = container_of(le, struct gfs2_bufdata, bd_le);\r\nstruct gfs2_meta_header *mh;\r\nstruct gfs2_trans *tr;\r\nlock_buffer(bd->bd_bh);\r\ngfs2_log_lock(sdp);\r\nif (!list_empty(&bd->bd_list_tr))\r\ngoto out;\r\ntr = current->journal_info;\r\ntr->tr_touched = 1;\r\ntr->tr_num_buf++;\r\nlist_add(&bd->bd_list_tr, &tr->tr_list_buf);\r\nif (!list_empty(&le->le_list))\r\ngoto out;\r\nset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\r\nset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\r\ngfs2_meta_check(sdp, bd->bd_bh);\r\ngfs2_pin(sdp, bd->bd_bh);\r\nmh = (struct gfs2_meta_header *)bd->bd_bh->b_data;\r\nmh->__pad0 = cpu_to_be64(0);\r\nmh->mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);\r\nsdp->sd_log_num_buf++;\r\nlist_add(&le->le_list, &sdp->sd_log_le_buf);\r\ntr->tr_num_buf_new++;\r\nout:\r\ngfs2_log_unlock(sdp);\r\nunlock_buffer(bd->bd_bh);\r\n}\r\nstatic void buf_lo_before_commit(struct gfs2_sbd *sdp)\r\n{\r\nstruct buffer_head *bh;\r\nstruct gfs2_log_descriptor *ld;\r\nstruct gfs2_bufdata *bd1 = NULL, *bd2;\r\nunsigned int total;\r\nunsigned int limit;\r\nunsigned int num;\r\nunsigned n;\r\n__be64 *ptr;\r\nlimit = buf_limit(sdp);\r\ngfs2_log_lock(sdp);\r\ntotal = sdp->sd_log_num_buf;\r\nbd1 = bd2 = list_prepare_entry(bd1, &sdp->sd_log_le_buf, bd_le.le_list);\r\nwhile(total) {\r\nnum = total;\r\nif (total > limit)\r\nnum = limit;\r\ngfs2_log_unlock(sdp);\r\nbh = gfs2_get_log_desc(sdp, GFS2_LOG_DESC_METADATA);\r\ngfs2_log_lock(sdp);\r\nld = bh_log_desc(bh);\r\nptr = bh_log_ptr(bh);\r\nld->ld_length = cpu_to_be32(num + 1);\r\nld->ld_data1 = cpu_to_be32(num);\r\nn = 0;\r\nlist_for_each_entry_continue(bd1, &sdp->sd_log_le_buf,\r\nbd_le.le_list) {\r\n*ptr++ = cpu_to_be64(bd1->bd_bh->b_blocknr);\r\nif (++n >= num)\r\nbreak;\r\n}\r\ngfs2_log_unlock(sdp);\r\nsubmit_bh(WRITE_SYNC, bh);\r\ngfs2_log_lock(sdp);\r\nn = 0;\r\nlist_for_each_entry_continue(bd2, &sdp->sd_log_le_buf,\r\nbd_le.le_list) {\r\nget_bh(bd2->bd_bh);\r\ngfs2_log_unlock(sdp);\r\nlock_buffer(bd2->bd_bh);\r\nbh = gfs2_log_fake_buf(sdp, bd2->bd_bh);\r\nsubmit_bh(WRITE_SYNC, bh);\r\ngfs2_log_lock(sdp);\r\nif (++n >= num)\r\nbreak;\r\n}\r\nBUG_ON(total < num);\r\ntotal -= num;\r\n}\r\ngfs2_log_unlock(sdp);\r\n}\r\nstatic void buf_lo_after_commit(struct gfs2_sbd *sdp, struct gfs2_ail *ai)\r\n{\r\nstruct list_head *head = &sdp->sd_log_le_buf;\r\nstruct gfs2_bufdata *bd;\r\nwhile (!list_empty(head)) {\r\nbd = list_entry(head->next, struct gfs2_bufdata, bd_le.le_list);\r\nlist_del_init(&bd->bd_le.le_list);\r\nsdp->sd_log_num_buf--;\r\ngfs2_unpin(sdp, bd->bd_bh, ai);\r\n}\r\ngfs2_assert_warn(sdp, !sdp->sd_log_num_buf);\r\n}\r\nstatic void buf_lo_before_scan(struct gfs2_jdesc *jd,\r\nstruct gfs2_log_header_host *head, int pass)\r\n{\r\nstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\r\nif (pass != 0)\r\nreturn;\r\nsdp->sd_found_blocks = 0;\r\nsdp->sd_replayed_blocks = 0;\r\n}\r\nstatic int buf_lo_scan_elements(struct gfs2_jdesc *jd, unsigned int start,\r\nstruct gfs2_log_descriptor *ld, __be64 *ptr,\r\nint pass)\r\n{\r\nstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\r\nstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\r\nstruct gfs2_glock *gl = ip->i_gl;\r\nunsigned int blks = be32_to_cpu(ld->ld_data1);\r\nstruct buffer_head *bh_log, *bh_ip;\r\nu64 blkno;\r\nint error = 0;\r\nif (pass != 1 || be32_to_cpu(ld->ld_type) != GFS2_LOG_DESC_METADATA)\r\nreturn 0;\r\ngfs2_replay_incr_blk(sdp, &start);\r\nfor (; blks; gfs2_replay_incr_blk(sdp, &start), blks--) {\r\nblkno = be64_to_cpu(*ptr++);\r\nsdp->sd_found_blocks++;\r\nif (gfs2_revoke_check(sdp, blkno, start))\r\ncontinue;\r\nerror = gfs2_replay_read_block(jd, start, &bh_log);\r\nif (error)\r\nreturn error;\r\nbh_ip = gfs2_meta_new(gl, blkno);\r\nmemcpy(bh_ip->b_data, bh_log->b_data, bh_log->b_size);\r\nif (gfs2_meta_check(sdp, bh_ip))\r\nerror = -EIO;\r\nelse\r\nmark_buffer_dirty(bh_ip);\r\nbrelse(bh_log);\r\nbrelse(bh_ip);\r\nif (error)\r\nbreak;\r\nsdp->sd_replayed_blocks++;\r\n}\r\nreturn error;\r\n}\r\nstatic void buf_lo_after_scan(struct gfs2_jdesc *jd, int error, int pass)\r\n{\r\nstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\r\nstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\r\nif (error) {\r\ngfs2_meta_sync(ip->i_gl);\r\nreturn;\r\n}\r\nif (pass != 1)\r\nreturn;\r\ngfs2_meta_sync(ip->i_gl);\r\nfs_info(sdp, "jid=%u: Replayed %u of %u blocks\n",\r\njd->jd_jid, sdp->sd_replayed_blocks, sdp->sd_found_blocks);\r\n}\r\nstatic void revoke_lo_add(struct gfs2_sbd *sdp, struct gfs2_log_element *le)\r\n{\r\nstruct gfs2_bufdata *bd = container_of(le, struct gfs2_bufdata, bd_le);\r\nstruct gfs2_glock *gl = bd->bd_gl;\r\nstruct gfs2_trans *tr;\r\ntr = current->journal_info;\r\ntr->tr_touched = 1;\r\ntr->tr_num_revoke++;\r\nsdp->sd_log_num_revoke++;\r\natomic_inc(&gl->gl_revokes);\r\nset_bit(GLF_LFLUSH, &gl->gl_flags);\r\nlist_add(&le->le_list, &sdp->sd_log_le_revoke);\r\n}\r\nstatic void revoke_lo_before_commit(struct gfs2_sbd *sdp)\r\n{\r\nstruct gfs2_log_descriptor *ld;\r\nstruct gfs2_meta_header *mh;\r\nstruct buffer_head *bh;\r\nunsigned int offset;\r\nstruct list_head *head = &sdp->sd_log_le_revoke;\r\nstruct gfs2_bufdata *bd;\r\nif (!sdp->sd_log_num_revoke)\r\nreturn;\r\nbh = gfs2_get_log_desc(sdp, GFS2_LOG_DESC_REVOKE);\r\nld = bh_log_desc(bh);\r\nld->ld_length = cpu_to_be32(gfs2_struct2blk(sdp, sdp->sd_log_num_revoke,\r\nsizeof(u64)));\r\nld->ld_data1 = cpu_to_be32(sdp->sd_log_num_revoke);\r\noffset = sizeof(struct gfs2_log_descriptor);\r\nlist_for_each_entry(bd, head, bd_le.le_list) {\r\nsdp->sd_log_num_revoke--;\r\nif (offset + sizeof(u64) > sdp->sd_sb.sb_bsize) {\r\nsubmit_bh(WRITE_SYNC, bh);\r\nbh = gfs2_log_get_buf(sdp);\r\nmh = (struct gfs2_meta_header *)bh->b_data;\r\nmh->mh_magic = cpu_to_be32(GFS2_MAGIC);\r\nmh->mh_type = cpu_to_be32(GFS2_METATYPE_LB);\r\nmh->mh_format = cpu_to_be32(GFS2_FORMAT_LB);\r\noffset = sizeof(struct gfs2_meta_header);\r\n}\r\n*(__be64 *)(bh->b_data + offset) = cpu_to_be64(bd->bd_blkno);\r\noffset += sizeof(u64);\r\n}\r\ngfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\r\nsubmit_bh(WRITE_SYNC, bh);\r\n}\r\nstatic void revoke_lo_after_commit(struct gfs2_sbd *sdp, struct gfs2_ail *ai)\r\n{\r\nstruct list_head *head = &sdp->sd_log_le_revoke;\r\nstruct gfs2_bufdata *bd;\r\nstruct gfs2_glock *gl;\r\nwhile (!list_empty(head)) {\r\nbd = list_entry(head->next, struct gfs2_bufdata, bd_le.le_list);\r\nlist_del_init(&bd->bd_le.le_list);\r\ngl = bd->bd_gl;\r\natomic_dec(&gl->gl_revokes);\r\nclear_bit(GLF_LFLUSH, &gl->gl_flags);\r\nkmem_cache_free(gfs2_bufdata_cachep, bd);\r\n}\r\n}\r\nstatic void revoke_lo_before_scan(struct gfs2_jdesc *jd,\r\nstruct gfs2_log_header_host *head, int pass)\r\n{\r\nstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\r\nif (pass != 0)\r\nreturn;\r\nsdp->sd_found_revokes = 0;\r\nsdp->sd_replay_tail = head->lh_tail;\r\n}\r\nstatic int revoke_lo_scan_elements(struct gfs2_jdesc *jd, unsigned int start,\r\nstruct gfs2_log_descriptor *ld, __be64 *ptr,\r\nint pass)\r\n{\r\nstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\r\nunsigned int blks = be32_to_cpu(ld->ld_length);\r\nunsigned int revokes = be32_to_cpu(ld->ld_data1);\r\nstruct buffer_head *bh;\r\nunsigned int offset;\r\nu64 blkno;\r\nint first = 1;\r\nint error;\r\nif (pass != 0 || be32_to_cpu(ld->ld_type) != GFS2_LOG_DESC_REVOKE)\r\nreturn 0;\r\noffset = sizeof(struct gfs2_log_descriptor);\r\nfor (; blks; gfs2_replay_incr_blk(sdp, &start), blks--) {\r\nerror = gfs2_replay_read_block(jd, start, &bh);\r\nif (error)\r\nreturn error;\r\nif (!first)\r\ngfs2_metatype_check(sdp, bh, GFS2_METATYPE_LB);\r\nwhile (offset + sizeof(u64) <= sdp->sd_sb.sb_bsize) {\r\nblkno = be64_to_cpu(*(__be64 *)(bh->b_data + offset));\r\nerror = gfs2_revoke_add(sdp, blkno, start);\r\nif (error < 0) {\r\nbrelse(bh);\r\nreturn error;\r\n}\r\nelse if (error)\r\nsdp->sd_found_revokes++;\r\nif (!--revokes)\r\nbreak;\r\noffset += sizeof(u64);\r\n}\r\nbrelse(bh);\r\noffset = sizeof(struct gfs2_meta_header);\r\nfirst = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void revoke_lo_after_scan(struct gfs2_jdesc *jd, int error, int pass)\r\n{\r\nstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\r\nif (error) {\r\ngfs2_revoke_clean(sdp);\r\nreturn;\r\n}\r\nif (pass != 1)\r\nreturn;\r\nfs_info(sdp, "jid=%u: Found %u revoke tags\n",\r\njd->jd_jid, sdp->sd_found_revokes);\r\ngfs2_revoke_clean(sdp);\r\n}\r\nstatic void databuf_lo_add(struct gfs2_sbd *sdp, struct gfs2_log_element *le)\r\n{\r\nstruct gfs2_bufdata *bd = container_of(le, struct gfs2_bufdata, bd_le);\r\nstruct gfs2_trans *tr = current->journal_info;\r\nstruct address_space *mapping = bd->bd_bh->b_page->mapping;\r\nstruct gfs2_inode *ip = GFS2_I(mapping->host);\r\nlock_buffer(bd->bd_bh);\r\ngfs2_log_lock(sdp);\r\nif (tr) {\r\nif (!list_empty(&bd->bd_list_tr))\r\ngoto out;\r\ntr->tr_touched = 1;\r\nif (gfs2_is_jdata(ip)) {\r\ntr->tr_num_buf++;\r\nlist_add(&bd->bd_list_tr, &tr->tr_list_buf);\r\n}\r\n}\r\nif (!list_empty(&le->le_list))\r\ngoto out;\r\nset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\r\nset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\r\nif (gfs2_is_jdata(ip)) {\r\ngfs2_pin(sdp, bd->bd_bh);\r\ntr->tr_num_databuf_new++;\r\nsdp->sd_log_num_databuf++;\r\nlist_add_tail(&le->le_list, &sdp->sd_log_le_databuf);\r\n} else {\r\nlist_add_tail(&le->le_list, &sdp->sd_log_le_ordered);\r\n}\r\nout:\r\ngfs2_log_unlock(sdp);\r\nunlock_buffer(bd->bd_bh);\r\n}\r\nstatic void gfs2_check_magic(struct buffer_head *bh)\r\n{\r\nvoid *kaddr;\r\n__be32 *ptr;\r\nclear_buffer_escaped(bh);\r\nkaddr = kmap_atomic(bh->b_page, KM_USER0);\r\nptr = kaddr + bh_offset(bh);\r\nif (*ptr == cpu_to_be32(GFS2_MAGIC))\r\nset_buffer_escaped(bh);\r\nkunmap_atomic(kaddr, KM_USER0);\r\n}\r\nstatic void gfs2_write_blocks(struct gfs2_sbd *sdp, struct buffer_head *bh,\r\nstruct list_head *list, struct list_head *done,\r\nunsigned int n)\r\n{\r\nstruct buffer_head *bh1;\r\nstruct gfs2_log_descriptor *ld;\r\nstruct gfs2_bufdata *bd;\r\n__be64 *ptr;\r\nif (!bh)\r\nreturn;\r\nld = bh_log_desc(bh);\r\nld->ld_length = cpu_to_be32(n + 1);\r\nld->ld_data1 = cpu_to_be32(n);\r\nptr = bh_log_ptr(bh);\r\nget_bh(bh);\r\nsubmit_bh(WRITE_SYNC, bh);\r\ngfs2_log_lock(sdp);\r\nwhile(!list_empty(list)) {\r\nbd = list_entry(list->next, struct gfs2_bufdata, bd_le.le_list);\r\nlist_move_tail(&bd->bd_le.le_list, done);\r\nget_bh(bd->bd_bh);\r\nwhile (be64_to_cpu(*ptr) != bd->bd_bh->b_blocknr) {\r\ngfs2_log_incr_head(sdp);\r\nptr += 2;\r\n}\r\ngfs2_log_unlock(sdp);\r\nlock_buffer(bd->bd_bh);\r\nif (buffer_escaped(bd->bd_bh)) {\r\nvoid *kaddr;\r\nbh1 = gfs2_log_get_buf(sdp);\r\nkaddr = kmap_atomic(bd->bd_bh->b_page, KM_USER0);\r\nmemcpy(bh1->b_data, kaddr + bh_offset(bd->bd_bh),\r\nbh1->b_size);\r\nkunmap_atomic(kaddr, KM_USER0);\r\n*(__be32 *)bh1->b_data = 0;\r\nclear_buffer_escaped(bd->bd_bh);\r\nunlock_buffer(bd->bd_bh);\r\nbrelse(bd->bd_bh);\r\n} else {\r\nbh1 = gfs2_log_fake_buf(sdp, bd->bd_bh);\r\n}\r\nsubmit_bh(WRITE_SYNC, bh1);\r\ngfs2_log_lock(sdp);\r\nptr += 2;\r\n}\r\ngfs2_log_unlock(sdp);\r\nbrelse(bh);\r\n}\r\nstatic void databuf_lo_before_commit(struct gfs2_sbd *sdp)\r\n{\r\nstruct gfs2_bufdata *bd = NULL;\r\nstruct buffer_head *bh = NULL;\r\nunsigned int n = 0;\r\n__be64 *ptr = NULL, *end = NULL;\r\nLIST_HEAD(processed);\r\nLIST_HEAD(in_progress);\r\ngfs2_log_lock(sdp);\r\nwhile (!list_empty(&sdp->sd_log_le_databuf)) {\r\nif (ptr == end) {\r\ngfs2_log_unlock(sdp);\r\ngfs2_write_blocks(sdp, bh, &in_progress, &processed, n);\r\nn = 0;\r\nbh = gfs2_get_log_desc(sdp, GFS2_LOG_DESC_JDATA);\r\nptr = bh_log_ptr(bh);\r\nend = bh_ptr_end(bh) - 1;\r\ngfs2_log_lock(sdp);\r\ncontinue;\r\n}\r\nbd = list_entry(sdp->sd_log_le_databuf.next, struct gfs2_bufdata, bd_le.le_list);\r\nlist_move_tail(&bd->bd_le.le_list, &in_progress);\r\ngfs2_check_magic(bd->bd_bh);\r\n*ptr++ = cpu_to_be64(bd->bd_bh->b_blocknr);\r\n*ptr++ = cpu_to_be64(buffer_escaped(bh) ? 1 : 0);\r\nn++;\r\n}\r\ngfs2_log_unlock(sdp);\r\ngfs2_write_blocks(sdp, bh, &in_progress, &processed, n);\r\ngfs2_log_lock(sdp);\r\nlist_splice(&processed, &sdp->sd_log_le_databuf);\r\ngfs2_log_unlock(sdp);\r\n}\r\nstatic int databuf_lo_scan_elements(struct gfs2_jdesc *jd, unsigned int start,\r\nstruct gfs2_log_descriptor *ld,\r\n__be64 *ptr, int pass)\r\n{\r\nstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\r\nstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\r\nstruct gfs2_glock *gl = ip->i_gl;\r\nunsigned int blks = be32_to_cpu(ld->ld_data1);\r\nstruct buffer_head *bh_log, *bh_ip;\r\nu64 blkno;\r\nu64 esc;\r\nint error = 0;\r\nif (pass != 1 || be32_to_cpu(ld->ld_type) != GFS2_LOG_DESC_JDATA)\r\nreturn 0;\r\ngfs2_replay_incr_blk(sdp, &start);\r\nfor (; blks; gfs2_replay_incr_blk(sdp, &start), blks--) {\r\nblkno = be64_to_cpu(*ptr++);\r\nesc = be64_to_cpu(*ptr++);\r\nsdp->sd_found_blocks++;\r\nif (gfs2_revoke_check(sdp, blkno, start))\r\ncontinue;\r\nerror = gfs2_replay_read_block(jd, start, &bh_log);\r\nif (error)\r\nreturn error;\r\nbh_ip = gfs2_meta_new(gl, blkno);\r\nmemcpy(bh_ip->b_data, bh_log->b_data, bh_log->b_size);\r\nif (esc) {\r\n__be32 *eptr = (__be32 *)bh_ip->b_data;\r\n*eptr = cpu_to_be32(GFS2_MAGIC);\r\n}\r\nmark_buffer_dirty(bh_ip);\r\nbrelse(bh_log);\r\nbrelse(bh_ip);\r\nsdp->sd_replayed_blocks++;\r\n}\r\nreturn error;\r\n}\r\nstatic void databuf_lo_after_scan(struct gfs2_jdesc *jd, int error, int pass)\r\n{\r\nstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\r\nstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\r\nif (error) {\r\ngfs2_meta_sync(ip->i_gl);\r\nreturn;\r\n}\r\nif (pass != 1)\r\nreturn;\r\ngfs2_meta_sync(ip->i_gl);\r\nfs_info(sdp, "jid=%u: Replayed %u of %u data blocks\n",\r\njd->jd_jid, sdp->sd_replayed_blocks, sdp->sd_found_blocks);\r\n}\r\nstatic void databuf_lo_after_commit(struct gfs2_sbd *sdp, struct gfs2_ail *ai)\r\n{\r\nstruct list_head *head = &sdp->sd_log_le_databuf;\r\nstruct gfs2_bufdata *bd;\r\nwhile (!list_empty(head)) {\r\nbd = list_entry(head->next, struct gfs2_bufdata, bd_le.le_list);\r\nlist_del_init(&bd->bd_le.le_list);\r\nsdp->sd_log_num_databuf--;\r\ngfs2_unpin(sdp, bd->bd_bh, ai);\r\n}\r\ngfs2_assert_warn(sdp, !sdp->sd_log_num_databuf);\r\n}
