static int acpi_processor_ppc_notifier(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct cpufreq_policy *policy = data;\r\nstruct acpi_processor *pr;\r\nunsigned int ppc = 0;\r\nif (event == CPUFREQ_START && ignore_ppc <= 0) {\r\nignore_ppc = 0;\r\nreturn 0;\r\n}\r\nif (ignore_ppc)\r\nreturn 0;\r\nif (event != CPUFREQ_INCOMPATIBLE)\r\nreturn 0;\r\nmutex_lock(&performance_mutex);\r\npr = per_cpu(processors, policy->cpu);\r\nif (!pr || !pr->performance)\r\ngoto out;\r\nppc = (unsigned int)pr->performance_platform_limit;\r\nif (ppc >= pr->performance->state_count)\r\ngoto out;\r\ncpufreq_verify_within_limits(policy, 0,\r\npr->performance->states[ppc].\r\ncore_frequency * 1000);\r\nout:\r\nmutex_unlock(&performance_mutex);\r\nreturn 0;\r\n}\r\nstatic int acpi_processor_get_platform_limit(struct acpi_processor *pr)\r\n{\r\nacpi_status status = 0;\r\nunsigned long long ppc = 0;\r\nif (!pr)\r\nreturn -EINVAL;\r\nstatus = acpi_evaluate_integer(pr->handle, "_PPC", NULL, &ppc);\r\nif (status != AE_NOT_FOUND)\r\nacpi_processor_ppc_status |= PPC_IN_USE;\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _PPC"));\r\nreturn -ENODEV;\r\n}\r\npr_debug("CPU %d: _PPC is %d - frequency %s limited\n", pr->id,\r\n(int)ppc, ppc ? "" : "not");\r\npr->performance_platform_limit = (int)ppc;\r\nreturn 0;\r\n}\r\nstatic void acpi_processor_ppc_ost(acpi_handle handle, int status)\r\n{\r\nunion acpi_object params[2] = {\r\n{.type = ACPI_TYPE_INTEGER,},\r\n{.type = ACPI_TYPE_INTEGER,},\r\n};\r\nstruct acpi_object_list arg_list = {2, params};\r\nacpi_handle temp;\r\nparams[0].integer.value = ACPI_PROCESSOR_NOTIFY_PERFORMANCE;\r\nparams[1].integer.value = status;\r\nif (ACPI_FAILURE(acpi_get_handle(handle, "_OST", &temp)))\r\nreturn;\r\nacpi_evaluate_object(handle, "_OST", &arg_list, NULL);\r\nreturn;\r\n}\r\nint acpi_processor_ppc_has_changed(struct acpi_processor *pr, int event_flag)\r\n{\r\nint ret;\r\nif (ignore_ppc) {\r\nif (event_flag)\r\nacpi_processor_ppc_ost(pr->handle, 1);\r\nreturn 0;\r\n}\r\nret = acpi_processor_get_platform_limit(pr);\r\nif (event_flag) {\r\nif (ret < 0)\r\nacpi_processor_ppc_ost(pr->handle, 1);\r\nelse\r\nacpi_processor_ppc_ost(pr->handle, 0);\r\n}\r\nif (ret < 0)\r\nreturn (ret);\r\nelse\r\nreturn cpufreq_update_policy(pr->id);\r\n}\r\nint acpi_processor_get_bios_limit(int cpu, unsigned int *limit)\r\n{\r\nstruct acpi_processor *pr;\r\npr = per_cpu(processors, cpu);\r\nif (!pr || !pr->performance || !pr->performance->state_count)\r\nreturn -ENODEV;\r\n*limit = pr->performance->states[pr->performance_platform_limit].\r\ncore_frequency * 1000;\r\nreturn 0;\r\n}\r\nvoid acpi_processor_ppc_init(void)\r\n{\r\nif (!cpufreq_register_notifier\r\n(&acpi_ppc_notifier_block, CPUFREQ_POLICY_NOTIFIER))\r\nacpi_processor_ppc_status |= PPC_REGISTERED;\r\nelse\r\nprintk(KERN_DEBUG\r\n"Warning: Processor Platform Limit not supported.\n");\r\n}\r\nvoid acpi_processor_ppc_exit(void)\r\n{\r\nif (acpi_processor_ppc_status & PPC_REGISTERED)\r\ncpufreq_unregister_notifier(&acpi_ppc_notifier_block,\r\nCPUFREQ_POLICY_NOTIFIER);\r\nacpi_processor_ppc_status &= ~PPC_REGISTERED;\r\n}\r\nstatic int acpi_processor_get_performance_control(struct acpi_processor *pr)\r\n{\r\nint result = 0;\r\nacpi_status status = 0;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *pct = NULL;\r\nunion acpi_object obj = { 0 };\r\nstatus = acpi_evaluate_object(pr->handle, "_PCT", NULL, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _PCT"));\r\nreturn -ENODEV;\r\n}\r\npct = (union acpi_object *)buffer.pointer;\r\nif (!pct || (pct->type != ACPI_TYPE_PACKAGE)\r\n|| (pct->package.count != 2)) {\r\nprintk(KERN_ERR PREFIX "Invalid _PCT data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nobj = pct->package.elements[0];\r\nif ((obj.type != ACPI_TYPE_BUFFER)\r\n|| (obj.buffer.length < sizeof(struct acpi_pct_register))\r\n|| (obj.buffer.pointer == NULL)) {\r\nprintk(KERN_ERR PREFIX "Invalid _PCT data (control_register)\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nmemcpy(&pr->performance->control_register, obj.buffer.pointer,\r\nsizeof(struct acpi_pct_register));\r\nobj = pct->package.elements[1];\r\nif ((obj.type != ACPI_TYPE_BUFFER)\r\n|| (obj.buffer.length < sizeof(struct acpi_pct_register))\r\n|| (obj.buffer.pointer == NULL)) {\r\nprintk(KERN_ERR PREFIX "Invalid _PCT data (status_register)\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nmemcpy(&pr->performance->status_register, obj.buffer.pointer,\r\nsizeof(struct acpi_pct_register));\r\nend:\r\nkfree(buffer.pointer);\r\nreturn result;\r\n}\r\nstatic int acpi_processor_get_performance_states(struct acpi_processor *pr)\r\n{\r\nint result = 0;\r\nacpi_status status = AE_OK;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_buffer format = { sizeof("NNNNNN"), "NNNNNN" };\r\nstruct acpi_buffer state = { 0, NULL };\r\nunion acpi_object *pss = NULL;\r\nint i;\r\nstatus = acpi_evaluate_object(pr->handle, "_PSS", NULL, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _PSS"));\r\nreturn -ENODEV;\r\n}\r\npss = buffer.pointer;\r\nif (!pss || (pss->type != ACPI_TYPE_PACKAGE)) {\r\nprintk(KERN_ERR PREFIX "Invalid _PSS data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d performance states\n",\r\npss->package.count));\r\npr->performance->state_count = pss->package.count;\r\npr->performance->states =\r\nkmalloc(sizeof(struct acpi_processor_px) * pss->package.count,\r\nGFP_KERNEL);\r\nif (!pr->performance->states) {\r\nresult = -ENOMEM;\r\ngoto end;\r\n}\r\nfor (i = 0; i < pr->performance->state_count; i++) {\r\nstruct acpi_processor_px *px = &(pr->performance->states[i]);\r\nstate.length = sizeof(struct acpi_processor_px);\r\nstate.pointer = px;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Extracting state %d\n", i));\r\nstatus = acpi_extract_package(&(pss->package.elements[i]),\r\n&format, &state);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Invalid _PSS data"));\r\nresult = -EFAULT;\r\nkfree(pr->performance->states);\r\ngoto end;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"State [%d]: core_frequency[%d] power[%d] transition_latency[%d] bus_master_latency[%d] control[0x%x] status[0x%x]\n",\r\ni,\r\n(u32) px->core_frequency,\r\n(u32) px->power,\r\n(u32) px->transition_latency,\r\n(u32) px->bus_master_latency,\r\n(u32) px->control, (u32) px->status));\r\nif (!px->core_frequency ||\r\n((u32)(px->core_frequency * 1000) !=\r\n(px->core_frequency * 1000))) {\r\nprintk(KERN_ERR FW_BUG PREFIX\r\n"Invalid BIOS _PSS frequency: 0x%llx MHz\n",\r\npx->core_frequency);\r\nresult = -EFAULT;\r\nkfree(pr->performance->states);\r\ngoto end;\r\n}\r\n}\r\nend:\r\nkfree(buffer.pointer);\r\nreturn result;\r\n}\r\nstatic int acpi_processor_get_performance_info(struct acpi_processor *pr)\r\n{\r\nint result = 0;\r\nacpi_status status = AE_OK;\r\nacpi_handle handle = NULL;\r\nif (!pr || !pr->performance || !pr->handle)\r\nreturn -EINVAL;\r\nstatus = acpi_get_handle(pr->handle, "_PCT", &handle);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"ACPI-based processor performance control unavailable\n"));\r\nreturn -ENODEV;\r\n}\r\nresult = acpi_processor_get_performance_control(pr);\r\nif (result)\r\ngoto update_bios;\r\nresult = acpi_processor_get_performance_states(pr);\r\nif (result)\r\ngoto update_bios;\r\nif (ignore_ppc != 1)\r\nresult = acpi_processor_get_platform_limit(pr);\r\nreturn result;\r\nupdate_bios:\r\n#ifdef CONFIG_X86\r\nif (ACPI_SUCCESS(acpi_get_handle(pr->handle, "_PPC", &handle))){\r\nif(boot_cpu_has(X86_FEATURE_EST))\r\nprintk(KERN_WARNING FW_BUG "BIOS needs update for CPU "\r\n"frequency support\n");\r\n}\r\n#endif\r\nreturn result;\r\n}\r\nint acpi_processor_notify_smm(struct module *calling_module)\r\n{\r\nacpi_status status;\r\nstatic int is_done = 0;\r\nif (!(acpi_processor_ppc_status & PPC_REGISTERED))\r\nreturn -EBUSY;\r\nif (!try_module_get(calling_module))\r\nreturn -EINVAL;\r\nif (is_done > 0) {\r\nmodule_put(calling_module);\r\nreturn 0;\r\n} else if (is_done < 0) {\r\nmodule_put(calling_module);\r\nreturn is_done;\r\n}\r\nis_done = -EIO;\r\nif ((!acpi_gbl_FADT.smi_command) || (!acpi_gbl_FADT.pstate_control)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "No SMI port or pstate_control\n"));\r\nmodule_put(calling_module);\r\nreturn 0;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Writing pstate_control [0x%x] to smi_command [0x%x]\n",\r\nacpi_gbl_FADT.pstate_control, acpi_gbl_FADT.smi_command));\r\nstatus = acpi_os_write_port(acpi_gbl_FADT.smi_command,\r\n(u32) acpi_gbl_FADT.pstate_control, 8);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Failed to write pstate_control [0x%x] to "\r\n"smi_command [0x%x]", acpi_gbl_FADT.pstate_control,\r\nacpi_gbl_FADT.smi_command));\r\nmodule_put(calling_module);\r\nreturn status;\r\n}\r\nis_done = 1;\r\nif (!(acpi_processor_ppc_status & PPC_IN_USE))\r\nmodule_put(calling_module);\r\nreturn 0;\r\n}\r\nstatic int acpi_processor_get_psd(struct acpi_processor *pr)\r\n{\r\nint result = 0;\r\nacpi_status status = AE_OK;\r\nstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\r\nstruct acpi_buffer format = {sizeof("NNNNN"), "NNNNN"};\r\nstruct acpi_buffer state = {0, NULL};\r\nunion acpi_object *psd = NULL;\r\nstruct acpi_psd_package *pdomain;\r\nstatus = acpi_evaluate_object(pr->handle, "_PSD", NULL, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nreturn -ENODEV;\r\n}\r\npsd = buffer.pointer;\r\nif (!psd || (psd->type != ACPI_TYPE_PACKAGE)) {\r\nprintk(KERN_ERR PREFIX "Invalid _PSD data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nif (psd->package.count != 1) {\r\nprintk(KERN_ERR PREFIX "Invalid _PSD data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\npdomain = &(pr->performance->domain_info);\r\nstate.length = sizeof(struct acpi_psd_package);\r\nstate.pointer = pdomain;\r\nstatus = acpi_extract_package(&(psd->package.elements[0]),\r\n&format, &state);\r\nif (ACPI_FAILURE(status)) {\r\nprintk(KERN_ERR PREFIX "Invalid _PSD data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nif (pdomain->num_entries != ACPI_PSD_REV0_ENTRIES) {\r\nprintk(KERN_ERR PREFIX "Unknown _PSD:num_entries\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nif (pdomain->revision != ACPI_PSD_REV0_REVISION) {\r\nprintk(KERN_ERR PREFIX "Unknown _PSD:revision\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nif (pdomain->coord_type != DOMAIN_COORD_TYPE_SW_ALL &&\r\npdomain->coord_type != DOMAIN_COORD_TYPE_SW_ANY &&\r\npdomain->coord_type != DOMAIN_COORD_TYPE_HW_ALL) {\r\nprintk(KERN_ERR PREFIX "Invalid _PSD:coord_type\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nend:\r\nkfree(buffer.pointer);\r\nreturn result;\r\n}\r\nint acpi_processor_preregister_performance(\r\nstruct acpi_processor_performance __percpu *performance)\r\n{\r\nint count, count_target;\r\nint retval = 0;\r\nunsigned int i, j;\r\ncpumask_var_t covered_cpus;\r\nstruct acpi_processor *pr;\r\nstruct acpi_psd_package *pdomain;\r\nstruct acpi_processor *match_pr;\r\nstruct acpi_psd_package *match_pdomain;\r\nif (!zalloc_cpumask_var(&covered_cpus, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nmutex_lock(&performance_mutex);\r\nfor_each_possible_cpu(i) {\r\npr = per_cpu(processors, i);\r\nif (!pr) {\r\ncontinue;\r\n}\r\nif (pr->performance) {\r\nretval = -EBUSY;\r\ngoto err_out;\r\n}\r\nif (!performance || !per_cpu_ptr(performance, i)) {\r\nretval = -EINVAL;\r\ngoto err_out;\r\n}\r\n}\r\nfor_each_possible_cpu(i) {\r\npr = per_cpu(processors, i);\r\nif (!pr)\r\ncontinue;\r\npr->performance = per_cpu_ptr(performance, i);\r\ncpumask_set_cpu(i, pr->performance->shared_cpu_map);\r\nif (acpi_processor_get_psd(pr)) {\r\nretval = -EINVAL;\r\ncontinue;\r\n}\r\n}\r\nif (retval)\r\ngoto err_ret;\r\nfor_each_possible_cpu(i) {\r\npr = per_cpu(processors, i);\r\nif (!pr)\r\ncontinue;\r\nif (cpumask_test_cpu(i, covered_cpus))\r\ncontinue;\r\npdomain = &(pr->performance->domain_info);\r\ncpumask_set_cpu(i, pr->performance->shared_cpu_map);\r\ncpumask_set_cpu(i, covered_cpus);\r\nif (pdomain->num_processors <= 1)\r\ncontinue;\r\ncount_target = pdomain->num_processors;\r\ncount = 1;\r\nif (pdomain->coord_type == DOMAIN_COORD_TYPE_SW_ALL)\r\npr->performance->shared_type = CPUFREQ_SHARED_TYPE_ALL;\r\nelse if (pdomain->coord_type == DOMAIN_COORD_TYPE_HW_ALL)\r\npr->performance->shared_type = CPUFREQ_SHARED_TYPE_HW;\r\nelse if (pdomain->coord_type == DOMAIN_COORD_TYPE_SW_ANY)\r\npr->performance->shared_type = CPUFREQ_SHARED_TYPE_ANY;\r\nfor_each_possible_cpu(j) {\r\nif (i == j)\r\ncontinue;\r\nmatch_pr = per_cpu(processors, j);\r\nif (!match_pr)\r\ncontinue;\r\nmatch_pdomain = &(match_pr->performance->domain_info);\r\nif (match_pdomain->domain != pdomain->domain)\r\ncontinue;\r\nif (match_pdomain->num_processors != count_target) {\r\nretval = -EINVAL;\r\ngoto err_ret;\r\n}\r\nif (pdomain->coord_type != match_pdomain->coord_type) {\r\nretval = -EINVAL;\r\ngoto err_ret;\r\n}\r\ncpumask_set_cpu(j, covered_cpus);\r\ncpumask_set_cpu(j, pr->performance->shared_cpu_map);\r\ncount++;\r\n}\r\nfor_each_possible_cpu(j) {\r\nif (i == j)\r\ncontinue;\r\nmatch_pr = per_cpu(processors, j);\r\nif (!match_pr)\r\ncontinue;\r\nmatch_pdomain = &(match_pr->performance->domain_info);\r\nif (match_pdomain->domain != pdomain->domain)\r\ncontinue;\r\nmatch_pr->performance->shared_type =\r\npr->performance->shared_type;\r\ncpumask_copy(match_pr->performance->shared_cpu_map,\r\npr->performance->shared_cpu_map);\r\n}\r\n}\r\nerr_ret:\r\nfor_each_possible_cpu(i) {\r\npr = per_cpu(processors, i);\r\nif (!pr || !pr->performance)\r\ncontinue;\r\nif (retval) {\r\ncpumask_clear(pr->performance->shared_cpu_map);\r\ncpumask_set_cpu(i, pr->performance->shared_cpu_map);\r\npr->performance->shared_type = CPUFREQ_SHARED_TYPE_ALL;\r\n}\r\npr->performance = NULL;\r\n}\r\nerr_out:\r\nmutex_unlock(&performance_mutex);\r\nfree_cpumask_var(covered_cpus);\r\nreturn retval;\r\n}\r\nint\r\nacpi_processor_register_performance(struct acpi_processor_performance\r\n*performance, unsigned int cpu)\r\n{\r\nstruct acpi_processor *pr;\r\nif (!(acpi_processor_ppc_status & PPC_REGISTERED))\r\nreturn -EINVAL;\r\nmutex_lock(&performance_mutex);\r\npr = per_cpu(processors, cpu);\r\nif (!pr) {\r\nmutex_unlock(&performance_mutex);\r\nreturn -ENODEV;\r\n}\r\nif (pr->performance) {\r\nmutex_unlock(&performance_mutex);\r\nreturn -EBUSY;\r\n}\r\nWARN_ON(!performance);\r\npr->performance = performance;\r\nif (acpi_processor_get_performance_info(pr)) {\r\npr->performance = NULL;\r\nmutex_unlock(&performance_mutex);\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&performance_mutex);\r\nreturn 0;\r\n}\r\nvoid\r\nacpi_processor_unregister_performance(struct acpi_processor_performance\r\n*performance, unsigned int cpu)\r\n{\r\nstruct acpi_processor *pr;\r\nmutex_lock(&performance_mutex);\r\npr = per_cpu(processors, cpu);\r\nif (!pr) {\r\nmutex_unlock(&performance_mutex);\r\nreturn;\r\n}\r\nif (pr->performance)\r\nkfree(pr->performance->states);\r\npr->performance = NULL;\r\nmutex_unlock(&performance_mutex);\r\nreturn;\r\n}
