bool ip_callchain__valid(struct ip_callchain *chain,\r\nconst union perf_event *event)\r\n{\r\nunsigned int chain_size = event->header.size;\r\nchain_size -= (unsigned long)&event->ip.__more_data - (unsigned long)event;\r\nreturn chain->nr * sizeof(u64) <= chain_size;\r\n}\r\nstatic void\r\nrb_insert_callchain(struct rb_root *root, struct callchain_node *chain,\r\nenum chain_mode mode)\r\n{\r\nstruct rb_node **p = &root->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct callchain_node *rnode;\r\nu64 chain_cumul = callchain_cumul_hits(chain);\r\nwhile (*p) {\r\nu64 rnode_cumul;\r\nparent = *p;\r\nrnode = rb_entry(parent, struct callchain_node, rb_node);\r\nrnode_cumul = callchain_cumul_hits(rnode);\r\nswitch (mode) {\r\ncase CHAIN_FLAT:\r\nif (rnode->hit < chain->hit)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\nbreak;\r\ncase CHAIN_GRAPH_ABS:\r\ncase CHAIN_GRAPH_REL:\r\nif (rnode_cumul < chain_cumul)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\nbreak;\r\ncase CHAIN_NONE:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nrb_link_node(&chain->rb_node, parent, p);\r\nrb_insert_color(&chain->rb_node, root);\r\n}\r\nstatic void\r\n__sort_chain_flat(struct rb_root *rb_root, struct callchain_node *node,\r\nu64 min_hit)\r\n{\r\nstruct callchain_node *child;\r\nchain_for_each_child(child, node)\r\n__sort_chain_flat(rb_root, child, min_hit);\r\nif (node->hit && node->hit >= min_hit)\r\nrb_insert_callchain(rb_root, node, CHAIN_FLAT);\r\n}\r\nstatic void\r\nsort_chain_flat(struct rb_root *rb_root, struct callchain_root *root,\r\nu64 min_hit, struct callchain_param *param __used)\r\n{\r\n__sort_chain_flat(rb_root, &root->node, min_hit);\r\n}\r\nstatic void __sort_chain_graph_abs(struct callchain_node *node,\r\nu64 min_hit)\r\n{\r\nstruct callchain_node *child;\r\nnode->rb_root = RB_ROOT;\r\nchain_for_each_child(child, node) {\r\n__sort_chain_graph_abs(child, min_hit);\r\nif (callchain_cumul_hits(child) >= min_hit)\r\nrb_insert_callchain(&node->rb_root, child,\r\nCHAIN_GRAPH_ABS);\r\n}\r\n}\r\nstatic void\r\nsort_chain_graph_abs(struct rb_root *rb_root, struct callchain_root *chain_root,\r\nu64 min_hit, struct callchain_param *param __used)\r\n{\r\n__sort_chain_graph_abs(&chain_root->node, min_hit);\r\nrb_root->rb_node = chain_root->node.rb_root.rb_node;\r\n}\r\nstatic void __sort_chain_graph_rel(struct callchain_node *node,\r\ndouble min_percent)\r\n{\r\nstruct callchain_node *child;\r\nu64 min_hit;\r\nnode->rb_root = RB_ROOT;\r\nmin_hit = ceil(node->children_hit * min_percent);\r\nchain_for_each_child(child, node) {\r\n__sort_chain_graph_rel(child, min_percent);\r\nif (callchain_cumul_hits(child) >= min_hit)\r\nrb_insert_callchain(&node->rb_root, child,\r\nCHAIN_GRAPH_REL);\r\n}\r\n}\r\nstatic void\r\nsort_chain_graph_rel(struct rb_root *rb_root, struct callchain_root *chain_root,\r\nu64 min_hit __used, struct callchain_param *param)\r\n{\r\n__sort_chain_graph_rel(&chain_root->node, param->min_percent / 100.0);\r\nrb_root->rb_node = chain_root->node.rb_root.rb_node;\r\n}\r\nint callchain_register_param(struct callchain_param *param)\r\n{\r\nswitch (param->mode) {\r\ncase CHAIN_GRAPH_ABS:\r\nparam->sort = sort_chain_graph_abs;\r\nbreak;\r\ncase CHAIN_GRAPH_REL:\r\nparam->sort = sort_chain_graph_rel;\r\nbreak;\r\ncase CHAIN_FLAT:\r\nparam->sort = sort_chain_flat;\r\nbreak;\r\ncase CHAIN_NONE:\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct callchain_node *\r\ncreate_child(struct callchain_node *parent, bool inherit_children)\r\n{\r\nstruct callchain_node *new;\r\nnew = zalloc(sizeof(*new));\r\nif (!new) {\r\nperror("not enough memory to create child for code path tree");\r\nreturn NULL;\r\n}\r\nnew->parent = parent;\r\nINIT_LIST_HEAD(&new->children);\r\nINIT_LIST_HEAD(&new->val);\r\nif (inherit_children) {\r\nstruct callchain_node *next;\r\nlist_splice(&parent->children, &new->children);\r\nINIT_LIST_HEAD(&parent->children);\r\nchain_for_each_child(next, new)\r\nnext->parent = new;\r\n}\r\nlist_add_tail(&new->siblings, &parent->children);\r\nreturn new;\r\n}\r\nstatic void\r\nfill_node(struct callchain_node *node, struct callchain_cursor *cursor)\r\n{\r\nstruct callchain_cursor_node *cursor_node;\r\nnode->val_nr = cursor->nr - cursor->pos;\r\nif (!node->val_nr)\r\npr_warning("Warning: empty node in callchain tree\n");\r\ncursor_node = callchain_cursor_current(cursor);\r\nwhile (cursor_node) {\r\nstruct callchain_list *call;\r\ncall = zalloc(sizeof(*call));\r\nif (!call) {\r\nperror("not enough memory for the code path tree");\r\nreturn;\r\n}\r\ncall->ip = cursor_node->ip;\r\ncall->ms.sym = cursor_node->sym;\r\ncall->ms.map = cursor_node->map;\r\nlist_add_tail(&call->list, &node->val);\r\ncallchain_cursor_advance(cursor);\r\ncursor_node = callchain_cursor_current(cursor);\r\n}\r\n}\r\nstatic void\r\nadd_child(struct callchain_node *parent,\r\nstruct callchain_cursor *cursor,\r\nu64 period)\r\n{\r\nstruct callchain_node *new;\r\nnew = create_child(parent, false);\r\nfill_node(new, cursor);\r\nnew->children_hit = 0;\r\nnew->hit = period;\r\n}\r\nstatic void\r\nsplit_add_child(struct callchain_node *parent,\r\nstruct callchain_cursor *cursor,\r\nstruct callchain_list *to_split,\r\nu64 idx_parents, u64 idx_local, u64 period)\r\n{\r\nstruct callchain_node *new;\r\nstruct list_head *old_tail;\r\nunsigned int idx_total = idx_parents + idx_local;\r\nnew = create_child(parent, true);\r\nold_tail = parent->val.prev;\r\nlist_del_range(&to_split->list, old_tail);\r\nnew->val.next = &to_split->list;\r\nnew->val.prev = old_tail;\r\nto_split->list.prev = &new->val;\r\nold_tail->next = &new->val;\r\nnew->hit = parent->hit;\r\nnew->children_hit = parent->children_hit;\r\nparent->children_hit = callchain_cumul_hits(new);\r\nnew->val_nr = parent->val_nr - idx_local;\r\nparent->val_nr = idx_local;\r\nif (idx_total < cursor->nr) {\r\nparent->hit = 0;\r\nadd_child(parent, cursor, period);\r\nparent->children_hit += period;\r\n} else {\r\nparent->hit = period;\r\n}\r\n}\r\nstatic void\r\nappend_chain_children(struct callchain_node *root,\r\nstruct callchain_cursor *cursor,\r\nu64 period)\r\n{\r\nstruct callchain_node *rnode;\r\nchain_for_each_child(rnode, root) {\r\nunsigned int ret = append_chain(rnode, cursor, period);\r\nif (!ret)\r\ngoto inc_children_hit;\r\n}\r\nadd_child(root, cursor, period);\r\ninc_children_hit:\r\nroot->children_hit += period;\r\n}\r\nstatic int\r\nappend_chain(struct callchain_node *root,\r\nstruct callchain_cursor *cursor,\r\nu64 period)\r\n{\r\nstruct callchain_cursor_node *curr_snap = cursor->curr;\r\nstruct callchain_list *cnode;\r\nu64 start = cursor->pos;\r\nbool found = false;\r\nu64 matches;\r\nlist_for_each_entry(cnode, &root->val, list) {\r\nstruct callchain_cursor_node *node;\r\nstruct symbol *sym;\r\nnode = callchain_cursor_current(cursor);\r\nif (!node)\r\nbreak;\r\nsym = node->sym;\r\nif (cnode->ms.sym && sym) {\r\nif (cnode->ms.sym->start != sym->start)\r\nbreak;\r\n} else if (cnode->ip != node->ip)\r\nbreak;\r\nif (!found)\r\nfound = true;\r\ncallchain_cursor_advance(cursor);\r\n}\r\nif (!found) {\r\ncursor->curr = curr_snap;\r\ncursor->pos = start;\r\nreturn -1;\r\n}\r\nmatches = cursor->pos - start;\r\nif (matches < root->val_nr) {\r\nsplit_add_child(root, cursor, cnode, start, matches, period);\r\nreturn 0;\r\n}\r\nif (matches == root->val_nr && cursor->pos == cursor->nr) {\r\nroot->hit += period;\r\nreturn 0;\r\n}\r\nappend_chain_children(root, cursor, period);\r\nreturn 0;\r\n}\r\nint callchain_append(struct callchain_root *root,\r\nstruct callchain_cursor *cursor,\r\nu64 period)\r\n{\r\nif (!cursor->nr)\r\nreturn 0;\r\ncallchain_cursor_commit(cursor);\r\nappend_chain_children(&root->node, cursor, period);\r\nif (cursor->nr > root->max_depth)\r\nroot->max_depth = cursor->nr;\r\nreturn 0;\r\n}\r\nstatic int\r\nmerge_chain_branch(struct callchain_cursor *cursor,\r\nstruct callchain_node *dst, struct callchain_node *src)\r\n{\r\nstruct callchain_cursor_node **old_last = cursor->last;\r\nstruct callchain_node *child, *next_child;\r\nstruct callchain_list *list, *next_list;\r\nint old_pos = cursor->nr;\r\nint err = 0;\r\nlist_for_each_entry_safe(list, next_list, &src->val, list) {\r\ncallchain_cursor_append(cursor, list->ip,\r\nlist->ms.map, list->ms.sym);\r\nlist_del(&list->list);\r\nfree(list);\r\n}\r\nif (src->hit) {\r\ncallchain_cursor_commit(cursor);\r\nappend_chain_children(dst, cursor, src->hit);\r\n}\r\nchain_for_each_child_safe(child, next_child, src) {\r\nerr = merge_chain_branch(cursor, dst, child);\r\nif (err)\r\nbreak;\r\nlist_del(&child->siblings);\r\nfree(child);\r\n}\r\ncursor->nr = old_pos;\r\ncursor->last = old_last;\r\nreturn err;\r\n}\r\nint callchain_merge(struct callchain_cursor *cursor,\r\nstruct callchain_root *dst, struct callchain_root *src)\r\n{\r\nreturn merge_chain_branch(cursor, &dst->node, &src->node);\r\n}\r\nint callchain_cursor_append(struct callchain_cursor *cursor,\r\nu64 ip, struct map *map, struct symbol *sym)\r\n{\r\nstruct callchain_cursor_node *node = *cursor->last;\r\nif (!node) {\r\nnode = calloc(sizeof(*node), 1);\r\nif (!node)\r\nreturn -ENOMEM;\r\n*cursor->last = node;\r\n}\r\nnode->ip = ip;\r\nnode->map = map;\r\nnode->sym = sym;\r\ncursor->nr++;\r\ncursor->last = &node->next;\r\nreturn 0;\r\n}
