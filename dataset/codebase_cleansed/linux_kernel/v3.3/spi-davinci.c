static void davinci_spi_rx_buf_u8(u32 data, struct davinci_spi *dspi)\r\n{\r\nif (dspi->rx) {\r\nu8 *rx = dspi->rx;\r\n*rx++ = (u8)data;\r\ndspi->rx = rx;\r\n}\r\n}\r\nstatic void davinci_spi_rx_buf_u16(u32 data, struct davinci_spi *dspi)\r\n{\r\nif (dspi->rx) {\r\nu16 *rx = dspi->rx;\r\n*rx++ = (u16)data;\r\ndspi->rx = rx;\r\n}\r\n}\r\nstatic u32 davinci_spi_tx_buf_u8(struct davinci_spi *dspi)\r\n{\r\nu32 data = 0;\r\nif (dspi->tx) {\r\nconst u8 *tx = dspi->tx;\r\ndata = *tx++;\r\ndspi->tx = tx;\r\n}\r\nreturn data;\r\n}\r\nstatic u32 davinci_spi_tx_buf_u16(struct davinci_spi *dspi)\r\n{\r\nu32 data = 0;\r\nif (dspi->tx) {\r\nconst u16 *tx = dspi->tx;\r\ndata = *tx++;\r\ndspi->tx = tx;\r\n}\r\nreturn data;\r\n}\r\nstatic inline void set_io_bits(void __iomem *addr, u32 bits)\r\n{\r\nu32 v = ioread32(addr);\r\nv |= bits;\r\niowrite32(v, addr);\r\n}\r\nstatic inline void clear_io_bits(void __iomem *addr, u32 bits)\r\n{\r\nu32 v = ioread32(addr);\r\nv &= ~bits;\r\niowrite32(v, addr);\r\n}\r\nstatic void davinci_spi_chipselect(struct spi_device *spi, int value)\r\n{\r\nstruct davinci_spi *dspi;\r\nstruct davinci_spi_platform_data *pdata;\r\nu8 chip_sel = spi->chip_select;\r\nu16 spidat1 = CS_DEFAULT;\r\nbool gpio_chipsel = false;\r\ndspi = spi_master_get_devdata(spi->master);\r\npdata = dspi->pdata;\r\nif (pdata->chip_sel && chip_sel < pdata->num_chipselect &&\r\npdata->chip_sel[chip_sel] != SPI_INTERN_CS)\r\ngpio_chipsel = true;\r\nif (gpio_chipsel) {\r\nif (value == BITBANG_CS_ACTIVE)\r\ngpio_set_value(pdata->chip_sel[chip_sel], 0);\r\nelse\r\ngpio_set_value(pdata->chip_sel[chip_sel], 1);\r\n} else {\r\nif (value == BITBANG_CS_ACTIVE) {\r\nspidat1 |= SPIDAT1_CSHOLD_MASK;\r\nspidat1 &= ~(0x1 << chip_sel);\r\n}\r\niowrite16(spidat1, dspi->base + SPIDAT1 + 2);\r\n}\r\n}\r\nstatic inline int davinci_spi_get_prescale(struct davinci_spi *dspi,\r\nu32 max_speed_hz)\r\n{\r\nint ret;\r\nret = DIV_ROUND_UP(clk_get_rate(dspi->clk), max_speed_hz);\r\nif (ret < 3 || ret > 256)\r\nreturn -EINVAL;\r\nreturn ret - 1;\r\n}\r\nstatic int davinci_spi_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct davinci_spi *dspi;\r\nstruct davinci_spi_config *spicfg;\r\nu8 bits_per_word = 0;\r\nu32 hz = 0, spifmt = 0, prescale = 0;\r\ndspi = spi_master_get_devdata(spi->master);\r\nspicfg = (struct davinci_spi_config *)spi->controller_data;\r\nif (!spicfg)\r\nspicfg = &davinci_spi_default_cfg;\r\nif (t) {\r\nbits_per_word = t->bits_per_word;\r\nhz = t->speed_hz;\r\n}\r\nif (!bits_per_word)\r\nbits_per_word = spi->bits_per_word;\r\nif (bits_per_word <= 8 && bits_per_word >= 2) {\r\ndspi->get_rx = davinci_spi_rx_buf_u8;\r\ndspi->get_tx = davinci_spi_tx_buf_u8;\r\ndspi->bytes_per_word[spi->chip_select] = 1;\r\n} else if (bits_per_word <= 16 && bits_per_word >= 2) {\r\ndspi->get_rx = davinci_spi_rx_buf_u16;\r\ndspi->get_tx = davinci_spi_tx_buf_u16;\r\ndspi->bytes_per_word[spi->chip_select] = 2;\r\n} else\r\nreturn -EINVAL;\r\nif (!hz)\r\nhz = spi->max_speed_hz;\r\nprescale = davinci_spi_get_prescale(dspi, hz);\r\nif (prescale < 0)\r\nreturn prescale;\r\nspifmt = (prescale << SPIFMT_PRESCALE_SHIFT) | (bits_per_word & 0x1f);\r\nif (spi->mode & SPI_LSB_FIRST)\r\nspifmt |= SPIFMT_SHIFTDIR_MASK;\r\nif (spi->mode & SPI_CPOL)\r\nspifmt |= SPIFMT_POLARITY_MASK;\r\nif (!(spi->mode & SPI_CPHA))\r\nspifmt |= SPIFMT_PHASE_MASK;\r\nif (dspi->version == SPI_VERSION_2) {\r\nu32 delay = 0;\r\nspifmt |= ((spicfg->wdelay << SPIFMT_WDELAY_SHIFT)\r\n& SPIFMT_WDELAY_MASK);\r\nif (spicfg->odd_parity)\r\nspifmt |= SPIFMT_ODD_PARITY_MASK;\r\nif (spicfg->parity_enable)\r\nspifmt |= SPIFMT_PARITYENA_MASK;\r\nif (spicfg->timer_disable) {\r\nspifmt |= SPIFMT_DISTIMER_MASK;\r\n} else {\r\ndelay |= (spicfg->c2tdelay << SPIDELAY_C2TDELAY_SHIFT)\r\n& SPIDELAY_C2TDELAY_MASK;\r\ndelay |= (spicfg->t2cdelay << SPIDELAY_T2CDELAY_SHIFT)\r\n& SPIDELAY_T2CDELAY_MASK;\r\n}\r\nif (spi->mode & SPI_READY) {\r\nspifmt |= SPIFMT_WAITENA_MASK;\r\ndelay |= (spicfg->t2edelay << SPIDELAY_T2EDELAY_SHIFT)\r\n& SPIDELAY_T2EDELAY_MASK;\r\ndelay |= (spicfg->c2edelay << SPIDELAY_C2EDELAY_SHIFT)\r\n& SPIDELAY_C2EDELAY_MASK;\r\n}\r\niowrite32(delay, dspi->base + SPIDELAY);\r\n}\r\niowrite32(spifmt, dspi->base + SPIFMT0);\r\nreturn 0;\r\n}\r\nstatic int davinci_spi_setup(struct spi_device *spi)\r\n{\r\nint retval = 0;\r\nstruct davinci_spi *dspi;\r\nstruct davinci_spi_platform_data *pdata;\r\ndspi = spi_master_get_devdata(spi->master);\r\npdata = dspi->pdata;\r\nif (!spi->bits_per_word)\r\nspi->bits_per_word = 8;\r\nif (!(spi->mode & SPI_NO_CS)) {\r\nif ((pdata->chip_sel == NULL) ||\r\n(pdata->chip_sel[spi->chip_select] == SPI_INTERN_CS))\r\nset_io_bits(dspi->base + SPIPC0, 1 << spi->chip_select);\r\n}\r\nif (spi->mode & SPI_READY)\r\nset_io_bits(dspi->base + SPIPC0, SPIPC0_SPIENA_MASK);\r\nif (spi->mode & SPI_LOOP)\r\nset_io_bits(dspi->base + SPIGCR1, SPIGCR1_LOOPBACK_MASK);\r\nelse\r\nclear_io_bits(dspi->base + SPIGCR1, SPIGCR1_LOOPBACK_MASK);\r\nreturn retval;\r\n}\r\nstatic int davinci_spi_check_error(struct davinci_spi *dspi, int int_status)\r\n{\r\nstruct device *sdev = dspi->bitbang.master->dev.parent;\r\nif (int_status & SPIFLG_TIMEOUT_MASK) {\r\ndev_dbg(sdev, "SPI Time-out Error\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (int_status & SPIFLG_DESYNC_MASK) {\r\ndev_dbg(sdev, "SPI Desynchronization Error\n");\r\nreturn -EIO;\r\n}\r\nif (int_status & SPIFLG_BITERR_MASK) {\r\ndev_dbg(sdev, "SPI Bit error\n");\r\nreturn -EIO;\r\n}\r\nif (dspi->version == SPI_VERSION_2) {\r\nif (int_status & SPIFLG_DLEN_ERR_MASK) {\r\ndev_dbg(sdev, "SPI Data Length Error\n");\r\nreturn -EIO;\r\n}\r\nif (int_status & SPIFLG_PARERR_MASK) {\r\ndev_dbg(sdev, "SPI Parity Error\n");\r\nreturn -EIO;\r\n}\r\nif (int_status & SPIFLG_OVRRUN_MASK) {\r\ndev_dbg(sdev, "SPI Data Overrun error\n");\r\nreturn -EIO;\r\n}\r\nif (int_status & SPIFLG_BUF_INIT_ACTIVE_MASK) {\r\ndev_dbg(sdev, "SPI Buffer Init Active\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int davinci_spi_process_events(struct davinci_spi *dspi)\r\n{\r\nu32 buf, status, errors = 0, spidat1;\r\nbuf = ioread32(dspi->base + SPIBUF);\r\nif (dspi->rcount > 0 && !(buf & SPIBUF_RXEMPTY_MASK)) {\r\ndspi->get_rx(buf & 0xFFFF, dspi);\r\ndspi->rcount--;\r\n}\r\nstatus = ioread32(dspi->base + SPIFLG);\r\nif (unlikely(status & SPIFLG_ERROR_MASK)) {\r\nerrors = status & SPIFLG_ERROR_MASK;\r\ngoto out;\r\n}\r\nif (dspi->wcount > 0 && !(buf & SPIBUF_TXFULL_MASK)) {\r\nspidat1 = ioread32(dspi->base + SPIDAT1);\r\ndspi->wcount--;\r\nspidat1 &= ~0xFFFF;\r\nspidat1 |= 0xFFFF & dspi->get_tx(dspi);\r\niowrite32(spidat1, dspi->base + SPIDAT1);\r\n}\r\nout:\r\nreturn errors;\r\n}\r\nstatic void davinci_spi_dma_callback(unsigned lch, u16 status, void *data)\r\n{\r\nstruct davinci_spi *dspi = data;\r\nstruct davinci_spi_dma *dma = &dspi->dma;\r\nedma_stop(lch);\r\nif (status == DMA_COMPLETE) {\r\nif (lch == dma->rx_channel)\r\ndspi->rcount = 0;\r\nif (lch == dma->tx_channel)\r\ndspi->wcount = 0;\r\n}\r\nif ((!dspi->wcount && !dspi->rcount) || (status != DMA_COMPLETE))\r\ncomplete(&dspi->done);\r\n}\r\nstatic int davinci_spi_bufs(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct davinci_spi *dspi;\r\nint data_type, ret;\r\nu32 tx_data, spidat1;\r\nu32 errors = 0;\r\nstruct davinci_spi_config *spicfg;\r\nstruct davinci_spi_platform_data *pdata;\r\nunsigned uninitialized_var(rx_buf_count);\r\nstruct device *sdev;\r\ndspi = spi_master_get_devdata(spi->master);\r\npdata = dspi->pdata;\r\nspicfg = (struct davinci_spi_config *)spi->controller_data;\r\nif (!spicfg)\r\nspicfg = &davinci_spi_default_cfg;\r\nsdev = dspi->bitbang.master->dev.parent;\r\ndata_type = dspi->bytes_per_word[spi->chip_select];\r\ndspi->tx = t->tx_buf;\r\ndspi->rx = t->rx_buf;\r\ndspi->wcount = t->len / data_type;\r\ndspi->rcount = dspi->wcount;\r\nspidat1 = ioread32(dspi->base + SPIDAT1);\r\nclear_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);\r\nset_io_bits(dspi->base + SPIGCR1, SPIGCR1_SPIENA_MASK);\r\nINIT_COMPLETION(dspi->done);\r\nif (spicfg->io_type == SPI_IO_TYPE_INTR)\r\nset_io_bits(dspi->base + SPIINT, SPIINT_MASKINT);\r\nif (spicfg->io_type != SPI_IO_TYPE_DMA) {\r\ndspi->wcount--;\r\ntx_data = dspi->get_tx(dspi);\r\nspidat1 &= 0xFFFF0000;\r\nspidat1 |= tx_data & 0xFFFF;\r\niowrite32(spidat1, dspi->base + SPIDAT1);\r\n} else {\r\nstruct davinci_spi_dma *dma;\r\nunsigned long tx_reg, rx_reg;\r\nstruct edmacc_param param;\r\nvoid *rx_buf;\r\nint b, c;\r\ndma = &dspi->dma;\r\ntx_reg = (unsigned long)dspi->pbase + SPIDAT1;\r\nrx_reg = (unsigned long)dspi->pbase + SPIBUF;\r\nif (t->tx_buf) {\r\nt->tx_dma = dma_map_single(&spi->dev, (void *)t->tx_buf,\r\nt->len, DMA_TO_DEVICE);\r\nif (dma_mapping_error(&spi->dev, t->tx_dma)) {\r\ndev_dbg(sdev, "Unable to DMA map %d bytes"\r\n"TX buffer\n", t->len);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nc = dspi->wcount / (SZ_64K - 1);\r\nb = dspi->wcount - c * (SZ_64K - 1);\r\nif (b)\r\nc++;\r\nelse\r\nb = SZ_64K - 1;\r\nparam.opt = TCINTEN | EDMA_TCC(dma->tx_channel);\r\nparam.src = t->tx_buf ? t->tx_dma : tx_reg;\r\nparam.a_b_cnt = b << 16 | data_type;\r\nparam.dst = tx_reg;\r\nparam.src_dst_bidx = t->tx_buf ? data_type : 0;\r\nparam.link_bcntrld = 0xffffffff;\r\nparam.src_dst_cidx = t->tx_buf ? data_type : 0;\r\nparam.ccnt = c;\r\nedma_write_slot(dma->tx_channel, &param);\r\nedma_link(dma->tx_channel, dma->dummy_param_slot);\r\nif (t->rx_buf) {\r\nrx_buf = t->rx_buf;\r\nrx_buf_count = t->len;\r\n} else {\r\nrx_buf = dspi->rx_tmp_buf;\r\nrx_buf_count = sizeof(dspi->rx_tmp_buf);\r\n}\r\nt->rx_dma = dma_map_single(&spi->dev, rx_buf, rx_buf_count,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(&spi->dev, t->rx_dma)) {\r\ndev_dbg(sdev, "Couldn't DMA map a %d bytes RX buffer\n",\r\nrx_buf_count);\r\nif (t->tx_buf)\r\ndma_unmap_single(NULL, t->tx_dma, t->len,\r\nDMA_TO_DEVICE);\r\nreturn -ENOMEM;\r\n}\r\nparam.opt = TCINTEN | EDMA_TCC(dma->rx_channel);\r\nparam.src = rx_reg;\r\nparam.a_b_cnt = b << 16 | data_type;\r\nparam.dst = t->rx_dma;\r\nparam.src_dst_bidx = (t->rx_buf ? data_type : 0) << 16;\r\nparam.link_bcntrld = 0xffffffff;\r\nparam.src_dst_cidx = (t->rx_buf ? data_type : 0) << 16;\r\nparam.ccnt = c;\r\nedma_write_slot(dma->rx_channel, &param);\r\nif (pdata->cshold_bug)\r\niowrite16(spidat1 >> 16, dspi->base + SPIDAT1 + 2);\r\nedma_start(dma->rx_channel);\r\nedma_start(dma->tx_channel);\r\nset_io_bits(dspi->base + SPIINT, SPIINT_DMA_REQ_EN);\r\n}\r\nif (spicfg->io_type != SPI_IO_TYPE_POLL) {\r\nwait_for_completion_interruptible(&(dspi->done));\r\n} else {\r\nwhile (dspi->rcount > 0 || dspi->wcount > 0) {\r\nerrors = davinci_spi_process_events(dspi);\r\nif (errors)\r\nbreak;\r\ncpu_relax();\r\n}\r\n}\r\nclear_io_bits(dspi->base + SPIINT, SPIINT_MASKALL);\r\nif (spicfg->io_type == SPI_IO_TYPE_DMA) {\r\nif (t->tx_buf)\r\ndma_unmap_single(NULL, t->tx_dma, t->len,\r\nDMA_TO_DEVICE);\r\ndma_unmap_single(NULL, t->rx_dma, rx_buf_count,\r\nDMA_FROM_DEVICE);\r\nclear_io_bits(dspi->base + SPIINT, SPIINT_DMA_REQ_EN);\r\n}\r\nclear_io_bits(dspi->base + SPIGCR1, SPIGCR1_SPIENA_MASK);\r\nset_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);\r\nif (errors) {\r\nret = davinci_spi_check_error(dspi, errors);\r\nWARN(!ret, "%s: error reported but no error found!\n",\r\ndev_name(&spi->dev));\r\nreturn ret;\r\n}\r\nif (dspi->rcount != 0 || dspi->wcount != 0) {\r\ndev_err(sdev, "SPI data transfer error\n");\r\nreturn -EIO;\r\n}\r\nreturn t->len;\r\n}\r\nstatic irqreturn_t davinci_spi_irq(s32 irq, void *data)\r\n{\r\nstruct davinci_spi *dspi = data;\r\nint status;\r\nstatus = davinci_spi_process_events(dspi);\r\nif (unlikely(status != 0))\r\nclear_io_bits(dspi->base + SPIINT, SPIINT_MASKINT);\r\nif ((!dspi->rcount && !dspi->wcount) || status)\r\ncomplete(&dspi->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int davinci_spi_request_dma(struct davinci_spi *dspi)\r\n{\r\nint r;\r\nstruct davinci_spi_dma *dma = &dspi->dma;\r\nr = edma_alloc_channel(dma->rx_channel, davinci_spi_dma_callback, dspi,\r\ndma->eventq);\r\nif (r < 0) {\r\npr_err("Unable to request DMA channel for SPI RX\n");\r\nr = -EAGAIN;\r\ngoto rx_dma_failed;\r\n}\r\nr = edma_alloc_channel(dma->tx_channel, davinci_spi_dma_callback, dspi,\r\ndma->eventq);\r\nif (r < 0) {\r\npr_err("Unable to request DMA channel for SPI TX\n");\r\nr = -EAGAIN;\r\ngoto tx_dma_failed;\r\n}\r\nr = edma_alloc_slot(EDMA_CTLR(dma->tx_channel), EDMA_SLOT_ANY);\r\nif (r < 0) {\r\npr_err("Unable to request SPI TX DMA param slot\n");\r\nr = -EAGAIN;\r\ngoto param_failed;\r\n}\r\ndma->dummy_param_slot = r;\r\nedma_link(dma->dummy_param_slot, dma->dummy_param_slot);\r\nreturn 0;\r\nparam_failed:\r\nedma_free_channel(dma->tx_channel);\r\ntx_dma_failed:\r\nedma_free_channel(dma->rx_channel);\r\nrx_dma_failed:\r\nreturn r;\r\n}\r\nstatic int __devinit davinci_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct davinci_spi *dspi;\r\nstruct davinci_spi_platform_data *pdata;\r\nstruct resource *r, *mem;\r\nresource_size_t dma_rx_chan = SPI_NO_RESOURCE;\r\nresource_size_t dma_tx_chan = SPI_NO_RESOURCE;\r\nint i = 0, ret = 0;\r\nu32 spipc0;\r\npdata = pdev->dev.platform_data;\r\nif (pdata == NULL) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct davinci_spi));\r\nif (master == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev_set_drvdata(&pdev->dev, master);\r\ndspi = spi_master_get_devdata(master);\r\nif (dspi == NULL) {\r\nret = -ENOENT;\r\ngoto free_master;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (r == NULL) {\r\nret = -ENOENT;\r\ngoto free_master;\r\n}\r\ndspi->pbase = r->start;\r\ndspi->pdata = pdata;\r\nmem = request_mem_region(r->start, resource_size(r), pdev->name);\r\nif (mem == NULL) {\r\nret = -EBUSY;\r\ngoto free_master;\r\n}\r\ndspi->base = ioremap(r->start, resource_size(r));\r\nif (dspi->base == NULL) {\r\nret = -ENOMEM;\r\ngoto release_region;\r\n}\r\ndspi->irq = platform_get_irq(pdev, 0);\r\nif (dspi->irq <= 0) {\r\nret = -EINVAL;\r\ngoto unmap_io;\r\n}\r\nret = request_irq(dspi->irq, davinci_spi_irq, 0, dev_name(&pdev->dev),\r\ndspi);\r\nif (ret)\r\ngoto unmap_io;\r\ndspi->bitbang.master = spi_master_get(master);\r\nif (dspi->bitbang.master == NULL) {\r\nret = -ENODEV;\r\ngoto irq_free;\r\n}\r\ndspi->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(dspi->clk)) {\r\nret = -ENODEV;\r\ngoto put_master;\r\n}\r\nclk_enable(dspi->clk);\r\nmaster->bus_num = pdev->id;\r\nmaster->num_chipselect = pdata->num_chipselect;\r\nmaster->setup = davinci_spi_setup;\r\ndspi->bitbang.chipselect = davinci_spi_chipselect;\r\ndspi->bitbang.setup_transfer = davinci_spi_setup_transfer;\r\ndspi->version = pdata->version;\r\ndspi->bitbang.flags = SPI_NO_CS | SPI_LSB_FIRST | SPI_LOOP;\r\nif (dspi->version == SPI_VERSION_2)\r\ndspi->bitbang.flags |= SPI_READY;\r\nr = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (r)\r\ndma_rx_chan = r->start;\r\nr = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (r)\r\ndma_tx_chan = r->start;\r\ndspi->bitbang.txrx_bufs = davinci_spi_bufs;\r\nif (dma_rx_chan != SPI_NO_RESOURCE &&\r\ndma_tx_chan != SPI_NO_RESOURCE) {\r\ndspi->dma.rx_channel = dma_rx_chan;\r\ndspi->dma.tx_channel = dma_tx_chan;\r\ndspi->dma.eventq = pdata->dma_event_q;\r\nret = davinci_spi_request_dma(dspi);\r\nif (ret)\r\ngoto free_clk;\r\ndev_info(&pdev->dev, "DMA: supported\n");\r\ndev_info(&pdev->dev, "DMA: RX channel: %d, TX channel: %d, "\r\n"event queue: %d\n", dma_rx_chan, dma_tx_chan,\r\npdata->dma_event_q);\r\n}\r\ndspi->get_rx = davinci_spi_rx_buf_u8;\r\ndspi->get_tx = davinci_spi_tx_buf_u8;\r\ninit_completion(&dspi->done);\r\niowrite32(0, dspi->base + SPIGCR0);\r\nudelay(100);\r\niowrite32(1, dspi->base + SPIGCR0);\r\nspipc0 = SPIPC0_DIFUN_MASK | SPIPC0_DOFUN_MASK | SPIPC0_CLKFUN_MASK;\r\niowrite32(spipc0, dspi->base + SPIPC0);\r\nif (pdata->chip_sel) {\r\nfor (i = 0; i < pdata->num_chipselect; i++) {\r\nif (pdata->chip_sel[i] != SPI_INTERN_CS)\r\ngpio_direction_output(pdata->chip_sel[i], 1);\r\n}\r\n}\r\nif (pdata->intr_line)\r\niowrite32(SPI_INTLVL_1, dspi->base + SPILVL);\r\nelse\r\niowrite32(SPI_INTLVL_0, dspi->base + SPILVL);\r\niowrite32(CS_DEFAULT, dspi->base + SPIDEF);\r\nset_io_bits(dspi->base + SPIGCR1, SPIGCR1_CLKMOD_MASK);\r\nset_io_bits(dspi->base + SPIGCR1, SPIGCR1_MASTER_MASK);\r\nset_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);\r\nret = spi_bitbang_start(&dspi->bitbang);\r\nif (ret)\r\ngoto free_dma;\r\ndev_info(&pdev->dev, "Controller at 0x%p\n", dspi->base);\r\nreturn ret;\r\nfree_dma:\r\nedma_free_channel(dspi->dma.tx_channel);\r\nedma_free_channel(dspi->dma.rx_channel);\r\nedma_free_slot(dspi->dma.dummy_param_slot);\r\nfree_clk:\r\nclk_disable(dspi->clk);\r\nclk_put(dspi->clk);\r\nput_master:\r\nspi_master_put(master);\r\nirq_free:\r\nfree_irq(dspi->irq, dspi);\r\nunmap_io:\r\niounmap(dspi->base);\r\nrelease_region:\r\nrelease_mem_region(dspi->pbase, resource_size(r));\r\nfree_master:\r\nkfree(master);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int __devexit davinci_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct davinci_spi *dspi;\r\nstruct spi_master *master;\r\nstruct resource *r;\r\nmaster = dev_get_drvdata(&pdev->dev);\r\ndspi = spi_master_get_devdata(master);\r\nspi_bitbang_stop(&dspi->bitbang);\r\nclk_disable(dspi->clk);\r\nclk_put(dspi->clk);\r\nspi_master_put(master);\r\nfree_irq(dspi->irq, dspi);\r\niounmap(dspi->base);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(dspi->pbase, resource_size(r));\r\nreturn 0;\r\n}
