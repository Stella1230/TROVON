static __u8 *sony_report_fixup(struct hid_device *hdev, __u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nif ((sc->quirks & VAIO_RDESC_CONSTANT) &&\r\n*rsize >= 56 && rdesc[54] == 0x81 && rdesc[55] == 0x07) {\r\nhid_info(hdev, "Fixing up Sony Vaio VGX report descriptor\n");\r\nrdesc[55] = 0x06;\r\n}\r\nif ((((sc->quirks & SIXAXIS_CONTROLLER_USB) && *rsize == 148) ||\r\n((sc->quirks & SIXAXIS_CONTROLLER_BT) && *rsize == 149)) &&\r\nrdesc[83] == 0x75) {\r\nhid_info(hdev, "Fixing up Sony Sixaxis report descriptor\n");\r\nmemcpy((void *)&rdesc[83], (void *)&sixaxis_rdesc_fixup,\r\nsizeof(sixaxis_rdesc_fixup));\r\n}\r\nreturn rdesc;\r\n}\r\nstatic int sony_raw_event(struct hid_device *hdev, struct hid_report *report,\r\n__u8 *rd, int size)\r\n{\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nif ((sc->quirks & (SIXAXIS_CONTROLLER_USB | SIXAXIS_CONTROLLER_BT)) &&\r\nrd[0] == 0x01 && size == 49) {\r\nswap(rd[41], rd[42]);\r\nswap(rd[43], rd[44]);\r\nswap(rd[45], rd[46]);\r\nswap(rd[47], rd[48]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sixaxis_usb_output_raw_report(struct hid_device *hid, __u8 *buf,\r\nsize_t count, unsigned char report_type)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(hid->dev.parent);\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct usb_host_interface *interface = intf->cur_altsetting;\r\nint report_id = buf[0];\r\nint ret;\r\nif (report_type == HID_OUTPUT_REPORT) {\r\nbuf++;\r\ncount--;\r\n}\r\nret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nHID_REQ_SET_REPORT,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n((report_type + 1) << 8) | report_id,\r\ninterface->desc.bInterfaceNumber, buf, count,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (ret > 0 && report_type == HID_OUTPUT_REPORT)\r\nret++;\r\nreturn ret;\r\n}\r\nstatic int sixaxis_set_operational_usb(struct hid_device *hdev)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\n__u16 ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\r\nint ret;\r\nchar *buf = kmalloc(18, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nHID_REQ_GET_REPORT,\r\nUSB_DIR_IN | USB_TYPE_CLASS |\r\nUSB_RECIP_INTERFACE,\r\n(3 << 8) | 0xf2, ifnum, buf, 17,\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (ret < 0)\r\nhid_err(hdev, "can't set operational mode\n");\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int sixaxis_set_operational_bt(struct hid_device *hdev)\r\n{\r\nunsigned char buf[] = { 0xf4, 0x42, 0x03, 0x00, 0x00 };\r\nreturn hdev->hid_output_raw_report(hdev, buf, sizeof(buf), HID_FEATURE_REPORT);\r\n}\r\nstatic int sony_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nint ret;\r\nunsigned long quirks = id->driver_data;\r\nstruct sony_sc *sc;\r\nsc = kzalloc(sizeof(*sc), GFP_KERNEL);\r\nif (sc == NULL) {\r\nhid_err(hdev, "can't alloc sony descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\nsc->quirks = quirks;\r\nhid_set_drvdata(hdev, sc);\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\ngoto err_free;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT |\r\nHID_CONNECT_HIDDEV_FORCE);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\ngoto err_free;\r\n}\r\nif (sc->quirks & SIXAXIS_CONTROLLER_USB) {\r\nhdev->hid_output_raw_report = sixaxis_usb_output_raw_report;\r\nret = sixaxis_set_operational_usb(hdev);\r\n}\r\nelse if (sc->quirks & SIXAXIS_CONTROLLER_BT)\r\nret = sixaxis_set_operational_bt(hdev);\r\nelse\r\nret = 0;\r\nif (ret < 0)\r\ngoto err_stop;\r\nreturn 0;\r\nerr_stop:\r\nhid_hw_stop(hdev);\r\nerr_free:\r\nkfree(sc);\r\nreturn ret;\r\n}\r\nstatic void sony_remove(struct hid_device *hdev)\r\n{\r\nhid_hw_stop(hdev);\r\nkfree(hid_get_drvdata(hdev));\r\n}\r\nstatic int __init sony_init(void)\r\n{\r\nreturn hid_register_driver(&sony_driver);\r\n}\r\nstatic void __exit sony_exit(void)\r\n{\r\nhid_unregister_driver(&sony_driver);\r\n}
