static inline int xen_tmem_op(u32 tmem_cmd, u32 tmem_pool, struct tmem_oid oid,\r\nu32 index, unsigned long gmfn, u32 tmem_offset, u32 pfn_offset, u32 len)\r\n{\r\nstruct tmem_op op;\r\nint rc = 0;\r\nop.cmd = tmem_cmd;\r\nop.pool_id = tmem_pool;\r\nop.u.gen.oid[0] = oid.oid[0];\r\nop.u.gen.oid[1] = oid.oid[1];\r\nop.u.gen.oid[2] = oid.oid[2];\r\nop.u.gen.index = index;\r\nop.u.gen.tmem_offset = tmem_offset;\r\nop.u.gen.pfn_offset = pfn_offset;\r\nop.u.gen.len = len;\r\nset_xen_guest_handle(op.u.gen.gmfn, (void *)gmfn);\r\nrc = HYPERVISOR_tmem_op(&op);\r\nreturn rc;\r\n}\r\nstatic int xen_tmem_new_pool(struct tmem_pool_uuid uuid,\r\nu32 flags, unsigned long pagesize)\r\n{\r\nstruct tmem_op op;\r\nint rc = 0, pageshift;\r\nfor (pageshift = 0; pagesize != 1; pageshift++)\r\npagesize >>= 1;\r\nflags |= (pageshift - 12) << TMEM_POOL_PAGESIZE_SHIFT;\r\nflags |= TMEM_SPEC_VERSION << TMEM_VERSION_SHIFT;\r\nop.cmd = TMEM_NEW_POOL;\r\nop.u.new.uuid[0] = uuid.uuid_lo;\r\nop.u.new.uuid[1] = uuid.uuid_hi;\r\nop.u.new.flags = flags;\r\nrc = HYPERVISOR_tmem_op(&op);\r\nreturn rc;\r\n}\r\nstatic int xen_tmem_put_page(u32 pool_id, struct tmem_oid oid,\r\nu32 index, unsigned long pfn)\r\n{\r\nunsigned long gmfn = xen_pv_domain() ? pfn_to_mfn(pfn) : pfn;\r\nreturn xen_tmem_op(TMEM_PUT_PAGE, pool_id, oid, index,\r\ngmfn, 0, 0, 0);\r\n}\r\nstatic int xen_tmem_get_page(u32 pool_id, struct tmem_oid oid,\r\nu32 index, unsigned long pfn)\r\n{\r\nunsigned long gmfn = xen_pv_domain() ? pfn_to_mfn(pfn) : pfn;\r\nreturn xen_tmem_op(TMEM_GET_PAGE, pool_id, oid, index,\r\ngmfn, 0, 0, 0);\r\n}\r\nstatic int xen_tmem_flush_page(u32 pool_id, struct tmem_oid oid, u32 index)\r\n{\r\nreturn xen_tmem_op(TMEM_FLUSH_PAGE, pool_id, oid, index,\r\n0, 0, 0, 0);\r\n}\r\nstatic int xen_tmem_flush_object(u32 pool_id, struct tmem_oid oid)\r\n{\r\nreturn xen_tmem_op(TMEM_FLUSH_OBJECT, pool_id, oid, 0, 0, 0, 0, 0);\r\n}\r\nstatic int __init enable_tmem(char *s)\r\n{\r\ntmem_enabled = 1;\r\nreturn 1;\r\n}\r\nstatic int xen_tmem_destroy_pool(u32 pool_id)\r\n{\r\nstruct tmem_oid oid = { { 0 } };\r\nreturn xen_tmem_op(TMEM_DESTROY_POOL, pool_id, oid, 0, 0, 0, 0, 0);\r\n}\r\nstatic void tmem_cleancache_put_page(int pool, struct cleancache_filekey key,\r\npgoff_t index, struct page *page)\r\n{\r\nu32 ind = (u32) index;\r\nstruct tmem_oid oid = *(struct tmem_oid *)&key;\r\nunsigned long pfn = page_to_pfn(page);\r\nif (pool < 0)\r\nreturn;\r\nif (ind != index)\r\nreturn;\r\nmb();\r\n(void)xen_tmem_put_page((u32)pool, oid, ind, pfn);\r\n}\r\nstatic int tmem_cleancache_get_page(int pool, struct cleancache_filekey key,\r\npgoff_t index, struct page *page)\r\n{\r\nu32 ind = (u32) index;\r\nstruct tmem_oid oid = *(struct tmem_oid *)&key;\r\nunsigned long pfn = page_to_pfn(page);\r\nint ret;\r\nif (pool < 0)\r\nreturn -1;\r\nif (ind != index)\r\nreturn -1;\r\nret = xen_tmem_get_page((u32)pool, oid, ind, pfn);\r\nif (ret == 1)\r\nreturn 0;\r\nelse\r\nreturn -1;\r\n}\r\nstatic void tmem_cleancache_flush_page(int pool, struct cleancache_filekey key,\r\npgoff_t index)\r\n{\r\nu32 ind = (u32) index;\r\nstruct tmem_oid oid = *(struct tmem_oid *)&key;\r\nif (pool < 0)\r\nreturn;\r\nif (ind != index)\r\nreturn;\r\n(void)xen_tmem_flush_page((u32)pool, oid, ind);\r\n}\r\nstatic void tmem_cleancache_flush_inode(int pool, struct cleancache_filekey key)\r\n{\r\nstruct tmem_oid oid = *(struct tmem_oid *)&key;\r\nif (pool < 0)\r\nreturn;\r\n(void)xen_tmem_flush_object((u32)pool, oid);\r\n}\r\nstatic void tmem_cleancache_flush_fs(int pool)\r\n{\r\nif (pool < 0)\r\nreturn;\r\n(void)xen_tmem_destroy_pool((u32)pool);\r\n}\r\nstatic int tmem_cleancache_init_fs(size_t pagesize)\r\n{\r\nstruct tmem_pool_uuid uuid_private = TMEM_POOL_PRIVATE_UUID;\r\nreturn xen_tmem_new_pool(uuid_private, 0, pagesize);\r\n}\r\nstatic int tmem_cleancache_init_shared_fs(char *uuid, size_t pagesize)\r\n{\r\nstruct tmem_pool_uuid shared_uuid;\r\nshared_uuid.uuid_lo = *(u64 *)uuid;\r\nshared_uuid.uuid_hi = *(u64 *)(&uuid[8]);\r\nreturn xen_tmem_new_pool(shared_uuid, TMEM_POOL_SHARED, pagesize);\r\n}\r\nstatic int __init no_cleancache(char *s)\r\n{\r\nuse_cleancache = 0;\r\nreturn 1;\r\n}\r\nstatic inline struct tmem_oid oswiz(unsigned type, u32 ind)\r\n{\r\nstruct tmem_oid oid = { .oid = { 0 } };\r\noid.oid[0] = _oswiz(type, ind);\r\nreturn oid;\r\n}\r\nstatic int tmem_frontswap_put_page(unsigned type, pgoff_t offset,\r\nstruct page *page)\r\n{\r\nu64 ind64 = (u64)offset;\r\nu32 ind = (u32)offset;\r\nunsigned long pfn = page_to_pfn(page);\r\nint pool = tmem_frontswap_poolid;\r\nint ret;\r\nif (pool < 0)\r\nreturn -1;\r\nif (ind64 != ind)\r\nreturn -1;\r\nmb();\r\nret = xen_tmem_put_page(pool, oswiz(type, ind), iswiz(ind), pfn);\r\nif (ret == 1)\r\nreturn 0;\r\nelse\r\nreturn -1;\r\n}\r\nstatic int tmem_frontswap_get_page(unsigned type, pgoff_t offset,\r\nstruct page *page)\r\n{\r\nu64 ind64 = (u64)offset;\r\nu32 ind = (u32)offset;\r\nunsigned long pfn = page_to_pfn(page);\r\nint pool = tmem_frontswap_poolid;\r\nint ret;\r\nif (pool < 0)\r\nreturn -1;\r\nif (ind64 != ind)\r\nreturn -1;\r\nret = xen_tmem_get_page(pool, oswiz(type, ind), iswiz(ind), pfn);\r\nif (ret == 1)\r\nreturn 0;\r\nelse\r\nreturn -1;\r\n}\r\nstatic void tmem_frontswap_flush_page(unsigned type, pgoff_t offset)\r\n{\r\nu64 ind64 = (u64)offset;\r\nu32 ind = (u32)offset;\r\nint pool = tmem_frontswap_poolid;\r\nif (pool < 0)\r\nreturn;\r\nif (ind64 != ind)\r\nreturn;\r\n(void) xen_tmem_flush_page(pool, oswiz(type, ind), iswiz(ind));\r\n}\r\nstatic void tmem_frontswap_flush_area(unsigned type)\r\n{\r\nint pool = tmem_frontswap_poolid;\r\nint ind;\r\nif (pool < 0)\r\nreturn;\r\nfor (ind = SWIZ_MASK; ind >= 0; ind--)\r\n(void)xen_tmem_flush_object(pool, oswiz(type, ind));\r\n}\r\nstatic void tmem_frontswap_init(unsigned ignored)\r\n{\r\nstruct tmem_pool_uuid private = TMEM_POOL_PRIVATE_UUID;\r\nif (tmem_frontswap_poolid < 0)\r\ntmem_frontswap_poolid =\r\nxen_tmem_new_pool(private, TMEM_POOL_PERSIST, PAGE_SIZE);\r\n}\r\nstatic int __init no_frontswap(char *s)\r\n{\r\nuse_frontswap = 0;\r\nreturn 1;\r\n}\r\nstatic int __init xen_tmem_init(void)\r\n{\r\nif (!xen_domain())\r\nreturn 0;\r\n#ifdef CONFIG_FRONTSWAP\r\nif (tmem_enabled && use_frontswap) {\r\nchar *s = "";\r\nstruct frontswap_ops old_ops =\r\nfrontswap_register_ops(&tmem_frontswap_ops);\r\ntmem_frontswap_poolid = -1;\r\nif (old_ops.init != NULL)\r\ns = " (WARNING: frontswap_ops overridden)";\r\nprintk(KERN_INFO "frontswap enabled, RAM provided by "\r\n"Xen Transcendent Memory\n");\r\n}\r\n#endif\r\n#ifdef CONFIG_CLEANCACHE\r\nBUG_ON(sizeof(struct cleancache_filekey) != sizeof(struct tmem_oid));\r\nif (tmem_enabled && use_cleancache) {\r\nchar *s = "";\r\nstruct cleancache_ops old_ops =\r\ncleancache_register_ops(&tmem_cleancache_ops);\r\nif (old_ops.init_fs != NULL)\r\ns = " (WARNING: cleancache_ops overridden)";\r\nprintk(KERN_INFO "cleancache enabled, RAM provided by "\r\n"Xen Transcendent Memory%s\n", s);\r\n}\r\n#endif\r\nreturn 0;\r\n}
