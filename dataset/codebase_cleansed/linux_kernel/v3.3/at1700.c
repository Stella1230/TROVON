static void cleanup_card(struct net_device *dev)\r\n{\r\n#ifdef CONFIG_MCA_LEGACY\r\nstruct net_local *lp = netdev_priv(dev);\r\nif (lp->mca_slot >= 0)\r\nmca_mark_as_unused(lp->mca_slot);\r\n#endif\r\nfree_irq(dev->irq, NULL);\r\nrelease_region(dev->base_addr, AT1700_IO_EXTENT);\r\n}\r\nstruct net_device * __init at1700_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct net_local));\r\nunsigned *port;\r\nint err = 0;\r\nif (!dev)\r\nreturn ERR_PTR(-ENODEV);\r\nif (unit >= 0) {\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nio = dev->base_addr;\r\nirq = dev->irq;\r\n} else {\r\ndev->base_addr = io;\r\ndev->irq = irq;\r\n}\r\nif (io > 0x1ff) {\r\nerr = at1700_probe1(dev, io);\r\n} else if (io != 0) {\r\nerr = -ENXIO;\r\n} else {\r\nfor (port = at1700_probe_list; *port; port++) {\r\nif (at1700_probe1(dev, *port) == 0)\r\nbreak;\r\ndev->irq = irq;\r\n}\r\nif (!*port)\r\nerr = -ENODEV;\r\n}\r\nif (err)\r\ngoto out;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out1;\r\nreturn dev;\r\nout1:\r\ncleanup_card(dev);\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init at1700_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nstatic const char fmv_irqmap[4] = {3, 7, 10, 15};\r\nstatic const char fmv_irqmap_pnp[8] = {3, 4, 5, 7, 9, 10, 11, 15};\r\nstatic const char at1700_irqmap[8] = {3, 4, 5, 9, 10, 11, 14, 15};\r\nunsigned int i, irq, is_fmv18x = 0, is_at1700 = 0;\r\nint slot, ret = -ENODEV;\r\nstruct net_local *lp = netdev_priv(dev);\r\nif (!request_region(ioaddr, AT1700_IO_EXTENT, DRV_NAME))\r\nreturn -EBUSY;\r\n#ifdef notdef\r\nprintk("at1700 probe at %#x, eeprom is %4.4x %4.4x %4.4x ctrl %4.4x.\n",\r\nioaddr, read_eeprom(ioaddr, 4), read_eeprom(ioaddr, 5),\r\nread_eeprom(ioaddr, 6), inw(ioaddr + EEPROM_Ctrl));\r\n#endif\r\n#ifdef CONFIG_MCA_LEGACY\r\nif (MCA_bus) {\r\nint j;\r\nint l_i;\r\nu_char pos3, pos4;\r\nfor (j = 0; at1720_mca_adapters[j].name != NULL; j ++) {\r\nslot = 0;\r\nwhile (slot != MCA_NOTFOUND) {\r\nslot = mca_find_unused_adapter( at1720_mca_adapters[j].id, slot );\r\nif (slot == MCA_NOTFOUND) break;\r\npos3 = mca_read_stored_pos( slot, 3 );\r\npos4 = mca_read_stored_pos( slot, 4 );\r\nfor (l_i = 0; l_i < 8; l_i++)\r\nif (( pos3 & 0x07) == at1700_ioaddr_pattern[l_i])\r\nbreak;\r\nioaddr = at1700_mca_probe_list[l_i];\r\nfor (irq = 0; irq < 0x10; irq++)\r\nif (((((pos4>>4) & 0x0f) | (pos3 & 0xf0)) & 0xff) == at1700_irq_pattern[irq])\r\nbreak;\r\nif ((dev->irq && dev->irq != irq) ||\r\n(dev->base_addr && dev->base_addr != ioaddr)) {\r\nslot++;\r\ncontinue;\r\n}\r\ndev->irq = irq;\r\nmca_set_adapter_name( slot, at1720_mca_adapters[j].name );\r\nmca_mark_as_used(slot);\r\ngoto found;\r\n}\r\n}\r\n}\r\n#endif\r\nslot = -1;\r\nif (at1700_probe_list[inb(ioaddr + IOCONFIG1) & 0x07] == ioaddr &&\r\nread_eeprom(ioaddr, 4) == 0x0000 &&\r\n(read_eeprom(ioaddr, 5) & 0xff00) == 0xF400)\r\nis_at1700 = 1;\r\nelse if (inb(ioaddr + SAPROM ) == 0x00 &&\r\ninb(ioaddr + SAPROM + 1) == 0x00 &&\r\ninb(ioaddr + SAPROM + 2) == 0x0e)\r\nis_fmv18x = 1;\r\nelse {\r\ngoto err_out;\r\n}\r\n#ifdef CONFIG_MCA_LEGACY\r\nfound:\r\n#endif\r\noutb(0, ioaddr + RESET);\r\nif (is_at1700) {\r\nirq = at1700_irqmap[(read_eeprom(ioaddr, 12)&0x04)\r\n| (read_eeprom(ioaddr, 0)>>14)];\r\n} else {\r\nif (inb(ioaddr + CARDSTATUS1) & 0x20) {\r\nirq = dev->irq;\r\nfor (i = 0; i < 8; i++) {\r\nif (irq == fmv_irqmap_pnp[i])\r\nbreak;\r\n}\r\nif (i == 8) {\r\ngoto err_mca;\r\n}\r\n} else {\r\nif (fmv18x_probe_list[inb(ioaddr + IOCONFIG) & 0x07] != ioaddr)\r\ngoto err_mca;\r\nirq = fmv_irqmap[(inb(ioaddr + IOCONFIG)>>6) & 0x03];\r\n}\r\n}\r\nprintk("%s: %s found at %#3x, IRQ %d, address ", dev->name,\r\nis_at1700 ? "AT1700" : "FMV-18X", ioaddr, irq);\r\ndev->base_addr = ioaddr;\r\ndev->irq = irq;\r\nif (is_at1700) {\r\nfor(i = 0; i < 3; i++) {\r\nunsigned short eeprom_val = read_eeprom(ioaddr, 4+i);\r\n((unsigned short *)dev->dev_addr)[i] = ntohs(eeprom_val);\r\n}\r\n} else {\r\nfor(i = 0; i < 6; i++) {\r\nunsigned char val = inb(ioaddr + SAPROM + i);\r\ndev->dev_addr[i] = val;\r\n}\r\n}\r\nprintk("%pM", dev->dev_addr);\r\n{\r\nconst char *porttype[] = {"auto-sense", "10baseT", "auto-sense", "10base2"};\r\nif (is_at1700) {\r\nushort setup_value = read_eeprom(ioaddr, 12);\r\ndev->if_port = setup_value >> 8;\r\n} else {\r\nushort setup_value = inb(ioaddr + CARDSTATUS);\r\nswitch (setup_value & 0x07) {\r\ncase 0x01:\r\ncase 0x02:\r\ndev->if_port = 0x18; break;\r\ncase 0x04:\r\ndev->if_port = 0x08; break;\r\ndefault:\r\ndev->if_port = 0x00; break;\r\n}\r\n}\r\nprintk(" %s interface.\n", porttype[(dev->if_port>>3) & 3]);\r\n}\r\noutb(0xda, ioaddr + CONFIG_0);\r\noutb(0x00, ioaddr + CONFIG_1);\r\nfor (i = 0; i < 6; i++)\r\noutb(dev->dev_addr[i], ioaddr + PORT_OFFSET(8 + i));\r\noutb(0x04, ioaddr + CONFIG_1);\r\nfor (i = 0; i < 8; i++)\r\noutb(0x00, ioaddr + PORT_OFFSET(8 + i));\r\noutb(0x08, ioaddr + CONFIG_1);\r\noutb(dev->if_port, ioaddr + MODE13);\r\noutb(0x00, ioaddr + COL16CNTL);\r\nif (net_debug)\r\nprintk(version);\r\ndev->netdev_ops = &at1700_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nspin_lock_init(&lp->lock);\r\nlp->jumpered = is_fmv18x;\r\nlp->mca_slot = slot;\r\nret = request_irq(irq, net_interrupt, 0, DRV_NAME, dev);\r\nif (ret) {\r\nprintk(KERN_ERR "AT1700 at %#3x is unusable due to a "\r\n"conflict on IRQ %d.\n",\r\nioaddr, irq);\r\ngoto err_mca;\r\n}\r\nreturn 0;\r\nerr_mca:\r\n#ifdef CONFIG_MCA_LEGACY\r\nif (slot >= 0)\r\nmca_mark_as_unused(slot);\r\n#endif\r\nerr_out:\r\nrelease_region(ioaddr, AT1700_IO_EXTENT);\r\nreturn ret;\r\n}\r\nstatic int __init read_eeprom(long ioaddr, int location)\r\n{\r\nint i;\r\nunsigned short retval = 0;\r\nlong ee_addr = ioaddr + EEPROM_Ctrl;\r\nlong ee_daddr = ioaddr + EEPROM_Data;\r\nint read_cmd = location | EE_READ_CMD;\r\nfor (i = 9; i >= 0; i--) {\r\nshort dataval = (read_cmd & (1 << i)) ? EE_DATA_WRITE : 0;\r\noutb(EE_CS, ee_addr);\r\noutb(dataval, ee_daddr);\r\noutb(EE_CS | EE_SHIFT_CLK, ee_addr);\r\n}\r\noutb(EE_DATA_WRITE, ee_daddr);\r\nfor (i = 16; i > 0; i--) {\r\noutb(EE_CS, ee_addr);\r\noutb(EE_CS | EE_SHIFT_CLK, ee_addr);\r\nretval = (retval << 1) | ((inb(ee_daddr) & EE_DATA_READ) ? 1 : 0);\r\n}\r\noutb(EE_CS, ee_addr);\r\noutb(EE_SHIFT_CLK, ee_addr);\r\noutb(0, ee_addr);\r\nreturn retval;\r\n}\r\nstatic int net_open(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\noutb(0x5a, ioaddr + CONFIG_0);\r\noutb(0xe8, ioaddr + CONFIG_1);\r\nlp->tx_started = 0;\r\nlp->tx_queue_ready = 1;\r\nlp->rx_started = 0;\r\nlp->tx_queue = 0;\r\nlp->tx_queue_len = 0;\r\noutb(0x82, ioaddr + TX_INTR);\r\noutb(0x81, ioaddr + RX_INTR);\r\nif (lp->jumpered) {\r\noutb(0x80, ioaddr + IOCONFIG1);\r\n}\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void net_tx_timeout (struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nprintk ("%s: transmit timed out with status %04x, %s?\n", dev->name,\r\ninw (ioaddr + STATUS), inb (ioaddr + TX_STATUS) & 0x80\r\n? "IRQ conflict" : "network cable problem");\r\nprintk ("%s: timeout registers: %04x %04x %04x %04x %04x %04x %04x %04x.\n",\r\ndev->name, inw(ioaddr + TX_STATUS), inw(ioaddr + TX_INTR), inw(ioaddr + TX_MODE),\r\ninw(ioaddr + CONFIG_0), inw(ioaddr + DATAPORT), inw(ioaddr + TX_START),\r\ninw(ioaddr + MODE13 - 1), inw(ioaddr + RX_CTRL));\r\ndev->stats.tx_errors++;\r\noutw(0xffff, ioaddr + MODE24);\r\noutw (0xffff, ioaddr + TX_STATUS);\r\noutb (0x5a, ioaddr + CONFIG_0);\r\noutb (0xe8, ioaddr + CONFIG_1);\r\noutw (0x8182, ioaddr + TX_INTR);\r\noutb (0x00, ioaddr + TX_START);\r\noutb (0x03, ioaddr + COL16CNTL);\r\ndev->trans_start = jiffies;\r\nlp->tx_started = 0;\r\nlp->tx_queue_ready = 1;\r\nlp->rx_started = 0;\r\nlp->tx_queue = 0;\r\nlp->tx_queue_len = 0;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t net_send_packet (struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nshort length = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\r\nshort len = skb->len;\r\nunsigned char *buf = skb->data;\r\nstatic u8 pad[ETH_ZLEN];\r\nnetif_stop_queue (dev);\r\nlp->tx_queue_ready = 0;\r\n{\r\noutw (length, ioaddr + DATAPORT);\r\noutsw (ioaddr + DATAPORT, buf, len >> 1);\r\nif (len & 1) {\r\noutw(skb->data[skb->len-1], ioaddr + DATAPORT);\r\nlen++;\r\n}\r\nif (length != skb->len)\r\noutsw(ioaddr + DATAPORT, pad, (length - len + 1) >> 1);\r\nlp->tx_queue++;\r\nlp->tx_queue_len += length + 2;\r\n}\r\nlp->tx_queue_ready = 1;\r\nif (lp->tx_started == 0) {\r\noutb (0x80 | lp->tx_queue, ioaddr + TX_START);\r\nlp->tx_queue = 0;\r\nlp->tx_queue_len = 0;\r\nlp->tx_started = 1;\r\nnetif_start_queue (dev);\r\n} else if (lp->tx_queue_len < 4096 - 1502)\r\nnetif_start_queue (dev);\r\ndev_kfree_skb (skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t net_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct net_local *lp;\r\nint ioaddr, status;\r\nint handled = 0;\r\nif (dev == NULL) {\r\nprintk ("at1700_interrupt(): irq %d for unknown device.\n", irq);\r\nreturn IRQ_NONE;\r\n}\r\nioaddr = dev->base_addr;\r\nlp = netdev_priv(dev);\r\nspin_lock (&lp->lock);\r\nstatus = inw(ioaddr + TX_STATUS);\r\noutw(status, ioaddr + TX_STATUS);\r\nif (net_debug > 4)\r\nprintk("%s: Interrupt with status %04x.\n", dev->name, status);\r\nif (lp->rx_started == 0 &&\r\n(status & 0xff00 || (inb(ioaddr + RX_MODE) & 0x40) == 0)) {\r\nhandled = 1;\r\nlp->rx_started = 1;\r\noutb(0x00, ioaddr + RX_INTR);\r\nnet_rx(dev);\r\noutb(0x81, ioaddr + RX_INTR);\r\nlp->rx_started = 0;\r\n}\r\nif (status & 0x00ff) {\r\nhandled = 1;\r\nif (status & 0x02) {\r\nif (net_debug > 4)\r\nprintk("%s: 16 Collision occur during Txing.\n", dev->name);\r\noutb(0x03, ioaddr + COL16CNTL);\r\ndev->stats.collisions++;\r\n}\r\nif (status & 0x82) {\r\ndev->stats.tx_packets++;\r\nif (lp->tx_queue && lp->tx_queue_ready) {\r\noutb(0x80 | lp->tx_queue, ioaddr + TX_START);\r\nlp->tx_queue = 0;\r\nlp->tx_queue_len = 0;\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue (dev);\r\n} else {\r\nlp->tx_started = 0;\r\nnetif_wake_queue (dev);\r\n}\r\n}\r\n}\r\nspin_unlock (&lp->lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void\r\nnet_rx(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nint boguscount = 5;\r\nwhile ((inb(ioaddr + RX_MODE) & 0x40) == 0) {\r\nushort status = inw(ioaddr + DATAPORT);\r\nushort pkt_len = inw(ioaddr + DATAPORT);\r\nif (net_debug > 4)\r\nprintk("%s: Rxing packet mode %02x status %04x.\n",\r\ndev->name, inb(ioaddr + RX_MODE), status);\r\n#ifndef final_version\r\nif (status == 0) {\r\noutb(0x05, ioaddr + RX_CTRL);\r\nbreak;\r\n}\r\n#endif\r\nif ((status & 0xF0) != 0x20) {\r\ndev->stats.rx_errors++;\r\nif (status & 0x08) dev->stats.rx_length_errors++;\r\nif (status & 0x04) dev->stats.rx_frame_errors++;\r\nif (status & 0x02) dev->stats.rx_crc_errors++;\r\nif (status & 0x01) dev->stats.rx_over_errors++;\r\n} else {\r\nstruct sk_buff *skb;\r\nif (pkt_len > 1550) {\r\nprintk("%s: The AT1700 claimed a very large packet, size %d.\n",\r\ndev->name, pkt_len);\r\ninw(ioaddr + DATAPORT); inw(ioaddr + DATAPORT);\r\noutb(0x05, ioaddr + RX_CTRL);\r\ndev->stats.rx_errors++;\r\nbreak;\r\n}\r\nskb = dev_alloc_skb(pkt_len+3);\r\nif (skb == NULL) {\r\nprintk("%s: Memory squeeze, dropping packet (len %d).\n",\r\ndev->name, pkt_len);\r\ninw(ioaddr + DATAPORT); inw(ioaddr + DATAPORT);\r\noutb(0x05, ioaddr + RX_CTRL);\r\ndev->stats.rx_dropped++;\r\nbreak;\r\n}\r\nskb_reserve(skb,2);\r\ninsw(ioaddr + DATAPORT, skb_put(skb,pkt_len), (pkt_len + 1) >> 1);\r\nskb->protocol=eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n}\r\nif (--boguscount <= 0)\r\nbreak;\r\n}\r\n{\r\nint i;\r\nfor (i = 0; i < 20; i++) {\r\nif ((inb(ioaddr + RX_MODE) & 0x40) == 0x40)\r\nbreak;\r\ninw(ioaddr + DATAPORT);\r\noutb(0x05, ioaddr + RX_CTRL);\r\n}\r\nif (net_debug > 5)\r\nprintk("%s: Exint Rx packet with mode %02x after %d ticks.\n",\r\ndev->name, inb(ioaddr + RX_MODE), i);\r\n}\r\n}\r\nstatic int net_close(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nnetif_stop_queue(dev);\r\noutb(0xda, ioaddr + CONFIG_0);\r\nif (lp->jumpered)\r\noutb(0x00, ioaddr + IOCONFIG1);\r\noutb(0x00, ioaddr + CONFIG_1);\r\nreturn 0;\r\n}\r\nstatic void\r\nset_rx_mode(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned char mc_filter[8];\r\nunsigned long flags;\r\nif (dev->flags & IFF_PROMISC) {\r\nmemset(mc_filter, 0xff, sizeof(mc_filter));\r\noutb(3, ioaddr + RX_MODE);\r\n} else if (netdev_mc_count(dev) > MC_FILTERBREAK ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\nmemset(mc_filter, 0xff, sizeof(mc_filter));\r\noutb(2, ioaddr + RX_MODE);\r\n} else if (netdev_mc_empty(dev)) {\r\nmemset(mc_filter, 0x00, sizeof(mc_filter));\r\noutb(1, ioaddr + RX_MODE);\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nmemset(mc_filter, 0, sizeof(mc_filter));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nunsigned int bit =\r\nether_crc_le(ETH_ALEN, ha->addr) >> 26;\r\nmc_filter[bit >> 3] |= (1 << bit);\r\n}\r\noutb(0x02, ioaddr + RX_MODE);\r\n}\r\nspin_lock_irqsave (&lp->lock, flags);\r\nif (memcmp(mc_filter, lp->mc_filter, sizeof(mc_filter))) {\r\nint i;\r\nint saved_bank = inw(ioaddr + CONFIG_0);\r\noutw((saved_bank & ~0x0C00) | 0x0480, ioaddr + CONFIG_0);\r\nfor (i = 0; i < 8; i++)\r\noutb(mc_filter[i], ioaddr + PORT_OFFSET(8 + i));\r\nmemcpy(lp->mc_filter, mc_filter, sizeof(mc_filter));\r\noutw(saved_bank, ioaddr + CONFIG_0);\r\n}\r\nspin_unlock_irqrestore (&lp->lock, flags);\r\n}\r\nstatic int __init at1700_module_init(void)\r\n{\r\nif (io == 0)\r\nprintk("at1700: You should not use auto-probing with insmod!\n");\r\ndev_at1700 = at1700_probe(-1);\r\nif (IS_ERR(dev_at1700))\r\nreturn PTR_ERR(dev_at1700);\r\nreturn 0;\r\n}\r\nstatic void __exit at1700_module_exit(void)\r\n{\r\nunregister_netdev(dev_at1700);\r\ncleanup_card(dev_at1700);\r\nfree_netdev(dev_at1700);\r\n}
