static void initio_do_pause(unsigned amount)\r\n{\r\nunsigned long the_time = jiffies + amount;\r\nwhile (time_before_eq(jiffies, the_time))\r\ncpu_relax();\r\n}\r\nstatic void initio_se2_instr(unsigned long base, u8 instr)\r\n{\r\nint i;\r\nu8 b;\r\noutb(SE2CS | SE2DO, base + TUL_NVRAM);\r\nudelay(30);\r\noutb(SE2CS | SE2CLK | SE2DO, base + TUL_NVRAM);\r\nudelay(30);\r\nfor (i = 0; i < 8; i++) {\r\nif (instr & 0x80)\r\nb = SE2CS | SE2DO;\r\nelse\r\nb = SE2CS;\r\noutb(b, base + TUL_NVRAM);\r\nudelay(30);\r\noutb(b | SE2CLK, base + TUL_NVRAM);\r\nudelay(30);\r\ninstr <<= 1;\r\n}\r\noutb(SE2CS, base + TUL_NVRAM);\r\nudelay(30);\r\n}\r\nvoid initio_se2_ew_en(unsigned long base)\r\n{\r\ninitio_se2_instr(base, 0x30);\r\noutb(0, base + TUL_NVRAM);\r\nudelay(30);\r\n}\r\nvoid initio_se2_ew_ds(unsigned long base)\r\n{\r\ninitio_se2_instr(base, 0);\r\noutb(0, base + TUL_NVRAM);\r\nudelay(30);\r\n}\r\nstatic u16 initio_se2_rd(unsigned long base, u8 addr)\r\n{\r\nu8 instr, rb;\r\nu16 val = 0;\r\nint i;\r\ninstr = (u8) (addr | 0x80);\r\ninitio_se2_instr(base, instr);\r\nfor (i = 15; i >= 0; i--) {\r\noutb(SE2CS | SE2CLK, base + TUL_NVRAM);\r\nudelay(30);\r\noutb(SE2CS, base + TUL_NVRAM);\r\nrb = inb(base + TUL_NVRAM);\r\nrb &= SE2DI;\r\nval += (rb << i);\r\nudelay(30);\r\n}\r\noutb(0, base + TUL_NVRAM);\r\nudelay(30);\r\nreturn val;\r\n}\r\nstatic void initio_se2_wr(unsigned long base, u8 addr, u16 val)\r\n{\r\nu8 rb;\r\nu8 instr;\r\nint i;\r\ninstr = (u8) (addr | 0x40);\r\ninitio_se2_instr(base, instr);\r\nfor (i = 15; i >= 0; i--) {\r\nif (val & 0x8000)\r\noutb(SE2CS | SE2DO, base + TUL_NVRAM);\r\nelse\r\noutb(SE2CS, base + TUL_NVRAM);\r\nudelay(30);\r\noutb(SE2CS | SE2CLK, base + TUL_NVRAM);\r\nudelay(30);\r\nval <<= 1;\r\n}\r\noutb(SE2CS, base + TUL_NVRAM);\r\nudelay(30);\r\noutb(0, base + TUL_NVRAM);\r\nudelay(30);\r\noutb(SE2CS, base + TUL_NVRAM);\r\nudelay(30);\r\nfor (;;) {\r\noutb(SE2CS | SE2CLK, base + TUL_NVRAM);\r\nudelay(30);\r\noutb(SE2CS, base + TUL_NVRAM);\r\nudelay(30);\r\nif ((rb = inb(base + TUL_NVRAM)) & SE2DI)\r\nbreak;\r\n}\r\noutb(0, base + TUL_NVRAM);\r\n}\r\nstatic int initio_se2_rd_all(unsigned long base)\r\n{\r\nint i;\r\nu16 chksum = 0;\r\nu16 *np;\r\ni91unvramp = &i91unvram;\r\nnp = (u16 *) i91unvramp;\r\nfor (i = 0; i < 32; i++)\r\n*np++ = initio_se2_rd(base, i);\r\nif (i91unvramp->NVM_Signature != INI_SIGNATURE)\r\nreturn -1;\r\nnp = (u16 *) i91unvramp;\r\nfor (i = 0; i < 31; i++)\r\nchksum += *np++;\r\nif (i91unvramp->NVM_CheckSum != chksum)\r\nreturn -1;\r\nreturn 1;\r\n}\r\nstatic void initio_se2_update_all(unsigned long base)\r\n{\r\nint i;\r\nu16 chksum = 0;\r\nu16 *np, *np1;\r\ni91unvramp = &i91unvram;\r\nnp = (u16 *) i91udftNvRam;\r\nfor (i = 0; i < 31; i++)\r\nchksum += *np++;\r\n*np = chksum;\r\ninitio_se2_ew_en(base);\r\nnp = (u16 *) i91udftNvRam;\r\nnp1 = (u16 *) i91unvramp;\r\nfor (i = 0; i < 32; i++, np++, np1++) {\r\nif (*np != *np1)\r\ninitio_se2_wr(base, i, *np);\r\n}\r\ninitio_se2_ew_ds(base);\r\n}\r\nstatic void initio_read_eeprom(unsigned long base)\r\n{\r\nu8 gctrl;\r\ni91unvramp = &i91unvram;\r\ngctrl = inb(base + TUL_GCTRL);\r\noutb(gctrl | TUL_GCTRL_EEPROM_BIT, base + TUL_GCTRL);\r\nif (initio_se2_rd_all(base) != 1) {\r\ninitio_se2_update_all(base);\r\ninitio_se2_rd_all(base);\r\n}\r\ngctrl = inb(base + TUL_GCTRL);\r\noutb(gctrl & ~TUL_GCTRL_EEPROM_BIT, base + TUL_GCTRL);\r\n}\r\nstatic void initio_stop_bm(struct initio_host * host)\r\n{\r\nif (inb(host->addr + TUL_XStatus) & XPEND) {\r\noutb(TAX_X_ABT | TAX_X_CLR_FIFO, host->addr + TUL_XCmd);\r\nwhile ((inb(host->addr + TUL_Int) & XABT) == 0)\r\ncpu_relax();\r\n}\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\n}\r\nstatic int initio_reset_scsi(struct initio_host * host, int seconds)\r\n{\r\noutb(TSC_RST_BUS, host->addr + TUL_SCtrl0);\r\nwhile (!((host->jsint = inb(host->addr + TUL_SInt)) & TSS_SCSIRST_INT))\r\ncpu_relax();\r\noutb(0, host->addr + TUL_SSignal);\r\ninitio_do_pause(seconds * HZ);\r\ninb(host->addr + TUL_SInt);\r\nreturn SCSI_RESET_SUCCESS;\r\n}\r\nstatic void initio_init(struct initio_host * host, u8 *bios_addr)\r\n{\r\nint i;\r\nu8 *flags;\r\nu8 *heads;\r\ninitio_read_eeprom(host->addr);\r\nif (i91unvramp->NVM_SCSIInfo[0].NVM_NumOfTarg == 8)\r\nhost->max_tar = 8;\r\nelse\r\nhost->max_tar = 16;\r\nhost->config = i91unvramp->NVM_SCSIInfo[0].NVM_ChConfig1;\r\nhost->scsi_id = i91unvramp->NVM_SCSIInfo[0].NVM_ChSCSIID;\r\nhost->idmask = ~(1 << host->scsi_id);\r\n#ifdef CHK_PARITY\r\noutb(inb(host->addr + TUL_PCMD) | 0x40, host->addr + TUL_PCMD);\r\n#endif\r\noutb(0x1F, host->addr + TUL_Mask);\r\ninitio_stop_bm(host);\r\noutb(TSC_RST_CHIP, host->addr + TUL_SCtrl0);\r\noutb(host->scsi_id << 4, host->addr + TUL_SScsiId);\r\nif (host->config & HCC_EN_PAR)\r\nhost->sconf1 = (TSC_INITDEFAULT | TSC_EN_SCSI_PAR);\r\nelse\r\nhost->sconf1 = (TSC_INITDEFAULT);\r\noutb(host->sconf1, host->addr + TUL_SConfig);\r\noutb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);\r\noutb(0, host->addr + TUL_SPeriod);\r\noutb(153, host->addr + TUL_STimeOut);\r\noutb((host->config & (HCC_ACT_TERM1 | HCC_ACT_TERM2)),\r\nhost->addr + TUL_XCtrl);\r\noutb(((host->config & HCC_AUTO_TERM) >> 4) |\r\n(inb(host->addr + TUL_GCTRL1) & 0xFE),\r\nhost->addr + TUL_GCTRL1);\r\nfor (i = 0,\r\nflags = & (i91unvramp->NVM_SCSIInfo[0].NVM_Targ0Config),\r\nheads = bios_addr + 0x180;\r\ni < host->max_tar;\r\ni++, flags++) {\r\nhost->targets[i].flags = *flags & ~(TCF_SYNC_DONE | TCF_WDTR_DONE);\r\nif (host->targets[i].flags & TCF_EN_255)\r\nhost->targets[i].drv_flags = TCF_DRV_255_63;\r\nelse\r\nhost->targets[i].drv_flags = 0;\r\nhost->targets[i].js_period = 0;\r\nhost->targets[i].sconfig0 = host->sconf1;\r\nhost->targets[i].heads = *heads++;\r\nif (host->targets[i].heads == 255)\r\nhost->targets[i].drv_flags = TCF_DRV_255_63;\r\nelse\r\nhost->targets[i].drv_flags = 0;\r\nhost->targets[i].sectors = *heads++;\r\nhost->targets[i].flags &= ~TCF_BUSY;\r\nhost->act_tags[i] = 0;\r\nhost->max_tags[i] = 0xFF;\r\n}\r\nprintk("i91u: PCI Base=0x%04X, IRQ=%d, BIOS=0x%04X0, SCSI ID=%d\n",\r\nhost->addr, host->pci_dev->irq,\r\nhost->bios_addr, host->scsi_id);\r\nif (host->config & HCC_SCSI_RESET) {\r\nprintk(KERN_INFO "i91u: Reset SCSI Bus ... \n");\r\ninitio_reset_scsi(host, 10);\r\n}\r\noutb(0x17, host->addr + TUL_SCFG1);\r\noutb(0xE9, host->addr + TUL_SIntEnable);\r\n}\r\nstatic struct scsi_ctrl_blk *initio_alloc_scb(struct initio_host *host)\r\n{\r\nstruct scsi_ctrl_blk *scb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->avail_lock, flags);\r\nif ((scb = host->first_avail) != NULL) {\r\n#if DEBUG_QUEUE\r\nprintk("find scb at %p\n", scb);\r\n#endif\r\nif ((host->first_avail = scb->next) == NULL)\r\nhost->last_avail = NULL;\r\nscb->next = NULL;\r\nscb->status = SCB_RENT;\r\n}\r\nspin_unlock_irqrestore(&host->avail_lock, flags);\r\nreturn scb;\r\n}\r\nstatic void initio_release_scb(struct initio_host * host, struct scsi_ctrl_blk * cmnd)\r\n{\r\nunsigned long flags;\r\n#if DEBUG_QUEUE\r\nprintk("Release SCB %p; ", cmnd);\r\n#endif\r\nspin_lock_irqsave(&(host->avail_lock), flags);\r\ncmnd->srb = NULL;\r\ncmnd->status = 0;\r\ncmnd->next = NULL;\r\nif (host->last_avail != NULL) {\r\nhost->last_avail->next = cmnd;\r\nhost->last_avail = cmnd;\r\n} else {\r\nhost->first_avail = cmnd;\r\nhost->last_avail = cmnd;\r\n}\r\nspin_unlock_irqrestore(&(host->avail_lock), flags);\r\n}\r\nstatic void initio_append_pend_scb(struct initio_host * host, struct scsi_ctrl_blk * scbp)\r\n{\r\n#if DEBUG_QUEUE\r\nprintk("Append pend SCB %p; ", scbp);\r\n#endif\r\nscbp->status = SCB_PEND;\r\nscbp->next = NULL;\r\nif (host->last_pending != NULL) {\r\nhost->last_pending->next = scbp;\r\nhost->last_pending = scbp;\r\n} else {\r\nhost->first_pending = scbp;\r\nhost->last_pending = scbp;\r\n}\r\n}\r\nstatic void initio_push_pend_scb(struct initio_host * host, struct scsi_ctrl_blk * scbp)\r\n{\r\n#if DEBUG_QUEUE\r\nprintk("Push pend SCB %p; ", scbp);\r\n#endif\r\nscbp->status = SCB_PEND;\r\nif ((scbp->next = host->first_pending) != NULL) {\r\nhost->first_pending = scbp;\r\n} else {\r\nhost->first_pending = scbp;\r\nhost->last_pending = scbp;\r\n}\r\n}\r\nstatic struct scsi_ctrl_blk *initio_find_first_pend_scb(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *first;\r\nfirst = host->first_pending;\r\nwhile (first != NULL) {\r\nif (first->opcode != ExecSCSI)\r\nreturn first;\r\nif (first->tagmsg == 0) {\r\nif ((host->act_tags[first->target] == 0) &&\r\n!(host->targets[first->target].flags & TCF_BUSY))\r\nreturn first;\r\n} else {\r\nif ((host->act_tags[first->target] >=\r\nhost->max_tags[first->target]) |\r\n(host->targets[first->target].flags & TCF_BUSY)) {\r\nfirst = first->next;\r\ncontinue;\r\n}\r\nreturn first;\r\n}\r\nfirst = first->next;\r\n}\r\nreturn first;\r\n}\r\nstatic void initio_unlink_pend_scb(struct initio_host * host, struct scsi_ctrl_blk * scb)\r\n{\r\nstruct scsi_ctrl_blk *tmp, *prev;\r\n#if DEBUG_QUEUE\r\nprintk("unlink pend SCB %p; ", scb);\r\n#endif\r\nprev = tmp = host->first_pending;\r\nwhile (tmp != NULL) {\r\nif (scb == tmp) {\r\nif (tmp == host->first_pending) {\r\nif ((host->first_pending = tmp->next) == NULL)\r\nhost->last_pending = NULL;\r\n} else {\r\nprev->next = tmp->next;\r\nif (tmp == host->last_pending)\r\nhost->last_pending = prev;\r\n}\r\ntmp->next = NULL;\r\nbreak;\r\n}\r\nprev = tmp;\r\ntmp = tmp->next;\r\n}\r\n}\r\nstatic void initio_append_busy_scb(struct initio_host * host, struct scsi_ctrl_blk * scbp)\r\n{\r\n#if DEBUG_QUEUE\r\nprintk("append busy SCB %p; ", scbp);\r\n#endif\r\nif (scbp->tagmsg)\r\nhost->act_tags[scbp->target]++;\r\nelse\r\nhost->targets[scbp->target].flags |= TCF_BUSY;\r\nscbp->status = SCB_BUSY;\r\nscbp->next = NULL;\r\nif (host->last_busy != NULL) {\r\nhost->last_busy->next = scbp;\r\nhost->last_busy = scbp;\r\n} else {\r\nhost->first_busy = scbp;\r\nhost->last_busy = scbp;\r\n}\r\n}\r\nstatic struct scsi_ctrl_blk *initio_pop_busy_scb(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *tmp;\r\nif ((tmp = host->first_busy) != NULL) {\r\nif ((host->first_busy = tmp->next) == NULL)\r\nhost->last_busy = NULL;\r\ntmp->next = NULL;\r\nif (tmp->tagmsg)\r\nhost->act_tags[tmp->target]--;\r\nelse\r\nhost->targets[tmp->target].flags &= ~TCF_BUSY;\r\n}\r\n#if DEBUG_QUEUE\r\nprintk("Pop busy SCB %p; ", tmp);\r\n#endif\r\nreturn tmp;\r\n}\r\nstatic void initio_unlink_busy_scb(struct initio_host * host, struct scsi_ctrl_blk * scb)\r\n{\r\nstruct scsi_ctrl_blk *tmp, *prev;\r\n#if DEBUG_QUEUE\r\nprintk("unlink busy SCB %p; ", scb);\r\n#endif\r\nprev = tmp = host->first_busy;\r\nwhile (tmp != NULL) {\r\nif (scb == tmp) {\r\nif (tmp == host->first_busy) {\r\nif ((host->first_busy = tmp->next) == NULL)\r\nhost->last_busy = NULL;\r\n} else {\r\nprev->next = tmp->next;\r\nif (tmp == host->last_busy)\r\nhost->last_busy = prev;\r\n}\r\ntmp->next = NULL;\r\nif (tmp->tagmsg)\r\nhost->act_tags[tmp->target]--;\r\nelse\r\nhost->targets[tmp->target].flags &= ~TCF_BUSY;\r\nbreak;\r\n}\r\nprev = tmp;\r\ntmp = tmp->next;\r\n}\r\nreturn;\r\n}\r\nstruct scsi_ctrl_blk *initio_find_busy_scb(struct initio_host * host, u16 tarlun)\r\n{\r\nstruct scsi_ctrl_blk *tmp, *prev;\r\nu16 scbp_tarlun;\r\nprev = tmp = host->first_busy;\r\nwhile (tmp != NULL) {\r\nscbp_tarlun = (tmp->lun << 8) | (tmp->target);\r\nif (scbp_tarlun == tarlun) {\r\nbreak;\r\n}\r\nprev = tmp;\r\ntmp = tmp->next;\r\n}\r\n#if DEBUG_QUEUE\r\nprintk("find busy SCB %p; ", tmp);\r\n#endif\r\nreturn tmp;\r\n}\r\nstatic void initio_append_done_scb(struct initio_host * host, struct scsi_ctrl_blk * scbp)\r\n{\r\n#if DEBUG_QUEUE\r\nprintk("append done SCB %p; ", scbp);\r\n#endif\r\nscbp->status = SCB_DONE;\r\nscbp->next = NULL;\r\nif (host->last_done != NULL) {\r\nhost->last_done->next = scbp;\r\nhost->last_done = scbp;\r\n} else {\r\nhost->first_done = scbp;\r\nhost->last_done = scbp;\r\n}\r\n}\r\nstruct scsi_ctrl_blk *initio_find_done_scb(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *tmp;\r\nif ((tmp = host->first_done) != NULL) {\r\nif ((host->first_done = tmp->next) == NULL)\r\nhost->last_done = NULL;\r\ntmp->next = NULL;\r\n}\r\n#if DEBUG_QUEUE\r\nprintk("find done SCB %p; ",tmp);\r\n#endif\r\nreturn tmp;\r\n}\r\nstatic int initio_abort_srb(struct initio_host * host, struct scsi_cmnd *srbp)\r\n{\r\nunsigned long flags;\r\nstruct scsi_ctrl_blk *tmp, *prev;\r\nspin_lock_irqsave(&host->semaph_lock, flags);\r\nif ((host->semaph == 0) && (host->active == NULL)) {\r\noutb(0x1F, host->addr + TUL_Mask);\r\nspin_unlock_irqrestore(&host->semaph_lock, flags);\r\ntulip_main(host);\r\nspin_lock_irqsave(&host->semaph_lock, flags);\r\nhost->semaph = 1;\r\noutb(0x0F, host->addr + TUL_Mask);\r\nspin_unlock_irqrestore(&host->semaph_lock, flags);\r\nreturn SCSI_ABORT_SNOOZE;\r\n}\r\nprev = tmp = host->first_pending;\r\nwhile (tmp != NULL) {\r\nif (tmp->srb == srbp) {\r\nif (tmp == host->active) {\r\nspin_unlock_irqrestore(&host->semaph_lock, flags);\r\nreturn SCSI_ABORT_BUSY;\r\n} else if (tmp == host->first_pending) {\r\nif ((host->first_pending = tmp->next) == NULL)\r\nhost->last_pending = NULL;\r\n} else {\r\nprev->next = tmp->next;\r\nif (tmp == host->last_pending)\r\nhost->last_pending = prev;\r\n}\r\ntmp->hastat = HOST_ABORTED;\r\ntmp->flags |= SCF_DONE;\r\nif (tmp->flags & SCF_POST)\r\n(*tmp->post) ((u8 *) host, (u8 *) tmp);\r\nspin_unlock_irqrestore(&host->semaph_lock, flags);\r\nreturn SCSI_ABORT_SUCCESS;\r\n}\r\nprev = tmp;\r\ntmp = tmp->next;\r\n}\r\nprev = tmp = host->first_busy;\r\nwhile (tmp != NULL) {\r\nif (tmp->srb == srbp) {\r\nif (tmp == host->active) {\r\nspin_unlock_irqrestore(&host->semaph_lock, flags);\r\nreturn SCSI_ABORT_BUSY;\r\n} else if (tmp->tagmsg == 0) {\r\nspin_unlock_irqrestore(&host->semaph_lock, flags);\r\nreturn SCSI_ABORT_BUSY;\r\n} else {\r\nhost->act_tags[tmp->target]--;\r\nif (tmp == host->first_busy) {\r\nif ((host->first_busy = tmp->next) == NULL)\r\nhost->last_busy = NULL;\r\n} else {\r\nprev->next = tmp->next;\r\nif (tmp == host->last_busy)\r\nhost->last_busy = prev;\r\n}\r\ntmp->next = NULL;\r\ntmp->hastat = HOST_ABORTED;\r\ntmp->flags |= SCF_DONE;\r\nif (tmp->flags & SCF_POST)\r\n(*tmp->post) ((u8 *) host, (u8 *) tmp);\r\nspin_unlock_irqrestore(&host->semaph_lock, flags);\r\nreturn SCSI_ABORT_SUCCESS;\r\n}\r\n}\r\nprev = tmp;\r\ntmp = tmp->next;\r\n}\r\nspin_unlock_irqrestore(&host->semaph_lock, flags);\r\nreturn SCSI_ABORT_NOT_RUNNING;\r\n}\r\nstatic int initio_bad_seq(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb;\r\nprintk("initio_bad_seg c=%d\n", host->index);\r\nif ((scb = host->active) != NULL) {\r\ninitio_unlink_busy_scb(host, scb);\r\nscb->hastat = HOST_BAD_PHAS;\r\nscb->tastat = 0;\r\ninitio_append_done_scb(host, scb);\r\n}\r\ninitio_stop_bm(host);\r\ninitio_reset_scsi(host, 8);\r\nreturn initio_post_scsi_rst(host);\r\n}\r\nstatic void initio_exec_scb(struct initio_host * host, struct scsi_ctrl_blk * scb)\r\n{\r\nunsigned long flags;\r\nscb->mode = 0;\r\nscb->sgidx = 0;\r\nscb->sgmax = scb->sglen;\r\nspin_lock_irqsave(&host->semaph_lock, flags);\r\ninitio_append_pend_scb(host, scb);\r\nif (host->semaph == 1) {\r\noutb(0x1F, host->addr + TUL_Mask);\r\nhost->semaph = 0;\r\nspin_unlock_irqrestore(&host->semaph_lock, flags);\r\ntulip_main(host);\r\nspin_lock_irqsave(&host->semaph_lock, flags);\r\nhost->semaph = 1;\r\noutb(0x0F, host->addr + TUL_Mask);\r\n}\r\nspin_unlock_irqrestore(&host->semaph_lock, flags);\r\nreturn;\r\n}\r\nstatic int initio_isr(struct initio_host * host)\r\n{\r\nif (inb(host->addr + TUL_Int) & TSS_INT_PENDING) {\r\nif (host->semaph == 1) {\r\noutb(0x1F, host->addr + TUL_Mask);\r\nhost->semaph = 0;\r\ntulip_main(host);\r\nhost->semaph = 1;\r\noutb(0x0F, host->addr + TUL_Mask);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tulip_main(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb;\r\nfor (;;) {\r\ntulip_scsi(host);\r\nwhile ((scb = initio_find_done_scb(host)) != NULL) {\r\nif (scb->tastat == INI_QUEUE_FULL) {\r\nhost->max_tags[scb->target] =\r\nhost->act_tags[scb->target] - 1;\r\nscb->tastat = 0;\r\ninitio_append_pend_scb(host, scb);\r\ncontinue;\r\n}\r\nif (!(scb->mode & SCM_RSENS)) {\r\nif (scb->tastat == 2) {\r\nif (scb->flags & SCF_SENSE) {\r\nu8 len;\r\nlen = scb->senselen;\r\nif (len == 0)\r\nlen = 1;\r\nscb->buflen = scb->senselen;\r\nscb->bufptr = scb->senseptr;\r\nscb->flags &= ~(SCF_SG | SCF_DIR);\r\nscb->mode = SCM_RSENS;\r\nscb->ident &= 0xBF;\r\nscb->tagmsg = 0;\r\nscb->tastat = 0;\r\nscb->cdblen = 6;\r\nscb->cdb[0] = SCSICMD_RequestSense;\r\nscb->cdb[1] = 0;\r\nscb->cdb[2] = 0;\r\nscb->cdb[3] = 0;\r\nscb->cdb[4] = len;\r\nscb->cdb[5] = 0;\r\ninitio_push_pend_scb(host, scb);\r\nbreak;\r\n}\r\n}\r\n} else {\r\nif (scb->tastat == 2) {\r\nscb->hastat = HOST_BAD_PHAS;\r\n}\r\nscb->tastat = 2;\r\n}\r\nscb->flags |= SCF_DONE;\r\nif (scb->flags & SCF_POST) {\r\n(*scb->post) ((u8 *) host, (u8 *) scb);\r\n}\r\n}\r\nif (inb(host->addr + TUL_SStatus0) & TSS_INT_PENDING)\r\ncontinue;\r\nif (host->active)\r\nreturn 1;\r\nif (initio_find_first_pend_scb(host) == NULL)\r\nreturn 1;\r\n}\r\n}\r\nstatic void tulip_scsi(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb;\r\nstruct target_control *active_tc;\r\nif ((host->jsstatus0 = inb(host->addr + TUL_SStatus0)) & TSS_INT_PENDING) {\r\nhost->phase = host->jsstatus0 & TSS_PH_MASK;\r\nhost->jsstatus1 = inb(host->addr + TUL_SStatus1);\r\nhost->jsint = inb(host->addr + TUL_SInt);\r\nif (host->jsint & TSS_SCSIRST_INT) {\r\nint_initio_scsi_rst(host);\r\nreturn;\r\n}\r\nif (host->jsint & TSS_RESEL_INT) {\r\nif (int_initio_resel(host) == 0)\r\ninitio_next_state(host);\r\nreturn;\r\n}\r\nif (host->jsint & TSS_SEL_TIMEOUT) {\r\nint_initio_busfree(host);\r\nreturn;\r\n}\r\nif (host->jsint & TSS_DISC_INT) {\r\nint_initio_busfree(host);\r\nreturn;\r\n}\r\nif (host->jsint & (TSS_FUNC_COMP | TSS_BUS_SERV)) {\r\nif ((scb = host->active) != NULL)\r\ninitio_next_state(host);\r\nreturn;\r\n}\r\n}\r\nif (host->active != NULL)\r\nreturn;\r\nif ((scb = initio_find_first_pend_scb(host)) == NULL)\r\nreturn;\r\noutb((host->scsi_id << 4) | (scb->target & 0x0F),\r\nhost->addr + TUL_SScsiId);\r\nif (scb->opcode == ExecSCSI) {\r\nactive_tc = &host->targets[scb->target];\r\nif (scb->tagmsg)\r\nactive_tc->drv_flags |= TCF_DRV_EN_TAG;\r\nelse\r\nactive_tc->drv_flags &= ~TCF_DRV_EN_TAG;\r\noutb(active_tc->js_period, host->addr + TUL_SPeriod);\r\nif ((active_tc->flags & (TCF_WDTR_DONE | TCF_NO_WDTR)) == 0) {\r\ninitio_select_atn_stop(host, scb);\r\n} else {\r\nif ((active_tc->flags & (TCF_SYNC_DONE | TCF_NO_SYNC_NEGO)) == 0) {\r\ninitio_select_atn_stop(host, scb);\r\n} else {\r\nif (scb->tagmsg)\r\ninitio_select_atn3(host, scb);\r\nelse\r\ninitio_select_atn(host, scb);\r\n}\r\n}\r\nif (scb->flags & SCF_POLL) {\r\nwhile (wait_tulip(host) != -1) {\r\nif (initio_next_state(host) == -1)\r\nbreak;\r\n}\r\n}\r\n} else if (scb->opcode == BusDevRst) {\r\ninitio_select_atn_stop(host, scb);\r\nscb->next_state = 8;\r\nif (scb->flags & SCF_POLL) {\r\nwhile (wait_tulip(host) != -1) {\r\nif (initio_next_state(host) == -1)\r\nbreak;\r\n}\r\n}\r\n} else if (scb->opcode == AbortCmd) {\r\nif (initio_abort_srb(host, scb->srb) != 0) {\r\ninitio_unlink_pend_scb(host, scb);\r\ninitio_release_scb(host, scb);\r\n} else {\r\nscb->opcode = BusDevRst;\r\ninitio_select_atn_stop(host, scb);\r\nscb->next_state = 8;\r\n}\r\n} else {\r\ninitio_unlink_pend_scb(host, scb);\r\nscb->hastat = 0x16;\r\ninitio_append_done_scb(host, scb);\r\n}\r\nreturn;\r\n}\r\nstatic int initio_next_state(struct initio_host * host)\r\n{\r\nint next;\r\nnext = host->active->next_state;\r\nfor (;;) {\r\nswitch (next) {\r\ncase 1:\r\nnext = initio_state_1(host);\r\nbreak;\r\ncase 2:\r\nnext = initio_state_2(host);\r\nbreak;\r\ncase 3:\r\nnext = initio_state_3(host);\r\nbreak;\r\ncase 4:\r\nnext = initio_state_4(host);\r\nbreak;\r\ncase 5:\r\nnext = initio_state_5(host);\r\nbreak;\r\ncase 6:\r\nnext = initio_state_6(host);\r\nbreak;\r\ncase 7:\r\nnext = initio_state_7(host);\r\nbreak;\r\ncase 8:\r\nreturn initio_bus_device_reset(host);\r\ndefault:\r\nreturn initio_bad_seq(host);\r\n}\r\nif (next <= 0)\r\nreturn next;\r\n}\r\n}\r\nstatic int initio_state_1(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb = host->active;\r\nstruct target_control *active_tc = host->active_tc;\r\n#if DEBUG_STATE\r\nprintk("-s1-");\r\n#endif\r\ninitio_unlink_pend_scb(host, scb);\r\ninitio_append_busy_scb(host, scb);\r\noutb(active_tc->sconfig0, host->addr + TUL_SConfig );\r\nif (host->phase == MSG_OUT) {\r\noutb(TSC_EN_BUS_IN | TSC_HW_RESELECT, host->addr + TUL_SCtrl1);\r\noutb(scb->ident, host->addr + TUL_SFifo);\r\nif (scb->tagmsg) {\r\noutb(scb->tagmsg, host->addr + TUL_SFifo);\r\noutb(scb->tagid, host->addr + TUL_SFifo);\r\n}\r\nif ((active_tc->flags & (TCF_WDTR_DONE | TCF_NO_WDTR)) == 0) {\r\nactive_tc->flags |= TCF_WDTR_DONE;\r\noutb(MSG_EXTEND, host->addr + TUL_SFifo);\r\noutb(2, host->addr + TUL_SFifo);\r\noutb(3, host->addr + TUL_SFifo);\r\noutb(1, host->addr + TUL_SFifo);\r\n} else if ((active_tc->flags & (TCF_SYNC_DONE | TCF_NO_SYNC_NEGO)) == 0) {\r\nactive_tc->flags |= TCF_SYNC_DONE;\r\noutb(MSG_EXTEND, host->addr + TUL_SFifo);\r\noutb(3, host->addr + TUL_SFifo);\r\noutb(1, host->addr + TUL_SFifo);\r\noutb(initio_rate_tbl[active_tc->flags & TCF_SCSI_RATE], host->addr + TUL_SFifo);\r\noutb(MAX_OFFSET, host->addr + TUL_SFifo);\r\n}\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nif (wait_tulip(host) == -1)\r\nreturn -1;\r\n}\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\noutb((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)), host->addr + TUL_SSignal);\r\nreturn 3;\r\n}\r\nstatic int initio_state_2(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb = host->active;\r\nstruct target_control *active_tc = host->active_tc;\r\n#if DEBUG_STATE\r\nprintk("-s2-");\r\n#endif\r\ninitio_unlink_pend_scb(host, scb);\r\ninitio_append_busy_scb(host, scb);\r\noutb(active_tc->sconfig0, host->addr + TUL_SConfig);\r\nif (host->jsstatus1 & TSS_CMD_PH_CMP)\r\nreturn 4;\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\noutb((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)), host->addr + TUL_SSignal);\r\nreturn 3;\r\n}\r\nstatic int initio_state_3(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb = host->active;\r\nstruct target_control *active_tc = host->active_tc;\r\nint i;\r\n#if DEBUG_STATE\r\nprintk("-s3-");\r\n#endif\r\nfor (;;) {\r\nswitch (host->phase) {\r\ncase CMD_OUT:\r\nfor (i = 0; i < (int) scb->cdblen; i++)\r\noutb(scb->cdb[i], host->addr + TUL_SFifo);\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nif (wait_tulip(host) == -1)\r\nreturn -1;\r\nif (host->phase == CMD_OUT)\r\nreturn initio_bad_seq(host);\r\nreturn 4;\r\ncase MSG_IN:\r\nscb->next_state = 3;\r\nif (initio_msgin(host) == -1)\r\nreturn -1;\r\nbreak;\r\ncase STATUS_IN:\r\nif (initio_status_msg(host) == -1)\r\nreturn -1;\r\nbreak;\r\ncase MSG_OUT:\r\nif (active_tc->flags & (TCF_SYNC_DONE | TCF_NO_SYNC_NEGO)) {\r\noutb(MSG_NOP, host->addr + TUL_SFifo);\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nif (wait_tulip(host) == -1)\r\nreturn -1;\r\n} else {\r\nactive_tc->flags |= TCF_SYNC_DONE;\r\noutb(MSG_EXTEND, host->addr + TUL_SFifo);\r\noutb(3, host->addr + TUL_SFifo);\r\noutb(1, host->addr + TUL_SFifo);\r\noutb(initio_rate_tbl[active_tc->flags & TCF_SCSI_RATE], host->addr + TUL_SFifo);\r\noutb(MAX_OFFSET, host->addr + TUL_SFifo);\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nif (wait_tulip(host) == -1)\r\nreturn -1;\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\noutb(inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7), host->addr + TUL_SSignal);\r\n}\r\nbreak;\r\ndefault:\r\nreturn initio_bad_seq(host);\r\n}\r\n}\r\n}\r\nstatic int initio_state_4(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb = host->active;\r\n#if DEBUG_STATE\r\nprintk("-s4-");\r\n#endif\r\nif ((scb->flags & SCF_DIR) == SCF_NO_XF) {\r\nreturn 6;\r\n}\r\nfor (;;) {\r\nif (scb->buflen == 0)\r\nreturn 6;\r\nswitch (host->phase) {\r\ncase STATUS_IN:\r\nif ((scb->flags & SCF_DIR) != 0)\r\nscb->hastat = HOST_DO_DU;\r\nif ((initio_status_msg(host)) == -1)\r\nreturn -1;\r\nbreak;\r\ncase MSG_IN:\r\nscb->next_state = 0x4;\r\nif (initio_msgin(host) == -1)\r\nreturn -1;\r\nbreak;\r\ncase MSG_OUT:\r\nif (host->jsstatus0 & TSS_PAR_ERROR) {\r\nscb->buflen = 0;\r\nscb->hastat = HOST_DO_DU;\r\nif (initio_msgout_ide(host) == -1)\r\nreturn -1;\r\nreturn 6;\r\n} else {\r\noutb(MSG_NOP, host->addr + TUL_SFifo);\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nif (wait_tulip(host) == -1)\r\nreturn -1;\r\n}\r\nbreak;\r\ncase DATA_IN:\r\nreturn initio_xfer_data_in(host);\r\ncase DATA_OUT:\r\nreturn initio_xfer_data_out(host);\r\ndefault:\r\nreturn initio_bad_seq(host);\r\n}\r\n}\r\n}\r\nstatic int initio_state_5(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb = host->active;\r\nlong cnt, xcnt;\r\n#if DEBUG_STATE\r\nprintk("-s5-");\r\n#endif\r\ncnt = inl(host->addr + TUL_SCnt0) & 0x0FFFFFF;\r\nif (inb(host->addr + TUL_XCmd) & 0x20) {\r\nif (host->jsstatus0 & TSS_PAR_ERROR)\r\nscb->hastat = HOST_DO_DU;\r\nif (inb(host->addr + TUL_XStatus) & XPEND) {\r\noutb(inb(host->addr + TUL_XCtrl) | 0x80, host->addr + TUL_XCtrl);\r\nwhile (inb(host->addr + TUL_XStatus) & XPEND)\r\ncpu_relax();\r\n}\r\n} else {\r\nif ((inb(host->addr + TUL_SStatus1) & TSS_XFER_CMP) == 0) {\r\nif (host->active_tc->js_period & TSC_WIDE_SCSI)\r\ncnt += (inb(host->addr + TUL_SFifoCnt) & 0x1F) << 1;\r\nelse\r\ncnt += (inb(host->addr + TUL_SFifoCnt) & 0x1F);\r\n}\r\nif (inb(host->addr + TUL_XStatus) & XPEND) {\r\noutb(TAX_X_ABT, host->addr + TUL_XCmd);\r\nwhile ((inb(host->addr + TUL_Int) & XABT) == 0)\r\ncpu_relax();\r\n}\r\nif ((cnt == 1) && (host->phase == DATA_OUT)) {\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nif (wait_tulip(host) == -1)\r\nreturn -1;\r\ncnt = 0;\r\n} else {\r\nif ((inb(host->addr + TUL_SStatus1) & TSS_XFER_CMP) == 0)\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\n}\r\n}\r\nif (cnt == 0) {\r\nscb->buflen = 0;\r\nreturn 6;\r\n}\r\nxcnt = (long) scb->buflen - cnt;\r\nscb->buflen = (u32) cnt;\r\nif (scb->flags & SCF_SG) {\r\nstruct sg_entry *sgp;\r\nunsigned long i;\r\nsgp = &scb->sglist[scb->sgidx];\r\nfor (i = scb->sgidx; i < scb->sgmax; sgp++, i++) {\r\nxcnt -= (long) sgp->len;\r\nif (xcnt < 0) {\r\nxcnt += (long) sgp->len;\r\nsgp->data += (u32) xcnt;\r\nsgp->len -= (u32) xcnt;\r\nscb->bufptr += ((u32) (i - scb->sgidx) << 3);\r\nscb->sglen = (u8) (scb->sgmax - i);\r\nscb->sgidx = (u16) i;\r\nreturn 4;\r\n}\r\n}\r\nreturn 6;\r\n} else {\r\nscb->bufptr += (u32) xcnt;\r\n}\r\nreturn 4;\r\n}\r\nstatic int initio_state_6(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb = host->active;\r\n#if DEBUG_STATE\r\nprintk("-s6-");\r\n#endif\r\nfor (;;) {\r\nswitch (host->phase) {\r\ncase STATUS_IN:\r\nif ((initio_status_msg(host)) == -1)\r\nreturn -1;\r\nbreak;\r\ncase MSG_IN:\r\nscb->next_state = 6;\r\nif ((initio_msgin(host)) == -1)\r\nreturn -1;\r\nbreak;\r\ncase MSG_OUT:\r\noutb(MSG_NOP, host->addr + TUL_SFifo);\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nif (wait_tulip(host) == -1)\r\nreturn -1;\r\nbreak;\r\ncase DATA_IN:\r\nreturn initio_xpad_in(host);\r\ncase DATA_OUT:\r\nreturn initio_xpad_out(host);\r\ndefault:\r\nreturn initio_bad_seq(host);\r\n}\r\n}\r\n}\r\nint initio_state_7(struct initio_host * host)\r\n{\r\nint cnt, i;\r\n#if DEBUG_STATE\r\nprintk("-s7-");\r\n#endif\r\ncnt = inb(host->addr + TUL_SFifoCnt) & 0x1F;\r\nif (cnt) {\r\nfor (i = 0; i < cnt; i++)\r\ninb(host->addr + TUL_SFifo);\r\n}\r\nswitch (host->phase) {\r\ncase DATA_IN:\r\ncase DATA_OUT:\r\nreturn initio_bad_seq(host);\r\ndefault:\r\nreturn 6;\r\n}\r\n}\r\nstatic int initio_xfer_data_in(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb = host->active;\r\nif ((scb->flags & SCF_DIR) == SCF_DOUT)\r\nreturn 6;\r\noutl(scb->buflen, host->addr + TUL_SCnt0);\r\noutb(TSC_XF_DMA_IN, host->addr + TUL_SCmd);\r\nif (scb->flags & SCF_SG) {\r\noutl(((u32) scb->sglen) << 3, host->addr + TUL_XCntH);\r\noutl(scb->bufptr, host->addr + TUL_XAddH);\r\noutb(TAX_SG_IN, host->addr + TUL_XCmd);\r\n} else {\r\noutl(scb->buflen, host->addr + TUL_XCntH);\r\noutl(scb->bufptr, host->addr + TUL_XAddH);\r\noutb(TAX_X_IN, host->addr + TUL_XCmd);\r\n}\r\nscb->next_state = 0x5;\r\nreturn 0;\r\n}\r\nstatic int initio_xfer_data_out(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb = host->active;\r\nif ((scb->flags & SCF_DIR) == SCF_DIN)\r\nreturn 6;\r\noutl(scb->buflen, host->addr + TUL_SCnt0);\r\noutb(TSC_XF_DMA_OUT, host->addr + TUL_SCmd);\r\nif (scb->flags & SCF_SG) {\r\noutl(((u32) scb->sglen) << 3, host->addr + TUL_XCntH);\r\noutl(scb->bufptr, host->addr + TUL_XAddH);\r\noutb(TAX_SG_OUT, host->addr + TUL_XCmd);\r\n} else {\r\noutl(scb->buflen, host->addr + TUL_XCntH);\r\noutl(scb->bufptr, host->addr + TUL_XAddH);\r\noutb(TAX_X_OUT, host->addr + TUL_XCmd);\r\n}\r\nscb->next_state = 0x5;\r\nreturn 0;\r\n}\r\nint initio_xpad_in(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb = host->active;\r\nstruct target_control *active_tc = host->active_tc;\r\nif ((scb->flags & SCF_DIR) != SCF_NO_DCHK)\r\nscb->hastat = HOST_DO_DU;\r\nfor (;;) {\r\nif (active_tc->js_period & TSC_WIDE_SCSI)\r\noutl(2, host->addr + TUL_SCnt0);\r\nelse\r\noutl(1, host->addr + TUL_SCnt0);\r\noutb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);\r\nif (wait_tulip(host) == -1)\r\nreturn -1;\r\nif (host->phase != DATA_IN) {\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\nreturn 6;\r\n}\r\ninb(host->addr + TUL_SFifo);\r\n}\r\n}\r\nint initio_xpad_out(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb = host->active;\r\nstruct target_control *active_tc = host->active_tc;\r\nif ((scb->flags & SCF_DIR) != SCF_NO_DCHK)\r\nscb->hastat = HOST_DO_DU;\r\nfor (;;) {\r\nif (active_tc->js_period & TSC_WIDE_SCSI)\r\noutl(2, host->addr + TUL_SCnt0);\r\nelse\r\noutl(1, host->addr + TUL_SCnt0);\r\noutb(0, host->addr + TUL_SFifo);\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nif ((wait_tulip(host)) == -1)\r\nreturn -1;\r\nif (host->phase != DATA_OUT) {\r\noutb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\nreturn 6;\r\n}\r\n}\r\n}\r\nint initio_status_msg(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb = host->active;\r\nu8 msg;\r\noutb(TSC_CMD_COMP, host->addr + TUL_SCmd);\r\nif (wait_tulip(host) == -1)\r\nreturn -1;\r\nscb->tastat = inb(host->addr + TUL_SFifo);\r\nif (host->phase == MSG_OUT) {\r\nif (host->jsstatus0 & TSS_PAR_ERROR)\r\noutb(MSG_PARITY, host->addr + TUL_SFifo);\r\nelse\r\noutb(MSG_NOP, host->addr + TUL_SFifo);\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nreturn wait_tulip(host);\r\n}\r\nif (host->phase == MSG_IN) {\r\nmsg = inb(host->addr + TUL_SFifo);\r\nif (host->jsstatus0 & TSS_PAR_ERROR) {\r\nif ((initio_msgin_accept(host)) == -1)\r\nreturn -1;\r\nif (host->phase != MSG_OUT)\r\nreturn initio_bad_seq(host);\r\noutb(MSG_PARITY, host->addr + TUL_SFifo);\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nreturn wait_tulip(host);\r\n}\r\nif (msg == 0) {\r\nif ((scb->tastat & 0x18) == 0x10)\r\nreturn initio_bad_seq(host);\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\noutb(TSC_MSG_ACCEPT, host->addr + TUL_SCmd);\r\nreturn initio_wait_done_disc(host);\r\n}\r\nif (msg == MSG_LINK_COMP || msg == MSG_LINK_FLAG) {\r\nif ((scb->tastat & 0x18) == 0x10)\r\nreturn initio_msgin_accept(host);\r\n}\r\n}\r\nreturn initio_bad_seq(host);\r\n}\r\nint int_initio_busfree(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb = host->active;\r\nif (scb != NULL) {\r\nif (scb->status & SCB_SELECT) {\r\ninitio_unlink_pend_scb(host, scb);\r\nscb->hastat = HOST_SEL_TOUT;\r\ninitio_append_done_scb(host, scb);\r\n} else {\r\ninitio_unlink_busy_scb(host, scb);\r\nscb->hastat = HOST_BUS_FREE;\r\ninitio_append_done_scb(host, scb);\r\n}\r\nhost->active = NULL;\r\nhost->active_tc = NULL;\r\n}\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\noutb(TSC_INITDEFAULT, host->addr + TUL_SConfig);\r\noutb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);\r\nreturn -1;\r\n}\r\nstatic int int_initio_scsi_rst(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb;\r\nint i;\r\nif (inb(host->addr + TUL_XStatus) & 0x01) {\r\noutb(TAX_X_ABT | TAX_X_CLR_FIFO, host->addr + TUL_XCmd);\r\nwhile ((inb(host->addr + TUL_Int) & 0x04) == 0)\r\ncpu_relax();\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\n}\r\nwhile ((scb = initio_pop_busy_scb(host)) != NULL) {\r\nscb->hastat = HOST_BAD_PHAS;\r\ninitio_append_done_scb(host, scb);\r\n}\r\nhost->active = NULL;\r\nhost->active_tc = NULL;\r\nfor (i = 0; i < host->max_tar; i++)\r\nhost->targets[i].flags &= ~(TCF_SYNC_DONE | TCF_WDTR_DONE);\r\nreturn -1;\r\n}\r\nint int_initio_resel(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb;\r\nstruct target_control *active_tc;\r\nu8 tag, msg = 0;\r\nu8 tar, lun;\r\nif ((scb = host->active) != NULL) {\r\nif (scb->status & SCB_SELECT)\r\nscb->status &= ~SCB_SELECT;\r\nhost->active = NULL;\r\n}\r\ntar = inb(host->addr + TUL_SBusId);\r\nlun = inb(host->addr + TUL_SIdent) & 0x0F;\r\nactive_tc = &host->targets[tar];\r\nhost->active_tc = active_tc;\r\noutb(active_tc->sconfig0, host->addr + TUL_SConfig);\r\noutb(active_tc->js_period, host->addr + TUL_SPeriod);\r\nif (active_tc->drv_flags & TCF_DRV_EN_TAG) {\r\nif ((initio_msgin_accept(host)) == -1)\r\nreturn -1;\r\nif (host->phase != MSG_IN)\r\ngoto no_tag;\r\noutl(1, host->addr + TUL_SCnt0);\r\noutb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);\r\nif (wait_tulip(host) == -1)\r\nreturn -1;\r\nmsg = inb(host->addr + TUL_SFifo);\r\nif (msg < MSG_STAG || msg > MSG_OTAG)\r\ngoto no_tag;\r\nif (initio_msgin_accept(host) == -1)\r\nreturn -1;\r\nif (host->phase != MSG_IN)\r\ngoto no_tag;\r\noutl(1, host->addr + TUL_SCnt0);\r\noutb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);\r\nif (wait_tulip(host) == -1)\r\nreturn -1;\r\ntag = inb(host->addr + TUL_SFifo);\r\nscb = host->scb + tag;\r\nif (scb->target != tar || scb->lun != lun) {\r\nreturn initio_msgout_abort_tag(host);\r\n}\r\nif (scb->status != SCB_BUSY) {\r\nreturn initio_msgout_abort_tag(host);\r\n}\r\nhost->active = scb;\r\nif ((initio_msgin_accept(host)) == -1)\r\nreturn -1;\r\n} else {\r\nno_tag:\r\nif ((scb = initio_find_busy_scb(host, tar | (lun << 8))) == NULL) {\r\nreturn initio_msgout_abort_targ(host);\r\n}\r\nhost->active = scb;\r\nif (!(active_tc->drv_flags & TCF_DRV_EN_TAG)) {\r\nif ((initio_msgin_accept(host)) == -1)\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int int_initio_bad_seq(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb;\r\nint i;\r\ninitio_reset_scsi(host, 10);\r\nwhile ((scb = initio_pop_busy_scb(host)) != NULL) {\r\nscb->hastat = HOST_BAD_PHAS;\r\ninitio_append_done_scb(host, scb);\r\n}\r\nfor (i = 0; i < host->max_tar; i++)\r\nhost->targets[i].flags &= ~(TCF_SYNC_DONE | TCF_WDTR_DONE);\r\nreturn -1;\r\n}\r\nstatic int initio_msgout_abort_targ(struct initio_host * host)\r\n{\r\noutb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);\r\nif (initio_msgin_accept(host) == -1)\r\nreturn -1;\r\nif (host->phase != MSG_OUT)\r\nreturn initio_bad_seq(host);\r\noutb(MSG_ABORT, host->addr + TUL_SFifo);\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nreturn initio_wait_disc(host);\r\n}\r\nstatic int initio_msgout_abort_tag(struct initio_host * host)\r\n{\r\noutb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);\r\nif (initio_msgin_accept(host) == -1)\r\nreturn -1;\r\nif (host->phase != MSG_OUT)\r\nreturn initio_bad_seq(host);\r\noutb(MSG_ABORT_TAG, host->addr + TUL_SFifo);\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nreturn initio_wait_disc(host);\r\n}\r\nstatic int initio_msgin(struct initio_host * host)\r\n{\r\nstruct target_control *active_tc;\r\nfor (;;) {\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\noutl(1, host->addr + TUL_SCnt0);\r\noutb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);\r\nif (wait_tulip(host) == -1)\r\nreturn -1;\r\nswitch (inb(host->addr + TUL_SFifo)) {\r\ncase MSG_DISC:\r\noutb(TSC_MSG_ACCEPT, host->addr + TUL_SCmd);\r\nreturn initio_wait_disc(host);\r\ncase MSG_SDP:\r\ncase MSG_RESTORE:\r\ncase MSG_NOP:\r\ninitio_msgin_accept(host);\r\nbreak;\r\ncase MSG_REJ:\r\noutb((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)),\r\nhost->addr + TUL_SSignal);\r\nactive_tc = host->active_tc;\r\nif ((active_tc->flags & (TCF_SYNC_DONE | TCF_NO_SYNC_NEGO)) == 0)\r\noutb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN),\r\nhost->addr + TUL_SSignal);\r\ninitio_msgin_accept(host);\r\nbreak;\r\ncase MSG_EXTEND:\r\ninitio_msgin_extend(host);\r\nbreak;\r\ncase MSG_IGNOREWIDE:\r\ninitio_msgin_accept(host);\r\nbreak;\r\ncase MSG_COMP:\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\noutb(TSC_MSG_ACCEPT, host->addr + TUL_SCmd);\r\nreturn initio_wait_done_disc(host);\r\ndefault:\r\ninitio_msgout_reject(host);\r\nbreak;\r\n}\r\nif (host->phase != MSG_IN)\r\nreturn host->phase;\r\n}\r\n}\r\nstatic int initio_msgout_reject(struct initio_host * host)\r\n{\r\noutb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);\r\nif (initio_msgin_accept(host) == -1)\r\nreturn -1;\r\nif (host->phase == MSG_OUT) {\r\noutb(MSG_REJ, host->addr + TUL_SFifo);\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nreturn wait_tulip(host);\r\n}\r\nreturn host->phase;\r\n}\r\nstatic int initio_msgout_ide(struct initio_host * host)\r\n{\r\noutb(MSG_IDE, host->addr + TUL_SFifo);\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nreturn wait_tulip(host);\r\n}\r\nstatic int initio_msgin_extend(struct initio_host * host)\r\n{\r\nu8 len, idx;\r\nif (initio_msgin_accept(host) != MSG_IN)\r\nreturn host->phase;\r\noutl(1, host->addr + TUL_SCnt0);\r\noutb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);\r\nif (wait_tulip(host) == -1)\r\nreturn -1;\r\nlen = inb(host->addr + TUL_SFifo);\r\nhost->msg[0] = len;\r\nfor (idx = 1; len != 0; len--) {\r\nif ((initio_msgin_accept(host)) != MSG_IN)\r\nreturn host->phase;\r\noutl(1, host->addr + TUL_SCnt0);\r\noutb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);\r\nif (wait_tulip(host) == -1)\r\nreturn -1;\r\nhost->msg[idx++] = inb(host->addr + TUL_SFifo);\r\n}\r\nif (host->msg[1] == 1) {\r\nu8 r;\r\nif (host->msg[0] != 3)\r\nreturn initio_msgout_reject(host);\r\nif (host->active_tc->flags & TCF_NO_SYNC_NEGO) {\r\nhost->msg[3] = 0;\r\n} else {\r\nif (initio_msgin_sync(host) == 0 &&\r\n(host->active_tc->flags & TCF_SYNC_DONE)) {\r\ninitio_sync_done(host);\r\nreturn initio_msgin_accept(host);\r\n}\r\n}\r\nr = inb(host->addr + TUL_SSignal);\r\noutb((r & (TSC_SET_ACK | 7)) | TSC_SET_ATN,\r\nhost->addr + TUL_SSignal);\r\nif (initio_msgin_accept(host) != MSG_OUT)\r\nreturn host->phase;\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\ninitio_sync_done(host);\r\noutb(MSG_EXTEND, host->addr + TUL_SFifo);\r\noutb(3, host->addr + TUL_SFifo);\r\noutb(1, host->addr + TUL_SFifo);\r\noutb(host->msg[2], host->addr + TUL_SFifo);\r\noutb(host->msg[3], host->addr + TUL_SFifo);\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nreturn wait_tulip(host);\r\n}\r\nif (host->msg[0] != 2 || host->msg[1] != 3)\r\nreturn initio_msgout_reject(host);\r\nif (host->active_tc->flags & TCF_NO_WDTR) {\r\nhost->msg[2] = 0;\r\n} else {\r\nif (host->msg[2] > 2)\r\nreturn initio_msgout_reject(host);\r\nif (host->msg[2] == 2) {\r\nhost->msg[2] = 1;\r\n} else {\r\nif ((host->active_tc->flags & TCF_NO_WDTR) == 0) {\r\nwdtr_done(host);\r\nif ((host->active_tc->flags & (TCF_SYNC_DONE | TCF_NO_SYNC_NEGO)) == 0)\r\noutb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);\r\nreturn initio_msgin_accept(host);\r\n}\r\n}\r\n}\r\noutb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);\r\nif (initio_msgin_accept(host) != MSG_OUT)\r\nreturn host->phase;\r\noutb(MSG_EXTEND, host->addr + TUL_SFifo);\r\noutb(2, host->addr + TUL_SFifo);\r\noutb(3, host->addr + TUL_SFifo);\r\noutb(host->msg[2], host->addr + TUL_SFifo);\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nreturn wait_tulip(host);\r\n}\r\nstatic int initio_msgin_sync(struct initio_host * host)\r\n{\r\nchar default_period;\r\ndefault_period = initio_rate_tbl[host->active_tc->flags & TCF_SCSI_RATE];\r\nif (host->msg[3] > MAX_OFFSET) {\r\nhost->msg[3] = MAX_OFFSET;\r\nif (host->msg[2] < default_period) {\r\nhost->msg[2] = default_period;\r\nreturn 1;\r\n}\r\nif (host->msg[2] >= 59)\r\nhost->msg[3] = 0;\r\nreturn 1;\r\n}\r\nif (host->msg[3] == 0) {\r\nreturn 0;\r\n}\r\nif (host->msg[2] < default_period) {\r\nhost->msg[2] = default_period;\r\nreturn 1;\r\n}\r\nif (host->msg[2] >= 59) {\r\nhost->msg[3] = 0;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wdtr_done(struct initio_host * host)\r\n{\r\nhost->active_tc->flags &= ~TCF_SYNC_DONE;\r\nhost->active_tc->flags |= TCF_WDTR_DONE;\r\nhost->active_tc->js_period = 0;\r\nif (host->msg[2])\r\nhost->active_tc->js_period |= TSC_WIDE_SCSI;\r\nhost->active_tc->sconfig0 &= ~TSC_ALT_PERIOD;\r\noutb(host->active_tc->sconfig0, host->addr + TUL_SConfig);\r\noutb(host->active_tc->js_period, host->addr + TUL_SPeriod);\r\nreturn 1;\r\n}\r\nstatic int initio_sync_done(struct initio_host * host)\r\n{\r\nint i;\r\nhost->active_tc->flags |= TCF_SYNC_DONE;\r\nif (host->msg[3]) {\r\nhost->active_tc->js_period |= host->msg[3];\r\nfor (i = 0; i < 8; i++) {\r\nif (initio_rate_tbl[i] >= host->msg[2])\r\nbreak;\r\n}\r\nhost->active_tc->js_period |= (i << 4);\r\nhost->active_tc->sconfig0 |= TSC_ALT_PERIOD;\r\n}\r\noutb(host->active_tc->sconfig0, host->addr + TUL_SConfig);\r\noutb(host->active_tc->js_period, host->addr + TUL_SPeriod);\r\nreturn -1;\r\n}\r\nstatic int initio_post_scsi_rst(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb;\r\nstruct target_control *active_tc;\r\nint i;\r\nhost->active = NULL;\r\nhost->active_tc = NULL;\r\nhost->flags = 0;\r\nwhile ((scb = initio_pop_busy_scb(host)) != NULL) {\r\nscb->hastat = HOST_BAD_PHAS;\r\ninitio_append_done_scb(host, scb);\r\n}\r\nactive_tc = &host->targets[0];\r\nfor (i = 0; i < host->max_tar; active_tc++, i++) {\r\nactive_tc->flags &= ~(TCF_SYNC_DONE | TCF_WDTR_DONE);\r\nactive_tc->js_period = 0;\r\nactive_tc->sconfig0 = host->sconf1;\r\nhost->act_tags[0] = 0;\r\nhost->targets[i].flags &= ~TCF_BUSY;\r\n}\r\nreturn -1;\r\n}\r\nstatic void initio_select_atn_stop(struct initio_host * host, struct scsi_ctrl_blk * scb)\r\n{\r\nscb->status |= SCB_SELECT;\r\nscb->next_state = 0x1;\r\nhost->active = scb;\r\nhost->active_tc = &host->targets[scb->target];\r\noutb(TSC_SELATNSTOP, host->addr + TUL_SCmd);\r\n}\r\nstatic void initio_select_atn(struct initio_host * host, struct scsi_ctrl_blk * scb)\r\n{\r\nint i;\r\nscb->status |= SCB_SELECT;\r\nscb->next_state = 0x2;\r\noutb(scb->ident, host->addr + TUL_SFifo);\r\nfor (i = 0; i < (int) scb->cdblen; i++)\r\noutb(scb->cdb[i], host->addr + TUL_SFifo);\r\nhost->active_tc = &host->targets[scb->target];\r\nhost->active = scb;\r\noutb(TSC_SEL_ATN, host->addr + TUL_SCmd);\r\n}\r\nstatic void initio_select_atn3(struct initio_host * host, struct scsi_ctrl_blk * scb)\r\n{\r\nint i;\r\nscb->status |= SCB_SELECT;\r\nscb->next_state = 0x2;\r\noutb(scb->ident, host->addr + TUL_SFifo);\r\noutb(scb->tagmsg, host->addr + TUL_SFifo);\r\noutb(scb->tagid, host->addr + TUL_SFifo);\r\nfor (i = 0; i < scb->cdblen; i++)\r\noutb(scb->cdb[i], host->addr + TUL_SFifo);\r\nhost->active_tc = &host->targets[scb->target];\r\nhost->active = scb;\r\noutb(TSC_SEL_ATN3, host->addr + TUL_SCmd);\r\n}\r\nint initio_bus_device_reset(struct initio_host * host)\r\n{\r\nstruct scsi_ctrl_blk *scb = host->active;\r\nstruct target_control *active_tc = host->active_tc;\r\nstruct scsi_ctrl_blk *tmp, *prev;\r\nu8 tar;\r\nif (host->phase != MSG_OUT)\r\nreturn int_initio_bad_seq(host);\r\ninitio_unlink_pend_scb(host, scb);\r\ninitio_release_scb(host, scb);\r\ntar = scb->target;\r\nactive_tc->flags &= ~(TCF_SYNC_DONE | TCF_WDTR_DONE | TCF_BUSY);\r\nprev = tmp = host->first_busy;\r\nwhile (tmp != NULL) {\r\nif (tmp->target == tar) {\r\nif (tmp == host->first_busy) {\r\nif ((host->first_busy = tmp->next) == NULL)\r\nhost->last_busy = NULL;\r\n} else {\r\nprev->next = tmp->next;\r\nif (tmp == host->last_busy)\r\nhost->last_busy = prev;\r\n}\r\ntmp->hastat = HOST_ABORTED;\r\ninitio_append_done_scb(host, tmp);\r\n}\r\nelse {\r\nprev = tmp;\r\n}\r\ntmp = tmp->next;\r\n}\r\noutb(MSG_DEVRST, host->addr + TUL_SFifo);\r\noutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\r\nreturn initio_wait_disc(host);\r\n}\r\nstatic int initio_msgin_accept(struct initio_host * host)\r\n{\r\noutb(TSC_MSG_ACCEPT, host->addr + TUL_SCmd);\r\nreturn wait_tulip(host);\r\n}\r\nstatic int wait_tulip(struct initio_host * host)\r\n{\r\nwhile (!((host->jsstatus0 = inb(host->addr + TUL_SStatus0))\r\n& TSS_INT_PENDING))\r\ncpu_relax();\r\nhost->jsint = inb(host->addr + TUL_SInt);\r\nhost->phase = host->jsstatus0 & TSS_PH_MASK;\r\nhost->jsstatus1 = inb(host->addr + TUL_SStatus1);\r\nif (host->jsint & TSS_RESEL_INT)\r\nreturn int_initio_resel(host);\r\nif (host->jsint & TSS_SEL_TIMEOUT)\r\nreturn int_initio_busfree(host);\r\nif (host->jsint & TSS_SCSIRST_INT)\r\nreturn int_initio_scsi_rst(host);\r\nif (host->jsint & TSS_DISC_INT) {\r\nif (host->flags & HCF_EXPECT_DONE_DISC) {\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\ninitio_unlink_busy_scb(host, host->active);\r\nhost->active->hastat = 0;\r\ninitio_append_done_scb(host, host->active);\r\nhost->active = NULL;\r\nhost->active_tc = NULL;\r\nhost->flags &= ~HCF_EXPECT_DONE_DISC;\r\noutb(TSC_INITDEFAULT, host->addr + TUL_SConfig);\r\noutb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);\r\nreturn -1;\r\n}\r\nif (host->flags & HCF_EXPECT_DISC) {\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\nhost->active = NULL;\r\nhost->active_tc = NULL;\r\nhost->flags &= ~HCF_EXPECT_DISC;\r\noutb(TSC_INITDEFAULT, host->addr + TUL_SConfig);\r\noutb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);\r\nreturn -1;\r\n}\r\nreturn int_initio_busfree(host);\r\n}\r\nif (host->jsint & (TSS_FUNC_COMP | TSS_BUS_SERV))\r\nreturn host->phase;\r\nreturn host->phase;\r\n}\r\nstatic int initio_wait_disc(struct initio_host * host)\r\n{\r\nwhile (!((host->jsstatus0 = inb(host->addr + TUL_SStatus0)) & TSS_INT_PENDING))\r\ncpu_relax();\r\nhost->jsint = inb(host->addr + TUL_SInt);\r\nif (host->jsint & TSS_SCSIRST_INT)\r\nreturn int_initio_scsi_rst(host);\r\nif (host->jsint & TSS_DISC_INT) {\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\noutb(TSC_INITDEFAULT, host->addr + TUL_SConfig);\r\noutb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);\r\nhost->active = NULL;\r\nreturn -1;\r\n}\r\nreturn initio_bad_seq(host);\r\n}\r\nstatic int initio_wait_done_disc(struct initio_host * host)\r\n{\r\nwhile (!((host->jsstatus0 = inb(host->addr + TUL_SStatus0))\r\n& TSS_INT_PENDING))\r\ncpu_relax();\r\nhost->jsint = inb(host->addr + TUL_SInt);\r\nif (host->jsint & TSS_SCSIRST_INT)\r\nreturn int_initio_scsi_rst(host);\r\nif (host->jsint & TSS_DISC_INT) {\r\noutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\r\noutb(TSC_INITDEFAULT, host->addr + TUL_SConfig);\r\noutb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);\r\ninitio_unlink_busy_scb(host, host->active);\r\ninitio_append_done_scb(host, host->active);\r\nhost->active = NULL;\r\nreturn -1;\r\n}\r\nreturn initio_bad_seq(host);\r\n}\r\nstatic irqreturn_t i91u_intr(int irqno, void *dev_id)\r\n{\r\nstruct Scsi_Host *dev = dev_id;\r\nunsigned long flags;\r\nint r;\r\nspin_lock_irqsave(dev->host_lock, flags);\r\nr = initio_isr((struct initio_host *)dev->hostdata);\r\nspin_unlock_irqrestore(dev->host_lock, flags);\r\nif (r)\r\nreturn IRQ_HANDLED;\r\nelse\r\nreturn IRQ_NONE;\r\n}\r\nstatic void initio_build_scb(struct initio_host * host, struct scsi_ctrl_blk * cblk, struct scsi_cmnd * cmnd)\r\n{\r\nstruct scatterlist *sglist;\r\nstruct sg_entry *sg;\r\nint i, nseg;\r\nlong total_len;\r\ndma_addr_t dma_addr;\r\ncblk->post = i91uSCBPost;\r\ncblk->srb = cmnd;\r\ncblk->opcode = ExecSCSI;\r\ncblk->flags = SCF_POST;\r\ncblk->target = cmnd->device->id;\r\ncblk->lun = cmnd->device->lun;\r\ncblk->ident = cmnd->device->lun | DISC_ALLOW;\r\ncblk->flags |= SCF_SENSE;\r\ndma_addr = dma_map_single(&host->pci_dev->dev, cmnd->sense_buffer,\r\nSENSE_SIZE, DMA_FROM_DEVICE);\r\ncblk->senseptr = (u32)dma_addr;\r\ncblk->senselen = SENSE_SIZE;\r\ncmnd->SCp.ptr = (char *)(unsigned long)dma_addr;\r\ncblk->cdblen = cmnd->cmd_len;\r\ncblk->hastat = 0;\r\ncblk->tastat = 0;\r\nmemcpy(cblk->cdb, cmnd->cmnd, cmnd->cmd_len);\r\nif (cmnd->device->tagged_supported) {\r\ncblk->tagmsg = SIMPLE_QUEUE_TAG;\r\n} else {\r\ncblk->tagmsg = 0;\r\n}\r\nnseg = scsi_dma_map(cmnd);\r\nBUG_ON(nseg < 0);\r\nif (nseg) {\r\ndma_addr = dma_map_single(&host->pci_dev->dev, &cblk->sglist[0],\r\nsizeof(struct sg_entry) * TOTAL_SG_ENTRY,\r\nDMA_BIDIRECTIONAL);\r\ncblk->bufptr = (u32)dma_addr;\r\ncmnd->SCp.dma_handle = dma_addr;\r\ncblk->sglen = nseg;\r\ncblk->flags |= SCF_SG;\r\ntotal_len = 0;\r\nsg = &cblk->sglist[0];\r\nscsi_for_each_sg(cmnd, sglist, cblk->sglen, i) {\r\nsg->data = cpu_to_le32((u32)sg_dma_address(sglist));\r\nsg->len = cpu_to_le32((u32)sg_dma_len(sglist));\r\ntotal_len += sg_dma_len(sglist);\r\n++sg;\r\n}\r\ncblk->buflen = (scsi_bufflen(cmnd) > total_len) ?\r\ntotal_len : scsi_bufflen(cmnd);\r\n} else {\r\ncblk->buflen = 0;\r\ncblk->sglen = 0;\r\n}\r\n}\r\nstatic int i91u_queuecommand_lck(struct scsi_cmnd *cmd,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nstruct initio_host *host = (struct initio_host *) cmd->device->host->hostdata;\r\nstruct scsi_ctrl_blk *cmnd;\r\ncmd->scsi_done = done;\r\ncmnd = initio_alloc_scb(host);\r\nif (!cmnd)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\ninitio_build_scb(host, cmnd, cmd);\r\ninitio_exec_scb(host, cmnd);\r\nreturn 0;\r\n}\r\nstatic int i91u_biosparam(struct scsi_device *sdev, struct block_device *dev,\r\nsector_t capacity, int *info_array)\r\n{\r\nstruct initio_host *host;\r\nstruct target_control *tc;\r\nhost = (struct initio_host *) sdev->host->hostdata;\r\ntc = &host->targets[sdev->id];\r\nif (tc->heads) {\r\ninfo_array[0] = tc->heads;\r\ninfo_array[1] = tc->sectors;\r\ninfo_array[2] = (unsigned long)capacity / tc->heads / tc->sectors;\r\n} else {\r\nif (tc->drv_flags & TCF_DRV_255_63) {\r\ninfo_array[0] = 255;\r\ninfo_array[1] = 63;\r\ninfo_array[2] = (unsigned long)capacity / 255 / 63;\r\n} else {\r\ninfo_array[0] = 64;\r\ninfo_array[1] = 32;\r\ninfo_array[2] = (unsigned long)capacity >> 11;\r\n}\r\n}\r\n#if defined(DEBUG_BIOSPARAM)\r\nif (i91u_debug & debug_biosparam) {\r\nprintk("bios geometry: head=%d, sec=%d, cyl=%d\n",\r\ninfo_array[0], info_array[1], info_array[2]);\r\nprintk("WARNING: check, if the bios geometry is correct.\n");\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void i91u_unmap_scb(struct pci_dev *pci_dev, struct scsi_cmnd *cmnd)\r\n{\r\nif (cmnd->SCp.ptr) {\r\ndma_unmap_single(&pci_dev->dev,\r\n(dma_addr_t)((unsigned long)cmnd->SCp.ptr),\r\nSENSE_SIZE, DMA_FROM_DEVICE);\r\ncmnd->SCp.ptr = NULL;\r\n}\r\nif (scsi_sg_count(cmnd)) {\r\ndma_unmap_single(&pci_dev->dev, cmnd->SCp.dma_handle,\r\nsizeof(struct sg_entry) * TOTAL_SG_ENTRY,\r\nDMA_BIDIRECTIONAL);\r\nscsi_dma_unmap(cmnd);\r\n}\r\n}\r\nstatic void i91uSCBPost(u8 * host_mem, u8 * cblk_mem)\r\n{\r\nstruct scsi_cmnd *cmnd;\r\nstruct initio_host *host;\r\nstruct scsi_ctrl_blk *cblk;\r\nhost = (struct initio_host *) host_mem;\r\ncblk = (struct scsi_ctrl_blk *) cblk_mem;\r\nif ((cmnd = cblk->srb) == NULL) {\r\nprintk(KERN_ERR "i91uSCBPost: SRB pointer is empty\n");\r\nWARN_ON(1);\r\ninitio_release_scb(host, cblk);\r\nreturn;\r\n}\r\nswitch (cblk->hastat) {\r\ncase 0x0:\r\ncase 0xa:\r\ncase 0xb:\r\ncblk->hastat = 0;\r\nbreak;\r\ncase 0x11:\r\ncblk->hastat = DID_TIME_OUT;\r\nbreak;\r\ncase 0x14:\r\ncblk->hastat = DID_RESET;\r\nbreak;\r\ncase 0x1a:\r\ncblk->hastat = DID_ABORT;\r\nbreak;\r\ncase 0x12:\r\ncase 0x13:\r\ncase 0x16:\r\ndefault:\r\nprintk("ini9100u: %x %x\n", cblk->hastat, cblk->tastat);\r\ncblk->hastat = DID_ERROR;\r\nbreak;\r\n}\r\ncmnd->result = cblk->tastat | (cblk->hastat << 16);\r\ni91u_unmap_scb(host->pci_dev, cmnd);\r\ncmnd->scsi_done(cmnd);\r\ninitio_release_scb(host, cblk);\r\n}\r\nstatic int initio_probe_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct initio_host *host;\r\nu32 reg;\r\nu16 bios_seg;\r\nstruct scsi_ctrl_blk *scb, *tmp, *prev = NULL ;\r\nint num_scb, i, error;\r\nerror = pci_enable_device(pdev);\r\nif (error)\r\nreturn error;\r\npci_read_config_dword(pdev, 0x44, (u32 *) & reg);\r\nbios_seg = (u16) (reg & 0xFF);\r\nif (((reg & 0xFF00) >> 8) == 0xFF)\r\nreg = 0;\r\nbios_seg = (bios_seg << 8) + ((u16) ((reg & 0xFF00) >> 8));\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nprintk(KERN_WARNING "i91u: Could not set 32 bit DMA mask\n");\r\nerror = -ENODEV;\r\ngoto out_disable_device;\r\n}\r\nshost = scsi_host_alloc(&initio_template, sizeof(struct initio_host));\r\nif (!shost) {\r\nprintk(KERN_WARNING "initio: Could not allocate host structure.\n");\r\nerror = -ENOMEM;\r\ngoto out_disable_device;\r\n}\r\nhost = (struct initio_host *)shost->hostdata;\r\nmemset(host, 0, sizeof(struct initio_host));\r\nhost->addr = pci_resource_start(pdev, 0);\r\nhost->bios_addr = bios_seg;\r\nif (!request_region(host->addr, 256, "i91u")) {\r\nprintk(KERN_WARNING "initio: I/O port range 0x%x is busy.\n", host->addr);\r\nerror = -ENODEV;\r\ngoto out_host_put;\r\n}\r\nif (initio_tag_enable)\r\nnum_scb = MAX_TARGETS * i91u_MAXQUEUE;\r\nelse\r\nnum_scb = MAX_TARGETS + 3;\r\nfor (; num_scb >= MAX_TARGETS + 3; num_scb--) {\r\ni = num_scb * sizeof(struct scsi_ctrl_blk);\r\nif ((scb = kzalloc(i, GFP_DMA)) != NULL)\r\nbreak;\r\n}\r\nif (!scb) {\r\nprintk(KERN_WARNING "initio: Cannot allocate SCB array.\n");\r\nerror = -ENOMEM;\r\ngoto out_release_region;\r\n}\r\nhost->pci_dev = pdev;\r\nhost->semaph = 1;\r\nspin_lock_init(&host->semaph_lock);\r\nhost->num_scbs = num_scb;\r\nhost->scb = scb;\r\nhost->next_pending = scb;\r\nhost->next_avail = scb;\r\nfor (i = 0, tmp = scb; i < num_scb; i++, tmp++) {\r\ntmp->tagid = i;\r\nif (i != 0)\r\nprev->next = tmp;\r\nprev = tmp;\r\n}\r\nprev->next = NULL;\r\nhost->scb_end = tmp;\r\nhost->first_avail = scb;\r\nhost->last_avail = prev;\r\nspin_lock_init(&host->avail_lock);\r\ninitio_init(host, phys_to_virt(((u32)bios_seg << 4)));\r\nhost->jsstatus0 = 0;\r\nshost->io_port = host->addr;\r\nshost->n_io_port = 0xff;\r\nshost->can_queue = num_scb;\r\nshost->unique_id = host->addr;\r\nshost->max_id = host->max_tar;\r\nshost->max_lun = 32;\r\nshost->irq = pdev->irq;\r\nshost->this_id = host->scsi_id;\r\nshost->base = host->addr;\r\nshost->sg_tablesize = TOTAL_SG_ENTRY;\r\nerror = request_irq(pdev->irq, i91u_intr, IRQF_DISABLED|IRQF_SHARED, "i91u", shost);\r\nif (error < 0) {\r\nprintk(KERN_WARNING "initio: Unable to request IRQ %d\n", pdev->irq);\r\ngoto out_free_scbs;\r\n}\r\npci_set_drvdata(pdev, shost);\r\nerror = scsi_add_host(shost, &pdev->dev);\r\nif (error)\r\ngoto out_free_irq;\r\nscsi_scan_host(shost);\r\nreturn 0;\r\nout_free_irq:\r\nfree_irq(pdev->irq, shost);\r\nout_free_scbs:\r\nkfree(host->scb);\r\nout_release_region:\r\nrelease_region(host->addr, 256);\r\nout_host_put:\r\nscsi_host_put(shost);\r\nout_disable_device:\r\npci_disable_device(pdev);\r\nreturn error;\r\n}\r\nstatic void initio_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nstruct initio_host *s = (struct initio_host *)host->hostdata;\r\nscsi_remove_host(host);\r\nfree_irq(pdev->irq, host);\r\nrelease_region(s->addr, 256);\r\nscsi_host_put(host);\r\npci_disable_device(pdev);\r\n}\r\nstatic int __init initio_init_driver(void)\r\n{\r\nreturn pci_register_driver(&initio_pci_driver);\r\n}\r\nstatic void __exit initio_exit_driver(void)\r\n{\r\npci_unregister_driver(&initio_pci_driver);\r\n}
