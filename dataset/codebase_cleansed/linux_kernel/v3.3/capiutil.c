char *capi_info2str(u16 reason)\r\n{\r\nreturn "..";\r\n}\r\nchar *capi_info2str(u16 reason)\r\n{\r\nswitch (reason) {\r\ncase 0x0001:\r\nreturn "NCPI not supported by current protocol, NCPI ignored";\r\ncase 0x0002:\r\nreturn "Flags not supported by current protocol, flags ignored";\r\ncase 0x0003:\r\nreturn "Alert already sent by another application";\r\ncase 0x1001:\r\nreturn "Too many applications";\r\ncase 0x1002:\r\nreturn "Logical block size too small, must be at least 128 Bytes";\r\ncase 0x1003:\r\nreturn "Buffer exceeds 64 kByte";\r\ncase 0x1004:\r\nreturn "Message buffer size too small, must be at least 1024 Bytes";\r\ncase 0x1005:\r\nreturn "Max. number of logical connections not supported";\r\ncase 0x1006:\r\nreturn "Reserved";\r\ncase 0x1007:\r\nreturn "The message could not be accepted because of an internal busy condition";\r\ncase 0x1008:\r\nreturn "OS resource error (no memory ?)";\r\ncase 0x1009:\r\nreturn "CAPI not installed";\r\ncase 0x100A:\r\nreturn "Controller does not support external equipment";\r\ncase 0x100B:\r\nreturn "Controller does only support external equipment";\r\ncase 0x1101:\r\nreturn "Illegal application number";\r\ncase 0x1102:\r\nreturn "Illegal command or subcommand or message length less than 12 bytes";\r\ncase 0x1103:\r\nreturn "The message could not be accepted because of a queue full condition !! The error code does not imply that CAPI cannot receive messages directed to another controller, PLCI or NCCI";\r\ncase 0x1104:\r\nreturn "Queue is empty";\r\ncase 0x1105:\r\nreturn "Queue overflow, a message was lost !! This indicates a configuration error. The only recovery from this error is to perform a CAPI_RELEASE";\r\ncase 0x1106:\r\nreturn "Unknown notification parameter";\r\ncase 0x1107:\r\nreturn "The Message could not be accepted because of an internal busy condition";\r\ncase 0x1108:\r\nreturn "OS Resource error (no memory ?)";\r\ncase 0x1109:\r\nreturn "CAPI not installed";\r\ncase 0x110A:\r\nreturn "Controller does not support external equipment";\r\ncase 0x110B:\r\nreturn "Controller does only support external equipment";\r\ncase 0x2001:\r\nreturn "Message not supported in current state";\r\ncase 0x2002:\r\nreturn "Illegal Controller / PLCI / NCCI";\r\ncase 0x2003:\r\nreturn "Out of PLCI";\r\ncase 0x2004:\r\nreturn "Out of NCCI";\r\ncase 0x2005:\r\nreturn "Out of LISTEN";\r\ncase 0x2006:\r\nreturn "Out of FAX resources (protocol T.30)";\r\ncase 0x2007:\r\nreturn "Illegal message parameter coding";\r\ncase 0x3001:\r\nreturn "B1 protocol not supported";\r\ncase 0x3002:\r\nreturn "B2 protocol not supported";\r\ncase 0x3003:\r\nreturn "B3 protocol not supported";\r\ncase 0x3004:\r\nreturn "B1 protocol parameter not supported";\r\ncase 0x3005:\r\nreturn "B2 protocol parameter not supported";\r\ncase 0x3006:\r\nreturn "B3 protocol parameter not supported";\r\ncase 0x3007:\r\nreturn "B protocol combination not supported";\r\ncase 0x3008:\r\nreturn "NCPI not supported";\r\ncase 0x3009:\r\nreturn "CIP Value unknown";\r\ncase 0x300A:\r\nreturn "Flags not supported (reserved bits)";\r\ncase 0x300B:\r\nreturn "Facility not supported";\r\ncase 0x300C:\r\nreturn "Data length not supported by current protocol";\r\ncase 0x300D:\r\nreturn "Reset procedure not supported by current protocol";\r\ncase 0x3301:\r\nreturn "Protocol error layer 1 (broken line or B-channel removed by signalling protocol)";\r\ncase 0x3302:\r\nreturn "Protocol error layer 2";\r\ncase 0x3303:\r\nreturn "Protocol error layer 3";\r\ncase 0x3304:\r\nreturn "Another application got that call";\r\ncase 0x3311:\r\nreturn "Connecting not successful (remote station is no FAX G3 machine)";\r\ncase 0x3312:\r\nreturn "Connecting not successful (training error)";\r\ncase 0x3313:\r\nreturn "Disconnected before transfer (remote station does not support transfer mode, e.g. resolution)";\r\ncase 0x3314:\r\nreturn "Disconnected during transfer (remote abort)";\r\ncase 0x3315:\r\nreturn "Disconnected during transfer (remote procedure error, e.g. unsuccessful repetition of T.30 commands)";\r\ncase 0x3316:\r\nreturn "Disconnected during transfer (local tx data underrun)";\r\ncase 0x3317:\r\nreturn "Disconnected during transfer (local rx data overflow)";\r\ncase 0x3318:\r\nreturn "Disconnected during transfer (local abort)";\r\ncase 0x3319:\r\nreturn "Illegal parameter coding (e.g. SFF coding error)";\r\ncase 0x3481: return "Unallocated (unassigned) number";\r\ncase 0x3482: return "No route to specified transit network";\r\ncase 0x3483: return "No route to destination";\r\ncase 0x3486: return "Channel unacceptable";\r\ncase 0x3487:\r\nreturn "Call awarded and being delivered in an established channel";\r\ncase 0x3490: return "Normal call clearing";\r\ncase 0x3491: return "User busy";\r\ncase 0x3492: return "No user responding";\r\ncase 0x3493: return "No answer from user (user alerted)";\r\ncase 0x3495: return "Call rejected";\r\ncase 0x3496: return "Number changed";\r\ncase 0x349A: return "Non-selected user clearing";\r\ncase 0x349B: return "Destination out of order";\r\ncase 0x349C: return "Invalid number format";\r\ncase 0x349D: return "Facility rejected";\r\ncase 0x349E: return "Response to STATUS ENQUIRY";\r\ncase 0x349F: return "Normal, unspecified";\r\ncase 0x34A2: return "No circuit / channel available";\r\ncase 0x34A6: return "Network out of order";\r\ncase 0x34A9: return "Temporary failure";\r\ncase 0x34AA: return "Switching equipment congestion";\r\ncase 0x34AB: return "Access information discarded";\r\ncase 0x34AC: return "Requested circuit / channel not available";\r\ncase 0x34AF: return "Resources unavailable, unspecified";\r\ncase 0x34B1: return "Quality of service unavailable";\r\ncase 0x34B2: return "Requested facility not subscribed";\r\ncase 0x34B9: return "Bearer capability not authorized";\r\ncase 0x34BA: return "Bearer capability not presently available";\r\ncase 0x34BF: return "Service or option not available, unspecified";\r\ncase 0x34C1: return "Bearer capability not implemented";\r\ncase 0x34C2: return "Channel type not implemented";\r\ncase 0x34C5: return "Requested facility not implemented";\r\ncase 0x34C6: return "Only restricted digital information bearer capability is available";\r\ncase 0x34CF: return "Service or option not implemented, unspecified";\r\ncase 0x34D1: return "Invalid call reference value";\r\ncase 0x34D2: return "Identified channel does not exist";\r\ncase 0x34D3: return "A suspended call exists, but this call identity does not";\r\ncase 0x34D4: return "Call identity in use";\r\ncase 0x34D5: return "No call suspended";\r\ncase 0x34D6: return "Call having the requested call identity has been cleared";\r\ncase 0x34D8: return "Incompatible destination";\r\ncase 0x34DB: return "Invalid transit network selection";\r\ncase 0x34DF: return "Invalid message, unspecified";\r\ncase 0x34E0: return "Mandatory information element is missing";\r\ncase 0x34E1: return "Message type non-existent or not implemented";\r\ncase 0x34E2: return "Message not compatible with call state or message type non-existent or not implemented";\r\ncase 0x34E3: return "Information element non-existent or not implemented";\r\ncase 0x34E4: return "Invalid information element contents";\r\ncase 0x34E5: return "Message not compatible with call state";\r\ncase 0x34E6: return "Recovery on timer expiry";\r\ncase 0x34EF: return "Protocol error, unspecified";\r\ncase 0x34FF: return "Interworking, unspecified";\r\ndefault: return "No additional information";\r\n}\r\n}\r\nstatic unsigned command_2_index(unsigned c, unsigned sc)\r\n{\r\nif (c & 0x80)\r\nc = 0x9 + (c & 0x0f);\r\nelse if (c <= 0x0f);\r\nelse if (c == 0x41)\r\nc = 0x9 + 0x1;\r\nelse if (c == 0xff)\r\nc = 0x00;\r\nreturn (sc & 3) * (0x9 + 0x9) + c;\r\n}\r\nstatic void jumpcstruct(_cmsg * cmsg)\r\n{\r\nunsigned layer;\r\nfor (cmsg->p++, layer = 1; layer;) {\r\ncmsg->p++;\r\nswitch (TYP) {\r\ncase _CMSTRUCT:\r\nlayer++;\r\nbreak;\r\ncase _CEND:\r\nlayer--;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void pars_2_message(_cmsg * cmsg)\r\n{\r\nfor (; TYP != _CEND; cmsg->p++) {\r\nswitch (TYP) {\r\ncase _CBYTE:\r\nbyteTLcpy(cmsg->m + cmsg->l, OFF);\r\ncmsg->l++;\r\nbreak;\r\ncase _CWORD:\r\nwordTLcpy(cmsg->m + cmsg->l, OFF);\r\ncmsg->l += 2;\r\nbreak;\r\ncase _CDWORD:\r\ndwordTLcpy(cmsg->m + cmsg->l, OFF);\r\ncmsg->l += 4;\r\nbreak;\r\ncase _CSTRUCT:\r\nif (*(u8 **) OFF == NULL) {\r\n*(cmsg->m + cmsg->l) = '\0';\r\ncmsg->l++;\r\n} else if (**(_cstruct *) OFF != 0xff) {\r\nstructTLcpy(cmsg->m + cmsg->l, *(_cstruct *) OFF, 1 + **(_cstruct *) OFF);\r\ncmsg->l += 1 + **(_cstruct *) OFF;\r\n} else {\r\n_cstruct s = *(_cstruct *) OFF;\r\nstructTLcpy(cmsg->m + cmsg->l, s, 3 + *(u16 *) (s + 1));\r\ncmsg->l += 3 + *(u16 *) (s + 1);\r\n}\r\nbreak;\r\ncase _CMSTRUCT:\r\nif (*(_cmstruct *) OFF == CAPI_DEFAULT) {\r\n*(cmsg->m + cmsg->l) = '\0';\r\ncmsg->l++;\r\njumpcstruct(cmsg);\r\n}\r\nelse {\r\nunsigned _l = cmsg->l;\r\nunsigned _ls;\r\ncmsg->l++;\r\ncmsg->p++;\r\npars_2_message(cmsg);\r\n_ls = cmsg->l - _l - 1;\r\nif (_ls < 255)\r\n(cmsg->m + _l)[0] = (u8) _ls;\r\nelse {\r\nstructTLcpyovl(cmsg->m + _l + 3, cmsg->m + _l + 1, _ls);\r\n(cmsg->m + _l)[0] = 0xff;\r\nwordTLcpy(cmsg->m + _l + 1, &_ls);\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nunsigned capi_cmsg2message(_cmsg * cmsg, u8 * msg)\r\n{\r\ncmsg->m = msg;\r\ncmsg->l = 8;\r\ncmsg->p = 0;\r\ncmsg->par = cpars[command_2_index(cmsg->Command, cmsg->Subcommand)];\r\npars_2_message(cmsg);\r\nwordTLcpy(msg + 0, &cmsg->l);\r\nbyteTLcpy(cmsg->m + 4, &cmsg->Command);\r\nbyteTLcpy(cmsg->m + 5, &cmsg->Subcommand);\r\nwordTLcpy(cmsg->m + 2, &cmsg->ApplId);\r\nwordTLcpy(cmsg->m + 6, &cmsg->Messagenumber);\r\nreturn 0;\r\n}\r\nstatic void message_2_pars(_cmsg * cmsg)\r\n{\r\nfor (; TYP != _CEND; cmsg->p++) {\r\nswitch (TYP) {\r\ncase _CBYTE:\r\nbyteTRcpy(cmsg->m + cmsg->l, OFF);\r\ncmsg->l++;\r\nbreak;\r\ncase _CWORD:\r\nwordTRcpy(cmsg->m + cmsg->l, OFF);\r\ncmsg->l += 2;\r\nbreak;\r\ncase _CDWORD:\r\ndwordTRcpy(cmsg->m + cmsg->l, OFF);\r\ncmsg->l += 4;\r\nbreak;\r\ncase _CSTRUCT:\r\n*(u8 **) OFF = cmsg->m + cmsg->l;\r\nif (cmsg->m[cmsg->l] != 0xff)\r\ncmsg->l += 1 + cmsg->m[cmsg->l];\r\nelse\r\ncmsg->l += 3 + *(u16 *) (cmsg->m + cmsg->l + 1);\r\nbreak;\r\ncase _CMSTRUCT:\r\nif (cmsg->m[cmsg->l] == '\0') {\r\n*(_cmstruct *) OFF = CAPI_DEFAULT;\r\ncmsg->l++;\r\njumpcstruct(cmsg);\r\n} else {\r\nunsigned _l = cmsg->l;\r\n*(_cmstruct *) OFF = CAPI_COMPOSE;\r\ncmsg->l = (cmsg->m + _l)[0] == 255 ? cmsg->l + 3 : cmsg->l + 1;\r\ncmsg->p++;\r\nmessage_2_pars(cmsg);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nunsigned capi_message2cmsg(_cmsg * cmsg, u8 * msg)\r\n{\r\nmemset(cmsg, 0, sizeof(_cmsg));\r\ncmsg->m = msg;\r\ncmsg->l = 8;\r\ncmsg->p = 0;\r\nbyteTRcpy(cmsg->m + 4, &cmsg->Command);\r\nbyteTRcpy(cmsg->m + 5, &cmsg->Subcommand);\r\ncmsg->par = cpars[command_2_index(cmsg->Command, cmsg->Subcommand)];\r\nmessage_2_pars(cmsg);\r\nwordTRcpy(msg + 0, &cmsg->l);\r\nwordTRcpy(cmsg->m + 2, &cmsg->ApplId);\r\nwordTRcpy(cmsg->m + 6, &cmsg->Messagenumber);\r\nreturn 0;\r\n}\r\nunsigned capi_cmsg_header(_cmsg * cmsg, u16 _ApplId,\r\nu8 _Command, u8 _Subcommand,\r\nu16 _Messagenumber, u32 _Controller)\r\n{\r\nmemset(cmsg, 0, sizeof(_cmsg));\r\ncmsg->ApplId = _ApplId;\r\ncmsg->Command = _Command;\r\ncmsg->Subcommand = _Subcommand;\r\ncmsg->Messagenumber = _Messagenumber;\r\ncmsg->adr.adrController = _Controller;\r\nreturn 0;\r\n}\r\nchar *capi_cmd2str(u8 cmd, u8 subcmd)\r\n{\r\nreturn mnames[command_2_index(cmd, subcmd)];\r\n}\r\nstatic _cdebbuf *bufprint(_cdebbuf *cdb, char *fmt,...)\r\n{\r\nva_list f;\r\nsize_t n,r;\r\nif (!cdb)\r\nreturn NULL;\r\nva_start(f, fmt);\r\nr = cdb->size - cdb->pos;\r\nn = vsnprintf(cdb->p, r, fmt, f);\r\nva_end(f);\r\nif (n >= r) {\r\nsize_t ns = 2 * cdb->size;\r\nu_char *nb;\r\nwhile ((ns - cdb->pos) <= n)\r\nns *= 2;\r\nnb = kmalloc(ns, GFP_ATOMIC);\r\nif (!nb) {\r\ncdebbuf_free(cdb);\r\nreturn NULL;\r\n}\r\nmemcpy(nb, cdb->buf, cdb->pos);\r\nkfree(cdb->buf);\r\nnb[cdb->pos] = 0;\r\ncdb->buf = nb;\r\ncdb->p = cdb->buf + cdb->pos;\r\ncdb->size = ns;\r\nva_start(f, fmt);\r\nr = cdb->size - cdb->pos;\r\nn = vsnprintf(cdb->p, r, fmt, f);\r\nva_end(f);\r\n}\r\ncdb->p += n;\r\ncdb->pos += n;\r\nreturn cdb;\r\n}\r\nstatic _cdebbuf *printstructlen(_cdebbuf *cdb, u8 * m, unsigned len)\r\n{\r\nunsigned hex = 0;\r\nif (!cdb)\r\nreturn NULL;\r\nfor (; len; len--, m++)\r\nif (isalnum(*m) || *m == ' ') {\r\nif (hex)\r\ncdb = bufprint(cdb, ">");\r\ncdb = bufprint(cdb, "%c", *m);\r\nhex = 0;\r\n} else {\r\nif (!hex)\r\ncdb = bufprint(cdb, "<%02x", *m);\r\nelse\r\ncdb = bufprint(cdb, " %02x", *m);\r\nhex = 1;\r\n}\r\nif (hex)\r\ncdb = bufprint(cdb, ">");\r\nreturn cdb;\r\n}\r\nstatic _cdebbuf *printstruct(_cdebbuf *cdb, u8 * m)\r\n{\r\nunsigned len;\r\nif (m[0] != 0xff) {\r\nlen = m[0];\r\nm += 1;\r\n} else {\r\nlen = ((u16 *) (m + 1))[0];\r\nm += 3;\r\n}\r\ncdb = printstructlen(cdb, m, len);\r\nreturn cdb;\r\n}\r\nstatic _cdebbuf *protocol_message_2_pars(_cdebbuf *cdb, _cmsg *cmsg, int level)\r\n{\r\nfor (; TYP != _CEND; cmsg->p++) {\r\nint slen = 29 + 3 - level;\r\nint i;\r\nif (!cdb)\r\nreturn NULL;\r\ncdb = bufprint(cdb, " ");\r\nfor (i = 0; i < level - 1; i++)\r\ncdb = bufprint(cdb, " ");\r\nswitch (TYP) {\r\ncase _CBYTE:\r\ncdb = bufprint(cdb, "%-*s = 0x%x\n", slen, NAME, *(u8 *) (cmsg->m + cmsg->l));\r\ncmsg->l++;\r\nbreak;\r\ncase _CWORD:\r\ncdb = bufprint(cdb, "%-*s = 0x%x\n", slen, NAME, *(u16 *) (cmsg->m + cmsg->l));\r\ncmsg->l += 2;\r\nbreak;\r\ncase _CDWORD:\r\ncdb = bufprint(cdb, "%-*s = 0x%lx\n", slen, NAME, *(u32 *) (cmsg->m + cmsg->l));\r\ncmsg->l += 4;\r\nbreak;\r\ncase _CSTRUCT:\r\ncdb = bufprint(cdb, "%-*s = ", slen, NAME);\r\nif (cmsg->m[cmsg->l] == '\0')\r\ncdb = bufprint(cdb, "default");\r\nelse\r\ncdb = printstruct(cdb, cmsg->m + cmsg->l);\r\ncdb = bufprint(cdb, "\n");\r\nif (cmsg->m[cmsg->l] != 0xff)\r\ncmsg->l += 1 + cmsg->m[cmsg->l];\r\nelse\r\ncmsg->l += 3 + *(u16 *) (cmsg->m + cmsg->l + 1);\r\nbreak;\r\ncase _CMSTRUCT:\r\nif (cmsg->m[cmsg->l] == '\0') {\r\ncdb = bufprint(cdb, "%-*s = default\n", slen, NAME);\r\ncmsg->l++;\r\njumpcstruct(cmsg);\r\n} else {\r\nchar *name = NAME;\r\nunsigned _l = cmsg->l;\r\ncdb = bufprint(cdb, "%-*s\n", slen, name);\r\ncmsg->l = (cmsg->m + _l)[0] == 255 ? cmsg->l + 3 : cmsg->l + 1;\r\ncmsg->p++;\r\ncdb = protocol_message_2_pars(cdb, cmsg, level + 1);\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn cdb;\r\n}\r\nstatic _cdebbuf *cdebbuf_alloc(void)\r\n{\r\n_cdebbuf *cdb;\r\nif (likely(!test_and_set_bit(1, &g_debbuf_lock))) {\r\ncdb = g_debbuf;\r\ngoto init;\r\n} else\r\ncdb = kmalloc(sizeof(_cdebbuf), GFP_ATOMIC);\r\nif (!cdb)\r\nreturn NULL;\r\ncdb->buf = kmalloc(CDEBUG_SIZE, GFP_ATOMIC);\r\nif (!cdb->buf) {\r\nkfree(cdb);\r\nreturn NULL;\r\n}\r\ncdb->size = CDEBUG_SIZE;\r\ninit:\r\ncdb->buf[0] = 0;\r\ncdb->p = cdb->buf;\r\ncdb->pos = 0;\r\nreturn cdb;\r\n}\r\nvoid cdebbuf_free(_cdebbuf *cdb)\r\n{\r\nif (likely(cdb == g_debbuf)) {\r\ntest_and_clear_bit(1, &g_debbuf_lock);\r\nreturn;\r\n}\r\nif (likely(cdb))\r\nkfree(cdb->buf);\r\nkfree(cdb);\r\n}\r\n_cdebbuf *capi_message2str(u8 * msg)\r\n{\r\n_cdebbuf *cdb;\r\n_cmsg *cmsg;\r\ncdb = cdebbuf_alloc();\r\nif (unlikely(!cdb))\r\nreturn NULL;\r\nif (likely(cdb == g_debbuf))\r\ncmsg = g_cmsg;\r\nelse\r\ncmsg = kmalloc(sizeof(_cmsg), GFP_ATOMIC);\r\nif (unlikely(!cmsg)) {\r\ncdebbuf_free(cdb);\r\nreturn NULL;\r\n}\r\ncmsg->m = msg;\r\ncmsg->l = 8;\r\ncmsg->p = 0;\r\nbyteTRcpy(cmsg->m + 4, &cmsg->Command);\r\nbyteTRcpy(cmsg->m + 5, &cmsg->Subcommand);\r\ncmsg->par = cpars[command_2_index(cmsg->Command, cmsg->Subcommand)];\r\ncdb = bufprint(cdb, "%-26s ID=%03d #0x%04x LEN=%04d\n",\r\nmnames[command_2_index(cmsg->Command, cmsg->Subcommand)],\r\n((unsigned short *) msg)[1],\r\n((unsigned short *) msg)[3],\r\n((unsigned short *) msg)[0]);\r\ncdb = protocol_message_2_pars(cdb, cmsg, 1);\r\nif (unlikely(cmsg != g_cmsg))\r\nkfree(cmsg);\r\nreturn cdb;\r\n}\r\n_cdebbuf *capi_cmsg2str(_cmsg * cmsg)\r\n{\r\n_cdebbuf *cdb;\r\nif (!cmsg->m)\r\nreturn NULL;\r\ncdb = cdebbuf_alloc();\r\nif (!cdb)\r\nreturn NULL;\r\ncmsg->l = 8;\r\ncmsg->p = 0;\r\ncdb = bufprint(cdb, "%s ID=%03d #0x%04x LEN=%04d\n",\r\nmnames[command_2_index(cmsg->Command, cmsg->Subcommand)],\r\n((u16 *) cmsg->m)[1],\r\n((u16 *) cmsg->m)[3],\r\n((u16 *) cmsg->m)[0]);\r\ncdb = protocol_message_2_pars(cdb, cmsg, 1);\r\nreturn cdb;\r\n}\r\nint __init cdebug_init(void)\r\n{\r\ng_cmsg= kmalloc(sizeof(_cmsg), GFP_KERNEL);\r\nif (!g_cmsg)\r\nreturn -ENOMEM;\r\ng_debbuf = kmalloc(sizeof(_cdebbuf), GFP_KERNEL);\r\nif (!g_debbuf) {\r\nkfree(g_cmsg);\r\nreturn -ENOMEM;\r\n}\r\ng_debbuf->buf = kmalloc(CDEBUG_GSIZE, GFP_KERNEL);\r\nif (!g_debbuf->buf) {\r\nkfree(g_cmsg);\r\nkfree(g_debbuf);\r\nreturn -ENOMEM;\r\n}\r\ng_debbuf->size = CDEBUG_GSIZE;\r\ng_debbuf->buf[0] = 0;\r\ng_debbuf->p = g_debbuf->buf;\r\ng_debbuf->pos = 0;\r\nreturn 0;\r\n}\r\nvoid __exit cdebug_exit(void)\r\n{\r\nif (g_debbuf)\r\nkfree(g_debbuf->buf);\r\nkfree(g_debbuf);\r\nkfree(g_cmsg);\r\n}\r\n_cdebbuf *capi_message2str(u8 * msg)\r\n{\r\nreturn &g_debbuf;\r\n}\r\n_cdebbuf *capi_cmsg2str(_cmsg * cmsg)\r\n{\r\nreturn &g_debbuf;\r\n}\r\nvoid cdebbuf_free(_cdebbuf *cdb)\r\n{\r\n}\r\nint __init cdebug_init(void)\r\n{\r\nreturn 0;\r\n}\r\nvoid __exit cdebug_exit(void)\r\n{\r\n}
