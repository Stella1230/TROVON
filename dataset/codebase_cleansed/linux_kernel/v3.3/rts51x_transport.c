unsigned int rts51x_access_sglist(unsigned char *buffer,\r\nunsigned int buflen, void *sglist,\r\nvoid **sgptr, unsigned int *offset,\r\nenum xfer_buf_dir dir)\r\n{\r\nunsigned int cnt;\r\nstruct scatterlist *sg = (struct scatterlist *)*sgptr;\r\nif (!sg)\r\nsg = (struct scatterlist *)sglist;\r\ncnt = 0;\r\nwhile (cnt < buflen && sg) {\r\nstruct page *page = sg_page(sg) +\r\n((sg->offset + *offset) >> PAGE_SHIFT);\r\nunsigned int poff = (sg->offset + *offset) & (PAGE_SIZE - 1);\r\nunsigned int sglen = sg->length - *offset;\r\nif (sglen > buflen - cnt) {\r\nsglen = buflen - cnt;\r\n*offset += sglen;\r\n} else {\r\n*offset = 0;\r\nsg = sg_next(sg);\r\n}\r\nwhile (sglen > 0) {\r\nunsigned int plen = min(sglen, (unsigned int)\r\nPAGE_SIZE - poff);\r\nunsigned char *ptr = kmap(page);\r\nif (dir == TO_XFER_BUF)\r\nmemcpy(ptr + poff, buffer + cnt, plen);\r\nelse\r\nmemcpy(buffer + cnt, ptr + poff, plen);\r\nkunmap(page);\r\npoff = 0;\r\n++page;\r\ncnt += plen;\r\nsglen -= plen;\r\n}\r\n}\r\n*sgptr = sg;\r\nreturn cnt;\r\n}\r\nunsigned int rts51x_access_xfer_buf(unsigned char *buffer,\r\nunsigned int buflen, struct scsi_cmnd *srb,\r\nstruct scatterlist **sgptr,\r\nunsigned int *offset, enum xfer_buf_dir dir)\r\n{\r\nreturn rts51x_access_sglist(buffer, buflen, (void *)scsi_sglist(srb),\r\n(void **)sgptr, offset, dir);\r\n}\r\nvoid rts51x_set_xfer_buf(unsigned char *buffer,\r\nunsigned int buflen, struct scsi_cmnd *srb)\r\n{\r\nunsigned int offset = 0;\r\nstruct scatterlist *sg = NULL;\r\nbuflen = min(buflen, scsi_bufflen(srb));\r\nbuflen = rts51x_access_xfer_buf(buffer, buflen, srb, &sg, &offset,\r\nTO_XFER_BUF);\r\nif (buflen < scsi_bufflen(srb))\r\nscsi_set_resid(srb, scsi_bufflen(srb) - buflen);\r\n}\r\nvoid rts51x_get_xfer_buf(unsigned char *buffer,\r\nunsigned int buflen, struct scsi_cmnd *srb)\r\n{\r\nunsigned int offset = 0;\r\nstruct scatterlist *sg = NULL;\r\nbuflen = min(buflen, scsi_bufflen(srb));\r\nbuflen = rts51x_access_xfer_buf(buffer, buflen, srb, &sg, &offset,\r\nFROM_XFER_BUF);\r\nif (buflen < scsi_bufflen(srb))\r\nscsi_set_resid(srb, scsi_bufflen(srb) - buflen);\r\n}\r\nstatic void urb_done_completion(struct urb *urb)\r\n{\r\nstruct completion *urb_done_ptr = urb->context;\r\nif (urb_done_ptr)\r\ncomplete(urb_done_ptr);\r\n}\r\nstatic int rts51x_msg_common(struct rts51x_chip *chip, struct urb *urb,\r\nint timeout)\r\n{\r\nstruct rts51x_usb *rts51x = chip->usb;\r\nstruct completion urb_done;\r\nlong timeleft;\r\nint status;\r\nif (test_bit(FLIDX_ABORTING, &rts51x->dflags))\r\nTRACE_RET(chip, -EIO);\r\ninit_completion(&urb_done);\r\nurb->context = &urb_done;\r\nurb->actual_length = 0;\r\nurb->error_count = 0;\r\nurb->status = 0;\r\nurb->transfer_flags = URB_NO_SETUP_DMA_MAP;\r\nif (urb->transfer_buffer == rts51x->iobuf) {\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nurb->transfer_dma = rts51x->iobuf_dma;\r\n}\r\nurb->setup_dma = rts51x->cr_dma;\r\nstatus = usb_submit_urb(urb, GFP_NOIO);\r\nif (status) {\r\nTRACE_RET(chip, status);\r\n}\r\nset_bit(FLIDX_URB_ACTIVE, &rts51x->dflags);\r\nif (test_bit(FLIDX_ABORTING, &rts51x->dflags)) {\r\nif (test_and_clear_bit(FLIDX_URB_ACTIVE, &rts51x->dflags)) {\r\nRTS51X_DEBUGP("-- cancelling URB\n");\r\nusb_unlink_urb(urb);\r\n}\r\n}\r\ntimeleft =\r\nwait_for_completion_interruptible_timeout(&urb_done,\r\n(timeout * HZ /\r\n1000) ? :\r\nMAX_SCHEDULE_TIMEOUT);\r\nclear_bit(FLIDX_URB_ACTIVE, &rts51x->dflags);\r\nif (timeleft <= 0) {\r\nRTS51X_DEBUGP("%s -- cancelling URB\n",\r\ntimeleft == 0 ? "Timeout" : "Signal");\r\nusb_kill_urb(urb);\r\nif (timeleft == 0)\r\nstatus = -ETIMEDOUT;\r\nelse\r\nstatus = -EINTR;\r\n} else {\r\nstatus = urb->status;\r\n}\r\nreturn status;\r\n}\r\nstatic int interpret_urb_result(struct rts51x_chip *chip, unsigned int pipe,\r\nunsigned int length, int result,\r\nunsigned int partial)\r\n{\r\nint retval = STATUS_SUCCESS;\r\nswitch (result) {\r\ncase 0:\r\nif (partial != length) {\r\nRTS51X_DEBUGP("-- short transfer\n");\r\nTRACE_RET(chip, STATUS_TRANS_SHORT);\r\n}\r\nreturn STATUS_SUCCESS;\r\ncase -EPIPE:\r\nif (usb_pipecontrol(pipe)) {\r\nRTS51X_DEBUGP("-- stall on control pipe\n");\r\nTRACE_RET(chip, STATUS_STALLED);\r\n}\r\nRTS51X_DEBUGP("clearing endpoint halt for pipe 0x%x\n", pipe);\r\nif (rts51x_clear_halt(chip, pipe) < 0)\r\nTRACE_RET(chip, STATUS_ERROR);\r\nretval = STATUS_STALLED;\r\nTRACE_GOTO(chip, Exit);\r\ncase -EOVERFLOW:\r\nRTS51X_DEBUGP("-- babble\n");\r\nretval = STATUS_TRANS_LONG;\r\nTRACE_GOTO(chip, Exit);\r\ncase -ECONNRESET:\r\nRTS51X_DEBUGP("-- transfer cancelled\n");\r\nretval = STATUS_ERROR;\r\nTRACE_GOTO(chip, Exit);\r\ncase -EREMOTEIO:\r\nRTS51X_DEBUGP("-- short read transfer\n");\r\nretval = STATUS_TRANS_SHORT;\r\nTRACE_GOTO(chip, Exit);\r\ncase -EIO:\r\nRTS51X_DEBUGP("-- abort or disconnect in progress\n");\r\nretval = STATUS_ERROR;\r\nTRACE_GOTO(chip, Exit);\r\ncase -ETIMEDOUT:\r\nRTS51X_DEBUGP("-- time out\n");\r\nretval = STATUS_TIMEDOUT;\r\nTRACE_GOTO(chip, Exit);\r\ndefault:\r\nRTS51X_DEBUGP("-- unknown error\n");\r\nretval = STATUS_ERROR;\r\nTRACE_GOTO(chip, Exit);\r\n}\r\nExit:\r\nif ((retval != STATUS_SUCCESS) && !usb_pipecontrol(pipe))\r\nrts51x_clear_hw_error(chip);\r\nreturn retval;\r\n}\r\nint rts51x_ctrl_transfer(struct rts51x_chip *chip, unsigned int pipe,\r\nu8 request, u8 requesttype, u16 value, u16 index,\r\nvoid *data, u16 size, int timeout)\r\n{\r\nstruct rts51x_usb *rts51x = chip->usb;\r\nint result;\r\nRTS51X_DEBUGP("%s: rq=%02x rqtype=%02x value=%04x index=%02x len=%u\n",\r\n__func__, request, requesttype, value, index, size);\r\nrts51x->cr->bRequestType = requesttype;\r\nrts51x->cr->bRequest = request;\r\nrts51x->cr->wValue = cpu_to_le16(value);\r\nrts51x->cr->wIndex = cpu_to_le16(index);\r\nrts51x->cr->wLength = cpu_to_le16(size);\r\nusb_fill_control_urb(rts51x->current_urb, rts51x->pusb_dev, pipe,\r\n(unsigned char *)rts51x->cr, data, size,\r\nurb_done_completion, NULL);\r\nresult = rts51x_msg_common(chip, rts51x->current_urb, timeout);\r\nreturn interpret_urb_result(chip, pipe, size, result,\r\nrts51x->current_urb->actual_length);\r\n}\r\nint rts51x_clear_halt(struct rts51x_chip *chip, unsigned int pipe)\r\n{\r\nint result;\r\nint endp = usb_pipeendpoint(pipe);\r\nif (usb_pipein(pipe))\r\nendp |= USB_DIR_IN;\r\nresult = rts51x_ctrl_transfer(chip, SND_CTRL_PIPE(chip),\r\nUSB_REQ_CLEAR_FEATURE, USB_RECIP_ENDPOINT,\r\nUSB_ENDPOINT_HALT, endp, NULL, 0, 3000);\r\nif (result != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nusb_reset_endpoint(chip->usb->pusb_dev, endp);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_reset_pipe(struct rts51x_chip *chip, char pipe)\r\n{\r\nreturn rts51x_clear_halt(chip, pipe);\r\n}\r\nstatic void rts51x_sg_clean(struct usb_sg_request *io)\r\n{\r\nif (io->urbs) {\r\nwhile (io->entries--)\r\nusb_free_urb(io->urbs[io->entries]);\r\nkfree(io->urbs);\r\nio->urbs = NULL;\r\n}\r\n#if 0\r\nif (io->dev->dev.dma_mask != NULL)\r\nusb_buffer_unmap_sg(io->dev, usb_pipein(io->pipe),\r\nio->sg, io->nents);\r\n#endif\r\nio->dev = NULL;\r\n}\r\nint rts51x_sg_init(struct usb_sg_request *io, struct usb_device *dev,\r\nunsigned pipe, unsigned period, struct scatterlist *sg,\r\nint nents, size_t length, gfp_t mem_flags)\r\n{\r\nreturn usb_sg_init(io, dev, pipe, period, sg, nents, length, mem_flags);\r\n}\r\nint rts51x_sg_wait(struct usb_sg_request *io, int timeout)\r\n{\r\nlong timeleft;\r\nint i;\r\nint entries = io->entries;\r\nspin_lock_irq(&io->lock);\r\ni = 0;\r\nwhile (i < entries && !io->status) {\r\nint retval;\r\nio->urbs[i]->dev = io->dev;\r\nretval = usb_submit_urb(io->urbs[i], GFP_ATOMIC);\r\nspin_unlock_irq(&io->lock);\r\nswitch (retval) {\r\ncase -ENXIO:\r\ncase -EAGAIN:\r\ncase -ENOMEM:\r\nio->urbs[i]->dev = NULL;\r\nretval = 0;\r\nyield();\r\nbreak;\r\ncase 0:\r\n++i;\r\ncpu_relax();\r\nbreak;\r\ndefault:\r\nio->urbs[i]->dev = NULL;\r\nio->urbs[i]->status = retval;\r\ndev_dbg(&io->dev->dev, "%s, submit --> %d\n",\r\n__func__, retval);\r\nusb_sg_cancel(io);\r\n}\r\nspin_lock_irq(&io->lock);\r\nif (retval && (io->status == 0 || io->status == -ECONNRESET))\r\nio->status = retval;\r\n}\r\nio->count -= entries - i;\r\nif (io->count == 0)\r\ncomplete(&io->complete);\r\nspin_unlock_irq(&io->lock);\r\ntimeleft =\r\nwait_for_completion_interruptible_timeout(&io->complete,\r\n(timeout * HZ /\r\n1000) ? :\r\nMAX_SCHEDULE_TIMEOUT);\r\nif (timeleft <= 0) {\r\nRTS51X_DEBUGP("%s -- cancelling SG request\n",\r\ntimeleft == 0 ? "Timeout" : "Signal");\r\nusb_sg_cancel(io);\r\nif (timeleft == 0)\r\nio->status = -ETIMEDOUT;\r\nelse\r\nio->status = -EINTR;\r\n}\r\nrts51x_sg_clean(io);\r\nreturn io->status;\r\n}\r\nstatic int rts51x_bulk_transfer_sglist(struct rts51x_chip *chip,\r\nunsigned int pipe,\r\nstruct scatterlist *sg, int num_sg,\r\nunsigned int length,\r\nunsigned int *act_len, int timeout)\r\n{\r\nint result;\r\nif (test_bit(FLIDX_ABORTING, &chip->usb->dflags))\r\nTRACE_RET(chip, STATUS_ERROR);\r\nRTS51X_DEBUGP("%s: xfer %u bytes, %d entries\n", __func__,\r\nlength, num_sg);\r\nresult =\r\nrts51x_sg_init(&chip->usb->current_sg, chip->usb->pusb_dev, pipe, 0,\r\nsg, num_sg, length, GFP_NOIO);\r\nif (result) {\r\nRTS51X_DEBUGP("rts51x_sg_init returned %d\n", result);\r\nTRACE_RET(chip, STATUS_ERROR);\r\n}\r\nset_bit(FLIDX_SG_ACTIVE, &chip->usb->dflags);\r\nif (test_bit(FLIDX_ABORTING, &chip->usb->dflags)) {\r\nif (test_and_clear_bit(FLIDX_SG_ACTIVE, &chip->usb->dflags)) {\r\nRTS51X_DEBUGP("-- cancelling sg request\n");\r\nusb_sg_cancel(&chip->usb->current_sg);\r\n}\r\n}\r\nresult = rts51x_sg_wait(&chip->usb->current_sg, timeout);\r\nclear_bit(FLIDX_SG_ACTIVE, &chip->usb->dflags);\r\nif (act_len)\r\n*act_len = chip->usb->current_sg.bytes;\r\nreturn interpret_urb_result(chip, pipe, length, result,\r\nchip->usb->current_sg.bytes);\r\n}\r\nint rts51x_bulk_transfer_buf(struct rts51x_chip *chip, unsigned int pipe,\r\nvoid *buf, unsigned int length,\r\nunsigned int *act_len, int timeout)\r\n{\r\nint result;\r\nusb_fill_bulk_urb(chip->usb->current_urb, chip->usb->pusb_dev, pipe,\r\nbuf, length, urb_done_completion, NULL);\r\nresult = rts51x_msg_common(chip, chip->usb->current_urb, timeout);\r\nif (act_len)\r\n*act_len = chip->usb->current_urb->actual_length;\r\nreturn interpret_urb_result(chip, pipe, length, result,\r\nchip->usb->current_urb->actual_length);\r\n}\r\nint rts51x_transfer_data(struct rts51x_chip *chip, unsigned int pipe,\r\nvoid *buf, unsigned int len, int use_sg,\r\nunsigned int *act_len, int timeout)\r\n{\r\nint result;\r\nif (timeout < 600)\r\ntimeout = 600;\r\nif (use_sg) {\r\nresult =\r\nrts51x_bulk_transfer_sglist(chip, pipe,\r\n(struct scatterlist *)buf,\r\nuse_sg, len, act_len, timeout);\r\n} else {\r\nresult =\r\nrts51x_bulk_transfer_buf(chip, pipe, buf, len, act_len,\r\ntimeout);\r\n}\r\nreturn result;\r\n}\r\nint rts51x_transfer_data_partial(struct rts51x_chip *chip, unsigned int pipe,\r\nvoid *buf, void **ptr, unsigned int *offset,\r\nunsigned int len, int use_sg,\r\nunsigned int *act_len, int timeout)\r\n{\r\nint result;\r\nif (timeout < 600)\r\ntimeout = 600;\r\nif (use_sg) {\r\nvoid *tmp_buf = kmalloc(len, GFP_KERNEL);\r\nif (!tmp_buf)\r\nTRACE_RET(chip, STATUS_NOMEM);\r\nif (usb_pipeout(pipe)) {\r\nrts51x_access_sglist(tmp_buf, len, buf, ptr, offset,\r\nFROM_XFER_BUF);\r\n}\r\nresult =\r\nrts51x_bulk_transfer_buf(chip, pipe, tmp_buf, len, act_len,\r\ntimeout);\r\nif (result == STATUS_SUCCESS) {\r\nif (usb_pipein(pipe)) {\r\nrts51x_access_sglist(tmp_buf, len, buf, ptr,\r\noffset, TO_XFER_BUF);\r\n}\r\n}\r\nkfree(tmp_buf);\r\n#if 0\r\nresult = rts51x_bulk_transfer_sglist_partial(chip, pipe, buf,\r\n(struct scatterlist **)ptr, offset,\r\nuse_sg, len, act_len, timeout);\r\n#endif\r\n} else {\r\nunsigned int step = 0;\r\nif (offset)\r\nstep = *offset;\r\nresult =\r\nrts51x_bulk_transfer_buf(chip, pipe, buf + step, len,\r\nact_len, timeout);\r\nif (act_len)\r\nstep += *act_len;\r\nelse\r\nstep += len;\r\nif (offset)\r\n*offset = step;\r\n}\r\nreturn result;\r\n}\r\nint rts51x_get_epc_status(struct rts51x_chip *chip, u16 * status)\r\n{\r\nunsigned int pipe = RCV_INTR_PIPE(chip);\r\nstruct usb_host_endpoint *ep;\r\nstruct completion urb_done;\r\nint result;\r\nif (!status)\r\nTRACE_RET(chip, STATUS_ERROR);\r\ninit_completion(&urb_done);\r\nep = chip->usb->pusb_dev->ep_in[usb_pipeendpoint(pipe)];\r\nusb_fill_int_urb(chip->usb->intr_urb, chip->usb->pusb_dev, pipe,\r\nstatus, 2, urb_done_completion, &urb_done, 1);\r\nresult = rts51x_msg_common(chip, chip->usb->intr_urb, 50);\r\nreturn interpret_urb_result(chip, pipe, 2, result,\r\nchip->usb->intr_urb->actual_length);\r\n}\r\nvoid rts51x_invoke_transport(struct scsi_cmnd *srb, struct rts51x_chip *chip)\r\n{\r\nint result;\r\n#ifdef CONFIG_PM\r\nif (chip->option.ss_en) {\r\nif (srb->cmnd[0] == TEST_UNIT_READY) {\r\nif (RTS51X_CHK_STAT(chip, STAT_SS)) {\r\nif (check_fake_card_ready(chip,\r\nSCSI_LUN(srb))) {\r\nsrb->result = SAM_STAT_GOOD;\r\n} else {\r\nsrb->result = SAM_STAT_CHECK_CONDITION;\r\nmemcpy(srb->sense_buffer,\r\nmedia_not_present, SENSE_SIZE);\r\n}\r\nreturn;\r\n}\r\n} else if (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {\r\nif (RTS51X_CHK_STAT(chip, STAT_SS)) {\r\nint prevent = srb->cmnd[4] & 0x1;\r\nif (prevent) {\r\nsrb->result = SAM_STAT_CHECK_CONDITION;\r\nmemcpy(srb->sense_buffer,\r\ninvalid_cmd_field, SENSE_SIZE);\r\n} else {\r\nsrb->result = SAM_STAT_GOOD;\r\n}\r\nreturn;\r\n}\r\n} else {\r\nif (RTS51X_CHK_STAT(chip, STAT_SS)\r\n|| RTS51X_CHK_STAT(chip, STAT_SS_PRE)) {\r\nRTS51X_DEBUGP("Try to wake up device\n");\r\nchip->resume_from_scsi = 1;\r\nrts51x_try_to_exit_ss(chip);\r\nif (RTS51X_CHK_STAT(chip, STAT_SS)) {\r\nwait_timeout(3000);\r\nrts51x_init_chip(chip);\r\nrts51x_init_cards(chip);\r\n}\r\n}\r\n}\r\n}\r\n#endif\r\nresult = rts51x_scsi_handler(srb, chip);\r\nif (result == TRANSPORT_ERROR) {\r\nRTS51X_DEBUGP("-- transport indicates error, resetting\n");\r\nsrb->result = DID_ERROR << 16;\r\ngoto Handle_Errors;\r\n}\r\nsrb->result = SAM_STAT_GOOD;\r\nif (result == TRANSPORT_FAILED) {\r\nsrb->result = SAM_STAT_CHECK_CONDITION;\r\nmemcpy(srb->sense_buffer,\r\n(unsigned char *)&(chip->sense_buffer[SCSI_LUN(srb)]),\r\nsizeof(struct sense_data_t));\r\n}\r\nreturn;\r\nHandle_Errors:\r\nreturn;\r\n}
