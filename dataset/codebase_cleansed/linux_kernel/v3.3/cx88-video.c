static const struct cx8800_fmt* format_by_fourcc(unsigned int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(formats); i++)\r\nif (formats[i].fourcc == fourcc)\r\nreturn formats+i;\r\nreturn NULL;\r\n}\r\nint cx8800_ctrl_query(struct cx88_core *core, struct v4l2_queryctrl *qctrl)\r\n{\r\nint i;\r\nif (qctrl->id < V4L2_CID_BASE ||\r\nqctrl->id >= V4L2_CID_LASTP1)\r\nreturn -EINVAL;\r\nfor (i = 0; i < CX8800_CTLS; i++)\r\nif (cx8800_ctls[i].v.id == qctrl->id)\r\nbreak;\r\nif (i == CX8800_CTLS) {\r\n*qctrl = no_ctl;\r\nreturn 0;\r\n}\r\n*qctrl = cx8800_ctls[i].v;\r\nif (cx8800_ctls[i].v.id == V4L2_CID_CHROMA_AGC &&\r\ncore->tvnorm & V4L2_STD_SECAM)\r\nqctrl->flags |= V4L2_CTRL_FLAG_INACTIVE;\r\nreturn 0;\r\n}\r\nstatic int res_get(struct cx8800_dev *dev, struct cx8800_fh *fh, unsigned int bit)\r\n{\r\nstruct cx88_core *core = dev->core;\r\nif (fh->resources & bit)\r\nreturn 1;\r\nmutex_lock(&core->lock);\r\nif (dev->resources & bit) {\r\nmutex_unlock(&core->lock);\r\nreturn 0;\r\n}\r\nfh->resources |= bit;\r\ndev->resources |= bit;\r\ndprintk(1,"res: get %d\n",bit);\r\nmutex_unlock(&core->lock);\r\nreturn 1;\r\n}\r\nstatic\r\nint res_check(struct cx8800_fh *fh, unsigned int bit)\r\n{\r\nreturn (fh->resources & bit);\r\n}\r\nstatic\r\nint res_locked(struct cx8800_dev *dev, unsigned int bit)\r\n{\r\nreturn (dev->resources & bit);\r\n}\r\nstatic\r\nvoid res_free(struct cx8800_dev *dev, struct cx8800_fh *fh, unsigned int bits)\r\n{\r\nstruct cx88_core *core = dev->core;\r\nBUG_ON((fh->resources & bits) != bits);\r\nmutex_lock(&core->lock);\r\nfh->resources &= ~bits;\r\ndev->resources &= ~bits;\r\ndprintk(1,"res: put %d\n",bits);\r\nmutex_unlock(&core->lock);\r\n}\r\nint cx88_video_mux(struct cx88_core *core, unsigned int input)\r\n{\r\ndprintk(1,"video_mux: %d [vmux=%d,gpio=0x%x,0x%x,0x%x,0x%x]\n",\r\ninput, INPUT(input).vmux,\r\nINPUT(input).gpio0,INPUT(input).gpio1,\r\nINPUT(input).gpio2,INPUT(input).gpio3);\r\ncore->input = input;\r\ncx_andor(MO_INPUT_FORMAT, 0x03 << 14, INPUT(input).vmux << 14);\r\ncx_write(MO_GP3_IO, INPUT(input).gpio3);\r\ncx_write(MO_GP0_IO, INPUT(input).gpio0);\r\ncx_write(MO_GP1_IO, INPUT(input).gpio1);\r\ncx_write(MO_GP2_IO, INPUT(input).gpio2);\r\nswitch (INPUT(input).type) {\r\ncase CX88_VMUX_SVIDEO:\r\ncx_set(MO_AFECFG_IO, 0x00000001);\r\ncx_set(MO_INPUT_FORMAT, 0x00010010);\r\ncx_set(MO_FILTER_EVEN, 0x00002020);\r\ncx_set(MO_FILTER_ODD, 0x00002020);\r\nbreak;\r\ndefault:\r\ncx_clear(MO_AFECFG_IO, 0x00000001);\r\ncx_clear(MO_INPUT_FORMAT, 0x00010010);\r\ncx_clear(MO_FILTER_EVEN, 0x00002020);\r\ncx_clear(MO_FILTER_ODD, 0x00002020);\r\nbreak;\r\n}\r\nif (INPUT(input).audioroute) {\r\nif (core->board.audio_chip &&\r\ncore->board.audio_chip == V4L2_IDENT_WM8775) {\r\ncall_all(core, audio, s_routing,\r\nINPUT(input).audioroute, 0, 0);\r\n}\r\nif (INPUT(input).type != CX88_VMUX_TELEVISION &&\r\nINPUT(input).type != CX88_VMUX_CABLE) {\r\ncore->tvaudio = WW_I2SADC;\r\ncx88_set_tvaudio(core);\r\n} else {\r\ncx_write(AUD_I2SCNTL, 0x0);\r\ncx_clear(AUD_CTL, EN_I2SIN_ENABLE);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int start_video_dma(struct cx8800_dev *dev,\r\nstruct cx88_dmaqueue *q,\r\nstruct cx88_buffer *buf)\r\n{\r\nstruct cx88_core *core = dev->core;\r\ncx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH21],\r\nbuf->bpl, buf->risc.dma);\r\ncx88_set_scale(core, buf->vb.width, buf->vb.height, buf->vb.field);\r\ncx_write(MO_COLOR_CTRL, buf->fmt->cxformat | ColorFormatGamma);\r\ncx_write(MO_VIDY_GPCNTRL,GP_COUNT_CONTROL_RESET);\r\nq->count = 1;\r\ncx_set(MO_PCI_INTMSK, core->pci_irqmask | PCI_INT_VIDINT);\r\ncx_set(MO_VID_INTMSK, 0x0f0011);\r\ncx_set(VID_CAPTURE_CONTROL,0x06);\r\ncx_set(MO_DEV_CNTRL2, (1<<5));\r\ncx_set(MO_VID_DMACNTRL, 0x11);\r\nreturn 0;\r\n}\r\nstatic int stop_video_dma(struct cx8800_dev *dev)\r\n{\r\nstruct cx88_core *core = dev->core;\r\ncx_clear(MO_VID_DMACNTRL, 0x11);\r\ncx_clear(VID_CAPTURE_CONTROL,0x06);\r\ncx_clear(MO_PCI_INTMSK, PCI_INT_VIDINT);\r\ncx_clear(MO_VID_INTMSK, 0x0f0011);\r\nreturn 0;\r\n}\r\nstatic int restart_video_queue(struct cx8800_dev *dev,\r\nstruct cx88_dmaqueue *q)\r\n{\r\nstruct cx88_core *core = dev->core;\r\nstruct cx88_buffer *buf, *prev;\r\nif (!list_empty(&q->active)) {\r\nbuf = list_entry(q->active.next, struct cx88_buffer, vb.queue);\r\ndprintk(2,"restart_queue [%p/%d]: restart dma\n",\r\nbuf, buf->vb.i);\r\nstart_video_dma(dev, q, buf);\r\nlist_for_each_entry(buf, &q->active, vb.queue)\r\nbuf->count = q->count++;\r\nmod_timer(&q->timeout, jiffies+BUFFER_TIMEOUT);\r\nreturn 0;\r\n}\r\nprev = NULL;\r\nfor (;;) {\r\nif (list_empty(&q->queued))\r\nreturn 0;\r\nbuf = list_entry(q->queued.next, struct cx88_buffer, vb.queue);\r\nif (NULL == prev) {\r\nlist_move_tail(&buf->vb.queue, &q->active);\r\nstart_video_dma(dev, q, buf);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nmod_timer(&q->timeout, jiffies+BUFFER_TIMEOUT);\r\ndprintk(2,"[%p/%d] restart_queue - first active\n",\r\nbuf,buf->vb.i);\r\n} else if (prev->vb.width == buf->vb.width &&\r\nprev->vb.height == buf->vb.height &&\r\nprev->fmt == buf->fmt) {\r\nlist_move_tail(&buf->vb.queue, &q->active);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\r\ndprintk(2,"[%p/%d] restart_queue - move to active\n",\r\nbuf,buf->vb.i);\r\n} else {\r\nreturn 0;\r\n}\r\nprev = buf;\r\n}\r\n}\r\nstatic int\r\nbuffer_setup(struct videobuf_queue *q, unsigned int *count, unsigned int *size)\r\n{\r\nstruct cx8800_fh *fh = q->priv_data;\r\n*size = fh->fmt->depth*fh->width*fh->height >> 3;\r\nif (0 == *count)\r\n*count = 32;\r\nif (*size * *count > vid_limit * 1024 * 1024)\r\n*count = (vid_limit * 1024 * 1024) / *size;\r\nreturn 0;\r\n}\r\nstatic int\r\nbuffer_prepare(struct videobuf_queue *q, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct cx8800_fh *fh = q->priv_data;\r\nstruct cx8800_dev *dev = fh->dev;\r\nstruct cx88_core *core = dev->core;\r\nstruct cx88_buffer *buf = container_of(vb,struct cx88_buffer,vb);\r\nstruct videobuf_dmabuf *dma=videobuf_to_dma(&buf->vb);\r\nint rc, init_buffer = 0;\r\nBUG_ON(NULL == fh->fmt);\r\nif (fh->width < 48 || fh->width > norm_maxw(core->tvnorm) ||\r\nfh->height < 32 || fh->height > norm_maxh(core->tvnorm))\r\nreturn -EINVAL;\r\nbuf->vb.size = (fh->width * fh->height * fh->fmt->depth) >> 3;\r\nif (0 != buf->vb.baddr && buf->vb.bsize < buf->vb.size)\r\nreturn -EINVAL;\r\nif (buf->fmt != fh->fmt ||\r\nbuf->vb.width != fh->width ||\r\nbuf->vb.height != fh->height ||\r\nbuf->vb.field != field) {\r\nbuf->fmt = fh->fmt;\r\nbuf->vb.width = fh->width;\r\nbuf->vb.height = fh->height;\r\nbuf->vb.field = field;\r\ninit_buffer = 1;\r\n}\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\ninit_buffer = 1;\r\nif (0 != (rc = videobuf_iolock(q,&buf->vb,NULL)))\r\ngoto fail;\r\n}\r\nif (init_buffer) {\r\nbuf->bpl = buf->vb.width * buf->fmt->depth >> 3;\r\nswitch (buf->vb.field) {\r\ncase V4L2_FIELD_TOP:\r\ncx88_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist, 0, UNSET,\r\nbuf->bpl, 0, buf->vb.height);\r\nbreak;\r\ncase V4L2_FIELD_BOTTOM:\r\ncx88_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist, UNSET, 0,\r\nbuf->bpl, 0, buf->vb.height);\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\ncx88_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist, 0, buf->bpl,\r\nbuf->bpl, buf->bpl,\r\nbuf->vb.height >> 1);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_TB:\r\ncx88_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist,\r\n0, buf->bpl * (buf->vb.height >> 1),\r\nbuf->bpl, 0,\r\nbuf->vb.height >> 1);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_BT:\r\ncx88_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist,\r\nbuf->bpl * (buf->vb.height >> 1), 0,\r\nbuf->bpl, 0,\r\nbuf->vb.height >> 1);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\ndprintk(2,"[%p/%d] buffer_prepare - %dx%d %dbpp \"%s\" - dma=0x%08lx\n",\r\nbuf, buf->vb.i,\r\nfh->width, fh->height, fh->fmt->depth, fh->fmt->name,\r\n(unsigned long)buf->risc.dma);\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\ncx88_free_buffer(q,buf);\r\nreturn rc;\r\n}\r\nstatic void\r\nbuffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nstruct cx88_buffer *buf = container_of(vb,struct cx88_buffer,vb);\r\nstruct cx88_buffer *prev;\r\nstruct cx8800_fh *fh = vq->priv_data;\r\nstruct cx8800_dev *dev = fh->dev;\r\nstruct cx88_core *core = dev->core;\r\nstruct cx88_dmaqueue *q = &dev->vidq;\r\nbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_IRQ1 | RISC_CNT_INC);\r\nbuf->risc.jmp[1] = cpu_to_le32(q->stopper.dma);\r\nif (!list_empty(&q->queued)) {\r\nlist_add_tail(&buf->vb.queue,&q->queued);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\ndprintk(2,"[%p/%d] buffer_queue - append to queued\n",\r\nbuf, buf->vb.i);\r\n} else if (list_empty(&q->active)) {\r\nlist_add_tail(&buf->vb.queue,&q->active);\r\nstart_video_dma(dev, q, buf);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nmod_timer(&q->timeout, jiffies+BUFFER_TIMEOUT);\r\ndprintk(2,"[%p/%d] buffer_queue - first active\n",\r\nbuf, buf->vb.i);\r\n} else {\r\nprev = list_entry(q->active.prev, struct cx88_buffer, vb.queue);\r\nif (prev->vb.width == buf->vb.width &&\r\nprev->vb.height == buf->vb.height &&\r\nprev->fmt == buf->fmt) {\r\nlist_add_tail(&buf->vb.queue,&q->active);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\r\ndprintk(2,"[%p/%d] buffer_queue - append to active\n",\r\nbuf, buf->vb.i);\r\n} else {\r\nlist_add_tail(&buf->vb.queue,&q->queued);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\ndprintk(2,"[%p/%d] buffer_queue - first queued\n",\r\nbuf, buf->vb.i);\r\n}\r\n}\r\n}\r\nstatic void buffer_release(struct videobuf_queue *q, struct videobuf_buffer *vb)\r\n{\r\nstruct cx88_buffer *buf = container_of(vb,struct cx88_buffer,vb);\r\ncx88_free_buffer(q,buf);\r\n}\r\nstatic struct videobuf_queue* get_queue(struct cx8800_fh *fh)\r\n{\r\nswitch (fh->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nreturn &fh->vidq;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nreturn &fh->vbiq;\r\ndefault:\r\nBUG();\r\nreturn NULL;\r\n}\r\n}\r\nstatic int get_ressource(struct cx8800_fh *fh)\r\n{\r\nswitch (fh->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nreturn RESOURCE_VIDEO;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nreturn RESOURCE_VBI;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nstatic int video_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nstruct cx8800_fh *fh;\r\nenum v4l2_buf_type type = 0;\r\nint radio = 0;\r\nswitch (vdev->vfl_type) {\r\ncase VFL_TYPE_GRABBER:\r\ntype = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\ntype = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nbreak;\r\ncase VFL_TYPE_RADIO:\r\nradio = 1;\r\nbreak;\r\n}\r\ndprintk(1, "open dev=%s radio=%d type=%s\n",\r\nvideo_device_node_name(vdev), radio, v4l2_type_names[type]);\r\nfh = kzalloc(sizeof(*fh),GFP_KERNEL);\r\nif (unlikely(!fh))\r\nreturn -ENOMEM;\r\nfile->private_data = fh;\r\nfh->dev = dev;\r\nfh->radio = radio;\r\nfh->type = type;\r\nfh->width = 320;\r\nfh->height = 240;\r\nfh->fmt = format_by_fourcc(V4L2_PIX_FMT_BGR24);\r\nmutex_lock(&core->lock);\r\nvideobuf_queue_sg_init(&fh->vidq, &cx8800_video_qops,\r\n&dev->pci->dev, &dev->slock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_INTERLACED,\r\nsizeof(struct cx88_buffer),\r\nfh, NULL);\r\nvideobuf_queue_sg_init(&fh->vbiq, &cx8800_vbi_qops,\r\n&dev->pci->dev, &dev->slock,\r\nV4L2_BUF_TYPE_VBI_CAPTURE,\r\nV4L2_FIELD_SEQ_TB,\r\nsizeof(struct cx88_buffer),\r\nfh, NULL);\r\nif (fh->radio) {\r\ndprintk(1,"video_open: setting radio device\n");\r\ncx_write(MO_GP3_IO, core->board.radio.gpio3);\r\ncx_write(MO_GP0_IO, core->board.radio.gpio0);\r\ncx_write(MO_GP1_IO, core->board.radio.gpio1);\r\ncx_write(MO_GP2_IO, core->board.radio.gpio2);\r\nif (core->board.radio.audioroute) {\r\nif(core->board.audio_chip &&\r\ncore->board.audio_chip == V4L2_IDENT_WM8775) {\r\ncall_all(core, audio, s_routing,\r\ncore->board.radio.audioroute, 0, 0);\r\n}\r\ncore->tvaudio = WW_I2SADC;\r\ncx88_set_tvaudio(core);\r\n} else {\r\ncore->tvaudio = WW_FM;\r\ncx88_set_tvaudio(core);\r\ncx88_set_stereo(core,V4L2_TUNER_MODE_STEREO,1);\r\n}\r\ncall_all(core, tuner, s_radio);\r\n}\r\ncore->users++;\r\nmutex_unlock(&core->lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nvideo_read(struct file *file, char __user *data, size_t count, loff_t *ppos)\r\n{\r\nstruct cx8800_fh *fh = file->private_data;\r\nswitch (fh->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nif (res_locked(fh->dev,RESOURCE_VIDEO))\r\nreturn -EBUSY;\r\nreturn videobuf_read_one(&fh->vidq, data, count, ppos,\r\nfile->f_flags & O_NONBLOCK);\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nif (!res_get(fh->dev,fh,RESOURCE_VBI))\r\nreturn -EBUSY;\r\nreturn videobuf_read_stream(&fh->vbiq, data, count, ppos, 1,\r\nfile->f_flags & O_NONBLOCK);\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nstatic unsigned int\r\nvideo_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct cx8800_fh *fh = file->private_data;\r\nstruct cx88_buffer *buf;\r\nunsigned int rc = POLLERR;\r\nif (V4L2_BUF_TYPE_VBI_CAPTURE == fh->type) {\r\nif (!res_get(fh->dev,fh,RESOURCE_VBI))\r\nreturn POLLERR;\r\nreturn videobuf_poll_stream(file, &fh->vbiq, wait);\r\n}\r\nmutex_lock(&fh->vidq.vb_lock);\r\nif (res_check(fh,RESOURCE_VIDEO)) {\r\nif (list_empty(&fh->vidq.stream))\r\ngoto done;\r\nbuf = list_entry(fh->vidq.stream.next,struct cx88_buffer,vb.stream);\r\n} else {\r\nbuf = (struct cx88_buffer*)fh->vidq.read_buf;\r\nif (NULL == buf)\r\ngoto done;\r\n}\r\npoll_wait(file, &buf->vb.done, wait);\r\nif (buf->vb.state == VIDEOBUF_DONE ||\r\nbuf->vb.state == VIDEOBUF_ERROR)\r\nrc = POLLIN|POLLRDNORM;\r\nelse\r\nrc = 0;\r\ndone:\r\nmutex_unlock(&fh->vidq.vb_lock);\r\nreturn rc;\r\n}\r\nstatic int video_release(struct file *file)\r\n{\r\nstruct cx8800_fh *fh = file->private_data;\r\nstruct cx8800_dev *dev = fh->dev;\r\nif (res_check(fh, RESOURCE_OVERLAY)) {\r\nres_free(dev,fh,RESOURCE_OVERLAY);\r\n}\r\nif (res_check(fh, RESOURCE_VIDEO)) {\r\nvideobuf_queue_cancel(&fh->vidq);\r\nres_free(dev,fh,RESOURCE_VIDEO);\r\n}\r\nif (fh->vidq.read_buf) {\r\nbuffer_release(&fh->vidq,fh->vidq.read_buf);\r\nkfree(fh->vidq.read_buf);\r\n}\r\nif (res_check(fh, RESOURCE_VBI)) {\r\nvideobuf_stop(&fh->vbiq);\r\nres_free(dev,fh,RESOURCE_VBI);\r\n}\r\nvideobuf_mmap_free(&fh->vidq);\r\nvideobuf_mmap_free(&fh->vbiq);\r\nmutex_lock(&dev->core->lock);\r\nfile->private_data = NULL;\r\nkfree(fh);\r\ndev->core->users--;\r\nif (!dev->core->users)\r\ncall_all(dev->core, core, s_power, 0);\r\nmutex_unlock(&dev->core->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nvideo_mmap(struct file *file, struct vm_area_struct * vma)\r\n{\r\nstruct cx8800_fh *fh = file->private_data;\r\nreturn videobuf_mmap_mapper(get_queue(fh), vma);\r\n}\r\nint cx88_get_control (struct cx88_core *core, struct v4l2_control *ctl)\r\n{\r\nconst struct cx88_ctrl *c = NULL;\r\nu32 value;\r\nint i;\r\nfor (i = 0; i < CX8800_CTLS; i++)\r\nif (cx8800_ctls[i].v.id == ctl->id)\r\nc = &cx8800_ctls[i];\r\nif (unlikely(NULL == c))\r\nreturn -EINVAL;\r\nvalue = c->sreg ? cx_sread(c->sreg) : cx_read(c->reg);\r\nswitch (ctl->id) {\r\ncase V4L2_CID_AUDIO_BALANCE:\r\nctl->value = ((value & 0x7f) < 0x40) ? ((value & 0x7f) + 0x40)\r\n: (0x7f - (value & 0x7f));\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nctl->value = 0x3f - (value & 0x3f);\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nctl->value = ((value & 0x0200) ? (((value & 0x0180) >> 7) + 1)\r\n: 0);\r\nbreak;\r\ndefault:\r\nctl->value = ((value + (c->off << c->shift)) & c->mask) >> c->shift;\r\nbreak;\r\n}\r\ndprintk(1,"get_control id=0x%X(%s) ctrl=0x%02x, reg=0x%02x val=0x%02x (mask 0x%02x)%s\n",\r\nctl->id, c->v.name, ctl->value, c->reg,\r\nvalue,c->mask, c->sreg ? " [shadowed]" : "");\r\nreturn 0;\r\n}\r\nint cx88_set_control(struct cx88_core *core, struct v4l2_control *ctl)\r\n{\r\nconst struct cx88_ctrl *c = NULL;\r\nu32 value,mask;\r\nint i;\r\nfor (i = 0; i < CX8800_CTLS; i++) {\r\nif (cx8800_ctls[i].v.id == ctl->id) {\r\nc = &cx8800_ctls[i];\r\n}\r\n}\r\nif (unlikely(NULL == c))\r\nreturn -EINVAL;\r\nif (ctl->value < c->v.minimum)\r\nctl->value = c->v.minimum;\r\nif (ctl->value > c->v.maximum)\r\nctl->value = c->v.maximum;\r\nif (core->board.audio_chip == V4L2_IDENT_WM8775) {\r\nstruct v4l2_control client_ctl;\r\nmemset(&client_ctl, 0, sizeof(client_ctl));\r\nclient_ctl.id = ctl->id;\r\nswitch (ctl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nclient_ctl.value = ctl->value;\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nclient_ctl.value = (ctl->value) ?\r\n(0x90 + ctl->value) << 8 : 0;\r\nbreak;\r\ncase V4L2_CID_AUDIO_BALANCE:\r\nclient_ctl.value = ctl->value << 9;\r\nbreak;\r\ndefault:\r\nclient_ctl.id = 0;\r\nbreak;\r\n}\r\nif (client_ctl.id)\r\ncall_hw(core, WM8775_GID, core, s_ctrl, &client_ctl);\r\n}\r\nmask=c->mask;\r\nswitch (ctl->id) {\r\ncase V4L2_CID_AUDIO_BALANCE:\r\nvalue = (ctl->value < 0x40) ? (0x7f - ctl->value) : (ctl->value - 0x40);\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nvalue = 0x3f - (ctl->value & 0x3f);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nvalue = ((ctl->value - c->off) << c->shift) & c->mask;\r\nif (core->tvnorm & V4L2_STD_SECAM) {\r\nvalue=value<<8|value;\r\n} else {\r\nvalue=(value*0x5a)/0x7f<<8|value;\r\n}\r\nmask=0xffff;\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nvalue = (ctl->value < 1 ? 0 : ((ctl->value + 3) << 7));\r\ncx_andor(MO_FILTER_EVEN, mask, value);\r\nbreak;\r\ncase V4L2_CID_CHROMA_AGC:\r\nvalue = ((ctl->value - c->off) << c->shift) & c->mask;\r\nif (core->tvnorm & V4L2_STD_SECAM && value)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nvalue = ((ctl->value - c->off) << c->shift) & c->mask;\r\nbreak;\r\n}\r\ndprintk(1,"set_control id=0x%X(%s) ctrl=0x%02x, reg=0x%02x val=0x%02x (mask 0x%02x)%s\n",\r\nctl->id, c->v.name, ctl->value, c->reg, value,\r\nmask, c->sreg ? " [shadowed]" : "");\r\nif (c->sreg) {\r\ncx_sandor(c->sreg, c->reg, mask, value);\r\n} else {\r\ncx_andor(c->reg, mask, value);\r\n}\r\nreturn 0;\r\n}\r\nstatic void init_controls(struct cx88_core *core)\r\n{\r\nstruct v4l2_control ctrl;\r\nint i;\r\nfor (i = 0; i < CX8800_CTLS; i++) {\r\nctrl.id=cx8800_ctls[i].v.id;\r\nctrl.value=cx8800_ctls[i].v.default_value;\r\ncx88_set_control(core, &ctrl);\r\n}\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx8800_fh *fh = priv;\r\nf->fmt.pix.width = fh->width;\r\nf->fmt.pix.height = fh->height;\r\nf->fmt.pix.field = fh->vidq.field;\r\nf->fmt.pix.pixelformat = fh->fmt->fourcc;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * fh->fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx88_core *core = ((struct cx8800_fh *)priv)->dev->core;\r\nconst struct cx8800_fmt *fmt;\r\nenum v4l2_field field;\r\nunsigned int maxw, maxh;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\nfield = f->fmt.pix.field;\r\nmaxw = norm_maxw(core->tvnorm);\r\nmaxh = norm_maxh(core->tvnorm);\r\nif (V4L2_FIELD_ANY == field) {\r\nfield = (f->fmt.pix.height > maxh/2)\r\n? V4L2_FIELD_INTERLACED\r\n: V4L2_FIELD_BOTTOM;\r\n}\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\nmaxh = maxh / 2;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nf->fmt.pix.field = field;\r\nv4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,\r\n&f->fmt.pix.height, 32, maxh, 0, 0);\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx8800_fh *fh = priv;\r\nint err = vidioc_try_fmt_vid_cap (file,priv,f);\r\nif (0 != err)\r\nreturn err;\r\nfh->fmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nfh->width = f->fmt.pix.width;\r\nfh->height = f->fmt.pix.height;\r\nfh->vidq.field = f->fmt.pix.field;\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap (struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct cx8800_dev *dev = ((struct cx8800_fh *)priv)->dev;\r\nstruct cx88_core *core = dev->core;\r\nstrcpy(cap->driver, "cx8800");\r\nstrlcpy(cap->card, core->board.name, sizeof(cap->card));\r\nsprintf(cap->bus_info,"PCI:%s",pci_name(dev->pci));\r\ncap->capabilities =\r\nV4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING |\r\nV4L2_CAP_VBI_CAPTURE;\r\nif (UNSET != core->board.tuner_type)\r\ncap->capabilities |= V4L2_CAP_TUNER;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap (struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (unlikely(f->index >= ARRAY_SIZE(formats)))\r\nreturn -EINVAL;\r\nstrlcpy(f->description,formats[f->index].name,sizeof(f->description));\r\nf->pixelformat = formats[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_reqbufs (struct file *file, void *priv, struct v4l2_requestbuffers *p)\r\n{\r\nstruct cx8800_fh *fh = priv;\r\nreturn (videobuf_reqbufs(get_queue(fh), p));\r\n}\r\nstatic int vidioc_querybuf (struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct cx8800_fh *fh = priv;\r\nreturn (videobuf_querybuf(get_queue(fh), p));\r\n}\r\nstatic int vidioc_qbuf (struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct cx8800_fh *fh = priv;\r\nreturn (videobuf_qbuf(get_queue(fh), p));\r\n}\r\nstatic int vidioc_dqbuf (struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct cx8800_fh *fh = priv;\r\nreturn (videobuf_dqbuf(get_queue(fh), p,\r\nfile->f_flags & O_NONBLOCK));\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct cx8800_fh *fh = priv;\r\nstruct cx8800_dev *dev = fh->dev;\r\nif (unlikely((fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\r\n(fh->type != V4L2_BUF_TYPE_VBI_CAPTURE)))\r\nreturn -EINVAL;\r\nif (unlikely(i != fh->type))\r\nreturn -EINVAL;\r\nif (unlikely(!res_get(dev,fh,get_ressource(fh))))\r\nreturn -EBUSY;\r\nreturn videobuf_streamon(get_queue(fh));\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct cx8800_fh *fh = priv;\r\nstruct cx8800_dev *dev = fh->dev;\r\nint err, res;\r\nif ((fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\r\n(fh->type != V4L2_BUF_TYPE_VBI_CAPTURE))\r\nreturn -EINVAL;\r\nif (i != fh->type)\r\nreturn -EINVAL;\r\nres = get_ressource(fh);\r\nerr = videobuf_streamoff(get_queue(fh));\r\nif (err < 0)\r\nreturn err;\r\nres_free(dev,fh,res);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std (struct file *file, void *priv, v4l2_std_id *tvnorms)\r\n{\r\nstruct cx88_core *core = ((struct cx8800_fh *)priv)->dev->core;\r\nmutex_lock(&core->lock);\r\ncx88_set_tvnorm(core,*tvnorms);\r\nmutex_unlock(&core->lock);\r\nreturn 0;\r\n}\r\nint cx88_enum_input (struct cx88_core *core,struct v4l2_input *i)\r\n{\r\nstatic const char * const iname[] = {\r\n[ CX88_VMUX_COMPOSITE1 ] = "Composite1",\r\n[ CX88_VMUX_COMPOSITE2 ] = "Composite2",\r\n[ CX88_VMUX_COMPOSITE3 ] = "Composite3",\r\n[ CX88_VMUX_COMPOSITE4 ] = "Composite4",\r\n[ CX88_VMUX_SVIDEO ] = "S-Video",\r\n[ CX88_VMUX_TELEVISION ] = "Television",\r\n[ CX88_VMUX_CABLE ] = "Cable TV",\r\n[ CX88_VMUX_DVB ] = "DVB",\r\n[ CX88_VMUX_DEBUG ] = "for debug only",\r\n};\r\nunsigned int n = i->index;\r\nif (n >= 4)\r\nreturn -EINVAL;\r\nif (0 == INPUT(n).type)\r\nreturn -EINVAL;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrcpy(i->name,iname[INPUT(n).type]);\r\nif ((CX88_VMUX_TELEVISION == INPUT(n).type) ||\r\n(CX88_VMUX_CABLE == INPUT(n).type)) {\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\ni->std = CX88_NORMS;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input (struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct cx88_core *core = ((struct cx8800_fh *)priv)->dev->core;\r\nreturn cx88_enum_input (core,i);\r\n}\r\nstatic int vidioc_g_input (struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct cx88_core *core = ((struct cx8800_fh *)priv)->dev->core;\r\n*i = core->input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input (struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct cx88_core *core = ((struct cx8800_fh *)priv)->dev->core;\r\nif (i >= 4)\r\nreturn -EINVAL;\r\nmutex_lock(&core->lock);\r\ncx88_newstation(core);\r\ncx88_video_mux(core,i);\r\nmutex_unlock(&core->lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl (struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qctrl)\r\n{\r\nstruct cx88_core *core = ((struct cx8800_fh *)priv)->dev->core;\r\nqctrl->id = v4l2_ctrl_next(ctrl_classes, qctrl->id);\r\nif (unlikely(qctrl->id == 0))\r\nreturn -EINVAL;\r\nreturn cx8800_ctrl_query(core, qctrl);\r\n}\r\nstatic int vidioc_g_ctrl (struct file *file, void *priv,\r\nstruct v4l2_control *ctl)\r\n{\r\nstruct cx88_core *core = ((struct cx8800_fh *)priv)->dev->core;\r\nreturn\r\ncx88_get_control(core,ctl);\r\n}\r\nstatic int vidioc_s_ctrl (struct file *file, void *priv,\r\nstruct v4l2_control *ctl)\r\n{\r\nstruct cx88_core *core = ((struct cx8800_fh *)priv)->dev->core;\r\nreturn\r\ncx88_set_control(core,ctl);\r\n}\r\nstatic int vidioc_g_tuner (struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct cx88_core *core = ((struct cx8800_fh *)priv)->dev->core;\r\nu32 reg;\r\nif (unlikely(UNSET == core->board.tuner_type))\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Television");\r\nt->type = V4L2_TUNER_ANALOG_TV;\r\nt->capability = V4L2_TUNER_CAP_NORM;\r\nt->rangehigh = 0xffffffffUL;\r\ncx88_get_stereo(core ,t);\r\nreg = cx_read(MO_DEVICE_STATUS);\r\nt->signal = (reg & (1<<5)) ? 0xffff : 0x0000;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner (struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct cx88_core *core = ((struct cx8800_fh *)priv)->dev->core;\r\nif (UNSET == core->board.tuner_type)\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\ncx88_set_stereo(core, t->audmode, 1);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency (struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cx8800_fh *fh = priv;\r\nstruct cx88_core *core = fh->dev->core;\r\nif (unlikely(UNSET == core->board.tuner_type))\r\nreturn -EINVAL;\r\nf->type = fh->radio ? V4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nf->frequency = core->freq;\r\ncall_all(core, tuner, g_frequency, f);\r\nreturn 0;\r\n}\r\nint cx88_set_freq (struct cx88_core *core,\r\nstruct v4l2_frequency *f)\r\n{\r\nif (unlikely(UNSET == core->board.tuner_type))\r\nreturn -EINVAL;\r\nif (unlikely(f->tuner != 0))\r\nreturn -EINVAL;\r\nmutex_lock(&core->lock);\r\ncore->freq = f->frequency;\r\ncx88_newstation(core);\r\ncall_all(core, tuner, s_frequency, f);\r\nmsleep (10);\r\ncx88_set_tvaudio(core);\r\nmutex_unlock(&core->lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency (struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cx8800_fh *fh = priv;\r\nstruct cx88_core *core = fh->dev->core;\r\nif (unlikely(0 == fh->radio && f->type != V4L2_TUNER_ANALOG_TV))\r\nreturn -EINVAL;\r\nif (unlikely(1 == fh->radio && f->type != V4L2_TUNER_RADIO))\r\nreturn -EINVAL;\r\nreturn\r\ncx88_set_freq (core,f);\r\n}\r\nstatic int vidioc_g_register (struct file *file, void *fh,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct cx88_core *core = ((struct cx8800_fh*)fh)->dev->core;\r\nif (!v4l2_chip_match_host(&reg->match))\r\nreturn -EINVAL;\r\nreg->val = cx_read(reg->reg & 0xffffff);\r\nreg->size = 4;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_register (struct file *file, void *fh,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct cx88_core *core = ((struct cx8800_fh*)fh)->dev->core;\r\nif (!v4l2_chip_match_host(&reg->match))\r\nreturn -EINVAL;\r\ncx_write(reg->reg & 0xffffff, reg->val);\r\nreturn 0;\r\n}\r\nstatic int radio_querycap (struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct cx8800_dev *dev = ((struct cx8800_fh *)priv)->dev;\r\nstruct cx88_core *core = dev->core;\r\nstrcpy(cap->driver, "cx8800");\r\nstrlcpy(cap->card, core->board.name, sizeof(cap->card));\r\nsprintf(cap->bus_info,"PCI:%s", pci_name(dev->pci));\r\ncap->capabilities = V4L2_CAP_TUNER;\r\nreturn 0;\r\n}\r\nstatic int radio_g_tuner (struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct cx88_core *core = ((struct cx8800_fh *)priv)->dev->core;\r\nif (unlikely(t->index > 0))\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Radio");\r\nt->type = V4L2_TUNER_RADIO;\r\ncall_all(core, tuner, g_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int radio_enum_input (struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nif (i->index != 0)\r\nreturn -EINVAL;\r\nstrcpy(i->name,"Radio");\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\nreturn 0;\r\n}\r\nstatic int radio_g_audio (struct file *file, void *priv, struct v4l2_audio *a)\r\n{\r\nif (unlikely(a->index))\r\nreturn -EINVAL;\r\nstrcpy(a->name,"Radio");\r\nreturn 0;\r\n}\r\nstatic int radio_s_tuner (struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct cx88_core *core = ((struct cx8800_fh *)priv)->dev->core;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\ncall_all(core, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int radio_s_audio (struct file *file, void *fh,\r\nstruct v4l2_audio *a)\r\n{\r\nreturn 0;\r\n}\r\nstatic int radio_s_input (struct file *file, void *fh, unsigned int i)\r\n{\r\nreturn 0;\r\n}\r\nstatic int radio_queryctrl (struct file *file, void *priv,\r\nstruct v4l2_queryctrl *c)\r\n{\r\nint i;\r\nif (c->id < V4L2_CID_BASE ||\r\nc->id >= V4L2_CID_LASTP1)\r\nreturn -EINVAL;\r\nif (c->id == V4L2_CID_AUDIO_MUTE ||\r\nc->id == V4L2_CID_AUDIO_VOLUME ||\r\nc->id == V4L2_CID_AUDIO_BALANCE) {\r\nfor (i = 0; i < CX8800_CTLS; i++) {\r\nif (cx8800_ctls[i].v.id == c->id)\r\nbreak;\r\n}\r\nif (i == CX8800_CTLS)\r\nreturn -EINVAL;\r\n*c = cx8800_ctls[i].v;\r\n} else\r\n*c = no_ctl;\r\nreturn 0;\r\n}\r\nstatic void cx8800_vid_timeout(unsigned long data)\r\n{\r\nstruct cx8800_dev *dev = (struct cx8800_dev*)data;\r\nstruct cx88_core *core = dev->core;\r\nstruct cx88_dmaqueue *q = &dev->vidq;\r\nstruct cx88_buffer *buf;\r\nunsigned long flags;\r\ncx88_sram_channel_dump(core, &cx88_sram_channels[SRAM_CH21]);\r\ncx_clear(MO_VID_DMACNTRL, 0x11);\r\ncx_clear(VID_CAPTURE_CONTROL, 0x06);\r\nspin_lock_irqsave(&dev->slock,flags);\r\nwhile (!list_empty(&q->active)) {\r\nbuf = list_entry(q->active.next, struct cx88_buffer, vb.queue);\r\nlist_del(&buf->vb.queue);\r\nbuf->vb.state = VIDEOBUF_ERROR;\r\nwake_up(&buf->vb.done);\r\nprintk("%s/0: [%p/%d] timeout - dma=0x%08lx\n", core->name,\r\nbuf, buf->vb.i, (unsigned long)buf->risc.dma);\r\n}\r\nrestart_video_queue(dev,q);\r\nspin_unlock_irqrestore(&dev->slock,flags);\r\n}\r\nstatic void cx8800_vid_irq(struct cx8800_dev *dev)\r\n{\r\nstruct cx88_core *core = dev->core;\r\nu32 status, mask, count;\r\nstatus = cx_read(MO_VID_INTSTAT);\r\nmask = cx_read(MO_VID_INTMSK);\r\nif (0 == (status & mask))\r\nreturn;\r\ncx_write(MO_VID_INTSTAT, status);\r\nif (irq_debug || (status & mask & ~0xff))\r\ncx88_print_irqbits(core->name, "irq vid",\r\ncx88_vid_irqs, ARRAY_SIZE(cx88_vid_irqs),\r\nstatus, mask);\r\nif (status & (1 << 16)) {\r\nprintk(KERN_WARNING "%s/0: video risc op code error\n",core->name);\r\ncx_clear(MO_VID_DMACNTRL, 0x11);\r\ncx_clear(VID_CAPTURE_CONTROL, 0x06);\r\ncx88_sram_channel_dump(core, &cx88_sram_channels[SRAM_CH21]);\r\n}\r\nif (status & 0x01) {\r\nspin_lock(&dev->slock);\r\ncount = cx_read(MO_VIDY_GPCNT);\r\ncx88_wakeup(core, &dev->vidq, count);\r\nspin_unlock(&dev->slock);\r\n}\r\nif (status & 0x08) {\r\nspin_lock(&dev->slock);\r\ncount = cx_read(MO_VBI_GPCNT);\r\ncx88_wakeup(core, &dev->vbiq, count);\r\nspin_unlock(&dev->slock);\r\n}\r\nif (status & 0x10) {\r\ndprintk(2,"stopper video\n");\r\nspin_lock(&dev->slock);\r\nrestart_video_queue(dev,&dev->vidq);\r\nspin_unlock(&dev->slock);\r\n}\r\nif (status & 0x80) {\r\ndprintk(2,"stopper vbi\n");\r\nspin_lock(&dev->slock);\r\ncx8800_restart_vbi_queue(dev,&dev->vbiq);\r\nspin_unlock(&dev->slock);\r\n}\r\n}\r\nstatic irqreturn_t cx8800_irq(int irq, void *dev_id)\r\n{\r\nstruct cx8800_dev *dev = dev_id;\r\nstruct cx88_core *core = dev->core;\r\nu32 status;\r\nint loop, handled = 0;\r\nfor (loop = 0; loop < 10; loop++) {\r\nstatus = cx_read(MO_PCI_INTSTAT) &\r\n(core->pci_irqmask | PCI_INT_VIDINT);\r\nif (0 == status)\r\ngoto out;\r\ncx_write(MO_PCI_INTSTAT, status);\r\nhandled = 1;\r\nif (status & core->pci_irqmask)\r\ncx88_core_irq(core,status);\r\nif (status & PCI_INT_VIDINT)\r\ncx8800_vid_irq(dev);\r\n};\r\nif (10 == loop) {\r\nprintk(KERN_WARNING "%s/0: irq loop -- clearing mask\n",\r\ncore->name);\r\ncx_write(MO_PCI_INTMSK,0);\r\n}\r\nout:\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void cx8800_unregister_video(struct cx8800_dev *dev)\r\n{\r\nif (dev->radio_dev) {\r\nif (video_is_registered(dev->radio_dev))\r\nvideo_unregister_device(dev->radio_dev);\r\nelse\r\nvideo_device_release(dev->radio_dev);\r\ndev->radio_dev = NULL;\r\n}\r\nif (dev->vbi_dev) {\r\nif (video_is_registered(dev->vbi_dev))\r\nvideo_unregister_device(dev->vbi_dev);\r\nelse\r\nvideo_device_release(dev->vbi_dev);\r\ndev->vbi_dev = NULL;\r\n}\r\nif (dev->video_dev) {\r\nif (video_is_registered(dev->video_dev))\r\nvideo_unregister_device(dev->video_dev);\r\nelse\r\nvideo_device_release(dev->video_dev);\r\ndev->video_dev = NULL;\r\n}\r\n}\r\nstatic int __devinit cx8800_initdev(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct cx8800_dev *dev;\r\nstruct cx88_core *core;\r\nint err;\r\ndev = kzalloc(sizeof(*dev),GFP_KERNEL);\r\nif (NULL == dev)\r\nreturn -ENOMEM;\r\ndev->pci = pci_dev;\r\nif (pci_enable_device(pci_dev)) {\r\nerr = -EIO;\r\ngoto fail_free;\r\n}\r\ncore = cx88_core_get(dev->pci);\r\nif (NULL == core) {\r\nerr = -EINVAL;\r\ngoto fail_free;\r\n}\r\ndev->core = core;\r\ndev->pci_rev = pci_dev->revision;\r\npci_read_config_byte(pci_dev, PCI_LATENCY_TIMER, &dev->pci_lat);\r\nprintk(KERN_INFO "%s/0: found at %s, rev: %d, irq: %d, "\r\n"latency: %d, mmio: 0x%llx\n", core->name,\r\npci_name(pci_dev), dev->pci_rev, pci_dev->irq,\r\ndev->pci_lat,(unsigned long long)pci_resource_start(pci_dev,0));\r\npci_set_master(pci_dev);\r\nif (!pci_dma_supported(pci_dev,DMA_BIT_MASK(32))) {\r\nprintk("%s/0: Oops: no 32bit PCI DMA ???\n",core->name);\r\nerr = -EIO;\r\ngoto fail_core;\r\n}\r\nmemcpy( &cx8800_vbi_template, &cx8800_video_template,\r\nsizeof(cx8800_vbi_template) );\r\nstrcpy(cx8800_vbi_template.name,"cx8800-vbi");\r\nspin_lock_init(&dev->slock);\r\ncore->tvnorm = cx8800_video_template.current_norm;\r\nINIT_LIST_HEAD(&dev->vidq.active);\r\nINIT_LIST_HEAD(&dev->vidq.queued);\r\ndev->vidq.timeout.function = cx8800_vid_timeout;\r\ndev->vidq.timeout.data = (unsigned long)dev;\r\ninit_timer(&dev->vidq.timeout);\r\ncx88_risc_stopper(dev->pci,&dev->vidq.stopper,\r\nMO_VID_DMACNTRL,0x11,0x00);\r\nINIT_LIST_HEAD(&dev->vbiq.active);\r\nINIT_LIST_HEAD(&dev->vbiq.queued);\r\ndev->vbiq.timeout.function = cx8800_vbi_timeout;\r\ndev->vbiq.timeout.data = (unsigned long)dev;\r\ninit_timer(&dev->vbiq.timeout);\r\ncx88_risc_stopper(dev->pci,&dev->vbiq.stopper,\r\nMO_VID_DMACNTRL,0x88,0x00);\r\nerr = request_irq(pci_dev->irq, cx8800_irq,\r\nIRQF_SHARED | IRQF_DISABLED, core->name, dev);\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s/0: can't get IRQ %d\n",\r\ncore->name,pci_dev->irq);\r\ngoto fail_core;\r\n}\r\ncx_set(MO_PCI_INTMSK, core->pci_irqmask);\r\nif (core->board.audio_chip == V4L2_IDENT_WM8775) {\r\nstruct i2c_board_info wm8775_info = {\r\n.type = "wm8775",\r\n.addr = 0x36 >> 1,\r\n.platform_data = &core->wm8775_data,\r\n};\r\nstruct v4l2_subdev *sd;\r\nif (core->boardnr == CX88_BOARD_HAUPPAUGE_NOVASPLUS_S1)\r\ncore->wm8775_data.is_nova_s = true;\r\nelse\r\ncore->wm8775_data.is_nova_s = false;\r\nsd = v4l2_i2c_new_subdev_board(&core->v4l2_dev, &core->i2c_adap,\r\n&wm8775_info, NULL);\r\nif (sd != NULL)\r\nsd->grp_id = WM8775_GID;\r\n}\r\nif (core->board.audio_chip == V4L2_IDENT_TVAUDIO) {\r\nv4l2_i2c_new_subdev(&core->v4l2_dev, &core->i2c_adap,\r\n"tvaudio", 0, I2C_ADDRS(0xb0 >> 1));\r\n}\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_5_GOLD:\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_7_GOLD: {\r\nstatic const struct i2c_board_info rtc_info = {\r\nI2C_BOARD_INFO("isl1208", 0x6f)\r\n};\r\nrequest_module("rtc-isl1208");\r\ncore->i2c_rtc = i2c_new_device(&core->i2c_adap, &rtc_info);\r\n}\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_5_PCI_NANO:\r\nrequest_module("ir-kbd-i2c");\r\n}\r\npci_set_drvdata(pci_dev, dev);\r\nmutex_lock(&core->lock);\r\ncx88_set_tvnorm(core, core->tvnorm);\r\ninit_controls(core);\r\ncx88_video_mux(core, 0);\r\ndev->video_dev = cx88_vdev_init(core,dev->pci,\r\n&cx8800_video_template,"video");\r\nvideo_set_drvdata(dev->video_dev, dev);\r\nerr = video_register_device(dev->video_dev,VFL_TYPE_GRABBER,\r\nvideo_nr[core->nr]);\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s/0: can't register video device\n",\r\ncore->name);\r\ngoto fail_unreg;\r\n}\r\nprintk(KERN_INFO "%s/0: registered device %s [v4l2]\n",\r\ncore->name, video_device_node_name(dev->video_dev));\r\ndev->vbi_dev = cx88_vdev_init(core,dev->pci,&cx8800_vbi_template,"vbi");\r\nvideo_set_drvdata(dev->vbi_dev, dev);\r\nerr = video_register_device(dev->vbi_dev,VFL_TYPE_VBI,\r\nvbi_nr[core->nr]);\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s/0: can't register vbi device\n",\r\ncore->name);\r\ngoto fail_unreg;\r\n}\r\nprintk(KERN_INFO "%s/0: registered device %s\n",\r\ncore->name, video_device_node_name(dev->vbi_dev));\r\nif (core->board.radio.type == CX88_RADIO) {\r\ndev->radio_dev = cx88_vdev_init(core,dev->pci,\r\n&cx8800_radio_template,"radio");\r\nvideo_set_drvdata(dev->radio_dev, dev);\r\nerr = video_register_device(dev->radio_dev,VFL_TYPE_RADIO,\r\nradio_nr[core->nr]);\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s/0: can't register radio device\n",\r\ncore->name);\r\ngoto fail_unreg;\r\n}\r\nprintk(KERN_INFO "%s/0: registered device %s\n",\r\ncore->name, video_device_node_name(dev->radio_dev));\r\n}\r\nif (core->board.tuner_type != TUNER_ABSENT) {\r\ncore->kthread = kthread_run(cx88_audio_thread, core, "cx88 tvaudio");\r\nif (IS_ERR(core->kthread)) {\r\nerr = PTR_ERR(core->kthread);\r\nprintk(KERN_ERR "%s/0: failed to create cx88 audio thread, err=%d\n",\r\ncore->name, err);\r\n}\r\n}\r\nmutex_unlock(&core->lock);\r\nreturn 0;\r\nfail_unreg:\r\ncx8800_unregister_video(dev);\r\nfree_irq(pci_dev->irq, dev);\r\nmutex_unlock(&core->lock);\r\nfail_core:\r\ncx88_core_put(core,dev->pci);\r\nfail_free:\r\nkfree(dev);\r\nreturn err;\r\n}\r\nstatic void __devexit cx8800_finidev(struct pci_dev *pci_dev)\r\n{\r\nstruct cx8800_dev *dev = pci_get_drvdata(pci_dev);\r\nstruct cx88_core *core = dev->core;\r\nif (core->kthread) {\r\nkthread_stop(core->kthread);\r\ncore->kthread = NULL;\r\n}\r\nif (core->ir)\r\ncx88_ir_stop(core);\r\ncx88_shutdown(core);\r\npci_disable_device(pci_dev);\r\nfree_irq(pci_dev->irq, dev);\r\ncx8800_unregister_video(dev);\r\npci_set_drvdata(pci_dev, NULL);\r\nbtcx_riscmem_free(dev->pci,&dev->vidq.stopper);\r\ncx88_core_put(core,dev->pci);\r\nkfree(dev);\r\n}\r\nstatic int cx8800_suspend(struct pci_dev *pci_dev, pm_message_t state)\r\n{\r\nstruct cx8800_dev *dev = pci_get_drvdata(pci_dev);\r\nstruct cx88_core *core = dev->core;\r\nspin_lock(&dev->slock);\r\nif (!list_empty(&dev->vidq.active)) {\r\nprintk("%s/0: suspend video\n", core->name);\r\nstop_video_dma(dev);\r\ndel_timer(&dev->vidq.timeout);\r\n}\r\nif (!list_empty(&dev->vbiq.active)) {\r\nprintk("%s/0: suspend vbi\n", core->name);\r\ncx8800_stop_vbi_dma(dev);\r\ndel_timer(&dev->vbiq.timeout);\r\n}\r\nspin_unlock(&dev->slock);\r\nif (core->ir)\r\ncx88_ir_stop(core);\r\ncx88_shutdown(core);\r\npci_save_state(pci_dev);\r\nif (0 != pci_set_power_state(pci_dev, pci_choose_state(pci_dev, state))) {\r\npci_disable_device(pci_dev);\r\ndev->state.disabled = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx8800_resume(struct pci_dev *pci_dev)\r\n{\r\nstruct cx8800_dev *dev = pci_get_drvdata(pci_dev);\r\nstruct cx88_core *core = dev->core;\r\nint err;\r\nif (dev->state.disabled) {\r\nerr=pci_enable_device(pci_dev);\r\nif (err) {\r\nprintk(KERN_ERR "%s/0: can't enable device\n",\r\ncore->name);\r\nreturn err;\r\n}\r\ndev->state.disabled = 0;\r\n}\r\nerr= pci_set_power_state(pci_dev, PCI_D0);\r\nif (err) {\r\nprintk(KERN_ERR "%s/0: can't set power state\n", core->name);\r\npci_disable_device(pci_dev);\r\ndev->state.disabled = 1;\r\nreturn err;\r\n}\r\npci_restore_state(pci_dev);\r\ncx88_reset(core);\r\nif (core->ir)\r\ncx88_ir_start(core);\r\ncx_set(MO_PCI_INTMSK, core->pci_irqmask);\r\nspin_lock(&dev->slock);\r\nif (!list_empty(&dev->vidq.active)) {\r\nprintk("%s/0: resume video\n", core->name);\r\nrestart_video_queue(dev,&dev->vidq);\r\n}\r\nif (!list_empty(&dev->vbiq.active)) {\r\nprintk("%s/0: resume vbi\n", core->name);\r\ncx8800_restart_vbi_queue(dev,&dev->vbiq);\r\n}\r\nspin_unlock(&dev->slock);\r\nreturn 0;\r\n}\r\nstatic int __init cx8800_init(void)\r\n{\r\nprintk(KERN_INFO "cx88/0: cx2388x v4l2 driver version %s loaded\n",\r\nCX88_VERSION);\r\nreturn pci_register_driver(&cx8800_pci_driver);\r\n}\r\nstatic void __exit cx8800_fini(void)\r\n{\r\npci_unregister_driver(&cx8800_pci_driver);\r\n}
