static int\r\nqla4xxx_read_flash(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nuint32_t offset = 0;\r\nuint32_t length = 0;\r\ndma_addr_t flash_dma;\r\nuint8_t *flash = NULL;\r\nint rval = -EINVAL;\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\ngoto leave;\r\nif (ql4xxx_reset_active(ha)) {\r\nql4_printk(KERN_ERR, ha, "%s: reset active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\nif (ha->flash_state != QLFLASH_WAITING) {\r\nql4_printk(KERN_ERR, ha, "%s: another flash operation "\r\n"active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\nha->flash_state = QLFLASH_READING;\r\noffset = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\nlength = bsg_job->reply_payload.payload_len;\r\nflash = dma_alloc_coherent(&ha->pdev->dev, length, &flash_dma,\r\nGFP_KERNEL);\r\nif (!flash) {\r\nql4_printk(KERN_ERR, ha, "%s: dma alloc failed for flash "\r\n"data\n", __func__);\r\nrval = -ENOMEM;\r\ngoto leave;\r\n}\r\nrval = qla4xxx_get_flash(ha, flash_dma, offset, length);\r\nif (rval) {\r\nql4_printk(KERN_ERR, ha, "%s: get flash failed\n", __func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\nrval = -EIO;\r\n} else {\r\nbsg_reply->reply_payload_rcv_len =\r\nsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt,\r\nflash, length);\r\nbsg_reply->result = DID_OK << 16;\r\n}\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\ndma_free_coherent(&ha->pdev->dev, length, flash, flash_dma);\r\nleave:\r\nha->flash_state = QLFLASH_WAITING;\r\nreturn rval;\r\n}\r\nstatic int\r\nqla4xxx_update_flash(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nuint32_t length = 0;\r\nuint32_t offset = 0;\r\nuint32_t options = 0;\r\ndma_addr_t flash_dma;\r\nuint8_t *flash = NULL;\r\nint rval = -EINVAL;\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\ngoto leave;\r\nif (ql4xxx_reset_active(ha)) {\r\nql4_printk(KERN_ERR, ha, "%s: reset active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\nif (ha->flash_state != QLFLASH_WAITING) {\r\nql4_printk(KERN_ERR, ha, "%s: another flash operation "\r\n"active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\nha->flash_state = QLFLASH_WRITING;\r\nlength = bsg_job->request_payload.payload_len;\r\noffset = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\noptions = bsg_req->rqst_data.h_vendor.vendor_cmd[2];\r\nflash = dma_alloc_coherent(&ha->pdev->dev, length, &flash_dma,\r\nGFP_KERNEL);\r\nif (!flash) {\r\nql4_printk(KERN_ERR, ha, "%s: dma alloc failed for flash "\r\n"data\n", __func__);\r\nrval = -ENOMEM;\r\ngoto leave;\r\n}\r\nsg_copy_to_buffer(bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, flash, length);\r\nrval = qla4xxx_set_flash(ha, flash_dma, offset, length, options);\r\nif (rval) {\r\nql4_printk(KERN_ERR, ha, "%s: set flash failed\n", __func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\nrval = -EIO;\r\n} else\r\nbsg_reply->result = DID_OK << 16;\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\ndma_free_coherent(&ha->pdev->dev, length, flash, flash_dma);\r\nleave:\r\nha->flash_state = QLFLASH_WAITING;\r\nreturn rval;\r\n}\r\nstatic int\r\nqla4xxx_get_acb_state(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nuint32_t status[MBOX_REG_COUNT];\r\nuint32_t acb_idx;\r\nuint32_t ip_idx;\r\nint rval = -EINVAL;\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\ngoto leave;\r\nif (is_qla4010(ha))\r\ngoto leave;\r\nif (ql4xxx_reset_active(ha)) {\r\nql4_printk(KERN_ERR, ha, "%s: reset active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\nif (bsg_job->reply_payload.payload_len < sizeof(status)) {\r\nql4_printk(KERN_ERR, ha, "%s: invalid payload len %d\n",\r\n__func__, bsg_job->reply_payload.payload_len);\r\nrval = -EINVAL;\r\ngoto leave;\r\n}\r\nacb_idx = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\nip_idx = bsg_req->rqst_data.h_vendor.vendor_cmd[2];\r\nrval = qla4xxx_get_ip_state(ha, acb_idx, ip_idx, status);\r\nif (rval) {\r\nql4_printk(KERN_ERR, ha, "%s: get ip state failed\n",\r\n__func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\nrval = -EIO;\r\n} else {\r\nbsg_reply->reply_payload_rcv_len =\r\nsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt,\r\nstatus, sizeof(status));\r\nbsg_reply->result = DID_OK << 16;\r\n}\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\nleave:\r\nreturn rval;\r\n}\r\nstatic int\r\nqla4xxx_read_nvram(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nuint32_t offset = 0;\r\nuint32_t len = 0;\r\nuint32_t total_len = 0;\r\ndma_addr_t nvram_dma;\r\nuint8_t *nvram = NULL;\r\nint rval = -EINVAL;\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\ngoto leave;\r\nif (!(is_qla4010(ha) || is_qla4022(ha) || is_qla4032(ha)))\r\ngoto leave;\r\nif (ql4xxx_reset_active(ha)) {\r\nql4_printk(KERN_ERR, ha, "%s: reset active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\noffset = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\nlen = bsg_job->reply_payload.payload_len;\r\ntotal_len = offset + len;\r\nif ((is_qla4010(ha) && total_len > QL4010_NVRAM_SIZE) ||\r\n((is_qla4022(ha) || is_qla4032(ha)) &&\r\ntotal_len > QL40X2_NVRAM_SIZE)) {\r\nql4_printk(KERN_ERR, ha, "%s: offset+len greater than max"\r\n" nvram size, offset=%d len=%d\n",\r\n__func__, offset, len);\r\ngoto leave;\r\n}\r\nnvram = dma_alloc_coherent(&ha->pdev->dev, len, &nvram_dma,\r\nGFP_KERNEL);\r\nif (!nvram) {\r\nql4_printk(KERN_ERR, ha, "%s: dma alloc failed for nvram "\r\n"data\n", __func__);\r\nrval = -ENOMEM;\r\ngoto leave;\r\n}\r\nrval = qla4xxx_get_nvram(ha, nvram_dma, offset, len);\r\nif (rval) {\r\nql4_printk(KERN_ERR, ha, "%s: get nvram failed\n", __func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\nrval = -EIO;\r\n} else {\r\nbsg_reply->reply_payload_rcv_len =\r\nsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt,\r\nnvram, len);\r\nbsg_reply->result = DID_OK << 16;\r\n}\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\ndma_free_coherent(&ha->pdev->dev, len, nvram, nvram_dma);\r\nleave:\r\nreturn rval;\r\n}\r\nstatic int\r\nqla4xxx_update_nvram(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nuint32_t offset = 0;\r\nuint32_t len = 0;\r\nuint32_t total_len = 0;\r\ndma_addr_t nvram_dma;\r\nuint8_t *nvram = NULL;\r\nint rval = -EINVAL;\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\ngoto leave;\r\nif (!(is_qla4010(ha) || is_qla4022(ha) || is_qla4032(ha)))\r\ngoto leave;\r\nif (ql4xxx_reset_active(ha)) {\r\nql4_printk(KERN_ERR, ha, "%s: reset active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\noffset = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\nlen = bsg_job->request_payload.payload_len;\r\ntotal_len = offset + len;\r\nif ((is_qla4010(ha) && total_len > QL4010_NVRAM_SIZE) ||\r\n((is_qla4022(ha) || is_qla4032(ha)) &&\r\ntotal_len > QL40X2_NVRAM_SIZE)) {\r\nql4_printk(KERN_ERR, ha, "%s: offset+len greater than max"\r\n" nvram size, offset=%d len=%d\n",\r\n__func__, offset, len);\r\ngoto leave;\r\n}\r\nnvram = dma_alloc_coherent(&ha->pdev->dev, len, &nvram_dma,\r\nGFP_KERNEL);\r\nif (!nvram) {\r\nql4_printk(KERN_ERR, ha, "%s: dma alloc failed for flash "\r\n"data\n", __func__);\r\nrval = -ENOMEM;\r\ngoto leave;\r\n}\r\nsg_copy_to_buffer(bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, nvram, len);\r\nrval = qla4xxx_set_nvram(ha, nvram_dma, offset, len);\r\nif (rval) {\r\nql4_printk(KERN_ERR, ha, "%s: set nvram failed\n", __func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\nrval = -EIO;\r\n} else\r\nbsg_reply->result = DID_OK << 16;\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\ndma_free_coherent(&ha->pdev->dev, len, nvram, nvram_dma);\r\nleave:\r\nreturn rval;\r\n}\r\nstatic int\r\nqla4xxx_restore_defaults(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nuint32_t region = 0;\r\nuint32_t field0 = 0;\r\nuint32_t field1 = 0;\r\nint rval = -EINVAL;\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\ngoto leave;\r\nif (is_qla4010(ha))\r\ngoto leave;\r\nif (ql4xxx_reset_active(ha)) {\r\nql4_printk(KERN_ERR, ha, "%s: reset active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\nregion = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\nfield0 = bsg_req->rqst_data.h_vendor.vendor_cmd[2];\r\nfield1 = bsg_req->rqst_data.h_vendor.vendor_cmd[3];\r\nrval = qla4xxx_restore_factory_defaults(ha, region, field0, field1);\r\nif (rval) {\r\nql4_printk(KERN_ERR, ha, "%s: set nvram failed\n", __func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\nrval = -EIO;\r\n} else\r\nbsg_reply->result = DID_OK << 16;\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\nleave:\r\nreturn rval;\r\n}\r\nstatic int\r\nqla4xxx_bsg_get_acb(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nuint32_t acb_type = 0;\r\nuint32_t len = 0;\r\ndma_addr_t acb_dma;\r\nuint8_t *acb = NULL;\r\nint rval = -EINVAL;\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\ngoto leave;\r\nif (is_qla4010(ha))\r\ngoto leave;\r\nif (ql4xxx_reset_active(ha)) {\r\nql4_printk(KERN_ERR, ha, "%s: reset active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\nacb_type = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\nlen = bsg_job->reply_payload.payload_len;\r\nif (len < sizeof(struct addr_ctrl_blk)) {\r\nql4_printk(KERN_ERR, ha, "%s: invalid acb len %d\n",\r\n__func__, len);\r\nrval = -EINVAL;\r\ngoto leave;\r\n}\r\nacb = dma_alloc_coherent(&ha->pdev->dev, len, &acb_dma, GFP_KERNEL);\r\nif (!acb) {\r\nql4_printk(KERN_ERR, ha, "%s: dma alloc failed for acb "\r\n"data\n", __func__);\r\nrval = -ENOMEM;\r\ngoto leave;\r\n}\r\nrval = qla4xxx_get_acb(ha, acb_dma, acb_type, len);\r\nif (rval) {\r\nql4_printk(KERN_ERR, ha, "%s: get acb failed\n", __func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\nrval = -EIO;\r\n} else {\r\nbsg_reply->reply_payload_rcv_len =\r\nsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt,\r\nacb, len);\r\nbsg_reply->result = DID_OK << 16;\r\n}\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\ndma_free_coherent(&ha->pdev->dev, len, acb, acb_dma);\r\nleave:\r\nreturn rval;\r\n}\r\nint qla4xxx_process_vendor_specific(struct bsg_job *bsg_job)\r\n{\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nswitch (bsg_req->rqst_data.h_vendor.vendor_cmd[0]) {\r\ncase QLISCSI_VND_READ_FLASH:\r\nreturn qla4xxx_read_flash(bsg_job);\r\ncase QLISCSI_VND_UPDATE_FLASH:\r\nreturn qla4xxx_update_flash(bsg_job);\r\ncase QLISCSI_VND_GET_ACB_STATE:\r\nreturn qla4xxx_get_acb_state(bsg_job);\r\ncase QLISCSI_VND_READ_NVRAM:\r\nreturn qla4xxx_read_nvram(bsg_job);\r\ncase QLISCSI_VND_UPDATE_NVRAM:\r\nreturn qla4xxx_update_nvram(bsg_job);\r\ncase QLISCSI_VND_RESTORE_DEFAULTS:\r\nreturn qla4xxx_restore_defaults(bsg_job);\r\ncase QLISCSI_VND_GET_ACB:\r\nreturn qla4xxx_bsg_get_acb(bsg_job);\r\ndefault:\r\nql4_printk(KERN_ERR, ha, "%s: invalid BSG vendor command: "\r\n"0x%x\n", __func__, bsg_req->msgcode);\r\nbsg_reply->result = (DID_ERROR << 16);\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\nreturn -ENOSYS;\r\n}\r\n}\r\nint qla4xxx_bsg_request(struct bsg_job *bsg_job)\r\n{\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nswitch (bsg_req->msgcode) {\r\ncase ISCSI_BSG_HST_VENDOR:\r\nreturn qla4xxx_process_vendor_specific(bsg_job);\r\ndefault:\r\nql4_printk(KERN_ERR, ha, "%s: invalid BSG command: 0x%x\n",\r\n__func__, bsg_req->msgcode);\r\n}\r\nreturn -ENOSYS;\r\n}
