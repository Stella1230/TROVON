struct agp_memory *agp_find_mem_by_key(int key)\r\n{\r\nstruct agp_memory *curr;\r\nif (agp_fe.current_controller == NULL)\r\nreturn NULL;\r\ncurr = agp_fe.current_controller->pool;\r\nwhile (curr != NULL) {\r\nif (curr->key == key)\r\nbreak;\r\ncurr = curr->next;\r\n}\r\nDBG("key=%d -> mem=%p", key, curr);\r\nreturn curr;\r\n}\r\nstatic void agp_remove_from_pool(struct agp_memory *temp)\r\n{\r\nstruct agp_memory *prev;\r\nstruct agp_memory *next;\r\nDBG("mem=%p", temp);\r\nif (agp_find_mem_by_key(temp->key) != NULL) {\r\nnext = temp->next;\r\nprev = temp->prev;\r\nif (prev != NULL) {\r\nprev->next = next;\r\nif (next != NULL)\r\nnext->prev = prev;\r\n} else {\r\nif (next != NULL)\r\nnext->prev = NULL;\r\nagp_fe.current_controller->pool = next;\r\n}\r\n}\r\n}\r\nstatic struct\r\nagp_segment_priv *agp_find_seg_in_client(const struct agp_client *client,\r\nunsigned long offset,\r\nint size, pgprot_t page_prot)\r\n{\r\nstruct agp_segment_priv *seg;\r\nint num_segments, i;\r\noff_t pg_start;\r\nsize_t pg_count;\r\npg_start = offset / 4096;\r\npg_count = size / 4096;\r\nseg = *(client->segments);\r\nnum_segments = client->num_segments;\r\nfor (i = 0; i < client->num_segments; i++) {\r\nif ((seg[i].pg_start == pg_start) &&\r\n(seg[i].pg_count == pg_count) &&\r\n(pgprot_val(seg[i].prot) == pgprot_val(page_prot))) {\r\nreturn seg + i;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void agp_remove_seg_from_client(struct agp_client *client)\r\n{\r\nDBG("client=%p", client);\r\nif (client->segments != NULL) {\r\nif (*(client->segments) != NULL) {\r\nDBG("Freeing %p from client %p", *(client->segments), client);\r\nkfree(*(client->segments));\r\n}\r\nDBG("Freeing %p from client %p", client->segments, client);\r\nkfree(client->segments);\r\nclient->segments = NULL;\r\n}\r\n}\r\nstatic void agp_add_seg_to_client(struct agp_client *client,\r\nstruct agp_segment_priv ** seg, int num_segments)\r\n{\r\nstruct agp_segment_priv **prev_seg;\r\nprev_seg = client->segments;\r\nif (prev_seg != NULL)\r\nagp_remove_seg_from_client(client);\r\nDBG("Adding seg %p (%d segments) to client %p", seg, num_segments, client);\r\nclient->num_segments = num_segments;\r\nclient->segments = seg;\r\n}\r\nstatic pgprot_t agp_convert_mmap_flags(int prot)\r\n{\r\nunsigned long prot_bits;\r\nprot_bits = calc_vm_prot_bits(prot) | VM_SHARED;\r\nreturn vm_get_page_prot(prot_bits);\r\n}\r\nint agp_create_segment(struct agp_client *client, struct agp_region *region)\r\n{\r\nstruct agp_segment_priv **ret_seg;\r\nstruct agp_segment_priv *seg;\r\nstruct agp_segment *user_seg;\r\nsize_t i;\r\nseg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);\r\nif (seg == NULL) {\r\nkfree(region->seg_list);\r\nregion->seg_list = NULL;\r\nreturn -ENOMEM;\r\n}\r\nuser_seg = region->seg_list;\r\nfor (i = 0; i < region->seg_count; i++) {\r\nseg[i].pg_start = user_seg[i].pg_start;\r\nseg[i].pg_count = user_seg[i].pg_count;\r\nseg[i].prot = agp_convert_mmap_flags(user_seg[i].prot);\r\n}\r\nkfree(region->seg_list);\r\nregion->seg_list = NULL;\r\nret_seg = kmalloc(sizeof(void *), GFP_KERNEL);\r\nif (ret_seg == NULL) {\r\nkfree(seg);\r\nreturn -ENOMEM;\r\n}\r\n*ret_seg = seg;\r\nagp_add_seg_to_client(client, ret_seg, region->seg_count);\r\nreturn 0;\r\n}\r\nstatic void agp_insert_into_pool(struct agp_memory * temp)\r\n{\r\nstruct agp_memory *prev;\r\nprev = agp_fe.current_controller->pool;\r\nif (prev != NULL) {\r\nprev->prev = temp;\r\ntemp->next = prev;\r\n}\r\nagp_fe.current_controller->pool = temp;\r\n}\r\nstruct agp_file_private *agp_find_private(pid_t pid)\r\n{\r\nstruct agp_file_private *curr;\r\ncurr = agp_fe.file_priv_list;\r\nwhile (curr != NULL) {\r\nif (curr->my_pid == pid)\r\nreturn curr;\r\ncurr = curr->next;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void agp_insert_file_private(struct agp_file_private * priv)\r\n{\r\nstruct agp_file_private *prev;\r\nprev = agp_fe.file_priv_list;\r\nif (prev != NULL)\r\nprev->prev = priv;\r\npriv->next = prev;\r\nagp_fe.file_priv_list = priv;\r\n}\r\nstatic void agp_remove_file_private(struct agp_file_private * priv)\r\n{\r\nstruct agp_file_private *next;\r\nstruct agp_file_private *prev;\r\nnext = priv->next;\r\nprev = priv->prev;\r\nif (prev != NULL) {\r\nprev->next = next;\r\nif (next != NULL)\r\nnext->prev = prev;\r\n} else {\r\nif (next != NULL)\r\nnext->prev = NULL;\r\nagp_fe.file_priv_list = next;\r\n}\r\n}\r\nvoid agp_free_memory_wrap(struct agp_memory *memory)\r\n{\r\nagp_remove_from_pool(memory);\r\nagp_free_memory(memory);\r\n}\r\nstruct agp_memory *agp_allocate_memory_wrap(size_t pg_count, u32 type)\r\n{\r\nstruct agp_memory *memory;\r\nmemory = agp_allocate_memory(agp_bridge, pg_count, type);\r\nif (memory == NULL)\r\nreturn NULL;\r\nagp_insert_into_pool(memory);\r\nreturn memory;\r\n}\r\nstatic struct agp_controller *agp_find_controller_by_pid(pid_t id)\r\n{\r\nstruct agp_controller *controller;\r\ncontroller = agp_fe.controllers;\r\nwhile (controller != NULL) {\r\nif (controller->pid == id)\r\nreturn controller;\r\ncontroller = controller->next;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct agp_controller *agp_create_controller(pid_t id)\r\n{\r\nstruct agp_controller *controller;\r\ncontroller = kzalloc(sizeof(struct agp_controller), GFP_KERNEL);\r\nif (controller == NULL)\r\nreturn NULL;\r\ncontroller->pid = id;\r\nreturn controller;\r\n}\r\nstatic int agp_insert_controller(struct agp_controller *controller)\r\n{\r\nstruct agp_controller *prev_controller;\r\nprev_controller = agp_fe.controllers;\r\ncontroller->next = prev_controller;\r\nif (prev_controller != NULL)\r\nprev_controller->prev = controller;\r\nagp_fe.controllers = controller;\r\nreturn 0;\r\n}\r\nstatic void agp_remove_all_clients(struct agp_controller *controller)\r\n{\r\nstruct agp_client *client;\r\nstruct agp_client *temp;\r\nclient = controller->clients;\r\nwhile (client) {\r\nstruct agp_file_private *priv;\r\ntemp = client;\r\nagp_remove_seg_from_client(temp);\r\npriv = agp_find_private(temp->pid);\r\nif (priv != NULL) {\r\nclear_bit(AGP_FF_IS_VALID, &priv->access_flags);\r\nclear_bit(AGP_FF_IS_CLIENT, &priv->access_flags);\r\n}\r\nclient = client->next;\r\nkfree(temp);\r\n}\r\n}\r\nstatic void agp_remove_all_memory(struct agp_controller *controller)\r\n{\r\nstruct agp_memory *memory;\r\nstruct agp_memory *temp;\r\nmemory = controller->pool;\r\nwhile (memory) {\r\ntemp = memory;\r\nmemory = memory->next;\r\nagp_free_memory_wrap(temp);\r\n}\r\n}\r\nstatic int agp_remove_controller(struct agp_controller *controller)\r\n{\r\nstruct agp_controller *prev_controller;\r\nstruct agp_controller *next_controller;\r\nprev_controller = controller->prev;\r\nnext_controller = controller->next;\r\nif (prev_controller != NULL) {\r\nprev_controller->next = next_controller;\r\nif (next_controller != NULL)\r\nnext_controller->prev = prev_controller;\r\n} else {\r\nif (next_controller != NULL)\r\nnext_controller->prev = NULL;\r\nagp_fe.controllers = next_controller;\r\n}\r\nagp_remove_all_memory(controller);\r\nagp_remove_all_clients(controller);\r\nif (agp_fe.current_controller == controller) {\r\nagp_fe.current_controller = NULL;\r\nagp_fe.backend_acquired = false;\r\nagp_backend_release(agp_bridge);\r\n}\r\nkfree(controller);\r\nreturn 0;\r\n}\r\nstatic void agp_controller_make_current(struct agp_controller *controller)\r\n{\r\nstruct agp_client *clients;\r\nclients = controller->clients;\r\nwhile (clients != NULL) {\r\nstruct agp_file_private *priv;\r\npriv = agp_find_private(clients->pid);\r\nif (priv != NULL) {\r\nset_bit(AGP_FF_IS_VALID, &priv->access_flags);\r\nset_bit(AGP_FF_IS_CLIENT, &priv->access_flags);\r\n}\r\nclients = clients->next;\r\n}\r\nagp_fe.current_controller = controller;\r\n}\r\nstatic void agp_controller_release_current(struct agp_controller *controller,\r\nstruct agp_file_private *controller_priv)\r\n{\r\nstruct agp_client *clients;\r\nclear_bit(AGP_FF_IS_VALID, &controller_priv->access_flags);\r\nclients = controller->clients;\r\nwhile (clients != NULL) {\r\nstruct agp_file_private *priv;\r\npriv = agp_find_private(clients->pid);\r\nif (priv != NULL)\r\nclear_bit(AGP_FF_IS_VALID, &priv->access_flags);\r\nclients = clients->next;\r\n}\r\nagp_fe.current_controller = NULL;\r\nagp_fe.used_by_controller = false;\r\nagp_backend_release(agp_bridge);\r\n}\r\nstatic struct agp_client\r\n*agp_find_client_in_controller(struct agp_controller *controller, pid_t id)\r\n{\r\nstruct agp_client *client;\r\nif (controller == NULL)\r\nreturn NULL;\r\nclient = controller->clients;\r\nwhile (client != NULL) {\r\nif (client->pid == id)\r\nreturn client;\r\nclient = client->next;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct agp_controller *agp_find_controller_for_client(pid_t id)\r\n{\r\nstruct agp_controller *controller;\r\ncontroller = agp_fe.controllers;\r\nwhile (controller != NULL) {\r\nif ((agp_find_client_in_controller(controller, id)) != NULL)\r\nreturn controller;\r\ncontroller = controller->next;\r\n}\r\nreturn NULL;\r\n}\r\nstruct agp_client *agp_find_client_by_pid(pid_t id)\r\n{\r\nstruct agp_client *temp;\r\nif (agp_fe.current_controller == NULL)\r\nreturn NULL;\r\ntemp = agp_find_client_in_controller(agp_fe.current_controller, id);\r\nreturn temp;\r\n}\r\nstatic void agp_insert_client(struct agp_client *client)\r\n{\r\nstruct agp_client *prev_client;\r\nprev_client = agp_fe.current_controller->clients;\r\nclient->next = prev_client;\r\nif (prev_client != NULL)\r\nprev_client->prev = client;\r\nagp_fe.current_controller->clients = client;\r\nagp_fe.current_controller->num_clients++;\r\n}\r\nstruct agp_client *agp_create_client(pid_t id)\r\n{\r\nstruct agp_client *new_client;\r\nnew_client = kzalloc(sizeof(struct agp_client), GFP_KERNEL);\r\nif (new_client == NULL)\r\nreturn NULL;\r\nnew_client->pid = id;\r\nagp_insert_client(new_client);\r\nreturn new_client;\r\n}\r\nint agp_remove_client(pid_t id)\r\n{\r\nstruct agp_client *client;\r\nstruct agp_client *prev_client;\r\nstruct agp_client *next_client;\r\nstruct agp_controller *controller;\r\ncontroller = agp_find_controller_for_client(id);\r\nif (controller == NULL)\r\nreturn -EINVAL;\r\nclient = agp_find_client_in_controller(controller, id);\r\nif (client == NULL)\r\nreturn -EINVAL;\r\nprev_client = client->prev;\r\nnext_client = client->next;\r\nif (prev_client != NULL) {\r\nprev_client->next = next_client;\r\nif (next_client != NULL)\r\nnext_client->prev = prev_client;\r\n} else {\r\nif (next_client != NULL)\r\nnext_client->prev = NULL;\r\ncontroller->clients = next_client;\r\n}\r\ncontroller->num_clients--;\r\nagp_remove_seg_from_client(client);\r\nkfree(client);\r\nreturn 0;\r\n}\r\nstatic int agp_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nunsigned int size, current_size;\r\nunsigned long offset;\r\nstruct agp_client *client;\r\nstruct agp_file_private *priv = file->private_data;\r\nstruct agp_kern_info kerninfo;\r\nmutex_lock(&(agp_fe.agp_mutex));\r\nif (agp_fe.backend_acquired != true)\r\ngoto out_eperm;\r\nif (!(test_bit(AGP_FF_IS_VALID, &priv->access_flags)))\r\ngoto out_eperm;\r\nagp_copy_info(agp_bridge, &kerninfo);\r\nsize = vma->vm_end - vma->vm_start;\r\ncurrent_size = kerninfo.aper_size;\r\ncurrent_size = current_size * 0x100000;\r\noffset = vma->vm_pgoff << PAGE_SHIFT;\r\nDBG("%lx:%lx", offset, offset+size);\r\nif (test_bit(AGP_FF_IS_CLIENT, &priv->access_flags)) {\r\nif ((size + offset) > current_size)\r\ngoto out_inval;\r\nclient = agp_find_client_by_pid(current->pid);\r\nif (client == NULL)\r\ngoto out_eperm;\r\nif (!agp_find_seg_in_client(client, offset, size, vma->vm_page_prot))\r\ngoto out_inval;\r\nDBG("client vm_ops=%p", kerninfo.vm_ops);\r\nif (kerninfo.vm_ops) {\r\nvma->vm_ops = kerninfo.vm_ops;\r\n} else if (io_remap_pfn_range(vma, vma->vm_start,\r\n(kerninfo.aper_base + offset) >> PAGE_SHIFT,\r\nsize, vma->vm_page_prot)) {\r\ngoto out_again;\r\n}\r\nmutex_unlock(&(agp_fe.agp_mutex));\r\nreturn 0;\r\n}\r\nif (test_bit(AGP_FF_IS_CONTROLLER, &priv->access_flags)) {\r\nif (size != current_size)\r\ngoto out_inval;\r\nDBG("controller vm_ops=%p", kerninfo.vm_ops);\r\nif (kerninfo.vm_ops) {\r\nvma->vm_ops = kerninfo.vm_ops;\r\n} else if (io_remap_pfn_range(vma, vma->vm_start,\r\nkerninfo.aper_base >> PAGE_SHIFT,\r\nsize, vma->vm_page_prot)) {\r\ngoto out_again;\r\n}\r\nmutex_unlock(&(agp_fe.agp_mutex));\r\nreturn 0;\r\n}\r\nout_eperm:\r\nmutex_unlock(&(agp_fe.agp_mutex));\r\nreturn -EPERM;\r\nout_inval:\r\nmutex_unlock(&(agp_fe.agp_mutex));\r\nreturn -EINVAL;\r\nout_again:\r\nmutex_unlock(&(agp_fe.agp_mutex));\r\nreturn -EAGAIN;\r\n}\r\nstatic int agp_release(struct inode *inode, struct file *file)\r\n{\r\nstruct agp_file_private *priv = file->private_data;\r\nmutex_lock(&(agp_fe.agp_mutex));\r\nDBG("priv=%p", priv);\r\nif (test_bit(AGP_FF_IS_CONTROLLER, &priv->access_flags)) {\r\nstruct agp_controller *controller;\r\ncontroller = agp_find_controller_by_pid(priv->my_pid);\r\nif (controller != NULL) {\r\nif (controller == agp_fe.current_controller)\r\nagp_controller_release_current(controller, priv);\r\nagp_remove_controller(controller);\r\ncontroller = NULL;\r\n}\r\n}\r\nif (test_bit(AGP_FF_IS_CLIENT, &priv->access_flags))\r\nagp_remove_client(priv->my_pid);\r\nagp_remove_file_private(priv);\r\nkfree(priv);\r\nfile->private_data = NULL;\r\nmutex_unlock(&(agp_fe.agp_mutex));\r\nreturn 0;\r\n}\r\nstatic int agp_open(struct inode *inode, struct file *file)\r\n{\r\nint minor = iminor(inode);\r\nstruct agp_file_private *priv;\r\nstruct agp_client *client;\r\nif (minor != AGPGART_MINOR)\r\nreturn -ENXIO;\r\nmutex_lock(&(agp_fe.agp_mutex));\r\npriv = kzalloc(sizeof(struct agp_file_private), GFP_KERNEL);\r\nif (priv == NULL) {\r\nmutex_unlock(&(agp_fe.agp_mutex));\r\nreturn -ENOMEM;\r\n}\r\nset_bit(AGP_FF_ALLOW_CLIENT, &priv->access_flags);\r\npriv->my_pid = current->pid;\r\nif (capable(CAP_SYS_RAWIO))\r\nset_bit(AGP_FF_ALLOW_CONTROLLER, &priv->access_flags);\r\nclient = agp_find_client_by_pid(current->pid);\r\nif (client != NULL) {\r\nset_bit(AGP_FF_IS_CLIENT, &priv->access_flags);\r\nset_bit(AGP_FF_IS_VALID, &priv->access_flags);\r\n}\r\nfile->private_data = (void *) priv;\r\nagp_insert_file_private(priv);\r\nDBG("private=%p, client=%p", priv, client);\r\nmutex_unlock(&(agp_fe.agp_mutex));\r\nreturn 0;\r\n}\r\nstatic ssize_t agp_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t * ppos)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t agp_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t * ppos)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int agpioc_info_wrap(struct agp_file_private *priv, void __user *arg)\r\n{\r\nstruct agp_info userinfo;\r\nstruct agp_kern_info kerninfo;\r\nagp_copy_info(agp_bridge, &kerninfo);\r\nuserinfo.version.major = kerninfo.version.major;\r\nuserinfo.version.minor = kerninfo.version.minor;\r\nuserinfo.bridge_id = kerninfo.device->vendor |\r\n(kerninfo.device->device << 16);\r\nuserinfo.agp_mode = kerninfo.mode;\r\nuserinfo.aper_base = kerninfo.aper_base;\r\nuserinfo.aper_size = kerninfo.aper_size;\r\nuserinfo.pg_total = userinfo.pg_system = kerninfo.max_memory;\r\nuserinfo.pg_used = kerninfo.current_memory;\r\nif (copy_to_user(arg, &userinfo, sizeof(struct agp_info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint agpioc_acquire_wrap(struct agp_file_private *priv)\r\n{\r\nstruct agp_controller *controller;\r\nDBG("");\r\nif (!(test_bit(AGP_FF_ALLOW_CONTROLLER, &priv->access_flags)))\r\nreturn -EPERM;\r\nif (agp_fe.current_controller != NULL)\r\nreturn -EBUSY;\r\nif (!agp_bridge)\r\nreturn -ENODEV;\r\nif (atomic_read(&agp_bridge->agp_in_use))\r\nreturn -EBUSY;\r\natomic_inc(&agp_bridge->agp_in_use);\r\nagp_fe.backend_acquired = true;\r\ncontroller = agp_find_controller_by_pid(priv->my_pid);\r\nif (controller != NULL) {\r\nagp_controller_make_current(controller);\r\n} else {\r\ncontroller = agp_create_controller(priv->my_pid);\r\nif (controller == NULL) {\r\nagp_fe.backend_acquired = false;\r\nagp_backend_release(agp_bridge);\r\nreturn -ENOMEM;\r\n}\r\nagp_insert_controller(controller);\r\nagp_controller_make_current(controller);\r\n}\r\nset_bit(AGP_FF_IS_CONTROLLER, &priv->access_flags);\r\nset_bit(AGP_FF_IS_VALID, &priv->access_flags);\r\nreturn 0;\r\n}\r\nint agpioc_release_wrap(struct agp_file_private *priv)\r\n{\r\nDBG("");\r\nagp_controller_release_current(agp_fe.current_controller, priv);\r\nreturn 0;\r\n}\r\nint agpioc_setup_wrap(struct agp_file_private *priv, void __user *arg)\r\n{\r\nstruct agp_setup mode;\r\nDBG("");\r\nif (copy_from_user(&mode, arg, sizeof(struct agp_setup)))\r\nreturn -EFAULT;\r\nagp_enable(agp_bridge, mode.agp_mode);\r\nreturn 0;\r\n}\r\nstatic int agpioc_reserve_wrap(struct agp_file_private *priv, void __user *arg)\r\n{\r\nstruct agp_region reserve;\r\nstruct agp_client *client;\r\nstruct agp_file_private *client_priv;\r\nDBG("");\r\nif (copy_from_user(&reserve, arg, sizeof(struct agp_region)))\r\nreturn -EFAULT;\r\nif ((unsigned) reserve.seg_count >= ~0U/sizeof(struct agp_segment))\r\nreturn -EFAULT;\r\nclient = agp_find_client_by_pid(reserve.pid);\r\nif (reserve.seg_count == 0) {\r\nclient_priv = agp_find_private(reserve.pid);\r\nif (client_priv != NULL) {\r\nset_bit(AGP_FF_IS_CLIENT, &client_priv->access_flags);\r\nset_bit(AGP_FF_IS_VALID, &client_priv->access_flags);\r\n}\r\nif (client == NULL) {\r\nreturn 0;\r\n}\r\nreturn agp_remove_client(reserve.pid);\r\n} else {\r\nstruct agp_segment *segment;\r\nif (reserve.seg_count >= 16384)\r\nreturn -EINVAL;\r\nsegment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),\r\nGFP_KERNEL);\r\nif (segment == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(segment, (void __user *) reserve.seg_list,\r\nsizeof(struct agp_segment) * reserve.seg_count)) {\r\nkfree(segment);\r\nreturn -EFAULT;\r\n}\r\nreserve.seg_list = segment;\r\nif (client == NULL) {\r\nclient = agp_create_client(reserve.pid);\r\nif (client == NULL) {\r\nkfree(segment);\r\nreturn -ENOMEM;\r\n}\r\nclient_priv = agp_find_private(reserve.pid);\r\nif (client_priv != NULL) {\r\nset_bit(AGP_FF_IS_CLIENT, &client_priv->access_flags);\r\nset_bit(AGP_FF_IS_VALID, &client_priv->access_flags);\r\n}\r\n}\r\nreturn agp_create_segment(client, &reserve);\r\n}\r\nreturn -EINVAL;\r\n}\r\nint agpioc_protect_wrap(struct agp_file_private *priv)\r\n{\r\nDBG("");\r\nreturn -EINVAL;\r\n}\r\nstatic int agpioc_allocate_wrap(struct agp_file_private *priv, void __user *arg)\r\n{\r\nstruct agp_memory *memory;\r\nstruct agp_allocate alloc;\r\nDBG("");\r\nif (copy_from_user(&alloc, arg, sizeof(struct agp_allocate)))\r\nreturn -EFAULT;\r\nif (alloc.type >= AGP_USER_TYPES)\r\nreturn -EINVAL;\r\nmemory = agp_allocate_memory_wrap(alloc.pg_count, alloc.type);\r\nif (memory == NULL)\r\nreturn -ENOMEM;\r\nalloc.key = memory->key;\r\nalloc.physical = memory->physical;\r\nif (copy_to_user(arg, &alloc, sizeof(struct agp_allocate))) {\r\nagp_free_memory_wrap(memory);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nint agpioc_deallocate_wrap(struct agp_file_private *priv, int arg)\r\n{\r\nstruct agp_memory *memory;\r\nDBG("");\r\nmemory = agp_find_mem_by_key(arg);\r\nif (memory == NULL)\r\nreturn -EINVAL;\r\nagp_free_memory_wrap(memory);\r\nreturn 0;\r\n}\r\nstatic int agpioc_bind_wrap(struct agp_file_private *priv, void __user *arg)\r\n{\r\nstruct agp_bind bind_info;\r\nstruct agp_memory *memory;\r\nDBG("");\r\nif (copy_from_user(&bind_info, arg, sizeof(struct agp_bind)))\r\nreturn -EFAULT;\r\nmemory = agp_find_mem_by_key(bind_info.key);\r\nif (memory == NULL)\r\nreturn -EINVAL;\r\nreturn agp_bind_memory(memory, bind_info.pg_start);\r\n}\r\nstatic int agpioc_unbind_wrap(struct agp_file_private *priv, void __user *arg)\r\n{\r\nstruct agp_memory *memory;\r\nstruct agp_unbind unbind;\r\nDBG("");\r\nif (copy_from_user(&unbind, arg, sizeof(struct agp_unbind)))\r\nreturn -EFAULT;\r\nmemory = agp_find_mem_by_key(unbind.key);\r\nif (memory == NULL)\r\nreturn -EINVAL;\r\nreturn agp_unbind_memory(memory);\r\n}\r\nstatic long agp_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct agp_file_private *curr_priv = file->private_data;\r\nint ret_val = -ENOTTY;\r\nDBG("priv=%p, cmd=%x", curr_priv, cmd);\r\nmutex_lock(&(agp_fe.agp_mutex));\r\nif ((agp_fe.current_controller == NULL) &&\r\n(cmd != AGPIOC_ACQUIRE)) {\r\nret_val = -EINVAL;\r\ngoto ioctl_out;\r\n}\r\nif ((agp_fe.backend_acquired != true) &&\r\n(cmd != AGPIOC_ACQUIRE)) {\r\nret_val = -EBUSY;\r\ngoto ioctl_out;\r\n}\r\nif (cmd != AGPIOC_ACQUIRE) {\r\nif (!(test_bit(AGP_FF_IS_CONTROLLER, &curr_priv->access_flags))) {\r\nret_val = -EPERM;\r\ngoto ioctl_out;\r\n}\r\nif (agp_fe.current_controller->pid != curr_priv->my_pid) {\r\nret_val = -EBUSY;\r\ngoto ioctl_out;\r\n}\r\n}\r\nswitch (cmd) {\r\ncase AGPIOC_INFO:\r\nret_val = agpioc_info_wrap(curr_priv, (void __user *) arg);\r\nbreak;\r\ncase AGPIOC_ACQUIRE:\r\nret_val = agpioc_acquire_wrap(curr_priv);\r\nbreak;\r\ncase AGPIOC_RELEASE:\r\nret_val = agpioc_release_wrap(curr_priv);\r\nbreak;\r\ncase AGPIOC_SETUP:\r\nret_val = agpioc_setup_wrap(curr_priv, (void __user *) arg);\r\nbreak;\r\ncase AGPIOC_RESERVE:\r\nret_val = agpioc_reserve_wrap(curr_priv, (void __user *) arg);\r\nbreak;\r\ncase AGPIOC_PROTECT:\r\nret_val = agpioc_protect_wrap(curr_priv);\r\nbreak;\r\ncase AGPIOC_ALLOCATE:\r\nret_val = agpioc_allocate_wrap(curr_priv, (void __user *) arg);\r\nbreak;\r\ncase AGPIOC_DEALLOCATE:\r\nret_val = agpioc_deallocate_wrap(curr_priv, (int) arg);\r\nbreak;\r\ncase AGPIOC_BIND:\r\nret_val = agpioc_bind_wrap(curr_priv, (void __user *) arg);\r\nbreak;\r\ncase AGPIOC_UNBIND:\r\nret_val = agpioc_unbind_wrap(curr_priv, (void __user *) arg);\r\nbreak;\r\ncase AGPIOC_CHIPSET_FLUSH:\r\nbreak;\r\n}\r\nioctl_out:\r\nDBG("ioctl returns %d\n", ret_val);\r\nmutex_unlock(&(agp_fe.agp_mutex));\r\nreturn ret_val;\r\n}\r\nint agp_frontend_initialize(void)\r\n{\r\nmemset(&agp_fe, 0, sizeof(struct agp_front_data));\r\nmutex_init(&(agp_fe.agp_mutex));\r\nif (misc_register(&agp_miscdev)) {\r\nprintk(KERN_ERR PFX "unable to get minor: %d\n", AGPGART_MINOR);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nvoid agp_frontend_cleanup(void)\r\n{\r\nmisc_deregister(&agp_miscdev);\r\n}
