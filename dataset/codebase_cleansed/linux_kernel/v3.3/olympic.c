static int __devinit olympic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev ;\r\nstruct olympic_private *olympic_priv;\r\nstatic int card_no = -1 ;\r\nint i ;\r\ncard_no++ ;\r\nif ((i = pci_enable_device(pdev))) {\r\nreturn i ;\r\n}\r\npci_set_master(pdev);\r\nif ((i = pci_request_regions(pdev,"olympic"))) {\r\ngoto op_disable_dev;\r\n}\r\ndev = alloc_trdev(sizeof(struct olympic_private)) ;\r\nif (!dev) {\r\ni = -ENOMEM;\r\ngoto op_release_dev;\r\n}\r\nolympic_priv = netdev_priv(dev) ;\r\nspin_lock_init(&olympic_priv->olympic_lock) ;\r\ninit_waitqueue_head(&olympic_priv->srb_wait);\r\ninit_waitqueue_head(&olympic_priv->trb_wait);\r\n#if OLYMPIC_DEBUG\r\nprintk(KERN_INFO "pci_device: %p, dev:%p, dev->priv: %p\n", pdev, dev, netdev_priv(dev));\r\n#endif\r\ndev->irq=pdev->irq;\r\ndev->base_addr=pci_resource_start(pdev, 0);\r\nolympic_priv->olympic_card_name = pci_name(pdev);\r\nolympic_priv->pdev = pdev;\r\nolympic_priv->olympic_mmio = ioremap(pci_resource_start(pdev,1),256);\r\nolympic_priv->olympic_lap = ioremap(pci_resource_start(pdev,2),2048);\r\nif (!olympic_priv->olympic_mmio || !olympic_priv->olympic_lap) {\r\ngoto op_free_iomap;\r\n}\r\nif ((pkt_buf_sz[card_no] < 100) || (pkt_buf_sz[card_no] > 18000) )\r\nolympic_priv->pkt_buf_sz = PKT_BUF_SZ ;\r\nelse\r\nolympic_priv->pkt_buf_sz = pkt_buf_sz[card_no] ;\r\ndev->mtu = olympic_priv->pkt_buf_sz - TR_HLEN ;\r\nolympic_priv->olympic_ring_speed = ringspeed[card_no] ;\r\nolympic_priv->olympic_message_level = message_level[card_no] ;\r\nolympic_priv->olympic_network_monitor = network_monitor[card_no];\r\nif ((i = olympic_init(dev))) {\r\ngoto op_free_iomap;\r\n}\r\ndev->netdev_ops = &olympic_netdev_ops;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\npci_set_drvdata(pdev,dev) ;\r\nregister_netdev(dev) ;\r\nprintk("Olympic: %s registered as: %s\n",olympic_priv->olympic_card_name,dev->name);\r\nif (olympic_priv->olympic_network_monitor) {\r\nchar proc_name[20] ;\r\nstrcpy(proc_name,"olympic_") ;\r\nstrcat(proc_name,dev->name) ;\r\nproc_create_data(proc_name, 0, init_net.proc_net, &olympic_proc_ops, dev);\r\nprintk("Olympic: Network Monitor information: /proc/%s\n",proc_name);\r\n}\r\nreturn 0 ;\r\nop_free_iomap:\r\nif (olympic_priv->olympic_mmio)\r\niounmap(olympic_priv->olympic_mmio);\r\nif (olympic_priv->olympic_lap)\r\niounmap(olympic_priv->olympic_lap);\r\nfree_netdev(dev);\r\nop_release_dev:\r\npci_release_regions(pdev);\r\nop_disable_dev:\r\npci_disable_device(pdev);\r\nreturn i;\r\n}\r\nstatic int olympic_init(struct net_device *dev)\r\n{\r\nstruct olympic_private *olympic_priv;\r\nu8 __iomem *olympic_mmio, *init_srb,*adapter_addr;\r\nunsigned long t;\r\nunsigned int uaa_addr;\r\nolympic_priv=netdev_priv(dev);\r\nolympic_mmio=olympic_priv->olympic_mmio;\r\nprintk("%s\n", version);\r\nprintk("%s. I/O at %hx, MMIO at %p, LAP at %p, using irq %d\n", olympic_priv->olympic_card_name, (unsigned int) dev->base_addr,olympic_priv->olympic_mmio, olympic_priv->olympic_lap, dev->irq);\r\nwritel(readl(olympic_mmio+BCTL) | BCTL_SOFTRESET,olympic_mmio+BCTL);\r\nt=jiffies;\r\nwhile((readl(olympic_mmio+BCTL)) & BCTL_SOFTRESET) {\r\nschedule();\r\nif(time_after(jiffies, t + 40*HZ)) {\r\nprintk(KERN_ERR "IBM PCI tokenring card not responding.\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nif(!(readl(olympic_mmio+BCTL) & BCTL_MODE_INDICATOR)) {\r\nwritel(readl(olympic_priv->olympic_mmio+FERMASK)|FERMASK_INT_BIT, olympic_mmio+FERMASK);\r\n}\r\n#if OLYMPIC_DEBUG\r\nprintk("BCTL: %x\n",readl(olympic_mmio+BCTL));\r\nprintk("GPR: %x\n",readw(olympic_mmio+GPR));\r\nprintk("SISRMASK: %x\n",readl(olympic_mmio+SISR_MASK));\r\n#endif\r\nwritel(readl(olympic_mmio+BCTL)|BCTL_MIMREB,olympic_mmio+BCTL);\r\nif (olympic_priv->olympic_ring_speed == 0) {\r\nwritew(readw(olympic_mmio+GPR)|GPR_AUTOSENSE,olympic_mmio+GPR);\r\nif (olympic_priv->olympic_message_level)\r\nprintk(KERN_INFO "%s: Ringspeed autosense mode on\n",olympic_priv->olympic_card_name);\r\n} else if (olympic_priv->olympic_ring_speed == 16) {\r\nif (olympic_priv->olympic_message_level)\r\nprintk(KERN_INFO "%s: Trying to open at 16 Mbps as requested\n", olympic_priv->olympic_card_name);\r\nwritew(GPR_16MBPS, olympic_mmio+GPR);\r\n} else if (olympic_priv->olympic_ring_speed == 4) {\r\nif (olympic_priv->olympic_message_level)\r\nprintk(KERN_INFO "%s: Trying to open at 4 Mbps as requested\n", olympic_priv->olympic_card_name) ;\r\nwritew(0, olympic_mmio+GPR);\r\n}\r\nwritew(readw(olympic_mmio+GPR)|GPR_NEPTUNE_BF,olympic_mmio+GPR);\r\n#if OLYMPIC_DEBUG\r\nprintk("GPR = %x\n",readw(olympic_mmio + GPR) ) ;\r\n#endif\r\nif(!(readl(olympic_mmio+BCTL) & BCTL_MODE_INDICATOR)) {\r\nt=jiffies;\r\nwhile (!(readl(olympic_mmio+CLKCTL) & CLKCTL_PAUSE)) {\r\nschedule() ;\r\nif(time_after(jiffies, t + 2*HZ)) {\r\nprintk(KERN_ERR "IBM Cardbus tokenring adapter not responsing.\n") ;\r\nreturn -ENODEV;\r\n}\r\n}\r\nwritel(readl(olympic_mmio+CLKCTL) & ~CLKCTL_PAUSE, olympic_mmio+CLKCTL) ;\r\n}\r\nwritel((1<<15),olympic_mmio+SISR_MASK_SUM);\r\nt=jiffies;\r\nwhile(!((readl(olympic_mmio+SISR_RR)) & SISR_SRB_REPLY)) {\r\nschedule();\r\nif(time_after(jiffies, t + 15*HZ)) {\r\nprintk(KERN_ERR "IBM PCI tokenring card not responding.\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nwritel(readw(olympic_mmio+LAPWWO),olympic_mmio+LAPA);\r\n#if OLYMPIC_DEBUG\r\nprintk("LAPWWO: %x, LAPA: %x\n",readl(olympic_mmio+LAPWWO), readl(olympic_mmio+LAPA));\r\n#endif\r\ninit_srb=olympic_priv->olympic_lap + ((readw(olympic_mmio+LAPWWO)) & (~0xf800));\r\n#if OLYMPIC_DEBUG\r\n{\r\nint i;\r\nprintk("init_srb(%p): ",init_srb);\r\nfor(i=0;i<20;i++)\r\nprintk("%x ",readb(init_srb+i));\r\nprintk("\n");\r\n}\r\n#endif\r\nif(readw(init_srb+6)) {\r\nprintk(KERN_INFO "tokenring card initialization failed. errorcode : %x\n",readw(init_srb+6));\r\nreturn -ENODEV;\r\n}\r\nif (olympic_priv->olympic_message_level) {\r\nif ( readb(init_srb +2) & 0x40) {\r\nprintk(KERN_INFO "Olympic: Adapter is FDX capable.\n") ;\r\n} else {\r\nprintk(KERN_INFO "Olympic: Adapter cannot do FDX.\n");\r\n}\r\n}\r\nuaa_addr=swab16(readw(init_srb+8));\r\n#if OLYMPIC_DEBUG\r\nprintk("UAA resides at %x\n",uaa_addr);\r\n#endif\r\nwritel(uaa_addr,olympic_mmio+LAPA);\r\nadapter_addr=olympic_priv->olympic_lap + (uaa_addr & (~0xf800));\r\nmemcpy_fromio(&dev->dev_addr[0], adapter_addr,6);\r\n#if OLYMPIC_DEBUG\r\nprintk("adapter address: %pM\n", dev->dev_addr);\r\n#endif\r\nolympic_priv->olympic_addr_table_addr = swab16(readw(init_srb + 12));\r\nolympic_priv->olympic_parms_addr = swab16(readw(init_srb + 14));\r\nreturn 0;\r\n}\r\nstatic int olympic_open(struct net_device *dev)\r\n{\r\nstruct olympic_private *olympic_priv=netdev_priv(dev);\r\nu8 __iomem *olympic_mmio=olympic_priv->olympic_mmio,*init_srb;\r\nunsigned long flags, t;\r\nint i, open_finished = 1 ;\r\nu8 resp, err;\r\nDECLARE_WAITQUEUE(wait,current) ;\r\nolympic_init(dev);\r\nif (request_irq(dev->irq, olympic_interrupt, IRQF_SHARED , "olympic",\r\ndev))\r\nreturn -EAGAIN;\r\n#if OLYMPIC_DEBUG\r\nprintk("BMCTL: %x\n",readl(olympic_mmio+BMCTL_SUM));\r\nprintk("pending ints: %x\n",readl(olympic_mmio+SISR_RR));\r\n#endif\r\nwritel(SISR_MI,olympic_mmio+SISR_MASK_SUM);\r\nwritel(SISR_MI | SISR_SRB_REPLY, olympic_mmio+SISR_MASK);\r\nwritel(LISR_LIE,olympic_mmio+LISR);\r\nwritel(readw(olympic_mmio+LAPWWO),olympic_mmio+LAPA);\r\ninit_srb=olympic_priv->olympic_lap + ((readw(olympic_mmio+LAPWWO)) & (~0xf800));\r\n#if OLYMPIC_DEBUG\r\nprintk("LAPWWO: %x, LAPA: %x\n",readw(olympic_mmio+LAPWWO), readl(olympic_mmio+LAPA));\r\nprintk("SISR Mask = %04x\n", readl(olympic_mmio+SISR_MASK));\r\nprintk("Before the open command\n");\r\n#endif\r\ndo {\r\nmemset_io(init_srb,0,SRB_COMMAND_SIZE);\r\nwriteb(SRB_OPEN_ADAPTER,init_srb) ;\r\nwriteb(OLYMPIC_CLEAR_RET_CODE,init_srb+2);\r\nif (olympic_priv->olympic_network_monitor)\r\nwritew(swab16(OPEN_ADAPTER_ENABLE_FDX | OPEN_ADAPTER_PASS_ADC_MAC | OPEN_ADAPTER_PASS_ATT_MAC | OPEN_ADAPTER_PASS_BEACON), init_srb+8);\r\nelse\r\nwritew(swab16(OPEN_ADAPTER_ENABLE_FDX), init_srb+8);\r\nif (olympic_priv->olympic_laa[0] | olympic_priv->olympic_laa[1] | olympic_priv->olympic_laa[2]) {\r\nwriteb(olympic_priv->olympic_laa[0],init_srb+12);\r\nwriteb(olympic_priv->olympic_laa[1],init_srb+13);\r\nwriteb(olympic_priv->olympic_laa[2],init_srb+14);\r\nwriteb(olympic_priv->olympic_laa[3],init_srb+15);\r\nwriteb(olympic_priv->olympic_laa[4],init_srb+16);\r\nwriteb(olympic_priv->olympic_laa[5],init_srb+17);\r\nmemcpy(dev->dev_addr,olympic_priv->olympic_laa,dev->addr_len) ;\r\n}\r\nwriteb(1,init_srb+30);\r\nspin_lock_irqsave(&olympic_priv->olympic_lock,flags);\r\nolympic_priv->srb_queued=1;\r\nwritel(LISR_SRB_CMD,olympic_mmio+LISR_SUM);\r\nspin_unlock_irqrestore(&olympic_priv->olympic_lock,flags);\r\nt = jiffies ;\r\nadd_wait_queue(&olympic_priv->srb_wait,&wait) ;\r\nset_current_state(TASK_INTERRUPTIBLE) ;\r\nwhile(olympic_priv->srb_queued) {\r\nschedule() ;\r\nif(signal_pending(current)) {\r\nprintk(KERN_WARNING "%s: Signal received in open.\n",\r\ndev->name);\r\nprintk(KERN_WARNING "SISR=%x LISR=%x\n",\r\nreadl(olympic_mmio+SISR),\r\nreadl(olympic_mmio+LISR));\r\nolympic_priv->srb_queued=0;\r\nbreak;\r\n}\r\nif (time_after(jiffies, t + 10*HZ)) {\r\nprintk(KERN_WARNING "%s: SRB timed out.\n",dev->name);\r\nolympic_priv->srb_queued=0;\r\nbreak ;\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE) ;\r\n}\r\nremove_wait_queue(&olympic_priv->srb_wait,&wait) ;\r\nset_current_state(TASK_RUNNING) ;\r\nolympic_priv->srb_queued = 0 ;\r\n#if OLYMPIC_DEBUG\r\nprintk("init_srb(%p): ",init_srb);\r\nfor(i=0;i<20;i++)\r\nprintk("%02x ",readb(init_srb+i));\r\nprintk("\n");\r\n#endif\r\nswitch (resp = readb(init_srb+2)) {\r\ncase OLYMPIC_CLEAR_RET_CODE:\r\nprintk(KERN_WARNING "%s: Adapter Open time out or error.\n", dev->name) ;\r\ngoto out;\r\ncase 0:\r\nopen_finished = 1;\r\nbreak;\r\ncase 0x07:\r\nif (!olympic_priv->olympic_ring_speed && open_finished) {\r\nprintk(KERN_WARNING "%s: Retrying at different ring speed\n", dev->name);\r\nopen_finished = 0 ;\r\ncontinue;\r\n}\r\nerr = readb(init_srb+7);\r\nif (!olympic_priv->olympic_ring_speed && ((err & 0x0f) == 0x0d)) {\r\nprintk(KERN_WARNING "%s: Tried to autosense ring speed with no monitors present\n",dev->name);\r\nprintk(KERN_WARNING "%s: Please try again with a specified ring speed\n",dev->name);\r\n} else {\r\nprintk(KERN_WARNING "%s: %s - %s\n", dev->name,\r\nopen_maj_error[(err & 0xf0) >> 4],\r\nopen_min_error[(err & 0x0f)]);\r\n}\r\ngoto out;\r\ncase 0x32:\r\nprintk(KERN_WARNING "%s: Invalid LAA: %pM\n",\r\ndev->name, olympic_priv->olympic_laa);\r\ngoto out;\r\ndefault:\r\nprintk(KERN_WARNING "%s: Bad OPEN response: %x\n", dev->name, resp);\r\ngoto out;\r\n}\r\n} while (!(open_finished)) ;\r\nif (readb(init_srb+18) & (1<<3))\r\nif (olympic_priv->olympic_message_level)\r\nprintk(KERN_INFO "%s: Opened in FDX Mode\n",dev->name);\r\nif (readb(init_srb+18) & (1<<1))\r\nolympic_priv->olympic_ring_speed = 100 ;\r\nelse if (readb(init_srb+18) & 1)\r\nolympic_priv->olympic_ring_speed = 16 ;\r\nelse\r\nolympic_priv->olympic_ring_speed = 4 ;\r\nif (olympic_priv->olympic_message_level)\r\nprintk(KERN_INFO "%s: Opened in %d Mbps mode\n",dev->name, olympic_priv->olympic_ring_speed);\r\nolympic_priv->asb = swab16(readw(init_srb+8));\r\nolympic_priv->srb = swab16(readw(init_srb+10));\r\nolympic_priv->arb = swab16(readw(init_srb+12));\r\nolympic_priv->trb = swab16(readw(init_srb+16));\r\nolympic_priv->olympic_receive_options = 0x01 ;\r\nolympic_priv->olympic_copy_all_options = 0 ;\r\nwritel((3<<16),olympic_mmio+BMCTL_RWM);\r\nwritel(BMCTL_RX_DIS|3,olympic_mmio+BMCTL_RWM);\r\nfor(i=0;i<OLYMPIC_RX_RING_SIZE;i++) {\r\nstruct sk_buff *skb;\r\nskb=dev_alloc_skb(olympic_priv->pkt_buf_sz);\r\nif(skb == NULL)\r\nbreak;\r\nskb->dev = dev;\r\nolympic_priv->olympic_rx_ring[i].buffer = cpu_to_le32(pci_map_single(olympic_priv->pdev,\r\nskb->data,olympic_priv->pkt_buf_sz, PCI_DMA_FROMDEVICE)) ;\r\nolympic_priv->olympic_rx_ring[i].res_length = cpu_to_le32(olympic_priv->pkt_buf_sz);\r\nolympic_priv->rx_ring_skb[i]=skb;\r\n}\r\nif (i==0) {\r\nprintk(KERN_WARNING "%s: Not enough memory to allocate rx buffers. Adapter disabled\n",dev->name);\r\ngoto out;\r\n}\r\nolympic_priv->rx_ring_dma_addr = pci_map_single(olympic_priv->pdev,olympic_priv->olympic_rx_ring,\r\nsizeof(struct olympic_rx_desc) * OLYMPIC_RX_RING_SIZE, PCI_DMA_TODEVICE);\r\nwritel(olympic_priv->rx_ring_dma_addr, olympic_mmio+RXDESCQ);\r\nwritel(olympic_priv->rx_ring_dma_addr, olympic_mmio+RXCDA);\r\nwritew(i, olympic_mmio+RXDESCQCNT);\r\nolympic_priv->rx_status_ring_dma_addr = pci_map_single(olympic_priv->pdev, olympic_priv->olympic_rx_status_ring,\r\nsizeof(struct olympic_rx_status) * OLYMPIC_RX_RING_SIZE, PCI_DMA_FROMDEVICE);\r\nwritel(olympic_priv->rx_status_ring_dma_addr, olympic_mmio+RXSTATQ);\r\nwritel(olympic_priv->rx_status_ring_dma_addr, olympic_mmio+RXCSA);\r\nolympic_priv->rx_ring_last_received = OLYMPIC_RX_RING_SIZE - 1;\r\nolympic_priv->rx_status_last_received = OLYMPIC_RX_RING_SIZE - 1;\r\nwritew(i, olympic_mmio+RXSTATQCNT);\r\n#if OLYMPIC_DEBUG\r\nprintk("# of rx buffers: %d, RXENQ: %x\n",i, readw(olympic_mmio+RXENQ));\r\nprintk("RXCSA: %x, rx_status_ring[0]: %p\n",readl(olympic_mmio+RXCSA),&olympic_priv->olympic_rx_status_ring[0]);\r\nprintk(" stat_ring[1]: %p, stat_ring[2]: %p, stat_ring[3]: %p\n", &(olympic_priv->olympic_rx_status_ring[1]), &(olympic_priv->olympic_rx_status_ring[2]), &(olympic_priv->olympic_rx_status_ring[3]) );\r\nprintk(" stat_ring[4]: %p, stat_ring[5]: %p, stat_ring[6]: %p\n", &(olympic_priv->olympic_rx_status_ring[4]), &(olympic_priv->olympic_rx_status_ring[5]), &(olympic_priv->olympic_rx_status_ring[6]) );\r\nprintk(" stat_ring[7]: %p\n", &(olympic_priv->olympic_rx_status_ring[7]) );\r\nprintk("RXCDA: %x, rx_ring[0]: %p\n",readl(olympic_mmio+RXCDA),&olympic_priv->olympic_rx_ring[0]);\r\nprintk("Rx_ring_dma_addr = %08x, rx_status_dma_addr = %08x\n",\r\nolympic_priv->rx_ring_dma_addr,olympic_priv->rx_status_ring_dma_addr) ;\r\n#endif\r\nwritew((((readw(olympic_mmio+RXENQ)) & 0x8000) ^ 0x8000) | i,olympic_mmio+RXENQ);\r\n#if OLYMPIC_DEBUG\r\nprintk("# of rx buffers: %d, RXENQ: %x\n",i, readw(olympic_mmio+RXENQ));\r\nprintk("RXCSA: %x, rx_ring[0]: %p\n",readl(olympic_mmio+RXCSA),&olympic_priv->olympic_rx_status_ring[0]);\r\nprintk("RXCDA: %x, rx_ring[0]: %p\n",readl(olympic_mmio+RXCDA),&olympic_priv->olympic_rx_ring[0]);\r\n#endif\r\nwritel(SISR_RX_STATUS | SISR_RX_NOBUF,olympic_mmio+SISR_MASK_SUM);\r\nwritel(BMCTL_TX1_DIS,olympic_mmio+BMCTL_RWM);\r\nfor(i=0;i<OLYMPIC_TX_RING_SIZE;i++)\r\nolympic_priv->olympic_tx_ring[i].buffer=cpu_to_le32(0xdeadbeef);\r\nolympic_priv->free_tx_ring_entries=OLYMPIC_TX_RING_SIZE;\r\nolympic_priv->tx_ring_dma_addr = pci_map_single(olympic_priv->pdev,olympic_priv->olympic_tx_ring,\r\nsizeof(struct olympic_tx_desc) * OLYMPIC_TX_RING_SIZE,PCI_DMA_TODEVICE) ;\r\nwritel(olympic_priv->tx_ring_dma_addr, olympic_mmio+TXDESCQ_1);\r\nwritel(olympic_priv->tx_ring_dma_addr, olympic_mmio+TXCDA_1);\r\nwritew(OLYMPIC_TX_RING_SIZE, olympic_mmio+TXDESCQCNT_1);\r\nolympic_priv->tx_status_ring_dma_addr = pci_map_single(olympic_priv->pdev, olympic_priv->olympic_tx_status_ring,\r\nsizeof(struct olympic_tx_status) * OLYMPIC_TX_RING_SIZE, PCI_DMA_FROMDEVICE);\r\nwritel(olympic_priv->tx_status_ring_dma_addr,olympic_mmio+TXSTATQ_1);\r\nwritel(olympic_priv->tx_status_ring_dma_addr,olympic_mmio+TXCSA_1);\r\nwritew(OLYMPIC_TX_RING_SIZE,olympic_mmio+TXSTATQCNT_1);\r\nolympic_priv->tx_ring_free=0;\r\nolympic_priv->tx_ring_last_status=OLYMPIC_TX_RING_SIZE-1;\r\nwritel(0xffffffff, olympic_mmio+EISR_RWM) ;\r\nwritel(0,olympic_mmio+EISR) ;\r\nwritel(EISR_MASK_OPTIONS,olympic_mmio+EISR_MASK) ;\r\nwritel(SISR_TX1_EOF | SISR_ADAPTER_CHECK | SISR_ARB_CMD | SISR_TRB_REPLY | SISR_ASB_FREE | SISR_ERR,olympic_mmio+SISR_MASK_SUM);\r\n#if OLYMPIC_DEBUG\r\nprintk("BMCTL: %x\n",readl(olympic_mmio+BMCTL_SUM));\r\nprintk("SISR MASK: %x\n",readl(olympic_mmio+SISR_MASK));\r\n#endif\r\nif (olympic_priv->olympic_network_monitor) {\r\nu8 __iomem *oat;\r\nu8 __iomem *opt;\r\nu8 addr[6];\r\noat = (olympic_priv->olympic_lap + olympic_priv->olympic_addr_table_addr);\r\nopt = (olympic_priv->olympic_lap + olympic_priv->olympic_parms_addr);\r\nfor (i = 0; i < 6; i++)\r\naddr[i] = readb(oat+offsetof(struct olympic_adapter_addr_table,node_addr)+i);\r\nprintk("%s: Node Address: %pM\n", dev->name, addr);\r\nprintk("%s: Functional Address: %02x:%02x:%02x:%02x\n",dev->name,\r\nreadb(oat+offsetof(struct olympic_adapter_addr_table,func_addr)),\r\nreadb(oat+offsetof(struct olympic_adapter_addr_table,func_addr)+1),\r\nreadb(oat+offsetof(struct olympic_adapter_addr_table,func_addr)+2),\r\nreadb(oat+offsetof(struct olympic_adapter_addr_table,func_addr)+3));\r\nfor (i = 0; i < 6; i++)\r\naddr[i] = readb(opt+offsetof(struct olympic_parameters_table, up_node_addr)+i);\r\nprintk("%s: NAUN Address: %pM\n", dev->name, addr);\r\n}\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nout:\r\nfree_irq(dev->irq, dev);\r\nreturn -EIO;\r\n}\r\nstatic void olympic_rx(struct net_device *dev)\r\n{\r\nstruct olympic_private *olympic_priv=netdev_priv(dev);\r\nu8 __iomem *olympic_mmio=olympic_priv->olympic_mmio;\r\nstruct olympic_rx_status *rx_status;\r\nstruct olympic_rx_desc *rx_desc ;\r\nint rx_ring_last_received,length, buffer_cnt, cpy_length, frag_len;\r\nstruct sk_buff *skb, *skb2;\r\nint i;\r\nrx_status=&(olympic_priv->olympic_rx_status_ring[(olympic_priv->rx_status_last_received + 1) & (OLYMPIC_RX_RING_SIZE - 1)]) ;\r\nwhile (rx_status->status_buffercnt) {\r\nu32 l_status_buffercnt;\r\nolympic_priv->rx_status_last_received++ ;\r\nolympic_priv->rx_status_last_received &= (OLYMPIC_RX_RING_SIZE -1);\r\n#if OLYMPIC_DEBUG\r\nprintk("rx status: %x rx len: %x\n", le32_to_cpu(rx_status->status_buffercnt), le32_to_cpu(rx_status->fragmentcnt_framelen));\r\n#endif\r\nlength = le32_to_cpu(rx_status->fragmentcnt_framelen) & 0xffff;\r\nbuffer_cnt = le32_to_cpu(rx_status->status_buffercnt) & 0xffff;\r\ni = buffer_cnt ;\r\nfrag_len = le32_to_cpu(rx_status->fragmentcnt_framelen) >> 16;\r\n#if OLYMPIC_DEBUG\r\nprintk("length: %x, frag_len: %x, buffer_cnt: %x\n", length, frag_len, buffer_cnt);\r\n#endif\r\nl_status_buffercnt = le32_to_cpu(rx_status->status_buffercnt);\r\nif(l_status_buffercnt & 0xC0000000) {\r\nif (l_status_buffercnt & 0x3B000000) {\r\nif (olympic_priv->olympic_message_level) {\r\nif (l_status_buffercnt & (1<<29))\r\nprintk(KERN_WARNING "%s: Rx Frame Truncated\n",dev->name);\r\nif (l_status_buffercnt & (1<<28))\r\nprintk(KERN_WARNING "%s: Rx Frame Receive overrun\n",dev->name);\r\nif (l_status_buffercnt & (1<<27))\r\nprintk(KERN_WARNING "%s: No receive buffers\n",dev->name);\r\nif (l_status_buffercnt & (1<<25))\r\nprintk(KERN_WARNING "%s: Receive frame error detect\n",dev->name);\r\nif (l_status_buffercnt & (1<<24))\r\nprintk(KERN_WARNING "%s: Received Error Detect\n",dev->name);\r\n}\r\nolympic_priv->rx_ring_last_received += i ;\r\nolympic_priv->rx_ring_last_received &= (OLYMPIC_RX_RING_SIZE -1) ;\r\ndev->stats.rx_errors++;\r\n} else {\r\nif (buffer_cnt == 1) {\r\nskb = dev_alloc_skb(max_t(int, olympic_priv->pkt_buf_sz,length)) ;\r\n} else {\r\nskb = dev_alloc_skb(length) ;\r\n}\r\nif (skb == NULL) {\r\nprintk(KERN_WARNING "%s: Not enough memory to copy packet to upper layers.\n",dev->name) ;\r\ndev->stats.rx_dropped++;\r\nolympic_priv->rx_ring_last_received += i ;\r\nolympic_priv->rx_ring_last_received &= (OLYMPIC_RX_RING_SIZE -1) ;\r\n} else {\r\nif (buffer_cnt==1) {\r\nolympic_priv->rx_ring_last_received++ ;\r\nolympic_priv->rx_ring_last_received &= (OLYMPIC_RX_RING_SIZE -1);\r\nrx_ring_last_received = olympic_priv->rx_ring_last_received ;\r\nif (length > 1500) {\r\nskb2=olympic_priv->rx_ring_skb[rx_ring_last_received] ;\r\npci_unmap_single(olympic_priv->pdev,\r\nle32_to_cpu(olympic_priv->olympic_rx_ring[rx_ring_last_received].buffer),\r\nolympic_priv->pkt_buf_sz,PCI_DMA_FROMDEVICE) ;\r\nskb_put(skb2,length-4);\r\nskb2->protocol = tr_type_trans(skb2,dev);\r\nolympic_priv->olympic_rx_ring[rx_ring_last_received].buffer =\r\ncpu_to_le32(pci_map_single(olympic_priv->pdev, skb->data,\r\nolympic_priv->pkt_buf_sz, PCI_DMA_FROMDEVICE));\r\nolympic_priv->olympic_rx_ring[rx_ring_last_received].res_length =\r\ncpu_to_le32(olympic_priv->pkt_buf_sz);\r\nolympic_priv->rx_ring_skb[rx_ring_last_received] = skb ;\r\nnetif_rx(skb2) ;\r\n} else {\r\npci_dma_sync_single_for_cpu(olympic_priv->pdev,\r\nle32_to_cpu(olympic_priv->olympic_rx_ring[rx_ring_last_received].buffer),\r\nolympic_priv->pkt_buf_sz,PCI_DMA_FROMDEVICE) ;\r\nskb_copy_from_linear_data(olympic_priv->rx_ring_skb[rx_ring_last_received],\r\nskb_put(skb,length - 4),\r\nlength - 4);\r\npci_dma_sync_single_for_device(olympic_priv->pdev,\r\nle32_to_cpu(olympic_priv->olympic_rx_ring[rx_ring_last_received].buffer),\r\nolympic_priv->pkt_buf_sz,PCI_DMA_FROMDEVICE) ;\r\nskb->protocol = tr_type_trans(skb,dev) ;\r\nnetif_rx(skb) ;\r\n}\r\n} else {\r\ndo {\r\nolympic_priv->rx_ring_last_received++ ;\r\nolympic_priv->rx_ring_last_received &= (OLYMPIC_RX_RING_SIZE -1);\r\nrx_ring_last_received = olympic_priv->rx_ring_last_received ;\r\npci_dma_sync_single_for_cpu(olympic_priv->pdev,\r\nle32_to_cpu(olympic_priv->olympic_rx_ring[rx_ring_last_received].buffer),\r\nolympic_priv->pkt_buf_sz,PCI_DMA_FROMDEVICE) ;\r\nrx_desc = &(olympic_priv->olympic_rx_ring[rx_ring_last_received]);\r\ncpy_length = (i == 1 ? frag_len : le32_to_cpu(rx_desc->res_length));\r\nskb_copy_from_linear_data(olympic_priv->rx_ring_skb[rx_ring_last_received],\r\nskb_put(skb, cpy_length),\r\ncpy_length);\r\npci_dma_sync_single_for_device(olympic_priv->pdev,\r\nle32_to_cpu(olympic_priv->olympic_rx_ring[rx_ring_last_received].buffer),\r\nolympic_priv->pkt_buf_sz,PCI_DMA_FROMDEVICE) ;\r\n} while (--i) ;\r\nskb_trim(skb,skb->len-4) ;\r\nskb->protocol = tr_type_trans(skb,dev);\r\nnetif_rx(skb) ;\r\n}\r\ndev->stats.rx_packets++ ;\r\ndev->stats.rx_bytes += length ;\r\n}\r\n}\r\n} else {\r\nolympic_priv->rx_ring_last_received += i ;\r\nolympic_priv->rx_ring_last_received &= (OLYMPIC_RX_RING_SIZE - 1) ;\r\n}\r\nrx_status->fragmentcnt_framelen = 0 ;\r\nrx_status->status_buffercnt = 0 ;\r\nrx_status = &(olympic_priv->olympic_rx_status_ring[(olympic_priv->rx_status_last_received+1) & (OLYMPIC_RX_RING_SIZE -1) ]);\r\nwritew((((readw(olympic_mmio+RXENQ)) & 0x8000) ^ 0x8000) | buffer_cnt , olympic_mmio+RXENQ);\r\n}\r\n}\r\nstatic void olympic_freemem(struct net_device *dev)\r\n{\r\nstruct olympic_private *olympic_priv=netdev_priv(dev);\r\nint i;\r\nfor(i=0;i<OLYMPIC_RX_RING_SIZE;i++) {\r\nif (olympic_priv->rx_ring_skb[olympic_priv->rx_status_last_received] != NULL) {\r\ndev_kfree_skb_irq(olympic_priv->rx_ring_skb[olympic_priv->rx_status_last_received]);\r\nolympic_priv->rx_ring_skb[olympic_priv->rx_status_last_received] = NULL;\r\n}\r\nif (olympic_priv->olympic_rx_ring[olympic_priv->rx_status_last_received].buffer != cpu_to_le32(0xdeadbeef)) {\r\npci_unmap_single(olympic_priv->pdev,\r\nle32_to_cpu(olympic_priv->olympic_rx_ring[olympic_priv->rx_status_last_received].buffer),\r\nolympic_priv->pkt_buf_sz, PCI_DMA_FROMDEVICE);\r\n}\r\nolympic_priv->rx_status_last_received++;\r\nolympic_priv->rx_status_last_received&=OLYMPIC_RX_RING_SIZE-1;\r\n}\r\npci_unmap_single(olympic_priv->pdev, olympic_priv->rx_status_ring_dma_addr,\r\nsizeof(struct olympic_rx_status) * OLYMPIC_RX_RING_SIZE, PCI_DMA_FROMDEVICE);\r\npci_unmap_single(olympic_priv->pdev, olympic_priv->rx_ring_dma_addr,\r\nsizeof(struct olympic_rx_desc) * OLYMPIC_RX_RING_SIZE, PCI_DMA_TODEVICE);\r\npci_unmap_single(olympic_priv->pdev, olympic_priv->tx_status_ring_dma_addr,\r\nsizeof(struct olympic_tx_status) * OLYMPIC_TX_RING_SIZE, PCI_DMA_FROMDEVICE);\r\npci_unmap_single(olympic_priv->pdev, olympic_priv->tx_ring_dma_addr,\r\nsizeof(struct olympic_tx_desc) * OLYMPIC_TX_RING_SIZE, PCI_DMA_TODEVICE);\r\nreturn ;\r\n}\r\nstatic irqreturn_t olympic_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev= (struct net_device *)dev_id;\r\nstruct olympic_private *olympic_priv=netdev_priv(dev);\r\nu8 __iomem *olympic_mmio=olympic_priv->olympic_mmio;\r\nu32 sisr;\r\nu8 __iomem *adapter_check_area ;\r\nsisr=readl(olympic_mmio+SISR) ;\r\nif (!(sisr & SISR_MI))\r\nreturn IRQ_NONE;\r\nsisr=readl(olympic_mmio+SISR_RR) ;\r\nspin_lock(&olympic_priv->olympic_lock);\r\nif (sisr == 0xffffffff) {\r\nprintk(KERN_WARNING "%s: Hotswap adapter removal.\n",dev->name) ;\r\nspin_unlock(&olympic_priv->olympic_lock) ;\r\nreturn IRQ_NONE;\r\n}\r\nif (sisr & (SISR_SRB_REPLY | SISR_TX1_EOF | SISR_RX_STATUS | SISR_ADAPTER_CHECK |\r\nSISR_ASB_FREE | SISR_ARB_CMD | SISR_TRB_REPLY | SISR_RX_NOBUF | SISR_ERR)) {\r\nif((sisr & SISR_ERR) && (readl(olympic_mmio+EISR) & EISR_MASK_OPTIONS)) {\r\nprintk(KERN_ERR "Olympic: EISR Error, EISR=%08x\n",readl(olympic_mmio+EISR)) ;\r\nprintk(KERN_ERR "The adapter must be reset to clear this condition.\n") ;\r\nprintk(KERN_ERR "Please report this error to the driver maintainer and/\n") ;\r\nprintk(KERN_ERR "or the linux-tr mailing list.\n") ;\r\nwake_up_interruptible(&olympic_priv->srb_wait);\r\nspin_unlock(&olympic_priv->olympic_lock) ;\r\nreturn IRQ_HANDLED;\r\n}\r\nif(sisr & SISR_SRB_REPLY) {\r\nif(olympic_priv->srb_queued==1) {\r\nwake_up_interruptible(&olympic_priv->srb_wait);\r\n} else if (olympic_priv->srb_queued==2) {\r\nolympic_srb_bh(dev) ;\r\n}\r\nolympic_priv->srb_queued=0;\r\n}\r\nif (sisr & SISR_TX1_EOF) {\r\nwhile(olympic_priv->olympic_tx_status_ring[(olympic_priv->tx_ring_last_status + 1) & (OLYMPIC_TX_RING_SIZE-1)].status) {\r\nolympic_priv->tx_ring_last_status++;\r\nolympic_priv->tx_ring_last_status &= (OLYMPIC_TX_RING_SIZE-1);\r\nolympic_priv->free_tx_ring_entries++;\r\ndev->stats.tx_bytes += olympic_priv->tx_ring_skb[olympic_priv->tx_ring_last_status]->len;\r\ndev->stats.tx_packets++ ;\r\npci_unmap_single(olympic_priv->pdev,\r\nle32_to_cpu(olympic_priv->olympic_tx_ring[olympic_priv->tx_ring_last_status].buffer),\r\nolympic_priv->tx_ring_skb[olympic_priv->tx_ring_last_status]->len,PCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq(olympic_priv->tx_ring_skb[olympic_priv->tx_ring_last_status]);\r\nolympic_priv->olympic_tx_ring[olympic_priv->tx_ring_last_status].buffer=cpu_to_le32(0xdeadbeef);\r\nolympic_priv->olympic_tx_status_ring[olympic_priv->tx_ring_last_status].status=0;\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\nif (sisr & SISR_RX_STATUS) {\r\nolympic_rx(dev);\r\n}\r\nif (sisr & SISR_ADAPTER_CHECK) {\r\nnetif_stop_queue(dev);\r\nprintk(KERN_WARNING "%s: Adapter Check Interrupt Raised, 8 bytes of information follow:\n", dev->name);\r\nwritel(readl(olympic_mmio+LAPWWC),olympic_mmio+LAPA);\r\nadapter_check_area = olympic_priv->olympic_lap + ((readl(olympic_mmio+LAPWWC)) & (~0xf800)) ;\r\nprintk(KERN_WARNING "%s: Bytes %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",dev->name, readb(adapter_check_area+0), readb(adapter_check_area+1), readb(adapter_check_area+2), readb(adapter_check_area+3), readb(adapter_check_area+4), readb(adapter_check_area+5), readb(adapter_check_area+6), readb(adapter_check_area+7)) ;\r\nspin_unlock(&olympic_priv->olympic_lock) ;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (sisr & SISR_ASB_FREE) {\r\nif (olympic_priv->asb_queued) {\r\nolympic_asb_bh(dev) ;\r\n}\r\n}\r\nif (sisr & SISR_ARB_CMD) {\r\nolympic_arb_cmd(dev) ;\r\n}\r\nif (sisr & SISR_TRB_REPLY) {\r\nif (olympic_priv->trb_queued) {\r\nwake_up_interruptible(&olympic_priv->trb_wait);\r\n}\r\nolympic_priv->trb_queued = 0 ;\r\n}\r\nif (sisr & SISR_RX_NOBUF) {\r\n}\r\n} else {\r\nprintk(KERN_WARNING "%s: Unexpected interrupt: %x\n",dev->name, sisr);\r\nprintk(KERN_WARNING "%s: SISR_MASK: %x\n",dev->name, readl(olympic_mmio+SISR_MASK)) ;\r\n}\r\nwritel(SISR_MI,olympic_mmio+SISR_MASK_SUM);\r\nspin_unlock(&olympic_priv->olympic_lock) ;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic netdev_tx_t olympic_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct olympic_private *olympic_priv=netdev_priv(dev);\r\nu8 __iomem *olympic_mmio=olympic_priv->olympic_mmio;\r\nunsigned long flags ;\r\nspin_lock_irqsave(&olympic_priv->olympic_lock, flags);\r\nnetif_stop_queue(dev);\r\nif(olympic_priv->free_tx_ring_entries) {\r\nolympic_priv->olympic_tx_ring[olympic_priv->tx_ring_free].buffer =\r\ncpu_to_le32(pci_map_single(olympic_priv->pdev, skb->data, skb->len,PCI_DMA_TODEVICE));\r\nolympic_priv->olympic_tx_ring[olympic_priv->tx_ring_free].status_length = cpu_to_le32(skb->len | (0x80000000));\r\nolympic_priv->tx_ring_skb[olympic_priv->tx_ring_free]=skb;\r\nolympic_priv->free_tx_ring_entries--;\r\nolympic_priv->tx_ring_free++;\r\nolympic_priv->tx_ring_free &= (OLYMPIC_TX_RING_SIZE-1);\r\nwritew((((readw(olympic_mmio+TXENQ_1)) & 0x8000) ^ 0x8000) | 1,olympic_mmio+TXENQ_1);\r\nnetif_wake_queue(dev);\r\nspin_unlock_irqrestore(&olympic_priv->olympic_lock,flags);\r\nreturn NETDEV_TX_OK;\r\n} else {\r\nspin_unlock_irqrestore(&olympic_priv->olympic_lock,flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\n}\r\nstatic int olympic_close(struct net_device *dev)\r\n{\r\nstruct olympic_private *olympic_priv=netdev_priv(dev);\r\nu8 __iomem *olympic_mmio=olympic_priv->olympic_mmio,*srb;\r\nunsigned long t,flags;\r\nDECLARE_WAITQUEUE(wait,current) ;\r\nnetif_stop_queue(dev);\r\nwritel(olympic_priv->srb,olympic_mmio+LAPA);\r\nsrb=olympic_priv->olympic_lap + (olympic_priv->srb & (~0xf800));\r\nwriteb(SRB_CLOSE_ADAPTER,srb+0);\r\nwriteb(0,srb+1);\r\nwriteb(OLYMPIC_CLEAR_RET_CODE,srb+2);\r\nadd_wait_queue(&olympic_priv->srb_wait,&wait) ;\r\nset_current_state(TASK_INTERRUPTIBLE) ;\r\nspin_lock_irqsave(&olympic_priv->olympic_lock,flags);\r\nolympic_priv->srb_queued=1;\r\nwritel(LISR_SRB_CMD,olympic_mmio+LISR_SUM);\r\nspin_unlock_irqrestore(&olympic_priv->olympic_lock,flags);\r\nwhile(olympic_priv->srb_queued) {\r\nt = schedule_timeout_interruptible(60*HZ);\r\nif(signal_pending(current)) {\r\nprintk(KERN_WARNING "%s: SRB timed out.\n",dev->name);\r\nprintk(KERN_WARNING "SISR=%x MISR=%x\n",readl(olympic_mmio+SISR),readl(olympic_mmio+LISR));\r\nolympic_priv->srb_queued=0;\r\nbreak;\r\n}\r\nif (t == 0) {\r\nprintk(KERN_WARNING "%s: SRB timed out. May not be fatal.\n",dev->name);\r\n}\r\nolympic_priv->srb_queued=0;\r\n}\r\nremove_wait_queue(&olympic_priv->srb_wait,&wait) ;\r\nolympic_priv->rx_status_last_received++;\r\nolympic_priv->rx_status_last_received&=OLYMPIC_RX_RING_SIZE-1;\r\nolympic_freemem(dev) ;\r\nwritel(readl(olympic_mmio+BCTL)|(3<<13),olympic_mmio+BCTL);\r\nudelay(1);\r\nwritel(readl(olympic_mmio+BCTL)&~(3<<13),olympic_mmio+BCTL);\r\n#if OLYMPIC_DEBUG\r\n{\r\nint i ;\r\nprintk("srb(%p): ",srb);\r\nfor(i=0;i<4;i++)\r\nprintk("%x ",readb(srb+i));\r\nprintk("\n");\r\n}\r\n#endif\r\nfree_irq(dev->irq,dev);\r\nreturn 0;\r\n}\r\nstatic void olympic_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct olympic_private *olympic_priv = netdev_priv(dev);\r\nu8 __iomem *olympic_mmio = olympic_priv->olympic_mmio ;\r\nu8 options = 0;\r\nu8 __iomem *srb;\r\nstruct netdev_hw_addr *ha;\r\nunsigned char dev_mc_address[4] ;\r\nwritel(olympic_priv->srb,olympic_mmio+LAPA);\r\nsrb=olympic_priv->olympic_lap + (olympic_priv->srb & (~0xf800));\r\noptions = olympic_priv->olympic_copy_all_options;\r\nif (dev->flags&IFF_PROMISC)\r\noptions |= 0x61 ;\r\nelse\r\noptions &= ~0x61 ;\r\nif ((options ^ olympic_priv->olympic_copy_all_options)) {\r\nwriteb(SRB_MODIFY_RECEIVE_OPTIONS,srb);\r\nwriteb(0,srb+1);\r\nwriteb(OLYMPIC_CLEAR_RET_CODE,srb+2);\r\nwriteb(0,srb+3);\r\nwriteb(olympic_priv->olympic_receive_options,srb+4);\r\nwriteb(options,srb+5);\r\nolympic_priv->srb_queued=2;\r\nwritel(LISR_SRB_CMD,olympic_mmio+LISR_SUM);\r\nolympic_priv->olympic_copy_all_options = options ;\r\nreturn ;\r\n}\r\ndev_mc_address[0] = dev_mc_address[1] = dev_mc_address[2] = dev_mc_address[3] = 0 ;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ndev_mc_address[0] |= ha->addr[2];\r\ndev_mc_address[1] |= ha->addr[3];\r\ndev_mc_address[2] |= ha->addr[4];\r\ndev_mc_address[3] |= ha->addr[5];\r\n}\r\nwriteb(SRB_SET_FUNC_ADDRESS,srb+0);\r\nwriteb(0,srb+1);\r\nwriteb(OLYMPIC_CLEAR_RET_CODE,srb+2);\r\nwriteb(0,srb+3);\r\nwriteb(0,srb+4);\r\nwriteb(0,srb+5);\r\nwriteb(dev_mc_address[0],srb+6);\r\nwriteb(dev_mc_address[1],srb+7);\r\nwriteb(dev_mc_address[2],srb+8);\r\nwriteb(dev_mc_address[3],srb+9);\r\nolympic_priv->srb_queued = 2 ;\r\nwritel(LISR_SRB_CMD,olympic_mmio+LISR_SUM);\r\n}\r\nstatic void olympic_srb_bh(struct net_device *dev)\r\n{\r\nstruct olympic_private *olympic_priv = netdev_priv(dev);\r\nu8 __iomem *olympic_mmio = olympic_priv->olympic_mmio ;\r\nu8 __iomem *srb;\r\nwritel(olympic_priv->srb,olympic_mmio+LAPA);\r\nsrb=olympic_priv->olympic_lap + (olympic_priv->srb & (~0xf800));\r\nswitch (readb(srb)) {\r\ncase SRB_MODIFY_RECEIVE_OPTIONS:\r\nswitch (readb(srb+2)) {\r\ncase 0x01:\r\nprintk(KERN_WARNING "%s: Unrecognized srb command\n",dev->name) ;\r\nbreak ;\r\ncase 0x04:\r\nprintk(KERN_WARNING "%s: Adapter must be open for this operation, doh!!\n",dev->name);\r\nbreak ;\r\ndefault:\r\nif (olympic_priv->olympic_message_level)\r\nprintk(KERN_WARNING "%s: Receive Options Modified to %x,%x\n",dev->name,olympic_priv->olympic_copy_all_options, olympic_priv->olympic_receive_options) ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase SRB_SET_GROUP_ADDRESS:\r\nswitch (readb(srb+2)) {\r\ncase 0x00:\r\nbreak ;\r\ncase 0x01:\r\nprintk(KERN_WARNING "%s: Unrecognized srb command\n",dev->name);\r\nbreak ;\r\ncase 0x04:\r\nprintk(KERN_WARNING "%s: Adapter must be open for this operation, doh!!\n",dev->name);\r\nbreak ;\r\ncase 0x3c:\r\nprintk(KERN_WARNING "%s: Group/Functional address indicator bits not set correctly\n",dev->name) ;\r\nbreak ;\r\ncase 0x3e:\r\nprintk(KERN_WARNING "%s: Group address registers full\n",dev->name) ;\r\nbreak ;\r\ncase 0x55:\r\nprintk(KERN_INFO "%s: Group Address already set.\n",dev->name) ;\r\nbreak ;\r\ndefault:\r\nbreak ;\r\n}\r\nbreak ;\r\ncase SRB_RESET_GROUP_ADDRESS:\r\nswitch (readb(srb+2)) {\r\ncase 0x00:\r\nbreak ;\r\ncase 0x01:\r\nprintk(KERN_WARNING "%s: Unrecognized srb command\n",dev->name);\r\nbreak ;\r\ncase 0x04:\r\nprintk(KERN_WARNING "%s: Adapter must be open for this operation, doh!!\n",dev->name) ;\r\nbreak ;\r\ncase 0x39:\r\nprintk(KERN_INFO "%s: Group address not found\n",dev->name);\r\nbreak ;\r\ndefault:\r\nbreak ;\r\n}\r\nbreak ;\r\ncase SRB_SET_FUNC_ADDRESS:\r\nswitch (readb(srb+2)) {\r\ncase 0x00:\r\nif (olympic_priv->olympic_message_level)\r\nprintk(KERN_INFO "%s: Functional Address Mask Set\n",dev->name);\r\nbreak ;\r\ncase 0x01:\r\nprintk(KERN_WARNING "%s: Unrecognized srb command\n",dev->name);\r\nbreak ;\r\ncase 0x04:\r\nprintk(KERN_WARNING "%s: Adapter must be open for this operation, doh!!\n",dev->name) ;\r\nbreak ;\r\ndefault:\r\nbreak ;\r\n}\r\nbreak ;\r\ncase SRB_READ_LOG:\r\nswitch (readb(srb+2)) {\r\ncase 0x00:\r\nif (olympic_priv->olympic_message_level)\r\nprintk(KERN_INFO "%s: Read Log issued\n",dev->name) ;\r\nbreak ;\r\ncase 0x01:\r\nprintk(KERN_WARNING "%s: Unrecognized srb command\n",dev->name);\r\nbreak ;\r\ncase 0x04:\r\nprintk(KERN_WARNING "%s: Adapter must be open for this operation, doh!!\n",dev->name) ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase SRB_READ_SR_COUNTERS:\r\nswitch (readb(srb+2)) {\r\ncase 0x00:\r\nif (olympic_priv->olympic_message_level)\r\nprintk(KERN_INFO "%s: Read Source Routing Counters issued\n",dev->name) ;\r\nbreak ;\r\ncase 0x01:\r\nprintk(KERN_WARNING "%s: Unrecognized srb command\n",dev->name);\r\nbreak ;\r\ncase 0x04:\r\nprintk(KERN_WARNING "%s: Adapter must be open for this operation, doh!!\n",dev->name) ;\r\nbreak ;\r\ndefault:\r\nbreak ;\r\n}\r\nbreak ;\r\ndefault:\r\nprintk(KERN_WARNING "%s: Unrecognized srb bh return value.\n",dev->name);\r\nbreak ;\r\n}\r\n}\r\nstatic int olympic_set_mac_address (struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *saddr = addr ;\r\nstruct olympic_private *olympic_priv = netdev_priv(dev);\r\nif (netif_running(dev)) {\r\nprintk(KERN_WARNING "%s: Cannot set mac/laa address while card is open\n", dev->name) ;\r\nreturn -EIO ;\r\n}\r\nmemcpy(olympic_priv->olympic_laa, saddr->sa_data,dev->addr_len) ;\r\nif (olympic_priv->olympic_message_level) {\r\nprintk(KERN_INFO "%s: MAC/LAA Set to = %x.%x.%x.%x.%x.%x\n",dev->name, olympic_priv->olympic_laa[0],\r\nolympic_priv->olympic_laa[1], olympic_priv->olympic_laa[2],\r\nolympic_priv->olympic_laa[3], olympic_priv->olympic_laa[4],\r\nolympic_priv->olympic_laa[5]);\r\n}\r\nreturn 0 ;\r\n}\r\nstatic void olympic_arb_cmd(struct net_device *dev)\r\n{\r\nstruct olympic_private *olympic_priv = netdev_priv(dev);\r\nu8 __iomem *olympic_mmio=olympic_priv->olympic_mmio;\r\nu8 __iomem *arb_block, *asb_block, *srb ;\r\nu8 header_len ;\r\nu16 frame_len, buffer_len ;\r\nstruct sk_buff *mac_frame ;\r\nu8 __iomem *buf_ptr ;\r\nu8 __iomem *frame_data ;\r\nu16 buff_off ;\r\nu16 lan_status = 0, lan_status_diff ;\r\nu8 fdx_prot_error ;\r\nu16 next_ptr;\r\narb_block = (olympic_priv->olympic_lap + olympic_priv->arb) ;\r\nasb_block = (olympic_priv->olympic_lap + olympic_priv->asb) ;\r\nsrb = (olympic_priv->olympic_lap + olympic_priv->srb) ;\r\nif (readb(arb_block+0) == ARB_RECEIVE_DATA) {\r\nheader_len = readb(arb_block+8) ;\r\nframe_len = swab16(readw(arb_block + 10)) ;\r\nbuff_off = swab16(readw(arb_block + 6)) ;\r\nbuf_ptr = olympic_priv->olympic_lap + buff_off ;\r\n#if OLYMPIC_DEBUG\r\n{\r\nint i;\r\nframe_data = buf_ptr+offsetof(struct mac_receive_buffer,frame_data) ;\r\nfor (i=0 ; i < 14 ; i++) {\r\nprintk("Loc %d = %02x\n",i,readb(frame_data + i));\r\n}\r\nprintk("next %04x, fs %02x, len %04x\n",readw(buf_ptr+offsetof(struct mac_receive_buffer,next)), readb(buf_ptr+offsetof(struct mac_receive_buffer,frame_status)), readw(buf_ptr+offsetof(struct mac_receive_buffer,buffer_length)));\r\n}\r\n#endif\r\nmac_frame = dev_alloc_skb(frame_len) ;\r\nif (!mac_frame) {\r\nprintk(KERN_WARNING "%s: Memory squeeze, dropping frame.\n", dev->name);\r\ngoto drop_frame;\r\n}\r\ndo {\r\nframe_data = buf_ptr+offsetof(struct mac_receive_buffer,frame_data) ;\r\nbuffer_len = swab16(readw(buf_ptr+offsetof(struct mac_receive_buffer,buffer_length)));\r\nmemcpy_fromio(skb_put(mac_frame, buffer_len), frame_data , buffer_len ) ;\r\nnext_ptr=readw(buf_ptr+offsetof(struct mac_receive_buffer,next));\r\n} while (next_ptr && (buf_ptr=olympic_priv->olympic_lap + swab16(next_ptr)));\r\nmac_frame->protocol = tr_type_trans(mac_frame, dev);\r\nif (olympic_priv->olympic_network_monitor) {\r\nstruct trh_hdr *mac_hdr;\r\nprintk(KERN_WARNING "%s: Received MAC Frame, details:\n",dev->name);\r\nmac_hdr = tr_hdr(mac_frame);\r\nprintk(KERN_WARNING "%s: MAC Frame Dest. Addr: %pM\n",\r\ndev->name, mac_hdr->daddr);\r\nprintk(KERN_WARNING "%s: MAC Frame Srce. Addr: %pM\n",\r\ndev->name, mac_hdr->saddr);\r\n}\r\nnetif_rx(mac_frame);\r\ndrop_frame:\r\nwritel(LISR_ARB_FREE,olympic_priv->olympic_mmio + LISR_SUM);\r\nif (readb(asb_block + 2) != 0xff) {\r\nolympic_priv->asb_queued = 1 ;\r\nwritel(LISR_ASB_FREE_REQ,olympic_priv->olympic_mmio+LISR_SUM);\r\nreturn ;\r\n}\r\nwriteb(ASB_RECEIVE_DATA,asb_block);\r\nwriteb(OLYMPIC_CLEAR_RET_CODE,asb_block+2);\r\nwriteb(readb(arb_block+6),asb_block+6);\r\nwriteb(readb(arb_block+7),asb_block+7);\r\nwritel(LISR_ASB_REPLY | LISR_ASB_FREE_REQ,olympic_priv->olympic_mmio+LISR_SUM);\r\nolympic_priv->asb_queued = 2 ;\r\nreturn ;\r\n} else if (readb(arb_block) == ARB_LAN_CHANGE_STATUS) {\r\nlan_status = swab16(readw(arb_block+6));\r\nfdx_prot_error = readb(arb_block+8) ;\r\nwritel(LISR_ARB_FREE,olympic_priv->olympic_mmio+LISR_SUM);\r\nlan_status_diff = olympic_priv->olympic_lan_status ^ lan_status ;\r\nif (lan_status_diff & (LSC_LWF | LSC_ARW | LSC_FPE | LSC_RR) ) {\r\nif (lan_status_diff & LSC_LWF)\r\nprintk(KERN_WARNING "%s: Short circuit detected on the lobe\n",dev->name);\r\nif (lan_status_diff & LSC_ARW)\r\nprintk(KERN_WARNING "%s: Auto removal error\n",dev->name);\r\nif (lan_status_diff & LSC_FPE)\r\nprintk(KERN_WARNING "%s: FDX Protocol Error\n",dev->name);\r\nif (lan_status_diff & LSC_RR)\r\nprintk(KERN_WARNING "%s: Force remove MAC frame received\n",dev->name);\r\nwritel(readl(olympic_mmio+BCTL)|(3<<13),olympic_mmio+BCTL);\r\nudelay(1);\r\nwritel(readl(olympic_mmio+BCTL)&~(3<<13),olympic_mmio+BCTL);\r\nnetif_stop_queue(dev);\r\nolympic_priv->srb = readw(olympic_priv->olympic_lap + LAPWWO) ;\r\nprintk(KERN_WARNING "%s: Adapter has been closed\n", dev->name);\r\n}\r\nif (olympic_priv->olympic_message_level) {\r\nif (lan_status_diff & LSC_SIG_LOSS)\r\nprintk(KERN_WARNING "%s: No receive signal detected\n", dev->name);\r\nif (lan_status_diff & LSC_HARD_ERR)\r\nprintk(KERN_INFO "%s: Beaconing\n",dev->name);\r\nif (lan_status_diff & LSC_SOFT_ERR)\r\nprintk(KERN_WARNING "%s: Adapter transmitted Soft Error Report Mac Frame\n",dev->name);\r\nif (lan_status_diff & LSC_TRAN_BCN)\r\nprintk(KERN_INFO "%s: We are transmitting the beacon, aaah\n",dev->name);\r\nif (lan_status_diff & LSC_SS)\r\nprintk(KERN_INFO "%s: Single Station on the ring\n", dev->name);\r\nif (lan_status_diff & LSC_RING_REC)\r\nprintk(KERN_INFO "%s: Ring recovery ongoing\n",dev->name);\r\nif (lan_status_diff & LSC_FDX_MODE)\r\nprintk(KERN_INFO "%s: Operating in FDX mode\n",dev->name);\r\n}\r\nif (lan_status_diff & LSC_CO) {\r\nif (olympic_priv->olympic_message_level)\r\nprintk(KERN_INFO "%s: Counter Overflow\n", dev->name);\r\nwriteb(SRB_READ_LOG, srb);\r\nwriteb(0,srb+1);\r\nwriteb(OLYMPIC_CLEAR_RET_CODE,srb+2);\r\nwriteb(0,srb+3);\r\nwriteb(0,srb+4);\r\nwriteb(0,srb+5);\r\nolympic_priv->srb_queued=2;\r\nwritel(LISR_SRB_CMD,olympic_mmio+LISR_SUM);\r\n}\r\nif (lan_status_diff & LSC_SR_CO) {\r\nif (olympic_priv->olympic_message_level)\r\nprintk(KERN_INFO "%s: Source routing counters overflow\n", dev->name);\r\nwriteb(SRB_READ_SR_COUNTERS,srb);\r\nwriteb(0,srb+1);\r\nwriteb(OLYMPIC_CLEAR_RET_CODE,srb+2);\r\nwriteb(0,srb+3);\r\nolympic_priv->srb_queued=2;\r\nwritel(LISR_SRB_CMD,olympic_mmio+LISR_SUM);\r\n}\r\nolympic_priv->olympic_lan_status = lan_status ;\r\n}\r\nelse\r\nprintk(KERN_WARNING "%s: Unknown arb command\n", dev->name);\r\n}\r\nstatic void olympic_asb_bh(struct net_device *dev)\r\n{\r\nstruct olympic_private *olympic_priv = netdev_priv(dev);\r\nu8 __iomem *arb_block, *asb_block ;\r\narb_block = (olympic_priv->olympic_lap + olympic_priv->arb) ;\r\nasb_block = (olympic_priv->olympic_lap + olympic_priv->asb) ;\r\nif (olympic_priv->asb_queued == 1) {\r\nwriteb(ASB_RECEIVE_DATA,asb_block);\r\nwriteb(OLYMPIC_CLEAR_RET_CODE,asb_block+2);\r\nwriteb(readb(arb_block+6),asb_block+6);\r\nwriteb(readb(arb_block+7),asb_block+7);\r\nwritel(LISR_ASB_REPLY | LISR_ASB_FREE_REQ,olympic_priv->olympic_mmio+LISR_SUM);\r\nolympic_priv->asb_queued = 2 ;\r\nreturn ;\r\n}\r\nif (olympic_priv->asb_queued == 2) {\r\nswitch (readb(asb_block+2)) {\r\ncase 0x01:\r\nprintk(KERN_WARNING "%s: Unrecognized command code\n", dev->name);\r\nbreak ;\r\ncase 0x26:\r\nprintk(KERN_WARNING "%s: Unrecognized buffer address\n", dev->name);\r\nbreak ;\r\ncase 0xFF:\r\nbreak ;\r\ndefault:\r\nprintk(KERN_WARNING "%s: Invalid return code in asb\n",dev->name);\r\nbreak ;\r\n}\r\n}\r\nolympic_priv->asb_queued = 0 ;\r\n}\r\nstatic int olympic_change_mtu(struct net_device *dev, int mtu)\r\n{\r\nstruct olympic_private *olympic_priv = netdev_priv(dev);\r\nu16 max_mtu ;\r\nif (olympic_priv->olympic_ring_speed == 4)\r\nmax_mtu = 4500 ;\r\nelse\r\nmax_mtu = 18000 ;\r\nif (mtu > max_mtu)\r\nreturn -EINVAL ;\r\nif (mtu < 100)\r\nreturn -EINVAL ;\r\ndev->mtu = mtu ;\r\nolympic_priv->pkt_buf_sz = mtu + TR_HLEN ;\r\nreturn 0 ;\r\n}\r\nstatic int olympic_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct olympic_private *olympic_priv=netdev_priv(dev);\r\nu8 __iomem *oat = (olympic_priv->olympic_lap + olympic_priv->olympic_addr_table_addr) ;\r\nu8 __iomem *opt = (olympic_priv->olympic_lap + olympic_priv->olympic_parms_addr) ;\r\nu8 addr[6];\r\nu8 addr2[6];\r\nint i;\r\nseq_printf(m,\r\n"IBM Pit/Pit-Phy/Olympic Chipset Token Ring Adapter %s\n",dev->name);\r\nseq_printf(m, "\n%6s: Adapter Address : Node Address : Functional Addr\n",\r\ndev->name);\r\nfor (i = 0 ; i < 6 ; i++)\r\naddr[i] = readb(oat+offsetof(struct olympic_adapter_addr_table,node_addr) + i);\r\nseq_printf(m, "%6s: %pM : %pM : %02x:%02x:%02x:%02x\n",\r\ndev->name,\r\ndev->dev_addr, addr,\r\nreadb(oat+offsetof(struct olympic_adapter_addr_table,func_addr)),\r\nreadb(oat+offsetof(struct olympic_adapter_addr_table,func_addr)+1),\r\nreadb(oat+offsetof(struct olympic_adapter_addr_table,func_addr)+2),\r\nreadb(oat+offsetof(struct olympic_adapter_addr_table,func_addr)+3));\r\nseq_printf(m, "\n%6s: Token Ring Parameters Table:\n", dev->name);\r\nseq_printf(m, "%6s: Physical Addr : Up Node Address : Poll Address : AccPri : Auth Src : Att Code :\n",\r\ndev->name) ;\r\nfor (i = 0 ; i < 6 ; i++)\r\naddr[i] = readb(opt+offsetof(struct olympic_parameters_table, up_node_addr) + i);\r\nfor (i = 0 ; i < 6 ; i++)\r\naddr2[i] = readb(opt+offsetof(struct olympic_parameters_table, poll_addr) + i);\r\nseq_printf(m, "%6s: %02x:%02x:%02x:%02x : %pM : %pM : %04x : %04x : %04x :\n",\r\ndev->name,\r\nreadb(opt+offsetof(struct olympic_parameters_table, phys_addr)),\r\nreadb(opt+offsetof(struct olympic_parameters_table, phys_addr)+1),\r\nreadb(opt+offsetof(struct olympic_parameters_table, phys_addr)+2),\r\nreadb(opt+offsetof(struct olympic_parameters_table, phys_addr)+3),\r\naddr, addr2,\r\nswab16(readw(opt+offsetof(struct olympic_parameters_table, acc_priority))),\r\nswab16(readw(opt+offsetof(struct olympic_parameters_table, auth_source_class))),\r\nswab16(readw(opt+offsetof(struct olympic_parameters_table, att_code))));\r\nseq_printf(m, "%6s: Source Address : Bcn T : Maj. V : Lan St : Lcl Rg : Mon Err : Frame Correl : \n",\r\ndev->name) ;\r\nfor (i = 0 ; i < 6 ; i++)\r\naddr[i] = readb(opt+offsetof(struct olympic_parameters_table, source_addr) + i);\r\nseq_printf(m, "%6s: %pM : %04x : %04x : %04x : %04x : %04x : %04x : \n",\r\ndev->name, addr,\r\nswab16(readw(opt+offsetof(struct olympic_parameters_table, beacon_type))),\r\nswab16(readw(opt+offsetof(struct olympic_parameters_table, major_vector))),\r\nswab16(readw(opt+offsetof(struct olympic_parameters_table, lan_status))),\r\nswab16(readw(opt+offsetof(struct olympic_parameters_table, local_ring))),\r\nswab16(readw(opt+offsetof(struct olympic_parameters_table, mon_error))),\r\nswab16(readw(opt+offsetof(struct olympic_parameters_table, frame_correl))));\r\nseq_printf(m, "%6s: Beacon Details : Tx : Rx : NAUN Node Address : NAUN Node Phys : \n",\r\ndev->name) ;\r\nfor (i = 0 ; i < 6 ; i++)\r\naddr[i] = readb(opt+offsetof(struct olympic_parameters_table, beacon_naun) + i);\r\nseq_printf(m, "%6s: : %02x : %02x : %pM : %02x:%02x:%02x:%02x : \n",\r\ndev->name,\r\nswab16(readw(opt+offsetof(struct olympic_parameters_table, beacon_transmit))),\r\nswab16(readw(opt+offsetof(struct olympic_parameters_table, beacon_receive))),\r\naddr,\r\nreadb(opt+offsetof(struct olympic_parameters_table, beacon_phys)),\r\nreadb(opt+offsetof(struct olympic_parameters_table, beacon_phys)+1),\r\nreadb(opt+offsetof(struct olympic_parameters_table, beacon_phys)+2),\r\nreadb(opt+offsetof(struct olympic_parameters_table, beacon_phys)+3));\r\nreturn 0;\r\n}\r\nstatic int olympic_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, olympic_proc_show, PDE(inode)->data);\r\n}\r\nstatic void __devexit olympic_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev) ;\r\nstruct olympic_private *olympic_priv=netdev_priv(dev);\r\nif (olympic_priv->olympic_network_monitor) {\r\nchar proc_name[20] ;\r\nstrcpy(proc_name,"olympic_") ;\r\nstrcat(proc_name,dev->name) ;\r\nremove_proc_entry(proc_name,init_net.proc_net);\r\n}\r\nunregister_netdev(dev) ;\r\niounmap(olympic_priv->olympic_mmio) ;\r\niounmap(olympic_priv->olympic_lap) ;\r\npci_release_regions(pdev) ;\r\npci_set_drvdata(pdev,NULL) ;\r\nfree_netdev(dev) ;\r\n}\r\nstatic int __init olympic_pci_init(void)\r\n{\r\nreturn pci_register_driver(&olympic_driver) ;\r\n}\r\nstatic void __exit olympic_pci_cleanup(void)\r\n{\r\npci_unregister_driver(&olympic_driver) ;\r\n}
