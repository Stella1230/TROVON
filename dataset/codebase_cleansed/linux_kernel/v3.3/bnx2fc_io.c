void bnx2fc_cmd_timer_set(struct bnx2fc_cmd *io_req,\r\nunsigned int timer_msec)\r\n{\r\nstruct bnx2fc_interface *interface = io_req->port->priv;\r\nif (queue_delayed_work(interface->timer_work_queue,\r\n&io_req->timeout_work,\r\nmsecs_to_jiffies(timer_msec)))\r\nkref_get(&io_req->refcount);\r\n}\r\nstatic void bnx2fc_cmd_timeout(struct work_struct *work)\r\n{\r\nstruct bnx2fc_cmd *io_req = container_of(work, struct bnx2fc_cmd,\r\ntimeout_work.work);\r\nstruct fc_lport *lport;\r\nstruct fc_rport_priv *rdata;\r\nu8 cmd_type = io_req->cmd_type;\r\nstruct bnx2fc_rport *tgt = io_req->tgt;\r\nint logo_issued;\r\nint rc;\r\nBNX2FC_IO_DBG(io_req, "cmd_timeout, cmd_type = %d,"\r\n"req_flags = %lx\n", cmd_type, io_req->req_flags);\r\nspin_lock_bh(&tgt->tgt_lock);\r\nif (test_and_clear_bit(BNX2FC_FLAG_ISSUE_RRQ, &io_req->req_flags)) {\r\nclear_bit(BNX2FC_FLAG_RETIRE_OXID, &io_req->req_flags);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nbnx2fc_send_rrq(io_req);\r\nreturn;\r\n}\r\nif (test_and_clear_bit(BNX2FC_FLAG_RETIRE_OXID, &io_req->req_flags)) {\r\nBNX2FC_IO_DBG(io_req, "IO ready for reuse now\n");\r\ngoto done;\r\n}\r\nswitch (cmd_type) {\r\ncase BNX2FC_SCSI_CMD:\r\nif (test_and_clear_bit(BNX2FC_FLAG_EH_ABORT,\r\n&io_req->req_flags)) {\r\nBNX2FC_IO_DBG(io_req, "eh_abort timed out\n");\r\ncomplete(&io_req->tm_done);\r\n} else if (test_bit(BNX2FC_FLAG_ISSUE_ABTS,\r\n&io_req->req_flags)) {\r\nBNX2FC_IO_DBG(io_req, "ABTS timed out refcnt = %d\n",\r\nio_req->refcount.refcount.counter);\r\nif (!(test_and_set_bit(BNX2FC_FLAG_ABTS_DONE,\r\n&io_req->req_flags))) {\r\nlport = io_req->port->lport;\r\nrdata = io_req->tgt->rdata;\r\nlogo_issued = test_and_set_bit(\r\nBNX2FC_FLAG_EXPL_LOGO,\r\n&tgt->flags);\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nif (!logo_issued) {\r\nBNX2FC_IO_DBG(io_req, "Explicit "\r\n"logo - tgt flags = 0x%lx\n",\r\ntgt->flags);\r\nmutex_lock(&lport->disc.disc_mutex);\r\nlport->tt.rport_logoff(rdata);\r\nmutex_unlock(&lport->disc.disc_mutex);\r\n}\r\nreturn;\r\n}\r\n} else {\r\nBNX2FC_IO_DBG(io_req, "IO timed out. issue ABTS\n");\r\nif (test_and_set_bit(BNX2FC_FLAG_IO_COMPL,\r\n&io_req->req_flags)) {\r\nBNX2FC_IO_DBG(io_req, "IO completed before "\r\n" timer expiry\n");\r\ngoto done;\r\n}\r\nif (!test_and_set_bit(BNX2FC_FLAG_ISSUE_ABTS,\r\n&io_req->req_flags)) {\r\nrc = bnx2fc_initiate_abts(io_req);\r\nif (rc == SUCCESS)\r\ngoto done;\r\nlport = io_req->port->lport;\r\nrdata = io_req->tgt->rdata;\r\nlogo_issued = test_and_set_bit(\r\nBNX2FC_FLAG_EXPL_LOGO,\r\n&tgt->flags);\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nif (!logo_issued) {\r\nBNX2FC_IO_DBG(io_req, "Explicit "\r\n"logo - tgt flags = 0x%lx\n",\r\ntgt->flags);\r\nmutex_lock(&lport->disc.disc_mutex);\r\nlport->tt.rport_logoff(rdata);\r\nmutex_unlock(&lport->disc.disc_mutex);\r\n}\r\nreturn;\r\n} else {\r\nBNX2FC_IO_DBG(io_req, "IO already in "\r\n"ABTS processing\n");\r\n}\r\n}\r\nbreak;\r\ncase BNX2FC_ELS:\r\nif (test_bit(BNX2FC_FLAG_ISSUE_ABTS, &io_req->req_flags)) {\r\nBNX2FC_IO_DBG(io_req, "ABTS for ELS timed out\n");\r\nif (!test_and_set_bit(BNX2FC_FLAG_ABTS_DONE,\r\n&io_req->req_flags)) {\r\nlport = io_req->port->lport;\r\nrdata = io_req->tgt->rdata;\r\nlogo_issued = test_and_set_bit(\r\nBNX2FC_FLAG_EXPL_LOGO,\r\n&tgt->flags);\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nif (!logo_issued) {\r\nBNX2FC_IO_DBG(io_req, "Explicitly logo"\r\n"(els)\n");\r\nmutex_lock(&lport->disc.disc_mutex);\r\nlport->tt.rport_logoff(rdata);\r\nmutex_unlock(&lport->disc.disc_mutex);\r\n}\r\nreturn;\r\n}\r\n} else {\r\nBNX2FC_IO_DBG(io_req, "ELS timed out\n");\r\nif (test_and_set_bit(BNX2FC_FLAG_ELS_DONE,\r\n&io_req->req_flags))\r\ngoto done;\r\nset_bit(BNX2FC_FLAG_ELS_TIMEOUT, &io_req->req_flags);\r\nif ((io_req->cb_func) && (io_req->cb_arg)) {\r\nio_req->cb_func(io_req->cb_arg);\r\nio_req->cb_arg = NULL;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR PFX "cmd_timeout: invalid cmd_type %d\n",\r\ncmd_type);\r\nbreak;\r\n}\r\ndone:\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\n}\r\nstatic void bnx2fc_scsi_done(struct bnx2fc_cmd *io_req, int err_code)\r\n{\r\nstruct scsi_cmnd *sc_cmd = io_req->sc_cmd;\r\nif (io_req->cmd_type != BNX2FC_SCSI_CMD)\r\nreturn;\r\nBNX2FC_IO_DBG(io_req, "scsi_done. err_code = 0x%x\n", err_code);\r\nif (test_bit(BNX2FC_FLAG_CMD_LOST, &io_req->req_flags)) {\r\nreturn;\r\n}\r\nbnx2fc_unmap_sg_list(io_req);\r\nio_req->sc_cmd = NULL;\r\nif (!sc_cmd) {\r\nprintk(KERN_ERR PFX "scsi_done - sc_cmd NULL. "\r\n"IO(0x%x) already cleaned up\n",\r\nio_req->xid);\r\nreturn;\r\n}\r\nsc_cmd->result = err_code << 16;\r\nBNX2FC_IO_DBG(io_req, "sc=%p, result=0x%x, retries=%d, allowed=%d\n",\r\nsc_cmd, host_byte(sc_cmd->result), sc_cmd->retries,\r\nsc_cmd->allowed);\r\nscsi_set_resid(sc_cmd, scsi_bufflen(sc_cmd));\r\nsc_cmd->SCp.ptr = NULL;\r\nsc_cmd->scsi_done(sc_cmd);\r\n}\r\nstruct bnx2fc_cmd_mgr *bnx2fc_cmd_mgr_alloc(struct bnx2fc_hba *hba,\r\nu16 min_xid, u16 max_xid)\r\n{\r\nstruct bnx2fc_cmd_mgr *cmgr;\r\nstruct io_bdt *bdt_info;\r\nstruct bnx2fc_cmd *io_req;\r\nsize_t len;\r\nu32 mem_size;\r\nu16 xid;\r\nint i;\r\nint num_ios, num_pri_ios;\r\nsize_t bd_tbl_sz;\r\nint arr_sz = num_possible_cpus() + 1;\r\nif (max_xid <= min_xid || max_xid == FC_XID_UNKNOWN) {\r\nprintk(KERN_ERR PFX "cmd_mgr_alloc: Invalid min_xid 0x%x \\r\nand max_xid 0x%x\n", min_xid, max_xid);\r\nreturn NULL;\r\n}\r\nBNX2FC_MISC_DBG("min xid 0x%x, max xid 0x%x\n", min_xid, max_xid);\r\nnum_ios = max_xid - min_xid + 1;\r\nlen = (num_ios * (sizeof(struct bnx2fc_cmd *)));\r\nlen += sizeof(struct bnx2fc_cmd_mgr);\r\ncmgr = kzalloc(len, GFP_KERNEL);\r\nif (!cmgr) {\r\nprintk(KERN_ERR PFX "failed to alloc cmgr\n");\r\nreturn NULL;\r\n}\r\ncmgr->free_list = kzalloc(sizeof(*cmgr->free_list) *\r\narr_sz, GFP_KERNEL);\r\nif (!cmgr->free_list) {\r\nprintk(KERN_ERR PFX "failed to alloc free_list\n");\r\ngoto mem_err;\r\n}\r\ncmgr->free_list_lock = kzalloc(sizeof(*cmgr->free_list_lock) *\r\narr_sz, GFP_KERNEL);\r\nif (!cmgr->free_list_lock) {\r\nprintk(KERN_ERR PFX "failed to alloc free_list_lock\n");\r\ngoto mem_err;\r\n}\r\ncmgr->hba = hba;\r\ncmgr->cmds = (struct bnx2fc_cmd **)(cmgr + 1);\r\nfor (i = 0; i < arr_sz; i++) {\r\nINIT_LIST_HEAD(&cmgr->free_list[i]);\r\nspin_lock_init(&cmgr->free_list_lock[i]);\r\n}\r\nxid = BNX2FC_MIN_XID;\r\nnum_pri_ios = num_ios - BNX2FC_ELSTM_XIDS;\r\nfor (i = 0; i < num_ios; i++) {\r\nio_req = kzalloc(sizeof(*io_req), GFP_KERNEL);\r\nif (!io_req) {\r\nprintk(KERN_ERR PFX "failed to alloc io_req\n");\r\ngoto mem_err;\r\n}\r\nINIT_LIST_HEAD(&io_req->link);\r\nINIT_DELAYED_WORK(&io_req->timeout_work, bnx2fc_cmd_timeout);\r\nio_req->xid = xid++;\r\nif (i < num_pri_ios)\r\nlist_add_tail(&io_req->link,\r\n&cmgr->free_list[io_req->xid %\r\nnum_possible_cpus()]);\r\nelse\r\nlist_add_tail(&io_req->link,\r\n&cmgr->free_list[num_possible_cpus()]);\r\nio_req++;\r\n}\r\nmem_size = num_ios * sizeof(struct io_bdt *);\r\ncmgr->io_bdt_pool = kmalloc(mem_size, GFP_KERNEL);\r\nif (!cmgr->io_bdt_pool) {\r\nprintk(KERN_ERR PFX "failed to alloc io_bdt_pool\n");\r\ngoto mem_err;\r\n}\r\nmem_size = sizeof(struct io_bdt);\r\nfor (i = 0; i < num_ios; i++) {\r\ncmgr->io_bdt_pool[i] = kmalloc(mem_size, GFP_KERNEL);\r\nif (!cmgr->io_bdt_pool[i]) {\r\nprintk(KERN_ERR PFX "failed to alloc "\r\n"io_bdt_pool[%d]\n", i);\r\ngoto mem_err;\r\n}\r\n}\r\nbd_tbl_sz = BNX2FC_MAX_BDS_PER_CMD * sizeof(struct fcoe_bd_ctx);\r\nfor (i = 0; i < num_ios; i++) {\r\nbdt_info = cmgr->io_bdt_pool[i];\r\nbdt_info->bd_tbl = dma_alloc_coherent(&hba->pcidev->dev,\r\nbd_tbl_sz,\r\n&bdt_info->bd_tbl_dma,\r\nGFP_KERNEL);\r\nif (!bdt_info->bd_tbl) {\r\nprintk(KERN_ERR PFX "failed to alloc "\r\n"bdt_tbl[%d]\n", i);\r\ngoto mem_err;\r\n}\r\n}\r\nreturn cmgr;\r\nmem_err:\r\nbnx2fc_cmd_mgr_free(cmgr);\r\nreturn NULL;\r\n}\r\nvoid bnx2fc_cmd_mgr_free(struct bnx2fc_cmd_mgr *cmgr)\r\n{\r\nstruct io_bdt *bdt_info;\r\nstruct bnx2fc_hba *hba = cmgr->hba;\r\nsize_t bd_tbl_sz;\r\nu16 min_xid = BNX2FC_MIN_XID;\r\nu16 max_xid = BNX2FC_MAX_XID;\r\nint num_ios;\r\nint i;\r\nnum_ios = max_xid - min_xid + 1;\r\nif (!cmgr->io_bdt_pool)\r\ngoto free_cmd_pool;\r\nbd_tbl_sz = BNX2FC_MAX_BDS_PER_CMD * sizeof(struct fcoe_bd_ctx);\r\nfor (i = 0; i < num_ios; i++) {\r\nbdt_info = cmgr->io_bdt_pool[i];\r\nif (bdt_info->bd_tbl) {\r\ndma_free_coherent(&hba->pcidev->dev, bd_tbl_sz,\r\nbdt_info->bd_tbl,\r\nbdt_info->bd_tbl_dma);\r\nbdt_info->bd_tbl = NULL;\r\n}\r\n}\r\nfor (i = 0; i < num_ios; i++) {\r\nkfree(cmgr->io_bdt_pool[i]);\r\ncmgr->io_bdt_pool[i] = NULL;\r\n}\r\nkfree(cmgr->io_bdt_pool);\r\ncmgr->io_bdt_pool = NULL;\r\nfree_cmd_pool:\r\nkfree(cmgr->free_list_lock);\r\nif (!cmgr->free_list)\r\ngoto free_cmgr;\r\nfor (i = 0; i < num_possible_cpus() + 1; i++) {\r\nstruct list_head *list;\r\nstruct list_head *tmp;\r\nlist_for_each_safe(list, tmp, &cmgr->free_list[i]) {\r\nstruct bnx2fc_cmd *io_req = (struct bnx2fc_cmd *)list;\r\nlist_del(&io_req->link);\r\nkfree(io_req);\r\n}\r\n}\r\nkfree(cmgr->free_list);\r\nfree_cmgr:\r\nkfree(cmgr);\r\n}\r\nstruct bnx2fc_cmd *bnx2fc_elstm_alloc(struct bnx2fc_rport *tgt, int type)\r\n{\r\nstruct fcoe_port *port = tgt->port;\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct bnx2fc_cmd_mgr *cmd_mgr = interface->hba->cmd_mgr;\r\nstruct bnx2fc_cmd *io_req;\r\nstruct list_head *listp;\r\nstruct io_bdt *bd_tbl;\r\nint index = RESERVE_FREE_LIST_INDEX;\r\nu32 free_sqes;\r\nu32 max_sqes;\r\nu16 xid;\r\nmax_sqes = tgt->max_sqes;\r\nswitch (type) {\r\ncase BNX2FC_TASK_MGMT_CMD:\r\nmax_sqes = BNX2FC_TM_MAX_SQES;\r\nbreak;\r\ncase BNX2FC_ELS:\r\nmax_sqes = BNX2FC_ELS_MAX_SQES;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_lock_bh(&cmd_mgr->free_list_lock[index]);\r\nfree_sqes = atomic_read(&tgt->free_sqes);\r\nif ((list_empty(&(cmd_mgr->free_list[index]))) ||\r\n(tgt->num_active_ios.counter >= max_sqes) ||\r\n(free_sqes + max_sqes <= BNX2FC_SQ_WQES_MAX)) {\r\nBNX2FC_TGT_DBG(tgt, "No free els_tm cmds available "\r\n"ios(%d):sqes(%d)\n",\r\ntgt->num_active_ios.counter, tgt->max_sqes);\r\nif (list_empty(&(cmd_mgr->free_list[index])))\r\nprintk(KERN_ERR PFX "elstm_alloc: list_empty\n");\r\nspin_unlock_bh(&cmd_mgr->free_list_lock[index]);\r\nreturn NULL;\r\n}\r\nlistp = (struct list_head *)\r\ncmd_mgr->free_list[index].next;\r\nlist_del_init(listp);\r\nio_req = (struct bnx2fc_cmd *) listp;\r\nxid = io_req->xid;\r\ncmd_mgr->cmds[xid] = io_req;\r\natomic_inc(&tgt->num_active_ios);\r\natomic_dec(&tgt->free_sqes);\r\nspin_unlock_bh(&cmd_mgr->free_list_lock[index]);\r\nINIT_LIST_HEAD(&io_req->link);\r\nio_req->port = port;\r\nio_req->cmd_mgr = cmd_mgr;\r\nio_req->req_flags = 0;\r\nio_req->cmd_type = type;\r\nbd_tbl = io_req->bd_tbl = cmd_mgr->io_bdt_pool[xid];\r\nbd_tbl->io_req = io_req;\r\nkref_init(&io_req->refcount);\r\nreturn io_req;\r\n}\r\nstruct bnx2fc_cmd *bnx2fc_cmd_alloc(struct bnx2fc_rport *tgt)\r\n{\r\nstruct fcoe_port *port = tgt->port;\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct bnx2fc_cmd_mgr *cmd_mgr = interface->hba->cmd_mgr;\r\nstruct bnx2fc_cmd *io_req;\r\nstruct list_head *listp;\r\nstruct io_bdt *bd_tbl;\r\nu32 free_sqes;\r\nu32 max_sqes;\r\nu16 xid;\r\nint index = get_cpu();\r\nmax_sqes = BNX2FC_SCSI_MAX_SQES;\r\nspin_lock_bh(&cmd_mgr->free_list_lock[index]);\r\nfree_sqes = atomic_read(&tgt->free_sqes);\r\nif ((list_empty(&cmd_mgr->free_list[index])) ||\r\n(tgt->num_active_ios.counter >= max_sqes) ||\r\n(free_sqes + max_sqes <= BNX2FC_SQ_WQES_MAX)) {\r\nspin_unlock_bh(&cmd_mgr->free_list_lock[index]);\r\nput_cpu();\r\nreturn NULL;\r\n}\r\nlistp = (struct list_head *)\r\ncmd_mgr->free_list[index].next;\r\nlist_del_init(listp);\r\nio_req = (struct bnx2fc_cmd *) listp;\r\nxid = io_req->xid;\r\ncmd_mgr->cmds[xid] = io_req;\r\natomic_inc(&tgt->num_active_ios);\r\natomic_dec(&tgt->free_sqes);\r\nspin_unlock_bh(&cmd_mgr->free_list_lock[index]);\r\nput_cpu();\r\nINIT_LIST_HEAD(&io_req->link);\r\nio_req->port = port;\r\nio_req->cmd_mgr = cmd_mgr;\r\nio_req->req_flags = 0;\r\nbd_tbl = io_req->bd_tbl = cmd_mgr->io_bdt_pool[xid];\r\nbd_tbl->io_req = io_req;\r\nkref_init(&io_req->refcount);\r\nreturn io_req;\r\n}\r\nvoid bnx2fc_cmd_release(struct kref *ref)\r\n{\r\nstruct bnx2fc_cmd *io_req = container_of(ref,\r\nstruct bnx2fc_cmd, refcount);\r\nstruct bnx2fc_cmd_mgr *cmd_mgr = io_req->cmd_mgr;\r\nint index;\r\nif (io_req->cmd_type == BNX2FC_SCSI_CMD)\r\nindex = io_req->xid % num_possible_cpus();\r\nelse\r\nindex = RESERVE_FREE_LIST_INDEX;\r\nspin_lock_bh(&cmd_mgr->free_list_lock[index]);\r\nif (io_req->cmd_type != BNX2FC_SCSI_CMD)\r\nbnx2fc_free_mp_resc(io_req);\r\ncmd_mgr->cmds[io_req->xid] = NULL;\r\nlist_del_init(&io_req->link);\r\nlist_add(&io_req->link,\r\n&cmd_mgr->free_list[index]);\r\natomic_dec(&io_req->tgt->num_active_ios);\r\nspin_unlock_bh(&cmd_mgr->free_list_lock[index]);\r\n}\r\nstatic void bnx2fc_free_mp_resc(struct bnx2fc_cmd *io_req)\r\n{\r\nstruct bnx2fc_mp_req *mp_req = &(io_req->mp_req);\r\nstruct bnx2fc_interface *interface = io_req->port->priv;\r\nstruct bnx2fc_hba *hba = interface->hba;\r\nsize_t sz = sizeof(struct fcoe_bd_ctx);\r\nmp_req->tm_flags = 0;\r\nif (mp_req->mp_req_bd) {\r\ndma_free_coherent(&hba->pcidev->dev, sz,\r\nmp_req->mp_req_bd,\r\nmp_req->mp_req_bd_dma);\r\nmp_req->mp_req_bd = NULL;\r\n}\r\nif (mp_req->mp_resp_bd) {\r\ndma_free_coherent(&hba->pcidev->dev, sz,\r\nmp_req->mp_resp_bd,\r\nmp_req->mp_resp_bd_dma);\r\nmp_req->mp_resp_bd = NULL;\r\n}\r\nif (mp_req->req_buf) {\r\ndma_free_coherent(&hba->pcidev->dev, PAGE_SIZE,\r\nmp_req->req_buf,\r\nmp_req->req_buf_dma);\r\nmp_req->req_buf = NULL;\r\n}\r\nif (mp_req->resp_buf) {\r\ndma_free_coherent(&hba->pcidev->dev, PAGE_SIZE,\r\nmp_req->resp_buf,\r\nmp_req->resp_buf_dma);\r\nmp_req->resp_buf = NULL;\r\n}\r\n}\r\nint bnx2fc_init_mp_req(struct bnx2fc_cmd *io_req)\r\n{\r\nstruct bnx2fc_mp_req *mp_req;\r\nstruct fcoe_bd_ctx *mp_req_bd;\r\nstruct fcoe_bd_ctx *mp_resp_bd;\r\nstruct bnx2fc_interface *interface = io_req->port->priv;\r\nstruct bnx2fc_hba *hba = interface->hba;\r\ndma_addr_t addr;\r\nsize_t sz;\r\nmp_req = (struct bnx2fc_mp_req *)&(io_req->mp_req);\r\nmemset(mp_req, 0, sizeof(struct bnx2fc_mp_req));\r\nmp_req->req_len = sizeof(struct fcp_cmnd);\r\nio_req->data_xfer_len = mp_req->req_len;\r\nmp_req->req_buf = dma_alloc_coherent(&hba->pcidev->dev, PAGE_SIZE,\r\n&mp_req->req_buf_dma,\r\nGFP_ATOMIC);\r\nif (!mp_req->req_buf) {\r\nprintk(KERN_ERR PFX "unable to alloc MP req buffer\n");\r\nbnx2fc_free_mp_resc(io_req);\r\nreturn FAILED;\r\n}\r\nmp_req->resp_buf = dma_alloc_coherent(&hba->pcidev->dev, PAGE_SIZE,\r\n&mp_req->resp_buf_dma,\r\nGFP_ATOMIC);\r\nif (!mp_req->resp_buf) {\r\nprintk(KERN_ERR PFX "unable to alloc TM resp buffer\n");\r\nbnx2fc_free_mp_resc(io_req);\r\nreturn FAILED;\r\n}\r\nmemset(mp_req->req_buf, 0, PAGE_SIZE);\r\nmemset(mp_req->resp_buf, 0, PAGE_SIZE);\r\nsz = sizeof(struct fcoe_bd_ctx);\r\nmp_req->mp_req_bd = dma_alloc_coherent(&hba->pcidev->dev, sz,\r\n&mp_req->mp_req_bd_dma,\r\nGFP_ATOMIC);\r\nif (!mp_req->mp_req_bd) {\r\nprintk(KERN_ERR PFX "unable to alloc MP req bd\n");\r\nbnx2fc_free_mp_resc(io_req);\r\nreturn FAILED;\r\n}\r\nmp_req->mp_resp_bd = dma_alloc_coherent(&hba->pcidev->dev, sz,\r\n&mp_req->mp_resp_bd_dma,\r\nGFP_ATOMIC);\r\nif (!mp_req->mp_req_bd) {\r\nprintk(KERN_ERR PFX "unable to alloc MP resp bd\n");\r\nbnx2fc_free_mp_resc(io_req);\r\nreturn FAILED;\r\n}\r\naddr = mp_req->req_buf_dma;\r\nmp_req_bd = mp_req->mp_req_bd;\r\nmp_req_bd->buf_addr_lo = (u32)addr & 0xffffffff;\r\nmp_req_bd->buf_addr_hi = (u32)((u64)addr >> 32);\r\nmp_req_bd->buf_len = PAGE_SIZE;\r\nmp_req_bd->flags = 0;\r\nmp_resp_bd = mp_req->mp_resp_bd;\r\naddr = mp_req->resp_buf_dma;\r\nmp_resp_bd->buf_addr_lo = (u32)addr & 0xffffffff;\r\nmp_resp_bd->buf_addr_hi = (u32)((u64)addr >> 32);\r\nmp_resp_bd->buf_len = PAGE_SIZE;\r\nmp_resp_bd->flags = 0;\r\nreturn SUCCESS;\r\n}\r\nstatic int bnx2fc_initiate_tmf(struct scsi_cmnd *sc_cmd, u8 tm_flags)\r\n{\r\nstruct fc_lport *lport;\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(sc_cmd->device));\r\nstruct fc_rport_libfc_priv *rp = rport->dd_data;\r\nstruct fcoe_port *port;\r\nstruct bnx2fc_interface *interface;\r\nstruct bnx2fc_rport *tgt;\r\nstruct bnx2fc_cmd *io_req;\r\nstruct bnx2fc_mp_req *tm_req;\r\nstruct fcoe_task_ctx_entry *task;\r\nstruct fcoe_task_ctx_entry *task_page;\r\nstruct Scsi_Host *host = sc_cmd->device->host;\r\nstruct fc_frame_header *fc_hdr;\r\nstruct fcp_cmnd *fcp_cmnd;\r\nint task_idx, index;\r\nint rc = SUCCESS;\r\nu16 xid;\r\nu32 sid, did;\r\nunsigned long start = jiffies;\r\nlport = shost_priv(host);\r\nport = lport_priv(lport);\r\ninterface = port->priv;\r\nif (rport == NULL) {\r\nprintk(KERN_ERR PFX "device_reset: rport is NULL\n");\r\nrc = FAILED;\r\ngoto tmf_err;\r\n}\r\nrc = fc_block_scsi_eh(sc_cmd);\r\nif (rc)\r\nreturn rc;\r\nif (lport->state != LPORT_ST_READY || !(lport->link_up)) {\r\nprintk(KERN_ERR PFX "device_reset: link is not ready\n");\r\nrc = FAILED;\r\ngoto tmf_err;\r\n}\r\ntgt = (struct bnx2fc_rport *)&rp[1];\r\nif (!(test_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags))) {\r\nprintk(KERN_ERR PFX "device_reset: tgt not offloaded\n");\r\nrc = FAILED;\r\ngoto tmf_err;\r\n}\r\nretry_tmf:\r\nio_req = bnx2fc_elstm_alloc(tgt, BNX2FC_TASK_MGMT_CMD);\r\nif (!io_req) {\r\nif (time_after(jiffies, start + HZ)) {\r\nprintk(KERN_ERR PFX "tmf: Failed TMF");\r\nrc = FAILED;\r\ngoto tmf_err;\r\n}\r\nmsleep(20);\r\ngoto retry_tmf;\r\n}\r\nio_req->sc_cmd = sc_cmd;\r\nio_req->port = port;\r\nio_req->tgt = tgt;\r\ntm_req = (struct bnx2fc_mp_req *)&(io_req->mp_req);\r\nrc = bnx2fc_init_mp_req(io_req);\r\nif (rc == FAILED) {\r\nprintk(KERN_ERR PFX "Task mgmt MP request init failed\n");\r\nspin_lock_bh(&tgt->tgt_lock);\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\ngoto tmf_err;\r\n}\r\nio_req->io_req_flags = 0;\r\ntm_req->tm_flags = tm_flags;\r\nbnx2fc_build_fcp_cmnd(io_req, (struct fcp_cmnd *)tm_req->req_buf);\r\nfcp_cmnd = (struct fcp_cmnd *)tm_req->req_buf;\r\nmemset(fcp_cmnd->fc_cdb, 0, sc_cmd->cmd_len);\r\nfcp_cmnd->fc_dl = 0;\r\nfc_hdr = &(tm_req->req_fc_hdr);\r\nsid = tgt->sid;\r\ndid = rport->port_id;\r\n__fc_fill_fc_hdr(fc_hdr, FC_RCTL_DD_UNSOL_CMD, did, sid,\r\nFC_TYPE_FCP, FC_FC_FIRST_SEQ | FC_FC_END_SEQ |\r\nFC_FC_SEQ_INIT, 0);\r\nxid = io_req->xid;\r\nBNX2FC_TGT_DBG(tgt, "Initiate TMF - xid = 0x%x\n", xid);\r\ntask_idx = xid/BNX2FC_TASKS_PER_PAGE;\r\nindex = xid % BNX2FC_TASKS_PER_PAGE;\r\ntask_page = (struct fcoe_task_ctx_entry *)\r\ninterface->hba->task_ctx[task_idx];\r\ntask = &(task_page[index]);\r\nbnx2fc_init_mp_task(io_req, task);\r\nsc_cmd->SCp.ptr = (char *)io_req;\r\nspin_lock_bh(&tgt->tgt_lock);\r\nbnx2fc_add_2_sq(tgt, xid);\r\nio_req->on_tmf_queue = 1;\r\nlist_add_tail(&io_req->link, &tgt->active_tm_queue);\r\ninit_completion(&io_req->tm_done);\r\nio_req->wait_for_comp = 1;\r\nbnx2fc_ring_doorbell(tgt);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nrc = wait_for_completion_timeout(&io_req->tm_done,\r\nBNX2FC_TM_TIMEOUT * HZ);\r\nspin_lock_bh(&tgt->tgt_lock);\r\nio_req->wait_for_comp = 0;\r\nif (!(test_bit(BNX2FC_FLAG_TM_COMPL, &io_req->req_flags)))\r\nset_bit(BNX2FC_FLAG_TM_TIMEOUT, &io_req->req_flags);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nif (!rc) {\r\nBNX2FC_TGT_DBG(tgt, "task mgmt command failed...\n");\r\nrc = FAILED;\r\n} else {\r\nBNX2FC_TGT_DBG(tgt, "task mgmt command success...\n");\r\nrc = SUCCESS;\r\n}\r\ntmf_err:\r\nreturn rc;\r\n}\r\nint bnx2fc_initiate_abts(struct bnx2fc_cmd *io_req)\r\n{\r\nstruct fc_lport *lport;\r\nstruct bnx2fc_rport *tgt = io_req->tgt;\r\nstruct fc_rport *rport = tgt->rport;\r\nstruct fc_rport_priv *rdata = tgt->rdata;\r\nstruct bnx2fc_interface *interface;\r\nstruct fcoe_port *port;\r\nstruct bnx2fc_cmd *abts_io_req;\r\nstruct fcoe_task_ctx_entry *task;\r\nstruct fcoe_task_ctx_entry *task_page;\r\nstruct fc_frame_header *fc_hdr;\r\nstruct bnx2fc_mp_req *abts_req;\r\nint task_idx, index;\r\nu32 sid, did;\r\nu16 xid;\r\nint rc = SUCCESS;\r\nu32 r_a_tov = rdata->r_a_tov;\r\nBNX2FC_IO_DBG(io_req, "Entered bnx2fc_initiate_abts\n");\r\nport = io_req->port;\r\ninterface = port->priv;\r\nlport = port->lport;\r\nif (!test_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags)) {\r\nprintk(KERN_ERR PFX "initiate_abts: tgt not offloaded\n");\r\nrc = FAILED;\r\ngoto abts_err;\r\n}\r\nif (rport == NULL) {\r\nprintk(KERN_ERR PFX "initiate_abts: rport is NULL\n");\r\nrc = FAILED;\r\ngoto abts_err;\r\n}\r\nif (lport->state != LPORT_ST_READY || !(lport->link_up)) {\r\nprintk(KERN_ERR PFX "initiate_abts: link is not ready\n");\r\nrc = FAILED;\r\ngoto abts_err;\r\n}\r\nabts_io_req = bnx2fc_elstm_alloc(tgt, BNX2FC_ABTS);\r\nif (!abts_io_req) {\r\nprintk(KERN_ERR PFX "abts: couldnt allocate cmd\n");\r\nrc = FAILED;\r\ngoto abts_err;\r\n}\r\nabts_io_req->sc_cmd = NULL;\r\nabts_io_req->port = port;\r\nabts_io_req->tgt = tgt;\r\nabts_io_req->data_xfer_len = 0;\r\nabts_req = (struct bnx2fc_mp_req *)&(abts_io_req->mp_req);\r\nmemset(abts_req, 0, sizeof(struct bnx2fc_mp_req));\r\nfc_hdr = &(abts_req->req_fc_hdr);\r\nfc_hdr->fh_ox_id = htons(io_req->xid);\r\nfc_hdr->fh_rx_id = htons(io_req->task->rxwr_txrd.var_ctx.rx_id);\r\nsid = tgt->sid;\r\ndid = rport->port_id;\r\n__fc_fill_fc_hdr(fc_hdr, FC_RCTL_BA_ABTS, did, sid,\r\nFC_TYPE_BLS, FC_FC_FIRST_SEQ | FC_FC_END_SEQ |\r\nFC_FC_SEQ_INIT, 0);\r\nxid = abts_io_req->xid;\r\nBNX2FC_IO_DBG(abts_io_req, "ABTS io_req\n");\r\ntask_idx = xid/BNX2FC_TASKS_PER_PAGE;\r\nindex = xid % BNX2FC_TASKS_PER_PAGE;\r\ntask_page = (struct fcoe_task_ctx_entry *)\r\ninterface->hba->task_ctx[task_idx];\r\ntask = &(task_page[index]);\r\nbnx2fc_init_mp_task(abts_io_req, task);\r\nbnx2fc_cmd_timer_set(io_req, 2 * r_a_tov);\r\nbnx2fc_add_2_sq(tgt, xid);\r\nbnx2fc_ring_doorbell(tgt);\r\nabts_err:\r\nreturn rc;\r\n}\r\nint bnx2fc_initiate_seq_cleanup(struct bnx2fc_cmd *orig_io_req, u32 offset,\r\nenum fc_rctl r_ctl)\r\n{\r\nstruct fc_lport *lport;\r\nstruct bnx2fc_rport *tgt = orig_io_req->tgt;\r\nstruct bnx2fc_interface *interface;\r\nstruct fcoe_port *port;\r\nstruct bnx2fc_cmd *seq_clnp_req;\r\nstruct fcoe_task_ctx_entry *task;\r\nstruct fcoe_task_ctx_entry *task_page;\r\nstruct bnx2fc_els_cb_arg *cb_arg = NULL;\r\nint task_idx, index;\r\nu16 xid;\r\nint rc = 0;\r\nBNX2FC_IO_DBG(orig_io_req, "bnx2fc_initiate_seq_cleanup xid = 0x%x\n",\r\norig_io_req->xid);\r\nkref_get(&orig_io_req->refcount);\r\nport = orig_io_req->port;\r\ninterface = port->priv;\r\nlport = port->lport;\r\ncb_arg = kzalloc(sizeof(struct bnx2fc_els_cb_arg), GFP_ATOMIC);\r\nif (!cb_arg) {\r\nprintk(KERN_ERR PFX "Unable to alloc cb_arg for seq clnup\n");\r\nrc = -ENOMEM;\r\ngoto cleanup_err;\r\n}\r\nseq_clnp_req = bnx2fc_elstm_alloc(tgt, BNX2FC_SEQ_CLEANUP);\r\nif (!seq_clnp_req) {\r\nprintk(KERN_ERR PFX "cleanup: couldnt allocate cmd\n");\r\nrc = -ENOMEM;\r\nkfree(cb_arg);\r\ngoto cleanup_err;\r\n}\r\nseq_clnp_req->sc_cmd = NULL;\r\nseq_clnp_req->port = port;\r\nseq_clnp_req->tgt = tgt;\r\nseq_clnp_req->data_xfer_len = 0;\r\nxid = seq_clnp_req->xid;\r\ntask_idx = xid/BNX2FC_TASKS_PER_PAGE;\r\nindex = xid % BNX2FC_TASKS_PER_PAGE;\r\ntask_page = (struct fcoe_task_ctx_entry *)\r\ninterface->hba->task_ctx[task_idx];\r\ntask = &(task_page[index]);\r\ncb_arg->aborted_io_req = orig_io_req;\r\ncb_arg->io_req = seq_clnp_req;\r\ncb_arg->r_ctl = r_ctl;\r\ncb_arg->offset = offset;\r\nseq_clnp_req->cb_arg = cb_arg;\r\nprintk(KERN_ERR PFX "call init_seq_cleanup_task\n");\r\nbnx2fc_init_seq_cleanup_task(seq_clnp_req, task, orig_io_req, offset);\r\nbnx2fc_add_2_sq(tgt, xid);\r\nbnx2fc_ring_doorbell(tgt);\r\ncleanup_err:\r\nreturn rc;\r\n}\r\nint bnx2fc_initiate_cleanup(struct bnx2fc_cmd *io_req)\r\n{\r\nstruct fc_lport *lport;\r\nstruct bnx2fc_rport *tgt = io_req->tgt;\r\nstruct bnx2fc_interface *interface;\r\nstruct fcoe_port *port;\r\nstruct bnx2fc_cmd *cleanup_io_req;\r\nstruct fcoe_task_ctx_entry *task;\r\nstruct fcoe_task_ctx_entry *task_page;\r\nint task_idx, index;\r\nu16 xid, orig_xid;\r\nint rc = 0;\r\nBNX2FC_IO_DBG(io_req, "Entered bnx2fc_initiate_cleanup\n");\r\nport = io_req->port;\r\ninterface = port->priv;\r\nlport = port->lport;\r\ncleanup_io_req = bnx2fc_elstm_alloc(tgt, BNX2FC_CLEANUP);\r\nif (!cleanup_io_req) {\r\nprintk(KERN_ERR PFX "cleanup: couldnt allocate cmd\n");\r\nrc = -1;\r\ngoto cleanup_err;\r\n}\r\ncleanup_io_req->sc_cmd = NULL;\r\ncleanup_io_req->port = port;\r\ncleanup_io_req->tgt = tgt;\r\ncleanup_io_req->data_xfer_len = 0;\r\nxid = cleanup_io_req->xid;\r\ntask_idx = xid/BNX2FC_TASKS_PER_PAGE;\r\nindex = xid % BNX2FC_TASKS_PER_PAGE;\r\ntask_page = (struct fcoe_task_ctx_entry *)\r\ninterface->hba->task_ctx[task_idx];\r\ntask = &(task_page[index]);\r\norig_xid = io_req->xid;\r\nBNX2FC_IO_DBG(io_req, "CLEANUP io_req xid = 0x%x\n", xid);\r\nbnx2fc_init_cleanup_task(cleanup_io_req, task, orig_xid);\r\nbnx2fc_add_2_sq(tgt, xid);\r\nbnx2fc_ring_doorbell(tgt);\r\ncleanup_err:\r\nreturn rc;\r\n}\r\nint bnx2fc_eh_target_reset(struct scsi_cmnd *sc_cmd)\r\n{\r\nreturn bnx2fc_initiate_tmf(sc_cmd, FCP_TMF_TGT_RESET);\r\n}\r\nint bnx2fc_eh_device_reset(struct scsi_cmnd *sc_cmd)\r\n{\r\nreturn bnx2fc_initiate_tmf(sc_cmd, FCP_TMF_LUN_RESET);\r\n}\r\nint bnx2fc_eh_abort(struct scsi_cmnd *sc_cmd)\r\n{\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(sc_cmd->device));\r\nstruct fc_rport_libfc_priv *rp = rport->dd_data;\r\nstruct bnx2fc_cmd *io_req;\r\nstruct fc_lport *lport;\r\nstruct fc_rport_priv *rdata;\r\nstruct bnx2fc_rport *tgt;\r\nint logo_issued;\r\nint wait_cnt = 0;\r\nint rc = FAILED;\r\nrc = fc_block_scsi_eh(sc_cmd);\r\nif (rc)\r\nreturn rc;\r\nlport = shost_priv(sc_cmd->device->host);\r\nif ((lport->state != LPORT_ST_READY) || !(lport->link_up)) {\r\nprintk(KERN_ERR PFX "eh_abort: link not ready\n");\r\nreturn rc;\r\n}\r\ntgt = (struct bnx2fc_rport *)&rp[1];\r\nBNX2FC_TGT_DBG(tgt, "Entered bnx2fc_eh_abort\n");\r\nspin_lock_bh(&tgt->tgt_lock);\r\nio_req = (struct bnx2fc_cmd *)sc_cmd->SCp.ptr;\r\nif (!io_req) {\r\nprintk(KERN_ERR PFX "eh_abort: io_req is NULL\n");\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nreturn SUCCESS;\r\n}\r\nBNX2FC_IO_DBG(io_req, "eh_abort - refcnt = %d\n",\r\nio_req->refcount.refcount.counter);\r\nkref_get(&io_req->refcount);\r\nBUG_ON(tgt != io_req->tgt);\r\nif (tgt->flush_in_prog) {\r\nprintk(KERN_ERR PFX "eh_abort: io_req (xid = 0x%x) "\r\n"flush in progress\n", io_req->xid);\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nreturn SUCCESS;\r\n}\r\nif (io_req->on_active_queue == 0) {\r\nprintk(KERN_ERR PFX "eh_abort: io_req (xid = 0x%x) "\r\n"not on active_q\n", io_req->xid);\r\nbnx2fc_scsi_done(io_req, DID_ABORT);\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nreturn SUCCESS;\r\n}\r\nlist_del_init(&io_req->link);\r\nio_req->on_active_queue = 0;\r\nlist_add_tail(&io_req->link, &tgt->io_retire_queue);\r\ninit_completion(&io_req->tm_done);\r\nio_req->wait_for_comp = 1;\r\nif (!test_and_set_bit(BNX2FC_FLAG_ISSUE_ABTS, &io_req->req_flags)) {\r\nif (cancel_delayed_work(&io_req->timeout_work))\r\nkref_put(&io_req->refcount,\r\nbnx2fc_cmd_release);\r\nset_bit(BNX2FC_FLAG_EH_ABORT, &io_req->req_flags);\r\nrc = bnx2fc_initiate_abts(io_req);\r\n} else {\r\nprintk(KERN_ERR PFX "eh_abort: io_req (xid = 0x%x) "\r\n"already in abts processing\n", io_req->xid);\r\nif (cancel_delayed_work(&io_req->timeout_work))\r\nkref_put(&io_req->refcount,\r\nbnx2fc_cmd_release);\r\nbnx2fc_initiate_cleanup(io_req);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nwait_for_completion(&io_req->tm_done);\r\nspin_lock_bh(&tgt->tgt_lock);\r\nio_req->wait_for_comp = 0;\r\nrdata = io_req->tgt->rdata;\r\nlogo_issued = test_and_set_bit(BNX2FC_FLAG_EXPL_LOGO,\r\n&tgt->flags);\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nif (!logo_issued) {\r\nBNX2FC_IO_DBG(io_req, "Expl logo - tgt flags = 0x%lx\n",\r\ntgt->flags);\r\nmutex_lock(&lport->disc.disc_mutex);\r\nlport->tt.rport_logoff(rdata);\r\nmutex_unlock(&lport->disc.disc_mutex);\r\ndo {\r\nmsleep(BNX2FC_RELOGIN_WAIT_TIME);\r\nif (wait_cnt++ > BNX2FC_RELOGIN_WAIT_CNT)\r\nreturn FAILED;\r\n} while (!test_bit(BNX2FC_FLAG_SESSION_READY,\r\n&tgt->flags));\r\n}\r\nreturn SUCCESS;\r\n}\r\nif (rc == FAILED) {\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nreturn rc;\r\n}\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nwait_for_completion(&io_req->tm_done);\r\nspin_lock_bh(&tgt->tgt_lock);\r\nio_req->wait_for_comp = 0;\r\nif (!(test_and_set_bit(BNX2FC_FLAG_ABTS_DONE,\r\n&io_req->req_flags))) {\r\nprintk(KERN_ERR PFX "abort failed, xid = 0x%x\n",\r\nio_req->xid);\r\nrc = FAILED;\r\n} else {\r\nBNX2FC_IO_DBG(io_req, "abort succeeded\n");\r\nrc = SUCCESS;\r\nbnx2fc_scsi_done(io_req, DID_ABORT);\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\n}\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nreturn rc;\r\n}\r\nvoid bnx2fc_process_seq_cleanup_compl(struct bnx2fc_cmd *seq_clnp_req,\r\nstruct fcoe_task_ctx_entry *task,\r\nu8 rx_state)\r\n{\r\nstruct bnx2fc_els_cb_arg *cb_arg = seq_clnp_req->cb_arg;\r\nstruct bnx2fc_cmd *orig_io_req = cb_arg->aborted_io_req;\r\nu32 offset = cb_arg->offset;\r\nenum fc_rctl r_ctl = cb_arg->r_ctl;\r\nint rc = 0;\r\nstruct bnx2fc_rport *tgt = orig_io_req->tgt;\r\nBNX2FC_IO_DBG(orig_io_req, "Entered process_cleanup_compl xid = 0x%x"\r\n"cmd_type = %d\n",\r\nseq_clnp_req->xid, seq_clnp_req->cmd_type);\r\nif (rx_state == FCOE_TASK_RX_STATE_IGNORED_SEQUENCE_CLEANUP) {\r\nprintk(KERN_ERR PFX "seq cleanup ignored - xid = 0x%x\n",\r\nseq_clnp_req->xid);\r\ngoto free_cb_arg;\r\n}\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nrc = bnx2fc_send_srr(orig_io_req, offset, r_ctl);\r\nspin_lock_bh(&tgt->tgt_lock);\r\nif (rc)\r\nprintk(KERN_ERR PFX "clnup_compl: Unable to send SRR"\r\n" IO will abort\n");\r\nseq_clnp_req->cb_arg = NULL;\r\nkref_put(&orig_io_req->refcount, bnx2fc_cmd_release);\r\nfree_cb_arg:\r\nkfree(cb_arg);\r\nreturn;\r\n}\r\nvoid bnx2fc_process_cleanup_compl(struct bnx2fc_cmd *io_req,\r\nstruct fcoe_task_ctx_entry *task,\r\nu8 num_rq)\r\n{\r\nBNX2FC_IO_DBG(io_req, "Entered process_cleanup_compl "\r\n"refcnt = %d, cmd_type = %d\n",\r\nio_req->refcount.refcount.counter, io_req->cmd_type);\r\nbnx2fc_scsi_done(io_req, DID_ERROR);\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\nif (io_req->wait_for_comp)\r\ncomplete(&io_req->tm_done);\r\n}\r\nvoid bnx2fc_process_abts_compl(struct bnx2fc_cmd *io_req,\r\nstruct fcoe_task_ctx_entry *task,\r\nu8 num_rq)\r\n{\r\nu32 r_ctl;\r\nu32 r_a_tov = FC_DEF_R_A_TOV;\r\nu8 issue_rrq = 0;\r\nstruct bnx2fc_rport *tgt = io_req->tgt;\r\nBNX2FC_IO_DBG(io_req, "Entered process_abts_compl xid = 0x%x"\r\n"refcnt = %d, cmd_type = %d\n",\r\nio_req->xid,\r\nio_req->refcount.refcount.counter, io_req->cmd_type);\r\nif (test_and_set_bit(BNX2FC_FLAG_ABTS_DONE,\r\n&io_req->req_flags)) {\r\nBNX2FC_IO_DBG(io_req, "Timer context finished processing"\r\n" this io\n");\r\nreturn;\r\n}\r\nif (test_and_set_bit(BNX2FC_FLAG_IO_CLEANUP,\r\n&io_req->req_flags))\r\ngoto io_compl;\r\nif (test_bit(BNX2FC_FLAG_ISSUE_ABTS, &io_req->req_flags))\r\nif (cancel_delayed_work(&io_req->timeout_work))\r\nkref_put(&io_req->refcount,\r\nbnx2fc_cmd_release);\r\nr_ctl = (u8)task->rxwr_only.union_ctx.comp_info.abts_rsp.r_ctl;\r\nswitch (r_ctl) {\r\ncase FC_RCTL_BA_ACC:\r\nBNX2FC_IO_DBG(io_req, "ABTS response - ACC Send RRQ\n");\r\nissue_rrq = 1;\r\nbreak;\r\ncase FC_RCTL_BA_RJT:\r\nBNX2FC_IO_DBG(io_req, "ABTS response - RJT\n");\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR PFX "Unknown ABTS response\n");\r\nbreak;\r\n}\r\nif (issue_rrq) {\r\nBNX2FC_IO_DBG(io_req, "Issue RRQ after R_A_TOV\n");\r\nset_bit(BNX2FC_FLAG_ISSUE_RRQ, &io_req->req_flags);\r\n}\r\nset_bit(BNX2FC_FLAG_RETIRE_OXID, &io_req->req_flags);\r\nbnx2fc_cmd_timer_set(io_req, r_a_tov);\r\nio_compl:\r\nif (io_req->wait_for_comp) {\r\nif (test_and_clear_bit(BNX2FC_FLAG_EH_ABORT,\r\n&io_req->req_flags))\r\ncomplete(&io_req->tm_done);\r\n} else {\r\nif (io_req->on_active_queue) {\r\nlist_del_init(&io_req->link);\r\nio_req->on_active_queue = 0;\r\nlist_add_tail(&io_req->link, &tgt->io_retire_queue);\r\n}\r\nbnx2fc_scsi_done(io_req, DID_ERROR);\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\n}\r\n}\r\nstatic void bnx2fc_lun_reset_cmpl(struct bnx2fc_cmd *io_req)\r\n{\r\nstruct scsi_cmnd *sc_cmd = io_req->sc_cmd;\r\nstruct bnx2fc_rport *tgt = io_req->tgt;\r\nstruct list_head *list;\r\nstruct list_head *tmp;\r\nstruct bnx2fc_cmd *cmd;\r\nint tm_lun = sc_cmd->device->lun;\r\nint rc = 0;\r\nint lun;\r\nBNX2FC_IO_DBG(io_req, "Entered bnx2fc_lun_reset_cmpl\n");\r\nlist_for_each_safe(list, tmp, &tgt->active_cmd_queue) {\r\nBNX2FC_TGT_DBG(tgt, "LUN RST cmpl: scan for pending IOs\n");\r\ncmd = (struct bnx2fc_cmd *)list;\r\nlun = cmd->sc_cmd->device->lun;\r\nif (lun == tm_lun) {\r\nif (!test_and_set_bit(BNX2FC_FLAG_ISSUE_ABTS,\r\n&cmd->req_flags)) {\r\nif (cancel_delayed_work(&io_req->timeout_work))\r\nkref_put(&io_req->refcount,\r\nbnx2fc_cmd_release);\r\nrc = bnx2fc_initiate_abts(cmd);\r\nWARN_ON(rc != SUCCESS);\r\n} else\r\nprintk(KERN_ERR PFX "lun_rst: abts already in"\r\n" progress for this IO 0x%x\n",\r\ncmd->xid);\r\n}\r\n}\r\n}\r\nstatic void bnx2fc_tgt_reset_cmpl(struct bnx2fc_cmd *io_req)\r\n{\r\nstruct bnx2fc_rport *tgt = io_req->tgt;\r\nstruct list_head *list;\r\nstruct list_head *tmp;\r\nstruct bnx2fc_cmd *cmd;\r\nint rc = 0;\r\nBNX2FC_IO_DBG(io_req, "Entered bnx2fc_tgt_reset_cmpl\n");\r\nlist_for_each_safe(list, tmp, &tgt->active_cmd_queue) {\r\nBNX2FC_TGT_DBG(tgt, "TGT RST cmpl: scan for pending IOs\n");\r\ncmd = (struct bnx2fc_cmd *)list;\r\nif (!test_and_set_bit(BNX2FC_FLAG_ISSUE_ABTS,\r\n&cmd->req_flags)) {\r\nif (cancel_delayed_work(&io_req->timeout_work))\r\nkref_put(&io_req->refcount,\r\nbnx2fc_cmd_release);\r\nrc = bnx2fc_initiate_abts(cmd);\r\nWARN_ON(rc != SUCCESS);\r\n} else\r\nprintk(KERN_ERR PFX "tgt_rst: abts already in progress"\r\n" for this IO 0x%x\n", cmd->xid);\r\n}\r\n}\r\nvoid bnx2fc_process_tm_compl(struct bnx2fc_cmd *io_req,\r\nstruct fcoe_task_ctx_entry *task, u8 num_rq)\r\n{\r\nstruct bnx2fc_mp_req *tm_req;\r\nstruct fc_frame_header *fc_hdr;\r\nstruct scsi_cmnd *sc_cmd = io_req->sc_cmd;\r\nu64 *hdr;\r\nu64 *temp_hdr;\r\nvoid *rsp_buf;\r\nBNX2FC_IO_DBG(io_req, "Entered process_tm_compl\n");\r\nif (!(test_bit(BNX2FC_FLAG_TM_TIMEOUT, &io_req->req_flags)))\r\nset_bit(BNX2FC_FLAG_TM_COMPL, &io_req->req_flags);\r\nelse {\r\nreturn;\r\n}\r\ntm_req = &(io_req->mp_req);\r\nfc_hdr = &(tm_req->resp_fc_hdr);\r\nhdr = (u64 *)fc_hdr;\r\ntemp_hdr = (u64 *)\r\n&task->rxwr_only.union_ctx.comp_info.mp_rsp.fc_hdr;\r\nhdr[0] = cpu_to_be64(temp_hdr[0]);\r\nhdr[1] = cpu_to_be64(temp_hdr[1]);\r\nhdr[2] = cpu_to_be64(temp_hdr[2]);\r\ntm_req->resp_len =\r\ntask->rxwr_only.union_ctx.comp_info.mp_rsp.mp_payload_len;\r\nrsp_buf = tm_req->resp_buf;\r\nif (fc_hdr->fh_r_ctl == FC_RCTL_DD_CMD_STATUS) {\r\nbnx2fc_parse_fcp_rsp(io_req,\r\n(struct fcoe_fcp_rsp_payload *)\r\nrsp_buf, num_rq);\r\nif (io_req->fcp_rsp_code == 0) {\r\nif (tm_req->tm_flags & FCP_TMF_LUN_RESET)\r\nbnx2fc_lun_reset_cmpl(io_req);\r\nelse if (tm_req->tm_flags & FCP_TMF_TGT_RESET)\r\nbnx2fc_tgt_reset_cmpl(io_req);\r\n}\r\n} else {\r\nprintk(KERN_ERR PFX "tmf's fc_hdr r_ctl = 0x%x\n",\r\nfc_hdr->fh_r_ctl);\r\n}\r\nif (!sc_cmd->SCp.ptr) {\r\nprintk(KERN_ERR PFX "tm_compl: SCp.ptr is NULL\n");\r\nreturn;\r\n}\r\nswitch (io_req->fcp_status) {\r\ncase FC_GOOD:\r\nif (io_req->cdb_status == 0) {\r\nsc_cmd->result = DID_OK << 16;\r\n} else {\r\nsc_cmd->result = (DID_OK << 16) | io_req->cdb_status;\r\n}\r\nif (io_req->fcp_resid)\r\nscsi_set_resid(sc_cmd, io_req->fcp_resid);\r\nbreak;\r\ndefault:\r\nBNX2FC_IO_DBG(io_req, "process_tm_compl: fcp_status = %d\n",\r\nio_req->fcp_status);\r\nbreak;\r\n}\r\nsc_cmd = io_req->sc_cmd;\r\nio_req->sc_cmd = NULL;\r\nif (io_req->on_tmf_queue) {\r\nlist_del_init(&io_req->link);\r\nio_req->on_tmf_queue = 0;\r\n} else {\r\nprintk(KERN_ERR PFX "Command not on active_cmd_queue!\n");\r\nreturn;\r\n}\r\nsc_cmd->SCp.ptr = NULL;\r\nsc_cmd->scsi_done(sc_cmd);\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\nif (io_req->wait_for_comp) {\r\nBNX2FC_IO_DBG(io_req, "tm_compl - wake up the waiter\n");\r\ncomplete(&io_req->tm_done);\r\n}\r\n}\r\nstatic int bnx2fc_split_bd(struct bnx2fc_cmd *io_req, u64 addr, int sg_len,\r\nint bd_index)\r\n{\r\nstruct fcoe_bd_ctx *bd = io_req->bd_tbl->bd_tbl;\r\nint frag_size, sg_frags;\r\nsg_frags = 0;\r\nwhile (sg_len) {\r\nif (sg_len >= BNX2FC_BD_SPLIT_SZ)\r\nfrag_size = BNX2FC_BD_SPLIT_SZ;\r\nelse\r\nfrag_size = sg_len;\r\nbd[bd_index + sg_frags].buf_addr_lo = addr & 0xffffffff;\r\nbd[bd_index + sg_frags].buf_addr_hi = addr >> 32;\r\nbd[bd_index + sg_frags].buf_len = (u16)frag_size;\r\nbd[bd_index + sg_frags].flags = 0;\r\naddr += (u64) frag_size;\r\nsg_frags++;\r\nsg_len -= frag_size;\r\n}\r\nreturn sg_frags;\r\n}\r\nstatic int bnx2fc_map_sg(struct bnx2fc_cmd *io_req)\r\n{\r\nstruct bnx2fc_interface *interface = io_req->port->priv;\r\nstruct bnx2fc_hba *hba = interface->hba;\r\nstruct scsi_cmnd *sc = io_req->sc_cmd;\r\nstruct fcoe_bd_ctx *bd = io_req->bd_tbl->bd_tbl;\r\nstruct scatterlist *sg;\r\nint byte_count = 0;\r\nint sg_count = 0;\r\nint bd_count = 0;\r\nint sg_frags;\r\nunsigned int sg_len;\r\nu64 addr;\r\nint i;\r\nsg_count = dma_map_sg(&hba->pcidev->dev, scsi_sglist(sc),\r\nscsi_sg_count(sc), sc->sc_data_direction);\r\nscsi_for_each_sg(sc, sg, sg_count, i) {\r\nsg_len = sg_dma_len(sg);\r\naddr = sg_dma_address(sg);\r\nif (sg_len > BNX2FC_MAX_BD_LEN) {\r\nsg_frags = bnx2fc_split_bd(io_req, addr, sg_len,\r\nbd_count);\r\n} else {\r\nsg_frags = 1;\r\nbd[bd_count].buf_addr_lo = addr & 0xffffffff;\r\nbd[bd_count].buf_addr_hi = addr >> 32;\r\nbd[bd_count].buf_len = (u16)sg_len;\r\nbd[bd_count].flags = 0;\r\n}\r\nbd_count += sg_frags;\r\nbyte_count += sg_len;\r\n}\r\nif (byte_count != scsi_bufflen(sc))\r\nprintk(KERN_ERR PFX "byte_count = %d != scsi_bufflen = %d, "\r\n"task_id = 0x%x\n", byte_count, scsi_bufflen(sc),\r\nio_req->xid);\r\nreturn bd_count;\r\n}\r\nstatic int bnx2fc_build_bd_list_from_sg(struct bnx2fc_cmd *io_req)\r\n{\r\nstruct scsi_cmnd *sc = io_req->sc_cmd;\r\nstruct fcoe_bd_ctx *bd = io_req->bd_tbl->bd_tbl;\r\nint bd_count;\r\nif (scsi_sg_count(sc)) {\r\nbd_count = bnx2fc_map_sg(io_req);\r\nif (bd_count == 0)\r\nreturn -ENOMEM;\r\n} else {\r\nbd_count = 0;\r\nbd[0].buf_addr_lo = bd[0].buf_addr_hi = 0;\r\nbd[0].buf_len = bd[0].flags = 0;\r\n}\r\nio_req->bd_tbl->bd_valid = bd_count;\r\nreturn 0;\r\n}\r\nstatic void bnx2fc_unmap_sg_list(struct bnx2fc_cmd *io_req)\r\n{\r\nstruct scsi_cmnd *sc = io_req->sc_cmd;\r\nif (io_req->bd_tbl->bd_valid && sc) {\r\nscsi_dma_unmap(sc);\r\nio_req->bd_tbl->bd_valid = 0;\r\n}\r\n}\r\nvoid bnx2fc_build_fcp_cmnd(struct bnx2fc_cmd *io_req,\r\nstruct fcp_cmnd *fcp_cmnd)\r\n{\r\nstruct scsi_cmnd *sc_cmd = io_req->sc_cmd;\r\nchar tag[2];\r\nmemset(fcp_cmnd, 0, sizeof(struct fcp_cmnd));\r\nint_to_scsilun(sc_cmd->device->lun,\r\n(struct scsi_lun *) fcp_cmnd->fc_lun);\r\nfcp_cmnd->fc_dl = htonl(io_req->data_xfer_len);\r\nmemcpy(fcp_cmnd->fc_cdb, sc_cmd->cmnd, sc_cmd->cmd_len);\r\nfcp_cmnd->fc_cmdref = 0;\r\nfcp_cmnd->fc_pri_ta = 0;\r\nfcp_cmnd->fc_tm_flags = io_req->mp_req.tm_flags;\r\nfcp_cmnd->fc_flags = io_req->io_req_flags;\r\nif (scsi_populate_tag_msg(sc_cmd, tag)) {\r\nswitch (tag[0]) {\r\ncase HEAD_OF_QUEUE_TAG:\r\nfcp_cmnd->fc_pri_ta = FCP_PTA_HEADQ;\r\nbreak;\r\ncase ORDERED_QUEUE_TAG:\r\nfcp_cmnd->fc_pri_ta = FCP_PTA_ORDERED;\r\nbreak;\r\ndefault:\r\nfcp_cmnd->fc_pri_ta = FCP_PTA_SIMPLE;\r\nbreak;\r\n}\r\n} else {\r\nfcp_cmnd->fc_pri_ta = 0;\r\n}\r\n}\r\nstatic void bnx2fc_parse_fcp_rsp(struct bnx2fc_cmd *io_req,\r\nstruct fcoe_fcp_rsp_payload *fcp_rsp,\r\nu8 num_rq)\r\n{\r\nstruct scsi_cmnd *sc_cmd = io_req->sc_cmd;\r\nstruct bnx2fc_rport *tgt = io_req->tgt;\r\nu8 rsp_flags = fcp_rsp->fcp_flags.flags;\r\nu32 rq_buff_len = 0;\r\nint i;\r\nunsigned char *rq_data;\r\nunsigned char *dummy;\r\nint fcp_sns_len = 0;\r\nint fcp_rsp_len = 0;\r\nio_req->fcp_status = FC_GOOD;\r\nio_req->fcp_resid = fcp_rsp->fcp_resid;\r\nio_req->scsi_comp_flags = rsp_flags;\r\nCMD_SCSI_STATUS(sc_cmd) = io_req->cdb_status =\r\nfcp_rsp->scsi_status_code;\r\nif (num_rq) {\r\nif (rsp_flags &\r\nFCOE_FCP_RSP_FLAGS_FCP_RSP_LEN_VALID) {\r\nfcp_rsp_len = rq_buff_len\r\n= fcp_rsp->fcp_rsp_len;\r\n}\r\nif (rsp_flags &\r\nFCOE_FCP_RSP_FLAGS_FCP_SNS_LEN_VALID) {\r\nfcp_sns_len = fcp_rsp->fcp_sns_len;\r\nrq_buff_len += fcp_rsp->fcp_sns_len;\r\n}\r\nio_req->fcp_rsp_len = fcp_rsp_len;\r\nio_req->fcp_sns_len = fcp_sns_len;\r\nif (rq_buff_len > num_rq * BNX2FC_RQ_BUF_SZ) {\r\nprintk(KERN_ERR PFX "invalid sns length %d\n",\r\nrq_buff_len);\r\nrq_buff_len = num_rq * BNX2FC_RQ_BUF_SZ;\r\n}\r\nrq_data = bnx2fc_get_next_rqe(tgt, 1);\r\nif (num_rq > 1) {\r\nfor (i = 1; i < num_rq; i++)\r\ndummy = bnx2fc_get_next_rqe(tgt, 1);\r\n}\r\nif ((fcp_rsp_len == 4) || (fcp_rsp_len == 8)) {\r\nio_req->fcp_rsp_code = rq_data[3];\r\nprintk(KERN_ERR PFX "fcp_rsp_code = %d\n",\r\nio_req->fcp_rsp_code);\r\n}\r\nrq_data += fcp_rsp_len;\r\nif (fcp_sns_len > SCSI_SENSE_BUFFERSIZE) {\r\nprintk(KERN_ERR PFX "Truncating sense buffer\n");\r\nfcp_sns_len = SCSI_SENSE_BUFFERSIZE;\r\n}\r\nmemset(sc_cmd->sense_buffer, 0, sizeof(sc_cmd->sense_buffer));\r\nif (fcp_sns_len)\r\nmemcpy(sc_cmd->sense_buffer, rq_data, fcp_sns_len);\r\nfor (i = 0; i < num_rq; i++)\r\nbnx2fc_return_rqe(tgt, 1);\r\n}\r\n}\r\nint bnx2fc_queuecommand(struct Scsi_Host *host,\r\nstruct scsi_cmnd *sc_cmd)\r\n{\r\nstruct fc_lport *lport = shost_priv(host);\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(sc_cmd->device));\r\nstruct fc_rport_libfc_priv *rp = rport->dd_data;\r\nstruct bnx2fc_rport *tgt;\r\nstruct bnx2fc_cmd *io_req;\r\nint rc = 0;\r\nint rval;\r\nrval = fc_remote_port_chkready(rport);\r\nif (rval) {\r\nsc_cmd->result = rval;\r\nsc_cmd->scsi_done(sc_cmd);\r\nreturn 0;\r\n}\r\nif ((lport->state != LPORT_ST_READY) || !(lport->link_up)) {\r\nrc = SCSI_MLQUEUE_HOST_BUSY;\r\ngoto exit_qcmd;\r\n}\r\ntgt = (struct bnx2fc_rport *)&rp[1];\r\nif (!test_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags)) {\r\nrc = SCSI_MLQUEUE_TARGET_BUSY;\r\ngoto exit_qcmd;\r\n}\r\nio_req = bnx2fc_cmd_alloc(tgt);\r\nif (!io_req) {\r\nrc = SCSI_MLQUEUE_HOST_BUSY;\r\ngoto exit_qcmd;\r\n}\r\nio_req->sc_cmd = sc_cmd;\r\nif (bnx2fc_post_io_req(tgt, io_req)) {\r\nprintk(KERN_ERR PFX "Unable to post io_req\n");\r\nrc = SCSI_MLQUEUE_HOST_BUSY;\r\ngoto exit_qcmd;\r\n}\r\nexit_qcmd:\r\nreturn rc;\r\n}\r\nvoid bnx2fc_process_scsi_cmd_compl(struct bnx2fc_cmd *io_req,\r\nstruct fcoe_task_ctx_entry *task,\r\nu8 num_rq)\r\n{\r\nstruct fcoe_fcp_rsp_payload *fcp_rsp;\r\nstruct bnx2fc_rport *tgt = io_req->tgt;\r\nstruct scsi_cmnd *sc_cmd;\r\nstruct Scsi_Host *host;\r\nif (test_and_set_bit(BNX2FC_FLAG_IO_COMPL, &io_req->req_flags)) {\r\nBNX2FC_IO_DBG(io_req, "Timer context finished processing "\r\n"this scsi cmd\n");\r\n}\r\nif (cancel_delayed_work(&io_req->timeout_work))\r\nkref_put(&io_req->refcount,\r\nbnx2fc_cmd_release);\r\nsc_cmd = io_req->sc_cmd;\r\nif (sc_cmd == NULL) {\r\nprintk(KERN_ERR PFX "scsi_cmd_compl - sc_cmd is NULL\n");\r\nreturn;\r\n}\r\nfcp_rsp = (struct fcoe_fcp_rsp_payload *)\r\n&(task->rxwr_only.union_ctx.comp_info.fcp_rsp.payload);\r\nbnx2fc_parse_fcp_rsp(io_req, fcp_rsp, num_rq);\r\nhost = sc_cmd->device->host;\r\nif (!sc_cmd->SCp.ptr) {\r\nprintk(KERN_ERR PFX "SCp.ptr is NULL\n");\r\nreturn;\r\n}\r\nif (io_req->on_active_queue) {\r\nlist_del_init(&io_req->link);\r\nio_req->on_active_queue = 0;\r\nlist_add_tail(&io_req->link, &tgt->io_retire_queue);\r\n} else {\r\nBNX2FC_IO_DBG(io_req, "xid not on active_cmd_queue\n");\r\nif (io_req->wait_for_comp)\r\nif (test_and_clear_bit(BNX2FC_FLAG_EH_ABORT,\r\n&io_req->req_flags))\r\ncomplete(&io_req->tm_done);\r\n}\r\nbnx2fc_unmap_sg_list(io_req);\r\nio_req->sc_cmd = NULL;\r\nswitch (io_req->fcp_status) {\r\ncase FC_GOOD:\r\nif (io_req->cdb_status == 0) {\r\nsc_cmd->result = DID_OK << 16;\r\n} else {\r\nBNX2FC_IO_DBG(io_req, "scsi_cmpl: cdb_status = %d"\r\n" fcp_resid = 0x%x\n",\r\nio_req->cdb_status, io_req->fcp_resid);\r\nsc_cmd->result = (DID_OK << 16) | io_req->cdb_status;\r\n}\r\nif (io_req->fcp_resid)\r\nscsi_set_resid(sc_cmd, io_req->fcp_resid);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR PFX "scsi_cmd_compl: fcp_status = %d\n",\r\nio_req->fcp_status);\r\nbreak;\r\n}\r\nsc_cmd->SCp.ptr = NULL;\r\nsc_cmd->scsi_done(sc_cmd);\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\n}\r\nint bnx2fc_post_io_req(struct bnx2fc_rport *tgt,\r\nstruct bnx2fc_cmd *io_req)\r\n{\r\nstruct fcoe_task_ctx_entry *task;\r\nstruct fcoe_task_ctx_entry *task_page;\r\nstruct scsi_cmnd *sc_cmd = io_req->sc_cmd;\r\nstruct fcoe_port *port = tgt->port;\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct bnx2fc_hba *hba = interface->hba;\r\nstruct fc_lport *lport = port->lport;\r\nstruct fcoe_dev_stats *stats;\r\nint task_idx, index;\r\nu16 xid;\r\nio_req->cmd_type = BNX2FC_SCSI_CMD;\r\nio_req->port = port;\r\nio_req->tgt = tgt;\r\nio_req->data_xfer_len = scsi_bufflen(sc_cmd);\r\nsc_cmd->SCp.ptr = (char *)io_req;\r\nstats = per_cpu_ptr(lport->dev_stats, get_cpu());\r\nif (sc_cmd->sc_data_direction == DMA_FROM_DEVICE) {\r\nio_req->io_req_flags = BNX2FC_READ;\r\nstats->InputRequests++;\r\nstats->InputBytes += io_req->data_xfer_len;\r\n} else if (sc_cmd->sc_data_direction == DMA_TO_DEVICE) {\r\nio_req->io_req_flags = BNX2FC_WRITE;\r\nstats->OutputRequests++;\r\nstats->OutputBytes += io_req->data_xfer_len;\r\n} else {\r\nio_req->io_req_flags = 0;\r\nstats->ControlRequests++;\r\n}\r\nput_cpu();\r\nxid = io_req->xid;\r\nif (bnx2fc_build_bd_list_from_sg(io_req)) {\r\nprintk(KERN_ERR PFX "BD list creation failed\n");\r\nspin_lock_bh(&tgt->tgt_lock);\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nreturn -EAGAIN;\r\n}\r\ntask_idx = xid / BNX2FC_TASKS_PER_PAGE;\r\nindex = xid % BNX2FC_TASKS_PER_PAGE;\r\ntask_page = (struct fcoe_task_ctx_entry *) hba->task_ctx[task_idx];\r\ntask = &(task_page[index]);\r\nbnx2fc_init_task(io_req, task);\r\nspin_lock_bh(&tgt->tgt_lock);\r\nif (tgt->flush_in_prog) {\r\nprintk(KERN_ERR PFX "Flush in progress..Host Busy\n");\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nreturn -EAGAIN;\r\n}\r\nif (!test_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags)) {\r\nprintk(KERN_ERR PFX "Session not ready...post_io\n");\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nreturn -EAGAIN;\r\n}\r\nif (tgt->io_timeout)\r\nbnx2fc_cmd_timer_set(io_req, BNX2FC_IO_TIMEOUT);\r\nbnx2fc_add_2_sq(tgt, xid);\r\nio_req->on_active_queue = 1;\r\nlist_add_tail(&io_req->link, &tgt->active_cmd_queue);\r\nbnx2fc_ring_doorbell(tgt);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nreturn 0;\r\n}
