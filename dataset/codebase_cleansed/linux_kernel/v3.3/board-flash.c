static void\r\n__init board_nor_init(struct mtd_partition *nor_parts, u8 nr_parts, u8 cs)\r\n{\r\nint err;\r\nboard_nor_data.parts = nor_parts;\r\nboard_nor_data.nr_parts = nr_parts;\r\nif (omap_rev() >= OMAP3430_REV_ES1_0) {\r\nerr = gpmc_cs_request(cs, FLASH_SIZE_SDPV2 - 1,\r\n(unsigned long *)&board_nor_resource.start);\r\nboard_nor_resource.end = board_nor_resource.start\r\n+ FLASH_SIZE_SDPV2 - 1;\r\n} else {\r\nerr = gpmc_cs_request(cs, FLASH_SIZE_SDPV1 - 1,\r\n(unsigned long *)&board_nor_resource.start);\r\nboard_nor_resource.end = board_nor_resource.start\r\n+ FLASH_SIZE_SDPV1 - 1;\r\n}\r\nif (err < 0) {\r\npr_err("NOR: Can't request GPMC CS\n");\r\nreturn;\r\n}\r\nif (platform_device_register(&board_nor_device) < 0)\r\npr_err("Unable to register NOR device\n");\r\n}\r\nstatic void\r\n__init board_onenand_init(struct mtd_partition *onenand_parts,\r\nu8 nr_parts, u8 cs)\r\n{\r\nboard_onenand_data.cs = cs;\r\nboard_onenand_data.parts = onenand_parts;\r\nboard_onenand_data.nr_parts = nr_parts;\r\ngpmc_onenand_init(&board_onenand_data);\r\n}\r\nstatic void\r\n__init board_onenand_init(struct mtd_partition *nor_parts, u8 nr_parts, u8 cs)\r\n{\r\n}\r\nvoid\r\n__init board_nand_init(struct mtd_partition *nand_parts,\r\nu8 nr_parts, u8 cs, int nand_type)\r\n{\r\nboard_nand_data.cs = cs;\r\nboard_nand_data.parts = nand_parts;\r\nboard_nand_data.nr_parts = nr_parts;\r\nboard_nand_data.devsize = nand_type;\r\nboard_nand_data.ecc_opt = OMAP_ECC_HAMMING_CODE_DEFAULT;\r\nboard_nand_data.gpmc_irq = OMAP_GPMC_IRQ_BASE + cs;\r\ngpmc_nand_init(&board_nand_data);\r\n}\r\nstatic u8 get_gpmc0_type(void)\r\n{\r\nu8 cs = 0;\r\nvoid __iomem *fpga_map_addr;\r\nfpga_map_addr = ioremap(DEBUG_BASE, 4096);\r\nif (!fpga_map_addr)\r\nreturn -ENOMEM;\r\nif (!(__raw_readw(fpga_map_addr + REG_FPGA_REV)))\r\ngoto unmap;\r\ncs = __raw_readw(fpga_map_addr + REG_FPGA_DIP_SWITCH_INPUT2) & 0xf;\r\nif (omap_rev() >= OMAP3430_REV_ES1_0)\r\ncs = ((cs & 8) >> 3) | ((cs & 4) >> 1) |\r\n((cs & 2) << 1) | ((cs & 1) << 3);\r\nelse\r\ncs = ((cs & 4) >> 2) | (cs & 2) | ((cs & 1) << 2);\r\nunmap:\r\niounmap(fpga_map_addr);\r\nreturn cs;\r\n}\r\nvoid board_flash_init(struct flash_partitions partition_info[],\r\nchar chip_sel_board[][GPMC_CS_NUM], int nand_type)\r\n{\r\nu8 cs = 0;\r\nu8 norcs = GPMC_CS_NUM + 1;\r\nu8 nandcs = GPMC_CS_NUM + 1;\r\nu8 onenandcs = GPMC_CS_NUM + 1;\r\nu8 idx;\r\nunsigned char *config_sel = NULL;\r\nidx = get_gpmc0_type();\r\nif (idx >= MAX_SUPPORTED_GPMC_CONFIG) {\r\npr_err("%s: Invalid chip select: %d\n", __func__, cs);\r\nreturn;\r\n}\r\nconfig_sel = (unsigned char *)(chip_sel_board[idx]);\r\nwhile (cs < GPMC_CS_NUM) {\r\nswitch (config_sel[cs]) {\r\ncase PDC_NOR:\r\nif (norcs > GPMC_CS_NUM)\r\nnorcs = cs;\r\nbreak;\r\ncase PDC_NAND:\r\nif (nandcs > GPMC_CS_NUM)\r\nnandcs = cs;\r\nbreak;\r\ncase PDC_ONENAND:\r\nif (onenandcs > GPMC_CS_NUM)\r\nonenandcs = cs;\r\nbreak;\r\n};\r\ncs++;\r\n}\r\nif (norcs > GPMC_CS_NUM)\r\npr_err("NOR: Unable to find configuration in GPMC\n");\r\nelse\r\nboard_nor_init(partition_info[0].parts,\r\npartition_info[0].nr_parts, norcs);\r\nif (onenandcs > GPMC_CS_NUM)\r\npr_err("OneNAND: Unable to find configuration in GPMC\n");\r\nelse\r\nboard_onenand_init(partition_info[1].parts,\r\npartition_info[1].nr_parts, onenandcs);\r\nif (nandcs > GPMC_CS_NUM)\r\npr_err("NAND: Unable to find configuration in GPMC\n");\r\nelse\r\nboard_nand_init(partition_info[2].parts,\r\npartition_info[2].nr_parts, nandcs, nand_type);\r\n}
