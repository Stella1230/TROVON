static void *squashfs_xz_init(struct squashfs_sb_info *msblk, void *buff,\r\nint len)\r\n{\r\nstruct comp_opts *comp_opts = buff;\r\nstruct squashfs_xz *stream;\r\nint dict_size = msblk->block_size;\r\nint err, n;\r\nif (comp_opts) {\r\nif (len < sizeof(*comp_opts)) {\r\nerr = -EIO;\r\ngoto failed;\r\n}\r\ndict_size = le32_to_cpu(comp_opts->dictionary_size);\r\nn = ffs(dict_size) - 1;\r\nif (dict_size != (1 << n) && dict_size != (1 << n) +\r\n(1 << (n + 1))) {\r\nerr = -EIO;\r\ngoto failed;\r\n}\r\n}\r\ndict_size = max_t(int, dict_size, SQUASHFS_METADATA_SIZE);\r\nstream = kmalloc(sizeof(*stream), GFP_KERNEL);\r\nif (stream == NULL) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nstream->state = xz_dec_init(XZ_PREALLOC, dict_size);\r\nif (stream->state == NULL) {\r\nkfree(stream);\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nreturn stream;\r\nfailed:\r\nERROR("Failed to initialise xz decompressor\n");\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void squashfs_xz_free(void *strm)\r\n{\r\nstruct squashfs_xz *stream = strm;\r\nif (stream) {\r\nxz_dec_end(stream->state);\r\nkfree(stream);\r\n}\r\n}\r\nstatic int squashfs_xz_uncompress(struct squashfs_sb_info *msblk, void **buffer,\r\nstruct buffer_head **bh, int b, int offset, int length, int srclength,\r\nint pages)\r\n{\r\nenum xz_ret xz_err;\r\nint avail, total = 0, k = 0, page = 0;\r\nstruct squashfs_xz *stream = msblk->stream;\r\nmutex_lock(&msblk->read_data_mutex);\r\nxz_dec_reset(stream->state);\r\nstream->buf.in_pos = 0;\r\nstream->buf.in_size = 0;\r\nstream->buf.out_pos = 0;\r\nstream->buf.out_size = PAGE_CACHE_SIZE;\r\nstream->buf.out = buffer[page++];\r\ndo {\r\nif (stream->buf.in_pos == stream->buf.in_size && k < b) {\r\navail = min(length, msblk->devblksize - offset);\r\nlength -= avail;\r\nwait_on_buffer(bh[k]);\r\nif (!buffer_uptodate(bh[k]))\r\ngoto release_mutex;\r\nstream->buf.in = bh[k]->b_data + offset;\r\nstream->buf.in_size = avail;\r\nstream->buf.in_pos = 0;\r\noffset = 0;\r\n}\r\nif (stream->buf.out_pos == stream->buf.out_size\r\n&& page < pages) {\r\nstream->buf.out = buffer[page++];\r\nstream->buf.out_pos = 0;\r\ntotal += PAGE_CACHE_SIZE;\r\n}\r\nxz_err = xz_dec_run(stream->state, &stream->buf);\r\nif (stream->buf.in_pos == stream->buf.in_size && k < b)\r\nput_bh(bh[k++]);\r\n} while (xz_err == XZ_OK);\r\nif (xz_err != XZ_STREAM_END) {\r\nERROR("xz_dec_run error, data probably corrupt\n");\r\ngoto release_mutex;\r\n}\r\nif (k < b) {\r\nERROR("xz_uncompress error, input remaining\n");\r\ngoto release_mutex;\r\n}\r\ntotal += stream->buf.out_pos;\r\nmutex_unlock(&msblk->read_data_mutex);\r\nreturn total;\r\nrelease_mutex:\r\nmutex_unlock(&msblk->read_data_mutex);\r\nfor (; k < b; k++)\r\nput_bh(bh[k]);\r\nreturn -EIO;\r\n}
