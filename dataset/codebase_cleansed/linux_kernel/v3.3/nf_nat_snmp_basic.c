static void asn1_open(struct asn1_ctx *ctx,\r\nunsigned char *buf,\r\nunsigned int len)\r\n{\r\nctx->begin = buf;\r\nctx->end = buf + len;\r\nctx->pointer = buf;\r\nctx->error = ASN1_ERR_NOERROR;\r\n}\r\nstatic unsigned char asn1_octet_decode(struct asn1_ctx *ctx, unsigned char *ch)\r\n{\r\nif (ctx->pointer >= ctx->end) {\r\nctx->error = ASN1_ERR_DEC_EMPTY;\r\nreturn 0;\r\n}\r\n*ch = *(ctx->pointer)++;\r\nreturn 1;\r\n}\r\nstatic unsigned char asn1_tag_decode(struct asn1_ctx *ctx, unsigned int *tag)\r\n{\r\nunsigned char ch;\r\n*tag = 0;\r\ndo\r\n{\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\n*tag <<= 7;\r\n*tag |= ch & 0x7F;\r\n} while ((ch & 0x80) == 0x80);\r\nreturn 1;\r\n}\r\nstatic unsigned char asn1_id_decode(struct asn1_ctx *ctx,\r\nunsigned int *cls,\r\nunsigned int *con,\r\nunsigned int *tag)\r\n{\r\nunsigned char ch;\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\n*cls = (ch & 0xC0) >> 6;\r\n*con = (ch & 0x20) >> 5;\r\n*tag = (ch & 0x1F);\r\nif (*tag == 0x1F) {\r\nif (!asn1_tag_decode(ctx, tag))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned char asn1_length_decode(struct asn1_ctx *ctx,\r\nunsigned int *def,\r\nunsigned int *len)\r\n{\r\nunsigned char ch, cnt;\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\nif (ch == 0x80)\r\n*def = 0;\r\nelse {\r\n*def = 1;\r\nif (ch < 0x80)\r\n*len = ch;\r\nelse {\r\ncnt = ch & 0x7F;\r\n*len = 0;\r\nwhile (cnt > 0) {\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\n*len <<= 8;\r\n*len |= ch;\r\ncnt--;\r\n}\r\n}\r\n}\r\nif (*len > ctx->end - ctx->pointer)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic unsigned char asn1_header_decode(struct asn1_ctx *ctx,\r\nunsigned char **eoc,\r\nunsigned int *cls,\r\nunsigned int *con,\r\nunsigned int *tag)\r\n{\r\nunsigned int def, len;\r\nif (!asn1_id_decode(ctx, cls, con, tag))\r\nreturn 0;\r\ndef = len = 0;\r\nif (!asn1_length_decode(ctx, &def, &len))\r\nreturn 0;\r\nif (*con == ASN1_PRI && !def)\r\nreturn 0;\r\nif (def)\r\n*eoc = ctx->pointer + len;\r\nelse\r\n*eoc = NULL;\r\nreturn 1;\r\n}\r\nstatic unsigned char asn1_eoc_decode(struct asn1_ctx *ctx, unsigned char *eoc)\r\n{\r\nunsigned char ch;\r\nif (eoc == NULL) {\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\nif (ch != 0x00) {\r\nctx->error = ASN1_ERR_DEC_EOC_MISMATCH;\r\nreturn 0;\r\n}\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\nif (ch != 0x00) {\r\nctx->error = ASN1_ERR_DEC_EOC_MISMATCH;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n} else {\r\nif (ctx->pointer != eoc) {\r\nctx->error = ASN1_ERR_DEC_LENGTH_MISMATCH;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\n}\r\nstatic unsigned char asn1_null_decode(struct asn1_ctx *ctx, unsigned char *eoc)\r\n{\r\nctx->pointer = eoc;\r\nreturn 1;\r\n}\r\nstatic unsigned char asn1_long_decode(struct asn1_ctx *ctx,\r\nunsigned char *eoc,\r\nlong *integer)\r\n{\r\nunsigned char ch;\r\nunsigned int len;\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\n*integer = (signed char) ch;\r\nlen = 1;\r\nwhile (ctx->pointer < eoc) {\r\nif (++len > sizeof (long)) {\r\nctx->error = ASN1_ERR_DEC_BADVALUE;\r\nreturn 0;\r\n}\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\n*integer <<= 8;\r\n*integer |= ch;\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned char asn1_uint_decode(struct asn1_ctx *ctx,\r\nunsigned char *eoc,\r\nunsigned int *integer)\r\n{\r\nunsigned char ch;\r\nunsigned int len;\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\n*integer = ch;\r\nif (ch == 0) len = 0;\r\nelse len = 1;\r\nwhile (ctx->pointer < eoc) {\r\nif (++len > sizeof (unsigned int)) {\r\nctx->error = ASN1_ERR_DEC_BADVALUE;\r\nreturn 0;\r\n}\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\n*integer <<= 8;\r\n*integer |= ch;\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned char asn1_ulong_decode(struct asn1_ctx *ctx,\r\nunsigned char *eoc,\r\nunsigned long *integer)\r\n{\r\nunsigned char ch;\r\nunsigned int len;\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\n*integer = ch;\r\nif (ch == 0) len = 0;\r\nelse len = 1;\r\nwhile (ctx->pointer < eoc) {\r\nif (++len > sizeof (unsigned long)) {\r\nctx->error = ASN1_ERR_DEC_BADVALUE;\r\nreturn 0;\r\n}\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\n*integer <<= 8;\r\n*integer |= ch;\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned char asn1_octets_decode(struct asn1_ctx *ctx,\r\nunsigned char *eoc,\r\nunsigned char **octets,\r\nunsigned int *len)\r\n{\r\nunsigned char *ptr;\r\n*len = 0;\r\n*octets = kmalloc(eoc - ctx->pointer, GFP_ATOMIC);\r\nif (*octets == NULL)\r\nreturn 0;\r\nptr = *octets;\r\nwhile (ctx->pointer < eoc) {\r\nif (!asn1_octet_decode(ctx, (unsigned char *)ptr++)) {\r\nkfree(*octets);\r\n*octets = NULL;\r\nreturn 0;\r\n}\r\n(*len)++;\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned char asn1_subid_decode(struct asn1_ctx *ctx,\r\nunsigned long *subid)\r\n{\r\nunsigned char ch;\r\n*subid = 0;\r\ndo {\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\n*subid <<= 7;\r\n*subid |= ch & 0x7F;\r\n} while ((ch & 0x80) == 0x80);\r\nreturn 1;\r\n}\r\nstatic unsigned char asn1_oid_decode(struct asn1_ctx *ctx,\r\nunsigned char *eoc,\r\nunsigned long **oid,\r\nunsigned int *len)\r\n{\r\nunsigned long subid;\r\nunsigned long *optr;\r\nsize_t size;\r\nsize = eoc - ctx->pointer + 1;\r\nif (size < 2 || size > ULONG_MAX/sizeof(unsigned long))\r\nreturn 0;\r\n*oid = kmalloc(size * sizeof(unsigned long), GFP_ATOMIC);\r\nif (*oid == NULL)\r\nreturn 0;\r\noptr = *oid;\r\nif (!asn1_subid_decode(ctx, &subid)) {\r\nkfree(*oid);\r\n*oid = NULL;\r\nreturn 0;\r\n}\r\nif (subid < 40) {\r\noptr [0] = 0;\r\noptr [1] = subid;\r\n} else if (subid < 80) {\r\noptr [0] = 1;\r\noptr [1] = subid - 40;\r\n} else {\r\noptr [0] = 2;\r\noptr [1] = subid - 80;\r\n}\r\n*len = 2;\r\noptr += 2;\r\nwhile (ctx->pointer < eoc) {\r\nif (++(*len) > size) {\r\nctx->error = ASN1_ERR_DEC_BADVALUE;\r\nkfree(*oid);\r\n*oid = NULL;\r\nreturn 0;\r\n}\r\nif (!asn1_subid_decode(ctx, optr++)) {\r\nkfree(*oid);\r\n*oid = NULL;\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned char snmp_tag_cls2syntax(unsigned int tag,\r\nunsigned int cls,\r\nunsigned short *syntax)\r\n{\r\nconst struct snmp_cnv *cnv;\r\ncnv = snmp_conv;\r\nwhile (cnv->syntax != -1) {\r\nif (cnv->tag == tag && cnv->class == cls) {\r\n*syntax = cnv->syntax;\r\nreturn 1;\r\n}\r\ncnv++;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char snmp_object_decode(struct asn1_ctx *ctx,\r\nstruct snmp_object **obj)\r\n{\r\nunsigned int cls, con, tag, len, idlen;\r\nunsigned short type;\r\nunsigned char *eoc, *end, *p;\r\nunsigned long *lp, *id;\r\nunsigned long ul;\r\nlong l;\r\n*obj = NULL;\r\nid = NULL;\r\nif (!asn1_header_decode(ctx, &eoc, &cls, &con, &tag))\r\nreturn 0;\r\nif (cls != ASN1_UNI || con != ASN1_CON || tag != ASN1_SEQ)\r\nreturn 0;\r\nif (!asn1_header_decode(ctx, &end, &cls, &con, &tag))\r\nreturn 0;\r\nif (cls != ASN1_UNI || con != ASN1_PRI || tag != ASN1_OJI)\r\nreturn 0;\r\nif (!asn1_oid_decode(ctx, end, &id, &idlen))\r\nreturn 0;\r\nif (!asn1_header_decode(ctx, &end, &cls, &con, &tag)) {\r\nkfree(id);\r\nreturn 0;\r\n}\r\nif (con != ASN1_PRI) {\r\nkfree(id);\r\nreturn 0;\r\n}\r\ntype = 0;\r\nif (!snmp_tag_cls2syntax(tag, cls, &type)) {\r\nkfree(id);\r\nreturn 0;\r\n}\r\nl = 0;\r\nswitch (type) {\r\ncase SNMP_INTEGER:\r\nlen = sizeof(long);\r\nif (!asn1_long_decode(ctx, end, &l)) {\r\nkfree(id);\r\nreturn 0;\r\n}\r\n*obj = kmalloc(sizeof(struct snmp_object) + len, GFP_ATOMIC);\r\nif (*obj == NULL) {\r\nkfree(id);\r\nreturn 0;\r\n}\r\n(*obj)->syntax.l[0] = l;\r\nbreak;\r\ncase SNMP_OCTETSTR:\r\ncase SNMP_OPAQUE:\r\nif (!asn1_octets_decode(ctx, end, &p, &len)) {\r\nkfree(id);\r\nreturn 0;\r\n}\r\n*obj = kmalloc(sizeof(struct snmp_object) + len, GFP_ATOMIC);\r\nif (*obj == NULL) {\r\nkfree(p);\r\nkfree(id);\r\nreturn 0;\r\n}\r\nmemcpy((*obj)->syntax.c, p, len);\r\nkfree(p);\r\nbreak;\r\ncase SNMP_NULL:\r\ncase SNMP_NOSUCHOBJECT:\r\ncase SNMP_NOSUCHINSTANCE:\r\ncase SNMP_ENDOFMIBVIEW:\r\nlen = 0;\r\n*obj = kmalloc(sizeof(struct snmp_object), GFP_ATOMIC);\r\nif (*obj == NULL) {\r\nkfree(id);\r\nreturn 0;\r\n}\r\nif (!asn1_null_decode(ctx, end)) {\r\nkfree(id);\r\nkfree(*obj);\r\n*obj = NULL;\r\nreturn 0;\r\n}\r\nbreak;\r\ncase SNMP_OBJECTID:\r\nif (!asn1_oid_decode(ctx, end, (unsigned long **)&lp, &len)) {\r\nkfree(id);\r\nreturn 0;\r\n}\r\nlen *= sizeof(unsigned long);\r\n*obj = kmalloc(sizeof(struct snmp_object) + len, GFP_ATOMIC);\r\nif (*obj == NULL) {\r\nkfree(lp);\r\nkfree(id);\r\nreturn 0;\r\n}\r\nmemcpy((*obj)->syntax.ul, lp, len);\r\nkfree(lp);\r\nbreak;\r\ncase SNMP_IPADDR:\r\nif (!asn1_octets_decode(ctx, end, &p, &len)) {\r\nkfree(id);\r\nreturn 0;\r\n}\r\nif (len != 4) {\r\nkfree(p);\r\nkfree(id);\r\nreturn 0;\r\n}\r\n*obj = kmalloc(sizeof(struct snmp_object) + len, GFP_ATOMIC);\r\nif (*obj == NULL) {\r\nkfree(p);\r\nkfree(id);\r\nreturn 0;\r\n}\r\nmemcpy((*obj)->syntax.uc, p, len);\r\nkfree(p);\r\nbreak;\r\ncase SNMP_COUNTER:\r\ncase SNMP_GAUGE:\r\ncase SNMP_TIMETICKS:\r\nlen = sizeof(unsigned long);\r\nif (!asn1_ulong_decode(ctx, end, &ul)) {\r\nkfree(id);\r\nreturn 0;\r\n}\r\n*obj = kmalloc(sizeof(struct snmp_object) + len, GFP_ATOMIC);\r\nif (*obj == NULL) {\r\nkfree(id);\r\nreturn 0;\r\n}\r\n(*obj)->syntax.ul[0] = ul;\r\nbreak;\r\ndefault:\r\nkfree(id);\r\nreturn 0;\r\n}\r\n(*obj)->syntax_len = len;\r\n(*obj)->type = type;\r\n(*obj)->id = id;\r\n(*obj)->id_len = idlen;\r\nif (!asn1_eoc_decode(ctx, eoc)) {\r\nkfree(id);\r\nkfree(*obj);\r\n*obj = NULL;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned char snmp_request_decode(struct asn1_ctx *ctx,\r\nstruct snmp_request *request)\r\n{\r\nunsigned int cls, con, tag;\r\nunsigned char *end;\r\nif (!asn1_header_decode(ctx, &end, &cls, &con, &tag))\r\nreturn 0;\r\nif (cls != ASN1_UNI || con != ASN1_PRI || tag != ASN1_INT)\r\nreturn 0;\r\nif (!asn1_ulong_decode(ctx, end, &request->id))\r\nreturn 0;\r\nif (!asn1_header_decode(ctx, &end, &cls, &con, &tag))\r\nreturn 0;\r\nif (cls != ASN1_UNI || con != ASN1_PRI || tag != ASN1_INT)\r\nreturn 0;\r\nif (!asn1_uint_decode(ctx, end, &request->error_status))\r\nreturn 0;\r\nif (!asn1_header_decode(ctx, &end, &cls, &con, &tag))\r\nreturn 0;\r\nif (cls != ASN1_UNI || con != ASN1_PRI || tag != ASN1_INT)\r\nreturn 0;\r\nif (!asn1_uint_decode(ctx, end, &request->error_index))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void fast_csum(__sum16 *csum,\r\nconst unsigned char *optr,\r\nconst unsigned char *nptr,\r\nint offset)\r\n{\r\nunsigned char s[4];\r\nif (offset & 1) {\r\ns[0] = ~0;\r\ns[1] = ~*optr;\r\ns[2] = 0;\r\ns[3] = *nptr;\r\n} else {\r\ns[0] = ~*optr;\r\ns[1] = ~0;\r\ns[2] = *nptr;\r\ns[3] = 0;\r\n}\r\n*csum = csum_fold(csum_partial(s, 4, ~csum_unfold(*csum)));\r\n}\r\nstatic inline void mangle_address(unsigned char *begin,\r\nunsigned char *addr,\r\nconst struct oct1_map *map,\r\n__sum16 *check)\r\n{\r\nif (map->from == NOCT1(addr)) {\r\nu_int32_t old;\r\nif (debug)\r\nmemcpy(&old, addr, sizeof(old));\r\n*addr = map->to;\r\nif (*check) {\r\nfast_csum(check,\r\n&map->from, &map->to, addr - begin);\r\n}\r\nif (debug)\r\nprintk(KERN_DEBUG "bsalg: mapped %pI4 to %pI4\n",\r\n&old, addr);\r\n}\r\n}\r\nstatic unsigned char snmp_trap_decode(struct asn1_ctx *ctx,\r\nstruct snmp_v1_trap *trap,\r\nconst struct oct1_map *map,\r\n__sum16 *check)\r\n{\r\nunsigned int cls, con, tag, len;\r\nunsigned char *end;\r\nif (!asn1_header_decode(ctx, &end, &cls, &con, &tag))\r\nreturn 0;\r\nif (cls != ASN1_UNI || con != ASN1_PRI || tag != ASN1_OJI)\r\nreturn 0;\r\nif (!asn1_oid_decode(ctx, end, &trap->id, &trap->id_len))\r\nreturn 0;\r\nif (!asn1_header_decode(ctx, &end, &cls, &con, &tag))\r\ngoto err_id_free;\r\nif (!((cls == ASN1_APL && con == ASN1_PRI && tag == SNMP_IPA) ||\r\n(cls == ASN1_UNI && con == ASN1_PRI && tag == ASN1_OTS)))\r\ngoto err_id_free;\r\nif (!asn1_octets_decode(ctx, end, (unsigned char **)&trap->ip_address, &len))\r\ngoto err_id_free;\r\nif (len != 4)\r\ngoto err_addr_free;\r\nmangle_address(ctx->begin, ctx->pointer - 4, map, check);\r\nif (!asn1_header_decode(ctx, &end, &cls, &con, &tag))\r\ngoto err_addr_free;\r\nif (cls != ASN1_UNI || con != ASN1_PRI || tag != ASN1_INT)\r\ngoto err_addr_free;\r\nif (!asn1_uint_decode(ctx, end, &trap->general))\r\ngoto err_addr_free;\r\nif (!asn1_header_decode(ctx, &end, &cls, &con, &tag))\r\ngoto err_addr_free;\r\nif (cls != ASN1_UNI || con != ASN1_PRI || tag != ASN1_INT)\r\ngoto err_addr_free;\r\nif (!asn1_uint_decode(ctx, end, &trap->specific))\r\ngoto err_addr_free;\r\nif (!asn1_header_decode(ctx, &end, &cls, &con, &tag))\r\ngoto err_addr_free;\r\nif (!((cls == ASN1_APL && con == ASN1_PRI && tag == SNMP_TIT) ||\r\n(cls == ASN1_UNI && con == ASN1_PRI && tag == ASN1_INT)))\r\ngoto err_addr_free;\r\nif (!asn1_ulong_decode(ctx, end, &trap->time))\r\ngoto err_addr_free;\r\nreturn 1;\r\nerr_addr_free:\r\nkfree((unsigned long *)trap->ip_address);\r\nerr_id_free:\r\nkfree(trap->id);\r\nreturn 0;\r\n}\r\nstatic void hex_dump(const unsigned char *buf, size_t len)\r\n{\r\nsize_t i;\r\nfor (i = 0; i < len; i++) {\r\nif (i && !(i % 16))\r\nprintk("\n");\r\nprintk("%02x ", *(buf + i));\r\n}\r\nprintk("\n");\r\n}\r\nstatic int snmp_parse_mangle(unsigned char *msg,\r\nu_int16_t len,\r\nconst struct oct1_map *map,\r\n__sum16 *check)\r\n{\r\nunsigned char *eoc, *end;\r\nunsigned int cls, con, tag, vers, pdutype;\r\nstruct asn1_ctx ctx;\r\nstruct asn1_octstr comm;\r\nstruct snmp_object *obj;\r\nif (debug > 1)\r\nhex_dump(msg, len);\r\nasn1_open(&ctx, msg, len);\r\nif (!asn1_header_decode(&ctx, &eoc, &cls, &con, &tag))\r\nreturn 0;\r\nif (cls != ASN1_UNI || con != ASN1_CON || tag != ASN1_SEQ)\r\nreturn 0;\r\nif (!asn1_header_decode(&ctx, &end, &cls, &con, &tag))\r\nreturn 0;\r\nif (cls != ASN1_UNI || con != ASN1_PRI || tag != ASN1_INT)\r\nreturn 0;\r\nif (!asn1_uint_decode (&ctx, end, &vers))\r\nreturn 0;\r\nif (debug > 1)\r\nprintk(KERN_DEBUG "bsalg: snmp version: %u\n", vers + 1);\r\nif (vers > 1)\r\nreturn 1;\r\nif (!asn1_header_decode (&ctx, &end, &cls, &con, &tag))\r\nreturn 0;\r\nif (cls != ASN1_UNI || con != ASN1_PRI || tag != ASN1_OTS)\r\nreturn 0;\r\nif (!asn1_octets_decode(&ctx, end, &comm.data, &comm.len))\r\nreturn 0;\r\nif (debug > 1) {\r\nunsigned int i;\r\nprintk(KERN_DEBUG "bsalg: community: ");\r\nfor (i = 0; i < comm.len; i++)\r\nprintk("%c", comm.data[i]);\r\nprintk("\n");\r\n}\r\nkfree(comm.data);\r\nif (!asn1_header_decode(&ctx, &eoc, &cls, &con, &pdutype))\r\nreturn 0;\r\nif (cls != ASN1_CTX || con != ASN1_CON)\r\nreturn 0;\r\nif (debug > 1) {\r\nstatic const unsigned char *const pdus[] = {\r\n[SNMP_PDU_GET] = "get",\r\n[SNMP_PDU_NEXT] = "get-next",\r\n[SNMP_PDU_RESPONSE] = "response",\r\n[SNMP_PDU_SET] = "set",\r\n[SNMP_PDU_TRAP1] = "trapv1",\r\n[SNMP_PDU_BULK] = "bulk",\r\n[SNMP_PDU_INFORM] = "inform",\r\n[SNMP_PDU_TRAP2] = "trapv2"\r\n};\r\nif (pdutype > SNMP_PDU_TRAP2)\r\nprintk(KERN_DEBUG "bsalg: bad pdu type %u\n", pdutype);\r\nelse\r\nprintk(KERN_DEBUG "bsalg: pdu: %s\n", pdus[pdutype]);\r\n}\r\nif (pdutype != SNMP_PDU_RESPONSE &&\r\npdutype != SNMP_PDU_TRAP1 && pdutype != SNMP_PDU_TRAP2)\r\nreturn 1;\r\nif (pdutype == SNMP_PDU_TRAP1) {\r\nstruct snmp_v1_trap trap;\r\nunsigned char ret = snmp_trap_decode(&ctx, &trap, map, check);\r\nif (ret) {\r\nkfree(trap.id);\r\nkfree((unsigned long *)trap.ip_address);\r\n} else\r\nreturn ret;\r\n} else {\r\nstruct snmp_request req;\r\nif (!snmp_request_decode(&ctx, &req))\r\nreturn 0;\r\nif (debug > 1)\r\nprintk(KERN_DEBUG "bsalg: request: id=0x%lx error_status=%u "\r\n"error_index=%u\n", req.id, req.error_status,\r\nreq.error_index);\r\n}\r\nif (!asn1_header_decode(&ctx, &eoc, &cls, &con, &tag))\r\nreturn 0;\r\nif (cls != ASN1_UNI || con != ASN1_CON || tag != ASN1_SEQ)\r\nreturn 0;\r\nwhile (!asn1_eoc_decode(&ctx, eoc)) {\r\nunsigned int i;\r\nif (!snmp_object_decode(&ctx, &obj)) {\r\nif (obj) {\r\nkfree(obj->id);\r\nkfree(obj);\r\n}\r\nreturn 0;\r\n}\r\nif (debug > 1) {\r\nprintk(KERN_DEBUG "bsalg: object: ");\r\nfor (i = 0; i < obj->id_len; i++) {\r\nif (i > 0)\r\nprintk(".");\r\nprintk("%lu", obj->id[i]);\r\n}\r\nprintk(": type=%u\n", obj->type);\r\n}\r\nif (obj->type == SNMP_IPADDR)\r\nmangle_address(ctx.begin, ctx.pointer - 4 , map, check);\r\nkfree(obj->id);\r\nkfree(obj);\r\n}\r\nif (!asn1_eoc_decode(&ctx, eoc))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int snmp_translate(struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nstruct sk_buff *skb)\r\n{\r\nstruct iphdr *iph = ip_hdr(skb);\r\nstruct udphdr *udph = (struct udphdr *)((__be32 *)iph + iph->ihl);\r\nu_int16_t udplen = ntohs(udph->len);\r\nu_int16_t paylen = udplen - sizeof(struct udphdr);\r\nint dir = CTINFO2DIR(ctinfo);\r\nstruct oct1_map map;\r\nif (dir == IP_CT_DIR_ORIGINAL) {\r\nmap.from = NOCT1(&ct->tuplehash[dir].tuple.src.u3.ip);\r\nmap.to = NOCT1(&ct->tuplehash[!dir].tuple.dst.u3.ip);\r\n} else {\r\nmap.from = NOCT1(&ct->tuplehash[dir].tuple.src.u3.ip);\r\nmap.to = NOCT1(&ct->tuplehash[!dir].tuple.dst.u3.ip);\r\n}\r\nif (map.from == map.to)\r\nreturn NF_ACCEPT;\r\nif (!snmp_parse_mangle((unsigned char *)udph + sizeof(struct udphdr),\r\npaylen, &map, &udph->check)) {\r\nif (net_ratelimit())\r\nprintk(KERN_WARNING "bsalg: parser failed\n");\r\nreturn NF_DROP;\r\n}\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int help(struct sk_buff *skb, unsigned int protoff,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo)\r\n{\r\nint dir = CTINFO2DIR(ctinfo);\r\nunsigned int ret;\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nconst struct udphdr *udph = (struct udphdr *)((__be32 *)iph + iph->ihl);\r\nif (udph->source == htons(SNMP_PORT) && dir != IP_CT_DIR_REPLY)\r\nreturn NF_ACCEPT;\r\nif (udph->dest == htons(SNMP_TRAP_PORT) && dir != IP_CT_DIR_ORIGINAL)\r\nreturn NF_ACCEPT;\r\nif (!(ct->status & IPS_NAT_MASK))\r\nreturn NF_ACCEPT;\r\nif (ntohs(udph->len) != skb->len - (iph->ihl << 2)) {\r\nif (net_ratelimit())\r\nprintk(KERN_WARNING "SNMP: dropping malformed packet src=%pI4 dst=%pI4\n",\r\n&iph->saddr, &iph->daddr);\r\nreturn NF_DROP;\r\n}\r\nif (!skb_make_writable(skb, skb->len))\r\nreturn NF_DROP;\r\nspin_lock_bh(&snmp_lock);\r\nret = snmp_translate(ct, ctinfo, skb);\r\nspin_unlock_bh(&snmp_lock);\r\nreturn ret;\r\n}\r\nstatic int __init nf_nat_snmp_basic_init(void)\r\n{\r\nint ret = 0;\r\nBUG_ON(nf_nat_snmp_hook != NULL);\r\nRCU_INIT_POINTER(nf_nat_snmp_hook, help);\r\nret = nf_conntrack_helper_register(&snmp_trap_helper);\r\nif (ret < 0) {\r\nnf_conntrack_helper_unregister(&snmp_helper);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit nf_nat_snmp_basic_fini(void)\r\n{\r\nRCU_INIT_POINTER(nf_nat_snmp_hook, NULL);\r\nnf_conntrack_helper_unregister(&snmp_trap_helper);\r\n}
