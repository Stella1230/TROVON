static int ams369fg06_spi_write_byte(struct ams369fg06 *lcd, int addr, int data)\r\n{\r\nu16 buf[1];\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer = {\r\n.len = 2,\r\n.tx_buf = buf,\r\n};\r\nbuf[0] = (addr << 8) | data;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nreturn spi_sync(lcd->spi, &msg);\r\n}\r\nstatic int ams369fg06_spi_write(struct ams369fg06 *lcd, unsigned char address,\r\nunsigned char command)\r\n{\r\nint ret = 0;\r\nif (address != DATA_ONLY)\r\nret = ams369fg06_spi_write_byte(lcd, 0x70, address);\r\nif (command != COMMAND_ONLY)\r\nret = ams369fg06_spi_write_byte(lcd, 0x72, command);\r\nreturn ret;\r\n}\r\nstatic int ams369fg06_panel_send_sequence(struct ams369fg06 *lcd,\r\nconst unsigned short *wbuf)\r\n{\r\nint ret = 0, i = 0;\r\nwhile ((wbuf[i] & DEFMASK) != ENDDEF) {\r\nif ((wbuf[i] & DEFMASK) != SLEEPMSEC) {\r\nret = ams369fg06_spi_write(lcd, wbuf[i], wbuf[i+1]);\r\nif (ret)\r\nbreak;\r\n} else\r\nmdelay(wbuf[i+1]);\r\ni += 2;\r\n}\r\nreturn ret;\r\n}\r\nstatic int _ams369fg06_gamma_ctl(struct ams369fg06 *lcd,\r\nconst unsigned int *gamma)\r\n{\r\nunsigned int i = 0;\r\nint ret = 0;\r\nfor (i = 0 ; i < GAMMA_TABLE_COUNT / 3; i++) {\r\nret = ams369fg06_spi_write(lcd, 0x40 + i, gamma[i]);\r\nret = ams369fg06_spi_write(lcd, 0x50 + i, gamma[i+7*1]);\r\nret = ams369fg06_spi_write(lcd, 0x60 + i, gamma[i+7*2]);\r\nif (ret) {\r\ndev_err(lcd->dev, "failed to set gamma table.\n");\r\ngoto gamma_err;\r\n}\r\n}\r\ngamma_err:\r\nreturn ret;\r\n}\r\nstatic int ams369fg06_gamma_ctl(struct ams369fg06 *lcd, int brightness)\r\n{\r\nint ret = 0;\r\nint gamma = 0;\r\nif ((brightness >= 0) && (brightness <= 50))\r\ngamma = 0;\r\nelse if ((brightness > 50) && (brightness <= 100))\r\ngamma = 1;\r\nelse if ((brightness > 100) && (brightness <= 150))\r\ngamma = 2;\r\nelse if ((brightness > 150) && (brightness <= 200))\r\ngamma = 3;\r\nelse if ((brightness > 200) && (brightness <= 255))\r\ngamma = 4;\r\nret = _ams369fg06_gamma_ctl(lcd, gamma_table.gamma_22_table[gamma]);\r\nreturn ret;\r\n}\r\nstatic int ams369fg06_ldi_init(struct ams369fg06 *lcd)\r\n{\r\nint ret, i;\r\nstatic const unsigned short *init_seq[] = {\r\nseq_setting,\r\nseq_stand_by_off,\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(init_seq); i++) {\r\nret = ams369fg06_panel_send_sequence(lcd, init_seq[i]);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ams369fg06_ldi_enable(struct ams369fg06 *lcd)\r\n{\r\nint ret, i;\r\nstatic const unsigned short *init_seq[] = {\r\nseq_stand_by_off,\r\nseq_display_on,\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(init_seq); i++) {\r\nret = ams369fg06_panel_send_sequence(lcd, init_seq[i]);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ams369fg06_ldi_disable(struct ams369fg06 *lcd)\r\n{\r\nint ret, i;\r\nstatic const unsigned short *init_seq[] = {\r\nseq_display_off,\r\nseq_stand_by_on,\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(init_seq); i++) {\r\nret = ams369fg06_panel_send_sequence(lcd, init_seq[i]);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ams369fg06_power_is_on(int power)\r\n{\r\nreturn ((power) <= FB_BLANK_NORMAL);\r\n}\r\nstatic int ams369fg06_power_on(struct ams369fg06 *lcd)\r\n{\r\nint ret = 0;\r\nstruct lcd_platform_data *pd = NULL;\r\nstruct backlight_device *bd = NULL;\r\npd = lcd->lcd_pd;\r\nif (!pd) {\r\ndev_err(lcd->dev, "platform data is NULL.\n");\r\nreturn -EFAULT;\r\n}\r\nbd = lcd->bd;\r\nif (!bd) {\r\ndev_err(lcd->dev, "backlight device is NULL.\n");\r\nreturn -EFAULT;\r\n}\r\nif (!pd->power_on) {\r\ndev_err(lcd->dev, "power_on is NULL.\n");\r\nreturn -EFAULT;\r\n} else {\r\npd->power_on(lcd->ld, 1);\r\nmdelay(pd->power_on_delay);\r\n}\r\nif (!pd->reset) {\r\ndev_err(lcd->dev, "reset is NULL.\n");\r\nreturn -EFAULT;\r\n} else {\r\npd->reset(lcd->ld);\r\nmdelay(pd->reset_delay);\r\n}\r\nret = ams369fg06_ldi_init(lcd);\r\nif (ret) {\r\ndev_err(lcd->dev, "failed to initialize ldi.\n");\r\nreturn ret;\r\n}\r\nret = ams369fg06_ldi_enable(lcd);\r\nif (ret) {\r\ndev_err(lcd->dev, "failed to enable ldi.\n");\r\nreturn ret;\r\n}\r\nret = ams369fg06_gamma_ctl(lcd, bd->props.brightness);\r\nif (ret) {\r\ndev_err(lcd->dev, "lcd gamma setting failed.\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ams369fg06_power_off(struct ams369fg06 *lcd)\r\n{\r\nint ret = 0;\r\nstruct lcd_platform_data *pd = NULL;\r\npd = lcd->lcd_pd;\r\nif (!pd) {\r\ndev_err(lcd->dev, "platform data is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nret = ams369fg06_ldi_disable(lcd);\r\nif (ret) {\r\ndev_err(lcd->dev, "lcd setting failed.\n");\r\nreturn -EIO;\r\n}\r\nmdelay(pd->power_off_delay);\r\nif (!pd->power_on) {\r\ndev_err(lcd->dev, "power_on is NULL.\n");\r\nreturn -EFAULT;\r\n} else\r\npd->power_on(lcd->ld, 0);\r\nreturn 0;\r\n}\r\nstatic int ams369fg06_power(struct ams369fg06 *lcd, int power)\r\n{\r\nint ret = 0;\r\nif (ams369fg06_power_is_on(power) &&\r\n!ams369fg06_power_is_on(lcd->power))\r\nret = ams369fg06_power_on(lcd);\r\nelse if (!ams369fg06_power_is_on(power) &&\r\nams369fg06_power_is_on(lcd->power))\r\nret = ams369fg06_power_off(lcd);\r\nif (!ret)\r\nlcd->power = power;\r\nreturn ret;\r\n}\r\nstatic int ams369fg06_get_power(struct lcd_device *ld)\r\n{\r\nstruct ams369fg06 *lcd = lcd_get_data(ld);\r\nreturn lcd->power;\r\n}\r\nstatic int ams369fg06_set_power(struct lcd_device *ld, int power)\r\n{\r\nstruct ams369fg06 *lcd = lcd_get_data(ld);\r\nif (power != FB_BLANK_UNBLANK && power != FB_BLANK_POWERDOWN &&\r\npower != FB_BLANK_NORMAL) {\r\ndev_err(lcd->dev, "power value should be 0, 1 or 4.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn ams369fg06_power(lcd, power);\r\n}\r\nstatic int ams369fg06_get_brightness(struct backlight_device *bd)\r\n{\r\nreturn bd->props.brightness;\r\n}\r\nstatic int ams369fg06_set_brightness(struct backlight_device *bd)\r\n{\r\nint ret = 0;\r\nint brightness = bd->props.brightness;\r\nstruct ams369fg06 *lcd = dev_get_drvdata(&bd->dev);\r\nif (brightness < MIN_BRIGHTNESS ||\r\nbrightness > bd->props.max_brightness) {\r\ndev_err(&bd->dev, "lcd brightness should be %d to %d.\n",\r\nMIN_BRIGHTNESS, MAX_BRIGHTNESS);\r\nreturn -EINVAL;\r\n}\r\nret = ams369fg06_gamma_ctl(lcd, bd->props.brightness);\r\nif (ret) {\r\ndev_err(&bd->dev, "lcd brightness setting failed.\n");\r\nreturn -EIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devinit ams369fg06_probe(struct spi_device *spi)\r\n{\r\nint ret = 0;\r\nstruct ams369fg06 *lcd = NULL;\r\nstruct lcd_device *ld = NULL;\r\nstruct backlight_device *bd = NULL;\r\nstruct backlight_properties props;\r\nlcd = kzalloc(sizeof(struct ams369fg06), GFP_KERNEL);\r\nif (!lcd)\r\nreturn -ENOMEM;\r\nspi->bits_per_word = 16;\r\nret = spi_setup(spi);\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "spi setup failed.\n");\r\ngoto out_free_lcd;\r\n}\r\nlcd->spi = spi;\r\nlcd->dev = &spi->dev;\r\nlcd->lcd_pd = spi->dev.platform_data;\r\nif (!lcd->lcd_pd) {\r\ndev_err(&spi->dev, "platform data is NULL\n");\r\ngoto out_free_lcd;\r\n}\r\nld = lcd_device_register("ams369fg06", &spi->dev, lcd,\r\n&ams369fg06_lcd_ops);\r\nif (IS_ERR(ld)) {\r\nret = PTR_ERR(ld);\r\ngoto out_free_lcd;\r\n}\r\nlcd->ld = ld;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = MAX_BRIGHTNESS;\r\nbd = backlight_device_register("ams369fg06-bl", &spi->dev, lcd,\r\n&ams369fg06_backlight_ops, &props);\r\nif (IS_ERR(bd)) {\r\nret = PTR_ERR(bd);\r\ngoto out_lcd_unregister;\r\n}\r\nbd->props.brightness = DEFAULT_BRIGHTNESS;\r\nlcd->bd = bd;\r\nif (!lcd->lcd_pd->lcd_enabled) {\r\nlcd->power = FB_BLANK_POWERDOWN;\r\nams369fg06_power(lcd, FB_BLANK_UNBLANK);\r\n} else\r\nlcd->power = FB_BLANK_UNBLANK;\r\ndev_set_drvdata(&spi->dev, lcd);\r\ndev_info(&spi->dev, "ams369fg06 panel driver has been probed.\n");\r\nreturn 0;\r\nout_lcd_unregister:\r\nlcd_device_unregister(ld);\r\nout_free_lcd:\r\nkfree(lcd);\r\nreturn ret;\r\n}\r\nstatic int __devexit ams369fg06_remove(struct spi_device *spi)\r\n{\r\nstruct ams369fg06 *lcd = dev_get_drvdata(&spi->dev);\r\nams369fg06_power(lcd, FB_BLANK_POWERDOWN);\r\nbacklight_device_unregister(lcd->bd);\r\nlcd_device_unregister(lcd->ld);\r\nkfree(lcd);\r\nreturn 0;\r\n}\r\nstatic int ams369fg06_suspend(struct spi_device *spi, pm_message_t mesg)\r\n{\r\nint ret = 0;\r\nstruct ams369fg06 *lcd = dev_get_drvdata(&spi->dev);\r\ndev_dbg(&spi->dev, "lcd->power = %d\n", lcd->power);\r\nbefore_power = lcd->power;\r\nret = ams369fg06_power(lcd, FB_BLANK_POWERDOWN);\r\nreturn ret;\r\n}\r\nstatic int ams369fg06_resume(struct spi_device *spi)\r\n{\r\nint ret = 0;\r\nstruct ams369fg06 *lcd = dev_get_drvdata(&spi->dev);\r\nif (before_power == FB_BLANK_UNBLANK)\r\nlcd->power = FB_BLANK_POWERDOWN;\r\ndev_dbg(&spi->dev, "before_power = %d\n", before_power);\r\nret = ams369fg06_power(lcd, before_power);\r\nreturn ret;\r\n}\r\nstatic void ams369fg06_shutdown(struct spi_device *spi)\r\n{\r\nstruct ams369fg06 *lcd = dev_get_drvdata(&spi->dev);\r\nams369fg06_power(lcd, FB_BLANK_POWERDOWN);\r\n}\r\nstatic int __init ams369fg06_init(void)\r\n{\r\nreturn spi_register_driver(&ams369fg06_driver);\r\n}\r\nstatic void __exit ams369fg06_exit(void)\r\n{\r\nspi_unregister_driver(&ams369fg06_driver);\r\n}
