static inline int twl6030_writeb(struct twl6030_usb *twl, u8 module,\r\nu8 data, u8 address)\r\n{\r\nint ret = 0;\r\nret = twl_i2c_write_u8(module, data, address);\r\nif (ret < 0)\r\ndev_err(twl->dev,\r\n"Write[0x%x] Error %d\n", address, ret);\r\nreturn ret;\r\n}\r\nstatic inline u8 twl6030_readb(struct twl6030_usb *twl, u8 module, u8 address)\r\n{\r\nu8 data, ret = 0;\r\nret = twl_i2c_read_u8(module, &data, address);\r\nif (ret >= 0)\r\nret = data;\r\nelse\r\ndev_err(twl->dev,\r\n"readb[0x%x,0x%x] Error %d\n",\r\nmodule, address, ret);\r\nreturn ret;\r\n}\r\nstatic int twl6030_phy_init(struct otg_transceiver *x)\r\n{\r\nstruct twl6030_usb *twl;\r\nstruct device *dev;\r\nstruct twl4030_usb_data *pdata;\r\ntwl = xceiv_to_twl(x);\r\ndev = twl->dev;\r\npdata = dev->platform_data;\r\nif (twl->linkstat == USB_EVENT_ID)\r\npdata->phy_power(twl->dev, 1, 1);\r\nelse\r\npdata->phy_power(twl->dev, 0, 1);\r\nreturn 0;\r\n}\r\nstatic void twl6030_phy_shutdown(struct otg_transceiver *x)\r\n{\r\nstruct twl6030_usb *twl;\r\nstruct device *dev;\r\nstruct twl4030_usb_data *pdata;\r\ntwl = xceiv_to_twl(x);\r\ndev = twl->dev;\r\npdata = dev->platform_data;\r\npdata->phy_power(twl->dev, 0, 0);\r\n}\r\nstatic int twl6030_phy_suspend(struct otg_transceiver *x, int suspend)\r\n{\r\nstruct twl6030_usb *twl = xceiv_to_twl(x);\r\nstruct device *dev = twl->dev;\r\nstruct twl4030_usb_data *pdata = dev->platform_data;\r\npdata->phy_suspend(dev, suspend);\r\nreturn 0;\r\n}\r\nstatic int twl6030_start_srp(struct otg_transceiver *x)\r\n{\r\nstruct twl6030_usb *twl = xceiv_to_twl(x);\r\ntwl6030_writeb(twl, TWL_MODULE_USB, 0x24, USB_VBUS_CTRL_SET);\r\ntwl6030_writeb(twl, TWL_MODULE_USB, 0x84, USB_VBUS_CTRL_SET);\r\nmdelay(100);\r\ntwl6030_writeb(twl, TWL_MODULE_USB, 0xa0, USB_VBUS_CTRL_CLR);\r\nreturn 0;\r\n}\r\nstatic int twl6030_usb_ldo_init(struct twl6030_usb *twl)\r\n{\r\nchar *regulator_name;\r\nif (twl->features & TWL6025_SUBCLASS)\r\nregulator_name = "ldousb";\r\nelse\r\nregulator_name = "vusb";\r\ntwl6030_writeb(twl, TWL6030_MODULE_ID0 , 0x1, TWL6030_BACKUP_REG);\r\ntwl6030_writeb(twl, TWL6030_MODULE_ID0 , 0x1, TWL6030_CFG_LDO_PD2);\r\ntwl6030_writeb(twl, TWL6030_MODULE_ID0 , 0x10, TWL6030_MISC2);\r\ntwl->usb3v3 = regulator_get(twl->dev, regulator_name);\r\nif (IS_ERR(twl->usb3v3))\r\nreturn -ENODEV;\r\ntwl6030_writeb(twl, TWL_MODULE_USB, 0x4, USB_VBUS_CTRL_SET);\r\ntwl6030_writeb(twl, TWL_MODULE_USB, 0x14, USB_ID_CTRL_SET);\r\nreturn 0;\r\n}\r\nstatic ssize_t twl6030_usb_vbus_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct twl6030_usb *twl = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nspin_lock_irqsave(&twl->lock, flags);\r\nswitch (twl->linkstat) {\r\ncase USB_EVENT_VBUS:\r\nret = snprintf(buf, PAGE_SIZE, "vbus\n");\r\nbreak;\r\ncase USB_EVENT_ID:\r\nret = snprintf(buf, PAGE_SIZE, "id\n");\r\nbreak;\r\ncase USB_EVENT_NONE:\r\nret = snprintf(buf, PAGE_SIZE, "none\n");\r\nbreak;\r\ndefault:\r\nret = snprintf(buf, PAGE_SIZE, "UNKNOWN\n");\r\n}\r\nspin_unlock_irqrestore(&twl->lock, flags);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t twl6030_usb_irq(int irq, void *_twl)\r\n{\r\nstruct twl6030_usb *twl = _twl;\r\nint status;\r\nu8 vbus_state, hw_state;\r\nhw_state = twl6030_readb(twl, TWL6030_MODULE_ID0, STS_HW_CONDITIONS);\r\nvbus_state = twl6030_readb(twl, TWL_MODULE_MAIN_CHARGE,\r\nCONTROLLER_STAT1);\r\nif (!(hw_state & STS_USB_ID)) {\r\nif (vbus_state & VBUS_DET) {\r\nregulator_enable(twl->usb3v3);\r\ntwl->asleep = 1;\r\nstatus = USB_EVENT_VBUS;\r\ntwl->otg.default_a = false;\r\ntwl->otg.state = OTG_STATE_B_IDLE;\r\ntwl->linkstat = status;\r\ntwl->otg.last_event = status;\r\natomic_notifier_call_chain(&twl->otg.notifier,\r\nstatus, twl->otg.gadget);\r\n} else {\r\nstatus = USB_EVENT_NONE;\r\ntwl->linkstat = status;\r\ntwl->otg.last_event = status;\r\natomic_notifier_call_chain(&twl->otg.notifier,\r\nstatus, twl->otg.gadget);\r\nif (twl->asleep) {\r\nregulator_disable(twl->usb3v3);\r\ntwl->asleep = 0;\r\n}\r\n}\r\n}\r\nsysfs_notify(&twl->dev->kobj, NULL, "vbus");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t twl6030_usbotg_irq(int irq, void *_twl)\r\n{\r\nstruct twl6030_usb *twl = _twl;\r\nint status = USB_EVENT_NONE;\r\nu8 hw_state;\r\nhw_state = twl6030_readb(twl, TWL6030_MODULE_ID0, STS_HW_CONDITIONS);\r\nif (hw_state & STS_USB_ID) {\r\nregulator_enable(twl->usb3v3);\r\ntwl->asleep = 1;\r\ntwl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_EN_HI_CLR, 0x1);\r\ntwl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_EN_HI_SET,\r\n0x10);\r\nstatus = USB_EVENT_ID;\r\ntwl->otg.default_a = true;\r\ntwl->otg.state = OTG_STATE_A_IDLE;\r\ntwl->linkstat = status;\r\ntwl->otg.last_event = status;\r\natomic_notifier_call_chain(&twl->otg.notifier, status,\r\ntwl->otg.gadget);\r\n} else {\r\ntwl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_EN_HI_CLR,\r\n0x10);\r\ntwl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_EN_HI_SET,\r\n0x1);\r\n}\r\ntwl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_LATCH_CLR, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int twl6030_set_peripheral(struct otg_transceiver *x,\r\nstruct usb_gadget *gadget)\r\n{\r\nstruct twl6030_usb *twl;\r\nif (!x)\r\nreturn -ENODEV;\r\ntwl = xceiv_to_twl(x);\r\ntwl->otg.gadget = gadget;\r\nif (!gadget)\r\ntwl->otg.state = OTG_STATE_UNDEFINED;\r\nreturn 0;\r\n}\r\nstatic int twl6030_enable_irq(struct otg_transceiver *x)\r\n{\r\nstruct twl6030_usb *twl = xceiv_to_twl(x);\r\ntwl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_EN_HI_SET, 0x1);\r\ntwl6030_interrupt_unmask(0x05, REG_INT_MSK_LINE_C);\r\ntwl6030_interrupt_unmask(0x05, REG_INT_MSK_STS_C);\r\ntwl6030_interrupt_unmask(TWL6030_CHARGER_CTRL_INT_MASK,\r\nREG_INT_MSK_LINE_C);\r\ntwl6030_interrupt_unmask(TWL6030_CHARGER_CTRL_INT_MASK,\r\nREG_INT_MSK_STS_C);\r\ntwl6030_usb_irq(twl->irq2, twl);\r\ntwl6030_usbotg_irq(twl->irq1, twl);\r\nreturn 0;\r\n}\r\nstatic void otg_set_vbus_work(struct work_struct *data)\r\n{\r\nstruct twl6030_usb *twl = container_of(data, struct twl6030_usb,\r\nset_vbus_work);\r\nif (twl->vbus_enable)\r\ntwl6030_writeb(twl, TWL_MODULE_MAIN_CHARGE , 0x40,\r\nCHARGERUSB_CTRL1);\r\nelse\r\ntwl6030_writeb(twl, TWL_MODULE_MAIN_CHARGE , 0x00,\r\nCHARGERUSB_CTRL1);\r\n}\r\nstatic int twl6030_set_vbus(struct otg_transceiver *x, bool enabled)\r\n{\r\nstruct twl6030_usb *twl = xceiv_to_twl(x);\r\ntwl->vbus_enable = enabled;\r\nschedule_work(&twl->set_vbus_work);\r\nreturn 0;\r\n}\r\nstatic int twl6030_set_host(struct otg_transceiver *x, struct usb_bus *host)\r\n{\r\nstruct twl6030_usb *twl;\r\nif (!x)\r\nreturn -ENODEV;\r\ntwl = xceiv_to_twl(x);\r\ntwl->otg.host = host;\r\nif (!host)\r\ntwl->otg.state = OTG_STATE_UNDEFINED;\r\nreturn 0;\r\n}\r\nstatic int __devinit twl6030_usb_probe(struct platform_device *pdev)\r\n{\r\nstruct twl6030_usb *twl;\r\nint status, err;\r\nstruct twl4030_usb_data *pdata;\r\nstruct device *dev = &pdev->dev;\r\npdata = dev->platform_data;\r\ntwl = kzalloc(sizeof *twl, GFP_KERNEL);\r\nif (!twl)\r\nreturn -ENOMEM;\r\ntwl->dev = &pdev->dev;\r\ntwl->irq1 = platform_get_irq(pdev, 0);\r\ntwl->irq2 = platform_get_irq(pdev, 1);\r\ntwl->features = pdata->features;\r\ntwl->otg.dev = twl->dev;\r\ntwl->otg.label = "twl6030";\r\ntwl->otg.set_host = twl6030_set_host;\r\ntwl->otg.set_peripheral = twl6030_set_peripheral;\r\ntwl->otg.set_vbus = twl6030_set_vbus;\r\ntwl->otg.init = twl6030_phy_init;\r\ntwl->otg.shutdown = twl6030_phy_shutdown;\r\ntwl->otg.set_suspend = twl6030_phy_suspend;\r\ntwl->otg.start_srp = twl6030_start_srp;\r\nspin_lock_init(&twl->lock);\r\nerr = twl6030_usb_ldo_init(twl);\r\nif (err) {\r\ndev_err(&pdev->dev, "ldo init failed\n");\r\nkfree(twl);\r\nreturn err;\r\n}\r\notg_set_transceiver(&twl->otg);\r\nplatform_set_drvdata(pdev, twl);\r\nif (device_create_file(&pdev->dev, &dev_attr_vbus))\r\ndev_warn(&pdev->dev, "could not create sysfs file\n");\r\nATOMIC_INIT_NOTIFIER_HEAD(&twl->otg.notifier);\r\nINIT_WORK(&twl->set_vbus_work, otg_set_vbus_work);\r\ntwl->irq_enabled = true;\r\nstatus = request_threaded_irq(twl->irq1, NULL, twl6030_usbotg_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,\r\n"twl6030_usb", twl);\r\nif (status < 0) {\r\ndev_err(&pdev->dev, "can't get IRQ %d, err %d\n",\r\ntwl->irq1, status);\r\ndevice_remove_file(twl->dev, &dev_attr_vbus);\r\nkfree(twl);\r\nreturn status;\r\n}\r\nstatus = request_threaded_irq(twl->irq2, NULL, twl6030_usb_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,\r\n"twl6030_usb", twl);\r\nif (status < 0) {\r\ndev_err(&pdev->dev, "can't get IRQ %d, err %d\n",\r\ntwl->irq2, status);\r\nfree_irq(twl->irq1, twl);\r\ndevice_remove_file(twl->dev, &dev_attr_vbus);\r\nkfree(twl);\r\nreturn status;\r\n}\r\ntwl->asleep = 0;\r\npdata->phy_init(dev);\r\ntwl6030_phy_suspend(&twl->otg, 0);\r\ntwl6030_enable_irq(&twl->otg);\r\ndev_info(&pdev->dev, "Initialized TWL6030 USB module\n");\r\nreturn 0;\r\n}\r\nstatic int __exit twl6030_usb_remove(struct platform_device *pdev)\r\n{\r\nstruct twl6030_usb *twl = platform_get_drvdata(pdev);\r\nstruct twl4030_usb_data *pdata;\r\nstruct device *dev = &pdev->dev;\r\npdata = dev->platform_data;\r\ntwl6030_interrupt_mask(TWL6030_USBOTG_INT_MASK,\r\nREG_INT_MSK_LINE_C);\r\ntwl6030_interrupt_mask(TWL6030_USBOTG_INT_MASK,\r\nREG_INT_MSK_STS_C);\r\nfree_irq(twl->irq1, twl);\r\nfree_irq(twl->irq2, twl);\r\nregulator_put(twl->usb3v3);\r\npdata->phy_exit(twl->dev);\r\ndevice_remove_file(twl->dev, &dev_attr_vbus);\r\ncancel_work_sync(&twl->set_vbus_work);\r\nkfree(twl);\r\nreturn 0;\r\n}\r\nstatic int __init twl6030_usb_init(void)\r\n{\r\nreturn platform_driver_register(&twl6030_usb_driver);\r\n}\r\nstatic void __exit twl6030_usb_exit(void)\r\n{\r\nplatform_driver_unregister(&twl6030_usb_driver);\r\n}
