static void\r\nmwifiex_wmm_ac_debug_print(const struct ieee_types_wmm_ac_parameters *ac_param)\r\n{\r\nconst char *ac_str[] = { "BK", "BE", "VI", "VO" };\r\npr_debug("info: WMM AC_%s: ACI=%d, ACM=%d, Aifsn=%d, "\r\n"EcwMin=%d, EcwMax=%d, TxopLimit=%d\n",\r\nac_str[wmm_aci_to_qidx_map[(ac_param->aci_aifsn_bitmap\r\n& MWIFIEX_ACI) >> 5]],\r\n(ac_param->aci_aifsn_bitmap & MWIFIEX_ACI) >> 5,\r\n(ac_param->aci_aifsn_bitmap & MWIFIEX_ACM) >> 4,\r\nac_param->aci_aifsn_bitmap & MWIFIEX_AIFSN,\r\nac_param->ecw_bitmap & MWIFIEX_ECW_MIN,\r\n(ac_param->ecw_bitmap & MWIFIEX_ECW_MAX) >> 4,\r\nle16_to_cpu(ac_param->tx_op_limit));\r\n}\r\nstatic struct mwifiex_ra_list_tbl *\r\nmwifiex_wmm_allocate_ralist_node(struct mwifiex_adapter *adapter, u8 *ra)\r\n{\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nra_list = kzalloc(sizeof(struct mwifiex_ra_list_tbl), GFP_ATOMIC);\r\nif (!ra_list) {\r\ndev_err(adapter->dev, "%s: failed to alloc ra_list\n",\r\n__func__);\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&ra_list->list);\r\nskb_queue_head_init(&ra_list->skb_head);\r\nmemcpy(ra_list->ra, ra, ETH_ALEN);\r\nra_list->total_pkts_size = 0;\r\ndev_dbg(adapter->dev, "info: allocated ra_list %p\n", ra_list);\r\nreturn ra_list;\r\n}\r\nvoid\r\nmwifiex_ralist_add(struct mwifiex_private *priv, u8 *ra)\r\n{\r\nint i;\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nfor (i = 0; i < MAX_NUM_TID; ++i) {\r\nra_list = mwifiex_wmm_allocate_ralist_node(adapter, ra);\r\ndev_dbg(adapter->dev, "info: created ra_list %p\n", ra_list);\r\nif (!ra_list)\r\nbreak;\r\nif (!mwifiex_queuing_ra_based(priv))\r\nra_list->is_11n_enabled = IS_11N_ENABLED(priv);\r\nelse\r\nra_list->is_11n_enabled = false;\r\ndev_dbg(adapter->dev, "data: ralist %p: is_11n_enabled=%d\n",\r\nra_list, ra_list->is_11n_enabled);\r\nlist_add_tail(&ra_list->list,\r\n&priv->wmm.tid_tbl_ptr[i].ra_list);\r\nif (!priv->wmm.tid_tbl_ptr[i].ra_list_curr)\r\npriv->wmm.tid_tbl_ptr[i].ra_list_curr = ra_list;\r\n}\r\n}\r\nstatic void mwifiex_wmm_default_queue_priorities(struct mwifiex_private *priv)\r\n{\r\npriv->wmm.queue_priority[0] = WMM_AC_VO;\r\npriv->wmm.queue_priority[1] = WMM_AC_VI;\r\npriv->wmm.queue_priority[2] = WMM_AC_BE;\r\npriv->wmm.queue_priority[3] = WMM_AC_BK;\r\n}\r\nstatic void\r\nmwifiex_wmm_queue_priorities_tid(struct mwifiex_wmm_desc *wmm)\r\n{\r\nu8 *queue_priority = wmm->queue_priority;\r\nint i;\r\nfor (i = 0; i < 4; ++i) {\r\ntos_to_tid[7 - (i * 2)] = ac_to_tid[queue_priority[i]][1];\r\ntos_to_tid[6 - (i * 2)] = ac_to_tid[queue_priority[i]][0];\r\n}\r\nfor (i = 0; i < MAX_NUM_TID; ++i)\r\ntos_to_tid_inv[tos_to_tid[i]] = (u8)i;\r\natomic_set(&wmm->highest_queued_prio, HIGH_PRIO_TID);\r\n}\r\nvoid\r\nmwifiex_wmm_setup_queue_priorities(struct mwifiex_private *priv,\r\nstruct ieee_types_wmm_parameter *wmm_ie)\r\n{\r\nu16 cw_min, avg_back_off, tmp[4];\r\nu32 i, j, num_ac;\r\nu8 ac_idx;\r\nif (!wmm_ie || !priv->wmm_enabled) {\r\nmwifiex_wmm_default_queue_priorities(priv);\r\nreturn;\r\n}\r\ndev_dbg(priv->adapter->dev, "info: WMM Parameter IE: version=%d, "\r\n"qos_info Parameter Set Count=%d, Reserved=%#x\n",\r\nwmm_ie->vend_hdr.version, wmm_ie->qos_info_bitmap &\r\nIEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK,\r\nwmm_ie->reserved);\r\nfor (num_ac = 0; num_ac < ARRAY_SIZE(wmm_ie->ac_params); num_ac++) {\r\ncw_min = (1 << (wmm_ie->ac_params[num_ac].ecw_bitmap &\r\nMWIFIEX_ECW_MIN)) - 1;\r\navg_back_off = (cw_min >> 1) +\r\n(wmm_ie->ac_params[num_ac].aci_aifsn_bitmap &\r\nMWIFIEX_AIFSN);\r\nac_idx = wmm_aci_to_qidx_map[(wmm_ie->ac_params[num_ac].\r\naci_aifsn_bitmap &\r\nMWIFIEX_ACI) >> 5];\r\npriv->wmm.queue_priority[ac_idx] = ac_idx;\r\ntmp[ac_idx] = avg_back_off;\r\ndev_dbg(priv->adapter->dev, "info: WMM: CWmax=%d CWmin=%d Avg Back-off=%d\n",\r\n(1 << ((wmm_ie->ac_params[num_ac].ecw_bitmap &\r\nMWIFIEX_ECW_MAX) >> 4)) - 1,\r\ncw_min, avg_back_off);\r\nmwifiex_wmm_ac_debug_print(&wmm_ie->ac_params[num_ac]);\r\n}\r\nfor (i = 0; i < num_ac; i++) {\r\nfor (j = 1; j < num_ac - i; j++) {\r\nif (tmp[j - 1] > tmp[j]) {\r\nswap(tmp[j - 1], tmp[j]);\r\nswap(priv->wmm.queue_priority[j - 1],\r\npriv->wmm.queue_priority[j]);\r\n} else if (tmp[j - 1] == tmp[j]) {\r\nif (priv->wmm.queue_priority[j - 1]\r\n< priv->wmm.queue_priority[j])\r\nswap(priv->wmm.queue_priority[j - 1],\r\npriv->wmm.queue_priority[j]);\r\n}\r\n}\r\n}\r\nmwifiex_wmm_queue_priorities_tid(&priv->wmm);\r\n}\r\nstatic enum mwifiex_wmm_ac_e\r\nmwifiex_wmm_eval_downgrade_ac(struct mwifiex_private *priv,\r\nenum mwifiex_wmm_ac_e eval_ac)\r\n{\r\nint down_ac;\r\nenum mwifiex_wmm_ac_e ret_ac;\r\nstruct mwifiex_wmm_ac_status *ac_status;\r\nac_status = &priv->wmm.ac_status[eval_ac];\r\nif (!ac_status->disabled)\r\nreturn eval_ac;\r\nret_ac = WMM_AC_BK;\r\nfor (down_ac = WMM_AC_BK; down_ac < eval_ac; down_ac++) {\r\nac_status = &priv->wmm.ac_status[down_ac];\r\nif (!ac_status->disabled && !ac_status->flow_required)\r\nret_ac = (enum mwifiex_wmm_ac_e) down_ac;\r\n}\r\nreturn ret_ac;\r\n}\r\nvoid\r\nmwifiex_wmm_setup_ac_downgrade(struct mwifiex_private *priv)\r\n{\r\nint ac_val;\r\ndev_dbg(priv->adapter->dev, "info: WMM: AC Priorities:"\r\n"BK(0), BE(1), VI(2), VO(3)\n");\r\nif (!priv->wmm_enabled) {\r\nfor (ac_val = WMM_AC_BK; ac_val <= WMM_AC_VO; ac_val++)\r\npriv->wmm.ac_down_graded_vals[ac_val] =\r\n(enum mwifiex_wmm_ac_e) ac_val;\r\n} else {\r\nfor (ac_val = WMM_AC_BK; ac_val <= WMM_AC_VO; ac_val++) {\r\npriv->wmm.ac_down_graded_vals[ac_val]\r\n= mwifiex_wmm_eval_downgrade_ac(priv,\r\n(enum mwifiex_wmm_ac_e) ac_val);\r\ndev_dbg(priv->adapter->dev, "info: WMM: AC PRIO %d maps to %d\n",\r\nac_val, priv->wmm.ac_down_graded_vals[ac_val]);\r\n}\r\n}\r\n}\r\nstatic enum mwifiex_wmm_ac_e\r\nmwifiex_wmm_convert_tos_to_ac(struct mwifiex_adapter *adapter, u32 tos)\r\n{\r\nconst enum mwifiex_wmm_ac_e tos_to_ac[] = { WMM_AC_BE,\r\nWMM_AC_BK,\r\nWMM_AC_BK,\r\nWMM_AC_BE,\r\nWMM_AC_VI,\r\nWMM_AC_VI,\r\nWMM_AC_VO,\r\nWMM_AC_VO\r\n};\r\nif (tos >= ARRAY_SIZE(tos_to_ac))\r\nreturn WMM_AC_BE;\r\nreturn tos_to_ac[tos];\r\n}\r\nstatic u8\r\nmwifiex_wmm_downgrade_tid(struct mwifiex_private *priv, u32 tid)\r\n{\r\nenum mwifiex_wmm_ac_e ac, ac_down;\r\nu8 new_tid;\r\nac = mwifiex_wmm_convert_tos_to_ac(priv->adapter, tid);\r\nac_down = priv->wmm.ac_down_graded_vals[ac];\r\nnew_tid = ac_to_tid[ac_down][tid % 2];\r\nreturn new_tid;\r\n}\r\nvoid\r\nmwifiex_wmm_init(struct mwifiex_adapter *adapter)\r\n{\r\nint i, j;\r\nstruct mwifiex_private *priv;\r\nfor (j = 0; j < adapter->priv_num; ++j) {\r\npriv = adapter->priv[j];\r\nif (!priv)\r\ncontinue;\r\nfor (i = 0; i < MAX_NUM_TID; ++i) {\r\npriv->aggr_prio_tbl[i].amsdu = tos_to_tid_inv[i];\r\npriv->aggr_prio_tbl[i].ampdu_ap = tos_to_tid_inv[i];\r\npriv->aggr_prio_tbl[i].ampdu_user = tos_to_tid_inv[i];\r\npriv->wmm.tid_tbl_ptr[i].ra_list_curr = NULL;\r\n}\r\npriv->aggr_prio_tbl[6].amsdu\r\n= priv->aggr_prio_tbl[6].ampdu_ap\r\n= priv->aggr_prio_tbl[6].ampdu_user\r\n= BA_STREAM_NOT_ALLOWED;\r\npriv->aggr_prio_tbl[7].amsdu = priv->aggr_prio_tbl[7].ampdu_ap\r\n= priv->aggr_prio_tbl[7].ampdu_user\r\n= BA_STREAM_NOT_ALLOWED;\r\npriv->add_ba_param.timeout = MWIFIEX_DEFAULT_BLOCK_ACK_TIMEOUT;\r\npriv->add_ba_param.tx_win_size = MWIFIEX_AMPDU_DEF_TXWINSIZE;\r\npriv->add_ba_param.rx_win_size = MWIFIEX_AMPDU_DEF_RXWINSIZE;\r\natomic_set(&priv->wmm.tx_pkts_queued, 0);\r\natomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\r\n}\r\n}\r\nint\r\nmwifiex_wmm_lists_empty(struct mwifiex_adapter *adapter)\r\n{\r\nint i;\r\nstruct mwifiex_private *priv;\r\nfor (i = 0; i < adapter->priv_num; ++i) {\r\npriv = adapter->priv[i];\r\nif (priv && atomic_read(&priv->wmm.tx_pkts_queued))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void\r\nmwifiex_wmm_del_pkts_in_ralist_node(struct mwifiex_private *priv,\r\nstruct mwifiex_ra_list_tbl *ra_list)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct sk_buff *skb, *tmp;\r\nskb_queue_walk_safe(&ra_list->skb_head, skb, tmp)\r\nmwifiex_write_data_complete(adapter, skb, -1);\r\n}\r\nstatic void\r\nmwifiex_wmm_del_pkts_in_ralist(struct mwifiex_private *priv,\r\nstruct list_head *ra_list_head)\r\n{\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nlist_for_each_entry(ra_list, ra_list_head, list)\r\nmwifiex_wmm_del_pkts_in_ralist_node(priv, ra_list);\r\n}\r\nstatic void mwifiex_wmm_cleanup_queues(struct mwifiex_private *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_NUM_TID; i++)\r\nmwifiex_wmm_del_pkts_in_ralist(priv, &priv->wmm.tid_tbl_ptr[i].\r\nra_list);\r\natomic_set(&priv->wmm.tx_pkts_queued, 0);\r\natomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\r\n}\r\nstatic void mwifiex_wmm_delete_all_ralist(struct mwifiex_private *priv)\r\n{\r\nstruct mwifiex_ra_list_tbl *ra_list, *tmp_node;\r\nint i;\r\nfor (i = 0; i < MAX_NUM_TID; ++i) {\r\ndev_dbg(priv->adapter->dev,\r\n"info: ra_list: freeing buf for tid %d\n", i);\r\nlist_for_each_entry_safe(ra_list, tmp_node,\r\n&priv->wmm.tid_tbl_ptr[i].ra_list, list) {\r\nlist_del(&ra_list->list);\r\nkfree(ra_list);\r\n}\r\nINIT_LIST_HEAD(&priv->wmm.tid_tbl_ptr[i].ra_list);\r\npriv->wmm.tid_tbl_ptr[i].ra_list_curr = NULL;\r\n}\r\n}\r\nvoid\r\nmwifiex_clean_txrx(struct mwifiex_private *priv)\r\n{\r\nunsigned long flags;\r\nmwifiex_11n_cleanup_reorder_tbl(priv);\r\nspin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);\r\nmwifiex_wmm_cleanup_queues(priv);\r\nmwifiex_11n_delete_all_tx_ba_stream_tbl(priv);\r\nif (priv->adapter->if_ops.cleanup_mpa_buf)\r\npriv->adapter->if_ops.cleanup_mpa_buf(priv->adapter);\r\nmwifiex_wmm_delete_all_ralist(priv);\r\nmemcpy(tos_to_tid, ac_to_tid, sizeof(tos_to_tid));\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);\r\n}\r\nstatic struct mwifiex_ra_list_tbl *\r\nmwifiex_wmm_get_ralist_node(struct mwifiex_private *priv, u8 tid,\r\nu8 *ra_addr)\r\n{\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nlist_for_each_entry(ra_list, &priv->wmm.tid_tbl_ptr[tid].ra_list,\r\nlist) {\r\nif (!memcmp(ra_list->ra, ra_addr, ETH_ALEN))\r\nreturn ra_list;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mwifiex_ra_list_tbl *\r\nmwifiex_wmm_get_queue_raptr(struct mwifiex_private *priv, u8 tid, u8 *ra_addr)\r\n{\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nra_list = mwifiex_wmm_get_ralist_node(priv, tid, ra_addr);\r\nif (ra_list)\r\nreturn ra_list;\r\nmwifiex_ralist_add(priv, ra_addr);\r\nreturn mwifiex_wmm_get_ralist_node(priv, tid, ra_addr);\r\n}\r\nint\r\nmwifiex_is_ralist_valid(struct mwifiex_private *priv,\r\nstruct mwifiex_ra_list_tbl *ra_list, int ptr_index)\r\n{\r\nstruct mwifiex_ra_list_tbl *rlist;\r\nlist_for_each_entry(rlist, &priv->wmm.tid_tbl_ptr[ptr_index].ra_list,\r\nlist) {\r\nif (rlist == ra_list)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid\r\nmwifiex_wmm_add_buf_txqueue(struct mwifiex_adapter *adapter,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mwifiex_txinfo *tx_info = MWIFIEX_SKB_TXCB(skb);\r\nstruct mwifiex_private *priv = adapter->priv[tx_info->bss_index];\r\nu32 tid;\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nu8 ra[ETH_ALEN], tid_down;\r\nunsigned long flags;\r\nif (!priv->media_connected) {\r\ndev_dbg(adapter->dev, "data: drop packet in disconnect\n");\r\nmwifiex_write_data_complete(adapter, skb, -1);\r\nreturn;\r\n}\r\ntid = skb->priority;\r\nspin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);\r\ntid_down = mwifiex_wmm_downgrade_tid(priv, tid);\r\nif (!mwifiex_queuing_ra_based(priv)) {\r\nif (!list_empty(&priv->wmm.tid_tbl_ptr[tid_down].ra_list))\r\nra_list = list_first_entry(\r\n&priv->wmm.tid_tbl_ptr[tid_down].ra_list,\r\nstruct mwifiex_ra_list_tbl, list);\r\nelse\r\nra_list = NULL;\r\n} else {\r\nmemcpy(ra, skb->data, ETH_ALEN);\r\nif (ra[0] & 0x01)\r\nmemset(ra, 0xff, ETH_ALEN);\r\nra_list = mwifiex_wmm_get_queue_raptr(priv, tid_down, ra);\r\n}\r\nif (!ra_list) {\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);\r\nmwifiex_write_data_complete(adapter, skb, -1);\r\nreturn;\r\n}\r\nskb_queue_tail(&ra_list->skb_head, skb);\r\nra_list->total_pkts_size += skb->len;\r\natomic_inc(&priv->wmm.tx_pkts_queued);\r\nif (atomic_read(&priv->wmm.highest_queued_prio) <\r\ntos_to_tid_inv[tid_down])\r\natomic_set(&priv->wmm.highest_queued_prio,\r\ntos_to_tid_inv[tid_down]);\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);\r\n}\r\nint mwifiex_ret_wmm_get_status(struct mwifiex_private *priv,\r\nconst struct host_cmd_ds_command *resp)\r\n{\r\nu8 *curr = (u8 *) &resp->params.get_wmm_status;\r\nuint16_t resp_len = le16_to_cpu(resp->size), tlv_len;\r\nint valid = true;\r\nstruct mwifiex_ie_types_data *tlv_hdr;\r\nstruct mwifiex_ie_types_wmm_queue_status *tlv_wmm_qstatus;\r\nstruct ieee_types_wmm_parameter *wmm_param_ie = NULL;\r\nstruct mwifiex_wmm_ac_status *ac_status;\r\ndev_dbg(priv->adapter->dev, "info: WMM: WMM_GET_STATUS cmdresp received: %d\n",\r\nresp_len);\r\nwhile ((resp_len >= sizeof(tlv_hdr->header)) && valid) {\r\ntlv_hdr = (struct mwifiex_ie_types_data *) curr;\r\ntlv_len = le16_to_cpu(tlv_hdr->header.len);\r\nswitch (le16_to_cpu(tlv_hdr->header.type)) {\r\ncase TLV_TYPE_WMMQSTATUS:\r\ntlv_wmm_qstatus =\r\n(struct mwifiex_ie_types_wmm_queue_status *)\r\ntlv_hdr;\r\ndev_dbg(priv->adapter->dev,\r\n"info: CMD_RESP: WMM_GET_STATUS:"\r\n" QSTATUS TLV: %d, %d, %d\n",\r\ntlv_wmm_qstatus->queue_index,\r\ntlv_wmm_qstatus->flow_required,\r\ntlv_wmm_qstatus->disabled);\r\nac_status = &priv->wmm.ac_status[tlv_wmm_qstatus->\r\nqueue_index];\r\nac_status->disabled = tlv_wmm_qstatus->disabled;\r\nac_status->flow_required =\r\ntlv_wmm_qstatus->flow_required;\r\nac_status->flow_created = tlv_wmm_qstatus->flow_created;\r\nbreak;\r\ncase WLAN_EID_VENDOR_SPECIFIC:\r\nwmm_param_ie =\r\n(struct ieee_types_wmm_parameter *) (curr +\r\n2);\r\nwmm_param_ie->vend_hdr.len = (u8) tlv_len;\r\nwmm_param_ie->vend_hdr.element_id =\r\nWLAN_EID_VENDOR_SPECIFIC;\r\ndev_dbg(priv->adapter->dev,\r\n"info: CMD_RESP: WMM_GET_STATUS:"\r\n" WMM Parameter Set Count: %d\n",\r\nwmm_param_ie->qos_info_bitmap &\r\nIEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK);\r\nmemcpy((u8 *) &priv->curr_bss_params.bss_descriptor.\r\nwmm_ie, wmm_param_ie,\r\nwmm_param_ie->vend_hdr.len + 2);\r\nbreak;\r\ndefault:\r\nvalid = false;\r\nbreak;\r\n}\r\ncurr += (tlv_len + sizeof(tlv_hdr->header));\r\nresp_len -= (tlv_len + sizeof(tlv_hdr->header));\r\n}\r\nmwifiex_wmm_setup_queue_priorities(priv, wmm_param_ie);\r\nmwifiex_wmm_setup_ac_downgrade(priv);\r\nreturn 0;\r\n}\r\nu32\r\nmwifiex_wmm_process_association_req(struct mwifiex_private *priv,\r\nu8 **assoc_buf,\r\nstruct ieee_types_wmm_parameter *wmm_ie,\r\nstruct ieee80211_ht_cap *ht_cap)\r\n{\r\nstruct mwifiex_ie_types_wmm_param_set *wmm_tlv;\r\nu32 ret_len = 0;\r\nif (!assoc_buf)\r\nreturn 0;\r\nif (!(*assoc_buf))\r\nreturn 0;\r\nif (!wmm_ie)\r\nreturn 0;\r\ndev_dbg(priv->adapter->dev, "info: WMM: process assoc req:"\r\n"bss->wmmIe=0x%x\n",\r\nwmm_ie->vend_hdr.element_id);\r\nif ((priv->wmm_required\r\n|| (ht_cap && (priv->adapter->config_bands & BAND_GN\r\n|| priv->adapter->config_bands & BAND_AN))\r\n)\r\n&& wmm_ie->vend_hdr.element_id == WLAN_EID_VENDOR_SPECIFIC) {\r\nwmm_tlv = (struct mwifiex_ie_types_wmm_param_set *) *assoc_buf;\r\nwmm_tlv->header.type = cpu_to_le16((u16) wmm_info_ie[0]);\r\nwmm_tlv->header.len = cpu_to_le16((u16) wmm_info_ie[1]);\r\nmemcpy(wmm_tlv->wmm_ie, &wmm_info_ie[2],\r\nle16_to_cpu(wmm_tlv->header.len));\r\nif (wmm_ie->qos_info_bitmap & IEEE80211_WMM_IE_AP_QOSINFO_UAPSD)\r\nmemcpy((u8 *) (wmm_tlv->wmm_ie\r\n+ le16_to_cpu(wmm_tlv->header.len)\r\n- sizeof(priv->wmm_qosinfo)),\r\n&priv->wmm_qosinfo,\r\nsizeof(priv->wmm_qosinfo));\r\nret_len = sizeof(wmm_tlv->header)\r\n+ le16_to_cpu(wmm_tlv->header.len);\r\n*assoc_buf += ret_len;\r\n}\r\nreturn ret_len;\r\n}\r\nu8\r\nmwifiex_wmm_compute_drv_pkt_delay(struct mwifiex_private *priv,\r\nconst struct sk_buff *skb)\r\n{\r\nu8 ret_val;\r\nstruct timeval out_tstamp, in_tstamp;\r\nu32 queue_delay;\r\ndo_gettimeofday(&out_tstamp);\r\nin_tstamp = ktime_to_timeval(skb->tstamp);\r\nqueue_delay = (out_tstamp.tv_sec - in_tstamp.tv_sec) * 1000;\r\nqueue_delay += (out_tstamp.tv_usec - in_tstamp.tv_usec) / 1000;\r\nret_val = (u8) (min(queue_delay, priv->wmm.drv_pkt_delay_max) >> 1);\r\ndev_dbg(priv->adapter->dev, "data: WMM: Pkt Delay: %d ms,"\r\n" %d ms sent to FW\n", queue_delay, ret_val);\r\nreturn ret_val;\r\n}\r\nstatic struct mwifiex_ra_list_tbl *\r\nmwifiex_wmm_get_highest_priolist_ptr(struct mwifiex_adapter *adapter,\r\nstruct mwifiex_private **priv, int *tid)\r\n{\r\nstruct mwifiex_private *priv_tmp;\r\nstruct mwifiex_ra_list_tbl *ptr, *head;\r\nstruct mwifiex_bss_prio_node *bssprio_node, *bssprio_head;\r\nstruct mwifiex_tid_tbl *tid_ptr;\r\nint is_list_empty;\r\nunsigned long flags;\r\nint i, j;\r\nfor (j = adapter->priv_num - 1; j >= 0; --j) {\r\nspin_lock_irqsave(&adapter->bss_prio_tbl[j].bss_prio_lock,\r\nflags);\r\nis_list_empty = list_empty(&adapter->bss_prio_tbl[j]\r\n.bss_prio_head);\r\nspin_unlock_irqrestore(&adapter->bss_prio_tbl[j].bss_prio_lock,\r\nflags);\r\nif (is_list_empty)\r\ncontinue;\r\nif (adapter->bss_prio_tbl[j].bss_prio_cur ==\r\n(struct mwifiex_bss_prio_node *)\r\n&adapter->bss_prio_tbl[j].bss_prio_head) {\r\nbssprio_node =\r\nlist_first_entry(&adapter->bss_prio_tbl[j]\r\n.bss_prio_head,\r\nstruct mwifiex_bss_prio_node,\r\nlist);\r\nbssprio_head = bssprio_node;\r\n} else {\r\nbssprio_node = adapter->bss_prio_tbl[j].bss_prio_cur;\r\nbssprio_head = bssprio_node;\r\n}\r\ndo {\r\natomic_t *hqp;\r\nspinlock_t *lock;\r\npriv_tmp = bssprio_node->priv;\r\nhqp = &priv_tmp->wmm.highest_queued_prio;\r\nlock = &priv_tmp->wmm.ra_list_spinlock;\r\nfor (i = atomic_read(hqp); i >= LOW_PRIO_TID; --i) {\r\ntid_ptr = &(priv_tmp)->wmm.\r\ntid_tbl_ptr[tos_to_tid[i]];\r\nspin_lock_irqsave(&tid_ptr->tid_tbl_lock,\r\nflags);\r\nis_list_empty =\r\nlist_empty(&adapter->bss_prio_tbl[j]\r\n.bss_prio_head);\r\nspin_unlock_irqrestore(&tid_ptr->tid_tbl_lock,\r\nflags);\r\nif (is_list_empty)\r\ncontinue;\r\nptr = list_first_entry(\r\n&tid_ptr->ra_list_curr->list,\r\nstruct mwifiex_ra_list_tbl,\r\nlist);\r\nhead = ptr;\r\nif (ptr == (struct mwifiex_ra_list_tbl *)\r\n&tid_ptr->ra_list) {\r\nptr = list_first_entry(&ptr->list,\r\nstruct mwifiex_ra_list_tbl, list);\r\nhead = ptr;\r\n}\r\ndo {\r\nis_list_empty =\r\nskb_queue_empty(&ptr->skb_head);\r\nif (!is_list_empty) {\r\nspin_lock_irqsave(lock, flags);\r\nif (atomic_read(hqp) > i)\r\natomic_set(hqp, i);\r\nspin_unlock_irqrestore(lock,\r\nflags);\r\n*priv = priv_tmp;\r\n*tid = tos_to_tid[i];\r\nreturn ptr;\r\n}\r\nptr = list_first_entry(&ptr->list,\r\nstruct mwifiex_ra_list_tbl,\r\nlist);\r\nif (ptr ==\r\n(struct mwifiex_ra_list_tbl *)\r\n&tid_ptr->ra_list)\r\nptr = list_first_entry(\r\n&ptr->list,\r\nstruct mwifiex_ra_list_tbl,\r\nlist);\r\n} while (ptr != head);\r\n}\r\natomic_set(hqp, NO_PKT_PRIO_TID);\r\nbssprio_node = list_first_entry(&bssprio_node->list,\r\nstruct mwifiex_bss_prio_node,\r\nlist);\r\nif (bssprio_node ==\r\n(struct mwifiex_bss_prio_node *)\r\n&adapter->bss_prio_tbl[j].bss_prio_head)\r\nbssprio_node = list_first_entry(\r\n&bssprio_node->list,\r\nstruct mwifiex_bss_prio_node,\r\nlist);\r\n} while (bssprio_node != bssprio_head);\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nmwifiex_is_11n_aggragation_possible(struct mwifiex_private *priv,\r\nstruct mwifiex_ra_list_tbl *ptr,\r\nint max_buf_size)\r\n{\r\nint count = 0, total_size = 0;\r\nstruct sk_buff *skb, *tmp;\r\nskb_queue_walk_safe(&ptr->skb_head, skb, tmp) {\r\ntotal_size += skb->len;\r\nif (total_size >= max_buf_size)\r\nbreak;\r\nif (++count >= MIN_NUM_AMSDU)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void\r\nmwifiex_send_single_packet(struct mwifiex_private *priv,\r\nstruct mwifiex_ra_list_tbl *ptr, int ptr_index,\r\nunsigned long ra_list_flags)\r\n__releases(&priv->wmm.ra_list_spinlock\r\nstatic int\r\nmwifiex_is_ptr_processed(struct mwifiex_private *priv,\r\nstruct mwifiex_ra_list_tbl *ptr)\r\n{\r\nstruct sk_buff *skb;\r\nstruct mwifiex_txinfo *tx_info;\r\nif (skb_queue_empty(&ptr->skb_head))\r\nreturn false;\r\nskb = skb_peek(&ptr->skb_head);\r\ntx_info = MWIFIEX_SKB_TXCB(skb);\r\nif (tx_info->flags & MWIFIEX_BUF_FLAG_REQUEUED_PKT)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void\r\nmwifiex_send_processed_packet(struct mwifiex_private *priv,\r\nstruct mwifiex_ra_list_tbl *ptr, int ptr_index,\r\nunsigned long ra_list_flags)\r\n__releases(&priv->wmm.ra_list_spinlock\r\nstatic int\r\nmwifiex_dequeue_tx_packet(struct mwifiex_adapter *adapter)\r\n{\r\nstruct mwifiex_ra_list_tbl *ptr;\r\nstruct mwifiex_private *priv = NULL;\r\nint ptr_index = 0;\r\nu8 ra[ETH_ALEN];\r\nint tid_del = 0, tid = 0;\r\nunsigned long flags;\r\nptr = mwifiex_wmm_get_highest_priolist_ptr(adapter, &priv, &ptr_index);\r\nif (!ptr)\r\nreturn -1;\r\ntid = mwifiex_get_tid(ptr);\r\ndev_dbg(adapter->dev, "data: tid=%d\n", tid);\r\nspin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);\r\nif (!mwifiex_is_ralist_valid(priv, ptr, ptr_index)) {\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);\r\nreturn -1;\r\n}\r\nif (mwifiex_is_ptr_processed(priv, ptr)) {\r\nmwifiex_send_processed_packet(priv, ptr, ptr_index, flags);\r\nreturn 0;\r\n}\r\nif (!ptr->is_11n_enabled || mwifiex_is_ba_stream_setup(priv, ptr, tid)\r\n|| ((priv->sec_info.wpa_enabled\r\n|| priv->sec_info.wpa2_enabled) && !priv->wpa_is_gtk_set)\r\n) {\r\nmwifiex_send_single_packet(priv, ptr, ptr_index, flags);\r\n} else {\r\nif (mwifiex_is_ampdu_allowed(priv, tid)) {\r\nif (mwifiex_space_avail_for_new_ba_stream(adapter)) {\r\nmwifiex_11n_create_tx_ba_stream_tbl(priv,\r\nptr->ra, tid,\r\nBA_STREAM_SETUP_INPROGRESS);\r\nmwifiex_send_addba(priv, tid, ptr->ra);\r\n} else if (mwifiex_find_stream_to_delete\r\n(priv, tid, &tid_del, ra)) {\r\nmwifiex_11n_create_tx_ba_stream_tbl(priv,\r\nptr->ra, tid,\r\nBA_STREAM_SETUP_INPROGRESS);\r\nmwifiex_send_delba(priv, tid_del, ra, 1);\r\n}\r\n}\r\nif (mwifiex_is_amsdu_allowed(priv, tid) &&\r\nmwifiex_is_11n_aggragation_possible(priv, ptr,\r\nadapter->tx_buf_size))\r\nmwifiex_11n_aggregate_pkt(priv, ptr, INTF_HEADER_LEN,\r\nptr_index, flags);\r\nelse\r\nmwifiex_send_single_packet(priv, ptr, ptr_index, flags);\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nmwifiex_wmm_process_tx(struct mwifiex_adapter *adapter)\r\n{\r\ndo {\r\nif (adapter->data_sent || adapter->tx_lock_flag)\r\nbreak;\r\nif (mwifiex_dequeue_tx_packet(adapter))\r\nbreak;\r\n} while (!mwifiex_wmm_lists_empty(adapter));\r\n}
