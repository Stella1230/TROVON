u32 dw_readl(struct dw_i2c_dev *dev, int offset)\r\n{\r\nu32 value = readl(dev->base + offset);\r\nif (dev->swab)\r\nreturn swab32(value);\r\nelse\r\nreturn value;\r\n}\r\nvoid dw_writel(struct dw_i2c_dev *dev, u32 b, int offset)\r\n{\r\nif (dev->swab)\r\nb = swab32(b);\r\nwritel(b, dev->base + offset);\r\n}\r\nstatic u32\r\ni2c_dw_scl_hcnt(u32 ic_clk, u32 tSYMBOL, u32 tf, int cond, int offset)\r\n{\r\nif (cond)\r\nreturn (ic_clk * tSYMBOL + 5000) / 10000 - 8 + offset;\r\nelse\r\nreturn (ic_clk * (tSYMBOL + tf) + 5000) / 10000 - 3 + offset;\r\n}\r\nstatic u32 i2c_dw_scl_lcnt(u32 ic_clk, u32 tLOW, u32 tf, int offset)\r\n{\r\nreturn ((ic_clk * (tLOW + tf) + 5000) / 10000) - 1 + offset;\r\n}\r\nint i2c_dw_init(struct dw_i2c_dev *dev)\r\n{\r\nu32 input_clock_khz;\r\nu32 hcnt, lcnt;\r\nu32 reg;\r\ninput_clock_khz = dev->get_clk_rate_khz(dev);\r\nreg = dw_readl(dev, DW_IC_COMP_TYPE);\r\nif (reg == ___constant_swab32(DW_IC_COMP_TYPE_VALUE)) {\r\ndev->swab = 1;\r\nreg = DW_IC_COMP_TYPE_VALUE;\r\n}\r\nif (reg != DW_IC_COMP_TYPE_VALUE) {\r\ndev_err(dev->dev, "Unknown Synopsys component type: "\r\n"0x%08x\n", reg);\r\nreturn -ENODEV;\r\n}\r\ndw_writel(dev, 0, DW_IC_ENABLE);\r\nhcnt = i2c_dw_scl_hcnt(input_clock_khz,\r\n40,\r\n3,\r\n0,\r\n0);\r\nlcnt = i2c_dw_scl_lcnt(input_clock_khz,\r\n47,\r\n3,\r\n0);\r\ndw_writel(dev, hcnt, DW_IC_SS_SCL_HCNT);\r\ndw_writel(dev, lcnt, DW_IC_SS_SCL_LCNT);\r\ndev_dbg(dev->dev, "Standard-mode HCNT:LCNT = %d:%d\n", hcnt, lcnt);\r\nhcnt = i2c_dw_scl_hcnt(input_clock_khz,\r\n6,\r\n3,\r\n0,\r\n0);\r\nlcnt = i2c_dw_scl_lcnt(input_clock_khz,\r\n13,\r\n3,\r\n0);\r\ndw_writel(dev, hcnt, DW_IC_FS_SCL_HCNT);\r\ndw_writel(dev, lcnt, DW_IC_FS_SCL_LCNT);\r\ndev_dbg(dev->dev, "Fast-mode HCNT:LCNT = %d:%d\n", hcnt, lcnt);\r\ndw_writel(dev, dev->tx_fifo_depth - 1, DW_IC_TX_TL);\r\ndw_writel(dev, 0, DW_IC_RX_TL);\r\ndw_writel(dev, dev->master_cfg , DW_IC_CON);\r\nreturn 0;\r\n}\r\nstatic int i2c_dw_wait_bus_not_busy(struct dw_i2c_dev *dev)\r\n{\r\nint timeout = TIMEOUT;\r\nwhile (dw_readl(dev, DW_IC_STATUS) & DW_IC_STATUS_ACTIVITY) {\r\nif (timeout <= 0) {\r\ndev_warn(dev->dev, "timeout waiting for bus ready\n");\r\nreturn -ETIMEDOUT;\r\n}\r\ntimeout--;\r\nmdelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void i2c_dw_xfer_init(struct dw_i2c_dev *dev)\r\n{\r\nstruct i2c_msg *msgs = dev->msgs;\r\nu32 ic_con;\r\ndw_writel(dev, 0, DW_IC_ENABLE);\r\ndw_writel(dev, msgs[dev->msg_write_idx].addr, DW_IC_TAR);\r\nic_con = dw_readl(dev, DW_IC_CON);\r\nif (msgs[dev->msg_write_idx].flags & I2C_M_TEN)\r\nic_con |= DW_IC_CON_10BITADDR_MASTER;\r\nelse\r\nic_con &= ~DW_IC_CON_10BITADDR_MASTER;\r\ndw_writel(dev, ic_con, DW_IC_CON);\r\ndw_writel(dev, 1, DW_IC_ENABLE);\r\ndw_writel(dev, DW_IC_INTR_DEFAULT_MASK, DW_IC_INTR_MASK);\r\n}\r\nvoid\r\ni2c_dw_xfer_msg(struct dw_i2c_dev *dev)\r\n{\r\nstruct i2c_msg *msgs = dev->msgs;\r\nu32 intr_mask;\r\nint tx_limit, rx_limit;\r\nu32 addr = msgs[dev->msg_write_idx].addr;\r\nu32 buf_len = dev->tx_buf_len;\r\nu8 *buf = dev->tx_buf;\r\nintr_mask = DW_IC_INTR_DEFAULT_MASK;\r\nfor (; dev->msg_write_idx < dev->msgs_num; dev->msg_write_idx++) {\r\nif (msgs[dev->msg_write_idx].addr != addr) {\r\ndev_err(dev->dev,\r\n"%s: invalid target address\n", __func__);\r\ndev->msg_err = -EINVAL;\r\nbreak;\r\n}\r\nif (msgs[dev->msg_write_idx].len == 0) {\r\ndev_err(dev->dev,\r\n"%s: invalid message length\n", __func__);\r\ndev->msg_err = -EINVAL;\r\nbreak;\r\n}\r\nif (!(dev->status & STATUS_WRITE_IN_PROGRESS)) {\r\nbuf = msgs[dev->msg_write_idx].buf;\r\nbuf_len = msgs[dev->msg_write_idx].len;\r\n}\r\ntx_limit = dev->tx_fifo_depth - dw_readl(dev, DW_IC_TXFLR);\r\nrx_limit = dev->rx_fifo_depth - dw_readl(dev, DW_IC_RXFLR);\r\nwhile (buf_len > 0 && tx_limit > 0 && rx_limit > 0) {\r\nif (msgs[dev->msg_write_idx].flags & I2C_M_RD) {\r\ndw_writel(dev, 0x100, DW_IC_DATA_CMD);\r\nrx_limit--;\r\n} else\r\ndw_writel(dev, *buf++, DW_IC_DATA_CMD);\r\ntx_limit--; buf_len--;\r\n}\r\ndev->tx_buf = buf;\r\ndev->tx_buf_len = buf_len;\r\nif (buf_len > 0) {\r\ndev->status |= STATUS_WRITE_IN_PROGRESS;\r\nbreak;\r\n} else\r\ndev->status &= ~STATUS_WRITE_IN_PROGRESS;\r\n}\r\nif (dev->msg_write_idx == dev->msgs_num)\r\nintr_mask &= ~DW_IC_INTR_TX_EMPTY;\r\nif (dev->msg_err)\r\nintr_mask = 0;\r\ndw_writel(dev, intr_mask, DW_IC_INTR_MASK);\r\n}\r\nstatic void\r\ni2c_dw_read(struct dw_i2c_dev *dev)\r\n{\r\nstruct i2c_msg *msgs = dev->msgs;\r\nint rx_valid;\r\nfor (; dev->msg_read_idx < dev->msgs_num; dev->msg_read_idx++) {\r\nu32 len;\r\nu8 *buf;\r\nif (!(msgs[dev->msg_read_idx].flags & I2C_M_RD))\r\ncontinue;\r\nif (!(dev->status & STATUS_READ_IN_PROGRESS)) {\r\nlen = msgs[dev->msg_read_idx].len;\r\nbuf = msgs[dev->msg_read_idx].buf;\r\n} else {\r\nlen = dev->rx_buf_len;\r\nbuf = dev->rx_buf;\r\n}\r\nrx_valid = dw_readl(dev, DW_IC_RXFLR);\r\nfor (; len > 0 && rx_valid > 0; len--, rx_valid--)\r\n*buf++ = dw_readl(dev, DW_IC_DATA_CMD);\r\nif (len > 0) {\r\ndev->status |= STATUS_READ_IN_PROGRESS;\r\ndev->rx_buf_len = len;\r\ndev->rx_buf = buf;\r\nreturn;\r\n} else\r\ndev->status &= ~STATUS_READ_IN_PROGRESS;\r\n}\r\n}\r\nstatic int i2c_dw_handle_tx_abort(struct dw_i2c_dev *dev)\r\n{\r\nunsigned long abort_source = dev->abort_source;\r\nint i;\r\nif (abort_source & DW_IC_TX_ABRT_NOACK) {\r\nfor_each_set_bit(i, &abort_source, ARRAY_SIZE(abort_sources))\r\ndev_dbg(dev->dev,\r\n"%s: %s\n", __func__, abort_sources[i]);\r\nreturn -EREMOTEIO;\r\n}\r\nfor_each_set_bit(i, &abort_source, ARRAY_SIZE(abort_sources))\r\ndev_err(dev->dev, "%s: %s\n", __func__, abort_sources[i]);\r\nif (abort_source & DW_IC_TX_ARB_LOST)\r\nreturn -EAGAIN;\r\nelse if (abort_source & DW_IC_TX_ABRT_GCALL_READ)\r\nreturn -EINVAL;\r\nelse\r\nreturn -EIO;\r\n}\r\nint\r\ni2c_dw_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\r\n{\r\nstruct dw_i2c_dev *dev = i2c_get_adapdata(adap);\r\nint ret;\r\ndev_dbg(dev->dev, "%s: msgs: %d\n", __func__, num);\r\nmutex_lock(&dev->lock);\r\npm_runtime_get_sync(dev->dev);\r\nINIT_COMPLETION(dev->cmd_complete);\r\ndev->msgs = msgs;\r\ndev->msgs_num = num;\r\ndev->cmd_err = 0;\r\ndev->msg_write_idx = 0;\r\ndev->msg_read_idx = 0;\r\ndev->msg_err = 0;\r\ndev->status = STATUS_IDLE;\r\ndev->abort_source = 0;\r\nret = i2c_dw_wait_bus_not_busy(dev);\r\nif (ret < 0)\r\ngoto done;\r\ni2c_dw_xfer_init(dev);\r\nret = wait_for_completion_interruptible_timeout(&dev->cmd_complete, HZ);\r\nif (ret == 0) {\r\ndev_err(dev->dev, "controller timed out\n");\r\ni2c_dw_init(dev);\r\nret = -ETIMEDOUT;\r\ngoto done;\r\n} else if (ret < 0)\r\ngoto done;\r\nif (dev->msg_err) {\r\nret = dev->msg_err;\r\ngoto done;\r\n}\r\nif (likely(!dev->cmd_err)) {\r\ndw_writel(dev, 0, DW_IC_ENABLE);\r\nret = num;\r\ngoto done;\r\n}\r\nif (dev->cmd_err == DW_IC_ERR_TX_ABRT) {\r\nret = i2c_dw_handle_tx_abort(dev);\r\ngoto done;\r\n}\r\nret = -EIO;\r\ndone:\r\npm_runtime_put(dev->dev);\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nu32 i2c_dw_func(struct i2c_adapter *adap)\r\n{\r\nstruct dw_i2c_dev *dev = i2c_get_adapdata(adap);\r\nreturn dev->functionality;\r\n}\r\nstatic u32 i2c_dw_read_clear_intrbits(struct dw_i2c_dev *dev)\r\n{\r\nu32 stat;\r\nstat = dw_readl(dev, DW_IC_INTR_STAT);\r\nif (stat & DW_IC_INTR_RX_UNDER)\r\ndw_readl(dev, DW_IC_CLR_RX_UNDER);\r\nif (stat & DW_IC_INTR_RX_OVER)\r\ndw_readl(dev, DW_IC_CLR_RX_OVER);\r\nif (stat & DW_IC_INTR_TX_OVER)\r\ndw_readl(dev, DW_IC_CLR_TX_OVER);\r\nif (stat & DW_IC_INTR_RD_REQ)\r\ndw_readl(dev, DW_IC_CLR_RD_REQ);\r\nif (stat & DW_IC_INTR_TX_ABRT) {\r\ndev->abort_source = dw_readl(dev, DW_IC_TX_ABRT_SOURCE);\r\ndw_readl(dev, DW_IC_CLR_TX_ABRT);\r\n}\r\nif (stat & DW_IC_INTR_RX_DONE)\r\ndw_readl(dev, DW_IC_CLR_RX_DONE);\r\nif (stat & DW_IC_INTR_ACTIVITY)\r\ndw_readl(dev, DW_IC_CLR_ACTIVITY);\r\nif (stat & DW_IC_INTR_STOP_DET)\r\ndw_readl(dev, DW_IC_CLR_STOP_DET);\r\nif (stat & DW_IC_INTR_START_DET)\r\ndw_readl(dev, DW_IC_CLR_START_DET);\r\nif (stat & DW_IC_INTR_GEN_CALL)\r\ndw_readl(dev, DW_IC_CLR_GEN_CALL);\r\nreturn stat;\r\n}\r\nirqreturn_t i2c_dw_isr(int this_irq, void *dev_id)\r\n{\r\nstruct dw_i2c_dev *dev = dev_id;\r\nu32 stat, enabled;\r\nenabled = dw_readl(dev, DW_IC_ENABLE);\r\nstat = dw_readl(dev, DW_IC_RAW_INTR_STAT);\r\ndev_dbg(dev->dev, "%s: %s enabled= 0x%x stat=0x%x\n", __func__,\r\ndev->adapter.name, enabled, stat);\r\nif (!enabled || !(stat & ~DW_IC_INTR_ACTIVITY))\r\nreturn IRQ_NONE;\r\nstat = i2c_dw_read_clear_intrbits(dev);\r\nif (stat & DW_IC_INTR_TX_ABRT) {\r\ndev->cmd_err |= DW_IC_ERR_TX_ABRT;\r\ndev->status = STATUS_IDLE;\r\ndw_writel(dev, 0, DW_IC_INTR_MASK);\r\ngoto tx_aborted;\r\n}\r\nif (stat & DW_IC_INTR_RX_FULL)\r\ni2c_dw_read(dev);\r\nif (stat & DW_IC_INTR_TX_EMPTY)\r\ni2c_dw_xfer_msg(dev);\r\ntx_aborted:\r\nif ((stat & (DW_IC_INTR_TX_ABRT | DW_IC_INTR_STOP_DET)) || dev->msg_err)\r\ncomplete(&dev->cmd_complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid i2c_dw_enable(struct dw_i2c_dev *dev)\r\n{\r\ndw_writel(dev, 1, DW_IC_ENABLE);\r\n}\r\nu32 i2c_dw_is_enabled(struct dw_i2c_dev *dev)\r\n{\r\nreturn dw_readl(dev, DW_IC_ENABLE);\r\n}\r\nvoid i2c_dw_disable(struct dw_i2c_dev *dev)\r\n{\r\ndw_writel(dev, 0, DW_IC_ENABLE);\r\ndw_writel(dev, 0, DW_IC_INTR_MASK);\r\ndw_readl(dev, DW_IC_CLR_INTR);\r\n}\r\nvoid i2c_dw_clear_int(struct dw_i2c_dev *dev)\r\n{\r\ndw_readl(dev, DW_IC_CLR_INTR);\r\n}\r\nvoid i2c_dw_disable_int(struct dw_i2c_dev *dev)\r\n{\r\ndw_writel(dev, 0, DW_IC_INTR_MASK);\r\n}\r\nu32 i2c_dw_read_comp_param(struct dw_i2c_dev *dev)\r\n{\r\nreturn dw_readl(dev, DW_IC_COMP_PARAM_1);\r\n}
