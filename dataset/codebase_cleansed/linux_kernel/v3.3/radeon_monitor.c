static char *radeon_get_mon_name(int type)\r\n{\r\nchar *pret = NULL;\r\nswitch (type) {\r\ncase MT_NONE:\r\npret = "no";\r\nbreak;\r\ncase MT_CRT:\r\npret = "CRT";\r\nbreak;\r\ncase MT_DFP:\r\npret = "DFP";\r\nbreak;\r\ncase MT_LCD:\r\npret = "LCD";\r\nbreak;\r\ncase MT_CTV:\r\npret = "CTV";\r\nbreak;\r\ncase MT_STV:\r\npret = "STV";\r\nbreak;\r\n}\r\nreturn pret;\r\n}\r\nstatic int __devinit radeon_parse_montype_prop(struct device_node *dp, u8 **out_EDID,\r\nint hdno)\r\n{\r\nstatic char *propnames[] = { "DFP,EDID", "LCD,EDID", "EDID",\r\n"EDID1", "EDID2", NULL };\r\nconst u8 *pedid = NULL;\r\nconst u8 *pmt = NULL;\r\nu8 *tmp;\r\nint i, mt = MT_NONE;\r\npr_debug("analyzing OF properties...\n");\r\npmt = of_get_property(dp, "display-type", NULL);\r\nif (!pmt)\r\nreturn MT_NONE;\r\npr_debug("display-type: %s\n", pmt);\r\nif (!strcmp(pmt, "LCD") || !strcmp(pmt, "DFP"))\r\nmt = MT_DFP;\r\nelse if (!strcmp(pmt, "CRT"))\r\nmt = MT_CRT;\r\nelse {\r\nif (strcmp(pmt, "NONE") != 0)\r\nprintk(KERN_WARNING "radeonfb: Unknown OF display-type: %s\n",\r\npmt);\r\nreturn MT_NONE;\r\n}\r\nfor (i = 0; propnames[i] != NULL; ++i) {\r\npedid = of_get_property(dp, propnames[i], NULL);\r\nif (pedid != NULL)\r\nbreak;\r\n}\r\nif (pedid == NULL && dp->parent && (hdno != -1))\r\npedid = of_get_property(dp->parent,\r\n(hdno == 0) ? "EDID1" : "EDID2", NULL);\r\nif (pedid == NULL && dp->parent && (hdno == 0))\r\npedid = of_get_property(dp->parent, "EDID", NULL);\r\nif (pedid == NULL)\r\nreturn mt;\r\ntmp = kmemdup(pedid, EDID_LENGTH, GFP_KERNEL);\r\nif (!tmp)\r\nreturn mt;\r\n*out_EDID = tmp;\r\nreturn mt;\r\n}\r\nstatic int __devinit radeon_probe_OF_head(struct radeonfb_info *rinfo, int head_no,\r\nu8 **out_EDID)\r\n{\r\nstruct device_node *dp;\r\npr_debug("radeon_probe_OF_head\n");\r\ndp = rinfo->of_node;\r\nwhile (dp == NULL)\r\nreturn MT_NONE;\r\nif (rinfo->has_CRTC2) {\r\nconst char *pname;\r\nint len, second = 0;\r\ndp = dp->child;\r\ndo {\r\nif (!dp)\r\nreturn MT_NONE;\r\npname = of_get_property(dp, "name", NULL);\r\nif (!pname)\r\nreturn MT_NONE;\r\nlen = strlen(pname);\r\npr_debug("head: %s (letter: %c, head_no: %d)\n",\r\npname, pname[len-1], head_no);\r\nif (pname[len-1] == 'A' && head_no == 0) {\r\nint mt = radeon_parse_montype_prop(dp, out_EDID, 0);\r\nif (mt == MT_DFP && rinfo->is_mobility)\r\nmt = MT_LCD;\r\nreturn mt;\r\n} else if (pname[len-1] == 'B' && head_no == 1)\r\nreturn radeon_parse_montype_prop(dp, out_EDID, 1);\r\nsecond = 1;\r\ndp = dp->sibling;\r\n} while(!second);\r\n} else {\r\nif (head_no > 0)\r\nreturn MT_NONE;\r\nreturn radeon_parse_montype_prop(dp, out_EDID, -1);\r\n}\r\nreturn MT_NONE;\r\n}\r\nstatic int __devinit radeon_get_panel_info_BIOS(struct radeonfb_info *rinfo)\r\n{\r\nunsigned long tmp, tmp0;\r\nchar stmp[30];\r\nint i;\r\nif (!rinfo->bios_seg)\r\nreturn 0;\r\nif (!(tmp = BIOS_IN16(rinfo->fp_bios_start + 0x40))) {\r\nprintk(KERN_ERR "radeonfb: Failed to detect DFP panel info using BIOS\n");\r\nrinfo->panel_info.pwr_delay = 200;\r\nreturn 0;\r\n}\r\nfor(i=0; i<24; i++)\r\nstmp[i] = BIOS_IN8(tmp+i+1);\r\nstmp[24] = 0;\r\nprintk("radeonfb: panel ID string: %s\n", stmp);\r\nrinfo->panel_info.xres = BIOS_IN16(tmp + 25);\r\nrinfo->panel_info.yres = BIOS_IN16(tmp + 27);\r\nprintk("radeonfb: detected LVDS panel size from BIOS: %dx%d\n",\r\nrinfo->panel_info.xres, rinfo->panel_info.yres);\r\nrinfo->panel_info.pwr_delay = BIOS_IN16(tmp + 44);\r\npr_debug("BIOS provided panel power delay: %d\n", rinfo->panel_info.pwr_delay);\r\nif (rinfo->panel_info.pwr_delay > 2000 || rinfo->panel_info.pwr_delay <= 0)\r\nrinfo->panel_info.pwr_delay = 2000;\r\nrinfo->panel_info.ref_divider = BIOS_IN16(tmp + 46);\r\nrinfo->panel_info.post_divider = BIOS_IN8(tmp + 48);\r\nrinfo->panel_info.fbk_divider = BIOS_IN16(tmp + 49);\r\nif (rinfo->panel_info.ref_divider != 0 &&\r\nrinfo->panel_info.fbk_divider > 3) {\r\nrinfo->panel_info.use_bios_dividers = 1;\r\nprintk(KERN_INFO "radeondb: BIOS provided dividers will be used\n");\r\npr_debug("ref_divider = %x\n", rinfo->panel_info.ref_divider);\r\npr_debug("post_divider = %x\n", rinfo->panel_info.post_divider);\r\npr_debug("fbk_divider = %x\n", rinfo->panel_info.fbk_divider);\r\n}\r\npr_debug("Scanning BIOS table ...\n");\r\nfor(i=0; i<32; i++) {\r\ntmp0 = BIOS_IN16(tmp+64+i*2);\r\nif (tmp0 == 0)\r\nbreak;\r\npr_debug(" %d x %d\n", BIOS_IN16(tmp0), BIOS_IN16(tmp0+2));\r\nif ((BIOS_IN16(tmp0) == rinfo->panel_info.xres) &&\r\n(BIOS_IN16(tmp0+2) == rinfo->panel_info.yres)) {\r\nrinfo->panel_info.hblank = (BIOS_IN16(tmp0+17) - BIOS_IN16(tmp0+19)) * 8;\r\nrinfo->panel_info.hOver_plus = ((BIOS_IN16(tmp0+21) -\r\nBIOS_IN16(tmp0+19) -1) * 8) & 0x7fff;\r\nrinfo->panel_info.hSync_width = BIOS_IN8(tmp0+23) * 8;\r\nrinfo->panel_info.vblank = BIOS_IN16(tmp0+24) - BIOS_IN16(tmp0+26);\r\nrinfo->panel_info.vOver_plus = (BIOS_IN16(tmp0+28) & 0x7ff) - BIOS_IN16(tmp0+26);\r\nrinfo->panel_info.vSync_width = (BIOS_IN16(tmp0+28) & 0xf800) >> 11;\r\nrinfo->panel_info.clock = BIOS_IN16(tmp0+9);\r\nrinfo->panel_info.hAct_high = 1;\r\nrinfo->panel_info.vAct_high = 1;\r\nrinfo->panel_info.valid = 1;\r\npr_debug("Found panel in BIOS table:\n");\r\npr_debug(" hblank: %d\n", rinfo->panel_info.hblank);\r\npr_debug(" hOver_plus: %d\n", rinfo->panel_info.hOver_plus);\r\npr_debug(" hSync_width: %d\n", rinfo->panel_info.hSync_width);\r\npr_debug(" vblank: %d\n", rinfo->panel_info.vblank);\r\npr_debug(" vOver_plus: %d\n", rinfo->panel_info.vOver_plus);\r\npr_debug(" vSync_width: %d\n", rinfo->panel_info.vSync_width);\r\npr_debug(" clock: %d\n", rinfo->panel_info.clock);\r\nreturn 1;\r\n}\r\n}\r\npr_debug("Didn't find panel in BIOS table !\n");\r\nreturn 0;\r\n}\r\nstatic void __devinit radeon_parse_connector_info(struct radeonfb_info *rinfo)\r\n{\r\nint offset, chips, connectors, tmp, i, conn, type;\r\nstatic char* __conn_type_table[16] = {\r\n"NONE", "Proprietary", "CRT", "DVI-I", "DVI-D", "Unknown", "Unknown",\r\n"Unknown", "Unknown", "Unknown", "Unknown", "Unknown", "Unknown",\r\n"Unknown", "Unknown", "Unknown"\r\n};\r\nif (!rinfo->bios_seg)\r\nreturn;\r\noffset = BIOS_IN16(rinfo->fp_bios_start + 0x50);\r\nif (offset == 0) {\r\nprintk(KERN_WARNING "radeonfb: No connector info table detected\n");\r\nreturn;\r\n}\r\nchips = BIOS_IN8(offset++) >> 4;\r\npr_debug("%d chips in connector info\n", chips);\r\nfor (i = 0; i < chips; i++) {\r\ntmp = BIOS_IN8(offset++);\r\nconnectors = tmp & 0x0f;\r\npr_debug(" - chip %d has %d connectors\n", tmp >> 4, connectors);\r\nfor (conn = 0; ; conn++) {\r\ntmp = BIOS_IN16(offset);\r\nif (tmp == 0)\r\nbreak;\r\noffset += 2;\r\ntype = (tmp >> 12) & 0x0f;\r\npr_debug(" * connector %d of type %d (%s) : %04x\n",\r\nconn, type, __conn_type_table[type], tmp);\r\n}\r\n}\r\n}\r\nstatic int __devinit radeon_crt_is_connected(struct radeonfb_info *rinfo, int is_crt_dac)\r\n{\r\nint connected = 0;\r\nif (is_crt_dac) {\r\nunsigned long ulOrigVCLK_ECP_CNTL;\r\nunsigned long ulOrigDAC_CNTL;\r\nunsigned long ulOrigDAC_EXT_CNTL;\r\nunsigned long ulOrigCRTC_EXT_CNTL;\r\nunsigned long ulData;\r\nunsigned long ulMask;\r\nulOrigVCLK_ECP_CNTL = INPLL(VCLK_ECP_CNTL);\r\nulData = ulOrigVCLK_ECP_CNTL;\r\nulData &= ~(PIXCLK_ALWAYS_ONb\r\n| PIXCLK_DAC_ALWAYS_ONb);\r\nulMask = ~(PIXCLK_ALWAYS_ONb\r\n| PIXCLK_DAC_ALWAYS_ONb);\r\nOUTPLLP(VCLK_ECP_CNTL, ulData, ulMask);\r\nulOrigCRTC_EXT_CNTL = INREG(CRTC_EXT_CNTL);\r\nulData = ulOrigCRTC_EXT_CNTL;\r\nulData |= CRTC_CRT_ON;\r\nOUTREG(CRTC_EXT_CNTL, ulData);\r\nulOrigDAC_EXT_CNTL = INREG(DAC_EXT_CNTL);\r\nulData = ulOrigDAC_EXT_CNTL;\r\nulData &= ~DAC_FORCE_DATA_MASK;\r\nulData |= (DAC_FORCE_BLANK_OFF_EN\r\n|DAC_FORCE_DATA_EN\r\n|DAC_FORCE_DATA_SEL_MASK);\r\nif ((rinfo->family == CHIP_FAMILY_RV250) ||\r\n(rinfo->family == CHIP_FAMILY_RV280))\r\nulData |= (0x01b6 << DAC_FORCE_DATA_SHIFT);\r\nelse\r\nulData |= (0x01ac << DAC_FORCE_DATA_SHIFT);\r\nOUTREG(DAC_EXT_CNTL, ulData);\r\nulOrigDAC_CNTL = INREG(DAC_CNTL);\r\nulData = ulOrigDAC_CNTL;\r\nulData |= DAC_CMP_EN;\r\nulData &= ~(DAC_RANGE_CNTL_MASK\r\n| DAC_PDWN);\r\nulData |= 0x2;\r\nOUTREG(DAC_CNTL, ulData);\r\nmdelay(1);\r\nulData = INREG(DAC_CNTL);\r\nconnected = (DAC_CMP_OUTPUT & ulData) ? 1 : 0;\r\nulData = ulOrigVCLK_ECP_CNTL;\r\nulMask = 0xFFFFFFFFL;\r\nOUTPLLP(VCLK_ECP_CNTL, ulData, ulMask);\r\nOUTREG(DAC_CNTL, ulOrigDAC_CNTL );\r\nOUTREG(DAC_EXT_CNTL, ulOrigDAC_EXT_CNTL );\r\nOUTREG(CRTC_EXT_CNTL, ulOrigCRTC_EXT_CNTL);\r\n}\r\nreturn connected ? MT_CRT : MT_NONE;\r\n}\r\nstatic int __devinit radeon_parse_monitor_layout(struct radeonfb_info *rinfo,\r\nconst char *monitor_layout)\r\n{\r\nchar s1[5], s2[5];\r\nint i = 0, second = 0;\r\nconst char *s;\r\nif (!monitor_layout)\r\nreturn 0;\r\ns = monitor_layout;\r\ndo {\r\nswitch(*s) {\r\ncase ',':\r\ns1[i] = '\0';\r\ni = 0;\r\nsecond = 1;\r\nbreak;\r\ncase ' ':\r\ncase '\0':\r\nbreak;\r\ndefault:\r\nif (i > 4)\r\nbreak;\r\nif (second)\r\ns2[i] = *s;\r\nelse\r\ns1[i] = *s;\r\ni++;\r\n}\r\nif (i > 4)\r\ni = 4;\r\n} while (*s++);\r\nif (second)\r\ns2[i] = 0;\r\nelse {\r\ns1[i] = 0;\r\ns2[0] = 0;\r\n}\r\nif (strcmp(s1, "CRT") == 0)\r\nrinfo->mon1_type = MT_CRT;\r\nelse if (strcmp(s1, "TMDS") == 0)\r\nrinfo->mon1_type = MT_DFP;\r\nelse if (strcmp(s1, "LVDS") == 0)\r\nrinfo->mon1_type = MT_LCD;\r\nif (strcmp(s2, "CRT") == 0)\r\nrinfo->mon2_type = MT_CRT;\r\nelse if (strcmp(s2, "TMDS") == 0)\r\nrinfo->mon2_type = MT_DFP;\r\nelse if (strcmp(s2, "LVDS") == 0)\r\nrinfo->mon2_type = MT_LCD;\r\nreturn 1;\r\n}\r\nvoid __devinit radeon_probe_screens(struct radeonfb_info *rinfo,\r\nconst char *monitor_layout, int ignore_edid)\r\n{\r\n#ifdef CONFIG_FB_RADEON_I2C\r\nint ddc_crt2_used = 0;\r\n#endif\r\nint tmp, i;\r\nradeon_parse_connector_info(rinfo);\r\nif (radeon_parse_monitor_layout(rinfo, monitor_layout)) {\r\npr_debug("Using specified monitor layout: %s", monitor_layout);\r\n#ifdef CONFIG_FB_RADEON_I2C\r\nif (!ignore_edid) {\r\nif (rinfo->mon1_type != MT_NONE)\r\nif (!radeon_probe_i2c_connector(rinfo, ddc_dvi, &rinfo->mon1_EDID)) {\r\nradeon_probe_i2c_connector(rinfo, ddc_crt2, &rinfo->mon1_EDID);\r\nddc_crt2_used = 1;\r\n}\r\nif (rinfo->mon2_type != MT_NONE)\r\nif (!radeon_probe_i2c_connector(rinfo, ddc_vga, &rinfo->mon2_EDID) &&\r\n!ddc_crt2_used)\r\nradeon_probe_i2c_connector(rinfo, ddc_crt2, &rinfo->mon2_EDID);\r\n}\r\n#endif\r\nif (rinfo->mon1_type == MT_NONE) {\r\nif (rinfo->mon2_type != MT_NONE) {\r\nrinfo->mon1_type = rinfo->mon2_type;\r\nrinfo->mon1_EDID = rinfo->mon2_EDID;\r\n} else {\r\nrinfo->mon1_type = MT_CRT;\r\nprintk(KERN_INFO "radeonfb: No valid monitor, assuming CRT on first port\n");\r\n}\r\nrinfo->mon2_type = MT_NONE;\r\nrinfo->mon2_EDID = NULL;\r\n}\r\n} else {\r\npr_debug("Starting monitor auto detection...\n");\r\n#if defined(DEBUG) && defined(CONFIG_FB_RADEON_I2C)\r\n{\r\nu8 *EDIDs[4] = { NULL, NULL, NULL, NULL };\r\nint mon_types[4] = {MT_NONE, MT_NONE, MT_NONE, MT_NONE};\r\nint i;\r\nfor (i = 0; i < 4; i++)\r\nmon_types[i] = radeon_probe_i2c_connector(rinfo,\r\ni+1, &EDIDs[i]);\r\n}\r\n#endif\r\nif (!rinfo->has_CRTC2) {\r\n#if defined(CONFIG_PPC_OF) || defined(CONFIG_SPARC)\r\nif (rinfo->mon1_type == MT_NONE)\r\nrinfo->mon1_type = radeon_probe_OF_head(rinfo, 0,\r\n&rinfo->mon1_EDID);\r\n#endif\r\n#ifdef CONFIG_FB_RADEON_I2C\r\nif (rinfo->mon1_type == MT_NONE)\r\nrinfo->mon1_type =\r\nradeon_probe_i2c_connector(rinfo, ddc_dvi,\r\n&rinfo->mon1_EDID);\r\nif (rinfo->mon1_type == MT_NONE)\r\nrinfo->mon1_type =\r\nradeon_probe_i2c_connector(rinfo, ddc_vga,\r\n&rinfo->mon1_EDID);\r\nif (rinfo->mon1_type == MT_NONE)\r\nrinfo->mon1_type =\r\nradeon_probe_i2c_connector(rinfo, ddc_crt2,\r\n&rinfo->mon1_EDID);\r\n#endif\r\nif (rinfo->mon1_type == MT_NONE)\r\nrinfo->mon1_type = MT_CRT;\r\ngoto bail;\r\n}\r\nif (rinfo->bios_seg &&\r\n(tmp = BIOS_IN16(rinfo->fp_bios_start + 0x50))) {\r\nfor (i = 1; i < 4; i++) {\r\nunsigned int tmp0;\r\nif (!BIOS_IN8(tmp + i*2) && i > 1)\r\nbreak;\r\ntmp0 = BIOS_IN16(tmp + i*2);\r\nif ((!(tmp0 & 0x01)) && (((tmp0 >> 8) & 0x0f) == ddc_dvi)) {\r\nrinfo->reversed_DAC = 1;\r\nprintk(KERN_INFO "radeonfb: Reversed DACs detected\n");\r\n}\r\nif ((((tmp0 >> 8) & 0x0f) == ddc_dvi) && ((tmp0 >> 4) & 0x01)) {\r\nrinfo->reversed_TMDS = 1;\r\nprintk(KERN_INFO "radeonfb: Reversed TMDS detected\n");\r\n}\r\n}\r\n}\r\n#if defined(CONFIG_PPC_OF) || defined(CONFIG_SPARC)\r\nif (rinfo->mon1_type == MT_NONE)\r\nrinfo->mon1_type = radeon_probe_OF_head(rinfo, 0,\r\n&rinfo->mon1_EDID);\r\n#endif\r\n#ifdef CONFIG_FB_RADEON_I2C\r\nif (rinfo->mon1_type == MT_NONE)\r\nrinfo->mon1_type = radeon_probe_i2c_connector(rinfo, ddc_dvi,\r\n&rinfo->mon1_EDID);\r\nif (rinfo->mon1_type == MT_NONE) {\r\nrinfo->mon1_type = radeon_probe_i2c_connector(rinfo, ddc_crt2,\r\n&rinfo->mon1_EDID);\r\nif (rinfo->mon1_type != MT_NONE)\r\nddc_crt2_used = 1;\r\n}\r\n#endif\r\nif (rinfo->mon1_type == MT_NONE && rinfo->is_mobility &&\r\n((rinfo->bios_seg && (INREG(BIOS_4_SCRATCH) & 4))\r\n|| (INREG(LVDS_GEN_CNTL) & LVDS_ON))) {\r\nrinfo->mon1_type = MT_LCD;\r\nprintk("Non-DDC laptop panel detected\n");\r\n}\r\nif (rinfo->mon1_type == MT_NONE)\r\nrinfo->mon1_type = radeon_crt_is_connected(rinfo, rinfo->reversed_DAC);\r\n#if defined(CONFIG_PPC_OF) || defined(CONFIG_SPARC)\r\nif (rinfo->mon2_type == MT_NONE)\r\nrinfo->mon2_type = radeon_probe_OF_head(rinfo, 1,\r\n&rinfo->mon2_EDID);\r\n#endif\r\n#ifdef CONFIG_FB_RADEON_I2C\r\nif (rinfo->mon2_type == MT_NONE)\r\nrinfo->mon2_type = radeon_probe_i2c_connector(rinfo, ddc_vga,\r\n&rinfo->mon2_EDID);\r\nif (rinfo->mon2_type == MT_NONE && !ddc_crt2_used)\r\nrinfo->mon2_type = radeon_probe_i2c_connector(rinfo, ddc_crt2,\r\n&rinfo->mon2_EDID);\r\n#endif\r\nif (rinfo->mon2_type == MT_NONE)\r\nrinfo->mon2_type = radeon_crt_is_connected(rinfo, !rinfo->reversed_DAC);\r\nif (rinfo->mon1_type == MT_NONE) {\r\nif (rinfo->mon2_type != MT_NONE) {\r\nrinfo->mon1_type = rinfo->mon2_type;\r\nrinfo->mon1_EDID = rinfo->mon2_EDID;\r\n} else\r\nrinfo->mon1_type = MT_CRT;\r\nrinfo->mon2_type = MT_NONE;\r\nrinfo->mon2_EDID = NULL;\r\n}\r\nif (rinfo->reversed_TMDS) {\r\nif (rinfo->mon1_type == MT_DFP || rinfo->mon2_type == MT_DFP) {\r\nint tmp_type = rinfo->mon1_type;\r\nu8 *tmp_EDID = rinfo->mon1_EDID;\r\nrinfo->mon1_type = rinfo->mon2_type;\r\nrinfo->mon1_EDID = rinfo->mon2_EDID;\r\nrinfo->mon2_type = tmp_type;\r\nrinfo->mon2_EDID = tmp_EDID;\r\nif (rinfo->mon1_type == MT_CRT || rinfo->mon2_type == MT_CRT)\r\nrinfo->reversed_DAC ^= 1;\r\n}\r\n}\r\n}\r\nif (ignore_edid) {\r\nkfree(rinfo->mon1_EDID);\r\nrinfo->mon1_EDID = NULL;\r\nkfree(rinfo->mon2_EDID);\r\nrinfo->mon2_EDID = NULL;\r\n}\r\nbail:\r\nprintk(KERN_INFO "radeonfb: Monitor 1 type %s found\n",\r\nradeon_get_mon_name(rinfo->mon1_type));\r\nif (rinfo->mon1_EDID)\r\nprintk(KERN_INFO "radeonfb: EDID probed\n");\r\nif (!rinfo->has_CRTC2)\r\nreturn;\r\nprintk(KERN_INFO "radeonfb: Monitor 2 type %s found\n",\r\nradeon_get_mon_name(rinfo->mon2_type));\r\nif (rinfo->mon2_EDID)\r\nprintk(KERN_INFO "radeonfb: EDID probed\n");\r\n}\r\nstatic void radeon_fixup_panel_info(struct radeonfb_info *rinfo)\r\n{\r\n#ifdef CONFIG_PPC_OF\r\nif (!rinfo->panel_info.use_bios_dividers && rinfo->mon1_type == MT_LCD\r\n&& rinfo->is_mobility) {\r\nint ppll_div_sel;\r\nu32 ppll_divn;\r\nppll_div_sel = INREG8(CLOCK_CNTL_INDEX + 1) & 0x3;\r\nradeon_pll_errata_after_index(rinfo);\r\nppll_divn = INPLL(PPLL_DIV_0 + ppll_div_sel);\r\nrinfo->panel_info.ref_divider = rinfo->pll.ref_div;\r\nrinfo->panel_info.fbk_divider = ppll_divn & 0x7ff;\r\nrinfo->panel_info.post_divider = (ppll_divn >> 16) & 0x7;\r\nrinfo->panel_info.use_bios_dividers = 1;\r\nprintk(KERN_DEBUG "radeonfb: Using Firmware dividers 0x%08x "\r\n"from PPLL %d\n",\r\nrinfo->panel_info.fbk_divider |\r\n(rinfo->panel_info.post_divider << 16),\r\nppll_div_sel);\r\n}\r\n#endif\r\n}\r\nstatic void radeon_var_to_panel_info(struct radeonfb_info *rinfo, struct fb_var_screeninfo *var)\r\n{\r\nrinfo->panel_info.xres = var->xres;\r\nrinfo->panel_info.yres = var->yres;\r\nrinfo->panel_info.clock = 100000000 / var->pixclock;\r\nrinfo->panel_info.hOver_plus = var->right_margin;\r\nrinfo->panel_info.hSync_width = var->hsync_len;\r\nrinfo->panel_info.hblank = var->left_margin +\r\n(var->right_margin + var->hsync_len);\r\nrinfo->panel_info.vOver_plus = var->lower_margin;\r\nrinfo->panel_info.vSync_width = var->vsync_len;\r\nrinfo->panel_info.vblank = var->upper_margin +\r\n(var->lower_margin + var->vsync_len);\r\nrinfo->panel_info.hAct_high =\r\n(var->sync & FB_SYNC_HOR_HIGH_ACT) != 0;\r\nrinfo->panel_info.vAct_high =\r\n(var->sync & FB_SYNC_VERT_HIGH_ACT) != 0;\r\nrinfo->panel_info.valid = 1;\r\nrinfo->panel_info.pwr_delay = 200;\r\n}\r\nstatic void radeon_videomode_to_var(struct fb_var_screeninfo *var,\r\nconst struct fb_videomode *mode)\r\n{\r\nvar->xres = mode->xres;\r\nvar->yres = mode->yres;\r\nvar->xres_virtual = mode->xres;\r\nvar->yres_virtual = mode->yres;\r\nvar->xoffset = 0;\r\nvar->yoffset = 0;\r\nvar->pixclock = mode->pixclock;\r\nvar->left_margin = mode->left_margin;\r\nvar->right_margin = mode->right_margin;\r\nvar->upper_margin = mode->upper_margin;\r\nvar->lower_margin = mode->lower_margin;\r\nvar->hsync_len = mode->hsync_len;\r\nvar->vsync_len = mode->vsync_len;\r\nvar->sync = mode->sync;\r\nvar->vmode = mode->vmode;\r\n}\r\nvoid __devinit radeon_check_modes(struct radeonfb_info *rinfo, const char *mode_option)\r\n{\r\nstruct fb_info * info = rinfo->info;\r\nint has_default_mode = 0;\r\ninfo->var = radeonfb_default_var;\r\nINIT_LIST_HEAD(&info->modelist);\r\nif (rinfo->mon1_type == MT_LCD)\r\nradeon_get_panel_info_BIOS(rinfo);\r\nif (!rinfo->panel_info.use_bios_dividers && rinfo->mon1_type != MT_CRT\r\n&& rinfo->mon1_EDID) {\r\nstruct fb_var_screeninfo var;\r\npr_debug("Parsing EDID data for panel info\n");\r\nif (fb_parse_edid(rinfo->mon1_EDID, &var) == 0) {\r\nif (var.xres >= rinfo->panel_info.xres &&\r\nvar.yres >= rinfo->panel_info.yres)\r\nradeon_var_to_panel_info(rinfo, &var);\r\n}\r\n}\r\nradeon_fixup_panel_info(rinfo);\r\nif (rinfo->mon1_type != MT_CRT && rinfo->panel_info.valid) {\r\nstruct fb_var_screeninfo *var = &info->var;\r\npr_debug("Setting up default mode based on panel info\n");\r\nvar->xres = rinfo->panel_info.xres;\r\nvar->yres = rinfo->panel_info.yres;\r\nvar->xres_virtual = rinfo->panel_info.xres;\r\nvar->yres_virtual = rinfo->panel_info.yres;\r\nvar->xoffset = var->yoffset = 0;\r\nvar->bits_per_pixel = 8;\r\nvar->pixclock = 100000000 / rinfo->panel_info.clock;\r\nvar->left_margin = (rinfo->panel_info.hblank - rinfo->panel_info.hOver_plus\r\n- rinfo->panel_info.hSync_width);\r\nvar->right_margin = rinfo->panel_info.hOver_plus;\r\nvar->upper_margin = (rinfo->panel_info.vblank - rinfo->panel_info.vOver_plus\r\n- rinfo->panel_info.vSync_width);\r\nvar->lower_margin = rinfo->panel_info.vOver_plus;\r\nvar->hsync_len = rinfo->panel_info.hSync_width;\r\nvar->vsync_len = rinfo->panel_info.vSync_width;\r\nvar->sync = 0;\r\nif (rinfo->panel_info.hAct_high)\r\nvar->sync |= FB_SYNC_HOR_HIGH_ACT;\r\nif (rinfo->panel_info.vAct_high)\r\nvar->sync |= FB_SYNC_VERT_HIGH_ACT;\r\nvar->vmode = 0;\r\nhas_default_mode = 1;\r\n}\r\nif (rinfo->mon1_EDID) {\r\nfb_edid_to_monspecs(rinfo->mon1_EDID, &info->monspecs);\r\nfb_videomode_to_modelist(info->monspecs.modedb,\r\ninfo->monspecs.modedb_len,\r\n&info->modelist);\r\nrinfo->mon1_modedb = info->monspecs.modedb;\r\nrinfo->mon1_dbsize = info->monspecs.modedb_len;\r\n}\r\nif (rinfo->mon1_type != MT_CRT && !rinfo->panel_info.valid) {\r\nstruct fb_videomode *modedb;\r\nint dbsize;\r\nchar modename[32];\r\npr_debug("Guessing panel info...\n");\r\nif (rinfo->panel_info.xres == 0 || rinfo->panel_info.yres == 0) {\r\nu32 tmp = INREG(FP_HORZ_STRETCH) & HORZ_PANEL_SIZE;\r\nrinfo->panel_info.xres = ((tmp >> HORZ_PANEL_SHIFT) + 1) * 8;\r\ntmp = INREG(FP_VERT_STRETCH) & VERT_PANEL_SIZE;\r\nrinfo->panel_info.yres = (tmp >> VERT_PANEL_SHIFT) + 1;\r\n}\r\nif (rinfo->panel_info.xres == 0 || rinfo->panel_info.yres == 0) {\r\nprintk(KERN_WARNING "radeonfb: Can't find panel size, going back to CRT\n");\r\nrinfo->mon1_type = MT_CRT;\r\ngoto pickup_default;\r\n}\r\nprintk(KERN_WARNING "radeonfb: Assuming panel size %dx%d\n",\r\nrinfo->panel_info.xres, rinfo->panel_info.yres);\r\nmodedb = rinfo->mon1_modedb;\r\ndbsize = rinfo->mon1_dbsize;\r\nsnprintf(modename, 31, "%dx%d", rinfo->panel_info.xres, rinfo->panel_info.yres);\r\nif (fb_find_mode(&info->var, info, modename,\r\nmodedb, dbsize, NULL, 8) == 0) {\r\nprintk(KERN_WARNING "radeonfb: Can't find mode for panel size, going back to CRT\n");\r\nrinfo->mon1_type = MT_CRT;\r\ngoto pickup_default;\r\n}\r\nhas_default_mode = 1;\r\nradeon_var_to_panel_info(rinfo, &info->var);\r\n}\r\npickup_default:\r\nif (mode_option) {\r\nif (fb_find_mode(&info->var, info, mode_option,\r\ninfo->monspecs.modedb,\r\ninfo->monspecs.modedb_len, NULL, 8) != 0)\r\nhas_default_mode = 1;\r\n}\r\nif (!has_default_mode && info->monspecs.modedb != NULL) {\r\nstruct fb_monspecs *specs = &info->monspecs;\r\nstruct fb_videomode *modedb = NULL;\r\nif (specs->misc & FB_MISC_1ST_DETAIL) {\r\nint i;\r\nfor (i = 0; i < specs->modedb_len; i++) {\r\nif (specs->modedb[i].flag & FB_MODE_IS_FIRST) {\r\nmodedb = &specs->modedb[i];\r\nbreak;\r\n}\r\n}\r\n} else {\r\nmodedb = &specs->modedb[0];\r\n}\r\nif (modedb != NULL) {\r\ninfo->var.bits_per_pixel = 8;\r\nradeon_videomode_to_var(&info->var, modedb);\r\nhas_default_mode = 1;\r\n}\r\n}\r\nif (1) {\r\nstruct fb_videomode mode;\r\nfb_var_to_videomode(&mode, &info->var);\r\nfb_add_videomode(&mode, &info->modelist);\r\n}\r\n}\r\nstatic int radeon_compare_modes(const struct fb_var_screeninfo *var,\r\nconst struct fb_videomode *mode)\r\n{\r\nint distance = 0;\r\ndistance = mode->yres - var->yres;\r\ndistance += (mode->xres - var->xres)/2;\r\nreturn distance;\r\n}\r\nint radeon_match_mode(struct radeonfb_info *rinfo,\r\nstruct fb_var_screeninfo *dest,\r\nconst struct fb_var_screeninfo *src)\r\n{\r\nconst struct fb_videomode *db = vesa_modes;\r\nint i, dbsize = 34;\r\nint has_rmx, native_db = 0;\r\nint distance = INT_MAX;\r\nconst struct fb_videomode *candidate = NULL;\r\nmemcpy(dest, src, sizeof(struct fb_var_screeninfo));\r\nif (rinfo->mon1_modedb) {\r\ndb = rinfo->mon1_modedb;\r\ndbsize = rinfo->mon1_dbsize;\r\nnative_db = 1;\r\n}\r\nhas_rmx = rinfo->mon1_type == MT_LCD || rinfo->mon1_type == MT_DFP;\r\nif ((src->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_TEST ||\r\n(src->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW) {\r\nif (has_rmx == 0 && rinfo->mon1_modedb)\r\nif (fb_validate_mode((struct fb_var_screeninfo *)src, rinfo->info))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nwhile (db) {\r\nfor (i = 0; i < dbsize; i++) {\r\nint d;\r\nif (db[i].yres < src->yres)\r\ncontinue;\r\nif (db[i].xres < src->xres)\r\ncontinue;\r\nd = radeon_compare_modes(src, &db[i]);\r\nif (d < distance) {\r\ncandidate = &db[i];\r\ndistance = d;\r\n}\r\n}\r\ndb = NULL;\r\nif (native_db && has_rmx) {\r\ndb = vesa_modes;\r\ndbsize = 34;\r\nnative_db = 0;\r\n}\r\n}\r\nif (candidate != NULL) {\r\nradeon_videomode_to_var(dest, candidate);\r\nreturn 0;\r\n}\r\nif (!has_rmx)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}
