static inline int is_imx27_cspi(struct spi_imx_data *d)\r\n{\r\nreturn d->devtype_data->devtype == IMX27_CSPI;\r\n}\r\nstatic inline int is_imx35_cspi(struct spi_imx_data *d)\r\n{\r\nreturn d->devtype_data->devtype == IMX35_CSPI;\r\n}\r\nstatic inline unsigned spi_imx_get_fifosize(struct spi_imx_data *d)\r\n{\r\nreturn (d->devtype_data->devtype == IMX51_ECSPI) ? 64 : 8;\r\n}\r\nstatic unsigned int spi_imx_clkdiv_1(unsigned int fin,\r\nunsigned int fspi, unsigned int max)\r\n{\r\nint i;\r\nfor (i = 2; i < max; i++)\r\nif (fspi * mxc_clkdivs[i] >= fin)\r\nreturn i;\r\nreturn max;\r\n}\r\nstatic unsigned int spi_imx_clkdiv_2(unsigned int fin,\r\nunsigned int fspi)\r\n{\r\nint i, div = 4;\r\nfor (i = 0; i < 7; i++) {\r\nif (fspi * div >= fin)\r\nreturn i;\r\ndiv <<= 1;\r\n}\r\nreturn 7;\r\n}\r\nstatic unsigned int mx51_ecspi_clkdiv(unsigned int fin, unsigned int fspi)\r\n{\r\nunsigned int pre, post;\r\nif (unlikely(fspi > fin))\r\nreturn 0;\r\npost = fls(fin) - fls(fspi);\r\nif (fin > fspi << post)\r\npost++;\r\npost = max(4U, post) - 4;\r\nif (unlikely(post > 0xf)) {\r\npr_err("%s: cannot set clock freq: %u (base freq: %u)\n",\r\n__func__, fspi, fin);\r\nreturn 0xff;\r\n}\r\npre = DIV_ROUND_UP(fin, fspi << post) - 1;\r\npr_debug("%s: fin: %u, fspi: %u, post: %u, pre: %u\n",\r\n__func__, fin, fspi, post, pre);\r\nreturn (pre << MX51_ECSPI_CTRL_PREDIV_OFFSET) |\r\n(post << MX51_ECSPI_CTRL_POSTDIV_OFFSET);\r\n}\r\nstatic void __maybe_unused mx51_ecspi_intctrl(struct spi_imx_data *spi_imx, int enable)\r\n{\r\nunsigned val = 0;\r\nif (enable & MXC_INT_TE)\r\nval |= MX51_ECSPI_INT_TEEN;\r\nif (enable & MXC_INT_RR)\r\nval |= MX51_ECSPI_INT_RREN;\r\nwritel(val, spi_imx->base + MX51_ECSPI_INT);\r\n}\r\nstatic void __maybe_unused mx51_ecspi_trigger(struct spi_imx_data *spi_imx)\r\n{\r\nu32 reg;\r\nreg = readl(spi_imx->base + MX51_ECSPI_CTRL);\r\nreg |= MX51_ECSPI_CTRL_XCH;\r\nwritel(reg, spi_imx->base + MX51_ECSPI_CTRL);\r\n}\r\nstatic int __maybe_unused mx51_ecspi_config(struct spi_imx_data *spi_imx,\r\nstruct spi_imx_config *config)\r\n{\r\nu32 ctrl = MX51_ECSPI_CTRL_ENABLE, cfg = 0;\r\nctrl |= MX51_ECSPI_CTRL_MODE_MASK;\r\nctrl |= mx51_ecspi_clkdiv(spi_imx->spi_clk, config->speed_hz);\r\nctrl |= MX51_ECSPI_CTRL_CS(config->cs);\r\nctrl |= (config->bpw - 1) << MX51_ECSPI_CTRL_BL_OFFSET;\r\ncfg |= MX51_ECSPI_CONFIG_SBBCTRL(config->cs);\r\nif (config->mode & SPI_CPHA)\r\ncfg |= MX51_ECSPI_CONFIG_SCLKPHA(config->cs);\r\nif (config->mode & SPI_CPOL)\r\ncfg |= MX51_ECSPI_CONFIG_SCLKPOL(config->cs);\r\nif (config->mode & SPI_CS_HIGH)\r\ncfg |= MX51_ECSPI_CONFIG_SSBPOL(config->cs);\r\nwritel(ctrl, spi_imx->base + MX51_ECSPI_CTRL);\r\nwritel(cfg, spi_imx->base + MX51_ECSPI_CONFIG);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mx51_ecspi_rx_available(struct spi_imx_data *spi_imx)\r\n{\r\nreturn readl(spi_imx->base + MX51_ECSPI_STAT) & MX51_ECSPI_STAT_RR;\r\n}\r\nstatic void __maybe_unused mx51_ecspi_reset(struct spi_imx_data *spi_imx)\r\n{\r\nwhile (mx51_ecspi_rx_available(spi_imx))\r\nreadl(spi_imx->base + MXC_CSPIRXDATA);\r\n}\r\nstatic void __maybe_unused mx31_intctrl(struct spi_imx_data *spi_imx, int enable)\r\n{\r\nunsigned int val = 0;\r\nif (enable & MXC_INT_TE)\r\nval |= MX31_INTREG_TEEN;\r\nif (enable & MXC_INT_RR)\r\nval |= MX31_INTREG_RREN;\r\nwritel(val, spi_imx->base + MXC_CSPIINT);\r\n}\r\nstatic void __maybe_unused mx31_trigger(struct spi_imx_data *spi_imx)\r\n{\r\nunsigned int reg;\r\nreg = readl(spi_imx->base + MXC_CSPICTRL);\r\nreg |= MX31_CSPICTRL_XCH;\r\nwritel(reg, spi_imx->base + MXC_CSPICTRL);\r\n}\r\nstatic int __maybe_unused mx31_config(struct spi_imx_data *spi_imx,\r\nstruct spi_imx_config *config)\r\n{\r\nunsigned int reg = MX31_CSPICTRL_ENABLE | MX31_CSPICTRL_MASTER;\r\nint cs = spi_imx->chipselect[config->cs];\r\nreg |= spi_imx_clkdiv_2(spi_imx->spi_clk, config->speed_hz) <<\r\nMX31_CSPICTRL_DR_SHIFT;\r\nif (is_imx35_cspi(spi_imx)) {\r\nreg |= (config->bpw - 1) << MX35_CSPICTRL_BL_SHIFT;\r\nreg |= MX31_CSPICTRL_SSCTL;\r\n} else {\r\nreg |= (config->bpw - 1) << MX31_CSPICTRL_BC_SHIFT;\r\n}\r\nif (config->mode & SPI_CPHA)\r\nreg |= MX31_CSPICTRL_PHA;\r\nif (config->mode & SPI_CPOL)\r\nreg |= MX31_CSPICTRL_POL;\r\nif (config->mode & SPI_CS_HIGH)\r\nreg |= MX31_CSPICTRL_SSPOL;\r\nif (cs < 0)\r\nreg |= (cs + 32) <<\r\n(is_imx35_cspi(spi_imx) ? MX35_CSPICTRL_CS_SHIFT :\r\nMX31_CSPICTRL_CS_SHIFT);\r\nwritel(reg, spi_imx->base + MXC_CSPICTRL);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mx31_rx_available(struct spi_imx_data *spi_imx)\r\n{\r\nreturn readl(spi_imx->base + MX31_CSPISTATUS) & MX31_STATUS_RR;\r\n}\r\nstatic void __maybe_unused mx31_reset(struct spi_imx_data *spi_imx)\r\n{\r\nwhile (readl(spi_imx->base + MX31_CSPISTATUS) & MX31_STATUS_RR)\r\nreadl(spi_imx->base + MXC_CSPIRXDATA);\r\n}\r\nstatic void __maybe_unused mx21_intctrl(struct spi_imx_data *spi_imx, int enable)\r\n{\r\nunsigned int val = 0;\r\nif (enable & MXC_INT_TE)\r\nval |= MX21_INTREG_TEEN;\r\nif (enable & MXC_INT_RR)\r\nval |= MX21_INTREG_RREN;\r\nwritel(val, spi_imx->base + MXC_CSPIINT);\r\n}\r\nstatic void __maybe_unused mx21_trigger(struct spi_imx_data *spi_imx)\r\n{\r\nunsigned int reg;\r\nreg = readl(spi_imx->base + MXC_CSPICTRL);\r\nreg |= MX21_CSPICTRL_XCH;\r\nwritel(reg, spi_imx->base + MXC_CSPICTRL);\r\n}\r\nstatic int __maybe_unused mx21_config(struct spi_imx_data *spi_imx,\r\nstruct spi_imx_config *config)\r\n{\r\nunsigned int reg = MX21_CSPICTRL_ENABLE | MX21_CSPICTRL_MASTER;\r\nint cs = spi_imx->chipselect[config->cs];\r\nunsigned int max = is_imx27_cspi(spi_imx) ? 16 : 18;\r\nreg |= spi_imx_clkdiv_1(spi_imx->spi_clk, config->speed_hz, max) <<\r\nMX21_CSPICTRL_DR_SHIFT;\r\nreg |= config->bpw - 1;\r\nif (config->mode & SPI_CPHA)\r\nreg |= MX21_CSPICTRL_PHA;\r\nif (config->mode & SPI_CPOL)\r\nreg |= MX21_CSPICTRL_POL;\r\nif (config->mode & SPI_CS_HIGH)\r\nreg |= MX21_CSPICTRL_SSPOL;\r\nif (cs < 0)\r\nreg |= (cs + 32) << MX21_CSPICTRL_CS_SHIFT;\r\nwritel(reg, spi_imx->base + MXC_CSPICTRL);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mx21_rx_available(struct spi_imx_data *spi_imx)\r\n{\r\nreturn readl(spi_imx->base + MXC_CSPIINT) & MX21_INTREG_RR;\r\n}\r\nstatic void __maybe_unused mx21_reset(struct spi_imx_data *spi_imx)\r\n{\r\nwritel(1, spi_imx->base + MXC_RESET);\r\n}\r\nstatic void __maybe_unused mx1_intctrl(struct spi_imx_data *spi_imx, int enable)\r\n{\r\nunsigned int val = 0;\r\nif (enable & MXC_INT_TE)\r\nval |= MX1_INTREG_TEEN;\r\nif (enable & MXC_INT_RR)\r\nval |= MX1_INTREG_RREN;\r\nwritel(val, spi_imx->base + MXC_CSPIINT);\r\n}\r\nstatic void __maybe_unused mx1_trigger(struct spi_imx_data *spi_imx)\r\n{\r\nunsigned int reg;\r\nreg = readl(spi_imx->base + MXC_CSPICTRL);\r\nreg |= MX1_CSPICTRL_XCH;\r\nwritel(reg, spi_imx->base + MXC_CSPICTRL);\r\n}\r\nstatic int __maybe_unused mx1_config(struct spi_imx_data *spi_imx,\r\nstruct spi_imx_config *config)\r\n{\r\nunsigned int reg = MX1_CSPICTRL_ENABLE | MX1_CSPICTRL_MASTER;\r\nreg |= spi_imx_clkdiv_2(spi_imx->spi_clk, config->speed_hz) <<\r\nMX1_CSPICTRL_DR_SHIFT;\r\nreg |= config->bpw - 1;\r\nif (config->mode & SPI_CPHA)\r\nreg |= MX1_CSPICTRL_PHA;\r\nif (config->mode & SPI_CPOL)\r\nreg |= MX1_CSPICTRL_POL;\r\nwritel(reg, spi_imx->base + MXC_CSPICTRL);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mx1_rx_available(struct spi_imx_data *spi_imx)\r\n{\r\nreturn readl(spi_imx->base + MXC_CSPIINT) & MX1_INTREG_RR;\r\n}\r\nstatic void __maybe_unused mx1_reset(struct spi_imx_data *spi_imx)\r\n{\r\nwritel(1, spi_imx->base + MXC_RESET);\r\n}\r\nstatic void spi_imx_chipselect(struct spi_device *spi, int is_active)\r\n{\r\nstruct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);\r\nint gpio = spi_imx->chipselect[spi->chip_select];\r\nint active = is_active != BITBANG_CS_INACTIVE;\r\nint dev_is_lowactive = !(spi->mode & SPI_CS_HIGH);\r\nif (gpio < 0)\r\nreturn;\r\ngpio_set_value(gpio, dev_is_lowactive ^ active);\r\n}\r\nstatic void spi_imx_push(struct spi_imx_data *spi_imx)\r\n{\r\nwhile (spi_imx->txfifo < spi_imx_get_fifosize(spi_imx)) {\r\nif (!spi_imx->count)\r\nbreak;\r\nspi_imx->tx(spi_imx);\r\nspi_imx->txfifo++;\r\n}\r\nspi_imx->devtype_data->trigger(spi_imx);\r\n}\r\nstatic irqreturn_t spi_imx_isr(int irq, void *dev_id)\r\n{\r\nstruct spi_imx_data *spi_imx = dev_id;\r\nwhile (spi_imx->devtype_data->rx_available(spi_imx)) {\r\nspi_imx->rx(spi_imx);\r\nspi_imx->txfifo--;\r\n}\r\nif (spi_imx->count) {\r\nspi_imx_push(spi_imx);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (spi_imx->txfifo) {\r\nspi_imx->devtype_data->intctrl(\r\nspi_imx, MXC_INT_RR);\r\nreturn IRQ_HANDLED;\r\n}\r\nspi_imx->devtype_data->intctrl(spi_imx, 0);\r\ncomplete(&spi_imx->xfer_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int spi_imx_setupxfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);\r\nstruct spi_imx_config config;\r\nconfig.bpw = t ? t->bits_per_word : spi->bits_per_word;\r\nconfig.speed_hz = t ? t->speed_hz : spi->max_speed_hz;\r\nconfig.mode = spi->mode;\r\nconfig.cs = spi->chip_select;\r\nif (!config.speed_hz)\r\nconfig.speed_hz = spi->max_speed_hz;\r\nif (!config.bpw)\r\nconfig.bpw = spi->bits_per_word;\r\nif (!config.speed_hz)\r\nconfig.speed_hz = spi->max_speed_hz;\r\nif (config.bpw <= 8) {\r\nspi_imx->rx = spi_imx_buf_rx_u8;\r\nspi_imx->tx = spi_imx_buf_tx_u8;\r\n} else if (config.bpw <= 16) {\r\nspi_imx->rx = spi_imx_buf_rx_u16;\r\nspi_imx->tx = spi_imx_buf_tx_u16;\r\n} else if (config.bpw <= 32) {\r\nspi_imx->rx = spi_imx_buf_rx_u32;\r\nspi_imx->tx = spi_imx_buf_tx_u32;\r\n} else\r\nBUG();\r\nspi_imx->devtype_data->config(spi_imx, &config);\r\nreturn 0;\r\n}\r\nstatic int spi_imx_transfer(struct spi_device *spi,\r\nstruct spi_transfer *transfer)\r\n{\r\nstruct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);\r\nspi_imx->tx_buf = transfer->tx_buf;\r\nspi_imx->rx_buf = transfer->rx_buf;\r\nspi_imx->count = transfer->len;\r\nspi_imx->txfifo = 0;\r\ninit_completion(&spi_imx->xfer_done);\r\nspi_imx_push(spi_imx);\r\nspi_imx->devtype_data->intctrl(spi_imx, MXC_INT_TE);\r\nwait_for_completion(&spi_imx->xfer_done);\r\nreturn transfer->len;\r\n}\r\nstatic int spi_imx_setup(struct spi_device *spi)\r\n{\r\nstruct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);\r\nint gpio = spi_imx->chipselect[spi->chip_select];\r\ndev_dbg(&spi->dev, "%s: mode %d, %u bpw, %d hz\n", __func__,\r\nspi->mode, spi->bits_per_word, spi->max_speed_hz);\r\nif (gpio >= 0)\r\ngpio_direction_output(gpio, spi->mode & SPI_CS_HIGH ? 0 : 1);\r\nspi_imx_chipselect(spi, BITBANG_CS_INACTIVE);\r\nreturn 0;\r\n}\r\nstatic void spi_imx_cleanup(struct spi_device *spi)\r\n{\r\n}\r\nstatic int __devinit spi_imx_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *of_id =\r\nof_match_device(spi_imx_dt_ids, &pdev->dev);\r\nstruct spi_imx_master *mxc_platform_info =\r\ndev_get_platdata(&pdev->dev);\r\nstruct spi_master *master;\r\nstruct spi_imx_data *spi_imx;\r\nstruct resource *res;\r\nint i, ret, num_cs;\r\nif (!np && !mxc_platform_info) {\r\ndev_err(&pdev->dev, "can't get the platform data\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32(np, "fsl,spi-num-chipselects", &num_cs);\r\nif (ret < 0)\r\nnum_cs = mxc_platform_info->num_chipselect;\r\nmaster = spi_alloc_master(&pdev->dev,\r\nsizeof(struct spi_imx_data) + sizeof(int) * num_cs);\r\nif (!master)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, master);\r\nmaster->bus_num = pdev->id;\r\nmaster->num_chipselect = num_cs;\r\nspi_imx = spi_master_get_devdata(master);\r\nspi_imx->bitbang.master = spi_master_get(master);\r\nfor (i = 0; i < master->num_chipselect; i++) {\r\nint cs_gpio = of_get_named_gpio(np, "cs-gpios", i);\r\nif (cs_gpio < 0)\r\ncs_gpio = mxc_platform_info->chipselect[i];\r\nspi_imx->chipselect[i] = cs_gpio;\r\nif (cs_gpio < 0)\r\ncontinue;\r\nret = gpio_request(spi_imx->chipselect[i], DRIVER_NAME);\r\nif (ret) {\r\nwhile (i > 0) {\r\ni--;\r\nif (spi_imx->chipselect[i] >= 0)\r\ngpio_free(spi_imx->chipselect[i]);\r\n}\r\ndev_err(&pdev->dev, "can't get cs gpios\n");\r\ngoto out_master_put;\r\n}\r\n}\r\nspi_imx->bitbang.chipselect = spi_imx_chipselect;\r\nspi_imx->bitbang.setup_transfer = spi_imx_setupxfer;\r\nspi_imx->bitbang.txrx_bufs = spi_imx_transfer;\r\nspi_imx->bitbang.master->setup = spi_imx_setup;\r\nspi_imx->bitbang.master->cleanup = spi_imx_cleanup;\r\nspi_imx->bitbang.master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\ninit_completion(&spi_imx->xfer_done);\r\nspi_imx->devtype_data = of_id ? of_id->data :\r\n(struct spi_imx_devtype_data *) pdev->id_entry->driver_data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "can't get platform resource\n");\r\nret = -ENOMEM;\r\ngoto out_gpio_free;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res), pdev->name)) {\r\ndev_err(&pdev->dev, "request_mem_region failed\n");\r\nret = -EBUSY;\r\ngoto out_gpio_free;\r\n}\r\nspi_imx->base = ioremap(res->start, resource_size(res));\r\nif (!spi_imx->base) {\r\nret = -EINVAL;\r\ngoto out_release_mem;\r\n}\r\nspi_imx->irq = platform_get_irq(pdev, 0);\r\nif (spi_imx->irq < 0) {\r\nret = -EINVAL;\r\ngoto out_iounmap;\r\n}\r\nret = request_irq(spi_imx->irq, spi_imx_isr, 0, DRIVER_NAME, spi_imx);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can't get irq%d: %d\n", spi_imx->irq, ret);\r\ngoto out_iounmap;\r\n}\r\nspi_imx->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(spi_imx->clk)) {\r\ndev_err(&pdev->dev, "unable to get clock\n");\r\nret = PTR_ERR(spi_imx->clk);\r\ngoto out_free_irq;\r\n}\r\nclk_enable(spi_imx->clk);\r\nspi_imx->spi_clk = clk_get_rate(spi_imx->clk);\r\nspi_imx->devtype_data->reset(spi_imx);\r\nspi_imx->devtype_data->intctrl(spi_imx, 0);\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nret = spi_bitbang_start(&spi_imx->bitbang);\r\nif (ret) {\r\ndev_err(&pdev->dev, "bitbang start failed with %d\n", ret);\r\ngoto out_clk_put;\r\n}\r\ndev_info(&pdev->dev, "probed\n");\r\nreturn ret;\r\nout_clk_put:\r\nclk_disable(spi_imx->clk);\r\nclk_put(spi_imx->clk);\r\nout_free_irq:\r\nfree_irq(spi_imx->irq, spi_imx);\r\nout_iounmap:\r\niounmap(spi_imx->base);\r\nout_release_mem:\r\nrelease_mem_region(res->start, resource_size(res));\r\nout_gpio_free:\r\nfor (i = 0; i < master->num_chipselect; i++)\r\nif (spi_imx->chipselect[i] >= 0)\r\ngpio_free(spi_imx->chipselect[i]);\r\nout_master_put:\r\nspi_master_put(master);\r\nkfree(master);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn ret;\r\n}\r\nstatic int __devexit spi_imx_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstruct spi_imx_data *spi_imx = spi_master_get_devdata(master);\r\nint i;\r\nspi_bitbang_stop(&spi_imx->bitbang);\r\nwritel(0, spi_imx->base + MXC_CSPICTRL);\r\nclk_disable(spi_imx->clk);\r\nclk_put(spi_imx->clk);\r\nfree_irq(spi_imx->irq, spi_imx);\r\niounmap(spi_imx->base);\r\nfor (i = 0; i < master->num_chipselect; i++)\r\nif (spi_imx->chipselect[i] >= 0)\r\ngpio_free(spi_imx->chipselect[i]);\r\nspi_master_put(master);\r\nrelease_mem_region(res->start, resource_size(res));\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
