static void spi_sh_write(struct spi_sh_data *ss, unsigned long data,\r\nunsigned long offset)\r\n{\r\nwritel(data, ss->addr + offset);\r\n}\r\nstatic unsigned long spi_sh_read(struct spi_sh_data *ss, unsigned long offset)\r\n{\r\nreturn readl(ss->addr + offset);\r\n}\r\nstatic void spi_sh_set_bit(struct spi_sh_data *ss, unsigned long val,\r\nunsigned long offset)\r\n{\r\nunsigned long tmp;\r\ntmp = spi_sh_read(ss, offset);\r\ntmp |= val;\r\nspi_sh_write(ss, tmp, offset);\r\n}\r\nstatic void spi_sh_clear_bit(struct spi_sh_data *ss, unsigned long val,\r\nunsigned long offset)\r\n{\r\nunsigned long tmp;\r\ntmp = spi_sh_read(ss, offset);\r\ntmp &= ~val;\r\nspi_sh_write(ss, tmp, offset);\r\n}\r\nstatic void clear_fifo(struct spi_sh_data *ss)\r\n{\r\nspi_sh_set_bit(ss, SPI_SH_RSTF, SPI_SH_CR2);\r\nspi_sh_clear_bit(ss, SPI_SH_RSTF, SPI_SH_CR2);\r\n}\r\nstatic int spi_sh_wait_receive_buffer(struct spi_sh_data *ss)\r\n{\r\nint timeout = 100000;\r\nwhile (spi_sh_read(ss, SPI_SH_CR1) & SPI_SH_RBE) {\r\nudelay(10);\r\nif (timeout-- < 0)\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int spi_sh_wait_write_buffer_empty(struct spi_sh_data *ss)\r\n{\r\nint timeout = 100000;\r\nwhile (!(spi_sh_read(ss, SPI_SH_CR1) & SPI_SH_TBE)) {\r\nudelay(10);\r\nif (timeout-- < 0)\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int spi_sh_send(struct spi_sh_data *ss, struct spi_message *mesg,\r\nstruct spi_transfer *t)\r\n{\r\nint i, retval = 0;\r\nint remain = t->len;\r\nint cur_len;\r\nunsigned char *data;\r\nunsigned long tmp;\r\nlong ret;\r\nif (t->len)\r\nspi_sh_set_bit(ss, SPI_SH_SSA, SPI_SH_CR1);\r\ndata = (unsigned char *)t->tx_buf;\r\nwhile (remain > 0) {\r\ncur_len = min(SPI_SH_FIFO_SIZE, remain);\r\nfor (i = 0; i < cur_len &&\r\n!(spi_sh_read(ss, SPI_SH_CR4) &\r\nSPI_SH_WPABRT) &&\r\n!(spi_sh_read(ss, SPI_SH_CR1) & SPI_SH_TBF);\r\ni++)\r\nspi_sh_write(ss, (unsigned long)data[i], SPI_SH_TBR);\r\nif (spi_sh_read(ss, SPI_SH_CR4) & SPI_SH_WPABRT) {\r\nspi_sh_set_bit(ss, SPI_SH_WPABRT, SPI_SH_CR4);\r\nretval = -EIO;\r\nbreak;\r\n}\r\ncur_len = i;\r\nremain -= cur_len;\r\ndata += cur_len;\r\nif (remain > 0) {\r\nss->cr1 &= ~SPI_SH_TBE;\r\nspi_sh_set_bit(ss, SPI_SH_TBE, SPI_SH_CR4);\r\nret = wait_event_interruptible_timeout(ss->wait,\r\nss->cr1 & SPI_SH_TBE,\r\nSPI_SH_SEND_TIMEOUT);\r\nif (ret == 0 && !(ss->cr1 & SPI_SH_TBE)) {\r\nprintk(KERN_ERR "%s: timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\n}\r\nif (list_is_last(&t->transfer_list, &mesg->transfers)) {\r\ntmp = spi_sh_read(ss, SPI_SH_CR1);\r\ntmp = tmp & ~(SPI_SH_SSD | SPI_SH_SSDB);\r\nspi_sh_write(ss, tmp, SPI_SH_CR1);\r\nspi_sh_set_bit(ss, SPI_SH_SSA, SPI_SH_CR1);\r\nss->cr1 &= ~SPI_SH_TBE;\r\nspi_sh_set_bit(ss, SPI_SH_TBE, SPI_SH_CR4);\r\nret = wait_event_interruptible_timeout(ss->wait,\r\nss->cr1 & SPI_SH_TBE,\r\nSPI_SH_SEND_TIMEOUT);\r\nif (ret == 0 && (ss->cr1 & SPI_SH_TBE)) {\r\nprintk(KERN_ERR "%s: timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic int spi_sh_receive(struct spi_sh_data *ss, struct spi_message *mesg,\r\nstruct spi_transfer *t)\r\n{\r\nint i;\r\nint remain = t->len;\r\nint cur_len;\r\nunsigned char *data;\r\nunsigned long tmp;\r\nlong ret;\r\nif (t->len > SPI_SH_MAX_BYTE)\r\nspi_sh_write(ss, SPI_SH_MAX_BYTE, SPI_SH_CR3);\r\nelse\r\nspi_sh_write(ss, t->len, SPI_SH_CR3);\r\ntmp = spi_sh_read(ss, SPI_SH_CR1);\r\ntmp = tmp & ~(SPI_SH_SSD | SPI_SH_SSDB);\r\nspi_sh_write(ss, tmp, SPI_SH_CR1);\r\nspi_sh_set_bit(ss, SPI_SH_SSA, SPI_SH_CR1);\r\nspi_sh_wait_write_buffer_empty(ss);\r\ndata = (unsigned char *)t->rx_buf;\r\nwhile (remain > 0) {\r\nif (remain >= SPI_SH_FIFO_SIZE) {\r\nss->cr1 &= ~SPI_SH_RBF;\r\nspi_sh_set_bit(ss, SPI_SH_RBF, SPI_SH_CR4);\r\nret = wait_event_interruptible_timeout(ss->wait,\r\nss->cr1 & SPI_SH_RBF,\r\nSPI_SH_RECEIVE_TIMEOUT);\r\nif (ret == 0 &&\r\nspi_sh_read(ss, SPI_SH_CR1) & SPI_SH_RBE) {\r\nprintk(KERN_ERR "%s: timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\ncur_len = min(SPI_SH_FIFO_SIZE, remain);\r\nfor (i = 0; i < cur_len; i++) {\r\nif (spi_sh_wait_receive_buffer(ss))\r\nbreak;\r\ndata[i] = (unsigned char)spi_sh_read(ss, SPI_SH_RBR);\r\n}\r\nremain -= cur_len;\r\ndata += cur_len;\r\n}\r\nif (t->len > SPI_SH_MAX_BYTE) {\r\nclear_fifo(ss);\r\nspi_sh_write(ss, 1, SPI_SH_CR3);\r\n} else {\r\nspi_sh_write(ss, 0, SPI_SH_CR3);\r\n}\r\nreturn 0;\r\n}\r\nstatic void spi_sh_work(struct work_struct *work)\r\n{\r\nstruct spi_sh_data *ss = container_of(work, struct spi_sh_data, ws);\r\nstruct spi_message *mesg;\r\nstruct spi_transfer *t;\r\nunsigned long flags;\r\nint ret;\r\npr_debug("%s: enter\n", __func__);\r\nspin_lock_irqsave(&ss->lock, flags);\r\nwhile (!list_empty(&ss->queue)) {\r\nmesg = list_entry(ss->queue.next, struct spi_message, queue);\r\nlist_del_init(&mesg->queue);\r\nspin_unlock_irqrestore(&ss->lock, flags);\r\nlist_for_each_entry(t, &mesg->transfers, transfer_list) {\r\npr_debug("tx_buf = %p, rx_buf = %p\n",\r\nt->tx_buf, t->rx_buf);\r\npr_debug("len = %d, delay_usecs = %d\n",\r\nt->len, t->delay_usecs);\r\nif (t->tx_buf) {\r\nret = spi_sh_send(ss, mesg, t);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nif (t->rx_buf) {\r\nret = spi_sh_receive(ss, mesg, t);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nmesg->actual_length += t->len;\r\n}\r\nspin_lock_irqsave(&ss->lock, flags);\r\nmesg->status = 0;\r\nmesg->complete(mesg->context);\r\n}\r\nclear_fifo(ss);\r\nspi_sh_set_bit(ss, SPI_SH_SSD, SPI_SH_CR1);\r\nudelay(100);\r\nspi_sh_clear_bit(ss, SPI_SH_SSA | SPI_SH_SSDB | SPI_SH_SSD,\r\nSPI_SH_CR1);\r\nclear_fifo(ss);\r\nspin_unlock_irqrestore(&ss->lock, flags);\r\nreturn;\r\nerror:\r\nmesg->status = ret;\r\nmesg->complete(mesg->context);\r\nspi_sh_clear_bit(ss, SPI_SH_SSA | SPI_SH_SSDB | SPI_SH_SSD,\r\nSPI_SH_CR1);\r\nclear_fifo(ss);\r\n}\r\nstatic int spi_sh_setup(struct spi_device *spi)\r\n{\r\nstruct spi_sh_data *ss = spi_master_get_devdata(spi->master);\r\nif (!spi->bits_per_word)\r\nspi->bits_per_word = 8;\r\npr_debug("%s: enter\n", __func__);\r\nspi_sh_write(ss, 0xfe, SPI_SH_CR1);\r\nspi_sh_write(ss, 0x00, SPI_SH_CR1);\r\nspi_sh_write(ss, 0x00, SPI_SH_CR3);\r\nclear_fifo(ss);\r\nspi_sh_write(ss, spi_sh_read(ss, SPI_SH_CR2) | 0x07, SPI_SH_CR2);\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic int spi_sh_transfer(struct spi_device *spi, struct spi_message *mesg)\r\n{\r\nstruct spi_sh_data *ss = spi_master_get_devdata(spi->master);\r\nunsigned long flags;\r\npr_debug("%s: enter\n", __func__);\r\npr_debug("\tmode = %02x\n", spi->mode);\r\nspin_lock_irqsave(&ss->lock, flags);\r\nmesg->actual_length = 0;\r\nmesg->status = -EINPROGRESS;\r\nspi_sh_clear_bit(ss, SPI_SH_SSA, SPI_SH_CR1);\r\nlist_add_tail(&mesg->queue, &ss->queue);\r\nqueue_work(ss->workqueue, &ss->ws);\r\nspin_unlock_irqrestore(&ss->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void spi_sh_cleanup(struct spi_device *spi)\r\n{\r\nstruct spi_sh_data *ss = spi_master_get_devdata(spi->master);\r\npr_debug("%s: enter\n", __func__);\r\nspi_sh_clear_bit(ss, SPI_SH_SSA | SPI_SH_SSDB | SPI_SH_SSD,\r\nSPI_SH_CR1);\r\n}\r\nstatic irqreturn_t spi_sh_irq(int irq, void *_ss)\r\n{\r\nstruct spi_sh_data *ss = (struct spi_sh_data *)_ss;\r\nunsigned long cr1;\r\ncr1 = spi_sh_read(ss, SPI_SH_CR1);\r\nif (cr1 & SPI_SH_TBE)\r\nss->cr1 |= SPI_SH_TBE;\r\nif (cr1 & SPI_SH_TBF)\r\nss->cr1 |= SPI_SH_TBF;\r\nif (cr1 & SPI_SH_RBE)\r\nss->cr1 |= SPI_SH_RBE;\r\nif (cr1 & SPI_SH_RBF)\r\nss->cr1 |= SPI_SH_RBF;\r\nif (ss->cr1) {\r\nspi_sh_clear_bit(ss, ss->cr1, SPI_SH_CR4);\r\nwake_up(&ss->wait);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devexit spi_sh_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_sh_data *ss = dev_get_drvdata(&pdev->dev);\r\nspi_unregister_master(ss->master);\r\ndestroy_workqueue(ss->workqueue);\r\nfree_irq(ss->irq, ss);\r\niounmap(ss->addr);\r\nreturn 0;\r\n}\r\nstatic int __devinit spi_sh_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct spi_master *master;\r\nstruct spi_sh_data *ss;\r\nint ret, irq;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(res == NULL)) {\r\ndev_err(&pdev->dev, "invalid resource\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "platform_get_irq error\n");\r\nreturn -ENODEV;\r\n}\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct spi_sh_data));\r\nif (master == NULL) {\r\ndev_err(&pdev->dev, "spi_alloc_master error.\n");\r\nreturn -ENOMEM;\r\n}\r\nss = spi_master_get_devdata(master);\r\ndev_set_drvdata(&pdev->dev, ss);\r\nss->irq = irq;\r\nss->master = master;\r\nss->addr = ioremap(res->start, resource_size(res));\r\nif (ss->addr == NULL) {\r\ndev_err(&pdev->dev, "ioremap error.\n");\r\nret = -ENOMEM;\r\ngoto error1;\r\n}\r\nINIT_LIST_HEAD(&ss->queue);\r\nspin_lock_init(&ss->lock);\r\nINIT_WORK(&ss->ws, spi_sh_work);\r\ninit_waitqueue_head(&ss->wait);\r\nss->workqueue = create_singlethread_workqueue(\r\ndev_name(master->dev.parent));\r\nif (ss->workqueue == NULL) {\r\ndev_err(&pdev->dev, "create workqueue error\n");\r\nret = -EBUSY;\r\ngoto error2;\r\n}\r\nret = request_irq(irq, spi_sh_irq, 0, "spi_sh", ss);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "request_irq error\n");\r\ngoto error3;\r\n}\r\nmaster->num_chipselect = 2;\r\nmaster->bus_num = pdev->id;\r\nmaster->setup = spi_sh_setup;\r\nmaster->transfer = spi_sh_transfer;\r\nmaster->cleanup = spi_sh_cleanup;\r\nret = spi_register_master(master);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "spi_register_master error.\n");\r\ngoto error4;\r\n}\r\nreturn 0;\r\nerror4:\r\nfree_irq(irq, ss);\r\nerror3:\r\ndestroy_workqueue(ss->workqueue);\r\nerror2:\r\niounmap(ss->addr);\r\nerror1:\r\nspi_master_put(master);\r\nreturn ret;\r\n}
