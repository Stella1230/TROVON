static unsigned int cache_level_to_agp_type(struct drm_device *dev,\r\nenum i915_cache_level cache_level)\r\n{\r\nswitch (cache_level) {\r\ncase I915_CACHE_LLC_MLC:\r\nif (INTEL_INFO(dev)->gen >= 6)\r\nreturn AGP_USER_CACHED_MEMORY_LLC_MLC;\r\ncase I915_CACHE_LLC:\r\nreturn AGP_USER_CACHED_MEMORY;\r\ndefault:\r\ncase I915_CACHE_NONE:\r\nreturn AGP_USER_MEMORY;\r\n}\r\n}\r\nstatic bool do_idling(struct drm_i915_private *dev_priv)\r\n{\r\nbool ret = dev_priv->mm.interruptible;\r\nif (unlikely(dev_priv->mm.gtt->do_idle_maps)) {\r\ndev_priv->mm.interruptible = false;\r\nif (i915_gpu_idle(dev_priv->dev)) {\r\nDRM_ERROR("Couldn't idle GPU\n");\r\nudelay(10);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void undo_idling(struct drm_i915_private *dev_priv, bool interruptible)\r\n{\r\nif (unlikely(dev_priv->mm.gtt->do_idle_maps))\r\ndev_priv->mm.interruptible = interruptible;\r\n}\r\nvoid i915_gem_restore_gtt_mappings(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct drm_i915_gem_object *obj;\r\nintel_gtt_clear_range(dev_priv->mm.gtt_start / PAGE_SIZE,\r\n(dev_priv->mm.gtt_end - dev_priv->mm.gtt_start) / PAGE_SIZE);\r\nlist_for_each_entry(obj, &dev_priv->mm.gtt_list, gtt_list) {\r\ni915_gem_clflush_object(obj);\r\ni915_gem_gtt_rebind_object(obj, obj->cache_level);\r\n}\r\nintel_gtt_chipset_flush();\r\n}\r\nint i915_gem_gtt_bind_object(struct drm_i915_gem_object *obj)\r\n{\r\nstruct drm_device *dev = obj->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nunsigned int agp_type = cache_level_to_agp_type(dev, obj->cache_level);\r\nint ret;\r\nif (dev_priv->mm.gtt->needs_dmar) {\r\nret = intel_gtt_map_memory(obj->pages,\r\nobj->base.size >> PAGE_SHIFT,\r\n&obj->sg_list,\r\n&obj->num_sg);\r\nif (ret != 0)\r\nreturn ret;\r\nintel_gtt_insert_sg_entries(obj->sg_list,\r\nobj->num_sg,\r\nobj->gtt_space->start >> PAGE_SHIFT,\r\nagp_type);\r\n} else\r\nintel_gtt_insert_pages(obj->gtt_space->start >> PAGE_SHIFT,\r\nobj->base.size >> PAGE_SHIFT,\r\nobj->pages,\r\nagp_type);\r\nreturn 0;\r\n}\r\nvoid i915_gem_gtt_rebind_object(struct drm_i915_gem_object *obj,\r\nenum i915_cache_level cache_level)\r\n{\r\nstruct drm_device *dev = obj->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nunsigned int agp_type = cache_level_to_agp_type(dev, cache_level);\r\nif (dev_priv->mm.gtt->needs_dmar) {\r\nBUG_ON(!obj->sg_list);\r\nintel_gtt_insert_sg_entries(obj->sg_list,\r\nobj->num_sg,\r\nobj->gtt_space->start >> PAGE_SHIFT,\r\nagp_type);\r\n} else\r\nintel_gtt_insert_pages(obj->gtt_space->start >> PAGE_SHIFT,\r\nobj->base.size >> PAGE_SHIFT,\r\nobj->pages,\r\nagp_type);\r\n}\r\nvoid i915_gem_gtt_unbind_object(struct drm_i915_gem_object *obj)\r\n{\r\nstruct drm_device *dev = obj->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nbool interruptible;\r\ninterruptible = do_idling(dev_priv);\r\nintel_gtt_clear_range(obj->gtt_space->start >> PAGE_SHIFT,\r\nobj->base.size >> PAGE_SHIFT);\r\nif (obj->sg_list) {\r\nintel_gtt_unmap_memory(obj->sg_list, obj->num_sg);\r\nobj->sg_list = NULL;\r\n}\r\nundo_idling(dev_priv, interruptible);\r\n}
