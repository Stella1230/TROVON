static inline void at32_wdt_stop(void)\r\n{\r\nunsigned long psel;\r\nspin_lock(&wdt->io_lock);\r\npsel = wdt_readl(wdt, CTRL) & WDT_BF(CTRL_PSEL, 0x0f);\r\nwdt_writel(wdt, CTRL, psel | WDT_BF(CTRL_KEY, 0x55));\r\nwdt_writel(wdt, CTRL, psel | WDT_BF(CTRL_KEY, 0xaa));\r\nspin_unlock(&wdt->io_lock);\r\n}\r\nstatic inline void at32_wdt_start(void)\r\n{\r\nunsigned long psel = (wdt->timeout > 1) ? 0xf : 0xe;\r\nspin_lock(&wdt->io_lock);\r\nwdt_writel(wdt, CTRL, WDT_BIT(CTRL_EN)\r\n| WDT_BF(CTRL_PSEL, psel)\r\n| WDT_BF(CTRL_KEY, 0x55));\r\nwdt_writel(wdt, CTRL, WDT_BIT(CTRL_EN)\r\n| WDT_BF(CTRL_PSEL, psel)\r\n| WDT_BF(CTRL_KEY, 0xaa));\r\nspin_unlock(&wdt->io_lock);\r\n}\r\nstatic inline void at32_wdt_pat(void)\r\n{\r\nspin_lock(&wdt->io_lock);\r\nwdt_writel(wdt, CLR, 0x42);\r\nspin_unlock(&wdt->io_lock);\r\n}\r\nstatic int at32_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(1, &wdt->users))\r\nreturn -EBUSY;\r\nat32_wdt_start();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int at32_wdt_close(struct inode *inode, struct file *file)\r\n{\r\nif (expect_release == 42) {\r\nat32_wdt_stop();\r\n} else {\r\ndev_dbg(wdt->miscdev.parent,\r\n"unexpected close, not stopping watchdog!\n");\r\nat32_wdt_pat();\r\n}\r\nclear_bit(1, &wdt->users);\r\nexpect_release = 0;\r\nreturn 0;\r\n}\r\nstatic int at32_wdt_settimeout(int time)\r\n{\r\nif ((time < TIMEOUT_MIN) || (time > TIMEOUT_MAX))\r\nreturn -EINVAL;\r\nwdt->timeout = time;\r\nreturn 0;\r\n}\r\nstatic int at32_wdt_get_status(void)\r\n{\r\nint rcause;\r\nint status = 0;\r\nrcause = wdt_readl(wdt, RCAUSE);\r\nswitch (rcause) {\r\ncase WDT_BIT(RCAUSE_EXT):\r\nstatus = WDIOF_EXTERN1;\r\nbreak;\r\ncase WDT_BIT(RCAUSE_WDT):\r\nstatus = WDIOF_CARDRESET;\r\nbreak;\r\ncase WDT_BIT(RCAUSE_POR):\r\ncase WDT_BIT(RCAUSE_JTAG):\r\ncase WDT_BIT(RCAUSE_SERP):\r\ndefault:\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic long at32_wdt_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint ret = -ENOTTY;\r\nint time;\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nret = copy_to_user(argp, &at32_wdt_info,\r\nsizeof(at32_wdt_info)) ? -EFAULT : 0;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\nret = put_user(0, p);\r\nbreak;\r\ncase WDIOC_GETBOOTSTATUS:\r\nret = put_user(wdt->boot_status, p);\r\nbreak;\r\ncase WDIOC_SETOPTIONS:\r\nret = get_user(time, p);\r\nif (ret)\r\nbreak;\r\nif (time & WDIOS_DISABLECARD)\r\nat32_wdt_stop();\r\nif (time & WDIOS_ENABLECARD)\r\nat32_wdt_start();\r\nret = 0;\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\nat32_wdt_pat();\r\nret = 0;\r\nbreak;\r\ncase WDIOC_SETTIMEOUT:\r\nret = get_user(time, p);\r\nif (ret)\r\nbreak;\r\nret = at32_wdt_settimeout(time);\r\nif (ret)\r\nbreak;\r\nat32_wdt_start();\r\ncase WDIOC_GETTIMEOUT:\r\nret = put_user(wdt->timeout, p);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t at32_wdt_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_release = 0;\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_release = 42;\r\n}\r\n}\r\nat32_wdt_pat();\r\n}\r\nreturn len;\r\n}\r\nstatic int __init at32_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *regs;\r\nint ret;\r\nif (wdt) {\r\ndev_dbg(&pdev->dev, "only 1 wdt instance supported.\n");\r\nreturn -EBUSY;\r\n}\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs) {\r\ndev_dbg(&pdev->dev, "missing mmio resource\n");\r\nreturn -ENXIO;\r\n}\r\nwdt = kzalloc(sizeof(struct wdt_at32ap700x), GFP_KERNEL);\r\nif (!wdt) {\r\ndev_dbg(&pdev->dev, "no memory for wdt structure\n");\r\nreturn -ENOMEM;\r\n}\r\nwdt->regs = ioremap(regs->start, resource_size(regs));\r\nif (!wdt->regs) {\r\nret = -ENOMEM;\r\ndev_dbg(&pdev->dev, "could not map I/O memory\n");\r\ngoto err_free;\r\n}\r\nspin_lock_init(&wdt->io_lock);\r\nwdt->boot_status = at32_wdt_get_status();\r\nif (wdt->boot_status & WDIOF_CARDRESET) {\r\ndev_info(&pdev->dev, "CPU must be reset with external "\r\n"reset or POR due to silicon errata.\n");\r\nret = -EIO;\r\ngoto err_iounmap;\r\n} else {\r\nwdt->users = 0;\r\n}\r\nwdt->miscdev.minor = WATCHDOG_MINOR;\r\nwdt->miscdev.name = "watchdog";\r\nwdt->miscdev.fops = &at32_wdt_fops;\r\nwdt->miscdev.parent = &pdev->dev;\r\nplatform_set_drvdata(pdev, wdt);\r\nif (at32_wdt_settimeout(timeout)) {\r\nat32_wdt_settimeout(TIMEOUT_DEFAULT);\r\ndev_dbg(&pdev->dev,\r\n"default timeout invalid, set to %d sec.\n",\r\nTIMEOUT_DEFAULT);\r\n}\r\nret = misc_register(&wdt->miscdev);\r\nif (ret) {\r\ndev_dbg(&pdev->dev, "failed to register wdt miscdev\n");\r\ngoto err_register;\r\n}\r\ndev_info(&pdev->dev,\r\n"AT32AP700X WDT at 0x%p, timeout %d sec (nowayout=%d)\n",\r\nwdt->regs, wdt->timeout, nowayout);\r\nreturn 0;\r\nerr_register:\r\nplatform_set_drvdata(pdev, NULL);\r\nerr_iounmap:\r\niounmap(wdt->regs);\r\nerr_free:\r\nkfree(wdt);\r\nwdt = NULL;\r\nreturn ret;\r\n}\r\nstatic int __exit at32_wdt_remove(struct platform_device *pdev)\r\n{\r\nif (wdt && platform_get_drvdata(pdev) == wdt) {\r\nif (!nowayout)\r\nat32_wdt_stop();\r\nmisc_deregister(&wdt->miscdev);\r\niounmap(wdt->regs);\r\nkfree(wdt);\r\nwdt = NULL;\r\nplatform_set_drvdata(pdev, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic void at32_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nat32_wdt_stop();\r\n}\r\nstatic int at32_wdt_suspend(struct platform_device *pdev, pm_message_t message)\r\n{\r\nat32_wdt_stop();\r\nreturn 0;\r\n}\r\nstatic int at32_wdt_resume(struct platform_device *pdev)\r\n{\r\nif (wdt->users)\r\nat32_wdt_start();\r\nreturn 0;\r\n}\r\nstatic int __init at32_wdt_init(void)\r\n{\r\nreturn platform_driver_probe(&at32_wdt_driver, at32_wdt_probe);\r\n}\r\nstatic void __exit at32_wdt_exit(void)\r\n{\r\nplatform_driver_unregister(&at32_wdt_driver);\r\n}
