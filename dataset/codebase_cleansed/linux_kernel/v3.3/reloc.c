rvalue dload_unpack(struct dload_state *dlthis, tgt_au_t * data, int fieldsz,\r\nint offset, unsigned sgn)\r\n{\r\nregister rvalue objval;\r\nregister int shift, direction;\r\nregister tgt_au_t *dp = data;\r\nfieldsz -= 1;\r\nif (TARGET_BIG_ENDIAN) {\r\ndp += (fieldsz + offset) >> LOG_TGTAU_BITS;\r\ndirection = -1;\r\n} else\r\ndirection = 1;\r\nobjval = *dp >> offset;\r\nshift = TGTAU_BITS - offset;\r\nwhile (shift <= fieldsz) {\r\ndp += direction;\r\nobjval += (rvalue) *dp << shift;\r\nshift += TGTAU_BITS;\r\n}\r\nif (sgn == ROP_UNS)\r\nobjval &= (2 << fieldsz) - 1;\r\nelse {\r\nshift = sizeof(rvalue) * BITS_PER_AU - 1 - fieldsz;\r\nobjval = (objval << shift) >> shift;\r\n}\r\nreturn objval;\r\n}\r\nint dload_repack(struct dload_state *dlthis, rvalue val, tgt_au_t * data,\r\nint fieldsz, int offset, unsigned sgn)\r\n{\r\nregister urvalue objval, mask;\r\nregister int shift, direction;\r\nregister tgt_au_t *dp = data;\r\nfieldsz -= 1;\r\nmask = (2UL << fieldsz) - 1;\r\nobjval = (val & mask);\r\nif (TARGET_BIG_ENDIAN) {\r\ndp += (fieldsz + offset) >> LOG_TGTAU_BITS;\r\ndirection = -1;\r\n} else\r\ndirection = 1;\r\n*dp = (*dp & ~(mask << offset)) + (objval << offset);\r\nshift = TGTAU_BITS - offset;\r\nobjval >>= shift;\r\nmask >>= shift;\r\nwhile (mask) {\r\ndp += direction;\r\n*dp = (*dp & ~mask) + objval;\r\nobjval >>= TGTAU_BITS;\r\nmask >>= TGTAU_BITS;\r\n}\r\nif (sgn) {\r\nunsigned tmp = (val >> fieldsz) + (sgn & 0x1);\r\nif (tmp > ovf_limit[sgn - 1])\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid dload_relocate(struct dload_state *dlthis, tgt_au_t * data,\r\nstruct reloc_record_t *rp, bool *tramps_generated,\r\nbool second_pass)\r\n{\r\nrvalue val, reloc_amt, orig_val = 0;\r\nunsigned int fieldsz = 0;\r\nunsigned int offset = 0;\r\nunsigned int reloc_info = 0;\r\nunsigned int reloc_action = 0;\r\nregister int rx = 0;\r\nrvalue *stackp = NULL;\r\nint top;\r\nstruct local_symbol *svp = NULL;\r\n#ifdef RFV_SCALE\r\nunsigned int scale = 0;\r\n#endif\r\nstruct image_packet_t *img_pkt = NULL;\r\nif (second_pass == false)\r\nimg_pkt = (struct image_packet_t *)((u8 *) data -\r\nsizeof(struct\r\nimage_packet_t));\r\nrx = HASH_FUNC(rp->TYPE);\r\nwhile (rop_map1[rx] != rp->TYPE) {\r\nrx = HASH_L(rop_map2[rx]);\r\nif (rx < 0) {\r\n#if TMS32060\r\nswitch (rp->TYPE) {\r\ncase R_C60ALIGN:\r\ncase R_C60NOCMP:\r\ncase R_C60FPHEAD:\r\nbreak;\r\ndefault:\r\ndload_error(dlthis, "Bad coff operator 0x%x",\r\nrp->TYPE);\r\n}\r\n#else\r\ndload_error(dlthis, "Bad coff operator 0x%x", rp->TYPE);\r\n#endif\r\nreturn;\r\n}\r\n}\r\nrx = HASH_I(rop_map2[rx]);\r\nif ((rx < (sizeof(rop_action) / sizeof(u16)))\r\n&& (rx < (sizeof(rop_info) / sizeof(u16))) && (rx > 0)) {\r\nreloc_action = rop_action[rx];\r\nreloc_info = rop_info[rx];\r\n} else {\r\ndload_error(dlthis, "Buffer Overflow - Array Index Out "\r\n"of Bounds");\r\n}\r\nreloc_amt = rp->UVAL;\r\nif (RFV_SYM(reloc_info)) {\r\nif (second_pass == false) {\r\nif ((u32) rp->SYMNDX < dlthis->dfile_hdr.df_no_syms) {\r\nsvp = &dlthis->local_symtab[rp->SYMNDX];\r\nreloc_amt = (RFV_SYM(reloc_info) == ROP_SYMD) ?\r\nsvp->delta : svp->value;\r\n}\r\nelse if (rp->SYMNDX == -1) {\r\nreloc_amt = (RFV_SYM(reloc_info) == ROP_SYMD) ?\r\ndlthis->delta_runaddr :\r\ndlthis->image_secn->run_addr;\r\n}\r\n}\r\n}\r\nval = 0;\r\ntop = RFV_STK(reloc_info);\r\nif (top) {\r\ntop += dlthis->relstkidx - RSTK_UOP;\r\nif (top >= STATIC_EXPR_STK_SIZE) {\r\ndload_error(dlthis,\r\n"Expression stack overflow in %s at offset "\r\nFMT_UI32, dlthis->image_secn->name,\r\nrp->vaddr + dlthis->image_offset);\r\nreturn;\r\n}\r\nval = dlthis->relstk[dlthis->relstkidx];\r\ndlthis->relstkidx = top;\r\nstackp = &dlthis->relstk[top];\r\n}\r\nif (reloc_info & ROP_RW) {\r\nfieldsz = RFV_WIDTH(reloc_action);\r\nif (fieldsz) {\r\noffset = RFV_POSN(reloc_action);\r\nif (TARGET_BIG_ENDIAN)\r\nrp->vaddr += RFV_BIGOFF(reloc_info);\r\n} else {\r\nfieldsz = rp->FIELDSZ;\r\noffset = rp->OFFSET;\r\nif (TARGET_BIG_ENDIAN)\r\nrp->vaddr += (rp->WORDSZ - offset - fieldsz)\r\n>> LOG_TARGET_AU_BITS;\r\n}\r\ndata = (tgt_au_t *) ((char *)data + TADDR_TO_HOST(rp->vaddr));\r\n#if BITS_PER_AU > TARGET_AU_BITS\r\nif (TARGET_BIG_ENDIAN) {\r\noffset += -((rp->vaddr << LOG_TARGET_AU_BITS) +\r\noffset + fieldsz) &\r\n(BITS_PER_AU - TARGET_AU_BITS);\r\n} else {\r\noffset += (rp->vaddr << LOG_TARGET_AU_BITS) &\r\n(BITS_PER_AU - 1);\r\n}\r\n#endif\r\n#ifdef RFV_SCALE\r\nscale = RFV_SCALE(reloc_info);\r\n#endif\r\n}\r\nif (reloc_info & ROP_R) {\r\nval = dload_unpack(dlthis, data, fieldsz, offset,\r\nRFV_SIGN(reloc_info));\r\norig_val = val;\r\n#ifdef RFV_SCALE\r\nval <<= scale;\r\n#endif\r\n}\r\nswitch (RFV_ACTION(reloc_action)) {\r\ncase RACT_VAL:\r\nbreak;\r\ncase RACT_ASGN:\r\nval = reloc_amt;\r\nbreak;\r\ncase RACT_ADD:\r\nval += reloc_amt;\r\nbreak;\r\ncase RACT_PCR:\r\nif (rp->SYMNDX == -1)\r\nreloc_amt = 0;\r\nval += reloc_amt - dlthis->delta_runaddr;\r\nbreak;\r\ncase RACT_ADDISP:\r\nval += rp->R_DISP + reloc_amt;\r\nbreak;\r\ncase RACT_ASGPC:\r\nval = dlthis->image_secn->run_addr + reloc_amt;\r\nbreak;\r\ncase RACT_PLUS:\r\nif (stackp != NULL)\r\nval += *stackp;\r\nbreak;\r\ncase RACT_SUB:\r\nif (stackp != NULL)\r\nval = *stackp - val;\r\nbreak;\r\ncase RACT_NEG:\r\nval = -val;\r\nbreak;\r\ncase RACT_MPY:\r\nif (stackp != NULL)\r\nval *= *stackp;\r\nbreak;\r\ncase RACT_DIV:\r\nif (stackp != NULL)\r\nval = *stackp / val;\r\nbreak;\r\ncase RACT_MOD:\r\nif (stackp != NULL)\r\nval = *stackp % val;\r\nbreak;\r\ncase RACT_SR:\r\nif (val >= sizeof(rvalue) * BITS_PER_AU)\r\nval = 0;\r\nelse if (stackp != NULL)\r\nval = (urvalue) *stackp >> val;\r\nbreak;\r\ncase RACT_ASR:\r\nif (val >= sizeof(rvalue) * BITS_PER_AU)\r\nval = sizeof(rvalue) * BITS_PER_AU - 1;\r\nelse if (stackp != NULL)\r\nval = *stackp >> val;\r\nbreak;\r\ncase RACT_SL:\r\nif (val >= sizeof(rvalue) * BITS_PER_AU)\r\nval = 0;\r\nelse if (stackp != NULL)\r\nval = *stackp << val;\r\nbreak;\r\ncase RACT_AND:\r\nif (stackp != NULL)\r\nval &= *stackp;\r\nbreak;\r\ncase RACT_OR:\r\nif (stackp != NULL)\r\nval |= *stackp;\r\nbreak;\r\ncase RACT_XOR:\r\nif (stackp != NULL)\r\nval ^= *stackp;\r\nbreak;\r\ncase RACT_NOT:\r\nval = ~val;\r\nbreak;\r\n#if TMS32060\r\ncase RACT_C6SECT:\r\nif (svp != NULL) {\r\nif (rp->SYMNDX >= 0)\r\nif (svp->secnn > 0)\r\nreloc_amt = dlthis->ldr_sections\r\n[svp->secnn - 1].run_addr;\r\n}\r\ncase RACT_C6BASE:\r\nif (dlthis->bss_run_base == 0) {\r\nstruct dynload_symbol *symp;\r\nsymp = dlthis->mysym->find_matching_symbol\r\n(dlthis->mysym, bsssymbol);\r\nif (symp)\r\ndlthis->bss_run_base = symp->value;\r\nelse\r\ndload_error(dlthis,\r\n"Global BSS base referenced in %s "\r\n"offset" FMT_UI32 " but not "\r\n"defined",\r\ndlthis->image_secn->name,\r\nrp->vaddr + dlthis->image_offset);\r\n}\r\nreloc_amt -= dlthis->bss_run_base;\r\ncase RACT_C6DSPL:\r\nscale = c60_scale[val & SCALE_MASK];\r\noffset += SCALE_BITS;\r\nfieldsz -= SCALE_BITS;\r\nval >>= SCALE_BITS;\r\nval <<= scale;\r\nval += reloc_amt;\r\nif (((1 << scale) - 1) & val)\r\ndload_error(dlthis,\r\n"Unaligned reference in %s offset "\r\nFMT_UI32, dlthis->image_secn->name,\r\nrp->vaddr + dlthis->image_offset);\r\nbreak;\r\n#endif\r\n}\r\nif (reloc_info & ROP_W) {\r\n#ifdef RFV_SCALE\r\nval >>= scale;\r\n#endif\r\nif (dload_repack(dlthis, val, data, fieldsz, offset,\r\nRFV_SIGN(reloc_info))) {\r\nif ((second_pass == false) &&\r\n(dload_tramp_avail(dlthis, rp) == true)) {\r\ndload_repack(dlthis, orig_val, data, fieldsz,\r\noffset, RFV_SIGN(reloc_info));\r\nif (!dload_tramp_generate(dlthis,\r\n(dlthis->image_secn -\r\ndlthis->ldr_sections),\r\ndlthis->image_offset,\r\nimg_pkt, rp)) {\r\ndload_error(dlthis,\r\n"Failed to "\r\n"generate trampoline for "\r\n"bit overflow");\r\ndload_error(dlthis,\r\n"Relocation val " FMT_UI32\r\n" overflows %d bits in %s "\r\n"offset " FMT_UI32, val,\r\nfieldsz,\r\ndlthis->image_secn->name,\r\ndlthis->image_offset +\r\nrp->vaddr);\r\n} else\r\n*tramps_generated = true;\r\n} else {\r\ndload_error(dlthis, "Relocation value "\r\nFMT_UI32 " overflows %d bits in %s"\r\n" offset " FMT_UI32, val, fieldsz,\r\ndlthis->image_secn->name,\r\ndlthis->image_offset + rp->vaddr);\r\n}\r\n}\r\n} else if (top)\r\n*stackp = val;\r\n}
