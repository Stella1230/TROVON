static struct tw9910_priv *to_tw9910(const struct i2c_client *client)\r\n{\r\nreturn container_of(i2c_get_clientdata(client), struct tw9910_priv,\r\nsubdev);\r\n}\r\nstatic int tw9910_mask_set(struct i2c_client *client, u8 command,\r\nu8 mask, u8 set)\r\n{\r\ns32 val = i2c_smbus_read_byte_data(client, command);\r\nif (val < 0)\r\nreturn val;\r\nval &= ~mask;\r\nval |= set & mask;\r\nreturn i2c_smbus_write_byte_data(client, command, val);\r\n}\r\nstatic int tw9910_set_scale(struct i2c_client *client,\r\nconst struct tw9910_scale_ctrl *scale)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, SCALE_HI,\r\n(scale->vscale & 0x0F00) >> 4 |\r\n(scale->hscale & 0x0F00) >> 8);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, HSCALE_LO,\r\nscale->hscale & 0x00FF);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, VSCALE_LO,\r\nscale->vscale & 0x00FF);\r\nreturn ret;\r\n}\r\nstatic int tw9910_set_hsync(struct i2c_client *client)\r\n{\r\nstruct tw9910_priv *priv = to_tw9910(client);\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, HSBEGIN,\r\n(HSYNC_START & 0x07F8) >> 3);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, HSEND,\r\n(HSYNC_END & 0x07F8) >> 3);\r\nif (ret < 0)\r\nreturn ret;\r\nif (1 == priv->revision)\r\nret = tw9910_mask_set(client, HSLOWCTL, 0x77,\r\n(HSYNC_START & 0x0007) << 4 |\r\n(HSYNC_END & 0x0007));\r\nreturn ret;\r\n}\r\nstatic void tw9910_reset(struct i2c_client *client)\r\n{\r\ntw9910_mask_set(client, ACNTL1, SRESET, SRESET);\r\nmsleep(1);\r\n}\r\nstatic int tw9910_power(struct i2c_client *client, int enable)\r\n{\r\nint ret;\r\nu8 acntl1;\r\nu8 acntl2;\r\nif (enable) {\r\nacntl1 = 0;\r\nacntl2 = 0;\r\n} else {\r\nacntl1 = CLK_PDN | Y_PDN | C_PDN;\r\nacntl2 = PLL_PDN;\r\n}\r\nret = tw9910_mask_set(client, ACNTL1, ACNTL1_PDN_MASK, acntl1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn tw9910_mask_set(client, ACNTL2, ACNTL2_PDN_MASK, acntl2);\r\n}\r\nstatic const struct tw9910_scale_ctrl *tw9910_select_norm(v4l2_std_id norm,\r\nu32 width, u32 height)\r\n{\r\nconst struct tw9910_scale_ctrl *scale;\r\nconst struct tw9910_scale_ctrl *ret = NULL;\r\n__u32 diff = 0xffffffff, tmp;\r\nint size, i;\r\nif (norm & V4L2_STD_NTSC) {\r\nscale = tw9910_ntsc_scales;\r\nsize = ARRAY_SIZE(tw9910_ntsc_scales);\r\n} else if (norm & V4L2_STD_PAL) {\r\nscale = tw9910_pal_scales;\r\nsize = ARRAY_SIZE(tw9910_pal_scales);\r\n} else {\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < size; i++) {\r\ntmp = abs(width - scale[i].width) +\r\nabs(height - scale[i].height);\r\nif (tmp < diff) {\r\ndiff = tmp;\r\nret = scale + i;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int tw9910_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct tw9910_priv *priv = to_tw9910(client);\r\nu8 val;\r\nint ret;\r\nif (!enable) {\r\nswitch (priv->revision) {\r\ncase 0:\r\nval = OEN_TRI_SEL_ALL_OFF_r0;\r\nbreak;\r\ncase 1:\r\nval = OEN_TRI_SEL_ALL_OFF_r1;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "un-supported revision\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nval = OEN_TRI_SEL_ALL_ON;\r\nif (!priv->scale) {\r\ndev_err(&client->dev, "norm select error\n");\r\nreturn -EPERM;\r\n}\r\ndev_dbg(&client->dev, "%s %dx%d\n",\r\npriv->scale->name,\r\npriv->scale->width,\r\npriv->scale->height);\r\n}\r\nret = tw9910_mask_set(client, OPFORM, OEN_TRI_SEL_MASK, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn tw9910_power(client, enable);\r\n}\r\nstatic int tw9910_g_std(struct v4l2_subdev *sd, v4l2_std_id *norm)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct tw9910_priv *priv = to_tw9910(client);\r\n*norm = priv->norm;\r\nreturn 0;\r\n}\r\nstatic int tw9910_s_std(struct v4l2_subdev *sd, v4l2_std_id norm)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct tw9910_priv *priv = to_tw9910(client);\r\nif (!(norm & (V4L2_STD_NTSC | V4L2_STD_PAL)))\r\nreturn -EINVAL;\r\npriv->norm = norm;\r\nreturn 0;\r\n}\r\nstatic int tw9910_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *id)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct tw9910_priv *priv = to_tw9910(client);\r\nid->ident = V4L2_IDENT_TW9910;\r\nid->revision = priv->revision;\r\nreturn 0;\r\n}\r\nstatic int tw9910_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nif (reg->reg > 0xff)\r\nreturn -EINVAL;\r\nret = i2c_smbus_read_byte_data(client, reg->reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreg->val = (__u64)ret;\r\nreturn 0;\r\n}\r\nstatic int tw9910_s_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->reg > 0xff ||\r\nreg->val > 0xff)\r\nreturn -EINVAL;\r\nreturn i2c_smbus_write_byte_data(client, reg->reg, reg->val);\r\n}\r\nstatic int tw9910_set_frame(struct v4l2_subdev *sd, u32 *width, u32 *height)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct tw9910_priv *priv = to_tw9910(client);\r\nint ret = -EINVAL;\r\nu8 val;\r\npriv->scale = tw9910_select_norm(priv->norm, *width, *height);\r\nif (!priv->scale)\r\ngoto tw9910_set_fmt_error;\r\ntw9910_reset(client);\r\nval = 0x00;\r\nif (SOCAM_DATAWIDTH_16 == priv->info->buswidth)\r\nval = LEN;\r\nret = tw9910_mask_set(client, OPFORM, LEN, val);\r\nif (ret < 0)\r\ngoto tw9910_set_fmt_error;\r\nswitch (priv->info->mpout) {\r\ncase TW9910_MPO_VLOSS:\r\nval = RTSEL_VLOSS; break;\r\ncase TW9910_MPO_HLOCK:\r\nval = RTSEL_HLOCK; break;\r\ncase TW9910_MPO_SLOCK:\r\nval = RTSEL_SLOCK; break;\r\ncase TW9910_MPO_VLOCK:\r\nval = RTSEL_VLOCK; break;\r\ncase TW9910_MPO_MONO:\r\nval = RTSEL_MONO; break;\r\ncase TW9910_MPO_DET50:\r\nval = RTSEL_DET50; break;\r\ncase TW9910_MPO_FIELD:\r\nval = RTSEL_FIELD; break;\r\ncase TW9910_MPO_RTCO:\r\nval = RTSEL_RTCO; break;\r\ndefault:\r\nval = 0;\r\n}\r\nret = tw9910_mask_set(client, VBICNTL, RTSEL_MASK, val);\r\nif (ret < 0)\r\ngoto tw9910_set_fmt_error;\r\nret = tw9910_set_scale(client, priv->scale);\r\nif (ret < 0)\r\ngoto tw9910_set_fmt_error;\r\nret = tw9910_set_hsync(client);\r\nif (ret < 0)\r\ngoto tw9910_set_fmt_error;\r\n*width = priv->scale->width;\r\n*height = priv->scale->height;\r\nreturn ret;\r\ntw9910_set_fmt_error:\r\ntw9910_reset(client);\r\npriv->scale = NULL;\r\nreturn ret;\r\n}\r\nstatic int tw9910_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct tw9910_priv *priv = to_tw9910(client);\r\na->c.left = 0;\r\na->c.top = 0;\r\nif (priv->norm & V4L2_STD_NTSC) {\r\na->c.width = 640;\r\na->c.height = 480;\r\n} else {\r\na->c.width = 768;\r\na->c.height = 576;\r\n}\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic int tw9910_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct tw9910_priv *priv = to_tw9910(client);\r\na->bounds.left = 0;\r\na->bounds.top = 0;\r\nif (priv->norm & V4L2_STD_NTSC) {\r\na->bounds.width = 640;\r\na->bounds.height = 480;\r\n} else {\r\na->bounds.width = 768;\r\na->bounds.height = 576;\r\n}\r\na->defrect = a->bounds;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\na->pixelaspect.numerator = 1;\r\na->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int tw9910_g_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct tw9910_priv *priv = to_tw9910(client);\r\nif (!priv->scale) {\r\nint ret;\r\nu32 width = 640, height = 480;\r\nret = tw9910_set_frame(sd, &width, &height);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nmf->width = priv->scale->width;\r\nmf->height = priv->scale->height;\r\nmf->code = V4L2_MBUS_FMT_UYVY8_2X8;\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\nmf->field = V4L2_FIELD_INTERLACED_BT;\r\nreturn 0;\r\n}\r\nstatic int tw9910_s_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nu32 width = mf->width, height = mf->height;\r\nint ret;\r\nWARN_ON(mf->field != V4L2_FIELD_ANY &&\r\nmf->field != V4L2_FIELD_INTERLACED_BT);\r\nif (mf->code != V4L2_MBUS_FMT_UYVY8_2X8)\r\nreturn -EINVAL;\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\nret = tw9910_set_frame(sd, &width, &height);\r\nif (!ret) {\r\nmf->width = width;\r\nmf->height = height;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tw9910_try_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct tw9910_priv *priv = to_tw9910(client);\r\nconst struct tw9910_scale_ctrl *scale;\r\nif (V4L2_FIELD_ANY == mf->field) {\r\nmf->field = V4L2_FIELD_INTERLACED_BT;\r\n} else if (V4L2_FIELD_INTERLACED_BT != mf->field) {\r\ndev_err(&client->dev, "Field type %d invalid.\n", mf->field);\r\nreturn -EINVAL;\r\n}\r\nmf->code = V4L2_MBUS_FMT_UYVY8_2X8;\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\nscale = tw9910_select_norm(priv->norm, mf->width, mf->height);\r\nif (!scale)\r\nreturn -EINVAL;\r\nmf->width = scale->width;\r\nmf->height = scale->height;\r\nreturn 0;\r\n}\r\nstatic int tw9910_video_probe(struct i2c_client *client)\r\n{\r\nstruct tw9910_priv *priv = to_tw9910(client);\r\ns32 id;\r\nif (SOCAM_DATAWIDTH_16 != priv->info->buswidth &&\r\nSOCAM_DATAWIDTH_8 != priv->info->buswidth) {\r\ndev_err(&client->dev, "bus width error\n");\r\nreturn -ENODEV;\r\n}\r\nid = i2c_smbus_read_byte_data(client, ID);\r\npriv->revision = GET_REV(id);\r\nid = GET_ID(id);\r\nif (0x0B != id ||\r\n0x01 < priv->revision) {\r\ndev_err(&client->dev,\r\n"Product ID error %x:%x\n",\r\nid, priv->revision);\r\nreturn -ENODEV;\r\n}\r\ndev_info(&client->dev,\r\n"tw9910 Product ID %0x:%0x\n", id, priv->revision);\r\npriv->norm = V4L2_STD_NTSC;\r\nreturn 0;\r\n}\r\nstatic int tw9910_enum_fmt(struct v4l2_subdev *sd, unsigned int index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index)\r\nreturn -EINVAL;\r\n*code = V4L2_MBUS_FMT_UYVY8_2X8;\r\nreturn 0;\r\n}\r\nstatic int tw9910_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\ncfg->flags = V4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_MASTER |\r\nV4L2_MBUS_VSYNC_ACTIVE_HIGH | V4L2_MBUS_VSYNC_ACTIVE_LOW |\r\nV4L2_MBUS_HSYNC_ACTIVE_HIGH | V4L2_MBUS_HSYNC_ACTIVE_LOW |\r\nV4L2_MBUS_DATA_ACTIVE_HIGH;\r\ncfg->type = V4L2_MBUS_PARALLEL;\r\ncfg->flags = soc_camera_apply_board_flags(icl, cfg);\r\nreturn 0;\r\n}\r\nstatic int tw9910_s_mbus_config(struct v4l2_subdev *sd,\r\nconst struct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nu8 val = VSSL_VVALID | HSSL_DVALID;\r\nunsigned long flags = soc_camera_apply_board_flags(icl, cfg);\r\nif (flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\r\nval |= HSP_HI;\r\nif (flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\r\nval |= VSP_HI;\r\nreturn i2c_smbus_write_byte_data(client, OUTCTR1, val);\r\n}\r\nstatic int tw9910_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct tw9910_priv *priv;\r\nstruct tw9910_video_info *info;\r\nstruct i2c_adapter *adapter =\r\nto_i2c_adapter(client->dev.parent);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nint ret;\r\nif (!icl || !icl->priv) {\r\ndev_err(&client->dev, "TW9910: missing platform data!\n");\r\nreturn -EINVAL;\r\n}\r\ninfo = icl->priv;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&client->dev,\r\n"I2C-Adapter doesn't support "\r\n"I2C_FUNC_SMBUS_BYTE_DATA\n");\r\nreturn -EIO;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->info = info;\r\nv4l2_i2c_subdev_init(&priv->subdev, client, &tw9910_subdev_ops);\r\nret = tw9910_video_probe(client);\r\nif (ret)\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nstatic int tw9910_remove(struct i2c_client *client)\r\n{\r\nstruct tw9910_priv *priv = to_tw9910(client);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int __init tw9910_module_init(void)\r\n{\r\nreturn i2c_add_driver(&tw9910_i2c_driver);\r\n}\r\nstatic void __exit tw9910_module_exit(void)\r\n{\r\ni2c_del_driver(&tw9910_i2c_driver);\r\n}
