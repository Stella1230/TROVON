void kvp_get_os_info(void)\r\n{\r\nFILE *file;\r\nchar *p, buf[512];\r\nuname(&uts_buf);\r\nos_build = uts_buf.release;\r\nprocessor_arch = uts_buf.machine;\r\np = strchr(os_build, '-');\r\nif (p)\r\n*p = '\0';\r\nfile = fopen("/etc/SuSE-release", "r");\r\nif (file != NULL)\r\ngoto kvp_osinfo_found;\r\nfile = fopen("/etc/redhat-release", "r");\r\nif (file != NULL)\r\ngoto kvp_osinfo_found;\r\nos_name = uts_buf.sysname;\r\nreturn;\r\nkvp_osinfo_found:\r\np = fgets(buf, sizeof(buf), file);\r\nif (p) {\r\np = strchr(buf, '\n');\r\nif (p)\r\n*p = '\0';\r\np = strdup(buf);\r\nif (!p)\r\ngoto done;\r\nos_name = p;\r\np = fgets(buf, sizeof(buf), file);\r\nif (p) {\r\np = strchr(buf, '\n');\r\nif (p)\r\n*p = '\0';\r\np = strdup(buf);\r\nif (!p)\r\ngoto done;\r\nos_major = p;\r\np = fgets(buf, sizeof(buf), file);\r\nif (p) {\r\np = strchr(buf, '\n');\r\nif (p)\r\n*p = '\0';\r\np = strdup(buf);\r\nif (p)\r\nos_minor = p;\r\n}\r\n}\r\n}\r\ndone:\r\nfclose(file);\r\nreturn;\r\n}\r\nstatic int\r\nkvp_get_ip_address(int family, char *buffer, int length)\r\n{\r\nstruct ifaddrs *ifap;\r\nstruct ifaddrs *curp;\r\nint ipv4_len = strlen("255.255.255.255") + 1;\r\nint ipv6_len = strlen("ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff")+1;\r\nint offset = 0;\r\nconst char *str;\r\nchar tmp[50];\r\nint error = 0;\r\nif (getifaddrs(&ifap)) {\r\nstrcpy(buffer, "getifaddrs failed\n");\r\nreturn 1;\r\n}\r\ncurp = ifap;\r\nwhile (curp != NULL) {\r\nif ((curp->ifa_addr != NULL) &&\r\n(curp->ifa_addr->sa_family == family)) {\r\nif (family == AF_INET) {\r\nstruct sockaddr_in *addr =\r\n(struct sockaddr_in *) curp->ifa_addr;\r\nstr = inet_ntop(family, &addr->sin_addr,\r\ntmp, 50);\r\nif (str == NULL) {\r\nstrcpy(buffer, "inet_ntop failed\n");\r\nerror = 1;\r\ngoto getaddr_done;\r\n}\r\nif (offset == 0)\r\nstrcpy(buffer, tmp);\r\nelse\r\nstrcat(buffer, tmp);\r\nstrcat(buffer, ";");\r\noffset += strlen(str) + 1;\r\nif ((length - offset) < (ipv4_len + 1))\r\ngoto getaddr_done;\r\n} else {\r\nstruct sockaddr_in6 *addr =\r\n(struct sockaddr_in6 *) curp->ifa_addr;\r\nstr = inet_ntop(family,\r\n&addr->sin6_addr.s6_addr,\r\ntmp, 50);\r\nif (str == NULL) {\r\nstrcpy(buffer, "inet_ntop failed\n");\r\nerror = 1;\r\ngoto getaddr_done;\r\n}\r\nif (offset == 0)\r\nstrcpy(buffer, tmp);\r\nelse\r\nstrcat(buffer, tmp);\r\nstrcat(buffer, ";");\r\noffset += strlen(str) + 1;\r\nif ((length - offset) < (ipv6_len + 1))\r\ngoto getaddr_done;\r\n}\r\n}\r\ncurp = curp->ifa_next;\r\n}\r\ngetaddr_done:\r\nfreeifaddrs(ifap);\r\nreturn error;\r\n}\r\nstatic int\r\nkvp_get_domain_name(char *buffer, int length)\r\n{\r\nstruct addrinfo hints, *info ;\r\nint error = 0;\r\ngethostname(buffer, length);\r\nmemset(&hints, 0, sizeof(hints));\r\nhints.ai_family = AF_INET;\r\nhints.ai_socktype = SOCK_STREAM;\r\nhints.ai_flags = AI_CANONNAME;\r\nerror = getaddrinfo(buffer, NULL, &hints, &info);\r\nif (error != 0) {\r\nstrcpy(buffer, "getaddrinfo failed\n");\r\nreturn error;\r\n}\r\nstrcpy(buffer, info->ai_canonname);\r\nfreeaddrinfo(info);\r\nreturn error;\r\n}\r\nstatic int\r\nnetlink_send(int fd, struct cn_msg *msg)\r\n{\r\nstruct nlmsghdr *nlh;\r\nunsigned int size;\r\nstruct msghdr message;\r\nchar buffer[64];\r\nstruct iovec iov[2];\r\nsize = NLMSG_SPACE(sizeof(struct cn_msg) + msg->len);\r\nnlh = (struct nlmsghdr *)buffer;\r\nnlh->nlmsg_seq = 0;\r\nnlh->nlmsg_pid = getpid();\r\nnlh->nlmsg_type = NLMSG_DONE;\r\nnlh->nlmsg_len = NLMSG_LENGTH(size - sizeof(*nlh));\r\nnlh->nlmsg_flags = 0;\r\niov[0].iov_base = nlh;\r\niov[0].iov_len = sizeof(*nlh);\r\niov[1].iov_base = msg;\r\niov[1].iov_len = size;\r\nmemset(&message, 0, sizeof(message));\r\nmessage.msg_name = &addr;\r\nmessage.msg_namelen = sizeof(addr);\r\nmessage.msg_iov = iov;\r\nmessage.msg_iovlen = 2;\r\nreturn sendmsg(fd, &message, 0);\r\n}\r\nint main(void)\r\n{\r\nint fd, len, sock_opt;\r\nint error;\r\nstruct cn_msg *message;\r\nstruct pollfd pfd;\r\nstruct nlmsghdr *incoming_msg;\r\nstruct cn_msg *incoming_cn_msg;\r\nstruct hv_ku_msg *hv_msg;\r\nchar *p;\r\nchar *key_value;\r\nchar *key_name;\r\ndaemon(1, 0);\r\nopenlog("KVP", 0, LOG_USER);\r\nsyslog(LOG_INFO, "KVP starting; pid is:%d", getpid());\r\nkvp_get_os_info();\r\nfd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);\r\nif (fd < 0) {\r\nsyslog(LOG_ERR, "netlink socket creation failed; error:%d", fd);\r\nexit(-1);\r\n}\r\naddr.nl_family = AF_NETLINK;\r\naddr.nl_pad = 0;\r\naddr.nl_pid = 0;\r\naddr.nl_groups = CN_KVP_IDX;\r\nerror = bind(fd, (struct sockaddr *)&addr, sizeof(addr));\r\nif (error < 0) {\r\nsyslog(LOG_ERR, "bind failed; error:%d", error);\r\nclose(fd);\r\nexit(-1);\r\n}\r\nsock_opt = addr.nl_groups;\r\nsetsockopt(fd, 270, 1, &sock_opt, sizeof(sock_opt));\r\nmessage = (struct cn_msg *)kvp_send_buffer;\r\nmessage->id.idx = CN_KVP_IDX;\r\nmessage->id.val = CN_KVP_VAL;\r\nmessage->seq = KVP_REGISTER;\r\nmessage->ack = 0;\r\nmessage->len = 0;\r\nlen = netlink_send(fd, message);\r\nif (len < 0) {\r\nsyslog(LOG_ERR, "netlink_send failed; error:%d", len);\r\nclose(fd);\r\nexit(-1);\r\n}\r\npfd.fd = fd;\r\nwhile (1) {\r\npfd.events = POLLIN;\r\npfd.revents = 0;\r\npoll(&pfd, 1, -1);\r\nlen = recv(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0);\r\nif (len < 0) {\r\nsyslog(LOG_ERR, "recv failed; error:%d", len);\r\nclose(fd);\r\nreturn -1;\r\n}\r\nincoming_msg = (struct nlmsghdr *)kvp_recv_buffer;\r\nincoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg);\r\nswitch (incoming_cn_msg->seq) {\r\ncase KVP_REGISTER:\r\np = (char *)incoming_cn_msg->data;\r\nlic_version = malloc(strlen(p) + 1);\r\nif (lic_version) {\r\nstrcpy(lic_version, p);\r\nsyslog(LOG_INFO, "KVP LIC Version: %s",\r\nlic_version);\r\n} else {\r\nsyslog(LOG_ERR, "malloc failed");\r\n}\r\ncontinue;\r\ncase KVP_KERNEL_GET:\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nhv_msg = (struct hv_ku_msg *)incoming_cn_msg->data;\r\nkey_name = (char *)hv_msg->kvp_key;\r\nkey_value = (char *)hv_msg->kvp_value;\r\nswitch (hv_msg->kvp_index) {\r\ncase FullyQualifiedDomainName:\r\nkvp_get_domain_name(key_value,\r\nHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\r\nstrcpy(key_name, "FullyQualifiedDomainName");\r\nbreak;\r\ncase IntegrationServicesVersion:\r\nstrcpy(key_name, "IntegrationServicesVersion");\r\nstrcpy(key_value, lic_version);\r\nbreak;\r\ncase NetworkAddressIPv4:\r\nkvp_get_ip_address(AF_INET, key_value,\r\nHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\r\nstrcpy(key_name, "NetworkAddressIPv4");\r\nbreak;\r\ncase NetworkAddressIPv6:\r\nkvp_get_ip_address(AF_INET6, key_value,\r\nHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\r\nstrcpy(key_name, "NetworkAddressIPv6");\r\nbreak;\r\ncase OSBuildNumber:\r\nstrcpy(key_value, os_build);\r\nstrcpy(key_name, "OSBuildNumber");\r\nbreak;\r\ncase OSName:\r\nstrcpy(key_value, os_name);\r\nstrcpy(key_name, "OSName");\r\nbreak;\r\ncase OSMajorVersion:\r\nstrcpy(key_value, os_major);\r\nstrcpy(key_name, "OSMajorVersion");\r\nbreak;\r\ncase OSMinorVersion:\r\nstrcpy(key_value, os_minor);\r\nstrcpy(key_name, "OSMinorVersion");\r\nbreak;\r\ncase OSVersion:\r\nstrcpy(key_value, os_build);\r\nstrcpy(key_name, "OSVersion");\r\nbreak;\r\ncase ProcessorArchitecture:\r\nstrcpy(key_value, processor_arch);\r\nstrcpy(key_name, "ProcessorArchitecture");\r\nbreak;\r\ndefault:\r\nstrcpy(key_value, "Unknown Key");\r\nstrcpy(key_name, "");\r\nbreak;\r\n}\r\nincoming_cn_msg->id.idx = CN_KVP_IDX;\r\nincoming_cn_msg->id.val = CN_KVP_VAL;\r\nincoming_cn_msg->seq = KVP_USER_SET;\r\nincoming_cn_msg->ack = 0;\r\nincoming_cn_msg->len = sizeof(struct hv_ku_msg);\r\nlen = netlink_send(fd, incoming_cn_msg);\r\nif (len < 0) {\r\nsyslog(LOG_ERR, "net_link send failed; error:%d", len);\r\nexit(-1);\r\n}\r\n}\r\n}
