static inline bool\r\nhash_ipport4_data_equal(const struct hash_ipport4_elem *ip1,\r\nconst struct hash_ipport4_elem *ip2,\r\nu32 *multi)\r\n{\r\nreturn ip1->ip == ip2->ip &&\r\nip1->port == ip2->port &&\r\nip1->proto == ip2->proto;\r\n}\r\nstatic inline bool\r\nhash_ipport4_data_isnull(const struct hash_ipport4_elem *elem)\r\n{\r\nreturn elem->proto == 0;\r\n}\r\nstatic inline void\r\nhash_ipport4_data_copy(struct hash_ipport4_elem *dst,\r\nconst struct hash_ipport4_elem *src)\r\n{\r\ndst->ip = src->ip;\r\ndst->port = src->port;\r\ndst->proto = src->proto;\r\n}\r\nstatic inline void\r\nhash_ipport4_data_zero_out(struct hash_ipport4_elem *elem)\r\n{\r\nelem->proto = 0;\r\n}\r\nstatic bool\r\nhash_ipport4_data_list(struct sk_buff *skb,\r\nconst struct hash_ipport4_elem *data)\r\n{\r\nNLA_PUT_IPADDR4(skb, IPSET_ATTR_IP, data->ip);\r\nNLA_PUT_NET16(skb, IPSET_ATTR_PORT, data->port);\r\nNLA_PUT_U8(skb, IPSET_ATTR_PROTO, data->proto);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn 1;\r\n}\r\nstatic bool\r\nhash_ipport4_data_tlist(struct sk_buff *skb,\r\nconst struct hash_ipport4_elem *data)\r\n{\r\nconst struct hash_ipport4_telem *tdata =\r\n(const struct hash_ipport4_telem *)data;\r\nNLA_PUT_IPADDR4(skb, IPSET_ATTR_IP, tdata->ip);\r\nNLA_PUT_NET16(skb, IPSET_ATTR_PORT, tdata->port);\r\nNLA_PUT_U8(skb, IPSET_ATTR_PROTO, data->proto);\r\nNLA_PUT_NET32(skb, IPSET_ATTR_TIMEOUT,\r\nhtonl(ip_set_timeout_get(tdata->timeout)));\r\nreturn 0;\r\nnla_put_failure:\r\nreturn 1;\r\n}\r\nstatic inline void\r\nhash_ipport4_data_next(struct ip_set_hash *h,\r\nconst struct hash_ipport4_elem *d)\r\n{\r\nh->next.ip = ntohl(d->ip);\r\nh->next.port = ntohs(d->port);\r\n}\r\nstatic int\r\nhash_ipport4_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, const struct ip_set_adt_opt *opt)\r\n{\r\nconst struct ip_set_hash *h = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_ipport4_elem data = { };\r\nif (!ip_set_get_ip4_port(skb, opt->flags & IPSET_DIM_TWO_SRC,\r\n&data.port, &data.proto))\r\nreturn -EINVAL;\r\nip4addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &data.ip);\r\nreturn adtfn(set, &data, opt_timeout(opt, h), opt->cmdflags);\r\n}\r\nstatic int\r\nhash_ipport4_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nconst struct ip_set_hash *h = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_ipport4_elem data = { };\r\nu32 ip, ip_to = 0, p = 0, port, port_to;\r\nu32 timeout = h->timeout;\r\nbool with_ports = false;\r\nint ret;\r\nif (unlikely(!tb[IPSET_ATTR_IP] ||\r\n!ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_PORT_TO) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nret = ip_set_get_ipaddr4(tb[IPSET_ATTR_IP], &data.ip);\r\nif (ret)\r\nreturn ret;\r\nif (tb[IPSET_ATTR_PORT])\r\ndata.port = nla_get_be16(tb[IPSET_ATTR_PORT]);\r\nelse\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_PROTO]) {\r\ndata.proto = nla_get_u8(tb[IPSET_ATTR_PROTO]);\r\nwith_ports = ip_set_proto_with_ports(data.proto);\r\nif (data.proto == 0)\r\nreturn -IPSET_ERR_INVALID_PROTO;\r\n} else\r\nreturn -IPSET_ERR_MISSING_PROTO;\r\nif (!(with_ports || data.proto == IPPROTO_ICMP))\r\ndata.port = 0;\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nif (!with_timeout(h->timeout))\r\nreturn -IPSET_ERR_TIMEOUT;\r\ntimeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\n}\r\nif (adt == IPSET_TEST ||\r\n!(tb[IPSET_ATTR_IP_TO] || tb[IPSET_ATTR_CIDR] ||\r\ntb[IPSET_ATTR_PORT_TO])) {\r\nret = adtfn(set, &data, timeout, flags);\r\nreturn ip_set_eexist(ret, flags) ? 0 : ret;\r\n}\r\nip = ntohl(data.ip);\r\nif (tb[IPSET_ATTR_IP_TO]) {\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &ip_to);\r\nif (ret)\r\nreturn ret;\r\nif (ip > ip_to)\r\nswap(ip, ip_to);\r\n} else if (tb[IPSET_ATTR_CIDR]) {\r\nu8 cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);\r\nif (cidr > 32)\r\nreturn -IPSET_ERR_INVALID_CIDR;\r\nip_set_mask_from_to(ip, ip_to, cidr);\r\n} else\r\nip_to = ip;\r\nport_to = port = ntohs(data.port);\r\nif (with_ports && tb[IPSET_ATTR_PORT_TO]) {\r\nport_to = ip_set_get_h16(tb[IPSET_ATTR_PORT_TO]);\r\nif (port > port_to)\r\nswap(port, port_to);\r\n}\r\nif (retried)\r\nip = h->next.ip;\r\nfor (; !before(ip_to, ip); ip++) {\r\np = retried && ip == h->next.ip ? h->next.port : port;\r\nfor (; p <= port_to; p++) {\r\ndata.ip = htonl(ip);\r\ndata.port = htons(p);\r\nret = adtfn(set, &data, timeout, flags);\r\nif (ret && !ip_set_eexist(ret, flags))\r\nreturn ret;\r\nelse\r\nret = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic bool\r\nhash_ipport_same_set(const struct ip_set *a, const struct ip_set *b)\r\n{\r\nconst struct ip_set_hash *x = a->data;\r\nconst struct ip_set_hash *y = b->data;\r\nreturn x->maxelem == y->maxelem &&\r\nx->timeout == y->timeout;\r\n}\r\nstatic inline bool\r\nhash_ipport6_data_equal(const struct hash_ipport6_elem *ip1,\r\nconst struct hash_ipport6_elem *ip2,\r\nu32 *multi)\r\n{\r\nreturn ipv6_addr_cmp(&ip1->ip.in6, &ip2->ip.in6) == 0 &&\r\nip1->port == ip2->port &&\r\nip1->proto == ip2->proto;\r\n}\r\nstatic inline bool\r\nhash_ipport6_data_isnull(const struct hash_ipport6_elem *elem)\r\n{\r\nreturn elem->proto == 0;\r\n}\r\nstatic inline void\r\nhash_ipport6_data_copy(struct hash_ipport6_elem *dst,\r\nconst struct hash_ipport6_elem *src)\r\n{\r\nmemcpy(dst, src, sizeof(*dst));\r\n}\r\nstatic inline void\r\nhash_ipport6_data_zero_out(struct hash_ipport6_elem *elem)\r\n{\r\nelem->proto = 0;\r\n}\r\nstatic bool\r\nhash_ipport6_data_list(struct sk_buff *skb,\r\nconst struct hash_ipport6_elem *data)\r\n{\r\nNLA_PUT_IPADDR6(skb, IPSET_ATTR_IP, &data->ip);\r\nNLA_PUT_NET16(skb, IPSET_ATTR_PORT, data->port);\r\nNLA_PUT_U8(skb, IPSET_ATTR_PROTO, data->proto);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn 1;\r\n}\r\nstatic bool\r\nhash_ipport6_data_tlist(struct sk_buff *skb,\r\nconst struct hash_ipport6_elem *data)\r\n{\r\nconst struct hash_ipport6_telem *e =\r\n(const struct hash_ipport6_telem *)data;\r\nNLA_PUT_IPADDR6(skb, IPSET_ATTR_IP, &e->ip);\r\nNLA_PUT_NET16(skb, IPSET_ATTR_PORT, data->port);\r\nNLA_PUT_U8(skb, IPSET_ATTR_PROTO, data->proto);\r\nNLA_PUT_NET32(skb, IPSET_ATTR_TIMEOUT,\r\nhtonl(ip_set_timeout_get(e->timeout)));\r\nreturn 0;\r\nnla_put_failure:\r\nreturn 1;\r\n}\r\nstatic inline void\r\nhash_ipport6_data_next(struct ip_set_hash *h,\r\nconst struct hash_ipport6_elem *d)\r\n{\r\nh->next.port = ntohs(d->port);\r\n}\r\nstatic int\r\nhash_ipport6_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, const struct ip_set_adt_opt *opt)\r\n{\r\nconst struct ip_set_hash *h = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_ipport6_elem data = { };\r\nif (!ip_set_get_ip6_port(skb, opt->flags & IPSET_DIM_TWO_SRC,\r\n&data.port, &data.proto))\r\nreturn -EINVAL;\r\nip6addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &data.ip.in6);\r\nreturn adtfn(set, &data, opt_timeout(opt, h), opt->cmdflags);\r\n}\r\nstatic int\r\nhash_ipport6_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nconst struct ip_set_hash *h = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_ipport6_elem data = { };\r\nu32 port, port_to;\r\nu32 timeout = h->timeout;\r\nbool with_ports = false;\r\nint ret;\r\nif (unlikely(!tb[IPSET_ATTR_IP] ||\r\n!ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_PORT_TO) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\r\ntb[IPSET_ATTR_IP_TO] ||\r\ntb[IPSET_ATTR_CIDR]))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nret = ip_set_get_ipaddr6(tb[IPSET_ATTR_IP], &data.ip);\r\nif (ret)\r\nreturn ret;\r\nif (tb[IPSET_ATTR_PORT])\r\ndata.port = nla_get_be16(tb[IPSET_ATTR_PORT]);\r\nelse\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_PROTO]) {\r\ndata.proto = nla_get_u8(tb[IPSET_ATTR_PROTO]);\r\nwith_ports = ip_set_proto_with_ports(data.proto);\r\nif (data.proto == 0)\r\nreturn -IPSET_ERR_INVALID_PROTO;\r\n} else\r\nreturn -IPSET_ERR_MISSING_PROTO;\r\nif (!(with_ports || data.proto == IPPROTO_ICMPV6))\r\ndata.port = 0;\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nif (!with_timeout(h->timeout))\r\nreturn -IPSET_ERR_TIMEOUT;\r\ntimeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\n}\r\nif (adt == IPSET_TEST || !with_ports || !tb[IPSET_ATTR_PORT_TO]) {\r\nret = adtfn(set, &data, timeout, flags);\r\nreturn ip_set_eexist(ret, flags) ? 0 : ret;\r\n}\r\nport = ntohs(data.port);\r\nport_to = ip_set_get_h16(tb[IPSET_ATTR_PORT_TO]);\r\nif (port > port_to)\r\nswap(port, port_to);\r\nif (retried)\r\nport = h->next.port;\r\nfor (; port <= port_to; port++) {\r\ndata.port = htons(port);\r\nret = adtfn(set, &data, timeout, flags);\r\nif (ret && !ip_set_eexist(ret, flags))\r\nreturn ret;\r\nelse\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nhash_ipport_create(struct ip_set *set, struct nlattr *tb[], u32 flags)\r\n{\r\nstruct ip_set_hash *h;\r\nu32 hashsize = IPSET_DEFAULT_HASHSIZE, maxelem = IPSET_DEFAULT_MAXELEM;\r\nu8 hbits;\r\nif (!(set->family == AF_INET || set->family == AF_INET6))\r\nreturn -IPSET_ERR_INVALID_FAMILY;\r\nif (unlikely(!ip_set_optattr_netorder(tb, IPSET_ATTR_HASHSIZE) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_MAXELEM) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_HASHSIZE]) {\r\nhashsize = ip_set_get_h32(tb[IPSET_ATTR_HASHSIZE]);\r\nif (hashsize < IPSET_MIMINAL_HASHSIZE)\r\nhashsize = IPSET_MIMINAL_HASHSIZE;\r\n}\r\nif (tb[IPSET_ATTR_MAXELEM])\r\nmaxelem = ip_set_get_h32(tb[IPSET_ATTR_MAXELEM]);\r\nh = kzalloc(sizeof(*h), GFP_KERNEL);\r\nif (!h)\r\nreturn -ENOMEM;\r\nh->maxelem = maxelem;\r\nget_random_bytes(&h->initval, sizeof(h->initval));\r\nh->timeout = IPSET_NO_TIMEOUT;\r\nhbits = htable_bits(hashsize);\r\nh->table = ip_set_alloc(\r\nsizeof(struct htable)\r\n+ jhash_size(hbits) * sizeof(struct hbucket));\r\nif (!h->table) {\r\nkfree(h);\r\nreturn -ENOMEM;\r\n}\r\nh->table->htable_bits = hbits;\r\nset->data = h;\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nh->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\nset->variant = set->family == AF_INET\r\n? &hash_ipport4_tvariant : &hash_ipport6_tvariant;\r\nif (set->family == AF_INET)\r\nhash_ipport4_gc_init(set);\r\nelse\r\nhash_ipport6_gc_init(set);\r\n} else {\r\nset->variant = set->family == AF_INET\r\n? &hash_ipport4_variant : &hash_ipport6_variant;\r\n}\r\npr_debug("create %s hashsize %u (%u) maxelem %u: %p(%p)\n",\r\nset->name, jhash_size(h->table->htable_bits),\r\nh->table->htable_bits, h->maxelem, set->data, h->table);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nhash_ipport_init(void)\r\n{\r\nreturn ip_set_type_register(&hash_ipport_type);\r\n}\r\nstatic void __exit\r\nhash_ipport_fini(void)\r\n{\r\nip_set_type_unregister(&hash_ipport_type);\r\n}
