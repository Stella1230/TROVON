static inline void kvm_patch_ins(u32 *inst, u32 new_inst)\r\n{\r\n*inst = new_inst;\r\nflush_icache_range((ulong)inst, (ulong)inst + 4);\r\n}\r\nstatic void kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\r\n{\r\n#ifdef CONFIG_64BIT\r\nkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\r\n#else\r\nkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\r\n#endif\r\n}\r\nstatic void kvm_patch_ins_ld(u32 *inst, long addr, u32 rt)\r\n{\r\n#ifdef CONFIG_64BIT\r\nkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\r\n#else\r\nkvm_patch_ins(inst, KVM_INST_LWZ | rt | ((addr + 4) & 0x0000fffc));\r\n#endif\r\n}\r\nstatic void kvm_patch_ins_lwz(u32 *inst, long addr, u32 rt)\r\n{\r\nkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000ffff));\r\n}\r\nstatic void kvm_patch_ins_std(u32 *inst, long addr, u32 rt)\r\n{\r\n#ifdef CONFIG_64BIT\r\nkvm_patch_ins(inst, KVM_INST_STD | rt | (addr & 0x0000fffc));\r\n#else\r\nkvm_patch_ins(inst, KVM_INST_STW | rt | ((addr + 4) & 0x0000fffc));\r\n#endif\r\n}\r\nstatic void kvm_patch_ins_stw(u32 *inst, long addr, u32 rt)\r\n{\r\nkvm_patch_ins(inst, KVM_INST_STW | rt | (addr & 0x0000fffc));\r\n}\r\nstatic void kvm_patch_ins_nop(u32 *inst)\r\n{\r\nkvm_patch_ins(inst, KVM_INST_NOP);\r\n}\r\nstatic void kvm_patch_ins_b(u32 *inst, int addr)\r\n{\r\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\r\nif ((ulong)inst < (ulong)&__end_interrupts)\r\nreturn;\r\n#endif\r\nkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\r\n}\r\nstatic u32 *kvm_alloc(int len)\r\n{\r\nu32 *p;\r\nif ((kvm_tmp_index + len) > ARRAY_SIZE(kvm_tmp)) {\r\nprintk(KERN_ERR "KVM: No more space (%d + %d)\n",\r\nkvm_tmp_index, len);\r\nkvm_patching_worked = false;\r\nreturn NULL;\r\n}\r\np = (void*)&kvm_tmp[kvm_tmp_index];\r\nkvm_tmp_index += len;\r\nreturn p;\r\n}\r\nstatic void kvm_patch_ins_mtmsrd(u32 *inst, u32 rt)\r\n{\r\nu32 *p;\r\nint distance_start;\r\nint distance_end;\r\nulong next_inst;\r\np = kvm_alloc(kvm_emulate_mtmsrd_len * 4);\r\nif (!p)\r\nreturn;\r\ndistance_start = (ulong)p - (ulong)inst;\r\nnext_inst = ((ulong)inst + 4);\r\ndistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsrd_branch_offs];\r\nif (distance_start > KVM_INST_B_MAX) {\r\nkvm_patching_worked = false;\r\nreturn;\r\n}\r\nmemcpy(p, kvm_emulate_mtmsrd, kvm_emulate_mtmsrd_len * 4);\r\np[kvm_emulate_mtmsrd_branch_offs] |= distance_end & KVM_INST_B_MASK;\r\nswitch (get_rt(rt)) {\r\ncase 30:\r\nkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\r\nmagic_var(scratch2), KVM_RT_30);\r\nbreak;\r\ncase 31:\r\nkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\r\nmagic_var(scratch1), KVM_RT_30);\r\nbreak;\r\ndefault:\r\np[kvm_emulate_mtmsrd_reg_offs] |= rt;\r\nbreak;\r\n}\r\np[kvm_emulate_mtmsrd_orig_ins_offs] = *inst;\r\nflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsrd_len * 4);\r\nkvm_patch_ins_b(inst, distance_start);\r\n}\r\nstatic void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\r\n{\r\nu32 *p;\r\nint distance_start;\r\nint distance_end;\r\nulong next_inst;\r\np = kvm_alloc(kvm_emulate_mtmsr_len * 4);\r\nif (!p)\r\nreturn;\r\ndistance_start = (ulong)p - (ulong)inst;\r\nnext_inst = ((ulong)inst + 4);\r\ndistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\r\nif (distance_start > KVM_INST_B_MAX) {\r\nkvm_patching_worked = false;\r\nreturn;\r\n}\r\nmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\r\np[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\r\nswitch (get_rt(rt)) {\r\ncase 30:\r\nkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\r\nmagic_var(scratch2), KVM_RT_30);\r\nkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\r\nmagic_var(scratch2), KVM_RT_30);\r\nbreak;\r\ncase 31:\r\nkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\r\nmagic_var(scratch1), KVM_RT_30);\r\nkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\r\nmagic_var(scratch1), KVM_RT_30);\r\nbreak;\r\ndefault:\r\np[kvm_emulate_mtmsr_reg1_offs] |= rt;\r\np[kvm_emulate_mtmsr_reg2_offs] |= rt;\r\nbreak;\r\n}\r\np[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\r\nflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\r\nkvm_patch_ins_b(inst, distance_start);\r\n}\r\nstatic void kvm_patch_ins_wrteei(u32 *inst)\r\n{\r\nu32 *p;\r\nint distance_start;\r\nint distance_end;\r\nulong next_inst;\r\np = kvm_alloc(kvm_emulate_wrteei_len * 4);\r\nif (!p)\r\nreturn;\r\ndistance_start = (ulong)p - (ulong)inst;\r\nnext_inst = ((ulong)inst + 4);\r\ndistance_end = next_inst - (ulong)&p[kvm_emulate_wrteei_branch_offs];\r\nif (distance_start > KVM_INST_B_MAX) {\r\nkvm_patching_worked = false;\r\nreturn;\r\n}\r\nmemcpy(p, kvm_emulate_wrteei, kvm_emulate_wrteei_len * 4);\r\np[kvm_emulate_wrteei_branch_offs] |= distance_end & KVM_INST_B_MASK;\r\np[kvm_emulate_wrteei_ee_offs] |= (*inst & MSR_EE);\r\nflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrteei_len * 4);\r\nkvm_patch_ins_b(inst, distance_start);\r\n}\r\nstatic void kvm_patch_ins_mtsrin(u32 *inst, u32 rt, u32 rb)\r\n{\r\nu32 *p;\r\nint distance_start;\r\nint distance_end;\r\nulong next_inst;\r\np = kvm_alloc(kvm_emulate_mtsrin_len * 4);\r\nif (!p)\r\nreturn;\r\ndistance_start = (ulong)p - (ulong)inst;\r\nnext_inst = ((ulong)inst + 4);\r\ndistance_end = next_inst - (ulong)&p[kvm_emulate_mtsrin_branch_offs];\r\nif (distance_start > KVM_INST_B_MAX) {\r\nkvm_patching_worked = false;\r\nreturn;\r\n}\r\nmemcpy(p, kvm_emulate_mtsrin, kvm_emulate_mtsrin_len * 4);\r\np[kvm_emulate_mtsrin_branch_offs] |= distance_end & KVM_INST_B_MASK;\r\np[kvm_emulate_mtsrin_reg1_offs] |= (rb << 10);\r\np[kvm_emulate_mtsrin_reg2_offs] |= rt;\r\np[kvm_emulate_mtsrin_orig_ins_offs] = *inst;\r\nflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtsrin_len * 4);\r\nkvm_patch_ins_b(inst, distance_start);\r\n}\r\nstatic void kvm_map_magic_page(void *data)\r\n{\r\nu32 *features = data;\r\nulong in[8];\r\nulong out[8];\r\nin[0] = KVM_MAGIC_PAGE;\r\nin[1] = KVM_MAGIC_PAGE;\r\nkvm_hypercall(in, out, HC_VENDOR_KVM | KVM_HC_PPC_MAP_MAGIC_PAGE);\r\n*features = out[0];\r\n}\r\nstatic void kvm_check_ins(u32 *inst, u32 features)\r\n{\r\nu32 _inst = *inst;\r\nu32 inst_no_rt = _inst & ~KVM_MASK_RT;\r\nu32 inst_rt = _inst & KVM_MASK_RT;\r\nswitch (inst_no_rt) {\r\ncase KVM_INST_MFMSR:\r\nkvm_patch_ins_ld(inst, magic_var(msr), inst_rt);\r\nbreak;\r\ncase KVM_INST_MFSPR_SPRG0:\r\nkvm_patch_ins_ld(inst, magic_var(sprg0), inst_rt);\r\nbreak;\r\ncase KVM_INST_MFSPR_SPRG1:\r\nkvm_patch_ins_ld(inst, magic_var(sprg1), inst_rt);\r\nbreak;\r\ncase KVM_INST_MFSPR_SPRG2:\r\nkvm_patch_ins_ld(inst, magic_var(sprg2), inst_rt);\r\nbreak;\r\ncase KVM_INST_MFSPR_SPRG3:\r\nkvm_patch_ins_ld(inst, magic_var(sprg3), inst_rt);\r\nbreak;\r\ncase KVM_INST_MFSPR_SRR0:\r\nkvm_patch_ins_ld(inst, magic_var(srr0), inst_rt);\r\nbreak;\r\ncase KVM_INST_MFSPR_SRR1:\r\nkvm_patch_ins_ld(inst, magic_var(srr1), inst_rt);\r\nbreak;\r\ncase KVM_INST_MFSPR_DAR:\r\nkvm_patch_ins_ld(inst, magic_var(dar), inst_rt);\r\nbreak;\r\ncase KVM_INST_MFSPR_DSISR:\r\nkvm_patch_ins_lwz(inst, magic_var(dsisr), inst_rt);\r\nbreak;\r\ncase KVM_INST_MTSPR_SPRG0:\r\nkvm_patch_ins_std(inst, magic_var(sprg0), inst_rt);\r\nbreak;\r\ncase KVM_INST_MTSPR_SPRG1:\r\nkvm_patch_ins_std(inst, magic_var(sprg1), inst_rt);\r\nbreak;\r\ncase KVM_INST_MTSPR_SPRG2:\r\nkvm_patch_ins_std(inst, magic_var(sprg2), inst_rt);\r\nbreak;\r\ncase KVM_INST_MTSPR_SPRG3:\r\nkvm_patch_ins_std(inst, magic_var(sprg3), inst_rt);\r\nbreak;\r\ncase KVM_INST_MTSPR_SRR0:\r\nkvm_patch_ins_std(inst, magic_var(srr0), inst_rt);\r\nbreak;\r\ncase KVM_INST_MTSPR_SRR1:\r\nkvm_patch_ins_std(inst, magic_var(srr1), inst_rt);\r\nbreak;\r\ncase KVM_INST_MTSPR_DAR:\r\nkvm_patch_ins_std(inst, magic_var(dar), inst_rt);\r\nbreak;\r\ncase KVM_INST_MTSPR_DSISR:\r\nkvm_patch_ins_stw(inst, magic_var(dsisr), inst_rt);\r\nbreak;\r\ncase KVM_INST_TLBSYNC:\r\nkvm_patch_ins_nop(inst);\r\nbreak;\r\ncase KVM_INST_MTMSRD_L1:\r\nkvm_patch_ins_mtmsrd(inst, inst_rt);\r\nbreak;\r\ncase KVM_INST_MTMSR:\r\ncase KVM_INST_MTMSRD_L0:\r\nkvm_patch_ins_mtmsr(inst, inst_rt);\r\nbreak;\r\n}\r\nswitch (inst_no_rt & ~KVM_MASK_RB) {\r\n#ifdef CONFIG_PPC_BOOK3S_32\r\ncase KVM_INST_MTSRIN:\r\nif (features & KVM_MAGIC_FEAT_SR) {\r\nu32 inst_rb = _inst & KVM_MASK_RB;\r\nkvm_patch_ins_mtsrin(inst, inst_rt, inst_rb);\r\n}\r\nbreak;\r\nbreak;\r\n#endif\r\n}\r\nswitch (_inst) {\r\n#ifdef CONFIG_BOOKE\r\ncase KVM_INST_WRTEEI_0:\r\ncase KVM_INST_WRTEEI_1:\r\nkvm_patch_ins_wrteei(inst);\r\nbreak;\r\n#endif\r\n}\r\n}\r\nstatic void kvm_use_magic_page(void)\r\n{\r\nu32 *p;\r\nu32 *start, *end;\r\nu32 tmp;\r\nu32 features;\r\non_each_cpu(kvm_map_magic_page, &features, 1);\r\nif (__get_user(tmp, (u32*)KVM_MAGIC_PAGE)) {\r\nkvm_patching_worked = false;\r\nreturn;\r\n}\r\nstart = (void*)_stext;\r\nend = (void*)_etext;\r\nfor (p = start; p < end; p++)\r\nkvm_check_ins(p, features);\r\nprintk(KERN_INFO "KVM: Live patching for a fast VM %s\n",\r\nkvm_patching_worked ? "worked" : "failed");\r\n}\r\nunsigned long kvm_hypercall(unsigned long *in,\r\nunsigned long *out,\r\nunsigned long nr)\r\n{\r\nunsigned long register r0 asm("r0");\r\nunsigned long register r3 asm("r3") = in[0];\r\nunsigned long register r4 asm("r4") = in[1];\r\nunsigned long register r5 asm("r5") = in[2];\r\nunsigned long register r6 asm("r6") = in[3];\r\nunsigned long register r7 asm("r7") = in[4];\r\nunsigned long register r8 asm("r8") = in[5];\r\nunsigned long register r9 asm("r9") = in[6];\r\nunsigned long register r10 asm("r10") = in[7];\r\nunsigned long register r11 asm("r11") = nr;\r\nunsigned long register r12 asm("r12");\r\nasm volatile("bl kvm_hypercall_start"\r\n: "=r"(r0), "=r"(r3), "=r"(r4), "=r"(r5), "=r"(r6),\r\n"=r"(r7), "=r"(r8), "=r"(r9), "=r"(r10), "=r"(r11),\r\n"=r"(r12)\r\n: "r"(r3), "r"(r4), "r"(r5), "r"(r6), "r"(r7), "r"(r8),\r\n"r"(r9), "r"(r10), "r"(r11)\r\n: "memory", "cc", "xer", "ctr", "lr");\r\nout[0] = r4;\r\nout[1] = r5;\r\nout[2] = r6;\r\nout[3] = r7;\r\nout[4] = r8;\r\nout[5] = r9;\r\nout[6] = r10;\r\nout[7] = r11;\r\nreturn r3;\r\n}\r\nstatic int kvm_para_setup(void)\r\n{\r\nextern u32 kvm_hypercall_start;\r\nstruct device_node *hyper_node;\r\nu32 *insts;\r\nint len, i;\r\nhyper_node = of_find_node_by_path("/hypervisor");\r\nif (!hyper_node)\r\nreturn -1;\r\ninsts = (u32*)of_get_property(hyper_node, "hcall-instructions", &len);\r\nif (len % 4)\r\nreturn -1;\r\nif (len > (4 * 4))\r\nreturn -1;\r\nfor (i = 0; i < (len / 4); i++)\r\nkvm_patch_ins(&(&kvm_hypercall_start)[i], insts[i]);\r\nreturn 0;\r\n}\r\nstatic __init void kvm_free_tmp(void)\r\n{\r\nunsigned long start, end;\r\nstart = (ulong)&kvm_tmp[kvm_tmp_index + (PAGE_SIZE - 1)] & PAGE_MASK;\r\nend = (ulong)&kvm_tmp[ARRAY_SIZE(kvm_tmp)] & PAGE_MASK;\r\nfor (; start < end; start += PAGE_SIZE) {\r\nClearPageReserved(virt_to_page(start));\r\ninit_page_count(virt_to_page(start));\r\nfree_page(start);\r\ntotalram_pages++;\r\n}\r\n}\r\nstatic int __init kvm_guest_init(void)\r\n{\r\nif (!kvm_para_available())\r\ngoto free_tmp;\r\nif (kvm_para_setup())\r\ngoto free_tmp;\r\nif (kvm_para_has_feature(KVM_FEATURE_MAGIC_PAGE))\r\nkvm_use_magic_page();\r\n#ifdef CONFIG_PPC_BOOK3S_64\r\npowersave_nap = 1;\r\n#endif\r\nfree_tmp:\r\nkvm_free_tmp();\r\nreturn 0;\r\n}
