static int ivtv_s_stream_vbi_fmt(struct cx2341x_handler *cxhdl, u32 fmt)\r\n{\r\nstruct ivtv *itv = container_of(cxhdl, struct ivtv, cxhdl);\r\nif (fmt && itv->vbi.sliced_mpeg_data[0] == NULL) {\r\nint i;\r\nfor (i = 0; i < IVTV_VBI_FRAMES; i++) {\r\nitv->vbi.sliced_mpeg_data[i] = kmalloc(2049, GFP_KERNEL);\r\nif (itv->vbi.sliced_mpeg_data[i] == NULL) {\r\nwhile (--i >= 0) {\r\nkfree(itv->vbi.sliced_mpeg_data[i]);\r\nitv->vbi.sliced_mpeg_data[i] = NULL;\r\n}\r\nreturn -ENOMEM;\r\n}\r\n}\r\n}\r\nitv->vbi.insert_mpeg = fmt;\r\nif (itv->vbi.insert_mpeg == 0) {\r\nreturn 0;\r\n}\r\nif (ivtv_get_service_set(itv->vbi.sliced_in) == 0) {\r\nif (itv->is_60hz)\r\nitv->vbi.sliced_in->service_set = V4L2_SLICED_CAPTION_525;\r\nelse\r\nitv->vbi.sliced_in->service_set = V4L2_SLICED_WSS_625;\r\nivtv_expand_service_set(itv->vbi.sliced_in, itv->is_50hz);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ivtv_s_video_encoding(struct cx2341x_handler *cxhdl, u32 val)\r\n{\r\nstruct ivtv *itv = container_of(cxhdl, struct ivtv, cxhdl);\r\nint is_mpeg1 = val == V4L2_MPEG_VIDEO_ENCODING_MPEG_1;\r\nstruct v4l2_mbus_framefmt fmt;\r\nfmt.width = cxhdl->width / (is_mpeg1 ? 2 : 1);\r\nfmt.height = cxhdl->height;\r\nfmt.code = V4L2_MBUS_FMT_FIXED;\r\nv4l2_subdev_call(itv->sd_video, video, s_mbus_fmt, &fmt);\r\nreturn 0;\r\n}\r\nstatic int ivtv_s_audio_sampling_freq(struct cx2341x_handler *cxhdl, u32 idx)\r\n{\r\nstatic const u32 freqs[3] = { 44100, 48000, 32000 };\r\nstruct ivtv *itv = container_of(cxhdl, struct ivtv, cxhdl);\r\nif (idx < ARRAY_SIZE(freqs))\r\nivtv_call_all(itv, audio, s_clock_freq, freqs[idx]);\r\nreturn 0;\r\n}\r\nstatic int ivtv_s_audio_mode(struct cx2341x_handler *cxhdl, u32 val)\r\n{\r\nstruct ivtv *itv = container_of(cxhdl, struct ivtv, cxhdl);\r\nitv->dualwatch_stereo_mode = val;\r\nreturn 0;\r\n}
