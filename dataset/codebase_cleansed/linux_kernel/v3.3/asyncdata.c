static inline int muststuff(unsigned char c)\r\n{\r\nif (c < PPP_TRANS) return 1;\r\nif (c == PPP_FLAG) return 1;\r\nif (c == PPP_ESCAPE) return 1;\r\nreturn 0;\r\n}\r\nstatic unsigned cmd_loop(unsigned numbytes, struct inbuf_t *inbuf)\r\n{\r\nunsigned char *src = inbuf->data + inbuf->head;\r\nstruct cardstate *cs = inbuf->cs;\r\nunsigned cbytes = cs->cbytes;\r\nunsigned procbytes = 0;\r\nunsigned char c;\r\nwhile (procbytes < numbytes) {\r\nc = *src++;\r\nprocbytes++;\r\nswitch (c) {\r\ncase '\n':\r\nif (cbytes == 0 && cs->respdata[0] == '\r') {\r\ncs->respdata[0] = 0;\r\nbreak;\r\n}\r\ncase '\r':\r\nif (cbytes >= MAX_RESP_SIZE) {\r\ndev_warn(cs->dev, "response too large (%d)\n",\r\ncbytes);\r\ncbytes = MAX_RESP_SIZE;\r\n}\r\ncs->cbytes = cbytes;\r\ngigaset_dbg_buffer(DEBUG_TRANSCMD, "received response",\r\ncbytes, cs->respdata);\r\ngigaset_handle_modem_response(cs);\r\ncbytes = 0;\r\ncs->respdata[0] = c;\r\nif (cs->dle && !(inbuf->inputstate & INS_DLE_command))\r\ninbuf->inputstate &= ~INS_command;\r\ngoto exit;\r\ncase DLE_FLAG:\r\nif (inbuf->inputstate & INS_DLE_char) {\r\ninbuf->inputstate &= ~INS_DLE_char;\r\n} else if (cs->dle ||\r\n(inbuf->inputstate & INS_DLE_command)) {\r\ninbuf->inputstate |= INS_DLE_char;\r\ngoto exit;\r\n}\r\ndefault:\r\nif (cbytes < MAX_RESP_SIZE)\r\ncs->respdata[cbytes] = c;\r\ncbytes++;\r\n}\r\n}\r\nexit:\r\ncs->cbytes = cbytes;\r\nreturn procbytes;\r\n}\r\nstatic unsigned lock_loop(unsigned numbytes, struct inbuf_t *inbuf)\r\n{\r\nunsigned char *src = inbuf->data + inbuf->head;\r\ngigaset_dbg_buffer(DEBUG_LOCKCMD, "received response", numbytes, src);\r\ngigaset_if_receive(inbuf->cs, src, numbytes);\r\nreturn numbytes;\r\n}\r\nstatic unsigned hdlc_loop(unsigned numbytes, struct inbuf_t *inbuf)\r\n{\r\nstruct cardstate *cs = inbuf->cs;\r\nstruct bc_state *bcs = cs->bcs;\r\nint inputstate = bcs->inputstate;\r\n__u16 fcs = bcs->rx_fcs;\r\nstruct sk_buff *skb = bcs->rx_skb;\r\nunsigned char *src = inbuf->data + inbuf->head;\r\nunsigned procbytes = 0;\r\nunsigned char c;\r\nif (inputstate & INS_byte_stuff) {\r\nif (!numbytes)\r\nreturn 0;\r\ninputstate &= ~INS_byte_stuff;\r\ngoto byte_stuff;\r\n}\r\nwhile (procbytes < numbytes) {\r\nc = *src++;\r\nprocbytes++;\r\nif (c == DLE_FLAG) {\r\nif (inputstate & INS_DLE_char) {\r\ninputstate &= ~INS_DLE_char;\r\n} else if (cs->dle || (inputstate & INS_DLE_command)) {\r\ninputstate |= INS_DLE_char;\r\nbreak;\r\n}\r\n}\r\nif (c == PPP_ESCAPE) {\r\nif (procbytes >= numbytes) {\r\ninputstate |= INS_byte_stuff;\r\nbreak;\r\n}\r\nbyte_stuff:\r\nc = *src++;\r\nprocbytes++;\r\nif (c == DLE_FLAG) {\r\nif (inputstate & INS_DLE_char) {\r\ninputstate &= ~INS_DLE_char;\r\n} else if (cs->dle ||\r\n(inputstate & INS_DLE_command)) {\r\ninputstate |=\r\nINS_DLE_char | INS_byte_stuff;\r\nbreak;\r\n}\r\n}\r\nc ^= PPP_TRANS;\r\n#ifdef CONFIG_GIGASET_DEBUG\r\nif (!muststuff(c))\r\ngig_dbg(DEBUG_HDLC, "byte stuffed: 0x%02x", c);\r\n#endif\r\n} else if (c == PPP_FLAG) {\r\nif (inputstate & INS_have_data) {\r\ngig_dbg(DEBUG_HDLC,\r\n"7e----------------------------");\r\nif (!skb) {\r\ngigaset_isdn_rcv_err(bcs);\r\n} else if (skb->len < 2) {\r\ndev_warn(cs->dev,\r\n"short frame (%d)\n",\r\nskb->len);\r\ngigaset_isdn_rcv_err(bcs);\r\ndev_kfree_skb_any(skb);\r\n} else if (fcs != PPP_GOODFCS) {\r\ndev_err(cs->dev,\r\n"Checksum failed, %u bytes corrupted!\n",\r\nskb->len);\r\ngigaset_isdn_rcv_err(bcs);\r\ndev_kfree_skb_any(skb);\r\n} else {\r\n__skb_trim(skb, skb->len - 2);\r\ngigaset_skb_rcvd(bcs, skb);\r\n}\r\ninputstate &= ~INS_have_data;\r\nskb = gigaset_new_rx_skb(bcs);\r\n} else {\r\n#ifdef CONFIG_GIGASET_DEBUG\r\n++bcs->emptycount;\r\n#endif\r\nif (!skb) {\r\ngigaset_isdn_rcv_err(bcs);\r\nskb = gigaset_new_rx_skb(bcs);\r\n}\r\n}\r\nfcs = PPP_INITFCS;\r\ncontinue;\r\n#ifdef CONFIG_GIGASET_DEBUG\r\n} else if (muststuff(c)) {\r\ngig_dbg(DEBUG_HDLC, "not byte stuffed: 0x%02x", c);\r\n#endif\r\n}\r\n#ifdef CONFIG_GIGASET_DEBUG\r\nif (!(inputstate & INS_have_data)) {\r\ngig_dbg(DEBUG_HDLC, "7e (%d x) ================",\r\nbcs->emptycount);\r\nbcs->emptycount = 0;\r\n}\r\n#endif\r\ninputstate |= INS_have_data;\r\nif (skb) {\r\nif (skb->len >= bcs->rx_bufsize) {\r\ndev_warn(cs->dev, "received packet too long\n");\r\ndev_kfree_skb_any(skb);\r\nbcs->rx_skb = skb = NULL;\r\n} else {\r\n*__skb_put(skb, 1) = c;\r\nfcs = crc_ccitt_byte(fcs, c);\r\n}\r\n}\r\n}\r\nbcs->inputstate = inputstate;\r\nbcs->rx_fcs = fcs;\r\nreturn procbytes;\r\n}\r\nstatic unsigned iraw_loop(unsigned numbytes, struct inbuf_t *inbuf)\r\n{\r\nstruct cardstate *cs = inbuf->cs;\r\nstruct bc_state *bcs = cs->bcs;\r\nint inputstate = bcs->inputstate;\r\nstruct sk_buff *skb = bcs->rx_skb;\r\nunsigned char *src = inbuf->data + inbuf->head;\r\nunsigned procbytes = 0;\r\nunsigned char c;\r\nif (!skb) {\r\ngigaset_new_rx_skb(bcs);\r\nreturn numbytes;\r\n}\r\nwhile (procbytes < numbytes && skb->len < bcs->rx_bufsize) {\r\nc = *src++;\r\nprocbytes++;\r\nif (c == DLE_FLAG) {\r\nif (inputstate & INS_DLE_char) {\r\ninputstate &= ~INS_DLE_char;\r\n} else if (cs->dle || (inputstate & INS_DLE_command)) {\r\ninputstate |= INS_DLE_char;\r\nbreak;\r\n}\r\n}\r\ninputstate |= INS_have_data;\r\n*__skb_put(skb, 1) = bitrev8(c);\r\n}\r\nif (inputstate & INS_have_data) {\r\ngigaset_skb_rcvd(bcs, skb);\r\ninputstate &= ~INS_have_data;\r\ngigaset_new_rx_skb(bcs);\r\n}\r\nbcs->inputstate = inputstate;\r\nreturn procbytes;\r\n}\r\nstatic void handle_dle(struct inbuf_t *inbuf)\r\n{\r\nstruct cardstate *cs = inbuf->cs;\r\nif (cs->mstate == MS_LOCKED)\r\nreturn;\r\nif (!(inbuf->inputstate & INS_DLE_char)) {\r\nif (inbuf->data[inbuf->head] == DLE_FLAG &&\r\n(cs->dle || inbuf->inputstate & INS_DLE_command)) {\r\ninbuf->head++;\r\nif (inbuf->head == inbuf->tail ||\r\ninbuf->head == RBUFSIZE) {\r\ninbuf->inputstate |= INS_DLE_char;\r\nreturn;\r\n}\r\n} else {\r\nreturn;\r\n}\r\n}\r\ninbuf->inputstate &= ~INS_DLE_char;\r\nswitch (inbuf->data[inbuf->head]) {\r\ncase 'X':\r\nif (inbuf->inputstate & INS_command)\r\ndev_notice(cs->dev,\r\n"received <DLE>X in command mode\n");\r\ninbuf->inputstate |= INS_command | INS_DLE_command;\r\ninbuf->head++;\r\nbreak;\r\ncase '.':\r\nif (!(inbuf->inputstate & INS_DLE_command))\r\ndev_notice(cs->dev,\r\n"received <DLE>. without <DLE>X\n");\r\ninbuf->inputstate &= ~INS_DLE_command;\r\nif (cs->dle)\r\ninbuf->inputstate &= ~INS_command;\r\ninbuf->head++;\r\nbreak;\r\ncase DLE_FLAG:\r\ninbuf->inputstate |= INS_DLE_char;\r\nif (!(cs->dle || inbuf->inputstate & INS_DLE_command))\r\ndev_notice(cs->dev,\r\n"received <DLE><DLE> not in DLE mode\n");\r\nbreak;\r\ndefault:\r\ndev_notice(cs->dev, "received <DLE><%02x>\n",\r\ninbuf->data[inbuf->head]);\r\n}\r\n}\r\nvoid gigaset_m10x_input(struct inbuf_t *inbuf)\r\n{\r\nstruct cardstate *cs = inbuf->cs;\r\nunsigned numbytes, procbytes;\r\ngig_dbg(DEBUG_INTR, "buffer state: %u -> %u", inbuf->head, inbuf->tail);\r\nwhile (inbuf->head != inbuf->tail) {\r\nhandle_dle(inbuf);\r\nnumbytes = (inbuf->head > inbuf->tail ?\r\nRBUFSIZE : inbuf->tail) - inbuf->head;\r\ngig_dbg(DEBUG_INTR, "processing %u bytes", numbytes);\r\nif (cs->mstate == MS_LOCKED)\r\nprocbytes = lock_loop(numbytes, inbuf);\r\nelse if (inbuf->inputstate & INS_command)\r\nprocbytes = cmd_loop(numbytes, inbuf);\r\nelse if (cs->bcs->proto2 == L2_HDLC)\r\nprocbytes = hdlc_loop(numbytes, inbuf);\r\nelse\r\nprocbytes = iraw_loop(numbytes, inbuf);\r\ninbuf->head += procbytes;\r\nif (inbuf->head >= RBUFSIZE)\r\ninbuf->head = 0;\r\ngig_dbg(DEBUG_INTR, "head set to %u", inbuf->head);\r\n}\r\n}\r\nstatic struct sk_buff *HDLC_Encode(struct sk_buff *skb)\r\n{\r\nstruct sk_buff *hdlc_skb;\r\n__u16 fcs;\r\nunsigned char c;\r\nunsigned char *cp;\r\nint len;\r\nunsigned int stuf_cnt;\r\nstuf_cnt = 0;\r\nfcs = PPP_INITFCS;\r\ncp = skb->data;\r\nlen = skb->len;\r\nwhile (len--) {\r\nif (muststuff(*cp))\r\nstuf_cnt++;\r\nfcs = crc_ccitt_byte(fcs, *cp++);\r\n}\r\nfcs ^= 0xffff;\r\nhdlc_skb = dev_alloc_skb(skb->len + stuf_cnt + 6 + skb->mac_len);\r\nif (!hdlc_skb) {\r\ndev_kfree_skb_any(skb);\r\nreturn NULL;\r\n}\r\nskb_reset_mac_header(hdlc_skb);\r\nskb_reserve(hdlc_skb, skb->mac_len);\r\nmemcpy(skb_mac_header(hdlc_skb), skb_mac_header(skb), skb->mac_len);\r\nhdlc_skb->mac_len = skb->mac_len;\r\n*(skb_put(hdlc_skb, 1)) = PPP_FLAG;\r\nwhile (skb->len--) {\r\nif (muststuff(*skb->data)) {\r\n*(skb_put(hdlc_skb, 1)) = PPP_ESCAPE;\r\n*(skb_put(hdlc_skb, 1)) = (*skb->data++) ^ PPP_TRANS;\r\n} else\r\n*(skb_put(hdlc_skb, 1)) = *skb->data++;\r\n}\r\nc = (fcs & 0x00ff);\r\nif (muststuff(c)) {\r\n*(skb_put(hdlc_skb, 1)) = PPP_ESCAPE;\r\nc ^= PPP_TRANS;\r\n}\r\n*(skb_put(hdlc_skb, 1)) = c;\r\nc = ((fcs >> 8) & 0x00ff);\r\nif (muststuff(c)) {\r\n*(skb_put(hdlc_skb, 1)) = PPP_ESCAPE;\r\nc ^= PPP_TRANS;\r\n}\r\n*(skb_put(hdlc_skb, 1)) = c;\r\n*(skb_put(hdlc_skb, 1)) = PPP_FLAG;\r\ndev_kfree_skb_any(skb);\r\nreturn hdlc_skb;\r\n}\r\nstatic struct sk_buff *iraw_encode(struct sk_buff *skb)\r\n{\r\nstruct sk_buff *iraw_skb;\r\nunsigned char c;\r\nunsigned char *cp;\r\nint len;\r\niraw_skb = dev_alloc_skb(2*skb->len + skb->mac_len);\r\nif (!iraw_skb) {\r\ndev_kfree_skb_any(skb);\r\nreturn NULL;\r\n}\r\nskb_reset_mac_header(iraw_skb);\r\nskb_reserve(iraw_skb, skb->mac_len);\r\nmemcpy(skb_mac_header(iraw_skb), skb_mac_header(skb), skb->mac_len);\r\niraw_skb->mac_len = skb->mac_len;\r\ncp = skb->data;\r\nlen = skb->len;\r\nwhile (len--) {\r\nc = bitrev8(*cp++);\r\nif (c == DLE_FLAG)\r\n*(skb_put(iraw_skb, 1)) = c;\r\n*(skb_put(iraw_skb, 1)) = c;\r\n}\r\ndev_kfree_skb_any(skb);\r\nreturn iraw_skb;\r\n}\r\nint gigaset_m10x_send_skb(struct bc_state *bcs, struct sk_buff *skb)\r\n{\r\nstruct cardstate *cs = bcs->cs;\r\nunsigned len = skb->len;\r\nunsigned long flags;\r\nif (bcs->proto2 == L2_HDLC)\r\nskb = HDLC_Encode(skb);\r\nelse\r\nskb = iraw_encode(skb);\r\nif (!skb) {\r\ndev_err(cs->dev,\r\n"unable to allocate memory for encoding!\n");\r\nreturn -ENOMEM;\r\n}\r\nskb_queue_tail(&bcs->squeue, skb);\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->connected)\r\ntasklet_schedule(&cs->write_tasklet);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn len;\r\n}
