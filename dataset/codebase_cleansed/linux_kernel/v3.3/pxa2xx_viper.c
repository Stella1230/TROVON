static inline struct arcom_pcmcia_pdata *viper_get_pdata(void)\r\n{\r\nreturn arcom_pcmcia_dev->dev.platform_data;\r\n}\r\nstatic int viper_pcmcia_hw_init(struct soc_pcmcia_socket *skt)\r\n{\r\nstruct arcom_pcmcia_pdata *pdata = viper_get_pdata();\r\nunsigned long flags;\r\nskt->socket.pci_irq = gpio_to_irq(pdata->rdy_gpio);\r\nirqs[0].irq = gpio_to_irq(pdata->cd_gpio);\r\nif (gpio_request(pdata->cd_gpio, "CF detect"))\r\ngoto err_request_cd;\r\nif (gpio_request(pdata->rdy_gpio, "CF ready"))\r\ngoto err_request_rdy;\r\nif (gpio_request(pdata->pwr_gpio, "CF power"))\r\ngoto err_request_pwr;\r\nlocal_irq_save(flags);\r\nif (gpio_direction_output(pdata->pwr_gpio, 0) ||\r\ngpio_direction_input(pdata->cd_gpio) ||\r\ngpio_direction_input(pdata->rdy_gpio)) {\r\nlocal_irq_restore(flags);\r\ngoto err_dir;\r\n}\r\nlocal_irq_restore(flags);\r\nreturn soc_pcmcia_request_irqs(skt, irqs, ARRAY_SIZE(irqs));\r\nerr_dir:\r\ngpio_free(pdata->pwr_gpio);\r\nerr_request_pwr:\r\ngpio_free(pdata->rdy_gpio);\r\nerr_request_rdy:\r\ngpio_free(pdata->cd_gpio);\r\nerr_request_cd:\r\ndev_err(&arcom_pcmcia_dev->dev, "Failed to setup PCMCIA GPIOs\n");\r\nreturn -1;\r\n}\r\nstatic void viper_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt)\r\n{\r\nstruct arcom_pcmcia_pdata *pdata = viper_get_pdata();\r\nsoc_pcmcia_free_irqs(skt, irqs, ARRAY_SIZE(irqs));\r\ngpio_free(pdata->pwr_gpio);\r\ngpio_free(pdata->rdy_gpio);\r\ngpio_free(pdata->cd_gpio);\r\n}\r\nstatic void viper_pcmcia_socket_state(struct soc_pcmcia_socket *skt,\r\nstruct pcmcia_state *state)\r\n{\r\nstruct arcom_pcmcia_pdata *pdata = viper_get_pdata();\r\nstate->detect = !gpio_get_value(pdata->cd_gpio);\r\nstate->ready = !!gpio_get_value(pdata->rdy_gpio);\r\nstate->bvd1 = 1;\r\nstate->bvd2 = 1;\r\nstate->wrprot = 0;\r\nstate->vs_3v = 1;\r\nstate->vs_Xv = 0;\r\n}\r\nstatic int viper_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,\r\nconst socket_state_t *state)\r\n{\r\nstruct arcom_pcmcia_pdata *pdata = viper_get_pdata();\r\npdata->reset(state->flags & SS_RESET);\r\nswitch (state->Vcc) {\r\ncase 0:\r\ngpio_set_value(pdata->pwr_gpio, 0);\r\nbreak;\r\ncase 33:\r\ngpio_set_value(pdata->pwr_gpio, 1);\r\nbreak;\r\ndefault:\r\ndev_err(&arcom_pcmcia_dev->dev, "Unsupported Vcc:%d\n", state->Vcc);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int viper_pcmcia_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nif (arcom_pcmcia_dev)\r\nreturn -EEXIST;\r\nif (!pdev->dev.platform_data)\r\nreturn -EINVAL;\r\nviper_pcmcia_device = platform_device_alloc("pxa2xx-pcmcia", -1);\r\nif (!viper_pcmcia_device)\r\nreturn -ENOMEM;\r\narcom_pcmcia_dev = pdev;\r\nviper_pcmcia_device->dev.parent = &pdev->dev;\r\nret = platform_device_add_data(viper_pcmcia_device,\r\n&viper_pcmcia_ops,\r\nsizeof(viper_pcmcia_ops));\r\nif (!ret)\r\nret = platform_device_add(viper_pcmcia_device);\r\nif (ret) {\r\nplatform_device_put(viper_pcmcia_device);\r\narcom_pcmcia_dev = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int viper_pcmcia_remove(struct platform_device *pdev)\r\n{\r\nplatform_device_unregister(viper_pcmcia_device);\r\narcom_pcmcia_dev = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init viper_pcmcia_init(void)\r\n{\r\nreturn platform_driver_register(&viper_pcmcia_driver);\r\n}\r\nstatic void __exit viper_pcmcia_exit(void)\r\n{\r\nreturn platform_driver_unregister(&viper_pcmcia_driver);\r\n}
