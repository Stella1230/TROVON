static struct wusbhc *usbhc_dev_to_wusbhc(struct device *dev)\r\n{\r\nstruct usb_bus *usb_bus = dev_get_drvdata(dev);\r\nstruct usb_hcd *usb_hcd = bus_to_hcd(usb_bus);\r\nreturn usb_hcd_to_wusbhc(usb_hcd);\r\n}\r\nstatic ssize_t wusb_trust_timeout_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct wusbhc *wusbhc = usbhc_dev_to_wusbhc(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", wusbhc->trust_timeout);\r\n}\r\nstatic ssize_t wusb_trust_timeout_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct wusbhc *wusbhc = usbhc_dev_to_wusbhc(dev);\r\nssize_t result = -ENOSYS;\r\nunsigned trust_timeout;\r\nresult = sscanf(buf, "%u", &trust_timeout);\r\nif (result != 1) {\r\nresult = -EINVAL;\r\ngoto out;\r\n}\r\nwusbhc->trust_timeout = trust_timeout;\r\ncancel_delayed_work(&wusbhc->keep_alive_timer);\r\nflush_workqueue(wusbd);\r\nqueue_delayed_work(wusbd, &wusbhc->keep_alive_timer,\r\n(trust_timeout * CONFIG_HZ)/1000/2);\r\nout:\r\nreturn result < 0 ? result : size;\r\n}\r\nstatic ssize_t wusb_chid_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct wusbhc *wusbhc = usbhc_dev_to_wusbhc(dev);\r\nconst struct wusb_ckhdid *chid;\r\nssize_t result = 0;\r\nif (wusbhc->wuie_host_info != NULL)\r\nchid = &wusbhc->wuie_host_info->CHID;\r\nelse\r\nchid = &wusb_ckhdid_zero;\r\nresult += ckhdid_printf(buf, PAGE_SIZE, chid);\r\nresult += sprintf(buf + result, "\n");\r\nreturn result;\r\n}\r\nstatic ssize_t wusb_chid_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct wusbhc *wusbhc = usbhc_dev_to_wusbhc(dev);\r\nstruct wusb_ckhdid chid;\r\nssize_t result;\r\nresult = sscanf(buf,\r\n"%02hhx %02hhx %02hhx %02hhx "\r\n"%02hhx %02hhx %02hhx %02hhx "\r\n"%02hhx %02hhx %02hhx %02hhx "\r\n"%02hhx %02hhx %02hhx %02hhx\n",\r\n&chid.data[0] , &chid.data[1] ,\r\n&chid.data[2] , &chid.data[3] ,\r\n&chid.data[4] , &chid.data[5] ,\r\n&chid.data[6] , &chid.data[7] ,\r\n&chid.data[8] , &chid.data[9] ,\r\n&chid.data[10], &chid.data[11],\r\n&chid.data[12], &chid.data[13],\r\n&chid.data[14], &chid.data[15]);\r\nif (result != 16) {\r\ndev_err(dev, "Unrecognized CHID (need 16 8-bit hex digits): "\r\n"%d\n", (int)result);\r\nreturn -EINVAL;\r\n}\r\nresult = wusbhc_chid_set(wusbhc, &chid);\r\nreturn result < 0 ? result : size;\r\n}\r\nstatic ssize_t wusb_phy_rate_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct wusbhc *wusbhc = usbhc_dev_to_wusbhc(dev);\r\nreturn sprintf(buf, "%d\n", wusbhc->phy_rate);\r\n}\r\nstatic ssize_t wusb_phy_rate_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct wusbhc *wusbhc = usbhc_dev_to_wusbhc(dev);\r\nuint8_t phy_rate;\r\nssize_t result;\r\nresult = sscanf(buf, "%hhu", &phy_rate);\r\nif (result != 1)\r\nreturn -EINVAL;\r\nif (phy_rate >= UWB_PHY_RATE_INVALID)\r\nreturn -EINVAL;\r\nwusbhc->phy_rate = phy_rate;\r\nreturn size;\r\n}\r\nint wusbhc_create(struct wusbhc *wusbhc)\r\n{\r\nint result = 0;\r\nwusbhc->trust_timeout = WUSB_TRUST_TIMEOUT_MS;\r\nwusbhc->phy_rate = UWB_PHY_RATE_INVALID - 1;\r\nmutex_init(&wusbhc->mutex);\r\nresult = wusbhc_mmcie_create(wusbhc);\r\nif (result < 0)\r\ngoto error_mmcie_create;\r\nresult = wusbhc_devconnect_create(wusbhc);\r\nif (result < 0)\r\ngoto error_devconnect_create;\r\nresult = wusbhc_rh_create(wusbhc);\r\nif (result < 0)\r\ngoto error_rh_create;\r\nresult = wusbhc_sec_create(wusbhc);\r\nif (result < 0)\r\ngoto error_sec_create;\r\nreturn 0;\r\nerror_sec_create:\r\nwusbhc_rh_destroy(wusbhc);\r\nerror_rh_create:\r\nwusbhc_devconnect_destroy(wusbhc);\r\nerror_devconnect_create:\r\nwusbhc_mmcie_destroy(wusbhc);\r\nerror_mmcie_create:\r\nreturn result;\r\n}\r\nstatic inline struct kobject *wusbhc_kobj(struct wusbhc *wusbhc)\r\n{\r\nreturn &wusbhc->usb_hcd.self.controller->kobj;\r\n}\r\nint wusbhc_b_create(struct wusbhc *wusbhc)\r\n{\r\nint result = 0;\r\nstruct device *dev = wusbhc->usb_hcd.self.controller;\r\nresult = sysfs_create_group(wusbhc_kobj(wusbhc), &wusbhc_attr_group);\r\nif (result < 0) {\r\ndev_err(dev, "Cannot register WUSBHC attributes: %d\n", result);\r\ngoto error_create_attr_group;\r\n}\r\nresult = wusbhc_pal_register(wusbhc);\r\nif (result < 0)\r\ngoto error_pal_register;\r\nreturn 0;\r\nerror_pal_register:\r\nsysfs_remove_group(wusbhc_kobj(wusbhc), &wusbhc_attr_group);\r\nerror_create_attr_group:\r\nreturn result;\r\n}\r\nvoid wusbhc_b_destroy(struct wusbhc *wusbhc)\r\n{\r\nwusbhc_pal_unregister(wusbhc);\r\nsysfs_remove_group(wusbhc_kobj(wusbhc), &wusbhc_attr_group);\r\n}\r\nvoid wusbhc_destroy(struct wusbhc *wusbhc)\r\n{\r\nwusbhc_sec_destroy(wusbhc);\r\nwusbhc_rh_destroy(wusbhc);\r\nwusbhc_devconnect_destroy(wusbhc);\r\nwusbhc_mmcie_destroy(wusbhc);\r\n}\r\nu8 wusb_cluster_id_get(void)\r\n{\r\nu8 id;\r\nspin_lock(&wusb_cluster_ids_lock);\r\nid = find_first_zero_bit(wusb_cluster_id_table, CLUSTER_IDS);\r\nif (id >= CLUSTER_IDS) {\r\nid = 0;\r\ngoto out;\r\n}\r\nset_bit(id, wusb_cluster_id_table);\r\nid = (u8) 0xff - id;\r\nout:\r\nspin_unlock(&wusb_cluster_ids_lock);\r\nreturn id;\r\n}\r\nvoid wusb_cluster_id_put(u8 id)\r\n{\r\nid = 0xff - id;\r\nBUG_ON(id >= CLUSTER_IDS);\r\nspin_lock(&wusb_cluster_ids_lock);\r\nWARN_ON(!test_bit(id, wusb_cluster_id_table));\r\nclear_bit(id, wusb_cluster_id_table);\r\nspin_unlock(&wusb_cluster_ids_lock);\r\n}\r\nvoid wusbhc_giveback_urb(struct wusbhc *wusbhc, struct urb *urb, int status)\r\n{\r\nstruct wusb_dev *wusb_dev = __wusb_dev_get_by_usb_dev(wusbhc, urb->dev);\r\nif (status == 0 && wusb_dev) {\r\nwusb_dev->entry_ts = jiffies;\r\nif (!list_empty(&wusb_dev->cack_node))\r\nqueue_work(wusbd, &wusb_dev->devconnect_acked_work);\r\nelse\r\nwusb_dev_put(wusb_dev);\r\n}\r\nusb_hcd_giveback_urb(&wusbhc->usb_hcd, urb, status);\r\n}\r\nvoid wusbhc_reset_all(struct wusbhc *wusbhc)\r\n{\r\nuwb_rc_reset_all(wusbhc->uwb_rc);\r\n}\r\nstatic int __init wusbcore_init(void)\r\n{\r\nint result;\r\nresult = wusb_crypto_init();\r\nif (result < 0)\r\ngoto error_crypto_init;\r\nwusbd = create_singlethread_workqueue("wusbd");\r\nif (wusbd == NULL) {\r\nresult = -ENOMEM;\r\nprintk(KERN_ERR "WUSB-core: Cannot create wusbd workqueue\n");\r\ngoto error_wusbd_create;\r\n}\r\nusb_register_notify(&wusb_usb_notifier);\r\nbitmap_zero(wusb_cluster_id_table, CLUSTER_IDS);\r\nset_bit(0, wusb_cluster_id_table);\r\nreturn 0;\r\nerror_wusbd_create:\r\nwusb_crypto_exit();\r\nerror_crypto_init:\r\nreturn result;\r\n}\r\nstatic void __exit wusbcore_exit(void)\r\n{\r\nclear_bit(0, wusb_cluster_id_table);\r\nif (!bitmap_empty(wusb_cluster_id_table, CLUSTER_IDS)) {\r\nchar buf[256];\r\nbitmap_scnprintf(buf, sizeof(buf), wusb_cluster_id_table,\r\nCLUSTER_IDS);\r\nprintk(KERN_ERR "BUG: WUSB Cluster IDs not released "\r\n"on exit: %s\n", buf);\r\nWARN_ON(1);\r\n}\r\nusb_unregister_notify(&wusb_usb_notifier);\r\ndestroy_workqueue(wusbd);\r\nwusb_crypto_exit();\r\n}
