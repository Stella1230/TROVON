static struct crypt_cpu *this_crypt_config(struct crypt_config *cc)\r\n{\r\nreturn this_cpu_ptr(cc->cpu);\r\n}\r\nstatic struct crypto_ablkcipher *any_tfm(struct crypt_config *cc)\r\n{\r\nreturn __this_cpu_ptr(cc->cpu)->tfms[0];\r\n}\r\nstatic int crypt_iv_plain_gen(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nmemset(iv, 0, cc->iv_size);\r\n*(__le32 *)iv = cpu_to_le32(dmreq->iv_sector & 0xffffffff);\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_plain64_gen(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nmemset(iv, 0, cc->iv_size);\r\n*(__le64 *)iv = cpu_to_le64(dmreq->iv_sector);\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_essiv_init(struct crypt_config *cc)\r\n{\r\nstruct iv_essiv_private *essiv = &cc->iv_gen_private.essiv;\r\nstruct hash_desc desc;\r\nstruct scatterlist sg;\r\nstruct crypto_cipher *essiv_tfm;\r\nint err, cpu;\r\nsg_init_one(&sg, cc->key, cc->key_size);\r\ndesc.tfm = essiv->hash_tfm;\r\ndesc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nerr = crypto_hash_digest(&desc, &sg, cc->key_size, essiv->salt);\r\nif (err)\r\nreturn err;\r\nfor_each_possible_cpu(cpu) {\r\nessiv_tfm = per_cpu_ptr(cc->cpu, cpu)->iv_private,\r\nerr = crypto_cipher_setkey(essiv_tfm, essiv->salt,\r\ncrypto_hash_digestsize(essiv->hash_tfm));\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_essiv_wipe(struct crypt_config *cc)\r\n{\r\nstruct iv_essiv_private *essiv = &cc->iv_gen_private.essiv;\r\nunsigned salt_size = crypto_hash_digestsize(essiv->hash_tfm);\r\nstruct crypto_cipher *essiv_tfm;\r\nint cpu, r, err = 0;\r\nmemset(essiv->salt, 0, salt_size);\r\nfor_each_possible_cpu(cpu) {\r\nessiv_tfm = per_cpu_ptr(cc->cpu, cpu)->iv_private;\r\nr = crypto_cipher_setkey(essiv_tfm, essiv->salt, salt_size);\r\nif (r)\r\nerr = r;\r\n}\r\nreturn err;\r\n}\r\nstatic struct crypto_cipher *setup_essiv_cpu(struct crypt_config *cc,\r\nstruct dm_target *ti,\r\nu8 *salt, unsigned saltsize)\r\n{\r\nstruct crypto_cipher *essiv_tfm;\r\nint err;\r\nessiv_tfm = crypto_alloc_cipher(cc->cipher, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(essiv_tfm)) {\r\nti->error = "Error allocating crypto tfm for ESSIV";\r\nreturn essiv_tfm;\r\n}\r\nif (crypto_cipher_blocksize(essiv_tfm) !=\r\ncrypto_ablkcipher_ivsize(any_tfm(cc))) {\r\nti->error = "Block size of ESSIV cipher does "\r\n"not match IV size of block cipher";\r\ncrypto_free_cipher(essiv_tfm);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nerr = crypto_cipher_setkey(essiv_tfm, salt, saltsize);\r\nif (err) {\r\nti->error = "Failed to set key for ESSIV cipher";\r\ncrypto_free_cipher(essiv_tfm);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn essiv_tfm;\r\n}\r\nstatic void crypt_iv_essiv_dtr(struct crypt_config *cc)\r\n{\r\nint cpu;\r\nstruct crypt_cpu *cpu_cc;\r\nstruct crypto_cipher *essiv_tfm;\r\nstruct iv_essiv_private *essiv = &cc->iv_gen_private.essiv;\r\ncrypto_free_hash(essiv->hash_tfm);\r\nessiv->hash_tfm = NULL;\r\nkzfree(essiv->salt);\r\nessiv->salt = NULL;\r\nfor_each_possible_cpu(cpu) {\r\ncpu_cc = per_cpu_ptr(cc->cpu, cpu);\r\nessiv_tfm = cpu_cc->iv_private;\r\nif (essiv_tfm)\r\ncrypto_free_cipher(essiv_tfm);\r\ncpu_cc->iv_private = NULL;\r\n}\r\n}\r\nstatic int crypt_iv_essiv_ctr(struct crypt_config *cc, struct dm_target *ti,\r\nconst char *opts)\r\n{\r\nstruct crypto_cipher *essiv_tfm = NULL;\r\nstruct crypto_hash *hash_tfm = NULL;\r\nu8 *salt = NULL;\r\nint err, cpu;\r\nif (!opts) {\r\nti->error = "Digest algorithm missing for ESSIV mode";\r\nreturn -EINVAL;\r\n}\r\nhash_tfm = crypto_alloc_hash(opts, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(hash_tfm)) {\r\nti->error = "Error initializing ESSIV hash";\r\nerr = PTR_ERR(hash_tfm);\r\ngoto bad;\r\n}\r\nsalt = kzalloc(crypto_hash_digestsize(hash_tfm), GFP_KERNEL);\r\nif (!salt) {\r\nti->error = "Error kmallocing salt storage in ESSIV";\r\nerr = -ENOMEM;\r\ngoto bad;\r\n}\r\ncc->iv_gen_private.essiv.salt = salt;\r\ncc->iv_gen_private.essiv.hash_tfm = hash_tfm;\r\nfor_each_possible_cpu(cpu) {\r\nessiv_tfm = setup_essiv_cpu(cc, ti, salt,\r\ncrypto_hash_digestsize(hash_tfm));\r\nif (IS_ERR(essiv_tfm)) {\r\ncrypt_iv_essiv_dtr(cc);\r\nreturn PTR_ERR(essiv_tfm);\r\n}\r\nper_cpu_ptr(cc->cpu, cpu)->iv_private = essiv_tfm;\r\n}\r\nreturn 0;\r\nbad:\r\nif (hash_tfm && !IS_ERR(hash_tfm))\r\ncrypto_free_hash(hash_tfm);\r\nkfree(salt);\r\nreturn err;\r\n}\r\nstatic int crypt_iv_essiv_gen(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nstruct crypto_cipher *essiv_tfm = this_crypt_config(cc)->iv_private;\r\nmemset(iv, 0, cc->iv_size);\r\n*(__le64 *)iv = cpu_to_le64(dmreq->iv_sector);\r\ncrypto_cipher_encrypt_one(essiv_tfm, iv, iv);\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_benbi_ctr(struct crypt_config *cc, struct dm_target *ti,\r\nconst char *opts)\r\n{\r\nunsigned bs = crypto_ablkcipher_blocksize(any_tfm(cc));\r\nint log = ilog2(bs);\r\nif (1 << log != bs) {\r\nti->error = "cypher blocksize is not a power of 2";\r\nreturn -EINVAL;\r\n}\r\nif (log > 9) {\r\nti->error = "cypher blocksize is > 512";\r\nreturn -EINVAL;\r\n}\r\ncc->iv_gen_private.benbi.shift = 9 - log;\r\nreturn 0;\r\n}\r\nstatic void crypt_iv_benbi_dtr(struct crypt_config *cc)\r\n{\r\n}\r\nstatic int crypt_iv_benbi_gen(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\n__be64 val;\r\nmemset(iv, 0, cc->iv_size - sizeof(u64));\r\nval = cpu_to_be64(((u64)dmreq->iv_sector << cc->iv_gen_private.benbi.shift) + 1);\r\nput_unaligned(val, (__be64 *)(iv + cc->iv_size - sizeof(u64)));\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_null_gen(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nmemset(iv, 0, cc->iv_size);\r\nreturn 0;\r\n}\r\nstatic void crypt_iv_lmk_dtr(struct crypt_config *cc)\r\n{\r\nstruct iv_lmk_private *lmk = &cc->iv_gen_private.lmk;\r\nif (lmk->hash_tfm && !IS_ERR(lmk->hash_tfm))\r\ncrypto_free_shash(lmk->hash_tfm);\r\nlmk->hash_tfm = NULL;\r\nkzfree(lmk->seed);\r\nlmk->seed = NULL;\r\n}\r\nstatic int crypt_iv_lmk_ctr(struct crypt_config *cc, struct dm_target *ti,\r\nconst char *opts)\r\n{\r\nstruct iv_lmk_private *lmk = &cc->iv_gen_private.lmk;\r\nlmk->hash_tfm = crypto_alloc_shash("md5", 0, 0);\r\nif (IS_ERR(lmk->hash_tfm)) {\r\nti->error = "Error initializing LMK hash";\r\nreturn PTR_ERR(lmk->hash_tfm);\r\n}\r\nif (cc->key_parts == cc->tfms_count) {\r\nlmk->seed = NULL;\r\nreturn 0;\r\n}\r\nlmk->seed = kzalloc(LMK_SEED_SIZE, GFP_KERNEL);\r\nif (!lmk->seed) {\r\ncrypt_iv_lmk_dtr(cc);\r\nti->error = "Error kmallocing seed storage in LMK";\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_lmk_init(struct crypt_config *cc)\r\n{\r\nstruct iv_lmk_private *lmk = &cc->iv_gen_private.lmk;\r\nint subkey_size = cc->key_size / cc->key_parts;\r\nif (lmk->seed)\r\nmemcpy(lmk->seed, cc->key + (cc->tfms_count * subkey_size),\r\ncrypto_shash_digestsize(lmk->hash_tfm));\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_lmk_wipe(struct crypt_config *cc)\r\n{\r\nstruct iv_lmk_private *lmk = &cc->iv_gen_private.lmk;\r\nif (lmk->seed)\r\nmemset(lmk->seed, 0, LMK_SEED_SIZE);\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_lmk_one(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq,\r\nu8 *data)\r\n{\r\nstruct iv_lmk_private *lmk = &cc->iv_gen_private.lmk;\r\nstruct {\r\nstruct shash_desc desc;\r\nchar ctx[crypto_shash_descsize(lmk->hash_tfm)];\r\n} sdesc;\r\nstruct md5_state md5state;\r\nu32 buf[4];\r\nint i, r;\r\nsdesc.desc.tfm = lmk->hash_tfm;\r\nsdesc.desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nr = crypto_shash_init(&sdesc.desc);\r\nif (r)\r\nreturn r;\r\nif (lmk->seed) {\r\nr = crypto_shash_update(&sdesc.desc, lmk->seed, LMK_SEED_SIZE);\r\nif (r)\r\nreturn r;\r\n}\r\nr = crypto_shash_update(&sdesc.desc, data + 16, 16 * 31);\r\nif (r)\r\nreturn r;\r\nbuf[0] = cpu_to_le32(dmreq->iv_sector & 0xFFFFFFFF);\r\nbuf[1] = cpu_to_le32((((u64)dmreq->iv_sector >> 32) & 0x00FFFFFF) | 0x80000000);\r\nbuf[2] = cpu_to_le32(4024);\r\nbuf[3] = 0;\r\nr = crypto_shash_update(&sdesc.desc, (u8 *)buf, sizeof(buf));\r\nif (r)\r\nreturn r;\r\nr = crypto_shash_export(&sdesc.desc, &md5state);\r\nif (r)\r\nreturn r;\r\nfor (i = 0; i < MD5_HASH_WORDS; i++)\r\n__cpu_to_le32s(&md5state.hash[i]);\r\nmemcpy(iv, &md5state.hash, cc->iv_size);\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_lmk_gen(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nu8 *src;\r\nint r = 0;\r\nif (bio_data_dir(dmreq->ctx->bio_in) == WRITE) {\r\nsrc = kmap_atomic(sg_page(&dmreq->sg_in), KM_USER0);\r\nr = crypt_iv_lmk_one(cc, iv, dmreq, src + dmreq->sg_in.offset);\r\nkunmap_atomic(src, KM_USER0);\r\n} else\r\nmemset(iv, 0, cc->iv_size);\r\nreturn r;\r\n}\r\nstatic int crypt_iv_lmk_post(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nu8 *dst;\r\nint r;\r\nif (bio_data_dir(dmreq->ctx->bio_in) == WRITE)\r\nreturn 0;\r\ndst = kmap_atomic(sg_page(&dmreq->sg_out), KM_USER0);\r\nr = crypt_iv_lmk_one(cc, iv, dmreq, dst + dmreq->sg_out.offset);\r\nif (!r)\r\ncrypto_xor(dst + dmreq->sg_out.offset, iv, cc->iv_size);\r\nkunmap_atomic(dst, KM_USER0);\r\nreturn r;\r\n}\r\nstatic void crypt_convert_init(struct crypt_config *cc,\r\nstruct convert_context *ctx,\r\nstruct bio *bio_out, struct bio *bio_in,\r\nsector_t sector)\r\n{\r\nctx->bio_in = bio_in;\r\nctx->bio_out = bio_out;\r\nctx->offset_in = 0;\r\nctx->offset_out = 0;\r\nctx->idx_in = bio_in ? bio_in->bi_idx : 0;\r\nctx->idx_out = bio_out ? bio_out->bi_idx : 0;\r\nctx->sector = sector + cc->iv_offset;\r\ninit_completion(&ctx->restart);\r\n}\r\nstatic struct dm_crypt_request *dmreq_of_req(struct crypt_config *cc,\r\nstruct ablkcipher_request *req)\r\n{\r\nreturn (struct dm_crypt_request *)((char *)req + cc->dmreq_start);\r\n}\r\nstatic struct ablkcipher_request *req_of_dmreq(struct crypt_config *cc,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nreturn (struct ablkcipher_request *)((char *)dmreq - cc->dmreq_start);\r\n}\r\nstatic u8 *iv_of_dmreq(struct crypt_config *cc,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nreturn (u8 *)ALIGN((unsigned long)(dmreq + 1),\r\ncrypto_ablkcipher_alignmask(any_tfm(cc)) + 1);\r\n}\r\nstatic int crypt_convert_block(struct crypt_config *cc,\r\nstruct convert_context *ctx,\r\nstruct ablkcipher_request *req)\r\n{\r\nstruct bio_vec *bv_in = bio_iovec_idx(ctx->bio_in, ctx->idx_in);\r\nstruct bio_vec *bv_out = bio_iovec_idx(ctx->bio_out, ctx->idx_out);\r\nstruct dm_crypt_request *dmreq;\r\nu8 *iv;\r\nint r = 0;\r\ndmreq = dmreq_of_req(cc, req);\r\niv = iv_of_dmreq(cc, dmreq);\r\ndmreq->iv_sector = ctx->sector;\r\ndmreq->ctx = ctx;\r\nsg_init_table(&dmreq->sg_in, 1);\r\nsg_set_page(&dmreq->sg_in, bv_in->bv_page, 1 << SECTOR_SHIFT,\r\nbv_in->bv_offset + ctx->offset_in);\r\nsg_init_table(&dmreq->sg_out, 1);\r\nsg_set_page(&dmreq->sg_out, bv_out->bv_page, 1 << SECTOR_SHIFT,\r\nbv_out->bv_offset + ctx->offset_out);\r\nctx->offset_in += 1 << SECTOR_SHIFT;\r\nif (ctx->offset_in >= bv_in->bv_len) {\r\nctx->offset_in = 0;\r\nctx->idx_in++;\r\n}\r\nctx->offset_out += 1 << SECTOR_SHIFT;\r\nif (ctx->offset_out >= bv_out->bv_len) {\r\nctx->offset_out = 0;\r\nctx->idx_out++;\r\n}\r\nif (cc->iv_gen_ops) {\r\nr = cc->iv_gen_ops->generator(cc, iv, dmreq);\r\nif (r < 0)\r\nreturn r;\r\n}\r\nablkcipher_request_set_crypt(req, &dmreq->sg_in, &dmreq->sg_out,\r\n1 << SECTOR_SHIFT, iv);\r\nif (bio_data_dir(ctx->bio_in) == WRITE)\r\nr = crypto_ablkcipher_encrypt(req);\r\nelse\r\nr = crypto_ablkcipher_decrypt(req);\r\nif (!r && cc->iv_gen_ops && cc->iv_gen_ops->post)\r\nr = cc->iv_gen_ops->post(cc, iv, dmreq);\r\nreturn r;\r\n}\r\nstatic void crypt_alloc_req(struct crypt_config *cc,\r\nstruct convert_context *ctx)\r\n{\r\nstruct crypt_cpu *this_cc = this_crypt_config(cc);\r\nunsigned key_index = ctx->sector & (cc->tfms_count - 1);\r\nif (!this_cc->req)\r\nthis_cc->req = mempool_alloc(cc->req_pool, GFP_NOIO);\r\nablkcipher_request_set_tfm(this_cc->req, this_cc->tfms[key_index]);\r\nablkcipher_request_set_callback(this_cc->req,\r\nCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\r\nkcryptd_async_done, dmreq_of_req(cc, this_cc->req));\r\n}\r\nstatic int crypt_convert(struct crypt_config *cc,\r\nstruct convert_context *ctx)\r\n{\r\nstruct crypt_cpu *this_cc = this_crypt_config(cc);\r\nint r;\r\natomic_set(&ctx->pending, 1);\r\nwhile(ctx->idx_in < ctx->bio_in->bi_vcnt &&\r\nctx->idx_out < ctx->bio_out->bi_vcnt) {\r\ncrypt_alloc_req(cc, ctx);\r\natomic_inc(&ctx->pending);\r\nr = crypt_convert_block(cc, ctx, this_cc->req);\r\nswitch (r) {\r\ncase -EBUSY:\r\nwait_for_completion(&ctx->restart);\r\nINIT_COMPLETION(ctx->restart);\r\ncase -EINPROGRESS:\r\nthis_cc->req = NULL;\r\nctx->sector++;\r\ncontinue;\r\ncase 0:\r\natomic_dec(&ctx->pending);\r\nctx->sector++;\r\ncond_resched();\r\ncontinue;\r\ndefault:\r\natomic_dec(&ctx->pending);\r\nreturn r;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void dm_crypt_bio_destructor(struct bio *bio)\r\n{\r\nstruct dm_crypt_io *io = bio->bi_private;\r\nstruct crypt_config *cc = io->target->private;\r\nbio_free(bio, cc->bs);\r\n}\r\nstatic struct bio *crypt_alloc_buffer(struct dm_crypt_io *io, unsigned size,\r\nunsigned *out_of_pages)\r\n{\r\nstruct crypt_config *cc = io->target->private;\r\nstruct bio *clone;\r\nunsigned int nr_iovecs = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\ngfp_t gfp_mask = GFP_NOIO | __GFP_HIGHMEM;\r\nunsigned i, len;\r\nstruct page *page;\r\nclone = bio_alloc_bioset(GFP_NOIO, nr_iovecs, cc->bs);\r\nif (!clone)\r\nreturn NULL;\r\nclone_init(io, clone);\r\n*out_of_pages = 0;\r\nfor (i = 0; i < nr_iovecs; i++) {\r\npage = mempool_alloc(cc->page_pool, gfp_mask);\r\nif (!page) {\r\n*out_of_pages = 1;\r\nbreak;\r\n}\r\nif (i == (MIN_BIO_PAGES - 1))\r\ngfp_mask = (gfp_mask | __GFP_NOWARN) & ~__GFP_WAIT;\r\nlen = (size > PAGE_SIZE) ? PAGE_SIZE : size;\r\nif (!bio_add_page(clone, page, len, 0)) {\r\nmempool_free(page, cc->page_pool);\r\nbreak;\r\n}\r\nsize -= len;\r\n}\r\nif (!clone->bi_size) {\r\nbio_put(clone);\r\nreturn NULL;\r\n}\r\nreturn clone;\r\n}\r\nstatic void crypt_free_buffer_pages(struct crypt_config *cc, struct bio *clone)\r\n{\r\nunsigned int i;\r\nstruct bio_vec *bv;\r\nfor (i = 0; i < clone->bi_vcnt; i++) {\r\nbv = bio_iovec_idx(clone, i);\r\nBUG_ON(!bv->bv_page);\r\nmempool_free(bv->bv_page, cc->page_pool);\r\nbv->bv_page = NULL;\r\n}\r\n}\r\nstatic struct dm_crypt_io *crypt_io_alloc(struct dm_target *ti,\r\nstruct bio *bio, sector_t sector)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nstruct dm_crypt_io *io;\r\nio = mempool_alloc(cc->io_pool, GFP_NOIO);\r\nio->target = ti;\r\nio->base_bio = bio;\r\nio->sector = sector;\r\nio->error = 0;\r\nio->base_io = NULL;\r\natomic_set(&io->pending, 0);\r\nreturn io;\r\n}\r\nstatic void crypt_inc_pending(struct dm_crypt_io *io)\r\n{\r\natomic_inc(&io->pending);\r\n}\r\nstatic void crypt_dec_pending(struct dm_crypt_io *io)\r\n{\r\nstruct crypt_config *cc = io->target->private;\r\nstruct bio *base_bio = io->base_bio;\r\nstruct dm_crypt_io *base_io = io->base_io;\r\nint error = io->error;\r\nif (!atomic_dec_and_test(&io->pending))\r\nreturn;\r\nmempool_free(io, cc->io_pool);\r\nif (likely(!base_io))\r\nbio_endio(base_bio, error);\r\nelse {\r\nif (error && !base_io->error)\r\nbase_io->error = error;\r\ncrypt_dec_pending(base_io);\r\n}\r\n}\r\nstatic void crypt_endio(struct bio *clone, int error)\r\n{\r\nstruct dm_crypt_io *io = clone->bi_private;\r\nstruct crypt_config *cc = io->target->private;\r\nunsigned rw = bio_data_dir(clone);\r\nif (unlikely(!bio_flagged(clone, BIO_UPTODATE) && !error))\r\nerror = -EIO;\r\nif (rw == WRITE)\r\ncrypt_free_buffer_pages(cc, clone);\r\nbio_put(clone);\r\nif (rw == READ && !error) {\r\nkcryptd_queue_crypt(io);\r\nreturn;\r\n}\r\nif (unlikely(error))\r\nio->error = error;\r\ncrypt_dec_pending(io);\r\n}\r\nstatic void clone_init(struct dm_crypt_io *io, struct bio *clone)\r\n{\r\nstruct crypt_config *cc = io->target->private;\r\nclone->bi_private = io;\r\nclone->bi_end_io = crypt_endio;\r\nclone->bi_bdev = cc->dev->bdev;\r\nclone->bi_rw = io->base_bio->bi_rw;\r\nclone->bi_destructor = dm_crypt_bio_destructor;\r\n}\r\nstatic int kcryptd_io_read(struct dm_crypt_io *io, gfp_t gfp)\r\n{\r\nstruct crypt_config *cc = io->target->private;\r\nstruct bio *base_bio = io->base_bio;\r\nstruct bio *clone;\r\nclone = bio_alloc_bioset(gfp, bio_segments(base_bio), cc->bs);\r\nif (!clone)\r\nreturn 1;\r\ncrypt_inc_pending(io);\r\nclone_init(io, clone);\r\nclone->bi_idx = 0;\r\nclone->bi_vcnt = bio_segments(base_bio);\r\nclone->bi_size = base_bio->bi_size;\r\nclone->bi_sector = cc->start + io->sector;\r\nmemcpy(clone->bi_io_vec, bio_iovec(base_bio),\r\nsizeof(struct bio_vec) * clone->bi_vcnt);\r\ngeneric_make_request(clone);\r\nreturn 0;\r\n}\r\nstatic void kcryptd_io_write(struct dm_crypt_io *io)\r\n{\r\nstruct bio *clone = io->ctx.bio_out;\r\ngeneric_make_request(clone);\r\n}\r\nstatic void kcryptd_io(struct work_struct *work)\r\n{\r\nstruct dm_crypt_io *io = container_of(work, struct dm_crypt_io, work);\r\nif (bio_data_dir(io->base_bio) == READ) {\r\ncrypt_inc_pending(io);\r\nif (kcryptd_io_read(io, GFP_NOIO))\r\nio->error = -ENOMEM;\r\ncrypt_dec_pending(io);\r\n} else\r\nkcryptd_io_write(io);\r\n}\r\nstatic void kcryptd_queue_io(struct dm_crypt_io *io)\r\n{\r\nstruct crypt_config *cc = io->target->private;\r\nINIT_WORK(&io->work, kcryptd_io);\r\nqueue_work(cc->io_queue, &io->work);\r\n}\r\nstatic void kcryptd_crypt_write_io_submit(struct dm_crypt_io *io,\r\nint error, int async)\r\n{\r\nstruct bio *clone = io->ctx.bio_out;\r\nstruct crypt_config *cc = io->target->private;\r\nif (unlikely(error < 0)) {\r\ncrypt_free_buffer_pages(cc, clone);\r\nbio_put(clone);\r\nio->error = -EIO;\r\ncrypt_dec_pending(io);\r\nreturn;\r\n}\r\nBUG_ON(io->ctx.idx_out < clone->bi_vcnt);\r\nclone->bi_sector = cc->start + io->sector;\r\nif (async)\r\nkcryptd_queue_io(io);\r\nelse\r\ngeneric_make_request(clone);\r\n}\r\nstatic void kcryptd_crypt_write_convert(struct dm_crypt_io *io)\r\n{\r\nstruct crypt_config *cc = io->target->private;\r\nstruct bio *clone;\r\nstruct dm_crypt_io *new_io;\r\nint crypt_finished;\r\nunsigned out_of_pages = 0;\r\nunsigned remaining = io->base_bio->bi_size;\r\nsector_t sector = io->sector;\r\nint r;\r\ncrypt_inc_pending(io);\r\ncrypt_convert_init(cc, &io->ctx, NULL, io->base_bio, sector);\r\nwhile (remaining) {\r\nclone = crypt_alloc_buffer(io, remaining, &out_of_pages);\r\nif (unlikely(!clone)) {\r\nio->error = -ENOMEM;\r\nbreak;\r\n}\r\nio->ctx.bio_out = clone;\r\nio->ctx.idx_out = 0;\r\nremaining -= clone->bi_size;\r\nsector += bio_sectors(clone);\r\ncrypt_inc_pending(io);\r\nr = crypt_convert(cc, &io->ctx);\r\ncrypt_finished = atomic_dec_and_test(&io->ctx.pending);\r\nif (crypt_finished) {\r\nkcryptd_crypt_write_io_submit(io, r, 0);\r\nif (unlikely(r < 0))\r\nbreak;\r\nio->sector = sector;\r\n}\r\nif (unlikely(out_of_pages))\r\ncongestion_wait(BLK_RW_ASYNC, HZ/100);\r\nif (unlikely(!crypt_finished && remaining)) {\r\nnew_io = crypt_io_alloc(io->target, io->base_bio,\r\nsector);\r\ncrypt_inc_pending(new_io);\r\ncrypt_convert_init(cc, &new_io->ctx, NULL,\r\nio->base_bio, sector);\r\nnew_io->ctx.idx_in = io->ctx.idx_in;\r\nnew_io->ctx.offset_in = io->ctx.offset_in;\r\nif (!io->base_io)\r\nnew_io->base_io = io;\r\nelse {\r\nnew_io->base_io = io->base_io;\r\ncrypt_inc_pending(io->base_io);\r\ncrypt_dec_pending(io);\r\n}\r\nio = new_io;\r\n}\r\n}\r\ncrypt_dec_pending(io);\r\n}\r\nstatic void kcryptd_crypt_read_done(struct dm_crypt_io *io, int error)\r\n{\r\nif (unlikely(error < 0))\r\nio->error = -EIO;\r\ncrypt_dec_pending(io);\r\n}\r\nstatic void kcryptd_crypt_read_convert(struct dm_crypt_io *io)\r\n{\r\nstruct crypt_config *cc = io->target->private;\r\nint r = 0;\r\ncrypt_inc_pending(io);\r\ncrypt_convert_init(cc, &io->ctx, io->base_bio, io->base_bio,\r\nio->sector);\r\nr = crypt_convert(cc, &io->ctx);\r\nif (atomic_dec_and_test(&io->ctx.pending))\r\nkcryptd_crypt_read_done(io, r);\r\ncrypt_dec_pending(io);\r\n}\r\nstatic void kcryptd_async_done(struct crypto_async_request *async_req,\r\nint error)\r\n{\r\nstruct dm_crypt_request *dmreq = async_req->data;\r\nstruct convert_context *ctx = dmreq->ctx;\r\nstruct dm_crypt_io *io = container_of(ctx, struct dm_crypt_io, ctx);\r\nstruct crypt_config *cc = io->target->private;\r\nif (error == -EINPROGRESS) {\r\ncomplete(&ctx->restart);\r\nreturn;\r\n}\r\nif (!error && cc->iv_gen_ops && cc->iv_gen_ops->post)\r\nerror = cc->iv_gen_ops->post(cc, iv_of_dmreq(cc, dmreq), dmreq);\r\nmempool_free(req_of_dmreq(cc, dmreq), cc->req_pool);\r\nif (!atomic_dec_and_test(&ctx->pending))\r\nreturn;\r\nif (bio_data_dir(io->base_bio) == READ)\r\nkcryptd_crypt_read_done(io, error);\r\nelse\r\nkcryptd_crypt_write_io_submit(io, error, 1);\r\n}\r\nstatic void kcryptd_crypt(struct work_struct *work)\r\n{\r\nstruct dm_crypt_io *io = container_of(work, struct dm_crypt_io, work);\r\nif (bio_data_dir(io->base_bio) == READ)\r\nkcryptd_crypt_read_convert(io);\r\nelse\r\nkcryptd_crypt_write_convert(io);\r\n}\r\nstatic void kcryptd_queue_crypt(struct dm_crypt_io *io)\r\n{\r\nstruct crypt_config *cc = io->target->private;\r\nINIT_WORK(&io->work, kcryptd_crypt);\r\nqueue_work(cc->crypt_queue, &io->work);\r\n}\r\nstatic int crypt_decode_key(u8 *key, char *hex, unsigned int size)\r\n{\r\nchar buffer[3];\r\nchar *endp;\r\nunsigned int i;\r\nbuffer[2] = '\0';\r\nfor (i = 0; i < size; i++) {\r\nbuffer[0] = *hex++;\r\nbuffer[1] = *hex++;\r\nkey[i] = (u8)simple_strtoul(buffer, &endp, 16);\r\nif (endp != &buffer[2])\r\nreturn -EINVAL;\r\n}\r\nif (*hex != '\0')\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void crypt_encode_key(char *hex, u8 *key, unsigned int size)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < size; i++) {\r\nsprintf(hex, "%02x", *key);\r\nhex += 2;\r\nkey++;\r\n}\r\n}\r\nstatic void crypt_free_tfms(struct crypt_config *cc, int cpu)\r\n{\r\nstruct crypt_cpu *cpu_cc = per_cpu_ptr(cc->cpu, cpu);\r\nunsigned i;\r\nfor (i = 0; i < cc->tfms_count; i++)\r\nif (cpu_cc->tfms[i] && !IS_ERR(cpu_cc->tfms[i])) {\r\ncrypto_free_ablkcipher(cpu_cc->tfms[i]);\r\ncpu_cc->tfms[i] = NULL;\r\n}\r\n}\r\nstatic int crypt_alloc_tfms(struct crypt_config *cc, int cpu, char *ciphermode)\r\n{\r\nstruct crypt_cpu *cpu_cc = per_cpu_ptr(cc->cpu, cpu);\r\nunsigned i;\r\nint err;\r\nfor (i = 0; i < cc->tfms_count; i++) {\r\ncpu_cc->tfms[i] = crypto_alloc_ablkcipher(ciphermode, 0, 0);\r\nif (IS_ERR(cpu_cc->tfms[i])) {\r\nerr = PTR_ERR(cpu_cc->tfms[i]);\r\ncrypt_free_tfms(cc, cpu);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int crypt_setkey_allcpus(struct crypt_config *cc)\r\n{\r\nunsigned subkey_size = cc->key_size >> ilog2(cc->tfms_count);\r\nint cpu, err = 0, i, r;\r\nfor_each_possible_cpu(cpu) {\r\nfor (i = 0; i < cc->tfms_count; i++) {\r\nr = crypto_ablkcipher_setkey(per_cpu_ptr(cc->cpu, cpu)->tfms[i],\r\ncc->key + (i * subkey_size), subkey_size);\r\nif (r)\r\nerr = r;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int crypt_set_key(struct crypt_config *cc, char *key)\r\n{\r\nint r = -EINVAL;\r\nint key_string_len = strlen(key);\r\nif (cc->key_size != (key_string_len >> 1))\r\ngoto out;\r\nif (!cc->key_size && strcmp(key, "-"))\r\ngoto out;\r\nif (cc->key_size && crypt_decode_key(cc->key, key, cc->key_size) < 0)\r\ngoto out;\r\nset_bit(DM_CRYPT_KEY_VALID, &cc->flags);\r\nr = crypt_setkey_allcpus(cc);\r\nout:\r\nmemset(key, '0', key_string_len);\r\nreturn r;\r\n}\r\nstatic int crypt_wipe_key(struct crypt_config *cc)\r\n{\r\nclear_bit(DM_CRYPT_KEY_VALID, &cc->flags);\r\nmemset(&cc->key, 0, cc->key_size * sizeof(u8));\r\nreturn crypt_setkey_allcpus(cc);\r\n}\r\nstatic void crypt_dtr(struct dm_target *ti)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nstruct crypt_cpu *cpu_cc;\r\nint cpu;\r\nti->private = NULL;\r\nif (!cc)\r\nreturn;\r\nif (cc->io_queue)\r\ndestroy_workqueue(cc->io_queue);\r\nif (cc->crypt_queue)\r\ndestroy_workqueue(cc->crypt_queue);\r\nif (cc->cpu)\r\nfor_each_possible_cpu(cpu) {\r\ncpu_cc = per_cpu_ptr(cc->cpu, cpu);\r\nif (cpu_cc->req)\r\nmempool_free(cpu_cc->req, cc->req_pool);\r\ncrypt_free_tfms(cc, cpu);\r\n}\r\nif (cc->bs)\r\nbioset_free(cc->bs);\r\nif (cc->page_pool)\r\nmempool_destroy(cc->page_pool);\r\nif (cc->req_pool)\r\nmempool_destroy(cc->req_pool);\r\nif (cc->io_pool)\r\nmempool_destroy(cc->io_pool);\r\nif (cc->iv_gen_ops && cc->iv_gen_ops->dtr)\r\ncc->iv_gen_ops->dtr(cc);\r\nif (cc->dev)\r\ndm_put_device(ti, cc->dev);\r\nif (cc->cpu)\r\nfree_percpu(cc->cpu);\r\nkzfree(cc->cipher);\r\nkzfree(cc->cipher_string);\r\nkzfree(cc);\r\n}\r\nstatic int crypt_ctr_cipher(struct dm_target *ti,\r\nchar *cipher_in, char *key)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nchar *tmp, *cipher, *chainmode, *ivmode, *ivopts, *keycount;\r\nchar *cipher_api = NULL;\r\nint cpu, ret = -EINVAL;\r\nif (strchr(cipher_in, '(')) {\r\nti->error = "Bad cipher specification";\r\nreturn -EINVAL;\r\n}\r\ncc->cipher_string = kstrdup(cipher_in, GFP_KERNEL);\r\nif (!cc->cipher_string)\r\ngoto bad_mem;\r\ntmp = cipher_in;\r\nkeycount = strsep(&tmp, "-");\r\ncipher = strsep(&keycount, ":");\r\nif (!keycount)\r\ncc->tfms_count = 1;\r\nelse if (sscanf(keycount, "%u", &cc->tfms_count) != 1 ||\r\n!is_power_of_2(cc->tfms_count)) {\r\nti->error = "Bad cipher key count specification";\r\nreturn -EINVAL;\r\n}\r\ncc->key_parts = cc->tfms_count;\r\ncc->cipher = kstrdup(cipher, GFP_KERNEL);\r\nif (!cc->cipher)\r\ngoto bad_mem;\r\nchainmode = strsep(&tmp, "-");\r\nivopts = strsep(&tmp, "-");\r\nivmode = strsep(&ivopts, ":");\r\nif (tmp)\r\nDMWARN("Ignoring unexpected additional cipher options");\r\ncc->cpu = __alloc_percpu(sizeof(*(cc->cpu)) +\r\ncc->tfms_count * sizeof(*(cc->cpu->tfms)),\r\n__alignof__(struct crypt_cpu));\r\nif (!cc->cpu) {\r\nti->error = "Cannot allocate per cpu state";\r\ngoto bad_mem;\r\n}\r\nif (!chainmode || (!strcmp(chainmode, "plain") && !ivmode)) {\r\nchainmode = "cbc";\r\nivmode = "plain";\r\n}\r\nif (strcmp(chainmode, "ecb") && !ivmode) {\r\nti->error = "IV mechanism required";\r\nreturn -EINVAL;\r\n}\r\ncipher_api = kmalloc(CRYPTO_MAX_ALG_NAME, GFP_KERNEL);\r\nif (!cipher_api)\r\ngoto bad_mem;\r\nret = snprintf(cipher_api, CRYPTO_MAX_ALG_NAME,\r\n"%s(%s)", chainmode, cipher);\r\nif (ret < 0) {\r\nkfree(cipher_api);\r\ngoto bad_mem;\r\n}\r\nfor_each_possible_cpu(cpu) {\r\nret = crypt_alloc_tfms(cc, cpu, cipher_api);\r\nif (ret < 0) {\r\nti->error = "Error allocating crypto tfm";\r\ngoto bad;\r\n}\r\n}\r\nret = crypt_set_key(cc, key);\r\nif (ret < 0) {\r\nti->error = "Error decoding and setting key";\r\ngoto bad;\r\n}\r\ncc->iv_size = crypto_ablkcipher_ivsize(any_tfm(cc));\r\nif (cc->iv_size)\r\ncc->iv_size = max(cc->iv_size,\r\n(unsigned int)(sizeof(u64) / sizeof(u8)));\r\nelse if (ivmode) {\r\nDMWARN("Selected cipher does not support IVs");\r\nivmode = NULL;\r\n}\r\nif (ivmode == NULL)\r\ncc->iv_gen_ops = NULL;\r\nelse if (strcmp(ivmode, "plain") == 0)\r\ncc->iv_gen_ops = &crypt_iv_plain_ops;\r\nelse if (strcmp(ivmode, "plain64") == 0)\r\ncc->iv_gen_ops = &crypt_iv_plain64_ops;\r\nelse if (strcmp(ivmode, "essiv") == 0)\r\ncc->iv_gen_ops = &crypt_iv_essiv_ops;\r\nelse if (strcmp(ivmode, "benbi") == 0)\r\ncc->iv_gen_ops = &crypt_iv_benbi_ops;\r\nelse if (strcmp(ivmode, "null") == 0)\r\ncc->iv_gen_ops = &crypt_iv_null_ops;\r\nelse if (strcmp(ivmode, "lmk") == 0) {\r\ncc->iv_gen_ops = &crypt_iv_lmk_ops;\r\nif (cc->key_size % cc->key_parts)\r\ncc->key_parts++;\r\n} else {\r\nret = -EINVAL;\r\nti->error = "Invalid IV mode";\r\ngoto bad;\r\n}\r\nif (cc->iv_gen_ops && cc->iv_gen_ops->ctr) {\r\nret = cc->iv_gen_ops->ctr(cc, ti, ivopts);\r\nif (ret < 0) {\r\nti->error = "Error creating IV";\r\ngoto bad;\r\n}\r\n}\r\nif (cc->iv_gen_ops && cc->iv_gen_ops->init) {\r\nret = cc->iv_gen_ops->init(cc);\r\nif (ret < 0) {\r\nti->error = "Error initialising IV";\r\ngoto bad;\r\n}\r\n}\r\nret = 0;\r\nbad:\r\nkfree(cipher_api);\r\nreturn ret;\r\nbad_mem:\r\nti->error = "Cannot allocate cipher strings";\r\nreturn -ENOMEM;\r\n}\r\nstatic int crypt_ctr(struct dm_target *ti, unsigned int argc, char **argv)\r\n{\r\nstruct crypt_config *cc;\r\nunsigned int key_size, opt_params;\r\nunsigned long long tmpll;\r\nint ret;\r\nstruct dm_arg_set as;\r\nconst char *opt_string;\r\nstatic struct dm_arg _args[] = {\r\n{0, 1, "Invalid number of feature args"},\r\n};\r\nif (argc < 5) {\r\nti->error = "Not enough arguments";\r\nreturn -EINVAL;\r\n}\r\nkey_size = strlen(argv[1]) >> 1;\r\ncc = kzalloc(sizeof(*cc) + key_size * sizeof(u8), GFP_KERNEL);\r\nif (!cc) {\r\nti->error = "Cannot allocate encryption context";\r\nreturn -ENOMEM;\r\n}\r\ncc->key_size = key_size;\r\nti->private = cc;\r\nret = crypt_ctr_cipher(ti, argv[0], argv[1]);\r\nif (ret < 0)\r\ngoto bad;\r\nret = -ENOMEM;\r\ncc->io_pool = mempool_create_slab_pool(MIN_IOS, _crypt_io_pool);\r\nif (!cc->io_pool) {\r\nti->error = "Cannot allocate crypt io mempool";\r\ngoto bad;\r\n}\r\ncc->dmreq_start = sizeof(struct ablkcipher_request);\r\ncc->dmreq_start += crypto_ablkcipher_reqsize(any_tfm(cc));\r\ncc->dmreq_start = ALIGN(cc->dmreq_start, crypto_tfm_ctx_alignment());\r\ncc->dmreq_start += crypto_ablkcipher_alignmask(any_tfm(cc)) &\r\n~(crypto_tfm_ctx_alignment() - 1);\r\ncc->req_pool = mempool_create_kmalloc_pool(MIN_IOS, cc->dmreq_start +\r\nsizeof(struct dm_crypt_request) + cc->iv_size);\r\nif (!cc->req_pool) {\r\nti->error = "Cannot allocate crypt request mempool";\r\ngoto bad;\r\n}\r\ncc->page_pool = mempool_create_page_pool(MIN_POOL_PAGES, 0);\r\nif (!cc->page_pool) {\r\nti->error = "Cannot allocate page mempool";\r\ngoto bad;\r\n}\r\ncc->bs = bioset_create(MIN_IOS, 0);\r\nif (!cc->bs) {\r\nti->error = "Cannot allocate crypt bioset";\r\ngoto bad;\r\n}\r\nret = -EINVAL;\r\nif (sscanf(argv[2], "%llu", &tmpll) != 1) {\r\nti->error = "Invalid iv_offset sector";\r\ngoto bad;\r\n}\r\ncc->iv_offset = tmpll;\r\nif (dm_get_device(ti, argv[3], dm_table_get_mode(ti->table), &cc->dev)) {\r\nti->error = "Device lookup failed";\r\ngoto bad;\r\n}\r\nif (sscanf(argv[4], "%llu", &tmpll) != 1) {\r\nti->error = "Invalid device sector";\r\ngoto bad;\r\n}\r\ncc->start = tmpll;\r\nargv += 5;\r\nargc -= 5;\r\nif (argc) {\r\nas.argc = argc;\r\nas.argv = argv;\r\nret = dm_read_arg_group(_args, &as, &opt_params, &ti->error);\r\nif (ret)\r\ngoto bad;\r\nopt_string = dm_shift_arg(&as);\r\nif (opt_params == 1 && opt_string &&\r\n!strcasecmp(opt_string, "allow_discards"))\r\nti->num_discard_requests = 1;\r\nelse if (opt_params) {\r\nret = -EINVAL;\r\nti->error = "Invalid feature arguments";\r\ngoto bad;\r\n}\r\n}\r\nret = -ENOMEM;\r\ncc->io_queue = alloc_workqueue("kcryptd_io",\r\nWQ_NON_REENTRANT|\r\nWQ_MEM_RECLAIM,\r\n1);\r\nif (!cc->io_queue) {\r\nti->error = "Couldn't create kcryptd io queue";\r\ngoto bad;\r\n}\r\ncc->crypt_queue = alloc_workqueue("kcryptd",\r\nWQ_NON_REENTRANT|\r\nWQ_CPU_INTENSIVE|\r\nWQ_MEM_RECLAIM,\r\n1);\r\nif (!cc->crypt_queue) {\r\nti->error = "Couldn't create kcryptd queue";\r\ngoto bad;\r\n}\r\nti->num_flush_requests = 1;\r\nti->discard_zeroes_data_unsupported = 1;\r\nreturn 0;\r\nbad:\r\ncrypt_dtr(ti);\r\nreturn ret;\r\n}\r\nstatic int crypt_map(struct dm_target *ti, struct bio *bio,\r\nunion map_info *map_context)\r\n{\r\nstruct dm_crypt_io *io;\r\nstruct crypt_config *cc;\r\nif (unlikely(bio->bi_rw & (REQ_FLUSH | REQ_DISCARD))) {\r\ncc = ti->private;\r\nbio->bi_bdev = cc->dev->bdev;\r\nif (bio_sectors(bio))\r\nbio->bi_sector = cc->start + dm_target_offset(ti, bio->bi_sector);\r\nreturn DM_MAPIO_REMAPPED;\r\n}\r\nio = crypt_io_alloc(ti, bio, dm_target_offset(ti, bio->bi_sector));\r\nif (bio_data_dir(io->base_bio) == READ) {\r\nif (kcryptd_io_read(io, GFP_NOWAIT))\r\nkcryptd_queue_io(io);\r\n} else\r\nkcryptd_queue_crypt(io);\r\nreturn DM_MAPIO_SUBMITTED;\r\n}\r\nstatic int crypt_status(struct dm_target *ti, status_type_t type,\r\nchar *result, unsigned int maxlen)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nunsigned int sz = 0;\r\nswitch (type) {\r\ncase STATUSTYPE_INFO:\r\nresult[0] = '\0';\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nDMEMIT("%s ", cc->cipher_string);\r\nif (cc->key_size > 0) {\r\nif ((maxlen - sz) < ((cc->key_size << 1) + 1))\r\nreturn -ENOMEM;\r\ncrypt_encode_key(result + sz, cc->key, cc->key_size);\r\nsz += cc->key_size << 1;\r\n} else {\r\nif (sz >= maxlen)\r\nreturn -ENOMEM;\r\nresult[sz++] = '-';\r\n}\r\nDMEMIT(" %llu %s %llu", (unsigned long long)cc->iv_offset,\r\ncc->dev->name, (unsigned long long)cc->start);\r\nif (ti->num_discard_requests)\r\nDMEMIT(" 1 allow_discards");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void crypt_postsuspend(struct dm_target *ti)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nset_bit(DM_CRYPT_SUSPENDED, &cc->flags);\r\n}\r\nstatic int crypt_preresume(struct dm_target *ti)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nif (!test_bit(DM_CRYPT_KEY_VALID, &cc->flags)) {\r\nDMERR("aborting resume - crypt key is not set.");\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic void crypt_resume(struct dm_target *ti)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nclear_bit(DM_CRYPT_SUSPENDED, &cc->flags);\r\n}\r\nstatic int crypt_message(struct dm_target *ti, unsigned argc, char **argv)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nint ret = -EINVAL;\r\nif (argc < 2)\r\ngoto error;\r\nif (!strcasecmp(argv[0], "key")) {\r\nif (!test_bit(DM_CRYPT_SUSPENDED, &cc->flags)) {\r\nDMWARN("not suspended during key manipulation.");\r\nreturn -EINVAL;\r\n}\r\nif (argc == 3 && !strcasecmp(argv[1], "set")) {\r\nret = crypt_set_key(cc, argv[2]);\r\nif (ret)\r\nreturn ret;\r\nif (cc->iv_gen_ops && cc->iv_gen_ops->init)\r\nret = cc->iv_gen_ops->init(cc);\r\nreturn ret;\r\n}\r\nif (argc == 2 && !strcasecmp(argv[1], "wipe")) {\r\nif (cc->iv_gen_ops && cc->iv_gen_ops->wipe) {\r\nret = cc->iv_gen_ops->wipe(cc);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn crypt_wipe_key(cc);\r\n}\r\n}\r\nerror:\r\nDMWARN("unrecognised message received.");\r\nreturn -EINVAL;\r\n}\r\nstatic int crypt_merge(struct dm_target *ti, struct bvec_merge_data *bvm,\r\nstruct bio_vec *biovec, int max_size)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nstruct request_queue *q = bdev_get_queue(cc->dev->bdev);\r\nif (!q->merge_bvec_fn)\r\nreturn max_size;\r\nbvm->bi_bdev = cc->dev->bdev;\r\nbvm->bi_sector = cc->start + dm_target_offset(ti, bvm->bi_sector);\r\nreturn min(max_size, q->merge_bvec_fn(q, bvm, biovec));\r\n}\r\nstatic int crypt_iterate_devices(struct dm_target *ti,\r\niterate_devices_callout_fn fn, void *data)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nreturn fn(ti, cc->dev, cc->start, ti->len, data);\r\n}\r\nstatic int __init dm_crypt_init(void)\r\n{\r\nint r;\r\n_crypt_io_pool = KMEM_CACHE(dm_crypt_io, 0);\r\nif (!_crypt_io_pool)\r\nreturn -ENOMEM;\r\nr = dm_register_target(&crypt_target);\r\nif (r < 0) {\r\nDMERR("register failed %d", r);\r\nkmem_cache_destroy(_crypt_io_pool);\r\n}\r\nreturn r;\r\n}\r\nstatic void __exit dm_crypt_exit(void)\r\n{\r\ndm_unregister_target(&crypt_target);\r\nkmem_cache_destroy(_crypt_io_pool);\r\n}
