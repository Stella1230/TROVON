static int grip_gpp_read_packet(struct gameport *gameport, int shift, unsigned int *data)\r\n{\r\nunsigned long flags;\r\nunsigned char u, v;\r\nunsigned int t;\r\nint i;\r\nint strobe = gameport_time(gameport, GRIP_STROBE_GPP);\r\ndata[0] = 0;\r\nt = strobe;\r\ni = 0;\r\nlocal_irq_save(flags);\r\nv = gameport_read(gameport) >> shift;\r\ndo {\r\nt--;\r\nu = v; v = (gameport_read(gameport) >> shift) & 3;\r\nif (~v & u & 1) {\r\ndata[0] |= (v >> 1) << i++;\r\nt = strobe;\r\n}\r\n} while (i < GRIP_LENGTH_GPP && t > 0);\r\nlocal_irq_restore(flags);\r\nif (i < GRIP_LENGTH_GPP) return -1;\r\nfor (i = 0; i < GRIP_LENGTH_GPP && (data[0] & 0xfe4210) ^ 0x7c0000; i++)\r\ndata[0] = data[0] >> 1 | (data[0] & 1) << (GRIP_LENGTH_GPP - 1);\r\nreturn -(i == GRIP_LENGTH_GPP);\r\n}\r\nstatic int grip_xt_read_packet(struct gameport *gameport, int shift, unsigned int *data)\r\n{\r\nunsigned int i, j, buf, crc;\r\nunsigned char u, v, w;\r\nunsigned long flags;\r\nunsigned int t;\r\nchar status;\r\nint strobe = gameport_time(gameport, GRIP_STROBE_XT);\r\ndata[0] = data[1] = data[2] = data[3] = 0;\r\nstatus = buf = i = j = 0;\r\nt = strobe;\r\nlocal_irq_save(flags);\r\nv = w = (gameport_read(gameport) >> shift) & 3;\r\ndo {\r\nt--;\r\nu = (gameport_read(gameport) >> shift) & 3;\r\nif (u ^ v) {\r\nif ((u ^ v) & 1) {\r\nbuf = (buf << 1) | (u >> 1);\r\nt = strobe;\r\ni++;\r\n} else\r\nif ((((u ^ v) & (v ^ w)) >> 1) & ~(u | v | w) & 1) {\r\nif (i == 20) {\r\ncrc = buf ^ (buf >> 7) ^ (buf >> 14);\r\nif (!((crc ^ (0x25cb9e70 >> ((crc >> 2) & 0x1c))) & 0xf)) {\r\ndata[buf >> 18] = buf >> 4;\r\nstatus |= 1 << (buf >> 18);\r\n}\r\nj++;\r\n}\r\nt = strobe;\r\nbuf = 0;\r\ni = 0;\r\n}\r\nw = v;\r\nv = u;\r\n}\r\n} while (status != 0xf && i < GRIP_MAX_BITS_XT && j < GRIP_MAX_CHUNKS_XT && t > 0);\r\nlocal_irq_restore(flags);\r\nreturn -(status != 0xf);\r\n}\r\nstatic void grip_poll(struct gameport *gameport)\r\n{\r\nstruct grip *grip = gameport_get_drvdata(gameport);\r\nunsigned int data[GRIP_LENGTH_XT];\r\nstruct input_dev *dev;\r\nint i, j;\r\nfor (i = 0; i < 2; i++) {\r\ndev = grip->dev[i];\r\nif (!dev)\r\ncontinue;\r\ngrip->reads++;\r\nswitch (grip->mode[i]) {\r\ncase GRIP_MODE_GPP:\r\nif (grip_gpp_read_packet(grip->gameport, (i << 1) + 4, data)) {\r\ngrip->bads++;\r\nbreak;\r\n}\r\ninput_report_abs(dev, ABS_X, ((*data >> 15) & 1) - ((*data >> 16) & 1));\r\ninput_report_abs(dev, ABS_Y, ((*data >> 13) & 1) - ((*data >> 12) & 1));\r\nfor (j = 0; j < 12; j++)\r\nif (grip_btn_gpp[j])\r\ninput_report_key(dev, grip_btn_gpp[j], (*data >> j) & 1);\r\nbreak;\r\ncase GRIP_MODE_BD:\r\nif (grip_xt_read_packet(grip->gameport, (i << 1) + 4, data)) {\r\ngrip->bads++;\r\nbreak;\r\n}\r\ninput_report_abs(dev, ABS_X, (data[0] >> 2) & 0x3f);\r\ninput_report_abs(dev, ABS_Y, 63 - ((data[0] >> 8) & 0x3f));\r\ninput_report_abs(dev, ABS_THROTTLE, (data[2] >> 8) & 0x3f);\r\ninput_report_abs(dev, ABS_HAT0X, ((data[2] >> 1) & 1) - ( data[2] & 1));\r\ninput_report_abs(dev, ABS_HAT0Y, ((data[2] >> 2) & 1) - ((data[2] >> 3) & 1));\r\nfor (j = 0; j < 5; j++)\r\ninput_report_key(dev, grip_btn_bd[j], (data[3] >> (j + 4)) & 1);\r\nbreak;\r\ncase GRIP_MODE_XT:\r\nif (grip_xt_read_packet(grip->gameport, (i << 1) + 4, data)) {\r\ngrip->bads++;\r\nbreak;\r\n}\r\ninput_report_abs(dev, ABS_X, (data[0] >> 2) & 0x3f);\r\ninput_report_abs(dev, ABS_Y, 63 - ((data[0] >> 8) & 0x3f));\r\ninput_report_abs(dev, ABS_BRAKE, (data[1] >> 2) & 0x3f);\r\ninput_report_abs(dev, ABS_GAS, (data[1] >> 8) & 0x3f);\r\ninput_report_abs(dev, ABS_THROTTLE, (data[2] >> 8) & 0x3f);\r\ninput_report_abs(dev, ABS_HAT0X, ((data[2] >> 1) & 1) - ( data[2] & 1));\r\ninput_report_abs(dev, ABS_HAT0Y, ((data[2] >> 2) & 1) - ((data[2] >> 3) & 1));\r\ninput_report_abs(dev, ABS_HAT1X, ((data[2] >> 5) & 1) - ((data[2] >> 4) & 1));\r\ninput_report_abs(dev, ABS_HAT1Y, ((data[2] >> 6) & 1) - ((data[2] >> 7) & 1));\r\nfor (j = 0; j < 11; j++)\r\ninput_report_key(dev, grip_btn_xt[j], (data[3] >> (j + 3)) & 1);\r\nbreak;\r\ncase GRIP_MODE_DC:\r\nif (grip_xt_read_packet(grip->gameport, (i << 1) + 4, data)) {\r\ngrip->bads++;\r\nbreak;\r\n}\r\ninput_report_abs(dev, ABS_X, (data[0] >> 2) & 0x3f);\r\ninput_report_abs(dev, ABS_Y, (data[0] >> 8) & 0x3f);\r\ninput_report_abs(dev, ABS_RX, (data[1] >> 2) & 0x3f);\r\ninput_report_abs(dev, ABS_RY, (data[1] >> 8) & 0x3f);\r\ninput_report_abs(dev, ABS_THROTTLE, (data[2] >> 8) & 0x3f);\r\ninput_report_abs(dev, ABS_HAT0X, ((data[2] >> 1) & 1) - ( data[2] & 1));\r\ninput_report_abs(dev, ABS_HAT0Y, ((data[2] >> 2) & 1) - ((data[2] >> 3) & 1));\r\nfor (j = 0; j < 9; j++)\r\ninput_report_key(dev, grip_btn_dc[j], (data[3] >> (j + 3)) & 1);\r\nbreak;\r\n}\r\ninput_sync(dev);\r\n}\r\n}\r\nstatic int grip_open(struct input_dev *dev)\r\n{\r\nstruct grip *grip = input_get_drvdata(dev);\r\ngameport_start_polling(grip->gameport);\r\nreturn 0;\r\n}\r\nstatic void grip_close(struct input_dev *dev)\r\n{\r\nstruct grip *grip = input_get_drvdata(dev);\r\ngameport_stop_polling(grip->gameport);\r\n}\r\nstatic int grip_connect(struct gameport *gameport, struct gameport_driver *drv)\r\n{\r\nstruct grip *grip;\r\nstruct input_dev *input_dev;\r\nunsigned int data[GRIP_LENGTH_XT];\r\nint i, j, t;\r\nint err;\r\nif (!(grip = kzalloc(sizeof(struct grip), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\ngrip->gameport = gameport;\r\ngameport_set_drvdata(gameport, grip);\r\nerr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\r\nif (err)\r\ngoto fail1;\r\nfor (i = 0; i < 2; i++) {\r\nif (!grip_gpp_read_packet(gameport, (i << 1) + 4, data)) {\r\ngrip->mode[i] = GRIP_MODE_GPP;\r\ncontinue;\r\n}\r\nif (!grip_xt_read_packet(gameport, (i << 1) + 4, data)) {\r\nif (!(data[3] & 7)) {\r\ngrip->mode[i] = GRIP_MODE_BD;\r\ncontinue;\r\n}\r\nif (!(data[2] & 0xf0)) {\r\ngrip->mode[i] = GRIP_MODE_XT;\r\ncontinue;\r\n}\r\ngrip->mode[i] = GRIP_MODE_DC;\r\ncontinue;\r\n}\r\n}\r\nif (!grip->mode[0] && !grip->mode[1]) {\r\nerr = -ENODEV;\r\ngoto fail2;\r\n}\r\ngameport_set_poll_handler(gameport, grip_poll);\r\ngameport_set_poll_interval(gameport, 20);\r\nfor (i = 0; i < 2; i++) {\r\nif (!grip->mode[i])\r\ncontinue;\r\ngrip->dev[i] = input_dev = input_allocate_device();\r\nif (!input_dev) {\r\nerr = -ENOMEM;\r\ngoto fail3;\r\n}\r\nsnprintf(grip->phys[i], sizeof(grip->phys[i]),\r\n"%s/input%d", gameport->phys, i);\r\ninput_dev->name = grip_name[grip->mode[i]];\r\ninput_dev->phys = grip->phys[i];\r\ninput_dev->id.bustype = BUS_GAMEPORT;\r\ninput_dev->id.vendor = GAMEPORT_ID_VENDOR_GRAVIS;\r\ninput_dev->id.product = grip->mode[i];\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &gameport->dev;\r\ninput_set_drvdata(input_dev, grip);\r\ninput_dev->open = grip_open;\r\ninput_dev->close = grip_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nfor (j = 0; (t = grip_abs[grip->mode[i]][j]) >= 0; j++) {\r\nif (j < grip_cen[grip->mode[i]])\r\ninput_set_abs_params(input_dev, t, 14, 52, 1, 2);\r\nelse if (j < grip_anx[grip->mode[i]])\r\ninput_set_abs_params(input_dev, t, 3, 57, 1, 0);\r\nelse\r\ninput_set_abs_params(input_dev, t, -1, 1, 0, 0);\r\n}\r\nfor (j = 0; (t = grip_btn[grip->mode[i]][j]) >= 0; j++)\r\nif (t > 0)\r\nset_bit(t, input_dev->keybit);\r\nerr = input_register_device(grip->dev[i]);\r\nif (err)\r\ngoto fail4;\r\n}\r\nreturn 0;\r\nfail4: input_free_device(grip->dev[i]);\r\nfail3: while (--i >= 0)\r\nif (grip->dev[i])\r\ninput_unregister_device(grip->dev[i]);\r\nfail2: gameport_close(gameport);\r\nfail1: gameport_set_drvdata(gameport, NULL);\r\nkfree(grip);\r\nreturn err;\r\n}\r\nstatic void grip_disconnect(struct gameport *gameport)\r\n{\r\nstruct grip *grip = gameport_get_drvdata(gameport);\r\nint i;\r\nfor (i = 0; i < 2; i++)\r\nif (grip->dev[i])\r\ninput_unregister_device(grip->dev[i]);\r\ngameport_close(gameport);\r\ngameport_set_drvdata(gameport, NULL);\r\nkfree(grip);\r\n}\r\nstatic int __init grip_init(void)\r\n{\r\nreturn gameport_register_driver(&grip_drv);\r\n}\r\nstatic void __exit grip_exit(void)\r\n{\r\ngameport_unregister_driver(&grip_drv);\r\n}
