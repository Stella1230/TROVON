static const struct apple_key_translation *apple_find_translation(\r\nconst struct apple_key_translation *table, u16 from)\r\n{\r\nconst struct apple_key_translation *trans;\r\nfor (trans = table; trans->from; trans++)\r\nif (trans->from == from)\r\nreturn trans;\r\nreturn NULL;\r\n}\r\nstatic int hidinput_apple_event(struct hid_device *hid, struct input_dev *input,\r\nstruct hid_usage *usage, __s32 value)\r\n{\r\nstruct apple_sc *asc = hid_get_drvdata(hid);\r\nconst struct apple_key_translation *trans, *table;\r\nif (usage->code == KEY_FN) {\r\nasc->fn_on = !!value;\r\ninput_event(input, usage->type, usage->code, value);\r\nreturn 1;\r\n}\r\nif (fnmode) {\r\nint do_translate;\r\nif (hid->product >= USB_DEVICE_ID_APPLE_WELLSPRING4_ANSI &&\r\nhid->product <= USB_DEVICE_ID_APPLE_WELLSPRING4A_JIS)\r\ntable = macbookair_fn_keys;\r\nelse if (hid->product < 0x21d || hid->product >= 0x300)\r\ntable = powerbook_fn_keys;\r\nelse\r\ntable = apple_fn_keys;\r\ntrans = apple_find_translation (table, usage->code);\r\nif (trans) {\r\nif (test_bit(usage->code, asc->pressed_fn))\r\ndo_translate = 1;\r\nelse if (trans->flags & APPLE_FLAG_FKEY)\r\ndo_translate = (fnmode == 2 && asc->fn_on) ||\r\n(fnmode == 1 && !asc->fn_on);\r\nelse\r\ndo_translate = asc->fn_on;\r\nif (do_translate) {\r\nif (value)\r\nset_bit(usage->code, asc->pressed_fn);\r\nelse\r\nclear_bit(usage->code, asc->pressed_fn);\r\ninput_event(input, usage->type, trans->to,\r\nvalue);\r\nreturn 1;\r\n}\r\n}\r\nif (asc->quirks & APPLE_NUMLOCK_EMULATION &&\r\n(test_bit(usage->code, asc->pressed_numlock) ||\r\ntest_bit(LED_NUML, input->led))) {\r\ntrans = apple_find_translation(powerbook_numlock_keys,\r\nusage->code);\r\nif (trans) {\r\nif (value)\r\nset_bit(usage->code,\r\nasc->pressed_numlock);\r\nelse\r\nclear_bit(usage->code,\r\nasc->pressed_numlock);\r\ninput_event(input, usage->type, trans->to,\r\nvalue);\r\n}\r\nreturn 1;\r\n}\r\n}\r\nif (iso_layout) {\r\nif (asc->quirks & APPLE_ISO_KEYBOARD) {\r\ntrans = apple_find_translation(apple_iso_keyboard, usage->code);\r\nif (trans) {\r\ninput_event(input, usage->type, trans->to, value);\r\nreturn 1;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int apple_event(struct hid_device *hdev, struct hid_field *field,\r\nstruct hid_usage *usage, __s32 value)\r\n{\r\nstruct apple_sc *asc = hid_get_drvdata(hdev);\r\nif (!(hdev->claimed & HID_CLAIMED_INPUT) || !field->hidinput ||\r\n!usage->type)\r\nreturn 0;\r\nif ((asc->quirks & APPLE_INVERT_HWHEEL) &&\r\nusage->code == REL_HWHEEL) {\r\ninput_event(field->hidinput->input, usage->type, usage->code,\r\n-value);\r\nreturn 1;\r\n}\r\nif ((asc->quirks & APPLE_HAS_FN) &&\r\nhidinput_apple_event(hdev, field->hidinput->input,\r\nusage, value))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic __u8 *apple_report_fixup(struct hid_device *hdev, __u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\nstruct apple_sc *asc = hid_get_drvdata(hdev);\r\nif ((asc->quirks & APPLE_RDESC_JIS) && *rsize >= 60 &&\r\nrdesc[53] == 0x65 && rdesc[59] == 0x65) {\r\nhid_info(hdev,\r\n"fixing up MacBook JIS keyboard report descriptor\n");\r\nrdesc[53] = rdesc[59] = 0xe7;\r\n}\r\nreturn rdesc;\r\n}\r\nstatic void apple_setup_input(struct input_dev *input)\r\n{\r\nconst struct apple_key_translation *trans;\r\nset_bit(KEY_NUMLOCK, input->keybit);\r\nfor (trans = apple_fn_keys; trans->from; trans++)\r\nset_bit(trans->to, input->keybit);\r\nfor (trans = powerbook_fn_keys; trans->from; trans++)\r\nset_bit(trans->to, input->keybit);\r\nfor (trans = powerbook_numlock_keys; trans->from; trans++)\r\nset_bit(trans->to, input->keybit);\r\nfor (trans = apple_iso_keyboard; trans->from; trans++)\r\nset_bit(trans->to, input->keybit);\r\n}\r\nstatic int apple_input_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nif (usage->hid == (HID_UP_CUSTOM | 0x0003)) {\r\nset_bit(EV_REP, hi->input->evbit);\r\nhid_map_usage_clear(hi, usage, bit, max, EV_KEY, KEY_FN);\r\napple_setup_input(hi->input);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int apple_input_mapped(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nstruct apple_sc *asc = hid_get_drvdata(hdev);\r\nif (asc->quirks & APPLE_MIGHTYMOUSE) {\r\nif (usage->hid == HID_GD_Z)\r\nhid_map_usage(hi, usage, bit, max, EV_REL, REL_HWHEEL);\r\nelse if (usage->code == BTN_1)\r\nhid_map_usage(hi, usage, bit, max, EV_KEY, BTN_2);\r\nelse if (usage->code == BTN_2)\r\nhid_map_usage(hi, usage, bit, max, EV_KEY, BTN_1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int apple_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nunsigned long quirks = id->driver_data;\r\nstruct apple_sc *asc;\r\nunsigned int connect_mask = HID_CONNECT_DEFAULT;\r\nint ret;\r\nasc = kzalloc(sizeof(*asc), GFP_KERNEL);\r\nif (asc == NULL) {\r\nhid_err(hdev, "can't alloc apple descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\nasc->quirks = quirks;\r\nhid_set_drvdata(hdev, asc);\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\ngoto err_free;\r\n}\r\nif (quirks & APPLE_HIDDEV)\r\nconnect_mask |= HID_CONNECT_HIDDEV_FORCE;\r\nif (quirks & APPLE_IGNORE_HIDINPUT)\r\nconnect_mask &= ~HID_CONNECT_HIDINPUT;\r\nret = hid_hw_start(hdev, connect_mask);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\ngoto err_free;\r\n}\r\nreturn 0;\r\nerr_free:\r\nkfree(asc);\r\nreturn ret;\r\n}\r\nstatic void apple_remove(struct hid_device *hdev)\r\n{\r\nhid_hw_stop(hdev);\r\nkfree(hid_get_drvdata(hdev));\r\n}\r\nstatic int __init apple_init(void)\r\n{\r\nint ret;\r\nret = hid_register_driver(&apple_driver);\r\nif (ret)\r\npr_err("can't register apple driver\n");\r\nreturn ret;\r\n}\r\nstatic void __exit apple_exit(void)\r\n{\r\nhid_unregister_driver(&apple_driver);\r\n}
