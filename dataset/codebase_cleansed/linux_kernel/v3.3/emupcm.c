static void snd_emu10k1_pcm_interrupt(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_voice *voice)\r\n{\r\nstruct snd_emu10k1_pcm *epcm;\r\nif ((epcm = voice->epcm) == NULL)\r\nreturn;\r\nif (epcm->substream == NULL)\r\nreturn;\r\n#if 0\r\nprintk(KERN_DEBUG "IRQ: position = 0x%x, period = 0x%x, size = 0x%x\n",\r\nepcm->substream->runtime->hw->pointer(emu, epcm->substream),\r\nsnd_pcm_lib_period_bytes(epcm->substream),\r\nsnd_pcm_lib_buffer_bytes(epcm->substream));\r\n#endif\r\nsnd_pcm_period_elapsed(epcm->substream);\r\n}\r\nstatic void snd_emu10k1_pcm_ac97adc_interrupt(struct snd_emu10k1 *emu,\r\nunsigned int status)\r\n{\r\n#if 0\r\nif (status & IPR_ADCBUFHALFFULL) {\r\nif (emu->pcm_capture_substream->runtime->mode == SNDRV_PCM_MODE_FRAME)\r\nreturn;\r\n}\r\n#endif\r\nsnd_pcm_period_elapsed(emu->pcm_capture_substream);\r\n}\r\nstatic void snd_emu10k1_pcm_ac97mic_interrupt(struct snd_emu10k1 *emu,\r\nunsigned int status)\r\n{\r\n#if 0\r\nif (status & IPR_MICBUFHALFFULL) {\r\nif (emu->pcm_capture_mic_substream->runtime->mode == SNDRV_PCM_MODE_FRAME)\r\nreturn;\r\n}\r\n#endif\r\nsnd_pcm_period_elapsed(emu->pcm_capture_mic_substream);\r\n}\r\nstatic void snd_emu10k1_pcm_efx_interrupt(struct snd_emu10k1 *emu,\r\nunsigned int status)\r\n{\r\n#if 0\r\nif (status & IPR_EFXBUFHALFFULL) {\r\nif (emu->pcm_capture_efx_substream->runtime->mode == SNDRV_PCM_MODE_FRAME)\r\nreturn;\r\n}\r\n#endif\r\nsnd_pcm_period_elapsed(emu->pcm_capture_efx_substream);\r\n}\r\nstatic snd_pcm_uframes_t snd_emu10k1_efx_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_pcm *epcm = runtime->private_data;\r\nunsigned int ptr;\r\nif (!epcm->running)\r\nreturn 0;\r\nptr = snd_emu10k1_ptr_read(emu, CCCA, epcm->voices[0]->number) & 0x00ffffff;\r\nptr += runtime->buffer_size;\r\nptr -= epcm->ccca_start_addr;\r\nptr %= runtime->buffer_size;\r\nreturn ptr;\r\n}\r\nstatic int snd_emu10k1_pcm_channel_alloc(struct snd_emu10k1_pcm * epcm, int voices)\r\n{\r\nint err, i;\r\nif (epcm->voices[1] != NULL && voices < 2) {\r\nsnd_emu10k1_voice_free(epcm->emu, epcm->voices[1]);\r\nepcm->voices[1] = NULL;\r\n}\r\nfor (i = 0; i < voices; i++) {\r\nif (epcm->voices[i] == NULL)\r\nbreak;\r\n}\r\nif (i == voices)\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(epcm->voices); i++) {\r\nif (epcm->voices[i]) {\r\nsnd_emu10k1_voice_free(epcm->emu, epcm->voices[i]);\r\nepcm->voices[i] = NULL;\r\n}\r\n}\r\nerr = snd_emu10k1_voice_alloc(epcm->emu,\r\nepcm->type == PLAYBACK_EMUVOICE ? EMU10K1_PCM : EMU10K1_EFX,\r\nvoices,\r\n&epcm->voices[0]);\r\nif (err < 0)\r\nreturn err;\r\nepcm->voices[0]->epcm = epcm;\r\nif (voices > 1) {\r\nfor (i = 1; i < voices; i++) {\r\nepcm->voices[i] = &epcm->emu->voices[epcm->voices[0]->number + i];\r\nepcm->voices[i]->epcm = epcm;\r\n}\r\n}\r\nif (epcm->extra == NULL) {\r\nerr = snd_emu10k1_voice_alloc(epcm->emu,\r\nepcm->type == PLAYBACK_EMUVOICE ? EMU10K1_PCM : EMU10K1_EFX,\r\n1,\r\n&epcm->extra);\r\nif (err < 0) {\r\nfor (i = 0; i < voices; i++) {\r\nsnd_emu10k1_voice_free(epcm->emu, epcm->voices[i]);\r\nepcm->voices[i] = NULL;\r\n}\r\nreturn err;\r\n}\r\nepcm->extra->epcm = epcm;\r\nepcm->extra->interrupt = snd_emu10k1_pcm_interrupt;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int snd_emu10k1_capture_rate_reg(unsigned int rate)\r\n{\r\nswitch (rate) {\r\ncase 8000: return ADCCR_SAMPLERATE_8;\r\ncase 11025: return ADCCR_SAMPLERATE_11;\r\ncase 16000: return ADCCR_SAMPLERATE_16;\r\ncase 22050: return ADCCR_SAMPLERATE_22;\r\ncase 24000: return ADCCR_SAMPLERATE_24;\r\ncase 32000: return ADCCR_SAMPLERATE_32;\r\ncase 44100: return ADCCR_SAMPLERATE_44;\r\ncase 48000: return ADCCR_SAMPLERATE_48;\r\ndefault:\r\nsnd_BUG();\r\nreturn ADCCR_SAMPLERATE_8;\r\n}\r\n}\r\nstatic unsigned int snd_emu10k1_audigy_capture_rate_reg(unsigned int rate)\r\n{\r\nswitch (rate) {\r\ncase 8000: return A_ADCCR_SAMPLERATE_8;\r\ncase 11025: return A_ADCCR_SAMPLERATE_11;\r\ncase 12000: return A_ADCCR_SAMPLERATE_12;\r\ncase 16000: return ADCCR_SAMPLERATE_16;\r\ncase 22050: return ADCCR_SAMPLERATE_22;\r\ncase 24000: return ADCCR_SAMPLERATE_24;\r\ncase 32000: return ADCCR_SAMPLERATE_32;\r\ncase 44100: return ADCCR_SAMPLERATE_44;\r\ncase 48000: return ADCCR_SAMPLERATE_48;\r\ndefault:\r\nsnd_BUG();\r\nreturn A_ADCCR_SAMPLERATE_8;\r\n}\r\n}\r\nstatic unsigned int emu10k1_calc_pitch_target(unsigned int rate)\r\n{\r\nunsigned int pitch_target;\r\npitch_target = (rate << 8) / 375;\r\npitch_target = (pitch_target >> 1) + (pitch_target & 1);\r\nreturn pitch_target;\r\n}\r\nstatic unsigned int emu10k1_select_interprom(unsigned int pitch_target)\r\n{\r\nif (pitch_target == PITCH_48000)\r\nreturn CCCA_INTERPROM_0;\r\nelse if (pitch_target < PITCH_48000)\r\nreturn CCCA_INTERPROM_1;\r\nelse if (pitch_target >= PITCH_96000)\r\nreturn CCCA_INTERPROM_0;\r\nelse if (pitch_target >= PITCH_85000)\r\nreturn CCCA_INTERPROM_6;\r\nelse if (pitch_target >= PITCH_80726)\r\nreturn CCCA_INTERPROM_5;\r\nelse if (pitch_target >= PITCH_67882)\r\nreturn CCCA_INTERPROM_4;\r\nelse if (pitch_target >= PITCH_57081)\r\nreturn CCCA_INTERPROM_3;\r\nelse\r\nreturn CCCA_INTERPROM_2;\r\n}\r\nstatic inline int emu10k1_ccis(int stereo, int w_16)\r\n{\r\nif (w_16) {\r\nreturn stereo ? 24 : 26;\r\n} else {\r\nreturn stereo ? 24*2 : 26*2;\r\n}\r\n}\r\nstatic void snd_emu10k1_pcm_init_voice(struct snd_emu10k1 *emu,\r\nint master, int extra,\r\nstruct snd_emu10k1_voice *evoice,\r\nunsigned int start_addr,\r\nunsigned int end_addr,\r\nstruct snd_emu10k1_pcm_mixer *mix)\r\n{\r\nstruct snd_pcm_substream *substream = evoice->epcm->substream;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int silent_page, tmp;\r\nint voice, stereo, w_16;\r\nunsigned char attn, send_amount[8];\r\nunsigned char send_routing[8];\r\nunsigned long flags;\r\nunsigned int pitch_target;\r\nunsigned int ccis;\r\nvoice = evoice->number;\r\nstereo = runtime->channels == 2;\r\nw_16 = snd_pcm_format_width(runtime->format) == 16;\r\nif (!extra && stereo) {\r\nstart_addr >>= 1;\r\nend_addr >>= 1;\r\n}\r\nif (w_16) {\r\nstart_addr >>= 1;\r\nend_addr >>= 1;\r\n}\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nif (extra) {\r\nattn = 0;\r\nmemset(send_routing, 0, sizeof(send_routing));\r\nsend_routing[0] = 0;\r\nsend_routing[1] = 1;\r\nsend_routing[2] = 2;\r\nsend_routing[3] = 3;\r\nmemset(send_amount, 0, sizeof(send_amount));\r\n} else {\r\ntmp = stereo ? (master ? 1 : 2) : 0;\r\nmemcpy(send_routing, &mix->send_routing[tmp][0], 8);\r\nmemcpy(send_amount, &mix->send_volume[tmp][0], 8);\r\n}\r\nccis = emu10k1_ccis(stereo, w_16);\r\nif (master) {\r\nevoice->epcm->ccca_start_addr = start_addr + ccis;\r\nif (extra) {\r\nstart_addr += ccis;\r\nend_addr += ccis + emu->delay_pcm_irq;\r\n}\r\nif (stereo && !extra) {\r\nsnd_emu10k1_ptr_write(emu, CPF, voice, CPF_STEREO_MASK);\r\nsnd_emu10k1_ptr_write(emu, CPF, (voice + 1), CPF_STEREO_MASK);\r\n} else {\r\nsnd_emu10k1_ptr_write(emu, CPF, voice, 0);\r\n}\r\n}\r\nif (emu->audigy) {\r\nsnd_emu10k1_ptr_write(emu, A_FXRT1, voice,\r\nsnd_emu10k1_compose_audigy_fxrt1(send_routing));\r\nsnd_emu10k1_ptr_write(emu, A_FXRT2, voice,\r\nsnd_emu10k1_compose_audigy_fxrt2(send_routing));\r\nsnd_emu10k1_ptr_write(emu, A_SENDAMOUNTS, voice,\r\n((unsigned int)send_amount[4] << 24) |\r\n((unsigned int)send_amount[5] << 16) |\r\n((unsigned int)send_amount[6] << 8) |\r\n(unsigned int)send_amount[7]);\r\n} else\r\nsnd_emu10k1_ptr_write(emu, FXRT, voice,\r\nsnd_emu10k1_compose_send_routing(send_routing));\r\nsnd_emu10k1_ptr_write(emu, PTRX, voice, (send_amount[0] << 8) | send_amount[1]);\r\nsnd_emu10k1_ptr_write(emu, DSL, voice, end_addr | (send_amount[3] << 24));\r\nsnd_emu10k1_ptr_write(emu, PSST, voice,\r\n(start_addr + (extra ? emu->delay_pcm_irq : 0)) |\r\n(send_amount[2] << 24));\r\nif (emu->card_capabilities->emu_model)\r\npitch_target = PITCH_48000;\r\nelse\r\npitch_target = emu10k1_calc_pitch_target(runtime->rate);\r\nif (extra)\r\nsnd_emu10k1_ptr_write(emu, CCCA, voice, start_addr |\r\nemu10k1_select_interprom(pitch_target) |\r\n(w_16 ? 0 : CCCA_8BITSELECT));\r\nelse\r\nsnd_emu10k1_ptr_write(emu, CCCA, voice, (start_addr + ccis) |\r\nemu10k1_select_interprom(pitch_target) |\r\n(w_16 ? 0 : CCCA_8BITSELECT));\r\nsnd_emu10k1_ptr_write(emu, Z1, voice, 0);\r\nsnd_emu10k1_ptr_write(emu, Z2, voice, 0);\r\nsilent_page = ((unsigned int)emu->silent_page.addr << 1) | MAP_PTI_MASK;\r\nsnd_emu10k1_ptr_write(emu, MAPA, voice, silent_page);\r\nsnd_emu10k1_ptr_write(emu, MAPB, voice, silent_page);\r\nsnd_emu10k1_ptr_write(emu, CVCF, voice, 0xffff);\r\nsnd_emu10k1_ptr_write(emu, VTFT, voice, 0xffff);\r\nsnd_emu10k1_ptr_write(emu, ATKHLDM, voice, 0);\r\nsnd_emu10k1_ptr_write(emu, DCYSUSM, voice, 0x007f);\r\nsnd_emu10k1_ptr_write(emu, LFOVAL1, voice, 0x8000);\r\nsnd_emu10k1_ptr_write(emu, LFOVAL2, voice, 0x8000);\r\nsnd_emu10k1_ptr_write(emu, FMMOD, voice, 0);\r\nsnd_emu10k1_ptr_write(emu, TREMFRQ, voice, 0);\r\nsnd_emu10k1_ptr_write(emu, FM2FRQ2, voice, 0);\r\nsnd_emu10k1_ptr_write(emu, ENVVAL, voice, 0x8000);\r\nsnd_emu10k1_ptr_write(emu, ATKHLDV, voice, 0x7f7f);\r\nsnd_emu10k1_ptr_write(emu, ENVVOL, voice, 0x0000);\r\nsnd_emu10k1_ptr_write(emu, PEFE_FILTERAMOUNT, voice, 0x7f);\r\nsnd_emu10k1_ptr_write(emu, PEFE_PITCHAMOUNT, voice, 0);\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\n}\r\nstatic int snd_emu10k1_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_pcm *epcm = runtime->private_data;\r\nint err;\r\nif ((err = snd_emu10k1_pcm_channel_alloc(epcm, params_channels(hw_params))) < 0)\r\nreturn err;\r\nif ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)\r\nreturn err;\r\nif (err > 0) {\r\nint mapped;\r\nif (epcm->memblk != NULL)\r\nsnd_emu10k1_free_pages(emu, epcm->memblk);\r\nepcm->memblk = snd_emu10k1_alloc_pages(emu, substream);\r\nepcm->start_addr = 0;\r\nif (! epcm->memblk)\r\nreturn -ENOMEM;\r\nmapped = ((struct snd_emu10k1_memblk *)epcm->memblk)->mapped_page;\r\nif (mapped < 0)\r\nreturn -ENOMEM;\r\nepcm->start_addr = mapped << PAGE_SHIFT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_pcm *epcm;\r\nif (runtime->private_data == NULL)\r\nreturn 0;\r\nepcm = runtime->private_data;\r\nif (epcm->extra) {\r\nsnd_emu10k1_voice_free(epcm->emu, epcm->extra);\r\nepcm->extra = NULL;\r\n}\r\nif (epcm->voices[1]) {\r\nsnd_emu10k1_voice_free(epcm->emu, epcm->voices[1]);\r\nepcm->voices[1] = NULL;\r\n}\r\nif (epcm->voices[0]) {\r\nsnd_emu10k1_voice_free(epcm->emu, epcm->voices[0]);\r\nepcm->voices[0] = NULL;\r\n}\r\nif (epcm->memblk) {\r\nsnd_emu10k1_free_pages(emu, epcm->memblk);\r\nepcm->memblk = NULL;\r\nepcm->start_addr = 0;\r\n}\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_efx_playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_pcm *epcm;\r\nint i;\r\nif (runtime->private_data == NULL)\r\nreturn 0;\r\nepcm = runtime->private_data;\r\nif (epcm->extra) {\r\nsnd_emu10k1_voice_free(epcm->emu, epcm->extra);\r\nepcm->extra = NULL;\r\n}\r\nfor (i = 0; i < NUM_EFX_PLAYBACK; i++) {\r\nif (epcm->voices[i]) {\r\nsnd_emu10k1_voice_free(epcm->emu, epcm->voices[i]);\r\nepcm->voices[i] = NULL;\r\n}\r\n}\r\nif (epcm->memblk) {\r\nsnd_emu10k1_free_pages(emu, epcm->memblk);\r\nepcm->memblk = NULL;\r\nepcm->start_addr = 0;\r\n}\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_pcm *epcm = runtime->private_data;\r\nunsigned int start_addr, end_addr;\r\nstart_addr = epcm->start_addr;\r\nend_addr = snd_pcm_lib_period_bytes(substream);\r\nif (runtime->channels == 2) {\r\nstart_addr >>= 1;\r\nend_addr >>= 1;\r\n}\r\nend_addr += start_addr;\r\nsnd_emu10k1_pcm_init_voice(emu, 1, 1, epcm->extra,\r\nstart_addr, end_addr, NULL);\r\nstart_addr = epcm->start_addr;\r\nend_addr = epcm->start_addr + snd_pcm_lib_buffer_bytes(substream);\r\nsnd_emu10k1_pcm_init_voice(emu, 1, 0, epcm->voices[0],\r\nstart_addr, end_addr,\r\n&emu->pcm_mixer[substream->number]);\r\nif (epcm->voices[1])\r\nsnd_emu10k1_pcm_init_voice(emu, 0, 0, epcm->voices[1],\r\nstart_addr, end_addr,\r\n&emu->pcm_mixer[substream->number]);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_efx_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_pcm *epcm = runtime->private_data;\r\nunsigned int start_addr, end_addr;\r\nunsigned int channel_size;\r\nint i;\r\nstart_addr = epcm->start_addr;\r\nend_addr = epcm->start_addr + snd_pcm_lib_buffer_bytes(substream);\r\nchannel_size = ( end_addr - start_addr ) / NUM_EFX_PLAYBACK;\r\nsnd_emu10k1_pcm_init_voice(emu, 1, 1, epcm->extra,\r\nstart_addr, start_addr + (channel_size / 2), NULL);\r\nsnd_emu10k1_pcm_init_voice(emu, 1, 0, epcm->voices[0],\r\nstart_addr, start_addr + channel_size,\r\n&emu->efx_pcm_mixer[0]);\r\nstart_addr += channel_size;\r\nfor (i = 1; i < NUM_EFX_PLAYBACK; i++) {\r\nsnd_emu10k1_pcm_init_voice(emu, 0, 0, epcm->voices[i],\r\nstart_addr, start_addr + channel_size,\r\n&emu->efx_pcm_mixer[i]);\r\nstart_addr += channel_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_emu10k1_capture_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_emu10k1_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_pcm *epcm = runtime->private_data;\r\nint idx;\r\nsnd_emu10k1_ptr_write(emu, epcm->capture_bs_reg, 0, 0);\r\nswitch (epcm->type) {\r\ncase CAPTURE_AC97ADC:\r\nsnd_emu10k1_ptr_write(emu, ADCCR, 0, 0);\r\nbreak;\r\ncase CAPTURE_EFX:\r\nif (emu->audigy) {\r\nsnd_emu10k1_ptr_write(emu, A_FXWC1, 0, 0);\r\nsnd_emu10k1_ptr_write(emu, A_FXWC2, 0, 0);\r\n} else\r\nsnd_emu10k1_ptr_write(emu, FXWC, 0, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsnd_emu10k1_ptr_write(emu, epcm->capture_ba_reg, 0, runtime->dma_addr);\r\nepcm->capture_bufsize = snd_pcm_lib_buffer_bytes(substream);\r\nepcm->capture_bs_val = 0;\r\nfor (idx = 0; idx < 31; idx++) {\r\nif (capture_period_sizes[idx] == epcm->capture_bufsize) {\r\nepcm->capture_bs_val = idx + 1;\r\nbreak;\r\n}\r\n}\r\nif (epcm->capture_bs_val == 0) {\r\nsnd_BUG();\r\nepcm->capture_bs_val++;\r\n}\r\nif (epcm->type == CAPTURE_AC97ADC) {\r\nepcm->capture_cr_val = emu->audigy ? A_ADCCR_LCHANENABLE : ADCCR_LCHANENABLE;\r\nif (runtime->channels > 1)\r\nepcm->capture_cr_val |= emu->audigy ? A_ADCCR_RCHANENABLE : ADCCR_RCHANENABLE;\r\nepcm->capture_cr_val |= emu->audigy ?\r\nsnd_emu10k1_audigy_capture_rate_reg(runtime->rate) :\r\nsnd_emu10k1_capture_rate_reg(runtime->rate);\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_emu10k1_playback_invalidate_cache(struct snd_emu10k1 *emu, int extra, struct snd_emu10k1_voice *evoice)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned int voice, stereo, i, ccis, cra = 64, cs, sample;\r\nif (evoice == NULL)\r\nreturn;\r\nruntime = evoice->epcm->substream->runtime;\r\nvoice = evoice->number;\r\nstereo = (!extra && runtime->channels == 2);\r\nsample = snd_pcm_format_width(runtime->format) == 16 ? 0 : 0x80808080;\r\nccis = emu10k1_ccis(stereo, sample == 0);\r\ncs = (sample == 0) ? (32-ccis) : (64-ccis+1) >> 1;\r\nif (cs > 16) cs = 16;\r\nfor (i = 0; i < cs; i++) {\r\nsnd_emu10k1_ptr_write(emu, CD0 + i, voice, sample);\r\nif (stereo) {\r\nsnd_emu10k1_ptr_write(emu, CD0 + i, voice + 1, sample);\r\n}\r\n}\r\nsnd_emu10k1_ptr_write(emu, CCR_CACHEINVALIDSIZE, voice, 0);\r\nsnd_emu10k1_ptr_write(emu, CCR_READADDRESS, voice, cra);\r\nif (stereo) {\r\nsnd_emu10k1_ptr_write(emu, CCR_CACHEINVALIDSIZE, voice + 1, 0);\r\nsnd_emu10k1_ptr_write(emu, CCR_READADDRESS, voice + 1, cra);\r\n}\r\nsnd_emu10k1_ptr_write(emu, CCR_CACHEINVALIDSIZE, voice, ccis);\r\nif (stereo) {\r\nsnd_emu10k1_ptr_write(emu, CCR_CACHEINVALIDSIZE, voice+1, ccis);\r\n}\r\n}\r\nstatic void snd_emu10k1_playback_prepare_voice(struct snd_emu10k1 *emu, struct snd_emu10k1_voice *evoice,\r\nint master, int extra,\r\nstruct snd_emu10k1_pcm_mixer *mix)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned int attn, vattn;\r\nunsigned int voice, tmp;\r\nif (evoice == NULL)\r\nreturn;\r\nsubstream = evoice->epcm->substream;\r\nruntime = substream->runtime;\r\nvoice = evoice->number;\r\nattn = extra ? 0 : 0x00ff;\r\ntmp = runtime->channels == 2 ? (master ? 1 : 2) : 0;\r\nvattn = mix != NULL ? (mix->attn[tmp] << 16) : 0;\r\nsnd_emu10k1_ptr_write(emu, IFATN, voice, attn);\r\nsnd_emu10k1_ptr_write(emu, VTFT, voice, vattn | 0xffff);\r\nsnd_emu10k1_ptr_write(emu, CVCF, voice, vattn | 0xffff);\r\nsnd_emu10k1_ptr_write(emu, DCYSUSV, voice, 0x7f7f);\r\nsnd_emu10k1_voice_clear_loop_stop(emu, voice);\r\n}\r\nstatic void snd_emu10k1_playback_trigger_voice(struct snd_emu10k1 *emu, struct snd_emu10k1_voice *evoice, int master, int extra)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned int voice, pitch, pitch_target;\r\nif (evoice == NULL)\r\nreturn;\r\nsubstream = evoice->epcm->substream;\r\nruntime = substream->runtime;\r\nvoice = evoice->number;\r\npitch = snd_emu10k1_rate_to_pitch(runtime->rate) >> 8;\r\nif (emu->card_capabilities->emu_model)\r\npitch_target = PITCH_48000;\r\nelse\r\npitch_target = emu10k1_calc_pitch_target(runtime->rate);\r\nsnd_emu10k1_ptr_write(emu, PTRX_PITCHTARGET, voice, pitch_target);\r\nif (master || evoice->epcm->type == PLAYBACK_EFX)\r\nsnd_emu10k1_ptr_write(emu, CPF_CURRENTPITCH, voice, pitch_target);\r\nsnd_emu10k1_ptr_write(emu, IP, voice, pitch);\r\nif (extra)\r\nsnd_emu10k1_voice_intr_enable(emu, voice);\r\n}\r\nstatic void snd_emu10k1_playback_stop_voice(struct snd_emu10k1 *emu, struct snd_emu10k1_voice *evoice)\r\n{\r\nunsigned int voice;\r\nif (evoice == NULL)\r\nreturn;\r\nvoice = evoice->number;\r\nsnd_emu10k1_voice_intr_disable(emu, voice);\r\nsnd_emu10k1_ptr_write(emu, PTRX_PITCHTARGET, voice, 0);\r\nsnd_emu10k1_ptr_write(emu, CPF_CURRENTPITCH, voice, 0);\r\nsnd_emu10k1_ptr_write(emu, IFATN, voice, 0xffff);\r\nsnd_emu10k1_ptr_write(emu, VTFT, voice, 0xffff);\r\nsnd_emu10k1_ptr_write(emu, CVCF, voice, 0xffff);\r\nsnd_emu10k1_ptr_write(emu, IP, voice, 0);\r\n}\r\nstatic inline void snd_emu10k1_playback_mangle_extra(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_pcm *epcm,\r\nstruct snd_pcm_substream *substream,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nunsigned int ptr, period_pos;\r\nperiod_pos = runtime->status->hw_ptr - runtime->hw_ptr_interrupt;\r\nperiod_pos %= runtime->period_size;\r\nptr = snd_emu10k1_ptr_read(emu, CCCA, epcm->extra->number);\r\nptr &= ~0x00ffffff;\r\nptr |= epcm->ccca_start_addr + period_pos;\r\nsnd_emu10k1_ptr_write(emu, CCCA, epcm->extra->number, ptr);\r\n}\r\nstatic int snd_emu10k1_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_pcm *epcm = runtime->private_data;\r\nstruct snd_emu10k1_pcm_mixer *mix;\r\nint result = 0;\r\nspin_lock(&emu->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nsnd_emu10k1_playback_invalidate_cache(emu, 1, epcm->extra);\r\nsnd_emu10k1_playback_invalidate_cache(emu, 0, epcm->voices[0]);\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (cmd == SNDRV_PCM_TRIGGER_PAUSE_RELEASE)\r\nsnd_emu10k1_playback_mangle_extra(emu, epcm, substream, runtime);\r\nmix = &emu->pcm_mixer[substream->number];\r\nsnd_emu10k1_playback_prepare_voice(emu, epcm->voices[0], 1, 0, mix);\r\nsnd_emu10k1_playback_prepare_voice(emu, epcm->voices[1], 0, 0, mix);\r\nsnd_emu10k1_playback_prepare_voice(emu, epcm->extra, 1, 1, NULL);\r\nsnd_emu10k1_playback_trigger_voice(emu, epcm->voices[0], 1, 0);\r\nsnd_emu10k1_playback_trigger_voice(emu, epcm->voices[1], 0, 0);\r\nsnd_emu10k1_playback_trigger_voice(emu, epcm->extra, 1, 1);\r\nepcm->running = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nepcm->running = 0;\r\nsnd_emu10k1_playback_stop_voice(emu, epcm->voices[0]);\r\nsnd_emu10k1_playback_stop_voice(emu, epcm->voices[1]);\r\nsnd_emu10k1_playback_stop_voice(emu, epcm->extra);\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock(&emu->reg_lock);\r\nreturn result;\r\n}\r\nstatic int snd_emu10k1_capture_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_pcm *epcm = runtime->private_data;\r\nint result = 0;\r\nspin_lock(&emu->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\noutl(epcm->capture_ipr, emu->port + IPR);\r\nsnd_emu10k1_intr_enable(emu, epcm->capture_inte);\r\nswitch (epcm->type) {\r\ncase CAPTURE_AC97ADC:\r\nsnd_emu10k1_ptr_write(emu, ADCCR, 0, epcm->capture_cr_val);\r\nbreak;\r\ncase CAPTURE_EFX:\r\nif (emu->audigy) {\r\nsnd_emu10k1_ptr_write(emu, A_FXWC1, 0, epcm->capture_cr_val);\r\nsnd_emu10k1_ptr_write(emu, A_FXWC2, 0, epcm->capture_cr_val2);\r\nsnd_printdd("cr_val=0x%x, cr_val2=0x%x\n", epcm->capture_cr_val, epcm->capture_cr_val2);\r\n} else\r\nsnd_emu10k1_ptr_write(emu, FXWC, 0, epcm->capture_cr_val);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsnd_emu10k1_ptr_write(emu, epcm->capture_bs_reg, 0, epcm->capture_bs_val);\r\nepcm->running = 1;\r\nepcm->first_ptr = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nepcm->running = 0;\r\nsnd_emu10k1_intr_disable(emu, epcm->capture_inte);\r\noutl(epcm->capture_ipr, emu->port + IPR);\r\nsnd_emu10k1_ptr_write(emu, epcm->capture_bs_reg, 0, 0);\r\nswitch (epcm->type) {\r\ncase CAPTURE_AC97ADC:\r\nsnd_emu10k1_ptr_write(emu, ADCCR, 0, 0);\r\nbreak;\r\ncase CAPTURE_EFX:\r\nif (emu->audigy) {\r\nsnd_emu10k1_ptr_write(emu, A_FXWC1, 0, 0);\r\nsnd_emu10k1_ptr_write(emu, A_FXWC2, 0, 0);\r\n} else\r\nsnd_emu10k1_ptr_write(emu, FXWC, 0, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\n}\r\nspin_unlock(&emu->reg_lock);\r\nreturn result;\r\n}\r\nstatic snd_pcm_uframes_t snd_emu10k1_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_pcm *epcm = runtime->private_data;\r\nunsigned int ptr;\r\nif (!epcm->running)\r\nreturn 0;\r\nptr = snd_emu10k1_ptr_read(emu, CCCA, epcm->voices[0]->number) & 0x00ffffff;\r\n#if 0\r\nptr += runtime->buffer_size;\r\nptr -= epcm->ccca_start_addr;\r\nptr %= runtime->buffer_size;\r\n#else\r\nif (ptr < epcm->ccca_start_addr)\r\nptr += runtime->buffer_size - epcm->ccca_start_addr;\r\nelse {\r\nptr -= epcm->ccca_start_addr;\r\nif (ptr >= runtime->buffer_size)\r\nptr -= runtime->buffer_size;\r\n}\r\n#endif\r\nreturn ptr;\r\n}\r\nstatic int snd_emu10k1_efx_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_pcm *epcm = runtime->private_data;\r\nint i;\r\nint result = 0;\r\nspin_lock(&emu->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nfor (i = 0; i < NUM_EFX_PLAYBACK; i++) {\r\nsnd_emu10k1_playback_invalidate_cache(emu, 0, epcm->voices[i]);\r\n}\r\nsnd_emu10k1_playback_invalidate_cache(emu, 1, epcm->extra);\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nsnd_emu10k1_playback_prepare_voice(emu, epcm->extra, 1, 1, NULL);\r\nsnd_emu10k1_playback_prepare_voice(emu, epcm->voices[0], 0, 0,\r\n&emu->efx_pcm_mixer[0]);\r\nfor (i = 1; i < NUM_EFX_PLAYBACK; i++)\r\nsnd_emu10k1_playback_prepare_voice(emu, epcm->voices[i], 0, 0,\r\n&emu->efx_pcm_mixer[i]);\r\nsnd_emu10k1_playback_trigger_voice(emu, epcm->voices[0], 0, 0);\r\nsnd_emu10k1_playback_trigger_voice(emu, epcm->extra, 1, 1);\r\nfor (i = 1; i < NUM_EFX_PLAYBACK; i++)\r\nsnd_emu10k1_playback_trigger_voice(emu, epcm->voices[i], 0, 0);\r\nepcm->running = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nepcm->running = 0;\r\nfor (i = 0; i < NUM_EFX_PLAYBACK; i++) {\r\nsnd_emu10k1_playback_stop_voice(emu, epcm->voices[i]);\r\n}\r\nsnd_emu10k1_playback_stop_voice(emu, epcm->extra);\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock(&emu->reg_lock);\r\nreturn result;\r\n}\r\nstatic snd_pcm_uframes_t snd_emu10k1_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_pcm *epcm = runtime->private_data;\r\nunsigned int ptr;\r\nif (!epcm->running)\r\nreturn 0;\r\nif (epcm->first_ptr) {\r\nudelay(50);\r\nepcm->first_ptr = 0;\r\n}\r\nptr = snd_emu10k1_ptr_read(emu, epcm->capture_idx_reg, 0) & 0x0000ffff;\r\nreturn bytes_to_frames(runtime, ptr);\r\n}\r\nstatic void snd_emu10k1_pcm_mixer_notify1(struct snd_emu10k1 *emu, struct snd_kcontrol *kctl, int idx, int activate)\r\n{\r\nstruct snd_ctl_elem_id id;\r\nif (! kctl)\r\nreturn;\r\nif (activate)\r\nkctl->vd[idx].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nelse\r\nkctl->vd[idx].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(emu->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO,\r\nsnd_ctl_build_ioff(&id, kctl, idx));\r\n}\r\nstatic void snd_emu10k1_pcm_mixer_notify(struct snd_emu10k1 *emu, int idx, int activate)\r\n{\r\nsnd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_send_routing, idx, activate);\r\nsnd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_send_volume, idx, activate);\r\nsnd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_attn, idx, activate);\r\n}\r\nstatic void snd_emu10k1_pcm_efx_mixer_notify(struct snd_emu10k1 *emu, int idx, int activate)\r\n{\r\nsnd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_efx_send_routing, idx, activate);\r\nsnd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_efx_send_volume, idx, activate);\r\nsnd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_efx_attn, idx, activate);\r\n}\r\nstatic void snd_emu10k1_pcm_free_substream(struct snd_pcm_runtime *runtime)\r\n{\r\nkfree(runtime->private_data);\r\n}\r\nstatic int snd_emu10k1_efx_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_emu10k1_pcm_mixer *mix;\r\nint i;\r\nfor (i = 0; i < NUM_EFX_PLAYBACK; i++) {\r\nmix = &emu->efx_pcm_mixer[i];\r\nmix->epcm = NULL;\r\nsnd_emu10k1_pcm_efx_mixer_notify(emu, i, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_efx_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_emu10k1_pcm *epcm;\r\nstruct snd_emu10k1_pcm_mixer *mix;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint i;\r\nepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\r\nif (epcm == NULL)\r\nreturn -ENOMEM;\r\nepcm->emu = emu;\r\nepcm->type = PLAYBACK_EFX;\r\nepcm->substream = substream;\r\nemu->pcm_playback_efx_substream = substream;\r\nruntime->private_data = epcm;\r\nruntime->private_free = snd_emu10k1_pcm_free_substream;\r\nruntime->hw = snd_emu10k1_efx_playback;\r\nfor (i = 0; i < NUM_EFX_PLAYBACK; i++) {\r\nmix = &emu->efx_pcm_mixer[i];\r\nmix->send_routing[0][0] = i;\r\nmemset(&mix->send_volume, 0, sizeof(mix->send_volume));\r\nmix->send_volume[0][0] = 255;\r\nmix->attn[0] = 0xffff;\r\nmix->epcm = epcm;\r\nsnd_emu10k1_pcm_efx_mixer_notify(emu, i, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_emu10k1_pcm *epcm;\r\nstruct snd_emu10k1_pcm_mixer *mix;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint i, err;\r\nepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\r\nif (epcm == NULL)\r\nreturn -ENOMEM;\r\nepcm->emu = emu;\r\nepcm->type = PLAYBACK_EMUVOICE;\r\nepcm->substream = substream;\r\nruntime->private_data = epcm;\r\nruntime->private_free = snd_emu10k1_pcm_free_substream;\r\nruntime->hw = snd_emu10k1_playback;\r\nif ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0) {\r\nkfree(epcm);\r\nreturn err;\r\n}\r\nif ((err = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 256, UINT_MAX)) < 0) {\r\nkfree(epcm);\r\nreturn err;\r\n}\r\nerr = snd_pcm_hw_rule_noresample(runtime, 48000);\r\nif (err < 0) {\r\nkfree(epcm);\r\nreturn err;\r\n}\r\nmix = &emu->pcm_mixer[substream->number];\r\nfor (i = 0; i < 4; i++)\r\nmix->send_routing[0][i] = mix->send_routing[1][i] = mix->send_routing[2][i] = i;\r\nmemset(&mix->send_volume, 0, sizeof(mix->send_volume));\r\nmix->send_volume[0][0] = mix->send_volume[0][1] =\r\nmix->send_volume[1][0] = mix->send_volume[2][1] = 255;\r\nmix->attn[0] = mix->attn[1] = mix->attn[2] = 0xffff;\r\nmix->epcm = epcm;\r\nsnd_emu10k1_pcm_mixer_notify(emu, substream->number, 1);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_emu10k1_pcm_mixer *mix = &emu->pcm_mixer[substream->number];\r\nmix->epcm = NULL;\r\nsnd_emu10k1_pcm_mixer_notify(emu, substream->number, 0);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_pcm *epcm;\r\nepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\r\nif (epcm == NULL)\r\nreturn -ENOMEM;\r\nepcm->emu = emu;\r\nepcm->type = CAPTURE_AC97ADC;\r\nepcm->substream = substream;\r\nepcm->capture_ipr = IPR_ADCBUFFULL|IPR_ADCBUFHALFFULL;\r\nepcm->capture_inte = INTE_ADCBUFENABLE;\r\nepcm->capture_ba_reg = ADCBA;\r\nepcm->capture_bs_reg = ADCBS;\r\nepcm->capture_idx_reg = emu->audigy ? A_ADCIDX : ADCIDX;\r\nruntime->private_data = epcm;\r\nruntime->private_free = snd_emu10k1_pcm_free_substream;\r\nruntime->hw = snd_emu10k1_capture;\r\nemu->capture_interrupt = snd_emu10k1_pcm_ac97adc_interrupt;\r\nemu->pcm_capture_substream = substream;\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_capture_period_sizes);\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_capture_rates);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nemu->capture_interrupt = NULL;\r\nemu->pcm_capture_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_capture_mic_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_emu10k1_pcm *epcm;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\r\nif (epcm == NULL)\r\nreturn -ENOMEM;\r\nepcm->emu = emu;\r\nepcm->type = CAPTURE_AC97MIC;\r\nepcm->substream = substream;\r\nepcm->capture_ipr = IPR_MICBUFFULL|IPR_MICBUFHALFFULL;\r\nepcm->capture_inte = INTE_MICBUFENABLE;\r\nepcm->capture_ba_reg = MICBA;\r\nepcm->capture_bs_reg = MICBS;\r\nepcm->capture_idx_reg = emu->audigy ? A_MICIDX : MICIDX;\r\nsubstream->runtime->private_data = epcm;\r\nsubstream->runtime->private_free = snd_emu10k1_pcm_free_substream;\r\nruntime->hw = snd_emu10k1_capture;\r\nruntime->hw.rates = SNDRV_PCM_RATE_8000;\r\nruntime->hw.rate_min = runtime->hw.rate_max = 8000;\r\nruntime->hw.channels_min = 1;\r\nemu->capture_mic_interrupt = snd_emu10k1_pcm_ac97mic_interrupt;\r\nemu->pcm_capture_mic_substream = substream;\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_capture_period_sizes);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_capture_mic_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nemu->capture_interrupt = NULL;\r\nemu->pcm_capture_mic_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_capture_efx_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_emu10k1_pcm *epcm;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint nefx = emu->audigy ? 64 : 32;\r\nint idx;\r\nepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\r\nif (epcm == NULL)\r\nreturn -ENOMEM;\r\nepcm->emu = emu;\r\nepcm->type = CAPTURE_EFX;\r\nepcm->substream = substream;\r\nepcm->capture_ipr = IPR_EFXBUFFULL|IPR_EFXBUFHALFFULL;\r\nepcm->capture_inte = INTE_EFXBUFENABLE;\r\nepcm->capture_ba_reg = FXBA;\r\nepcm->capture_bs_reg = FXBS;\r\nepcm->capture_idx_reg = FXIDX;\r\nsubstream->runtime->private_data = epcm;\r\nsubstream->runtime->private_free = snd_emu10k1_pcm_free_substream;\r\nruntime->hw = snd_emu10k1_capture_efx;\r\nruntime->hw.rates = SNDRV_PCM_RATE_48000;\r\nruntime->hw.rate_min = runtime->hw.rate_max = 48000;\r\nspin_lock_irq(&emu->reg_lock);\r\nif (emu->card_capabilities->emu_model) {\r\n#if 1\r\nswitch (emu->emu1010.internal_clock) {\r\ncase 0:\r\nruntime->hw.rates = SNDRV_PCM_RATE_44100;\r\nruntime->hw.rate_min = runtime->hw.rate_max = 44100;\r\nruntime->hw.channels_min =\r\nruntime->hw.channels_max = 16;\r\nbreak;\r\ncase 1:\r\nruntime->hw.rates = SNDRV_PCM_RATE_48000;\r\nruntime->hw.rate_min = runtime->hw.rate_max = 48000;\r\nruntime->hw.channels_min =\r\nruntime->hw.channels_max = 16;\r\nbreak;\r\n};\r\n#endif\r\n#if 0\r\nruntime->hw.rates = SNDRV_PCM_RATE_96000;\r\nruntime->hw.rate_min = runtime->hw.rate_max = 96000;\r\nruntime->hw.channels_min = runtime->hw.channels_max = 4;\r\n#endif\r\n#if 0\r\nruntime->hw.rates = SNDRV_PCM_RATE_192000;\r\nruntime->hw.rate_min = runtime->hw.rate_max = 192000;\r\nruntime->hw.channels_min = runtime->hw.channels_max = 2;\r\n#endif\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_S32_LE;\r\n} else {\r\nruntime->hw.channels_min = runtime->hw.channels_max = 0;\r\nfor (idx = 0; idx < nefx; idx++) {\r\nif (emu->efx_voices_mask[idx/32] & (1 << (idx%32))) {\r\nruntime->hw.channels_min++;\r\nruntime->hw.channels_max++;\r\n}\r\n}\r\n}\r\nepcm->capture_cr_val = emu->efx_voices_mask[0];\r\nepcm->capture_cr_val2 = emu->efx_voices_mask[1];\r\nspin_unlock_irq(&emu->reg_lock);\r\nemu->capture_efx_interrupt = snd_emu10k1_pcm_efx_interrupt;\r\nemu->pcm_capture_efx_substream = substream;\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_capture_period_sizes);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_capture_efx_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nemu->capture_interrupt = NULL;\r\nemu->pcm_capture_efx_substream = NULL;\r\nreturn 0;\r\n}\r\nint __devinit snd_emu10k1_pcm(struct snd_emu10k1 * emu, int device, struct snd_pcm ** rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nstruct snd_pcm_substream *substream;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nif ((err = snd_pcm_new(emu->card, "emu10k1", device, 32, 1, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = emu;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_emu10k1_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_emu10k1_capture_ops);\r\npcm->info_flags = 0;\r\npcm->dev_subclass = SNDRV_PCM_SUBCLASS_GENERIC_MIX;\r\nstrcpy(pcm->name, "ADC Capture/Standard PCM Playback");\r\nemu->pcm = pcm;\r\nfor (substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; substream; substream = substream->next)\r\nif ((err = snd_pcm_lib_preallocate_pages(substream, SNDRV_DMA_TYPE_DEV_SG, snd_dma_pci_data(emu->pci), 64*1024, 64*1024)) < 0)\r\nreturn err;\r\nfor (substream = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream; substream; substream = substream->next)\r\nsnd_pcm_lib_preallocate_pages(substream, SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(emu->pci), 64*1024, 64*1024);\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nint __devinit snd_emu10k1_pcm_multi(struct snd_emu10k1 * emu, int device, struct snd_pcm ** rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nstruct snd_pcm_substream *substream;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nif ((err = snd_pcm_new(emu->card, "emu10k1", device, 1, 0, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = emu;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_emu10k1_efx_playback_ops);\r\npcm->info_flags = 0;\r\npcm->dev_subclass = SNDRV_PCM_SUBCLASS_GENERIC_MIX;\r\nstrcpy(pcm->name, "Multichannel Playback");\r\nemu->pcm_multi = pcm;\r\nfor (substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; substream; substream = substream->next)\r\nif ((err = snd_pcm_lib_preallocate_pages(substream, SNDRV_DMA_TYPE_DEV_SG, snd_dma_pci_data(emu->pci), 64*1024, 64*1024)) < 0)\r\nreturn err;\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nint __devinit snd_emu10k1_pcm_mic(struct snd_emu10k1 * emu, int device, struct snd_pcm ** rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nif ((err = snd_pcm_new(emu->card, "emu10k1 mic", device, 0, 1, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = emu;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_emu10k1_capture_mic_ops);\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "Mic Capture");\r\nemu->pcm_mic = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(emu->pci), 64*1024, 64*1024);\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_pcm_efx_voices_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nint nefx = emu->audigy ? 64 : 32;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = nefx;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_pcm_efx_voices_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nint nefx = emu->audigy ? 64 : 32;\r\nint idx;\r\nspin_lock_irq(&emu->reg_lock);\r\nfor (idx = 0; idx < nefx; idx++)\r\nucontrol->value.integer.value[idx] = (emu->efx_voices_mask[idx / 32] & (1 << (idx % 32))) ? 1 : 0;\r\nspin_unlock_irq(&emu->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_pcm_efx_voices_mask_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int nval[2], bits;\r\nint nefx = emu->audigy ? 64 : 32;\r\nint nefxb = emu->audigy ? 7 : 6;\r\nint change, idx;\r\nnval[0] = nval[1] = 0;\r\nfor (idx = 0, bits = 0; idx < nefx; idx++)\r\nif (ucontrol->value.integer.value[idx]) {\r\nnval[idx / 32] |= 1 << (idx % 32);\r\nbits++;\r\n}\r\nfor (idx = 0; idx < nefxb; idx++)\r\nif (1 << idx == bits)\r\nbreak;\r\nif (idx >= nefxb)\r\nreturn -EINVAL;\r\nspin_lock_irq(&emu->reg_lock);\r\nchange = (nval[0] != emu->efx_voices_mask[0]) ||\r\n(nval[1] != emu->efx_voices_mask[1]);\r\nemu->efx_voices_mask[0] = nval[0];\r\nemu->efx_voices_mask[1] = nval[1];\r\nspin_unlock_irq(&emu->reg_lock);\r\nreturn change;\r\n}\r\nstatic void snd_emu10k1_fx8010_playback_irq(struct snd_emu10k1 *emu, void *private_data)\r\n{\r\nstruct snd_pcm_substream *substream = private_data;\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\nstatic void snd_emu10k1_fx8010_playback_tram_poke1(unsigned short *dst_left,\r\nunsigned short *dst_right,\r\nunsigned short *src,\r\nunsigned int count,\r\nunsigned int tram_shift)\r\n{\r\nif ((tram_shift & 1) == 0) {\r\nwhile (count--) {\r\n*dst_left-- = *src++;\r\n*dst_right-- = *src++;\r\n}\r\n} else {\r\nwhile (count--) {\r\n*dst_right-- = *src++;\r\n*dst_left-- = *src++;\r\n}\r\n}\r\n}\r\nstatic void fx8010_pb_trans_copy(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_indirect *rec, size_t bytes)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];\r\nunsigned int tram_size = pcm->buffer_size;\r\nunsigned short *src = (unsigned short *)(substream->runtime->dma_area + rec->sw_data);\r\nunsigned int frames = bytes >> 2, count;\r\nunsigned int tram_pos = pcm->tram_pos;\r\nunsigned int tram_shift = pcm->tram_shift;\r\nwhile (frames > tram_pos) {\r\ncount = tram_pos + 1;\r\nsnd_emu10k1_fx8010_playback_tram_poke1((unsigned short *)emu->fx8010.etram_pages.area + tram_pos,\r\n(unsigned short *)emu->fx8010.etram_pages.area + tram_pos + tram_size / 2,\r\nsrc, count, tram_shift);\r\nsrc += count * 2;\r\nframes -= count;\r\ntram_pos = (tram_size / 2) - 1;\r\ntram_shift++;\r\n}\r\nsnd_emu10k1_fx8010_playback_tram_poke1((unsigned short *)emu->fx8010.etram_pages.area + tram_pos,\r\n(unsigned short *)emu->fx8010.etram_pages.area + tram_pos + tram_size / 2,\r\nsrc, frames, tram_shift);\r\ntram_pos -= frames;\r\npcm->tram_pos = tram_pos;\r\npcm->tram_shift = tram_shift;\r\n}\r\nstatic int snd_emu10k1_fx8010_playback_transfer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];\r\nsnd_pcm_indirect_playback_transfer(substream, &pcm->pcm_rec, fx8010_pb_trans_copy);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_fx8010_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_emu10k1_fx8010_playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];\r\nunsigned int i;\r\nfor (i = 0; i < pcm->channels; i++)\r\nsnd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + 0x80 + pcm->etram[i], 0, 0);\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_fx8010_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];\r\nunsigned int i;\r\nmemset(&pcm->pcm_rec, 0, sizeof(pcm->pcm_rec));\r\npcm->pcm_rec.hw_buffer_size = pcm->buffer_size * 2;\r\npcm->pcm_rec.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);\r\npcm->tram_pos = INITIAL_TRAM_POS(pcm->buffer_size);\r\npcm->tram_shift = 0;\r\nsnd_emu10k1_ptr_write(emu, emu->gpr_base + pcm->gpr_running, 0, 0);\r\nsnd_emu10k1_ptr_write(emu, emu->gpr_base + pcm->gpr_trigger, 0, 0);\r\nsnd_emu10k1_ptr_write(emu, emu->gpr_base + pcm->gpr_size, 0, runtime->buffer_size);\r\nsnd_emu10k1_ptr_write(emu, emu->gpr_base + pcm->gpr_ptr, 0, 0);\r\nsnd_emu10k1_ptr_write(emu, emu->gpr_base + pcm->gpr_count, 0, runtime->period_size);\r\nsnd_emu10k1_ptr_write(emu, emu->gpr_base + pcm->gpr_tmpcount, 0, runtime->period_size);\r\nfor (i = 0; i < pcm->channels; i++)\r\nsnd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + 0x80 + pcm->etram[i], 0, (TANKMEMADDRREG_READ|TANKMEMADDRREG_ALIGN) + i * (runtime->buffer_size / pcm->channels));\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_fx8010_playback_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];\r\nint result = 0;\r\nspin_lock(&emu->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\n#ifdef EMU10K1_SET_AC3_IEC958\r\n{\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nunsigned int bits;\r\nbits = SPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |\r\nSPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC | SPCS_GENERATIONSTATUS |\r\n0x00001200 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT | SPCS_NOTAUDIODATA;\r\nsnd_emu10k1_ptr_write(emu, SPCS0 + i, 0, bits);\r\n}\r\n}\r\n#endif\r\nresult = snd_emu10k1_fx8010_register_irq_handler(emu, snd_emu10k1_fx8010_playback_irq, pcm->gpr_running, substream, &pcm->irq);\r\nif (result < 0)\r\ngoto __err;\r\nsnd_emu10k1_fx8010_playback_transfer(substream);\r\nsnd_emu10k1_ptr_write(emu, emu->gpr_base + pcm->gpr_trigger, 0, 1);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nsnd_emu10k1_fx8010_unregister_irq_handler(emu, pcm->irq); pcm->irq = NULL;\r\nsnd_emu10k1_ptr_write(emu, emu->gpr_base + pcm->gpr_trigger, 0, 0);\r\npcm->tram_pos = INITIAL_TRAM_POS(pcm->buffer_size);\r\npcm->tram_shift = 0;\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\n__err:\r\nspin_unlock(&emu->reg_lock);\r\nreturn result;\r\n}\r\nstatic snd_pcm_uframes_t snd_emu10k1_fx8010_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];\r\nsize_t ptr;\r\nif (!snd_emu10k1_ptr_read(emu, emu->gpr_base + pcm->gpr_trigger, 0))\r\nreturn 0;\r\nptr = snd_emu10k1_ptr_read(emu, emu->gpr_base + pcm->gpr_ptr, 0) << 2;\r\nreturn snd_pcm_indirect_playback_pointer(substream, &pcm->pcm_rec, ptr);\r\n}\r\nstatic int snd_emu10k1_fx8010_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];\r\nruntime->hw = snd_emu10k1_fx8010_playback;\r\nruntime->hw.channels_min = runtime->hw.channels_max = pcm->channels;\r\nruntime->hw.period_bytes_max = (pcm->buffer_size * 2) / 2;\r\nspin_lock_irq(&emu->reg_lock);\r\nif (pcm->valid == 0) {\r\nspin_unlock_irq(&emu->reg_lock);\r\nreturn -ENODEV;\r\n}\r\npcm->opened = 1;\r\nspin_unlock_irq(&emu->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_fx8010_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];\r\nspin_lock_irq(&emu->reg_lock);\r\npcm->opened = 0;\r\nspin_unlock_irq(&emu->reg_lock);\r\nreturn 0;\r\n}\r\nint __devinit snd_emu10k1_pcm_efx(struct snd_emu10k1 * emu, int device, struct snd_pcm ** rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nstruct snd_kcontrol *kctl;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nif ((err = snd_pcm_new(emu->card, "emu10k1 efx", device, 8, 1, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = emu;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_emu10k1_fx8010_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_emu10k1_capture_efx_ops);\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "Multichannel Capture/PT Playback");\r\nemu->pcm_efx = pcm;\r\nif (rpcm)\r\n*rpcm = pcm;\r\nif (emu->audigy) {\r\nemu->efx_voices_mask[0] = 0;\r\nif (emu->card_capabilities->emu_model)\r\nemu->efx_voices_mask[1] = 0xffffffff;\r\nelse\r\nemu->efx_voices_mask[1] = 0xffff;\r\n} else {\r\nemu->efx_voices_mask[0] = 0xffff0000;\r\nemu->efx_voices_mask[1] = 0;\r\n}\r\nkctl = snd_ctl_new1(&snd_emu10k1_pcm_efx_voices_mask, emu);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nkctl->id.device = device;\r\nsnd_ctl_add(emu->card, kctl);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(emu->pci), 64*1024, 64*1024);\r\nreturn 0;\r\n}
