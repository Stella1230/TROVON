static int omap2_onenand_set_async_mode(int cs, void __iomem *onenand_base)\r\n{\r\nstruct gpmc_timings t;\r\nu32 reg;\r\nint err;\r\nconst int t_cer = 15;\r\nconst int t_avdp = 12;\r\nconst int t_aavdh = 7;\r\nconst int t_ce = 76;\r\nconst int t_aa = 76;\r\nconst int t_oe = 20;\r\nconst int t_cez = 20;\r\nconst int t_ds = 30;\r\nconst int t_wpl = 40;\r\nconst int t_wph = 30;\r\nreg = readw(onenand_base + ONENAND_REG_SYS_CFG1);\r\nreg &= ~ONENAND_SYS_CFG1_SYNC_READ & ~ONENAND_SYS_CFG1_SYNC_WRITE;\r\nwritew(reg, onenand_base + ONENAND_REG_SYS_CFG1);\r\nmemset(&t, 0, sizeof(t));\r\nt.sync_clk = 0;\r\nt.cs_on = 0;\r\nt.adv_on = 0;\r\nt.adv_rd_off = gpmc_round_ns_to_ticks(max_t(int, t_avdp, t_cer));\r\nt.oe_on = t.adv_rd_off + gpmc_round_ns_to_ticks(t_aavdh);\r\nt.access = t.adv_on + gpmc_round_ns_to_ticks(t_aa);\r\nt.access = max_t(int, t.access, t.cs_on + gpmc_round_ns_to_ticks(t_ce));\r\nt.access = max_t(int, t.access, t.oe_on + gpmc_round_ns_to_ticks(t_oe));\r\nt.oe_off = t.access + gpmc_round_ns_to_ticks(1);\r\nt.cs_rd_off = t.oe_off;\r\nt.rd_cycle = t.cs_rd_off + gpmc_round_ns_to_ticks(t_cez);\r\nt.adv_wr_off = t.adv_rd_off;\r\nt.we_on = t.oe_on;\r\nif (cpu_is_omap34xx()) {\r\nt.wr_data_mux_bus = t.we_on;\r\nt.wr_access = t.we_on + gpmc_round_ns_to_ticks(t_ds);\r\n}\r\nt.we_off = t.we_on + gpmc_round_ns_to_ticks(t_wpl);\r\nt.cs_wr_off = t.we_off + gpmc_round_ns_to_ticks(t_wph);\r\nt.wr_cycle = t.cs_wr_off + gpmc_round_ns_to_ticks(t_cez);\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG1,\r\nGPMC_CONFIG1_DEVICESIZE_16 |\r\nGPMC_CONFIG1_MUXADDDATA);\r\nerr = gpmc_cs_set_timings(cs, &t);\r\nif (err)\r\nreturn err;\r\nreg = readw(onenand_base + ONENAND_REG_SYS_CFG1);\r\nreg &= ~ONENAND_SYS_CFG1_SYNC_READ & ~ONENAND_SYS_CFG1_SYNC_WRITE;\r\nwritew(reg, onenand_base + ONENAND_REG_SYS_CFG1);\r\nreturn 0;\r\n}\r\nstatic void set_onenand_cfg(void __iomem *onenand_base, int latency,\r\nint sync_read, int sync_write, int hf, int vhf)\r\n{\r\nu32 reg;\r\nreg = readw(onenand_base + ONENAND_REG_SYS_CFG1);\r\nreg &= ~((0x7 << ONENAND_SYS_CFG1_BRL_SHIFT) | (0x7 << 9));\r\nreg |= (latency << ONENAND_SYS_CFG1_BRL_SHIFT) |\r\nONENAND_SYS_CFG1_BL_16;\r\nif (sync_read)\r\nreg |= ONENAND_SYS_CFG1_SYNC_READ;\r\nelse\r\nreg &= ~ONENAND_SYS_CFG1_SYNC_READ;\r\nif (sync_write)\r\nreg |= ONENAND_SYS_CFG1_SYNC_WRITE;\r\nelse\r\nreg &= ~ONENAND_SYS_CFG1_SYNC_WRITE;\r\nif (hf)\r\nreg |= ONENAND_SYS_CFG1_HF;\r\nelse\r\nreg &= ~ONENAND_SYS_CFG1_HF;\r\nif (vhf)\r\nreg |= ONENAND_SYS_CFG1_VHF;\r\nelse\r\nreg &= ~ONENAND_SYS_CFG1_VHF;\r\nwritew(reg, onenand_base + ONENAND_REG_SYS_CFG1);\r\n}\r\nstatic int omap2_onenand_get_freq(struct omap_onenand_platform_data *cfg,\r\nvoid __iomem *onenand_base, bool *clk_dep)\r\n{\r\nu16 ver = readw(onenand_base + ONENAND_REG_VERSION_ID);\r\nint freq = 0;\r\nif (cfg->get_freq) {\r\nstruct onenand_freq_info fi;\r\nfi.maf_id = readw(onenand_base + ONENAND_REG_MANUFACTURER_ID);\r\nfi.dev_id = readw(onenand_base + ONENAND_REG_DEVICE_ID);\r\nfi.ver_id = ver;\r\nfreq = cfg->get_freq(&fi, clk_dep);\r\nif (freq)\r\nreturn freq;\r\n}\r\nswitch ((ver >> 4) & 0xf) {\r\ncase 0:\r\nfreq = 40;\r\nbreak;\r\ncase 1:\r\nfreq = 54;\r\nbreak;\r\ncase 2:\r\nfreq = 66;\r\nbreak;\r\ncase 3:\r\nfreq = 83;\r\nbreak;\r\ncase 4:\r\nfreq = 104;\r\nbreak;\r\ndefault:\r\nfreq = 54;\r\nbreak;\r\n}\r\nreturn freq;\r\n}\r\nstatic int omap2_onenand_set_sync_mode(struct omap_onenand_platform_data *cfg,\r\nvoid __iomem *onenand_base,\r\nint *freq_ptr)\r\n{\r\nstruct gpmc_timings t;\r\nconst int t_cer = 15;\r\nconst int t_avdp = 12;\r\nconst int t_cez = 20;\r\nconst int t_ds = 30;\r\nconst int t_wpl = 40;\r\nconst int t_wph = 30;\r\nint min_gpmc_clk_period, t_ces, t_avds, t_avdh, t_ach, t_aavdh, t_rdyo;\r\nint tick_ns, div, fclk_offset_ns, fclk_offset, gpmc_clk_ns, latency;\r\nint first_time = 0, hf = 0, vhf = 0, sync_read = 0, sync_write = 0;\r\nint err, ticks_cez;\r\nint cs = cfg->cs, freq = *freq_ptr;\r\nu32 reg;\r\nbool clk_dep = false;\r\nif (cfg->flags & ONENAND_SYNC_READ) {\r\nsync_read = 1;\r\n} else if (cfg->flags & ONENAND_SYNC_READWRITE) {\r\nsync_read = 1;\r\nsync_write = 1;\r\n} else\r\nreturn omap2_onenand_set_async_mode(cs, onenand_base);\r\nif (!freq) {\r\nerr = omap2_onenand_set_async_mode(cs, onenand_base);\r\nif (err)\r\nreturn err;\r\nfreq = omap2_onenand_get_freq(cfg, onenand_base, &clk_dep);\r\nfirst_time = 1;\r\n}\r\nswitch (freq) {\r\ncase 104:\r\nmin_gpmc_clk_period = 9600;\r\nt_ces = 3;\r\nt_avds = 4;\r\nt_avdh = 2;\r\nt_ach = 3;\r\nt_aavdh = 6;\r\nt_rdyo = 6;\r\nbreak;\r\ncase 83:\r\nmin_gpmc_clk_period = 12000;\r\nt_ces = 5;\r\nt_avds = 4;\r\nt_avdh = 2;\r\nt_ach = 6;\r\nt_aavdh = 6;\r\nt_rdyo = 9;\r\nbreak;\r\ncase 66:\r\nmin_gpmc_clk_period = 15000;\r\nt_ces = 6;\r\nt_avds = 5;\r\nt_avdh = 2;\r\nt_ach = 6;\r\nt_aavdh = 6;\r\nt_rdyo = 11;\r\nbreak;\r\ndefault:\r\nmin_gpmc_clk_period = 18500;\r\nt_ces = 7;\r\nt_avds = 7;\r\nt_avdh = 7;\r\nt_ach = 9;\r\nt_aavdh = 7;\r\nt_rdyo = 15;\r\nsync_write = 0;\r\nbreak;\r\n}\r\ntick_ns = gpmc_ticks_to_ns(1);\r\ndiv = gpmc_cs_calc_divider(cs, min_gpmc_clk_period);\r\ngpmc_clk_ns = gpmc_ticks_to_ns(div);\r\nif (gpmc_clk_ns < 15)\r\nhf = 1;\r\nif (gpmc_clk_ns < 12)\r\nvhf = 1;\r\nif (vhf)\r\nlatency = 8;\r\nelse if (hf)\r\nlatency = 6;\r\nelse if (gpmc_clk_ns >= 25)\r\nlatency = 3;\r\nelse\r\nlatency = 4;\r\nif (clk_dep) {\r\nif (gpmc_clk_ns < 12) {\r\nt_ces = 3;\r\nt_avds = 4;\r\n} else if (gpmc_clk_ns < 15) {\r\nt_ces = 5;\r\nt_avds = 4;\r\n} else if (gpmc_clk_ns < 25) {\r\nt_ces = 6;\r\nt_avds = 5;\r\n} else {\r\nt_ces = 7;\r\nt_avds = 7;\r\n}\r\n}\r\nif (first_time)\r\nset_onenand_cfg(onenand_base, latency,\r\nsync_read, sync_write, hf, vhf);\r\nif (div == 1) {\r\nreg = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG2);\r\nreg |= (1 << 7);\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG2, reg);\r\nreg = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG3);\r\nreg |= (1 << 7);\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG3, reg);\r\nreg = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG4);\r\nreg |= (1 << 7);\r\nreg |= (1 << 23);\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG4, reg);\r\n} else {\r\nreg = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG2);\r\nreg &= ~(1 << 7);\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG2, reg);\r\nreg = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG3);\r\nreg &= ~(1 << 7);\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG3, reg);\r\nreg = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG4);\r\nreg &= ~(1 << 7);\r\nreg &= ~(1 << 23);\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG4, reg);\r\n}\r\nmemset(&t, 0, sizeof(t));\r\nt.sync_clk = min_gpmc_clk_period;\r\nt.cs_on = 0;\r\nt.adv_on = 0;\r\nfclk_offset_ns = gpmc_round_ns_to_ticks(max_t(int, t_ces, t_avds));\r\nfclk_offset = gpmc_ns_to_ticks(fclk_offset_ns);\r\nt.page_burst_access = gpmc_clk_ns;\r\nt.adv_rd_off = gpmc_ticks_to_ns(fclk_offset + gpmc_ns_to_ticks(t_avdh));\r\nt.oe_on = gpmc_ticks_to_ns(fclk_offset + gpmc_ns_to_ticks(t_ach));\r\nif (t.oe_on <= t.adv_rd_off)\r\nt.oe_on = t.adv_rd_off + gpmc_round_ns_to_ticks(1);\r\nt.access = gpmc_ticks_to_ns(fclk_offset + (latency + 1) * div);\r\nt.oe_off = t.access + gpmc_round_ns_to_ticks(1);\r\nt.cs_rd_off = t.oe_off;\r\nticks_cez = ((gpmc_ns_to_ticks(t_cez) + div - 1) / div) * div;\r\nt.rd_cycle = gpmc_ticks_to_ns(fclk_offset + (latency + 1) * div +\r\nticks_cez);\r\nif (sync_write) {\r\nt.adv_wr_off = t.adv_rd_off;\r\nt.we_on = 0;\r\nt.we_off = t.cs_rd_off;\r\nt.cs_wr_off = t.cs_rd_off;\r\nt.wr_cycle = t.rd_cycle;\r\nif (cpu_is_omap34xx()) {\r\nt.wr_data_mux_bus = gpmc_ticks_to_ns(fclk_offset +\r\ngpmc_ps_to_ticks(min_gpmc_clk_period +\r\nt_rdyo * 1000));\r\nt.wr_access = t.access;\r\n}\r\n} else {\r\nt.adv_wr_off = gpmc_round_ns_to_ticks(max_t(int,\r\nt_avdp, t_cer));\r\nt.we_on = t.adv_wr_off + gpmc_round_ns_to_ticks(t_aavdh);\r\nt.we_off = t.we_on + gpmc_round_ns_to_ticks(t_wpl);\r\nt.cs_wr_off = t.we_off + gpmc_round_ns_to_ticks(t_wph);\r\nt.wr_cycle = t.cs_wr_off + gpmc_round_ns_to_ticks(t_cez);\r\nif (cpu_is_omap34xx()) {\r\nt.wr_data_mux_bus = t.we_on;\r\nt.wr_access = t.we_on + gpmc_round_ns_to_ticks(t_ds);\r\n}\r\n}\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG1,\r\nGPMC_CONFIG1_WRAPBURST_SUPP |\r\nGPMC_CONFIG1_READMULTIPLE_SUPP |\r\n(sync_read ? GPMC_CONFIG1_READTYPE_SYNC : 0) |\r\n(sync_write ? GPMC_CONFIG1_WRITEMULTIPLE_SUPP : 0) |\r\n(sync_write ? GPMC_CONFIG1_WRITETYPE_SYNC : 0) |\r\nGPMC_CONFIG1_CLKACTIVATIONTIME(fclk_offset) |\r\nGPMC_CONFIG1_PAGE_LEN(2) |\r\n(cpu_is_omap34xx() ? 0 :\r\n(GPMC_CONFIG1_WAIT_READ_MON |\r\nGPMC_CONFIG1_WAIT_PIN_SEL(0))) |\r\nGPMC_CONFIG1_DEVICESIZE_16 |\r\nGPMC_CONFIG1_DEVICETYPE_NOR |\r\nGPMC_CONFIG1_MUXADDDATA);\r\nerr = gpmc_cs_set_timings(cs, &t);\r\nif (err)\r\nreturn err;\r\nset_onenand_cfg(onenand_base, latency, sync_read, sync_write, hf, vhf);\r\n*freq_ptr = freq;\r\nreturn 0;\r\n}\r\nstatic int gpmc_onenand_setup(void __iomem *onenand_base, int *freq_ptr)\r\n{\r\nstruct device *dev = &gpmc_onenand_device.dev;\r\nif (omap2_onenand_set_sync_mode(gpmc_onenand_data, onenand_base,\r\nfreq_ptr) < 0) {\r\ndev_err(dev, "Unable to set synchronous mode\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid __init gpmc_onenand_init(struct omap_onenand_platform_data *_onenand_data)\r\n{\r\ngpmc_onenand_data = _onenand_data;\r\ngpmc_onenand_data->onenand_setup = gpmc_onenand_setup;\r\ngpmc_onenand_device.dev.platform_data = gpmc_onenand_data;\r\nif (cpu_is_omap24xx() &&\r\n(gpmc_onenand_data->flags & ONENAND_SYNC_READWRITE)) {\r\nprintk(KERN_ERR "Onenand using only SYNC_READ on 24xx\n");\r\ngpmc_onenand_data->flags &= ~ONENAND_SYNC_READWRITE;\r\ngpmc_onenand_data->flags |= ONENAND_SYNC_READ;\r\n}\r\nif (platform_device_register(&gpmc_onenand_device) < 0) {\r\nprintk(KERN_ERR "Unable to register OneNAND device\n");\r\nreturn;\r\n}\r\n}
