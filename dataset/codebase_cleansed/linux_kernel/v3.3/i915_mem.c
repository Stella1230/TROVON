static void mark_block(struct drm_device * dev, struct mem_block *p, int in_use)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nstruct drm_i915_master_private *master_priv = dev->primary->master->driver_priv;\r\ndrm_i915_sarea_t *sarea_priv = master_priv->sarea_priv;\r\nstruct drm_tex_region *list;\r\nunsigned shift, nr;\r\nunsigned start;\r\nunsigned end;\r\nunsigned i;\r\nint age;\r\nshift = dev_priv->tex_lru_log_granularity;\r\nnr = I915_NR_TEX_REGIONS;\r\nstart = p->start >> shift;\r\nend = (p->start + p->size - 1) >> shift;\r\nage = ++sarea_priv->texAge;\r\nlist = sarea_priv->texList;\r\nfor (i = start; i <= end; i++) {\r\nlist[i].in_use = in_use;\r\nlist[i].age = age;\r\nlist[(unsigned)list[i].next].prev = list[i].prev;\r\nlist[(unsigned)list[i].prev].next = list[i].next;\r\nlist[i].prev = nr;\r\nlist[i].next = list[nr].next;\r\nlist[(unsigned)list[nr].next].prev = i;\r\nlist[nr].next = i;\r\n}\r\n}\r\nstatic struct mem_block *split_block(struct mem_block *p, int start, int size,\r\nstruct drm_file *file_priv)\r\n{\r\nif (start > p->start) {\r\nstruct mem_block *newblock = kmalloc(sizeof(*newblock),\r\nGFP_KERNEL);\r\nif (!newblock)\r\ngoto out;\r\nnewblock->start = start;\r\nnewblock->size = p->size - (start - p->start);\r\nnewblock->file_priv = NULL;\r\nnewblock->next = p->next;\r\nnewblock->prev = p;\r\np->next->prev = newblock;\r\np->next = newblock;\r\np->size -= newblock->size;\r\np = newblock;\r\n}\r\nif (size < p->size) {\r\nstruct mem_block *newblock = kmalloc(sizeof(*newblock),\r\nGFP_KERNEL);\r\nif (!newblock)\r\ngoto out;\r\nnewblock->start = start + size;\r\nnewblock->size = p->size - size;\r\nnewblock->file_priv = NULL;\r\nnewblock->next = p->next;\r\nnewblock->prev = p;\r\np->next->prev = newblock;\r\np->next = newblock;\r\np->size = size;\r\n}\r\nout:\r\np->file_priv = file_priv;\r\nreturn p;\r\n}\r\nstatic struct mem_block *alloc_block(struct mem_block *heap, int size,\r\nint align2, struct drm_file *file_priv)\r\n{\r\nstruct mem_block *p;\r\nint mask = (1 << align2) - 1;\r\nfor (p = heap->next; p != heap; p = p->next) {\r\nint start = (p->start + mask) & ~mask;\r\nif (p->file_priv == NULL && start + size <= p->start + p->size)\r\nreturn split_block(p, start, size, file_priv);\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mem_block *find_block(struct mem_block *heap, int start)\r\n{\r\nstruct mem_block *p;\r\nfor (p = heap->next; p != heap; p = p->next)\r\nif (p->start == start)\r\nreturn p;\r\nreturn NULL;\r\n}\r\nstatic void free_block(struct mem_block *p)\r\n{\r\np->file_priv = NULL;\r\nif (p->next->file_priv == NULL) {\r\nstruct mem_block *q = p->next;\r\np->size += q->size;\r\np->next = q->next;\r\np->next->prev = p;\r\nkfree(q);\r\n}\r\nif (p->prev->file_priv == NULL) {\r\nstruct mem_block *q = p->prev;\r\nq->size += p->size;\r\nq->next = p->next;\r\nq->next->prev = q;\r\nkfree(p);\r\n}\r\n}\r\nstatic int init_heap(struct mem_block **heap, int start, int size)\r\n{\r\nstruct mem_block *blocks = kmalloc(sizeof(*blocks), GFP_KERNEL);\r\nif (!blocks)\r\nreturn -ENOMEM;\r\n*heap = kmalloc(sizeof(**heap), GFP_KERNEL);\r\nif (!*heap) {\r\nkfree(blocks);\r\nreturn -ENOMEM;\r\n}\r\nblocks->start = start;\r\nblocks->size = size;\r\nblocks->file_priv = NULL;\r\nblocks->next = blocks->prev = *heap;\r\nmemset(*heap, 0, sizeof(**heap));\r\n(*heap)->file_priv = (struct drm_file *) -1;\r\n(*heap)->next = (*heap)->prev = blocks;\r\nreturn 0;\r\n}\r\nvoid i915_mem_release(struct drm_device * dev, struct drm_file *file_priv,\r\nstruct mem_block *heap)\r\n{\r\nstruct mem_block *p;\r\nif (!heap || !heap->next)\r\nreturn;\r\nfor (p = heap->next; p != heap; p = p->next) {\r\nif (p->file_priv == file_priv) {\r\np->file_priv = NULL;\r\nmark_block(dev, p, 0);\r\n}\r\n}\r\nfor (p = heap->next; p != heap; p = p->next) {\r\nwhile (p->file_priv == NULL && p->next->file_priv == NULL) {\r\nstruct mem_block *q = p->next;\r\np->size += q->size;\r\np->next = q->next;\r\np->next->prev = p;\r\nkfree(q);\r\n}\r\n}\r\n}\r\nvoid i915_mem_takedown(struct mem_block **heap)\r\n{\r\nstruct mem_block *p;\r\nif (!*heap)\r\nreturn;\r\nfor (p = (*heap)->next; p != *heap;) {\r\nstruct mem_block *q = p;\r\np = p->next;\r\nkfree(q);\r\n}\r\nkfree(*heap);\r\n*heap = NULL;\r\n}\r\nstatic struct mem_block **get_heap(drm_i915_private_t * dev_priv, int region)\r\n{\r\nswitch (region) {\r\ncase I915_MEM_REGION_AGP:\r\nreturn &dev_priv->agp_heap;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nint i915_mem_alloc(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\ndrm_i915_mem_alloc_t *alloc = data;\r\nstruct mem_block *block, **heap;\r\nif (!dev_priv) {\r\nDRM_ERROR("called with no initialization\n");\r\nreturn -EINVAL;\r\n}\r\nheap = get_heap(dev_priv, alloc->region);\r\nif (!heap || !*heap)\r\nreturn -EFAULT;\r\nif (alloc->alignment < 12)\r\nalloc->alignment = 12;\r\nblock = alloc_block(*heap, alloc->size, alloc->alignment, file_priv);\r\nif (!block)\r\nreturn -ENOMEM;\r\nmark_block(dev, block, 1);\r\nif (DRM_COPY_TO_USER(alloc->region_offset, &block->start,\r\nsizeof(int))) {\r\nDRM_ERROR("copy_to_user\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nint i915_mem_free(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\ndrm_i915_mem_free_t *memfree = data;\r\nstruct mem_block *block, **heap;\r\nif (!dev_priv) {\r\nDRM_ERROR("called with no initialization\n");\r\nreturn -EINVAL;\r\n}\r\nheap = get_heap(dev_priv, memfree->region);\r\nif (!heap || !*heap)\r\nreturn -EFAULT;\r\nblock = find_block(*heap, memfree->region_offset);\r\nif (!block)\r\nreturn -EFAULT;\r\nif (block->file_priv != file_priv)\r\nreturn -EPERM;\r\nmark_block(dev, block, 0);\r\nfree_block(block);\r\nreturn 0;\r\n}\r\nint i915_mem_init_heap(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\ndrm_i915_mem_init_heap_t *initheap = data;\r\nstruct mem_block **heap;\r\nif (!dev_priv) {\r\nDRM_ERROR("called with no initialization\n");\r\nreturn -EINVAL;\r\n}\r\nheap = get_heap(dev_priv, initheap->region);\r\nif (!heap)\r\nreturn -EFAULT;\r\nif (*heap) {\r\nDRM_ERROR("heap already initialized?");\r\nreturn -EFAULT;\r\n}\r\nreturn init_heap(heap, initheap->start, initheap->size);\r\n}\r\nint i915_mem_destroy_heap(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\ndrm_i915_mem_destroy_heap_t *destroyheap = data;\r\nstruct mem_block **heap;\r\nif (!dev_priv) {\r\nDRM_ERROR("called with no initialization\n");\r\nreturn -EINVAL;\r\n}\r\nheap = get_heap(dev_priv, destroyheap->region);\r\nif (!heap) {\r\nDRM_ERROR("get_heap failed");\r\nreturn -EFAULT;\r\n}\r\nif (!*heap) {\r\nDRM_ERROR("heap not initialized?");\r\nreturn -EFAULT;\r\n}\r\ni915_mem_takedown(heap);\r\nreturn 0;\r\n}
