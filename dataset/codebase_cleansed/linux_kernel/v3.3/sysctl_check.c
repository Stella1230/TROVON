static int sysctl_depth(struct ctl_table *table)\r\n{\r\nstruct ctl_table *tmp;\r\nint depth;\r\ndepth = 0;\r\nfor (tmp = table; tmp->parent; tmp = tmp->parent)\r\ndepth++;\r\nreturn depth;\r\n}\r\nstatic struct ctl_table *sysctl_parent(struct ctl_table *table, int n)\r\n{\r\nint i;\r\nfor (i = 0; table && i < n; i++)\r\ntable = table->parent;\r\nreturn table;\r\n}\r\nstatic void sysctl_print_path(struct ctl_table *table)\r\n{\r\nstruct ctl_table *tmp;\r\nint depth, i;\r\ndepth = sysctl_depth(table);\r\nif (table->procname) {\r\nfor (i = depth; i >= 0; i--) {\r\ntmp = sysctl_parent(table, i);\r\nprintk("/%s", tmp->procname?tmp->procname:"");\r\n}\r\n}\r\nprintk(" ");\r\n}\r\nstatic struct ctl_table *sysctl_check_lookup(struct nsproxy *namespaces,\r\nstruct ctl_table *table)\r\n{\r\nstruct ctl_table_header *head;\r\nstruct ctl_table *ref, *test;\r\nint depth, cur_depth;\r\ndepth = sysctl_depth(table);\r\nfor (head = __sysctl_head_next(namespaces, NULL); head;\r\nhead = __sysctl_head_next(namespaces, head)) {\r\ncur_depth = depth;\r\nref = head->ctl_table;\r\nrepeat:\r\ntest = sysctl_parent(table, cur_depth);\r\nfor (; ref->procname; ref++) {\r\nint match = 0;\r\nif (cur_depth && !ref->child)\r\ncontinue;\r\nif (test->procname && ref->procname &&\r\n(strcmp(test->procname, ref->procname) == 0))\r\nmatch++;\r\nif (match) {\r\nif (cur_depth != 0) {\r\ncur_depth--;\r\nref = ref->child;\r\ngoto repeat;\r\n}\r\ngoto out;\r\n}\r\n}\r\n}\r\nref = NULL;\r\nout:\r\nsysctl_head_finish(head);\r\nreturn ref;\r\n}\r\nstatic void set_fail(const char **fail, struct ctl_table *table, const char *str)\r\n{\r\nif (*fail) {\r\nprintk(KERN_ERR "sysctl table check failed: ");\r\nsysctl_print_path(table);\r\nprintk(" %s\n", *fail);\r\ndump_stack();\r\n}\r\n*fail = str;\r\n}\r\nstatic void sysctl_check_leaf(struct nsproxy *namespaces,\r\nstruct ctl_table *table, const char **fail)\r\n{\r\nstruct ctl_table *ref;\r\nref = sysctl_check_lookup(namespaces, table);\r\nif (ref && (ref != table))\r\nset_fail(fail, table, "Sysctl already exists");\r\n}\r\nint sysctl_check_table(struct nsproxy *namespaces, struct ctl_table *table)\r\n{\r\nint error = 0;\r\nfor (; table->procname; table++) {\r\nconst char *fail = NULL;\r\nif (table->parent) {\r\nif (!table->parent->procname)\r\nset_fail(&fail, table, "Parent without procname");\r\n}\r\nif (table->child) {\r\nif (table->data)\r\nset_fail(&fail, table, "Directory with data?");\r\nif (table->maxlen)\r\nset_fail(&fail, table, "Directory with maxlen?");\r\nif ((table->mode & (S_IRUGO|S_IXUGO)) != table->mode)\r\nset_fail(&fail, table, "Writable sysctl directory");\r\nif (table->proc_handler)\r\nset_fail(&fail, table, "Directory with proc_handler");\r\nif (table->extra1)\r\nset_fail(&fail, table, "Directory with extra1");\r\nif (table->extra2)\r\nset_fail(&fail, table, "Directory with extra2");\r\n} else {\r\nif ((table->proc_handler == proc_dostring) ||\r\n(table->proc_handler == proc_dointvec) ||\r\n(table->proc_handler == proc_dointvec_minmax) ||\r\n(table->proc_handler == proc_dointvec_jiffies) ||\r\n(table->proc_handler == proc_dointvec_userhz_jiffies) ||\r\n(table->proc_handler == proc_dointvec_ms_jiffies) ||\r\n(table->proc_handler == proc_doulongvec_minmax) ||\r\n(table->proc_handler == proc_doulongvec_ms_jiffies_minmax)) {\r\nif (!table->data)\r\nset_fail(&fail, table, "No data");\r\nif (!table->maxlen)\r\nset_fail(&fail, table, "No maxlen");\r\n}\r\n#ifdef CONFIG_PROC_SYSCTL\r\nif (!table->proc_handler)\r\nset_fail(&fail, table, "No proc_handler");\r\n#endif\r\nsysctl_check_leaf(namespaces, table, &fail);\r\n}\r\nif (table->mode > 0777)\r\nset_fail(&fail, table, "bogus .mode");\r\nif (fail) {\r\nset_fail(&fail, table, NULL);\r\nerror = -EINVAL;\r\n}\r\nif (table->child)\r\nerror |= sysctl_check_table(namespaces, table->child);\r\n}\r\nreturn error;\r\n}
