static int write_reg(struct i2c_client *client, u8 reg, u8 value, int channel)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg | (channel << 6), value);\r\n}\r\nstatic int write_regs(struct i2c_client *client, u8 *regs, int channel)\r\n{\r\nint i;\r\nfor (i = 0; regs[i] != 0xff; i += 2)\r\nif (i2c_smbus_write_byte_data(client,\r\nregs[i] | (channel << 6), regs[i + 1]) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int wis_tw2804_command(struct i2c_client *client,\r\nunsigned int cmd, void *arg)\r\n{\r\nstruct wis_tw2804 *dec = i2c_get_clientdata(client);\r\nif (cmd == DECODER_SET_CHANNEL) {\r\nint *input = arg;\r\nif (*input < 0 || *input > 3) {\r\nprintk(KERN_ERR "wis-tw2804: channel %d is not "\r\n"between 0 and 3!\n", *input);\r\nreturn 0;\r\n}\r\ndec->channel = *input;\r\nprintk(KERN_DEBUG "wis-tw2804: initializing TW2804 "\r\n"channel %d\n", dec->channel);\r\nif (dec->channel == 0 &&\r\nwrite_regs(client, global_registers, 0) < 0) {\r\nprintk(KERN_ERR "wis-tw2804: error initializing "\r\n"TW2804 global registers\n");\r\nreturn 0;\r\n}\r\nif (write_regs(client, channel_registers, dec->channel) < 0) {\r\nprintk(KERN_ERR "wis-tw2804: error initializing "\r\n"TW2804 channel %d\n", dec->channel);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nif (dec->channel < 0) {\r\nprintk(KERN_DEBUG "wis-tw2804: ignoring command %08x until "\r\n"channel number is set\n", cmd);\r\nreturn 0;\r\n}\r\nswitch (cmd) {\r\ncase VIDIOC_S_STD:\r\n{\r\nv4l2_std_id *input = arg;\r\nu8 regs[] = {\r\n0x01, *input & V4L2_STD_NTSC ? 0xc4 : 0x84,\r\n0x09, *input & V4L2_STD_NTSC ? 0x07 : 0x04,\r\n0x0a, *input & V4L2_STD_NTSC ? 0xf0 : 0x20,\r\n0x0b, *input & V4L2_STD_NTSC ? 0x07 : 0x04,\r\n0x0c, *input & V4L2_STD_NTSC ? 0xf0 : 0x20,\r\n0x0d, *input & V4L2_STD_NTSC ? 0x40 : 0x4a,\r\n0x16, *input & V4L2_STD_NTSC ? 0x00 : 0x40,\r\n0x17, *input & V4L2_STD_NTSC ? 0x00 : 0x40,\r\n0x20, *input & V4L2_STD_NTSC ? 0x07 : 0x0f,\r\n0x21, *input & V4L2_STD_NTSC ? 0x07 : 0x0f,\r\n0xff, 0xff,\r\n};\r\nwrite_regs(client, regs, dec->channel);\r\ndec->norm = *input;\r\nbreak;\r\n}\r\ncase VIDIOC_QUERYCTRL:\r\n{\r\nstruct v4l2_queryctrl *ctrl = arg;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nctrl->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrncpy(ctrl->name, "Brightness", sizeof(ctrl->name));\r\nctrl->minimum = 0;\r\nctrl->maximum = 255;\r\nctrl->step = 1;\r\nctrl->default_value = 128;\r\nctrl->flags = 0;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nctrl->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrncpy(ctrl->name, "Contrast", sizeof(ctrl->name));\r\nctrl->minimum = 0;\r\nctrl->maximum = 255;\r\nctrl->step = 1;\r\nctrl->default_value = 128;\r\nctrl->flags = 0;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nctrl->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrncpy(ctrl->name, "Saturation", sizeof(ctrl->name));\r\nctrl->minimum = 0;\r\nctrl->maximum = 255;\r\nctrl->step = 1;\r\nctrl->default_value = 128;\r\nctrl->flags = 0;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nctrl->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrncpy(ctrl->name, "Hue", sizeof(ctrl->name));\r\nctrl->minimum = 0;\r\nctrl->maximum = 255;\r\nctrl->step = 1;\r\nctrl->default_value = 128;\r\nctrl->flags = 0;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_S_CTRL:\r\n{\r\nstruct v4l2_control *ctrl = arg;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nif (ctrl->value > 255)\r\ndec->brightness = 255;\r\nelse if (ctrl->value < 0)\r\ndec->brightness = 0;\r\nelse\r\ndec->brightness = ctrl->value;\r\nwrite_reg(client, 0x12, dec->brightness, dec->channel);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nif (ctrl->value > 255)\r\ndec->contrast = 255;\r\nelse if (ctrl->value < 0)\r\ndec->contrast = 0;\r\nelse\r\ndec->contrast = ctrl->value;\r\nwrite_reg(client, 0x11, dec->contrast, dec->channel);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nif (ctrl->value > 255)\r\ndec->saturation = 255;\r\nelse if (ctrl->value < 0)\r\ndec->saturation = 0;\r\nelse\r\ndec->saturation = ctrl->value;\r\nwrite_reg(client, 0x10, dec->saturation, dec->channel);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nif (ctrl->value > 255)\r\ndec->hue = 255;\r\nelse if (ctrl->value < 0)\r\ndec->hue = 0;\r\nelse\r\ndec->hue = ctrl->value;\r\nwrite_reg(client, 0x0f, dec->hue, dec->channel);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_G_CTRL:\r\n{\r\nstruct v4l2_control *ctrl = arg;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nctrl->value = dec->brightness;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nctrl->value = dec->contrast;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nctrl->value = dec->saturation;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nctrl->value = dec->hue;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wis_tw2804_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct wis_tw2804 *dec;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\ndec = kmalloc(sizeof(struct wis_tw2804), GFP_KERNEL);\r\nif (dec == NULL)\r\nreturn -ENOMEM;\r\ndec->channel = -1;\r\ndec->norm = V4L2_STD_NTSC;\r\ndec->brightness = 128;\r\ndec->contrast = 128;\r\ndec->saturation = 128;\r\ndec->hue = 128;\r\ni2c_set_clientdata(client, dec);\r\nprintk(KERN_DEBUG "wis-tw2804: creating TW2804 at address %d on %s\n",\r\nclient->addr, adapter->name);\r\nreturn 0;\r\n}\r\nstatic int wis_tw2804_remove(struct i2c_client *client)\r\n{\r\nstruct wis_tw2804 *dec = i2c_get_clientdata(client);\r\nkfree(dec);\r\nreturn 0;\r\n}\r\nstatic int __init wis_tw2804_init(void)\r\n{\r\nreturn i2c_add_driver(&wis_tw2804_driver);\r\n}\r\nstatic void __exit wis_tw2804_cleanup(void)\r\n{\r\ni2c_del_driver(&wis_tw2804_driver);\r\n}
