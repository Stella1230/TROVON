static inline void print_err_status(struct au0828_dev *dev,\r\nint packet, int status)\r\n{\r\nchar *errmsg = "Unknown";\r\nswitch (status) {\r\ncase -ENOENT:\r\nerrmsg = "unlinked synchronuously";\r\nbreak;\r\ncase -ECONNRESET:\r\nerrmsg = "unlinked asynchronuously";\r\nbreak;\r\ncase -ENOSR:\r\nerrmsg = "Buffer error (overrun)";\r\nbreak;\r\ncase -EPIPE:\r\nerrmsg = "Stalled (device not responding)";\r\nbreak;\r\ncase -EOVERFLOW:\r\nerrmsg = "Babble (bad cable?)";\r\nbreak;\r\ncase -EPROTO:\r\nerrmsg = "Bit-stuff error (bad cable?)";\r\nbreak;\r\ncase -EILSEQ:\r\nerrmsg = "CRC/Timeout (could be anything)";\r\nbreak;\r\ncase -ETIME:\r\nerrmsg = "Device does not respond";\r\nbreak;\r\n}\r\nif (packet < 0) {\r\nau0828_isocdbg("URB status %d [%s].\n", status, errmsg);\r\n} else {\r\nau0828_isocdbg("URB packet %d, status %d [%s].\n",\r\npacket, status, errmsg);\r\n}\r\n}\r\nstatic int check_dev(struct au0828_dev *dev)\r\n{\r\nif (dev->dev_state & DEV_DISCONNECTED) {\r\nprintk(KERN_INFO "v4l2 ioctl: device not present\n");\r\nreturn -ENODEV;\r\n}\r\nif (dev->dev_state & DEV_MISCONFIGURED) {\r\nprintk(KERN_INFO "v4l2 ioctl: device is misconfigured; "\r\n"close and open it again\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void au0828_irq_callback(struct urb *urb)\r\n{\r\nstruct au0828_dmaqueue *dma_q = urb->context;\r\nstruct au0828_dev *dev = container_of(dma_q, struct au0828_dev, vidq);\r\nunsigned long flags = 0;\r\nint rc, i;\r\nswitch (urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nau0828_isocdbg("au0828_irq_callback called: status kill\n");\r\nreturn;\r\ndefault:\r\nau0828_isocdbg("urb completition error %d.\n", urb->status);\r\nbreak;\r\n}\r\nspin_lock_irqsave(&dev->slock, flags);\r\nrc = dev->isoc_ctl.isoc_copy(dev, urb);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nurb->iso_frame_desc[i].status = 0;\r\nurb->iso_frame_desc[i].actual_length = 0;\r\n}\r\nurb->status = 0;\r\nurb->status = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (urb->status) {\r\nau0828_isocdbg("urb resubmit failed (error=%i)\n",\r\nurb->status);\r\n}\r\n}\r\nvoid au0828_uninit_isoc(struct au0828_dev *dev)\r\n{\r\nstruct urb *urb;\r\nint i;\r\nau0828_isocdbg("au0828: called au0828_uninit_isoc\n");\r\ndev->isoc_ctl.nfields = -1;\r\nfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\r\nurb = dev->isoc_ctl.urb[i];\r\nif (urb) {\r\nif (!irqs_disabled())\r\nusb_kill_urb(urb);\r\nelse\r\nusb_unlink_urb(urb);\r\nif (dev->isoc_ctl.transfer_buffer[i]) {\r\nusb_free_coherent(dev->usbdev,\r\nurb->transfer_buffer_length,\r\ndev->isoc_ctl.transfer_buffer[i],\r\nurb->transfer_dma);\r\n}\r\nusb_free_urb(urb);\r\ndev->isoc_ctl.urb[i] = NULL;\r\n}\r\ndev->isoc_ctl.transfer_buffer[i] = NULL;\r\n}\r\nkfree(dev->isoc_ctl.urb);\r\nkfree(dev->isoc_ctl.transfer_buffer);\r\ndev->isoc_ctl.urb = NULL;\r\ndev->isoc_ctl.transfer_buffer = NULL;\r\ndev->isoc_ctl.num_bufs = 0;\r\n}\r\nint au0828_init_isoc(struct au0828_dev *dev, int max_packets,\r\nint num_bufs, int max_pkt_size,\r\nint (*isoc_copy) (struct au0828_dev *dev, struct urb *urb))\r\n{\r\nstruct au0828_dmaqueue *dma_q = &dev->vidq;\r\nint i;\r\nint sb_size, pipe;\r\nstruct urb *urb;\r\nint j, k;\r\nint rc;\r\nau0828_isocdbg("au0828: called au0828_prepare_isoc\n");\r\nau0828_uninit_isoc(dev);\r\ndev->isoc_ctl.isoc_copy = isoc_copy;\r\ndev->isoc_ctl.num_bufs = num_bufs;\r\ndev->isoc_ctl.urb = kzalloc(sizeof(void *)*num_bufs, GFP_KERNEL);\r\nif (!dev->isoc_ctl.urb) {\r\nau0828_isocdbg("cannot alloc memory for usb buffers\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->isoc_ctl.transfer_buffer = kzalloc(sizeof(void *)*num_bufs,\r\nGFP_KERNEL);\r\nif (!dev->isoc_ctl.transfer_buffer) {\r\nau0828_isocdbg("cannot allocate memory for usb transfer\n");\r\nkfree(dev->isoc_ctl.urb);\r\nreturn -ENOMEM;\r\n}\r\ndev->isoc_ctl.max_pkt_size = max_pkt_size;\r\ndev->isoc_ctl.buf = NULL;\r\nsb_size = max_packets * dev->isoc_ctl.max_pkt_size;\r\nfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\r\nurb = usb_alloc_urb(max_packets, GFP_KERNEL);\r\nif (!urb) {\r\nau0828_isocdbg("cannot alloc isoc_ctl.urb %i\n", i);\r\nau0828_uninit_isoc(dev);\r\nreturn -ENOMEM;\r\n}\r\ndev->isoc_ctl.urb[i] = urb;\r\ndev->isoc_ctl.transfer_buffer[i] = usb_alloc_coherent(dev->usbdev,\r\nsb_size, GFP_KERNEL, &urb->transfer_dma);\r\nif (!dev->isoc_ctl.transfer_buffer[i]) {\r\nprintk("unable to allocate %i bytes for transfer"\r\n" buffer %i%s\n",\r\nsb_size, i,\r\nin_interrupt() ? " while in int" : "");\r\nau0828_uninit_isoc(dev);\r\nreturn -ENOMEM;\r\n}\r\nmemset(dev->isoc_ctl.transfer_buffer[i], 0, sb_size);\r\npipe = usb_rcvisocpipe(dev->usbdev,\r\ndev->isoc_in_endpointaddr),\r\nusb_fill_int_urb(urb, dev->usbdev, pipe,\r\ndev->isoc_ctl.transfer_buffer[i], sb_size,\r\nau0828_irq_callback, dma_q, 1);\r\nurb->number_of_packets = max_packets;\r\nurb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\r\nk = 0;\r\nfor (j = 0; j < max_packets; j++) {\r\nurb->iso_frame_desc[j].offset = k;\r\nurb->iso_frame_desc[j].length =\r\ndev->isoc_ctl.max_pkt_size;\r\nk += dev->isoc_ctl.max_pkt_size;\r\n}\r\n}\r\ninit_waitqueue_head(&dma_q->wq);\r\nfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\r\nrc = usb_submit_urb(dev->isoc_ctl.urb[i], GFP_ATOMIC);\r\nif (rc) {\r\nau0828_isocdbg("submit of urb %i failed (error=%i)\n",\r\ni, rc);\r\nau0828_uninit_isoc(dev);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void buffer_filled(struct au0828_dev *dev,\r\nstruct au0828_dmaqueue *dma_q,\r\nstruct au0828_buffer *buf)\r\n{\r\nau0828_isocdbg("[%p/%d] wakeup\n", buf, buf->vb.i);\r\nbuf->vb.state = VIDEOBUF_DONE;\r\nbuf->vb.field_count++;\r\ndo_gettimeofday(&buf->vb.ts);\r\ndev->isoc_ctl.buf = NULL;\r\nlist_del(&buf->vb.queue);\r\nwake_up(&buf->vb.done);\r\n}\r\nstatic inline void vbi_buffer_filled(struct au0828_dev *dev,\r\nstruct au0828_dmaqueue *dma_q,\r\nstruct au0828_buffer *buf)\r\n{\r\nau0828_isocdbg("[%p/%d] wakeup\n", buf, buf->vb.i);\r\nbuf->vb.state = VIDEOBUF_DONE;\r\nbuf->vb.field_count++;\r\ndo_gettimeofday(&buf->vb.ts);\r\ndev->isoc_ctl.vbi_buf = NULL;\r\nlist_del(&buf->vb.queue);\r\nwake_up(&buf->vb.done);\r\n}\r\nstatic void au0828_copy_video(struct au0828_dev *dev,\r\nstruct au0828_dmaqueue *dma_q,\r\nstruct au0828_buffer *buf,\r\nunsigned char *p,\r\nunsigned char *outp, unsigned long len)\r\n{\r\nvoid *fieldstart, *startwrite, *startread;\r\nint linesdone, currlinedone, offset, lencopy, remain;\r\nint bytesperline = dev->width << 1;\r\nif (len == 0)\r\nreturn;\r\nif (dma_q->pos + len > buf->vb.size)\r\nlen = buf->vb.size - dma_q->pos;\r\nstartread = p;\r\nremain = len;\r\nif (buf->top_field)\r\nfieldstart = outp;\r\nelse\r\nfieldstart = outp + bytesperline;\r\nlinesdone = dma_q->pos / bytesperline;\r\ncurrlinedone = dma_q->pos % bytesperline;\r\noffset = linesdone * bytesperline * 2 + currlinedone;\r\nstartwrite = fieldstart + offset;\r\nlencopy = bytesperline - currlinedone;\r\nlencopy = lencopy > remain ? remain : lencopy;\r\nif ((char *)startwrite + lencopy > (char *)outp + buf->vb.size) {\r\nau0828_isocdbg("Overflow of %zi bytes past buffer end (1)\n",\r\n((char *)startwrite + lencopy) -\r\n((char *)outp + buf->vb.size));\r\nremain = (char *)outp + buf->vb.size - (char *)startwrite;\r\nlencopy = remain;\r\n}\r\nif (lencopy <= 0)\r\nreturn;\r\nmemcpy(startwrite, startread, lencopy);\r\nremain -= lencopy;\r\nwhile (remain > 0) {\r\nstartwrite += lencopy + bytesperline;\r\nstartread += lencopy;\r\nif (bytesperline > remain)\r\nlencopy = remain;\r\nelse\r\nlencopy = bytesperline;\r\nif ((char *)startwrite + lencopy > (char *)outp +\r\nbuf->vb.size) {\r\nau0828_isocdbg("Overflow %zi bytes past buf end (2)\n",\r\n((char *)startwrite + lencopy) -\r\n((char *)outp + buf->vb.size));\r\nlencopy = remain = (char *)outp + buf->vb.size -\r\n(char *)startwrite;\r\n}\r\nif (lencopy <= 0)\r\nbreak;\r\nmemcpy(startwrite, startread, lencopy);\r\nremain -= lencopy;\r\n}\r\nif (offset > 1440) {\r\nif (outp[0] < 0x60 && outp[1440] < 0x60)\r\ndev->greenscreen_detected = 1;\r\n}\r\ndma_q->pos += len;\r\n}\r\nstatic inline void get_next_buf(struct au0828_dmaqueue *dma_q,\r\nstruct au0828_buffer **buf)\r\n{\r\nstruct au0828_dev *dev = container_of(dma_q, struct au0828_dev, vidq);\r\nif (list_empty(&dma_q->active)) {\r\nau0828_isocdbg("No active queue to serve\n");\r\ndev->isoc_ctl.buf = NULL;\r\n*buf = NULL;\r\nreturn;\r\n}\r\n*buf = list_entry(dma_q->active.next, struct au0828_buffer, vb.queue);\r\ndev->isoc_ctl.buf = *buf;\r\nreturn;\r\n}\r\nstatic void au0828_copy_vbi(struct au0828_dev *dev,\r\nstruct au0828_dmaqueue *dma_q,\r\nstruct au0828_buffer *buf,\r\nunsigned char *p,\r\nunsigned char *outp, unsigned long len)\r\n{\r\nunsigned char *startwrite, *startread;\r\nint bytesperline;\r\nint i, j = 0;\r\nif (dev == NULL) {\r\nau0828_isocdbg("dev is null\n");\r\nreturn;\r\n}\r\nif (dma_q == NULL) {\r\nau0828_isocdbg("dma_q is null\n");\r\nreturn;\r\n}\r\nif (buf == NULL)\r\nreturn;\r\nif (p == NULL) {\r\nau0828_isocdbg("p is null\n");\r\nreturn;\r\n}\r\nif (outp == NULL) {\r\nau0828_isocdbg("outp is null\n");\r\nreturn;\r\n}\r\nbytesperline = dev->vbi_width;\r\nif (dma_q->pos + len > buf->vb.size)\r\nlen = buf->vb.size - dma_q->pos;\r\nstartread = p;\r\nstartwrite = outp + (dma_q->pos / 2);\r\nif (buf->top_field == 0)\r\nstartwrite += bytesperline * dev->vbi_height;\r\nfor (i = 0; i < len; i += 2)\r\nstartwrite[j++] = startread[i+1];\r\ndma_q->pos += len;\r\n}\r\nstatic inline void vbi_get_next_buf(struct au0828_dmaqueue *dma_q,\r\nstruct au0828_buffer **buf)\r\n{\r\nstruct au0828_dev *dev = container_of(dma_q, struct au0828_dev, vbiq);\r\nchar *outp;\r\nif (list_empty(&dma_q->active)) {\r\nau0828_isocdbg("No active queue to serve\n");\r\ndev->isoc_ctl.vbi_buf = NULL;\r\n*buf = NULL;\r\nreturn;\r\n}\r\n*buf = list_entry(dma_q->active.next, struct au0828_buffer, vb.queue);\r\noutp = videobuf_to_vmalloc(&(*buf)->vb);\r\nmemset(outp, 0x00, (*buf)->vb.size);\r\ndev->isoc_ctl.vbi_buf = *buf;\r\nreturn;\r\n}\r\nstatic inline int au0828_isoc_copy(struct au0828_dev *dev, struct urb *urb)\r\n{\r\nstruct au0828_buffer *buf;\r\nstruct au0828_buffer *vbi_buf;\r\nstruct au0828_dmaqueue *dma_q = urb->context;\r\nstruct au0828_dmaqueue *vbi_dma_q = &dev->vbiq;\r\nunsigned char *outp = NULL;\r\nunsigned char *vbioutp = NULL;\r\nint i, len = 0, rc = 1;\r\nunsigned char *p;\r\nunsigned char fbyte;\r\nunsigned int vbi_field_size;\r\nunsigned int remain, lencopy;\r\nif (!dev)\r\nreturn 0;\r\nif ((dev->dev_state & DEV_DISCONNECTED) ||\r\n(dev->dev_state & DEV_MISCONFIGURED))\r\nreturn 0;\r\nif (urb->status < 0) {\r\nprint_err_status(dev, -1, urb->status);\r\nif (urb->status == -ENOENT)\r\nreturn 0;\r\n}\r\nbuf = dev->isoc_ctl.buf;\r\nif (buf != NULL)\r\noutp = videobuf_to_vmalloc(&buf->vb);\r\nvbi_buf = dev->isoc_ctl.vbi_buf;\r\nif (vbi_buf != NULL)\r\nvbioutp = videobuf_to_vmalloc(&vbi_buf->vb);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nint status = urb->iso_frame_desc[i].status;\r\nif (status < 0) {\r\nprint_err_status(dev, i, status);\r\nif (urb->iso_frame_desc[i].status != -EPROTO)\r\ncontinue;\r\n}\r\nif (urb->iso_frame_desc[i].actual_length <= 0)\r\ncontinue;\r\nif (urb->iso_frame_desc[i].actual_length >\r\ndev->max_pkt_size) {\r\nau0828_isocdbg("packet bigger than packet size");\r\ncontinue;\r\n}\r\np = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nfbyte = p[0];\r\nlen = urb->iso_frame_desc[i].actual_length - 4;\r\np += 4;\r\nif (fbyte & 0x80) {\r\nlen -= 4;\r\np += 4;\r\nau0828_isocdbg("Video frame %s\n",\r\n(fbyte & 0x40) ? "odd" : "even");\r\nif (fbyte & 0x40) {\r\nif (vbi_buf != NULL)\r\nvbi_buffer_filled(dev,\r\nvbi_dma_q,\r\nvbi_buf);\r\nvbi_get_next_buf(vbi_dma_q, &vbi_buf);\r\nif (vbi_buf == NULL)\r\nvbioutp = NULL;\r\nelse\r\nvbioutp = videobuf_to_vmalloc(\r\n&vbi_buf->vb);\r\nif (buf != NULL)\r\nbuffer_filled(dev, dma_q, buf);\r\nget_next_buf(dma_q, &buf);\r\nif (buf == NULL)\r\noutp = NULL;\r\nelse\r\noutp = videobuf_to_vmalloc(&buf->vb);\r\nif (dev->vid_timeout_running)\r\nmod_timer(&dev->vid_timeout,\r\njiffies + (HZ / 10));\r\nif (dev->vbi_timeout_running)\r\nmod_timer(&dev->vbi_timeout,\r\njiffies + (HZ / 10));\r\n}\r\nif (buf != NULL) {\r\nif (fbyte & 0x40)\r\nbuf->top_field = 1;\r\nelse\r\nbuf->top_field = 0;\r\n}\r\nif (vbi_buf != NULL) {\r\nif (fbyte & 0x40)\r\nvbi_buf->top_field = 1;\r\nelse\r\nvbi_buf->top_field = 0;\r\n}\r\ndev->vbi_read = 0;\r\nvbi_dma_q->pos = 0;\r\ndma_q->pos = 0;\r\n}\r\nvbi_field_size = dev->vbi_width * dev->vbi_height * 2;\r\nif (dev->vbi_read < vbi_field_size) {\r\nremain = vbi_field_size - dev->vbi_read;\r\nif (len < remain)\r\nlencopy = len;\r\nelse\r\nlencopy = remain;\r\nif (vbi_buf != NULL)\r\nau0828_copy_vbi(dev, vbi_dma_q, vbi_buf, p,\r\nvbioutp, len);\r\nlen -= lencopy;\r\np += lencopy;\r\ndev->vbi_read += lencopy;\r\n}\r\nif (dev->vbi_read >= vbi_field_size && buf != NULL)\r\nau0828_copy_video(dev, dma_q, buf, p, outp, len);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nbuffer_setup(struct videobuf_queue *vq, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct au0828_fh *fh = vq->priv_data;\r\n*size = (fh->dev->width * fh->dev->height * 16 + 7) >> 3;\r\nif (0 == *count)\r\n*count = AU0828_DEF_BUF;\r\nif (*count < AU0828_MIN_BUF)\r\n*count = AU0828_MIN_BUF;\r\nreturn 0;\r\n}\r\nstatic void free_buffer(struct videobuf_queue *vq, struct au0828_buffer *buf)\r\n{\r\nstruct au0828_fh *fh = vq->priv_data;\r\nstruct au0828_dev *dev = fh->dev;\r\nunsigned long flags = 0;\r\nif (in_interrupt())\r\nBUG();\r\nspin_lock_irqsave(&dev->slock, flags);\r\nif (dev->isoc_ctl.buf == buf)\r\ndev->isoc_ctl.buf = NULL;\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nvideobuf_vmalloc_free(&buf->vb);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int\r\nbuffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct au0828_fh *fh = vq->priv_data;\r\nstruct au0828_buffer *buf = container_of(vb, struct au0828_buffer, vb);\r\nstruct au0828_dev *dev = fh->dev;\r\nint rc = 0, urb_init = 0;\r\nbuf->vb.size = (fh->dev->width * fh->dev->height * 16 + 7) >> 3;\r\nif (0 != buf->vb.baddr && buf->vb.bsize < buf->vb.size)\r\nreturn -EINVAL;\r\nbuf->vb.width = dev->width;\r\nbuf->vb.height = dev->height;\r\nbuf->vb.field = field;\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\nrc = videobuf_iolock(vq, &buf->vb, NULL);\r\nif (rc < 0) {\r\nprintk(KERN_INFO "videobuf_iolock failed\n");\r\ngoto fail;\r\n}\r\n}\r\nif (!dev->isoc_ctl.num_bufs)\r\nurb_init = 1;\r\nif (urb_init) {\r\nrc = au0828_init_isoc(dev, AU0828_ISO_PACKETS_PER_URB,\r\nAU0828_MAX_ISO_BUFS, dev->max_pkt_size,\r\nau0828_isoc_copy);\r\nif (rc < 0) {\r\nprintk(KERN_INFO "au0828_init_isoc failed\n");\r\ngoto fail;\r\n}\r\n}\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\nfree_buffer(vq, buf);\r\nreturn rc;\r\n}\r\nstatic void\r\nbuffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nstruct au0828_buffer *buf = container_of(vb,\r\nstruct au0828_buffer,\r\nvb);\r\nstruct au0828_fh *fh = vq->priv_data;\r\nstruct au0828_dev *dev = fh->dev;\r\nstruct au0828_dmaqueue *vidq = &dev->vidq;\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&buf->vb.queue, &vidq->active);\r\n}\r\nstatic void buffer_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct au0828_buffer *buf = container_of(vb,\r\nstruct au0828_buffer,\r\nvb);\r\nfree_buffer(vq, buf);\r\n}\r\nstatic int au0828_i2s_init(struct au0828_dev *dev)\r\n{\r\nau0828_writereg(dev, AU0828_AUDIOCTRL_50C, 0x01);\r\nreturn 0;\r\n}\r\nint au0828_analog_stream_enable(struct au0828_dev *d)\r\n{\r\ndprintk(1, "au0828_analog_stream_enable called\n");\r\nau0828_writereg(d, AU0828_SENSORCTRL_VBI_103, 0x00);\r\nau0828_writereg(d, 0x106, 0x00);\r\nau0828_writereg(d, 0x110, 0x00);\r\nau0828_writereg(d, 0x111, 0x00);\r\nau0828_writereg(d, 0x114, 0xa0);\r\nau0828_writereg(d, 0x115, 0x05);\r\nau0828_writereg(d, 0x112, 0x00);\r\nau0828_writereg(d, 0x113, 0x00);\r\nau0828_writereg(d, 0x116, 0xf2);\r\nau0828_writereg(d, 0x117, 0x00);\r\nau0828_writereg(d, AU0828_SENSORCTRL_100, 0xb3);\r\nreturn 0;\r\n}\r\nint au0828_analog_stream_disable(struct au0828_dev *d)\r\n{\r\ndprintk(1, "au0828_analog_stream_disable called\n");\r\nau0828_writereg(d, AU0828_SENSORCTRL_100, 0x0);\r\nreturn 0;\r\n}\r\nvoid au0828_analog_stream_reset(struct au0828_dev *dev)\r\n{\r\ndprintk(1, "au0828_analog_stream_reset called\n");\r\nau0828_writereg(dev, AU0828_SENSORCTRL_100, 0x0);\r\nmdelay(30);\r\nau0828_writereg(dev, AU0828_SENSORCTRL_100, 0xb3);\r\n}\r\nstatic int au0828_stream_interrupt(struct au0828_dev *dev)\r\n{\r\nint ret = 0;\r\ndev->stream_state = STREAM_INTERRUPT;\r\nif (dev->dev_state == DEV_DISCONNECTED)\r\nreturn -ENODEV;\r\nelse if (ret) {\r\ndev->dev_state = DEV_MISCONFIGURED;\r\ndprintk(1, "%s device is misconfigured!\n", __func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid au0828_analog_unregister(struct au0828_dev *dev)\r\n{\r\ndprintk(1, "au0828_release_resources called\n");\r\nmutex_lock(&au0828_sysfs_lock);\r\nif (dev->vdev)\r\nvideo_unregister_device(dev->vdev);\r\nif (dev->vbi_dev)\r\nvideo_unregister_device(dev->vbi_dev);\r\nmutex_unlock(&au0828_sysfs_lock);\r\n}\r\nstatic int res_get(struct au0828_fh *fh, unsigned int bit)\r\n{\r\nstruct au0828_dev *dev = fh->dev;\r\nif (fh->resources & bit)\r\nreturn 1;\r\nmutex_lock(&dev->lock);\r\nif (dev->resources & bit) {\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nfh->resources |= bit;\r\ndev->resources |= bit;\r\ndprintk(1, "res: get %d\n", bit);\r\nmutex_unlock(&dev->lock);\r\nreturn 1;\r\n}\r\nstatic int res_check(struct au0828_fh *fh, unsigned int bit)\r\n{\r\nreturn fh->resources & bit;\r\n}\r\nstatic int res_locked(struct au0828_dev *dev, unsigned int bit)\r\n{\r\nreturn dev->resources & bit;\r\n}\r\nstatic void res_free(struct au0828_fh *fh, unsigned int bits)\r\n{\r\nstruct au0828_dev *dev = fh->dev;\r\nBUG_ON((fh->resources & bits) != bits);\r\nmutex_lock(&dev->lock);\r\nfh->resources &= ~bits;\r\ndev->resources &= ~bits;\r\ndprintk(1, "res: put %d\n", bits);\r\nmutex_unlock(&dev->lock);\r\n}\r\nstatic int get_ressource(struct au0828_fh *fh)\r\n{\r\nswitch (fh->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nreturn AU0828_RESOURCE_VIDEO;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nreturn AU0828_RESOURCE_VBI;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nvoid au0828_vid_buffer_timeout(unsigned long data)\r\n{\r\nstruct au0828_dev *dev = (struct au0828_dev *) data;\r\nstruct au0828_dmaqueue *dma_q = &dev->vidq;\r\nstruct au0828_buffer *buf;\r\nunsigned char *vid_data;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&dev->slock, flags);\r\nbuf = dev->isoc_ctl.buf;\r\nif (buf != NULL) {\r\nvid_data = videobuf_to_vmalloc(&buf->vb);\r\nmemset(vid_data, 0x00, buf->vb.size);\r\nbuffer_filled(dev, dma_q, buf);\r\n}\r\nget_next_buf(dma_q, &buf);\r\nif (dev->vid_timeout_running == 1)\r\nmod_timer(&dev->vid_timeout, jiffies + (HZ / 10));\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nvoid au0828_vbi_buffer_timeout(unsigned long data)\r\n{\r\nstruct au0828_dev *dev = (struct au0828_dev *) data;\r\nstruct au0828_dmaqueue *dma_q = &dev->vbiq;\r\nstruct au0828_buffer *buf;\r\nunsigned char *vbi_data;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&dev->slock, flags);\r\nbuf = dev->isoc_ctl.vbi_buf;\r\nif (buf != NULL) {\r\nvbi_data = videobuf_to_vmalloc(&buf->vb);\r\nmemset(vbi_data, 0x00, buf->vb.size);\r\nvbi_buffer_filled(dev, dma_q, buf);\r\n}\r\nvbi_get_next_buf(dma_q, &buf);\r\nif (dev->vbi_timeout_running == 1)\r\nmod_timer(&dev->vbi_timeout, jiffies + (HZ / 10));\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nstatic int au0828_v4l2_open(struct file *filp)\r\n{\r\nint ret = 0;\r\nstruct video_device *vdev = video_devdata(filp);\r\nstruct au0828_dev *dev = video_drvdata(filp);\r\nstruct au0828_fh *fh;\r\nint type;\r\nswitch (vdev->vfl_type) {\r\ncase VFL_TYPE_GRABBER:\r\ntype = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\ntype = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfh = kzalloc(sizeof(struct au0828_fh), GFP_KERNEL);\r\nif (NULL == fh) {\r\ndprintk(1, "Failed allocate au0828_fh struct!\n");\r\nreturn -ENOMEM;\r\n}\r\nfh->type = type;\r\nfh->dev = dev;\r\nfilp->private_data = fh;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE && dev->users == 0) {\r\nret = usb_set_interface(dev->usbdev, 0, 5);\r\nif (ret < 0) {\r\nprintk(KERN_INFO "Au0828 can't set alternate to 5!\n");\r\nreturn -EBUSY;\r\n}\r\ndev->width = NTSC_STD_W;\r\ndev->height = NTSC_STD_H;\r\ndev->frame_size = dev->width * dev->height * 2;\r\ndev->field_size = dev->width * dev->height;\r\ndev->bytesperline = dev->width * 2;\r\nau0828_analog_stream_enable(dev);\r\nau0828_analog_stream_reset(dev);\r\nau0828_i2s_init(dev);\r\ndev->stream_state = STREAM_OFF;\r\ndev->dev_state |= DEV_INITIALIZED;\r\n}\r\ndev->users++;\r\nvideobuf_queue_vmalloc_init(&fh->vb_vidq, &au0828_video_qops,\r\nNULL, &dev->slock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_INTERLACED,\r\nsizeof(struct au0828_buffer), fh, NULL);\r\ndev->vbi_width = 720;\r\ndev->vbi_height = 1;\r\nvideobuf_queue_vmalloc_init(&fh->vb_vbiq, &au0828_vbi_qops,\r\nNULL, &dev->slock,\r\nV4L2_BUF_TYPE_VBI_CAPTURE,\r\nV4L2_FIELD_SEQ_TB,\r\nsizeof(struct au0828_buffer), fh, NULL);\r\nreturn ret;\r\n}\r\nstatic int au0828_v4l2_close(struct file *filp)\r\n{\r\nint ret;\r\nstruct au0828_fh *fh = filp->private_data;\r\nstruct au0828_dev *dev = fh->dev;\r\nif (res_check(fh, AU0828_RESOURCE_VIDEO)) {\r\ndev->vid_timeout_running = 0;\r\ndel_timer_sync(&dev->vid_timeout);\r\nvideobuf_stop(&fh->vb_vidq);\r\nres_free(fh, AU0828_RESOURCE_VIDEO);\r\n}\r\nif (res_check(fh, AU0828_RESOURCE_VBI)) {\r\ndev->vbi_timeout_running = 0;\r\ndel_timer_sync(&dev->vbi_timeout);\r\nvideobuf_stop(&fh->vb_vbiq);\r\nres_free(fh, AU0828_RESOURCE_VBI);\r\n}\r\nif (dev->users == 1) {\r\nif (dev->dev_state & DEV_DISCONNECTED) {\r\nau0828_analog_unregister(dev);\r\nkfree(dev);\r\nreturn 0;\r\n}\r\nau0828_analog_stream_disable(dev);\r\nau0828_uninit_isoc(dev);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, s_power, 0);\r\nret = usb_set_interface(dev->usbdev, 0, 0);\r\nif (ret < 0)\r\nprintk(KERN_INFO "Au0828 can't set alternate to 0!\n");\r\n}\r\nvideobuf_mmap_free(&fh->vb_vidq);\r\nvideobuf_mmap_free(&fh->vb_vbiq);\r\nkfree(fh);\r\ndev->users--;\r\nwake_up_interruptible_nr(&dev->open, 1);\r\nreturn 0;\r\n}\r\nstatic ssize_t au0828_v4l2_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct au0828_fh *fh = filp->private_data;\r\nstruct au0828_dev *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nif (res_locked(dev, AU0828_RESOURCE_VIDEO))\r\nreturn -EBUSY;\r\nreturn videobuf_read_stream(&fh->vb_vidq, buf, count, pos, 0,\r\nfilp->f_flags & O_NONBLOCK);\r\n}\r\nif (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\r\nif (!res_get(fh, AU0828_RESOURCE_VBI))\r\nreturn -EBUSY;\r\nif (dev->vbi_timeout_running == 0) {\r\ndev->vbi_timeout_running = 1;\r\nmod_timer(&dev->vbi_timeout, jiffies + (HZ / 10));\r\n}\r\nreturn videobuf_read_stream(&fh->vb_vbiq, buf, count, pos, 0,\r\nfilp->f_flags & O_NONBLOCK);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int au0828_v4l2_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct au0828_fh *fh = filp->private_data;\r\nstruct au0828_dev *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nif (!res_get(fh, AU0828_RESOURCE_VIDEO))\r\nreturn POLLERR;\r\nreturn videobuf_poll_stream(filp, &fh->vb_vidq, wait);\r\n} else if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\r\nif (!res_get(fh, AU0828_RESOURCE_VBI))\r\nreturn POLLERR;\r\nreturn videobuf_poll_stream(filp, &fh->vb_vbiq, wait);\r\n} else {\r\nreturn POLLERR;\r\n}\r\n}\r\nstatic int au0828_v4l2_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct au0828_fh *fh = filp->private_data;\r\nstruct au0828_dev *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nrc = videobuf_mmap_mapper(&fh->vb_vidq, vma);\r\nelse if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE)\r\nrc = videobuf_mmap_mapper(&fh->vb_vbiq, vma);\r\nreturn rc;\r\n}\r\nstatic int au0828_set_format(struct au0828_dev *dev, unsigned int cmd,\r\nstruct v4l2_format *format)\r\n{\r\nint ret;\r\nint width = format->fmt.pix.width;\r\nint height = format->fmt.pix.height;\r\nif (format->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (format->fmt.pix.pixelformat != V4L2_PIX_FMT_UYVY)\r\nreturn -EINVAL;\r\nif (width != 720)\r\nwidth = 720;\r\nif (height != 480)\r\nheight = 480;\r\nformat->fmt.pix.width = width;\r\nformat->fmt.pix.height = height;\r\nformat->fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;\r\nformat->fmt.pix.bytesperline = width * 2;\r\nformat->fmt.pix.sizeimage = width * height * 2;\r\nformat->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nformat->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nif (cmd == VIDIOC_TRY_FMT)\r\nreturn 0;\r\ndev->width = width;\r\ndev->height = height;\r\ndev->frame_size = width * height * 2;\r\ndev->field_size = width * height;\r\ndev->bytesperline = width * 2;\r\nif (dev->stream_state == STREAM_ON) {\r\ndprintk(1, "VIDIOC_SET_FMT: interrupting stream!\n");\r\nret = au0828_stream_interrupt(dev);\r\nif (ret != 0) {\r\ndprintk(1, "error interrupting video stream!\n");\r\nreturn ret;\r\n}\r\n}\r\nret = usb_set_interface(dev->usbdev, 0, 5);\r\nif (ret < 0) {\r\nprintk(KERN_INFO "Au0828 can't set alt setting to 5!\n");\r\nreturn -EBUSY;\r\n}\r\nau0828_analog_stream_enable(dev);\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, queryctrl, qc);\r\nif (qc->type)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nstrlcpy(cap->driver, "au0828", sizeof(cap->driver));\r\nstrlcpy(cap->card, dev->board.name, sizeof(cap->card));\r\nstrlcpy(cap->bus_info, dev->v4l2_dev.name, sizeof(cap->bus_info));\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_VBI_CAPTURE |\r\nV4L2_CAP_AUDIO |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING |\r\nV4L2_CAP_TUNER;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index)\r\nreturn -EINVAL;\r\nf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nstrcpy(f->description, "Packed YUV2");\r\nf->flags = 0;\r\nf->pixelformat = V4L2_PIX_FMT_UYVY;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nf->fmt.pix.width = dev->width;\r\nf->fmt.pix.height = dev->height;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;\r\nf->fmt.pix.bytesperline = dev->bytesperline;\r\nf->fmt.pix.sizeimage = dev->frame_size;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nreturn au0828_set_format(dev, VIDIOC_TRY_FMT, f);\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nmutex_lock(&dev->lock);\r\nif (videobuf_queue_is_busy(&fh->vb_vidq)) {\r\nprintk(KERN_INFO "%s queue busy\n", __func__);\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nrc = au0828_set_format(dev, VIDIOC_S_FMT, f);\r\nout:\r\nmutex_unlock(&dev->lock);\r\nreturn rc;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id * norm)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, s_std, *norm);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *input)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nunsigned int tmp;\r\nstatic const char *inames[] = {\r\n[AU0828_VMUX_UNDEFINED] = "Undefined",\r\n[AU0828_VMUX_COMPOSITE] = "Composite",\r\n[AU0828_VMUX_SVIDEO] = "S-Video",\r\n[AU0828_VMUX_CABLE] = "Cable TV",\r\n[AU0828_VMUX_TELEVISION] = "Television",\r\n[AU0828_VMUX_DVB] = "DVB",\r\n[AU0828_VMUX_DEBUG] = "tv debug"\r\n};\r\ntmp = input->index;\r\nif (tmp >= AU0828_MAX_INPUT)\r\nreturn -EINVAL;\r\nif (AUVI_INPUT(tmp).type == 0)\r\nreturn -EINVAL;\r\ninput->index = tmp;\r\nstrcpy(input->name, inames[AUVI_INPUT(tmp).type]);\r\nif ((AUVI_INPUT(tmp).type == AU0828_VMUX_TELEVISION) ||\r\n(AUVI_INPUT(tmp).type == AU0828_VMUX_CABLE))\r\ninput->type |= V4L2_INPUT_TYPE_TUNER;\r\nelse\r\ninput->type |= V4L2_INPUT_TYPE_CAMERA;\r\ninput->std = dev->vdev->tvnorms;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\n*i = dev->ctrl_input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int index)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nint i;\r\ndprintk(1, "VIDIOC_S_INPUT in function %s, input=%d\n", __func__,\r\nindex);\r\nif (index >= AU0828_MAX_INPUT)\r\nreturn -EINVAL;\r\nif (AUVI_INPUT(index).type == 0)\r\nreturn -EINVAL;\r\ndev->ctrl_input = index;\r\nswitch (AUVI_INPUT(index).type) {\r\ncase AU0828_VMUX_SVIDEO:\r\ndev->input_type = AU0828_VMUX_SVIDEO;\r\nbreak;\r\ncase AU0828_VMUX_COMPOSITE:\r\ndev->input_type = AU0828_VMUX_COMPOSITE;\r\nbreak;\r\ncase AU0828_VMUX_TELEVISION:\r\ndev->input_type = AU0828_VMUX_TELEVISION;\r\nbreak;\r\ndefault:\r\ndprintk(1, "VIDIOC_S_INPUT unknown input type set [%d]\n",\r\nAUVI_INPUT(index).type);\r\nbreak;\r\n}\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_routing,\r\nAUVI_INPUT(index).vmux, 0, 0);\r\nfor (i = 0; i < AU0828_MAX_INPUT; i++) {\r\nint enable = 0;\r\nif (AUVI_INPUT(i).audio_setup == NULL)\r\ncontinue;\r\nif (i == index)\r\nenable = 1;\r\nelse\r\nenable = 0;\r\nif (enable) {\r\n(AUVI_INPUT(i).audio_setup)(dev, enable);\r\n} else {\r\nif ((AUVI_INPUT(i).audio_setup) !=\r\n((AUVI_INPUT(index).audio_setup))) {\r\n(AUVI_INPUT(i).audio_setup)(dev, enable);\r\n}\r\n}\r\n}\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, audio, s_routing,\r\nAUVI_INPUT(index).amux, 0, 0);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *priv, struct v4l2_audio *a)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nunsigned int index = a->index;\r\nif (a->index > 1)\r\nreturn -EINVAL;\r\nindex = dev->ctrl_ainput;\r\nif (index == 0)\r\nstrcpy(a->name, "Television");\r\nelse\r\nstrcpy(a->name, "Line in");\r\na->capability = V4L2_AUDCAP_STEREO;\r\na->index = index;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *priv, struct v4l2_audio *a)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nif (a->index != dev->ctrl_ainput)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, g_ctrl, ctrl);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, s_ctrl, ctrl);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv, struct v4l2_tuner *t)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nif (t->index != 0)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Auvitek tuner");\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, g_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nif (t->index != 0)\r\nreturn -EINVAL;\r\nt->type = V4L2_TUNER_ANALOG_TV;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_tuner, t);\r\ndprintk(1, "VIDIOC_S_TUNER: signal = %x, afc = %x\n", t->signal,\r\nt->afc);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *freq)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nfreq->type = V4L2_TUNER_ANALOG_TV;\r\nfreq->frequency = dev->ctrl_freq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *freq)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nif (freq->tuner != 0)\r\nreturn -EINVAL;\r\nif (freq->type != V4L2_TUNER_ANALOG_TV)\r\nreturn -EINVAL;\r\ndev->ctrl_freq = freq->frequency;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_frequency, freq);\r\nau0828_analog_stream_reset(dev);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *format)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nformat->fmt.vbi.samples_per_line = dev->vbi_width;\r\nformat->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\r\nformat->fmt.vbi.offset = 0;\r\nformat->fmt.vbi.flags = 0;\r\nformat->fmt.vbi.sampling_rate = 6750000 * 4 / 2;\r\nformat->fmt.vbi.count[0] = dev->vbi_height;\r\nformat->fmt.vbi.count[1] = dev->vbi_height;\r\nformat->fmt.vbi.start[0] = 21;\r\nformat->fmt.vbi.start[1] = 284;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_chip_ident(struct file *file, void *priv,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nchip->ident = V4L2_IDENT_NONE;\r\nchip->revision = 0;\r\nif (v4l2_chip_match_host(&chip->match)) {\r\nchip->ident = V4L2_IDENT_AU0828;\r\nreturn 0;\r\n}\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, g_chip_ident, chip);\r\nif (chip->ident == V4L2_IDENT_NONE)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int vidioc_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *cc)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nif (cc->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\ncc->bounds.left = 0;\r\ncc->bounds.top = 0;\r\ncc->bounds.width = dev->width;\r\ncc->bounds.height = dev->height;\r\ncc->defrect = cc->bounds;\r\ncc->pixelaspect.numerator = 54;\r\ncc->pixelaspect.denominator = 59;\r\nreturn 0;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nint rc = -EINVAL;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (unlikely(type != fh->type))\r\nreturn -EINVAL;\r\ndprintk(1, "vidioc_streamon fh=%p t=%d fh->res=%d dev->res=%d\n",\r\nfh, type, fh->resources, dev->resources);\r\nif (unlikely(!res_get(fh, get_ressource(fh))))\r\nreturn -EBUSY;\r\nif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nau0828_analog_stream_enable(dev);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_stream, 1);\r\n}\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nrc = videobuf_streamon(&fh->vb_vidq);\r\ndev->vid_timeout_running = 1;\r\nmod_timer(&dev->vid_timeout, jiffies + (HZ / 10));\r\n} else if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\r\nrc = videobuf_streamon(&fh->vb_vbiq);\r\ndev->vbi_timeout_running = 1;\r\nmod_timer(&dev->vbi_timeout, jiffies + (HZ / 10));\r\n}\r\nreturn rc;\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nint rc;\r\nint i;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\nfh->type != V4L2_BUF_TYPE_VBI_CAPTURE)\r\nreturn -EINVAL;\r\nif (type != fh->type)\r\nreturn -EINVAL;\r\ndprintk(1, "vidioc_streamoff fh=%p t=%d fh->res=%d dev->res=%d\n",\r\nfh, type, fh->resources, dev->resources);\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\ndev->vid_timeout_running = 0;\r\ndel_timer_sync(&dev->vid_timeout);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_stream, 0);\r\nrc = au0828_stream_interrupt(dev);\r\nif (rc != 0)\r\nreturn rc;\r\nfor (i = 0; i < AU0828_MAX_INPUT; i++) {\r\nif (AUVI_INPUT(i).audio_setup == NULL)\r\ncontinue;\r\n(AUVI_INPUT(i).audio_setup)(dev, 0);\r\n}\r\nvideobuf_streamoff(&fh->vb_vidq);\r\nres_free(fh, AU0828_RESOURCE_VIDEO);\r\n} else if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\r\ndev->vbi_timeout_running = 0;\r\ndel_timer_sync(&dev->vbi_timeout);\r\nvideobuf_streamoff(&fh->vb_vbiq);\r\nres_free(fh, AU0828_RESOURCE_VBI);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nswitch (reg->match.type) {\r\ncase V4L2_CHIP_MATCH_I2C_DRIVER:\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, g_register, reg);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int vidioc_s_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nswitch (reg->match.type) {\r\ncase V4L2_CHIP_MATCH_I2C_DRIVER:\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, s_register, reg);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nrc = videobuf_reqbufs(&fh->vb_vidq, rb);\r\nelse if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE)\r\nrc = videobuf_reqbufs(&fh->vb_vbiq, rb);\r\nreturn rc;\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *b)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nrc = videobuf_querybuf(&fh->vb_vidq, b);\r\nelse if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE)\r\nrc = videobuf_querybuf(&fh->vb_vbiq, b);\r\nreturn rc;\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nrc = videobuf_qbuf(&fh->vb_vidq, b);\r\nelse if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE)\r\nrc = videobuf_qbuf(&fh->vb_vbiq, b);\r\nreturn rc;\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct au0828_fh *fh = priv;\r\nstruct au0828_dev *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (dev->greenscreen_detected == 1) {\r\ndprintk(1, "Detected green frame. Resetting stream...\n");\r\nau0828_analog_stream_reset(dev);\r\ndev->greenscreen_detected = 0;\r\n}\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nrc = videobuf_dqbuf(&fh->vb_vidq, b, file->f_flags & O_NONBLOCK);\r\nelse if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE)\r\nrc = videobuf_dqbuf(&fh->vb_vbiq, b, file->f_flags & O_NONBLOCK);\r\nreturn rc;\r\n}\r\nint au0828_analog_register(struct au0828_dev *dev,\r\nstruct usb_interface *interface)\r\n{\r\nint retval = -ENOMEM;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint i;\r\ndprintk(1, "au0828_analog_register called!\n");\r\nretval = usb_set_interface(dev->usbdev,\r\ninterface->cur_altsetting->desc.bInterfaceNumber, 5);\r\nif (retval != 0) {\r\nprintk(KERN_INFO "Failure setting usb interface0 to as5\n");\r\nreturn retval;\r\n}\r\niface_desc = interface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK)\r\n== USB_DIR_IN) &&\r\n((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)\r\n== USB_ENDPOINT_XFER_ISOC)) {\r\nu16 tmp = le16_to_cpu(endpoint->wMaxPacketSize);\r\ndev->max_pkt_size = (tmp & 0x07ff) *\r\n(((tmp & 0x1800) >> 11) + 1);\r\ndev->isoc_in_endpointaddr = endpoint->bEndpointAddress;\r\n}\r\n}\r\nif (!(dev->isoc_in_endpointaddr)) {\r\nprintk(KERN_INFO "Could not locate isoc endpoint\n");\r\nkfree(dev);\r\nreturn -ENODEV;\r\n}\r\ninit_waitqueue_head(&dev->open);\r\nspin_lock_init(&dev->slock);\r\nmutex_init(&dev->lock);\r\nINIT_LIST_HEAD(&dev->vidq.active);\r\nINIT_LIST_HEAD(&dev->vidq.queued);\r\nINIT_LIST_HEAD(&dev->vbiq.active);\r\nINIT_LIST_HEAD(&dev->vbiq.queued);\r\ndev->vid_timeout.function = au0828_vid_buffer_timeout;\r\ndev->vid_timeout.data = (unsigned long) dev;\r\ninit_timer(&dev->vid_timeout);\r\ndev->vbi_timeout.function = au0828_vbi_buffer_timeout;\r\ndev->vbi_timeout.data = (unsigned long) dev;\r\ninit_timer(&dev->vbi_timeout);\r\ndev->width = NTSC_STD_W;\r\ndev->height = NTSC_STD_H;\r\ndev->field_size = dev->width * dev->height;\r\ndev->frame_size = dev->field_size << 1;\r\ndev->bytesperline = dev->width << 1;\r\ndev->ctrl_ainput = 0;\r\ndev->vdev = video_device_alloc();\r\nif (NULL == dev->vdev) {\r\ndprintk(1, "Can't allocate video_device.\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->vbi_dev = video_device_alloc();\r\nif (NULL == dev->vbi_dev) {\r\ndprintk(1, "Can't allocate vbi_device.\n");\r\nkfree(dev->vdev);\r\nreturn -ENOMEM;\r\n}\r\n*dev->vdev = au0828_video_template;\r\ndev->vdev->parent = &dev->usbdev->dev;\r\nstrcpy(dev->vdev->name, "au0828a video");\r\n*dev->vbi_dev = au0828_video_template;\r\ndev->vbi_dev->parent = &dev->usbdev->dev;\r\nstrcpy(dev->vbi_dev->name, "au0828a vbi");\r\nvideo_set_drvdata(dev->vdev, dev);\r\nretval = video_register_device(dev->vdev, VFL_TYPE_GRABBER, -1);\r\nif (retval != 0) {\r\ndprintk(1, "unable to register video device (error = %d).\n",\r\nretval);\r\nvideo_device_release(dev->vdev);\r\nreturn -ENODEV;\r\n}\r\nvideo_set_drvdata(dev->vbi_dev, dev);\r\nretval = video_register_device(dev->vbi_dev, VFL_TYPE_VBI, -1);\r\nif (retval != 0) {\r\ndprintk(1, "unable to register vbi device (error = %d).\n",\r\nretval);\r\nvideo_device_release(dev->vbi_dev);\r\nvideo_device_release(dev->vdev);\r\nreturn -ENODEV;\r\n}\r\ndprintk(1, "%s completed!\n", __func__);\r\nreturn 0;\r\n}
