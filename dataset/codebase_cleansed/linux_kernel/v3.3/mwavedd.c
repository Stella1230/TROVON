static int mwave_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned int retval = 0;\r\nPRINTK_3(TRACE_MWAVE,\r\n"mwavedd::mwave_open, entry inode %p file %p\n",\r\ninode, file);\r\nPRINTK_2(TRACE_MWAVE,\r\n"mwavedd::mwave_open, exit return retval %x\n", retval);\r\nreturn retval;\r\n}\r\nstatic int mwave_close(struct inode *inode, struct file *file)\r\n{\r\nunsigned int retval = 0;\r\nPRINTK_3(TRACE_MWAVE,\r\n"mwavedd::mwave_close, entry inode %p file %p\n",\r\ninode, file);\r\nPRINTK_2(TRACE_MWAVE, "mwavedd::mwave_close, exit retval %x\n",\r\nretval);\r\nreturn retval;\r\n}\r\nstatic long mwave_ioctl(struct file *file, unsigned int iocmd,\r\nunsigned long ioarg)\r\n{\r\nunsigned int retval = 0;\r\npMWAVE_DEVICE_DATA pDrvData = &mwave_s_mdd;\r\nvoid __user *arg = (void __user *)ioarg;\r\nPRINTK_4(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl, entry file %p cmd %x arg %x\n",\r\nfile, iocmd, (int) ioarg);\r\nswitch (iocmd) {\r\ncase IOCTL_MW_RESET:\r\nPRINTK_1(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl, IOCTL_MW_RESET"\r\n" calling tp3780I_ResetDSP\n");\r\nmutex_lock(&mwave_mutex);\r\nretval = tp3780I_ResetDSP(&pDrvData->rBDData);\r\nmutex_unlock(&mwave_mutex);\r\nPRINTK_2(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl, IOCTL_MW_RESET"\r\n" retval %x from tp3780I_ResetDSP\n",\r\nretval);\r\nbreak;\r\ncase IOCTL_MW_RUN:\r\nPRINTK_1(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl, IOCTL_MW_RUN"\r\n" calling tp3780I_StartDSP\n");\r\nmutex_lock(&mwave_mutex);\r\nretval = tp3780I_StartDSP(&pDrvData->rBDData);\r\nmutex_unlock(&mwave_mutex);\r\nPRINTK_2(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl, IOCTL_MW_RUN"\r\n" retval %x from tp3780I_StartDSP\n",\r\nretval);\r\nbreak;\r\ncase IOCTL_MW_DSP_ABILITIES: {\r\nMW_ABILITIES rAbilities;\r\nPRINTK_1(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl,"\r\n" IOCTL_MW_DSP_ABILITIES calling"\r\n" tp3780I_QueryAbilities\n");\r\nmutex_lock(&mwave_mutex);\r\nretval = tp3780I_QueryAbilities(&pDrvData->rBDData,\r\n&rAbilities);\r\nmutex_unlock(&mwave_mutex);\r\nPRINTK_2(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl, IOCTL_MW_DSP_ABILITIES"\r\n" retval %x from tp3780I_QueryAbilities\n",\r\nretval);\r\nif (retval == 0) {\r\nif( copy_to_user(arg, &rAbilities,\r\nsizeof(MW_ABILITIES)) )\r\nreturn -EFAULT;\r\n}\r\nPRINTK_2(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl, IOCTL_MW_DSP_ABILITIES"\r\n" exit retval %x\n",\r\nretval);\r\n}\r\nbreak;\r\ncase IOCTL_MW_READ_DATA:\r\ncase IOCTL_MW_READCLEAR_DATA: {\r\nMW_READWRITE rReadData;\r\nunsigned short __user *pusBuffer = NULL;\r\nif( copy_from_user(&rReadData, arg,\r\nsizeof(MW_READWRITE)) )\r\nreturn -EFAULT;\r\npusBuffer = (unsigned short __user *) (rReadData.pBuf);\r\nPRINTK_4(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl IOCTL_MW_READ_DATA,"\r\n" size %lx, ioarg %lx pusBuffer %p\n",\r\nrReadData.ulDataLength, ioarg, pusBuffer);\r\nmutex_lock(&mwave_mutex);\r\nretval = tp3780I_ReadWriteDspDStore(&pDrvData->rBDData,\r\niocmd,\r\npusBuffer,\r\nrReadData.ulDataLength,\r\nrReadData.usDspAddress);\r\nmutex_unlock(&mwave_mutex);\r\n}\r\nbreak;\r\ncase IOCTL_MW_READ_INST: {\r\nMW_READWRITE rReadData;\r\nunsigned short __user *pusBuffer = NULL;\r\nif( copy_from_user(&rReadData, arg,\r\nsizeof(MW_READWRITE)) )\r\nreturn -EFAULT;\r\npusBuffer = (unsigned short __user *) (rReadData.pBuf);\r\nPRINTK_4(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl IOCTL_MW_READ_INST,"\r\n" size %lx, ioarg %lx pusBuffer %p\n",\r\nrReadData.ulDataLength / 2, ioarg,\r\npusBuffer);\r\nmutex_lock(&mwave_mutex);\r\nretval = tp3780I_ReadWriteDspDStore(&pDrvData->rBDData,\r\niocmd, pusBuffer,\r\nrReadData.ulDataLength / 2,\r\nrReadData.usDspAddress);\r\nmutex_unlock(&mwave_mutex);\r\n}\r\nbreak;\r\ncase IOCTL_MW_WRITE_DATA: {\r\nMW_READWRITE rWriteData;\r\nunsigned short __user *pusBuffer = NULL;\r\nif( copy_from_user(&rWriteData, arg,\r\nsizeof(MW_READWRITE)) )\r\nreturn -EFAULT;\r\npusBuffer = (unsigned short __user *) (rWriteData.pBuf);\r\nPRINTK_4(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl IOCTL_MW_WRITE_DATA,"\r\n" size %lx, ioarg %lx pusBuffer %p\n",\r\nrWriteData.ulDataLength, ioarg,\r\npusBuffer);\r\nmutex_lock(&mwave_mutex);\r\nretval = tp3780I_ReadWriteDspDStore(&pDrvData->rBDData,\r\niocmd, pusBuffer,\r\nrWriteData.ulDataLength,\r\nrWriteData.usDspAddress);\r\nmutex_unlock(&mwave_mutex);\r\n}\r\nbreak;\r\ncase IOCTL_MW_WRITE_INST: {\r\nMW_READWRITE rWriteData;\r\nunsigned short __user *pusBuffer = NULL;\r\nif( copy_from_user(&rWriteData, arg,\r\nsizeof(MW_READWRITE)) )\r\nreturn -EFAULT;\r\npusBuffer = (unsigned short __user *)(rWriteData.pBuf);\r\nPRINTK_4(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl IOCTL_MW_WRITE_INST,"\r\n" size %lx, ioarg %lx pusBuffer %p\n",\r\nrWriteData.ulDataLength, ioarg,\r\npusBuffer);\r\nmutex_lock(&mwave_mutex);\r\nretval = tp3780I_ReadWriteDspIStore(&pDrvData->rBDData,\r\niocmd, pusBuffer,\r\nrWriteData.ulDataLength,\r\nrWriteData.usDspAddress);\r\nmutex_unlock(&mwave_mutex);\r\n}\r\nbreak;\r\ncase IOCTL_MW_REGISTER_IPC: {\r\nunsigned int ipcnum = (unsigned int) ioarg;\r\nif (ipcnum >= ARRAY_SIZE(pDrvData->IPCs)) {\r\nPRINTK_ERROR(KERN_ERR_MWAVE\r\n"mwavedd::mwave_ioctl:"\r\n" IOCTL_MW_REGISTER_IPC:"\r\n" Error: Invalid ipcnum %x\n",\r\nipcnum);\r\nreturn -EINVAL;\r\n}\r\nPRINTK_3(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl IOCTL_MW_REGISTER_IPC"\r\n" ipcnum %x entry usIntCount %x\n",\r\nipcnum,\r\npDrvData->IPCs[ipcnum].usIntCount);\r\nmutex_lock(&mwave_mutex);\r\npDrvData->IPCs[ipcnum].bIsHere = FALSE;\r\npDrvData->IPCs[ipcnum].bIsEnabled = TRUE;\r\nmutex_unlock(&mwave_mutex);\r\nPRINTK_2(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl IOCTL_MW_REGISTER_IPC"\r\n" ipcnum %x exit\n",\r\nipcnum);\r\n}\r\nbreak;\r\ncase IOCTL_MW_GET_IPC: {\r\nunsigned int ipcnum = (unsigned int) ioarg;\r\nif (ipcnum >= ARRAY_SIZE(pDrvData->IPCs)) {\r\nPRINTK_ERROR(KERN_ERR_MWAVE\r\n"mwavedd::mwave_ioctl:"\r\n" IOCTL_MW_GET_IPC: Error:"\r\n" Invalid ipcnum %x\n", ipcnum);\r\nreturn -EINVAL;\r\n}\r\nPRINTK_3(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl IOCTL_MW_GET_IPC"\r\n" ipcnum %x, usIntCount %x\n",\r\nipcnum,\r\npDrvData->IPCs[ipcnum].usIntCount);\r\nmutex_lock(&mwave_mutex);\r\nif (pDrvData->IPCs[ipcnum].bIsEnabled == TRUE) {\r\nDECLARE_WAITQUEUE(wait, current);\r\nPRINTK_2(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl, thread for"\r\n" ipc %x going to sleep\n",\r\nipcnum);\r\nadd_wait_queue(&pDrvData->IPCs[ipcnum].ipc_wait_queue, &wait);\r\npDrvData->IPCs[ipcnum].bIsHere = TRUE;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (pDrvData->IPCs[ipcnum].usIntCount == 1) {\r\npDrvData->IPCs[ipcnum].usIntCount = 2;\r\nPRINTK_2(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl"\r\n" IOCTL_MW_GET_IPC ipcnum %x"\r\n" handling first int\n",\r\nipcnum);\r\n} else {\r\nschedule();\r\nif (pDrvData->IPCs[ipcnum].usIntCount == 1) {\r\npDrvData->IPCs[ipcnum].usIntCount = 2;\r\n}\r\nPRINTK_2(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl"\r\n" IOCTL_MW_GET_IPC ipcnum %x"\r\n" woke up and returning to"\r\n" application\n",\r\nipcnum);\r\n}\r\npDrvData->IPCs[ipcnum].bIsHere = FALSE;\r\nremove_wait_queue(&pDrvData->IPCs[ipcnum].ipc_wait_queue, &wait);\r\nset_current_state(TASK_RUNNING);\r\nPRINTK_2(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl IOCTL_MW_GET_IPC,"\r\n" returning thread for ipc %x"\r\n" processing\n",\r\nipcnum);\r\n}\r\nmutex_unlock(&mwave_mutex);\r\n}\r\nbreak;\r\ncase IOCTL_MW_UNREGISTER_IPC: {\r\nunsigned int ipcnum = (unsigned int) ioarg;\r\nPRINTK_2(TRACE_MWAVE,\r\n"mwavedd::mwave_ioctl IOCTL_MW_UNREGISTER_IPC"\r\n" ipcnum %x\n",\r\nipcnum);\r\nif (ipcnum >= ARRAY_SIZE(pDrvData->IPCs)) {\r\nPRINTK_ERROR(KERN_ERR_MWAVE\r\n"mwavedd::mwave_ioctl:"\r\n" IOCTL_MW_UNREGISTER_IPC:"\r\n" Error: Invalid ipcnum %x\n",\r\nipcnum);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&mwave_mutex);\r\nif (pDrvData->IPCs[ipcnum].bIsEnabled == TRUE) {\r\npDrvData->IPCs[ipcnum].bIsEnabled = FALSE;\r\nif (pDrvData->IPCs[ipcnum].bIsHere == TRUE) {\r\nwake_up_interruptible(&pDrvData->IPCs[ipcnum].ipc_wait_queue);\r\n}\r\n}\r\nmutex_unlock(&mwave_mutex);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENOTTY;\r\nbreak;\r\n}\r\nPRINTK_2(TRACE_MWAVE, "mwavedd::mwave_ioctl, exit retval %x\n", retval);\r\nreturn retval;\r\n}\r\nstatic ssize_t mwave_read(struct file *file, char __user *buf, size_t count,\r\nloff_t * ppos)\r\n{\r\nPRINTK_5(TRACE_MWAVE,\r\n"mwavedd::mwave_read entry file %p, buf %p, count %zx ppos %p\n",\r\nfile, buf, count, ppos);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t mwave_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t * ppos)\r\n{\r\nPRINTK_5(TRACE_MWAVE,\r\n"mwavedd::mwave_write entry file %p, buf %p,"\r\n" count %zx ppos %p\n",\r\nfile, buf, count, ppos);\r\nreturn -EINVAL;\r\n}\r\nstatic int register_serial_portandirq(unsigned int port, int irq)\r\n{\r\nstruct uart_port uart;\r\nswitch ( port ) {\r\ncase 0x3f8:\r\ncase 0x2f8:\r\ncase 0x3e8:\r\ncase 0x2e8:\r\nbreak;\r\ndefault:\r\nPRINTK_ERROR(KERN_ERR_MWAVE\r\n"mwavedd::register_serial_portandirq:"\r\n" Error: Illegal port %x\n", port );\r\nreturn -1;\r\n}\r\nswitch ( irq ) {\r\ncase 3:\r\ncase 4:\r\ncase 5:\r\ncase 7:\r\nbreak;\r\ndefault:\r\nPRINTK_ERROR(KERN_ERR_MWAVE\r\n"mwavedd::register_serial_portandirq:"\r\n" Error: Illegal irq %x\n", irq );\r\nreturn -1;\r\n}\r\nmemset(&uart, 0, sizeof(struct uart_port));\r\nuart.uartclk = 1843200;\r\nuart.iobase = port;\r\nuart.irq = irq;\r\nuart.iotype = UPIO_PORT;\r\nuart.flags = UPF_SHARE_IRQ;\r\nreturn serial8250_register_port(&uart);\r\n}\r\nstatic void mwave_exit(void)\r\n{\r\npMWAVE_DEVICE_DATA pDrvData = &mwave_s_mdd;\r\nPRINTK_1(TRACE_MWAVE, "mwavedd::mwave_exit entry\n");\r\n#if 0\r\nfor (i = 0; i < pDrvData->nr_registered_attrs; i++)\r\ndevice_remove_file(&mwave_device, mwave_dev_attrs[i]);\r\npDrvData->nr_registered_attrs = 0;\r\nif (pDrvData->device_registered) {\r\ndevice_unregister(&mwave_device);\r\npDrvData->device_registered = FALSE;\r\n}\r\n#endif\r\nif ( pDrvData->sLine >= 0 ) {\r\nserial8250_unregister_port(pDrvData->sLine);\r\n}\r\nif (pDrvData->bMwaveDevRegistered) {\r\nmisc_deregister(&mwave_misc_dev);\r\n}\r\nif (pDrvData->bDSPEnabled) {\r\ntp3780I_DisableDSP(&pDrvData->rBDData);\r\n}\r\nif (pDrvData->bResourcesClaimed) {\r\ntp3780I_ReleaseResources(&pDrvData->rBDData);\r\n}\r\nif (pDrvData->bBDInitialized) {\r\ntp3780I_Cleanup(&pDrvData->rBDData);\r\n}\r\nPRINTK_1(TRACE_MWAVE, "mwavedd::mwave_exit exit\n");\r\n}\r\nstatic int __init mwave_init(void)\r\n{\r\nint i;\r\nint retval = 0;\r\npMWAVE_DEVICE_DATA pDrvData = &mwave_s_mdd;\r\nPRINTK_1(TRACE_MWAVE, "mwavedd::mwave_init entry\n");\r\nmemset(&mwave_s_mdd, 0, sizeof(MWAVE_DEVICE_DATA));\r\npDrvData->bBDInitialized = FALSE;\r\npDrvData->bResourcesClaimed = FALSE;\r\npDrvData->bDSPEnabled = FALSE;\r\npDrvData->bDSPReset = FALSE;\r\npDrvData->bMwaveDevRegistered = FALSE;\r\npDrvData->sLine = -1;\r\nfor (i = 0; i < ARRAY_SIZE(pDrvData->IPCs); i++) {\r\npDrvData->IPCs[i].bIsEnabled = FALSE;\r\npDrvData->IPCs[i].bIsHere = FALSE;\r\npDrvData->IPCs[i].usIntCount = 0;\r\ninit_waitqueue_head(&pDrvData->IPCs[i].ipc_wait_queue);\r\n}\r\nretval = tp3780I_InitializeBoardData(&pDrvData->rBDData);\r\nPRINTK_2(TRACE_MWAVE,\r\n"mwavedd::mwave_init, return from tp3780I_InitializeBoardData"\r\n" retval %x\n",\r\nretval);\r\nif (retval) {\r\nPRINTK_ERROR(KERN_ERR_MWAVE\r\n"mwavedd::mwave_init: Error:"\r\n" Failed to initialize board data\n");\r\ngoto cleanup_error;\r\n}\r\npDrvData->bBDInitialized = TRUE;\r\nretval = tp3780I_CalcResources(&pDrvData->rBDData);\r\nPRINTK_2(TRACE_MWAVE,\r\n"mwavedd::mwave_init, return from tp3780I_CalcResources"\r\n" retval %x\n",\r\nretval);\r\nif (retval) {\r\nPRINTK_ERROR(KERN_ERR_MWAVE\r\n"mwavedd:mwave_init: Error:"\r\n" Failed to calculate resources\n");\r\ngoto cleanup_error;\r\n}\r\nretval = tp3780I_ClaimResources(&pDrvData->rBDData);\r\nPRINTK_2(TRACE_MWAVE,\r\n"mwavedd::mwave_init, return from tp3780I_ClaimResources"\r\n" retval %x\n",\r\nretval);\r\nif (retval) {\r\nPRINTK_ERROR(KERN_ERR_MWAVE\r\n"mwavedd:mwave_init: Error:"\r\n" Failed to claim resources\n");\r\ngoto cleanup_error;\r\n}\r\npDrvData->bResourcesClaimed = TRUE;\r\nretval = tp3780I_EnableDSP(&pDrvData->rBDData);\r\nPRINTK_2(TRACE_MWAVE,\r\n"mwavedd::mwave_init, return from tp3780I_EnableDSP"\r\n" retval %x\n",\r\nretval);\r\nif (retval) {\r\nPRINTK_ERROR(KERN_ERR_MWAVE\r\n"mwavedd:mwave_init: Error:"\r\n" Failed to enable DSP\n");\r\ngoto cleanup_error;\r\n}\r\npDrvData->bDSPEnabled = TRUE;\r\nif (misc_register(&mwave_misc_dev) < 0) {\r\nPRINTK_ERROR(KERN_ERR_MWAVE\r\n"mwavedd:mwave_init: Error:"\r\n" Failed to register misc device\n");\r\ngoto cleanup_error;\r\n}\r\npDrvData->bMwaveDevRegistered = TRUE;\r\npDrvData->sLine = register_serial_portandirq(\r\npDrvData->rBDData.rDspSettings.usUartBaseIO,\r\npDrvData->rBDData.rDspSettings.usUartIrq\r\n);\r\nif (pDrvData->sLine < 0) {\r\nPRINTK_ERROR(KERN_ERR_MWAVE\r\n"mwavedd:mwave_init: Error:"\r\n" Failed to register serial driver\n");\r\ngoto cleanup_error;\r\n}\r\n#if 0\r\nmemset(&mwave_device, 0, sizeof (struct device));\r\ndev_set_name(&mwave_device, "mwave");\r\nif (device_register(&mwave_device))\r\ngoto cleanup_error;\r\npDrvData->device_registered = TRUE;\r\nfor (i = 0; i < ARRAY_SIZE(mwave_dev_attrs); i++) {\r\nif(device_create_file(&mwave_device, mwave_dev_attrs[i])) {\r\nPRINTK_ERROR(KERN_ERR_MWAVE\r\n"mwavedd:mwave_init: Error:"\r\n" Failed to create sysfs file %s\n",\r\nmwave_dev_attrs[i]->attr.name);\r\ngoto cleanup_error;\r\n}\r\npDrvData->nr_registered_attrs++;\r\n}\r\n#endif\r\nreturn 0;\r\ncleanup_error:\r\nPRINTK_ERROR(KERN_ERR_MWAVE\r\n"mwavedd::mwave_init: Error:"\r\n" Failed to initialize\n");\r\nmwave_exit();\r\nreturn -EIO;\r\n}
