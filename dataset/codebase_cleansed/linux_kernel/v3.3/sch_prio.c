static struct Qdisc *\r\nprio_classify(struct sk_buff *skb, struct Qdisc *sch, int *qerr)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nu32 band = skb->priority;\r\nstruct tcf_result res;\r\nint err;\r\n*qerr = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\r\nif (TC_H_MAJ(skb->priority) != sch->handle) {\r\nerr = tc_classify(skb, q->filter_list, &res);\r\n#ifdef CONFIG_NET_CLS_ACT\r\nswitch (err) {\r\ncase TC_ACT_STOLEN:\r\ncase TC_ACT_QUEUED:\r\n*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\r\ncase TC_ACT_SHOT:\r\nreturn NULL;\r\n}\r\n#endif\r\nif (!q->filter_list || err < 0) {\r\nif (TC_H_MAJ(band))\r\nband = 0;\r\nreturn q->queues[q->prio2band[band & TC_PRIO_MAX]];\r\n}\r\nband = res.classid;\r\n}\r\nband = TC_H_MIN(band) - 1;\r\nif (band >= q->bands)\r\nreturn q->queues[q->prio2band[0]];\r\nreturn q->queues[band];\r\n}\r\nstatic int\r\nprio_enqueue(struct sk_buff *skb, struct Qdisc *sch)\r\n{\r\nstruct Qdisc *qdisc;\r\nint ret;\r\nqdisc = prio_classify(skb, sch, &ret);\r\n#ifdef CONFIG_NET_CLS_ACT\r\nif (qdisc == NULL) {\r\nif (ret & __NET_XMIT_BYPASS)\r\nsch->qstats.drops++;\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\n#endif\r\nret = qdisc_enqueue(skb, qdisc);\r\nif (ret == NET_XMIT_SUCCESS) {\r\nsch->q.qlen++;\r\nreturn NET_XMIT_SUCCESS;\r\n}\r\nif (net_xmit_drop_count(ret))\r\nsch->qstats.drops++;\r\nreturn ret;\r\n}\r\nstatic struct sk_buff *prio_peek(struct Qdisc *sch)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nint prio;\r\nfor (prio = 0; prio < q->bands; prio++) {\r\nstruct Qdisc *qdisc = q->queues[prio];\r\nstruct sk_buff *skb = qdisc->ops->peek(qdisc);\r\nif (skb)\r\nreturn skb;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sk_buff *prio_dequeue(struct Qdisc *sch)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nint prio;\r\nfor (prio = 0; prio < q->bands; prio++) {\r\nstruct Qdisc *qdisc = q->queues[prio];\r\nstruct sk_buff *skb = qdisc_dequeue_peeked(qdisc);\r\nif (skb) {\r\nqdisc_bstats_update(sch, skb);\r\nsch->q.qlen--;\r\nreturn skb;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned int prio_drop(struct Qdisc *sch)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nint prio;\r\nunsigned int len;\r\nstruct Qdisc *qdisc;\r\nfor (prio = q->bands-1; prio >= 0; prio--) {\r\nqdisc = q->queues[prio];\r\nif (qdisc->ops->drop && (len = qdisc->ops->drop(qdisc)) != 0) {\r\nsch->q.qlen--;\r\nreturn len;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nprio_reset(struct Qdisc *sch)\r\n{\r\nint prio;\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nfor (prio = 0; prio < q->bands; prio++)\r\nqdisc_reset(q->queues[prio]);\r\nsch->q.qlen = 0;\r\n}\r\nstatic void\r\nprio_destroy(struct Qdisc *sch)\r\n{\r\nint prio;\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\ntcf_destroy_chain(&q->filter_list);\r\nfor (prio = 0; prio < q->bands; prio++)\r\nqdisc_destroy(q->queues[prio]);\r\n}\r\nstatic int prio_tune(struct Qdisc *sch, struct nlattr *opt)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nstruct tc_prio_qopt *qopt;\r\nint i;\r\nif (nla_len(opt) < sizeof(*qopt))\r\nreturn -EINVAL;\r\nqopt = nla_data(opt);\r\nif (qopt->bands > TCQ_PRIO_BANDS || qopt->bands < 2)\r\nreturn -EINVAL;\r\nfor (i = 0; i <= TC_PRIO_MAX; i++) {\r\nif (qopt->priomap[i] >= qopt->bands)\r\nreturn -EINVAL;\r\n}\r\nsch_tree_lock(sch);\r\nq->bands = qopt->bands;\r\nmemcpy(q->prio2band, qopt->priomap, TC_PRIO_MAX+1);\r\nfor (i = q->bands; i < TCQ_PRIO_BANDS; i++) {\r\nstruct Qdisc *child = q->queues[i];\r\nq->queues[i] = &noop_qdisc;\r\nif (child != &noop_qdisc) {\r\nqdisc_tree_decrease_qlen(child, child->q.qlen);\r\nqdisc_destroy(child);\r\n}\r\n}\r\nsch_tree_unlock(sch);\r\nfor (i = 0; i < q->bands; i++) {\r\nif (q->queues[i] == &noop_qdisc) {\r\nstruct Qdisc *child, *old;\r\nchild = qdisc_create_dflt(sch->dev_queue,\r\n&pfifo_qdisc_ops,\r\nTC_H_MAKE(sch->handle, i + 1));\r\nif (child) {\r\nsch_tree_lock(sch);\r\nold = q->queues[i];\r\nq->queues[i] = child;\r\nif (old != &noop_qdisc) {\r\nqdisc_tree_decrease_qlen(old,\r\nold->q.qlen);\r\nqdisc_destroy(old);\r\n}\r\nsch_tree_unlock(sch);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int prio_init(struct Qdisc *sch, struct nlattr *opt)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nint i;\r\nfor (i = 0; i < TCQ_PRIO_BANDS; i++)\r\nq->queues[i] = &noop_qdisc;\r\nif (opt == NULL) {\r\nreturn -EINVAL;\r\n} else {\r\nint err;\r\nif ((err = prio_tune(sch, opt)) != 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int prio_dump(struct Qdisc *sch, struct sk_buff *skb)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tc_prio_qopt opt;\r\nopt.bands = q->bands;\r\nmemcpy(&opt.priomap, q->prio2band, TC_PRIO_MAX + 1);\r\nNLA_PUT(skb, TCA_OPTIONS, sizeof(opt), &opt);\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int prio_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,\r\nstruct Qdisc **old)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nunsigned long band = arg - 1;\r\nif (new == NULL)\r\nnew = &noop_qdisc;\r\nsch_tree_lock(sch);\r\n*old = q->queues[band];\r\nq->queues[band] = new;\r\nqdisc_tree_decrease_qlen(*old, (*old)->q.qlen);\r\nqdisc_reset(*old);\r\nsch_tree_unlock(sch);\r\nreturn 0;\r\n}\r\nstatic struct Qdisc *\r\nprio_leaf(struct Qdisc *sch, unsigned long arg)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nunsigned long band = arg - 1;\r\nreturn q->queues[band];\r\n}\r\nstatic unsigned long prio_get(struct Qdisc *sch, u32 classid)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nunsigned long band = TC_H_MIN(classid);\r\nif (band - 1 >= q->bands)\r\nreturn 0;\r\nreturn band;\r\n}\r\nstatic unsigned long prio_bind(struct Qdisc *sch, unsigned long parent, u32 classid)\r\n{\r\nreturn prio_get(sch, classid);\r\n}\r\nstatic void prio_put(struct Qdisc *q, unsigned long cl)\r\n{\r\n}\r\nstatic int prio_dump_class(struct Qdisc *sch, unsigned long cl, struct sk_buff *skb,\r\nstruct tcmsg *tcm)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\ntcm->tcm_handle |= TC_H_MIN(cl);\r\ntcm->tcm_info = q->queues[cl-1]->handle;\r\nreturn 0;\r\n}\r\nstatic int prio_dump_class_stats(struct Qdisc *sch, unsigned long cl,\r\nstruct gnet_dump *d)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nstruct Qdisc *cl_q;\r\ncl_q = q->queues[cl - 1];\r\ncl_q->qstats.qlen = cl_q->q.qlen;\r\nif (gnet_stats_copy_basic(d, &cl_q->bstats) < 0 ||\r\ngnet_stats_copy_queue(d, &cl_q->qstats) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void prio_walk(struct Qdisc *sch, struct qdisc_walker *arg)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nint prio;\r\nif (arg->stop)\r\nreturn;\r\nfor (prio = 0; prio < q->bands; prio++) {\r\nif (arg->count < arg->skip) {\r\narg->count++;\r\ncontinue;\r\n}\r\nif (arg->fn(sch, prio + 1, arg) < 0) {\r\narg->stop = 1;\r\nbreak;\r\n}\r\narg->count++;\r\n}\r\n}\r\nstatic struct tcf_proto **prio_find_tcf(struct Qdisc *sch, unsigned long cl)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nif (cl)\r\nreturn NULL;\r\nreturn &q->filter_list;\r\n}\r\nstatic int __init prio_module_init(void)\r\n{\r\nreturn register_qdisc(&prio_qdisc_ops);\r\n}\r\nstatic void __exit prio_module_exit(void)\r\n{\r\nunregister_qdisc(&prio_qdisc_ops);\r\n}
