static int cadet_getstereo(struct cadet *dev)\r\n{\r\nint ret = V4L2_TUNER_SUB_MONO;\r\nif (dev->curtuner != 0)\r\nreturn V4L2_TUNER_SUB_MONO;\r\nmutex_lock(&dev->lock);\r\noutb(7, dev->io);\r\nif ((inb(dev->io + 1) & 0x40) == 0)\r\nret = V4L2_TUNER_SUB_STEREO;\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic unsigned cadet_gettune(struct cadet *dev)\r\n{\r\nint curvol, i;\r\nunsigned fifo = 0;\r\nmutex_lock(&dev->lock);\r\noutb(7, dev->io);\r\ncurvol = inb(dev->io + 1);\r\noutb(0x00, dev->io + 1);\r\ndev->tunestat = 0xffff;\r\nfor (i = 0; i < 25; i++) {\r\nfifo = (fifo << 1) | ((inb(dev->io + 1) >> 7) & 0x01);\r\nif (i < 24) {\r\noutb(0x01, dev->io + 1);\r\ndev->tunestat &= inb(dev->io + 1);\r\noutb(0x00, dev->io + 1);\r\n}\r\n}\r\noutb(curvol, dev->io + 1);\r\nmutex_unlock(&dev->lock);\r\nreturn fifo;\r\n}\r\nstatic unsigned cadet_getfreq(struct cadet *dev)\r\n{\r\nint i;\r\nunsigned freq = 0, test, fifo = 0;\r\nfifo = cadet_gettune(dev);\r\nif (dev->curtuner == 0) {\r\ntest = 12500;\r\nfor (i = 0; i < 14; i++) {\r\nif ((fifo & 0x01) != 0)\r\nfreq += test;\r\ntest = test << 1;\r\nfifo = fifo >> 1;\r\n}\r\nfreq -= 10700000;\r\nfreq = (freq * 16) / 1000000;\r\n}\r\nif (dev->curtuner == 1)\r\nfreq = ((fifo & 0x7fff) - 2010) * 16;\r\nreturn freq;\r\n}\r\nstatic void cadet_settune(struct cadet *dev, unsigned fifo)\r\n{\r\nint i;\r\nunsigned test;\r\nmutex_lock(&dev->lock);\r\noutb(7, dev->io);\r\ntest = 0;\r\ntest = (fifo >> 23) & 0x02;\r\ntest |= 0x1c;\r\noutb(7, dev->io);\r\noutb(test, dev->io + 1);\r\nfor (i = 0; i < 25; i++) {\r\ntest |= 0x01;\r\noutb(test, dev->io + 1);\r\ntest &= 0xfe;\r\noutb(test, dev->io + 1);\r\nfifo = fifo << 1;\r\ntest = 0x1c | ((fifo >> 23) & 0x02);\r\noutb(test, dev->io + 1);\r\n}\r\nmutex_unlock(&dev->lock);\r\n}\r\nstatic void cadet_setfreq(struct cadet *dev, unsigned freq)\r\n{\r\nunsigned fifo;\r\nint i, j, test;\r\nint curvol;\r\nfifo = 0;\r\nif (dev->curtuner == 0) {\r\ntest = 102400;\r\nfreq = (freq * 1000) / 16;\r\nfreq += 10700;\r\nfor (i = 0; i < 14; i++) {\r\nfifo = fifo << 1;\r\nif (freq >= test) {\r\nfifo |= 0x01;\r\nfreq -= test;\r\n}\r\ntest = test >> 1;\r\n}\r\n}\r\nif (dev->curtuner == 1) {\r\nfifo = (freq / 16) + 2010;\r\nfifo |= 0x100000;\r\n}\r\nmutex_lock(&dev->lock);\r\noutb(7, dev->io);\r\ncurvol = inb(dev->io + 1);\r\nmutex_unlock(&dev->lock);\r\nfor (j = 3; j > -1; j--) {\r\ncadet_settune(dev, fifo | (j << 16));\r\nmutex_lock(&dev->lock);\r\noutb(7, dev->io);\r\noutb(curvol, dev->io + 1);\r\nmutex_unlock(&dev->lock);\r\nmsleep(100);\r\ncadet_gettune(dev);\r\nif ((dev->tunestat & 0x40) == 0) {\r\ndev->sigstrength = sigtable[dev->curtuner][j];\r\nreturn;\r\n}\r\n}\r\ndev->sigstrength = 0;\r\n}\r\nstatic int cadet_getvol(struct cadet *dev)\r\n{\r\nint ret = 0;\r\nmutex_lock(&dev->lock);\r\noutb(7, dev->io);\r\nif ((inb(dev->io + 1) & 0x20) != 0)\r\nret = 0xffff;\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic void cadet_setvol(struct cadet *dev, int vol)\r\n{\r\nmutex_lock(&dev->lock);\r\noutb(7, dev->io);\r\nif (vol > 0)\r\noutb(0x20, dev->io + 1);\r\nelse\r\noutb(0x00, dev->io + 1);\r\nmutex_unlock(&dev->lock);\r\n}\r\nstatic void cadet_handler(unsigned long data)\r\n{\r\nstruct cadet *dev = (void *)data;\r\nif (mutex_trylock(&dev->lock)) {\r\noutb(0x3, dev->io);\r\nif ((inb(dev->io + 1) & 0x20) != 0)\r\nprintk(KERN_CRIT "cadet: RDS fifo overflow\n");\r\noutb(0x80, dev->io);\r\nwhile ((inb(dev->io) & 0x80) != 0) {\r\ndev->rdsbuf[dev->rdsin] = inb(dev->io + 1);\r\nif (dev->rdsin == dev->rdsout)\r\nprintk(KERN_WARNING "cadet: RDS buffer overflow\n");\r\nelse\r\ndev->rdsin++;\r\n}\r\nmutex_unlock(&dev->lock);\r\n}\r\nif (dev->rdsin != dev->rdsout)\r\nwake_up_interruptible(&dev->read_queue);\r\ninit_timer(&dev->readtimer);\r\ndev->readtimer.function = cadet_handler;\r\ndev->readtimer.data = (unsigned long)0;\r\ndev->readtimer.expires = jiffies + msecs_to_jiffies(50);\r\nadd_timer(&dev->readtimer);\r\n}\r\nstatic ssize_t cadet_read(struct file *file, char __user *data, size_t count, loff_t *ppos)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\nunsigned char readbuf[RDS_BUFFER];\r\nint i = 0;\r\nmutex_lock(&dev->lock);\r\nif (dev->rdsstat == 0) {\r\ndev->rdsstat = 1;\r\noutb(0x80, dev->io);\r\ninit_timer(&dev->readtimer);\r\ndev->readtimer.function = cadet_handler;\r\ndev->readtimer.data = (unsigned long)dev;\r\ndev->readtimer.expires = jiffies + msecs_to_jiffies(50);\r\nadd_timer(&dev->readtimer);\r\n}\r\nif (dev->rdsin == dev->rdsout) {\r\nmutex_unlock(&dev->lock);\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EWOULDBLOCK;\r\ninterruptible_sleep_on(&dev->read_queue);\r\nmutex_lock(&dev->lock);\r\n}\r\nwhile (i < count && dev->rdsin != dev->rdsout)\r\nreadbuf[i++] = dev->rdsbuf[dev->rdsout++];\r\nmutex_unlock(&dev->lock);\r\nif (copy_to_user(data, readbuf, i))\r\nreturn -EFAULT;\r\nreturn i;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstrlcpy(v->driver, "ADS Cadet", sizeof(v->driver));\r\nstrlcpy(v->card, "ADS Cadet", sizeof(v->card));\r\nstrlcpy(v->bus_info, "ISA", sizeof(v->bus_info));\r\nv->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO |\r\nV4L2_CAP_READWRITE | V4L2_CAP_RDS_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\nv->type = V4L2_TUNER_RADIO;\r\nswitch (v->index) {\r\ncase 0:\r\nstrlcpy(v->name, "FM", sizeof(v->name));\r\nv->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS |\r\nV4L2_TUNER_CAP_RDS_BLOCK_IO;\r\nv->rangelow = 1400;\r\nv->rangehigh = 1728;\r\nv->rxsubchans = cadet_getstereo(dev);\r\nswitch (v->rxsubchans) {\r\ncase V4L2_TUNER_SUB_MONO:\r\nv->audmode = V4L2_TUNER_MODE_MONO;\r\nbreak;\r\ncase V4L2_TUNER_SUB_STEREO:\r\nv->audmode = V4L2_TUNER_MODE_STEREO;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nv->rxsubchans |= V4L2_TUNER_SUB_RDS;\r\nbreak;\r\ncase 1:\r\nstrlcpy(v->name, "AM", sizeof(v->name));\r\nv->capability = V4L2_TUNER_CAP_LOW;\r\nv->rangelow = 8320;\r\nv->rangehigh = 26400;\r\nv->rxsubchans = V4L2_TUNER_SUB_MONO;\r\nv->audmode = V4L2_TUNER_MODE_MONO;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nv->signal = dev->sigstrength;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\nif (v->index != 0 && v->index != 1)\r\nreturn -EINVAL;\r\ndev->curtuner = v->index;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\nf->tuner = dev->curtuner;\r\nf->type = V4L2_TUNER_RADIO;\r\nf->frequency = cadet_getfreq(dev);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\nif (f->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nif (dev->curtuner == 0 && (f->frequency < 1400 || f->frequency > 1728))\r\nreturn -EINVAL;\r\nif (dev->curtuner == 1 && (f->frequency < 8320 || f->frequency > 26400))\r\nreturn -EINVAL;\r\ncadet_setfreq(dev, f->frequency);\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nswitch (qc->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 0xff, 1, 0xff);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nctrl->value = (cadet_getvol(dev) == 0);\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nctrl->value = cadet_getvol(dev);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\nswitch (ctrl->id){\r\ncase V4L2_CID_AUDIO_MUTE:\r\nif (ctrl->value)\r\ncadet_setvol(dev, 0);\r\nelse\r\ncadet_setvol(dev, 0xffff);\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\ncadet_setvol(dev, ctrl->value);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *filp, void *priv, unsigned int i)\r\n{\r\nreturn i ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\na->index = 0;\r\nstrlcpy(a->name, "Radio", sizeof(a->name));\r\na->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\nreturn a->index ? -EINVAL : 0;\r\n}\r\nstatic int cadet_open(struct file *file)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\nmutex_lock(&dev->lock);\r\ndev->users++;\r\nif (1 == dev->users)\r\ninit_waitqueue_head(&dev->read_queue);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int cadet_release(struct file *file)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\nmutex_lock(&dev->lock);\r\ndev->users--;\r\nif (0 == dev->users) {\r\ndel_timer_sync(&dev->readtimer);\r\ndev->rdsstat = 0;\r\n}\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic unsigned int cadet_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\npoll_wait(file, &dev->read_queue, wait);\r\nif (dev->rdsin != dev->rdsout)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int cadet_pnp_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)\r\n{\r\nif (!dev)\r\nreturn -ENODEV;\r\nif (io > 0)\r\nreturn -EBUSY;\r\nif (!pnp_port_valid(dev, 0))\r\nreturn -ENODEV;\r\nio = pnp_port_start(dev, 0);\r\nprintk(KERN_INFO "radio-cadet: PnP reports device at %#x\n", io);\r\nreturn io;\r\n}\r\nstatic void cadet_probe(struct cadet *dev)\r\n{\r\nstatic int iovals[8] = { 0x330, 0x332, 0x334, 0x336, 0x338, 0x33a, 0x33c, 0x33e };\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\ndev->io = iovals[i];\r\nif (request_region(dev->io, 2, "cadet-probe")) {\r\ncadet_setfreq(dev, 1410);\r\nif (cadet_getfreq(dev) == 1410) {\r\nrelease_region(dev->io, 2);\r\nreturn;\r\n}\r\nrelease_region(dev->io, 2);\r\n}\r\n}\r\ndev->io = -1;\r\n}\r\nstatic int __init cadet_init(void)\r\n{\r\nstruct cadet *dev = &cadet_card;\r\nstruct v4l2_device *v4l2_dev = &dev->v4l2_dev;\r\nint res;\r\nstrlcpy(v4l2_dev->name, "cadet", sizeof(v4l2_dev->name));\r\nmutex_init(&dev->lock);\r\nif (io < 0)\r\npnp_register_driver(&cadet_pnp_driver);\r\ndev->io = io;\r\nif (dev->io < 0)\r\ncadet_probe(dev);\r\nif (dev->io < 0) {\r\n#ifdef MODULE\r\nv4l2_err(v4l2_dev, "you must set an I/O address with io=0x330, 0x332, 0x334,\n");\r\nv4l2_err(v4l2_dev, "0x336, 0x338, 0x33a, 0x33c or 0x33e\n");\r\n#endif\r\ngoto fail;\r\n}\r\nif (!request_region(dev->io, 2, "cadet"))\r\ngoto fail;\r\nres = v4l2_device_register(NULL, v4l2_dev);\r\nif (res < 0) {\r\nrelease_region(dev->io, 2);\r\nv4l2_err(v4l2_dev, "could not register v4l2_device\n");\r\ngoto fail;\r\n}\r\nstrlcpy(dev->vdev.name, v4l2_dev->name, sizeof(dev->vdev.name));\r\ndev->vdev.v4l2_dev = v4l2_dev;\r\ndev->vdev.fops = &cadet_fops;\r\ndev->vdev.ioctl_ops = &cadet_ioctl_ops;\r\ndev->vdev.release = video_device_release_empty;\r\nvideo_set_drvdata(&dev->vdev, dev);\r\nif (video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {\r\nv4l2_device_unregister(v4l2_dev);\r\nrelease_region(dev->io, 2);\r\ngoto fail;\r\n}\r\nv4l2_info(v4l2_dev, "ADS Cadet Radio Card at 0x%x\n", dev->io);\r\nreturn 0;\r\nfail:\r\npnp_unregister_driver(&cadet_pnp_driver);\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit cadet_exit(void)\r\n{\r\nstruct cadet *dev = &cadet_card;\r\nvideo_unregister_device(&dev->vdev);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nrelease_region(dev->io, 2);\r\npnp_unregister_driver(&cadet_pnp_driver);\r\n}
