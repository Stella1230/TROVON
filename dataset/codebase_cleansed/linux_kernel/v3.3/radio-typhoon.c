static void typhoon_setvol_generic(struct typhoon *dev, int vol)\r\n{\r\nmutex_lock(&dev->lock);\r\nvol >>= 14;\r\nvol &= 3;\r\noutb_p(vol / 2, dev->io);\r\noutb_p(vol % 2, dev->io + 2);\r\nmutex_unlock(&dev->lock);\r\n}\r\nstatic int typhoon_setfreq_generic(struct typhoon *dev,\r\nunsigned long frequency)\r\n{\r\nunsigned long outval;\r\nunsigned long x;\r\nmutex_lock(&dev->lock);\r\nx = frequency / 160;\r\noutval = (x * x + 2500) / 5000;\r\noutval = (outval * x + 5000) / 10000;\r\noutval -= (10 * x * x + 10433) / 20866;\r\noutval += 4 * x - 11505;\r\noutb_p((outval >> 8) & 0x01, dev->io + 4);\r\noutb_p(outval >> 9, dev->io + 6);\r\noutb_p(outval & 0xff, dev->io + 8);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int typhoon_setfreq(struct typhoon *dev, unsigned long frequency)\r\n{\r\ntyphoon_setfreq_generic(dev, frequency);\r\ndev->curfreq = frequency;\r\nreturn 0;\r\n}\r\nstatic void typhoon_mute(struct typhoon *dev)\r\n{\r\nif (dev->muted == 1)\r\nreturn;\r\ntyphoon_setvol_generic(dev, 0);\r\ntyphoon_setfreq_generic(dev, dev->mutefreq);\r\ndev->muted = 1;\r\n}\r\nstatic void typhoon_unmute(struct typhoon *dev)\r\n{\r\nif (dev->muted == 0)\r\nreturn;\r\ntyphoon_setfreq_generic(dev, dev->curfreq);\r\ntyphoon_setvol_generic(dev, dev->curvol);\r\ndev->muted = 0;\r\n}\r\nstatic int typhoon_setvol(struct typhoon *dev, int vol)\r\n{\r\nif (dev->muted && vol != 0) {\r\ndev->curvol = vol;\r\ntyphoon_unmute(dev);\r\nreturn 0;\r\n}\r\nif (vol == dev->curvol)\r\nreturn 0;\r\nif (vol == 0) {\r\ntyphoon_mute(dev);\r\ndev->curvol = vol;\r\nreturn 0;\r\n}\r\ntyphoon_setvol_generic(dev, vol);\r\ndev->curvol = vol;\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstrlcpy(v->driver, "radio-typhoon", sizeof(v->driver));\r\nstrlcpy(v->card, "Typhoon Radio", sizeof(v->card));\r\nstrlcpy(v->bus_info, "ISA", sizeof(v->bus_info));\r\nv->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(v->name, "FM", sizeof(v->name));\r\nv->type = V4L2_TUNER_RADIO;\r\nv->rangelow = 87.5 * 16000;\r\nv->rangehigh = 108 * 16000;\r\nv->rxsubchans = V4L2_TUNER_SUB_MONO;\r\nv->capability = V4L2_TUNER_CAP_LOW;\r\nv->audmode = V4L2_TUNER_MODE_MONO;\r\nv->signal = 0xFFFF;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nreturn v->index ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct typhoon *dev = video_drvdata(file);\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_RADIO;\r\nf->frequency = dev->curfreq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct typhoon *dev = video_drvdata(file);\r\nif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\ndev->curfreq = f->frequency;\r\ntyphoon_setfreq(dev, dev->curfreq);\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nswitch (qc->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 65535, 16384, 65535);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct typhoon *dev = video_drvdata(file);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nctrl->value = dev->muted;\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nctrl->value = dev->curvol;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_s_ctrl (struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct typhoon *dev = video_drvdata(file);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nif (ctrl->value)\r\ntyphoon_mute(dev);\r\nelse\r\ntyphoon_unmute(dev);\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\ntyphoon_setvol(dev, ctrl->value);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *filp, void *priv, unsigned int i)\r\n{\r\nreturn i ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\na->index = 0;\r\nstrlcpy(a->name, "Radio", sizeof(a->name));\r\na->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\nreturn a->index ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_log_status(struct file *file, void *priv)\r\n{\r\nstruct typhoon *dev = video_drvdata(file);\r\nstruct v4l2_device *v4l2_dev = &dev->v4l2_dev;\r\nv4l2_info(v4l2_dev, BANNER);\r\n#ifdef MODULE\r\nv4l2_info(v4l2_dev, "Load type: Driver loaded as a module\n\n");\r\n#else\r\nv4l2_info(v4l2_dev, "Load type: Driver compiled into kernel\n\n");\r\n#endif\r\nv4l2_info(v4l2_dev, "frequency = %lu kHz\n", dev->curfreq >> 4);\r\nv4l2_info(v4l2_dev, "volume = %d\n", dev->curvol);\r\nv4l2_info(v4l2_dev, "mute = %s\n", dev->muted ? "on" : "off");\r\nv4l2_info(v4l2_dev, "io = 0x%x\n", dev->io);\r\nv4l2_info(v4l2_dev, "mute frequency = %lu kHz\n", dev->mutefreq >> 4);\r\nreturn 0;\r\n}\r\nstatic int __init typhoon_init(void)\r\n{\r\nstruct typhoon *dev = &typhoon_card;\r\nstruct v4l2_device *v4l2_dev = &dev->v4l2_dev;\r\nint res;\r\nstrlcpy(v4l2_dev->name, "typhoon", sizeof(v4l2_dev->name));\r\ndev->io = io;\r\nif (dev->io == -1) {\r\nv4l2_err(v4l2_dev, "You must set an I/O address with io=0x316 or io=0x336\n");\r\nreturn -EINVAL;\r\n}\r\nif (mutefreq < 87000 || mutefreq > 108500) {\r\nv4l2_err(v4l2_dev, "You must set a frequency (in kHz) used when muting the card,\n");\r\nv4l2_err(v4l2_dev, "e.g. with \"mutefreq=87500\" (87000 <= mutefreq <= 108500)\n");\r\nreturn -EINVAL;\r\n}\r\ndev->curfreq = dev->mutefreq = mutefreq << 4;\r\nmutex_init(&dev->lock);\r\nif (!request_region(dev->io, 8, "typhoon")) {\r\nv4l2_err(v4l2_dev, "port 0x%x already in use\n",\r\ndev->io);\r\nreturn -EBUSY;\r\n}\r\nres = v4l2_device_register(NULL, v4l2_dev);\r\nif (res < 0) {\r\nrelease_region(dev->io, 8);\r\nv4l2_err(v4l2_dev, "Could not register v4l2_device\n");\r\nreturn res;\r\n}\r\nv4l2_info(v4l2_dev, BANNER);\r\nstrlcpy(dev->vdev.name, v4l2_dev->name, sizeof(dev->vdev.name));\r\ndev->vdev.v4l2_dev = v4l2_dev;\r\ndev->vdev.fops = &typhoon_fops;\r\ndev->vdev.ioctl_ops = &typhoon_ioctl_ops;\r\ndev->vdev.release = video_device_release_empty;\r\nvideo_set_drvdata(&dev->vdev, dev);\r\ntyphoon_mute(dev);\r\nif (video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nrelease_region(dev->io, 8);\r\nreturn -EINVAL;\r\n}\r\nv4l2_info(v4l2_dev, "port 0x%x.\n", dev->io);\r\nv4l2_info(v4l2_dev, "mute frequency is %lu kHz.\n", mutefreq);\r\nreturn 0;\r\n}\r\nstatic void __exit typhoon_exit(void)\r\n{\r\nstruct typhoon *dev = &typhoon_card;\r\nvideo_unregister_device(&dev->vdev);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nrelease_region(dev->io, 8);\r\n}
