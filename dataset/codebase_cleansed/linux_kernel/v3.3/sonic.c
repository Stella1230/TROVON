static int sonic_open(struct net_device *dev)\r\n{\r\nstruct sonic_local *lp = netdev_priv(dev);\r\nint i;\r\nif (sonic_debug > 2)\r\nprintk("sonic_open: initializing sonic driver.\n");\r\nfor (i = 0; i < SONIC_NUM_RRS; i++) {\r\nstruct sk_buff *skb = dev_alloc_skb(SONIC_RBSIZE + 2);\r\nif (skb == NULL) {\r\nwhile(i > 0) {\r\ni--;\r\ndev_kfree_skb(lp->rx_skb[i]);\r\nlp->rx_skb[i] = NULL;\r\n}\r\nprintk(KERN_ERR "%s: couldn't allocate receive buffers\n",\r\ndev->name);\r\nreturn -ENOMEM;\r\n}\r\nif (SONIC_BUS_SCALE(lp->dma_bitmode) == 2)\r\nskb_reserve(skb, 2);\r\nlp->rx_skb[i] = skb;\r\n}\r\nfor (i = 0; i < SONIC_NUM_RRS; i++) {\r\ndma_addr_t laddr = dma_map_single(lp->device, skb_put(lp->rx_skb[i], SONIC_RBSIZE),\r\nSONIC_RBSIZE, DMA_FROM_DEVICE);\r\nif (!laddr) {\r\nwhile(i > 0) {\r\ni--;\r\ndma_unmap_single(lp->device, lp->rx_laddr[i], SONIC_RBSIZE, DMA_FROM_DEVICE);\r\nlp->rx_laddr[i] = (dma_addr_t)0;\r\n}\r\nfor (i = 0; i < SONIC_NUM_RRS; i++) {\r\ndev_kfree_skb(lp->rx_skb[i]);\r\nlp->rx_skb[i] = NULL;\r\n}\r\nprintk(KERN_ERR "%s: couldn't map rx DMA buffers\n",\r\ndev->name);\r\nreturn -ENOMEM;\r\n}\r\nlp->rx_laddr[i] = laddr;\r\n}\r\nsonic_init(dev);\r\nnetif_start_queue(dev);\r\nif (sonic_debug > 2)\r\nprintk("sonic_open: Initialization done.\n");\r\nreturn 0;\r\n}\r\nstatic int sonic_close(struct net_device *dev)\r\n{\r\nstruct sonic_local *lp = netdev_priv(dev);\r\nint i;\r\nif (sonic_debug > 2)\r\nprintk("sonic_close\n");\r\nnetif_stop_queue(dev);\r\nSONIC_WRITE(SONIC_IMR, 0);\r\nSONIC_WRITE(SONIC_ISR, 0x7fff);\r\nSONIC_WRITE(SONIC_CMD, SONIC_CR_RST);\r\nfor (i = 0; i < SONIC_NUM_TDS; i++) {\r\nif(lp->tx_laddr[i]) {\r\ndma_unmap_single(lp->device, lp->tx_laddr[i], lp->tx_len[i], DMA_TO_DEVICE);\r\nlp->tx_laddr[i] = (dma_addr_t)0;\r\n}\r\nif(lp->tx_skb[i]) {\r\ndev_kfree_skb(lp->tx_skb[i]);\r\nlp->tx_skb[i] = NULL;\r\n}\r\n}\r\nfor (i = 0; i < SONIC_NUM_RRS; i++) {\r\nif(lp->rx_laddr[i]) {\r\ndma_unmap_single(lp->device, lp->rx_laddr[i], SONIC_RBSIZE, DMA_FROM_DEVICE);\r\nlp->rx_laddr[i] = (dma_addr_t)0;\r\n}\r\nif(lp->rx_skb[i]) {\r\ndev_kfree_skb(lp->rx_skb[i]);\r\nlp->rx_skb[i] = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sonic_tx_timeout(struct net_device *dev)\r\n{\r\nstruct sonic_local *lp = netdev_priv(dev);\r\nint i;\r\nSONIC_WRITE(SONIC_IMR, 0);\r\nSONIC_WRITE(SONIC_ISR, 0x7fff);\r\nSONIC_WRITE(SONIC_CMD, SONIC_CR_RST);\r\nfor (i = 0; i < SONIC_NUM_TDS; i++) {\r\nif(lp->tx_laddr[i]) {\r\ndma_unmap_single(lp->device, lp->tx_laddr[i], lp->tx_len[i], DMA_TO_DEVICE);\r\nlp->tx_laddr[i] = (dma_addr_t)0;\r\n}\r\nif(lp->tx_skb[i]) {\r\ndev_kfree_skb(lp->tx_skb[i]);\r\nlp->tx_skb[i] = NULL;\r\n}\r\n}\r\nsonic_init(dev);\r\nlp->stats.tx_errors++;\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int sonic_send_packet(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct sonic_local *lp = netdev_priv(dev);\r\ndma_addr_t laddr;\r\nint length;\r\nint entry = lp->next_tx;\r\nif (sonic_debug > 2)\r\nprintk("sonic_send_packet: skb=%p, dev=%p\n", skb, dev);\r\nlength = skb->len;\r\nif (length < ETH_ZLEN) {\r\nif (skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nlength = ETH_ZLEN;\r\n}\r\nladdr = dma_map_single(lp->device, skb->data, length, DMA_TO_DEVICE);\r\nif (!laddr) {\r\nprintk(KERN_ERR "%s: failed to map tx DMA buffer.\n", dev->name);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nsonic_tda_put(dev, entry, SONIC_TD_STATUS, 0);\r\nsonic_tda_put(dev, entry, SONIC_TD_FRAG_COUNT, 1);\r\nsonic_tda_put(dev, entry, SONIC_TD_PKTSIZE, length);\r\nsonic_tda_put(dev, entry, SONIC_TD_FRAG_PTR_L, laddr & 0xffff);\r\nsonic_tda_put(dev, entry, SONIC_TD_FRAG_PTR_H, laddr >> 16);\r\nsonic_tda_put(dev, entry, SONIC_TD_FRAG_SIZE, length);\r\nsonic_tda_put(dev, entry, SONIC_TD_LINK,\r\nsonic_tda_get(dev, entry, SONIC_TD_LINK) | SONIC_EOL);\r\nwmb();\r\nlp->tx_len[entry] = length;\r\nlp->tx_laddr[entry] = laddr;\r\nlp->tx_skb[entry] = skb;\r\nwmb();\r\nsonic_tda_put(dev, lp->eol_tx, SONIC_TD_LINK,\r\nsonic_tda_get(dev, lp->eol_tx, SONIC_TD_LINK) & ~SONIC_EOL);\r\nlp->eol_tx = entry;\r\nlp->next_tx = (entry + 1) & SONIC_TDS_MASK;\r\nif (lp->tx_skb[lp->next_tx] != NULL) {\r\nif (sonic_debug > 3)\r\nprintk("%s: stopping queue\n", dev->name);\r\nnetif_stop_queue(dev);\r\n} else netif_start_queue(dev);\r\nif (sonic_debug > 2)\r\nprintk("sonic_send_packet: issuing Tx command\n");\r\nSONIC_WRITE(SONIC_CMD, SONIC_CR_TXP);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t sonic_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct sonic_local *lp = netdev_priv(dev);\r\nint status;\r\nif (!(status = SONIC_READ(SONIC_ISR) & SONIC_IMR_DEFAULT))\r\nreturn IRQ_NONE;\r\ndo {\r\nif (status & SONIC_INT_PKTRX) {\r\nif (sonic_debug > 2)\r\nprintk("%s: packet rx\n", dev->name);\r\nsonic_rx(dev);\r\nSONIC_WRITE(SONIC_ISR, SONIC_INT_PKTRX);\r\n}\r\nif (status & SONIC_INT_TXDN) {\r\nint entry = lp->cur_tx;\r\nint td_status;\r\nint freed_some = 0;\r\nif (sonic_debug > 2)\r\nprintk("%s: tx done\n", dev->name);\r\nwhile (lp->tx_skb[entry] != NULL) {\r\nif ((td_status = sonic_tda_get(dev, entry, SONIC_TD_STATUS)) == 0)\r\nbreak;\r\nif (td_status & 0x0001) {\r\nlp->stats.tx_packets++;\r\nlp->stats.tx_bytes += sonic_tda_get(dev, entry, SONIC_TD_PKTSIZE);\r\n} else {\r\nlp->stats.tx_errors++;\r\nif (td_status & 0x0642)\r\nlp->stats.tx_aborted_errors++;\r\nif (td_status & 0x0180)\r\nlp->stats.tx_carrier_errors++;\r\nif (td_status & 0x0020)\r\nlp->stats.tx_window_errors++;\r\nif (td_status & 0x0004)\r\nlp->stats.tx_fifo_errors++;\r\n}\r\ndev_kfree_skb_irq(lp->tx_skb[entry]);\r\nlp->tx_skb[entry] = NULL;\r\ndma_unmap_single(lp->device, lp->tx_laddr[entry], lp->tx_len[entry], DMA_TO_DEVICE);\r\nlp->tx_laddr[entry] = (dma_addr_t)0;\r\nfreed_some = 1;\r\nif (sonic_tda_get(dev, entry, SONIC_TD_LINK) & SONIC_EOL) {\r\nentry = (entry + 1) & SONIC_TDS_MASK;\r\nbreak;\r\n}\r\nentry = (entry + 1) & SONIC_TDS_MASK;\r\n}\r\nif (freed_some || lp->tx_skb[entry] == NULL)\r\nnetif_wake_queue(dev);\r\nlp->cur_tx = entry;\r\nSONIC_WRITE(SONIC_ISR, SONIC_INT_TXDN);\r\n}\r\nif (status & SONIC_INT_RFO) {\r\nif (sonic_debug > 1)\r\nprintk("%s: rx fifo overrun\n", dev->name);\r\nlp->stats.rx_fifo_errors++;\r\nSONIC_WRITE(SONIC_ISR, SONIC_INT_RFO);\r\n}\r\nif (status & SONIC_INT_RDE) {\r\nif (sonic_debug > 1)\r\nprintk("%s: rx descriptors exhausted\n", dev->name);\r\nlp->stats.rx_dropped++;\r\nSONIC_WRITE(SONIC_ISR, SONIC_INT_RDE);\r\n}\r\nif (status & SONIC_INT_RBAE) {\r\nif (sonic_debug > 1)\r\nprintk("%s: rx buffer area exceeded\n", dev->name);\r\nlp->stats.rx_dropped++;\r\nSONIC_WRITE(SONIC_ISR, SONIC_INT_RBAE);\r\n}\r\nif (status & SONIC_INT_FAE) {\r\nlp->stats.rx_frame_errors += 65536;\r\nSONIC_WRITE(SONIC_ISR, SONIC_INT_FAE);\r\n}\r\nif (status & SONIC_INT_CRC) {\r\nlp->stats.rx_crc_errors += 65536;\r\nSONIC_WRITE(SONIC_ISR, SONIC_INT_CRC);\r\n}\r\nif (status & SONIC_INT_MP) {\r\nlp->stats.rx_missed_errors += 65536;\r\nSONIC_WRITE(SONIC_ISR, SONIC_INT_MP);\r\n}\r\nif (status & SONIC_INT_TXER) {\r\nif ((SONIC_READ(SONIC_TCR) & SONIC_TCR_FU) && (sonic_debug > 2))\r\nprintk(KERN_ERR "%s: tx fifo underrun\n", dev->name);\r\nSONIC_WRITE(SONIC_ISR, SONIC_INT_TXER);\r\n}\r\nif (status & SONIC_INT_BR) {\r\nprintk(KERN_ERR "%s: Bus retry occurred! Device interrupt disabled.\n",\r\ndev->name);\r\nSONIC_WRITE(SONIC_IMR, 0);\r\nSONIC_WRITE(SONIC_ISR, SONIC_INT_BR);\r\n}\r\nif (status & SONIC_INT_LCD)\r\nSONIC_WRITE(SONIC_ISR, SONIC_INT_LCD);\r\n} while((status = SONIC_READ(SONIC_ISR) & SONIC_IMR_DEFAULT));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sonic_rx(struct net_device *dev)\r\n{\r\nstruct sonic_local *lp = netdev_priv(dev);\r\nint status;\r\nint entry = lp->cur_rx;\r\nwhile (sonic_rda_get(dev, entry, SONIC_RD_IN_USE) == 0) {\r\nstruct sk_buff *used_skb;\r\nstruct sk_buff *new_skb;\r\ndma_addr_t new_laddr;\r\nu16 bufadr_l;\r\nu16 bufadr_h;\r\nint pkt_len;\r\nstatus = sonic_rda_get(dev, entry, SONIC_RD_STATUS);\r\nif (status & SONIC_RCR_PRX) {\r\nnew_skb = dev_alloc_skb(SONIC_RBSIZE + 2);\r\nif (new_skb == NULL) {\r\nprintk(KERN_ERR "%s: Memory squeeze, dropping packet.\n", dev->name);\r\nlp->stats.rx_dropped++;\r\nbreak;\r\n}\r\nif(SONIC_BUS_SCALE(lp->dma_bitmode) == 2)\r\nskb_reserve(new_skb, 2);\r\nnew_laddr = dma_map_single(lp->device, skb_put(new_skb, SONIC_RBSIZE),\r\nSONIC_RBSIZE, DMA_FROM_DEVICE);\r\nif (!new_laddr) {\r\ndev_kfree_skb(new_skb);\r\nprintk(KERN_ERR "%s: Failed to map rx buffer, dropping packet.\n", dev->name);\r\nlp->stats.rx_dropped++;\r\nbreak;\r\n}\r\ndma_unmap_single(lp->device, lp->rx_laddr[entry], SONIC_RBSIZE, DMA_FROM_DEVICE);\r\nused_skb = lp->rx_skb[entry];\r\npkt_len = sonic_rda_get(dev, entry, SONIC_RD_PKTLEN);\r\nskb_trim(used_skb, pkt_len);\r\nused_skb->protocol = eth_type_trans(used_skb, dev);\r\nnetif_rx(used_skb);\r\nlp->stats.rx_packets++;\r\nlp->stats.rx_bytes += pkt_len;\r\nlp->rx_laddr[entry] = new_laddr;\r\nlp->rx_skb[entry] = new_skb;\r\nbufadr_l = (unsigned long)new_laddr & 0xffff;\r\nbufadr_h = (unsigned long)new_laddr >> 16;\r\nsonic_rra_put(dev, entry, SONIC_RR_BUFADR_L, bufadr_l);\r\nsonic_rra_put(dev, entry, SONIC_RR_BUFADR_H, bufadr_h);\r\n} else {\r\nlp->stats.rx_errors++;\r\nif (status & SONIC_RCR_FAER)\r\nlp->stats.rx_frame_errors++;\r\nif (status & SONIC_RCR_CRCR)\r\nlp->stats.rx_crc_errors++;\r\n}\r\nif (status & SONIC_RCR_LPKT) {\r\nlp->cur_rwp += SIZEOF_SONIC_RR * SONIC_BUS_SCALE(lp->dma_bitmode);\r\nif (lp->cur_rwp >= lp->rra_end) lp->cur_rwp = lp->rra_laddr & 0xffff;\r\nSONIC_WRITE(SONIC_RWP, lp->cur_rwp);\r\nif (SONIC_READ(SONIC_ISR) & SONIC_INT_RBE) {\r\nif (sonic_debug > 2)\r\nprintk("%s: rx buffer exhausted\n", dev->name);\r\nSONIC_WRITE(SONIC_ISR, SONIC_INT_RBE);\r\n}\r\n} else\r\nprintk(KERN_ERR "%s: rx desc without RCR_LPKT. Shouldn't happen !?\n",\r\ndev->name);\r\nsonic_rda_put(dev, entry, SONIC_RD_LINK,\r\nsonic_rda_get(dev, entry, SONIC_RD_LINK) | SONIC_EOL);\r\nsonic_rda_put(dev, entry, SONIC_RD_IN_USE, 1);\r\nsonic_rda_put(dev, lp->eol_rx, SONIC_RD_LINK,\r\nsonic_rda_get(dev, lp->eol_rx, SONIC_RD_LINK) & ~SONIC_EOL);\r\nlp->eol_rx = entry;\r\nlp->cur_rx = entry = (entry + 1) & SONIC_RDS_MASK;\r\n}\r\n}\r\nstatic struct net_device_stats *sonic_get_stats(struct net_device *dev)\r\n{\r\nstruct sonic_local *lp = netdev_priv(dev);\r\nlp->stats.rx_crc_errors += SONIC_READ(SONIC_CRCT);\r\nSONIC_WRITE(SONIC_CRCT, 0xffff);\r\nlp->stats.rx_frame_errors += SONIC_READ(SONIC_FAET);\r\nSONIC_WRITE(SONIC_FAET, 0xffff);\r\nlp->stats.rx_missed_errors += SONIC_READ(SONIC_MPT);\r\nSONIC_WRITE(SONIC_MPT, 0xffff);\r\nreturn &lp->stats;\r\n}\r\nstatic void sonic_multicast_list(struct net_device *dev)\r\n{\r\nstruct sonic_local *lp = netdev_priv(dev);\r\nunsigned int rcr;\r\nstruct netdev_hw_addr *ha;\r\nunsigned char *addr;\r\nint i;\r\nrcr = SONIC_READ(SONIC_RCR) & ~(SONIC_RCR_PRO | SONIC_RCR_AMC);\r\nrcr |= SONIC_RCR_BRD;\r\nif (dev->flags & IFF_PROMISC) {\r\nrcr |= SONIC_RCR_PRO;\r\n} else {\r\nif ((dev->flags & IFF_ALLMULTI) ||\r\n(netdev_mc_count(dev) > 15)) {\r\nrcr |= SONIC_RCR_AMC;\r\n} else {\r\nif (sonic_debug > 2)\r\nprintk("sonic_multicast_list: mc_count %d\n",\r\nnetdev_mc_count(dev));\r\nsonic_set_cam_enable(dev, 1);\r\ni = 1;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\naddr = ha->addr;\r\nsonic_cda_put(dev, i, SONIC_CD_CAP0, addr[1] << 8 | addr[0]);\r\nsonic_cda_put(dev, i, SONIC_CD_CAP1, addr[3] << 8 | addr[2]);\r\nsonic_cda_put(dev, i, SONIC_CD_CAP2, addr[5] << 8 | addr[4]);\r\nsonic_set_cam_enable(dev, sonic_get_cam_enable(dev) | (1 << i));\r\ni++;\r\n}\r\nSONIC_WRITE(SONIC_CDC, 16);\r\nSONIC_WRITE(SONIC_CDP, lp->cda_laddr & 0xffff);\r\nSONIC_WRITE(SONIC_CMD, SONIC_CR_LCAM);\r\n}\r\n}\r\nif (sonic_debug > 2)\r\nprintk("sonic_multicast_list: setting RCR=%x\n", rcr);\r\nSONIC_WRITE(SONIC_RCR, rcr);\r\n}\r\nstatic int sonic_init(struct net_device *dev)\r\n{\r\nunsigned int cmd;\r\nstruct sonic_local *lp = netdev_priv(dev);\r\nint i;\r\nSONIC_WRITE(SONIC_IMR, 0);\r\nSONIC_WRITE(SONIC_ISR, 0x7fff);\r\nSONIC_WRITE(SONIC_CMD, SONIC_CR_RST);\r\nSONIC_WRITE(SONIC_CMD, 0);\r\nSONIC_WRITE(SONIC_CMD, SONIC_CR_RXDIS);\r\nif (sonic_debug > 2)\r\nprintk("sonic_init: initialize receive resource area\n");\r\nfor (i = 0; i < SONIC_NUM_RRS; i++) {\r\nu16 bufadr_l = (unsigned long)lp->rx_laddr[i] & 0xffff;\r\nu16 bufadr_h = (unsigned long)lp->rx_laddr[i] >> 16;\r\nsonic_rra_put(dev, i, SONIC_RR_BUFADR_L, bufadr_l);\r\nsonic_rra_put(dev, i, SONIC_RR_BUFADR_H, bufadr_h);\r\nsonic_rra_put(dev, i, SONIC_RR_BUFSIZE_L, SONIC_RBSIZE >> 1);\r\nsonic_rra_put(dev, i, SONIC_RR_BUFSIZE_H, 0);\r\n}\r\nlp->rra_end = (lp->rra_laddr + SONIC_NUM_RRS * SIZEOF_SONIC_RR *\r\nSONIC_BUS_SCALE(lp->dma_bitmode)) & 0xffff;\r\nlp->cur_rwp = (lp->rra_laddr + (SONIC_NUM_RRS - 1) * SIZEOF_SONIC_RR *\r\nSONIC_BUS_SCALE(lp->dma_bitmode)) & 0xffff;\r\nSONIC_WRITE(SONIC_RSA, lp->rra_laddr & 0xffff);\r\nSONIC_WRITE(SONIC_REA, lp->rra_end);\r\nSONIC_WRITE(SONIC_RRP, lp->rra_laddr & 0xffff);\r\nSONIC_WRITE(SONIC_RWP, lp->cur_rwp);\r\nSONIC_WRITE(SONIC_URRA, lp->rra_laddr >> 16);\r\nSONIC_WRITE(SONIC_EOBC, (SONIC_RBSIZE >> 1) - (lp->dma_bitmode ? 2 : 1));\r\nif (sonic_debug > 3)\r\nprintk("sonic_init: issuing RRRA command\n");\r\nSONIC_WRITE(SONIC_CMD, SONIC_CR_RRRA);\r\ni = 0;\r\nwhile (i++ < 100) {\r\nif (SONIC_READ(SONIC_CMD) & SONIC_CR_RRRA)\r\nbreak;\r\n}\r\nif (sonic_debug > 2)\r\nprintk("sonic_init: status=%x i=%d\n", SONIC_READ(SONIC_CMD), i);\r\nif (sonic_debug > 2)\r\nprintk("sonic_init: initialize receive descriptors\n");\r\nfor (i=0; i<SONIC_NUM_RDS; i++) {\r\nsonic_rda_put(dev, i, SONIC_RD_STATUS, 0);\r\nsonic_rda_put(dev, i, SONIC_RD_PKTLEN, 0);\r\nsonic_rda_put(dev, i, SONIC_RD_PKTPTR_L, 0);\r\nsonic_rda_put(dev, i, SONIC_RD_PKTPTR_H, 0);\r\nsonic_rda_put(dev, i, SONIC_RD_SEQNO, 0);\r\nsonic_rda_put(dev, i, SONIC_RD_IN_USE, 1);\r\nsonic_rda_put(dev, i, SONIC_RD_LINK,\r\nlp->rda_laddr +\r\n((i+1) * SIZEOF_SONIC_RD * SONIC_BUS_SCALE(lp->dma_bitmode)));\r\n}\r\nsonic_rda_put(dev, SONIC_NUM_RDS - 1, SONIC_RD_LINK,\r\n(lp->rda_laddr & 0xffff) | SONIC_EOL);\r\nlp->eol_rx = SONIC_NUM_RDS - 1;\r\nlp->cur_rx = 0;\r\nSONIC_WRITE(SONIC_URDA, lp->rda_laddr >> 16);\r\nSONIC_WRITE(SONIC_CRDA, lp->rda_laddr & 0xffff);\r\nif (sonic_debug > 2)\r\nprintk("sonic_init: initialize transmit descriptors\n");\r\nfor (i = 0; i < SONIC_NUM_TDS; i++) {\r\nsonic_tda_put(dev, i, SONIC_TD_STATUS, 0);\r\nsonic_tda_put(dev, i, SONIC_TD_CONFIG, 0);\r\nsonic_tda_put(dev, i, SONIC_TD_PKTSIZE, 0);\r\nsonic_tda_put(dev, i, SONIC_TD_FRAG_COUNT, 0);\r\nsonic_tda_put(dev, i, SONIC_TD_LINK,\r\n(lp->tda_laddr & 0xffff) +\r\n(i + 1) * SIZEOF_SONIC_TD * SONIC_BUS_SCALE(lp->dma_bitmode));\r\nlp->tx_skb[i] = NULL;\r\n}\r\nsonic_tda_put(dev, SONIC_NUM_TDS - 1, SONIC_TD_LINK,\r\n(lp->tda_laddr & 0xffff));\r\nSONIC_WRITE(SONIC_UTDA, lp->tda_laddr >> 16);\r\nSONIC_WRITE(SONIC_CTDA, lp->tda_laddr & 0xffff);\r\nlp->cur_tx = lp->next_tx = 0;\r\nlp->eol_tx = SONIC_NUM_TDS - 1;\r\nsonic_cda_put(dev, 0, SONIC_CD_CAP0, dev->dev_addr[1] << 8 | dev->dev_addr[0]);\r\nsonic_cda_put(dev, 0, SONIC_CD_CAP1, dev->dev_addr[3] << 8 | dev->dev_addr[2]);\r\nsonic_cda_put(dev, 0, SONIC_CD_CAP2, dev->dev_addr[5] << 8 | dev->dev_addr[4]);\r\nsonic_set_cam_enable(dev, 1);\r\nfor (i = 0; i < 16; i++)\r\nsonic_cda_put(dev, i, SONIC_CD_ENTRY_POINTER, i);\r\nSONIC_WRITE(SONIC_CDP, lp->cda_laddr & 0xffff);\r\nSONIC_WRITE(SONIC_CDC, 16);\r\nSONIC_WRITE(SONIC_CMD, SONIC_CR_LCAM);\r\ni = 0;\r\nwhile (i++ < 100) {\r\nif (SONIC_READ(SONIC_ISR) & SONIC_INT_LCD)\r\nbreak;\r\n}\r\nif (sonic_debug > 2) {\r\nprintk("sonic_init: CMD=%x, ISR=%x\n, i=%d",\r\nSONIC_READ(SONIC_CMD), SONIC_READ(SONIC_ISR), i);\r\n}\r\nSONIC_WRITE(SONIC_CMD, SONIC_CR_RXEN | SONIC_CR_STP);\r\nSONIC_WRITE(SONIC_RCR, SONIC_RCR_DEFAULT);\r\nSONIC_WRITE(SONIC_TCR, SONIC_TCR_DEFAULT);\r\nSONIC_WRITE(SONIC_ISR, 0x7fff);\r\nSONIC_WRITE(SONIC_IMR, SONIC_IMR_DEFAULT);\r\ncmd = SONIC_READ(SONIC_CMD);\r\nif ((cmd & SONIC_CR_RXEN) == 0 || (cmd & SONIC_CR_STP) == 0)\r\nprintk(KERN_ERR "sonic_init: failed, status=%x\n", cmd);\r\nif (sonic_debug > 2)\r\nprintk("sonic_init: new status=%x\n",\r\nSONIC_READ(SONIC_CMD));\r\nreturn 0;\r\n}
