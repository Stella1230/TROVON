static void __init\r\npciauto_setup_bars(struct pci_dev *dev, int bar_limit)\r\n{\r\nint bar_size;\r\nint bar, bar_nr;\r\nint *upper_limit;\r\nint found_mem64 = 0;\r\nfor (bar = PCI_BASE_ADDRESS_0, bar_nr = 0;\r\nbar <= bar_limit;\r\nbar+=4, bar_nr++)\r\n{\r\npci_write_config_dword(dev, bar, 0xffffffff);\r\npci_read_config_dword(dev, bar, &bar_size);\r\nif (!bar_size)\r\ncontinue;\r\nif (bar_size & PCI_BASE_ADDRESS_SPACE_IO)\r\n{\r\nbar_size &= PCI_BASE_ADDRESS_IO_MASK;\r\nupper_limit = &pciauto_upper_iospc;\r\nDBG("PCI Autoconfig: BAR %d, I/O, ", bar_nr);\r\n}\r\nelse\r\n{\r\nif ((bar_size & PCI_BASE_ADDRESS_MEM_TYPE_MASK) ==\r\nPCI_BASE_ADDRESS_MEM_TYPE_64)\r\nfound_mem64 = 1;\r\nbar_size &= PCI_BASE_ADDRESS_MEM_MASK;\r\nupper_limit = &pciauto_upper_memspc;\r\nDBG("PCI Autoconfig: BAR %d, Mem, ", bar_nr);\r\n}\r\n*upper_limit = (*upper_limit + bar_size) & bar_size;\r\npci_write_config_dword(dev, bar, *upper_limit);\r\nif (found_mem64)\r\npci_write_config_dword(dev, (bar+=4), 0x00000000);\r\nDBG("size=0x%x, address=0x%x\n", ~bar_size + 1, *upper_limit);\r\n}\r\n}\r\nstatic void __init\r\npciauto_setup_irq(struct pci_controller* pci_ctrl,struct pci_dev *dev,int devfn)\r\n{\r\nu8 pin;\r\nint irq = 0;\r\npci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);\r\nif (pin == 0 || pin > 4)\r\npin = 1;\r\nif (pci_ctrl->map_irq)\r\nirq = pci_ctrl->map_irq(dev, PCI_SLOT(devfn), pin);\r\nif (irq == -1)\r\nirq = 0;\r\nDBG("PCI Autoconfig: Interrupt %d, pin %d\n", irq, pin);\r\npci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);\r\n}\r\nstatic void __init\r\npciauto_prescan_setup_bridge(struct pci_dev *dev, int current_bus,\r\nint sub_bus, int *iosave, int *memsave)\r\n{\r\npci_write_config_byte(dev, PCI_PRIMARY_BUS, current_bus);\r\npci_write_config_byte(dev, PCI_SECONDARY_BUS, sub_bus + 1);\r\npci_write_config_byte(dev, PCI_SUBORDINATE_BUS, 0xff);\r\npciauto_upper_memspc &= ~(0x100000 - 1);\r\n*memsave = pciauto_upper_memspc;\r\npciauto_upper_iospc &= ~(0x1000 - 1);\r\n*iosave = pciauto_upper_iospc;\r\npci_write_config_word(dev, PCI_MEMORY_LIMIT,\r\n((pciauto_upper_memspc - 1) & 0xfff00000) >> 16);\r\npci_write_config_byte(dev, PCI_IO_LIMIT,\r\n((pciauto_upper_iospc - 1) & 0x0000f000) >> 8);\r\npci_write_config_word(dev, PCI_IO_LIMIT_UPPER16,\r\n((pciauto_upper_iospc - 1) & 0xffff0000) >> 16);\r\n}\r\nstatic void __init\r\npciauto_postscan_setup_bridge(struct pci_dev *dev, int current_bus, int sub_bus,\r\nint *iosave, int *memsave)\r\n{\r\nint cmdstat;\r\npci_write_config_byte(dev, PCI_SUBORDINATE_BUS, sub_bus);\r\npciauto_upper_memspc &= ~(0x100000 - 1);\r\nif (*memsave == pciauto_upper_memspc)\r\npciauto_upper_memspc -= 0x00100000;\r\npci_write_config_word(dev, PCI_MEMORY_BASE, pciauto_upper_memspc >> 16);\r\npci_write_config_word(dev, PCI_PREF_MEMORY_LIMIT,\r\n((pciauto_upper_memspc - 1) & 0xfff00000) >> 16);\r\npciauto_upper_memspc -= 0x100000;\r\npci_write_config_word(dev, PCI_PREF_MEMORY_BASE,\r\npciauto_upper_memspc >> 16);\r\npciauto_upper_iospc &= ~(0x1000 - 1);\r\nif (*iosave == pciauto_upper_iospc)\r\npciauto_upper_iospc -= 0x1000;\r\npci_write_config_byte(dev, PCI_IO_BASE,\r\n(pciauto_upper_iospc & 0x0000f000) >> 8);\r\npci_write_config_word(dev, PCI_IO_BASE_UPPER16,\r\npciauto_upper_iospc >> 16);\r\npci_read_config_dword(dev, PCI_COMMAND, &cmdstat);\r\npci_write_config_dword(dev, PCI_COMMAND,\r\ncmdstat |\r\nPCI_COMMAND_IO |\r\nPCI_COMMAND_MEMORY |\r\nPCI_COMMAND_MASTER);\r\n}\r\nint __init pciauto_bus_scan(struct pci_controller *pci_ctrl, int current_bus)\r\n{\r\nint sub_bus, pci_devfn, pci_class, cmdstat, found_multi=0;\r\nunsigned short vid;\r\nunsigned char header_type;\r\nstruct pci_dev *dev = &pciauto_dev;\r\npciauto_dev.bus = &pciauto_bus;\r\npciauto_dev.sysdata = pci_ctrl;\r\npciauto_bus.ops = pci_ctrl->ops;\r\nif (current_bus == pci_ctrl->first_busno)\r\n{\r\npciauto_upper_iospc = pci_ctrl->io_resource.end + 1;\r\npciauto_upper_memspc = pci_ctrl->mem_resources[0].end + 1;\r\n}\r\nsub_bus = current_bus;\r\nfor (pci_devfn = 0; pci_devfn < 0xff; pci_devfn++)\r\n{\r\nif ((current_bus == pci_ctrl->first_busno) && (pci_devfn == 0))\r\ncontinue;\r\nif (PCI_FUNC(pci_devfn) && !found_multi)\r\ncontinue;\r\npciauto_bus.number = current_bus;\r\npciauto_dev.devfn = pci_devfn;\r\nif (pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type))\r\ncontinue;\r\nif (!PCI_FUNC(pci_devfn))\r\nfound_multi = header_type & 0x80;\r\npci_read_config_word(dev, PCI_VENDOR_ID, &vid);\r\nif (vid == 0xffff || vid == 0x0000) {\r\nfound_multi = 0;\r\ncontinue;\r\n}\r\npci_read_config_dword(dev, PCI_CLASS_REVISION, &pci_class);\r\nif ((pci_class >> 16) == PCI_CLASS_BRIDGE_PCI) {\r\nint iosave, memsave;\r\nDBG("PCI Autoconfig: Found P2P bridge, device %d\n",\r\nPCI_SLOT(pci_devfn));\r\npciauto_setup_bars(dev, PCI_BASE_ADDRESS_1);\r\npciauto_prescan_setup_bridge(dev, current_bus, sub_bus,\r\n&iosave, &memsave);\r\nsub_bus = pciauto_bus_scan(pci_ctrl, sub_bus+1);\r\npciauto_postscan_setup_bridge(dev, current_bus, sub_bus,\r\n&iosave, &memsave);\r\npciauto_bus.number = current_bus;\r\ncontinue;\r\n}\r\n#if 0\r\nif ((pci_class >> 16) == PCI_CLASS_STORAGE_IDE) {\r\nunsigned char prg_iface;\r\npci_read_config_byte(dev, PCI_CLASS_PROG, &prg_iface);\r\nif (!(prg_iface & PCIAUTO_IDE_MODE_MASK)) {\r\nDBG("PCI Autoconfig: Skipping legacy mode "\r\n"IDE controller\n");\r\ncontinue;\r\n}\r\n}\r\n#endif\r\npci_read_config_dword(dev, PCI_COMMAND, &cmdstat);\r\npci_write_config_dword(dev, PCI_COMMAND,\r\ncmdstat |\r\nPCI_COMMAND_IO |\r\nPCI_COMMAND_MEMORY |\r\nPCI_COMMAND_MASTER);\r\npci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x80);\r\nDBG("PCI Autoconfig: Found Bus %d, Device %d, Function %d\n",\r\ncurrent_bus, PCI_SLOT(pci_devfn), PCI_FUNC(pci_devfn) );\r\npciauto_setup_bars(dev, PCI_BASE_ADDRESS_5);\r\npciauto_setup_irq(pci_ctrl, dev, pci_devfn);\r\n}\r\nreturn sub_bus;\r\n}
