static inline void\r\nwaitforCEC(struct IsdnCardState *cs, int jade, int reg)\r\n{\r\nint to = 50;\r\nint mask = (reg == jade_HDLC_XCMD ? jadeSTAR_XCEC : jadeSTAR_RCEC);\r\nwhile ((READJADE(cs, jade, jade_HDLC_STAR) & mask) && to) {\r\nudelay(1);\r\nto--;\r\n}\r\nif (!to)\r\nprintk(KERN_WARNING "HiSax: waitforCEC (jade) timeout\n");\r\n}\r\nstatic inline void\r\nwaitforXFW(struct IsdnCardState *cs, int jade)\r\n{\r\n}\r\nstatic inline void\r\nWriteJADECMDR(struct IsdnCardState *cs, int jade, int reg, u_char data)\r\n{\r\nwaitforCEC(cs, jade, reg);\r\nWRITEJADE(cs, jade, reg, data);\r\n}\r\nstatic void\r\njade_empty_fifo(struct BCState *bcs, int count)\r\n{\r\nu_char *ptr;\r\nstruct IsdnCardState *cs = bcs->cs;\r\nif ((cs->debug & L1_DEB_HSCX) && !(cs->debug & L1_DEB_HSCX_FIFO))\r\ndebugl1(cs, "jade_empty_fifo");\r\nif (bcs->hw.hscx.rcvidx + count > HSCX_BUFMAX) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "jade_empty_fifo: incoming packet too large");\r\nWriteJADECMDR(cs, bcs->hw.hscx.hscx, jade_HDLC_RCMD, jadeRCMD_RMC);\r\nbcs->hw.hscx.rcvidx = 0;\r\nreturn;\r\n}\r\nptr = bcs->hw.hscx.rcvbuf + bcs->hw.hscx.rcvidx;\r\nbcs->hw.hscx.rcvidx += count;\r\nREADJADEFIFO(cs, bcs->hw.hscx.hscx, ptr, count);\r\nWriteJADECMDR(cs, bcs->hw.hscx.hscx, jade_HDLC_RCMD, jadeRCMD_RMC);\r\nif (cs->debug & L1_DEB_HSCX_FIFO) {\r\nchar *t = bcs->blog;\r\nt += sprintf(t, "jade_empty_fifo %c cnt %d",\r\nbcs->hw.hscx.hscx ? 'B' : 'A', count);\r\nQuickHex(t, ptr, count);\r\ndebugl1(cs, bcs->blog);\r\n}\r\n}\r\nstatic void\r\njade_fill_fifo(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint more, count;\r\nint fifo_size = 32;\r\nu_char *ptr;\r\nif ((cs->debug & L1_DEB_HSCX) && !(cs->debug & L1_DEB_HSCX_FIFO))\r\ndebugl1(cs, "jade_fill_fifo");\r\nif (!bcs->tx_skb)\r\nreturn;\r\nif (bcs->tx_skb->len <= 0)\r\nreturn;\r\nmore = (bcs->mode == L1_MODE_TRANS) ? 1 : 0;\r\nif (bcs->tx_skb->len > fifo_size) {\r\nmore = !0;\r\ncount = fifo_size;\r\n} else\r\ncount = bcs->tx_skb->len;\r\nwaitforXFW(cs, bcs->hw.hscx.hscx);\r\nptr = bcs->tx_skb->data;\r\nskb_pull(bcs->tx_skb, count);\r\nbcs->tx_cnt -= count;\r\nbcs->hw.hscx.count += count;\r\nWRITEJADEFIFO(cs, bcs->hw.hscx.hscx, ptr, count);\r\nWriteJADECMDR(cs, bcs->hw.hscx.hscx, jade_HDLC_XCMD, more ? jadeXCMD_XF : (jadeXCMD_XF|jadeXCMD_XME));\r\nif (cs->debug & L1_DEB_HSCX_FIFO) {\r\nchar *t = bcs->blog;\r\nt += sprintf(t, "jade_fill_fifo %c cnt %d",\r\nbcs->hw.hscx.hscx ? 'B' : 'A', count);\r\nQuickHex(t, ptr, count);\r\ndebugl1(cs, bcs->blog);\r\n}\r\n}\r\nstatic void\r\njade_interrupt(struct IsdnCardState *cs, u_char val, u_char jade)\r\n{\r\nu_char r;\r\nstruct BCState *bcs = cs->bcs + jade;\r\nstruct sk_buff *skb;\r\nint fifo_size = 32;\r\nint count;\r\nint i_jade = (int) jade;\r\nif (!test_bit(BC_FLG_INIT, &bcs->Flag))\r\nreturn;\r\nif (val & 0x80) {\r\nr = READJADE(cs, i_jade, jade_HDLC_RSTA);\r\nif ((r & 0xf0) != 0xa0) {\r\nif (!(r & 0x80))\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "JADE %s invalid frame", (jade ? "B":"A"));\r\nif ((r & 0x40) && bcs->mode)\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "JADE %c RDO mode=%d", 'A'+jade, bcs->mode);\r\nif (!(r & 0x20))\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "JADE %c CRC error", 'A'+jade);\r\nWriteJADECMDR(cs, jade, jade_HDLC_RCMD, jadeRCMD_RMC);\r\n} else {\r\ncount = READJADE(cs, i_jade, jade_HDLC_RBCL) & 0x1F;\r\nif (count == 0)\r\ncount = fifo_size;\r\njade_empty_fifo(bcs, count);\r\nif ((count = bcs->hw.hscx.rcvidx - 1) > 0) {\r\nif (cs->debug & L1_DEB_HSCX_FIFO)\r\ndebugl1(cs, "HX Frame %d", count);\r\nif (!(skb = dev_alloc_skb(count)))\r\nprintk(KERN_WARNING "JADE %s receive out of memory\n", (jade ? "B":"A"));\r\nelse {\r\nmemcpy(skb_put(skb, count), bcs->hw.hscx.rcvbuf, count);\r\nskb_queue_tail(&bcs->rqueue, skb);\r\n}\r\n}\r\n}\r\nbcs->hw.hscx.rcvidx = 0;\r\nschedule_event(bcs, B_RCVBUFREADY);\r\n}\r\nif (val & 0x40) {\r\njade_empty_fifo(bcs, fifo_size);\r\nif (bcs->mode == L1_MODE_TRANS) {\r\nif (!(skb = dev_alloc_skb(fifo_size)))\r\nprintk(KERN_WARNING "HiSax: receive out of memory\n");\r\nelse {\r\nmemcpy(skb_put(skb, fifo_size), bcs->hw.hscx.rcvbuf, fifo_size);\r\nskb_queue_tail(&bcs->rqueue, skb);\r\n}\r\nbcs->hw.hscx.rcvidx = 0;\r\nschedule_event(bcs, B_RCVBUFREADY);\r\n}\r\n}\r\nif (val & 0x10) {\r\nif (bcs->tx_skb) {\r\nif (bcs->tx_skb->len) {\r\njade_fill_fifo(bcs);\r\nreturn;\r\n} else {\r\nif (test_bit(FLG_LLI_L1WAKEUP,&bcs->st->lli.flag) &&\r\n(PACKET_NOACK != bcs->tx_skb->pkt_type)) {\r\nu_long flags;\r\nspin_lock_irqsave(&bcs->aclock, flags);\r\nbcs->ackcnt += bcs->hw.hscx.count;\r\nspin_unlock_irqrestore(&bcs->aclock, flags);\r\nschedule_event(bcs, B_ACKPENDING);\r\n}\r\ndev_kfree_skb_irq(bcs->tx_skb);\r\nbcs->hw.hscx.count = 0;\r\nbcs->tx_skb = NULL;\r\n}\r\n}\r\nif ((bcs->tx_skb = skb_dequeue(&bcs->squeue))) {\r\nbcs->hw.hscx.count = 0;\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\njade_fill_fifo(bcs);\r\n} else {\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nschedule_event(bcs, B_XMTBUFREADY);\r\n}\r\n}\r\n}\r\nstatic inline void\r\njade_int_main(struct IsdnCardState *cs, u_char val, int jade)\r\n{\r\nstruct BCState *bcs;\r\nbcs = cs->bcs + jade;\r\nif (val & jadeISR_RFO) {\r\nval &= ~jadeISR_RFO;\r\n}\r\nif (val & jadeISR_XDU) {\r\nif (bcs->mode == 1)\r\njade_fill_fifo(bcs);\r\nelse {\r\nif (bcs->tx_skb) {\r\nskb_push(bcs->tx_skb, bcs->hw.hscx.count);\r\nbcs->tx_cnt += bcs->hw.hscx.count;\r\nbcs->hw.hscx.count = 0;\r\n}\r\nWriteJADECMDR(cs, bcs->hw.hscx.hscx, jade_HDLC_XCMD, jadeXCMD_XRES);\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "JADE %c EXIR %x Lost TX", 'A'+jade, val);\r\n}\r\n}\r\nif (val & (jadeISR_RME|jadeISR_RPF|jadeISR_XPR)) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "JADE %c interrupt %x", 'A'+jade, val);\r\njade_interrupt(cs, val, jade);\r\n}\r\n}
