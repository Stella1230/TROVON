static inline struct ks0127 *to_ks0127(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct ks0127, sd);\r\n}\r\nstatic void init_reg_defaults(void)\r\n{\r\nstatic int initialized;\r\nu8 *table = reg_defaults;\r\nif (initialized)\r\nreturn;\r\ninitialized = 1;\r\ntable[KS_CMDA] = 0x2c;\r\ntable[KS_CMDB] = 0x12;\r\ntable[KS_CMDC] = 0x00;\r\ntable[KS_CMDD] = 0x01;\r\ntable[KS_HAVB] = 0x00;\r\ntable[KS_HAVE] = 0x00;\r\ntable[KS_HS1B] = 0x10;\r\ntable[KS_HS1E] = 0x00;\r\ntable[KS_HS2B] = 0x00;\r\ntable[KS_HS2E] = 0x00;\r\ntable[KS_AGC] = 0x53;\r\ntable[KS_HXTRA] = 0x00;\r\ntable[KS_CDEM] = 0x00;\r\ntable[KS_PORTAB] = 0x0f;\r\ntable[KS_LUMA] = 0x01;\r\ntable[KS_CON] = 0x00;\r\ntable[KS_BRT] = 0x00;\r\ntable[KS_CHROMA] = 0x2a;\r\ntable[KS_CHROMB] = 0x90;\r\ntable[KS_DEMOD] = 0x00;\r\ntable[KS_SAT] = 0x00;\r\ntable[KS_HUE] = 0x00;\r\ntable[KS_VERTIA] = 0x00;\r\ntable[KS_VERTIB] = 0x12;\r\ntable[KS_VERTIC] = 0x0b;\r\ntable[KS_HSCLL] = 0x00;\r\ntable[KS_HSCLH] = 0x00;\r\ntable[KS_VSCLL] = 0x00;\r\ntable[KS_VSCLH] = 0x00;\r\ntable[KS_OFMTA] = 0x30;\r\ntable[KS_OFMTB] = 0x00;\r\ntable[KS_VBICTL] = 0x5d;\r\ntable[KS_CCDAT2] = 0x00;\r\ntable[KS_CCDAT1] = 0x00;\r\ntable[KS_VBIL30] = 0xa8;\r\ntable[KS_VBIL74] = 0xaa;\r\ntable[KS_VBIL118] = 0x2a;\r\ntable[KS_VBIL1512] = 0x00;\r\ntable[KS_TTFRAM] = 0x00;\r\ntable[KS_TESTA] = 0x00;\r\ntable[KS_UVOFFH] = 0x00;\r\ntable[KS_UVOFFL] = 0x00;\r\ntable[KS_UGAIN] = 0x00;\r\ntable[KS_VGAIN] = 0x00;\r\ntable[KS_VAVB] = 0x07;\r\ntable[KS_VAVE] = 0x00;\r\ntable[KS_CTRACK] = 0x00;\r\ntable[KS_POLCTL] = 0x41;\r\ntable[KS_REFCOD] = 0x80;\r\ntable[KS_INVALY] = 0x10;\r\ntable[KS_INVALU] = 0x80;\r\ntable[KS_INVALV] = 0x80;\r\ntable[KS_UNUSEY] = 0x10;\r\ntable[KS_UNUSEU] = 0x80;\r\ntable[KS_UNUSEV] = 0x80;\r\ntable[KS_USRSAV] = 0x00;\r\ntable[KS_USREAV] = 0x00;\r\ntable[KS_SHS1A] = 0x00;\r\ntable[KS_SHS1B] = 0x80;\r\ntable[KS_SHS1C] = 0x00;\r\ntable[KS_CMDE] = 0x00;\r\ntable[KS_VSDEL] = 0x00;\r\ntable[KS_CMDF] = 0x02;\r\n}\r\nstatic u8 ks0127_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nchar val = 0;\r\nstruct i2c_msg msgs[] = {\r\n{ client->addr, 0, sizeof(reg), &reg },\r\n{ client->addr, I2C_M_RD | I2C_M_NO_RD_ACK, sizeof(val), &val }\r\n};\r\nint ret;\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret != ARRAY_SIZE(msgs))\r\nv4l2_dbg(1, debug, sd, "read error\n");\r\nreturn val;\r\n}\r\nstatic void ks0127_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ks0127 *ks = to_ks0127(sd);\r\nchar msg[] = { reg, val };\r\nif (i2c_master_send(client, msg, sizeof(msg)) != sizeof(msg))\r\nv4l2_dbg(1, debug, sd, "write error\n");\r\nks->regs[reg] = val;\r\n}\r\nstatic void ks0127_and_or(struct v4l2_subdev *sd, u8 reg, u8 and_v, u8 or_v)\r\n{\r\nstruct ks0127 *ks = to_ks0127(sd);\r\nu8 val = ks->regs[reg];\r\nval = (val & and_v) | or_v;\r\nks0127_write(sd, reg, val);\r\n}\r\nstatic void ks0127_init(struct v4l2_subdev *sd)\r\n{\r\nstruct ks0127 *ks = to_ks0127(sd);\r\nu8 *table = reg_defaults;\r\nint i;\r\nks->ident = V4L2_IDENT_KS0127;\r\nv4l2_dbg(1, debug, sd, "reset\n");\r\nmsleep(1);\r\nfor (i = 1; i < 33; i++)\r\nks0127_write(sd, i, table[i]);\r\nfor (i = 35; i < 40; i++)\r\nks0127_write(sd, i, table[i]);\r\nfor (i = 41; i < 56; i++)\r\nks0127_write(sd, i, table[i]);\r\nfor (i = 58; i < 64; i++)\r\nks0127_write(sd, i, table[i]);\r\nif ((ks0127_read(sd, KS_STAT) & 0x80) == 0) {\r\nks->ident = V4L2_IDENT_KS0122S;\r\nv4l2_dbg(1, debug, sd, "ks0122s found\n");\r\nreturn;\r\n}\r\nswitch (ks0127_read(sd, KS_CMDE) & 0x0f) {\r\ncase 0:\r\nv4l2_dbg(1, debug, sd, "ks0127 found\n");\r\nbreak;\r\ncase 9:\r\nks->ident = V4L2_IDENT_KS0127B;\r\nv4l2_dbg(1, debug, sd, "ks0127B Revision A found\n");\r\nbreak;\r\ndefault:\r\nv4l2_dbg(1, debug, sd, "unknown revision\n");\r\nbreak;\r\n}\r\n}\r\nstatic int ks0127_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct ks0127 *ks = to_ks0127(sd);\r\nswitch (input) {\r\ncase KS_INPUT_COMPOSITE_1:\r\ncase KS_INPUT_COMPOSITE_2:\r\ncase KS_INPUT_COMPOSITE_3:\r\ncase KS_INPUT_COMPOSITE_4:\r\ncase KS_INPUT_COMPOSITE_5:\r\ncase KS_INPUT_COMPOSITE_6:\r\nv4l2_dbg(1, debug, sd,\r\n"s_routing %d: Composite\n", input);\r\nks0127_and_or(sd, KS_CMDA, 0xfc, 0x00);\r\nks0127_and_or(sd, KS_CMDA, ~0x40, 0x00);\r\nks0127_and_or(sd, KS_CMDB, 0xb0, input);\r\nks0127_and_or(sd, KS_CMDC, 0x70, 0x0a);\r\nks0127_and_or(sd, KS_CMDD, 0x03, 0x00);\r\nks0127_and_or(sd, KS_CTRACK, 0xcf, 0x00);\r\nks0127_and_or(sd, KS_LUMA, 0x00,\r\n(reg_defaults[KS_LUMA])|0x0c);\r\nks0127_and_or(sd, KS_VERTIA, 0x08, 0x81);\r\nks0127_and_or(sd, KS_VERTIC, 0x0f, 0x90);\r\nks0127_and_or(sd, KS_CHROMB, 0x0f, 0x90);\r\nks0127_write(sd, KS_UGAIN, reg_defaults[KS_UGAIN]);\r\nks0127_write(sd, KS_VGAIN, reg_defaults[KS_VGAIN]);\r\nks0127_write(sd, KS_UVOFFH, reg_defaults[KS_UVOFFH]);\r\nks0127_write(sd, KS_UVOFFL, reg_defaults[KS_UVOFFL]);\r\nbreak;\r\ncase KS_INPUT_SVIDEO_1:\r\ncase KS_INPUT_SVIDEO_2:\r\ncase KS_INPUT_SVIDEO_3:\r\nv4l2_dbg(1, debug, sd,\r\n"s_routing %d: S-Video\n", input);\r\nks0127_and_or(sd, KS_CMDA, 0xfc, 0x00);\r\nks0127_and_or(sd, KS_CMDA, ~0x40, 0x00);\r\nks0127_and_or(sd, KS_CMDB, 0xb0, input);\r\nks0127_and_or(sd, KS_CMDC, 0x70, 0x0a);\r\nks0127_and_or(sd, KS_CMDD, 0x03, 0x00);\r\nks0127_and_or(sd, KS_CTRACK, 0xcf, 0x00);\r\nks0127_and_or(sd, KS_LUMA, 0x00,\r\nreg_defaults[KS_LUMA]);\r\nks0127_and_or(sd, KS_VERTIA, 0x08,\r\n(reg_defaults[KS_VERTIA]&0xf0)|0x01);\r\nks0127_and_or(sd, KS_VERTIC, 0x0f,\r\nreg_defaults[KS_VERTIC]&0xf0);\r\nks0127_and_or(sd, KS_CHROMB, 0x0f,\r\nreg_defaults[KS_CHROMB]&0xf0);\r\nks0127_write(sd, KS_UGAIN, reg_defaults[KS_UGAIN]);\r\nks0127_write(sd, KS_VGAIN, reg_defaults[KS_VGAIN]);\r\nks0127_write(sd, KS_UVOFFH, reg_defaults[KS_UVOFFH]);\r\nks0127_write(sd, KS_UVOFFL, reg_defaults[KS_UVOFFL]);\r\nbreak;\r\ncase KS_INPUT_YUV656:\r\nv4l2_dbg(1, debug, sd, "s_routing 15: YUV656\n");\r\nif (ks->norm & V4L2_STD_525_60)\r\nks0127_and_or(sd, KS_CMDA, 0xfc, 0x03);\r\nelse\r\nks0127_and_or(sd, KS_CMDA, 0xfc, 0x02);\r\nks0127_and_or(sd, KS_CMDA, 0xff, 0x40);\r\nks0127_and_or(sd, KS_CMDB, 0xb0, (input | 0x40));\r\nks0127_and_or(sd, KS_CMDC, 0x70, 0x87);\r\nks0127_and_or(sd, KS_CMDD, 0x03, 0x08);\r\nks0127_and_or(sd, KS_CTRACK, 0xcf, 0x30);\r\nks0127_and_or(sd, KS_LUMA, 0x00, 0x71);\r\nks0127_and_or(sd, KS_VERTIC, 0x0f,\r\nreg_defaults[KS_VERTIC]&0xf0);\r\nks0127_and_or(sd, KS_VERTIA, 0x08, 0x81);\r\nks0127_and_or(sd, KS_CHROMB, 0x0f,\r\nreg_defaults[KS_CHROMB]&0xf0);\r\nks0127_and_or(sd, KS_CON, 0x00, 0x00);\r\nks0127_and_or(sd, KS_BRT, 0x00, 32);\r\nks0127_and_or(sd, KS_SAT, 0x00, 0xe8);\r\nks0127_and_or(sd, KS_HUE, 0x00, 0);\r\nks0127_and_or(sd, KS_UGAIN, 0x00, 238);\r\nks0127_and_or(sd, KS_VGAIN, 0x00, 0x00);\r\nks0127_and_or(sd, KS_UVOFFH, 0x00, 0x4f);\r\nks0127_and_or(sd, KS_UVOFFL, 0x00, 0x00);\r\nbreak;\r\ndefault:\r\nv4l2_dbg(1, debug, sd,\r\n"s_routing: Unknown input %d\n", input);\r\nbreak;\r\n}\r\nks0127_write(sd, KS_DEMOD, reg_defaults[KS_DEMOD]);\r\nreturn 0;\r\n}\r\nstatic int ks0127_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct ks0127 *ks = to_ks0127(sd);\r\nks0127_and_or(sd, KS_DEMOD, 0xf0, 0x00);\r\nks->norm = std;\r\nif (std & V4L2_STD_NTSC) {\r\nv4l2_dbg(1, debug, sd,\r\n"s_std: NTSC_M\n");\r\nks0127_and_or(sd, KS_CHROMA, 0x9f, 0x20);\r\n} else if (std & V4L2_STD_PAL_N) {\r\nv4l2_dbg(1, debug, sd,\r\n"s_std: NTSC_N (fixme)\n");\r\nks0127_and_or(sd, KS_CHROMA, 0x9f, 0x40);\r\n} else if (std & V4L2_STD_PAL) {\r\nv4l2_dbg(1, debug, sd,\r\n"s_std: PAL_N\n");\r\nks0127_and_or(sd, KS_CHROMA, 0x9f, 0x20);\r\n} else if (std & V4L2_STD_PAL_M) {\r\nv4l2_dbg(1, debug, sd,\r\n"s_std: PAL_M (fixme)\n");\r\nks0127_and_or(sd, KS_CHROMA, 0x9f, 0x40);\r\n} else if (std & V4L2_STD_SECAM) {\r\nv4l2_dbg(1, debug, sd,\r\n"s_std: SECAM\n");\r\nks0127_and_or(sd, KS_CHROMA, 0xdf, 0x20);\r\nks0127_and_or(sd, KS_DEMOD, 0xf0, 0x00);\r\nschedule_timeout_interruptible(HZ/10+1);\r\nif (!(ks0127_read(sd, KS_DEMOD) & 0x40))\r\nks0127_and_or(sd, KS_DEMOD, 0xf0, 0x0f);\r\n} else {\r\nv4l2_dbg(1, debug, sd, "s_std: Unknown norm %llx\n",\r\n(unsigned long long)std);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ks0127_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nv4l2_dbg(1, debug, sd, "s_stream(%d)\n", enable);\r\nif (enable) {\r\nks0127_and_or(sd, KS_OFMTA, 0xcf, 0x30);\r\nks0127_and_or(sd, KS_CDEM, 0x7f, 0x00);\r\n} else {\r\nks0127_and_or(sd, KS_OFMTA, 0xcf, 0x00);\r\nks0127_and_or(sd, KS_CDEM, 0x7f, 0x80);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ks0127_status(struct v4l2_subdev *sd, u32 *pstatus, v4l2_std_id *pstd)\r\n{\r\nint stat = V4L2_IN_ST_NO_SIGNAL;\r\nu8 status;\r\nv4l2_std_id std = V4L2_STD_ALL;\r\nstatus = ks0127_read(sd, KS_STAT);\r\nif (!(status & 0x20))\r\nstat = 0;\r\nif (!(status & 0x01))\r\nstat |= V4L2_IN_ST_NO_COLOR;\r\nif ((status & 0x08))\r\nstd = V4L2_STD_PAL;\r\nelse\r\nstd = V4L2_STD_NTSC;\r\nif (pstd)\r\n*pstd = std;\r\nif (pstatus)\r\n*pstatus = stat;\r\nreturn 0;\r\n}\r\nstatic int ks0127_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\r\n{\r\nv4l2_dbg(1, debug, sd, "querystd\n");\r\nreturn ks0127_status(sd, NULL, std);\r\n}\r\nstatic int ks0127_g_input_status(struct v4l2_subdev *sd, u32 *status)\r\n{\r\nv4l2_dbg(1, debug, sd, "g_input_status\n");\r\nreturn ks0127_status(sd, status, NULL);\r\n}\r\nstatic int ks0127_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ks0127 *ks = to_ks0127(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, ks->ident, 0);\r\n}\r\nstatic int ks0127_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct ks0127 *ks;\r\nstruct v4l2_subdev *sd;\r\nv4l_info(client, "%s chip found @ 0x%x (%s)\n",\r\nclient->addr == (I2C_KS0127_ADDON >> 1) ? "addon" : "on-board",\r\nclient->addr << 1, client->adapter->name);\r\nks = kzalloc(sizeof(*ks), GFP_KERNEL);\r\nif (ks == NULL)\r\nreturn -ENOMEM;\r\nsd = &ks->sd;\r\nv4l2_i2c_subdev_init(sd, client, &ks0127_ops);\r\ninit_reg_defaults();\r\nks0127_write(sd, KS_CMDA, 0x2c);\r\nmdelay(10);\r\nks0127_init(sd);\r\nreturn 0;\r\n}\r\nstatic int ks0127_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nks0127_write(sd, KS_OFMTA, 0x20);\r\nks0127_write(sd, KS_CMDA, 0x2c | 0x80);\r\nkfree(to_ks0127(sd));\r\nreturn 0;\r\n}\r\nstatic __init int init_ks0127(void)\r\n{\r\nreturn i2c_add_driver(&ks0127_driver);\r\n}\r\nstatic __exit void exit_ks0127(void)\r\n{\r\ni2c_del_driver(&ks0127_driver);\r\n}
