static void fsmc_select_chip(struct mtd_info *mtd, int chipnr)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct fsmc_nand_data *host;\r\nhost = container_of(mtd, struct fsmc_nand_data, mtd);\r\nswitch (chipnr) {\r\ncase -1:\r\nchip->cmd_ctrl(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);\r\nbreak;\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nif (host->select_chip)\r\nhost->select_chip(chipnr,\r\nchip->options & NAND_BUSWIDTH_16);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void fsmc_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct fsmc_nand_data *host = container_of(mtd,\r\nstruct fsmc_nand_data, mtd);\r\nstruct fsmc_regs *regs = host->regs_va;\r\nunsigned int bank = host->bank;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nif (ctrl & NAND_CLE) {\r\nthis->IO_ADDR_R = (void __iomem *)host->cmd_va;\r\nthis->IO_ADDR_W = (void __iomem *)host->cmd_va;\r\n} else if (ctrl & NAND_ALE) {\r\nthis->IO_ADDR_R = (void __iomem *)host->addr_va;\r\nthis->IO_ADDR_W = (void __iomem *)host->addr_va;\r\n} else {\r\nthis->IO_ADDR_R = (void __iomem *)host->data_va;\r\nthis->IO_ADDR_W = (void __iomem *)host->data_va;\r\n}\r\nif (ctrl & NAND_NCE) {\r\nwritel(readl(&regs->bank_regs[bank].pc) | FSMC_ENABLE,\r\n&regs->bank_regs[bank].pc);\r\n} else {\r\nwritel(readl(&regs->bank_regs[bank].pc) & ~FSMC_ENABLE,\r\n&regs->bank_regs[bank].pc);\r\n}\r\n}\r\nmb();\r\nif (cmd != NAND_CMD_NONE)\r\nwriteb(cmd, this->IO_ADDR_W);\r\n}\r\nstatic void __init fsmc_nand_setup(struct fsmc_regs *regs, uint32_t bank,\r\nuint32_t busw)\r\n{\r\nuint32_t value = FSMC_DEVTYPE_NAND | FSMC_ENABLE | FSMC_WAITON;\r\nif (busw)\r\nwritel(value | FSMC_DEVWID_16, &regs->bank_regs[bank].pc);\r\nelse\r\nwritel(value | FSMC_DEVWID_8, &regs->bank_regs[bank].pc);\r\nwritel(readl(&regs->bank_regs[bank].pc) | FSMC_TCLR_1 | FSMC_TAR_1,\r\n&regs->bank_regs[bank].pc);\r\nwritel(FSMC_THIZ_1 | FSMC_THOLD_4 | FSMC_TWAIT_6 | FSMC_TSET_0,\r\n&regs->bank_regs[bank].comm);\r\nwritel(FSMC_THIZ_1 | FSMC_THOLD_4 | FSMC_TWAIT_6 | FSMC_TSET_0,\r\n&regs->bank_regs[bank].attrib);\r\n}\r\nstatic void fsmc_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nstruct fsmc_nand_data *host = container_of(mtd,\r\nstruct fsmc_nand_data, mtd);\r\nstruct fsmc_regs *regs = host->regs_va;\r\nuint32_t bank = host->bank;\r\nwritel(readl(&regs->bank_regs[bank].pc) & ~FSMC_ECCPLEN_256,\r\n&regs->bank_regs[bank].pc);\r\nwritel(readl(&regs->bank_regs[bank].pc) & ~FSMC_ECCEN,\r\n&regs->bank_regs[bank].pc);\r\nwritel(readl(&regs->bank_regs[bank].pc) | FSMC_ECCEN,\r\n&regs->bank_regs[bank].pc);\r\n}\r\nstatic int fsmc_read_hwecc_ecc4(struct mtd_info *mtd, const uint8_t *data,\r\nuint8_t *ecc)\r\n{\r\nstruct fsmc_nand_data *host = container_of(mtd,\r\nstruct fsmc_nand_data, mtd);\r\nstruct fsmc_regs *regs = host->regs_va;\r\nuint32_t bank = host->bank;\r\nuint32_t ecc_tmp;\r\nunsigned long deadline = jiffies + FSMC_BUSY_WAIT_TIMEOUT;\r\ndo {\r\nif (readl(&regs->bank_regs[bank].sts) & FSMC_CODE_RDY)\r\nbreak;\r\nelse\r\ncond_resched();\r\n} while (!time_after_eq(jiffies, deadline));\r\necc_tmp = readl(&regs->bank_regs[bank].ecc1);\r\necc[0] = (uint8_t) (ecc_tmp >> 0);\r\necc[1] = (uint8_t) (ecc_tmp >> 8);\r\necc[2] = (uint8_t) (ecc_tmp >> 16);\r\necc[3] = (uint8_t) (ecc_tmp >> 24);\r\necc_tmp = readl(&regs->bank_regs[bank].ecc2);\r\necc[4] = (uint8_t) (ecc_tmp >> 0);\r\necc[5] = (uint8_t) (ecc_tmp >> 8);\r\necc[6] = (uint8_t) (ecc_tmp >> 16);\r\necc[7] = (uint8_t) (ecc_tmp >> 24);\r\necc_tmp = readl(&regs->bank_regs[bank].ecc3);\r\necc[8] = (uint8_t) (ecc_tmp >> 0);\r\necc[9] = (uint8_t) (ecc_tmp >> 8);\r\necc[10] = (uint8_t) (ecc_tmp >> 16);\r\necc[11] = (uint8_t) (ecc_tmp >> 24);\r\necc_tmp = readl(&regs->bank_regs[bank].sts);\r\necc[12] = (uint8_t) (ecc_tmp >> 16);\r\nreturn 0;\r\n}\r\nstatic int fsmc_read_hwecc_ecc1(struct mtd_info *mtd, const uint8_t *data,\r\nuint8_t *ecc)\r\n{\r\nstruct fsmc_nand_data *host = container_of(mtd,\r\nstruct fsmc_nand_data, mtd);\r\nstruct fsmc_regs *regs = host->regs_va;\r\nuint32_t bank = host->bank;\r\nuint32_t ecc_tmp;\r\necc_tmp = readl(&regs->bank_regs[bank].ecc1);\r\necc[0] = (uint8_t) (ecc_tmp >> 0);\r\necc[1] = (uint8_t) (ecc_tmp >> 8);\r\necc[2] = (uint8_t) (ecc_tmp >> 16);\r\nreturn 0;\r\n}\r\nstatic int fsmc_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int page)\r\n{\r\nstruct fsmc_nand_data *host = container_of(mtd,\r\nstruct fsmc_nand_data, mtd);\r\nstruct fsmc_eccplace *ecc_place = host->ecc_place;\r\nint i, j, s, stat, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nuint8_t *p = buf;\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nuint8_t *ecc_code = chip->buffers->ecccode;\r\nint off, len, group = 0;\r\nuint16_t ecc_oob[7];\r\nuint8_t *oob = (uint8_t *)&ecc_oob[0];\r\nfor (i = 0, s = 0; s < eccsteps; s++, i += eccbytes, p += eccsize) {\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, s * eccsize, page);\r\nchip->ecc.hwctl(mtd, NAND_ECC_READ);\r\nchip->read_buf(mtd, p, eccsize);\r\nfor (j = 0; j < eccbytes;) {\r\noff = ecc_place->eccplace[group].offset;\r\nlen = ecc_place->eccplace[group].length;\r\ngroup++;\r\nlen = roundup(len, 2);\r\nchip->cmdfunc(mtd, NAND_CMD_READOOB, off, page);\r\nchip->read_buf(mtd, oob + j, len);\r\nj += len;\r\n}\r\nmemcpy(&ecc_code[i], oob, 13);\r\nchip->ecc.calculate(mtd, p, &ecc_calc[i]);\r\nstat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);\r\nif (stat < 0)\r\nmtd->ecc_stats.failed++;\r\nelse\r\nmtd->ecc_stats.corrected += stat;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsmc_correct_data(struct mtd_info *mtd, uint8_t *dat,\r\nuint8_t *read_ecc, uint8_t *calc_ecc)\r\n{\r\nstruct fsmc_nand_data *host = container_of(mtd,\r\nstruct fsmc_nand_data, mtd);\r\nstruct fsmc_regs *regs = host->regs_va;\r\nunsigned int bank = host->bank;\r\nuint16_t err_idx[8];\r\nuint64_t ecc_data[2];\r\nuint32_t num_err, i;\r\nmemcpy(ecc_data, calc_ecc, 13);\r\nfor (i = 0; i < 8; i++) {\r\nif (i == 4) {\r\nerr_idx[4] = ((ecc_data[1] & 0x1) << 12) | ecc_data[0];\r\necc_data[1] >>= 1;\r\ncontinue;\r\n}\r\nerr_idx[i] = (ecc_data[i/4] & 0x1FFF);\r\necc_data[i/4] >>= 13;\r\n}\r\nnum_err = (readl(&regs->bank_regs[bank].sts) >> 10) & 0xF;\r\nif (num_err == 0xF)\r\nreturn -EBADMSG;\r\ni = 0;\r\nwhile (num_err--) {\r\nchange_bit(0, (unsigned long *)&err_idx[i]);\r\nchange_bit(1, (unsigned long *)&err_idx[i]);\r\nif (err_idx[i] <= 512 * 8) {\r\nchange_bit(err_idx[i], (unsigned long *)dat);\r\ni++;\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic int __init fsmc_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct fsmc_nand_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct fsmc_nand_data *host;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *nand;\r\nstruct fsmc_regs *regs;\r\nstruct resource *res;\r\nint ret = 0;\r\nu32 pid;\r\nint i;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "platform data is NULL\n");\r\nreturn -EINVAL;\r\n}\r\nhost = kzalloc(sizeof(*host), GFP_KERNEL);\r\nif (!host) {\r\ndev_err(&pdev->dev, "failed to allocate device structure\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "nand_data");\r\nif (!res) {\r\nret = -EIO;\r\ngoto err_probe1;\r\n}\r\nhost->resdata = request_mem_region(res->start, resource_size(res),\r\npdev->name);\r\nif (!host->resdata) {\r\nret = -EIO;\r\ngoto err_probe1;\r\n}\r\nhost->data_va = ioremap(res->start, resource_size(res));\r\nif (!host->data_va) {\r\nret = -EIO;\r\ngoto err_probe1;\r\n}\r\nhost->resaddr = request_mem_region(res->start + PLAT_NAND_ALE,\r\nresource_size(res), pdev->name);\r\nif (!host->resaddr) {\r\nret = -EIO;\r\ngoto err_probe1;\r\n}\r\nhost->addr_va = ioremap(res->start + PLAT_NAND_ALE, resource_size(res));\r\nif (!host->addr_va) {\r\nret = -EIO;\r\ngoto err_probe1;\r\n}\r\nhost->rescmd = request_mem_region(res->start + PLAT_NAND_CLE,\r\nresource_size(res), pdev->name);\r\nif (!host->rescmd) {\r\nret = -EIO;\r\ngoto err_probe1;\r\n}\r\nhost->cmd_va = ioremap(res->start + PLAT_NAND_CLE, resource_size(res));\r\nif (!host->cmd_va) {\r\nret = -EIO;\r\ngoto err_probe1;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "fsmc_regs");\r\nif (!res) {\r\nret = -EIO;\r\ngoto err_probe1;\r\n}\r\nhost->resregs = request_mem_region(res->start, resource_size(res),\r\npdev->name);\r\nif (!host->resregs) {\r\nret = -EIO;\r\ngoto err_probe1;\r\n}\r\nhost->regs_va = ioremap(res->start, resource_size(res));\r\nif (!host->regs_va) {\r\nret = -EIO;\r\ngoto err_probe1;\r\n}\r\nhost->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(host->clk)) {\r\ndev_err(&pdev->dev, "failed to fetch block clock\n");\r\nret = PTR_ERR(host->clk);\r\nhost->clk = NULL;\r\ngoto err_probe1;\r\n}\r\nret = clk_enable(host->clk);\r\nif (ret)\r\ngoto err_probe1;\r\nfor (pid = 0, i = 0; i < 4; i++)\r\npid |= (readl(host->regs_va + resource_size(res) - 0x20 + 4 * i) & 255) << (i * 8);\r\nhost->pid = pid;\r\ndev_info(&pdev->dev, "FSMC device partno %03x, manufacturer %02x, "\r\n"revision %02x, config %02x\n",\r\nAMBA_PART_BITS(pid), AMBA_MANF_BITS(pid),\r\nAMBA_REV_BITS(pid), AMBA_CONFIG_BITS(pid));\r\nhost->bank = pdata->bank;\r\nhost->select_chip = pdata->select_bank;\r\nregs = host->regs_va;\r\nmtd = &host->mtd;\r\nnand = &host->nand;\r\nmtd->priv = nand;\r\nnand->priv = host;\r\nhost->mtd.owner = THIS_MODULE;\r\nnand->IO_ADDR_R = host->data_va;\r\nnand->IO_ADDR_W = host->data_va;\r\nnand->cmd_ctrl = fsmc_cmd_ctrl;\r\nnand->chip_delay = 30;\r\nnand->ecc.mode = NAND_ECC_HW;\r\nnand->ecc.hwctl = fsmc_enable_hwecc;\r\nnand->ecc.size = 512;\r\nnand->options = pdata->options;\r\nnand->select_chip = fsmc_select_chip;\r\nif (pdata->width == FSMC_NAND_BW16)\r\nnand->options |= NAND_BUSWIDTH_16;\r\nfsmc_nand_setup(regs, host->bank, nand->options & NAND_BUSWIDTH_16);\r\nif (AMBA_REV_BITS(host->pid) >= 8) {\r\nnand->ecc.read_page = fsmc_read_page_hwecc;\r\nnand->ecc.calculate = fsmc_read_hwecc_ecc4;\r\nnand->ecc.correct = fsmc_correct_data;\r\nnand->ecc.bytes = 13;\r\n} else {\r\nnand->ecc.calculate = fsmc_read_hwecc_ecc1;\r\nnand->ecc.correct = nand_correct_data;\r\nnand->ecc.bytes = 3;\r\n}\r\nif (nand_scan_ident(&host->mtd, 1, NULL)) {\r\nret = -ENXIO;\r\ndev_err(&pdev->dev, "No NAND Device found!\n");\r\ngoto err_probe;\r\n}\r\nif (AMBA_REV_BITS(host->pid) >= 8) {\r\nif (host->mtd.writesize == 512) {\r\nnand->ecc.layout = &fsmc_ecc4_sp_layout;\r\nhost->ecc_place = &fsmc_ecc4_sp_place;\r\n} else {\r\nnand->ecc.layout = &fsmc_ecc4_lp_layout;\r\nhost->ecc_place = &fsmc_ecc4_lp_place;\r\n}\r\n} else {\r\nnand->ecc.layout = &fsmc_ecc1_layout;\r\n}\r\nif (nand_scan_tail(&host->mtd)) {\r\nret = -ENXIO;\r\ngoto err_probe;\r\n}\r\nhost->mtd.name = "nand";\r\nret = mtd_device_parse_register(&host->mtd, NULL, 0,\r\nhost->mtd.size <= 0x04000000 ?\r\npartition_info_16KB_blk :\r\npartition_info_128KB_blk,\r\nhost->mtd.size <= 0x04000000 ?\r\nARRAY_SIZE(partition_info_16KB_blk) :\r\nARRAY_SIZE(partition_info_128KB_blk));\r\nif (ret)\r\ngoto err_probe;\r\nplatform_set_drvdata(pdev, host);\r\ndev_info(&pdev->dev, "FSMC NAND driver registration successful\n");\r\nreturn 0;\r\nerr_probe:\r\nclk_disable(host->clk);\r\nerr_probe1:\r\nif (host->clk)\r\nclk_put(host->clk);\r\nif (host->regs_va)\r\niounmap(host->regs_va);\r\nif (host->resregs)\r\nrelease_mem_region(host->resregs->start,\r\nresource_size(host->resregs));\r\nif (host->cmd_va)\r\niounmap(host->cmd_va);\r\nif (host->rescmd)\r\nrelease_mem_region(host->rescmd->start,\r\nresource_size(host->rescmd));\r\nif (host->addr_va)\r\niounmap(host->addr_va);\r\nif (host->resaddr)\r\nrelease_mem_region(host->resaddr->start,\r\nresource_size(host->resaddr));\r\nif (host->data_va)\r\niounmap(host->data_va);\r\nif (host->resdata)\r\nrelease_mem_region(host->resdata->start,\r\nresource_size(host->resdata));\r\nkfree(host);\r\nreturn ret;\r\n}\r\nstatic int fsmc_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct fsmc_nand_data *host = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nif (host) {\r\nnand_release(&host->mtd);\r\nclk_disable(host->clk);\r\nclk_put(host->clk);\r\niounmap(host->regs_va);\r\nrelease_mem_region(host->resregs->start,\r\nresource_size(host->resregs));\r\niounmap(host->cmd_va);\r\nrelease_mem_region(host->rescmd->start,\r\nresource_size(host->rescmd));\r\niounmap(host->addr_va);\r\nrelease_mem_region(host->resaddr->start,\r\nresource_size(host->resaddr));\r\niounmap(host->data_va);\r\nrelease_mem_region(host->resdata->start,\r\nresource_size(host->resdata));\r\nkfree(host);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsmc_nand_suspend(struct device *dev)\r\n{\r\nstruct fsmc_nand_data *host = dev_get_drvdata(dev);\r\nif (host)\r\nclk_disable(host->clk);\r\nreturn 0;\r\n}\r\nstatic int fsmc_nand_resume(struct device *dev)\r\n{\r\nstruct fsmc_nand_data *host = dev_get_drvdata(dev);\r\nif (host)\r\nclk_enable(host->clk);\r\nreturn 0;\r\n}\r\nstatic int __init fsmc_nand_init(void)\r\n{\r\nreturn platform_driver_probe(&fsmc_nand_driver,\r\nfsmc_nand_probe);\r\n}\r\nstatic void __exit fsmc_nand_exit(void)\r\n{\r\nplatform_driver_unregister(&fsmc_nand_driver);\r\n}
