static struct ib_ah *iwch_ah_create(struct ib_pd *pd,\r\nstruct ib_ah_attr *ah_attr)\r\n{\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nstatic int iwch_ah_destroy(struct ib_ah *ah)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int iwch_multicast_attach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int iwch_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int iwch_process_mad(struct ib_device *ibdev,\r\nint mad_flags,\r\nu8 port_num,\r\nstruct ib_wc *in_wc,\r\nstruct ib_grh *in_grh,\r\nstruct ib_mad *in_mad, struct ib_mad *out_mad)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int iwch_dealloc_ucontext(struct ib_ucontext *context)\r\n{\r\nstruct iwch_dev *rhp = to_iwch_dev(context->device);\r\nstruct iwch_ucontext *ucontext = to_iwch_ucontext(context);\r\nstruct iwch_mm_entry *mm, *tmp;\r\nPDBG("%s context %p\n", __func__, context);\r\nlist_for_each_entry_safe(mm, tmp, &ucontext->mmaps, entry)\r\nkfree(mm);\r\ncxio_release_ucontext(&rhp->rdev, &ucontext->uctx);\r\nkfree(ucontext);\r\nreturn 0;\r\n}\r\nstatic struct ib_ucontext *iwch_alloc_ucontext(struct ib_device *ibdev,\r\nstruct ib_udata *udata)\r\n{\r\nstruct iwch_ucontext *context;\r\nstruct iwch_dev *rhp = to_iwch_dev(ibdev);\r\nPDBG("%s ibdev %p\n", __func__, ibdev);\r\ncontext = kzalloc(sizeof(*context), GFP_KERNEL);\r\nif (!context)\r\nreturn ERR_PTR(-ENOMEM);\r\ncxio_init_ucontext(&rhp->rdev, &context->uctx);\r\nINIT_LIST_HEAD(&context->mmaps);\r\nspin_lock_init(&context->mmap_lock);\r\nreturn &context->ibucontext;\r\n}\r\nstatic int iwch_destroy_cq(struct ib_cq *ib_cq)\r\n{\r\nstruct iwch_cq *chp;\r\nPDBG("%s ib_cq %p\n", __func__, ib_cq);\r\nchp = to_iwch_cq(ib_cq);\r\nremove_handle(chp->rhp, &chp->rhp->cqidr, chp->cq.cqid);\r\natomic_dec(&chp->refcnt);\r\nwait_event(chp->wait, !atomic_read(&chp->refcnt));\r\ncxio_destroy_cq(&chp->rhp->rdev, &chp->cq);\r\nkfree(chp);\r\nreturn 0;\r\n}\r\nstatic struct ib_cq *iwch_create_cq(struct ib_device *ibdev, int entries, int vector,\r\nstruct ib_ucontext *ib_context,\r\nstruct ib_udata *udata)\r\n{\r\nstruct iwch_dev *rhp;\r\nstruct iwch_cq *chp;\r\nstruct iwch_create_cq_resp uresp;\r\nstruct iwch_create_cq_req ureq;\r\nstruct iwch_ucontext *ucontext = NULL;\r\nstatic int warned;\r\nsize_t resplen;\r\nPDBG("%s ib_dev %p entries %d\n", __func__, ibdev, entries);\r\nrhp = to_iwch_dev(ibdev);\r\nchp = kzalloc(sizeof(*chp), GFP_KERNEL);\r\nif (!chp)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (ib_context) {\r\nucontext = to_iwch_ucontext(ib_context);\r\nif (!t3a_device(rhp)) {\r\nif (ib_copy_from_udata(&ureq, udata, sizeof (ureq))) {\r\nkfree(chp);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nchp->user_rptr_addr = (u32 __user *)(unsigned long)ureq.user_rptr_addr;\r\n}\r\n}\r\nif (t3a_device(rhp)) {\r\nentries += 16;\r\n}\r\nentries = roundup_pow_of_two(entries);\r\nchp->cq.size_log2 = ilog2(entries);\r\nif (cxio_create_cq(&rhp->rdev, &chp->cq, !ucontext)) {\r\nkfree(chp);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nchp->rhp = rhp;\r\nchp->ibcq.cqe = 1 << chp->cq.size_log2;\r\nspin_lock_init(&chp->lock);\r\nspin_lock_init(&chp->comp_handler_lock);\r\natomic_set(&chp->refcnt, 1);\r\ninit_waitqueue_head(&chp->wait);\r\nif (insert_handle(rhp, &rhp->cqidr, chp, chp->cq.cqid)) {\r\ncxio_destroy_cq(&chp->rhp->rdev, &chp->cq);\r\nkfree(chp);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nif (ucontext) {\r\nstruct iwch_mm_entry *mm;\r\nmm = kmalloc(sizeof *mm, GFP_KERNEL);\r\nif (!mm) {\r\niwch_destroy_cq(&chp->ibcq);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nuresp.cqid = chp->cq.cqid;\r\nuresp.size_log2 = chp->cq.size_log2;\r\nspin_lock(&ucontext->mmap_lock);\r\nuresp.key = ucontext->key;\r\nucontext->key += PAGE_SIZE;\r\nspin_unlock(&ucontext->mmap_lock);\r\nmm->key = uresp.key;\r\nmm->addr = virt_to_phys(chp->cq.queue);\r\nif (udata->outlen < sizeof uresp) {\r\nif (!warned++)\r\nprintk(KERN_WARNING MOD "Warning - "\r\n"downlevel libcxgb3 (non-fatal).\n");\r\nmm->len = PAGE_ALIGN((1UL << uresp.size_log2) *\r\nsizeof(struct t3_cqe));\r\nresplen = sizeof(struct iwch_create_cq_resp_v0);\r\n} else {\r\nmm->len = PAGE_ALIGN(((1UL << uresp.size_log2) + 1) *\r\nsizeof(struct t3_cqe));\r\nuresp.memsize = mm->len;\r\nresplen = sizeof uresp;\r\n}\r\nif (ib_copy_to_udata(udata, &uresp, resplen)) {\r\nkfree(mm);\r\niwch_destroy_cq(&chp->ibcq);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\ninsert_mmap(ucontext, mm);\r\n}\r\nPDBG("created cqid 0x%0x chp %p size 0x%0x, dma_addr 0x%0llx\n",\r\nchp->cq.cqid, chp, (1 << chp->cq.size_log2),\r\n(unsigned long long) chp->cq.dma_addr);\r\nreturn &chp->ibcq;\r\n}\r\nstatic int iwch_resize_cq(struct ib_cq *cq, int cqe, struct ib_udata *udata)\r\n{\r\n#ifdef notyet\r\nstruct iwch_cq *chp = to_iwch_cq(cq);\r\nstruct t3_cq oldcq, newcq;\r\nint ret;\r\nPDBG("%s ib_cq %p cqe %d\n", __func__, cq, cqe);\r\nif (cqe <= cq->cqe)\r\nreturn 0;\r\ncqe = roundup_pow_of_two(cqe+1);\r\nnewcq.size_log2 = ilog2(cqe);\r\nif (cqe < Q_COUNT(chp->cq.rptr, chp->cq.wptr)) {\r\nreturn -ENOMEM;\r\n}\r\nret = iwch_quiesce_qps(chp);\r\nif (ret) {\r\nreturn ret;\r\n}\r\nret = cxio_create_cq(&chp->rhp->rdev, &newcq);\r\nif (ret) {\r\nreturn ret;\r\n}\r\nmemcpy(newcq.queue, chp->cq.queue, (1 << chp->cq.size_log2) *\r\nsizeof(struct t3_cqe));\r\noldcq = chp->cq;\r\nchp->cq = newcq;\r\nchp->cq.cqid = oldcq.cqid;\r\nret = cxio_resize_cq(&chp->rhp->rdev, &chp->cq);\r\nif (ret) {\r\nchp->cq = oldcq;\r\nreturn ret;\r\n}\r\nchp->ibcq.cqe = (1<<chp->cq.size_log2) - 1;\r\noldcq.cqid = newcq.cqid;\r\nret = cxio_destroy_cq(&chp->rhp->rdev, &oldcq);\r\nif (ret) {\r\nprintk(KERN_ERR MOD "%s - cxio_destroy_cq failed %d\n",\r\n__func__, ret);\r\n}\r\nret = iwch_resume_qps(chp);\r\nreturn ret;\r\n#else\r\nreturn -ENOSYS;\r\n#endif\r\n}\r\nstatic int iwch_arm_cq(struct ib_cq *ibcq, enum ib_cq_notify_flags flags)\r\n{\r\nstruct iwch_dev *rhp;\r\nstruct iwch_cq *chp;\r\nenum t3_cq_opcode cq_op;\r\nint err;\r\nunsigned long flag;\r\nu32 rptr;\r\nchp = to_iwch_cq(ibcq);\r\nrhp = chp->rhp;\r\nif ((flags & IB_CQ_SOLICITED_MASK) == IB_CQ_SOLICITED)\r\ncq_op = CQ_ARM_SE;\r\nelse\r\ncq_op = CQ_ARM_AN;\r\nif (chp->user_rptr_addr) {\r\nif (get_user(rptr, chp->user_rptr_addr))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&chp->lock, flag);\r\nchp->cq.rptr = rptr;\r\n} else\r\nspin_lock_irqsave(&chp->lock, flag);\r\nPDBG("%s rptr 0x%x\n", __func__, chp->cq.rptr);\r\nerr = cxio_hal_cq_op(&rhp->rdev, &chp->cq, cq_op, 0);\r\nspin_unlock_irqrestore(&chp->lock, flag);\r\nif (err < 0)\r\nprintk(KERN_ERR MOD "Error %d rearming CQID 0x%x\n", err,\r\nchp->cq.cqid);\r\nif (err > 0 && !(flags & IB_CQ_REPORT_MISSED_EVENTS))\r\nerr = 0;\r\nreturn err;\r\n}\r\nstatic int iwch_mmap(struct ib_ucontext *context, struct vm_area_struct *vma)\r\n{\r\nint len = vma->vm_end - vma->vm_start;\r\nu32 key = vma->vm_pgoff << PAGE_SHIFT;\r\nstruct cxio_rdev *rdev_p;\r\nint ret = 0;\r\nstruct iwch_mm_entry *mm;\r\nstruct iwch_ucontext *ucontext;\r\nu64 addr;\r\nPDBG("%s pgoff 0x%lx key 0x%x len %d\n", __func__, vma->vm_pgoff,\r\nkey, len);\r\nif (vma->vm_start & (PAGE_SIZE-1)) {\r\nreturn -EINVAL;\r\n}\r\nrdev_p = &(to_iwch_dev(context->device)->rdev);\r\nucontext = to_iwch_ucontext(context);\r\nmm = remove_mmap(ucontext, key, len);\r\nif (!mm)\r\nreturn -EINVAL;\r\naddr = mm->addr;\r\nkfree(mm);\r\nif ((addr >= rdev_p->rnic_info.udbell_physbase) &&\r\n(addr < (rdev_p->rnic_info.udbell_physbase +\r\nrdev_p->rnic_info.udbell_len))) {\r\nif (vma->vm_flags & VM_READ) {\r\nreturn -EPERM;\r\n}\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nvma->vm_flags |= VM_DONTCOPY | VM_DONTEXPAND;\r\nvma->vm_flags &= ~VM_MAYREAD;\r\nret = io_remap_pfn_range(vma, vma->vm_start,\r\naddr >> PAGE_SHIFT,\r\nlen, vma->vm_page_prot);\r\n} else {\r\nret = remap_pfn_range(vma, vma->vm_start,\r\naddr >> PAGE_SHIFT,\r\nlen, vma->vm_page_prot);\r\n}\r\nreturn ret;\r\n}\r\nstatic int iwch_deallocate_pd(struct ib_pd *pd)\r\n{\r\nstruct iwch_dev *rhp;\r\nstruct iwch_pd *php;\r\nphp = to_iwch_pd(pd);\r\nrhp = php->rhp;\r\nPDBG("%s ibpd %p pdid 0x%x\n", __func__, pd, php->pdid);\r\ncxio_hal_put_pdid(rhp->rdev.rscp, php->pdid);\r\nkfree(php);\r\nreturn 0;\r\n}\r\nstatic struct ib_pd *iwch_allocate_pd(struct ib_device *ibdev,\r\nstruct ib_ucontext *context,\r\nstruct ib_udata *udata)\r\n{\r\nstruct iwch_pd *php;\r\nu32 pdid;\r\nstruct iwch_dev *rhp;\r\nPDBG("%s ibdev %p\n", __func__, ibdev);\r\nrhp = (struct iwch_dev *) ibdev;\r\npdid = cxio_hal_get_pdid(rhp->rdev.rscp);\r\nif (!pdid)\r\nreturn ERR_PTR(-EINVAL);\r\nphp = kzalloc(sizeof(*php), GFP_KERNEL);\r\nif (!php) {\r\ncxio_hal_put_pdid(rhp->rdev.rscp, pdid);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nphp->pdid = pdid;\r\nphp->rhp = rhp;\r\nif (context) {\r\nif (ib_copy_to_udata(udata, &php->pdid, sizeof (__u32))) {\r\niwch_deallocate_pd(&php->ibpd);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\n}\r\nPDBG("%s pdid 0x%0x ptr 0x%p\n", __func__, pdid, php);\r\nreturn &php->ibpd;\r\n}\r\nstatic int iwch_dereg_mr(struct ib_mr *ib_mr)\r\n{\r\nstruct iwch_dev *rhp;\r\nstruct iwch_mr *mhp;\r\nu32 mmid;\r\nPDBG("%s ib_mr %p\n", __func__, ib_mr);\r\nif (atomic_read(&ib_mr->usecnt))\r\nreturn -EINVAL;\r\nmhp = to_iwch_mr(ib_mr);\r\nrhp = mhp->rhp;\r\nmmid = mhp->attr.stag >> 8;\r\ncxio_dereg_mem(&rhp->rdev, mhp->attr.stag, mhp->attr.pbl_size,\r\nmhp->attr.pbl_addr);\r\niwch_free_pbl(mhp);\r\nremove_handle(rhp, &rhp->mmidr, mmid);\r\nif (mhp->kva)\r\nkfree((void *) (unsigned long) mhp->kva);\r\nif (mhp->umem)\r\nib_umem_release(mhp->umem);\r\nPDBG("%s mmid 0x%x ptr %p\n", __func__, mmid, mhp);\r\nkfree(mhp);\r\nreturn 0;\r\n}\r\nstatic struct ib_mr *iwch_register_phys_mem(struct ib_pd *pd,\r\nstruct ib_phys_buf *buffer_list,\r\nint num_phys_buf,\r\nint acc,\r\nu64 *iova_start)\r\n{\r\n__be64 *page_list;\r\nint shift;\r\nu64 total_size;\r\nint npages;\r\nstruct iwch_dev *rhp;\r\nstruct iwch_pd *php;\r\nstruct iwch_mr *mhp;\r\nint ret;\r\nPDBG("%s ib_pd %p\n", __func__, pd);\r\nphp = to_iwch_pd(pd);\r\nrhp = php->rhp;\r\nmhp = kzalloc(sizeof(*mhp), GFP_KERNEL);\r\nif (!mhp)\r\nreturn ERR_PTR(-ENOMEM);\r\nmhp->rhp = rhp;\r\nif ((*iova_start & ~PAGE_MASK) != (buffer_list[0].addr & ~PAGE_MASK)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (num_phys_buf > 1 &&\r\n((buffer_list[0].addr + buffer_list[0].size) & ~PAGE_MASK)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = build_phys_page_list(buffer_list, num_phys_buf, iova_start,\r\n&total_size, &npages, &shift, &page_list);\r\nif (ret)\r\ngoto err;\r\nret = iwch_alloc_pbl(mhp, npages);\r\nif (ret) {\r\nkfree(page_list);\r\ngoto err_pbl;\r\n}\r\nret = iwch_write_pbl(mhp, page_list, npages, 0);\r\nkfree(page_list);\r\nif (ret)\r\ngoto err_pbl;\r\nmhp->attr.pdid = php->pdid;\r\nmhp->attr.zbva = 0;\r\nmhp->attr.perms = iwch_ib_to_tpt_access(acc);\r\nmhp->attr.va_fbo = *iova_start;\r\nmhp->attr.page_size = shift - 12;\r\nmhp->attr.len = (u32) total_size;\r\nmhp->attr.pbl_size = npages;\r\nret = iwch_register_mem(rhp, php, mhp, shift);\r\nif (ret)\r\ngoto err_pbl;\r\nreturn &mhp->ibmr;\r\nerr_pbl:\r\niwch_free_pbl(mhp);\r\nerr:\r\nkfree(mhp);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int iwch_reregister_phys_mem(struct ib_mr *mr,\r\nint mr_rereg_mask,\r\nstruct ib_pd *pd,\r\nstruct ib_phys_buf *buffer_list,\r\nint num_phys_buf,\r\nint acc, u64 * iova_start)\r\n{\r\nstruct iwch_mr mh, *mhp;\r\nstruct iwch_pd *php;\r\nstruct iwch_dev *rhp;\r\n__be64 *page_list = NULL;\r\nint shift = 0;\r\nu64 total_size;\r\nint npages;\r\nint ret;\r\nPDBG("%s ib_mr %p ib_pd %p\n", __func__, mr, pd);\r\nif (atomic_read(&mr->usecnt))\r\nreturn -EINVAL;\r\nmhp = to_iwch_mr(mr);\r\nrhp = mhp->rhp;\r\nphp = to_iwch_pd(mr->pd);\r\nif (rhp != php->rhp)\r\nreturn -EINVAL;\r\nmemcpy(&mh, mhp, sizeof *mhp);\r\nif (mr_rereg_mask & IB_MR_REREG_PD)\r\nphp = to_iwch_pd(pd);\r\nif (mr_rereg_mask & IB_MR_REREG_ACCESS)\r\nmh.attr.perms = iwch_ib_to_tpt_access(acc);\r\nif (mr_rereg_mask & IB_MR_REREG_TRANS) {\r\nret = build_phys_page_list(buffer_list, num_phys_buf,\r\niova_start,\r\n&total_size, &npages,\r\n&shift, &page_list);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = iwch_reregister_mem(rhp, php, &mh, shift, npages);\r\nkfree(page_list);\r\nif (ret) {\r\nreturn ret;\r\n}\r\nif (mr_rereg_mask & IB_MR_REREG_PD)\r\nmhp->attr.pdid = php->pdid;\r\nif (mr_rereg_mask & IB_MR_REREG_ACCESS)\r\nmhp->attr.perms = iwch_ib_to_tpt_access(acc);\r\nif (mr_rereg_mask & IB_MR_REREG_TRANS) {\r\nmhp->attr.zbva = 0;\r\nmhp->attr.va_fbo = *iova_start;\r\nmhp->attr.page_size = shift - 12;\r\nmhp->attr.len = (u32) total_size;\r\nmhp->attr.pbl_size = npages;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct ib_mr *iwch_reg_user_mr(struct ib_pd *pd, u64 start, u64 length,\r\nu64 virt, int acc, struct ib_udata *udata)\r\n{\r\n__be64 *pages;\r\nint shift, n, len;\r\nint i, j, k;\r\nint err = 0;\r\nstruct ib_umem_chunk *chunk;\r\nstruct iwch_dev *rhp;\r\nstruct iwch_pd *php;\r\nstruct iwch_mr *mhp;\r\nstruct iwch_reg_user_mr_resp uresp;\r\nPDBG("%s ib_pd %p\n", __func__, pd);\r\nphp = to_iwch_pd(pd);\r\nrhp = php->rhp;\r\nmhp = kzalloc(sizeof(*mhp), GFP_KERNEL);\r\nif (!mhp)\r\nreturn ERR_PTR(-ENOMEM);\r\nmhp->rhp = rhp;\r\nmhp->umem = ib_umem_get(pd->uobject->context, start, length, acc, 0);\r\nif (IS_ERR(mhp->umem)) {\r\nerr = PTR_ERR(mhp->umem);\r\nkfree(mhp);\r\nreturn ERR_PTR(err);\r\n}\r\nshift = ffs(mhp->umem->page_size) - 1;\r\nn = 0;\r\nlist_for_each_entry(chunk, &mhp->umem->chunk_list, list)\r\nn += chunk->nents;\r\nerr = iwch_alloc_pbl(mhp, n);\r\nif (err)\r\ngoto err;\r\npages = (__be64 *) __get_free_page(GFP_KERNEL);\r\nif (!pages) {\r\nerr = -ENOMEM;\r\ngoto err_pbl;\r\n}\r\ni = n = 0;\r\nlist_for_each_entry(chunk, &mhp->umem->chunk_list, list)\r\nfor (j = 0; j < chunk->nmap; ++j) {\r\nlen = sg_dma_len(&chunk->page_list[j]) >> shift;\r\nfor (k = 0; k < len; ++k) {\r\npages[i++] = cpu_to_be64(sg_dma_address(\r\n&chunk->page_list[j]) +\r\nmhp->umem->page_size * k);\r\nif (i == PAGE_SIZE / sizeof *pages) {\r\nerr = iwch_write_pbl(mhp, pages, i, n);\r\nif (err)\r\ngoto pbl_done;\r\nn += i;\r\ni = 0;\r\n}\r\n}\r\n}\r\nif (i)\r\nerr = iwch_write_pbl(mhp, pages, i, n);\r\npbl_done:\r\nfree_page((unsigned long) pages);\r\nif (err)\r\ngoto err_pbl;\r\nmhp->attr.pdid = php->pdid;\r\nmhp->attr.zbva = 0;\r\nmhp->attr.perms = iwch_ib_to_tpt_access(acc);\r\nmhp->attr.va_fbo = virt;\r\nmhp->attr.page_size = shift - 12;\r\nmhp->attr.len = (u32) length;\r\nerr = iwch_register_mem(rhp, php, mhp, shift);\r\nif (err)\r\ngoto err_pbl;\r\nif (udata && !t3a_device(rhp)) {\r\nuresp.pbl_addr = (mhp->attr.pbl_addr -\r\nrhp->rdev.rnic_info.pbl_base) >> 3;\r\nPDBG("%s user resp pbl_addr 0x%x\n", __func__,\r\nuresp.pbl_addr);\r\nif (ib_copy_to_udata(udata, &uresp, sizeof (uresp))) {\r\niwch_dereg_mr(&mhp->ibmr);\r\nerr = -EFAULT;\r\ngoto err;\r\n}\r\n}\r\nreturn &mhp->ibmr;\r\nerr_pbl:\r\niwch_free_pbl(mhp);\r\nerr:\r\nib_umem_release(mhp->umem);\r\nkfree(mhp);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic struct ib_mr *iwch_get_dma_mr(struct ib_pd *pd, int acc)\r\n{\r\nstruct ib_phys_buf bl;\r\nu64 kva;\r\nstruct ib_mr *ibmr;\r\nPDBG("%s ib_pd %p\n", __func__, pd);\r\nbl.size = 0xffffffff;\r\nbl.addr = 0;\r\nkva = 0;\r\nibmr = iwch_register_phys_mem(pd, &bl, 1, acc, &kva);\r\nreturn ibmr;\r\n}\r\nstatic struct ib_mw *iwch_alloc_mw(struct ib_pd *pd)\r\n{\r\nstruct iwch_dev *rhp;\r\nstruct iwch_pd *php;\r\nstruct iwch_mw *mhp;\r\nu32 mmid;\r\nu32 stag = 0;\r\nint ret;\r\nphp = to_iwch_pd(pd);\r\nrhp = php->rhp;\r\nmhp = kzalloc(sizeof(*mhp), GFP_KERNEL);\r\nif (!mhp)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = cxio_allocate_window(&rhp->rdev, &stag, php->pdid);\r\nif (ret) {\r\nkfree(mhp);\r\nreturn ERR_PTR(ret);\r\n}\r\nmhp->rhp = rhp;\r\nmhp->attr.pdid = php->pdid;\r\nmhp->attr.type = TPT_MW;\r\nmhp->attr.stag = stag;\r\nmmid = (stag) >> 8;\r\nmhp->ibmw.rkey = stag;\r\nif (insert_handle(rhp, &rhp->mmidr, mhp, mmid)) {\r\ncxio_deallocate_window(&rhp->rdev, mhp->attr.stag);\r\nkfree(mhp);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nPDBG("%s mmid 0x%x mhp %p stag 0x%x\n", __func__, mmid, mhp, stag);\r\nreturn &(mhp->ibmw);\r\n}\r\nstatic int iwch_dealloc_mw(struct ib_mw *mw)\r\n{\r\nstruct iwch_dev *rhp;\r\nstruct iwch_mw *mhp;\r\nu32 mmid;\r\nmhp = to_iwch_mw(mw);\r\nrhp = mhp->rhp;\r\nmmid = (mw->rkey) >> 8;\r\ncxio_deallocate_window(&rhp->rdev, mhp->attr.stag);\r\nremove_handle(rhp, &rhp->mmidr, mmid);\r\nkfree(mhp);\r\nPDBG("%s ib_mw %p mmid 0x%x ptr %p\n", __func__, mw, mmid, mhp);\r\nreturn 0;\r\n}\r\nstatic struct ib_mr *iwch_alloc_fast_reg_mr(struct ib_pd *pd, int pbl_depth)\r\n{\r\nstruct iwch_dev *rhp;\r\nstruct iwch_pd *php;\r\nstruct iwch_mr *mhp;\r\nu32 mmid;\r\nu32 stag = 0;\r\nint ret = 0;\r\nphp = to_iwch_pd(pd);\r\nrhp = php->rhp;\r\nmhp = kzalloc(sizeof(*mhp), GFP_KERNEL);\r\nif (!mhp)\r\ngoto err;\r\nmhp->rhp = rhp;\r\nret = iwch_alloc_pbl(mhp, pbl_depth);\r\nif (ret)\r\ngoto err1;\r\nmhp->attr.pbl_size = pbl_depth;\r\nret = cxio_allocate_stag(&rhp->rdev, &stag, php->pdid,\r\nmhp->attr.pbl_size, mhp->attr.pbl_addr);\r\nif (ret)\r\ngoto err2;\r\nmhp->attr.pdid = php->pdid;\r\nmhp->attr.type = TPT_NON_SHARED_MR;\r\nmhp->attr.stag = stag;\r\nmhp->attr.state = 1;\r\nmmid = (stag) >> 8;\r\nmhp->ibmr.rkey = mhp->ibmr.lkey = stag;\r\nif (insert_handle(rhp, &rhp->mmidr, mhp, mmid))\r\ngoto err3;\r\nPDBG("%s mmid 0x%x mhp %p stag 0x%x\n", __func__, mmid, mhp, stag);\r\nreturn &(mhp->ibmr);\r\nerr3:\r\ncxio_dereg_mem(&rhp->rdev, stag, mhp->attr.pbl_size,\r\nmhp->attr.pbl_addr);\r\nerr2:\r\niwch_free_pbl(mhp);\r\nerr1:\r\nkfree(mhp);\r\nerr:\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic struct ib_fast_reg_page_list *iwch_alloc_fastreg_pbl(\r\nstruct ib_device *device,\r\nint page_list_len)\r\n{\r\nstruct ib_fast_reg_page_list *page_list;\r\npage_list = kmalloc(sizeof *page_list + page_list_len * sizeof(u64),\r\nGFP_KERNEL);\r\nif (!page_list)\r\nreturn ERR_PTR(-ENOMEM);\r\npage_list->page_list = (u64 *)(page_list + 1);\r\npage_list->max_page_list_len = page_list_len;\r\nreturn page_list;\r\n}\r\nstatic void iwch_free_fastreg_pbl(struct ib_fast_reg_page_list *page_list)\r\n{\r\nkfree(page_list);\r\n}\r\nstatic int iwch_destroy_qp(struct ib_qp *ib_qp)\r\n{\r\nstruct iwch_dev *rhp;\r\nstruct iwch_qp *qhp;\r\nstruct iwch_qp_attributes attrs;\r\nstruct iwch_ucontext *ucontext;\r\nqhp = to_iwch_qp(ib_qp);\r\nrhp = qhp->rhp;\r\nattrs.next_state = IWCH_QP_STATE_ERROR;\r\niwch_modify_qp(rhp, qhp, IWCH_QP_ATTR_NEXT_STATE, &attrs, 0);\r\nwait_event(qhp->wait, !qhp->ep);\r\nremove_handle(rhp, &rhp->qpidr, qhp->wq.qpid);\r\natomic_dec(&qhp->refcnt);\r\nwait_event(qhp->wait, !atomic_read(&qhp->refcnt));\r\nucontext = ib_qp->uobject ? to_iwch_ucontext(ib_qp->uobject->context)\r\n: NULL;\r\ncxio_destroy_qp(&rhp->rdev, &qhp->wq,\r\nucontext ? &ucontext->uctx : &rhp->rdev.uctx);\r\nPDBG("%s ib_qp %p qpid 0x%0x qhp %p\n", __func__,\r\nib_qp, qhp->wq.qpid, qhp);\r\nkfree(qhp);\r\nreturn 0;\r\n}\r\nstatic struct ib_qp *iwch_create_qp(struct ib_pd *pd,\r\nstruct ib_qp_init_attr *attrs,\r\nstruct ib_udata *udata)\r\n{\r\nstruct iwch_dev *rhp;\r\nstruct iwch_qp *qhp;\r\nstruct iwch_pd *php;\r\nstruct iwch_cq *schp;\r\nstruct iwch_cq *rchp;\r\nstruct iwch_create_qp_resp uresp;\r\nint wqsize, sqsize, rqsize;\r\nstruct iwch_ucontext *ucontext;\r\nPDBG("%s ib_pd %p\n", __func__, pd);\r\nif (attrs->qp_type != IB_QPT_RC)\r\nreturn ERR_PTR(-EINVAL);\r\nphp = to_iwch_pd(pd);\r\nrhp = php->rhp;\r\nschp = get_chp(rhp, ((struct iwch_cq *) attrs->send_cq)->cq.cqid);\r\nrchp = get_chp(rhp, ((struct iwch_cq *) attrs->recv_cq)->cq.cqid);\r\nif (!schp || !rchp)\r\nreturn ERR_PTR(-EINVAL);\r\nrqsize = roundup_pow_of_two(attrs->cap.max_recv_wr);\r\nif (rqsize == attrs->cap.max_recv_wr)\r\nrqsize = roundup_pow_of_two(attrs->cap.max_recv_wr+1);\r\nif (rqsize < 16)\r\nrqsize = 16;\r\nif (rqsize > T3_MAX_RQ_SIZE)\r\nreturn ERR_PTR(-EINVAL);\r\nif (attrs->cap.max_inline_data > T3_MAX_INLINE)\r\nreturn ERR_PTR(-EINVAL);\r\nsqsize = roundup_pow_of_two(attrs->cap.max_send_wr);\r\nwqsize = roundup_pow_of_two(rqsize + sqsize);\r\nucontext = pd->uobject ? to_iwch_ucontext(pd->uobject->context) : NULL;\r\nif (!ucontext && wqsize < (rqsize + (2 * sqsize)))\r\nwqsize = roundup_pow_of_two(rqsize +\r\nroundup_pow_of_two(attrs->cap.max_send_wr * 2));\r\nPDBG("%s wqsize %d sqsize %d rqsize %d\n", __func__,\r\nwqsize, sqsize, rqsize);\r\nqhp = kzalloc(sizeof(*qhp), GFP_KERNEL);\r\nif (!qhp)\r\nreturn ERR_PTR(-ENOMEM);\r\nqhp->wq.size_log2 = ilog2(wqsize);\r\nqhp->wq.rq_size_log2 = ilog2(rqsize);\r\nqhp->wq.sq_size_log2 = ilog2(sqsize);\r\nif (cxio_create_qp(&rhp->rdev, !udata, &qhp->wq,\r\nucontext ? &ucontext->uctx : &rhp->rdev.uctx)) {\r\nkfree(qhp);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nattrs->cap.max_recv_wr = rqsize - 1;\r\nattrs->cap.max_send_wr = sqsize;\r\nattrs->cap.max_inline_data = T3_MAX_INLINE;\r\nqhp->rhp = rhp;\r\nqhp->attr.pd = php->pdid;\r\nqhp->attr.scq = ((struct iwch_cq *) attrs->send_cq)->cq.cqid;\r\nqhp->attr.rcq = ((struct iwch_cq *) attrs->recv_cq)->cq.cqid;\r\nqhp->attr.sq_num_entries = attrs->cap.max_send_wr;\r\nqhp->attr.rq_num_entries = attrs->cap.max_recv_wr;\r\nqhp->attr.sq_max_sges = attrs->cap.max_send_sge;\r\nqhp->attr.sq_max_sges_rdma_write = attrs->cap.max_send_sge;\r\nqhp->attr.rq_max_sges = attrs->cap.max_recv_sge;\r\nqhp->attr.state = IWCH_QP_STATE_IDLE;\r\nqhp->attr.next_state = IWCH_QP_STATE_IDLE;\r\nqhp->attr.enable_rdma_read = 1;\r\nqhp->attr.enable_rdma_write = 1;\r\nqhp->attr.enable_bind = 1;\r\nqhp->attr.max_ord = 1;\r\nqhp->attr.max_ird = 1;\r\nspin_lock_init(&qhp->lock);\r\ninit_waitqueue_head(&qhp->wait);\r\natomic_set(&qhp->refcnt, 1);\r\nif (insert_handle(rhp, &rhp->qpidr, qhp, qhp->wq.qpid)) {\r\ncxio_destroy_qp(&rhp->rdev, &qhp->wq,\r\nucontext ? &ucontext->uctx : &rhp->rdev.uctx);\r\nkfree(qhp);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nif (udata) {\r\nstruct iwch_mm_entry *mm1, *mm2;\r\nmm1 = kmalloc(sizeof *mm1, GFP_KERNEL);\r\nif (!mm1) {\r\niwch_destroy_qp(&qhp->ibqp);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nmm2 = kmalloc(sizeof *mm2, GFP_KERNEL);\r\nif (!mm2) {\r\nkfree(mm1);\r\niwch_destroy_qp(&qhp->ibqp);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nuresp.qpid = qhp->wq.qpid;\r\nuresp.size_log2 = qhp->wq.size_log2;\r\nuresp.sq_size_log2 = qhp->wq.sq_size_log2;\r\nuresp.rq_size_log2 = qhp->wq.rq_size_log2;\r\nspin_lock(&ucontext->mmap_lock);\r\nuresp.key = ucontext->key;\r\nucontext->key += PAGE_SIZE;\r\nuresp.db_key = ucontext->key;\r\nucontext->key += PAGE_SIZE;\r\nspin_unlock(&ucontext->mmap_lock);\r\nif (ib_copy_to_udata(udata, &uresp, sizeof (uresp))) {\r\nkfree(mm1);\r\nkfree(mm2);\r\niwch_destroy_qp(&qhp->ibqp);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nmm1->key = uresp.key;\r\nmm1->addr = virt_to_phys(qhp->wq.queue);\r\nmm1->len = PAGE_ALIGN(wqsize * sizeof (union t3_wr));\r\ninsert_mmap(ucontext, mm1);\r\nmm2->key = uresp.db_key;\r\nmm2->addr = qhp->wq.udb & PAGE_MASK;\r\nmm2->len = PAGE_SIZE;\r\ninsert_mmap(ucontext, mm2);\r\n}\r\nqhp->ibqp.qp_num = qhp->wq.qpid;\r\ninit_timer(&(qhp->timer));\r\nPDBG("%s sq_num_entries %d, rq_num_entries %d "\r\n"qpid 0x%0x qhp %p dma_addr 0x%llx size %d rq_addr 0x%x\n",\r\n__func__, qhp->attr.sq_num_entries, qhp->attr.rq_num_entries,\r\nqhp->wq.qpid, qhp, (unsigned long long) qhp->wq.dma_addr,\r\n1 << qhp->wq.size_log2, qhp->wq.rq_addr);\r\nreturn &qhp->ibqp;\r\n}\r\nstatic int iwch_ib_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,\r\nint attr_mask, struct ib_udata *udata)\r\n{\r\nstruct iwch_dev *rhp;\r\nstruct iwch_qp *qhp;\r\nenum iwch_qp_attr_mask mask = 0;\r\nstruct iwch_qp_attributes attrs;\r\nPDBG("%s ib_qp %p\n", __func__, ibqp);\r\nif ((attr_mask & IB_QP_STATE) && (attr->qp_state == IB_QPS_RTR))\r\nattr_mask &= ~IB_QP_STATE;\r\nif (!attr_mask)\r\nreturn 0;\r\nmemset(&attrs, 0, sizeof attrs);\r\nqhp = to_iwch_qp(ibqp);\r\nrhp = qhp->rhp;\r\nattrs.next_state = iwch_convert_state(attr->qp_state);\r\nattrs.enable_rdma_read = (attr->qp_access_flags &\r\nIB_ACCESS_REMOTE_READ) ? 1 : 0;\r\nattrs.enable_rdma_write = (attr->qp_access_flags &\r\nIB_ACCESS_REMOTE_WRITE) ? 1 : 0;\r\nattrs.enable_bind = (attr->qp_access_flags & IB_ACCESS_MW_BIND) ? 1 : 0;\r\nmask |= (attr_mask & IB_QP_STATE) ? IWCH_QP_ATTR_NEXT_STATE : 0;\r\nmask |= (attr_mask & IB_QP_ACCESS_FLAGS) ?\r\n(IWCH_QP_ATTR_ENABLE_RDMA_READ |\r\nIWCH_QP_ATTR_ENABLE_RDMA_WRITE |\r\nIWCH_QP_ATTR_ENABLE_RDMA_BIND) : 0;\r\nreturn iwch_modify_qp(rhp, qhp, mask, &attrs, 0);\r\n}\r\nvoid iwch_qp_add_ref(struct ib_qp *qp)\r\n{\r\nPDBG("%s ib_qp %p\n", __func__, qp);\r\natomic_inc(&(to_iwch_qp(qp)->refcnt));\r\n}\r\nvoid iwch_qp_rem_ref(struct ib_qp *qp)\r\n{\r\nPDBG("%s ib_qp %p\n", __func__, qp);\r\nif (atomic_dec_and_test(&(to_iwch_qp(qp)->refcnt)))\r\nwake_up(&(to_iwch_qp(qp)->wait));\r\n}\r\nstatic struct ib_qp *iwch_get_qp(struct ib_device *dev, int qpn)\r\n{\r\nPDBG("%s ib_dev %p qpn 0x%x\n", __func__, dev, qpn);\r\nreturn (struct ib_qp *)get_qhp(to_iwch_dev(dev), qpn);\r\n}\r\nstatic int iwch_query_pkey(struct ib_device *ibdev,\r\nu8 port, u16 index, u16 * pkey)\r\n{\r\nPDBG("%s ibdev %p\n", __func__, ibdev);\r\n*pkey = 0;\r\nreturn 0;\r\n}\r\nstatic int iwch_query_gid(struct ib_device *ibdev, u8 port,\r\nint index, union ib_gid *gid)\r\n{\r\nstruct iwch_dev *dev;\r\nPDBG("%s ibdev %p, port %d, index %d, gid %p\n",\r\n__func__, ibdev, port, index, gid);\r\ndev = to_iwch_dev(ibdev);\r\nBUG_ON(port == 0 || port > 2);\r\nmemset(&(gid->raw[0]), 0, sizeof(gid->raw));\r\nmemcpy(&(gid->raw[0]), dev->rdev.port_info.lldevs[port-1]->dev_addr, 6);\r\nreturn 0;\r\n}\r\nstatic u64 fw_vers_string_to_u64(struct iwch_dev *iwch_dev)\r\n{\r\nstruct ethtool_drvinfo info;\r\nstruct net_device *lldev = iwch_dev->rdev.t3cdev_p->lldev;\r\nchar *cp, *next;\r\nunsigned fw_maj, fw_min, fw_mic;\r\nlldev->ethtool_ops->get_drvinfo(lldev, &info);\r\nnext = info.fw_version + 1;\r\ncp = strsep(&next, ".");\r\nsscanf(cp, "%i", &fw_maj);\r\ncp = strsep(&next, ".");\r\nsscanf(cp, "%i", &fw_min);\r\ncp = strsep(&next, ".");\r\nsscanf(cp, "%i", &fw_mic);\r\nreturn (((u64)fw_maj & 0xffff) << 32) | ((fw_min & 0xffff) << 16) |\r\n(fw_mic & 0xffff);\r\n}\r\nstatic int iwch_query_device(struct ib_device *ibdev,\r\nstruct ib_device_attr *props)\r\n{\r\nstruct iwch_dev *dev;\r\nPDBG("%s ibdev %p\n", __func__, ibdev);\r\ndev = to_iwch_dev(ibdev);\r\nmemset(props, 0, sizeof *props);\r\nmemcpy(&props->sys_image_guid, dev->rdev.t3cdev_p->lldev->dev_addr, 6);\r\nprops->hw_ver = dev->rdev.t3cdev_p->type;\r\nprops->fw_ver = fw_vers_string_to_u64(dev);\r\nprops->device_cap_flags = dev->device_cap_flags;\r\nprops->page_size_cap = dev->attr.mem_pgsizes_bitmask;\r\nprops->vendor_id = (u32)dev->rdev.rnic_info.pdev->vendor;\r\nprops->vendor_part_id = (u32)dev->rdev.rnic_info.pdev->device;\r\nprops->max_mr_size = dev->attr.max_mr_size;\r\nprops->max_qp = dev->attr.max_qps;\r\nprops->max_qp_wr = dev->attr.max_wrs;\r\nprops->max_sge = dev->attr.max_sge_per_wr;\r\nprops->max_sge_rd = 1;\r\nprops->max_qp_rd_atom = dev->attr.max_rdma_reads_per_qp;\r\nprops->max_qp_init_rd_atom = dev->attr.max_rdma_reads_per_qp;\r\nprops->max_cq = dev->attr.max_cqs;\r\nprops->max_cqe = dev->attr.max_cqes_per_cq;\r\nprops->max_mr = dev->attr.max_mem_regs;\r\nprops->max_pd = dev->attr.max_pds;\r\nprops->local_ca_ack_delay = 0;\r\nprops->max_fast_reg_page_list_len = T3_MAX_FASTREG_DEPTH;\r\nreturn 0;\r\n}\r\nstatic int iwch_query_port(struct ib_device *ibdev,\r\nu8 port, struct ib_port_attr *props)\r\n{\r\nstruct iwch_dev *dev;\r\nstruct net_device *netdev;\r\nstruct in_device *inetdev;\r\nPDBG("%s ibdev %p\n", __func__, ibdev);\r\ndev = to_iwch_dev(ibdev);\r\nnetdev = dev->rdev.port_info.lldevs[port-1];\r\nmemset(props, 0, sizeof(struct ib_port_attr));\r\nprops->max_mtu = IB_MTU_4096;\r\nif (netdev->mtu >= 4096)\r\nprops->active_mtu = IB_MTU_4096;\r\nelse if (netdev->mtu >= 2048)\r\nprops->active_mtu = IB_MTU_2048;\r\nelse if (netdev->mtu >= 1024)\r\nprops->active_mtu = IB_MTU_1024;\r\nelse if (netdev->mtu >= 512)\r\nprops->active_mtu = IB_MTU_512;\r\nelse\r\nprops->active_mtu = IB_MTU_256;\r\nif (!netif_carrier_ok(netdev))\r\nprops->state = IB_PORT_DOWN;\r\nelse {\r\ninetdev = in_dev_get(netdev);\r\nif (inetdev) {\r\nif (inetdev->ifa_list)\r\nprops->state = IB_PORT_ACTIVE;\r\nelse\r\nprops->state = IB_PORT_INIT;\r\nin_dev_put(inetdev);\r\n} else\r\nprops->state = IB_PORT_INIT;\r\n}\r\nprops->port_cap_flags =\r\nIB_PORT_CM_SUP |\r\nIB_PORT_SNMP_TUNNEL_SUP |\r\nIB_PORT_REINIT_SUP |\r\nIB_PORT_DEVICE_MGMT_SUP |\r\nIB_PORT_VENDOR_CLASS_SUP | IB_PORT_BOOT_MGMT_SUP;\r\nprops->gid_tbl_len = 1;\r\nprops->pkey_tbl_len = 1;\r\nprops->active_width = 2;\r\nprops->active_speed = 2;\r\nprops->max_msg_sz = -1;\r\nreturn 0;\r\n}\r\nstatic ssize_t show_rev(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iwch_dev *iwch_dev = container_of(dev, struct iwch_dev,\r\nibdev.dev);\r\nPDBG("%s dev 0x%p\n", __func__, dev);\r\nreturn sprintf(buf, "%d\n", iwch_dev->rdev.t3cdev_p->type);\r\n}\r\nstatic ssize_t show_fw_ver(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct iwch_dev *iwch_dev = container_of(dev, struct iwch_dev,\r\nibdev.dev);\r\nstruct ethtool_drvinfo info;\r\nstruct net_device *lldev = iwch_dev->rdev.t3cdev_p->lldev;\r\nPDBG("%s dev 0x%p\n", __func__, dev);\r\nlldev->ethtool_ops->get_drvinfo(lldev, &info);\r\nreturn sprintf(buf, "%s\n", info.fw_version);\r\n}\r\nstatic ssize_t show_hca(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iwch_dev *iwch_dev = container_of(dev, struct iwch_dev,\r\nibdev.dev);\r\nstruct ethtool_drvinfo info;\r\nstruct net_device *lldev = iwch_dev->rdev.t3cdev_p->lldev;\r\nPDBG("%s dev 0x%p\n", __func__, dev);\r\nlldev->ethtool_ops->get_drvinfo(lldev, &info);\r\nreturn sprintf(buf, "%s\n", info.driver);\r\n}\r\nstatic ssize_t show_board(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iwch_dev *iwch_dev = container_of(dev, struct iwch_dev,\r\nibdev.dev);\r\nPDBG("%s dev 0x%p\n", __func__, dev);\r\nreturn sprintf(buf, "%x.%x\n", iwch_dev->rdev.rnic_info.pdev->vendor,\r\niwch_dev->rdev.rnic_info.pdev->device);\r\n}\r\nstatic int iwch_get_mib(struct ib_device *ibdev,\r\nunion rdma_protocol_stats *stats)\r\n{\r\nstruct iwch_dev *dev;\r\nstruct tp_mib_stats m;\r\nint ret;\r\nPDBG("%s ibdev %p\n", __func__, ibdev);\r\ndev = to_iwch_dev(ibdev);\r\nret = dev->rdev.t3cdev_p->ctl(dev->rdev.t3cdev_p, RDMA_GET_MIB, &m);\r\nif (ret)\r\nreturn -ENOSYS;\r\nmemset(stats, 0, sizeof *stats);\r\nstats->iw.ipInReceives = ((u64) m.ipInReceive_hi << 32) +\r\nm.ipInReceive_lo;\r\nstats->iw.ipInHdrErrors = ((u64) m.ipInHdrErrors_hi << 32) +\r\nm.ipInHdrErrors_lo;\r\nstats->iw.ipInAddrErrors = ((u64) m.ipInAddrErrors_hi << 32) +\r\nm.ipInAddrErrors_lo;\r\nstats->iw.ipInUnknownProtos = ((u64) m.ipInUnknownProtos_hi << 32) +\r\nm.ipInUnknownProtos_lo;\r\nstats->iw.ipInDiscards = ((u64) m.ipInDiscards_hi << 32) +\r\nm.ipInDiscards_lo;\r\nstats->iw.ipInDelivers = ((u64) m.ipInDelivers_hi << 32) +\r\nm.ipInDelivers_lo;\r\nstats->iw.ipOutRequests = ((u64) m.ipOutRequests_hi << 32) +\r\nm.ipOutRequests_lo;\r\nstats->iw.ipOutDiscards = ((u64) m.ipOutDiscards_hi << 32) +\r\nm.ipOutDiscards_lo;\r\nstats->iw.ipOutNoRoutes = ((u64) m.ipOutNoRoutes_hi << 32) +\r\nm.ipOutNoRoutes_lo;\r\nstats->iw.ipReasmTimeout = (u64) m.ipReasmTimeout;\r\nstats->iw.ipReasmReqds = (u64) m.ipReasmReqds;\r\nstats->iw.ipReasmOKs = (u64) m.ipReasmOKs;\r\nstats->iw.ipReasmFails = (u64) m.ipReasmFails;\r\nstats->iw.tcpActiveOpens = (u64) m.tcpActiveOpens;\r\nstats->iw.tcpPassiveOpens = (u64) m.tcpPassiveOpens;\r\nstats->iw.tcpAttemptFails = (u64) m.tcpAttemptFails;\r\nstats->iw.tcpEstabResets = (u64) m.tcpEstabResets;\r\nstats->iw.tcpOutRsts = (u64) m.tcpOutRsts;\r\nstats->iw.tcpCurrEstab = (u64) m.tcpCurrEstab;\r\nstats->iw.tcpInSegs = ((u64) m.tcpInSegs_hi << 32) +\r\nm.tcpInSegs_lo;\r\nstats->iw.tcpOutSegs = ((u64) m.tcpOutSegs_hi << 32) +\r\nm.tcpOutSegs_lo;\r\nstats->iw.tcpRetransSegs = ((u64) m.tcpRetransSeg_hi << 32) +\r\nm.tcpRetransSeg_lo;\r\nstats->iw.tcpInErrs = ((u64) m.tcpInErrs_hi << 32) +\r\nm.tcpInErrs_lo;\r\nstats->iw.tcpRtoMin = (u64) m.tcpRtoMin;\r\nstats->iw.tcpRtoMax = (u64) m.tcpRtoMax;\r\nreturn 0;\r\n}\r\nint iwch_register_device(struct iwch_dev *dev)\r\n{\r\nint ret;\r\nint i;\r\nPDBG("%s iwch_dev %p\n", __func__, dev);\r\nstrlcpy(dev->ibdev.name, "cxgb3_%d", IB_DEVICE_NAME_MAX);\r\nmemset(&dev->ibdev.node_guid, 0, sizeof(dev->ibdev.node_guid));\r\nmemcpy(&dev->ibdev.node_guid, dev->rdev.t3cdev_p->lldev->dev_addr, 6);\r\ndev->ibdev.owner = THIS_MODULE;\r\ndev->device_cap_flags = IB_DEVICE_LOCAL_DMA_LKEY |\r\nIB_DEVICE_MEM_WINDOW |\r\nIB_DEVICE_MEM_MGT_EXTENSIONS;\r\ndev->ibdev.local_dma_lkey = 0;\r\ndev->ibdev.uverbs_cmd_mask =\r\n(1ull << IB_USER_VERBS_CMD_GET_CONTEXT) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_DEVICE) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_PORT) |\r\n(1ull << IB_USER_VERBS_CMD_ALLOC_PD) |\r\n(1ull << IB_USER_VERBS_CMD_DEALLOC_PD) |\r\n(1ull << IB_USER_VERBS_CMD_REG_MR) |\r\n(1ull << IB_USER_VERBS_CMD_DEREG_MR) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_REQ_NOTIFY_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_QP) |\r\n(1ull << IB_USER_VERBS_CMD_MODIFY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_POLL_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_POST_SEND) |\r\n(1ull << IB_USER_VERBS_CMD_POST_RECV);\r\ndev->ibdev.node_type = RDMA_NODE_RNIC;\r\nmemcpy(dev->ibdev.node_desc, IWCH_NODE_DESC, sizeof(IWCH_NODE_DESC));\r\ndev->ibdev.phys_port_cnt = dev->rdev.port_info.nports;\r\ndev->ibdev.num_comp_vectors = 1;\r\ndev->ibdev.dma_device = &(dev->rdev.rnic_info.pdev->dev);\r\ndev->ibdev.query_device = iwch_query_device;\r\ndev->ibdev.query_port = iwch_query_port;\r\ndev->ibdev.query_pkey = iwch_query_pkey;\r\ndev->ibdev.query_gid = iwch_query_gid;\r\ndev->ibdev.alloc_ucontext = iwch_alloc_ucontext;\r\ndev->ibdev.dealloc_ucontext = iwch_dealloc_ucontext;\r\ndev->ibdev.mmap = iwch_mmap;\r\ndev->ibdev.alloc_pd = iwch_allocate_pd;\r\ndev->ibdev.dealloc_pd = iwch_deallocate_pd;\r\ndev->ibdev.create_ah = iwch_ah_create;\r\ndev->ibdev.destroy_ah = iwch_ah_destroy;\r\ndev->ibdev.create_qp = iwch_create_qp;\r\ndev->ibdev.modify_qp = iwch_ib_modify_qp;\r\ndev->ibdev.destroy_qp = iwch_destroy_qp;\r\ndev->ibdev.create_cq = iwch_create_cq;\r\ndev->ibdev.destroy_cq = iwch_destroy_cq;\r\ndev->ibdev.resize_cq = iwch_resize_cq;\r\ndev->ibdev.poll_cq = iwch_poll_cq;\r\ndev->ibdev.get_dma_mr = iwch_get_dma_mr;\r\ndev->ibdev.reg_phys_mr = iwch_register_phys_mem;\r\ndev->ibdev.rereg_phys_mr = iwch_reregister_phys_mem;\r\ndev->ibdev.reg_user_mr = iwch_reg_user_mr;\r\ndev->ibdev.dereg_mr = iwch_dereg_mr;\r\ndev->ibdev.alloc_mw = iwch_alloc_mw;\r\ndev->ibdev.bind_mw = iwch_bind_mw;\r\ndev->ibdev.dealloc_mw = iwch_dealloc_mw;\r\ndev->ibdev.alloc_fast_reg_mr = iwch_alloc_fast_reg_mr;\r\ndev->ibdev.alloc_fast_reg_page_list = iwch_alloc_fastreg_pbl;\r\ndev->ibdev.free_fast_reg_page_list = iwch_free_fastreg_pbl;\r\ndev->ibdev.attach_mcast = iwch_multicast_attach;\r\ndev->ibdev.detach_mcast = iwch_multicast_detach;\r\ndev->ibdev.process_mad = iwch_process_mad;\r\ndev->ibdev.req_notify_cq = iwch_arm_cq;\r\ndev->ibdev.post_send = iwch_post_send;\r\ndev->ibdev.post_recv = iwch_post_receive;\r\ndev->ibdev.get_protocol_stats = iwch_get_mib;\r\ndev->ibdev.uverbs_abi_ver = IWCH_UVERBS_ABI_VERSION;\r\ndev->ibdev.iwcm = kmalloc(sizeof(struct iw_cm_verbs), GFP_KERNEL);\r\nif (!dev->ibdev.iwcm)\r\nreturn -ENOMEM;\r\ndev->ibdev.iwcm->connect = iwch_connect;\r\ndev->ibdev.iwcm->accept = iwch_accept_cr;\r\ndev->ibdev.iwcm->reject = iwch_reject_cr;\r\ndev->ibdev.iwcm->create_listen = iwch_create_listen;\r\ndev->ibdev.iwcm->destroy_listen = iwch_destroy_listen;\r\ndev->ibdev.iwcm->add_ref = iwch_qp_add_ref;\r\ndev->ibdev.iwcm->rem_ref = iwch_qp_rem_ref;\r\ndev->ibdev.iwcm->get_qp = iwch_get_qp;\r\nret = ib_register_device(&dev->ibdev, NULL);\r\nif (ret)\r\ngoto bail1;\r\nfor (i = 0; i < ARRAY_SIZE(iwch_class_attributes); ++i) {\r\nret = device_create_file(&dev->ibdev.dev,\r\niwch_class_attributes[i]);\r\nif (ret) {\r\ngoto bail2;\r\n}\r\n}\r\nreturn 0;\r\nbail2:\r\nib_unregister_device(&dev->ibdev);\r\nbail1:\r\nkfree(dev->ibdev.iwcm);\r\nreturn ret;\r\n}\r\nvoid iwch_unregister_device(struct iwch_dev *dev)\r\n{\r\nint i;\r\nPDBG("%s iwch_dev %p\n", __func__, dev);\r\nfor (i = 0; i < ARRAY_SIZE(iwch_class_attributes); ++i)\r\ndevice_remove_file(&dev->ibdev.dev,\r\niwch_class_attributes[i]);\r\nib_unregister_device(&dev->ibdev);\r\nkfree(dev->ibdev.iwcm);\r\nreturn;\r\n}
