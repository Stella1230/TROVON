static unsigned int\r\nsecmark_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nu32 secmark = 0;\r\nconst struct xt_secmark_target_info *info = par->targinfo;\r\nBUG_ON(info->mode != mode);\r\nswitch (mode) {\r\ncase SECMARK_MODE_SEL:\r\nsecmark = info->secid;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nskb->secmark = secmark;\r\nreturn XT_CONTINUE;\r\n}\r\nstatic int checkentry_lsm(struct xt_secmark_target_info *info)\r\n{\r\nint err;\r\ninfo->secctx[SECMARK_SECCTX_MAX - 1] = '\0';\r\ninfo->secid = 0;\r\nerr = security_secctx_to_secid(info->secctx, strlen(info->secctx),\r\n&info->secid);\r\nif (err) {\r\nif (err == -EINVAL)\r\npr_info("invalid security context \'%s\'\n", info->secctx);\r\nreturn err;\r\n}\r\nif (!info->secid) {\r\npr_info("unable to map security context \'%s\'\n", info->secctx);\r\nreturn -ENOENT;\r\n}\r\nerr = security_secmark_relabel_packet(info->secid);\r\nif (err) {\r\npr_info("unable to obtain relabeling permission\n");\r\nreturn err;\r\n}\r\nsecurity_secmark_refcount_inc();\r\nreturn 0;\r\n}\r\nstatic int secmark_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nstruct xt_secmark_target_info *info = par->targinfo;\r\nint err;\r\nif (strcmp(par->table, "mangle") != 0 &&\r\nstrcmp(par->table, "security") != 0) {\r\npr_info("target only valid in the \'mangle\' "\r\n"or \'security\' tables, not \'%s\'.\n", par->table);\r\nreturn -EINVAL;\r\n}\r\nif (mode && mode != info->mode) {\r\npr_info("mode already set to %hu cannot mix with "\r\n"rules for mode %hu\n", mode, info->mode);\r\nreturn -EINVAL;\r\n}\r\nswitch (info->mode) {\r\ncase SECMARK_MODE_SEL:\r\nbreak;\r\ndefault:\r\npr_info("invalid mode: %hu\n", info->mode);\r\nreturn -EINVAL;\r\n}\r\nerr = checkentry_lsm(info);\r\nif (err)\r\nreturn err;\r\nif (!mode)\r\nmode = info->mode;\r\nreturn 0;\r\n}\r\nstatic void secmark_tg_destroy(const struct xt_tgdtor_param *par)\r\n{\r\nswitch (mode) {\r\ncase SECMARK_MODE_SEL:\r\nsecurity_secmark_refcount_dec();\r\n}\r\n}\r\nstatic int __init secmark_tg_init(void)\r\n{\r\nreturn xt_register_target(&secmark_tg_reg);\r\n}\r\nstatic void __exit secmark_tg_exit(void)\r\n{\r\nxt_unregister_target(&secmark_tg_reg);\r\n}
