static void DisplayRegisterContents(int module,\r\nint channel,\r\nint (*fpPrint) (const char *, ...)\r\n) {\r\nint chan;\r\n(*fpPrint) ("Displaying register content \n\n");\r\n(*fpPrint) ("Module %d: Interrupt raw transfer 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_RAW_TRAN(module)));\r\n(*fpPrint) ("Module %d: Interrupt raw block 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_RAW_BLOCK(module)));\r\n(*fpPrint) ("Module %d: Interrupt raw src transfer 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_RAW_STRAN(module)));\r\n(*fpPrint) ("Module %d: Interrupt raw dst transfer 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_RAW_DTRAN(module)));\r\n(*fpPrint) ("Module %d: Interrupt raw error 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_RAW_ERROR(module)));\r\n(*fpPrint) ("--------------------------------------------------\n");\r\n(*fpPrint) ("Module %d: Interrupt stat transfer 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_STAT_TRAN(module)));\r\n(*fpPrint) ("Module %d: Interrupt stat block 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_STAT_BLOCK(module)));\r\n(*fpPrint) ("Module %d: Interrupt stat src transfer 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_STAT_STRAN(module)));\r\n(*fpPrint) ("Module %d: Interrupt stat dst transfer 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_STAT_DTRAN(module)));\r\n(*fpPrint) ("Module %d: Interrupt stat error 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_STAT_ERROR(module)));\r\n(*fpPrint) ("--------------------------------------------------\n");\r\n(*fpPrint) ("Module %d: Interrupt mask transfer 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_MASK_TRAN(module)));\r\n(*fpPrint) ("Module %d: Interrupt mask block 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_MASK_BLOCK(module)));\r\n(*fpPrint) ("Module %d: Interrupt mask src transfer 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_MASK_STRAN(module)));\r\n(*fpPrint) ("Module %d: Interrupt mask dst transfer 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_MASK_DTRAN(module)));\r\n(*fpPrint) ("Module %d: Interrupt mask error 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_MASK_ERROR(module)));\r\n(*fpPrint) ("--------------------------------------------------\n");\r\n(*fpPrint) ("Module %d: Interrupt clear transfer 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_CLEAR_TRAN(module)));\r\n(*fpPrint) ("Module %d: Interrupt clear block 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_CLEAR_BLOCK(module)));\r\n(*fpPrint) ("Module %d: Interrupt clear src transfer 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_CLEAR_STRAN(module)));\r\n(*fpPrint) ("Module %d: Interrupt clear dst transfer 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_CLEAR_DTRAN(module)));\r\n(*fpPrint) ("Module %d: Interrupt clear error 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_INT_CLEAR_ERROR(module)));\r\n(*fpPrint) ("--------------------------------------------------\n");\r\n(*fpPrint) ("Module %d: SW source req 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_SW_HS_SRC_REQ(module)));\r\n(*fpPrint) ("Module %d: SW dest req 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_SW_HS_DST_REQ(module)));\r\n(*fpPrint) ("Module %d: SW source signal 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_SW_HS_SRC_SGL_REQ(module)));\r\n(*fpPrint) ("Module %d: SW dest signal 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_SW_HS_DST_SGL_REQ(module)));\r\n(*fpPrint) ("Module %d: SW source last 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_SW_HS_SRC_LST_REQ(module)));\r\n(*fpPrint) ("Module %d: SW dest last 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_SW_HS_DST_LST_REQ(module)));\r\n(*fpPrint) ("--------------------------------------------------\n");\r\n(*fpPrint) ("Module %d: misc config 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_MISC_CFG(module)));\r\n(*fpPrint) ("Module %d: misc channel enable 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_MISC_CH_ENABLE(module)));\r\n(*fpPrint) ("Module %d: misc ID 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_MISC_ID(module)));\r\n(*fpPrint) ("Module %d: misc test 0x%X\n",\r\nmodule, (uint32_t) (dmacHw_REG_MISC_TEST(module)));\r\nif (channel == -1) {\r\nfor (chan = 0; chan < 8; chan++) {\r\n(*fpPrint)\r\n("--------------------------------------------------\n");\r\n(*fpPrint)\r\n("Module %d: Channel %d Source 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_SAR(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Destination 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_DAR(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d LLP 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_LLP(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Control (LO) 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_CTL_LO(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Control (HI) 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_CTL_HI(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Source Stats 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_SSTAT(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Dest Stats 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_DSTAT(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Source Stats Addr 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_SSTATAR(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Dest Stats Addr 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_DSTATAR(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Config (LO) 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_CFG_LO(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Config (HI) 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_CFG_HI(module, chan)));\r\n}\r\n} else {\r\nchan = channel;\r\n(*fpPrint)\r\n("--------------------------------------------------\n");\r\n(*fpPrint)\r\n("Module %d: Channel %d Source 0x%X\n",\r\nmodule, chan, (uint32_t) (dmacHw_REG_SAR(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Destination 0x%X\n",\r\nmodule, chan, (uint32_t) (dmacHw_REG_DAR(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d LLP 0x%X\n",\r\nmodule, chan, (uint32_t) (dmacHw_REG_LLP(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Control (LO) 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_CTL_LO(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Control (HI) 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_CTL_HI(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Source Stats 0x%X\n",\r\nmodule, chan, (uint32_t) (dmacHw_REG_SSTAT(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Dest Stats 0x%X\n",\r\nmodule, chan, (uint32_t) (dmacHw_REG_DSTAT(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Source Stats Addr 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_SSTATAR(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Dest Stats Addr 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_DSTATAR(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Config (LO) 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_CFG_LO(module, chan)));\r\n(*fpPrint)\r\n("Module %d: Channel %d Config (HI) 0x%X\n",\r\nmodule, chan,\r\n(uint32_t) (dmacHw_REG_CFG_HI(module, chan)));\r\n}\r\n}\r\nstatic void DisplayDescRing(void *pDescriptor,\r\nint (*fpPrint) (const char *, ...)\r\n) {\r\ndmacHw_DESC_RING_t *pRing = dmacHw_GET_DESC_RING(pDescriptor);\r\ndmacHw_DESC_t *pStart;\r\nif (pRing->pHead == NULL) {\r\nreturn;\r\n}\r\npStart = pRing->pHead;\r\nwhile ((dmacHw_DESC_t *) pStart->llp != pRing->pHead) {\r\nif (pStart == pRing->pHead) {\r\n(*fpPrint) ("Head\n");\r\n}\r\nif (pStart == pRing->pTail) {\r\n(*fpPrint) ("Tail\n");\r\n}\r\nif (pStart == pRing->pProg) {\r\n(*fpPrint) ("Prog\n");\r\n}\r\nif (pStart == pRing->pEnd) {\r\n(*fpPrint) ("End\n");\r\n}\r\nif (pStart == pRing->pFree) {\r\n(*fpPrint) ("Free\n");\r\n}\r\n(*fpPrint) ("0x%X:\n", (uint32_t) pStart);\r\n(*fpPrint) ("sar 0x%0X\n", pStart->sar);\r\n(*fpPrint) ("dar 0x%0X\n", pStart->dar);\r\n(*fpPrint) ("llp 0x%0X\n", pStart->llp);\r\n(*fpPrint) ("ctl.lo 0x%0X\n", pStart->ctl.lo);\r\n(*fpPrint) ("ctl.hi 0x%0X\n", pStart->ctl.hi);\r\n(*fpPrint) ("sstat 0x%0X\n", pStart->sstat);\r\n(*fpPrint) ("dstat 0x%0X\n", pStart->dstat);\r\n(*fpPrint) ("devCtl 0x%0X\n", pStart->devCtl);\r\npStart = (dmacHw_DESC_t *) pStart->llp;\r\n}\r\nif (pStart == pRing->pHead) {\r\n(*fpPrint) ("Head\n");\r\n}\r\nif (pStart == pRing->pTail) {\r\n(*fpPrint) ("Tail\n");\r\n}\r\nif (pStart == pRing->pProg) {\r\n(*fpPrint) ("Prog\n");\r\n}\r\nif (pStart == pRing->pEnd) {\r\n(*fpPrint) ("End\n");\r\n}\r\nif (pStart == pRing->pFree) {\r\n(*fpPrint) ("Free\n");\r\n}\r\n(*fpPrint) ("0x%X:\n", (uint32_t) pStart);\r\n(*fpPrint) ("sar 0x%0X\n", pStart->sar);\r\n(*fpPrint) ("dar 0x%0X\n", pStart->dar);\r\n(*fpPrint) ("llp 0x%0X\n", pStart->llp);\r\n(*fpPrint) ("ctl.lo 0x%0X\n", pStart->ctl.lo);\r\n(*fpPrint) ("ctl.hi 0x%0X\n", pStart->ctl.hi);\r\n(*fpPrint) ("sstat 0x%0X\n", pStart->sstat);\r\n(*fpPrint) ("dstat 0x%0X\n", pStart->dstat);\r\n(*fpPrint) ("devCtl 0x%0X\n", pStart->devCtl);\r\n}\r\nstatic inline int DmaIsFlowController(void *pDescriptor\r\n) {\r\nuint32_t ttfc =\r\n(dmacHw_GET_DESC_RING(pDescriptor))->pTail->ctl.\r\nlo & dmacHw_REG_CTL_TTFC_MASK;\r\nswitch (ttfc) {\r\ncase dmacHw_REG_CTL_TTFC_MM_DMAC:\r\ncase dmacHw_REG_CTL_TTFC_MP_DMAC:\r\ncase dmacHw_REG_CTL_TTFC_PM_DMAC:\r\ncase dmacHw_REG_CTL_TTFC_PP_DMAC:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid dmacHw_setDataLength(dmacHw_CONFIG_t *pConfig,\r\nvoid *pDescriptor,\r\nsize_t dataLen\r\n) {\r\ndmacHw_DESC_t *pProg;\r\ndmacHw_DESC_t *pHead;\r\nint srcTs = 0;\r\nint srcTrSize = 0;\r\npHead = (dmacHw_GET_DESC_RING(pDescriptor))->pHead;\r\npProg = pHead;\r\nsrcTrSize = dmacHw_GetTrWidthInBytes(pConfig->srcMaxTransactionWidth);\r\nsrcTs = dataLen / srcTrSize;\r\ndo {\r\npProg->ctl.hi = srcTs & dmacHw_REG_CTL_BLOCK_TS_MASK;\r\npProg = (dmacHw_DESC_t *) pProg->llp;\r\n} while (pProg != pHead);\r\n}\r\nvoid dmacHw_clearInterrupt(dmacHw_HANDLE_t handle\r\n) {\r\ndmacHw_CBLK_t *pCblk = dmacHw_HANDLE_TO_CBLK(handle);\r\ndmacHw_TRAN_INT_CLEAR(pCblk->module, pCblk->channel);\r\ndmacHw_BLOCK_INT_CLEAR(pCblk->module, pCblk->channel);\r\ndmacHw_ERROR_INT_CLEAR(pCblk->module, pCblk->channel);\r\n}\r\ndmacHw_INTERRUPT_STATUS_e dmacHw_getInterruptStatus(dmacHw_HANDLE_t handle\r\n) {\r\ndmacHw_CBLK_t *pCblk = dmacHw_HANDLE_TO_CBLK(handle);\r\ndmacHw_INTERRUPT_STATUS_e status = dmacHw_INTERRUPT_STATUS_NONE;\r\nif (dmacHw_REG_INT_STAT_TRAN(pCblk->module) &\r\n((0x00000001 << pCblk->channel))) {\r\nstatus |= dmacHw_INTERRUPT_STATUS_TRANS;\r\n}\r\nif (dmacHw_REG_INT_STAT_BLOCK(pCblk->module) &\r\n((0x00000001 << pCblk->channel))) {\r\nstatus |= dmacHw_INTERRUPT_STATUS_BLOCK;\r\n}\r\nif (dmacHw_REG_INT_STAT_ERROR(pCblk->module) &\r\n((0x00000001 << pCblk->channel))) {\r\nstatus |= dmacHw_INTERRUPT_STATUS_ERROR;\r\n}\r\nreturn status;\r\n}\r\ndmacHw_HANDLE_t dmacHw_getInterruptSource(void)\r\n{\r\nuint32_t i;\r\nfor (i = 0; i < dmaChannelCount_0 + dmaChannelCount_1; i++) {\r\nif ((dmacHw_REG_INT_STAT_TRAN(dmacHw_gCblk[i].module) &\r\n((0x00000001 << dmacHw_gCblk[i].channel)))\r\n|| (dmacHw_REG_INT_STAT_BLOCK(dmacHw_gCblk[i].module) &\r\n((0x00000001 << dmacHw_gCblk[i].channel)))\r\n|| (dmacHw_REG_INT_STAT_ERROR(dmacHw_gCblk[i].module) &\r\n((0x00000001 << dmacHw_gCblk[i].channel)))\r\n) {\r\nreturn dmacHw_CBLK_TO_HANDLE(&dmacHw_gCblk[i]);\r\n}\r\n}\r\nreturn dmacHw_CBLK_TO_HANDLE(NULL);\r\n}\r\nint dmacHw_calculateDescriptorCount(dmacHw_CONFIG_t *pConfig,\r\nvoid *pSrcAddr,\r\nvoid *pDstAddr,\r\nsize_t dataLen\r\n) {\r\nint srcTs = 0;\r\nint oddSize = 0;\r\nint descCount = 0;\r\nint dstTrSize = 0;\r\nint srcTrSize = 0;\r\nuint32_t maxBlockSize = dmacHw_MAX_BLOCKSIZE;\r\ndmacHw_TRANSACTION_WIDTH_e dstTrWidth;\r\ndmacHw_TRANSACTION_WIDTH_e srcTrWidth;\r\ndstTrSize = dmacHw_GetTrWidthInBytes(pConfig->dstMaxTransactionWidth);\r\nsrcTrSize = dmacHw_GetTrWidthInBytes(pConfig->srcMaxTransactionWidth);\r\nif ((pSrcAddr == NULL) || (pDstAddr == NULL) || (dataLen == 0)) {\r\nreturn -1;\r\n}\r\nif (pConfig->srcGatherWidth % srcTrSize\r\n|| pConfig->dstScatterWidth % dstTrSize) {\r\nreturn -1;\r\n}\r\ndstTrWidth = pConfig->dstMaxTransactionWidth;\r\nwhile (dmacHw_ADDRESS_MASK(dstTrSize) & (uint32_t) pDstAddr) {\r\ndstTrWidth = dmacHw_GetNextTrWidth(dstTrWidth);\r\ndstTrSize = dmacHw_GetTrWidthInBytes(dstTrWidth);\r\n}\r\nsrcTrWidth = pConfig->srcMaxTransactionWidth;\r\nwhile (dmacHw_ADDRESS_MASK(srcTrSize) & (uint32_t) pSrcAddr) {\r\nsrcTrWidth = dmacHw_GetNextTrWidth(srcTrWidth);\r\nsrcTrSize = dmacHw_GetTrWidthInBytes(srcTrWidth);\r\n}\r\nif (pConfig->maxDataPerBlock\r\n&& ((pConfig->maxDataPerBlock / srcTrSize) <\r\ndmacHw_MAX_BLOCKSIZE)) {\r\nmaxBlockSize = pConfig->maxDataPerBlock / srcTrSize;\r\n}\r\nsrcTs = dataLen / srcTrSize;\r\nif (srcTs && (dstTrSize > srcTrSize)) {\r\noddSize = dataLen % dstTrSize;\r\nsrcTs = srcTs - (oddSize / srcTrSize);\r\n} else {\r\noddSize = dataLen % srcTrSize;\r\n}\r\nif (oddSize) {\r\ndescCount++;\r\n}\r\nif (srcTs) {\r\ndescCount += ((srcTs - 1) / maxBlockSize) + 1;\r\n}\r\nreturn descCount;\r\n}\r\nuint32_t dmacHw_descriptorPending(dmacHw_HANDLE_t handle,\r\nvoid *pDescriptor\r\n) {\r\ndmacHw_CBLK_t *pCblk = dmacHw_HANDLE_TO_CBLK(handle);\r\ndmacHw_DESC_RING_t *pRing = dmacHw_GET_DESC_RING(pDescriptor);\r\nif (!CHANNEL_BUSY(pCblk->module, pCblk->channel)) {\r\nif (pRing->pEnd) {\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid dmacHw_stopTransfer(dmacHw_HANDLE_t handle\r\n) {\r\ndmacHw_CBLK_t *pCblk;\r\npCblk = dmacHw_HANDLE_TO_CBLK(handle);\r\ndmacHw_DMA_STOP(pCblk->module, pCblk->channel);\r\n}\r\nint dmacHw_freeMem(dmacHw_CONFIG_t *pConfig,\r\nvoid *pDescriptor,\r\nvoid (*fpFree) (void *)\r\n) {\r\ndmacHw_DESC_RING_t *pRing = dmacHw_GET_DESC_RING(pDescriptor);\r\nuint32_t count = 0;\r\nif (fpFree == NULL) {\r\nreturn -1;\r\n}\r\nwhile ((pRing->pFree != pRing->pTail)\r\n&& (pRing->pFree->ctl.lo & dmacHw_DESC_FREE)) {\r\nif (pRing->pFree->devCtl == dmacHw_FREE_USER_MEMORY) {\r\nif (dmacHw_DST_IS_MEMORY(pConfig->transferType)) {\r\n(*fpFree) ((void *)pRing->pFree->dar);\r\n} else {\r\n(*fpFree) ((void *)pRing->pFree->sar);\r\n}\r\npRing->pFree->devCtl = ~dmacHw_FREE_USER_MEMORY;\r\n}\r\ndmacHw_NEXT_DESC(pRing, pFree);\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nint dmacHw_setVariableDataDescriptor(dmacHw_HANDLE_t handle,\r\ndmacHw_CONFIG_t *pConfig,\r\nvoid *pDescriptor,\r\nuint32_t srcAddr,\r\nvoid *(*fpAlloc) (int len),\r\nint len,\r\nint num\r\n) {\r\ndmacHw_CBLK_t *pCblk = dmacHw_HANDLE_TO_CBLK(handle);\r\ndmacHw_DESC_t *pProg = NULL;\r\ndmacHw_DESC_t *pLast = NULL;\r\ndmacHw_DESC_RING_t *pRing = dmacHw_GET_DESC_RING(pDescriptor);\r\nuint32_t dstAddr;\r\nuint32_t controlParam;\r\nint i;\r\ndmacHw_ASSERT(pConfig->transferType ==\r\ndmacHw_TRANSFER_TYPE_PERIPHERAL_TO_MEM);\r\nif (num > pRing->num) {\r\nreturn -1;\r\n}\r\npLast = pRing->pEnd;\r\npProg = pRing->pHead;\r\ncontrolParam = pConfig->srcUpdate |\r\npConfig->dstUpdate |\r\npConfig->srcMaxTransactionWidth |\r\npConfig->dstMaxTransactionWidth |\r\npConfig->srcMasterInterface |\r\npConfig->dstMasterInterface |\r\npConfig->srcMaxBurstWidth |\r\npConfig->dstMaxBurstWidth |\r\ndmacHw_REG_CTL_TTFC_PM_PERI |\r\ndmacHw_REG_CTL_LLP_DST_EN |\r\ndmacHw_REG_CTL_LLP_SRC_EN | dmacHw_REG_CTL_INT_EN;\r\nfor (i = 0; i < num; i++) {\r\nif (((pRing->pHead->ctl.hi & dmacHw_DESC_FREE) == 0) ||\r\n((dmacHw_DESC_t *) pRing->pHead->llp == pRing->pTail)\r\n) {\r\nbreak;\r\n}\r\npRing->pHead->sar = srcAddr;\r\nif (fpAlloc) {\r\ndstAddr = (uint32_t) (*fpAlloc) (len);\r\nif (dstAddr == 0) {\r\nif (i == 0) {\r\nreturn -1;\r\n}\r\nbreak;\r\n}\r\npRing->pHead->dar = dstAddr;\r\n}\r\npRing->pHead->ctl.lo = controlParam;\r\npRing->pHead->devCtl = dmacHw_FREE_USER_MEMORY;\r\npRing->pHead->ctl.hi = 0;\r\npRing->pEnd = pRing->pHead;\r\ndmacHw_NEXT_DESC(pRing, pHead);\r\n}\r\npRing->pEnd->ctl.lo &=\r\n~(dmacHw_REG_CTL_LLP_DST_EN | dmacHw_REG_CTL_LLP_SRC_EN);\r\nif (pLast != pProg) {\r\npLast->ctl.lo |=\r\ndmacHw_REG_CTL_LLP_DST_EN | dmacHw_REG_CTL_LLP_SRC_EN;\r\n}\r\npCblk->descUpdated = 1;\r\nif (!pCblk->varDataStarted) {\r\ndmacHw_SET_LLP(pCblk->module, pCblk->channel,\r\n(uint32_t) pProg - pRing->virt2PhyOffset);\r\npCblk->varDataStarted = 1;\r\n}\r\nreturn i;\r\n}\r\nint dmacHw_readTransferredData(dmacHw_HANDLE_t handle,\r\ndmacHw_CONFIG_t *pConfig,\r\nvoid *pDescriptor,\r\nvoid **ppBbuf,\r\nsize_t *pLlen\r\n) {\r\ndmacHw_DESC_RING_t *pRing = dmacHw_GET_DESC_RING(pDescriptor);\r\n(void)handle;\r\nif (pConfig->transferMode != dmacHw_TRANSFER_MODE_CONTINUOUS) {\r\nif (((pRing->pTail->ctl.hi & dmacHw_DESC_FREE) == 0) ||\r\n(pRing->pTail == pRing->pHead)\r\n) {\r\n*ppBbuf = (char *)NULL;\r\n*pLlen = 0;\r\nreturn 0;\r\n}\r\n}\r\n*ppBbuf = (char *)pRing->pTail->dar;\r\nif (DmaIsFlowController(pDescriptor)) {\r\nuint32_t srcTrSize = 0;\r\nswitch (pRing->pTail->ctl.lo & dmacHw_REG_CTL_SRC_TR_WIDTH_MASK) {\r\ncase dmacHw_REG_CTL_SRC_TR_WIDTH_8:\r\nsrcTrSize = 1;\r\nbreak;\r\ncase dmacHw_REG_CTL_SRC_TR_WIDTH_16:\r\nsrcTrSize = 2;\r\nbreak;\r\ncase dmacHw_REG_CTL_SRC_TR_WIDTH_32:\r\nsrcTrSize = 4;\r\nbreak;\r\ncase dmacHw_REG_CTL_SRC_TR_WIDTH_64:\r\nsrcTrSize = 8;\r\nbreak;\r\ndefault:\r\ndmacHw_ASSERT(0);\r\n}\r\n*pLlen =\r\n(pRing->pTail->ctl.hi & dmacHw_REG_CTL_BLOCK_TS_MASK) *\r\nsrcTrSize;\r\n} else {\r\n*pLlen = pRing->pTail->sstat;\r\n}\r\ndmacHw_NEXT_DESC(pRing, pTail);\r\nreturn 1;\r\n}\r\nint dmacHw_setControlDescriptor(dmacHw_CONFIG_t *pConfig,\r\nvoid *pDescriptor,\r\nuint32_t ctlAddress,\r\nuint32_t control\r\n) {\r\ndmacHw_DESC_RING_t *pRing = dmacHw_GET_DESC_RING(pDescriptor);\r\nif (ctlAddress == 0) {\r\nreturn -1;\r\n}\r\nif ((pRing->pHead->ctl.hi & dmacHw_DESC_FREE) == 0) {\r\nreturn -1;\r\n}\r\npRing->pHead->devCtl = control;\r\npRing->pHead->sar = (uint32_t) &pRing->pHead->devCtl;\r\npRing->pHead->dar = ctlAddress;\r\nif (pConfig->flowControler == dmacHw_FLOW_CONTROL_DMA) {\r\npRing->pHead->ctl.lo = pConfig->transferType |\r\ndmacHw_SRC_ADDRESS_UPDATE_MODE_INC |\r\ndmacHw_DST_ADDRESS_UPDATE_MODE_INC |\r\ndmacHw_SRC_TRANSACTION_WIDTH_32 |\r\npConfig->dstMaxTransactionWidth |\r\ndmacHw_SRC_BURST_WIDTH_0 |\r\ndmacHw_DST_BURST_WIDTH_0 |\r\npConfig->srcMasterInterface |\r\npConfig->dstMasterInterface | dmacHw_REG_CTL_INT_EN;\r\n} else {\r\nuint32_t transferType = 0;\r\nswitch (pConfig->transferType) {\r\ncase dmacHw_TRANSFER_TYPE_PERIPHERAL_TO_MEM:\r\ntransferType = dmacHw_REG_CTL_TTFC_PM_PERI;\r\nbreak;\r\ncase dmacHw_TRANSFER_TYPE_MEM_TO_PERIPHERAL:\r\ntransferType = dmacHw_REG_CTL_TTFC_MP_PERI;\r\nbreak;\r\ndefault:\r\ndmacHw_ASSERT(0);\r\n}\r\npRing->pHead->ctl.lo = transferType |\r\ndmacHw_SRC_ADDRESS_UPDATE_MODE_INC |\r\ndmacHw_DST_ADDRESS_UPDATE_MODE_INC |\r\ndmacHw_SRC_TRANSACTION_WIDTH_32 |\r\npConfig->dstMaxTransactionWidth |\r\ndmacHw_SRC_BURST_WIDTH_0 |\r\ndmacHw_DST_BURST_WIDTH_0 |\r\npConfig->srcMasterInterface |\r\npConfig->dstMasterInterface |\r\npConfig->flowControler | dmacHw_REG_CTL_INT_EN;\r\n}\r\npRing->pHead->ctl.hi = dmacHw_REG_CTL_BLOCK_TS_MASK & 1;\r\nif (pRing->pProg == dmacHw_DESC_INIT) {\r\npRing->pProg = pRing->pHead;\r\n}\r\npRing->pEnd = pRing->pHead;\r\ndmacHw_NEXT_DESC(pRing, pHead);\r\nif (!dmacHw_DST_IS_MEMORY(pConfig->transferType)) {\r\npRing->pTail = pRing->pHead;\r\n}\r\nreturn 0;\r\n}\r\nvoid dmacHw_setChannelUserData(dmacHw_HANDLE_t handle,\r\nvoid *userData\r\n) {\r\ndmacHw_CBLK_t *pCblk = dmacHw_HANDLE_TO_CBLK(handle);\r\npCblk->userData = userData;\r\n}\r\nvoid *dmacHw_getChannelUserData(dmacHw_HANDLE_t handle\r\n) {\r\ndmacHw_CBLK_t *pCblk = dmacHw_HANDLE_TO_CBLK(handle);\r\nreturn pCblk->userData;\r\n}\r\nvoid dmacHw_resetDescriptorControl(void *pDescriptor\r\n) {\r\nint i;\r\ndmacHw_DESC_RING_t *pRing;\r\ndmacHw_DESC_t *pDesc;\r\npRing = dmacHw_GET_DESC_RING(pDescriptor);\r\npDesc = pRing->pHead;\r\nfor (i = 0; i < pRing->num; i++) {\r\npDesc->ctl.hi = dmacHw_DESC_FREE;\r\npDesc++;\r\n}\r\npRing->pFree = pRing->pTail = pRing->pEnd = pRing->pHead;\r\npRing->pProg = dmacHw_DESC_INIT;\r\n}\r\nvoid dmacHw_printDebugInfo(dmacHw_HANDLE_t handle,\r\nvoid *pDescriptor,\r\nint (*fpPrint) (const char *, ...)\r\n) {\r\ndmacHw_CBLK_t *pCblk = dmacHw_HANDLE_TO_CBLK(handle);\r\nDisplayRegisterContents(pCblk->module, pCblk->channel, fpPrint);\r\nDisplayDescRing(pDescriptor, fpPrint);\r\n}
