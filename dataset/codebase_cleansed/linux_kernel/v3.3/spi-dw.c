static int spi_show_regs_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = inode->i_private;\r\nreturn 0;\r\n}\r\nstatic ssize_t spi_show_regs(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct dw_spi *dws;\r\nchar *buf;\r\nu32 len = 0;\r\nssize_t ret;\r\ndws = file->private_data;\r\nbuf = kzalloc(SPI_REGS_BUFSIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn 0;\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"MRST SPI0 registers:\n");\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"=================================\n");\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"CTRL0: \t\t0x%08x\n", dw_readl(dws, DW_SPI_CTRL0));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"CTRL1: \t\t0x%08x\n", dw_readl(dws, DW_SPI_CTRL1));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"SSIENR: \t0x%08x\n", dw_readl(dws, DW_SPI_SSIENR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"SER: \t\t0x%08x\n", dw_readl(dws, DW_SPI_SER));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"BAUDR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_BAUDR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"TXFTLR: \t0x%08x\n", dw_readl(dws, DW_SPI_TXFLTR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"RXFTLR: \t0x%08x\n", dw_readl(dws, DW_SPI_RXFLTR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"TXFLR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_TXFLR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"RXFLR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_RXFLR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"SR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_SR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"IMR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_IMR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"ISR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_ISR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"DMACR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_DMACR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"DMATDLR: \t0x%08x\n", dw_readl(dws, DW_SPI_DMATDLR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"DMARDLR: \t0x%08x\n", dw_readl(dws, DW_SPI_DMARDLR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"=================================\n");\r\nret = simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int mrst_spi_debugfs_init(struct dw_spi *dws)\r\n{\r\ndws->debugfs = debugfs_create_dir("mrst_spi", NULL);\r\nif (!dws->debugfs)\r\nreturn -ENOMEM;\r\ndebugfs_create_file("registers", S_IFREG | S_IRUGO,\r\ndws->debugfs, (void *)dws, &mrst_spi_regs_ops);\r\nreturn 0;\r\n}\r\nstatic void mrst_spi_debugfs_remove(struct dw_spi *dws)\r\n{\r\nif (dws->debugfs)\r\ndebugfs_remove_recursive(dws->debugfs);\r\n}\r\nstatic inline int mrst_spi_debugfs_init(struct dw_spi *dws)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void mrst_spi_debugfs_remove(struct dw_spi *dws)\r\n{\r\n}\r\nstatic inline u32 tx_max(struct dw_spi *dws)\r\n{\r\nu32 tx_left, tx_room, rxtx_gap;\r\ntx_left = (dws->tx_end - dws->tx) / dws->n_bytes;\r\ntx_room = dws->fifo_len - dw_readw(dws, DW_SPI_TXFLR);\r\nrxtx_gap = ((dws->rx_end - dws->rx) - (dws->tx_end - dws->tx))\r\n/ dws->n_bytes;\r\nreturn min3(tx_left, tx_room, (u32) (dws->fifo_len - rxtx_gap));\r\n}\r\nstatic inline u32 rx_max(struct dw_spi *dws)\r\n{\r\nu32 rx_left = (dws->rx_end - dws->rx) / dws->n_bytes;\r\nreturn min(rx_left, (u32)dw_readw(dws, DW_SPI_RXFLR));\r\n}\r\nstatic void dw_writer(struct dw_spi *dws)\r\n{\r\nu32 max = tx_max(dws);\r\nu16 txw = 0;\r\nwhile (max--) {\r\nif (dws->tx_end - dws->len) {\r\nif (dws->n_bytes == 1)\r\ntxw = *(u8 *)(dws->tx);\r\nelse\r\ntxw = *(u16 *)(dws->tx);\r\n}\r\ndw_writew(dws, DW_SPI_DR, txw);\r\ndws->tx += dws->n_bytes;\r\n}\r\n}\r\nstatic void dw_reader(struct dw_spi *dws)\r\n{\r\nu32 max = rx_max(dws);\r\nu16 rxw;\r\nwhile (max--) {\r\nrxw = dw_readw(dws, DW_SPI_DR);\r\nif (dws->rx_end - dws->len) {\r\nif (dws->n_bytes == 1)\r\n*(u8 *)(dws->rx) = rxw;\r\nelse\r\n*(u16 *)(dws->rx) = rxw;\r\n}\r\ndws->rx += dws->n_bytes;\r\n}\r\n}\r\nstatic void *next_transfer(struct dw_spi *dws)\r\n{\r\nstruct spi_message *msg = dws->cur_msg;\r\nstruct spi_transfer *trans = dws->cur_transfer;\r\nif (trans->transfer_list.next != &msg->transfers) {\r\ndws->cur_transfer =\r\nlist_entry(trans->transfer_list.next,\r\nstruct spi_transfer,\r\ntransfer_list);\r\nreturn RUNNING_STATE;\r\n} else\r\nreturn DONE_STATE;\r\n}\r\nstatic int map_dma_buffers(struct dw_spi *dws)\r\n{\r\nif (!dws->cur_msg->is_dma_mapped\r\n|| !dws->dma_inited\r\n|| !dws->cur_chip->enable_dma\r\n|| !dws->dma_ops)\r\nreturn 0;\r\nif (dws->cur_transfer->tx_dma)\r\ndws->tx_dma = dws->cur_transfer->tx_dma;\r\nif (dws->cur_transfer->rx_dma)\r\ndws->rx_dma = dws->cur_transfer->rx_dma;\r\nreturn 1;\r\n}\r\nstatic void giveback(struct dw_spi *dws)\r\n{\r\nstruct spi_transfer *last_transfer;\r\nunsigned long flags;\r\nstruct spi_message *msg;\r\nspin_lock_irqsave(&dws->lock, flags);\r\nmsg = dws->cur_msg;\r\ndws->cur_msg = NULL;\r\ndws->cur_transfer = NULL;\r\ndws->prev_chip = dws->cur_chip;\r\ndws->cur_chip = NULL;\r\ndws->dma_mapped = 0;\r\nqueue_work(dws->workqueue, &dws->pump_messages);\r\nspin_unlock_irqrestore(&dws->lock, flags);\r\nlast_transfer = list_entry(msg->transfers.prev,\r\nstruct spi_transfer,\r\ntransfer_list);\r\nif (!last_transfer->cs_change && dws->cs_control)\r\ndws->cs_control(MRST_SPI_DEASSERT);\r\nmsg->state = NULL;\r\nif (msg->complete)\r\nmsg->complete(msg->context);\r\n}\r\nstatic void int_error_stop(struct dw_spi *dws, const char *msg)\r\n{\r\nspi_enable_chip(dws, 0);\r\ndev_err(&dws->master->dev, "%s\n", msg);\r\ndws->cur_msg->state = ERROR_STATE;\r\ntasklet_schedule(&dws->pump_transfers);\r\n}\r\nvoid dw_spi_xfer_done(struct dw_spi *dws)\r\n{\r\ndws->cur_msg->actual_length += dws->len;\r\ndws->cur_msg->state = next_transfer(dws);\r\nif (dws->cur_msg->state == DONE_STATE) {\r\ndws->cur_msg->status = 0;\r\ngiveback(dws);\r\n} else\r\ntasklet_schedule(&dws->pump_transfers);\r\n}\r\nstatic irqreturn_t interrupt_transfer(struct dw_spi *dws)\r\n{\r\nu16 irq_status = dw_readw(dws, DW_SPI_ISR);\r\nif (irq_status & (SPI_INT_TXOI | SPI_INT_RXOI | SPI_INT_RXUI)) {\r\ndw_readw(dws, DW_SPI_TXOICR);\r\ndw_readw(dws, DW_SPI_RXOICR);\r\ndw_readw(dws, DW_SPI_RXUICR);\r\nint_error_stop(dws, "interrupt_transfer: fifo overrun/underrun");\r\nreturn IRQ_HANDLED;\r\n}\r\ndw_reader(dws);\r\nif (dws->rx_end == dws->rx) {\r\nspi_mask_intr(dws, SPI_INT_TXEI);\r\ndw_spi_xfer_done(dws);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (irq_status & SPI_INT_TXEI) {\r\nspi_mask_intr(dws, SPI_INT_TXEI);\r\ndw_writer(dws);\r\nspi_umask_intr(dws, SPI_INT_TXEI);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t dw_spi_irq(int irq, void *dev_id)\r\n{\r\nstruct dw_spi *dws = dev_id;\r\nu16 irq_status = dw_readw(dws, DW_SPI_ISR) & 0x3f;\r\nif (!irq_status)\r\nreturn IRQ_NONE;\r\nif (!dws->cur_msg) {\r\nspi_mask_intr(dws, SPI_INT_TXEI);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn dws->transfer_handler(dws);\r\n}\r\nstatic void poll_transfer(struct dw_spi *dws)\r\n{\r\ndo {\r\ndw_writer(dws);\r\ndw_reader(dws);\r\ncpu_relax();\r\n} while (dws->rx_end > dws->rx);\r\ndw_spi_xfer_done(dws);\r\n}\r\nstatic void pump_transfers(unsigned long data)\r\n{\r\nstruct dw_spi *dws = (struct dw_spi *)data;\r\nstruct spi_message *message = NULL;\r\nstruct spi_transfer *transfer = NULL;\r\nstruct spi_transfer *previous = NULL;\r\nstruct spi_device *spi = NULL;\r\nstruct chip_data *chip = NULL;\r\nu8 bits = 0;\r\nu8 imask = 0;\r\nu8 cs_change = 0;\r\nu16 txint_level = 0;\r\nu16 clk_div = 0;\r\nu32 speed = 0;\r\nu32 cr0 = 0;\r\nmessage = dws->cur_msg;\r\ntransfer = dws->cur_transfer;\r\nchip = dws->cur_chip;\r\nspi = message->spi;\r\nif (unlikely(!chip->clk_div))\r\nchip->clk_div = dws->max_freq / chip->speed_hz;\r\nif (message->state == ERROR_STATE) {\r\nmessage->status = -EIO;\r\ngoto early_exit;\r\n}\r\nif (message->state == DONE_STATE) {\r\nmessage->status = 0;\r\ngoto early_exit;\r\n}\r\nif (message->state == RUNNING_STATE) {\r\nprevious = list_entry(transfer->transfer_list.prev,\r\nstruct spi_transfer,\r\ntransfer_list);\r\nif (previous->delay_usecs)\r\nudelay(previous->delay_usecs);\r\n}\r\ndws->n_bytes = chip->n_bytes;\r\ndws->dma_width = chip->dma_width;\r\ndws->cs_control = chip->cs_control;\r\ndws->rx_dma = transfer->rx_dma;\r\ndws->tx_dma = transfer->tx_dma;\r\ndws->tx = (void *)transfer->tx_buf;\r\ndws->tx_end = dws->tx + transfer->len;\r\ndws->rx = transfer->rx_buf;\r\ndws->rx_end = dws->rx + transfer->len;\r\ndws->cs_change = transfer->cs_change;\r\ndws->len = dws->cur_transfer->len;\r\nif (chip != dws->prev_chip)\r\ncs_change = 1;\r\ncr0 = chip->cr0;\r\nif (transfer->speed_hz) {\r\nspeed = chip->speed_hz;\r\nif (transfer->speed_hz != speed) {\r\nspeed = transfer->speed_hz;\r\nif (speed > dws->max_freq) {\r\nprintk(KERN_ERR "MRST SPI0: unsupported"\r\n"freq: %dHz\n", speed);\r\nmessage->status = -EIO;\r\ngoto early_exit;\r\n}\r\nclk_div = dws->max_freq / speed;\r\nclk_div = (clk_div + 1) & 0xfffe;\r\nchip->speed_hz = speed;\r\nchip->clk_div = clk_div;\r\n}\r\n}\r\nif (transfer->bits_per_word) {\r\nbits = transfer->bits_per_word;\r\nswitch (bits) {\r\ncase 8:\r\ncase 16:\r\ndws->n_bytes = dws->dma_width = bits >> 3;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "MRST SPI0: unsupported bits:"\r\n"%db\n", bits);\r\nmessage->status = -EIO;\r\ngoto early_exit;\r\n}\r\ncr0 = (bits - 1)\r\n| (chip->type << SPI_FRF_OFFSET)\r\n| (spi->mode << SPI_MODE_OFFSET)\r\n| (chip->tmode << SPI_TMOD_OFFSET);\r\n}\r\nmessage->state = RUNNING_STATE;\r\nif (dws->cs_control) {\r\nif (dws->rx && dws->tx)\r\nchip->tmode = SPI_TMOD_TR;\r\nelse if (dws->rx)\r\nchip->tmode = SPI_TMOD_RO;\r\nelse\r\nchip->tmode = SPI_TMOD_TO;\r\ncr0 &= ~SPI_TMOD_MASK;\r\ncr0 |= (chip->tmode << SPI_TMOD_OFFSET);\r\n}\r\ndws->dma_mapped = map_dma_buffers(dws);\r\nif (!dws->dma_mapped && !chip->poll_mode) {\r\nint templen = dws->len / dws->n_bytes;\r\ntxint_level = dws->fifo_len / 2;\r\ntxint_level = (templen > txint_level) ? txint_level : templen;\r\nimask |= SPI_INT_TXEI | SPI_INT_TXOI | SPI_INT_RXUI | SPI_INT_RXOI;\r\ndws->transfer_handler = interrupt_transfer;\r\n}\r\nif (dw_readw(dws, DW_SPI_CTRL0) != cr0 || cs_change || clk_div || imask) {\r\nspi_enable_chip(dws, 0);\r\nif (dw_readw(dws, DW_SPI_CTRL0) != cr0)\r\ndw_writew(dws, DW_SPI_CTRL0, cr0);\r\nspi_set_clk(dws, clk_div ? clk_div : chip->clk_div);\r\nspi_chip_sel(dws, spi->chip_select);\r\nspi_mask_intr(dws, 0xff);\r\nif (imask)\r\nspi_umask_intr(dws, imask);\r\nif (txint_level)\r\ndw_writew(dws, DW_SPI_TXFLTR, txint_level);\r\nspi_enable_chip(dws, 1);\r\nif (cs_change)\r\ndws->prev_chip = chip;\r\n}\r\nif (dws->dma_mapped)\r\ndws->dma_ops->dma_transfer(dws, cs_change);\r\nif (chip->poll_mode)\r\npoll_transfer(dws);\r\nreturn;\r\nearly_exit:\r\ngiveback(dws);\r\nreturn;\r\n}\r\nstatic void pump_messages(struct work_struct *work)\r\n{\r\nstruct dw_spi *dws =\r\ncontainer_of(work, struct dw_spi, pump_messages);\r\nunsigned long flags;\r\nspin_lock_irqsave(&dws->lock, flags);\r\nif (list_empty(&dws->queue) || dws->run == QUEUE_STOPPED) {\r\ndws->busy = 0;\r\nspin_unlock_irqrestore(&dws->lock, flags);\r\nreturn;\r\n}\r\nif (dws->cur_msg) {\r\nspin_unlock_irqrestore(&dws->lock, flags);\r\nreturn;\r\n}\r\ndws->cur_msg = list_entry(dws->queue.next, struct spi_message, queue);\r\nlist_del_init(&dws->cur_msg->queue);\r\ndws->cur_msg->state = START_STATE;\r\ndws->cur_transfer = list_entry(dws->cur_msg->transfers.next,\r\nstruct spi_transfer,\r\ntransfer_list);\r\ndws->cur_chip = spi_get_ctldata(dws->cur_msg->spi);\r\ntasklet_schedule(&dws->pump_transfers);\r\ndws->busy = 1;\r\nspin_unlock_irqrestore(&dws->lock, flags);\r\n}\r\nstatic int dw_spi_transfer(struct spi_device *spi, struct spi_message *msg)\r\n{\r\nstruct dw_spi *dws = spi_master_get_devdata(spi->master);\r\nunsigned long flags;\r\nspin_lock_irqsave(&dws->lock, flags);\r\nif (dws->run == QUEUE_STOPPED) {\r\nspin_unlock_irqrestore(&dws->lock, flags);\r\nreturn -ESHUTDOWN;\r\n}\r\nmsg->actual_length = 0;\r\nmsg->status = -EINPROGRESS;\r\nmsg->state = START_STATE;\r\nlist_add_tail(&msg->queue, &dws->queue);\r\nif (dws->run == QUEUE_RUNNING && !dws->busy) {\r\nif (dws->cur_transfer || dws->cur_msg)\r\nqueue_work(dws->workqueue,\r\n&dws->pump_messages);\r\nelse {\r\nspin_unlock_irqrestore(&dws->lock, flags);\r\npump_messages(&dws->pump_messages);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dws->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dw_spi_setup(struct spi_device *spi)\r\n{\r\nstruct dw_spi_chip *chip_info = NULL;\r\nstruct chip_data *chip;\r\nif (spi->bits_per_word != 8 && spi->bits_per_word != 16)\r\nreturn -EINVAL;\r\nchip = spi_get_ctldata(spi);\r\nif (!chip) {\r\nchip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\n}\r\nchip_info = spi->controller_data;\r\nif (chip_info) {\r\nif (chip_info->cs_control)\r\nchip->cs_control = chip_info->cs_control;\r\nchip->poll_mode = chip_info->poll_mode;\r\nchip->type = chip_info->type;\r\nchip->rx_threshold = 0;\r\nchip->tx_threshold = 0;\r\nchip->enable_dma = chip_info->enable_dma;\r\n}\r\nif (spi->bits_per_word <= 8) {\r\nchip->n_bytes = 1;\r\nchip->dma_width = 1;\r\n} else if (spi->bits_per_word <= 16) {\r\nchip->n_bytes = 2;\r\nchip->dma_width = 2;\r\n} else {\r\ndev_err(&spi->dev, "invalid wordsize\n");\r\nreturn -EINVAL;\r\n}\r\nchip->bits_per_word = spi->bits_per_word;\r\nif (!spi->max_speed_hz) {\r\ndev_err(&spi->dev, "No max speed HZ parameter\n");\r\nreturn -EINVAL;\r\n}\r\nchip->speed_hz = spi->max_speed_hz;\r\nchip->tmode = 0;\r\nchip->cr0 = (chip->bits_per_word - 1)\r\n| (chip->type << SPI_FRF_OFFSET)\r\n| (spi->mode << SPI_MODE_OFFSET)\r\n| (chip->tmode << SPI_TMOD_OFFSET);\r\nspi_set_ctldata(spi, chip);\r\nreturn 0;\r\n}\r\nstatic void dw_spi_cleanup(struct spi_device *spi)\r\n{\r\nstruct chip_data *chip = spi_get_ctldata(spi);\r\nkfree(chip);\r\n}\r\nstatic int __devinit init_queue(struct dw_spi *dws)\r\n{\r\nINIT_LIST_HEAD(&dws->queue);\r\nspin_lock_init(&dws->lock);\r\ndws->run = QUEUE_STOPPED;\r\ndws->busy = 0;\r\ntasklet_init(&dws->pump_transfers,\r\npump_transfers, (unsigned long)dws);\r\nINIT_WORK(&dws->pump_messages, pump_messages);\r\ndws->workqueue = create_singlethread_workqueue(\r\ndev_name(dws->master->dev.parent));\r\nif (dws->workqueue == NULL)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int start_queue(struct dw_spi *dws)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dws->lock, flags);\r\nif (dws->run == QUEUE_RUNNING || dws->busy) {\r\nspin_unlock_irqrestore(&dws->lock, flags);\r\nreturn -EBUSY;\r\n}\r\ndws->run = QUEUE_RUNNING;\r\ndws->cur_msg = NULL;\r\ndws->cur_transfer = NULL;\r\ndws->cur_chip = NULL;\r\ndws->prev_chip = NULL;\r\nspin_unlock_irqrestore(&dws->lock, flags);\r\nqueue_work(dws->workqueue, &dws->pump_messages);\r\nreturn 0;\r\n}\r\nstatic int stop_queue(struct dw_spi *dws)\r\n{\r\nunsigned long flags;\r\nunsigned limit = 50;\r\nint status = 0;\r\nspin_lock_irqsave(&dws->lock, flags);\r\ndws->run = QUEUE_STOPPED;\r\nwhile ((!list_empty(&dws->queue) || dws->busy) && limit--) {\r\nspin_unlock_irqrestore(&dws->lock, flags);\r\nmsleep(10);\r\nspin_lock_irqsave(&dws->lock, flags);\r\n}\r\nif (!list_empty(&dws->queue) || dws->busy)\r\nstatus = -EBUSY;\r\nspin_unlock_irqrestore(&dws->lock, flags);\r\nreturn status;\r\n}\r\nstatic int destroy_queue(struct dw_spi *dws)\r\n{\r\nint status;\r\nstatus = stop_queue(dws);\r\nif (status != 0)\r\nreturn status;\r\ndestroy_workqueue(dws->workqueue);\r\nreturn 0;\r\n}\r\nstatic void spi_hw_init(struct dw_spi *dws)\r\n{\r\nspi_enable_chip(dws, 0);\r\nspi_mask_intr(dws, 0xff);\r\nspi_enable_chip(dws, 1);\r\nif (!dws->fifo_len) {\r\nu32 fifo;\r\nfor (fifo = 2; fifo <= 257; fifo++) {\r\ndw_writew(dws, DW_SPI_TXFLTR, fifo);\r\nif (fifo != dw_readw(dws, DW_SPI_TXFLTR))\r\nbreak;\r\n}\r\ndws->fifo_len = (fifo == 257) ? 0 : fifo;\r\ndw_writew(dws, DW_SPI_TXFLTR, 0);\r\n}\r\n}\r\nint __devinit dw_spi_add_host(struct dw_spi *dws)\r\n{\r\nstruct spi_master *master;\r\nint ret;\r\nBUG_ON(dws == NULL);\r\nmaster = spi_alloc_master(dws->parent_dev, 0);\r\nif (!master) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\ndws->master = master;\r\ndws->type = SSI_MOTO_SPI;\r\ndws->prev_chip = NULL;\r\ndws->dma_inited = 0;\r\ndws->dma_addr = (dma_addr_t)(dws->paddr + 0x60);\r\nsnprintf(dws->name, sizeof(dws->name), "dw_spi%d",\r\ndws->bus_num);\r\nret = request_irq(dws->irq, dw_spi_irq, IRQF_SHARED,\r\ndws->name, dws);\r\nif (ret < 0) {\r\ndev_err(&master->dev, "can not get IRQ\n");\r\ngoto err_free_master;\r\n}\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA;\r\nmaster->bus_num = dws->bus_num;\r\nmaster->num_chipselect = dws->num_cs;\r\nmaster->cleanup = dw_spi_cleanup;\r\nmaster->setup = dw_spi_setup;\r\nmaster->transfer = dw_spi_transfer;\r\nspi_hw_init(dws);\r\nif (dws->dma_ops && dws->dma_ops->dma_init) {\r\nret = dws->dma_ops->dma_init(dws);\r\nif (ret) {\r\ndev_warn(&master->dev, "DMA init failed\n");\r\ndws->dma_inited = 0;\r\n}\r\n}\r\nret = init_queue(dws);\r\nif (ret) {\r\ndev_err(&master->dev, "problem initializing queue\n");\r\ngoto err_diable_hw;\r\n}\r\nret = start_queue(dws);\r\nif (ret) {\r\ndev_err(&master->dev, "problem starting queue\n");\r\ngoto err_diable_hw;\r\n}\r\nspi_master_set_devdata(master, dws);\r\nret = spi_register_master(master);\r\nif (ret) {\r\ndev_err(&master->dev, "problem registering spi master\n");\r\ngoto err_queue_alloc;\r\n}\r\nmrst_spi_debugfs_init(dws);\r\nreturn 0;\r\nerr_queue_alloc:\r\ndestroy_queue(dws);\r\nif (dws->dma_ops && dws->dma_ops->dma_exit)\r\ndws->dma_ops->dma_exit(dws);\r\nerr_diable_hw:\r\nspi_enable_chip(dws, 0);\r\nfree_irq(dws->irq, dws);\r\nerr_free_master:\r\nspi_master_put(master);\r\nexit:\r\nreturn ret;\r\n}\r\nvoid __devexit dw_spi_remove_host(struct dw_spi *dws)\r\n{\r\nint status = 0;\r\nif (!dws)\r\nreturn;\r\nmrst_spi_debugfs_remove(dws);\r\nstatus = destroy_queue(dws);\r\nif (status != 0)\r\ndev_err(&dws->master->dev, "dw_spi_remove: workqueue will not "\r\n"complete, message memory not freed\n");\r\nif (dws->dma_ops && dws->dma_ops->dma_exit)\r\ndws->dma_ops->dma_exit(dws);\r\nspi_enable_chip(dws, 0);\r\nspi_set_clk(dws, 0);\r\nfree_irq(dws->irq, dws);\r\nspi_unregister_master(dws->master);\r\n}\r\nint dw_spi_suspend_host(struct dw_spi *dws)\r\n{\r\nint ret = 0;\r\nret = stop_queue(dws);\r\nif (ret)\r\nreturn ret;\r\nspi_enable_chip(dws, 0);\r\nspi_set_clk(dws, 0);\r\nreturn ret;\r\n}\r\nint dw_spi_resume_host(struct dw_spi *dws)\r\n{\r\nint ret;\r\nspi_hw_init(dws);\r\nret = start_queue(dws);\r\nif (ret)\r\ndev_err(&dws->master->dev, "fail to start queue (%d)\n", ret);\r\nreturn ret;\r\n}
