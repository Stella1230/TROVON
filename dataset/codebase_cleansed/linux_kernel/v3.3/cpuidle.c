static int at91_enter_idle(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nstruct timeval before, after;\r\nint idle_time;\r\nu32 saved_lpr;\r\nlocal_irq_disable();\r\ndo_gettimeofday(&before);\r\nif (index == 0)\r\ncpu_do_idle();\r\nelse if (index == 1) {\r\nasm("b 1f; .align 5; 1:");\r\nasm("mcr p15, 0, r0, c7, c10, 4");\r\nsaved_lpr = sdram_selfrefresh_enable();\r\ncpu_do_idle();\r\nsdram_selfrefresh_disable(saved_lpr);\r\n}\r\ndo_gettimeofday(&after);\r\nlocal_irq_enable();\r\nidle_time = (after.tv_sec - before.tv_sec) * USEC_PER_SEC +\r\n(after.tv_usec - before.tv_usec);\r\ndev->last_residency = idle_time;\r\nreturn index;\r\n}\r\nstatic int at91_init_cpuidle(void)\r\n{\r\nstruct cpuidle_device *device;\r\nstruct cpuidle_driver *driver = &at91_idle_driver;\r\ndevice = &per_cpu(at91_cpuidle_device, smp_processor_id());\r\ndevice->state_count = AT91_MAX_STATES;\r\ndriver->state_count = AT91_MAX_STATES;\r\ndriver->states[0].enter = at91_enter_idle;\r\ndriver->states[0].exit_latency = 1;\r\ndriver->states[0].target_residency = 10000;\r\ndriver->states[0].flags = CPUIDLE_FLAG_TIME_VALID;\r\nstrcpy(driver->states[0].name, "WFI");\r\nstrcpy(driver->states[0].desc, "Wait for interrupt");\r\ndriver->states[1].enter = at91_enter_idle;\r\ndriver->states[1].exit_latency = 10;\r\ndriver->states[1].target_residency = 10000;\r\ndriver->states[1].flags = CPUIDLE_FLAG_TIME_VALID;\r\nstrcpy(driver->states[1].name, "RAM_SR");\r\nstrcpy(driver->states[1].desc, "WFI and RAM Self Refresh");\r\ncpuidle_register_driver(&at91_idle_driver);\r\nif (cpuidle_register_device(device)) {\r\nprintk(KERN_ERR "at91_init_cpuidle: Failed registering\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}
