static int\r\nemu8k_open_dram_for_pcm(struct snd_emu8000 *emu, int channels)\r\n{\r\nint i;\r\nsnd_emux_lock_voice(emu->emu, 0);\r\nif (channels > 1)\r\nsnd_emux_lock_voice(emu->emu, 1);\r\nfor (i = channels + 1; i < EMU8000_DRAM_VOICES; i++) {\r\nunsigned int mode = EMU8000_RAM_WRITE;\r\nsnd_emux_lock_voice(emu->emu, i);\r\n#ifndef USE_NONINTERLEAVE\r\nif (channels > 1 && (i & 1) != 0)\r\nmode |= EMU8000_RAM_RIGHT;\r\n#endif\r\nsnd_emu8000_dma_chan(emu, i, mode);\r\n}\r\nEMU8000_VTFT_WRITE(emu, 30, 0);\r\nEMU8000_PSST_WRITE(emu, 30, 0x1d8);\r\nEMU8000_CSL_WRITE(emu, 30, 0x1e0);\r\nEMU8000_CCCA_WRITE(emu, 30, 0x1d8);\r\nEMU8000_VTFT_WRITE(emu, 31, 0);\r\nEMU8000_PSST_WRITE(emu, 31, 0x1d8);\r\nEMU8000_CSL_WRITE(emu, 31, 0x1e0);\r\nEMU8000_CCCA_WRITE(emu, 31, 0x1d8);\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_emu8000_write_wait(struct snd_emu8000 *emu, int can_schedule)\r\n{\r\nwhile ((EMU8000_SMALW_READ(emu) & 0x80000000) != 0) {\r\nif (can_schedule) {\r\nschedule_timeout_interruptible(1);\r\nif (signal_pending(current))\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\nemu8k_close_dram(struct snd_emu8000 *emu)\r\n{\r\nint i;\r\nfor (i = 0; i < 2; i++)\r\nsnd_emux_unlock_voice(emu->emu, i);\r\nfor (; i < EMU8000_DRAM_VOICES; i++) {\r\nsnd_emu8000_dma_chan(emu, i, EMU8000_RAM_CLOSE);\r\nsnd_emux_unlock_voice(emu->emu, i);\r\n}\r\n}\r\nstatic int calc_rate_offset(int hz)\r\n{\r\nreturn snd_sf_linear_to_log(hz, OFFSET_SAMPLERATE, SAMPLERATE_RATIO);\r\n}\r\nstatic inline int emu8k_get_curpos(struct snd_emu8k_pcm *rec, int ch)\r\n{\r\nint val = EMU8000_CCCA_READ(rec->emu, ch) & 0xfffffff;\r\nval -= rec->loop_start[ch] - 1;\r\nreturn val;\r\n}\r\nstatic void emu8k_pcm_timer_func(unsigned long data)\r\n{\r\nstruct snd_emu8k_pcm *rec = (struct snd_emu8k_pcm *)data;\r\nint ptr, delta;\r\nspin_lock(&rec->timer_lock);\r\nptr = emu8k_get_curpos(rec, 0);\r\nif (ptr < rec->last_ptr)\r\ndelta = ptr + rec->buf_size - rec->last_ptr;\r\nelse\r\ndelta = ptr - rec->last_ptr;\r\nrec->period_pos += delta;\r\nrec->last_ptr = ptr;\r\nrec->timer.expires = jiffies + 1;\r\nadd_timer(&rec->timer);\r\nif (rec->period_pos >= (int)rec->period_size) {\r\nrec->period_pos %= rec->period_size;\r\nspin_unlock(&rec->timer_lock);\r\nsnd_pcm_period_elapsed(rec->substream);\r\nreturn;\r\n}\r\nspin_unlock(&rec->timer_lock);\r\n}\r\nstatic int emu8k_pcm_open(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_emu8000 *emu = snd_pcm_substream_chip(subs);\r\nstruct snd_emu8k_pcm *rec;\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nrec = kzalloc(sizeof(*rec), GFP_KERNEL);\r\nif (! rec)\r\nreturn -ENOMEM;\r\nrec->emu = emu;\r\nrec->substream = subs;\r\nruntime->private_data = rec;\r\nspin_lock_init(&rec->timer_lock);\r\ninit_timer(&rec->timer);\r\nrec->timer.function = emu8k_pcm_timer_func;\r\nrec->timer.data = (unsigned long)rec;\r\nruntime->hw = emu8k_pcm_hw;\r\nruntime->hw.buffer_bytes_max = emu->mem_size - LOOP_BLANK_SIZE * 3;\r\nruntime->hw.period_bytes_max = runtime->hw.buffer_bytes_max / 2;\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_TIME,\r\n(1000000 + HZ - 1) / HZ, UINT_MAX);\r\nreturn 0;\r\n}\r\nstatic int emu8k_pcm_close(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\r\nkfree(rec);\r\nsubs->runtime->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int calc_pitch_target(int pitch)\r\n{\r\nint ptarget = 1 << (pitch >> 12);\r\nif (pitch & 0x800) ptarget += (ptarget * 0x102e) / 0x2710;\r\nif (pitch & 0x400) ptarget += (ptarget * 0x764) / 0x2710;\r\nif (pitch & 0x200) ptarget += (ptarget * 0x389) / 0x2710;\r\nptarget += (ptarget >> 1);\r\nif (ptarget > 0xffff) ptarget = 0xffff;\r\nreturn ptarget;\r\n}\r\nstatic void setup_voice(struct snd_emu8k_pcm *rec, int ch)\r\n{\r\nstruct snd_emu8000 *hw = rec->emu;\r\nunsigned int temp;\r\nEMU8000_DCYSUSV_WRITE(hw, ch, 0x0080);\r\nEMU8000_VTFT_WRITE(hw, ch, 0x0000FFFF);\r\nEMU8000_CVCF_WRITE(hw, ch, 0x0000FFFF);\r\nEMU8000_PTRX_WRITE(hw, ch, 0);\r\nEMU8000_CPF_WRITE(hw, ch, 0);\r\nEMU8000_IP_WRITE(hw, ch, rec->pitch);\r\nEMU8000_ENVVAL_WRITE(hw, ch, 0x8000);\r\nEMU8000_ATKHLD_WRITE(hw, ch, 0x7f7f);\r\nEMU8000_DCYSUS_WRITE(hw, ch, 0x7f7f);\r\nEMU8000_ENVVOL_WRITE(hw, ch, 0x8000);\r\nEMU8000_ATKHLDV_WRITE(hw, ch, 0x7f7f);\r\nEMU8000_PEFE_WRITE(hw, ch, 0x0);\r\nEMU8000_LFO1VAL_WRITE(hw, ch, 0x8000);\r\nEMU8000_LFO2VAL_WRITE(hw, ch, 0x8000);\r\nEMU8000_FMMOD_WRITE(hw, ch, 0);\r\nEMU8000_TREMFRQ_WRITE(hw, ch, 0);\r\nEMU8000_FM2FRQ2_WRITE(hw, ch, 0);\r\ntemp = rec->panning[ch];\r\ntemp = (temp <<24) | ((unsigned int)rec->loop_start[ch] - 1);\r\nEMU8000_PSST_WRITE(hw, ch, temp);\r\ntemp = 0;\r\ntemp = (temp << 24) | ((unsigned int)rec->loop_start[ch] + rec->buf_size - 1);\r\nEMU8000_CSL_WRITE(hw, ch, temp);\r\ntemp = 0;\r\ntemp = (temp << 28) | ((unsigned int)rec->loop_start[ch] - 1);\r\nEMU8000_CCCA_WRITE(hw, ch, temp);\r\nEMU8000_00A0_WRITE(hw, ch, 0);\r\nEMU8000_0080_WRITE(hw, ch, 0);\r\n}\r\nstatic void start_voice(struct snd_emu8k_pcm *rec, int ch)\r\n{\r\nunsigned long flags;\r\nstruct snd_emu8000 *hw = rec->emu;\r\nunsigned int temp, aux;\r\nint pt = calc_pitch_target(rec->pitch);\r\nEMU8000_IFATN_WRITE(hw, ch, 0xff00);\r\nEMU8000_VTFT_WRITE(hw, ch, 0xffff);\r\nEMU8000_CVCF_WRITE(hw, ch, 0xffff);\r\nEMU8000_DCYSUSV_WRITE(hw, ch, 0x7f7f);\r\ntemp = 0;\r\nif (rec->panning[ch] == 0)\r\naux = 0xff;\r\nelse\r\naux = (-rec->panning[ch]) & 0xff;\r\ntemp = (temp << 8) | (pt << 16) | aux;\r\nEMU8000_PTRX_WRITE(hw, ch, temp);\r\nEMU8000_CPF_WRITE(hw, ch, pt << 16);\r\nspin_lock_irqsave(&rec->timer_lock, flags);\r\nif (! rec->timer_running) {\r\nrec->timer.expires = jiffies + 1;\r\nadd_timer(&rec->timer);\r\nrec->timer_running = 1;\r\n}\r\nspin_unlock_irqrestore(&rec->timer_lock, flags);\r\n}\r\nstatic void stop_voice(struct snd_emu8k_pcm *rec, int ch)\r\n{\r\nunsigned long flags;\r\nstruct snd_emu8000 *hw = rec->emu;\r\nEMU8000_DCYSUSV_WRITE(hw, ch, 0x807F);\r\nspin_lock_irqsave(&rec->timer_lock, flags);\r\nif (rec->timer_running) {\r\ndel_timer(&rec->timer);\r\nrec->timer_running = 0;\r\n}\r\nspin_unlock_irqrestore(&rec->timer_lock, flags);\r\n}\r\nstatic int emu8k_pcm_trigger(struct snd_pcm_substream *subs, int cmd)\r\n{\r\nstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\r\nint ch;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nfor (ch = 0; ch < rec->voices; ch++)\r\nstart_voice(rec, ch);\r\nrec->running = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nrec->running = 0;\r\nfor (ch = 0; ch < rec->voices; ch++)\r\nstop_voice(rec, ch);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int emu8k_transfer_block(struct snd_emu8000 *emu, int offset, unsigned short *buf, int count)\r\n{\r\nEMU8000_SMALW_WRITE(emu, offset);\r\nwhile (count > 0) {\r\nunsigned short sval;\r\nCHECK_SCHEDULER();\r\nif (get_user(sval, buf))\r\nreturn -EFAULT;\r\nEMU8000_SMLD_WRITE(emu, sval);\r\nbuf++;\r\ncount--;\r\n}\r\nreturn 0;\r\n}\r\nstatic int emu8k_pcm_copy(struct snd_pcm_substream *subs,\r\nint voice,\r\nsnd_pcm_uframes_t pos,\r\nvoid *src,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\r\nstruct snd_emu8000 *emu = rec->emu;\r\nsnd_emu8000_write_wait(emu, 1);\r\nif (voice == -1) {\r\nunsigned short *buf = src;\r\nint i, err;\r\ncount /= rec->voices;\r\nfor (i = 0; i < rec->voices; i++) {\r\nerr = emu8k_transfer_block(emu, pos + rec->loop_start[i], buf, count);\r\nif (err < 0)\r\nreturn err;\r\nbuf += count;\r\n}\r\nreturn 0;\r\n} else {\r\nreturn emu8k_transfer_block(emu, pos + rec->loop_start[voice], src, count);\r\n}\r\n}\r\nstatic int emu8k_silence_block(struct snd_emu8000 *emu, int offset, int count)\r\n{\r\nEMU8000_SMALW_WRITE(emu, offset);\r\nwhile (count > 0) {\r\nCHECK_SCHEDULER();\r\nEMU8000_SMLD_WRITE(emu, 0);\r\ncount--;\r\n}\r\nreturn 0;\r\n}\r\nstatic int emu8k_pcm_silence(struct snd_pcm_substream *subs,\r\nint voice,\r\nsnd_pcm_uframes_t pos,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\r\nstruct snd_emu8000 *emu = rec->emu;\r\nsnd_emu8000_write_wait(emu, 1);\r\nif (voice == -1 && rec->voices == 1)\r\nvoice = 0;\r\nif (voice == -1) {\r\nint err;\r\nerr = emu8k_silence_block(emu, pos + rec->loop_start[0], count / 2);\r\nif (err < 0)\r\nreturn err;\r\nreturn emu8k_silence_block(emu, pos + rec->loop_start[1], count / 2);\r\n} else {\r\nreturn emu8k_silence_block(emu, pos + rec->loop_start[voice], count);\r\n}\r\n}\r\nstatic int emu8k_pcm_copy(struct snd_pcm_substream *subs,\r\nint voice,\r\nsnd_pcm_uframes_t pos,\r\nvoid __user *src,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\r\nstruct snd_emu8000 *emu = rec->emu;\r\nunsigned short __user *buf = src;\r\nsnd_emu8000_write_wait(emu, 1);\r\nEMU8000_SMALW_WRITE(emu, pos + rec->loop_start[0]);\r\nif (rec->voices > 1)\r\nEMU8000_SMARW_WRITE(emu, pos + rec->loop_start[1]);\r\nwhile (count-- > 0) {\r\nunsigned short sval;\r\nCHECK_SCHEDULER();\r\nif (get_user(sval, buf))\r\nreturn -EFAULT;\r\nEMU8000_SMLD_WRITE(emu, sval);\r\nbuf++;\r\nif (rec->voices > 1) {\r\nCHECK_SCHEDULER();\r\nif (get_user(sval, buf))\r\nreturn -EFAULT;\r\nEMU8000_SMRD_WRITE(emu, sval);\r\nbuf++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int emu8k_pcm_silence(struct snd_pcm_substream *subs,\r\nint voice,\r\nsnd_pcm_uframes_t pos,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\r\nstruct snd_emu8000 *emu = rec->emu;\r\nsnd_emu8000_write_wait(emu, 1);\r\nEMU8000_SMALW_WRITE(emu, rec->loop_start[0] + pos);\r\nif (rec->voices > 1)\r\nEMU8000_SMARW_WRITE(emu, rec->loop_start[1] + pos);\r\nwhile (count-- > 0) {\r\nCHECK_SCHEDULER();\r\nEMU8000_SMLD_WRITE(emu, 0);\r\nif (rec->voices > 1) {\r\nCHECK_SCHEDULER();\r\nEMU8000_SMRD_WRITE(emu, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int emu8k_pcm_hw_params(struct snd_pcm_substream *subs,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\r\nif (rec->block) {\r\nsnd_util_mem_free(rec->emu->memhdr, rec->block);\r\nrec->block = NULL;\r\n}\r\nrec->allocated_bytes = params_buffer_bytes(hw_params) + LOOP_BLANK_SIZE * 4;\r\nrec->block = snd_util_mem_alloc(rec->emu->memhdr, rec->allocated_bytes);\r\nif (! rec->block)\r\nreturn -ENOMEM;\r\nrec->offset = EMU8000_DRAM_OFFSET + (rec->block->offset >> 1);\r\nsubs->dma_buffer.bytes = params_buffer_bytes(hw_params);\r\nreturn 0;\r\n}\r\nstatic int emu8k_pcm_hw_free(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\r\nif (rec->block) {\r\nint ch;\r\nfor (ch = 0; ch < rec->voices; ch++)\r\nstop_voice(rec, ch);\r\nif (rec->dram_opened)\r\nemu8k_close_dram(rec->emu);\r\nsnd_util_mem_free(rec->emu->memhdr, rec->block);\r\nrec->block = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int emu8k_pcm_prepare(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\r\nrec->pitch = 0xe000 + calc_rate_offset(subs->runtime->rate);\r\nrec->last_ptr = 0;\r\nrec->period_pos = 0;\r\nrec->buf_size = subs->runtime->buffer_size;\r\nrec->period_size = subs->runtime->period_size;\r\nrec->voices = subs->runtime->channels;\r\nrec->loop_start[0] = rec->offset + LOOP_BLANK_SIZE;\r\nif (rec->voices > 1)\r\nrec->loop_start[1] = rec->loop_start[0] + rec->buf_size + LOOP_BLANK_SIZE;\r\nif (rec->voices > 1) {\r\nrec->panning[0] = 0xff;\r\nrec->panning[1] = 0x00;\r\n} else\r\nrec->panning[0] = 0x80;\r\nif (! rec->dram_opened) {\r\nint err, i, ch;\r\nsnd_emux_terminate_all(rec->emu->emu);\r\nif ((err = emu8k_open_dram_for_pcm(rec->emu, rec->voices)) != 0)\r\nreturn err;\r\nrec->dram_opened = 1;\r\nsnd_emu8000_write_wait(rec->emu, 0);\r\nEMU8000_SMALW_WRITE(rec->emu, rec->offset);\r\nfor (i = 0; i < LOOP_BLANK_SIZE; i++)\r\nEMU8000_SMLD_WRITE(rec->emu, 0);\r\nfor (ch = 0; ch < rec->voices; ch++) {\r\nEMU8000_SMALW_WRITE(rec->emu, rec->loop_start[ch] + rec->buf_size);\r\nfor (i = 0; i < LOOP_BLANK_SIZE; i++)\r\nEMU8000_SMLD_WRITE(rec->emu, 0);\r\n}\r\n}\r\nsetup_voice(rec, 0);\r\nif (rec->voices > 1)\r\nsetup_voice(rec, 1);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t emu8k_pcm_pointer(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\r\nif (rec->running)\r\nreturn emu8k_get_curpos(rec, 0);\r\nreturn 0;\r\n}\r\nstatic void snd_emu8000_pcm_free(struct snd_pcm *pcm)\r\n{\r\nstruct snd_emu8000 *emu = pcm->private_data;\r\nemu->pcm = NULL;\r\n}\r\nint snd_emu8000_pcm_new(struct snd_card *card, struct snd_emu8000 *emu, int index)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif ((err = snd_pcm_new(card, "Emu8000 PCM", index, 1, 0, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = emu;\r\npcm->private_free = snd_emu8000_pcm_free;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &emu8k_pcm_ops);\r\nemu->pcm = pcm;\r\nsnd_device_register(card, pcm);\r\nreturn 0;\r\n}
