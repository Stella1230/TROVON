static void __devinit quirk_resource_alignment(struct pci_dev *dev)\r\n{\r\nint i;\r\nstruct resource *r;\r\nresource_size_t align, size;\r\nu16 command;\r\nif (!pci_is_reassigndev(dev))\r\nreturn;\r\nif (dev->hdr_type == PCI_HEADER_TYPE_NORMAL &&\r\n(dev->class >> 8) == PCI_CLASS_BRIDGE_HOST) {\r\ndev_warn(&dev->dev,\r\n"Can't reassign resources to host bridge.\n");\r\nreturn;\r\n}\r\ndev_info(&dev->dev,\r\n"Disabling memory decoding and releasing memory resources.\n");\r\npci_read_config_word(dev, PCI_COMMAND, &command);\r\ncommand &= ~PCI_COMMAND_MEMORY;\r\npci_write_config_word(dev, PCI_COMMAND, command);\r\nalign = pci_specified_resource_alignment(dev);\r\nfor (i=0; i < PCI_BRIDGE_RESOURCES; i++) {\r\nr = &dev->resource[i];\r\nif (!(r->flags & IORESOURCE_MEM))\r\ncontinue;\r\nsize = resource_size(r);\r\nif (size < align) {\r\nsize = align;\r\ndev_info(&dev->dev,\r\n"Rounding up size of resource #%d to %#llx.\n",\r\ni, (unsigned long long)size);\r\n}\r\nr->end = size - 1;\r\nr->start = 0;\r\n}\r\nif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE &&\r\n(dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {\r\nfor (i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++) {\r\nr = &dev->resource[i];\r\nif (!(r->flags & IORESOURCE_MEM))\r\ncontinue;\r\nr->end = resource_size(r) - 1;\r\nr->start = 0;\r\n}\r\npci_disable_bridge_window(dev);\r\n}\r\n}\r\nstatic void __devinit quirk_mmio_always_on(struct pci_dev *dev)\r\n{\r\nif ((dev->class >> 8) == PCI_CLASS_BRIDGE_HOST)\r\ndev->mmio_always_on = 1;\r\n}\r\nstatic void __devinit quirk_mellanox_tavor(struct pci_dev *dev)\r\n{\r\ndev->broken_parity_status = 1;\r\n}\r\nstatic void quirk_passive_release(struct pci_dev *dev)\r\n{\r\nstruct pci_dev *d = NULL;\r\nunsigned char dlc;\r\nwhile ((d = pci_get_device(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371SB_0, d))) {\r\npci_read_config_byte(d, 0x82, &dlc);\r\nif (!(dlc & 1<<1)) {\r\ndev_info(&d->dev, "PIIX3: Enabling Passive Release\n");\r\ndlc |= 1<<1;\r\npci_write_config_byte(d, 0x82, dlc);\r\n}\r\n}\r\n}\r\nstatic void __devinit quirk_isa_dma_hangs(struct pci_dev *dev)\r\n{\r\nif (!isa_dma_bridge_buggy) {\r\nisa_dma_bridge_buggy=1;\r\ndev_info(&dev->dev, "Activating ISA DMA hang workarounds\n");\r\n}\r\n}\r\nstatic void __devinit quirk_tigerpoint_bm_sts(struct pci_dev *dev)\r\n{\r\nu32 pmbase;\r\nu16 pm1a;\r\npci_read_config_dword(dev, 0x40, &pmbase);\r\npmbase = pmbase & 0xff80;\r\npm1a = inw(pmbase);\r\nif (pm1a & 0x10) {\r\ndev_info(&dev->dev, FW_BUG "TigerPoint LPC.BM_STS cleared\n");\r\noutw(0x10, pmbase);\r\n}\r\n}\r\nstatic void __devinit quirk_nopcipci(struct pci_dev *dev)\r\n{\r\nif ((pci_pci_problems & PCIPCI_FAIL)==0) {\r\ndev_info(&dev->dev, "Disabling direct PCI/PCI transfers\n");\r\npci_pci_problems |= PCIPCI_FAIL;\r\n}\r\n}\r\nstatic void __devinit quirk_nopciamd(struct pci_dev *dev)\r\n{\r\nu8 rev;\r\npci_read_config_byte(dev, 0x08, &rev);\r\nif (rev == 0x13) {\r\ndev_info(&dev->dev, "Chipset erratum: Disabling direct PCI/AGP transfers\n");\r\npci_pci_problems |= PCIAGP_FAIL;\r\n}\r\n}\r\nstatic void __devinit quirk_triton(struct pci_dev *dev)\r\n{\r\nif ((pci_pci_problems&PCIPCI_TRITON)==0) {\r\ndev_info(&dev->dev, "Limiting direct PCI/PCI transfers\n");\r\npci_pci_problems |= PCIPCI_TRITON;\r\n}\r\n}\r\nstatic void quirk_vialatency(struct pci_dev *dev)\r\n{\r\nstruct pci_dev *p;\r\nu8 busarb;\r\np = pci_get_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C686, NULL);\r\nif (p!=NULL) {\r\nif (p->revision < 0x40 || p->revision > 0x42)\r\ngoto exit;\r\n} else {\r\np = pci_get_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8231, NULL);\r\nif (p==NULL)\r\ngoto exit;\r\nif (p->revision < 0x10 || p->revision > 0x12)\r\ngoto exit;\r\n}\r\npci_read_config_byte(dev, 0x76, &busarb);\r\nbusarb &= ~(1<<5);\r\nbusarb |= (1<<4);\r\npci_write_config_byte(dev, 0x76, busarb);\r\ndev_info(&dev->dev, "Applying VIA southbridge workaround\n");\r\nexit:\r\npci_dev_put(p);\r\n}\r\nstatic void __devinit quirk_viaetbf(struct pci_dev *dev)\r\n{\r\nif ((pci_pci_problems&PCIPCI_VIAETBF)==0) {\r\ndev_info(&dev->dev, "Limiting direct PCI/PCI transfers\n");\r\npci_pci_problems |= PCIPCI_VIAETBF;\r\n}\r\n}\r\nstatic void __devinit quirk_vsfx(struct pci_dev *dev)\r\n{\r\nif ((pci_pci_problems&PCIPCI_VSFX)==0) {\r\ndev_info(&dev->dev, "Limiting direct PCI/PCI transfers\n");\r\npci_pci_problems |= PCIPCI_VSFX;\r\n}\r\n}\r\nstatic void __init quirk_alimagik(struct pci_dev *dev)\r\n{\r\nif ((pci_pci_problems&PCIPCI_ALIMAGIK)==0) {\r\ndev_info(&dev->dev, "Limiting direct PCI/PCI transfers\n");\r\npci_pci_problems |= PCIPCI_ALIMAGIK|PCIPCI_TRITON;\r\n}\r\n}\r\nstatic void __devinit quirk_natoma(struct pci_dev *dev)\r\n{\r\nif ((pci_pci_problems&PCIPCI_NATOMA)==0) {\r\ndev_info(&dev->dev, "Limiting direct PCI/PCI transfers\n");\r\npci_pci_problems |= PCIPCI_NATOMA;\r\n}\r\n}\r\nstatic void __devinit quirk_citrine(struct pci_dev *dev)\r\n{\r\ndev->cfg_size = 0xA0;\r\n}\r\nstatic void __devinit quirk_s3_64M(struct pci_dev *dev)\r\n{\r\nstruct resource *r = &dev->resource[0];\r\nif ((r->start & 0x3ffffff) || r->end != r->start + 0x3ffffff) {\r\nr->start = 0;\r\nr->end = 0x3ffffff;\r\n}\r\n}\r\nstatic void __devinit quirk_cs5536_vsa(struct pci_dev *dev)\r\n{\r\nif (pci_resource_len(dev, 0) != 8) {\r\nstruct resource *res = &dev->resource[0];\r\nres->end = res->start + 8 - 1;\r\ndev_info(&dev->dev, "CS5536 ISA bridge bug detected "\r\n"(incorrect header); workaround applied.\n");\r\n}\r\n}\r\nstatic void __devinit quirk_io_region(struct pci_dev *dev, unsigned region,\r\nunsigned size, int nr, const char *name)\r\n{\r\nregion &= ~(size-1);\r\nif (region) {\r\nstruct pci_bus_region bus_region;\r\nstruct resource *res = dev->resource + nr;\r\nres->name = pci_name(dev);\r\nres->start = region;\r\nres->end = region + size - 1;\r\nres->flags = IORESOURCE_IO;\r\nbus_region.start = res->start;\r\nbus_region.end = res->end;\r\npcibios_bus_to_resource(dev, res, &bus_region);\r\nif (pci_claim_resource(dev, nr) == 0)\r\ndev_info(&dev->dev, "quirk: %pR claimed by %s\n",\r\nres, name);\r\n}\r\n}\r\nstatic void __devinit quirk_ati_exploding_mce(struct pci_dev *dev)\r\n{\r\ndev_info(&dev->dev, "ATI Northbridge, reserving I/O ports 0x3b0 to 0x3bb\n");\r\nrequest_region(0x3b0, 0x0C, "RadeonIGP");\r\nrequest_region(0x3d3, 0x01, "RadeonIGP");\r\n}\r\nstatic void __devinit quirk_ali7101_acpi(struct pci_dev *dev)\r\n{\r\nu16 region;\r\npci_read_config_word(dev, 0xE0, &region);\r\nquirk_io_region(dev, region, 64, PCI_BRIDGE_RESOURCES, "ali7101 ACPI");\r\npci_read_config_word(dev, 0xE2, &region);\r\nquirk_io_region(dev, region, 32, PCI_BRIDGE_RESOURCES+1, "ali7101 SMB");\r\n}\r\nstatic void piix4_io_quirk(struct pci_dev *dev, const char *name, unsigned int port, unsigned int enable)\r\n{\r\nu32 devres;\r\nu32 mask, size, base;\r\npci_read_config_dword(dev, port, &devres);\r\nif ((devres & enable) != enable)\r\nreturn;\r\nmask = (devres >> 16) & 15;\r\nbase = devres & 0xffff;\r\nsize = 16;\r\nfor (;;) {\r\nunsigned bit = size >> 1;\r\nif ((bit & mask) == bit)\r\nbreak;\r\nsize = bit;\r\n}\r\nbase &= -size;\r\ndev_info(&dev->dev, "%s PIO at %04x-%04x\n", name, base, base + size - 1);\r\n}\r\nstatic void piix4_mem_quirk(struct pci_dev *dev, const char *name, unsigned int port, unsigned int enable)\r\n{\r\nu32 devres;\r\nu32 mask, size, base;\r\npci_read_config_dword(dev, port, &devres);\r\nif ((devres & enable) != enable)\r\nreturn;\r\nbase = devres & 0xffff0000;\r\nmask = (devres & 0x3f) << 16;\r\nsize = 128 << 16;\r\nfor (;;) {\r\nunsigned bit = size >> 1;\r\nif ((bit & mask) == bit)\r\nbreak;\r\nsize = bit;\r\n}\r\nbase &= -size;\r\ndev_info(&dev->dev, "%s MMIO at %04x-%04x\n", name, base, base + size - 1);\r\n}\r\nstatic void __devinit quirk_piix4_acpi(struct pci_dev *dev)\r\n{\r\nu32 region, res_a;\r\npci_read_config_dword(dev, 0x40, &region);\r\nquirk_io_region(dev, region, 64, PCI_BRIDGE_RESOURCES, "PIIX4 ACPI");\r\npci_read_config_dword(dev, 0x90, &region);\r\nquirk_io_region(dev, region, 16, PCI_BRIDGE_RESOURCES+1, "PIIX4 SMB");\r\npci_read_config_dword(dev, 0x5c, &res_a);\r\npiix4_io_quirk(dev, "PIIX4 devres B", 0x60, 3 << 21);\r\npiix4_io_quirk(dev, "PIIX4 devres C", 0x64, 3 << 21);\r\nif (res_a & (1 << 29)) {\r\npiix4_io_quirk(dev, "PIIX4 devres E", 0x68, 1 << 20);\r\npiix4_mem_quirk(dev, "PIIX4 devres F", 0x6c, 1 << 7);\r\n}\r\nif (res_a & (1 << 30)) {\r\npiix4_io_quirk(dev, "PIIX4 devres G", 0x70, 1 << 20);\r\npiix4_mem_quirk(dev, "PIIX4 devres H", 0x74, 1 << 7);\r\n}\r\npiix4_io_quirk(dev, "PIIX4 devres I", 0x78, 1 << 20);\r\npiix4_io_quirk(dev, "PIIX4 devres J", 0x7c, 1 << 20);\r\n}\r\nstatic void __devinit quirk_ich4_lpc_acpi(struct pci_dev *dev)\r\n{\r\nu32 region;\r\nu8 enable;\r\npci_read_config_byte(dev, ICH_ACPI_CNTL, &enable);\r\nif (enable & ICH4_ACPI_EN) {\r\npci_read_config_dword(dev, ICH_PMBASE, &region);\r\nregion &= PCI_BASE_ADDRESS_IO_MASK;\r\nif (region >= PCIBIOS_MIN_IO)\r\nquirk_io_region(dev, region, 128, PCI_BRIDGE_RESOURCES,\r\n"ICH4 ACPI/GPIO/TCO");\r\n}\r\npci_read_config_byte(dev, ICH4_GPIO_CNTL, &enable);\r\nif (enable & ICH4_GPIO_EN) {\r\npci_read_config_dword(dev, ICH4_GPIOBASE, &region);\r\nregion &= PCI_BASE_ADDRESS_IO_MASK;\r\nif (region >= PCIBIOS_MIN_IO)\r\nquirk_io_region(dev, region, 64,\r\nPCI_BRIDGE_RESOURCES + 1, "ICH4 GPIO");\r\n}\r\n}\r\nstatic void __devinit ich6_lpc_acpi_gpio(struct pci_dev *dev)\r\n{\r\nu32 region;\r\nu8 enable;\r\npci_read_config_byte(dev, ICH_ACPI_CNTL, &enable);\r\nif (enable & ICH6_ACPI_EN) {\r\npci_read_config_dword(dev, ICH_PMBASE, &region);\r\nregion &= PCI_BASE_ADDRESS_IO_MASK;\r\nif (region >= PCIBIOS_MIN_IO)\r\nquirk_io_region(dev, region, 128, PCI_BRIDGE_RESOURCES,\r\n"ICH6 ACPI/GPIO/TCO");\r\n}\r\npci_read_config_byte(dev, ICH6_GPIO_CNTL, &enable);\r\nif (enable & ICH6_GPIO_EN) {\r\npci_read_config_dword(dev, ICH6_GPIOBASE, &region);\r\nregion &= PCI_BASE_ADDRESS_IO_MASK;\r\nif (region >= PCIBIOS_MIN_IO)\r\nquirk_io_region(dev, region, 64,\r\nPCI_BRIDGE_RESOURCES + 1, "ICH6 GPIO");\r\n}\r\n}\r\nstatic void __devinit ich6_lpc_generic_decode(struct pci_dev *dev, unsigned reg, const char *name, int dynsize)\r\n{\r\nu32 val;\r\nu32 size, base;\r\npci_read_config_dword(dev, reg, &val);\r\nif (!(val & 1))\r\nreturn;\r\nbase = val & 0xfffc;\r\nif (dynsize) {\r\nsize = 16;\r\n} else {\r\nsize = 128;\r\n}\r\nbase &= ~(size-1);\r\ndev_info(&dev->dev, "%s PIO at %04x-%04x\n", name, base, base+size-1);\r\n}\r\nstatic void __devinit quirk_ich6_lpc(struct pci_dev *dev)\r\n{\r\nich6_lpc_acpi_gpio(dev);\r\nich6_lpc_generic_decode(dev, 0x84, "LPC Generic IO decode 1", 0);\r\nich6_lpc_generic_decode(dev, 0x88, "LPC Generic IO decode 2", 1);\r\n}\r\nstatic void __devinit ich7_lpc_generic_decode(struct pci_dev *dev, unsigned reg, const char *name)\r\n{\r\nu32 val;\r\nu32 mask, base;\r\npci_read_config_dword(dev, reg, &val);\r\nif (!(val & 1))\r\nreturn;\r\nbase = val & 0xfffc;\r\nmask = (val >> 16) & 0xfc;\r\nmask |= 3;\r\ndev_info(&dev->dev, "%s PIO at %04x (mask %04x)\n", name, base, mask);\r\n}\r\nstatic void __devinit quirk_ich7_lpc(struct pci_dev *dev)\r\n{\r\nich6_lpc_acpi_gpio(dev);\r\nich7_lpc_generic_decode(dev, 0x84, "ICH7 LPC Generic IO decode 1");\r\nich7_lpc_generic_decode(dev, 0x88, "ICH7 LPC Generic IO decode 2");\r\nich7_lpc_generic_decode(dev, 0x8c, "ICH7 LPC Generic IO decode 3");\r\nich7_lpc_generic_decode(dev, 0x90, "ICH7 LPC Generic IO decode 4");\r\n}\r\nstatic void __devinit quirk_vt82c586_acpi(struct pci_dev *dev)\r\n{\r\nu32 region;\r\nif (dev->revision & 0x10) {\r\npci_read_config_dword(dev, 0x48, &region);\r\nregion &= PCI_BASE_ADDRESS_IO_MASK;\r\nquirk_io_region(dev, region, 256, PCI_BRIDGE_RESOURCES, "vt82c586 ACPI");\r\n}\r\n}\r\nstatic void __devinit quirk_vt82c686_acpi(struct pci_dev *dev)\r\n{\r\nu16 hm;\r\nu32 smb;\r\nquirk_vt82c586_acpi(dev);\r\npci_read_config_word(dev, 0x70, &hm);\r\nhm &= PCI_BASE_ADDRESS_IO_MASK;\r\nquirk_io_region(dev, hm, 128, PCI_BRIDGE_RESOURCES + 1, "vt82c686 HW-mon");\r\npci_read_config_dword(dev, 0x90, &smb);\r\nsmb &= PCI_BASE_ADDRESS_IO_MASK;\r\nquirk_io_region(dev, smb, 16, PCI_BRIDGE_RESOURCES + 2, "vt82c686 SMB");\r\n}\r\nstatic void __devinit quirk_vt8235_acpi(struct pci_dev *dev)\r\n{\r\nu16 pm, smb;\r\npci_read_config_word(dev, 0x88, &pm);\r\npm &= PCI_BASE_ADDRESS_IO_MASK;\r\nquirk_io_region(dev, pm, 128, PCI_BRIDGE_RESOURCES, "vt8235 PM");\r\npci_read_config_word(dev, 0xd0, &smb);\r\nsmb &= PCI_BASE_ADDRESS_IO_MASK;\r\nquirk_io_region(dev, smb, 16, PCI_BRIDGE_RESOURCES + 1, "vt8235 SMB");\r\n}\r\nstatic void __devinit quirk_xio2000a(struct pci_dev *dev)\r\n{\r\nstruct pci_dev *pdev;\r\nu16 command;\r\ndev_warn(&dev->dev, "TI XIO2000a quirk detected; "\r\n"secondary bus fast back-to-back transfers disabled\n");\r\nlist_for_each_entry(pdev, &dev->subordinate->devices, bus_list) {\r\npci_read_config_word(pdev, PCI_COMMAND, &command);\r\nif (command & PCI_COMMAND_FAST_BACK)\r\npci_write_config_word(pdev, PCI_COMMAND, command & ~PCI_COMMAND_FAST_BACK);\r\n}\r\n}\r\nstatic void quirk_via_ioapic(struct pci_dev *dev)\r\n{\r\nu8 tmp;\r\nif (nr_ioapics < 1)\r\ntmp = 0;\r\nelse\r\ntmp = 0x1f;\r\ndev_info(&dev->dev, "%sbling VIA external APIC routing\n",\r\ntmp == 0 ? "Disa" : "Ena");\r\npci_write_config_byte (dev, 0x58, tmp);\r\n}\r\nstatic void quirk_via_vt8237_bypass_apic_deassert(struct pci_dev *dev)\r\n{\r\nu8 misc_control2;\r\n#define BYPASS_APIC_DEASSERT 8\r\npci_read_config_byte(dev, 0x5B, &misc_control2);\r\nif (!(misc_control2 & BYPASS_APIC_DEASSERT)) {\r\ndev_info(&dev->dev, "Bypassing VIA 8237 APIC De-Assert Message\n");\r\npci_write_config_byte(dev, 0x5B, misc_control2|BYPASS_APIC_DEASSERT);\r\n}\r\n}\r\nstatic void __devinit quirk_amd_ioapic(struct pci_dev *dev)\r\n{\r\nif (dev->revision >= 0x02) {\r\ndev_warn(&dev->dev, "I/O APIC: AMD Erratum #22 may be present. In the event of instability try\n");\r\ndev_warn(&dev->dev, " : booting with the \"noapic\" option\n");\r\n}\r\n}\r\nstatic void __init quirk_ioapic_rmw(struct pci_dev *dev)\r\n{\r\nif (dev->devfn == 0 && dev->bus->number == 0)\r\nsis_apic_bug = 1;\r\n}\r\nstatic void __init quirk_amd_8131_mmrbc(struct pci_dev *dev)\r\n{\r\nif (dev->subordinate && dev->revision <= 0x12) {\r\ndev_info(&dev->dev, "AMD8131 rev %x detected; "\r\n"disabling PCI-X MMRBC\n", dev->revision);\r\ndev->subordinate->bus_flags |= PCI_BUS_FLAGS_NO_MMRBC;\r\n}\r\n}\r\nstatic void __devinit quirk_via_acpi(struct pci_dev *d)\r\n{\r\nu8 irq;\r\npci_read_config_byte(d, 0x42, &irq);\r\nirq &= 0xf;\r\nif (irq && (irq != 2))\r\nd->irq = irq;\r\n}\r\nstatic void quirk_via_bridge(struct pci_dev *dev)\r\n{\r\nswitch (dev->device) {\r\ncase PCI_DEVICE_ID_VIA_82C686:\r\nvia_vlink_dev_lo = PCI_SLOT(dev->devfn);\r\nvia_vlink_dev_hi = PCI_SLOT(dev->devfn);\r\nbreak;\r\ncase PCI_DEVICE_ID_VIA_8237:\r\ncase PCI_DEVICE_ID_VIA_8237A:\r\nvia_vlink_dev_lo = 15;\r\nbreak;\r\ncase PCI_DEVICE_ID_VIA_8235:\r\nvia_vlink_dev_lo = 16;\r\nbreak;\r\ncase PCI_DEVICE_ID_VIA_8231:\r\ncase PCI_DEVICE_ID_VIA_8233_0:\r\ncase PCI_DEVICE_ID_VIA_8233A:\r\ncase PCI_DEVICE_ID_VIA_8233C_0:\r\nvia_vlink_dev_lo = 17;\r\nbreak;\r\n}\r\n}\r\nstatic void quirk_via_vlink(struct pci_dev *dev)\r\n{\r\nu8 irq, new_irq;\r\nif (via_vlink_dev_lo == -1)\r\nreturn;\r\nnew_irq = dev->irq;\r\nif (!new_irq || new_irq > 15)\r\nreturn;\r\nif (dev->bus->number != 0 || PCI_SLOT(dev->devfn) > via_vlink_dev_hi ||\r\nPCI_SLOT(dev->devfn) < via_vlink_dev_lo)\r\nreturn;\r\npci_read_config_byte(dev, PCI_INTERRUPT_LINE, &irq);\r\nif (new_irq != irq) {\r\ndev_info(&dev->dev, "VIA VLink IRQ fixup, from %d to %d\n",\r\nirq, new_irq);\r\nudelay(15);\r\npci_write_config_byte(dev, PCI_INTERRUPT_LINE, new_irq);\r\n}\r\n}\r\nstatic void __devinit quirk_vt82c598_id(struct pci_dev *dev)\r\n{\r\npci_write_config_byte(dev, 0xfc, 0);\r\npci_read_config_word(dev, PCI_DEVICE_ID, &dev->device);\r\n}\r\nstatic void quirk_cardbus_legacy(struct pci_dev *dev)\r\n{\r\nif ((PCI_CLASS_BRIDGE_CARDBUS << 8) ^ dev->class)\r\nreturn;\r\npci_write_config_dword(dev, PCI_CB_LEGACY_MODE_BASE, 0);\r\n}\r\nstatic void quirk_amd_ordering(struct pci_dev *dev)\r\n{\r\nu32 pcic;\r\npci_read_config_dword(dev, 0x4C, &pcic);\r\nif ((pcic&6)!=6) {\r\npcic |= 6;\r\ndev_warn(&dev->dev, "BIOS failed to enable PCI standards compliance; fixing this error\n");\r\npci_write_config_dword(dev, 0x4C, pcic);\r\npci_read_config_dword(dev, 0x84, &pcic);\r\npcic |= (1<<23);\r\npci_write_config_dword(dev, 0x84, pcic);\r\n}\r\n}\r\nstatic void __devinit quirk_dunord ( struct pci_dev * dev )\r\n{\r\nstruct resource *r = &dev->resource [1];\r\nr->start = 0;\r\nr->end = 0xffffff;\r\n}\r\nstatic void __devinit quirk_transparent_bridge(struct pci_dev *dev)\r\n{\r\ndev->transparent = 1;\r\n}\r\nstatic void quirk_mediagx_master(struct pci_dev *dev)\r\n{\r\nu8 reg;\r\npci_read_config_byte(dev, 0x41, &reg);\r\nif (reg & 2) {\r\nreg &= ~2;\r\ndev_info(&dev->dev, "Fixup for MediaGX/Geode Slave Disconnect Boundary (0x41=0x%02x)\n", reg);\r\npci_write_config_byte(dev, 0x41, reg);\r\n}\r\n}\r\nstatic void quirk_disable_pxb(struct pci_dev *pdev)\r\n{\r\nu16 config;\r\nif (pdev->revision != 0x04)\r\nreturn;\r\npci_read_config_word(pdev, 0x40, &config);\r\nif (config & (1<<6)) {\r\nconfig &= ~(1<<6);\r\npci_write_config_word(pdev, 0x40, config);\r\ndev_info(&pdev->dev, "C0 revision 450NX. Disabling PCI restreaming\n");\r\n}\r\n}\r\nstatic void __devinit quirk_amd_ide_mode(struct pci_dev *pdev)\r\n{\r\nu8 tmp;\r\npci_read_config_byte(pdev, PCI_CLASS_DEVICE, &tmp);\r\nif (tmp == 0x01) {\r\npci_read_config_byte(pdev, 0x40, &tmp);\r\npci_write_config_byte(pdev, 0x40, tmp|1);\r\npci_write_config_byte(pdev, 0x9, 1);\r\npci_write_config_byte(pdev, 0xa, 6);\r\npci_write_config_byte(pdev, 0x40, tmp);\r\npdev->class = PCI_CLASS_STORAGE_SATA_AHCI;\r\ndev_info(&pdev->dev, "set SATA to AHCI mode\n");\r\n}\r\n}\r\nstatic void __devinit quirk_svwks_csb5ide(struct pci_dev *pdev)\r\n{\r\nu8 prog;\r\npci_read_config_byte(pdev, PCI_CLASS_PROG, &prog);\r\nif (prog & 5) {\r\nprog &= ~5;\r\npdev->class &= ~5;\r\npci_write_config_byte(pdev, PCI_CLASS_PROG, prog);\r\n}\r\n}\r\nstatic void __init quirk_ide_samemode(struct pci_dev *pdev)\r\n{\r\nu8 prog;\r\npci_read_config_byte(pdev, PCI_CLASS_PROG, &prog);\r\nif (((prog & 1) && !(prog & 4)) || ((prog & 4) && !(prog & 1))) {\r\ndev_info(&pdev->dev, "IDE mode mismatch; forcing legacy mode\n");\r\nprog &= ~5;\r\npdev->class &= ~5;\r\npci_write_config_byte(pdev, PCI_CLASS_PROG, prog);\r\n}\r\n}\r\nstatic void __devinit quirk_no_ata_d3(struct pci_dev *pdev)\r\n{\r\nif ((pdev->class >> 8) == PCI_CLASS_STORAGE_IDE)\r\npdev->dev_flags |= PCI_DEV_FLAGS_NO_D3;\r\n}\r\nstatic void __init quirk_eisa_bridge(struct pci_dev *dev)\r\n{\r\ndev->class = PCI_CLASS_BRIDGE_EISA << 8;\r\n}\r\nstatic void __init asus_hides_smbus_hostbridge(struct pci_dev *dev)\r\n{\r\nif (unlikely(dev->subsystem_vendor == PCI_VENDOR_ID_ASUSTEK)) {\r\nif (dev->device == PCI_DEVICE_ID_INTEL_82845_HB)\r\nswitch(dev->subsystem_device) {\r\ncase 0x8025:\r\ncase 0x8070:\r\ncase 0x8088:\r\ncase 0x1626:\r\nasus_hides_smbus = 1;\r\n}\r\nelse if (dev->device == PCI_DEVICE_ID_INTEL_82845G_HB)\r\nswitch(dev->subsystem_device) {\r\ncase 0x80b1:\r\ncase 0x80b2:\r\ncase 0x8093:\r\nasus_hides_smbus = 1;\r\n}\r\nelse if (dev->device == PCI_DEVICE_ID_INTEL_82850_HB)\r\nswitch(dev->subsystem_device) {\r\ncase 0x8030:\r\nasus_hides_smbus = 1;\r\n}\r\nelse if (dev->device == PCI_DEVICE_ID_INTEL_7205_0)\r\nswitch (dev->subsystem_device) {\r\ncase 0x8070:\r\nasus_hides_smbus = 1;\r\n}\r\nelse if (dev->device == PCI_DEVICE_ID_INTEL_E7501_MCH)\r\nswitch (dev->subsystem_device) {\r\ncase 0x80c9:\r\nasus_hides_smbus = 1;\r\n}\r\nelse if (dev->device == PCI_DEVICE_ID_INTEL_82855GM_HB)\r\nswitch (dev->subsystem_device) {\r\ncase 0x1751:\r\ncase 0x1821:\r\ncase 0x1897:\r\nasus_hides_smbus = 1;\r\n}\r\nelse if (dev->device == PCI_DEVICE_ID_INTEL_82855PM_HB)\r\nswitch (dev->subsystem_device) {\r\ncase 0x184b:\r\ncase 0x186a:\r\nasus_hides_smbus = 1;\r\n}\r\nelse if (dev->device == PCI_DEVICE_ID_INTEL_82865_HB)\r\nswitch (dev->subsystem_device) {\r\ncase 0x80f2:\r\nasus_hides_smbus = 1;\r\n}\r\nelse if (dev->device == PCI_DEVICE_ID_INTEL_82915GM_HB)\r\nswitch (dev->subsystem_device) {\r\ncase 0x1882:\r\ncase 0x1977:\r\nasus_hides_smbus = 1;\r\n}\r\n} else if (unlikely(dev->subsystem_vendor == PCI_VENDOR_ID_HP)) {\r\nif (dev->device == PCI_DEVICE_ID_INTEL_82855PM_HB)\r\nswitch(dev->subsystem_device) {\r\ncase 0x088C:\r\ncase 0x0890:\r\nasus_hides_smbus = 1;\r\n}\r\nelse if (dev->device == PCI_DEVICE_ID_INTEL_82865_HB)\r\nswitch (dev->subsystem_device) {\r\ncase 0x12bc:\r\ncase 0x12bd:\r\ncase 0x006a:\r\nasus_hides_smbus = 1;\r\n}\r\nelse if (dev->device == PCI_DEVICE_ID_INTEL_82875_HB)\r\nswitch (dev->subsystem_device) {\r\ncase 0x12bf:\r\nasus_hides_smbus = 1;\r\n}\r\n} else if (unlikely(dev->subsystem_vendor == PCI_VENDOR_ID_SAMSUNG)) {\r\nif (dev->device == PCI_DEVICE_ID_INTEL_82855PM_HB)\r\nswitch(dev->subsystem_device) {\r\ncase 0xC00C:\r\nasus_hides_smbus = 1;\r\n}\r\n} else if (unlikely(dev->subsystem_vendor == PCI_VENDOR_ID_COMPAQ)) {\r\nif (dev->device == PCI_DEVICE_ID_INTEL_82855PM_HB)\r\nswitch(dev->subsystem_device) {\r\ncase 0x0058:\r\nasus_hides_smbus = 1;\r\n}\r\nelse if (dev->device == PCI_DEVICE_ID_INTEL_82810_IG3)\r\nswitch(dev->subsystem_device) {\r\ncase 0xB16C:\r\nasus_hides_smbus = 1;\r\n}\r\nelse if (dev->device == PCI_DEVICE_ID_INTEL_82801DB_2)\r\nswitch(dev->subsystem_device) {\r\ncase 0x00b8:\r\ncase 0x00b9:\r\ncase 0x00ba:\r\nasus_hides_smbus = 1;\r\n}\r\nelse if (dev->device == PCI_DEVICE_ID_INTEL_82815_CGC)\r\nswitch (dev->subsystem_device) {\r\ncase 0x001A:\r\nasus_hides_smbus = 1;\r\n}\r\n}\r\n}\r\nstatic void asus_hides_smbus_lpc(struct pci_dev *dev)\r\n{\r\nu16 val;\r\nif (likely(!asus_hides_smbus))\r\nreturn;\r\npci_read_config_word(dev, 0xF2, &val);\r\nif (val & 0x8) {\r\npci_write_config_word(dev, 0xF2, val & (~0x8));\r\npci_read_config_word(dev, 0xF2, &val);\r\nif (val & 0x8)\r\ndev_info(&dev->dev, "i801 SMBus device continues to play 'hide and seek'! 0x%x\n", val);\r\nelse\r\ndev_info(&dev->dev, "Enabled i801 SMBus device\n");\r\n}\r\n}\r\nstatic void asus_hides_smbus_lpc_ich6_suspend(struct pci_dev *dev)\r\n{\r\nu32 rcba;\r\nif (likely(!asus_hides_smbus))\r\nreturn;\r\nWARN_ON(asus_rcba_base);\r\npci_read_config_dword(dev, 0xF0, &rcba);\r\nasus_rcba_base = ioremap_nocache(rcba & 0xFFFFC000, 0x4000);\r\nif (asus_rcba_base == NULL)\r\nreturn;\r\n}\r\nstatic void asus_hides_smbus_lpc_ich6_resume_early(struct pci_dev *dev)\r\n{\r\nu32 val;\r\nif (likely(!asus_hides_smbus || !asus_rcba_base))\r\nreturn;\r\nval = readl(asus_rcba_base + 0x3418);\r\nwritel(val & 0xFFFFFFF7, asus_rcba_base + 0x3418);\r\n}\r\nstatic void asus_hides_smbus_lpc_ich6_resume(struct pci_dev *dev)\r\n{\r\nif (likely(!asus_hides_smbus || !asus_rcba_base))\r\nreturn;\r\niounmap(asus_rcba_base);\r\nasus_rcba_base = NULL;\r\ndev_info(&dev->dev, "Enabled ICH6/i801 SMBus device\n");\r\n}\r\nstatic void asus_hides_smbus_lpc_ich6(struct pci_dev *dev)\r\n{\r\nasus_hides_smbus_lpc_ich6_suspend(dev);\r\nasus_hides_smbus_lpc_ich6_resume_early(dev);\r\nasus_hides_smbus_lpc_ich6_resume(dev);\r\n}\r\nstatic void quirk_sis_96x_smbus(struct pci_dev *dev)\r\n{\r\nu8 val = 0;\r\npci_read_config_byte(dev, 0x77, &val);\r\nif (val & 0x10) {\r\ndev_info(&dev->dev, "Enabling SiS 96x SMBus\n");\r\npci_write_config_byte(dev, 0x77, val & ~0x10);\r\n}\r\n}\r\nstatic void quirk_sis_503(struct pci_dev *dev)\r\n{\r\nu8 reg;\r\nu16 devid;\r\npci_read_config_byte(dev, SIS_DETECT_REGISTER, &reg);\r\npci_write_config_byte(dev, SIS_DETECT_REGISTER, reg | (1 << 6));\r\npci_read_config_word(dev, PCI_DEVICE_ID, &devid);\r\nif (((devid & 0xfff0) != 0x0960) && (devid != 0x0018)) {\r\npci_write_config_byte(dev, SIS_DETECT_REGISTER, reg);\r\nreturn;\r\n}\r\ndev->device = devid;\r\nquirk_sis_96x_smbus(dev);\r\n}\r\nstatic void asus_hides_ac97_lpc(struct pci_dev *dev)\r\n{\r\nu8 val;\r\nint asus_hides_ac97 = 0;\r\nif (likely(dev->subsystem_vendor == PCI_VENDOR_ID_ASUSTEK)) {\r\nif (dev->device == PCI_DEVICE_ID_VIA_8237)\r\nasus_hides_ac97 = 1;\r\n}\r\nif (!asus_hides_ac97)\r\nreturn;\r\npci_read_config_byte(dev, 0x50, &val);\r\nif (val & 0xc0) {\r\npci_write_config_byte(dev, 0x50, val & (~0xc0));\r\npci_read_config_byte(dev, 0x50, &val);\r\nif (val & 0xc0)\r\ndev_info(&dev->dev, "Onboard AC97/MC97 devices continue to play 'hide and seek'! 0x%x\n", val);\r\nelse\r\ndev_info(&dev->dev, "Enabled onboard AC97/MC97 devices\n");\r\n}\r\n}\r\nstatic void quirk_jmicron_ata(struct pci_dev *pdev)\r\n{\r\nu32 conf1, conf5, class;\r\nu8 hdr;\r\nif (PCI_FUNC(pdev->devfn))\r\nreturn;\r\npci_read_config_dword(pdev, 0x40, &conf1);\r\npci_read_config_dword(pdev, 0x80, &conf5);\r\nconf1 &= ~0x00CFF302;\r\nconf5 &= ~(1 << 24);\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_JMICRON_JMB360:\r\ncase PCI_DEVICE_ID_JMICRON_JMB362:\r\ncase PCI_DEVICE_ID_JMICRON_JMB364:\r\nconf1 |= 0x0002A100;\r\nbreak;\r\ncase PCI_DEVICE_ID_JMICRON_JMB365:\r\ncase PCI_DEVICE_ID_JMICRON_JMB366:\r\nconf5 |= (1 << 24);\r\ncase PCI_DEVICE_ID_JMICRON_JMB361:\r\ncase PCI_DEVICE_ID_JMICRON_JMB363:\r\ncase PCI_DEVICE_ID_JMICRON_JMB369:\r\nconf1 |= 0x00C2A1B3;\r\nbreak;\r\ncase PCI_DEVICE_ID_JMICRON_JMB368:\r\nconf1 |= 0x00C00000;\r\nbreak;\r\n}\r\npci_write_config_dword(pdev, 0x40, conf1);\r\npci_write_config_dword(pdev, 0x80, conf5);\r\npci_read_config_byte(pdev, PCI_HEADER_TYPE, &hdr);\r\npdev->hdr_type = hdr & 0x7f;\r\npdev->multifunction = !!(hdr & 0x80);\r\npci_read_config_dword(pdev, PCI_CLASS_REVISION, &class);\r\npdev->class = class >> 8;\r\n}\r\nstatic void __init quirk_alder_ioapic(struct pci_dev *pdev)\r\n{\r\nint i;\r\nif ((pdev->class >> 8) != 0xff00)\r\nreturn;\r\nif (pci_resource_start(pdev, 0) && pci_resource_len(pdev, 0))\r\ninsert_resource(&iomem_resource, &pdev->resource[0]);\r\nfor (i=1; i < 6; i++) {\r\nmemset(&pdev->resource[i], 0, sizeof(pdev->resource[i]));\r\n}\r\n}\r\nstatic void __devinit quirk_pcie_mch(struct pci_dev *pdev)\r\n{\r\npci_msi_off(pdev);\r\npdev->no_msi = 1;\r\n}\r\nstatic void __devinit quirk_pcie_pxh(struct pci_dev *dev)\r\n{\r\npci_msi_off(dev);\r\ndev->no_msi = 1;\r\ndev_warn(&dev->dev, "PXH quirk detected; SHPC device MSI disabled\n");\r\n}\r\nstatic void quirk_intel_pcie_pm(struct pci_dev * dev)\r\n{\r\npci_pm_d3_delay = 120;\r\ndev->no_d1d2 = 1;\r\n}\r\nstatic void quirk_reroute_to_boot_interrupts_intel(struct pci_dev *dev)\r\n{\r\nif (noioapicquirk || noioapicreroute)\r\nreturn;\r\ndev->irq_reroute_variant = INTEL_IRQ_REROUTE_VARIANT;\r\ndev_info(&dev->dev, "rerouting interrupts for [%04x:%04x]\n",\r\ndev->vendor, dev->device);\r\n}\r\nstatic void quirk_disable_intel_boot_interrupt(struct pci_dev *dev)\r\n{\r\nu16 pci_config_word;\r\nif (noioapicquirk)\r\nreturn;\r\npci_read_config_word(dev, INTEL_6300_IOAPIC_ABAR, &pci_config_word);\r\npci_config_word |= INTEL_6300_DISABLE_BOOT_IRQ;\r\npci_write_config_word(dev, INTEL_6300_IOAPIC_ABAR, pci_config_word);\r\ndev_info(&dev->dev, "disabled boot interrupts on device [%04x:%04x]\n",\r\ndev->vendor, dev->device);\r\n}\r\nstatic void quirk_disable_broadcom_boot_interrupt(struct pci_dev *dev)\r\n{\r\nu32 pci_config_dword;\r\nu8 irq;\r\nif (noioapicquirk)\r\nreturn;\r\npci_read_config_dword(dev, BC_HT1000_FEATURE_REG, &pci_config_dword);\r\npci_write_config_dword(dev, BC_HT1000_FEATURE_REG, pci_config_dword |\r\nBC_HT1000_PIC_REGS_ENABLE);\r\nfor (irq = 0x10; irq < 0x10 + 32; irq++) {\r\noutb(irq, BC_HT1000_MAP_IDX);\r\noutb(0x00, BC_HT1000_MAP_DATA);\r\n}\r\npci_write_config_dword(dev, BC_HT1000_FEATURE_REG, pci_config_dword);\r\ndev_info(&dev->dev, "disabled boot interrupts on device [%04x:%04x]\n",\r\ndev->vendor, dev->device);\r\n}\r\nstatic void quirk_disable_amd_813x_boot_interrupt(struct pci_dev *dev)\r\n{\r\nu32 pci_config_dword;\r\nif (noioapicquirk)\r\nreturn;\r\nif ((dev->revision == AMD_813X_REV_B1) ||\r\n(dev->revision == AMD_813X_REV_B2))\r\nreturn;\r\npci_read_config_dword(dev, AMD_813X_MISC, &pci_config_dword);\r\npci_config_dword &= ~AMD_813X_NOIOAMODE;\r\npci_write_config_dword(dev, AMD_813X_MISC, pci_config_dword);\r\ndev_info(&dev->dev, "disabled boot interrupts on device [%04x:%04x]\n",\r\ndev->vendor, dev->device);\r\n}\r\nstatic void quirk_disable_amd_8111_boot_interrupt(struct pci_dev *dev)\r\n{\r\nu16 pci_config_word;\r\nif (noioapicquirk)\r\nreturn;\r\npci_read_config_word(dev, AMD_8111_PCI_IRQ_ROUTING, &pci_config_word);\r\nif (!pci_config_word) {\r\ndev_info(&dev->dev, "boot interrupts on device [%04x:%04x] "\r\n"already disabled\n", dev->vendor, dev->device);\r\nreturn;\r\n}\r\npci_write_config_word(dev, AMD_8111_PCI_IRQ_ROUTING, 0);\r\ndev_info(&dev->dev, "disabled boot interrupts on device [%04x:%04x]\n",\r\ndev->vendor, dev->device);\r\n}\r\nstatic void __init quirk_tc86c001_ide(struct pci_dev *dev)\r\n{\r\nstruct resource *r = &dev->resource[0];\r\nif (r->start & 0x8) {\r\nr->start = 0;\r\nr->end = 0xf;\r\n}\r\n}\r\nstatic void __devinit quirk_netmos(struct pci_dev *dev)\r\n{\r\nunsigned int num_parallel = (dev->subsystem_device & 0xf0) >> 4;\r\nunsigned int num_serial = dev->subsystem_device & 0xf;\r\nswitch (dev->device) {\r\ncase PCI_DEVICE_ID_NETMOS_9835:\r\nif (dev->subsystem_vendor == PCI_VENDOR_ID_IBM &&\r\ndev->subsystem_device == 0x0299)\r\nreturn;\r\ncase PCI_DEVICE_ID_NETMOS_9735:\r\ncase PCI_DEVICE_ID_NETMOS_9745:\r\ncase PCI_DEVICE_ID_NETMOS_9845:\r\ncase PCI_DEVICE_ID_NETMOS_9855:\r\nif ((dev->class >> 8) == PCI_CLASS_COMMUNICATION_SERIAL &&\r\nnum_parallel) {\r\ndev_info(&dev->dev, "Netmos %04x (%u parallel, "\r\n"%u serial); changing class SERIAL to OTHER "\r\n"(use parport_serial)\n",\r\ndev->device, num_parallel, num_serial);\r\ndev->class = (PCI_CLASS_COMMUNICATION_OTHER << 8) |\r\n(dev->class & 0xff);\r\n}\r\n}\r\n}\r\nstatic void __devinit quirk_e100_interrupt(struct pci_dev *dev)\r\n{\r\nu16 command, pmcsr;\r\nu8 __iomem *csr;\r\nu8 cmd_hi;\r\nint pm;\r\nswitch (dev->device) {\r\ncase 0x1029:\r\ncase 0x1030 ... 0x1034:\r\ncase 0x1038 ... 0x103E:\r\ncase 0x1050 ... 0x1057:\r\ncase 0x1059:\r\ncase 0x1064 ... 0x106B:\r\ncase 0x1091 ... 0x1095:\r\ncase 0x1209:\r\ncase 0x1229:\r\ncase 0x2449:\r\ncase 0x2459:\r\ncase 0x245D:\r\ncase 0x27DC:\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\npci_read_config_word(dev, PCI_COMMAND, &command);\r\nif (!(command & PCI_COMMAND_MEMORY) || !pci_resource_start(dev, 0))\r\nreturn;\r\npm = pci_find_capability(dev, PCI_CAP_ID_PM);\r\nif (pm) {\r\npci_read_config_word(dev, pm + PCI_PM_CTRL, &pmcsr);\r\nif ((pmcsr & PCI_PM_CTRL_STATE_MASK) != PCI_D0)\r\nreturn;\r\n}\r\ncsr = ioremap(pci_resource_start(dev, 0), 8);\r\nif (!csr) {\r\ndev_warn(&dev->dev, "Can't map e100 registers\n");\r\nreturn;\r\n}\r\ncmd_hi = readb(csr + 3);\r\nif (cmd_hi == 0) {\r\ndev_warn(&dev->dev, "Firmware left e100 interrupts enabled; "\r\n"disabling\n");\r\nwriteb(1, csr + 3);\r\n}\r\niounmap(csr);\r\n}\r\nstatic void __devinit quirk_disable_aspm_l0s(struct pci_dev *dev)\r\n{\r\ndev_info(&dev->dev, "Disabling L0s\n");\r\npci_disable_link_state(dev, PCIE_LINK_STATE_L0S);\r\n}\r\nstatic void __devinit fixup_rev1_53c810(struct pci_dev* dev)\r\n{\r\nif (dev->class == PCI_CLASS_NOT_DEFINED) {\r\ndev_info(&dev->dev, "NCR 53c810 rev 1 detected; setting PCI class\n");\r\ndev->class = PCI_CLASS_STORAGE_SCSI;\r\n}\r\n}\r\nstatic void __devinit quirk_p64h2_1k_io(struct pci_dev *dev)\r\n{\r\nu16 en1k;\r\nu8 io_base_lo, io_limit_lo;\r\nunsigned long base, limit;\r\nstruct resource *res = dev->resource + PCI_BRIDGE_RESOURCES;\r\npci_read_config_word(dev, 0x40, &en1k);\r\nif (en1k & 0x200) {\r\ndev_info(&dev->dev, "Enable I/O Space to 1KB granularity\n");\r\npci_read_config_byte(dev, PCI_IO_BASE, &io_base_lo);\r\npci_read_config_byte(dev, PCI_IO_LIMIT, &io_limit_lo);\r\nbase = (io_base_lo & (PCI_IO_RANGE_MASK | 0x0c)) << 8;\r\nlimit = (io_limit_lo & (PCI_IO_RANGE_MASK | 0x0c)) << 8;\r\nif (base <= limit) {\r\nres->start = base;\r\nres->end = limit + 0x3ff;\r\n}\r\n}\r\n}\r\nstatic void __devinit quirk_p64h2_1k_io_fix_iobl(struct pci_dev *dev)\r\n{\r\nu16 en1k, iobl_adr, iobl_adr_1k;\r\nstruct resource *res = dev->resource + PCI_BRIDGE_RESOURCES;\r\npci_read_config_word(dev, 0x40, &en1k);\r\nif (en1k & 0x200) {\r\npci_read_config_word(dev, PCI_IO_BASE, &iobl_adr);\r\niobl_adr_1k = iobl_adr | (res->start >> 8) | (res->end & 0xfc00);\r\nif (iobl_adr != iobl_adr_1k) {\r\ndev_info(&dev->dev, "Fixing P64H2 IOBL_ADR from 0x%x to 0x%x for 1KB granularity\n",\r\niobl_adr,iobl_adr_1k);\r\npci_write_config_word(dev, PCI_IO_BASE, iobl_adr_1k);\r\n}\r\n}\r\n}\r\nstatic void quirk_nvidia_ck804_pcie_aer_ext_cap(struct pci_dev *dev)\r\n{\r\nuint8_t b;\r\nif (pci_read_config_byte(dev, 0xf41, &b) == 0) {\r\nif (!(b & 0x20)) {\r\npci_write_config_byte(dev, 0xf41, b | 0x20);\r\ndev_info(&dev->dev,\r\n"Linking AER extended capability\n");\r\n}\r\n}\r\n}\r\nstatic void __devinit quirk_via_cx700_pci_parking_caching(struct pci_dev *dev)\r\n{\r\nstruct pci_dev *p = pci_get_device(PCI_VENDOR_ID_VIA,\r\nPCI_DEVICE_ID_VIA_8235_USB_2, NULL);\r\nuint8_t b;\r\np = pci_get_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8235_USB_2, p);\r\nif (!p)\r\nreturn;\r\npci_dev_put(p);\r\nif (pci_read_config_byte(dev, 0x76, &b) == 0) {\r\nif (b & 0x40) {\r\npci_write_config_byte(dev, 0x76, b ^ 0x40);\r\ndev_info(&dev->dev,\r\n"Disabling VIA CX700 PCI parking\n");\r\n}\r\n}\r\nif (pci_read_config_byte(dev, 0x72, &b) == 0) {\r\nif (b != 0) {\r\npci_write_config_byte(dev, 0x72, 0x0);\r\npci_write_config_byte(dev, 0x75, 0x1);\r\npci_write_config_byte(dev, 0x77, 0x0);\r\ndev_info(&dev->dev,\r\n"Disabling VIA CX700 PCI caching\n");\r\n}\r\n}\r\n}\r\nstatic void __devinit quirk_brcm_570x_limit_vpd(struct pci_dev *dev)\r\n{\r\nif ((dev->device == PCI_DEVICE_ID_NX2_5706) ||\r\n(dev->device == PCI_DEVICE_ID_NX2_5706S) ||\r\n(dev->device == PCI_DEVICE_ID_NX2_5708) ||\r\n(dev->device == PCI_DEVICE_ID_NX2_5708S) ||\r\n((dev->device == PCI_DEVICE_ID_NX2_5709) &&\r\n(dev->revision & 0xf0) == 0x0)) {\r\nif (dev->vpd)\r\ndev->vpd->len = 0x80;\r\n}\r\n}\r\nstatic void __devinit quirk_unhide_mch_dev6(struct pci_dev *dev)\r\n{\r\nu8 reg;\r\nif (pci_read_config_byte(dev, 0xF4, &reg) == 0 && !(reg & 0x02)) {\r\ndev_info(&dev->dev, "Enabling MCH 'Overflow' Device\n");\r\npci_write_config_byte(dev, 0xF4, reg | 0x02);\r\n}\r\n}\r\nstatic void __devinit quirk_tile_plx_gen1(struct pci_dev *dev)\r\n{\r\nif (tile_plx_gen1) {\r\npci_write_config_dword(dev, 0x98, 0x1);\r\nmdelay(50);\r\n}\r\n}\r\nstatic void __init quirk_disable_all_msi(struct pci_dev *dev)\r\n{\r\npci_no_msi();\r\ndev_warn(&dev->dev, "MSI quirk detected; MSI disabled\n");\r\n}\r\nstatic void __devinit quirk_disable_msi(struct pci_dev *dev)\r\n{\r\nif (dev->subordinate) {\r\ndev_warn(&dev->dev, "MSI quirk detected; "\r\n"subordinate MSI disabled\n");\r\ndev->subordinate->bus_flags |= PCI_BUS_FLAGS_NO_MSI;\r\n}\r\n}\r\nstatic void __devinit quirk_amd_780_apc_msi(struct pci_dev *host_bridge)\r\n{\r\nstruct pci_dev *apc_bridge;\r\napc_bridge = pci_get_slot(host_bridge->bus, PCI_DEVFN(1, 0));\r\nif (apc_bridge) {\r\nif (apc_bridge->device == 0x9602)\r\nquirk_disable_msi(apc_bridge);\r\npci_dev_put(apc_bridge);\r\n}\r\n}\r\nstatic int __devinit msi_ht_cap_enabled(struct pci_dev *dev)\r\n{\r\nint pos, ttl = 48;\r\npos = pci_find_ht_capability(dev, HT_CAPTYPE_MSI_MAPPING);\r\nwhile (pos && ttl--) {\r\nu8 flags;\r\nif (pci_read_config_byte(dev, pos + HT_MSI_FLAGS,\r\n&flags) == 0)\r\n{\r\ndev_info(&dev->dev, "Found %s HT MSI Mapping\n",\r\nflags & HT_MSI_FLAGS_ENABLE ?\r\n"enabled" : "disabled");\r\nreturn (flags & HT_MSI_FLAGS_ENABLE) != 0;\r\n}\r\npos = pci_find_next_ht_capability(dev, pos,\r\nHT_CAPTYPE_MSI_MAPPING);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __devinit quirk_msi_ht_cap(struct pci_dev *dev)\r\n{\r\nif (dev->subordinate && !msi_ht_cap_enabled(dev)) {\r\ndev_warn(&dev->dev, "MSI quirk detected; "\r\n"subordinate MSI disabled\n");\r\ndev->subordinate->bus_flags |= PCI_BUS_FLAGS_NO_MSI;\r\n}\r\n}\r\nstatic void __devinit quirk_nvidia_ck804_msi_ht_cap(struct pci_dev *dev)\r\n{\r\nstruct pci_dev *pdev;\r\nif (!dev->subordinate)\r\nreturn;\r\npdev = pci_get_slot(dev->bus, 0);\r\nif (!pdev)\r\nreturn;\r\nif (!msi_ht_cap_enabled(dev) && !msi_ht_cap_enabled(pdev)) {\r\ndev_warn(&dev->dev, "MSI quirk detected; "\r\n"subordinate MSI disabled\n");\r\ndev->subordinate->bus_flags |= PCI_BUS_FLAGS_NO_MSI;\r\n}\r\npci_dev_put(pdev);\r\n}\r\nstatic void __devinit ht_enable_msi_mapping(struct pci_dev *dev)\r\n{\r\nint pos, ttl = 48;\r\npos = pci_find_ht_capability(dev, HT_CAPTYPE_MSI_MAPPING);\r\nwhile (pos && ttl--) {\r\nu8 flags;\r\nif (pci_read_config_byte(dev, pos + HT_MSI_FLAGS,\r\n&flags) == 0) {\r\ndev_info(&dev->dev, "Enabling HT MSI Mapping\n");\r\npci_write_config_byte(dev, pos + HT_MSI_FLAGS,\r\nflags | HT_MSI_FLAGS_ENABLE);\r\n}\r\npos = pci_find_next_ht_capability(dev, pos,\r\nHT_CAPTYPE_MSI_MAPPING);\r\n}\r\n}\r\nstatic void __devinit nvenet_msi_disable(struct pci_dev *dev)\r\n{\r\nconst char *board_name = dmi_get_system_info(DMI_BOARD_NAME);\r\nif (board_name &&\r\n(strstr(board_name, "P5N32-SLI PREMIUM") ||\r\nstrstr(board_name, "P5N32-E SLI"))) {\r\ndev_info(&dev->dev,\r\n"Disabling msi for MCP55 NIC on P5N32-SLI\n");\r\ndev->no_msi = 1;\r\n}\r\n}\r\nstatic void __devinit nvbridge_check_legacy_irq_routing(struct pci_dev *dev)\r\n{\r\nu32 cfg;\r\nif (!pci_find_capability(dev, PCI_CAP_ID_HT))\r\nreturn;\r\npci_read_config_dword(dev, 0x74, &cfg);\r\nif (cfg & ((1 << 2) | (1 << 15))) {\r\nprintk(KERN_INFO "Rewriting irq routing register on MCP55\n");\r\ncfg &= ~((1 << 2) | (1 << 15));\r\npci_write_config_dword(dev, 0x74, cfg);\r\n}\r\n}\r\nstatic int __devinit ht_check_msi_mapping(struct pci_dev *dev)\r\n{\r\nint pos, ttl = 48;\r\nint found = 0;\r\npos = pci_find_ht_capability(dev, HT_CAPTYPE_MSI_MAPPING);\r\nwhile (pos && ttl--) {\r\nu8 flags;\r\nif (found < 1)\r\nfound = 1;\r\nif (pci_read_config_byte(dev, pos + HT_MSI_FLAGS,\r\n&flags) == 0) {\r\nif (flags & HT_MSI_FLAGS_ENABLE) {\r\nif (found < 2) {\r\nfound = 2;\r\nbreak;\r\n}\r\n}\r\n}\r\npos = pci_find_next_ht_capability(dev, pos,\r\nHT_CAPTYPE_MSI_MAPPING);\r\n}\r\nreturn found;\r\n}\r\nstatic int __devinit host_bridge_with_leaf(struct pci_dev *host_bridge)\r\n{\r\nstruct pci_dev *dev;\r\nint pos;\r\nint i, dev_no;\r\nint found = 0;\r\ndev_no = host_bridge->devfn >> 3;\r\nfor (i = dev_no + 1; i < 0x20; i++) {\r\ndev = pci_get_slot(host_bridge->bus, PCI_DEVFN(i, 0));\r\nif (!dev)\r\ncontinue;\r\npos = pci_find_ht_capability(dev, HT_CAPTYPE_SLAVE);\r\nif (pos != 0) {\r\npci_dev_put(dev);\r\nbreak;\r\n}\r\nif (ht_check_msi_mapping(dev)) {\r\nfound = 1;\r\npci_dev_put(dev);\r\nbreak;\r\n}\r\npci_dev_put(dev);\r\n}\r\nreturn found;\r\n}\r\nstatic int __devinit is_end_of_ht_chain(struct pci_dev *dev)\r\n{\r\nint pos, ctrl_off;\r\nint end = 0;\r\nu16 flags, ctrl;\r\npos = pci_find_ht_capability(dev, HT_CAPTYPE_SLAVE);\r\nif (!pos)\r\ngoto out;\r\npci_read_config_word(dev, pos + PCI_CAP_FLAGS, &flags);\r\nctrl_off = ((flags >> 10) & 1) ?\r\nPCI_HT_CAP_SLAVE_CTRL0 : PCI_HT_CAP_SLAVE_CTRL1;\r\npci_read_config_word(dev, pos + ctrl_off, &ctrl);\r\nif (ctrl & (1 << 6))\r\nend = 1;\r\nout:\r\nreturn end;\r\n}\r\nstatic void __devinit nv_ht_enable_msi_mapping(struct pci_dev *dev)\r\n{\r\nstruct pci_dev *host_bridge;\r\nint pos;\r\nint i, dev_no;\r\nint found = 0;\r\ndev_no = dev->devfn >> 3;\r\nfor (i = dev_no; i >= 0; i--) {\r\nhost_bridge = pci_get_slot(dev->bus, PCI_DEVFN(i, 0));\r\nif (!host_bridge)\r\ncontinue;\r\npos = pci_find_ht_capability(host_bridge, HT_CAPTYPE_SLAVE);\r\nif (pos != 0) {\r\nfound = 1;\r\nbreak;\r\n}\r\npci_dev_put(host_bridge);\r\n}\r\nif (!found)\r\nreturn;\r\nif (host_bridge == dev && is_end_of_ht_chain(host_bridge) &&\r\nhost_bridge_with_leaf(host_bridge))\r\ngoto out;\r\nif (msi_ht_cap_enabled(host_bridge))\r\ngoto out;\r\nht_enable_msi_mapping(dev);\r\nout:\r\npci_dev_put(host_bridge);\r\n}\r\nstatic void __devinit ht_disable_msi_mapping(struct pci_dev *dev)\r\n{\r\nint pos, ttl = 48;\r\npos = pci_find_ht_capability(dev, HT_CAPTYPE_MSI_MAPPING);\r\nwhile (pos && ttl--) {\r\nu8 flags;\r\nif (pci_read_config_byte(dev, pos + HT_MSI_FLAGS,\r\n&flags) == 0) {\r\ndev_info(&dev->dev, "Disabling HT MSI Mapping\n");\r\npci_write_config_byte(dev, pos + HT_MSI_FLAGS,\r\nflags & ~HT_MSI_FLAGS_ENABLE);\r\n}\r\npos = pci_find_next_ht_capability(dev, pos,\r\nHT_CAPTYPE_MSI_MAPPING);\r\n}\r\n}\r\nstatic void __devinit __nv_msi_ht_cap_quirk(struct pci_dev *dev, int all)\r\n{\r\nstruct pci_dev *host_bridge;\r\nint pos;\r\nint found;\r\nif (!pci_msi_enabled())\r\nreturn;\r\nfound = ht_check_msi_mapping(dev);\r\nif (found == 0)\r\nreturn;\r\nhost_bridge = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));\r\nif (host_bridge == NULL) {\r\ndev_warn(&dev->dev,\r\n"nv_msi_ht_cap_quirk didn't locate host bridge\n");\r\nreturn;\r\n}\r\npos = pci_find_ht_capability(host_bridge, HT_CAPTYPE_SLAVE);\r\nif (pos != 0) {\r\nif (found == 1) {\r\nif (all)\r\nht_enable_msi_mapping(dev);\r\nelse\r\nnv_ht_enable_msi_mapping(dev);\r\n}\r\nreturn;\r\n}\r\nif (found == 1)\r\nreturn;\r\nht_disable_msi_mapping(dev);\r\n}\r\nstatic void __devinit nv_msi_ht_cap_quirk_all(struct pci_dev *dev)\r\n{\r\nreturn __nv_msi_ht_cap_quirk(dev, 1);\r\n}\r\nstatic void __devinit nv_msi_ht_cap_quirk_leaf(struct pci_dev *dev)\r\n{\r\nreturn __nv_msi_ht_cap_quirk(dev, 0);\r\n}\r\nstatic void __devinit quirk_msi_intx_disable_bug(struct pci_dev *dev)\r\n{\r\ndev->dev_flags |= PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG;\r\n}\r\nstatic void __devinit quirk_msi_intx_disable_ati_bug(struct pci_dev *dev)\r\n{\r\nstruct pci_dev *p;\r\np = pci_get_device(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS,\r\nNULL);\r\nif (!p)\r\nreturn;\r\nif ((p->revision < 0x3B) && (p->revision >= 0x30))\r\ndev->dev_flags |= PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG;\r\npci_dev_put(p);\r\n}\r\nstatic void __devinit quirk_hotplug_bridge(struct pci_dev *dev)\r\n{\r\ndev->is_hotplug_bridge = 1;\r\n}\r\nstatic void ricoh_mmc_fixup_rl5c476(struct pci_dev *dev)\r\n{\r\nu8 write_enable;\r\nu8 write_target;\r\nu8 disable;\r\nif (PCI_FUNC(dev->devfn))\r\nreturn;\r\npci_read_config_byte(dev, 0xB7, &disable);\r\nif (disable & 0x02)\r\nreturn;\r\npci_read_config_byte(dev, 0x8E, &write_enable);\r\npci_write_config_byte(dev, 0x8E, 0xAA);\r\npci_read_config_byte(dev, 0x8D, &write_target);\r\npci_write_config_byte(dev, 0x8D, 0xB7);\r\npci_write_config_byte(dev, 0xB7, disable | 0x02);\r\npci_write_config_byte(dev, 0x8E, write_enable);\r\npci_write_config_byte(dev, 0x8D, write_target);\r\ndev_notice(&dev->dev, "proprietary Ricoh MMC controller disabled (via cardbus function)\n");\r\ndev_notice(&dev->dev, "MMC cards are now supported by standard SDHCI controller\n");\r\n}\r\nstatic void ricoh_mmc_fixup_r5c832(struct pci_dev *dev)\r\n{\r\nu8 write_enable;\r\nu8 disable;\r\nif (PCI_FUNC(dev->devfn))\r\nreturn;\r\nif (dev->device == PCI_DEVICE_ID_RICOH_R5CE823) {\r\npci_write_config_byte(dev, 0xf9, 0xfc);\r\npci_write_config_byte(dev, 0x150, 0x10);\r\npci_write_config_byte(dev, 0xf9, 0x00);\r\npci_write_config_byte(dev, 0xfc, 0x01);\r\npci_write_config_byte(dev, 0xe1, 0x32);\r\npci_write_config_byte(dev, 0xfc, 0x00);\r\ndev_notice(&dev->dev, "MMC controller base frequency changed to 50Mhz.\n");\r\n}\r\npci_read_config_byte(dev, 0xCB, &disable);\r\nif (disable & 0x02)\r\nreturn;\r\npci_read_config_byte(dev, 0xCA, &write_enable);\r\npci_write_config_byte(dev, 0xCA, 0x57);\r\npci_write_config_byte(dev, 0xCB, disable | 0x02);\r\npci_write_config_byte(dev, 0xCA, write_enable);\r\ndev_notice(&dev->dev, "proprietary Ricoh MMC controller disabled (via firewire function)\n");\r\ndev_notice(&dev->dev, "MMC cards are now supported by standard SDHCI controller\n");\r\n}\r\nstatic void vtd_mask_spec_errors(struct pci_dev *dev)\r\n{\r\nu32 word;\r\npci_read_config_dword(dev, VTUNCERRMSK_REG, &word);\r\npci_write_config_dword(dev, VTUNCERRMSK_REG, word | VTD_MSK_SPEC_ERRORS);\r\n}\r\nstatic void __devinit fixup_ti816x_class(struct pci_dev* dev)\r\n{\r\nif (dev->class == PCI_CLASS_NOT_DEFINED) {\r\ndev_info(&dev->dev, "Setting PCI class for 816x PCIe device\n");\r\ndev->class = PCI_CLASS_MULTIMEDIA_VIDEO;\r\n}\r\n}\r\nstatic void __devinit fixup_mpss_256(struct pci_dev *dev)\r\n{\r\ndev->pcie_mpss = 1;\r\n}\r\nstatic void __devinit quirk_intel_mc_errata(struct pci_dev *dev)\r\n{\r\nint err;\r\nu16 rcc;\r\nif (pcie_bus_config == PCIE_BUS_TUNE_OFF)\r\nreturn;\r\nerr = pci_read_config_word(dev, 0x48, &rcc);\r\nif (err) {\r\ndev_err(&dev->dev, "Error attempting to read the read "\r\n"completion coalescing register.\n");\r\nreturn;\r\n}\r\nif (!(rcc & (1 << 10)))\r\nreturn;\r\nrcc &= ~(1 << 10);\r\nerr = pci_write_config_word(dev, 0x48, rcc);\r\nif (err) {\r\ndev_err(&dev->dev, "Error attempting to write the read "\r\n"completion coalescing register.\n");\r\nreturn;\r\n}\r\npr_info_once("Read completion coalescing disabled due to hardware "\r\n"errata relating to 256B MPS.\n");\r\n}\r\nstatic void pci_do_fixups(struct pci_dev *dev, struct pci_fixup *f,\r\nstruct pci_fixup *end)\r\n{\r\nwhile (f < end) {\r\nif ((f->vendor == dev->vendor || f->vendor == (u16) PCI_ANY_ID) &&\r\n(f->device == dev->device || f->device == (u16) PCI_ANY_ID)) {\r\ndev_dbg(&dev->dev, "calling %pF\n", f->hook);\r\nf->hook(dev);\r\n}\r\nf++;\r\n}\r\n}\r\nvoid pci_fixup_device(enum pci_fixup_pass pass, struct pci_dev *dev)\r\n{\r\nstruct pci_fixup *start, *end;\r\nswitch(pass) {\r\ncase pci_fixup_early:\r\nstart = __start_pci_fixups_early;\r\nend = __end_pci_fixups_early;\r\nbreak;\r\ncase pci_fixup_header:\r\nstart = __start_pci_fixups_header;\r\nend = __end_pci_fixups_header;\r\nbreak;\r\ncase pci_fixup_final:\r\nstart = __start_pci_fixups_final;\r\nend = __end_pci_fixups_final;\r\nbreak;\r\ncase pci_fixup_enable:\r\nstart = __start_pci_fixups_enable;\r\nend = __end_pci_fixups_enable;\r\nbreak;\r\ncase pci_fixup_resume:\r\nstart = __start_pci_fixups_resume;\r\nend = __end_pci_fixups_resume;\r\nbreak;\r\ncase pci_fixup_resume_early:\r\nstart = __start_pci_fixups_resume_early;\r\nend = __end_pci_fixups_resume_early;\r\nbreak;\r\ncase pci_fixup_suspend:\r\nstart = __start_pci_fixups_suspend;\r\nend = __end_pci_fixups_suspend;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\npci_do_fixups(dev, start, end);\r\n}\r\nstatic int __init pci_apply_final_quirks(void)\r\n{\r\nstruct pci_dev *dev = NULL;\r\nu8 cls = 0;\r\nu8 tmp;\r\nif (pci_cache_line_size)\r\nprintk(KERN_DEBUG "PCI: CLS %u bytes\n",\r\npci_cache_line_size << 2);\r\nfor_each_pci_dev(dev) {\r\npci_fixup_device(pci_fixup_final, dev);\r\nif (!pci_cache_line_size) {\r\npci_read_config_byte(dev, PCI_CACHE_LINE_SIZE, &tmp);\r\nif (!cls)\r\ncls = tmp;\r\nif (!tmp || cls == tmp)\r\ncontinue;\r\nprintk(KERN_DEBUG "PCI: CLS mismatch (%u != %u), "\r\n"using %u bytes\n", cls << 2, tmp << 2,\r\npci_dfl_cache_line_size << 2);\r\npci_cache_line_size = pci_dfl_cache_line_size;\r\n}\r\n}\r\nif (!pci_cache_line_size) {\r\nprintk(KERN_DEBUG "PCI: CLS %u bytes, default %u\n",\r\ncls << 2, pci_dfl_cache_line_size << 2);\r\npci_cache_line_size = cls ? cls : pci_dfl_cache_line_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int reset_intel_generic_dev(struct pci_dev *dev, int probe)\r\n{\r\nint pos;\r\nif (dev->class == PCI_CLASS_SERIAL_USB) {\r\npos = pci_find_capability(dev, PCI_CAP_ID_VNDR);\r\nif (!pos)\r\nreturn -ENOTTY;\r\nif (probe)\r\nreturn 0;\r\npci_write_config_byte(dev, pos + 0x4, 1);\r\nmsleep(100);\r\nreturn 0;\r\n} else {\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int reset_intel_82599_sfp_virtfn(struct pci_dev *dev, int probe)\r\n{\r\nint pos;\r\npos = pci_find_capability(dev, PCI_CAP_ID_EXP);\r\nif (!pos)\r\nreturn -ENOTTY;\r\nif (probe)\r\nreturn 0;\r\npci_write_config_word(dev, pos + PCI_EXP_DEVCTL,\r\nPCI_EXP_DEVCTL_BCR_FLR);\r\nmsleep(100);\r\nreturn 0;\r\n}\r\nint pci_dev_specific_reset(struct pci_dev *dev, int probe)\r\n{\r\nconst struct pci_dev_reset_methods *i;\r\nfor (i = pci_dev_reset_methods; i->reset; i++) {\r\nif ((i->vendor == dev->vendor ||\r\ni->vendor == (u16)PCI_ANY_ID) &&\r\n(i->device == dev->device ||\r\ni->device == (u16)PCI_ANY_ID))\r\nreturn i->reset(dev, probe);\r\n}\r\nreturn -ENOTTY;\r\n}
