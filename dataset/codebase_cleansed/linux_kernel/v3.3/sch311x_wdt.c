static inline void sch311x_sio_enter(int sio_config_port)\r\n{\r\noutb(0x55, sio_config_port);\r\n}\r\nstatic inline void sch311x_sio_exit(int sio_config_port)\r\n{\r\noutb(0xaa, sio_config_port);\r\n}\r\nstatic inline int sch311x_sio_inb(int sio_config_port, int reg)\r\n{\r\noutb(reg, sio_config_port);\r\nreturn inb(sio_config_port + 1);\r\n}\r\nstatic inline void sch311x_sio_outb(int sio_config_port, int reg, int val)\r\n{\r\noutb(reg, sio_config_port);\r\noutb(val, sio_config_port + 1);\r\n}\r\nstatic void sch311x_wdt_set_timeout(int t)\r\n{\r\nunsigned char timeout_unit = 0x80;\r\nif (t > 255) {\r\ntimeout_unit = 0;\r\nt /= 60;\r\n}\r\noutb(timeout_unit, sch311x_wdt_data.runtime_reg + WDT_TIME_OUT);\r\noutb(t, sch311x_wdt_data.runtime_reg + WDT_VAL);\r\n}\r\nstatic void sch311x_wdt_start(void)\r\n{\r\nspin_lock(&sch311x_wdt_data.io_lock);\r\nsch311x_wdt_set_timeout(timeout);\r\noutb(0x0e, sch311x_wdt_data.runtime_reg + GP60);\r\nspin_unlock(&sch311x_wdt_data.io_lock);\r\n}\r\nstatic void sch311x_wdt_stop(void)\r\n{\r\nspin_lock(&sch311x_wdt_data.io_lock);\r\noutb(0x01, sch311x_wdt_data.runtime_reg + GP60);\r\nsch311x_wdt_set_timeout(0);\r\nspin_unlock(&sch311x_wdt_data.io_lock);\r\n}\r\nstatic void sch311x_wdt_keepalive(void)\r\n{\r\nspin_lock(&sch311x_wdt_data.io_lock);\r\nsch311x_wdt_set_timeout(timeout);\r\nspin_unlock(&sch311x_wdt_data.io_lock);\r\n}\r\nstatic int sch311x_wdt_set_heartbeat(int t)\r\n{\r\nif (t < 1 || t > (255*60))\r\nreturn -EINVAL;\r\nif (t > 255)\r\nt = (((t - 1) / 60) + 1) * 60;\r\ntimeout = t;\r\nreturn 0;\r\n}\r\nstatic void sch311x_wdt_get_status(int *status)\r\n{\r\nunsigned char new_status;\r\n*status = 0;\r\nspin_lock(&sch311x_wdt_data.io_lock);\r\nnew_status = inb(sch311x_wdt_data.runtime_reg + WDT_CTRL);\r\nif (new_status & 0x01)\r\n*status |= WDIOF_CARDRESET;\r\nspin_unlock(&sch311x_wdt_data.io_lock);\r\n}\r\nstatic ssize_t sch311x_wdt_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count) {\r\nif (!nowayout) {\r\nsize_t i;\r\nsch311x_wdt_expect_close = 0;\r\nfor (i = 0; i != count; i++) {\r\nchar c;\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nsch311x_wdt_expect_close = 42;\r\n}\r\n}\r\nsch311x_wdt_keepalive();\r\n}\r\nreturn count;\r\n}\r\nstatic long sch311x_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint status;\r\nint new_timeout;\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_KEEPALIVEPING |\r\nWDIOF_SETTIMEOUT |\r\nWDIOF_MAGICCLOSE,\r\n.firmware_version = 1,\r\n.identity = DRV_NAME,\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user(argp, &ident, sizeof(ident)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\n{\r\nsch311x_wdt_get_status(&status);\r\nreturn put_user(status, p);\r\n}\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(sch311x_wdt_data.boot_status, p);\r\ncase WDIOC_SETOPTIONS:\r\n{\r\nint options, retval = -EINVAL;\r\nif (get_user(options, p))\r\nreturn -EFAULT;\r\nif (options & WDIOS_DISABLECARD) {\r\nsch311x_wdt_stop();\r\nretval = 0;\r\n}\r\nif (options & WDIOS_ENABLECARD) {\r\nsch311x_wdt_start();\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\ncase WDIOC_KEEPALIVE:\r\nsch311x_wdt_keepalive();\r\nbreak;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_timeout, p))\r\nreturn -EFAULT;\r\nif (sch311x_wdt_set_heartbeat(new_timeout))\r\nreturn -EINVAL;\r\nsch311x_wdt_keepalive();\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(timeout, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sch311x_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &sch311x_wdt_is_open))\r\nreturn -EBUSY;\r\nsch311x_wdt_start();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int sch311x_wdt_close(struct inode *inode, struct file *file)\r\n{\r\nif (sch311x_wdt_expect_close == 42) {\r\nsch311x_wdt_stop();\r\n} else {\r\nprintk(KERN_CRIT PFX\r\n"Unexpected close, not stopping watchdog!\n");\r\nsch311x_wdt_keepalive();\r\n}\r\nclear_bit(0, &sch311x_wdt_is_open);\r\nsch311x_wdt_expect_close = 0;\r\nreturn 0;\r\n}\r\nstatic int __devinit sch311x_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nunsigned char val;\r\nint err;\r\nspin_lock_init(&sch311x_wdt_data.io_lock);\r\nif (!request_region(sch311x_wdt_data.runtime_reg + RESGEN, 1,\r\nDRV_NAME)) {\r\ndev_err(dev, "Failed to request region 0x%04x-0x%04x.\n",\r\nsch311x_wdt_data.runtime_reg + RESGEN,\r\nsch311x_wdt_data.runtime_reg + RESGEN);\r\nerr = -EBUSY;\r\ngoto exit;\r\n}\r\nif (!request_region(sch311x_wdt_data.runtime_reg + GP60, 1, DRV_NAME)) {\r\ndev_err(dev, "Failed to request region 0x%04x-0x%04x.\n",\r\nsch311x_wdt_data.runtime_reg + GP60,\r\nsch311x_wdt_data.runtime_reg + GP60);\r\nerr = -EBUSY;\r\ngoto exit_release_region;\r\n}\r\nif (!request_region(sch311x_wdt_data.runtime_reg + WDT_TIME_OUT, 4,\r\nDRV_NAME)) {\r\ndev_err(dev, "Failed to request region 0x%04x-0x%04x.\n",\r\nsch311x_wdt_data.runtime_reg + WDT_TIME_OUT,\r\nsch311x_wdt_data.runtime_reg + WDT_CTRL);\r\nerr = -EBUSY;\r\ngoto exit_release_region2;\r\n}\r\nsch311x_wdt_stop();\r\noutb(0, sch311x_wdt_data.runtime_reg + WDT_CFG);\r\nif (sch311x_wdt_set_heartbeat(timeout)) {\r\nsch311x_wdt_set_heartbeat(WATCHDOG_TIMEOUT);\r\ndev_info(dev, "timeout value must be 1<=x<=15300, using %d\n",\r\ntimeout);\r\n}\r\nsch311x_wdt_get_status(&sch311x_wdt_data.boot_status);\r\noutb(0, sch311x_wdt_data.runtime_reg + RESGEN);\r\nval = therm_trip ? 0x06 : 0x04;\r\noutb(val, sch311x_wdt_data.runtime_reg + RESGEN);\r\nsch311x_wdt_miscdev.parent = dev;\r\nerr = misc_register(&sch311x_wdt_miscdev);\r\nif (err != 0) {\r\ndev_err(dev, "cannot register miscdev on minor=%d (err=%d)\n",\r\nWATCHDOG_MINOR, err);\r\ngoto exit_release_region3;\r\n}\r\ndev_info(dev,\r\n"SMSC SCH311x WDT initialized. timeout=%d sec (nowayout=%d)\n",\r\ntimeout, nowayout);\r\nreturn 0;\r\nexit_release_region3:\r\nrelease_region(sch311x_wdt_data.runtime_reg + WDT_TIME_OUT, 4);\r\nexit_release_region2:\r\nrelease_region(sch311x_wdt_data.runtime_reg + GP60, 1);\r\nexit_release_region:\r\nrelease_region(sch311x_wdt_data.runtime_reg + RESGEN, 1);\r\nsch311x_wdt_data.runtime_reg = 0;\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __devexit sch311x_wdt_remove(struct platform_device *pdev)\r\n{\r\nif (!nowayout)\r\nsch311x_wdt_stop();\r\nmisc_deregister(&sch311x_wdt_miscdev);\r\nrelease_region(sch311x_wdt_data.runtime_reg + WDT_TIME_OUT, 4);\r\nrelease_region(sch311x_wdt_data.runtime_reg + GP60, 1);\r\nrelease_region(sch311x_wdt_data.runtime_reg + RESGEN, 1);\r\nsch311x_wdt_data.runtime_reg = 0;\r\nreturn 0;\r\n}\r\nstatic void sch311x_wdt_shutdown(struct platform_device *dev)\r\n{\r\nsch311x_wdt_stop();\r\n}\r\nstatic int __init sch311x_detect(int sio_config_port, unsigned short *addr)\r\n{\r\nint err = 0, reg;\r\nunsigned short base_addr;\r\nunsigned char dev_id;\r\nsch311x_sio_enter(sio_config_port);\r\nreg = force_id ? force_id : sch311x_sio_inb(sio_config_port, 0x20);\r\nif (!(reg == 0x7c || reg == 0x7d || reg == 0x7f)) {\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\ndev_id = reg == 0x7c ? 2 : reg == 0x7d ? 4 : 6;\r\nsch311x_sio_outb(sio_config_port, 0x07, 0x0a);\r\nif ((sch311x_sio_inb(sio_config_port, 0x30) & 0x01) == 0)\r\nprintk(KERN_INFO PFX "Seems that LDN 0x0a is not active...\n");\r\nbase_addr = (sch311x_sio_inb(sio_config_port, 0x60) << 8) |\r\nsch311x_sio_inb(sio_config_port, 0x61);\r\nif (!base_addr) {\r\nprintk(KERN_ERR PFX "Base address not set.\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\n*addr = base_addr;\r\nprintk(KERN_INFO PFX "Found an SMSC SCH311%d chip at 0x%04x\n",\r\ndev_id, base_addr);\r\nexit:\r\nsch311x_sio_exit(sio_config_port);\r\nreturn err;\r\n}\r\nstatic int __init sch311x_wdt_init(void)\r\n{\r\nint err, i, found = 0;\r\nunsigned short addr = 0;\r\nfor (i = 0; !found && sch311x_ioports[i]; i++)\r\nif (sch311x_detect(sch311x_ioports[i], &addr) == 0)\r\nfound++;\r\nif (!found)\r\nreturn -ENODEV;\r\nsch311x_wdt_data.runtime_reg = addr;\r\nerr = platform_driver_register(&sch311x_wdt_driver);\r\nif (err)\r\nreturn err;\r\nsch311x_wdt_pdev = platform_device_register_simple(DRV_NAME, addr,\r\nNULL, 0);\r\nif (IS_ERR(sch311x_wdt_pdev)) {\r\nerr = PTR_ERR(sch311x_wdt_pdev);\r\ngoto unreg_platform_driver;\r\n}\r\nreturn 0;\r\nunreg_platform_driver:\r\nplatform_driver_unregister(&sch311x_wdt_driver);\r\nreturn err;\r\n}\r\nstatic void __exit sch311x_wdt_exit(void)\r\n{\r\nplatform_device_unregister(sch311x_wdt_pdev);\r\nplatform_driver_unregister(&sch311x_wdt_driver);\r\n}
