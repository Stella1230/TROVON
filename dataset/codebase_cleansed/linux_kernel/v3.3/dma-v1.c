static void imx_dmav1_writel(unsigned val, unsigned offset)\r\n{\r\n__raw_writel(val, imx_dmav1_baseaddr + offset);\r\n}\r\nstatic unsigned imx_dmav1_readl(unsigned offset)\r\n{\r\nreturn __raw_readl(imx_dmav1_baseaddr + offset);\r\n}\r\nstatic int imx_dma_hw_chain(struct imx_dma_channel *imxdma)\r\n{\r\nif (cpu_is_mx27())\r\nreturn imxdma->hw_chaining;\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline int imx_dma_sg_next(int channel, struct scatterlist *sg)\r\n{\r\nstruct imx_dma_channel *imxdma = &imx_dma_channels[channel];\r\nunsigned long now;\r\nif (!imxdma->name) {\r\nprintk(KERN_CRIT "%s: called for not allocated channel %d\n",\r\n__func__, channel);\r\nreturn 0;\r\n}\r\nnow = min(imxdma->resbytes, sg->length);\r\nif (imxdma->resbytes != IMX_DMA_LENGTH_LOOP)\r\nimxdma->resbytes -= now;\r\nif ((imxdma->dma_mode & DMA_MODE_MASK) == DMA_MODE_READ)\r\nimx_dmav1_writel(sg->dma_address, DMA_DAR(channel));\r\nelse\r\nimx_dmav1_writel(sg->dma_address, DMA_SAR(channel));\r\nimx_dmav1_writel(now, DMA_CNTR(channel));\r\npr_debug("imxdma%d: next sg chunk dst 0x%08x, src 0x%08x, "\r\n"size 0x%08x\n", channel,\r\nimx_dmav1_readl(DMA_DAR(channel)),\r\nimx_dmav1_readl(DMA_SAR(channel)),\r\nimx_dmav1_readl(DMA_CNTR(channel)));\r\nreturn now;\r\n}\r\nint\r\nimx_dma_setup_single(int channel, dma_addr_t dma_address,\r\nunsigned int dma_length, unsigned int dev_addr,\r\nunsigned int dmamode)\r\n{\r\nstruct imx_dma_channel *imxdma = &imx_dma_channels[channel];\r\nimxdma->sg = NULL;\r\nimxdma->dma_mode = dmamode;\r\nif (!dma_address) {\r\nprintk(KERN_ERR "imxdma%d: imx_dma_setup_single null address\n",\r\nchannel);\r\nreturn -EINVAL;\r\n}\r\nif (!dma_length) {\r\nprintk(KERN_ERR "imxdma%d: imx_dma_setup_single zero length\n",\r\nchannel);\r\nreturn -EINVAL;\r\n}\r\nif ((dmamode & DMA_MODE_MASK) == DMA_MODE_READ) {\r\npr_debug("imxdma%d: %s dma_addressg=0x%08x dma_length=%d "\r\n"dev_addr=0x%08x for read\n",\r\nchannel, __func__, (unsigned int)dma_address,\r\ndma_length, dev_addr);\r\nimx_dmav1_writel(dev_addr, DMA_SAR(channel));\r\nimx_dmav1_writel(dma_address, DMA_DAR(channel));\r\nimx_dmav1_writel(imxdma->ccr_from_device, DMA_CCR(channel));\r\n} else if ((dmamode & DMA_MODE_MASK) == DMA_MODE_WRITE) {\r\npr_debug("imxdma%d: %s dma_addressg=0x%08x dma_length=%d "\r\n"dev_addr=0x%08x for write\n",\r\nchannel, __func__, (unsigned int)dma_address,\r\ndma_length, dev_addr);\r\nimx_dmav1_writel(dma_address, DMA_SAR(channel));\r\nimx_dmav1_writel(dev_addr, DMA_DAR(channel));\r\nimx_dmav1_writel(imxdma->ccr_to_device,\r\nDMA_CCR(channel));\r\n} else {\r\nprintk(KERN_ERR "imxdma%d: imx_dma_setup_single bad dmamode\n",\r\nchannel);\r\nreturn -EINVAL;\r\n}\r\nimx_dmav1_writel(dma_length, DMA_CNTR(channel));\r\nreturn 0;\r\n}\r\nint\r\nimx_dma_setup_sg(int channel,\r\nstruct scatterlist *sg, unsigned int sgcount,\r\nunsigned int dma_length, unsigned int dev_addr,\r\nunsigned int dmamode)\r\n{\r\nstruct imx_dma_channel *imxdma = &imx_dma_channels[channel];\r\nif (imxdma->in_use)\r\nreturn -EBUSY;\r\nimxdma->sg = sg;\r\nimxdma->dma_mode = dmamode;\r\nimxdma->resbytes = dma_length;\r\nif (!sg || !sgcount) {\r\nprintk(KERN_ERR "imxdma%d: imx_dma_setup_sg empty sg list\n",\r\nchannel);\r\nreturn -EINVAL;\r\n}\r\nif (!sg->length) {\r\nprintk(KERN_ERR "imxdma%d: imx_dma_setup_sg zero length\n",\r\nchannel);\r\nreturn -EINVAL;\r\n}\r\nif ((dmamode & DMA_MODE_MASK) == DMA_MODE_READ) {\r\npr_debug("imxdma%d: %s sg=%p sgcount=%d total length=%d "\r\n"dev_addr=0x%08x for read\n",\r\nchannel, __func__, sg, sgcount, dma_length, dev_addr);\r\nimx_dmav1_writel(dev_addr, DMA_SAR(channel));\r\nimx_dmav1_writel(imxdma->ccr_from_device, DMA_CCR(channel));\r\n} else if ((dmamode & DMA_MODE_MASK) == DMA_MODE_WRITE) {\r\npr_debug("imxdma%d: %s sg=%p sgcount=%d total length=%d "\r\n"dev_addr=0x%08x for write\n",\r\nchannel, __func__, sg, sgcount, dma_length, dev_addr);\r\nimx_dmav1_writel(dev_addr, DMA_DAR(channel));\r\nimx_dmav1_writel(imxdma->ccr_to_device, DMA_CCR(channel));\r\n} else {\r\nprintk(KERN_ERR "imxdma%d: imx_dma_setup_sg bad dmamode\n",\r\nchannel);\r\nreturn -EINVAL;\r\n}\r\nimx_dma_sg_next(channel, sg);\r\nreturn 0;\r\n}\r\nint\r\nimx_dma_config_channel(int channel, unsigned int config_port,\r\nunsigned int config_mem, unsigned int dmareq, int hw_chaining)\r\n{\r\nstruct imx_dma_channel *imxdma = &imx_dma_channels[channel];\r\nu32 dreq = 0;\r\nimxdma->hw_chaining = 0;\r\nif (hw_chaining) {\r\nimxdma->hw_chaining = 1;\r\nif (!imx_dma_hw_chain(imxdma))\r\nreturn -EINVAL;\r\n}\r\nif (dmareq)\r\ndreq = CCR_REN;\r\nimxdma->ccr_from_device = config_port | (config_mem << 2) | dreq;\r\nimxdma->ccr_to_device = config_mem | (config_port << 2) | dreq;\r\nimx_dmav1_writel(dmareq, DMA_RSSR(channel));\r\nreturn 0;\r\n}\r\nvoid imx_dma_config_burstlen(int channel, unsigned int burstlen)\r\n{\r\nimx_dmav1_writel(burstlen, DMA_BLR(channel));\r\n}\r\nint\r\nimx_dma_setup_handlers(int channel,\r\nvoid (*irq_handler) (int, void *),\r\nvoid (*err_handler) (int, void *, int),\r\nvoid *data)\r\n{\r\nstruct imx_dma_channel *imxdma = &imx_dma_channels[channel];\r\nunsigned long flags;\r\nif (!imxdma->name) {\r\nprintk(KERN_CRIT "%s: called for not allocated channel %d\n",\r\n__func__, channel);\r\nreturn -ENODEV;\r\n}\r\nlocal_irq_save(flags);\r\nimx_dmav1_writel(1 << channel, DMA_DISR);\r\nimxdma->irq_handler = irq_handler;\r\nimxdma->err_handler = err_handler;\r\nimxdma->data = data;\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nint\r\nimx_dma_setup_progression_handler(int channel,\r\nvoid (*prog_handler) (int, void*, struct scatterlist*))\r\n{\r\nstruct imx_dma_channel *imxdma = &imx_dma_channels[channel];\r\nunsigned long flags;\r\nif (!imxdma->name) {\r\nprintk(KERN_CRIT "%s: called for not allocated channel %d\n",\r\n__func__, channel);\r\nreturn -ENODEV;\r\n}\r\nlocal_irq_save(flags);\r\nimxdma->prog_handler = prog_handler;\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nvoid imx_dma_enable(int channel)\r\n{\r\nstruct imx_dma_channel *imxdma = &imx_dma_channels[channel];\r\nunsigned long flags;\r\npr_debug("imxdma%d: imx_dma_enable\n", channel);\r\nif (!imxdma->name) {\r\nprintk(KERN_CRIT "%s: called for not allocated channel %d\n",\r\n__func__, channel);\r\nreturn;\r\n}\r\nif (imxdma->in_use)\r\nreturn;\r\nlocal_irq_save(flags);\r\nimx_dmav1_writel(1 << channel, DMA_DISR);\r\nimx_dmav1_writel(imx_dmav1_readl(DMA_DIMR) & ~(1 << channel), DMA_DIMR);\r\nimx_dmav1_writel(imx_dmav1_readl(DMA_CCR(channel)) | CCR_CEN |\r\nCCR_ACRPT, DMA_CCR(channel));\r\nif ((cpu_is_mx21() || cpu_is_mx27()) &&\r\nimxdma->sg && imx_dma_hw_chain(imxdma)) {\r\nimxdma->sg = sg_next(imxdma->sg);\r\nif (imxdma->sg) {\r\nu32 tmp;\r\nimx_dma_sg_next(channel, imxdma->sg);\r\ntmp = imx_dmav1_readl(DMA_CCR(channel));\r\nimx_dmav1_writel(tmp | CCR_RPT | CCR_ACRPT,\r\nDMA_CCR(channel));\r\n}\r\n}\r\nimxdma->in_use = 1;\r\nlocal_irq_restore(flags);\r\n}\r\nvoid imx_dma_disable(int channel)\r\n{\r\nstruct imx_dma_channel *imxdma = &imx_dma_channels[channel];\r\nunsigned long flags;\r\npr_debug("imxdma%d: imx_dma_disable\n", channel);\r\nif (imx_dma_hw_chain(imxdma))\r\ndel_timer(&imxdma->watchdog);\r\nlocal_irq_save(flags);\r\nimx_dmav1_writel(imx_dmav1_readl(DMA_DIMR) | (1 << channel), DMA_DIMR);\r\nimx_dmav1_writel(imx_dmav1_readl(DMA_CCR(channel)) & ~CCR_CEN,\r\nDMA_CCR(channel));\r\nimx_dmav1_writel(1 << channel, DMA_DISR);\r\nimxdma->in_use = 0;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void imx_dma_watchdog(unsigned long chno)\r\n{\r\nstruct imx_dma_channel *imxdma = &imx_dma_channels[chno];\r\nimx_dmav1_writel(0, DMA_CCR(chno));\r\nimxdma->in_use = 0;\r\nimxdma->sg = NULL;\r\nif (imxdma->err_handler)\r\nimxdma->err_handler(chno, imxdma->data, IMX_DMA_ERR_TIMEOUT);\r\n}\r\nstatic irqreturn_t dma_err_handler(int irq, void *dev_id)\r\n{\r\nint i, disr;\r\nstruct imx_dma_channel *imxdma;\r\nunsigned int err_mask;\r\nint errcode;\r\ndisr = imx_dmav1_readl(DMA_DISR);\r\nerr_mask = imx_dmav1_readl(DMA_DBTOSR) |\r\nimx_dmav1_readl(DMA_DRTOSR) |\r\nimx_dmav1_readl(DMA_DSESR) |\r\nimx_dmav1_readl(DMA_DBOSR);\r\nif (!err_mask)\r\nreturn IRQ_HANDLED;\r\nimx_dmav1_writel(disr & err_mask, DMA_DISR);\r\nfor (i = 0; i < IMX_DMA_CHANNELS; i++) {\r\nif (!(err_mask & (1 << i)))\r\ncontinue;\r\nimxdma = &imx_dma_channels[i];\r\nerrcode = 0;\r\nif (imx_dmav1_readl(DMA_DBTOSR) & (1 << i)) {\r\nimx_dmav1_writel(1 << i, DMA_DBTOSR);\r\nerrcode |= IMX_DMA_ERR_BURST;\r\n}\r\nif (imx_dmav1_readl(DMA_DRTOSR) & (1 << i)) {\r\nimx_dmav1_writel(1 << i, DMA_DRTOSR);\r\nerrcode |= IMX_DMA_ERR_REQUEST;\r\n}\r\nif (imx_dmav1_readl(DMA_DSESR) & (1 << i)) {\r\nimx_dmav1_writel(1 << i, DMA_DSESR);\r\nerrcode |= IMX_DMA_ERR_TRANSFER;\r\n}\r\nif (imx_dmav1_readl(DMA_DBOSR) & (1 << i)) {\r\nimx_dmav1_writel(1 << i, DMA_DBOSR);\r\nerrcode |= IMX_DMA_ERR_BUFFER;\r\n}\r\nif (imxdma->name && imxdma->err_handler) {\r\nimxdma->err_handler(i, imxdma->data, errcode);\r\ncontinue;\r\n}\r\nimx_dma_channels[i].sg = NULL;\r\nprintk(KERN_WARNING\r\n"DMA timeout on channel %d (%s) -%s%s%s%s\n",\r\ni, imxdma->name,\r\nerrcode & IMX_DMA_ERR_BURST ? " burst" : "",\r\nerrcode & IMX_DMA_ERR_REQUEST ? " request" : "",\r\nerrcode & IMX_DMA_ERR_TRANSFER ? " transfer" : "",\r\nerrcode & IMX_DMA_ERR_BUFFER ? " buffer" : "");\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void dma_irq_handle_channel(int chno)\r\n{\r\nstruct imx_dma_channel *imxdma = &imx_dma_channels[chno];\r\nif (!imxdma->name) {\r\nprintk(KERN_WARNING\r\n"spurious IRQ for DMA channel %d\n", chno);\r\nreturn;\r\n}\r\nif (imxdma->sg) {\r\nu32 tmp;\r\nstruct scatterlist *current_sg = imxdma->sg;\r\nimxdma->sg = sg_next(imxdma->sg);\r\nif (imxdma->sg) {\r\nimx_dma_sg_next(chno, imxdma->sg);\r\ntmp = imx_dmav1_readl(DMA_CCR(chno));\r\nif (imx_dma_hw_chain(imxdma)) {\r\nmod_timer(&imxdma->watchdog,\r\njiffies + msecs_to_jiffies(500));\r\ntmp |= CCR_CEN | CCR_RPT | CCR_ACRPT;\r\nimx_dmav1_writel(tmp, DMA_CCR(chno));\r\n} else {\r\nimx_dmav1_writel(tmp & ~CCR_CEN, DMA_CCR(chno));\r\ntmp |= CCR_CEN;\r\n}\r\nimx_dmav1_writel(tmp, DMA_CCR(chno));\r\nif (imxdma->prog_handler)\r\nimxdma->prog_handler(chno, imxdma->data,\r\ncurrent_sg);\r\nreturn;\r\n}\r\nif (imx_dma_hw_chain(imxdma)) {\r\ndel_timer(&imxdma->watchdog);\r\nreturn;\r\n}\r\n}\r\nimx_dmav1_writel(0, DMA_CCR(chno));\r\nimxdma->in_use = 0;\r\nif (imxdma->irq_handler)\r\nimxdma->irq_handler(chno, imxdma->data);\r\n}\r\nstatic irqreturn_t dma_irq_handler(int irq, void *dev_id)\r\n{\r\nint i, disr;\r\nif (cpu_is_mx21() || cpu_is_mx27())\r\ndma_err_handler(irq, dev_id);\r\ndisr = imx_dmav1_readl(DMA_DISR);\r\npr_debug("imxdma: dma_irq_handler called, disr=0x%08x\n",\r\ndisr);\r\nimx_dmav1_writel(disr, DMA_DISR);\r\nfor (i = 0; i < IMX_DMA_CHANNELS; i++) {\r\nif (disr & (1 << i))\r\ndma_irq_handle_channel(i);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nint imx_dma_request(int channel, const char *name)\r\n{\r\nstruct imx_dma_channel *imxdma = &imx_dma_channels[channel];\r\nunsigned long flags;\r\nint ret = 0;\r\nif (!name)\r\nreturn -EINVAL;\r\nif (channel >= IMX_DMA_CHANNELS) {\r\nprintk(KERN_CRIT "%s: called for non-existed channel %d\n",\r\n__func__, channel);\r\nreturn -EINVAL;\r\n}\r\nlocal_irq_save(flags);\r\nif (imxdma->name) {\r\nlocal_irq_restore(flags);\r\nreturn -EBUSY;\r\n}\r\nmemset(imxdma, 0, sizeof(*imxdma));\r\nimxdma->name = name;\r\nlocal_irq_restore(flags);\r\nif (cpu_is_mx21() || cpu_is_mx27()) {\r\nret = request_irq(MX2x_INT_DMACH0 + channel,\r\ndma_irq_handler, 0, "DMA", NULL);\r\nif (ret) {\r\nimxdma->name = NULL;\r\npr_crit("Can't register IRQ %d for DMA channel %d\n",\r\nMX2x_INT_DMACH0 + channel, channel);\r\nreturn ret;\r\n}\r\ninit_timer(&imxdma->watchdog);\r\nimxdma->watchdog.function = &imx_dma_watchdog;\r\nimxdma->watchdog.data = channel;\r\n}\r\nreturn ret;\r\n}\r\nvoid imx_dma_free(int channel)\r\n{\r\nunsigned long flags;\r\nstruct imx_dma_channel *imxdma = &imx_dma_channels[channel];\r\nif (!imxdma->name) {\r\nprintk(KERN_CRIT\r\n"%s: trying to free free channel %d\n",\r\n__func__, channel);\r\nreturn;\r\n}\r\nlocal_irq_save(flags);\r\nimx_dma_disable(channel);\r\nimxdma->name = NULL;\r\nif (cpu_is_mx21() || cpu_is_mx27())\r\nfree_irq(MX2x_INT_DMACH0 + channel, NULL);\r\nlocal_irq_restore(flags);\r\n}\r\nint imx_dma_request_by_prio(const char *name, enum imx_dma_prio prio)\r\n{\r\nint i;\r\nint best;\r\nswitch (prio) {\r\ncase (DMA_PRIO_HIGH):\r\nbest = 8;\r\nbreak;\r\ncase (DMA_PRIO_MEDIUM):\r\nbest = 4;\r\nbreak;\r\ncase (DMA_PRIO_LOW):\r\ndefault:\r\nbest = 0;\r\nbreak;\r\n}\r\nfor (i = best; i < IMX_DMA_CHANNELS; i++)\r\nif (!imx_dma_request(i, name))\r\nreturn i;\r\nfor (i = best - 1; i >= 0; i--)\r\nif (!imx_dma_request(i, name))\r\nreturn i;\r\nprintk(KERN_ERR "%s: no free DMA channel found\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nstatic int __init imx_dma_init(void)\r\n{\r\nint ret = 0;\r\nint i;\r\nif (cpu_is_mx1())\r\nimx_dmav1_baseaddr = MX1_IO_ADDRESS(MX1_DMA_BASE_ADDR);\r\nelse if (cpu_is_mx21())\r\nimx_dmav1_baseaddr = MX21_IO_ADDRESS(MX21_DMA_BASE_ADDR);\r\nelse if (cpu_is_mx27())\r\nimx_dmav1_baseaddr = MX27_IO_ADDRESS(MX27_DMA_BASE_ADDR);\r\nelse\r\nreturn 0;\r\ndma_clk = clk_get(NULL, "dma");\r\nif (IS_ERR(dma_clk))\r\nreturn PTR_ERR(dma_clk);\r\nclk_enable(dma_clk);\r\nimx_dmav1_writel(DCR_DRST, DMA_DCR);\r\nif (cpu_is_mx1()) {\r\nret = request_irq(MX1_DMA_INT, dma_irq_handler, 0, "DMA", NULL);\r\nif (ret) {\r\npr_crit("Wow! Can't register IRQ for DMA\n");\r\nreturn ret;\r\n}\r\nret = request_irq(MX1_DMA_ERR, dma_err_handler, 0, "DMA", NULL);\r\nif (ret) {\r\npr_crit("Wow! Can't register ERRIRQ for DMA\n");\r\nfree_irq(MX1_DMA_INT, NULL);\r\nreturn ret;\r\n}\r\n}\r\nimx_dmav1_writel(DCR_DEN, DMA_DCR);\r\nimx_dmav1_writel((1 << IMX_DMA_CHANNELS) - 1, DMA_DISR);\r\nimx_dmav1_writel((1 << IMX_DMA_CHANNELS) - 1, DMA_DIMR);\r\nfor (i = 0; i < IMX_DMA_CHANNELS; i++) {\r\nimx_dma_channels[i].sg = NULL;\r\nimx_dma_channels[i].dma_num = i;\r\n}\r\nreturn ret;\r\n}
