static int pb0100_probe(struct sd *sd)\r\n{\r\nu16 sensor;\r\nint i, err;\r\ns32 *sensor_settings;\r\nerr = stv06xx_read_sensor(sd, PB_IDENT, &sensor);\r\nif (err < 0)\r\nreturn -ENODEV;\r\nif ((sensor >> 8) == 0x64) {\r\nsensor_settings = kmalloc(\r\nARRAY_SIZE(pb0100_ctrl) * sizeof(s32),\r\nGFP_KERNEL);\r\nif (!sensor_settings)\r\nreturn -ENOMEM;\r\npr_info("Photobit pb0100 sensor detected\n");\r\nsd->gspca_dev.cam.cam_mode = pb0100_mode;\r\nsd->gspca_dev.cam.nmodes = ARRAY_SIZE(pb0100_mode);\r\nsd->desc.ctrls = pb0100_ctrl;\r\nsd->desc.nctrls = ARRAY_SIZE(pb0100_ctrl);\r\nfor (i = 0; i < sd->desc.nctrls; i++)\r\nsensor_settings[i] = pb0100_ctrl[i].qctrl.default_value;\r\nsd->sensor_priv = sensor_settings;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int pb0100_start(struct sd *sd)\r\n{\r\nint err, packet_size, max_packet_size;\r\nstruct usb_host_interface *alt;\r\nstruct usb_interface *intf;\r\nstruct cam *cam = &sd->gspca_dev.cam;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nu32 mode = cam->cam_mode[sd->gspca_dev.curr_mode].priv;\r\nintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\r\nalt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\r\nif (!alt)\r\nreturn -ENODEV;\r\npacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\r\nmax_packet_size = sd->sensor->max_packet_size[sd->gspca_dev.curr_mode];\r\nif (packet_size < max_packet_size)\r\nstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(4)|BIT(3)|BIT(1));\r\nelse\r\nstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(5)|BIT(3)|BIT(1));\r\nif (mode & PB0100_CROP_TO_VGA) {\r\nstv06xx_write_sensor(sd, PB_RSTART, 30);\r\nstv06xx_write_sensor(sd, PB_CSTART, 20);\r\nstv06xx_write_sensor(sd, PB_RWSIZE, 240 - 1);\r\nstv06xx_write_sensor(sd, PB_CWSIZE, 320 - 1);\r\n} else {\r\nstv06xx_write_sensor(sd, PB_RSTART, 8);\r\nstv06xx_write_sensor(sd, PB_CSTART, 4);\r\nstv06xx_write_sensor(sd, PB_RWSIZE, 288 - 1);\r\nstv06xx_write_sensor(sd, PB_CWSIZE, 352 - 1);\r\n}\r\nif (mode & PB0100_SUBSAMPLE) {\r\nstv06xx_write_bridge(sd, STV_Y_CTRL, 0x02);\r\nstv06xx_write_bridge(sd, STV_X_CTRL, 0x06);\r\nstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x10);\r\n} else {\r\nstv06xx_write_bridge(sd, STV_Y_CTRL, 0x01);\r\nstv06xx_write_bridge(sd, STV_X_CTRL, 0x0a);\r\nstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x20);\r\n}\r\npb0100_set_gain(&sd->gspca_dev, sensor_settings[GAIN_IDX]);\r\npb0100_set_exposure(&sd->gspca_dev, sensor_settings[EXPOSURE_IDX]);\r\npb0100_set_autogain_target(&sd->gspca_dev,\r\nsensor_settings[AUTOGAIN_TARGET_IDX]);\r\npb0100_set_autogain(&sd->gspca_dev, sensor_settings[AUTOGAIN_IDX]);\r\nerr = stv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3)|BIT(1));\r\nPDEBUG(D_STREAM, "Started stream, status: %d", err);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int pb0100_stop(struct sd *sd)\r\n{\r\nint err;\r\nerr = stv06xx_write_sensor(sd, PB_ABORTFRAME, 1);\r\nif (err < 0)\r\ngoto out;\r\nerr = stv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3));\r\nPDEBUG(D_STREAM, "Halting stream");\r\nout:\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic void pb0100_disconnect(struct sd *sd)\r\n{\r\nsd->sensor = NULL;\r\nkfree(sd->sensor_priv);\r\n}\r\nstatic int pb0100_init(struct sd *sd)\r\n{\r\nstv06xx_write_bridge(sd, STV_REG00, 1);\r\nstv06xx_write_bridge(sd, STV_SCAN_RATE, 0);\r\nstv06xx_write_sensor(sd, PB_RESET, 1);\r\nstv06xx_write_sensor(sd, PB_RESET, 0);\r\nstv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3));\r\nstv06xx_write_sensor(sd, PB_PREADCTRL, BIT(12)|BIT(10)|BIT(6));\r\nstv06xx_write_sensor(sd, PB_ADCGLOBALGAIN, 12);\r\nstv06xx_write_sensor(sd, PB_R28, 12);\r\nstv06xx_write_sensor(sd, PB_ADCMAXGAIN, 180);\r\nstv06xx_write_sensor(sd, PB_ADCMINGAIN, 12);\r\nstv06xx_write_sensor(sd, PB_R54, 3);\r\nstv06xx_write_sensor(sd, PB_R55, 0);\r\nstv06xx_write_sensor(sd, PB_UPDATEINT, 1);\r\nstv06xx_write_sensor(sd, PB_R15, 800);\r\nstv06xx_write_sensor(sd, PB_R17, 10);\r\nstv06xx_write_sensor(sd, PB_EXPGAIN, 0);\r\nstv06xx_write_sensor(sd, PB_VOFFSET, 0);\r\nstv06xx_write_sensor(sd, PB_ADCGAINH, 11);\r\nstv06xx_write_sensor(sd, PB_ADCGAINL, 0);\r\nstv06xx_write_bridge(sd, STV_REG00, 0x11);\r\nstv06xx_write_bridge(sd, STV_REG03, 0x45);\r\nstv06xx_write_bridge(sd, STV_REG04, 0x07);\r\nstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(4)|BIT(3)|BIT(1));\r\nstv06xx_write_sensor(sd, PB_CFILLIN, 14);\r\nstv06xx_write_sensor(sd, PB_VBL, 0);\r\nstv06xx_write_sensor(sd, PB_FINTTIME, 0);\r\nstv06xx_write_sensor(sd, PB_RINTTIME, 123);\r\nstv06xx_write_bridge(sd, STV_REG01, 0xc2);\r\nstv06xx_write_bridge(sd, STV_REG02, 0xb0);\r\nreturn 0;\r\n}\r\nstatic int pb0100_dump(struct sd *sd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pb0100_get_gain(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[GAIN_IDX];\r\nreturn 0;\r\n}\r\nstatic int pb0100_set_gain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nif (sensor_settings[AUTOGAIN_IDX])\r\nreturn -EBUSY;\r\nsensor_settings[GAIN_IDX] = val;\r\nerr = stv06xx_write_sensor(sd, PB_G1GAIN, val);\r\nif (!err)\r\nerr = stv06xx_write_sensor(sd, PB_G2GAIN, val);\r\nPDEBUG(D_V4L2, "Set green gain to %d, status: %d", val, err);\r\nif (!err)\r\nerr = pb0100_set_red_balance(gspca_dev,\r\nsensor_settings[RED_BALANCE_IDX]);\r\nif (!err)\r\nerr = pb0100_set_blue_balance(gspca_dev,\r\nsensor_settings[BLUE_BALANCE_IDX]);\r\nreturn err;\r\n}\r\nstatic int pb0100_get_red_balance(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[RED_BALANCE_IDX];\r\nreturn 0;\r\n}\r\nstatic int pb0100_set_red_balance(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nif (sensor_settings[AUTOGAIN_IDX])\r\nreturn -EBUSY;\r\nsensor_settings[RED_BALANCE_IDX] = val;\r\nval += sensor_settings[GAIN_IDX];\r\nif (val < 0)\r\nval = 0;\r\nelse if (val > 255)\r\nval = 255;\r\nerr = stv06xx_write_sensor(sd, PB_RGAIN, val);\r\nPDEBUG(D_V4L2, "Set red gain to %d, status: %d", val, err);\r\nreturn err;\r\n}\r\nstatic int pb0100_get_blue_balance(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[BLUE_BALANCE_IDX];\r\nreturn 0;\r\n}\r\nstatic int pb0100_set_blue_balance(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nif (sensor_settings[AUTOGAIN_IDX])\r\nreturn -EBUSY;\r\nsensor_settings[BLUE_BALANCE_IDX] = val;\r\nval += sensor_settings[GAIN_IDX];\r\nif (val < 0)\r\nval = 0;\r\nelse if (val > 255)\r\nval = 255;\r\nerr = stv06xx_write_sensor(sd, PB_BGAIN, val);\r\nPDEBUG(D_V4L2, "Set blue gain to %d, status: %d", val, err);\r\nreturn err;\r\n}\r\nstatic int pb0100_get_exposure(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[EXPOSURE_IDX];\r\nreturn 0;\r\n}\r\nstatic int pb0100_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nif (sensor_settings[AUTOGAIN_IDX])\r\nreturn -EBUSY;\r\nsensor_settings[EXPOSURE_IDX] = val;\r\nerr = stv06xx_write_sensor(sd, PB_RINTTIME, val);\r\nPDEBUG(D_V4L2, "Set exposure to %d, status: %d", val, err);\r\nreturn err;\r\n}\r\nstatic int pb0100_get_autogain(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[AUTOGAIN_IDX];\r\nreturn 0;\r\n}\r\nstatic int pb0100_set_autogain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nsensor_settings[AUTOGAIN_IDX] = val;\r\nif (sensor_settings[AUTOGAIN_IDX]) {\r\nif (sensor_settings[NATURAL_IDX])\r\nval = BIT(6)|BIT(4)|BIT(0);\r\nelse\r\nval = BIT(4)|BIT(0);\r\n} else\r\nval = 0;\r\nerr = stv06xx_write_sensor(sd, PB_EXPGAIN, val);\r\nPDEBUG(D_V4L2, "Set autogain to %d (natural: %d), status: %d",\r\nsensor_settings[AUTOGAIN_IDX], sensor_settings[NATURAL_IDX],\r\nerr);\r\nreturn err;\r\n}\r\nstatic int pb0100_get_autogain_target(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[AUTOGAIN_TARGET_IDX];\r\nreturn 0;\r\n}\r\nstatic int pb0100_set_autogain_target(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err, totalpixels, brightpixels, darkpixels;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nsensor_settings[AUTOGAIN_TARGET_IDX] = val;\r\ntotalpixels = gspca_dev->width * gspca_dev->height;\r\ntotalpixels = totalpixels/(8*8) + totalpixels/(64*64);\r\nbrightpixels = (totalpixels * val) >> 8;\r\ndarkpixels = totalpixels - brightpixels;\r\nerr = stv06xx_write_sensor(sd, PB_R21, brightpixels);\r\nif (!err)\r\nerr = stv06xx_write_sensor(sd, PB_R22, darkpixels);\r\nPDEBUG(D_V4L2, "Set autogain target to %d, status: %d", val, err);\r\nreturn err;\r\n}\r\nstatic int pb0100_get_natural(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[NATURAL_IDX];\r\nreturn 0;\r\n}\r\nstatic int pb0100_set_natural(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nsensor_settings[NATURAL_IDX] = val;\r\nreturn pb0100_set_autogain(gspca_dev, sensor_settings[AUTOGAIN_IDX]);\r\n}
