int dlm_init_lock_cache(void)\r\n{\r\ndlm_lock_cache = kmem_cache_create("o2dlm_lock",\r\nsizeof(struct dlm_lock),\r\n0, SLAB_HWCACHE_ALIGN, NULL);\r\nif (dlm_lock_cache == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid dlm_destroy_lock_cache(void)\r\n{\r\nif (dlm_lock_cache)\r\nkmem_cache_destroy(dlm_lock_cache);\r\n}\r\nstatic int dlm_can_grant_new_lock(struct dlm_lock_resource *res,\r\nstruct dlm_lock *lock)\r\n{\r\nstruct list_head *iter;\r\nstruct dlm_lock *tmplock;\r\nlist_for_each(iter, &res->granted) {\r\ntmplock = list_entry(iter, struct dlm_lock, list);\r\nif (!dlm_lock_compatible(tmplock->ml.type, lock->ml.type))\r\nreturn 0;\r\n}\r\nlist_for_each(iter, &res->converting) {\r\ntmplock = list_entry(iter, struct dlm_lock, list);\r\nif (!dlm_lock_compatible(tmplock->ml.type, lock->ml.type))\r\nreturn 0;\r\nif (!dlm_lock_compatible(tmplock->ml.convert_type,\r\nlock->ml.type))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic enum dlm_status dlmlock_master(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res,\r\nstruct dlm_lock *lock, int flags)\r\n{\r\nint call_ast = 0, kick_thread = 0;\r\nenum dlm_status status = DLM_NORMAL;\r\nmlog(0, "type=%d\n", lock->ml.type);\r\nspin_lock(&res->spinlock);\r\nstatus = __dlm_lockres_state_to_status(res);\r\nif (status != DLM_NORMAL &&\r\nlock->ml.node != dlm->node_num) {\r\nspin_unlock(&res->spinlock);\r\ndlm_error(status);\r\nreturn status;\r\n}\r\n__dlm_wait_on_lockres(res);\r\n__dlm_lockres_reserve_ast(res);\r\nif (dlm_can_grant_new_lock(res, lock)) {\r\nmlog(0, "I can grant this lock right away\n");\r\nlock->lksb->status = DLM_NORMAL;\r\nstatus = DLM_NORMAL;\r\ndlm_lock_get(lock);\r\nlist_add_tail(&lock->list, &res->granted);\r\nif (!dlm_is_recovery_lock(res->lockname.name,\r\nres->lockname.len)) {\r\nkick_thread = 1;\r\ncall_ast = 1;\r\n} else {\r\nmlog(0, "%s: returning DLM_NORMAL to "\r\n"node %u for reco lock\n", dlm->name,\r\nlock->ml.node);\r\n}\r\n} else {\r\nif (flags & LKM_NOQUEUE) {\r\nstatus = DLM_NOTQUEUED;\r\nif (dlm_is_recovery_lock(res->lockname.name,\r\nres->lockname.len)) {\r\nmlog(0, "%s: returning NOTQUEUED to "\r\n"node %u for reco lock\n", dlm->name,\r\nlock->ml.node);\r\n}\r\n} else {\r\ndlm_lock_get(lock);\r\nlist_add_tail(&lock->list, &res->blocked);\r\nkick_thread = 1;\r\n}\r\n}\r\nspin_unlock(&res->spinlock);\r\nwake_up(&res->wq);\r\nif (call_ast)\r\ndlm_queue_ast(dlm, lock);\r\nelse\r\ndlm_lockres_release_ast(dlm, res);\r\ndlm_lockres_calc_usage(dlm, res);\r\nif (kick_thread)\r\ndlm_kick_thread(dlm, res);\r\nreturn status;\r\n}\r\nvoid dlm_revert_pending_lock(struct dlm_lock_resource *res,\r\nstruct dlm_lock *lock)\r\n{\r\nlist_del_init(&lock->list);\r\nlock->lksb->flags &= ~DLM_LKSB_GET_LVB;\r\n}\r\nstatic enum dlm_status dlmlock_remote(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res,\r\nstruct dlm_lock *lock, int flags)\r\n{\r\nenum dlm_status status = DLM_DENIED;\r\nint lockres_changed = 1;\r\nmlog(0, "type=%d, lockres %.*s, flags = 0x%x\n",\r\nlock->ml.type, res->lockname.len,\r\nres->lockname.name, flags);\r\nspin_lock(&res->spinlock);\r\n__dlm_wait_on_lockres(res);\r\nif (res->owner == dlm->node_num) {\r\nspin_unlock(&res->spinlock);\r\nreturn DLM_RECOVERING;\r\n}\r\nres->state |= DLM_LOCK_RES_IN_PROGRESS;\r\ndlm_lock_get(lock);\r\nlist_add_tail(&lock->list, &res->blocked);\r\nlock->lock_pending = 1;\r\nspin_unlock(&res->spinlock);\r\nstatus = dlm_send_remote_lock_request(dlm, res, lock, flags);\r\nspin_lock(&res->spinlock);\r\nres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\r\nlock->lock_pending = 0;\r\nif (status != DLM_NORMAL) {\r\nif (status == DLM_RECOVERING &&\r\ndlm_is_recovery_lock(res->lockname.name,\r\nres->lockname.len)) {\r\nmlog(0, "%s: recovery lock was owned by "\r\n"dead node %u, remaster it now.\n",\r\ndlm->name, res->owner);\r\n} else if (status != DLM_NOTQUEUED) {\r\nlockres_changed = 0;\r\ndlm_error(status);\r\n}\r\ndlm_revert_pending_lock(res, lock);\r\ndlm_lock_put(lock);\r\n} else if (dlm_is_recovery_lock(res->lockname.name,\r\nres->lockname.len)) {\r\nmlog(0, "%s: $RECOVERY lock for this node (%u) is "\r\n"mastered by %u; got lock, manually granting (no ast)\n",\r\ndlm->name, dlm->node_num, res->owner);\r\nlist_move_tail(&lock->list, &res->granted);\r\n}\r\nspin_unlock(&res->spinlock);\r\nif (lockres_changed)\r\ndlm_lockres_calc_usage(dlm, res);\r\nwake_up(&res->wq);\r\nreturn status;\r\n}\r\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res,\r\nstruct dlm_lock *lock, int flags)\r\n{\r\nstruct dlm_create_lock create;\r\nint tmpret, status = 0;\r\nenum dlm_status ret;\r\nmemset(&create, 0, sizeof(create));\r\ncreate.node_idx = dlm->node_num;\r\ncreate.requested_type = lock->ml.type;\r\ncreate.cookie = lock->ml.cookie;\r\ncreate.namelen = res->lockname.len;\r\ncreate.flags = cpu_to_be32(flags);\r\nmemcpy(create.name, res->lockname.name, create.namelen);\r\ntmpret = o2net_send_message(DLM_CREATE_LOCK_MSG, dlm->key, &create,\r\nsizeof(create), res->owner, &status);\r\nif (tmpret >= 0) {\r\nret = status;\r\nif (ret == DLM_REJECTED) {\r\nmlog(ML_ERROR, "%s: res %.*s, Stale lockres no longer "\r\n"owned by node %u. That node is coming back up "\r\n"currently.\n", dlm->name, create.namelen,\r\ncreate.name, res->owner);\r\ndlm_print_one_lock_resource(res);\r\nBUG();\r\n}\r\n} else {\r\nmlog(ML_ERROR, "%s: res %.*s, Error %d send CREATE LOCK to "\r\n"node %u\n", dlm->name, create.namelen, create.name,\r\ntmpret, res->owner);\r\nif (dlm_is_host_down(tmpret))\r\nret = DLM_RECOVERING;\r\nelse\r\nret = dlm_err_to_dlm_status(tmpret);\r\n}\r\nreturn ret;\r\n}\r\nvoid dlm_lock_get(struct dlm_lock *lock)\r\n{\r\nkref_get(&lock->lock_refs);\r\n}\r\nvoid dlm_lock_put(struct dlm_lock *lock)\r\n{\r\nkref_put(&lock->lock_refs, dlm_lock_release);\r\n}\r\nstatic void dlm_lock_release(struct kref *kref)\r\n{\r\nstruct dlm_lock *lock;\r\nlock = container_of(kref, struct dlm_lock, lock_refs);\r\nBUG_ON(!list_empty(&lock->list));\r\nBUG_ON(!list_empty(&lock->ast_list));\r\nBUG_ON(!list_empty(&lock->bast_list));\r\nBUG_ON(lock->ast_pending);\r\nBUG_ON(lock->bast_pending);\r\ndlm_lock_detach_lockres(lock);\r\nif (lock->lksb_kernel_allocated) {\r\nmlog(0, "freeing kernel-allocated lksb\n");\r\nkfree(lock->lksb);\r\n}\r\nkmem_cache_free(dlm_lock_cache, lock);\r\n}\r\nvoid dlm_lock_attach_lockres(struct dlm_lock *lock,\r\nstruct dlm_lock_resource *res)\r\n{\r\ndlm_lockres_get(res);\r\nlock->lockres = res;\r\n}\r\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock)\r\n{\r\nstruct dlm_lock_resource *res;\r\nres = lock->lockres;\r\nif (res) {\r\nlock->lockres = NULL;\r\nmlog(0, "removing lock's lockres reference\n");\r\ndlm_lockres_put(res);\r\n}\r\n}\r\nstatic void dlm_init_lock(struct dlm_lock *newlock, int type,\r\nu8 node, u64 cookie)\r\n{\r\nINIT_LIST_HEAD(&newlock->list);\r\nINIT_LIST_HEAD(&newlock->ast_list);\r\nINIT_LIST_HEAD(&newlock->bast_list);\r\nspin_lock_init(&newlock->spinlock);\r\nnewlock->ml.type = type;\r\nnewlock->ml.convert_type = LKM_IVMODE;\r\nnewlock->ml.highest_blocked = LKM_IVMODE;\r\nnewlock->ml.node = node;\r\nnewlock->ml.pad1 = 0;\r\nnewlock->ml.list = 0;\r\nnewlock->ml.flags = 0;\r\nnewlock->ast = NULL;\r\nnewlock->bast = NULL;\r\nnewlock->astdata = NULL;\r\nnewlock->ml.cookie = cpu_to_be64(cookie);\r\nnewlock->ast_pending = 0;\r\nnewlock->bast_pending = 0;\r\nnewlock->convert_pending = 0;\r\nnewlock->lock_pending = 0;\r\nnewlock->unlock_pending = 0;\r\nnewlock->cancel_pending = 0;\r\nnewlock->lksb_kernel_allocated = 0;\r\nkref_init(&newlock->lock_refs);\r\n}\r\nstruct dlm_lock * dlm_new_lock(int type, u8 node, u64 cookie,\r\nstruct dlm_lockstatus *lksb)\r\n{\r\nstruct dlm_lock *lock;\r\nint kernel_allocated = 0;\r\nlock = kmem_cache_zalloc(dlm_lock_cache, GFP_NOFS);\r\nif (!lock)\r\nreturn NULL;\r\nif (!lksb) {\r\nlksb = kzalloc(sizeof(*lksb), GFP_NOFS);\r\nif (!lksb) {\r\nkmem_cache_free(dlm_lock_cache, lock);\r\nreturn NULL;\r\n}\r\nkernel_allocated = 1;\r\n}\r\ndlm_init_lock(lock, type, node, cookie);\r\nif (kernel_allocated)\r\nlock->lksb_kernel_allocated = 1;\r\nlock->lksb = lksb;\r\nlksb->lockid = lock;\r\nreturn lock;\r\n}\r\nint dlm_create_lock_handler(struct o2net_msg *msg, u32 len, void *data,\r\nvoid **ret_data)\r\n{\r\nstruct dlm_ctxt *dlm = data;\r\nstruct dlm_create_lock *create = (struct dlm_create_lock *)msg->buf;\r\nstruct dlm_lock_resource *res = NULL;\r\nstruct dlm_lock *newlock = NULL;\r\nstruct dlm_lockstatus *lksb = NULL;\r\nenum dlm_status status = DLM_NORMAL;\r\nchar *name;\r\nunsigned int namelen;\r\nBUG_ON(!dlm);\r\nif (!dlm_grab(dlm))\r\nreturn DLM_REJECTED;\r\nname = create->name;\r\nnamelen = create->namelen;\r\nstatus = DLM_REJECTED;\r\nif (!dlm_domain_fully_joined(dlm)) {\r\nmlog(ML_ERROR, "Domain %s not fully joined, but node %u is "\r\n"sending a create_lock message for lock %.*s!\n",\r\ndlm->name, create->node_idx, namelen, name);\r\ndlm_error(status);\r\ngoto leave;\r\n}\r\nstatus = DLM_IVBUFLEN;\r\nif (namelen > DLM_LOCKID_NAME_MAX) {\r\ndlm_error(status);\r\ngoto leave;\r\n}\r\nstatus = DLM_SYSERR;\r\nnewlock = dlm_new_lock(create->requested_type,\r\ncreate->node_idx,\r\nbe64_to_cpu(create->cookie), NULL);\r\nif (!newlock) {\r\ndlm_error(status);\r\ngoto leave;\r\n}\r\nlksb = newlock->lksb;\r\nif (be32_to_cpu(create->flags) & LKM_GET_LVB) {\r\nlksb->flags |= DLM_LKSB_GET_LVB;\r\nmlog(0, "set DLM_LKSB_GET_LVB flag\n");\r\n}\r\nstatus = DLM_IVLOCKID;\r\nres = dlm_lookup_lockres(dlm, name, namelen);\r\nif (!res) {\r\ndlm_error(status);\r\ngoto leave;\r\n}\r\nspin_lock(&res->spinlock);\r\nstatus = __dlm_lockres_state_to_status(res);\r\nspin_unlock(&res->spinlock);\r\nif (status != DLM_NORMAL) {\r\nmlog(0, "lockres recovering/migrating/in-progress\n");\r\ngoto leave;\r\n}\r\ndlm_lock_attach_lockres(newlock, res);\r\nstatus = dlmlock_master(dlm, res, newlock, be32_to_cpu(create->flags));\r\nleave:\r\nif (status != DLM_NORMAL)\r\nif (newlock)\r\ndlm_lock_put(newlock);\r\nif (res)\r\ndlm_lockres_put(res);\r\ndlm_put(dlm);\r\nreturn status;\r\n}\r\nstatic inline void dlm_get_next_cookie(u8 node_num, u64 *cookie)\r\n{\r\nu64 tmpnode = node_num;\r\ntmpnode <<= 56;\r\nspin_lock(&dlm_cookie_lock);\r\n*cookie = (dlm_next_cookie | tmpnode);\r\nif (++dlm_next_cookie & 0xff00000000000000ull) {\r\nmlog(0, "This node's cookie will now wrap!\n");\r\ndlm_next_cookie = 1;\r\n}\r\nspin_unlock(&dlm_cookie_lock);\r\n}\r\nenum dlm_status dlmlock(struct dlm_ctxt *dlm, int mode,\r\nstruct dlm_lockstatus *lksb, int flags,\r\nconst char *name, int namelen, dlm_astlockfunc_t *ast,\r\nvoid *data, dlm_bastlockfunc_t *bast)\r\n{\r\nenum dlm_status status;\r\nstruct dlm_lock_resource *res = NULL;\r\nstruct dlm_lock *lock = NULL;\r\nint convert = 0, recovery = 0;\r\nif (!lksb) {\r\ndlm_error(DLM_BADARGS);\r\nreturn DLM_BADARGS;\r\n}\r\nstatus = DLM_BADPARAM;\r\nif (mode != LKM_EXMODE && mode != LKM_PRMODE && mode != LKM_NLMODE) {\r\ndlm_error(status);\r\ngoto error;\r\n}\r\nif (flags & ~LKM_VALID_FLAGS) {\r\ndlm_error(status);\r\ngoto error;\r\n}\r\nconvert = (flags & LKM_CONVERT);\r\nrecovery = (flags & LKM_RECOVERY);\r\nif (recovery &&\r\n(!dlm_is_recovery_lock(name, namelen) || convert) ) {\r\ndlm_error(status);\r\ngoto error;\r\n}\r\nif (convert && (flags & LKM_LOCAL)) {\r\nmlog(ML_ERROR, "strange LOCAL convert request!\n");\r\ngoto error;\r\n}\r\nif (convert) {\r\nlock = lksb->lockid;\r\nif (!lock) {\r\nmlog(ML_ERROR, "NULL lock pointer in convert "\r\n"request\n");\r\ngoto error;\r\n}\r\nres = lock->lockres;\r\nif (!res) {\r\nmlog(ML_ERROR, "NULL lockres pointer in convert "\r\n"request\n");\r\ngoto error;\r\n}\r\ndlm_lockres_get(res);\r\nif (lock->lksb != lksb || lock->ast != ast ||\r\nlock->bast != bast || lock->astdata != data) {\r\nstatus = DLM_BADARGS;\r\nmlog(ML_ERROR, "new args: lksb=%p, ast=%p, bast=%p, "\r\n"astdata=%p\n", lksb, ast, bast, data);\r\nmlog(ML_ERROR, "orig args: lksb=%p, ast=%p, bast=%p, "\r\n"astdata=%p\n", lock->lksb, lock->ast,\r\nlock->bast, lock->astdata);\r\ngoto error;\r\n}\r\nretry_convert:\r\ndlm_wait_for_recovery(dlm);\r\nif (res->owner == dlm->node_num)\r\nstatus = dlmconvert_master(dlm, res, lock, flags, mode);\r\nelse\r\nstatus = dlmconvert_remote(dlm, res, lock, flags, mode);\r\nif (status == DLM_RECOVERING || status == DLM_MIGRATING ||\r\nstatus == DLM_FORWARD) {\r\nmlog(0, "retrying convert with migration/recovery/"\r\n"in-progress\n");\r\nmsleep(100);\r\ngoto retry_convert;\r\n}\r\n} else {\r\nu64 tmpcookie;\r\nstatus = DLM_BADARGS;\r\nif (!name) {\r\ndlm_error(status);\r\ngoto error;\r\n}\r\nstatus = DLM_IVBUFLEN;\r\nif (namelen > DLM_LOCKID_NAME_MAX || namelen < 1) {\r\ndlm_error(status);\r\ngoto error;\r\n}\r\ndlm_get_next_cookie(dlm->node_num, &tmpcookie);\r\nlock = dlm_new_lock(mode, dlm->node_num, tmpcookie, lksb);\r\nif (!lock) {\r\ndlm_error(status);\r\ngoto error;\r\n}\r\nif (!recovery)\r\ndlm_wait_for_recovery(dlm);\r\nres = dlm_get_lock_resource(dlm, name, namelen, flags);\r\nif (!res) {\r\nstatus = DLM_IVLOCKID;\r\ndlm_error(status);\r\ngoto error;\r\n}\r\nmlog(0, "type=%d, flags = 0x%x\n", mode, flags);\r\nmlog(0, "creating lock: lock=%p res=%p\n", lock, res);\r\ndlm_lock_attach_lockres(lock, res);\r\nlock->ast = ast;\r\nlock->bast = bast;\r\nlock->astdata = data;\r\nretry_lock:\r\nif (flags & LKM_VALBLK) {\r\nmlog(0, "LKM_VALBLK passed by caller\n");\r\nif (mode < LKM_PRMODE)\r\nflags &= ~LKM_VALBLK;\r\nelse {\r\nflags |= LKM_GET_LVB;\r\nlock->lksb->flags |= DLM_LKSB_GET_LVB;\r\n}\r\n}\r\nif (res->owner == dlm->node_num)\r\nstatus = dlmlock_master(dlm, res, lock, flags);\r\nelse\r\nstatus = dlmlock_remote(dlm, res, lock, flags);\r\nif (status == DLM_RECOVERING || status == DLM_MIGRATING ||\r\nstatus == DLM_FORWARD) {\r\nmsleep(100);\r\nif (recovery) {\r\nif (status != DLM_RECOVERING)\r\ngoto retry_lock;\r\ndlm_wait_for_node_death(dlm, res->owner,\r\nDLM_NODE_DEATH_WAIT_MAX);\r\n} else {\r\ndlm_wait_for_recovery(dlm);\r\ngoto retry_lock;\r\n}\r\n}\r\nspin_lock(&res->spinlock);\r\ndlm_lockres_drop_inflight_ref(dlm, res);\r\nspin_unlock(&res->spinlock);\r\ndlm_lockres_calc_usage(dlm, res);\r\ndlm_kick_thread(dlm, res);\r\nif (status != DLM_NORMAL) {\r\nlock->lksb->flags &= ~DLM_LKSB_GET_LVB;\r\nif (status != DLM_NOTQUEUED)\r\ndlm_error(status);\r\ngoto error;\r\n}\r\n}\r\nerror:\r\nif (status != DLM_NORMAL) {\r\nif (lock && !convert)\r\ndlm_lock_put(lock);\r\nlksb->status = status;\r\n}\r\nif (res)\r\ndlm_lockres_put(res);\r\nreturn status;\r\n}
