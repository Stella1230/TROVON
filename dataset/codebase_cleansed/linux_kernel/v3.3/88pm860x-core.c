static irqreturn_t pm860x_irq(int irq, void *data)\r\n{\r\nstruct pm860x_chip *chip = data;\r\nstruct pm860x_irq_data *irq_data;\r\nstruct i2c_client *i2c;\r\nint read_reg = -1, value = 0;\r\nint i;\r\ni2c = (chip->id == CHIP_PM8607) ? chip->client : chip->companion;\r\nfor (i = 0; i < ARRAY_SIZE(pm860x_irqs); i++) {\r\nirq_data = &pm860x_irqs[i];\r\nif (read_reg != irq_data->reg) {\r\nread_reg = irq_data->reg;\r\nvalue = pm860x_reg_read(i2c, irq_data->reg);\r\n}\r\nif (value & irq_data->enable)\r\nhandle_nested_irq(chip->irq_base + i);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pm860x_irq_lock(struct irq_data *data)\r\n{\r\nstruct pm860x_chip *chip = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&chip->irq_lock);\r\n}\r\nstatic void pm860x_irq_sync_unlock(struct irq_data *data)\r\n{\r\nstruct pm860x_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct pm860x_irq_data *irq_data;\r\nstruct i2c_client *i2c;\r\nstatic unsigned char cached[3] = {0x0, 0x0, 0x0};\r\nunsigned char mask[3];\r\nint i;\r\ni2c = (chip->id == CHIP_PM8607) ? chip->client : chip->companion;\r\nfor (i = 0; i < 3; i++)\r\nmask[i] = cached[i];\r\nfor (i = 0; i < ARRAY_SIZE(pm860x_irqs); i++) {\r\nirq_data = &pm860x_irqs[i];\r\nswitch (irq_data->mask_reg) {\r\ncase PM8607_INT_MASK_1:\r\nmask[0] &= ~irq_data->offs;\r\nmask[0] |= irq_data->enable;\r\nbreak;\r\ncase PM8607_INT_MASK_2:\r\nmask[1] &= ~irq_data->offs;\r\nmask[1] |= irq_data->enable;\r\nbreak;\r\ncase PM8607_INT_MASK_3:\r\nmask[2] &= ~irq_data->offs;\r\nmask[2] |= irq_data->enable;\r\nbreak;\r\ndefault:\r\ndev_err(chip->dev, "wrong IRQ\n");\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nif (mask[i] != cached[i]) {\r\ncached[i] = mask[i];\r\npm860x_reg_write(i2c, PM8607_INT_MASK_1 + i, mask[i]);\r\n}\r\n}\r\nmutex_unlock(&chip->irq_lock);\r\n}\r\nstatic void pm860x_irq_enable(struct irq_data *data)\r\n{\r\nstruct pm860x_chip *chip = irq_data_get_irq_chip_data(data);\r\npm860x_irqs[data->irq - chip->irq_base].enable\r\n= pm860x_irqs[data->irq - chip->irq_base].offs;\r\n}\r\nstatic void pm860x_irq_disable(struct irq_data *data)\r\n{\r\nstruct pm860x_chip *chip = irq_data_get_irq_chip_data(data);\r\npm860x_irqs[data->irq - chip->irq_base].enable = 0;\r\n}\r\nstatic int __devinit device_gpadc_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nstruct i2c_client *i2c = (chip->id == CHIP_PM8607) ? chip->client \\r\n: chip->companion;\r\nint data;\r\nint ret;\r\nif (!pdata || !pdata->touch)\r\nreturn -EINVAL;\r\ndata = 0;\r\ndata |= (pdata->touch->gpadc_prebias << 1) & PM8607_GPADC_PREBIAS_MASK;\r\ndata |= (pdata->touch->slot_cycle << 3) & PM8607_GPADC_SLOT_CYCLE_MASK;\r\ndata |= (pdata->touch->off_scale << 5) & PM8607_GPADC_OFF_SCALE_MASK;\r\ndata |= (pdata->touch->sw_cal << 7) & PM8607_GPADC_SW_CAL_MASK;\r\nif (data) {\r\nret = pm860x_reg_write(i2c, PM8607_GPADC_MISC1, data);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nif (pdata->touch->tsi_prebias) {\r\ndata = pdata->touch->tsi_prebias;\r\nret = pm860x_reg_write(i2c, PM8607_TSI_PREBIAS, data);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\ndata = 0;\r\ndata |= pdata->touch->pen_prebias & PM8607_PD_PREBIAS_MASK;\r\ndata |= (pdata->touch->pen_prechg << 5) & PM8607_PD_PRECHG_MASK;\r\nif (data) {\r\nret = pm860x_reg_write(i2c, PM8607_PD_PREBIAS, data);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nret = pm860x_set_bits(i2c, PM8607_GPADC_MISC1,\r\nPM8607_GPADC_EN, PM8607_GPADC_EN);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __devinit device_irq_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nstruct i2c_client *i2c = (chip->id == CHIP_PM8607) ? chip->client \\r\n: chip->companion;\r\nunsigned char status_buf[INT_STATUS_NUM];\r\nunsigned long flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;\r\nint i, data, mask, ret = -EINVAL;\r\nint __irq;\r\nif (!pdata || !pdata->irq_base) {\r\ndev_warn(chip->dev, "No interrupt support on IRQ base\n");\r\nreturn -EINVAL;\r\n}\r\nmask = PM8607_B0_MISC1_INV_INT | PM8607_B0_MISC1_INT_CLEAR\r\n| PM8607_B0_MISC1_INT_MASK;\r\ndata = 0;\r\nchip->irq_mode = 0;\r\nif (pdata && pdata->irq_mode) {\r\ndata |= PM8607_B0_MISC1_INT_CLEAR;\r\nchip->irq_mode = 1;\r\n}\r\nret = pm860x_set_bits(i2c, PM8607_B0_MISC1, mask, data);\r\nif (ret < 0)\r\ngoto out;\r\nmemset(status_buf, 0, INT_STATUS_NUM);\r\nret = pm860x_bulk_write(i2c, PM8607_INT_MASK_1,\r\nINT_STATUS_NUM, status_buf);\r\nif (ret < 0)\r\ngoto out;\r\nif (chip->irq_mode) {\r\nmemset(status_buf, 0xFF, INT_STATUS_NUM);\r\nret = pm860x_bulk_write(i2c, PM8607_INT_STATUS1,\r\nINT_STATUS_NUM, status_buf);\r\n} else {\r\nret = pm860x_bulk_read(i2c, PM8607_INT_STATUS1,\r\nINT_STATUS_NUM, status_buf);\r\n}\r\nif (ret < 0)\r\ngoto out;\r\nmutex_init(&chip->irq_lock);\r\nchip->irq_base = pdata->irq_base;\r\nchip->core_irq = i2c->irq;\r\nif (!chip->core_irq)\r\ngoto out;\r\nfor (i = 0; i < ARRAY_SIZE(pm860x_irqs); i++) {\r\n__irq = i + chip->irq_base;\r\nirq_set_chip_data(__irq, chip);\r\nirq_set_chip_and_handler(__irq, &pm860x_irq_chip,\r\nhandle_edge_irq);\r\nirq_set_nested_thread(__irq, 1);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(__irq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(__irq);\r\n#endif\r\n}\r\nret = request_threaded_irq(chip->core_irq, NULL, pm860x_irq, flags,\r\n"88pm860x", chip);\r\nif (ret) {\r\ndev_err(chip->dev, "Failed to request IRQ: %d\n", ret);\r\nchip->core_irq = 0;\r\n}\r\nreturn 0;\r\nout:\r\nchip->core_irq = 0;\r\nreturn ret;\r\n}\r\nstatic void device_irq_exit(struct pm860x_chip *chip)\r\n{\r\nif (chip->core_irq)\r\nfree_irq(chip->core_irq, chip);\r\n}\r\nstatic void __devinit device_bk_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint ret;\r\nint i, j, id;\r\nif ((pdata == NULL) || (pdata->backlight == NULL))\r\nreturn;\r\nif (pdata->num_backlights > ARRAY_SIZE(bk_devs))\r\npdata->num_backlights = ARRAY_SIZE(bk_devs);\r\nfor (i = 0; i < pdata->num_backlights; i++) {\r\nbk_devs[i].platform_data = &pdata->backlight[i];\r\nbk_devs[i].pdata_size = sizeof(struct pm860x_backlight_pdata);\r\nfor (j = 0; j < ARRAY_SIZE(bk_devs); j++) {\r\nid = bk_resources[j].start;\r\nif (pdata->backlight[i].flags != id)\r\ncontinue;\r\nbk_devs[i].num_resources = 1;\r\nbk_devs[i].resources = &bk_resources[j];\r\nret = mfd_add_devices(chip->dev, 0,\r\n&bk_devs[i], 1,\r\n&bk_resources[j], 0);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to add "\r\n"backlight subdev\n");\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nstatic void __devinit device_led_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint ret;\r\nint i, j, id;\r\nif ((pdata == NULL) || (pdata->led == NULL))\r\nreturn;\r\nif (pdata->num_leds > ARRAY_SIZE(led_devs))\r\npdata->num_leds = ARRAY_SIZE(led_devs);\r\nfor (i = 0; i < pdata->num_leds; i++) {\r\nled_devs[i].platform_data = &pdata->led[i];\r\nled_devs[i].pdata_size = sizeof(struct pm860x_led_pdata);\r\nfor (j = 0; j < ARRAY_SIZE(led_devs); j++) {\r\nid = led_resources[j].start;\r\nif (pdata->led[i].flags != id)\r\ncontinue;\r\nled_devs[i].num_resources = 1;\r\nled_devs[i].resources = &led_resources[j],\r\nret = mfd_add_devices(chip->dev, 0,\r\n&led_devs[i], 1,\r\n&led_resources[j], 0);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to add "\r\n"led subdev\n");\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nstatic void __devinit device_regulator_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nstruct regulator_init_data *initdata;\r\nint ret;\r\nint i, seq;\r\nif ((pdata == NULL) || (pdata->regulator == NULL))\r\nreturn;\r\nif (pdata->num_regulators > ARRAY_SIZE(regulator_devs))\r\npdata->num_regulators = ARRAY_SIZE(regulator_devs);\r\nfor (i = 0, seq = -1; i < pdata->num_regulators; i++) {\r\ninitdata = &pdata->regulator[i];\r\nseq = *(unsigned int *)initdata->driver_data;\r\nif ((seq < 0) || (seq > PM8607_ID_RG_MAX)) {\r\ndev_err(chip->dev, "Wrong ID(%d) on regulator(%s)\n",\r\nseq, initdata->constraints.name);\r\ngoto out;\r\n}\r\nregulator_devs[i].platform_data = &pdata->regulator[i];\r\nregulator_devs[i].pdata_size = sizeof(struct regulator_init_data);\r\nregulator_devs[i].num_resources = 1;\r\nregulator_devs[i].resources = &regulator_resources[seq];\r\nret = mfd_add_devices(chip->dev, 0, &regulator_devs[i], 1,\r\n&regulator_resources[seq], 0);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to add regulator subdev\n");\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn;\r\n}\r\nstatic void __devinit device_rtc_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint ret;\r\nif ((pdata == NULL))\r\nreturn;\r\nrtc_devs[0].platform_data = pdata->rtc;\r\nrtc_devs[0].pdata_size = sizeof(struct pm860x_rtc_pdata);\r\nrtc_devs[0].num_resources = ARRAY_SIZE(rtc_resources);\r\nrtc_devs[0].resources = &rtc_resources[0];\r\nret = mfd_add_devices(chip->dev, 0, &rtc_devs[0],\r\nARRAY_SIZE(rtc_devs), &rtc_resources[0],\r\nchip->irq_base);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to add rtc subdev\n");\r\n}\r\nstatic void __devinit device_touch_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint ret;\r\nif (pdata == NULL)\r\nreturn;\r\ntouch_devs[0].platform_data = pdata->touch;\r\ntouch_devs[0].pdata_size = sizeof(struct pm860x_touch_pdata);\r\ntouch_devs[0].num_resources = ARRAY_SIZE(touch_resources);\r\ntouch_devs[0].resources = &touch_resources[0];\r\nret = mfd_add_devices(chip->dev, 0, &touch_devs[0],\r\nARRAY_SIZE(touch_devs), &touch_resources[0],\r\nchip->irq_base);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to add touch subdev\n");\r\n}\r\nstatic void __devinit device_power_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint ret;\r\nif (pdata == NULL)\r\nreturn;\r\npower_devs[0].platform_data = pdata->power;\r\npower_devs[0].pdata_size = sizeof(struct pm860x_power_pdata);\r\npower_devs[0].num_resources = ARRAY_SIZE(battery_resources);\r\npower_devs[0].resources = &battery_resources[0],\r\nret = mfd_add_devices(chip->dev, 0, &power_devs[0], 1,\r\n&battery_resources[0], chip->irq_base);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to add battery subdev\n");\r\npower_devs[1].platform_data = pdata->power;\r\npower_devs[1].pdata_size = sizeof(struct pm860x_power_pdata);\r\npower_devs[1].num_resources = ARRAY_SIZE(charger_resources);\r\npower_devs[1].resources = &charger_resources[0],\r\nret = mfd_add_devices(chip->dev, 0, &power_devs[1], 1,\r\n&charger_resources[0], chip->irq_base);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to add charger subdev\n");\r\n}\r\nstatic void __devinit device_onkey_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint ret;\r\nonkey_devs[0].num_resources = ARRAY_SIZE(onkey_resources);\r\nonkey_devs[0].resources = &onkey_resources[0],\r\nret = mfd_add_devices(chip->dev, 0, &onkey_devs[0],\r\nARRAY_SIZE(onkey_devs), &onkey_resources[0],\r\nchip->irq_base);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to add onkey subdev\n");\r\n}\r\nstatic void __devinit device_codec_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint ret;\r\ncodec_devs[0].num_resources = ARRAY_SIZE(codec_resources);\r\ncodec_devs[0].resources = &codec_resources[0],\r\nret = mfd_add_devices(chip->dev, 0, &codec_devs[0],\r\nARRAY_SIZE(codec_devs), &codec_resources[0], 0);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to add codec subdev\n");\r\n}\r\nstatic void __devinit device_8607_init(struct pm860x_chip *chip,\r\nstruct i2c_client *i2c,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint data, ret;\r\nret = pm860x_reg_read(i2c, PM8607_CHIP_ID);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to read CHIP ID: %d\n", ret);\r\ngoto out;\r\n}\r\nswitch (ret & PM8607_VERSION_MASK) {\r\ncase 0x40:\r\ncase 0x50:\r\ndev_info(chip->dev, "Marvell 88PM8607 (ID: %02x) detected\n",\r\nret);\r\nbreak;\r\ndefault:\r\ndev_err(chip->dev, "Failed to detect Marvell 88PM8607. "\r\n"Chip ID: %02x\n", ret);\r\ngoto out;\r\n}\r\nret = pm860x_reg_read(i2c, PM8607_BUCK3);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to read BUCK3 register: %d\n", ret);\r\ngoto out;\r\n}\r\nif (ret & PM8607_BUCK3_DOUBLE)\r\nchip->buck3_double = 1;\r\nret = pm860x_reg_read(i2c, PM8607_B0_MISC1);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to read MISC1 register: %d\n", ret);\r\ngoto out;\r\n}\r\nif (pdata && (pdata->i2c_port == PI2C_PORT))\r\ndata = PM8607_B0_MISC1_PI2C;\r\nelse\r\ndata = 0;\r\nret = pm860x_set_bits(i2c, PM8607_B0_MISC1, PM8607_B0_MISC1_PI2C, data);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to access MISC1:%d\n", ret);\r\ngoto out;\r\n}\r\nret = device_gpadc_init(chip, pdata);\r\nif (ret < 0)\r\ngoto out;\r\nret = device_irq_init(chip, pdata);\r\nif (ret < 0)\r\ngoto out;\r\ndevice_regulator_init(chip, pdata);\r\ndevice_rtc_init(chip, pdata);\r\ndevice_onkey_init(chip, pdata);\r\ndevice_touch_init(chip, pdata);\r\ndevice_power_init(chip, pdata);\r\ndevice_codec_init(chip, pdata);\r\nout:\r\nreturn;\r\n}\r\nint __devinit pm860x_device_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nchip->core_irq = 0;\r\nswitch (chip->id) {\r\ncase CHIP_PM8606:\r\ndevice_bk_init(chip, pdata);\r\ndevice_led_init(chip, pdata);\r\nbreak;\r\ncase CHIP_PM8607:\r\ndevice_8607_init(chip, chip->client, pdata);\r\nbreak;\r\n}\r\nif (chip->companion) {\r\nswitch (chip->id) {\r\ncase CHIP_PM8607:\r\ndevice_bk_init(chip, pdata);\r\ndevice_led_init(chip, pdata);\r\nbreak;\r\ncase CHIP_PM8606:\r\ndevice_8607_init(chip, chip->companion, pdata);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid __devexit pm860x_device_exit(struct pm860x_chip *chip)\r\n{\r\ndevice_irq_exit(chip);\r\nmfd_remove_devices(chip->dev);\r\n}
