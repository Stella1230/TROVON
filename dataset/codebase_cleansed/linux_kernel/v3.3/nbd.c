static const char *ioctl_cmd_to_ascii(int cmd)\r\n{\r\nswitch (cmd) {\r\ncase NBD_SET_SOCK: return "set-sock";\r\ncase NBD_SET_BLKSIZE: return "set-blksize";\r\ncase NBD_SET_SIZE: return "set-size";\r\ncase NBD_DO_IT: return "do-it";\r\ncase NBD_CLEAR_SOCK: return "clear-sock";\r\ncase NBD_CLEAR_QUE: return "clear-que";\r\ncase NBD_PRINT_DEBUG: return "print-debug";\r\ncase NBD_SET_SIZE_BLOCKS: return "set-size-blocks";\r\ncase NBD_DISCONNECT: return "disconnect";\r\ncase BLKROSET: return "set-read-only";\r\ncase BLKFLSBUF: return "flush-buffer-cache";\r\n}\r\nreturn "unknown";\r\n}\r\nstatic const char *nbdcmd_to_ascii(int cmd)\r\n{\r\nswitch (cmd) {\r\ncase NBD_CMD_READ: return "read";\r\ncase NBD_CMD_WRITE: return "write";\r\ncase NBD_CMD_DISC: return "disconnect";\r\n}\r\nreturn "invalid";\r\n}\r\nstatic void nbd_end_request(struct request *req)\r\n{\r\nint error = req->errors ? -EIO : 0;\r\nstruct request_queue *q = req->q;\r\nunsigned long flags;\r\ndprintk(DBG_BLKDEV, "%s: request %p: %s\n", req->rq_disk->disk_name,\r\nreq, error ? "failed" : "done");\r\nspin_lock_irqsave(q->queue_lock, flags);\r\n__blk_end_request_all(req, error);\r\nspin_unlock_irqrestore(q->queue_lock, flags);\r\n}\r\nstatic void sock_shutdown(struct nbd_device *lo, int lock)\r\n{\r\nif (lock)\r\nmutex_lock(&lo->tx_lock);\r\nif (lo->sock) {\r\ndev_warn(disk_to_dev(lo->disk), "shutting down socket\n");\r\nkernel_sock_shutdown(lo->sock, SHUT_RDWR);\r\nlo->sock = NULL;\r\n}\r\nif (lock)\r\nmutex_unlock(&lo->tx_lock);\r\n}\r\nstatic void nbd_xmit_timeout(unsigned long arg)\r\n{\r\nstruct task_struct *task = (struct task_struct *)arg;\r\nprintk(KERN_WARNING "nbd: killing hung xmit (%s, pid: %d)\n",\r\ntask->comm, task->pid);\r\nforce_sig(SIGKILL, task);\r\n}\r\nstatic int sock_xmit(struct nbd_device *lo, int send, void *buf, int size,\r\nint msg_flags)\r\n{\r\nstruct socket *sock = lo->sock;\r\nint result;\r\nstruct msghdr msg;\r\nstruct kvec iov;\r\nsigset_t blocked, oldset;\r\nif (unlikely(!sock)) {\r\ndev_err(disk_to_dev(lo->disk),\r\n"Attempted %s on closed socket in sock_xmit\n",\r\n(send ? "send" : "recv"));\r\nreturn -EINVAL;\r\n}\r\nsiginitsetinv(&blocked, sigmask(SIGKILL));\r\nsigprocmask(SIG_SETMASK, &blocked, &oldset);\r\ndo {\r\nsock->sk->sk_allocation = GFP_NOIO;\r\niov.iov_base = buf;\r\niov.iov_len = size;\r\nmsg.msg_name = NULL;\r\nmsg.msg_namelen = 0;\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = msg_flags | MSG_NOSIGNAL;\r\nif (send) {\r\nstruct timer_list ti;\r\nif (lo->xmit_timeout) {\r\ninit_timer(&ti);\r\nti.function = nbd_xmit_timeout;\r\nti.data = (unsigned long)current;\r\nti.expires = jiffies + lo->xmit_timeout;\r\nadd_timer(&ti);\r\n}\r\nresult = kernel_sendmsg(sock, &msg, &iov, 1, size);\r\nif (lo->xmit_timeout)\r\ndel_timer_sync(&ti);\r\n} else\r\nresult = kernel_recvmsg(sock, &msg, &iov, 1, size,\r\nmsg.msg_flags);\r\nif (signal_pending(current)) {\r\nsiginfo_t info;\r\nprintk(KERN_WARNING "nbd (pid %d: %s) got signal %d\n",\r\ntask_pid_nr(current), current->comm,\r\ndequeue_signal_lock(current, &current->blocked, &info));\r\nresult = -EINTR;\r\nsock_shutdown(lo, !send);\r\nbreak;\r\n}\r\nif (result <= 0) {\r\nif (result == 0)\r\nresult = -EPIPE;\r\nbreak;\r\n}\r\nsize -= result;\r\nbuf += result;\r\n} while (size > 0);\r\nsigprocmask(SIG_SETMASK, &oldset, NULL);\r\nreturn result;\r\n}\r\nstatic inline int sock_send_bvec(struct nbd_device *lo, struct bio_vec *bvec,\r\nint flags)\r\n{\r\nint result;\r\nvoid *kaddr = kmap(bvec->bv_page);\r\nresult = sock_xmit(lo, 1, kaddr + bvec->bv_offset, bvec->bv_len, flags);\r\nkunmap(bvec->bv_page);\r\nreturn result;\r\n}\r\nstatic int nbd_send_req(struct nbd_device *lo, struct request *req)\r\n{\r\nint result, flags;\r\nstruct nbd_request request;\r\nunsigned long size = blk_rq_bytes(req);\r\nrequest.magic = htonl(NBD_REQUEST_MAGIC);\r\nrequest.type = htonl(nbd_cmd(req));\r\nrequest.from = cpu_to_be64((u64)blk_rq_pos(req) << 9);\r\nrequest.len = htonl(size);\r\nmemcpy(request.handle, &req, sizeof(req));\r\ndprintk(DBG_TX, "%s: request %p: sending control (%s@%llu,%uB)\n",\r\nlo->disk->disk_name, req,\r\nnbdcmd_to_ascii(nbd_cmd(req)),\r\n(unsigned long long)blk_rq_pos(req) << 9,\r\nblk_rq_bytes(req));\r\nresult = sock_xmit(lo, 1, &request, sizeof(request),\r\n(nbd_cmd(req) == NBD_CMD_WRITE) ? MSG_MORE : 0);\r\nif (result <= 0) {\r\ndev_err(disk_to_dev(lo->disk),\r\n"Send control failed (result %d)\n", result);\r\ngoto error_out;\r\n}\r\nif (nbd_cmd(req) == NBD_CMD_WRITE) {\r\nstruct req_iterator iter;\r\nstruct bio_vec *bvec;\r\nrq_for_each_segment(bvec, req, iter) {\r\nflags = 0;\r\nif (!rq_iter_last(req, iter))\r\nflags = MSG_MORE;\r\ndprintk(DBG_TX, "%s: request %p: sending %d bytes data\n",\r\nlo->disk->disk_name, req, bvec->bv_len);\r\nresult = sock_send_bvec(lo, bvec, flags);\r\nif (result <= 0) {\r\ndev_err(disk_to_dev(lo->disk),\r\n"Send data failed (result %d)\n",\r\nresult);\r\ngoto error_out;\r\n}\r\n}\r\n}\r\nreturn 0;\r\nerror_out:\r\nreturn -EIO;\r\n}\r\nstatic struct request *nbd_find_request(struct nbd_device *lo,\r\nstruct request *xreq)\r\n{\r\nstruct request *req, *tmp;\r\nint err;\r\nerr = wait_event_interruptible(lo->active_wq, lo->active_req != xreq);\r\nif (unlikely(err))\r\ngoto out;\r\nspin_lock(&lo->queue_lock);\r\nlist_for_each_entry_safe(req, tmp, &lo->queue_head, queuelist) {\r\nif (req != xreq)\r\ncontinue;\r\nlist_del_init(&req->queuelist);\r\nspin_unlock(&lo->queue_lock);\r\nreturn req;\r\n}\r\nspin_unlock(&lo->queue_lock);\r\nerr = -ENOENT;\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic inline int sock_recv_bvec(struct nbd_device *lo, struct bio_vec *bvec)\r\n{\r\nint result;\r\nvoid *kaddr = kmap(bvec->bv_page);\r\nresult = sock_xmit(lo, 0, kaddr + bvec->bv_offset, bvec->bv_len,\r\nMSG_WAITALL);\r\nkunmap(bvec->bv_page);\r\nreturn result;\r\n}\r\nstatic struct request *nbd_read_stat(struct nbd_device *lo)\r\n{\r\nint result;\r\nstruct nbd_reply reply;\r\nstruct request *req;\r\nreply.magic = 0;\r\nresult = sock_xmit(lo, 0, &reply, sizeof(reply), MSG_WAITALL);\r\nif (result <= 0) {\r\ndev_err(disk_to_dev(lo->disk),\r\n"Receive control failed (result %d)\n", result);\r\ngoto harderror;\r\n}\r\nif (ntohl(reply.magic) != NBD_REPLY_MAGIC) {\r\ndev_err(disk_to_dev(lo->disk), "Wrong magic (0x%lx)\n",\r\n(unsigned long)ntohl(reply.magic));\r\nresult = -EPROTO;\r\ngoto harderror;\r\n}\r\nreq = nbd_find_request(lo, *(struct request **)reply.handle);\r\nif (IS_ERR(req)) {\r\nresult = PTR_ERR(req);\r\nif (result != -ENOENT)\r\ngoto harderror;\r\ndev_err(disk_to_dev(lo->disk), "Unexpected reply (%p)\n",\r\nreply.handle);\r\nresult = -EBADR;\r\ngoto harderror;\r\n}\r\nif (ntohl(reply.error)) {\r\ndev_err(disk_to_dev(lo->disk), "Other side returned error (%d)\n",\r\nntohl(reply.error));\r\nreq->errors++;\r\nreturn req;\r\n}\r\ndprintk(DBG_RX, "%s: request %p: got reply\n",\r\nlo->disk->disk_name, req);\r\nif (nbd_cmd(req) == NBD_CMD_READ) {\r\nstruct req_iterator iter;\r\nstruct bio_vec *bvec;\r\nrq_for_each_segment(bvec, req, iter) {\r\nresult = sock_recv_bvec(lo, bvec);\r\nif (result <= 0) {\r\ndev_err(disk_to_dev(lo->disk), "Receive data failed (result %d)\n",\r\nresult);\r\nreq->errors++;\r\nreturn req;\r\n}\r\ndprintk(DBG_RX, "%s: request %p: got %d bytes data\n",\r\nlo->disk->disk_name, req, bvec->bv_len);\r\n}\r\n}\r\nreturn req;\r\nharderror:\r\nlo->harderror = result;\r\nreturn NULL;\r\n}\r\nstatic ssize_t pid_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nreturn sprintf(buf, "%ld\n",\r\n(long) ((struct nbd_device *)disk->private_data)->pid);\r\n}\r\nstatic int nbd_do_it(struct nbd_device *lo)\r\n{\r\nstruct request *req;\r\nint ret;\r\nBUG_ON(lo->magic != LO_MAGIC);\r\nlo->pid = task_pid_nr(current);\r\nret = device_create_file(disk_to_dev(lo->disk), &pid_attr);\r\nif (ret) {\r\ndev_err(disk_to_dev(lo->disk), "device_create_file failed!\n");\r\nlo->pid = 0;\r\nreturn ret;\r\n}\r\nwhile ((req = nbd_read_stat(lo)) != NULL)\r\nnbd_end_request(req);\r\ndevice_remove_file(disk_to_dev(lo->disk), &pid_attr);\r\nlo->pid = 0;\r\nreturn 0;\r\n}\r\nstatic void nbd_clear_que(struct nbd_device *lo)\r\n{\r\nstruct request *req;\r\nBUG_ON(lo->magic != LO_MAGIC);\r\nBUG_ON(lo->sock);\r\nBUG_ON(lo->active_req);\r\nwhile (!list_empty(&lo->queue_head)) {\r\nreq = list_entry(lo->queue_head.next, struct request,\r\nqueuelist);\r\nlist_del_init(&req->queuelist);\r\nreq->errors++;\r\nnbd_end_request(req);\r\n}\r\n}\r\nstatic void nbd_handle_req(struct nbd_device *lo, struct request *req)\r\n{\r\nif (req->cmd_type != REQ_TYPE_FS)\r\ngoto error_out;\r\nnbd_cmd(req) = NBD_CMD_READ;\r\nif (rq_data_dir(req) == WRITE) {\r\nnbd_cmd(req) = NBD_CMD_WRITE;\r\nif (lo->flags & NBD_READ_ONLY) {\r\ndev_err(disk_to_dev(lo->disk),\r\n"Write on read-only\n");\r\ngoto error_out;\r\n}\r\n}\r\nreq->errors = 0;\r\nmutex_lock(&lo->tx_lock);\r\nif (unlikely(!lo->sock)) {\r\nmutex_unlock(&lo->tx_lock);\r\ndev_err(disk_to_dev(lo->disk),\r\n"Attempted send on closed socket\n");\r\ngoto error_out;\r\n}\r\nlo->active_req = req;\r\nif (nbd_send_req(lo, req) != 0) {\r\ndev_err(disk_to_dev(lo->disk), "Request send failed\n");\r\nreq->errors++;\r\nnbd_end_request(req);\r\n} else {\r\nspin_lock(&lo->queue_lock);\r\nlist_add(&req->queuelist, &lo->queue_head);\r\nspin_unlock(&lo->queue_lock);\r\n}\r\nlo->active_req = NULL;\r\nmutex_unlock(&lo->tx_lock);\r\nwake_up_all(&lo->active_wq);\r\nreturn;\r\nerror_out:\r\nreq->errors++;\r\nnbd_end_request(req);\r\n}\r\nstatic int nbd_thread(void *data)\r\n{\r\nstruct nbd_device *lo = data;\r\nstruct request *req;\r\nset_user_nice(current, -20);\r\nwhile (!kthread_should_stop() || !list_empty(&lo->waiting_queue)) {\r\nwait_event_interruptible(lo->waiting_wq,\r\nkthread_should_stop() ||\r\n!list_empty(&lo->waiting_queue));\r\nif (list_empty(&lo->waiting_queue))\r\ncontinue;\r\nspin_lock_irq(&lo->queue_lock);\r\nreq = list_entry(lo->waiting_queue.next, struct request,\r\nqueuelist);\r\nlist_del_init(&req->queuelist);\r\nspin_unlock_irq(&lo->queue_lock);\r\nnbd_handle_req(lo, req);\r\n}\r\nreturn 0;\r\n}\r\nstatic void do_nbd_request(struct request_queue *q)\r\n{\r\nstruct request *req;\r\nwhile ((req = blk_fetch_request(q)) != NULL) {\r\nstruct nbd_device *lo;\r\nspin_unlock_irq(q->queue_lock);\r\ndprintk(DBG_BLKDEV, "%s: request %p: dequeued (flags=%x)\n",\r\nreq->rq_disk->disk_name, req, req->cmd_type);\r\nlo = req->rq_disk->private_data;\r\nBUG_ON(lo->magic != LO_MAGIC);\r\nif (unlikely(!lo->sock)) {\r\ndev_err(disk_to_dev(lo->disk),\r\n"Attempted send on closed socket\n");\r\nreq->errors++;\r\nnbd_end_request(req);\r\nspin_lock_irq(q->queue_lock);\r\ncontinue;\r\n}\r\nspin_lock_irq(&lo->queue_lock);\r\nlist_add_tail(&req->queuelist, &lo->waiting_queue);\r\nspin_unlock_irq(&lo->queue_lock);\r\nwake_up(&lo->waiting_wq);\r\nspin_lock_irq(q->queue_lock);\r\n}\r\n}\r\nstatic int __nbd_ioctl(struct block_device *bdev, struct nbd_device *lo,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase NBD_DISCONNECT: {\r\nstruct request sreq;\r\ndev_info(disk_to_dev(lo->disk), "NBD_DISCONNECT\n");\r\nblk_rq_init(NULL, &sreq);\r\nsreq.cmd_type = REQ_TYPE_SPECIAL;\r\nnbd_cmd(&sreq) = NBD_CMD_DISC;\r\nif (!lo->sock)\r\nreturn -EINVAL;\r\nnbd_send_req(lo, &sreq);\r\nreturn 0;\r\n}\r\ncase NBD_CLEAR_SOCK: {\r\nstruct file *file;\r\nlo->sock = NULL;\r\nfile = lo->file;\r\nlo->file = NULL;\r\nnbd_clear_que(lo);\r\nBUG_ON(!list_empty(&lo->queue_head));\r\nif (file)\r\nfput(file);\r\nreturn 0;\r\n}\r\ncase NBD_SET_SOCK: {\r\nstruct file *file;\r\nif (lo->file)\r\nreturn -EBUSY;\r\nfile = fget(arg);\r\nif (file) {\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nif (S_ISSOCK(inode->i_mode)) {\r\nlo->file = file;\r\nlo->sock = SOCKET_I(inode);\r\nif (max_part > 0)\r\nbdev->bd_invalidated = 1;\r\nreturn 0;\r\n} else {\r\nfput(file);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\ncase NBD_SET_BLKSIZE:\r\nlo->blksize = arg;\r\nlo->bytesize &= ~(lo->blksize-1);\r\nbdev->bd_inode->i_size = lo->bytesize;\r\nset_blocksize(bdev, lo->blksize);\r\nset_capacity(lo->disk, lo->bytesize >> 9);\r\nreturn 0;\r\ncase NBD_SET_SIZE:\r\nlo->bytesize = arg & ~(lo->blksize-1);\r\nbdev->bd_inode->i_size = lo->bytesize;\r\nset_blocksize(bdev, lo->blksize);\r\nset_capacity(lo->disk, lo->bytesize >> 9);\r\nreturn 0;\r\ncase NBD_SET_TIMEOUT:\r\nlo->xmit_timeout = arg * HZ;\r\nreturn 0;\r\ncase NBD_SET_SIZE_BLOCKS:\r\nlo->bytesize = ((u64) arg) * lo->blksize;\r\nbdev->bd_inode->i_size = lo->bytesize;\r\nset_blocksize(bdev, lo->blksize);\r\nset_capacity(lo->disk, lo->bytesize >> 9);\r\nreturn 0;\r\ncase NBD_DO_IT: {\r\nstruct task_struct *thread;\r\nstruct file *file;\r\nint error;\r\nif (lo->pid)\r\nreturn -EBUSY;\r\nif (!lo->file)\r\nreturn -EINVAL;\r\nmutex_unlock(&lo->tx_lock);\r\nthread = kthread_create(nbd_thread, lo, lo->disk->disk_name);\r\nif (IS_ERR(thread)) {\r\nmutex_lock(&lo->tx_lock);\r\nreturn PTR_ERR(thread);\r\n}\r\nwake_up_process(thread);\r\nerror = nbd_do_it(lo);\r\nkthread_stop(thread);\r\nmutex_lock(&lo->tx_lock);\r\nif (error)\r\nreturn error;\r\nsock_shutdown(lo, 0);\r\nfile = lo->file;\r\nlo->file = NULL;\r\nnbd_clear_que(lo);\r\ndev_warn(disk_to_dev(lo->disk), "queue cleared\n");\r\nif (file)\r\nfput(file);\r\nlo->bytesize = 0;\r\nbdev->bd_inode->i_size = 0;\r\nset_capacity(lo->disk, 0);\r\nif (max_part > 0)\r\nioctl_by_bdev(bdev, BLKRRPART, 0);\r\nreturn lo->harderror;\r\n}\r\ncase NBD_CLEAR_QUE:\r\nBUG_ON(!lo->sock && !list_empty(&lo->queue_head));\r\nreturn 0;\r\ncase NBD_PRINT_DEBUG:\r\ndev_info(disk_to_dev(lo->disk),\r\n"next = %p, prev = %p, head = %p\n",\r\nlo->queue_head.next, lo->queue_head.prev,\r\n&lo->queue_head);\r\nreturn 0;\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic int nbd_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct nbd_device *lo = bdev->bd_disk->private_data;\r\nint error;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nBUG_ON(lo->magic != LO_MAGIC);\r\ndprintk(DBG_IOCTL, "%s: nbd_ioctl cmd=%s(0x%x) arg=%lu\n",\r\nlo->disk->disk_name, ioctl_cmd_to_ascii(cmd), cmd, arg);\r\nmutex_lock(&lo->tx_lock);\r\nerror = __nbd_ioctl(bdev, lo, cmd, arg);\r\nmutex_unlock(&lo->tx_lock);\r\nreturn error;\r\n}\r\nstatic int __init nbd_init(void)\r\n{\r\nint err = -ENOMEM;\r\nint i;\r\nint part_shift;\r\nBUILD_BUG_ON(sizeof(struct nbd_request) != 28);\r\nif (max_part < 0) {\r\nprintk(KERN_ERR "nbd: max_part must be >= 0\n");\r\nreturn -EINVAL;\r\n}\r\nnbd_dev = kcalloc(nbds_max, sizeof(*nbd_dev), GFP_KERNEL);\r\nif (!nbd_dev)\r\nreturn -ENOMEM;\r\npart_shift = 0;\r\nif (max_part > 0) {\r\npart_shift = fls(max_part);\r\nmax_part = (1UL << part_shift) - 1;\r\n}\r\nif ((1UL << part_shift) > DISK_MAX_PARTS)\r\nreturn -EINVAL;\r\nif (nbds_max > 1UL << (MINORBITS - part_shift))\r\nreturn -EINVAL;\r\nfor (i = 0; i < nbds_max; i++) {\r\nstruct gendisk *disk = alloc_disk(1 << part_shift);\r\nif (!disk)\r\ngoto out;\r\nnbd_dev[i].disk = disk;\r\ndisk->queue = blk_init_queue(do_nbd_request, &nbd_lock);\r\nif (!disk->queue) {\r\nput_disk(disk);\r\ngoto out;\r\n}\r\nqueue_flag_set_unlocked(QUEUE_FLAG_NONROT, disk->queue);\r\n}\r\nif (register_blkdev(NBD_MAJOR, "nbd")) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nprintk(KERN_INFO "nbd: registered device at major %d\n", NBD_MAJOR);\r\ndprintk(DBG_INIT, "nbd: debugflags=0x%x\n", debugflags);\r\nfor (i = 0; i < nbds_max; i++) {\r\nstruct gendisk *disk = nbd_dev[i].disk;\r\nnbd_dev[i].file = NULL;\r\nnbd_dev[i].magic = LO_MAGIC;\r\nnbd_dev[i].flags = 0;\r\nINIT_LIST_HEAD(&nbd_dev[i].waiting_queue);\r\nspin_lock_init(&nbd_dev[i].queue_lock);\r\nINIT_LIST_HEAD(&nbd_dev[i].queue_head);\r\nmutex_init(&nbd_dev[i].tx_lock);\r\ninit_waitqueue_head(&nbd_dev[i].active_wq);\r\ninit_waitqueue_head(&nbd_dev[i].waiting_wq);\r\nnbd_dev[i].blksize = 1024;\r\nnbd_dev[i].bytesize = 0;\r\ndisk->major = NBD_MAJOR;\r\ndisk->first_minor = i << part_shift;\r\ndisk->fops = &nbd_fops;\r\ndisk->private_data = &nbd_dev[i];\r\nsprintf(disk->disk_name, "nbd%d", i);\r\nset_capacity(disk, 0);\r\nadd_disk(disk);\r\n}\r\nreturn 0;\r\nout:\r\nwhile (i--) {\r\nblk_cleanup_queue(nbd_dev[i].disk->queue);\r\nput_disk(nbd_dev[i].disk);\r\n}\r\nkfree(nbd_dev);\r\nreturn err;\r\n}\r\nstatic void __exit nbd_cleanup(void)\r\n{\r\nint i;\r\nfor (i = 0; i < nbds_max; i++) {\r\nstruct gendisk *disk = nbd_dev[i].disk;\r\nnbd_dev[i].magic = 0;\r\nif (disk) {\r\ndel_gendisk(disk);\r\nblk_cleanup_queue(disk->queue);\r\nput_disk(disk);\r\n}\r\n}\r\nunregister_blkdev(NBD_MAJOR, "nbd");\r\nkfree(nbd_dev);\r\nprintk(KERN_INFO "nbd: unregistered device at major %d\n", NBD_MAJOR);\r\n}
