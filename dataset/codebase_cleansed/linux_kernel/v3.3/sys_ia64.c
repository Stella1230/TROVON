unsigned long\r\narch_get_unmapped_area (struct file *filp, unsigned long addr, unsigned long len,\r\nunsigned long pgoff, unsigned long flags)\r\n{\r\nlong map_shared = (flags & MAP_SHARED);\r\nunsigned long start_addr, align_mask = PAGE_SIZE - 1;\r\nstruct mm_struct *mm = current->mm;\r\nstruct vm_area_struct *vma;\r\nif (len > RGN_MAP_LIMIT)\r\nreturn -ENOMEM;\r\nif (flags & MAP_FIXED) {\r\nif (is_hugepage_only_range(mm, addr, len))\r\nreturn -EINVAL;\r\nreturn addr;\r\n}\r\n#ifdef CONFIG_HUGETLB_PAGE\r\nif (REGION_NUMBER(addr) == RGN_HPAGE)\r\naddr = 0;\r\n#endif\r\nif (!addr)\r\naddr = mm->free_area_cache;\r\nif (map_shared && (TASK_SIZE > 0xfffffffful))\r\nalign_mask = SHMLBA - 1;\r\nfull_search:\r\nstart_addr = addr = (addr + align_mask) & ~align_mask;\r\nfor (vma = find_vma(mm, addr); ; vma = vma->vm_next) {\r\nif (TASK_SIZE - len < addr || RGN_MAP_LIMIT - len < REGION_OFFSET(addr)) {\r\nif (start_addr != TASK_UNMAPPED_BASE) {\r\naddr = TASK_UNMAPPED_BASE;\r\ngoto full_search;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nif (!vma || addr + len <= vma->vm_start) {\r\nmm->free_area_cache = addr + len;\r\nreturn addr;\r\n}\r\naddr = (vma->vm_end + align_mask) & ~align_mask;\r\n}\r\n}\r\nasmlinkage long\r\nia64_getpriority (int which, int who)\r\n{\r\nlong prio;\r\nprio = sys_getpriority(which, who);\r\nif (prio >= 0) {\r\nforce_successful_syscall_return();\r\nprio = 20 - prio;\r\n}\r\nreturn prio;\r\n}\r\nasmlinkage unsigned long\r\nsys_getpagesize (void)\r\n{\r\nreturn PAGE_SIZE;\r\n}\r\nasmlinkage unsigned long\r\nia64_brk (unsigned long brk)\r\n{\r\nunsigned long retval = sys_brk(brk);\r\nforce_successful_syscall_return();\r\nreturn retval;\r\n}\r\nasmlinkage long\r\nsys_ia64_pipe (void)\r\n{\r\nstruct pt_regs *regs = task_pt_regs(current);\r\nint fd[2];\r\nint retval;\r\nretval = do_pipe_flags(fd, 0);\r\nif (retval)\r\ngoto out;\r\nretval = fd[0];\r\nregs->r9 = fd[1];\r\nout:\r\nreturn retval;\r\n}\r\nint ia64_mmap_check(unsigned long addr, unsigned long len,\r\nunsigned long flags)\r\n{\r\nunsigned long roff;\r\nroff = REGION_OFFSET(addr);\r\nif ((len > RGN_MAP_LIMIT) || (roff > (RGN_MAP_LIMIT - len)))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nasmlinkage unsigned long\r\nsys_mmap2 (unsigned long addr, unsigned long len, int prot, int flags, int fd, long pgoff)\r\n{\r\naddr = sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);\r\nif (!IS_ERR((void *) addr))\r\nforce_successful_syscall_return();\r\nreturn addr;\r\n}\r\nasmlinkage unsigned long\r\nsys_mmap (unsigned long addr, unsigned long len, int prot, int flags, int fd, long off)\r\n{\r\nif (offset_in_page(off) != 0)\r\nreturn -EINVAL;\r\naddr = sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);\r\nif (!IS_ERR((void *) addr))\r\nforce_successful_syscall_return();\r\nreturn addr;\r\n}\r\nasmlinkage unsigned long\r\nia64_mremap (unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long flags,\r\nunsigned long new_addr)\r\n{\r\nextern unsigned long do_mremap (unsigned long addr,\r\nunsigned long old_len,\r\nunsigned long new_len,\r\nunsigned long flags,\r\nunsigned long new_addr);\r\ndown_write(&current->mm->mmap_sem);\r\n{\r\naddr = do_mremap(addr, old_len, new_len, flags, new_addr);\r\n}\r\nup_write(&current->mm->mmap_sem);\r\nif (IS_ERR((void *) addr))\r\nreturn addr;\r\nforce_successful_syscall_return();\r\nreturn addr;\r\n}\r\nasmlinkage long\r\nsys_pciconfig_read (unsigned long bus, unsigned long dfn, unsigned long off, unsigned long len,\r\nvoid *buf)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nasmlinkage long\r\nsys_pciconfig_write (unsigned long bus, unsigned long dfn, unsigned long off, unsigned long len,\r\nvoid *buf)\r\n{\r\nreturn -ENOSYS;\r\n}
