static int key_get_type_from_user(char *type,\r\nconst char __user *_type,\r\nunsigned len)\r\n{\r\nint ret;\r\nret = strncpy_from_user(type, _type, len);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret == 0 || ret >= len)\r\nreturn -EINVAL;\r\nif (type[0] == '.')\r\nreturn -EPERM;\r\ntype[len - 1] = '\0';\r\nreturn 0;\r\n}\r\nlong keyctl_get_keyring_ID(key_serial_t id, int create)\r\n{\r\nkey_ref_t key_ref;\r\nunsigned long lflags;\r\nlong ret;\r\nlflags = create ? KEY_LOOKUP_CREATE : 0;\r\nkey_ref = lookup_user_key(id, lflags, KEY_SEARCH);\r\nif (IS_ERR(key_ref)) {\r\nret = PTR_ERR(key_ref);\r\ngoto error;\r\n}\r\nret = key_ref_to_ptr(key_ref)->serial;\r\nkey_ref_put(key_ref);\r\nerror:\r\nreturn ret;\r\n}\r\nlong keyctl_join_session_keyring(const char __user *_name)\r\n{\r\nchar *name;\r\nlong ret;\r\nname = NULL;\r\nif (_name) {\r\nname = strndup_user(_name, PAGE_SIZE);\r\nif (IS_ERR(name)) {\r\nret = PTR_ERR(name);\r\ngoto error;\r\n}\r\n}\r\nret = join_session_keyring(name);\r\nkfree(name);\r\nerror:\r\nreturn ret;\r\n}\r\nlong keyctl_update_key(key_serial_t id,\r\nconst void __user *_payload,\r\nsize_t plen)\r\n{\r\nkey_ref_t key_ref;\r\nvoid *payload;\r\nlong ret;\r\nret = -EINVAL;\r\nif (plen > PAGE_SIZE)\r\ngoto error;\r\npayload = NULL;\r\nif (_payload) {\r\nret = -ENOMEM;\r\npayload = kmalloc(plen, GFP_KERNEL);\r\nif (!payload)\r\ngoto error;\r\nret = -EFAULT;\r\nif (copy_from_user(payload, _payload, plen) != 0)\r\ngoto error2;\r\n}\r\nkey_ref = lookup_user_key(id, 0, KEY_WRITE);\r\nif (IS_ERR(key_ref)) {\r\nret = PTR_ERR(key_ref);\r\ngoto error2;\r\n}\r\nret = key_update(key_ref, payload, plen);\r\nkey_ref_put(key_ref);\r\nerror2:\r\nkfree(payload);\r\nerror:\r\nreturn ret;\r\n}\r\nlong keyctl_revoke_key(key_serial_t id)\r\n{\r\nkey_ref_t key_ref;\r\nlong ret;\r\nkey_ref = lookup_user_key(id, 0, KEY_WRITE);\r\nif (IS_ERR(key_ref)) {\r\nret = PTR_ERR(key_ref);\r\nif (ret != -EACCES)\r\ngoto error;\r\nkey_ref = lookup_user_key(id, 0, KEY_SETATTR);\r\nif (IS_ERR(key_ref)) {\r\nret = PTR_ERR(key_ref);\r\ngoto error;\r\n}\r\n}\r\nkey_revoke(key_ref_to_ptr(key_ref));\r\nret = 0;\r\nkey_ref_put(key_ref);\r\nerror:\r\nreturn ret;\r\n}\r\nlong keyctl_keyring_clear(key_serial_t ringid)\r\n{\r\nkey_ref_t keyring_ref;\r\nlong ret;\r\nkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_WRITE);\r\nif (IS_ERR(keyring_ref)) {\r\nret = PTR_ERR(keyring_ref);\r\ngoto error;\r\n}\r\nret = keyring_clear(key_ref_to_ptr(keyring_ref));\r\nkey_ref_put(keyring_ref);\r\nerror:\r\nreturn ret;\r\n}\r\nlong keyctl_keyring_link(key_serial_t id, key_serial_t ringid)\r\n{\r\nkey_ref_t keyring_ref, key_ref;\r\nlong ret;\r\nkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_WRITE);\r\nif (IS_ERR(keyring_ref)) {\r\nret = PTR_ERR(keyring_ref);\r\ngoto error;\r\n}\r\nkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE, KEY_LINK);\r\nif (IS_ERR(key_ref)) {\r\nret = PTR_ERR(key_ref);\r\ngoto error2;\r\n}\r\nret = key_link(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));\r\nkey_ref_put(key_ref);\r\nerror2:\r\nkey_ref_put(keyring_ref);\r\nerror:\r\nreturn ret;\r\n}\r\nlong keyctl_keyring_unlink(key_serial_t id, key_serial_t ringid)\r\n{\r\nkey_ref_t keyring_ref, key_ref;\r\nlong ret;\r\nkeyring_ref = lookup_user_key(ringid, 0, KEY_WRITE);\r\nif (IS_ERR(keyring_ref)) {\r\nret = PTR_ERR(keyring_ref);\r\ngoto error;\r\n}\r\nkey_ref = lookup_user_key(id, KEY_LOOKUP_FOR_UNLINK, 0);\r\nif (IS_ERR(key_ref)) {\r\nret = PTR_ERR(key_ref);\r\ngoto error2;\r\n}\r\nret = key_unlink(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));\r\nkey_ref_put(key_ref);\r\nerror2:\r\nkey_ref_put(keyring_ref);\r\nerror:\r\nreturn ret;\r\n}\r\nlong keyctl_describe_key(key_serial_t keyid,\r\nchar __user *buffer,\r\nsize_t buflen)\r\n{\r\nstruct key *key, *instkey;\r\nkey_ref_t key_ref;\r\nchar *tmpbuf;\r\nlong ret;\r\nkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_VIEW);\r\nif (IS_ERR(key_ref)) {\r\nif (PTR_ERR(key_ref) == -EACCES) {\r\ninstkey = key_get_instantiation_authkey(keyid);\r\nif (!IS_ERR(instkey)) {\r\nkey_put(instkey);\r\nkey_ref = lookup_user_key(keyid,\r\nKEY_LOOKUP_PARTIAL,\r\n0);\r\nif (!IS_ERR(key_ref))\r\ngoto okay;\r\n}\r\n}\r\nret = PTR_ERR(key_ref);\r\ngoto error;\r\n}\r\nokay:\r\nret = -ENOMEM;\r\ntmpbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!tmpbuf)\r\ngoto error2;\r\nkey = key_ref_to_ptr(key_ref);\r\nret = snprintf(tmpbuf, PAGE_SIZE - 1,\r\n"%s;%d;%d;%08x;%s",\r\nkey->type->name,\r\nkey->uid,\r\nkey->gid,\r\nkey->perm,\r\nkey->description ?: "");\r\nif (ret > PAGE_SIZE - 1)\r\nret = PAGE_SIZE - 1;\r\ntmpbuf[ret] = 0;\r\nret++;\r\nif (buffer && buflen > 0) {\r\nif (buflen > ret)\r\nbuflen = ret;\r\nif (copy_to_user(buffer, tmpbuf, buflen) != 0)\r\nret = -EFAULT;\r\n}\r\nkfree(tmpbuf);\r\nerror2:\r\nkey_ref_put(key_ref);\r\nerror:\r\nreturn ret;\r\n}\r\nlong keyctl_keyring_search(key_serial_t ringid,\r\nconst char __user *_type,\r\nconst char __user *_description,\r\nkey_serial_t destringid)\r\n{\r\nstruct key_type *ktype;\r\nkey_ref_t keyring_ref, key_ref, dest_ref;\r\nchar type[32], *description;\r\nlong ret;\r\nret = key_get_type_from_user(type, _type, sizeof(type));\r\nif (ret < 0)\r\ngoto error;\r\ndescription = strndup_user(_description, PAGE_SIZE);\r\nif (IS_ERR(description)) {\r\nret = PTR_ERR(description);\r\ngoto error;\r\n}\r\nkeyring_ref = lookup_user_key(ringid, 0, KEY_SEARCH);\r\nif (IS_ERR(keyring_ref)) {\r\nret = PTR_ERR(keyring_ref);\r\ngoto error2;\r\n}\r\ndest_ref = NULL;\r\nif (destringid) {\r\ndest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\r\nKEY_WRITE);\r\nif (IS_ERR(dest_ref)) {\r\nret = PTR_ERR(dest_ref);\r\ngoto error3;\r\n}\r\n}\r\nktype = key_type_lookup(type);\r\nif (IS_ERR(ktype)) {\r\nret = PTR_ERR(ktype);\r\ngoto error4;\r\n}\r\nkey_ref = keyring_search(keyring_ref, ktype, description);\r\nif (IS_ERR(key_ref)) {\r\nret = PTR_ERR(key_ref);\r\nif (ret == -EAGAIN)\r\nret = -ENOKEY;\r\ngoto error5;\r\n}\r\nif (dest_ref) {\r\nret = key_permission(key_ref, KEY_LINK);\r\nif (ret < 0)\r\ngoto error6;\r\nret = key_link(key_ref_to_ptr(dest_ref), key_ref_to_ptr(key_ref));\r\nif (ret < 0)\r\ngoto error6;\r\n}\r\nret = key_ref_to_ptr(key_ref)->serial;\r\nerror6:\r\nkey_ref_put(key_ref);\r\nerror5:\r\nkey_type_put(ktype);\r\nerror4:\r\nkey_ref_put(dest_ref);\r\nerror3:\r\nkey_ref_put(keyring_ref);\r\nerror2:\r\nkfree(description);\r\nerror:\r\nreturn ret;\r\n}\r\nlong keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\r\n{\r\nstruct key *key;\r\nkey_ref_t key_ref;\r\nlong ret;\r\nkey_ref = lookup_user_key(keyid, 0, 0);\r\nif (IS_ERR(key_ref)) {\r\nret = -ENOKEY;\r\ngoto error;\r\n}\r\nkey = key_ref_to_ptr(key_ref);\r\nret = key_permission(key_ref, KEY_READ);\r\nif (ret == 0)\r\ngoto can_read_key;\r\nif (ret != -EACCES)\r\ngoto error;\r\nif (!is_key_possessed(key_ref)) {\r\nret = -EACCES;\r\ngoto error2;\r\n}\r\ncan_read_key:\r\nret = key_validate(key);\r\nif (ret == 0) {\r\nret = -EOPNOTSUPP;\r\nif (key->type->read) {\r\ndown_read(&key->sem);\r\nret = key->type->read(key, buffer, buflen);\r\nup_read(&key->sem);\r\n}\r\n}\r\nerror2:\r\nkey_put(key);\r\nerror:\r\nreturn ret;\r\n}\r\nlong keyctl_chown_key(key_serial_t id, uid_t uid, gid_t gid)\r\n{\r\nstruct key_user *newowner, *zapowner = NULL;\r\nstruct key *key;\r\nkey_ref_t key_ref;\r\nlong ret;\r\nret = 0;\r\nif (uid == (uid_t) -1 && gid == (gid_t) -1)\r\ngoto error;\r\nkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\r\nKEY_SETATTR);\r\nif (IS_ERR(key_ref)) {\r\nret = PTR_ERR(key_ref);\r\ngoto error;\r\n}\r\nkey = key_ref_to_ptr(key_ref);\r\nret = -EACCES;\r\ndown_write(&key->sem);\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nif (uid != (uid_t) -1 && key->uid != uid)\r\ngoto error_put;\r\nif (gid != (gid_t) -1 && gid != key->gid && !in_group_p(gid))\r\ngoto error_put;\r\n}\r\nif (uid != (uid_t) -1 && uid != key->uid) {\r\nret = -ENOMEM;\r\nnewowner = key_user_lookup(uid, current_user_ns());\r\nif (!newowner)\r\ngoto error_put;\r\nif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\r\nunsigned maxkeys = (uid == 0) ?\r\nkey_quota_root_maxkeys : key_quota_maxkeys;\r\nunsigned maxbytes = (uid == 0) ?\r\nkey_quota_root_maxbytes : key_quota_maxbytes;\r\nspin_lock(&newowner->lock);\r\nif (newowner->qnkeys + 1 >= maxkeys ||\r\nnewowner->qnbytes + key->quotalen >= maxbytes ||\r\nnewowner->qnbytes + key->quotalen <\r\nnewowner->qnbytes)\r\ngoto quota_overrun;\r\nnewowner->qnkeys++;\r\nnewowner->qnbytes += key->quotalen;\r\nspin_unlock(&newowner->lock);\r\nspin_lock(&key->user->lock);\r\nkey->user->qnkeys--;\r\nkey->user->qnbytes -= key->quotalen;\r\nspin_unlock(&key->user->lock);\r\n}\r\natomic_dec(&key->user->nkeys);\r\natomic_inc(&newowner->nkeys);\r\nif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\r\natomic_dec(&key->user->nikeys);\r\natomic_inc(&newowner->nikeys);\r\n}\r\nzapowner = key->user;\r\nkey->user = newowner;\r\nkey->uid = uid;\r\n}\r\nif (gid != (gid_t) -1)\r\nkey->gid = gid;\r\nret = 0;\r\nerror_put:\r\nup_write(&key->sem);\r\nkey_put(key);\r\nif (zapowner)\r\nkey_user_put(zapowner);\r\nerror:\r\nreturn ret;\r\nquota_overrun:\r\nspin_unlock(&newowner->lock);\r\nzapowner = newowner;\r\nret = -EDQUOT;\r\ngoto error_put;\r\n}\r\nlong keyctl_setperm_key(key_serial_t id, key_perm_t perm)\r\n{\r\nstruct key *key;\r\nkey_ref_t key_ref;\r\nlong ret;\r\nret = -EINVAL;\r\nif (perm & ~(KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL))\r\ngoto error;\r\nkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\r\nKEY_SETATTR);\r\nif (IS_ERR(key_ref)) {\r\nret = PTR_ERR(key_ref);\r\ngoto error;\r\n}\r\nkey = key_ref_to_ptr(key_ref);\r\nret = -EACCES;\r\ndown_write(&key->sem);\r\nif (capable(CAP_SYS_ADMIN) || key->uid == current_fsuid()) {\r\nkey->perm = perm;\r\nret = 0;\r\n}\r\nup_write(&key->sem);\r\nkey_put(key);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic long get_instantiation_keyring(key_serial_t ringid,\r\nstruct request_key_auth *rka,\r\nstruct key **_dest_keyring)\r\n{\r\nkey_ref_t dkref;\r\n*_dest_keyring = NULL;\r\nif (ringid == 0)\r\nreturn 0;\r\nif (ringid > 0) {\r\ndkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_WRITE);\r\nif (IS_ERR(dkref))\r\nreturn PTR_ERR(dkref);\r\n*_dest_keyring = key_ref_to_ptr(dkref);\r\nreturn 0;\r\n}\r\nif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\r\nreturn -EINVAL;\r\nif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\r\n*_dest_keyring = key_get(rka->dest_keyring);\r\nreturn 0;\r\n}\r\nreturn -ENOKEY;\r\n}\r\nstatic int keyctl_change_reqkey_auth(struct key *key)\r\n{\r\nstruct cred *new;\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\nkey_put(new->request_key_auth);\r\nnew->request_key_auth = key_get(key);\r\nreturn commit_creds(new);\r\n}\r\nstatic long copy_from_user_iovec(void *buffer, const struct iovec *iov,\r\nunsigned ioc)\r\n{\r\nfor (; ioc > 0; ioc--) {\r\nif (copy_from_user(buffer, iov->iov_base, iov->iov_len) != 0)\r\nreturn -EFAULT;\r\nbuffer += iov->iov_len;\r\niov++;\r\n}\r\nreturn 0;\r\n}\r\nlong keyctl_instantiate_key_common(key_serial_t id,\r\nconst struct iovec *payload_iov,\r\nunsigned ioc,\r\nsize_t plen,\r\nkey_serial_t ringid)\r\n{\r\nconst struct cred *cred = current_cred();\r\nstruct request_key_auth *rka;\r\nstruct key *instkey, *dest_keyring;\r\nvoid *payload;\r\nlong ret;\r\nbool vm = false;\r\nkenter("%d,,%zu,%d", id, plen, ringid);\r\nret = -EINVAL;\r\nif (plen > 1024 * 1024 - 1)\r\ngoto error;\r\nret = -EPERM;\r\ninstkey = cred->request_key_auth;\r\nif (!instkey)\r\ngoto error;\r\nrka = instkey->payload.data;\r\nif (rka->target_key->serial != id)\r\ngoto error;\r\npayload = NULL;\r\nif (payload_iov) {\r\nret = -ENOMEM;\r\npayload = kmalloc(plen, GFP_KERNEL);\r\nif (!payload) {\r\nif (plen <= PAGE_SIZE)\r\ngoto error;\r\nvm = true;\r\npayload = vmalloc(plen);\r\nif (!payload)\r\ngoto error;\r\n}\r\nret = copy_from_user_iovec(payload, payload_iov, ioc);\r\nif (ret < 0)\r\ngoto error2;\r\n}\r\nret = get_instantiation_keyring(ringid, rka, &dest_keyring);\r\nif (ret < 0)\r\ngoto error2;\r\nret = key_instantiate_and_link(rka->target_key, payload, plen,\r\ndest_keyring, instkey);\r\nkey_put(dest_keyring);\r\nif (ret == 0)\r\nkeyctl_change_reqkey_auth(NULL);\r\nerror2:\r\nif (!vm)\r\nkfree(payload);\r\nelse\r\nvfree(payload);\r\nerror:\r\nreturn ret;\r\n}\r\nlong keyctl_instantiate_key(key_serial_t id,\r\nconst void __user *_payload,\r\nsize_t plen,\r\nkey_serial_t ringid)\r\n{\r\nif (_payload && plen) {\r\nstruct iovec iov[1] = {\r\n[0].iov_base = (void __user *)_payload,\r\n[0].iov_len = plen\r\n};\r\nreturn keyctl_instantiate_key_common(id, iov, 1, plen, ringid);\r\n}\r\nreturn keyctl_instantiate_key_common(id, NULL, 0, 0, ringid);\r\n}\r\nlong keyctl_instantiate_key_iov(key_serial_t id,\r\nconst struct iovec __user *_payload_iov,\r\nunsigned ioc,\r\nkey_serial_t ringid)\r\n{\r\nstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\r\nlong ret;\r\nif (_payload_iov == 0 || ioc == 0)\r\ngoto no_payload;\r\nret = rw_copy_check_uvector(WRITE, _payload_iov, ioc,\r\nARRAY_SIZE(iovstack), iovstack, &iov, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret == 0)\r\ngoto no_payload_free;\r\nret = keyctl_instantiate_key_common(id, iov, ioc, ret, ringid);\r\nif (iov != iovstack)\r\nkfree(iov);\r\nreturn ret;\r\nno_payload_free:\r\nif (iov != iovstack)\r\nkfree(iov);\r\nno_payload:\r\nreturn keyctl_instantiate_key_common(id, NULL, 0, 0, ringid);\r\n}\r\nlong keyctl_negate_key(key_serial_t id, unsigned timeout, key_serial_t ringid)\r\n{\r\nreturn keyctl_reject_key(id, timeout, ENOKEY, ringid);\r\n}\r\nlong keyctl_reject_key(key_serial_t id, unsigned timeout, unsigned error,\r\nkey_serial_t ringid)\r\n{\r\nconst struct cred *cred = current_cred();\r\nstruct request_key_auth *rka;\r\nstruct key *instkey, *dest_keyring;\r\nlong ret;\r\nkenter("%d,%u,%u,%d", id, timeout, error, ringid);\r\nif (error <= 0 ||\r\nerror >= MAX_ERRNO ||\r\nerror == ERESTARTSYS ||\r\nerror == ERESTARTNOINTR ||\r\nerror == ERESTARTNOHAND ||\r\nerror == ERESTART_RESTARTBLOCK)\r\nreturn -EINVAL;\r\nret = -EPERM;\r\ninstkey = cred->request_key_auth;\r\nif (!instkey)\r\ngoto error;\r\nrka = instkey->payload.data;\r\nif (rka->target_key->serial != id)\r\ngoto error;\r\nret = get_instantiation_keyring(ringid, rka, &dest_keyring);\r\nif (ret < 0)\r\ngoto error;\r\nret = key_reject_and_link(rka->target_key, timeout, error,\r\ndest_keyring, instkey);\r\nkey_put(dest_keyring);\r\nif (ret == 0)\r\nkeyctl_change_reqkey_auth(NULL);\r\nerror:\r\nreturn ret;\r\n}\r\nlong keyctl_set_reqkey_keyring(int reqkey_defl)\r\n{\r\nstruct cred *new;\r\nint ret, old_setting;\r\nold_setting = current_cred_xxx(jit_keyring);\r\nif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\r\nreturn old_setting;\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\nswitch (reqkey_defl) {\r\ncase KEY_REQKEY_DEFL_THREAD_KEYRING:\r\nret = install_thread_keyring_to_cred(new);\r\nif (ret < 0)\r\ngoto error;\r\ngoto set;\r\ncase KEY_REQKEY_DEFL_PROCESS_KEYRING:\r\nret = install_process_keyring_to_cred(new);\r\nif (ret < 0) {\r\nif (ret != -EEXIST)\r\ngoto error;\r\nret = 0;\r\n}\r\ngoto set;\r\ncase KEY_REQKEY_DEFL_DEFAULT:\r\ncase KEY_REQKEY_DEFL_SESSION_KEYRING:\r\ncase KEY_REQKEY_DEFL_USER_KEYRING:\r\ncase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\r\ncase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\r\ngoto set;\r\ncase KEY_REQKEY_DEFL_NO_CHANGE:\r\ncase KEY_REQKEY_DEFL_GROUP_KEYRING:\r\ndefault:\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nset:\r\nnew->jit_keyring = reqkey_defl;\r\ncommit_creds(new);\r\nreturn old_setting;\r\nerror:\r\nabort_creds(new);\r\nreturn ret;\r\n}\r\nlong keyctl_set_timeout(key_serial_t id, unsigned timeout)\r\n{\r\nstruct timespec now;\r\nstruct key *key, *instkey;\r\nkey_ref_t key_ref;\r\ntime_t expiry;\r\nlong ret;\r\nkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\r\nKEY_SETATTR);\r\nif (IS_ERR(key_ref)) {\r\nif (PTR_ERR(key_ref) == -EACCES) {\r\ninstkey = key_get_instantiation_authkey(id);\r\nif (!IS_ERR(instkey)) {\r\nkey_put(instkey);\r\nkey_ref = lookup_user_key(id,\r\nKEY_LOOKUP_PARTIAL,\r\n0);\r\nif (!IS_ERR(key_ref))\r\ngoto okay;\r\n}\r\n}\r\nret = PTR_ERR(key_ref);\r\ngoto error;\r\n}\r\nokay:\r\nkey = key_ref_to_ptr(key_ref);\r\ndown_write(&key->sem);\r\nexpiry = 0;\r\nif (timeout > 0) {\r\nnow = current_kernel_time();\r\nexpiry = now.tv_sec + timeout;\r\n}\r\nkey->expiry = expiry;\r\nkey_schedule_gc(key->expiry + key_gc_delay);\r\nup_write(&key->sem);\r\nkey_put(key);\r\nret = 0;\r\nerror:\r\nreturn ret;\r\n}\r\nlong keyctl_assume_authority(key_serial_t id)\r\n{\r\nstruct key *authkey;\r\nlong ret;\r\nret = -EINVAL;\r\nif (id < 0)\r\ngoto error;\r\nif (id == 0) {\r\nret = keyctl_change_reqkey_auth(NULL);\r\ngoto error;\r\n}\r\nauthkey = key_get_instantiation_authkey(id);\r\nif (IS_ERR(authkey)) {\r\nret = PTR_ERR(authkey);\r\ngoto error;\r\n}\r\nret = keyctl_change_reqkey_auth(authkey);\r\nif (ret < 0)\r\ngoto error;\r\nkey_put(authkey);\r\nret = authkey->serial;\r\nerror:\r\nreturn ret;\r\n}\r\nlong keyctl_get_security(key_serial_t keyid,\r\nchar __user *buffer,\r\nsize_t buflen)\r\n{\r\nstruct key *key, *instkey;\r\nkey_ref_t key_ref;\r\nchar *context;\r\nlong ret;\r\nkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_VIEW);\r\nif (IS_ERR(key_ref)) {\r\nif (PTR_ERR(key_ref) != -EACCES)\r\nreturn PTR_ERR(key_ref);\r\ninstkey = key_get_instantiation_authkey(keyid);\r\nif (IS_ERR(instkey))\r\nreturn PTR_ERR(instkey);\r\nkey_put(instkey);\r\nkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, 0);\r\nif (IS_ERR(key_ref))\r\nreturn PTR_ERR(key_ref);\r\n}\r\nkey = key_ref_to_ptr(key_ref);\r\nret = security_key_getsecurity(key, &context);\r\nif (ret == 0) {\r\nret = 1;\r\nif (buffer && buflen > 0 &&\r\ncopy_to_user(buffer, "", 1) != 0)\r\nret = -EFAULT;\r\n} else if (ret > 0) {\r\nif (buffer && buflen > 0) {\r\nif (buflen > ret)\r\nbuflen = ret;\r\nif (copy_to_user(buffer, context, buflen) != 0)\r\nret = -EFAULT;\r\n}\r\nkfree(context);\r\n}\r\nkey_ref_put(key_ref);\r\nreturn ret;\r\n}\r\nlong keyctl_session_to_parent(void)\r\n{\r\n#ifdef TIF_NOTIFY_RESUME\r\nstruct task_struct *me, *parent;\r\nconst struct cred *mycred, *pcred;\r\nstruct cred *cred, *oldcred;\r\nkey_ref_t keyring_r;\r\nint ret;\r\nkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_LINK);\r\nif (IS_ERR(keyring_r))\r\nreturn PTR_ERR(keyring_r);\r\nret = -ENOMEM;\r\ncred = cred_alloc_blank();\r\nif (!cred)\r\ngoto error_keyring;\r\ncred->tgcred->session_keyring = key_ref_to_ptr(keyring_r);\r\nkeyring_r = NULL;\r\nme = current;\r\nrcu_read_lock();\r\nwrite_lock_irq(&tasklist_lock);\r\nparent = me->real_parent;\r\nret = -EPERM;\r\nif (parent->pid <= 1 || !parent->mm)\r\ngoto not_permitted;\r\nif (!thread_group_empty(parent))\r\ngoto not_permitted;\r\nmycred = current_cred();\r\npcred = __task_cred(parent);\r\nif (mycred == pcred ||\r\nmycred->tgcred->session_keyring == pcred->tgcred->session_keyring)\r\ngoto already_same;\r\nif (pcred->uid != mycred->euid ||\r\npcred->euid != mycred->euid ||\r\npcred->suid != mycred->euid ||\r\npcred->gid != mycred->egid ||\r\npcred->egid != mycred->egid ||\r\npcred->sgid != mycred->egid)\r\ngoto not_permitted;\r\nif ((pcred->tgcred->session_keyring &&\r\npcred->tgcred->session_keyring->uid != mycred->euid) ||\r\nmycred->tgcred->session_keyring->uid != mycred->euid)\r\ngoto not_permitted;\r\noldcred = parent->replacement_session_keyring;\r\nparent->replacement_session_keyring = cred;\r\ncred = NULL;\r\nset_ti_thread_flag(task_thread_info(parent), TIF_NOTIFY_RESUME);\r\nwrite_unlock_irq(&tasklist_lock);\r\nrcu_read_unlock();\r\nif (oldcred)\r\nput_cred(oldcred);\r\nreturn 0;\r\nalready_same:\r\nret = 0;\r\nnot_permitted:\r\nwrite_unlock_irq(&tasklist_lock);\r\nrcu_read_unlock();\r\nput_cred(cred);\r\nreturn ret;\r\nerror_keyring:\r\nkey_ref_put(keyring_r);\r\nreturn ret;\r\n#else\r\n#warning TIF_NOTIFY_RESUME not implemented\r\nreturn -EOPNOTSUPP;\r\n#endif\r\n}
