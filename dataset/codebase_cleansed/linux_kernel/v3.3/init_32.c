void __init kmap_init(void)\r\n{\r\nkmap_pte = kmap_get_fixmap_pte(__fix_to_virt(FIX_KMAP_BEGIN));\r\nkmap_prot = __pgprot(SRMMU_ET_PTE | SRMMU_PRIV | SRMMU_CACHE);\r\n}\r\nvoid show_mem(unsigned int filter)\r\n{\r\nprintk("Mem-info:\n");\r\nshow_free_areas(filter);\r\nprintk("Free swap: %6ldkB\n",\r\nnr_swap_pages << (PAGE_SHIFT-10));\r\nprintk("%ld pages of RAM\n", totalram_pages);\r\nprintk("%ld free pages\n", nr_free_pages());\r\n#if 0\r\nprintk("%ld pages in page table cache\n",pgtable_cache_size);\r\n#ifndef CONFIG_SMP\r\nif (sparc_cpu_model == sun4m || sparc_cpu_model == sun4d)\r\nprintk("%ld entries in page dir cache\n",pgd_cache_size);\r\n#endif\r\n#endif\r\n}\r\nvoid __init sparc_context_init(int numctx)\r\n{\r\nint ctx;\r\nctx_list_pool = __alloc_bootmem(numctx * sizeof(struct ctx_list), SMP_CACHE_BYTES, 0UL);\r\nfor(ctx = 0; ctx < numctx; ctx++) {\r\nstruct ctx_list *clist;\r\nclist = (ctx_list_pool + ctx);\r\nclist->ctx_number = ctx;\r\nclist->ctx_mm = NULL;\r\n}\r\nctx_free.next = ctx_free.prev = &ctx_free;\r\nctx_used.next = ctx_used.prev = &ctx_used;\r\nfor(ctx = 0; ctx < numctx; ctx++)\r\nadd_to_free_ctxlist(ctx_list_pool + ctx);\r\n}\r\nunsigned long calc_highpages(void)\r\n{\r\nint i;\r\nint nr = 0;\r\nfor (i = 0; sp_banks[i].num_bytes != 0; i++) {\r\nunsigned long start_pfn = sp_banks[i].base_addr >> PAGE_SHIFT;\r\nunsigned long end_pfn = (sp_banks[i].base_addr + sp_banks[i].num_bytes) >> PAGE_SHIFT;\r\nif (end_pfn <= max_low_pfn)\r\ncontinue;\r\nif (start_pfn < max_low_pfn)\r\nstart_pfn = max_low_pfn;\r\nnr += end_pfn - start_pfn;\r\n}\r\nreturn nr;\r\n}\r\nstatic unsigned long calc_max_low_pfn(void)\r\n{\r\nint i;\r\nunsigned long tmp = pfn_base + (SRMMU_MAXMEM >> PAGE_SHIFT);\r\nunsigned long curr_pfn, last_pfn;\r\nlast_pfn = (sp_banks[0].base_addr + sp_banks[0].num_bytes) >> PAGE_SHIFT;\r\nfor (i = 1; sp_banks[i].num_bytes != 0; i++) {\r\ncurr_pfn = sp_banks[i].base_addr >> PAGE_SHIFT;\r\nif (curr_pfn >= tmp) {\r\nif (last_pfn < tmp)\r\ntmp = last_pfn;\r\nbreak;\r\n}\r\nlast_pfn = (sp_banks[i].base_addr + sp_banks[i].num_bytes) >> PAGE_SHIFT;\r\n}\r\nreturn tmp;\r\n}\r\nunsigned long __init bootmem_init(unsigned long *pages_avail)\r\n{\r\nunsigned long bootmap_size, start_pfn;\r\nunsigned long end_of_phys_memory = 0UL;\r\nunsigned long bootmap_pfn, bytes_avail, size;\r\nint i;\r\nbytes_avail = 0UL;\r\nfor (i = 0; sp_banks[i].num_bytes != 0; i++) {\r\nend_of_phys_memory = sp_banks[i].base_addr +\r\nsp_banks[i].num_bytes;\r\nbytes_avail += sp_banks[i].num_bytes;\r\nif (cmdline_memory_size) {\r\nif (bytes_avail > cmdline_memory_size) {\r\nunsigned long slack = bytes_avail - cmdline_memory_size;\r\nbytes_avail -= slack;\r\nend_of_phys_memory -= slack;\r\nsp_banks[i].num_bytes -= slack;\r\nif (sp_banks[i].num_bytes == 0) {\r\nsp_banks[i].base_addr = 0xdeadbeef;\r\n} else {\r\nsp_banks[i+1].num_bytes = 0;\r\nsp_banks[i+1].base_addr = 0xdeadbeef;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstart_pfn = (unsigned long)__pa(PAGE_ALIGN((unsigned long) &_end));\r\nstart_pfn >>= PAGE_SHIFT;\r\nbootmap_pfn = start_pfn;\r\nmax_pfn = end_of_phys_memory >> PAGE_SHIFT;\r\nmax_low_pfn = max_pfn;\r\nhighstart_pfn = highend_pfn = max_pfn;\r\nif (max_low_pfn > pfn_base + (SRMMU_MAXMEM >> PAGE_SHIFT)) {\r\nhighstart_pfn = pfn_base + (SRMMU_MAXMEM >> PAGE_SHIFT);\r\nmax_low_pfn = calc_max_low_pfn();\r\nprintk(KERN_NOTICE "%ldMB HIGHMEM available.\n",\r\ncalc_highpages() >> (20 - PAGE_SHIFT));\r\n}\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\nif (sparc_ramdisk_image) {\r\nif (sparc_ramdisk_image >= (unsigned long)&_end - 2 * PAGE_SIZE)\r\nsparc_ramdisk_image -= KERNBASE;\r\ninitrd_start = sparc_ramdisk_image + phys_base;\r\ninitrd_end = initrd_start + sparc_ramdisk_size;\r\nif (initrd_end > end_of_phys_memory) {\r\nprintk(KERN_CRIT "initrd extends beyond end of memory "\r\n"(0x%016lx > 0x%016lx)\ndisabling initrd\n",\r\ninitrd_end, end_of_phys_memory);\r\ninitrd_start = 0;\r\n}\r\nif (initrd_start) {\r\nif (initrd_start >= (start_pfn << PAGE_SHIFT) &&\r\ninitrd_start < (start_pfn << PAGE_SHIFT) + 2 * PAGE_SIZE)\r\nbootmap_pfn = PAGE_ALIGN (initrd_end) >> PAGE_SHIFT;\r\n}\r\n}\r\n#endif\r\nbootmap_size = init_bootmem_node(NODE_DATA(0), bootmap_pfn, pfn_base,\r\nmax_low_pfn);\r\n*pages_avail = 0;\r\nfor (i = 0; sp_banks[i].num_bytes != 0; i++) {\r\nunsigned long curr_pfn, last_pfn;\r\ncurr_pfn = sp_banks[i].base_addr >> PAGE_SHIFT;\r\nif (curr_pfn >= max_low_pfn)\r\nbreak;\r\nlast_pfn = (sp_banks[i].base_addr + sp_banks[i].num_bytes) >> PAGE_SHIFT;\r\nif (last_pfn > max_low_pfn)\r\nlast_pfn = max_low_pfn;\r\nif (last_pfn <= curr_pfn)\r\ncontinue;\r\nsize = (last_pfn - curr_pfn) << PAGE_SHIFT;\r\n*pages_avail += last_pfn - curr_pfn;\r\nfree_bootmem(sp_banks[i].base_addr, size);\r\n}\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\nif (initrd_start) {\r\nsize = initrd_end - initrd_start;\r\nreserve_bootmem(initrd_start, size, BOOTMEM_DEFAULT);\r\n*pages_avail -= PAGE_ALIGN(size) >> PAGE_SHIFT;\r\ninitrd_start = (initrd_start - phys_base) + PAGE_OFFSET;\r\ninitrd_end = (initrd_end - phys_base) + PAGE_OFFSET;\r\n}\r\n#endif\r\nsize = (start_pfn << PAGE_SHIFT) - phys_base;\r\nreserve_bootmem(phys_base, size, BOOTMEM_DEFAULT);\r\n*pages_avail -= PAGE_ALIGN(size) >> PAGE_SHIFT;\r\nsize = bootmap_size;\r\nreserve_bootmem((bootmap_pfn << PAGE_SHIFT), size, BOOTMEM_DEFAULT);\r\n*pages_avail -= PAGE_ALIGN(size) >> PAGE_SHIFT;\r\nreturn max_pfn;\r\n}\r\nvoid check_pgt_cache(void)\r\n{\r\ndo_check_pgt_cache(pgt_cache_water[0], pgt_cache_water[1]);\r\n}\r\nvoid __init paging_init(void)\r\n{\r\nswitch(sparc_cpu_model) {\r\ncase sun4c:\r\ncase sun4e:\r\ncase sun4:\r\nsun4c_paging_init();\r\nsparc_unmapped_base = 0xe0000000;\r\nBTFIXUPSET_SETHI(sparc_unmapped_base, 0xe0000000);\r\nbreak;\r\ncase sparc_leon:\r\nleon_init();\r\ncase sun4m:\r\ncase sun4d:\r\nsrmmu_paging_init();\r\nsparc_unmapped_base = 0x50000000;\r\nBTFIXUPSET_SETHI(sparc_unmapped_base, 0x50000000);\r\nbreak;\r\ndefault:\r\nprom_printf("paging_init: Cannot init paging on this Sparc\n");\r\nprom_printf("paging_init: sparc_cpu_model = %d\n", sparc_cpu_model);\r\nprom_printf("paging_init: Halting...\n");\r\nprom_halt();\r\n}\r\nprotection_map[0] = PAGE_NONE;\r\nprotection_map[1] = PAGE_READONLY;\r\nprotection_map[2] = PAGE_COPY;\r\nprotection_map[3] = PAGE_COPY;\r\nprotection_map[4] = PAGE_READONLY;\r\nprotection_map[5] = PAGE_READONLY;\r\nprotection_map[6] = PAGE_COPY;\r\nprotection_map[7] = PAGE_COPY;\r\nprotection_map[8] = PAGE_NONE;\r\nprotection_map[9] = PAGE_READONLY;\r\nprotection_map[10] = PAGE_SHARED;\r\nprotection_map[11] = PAGE_SHARED;\r\nprotection_map[12] = PAGE_READONLY;\r\nprotection_map[13] = PAGE_READONLY;\r\nprotection_map[14] = PAGE_SHARED;\r\nprotection_map[15] = PAGE_SHARED;\r\nbtfixup();\r\nprom_build_devicetree();\r\nof_fill_in_cpu_data();\r\ndevice_scan();\r\n}\r\nstatic void __init taint_real_pages(void)\r\n{\r\nint i;\r\nfor (i = 0; sp_banks[i].num_bytes; i++) {\r\nunsigned long start, end;\r\nstart = sp_banks[i].base_addr;\r\nend = start + sp_banks[i].num_bytes;\r\nwhile (start < end) {\r\nset_bit(start >> 20, sparc_valid_addr_bitmap);\r\nstart += PAGE_SIZE;\r\n}\r\n}\r\n}\r\nstatic void map_high_region(unsigned long start_pfn, unsigned long end_pfn)\r\n{\r\nunsigned long tmp;\r\n#ifdef CONFIG_DEBUG_HIGHMEM\r\nprintk("mapping high region %08lx - %08lx\n", start_pfn, end_pfn);\r\n#endif\r\nfor (tmp = start_pfn; tmp < end_pfn; tmp++) {\r\nstruct page *page = pfn_to_page(tmp);\r\nClearPageReserved(page);\r\ninit_page_count(page);\r\n__free_page(page);\r\ntotalhigh_pages++;\r\n}\r\n}\r\nvoid __init mem_init(void)\r\n{\r\nint codepages = 0;\r\nint datapages = 0;\r\nint initpages = 0;\r\nint reservedpages = 0;\r\nint i;\r\nif (PKMAP_BASE+LAST_PKMAP*PAGE_SIZE >= FIXADDR_START) {\r\nprom_printf("BUG: fixmap and pkmap areas overlap\n");\r\nprom_printf("pkbase: 0x%lx pkend: 0x%lx fixstart 0x%lx\n",\r\nPKMAP_BASE,\r\n(unsigned long)PKMAP_BASE+LAST_PKMAP*PAGE_SIZE,\r\nFIXADDR_START);\r\nprom_printf("Please mail sparclinux@vger.kernel.org.\n");\r\nprom_halt();\r\n}\r\nmemset((void *)&empty_zero_page, 0, PAGE_SIZE);\r\ni = last_valid_pfn >> ((20 - PAGE_SHIFT) + 5);\r\ni += 1;\r\nsparc_valid_addr_bitmap = (unsigned long *)\r\n__alloc_bootmem(i << 2, SMP_CACHE_BYTES, 0UL);\r\nif (sparc_valid_addr_bitmap == NULL) {\r\nprom_printf("mem_init: Cannot alloc valid_addr_bitmap.\n");\r\nprom_halt();\r\n}\r\nmemset(sparc_valid_addr_bitmap, 0, i << 2);\r\ntaint_real_pages();\r\nmax_mapnr = last_valid_pfn - pfn_base;\r\nhigh_memory = __va(max_low_pfn << PAGE_SHIFT);\r\ntotalram_pages = free_all_bootmem();\r\nfor (i = 0; sp_banks[i].num_bytes != 0; i++) {\r\nunsigned long start_pfn = sp_banks[i].base_addr >> PAGE_SHIFT;\r\nunsigned long end_pfn = (sp_banks[i].base_addr + sp_banks[i].num_bytes) >> PAGE_SHIFT;\r\nnum_physpages += sp_banks[i].num_bytes >> PAGE_SHIFT;\r\nif (end_pfn <= highstart_pfn)\r\ncontinue;\r\nif (start_pfn < highstart_pfn)\r\nstart_pfn = highstart_pfn;\r\nmap_high_region(start_pfn, end_pfn);\r\n}\r\ntotalram_pages += totalhigh_pages;\r\ncodepages = (((unsigned long) &_etext) - ((unsigned long)&_start));\r\ncodepages = PAGE_ALIGN(codepages) >> PAGE_SHIFT;\r\ndatapages = (((unsigned long) &_edata) - ((unsigned long)&_etext));\r\ndatapages = PAGE_ALIGN(datapages) >> PAGE_SHIFT;\r\ninitpages = (((unsigned long) &__init_end) - ((unsigned long) &__init_begin));\r\ninitpages = PAGE_ALIGN(initpages) >> PAGE_SHIFT;\r\nfor (i=0; i < max_low_pfn; i++)\r\nif (test_bit(i >> (20 - PAGE_SHIFT), sparc_valid_addr_bitmap)\r\n&& PageReserved(pfn_to_page(i)))\r\nreservedpages++;\r\nprintk(KERN_INFO "Memory: %luk/%luk available (%dk kernel code, %dk reserved, %dk data, %dk init, %ldk highmem)\n",\r\nnr_free_pages() << (PAGE_SHIFT-10),\r\nnum_physpages << (PAGE_SHIFT - 10),\r\ncodepages << (PAGE_SHIFT-10),\r\nreservedpages << (PAGE_SHIFT - 10),\r\ndatapages << (PAGE_SHIFT-10),\r\ninitpages << (PAGE_SHIFT-10),\r\ntotalhigh_pages << (PAGE_SHIFT-10));\r\n}\r\nvoid free_initmem (void)\r\n{\r\nunsigned long addr;\r\nunsigned long freed;\r\naddr = (unsigned long)(&__init_begin);\r\nfreed = (unsigned long)(&__init_end) - addr;\r\nfor (; addr < (unsigned long)(&__init_end); addr += PAGE_SIZE) {\r\nstruct page *p;\r\nmemset((void *)addr, POISON_FREE_INITMEM, PAGE_SIZE);\r\np = virt_to_page(addr);\r\nClearPageReserved(p);\r\ninit_page_count(p);\r\n__free_page(p);\r\ntotalram_pages++;\r\nnum_physpages++;\r\n}\r\nprintk(KERN_INFO "Freeing unused kernel memory: %ldk freed\n",\r\nfreed >> 10);\r\n}\r\nvoid free_initrd_mem(unsigned long start, unsigned long end)\r\n{\r\nif (start < end)\r\nprintk(KERN_INFO "Freeing initrd memory: %ldk freed\n",\r\n(end - start) >> 10);\r\nfor (; start < end; start += PAGE_SIZE) {\r\nstruct page *p;\r\nmemset((void *)start, POISON_FREE_INITMEM, PAGE_SIZE);\r\np = virt_to_page(start);\r\nClearPageReserved(p);\r\ninit_page_count(p);\r\n__free_page(p);\r\ntotalram_pages++;\r\nnum_physpages++;\r\n}\r\n}\r\nvoid sparc_flush_page_to_ram(struct page *page)\r\n{\r\nunsigned long vaddr = (unsigned long)page_address(page);\r\nif (vaddr)\r\n__flush_page_to_ram(vaddr);\r\n}
