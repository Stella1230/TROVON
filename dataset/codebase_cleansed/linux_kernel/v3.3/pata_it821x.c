static void it821x_program(struct ata_port *ap, struct ata_device *adev, u16 timing)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstruct it821x_dev *itdev = ap->private_data;\r\nint channel = ap->port_no;\r\nu8 conf;\r\nif (itdev->clock_mode == ATA_66)\r\nconf = timing >> 8;\r\nelse\r\nconf = timing & 0xFF;\r\npci_write_config_byte(pdev, 0x54 + 4 * channel, conf);\r\n}\r\nstatic void it821x_program_udma(struct ata_port *ap, struct ata_device *adev, u16 timing)\r\n{\r\nstruct it821x_dev *itdev = ap->private_data;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nint channel = ap->port_no;\r\nint unit = adev->devno;\r\nu8 conf;\r\nif (itdev->clock_mode == ATA_66)\r\nconf = timing >> 8;\r\nelse\r\nconf = timing & 0xFF;\r\nif (itdev->timing10 == 0)\r\npci_write_config_byte(pdev, 0x56 + 4 * channel + unit, conf);\r\nelse {\r\npci_write_config_byte(pdev, 0x56 + 4 * channel, conf);\r\npci_write_config_byte(pdev, 0x56 + 4 * channel + 1, conf);\r\n}\r\n}\r\nstatic void it821x_clock_strategy(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstruct it821x_dev *itdev = ap->private_data;\r\nu8 unit = adev->devno;\r\nstruct ata_device *pair = ata_dev_pair(adev);\r\nint clock, altclock;\r\nu8 v;\r\nint sel = 0;\r\nif (itdev->want[0][0] > itdev->want[1][0]) {\r\nclock = itdev->want[0][1];\r\naltclock = itdev->want[1][1];\r\n} else {\r\nclock = itdev->want[1][1];\r\naltclock = itdev->want[0][1];\r\n}\r\nif (clock == ATA_ANY)\r\nclock = altclock;\r\nif (clock == ATA_ANY)\r\nreturn;\r\nif (clock == itdev->clock_mode)\r\nreturn;\r\nif (clock == ATA_66)\r\nitdev->clock_mode = ATA_66;\r\nelse {\r\nitdev->clock_mode = ATA_50;\r\nsel = 1;\r\n}\r\npci_read_config_byte(pdev, 0x50, &v);\r\nv &= ~(1 << (1 + ap->port_no));\r\nv |= sel << (1 + ap->port_no);\r\npci_write_config_byte(pdev, 0x50, v);\r\nif (pair && itdev->udma[1-unit] != UDMA_OFF) {\r\nit821x_program_udma(ap, pair, itdev->udma[1-unit]);\r\nit821x_program(ap, pair, itdev->pio[1-unit]);\r\n}\r\nif (itdev->udma[unit] != UDMA_OFF) {\r\nit821x_program_udma(ap, adev, itdev->udma[unit]);\r\nit821x_program(ap, adev, itdev->pio[unit]);\r\n}\r\n}\r\nstatic void it821x_passthru_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstatic const u16 pio[] = { 0xAA88, 0xA382, 0xA181, 0x3332, 0x3121 };\r\nstatic const u8 pio_want[] = { ATA_66, ATA_66, ATA_66, ATA_66, ATA_ANY };\r\nstruct it821x_dev *itdev = ap->private_data;\r\nint unit = adev->devno;\r\nint mode_wanted = adev->pio_mode - XFER_PIO_0;\r\nitdev->want[unit][1] = pio_want[mode_wanted];\r\nitdev->want[unit][0] = 1;\r\nitdev->pio[unit] = pio[mode_wanted];\r\nit821x_clock_strategy(ap, adev);\r\nit821x_program(ap, adev, itdev->pio[unit]);\r\n}\r\nstatic void it821x_passthru_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstatic const u16 dma[] = { 0x8866, 0x3222, 0x3121 };\r\nstatic const u8 mwdma_want[] = { ATA_ANY, ATA_66, ATA_ANY };\r\nstatic const u16 udma[] = { 0x4433, 0x4231, 0x3121, 0x2121, 0x1111, 0x2211, 0x1111 };\r\nstatic const u8 udma_want[] = { ATA_ANY, ATA_50, ATA_ANY, ATA_66, ATA_66, ATA_50, ATA_66 };\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstruct it821x_dev *itdev = ap->private_data;\r\nint channel = ap->port_no;\r\nint unit = adev->devno;\r\nu8 conf;\r\nif (adev->dma_mode >= XFER_UDMA_0) {\r\nint mode_wanted = adev->dma_mode - XFER_UDMA_0;\r\nitdev->want[unit][1] = udma_want[mode_wanted];\r\nitdev->want[unit][0] = 3;\r\nitdev->mwdma[unit] = MWDMA_OFF;\r\nitdev->udma[unit] = udma[mode_wanted];\r\nif (mode_wanted >= 5)\r\nitdev->udma[unit] |= 0x8080;\r\npci_read_config_byte(pdev, 0x50, &conf);\r\nif (itdev->timing10)\r\nconf &= channel ? 0x9F: 0xE7;\r\nelse\r\nconf &= ~ (1 << (3 + 2 * channel + unit));\r\npci_write_config_byte(pdev, 0x50, conf);\r\nit821x_clock_strategy(ap, adev);\r\nit821x_program_udma(ap, adev, itdev->udma[unit]);\r\n} else {\r\nint mode_wanted = adev->dma_mode - XFER_MW_DMA_0;\r\nitdev->want[unit][1] = mwdma_want[mode_wanted];\r\nitdev->want[unit][0] = 2;\r\nitdev->mwdma[unit] = dma[mode_wanted];\r\nitdev->udma[unit] = UDMA_OFF;\r\npci_read_config_byte(pdev, 0x50, &conf);\r\nif (itdev->timing10)\r\nconf |= channel ? 0x60: 0x18;\r\nelse\r\nconf |= 1 << (3 + 2 * channel + unit);\r\npci_write_config_byte(pdev, 0x50, conf);\r\nit821x_clock_strategy(ap, adev);\r\n}\r\n}\r\nstatic void it821x_passthru_bmdma_start(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ata_device *adev = qc->dev;\r\nstruct it821x_dev *itdev = ap->private_data;\r\nint unit = adev->devno;\r\nif (itdev->mwdma[unit] != MWDMA_OFF)\r\nit821x_program(ap, adev, itdev->mwdma[unit]);\r\nelse if (itdev->udma[unit] != UDMA_OFF && itdev->timing10)\r\nit821x_program_udma(ap, adev, itdev->udma[unit]);\r\nata_bmdma_start(qc);\r\n}\r\nstatic void it821x_passthru_bmdma_stop(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ata_device *adev = qc->dev;\r\nstruct it821x_dev *itdev = ap->private_data;\r\nint unit = adev->devno;\r\nata_bmdma_stop(qc);\r\nif (itdev->mwdma[unit] != MWDMA_OFF)\r\nit821x_program(ap, adev, itdev->pio[unit]);\r\n}\r\nstatic void it821x_passthru_dev_select(struct ata_port *ap,\r\nunsigned int device)\r\n{\r\nstruct it821x_dev *itdev = ap->private_data;\r\nif (itdev && device != itdev->last_device) {\r\nstruct ata_device *adev = &ap->link.device[device];\r\nit821x_program(ap, adev, itdev->pio[adev->devno]);\r\nitdev->last_device = device;\r\n}\r\nata_sff_dev_select(ap, device);\r\n}\r\nstatic unsigned int it821x_smart_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nswitch(qc->tf.command)\r\n{\r\ncase ATA_CMD_READ:\r\ncase ATA_CMD_READ_EXT:\r\ncase ATA_CMD_WRITE:\r\ncase ATA_CMD_WRITE_EXT:\r\ncase ATA_CMD_PIO_READ:\r\ncase ATA_CMD_PIO_READ_EXT:\r\ncase ATA_CMD_PIO_WRITE:\r\ncase ATA_CMD_PIO_WRITE_EXT:\r\ncase ATA_CMD_READ_MULTI:\r\ncase ATA_CMD_READ_MULTI_EXT:\r\ncase ATA_CMD_WRITE_MULTI:\r\ncase ATA_CMD_WRITE_MULTI_EXT:\r\ncase ATA_CMD_ID_ATA:\r\ncase ATA_CMD_INIT_DEV_PARAMS:\r\ncase 0xFC:\r\ncase ATA_CMD_SET_FEATURES:\r\nreturn ata_bmdma_qc_issue(qc);\r\n}\r\nprintk(KERN_DEBUG "it821x: can't process command 0x%02X\n", qc->tf.command);\r\nreturn AC_ERR_DEV;\r\n}\r\nstatic unsigned int it821x_passthru_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nit821x_passthru_dev_select(qc->ap, qc->dev->devno);\r\nreturn ata_bmdma_qc_issue(qc);\r\n}\r\nstatic int it821x_smart_set_mode(struct ata_link *link, struct ata_device **unused)\r\n{\r\nstruct ata_device *dev;\r\nata_for_each_dev(dev, link, ENABLED) {\r\ndev->pio_mode = XFER_PIO_0;\r\ndev->dma_mode = XFER_MW_DMA_0;\r\nif (ata_id_has_dma(dev->id)) {\r\nata_dev_info(dev, "configured for DMA\n");\r\ndev->xfer_mode = XFER_MW_DMA_0;\r\ndev->xfer_shift = ATA_SHIFT_MWDMA;\r\ndev->flags &= ~ATA_DFLAG_PIO;\r\n} else {\r\nata_dev_info(dev, "configured for PIO\n");\r\ndev->xfer_mode = XFER_PIO_0;\r\ndev->xfer_shift = ATA_SHIFT_PIO;\r\ndev->flags |= ATA_DFLAG_PIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void it821x_dev_config(struct ata_device *adev)\r\n{\r\nunsigned char model_num[ATA_ID_PROD_LEN + 1];\r\nata_id_c_string(adev->id, model_num, ATA_ID_PROD, sizeof(model_num));\r\nif (adev->max_sectors > 255)\r\nadev->max_sectors = 255;\r\nif (strstr(model_num, "Integrated Technology Express")) {\r\nata_dev_info(adev, "%sRAID%d volume",\r\nadev->id[147] ? "Bootable " : "",\r\nadev->id[129]);\r\nif (adev->id[129] != 1)\r\npr_cont("(%dK stripe)", adev->id[146]);\r\npr_cont("\n");\r\n}\r\nadev->horkage &= ~ATA_HORKAGE_DIAGNOSTIC;\r\nadev->horkage |= ATA_HORKAGE_BROKEN_HPA;\r\n}\r\nstatic unsigned int it821x_read_id(struct ata_device *adev,\r\nstruct ata_taskfile *tf, u16 *id)\r\n{\r\nunsigned int err_mask;\r\nunsigned char model_num[ATA_ID_PROD_LEN + 1];\r\nerr_mask = ata_do_dev_read_id(adev, tf, id);\r\nif (err_mask)\r\nreturn err_mask;\r\nata_id_c_string(id, model_num, ATA_ID_PROD, sizeof(model_num));\r\nid[83] &= ~(1 << 12);\r\nid[83] &= ~(1 << 13);\r\nid[84] &= ~(1 << 6);\r\nid[85] &= ~(1 << 10);\r\nid[76] = 0;\r\nif (strstr(model_num, "Integrated Technology Express")) {\r\nid[49] |= 0x0300;\r\nid[83] &= 0x7FFF;\r\nid[83] |= 0x4400;\r\nid[86] |= 0x0400;\r\nid[ATA_ID_MAJOR_VER] |= 0x1F;\r\nmemset(&id[ATA_ID_SERNO], 0x20, ATA_ID_SERNO_LEN);\r\n}\r\nreturn err_mask;\r\n}\r\nstatic int it821x_check_atapi_dma(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct it821x_dev *itdev = ap->private_data;\r\nif (ata_qc_raw_nbytes(qc) < 2048)\r\nreturn -EOPNOTSUPP;\r\nif (itdev->smart)\r\nreturn -EOPNOTSUPP;\r\nif (itdev->timing10)\r\nreturn -EOPNOTSUPP;\r\nreturn 0;\r\n}\r\nstatic void it821x_display_disk(int n, u8 *buf)\r\n{\r\nunsigned char id[41];\r\nint mode = 0;\r\nchar *mtype = "";\r\nchar mbuf[8];\r\nchar *cbl = "(40 wire cable)";\r\nstatic const char *types[5] = {\r\n"RAID0", "RAID1", "RAID 0+1", "JBOD", "DISK"\r\n};\r\nif (buf[52] > 4)\r\nreturn;\r\nata_id_c_string((u16 *)buf, id, 0, 41);\r\nif (buf[51]) {\r\nmode = ffs(buf[51]);\r\nmtype = "UDMA";\r\n} else if (buf[49]) {\r\nmode = ffs(buf[49]);\r\nmtype = "MWDMA";\r\n}\r\nif (buf[76])\r\ncbl = "";\r\nif (mode)\r\nsnprintf(mbuf, 8, "%5s%d", mtype, mode - 1);\r\nelse\r\nstrcpy(mbuf, "PIO");\r\nif (buf[52] == 4)\r\nprintk(KERN_INFO "%d: %-6s %-8s %s %s\n",\r\nn, mbuf, types[buf[52]], id, cbl);\r\nelse\r\nprintk(KERN_INFO "%d: %-6s %-8s Volume: %1d %s %s\n",\r\nn, mbuf, types[buf[52]], buf[53], id, cbl);\r\nif (buf[125] < 100)\r\nprintk(KERN_INFO "%d: Rebuilding: %d%%\n", n, buf[125]);\r\n}\r\nstatic u8 *it821x_firmware_command(struct ata_port *ap, u8 cmd, int len)\r\n{\r\nu8 status;\r\nint n = 0;\r\nu16 *buf = kmalloc(len, GFP_KERNEL);\r\nif (buf == NULL) {\r\nprintk(KERN_ERR "it821x_firmware_command: Out of memory\n");\r\nreturn NULL;\r\n}\r\nap->ctl |= ATA_NIEN;\r\niowrite8(ap->ctl, ap->ioaddr.ctl_addr);\r\nata_wait_idle(ap);\r\niowrite8(ATA_DEVICE_OBS, ap->ioaddr.device_addr);\r\niowrite8(cmd, ap->ioaddr.command_addr);\r\nudelay(1);\r\nwhile(n++ < 10) {\r\nstatus = ioread8(ap->ioaddr.status_addr);\r\nif (status & ATA_ERR) {\r\nkfree(buf);\r\nprintk(KERN_ERR "it821x_firmware_command: rejected\n");\r\nreturn NULL;\r\n}\r\nif (status & ATA_DRQ) {\r\nioread16_rep(ap->ioaddr.data_addr, buf, len/2);\r\nreturn (u8 *)buf;\r\n}\r\nmdelay(1);\r\n}\r\nkfree(buf);\r\nprintk(KERN_ERR "it821x_firmware_command: timeout\n");\r\nreturn NULL;\r\n}\r\nstatic void it821x_probe_firmware(struct ata_port *ap)\r\n{\r\nu8 *buf;\r\nint i;\r\nbuf = it821x_firmware_command(ap, 0xFA, 512);\r\nif (buf != NULL) {\r\nprintk(KERN_INFO "pata_it821x: Firmware %02X/%02X/%02X%02X\n",\r\nbuf[505],\r\nbuf[506],\r\nbuf[507],\r\nbuf[508]);\r\nfor (i = 0; i < 4; i++)\r\nit821x_display_disk(i, buf + 128 * i);\r\nkfree(buf);\r\n}\r\n}\r\nstatic int it821x_port_start(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstruct it821x_dev *itdev;\r\nu8 conf;\r\nint ret = ata_bmdma_port_start(ap);\r\nif (ret < 0)\r\nreturn ret;\r\nitdev = devm_kzalloc(&pdev->dev, sizeof(struct it821x_dev), GFP_KERNEL);\r\nif (itdev == NULL)\r\nreturn -ENOMEM;\r\nap->private_data = itdev;\r\npci_read_config_byte(pdev, 0x50, &conf);\r\nif (conf & 1) {\r\nitdev->smart = 1;\r\nif (ap->port_no == 0)\r\nit821x_probe_firmware(ap);\r\n}\r\nif (conf & (1 << (1 + ap->port_no)))\r\nitdev->clock_mode = ATA_50;\r\nelse\r\nitdev->clock_mode = ATA_66;\r\nitdev->want[0][1] = ATA_ANY;\r\nitdev->want[1][1] = ATA_ANY;\r\nitdev->last_device = -1;\r\nif (pdev->revision == 0x10) {\r\nitdev->timing10 = 1;\r\nif (!itdev->smart)\r\nprintk(KERN_WARNING DRV_NAME": Revision 0x10, workarounds activated.\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int it821x_rdc_cable(struct ata_port *ap)\r\n{\r\nu16 r40;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\npci_read_config_word(pdev, 0x40, &r40);\r\nif (r40 & (1 << (2 + ap->port_no)))\r\nreturn ATA_CBL_PATA40;\r\nreturn ATA_CBL_PATA80;\r\n}\r\nstatic void it821x_disable_raid(struct pci_dev *pdev)\r\n{\r\nif (pdev->vendor != PCI_VENDOR_ID_ITE ||\r\npdev->device != PCI_DEVICE_ID_ITE_8212)\r\nreturn;\r\npci_write_config_byte(pdev, 0x5E, 0x01);\r\npci_write_config_byte(pdev, 0x50, 0x00);\r\npci_write_config_word(pdev, PCI_COMMAND,\r\nPCI_COMMAND_PARITY | PCI_COMMAND_IO |\r\nPCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\r\npci_write_config_word(pdev, 0x40, 0xA0F3);\r\npci_write_config_dword(pdev,0x4C, 0x02040204);\r\npci_write_config_byte(pdev, 0x42, 0x36);\r\npci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x20);\r\n}\r\nstatic int it821x_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nu8 conf;\r\nstatic const struct ata_port_info info_smart = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA6,\r\n.port_ops = &it821x_smart_port_ops\r\n};\r\nstatic const struct ata_port_info info_passthru = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA6,\r\n.port_ops = &it821x_passthru_port_ops\r\n};\r\nstatic const struct ata_port_info info_rdc = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA6,\r\n.port_ops = &it821x_rdc_port_ops\r\n};\r\nstatic const struct ata_port_info info_rdc_11 = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.port_ops = &it821x_rdc_port_ops\r\n};\r\nconst struct ata_port_info *ppi[] = { NULL, NULL };\r\nstatic char *mode[2] = { "pass through", "smart" };\r\nint rc;\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nif (pdev->vendor == PCI_VENDOR_ID_RDC) {\r\nif (pdev->revision == 0x11)\r\nppi[0] = &info_rdc_11;\r\nelse\r\nppi[0] = &info_rdc;\r\n} else {\r\nif (it8212_noraid) {\r\nprintk(KERN_INFO DRV_NAME ": forcing bypass mode.\n");\r\nit821x_disable_raid(pdev);\r\n}\r\npci_read_config_byte(pdev, 0x50, &conf);\r\nconf &= 1;\r\nprintk(KERN_INFO DRV_NAME": controller in %s mode.\n",\r\nmode[conf]);\r\nif (conf == 0)\r\nppi[0] = &info_passthru;\r\nelse\r\nppi[0] = &info_smart;\r\n}\r\nreturn ata_pci_bmdma_init_one(pdev, ppi, &it821x_sht, NULL, 0);\r\n}\r\nstatic int it821x_reinit_one(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(&pdev->dev);\r\nint rc;\r\nrc = ata_pci_device_do_resume(pdev);\r\nif (rc)\r\nreturn rc;\r\nif (it8212_noraid)\r\nit821x_disable_raid(pdev);\r\nata_host_resume(host);\r\nreturn rc;\r\n}\r\nstatic int __init it821x_init(void)\r\n{\r\nreturn pci_register_driver(&it821x_pci_driver);\r\n}\r\nstatic void __exit it821x_exit(void)\r\n{\r\npci_unregister_driver(&it821x_pci_driver);\r\n}
