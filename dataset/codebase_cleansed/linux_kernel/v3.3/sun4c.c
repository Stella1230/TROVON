static void __init sun4c_flush_all(void)\r\n{\r\nunsigned long begin, end;\r\nif (sun4c_vacinfo.on)\r\npanic("SUN4C: AIEEE, trying to invalidate vac while it is on.");\r\nbegin = AC_CACHETAGS;\r\nend = (AC_CACHETAGS + SUN4C_VAC_SIZE);\r\nwhile (begin < end) {\r\n__asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :\r\n"r" (begin), "i" (ASI_CONTROL));\r\nbegin += sun4c_vacinfo.linesize;\r\n}\r\n}\r\nstatic void sun4c_flush_context_hw(void)\r\n{\r\nunsigned long end = SUN4C_VAC_SIZE;\r\n__asm__ __volatile__(\r\n"1: addcc %0, -4096, %0\n\t"\r\n" bne 1b\n\t"\r\n" sta %%g0, [%0] %2"\r\n: "=&r" (end)\r\n: "0" (end), "i" (ASI_HWFLUSHCONTEXT)\r\n: "cc");\r\n}\r\nstatic void sun4c_flush_segment_hw(unsigned long addr)\r\n{\r\nif (sun4c_get_segmap(addr) != invalid_segment) {\r\nunsigned long vac_size = SUN4C_VAC_SIZE;\r\n__asm__ __volatile__(\r\n"1: addcc %0, -4096, %0\n\t"\r\n" bne 1b\n\t"\r\n" sta %%g0, [%2 + %0] %3"\r\n: "=&r" (vac_size)\r\n: "0" (vac_size), "r" (addr), "i" (ASI_HWFLUSHSEG)\r\n: "cc");\r\n}\r\n}\r\nstatic void sun4c_flush_page_hw(unsigned long addr)\r\n{\r\naddr &= PAGE_MASK;\r\nif ((int)sun4c_get_pte(addr) < 0)\r\n__asm__ __volatile__("sta %%g0, [%0] %1"\r\n: : "r" (addr), "i" (ASI_HWFLUSHPAGE));\r\n}\r\nstatic void sun4c_flush_context_sw(void)\r\n{\r\nunsigned long nbytes = SUN4C_VAC_SIZE;\r\nunsigned long lsize = sun4c_vacinfo.linesize;\r\n__asm__ __volatile__(\r\n"add %2, %2, %%g1\n\t"\r\n"add %2, %%g1, %%g2\n\t"\r\n"add %2, %%g2, %%g3\n\t"\r\n"add %2, %%g3, %%g4\n\t"\r\n"add %2, %%g4, %%g5\n\t"\r\n"add %2, %%g5, %%o4\n\t"\r\n"add %2, %%o4, %%o5\n"\r\n"1:\n\t"\r\n"subcc %0, %%o5, %0\n\t"\r\n"sta %%g0, [%0] %3\n\t"\r\n"sta %%g0, [%0 + %2] %3\n\t"\r\n"sta %%g0, [%0 + %%g1] %3\n\t"\r\n"sta %%g0, [%0 + %%g2] %3\n\t"\r\n"sta %%g0, [%0 + %%g3] %3\n\t"\r\n"sta %%g0, [%0 + %%g4] %3\n\t"\r\n"sta %%g0, [%0 + %%g5] %3\n\t"\r\n"bg 1b\n\t"\r\n" sta %%g0, [%1 + %%o4] %3\n"\r\n: "=&r" (nbytes)\r\n: "0" (nbytes), "r" (lsize), "i" (ASI_FLUSHCTX)\r\n: "g1", "g2", "g3", "g4", "g5", "o4", "o5", "cc");\r\n}\r\nstatic void sun4c_flush_segment_sw(unsigned long addr)\r\n{\r\nif (sun4c_get_segmap(addr) != invalid_segment) {\r\nunsigned long nbytes = SUN4C_VAC_SIZE;\r\nunsigned long lsize = sun4c_vacinfo.linesize;\r\n__asm__ __volatile__(\r\n"add %2, %2, %%g1\n\t"\r\n"add %2, %%g1, %%g2\n\t"\r\n"add %2, %%g2, %%g3\n\t"\r\n"add %2, %%g3, %%g4\n\t"\r\n"add %2, %%g4, %%g5\n\t"\r\n"add %2, %%g5, %%o4\n\t"\r\n"add %2, %%o4, %%o5\n"\r\n"1:\n\t"\r\n"subcc %1, %%o5, %1\n\t"\r\n"sta %%g0, [%0] %6\n\t"\r\n"sta %%g0, [%0 + %2] %6\n\t"\r\n"sta %%g0, [%0 + %%g1] %6\n\t"\r\n"sta %%g0, [%0 + %%g2] %6\n\t"\r\n"sta %%g0, [%0 + %%g3] %6\n\t"\r\n"sta %%g0, [%0 + %%g4] %6\n\t"\r\n"sta %%g0, [%0 + %%g5] %6\n\t"\r\n"sta %%g0, [%0 + %%o4] %6\n\t"\r\n"bg 1b\n\t"\r\n" add %0, %%o5, %0\n"\r\n: "=&r" (addr), "=&r" (nbytes), "=&r" (lsize)\r\n: "0" (addr), "1" (nbytes), "2" (lsize),\r\n"i" (ASI_FLUSHSEG)\r\n: "g1", "g2", "g3", "g4", "g5", "o4", "o5", "cc");\r\n}\r\n}\r\nstatic void sun4c_flush_page_sw(unsigned long addr)\r\n{\r\naddr &= PAGE_MASK;\r\nif ((sun4c_get_pte(addr) & (_SUN4C_PAGE_NOCACHE | _SUN4C_PAGE_VALID)) ==\r\n_SUN4C_PAGE_VALID) {\r\nunsigned long left = PAGE_SIZE;\r\nunsigned long lsize = sun4c_vacinfo.linesize;\r\n__asm__ __volatile__(\r\n"add %2, %2, %%g1\n\t"\r\n"add %2, %%g1, %%g2\n\t"\r\n"add %2, %%g2, %%g3\n\t"\r\n"add %2, %%g3, %%g4\n\t"\r\n"add %2, %%g4, %%g5\n\t"\r\n"add %2, %%g5, %%o4\n\t"\r\n"add %2, %%o4, %%o5\n"\r\n"1:\n\t"\r\n"subcc %1, %%o5, %1\n\t"\r\n"sta %%g0, [%0] %6\n\t"\r\n"sta %%g0, [%0 + %2] %6\n\t"\r\n"sta %%g0, [%0 + %%g1] %6\n\t"\r\n"sta %%g0, [%0 + %%g2] %6\n\t"\r\n"sta %%g0, [%0 + %%g3] %6\n\t"\r\n"sta %%g0, [%0 + %%g4] %6\n\t"\r\n"sta %%g0, [%0 + %%g5] %6\n\t"\r\n"sta %%g0, [%0 + %%o4] %6\n\t"\r\n"bg 1b\n\t"\r\n" add %0, %%o5, %0\n"\r\n: "=&r" (addr), "=&r" (left), "=&r" (lsize)\r\n: "0" (addr), "1" (left), "2" (lsize),\r\n"i" (ASI_FLUSHPG)\r\n: "g1", "g2", "g3", "g4", "g5", "o4", "o5", "cc");\r\n}\r\n}\r\nvoid sun4c_complete_all_stores(void)\r\n{\r\nvolatile int _unused;\r\n_unused = sun4c_get_context();\r\nsun4c_set_context(_unused);\r\n_unused = get_auxio();\r\n}\r\nstatic inline void sun4c_init_clean_segmap(unsigned char pseg)\r\n{\r\nunsigned long vaddr;\r\nsun4c_put_segmap(0, pseg);\r\nfor (vaddr = 0; vaddr < SUN4C_REAL_PGDIR_SIZE; vaddr += PAGE_SIZE)\r\nsun4c_put_pte(vaddr, 0);\r\nsun4c_put_segmap(0, invalid_segment);\r\n}\r\nstatic inline void sun4c_init_clean_mmu(unsigned long kernel_end)\r\n{\r\nunsigned long vaddr;\r\nunsigned char savectx, ctx;\r\nsavectx = sun4c_get_context();\r\nfor (ctx = 0; ctx < num_contexts; ctx++) {\r\nsun4c_set_context(ctx);\r\nfor (vaddr = 0; vaddr < 0x20000000; vaddr += SUN4C_REAL_PGDIR_SIZE)\r\nsun4c_put_segmap(vaddr, invalid_segment);\r\nfor (vaddr = 0xe0000000; vaddr < KERNBASE; vaddr += SUN4C_REAL_PGDIR_SIZE)\r\nsun4c_put_segmap(vaddr, invalid_segment);\r\nfor (vaddr = kernel_end; vaddr < KADB_DEBUGGER_BEGVM; vaddr += SUN4C_REAL_PGDIR_SIZE)\r\nsun4c_put_segmap(vaddr, invalid_segment);\r\nfor (vaddr = LINUX_OPPROM_ENDVM; vaddr; vaddr += SUN4C_REAL_PGDIR_SIZE)\r\nsun4c_put_segmap(vaddr, invalid_segment);\r\n}\r\nsun4c_set_context(savectx);\r\n}\r\nvoid __init sun4c_probe_vac(void)\r\n{\r\nsun4c_disable_vac();\r\nif ((idprom->id_machtype == (SM_SUN4C | SM_4C_SS1)) ||\r\n(idprom->id_machtype == (SM_SUN4C | SM_4C_SS1PLUS))) {\r\nsun4c_vacinfo.num_bytes = 65536;\r\nsun4c_vacinfo.linesize = 16;\r\n} else {\r\nsun4c_vacinfo.num_bytes =\r\nprom_getintdefault(prom_root_node, "vac-size", 65536);\r\nsun4c_vacinfo.linesize =\r\nprom_getintdefault(prom_root_node, "vac-linesize", 16);\r\n}\r\nsun4c_vacinfo.do_hwflushes =\r\nprom_getintdefault(prom_root_node, "vac-hwflush", 0);\r\nif (sun4c_vacinfo.do_hwflushes == 0)\r\nsun4c_vacinfo.do_hwflushes =\r\nprom_getintdefault(prom_root_node, "vac_hwflush", 0);\r\nif (sun4c_vacinfo.num_bytes != 65536) {\r\nprom_printf("WEIRD Sun4C VAC cache size, "\r\n"tell sparclinux@vger.kernel.org");\r\nprom_halt();\r\n}\r\nswitch (sun4c_vacinfo.linesize) {\r\ncase 16:\r\nsun4c_vacinfo.log2lsize = 4;\r\nbreak;\r\ncase 32:\r\nsun4c_vacinfo.log2lsize = 5;\r\nbreak;\r\ndefault:\r\nprom_printf("probe_vac: Didn't expect vac-linesize of %d, halting\n",\r\nsun4c_vacinfo.linesize);\r\nprom_halt();\r\n}\r\nsun4c_flush_all();\r\nsun4c_enable_vac();\r\n}\r\nstatic void __init patch_kernel_fault_handler(void)\r\n{\r\nunsigned long *iaddr, *daddr;\r\nswitch (num_segmaps) {\r\ncase 128:\r\nbreak;\r\ncase 256:\r\nPATCH_INSN(invalid_segment_patch1_ff,\r\ninvalid_segment_patch1);\r\nPATCH_INSN(invalid_segment_patch2_ff,\r\ninvalid_segment_patch2);\r\nbreak;\r\ncase 512:\r\nPATCH_INSN(invalid_segment_patch1_1ff,\r\ninvalid_segment_patch1);\r\nPATCH_INSN(invalid_segment_patch2_1ff,\r\ninvalid_segment_patch2);\r\nbreak;\r\ndefault:\r\nprom_printf("Unhandled number of segmaps: %d\n",\r\nnum_segmaps);\r\nprom_halt();\r\n}\r\nswitch (num_contexts) {\r\ncase 8:\r\nbreak;\r\ncase 16:\r\nPATCH_INSN(num_context_patch1_16,\r\nnum_context_patch1);\r\nbreak;\r\ndefault:\r\nprom_printf("Unhandled number of contexts: %d\n",\r\nnum_contexts);\r\nprom_halt();\r\n}\r\nif (sun4c_vacinfo.do_hwflushes != 0) {\r\nPATCH_INSN(vac_hwflush_patch1_on, vac_hwflush_patch1);\r\nPATCH_INSN(vac_hwflush_patch2_on, vac_hwflush_patch2);\r\n} else {\r\nswitch (sun4c_vacinfo.linesize) {\r\ncase 16:\r\nbreak;\r\ncase 32:\r\nPATCH_INSN(vac_linesize_patch_32, vac_linesize_patch);\r\nbreak;\r\ndefault:\r\nprom_printf("Impossible VAC linesize %d, halting...\n",\r\nsun4c_vacinfo.linesize);\r\nprom_halt();\r\n}\r\n}\r\n}\r\nstatic void __init sun4c_probe_mmu(void)\r\n{\r\nif ((idprom->id_machtype == (SM_SUN4C | SM_4C_SS1)) ||\r\n(idprom->id_machtype == (SM_SUN4C | SM_4C_SS1PLUS))) {\r\nnum_segmaps = 128;\r\nnum_contexts = 8;\r\n} else {\r\nnum_segmaps =\r\nprom_getintdefault(prom_root_node, "mmu-npmg", 128);\r\nnum_contexts =\r\nprom_getintdefault(prom_root_node, "mmu-nctx", 0x8);\r\n}\r\npatch_kernel_fault_handler();\r\n}\r\nvoid __init sun4c_probe_memerr_reg(void)\r\n{\r\nphandle node;\r\nstruct linux_prom_registers regs[1];\r\nnode = prom_getchild(prom_root_node);\r\nnode = prom_searchsiblings(prom_root_node, "memory-error");\r\nif (!node)\r\nreturn;\r\nif (prom_getproperty(node, "reg", (char *)regs, sizeof(regs)) <= 0)\r\nreturn;\r\nsun4c_memerr_reg = ioremap(regs[0].phys_addr, regs[0].reg_size);\r\n}\r\nstatic inline void sun4c_init_ss2_cache_bug(void)\r\n{\r\nif ((idprom->id_machtype == (SM_SUN4C | SM_4C_SS2)) ||\r\n(idprom->id_machtype == (SM_SUN4C | SM_4C_IPX)) ||\r\n(idprom->id_machtype == (SM_SUN4C | SM_4C_ELC))) {\r\nprintk("SS2 cache bug detected, uncaching trap table page\n");\r\nsun4c_flush_page((unsigned int) &_start);\r\nsun4c_put_pte(((unsigned long) &_start),\r\n(sun4c_get_pte((unsigned long) &_start) | _SUN4C_PAGE_NOCACHE));\r\n}\r\n}\r\nstatic int sun4c_map_dma_area(struct device *dev, dma_addr_t *pba, unsigned long va,\r\nunsigned long addr, int len)\r\n{\r\nunsigned long page, end;\r\n*pba = addr;\r\nend = PAGE_ALIGN((addr + len));\r\nwhile (addr < end) {\r\npage = va;\r\nsun4c_flush_page(page);\r\npage -= PAGE_OFFSET;\r\npage >>= PAGE_SHIFT;\r\npage |= (_SUN4C_PAGE_VALID | _SUN4C_PAGE_DIRTY |\r\n_SUN4C_PAGE_NOCACHE | _SUN4C_PAGE_PRIV);\r\nsun4c_put_pte(addr, page);\r\naddr += PAGE_SIZE;\r\nva += PAGE_SIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sun4c_unmap_dma_area(struct device *dev, unsigned long busa, int len)\r\n{\r\n}\r\nstatic void __init sun4c_init_mmu_entry_pool(void)\r\n{\r\nint i;\r\nfor (i=0; i < SUN4C_MAX_SEGMAPS; i++) {\r\nmmu_entry_pool[i].pseg = i;\r\nmmu_entry_pool[i].next = NULL;\r\nmmu_entry_pool[i].prev = NULL;\r\nmmu_entry_pool[i].vaddr = 0;\r\nmmu_entry_pool[i].locked = 0;\r\nmmu_entry_pool[i].ctx = 0;\r\nmmu_entry_pool[i].lru_next = NULL;\r\nmmu_entry_pool[i].lru_prev = NULL;\r\n}\r\nmmu_entry_pool[invalid_segment].locked = 1;\r\n}\r\nstatic inline void fix_permissions(unsigned long vaddr, unsigned long bits_on,\r\nunsigned long bits_off)\r\n{\r\nunsigned long start, end;\r\nend = vaddr + SUN4C_REAL_PGDIR_SIZE;\r\nfor (start = vaddr; start < end; start += PAGE_SIZE)\r\nif (sun4c_get_pte(start) & _SUN4C_PAGE_VALID)\r\nsun4c_put_pte(start, (sun4c_get_pte(start) | bits_on) &\r\n~bits_off);\r\n}\r\nstatic inline void sun4c_init_map_kernelprom(unsigned long kernel_end)\r\n{\r\nunsigned long vaddr;\r\nunsigned char pseg, ctx;\r\nfor (vaddr = KADB_DEBUGGER_BEGVM;\r\nvaddr < LINUX_OPPROM_ENDVM;\r\nvaddr += SUN4C_REAL_PGDIR_SIZE) {\r\npseg = sun4c_get_segmap(vaddr);\r\nif (pseg != invalid_segment) {\r\nmmu_entry_pool[pseg].locked = 1;\r\nfor (ctx = 0; ctx < num_contexts; ctx++)\r\nprom_putsegment(ctx, vaddr, pseg);\r\nfix_permissions(vaddr, _SUN4C_PAGE_PRIV, 0);\r\n}\r\n}\r\nfor (vaddr = KERNBASE; vaddr < kernel_end; vaddr += SUN4C_REAL_PGDIR_SIZE) {\r\npseg = sun4c_get_segmap(vaddr);\r\nmmu_entry_pool[pseg].locked = 1;\r\nfor (ctx = 0; ctx < num_contexts; ctx++)\r\nprom_putsegment(ctx, vaddr, pseg);\r\nfix_permissions(vaddr, _SUN4C_PAGE_PRIV, _SUN4C_PAGE_NOCACHE);\r\n}\r\n}\r\nstatic void __init sun4c_init_lock_area(unsigned long start, unsigned long end)\r\n{\r\nint i, ctx;\r\nwhile (start < end) {\r\nfor (i = 0; i < invalid_segment; i++)\r\nif (!mmu_entry_pool[i].locked)\r\nbreak;\r\nmmu_entry_pool[i].locked = 1;\r\nsun4c_init_clean_segmap(i);\r\nfor (ctx = 0; ctx < num_contexts; ctx++)\r\nprom_putsegment(ctx, start, mmu_entry_pool[i].pseg);\r\nstart += SUN4C_REAL_PGDIR_SIZE;\r\n}\r\n}\r\nstatic inline void sun4c_init_rings(void)\r\n{\r\nint i;\r\nfor (i = 0; i < SUN4C_MAX_CONTEXTS; i++) {\r\nsun4c_context_ring[i].ringhd.next =\r\nsun4c_context_ring[i].ringhd.prev =\r\n&sun4c_context_ring[i].ringhd;\r\nsun4c_context_ring[i].num_entries = 0;\r\n}\r\nsun4c_ufree_ring.ringhd.next = sun4c_ufree_ring.ringhd.prev =\r\n&sun4c_ufree_ring.ringhd;\r\nsun4c_ufree_ring.num_entries = 0;\r\nsun4c_ulru_ring.ringhd.lru_next = sun4c_ulru_ring.ringhd.lru_prev =\r\n&sun4c_ulru_ring.ringhd;\r\nsun4c_ulru_ring.num_entries = 0;\r\nsun4c_kernel_ring.ringhd.next = sun4c_kernel_ring.ringhd.prev =\r\n&sun4c_kernel_ring.ringhd;\r\nsun4c_kernel_ring.num_entries = 0;\r\nsun4c_kfree_ring.ringhd.next = sun4c_kfree_ring.ringhd.prev =\r\n&sun4c_kfree_ring.ringhd;\r\nsun4c_kfree_ring.num_entries = 0;\r\n}\r\nstatic void add_ring(struct sun4c_mmu_ring *ring,\r\nstruct sun4c_mmu_entry *entry)\r\n{\r\nstruct sun4c_mmu_entry *head = &ring->ringhd;\r\nentry->prev = head;\r\n(entry->next = head->next)->prev = entry;\r\nhead->next = entry;\r\nring->num_entries++;\r\n}\r\nstatic inline void add_lru(struct sun4c_mmu_entry *entry)\r\n{\r\nstruct sun4c_mmu_ring *ring = &sun4c_ulru_ring;\r\nstruct sun4c_mmu_entry *head = &ring->ringhd;\r\nentry->lru_next = head;\r\n(entry->lru_prev = head->lru_prev)->lru_next = entry;\r\nhead->lru_prev = entry;\r\n}\r\nstatic void add_ring_ordered(struct sun4c_mmu_ring *ring,\r\nstruct sun4c_mmu_entry *entry)\r\n{\r\nstruct sun4c_mmu_entry *head = &ring->ringhd;\r\nunsigned long addr = entry->vaddr;\r\nwhile ((head->next != &ring->ringhd) && (head->next->vaddr < addr))\r\nhead = head->next;\r\nentry->prev = head;\r\n(entry->next = head->next)->prev = entry;\r\nhead->next = entry;\r\nring->num_entries++;\r\nadd_lru(entry);\r\n}\r\nstatic inline void remove_ring(struct sun4c_mmu_ring *ring,\r\nstruct sun4c_mmu_entry *entry)\r\n{\r\nstruct sun4c_mmu_entry *next = entry->next;\r\n(next->prev = entry->prev)->next = next;\r\nring->num_entries--;\r\n}\r\nstatic void remove_lru(struct sun4c_mmu_entry *entry)\r\n{\r\nstruct sun4c_mmu_entry *next = entry->lru_next;\r\n(next->lru_prev = entry->lru_prev)->lru_next = next;\r\n}\r\nstatic void free_user_entry(int ctx, struct sun4c_mmu_entry *entry)\r\n{\r\nremove_ring(sun4c_context_ring+ctx, entry);\r\nremove_lru(entry);\r\nadd_ring(&sun4c_ufree_ring, entry);\r\n}\r\nstatic void free_kernel_entry(struct sun4c_mmu_entry *entry,\r\nstruct sun4c_mmu_ring *ring)\r\n{\r\nremove_ring(ring, entry);\r\nadd_ring(&sun4c_kfree_ring, entry);\r\n}\r\nstatic void __init sun4c_init_fill_kernel_ring(int howmany)\r\n{\r\nint i;\r\nwhile (howmany) {\r\nfor (i = 0; i < invalid_segment; i++)\r\nif (!mmu_entry_pool[i].locked)\r\nbreak;\r\nmmu_entry_pool[i].locked = 1;\r\nsun4c_init_clean_segmap(i);\r\nadd_ring(&sun4c_kfree_ring, &mmu_entry_pool[i]);\r\nhowmany--;\r\n}\r\n}\r\nstatic void __init sun4c_init_fill_user_ring(void)\r\n{\r\nint i;\r\nfor (i = 0; i < invalid_segment; i++) {\r\nif (mmu_entry_pool[i].locked)\r\ncontinue;\r\nsun4c_init_clean_segmap(i);\r\nadd_ring(&sun4c_ufree_ring, &mmu_entry_pool[i]);\r\n}\r\n}\r\nstatic void sun4c_kernel_unmap(struct sun4c_mmu_entry *kentry)\r\n{\r\nint savectx, ctx;\r\nsavectx = sun4c_get_context();\r\nfor (ctx = 0; ctx < num_contexts; ctx++) {\r\nsun4c_set_context(ctx);\r\nsun4c_put_segmap(kentry->vaddr, invalid_segment);\r\n}\r\nsun4c_set_context(savectx);\r\n}\r\nstatic void sun4c_kernel_map(struct sun4c_mmu_entry *kentry)\r\n{\r\nint savectx, ctx;\r\nsavectx = sun4c_get_context();\r\nfor (ctx = 0; ctx < num_contexts; ctx++) {\r\nsun4c_set_context(ctx);\r\nsun4c_put_segmap(kentry->vaddr, kentry->pseg);\r\n}\r\nsun4c_set_context(savectx);\r\n}\r\nstatic void sun4c_demap_context(struct sun4c_mmu_ring *crp, unsigned char ctx)\r\n{\r\nstruct sun4c_mmu_entry *head = &crp->ringhd;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (head->next != head) {\r\nstruct sun4c_mmu_entry *entry = head->next;\r\nint savectx = sun4c_get_context();\r\nflush_user_windows();\r\nsun4c_set_context(ctx);\r\nsun4c_flush_context();\r\ndo {\r\nstruct sun4c_mmu_entry *next = entry->next;\r\nsun4c_user_unmap(entry);\r\nfree_user_entry(ctx, entry);\r\nentry = next;\r\n} while (entry != head);\r\nsun4c_set_context(savectx);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic struct sun4c_mmu_entry *sun4c_kernel_strategy(void)\r\n{\r\nstruct sun4c_mmu_entry *this_entry;\r\nif (sun4c_kfree_ring.num_entries) {\r\nthis_entry = sun4c_kfree_ring.ringhd.next;\r\nreturn this_entry;\r\n}\r\nthis_entry = sun4c_kernel_ring.ringhd.prev;\r\nsun4c_flush_segment(this_entry->vaddr);\r\nsun4c_kernel_unmap(this_entry);\r\nfree_kernel_entry(this_entry, &sun4c_kernel_ring);\r\nthis_entry = sun4c_kfree_ring.ringhd.next;\r\nreturn this_entry;\r\n}\r\nstatic struct sun4c_mmu_entry *sun4c_user_strategy(void)\r\n{\r\nstruct sun4c_mmu_entry *entry;\r\nunsigned char ctx;\r\nint savectx;\r\nif (sun4c_ufree_ring.num_entries) {\r\nentry = sun4c_ufree_ring.ringhd.next;\r\ngoto unlink_out;\r\n}\r\nif (sun4c_user_taken_entries) {\r\nentry = sun4c_kernel_strategy();\r\nsun4c_user_taken_entries--;\r\ngoto kunlink_out;\r\n}\r\nentry = sun4c_ulru_ring.ringhd.lru_next;\r\nctx = entry->ctx;\r\nsavectx = sun4c_get_context();\r\nflush_user_windows();\r\nsun4c_set_context(ctx);\r\nsun4c_flush_segment(entry->vaddr);\r\nsun4c_user_unmap(entry);\r\nremove_ring(sun4c_context_ring + ctx, entry);\r\nremove_lru(entry);\r\nsun4c_set_context(savectx);\r\nreturn entry;\r\nunlink_out:\r\nremove_ring(&sun4c_ufree_ring, entry);\r\nreturn entry;\r\nkunlink_out:\r\nremove_ring(&sun4c_kfree_ring, entry);\r\nreturn entry;\r\n}\r\nvoid sun4c_grow_kernel_ring(void)\r\n{\r\nstruct sun4c_mmu_entry *entry;\r\nif (sun4c_user_taken_entries >= max_user_taken_entries)\r\nreturn;\r\nif (sun4c_ufree_ring.num_entries) {\r\nentry = sun4c_ufree_ring.ringhd.next;\r\nremove_ring(&sun4c_ufree_ring, entry);\r\nadd_ring(&sun4c_kfree_ring, entry);\r\nsun4c_user_taken_entries++;\r\n}\r\n}\r\nstatic void get_locked_segment(unsigned long addr)\r\n{\r\nstruct sun4c_mmu_entry *stolen;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\naddr &= SUN4C_REAL_PGDIR_MASK;\r\nstolen = sun4c_user_strategy();\r\nmax_user_taken_entries--;\r\nstolen->vaddr = addr;\r\nflush_user_windows();\r\nsun4c_kernel_map(stolen);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void free_locked_segment(unsigned long addr)\r\n{\r\nstruct sun4c_mmu_entry *entry;\r\nunsigned long flags;\r\nunsigned char pseg;\r\nlocal_irq_save(flags);\r\naddr &= SUN4C_REAL_PGDIR_MASK;\r\npseg = sun4c_get_segmap(addr);\r\nentry = &mmu_entry_pool[pseg];\r\nflush_user_windows();\r\nsun4c_flush_segment(addr);\r\nsun4c_kernel_unmap(entry);\r\nadd_ring(&sun4c_ufree_ring, entry);\r\nmax_user_taken_entries++;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic inline void garbage_collect(int entry)\r\n{\r\nint start, end;\r\nentry &= ~31;\r\nstart = entry;\r\nfor (end = (start + 32); start < end; start++)\r\nif (sun4c_bucket[start] != BUCKET_EMPTY)\r\nreturn;\r\nfree_locked_segment(BUCKET_ADDR(entry));\r\n}\r\nstatic struct thread_info *sun4c_alloc_thread_info_node(int node)\r\n{\r\nunsigned long addr, pages;\r\nint entry;\r\npages = __get_free_pages(GFP_KERNEL, THREAD_INFO_ORDER);\r\nif (!pages)\r\nreturn NULL;\r\nfor (entry = sun4c_lowbucket_avail; entry < NR_TASK_BUCKETS; entry++)\r\nif (sun4c_bucket[entry] == BUCKET_EMPTY)\r\nbreak;\r\nif (entry == NR_TASK_BUCKETS) {\r\nfree_pages(pages, THREAD_INFO_ORDER);\r\nreturn NULL;\r\n}\r\nif (entry >= sun4c_lowbucket_avail)\r\nsun4c_lowbucket_avail = entry + 1;\r\naddr = BUCKET_ADDR(entry);\r\nsun4c_bucket[entry] = (union task_union *) addr;\r\nif(sun4c_get_segmap(addr) == invalid_segment)\r\nget_locked_segment(addr);\r\nsun4c_flush_page(pages);\r\nsun4c_flush_page(pages + PAGE_SIZE);\r\nsun4c_put_pte(addr, BUCKET_PTE(pages));\r\nsun4c_put_pte(addr + PAGE_SIZE, BUCKET_PTE(pages + PAGE_SIZE));\r\n#ifdef CONFIG_DEBUG_STACK_USAGE\r\nmemset((void *)addr, 0, PAGE_SIZE << THREAD_INFO_ORDER);\r\n#endif\r\nreturn (struct thread_info *) addr;\r\n}\r\nstatic void sun4c_free_thread_info(struct thread_info *ti)\r\n{\r\nunsigned long tiaddr = (unsigned long) ti;\r\nunsigned long pages = BUCKET_PTE_PAGE(sun4c_get_pte(tiaddr));\r\nint entry = BUCKET_NUM(tiaddr);\r\nsun4c_flush_page(tiaddr);\r\nsun4c_flush_page(tiaddr + PAGE_SIZE);\r\nsun4c_put_pte(tiaddr, 0);\r\nsun4c_put_pte(tiaddr + PAGE_SIZE, 0);\r\nsun4c_bucket[entry] = BUCKET_EMPTY;\r\nif (entry < sun4c_lowbucket_avail)\r\nsun4c_lowbucket_avail = entry;\r\nfree_pages(pages, THREAD_INFO_ORDER);\r\ngarbage_collect(entry);\r\n}\r\nstatic void __init sun4c_init_buckets(void)\r\n{\r\nint entry;\r\nif (sizeof(union thread_union) != (PAGE_SIZE << THREAD_INFO_ORDER)) {\r\nextern void thread_info_size_is_bolixed_pete(void);\r\nthread_info_size_is_bolixed_pete();\r\n}\r\nfor (entry = 0; entry < NR_TASK_BUCKETS; entry++)\r\nsun4c_bucket[entry] = BUCKET_EMPTY;\r\nsun4c_lowbucket_avail = 0;\r\n}\r\nstatic char *sun4c_lockarea(char *vaddr, unsigned long size)\r\n{\r\nunsigned long base, scan;\r\nunsigned long npages;\r\nunsigned long vpage;\r\nunsigned long pte;\r\nunsigned long apage;\r\nunsigned long high;\r\nunsigned long flags;\r\nnpages = (((unsigned long)vaddr & ~PAGE_MASK) +\r\nsize + (PAGE_SIZE-1)) >> PAGE_SHIFT;\r\nlocal_irq_save(flags);\r\nbase = bitmap_find_next_zero_area(sun4c_iobuffer_map, iobuffer_map_size,\r\n0, npages, 0);\r\nif (base >= iobuffer_map_size)\r\ngoto abend;\r\nhigh = ((base + npages) << PAGE_SHIFT) + sun4c_iobuffer_start;\r\nhigh = SUN4C_REAL_PGDIR_ALIGN(high);\r\nwhile (high > sun4c_iobuffer_high) {\r\nget_locked_segment(sun4c_iobuffer_high);\r\nsun4c_iobuffer_high += SUN4C_REAL_PGDIR_SIZE;\r\n}\r\nvpage = ((unsigned long) vaddr) & PAGE_MASK;\r\nfor (scan = base; scan < base+npages; scan++) {\r\npte = ((vpage-PAGE_OFFSET) >> PAGE_SHIFT);\r\npte |= pgprot_val(SUN4C_PAGE_KERNEL);\r\npte |= _SUN4C_PAGE_NOCACHE;\r\nset_bit(scan, sun4c_iobuffer_map);\r\napage = (scan << PAGE_SHIFT) + sun4c_iobuffer_start;\r\nsun4c_flush_page(vpage);\r\nsun4c_put_pte(apage, pte);\r\nvpage += PAGE_SIZE;\r\n}\r\nlocal_irq_restore(flags);\r\nreturn (char *) ((base << PAGE_SHIFT) + sun4c_iobuffer_start +\r\n(((unsigned long) vaddr) & ~PAGE_MASK));\r\nabend:\r\nlocal_irq_restore(flags);\r\nprintk("DMA vaddr=0x%p size=%08lx\n", vaddr, size);\r\npanic("Out of iobuffer table");\r\nreturn NULL;\r\n}\r\nstatic void sun4c_unlockarea(char *vaddr, unsigned long size)\r\n{\r\nunsigned long vpage, npages;\r\nunsigned long flags;\r\nint scan, high;\r\nvpage = (unsigned long)vaddr & PAGE_MASK;\r\nnpages = (((unsigned long)vaddr & ~PAGE_MASK) +\r\nsize + (PAGE_SIZE-1)) >> PAGE_SHIFT;\r\nlocal_irq_save(flags);\r\nwhile (npages != 0) {\r\n--npages;\r\nsun4c_put_pte(vpage, 0);\r\nclear_bit((vpage - sun4c_iobuffer_start) >> PAGE_SHIFT,\r\nsun4c_iobuffer_map);\r\nvpage += PAGE_SIZE;\r\n}\r\nscan = (sun4c_iobuffer_high - sun4c_iobuffer_start) >> PAGE_SHIFT;\r\nwhile (scan >= 0 && !sun4c_iobuffer_map[scan >> 5])\r\nscan -= 32;\r\nscan += 32;\r\nhigh = sun4c_iobuffer_start + (scan << PAGE_SHIFT);\r\nhigh = SUN4C_REAL_PGDIR_ALIGN(high) + SUN4C_REAL_PGDIR_SIZE;\r\nwhile (high < sun4c_iobuffer_high) {\r\nsun4c_iobuffer_high -= SUN4C_REAL_PGDIR_SIZE;\r\nfree_locked_segment(sun4c_iobuffer_high);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic __u32 sun4c_get_scsi_one(struct device *dev, char *bufptr, unsigned long len)\r\n{\r\nunsigned long page;\r\npage = ((unsigned long)bufptr) & PAGE_MASK;\r\nif (!virt_addr_valid(page)) {\r\nsun4c_flush_page(page);\r\nreturn (__u32)bufptr;\r\n}\r\nreturn (__u32)sun4c_lockarea(bufptr, len);\r\n}\r\nstatic void sun4c_get_scsi_sgl(struct device *dev, struct scatterlist *sg, int sz)\r\n{\r\nwhile (sz != 0) {\r\n--sz;\r\nsg->dma_address = (__u32)sun4c_lockarea(sg_virt(sg), sg->length);\r\nsg->dma_length = sg->length;\r\nsg = sg_next(sg);\r\n}\r\n}\r\nstatic void sun4c_release_scsi_one(struct device *dev, __u32 bufptr, unsigned long len)\r\n{\r\nif (bufptr < sun4c_iobuffer_start)\r\nreturn;\r\nsun4c_unlockarea((char *)bufptr, len);\r\n}\r\nstatic void sun4c_release_scsi_sgl(struct device *dev, struct scatterlist *sg, int sz)\r\n{\r\nwhile (sz != 0) {\r\n--sz;\r\nsun4c_unlockarea((char *)sg->dma_address, sg->length);\r\nsg = sg_next(sg);\r\n}\r\n}\r\nstatic void __init sun4c_init_lock_areas(void)\r\n{\r\nunsigned long sun4c_taskstack_start;\r\nunsigned long sun4c_taskstack_end;\r\nint bitmap_size;\r\nsun4c_init_buckets();\r\nsun4c_taskstack_start = SUN4C_LOCK_VADDR;\r\nsun4c_taskstack_end = (sun4c_taskstack_start +\r\n(TASK_ENTRY_SIZE * NR_TASK_BUCKETS));\r\nif (sun4c_taskstack_end >= SUN4C_LOCK_END) {\r\nprom_printf("Too many tasks, decrease NR_TASK_BUCKETS please.\n");\r\nprom_halt();\r\n}\r\nsun4c_iobuffer_start = sun4c_iobuffer_high =\r\nSUN4C_REAL_PGDIR_ALIGN(sun4c_taskstack_end);\r\nsun4c_iobuffer_end = SUN4C_LOCK_END;\r\nbitmap_size = (sun4c_iobuffer_end - sun4c_iobuffer_start) >> PAGE_SHIFT;\r\nbitmap_size = (bitmap_size + 7) >> 3;\r\nbitmap_size = LONG_ALIGN(bitmap_size);\r\niobuffer_map_size = bitmap_size << 3;\r\nsun4c_iobuffer_map = __alloc_bootmem(bitmap_size, SMP_CACHE_BYTES, 0UL);\r\nmemset((void *) sun4c_iobuffer_map, 0, bitmap_size);\r\nsun4c_kstack_vma.vm_mm = &init_mm;\r\nsun4c_kstack_vma.vm_start = sun4c_taskstack_start;\r\nsun4c_kstack_vma.vm_end = sun4c_taskstack_end;\r\nsun4c_kstack_vma.vm_page_prot = PAGE_SHARED;\r\nsun4c_kstack_vma.vm_flags = VM_READ | VM_WRITE | VM_EXEC;\r\ninsert_vm_struct(&init_mm, &sun4c_kstack_vma);\r\n}\r\nstatic void sun4c_flush_cache_all(void)\r\n{\r\nunsigned long begin, end;\r\nflush_user_windows();\r\nbegin = (KERNBASE + SUN4C_REAL_PGDIR_SIZE);\r\nend = (begin + SUN4C_VAC_SIZE);\r\nif (sun4c_vacinfo.linesize == 32) {\r\nwhile (begin < end) {\r\n__asm__ __volatile__(\r\n"ld [%0 + 0x00], %%g0\n\t"\r\n"ld [%0 + 0x20], %%g0\n\t"\r\n"ld [%0 + 0x40], %%g0\n\t"\r\n"ld [%0 + 0x60], %%g0\n\t"\r\n"ld [%0 + 0x80], %%g0\n\t"\r\n"ld [%0 + 0xa0], %%g0\n\t"\r\n"ld [%0 + 0xc0], %%g0\n\t"\r\n"ld [%0 + 0xe0], %%g0\n\t"\r\n"ld [%0 + 0x100], %%g0\n\t"\r\n"ld [%0 + 0x120], %%g0\n\t"\r\n"ld [%0 + 0x140], %%g0\n\t"\r\n"ld [%0 + 0x160], %%g0\n\t"\r\n"ld [%0 + 0x180], %%g0\n\t"\r\n"ld [%0 + 0x1a0], %%g0\n\t"\r\n"ld [%0 + 0x1c0], %%g0\n\t"\r\n"ld [%0 + 0x1e0], %%g0\n"\r\n: : "r" (begin));\r\nbegin += 512;\r\n}\r\n} else {\r\nwhile (begin < end) {\r\n__asm__ __volatile__(\r\n"ld [%0 + 0x00], %%g0\n\t"\r\n"ld [%0 + 0x10], %%g0\n\t"\r\n"ld [%0 + 0x20], %%g0\n\t"\r\n"ld [%0 + 0x30], %%g0\n\t"\r\n"ld [%0 + 0x40], %%g0\n\t"\r\n"ld [%0 + 0x50], %%g0\n\t"\r\n"ld [%0 + 0x60], %%g0\n\t"\r\n"ld [%0 + 0x70], %%g0\n\t"\r\n"ld [%0 + 0x80], %%g0\n\t"\r\n"ld [%0 + 0x90], %%g0\n\t"\r\n"ld [%0 + 0xa0], %%g0\n\t"\r\n"ld [%0 + 0xb0], %%g0\n\t"\r\n"ld [%0 + 0xc0], %%g0\n\t"\r\n"ld [%0 + 0xd0], %%g0\n\t"\r\n"ld [%0 + 0xe0], %%g0\n\t"\r\n"ld [%0 + 0xf0], %%g0\n"\r\n: : "r" (begin));\r\nbegin += 256;\r\n}\r\n}\r\n}\r\nstatic void sun4c_flush_cache_mm(struct mm_struct *mm)\r\n{\r\nint new_ctx = mm->context;\r\nif (new_ctx != NO_CONTEXT) {\r\nflush_user_windows();\r\nif (sun4c_context_ring[new_ctx].num_entries) {\r\nstruct sun4c_mmu_entry *head = &sun4c_context_ring[new_ctx].ringhd;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (head->next != head) {\r\nstruct sun4c_mmu_entry *entry = head->next;\r\nint savectx = sun4c_get_context();\r\nsun4c_set_context(new_ctx);\r\nsun4c_flush_context();\r\ndo {\r\nstruct sun4c_mmu_entry *next = entry->next;\r\nsun4c_user_unmap(entry);\r\nfree_user_entry(new_ctx, entry);\r\nentry = next;\r\n} while (entry != head);\r\nsun4c_set_context(savectx);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\n}\r\nstatic void sun4c_flush_cache_range(struct vm_area_struct *vma, unsigned long start, unsigned long end)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nint new_ctx = mm->context;\r\nif (new_ctx != NO_CONTEXT) {\r\nstruct sun4c_mmu_entry *head = &sun4c_context_ring[new_ctx].ringhd;\r\nstruct sun4c_mmu_entry *entry;\r\nunsigned long flags;\r\nflush_user_windows();\r\nlocal_irq_save(flags);\r\nfor (entry = head->next;\r\n(entry != head) && ((entry->vaddr+SUN4C_REAL_PGDIR_SIZE) < start);\r\nentry = entry->next)\r\n;\r\nif ((entry != head) && (entry->vaddr < end)) {\r\nint octx = sun4c_get_context();\r\nsun4c_set_context(new_ctx);\r\ndo {\r\nstruct sun4c_mmu_entry *next = entry->next;\r\nunsigned long realend;\r\nrealend = entry->vaddr + SUN4C_REAL_PGDIR_SIZE;\r\nif (end < realend)\r\nrealend = end;\r\nif ((realend - entry->vaddr) <= (PAGE_SIZE << 3)) {\r\nunsigned long page = entry->vaddr;\r\nwhile (page < realend) {\r\nsun4c_flush_page(page);\r\npage += PAGE_SIZE;\r\n}\r\n} else {\r\nsun4c_flush_segment(entry->vaddr);\r\nsun4c_user_unmap(entry);\r\nfree_user_entry(new_ctx, entry);\r\n}\r\nentry = next;\r\n} while ((entry != head) && (entry->vaddr < end));\r\nsun4c_set_context(octx);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nstatic void sun4c_flush_cache_page(struct vm_area_struct *vma, unsigned long page)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nint new_ctx = mm->context;\r\nif (new_ctx != NO_CONTEXT) {\r\nint octx = sun4c_get_context();\r\nunsigned long flags;\r\nflush_user_windows();\r\nlocal_irq_save(flags);\r\nsun4c_set_context(new_ctx);\r\nsun4c_flush_page(page);\r\nsun4c_set_context(octx);\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nstatic void sun4c_flush_page_to_ram(unsigned long page)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nsun4c_flush_page(page);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void sun4c_flush_sig_insns(struct mm_struct *mm, unsigned long insn_addr)\r\n{\r\n}\r\nstatic void sun4c_flush_tlb_all(void)\r\n{\r\nstruct sun4c_mmu_entry *this_entry, *next_entry;\r\nunsigned long flags;\r\nint savectx, ctx;\r\nlocal_irq_save(flags);\r\nthis_entry = sun4c_kernel_ring.ringhd.next;\r\nsavectx = sun4c_get_context();\r\nflush_user_windows();\r\nwhile (sun4c_kernel_ring.num_entries) {\r\nnext_entry = this_entry->next;\r\nsun4c_flush_segment(this_entry->vaddr);\r\nfor (ctx = 0; ctx < num_contexts; ctx++) {\r\nsun4c_set_context(ctx);\r\nsun4c_put_segmap(this_entry->vaddr, invalid_segment);\r\n}\r\nfree_kernel_entry(this_entry, &sun4c_kernel_ring);\r\nthis_entry = next_entry;\r\n}\r\nsun4c_set_context(savectx);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void sun4c_flush_tlb_mm(struct mm_struct *mm)\r\n{\r\nint new_ctx = mm->context;\r\nif (new_ctx != NO_CONTEXT) {\r\nstruct sun4c_mmu_entry *head = &sun4c_context_ring[new_ctx].ringhd;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (head->next != head) {\r\nstruct sun4c_mmu_entry *entry = head->next;\r\nint savectx = sun4c_get_context();\r\nsun4c_set_context(new_ctx);\r\nsun4c_flush_context();\r\ndo {\r\nstruct sun4c_mmu_entry *next = entry->next;\r\nsun4c_user_unmap(entry);\r\nfree_user_entry(new_ctx, entry);\r\nentry = next;\r\n} while (entry != head);\r\nsun4c_set_context(savectx);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nstatic void sun4c_flush_tlb_range(struct vm_area_struct *vma, unsigned long start, unsigned long end)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nint new_ctx = mm->context;\r\nif (new_ctx != NO_CONTEXT) {\r\nstruct sun4c_mmu_entry *head = &sun4c_context_ring[new_ctx].ringhd;\r\nstruct sun4c_mmu_entry *entry;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nfor (entry = head->next;\r\n(entry != head) && ((entry->vaddr+SUN4C_REAL_PGDIR_SIZE) < start);\r\nentry = entry->next)\r\n;\r\nif ((entry != head) && (entry->vaddr < end)) {\r\nint octx = sun4c_get_context();\r\nsun4c_set_context(new_ctx);\r\ndo {\r\nstruct sun4c_mmu_entry *next = entry->next;\r\nsun4c_flush_segment(entry->vaddr);\r\nsun4c_user_unmap(entry);\r\nfree_user_entry(new_ctx, entry);\r\nentry = next;\r\n} while ((entry != head) && (entry->vaddr < end));\r\nsun4c_set_context(octx);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nstatic void sun4c_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nint new_ctx = mm->context;\r\nif (new_ctx != NO_CONTEXT) {\r\nint savectx = sun4c_get_context();\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nsun4c_set_context(new_ctx);\r\npage &= PAGE_MASK;\r\nsun4c_flush_page(page);\r\nsun4c_put_pte(page, 0);\r\nsun4c_set_context(savectx);\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nstatic inline void sun4c_mapioaddr(unsigned long physaddr, unsigned long virt_addr)\r\n{\r\nunsigned long page_entry, pg_iobits;\r\npg_iobits = _SUN4C_PAGE_PRESENT | _SUN4C_READABLE | _SUN4C_WRITEABLE |\r\n_SUN4C_PAGE_IO | _SUN4C_PAGE_NOCACHE;\r\npage_entry = ((physaddr >> PAGE_SHIFT) & SUN4C_PFN_MASK);\r\npage_entry |= ((pg_iobits | _SUN4C_PAGE_PRIV) & ~(_SUN4C_PAGE_PRESENT));\r\nsun4c_put_pte(virt_addr, page_entry);\r\n}\r\nstatic void sun4c_mapiorange(unsigned int bus, unsigned long xpa,\r\nunsigned long xva, unsigned int len)\r\n{\r\nwhile (len != 0) {\r\nlen -= PAGE_SIZE;\r\nsun4c_mapioaddr(xpa, xva);\r\nxva += PAGE_SIZE;\r\nxpa += PAGE_SIZE;\r\n}\r\n}\r\nstatic void sun4c_unmapiorange(unsigned long virt_addr, unsigned int len)\r\n{\r\nwhile (len != 0) {\r\nlen -= PAGE_SIZE;\r\nsun4c_put_pte(virt_addr, 0);\r\nvirt_addr += PAGE_SIZE;\r\n}\r\n}\r\nstatic void sun4c_alloc_context(struct mm_struct *old_mm, struct mm_struct *mm)\r\n{\r\nstruct ctx_list *ctxp;\r\nctxp = ctx_free.next;\r\nif (ctxp != &ctx_free) {\r\nremove_from_ctx_list(ctxp);\r\nadd_to_used_ctxlist(ctxp);\r\nmm->context = ctxp->ctx_number;\r\nctxp->ctx_mm = mm;\r\nreturn;\r\n}\r\nctxp = ctx_used.next;\r\nif (ctxp->ctx_mm == old_mm)\r\nctxp = ctxp->next;\r\nremove_from_ctx_list(ctxp);\r\nadd_to_used_ctxlist(ctxp);\r\nctxp->ctx_mm->context = NO_CONTEXT;\r\nctxp->ctx_mm = mm;\r\nmm->context = ctxp->ctx_number;\r\nsun4c_demap_context(&sun4c_context_ring[ctxp->ctx_number],\r\nctxp->ctx_number);\r\n}\r\nstatic void sun4c_switch_mm(struct mm_struct *old_mm, struct mm_struct *mm, struct task_struct *tsk, int cpu)\r\n{\r\nstruct ctx_list *ctx;\r\nint dirty = 0;\r\nif (mm->context == NO_CONTEXT) {\r\ndirty = 1;\r\nsun4c_alloc_context(old_mm, mm);\r\n} else {\r\nctx = ctx_list_pool + mm->context;\r\nremove_from_ctx_list(ctx);\r\nadd_to_used_ctxlist(ctx);\r\n}\r\nif (dirty || old_mm != mm)\r\nsun4c_set_context(mm->context);\r\n}\r\nstatic void sun4c_destroy_context(struct mm_struct *mm)\r\n{\r\nstruct ctx_list *ctx_old;\r\nif (mm->context != NO_CONTEXT) {\r\nsun4c_demap_context(&sun4c_context_ring[mm->context], mm->context);\r\nctx_old = ctx_list_pool + mm->context;\r\nremove_from_ctx_list(ctx_old);\r\nadd_to_free_ctxlist(ctx_old);\r\nmm->context = NO_CONTEXT;\r\n}\r\n}\r\nstatic void sun4c_mmu_info(struct seq_file *m)\r\n{\r\nint used_user_entries, i;\r\nused_user_entries = 0;\r\nfor (i = 0; i < num_contexts; i++)\r\nused_user_entries += sun4c_context_ring[i].num_entries;\r\nseq_printf(m,\r\n"vacsize\t\t: %d bytes\n"\r\n"vachwflush\t: %s\n"\r\n"vaclinesize\t: %d bytes\n"\r\n"mmuctxs\t\t: %d\n"\r\n"mmupsegs\t: %d\n"\r\n"kernelpsegs\t: %d\n"\r\n"kfreepsegs\t: %d\n"\r\n"usedpsegs\t: %d\n"\r\n"ufreepsegs\t: %d\n"\r\n"user_taken\t: %d\n"\r\n"max_taken\t: %d\n",\r\nsun4c_vacinfo.num_bytes,\r\n(sun4c_vacinfo.do_hwflushes ? "yes" : "no"),\r\nsun4c_vacinfo.linesize,\r\nnum_contexts,\r\n(invalid_segment + 1),\r\nsun4c_kernel_ring.num_entries,\r\nsun4c_kfree_ring.num_entries,\r\nused_user_entries,\r\nsun4c_ufree_ring.num_entries,\r\nsun4c_user_taken_entries,\r\nmax_user_taken_entries);\r\n}\r\nstatic void sun4c_set_pte(pte_t *ptep, pte_t pte)\r\n{\r\n*ptep = pte;\r\n}\r\nstatic void sun4c_pgd_set(pgd_t * pgdp, pmd_t * pmdp)\r\n{\r\n}\r\nstatic void sun4c_pmd_set(pmd_t * pmdp, pte_t * ptep)\r\n{\r\npmdp->pmdv[0] = PGD_TABLE | (unsigned long) ptep;\r\n}\r\nstatic void sun4c_pmd_populate(pmd_t * pmdp, struct page * ptep)\r\n{\r\nif (page_address(ptep) == NULL) BUG();\r\npmdp->pmdv[0] = PGD_TABLE | (unsigned long) page_address(ptep);\r\n}\r\nstatic int sun4c_pte_present(pte_t pte)\r\n{\r\nreturn ((pte_val(pte) & (_SUN4C_PAGE_PRESENT | _SUN4C_PAGE_PRIV)) != 0);\r\n}\r\nstatic void sun4c_pte_clear(pte_t *ptep) { *ptep = __pte(0); }\r\nstatic int sun4c_pmd_bad(pmd_t pmd)\r\n{\r\nreturn (((pmd_val(pmd) & ~PAGE_MASK) != PGD_TABLE) ||\r\n(!virt_addr_valid(pmd_val(pmd))));\r\n}\r\nstatic int sun4c_pmd_present(pmd_t pmd)\r\n{\r\nreturn ((pmd_val(pmd) & PGD_PRESENT) != 0);\r\n}\r\nstatic void sun4c_pmd_clear(pmd_t *pmdp) {\r\nmemset((void *)pmdp, 0, sizeof(pmd_t));\r\n}\r\nstatic int sun4c_pgd_none(pgd_t pgd) { return 0; }\r\nstatic int sun4c_pgd_bad(pgd_t pgd) { return 0; }\r\nstatic int sun4c_pgd_present(pgd_t pgd) { return 1; }\r\nstatic void sun4c_pgd_clear(pgd_t * pgdp) { }\r\nstatic pte_t sun4c_pte_mkwrite(pte_t pte)\r\n{\r\npte = __pte(pte_val(pte) | _SUN4C_PAGE_WRITE);\r\nif (pte_val(pte) & _SUN4C_PAGE_MODIFIED)\r\npte = __pte(pte_val(pte) | _SUN4C_PAGE_SILENT_WRITE);\r\nreturn pte;\r\n}\r\nstatic pte_t sun4c_pte_mkdirty(pte_t pte)\r\n{\r\npte = __pte(pte_val(pte) | _SUN4C_PAGE_MODIFIED);\r\nif (pte_val(pte) & _SUN4C_PAGE_WRITE)\r\npte = __pte(pte_val(pte) | _SUN4C_PAGE_SILENT_WRITE);\r\nreturn pte;\r\n}\r\nstatic pte_t sun4c_pte_mkyoung(pte_t pte)\r\n{\r\npte = __pte(pte_val(pte) | _SUN4C_PAGE_ACCESSED);\r\nif (pte_val(pte) & _SUN4C_PAGE_READ)\r\npte = __pte(pte_val(pte) | _SUN4C_PAGE_SILENT_READ);\r\nreturn pte;\r\n}\r\nstatic pte_t sun4c_mk_pte(struct page *page, pgprot_t pgprot)\r\n{\r\nreturn __pte(page_to_pfn(page) | pgprot_val(pgprot));\r\n}\r\nstatic pte_t sun4c_mk_pte_phys(unsigned long phys_page, pgprot_t pgprot)\r\n{\r\nreturn __pte((phys_page >> PAGE_SHIFT) | pgprot_val(pgprot));\r\n}\r\nstatic pte_t sun4c_mk_pte_io(unsigned long page, pgprot_t pgprot, int space)\r\n{\r\nreturn __pte(((page - PAGE_OFFSET) >> PAGE_SHIFT) | pgprot_val(pgprot));\r\n}\r\nstatic unsigned long sun4c_pte_pfn(pte_t pte)\r\n{\r\nreturn pte_val(pte) & SUN4C_PFN_MASK;\r\n}\r\nstatic pte_t sun4c_pgoff_to_pte(unsigned long pgoff)\r\n{\r\nreturn __pte(pgoff | _SUN4C_PAGE_FILE);\r\n}\r\nstatic unsigned long sun4c_pte_to_pgoff(pte_t pte)\r\n{\r\nreturn pte_val(pte) & ((1UL << PTE_FILE_MAX_BITS) - 1);\r\n}\r\nstatic inline unsigned long sun4c_pmd_page_v(pmd_t pmd)\r\n{\r\nreturn (pmd_val(pmd) & PAGE_MASK);\r\n}\r\nstatic struct page *sun4c_pmd_page(pmd_t pmd)\r\n{\r\nreturn virt_to_page(sun4c_pmd_page_v(pmd));\r\n}\r\nstatic unsigned long sun4c_pgd_page(pgd_t pgd) { return 0; }\r\nstatic inline pgd_t *sun4c_pgd_offset(struct mm_struct * mm, unsigned long address)\r\n{\r\nreturn mm->pgd + (address >> SUN4C_PGDIR_SHIFT);\r\n}\r\nstatic pmd_t *sun4c_pmd_offset(pgd_t * dir, unsigned long address)\r\n{\r\nreturn (pmd_t *) dir;\r\n}\r\npte_t *sun4c_pte_offset_kernel(pmd_t * dir, unsigned long address)\r\n{\r\nreturn (pte_t *) sun4c_pmd_page_v(*dir) +\r\n((address >> PAGE_SHIFT) & (SUN4C_PTRS_PER_PTE - 1));\r\n}\r\nstatic unsigned long sun4c_swp_type(swp_entry_t entry)\r\n{\r\nreturn (entry.val & SUN4C_SWP_TYPE_MASK);\r\n}\r\nstatic unsigned long sun4c_swp_offset(swp_entry_t entry)\r\n{\r\nreturn (entry.val >> SUN4C_SWP_OFF_SHIFT) & SUN4C_SWP_OFF_MASK;\r\n}\r\nstatic swp_entry_t sun4c_swp_entry(unsigned long type, unsigned long offset)\r\n{\r\nreturn (swp_entry_t) {\r\n(offset & SUN4C_SWP_OFF_MASK) << SUN4C_SWP_OFF_SHIFT\r\n| (type & SUN4C_SWP_TYPE_MASK) };\r\n}\r\nstatic void sun4c_free_pte_slow(pte_t *pte)\r\n{\r\nfree_page((unsigned long)pte);\r\n}\r\nstatic void sun4c_free_pgd_slow(pgd_t *pgd)\r\n{\r\nfree_page((unsigned long)pgd);\r\n}\r\nstatic pgd_t *sun4c_get_pgd_fast(void)\r\n{\r\nunsigned long *ret;\r\nif ((ret = pgd_quicklist) != NULL) {\r\npgd_quicklist = (unsigned long *)(*ret);\r\nret[0] = ret[1];\r\npgtable_cache_size--;\r\n} else {\r\npgd_t *init;\r\nret = (unsigned long *)__get_free_page(GFP_KERNEL);\r\nmemset (ret, 0, (KERNBASE / SUN4C_PGDIR_SIZE) * sizeof(pgd_t));\r\ninit = sun4c_pgd_offset(&init_mm, 0);\r\nmemcpy (((pgd_t *)ret) + USER_PTRS_PER_PGD, init + USER_PTRS_PER_PGD,\r\n(PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));\r\n}\r\nreturn (pgd_t *)ret;\r\n}\r\nstatic void sun4c_free_pgd_fast(pgd_t *pgd)\r\n{\r\n*(unsigned long *)pgd = (unsigned long) pgd_quicklist;\r\npgd_quicklist = (unsigned long *) pgd;\r\npgtable_cache_size++;\r\n}\r\nstatic inline pte_t *\r\nsun4c_pte_alloc_one_fast(struct mm_struct *mm, unsigned long address)\r\n{\r\nunsigned long *ret;\r\nif ((ret = (unsigned long *)pte_quicklist) != NULL) {\r\npte_quicklist = (unsigned long *)(*ret);\r\nret[0] = ret[1];\r\npgtable_cache_size--;\r\n}\r\nreturn (pte_t *)ret;\r\n}\r\nstatic pte_t *sun4c_pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)\r\n{\r\npte_t *pte;\r\nif ((pte = sun4c_pte_alloc_one_fast(mm, address)) != NULL)\r\nreturn pte;\r\npte = (pte_t *)get_zeroed_page(GFP_KERNEL|__GFP_REPEAT);\r\nreturn pte;\r\n}\r\nstatic pgtable_t sun4c_pte_alloc_one(struct mm_struct *mm, unsigned long address)\r\n{\r\npte_t *pte;\r\nstruct page *page;\r\npte = sun4c_pte_alloc_one_kernel(mm, address);\r\nif (pte == NULL)\r\nreturn NULL;\r\npage = virt_to_page(pte);\r\npgtable_page_ctor(page);\r\nreturn page;\r\n}\r\nstatic inline void sun4c_free_pte_fast(pte_t *pte)\r\n{\r\n*(unsigned long *)pte = (unsigned long) pte_quicklist;\r\npte_quicklist = (unsigned long *) pte;\r\npgtable_cache_size++;\r\n}\r\nstatic void sun4c_pte_free(pgtable_t pte)\r\n{\r\npgtable_page_dtor(pte);\r\nsun4c_free_pte_fast(page_address(pte));\r\n}\r\nstatic pmd_t *sun4c_pmd_alloc_one(struct mm_struct *mm, unsigned long address)\r\n{\r\nBUG();\r\nreturn NULL;\r\n}\r\nstatic void sun4c_free_pmd_fast(pmd_t * pmd) { }\r\nstatic void sun4c_check_pgt_cache(int low, int high)\r\n{\r\nif (pgtable_cache_size > high) {\r\ndo {\r\nif (pgd_quicklist)\r\nsun4c_free_pgd_slow(sun4c_get_pgd_fast());\r\nif (pte_quicklist)\r\nsun4c_free_pte_slow(sun4c_pte_alloc_one_fast(NULL, 0));\r\n} while (pgtable_cache_size > low);\r\n}\r\n}\r\nvoid sun4c_update_mmu_cache(struct vm_area_struct *vma, unsigned long address, pte_t *ptep)\r\n{\r\nunsigned long flags;\r\nint pseg;\r\nif (vma->vm_mm->context == NO_CONTEXT)\r\nreturn;\r\nlocal_irq_save(flags);\r\naddress &= PAGE_MASK;\r\nif ((pseg = sun4c_get_segmap(address)) == invalid_segment) {\r\nstruct sun4c_mmu_entry *entry = sun4c_user_strategy();\r\nstruct mm_struct *mm = vma->vm_mm;\r\nunsigned long start, end;\r\nentry->vaddr = start = (address & SUN4C_REAL_PGDIR_MASK);\r\nentry->ctx = mm->context;\r\nadd_ring_ordered(sun4c_context_ring + mm->context, entry);\r\nsun4c_put_segmap(entry->vaddr, entry->pseg);\r\nend = start + SUN4C_REAL_PGDIR_SIZE;\r\nwhile (start < end) {\r\n#ifdef SUN4C_PRELOAD_PSEG\r\npgd_t *pgdp = sun4c_pgd_offset(mm, start);\r\npte_t *ptep;\r\nif (!pgdp)\r\ngoto no_mapping;\r\nptep = sun4c_pte_offset_kernel((pmd_t *) pgdp, start);\r\nif (!ptep || !(pte_val(*ptep) & _SUN4C_PAGE_PRESENT))\r\ngoto no_mapping;\r\nsun4c_put_pte(start, pte_val(*ptep));\r\ngoto next;\r\nno_mapping:\r\n#endif\r\nsun4c_put_pte(start, 0);\r\n#ifdef SUN4C_PRELOAD_PSEG\r\nnext:\r\n#endif\r\nstart += PAGE_SIZE;\r\n}\r\n#ifndef SUN4C_PRELOAD_PSEG\r\nsun4c_put_pte(address, pte_val(*ptep));\r\n#endif\r\nlocal_irq_restore(flags);\r\nreturn;\r\n} else {\r\nstruct sun4c_mmu_entry *entry = &mmu_entry_pool[pseg];\r\nremove_lru(entry);\r\nadd_lru(entry);\r\n}\r\nsun4c_put_pte(address, pte_val(*ptep));\r\nlocal_irq_restore(flags);\r\n}\r\nvoid __init sun4c_paging_init(void)\r\n{\r\nint i, cnt;\r\nunsigned long kernel_end, vaddr;\r\nextern struct resource sparc_iomap;\r\nunsigned long end_pfn, pages_avail;\r\nkernel_end = (unsigned long) &_end;\r\nkernel_end = SUN4C_REAL_PGDIR_ALIGN(kernel_end);\r\npages_avail = 0;\r\nlast_valid_pfn = bootmem_init(&pages_avail);\r\nend_pfn = last_valid_pfn;\r\nsun4c_probe_mmu();\r\ninvalid_segment = (num_segmaps - 1);\r\nsun4c_init_mmu_entry_pool();\r\nsun4c_init_rings();\r\nsun4c_init_map_kernelprom(kernel_end);\r\nsun4c_init_clean_mmu(kernel_end);\r\nsun4c_init_fill_kernel_ring(SUN4C_KERNEL_BUCKETS);\r\nsun4c_init_lock_area(sparc_iomap.start, IOBASE_END);\r\nsun4c_init_lock_area(DVMA_VADDR, DVMA_END);\r\nsun4c_init_lock_areas();\r\nsun4c_init_fill_user_ring();\r\nsun4c_set_context(0);\r\nmemset(swapper_pg_dir, 0, PAGE_SIZE);\r\nmemset(pg0, 0, PAGE_SIZE);\r\nmemset(pg1, 0, PAGE_SIZE);\r\nmemset(pg2, 0, PAGE_SIZE);\r\nmemset(pg3, 0, PAGE_SIZE);\r\nvaddr = VMALLOC_START;\r\nswapper_pg_dir[vaddr>>SUN4C_PGDIR_SHIFT] = __pgd(PGD_TABLE | (unsigned long) pg0);\r\nvaddr += SUN4C_PGDIR_SIZE;\r\nswapper_pg_dir[vaddr>>SUN4C_PGDIR_SHIFT] = __pgd(PGD_TABLE | (unsigned long) pg1);\r\nvaddr += SUN4C_PGDIR_SIZE;\r\nswapper_pg_dir[vaddr>>SUN4C_PGDIR_SHIFT] = __pgd(PGD_TABLE | (unsigned long) pg2);\r\nvaddr += SUN4C_PGDIR_SIZE;\r\nswapper_pg_dir[vaddr>>SUN4C_PGDIR_SHIFT] = __pgd(PGD_TABLE | (unsigned long) pg3);\r\nsun4c_init_ss2_cache_bug();\r\nsparc_context_init(num_contexts);\r\n{\r\nunsigned long zones_size[MAX_NR_ZONES];\r\nunsigned long zholes_size[MAX_NR_ZONES];\r\nunsigned long npages;\r\nint znum;\r\nfor (znum = 0; znum < MAX_NR_ZONES; znum++)\r\nzones_size[znum] = zholes_size[znum] = 0;\r\nnpages = max_low_pfn - pfn_base;\r\nzones_size[ZONE_DMA] = npages;\r\nzholes_size[ZONE_DMA] = npages - pages_avail;\r\nnpages = highend_pfn - max_low_pfn;\r\nzones_size[ZONE_HIGHMEM] = npages;\r\nzholes_size[ZONE_HIGHMEM] = npages - calc_highpages();\r\nfree_area_init_node(0, zones_size, pfn_base, zholes_size);\r\n}\r\ncnt = 0;\r\nfor (i = 0; i < num_segmaps; i++)\r\nif (mmu_entry_pool[i].locked)\r\ncnt++;\r\nmax_user_taken_entries = num_segmaps - cnt - 40 - 1;\r\nprintk("SUN4C: %d mmu entries for the kernel\n", cnt);\r\n}\r\nstatic pgprot_t sun4c_pgprot_noncached(pgprot_t prot)\r\n{\r\nprot |= __pgprot(_SUN4C_PAGE_IO | _SUN4C_PAGE_NOCACHE);\r\nreturn prot;\r\n}\r\nvoid __init ld_mmu_sun4c(void)\r\n{\r\nextern void ___xchg32_sun4c(void);\r\nprintk("Loading sun4c MMU routines\n");\r\nBTFIXUPSET_SIMM13(pgdir_shift, SUN4C_PGDIR_SHIFT);\r\nBTFIXUPSET_SETHI(pgdir_size, SUN4C_PGDIR_SIZE);\r\nBTFIXUPSET_SETHI(pgdir_mask, SUN4C_PGDIR_MASK);\r\nBTFIXUPSET_SIMM13(ptrs_per_pmd, SUN4C_PTRS_PER_PMD);\r\nBTFIXUPSET_SIMM13(ptrs_per_pgd, SUN4C_PTRS_PER_PGD);\r\nBTFIXUPSET_SIMM13(user_ptrs_per_pgd, KERNBASE / SUN4C_PGDIR_SIZE);\r\nBTFIXUPSET_INT(page_none, pgprot_val(SUN4C_PAGE_NONE));\r\nPAGE_SHARED = pgprot_val(SUN4C_PAGE_SHARED);\r\nBTFIXUPSET_INT(page_copy, pgprot_val(SUN4C_PAGE_COPY));\r\nBTFIXUPSET_INT(page_readonly, pgprot_val(SUN4C_PAGE_READONLY));\r\nBTFIXUPSET_INT(page_kernel, pgprot_val(SUN4C_PAGE_KERNEL));\r\npage_kernel = pgprot_val(SUN4C_PAGE_KERNEL);\r\nBTFIXUPSET_CALL(pgprot_noncached, sun4c_pgprot_noncached, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(___xchg32, ___xchg32_sun4c, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(do_check_pgt_cache, sun4c_check_pgt_cache, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(flush_cache_all, sun4c_flush_cache_all, BTFIXUPCALL_NORM);\r\nif (sun4c_vacinfo.do_hwflushes) {\r\nBTFIXUPSET_CALL(sun4c_flush_page, sun4c_flush_page_hw, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(sun4c_flush_segment, sun4c_flush_segment_hw, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(sun4c_flush_context, sun4c_flush_context_hw, BTFIXUPCALL_NORM);\r\n} else {\r\nBTFIXUPSET_CALL(sun4c_flush_page, sun4c_flush_page_sw, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(sun4c_flush_segment, sun4c_flush_segment_sw, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(sun4c_flush_context, sun4c_flush_context_sw, BTFIXUPCALL_NORM);\r\n}\r\nBTFIXUPSET_CALL(flush_tlb_mm, sun4c_flush_tlb_mm, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(flush_cache_mm, sun4c_flush_cache_mm, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(destroy_context, sun4c_destroy_context, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(switch_mm, sun4c_switch_mm, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(flush_cache_page, sun4c_flush_cache_page, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(flush_tlb_page, sun4c_flush_tlb_page, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(flush_tlb_range, sun4c_flush_tlb_range, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(flush_cache_range, sun4c_flush_cache_range, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(__flush_page_to_ram, sun4c_flush_page_to_ram, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(flush_tlb_all, sun4c_flush_tlb_all, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(flush_sig_insns, sun4c_flush_sig_insns, BTFIXUPCALL_NOP);\r\nBTFIXUPSET_CALL(set_pte, sun4c_set_pte, BTFIXUPCALL_STO1O0);\r\nBTFIXUPSET_CALL(pte_pfn, sun4c_pte_pfn, BTFIXUPCALL_NORM);\r\n#if 0\r\nBTFIXUPSET_CALL(pmd_page, sun4c_pmd_page, BTFIXUPCALL_ANDNINT(PAGE_SIZE - 1));\r\n#else\r\nBTFIXUPSET_CALL(pmd_page, sun4c_pmd_page, BTFIXUPCALL_NORM);\r\n#endif\r\nBTFIXUPSET_CALL(pmd_set, sun4c_pmd_set, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(pmd_populate, sun4c_pmd_populate, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(pte_present, sun4c_pte_present, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(pte_clear, sun4c_pte_clear, BTFIXUPCALL_STG0O0);\r\nBTFIXUPSET_CALL(pmd_bad, sun4c_pmd_bad, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(pmd_present, sun4c_pmd_present, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(pmd_clear, sun4c_pmd_clear, BTFIXUPCALL_STG0O0);\r\nBTFIXUPSET_CALL(pgd_none, sun4c_pgd_none, BTFIXUPCALL_RETINT(0));\r\nBTFIXUPSET_CALL(pgd_bad, sun4c_pgd_bad, BTFIXUPCALL_RETINT(0));\r\nBTFIXUPSET_CALL(pgd_present, sun4c_pgd_present, BTFIXUPCALL_RETINT(1));\r\nBTFIXUPSET_CALL(pgd_clear, sun4c_pgd_clear, BTFIXUPCALL_NOP);\r\nBTFIXUPSET_CALL(mk_pte, sun4c_mk_pte, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(mk_pte_phys, sun4c_mk_pte_phys, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(mk_pte_io, sun4c_mk_pte_io, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_INT(pte_modify_mask, _SUN4C_PAGE_CHG_MASK);\r\nBTFIXUPSET_CALL(pmd_offset, sun4c_pmd_offset, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(pte_offset_kernel, sun4c_pte_offset_kernel, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(free_pte_fast, sun4c_free_pte_fast, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(pte_free, sun4c_pte_free, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(pte_alloc_one_kernel, sun4c_pte_alloc_one_kernel, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(pte_alloc_one, sun4c_pte_alloc_one, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(free_pmd_fast, sun4c_free_pmd_fast, BTFIXUPCALL_NOP);\r\nBTFIXUPSET_CALL(pmd_alloc_one, sun4c_pmd_alloc_one, BTFIXUPCALL_RETO0);\r\nBTFIXUPSET_CALL(free_pgd_fast, sun4c_free_pgd_fast, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(get_pgd_fast, sun4c_get_pgd_fast, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_HALF(pte_writei, _SUN4C_PAGE_WRITE);\r\nBTFIXUPSET_HALF(pte_dirtyi, _SUN4C_PAGE_MODIFIED);\r\nBTFIXUPSET_HALF(pte_youngi, _SUN4C_PAGE_ACCESSED);\r\nBTFIXUPSET_HALF(pte_filei, _SUN4C_PAGE_FILE);\r\nBTFIXUPSET_HALF(pte_wrprotecti, _SUN4C_PAGE_WRITE|_SUN4C_PAGE_SILENT_WRITE);\r\nBTFIXUPSET_HALF(pte_mkcleani, _SUN4C_PAGE_MODIFIED|_SUN4C_PAGE_SILENT_WRITE);\r\nBTFIXUPSET_HALF(pte_mkoldi, _SUN4C_PAGE_ACCESSED|_SUN4C_PAGE_SILENT_READ);\r\nBTFIXUPSET_CALL(pte_mkwrite, sun4c_pte_mkwrite, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(pte_mkdirty, sun4c_pte_mkdirty, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(pte_mkyoung, sun4c_pte_mkyoung, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(update_mmu_cache, sun4c_update_mmu_cache, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(pte_to_pgoff, sun4c_pte_to_pgoff, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(pgoff_to_pte, sun4c_pgoff_to_pte, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(mmu_lockarea, sun4c_lockarea, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(mmu_unlockarea, sun4c_unlockarea, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(mmu_get_scsi_one, sun4c_get_scsi_one, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(mmu_get_scsi_sgl, sun4c_get_scsi_sgl, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(mmu_release_scsi_one, sun4c_release_scsi_one, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(mmu_release_scsi_sgl, sun4c_release_scsi_sgl, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(mmu_map_dma_area, sun4c_map_dma_area, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(mmu_unmap_dma_area, sun4c_unmap_dma_area, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(sparc_mapiorange, sun4c_mapiorange, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(sparc_unmapiorange, sun4c_unmapiorange, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(__swp_type, sun4c_swp_type, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(__swp_offset, sun4c_swp_offset, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(__swp_entry, sun4c_swp_entry, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(alloc_thread_info_node, sun4c_alloc_thread_info_node, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(free_thread_info, sun4c_free_thread_info, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(mmu_info, sun4c_mmu_info, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(pgd_set, sun4c_pgd_set, BTFIXUPCALL_NOP);\r\nBTFIXUPSET_CALL(pgd_page_vaddr, sun4c_pgd_page, BTFIXUPCALL_RETO0);\r\n}
