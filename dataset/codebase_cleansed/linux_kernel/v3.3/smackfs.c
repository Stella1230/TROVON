static void smk_netlabel_audit_set(struct netlbl_audit *nap)\r\n{\r\nnap->loginuid = audit_get_loginuid(current);\r\nnap->sessionid = audit_get_sessionid(current);\r\nnap->secid = smack_to_secid(smk_of_current());\r\n}\r\nstatic int smk_set_access(struct smack_rule *srp, struct list_head *rule_list,\r\nstruct mutex *rule_lock)\r\n{\r\nstruct smack_rule *sp;\r\nint found = 0;\r\nmutex_lock(rule_lock);\r\nlist_for_each_entry_rcu(sp, rule_list, list) {\r\nif (sp->smk_object == srp->smk_object &&\r\nsp->smk_subject == srp->smk_subject) {\r\nfound = 1;\r\nsp->smk_access = srp->smk_access;\r\nbreak;\r\n}\r\n}\r\nif (found == 0)\r\nlist_add_rcu(&srp->list, rule_list);\r\nmutex_unlock(rule_lock);\r\nreturn found;\r\n}\r\nstatic int smk_parse_rule(const char *data, struct smack_rule *rule, int import)\r\n{\r\nchar smack[SMK_LABELLEN];\r\nstruct smack_known *skp;\r\nif (import) {\r\nrule->smk_subject = smk_import(data, 0);\r\nif (rule->smk_subject == NULL)\r\nreturn -1;\r\nrule->smk_object = smk_import(data + SMK_LABELLEN, 0);\r\nif (rule->smk_object == NULL)\r\nreturn -1;\r\n} else {\r\nsmk_parse_smack(data, 0, smack);\r\nskp = smk_find_entry(smack);\r\nif (skp == NULL)\r\nreturn -1;\r\nrule->smk_subject = skp->smk_known;\r\nsmk_parse_smack(data + SMK_LABELLEN, 0, smack);\r\nskp = smk_find_entry(smack);\r\nif (skp == NULL)\r\nreturn -1;\r\nrule->smk_object = skp->smk_known;\r\n}\r\nrule->smk_access = 0;\r\nswitch (data[SMK_LABELLEN + SMK_LABELLEN]) {\r\ncase '-':\r\nbreak;\r\ncase 'r':\r\ncase 'R':\r\nrule->smk_access |= MAY_READ;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nswitch (data[SMK_LABELLEN + SMK_LABELLEN + 1]) {\r\ncase '-':\r\nbreak;\r\ncase 'w':\r\ncase 'W':\r\nrule->smk_access |= MAY_WRITE;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nswitch (data[SMK_LABELLEN + SMK_LABELLEN + 2]) {\r\ncase '-':\r\nbreak;\r\ncase 'x':\r\ncase 'X':\r\nrule->smk_access |= MAY_EXEC;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nswitch (data[SMK_LABELLEN + SMK_LABELLEN + 3]) {\r\ncase '-':\r\nbreak;\r\ncase 'a':\r\ncase 'A':\r\nrule->smk_access |= MAY_APPEND;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nswitch (data[SMK_LABELLEN + SMK_LABELLEN + 4]) {\r\ncase '-':\r\nbreak;\r\ncase 't':\r\ncase 'T':\r\nrule->smk_access |= MAY_TRANSMUTE;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t smk_write_load_list(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos,\r\nstruct list_head *rule_list,\r\nstruct mutex *rule_lock)\r\n{\r\nstruct smack_master_list *smlp;\r\nstruct smack_known *skp;\r\nstruct smack_rule *rule;\r\nchar *data;\r\nint rc = -EINVAL;\r\nint load = 0;\r\nif (*ppos != 0)\r\nreturn -EINVAL;\r\nif (count < (SMK_OLOADLEN) || count > SMK_LOADLEN)\r\nreturn -EINVAL;\r\ndata = kzalloc(SMK_LOADLEN, GFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(data, buf, count) != 0) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nif (count == (SMK_OLOADLEN))\r\ndata[SMK_OLOADLEN] = '-';\r\nrule = kzalloc(sizeof(*rule), GFP_KERNEL);\r\nif (rule == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nif (smk_parse_rule(data, rule, 1))\r\ngoto out_free_rule;\r\nif (rule_list == NULL) {\r\nload = 1;\r\nskp = smk_find_entry(rule->smk_subject);\r\nrule_list = &skp->smk_rules;\r\nrule_lock = &skp->smk_rules_lock;\r\n}\r\nrc = count;\r\nif (load && !smk_set_access(rule, rule_list, rule_lock)) {\r\nsmlp = kzalloc(sizeof(*smlp), GFP_KERNEL);\r\nif (smlp != NULL) {\r\nsmlp->smk_rule = rule;\r\nlist_add_rcu(&smlp->list, &smack_rule_list);\r\n} else\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nout_free_rule:\r\nkfree(rule);\r\nout:\r\nkfree(data);\r\nreturn rc;\r\n}\r\nstatic void *smk_seq_start(struct seq_file *s, loff_t *pos,\r\nstruct list_head *head)\r\n{\r\nstruct list_head *list;\r\nif (s->index == 0)\r\ns->private = head;\r\nif (s->private == NULL)\r\nreturn NULL;\r\nlist = s->private;\r\nif (list_empty(list))\r\nreturn NULL;\r\nif (s->index == 0)\r\nreturn list->next;\r\nreturn list;\r\n}\r\nstatic void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\r\nstruct list_head *head)\r\n{\r\nstruct list_head *list = v;\r\nif (list_is_last(list, head)) {\r\ns->private = NULL;\r\nreturn NULL;\r\n}\r\ns->private = list->next;\r\nreturn list->next;\r\n}\r\nstatic void smk_seq_stop(struct seq_file *s, void *v)\r\n{\r\n}\r\nstatic void *load_seq_start(struct seq_file *s, loff_t *pos)\r\n{\r\nreturn smk_seq_start(s, pos, &smack_rule_list);\r\n}\r\nstatic void *load_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nreturn smk_seq_next(s, v, pos, &smack_rule_list);\r\n}\r\nstatic int load_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct list_head *list = v;\r\nstruct smack_master_list *smlp =\r\nlist_entry(list, struct smack_master_list, list);\r\nstruct smack_rule *srp = smlp->smk_rule;\r\nseq_printf(s, "%s %s", (char *)srp->smk_subject,\r\n(char *)srp->smk_object);\r\nseq_putc(s, ' ');\r\nif (srp->smk_access & MAY_READ)\r\nseq_putc(s, 'r');\r\nif (srp->smk_access & MAY_WRITE)\r\nseq_putc(s, 'w');\r\nif (srp->smk_access & MAY_EXEC)\r\nseq_putc(s, 'x');\r\nif (srp->smk_access & MAY_APPEND)\r\nseq_putc(s, 'a');\r\nif (srp->smk_access & MAY_TRANSMUTE)\r\nseq_putc(s, 't');\r\nif (srp->smk_access == 0)\r\nseq_putc(s, '-');\r\nseq_putc(s, '\n');\r\nreturn 0;\r\n}\r\nstatic int smk_open_load(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &load_seq_ops);\r\n}\r\nstatic ssize_t smk_write_load(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nreturn smk_write_load_list(file, buf, count, ppos, NULL, NULL);\r\n}\r\nstatic void smk_cipso_doi(void)\r\n{\r\nint rc;\r\nstruct cipso_v4_doi *doip;\r\nstruct netlbl_audit nai;\r\nsmk_netlabel_audit_set(&nai);\r\nrc = netlbl_cfg_map_del(NULL, PF_INET, NULL, NULL, &nai);\r\nif (rc != 0)\r\nprintk(KERN_WARNING "%s:%d remove rc = %d\n",\r\n__func__, __LINE__, rc);\r\ndoip = kmalloc(sizeof(struct cipso_v4_doi), GFP_KERNEL);\r\nif (doip == NULL)\r\npanic("smack: Failed to initialize cipso DOI.\n");\r\ndoip->map.std = NULL;\r\ndoip->doi = smk_cipso_doi_value;\r\ndoip->type = CIPSO_V4_MAP_PASS;\r\ndoip->tags[0] = CIPSO_V4_TAG_RBITMAP;\r\nfor (rc = 1; rc < CIPSO_V4_TAG_MAXCNT; rc++)\r\ndoip->tags[rc] = CIPSO_V4_TAG_INVALID;\r\nrc = netlbl_cfg_cipsov4_add(doip, &nai);\r\nif (rc != 0) {\r\nprintk(KERN_WARNING "%s:%d cipso add rc = %d\n",\r\n__func__, __LINE__, rc);\r\nkfree(doip);\r\nreturn;\r\n}\r\nrc = netlbl_cfg_cipsov4_map_add(doip->doi, NULL, NULL, NULL, &nai);\r\nif (rc != 0) {\r\nprintk(KERN_WARNING "%s:%d map add rc = %d\n",\r\n__func__, __LINE__, rc);\r\nkfree(doip);\r\nreturn;\r\n}\r\n}\r\nstatic void smk_unlbl_ambient(char *oldambient)\r\n{\r\nint rc;\r\nstruct netlbl_audit nai;\r\nsmk_netlabel_audit_set(&nai);\r\nif (oldambient != NULL) {\r\nrc = netlbl_cfg_map_del(oldambient, PF_INET, NULL, NULL, &nai);\r\nif (rc != 0)\r\nprintk(KERN_WARNING "%s:%d remove rc = %d\n",\r\n__func__, __LINE__, rc);\r\n}\r\nrc = netlbl_cfg_unlbl_map_add(smack_net_ambient, PF_INET,\r\nNULL, NULL, &nai);\r\nif (rc != 0)\r\nprintk(KERN_WARNING "%s:%d add rc = %d\n",\r\n__func__, __LINE__, rc);\r\n}\r\nstatic void *cipso_seq_start(struct seq_file *s, loff_t *pos)\r\n{\r\nreturn smk_seq_start(s, pos, &smack_known_list);\r\n}\r\nstatic void *cipso_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nreturn smk_seq_next(s, v, pos, &smack_known_list);\r\n}\r\nstatic int cipso_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct list_head *list = v;\r\nstruct smack_known *skp =\r\nlist_entry(list, struct smack_known, list);\r\nstruct smack_cipso *scp = skp->smk_cipso;\r\nchar *cbp;\r\nchar sep = '/';\r\nint cat = 1;\r\nint i;\r\nunsigned char m;\r\nif (scp == NULL)\r\nreturn 0;\r\nseq_printf(s, "%s %3d", (char *)&skp->smk_known, scp->smk_level);\r\ncbp = scp->smk_catset;\r\nfor (i = 0; i < SMK_LABELLEN; i++)\r\nfor (m = 0x80; m != 0; m >>= 1) {\r\nif (m & cbp[i]) {\r\nseq_printf(s, "%c%d", sep, cat);\r\nsep = ',';\r\n}\r\ncat++;\r\n}\r\nseq_putc(s, '\n');\r\nreturn 0;\r\n}\r\nstatic int smk_open_cipso(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &cipso_seq_ops);\r\n}\r\nstatic ssize_t smk_write_cipso(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct smack_known *skp;\r\nstruct smack_cipso *scp = NULL;\r\nchar mapcatset[SMK_LABELLEN];\r\nint maplevel;\r\nint cat;\r\nint catlen;\r\nssize_t rc = -EINVAL;\r\nchar *data = NULL;\r\nchar *rule;\r\nint ret;\r\nint i;\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (*ppos != 0)\r\nreturn -EINVAL;\r\nif (count < SMK_CIPSOMIN || count > SMK_CIPSOMAX)\r\nreturn -EINVAL;\r\ndata = kzalloc(count + 1, GFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(data, buf, count) != 0) {\r\nrc = -EFAULT;\r\ngoto unlockedout;\r\n}\r\nif (data[0] == '-') {\r\nrc = -EINVAL;\r\ngoto unlockedout;\r\n}\r\ndata[count] = '\0';\r\nrule = data;\r\nmutex_lock(&smack_cipso_lock);\r\nskp = smk_import_entry(rule, 0);\r\nif (skp == NULL)\r\ngoto out;\r\nrule += SMK_LABELLEN;\r\nret = sscanf(rule, "%d", &maplevel);\r\nif (ret != 1 || maplevel > SMACK_CIPSO_MAXLEVEL)\r\ngoto out;\r\nrule += SMK_DIGITLEN;\r\nret = sscanf(rule, "%d", &catlen);\r\nif (ret != 1 || catlen > SMACK_CIPSO_MAXCATNUM)\r\ngoto out;\r\nif (count != (SMK_CIPSOMIN + catlen * SMK_DIGITLEN))\r\ngoto out;\r\nmemset(mapcatset, 0, sizeof(mapcatset));\r\nfor (i = 0; i < catlen; i++) {\r\nrule += SMK_DIGITLEN;\r\nret = sscanf(rule, "%d", &cat);\r\nif (ret != 1 || cat > SMACK_CIPSO_MAXCATVAL)\r\ngoto out;\r\nsmack_catset_bit(cat, mapcatset);\r\n}\r\nif (skp->smk_cipso == NULL) {\r\nscp = kzalloc(sizeof(struct smack_cipso), GFP_KERNEL);\r\nif (scp == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nspin_lock_bh(&skp->smk_cipsolock);\r\nif (scp == NULL)\r\nscp = skp->smk_cipso;\r\nelse\r\nskp->smk_cipso = scp;\r\nscp->smk_level = maplevel;\r\nmemcpy(scp->smk_catset, mapcatset, sizeof(mapcatset));\r\nspin_unlock_bh(&skp->smk_cipsolock);\r\nrc = count;\r\nout:\r\nmutex_unlock(&smack_cipso_lock);\r\nunlockedout:\r\nkfree(data);\r\nreturn rc;\r\n}\r\nstatic void *netlbladdr_seq_start(struct seq_file *s, loff_t *pos)\r\n{\r\nreturn smk_seq_start(s, pos, &smk_netlbladdr_list);\r\n}\r\nstatic void *netlbladdr_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nreturn smk_seq_next(s, v, pos, &smk_netlbladdr_list);\r\n}\r\nstatic int netlbladdr_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct list_head *list = v;\r\nstruct smk_netlbladdr *skp =\r\nlist_entry(list, struct smk_netlbladdr, list);\r\nunsigned char *hp = (char *) &skp->smk_host.sin_addr.s_addr;\r\nint maskn;\r\nu32 temp_mask = be32_to_cpu(skp->smk_mask.s_addr);\r\nfor (maskn = 0; temp_mask; temp_mask <<= 1, maskn++);\r\nseq_printf(s, "%u.%u.%u.%u/%d %s\n",\r\nhp[0], hp[1], hp[2], hp[3], maskn, skp->smk_label);\r\nreturn 0;\r\n}\r\nstatic int smk_open_netlbladdr(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &netlbladdr_seq_ops);\r\n}\r\nstatic void smk_netlbladdr_insert(struct smk_netlbladdr *new)\r\n{\r\nstruct smk_netlbladdr *m, *m_next;\r\nif (list_empty(&smk_netlbladdr_list)) {\r\nlist_add_rcu(&new->list, &smk_netlbladdr_list);\r\nreturn;\r\n}\r\nm = list_entry_rcu(smk_netlbladdr_list.next,\r\nstruct smk_netlbladdr, list);\r\nif (new->smk_mask.s_addr > m->smk_mask.s_addr) {\r\nlist_add_rcu(&new->list, &smk_netlbladdr_list);\r\nreturn;\r\n}\r\nlist_for_each_entry_rcu(m, &smk_netlbladdr_list, list) {\r\nif (list_is_last(&m->list, &smk_netlbladdr_list)) {\r\nlist_add_rcu(&new->list, &m->list);\r\nreturn;\r\n}\r\nm_next = list_entry_rcu(m->list.next,\r\nstruct smk_netlbladdr, list);\r\nif (new->smk_mask.s_addr > m_next->smk_mask.s_addr) {\r\nlist_add_rcu(&new->list, &m->list);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic ssize_t smk_write_netlbladdr(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct smk_netlbladdr *skp;\r\nstruct sockaddr_in newname;\r\nchar smack[SMK_LABELLEN];\r\nchar *sp;\r\nchar data[SMK_NETLBLADDRMAX + 1];\r\nchar *host = (char *)&newname.sin_addr.s_addr;\r\nint rc;\r\nstruct netlbl_audit audit_info;\r\nstruct in_addr mask;\r\nunsigned int m;\r\nint found;\r\nu32 mask_bits = (1<<31);\r\n__be32 nsa;\r\nu32 temp_mask;\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (*ppos != 0)\r\nreturn -EINVAL;\r\nif (count < SMK_NETLBLADDRMIN || count > SMK_NETLBLADDRMAX)\r\nreturn -EINVAL;\r\nif (copy_from_user(data, buf, count) != 0)\r\nreturn -EFAULT;\r\ndata[count] = '\0';\r\nrc = sscanf(data, "%hhd.%hhd.%hhd.%hhd/%d %s",\r\n&host[0], &host[1], &host[2], &host[3], &m, smack);\r\nif (rc != 6) {\r\nrc = sscanf(data, "%hhd.%hhd.%hhd.%hhd %s",\r\n&host[0], &host[1], &host[2], &host[3], smack);\r\nif (rc != 5)\r\nreturn -EINVAL;\r\nm = BEBITS;\r\n}\r\nif (m > BEBITS)\r\nreturn -EINVAL;\r\nif (smack[0] != '-') {\r\nsp = smk_import(smack, 0);\r\nif (sp == NULL)\r\nreturn -EINVAL;\r\n} else {\r\nif (strcmp(smack, smack_cipso_option) == 0)\r\nsp = (char *)smack_cipso_option;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nfor (temp_mask = 0; m > 0; m--) {\r\ntemp_mask |= mask_bits;\r\nmask_bits >>= 1;\r\n}\r\nmask.s_addr = cpu_to_be32(temp_mask);\r\nnewname.sin_addr.s_addr &= mask.s_addr;\r\nmutex_lock(&smk_netlbladdr_lock);\r\nnsa = newname.sin_addr.s_addr;\r\nfound = 0;\r\nlist_for_each_entry_rcu(skp, &smk_netlbladdr_list, list) {\r\nif (skp->smk_host.sin_addr.s_addr == nsa &&\r\nskp->smk_mask.s_addr == mask.s_addr) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nsmk_netlabel_audit_set(&audit_info);\r\nif (found == 0) {\r\nskp = kzalloc(sizeof(*skp), GFP_KERNEL);\r\nif (skp == NULL)\r\nrc = -ENOMEM;\r\nelse {\r\nrc = 0;\r\nskp->smk_host.sin_addr.s_addr = newname.sin_addr.s_addr;\r\nskp->smk_mask.s_addr = mask.s_addr;\r\nskp->smk_label = sp;\r\nsmk_netlbladdr_insert(skp);\r\n}\r\n} else {\r\nif (skp->smk_label != smack_cipso_option)\r\nrc = netlbl_cfg_unlbl_static_del(&init_net, NULL,\r\n&skp->smk_host.sin_addr, &skp->smk_mask,\r\nPF_INET, &audit_info);\r\nelse\r\nrc = 0;\r\nskp->smk_label = sp;\r\n}\r\nif (rc == 0 && sp != smack_cipso_option)\r\nrc = netlbl_cfg_unlbl_static_add(&init_net, NULL,\r\n&skp->smk_host.sin_addr, &skp->smk_mask, PF_INET,\r\nsmack_to_secid(skp->smk_label), &audit_info);\r\nif (rc == 0)\r\nrc = count;\r\nmutex_unlock(&smk_netlbladdr_lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_read_doi(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar temp[80];\r\nssize_t rc;\r\nif (*ppos != 0)\r\nreturn 0;\r\nsprintf(temp, "%d", smk_cipso_doi_value);\r\nrc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_write_doi(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar temp[80];\r\nint i;\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (count >= sizeof(temp) || count == 0)\r\nreturn -EINVAL;\r\nif (copy_from_user(temp, buf, count) != 0)\r\nreturn -EFAULT;\r\ntemp[count] = '\0';\r\nif (sscanf(temp, "%d", &i) != 1)\r\nreturn -EINVAL;\r\nsmk_cipso_doi_value = i;\r\nsmk_cipso_doi();\r\nreturn count;\r\n}\r\nstatic ssize_t smk_read_direct(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar temp[80];\r\nssize_t rc;\r\nif (*ppos != 0)\r\nreturn 0;\r\nsprintf(temp, "%d", smack_cipso_direct);\r\nrc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_write_direct(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar temp[80];\r\nint i;\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (count >= sizeof(temp) || count == 0)\r\nreturn -EINVAL;\r\nif (copy_from_user(temp, buf, count) != 0)\r\nreturn -EFAULT;\r\ntemp[count] = '\0';\r\nif (sscanf(temp, "%d", &i) != 1)\r\nreturn -EINVAL;\r\nsmack_cipso_direct = i;\r\nreturn count;\r\n}\r\nstatic ssize_t smk_read_ambient(struct file *filp, char __user *buf,\r\nsize_t cn, loff_t *ppos)\r\n{\r\nssize_t rc;\r\nint asize;\r\nif (*ppos != 0)\r\nreturn 0;\r\nmutex_lock(&smack_ambient_lock);\r\nasize = strlen(smack_net_ambient) + 1;\r\nif (cn >= asize)\r\nrc = simple_read_from_buffer(buf, cn, ppos,\r\nsmack_net_ambient, asize);\r\nelse\r\nrc = -EINVAL;\r\nmutex_unlock(&smack_ambient_lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_write_ambient(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar in[SMK_LABELLEN];\r\nchar *oldambient;\r\nchar *smack;\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (count >= SMK_LABELLEN)\r\nreturn -EINVAL;\r\nif (copy_from_user(in, buf, count) != 0)\r\nreturn -EFAULT;\r\nsmack = smk_import(in, count);\r\nif (smack == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&smack_ambient_lock);\r\noldambient = smack_net_ambient;\r\nsmack_net_ambient = smack;\r\nsmk_unlbl_ambient(oldambient);\r\nmutex_unlock(&smack_ambient_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t smk_read_onlycap(struct file *filp, char __user *buf,\r\nsize_t cn, loff_t *ppos)\r\n{\r\nchar *smack = "";\r\nssize_t rc = -EINVAL;\r\nint asize;\r\nif (*ppos != 0)\r\nreturn 0;\r\nif (smack_onlycap != NULL)\r\nsmack = smack_onlycap;\r\nasize = strlen(smack) + 1;\r\nif (cn >= asize)\r\nrc = simple_read_from_buffer(buf, cn, ppos, smack, asize);\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_write_onlycap(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar in[SMK_LABELLEN];\r\nchar *sp = smk_of_task(current->cred->security);\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (smack_onlycap != NULL && smack_onlycap != sp)\r\nreturn -EPERM;\r\nif (count >= SMK_LABELLEN)\r\nreturn -EINVAL;\r\nif (copy_from_user(in, buf, count) != 0)\r\nreturn -EFAULT;\r\nsmack_onlycap = smk_import(in, count);\r\nreturn count;\r\n}\r\nstatic ssize_t smk_read_logging(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar temp[32];\r\nssize_t rc;\r\nif (*ppos != 0)\r\nreturn 0;\r\nsprintf(temp, "%d\n", log_policy);\r\nrc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_write_logging(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar temp[32];\r\nint i;\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (count >= sizeof(temp) || count == 0)\r\nreturn -EINVAL;\r\nif (copy_from_user(temp, buf, count) != 0)\r\nreturn -EFAULT;\r\ntemp[count] = '\0';\r\nif (sscanf(temp, "%d", &i) != 1)\r\nreturn -EINVAL;\r\nif (i < 0 || i > 3)\r\nreturn -EINVAL;\r\nlog_policy = i;\r\nreturn count;\r\n}\r\nstatic void *load_self_seq_start(struct seq_file *s, loff_t *pos)\r\n{\r\nstruct task_smack *tsp = current_security();\r\nreturn smk_seq_start(s, pos, &tsp->smk_rules);\r\n}\r\nstatic void *load_self_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nstruct task_smack *tsp = current_security();\r\nreturn smk_seq_next(s, v, pos, &tsp->smk_rules);\r\n}\r\nstatic int load_self_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct list_head *list = v;\r\nstruct smack_rule *srp =\r\nlist_entry(list, struct smack_rule, list);\r\nseq_printf(s, "%s %s", (char *)srp->smk_subject,\r\n(char *)srp->smk_object);\r\nseq_putc(s, ' ');\r\nif (srp->smk_access & MAY_READ)\r\nseq_putc(s, 'r');\r\nif (srp->smk_access & MAY_WRITE)\r\nseq_putc(s, 'w');\r\nif (srp->smk_access & MAY_EXEC)\r\nseq_putc(s, 'x');\r\nif (srp->smk_access & MAY_APPEND)\r\nseq_putc(s, 'a');\r\nif (srp->smk_access & MAY_TRANSMUTE)\r\nseq_putc(s, 't');\r\nif (srp->smk_access == 0)\r\nseq_putc(s, '-');\r\nseq_putc(s, '\n');\r\nreturn 0;\r\n}\r\nstatic int smk_open_load_self(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &load_self_seq_ops);\r\n}\r\nstatic ssize_t smk_write_load_self(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct task_smack *tsp = current_security();\r\nreturn smk_write_load_list(file, buf, count, ppos, &tsp->smk_rules,\r\n&tsp->smk_rules_lock);\r\n}\r\nstatic ssize_t smk_write_access(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct smack_rule rule;\r\nchar *data;\r\nint res;\r\ndata = simple_transaction_get(file, buf, count);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nif (count < SMK_LOADLEN || smk_parse_rule(data, &rule, 0))\r\nreturn -EINVAL;\r\nres = smk_access(rule.smk_subject, rule.smk_object, rule.smk_access,\r\nNULL);\r\ndata[0] = res == 0 ? '1' : '0';\r\ndata[1] = '\0';\r\nsimple_transaction_set(file, 2);\r\nreturn SMK_LOADLEN;\r\n}\r\nstatic int smk_fill_super(struct super_block *sb, void *data, int silent)\r\n{\r\nint rc;\r\nstruct inode *root_inode;\r\nstatic struct tree_descr smack_files[] = {\r\n[SMK_LOAD] = {\r\n"load", &smk_load_ops, S_IRUGO|S_IWUSR},\r\n[SMK_CIPSO] = {\r\n"cipso", &smk_cipso_ops, S_IRUGO|S_IWUSR},\r\n[SMK_DOI] = {\r\n"doi", &smk_doi_ops, S_IRUGO|S_IWUSR},\r\n[SMK_DIRECT] = {\r\n"direct", &smk_direct_ops, S_IRUGO|S_IWUSR},\r\n[SMK_AMBIENT] = {\r\n"ambient", &smk_ambient_ops, S_IRUGO|S_IWUSR},\r\n[SMK_NETLBLADDR] = {\r\n"netlabel", &smk_netlbladdr_ops, S_IRUGO|S_IWUSR},\r\n[SMK_ONLYCAP] = {\r\n"onlycap", &smk_onlycap_ops, S_IRUGO|S_IWUSR},\r\n[SMK_LOGGING] = {\r\n"logging", &smk_logging_ops, S_IRUGO|S_IWUSR},\r\n[SMK_LOAD_SELF] = {\r\n"load-self", &smk_load_self_ops, S_IRUGO|S_IWUGO},\r\n[SMK_ACCESSES] = {\r\n"access", &smk_access_ops, S_IRUGO|S_IWUGO},\r\n{""}\r\n};\r\nrc = simple_fill_super(sb, SMACK_MAGIC, smack_files);\r\nif (rc != 0) {\r\nprintk(KERN_ERR "%s failed %d while creating inodes\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nroot_inode = sb->s_root->d_inode;\r\nroot_inode->i_security = new_inode_smack(smack_known_floor.smk_known);\r\nreturn 0;\r\n}\r\nstatic struct dentry *smk_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nreturn mount_single(fs_type, flags, data, smk_fill_super);\r\n}\r\nstatic int __init init_smk_fs(void)\r\n{\r\nint err;\r\nif (!security_module_enable(&smack_ops))\r\nreturn 0;\r\nerr = register_filesystem(&smk_fs_type);\r\nif (!err) {\r\nsmackfs_mount = kern_mount(&smk_fs_type);\r\nif (IS_ERR(smackfs_mount)) {\r\nprintk(KERN_ERR "smackfs: could not mount!\n");\r\nerr = PTR_ERR(smackfs_mount);\r\nsmackfs_mount = NULL;\r\n}\r\n}\r\nsmk_cipso_doi();\r\nsmk_unlbl_ambient(NULL);\r\nmutex_init(&smack_known_floor.smk_rules_lock);\r\nmutex_init(&smack_known_hat.smk_rules_lock);\r\nmutex_init(&smack_known_huh.smk_rules_lock);\r\nmutex_init(&smack_known_invalid.smk_rules_lock);\r\nmutex_init(&smack_known_star.smk_rules_lock);\r\nmutex_init(&smack_known_web.smk_rules_lock);\r\nINIT_LIST_HEAD(&smack_known_floor.smk_rules);\r\nINIT_LIST_HEAD(&smack_known_hat.smk_rules);\r\nINIT_LIST_HEAD(&smack_known_huh.smk_rules);\r\nINIT_LIST_HEAD(&smack_known_invalid.smk_rules);\r\nINIT_LIST_HEAD(&smack_known_star.smk_rules);\r\nINIT_LIST_HEAD(&smack_known_web.smk_rules);\r\nreturn err;\r\n}
