static void\r\nath5k_tx(struct ieee80211_hw *hw, struct sk_buff *skb)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nu16 qnum = skb_get_queue_mapping(skb);\r\nif (WARN_ON(qnum >= ah->ah_capabilities.cap_queues.q_tx_num)) {\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nath5k_tx_queue(hw, skb, &ah->txqs[qnum]);\r\n}\r\nstatic int\r\nath5k_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nint ret;\r\nstruct ath5k_vif *avf = (void *)vif->drv_priv;\r\nmutex_lock(&ah->lock);\r\nif ((vif->type == NL80211_IFTYPE_AP ||\r\nvif->type == NL80211_IFTYPE_ADHOC)\r\n&& (ah->num_ap_vifs + ah->num_adhoc_vifs) >= ATH_BCBUF) {\r\nret = -ELNRNG;\r\ngoto end;\r\n}\r\nif (ah->num_adhoc_vifs ||\r\n(ah->nvifs && vif->type == NL80211_IFTYPE_ADHOC)) {\r\nATH5K_ERR(ah, "Only one single ad-hoc interface is allowed.\n");\r\nret = -ELNRNG;\r\ngoto end;\r\n}\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_ADHOC:\r\ncase NL80211_IFTYPE_MESH_POINT:\r\navf->opmode = vif->type;\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\ngoto end;\r\n}\r\nah->nvifs++;\r\nATH5K_DBG(ah, ATH5K_DEBUG_MODE, "add interface mode %d\n", avf->opmode);\r\nif ((avf->opmode == NL80211_IFTYPE_AP) ||\r\n(avf->opmode == NL80211_IFTYPE_ADHOC) ||\r\n(avf->opmode == NL80211_IFTYPE_MESH_POINT)) {\r\nint slot;\r\nWARN_ON(list_empty(&ah->bcbuf));\r\navf->bbuf = list_first_entry(&ah->bcbuf, struct ath5k_buf,\r\nlist);\r\nlist_del(&avf->bbuf->list);\r\navf->bslot = 0;\r\nfor (slot = 0; slot < ATH_BCBUF; slot++) {\r\nif (!ah->bslot[slot]) {\r\navf->bslot = slot;\r\nbreak;\r\n}\r\n}\r\nBUG_ON(ah->bslot[avf->bslot] != NULL);\r\nah->bslot[avf->bslot] = vif;\r\nif (avf->opmode == NL80211_IFTYPE_AP)\r\nah->num_ap_vifs++;\r\nelse if (avf->opmode == NL80211_IFTYPE_ADHOC)\r\nah->num_adhoc_vifs++;\r\n}\r\nath5k_hw_set_lladdr(ah, vif->addr);\r\nath5k_update_bssid_mask_and_opmode(ah, vif);\r\nret = 0;\r\nend:\r\nmutex_unlock(&ah->lock);\r\nreturn ret;\r\n}\r\nstatic void\r\nath5k_remove_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nstruct ath5k_vif *avf = (void *)vif->drv_priv;\r\nunsigned int i;\r\nmutex_lock(&ah->lock);\r\nah->nvifs--;\r\nif (avf->bbuf) {\r\nath5k_txbuf_free_skb(ah, avf->bbuf);\r\nlist_add_tail(&avf->bbuf->list, &ah->bcbuf);\r\nfor (i = 0; i < ATH_BCBUF; i++) {\r\nif (ah->bslot[i] == vif) {\r\nah->bslot[i] = NULL;\r\nbreak;\r\n}\r\n}\r\navf->bbuf = NULL;\r\n}\r\nif (avf->opmode == NL80211_IFTYPE_AP)\r\nah->num_ap_vifs--;\r\nelse if (avf->opmode == NL80211_IFTYPE_ADHOC)\r\nah->num_adhoc_vifs--;\r\nath5k_update_bssid_mask_and_opmode(ah, NULL);\r\nmutex_unlock(&ah->lock);\r\n}\r\nstatic int\r\nath5k_config(struct ieee80211_hw *hw, u32 changed)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nint ret = 0;\r\nint i;\r\nmutex_lock(&ah->lock);\r\nif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\r\nret = ath5k_chan_set(ah, conf->channel);\r\nif (ret < 0)\r\ngoto unlock;\r\n}\r\nif ((changed & IEEE80211_CONF_CHANGE_POWER) &&\r\n(ah->power_level != conf->power_level)) {\r\nah->power_level = conf->power_level;\r\nath5k_hw_set_txpower_limit(ah, (conf->power_level * 2));\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS) {\r\nah->ah_retry_long = conf->long_frame_max_tx_count;\r\nah->ah_retry_short = conf->short_frame_max_tx_count;\r\nfor (i = 0; i < ah->ah_capabilities.cap_queues.q_tx_num; i++)\r\nath5k_hw_set_tx_retry_limits(ah, i);\r\n}\r\nath5k_hw_set_antenna_mode(ah, ah->ah_ant_mode);\r\nunlock:\r\nmutex_unlock(&ah->lock);\r\nreturn ret;\r\n}\r\nstatic void\r\nath5k_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *bss_conf, u32 changes)\r\n{\r\nstruct ath5k_vif *avf = (void *)vif->drv_priv;\r\nstruct ath5k_hw *ah = hw->priv;\r\nstruct ath_common *common = ath5k_hw_common(ah);\r\nunsigned long flags;\r\nmutex_lock(&ah->lock);\r\nif (changes & BSS_CHANGED_BSSID) {\r\nmemcpy(common->curbssid, bss_conf->bssid, ETH_ALEN);\r\ncommon->curaid = 0;\r\nath5k_hw_set_bssid(ah);\r\nmmiowb();\r\n}\r\nif (changes & BSS_CHANGED_BEACON_INT)\r\nah->bintval = bss_conf->beacon_int;\r\nif (changes & BSS_CHANGED_ERP_SLOT) {\r\nint slot_time;\r\nah->ah_short_slot = bss_conf->use_short_slot;\r\nslot_time = ath5k_hw_get_default_slottime(ah) +\r\n3 * ah->ah_coverage_class;\r\nath5k_hw_set_ifs_intervals(ah, slot_time);\r\n}\r\nif (changes & BSS_CHANGED_ASSOC) {\r\navf->assoc = bss_conf->assoc;\r\nif (bss_conf->assoc)\r\nah->assoc = bss_conf->assoc;\r\nelse\r\nah->assoc = ath5k_any_vif_assoc(ah);\r\nif (ah->opmode == NL80211_IFTYPE_STATION)\r\nath5k_set_beacon_filter(hw, ah->assoc);\r\nath5k_hw_set_ledstate(ah, ah->assoc ?\r\nAR5K_LED_ASSOC : AR5K_LED_INIT);\r\nif (bss_conf->assoc) {\r\nATH5K_DBG(ah, ATH5K_DEBUG_ANY,\r\n"Bss Info ASSOC %d, bssid: %pM\n",\r\nbss_conf->aid, common->curbssid);\r\ncommon->curaid = bss_conf->aid;\r\nath5k_hw_set_bssid(ah);\r\n}\r\n}\r\nif (changes & BSS_CHANGED_BEACON) {\r\nspin_lock_irqsave(&ah->block, flags);\r\nath5k_beacon_update(hw, vif);\r\nspin_unlock_irqrestore(&ah->block, flags);\r\n}\r\nif (changes & BSS_CHANGED_BEACON_ENABLED)\r\nah->enable_beacon = bss_conf->enable_beacon;\r\nif (changes & (BSS_CHANGED_BEACON | BSS_CHANGED_BEACON_ENABLED |\r\nBSS_CHANGED_BEACON_INT))\r\nath5k_beacon_config(ah);\r\nmutex_unlock(&ah->lock);\r\n}\r\nstatic u64\r\nath5k_prepare_multicast(struct ieee80211_hw *hw,\r\nstruct netdev_hw_addr_list *mc_list)\r\n{\r\nu32 mfilt[2], val;\r\nu8 pos;\r\nstruct netdev_hw_addr *ha;\r\nmfilt[0] = 0;\r\nmfilt[1] = 1;\r\nnetdev_hw_addr_list_for_each(ha, mc_list) {\r\nval = get_unaligned_le32(ha->addr + 0);\r\npos = (val >> 18) ^ (val >> 12) ^ (val >> 6) ^ val;\r\nval = get_unaligned_le32(ha->addr + 3);\r\npos ^= (val >> 18) ^ (val >> 12) ^ (val >> 6) ^ val;\r\npos &= 0x3f;\r\nmfilt[pos / 32] |= (1 << (pos % 32));\r\n}\r\nreturn ((u64)(mfilt[1]) << 32) | mfilt[0];\r\n}\r\nstatic void\r\nath5k_configure_filter(struct ieee80211_hw *hw, unsigned int changed_flags,\r\nunsigned int *new_flags, u64 multicast)\r\n{\r\n#define SUPPORTED_FIF_FLAGS \\r\n(FIF_PROMISC_IN_BSS | FIF_ALLMULTI | FIF_FCSFAIL | \\r\nFIF_PLCPFAIL | FIF_CONTROL | FIF_OTHER_BSS | \\r\nFIF_BCN_PRBRESP_PROMISC)\r\nstruct ath5k_hw *ah = hw->priv;\r\nu32 mfilt[2], rfilt;\r\nstruct ath5k_vif_iter_data iter_data;\r\nmutex_lock(&ah->lock);\r\nmfilt[0] = multicast;\r\nmfilt[1] = multicast >> 32;\r\nchanged_flags &= SUPPORTED_FIF_FLAGS;\r\n*new_flags &= SUPPORTED_FIF_FLAGS;\r\nrfilt = (ath5k_hw_get_rx_filter(ah) & (AR5K_RX_FILTER_PHYERR)) |\r\n(AR5K_RX_FILTER_UCAST | AR5K_RX_FILTER_BCAST |\r\nAR5K_RX_FILTER_MCAST);\r\nif (changed_flags & (FIF_PROMISC_IN_BSS | FIF_OTHER_BSS)) {\r\nif (*new_flags & FIF_PROMISC_IN_BSS)\r\n__set_bit(ATH_STAT_PROMISC, ah->status);\r\nelse\r\n__clear_bit(ATH_STAT_PROMISC, ah->status);\r\n}\r\nif (test_bit(ATH_STAT_PROMISC, ah->status))\r\nrfilt |= AR5K_RX_FILTER_PROM;\r\nif (*new_flags & FIF_ALLMULTI) {\r\nmfilt[0] = ~0;\r\nmfilt[1] = ~0;\r\n}\r\nif (*new_flags & (FIF_FCSFAIL | FIF_PLCPFAIL))\r\nrfilt |= AR5K_RX_FILTER_PHYERR;\r\nif ((*new_flags & FIF_BCN_PRBRESP_PROMISC) || (ah->nvifs > 1))\r\nrfilt |= AR5K_RX_FILTER_BEACON;\r\nif (*new_flags & FIF_CONTROL)\r\nrfilt |= AR5K_RX_FILTER_CONTROL;\r\nswitch (ah->opmode) {\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nrfilt |= AR5K_RX_FILTER_CONTROL |\r\nAR5K_RX_FILTER_BEACON |\r\nAR5K_RX_FILTER_PROBEREQ |\r\nAR5K_RX_FILTER_PROM;\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_ADHOC:\r\nrfilt |= AR5K_RX_FILTER_PROBEREQ |\r\nAR5K_RX_FILTER_BEACON;\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\nif (ah->assoc)\r\nrfilt |= AR5K_RX_FILTER_BEACON;\r\ndefault:\r\nbreak;\r\n}\r\niter_data.hw_macaddr = NULL;\r\niter_data.n_stas = 0;\r\niter_data.need_set_hw_addr = false;\r\nieee80211_iterate_active_interfaces_atomic(ah->hw, ath5k_vif_iter,\r\n&iter_data);\r\nif (iter_data.n_stas > 1) {\r\nrfilt |= AR5K_RX_FILTER_PROM;\r\n}\r\nath5k_hw_set_rx_filter(ah, rfilt);\r\nath5k_hw_set_mcast_filter(ah, mfilt[0], mfilt[1]);\r\nah->filter_flags = rfilt;\r\nmutex_unlock(&ah->lock);\r\n}\r\nstatic int\r\nath5k_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\r\nstruct ieee80211_vif *vif, struct ieee80211_sta *sta,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nstruct ath_common *common = ath5k_hw_common(ah);\r\nint ret = 0;\r\nif (ath5k_modparam_nohwcrypt)\r\nreturn -EOPNOTSUPP;\r\nswitch (key->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nif (common->crypt_caps & ATH_CRYPT_CAP_CIPHER_AESCCM)\r\nbreak;\r\nreturn -EOPNOTSUPP;\r\ndefault:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&ah->lock);\r\nswitch (cmd) {\r\ncase SET_KEY:\r\nret = ath_key_config(common, vif, sta, key);\r\nif (ret >= 0) {\r\nkey->hw_key_idx = ret;\r\nkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\r\nif (key->cipher == WLAN_CIPHER_SUITE_TKIP)\r\nkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\r\nif (key->cipher == WLAN_CIPHER_SUITE_CCMP)\r\nkey->flags |= IEEE80211_KEY_FLAG_SW_MGMT;\r\nret = 0;\r\n}\r\nbreak;\r\ncase DISABLE_KEY:\r\nath_key_delete(common, key);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmmiowb();\r\nmutex_unlock(&ah->lock);\r\nreturn ret;\r\n}\r\nstatic void\r\nath5k_sw_scan_start(struct ieee80211_hw *hw)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nif (!ah->assoc)\r\nath5k_hw_set_ledstate(ah, AR5K_LED_SCAN);\r\n}\r\nstatic void\r\nath5k_sw_scan_complete(struct ieee80211_hw *hw)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nath5k_hw_set_ledstate(ah, ah->assoc ?\r\nAR5K_LED_ASSOC : AR5K_LED_INIT);\r\n}\r\nstatic int\r\nath5k_get_stats(struct ieee80211_hw *hw,\r\nstruct ieee80211_low_level_stats *stats)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nath5k_hw_update_mib_counters(ah);\r\nstats->dot11ACKFailureCount = ah->stats.ack_fail;\r\nstats->dot11RTSFailureCount = ah->stats.rts_fail;\r\nstats->dot11RTSSuccessCount = ah->stats.rts_ok;\r\nstats->dot11FCSErrorCount = ah->stats.fcs_error;\r\nreturn 0;\r\n}\r\nstatic int\r\nath5k_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif, u16 queue,\r\nconst struct ieee80211_tx_queue_params *params)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nstruct ath5k_txq_info qi;\r\nint ret = 0;\r\nif (queue >= ah->ah_capabilities.cap_queues.q_tx_num)\r\nreturn 0;\r\nmutex_lock(&ah->lock);\r\nath5k_hw_get_tx_queueprops(ah, queue, &qi);\r\nqi.tqi_aifs = params->aifs;\r\nqi.tqi_cw_min = params->cw_min;\r\nqi.tqi_cw_max = params->cw_max;\r\nqi.tqi_burst_time = params->txop;\r\nATH5K_DBG(ah, ATH5K_DEBUG_ANY,\r\n"Configure tx [queue %d], "\r\n"aifs: %d, cw_min: %d, cw_max: %d, txop: %d\n",\r\nqueue, params->aifs, params->cw_min,\r\nparams->cw_max, params->txop);\r\nif (ath5k_hw_set_tx_queueprops(ah, queue, &qi)) {\r\nATH5K_ERR(ah,\r\n"Unable to update hardware queue %u!\n", queue);\r\nret = -EIO;\r\n} else\r\nath5k_hw_reset_tx_queue(ah, queue);\r\nmutex_unlock(&ah->lock);\r\nreturn ret;\r\n}\r\nstatic u64\r\nath5k_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nreturn ath5k_hw_get_tsf64(ah);\r\n}\r\nstatic void\r\nath5k_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif, u64 tsf)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nath5k_hw_set_tsf64(ah, tsf);\r\n}\r\nstatic void\r\nath5k_reset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nif (ah->opmode == NL80211_IFTYPE_ADHOC)\r\nath5k_beacon_update_timers(ah, 0);\r\nelse\r\nath5k_hw_reset_tsf(ah);\r\n}\r\nstatic int\r\nath5k_get_survey(struct ieee80211_hw *hw, int idx, struct survey_info *survey)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nstruct ath_common *common = ath5k_hw_common(ah);\r\nstruct ath_cycle_counters *cc = &common->cc_survey;\r\nunsigned int div = common->clockrate * 1000;\r\nif (idx != 0)\r\nreturn -ENOENT;\r\nspin_lock_bh(&common->cc_lock);\r\nath_hw_cycle_counters_update(common);\r\nif (cc->cycles > 0) {\r\nah->survey.channel_time += cc->cycles / div;\r\nah->survey.channel_time_busy += cc->rx_busy / div;\r\nah->survey.channel_time_rx += cc->rx_frame / div;\r\nah->survey.channel_time_tx += cc->tx_frame / div;\r\n}\r\nmemset(cc, 0, sizeof(*cc));\r\nspin_unlock_bh(&common->cc_lock);\r\nmemcpy(survey, &ah->survey, sizeof(*survey));\r\nsurvey->channel = conf->channel;\r\nsurvey->noise = ah->ah_noise_floor;\r\nsurvey->filled = SURVEY_INFO_NOISE_DBM |\r\nSURVEY_INFO_CHANNEL_TIME |\r\nSURVEY_INFO_CHANNEL_TIME_BUSY |\r\nSURVEY_INFO_CHANNEL_TIME_RX |\r\nSURVEY_INFO_CHANNEL_TIME_TX;\r\nreturn 0;\r\n}\r\nstatic void\r\nath5k_set_coverage_class(struct ieee80211_hw *hw, u8 coverage_class)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nmutex_lock(&ah->lock);\r\nath5k_hw_set_coverage_class(ah, coverage_class);\r\nmutex_unlock(&ah->lock);\r\n}\r\nstatic int\r\nath5k_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nif (tx_ant == 1 && rx_ant == 1)\r\nath5k_hw_set_antenna_mode(ah, AR5K_ANTMODE_FIXED_A);\r\nelse if (tx_ant == 2 && rx_ant == 2)\r\nath5k_hw_set_antenna_mode(ah, AR5K_ANTMODE_FIXED_B);\r\nelse if ((tx_ant & 3) == 3 && (rx_ant & 3) == 3)\r\nath5k_hw_set_antenna_mode(ah, AR5K_ANTMODE_DEFAULT);\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nath5k_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nswitch (ah->ah_ant_mode) {\r\ncase AR5K_ANTMODE_FIXED_A:\r\n*tx_ant = 1; *rx_ant = 1; break;\r\ncase AR5K_ANTMODE_FIXED_B:\r\n*tx_ant = 2; *rx_ant = 2; break;\r\ncase AR5K_ANTMODE_DEFAULT:\r\n*tx_ant = 3; *rx_ant = 3; break;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ath5k_get_ringparam(struct ieee80211_hw *hw,\r\nu32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\n*tx = ah->txqs[AR5K_TX_QUEUE_ID_DATA_MIN].txq_max;\r\n*tx_max = ATH5K_TXQ_LEN_MAX;\r\n*rx = *rx_max = ATH_RXBUF;\r\n}\r\nstatic int ath5k_set_ringparam(struct ieee80211_hw *hw, u32 tx, u32 rx)\r\n{\r\nstruct ath5k_hw *ah = hw->priv;\r\nu16 qnum;\r\nif (rx != ATH_RXBUF)\r\nreturn -EINVAL;\r\nif (!tx || tx > ATH5K_TXQ_LEN_MAX)\r\nreturn -EINVAL;\r\nfor (qnum = 0; qnum < ARRAY_SIZE(ah->txqs); qnum++) {\r\nif (!ah->txqs[qnum].setup)\r\ncontinue;\r\nif (ah->txqs[qnum].qnum < AR5K_TX_QUEUE_ID_DATA_MIN ||\r\nah->txqs[qnum].qnum > AR5K_TX_QUEUE_ID_DATA_MAX)\r\ncontinue;\r\nah->txqs[qnum].txq_max = tx;\r\nif (ah->txqs[qnum].txq_len >= ah->txqs[qnum].txq_max)\r\nieee80211_stop_queue(hw, ah->txqs[qnum].qnum);\r\n}\r\nreturn 0;\r\n}
