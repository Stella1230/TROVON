static u32 bcma_chipco_pll_read(struct bcma_drv_cc *cc, u32 offset)\r\n{\r\nbcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR, offset);\r\nbcma_cc_read32(cc, BCMA_CC_PLLCTL_ADDR);\r\nreturn bcma_cc_read32(cc, BCMA_CC_PLLCTL_DATA);\r\n}\r\nvoid bcma_chipco_pll_write(struct bcma_drv_cc *cc, u32 offset, u32 value)\r\n{\r\nbcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR, offset);\r\nbcma_cc_read32(cc, BCMA_CC_PLLCTL_ADDR);\r\nbcma_cc_write32(cc, BCMA_CC_PLLCTL_DATA, value);\r\n}\r\nvoid bcma_chipco_pll_maskset(struct bcma_drv_cc *cc, u32 offset, u32 mask,\r\nu32 set)\r\n{\r\nbcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR, offset);\r\nbcma_cc_read32(cc, BCMA_CC_PLLCTL_ADDR);\r\nbcma_cc_maskset32(cc, BCMA_CC_PLLCTL_DATA, mask, set);\r\n}\r\nvoid bcma_chipco_chipctl_maskset(struct bcma_drv_cc *cc,\r\nu32 offset, u32 mask, u32 set)\r\n{\r\nbcma_cc_write32(cc, BCMA_CC_CHIPCTL_ADDR, offset);\r\nbcma_cc_read32(cc, BCMA_CC_CHIPCTL_ADDR);\r\nbcma_cc_maskset32(cc, BCMA_CC_CHIPCTL_DATA, mask, set);\r\n}\r\nvoid bcma_chipco_regctl_maskset(struct bcma_drv_cc *cc, u32 offset, u32 mask,\r\nu32 set)\r\n{\r\nbcma_cc_write32(cc, BCMA_CC_REGCTL_ADDR, offset);\r\nbcma_cc_read32(cc, BCMA_CC_REGCTL_ADDR);\r\nbcma_cc_maskset32(cc, BCMA_CC_REGCTL_DATA, mask, set);\r\n}\r\nstatic void bcma_pmu_pll_init(struct bcma_drv_cc *cc)\r\n{\r\nstruct bcma_bus *bus = cc->core->bus;\r\nswitch (bus->chipinfo.id) {\r\ncase 0x4313:\r\ncase 0x4331:\r\ncase 43224:\r\ncase 43225:\r\nbreak;\r\ndefault:\r\npr_err("PLL init unknown for device 0x%04X\n",\r\nbus->chipinfo.id);\r\n}\r\n}\r\nstatic void bcma_pmu_resources_init(struct bcma_drv_cc *cc)\r\n{\r\nstruct bcma_bus *bus = cc->core->bus;\r\nu32 min_msk = 0, max_msk = 0;\r\nswitch (bus->chipinfo.id) {\r\ncase 0x4313:\r\nmin_msk = 0x200D;\r\nmax_msk = 0xFFFF;\r\nbreak;\r\ncase 43224:\r\ncase 43225:\r\nbreak;\r\ndefault:\r\npr_err("PMU resource config unknown for device 0x%04X\n",\r\nbus->chipinfo.id);\r\n}\r\nif (min_msk)\r\nbcma_cc_write32(cc, BCMA_CC_PMU_MINRES_MSK, min_msk);\r\nif (max_msk)\r\nbcma_cc_write32(cc, BCMA_CC_PMU_MAXRES_MSK, max_msk);\r\n}\r\nvoid bcma_pmu_swreg_init(struct bcma_drv_cc *cc)\r\n{\r\nstruct bcma_bus *bus = cc->core->bus;\r\nswitch (bus->chipinfo.id) {\r\ncase 0x4313:\r\ncase 0x4331:\r\ncase 43224:\r\ncase 43225:\r\nbreak;\r\ndefault:\r\npr_err("PMU switch/regulators init unknown for device "\r\n"0x%04X\n", bus->chipinfo.id);\r\n}\r\n}\r\nvoid bcma_chipco_bcm4331_ext_pa_lines_ctl(struct bcma_drv_cc *cc, bool enable)\r\n{\r\nstruct bcma_bus *bus = cc->core->bus;\r\nu32 val;\r\nval = bcma_cc_read32(cc, BCMA_CC_CHIPCTL);\r\nif (enable) {\r\nval |= BCMA_CHIPCTL_4331_EXTPA_EN;\r\nif (bus->chipinfo.pkg == 9 || bus->chipinfo.pkg == 11)\r\nval |= BCMA_CHIPCTL_4331_EXTPA_ON_GPIO2_5;\r\n} else {\r\nval &= ~BCMA_CHIPCTL_4331_EXTPA_EN;\r\nval &= ~BCMA_CHIPCTL_4331_EXTPA_ON_GPIO2_5;\r\n}\r\nbcma_cc_write32(cc, BCMA_CC_CHIPCTL, val);\r\n}\r\nvoid bcma_pmu_workarounds(struct bcma_drv_cc *cc)\r\n{\r\nstruct bcma_bus *bus = cc->core->bus;\r\nswitch (bus->chipinfo.id) {\r\ncase 0x4313:\r\nbcma_chipco_chipctl_maskset(cc, 0, ~0, 0x7);\r\nbreak;\r\ncase 0x4331:\r\nbreak;\r\ncase 43224:\r\nif (bus->chipinfo.rev == 0) {\r\npr_err("Workarounds for 43224 rev 0 not fully "\r\n"implemented\n");\r\nbcma_chipco_chipctl_maskset(cc, 0, ~0, 0x00F000F0);\r\n} else {\r\nbcma_chipco_chipctl_maskset(cc, 0, ~0, 0xF0);\r\n}\r\nbreak;\r\ncase 43225:\r\nbreak;\r\ndefault:\r\npr_err("Workarounds unknown for device 0x%04X\n",\r\nbus->chipinfo.id);\r\n}\r\n}\r\nvoid bcma_pmu_init(struct bcma_drv_cc *cc)\r\n{\r\nu32 pmucap;\r\npmucap = bcma_cc_read32(cc, BCMA_CC_PMU_CAP);\r\ncc->pmu.rev = (pmucap & BCMA_CC_PMU_CAP_REVISION);\r\npr_debug("Found rev %u PMU (capabilities 0x%08X)\n", cc->pmu.rev,\r\npmucap);\r\nif (cc->pmu.rev == 1)\r\nbcma_cc_mask32(cc, BCMA_CC_PMU_CTL,\r\n~BCMA_CC_PMU_CTL_NOILPONW);\r\nelse\r\nbcma_cc_set32(cc, BCMA_CC_PMU_CTL,\r\nBCMA_CC_PMU_CTL_NOILPONW);\r\nif (cc->core->id.id == 0x4329 && cc->core->id.rev == 2)\r\npr_err("Fix for 4329b0 bad LPOM state not implemented!\n");\r\nbcma_pmu_pll_init(cc);\r\nbcma_pmu_resources_init(cc);\r\nbcma_pmu_swreg_init(cc);\r\nbcma_pmu_workarounds(cc);\r\n}\r\nu32 bcma_pmu_alp_clock(struct bcma_drv_cc *cc)\r\n{\r\nstruct bcma_bus *bus = cc->core->bus;\r\nswitch (bus->chipinfo.id) {\r\ncase 0x4716:\r\ncase 0x4748:\r\ncase 47162:\r\ncase 0x4313:\r\ncase 0x5357:\r\ncase 0x4749:\r\ncase 53572:\r\nreturn 20000 * 1000;\r\ncase 0x5356:\r\ncase 0x5300:\r\nreturn 25000 * 1000;\r\ndefault:\r\npr_warn("No ALP clock specified for %04X device, "\r\n"pmu rev. %d, using default %d Hz\n",\r\nbus->chipinfo.id, cc->pmu.rev, BCMA_CC_PMU_ALP_CLOCK);\r\n}\r\nreturn BCMA_CC_PMU_ALP_CLOCK;\r\n}\r\nstatic u32 bcma_pmu_clock(struct bcma_drv_cc *cc, u32 pll0, u32 m)\r\n{\r\nu32 tmp, div, ndiv, p1, p2, fc;\r\nstruct bcma_bus *bus = cc->core->bus;\r\nBUG_ON((pll0 & 3) || (pll0 > BCMA_CC_PMU4716_MAINPLL_PLL0));\r\nBUG_ON(!m || m > 4);\r\nif (bus->chipinfo.id == 0x5357 || bus->chipinfo.id == 0x4749) {\r\ntmp = bcma_cc_read32(cc, BCMA_CC_CHIPSTAT);\r\nif (tmp & 0x40000)\r\nreturn 133 * 1000000;\r\n}\r\ntmp = bcma_chipco_pll_read(cc, pll0 + BCMA_CC_PPL_P1P2_OFF);\r\np1 = (tmp & BCMA_CC_PPL_P1_MASK) >> BCMA_CC_PPL_P1_SHIFT;\r\np2 = (tmp & BCMA_CC_PPL_P2_MASK) >> BCMA_CC_PPL_P2_SHIFT;\r\ntmp = bcma_chipco_pll_read(cc, pll0 + BCMA_CC_PPL_M14_OFF);\r\ndiv = (tmp >> ((m - 1) * BCMA_CC_PPL_MDIV_WIDTH)) &\r\nBCMA_CC_PPL_MDIV_MASK;\r\ntmp = bcma_chipco_pll_read(cc, pll0 + BCMA_CC_PPL_NM5_OFF);\r\nndiv = (tmp & BCMA_CC_PPL_NDIV_MASK) >> BCMA_CC_PPL_NDIV_SHIFT;\r\nfc = bcma_pmu_alp_clock(cc) / 1000000;\r\nfc = (p1 * ndiv * fc) / p2;\r\nreturn (fc / div) * 1000000;\r\n}\r\nu32 bcma_pmu_get_clockcontrol(struct bcma_drv_cc *cc)\r\n{\r\nstruct bcma_bus *bus = cc->core->bus;\r\nswitch (bus->chipinfo.id) {\r\ncase 0x4716:\r\ncase 0x4748:\r\ncase 47162:\r\nreturn bcma_pmu_clock(cc, BCMA_CC_PMU4716_MAINPLL_PLL0,\r\nBCMA_CC_PMU5_MAINPLL_SSB);\r\ncase 0x5356:\r\nreturn bcma_pmu_clock(cc, BCMA_CC_PMU5356_MAINPLL_PLL0,\r\nBCMA_CC_PMU5_MAINPLL_SSB);\r\ncase 0x5357:\r\ncase 0x4749:\r\nreturn bcma_pmu_clock(cc, BCMA_CC_PMU5357_MAINPLL_PLL0,\r\nBCMA_CC_PMU5_MAINPLL_SSB);\r\ncase 0x5300:\r\nreturn bcma_pmu_clock(cc, BCMA_CC_PMU4706_MAINPLL_PLL0,\r\nBCMA_CC_PMU5_MAINPLL_SSB);\r\ncase 53572:\r\nreturn 75000000;\r\ndefault:\r\npr_warn("No backplane clock specified for %04X device, "\r\n"pmu rev. %d, using default %d Hz\n",\r\nbus->chipinfo.id, cc->pmu.rev, BCMA_CC_PMU_HT_CLOCK);\r\n}\r\nreturn BCMA_CC_PMU_HT_CLOCK;\r\n}\r\nu32 bcma_pmu_get_clockcpu(struct bcma_drv_cc *cc)\r\n{\r\nstruct bcma_bus *bus = cc->core->bus;\r\nif (bus->chipinfo.id == 53572)\r\nreturn 300000000;\r\nif (cc->pmu.rev >= 5) {\r\nu32 pll;\r\nswitch (bus->chipinfo.id) {\r\ncase 0x5356:\r\npll = BCMA_CC_PMU5356_MAINPLL_PLL0;\r\nbreak;\r\ncase 0x5357:\r\ncase 0x4749:\r\npll = BCMA_CC_PMU5357_MAINPLL_PLL0;\r\nbreak;\r\ndefault:\r\npll = BCMA_CC_PMU4716_MAINPLL_PLL0;\r\nbreak;\r\n}\r\nreturn bcma_pmu_clock(cc, pll, BCMA_CC_PMU5_MAINPLL_CPU);\r\n}\r\nreturn bcma_pmu_get_clockcontrol(cc);\r\n}
