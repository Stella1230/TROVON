static void sclp_rw_pm_event(struct sclp_register *reg,\r\nenum sclp_pm_event sclp_pm_event)\r\n{\r\nsclp_console_pm_event(sclp_pm_event);\r\n}\r\nstruct sclp_buffer *\r\nsclp_make_buffer(void *page, unsigned short columns, unsigned short htab)\r\n{\r\nstruct sclp_buffer *buffer;\r\nstruct write_sccb *sccb;\r\nsccb = (struct write_sccb *) page;\r\nbuffer = ((struct sclp_buffer *) ((addr_t) sccb + PAGE_SIZE)) - 1;\r\nbuffer->sccb = sccb;\r\nbuffer->retry_count = 0;\r\nbuffer->mto_number = 0;\r\nbuffer->mto_char_sum = 0;\r\nbuffer->current_line = NULL;\r\nbuffer->current_length = 0;\r\nbuffer->columns = columns;\r\nbuffer->htab = htab;\r\nmemset(sccb, 0, sizeof(struct write_sccb));\r\nsccb->header.length = sizeof(struct write_sccb);\r\nsccb->msg_buf.header.length = sizeof(struct msg_buf);\r\nsccb->msg_buf.header.type = EVTYP_MSG;\r\nsccb->msg_buf.mdb.header.length = sizeof(struct mdb);\r\nsccb->msg_buf.mdb.header.type = 1;\r\nsccb->msg_buf.mdb.header.tag = 0xD4C4C240;\r\nsccb->msg_buf.mdb.header.revision_code = 1;\r\nsccb->msg_buf.mdb.go.length = sizeof(struct go);\r\nsccb->msg_buf.mdb.go.type = 1;\r\nreturn buffer;\r\n}\r\nvoid *\r\nsclp_unmake_buffer(struct sclp_buffer *buffer)\r\n{\r\nreturn buffer->sccb;\r\n}\r\nstatic int\r\nsclp_initialize_mto(struct sclp_buffer *buffer, int max_len)\r\n{\r\nstruct write_sccb *sccb;\r\nstruct mto *mto;\r\nint mto_size;\r\nmto_size = sizeof(struct mto) + max_len;\r\nsccb = buffer->sccb;\r\nif ((MAX_SCCB_ROOM - sccb->header.length) < mto_size)\r\nreturn -ENOMEM;\r\nmto = (struct mto *)(((addr_t) sccb) + sccb->header.length);\r\nmemset(mto, 0, sizeof(struct mto));\r\nmto->length = sizeof(struct mto);\r\nmto->type = 4;\r\nmto->line_type_flags = LNTPFLGS_ENDTEXT;\r\nbuffer->current_line = (char *) (mto + 1);\r\nbuffer->current_length = 0;\r\nreturn 0;\r\n}\r\nstatic void\r\nsclp_finalize_mto(struct sclp_buffer *buffer)\r\n{\r\nstruct write_sccb *sccb;\r\nstruct mto *mto;\r\nint str_len, mto_size;\r\nstr_len = buffer->current_length;\r\nbuffer->current_line = NULL;\r\nbuffer->current_length = 0;\r\nmto_size = sizeof(struct mto) + str_len;\r\nsccb = buffer->sccb;\r\nmto = (struct mto *)(((addr_t) sccb) + sccb->header.length);\r\nmto->length = mto_size;\r\nsccb->header.length += mto_size;\r\nsccb->msg_buf.header.length += mto_size;\r\nsccb->msg_buf.mdb.header.length += mto_size;\r\nbuffer->mto_number++;\r\nbuffer->mto_char_sum += str_len;\r\n}\r\nint\r\nsclp_write(struct sclp_buffer *buffer, const unsigned char *msg, int count)\r\n{\r\nint spaces, i_msg;\r\nint rc;\r\nfor (i_msg = 0; i_msg < count; i_msg++) {\r\nswitch (msg[i_msg]) {\r\ncase '\n':\r\nif (buffer->current_line == NULL) {\r\nrc = sclp_initialize_mto(buffer, 0);\r\nif (rc)\r\nreturn i_msg;\r\n}\r\nsclp_finalize_mto(buffer);\r\nbreak;\r\ncase '\a':\r\nbuffer->sccb->msg_buf.mdb.go.general_msg_flags |=\r\nGNRLMSGFLGS_SNDALRM;\r\nbreak;\r\ncase '\t':\r\nif (buffer->current_line == NULL) {\r\nrc = sclp_initialize_mto(buffer,\r\nbuffer->columns);\r\nif (rc)\r\nreturn i_msg;\r\n}\r\ndo {\r\nif (buffer->current_length >= buffer->columns)\r\nbreak;\r\n*buffer->current_line++ = 0x40;\r\nbuffer->current_length++;\r\n} while (buffer->current_length % buffer->htab);\r\nbreak;\r\ncase '\f':\r\ncase '\v':\r\nif (buffer->current_line != NULL) {\r\nspaces = buffer->current_length;\r\nsclp_finalize_mto(buffer);\r\nrc = sclp_initialize_mto(buffer,\r\nbuffer->columns);\r\nif (rc)\r\nreturn i_msg;\r\nmemset(buffer->current_line, 0x40, spaces);\r\nbuffer->current_line += spaces;\r\nbuffer->current_length = spaces;\r\n} else {\r\nrc = sclp_initialize_mto(buffer,\r\nbuffer->columns);\r\nif (rc)\r\nreturn i_msg;\r\nsclp_finalize_mto(buffer);\r\n}\r\nbreak;\r\ncase '\b':\r\nif (buffer->current_line != NULL &&\r\nbuffer->current_length > 0) {\r\nbuffer->current_length--;\r\nbuffer->current_line--;\r\n}\r\nbreak;\r\ncase 0x00:\r\nif (buffer->current_line != NULL)\r\nsclp_finalize_mto(buffer);\r\ni_msg = count - 1;\r\nbreak;\r\ndefault:\r\nif (!isprint(msg[i_msg]))\r\nbreak;\r\nif (buffer->current_line == NULL) {\r\nrc = sclp_initialize_mto(buffer,\r\nbuffer->columns);\r\nif (rc)\r\nreturn i_msg;\r\n}\r\n*buffer->current_line++ = sclp_ascebc(msg[i_msg]);\r\nbuffer->current_length++;\r\nbreak;\r\n}\r\nif (buffer->current_line != NULL &&\r\nbuffer->current_length >= buffer->columns)\r\nsclp_finalize_mto(buffer);\r\n}\r\nreturn i_msg;\r\n}\r\nint\r\nsclp_buffer_space(struct sclp_buffer *buffer)\r\n{\r\nint count;\r\ncount = MAX_SCCB_ROOM - buffer->sccb->header.length;\r\nif (buffer->current_line != NULL)\r\ncount -= sizeof(struct mto) + buffer->current_length;\r\nreturn count;\r\n}\r\nint\r\nsclp_chars_in_buffer(struct sclp_buffer *buffer)\r\n{\r\nint count;\r\ncount = buffer->mto_char_sum;\r\nif (buffer->current_line != NULL)\r\ncount += buffer->current_length;\r\nreturn count;\r\n}\r\nvoid\r\nsclp_set_columns(struct sclp_buffer *buffer, unsigned short columns)\r\n{\r\nbuffer->columns = columns;\r\nif (buffer->current_line != NULL &&\r\nbuffer->current_length > buffer->columns)\r\nsclp_finalize_mto(buffer);\r\n}\r\nvoid\r\nsclp_set_htab(struct sclp_buffer *buffer, unsigned short htab)\r\n{\r\nbuffer->htab = htab;\r\n}\r\nint\r\nsclp_rw_init(void)\r\n{\r\nstatic int init_done = 0;\r\nint rc;\r\nif (init_done)\r\nreturn 0;\r\nrc = sclp_register(&sclp_rw_event);\r\nif (rc == 0)\r\ninit_done = 1;\r\nreturn rc;\r\n}\r\nstatic void\r\nsclp_writedata_callback(struct sclp_req *request, void *data)\r\n{\r\nint rc;\r\nstruct sclp_buffer *buffer;\r\nstruct write_sccb *sccb;\r\nbuffer = (struct sclp_buffer *) data;\r\nsccb = buffer->sccb;\r\nif (request->status == SCLP_REQ_FAILED) {\r\nif (buffer->callback != NULL)\r\nbuffer->callback(buffer, -EIO);\r\nreturn;\r\n}\r\nswitch (sccb->header.response_code) {\r\ncase 0x0020 :\r\nrc = 0;\r\nbreak;\r\ncase 0x0340:\r\nif (++buffer->retry_count > SCLP_BUFFER_MAX_RETRY) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\nif (sclp_remove_processed((struct sccb_header *) sccb) > 0) {\r\nsccb->header.response_code = 0x0000;\r\nbuffer->request.status = SCLP_REQ_FILLED;\r\nrc = sclp_add_request(request);\r\nif (rc == 0)\r\nreturn;\r\n} else\r\nrc = 0;\r\nbreak;\r\ncase 0x0040:\r\ncase 0x05f0:\r\nif (++buffer->retry_count > SCLP_BUFFER_MAX_RETRY) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\nsccb->header.response_code = 0x0000;\r\nbuffer->request.status = SCLP_REQ_FILLED;\r\nrc = sclp_add_request(request);\r\nif (rc == 0)\r\nreturn;\r\nbreak;\r\ndefault:\r\nif (sccb->header.response_code == 0x71f0)\r\nrc = -ENOMEM;\r\nelse\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nif (buffer->callback != NULL)\r\nbuffer->callback(buffer, rc);\r\n}\r\nint\r\nsclp_emit_buffer(struct sclp_buffer *buffer,\r\nvoid (*callback)(struct sclp_buffer *, int))\r\n{\r\nstruct write_sccb *sccb;\r\nif (buffer->current_line != NULL)\r\nsclp_finalize_mto(buffer);\r\nif (buffer->mto_number == 0)\r\nreturn -EIO;\r\nsccb = buffer->sccb;\r\nif (sclp_rw_event.sclp_receive_mask & EVTYP_MSG_MASK)\r\nsccb->msg_buf.header.type = EVTYP_MSG;\r\nelse if (sclp_rw_event.sclp_receive_mask & EVTYP_PMSGCMD_MASK)\r\nsccb->msg_buf.header.type = EVTYP_PMSGCMD;\r\nelse\r\nreturn -ENOSYS;\r\nbuffer->request.command = SCLP_CMDW_WRITE_EVENT_DATA;\r\nbuffer->request.status = SCLP_REQ_FILLED;\r\nbuffer->request.callback = sclp_writedata_callback;\r\nbuffer->request.callback_data = buffer;\r\nbuffer->request.sccb = sccb;\r\nbuffer->callback = callback;\r\nreturn sclp_add_request(&buffer->request);\r\n}
