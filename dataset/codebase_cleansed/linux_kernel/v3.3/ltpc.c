static unsigned long dma_mem_alloc(int size)\r\n{\r\nint order = get_order(size);\r\nreturn __get_dma_pages(GFP_KERNEL, order);\r\n}\r\nstatic void enQ(struct xmitQel *qel)\r\n{\r\nunsigned long flags;\r\nqel->next = NULL;\r\nspin_lock_irqsave(&txqueue_lock, flags);\r\nif (xmQtl) {\r\nxmQtl->next = qel;\r\n} else {\r\nxmQhd = qel;\r\n}\r\nxmQtl = qel;\r\nspin_unlock_irqrestore(&txqueue_lock, flags);\r\nif (debug & DEBUG_LOWER)\r\nprintk("enqueued a 0x%02x command\n",qel->cbuf[0]);\r\n}\r\nstatic struct xmitQel *deQ(void)\r\n{\r\nunsigned long flags;\r\nint i;\r\nstruct xmitQel *qel=NULL;\r\nspin_lock_irqsave(&txqueue_lock, flags);\r\nif (xmQhd) {\r\nqel = xmQhd;\r\nxmQhd = qel->next;\r\nif(!xmQhd) xmQtl = NULL;\r\n}\r\nspin_unlock_irqrestore(&txqueue_lock, flags);\r\nif ((debug & DEBUG_LOWER) && qel) {\r\nint n;\r\nprintk(KERN_DEBUG "ltpc: dequeued command ");\r\nn = qel->cbuflen;\r\nif (n>100) n=100;\r\nfor(i=0;i<n;i++) printk("%02x ",qel->cbuf[i]);\r\nprintk("\n");\r\n}\r\nreturn qel;\r\n}\r\nstatic int wait_timeout(struct net_device *dev, int c)\r\n{\r\nint i;\r\nfor(i=0;i<200000;i++) {\r\nif ( c != inb_p(dev->base_addr+6) ) return 0;\r\nudelay(100);\r\n}\r\nreturn 1;\r\n}\r\nstatic int getmbox(void)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&mbox_lock, flags);\r\nfor(i=1;i<16;i++) if(!mboxinuse[i]) {\r\nmboxinuse[i]=1;\r\nspin_unlock_irqrestore(&mbox_lock, flags);\r\nreturn i;\r\n}\r\nspin_unlock_irqrestore(&mbox_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void handlefc(struct net_device *dev)\r\n{\r\nint dma = dev->dma;\r\nint base = dev->base_addr;\r\nunsigned long flags;\r\nflags=claim_dma_lock();\r\ndisable_dma(dma);\r\nclear_dma_ff(dma);\r\nset_dma_mode(dma,DMA_MODE_READ);\r\nset_dma_addr(dma,virt_to_bus(ltdmacbuf));\r\nset_dma_count(dma,50);\r\nenable_dma(dma);\r\nrelease_dma_lock(flags);\r\ninb_p(base+3);\r\ninb_p(base+2);\r\nif ( wait_timeout(dev,0xfc) ) printk("timed out in handlefc\n");\r\n}\r\nstatic void handlefd(struct net_device *dev)\r\n{\r\nint dma = dev->dma;\r\nint base = dev->base_addr;\r\nunsigned long flags;\r\nflags=claim_dma_lock();\r\ndisable_dma(dma);\r\nclear_dma_ff(dma);\r\nset_dma_mode(dma,DMA_MODE_READ);\r\nset_dma_addr(dma,virt_to_bus(ltdmabuf));\r\nset_dma_count(dma,800);\r\nenable_dma(dma);\r\nrelease_dma_lock(flags);\r\ninb_p(base+3);\r\ninb_p(base+2);\r\nif ( wait_timeout(dev,0xfd) ) printk("timed out in handlefd\n");\r\nsendup_buffer(dev);\r\n}\r\nstatic void handlewrite(struct net_device *dev)\r\n{\r\nint dma = dev->dma;\r\nint base = dev->base_addr;\r\nunsigned long flags;\r\nflags=claim_dma_lock();\r\ndisable_dma(dma);\r\nclear_dma_ff(dma);\r\nset_dma_mode(dma,DMA_MODE_WRITE);\r\nset_dma_addr(dma,virt_to_bus(ltdmabuf));\r\nset_dma_count(dma,800);\r\nenable_dma(dma);\r\nrelease_dma_lock(flags);\r\ninb_p(base+3);\r\ninb_p(base+2);\r\nif ( wait_timeout(dev,0xfb) ) {\r\nflags=claim_dma_lock();\r\nprintk("timed out in handlewrite, dma res %d\n",\r\nget_dma_residue(dev->dma) );\r\nrelease_dma_lock(flags);\r\n}\r\n}\r\nstatic void handleread(struct net_device *dev)\r\n{\r\nint dma = dev->dma;\r\nint base = dev->base_addr;\r\nunsigned long flags;\r\nflags=claim_dma_lock();\r\ndisable_dma(dma);\r\nclear_dma_ff(dma);\r\nset_dma_mode(dma,DMA_MODE_READ);\r\nset_dma_addr(dma,virt_to_bus(ltdmabuf));\r\nset_dma_count(dma,800);\r\nenable_dma(dma);\r\nrelease_dma_lock(flags);\r\ninb_p(base+3);\r\ninb_p(base+2);\r\nif ( wait_timeout(dev,0xfb) ) printk("timed out in handleread\n");\r\n}\r\nstatic void handlecommand(struct net_device *dev)\r\n{\r\nint dma = dev->dma;\r\nint base = dev->base_addr;\r\nunsigned long flags;\r\nflags=claim_dma_lock();\r\ndisable_dma(dma);\r\nclear_dma_ff(dma);\r\nset_dma_mode(dma,DMA_MODE_WRITE);\r\nset_dma_addr(dma,virt_to_bus(ltdmacbuf));\r\nset_dma_count(dma,50);\r\nenable_dma(dma);\r\nrelease_dma_lock(flags);\r\ninb_p(base+3);\r\ninb_p(base+2);\r\nif ( wait_timeout(dev,0xfa) ) printk("timed out in handlecommand\n");\r\n}\r\nstatic void idle(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nint state;\r\nstruct xmitQel *q = NULL;\r\nint oops;\r\nint i;\r\nint base = dev->base_addr;\r\nspin_lock_irqsave(&txqueue_lock, flags);\r\nif(QInIdle) {\r\nspin_unlock_irqrestore(&txqueue_lock, flags);\r\nreturn;\r\n}\r\nQInIdle = 1;\r\nspin_unlock_irqrestore(&txqueue_lock, flags);\r\n(void) inb_p(base+6);\r\noops = 100;\r\nloop:\r\nif (0>oops--) {\r\nprintk("idle: looped too many times\n");\r\ngoto done;\r\n}\r\nstate = inb_p(base+6);\r\nif (state != inb_p(base+6)) goto loop;\r\nswitch(state) {\r\ncase 0xfc:\r\nif (debug & DEBUG_LOWER) printk("idle: fc\n");\r\nhandlefc(dev);\r\nbreak;\r\ncase 0xfd:\r\nif(debug & DEBUG_LOWER) printk("idle: fd\n");\r\nhandlefd(dev);\r\nbreak;\r\ncase 0xf9:\r\nif (debug & DEBUG_LOWER) printk("idle: f9\n");\r\nif(!mboxinuse[0]) {\r\nmboxinuse[0] = 1;\r\nqels[0].cbuf = rescbuf;\r\nqels[0].cbuflen = 2;\r\nqels[0].dbuf = resdbuf;\r\nqels[0].dbuflen = 2;\r\nqels[0].QWrite = 0;\r\nqels[0].mailbox = 0;\r\nenQ(&qels[0]);\r\n}\r\ninb_p(dev->base_addr+1);\r\ninb_p(dev->base_addr+0);\r\nif( wait_timeout(dev,0xf9) )\r\nprintk("timed out idle f9\n");\r\nbreak;\r\ncase 0xf8:\r\nif (xmQhd) {\r\ninb_p(dev->base_addr+1);\r\ninb_p(dev->base_addr+0);\r\nif(wait_timeout(dev,0xf8) )\r\nprintk("timed out idle f8\n");\r\n} else {\r\ngoto done;\r\n}\r\nbreak;\r\ncase 0xfa:\r\nif(debug & DEBUG_LOWER) printk("idle: fa\n");\r\nif (xmQhd) {\r\nq=deQ();\r\nmemcpy(ltdmacbuf,q->cbuf,q->cbuflen);\r\nltdmacbuf[1] = q->mailbox;\r\nif (debug>1) {\r\nint n;\r\nprintk("ltpc: sent command ");\r\nn = q->cbuflen;\r\nif (n>100) n=100;\r\nfor(i=0;i<n;i++)\r\nprintk("%02x ",ltdmacbuf[i]);\r\nprintk("\n");\r\n}\r\nhandlecommand(dev);\r\nif(0xfa==inb_p(base+6)) {\r\ngoto done;\r\n}\r\n} else {\r\nif (!mboxinuse[0]) {\r\nmboxinuse[0] = 1;\r\nqels[0].cbuf = rescbuf;\r\nqels[0].cbuflen = 2;\r\nqels[0].dbuf = resdbuf;\r\nqels[0].dbuflen = 2;\r\nqels[0].QWrite = 0;\r\nqels[0].mailbox = 0;\r\nenQ(&qels[0]);\r\n} else {\r\nprintk("trouble: response command already queued\n");\r\ngoto done;\r\n}\r\n}\r\nbreak;\r\ncase 0Xfb:\r\nif(debug & DEBUG_LOWER) printk("idle: fb\n");\r\nif(q->QWrite) {\r\nmemcpy(ltdmabuf,q->dbuf,q->dbuflen);\r\nhandlewrite(dev);\r\n} else {\r\nhandleread(dev);\r\nif(q->mailbox) {\r\nmemcpy(q->dbuf,ltdmabuf,q->dbuflen);\r\n} else {\r\nmailbox[ 0x0f & ltdmabuf[0] ] = ltdmabuf[1];\r\nmboxinuse[0]=0;\r\n}\r\n}\r\nbreak;\r\n}\r\ngoto loop;\r\ndone:\r\nQInIdle=0;\r\nif (dev->irq) {\r\ninb_p(base+7);\r\ninb_p(base+7);\r\n}\r\n}\r\nstatic int do_write(struct net_device *dev, void *cbuf, int cbuflen,\r\nvoid *dbuf, int dbuflen)\r\n{\r\nint i = getmbox();\r\nint ret;\r\nif(i) {\r\nqels[i].cbuf = cbuf;\r\nqels[i].cbuflen = cbuflen;\r\nqels[i].dbuf = dbuf;\r\nqels[i].dbuflen = dbuflen;\r\nqels[i].QWrite = 1;\r\nqels[i].mailbox = i;\r\nenQ(&qels[i]);\r\nidle(dev);\r\nret = mailbox[i];\r\nmboxinuse[i]=0;\r\nreturn ret;\r\n}\r\nprintk("ltpc: could not allocate mbox\n");\r\nreturn -1;\r\n}\r\nstatic int do_read(struct net_device *dev, void *cbuf, int cbuflen,\r\nvoid *dbuf, int dbuflen)\r\n{\r\nint i = getmbox();\r\nint ret;\r\nif(i) {\r\nqels[i].cbuf = cbuf;\r\nqels[i].cbuflen = cbuflen;\r\nqels[i].dbuf = dbuf;\r\nqels[i].dbuflen = dbuflen;\r\nqels[i].QWrite = 0;\r\nqels[i].mailbox = i;\r\nenQ(&qels[i]);\r\nidle(dev);\r\nret = mailbox[i];\r\nmboxinuse[i]=0;\r\nreturn ret;\r\n}\r\nprintk("ltpc: could not allocate mbox\n");\r\nreturn -1;\r\n}\r\nstatic int read_30 ( struct net_device *dev)\r\n{\r\nlt_command c;\r\nc.getflags.command = LT_GETFLAGS;\r\nreturn do_read(dev, &c, sizeof(c.getflags),&c,0);\r\n}\r\nstatic int set_30 (struct net_device *dev,int x)\r\n{\r\nlt_command c;\r\nc.setflags.command = LT_SETFLAGS;\r\nc.setflags.flags = x;\r\nreturn do_write(dev, &c, sizeof(c.setflags),&c,0);\r\n}\r\nstatic int sendup_buffer (struct net_device *dev)\r\n{\r\nint dnode, snode, llaptype, len;\r\nint sklen;\r\nstruct sk_buff *skb;\r\nstruct lt_rcvlap *ltc = (struct lt_rcvlap *) ltdmacbuf;\r\nif (ltc->command != LT_RCVLAP) {\r\nprintk("unknown command 0x%02x from ltpc card\n",ltc->command);\r\nreturn -1;\r\n}\r\ndnode = ltc->dnode;\r\nsnode = ltc->snode;\r\nllaptype = ltc->laptype;\r\nlen = ltc->length;\r\nsklen = len;\r\nif (llaptype == 1)\r\nsklen += 8;\r\nif(sklen > 800) {\r\nprintk(KERN_INFO "%s: nonsense length in ltpc command 0x14: 0x%08x\n",\r\ndev->name,sklen);\r\nreturn -1;\r\n}\r\nif ( (llaptype==0) || (llaptype>2) ) {\r\nprintk(KERN_INFO "%s: unknown LLAP type: %d\n",dev->name,llaptype);\r\nreturn -1;\r\n}\r\nskb = dev_alloc_skb(3+sklen);\r\nif (skb == NULL)\r\n{\r\nprintk("%s: dropping packet due to memory squeeze.\n",\r\ndev->name);\r\nreturn -1;\r\n}\r\nskb->dev = dev;\r\nif (sklen > len)\r\nskb_reserve(skb,8);\r\nskb_put(skb,len+3);\r\nskb->protocol = htons(ETH_P_LOCALTALK);\r\nskb->data[0] = dnode;\r\nskb->data[1] = snode;\r\nskb->data[2] = llaptype;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb,3);\r\nskb_copy_to_linear_data(skb, ltdmabuf, len);\r\nskb_reset_transport_header(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nnetif_rx(skb);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\nltpc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nif (dev==NULL) {\r\nprintk("ltpc_interrupt: unknown device.\n");\r\nreturn IRQ_NONE;\r\n}\r\ninb_p(dev->base_addr+6);\r\nidle(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ltpc_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct sockaddr_at *sa = (struct sockaddr_at *) &ifr->ifr_addr;\r\nstruct ltpc_private *ltpc_priv = netdev_priv(dev);\r\nstruct atalk_addr *aa = &ltpc_priv->my_addr;\r\nstruct lt_init c;\r\nint ltflags;\r\nif(debug & DEBUG_VERBOSE) printk("ltpc_ioctl called\n");\r\nswitch(cmd) {\r\ncase SIOCSIFADDR:\r\naa->s_net = sa->sat_addr.s_net;\r\nc.command = LT_INIT;\r\nc.hint = sa->sat_addr.s_node;\r\naa->s_node = do_read(dev,&c,sizeof(c),&c,0);\r\nltflags = read_30(dev);\r\nltflags |= LT_FLAG_ALLLAP;\r\nset_30 (dev,ltflags);\r\ndev->broadcast[0] = 0xFF;\r\ndev->dev_addr[0] = aa->s_node;\r\ndev->addr_len=1;\r\nreturn 0;\r\ncase SIOCGIFADDR:\r\nsa->sat_addr.s_net = aa->s_net;\r\nsa->sat_addr.s_node = aa->s_node;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\n}\r\nstatic void ltpc_poll(unsigned long l)\r\n{\r\nstruct net_device *dev = (struct net_device *) l;\r\ndel_timer(&ltpc_timer);\r\nif(debug & DEBUG_VERBOSE) {\r\nif (!ltpc_poll_counter) {\r\nltpc_poll_counter = 50;\r\nprintk("ltpc poll is alive\n");\r\n}\r\nltpc_poll_counter--;\r\n}\r\nif (!dev)\r\nreturn;\r\nidle(dev);\r\nltpc_timer.expires = jiffies + HZ/20;\r\nadd_timer(&ltpc_timer);\r\n}\r\nstatic netdev_tx_t ltpc_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nint i;\r\nstruct lt_sendlap cbuf;\r\nunsigned char *hdr;\r\ncbuf.command = LT_SENDLAP;\r\ncbuf.dnode = skb->data[0];\r\ncbuf.laptype = skb->data[2];\r\nskb_pull(skb,3);\r\ncbuf.length = skb->len;\r\nskb_reset_transport_header(skb);\r\nif(debug & DEBUG_UPPER) {\r\nprintk("command ");\r\nfor(i=0;i<6;i++)\r\nprintk("%02x ",((unsigned char *)&cbuf)[i]);\r\nprintk("\n");\r\n}\r\nhdr = skb_transport_header(skb);\r\ndo_write(dev, &cbuf, sizeof(cbuf), hdr, skb->len);\r\nif(debug & DEBUG_UPPER) {\r\nprintk("sent %d ddp bytes\n",skb->len);\r\nfor (i = 0; i < skb->len; i++)\r\nprintk("%02x ", hdr[i]);\r\nprintk("\n");\r\n}\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int __init ltpc_probe_dma(int base, int dma)\r\n{\r\nint want = (dma == 3) ? 2 : (dma == 1) ? 1 : 3;\r\nunsigned long timeout;\r\nunsigned long f;\r\nif (want & 1) {\r\nif (request_dma(1,"ltpc")) {\r\nwant &= ~1;\r\n} else {\r\nf=claim_dma_lock();\r\ndisable_dma(1);\r\nclear_dma_ff(1);\r\nset_dma_mode(1,DMA_MODE_WRITE);\r\nset_dma_addr(1,virt_to_bus(ltdmabuf));\r\nset_dma_count(1,sizeof(struct lt_mem));\r\nenable_dma(1);\r\nrelease_dma_lock(f);\r\n}\r\n}\r\nif (want & 2) {\r\nif (request_dma(3,"ltpc")) {\r\nwant &= ~2;\r\n} else {\r\nf=claim_dma_lock();\r\ndisable_dma(3);\r\nclear_dma_ff(3);\r\nset_dma_mode(3,DMA_MODE_WRITE);\r\nset_dma_addr(3,virt_to_bus(ltdmabuf));\r\nset_dma_count(3,sizeof(struct lt_mem));\r\nenable_dma(3);\r\nrelease_dma_lock(f);\r\n}\r\n}\r\nltdmabuf[0] = LT_READMEM;\r\nltdmabuf[1] = 1;\r\nltdmabuf[2] = 0; ltdmabuf[3] = 0;\r\nltdmabuf[4] = 0; ltdmabuf[5] = 1;\r\nltdmabuf[6] = 0;\r\ninb_p(io+1);\r\ninb_p(io+0);\r\ntimeout = jiffies+100*HZ/100;\r\nwhile(time_before(jiffies, timeout)) {\r\nif ( 0xfa == inb_p(io+6) ) break;\r\n}\r\ninb_p(io+3);\r\ninb_p(io+2);\r\nwhile(time_before(jiffies, timeout)) {\r\nif ( 0xfb == inb_p(io+6) ) break;\r\n}\r\nif ((want & 2) && (get_dma_residue(3)==sizeof(struct lt_mem))) {\r\nwant &= ~2;\r\nfree_dma(3);\r\n}\r\nif ((want & 1) && (get_dma_residue(1)==sizeof(struct lt_mem))) {\r\nwant &= ~1;\r\nfree_dma(1);\r\n}\r\nif (!want)\r\nreturn 0;\r\nreturn (want & 2) ? 3 : 1;\r\n}\r\nstruct net_device * __init ltpc_probe(void)\r\n{\r\nstruct net_device *dev;\r\nint err = -ENOMEM;\r\nint x=0,y=0;\r\nint autoirq;\r\nunsigned long f;\r\nunsigned long timeout;\r\ndev = alloc_ltalkdev(sizeof(struct ltpc_private));\r\nif (!dev)\r\ngoto out;\r\nif (io != 0x240 && request_region(0x220,8,"ltpc")) {\r\nx = inb_p(0x220+6);\r\nif ( (x!=0xff) && (x>=0xf0) ) {\r\nio = 0x220;\r\ngoto got_port;\r\n}\r\nrelease_region(0x220,8);\r\n}\r\nif (io != 0x220 && request_region(0x240,8,"ltpc")) {\r\ny = inb_p(0x240+6);\r\nif ( (y!=0xff) && (y>=0xf0) ){\r\nio = 0x240;\r\ngoto got_port;\r\n}\r\nrelease_region(0x240,8);\r\n}\r\nprintk(KERN_ERR "LocalTalk card not found; 220 = %02x, 240 = %02x.\n", x,y);\r\nerr = -ENODEV;\r\ngoto out1;\r\ngot_port:\r\nif (irq < 2) {\r\nunsigned long irq_mask;\r\nirq_mask = probe_irq_on();\r\ninb_p(io+7);\r\ninb_p(io+7);\r\ninb_p(io+6);\r\nmdelay(2);\r\nautoirq = probe_irq_off(irq_mask);\r\nif (autoirq == 0) {\r\nprintk(KERN_ERR "ltpc: probe at %#x failed to detect IRQ line.\n", io);\r\n} else {\r\nirq = autoirq;\r\n}\r\n}\r\nltdmabuf = (unsigned char *) dma_mem_alloc(1000);\r\nif (!ltdmabuf) {\r\nprintk(KERN_ERR "ltpc: mem alloc failed\n");\r\nerr = -ENOMEM;\r\ngoto out2;\r\n}\r\nltdmacbuf = &ltdmabuf[800];\r\nif(debug & DEBUG_VERBOSE) {\r\nprintk("ltdmabuf pointer %08lx\n",(unsigned long) ltdmabuf);\r\n}\r\ninb_p(io+1);\r\ninb_p(io+3);\r\nmsleep(20);\r\ninb_p(io+0);\r\ninb_p(io+2);\r\ninb_p(io+7);\r\ninb_p(io+4);\r\ninb_p(io+5);\r\ninb_p(io+5);\r\ninb_p(io+6);\r\nssleep(1);\r\ndma = ltpc_probe_dma(io, dma);\r\nif (!dma) {\r\nprintk(KERN_ERR "No DMA channel found on ltpc card.\n");\r\nerr = -ENODEV;\r\ngoto out3;\r\n}\r\nif(irq)\r\nprintk(KERN_INFO "Apple/Farallon LocalTalk-PC card at %03x, IR%d, DMA%d.\n",io,irq,dma);\r\nelse\r\nprintk(KERN_INFO "Apple/Farallon LocalTalk-PC card at %03x, DMA%d. Using polled mode.\n",io,dma);\r\ndev->netdev_ops = &ltpc_netdev;\r\ndev->base_addr = io;\r\ndev->irq = irq;\r\ndev->dma = dma;\r\nf=claim_dma_lock();\r\ndisable_dma(dma);\r\nclear_dma_ff(dma);\r\nset_dma_mode(dma,DMA_MODE_READ);\r\nset_dma_addr(dma,virt_to_bus(ltdmabuf));\r\nset_dma_count(dma,0x100);\r\nenable_dma(dma);\r\nrelease_dma_lock(f);\r\n(void) inb_p(io+3);\r\n(void) inb_p(io+2);\r\ntimeout = jiffies+100*HZ/100;\r\nwhile(time_before(jiffies, timeout)) {\r\nif( 0xf9 == inb_p(io+6))\r\nbreak;\r\nschedule();\r\n}\r\nif(debug & DEBUG_VERBOSE) {\r\nprintk("setting up timer and irq\n");\r\n}\r\nif (irq && request_irq( irq, ltpc_interrupt, 0, "ltpc", dev) >= 0)\r\n{\r\n(void) inb_p(io+7);\r\n(void) inb_p(io+7);\r\n} else {\r\nif( irq )\r\nprintk(KERN_ERR "ltpc: IRQ already in use, using polled mode.\n");\r\ndev->irq = 0;\r\ninit_timer(&ltpc_timer);\r\nltpc_timer.function=ltpc_poll;\r\nltpc_timer.data = (unsigned long) dev;\r\nltpc_timer.expires = jiffies + HZ/20;\r\nadd_timer(&ltpc_timer);\r\n}\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out4;\r\nreturn NULL;\r\nout4:\r\ndel_timer_sync(&ltpc_timer);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nout3:\r\nfree_pages((unsigned long)ltdmabuf, get_order(1000));\r\nout2:\r\nrelease_region(io, 8);\r\nout1:\r\nfree_netdev(dev);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init ltpc_setup(char *str)\r\n{\r\nint ints[5];\r\nstr = get_options(str, ARRAY_SIZE(ints), ints);\r\nif (ints[0] == 0) {\r\nif (str && !strncmp(str, "auto", 4)) {\r\n}\r\nelse {\r\nprintk (KERN_ERR\r\n"ltpc: usage: ltpc=auto|iobase[,irq[,dma]]\n");\r\nreturn 0;\r\n}\r\n} else {\r\nio = ints[1];\r\nif (ints[0] > 1) {\r\nirq = ints[2];\r\n}\r\nif (ints[0] > 2) {\r\ndma = ints[3];\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init ltpc_module_init(void)\r\n{\r\nif(io == 0)\r\nprintk(KERN_NOTICE\r\n"ltpc: Autoprobing is not recommended for modules\n");\r\ndev_ltpc = ltpc_probe();\r\nif (IS_ERR(dev_ltpc))\r\nreturn PTR_ERR(dev_ltpc);\r\nreturn 0;\r\n}\r\nstatic void __exit ltpc_cleanup(void)\r\n{\r\nif(debug & DEBUG_VERBOSE) printk("unregister_netdev\n");\r\nunregister_netdev(dev_ltpc);\r\nltpc_timer.data = 0;\r\ndel_timer_sync(&ltpc_timer);\r\nif(debug & DEBUG_VERBOSE) printk("freeing irq\n");\r\nif (dev_ltpc->irq)\r\nfree_irq(dev_ltpc->irq, dev_ltpc);\r\nif(debug & DEBUG_VERBOSE) printk("freeing dma\n");\r\nif (dev_ltpc->dma)\r\nfree_dma(dev_ltpc->dma);\r\nif(debug & DEBUG_VERBOSE) printk("freeing ioaddr\n");\r\nif (dev_ltpc->base_addr)\r\nrelease_region(dev_ltpc->base_addr,8);\r\nfree_netdev(dev_ltpc);\r\nif(debug & DEBUG_VERBOSE) printk("free_pages\n");\r\nfree_pages( (unsigned long) ltdmabuf, get_order(1000));\r\nif(debug & DEBUG_VERBOSE) printk("returning from cleanup_module\n");\r\n}
