static int nvec_power_notifier(struct notifier_block *nb,\r\nunsigned long event_type, void *data)\r\n{\r\nstruct nvec_power *power =\r\ncontainer_of(nb, struct nvec_power, notifier);\r\nstruct bat_response *res = (struct bat_response *)data;\r\nif (event_type != NVEC_SYS)\r\nreturn NOTIFY_DONE;\r\nif (res->sub_type == 0) {\r\nif (power->on != res->plu) {\r\npower->on = res->plu;\r\npower_supply_changed(&nvec_psy);\r\n}\r\nreturn NOTIFY_STOP;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void get_bat_mfg_data(struct nvec_power *power)\r\n{\r\nint i;\r\nchar buf[] = { '\x02', '\x00' };\r\nfor (i = 0; i < ARRAY_SIZE(bat_init); i++) {\r\nbuf[1] = bat_init[i];\r\nnvec_write_async(power->nvec, buf, 2);\r\n}\r\n}\r\nstatic int nvec_power_bat_notifier(struct notifier_block *nb,\r\nunsigned long event_type, void *data)\r\n{\r\nstruct nvec_power *power =\r\ncontainer_of(nb, struct nvec_power, notifier);\r\nstruct bat_response *res = (struct bat_response *)data;\r\nint status_changed = 0;\r\nif (event_type != NVEC_BAT)\r\nreturn NOTIFY_DONE;\r\nswitch (res->sub_type) {\r\ncase SLOT_STATUS:\r\nif (res->plc[0] & 1) {\r\nif (power->bat_present == 0) {\r\nstatus_changed = 1;\r\nget_bat_mfg_data(power);\r\n}\r\npower->bat_present = 1;\r\nswitch ((res->plc[0] >> 1) & 3) {\r\ncase 0:\r\npower->bat_status =\r\nPOWER_SUPPLY_STATUS_NOT_CHARGING;\r\nbreak;\r\ncase 1:\r\npower->bat_status =\r\nPOWER_SUPPLY_STATUS_CHARGING;\r\nbreak;\r\ncase 2:\r\npower->bat_status =\r\nPOWER_SUPPLY_STATUS_DISCHARGING;\r\nbreak;\r\ndefault:\r\npower->bat_status = POWER_SUPPLY_STATUS_UNKNOWN;\r\n}\r\n} else {\r\nif (power->bat_present == 1)\r\nstatus_changed = 1;\r\npower->bat_present = 0;\r\npower->bat_status = POWER_SUPPLY_STATUS_UNKNOWN;\r\n}\r\npower->bat_cap = res->plc[1];\r\nif (status_changed)\r\npower_supply_changed(&nvec_bat_psy);\r\nbreak;\r\ncase VOLTAGE:\r\npower->bat_voltage_now = res->plu * 1000;\r\nbreak;\r\ncase TIME_REMAINING:\r\npower->time_remain = res->plu * 3600;\r\nbreak;\r\ncase CURRENT:\r\npower->bat_current_now = res->pls * 1000;\r\nbreak;\r\ncase AVERAGE_CURRENT:\r\npower->bat_current_avg = res->pls * 1000;\r\nbreak;\r\ncase CAPACITY_REMAINING:\r\npower->capacity_remain = res->plu * 1000;\r\nbreak;\r\ncase LAST_FULL_CHARGE_CAPACITY:\r\npower->charge_last_full = res->plu * 1000;\r\nbreak;\r\ncase DESIGN_CAPACITY:\r\npower->charge_full_design = res->plu * 1000;\r\nbreak;\r\ncase CRITICAL_CAPACITY:\r\npower->critical_capacity = res->plu * 1000;\r\nbreak;\r\ncase TEMPERATURE:\r\npower->bat_temperature = res->plu - 2732;\r\nbreak;\r\ncase MANUFACTURER:\r\nmemcpy(power->bat_manu, &res->plc, res->length - 2);\r\npower->bat_model[res->length - 2] = '\0';\r\nbreak;\r\ncase MODEL:\r\nmemcpy(power->bat_model, &res->plc, res->length - 2);\r\npower->bat_model[res->length - 2] = '\0';\r\nbreak;\r\ncase TYPE:\r\nmemcpy(power->bat_type, &res->plc, res->length - 2);\r\npower->bat_type[res->length - 2] = '\0';\r\nif (!strncmp(power->bat_type, "Li", 30))\r\npower->bat_type_enum = POWER_SUPPLY_TECHNOLOGY_LION;\r\nelse\r\npower->bat_type_enum = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;\r\nbreak;\r\ndefault:\r\nreturn NOTIFY_STOP;\r\n}\r\nreturn NOTIFY_STOP;\r\n}\r\nstatic int nvec_power_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct nvec_power *power = dev_get_drvdata(psy->dev->parent);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = power->on;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nvec_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct nvec_power *power = dev_get_drvdata(psy->dev->parent);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nval->intval = power->bat_status;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nval->intval = power->bat_cap;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = power->bat_present;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nval->intval = power->bat_voltage_now;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nval->intval = power->bat_current_now;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_AVG:\r\nval->intval = power->bat_current_avg;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:\r\nval->intval = power->time_remain;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\nval->intval = power->charge_full_design;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\nval->intval = power->charge_last_full;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_EMPTY:\r\nval->intval = power->critical_capacity;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\nval->intval = power->capacity_remain;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nval->intval = power->bat_temperature;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MANUFACTURER:\r\nval->strval = power->bat_manu;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MODEL_NAME:\r\nval->strval = power->bat_model;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = power->bat_type_enum;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void nvec_power_poll(struct work_struct *work)\r\n{\r\nchar buf[] = { '\x01', '\x00' };\r\nstruct nvec_power *power = container_of(work, struct nvec_power,\r\npoller.work);\r\nif (counter >= ARRAY_SIZE(bat_iter))\r\ncounter = 0;\r\nnvec_write_async(power->nvec, buf, 2);\r\nmsleep(100);\r\nbuf[0] = '\x02';\r\nbuf[1] = bat_iter[counter++];\r\nnvec_write_async(power->nvec, buf, 2);\r\nschedule_delayed_work(to_delayed_work(work), msecs_to_jiffies(5000));\r\n}\r\nstatic int __devinit nvec_power_probe(struct platform_device *pdev)\r\n{\r\nstruct power_supply *psy;\r\nstruct nvec_power *power =\r\nkzalloc(sizeof(struct nvec_power), GFP_NOWAIT);\r\nstruct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);\r\ndev_set_drvdata(&pdev->dev, power);\r\npower->nvec = nvec;\r\nswitch (pdev->id) {\r\ncase AC:\r\npsy = &nvec_psy;\r\npower->notifier.notifier_call = nvec_power_notifier;\r\nINIT_DELAYED_WORK(&power->poller, nvec_power_poll);\r\nschedule_delayed_work(&power->poller, msecs_to_jiffies(5000));\r\nbreak;\r\ncase BAT:\r\npsy = &nvec_bat_psy;\r\npower->notifier.notifier_call = nvec_power_bat_notifier;\r\nbreak;\r\ndefault:\r\nkfree(power);\r\nreturn -ENODEV;\r\n}\r\nnvec_register_notifier(nvec, &power->notifier, NVEC_SYS);\r\nif (pdev->id == BAT)\r\nget_bat_mfg_data(power);\r\nreturn power_supply_register(&pdev->dev, psy);\r\n}\r\nstatic int __init nvec_power_init(void)\r\n{\r\nreturn platform_driver_register(&nvec_power_driver);\r\n}
