static inline unsigned int\r\nip_vs_sed_dest_overhead(struct ip_vs_dest *dest)\r\n{\r\nreturn atomic_read(&dest->activeconns) + 1;\r\n}\r\nstatic struct ip_vs_dest *\r\nip_vs_sed_schedule(struct ip_vs_service *svc, const struct sk_buff *skb)\r\n{\r\nstruct ip_vs_dest *dest, *least;\r\nunsigned int loh, doh;\r\nIP_VS_DBG(6, "%s(): Scheduling...\n", __func__);\r\nlist_for_each_entry(dest, &svc->destinations, n_list) {\r\nif (!(dest->flags & IP_VS_DEST_F_OVERLOAD) &&\r\natomic_read(&dest->weight) > 0) {\r\nleast = dest;\r\nloh = ip_vs_sed_dest_overhead(least);\r\ngoto nextstage;\r\n}\r\n}\r\nip_vs_scheduler_err(svc, "no destination available");\r\nreturn NULL;\r\nnextstage:\r\nlist_for_each_entry_continue(dest, &svc->destinations, n_list) {\r\nif (dest->flags & IP_VS_DEST_F_OVERLOAD)\r\ncontinue;\r\ndoh = ip_vs_sed_dest_overhead(dest);\r\nif (loh * atomic_read(&dest->weight) >\r\ndoh * atomic_read(&least->weight)) {\r\nleast = dest;\r\nloh = doh;\r\n}\r\n}\r\nIP_VS_DBG_BUF(6, "SED: server %s:%u "\r\n"activeconns %d refcnt %d weight %d overhead %d\n",\r\nIP_VS_DBG_ADDR(svc->af, &least->addr), ntohs(least->port),\r\natomic_read(&least->activeconns),\r\natomic_read(&least->refcnt),\r\natomic_read(&least->weight), loh);\r\nreturn least;\r\n}\r\nstatic int __init ip_vs_sed_init(void)\r\n{\r\nreturn register_ip_vs_scheduler(&ip_vs_sed_scheduler);\r\n}\r\nstatic void __exit ip_vs_sed_cleanup(void)\r\n{\r\nunregister_ip_vs_scheduler(&ip_vs_sed_scheduler);\r\n}
