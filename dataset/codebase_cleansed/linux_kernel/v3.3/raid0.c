static int raid0_congested(void *data, int bits)\r\n{\r\nstruct mddev *mddev = data;\r\nstruct r0conf *conf = mddev->private;\r\nstruct md_rdev **devlist = conf->devlist;\r\nint raid_disks = conf->strip_zone[0].nb_dev;\r\nint i, ret = 0;\r\nif (mddev_congested(mddev, bits))\r\nreturn 1;\r\nfor (i = 0; i < raid_disks && !ret ; i++) {\r\nstruct request_queue *q = bdev_get_queue(devlist[i]->bdev);\r\nret |= bdi_congested(&q->backing_dev_info, bits);\r\n}\r\nreturn ret;\r\n}\r\nstatic void dump_zones(struct mddev *mddev)\r\n{\r\nint j, k;\r\nsector_t zone_size = 0;\r\nsector_t zone_start = 0;\r\nchar b[BDEVNAME_SIZE];\r\nstruct r0conf *conf = mddev->private;\r\nint raid_disks = conf->strip_zone[0].nb_dev;\r\nprintk(KERN_INFO "md: RAID0 configuration for %s - %d zone%s\n",\r\nmdname(mddev),\r\nconf->nr_strip_zones, conf->nr_strip_zones==1?"":"s");\r\nfor (j = 0; j < conf->nr_strip_zones; j++) {\r\nprintk(KERN_INFO "md: zone%d=[", j);\r\nfor (k = 0; k < conf->strip_zone[j].nb_dev; k++)\r\nprintk(KERN_CONT "%s%s", k?"/":"",\r\nbdevname(conf->devlist[j*raid_disks\r\n+ k]->bdev, b));\r\nprintk(KERN_CONT "]\n");\r\nzone_size = conf->strip_zone[j].zone_end - zone_start;\r\nprintk(KERN_INFO " zone-offset=%10lluKB, "\r\n"device-offset=%10lluKB, size=%10lluKB\n",\r\n(unsigned long long)zone_start>>1,\r\n(unsigned long long)conf->strip_zone[j].dev_start>>1,\r\n(unsigned long long)zone_size>>1);\r\nzone_start = conf->strip_zone[j].zone_end;\r\n}\r\nprintk(KERN_INFO "\n");\r\n}\r\nstatic int create_strip_zones(struct mddev *mddev, struct r0conf **private_conf)\r\n{\r\nint i, c, err;\r\nsector_t curr_zone_end, sectors;\r\nstruct md_rdev *smallest, *rdev1, *rdev2, *rdev, **dev;\r\nstruct strip_zone *zone;\r\nint cnt;\r\nchar b[BDEVNAME_SIZE];\r\nchar b2[BDEVNAME_SIZE];\r\nstruct r0conf *conf = kzalloc(sizeof(*conf), GFP_KERNEL);\r\nif (!conf)\r\nreturn -ENOMEM;\r\nlist_for_each_entry(rdev1, &mddev->disks, same_set) {\r\npr_debug("md/raid0:%s: looking at %s\n",\r\nmdname(mddev),\r\nbdevname(rdev1->bdev, b));\r\nc = 0;\r\nsectors = rdev1->sectors;\r\nsector_div(sectors, mddev->chunk_sectors);\r\nrdev1->sectors = sectors * mddev->chunk_sectors;\r\nlist_for_each_entry(rdev2, &mddev->disks, same_set) {\r\npr_debug("md/raid0:%s: comparing %s(%llu)"\r\n" with %s(%llu)\n",\r\nmdname(mddev),\r\nbdevname(rdev1->bdev,b),\r\n(unsigned long long)rdev1->sectors,\r\nbdevname(rdev2->bdev,b2),\r\n(unsigned long long)rdev2->sectors);\r\nif (rdev2 == rdev1) {\r\npr_debug("md/raid0:%s: END\n",\r\nmdname(mddev));\r\nbreak;\r\n}\r\nif (rdev2->sectors == rdev1->sectors) {\r\npr_debug("md/raid0:%s: EQUAL\n",\r\nmdname(mddev));\r\nc = 1;\r\nbreak;\r\n}\r\npr_debug("md/raid0:%s: NOT EQUAL\n",\r\nmdname(mddev));\r\n}\r\nif (!c) {\r\npr_debug("md/raid0:%s: ==> UNIQUE\n",\r\nmdname(mddev));\r\nconf->nr_strip_zones++;\r\npr_debug("md/raid0:%s: %d zones\n",\r\nmdname(mddev), conf->nr_strip_zones);\r\n}\r\n}\r\npr_debug("md/raid0:%s: FINAL %d zones\n",\r\nmdname(mddev), conf->nr_strip_zones);\r\nerr = -ENOMEM;\r\nconf->strip_zone = kzalloc(sizeof(struct strip_zone)*\r\nconf->nr_strip_zones, GFP_KERNEL);\r\nif (!conf->strip_zone)\r\ngoto abort;\r\nconf->devlist = kzalloc(sizeof(struct md_rdev*)*\r\nconf->nr_strip_zones*mddev->raid_disks,\r\nGFP_KERNEL);\r\nif (!conf->devlist)\r\ngoto abort;\r\nzone = &conf->strip_zone[0];\r\ncnt = 0;\r\nsmallest = NULL;\r\ndev = conf->devlist;\r\nerr = -EINVAL;\r\nlist_for_each_entry(rdev1, &mddev->disks, same_set) {\r\nint j = rdev1->raid_disk;\r\nif (mddev->level == 10) {\r\nj /= 2;\r\nrdev1->new_raid_disk = j;\r\n}\r\nif (mddev->level == 1) {\r\nj = 0;\r\nrdev1->new_raid_disk = j;\r\n}\r\nif (j < 0 || j >= mddev->raid_disks) {\r\nprintk(KERN_ERR "md/raid0:%s: bad disk number %d - "\r\n"aborting!\n", mdname(mddev), j);\r\ngoto abort;\r\n}\r\nif (dev[j]) {\r\nprintk(KERN_ERR "md/raid0:%s: multiple devices for %d - "\r\n"aborting!\n", mdname(mddev), j);\r\ngoto abort;\r\n}\r\ndev[j] = rdev1;\r\ndisk_stack_limits(mddev->gendisk, rdev1->bdev,\r\nrdev1->data_offset << 9);\r\nif (rdev1->bdev->bd_disk->queue->merge_bvec_fn) {\r\nblk_queue_max_segments(mddev->queue, 1);\r\nblk_queue_segment_boundary(mddev->queue,\r\nPAGE_CACHE_SIZE - 1);\r\n}\r\nif (!smallest || (rdev1->sectors < smallest->sectors))\r\nsmallest = rdev1;\r\ncnt++;\r\n}\r\nif (cnt != mddev->raid_disks) {\r\nprintk(KERN_ERR "md/raid0:%s: too few disks (%d of %d) - "\r\n"aborting!\n", mdname(mddev), cnt, mddev->raid_disks);\r\ngoto abort;\r\n}\r\nzone->nb_dev = cnt;\r\nzone->zone_end = smallest->sectors * cnt;\r\ncurr_zone_end = zone->zone_end;\r\nfor (i = 1; i < conf->nr_strip_zones; i++)\r\n{\r\nint j;\r\nzone = conf->strip_zone + i;\r\ndev = conf->devlist + i * mddev->raid_disks;\r\npr_debug("md/raid0:%s: zone %d\n", mdname(mddev), i);\r\nzone->dev_start = smallest->sectors;\r\nsmallest = NULL;\r\nc = 0;\r\nfor (j=0; j<cnt; j++) {\r\nrdev = conf->devlist[j];\r\nif (rdev->sectors <= zone->dev_start) {\r\npr_debug("md/raid0:%s: checking %s ... nope\n",\r\nmdname(mddev),\r\nbdevname(rdev->bdev, b));\r\ncontinue;\r\n}\r\npr_debug("md/raid0:%s: checking %s ..."\r\n" contained as device %d\n",\r\nmdname(mddev),\r\nbdevname(rdev->bdev, b), c);\r\ndev[c] = rdev;\r\nc++;\r\nif (!smallest || rdev->sectors < smallest->sectors) {\r\nsmallest = rdev;\r\npr_debug("md/raid0:%s: (%llu) is smallest!.\n",\r\nmdname(mddev),\r\n(unsigned long long)rdev->sectors);\r\n}\r\n}\r\nzone->nb_dev = c;\r\nsectors = (smallest->sectors - zone->dev_start) * c;\r\npr_debug("md/raid0:%s: zone->nb_dev: %d, sectors: %llu\n",\r\nmdname(mddev),\r\nzone->nb_dev, (unsigned long long)sectors);\r\ncurr_zone_end += sectors;\r\nzone->zone_end = curr_zone_end;\r\npr_debug("md/raid0:%s: current zone start: %llu\n",\r\nmdname(mddev),\r\n(unsigned long long)smallest->sectors);\r\n}\r\nmddev->queue->backing_dev_info.congested_fn = raid0_congested;\r\nmddev->queue->backing_dev_info.congested_data = mddev;\r\nif ((mddev->chunk_sectors << 9) % queue_logical_block_size(mddev->queue)) {\r\nprintk(KERN_ERR "md/raid0:%s: chunk_size of %d not valid\n",\r\nmdname(mddev),\r\nmddev->chunk_sectors << 9);\r\ngoto abort;\r\n}\r\nblk_queue_io_min(mddev->queue, mddev->chunk_sectors << 9);\r\nblk_queue_io_opt(mddev->queue,\r\n(mddev->chunk_sectors << 9) * mddev->raid_disks);\r\npr_debug("md/raid0:%s: done.\n", mdname(mddev));\r\n*private_conf = conf;\r\nreturn 0;\r\nabort:\r\nkfree(conf->strip_zone);\r\nkfree(conf->devlist);\r\nkfree(conf);\r\n*private_conf = NULL;\r\nreturn err;\r\n}\r\nstatic int raid0_mergeable_bvec(struct request_queue *q,\r\nstruct bvec_merge_data *bvm,\r\nstruct bio_vec *biovec)\r\n{\r\nstruct mddev *mddev = q->queuedata;\r\nsector_t sector = bvm->bi_sector + get_start_sect(bvm->bi_bdev);\r\nint max;\r\nunsigned int chunk_sectors = mddev->chunk_sectors;\r\nunsigned int bio_sectors = bvm->bi_size >> 9;\r\nif (is_power_of_2(chunk_sectors))\r\nmax = (chunk_sectors - ((sector & (chunk_sectors-1))\r\n+ bio_sectors)) << 9;\r\nelse\r\nmax = (chunk_sectors - (sector_div(sector, chunk_sectors)\r\n+ bio_sectors)) << 9;\r\nif (max < 0) max = 0;\r\nif (max <= biovec->bv_len && bio_sectors == 0)\r\nreturn biovec->bv_len;\r\nelse\r\nreturn max;\r\n}\r\nstatic sector_t raid0_size(struct mddev *mddev, sector_t sectors, int raid_disks)\r\n{\r\nsector_t array_sectors = 0;\r\nstruct md_rdev *rdev;\r\nWARN_ONCE(sectors || raid_disks,\r\n"%s does not support generic reshape\n", __func__);\r\nlist_for_each_entry(rdev, &mddev->disks, same_set)\r\narray_sectors += rdev->sectors;\r\nreturn array_sectors;\r\n}\r\nstatic int raid0_run(struct mddev *mddev)\r\n{\r\nstruct r0conf *conf;\r\nint ret;\r\nif (mddev->chunk_sectors == 0) {\r\nprintk(KERN_ERR "md/raid0:%s: chunk size must be set.\n",\r\nmdname(mddev));\r\nreturn -EINVAL;\r\n}\r\nif (md_check_no_bitmap(mddev))\r\nreturn -EINVAL;\r\nblk_queue_max_hw_sectors(mddev->queue, mddev->chunk_sectors);\r\nif (mddev->private == NULL) {\r\nret = create_strip_zones(mddev, &conf);\r\nif (ret < 0)\r\nreturn ret;\r\nmddev->private = conf;\r\n}\r\nconf = mddev->private;\r\nmd_set_array_sectors(mddev, raid0_size(mddev, 0, 0));\r\nprintk(KERN_INFO "md/raid0:%s: md_size is %llu sectors.\n",\r\nmdname(mddev),\r\n(unsigned long long)mddev->array_sectors);\r\n{\r\nint stripe = mddev->raid_disks *\r\n(mddev->chunk_sectors << 9) / PAGE_SIZE;\r\nif (mddev->queue->backing_dev_info.ra_pages < 2* stripe)\r\nmddev->queue->backing_dev_info.ra_pages = 2* stripe;\r\n}\r\nblk_queue_merge_bvec(mddev->queue, raid0_mergeable_bvec);\r\ndump_zones(mddev);\r\nreturn md_integrity_register(mddev);\r\n}\r\nstatic int raid0_stop(struct mddev *mddev)\r\n{\r\nstruct r0conf *conf = mddev->private;\r\nblk_sync_queue(mddev->queue);\r\nkfree(conf->strip_zone);\r\nkfree(conf->devlist);\r\nkfree(conf);\r\nmddev->private = NULL;\r\nreturn 0;\r\n}\r\nstatic struct strip_zone *find_zone(struct r0conf *conf,\r\nsector_t *sectorp)\r\n{\r\nint i;\r\nstruct strip_zone *z = conf->strip_zone;\r\nsector_t sector = *sectorp;\r\nfor (i = 0; i < conf->nr_strip_zones; i++)\r\nif (sector < z[i].zone_end) {\r\nif (i)\r\n*sectorp = sector - z[i-1].zone_end;\r\nreturn z + i;\r\n}\r\nBUG();\r\n}\r\nstatic struct md_rdev *map_sector(struct mddev *mddev, struct strip_zone *zone,\r\nsector_t sector, sector_t *sector_offset)\r\n{\r\nunsigned int sect_in_chunk;\r\nsector_t chunk;\r\nstruct r0conf *conf = mddev->private;\r\nint raid_disks = conf->strip_zone[0].nb_dev;\r\nunsigned int chunk_sects = mddev->chunk_sectors;\r\nif (is_power_of_2(chunk_sects)) {\r\nint chunksect_bits = ffz(~chunk_sects);\r\nsect_in_chunk = sector & (chunk_sects - 1);\r\nsector >>= chunksect_bits;\r\nchunk = *sector_offset;\r\nsector_div(chunk, zone->nb_dev << chunksect_bits);\r\n} else{\r\nsect_in_chunk = sector_div(sector, chunk_sects);\r\nchunk = *sector_offset;\r\nsector_div(chunk, chunk_sects * zone->nb_dev);\r\n}\r\n*sector_offset = (chunk * chunk_sects) + sect_in_chunk;\r\nreturn conf->devlist[(zone - conf->strip_zone)*raid_disks\r\n+ sector_div(sector, zone->nb_dev)];\r\n}\r\nstatic inline int is_io_in_chunk_boundary(struct mddev *mddev,\r\nunsigned int chunk_sects, struct bio *bio)\r\n{\r\nif (likely(is_power_of_2(chunk_sects))) {\r\nreturn chunk_sects >= ((bio->bi_sector & (chunk_sects-1))\r\n+ (bio->bi_size >> 9));\r\n} else{\r\nsector_t sector = bio->bi_sector;\r\nreturn chunk_sects >= (sector_div(sector, chunk_sects)\r\n+ (bio->bi_size >> 9));\r\n}\r\n}\r\nstatic void raid0_make_request(struct mddev *mddev, struct bio *bio)\r\n{\r\nunsigned int chunk_sects;\r\nsector_t sector_offset;\r\nstruct strip_zone *zone;\r\nstruct md_rdev *tmp_dev;\r\nif (unlikely(bio->bi_rw & REQ_FLUSH)) {\r\nmd_flush_request(mddev, bio);\r\nreturn;\r\n}\r\nchunk_sects = mddev->chunk_sectors;\r\nif (unlikely(!is_io_in_chunk_boundary(mddev, chunk_sects, bio))) {\r\nsector_t sector = bio->bi_sector;\r\nstruct bio_pair *bp;\r\nif (bio->bi_vcnt != 1 ||\r\nbio->bi_idx != 0)\r\ngoto bad_map;\r\nif (likely(is_power_of_2(chunk_sects)))\r\nbp = bio_split(bio, chunk_sects - (sector &\r\n(chunk_sects-1)));\r\nelse\r\nbp = bio_split(bio, chunk_sects -\r\nsector_div(sector, chunk_sects));\r\nraid0_make_request(mddev, &bp->bio1);\r\nraid0_make_request(mddev, &bp->bio2);\r\nbio_pair_release(bp);\r\nreturn;\r\n}\r\nsector_offset = bio->bi_sector;\r\nzone = find_zone(mddev->private, &sector_offset);\r\ntmp_dev = map_sector(mddev, zone, bio->bi_sector,\r\n&sector_offset);\r\nbio->bi_bdev = tmp_dev->bdev;\r\nbio->bi_sector = sector_offset + zone->dev_start +\r\ntmp_dev->data_offset;\r\ngeneric_make_request(bio);\r\nreturn;\r\nbad_map:\r\nprintk("md/raid0:%s: make_request bug: can't convert block across chunks"\r\n" or bigger than %dk %llu %d\n",\r\nmdname(mddev), chunk_sects / 2,\r\n(unsigned long long)bio->bi_sector, bio->bi_size >> 10);\r\nbio_io_error(bio);\r\nreturn;\r\n}\r\nstatic void raid0_status(struct seq_file *seq, struct mddev *mddev)\r\n{\r\nseq_printf(seq, " %dk chunks", mddev->chunk_sectors / 2);\r\nreturn;\r\n}\r\nstatic void *raid0_takeover_raid45(struct mddev *mddev)\r\n{\r\nstruct md_rdev *rdev;\r\nstruct r0conf *priv_conf;\r\nif (mddev->degraded != 1) {\r\nprintk(KERN_ERR "md/raid0:%s: raid5 must be degraded! Degraded disks: %d\n",\r\nmdname(mddev),\r\nmddev->degraded);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nlist_for_each_entry(rdev, &mddev->disks, same_set) {\r\nif (rdev->raid_disk == mddev->raid_disks-1) {\r\nprintk(KERN_ERR "md/raid0:%s: raid5 must have missing parity disk!\n",\r\nmdname(mddev));\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\nmddev->new_level = 0;\r\nmddev->new_layout = 0;\r\nmddev->new_chunk_sectors = mddev->chunk_sectors;\r\nmddev->raid_disks--;\r\nmddev->delta_disks = -1;\r\nmddev->recovery_cp = MaxSector;\r\ncreate_strip_zones(mddev, &priv_conf);\r\nreturn priv_conf;\r\n}\r\nstatic void *raid0_takeover_raid10(struct mddev *mddev)\r\n{\r\nstruct r0conf *priv_conf;\r\nif (mddev->layout != ((1 << 8) + 2)) {\r\nprintk(KERN_ERR "md/raid0:%s:: Raid0 cannot takover layout: 0x%x\n",\r\nmdname(mddev),\r\nmddev->layout);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (mddev->raid_disks & 1) {\r\nprintk(KERN_ERR "md/raid0:%s: Raid0 cannot takover Raid10 with odd disk number.\n",\r\nmdname(mddev));\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (mddev->degraded != (mddev->raid_disks>>1)) {\r\nprintk(KERN_ERR "md/raid0:%s: All mirrors must be already degraded!\n",\r\nmdname(mddev));\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nmddev->new_level = 0;\r\nmddev->new_layout = 0;\r\nmddev->new_chunk_sectors = mddev->chunk_sectors;\r\nmddev->delta_disks = - mddev->raid_disks / 2;\r\nmddev->raid_disks += mddev->delta_disks;\r\nmddev->degraded = 0;\r\nmddev->recovery_cp = MaxSector;\r\ncreate_strip_zones(mddev, &priv_conf);\r\nreturn priv_conf;\r\n}\r\nstatic void *raid0_takeover_raid1(struct mddev *mddev)\r\n{\r\nstruct r0conf *priv_conf;\r\nif ((mddev->raid_disks - 1) != mddev->degraded) {\r\nprintk(KERN_ERR "md/raid0:%s: (N - 1) mirrors drives must be already faulty!\n",\r\nmdname(mddev));\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nmddev->new_level = 0;\r\nmddev->new_layout = 0;\r\nmddev->new_chunk_sectors = 128;\r\nmddev->delta_disks = 1 - mddev->raid_disks;\r\nmddev->raid_disks = 1;\r\nmddev->recovery_cp = MaxSector;\r\ncreate_strip_zones(mddev, &priv_conf);\r\nreturn priv_conf;\r\n}\r\nstatic void *raid0_takeover(struct mddev *mddev)\r\n{\r\nif (mddev->level == 4)\r\nreturn raid0_takeover_raid45(mddev);\r\nif (mddev->level == 5) {\r\nif (mddev->layout == ALGORITHM_PARITY_N)\r\nreturn raid0_takeover_raid45(mddev);\r\nprintk(KERN_ERR "md/raid0:%s: Raid can only takeover Raid5 with layout: %d\n",\r\nmdname(mddev), ALGORITHM_PARITY_N);\r\n}\r\nif (mddev->level == 10)\r\nreturn raid0_takeover_raid10(mddev);\r\nif (mddev->level == 1)\r\nreturn raid0_takeover_raid1(mddev);\r\nprintk(KERN_ERR "Takeover from raid%i to raid0 not supported\n",\r\nmddev->level);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic void raid0_quiesce(struct mddev *mddev, int state)\r\n{\r\n}\r\nstatic int __init raid0_init (void)\r\n{\r\nreturn register_md_personality (&raid0_personality);\r\n}\r\nstatic void raid0_exit (void)\r\n{\r\nunregister_md_personality (&raid0_personality);\r\n}
