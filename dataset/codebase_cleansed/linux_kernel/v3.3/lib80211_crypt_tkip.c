static unsigned long lib80211_tkip_set_flags(unsigned long flags, void *priv)\r\n{\r\nstruct lib80211_tkip_data *_priv = priv;\r\nunsigned long old_flags = _priv->flags;\r\n_priv->flags = flags;\r\nreturn old_flags;\r\n}\r\nstatic unsigned long lib80211_tkip_get_flags(void *priv)\r\n{\r\nstruct lib80211_tkip_data *_priv = priv;\r\nreturn _priv->flags;\r\n}\r\nstatic void *lib80211_tkip_init(int key_idx)\r\n{\r\nstruct lib80211_tkip_data *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_ATOMIC);\r\nif (priv == NULL)\r\ngoto fail;\r\npriv->key_idx = key_idx;\r\npriv->tx_tfm_arc4 = crypto_alloc_blkcipher("ecb(arc4)", 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (IS_ERR(priv->tx_tfm_arc4)) {\r\npriv->tx_tfm_arc4 = NULL;\r\ngoto fail;\r\n}\r\npriv->tx_tfm_michael = crypto_alloc_hash("michael_mic", 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (IS_ERR(priv->tx_tfm_michael)) {\r\npriv->tx_tfm_michael = NULL;\r\ngoto fail;\r\n}\r\npriv->rx_tfm_arc4 = crypto_alloc_blkcipher("ecb(arc4)", 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (IS_ERR(priv->rx_tfm_arc4)) {\r\npriv->rx_tfm_arc4 = NULL;\r\ngoto fail;\r\n}\r\npriv->rx_tfm_michael = crypto_alloc_hash("michael_mic", 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (IS_ERR(priv->rx_tfm_michael)) {\r\npriv->rx_tfm_michael = NULL;\r\ngoto fail;\r\n}\r\nreturn priv;\r\nfail:\r\nif (priv) {\r\nif (priv->tx_tfm_michael)\r\ncrypto_free_hash(priv->tx_tfm_michael);\r\nif (priv->tx_tfm_arc4)\r\ncrypto_free_blkcipher(priv->tx_tfm_arc4);\r\nif (priv->rx_tfm_michael)\r\ncrypto_free_hash(priv->rx_tfm_michael);\r\nif (priv->rx_tfm_arc4)\r\ncrypto_free_blkcipher(priv->rx_tfm_arc4);\r\nkfree(priv);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void lib80211_tkip_deinit(void *priv)\r\n{\r\nstruct lib80211_tkip_data *_priv = priv;\r\nif (_priv) {\r\nif (_priv->tx_tfm_michael)\r\ncrypto_free_hash(_priv->tx_tfm_michael);\r\nif (_priv->tx_tfm_arc4)\r\ncrypto_free_blkcipher(_priv->tx_tfm_arc4);\r\nif (_priv->rx_tfm_michael)\r\ncrypto_free_hash(_priv->rx_tfm_michael);\r\nif (_priv->rx_tfm_arc4)\r\ncrypto_free_blkcipher(_priv->rx_tfm_arc4);\r\n}\r\nkfree(priv);\r\n}\r\nstatic inline u16 RotR1(u16 val)\r\n{\r\nreturn (val >> 1) | (val << 15);\r\n}\r\nstatic inline u8 Lo8(u16 val)\r\n{\r\nreturn val & 0xff;\r\n}\r\nstatic inline u8 Hi8(u16 val)\r\n{\r\nreturn val >> 8;\r\n}\r\nstatic inline u16 Lo16(u32 val)\r\n{\r\nreturn val & 0xffff;\r\n}\r\nstatic inline u16 Hi16(u32 val)\r\n{\r\nreturn val >> 16;\r\n}\r\nstatic inline u16 Mk16(u8 hi, u8 lo)\r\n{\r\nreturn lo | (((u16) hi) << 8);\r\n}\r\nstatic inline u16 Mk16_le(__le16 * v)\r\n{\r\nreturn le16_to_cpu(*v);\r\n}\r\nstatic inline u16 _S_(u16 v)\r\n{\r\nu16 t = Sbox[Hi8(v)];\r\nreturn Sbox[Lo8(v)] ^ ((t << 8) | (t >> 8));\r\n}\r\nstatic void tkip_mixing_phase1(u16 * TTAK, const u8 * TK, const u8 * TA,\r\nu32 IV32)\r\n{\r\nint i, j;\r\nTTAK[0] = Lo16(IV32);\r\nTTAK[1] = Hi16(IV32);\r\nTTAK[2] = Mk16(TA[1], TA[0]);\r\nTTAK[3] = Mk16(TA[3], TA[2]);\r\nTTAK[4] = Mk16(TA[5], TA[4]);\r\nfor (i = 0; i < PHASE1_LOOP_COUNT; i++) {\r\nj = 2 * (i & 1);\r\nTTAK[0] += _S_(TTAK[4] ^ Mk16(TK[1 + j], TK[0 + j]));\r\nTTAK[1] += _S_(TTAK[0] ^ Mk16(TK[5 + j], TK[4 + j]));\r\nTTAK[2] += _S_(TTAK[1] ^ Mk16(TK[9 + j], TK[8 + j]));\r\nTTAK[3] += _S_(TTAK[2] ^ Mk16(TK[13 + j], TK[12 + j]));\r\nTTAK[4] += _S_(TTAK[3] ^ Mk16(TK[1 + j], TK[0 + j])) + i;\r\n}\r\n}\r\nstatic void tkip_mixing_phase2(u8 * WEPSeed, const u8 * TK, const u16 * TTAK,\r\nu16 IV16)\r\n{\r\nu16 *PPK = (u16 *) & WEPSeed[4];\r\nPPK[0] = TTAK[0];\r\nPPK[1] = TTAK[1];\r\nPPK[2] = TTAK[2];\r\nPPK[3] = TTAK[3];\r\nPPK[4] = TTAK[4];\r\nPPK[5] = TTAK[4] + IV16;\r\nPPK[0] += _S_(PPK[5] ^ Mk16_le((__le16 *) & TK[0]));\r\nPPK[1] += _S_(PPK[0] ^ Mk16_le((__le16 *) & TK[2]));\r\nPPK[2] += _S_(PPK[1] ^ Mk16_le((__le16 *) & TK[4]));\r\nPPK[3] += _S_(PPK[2] ^ Mk16_le((__le16 *) & TK[6]));\r\nPPK[4] += _S_(PPK[3] ^ Mk16_le((__le16 *) & TK[8]));\r\nPPK[5] += _S_(PPK[4] ^ Mk16_le((__le16 *) & TK[10]));\r\nPPK[0] += RotR1(PPK[5] ^ Mk16_le((__le16 *) & TK[12]));\r\nPPK[1] += RotR1(PPK[0] ^ Mk16_le((__le16 *) & TK[14]));\r\nPPK[2] += RotR1(PPK[1]);\r\nPPK[3] += RotR1(PPK[2]);\r\nPPK[4] += RotR1(PPK[3]);\r\nPPK[5] += RotR1(PPK[4]);\r\nWEPSeed[0] = Hi8(IV16);\r\nWEPSeed[1] = (Hi8(IV16) | 0x20) & 0x7F;\r\nWEPSeed[2] = Lo8(IV16);\r\nWEPSeed[3] = Lo8((PPK[5] ^ Mk16_le((__le16 *) & TK[0])) >> 1);\r\n#ifdef __BIG_ENDIAN\r\n{\r\nint i;\r\nfor (i = 0; i < 6; i++)\r\nPPK[i] = (PPK[i] << 8) | (PPK[i] >> 8);\r\n}\r\n#endif\r\n}\r\nstatic int lib80211_tkip_hdr(struct sk_buff *skb, int hdr_len,\r\nu8 * rc4key, int keylen, void *priv)\r\n{\r\nstruct lib80211_tkip_data *tkey = priv;\r\nu8 *pos;\r\nstruct ieee80211_hdr *hdr;\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\nif (skb_headroom(skb) < TKIP_HDR_LEN || skb->len < hdr_len)\r\nreturn -1;\r\nif (rc4key == NULL || keylen < 16)\r\nreturn -1;\r\nif (!tkey->tx_phase1_done) {\r\ntkip_mixing_phase1(tkey->tx_ttak, tkey->key, hdr->addr2,\r\ntkey->tx_iv32);\r\ntkey->tx_phase1_done = 1;\r\n}\r\ntkip_mixing_phase2(rc4key, tkey->key, tkey->tx_ttak, tkey->tx_iv16);\r\npos = skb_push(skb, TKIP_HDR_LEN);\r\nmemmove(pos, pos + TKIP_HDR_LEN, hdr_len);\r\npos += hdr_len;\r\n*pos++ = *rc4key;\r\n*pos++ = *(rc4key + 1);\r\n*pos++ = *(rc4key + 2);\r\n*pos++ = (tkey->key_idx << 6) | (1 << 5) ;\r\n*pos++ = tkey->tx_iv32 & 0xff;\r\n*pos++ = (tkey->tx_iv32 >> 8) & 0xff;\r\n*pos++ = (tkey->tx_iv32 >> 16) & 0xff;\r\n*pos++ = (tkey->tx_iv32 >> 24) & 0xff;\r\ntkey->tx_iv16++;\r\nif (tkey->tx_iv16 == 0) {\r\ntkey->tx_phase1_done = 0;\r\ntkey->tx_iv32++;\r\n}\r\nreturn TKIP_HDR_LEN;\r\n}\r\nstatic int lib80211_tkip_encrypt(struct sk_buff *skb, int hdr_len, void *priv)\r\n{\r\nstruct lib80211_tkip_data *tkey = priv;\r\nstruct blkcipher_desc desc = { .tfm = tkey->tx_tfm_arc4 };\r\nint len;\r\nu8 rc4key[16], *pos, *icv;\r\nu32 crc;\r\nstruct scatterlist sg;\r\nif (tkey->flags & IEEE80211_CRYPTO_TKIP_COUNTERMEASURES) {\r\nif (net_ratelimit()) {\r\nstruct ieee80211_hdr *hdr =\r\n(struct ieee80211_hdr *)skb->data;\r\nprintk(KERN_DEBUG ": TKIP countermeasures: dropped "\r\n"TX packet to %pM\n", hdr->addr1);\r\n}\r\nreturn -1;\r\n}\r\nif (skb_tailroom(skb) < 4 || skb->len < hdr_len)\r\nreturn -1;\r\nlen = skb->len - hdr_len;\r\npos = skb->data + hdr_len;\r\nif ((lib80211_tkip_hdr(skb, hdr_len, rc4key, 16, priv)) < 0)\r\nreturn -1;\r\ncrc = ~crc32_le(~0, pos, len);\r\nicv = skb_put(skb, 4);\r\nicv[0] = crc;\r\nicv[1] = crc >> 8;\r\nicv[2] = crc >> 16;\r\nicv[3] = crc >> 24;\r\ncrypto_blkcipher_setkey(tkey->tx_tfm_arc4, rc4key, 16);\r\nsg_init_one(&sg, pos, len + 4);\r\nreturn crypto_blkcipher_encrypt(&desc, &sg, &sg, len + 4);\r\n}\r\nstatic inline int tkip_replay_check(u32 iv32_n, u16 iv16_n,\r\nu32 iv32_o, u16 iv16_o)\r\n{\r\nif ((s32)iv32_n - (s32)iv32_o < 0 ||\r\n(iv32_n == iv32_o && iv16_n <= iv16_o))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int lib80211_tkip_decrypt(struct sk_buff *skb, int hdr_len, void *priv)\r\n{\r\nstruct lib80211_tkip_data *tkey = priv;\r\nstruct blkcipher_desc desc = { .tfm = tkey->rx_tfm_arc4 };\r\nu8 rc4key[16];\r\nu8 keyidx, *pos;\r\nu32 iv32;\r\nu16 iv16;\r\nstruct ieee80211_hdr *hdr;\r\nu8 icv[4];\r\nu32 crc;\r\nstruct scatterlist sg;\r\nint plen;\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\nif (tkey->flags & IEEE80211_CRYPTO_TKIP_COUNTERMEASURES) {\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG ": TKIP countermeasures: dropped "\r\n"received packet from %pM\n", hdr->addr2);\r\n}\r\nreturn -1;\r\n}\r\nif (skb->len < hdr_len + TKIP_HDR_LEN + 4)\r\nreturn -1;\r\npos = skb->data + hdr_len;\r\nkeyidx = pos[3];\r\nif (!(keyidx & (1 << 5))) {\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "TKIP: received packet without ExtIV"\r\n" flag from %pM\n", hdr->addr2);\r\n}\r\nreturn -2;\r\n}\r\nkeyidx >>= 6;\r\nif (tkey->key_idx != keyidx) {\r\nprintk(KERN_DEBUG "TKIP: RX tkey->key_idx=%d frame "\r\n"keyidx=%d priv=%p\n", tkey->key_idx, keyidx, priv);\r\nreturn -6;\r\n}\r\nif (!tkey->key_set) {\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "TKIP: received packet from %pM"\r\n" with keyid=%d that does not have a configured"\r\n" key\n", hdr->addr2, keyidx);\r\n}\r\nreturn -3;\r\n}\r\niv16 = (pos[0] << 8) | pos[2];\r\niv32 = pos[4] | (pos[5] << 8) | (pos[6] << 16) | (pos[7] << 24);\r\npos += TKIP_HDR_LEN;\r\nif (tkip_replay_check(iv32, iv16, tkey->rx_iv32, tkey->rx_iv16)) {\r\n#ifdef CONFIG_LIB80211_DEBUG\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "TKIP: replay detected: STA=%pM"\r\n" previous TSC %08x%04x received TSC "\r\n"%08x%04x\n", hdr->addr2,\r\ntkey->rx_iv32, tkey->rx_iv16, iv32, iv16);\r\n}\r\n#endif\r\ntkey->dot11RSNAStatsTKIPReplays++;\r\nreturn -4;\r\n}\r\nif (iv32 != tkey->rx_iv32 || !tkey->rx_phase1_done) {\r\ntkip_mixing_phase1(tkey->rx_ttak, tkey->key, hdr->addr2, iv32);\r\ntkey->rx_phase1_done = 1;\r\n}\r\ntkip_mixing_phase2(rc4key, tkey->key, tkey->rx_ttak, iv16);\r\nplen = skb->len - hdr_len - 12;\r\ncrypto_blkcipher_setkey(tkey->rx_tfm_arc4, rc4key, 16);\r\nsg_init_one(&sg, pos, plen + 4);\r\nif (crypto_blkcipher_decrypt(&desc, &sg, &sg, plen + 4)) {\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG ": TKIP: failed to decrypt "\r\n"received packet from %pM\n",\r\nhdr->addr2);\r\n}\r\nreturn -7;\r\n}\r\ncrc = ~crc32_le(~0, pos, plen);\r\nicv[0] = crc;\r\nicv[1] = crc >> 8;\r\nicv[2] = crc >> 16;\r\nicv[3] = crc >> 24;\r\nif (memcmp(icv, pos + plen, 4) != 0) {\r\nif (iv32 != tkey->rx_iv32) {\r\ntkey->rx_phase1_done = 0;\r\n}\r\n#ifdef CONFIG_LIB80211_DEBUG\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "TKIP: ICV error detected: STA="\r\n"%pM\n", hdr->addr2);\r\n}\r\n#endif\r\ntkey->dot11RSNAStatsTKIPICVErrors++;\r\nreturn -5;\r\n}\r\ntkey->rx_iv32_new = iv32;\r\ntkey->rx_iv16_new = iv16;\r\nmemmove(skb->data + TKIP_HDR_LEN, skb->data, hdr_len);\r\nskb_pull(skb, TKIP_HDR_LEN);\r\nskb_trim(skb, skb->len - 4);\r\nreturn keyidx;\r\n}\r\nstatic int michael_mic(struct crypto_hash *tfm_michael, u8 * key, u8 * hdr,\r\nu8 * data, size_t data_len, u8 * mic)\r\n{\r\nstruct hash_desc desc;\r\nstruct scatterlist sg[2];\r\nif (tfm_michael == NULL) {\r\npr_warn("%s(): tfm_michael == NULL\n", __func__);\r\nreturn -1;\r\n}\r\nsg_init_table(sg, 2);\r\nsg_set_buf(&sg[0], hdr, 16);\r\nsg_set_buf(&sg[1], data, data_len);\r\nif (crypto_hash_setkey(tfm_michael, key, 8))\r\nreturn -1;\r\ndesc.tfm = tfm_michael;\r\ndesc.flags = 0;\r\nreturn crypto_hash_digest(&desc, sg, data_len + 16, mic);\r\n}\r\nstatic void michael_mic_hdr(struct sk_buff *skb, u8 * hdr)\r\n{\r\nstruct ieee80211_hdr *hdr11;\r\nhdr11 = (struct ieee80211_hdr *)skb->data;\r\nswitch (le16_to_cpu(hdr11->frame_control) &\r\n(IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {\r\ncase IEEE80211_FCTL_TODS:\r\nmemcpy(hdr, hdr11->addr3, ETH_ALEN);\r\nmemcpy(hdr + ETH_ALEN, hdr11->addr2, ETH_ALEN);\r\nbreak;\r\ncase IEEE80211_FCTL_FROMDS:\r\nmemcpy(hdr, hdr11->addr1, ETH_ALEN);\r\nmemcpy(hdr + ETH_ALEN, hdr11->addr3, ETH_ALEN);\r\nbreak;\r\ncase IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS:\r\nmemcpy(hdr, hdr11->addr3, ETH_ALEN);\r\nmemcpy(hdr + ETH_ALEN, hdr11->addr4, ETH_ALEN);\r\nbreak;\r\ncase 0:\r\nmemcpy(hdr, hdr11->addr1, ETH_ALEN);\r\nmemcpy(hdr + ETH_ALEN, hdr11->addr2, ETH_ALEN);\r\nbreak;\r\n}\r\nif (ieee80211_is_data_qos(hdr11->frame_control)) {\r\nhdr[12] = le16_to_cpu(*((__le16 *)ieee80211_get_qos_ctl(hdr11)))\r\n& IEEE80211_QOS_CTL_TID_MASK;\r\n} else\r\nhdr[12] = 0;\r\nhdr[13] = hdr[14] = hdr[15] = 0;\r\n}\r\nstatic int lib80211_michael_mic_add(struct sk_buff *skb, int hdr_len,\r\nvoid *priv)\r\n{\r\nstruct lib80211_tkip_data *tkey = priv;\r\nu8 *pos;\r\nif (skb_tailroom(skb) < 8 || skb->len < hdr_len) {\r\nprintk(KERN_DEBUG "Invalid packet for Michael MIC add "\r\n"(tailroom=%d hdr_len=%d skb->len=%d)\n",\r\nskb_tailroom(skb), hdr_len, skb->len);\r\nreturn -1;\r\n}\r\nmichael_mic_hdr(skb, tkey->tx_hdr);\r\npos = skb_put(skb, 8);\r\nif (michael_mic(tkey->tx_tfm_michael, &tkey->key[16], tkey->tx_hdr,\r\nskb->data + hdr_len, skb->len - 8 - hdr_len, pos))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void lib80211_michael_mic_failure(struct net_device *dev,\r\nstruct ieee80211_hdr *hdr,\r\nint keyidx)\r\n{\r\nunion iwreq_data wrqu;\r\nstruct iw_michaelmicfailure ev;\r\nmemset(&ev, 0, sizeof(ev));\r\nev.flags = keyidx & IW_MICFAILURE_KEY_ID;\r\nif (hdr->addr1[0] & 0x01)\r\nev.flags |= IW_MICFAILURE_GROUP;\r\nelse\r\nev.flags |= IW_MICFAILURE_PAIRWISE;\r\nev.src_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(ev.src_addr.sa_data, hdr->addr2, ETH_ALEN);\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwrqu.data.length = sizeof(ev);\r\nwireless_send_event(dev, IWEVMICHAELMICFAILURE, &wrqu, (char *)&ev);\r\n}\r\nstatic int lib80211_michael_mic_verify(struct sk_buff *skb, int keyidx,\r\nint hdr_len, void *priv)\r\n{\r\nstruct lib80211_tkip_data *tkey = priv;\r\nu8 mic[8];\r\nif (!tkey->key_set)\r\nreturn -1;\r\nmichael_mic_hdr(skb, tkey->rx_hdr);\r\nif (michael_mic(tkey->rx_tfm_michael, &tkey->key[24], tkey->rx_hdr,\r\nskb->data + hdr_len, skb->len - 8 - hdr_len, mic))\r\nreturn -1;\r\nif (memcmp(mic, skb->data + skb->len - 8, 8) != 0) {\r\nstruct ieee80211_hdr *hdr;\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\nprintk(KERN_DEBUG "%s: Michael MIC verification failed for "\r\n"MSDU from %pM keyidx=%d\n",\r\nskb->dev ? skb->dev->name : "N/A", hdr->addr2,\r\nkeyidx);\r\nif (skb->dev)\r\nlib80211_michael_mic_failure(skb->dev, hdr, keyidx);\r\ntkey->dot11RSNAStatsTKIPLocalMICFailures++;\r\nreturn -1;\r\n}\r\ntkey->rx_iv32 = tkey->rx_iv32_new;\r\ntkey->rx_iv16 = tkey->rx_iv16_new;\r\nskb_trim(skb, skb->len - 8);\r\nreturn 0;\r\n}\r\nstatic int lib80211_tkip_set_key(void *key, int len, u8 * seq, void *priv)\r\n{\r\nstruct lib80211_tkip_data *tkey = priv;\r\nint keyidx;\r\nstruct crypto_hash *tfm = tkey->tx_tfm_michael;\r\nstruct crypto_blkcipher *tfm2 = tkey->tx_tfm_arc4;\r\nstruct crypto_hash *tfm3 = tkey->rx_tfm_michael;\r\nstruct crypto_blkcipher *tfm4 = tkey->rx_tfm_arc4;\r\nkeyidx = tkey->key_idx;\r\nmemset(tkey, 0, sizeof(*tkey));\r\ntkey->key_idx = keyidx;\r\ntkey->tx_tfm_michael = tfm;\r\ntkey->tx_tfm_arc4 = tfm2;\r\ntkey->rx_tfm_michael = tfm3;\r\ntkey->rx_tfm_arc4 = tfm4;\r\nif (len == TKIP_KEY_LEN) {\r\nmemcpy(tkey->key, key, TKIP_KEY_LEN);\r\ntkey->key_set = 1;\r\ntkey->tx_iv16 = 1;\r\nif (seq) {\r\ntkey->rx_iv32 = (seq[5] << 24) | (seq[4] << 16) |\r\n(seq[3] << 8) | seq[2];\r\ntkey->rx_iv16 = (seq[1] << 8) | seq[0];\r\n}\r\n} else if (len == 0)\r\ntkey->key_set = 0;\r\nelse\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int lib80211_tkip_get_key(void *key, int len, u8 * seq, void *priv)\r\n{\r\nstruct lib80211_tkip_data *tkey = priv;\r\nif (len < TKIP_KEY_LEN)\r\nreturn -1;\r\nif (!tkey->key_set)\r\nreturn 0;\r\nmemcpy(key, tkey->key, TKIP_KEY_LEN);\r\nif (seq) {\r\nu16 iv16 = tkey->tx_iv16;\r\nu32 iv32 = tkey->tx_iv32;\r\nif (iv16 == 0)\r\niv32--;\r\niv16--;\r\nseq[0] = tkey->tx_iv16;\r\nseq[1] = tkey->tx_iv16 >> 8;\r\nseq[2] = tkey->tx_iv32;\r\nseq[3] = tkey->tx_iv32 >> 8;\r\nseq[4] = tkey->tx_iv32 >> 16;\r\nseq[5] = tkey->tx_iv32 >> 24;\r\n}\r\nreturn TKIP_KEY_LEN;\r\n}\r\nstatic char *lib80211_tkip_print_stats(char *p, void *priv)\r\n{\r\nstruct lib80211_tkip_data *tkip = priv;\r\np += sprintf(p, "key[%d] alg=TKIP key_set=%d "\r\n"tx_pn=%02x%02x%02x%02x%02x%02x "\r\n"rx_pn=%02x%02x%02x%02x%02x%02x "\r\n"replays=%d icv_errors=%d local_mic_failures=%d\n",\r\ntkip->key_idx, tkip->key_set,\r\n(tkip->tx_iv32 >> 24) & 0xff,\r\n(tkip->tx_iv32 >> 16) & 0xff,\r\n(tkip->tx_iv32 >> 8) & 0xff,\r\ntkip->tx_iv32 & 0xff,\r\n(tkip->tx_iv16 >> 8) & 0xff,\r\ntkip->tx_iv16 & 0xff,\r\n(tkip->rx_iv32 >> 24) & 0xff,\r\n(tkip->rx_iv32 >> 16) & 0xff,\r\n(tkip->rx_iv32 >> 8) & 0xff,\r\ntkip->rx_iv32 & 0xff,\r\n(tkip->rx_iv16 >> 8) & 0xff,\r\ntkip->rx_iv16 & 0xff,\r\ntkip->dot11RSNAStatsTKIPReplays,\r\ntkip->dot11RSNAStatsTKIPICVErrors,\r\ntkip->dot11RSNAStatsTKIPLocalMICFailures);\r\nreturn p;\r\n}\r\nstatic int __init lib80211_crypto_tkip_init(void)\r\n{\r\nreturn lib80211_register_crypto_ops(&lib80211_crypt_tkip);\r\n}\r\nstatic void __exit lib80211_crypto_tkip_exit(void)\r\n{\r\nlib80211_unregister_crypto_ops(&lib80211_crypt_tkip);\r\n}
