static int smu_set_fan(int pwm, u8 id, u16 value)\r\n{\r\nstruct smu_cmd cmd;\r\nu8 buffer[16];\r\nDECLARE_COMPLETION_ONSTACK(comp);\r\nint rc;\r\ncmd.cmd = SMU_CMD_FAN_COMMAND;\r\nretry:\r\nif (smu_supports_new_fans_ops) {\r\nbuffer[0] = 0x30;\r\nbuffer[1] = id;\r\n*((u16 *)(&buffer[2])) = value;\r\ncmd.data_len = 4;\r\n} else {\r\nif (id > 7)\r\nreturn -EINVAL;\r\nmemset(buffer, 0, 16);\r\nbuffer[0] = pwm ? 0x10 : 0x00;\r\nbuffer[1] = 0x01 << id;\r\n*((u16 *)&buffer[2 + id * 2]) = value;\r\ncmd.data_len = 14;\r\n}\r\ncmd.reply_len = 16;\r\ncmd.data_buf = cmd.reply_buf = buffer;\r\ncmd.status = 0;\r\ncmd.done = smu_done_complete;\r\ncmd.misc = &comp;\r\nrc = smu_queue_cmd(&cmd);\r\nif (rc)\r\nreturn rc;\r\nwait_for_completion(&comp);\r\nif (cmd.status != 0 && smu_supports_new_fans_ops) {\r\nprintk(KERN_WARNING "windfarm: SMU failed new fan command "\r\n"falling back to old method\n");\r\nsmu_supports_new_fans_ops = 0;\r\ngoto retry;\r\n}\r\nreturn cmd.status;\r\n}\r\nstatic void smu_fan_release(struct wf_control *ct)\r\n{\r\nstruct smu_fan_control *fct = to_smu_fan(ct);\r\nkfree(fct);\r\n}\r\nstatic int smu_fan_set(struct wf_control *ct, s32 value)\r\n{\r\nstruct smu_fan_control *fct = to_smu_fan(ct);\r\nif (value < fct->min)\r\nvalue = fct->min;\r\nif (value > fct->max)\r\nvalue = fct->max;\r\nfct->value = value;\r\nreturn smu_set_fan(fct->fan_type, fct->reg, value);\r\n}\r\nstatic int smu_fan_get(struct wf_control *ct, s32 *value)\r\n{\r\nstruct smu_fan_control *fct = to_smu_fan(ct);\r\n*value = fct->value;\r\nreturn 0;\r\n}\r\nstatic s32 smu_fan_min(struct wf_control *ct)\r\n{\r\nstruct smu_fan_control *fct = to_smu_fan(ct);\r\nreturn fct->min;\r\n}\r\nstatic s32 smu_fan_max(struct wf_control *ct)\r\n{\r\nstruct smu_fan_control *fct = to_smu_fan(ct);\r\nreturn fct->max;\r\n}\r\nstatic struct smu_fan_control *smu_fan_create(struct device_node *node,\r\nint pwm_fan)\r\n{\r\nstruct smu_fan_control *fct;\r\nconst s32 *v;\r\nconst u32 *reg;\r\nconst char *l;\r\nfct = kmalloc(sizeof(struct smu_fan_control), GFP_KERNEL);\r\nif (fct == NULL)\r\nreturn NULL;\r\nfct->ctrl.ops = &smu_fan_ops;\r\nl = of_get_property(node, "location", NULL);\r\nif (l == NULL)\r\ngoto fail;\r\nfct->fan_type = pwm_fan;\r\nfct->ctrl.type = pwm_fan ? WF_CONTROL_PWM_FAN : WF_CONTROL_RPM_FAN;\r\nsysfs_attr_init(&fct->ctrl.attr.attr);\r\nfct->ctrl.name = NULL;\r\nif (!strcmp(l, "Rear Fan 0") || !strcmp(l, "Rear Fan") ||\r\n!strcmp(l, "Rear fan 0") || !strcmp(l, "Rear fan") ||\r\n!strcmp(l, "CPU A EXHAUST"))\r\nfct->ctrl.name = "cpu-rear-fan-0";\r\nelse if (!strcmp(l, "Rear Fan 1") || !strcmp(l, "Rear fan 1") ||\r\n!strcmp(l, "CPU B EXHAUST"))\r\nfct->ctrl.name = "cpu-rear-fan-1";\r\nelse if (!strcmp(l, "Front Fan 0") || !strcmp(l, "Front Fan") ||\r\n!strcmp(l, "Front fan 0") || !strcmp(l, "Front fan") ||\r\n!strcmp(l, "CPU A INTAKE"))\r\nfct->ctrl.name = "cpu-front-fan-0";\r\nelse if (!strcmp(l, "Front Fan 1") || !strcmp(l, "Front fan 1") ||\r\n!strcmp(l, "CPU B INTAKE"))\r\nfct->ctrl.name = "cpu-front-fan-1";\r\nelse if (!strcmp(l, "CPU A PUMP"))\r\nfct->ctrl.name = "cpu-pump-0";\r\nelse if (!strcmp(l, "CPU B PUMP"))\r\nfct->ctrl.name = "cpu-pump-1";\r\nelse if (!strcmp(l, "Slots Fan") || !strcmp(l, "Slots fan") ||\r\n!strcmp(l, "EXPANSION SLOTS INTAKE"))\r\nfct->ctrl.name = "slots-fan";\r\nelse if (!strcmp(l, "Drive Bay") || !strcmp(l, "Drive bay") ||\r\n!strcmp(l, "DRIVE BAY A INTAKE"))\r\nfct->ctrl.name = "drive-bay-fan";\r\nelse if (!strcmp(l, "BACKSIDE"))\r\nfct->ctrl.name = "backside-fan";\r\nif (!strcmp(l, "System Fan") || !strcmp(l, "System fan"))\r\nfct->ctrl.name = "system-fan";\r\nelse if (!strcmp(l, "CPU Fan") || !strcmp(l, "CPU fan"))\r\nfct->ctrl.name = "cpu-fan";\r\nelse if (!strcmp(l, "Hard Drive") || !strcmp(l, "Hard drive"))\r\nfct->ctrl.name = "drive-bay-fan";\r\nelse if (!strcmp(l, "HDD Fan"))\r\nfct->ctrl.name = "hard-drive-fan";\r\nelse if (!strcmp(l, "ODD Fan"))\r\nfct->ctrl.name = "optical-drive-fan";\r\nif (fct->ctrl.name == NULL)\r\ngoto fail;\r\nv = of_get_property(node, "min-value", NULL);\r\nif (v == NULL)\r\ngoto fail;\r\nfct->min = *v;\r\nv = of_get_property(node, "max-value", NULL);\r\nif (v == NULL)\r\ngoto fail;\r\nfct->max = *v;\r\nreg = of_get_property(node, "reg", NULL);\r\nif (reg == NULL)\r\ngoto fail;\r\nfct->reg = *reg;\r\nif (wf_register_control(&fct->ctrl))\r\ngoto fail;\r\nreturn fct;\r\nfail:\r\nkfree(fct);\r\nreturn NULL;\r\n}\r\nstatic int __init smu_controls_init(void)\r\n{\r\nstruct device_node *smu, *fans, *fan;\r\nif (!smu_present())\r\nreturn -ENODEV;\r\nsmu = of_find_node_by_type(NULL, "smu");\r\nif (smu == NULL)\r\nreturn -ENODEV;\r\nfor (fans = NULL; (fans = of_get_next_child(smu, fans)) != NULL;)\r\nif (!strcmp(fans->name, "rpm-fans") ||\r\nof_device_is_compatible(fans, "smu-rpm-fans"))\r\nbreak;\r\nfor (fan = NULL;\r\nfans && (fan = of_get_next_child(fans, fan)) != NULL;) {\r\nstruct smu_fan_control *fct;\r\nfct = smu_fan_create(fan, 0);\r\nif (fct == NULL) {\r\nprintk(KERN_WARNING "windfarm: Failed to create SMU "\r\n"RPM fan %s\n", fan->name);\r\ncontinue;\r\n}\r\nlist_add(&fct->link, &smu_fans);\r\n}\r\nof_node_put(fans);\r\nfor (fans = NULL; (fans = of_get_next_child(smu, fans)) != NULL;)\r\nif (!strcmp(fans->name, "pwm-fans"))\r\nbreak;\r\nfor (fan = NULL;\r\nfans && (fan = of_get_next_child(fans, fan)) != NULL;) {\r\nstruct smu_fan_control *fct;\r\nfct = smu_fan_create(fan, 1);\r\nif (fct == NULL) {\r\nprintk(KERN_WARNING "windfarm: Failed to create SMU "\r\n"PWM fan %s\n", fan->name);\r\ncontinue;\r\n}\r\nlist_add(&fct->link, &smu_fans);\r\n}\r\nof_node_put(fans);\r\nof_node_put(smu);\r\nreturn 0;\r\n}\r\nstatic void __exit smu_controls_exit(void)\r\n{\r\nstruct smu_fan_control *fct;\r\nwhile (!list_empty(&smu_fans)) {\r\nfct = list_entry(smu_fans.next, struct smu_fan_control, link);\r\nlist_del(&fct->link);\r\nwf_unregister_control(&fct->ctrl);\r\n}\r\n}
