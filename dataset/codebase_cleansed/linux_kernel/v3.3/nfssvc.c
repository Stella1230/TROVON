int nfsd_vers(int vers, enum vers_op change)\r\n{\r\nif (vers < NFSD_MINVERS || vers >= NFSD_NRVERS)\r\nreturn 0;\r\nswitch(change) {\r\ncase NFSD_SET:\r\nnfsd_versions[vers] = nfsd_version[vers];\r\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\r\nif (vers < NFSD_ACL_NRVERS)\r\nnfsd_acl_versions[vers] = nfsd_acl_version[vers];\r\n#endif\r\nbreak;\r\ncase NFSD_CLEAR:\r\nnfsd_versions[vers] = NULL;\r\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\r\nif (vers < NFSD_ACL_NRVERS)\r\nnfsd_acl_versions[vers] = NULL;\r\n#endif\r\nbreak;\r\ncase NFSD_TEST:\r\nreturn nfsd_versions[vers] != NULL;\r\ncase NFSD_AVAIL:\r\nreturn nfsd_version[vers] != NULL;\r\n}\r\nreturn 0;\r\n}\r\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\r\n{\r\nif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\r\nreturn -1;\r\nswitch(change) {\r\ncase NFSD_SET:\r\nnfsd_supported_minorversion = minorversion;\r\nbreak;\r\ncase NFSD_CLEAR:\r\nif (minorversion == 0)\r\nreturn -1;\r\nnfsd_supported_minorversion = minorversion - 1;\r\nbreak;\r\ncase NFSD_TEST:\r\nreturn minorversion <= nfsd_supported_minorversion;\r\ncase NFSD_AVAIL:\r\nreturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\r\n}\r\nreturn 0;\r\n}\r\nint nfsd_nrthreads(void)\r\n{\r\nint rv = 0;\r\nmutex_lock(&nfsd_mutex);\r\nif (nfsd_serv)\r\nrv = nfsd_serv->sv_nrthreads;\r\nmutex_unlock(&nfsd_mutex);\r\nreturn rv;\r\n}\r\nstatic int nfsd_init_socks(int port)\r\n{\r\nint error;\r\nif (!list_empty(&nfsd_serv->sv_permsocks))\r\nreturn 0;\r\nerror = svc_create_xprt(nfsd_serv, "udp", &init_net, PF_INET, port,\r\nSVC_SOCK_DEFAULTS);\r\nif (error < 0)\r\nreturn error;\r\nerror = svc_create_xprt(nfsd_serv, "tcp", &init_net, PF_INET, port,\r\nSVC_SOCK_DEFAULTS);\r\nif (error < 0)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int nfsd_startup(unsigned short port, int nrservs)\r\n{\r\nint ret;\r\nif (nfsd_up)\r\nreturn 0;\r\nret = nfsd_racache_init(2*nrservs);\r\nif (ret)\r\nreturn ret;\r\nret = nfsd_init_socks(port);\r\nif (ret)\r\ngoto out_racache;\r\nret = lockd_up();\r\nif (ret)\r\ngoto out_racache;\r\nret = nfs4_state_start();\r\nif (ret)\r\ngoto out_lockd;\r\nnfsd_up = true;\r\nreturn 0;\r\nout_lockd:\r\nlockd_down();\r\nout_racache:\r\nnfsd_racache_shutdown();\r\nreturn ret;\r\n}\r\nstatic void nfsd_shutdown(void)\r\n{\r\nif (!nfsd_up)\r\nreturn;\r\nnfs4_state_shutdown();\r\nlockd_down();\r\nnfsd_racache_shutdown();\r\nnfsd_up = false;\r\n}\r\nstatic void nfsd_last_thread(struct svc_serv *serv)\r\n{\r\nnfsd_serv = NULL;\r\nnfsd_shutdown();\r\nsvc_rpcb_cleanup(serv);\r\nprintk(KERN_WARNING "nfsd: last server has exited, flushing export "\r\n"cache\n");\r\nnfsd_export_flush();\r\n}\r\nvoid nfsd_reset_versions(void)\r\n{\r\nint found_one = 0;\r\nint i;\r\nfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++) {\r\nif (nfsd_program.pg_vers[i])\r\nfound_one = 1;\r\n}\r\nif (!found_one) {\r\nfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++)\r\nnfsd_program.pg_vers[i] = nfsd_version[i];\r\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\r\nfor (i = NFSD_ACL_MINVERS; i < NFSD_ACL_NRVERS; i++)\r\nnfsd_acl_program.pg_vers[i] =\r\nnfsd_acl_version[i];\r\n#endif\r\n}\r\n}\r\nstatic void set_max_drc(void)\r\n{\r\n#define NFSD_DRC_SIZE_SHIFT 10\r\nnfsd_drc_max_mem = (nr_free_buffer_pages()\r\n>> NFSD_DRC_SIZE_SHIFT) * PAGE_SIZE;\r\nnfsd_drc_mem_used = 0;\r\nspin_lock_init(&nfsd_drc_lock);\r\ndprintk("%s nfsd_drc_max_mem %u \n", __func__, nfsd_drc_max_mem);\r\n}\r\nint nfsd_create_serv(void)\r\n{\r\nint err = 0;\r\nWARN_ON(!mutex_is_locked(&nfsd_mutex));\r\nif (nfsd_serv) {\r\nsvc_get(nfsd_serv);\r\nreturn 0;\r\n}\r\nif (nfsd_max_blksize == 0) {\r\nstruct sysinfo i;\r\nsi_meminfo(&i);\r\nnfsd_max_blksize = NFSSVC_MAXBLKSIZE;\r\ni.totalram <<= PAGE_SHIFT - 12;\r\nwhile (nfsd_max_blksize > i.totalram &&\r\nnfsd_max_blksize >= 8*1024*2)\r\nnfsd_max_blksize /= 2;\r\n}\r\nnfsd_reset_versions();\r\nnfsd_serv = svc_create_pooled(&nfsd_program, nfsd_max_blksize,\r\nnfsd_last_thread, nfsd, THIS_MODULE);\r\nif (nfsd_serv == NULL)\r\nreturn -ENOMEM;\r\nset_max_drc();\r\ndo_gettimeofday(&nfssvc_boot);\r\nreturn err;\r\n}\r\nint nfsd_nrpools(void)\r\n{\r\nif (nfsd_serv == NULL)\r\nreturn 0;\r\nelse\r\nreturn nfsd_serv->sv_nrpools;\r\n}\r\nint nfsd_get_nrthreads(int n, int *nthreads)\r\n{\r\nint i = 0;\r\nif (nfsd_serv != NULL) {\r\nfor (i = 0; i < nfsd_serv->sv_nrpools && i < n; i++)\r\nnthreads[i] = nfsd_serv->sv_pools[i].sp_nrthreads;\r\n}\r\nreturn 0;\r\n}\r\nint nfsd_set_nrthreads(int n, int *nthreads)\r\n{\r\nint i = 0;\r\nint tot = 0;\r\nint err = 0;\r\nWARN_ON(!mutex_is_locked(&nfsd_mutex));\r\nif (nfsd_serv == NULL || n <= 0)\r\nreturn 0;\r\nif (n > nfsd_serv->sv_nrpools)\r\nn = nfsd_serv->sv_nrpools;\r\ntot = 0;\r\nfor (i = 0; i < n; i++) {\r\nif (nthreads[i] > NFSD_MAXSERVS)\r\nnthreads[i] = NFSD_MAXSERVS;\r\ntot += nthreads[i];\r\n}\r\nif (tot > NFSD_MAXSERVS) {\r\nfor (i = 0; i < n && tot > 0; i++) {\r\nint new = nthreads[i] * NFSD_MAXSERVS / tot;\r\ntot -= (nthreads[i] - new);\r\nnthreads[i] = new;\r\n}\r\nfor (i = 0; i < n && tot > 0; i++) {\r\nnthreads[i]--;\r\ntot--;\r\n}\r\n}\r\nif (nthreads[0] == 0)\r\nnthreads[0] = 1;\r\nsvc_get(nfsd_serv);\r\nfor (i = 0; i < n; i++) {\r\nerr = svc_set_num_threads(nfsd_serv, &nfsd_serv->sv_pools[i],\r\nnthreads[i]);\r\nif (err)\r\nbreak;\r\n}\r\nsvc_destroy(nfsd_serv);\r\nreturn err;\r\n}\r\nint\r\nnfsd_svc(unsigned short port, int nrservs)\r\n{\r\nint error;\r\nbool nfsd_up_before;\r\nmutex_lock(&nfsd_mutex);\r\ndprintk("nfsd: creating service\n");\r\nif (nrservs <= 0)\r\nnrservs = 0;\r\nif (nrservs > NFSD_MAXSERVS)\r\nnrservs = NFSD_MAXSERVS;\r\nerror = 0;\r\nif (nrservs == 0 && nfsd_serv == NULL)\r\ngoto out;\r\nerror = nfsd_create_serv();\r\nif (error)\r\ngoto out;\r\nnfsd_up_before = nfsd_up;\r\nerror = nfsd_startup(port, nrservs);\r\nif (error)\r\ngoto out_destroy;\r\nerror = svc_set_num_threads(nfsd_serv, NULL, nrservs);\r\nif (error)\r\ngoto out_shutdown;\r\nerror = nfsd_serv->sv_nrthreads - 1;\r\nout_shutdown:\r\nif (error < 0 && !nfsd_up_before)\r\nnfsd_shutdown();\r\nout_destroy:\r\nsvc_destroy(nfsd_serv);\r\nout:\r\nmutex_unlock(&nfsd_mutex);\r\nreturn error;\r\n}\r\nstatic int\r\nnfsd(void *vrqstp)\r\n{\r\nstruct svc_rqst *rqstp = (struct svc_rqst *) vrqstp;\r\nint err, preverr = 0;\r\nmutex_lock(&nfsd_mutex);\r\nif (unshare_fs_struct() < 0) {\r\nprintk("Unable to start nfsd thread: out of memory\n");\r\ngoto out;\r\n}\r\ncurrent->fs->umask = 0;\r\nallow_signal(SIGKILL);\r\nallow_signal(SIGHUP);\r\nallow_signal(SIGINT);\r\nallow_signal(SIGQUIT);\r\nnfsdstats.th_cnt++;\r\nmutex_unlock(&nfsd_mutex);\r\ncurrent->flags |= PF_LESS_THROTTLE;\r\nset_freezable();\r\nfor (;;) {\r\nwhile ((err = svc_recv(rqstp, 60*60*HZ)) == -EAGAIN)\r\n;\r\nif (err == -EINTR)\r\nbreak;\r\nelse if (err < 0) {\r\nif (err != preverr) {\r\nprintk(KERN_WARNING "%s: unexpected error "\r\n"from svc_recv (%d)\n", __func__, -err);\r\npreverr = err;\r\n}\r\nschedule_timeout_uninterruptible(HZ);\r\ncontinue;\r\n}\r\nvalidate_process_creds();\r\nsvc_process(rqstp);\r\nvalidate_process_creds();\r\n}\r\nflush_signals(current);\r\nmutex_lock(&nfsd_mutex);\r\nnfsdstats.th_cnt --;\r\nout:\r\nsvc_exit_thread(rqstp);\r\nmutex_unlock(&nfsd_mutex);\r\nmodule_put_and_exit(0);\r\nreturn 0;\r\n}\r\nstatic __be32 map_new_errors(u32 vers, __be32 nfserr)\r\n{\r\nif (nfserr == nfserr_jukebox && vers == 2)\r\nreturn nfserr_dropit;\r\nif (nfserr == nfserr_wrongsec && vers < 4)\r\nreturn nfserr_acces;\r\nreturn nfserr;\r\n}\r\nint\r\nnfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)\r\n{\r\nstruct svc_procedure *proc;\r\nkxdrproc_t xdr;\r\n__be32 nfserr;\r\n__be32 *nfserrp;\r\ndprintk("nfsd_dispatch: vers %d proc %d\n",\r\nrqstp->rq_vers, rqstp->rq_proc);\r\nproc = rqstp->rq_procinfo;\r\nrqstp->rq_cachetype = proc->pc_cachetype;\r\nxdr = proc->pc_decode;\r\nif (xdr && !xdr(rqstp, (__be32*)rqstp->rq_arg.head[0].iov_base,\r\nrqstp->rq_argp)) {\r\ndprintk("nfsd: failed to decode arguments!\n");\r\n*statp = rpc_garbage_args;\r\nreturn 1;\r\n}\r\nswitch (nfsd_cache_lookup(rqstp)) {\r\ncase RC_INTR:\r\ncase RC_DROPIT:\r\nreturn 0;\r\ncase RC_REPLY:\r\nreturn 1;\r\ncase RC_DOIT:;\r\n}\r\nnfserrp = rqstp->rq_res.head[0].iov_base\r\n+ rqstp->rq_res.head[0].iov_len;\r\nrqstp->rq_res.head[0].iov_len += sizeof(__be32);\r\nnfserr = proc->pc_func(rqstp, rqstp->rq_argp, rqstp->rq_resp);\r\nnfserr = map_new_errors(rqstp->rq_vers, nfserr);\r\nif (nfserr == nfserr_dropit || rqstp->rq_dropme) {\r\ndprintk("nfsd: Dropping request; may be revisited later\n");\r\nnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\r\nreturn 0;\r\n}\r\nif (rqstp->rq_proc != 0)\r\n*nfserrp++ = nfserr;\r\nif (!(nfserr && rqstp->rq_vers == 2)) {\r\nxdr = proc->pc_encode;\r\nif (xdr && !xdr(rqstp, nfserrp,\r\nrqstp->rq_resp)) {\r\ndprintk("nfsd: failed to encode result!\n");\r\nnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\r\n*statp = rpc_system_err;\r\nreturn 1;\r\n}\r\n}\r\nnfsd_cache_update(rqstp, proc->pc_cachetype, statp + 1);\r\nreturn 1;\r\n}\r\nint nfsd_pool_stats_open(struct inode *inode, struct file *file)\r\n{\r\nint ret;\r\nmutex_lock(&nfsd_mutex);\r\nif (nfsd_serv == NULL) {\r\nmutex_unlock(&nfsd_mutex);\r\nreturn -ENODEV;\r\n}\r\nsvc_get(nfsd_serv);\r\nret = svc_pool_stats_open(nfsd_serv, file);\r\nmutex_unlock(&nfsd_mutex);\r\nreturn ret;\r\n}\r\nint nfsd_pool_stats_release(struct inode *inode, struct file *file)\r\n{\r\nint ret = seq_release(inode, file);\r\nmutex_lock(&nfsd_mutex);\r\nsvc_destroy(nfsd_serv);\r\nmutex_unlock(&nfsd_mutex);\r\nreturn ret;\r\n}
