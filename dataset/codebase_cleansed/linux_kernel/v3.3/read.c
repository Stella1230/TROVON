struct nfs_read_data *nfs_readdata_alloc(unsigned int pagecount)\r\n{\r\nstruct nfs_read_data *p;\r\np = kmem_cache_zalloc(nfs_rdata_cachep, GFP_KERNEL);\r\nif (p) {\r\nINIT_LIST_HEAD(&p->pages);\r\np->npages = pagecount;\r\nif (pagecount <= ARRAY_SIZE(p->page_array))\r\np->pagevec = p->page_array;\r\nelse {\r\np->pagevec = kcalloc(pagecount, sizeof(struct page *), GFP_KERNEL);\r\nif (!p->pagevec) {\r\nkmem_cache_free(nfs_rdata_cachep, p);\r\np = NULL;\r\n}\r\n}\r\n}\r\nreturn p;\r\n}\r\nvoid nfs_readdata_free(struct nfs_read_data *p)\r\n{\r\nif (p && (p->pagevec != &p->page_array[0]))\r\nkfree(p->pagevec);\r\nkmem_cache_free(nfs_rdata_cachep, p);\r\n}\r\nvoid nfs_readdata_release(struct nfs_read_data *rdata)\r\n{\r\nput_lseg(rdata->lseg);\r\nput_nfs_open_context(rdata->args.context);\r\nnfs_readdata_free(rdata);\r\n}\r\nstatic\r\nint nfs_return_empty_page(struct page *page)\r\n{\r\nzero_user(page, 0, PAGE_CACHE_SIZE);\r\nSetPageUptodate(page);\r\nunlock_page(page);\r\nreturn 0;\r\n}\r\nstatic void nfs_readpage_truncate_uninitialised_page(struct nfs_read_data *data)\r\n{\r\nunsigned int remainder = data->args.count - data->res.count;\r\nunsigned int base = data->args.pgbase + data->res.count;\r\nunsigned int pglen;\r\nstruct page **pages;\r\nif (data->res.eof == 0 || remainder == 0)\r\nreturn;\r\npages = &data->args.pages[base >> PAGE_CACHE_SHIFT];\r\nbase &= ~PAGE_CACHE_MASK;\r\npglen = PAGE_CACHE_SIZE - base;\r\nfor (;;) {\r\nif (remainder <= pglen) {\r\nzero_user(*pages, base, remainder);\r\nbreak;\r\n}\r\nzero_user(*pages, base, pglen);\r\npages++;\r\nremainder -= pglen;\r\npglen = PAGE_CACHE_SIZE;\r\nbase = 0;\r\n}\r\n}\r\nvoid nfs_pageio_init_read_mds(struct nfs_pageio_descriptor *pgio,\r\nstruct inode *inode)\r\n{\r\nnfs_pageio_init(pgio, inode, &nfs_pageio_read_ops,\r\nNFS_SERVER(inode)->rsize, 0);\r\n}\r\nvoid nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio)\r\n{\r\npgio->pg_ops = &nfs_pageio_read_ops;\r\npgio->pg_bsize = NFS_SERVER(pgio->pg_inode)->rsize;\r\n}\r\nstatic void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,\r\nstruct inode *inode)\r\n{\r\nif (!pnfs_pageio_init_read(pgio, inode))\r\nnfs_pageio_init_read_mds(pgio, inode);\r\n}\r\nint nfs_readpage_async(struct nfs_open_context *ctx, struct inode *inode,\r\nstruct page *page)\r\n{\r\nstruct nfs_page *new;\r\nunsigned int len;\r\nstruct nfs_pageio_descriptor pgio;\r\nlen = nfs_page_length(page);\r\nif (len == 0)\r\nreturn nfs_return_empty_page(page);\r\nnew = nfs_create_request(ctx, inode, page, 0, len);\r\nif (IS_ERR(new)) {\r\nunlock_page(page);\r\nreturn PTR_ERR(new);\r\n}\r\nif (len < PAGE_CACHE_SIZE)\r\nzero_user_segment(page, len, PAGE_CACHE_SIZE);\r\nnfs_pageio_init_read(&pgio, inode);\r\nnfs_pageio_add_request(&pgio, new);\r\nnfs_pageio_complete(&pgio);\r\nreturn 0;\r\n}\r\nstatic void nfs_readpage_release(struct nfs_page *req)\r\n{\r\nstruct inode *d_inode = req->wb_context->dentry->d_inode;\r\nif (PageUptodate(req->wb_page))\r\nnfs_readpage_to_fscache(d_inode, req->wb_page, 0);\r\nunlock_page(req->wb_page);\r\ndprintk("NFS: read done (%s/%Ld %d@%Ld)\n",\r\nreq->wb_context->dentry->d_inode->i_sb->s_id,\r\n(long long)NFS_FILEID(req->wb_context->dentry->d_inode),\r\nreq->wb_bytes,\r\n(long long)req_offset(req));\r\nnfs_release_request(req);\r\n}\r\nint nfs_initiate_read(struct nfs_read_data *data, struct rpc_clnt *clnt,\r\nconst struct rpc_call_ops *call_ops)\r\n{\r\nstruct inode *inode = data->inode;\r\nint swap_flags = IS_SWAPFILE(inode) ? NFS_RPC_SWAPFLAGS : 0;\r\nstruct rpc_task *task;\r\nstruct rpc_message msg = {\r\n.rpc_argp = &data->args,\r\n.rpc_resp = &data->res,\r\n.rpc_cred = data->cred,\r\n};\r\nstruct rpc_task_setup task_setup_data = {\r\n.task = &data->task,\r\n.rpc_client = clnt,\r\n.rpc_message = &msg,\r\n.callback_ops = call_ops,\r\n.callback_data = data,\r\n.workqueue = nfsiod_workqueue,\r\n.flags = RPC_TASK_ASYNC | swap_flags,\r\n};\r\nNFS_PROTO(inode)->read_setup(data, &msg);\r\ndprintk("NFS: %5u initiated read call (req %s/%lld, %u bytes @ "\r\n"offset %llu)\n",\r\ndata->task.tk_pid,\r\ninode->i_sb->s_id,\r\n(long long)NFS_FILEID(inode),\r\ndata->args.count,\r\n(unsigned long long)data->args.offset);\r\ntask = rpc_run_task(&task_setup_data);\r\nif (IS_ERR(task))\r\nreturn PTR_ERR(task);\r\nrpc_put_task(task);\r\nreturn 0;\r\n}\r\nstatic void nfs_read_rpcsetup(struct nfs_page *req, struct nfs_read_data *data,\r\nunsigned int count, unsigned int offset)\r\n{\r\nstruct inode *inode = req->wb_context->dentry->d_inode;\r\ndata->req = req;\r\ndata->inode = inode;\r\ndata->cred = req->wb_context->cred;\r\ndata->args.fh = NFS_FH(inode);\r\ndata->args.offset = req_offset(req) + offset;\r\ndata->args.pgbase = req->wb_pgbase + offset;\r\ndata->args.pages = data->pagevec;\r\ndata->args.count = count;\r\ndata->args.context = get_nfs_open_context(req->wb_context);\r\ndata->args.lock_context = req->wb_lock_context;\r\ndata->res.fattr = &data->fattr;\r\ndata->res.count = count;\r\ndata->res.eof = 0;\r\nnfs_fattr_init(&data->fattr);\r\n}\r\nstatic int nfs_do_read(struct nfs_read_data *data,\r\nconst struct rpc_call_ops *call_ops)\r\n{\r\nstruct inode *inode = data->args.context->dentry->d_inode;\r\nreturn nfs_initiate_read(data, NFS_CLIENT(inode), call_ops);\r\n}\r\nstatic int\r\nnfs_do_multiple_reads(struct list_head *head,\r\nconst struct rpc_call_ops *call_ops)\r\n{\r\nstruct nfs_read_data *data;\r\nint ret = 0;\r\nwhile (!list_empty(head)) {\r\nint ret2;\r\ndata = list_entry(head->next, struct nfs_read_data, list);\r\nlist_del_init(&data->list);\r\nret2 = nfs_do_read(data, call_ops);\r\nif (ret == 0)\r\nret = ret2;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nnfs_async_read_error(struct list_head *head)\r\n{\r\nstruct nfs_page *req;\r\nwhile (!list_empty(head)) {\r\nreq = nfs_list_entry(head->next);\r\nnfs_list_remove_request(req);\r\nnfs_readpage_release(req);\r\n}\r\n}\r\nstatic int nfs_pagein_multi(struct nfs_pageio_descriptor *desc, struct list_head *res)\r\n{\r\nstruct nfs_page *req = nfs_list_entry(desc->pg_list.next);\r\nstruct page *page = req->wb_page;\r\nstruct nfs_read_data *data;\r\nsize_t rsize = desc->pg_bsize, nbytes;\r\nunsigned int offset;\r\nint requests = 0;\r\nint ret = 0;\r\nnfs_list_remove_request(req);\r\noffset = 0;\r\nnbytes = desc->pg_count;\r\ndo {\r\nsize_t len = min(nbytes,rsize);\r\ndata = nfs_readdata_alloc(1);\r\nif (!data)\r\ngoto out_bad;\r\ndata->pagevec[0] = page;\r\nnfs_read_rpcsetup(req, data, len, offset);\r\nlist_add(&data->list, res);\r\nrequests++;\r\nnbytes -= len;\r\noffset += len;\r\n} while(nbytes != 0);\r\natomic_set(&req->wb_complete, requests);\r\ndesc->pg_rpc_callops = &nfs_read_partial_ops;\r\nreturn ret;\r\nout_bad:\r\nwhile (!list_empty(res)) {\r\ndata = list_entry(res->next, struct nfs_read_data, list);\r\nlist_del(&data->list);\r\nnfs_readdata_free(data);\r\n}\r\nnfs_readpage_release(req);\r\nreturn -ENOMEM;\r\n}\r\nstatic int nfs_pagein_one(struct nfs_pageio_descriptor *desc, struct list_head *res)\r\n{\r\nstruct nfs_page *req;\r\nstruct page **pages;\r\nstruct nfs_read_data *data;\r\nstruct list_head *head = &desc->pg_list;\r\nint ret = 0;\r\ndata = nfs_readdata_alloc(nfs_page_array_len(desc->pg_base,\r\ndesc->pg_count));\r\nif (!data) {\r\nnfs_async_read_error(head);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\npages = data->pagevec;\r\nwhile (!list_empty(head)) {\r\nreq = nfs_list_entry(head->next);\r\nnfs_list_remove_request(req);\r\nnfs_list_add_request(req, &data->pages);\r\n*pages++ = req->wb_page;\r\n}\r\nreq = nfs_list_entry(data->pages.next);\r\nnfs_read_rpcsetup(req, data, desc->pg_count, 0);\r\nlist_add(&data->list, res);\r\ndesc->pg_rpc_callops = &nfs_read_full_ops;\r\nout:\r\nreturn ret;\r\n}\r\nint nfs_generic_pagein(struct nfs_pageio_descriptor *desc, struct list_head *head)\r\n{\r\nif (desc->pg_bsize < PAGE_CACHE_SIZE)\r\nreturn nfs_pagein_multi(desc, head);\r\nreturn nfs_pagein_one(desc, head);\r\n}\r\nstatic int nfs_generic_pg_readpages(struct nfs_pageio_descriptor *desc)\r\n{\r\nLIST_HEAD(head);\r\nint ret;\r\nret = nfs_generic_pagein(desc, &head);\r\nif (ret == 0)\r\nret = nfs_do_multiple_reads(&head, desc->pg_rpc_callops);\r\nreturn ret;\r\n}\r\nint nfs_readpage_result(struct rpc_task *task, struct nfs_read_data *data)\r\n{\r\nint status;\r\ndprintk("NFS: %s: %5u, (status %d)\n", __func__, task->tk_pid,\r\ntask->tk_status);\r\nstatus = NFS_PROTO(data->inode)->read_done(task, data);\r\nif (status != 0)\r\nreturn status;\r\nnfs_add_stats(data->inode, NFSIOS_SERVERREADBYTES, data->res.count);\r\nif (task->tk_status == -ESTALE) {\r\nset_bit(NFS_INO_STALE, &NFS_I(data->inode)->flags);\r\nnfs_mark_for_revalidate(data->inode);\r\n}\r\nreturn 0;\r\n}\r\nstatic void nfs_readpage_retry(struct rpc_task *task, struct nfs_read_data *data)\r\n{\r\nstruct nfs_readargs *argp = &data->args;\r\nstruct nfs_readres *resp = &data->res;\r\nif (resp->eof || resp->count == argp->count)\r\nreturn;\r\nnfs_inc_stats(data->inode, NFSIOS_SHORTREAD);\r\nif (resp->count == 0)\r\nreturn;\r\ndata->mds_offset += resp->count;\r\nargp->offset += resp->count;\r\nargp->pgbase += resp->count;\r\nargp->count -= resp->count;\r\nrpc_restart_call_prepare(task);\r\n}\r\nstatic void nfs_readpage_result_partial(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs_read_data *data = calldata;\r\nif (nfs_readpage_result(task, data) != 0)\r\nreturn;\r\nif (task->tk_status < 0)\r\nreturn;\r\nnfs_readpage_truncate_uninitialised_page(data);\r\nnfs_readpage_retry(task, data);\r\n}\r\nstatic void nfs_readpage_release_partial(void *calldata)\r\n{\r\nstruct nfs_read_data *data = calldata;\r\nstruct nfs_page *req = data->req;\r\nstruct page *page = req->wb_page;\r\nint status = data->task.tk_status;\r\nif (status < 0)\r\nset_bit(PG_PARTIAL_READ_FAILED, &req->wb_flags);\r\nif (atomic_dec_and_test(&req->wb_complete)) {\r\nif (!test_bit(PG_PARTIAL_READ_FAILED, &req->wb_flags))\r\nSetPageUptodate(page);\r\nnfs_readpage_release(req);\r\n}\r\nnfs_readdata_release(calldata);\r\n}\r\nvoid nfs_read_prepare(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs_read_data *data = calldata;\r\nif (nfs4_setup_sequence(NFS_SERVER(data->inode),\r\n&data->args.seq_args, &data->res.seq_res,\r\n0, task))\r\nreturn;\r\nrpc_call_start(task);\r\n}\r\nstatic void nfs_readpage_set_pages_uptodate(struct nfs_read_data *data)\r\n{\r\nunsigned int count = data->res.count;\r\nunsigned int base = data->args.pgbase;\r\nstruct page **pages;\r\nif (data->res.eof)\r\ncount = data->args.count;\r\nif (unlikely(count == 0))\r\nreturn;\r\npages = &data->args.pages[base >> PAGE_CACHE_SHIFT];\r\nbase &= ~PAGE_CACHE_MASK;\r\ncount += base;\r\nfor (;count >= PAGE_CACHE_SIZE; count -= PAGE_CACHE_SIZE, pages++)\r\nSetPageUptodate(*pages);\r\nif (count == 0)\r\nreturn;\r\nif (data->res.eof || data->res.count == data->args.count)\r\nSetPageUptodate(*pages);\r\n}\r\nstatic void nfs_readpage_result_full(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs_read_data *data = calldata;\r\nif (nfs_readpage_result(task, data) != 0)\r\nreturn;\r\nif (task->tk_status < 0)\r\nreturn;\r\nnfs_readpage_truncate_uninitialised_page(data);\r\nnfs_readpage_set_pages_uptodate(data);\r\nnfs_readpage_retry(task, data);\r\n}\r\nstatic void nfs_readpage_release_full(void *calldata)\r\n{\r\nstruct nfs_read_data *data = calldata;\r\nwhile (!list_empty(&data->pages)) {\r\nstruct nfs_page *req = nfs_list_entry(data->pages.next);\r\nnfs_list_remove_request(req);\r\nnfs_readpage_release(req);\r\n}\r\nnfs_readdata_release(calldata);\r\n}\r\nint nfs_readpage(struct file *file, struct page *page)\r\n{\r\nstruct nfs_open_context *ctx;\r\nstruct inode *inode = page->mapping->host;\r\nint error;\r\ndprintk("NFS: nfs_readpage (%p %ld@%lu)\n",\r\npage, PAGE_CACHE_SIZE, page->index);\r\nnfs_inc_stats(inode, NFSIOS_VFSREADPAGE);\r\nnfs_add_stats(inode, NFSIOS_READPAGES, 1);\r\nerror = nfs_wb_page(inode, page);\r\nif (error)\r\ngoto out_unlock;\r\nif (PageUptodate(page))\r\ngoto out_unlock;\r\nerror = -ESTALE;\r\nif (NFS_STALE(inode))\r\ngoto out_unlock;\r\nif (file == NULL) {\r\nerror = -EBADF;\r\nctx = nfs_find_open_context(inode, NULL, FMODE_READ);\r\nif (ctx == NULL)\r\ngoto out_unlock;\r\n} else\r\nctx = get_nfs_open_context(nfs_file_open_context(file));\r\nif (!IS_SYNC(inode)) {\r\nerror = nfs_readpage_from_fscache(ctx, inode, page);\r\nif (error == 0)\r\ngoto out;\r\n}\r\nerror = nfs_readpage_async(ctx, inode, page);\r\nout:\r\nput_nfs_open_context(ctx);\r\nreturn error;\r\nout_unlock:\r\nunlock_page(page);\r\nreturn error;\r\n}\r\nstatic int\r\nreadpage_async_filler(void *data, struct page *page)\r\n{\r\nstruct nfs_readdesc *desc = (struct nfs_readdesc *)data;\r\nstruct inode *inode = page->mapping->host;\r\nstruct nfs_page *new;\r\nunsigned int len;\r\nint error;\r\nlen = nfs_page_length(page);\r\nif (len == 0)\r\nreturn nfs_return_empty_page(page);\r\nnew = nfs_create_request(desc->ctx, inode, page, 0, len);\r\nif (IS_ERR(new))\r\ngoto out_error;\r\nif (len < PAGE_CACHE_SIZE)\r\nzero_user_segment(page, len, PAGE_CACHE_SIZE);\r\nif (!nfs_pageio_add_request(desc->pgio, new)) {\r\nerror = desc->pgio->pg_error;\r\ngoto out_unlock;\r\n}\r\nreturn 0;\r\nout_error:\r\nerror = PTR_ERR(new);\r\nout_unlock:\r\nunlock_page(page);\r\nreturn error;\r\n}\r\nint nfs_readpages(struct file *filp, struct address_space *mapping,\r\nstruct list_head *pages, unsigned nr_pages)\r\n{\r\nstruct nfs_pageio_descriptor pgio;\r\nstruct nfs_readdesc desc = {\r\n.pgio = &pgio,\r\n};\r\nstruct inode *inode = mapping->host;\r\nunsigned long npages;\r\nint ret = -ESTALE;\r\ndprintk("NFS: nfs_readpages (%s/%Ld %d)\n",\r\ninode->i_sb->s_id,\r\n(long long)NFS_FILEID(inode),\r\nnr_pages);\r\nnfs_inc_stats(inode, NFSIOS_VFSREADPAGES);\r\nif (NFS_STALE(inode))\r\ngoto out;\r\nif (filp == NULL) {\r\ndesc.ctx = nfs_find_open_context(inode, NULL, FMODE_READ);\r\nif (desc.ctx == NULL)\r\nreturn -EBADF;\r\n} else\r\ndesc.ctx = get_nfs_open_context(nfs_file_open_context(filp));\r\nret = nfs_readpages_from_fscache(desc.ctx, inode, mapping,\r\npages, &nr_pages);\r\nif (ret == 0)\r\ngoto read_complete;\r\nnfs_pageio_init_read(&pgio, inode);\r\nret = read_cache_pages(mapping, pages, readpage_async_filler, &desc);\r\nnfs_pageio_complete(&pgio);\r\nnpages = (pgio.pg_bytes_written + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\r\nnfs_add_stats(inode, NFSIOS_READPAGES, npages);\r\nread_complete:\r\nput_nfs_open_context(desc.ctx);\r\nout:\r\nreturn ret;\r\n}\r\nint __init nfs_init_readpagecache(void)\r\n{\r\nnfs_rdata_cachep = kmem_cache_create("nfs_read_data",\r\nsizeof(struct nfs_read_data),\r\n0, SLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (nfs_rdata_cachep == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid nfs_destroy_readpagecache(void)\r\n{\r\nkmem_cache_destroy(nfs_rdata_cachep);\r\n}
