static void broadsheet_gpio_issue_data(struct broadsheetfb_par *par, u16 data)\r\n{\r\npar->board->set_ctl(par, BS_WR, 0);\r\npar->board->set_hdb(par, data);\r\npar->board->set_ctl(par, BS_WR, 1);\r\n}\r\nstatic void broadsheet_gpio_issue_cmd(struct broadsheetfb_par *par, u16 data)\r\n{\r\npar->board->set_ctl(par, BS_DC, 0);\r\nbroadsheet_gpio_issue_data(par, data);\r\n}\r\nstatic void broadsheet_gpio_send_command(struct broadsheetfb_par *par, u16 data)\r\n{\r\npar->board->wait_for_rdy(par);\r\npar->board->set_ctl(par, BS_CS, 0);\r\nbroadsheet_gpio_issue_cmd(par, data);\r\npar->board->set_ctl(par, BS_DC, 1);\r\npar->board->set_ctl(par, BS_CS, 1);\r\n}\r\nstatic void broadsheet_gpio_send_cmdargs(struct broadsheetfb_par *par, u16 cmd,\r\nint argc, u16 *argv)\r\n{\r\nint i;\r\npar->board->wait_for_rdy(par);\r\npar->board->set_ctl(par, BS_CS, 0);\r\nbroadsheet_gpio_issue_cmd(par, cmd);\r\npar->board->set_ctl(par, BS_DC, 1);\r\nfor (i = 0; i < argc; i++)\r\nbroadsheet_gpio_issue_data(par, argv[i]);\r\npar->board->set_ctl(par, BS_CS, 1);\r\n}\r\nstatic void broadsheet_mmio_send_cmdargs(struct broadsheetfb_par *par, u16 cmd,\r\nint argc, u16 *argv)\r\n{\r\nint i;\r\npar->board->mmio_write(par, BS_MMIO_CMD, cmd);\r\nfor (i = 0; i < argc; i++)\r\npar->board->mmio_write(par, BS_MMIO_DATA, argv[i]);\r\n}\r\nstatic void broadsheet_send_command(struct broadsheetfb_par *par, u16 data)\r\n{\r\nif (par->board->mmio_write)\r\npar->board->mmio_write(par, BS_MMIO_CMD, data);\r\nelse\r\nbroadsheet_gpio_send_command(par, data);\r\n}\r\nstatic void broadsheet_send_cmdargs(struct broadsheetfb_par *par, u16 cmd,\r\nint argc, u16 *argv)\r\n{\r\nif (par->board->mmio_write)\r\nbroadsheet_mmio_send_cmdargs(par, cmd, argc, argv);\r\nelse\r\nbroadsheet_gpio_send_cmdargs(par, cmd, argc, argv);\r\n}\r\nstatic void broadsheet_gpio_burst_write(struct broadsheetfb_par *par, int size,\r\nu16 *data)\r\n{\r\nint i;\r\nu16 tmp;\r\npar->board->set_ctl(par, BS_CS, 0);\r\npar->board->set_ctl(par, BS_DC, 1);\r\nfor (i = 0; i < size; i++) {\r\npar->board->set_ctl(par, BS_WR, 0);\r\ntmp = (data[i] & 0x0F) << 4;\r\ntmp |= (data[i] & 0x0F00) << 4;\r\npar->board->set_hdb(par, tmp);\r\npar->board->set_ctl(par, BS_WR, 1);\r\n}\r\npar->board->set_ctl(par, BS_CS, 1);\r\n}\r\nstatic void broadsheet_mmio_burst_write(struct broadsheetfb_par *par, int size,\r\nu16 *data)\r\n{\r\nint i;\r\nu16 tmp;\r\nfor (i = 0; i < size; i++) {\r\ntmp = (data[i] & 0x0F) << 4;\r\ntmp |= (data[i] & 0x0F00) << 4;\r\npar->board->mmio_write(par, BS_MMIO_DATA, tmp);\r\n}\r\n}\r\nstatic void broadsheet_burst_write(struct broadsheetfb_par *par, int size,\r\nu16 *data)\r\n{\r\nif (par->board->mmio_write)\r\nbroadsheet_mmio_burst_write(par, size, data);\r\nelse\r\nbroadsheet_gpio_burst_write(par, size, data);\r\n}\r\nstatic u16 broadsheet_gpio_get_data(struct broadsheetfb_par *par)\r\n{\r\nu16 res;\r\npar->board->wait_for_rdy(par);\r\npar->board->set_ctl(par, BS_DC, 1);\r\npar->board->set_ctl(par, BS_CS, 0);\r\npar->board->set_ctl(par, BS_WR, 0);\r\nres = par->board->get_hdb(par);\r\npar->board->set_ctl(par, BS_WR, 1);\r\npar->board->set_ctl(par, BS_CS, 1);\r\nreturn res;\r\n}\r\nstatic u16 broadsheet_get_data(struct broadsheetfb_par *par)\r\n{\r\nif (par->board->mmio_read)\r\nreturn par->board->mmio_read(par);\r\nelse\r\nreturn broadsheet_gpio_get_data(par);\r\n}\r\nstatic void broadsheet_gpio_write_reg(struct broadsheetfb_par *par, u16 reg,\r\nu16 data)\r\n{\r\npar->board->wait_for_rdy(par);\r\npar->board->set_ctl(par, BS_CS, 0);\r\nbroadsheet_gpio_issue_cmd(par, BS_CMD_WR_REG);\r\npar->board->set_ctl(par, BS_DC, 1);\r\nbroadsheet_gpio_issue_data(par, reg);\r\nbroadsheet_gpio_issue_data(par, data);\r\npar->board->set_ctl(par, BS_CS, 1);\r\n}\r\nstatic void broadsheet_mmio_write_reg(struct broadsheetfb_par *par, u16 reg,\r\nu16 data)\r\n{\r\npar->board->mmio_write(par, BS_MMIO_CMD, BS_CMD_WR_REG);\r\npar->board->mmio_write(par, BS_MMIO_DATA, reg);\r\npar->board->mmio_write(par, BS_MMIO_DATA, data);\r\n}\r\nstatic void broadsheet_write_reg(struct broadsheetfb_par *par, u16 reg,\r\nu16 data)\r\n{\r\nif (par->board->mmio_write)\r\nbroadsheet_mmio_write_reg(par, reg, data);\r\nelse\r\nbroadsheet_gpio_write_reg(par, reg, data);\r\n}\r\nstatic void broadsheet_write_reg32(struct broadsheetfb_par *par, u16 reg,\r\nu32 data)\r\n{\r\nbroadsheet_write_reg(par, reg, cpu_to_le32(data) & 0xFFFF);\r\nbroadsheet_write_reg(par, reg + 2, (cpu_to_le32(data) >> 16) & 0xFFFF);\r\n}\r\nstatic u16 broadsheet_read_reg(struct broadsheetfb_par *par, u16 reg)\r\n{\r\nbroadsheet_send_cmdargs(par, BS_CMD_RD_REG, 1, &reg);\r\npar->board->wait_for_rdy(par);\r\nreturn broadsheet_get_data(par);\r\n}\r\nstatic int is_broadsheet_pll_locked(struct broadsheetfb_par *par)\r\n{\r\nreturn broadsheet_read_reg(par, 0x000A) & 0x0001;\r\n}\r\nstatic int broadsheet_setup_plls(struct broadsheetfb_par *par)\r\n{\r\nint retry_count = 0;\r\nu16 tmp;\r\nbroadsheet_write_reg(par, 0x0006, 0x0000);\r\nbroadsheet_write_reg(par, 0x0010, 0x0004);\r\nbroadsheet_write_reg(par, 0x0012, 0x5949);\r\nbroadsheet_write_reg(par, 0x0014, 0x0040);\r\nbroadsheet_write_reg(par, 0x0016, 0x0000);\r\ndo {\r\nif (retry_count++ > 100)\r\nreturn -ETIMEDOUT;\r\nmdelay(1);\r\n} while (!is_broadsheet_pll_locked(par));\r\ntmp = broadsheet_read_reg(par, 0x0006);\r\ntmp &= ~0x1;\r\nbroadsheet_write_reg(par, 0x0006, tmp);\r\nreturn 0;\r\n}\r\nstatic int broadsheet_setup_spi(struct broadsheetfb_par *par)\r\n{\r\nbroadsheet_write_reg(par, 0x0204, ((3 << 3) | 1));\r\nbroadsheet_write_reg(par, 0x0208, 0x0001);\r\nreturn 0;\r\n}\r\nstatic int broadsheet_setup_spiflash(struct broadsheetfb_par *par,\r\nu16 *orig_sfmcd)\r\n{\r\n*orig_sfmcd = broadsheet_read_reg(par, 0x0204);\r\nbroadsheet_write_reg(par, 0x0208, 0);\r\nbroadsheet_write_reg(par, 0x0204, 0);\r\nbroadsheet_write_reg(par, 0x0204, ((3 << 3) | 1));\r\nreturn 0;\r\n}\r\nstatic int broadsheet_spiflash_wait_for_bit(struct broadsheetfb_par *par,\r\nu16 reg, int bitnum, int val,\r\nint timeout)\r\n{\r\nu16 tmp;\r\ndo {\r\ntmp = broadsheet_read_reg(par, reg);\r\nif (((tmp >> bitnum) & 1) == val)\r\nreturn 0;\r\nmdelay(1);\r\n} while (timeout--);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int broadsheet_spiflash_write_byte(struct broadsheetfb_par *par, u8 data)\r\n{\r\nbroadsheet_write_reg(par, 0x0202, (data | 0x100));\r\nreturn broadsheet_spiflash_wait_for_bit(par, 0x0206, 3, 0, 100);\r\n}\r\nstatic int broadsheet_spiflash_read_byte(struct broadsheetfb_par *par, u8 *data)\r\n{\r\nint err;\r\nu16 tmp;\r\nbroadsheet_write_reg(par, 0x0202, 0);\r\nerr = broadsheet_spiflash_wait_for_bit(par, 0x0206, 3, 0, 100);\r\nif (err)\r\nreturn err;\r\ntmp = broadsheet_read_reg(par, 0x200);\r\n*data = tmp & 0xFF;\r\nreturn 0;\r\n}\r\nstatic int broadsheet_spiflash_wait_for_status(struct broadsheetfb_par *par,\r\nint timeout)\r\n{\r\nu8 tmp;\r\nint err;\r\ndo {\r\nbroadsheet_write_reg(par, 0x0208, 1);\r\nerr = broadsheet_spiflash_write_byte(par, 0x05);\r\nif (err)\r\ngoto failout;\r\nerr = broadsheet_spiflash_read_byte(par, &tmp);\r\nif (err)\r\ngoto failout;\r\nbroadsheet_write_reg(par, 0x0208, 0);\r\nif (!(tmp & 0x1))\r\nreturn 0;\r\nmdelay(5);\r\n} while (timeout--);\r\ndev_err(par->info->device, "Timed out waiting for spiflash status\n");\r\nreturn -ETIMEDOUT;\r\nfailout:\r\nbroadsheet_write_reg(par, 0x0208, 0);\r\nreturn err;\r\n}\r\nstatic int broadsheet_spiflash_op_on_address(struct broadsheetfb_par *par,\r\nu8 op, u32 addr)\r\n{\r\nint i;\r\nu8 tmp;\r\nint err;\r\nbroadsheet_write_reg(par, 0x0208, 1);\r\nerr = broadsheet_spiflash_write_byte(par, op);\r\nif (err)\r\nreturn err;\r\nfor (i = 2; i >= 0; i--) {\r\ntmp = ((addr >> (i * 8)) & 0xFF);\r\nerr = broadsheet_spiflash_write_byte(par, tmp);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic int broadsheet_verify_spiflash(struct broadsheetfb_par *par,\r\nint *flash_type)\r\n{\r\nint err = 0;\r\nu8 sig;\r\nerr = broadsheet_spiflash_op_on_address(par, 0xAB, 0x00000000);\r\nif (err)\r\ngoto failout;\r\nerr = broadsheet_spiflash_read_byte(par, &sig);\r\nif (err)\r\ngoto failout;\r\nif ((sig != 0x10) && (sig != 0x11)) {\r\ndev_err(par->info->device, "Unexpected flash type\n");\r\nerr = -EINVAL;\r\ngoto failout;\r\n}\r\n*flash_type = sig;\r\nfailout:\r\nbroadsheet_write_reg(par, 0x0208, 0);\r\nreturn err;\r\n}\r\nstatic int broadsheet_setup_for_wfm_write(struct broadsheetfb_par *par,\r\nu16 *initial_sfmcd, int *flash_type)\r\n{\r\nint err;\r\nerr = broadsheet_setup_plls(par);\r\nif (err)\r\nreturn err;\r\nbroadsheet_write_reg(par, 0x0106, 0x0203);\r\nerr = broadsheet_setup_spi(par);\r\nif (err)\r\nreturn err;\r\nerr = broadsheet_setup_spiflash(par, initial_sfmcd);\r\nif (err)\r\nreturn err;\r\nreturn broadsheet_verify_spiflash(par, flash_type);\r\n}\r\nstatic int broadsheet_spiflash_write_control(struct broadsheetfb_par *par,\r\nint mode)\r\n{\r\nint err;\r\nbroadsheet_write_reg(par, 0x0208, 1);\r\nif (mode)\r\nerr = broadsheet_spiflash_write_byte(par, 0x06);\r\nelse\r\nerr = broadsheet_spiflash_write_byte(par, 0x04);\r\nbroadsheet_write_reg(par, 0x0208, 0);\r\nreturn err;\r\n}\r\nstatic int broadsheet_spiflash_erase_sector(struct broadsheetfb_par *par,\r\nint addr)\r\n{\r\nint err;\r\nbroadsheet_spiflash_write_control(par, 1);\r\nerr = broadsheet_spiflash_op_on_address(par, 0xD8, addr);\r\nbroadsheet_write_reg(par, 0x0208, 0);\r\nif (err)\r\nreturn err;\r\nerr = broadsheet_spiflash_wait_for_status(par, 1000);\r\nreturn err;\r\n}\r\nstatic int broadsheet_spiflash_read_range(struct broadsheetfb_par *par,\r\nint addr, int size, char *data)\r\n{\r\nint err;\r\nint i;\r\nerr = broadsheet_spiflash_op_on_address(par, 0x03, addr);\r\nif (err)\r\ngoto failout;\r\nfor (i = 0; i < size; i++) {\r\nerr = broadsheet_spiflash_read_byte(par, &data[i]);\r\nif (err)\r\ngoto failout;\r\n}\r\nfailout:\r\nbroadsheet_write_reg(par, 0x0208, 0);\r\nreturn err;\r\n}\r\nstatic int broadsheet_spiflash_write_page(struct broadsheetfb_par *par,\r\nint addr, const char *data)\r\n{\r\nint err;\r\nint i;\r\nbroadsheet_spiflash_write_control(par, 1);\r\nerr = broadsheet_spiflash_op_on_address(par, 0x02, addr);\r\nif (err)\r\ngoto failout;\r\nfor (i = 0; i < BS_SPIFLASH_PAGE_SIZE; i++) {\r\nerr = broadsheet_spiflash_write_byte(par, data[i]);\r\nif (err)\r\ngoto failout;\r\n}\r\nbroadsheet_write_reg(par, 0x0208, 0);\r\nerr = broadsheet_spiflash_wait_for_status(par, 100);\r\nfailout:\r\nreturn err;\r\n}\r\nstatic int broadsheet_spiflash_write_sector(struct broadsheetfb_par *par,\r\nint addr, const char *data, int sector_size)\r\n{\r\nint i;\r\nint err;\r\nfor (i = 0; i < sector_size; i += BS_SPIFLASH_PAGE_SIZE) {\r\nerr = broadsheet_spiflash_write_page(par, addr + i, &data[i]);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int broadsheet_spiflash_rewrite_sector(struct broadsheetfb_par *par,\r\nint sector_size, int data_start_addr,\r\nint data_len, const char *data)\r\n{\r\nint err;\r\nchar *sector_buffer;\r\nint tail_start_addr;\r\nint start_sector_addr;\r\nsector_buffer = kzalloc(sizeof(char)*sector_size, GFP_KERNEL);\r\nif (!sector_buffer)\r\nreturn -ENOMEM;\r\nstart_sector_addr = (data_start_addr / sector_size) * sector_size;\r\nif (data_start_addr != start_sector_addr) {\r\nerr = broadsheet_spiflash_read_range(par, start_sector_addr,\r\ndata_start_addr, sector_buffer);\r\nif (err)\r\nreturn err;\r\n}\r\nmemcpy(sector_buffer + data_start_addr, data, data_len);\r\ntail_start_addr = (data_start_addr + data_len) % sector_size;\r\nif (tail_start_addr) {\r\nint tail_len;\r\ntail_len = sector_size - tail_start_addr;\r\nerr = broadsheet_spiflash_read_range(par, tail_start_addr,\r\ntail_len, sector_buffer + tail_start_addr);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = broadsheet_spiflash_erase_sector(par, start_sector_addr);\r\nif (err)\r\nreturn err;\r\nerr = broadsheet_spiflash_write_sector(par, start_sector_addr,\r\nsector_buffer, sector_size);\r\nreturn err;\r\n}\r\nstatic int broadsheet_write_spiflash(struct broadsheetfb_par *par, u32 wfm_addr,\r\nconst u8 *wfm, int bytecount, int flash_type)\r\n{\r\nint sector_size;\r\nint err;\r\nint cur_addr;\r\nint writecount;\r\nint maxlen;\r\nint offset = 0;\r\nswitch (flash_type) {\r\ncase 0x10:\r\nsector_size = 32*1024;\r\nbreak;\r\ncase 0x11:\r\ndefault:\r\nsector_size = 64*1024;\r\nbreak;\r\n}\r\nwhile (bytecount) {\r\ncur_addr = wfm_addr + offset;\r\nmaxlen = roundup(cur_addr, sector_size) - cur_addr;\r\nwritecount = min(bytecount, maxlen);\r\nerr = broadsheet_spiflash_rewrite_sector(par, sector_size,\r\ncur_addr, writecount, wfm + offset);\r\nif (err)\r\nreturn err;\r\noffset += writecount;\r\nbytecount -= writecount;\r\n}\r\nreturn 0;\r\n}\r\nstatic int broadsheet_store_waveform_to_spiflash(struct broadsheetfb_par *par,\r\nconst u8 *wfm, size_t wfm_size)\r\n{\r\nint err = 0;\r\nu16 initial_sfmcd = 0;\r\nint flash_type = 0;\r\nerr = broadsheet_setup_for_wfm_write(par, &initial_sfmcd, &flash_type);\r\nif (err)\r\ngoto failout;\r\nerr = broadsheet_write_spiflash(par, 0x886, wfm, wfm_size, flash_type);\r\nfailout:\r\nbroadsheet_write_reg(par, 0x0204, initial_sfmcd);\r\nreturn err;\r\n}\r\nstatic ssize_t broadsheet_loadstore_waveform(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nint err;\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct broadsheetfb_par *par = info->par;\r\nconst struct firmware *fw_entry;\r\nif (len < 1)\r\nreturn -EINVAL;\r\nerr = request_firmware(&fw_entry, "broadsheet.wbf", dev);\r\nif (err < 0) {\r\ndev_err(dev, "Failed to get broadsheet waveform\n");\r\ngoto err_failed;\r\n}\r\nif ((fw_entry->size < 8*1024) || (fw_entry->size > 64*1024)) {\r\ndev_err(dev, "Invalid waveform\n");\r\nerr = -EINVAL;\r\ngoto err_failed;\r\n}\r\nmutex_lock(&(par->io_lock));\r\nerr = broadsheet_store_waveform_to_spiflash(par, fw_entry->data,\r\nfw_entry->size);\r\nmutex_unlock(&(par->io_lock));\r\nif (err < 0) {\r\ndev_err(dev, "Failed to store broadsheet waveform\n");\r\ngoto err_failed;\r\n}\r\ndev_info(dev, "Stored broadsheet waveform, size %zd\n", fw_entry->size);\r\nreturn len;\r\nerr_failed:\r\nreturn err;\r\n}\r\nstatic void __devinit broadsheet_init_display(struct broadsheetfb_par *par)\r\n{\r\nu16 args[5];\r\nint xres = par->info->var.xres;\r\nint yres = par->info->var.yres;\r\nargs[0] = panel_table[par->panel_index].w;\r\nargs[1] = panel_table[par->panel_index].h;\r\nargs[2] = panel_table[par->panel_index].sdcfg;\r\nargs[3] = panel_table[par->panel_index].gdcfg;\r\nargs[4] = panel_table[par->panel_index].lutfmt;\r\nbroadsheet_send_cmdargs(par, BS_CMD_INIT_DSPE_CFG, 5, args);\r\nbroadsheet_send_cmdargs(par, BS_CMD_INIT_DSPE_CFG, 5, args);\r\nargs[0] = panel_table[par->panel_index].fsynclen;\r\nargs[1] = panel_table[par->panel_index].fendfbegin;\r\nargs[2] = panel_table[par->panel_index].lsynclen;\r\nargs[3] = panel_table[par->panel_index].lendlbegin;\r\nargs[4] = panel_table[par->panel_index].pixclk;\r\nbroadsheet_send_cmdargs(par, BS_CMD_INIT_DSPE_TMG, 5, args);\r\nbroadsheet_write_reg32(par, 0x310, xres*yres*2);\r\nargs[0] = 0x886;\r\nargs[1] = 0;\r\nbroadsheet_send_cmdargs(par, BS_CMD_RD_WFM_INFO, 2, args);\r\nbroadsheet_send_command(par, BS_CMD_UPD_GDRV_CLR);\r\nbroadsheet_send_command(par, BS_CMD_WAIT_DSPE_TRG);\r\nbroadsheet_write_reg(par, 0x330, 0x84);\r\nbroadsheet_send_command(par, BS_CMD_WAIT_DSPE_TRG);\r\nargs[0] = (0x3 << 4);\r\nbroadsheet_send_cmdargs(par, BS_CMD_LD_IMG, 1, args);\r\nargs[0] = 0x154;\r\nbroadsheet_send_cmdargs(par, BS_CMD_WR_REG, 1, args);\r\nbroadsheet_burst_write(par, (panel_table[par->panel_index].w *\r\npanel_table[par->panel_index].h)/2,\r\n(u16 *) par->info->screen_base);\r\nbroadsheet_send_command(par, BS_CMD_LD_IMG_END);\r\nargs[0] = 0x4300;\r\nbroadsheet_send_cmdargs(par, BS_CMD_UPD_FULL, 1, args);\r\nbroadsheet_send_command(par, BS_CMD_WAIT_DSPE_TRG);\r\nbroadsheet_send_command(par, BS_CMD_WAIT_DSPE_FREND);\r\npar->board->wait_for_rdy(par);\r\n}\r\nstatic void __devinit broadsheet_identify(struct broadsheetfb_par *par)\r\n{\r\nu16 rev, prc;\r\nstruct device *dev = par->info->device;\r\nrev = broadsheet_read_reg(par, BS_REG_REV);\r\nprc = broadsheet_read_reg(par, BS_REG_PRC);\r\ndev_info(dev, "Broadsheet Rev 0x%x, Product Code 0x%x\n", rev, prc);\r\nif (prc != 0x0047)\r\ndev_warn(dev, "Unrecognized Broadsheet Product Code\n");\r\nif (rev != 0x0100)\r\ndev_warn(dev, "Unrecognized Broadsheet Revision\n");\r\n}\r\nstatic void __devinit broadsheet_init(struct broadsheetfb_par *par)\r\n{\r\nbroadsheet_send_command(par, BS_CMD_INIT_SYS_RUN);\r\nmsleep(1000);\r\nbroadsheet_init_display(par);\r\n}\r\nstatic void broadsheetfb_dpy_update_pages(struct broadsheetfb_par *par,\r\nu16 y1, u16 y2)\r\n{\r\nu16 args[5];\r\nunsigned char *buf = (unsigned char *)par->info->screen_base;\r\nmutex_lock(&(par->io_lock));\r\ny1 &= 0xFFFC;\r\ny2 |= 0x0003;\r\nargs[0] = 0x3 << 4;\r\nargs[1] = 0;\r\nargs[2] = y1;\r\nargs[3] = cpu_to_le16(par->info->var.xres);\r\nargs[4] = y2;\r\nbroadsheet_send_cmdargs(par, BS_CMD_LD_IMG_AREA, 5, args);\r\nargs[0] = 0x154;\r\nbroadsheet_send_cmdargs(par, BS_CMD_WR_REG, 1, args);\r\nbuf += y1 * par->info->var.xres;\r\nbroadsheet_burst_write(par, ((1 + y2 - y1) * par->info->var.xres)/2,\r\n(u16 *) buf);\r\nbroadsheet_send_command(par, BS_CMD_LD_IMG_END);\r\nargs[0] = 0x4300;\r\nbroadsheet_send_cmdargs(par, BS_CMD_UPD_FULL, 1, args);\r\nbroadsheet_send_command(par, BS_CMD_WAIT_DSPE_TRG);\r\nbroadsheet_send_command(par, BS_CMD_WAIT_DSPE_FREND);\r\npar->board->wait_for_rdy(par);\r\nmutex_unlock(&(par->io_lock));\r\n}\r\nstatic void broadsheetfb_dpy_update(struct broadsheetfb_par *par)\r\n{\r\nu16 args[5];\r\nmutex_lock(&(par->io_lock));\r\nargs[0] = 0x3 << 4;\r\nbroadsheet_send_cmdargs(par, BS_CMD_LD_IMG, 1, args);\r\nargs[0] = 0x154;\r\nbroadsheet_send_cmdargs(par, BS_CMD_WR_REG, 1, args);\r\nbroadsheet_burst_write(par, (panel_table[par->panel_index].w *\r\npanel_table[par->panel_index].h)/2,\r\n(u16 *) par->info->screen_base);\r\nbroadsheet_send_command(par, BS_CMD_LD_IMG_END);\r\nargs[0] = 0x4300;\r\nbroadsheet_send_cmdargs(par, BS_CMD_UPD_FULL, 1, args);\r\nbroadsheet_send_command(par, BS_CMD_WAIT_DSPE_TRG);\r\nbroadsheet_send_command(par, BS_CMD_WAIT_DSPE_FREND);\r\npar->board->wait_for_rdy(par);\r\nmutex_unlock(&(par->io_lock));\r\n}\r\nstatic void broadsheetfb_dpy_deferred_io(struct fb_info *info,\r\nstruct list_head *pagelist)\r\n{\r\nu16 y1 = 0, h = 0;\r\nint prev_index = -1;\r\nstruct page *cur;\r\nstruct fb_deferred_io *fbdefio = info->fbdefio;\r\nint h_inc;\r\nu16 yres = info->var.yres;\r\nu16 xres = info->var.xres;\r\nh_inc = DIV_ROUND_UP(PAGE_SIZE , xres);\r\nlist_for_each_entry(cur, &fbdefio->pagelist, lru) {\r\nif (prev_index < 0) {\r\ny1 = (cur->index << PAGE_SHIFT) / xres;\r\nh = h_inc;\r\n} else if ((prev_index + 1) == cur->index) {\r\nh += h_inc;\r\n} else {\r\nbroadsheetfb_dpy_update_pages(info->par, y1, y1 + h);\r\ny1 = (cur->index << PAGE_SHIFT) / xres;\r\nh = h_inc;\r\n}\r\nprev_index = cur->index;\r\n}\r\nif (h >= yres) {\r\nbroadsheetfb_dpy_update(info->par);\r\n} else {\r\nbroadsheetfb_dpy_update_pages(info->par, y1,\r\nmin((u16) (y1 + h), yres));\r\n}\r\n}\r\nstatic void broadsheetfb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nstruct broadsheetfb_par *par = info->par;\r\nsys_fillrect(info, rect);\r\nbroadsheetfb_dpy_update(par);\r\n}\r\nstatic void broadsheetfb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct broadsheetfb_par *par = info->par;\r\nsys_copyarea(info, area);\r\nbroadsheetfb_dpy_update(par);\r\n}\r\nstatic void broadsheetfb_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nstruct broadsheetfb_par *par = info->par;\r\nsys_imageblit(info, image);\r\nbroadsheetfb_dpy_update(par);\r\n}\r\nstatic ssize_t broadsheetfb_write(struct fb_info *info, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct broadsheetfb_par *par = info->par;\r\nunsigned long p = *ppos;\r\nvoid *dst;\r\nint err = 0;\r\nunsigned long total_size;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn -EPERM;\r\ntotal_size = info->fix.smem_len;\r\nif (p > total_size)\r\nreturn -EFBIG;\r\nif (count > total_size) {\r\nerr = -EFBIG;\r\ncount = total_size;\r\n}\r\nif (count + p > total_size) {\r\nif (!err)\r\nerr = -ENOSPC;\r\ncount = total_size - p;\r\n}\r\ndst = (void *)(info->screen_base + p);\r\nif (copy_from_user(dst, buf, count))\r\nerr = -EFAULT;\r\nif (!err)\r\n*ppos += count;\r\nbroadsheetfb_dpy_update(par);\r\nreturn (err) ? err : count;\r\n}\r\nstatic int __devinit broadsheetfb_probe(struct platform_device *dev)\r\n{\r\nstruct fb_info *info;\r\nstruct broadsheet_board *board;\r\nint retval = -ENOMEM;\r\nint videomemorysize;\r\nunsigned char *videomemory;\r\nstruct broadsheetfb_par *par;\r\nint i;\r\nint dpyw, dpyh;\r\nint panel_index;\r\nboard = dev->dev.platform_data;\r\nif (!board)\r\nreturn -EINVAL;\r\nif (!try_module_get(board->owner))\r\nreturn -ENODEV;\r\ninfo = framebuffer_alloc(sizeof(struct broadsheetfb_par), &dev->dev);\r\nif (!info)\r\ngoto err;\r\nswitch (board->get_panel_type()) {\r\ncase 37:\r\npanel_index = 1;\r\nbreak;\r\ncase 97:\r\npanel_index = 2;\r\nbreak;\r\ncase 6:\r\ndefault:\r\npanel_index = 0;\r\nbreak;\r\n}\r\ndpyw = panel_table[panel_index].w;\r\ndpyh = panel_table[panel_index].h;\r\nvideomemorysize = roundup((dpyw*dpyh), PAGE_SIZE);\r\nvideomemory = vzalloc(videomemorysize);\r\nif (!videomemory)\r\ngoto err_fb_rel;\r\ninfo->screen_base = (char *)videomemory;\r\ninfo->fbops = &broadsheetfb_ops;\r\nbroadsheetfb_var.xres = dpyw;\r\nbroadsheetfb_var.yres = dpyh;\r\nbroadsheetfb_var.xres_virtual = dpyw;\r\nbroadsheetfb_var.yres_virtual = dpyh;\r\ninfo->var = broadsheetfb_var;\r\nbroadsheetfb_fix.line_length = dpyw;\r\ninfo->fix = broadsheetfb_fix;\r\ninfo->fix.smem_len = videomemorysize;\r\npar = info->par;\r\npar->panel_index = panel_index;\r\npar->info = info;\r\npar->board = board;\r\npar->write_reg = broadsheet_write_reg;\r\npar->read_reg = broadsheet_read_reg;\r\ninit_waitqueue_head(&par->waitq);\r\nmutex_init(&par->io_lock);\r\ninfo->flags = FBINFO_FLAG_DEFAULT | FBINFO_VIRTFB;\r\ninfo->fbdefio = &broadsheetfb_defio;\r\nfb_deferred_io_init(info);\r\nretval = fb_alloc_cmap(&info->cmap, 16, 0);\r\nif (retval < 0) {\r\ndev_err(&dev->dev, "Failed to allocate colormap\n");\r\ngoto err_vfree;\r\n}\r\nfor (i = 0; i < 16; i++)\r\ninfo->cmap.red[i] = (((2*i)+1)*(0xFFFF))/32;\r\nmemcpy(info->cmap.green, info->cmap.red, sizeof(u16)*16);\r\nmemcpy(info->cmap.blue, info->cmap.red, sizeof(u16)*16);\r\nretval = par->board->setup_irq(info);\r\nif (retval < 0)\r\ngoto err_cmap;\r\nretval = board->init(par);\r\nif (retval < 0)\r\ngoto err_free_irq;\r\nbroadsheet_identify(par);\r\nbroadsheet_init(par);\r\nretval = register_framebuffer(info);\r\nif (retval < 0)\r\ngoto err_free_irq;\r\nplatform_set_drvdata(dev, info);\r\nretval = device_create_file(&dev->dev, &dev_attr_loadstore_waveform);\r\nif (retval < 0)\r\ngoto err_unreg_fb;\r\nprintk(KERN_INFO\r\n"fb%d: Broadsheet frame buffer, using %dK of video memory\n",\r\ninfo->node, videomemorysize >> 10);\r\nreturn 0;\r\nerr_unreg_fb:\r\nunregister_framebuffer(info);\r\nerr_free_irq:\r\nboard->cleanup(par);\r\nerr_cmap:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr_vfree:\r\nvfree(videomemory);\r\nerr_fb_rel:\r\nframebuffer_release(info);\r\nerr:\r\nmodule_put(board->owner);\r\nreturn retval;\r\n}\r\nstatic int __devexit broadsheetfb_remove(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nif (info) {\r\nstruct broadsheetfb_par *par = info->par;\r\ndevice_remove_file(info->dev, &dev_attr_loadstore_waveform);\r\nunregister_framebuffer(info);\r\nfb_deferred_io_cleanup(info);\r\npar->board->cleanup(par);\r\nfb_dealloc_cmap(&info->cmap);\r\nvfree((void *)info->screen_base);\r\nmodule_put(par->board->owner);\r\nframebuffer_release(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init broadsheetfb_init(void)\r\n{\r\nreturn platform_driver_register(&broadsheetfb_driver);\r\n}\r\nstatic void __exit broadsheetfb_exit(void)\r\n{\r\nplatform_driver_unregister(&broadsheetfb_driver);\r\n}
