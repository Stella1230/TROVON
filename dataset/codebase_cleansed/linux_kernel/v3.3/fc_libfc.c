static int __init libfc_init(void)\r\n{\r\nint rc = 0;\r\nrc = fc_setup_fcp();\r\nif (rc)\r\nreturn rc;\r\nrc = fc_setup_exch_mgr();\r\nif (rc)\r\ngoto destroy_pkt_cache;\r\nrc = fc_setup_rport();\r\nif (rc)\r\ngoto destroy_em;\r\nreturn rc;\r\ndestroy_em:\r\nfc_destroy_exch_mgr();\r\ndestroy_pkt_cache:\r\nfc_destroy_fcp();\r\nreturn rc;\r\n}\r\nstatic void __exit libfc_exit(void)\r\n{\r\nfc_destroy_fcp();\r\nfc_destroy_exch_mgr();\r\nfc_destroy_rport();\r\n}\r\nu32 fc_copy_buffer_to_sglist(void *buf, size_t len,\r\nstruct scatterlist *sg,\r\nu32 *nents, size_t *offset,\r\nenum km_type km_type, u32 *crc)\r\n{\r\nsize_t remaining = len;\r\nu32 copy_len = 0;\r\nwhile (remaining > 0 && sg) {\r\nsize_t off, sg_bytes;\r\nvoid *page_addr;\r\nif (*offset >= sg->length) {\r\nif (!(*nents))\r\nbreak;\r\n--(*nents);\r\n*offset -= sg->length;\r\nsg = sg_next(sg);\r\ncontinue;\r\n}\r\nsg_bytes = min(remaining, sg->length - *offset);\r\noff = *offset + sg->offset;\r\nsg_bytes = min(sg_bytes,\r\n(size_t)(PAGE_SIZE - (off & ~PAGE_MASK)));\r\npage_addr = kmap_atomic(sg_page(sg) + (off >> PAGE_SHIFT),\r\nkm_type);\r\nif (crc)\r\n*crc = crc32(*crc, buf, sg_bytes);\r\nmemcpy((char *)page_addr + (off & ~PAGE_MASK), buf, sg_bytes);\r\nkunmap_atomic(page_addr, km_type);\r\nbuf += sg_bytes;\r\n*offset += sg_bytes;\r\nremaining -= sg_bytes;\r\ncopy_len += sg_bytes;\r\n}\r\nreturn copy_len;\r\n}\r\nvoid fc_fill_hdr(struct fc_frame *fp, const struct fc_frame *in_fp,\r\nenum fc_rctl r_ctl, u32 f_ctl, u16 seq_cnt, u32 parm_offset)\r\n{\r\nstruct fc_frame_header *fh;\r\nstruct fc_frame_header *in_fh;\r\nstruct fc_seq *sp;\r\nu32 fill;\r\nfh = __fc_frame_header_get(fp);\r\nin_fh = __fc_frame_header_get(in_fp);\r\nif (f_ctl & FC_FC_END_SEQ) {\r\nfill = -fr_len(fp) & 3;\r\nif (fill) {\r\nmemset(skb_put(fp_skb(fp), fill), 0, fill);\r\nf_ctl |= fill;\r\n}\r\nfr_eof(fp) = FC_EOF_T;\r\n} else {\r\nWARN_ON(fr_len(fp) % 4 != 0);\r\nfr_eof(fp) = FC_EOF_N;\r\n}\r\nfh->fh_r_ctl = r_ctl;\r\nmemcpy(fh->fh_d_id, in_fh->fh_s_id, sizeof(fh->fh_d_id));\r\nmemcpy(fh->fh_s_id, in_fh->fh_d_id, sizeof(fh->fh_s_id));\r\nfh->fh_type = in_fh->fh_type;\r\nhton24(fh->fh_f_ctl, f_ctl);\r\nfh->fh_ox_id = in_fh->fh_ox_id;\r\nfh->fh_rx_id = in_fh->fh_rx_id;\r\nfh->fh_cs_ctl = 0;\r\nfh->fh_df_ctl = 0;\r\nfh->fh_parm_offset = htonl(parm_offset);\r\nsp = fr_seq(in_fp);\r\nif (sp) {\r\nfr_seq(fp) = sp;\r\nfh->fh_seq_id = sp->id;\r\nseq_cnt = sp->cnt;\r\n} else {\r\nfh->fh_seq_id = 0;\r\n}\r\nfh->fh_seq_cnt = ntohs(seq_cnt);\r\nfr_sof(fp) = seq_cnt ? FC_SOF_N3 : FC_SOF_I3;\r\nfr_encaps(fp) = fr_encaps(in_fp);\r\n}\r\nvoid fc_fill_reply_hdr(struct fc_frame *fp, const struct fc_frame *in_fp,\r\nenum fc_rctl r_ctl, u32 parm_offset)\r\n{\r\nstruct fc_seq *sp;\r\nsp = fr_seq(in_fp);\r\nif (sp)\r\nfr_seq(fp) = fr_dev(in_fp)->tt.seq_start_next(sp);\r\nfc_fill_hdr(fp, in_fp, r_ctl, FC_FCTL_RESP, 0, parm_offset);\r\n}\r\nvoid fc_fc4_conf_lport_params(struct fc_lport *lport, enum fc_fh_type type)\r\n{\r\nstruct fc4_prov *prov_entry;\r\nBUG_ON(type >= FC_FC4_PROV_SIZE);\r\nBUG_ON(!lport);\r\nprov_entry = fc_passive_prov[type];\r\nif (type == FC_TYPE_FCP) {\r\nif (prov_entry && prov_entry->recv)\r\nlport->service_params |= FCP_SPPF_TARG_FCN;\r\n}\r\n}\r\nvoid fc_lport_iterate(void (*notify)(struct fc_lport *, void *), void *arg)\r\n{\r\nstruct fc_lport *lport;\r\nmutex_lock(&fc_prov_mutex);\r\nlist_for_each_entry(lport, &fc_local_ports, lport_list)\r\nnotify(lport, arg);\r\nmutex_unlock(&fc_prov_mutex);\r\n}\r\nint fc_fc4_register_provider(enum fc_fh_type type, struct fc4_prov *prov)\r\n{\r\nstruct fc4_prov **prov_entry;\r\nint ret = 0;\r\nif (type >= FC_FC4_PROV_SIZE)\r\nreturn -EINVAL;\r\nmutex_lock(&fc_prov_mutex);\r\nprov_entry = (prov->recv ? fc_passive_prov : fc_active_prov) + type;\r\nif (*prov_entry)\r\nret = -EBUSY;\r\nelse\r\n*prov_entry = prov;\r\nmutex_unlock(&fc_prov_mutex);\r\nreturn ret;\r\n}\r\nvoid fc_fc4_deregister_provider(enum fc_fh_type type, struct fc4_prov *prov)\r\n{\r\nBUG_ON(type >= FC_FC4_PROV_SIZE);\r\nmutex_lock(&fc_prov_mutex);\r\nif (prov->recv)\r\nrcu_assign_pointer(fc_passive_prov[type], NULL);\r\nelse\r\nrcu_assign_pointer(fc_active_prov[type], NULL);\r\nmutex_unlock(&fc_prov_mutex);\r\nsynchronize_rcu();\r\n}\r\nvoid fc_fc4_add_lport(struct fc_lport *lport)\r\n{\r\nmutex_lock(&fc_prov_mutex);\r\nlist_add_tail(&lport->lport_list, &fc_local_ports);\r\nblocking_notifier_call_chain(&fc_lport_notifier_head,\r\nFC_LPORT_EV_ADD, lport);\r\nmutex_unlock(&fc_prov_mutex);\r\n}\r\nvoid fc_fc4_del_lport(struct fc_lport *lport)\r\n{\r\nmutex_lock(&fc_prov_mutex);\r\nlist_del(&lport->lport_list);\r\nblocking_notifier_call_chain(&fc_lport_notifier_head,\r\nFC_LPORT_EV_DEL, lport);\r\nmutex_unlock(&fc_prov_mutex);\r\n}
