struct net_device * __init ewrk3_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct ewrk3_private));\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (unit >= 0) {\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\n}\r\nerr = ewrk3_probe1(dev, dev->base_addr, dev->irq);\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init ewrk3_probe1(struct net_device *dev, u_long iobase, int irq)\r\n{\r\nint err;\r\ndev->base_addr = iobase;\r\ndev->irq = irq;\r\nerr = isa_probe(dev, iobase);\r\nif (err != 0)\r\nerr = eisa_probe(dev, iobase);\r\nif (err)\r\nreturn err;\r\nerr = register_netdev(dev);\r\nif (err)\r\nrelease_region(dev->base_addr, EWRK3_TOTAL_SIZE);\r\nreturn err;\r\n}\r\nstatic int __init\r\newrk3_hw_init(struct net_device *dev, u_long iobase)\r\n{\r\nstruct ewrk3_private *lp;\r\nint i, status = 0;\r\nu_long mem_start, shmem_length;\r\nu_char cr, cmr, icr, nicsr, lemac, hard_strapped = 0;\r\nu_char eeprom_image[EEPROM_MAX], chksum, eisa_cr = 0;\r\nif (iobase > 0x400)\r\neisa_cr = inb(EISA_CR);\r\nINIT_EWRK3;\r\nnicsr = inb(EWRK3_CSR);\r\nicr = inb(EWRK3_ICR);\r\nicr &= 0x70;\r\noutb(icr, EWRK3_ICR);\r\nif (nicsr != (CSR_TXD | CSR_RXD))\r\nreturn -ENXIO;\r\nfor (chksum = 0, i = 0; i < EEPROM_MAX; i += 2) {\r\nunion {\r\nshort val;\r\nchar c[2];\r\n} tmp;\r\ntmp.val = (short) Read_EEPROM(iobase, (i >> 1));\r\neeprom_image[i] = tmp.c[0];\r\neeprom_image[i + 1] = tmp.c[1];\r\nchksum += eeprom_image[i] + eeprom_image[i + 1];\r\n}\r\nif (chksum != 0) {\r\nprintk("%s: Device has a bad on-board EEPROM.\n", dev->name);\r\nreturn -ENXIO;\r\n}\r\nEthwrkSignature(name, eeprom_image);\r\nif (*name == '\0')\r\nreturn -ENXIO;\r\ndev->base_addr = iobase;\r\nif (iobase > 0x400) {\r\noutb(eisa_cr, EISA_CR);\r\n}\r\nlemac = eeprom_image[EEPROM_CHIPVER];\r\ncmr = inb(EWRK3_CMR);\r\nif (((lemac == LeMAC) && ((cmr & CMR_NO_EEPROM) != CMR_NO_EEPROM)) ||\r\n((lemac == LeMAC2) && !(cmr & CMR_HS))) {\r\nprintk("%s: %s at %#4lx", dev->name, name, iobase);\r\nhard_strapped = 1;\r\n} else if ((iobase & 0x0fff) == EWRK3_EISA_IO_PORTS) {\r\nprintk("%s: %s at %#4lx (EISA slot %ld)",\r\ndev->name, name, iobase, ((iobase >> 12) & 0x0f));\r\n} else {\r\nprintk("%s: %s at %#4lx", dev->name, name, iobase);\r\n}\r\nprintk(", h/w address ");\r\nif (lemac != LeMAC2)\r\nDevicePresent(iobase);\r\nstatus = get_hw_addr(dev, eeprom_image, lemac);\r\nprintk("%pM\n", dev->dev_addr);\r\nif (status) {\r\nprintk(" which has an EEPROM CRC error.\n");\r\nreturn -ENXIO;\r\n}\r\nif (lemac == LeMAC2) {\r\ncmr &= ~(CMR_RA | CMR_WB | CMR_LINK | CMR_POLARITY | CMR_0WS);\r\nif (eeprom_image[EEPROM_MISC0] & READ_AHEAD)\r\ncmr |= CMR_RA;\r\nif (eeprom_image[EEPROM_MISC0] & WRITE_BEHIND)\r\ncmr |= CMR_WB;\r\nif (eeprom_image[EEPROM_NETMAN0] & NETMAN_POL)\r\ncmr |= CMR_POLARITY;\r\nif (eeprom_image[EEPROM_NETMAN0] & NETMAN_LINK)\r\ncmr |= CMR_LINK;\r\nif (eeprom_image[EEPROM_MISC0] & _0WS_ENA)\r\ncmr |= CMR_0WS;\r\n}\r\nif (eeprom_image[EEPROM_SETUP] & SETUP_DRAM)\r\ncmr |= CMR_DRAM;\r\noutb(cmr, EWRK3_CMR);\r\ncr = inb(EWRK3_CR);\r\ncr |= eeprom_image[EEPROM_SETUP] & SETUP_APD;\r\nif (cr & SETUP_APD)\r\ncr |= eeprom_image[EEPROM_SETUP] & SETUP_PS;\r\ncr |= eeprom_image[EEPROM_MISC0] & FAST_BUS;\r\ncr |= eeprom_image[EEPROM_MISC0] & ENA_16;\r\noutb(cr, EWRK3_CR);\r\nmem_start = inb(EWRK3_MBR);\r\nshmem_length = 0;\r\nif (mem_start != 0) {\r\nif ((mem_start >= 0x0a) && (mem_start <= 0x0f)) {\r\nmem_start *= SHMEM_64K;\r\nshmem_length = SHMEM_64K;\r\n} else if ((mem_start >= 0x14) && (mem_start <= 0x1f)) {\r\nmem_start *= SHMEM_32K;\r\nshmem_length = SHMEM_32K;\r\n} else if ((mem_start >= 0x40) && (mem_start <= 0xff)) {\r\nmem_start = mem_start * SHMEM_2K + 0x80000;\r\nshmem_length = SHMEM_2K;\r\n} else {\r\nreturn -ENXIO;\r\n}\r\n}\r\nif (hard_strapped) {\r\nprintk(" is hard strapped.\n");\r\n} else if (mem_start) {\r\nprintk(" has a %dk RAM window", (int) (shmem_length >> 10));\r\nprintk(" at 0x%.5lx", mem_start);\r\n} else {\r\nprintk(" is in I/O only mode");\r\n}\r\nlp = netdev_priv(dev);\r\nlp->shmem_base = mem_start;\r\nlp->shmem = ioremap(mem_start, shmem_length);\r\nif (!lp->shmem)\r\nreturn -ENOMEM;\r\nlp->shmem_length = shmem_length;\r\nlp->lemac = lemac;\r\nlp->hard_strapped = hard_strapped;\r\nlp->led_mask = CR_LED;\r\nspin_lock_init(&lp->hw_lock);\r\nlp->mPage = 64;\r\nif (cmr & CMR_DRAM)\r\nlp->mPage <<= 1;\r\nsprintf(lp->adapter_name, "%s (%s)", name, dev->name);\r\nlp->irq_mask = ICR_TNEM | ICR_TXDM | ICR_RNEM | ICR_RXDM;\r\nif (!hard_strapped) {\r\nicr |= ICR_IE;\r\noutb(icr, EWRK3_ICR);\r\ndev->dma = 0;\r\nif (dev->irq < 2) {\r\n#ifndef MODULE\r\nu_char irqnum;\r\nunsigned long irq_mask;\r\nirq_mask = probe_irq_on();\r\nicr |= ICR_TNEM;\r\noutb(1, EWRK3_TDQ);\r\noutb(icr, EWRK3_ICR);\r\nirqnum = irq[((icr & IRQ_SEL) >> 4)];\r\nmdelay(20);\r\ndev->irq = probe_irq_off(irq_mask);\r\nif ((dev->irq) && (irqnum == dev->irq)) {\r\nprintk(" and uses IRQ%d.\n", dev->irq);\r\n} else {\r\nif (!dev->irq) {\r\nprintk(" and failed to detect IRQ line.\n");\r\n} else if ((irqnum == 1) && (lemac == LeMAC2)) {\r\nprintk(" and an illegal IRQ line detected.\n");\r\n} else {\r\nprintk(", but incorrect IRQ line detected.\n");\r\n}\r\niounmap(lp->shmem);\r\nreturn -ENXIO;\r\n}\r\nDISABLE_IRQs;\r\n#endif\r\n} else {\r\nprintk(" and requires IRQ%d.\n", dev->irq);\r\n}\r\n}\r\nif (ewrk3_debug > 1) {\r\nprintk(version);\r\n}\r\ndev->netdev_ops = &ewrk3_netdev_ops;\r\nif (lp->adapter_name[4] == '3')\r\nSET_ETHTOOL_OPS(dev, &ethtool_ops_203);\r\nelse\r\nSET_ETHTOOL_OPS(dev, &ethtool_ops);\r\ndev->watchdog_timeo = QUEUE_PKT_TIMEOUT;\r\ndev->mem_start = 0;\r\nreturn 0;\r\n}\r\nstatic int ewrk3_open(struct net_device *dev)\r\n{\r\nstruct ewrk3_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nint status = 0;\r\nu_char icr, csr;\r\nSTOP_EWRK3;\r\nif (!lp->hard_strapped) {\r\nif (request_irq(dev->irq, (void *) ewrk3_interrupt, 0, "ewrk3", dev)) {\r\nprintk("ewrk3_open(): Requested IRQ%d is busy\n", dev->irq);\r\nstatus = -EAGAIN;\r\n} else {\r\newrk3_init(dev);\r\nif (ewrk3_debug > 1) {\r\nprintk("%s: ewrk3 open with irq %d\n", dev->name, dev->irq);\r\nprintk(" physical address: %pM\n", dev->dev_addr);\r\nif (lp->shmem_length == 0) {\r\nprintk(" no shared memory, I/O only mode\n");\r\n} else {\r\nprintk(" start of shared memory: 0x%08lx\n", lp->shmem_base);\r\nprintk(" window length: 0x%04lx\n", lp->shmem_length);\r\n}\r\nprintk(" # of DRAMS: %d\n", ((inb(EWRK3_CMR) & 0x02) ? 2 : 1));\r\nprintk(" csr: 0x%02x\n", inb(EWRK3_CSR));\r\nprintk(" cr: 0x%02x\n", inb(EWRK3_CR));\r\nprintk(" icr: 0x%02x\n", inb(EWRK3_ICR));\r\nprintk(" cmr: 0x%02x\n", inb(EWRK3_CMR));\r\nprintk(" fmqc: 0x%02x\n", inb(EWRK3_FMQC));\r\n}\r\nnetif_start_queue(dev);\r\nicr = inb(EWRK3_ICR);\r\nENABLE_IRQs;\r\n}\r\n} else {\r\nprintk(KERN_ERR "%s: ewrk3 available for hard strapped set up only.\n", dev->name);\r\nprintk(KERN_ERR " Run the 'ewrk3setup' utility or remove the hard straps.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn status;\r\n}\r\nstatic void ewrk3_init(struct net_device *dev)\r\n{\r\nstruct ewrk3_private *lp = netdev_priv(dev);\r\nu_char csr, page;\r\nu_long iobase = dev->base_addr;\r\nint i;\r\nset_multicast_list(dev);\r\nfor (i=0; i<ETH_ALEN; i++)\r\noutb(dev->dev_addr[i], EWRK3_PAR0 + i);\r\nwhile (inb(EWRK3_TQ));\r\nwhile (inb(EWRK3_TDQ));\r\nwhile (inb(EWRK3_RQ));\r\nwhile (inb(EWRK3_FMQ));\r\nfor (page = 1; page < lp->mPage; page++) {\r\noutb(page, EWRK3_FMQ);\r\n}\r\nSTART_EWRK3;\r\n}\r\nstatic void ewrk3_timeout(struct net_device *dev)\r\n{\r\nstruct ewrk3_private *lp = netdev_priv(dev);\r\nu_char icr, csr;\r\nu_long iobase = dev->base_addr;\r\nif (!lp->hard_strapped)\r\n{\r\nprintk(KERN_WARNING"%s: transmit timed/locked out, status %04x, resetting.\n",\r\ndev->name, inb(EWRK3_CSR));\r\nDISABLE_IRQs;\r\nSTOP_EWRK3;\r\newrk3_init(dev);\r\nENABLE_IRQs;\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nstatic netdev_tx_t ewrk3_queue_pkt(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ewrk3_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nvoid __iomem *buf = NULL;\r\nu_char icr;\r\nu_char page;\r\nspin_lock_irq (&lp->hw_lock);\r\nDISABLE_IRQs;\r\nif (inb (EWRK3_FMQC) == 0) {\r\nprintk (KERN_WARNING "%s: ewrk3_queue_pkt(): No free resources...\n",\r\ndev->name);\r\nprintk (KERN_WARNING "%s: ewrk3_queue_pkt(): CSR: %02x ICR: %02x FMQC: %02x\n",\r\ndev->name, inb (EWRK3_CSR), inb (EWRK3_ICR),\r\ninb (EWRK3_FMQC));\r\ngoto err_out;\r\n}\r\nif ((page = inb (EWRK3_FMQ)) >= lp->mPage) {\r\nprintk ("ewrk3_queue_pkt(): Invalid free memory page (%d).\n",\r\n(u_char) page);\r\ngoto err_out;\r\n}\r\nif (lp->shmem_length == IO_ONLY) {\r\noutb (page, EWRK3_IOPR);\r\n} else if (lp->shmem_length == SHMEM_2K) {\r\nbuf = lp->shmem;\r\noutb (page, EWRK3_MPR);\r\n} else if (lp->shmem_length == SHMEM_32K) {\r\nbuf = (((short) page << 11) & 0x7800) + lp->shmem;\r\noutb ((page >> 4), EWRK3_MPR);\r\n} else if (lp->shmem_length == SHMEM_64K) {\r\nbuf = (((short) page << 11) & 0xf800) + lp->shmem;\r\noutb ((page >> 5), EWRK3_MPR);\r\n} else {\r\nprintk (KERN_ERR "%s: Oops - your private data area is hosed!\n",\r\ndev->name);\r\nBUG ();\r\n}\r\nif (lp->shmem_length == IO_ONLY) {\r\nint i;\r\nu_char *p = skb->data;\r\noutb ((char) (TCR_QMODE | TCR_PAD | TCR_IFC), EWRK3_DATA);\r\noutb ((char) (skb->len & 0xff), EWRK3_DATA);\r\noutb ((char) ((skb->len >> 8) & 0xff), EWRK3_DATA);\r\noutb ((char) 0x04, EWRK3_DATA);\r\nfor (i = 0; i < skb->len; i++) {\r\noutb (*p++, EWRK3_DATA);\r\n}\r\noutb (page, EWRK3_TQ);\r\n} else {\r\nwriteb ((char) (TCR_QMODE | TCR_PAD | TCR_IFC), buf);\r\nbuf += 1;\r\nwriteb ((char) (skb->len & 0xff), buf);\r\nbuf += 1;\r\nif (lp->txc) {\r\nwriteb(((skb->len >> 8) & 0xff) | XCT, buf);\r\nbuf += 1;\r\nwriteb (0x04, buf);\r\nbuf += 1;\r\nwriteb (0x00, (buf + skb->len));\r\nmemcpy_toio (buf, skb->data, PRELOAD);\r\noutb (page, EWRK3_TQ);\r\nmemcpy_toio (buf + PRELOAD,\r\nskb->data + PRELOAD,\r\nskb->len - PRELOAD);\r\nwriteb (0xff, (buf + skb->len));\r\n} else {\r\nwriteb ((skb->len >> 8) & 0xff, buf);\r\nbuf += 1;\r\nwriteb (0x04, buf);\r\nbuf += 1;\r\nmemcpy_toio (buf, skb->data, skb->len);\r\noutb (page, EWRK3_TQ);\r\n}\r\n}\r\nENABLE_IRQs;\r\nspin_unlock_irq (&lp->hw_lock);\r\ndev->stats.tx_bytes += skb->len;\r\ndev_kfree_skb (skb);\r\nif (inb (EWRK3_FMQC) == 0)\r\nnetif_stop_queue (dev);\r\nreturn NETDEV_TX_OK;\r\nerr_out:\r\nENABLE_IRQs;\r\nspin_unlock_irq (&lp->hw_lock);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nstatic irqreturn_t ewrk3_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct ewrk3_private *lp;\r\nu_long iobase;\r\nu_char icr, cr, csr;\r\nlp = netdev_priv(dev);\r\niobase = dev->base_addr;\r\ncsr = inb(EWRK3_CSR);\r\nspin_lock(&lp->hw_lock);\r\nDISABLE_IRQs;\r\ncr = inb(EWRK3_CR);\r\ncr |= lp->led_mask;\r\noutb(cr, EWRK3_CR);\r\nif (csr & CSR_RNE)\r\newrk3_rx(dev);\r\nif (csr & CSR_TNE)\r\newrk3_tx(dev);\r\nif (inb(EWRK3_FMQC)) {\r\nlp->irq_mask |= ICR_TXDM | ICR_RXDM;\r\ncsr &= ~(CSR_TXD | CSR_RXD);\r\noutb(csr, EWRK3_CSR);\r\nnetif_wake_queue(dev);\r\n} else {\r\nlp->irq_mask &= ~(ICR_TXDM | ICR_RXDM);\r\n}\r\ncr &= ~(lp->led_mask);\r\noutb(cr, EWRK3_CR);\r\nENABLE_IRQs;\r\nspin_unlock(&lp->hw_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ewrk3_rx(struct net_device *dev)\r\n{\r\nstruct ewrk3_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nint i, status = 0;\r\nu_char page;\r\nvoid __iomem *buf = NULL;\r\nwhile (inb(EWRK3_RQC) && !status) {\r\nif ((page = inb(EWRK3_RQ)) < lp->mPage) {\r\nif (lp->shmem_length == IO_ONLY) {\r\noutb(page, EWRK3_IOPR);\r\n} else if (lp->shmem_length == SHMEM_2K) {\r\nbuf = lp->shmem;\r\noutb(page, EWRK3_MPR);\r\n} else if (lp->shmem_length == SHMEM_32K) {\r\nbuf = (((short) page << 11) & 0x7800) + lp->shmem;\r\noutb((page >> 4), EWRK3_MPR);\r\n} else if (lp->shmem_length == SHMEM_64K) {\r\nbuf = (((short) page << 11) & 0xf800) + lp->shmem;\r\noutb((page >> 5), EWRK3_MPR);\r\n} else {\r\nstatus = -1;\r\nprintk("%s: Oops - your private data area is hosed!\n", dev->name);\r\n}\r\nif (!status) {\r\nchar rx_status;\r\nint pkt_len;\r\nif (lp->shmem_length == IO_ONLY) {\r\nrx_status = inb(EWRK3_DATA);\r\npkt_len = inb(EWRK3_DATA);\r\npkt_len |= ((u_short) inb(EWRK3_DATA) << 8);\r\n} else {\r\nrx_status = readb(buf);\r\nbuf += 1;\r\npkt_len = readw(buf);\r\nbuf += 3;\r\n}\r\nif (!(rx_status & R_ROK)) {\r\ndev->stats.rx_errors++;\r\nif (rx_status & R_DBE)\r\ndev->stats.rx_frame_errors++;\r\nif (rx_status & R_CRC)\r\ndev->stats.rx_crc_errors++;\r\nif (rx_status & R_PLL)\r\ndev->stats.rx_fifo_errors++;\r\n} else {\r\nstruct sk_buff *skb;\r\nif ((skb = dev_alloc_skb(pkt_len + 2)) != NULL) {\r\nunsigned char *p;\r\nskb_reserve(skb, 2);\r\np = skb_put(skb, pkt_len);\r\nif (lp->shmem_length == IO_ONLY) {\r\n*p = inb(EWRK3_DATA);\r\nfor (i = 0; i < pkt_len; i++) {\r\n*p++ = inb(EWRK3_DATA);\r\n}\r\n} else {\r\nmemcpy_fromio(p, buf, pkt_len);\r\n}\r\nfor (i = 1; i < EWRK3_PKT_STAT_SZ - 1; i++) {\r\nif (pkt_len < i * EWRK3_PKT_BIN_SZ) {\r\nlp->pktStats.bins[i]++;\r\ni = EWRK3_PKT_STAT_SZ;\r\n}\r\n}\r\np = skb->data;\r\nif (is_multicast_ether_addr(p)) {\r\nif (is_broadcast_ether_addr(p)) {\r\nlp->pktStats.broadcast++;\r\n} else {\r\nlp->pktStats.multicast++;\r\n}\r\n} else if (compare_ether_addr(p, dev->dev_addr) == 0) {\r\nlp->pktStats.unicast++;\r\n}\r\nlp->pktStats.bins[0]++;\r\nif (lp->pktStats.bins[0] == 0) {\r\nmemset(&lp->pktStats, 0, sizeof(lp->pktStats));\r\n}\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n} else {\r\nprintk("%s: Insufficient memory; nuking packet.\n", dev->name);\r\ndev->stats.rx_dropped++;\r\nbreak;\r\n}\r\n}\r\n}\r\noutb(page, EWRK3_FMQ);\r\n} else {\r\nprintk("ewrk3_rx(): Illegal page number, page %d\n", page);\r\nprintk("ewrk3_rx(): CSR: %02x ICR: %02x FMQC: %02x\n", inb(EWRK3_CSR), inb(EWRK3_ICR), inb(EWRK3_FMQC));\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int ewrk3_tx(struct net_device *dev)\r\n{\r\nstruct ewrk3_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nu_char tx_status;\r\nwhile ((tx_status = inb(EWRK3_TDQ)) > 0) {\r\nif (tx_status & T_VSTS) {\r\nif (tx_status & T_TXE) {\r\ndev->stats.tx_errors++;\r\nif (tx_status & T_NCL)\r\ndev->stats.tx_carrier_errors++;\r\nif (tx_status & T_LCL)\r\ndev->stats.tx_window_errors++;\r\nif (tx_status & T_CTU) {\r\nif ((tx_status & T_COLL) ^ T_XUR) {\r\nlp->pktStats.tx_underruns++;\r\n} else {\r\nlp->pktStats.excessive_underruns++;\r\n}\r\n} else if (tx_status & T_COLL) {\r\nif ((tx_status & T_COLL) ^ T_XCOLL) {\r\ndev->stats.collisions++;\r\n} else {\r\nlp->pktStats.excessive_collisions++;\r\n}\r\n}\r\n} else {\r\ndev->stats.tx_packets++;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ewrk3_close(struct net_device *dev)\r\n{\r\nstruct ewrk3_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nu_char icr, csr;\r\nnetif_stop_queue(dev);\r\nif (ewrk3_debug > 1) {\r\nprintk("%s: Shutting down ethercard, status was %2.2x.\n",\r\ndev->name, inb(EWRK3_CSR));\r\n}\r\nDISABLE_IRQs;\r\nSTOP_EWRK3;\r\nwhile (inb(EWRK3_TQ));\r\nwhile (inb(EWRK3_TDQ));\r\nwhile (inb(EWRK3_RQ));\r\nif (!lp->hard_strapped) {\r\nfree_irq(dev->irq, dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nstruct ewrk3_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nu_char csr;\r\ncsr = inb(EWRK3_CSR);\r\nif (lp->shmem_length == IO_ONLY) {\r\nlp->mctbl = NULL;\r\n} else {\r\nlp->mctbl = lp->shmem + PAGE0_HTE;\r\n}\r\ncsr &= ~(CSR_PME | CSR_MCE);\r\nif (dev->flags & IFF_PROMISC) {\r\ncsr |= CSR_PME;\r\noutb(csr, EWRK3_CSR);\r\n} else {\r\nSetMulticastFilter(dev);\r\ncsr |= CSR_MCE;\r\noutb(csr, EWRK3_CSR);\r\n}\r\n}\r\nstatic void SetMulticastFilter(struct net_device *dev)\r\n{\r\nstruct ewrk3_private *lp = netdev_priv(dev);\r\nstruct netdev_hw_addr *ha;\r\nu_long iobase = dev->base_addr;\r\nint i;\r\nchar bit, byte;\r\nshort __iomem *p = lp->mctbl;\r\nu16 hashcode;\r\nu32 crc;\r\nspin_lock_irq(&lp->hw_lock);\r\nif (lp->shmem_length == IO_ONLY) {\r\noutb(0, EWRK3_IOPR);\r\noutw(PAGE0_HTE, EWRK3_PIR1);\r\n} else {\r\noutb(0, EWRK3_MPR);\r\n}\r\nif (dev->flags & IFF_ALLMULTI) {\r\nfor (i = 0; i < (HASH_TABLE_LEN >> 3); i++) {\r\nif (lp->shmem_length == IO_ONLY) {\r\noutb(0xff, EWRK3_DATA);\r\n} else {\r\nwritew(0xffff, p);\r\np++;\r\ni++;\r\n}\r\n}\r\n} else {\r\nif (lp->shmem_length == IO_ONLY) {\r\nfor (i = 0; i < (HASH_TABLE_LEN >> 4) - 1; i++) {\r\noutb(0x00, EWRK3_DATA);\r\n}\r\noutb(0x80, EWRK3_DATA);\r\ni++;\r\nfor (; i < (HASH_TABLE_LEN >> 3); i++) {\r\noutb(0x00, EWRK3_DATA);\r\n}\r\n} else {\r\nmemset_io(lp->mctbl, 0, HASH_TABLE_LEN >> 3);\r\nwriteb(0x80, lp->mctbl + (HASH_TABLE_LEN >> 4) - 1);\r\n}\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc_le(ETH_ALEN, ha->addr);\r\nhashcode = crc & ((1 << 9) - 1);\r\nbyte = hashcode >> 3;\r\nbit = 1 << (hashcode & 0x07);\r\nif (lp->shmem_length == IO_ONLY) {\r\nu_char tmp;\r\noutw(PAGE0_HTE + byte, EWRK3_PIR1);\r\ntmp = inb(EWRK3_DATA);\r\ntmp |= bit;\r\noutw(PAGE0_HTE + byte, EWRK3_PIR1);\r\noutb(tmp, EWRK3_DATA);\r\n} else {\r\nwriteb(readb(lp->mctbl + byte) | bit, lp->mctbl + byte);\r\n}\r\n}\r\n}\r\nspin_unlock_irq(&lp->hw_lock);\r\n}\r\nstatic int __init isa_probe(struct net_device *dev, u_long ioaddr)\r\n{\r\nint i = num_ewrks3s, maxSlots;\r\nint ret = -ENODEV;\r\nu_long iobase;\r\nif (ioaddr >= 0x400)\r\ngoto out;\r\nif (ioaddr == 0) {\r\niobase = EWRK3_IO_BASE;\r\nmaxSlots = 24;\r\n} else {\r\niobase = ioaddr;\r\nmaxSlots = i + 1;\r\n}\r\nfor (; (i < maxSlots) && (dev != NULL);\r\niobase += EWRK3_IOP_INC, i++)\r\n{\r\nif (request_region(iobase, EWRK3_TOTAL_SIZE, DRV_NAME)) {\r\nif (DevicePresent(iobase) == 0) {\r\nint irq = dev->irq;\r\nret = ewrk3_hw_init(dev, iobase);\r\nif (!ret)\r\nbreak;\r\ndev->irq = irq;\r\n}\r\nrelease_region(iobase, EWRK3_TOTAL_SIZE);\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init eisa_probe(struct net_device *dev, u_long ioaddr)\r\n{\r\nint i, maxSlots;\r\nu_long iobase;\r\nint ret = -ENODEV;\r\nif (ioaddr < 0x1000)\r\ngoto out;\r\niobase = ioaddr;\r\ni = (ioaddr >> 12);\r\nmaxSlots = i + 1;\r\nfor (i = 1; (i < maxSlots) && (dev != NULL); i++, iobase += EISA_SLOT_INC) {\r\nif (EISA_signature(name, EISA_ID) == 0) {\r\nif (request_region(iobase, EWRK3_TOTAL_SIZE, DRV_NAME) &&\r\nDevicePresent(iobase) == 0) {\r\nint irq = dev->irq;\r\nret = ewrk3_hw_init(dev, iobase);\r\nif (!ret)\r\nbreak;\r\ndev->irq = irq;\r\n}\r\nrelease_region(iobase, EWRK3_TOTAL_SIZE);\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int Read_EEPROM(u_long iobase, u_char eaddr)\r\n{\r\nint i;\r\noutb((eaddr & 0x3f), EWRK3_PIR1);\r\noutb(EEPROM_RD, EWRK3_IOPR);\r\nfor (i = 0; i < 5000; i++)\r\ninb(EWRK3_CSR);\r\nreturn inw(EWRK3_EPROM1);\r\n}\r\nstatic int Write_EEPROM(short data, u_long iobase, u_char eaddr)\r\n{\r\nint i;\r\noutb(EEPROM_WR_EN, EWRK3_IOPR);\r\nfor (i = 0; i < 5000; i++)\r\ninb(EWRK3_CSR);\r\noutw(data, EWRK3_EPROM1);\r\noutb((eaddr & 0x3f), EWRK3_PIR1);\r\noutb(EEPROM_WR, EWRK3_IOPR);\r\nfor (i = 0; i < 75000; i++)\r\ninb(EWRK3_CSR);\r\noutb(EEPROM_WR_DIS, EWRK3_IOPR);\r\nfor (i = 0; i < 5000; i++)\r\ninb(EWRK3_CSR);\r\nreturn 0;\r\n}\r\nstatic void __init EthwrkSignature(char *name, char *eeprom_image)\r\n{\r\nint i;\r\nchar *signatures[] = EWRK3_SIGNATURE;\r\nfor (i=0; *signatures[i] != '\0'; i++)\r\nif( !strncmp(eeprom_image+EEPROM_PNAME7, signatures[i], strlen(signatures[i])) )\r\nbreak;\r\nif (*signatures[i] != '\0') {\r\nmemcpy(name, eeprom_image+EEPROM_PNAME7, EWRK3_STRLEN);\r\nname[EWRK3_STRLEN] = '\0';\r\n} else\r\nname[0] = '\0';\r\n}\r\nstatic int __init DevicePresent(u_long iobase)\r\n{\r\nunion {\r\nstruct {\r\nu32 a;\r\nu32 b;\r\n} llsig;\r\nchar Sig[sizeof(u32) << 1];\r\n}\r\ndev;\r\nshort sigLength;\r\nchar data;\r\nint i, j, status = 0;\r\ndev.llsig.a = ETH_PROM_SIG;\r\ndev.llsig.b = ETH_PROM_SIG;\r\nsigLength = sizeof(u32) << 1;\r\nfor (i = 0, j = 0; j < sigLength && i < PROBE_LENGTH + sigLength - 1; i++) {\r\ndata = inb(EWRK3_APROM);\r\nif (dev.Sig[j] == data) {\r\nj++;\r\n} else {\r\nif (data == dev.Sig[0]) {\r\nj = 1;\r\n} else {\r\nj = 0;\r\n}\r\n}\r\n}\r\nif (j != sigLength) {\r\nstatus = -ENODEV;\r\n}\r\nreturn status;\r\n}\r\nstatic u_char __init get_hw_addr(struct net_device *dev, u_char * eeprom_image, char chipType)\r\n{\r\nint i, j, k;\r\nu_short chksum;\r\nu_char crc, lfsr, sd, status = 0;\r\nu_long iobase = dev->base_addr;\r\nu16 tmp;\r\nif (chipType == LeMAC2) {\r\nfor (crc = 0x6a, j = 0; j < ETH_ALEN; j++) {\r\nsd = dev->dev_addr[j] = eeprom_image[EEPROM_PADDR0 + j];\r\noutb(dev->dev_addr[j], EWRK3_PAR0 + j);\r\nfor (k = 0; k < 8; k++, sd >>= 1) {\r\nlfsr = ((((crc & 0x02) >> 1) ^ (crc & 0x01)) ^ (sd & 0x01)) << 7;\r\ncrc = (crc >> 1) + lfsr;\r\n}\r\n}\r\nif (crc != eeprom_image[EEPROM_PA_CRC])\r\nstatus = -1;\r\n} else {\r\nfor (i = 0, k = 0; i < ETH_ALEN;) {\r\nk <<= 1;\r\nif (k > 0xffff)\r\nk -= 0xffff;\r\nk += (u_char) (tmp = inb(EWRK3_APROM));\r\ndev->dev_addr[i] = (u_char) tmp;\r\noutb(dev->dev_addr[i], EWRK3_PAR0 + i);\r\ni++;\r\nk += (u_short) ((tmp = inb(EWRK3_APROM)) << 8);\r\ndev->dev_addr[i] = (u_char) tmp;\r\noutb(dev->dev_addr[i], EWRK3_PAR0 + i);\r\ni++;\r\nif (k > 0xffff)\r\nk -= 0xffff;\r\n}\r\nif (k == 0xffff)\r\nk = 0;\r\nchksum = inb(EWRK3_APROM);\r\nchksum |= (inb(EWRK3_APROM) << 8);\r\nif (k != chksum)\r\nstatus = -1;\r\n}\r\nreturn status;\r\n}\r\nstatic int __init EISA_signature(char *name, s32 eisa_id)\r\n{\r\nu_long i;\r\nchar *signatures[] = EWRK3_SIGNATURE;\r\nchar ManCode[EWRK3_STRLEN];\r\nunion {\r\ns32 ID;\r\nchar Id[4];\r\n} Eisa;\r\nint status = 0;\r\n*name = '\0';\r\nfor (i = 0; i < 4; i++) {\r\nEisa.Id[i] = inb(eisa_id + i);\r\n}\r\nManCode[0] = (((Eisa.Id[0] >> 2) & 0x1f) + 0x40);\r\nManCode[1] = (((Eisa.Id[1] & 0xe0) >> 5) + ((Eisa.Id[0] & 0x03) << 3) + 0x40);\r\nManCode[2] = (((Eisa.Id[2] >> 4) & 0x0f) + 0x30);\r\nManCode[3] = ((Eisa.Id[2] & 0x0f) + 0x30);\r\nManCode[4] = (((Eisa.Id[3] >> 4) & 0x0f) + 0x30);\r\nManCode[5] = '\0';\r\nfor (i = 0; (*signatures[i] != '\0') && (*name == '\0'); i++) {\r\nif (strstr(ManCode, signatures[i]) != NULL) {\r\nstrcpy(name, ManCode);\r\nstatus = 1;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic void ewrk3_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nint fwrev = Read_EEPROM(dev->base_addr, EEPROM_REVLVL);\r\nstrcpy(info->driver, DRV_NAME);\r\nstrcpy(info->version, DRV_VERSION);\r\nsprintf(info->fw_version, "%d", fwrev);\r\nstrcpy(info->bus_info, "N/A");\r\ninfo->eedump_len = EEPROM_MAX;\r\n}\r\nstatic int ewrk3_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct ewrk3_private *lp = netdev_priv(dev);\r\nunsigned long iobase = dev->base_addr;\r\nu8 cr = inb(EWRK3_CR);\r\nswitch (lp->adapter_name[4]) {\r\ncase '3':\r\necmd->supported = SUPPORTED_BNC;\r\necmd->port = PORT_BNC;\r\nbreak;\r\ncase '4':\r\necmd->supported = SUPPORTED_TP;\r\necmd->port = PORT_TP;\r\nbreak;\r\ncase '5':\r\necmd->supported = SUPPORTED_TP | SUPPORTED_BNC | SUPPORTED_AUI;\r\necmd->autoneg = !(cr & CR_APD);\r\nif (!ecmd->autoneg)\r\necmd->port = (cr & CR_PSEL) ? PORT_BNC : PORT_TP;\r\nbreak;\r\n}\r\necmd->supported |= SUPPORTED_10baseT_Half;\r\nethtool_cmd_speed_set(ecmd, SPEED_10);\r\necmd->duplex = DUPLEX_HALF;\r\nreturn 0;\r\n}\r\nstatic int ewrk3_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct ewrk3_private *lp = netdev_priv(dev);\r\nunsigned long iobase = dev->base_addr;\r\nunsigned long flags;\r\nu8 cr;\r\nif (lp->adapter_name[4] != '5')\r\nreturn -EOPNOTSUPP;\r\nif (ecmd->speed != SPEED_10)\r\nreturn -EINVAL;\r\nif (ecmd->port != PORT_TP && ecmd->port != PORT_BNC)\r\nreturn -EINVAL;\r\nif (ecmd->transceiver != XCVR_INTERNAL)\r\nreturn -EINVAL;\r\nif (ecmd->duplex != DUPLEX_HALF)\r\nreturn -EINVAL;\r\nif (ecmd->phy_address != 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&lp->hw_lock, flags);\r\ncr = inb(EWRK3_CR);\r\nif (ecmd->autoneg) {\r\ncr &= ~CR_APD;\r\n} else {\r\ncr |= CR_APD;\r\nif (ecmd->port == PORT_TP)\r\ncr &= ~CR_PSEL;\r\nelse\r\ncr |= CR_PSEL;\r\n}\r\noutb(cr, EWRK3_CR);\r\nspin_unlock_irqrestore(&lp->hw_lock, flags);\r\nreturn 0;\r\n}\r\nstatic u32 ewrk3_get_link(struct net_device *dev)\r\n{\r\nunsigned long iobase = dev->base_addr;\r\nu8 cmr = inb(EWRK3_CMR);\r\nreturn !(cmr & CMR_LINK);\r\n}\r\nstatic int ewrk3_set_phys_id(struct net_device *dev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nstruct ewrk3_private *lp = netdev_priv(dev);\r\nunsigned long iobase = dev->base_addr;\r\nu8 cr;\r\nspin_lock_irq(&lp->hw_lock);\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nlp->led_mask = 0;\r\nspin_unlock_irq(&lp->hw_lock);\r\nreturn 2;\r\ncase ETHTOOL_ID_ON:\r\ncr = inb(EWRK3_CR);\r\noutb(cr | CR_LED, EWRK3_CR);\r\nbreak;\r\ncase ETHTOOL_ID_OFF:\r\ncr = inb(EWRK3_CR);\r\noutb(cr & ~CR_LED, EWRK3_CR);\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\nlp->led_mask = CR_LED;\r\ncr = inb(EWRK3_CR);\r\noutb(cr & ~CR_LED, EWRK3_CR);\r\n}\r\nspin_unlock_irq(&lp->hw_lock);\r\nreturn 0;\r\n}\r\nstatic int ewrk3_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct ewrk3_private *lp = netdev_priv(dev);\r\nstruct ewrk3_ioctl *ioc = (struct ewrk3_ioctl *) &rq->ifr_ifru;\r\nu_long iobase = dev->base_addr;\r\nint i, j, status = 0;\r\nu_char csr;\r\nunsigned long flags;\r\nunion ewrk3_addr {\r\nu_char addr[HASH_TABLE_LEN * ETH_ALEN];\r\nu_short val[(HASH_TABLE_LEN * ETH_ALEN) >> 1];\r\n};\r\nunion ewrk3_addr *tmp;\r\nif (cmd != EWRK3IOCTL)\r\nreturn -EOPNOTSUPP;\r\ntmp = kmalloc(sizeof(union ewrk3_addr), GFP_KERNEL);\r\nif(tmp==NULL)\r\nreturn -ENOMEM;\r\nswitch (ioc->cmd) {\r\ncase EWRK3_GET_HWADDR:\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\ntmp->addr[i] = dev->dev_addr[i];\r\n}\r\nioc->len = ETH_ALEN;\r\nif (copy_to_user(ioc->data, tmp->addr, ioc->len))\r\nstatus = -EFAULT;\r\nbreak;\r\ncase EWRK3_SET_HWADDR:\r\nif (capable(CAP_NET_ADMIN)) {\r\nspin_lock_irqsave(&lp->hw_lock, flags);\r\ncsr = inb(EWRK3_CSR);\r\ncsr |= (CSR_TXD | CSR_RXD);\r\noutb(csr, EWRK3_CSR);\r\nspin_unlock_irqrestore(&lp->hw_lock, flags);\r\nif (copy_from_user(tmp->addr, ioc->data, ETH_ALEN)) {\r\nstatus = -EFAULT;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&lp->hw_lock, flags);\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\ndev->dev_addr[i] = tmp->addr[i];\r\noutb(tmp->addr[i], EWRK3_PAR0 + i);\r\n}\r\ncsr = inb(EWRK3_CSR);\r\ncsr &= ~(CSR_TXD | CSR_RXD);\r\noutb(csr, EWRK3_CSR);\r\nspin_unlock_irqrestore(&lp->hw_lock, flags);\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nbreak;\r\ncase EWRK3_SET_PROM:\r\nif (capable(CAP_NET_ADMIN)) {\r\nspin_lock_irqsave(&lp->hw_lock, flags);\r\ncsr = inb(EWRK3_CSR);\r\ncsr |= CSR_PME;\r\ncsr &= ~CSR_MCE;\r\noutb(csr, EWRK3_CSR);\r\nspin_unlock_irqrestore(&lp->hw_lock, flags);\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nbreak;\r\ncase EWRK3_CLR_PROM:\r\nif (capable(CAP_NET_ADMIN)) {\r\nspin_lock_irqsave(&lp->hw_lock, flags);\r\ncsr = inb(EWRK3_CSR);\r\ncsr &= ~CSR_PME;\r\noutb(csr, EWRK3_CSR);\r\nspin_unlock_irqrestore(&lp->hw_lock, flags);\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nbreak;\r\ncase EWRK3_GET_MCA:\r\nspin_lock_irqsave(&lp->hw_lock, flags);\r\nif (lp->shmem_length == IO_ONLY) {\r\noutb(0, EWRK3_IOPR);\r\noutw(PAGE0_HTE, EWRK3_PIR1);\r\nfor (i = 0; i < (HASH_TABLE_LEN >> 3); i++) {\r\ntmp->addr[i] = inb(EWRK3_DATA);\r\n}\r\n} else {\r\noutb(0, EWRK3_MPR);\r\nmemcpy_fromio(tmp->addr, lp->shmem + PAGE0_HTE, (HASH_TABLE_LEN >> 3));\r\n}\r\nspin_unlock_irqrestore(&lp->hw_lock, flags);\r\nioc->len = (HASH_TABLE_LEN >> 3);\r\nif (copy_to_user(ioc->data, tmp->addr, ioc->len))\r\nstatus = -EFAULT;\r\nbreak;\r\ncase EWRK3_SET_MCA:\r\nif (capable(CAP_NET_ADMIN)) {\r\nif (ioc->len > HASH_TABLE_LEN) {\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nif (copy_from_user(tmp->addr, ioc->data, ETH_ALEN * ioc->len)) {\r\nstatus = -EFAULT;\r\nbreak;\r\n}\r\nset_multicast_list(dev);\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nbreak;\r\ncase EWRK3_CLR_MCA:\r\nif (capable(CAP_NET_ADMIN)) {\r\nset_multicast_list(dev);\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nbreak;\r\ncase EWRK3_MCA_EN:\r\nif (capable(CAP_NET_ADMIN)) {\r\nspin_lock_irqsave(&lp->hw_lock, flags);\r\ncsr = inb(EWRK3_CSR);\r\ncsr |= CSR_MCE;\r\ncsr &= ~CSR_PME;\r\noutb(csr, EWRK3_CSR);\r\nspin_unlock_irqrestore(&lp->hw_lock, flags);\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nbreak;\r\ncase EWRK3_GET_STATS: {\r\nstruct ewrk3_stats *tmp_stats =\r\nkmalloc(sizeof(lp->pktStats), GFP_KERNEL);\r\nif (!tmp_stats) {\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&lp->hw_lock, flags);\r\nmemcpy(tmp_stats, &lp->pktStats, sizeof(lp->pktStats));\r\nspin_unlock_irqrestore(&lp->hw_lock, flags);\r\nioc->len = sizeof(lp->pktStats);\r\nif (copy_to_user(ioc->data, tmp_stats, sizeof(lp->pktStats)))\r\nstatus = -EFAULT;\r\nkfree(tmp_stats);\r\nbreak;\r\n}\r\ncase EWRK3_CLR_STATS:\r\nif (capable(CAP_NET_ADMIN)) {\r\nspin_lock_irqsave(&lp->hw_lock, flags);\r\nmemset(&lp->pktStats, 0, sizeof(lp->pktStats));\r\nspin_unlock_irqrestore(&lp->hw_lock,flags);\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nbreak;\r\ncase EWRK3_GET_CSR:\r\ntmp->addr[0] = inb(EWRK3_CSR);\r\nioc->len = 1;\r\nif (copy_to_user(ioc->data, tmp->addr, ioc->len))\r\nstatus = -EFAULT;\r\nbreak;\r\ncase EWRK3_SET_CSR:\r\nif (capable(CAP_NET_ADMIN)) {\r\nif (copy_from_user(tmp->addr, ioc->data, 1)) {\r\nstatus = -EFAULT;\r\nbreak;\r\n}\r\noutb(tmp->addr[0], EWRK3_CSR);\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nbreak;\r\ncase EWRK3_GET_EEPROM:\r\nif (capable(CAP_NET_ADMIN)) {\r\nfor (i = 0; i < (EEPROM_MAX >> 1); i++) {\r\ntmp->val[i] = (short) Read_EEPROM(iobase, i);\r\n}\r\ni = EEPROM_MAX;\r\ntmp->addr[i++] = inb(EWRK3_CMR);\r\nfor (j = 0; j < ETH_ALEN; j++) {\r\ntmp->addr[i++] = inb(EWRK3_PAR0 + j);\r\n}\r\nioc->len = EEPROM_MAX + 1 + ETH_ALEN;\r\nif (copy_to_user(ioc->data, tmp->addr, ioc->len))\r\nstatus = -EFAULT;\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nbreak;\r\ncase EWRK3_SET_EEPROM:\r\nif (capable(CAP_NET_ADMIN)) {\r\nif (copy_from_user(tmp->addr, ioc->data, EEPROM_MAX)) {\r\nstatus = -EFAULT;\r\nbreak;\r\n}\r\nfor (i = 0; i < (EEPROM_MAX >> 1); i++) {\r\nWrite_EEPROM(tmp->val[i], iobase, i);\r\n}\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nbreak;\r\ncase EWRK3_GET_CMR:\r\ntmp->addr[0] = inb(EWRK3_CMR);\r\nioc->len = 1;\r\nif (copy_to_user(ioc->data, tmp->addr, ioc->len))\r\nstatus = -EFAULT;\r\nbreak;\r\ncase EWRK3_SET_TX_CUT_THRU:\r\nif (capable(CAP_NET_ADMIN)) {\r\nlp->txc = 1;\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nbreak;\r\ncase EWRK3_CLR_TX_CUT_THRU:\r\nif (capable(CAP_NET_ADMIN)) {\r\nlp->txc = 0;\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nbreak;\r\ndefault:\r\nstatus = -EOPNOTSUPP;\r\n}\r\nkfree(tmp);\r\nreturn status;\r\n}\r\nstatic __exit void ewrk3_exit_module(void)\r\n{\r\nint i;\r\nfor( i=0; i<ndevs; i++ ) {\r\nstruct net_device *dev = ewrk3_devs[i];\r\nstruct ewrk3_private *lp = netdev_priv(dev);\r\newrk3_devs[i] = NULL;\r\nunregister_netdev(dev);\r\nrelease_region(dev->base_addr, EWRK3_TOTAL_SIZE);\r\niounmap(lp->shmem);\r\nfree_netdev(dev);\r\n}\r\n}\r\nstatic __init int ewrk3_init_module(void)\r\n{\r\nint i=0;\r\nwhile( io[i] && irq[i] ) {\r\nstruct net_device *dev\r\n= alloc_etherdev(sizeof(struct ewrk3_private));\r\nif (!dev)\r\nbreak;\r\nif (ewrk3_probe1(dev, io[i], irq[i]) != 0) {\r\nfree_netdev(dev);\r\nbreak;\r\n}\r\newrk3_devs[ndevs++] = dev;\r\ni++;\r\n}\r\nreturn ndevs ? 0 : -EIO;\r\n}
