u32 davinci_vc_read(struct davinci_vc *davinci_vc, int reg)\r\n{\r\nreturn __raw_readl(davinci_vc->base + reg);\r\n}\r\nvoid davinci_vc_write(struct davinci_vc *davinci_vc,\r\nint reg, u32 val)\r\n{\r\n__raw_writel(val, davinci_vc->base + reg);\r\n}\r\nstatic int __init davinci_vc_probe(struct platform_device *pdev)\r\n{\r\nstruct davinci_vc *davinci_vc;\r\nstruct resource *res, *mem;\r\nstruct mfd_cell *cell = NULL;\r\nint ret;\r\ndavinci_vc = kzalloc(sizeof(struct davinci_vc), GFP_KERNEL);\r\nif (!davinci_vc) {\r\ndev_dbg(&pdev->dev,\r\n"could not allocate memory for private data\n");\r\nreturn -ENOMEM;\r\n}\r\ndavinci_vc->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(davinci_vc->clk)) {\r\ndev_dbg(&pdev->dev,\r\n"could not get the clock for voice codec\n");\r\nret = -ENODEV;\r\ngoto fail1;\r\n}\r\nclk_enable(davinci_vc->clk);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no mem resource\n");\r\nret = -ENODEV;\r\ngoto fail2;\r\n}\r\ndavinci_vc->pbase = res->start;\r\ndavinci_vc->base_size = resource_size(res);\r\nmem = request_mem_region(davinci_vc->pbase, davinci_vc->base_size,\r\npdev->name);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "VCIF region already claimed\n");\r\nret = -EBUSY;\r\ngoto fail2;\r\n}\r\ndavinci_vc->base = ioremap(davinci_vc->pbase, davinci_vc->base_size);\r\nif (!davinci_vc->base) {\r\ndev_err(&pdev->dev, "can't ioremap mem resource.\n");\r\nret = -ENOMEM;\r\ngoto fail3;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no DMA resource\n");\r\nret = -ENXIO;\r\ngoto fail4;\r\n}\r\ndavinci_vc->davinci_vcif.dma_tx_channel = res->start;\r\ndavinci_vc->davinci_vcif.dma_tx_addr =\r\n(dma_addr_t)(io_v2p(davinci_vc->base) + DAVINCI_VC_WFIFO);\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no DMA resource\n");\r\nret = -ENXIO;\r\ngoto fail4;\r\n}\r\ndavinci_vc->davinci_vcif.dma_rx_channel = res->start;\r\ndavinci_vc->davinci_vcif.dma_rx_addr =\r\n(dma_addr_t)(io_v2p(davinci_vc->base) + DAVINCI_VC_RFIFO);\r\ndavinci_vc->dev = &pdev->dev;\r\ndavinci_vc->pdev = pdev;\r\ncell = &davinci_vc->cells[DAVINCI_VC_VCIF_CELL];\r\ncell->name = "davinci-vcif";\r\ncell->platform_data = davinci_vc;\r\ncell->pdata_size = sizeof(*davinci_vc);\r\ncell = &davinci_vc->cells[DAVINCI_VC_CQ93VC_CELL];\r\ncell->name = "cq93vc-codec";\r\ncell->platform_data = davinci_vc;\r\ncell->pdata_size = sizeof(*davinci_vc);\r\nret = mfd_add_devices(&pdev->dev, pdev->id, davinci_vc->cells,\r\nDAVINCI_VC_CELLS, NULL, 0);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "fail to register client devices\n");\r\ngoto fail4;\r\n}\r\nreturn 0;\r\nfail4:\r\niounmap(davinci_vc->base);\r\nfail3:\r\nrelease_mem_region(davinci_vc->pbase, davinci_vc->base_size);\r\nfail2:\r\nclk_disable(davinci_vc->clk);\r\nclk_put(davinci_vc->clk);\r\ndavinci_vc->clk = NULL;\r\nfail1:\r\nkfree(davinci_vc);\r\nreturn ret;\r\n}\r\nstatic int __devexit davinci_vc_remove(struct platform_device *pdev)\r\n{\r\nstruct davinci_vc *davinci_vc = platform_get_drvdata(pdev);\r\nmfd_remove_devices(&pdev->dev);\r\niounmap(davinci_vc->base);\r\nrelease_mem_region(davinci_vc->pbase, davinci_vc->base_size);\r\nclk_disable(davinci_vc->clk);\r\nclk_put(davinci_vc->clk);\r\ndavinci_vc->clk = NULL;\r\nkfree(davinci_vc);\r\nreturn 0;\r\n}\r\nstatic int __init davinci_vc_init(void)\r\n{\r\nreturn platform_driver_probe(&davinci_vc_driver, davinci_vc_probe);\r\n}\r\nstatic void __exit davinci_vc_exit(void)\r\n{\r\nplatform_driver_unregister(&davinci_vc_driver);\r\n}
