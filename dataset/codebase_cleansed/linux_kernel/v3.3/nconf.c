static void print_function_line(void)\r\n{\r\nint i;\r\nint offset = 1;\r\nconst int skip = 1;\r\nfor (i = 0; i < function_keys_num; i++) {\r\n(void) wattrset(main_window, attributes[FUNCTION_HIGHLIGHT]);\r\nmvwprintw(main_window, LINES-3, offset,\r\n"%s",\r\nfunction_keys[i].key_str);\r\n(void) wattrset(main_window, attributes[FUNCTION_TEXT]);\r\noffset += strlen(function_keys[i].key_str);\r\nmvwprintw(main_window, LINES-3,\r\noffset, "%s",\r\nfunction_keys[i].func);\r\noffset += strlen(function_keys[i].func) + skip;\r\n}\r\n(void) wattrset(main_window, attributes[NORMAL]);\r\n}\r\nstatic void handle_f1(int *key, struct menu *current_item)\r\n{\r\nshow_scroll_win(main_window,\r\n_("README"), _(nconf_readme));\r\nreturn;\r\n}\r\nstatic void handle_f2(int *key, struct menu *current_item)\r\n{\r\nshow_help(current_item);\r\nreturn;\r\n}\r\nstatic void handle_f3(int *key, struct menu *current_item)\r\n{\r\nshow_scroll_win(main_window,\r\n_("Instructions"),\r\n_(current_instructions));\r\nreturn;\r\n}\r\nstatic void handle_f4(int *key, struct menu *current_item)\r\n{\r\nint res = btn_dialog(main_window,\r\n_("Show all symbols?"),\r\n2,\r\n" <Show All> ",\r\n"<Don't show all>");\r\nif (res == 0)\r\nshow_all_items = 1;\r\nelse if (res == 1)\r\nshow_all_items = 0;\r\nreturn;\r\n}\r\nstatic void handle_f5(int *key, struct menu *current_item)\r\n{\r\n*key = KEY_LEFT;\r\nreturn;\r\n}\r\nstatic void handle_f6(int *key, struct menu *current_item)\r\n{\r\nconf_save();\r\nreturn;\r\n}\r\nstatic void handle_f7(int *key, struct menu *current_item)\r\n{\r\nconf_load();\r\nreturn;\r\n}\r\nstatic void handle_f8(int *key, struct menu *current_item)\r\n{\r\nsearch_conf();\r\nreturn;\r\n}\r\nstatic void handle_f9(int *key, struct menu *current_item)\r\n{\r\ndo_exit();\r\nreturn;\r\n}\r\nstatic int process_special_keys(int *key, struct menu *menu)\r\n{\r\nint i;\r\nif (*key == KEY_RESIZE) {\r\nsetup_windows();\r\nreturn 1;\r\n}\r\nfor (i = 0; i < function_keys_num; i++) {\r\nif (*key == KEY_F(function_keys[i].key) ||\r\n*key == '0' + function_keys[i].key){\r\nfunction_keys[i].handler(key, menu);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void clean_items(void)\r\n{\r\nint i;\r\nfor (i = 0; curses_menu_items[i]; i++)\r\nfree_item(curses_menu_items[i]);\r\nbzero(curses_menu_items, sizeof(curses_menu_items));\r\nbzero(k_menu_items, sizeof(k_menu_items));\r\nitems_num = 0;\r\n}\r\nstatic int get_mext_match(const char *match_str, match_f flag)\r\n{\r\nint match_start = item_index(current_item(curses_menu));\r\nint index;\r\nif (flag == FIND_NEXT_MATCH_DOWN)\r\n++match_start;\r\nelse if (flag == FIND_NEXT_MATCH_UP)\r\n--match_start;\r\nindex = match_start;\r\nindex = (index + items_num) % items_num;\r\nwhile (true) {\r\nchar *str = k_menu_items[index].str;\r\nif (strcasestr(str, match_str) != 0)\r\nreturn index;\r\nif (flag == FIND_NEXT_MATCH_UP ||\r\nflag == MATCH_TINKER_PATTERN_UP)\r\n--index;\r\nelse\r\n++index;\r\nindex = (index + items_num) % items_num;\r\nif (index == match_start)\r\nreturn -1;\r\n}\r\n}\r\nstatic void item_make(struct menu *menu, char tag, const char *fmt, ...)\r\n{\r\nva_list ap;\r\nif (items_num > MAX_MENU_ITEMS-1)\r\nreturn;\r\nbzero(&k_menu_items[items_num], sizeof(k_menu_items[0]));\r\nk_menu_items[items_num].tag = tag;\r\nk_menu_items[items_num].usrptr = menu;\r\nif (menu != NULL)\r\nk_menu_items[items_num].is_visible =\r\nmenu_is_visible(menu);\r\nelse\r\nk_menu_items[items_num].is_visible = 1;\r\nva_start(ap, fmt);\r\nvsnprintf(k_menu_items[items_num].str,\r\nsizeof(k_menu_items[items_num].str),\r\nfmt, ap);\r\nva_end(ap);\r\nif (!k_menu_items[items_num].is_visible)\r\nmemcpy(k_menu_items[items_num].str, "XXX", 3);\r\ncurses_menu_items[items_num] = new_item(\r\nk_menu_items[items_num].str,\r\nk_menu_items[items_num].str);\r\nset_item_userptr(curses_menu_items[items_num],\r\n&k_menu_items[items_num]);\r\nitems_num++;\r\ncurses_menu_items[items_num] = NULL;\r\n}\r\nstatic void item_add_str(const char *fmt, ...)\r\n{\r\nva_list ap;\r\nint index = items_num-1;\r\nchar new_str[256];\r\nchar tmp_str[256];\r\nif (index < 0)\r\nreturn;\r\nva_start(ap, fmt);\r\nvsnprintf(new_str, sizeof(new_str), fmt, ap);\r\nva_end(ap);\r\nsnprintf(tmp_str, sizeof(tmp_str), "%s%s",\r\nk_menu_items[index].str, new_str);\r\nstrncpy(k_menu_items[index].str,\r\ntmp_str,\r\nsizeof(k_menu_items[index].str));\r\nfree_item(curses_menu_items[index]);\r\ncurses_menu_items[index] = new_item(\r\nk_menu_items[index].str,\r\nk_menu_items[index].str);\r\nset_item_userptr(curses_menu_items[index],\r\n&k_menu_items[index]);\r\n}\r\nstatic char item_tag(void)\r\n{\r\nITEM *cur;\r\nstruct mitem *mcur;\r\ncur = current_item(curses_menu);\r\nif (cur == NULL)\r\nreturn 0;\r\nmcur = (struct mitem *) item_userptr(cur);\r\nreturn mcur->tag;\r\n}\r\nstatic int curses_item_index(void)\r\n{\r\nreturn item_index(current_item(curses_menu));\r\n}\r\nstatic void *item_data(void)\r\n{\r\nITEM *cur;\r\nstruct mitem *mcur;\r\ncur = current_item(curses_menu);\r\nif (!cur)\r\nreturn NULL;\r\nmcur = (struct mitem *) item_userptr(cur);\r\nreturn mcur->usrptr;\r\n}\r\nstatic int item_is_tag(char tag)\r\n{\r\nreturn item_tag() == tag;\r\n}\r\nstatic const char *set_config_filename(const char *config_filename)\r\n{\r\nint size;\r\nsize = snprintf(menu_backtitle, sizeof(menu_backtitle),\r\n"%s - %s", config_filename, rootmenu.prompt->text);\r\nif (size >= sizeof(menu_backtitle))\r\nmenu_backtitle[sizeof(menu_backtitle)-1] = '\0';\r\nsize = snprintf(filename, sizeof(filename), "%s", config_filename);\r\nif (size >= sizeof(filename))\r\nfilename[sizeof(filename)-1] = '\0';\r\nreturn menu_backtitle;\r\n}\r\nstatic int do_exit(void)\r\n{\r\nint res;\r\nif (!conf_get_changed()) {\r\nglobal_exit = 1;\r\nreturn 0;\r\n}\r\nres = btn_dialog(main_window,\r\n_("Do you wish to save your new configuration?\n"\r\n"<ESC> to cancel and resume nconfig."),\r\n2,\r\n" <save> ",\r\n"<don't save>");\r\nif (res == KEY_EXIT) {\r\nglobal_exit = 0;\r\nreturn -1;\r\n}\r\nswitch (res) {\r\ncase 0:\r\nres = conf_write(filename);\r\nif (res)\r\nbtn_dialog(\r\nmain_window,\r\n_("Error during writing of configuration.\n"\r\n"Your configuration changes were NOT saved."),\r\n1,\r\n"<OK>");\r\nbreak;\r\ndefault:\r\nbtn_dialog(\r\nmain_window,\r\n_("Your configuration changes were NOT saved."),\r\n1,\r\n"<OK>");\r\nbreak;\r\n}\r\nglobal_exit = 1;\r\nreturn 0;\r\n}\r\nstatic void search_conf(void)\r\n{\r\nstruct symbol **sym_arr;\r\nstruct gstr res;\r\nchar *dialog_input;\r\nint dres;\r\nagain:\r\ndres = dialog_inputbox(main_window,\r\n_("Search Configuration Parameter"),\r\n_("Enter " CONFIG_ " (sub)string to search for "\r\n"(with or without \"" CONFIG_ "\")"),\r\n"", &dialog_input_result, &dialog_input_result_len);\r\nswitch (dres) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nshow_scroll_win(main_window,\r\n_("Search Configuration"), search_help);\r\ngoto again;\r\ndefault:\r\nreturn;\r\n}\r\ndialog_input = dialog_input_result;\r\nif (strncasecmp(dialog_input_result, CONFIG_, strlen(CONFIG_)) == 0)\r\ndialog_input += strlen(CONFIG_);\r\nsym_arr = sym_re_search(dialog_input);\r\nres = get_relations_str(sym_arr);\r\nfree(sym_arr);\r\nshow_scroll_win(main_window,\r\n_("Search Results"), str_get(&res));\r\nstr_free(&res);\r\n}\r\nstatic void build_conf(struct menu *menu)\r\n{\r\nstruct symbol *sym;\r\nstruct property *prop;\r\nstruct menu *child;\r\nint type, tmp, doint = 2;\r\ntristate val;\r\nchar ch;\r\nif (!menu || (!show_all_items && !menu_is_visible(menu)))\r\nreturn;\r\nsym = menu->sym;\r\nprop = menu->prompt;\r\nif (!sym) {\r\nif (prop && menu != current_menu) {\r\nconst char *prompt = menu_get_prompt(menu);\r\nenum prop_type ptype;\r\nptype = menu->prompt ? menu->prompt->type : P_UNKNOWN;\r\nswitch (ptype) {\r\ncase P_MENU:\r\nchild_count++;\r\nprompt = _(prompt);\r\nif (single_menu_mode) {\r\nitem_make(menu, 'm',\r\n"%s%*c%s",\r\nmenu->data ? "-->" : "++>",\r\nindent + 1, ' ', prompt);\r\n} else\r\nitem_make(menu, 'm',\r\n" %*c%s --->",\r\nindent + 1,\r\n' ', prompt);\r\nif (single_menu_mode && menu->data)\r\ngoto conf_childs;\r\nreturn;\r\ncase P_COMMENT:\r\nif (prompt) {\r\nchild_count++;\r\nitem_make(menu, ':',\r\n" %*c*** %s ***",\r\nindent + 1, ' ',\r\n_(prompt));\r\n}\r\nbreak;\r\ndefault:\r\nif (prompt) {\r\nchild_count++;\r\nitem_make(menu, ':', "---%*c%s",\r\nindent + 1, ' ',\r\n_(prompt));\r\n}\r\n}\r\n} else\r\ndoint = 0;\r\ngoto conf_childs;\r\n}\r\ntype = sym_get_type(sym);\r\nif (sym_is_choice(sym)) {\r\nstruct symbol *def_sym = sym_get_choice_value(sym);\r\nstruct menu *def_menu = NULL;\r\nchild_count++;\r\nfor (child = menu->list; child; child = child->next) {\r\nif (menu_is_visible(child) && child->sym == def_sym)\r\ndef_menu = child;\r\n}\r\nval = sym_get_tristate_value(sym);\r\nif (sym_is_changable(sym)) {\r\nswitch (type) {\r\ncase S_BOOLEAN:\r\nitem_make(menu, 't', "[%c]",\r\nval == no ? ' ' : '*');\r\nbreak;\r\ncase S_TRISTATE:\r\nswitch (val) {\r\ncase yes:\r\nch = '*';\r\nbreak;\r\ncase mod:\r\nch = 'M';\r\nbreak;\r\ndefault:\r\nch = ' ';\r\nbreak;\r\n}\r\nitem_make(menu, 't', "<%c>", ch);\r\nbreak;\r\n}\r\n} else {\r\nitem_make(menu, def_menu ? 't' : ':', " ");\r\n}\r\nitem_add_str("%*c%s", indent + 1,\r\n' ', _(menu_get_prompt(menu)));\r\nif (val == yes) {\r\nif (def_menu) {\r\nitem_add_str(" (%s)",\r\n_(menu_get_prompt(def_menu)));\r\nitem_add_str(" --->");\r\nif (def_menu->list) {\r\nindent += 2;\r\nbuild_conf(def_menu);\r\nindent -= 2;\r\n}\r\n}\r\nreturn;\r\n}\r\n} else {\r\nif (menu == current_menu) {\r\nitem_make(menu, ':',\r\n"---%*c%s", indent + 1,\r\n' ', _(menu_get_prompt(menu)));\r\ngoto conf_childs;\r\n}\r\nchild_count++;\r\nval = sym_get_tristate_value(sym);\r\nif (sym_is_choice_value(sym) && val == yes) {\r\nitem_make(menu, ':', " ");\r\n} else {\r\nswitch (type) {\r\ncase S_BOOLEAN:\r\nif (sym_is_changable(sym))\r\nitem_make(menu, 't', "[%c]",\r\nval == no ? ' ' : '*');\r\nelse\r\nitem_make(menu, 't', "-%c-",\r\nval == no ? ' ' : '*');\r\nbreak;\r\ncase S_TRISTATE:\r\nswitch (val) {\r\ncase yes:\r\nch = '*';\r\nbreak;\r\ncase mod:\r\nch = 'M';\r\nbreak;\r\ndefault:\r\nch = ' ';\r\nbreak;\r\n}\r\nif (sym_is_changable(sym)) {\r\nif (sym->rev_dep.tri == mod)\r\nitem_make(menu,\r\n't', "{%c}", ch);\r\nelse\r\nitem_make(menu,\r\n't', "<%c>", ch);\r\n} else\r\nitem_make(menu, 't', "-%c-", ch);\r\nbreak;\r\ndefault:\r\ntmp = 2 + strlen(sym_get_string_value(sym));\r\nitem_make(menu, 's', " (%s)",\r\nsym_get_string_value(sym));\r\ntmp = indent - tmp + 4;\r\nif (tmp < 0)\r\ntmp = 0;\r\nitem_add_str("%*c%s%s", tmp, ' ',\r\n_(menu_get_prompt(menu)),\r\n(sym_has_value(sym) ||\r\n!sym_is_changable(sym)) ? "" :\r\n_(" (NEW)"));\r\ngoto conf_childs;\r\n}\r\n}\r\nitem_add_str("%*c%s%s", indent + 1, ' ',\r\n_(menu_get_prompt(menu)),\r\n(sym_has_value(sym) || !sym_is_changable(sym)) ?\r\n"" : _(" (NEW)"));\r\nif (menu->prompt && menu->prompt->type == P_MENU) {\r\nitem_add_str(" --->");\r\nreturn;\r\n}\r\n}\r\nconf_childs:\r\nindent += doint;\r\nfor (child = menu->list; child; child = child->next)\r\nbuild_conf(child);\r\nindent -= doint;\r\n}\r\nstatic void reset_menu(void)\r\n{\r\nunpost_menu(curses_menu);\r\nclean_items();\r\n}\r\nstatic void center_item(int selected_index, int *last_top_row)\r\n{\r\nint toprow;\r\nset_top_row(curses_menu, *last_top_row);\r\ntoprow = top_row(curses_menu);\r\nif (selected_index < toprow ||\r\nselected_index >= toprow+mwin_max_lines) {\r\ntoprow = max(selected_index-mwin_max_lines/2, 0);\r\nif (toprow >= item_count(curses_menu)-mwin_max_lines)\r\ntoprow = item_count(curses_menu)-mwin_max_lines;\r\nset_top_row(curses_menu, toprow);\r\n}\r\nset_current_item(curses_menu,\r\ncurses_menu_items[selected_index]);\r\n*last_top_row = toprow;\r\npost_menu(curses_menu);\r\nrefresh_all_windows(main_window);\r\n}\r\nstatic void show_menu(const char *prompt, const char *instructions,\r\nint selected_index, int *last_top_row)\r\n{\r\nint maxx, maxy;\r\nWINDOW *menu_window;\r\ncurrent_instructions = instructions;\r\nclear();\r\n(void) wattrset(main_window, attributes[NORMAL]);\r\nprint_in_middle(stdscr, 1, 0, COLS,\r\nmenu_backtitle,\r\nattributes[MAIN_HEADING]);\r\n(void) wattrset(main_window, attributes[MAIN_MENU_BOX]);\r\nbox(main_window, 0, 0);\r\n(void) wattrset(main_window, attributes[MAIN_MENU_HEADING]);\r\nmvwprintw(main_window, 0, 3, " %s ", prompt);\r\n(void) wattrset(main_window, attributes[NORMAL]);\r\nset_menu_items(curses_menu, curses_menu_items);\r\nscale_menu(curses_menu, &maxy, &maxx);\r\nmaxx = min(maxx, mwin_max_cols-2);\r\nmaxy = mwin_max_lines;\r\nmenu_window = derwin(main_window,\r\nmaxy,\r\nmaxx,\r\n2,\r\n(mwin_max_cols-maxx)/2);\r\nkeypad(menu_window, TRUE);\r\nset_menu_win(curses_menu, menu_window);\r\nset_menu_sub(curses_menu, menu_window);\r\nset_menu_format(curses_menu, maxy, 1);\r\ncenter_item(selected_index, last_top_row);\r\nset_menu_format(curses_menu, maxy, 1);\r\nprint_function_line();\r\npost_menu(curses_menu);\r\nrefresh_all_windows(main_window);\r\n}\r\nstatic void adj_match_dir(match_f *match_direction)\r\n{\r\nif (*match_direction == FIND_NEXT_MATCH_DOWN)\r\n*match_direction =\r\nMATCH_TINKER_PATTERN_DOWN;\r\nelse if (*match_direction == FIND_NEXT_MATCH_UP)\r\n*match_direction =\r\nMATCH_TINKER_PATTERN_UP;\r\n}\r\nstatic int do_match(int key, struct match_state *state, int *ans)\r\n{\r\nchar c = (char) key;\r\nint terminate_search = 0;\r\n*ans = -1;\r\nif (key == '/' || (state->in_search && key == 27)) {\r\nmove(0, 0);\r\nrefresh();\r\nclrtoeol();\r\nstate->in_search = 1-state->in_search;\r\nbzero(state->pattern, sizeof(state->pattern));\r\nstate->match_direction = MATCH_TINKER_PATTERN_DOWN;\r\nreturn 0;\r\n} else if (!state->in_search)\r\nreturn 1;\r\nif (isalnum(c) || isgraph(c) || c == ' ') {\r\nstate->pattern[strlen(state->pattern)] = c;\r\nstate->pattern[strlen(state->pattern)] = '\0';\r\nadj_match_dir(&state->match_direction);\r\n*ans = get_mext_match(state->pattern,\r\nstate->match_direction);\r\n} else if (key == KEY_DOWN) {\r\nstate->match_direction = FIND_NEXT_MATCH_DOWN;\r\n*ans = get_mext_match(state->pattern,\r\nstate->match_direction);\r\n} else if (key == KEY_UP) {\r\nstate->match_direction = FIND_NEXT_MATCH_UP;\r\n*ans = get_mext_match(state->pattern,\r\nstate->match_direction);\r\n} else if (key == KEY_BACKSPACE || key == 127) {\r\nstate->pattern[strlen(state->pattern)-1] = '\0';\r\nadj_match_dir(&state->match_direction);\r\n} else\r\nterminate_search = 1;\r\nif (terminate_search) {\r\nstate->in_search = 0;\r\nbzero(state->pattern, sizeof(state->pattern));\r\nmove(0, 0);\r\nrefresh();\r\nclrtoeol();\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void conf(struct menu *menu)\r\n{\r\nstruct menu *submenu = 0;\r\nconst char *prompt = menu_get_prompt(menu);\r\nstruct symbol *sym;\r\nint res;\r\nint current_index = 0;\r\nint last_top_row = 0;\r\nstruct match_state match_state = {\r\n.in_search = 0,\r\n.match_direction = MATCH_TINKER_PATTERN_DOWN,\r\n.pattern = "",\r\n};\r\nwhile (!global_exit) {\r\nreset_menu();\r\ncurrent_menu = menu;\r\nbuild_conf(menu);\r\nif (!child_count)\r\nbreak;\r\nshow_menu(prompt ? _(prompt) : _("Main Menu"),\r\n_(menu_instructions),\r\ncurrent_index, &last_top_row);\r\nkeypad((menu_win(curses_menu)), TRUE);\r\nwhile (!global_exit) {\r\nif (match_state.in_search) {\r\nmvprintw(0, 0,\r\n"searching: %s", match_state.pattern);\r\nclrtoeol();\r\n}\r\nrefresh_all_windows(main_window);\r\nres = wgetch(menu_win(curses_menu));\r\nif (!res)\r\nbreak;\r\nif (do_match(res, &match_state, &current_index) == 0) {\r\nif (current_index != -1)\r\ncenter_item(current_index,\r\n&last_top_row);\r\ncontinue;\r\n}\r\nif (process_special_keys(&res,\r\n(struct menu *) item_data()))\r\nbreak;\r\nswitch (res) {\r\ncase KEY_DOWN:\r\nmenu_driver(curses_menu, REQ_DOWN_ITEM);\r\nbreak;\r\ncase KEY_UP:\r\nmenu_driver(curses_menu, REQ_UP_ITEM);\r\nbreak;\r\ncase KEY_NPAGE:\r\nmenu_driver(curses_menu, REQ_SCR_DPAGE);\r\nbreak;\r\ncase KEY_PPAGE:\r\nmenu_driver(curses_menu, REQ_SCR_UPAGE);\r\nbreak;\r\ncase KEY_HOME:\r\nmenu_driver(curses_menu, REQ_FIRST_ITEM);\r\nbreak;\r\ncase KEY_END:\r\nmenu_driver(curses_menu, REQ_LAST_ITEM);\r\nbreak;\r\ncase 'h':\r\ncase '?':\r\nshow_help((struct menu *) item_data());\r\nbreak;\r\n}\r\nif (res == 10 || res == 27 ||\r\nres == 32 || res == 'n' || res == 'y' ||\r\nres == KEY_LEFT || res == KEY_RIGHT ||\r\nres == 'm')\r\nbreak;\r\nrefresh_all_windows(main_window);\r\n}\r\nrefresh_all_windows(main_window);\r\nif (res == 27 || (menu != &rootmenu && res == KEY_LEFT))\r\nbreak;\r\nlast_top_row = top_row(curses_menu);\r\ncurrent_index = curses_item_index();\r\nif (!item_tag())\r\ncontinue;\r\nsubmenu = (struct menu *) item_data();\r\nif (!submenu || !menu_is_visible(submenu))\r\ncontinue;\r\nsym = submenu->sym;\r\nswitch (res) {\r\ncase ' ':\r\nif (item_is_tag('t'))\r\nsym_toggle_tristate_value(sym);\r\nelse if (item_is_tag('m'))\r\nconf(submenu);\r\nbreak;\r\ncase KEY_RIGHT:\r\ncase 10:\r\nswitch (item_tag()) {\r\ncase 'm':\r\nif (single_menu_mode)\r\nsubmenu->data =\r\n(void *) (long) !submenu->data;\r\nelse\r\nconf(submenu);\r\nbreak;\r\ncase 't':\r\nif (sym_is_choice(sym) &&\r\nsym_get_tristate_value(sym) == yes)\r\nconf_choice(submenu);\r\nelse if (submenu->prompt &&\r\nsubmenu->prompt->type == P_MENU)\r\nconf(submenu);\r\nelse if (res == 10)\r\nsym_toggle_tristate_value(sym);\r\nbreak;\r\ncase 's':\r\nconf_string(submenu);\r\nbreak;\r\n}\r\nbreak;\r\ncase 'y':\r\nif (item_is_tag('t')) {\r\nif (sym_set_tristate_value(sym, yes))\r\nbreak;\r\nif (sym_set_tristate_value(sym, mod))\r\nbtn_dialog(main_window, setmod_text, 0);\r\n}\r\nbreak;\r\ncase 'n':\r\nif (item_is_tag('t'))\r\nsym_set_tristate_value(sym, no);\r\nbreak;\r\ncase 'm':\r\nif (item_is_tag('t'))\r\nsym_set_tristate_value(sym, mod);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void conf_message_callback(const char *fmt, va_list ap)\r\n{\r\nchar buf[1024];\r\nvsnprintf(buf, sizeof(buf), fmt, ap);\r\nbtn_dialog(main_window, buf, 1, "<OK>");\r\n}\r\nstatic void show_help(struct menu *menu)\r\n{\r\nstruct gstr help;\r\nif (!menu)\r\nreturn;\r\nhelp = str_new();\r\nmenu_get_ext_help(menu, &help);\r\nshow_scroll_win(main_window, _(menu_get_prompt(menu)), str_get(&help));\r\nstr_free(&help);\r\n}\r\nstatic void conf_choice(struct menu *menu)\r\n{\r\nconst char *prompt = _(menu_get_prompt(menu));\r\nstruct menu *child = 0;\r\nstruct symbol *active;\r\nint selected_index = 0;\r\nint last_top_row = 0;\r\nint res, i = 0;\r\nstruct match_state match_state = {\r\n.in_search = 0,\r\n.match_direction = MATCH_TINKER_PATTERN_DOWN,\r\n.pattern = "",\r\n};\r\nactive = sym_get_choice_value(menu->sym);\r\nwhile (!global_exit) {\r\nreset_menu();\r\nfor (i = 0, child = menu->list; child; child = child->next) {\r\nif (!show_all_items && !menu_is_visible(child))\r\ncontinue;\r\nif (child->sym == sym_get_choice_value(menu->sym))\r\nitem_make(child, ':', "<X> %s",\r\n_(menu_get_prompt(child)));\r\nelse if (child->sym)\r\nitem_make(child, ':', " %s",\r\n_(menu_get_prompt(child)));\r\nelse\r\nitem_make(child, ':', "*** %s ***",\r\n_(menu_get_prompt(child)));\r\nif (child->sym == active){\r\nlast_top_row = top_row(curses_menu);\r\nselected_index = i;\r\n}\r\ni++;\r\n}\r\nshow_menu(prompt ? _(prompt) : _("Choice Menu"),\r\n_(radiolist_instructions),\r\nselected_index,\r\n&last_top_row);\r\nwhile (!global_exit) {\r\nif (match_state.in_search) {\r\nmvprintw(0, 0, "searching: %s",\r\nmatch_state.pattern);\r\nclrtoeol();\r\n}\r\nrefresh_all_windows(main_window);\r\nres = wgetch(menu_win(curses_menu));\r\nif (!res)\r\nbreak;\r\nif (do_match(res, &match_state, &selected_index) == 0) {\r\nif (selected_index != -1)\r\ncenter_item(selected_index,\r\n&last_top_row);\r\ncontinue;\r\n}\r\nif (process_special_keys(\r\n&res,\r\n(struct menu *) item_data()))\r\nbreak;\r\nswitch (res) {\r\ncase KEY_DOWN:\r\nmenu_driver(curses_menu, REQ_DOWN_ITEM);\r\nbreak;\r\ncase KEY_UP:\r\nmenu_driver(curses_menu, REQ_UP_ITEM);\r\nbreak;\r\ncase KEY_NPAGE:\r\nmenu_driver(curses_menu, REQ_SCR_DPAGE);\r\nbreak;\r\ncase KEY_PPAGE:\r\nmenu_driver(curses_menu, REQ_SCR_UPAGE);\r\nbreak;\r\ncase KEY_HOME:\r\nmenu_driver(curses_menu, REQ_FIRST_ITEM);\r\nbreak;\r\ncase KEY_END:\r\nmenu_driver(curses_menu, REQ_LAST_ITEM);\r\nbreak;\r\ncase 'h':\r\ncase '?':\r\nshow_help((struct menu *) item_data());\r\nbreak;\r\n}\r\nif (res == 10 || res == 27 || res == ' ' ||\r\nres == KEY_LEFT){\r\nbreak;\r\n}\r\nrefresh_all_windows(main_window);\r\n}\r\nif (res == 27 || res == KEY_LEFT)\r\nbreak;\r\nchild = item_data();\r\nif (!child || !menu_is_visible(child) || !child->sym)\r\ncontinue;\r\nswitch (res) {\r\ncase ' ':\r\ncase 10:\r\ncase KEY_RIGHT:\r\nsym_set_tristate_value(child->sym, yes);\r\nreturn;\r\ncase 'h':\r\ncase '?':\r\nshow_help(child);\r\nactive = child->sym;\r\nbreak;\r\ncase KEY_EXIT:\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void conf_string(struct menu *menu)\r\n{\r\nconst char *prompt = menu_get_prompt(menu);\r\nwhile (1) {\r\nint res;\r\nconst char *heading;\r\nswitch (sym_get_type(menu->sym)) {\r\ncase S_INT:\r\nheading = _(inputbox_instructions_int);\r\nbreak;\r\ncase S_HEX:\r\nheading = _(inputbox_instructions_hex);\r\nbreak;\r\ncase S_STRING:\r\nheading = _(inputbox_instructions_string);\r\nbreak;\r\ndefault:\r\nheading = _("Internal nconf error!");\r\n}\r\nres = dialog_inputbox(main_window,\r\nprompt ? _(prompt) : _("Main Menu"),\r\nheading,\r\nsym_get_string_value(menu->sym),\r\n&dialog_input_result,\r\n&dialog_input_result_len);\r\nswitch (res) {\r\ncase 0:\r\nif (sym_set_string_value(menu->sym,\r\ndialog_input_result))\r\nreturn;\r\nbtn_dialog(main_window,\r\n_("You have made an invalid entry."), 0);\r\nbreak;\r\ncase 1:\r\nshow_help(menu);\r\nbreak;\r\ncase KEY_EXIT:\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void conf_load(void)\r\n{\r\nwhile (1) {\r\nint res;\r\nres = dialog_inputbox(main_window,\r\nNULL, load_config_text,\r\nfilename,\r\n&dialog_input_result,\r\n&dialog_input_result_len);\r\nswitch (res) {\r\ncase 0:\r\nif (!dialog_input_result[0])\r\nreturn;\r\nif (!conf_read(dialog_input_result)) {\r\nset_config_filename(dialog_input_result);\r\nsym_set_change_count(1);\r\nreturn;\r\n}\r\nbtn_dialog(main_window, _("File does not exist!"), 0);\r\nbreak;\r\ncase 1:\r\nshow_scroll_win(main_window,\r\n_("Load Alternate Configuration"),\r\nload_config_help);\r\nbreak;\r\ncase KEY_EXIT:\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void conf_save(void)\r\n{\r\nwhile (1) {\r\nint res;\r\nres = dialog_inputbox(main_window,\r\nNULL, save_config_text,\r\nfilename,\r\n&dialog_input_result,\r\n&dialog_input_result_len);\r\nswitch (res) {\r\ncase 0:\r\nif (!dialog_input_result[0])\r\nreturn;\r\nres = conf_write(dialog_input_result);\r\nif (!res) {\r\nset_config_filename(dialog_input_result);\r\nreturn;\r\n}\r\nbtn_dialog(main_window, _("Can't create file! "\r\n"Probably a nonexistent directory."),\r\n1, "<OK>");\r\nbreak;\r\ncase 1:\r\nshow_scroll_win(main_window,\r\n_("Save Alternate Configuration"),\r\nsave_config_help);\r\nbreak;\r\ncase KEY_EXIT:\r\nreturn;\r\n}\r\n}\r\n}\r\nvoid setup_windows(void)\r\n{\r\nif (main_window != NULL)\r\ndelwin(main_window);\r\nmain_window = newwin(LINES-2, COLS-2, 2, 1);\r\nkeypad(main_window, TRUE);\r\nmwin_max_lines = LINES-7;\r\nmwin_max_cols = COLS-6;\r\nnew_panel(main_window);\r\n}\r\nint main(int ac, char **av)\r\n{\r\nchar *mode;\r\nsetlocale(LC_ALL, "");\r\nbindtextdomain(PACKAGE, LOCALEDIR);\r\ntextdomain(PACKAGE);\r\nconf_parse(av[1]);\r\nconf_read(NULL);\r\nmode = getenv("NCONFIG_MODE");\r\nif (mode) {\r\nif (!strcasecmp(mode, "single_menu"))\r\nsingle_menu_mode = 1;\r\n}\r\ninitscr();\r\nset_colors();\r\ncbreak();\r\nnoecho();\r\nkeypad(stdscr, TRUE);\r\ncurs_set(0);\r\nif (COLS < 75 || LINES < 20) {\r\nendwin();\r\nprintf("Your terminal should have at "\r\n"least 20 lines and 75 columns\n");\r\nreturn 1;\r\n}\r\nnotimeout(stdscr, FALSE);\r\nESCDELAY = 1;\r\ncurses_menu = new_menu(curses_menu_items);\r\nmenu_opts_off(curses_menu, O_SHOWDESC);\r\nmenu_opts_on(curses_menu, O_SHOWMATCH);\r\nmenu_opts_on(curses_menu, O_ONEVALUE);\r\nmenu_opts_on(curses_menu, O_NONCYCLIC);\r\nmenu_opts_on(curses_menu, O_IGNORECASE);\r\nset_menu_mark(curses_menu, " ");\r\nset_menu_fore(curses_menu, attributes[MAIN_MENU_FORE]);\r\nset_menu_back(curses_menu, attributes[MAIN_MENU_BACK]);\r\nset_menu_grey(curses_menu, attributes[MAIN_MENU_GREY]);\r\nset_config_filename(conf_get_configname());\r\nsetup_windows();\r\nif (has_key(KEY_F(1)) == FALSE) {\r\nshow_scroll_win(main_window,\r\n_("Instructions"),\r\n_(menu_no_f_instructions));\r\n}\r\nconf_set_message_callback(conf_message_callback);\r\nwhile (!global_exit) {\r\nconf(&rootmenu);\r\nif (!global_exit && do_exit() == 0)\r\nbreak;\r\n}\r\nunpost_menu(curses_menu);\r\nfree_menu(curses_menu);\r\ndelwin(main_window);\r\nclear();\r\nrefresh();\r\nendwin();\r\nreturn 0;\r\n}
