static void crb_addr_transform_setup(void)\r\n{\r\ncrb_addr_transform(XDMA);\r\ncrb_addr_transform(TIMR);\r\ncrb_addr_transform(SRE);\r\ncrb_addr_transform(SQN3);\r\ncrb_addr_transform(SQN2);\r\ncrb_addr_transform(SQN1);\r\ncrb_addr_transform(SQN0);\r\ncrb_addr_transform(SQS3);\r\ncrb_addr_transform(SQS2);\r\ncrb_addr_transform(SQS1);\r\ncrb_addr_transform(SQS0);\r\ncrb_addr_transform(RPMX7);\r\ncrb_addr_transform(RPMX6);\r\ncrb_addr_transform(RPMX5);\r\ncrb_addr_transform(RPMX4);\r\ncrb_addr_transform(RPMX3);\r\ncrb_addr_transform(RPMX2);\r\ncrb_addr_transform(RPMX1);\r\ncrb_addr_transform(RPMX0);\r\ncrb_addr_transform(ROMUSB);\r\ncrb_addr_transform(SN);\r\ncrb_addr_transform(QMN);\r\ncrb_addr_transform(QMS);\r\ncrb_addr_transform(PGNI);\r\ncrb_addr_transform(PGND);\r\ncrb_addr_transform(PGN3);\r\ncrb_addr_transform(PGN2);\r\ncrb_addr_transform(PGN1);\r\ncrb_addr_transform(PGN0);\r\ncrb_addr_transform(PGSI);\r\ncrb_addr_transform(PGSD);\r\ncrb_addr_transform(PGS3);\r\ncrb_addr_transform(PGS2);\r\ncrb_addr_transform(PGS1);\r\ncrb_addr_transform(PGS0);\r\ncrb_addr_transform(PS);\r\ncrb_addr_transform(PH);\r\ncrb_addr_transform(NIU);\r\ncrb_addr_transform(I2Q);\r\ncrb_addr_transform(EG);\r\ncrb_addr_transform(MN);\r\ncrb_addr_transform(MS);\r\ncrb_addr_transform(CAS2);\r\ncrb_addr_transform(CAS1);\r\ncrb_addr_transform(CAS0);\r\ncrb_addr_transform(CAM);\r\ncrb_addr_transform(C2C1);\r\ncrb_addr_transform(C2C0);\r\ncrb_addr_transform(SMB);\r\ncrb_addr_transform(OCM0);\r\ncrb_addr_transform(I2C0);\r\n}\r\nvoid qlcnic_release_rx_buffers(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_recv_context *recv_ctx;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nstruct qlcnic_rx_buffer *rx_buf;\r\nint i, ring;\r\nrecv_ctx = adapter->recv_ctx;\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nfor (i = 0; i < rds_ring->num_desc; ++i) {\r\nrx_buf = &(rds_ring->rx_buf_arr[i]);\r\nif (rx_buf->skb == NULL)\r\ncontinue;\r\npci_unmap_single(adapter->pdev,\r\nrx_buf->dma,\r\nrds_ring->dma_size,\r\nPCI_DMA_FROMDEVICE);\r\ndev_kfree_skb_any(rx_buf->skb);\r\n}\r\n}\r\n}\r\nvoid qlcnic_reset_rx_buffers_list(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_recv_context *recv_ctx;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nstruct qlcnic_rx_buffer *rx_buf;\r\nint i, ring;\r\nrecv_ctx = adapter->recv_ctx;\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nINIT_LIST_HEAD(&rds_ring->free_list);\r\nrx_buf = rds_ring->rx_buf_arr;\r\nfor (i = 0; i < rds_ring->num_desc; i++) {\r\nlist_add_tail(&rx_buf->list,\r\n&rds_ring->free_list);\r\nrx_buf++;\r\n}\r\n}\r\n}\r\nvoid qlcnic_release_tx_buffers(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_cmd_buffer *cmd_buf;\r\nstruct qlcnic_skb_frag *buffrag;\r\nint i, j;\r\nstruct qlcnic_host_tx_ring *tx_ring = adapter->tx_ring;\r\ncmd_buf = tx_ring->cmd_buf_arr;\r\nfor (i = 0; i < tx_ring->num_desc; i++) {\r\nbuffrag = cmd_buf->frag_array;\r\nif (buffrag->dma) {\r\npci_unmap_single(adapter->pdev, buffrag->dma,\r\nbuffrag->length, PCI_DMA_TODEVICE);\r\nbuffrag->dma = 0ULL;\r\n}\r\nfor (j = 0; j < cmd_buf->frag_count; j++) {\r\nbuffrag++;\r\nif (buffrag->dma) {\r\npci_unmap_page(adapter->pdev, buffrag->dma,\r\nbuffrag->length,\r\nPCI_DMA_TODEVICE);\r\nbuffrag->dma = 0ULL;\r\n}\r\n}\r\nif (cmd_buf->skb) {\r\ndev_kfree_skb_any(cmd_buf->skb);\r\ncmd_buf->skb = NULL;\r\n}\r\ncmd_buf++;\r\n}\r\n}\r\nvoid qlcnic_free_sw_resources(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_recv_context *recv_ctx;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\nint ring;\r\nrecv_ctx = adapter->recv_ctx;\r\nif (recv_ctx->rds_rings == NULL)\r\ngoto skip_rds;\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nvfree(rds_ring->rx_buf_arr);\r\nrds_ring->rx_buf_arr = NULL;\r\n}\r\nkfree(recv_ctx->rds_rings);\r\nskip_rds:\r\nif (adapter->tx_ring == NULL)\r\nreturn;\r\ntx_ring = adapter->tx_ring;\r\nvfree(tx_ring->cmd_buf_arr);\r\ntx_ring->cmd_buf_arr = NULL;\r\nkfree(adapter->tx_ring);\r\nadapter->tx_ring = NULL;\r\n}\r\nint qlcnic_alloc_sw_resources(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_recv_context *recv_ctx;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\nstruct qlcnic_rx_buffer *rx_buf;\r\nint ring, i, size;\r\nstruct qlcnic_cmd_buffer *cmd_buf_arr;\r\nstruct net_device *netdev = adapter->netdev;\r\nsize = sizeof(struct qlcnic_host_tx_ring);\r\ntx_ring = kzalloc(size, GFP_KERNEL);\r\nif (tx_ring == NULL) {\r\ndev_err(&netdev->dev, "failed to allocate tx ring struct\n");\r\nreturn -ENOMEM;\r\n}\r\nadapter->tx_ring = tx_ring;\r\ntx_ring->num_desc = adapter->num_txd;\r\ntx_ring->txq = netdev_get_tx_queue(netdev, 0);\r\ncmd_buf_arr = vzalloc(TX_BUFF_RINGSIZE(tx_ring));\r\nif (cmd_buf_arr == NULL) {\r\ndev_err(&netdev->dev, "failed to allocate cmd buffer ring\n");\r\ngoto err_out;\r\n}\r\ntx_ring->cmd_buf_arr = cmd_buf_arr;\r\nrecv_ctx = adapter->recv_ctx;\r\nsize = adapter->max_rds_rings * sizeof(struct qlcnic_host_rds_ring);\r\nrds_ring = kzalloc(size, GFP_KERNEL);\r\nif (rds_ring == NULL) {\r\ndev_err(&netdev->dev, "failed to allocate rds ring struct\n");\r\ngoto err_out;\r\n}\r\nrecv_ctx->rds_rings = rds_ring;\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nswitch (ring) {\r\ncase RCV_RING_NORMAL:\r\nrds_ring->num_desc = adapter->num_rxd;\r\nrds_ring->dma_size = QLCNIC_P3P_RX_BUF_MAX_LEN;\r\nrds_ring->skb_size = rds_ring->dma_size + NET_IP_ALIGN;\r\nbreak;\r\ncase RCV_RING_JUMBO:\r\nrds_ring->num_desc = adapter->num_jumbo_rxd;\r\nrds_ring->dma_size =\r\nQLCNIC_P3P_RX_JUMBO_BUF_MAX_LEN;\r\nif (adapter->capabilities & QLCNIC_FW_CAPABILITY_HW_LRO)\r\nrds_ring->dma_size += QLCNIC_LRO_BUFFER_EXTRA;\r\nrds_ring->skb_size =\r\nrds_ring->dma_size + NET_IP_ALIGN;\r\nbreak;\r\n}\r\nrds_ring->rx_buf_arr = vzalloc(RCV_BUFF_RINGSIZE(rds_ring));\r\nif (rds_ring->rx_buf_arr == NULL) {\r\ndev_err(&netdev->dev, "Failed to allocate "\r\n"rx buffer ring %d\n", ring);\r\ngoto err_out;\r\n}\r\nINIT_LIST_HEAD(&rds_ring->free_list);\r\nrx_buf = rds_ring->rx_buf_arr;\r\nfor (i = 0; i < rds_ring->num_desc; i++) {\r\nlist_add_tail(&rx_buf->list,\r\n&rds_ring->free_list);\r\nrx_buf->ref_handle = i;\r\nrx_buf++;\r\n}\r\nspin_lock_init(&rds_ring->lock);\r\n}\r\nfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nsds_ring->irq = adapter->msix_entries[ring].vector;\r\nsds_ring->adapter = adapter;\r\nsds_ring->num_desc = adapter->num_rxd;\r\nfor (i = 0; i < NUM_RCV_DESC_RINGS; i++)\r\nINIT_LIST_HEAD(&sds_ring->free_list[i]);\r\n}\r\nreturn 0;\r\nerr_out:\r\nqlcnic_free_sw_resources(adapter);\r\nreturn -ENOMEM;\r\n}\r\nstatic u32 qlcnic_decode_crb_addr(u32 addr)\r\n{\r\nint i;\r\nu32 base_addr, offset, pci_base;\r\ncrb_addr_transform_setup();\r\npci_base = QLCNIC_ADDR_ERROR;\r\nbase_addr = addr & 0xfff00000;\r\noffset = addr & 0x000fffff;\r\nfor (i = 0; i < QLCNIC_MAX_CRB_XFORM; i++) {\r\nif (crb_addr_xform[i] == base_addr) {\r\npci_base = i << 20;\r\nbreak;\r\n}\r\n}\r\nif (pci_base == QLCNIC_ADDR_ERROR)\r\nreturn pci_base;\r\nelse\r\nreturn pci_base + offset;\r\n}\r\nstatic int qlcnic_wait_rom_done(struct qlcnic_adapter *adapter)\r\n{\r\nlong timeout = 0;\r\nlong done = 0;\r\ncond_resched();\r\nwhile (done == 0) {\r\ndone = QLCRD32(adapter, QLCNIC_ROMUSB_GLB_STATUS);\r\ndone &= 2;\r\nif (++timeout >= QLCNIC_MAX_ROM_WAIT_USEC) {\r\ndev_err(&adapter->pdev->dev,\r\n"Timeout reached waiting for rom done");\r\nreturn -EIO;\r\n}\r\nudelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_rom_fast_read(struct qlcnic_adapter *adapter,\r\nu32 addr, u32 *valp)\r\n{\r\nQLCWR32(adapter, QLCNIC_ROMUSB_ROM_ADDRESS, addr);\r\nQLCWR32(adapter, QLCNIC_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);\r\nQLCWR32(adapter, QLCNIC_ROMUSB_ROM_ABYTE_CNT, 3);\r\nQLCWR32(adapter, QLCNIC_ROMUSB_ROM_INSTR_OPCODE, 0xb);\r\nif (qlcnic_wait_rom_done(adapter)) {\r\ndev_err(&adapter->pdev->dev, "Error waiting for rom done\n");\r\nreturn -EIO;\r\n}\r\nQLCWR32(adapter, QLCNIC_ROMUSB_ROM_ABYTE_CNT, 0);\r\nudelay(10);\r\nQLCWR32(adapter, QLCNIC_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);\r\n*valp = QLCRD32(adapter, QLCNIC_ROMUSB_ROM_RDATA);\r\nreturn 0;\r\n}\r\nstatic int do_rom_fast_read_words(struct qlcnic_adapter *adapter, int addr,\r\nu8 *bytes, size_t size)\r\n{\r\nint addridx;\r\nint ret = 0;\r\nfor (addridx = addr; addridx < (addr + size); addridx += 4) {\r\nint v;\r\nret = do_rom_fast_read(adapter, addridx, &v);\r\nif (ret != 0)\r\nbreak;\r\n*(__le32 *)bytes = cpu_to_le32(v);\r\nbytes += 4;\r\n}\r\nreturn ret;\r\n}\r\nint\r\nqlcnic_rom_fast_read_words(struct qlcnic_adapter *adapter, int addr,\r\nu8 *bytes, size_t size)\r\n{\r\nint ret;\r\nret = qlcnic_rom_lock(adapter);\r\nif (ret < 0)\r\nreturn ret;\r\nret = do_rom_fast_read_words(adapter, addr, bytes, size);\r\nqlcnic_rom_unlock(adapter);\r\nreturn ret;\r\n}\r\nint qlcnic_rom_fast_read(struct qlcnic_adapter *adapter, u32 addr, u32 *valp)\r\n{\r\nint ret;\r\nif (qlcnic_rom_lock(adapter) != 0)\r\nreturn -EIO;\r\nret = do_rom_fast_read(adapter, addr, valp);\r\nqlcnic_rom_unlock(adapter);\r\nreturn ret;\r\n}\r\nint qlcnic_pinit_from_rom(struct qlcnic_adapter *adapter)\r\n{\r\nint addr, val;\r\nint i, n, init_delay;\r\nstruct crb_addr_pair *buf;\r\nunsigned offset;\r\nu32 off;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nQLCWR32(adapter, CRB_CMDPEG_STATE, 0);\r\nQLCWR32(adapter, CRB_RCVPEG_STATE, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x10, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x14, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x18, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x1c, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x20, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x24, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_NIU + 0x40, 0xff);\r\nQLCWR32(adapter, QLCNIC_CRB_NIU + 0x70000, 0x00);\r\nQLCWR32(adapter, QLCNIC_CRB_NIU + 0x80000, 0x00);\r\nQLCWR32(adapter, QLCNIC_CRB_NIU + 0x90000, 0x00);\r\nQLCWR32(adapter, QLCNIC_CRB_NIU + 0xa0000, 0x00);\r\nQLCWR32(adapter, QLCNIC_CRB_NIU + 0xb0000, 0x00);\r\nval = QLCRD32(adapter, QLCNIC_CRB_SRE + 0x1000);\r\nQLCWR32(adapter, QLCNIC_CRB_SRE + 0x1000, val & (~(0x1)));\r\nQLCWR32(adapter, QLCNIC_CRB_EPG + 0x1300, 0x1);\r\nQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x0, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x8, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x10, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x18, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x100, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x200, 0x0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_0 + 0x3c, 1);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_1 + 0x3c, 1);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_2 + 0x3c, 1);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_3 + 0x3c, 1);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_4 + 0x3c, 1);\r\nmsleep(20);\r\nqlcnic_rom_unlock(adapter);\r\nQLCWR32(adapter, QLCNIC_ROMUSB_GLB_SW_RESET, 0xfeffffff);\r\nif (qlcnic_rom_fast_read(adapter, 0, &n) != 0 || (n != 0xcafecafe) ||\r\nqlcnic_rom_fast_read(adapter, 4, &n) != 0) {\r\ndev_err(&pdev->dev, "ERROR Reading crb_init area: val:%x\n", n);\r\nreturn -EIO;\r\n}\r\noffset = n & 0xffffU;\r\nn = (n >> 16) & 0xffffU;\r\nif (n >= 1024) {\r\ndev_err(&pdev->dev, "QLOGIC card flash not initialized.\n");\r\nreturn -EIO;\r\n}\r\nbuf = kcalloc(n, sizeof(struct crb_addr_pair), GFP_KERNEL);\r\nif (buf == NULL) {\r\ndev_err(&pdev->dev, "Unable to calloc memory for rom read.\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < n; i++) {\r\nif (qlcnic_rom_fast_read(adapter, 8*i + 4*offset, &val) != 0 ||\r\nqlcnic_rom_fast_read(adapter, 8*i + 4*offset + 4, &addr) != 0) {\r\nkfree(buf);\r\nreturn -EIO;\r\n}\r\nbuf[i].addr = addr;\r\nbuf[i].data = val;\r\n}\r\nfor (i = 0; i < n; i++) {\r\noff = qlcnic_decode_crb_addr(buf[i].addr);\r\nif (off == QLCNIC_ADDR_ERROR) {\r\ndev_err(&pdev->dev, "CRB init value out of range %x\n",\r\nbuf[i].addr);\r\ncontinue;\r\n}\r\noff += QLCNIC_PCI_CRBSPACE;\r\nif (off & 1)\r\ncontinue;\r\nif (off == QLCNIC_CAM_RAM(0x1fc))\r\ncontinue;\r\nif (off == (QLCNIC_CRB_I2C0 + 0x1c))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0xbc))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0xa8))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0xc8))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0x24))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0x1c))\r\ncontinue;\r\nif ((off & 0x0ff00000) == QLCNIC_CRB_DDR_NET)\r\ncontinue;\r\nif (off == QLCNIC_PCIE_REG(PCIE_SETUP_FUNCTION))\r\ncontinue;\r\nif (off == QLCNIC_PCIE_REG(PCIE_SETUP_FUNCTION2))\r\ncontinue;\r\nif ((off & 0x0ff00000) == QLCNIC_CRB_SMB)\r\ncontinue;\r\ninit_delay = 1;\r\nif (off == QLCNIC_ROMUSB_GLB_SW_RESET)\r\ninit_delay = 1000;\r\nQLCWR32(adapter, off, buf[i].data);\r\nmsleep(init_delay);\r\n}\r\nkfree(buf);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_D + 0xec, 0x1e);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_D + 0x4c, 8);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_I + 0x4c, 8);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_0 + 0x8, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_0 + 0xc, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_1 + 0x8, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_1 + 0xc, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_2 + 0x8, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_2 + 0xc, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_3 + 0x8, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_3 + 0xc, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_4 + 0x8, 0);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_4 + 0xc, 0);\r\nmsleep(1);\r\nQLCWR32(adapter, QLCNIC_PEG_HALT_STATUS1, 0);\r\nQLCWR32(adapter, QLCNIC_PEG_HALT_STATUS2, 0);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_cmd_peg_ready(struct qlcnic_adapter *adapter)\r\n{\r\nu32 val;\r\nint retries = QLCNIC_CMDPEG_CHECK_RETRY_COUNT;\r\ndo {\r\nval = QLCRD32(adapter, CRB_CMDPEG_STATE);\r\nswitch (val) {\r\ncase PHAN_INITIALIZE_COMPLETE:\r\ncase PHAN_INITIALIZE_ACK:\r\nreturn 0;\r\ncase PHAN_INITIALIZE_FAILED:\r\ngoto out_err;\r\ndefault:\r\nbreak;\r\n}\r\nmsleep(QLCNIC_CMDPEG_CHECK_DELAY);\r\n} while (--retries);\r\nQLCWR32(adapter, CRB_CMDPEG_STATE, PHAN_INITIALIZE_FAILED);\r\nout_err:\r\ndev_err(&adapter->pdev->dev, "Command Peg initialization not "\r\n"complete, state: 0x%x.\n", val);\r\nreturn -EIO;\r\n}\r\nstatic int\r\nqlcnic_receive_peg_ready(struct qlcnic_adapter *adapter)\r\n{\r\nu32 val;\r\nint retries = QLCNIC_RCVPEG_CHECK_RETRY_COUNT;\r\ndo {\r\nval = QLCRD32(adapter, CRB_RCVPEG_STATE);\r\nif (val == PHAN_PEG_RCV_INITIALIZED)\r\nreturn 0;\r\nmsleep(QLCNIC_RCVPEG_CHECK_DELAY);\r\n} while (--retries);\r\nif (!retries) {\r\ndev_err(&adapter->pdev->dev, "Receive Peg initialization not "\r\n"complete, state: 0x%x.\n", val);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nqlcnic_check_fw_status(struct qlcnic_adapter *adapter)\r\n{\r\nint err;\r\nerr = qlcnic_cmd_peg_ready(adapter);\r\nif (err)\r\nreturn err;\r\nerr = qlcnic_receive_peg_ready(adapter);\r\nif (err)\r\nreturn err;\r\nQLCWR32(adapter, CRB_CMDPEG_STATE, PHAN_INITIALIZE_ACK);\r\nreturn err;\r\n}\r\nint\r\nqlcnic_setup_idc_param(struct qlcnic_adapter *adapter) {\r\nint timeo;\r\nu32 val;\r\nval = QLCRD32(adapter, QLCNIC_CRB_DEV_PARTITION_INFO);\r\nval = QLC_DEV_GET_DRV(val, adapter->portnum);\r\nif ((val & 0x3) != QLCNIC_TYPE_NIC) {\r\ndev_err(&adapter->pdev->dev,\r\n"Not an Ethernet NIC func=%u\n", val);\r\nreturn -EIO;\r\n}\r\nadapter->physical_port = (val >> 2);\r\nif (qlcnic_rom_fast_read(adapter, QLCNIC_ROM_DEV_INIT_TIMEOUT, &timeo))\r\ntimeo = QLCNIC_INIT_TIMEOUT_SECS;\r\nadapter->dev_init_timeo = timeo;\r\nif (qlcnic_rom_fast_read(adapter, QLCNIC_ROM_DRV_RESET_TIMEOUT, &timeo))\r\ntimeo = QLCNIC_RESET_TIMEOUT_SECS;\r\nadapter->reset_ack_timeo = timeo;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_get_flt_entry(struct qlcnic_adapter *adapter, u8 region,\r\nstruct qlcnic_flt_entry *region_entry)\r\n{\r\nstruct qlcnic_flt_header flt_hdr;\r\nstruct qlcnic_flt_entry *flt_entry;\r\nint i = 0, ret;\r\nu32 entry_size;\r\nmemset(region_entry, 0, sizeof(struct qlcnic_flt_entry));\r\nret = qlcnic_rom_fast_read_words(adapter, QLCNIC_FLT_LOCATION,\r\n(u8 *)&flt_hdr,\r\nsizeof(struct qlcnic_flt_header));\r\nif (ret) {\r\ndev_warn(&adapter->pdev->dev,\r\n"error reading flash layout header\n");\r\nreturn -EIO;\r\n}\r\nentry_size = flt_hdr.len - sizeof(struct qlcnic_flt_header);\r\nflt_entry = (struct qlcnic_flt_entry *)vzalloc(entry_size);\r\nif (flt_entry == NULL) {\r\ndev_warn(&adapter->pdev->dev, "error allocating memory\n");\r\nreturn -EIO;\r\n}\r\nret = qlcnic_rom_fast_read_words(adapter, QLCNIC_FLT_LOCATION +\r\nsizeof(struct qlcnic_flt_header),\r\n(u8 *)flt_entry, entry_size);\r\nif (ret) {\r\ndev_warn(&adapter->pdev->dev,\r\n"error reading flash layout entries\n");\r\ngoto err_out;\r\n}\r\nwhile (i < (entry_size/sizeof(struct qlcnic_flt_entry))) {\r\nif (flt_entry[i].region == region)\r\nbreak;\r\ni++;\r\n}\r\nif (i >= (entry_size/sizeof(struct qlcnic_flt_entry))) {\r\ndev_warn(&adapter->pdev->dev,\r\n"region=%x not found in %d regions\n", region, i);\r\nret = -EIO;\r\ngoto err_out;\r\n}\r\nmemcpy(region_entry, &flt_entry[i], sizeof(struct qlcnic_flt_entry));\r\nerr_out:\r\nvfree(flt_entry);\r\nreturn ret;\r\n}\r\nint\r\nqlcnic_check_flash_fw_ver(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_flt_entry fw_entry;\r\nu32 ver = -1, min_ver;\r\nint ret;\r\nif (adapter->ahw->revision_id == QLCNIC_P3P_C0)\r\nret = qlcnic_get_flt_entry(adapter, QLCNIC_C0_FW_IMAGE_REGION,\r\n&fw_entry);\r\nelse\r\nret = qlcnic_get_flt_entry(adapter, QLCNIC_B0_FW_IMAGE_REGION,\r\n&fw_entry);\r\nif (!ret)\r\nqlcnic_rom_fast_read(adapter, fw_entry.start_addr + 4,\r\n(int *)&ver);\r\nelse\r\nqlcnic_rom_fast_read(adapter, QLCNIC_FW_VERSION_OFFSET,\r\n(int *)&ver);\r\nver = QLCNIC_DECODE_VERSION(ver);\r\nmin_ver = QLCNIC_MIN_FW_VERSION;\r\nif (ver < min_ver) {\r\ndev_err(&adapter->pdev->dev,\r\n"firmware version %d.%d.%d unsupported."\r\n"Min supported version %d.%d.%d\n",\r\n_major(ver), _minor(ver), _build(ver),\r\n_major(min_ver), _minor(min_ver), _build(min_ver));\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_has_mn(struct qlcnic_adapter *adapter)\r\n{\r\nu32 capability;\r\ncapability = 0;\r\ncapability = QLCRD32(adapter, QLCNIC_PEG_TUNE_CAPABILITY);\r\nif (capability & QLCNIC_PEG_TUNE_MN_PRESENT)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic\r\nstruct uni_table_desc *qlcnic_get_table_desc(const u8 *unirom, int section)\r\n{\r\nu32 i;\r\nstruct uni_table_desc *directory = (struct uni_table_desc *) &unirom[0];\r\n__le32 entries = cpu_to_le32(directory->num_entries);\r\nfor (i = 0; i < entries; i++) {\r\n__le32 offs = cpu_to_le32(directory->findex) +\r\n(i * cpu_to_le32(directory->entry_size));\r\n__le32 tab_type = cpu_to_le32(*((u32 *)&unirom[offs] + 8));\r\nif (tab_type == section)\r\nreturn (struct uni_table_desc *) &unirom[offs];\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nqlcnic_validate_header(struct qlcnic_adapter *adapter)\r\n{\r\nconst u8 *unirom = adapter->fw->data;\r\nstruct uni_table_desc *directory = (struct uni_table_desc *) &unirom[0];\r\n__le32 fw_file_size = adapter->fw->size;\r\n__le32 entries;\r\n__le32 entry_size;\r\n__le32 tab_size;\r\nif (fw_file_size < FILEHEADER_SIZE)\r\nreturn -EINVAL;\r\nentries = cpu_to_le32(directory->num_entries);\r\nentry_size = cpu_to_le32(directory->entry_size);\r\ntab_size = cpu_to_le32(directory->findex) + (entries * entry_size);\r\nif (fw_file_size < tab_size)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_validate_bootld(struct qlcnic_adapter *adapter)\r\n{\r\nstruct uni_table_desc *tab_desc;\r\nstruct uni_data_desc *descr;\r\nconst u8 *unirom = adapter->fw->data;\r\nint idx = cpu_to_le32(*((int *)&unirom[adapter->file_prd_off] +\r\nQLCNIC_UNI_BOOTLD_IDX_OFF));\r\n__le32 offs;\r\n__le32 tab_size;\r\n__le32 data_size;\r\ntab_desc = qlcnic_get_table_desc(unirom, QLCNIC_UNI_DIR_SECT_BOOTLD);\r\nif (!tab_desc)\r\nreturn -EINVAL;\r\ntab_size = cpu_to_le32(tab_desc->findex) +\r\n(cpu_to_le32(tab_desc->entry_size) * (idx + 1));\r\nif (adapter->fw->size < tab_size)\r\nreturn -EINVAL;\r\noffs = cpu_to_le32(tab_desc->findex) +\r\n(cpu_to_le32(tab_desc->entry_size) * (idx));\r\ndescr = (struct uni_data_desc *)&unirom[offs];\r\ndata_size = cpu_to_le32(descr->findex) + cpu_to_le32(descr->size);\r\nif (adapter->fw->size < data_size)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_validate_fw(struct qlcnic_adapter *adapter)\r\n{\r\nstruct uni_table_desc *tab_desc;\r\nstruct uni_data_desc *descr;\r\nconst u8 *unirom = adapter->fw->data;\r\nint idx = cpu_to_le32(*((int *)&unirom[adapter->file_prd_off] +\r\nQLCNIC_UNI_FIRMWARE_IDX_OFF));\r\n__le32 offs;\r\n__le32 tab_size;\r\n__le32 data_size;\r\ntab_desc = qlcnic_get_table_desc(unirom, QLCNIC_UNI_DIR_SECT_FW);\r\nif (!tab_desc)\r\nreturn -EINVAL;\r\ntab_size = cpu_to_le32(tab_desc->findex) +\r\n(cpu_to_le32(tab_desc->entry_size) * (idx + 1));\r\nif (adapter->fw->size < tab_size)\r\nreturn -EINVAL;\r\noffs = cpu_to_le32(tab_desc->findex) +\r\n(cpu_to_le32(tab_desc->entry_size) * (idx));\r\ndescr = (struct uni_data_desc *)&unirom[offs];\r\ndata_size = cpu_to_le32(descr->findex) + cpu_to_le32(descr->size);\r\nif (adapter->fw->size < data_size)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_validate_product_offs(struct qlcnic_adapter *adapter)\r\n{\r\nstruct uni_table_desc *ptab_descr;\r\nconst u8 *unirom = adapter->fw->data;\r\nint mn_present = qlcnic_has_mn(adapter);\r\n__le32 entries;\r\n__le32 entry_size;\r\n__le32 tab_size;\r\nu32 i;\r\nptab_descr = qlcnic_get_table_desc(unirom,\r\nQLCNIC_UNI_DIR_SECT_PRODUCT_TBL);\r\nif (!ptab_descr)\r\nreturn -EINVAL;\r\nentries = cpu_to_le32(ptab_descr->num_entries);\r\nentry_size = cpu_to_le32(ptab_descr->entry_size);\r\ntab_size = cpu_to_le32(ptab_descr->findex) + (entries * entry_size);\r\nif (adapter->fw->size < tab_size)\r\nreturn -EINVAL;\r\nnomn:\r\nfor (i = 0; i < entries; i++) {\r\n__le32 flags, file_chiprev, offs;\r\nu8 chiprev = adapter->ahw->revision_id;\r\nu32 flagbit;\r\noffs = cpu_to_le32(ptab_descr->findex) +\r\n(i * cpu_to_le32(ptab_descr->entry_size));\r\nflags = cpu_to_le32(*((int *)&unirom[offs] +\r\nQLCNIC_UNI_FLAGS_OFF));\r\nfile_chiprev = cpu_to_le32(*((int *)&unirom[offs] +\r\nQLCNIC_UNI_CHIP_REV_OFF));\r\nflagbit = mn_present ? 1 : 2;\r\nif ((chiprev == file_chiprev) &&\r\n((1ULL << flagbit) & flags)) {\r\nadapter->file_prd_off = offs;\r\nreturn 0;\r\n}\r\n}\r\nif (mn_present) {\r\nmn_present = 0;\r\ngoto nomn;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nqlcnic_validate_unified_romimage(struct qlcnic_adapter *adapter)\r\n{\r\nif (qlcnic_validate_header(adapter)) {\r\ndev_err(&adapter->pdev->dev,\r\n"unified image: header validation failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (qlcnic_validate_product_offs(adapter)) {\r\ndev_err(&adapter->pdev->dev,\r\n"unified image: product validation failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (qlcnic_validate_bootld(adapter)) {\r\ndev_err(&adapter->pdev->dev,\r\n"unified image: bootld validation failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (qlcnic_validate_fw(adapter)) {\r\ndev_err(&adapter->pdev->dev,\r\n"unified image: firmware validation failed\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic\r\nstruct uni_data_desc *qlcnic_get_data_desc(struct qlcnic_adapter *adapter,\r\nu32 section, u32 idx_offset)\r\n{\r\nconst u8 *unirom = adapter->fw->data;\r\nint idx = cpu_to_le32(*((int *)&unirom[adapter->file_prd_off] +\r\nidx_offset));\r\nstruct uni_table_desc *tab_desc;\r\n__le32 offs;\r\ntab_desc = qlcnic_get_table_desc(unirom, section);\r\nif (tab_desc == NULL)\r\nreturn NULL;\r\noffs = cpu_to_le32(tab_desc->findex) +\r\n(cpu_to_le32(tab_desc->entry_size) * idx);\r\nreturn (struct uni_data_desc *)&unirom[offs];\r\n}\r\nstatic u8 *\r\nqlcnic_get_bootld_offs(struct qlcnic_adapter *adapter)\r\n{\r\nu32 offs = QLCNIC_BOOTLD_START;\r\nif (adapter->fw_type == QLCNIC_UNIFIED_ROMIMAGE)\r\noffs = cpu_to_le32((qlcnic_get_data_desc(adapter,\r\nQLCNIC_UNI_DIR_SECT_BOOTLD,\r\nQLCNIC_UNI_BOOTLD_IDX_OFF))->findex);\r\nreturn (u8 *)&adapter->fw->data[offs];\r\n}\r\nstatic u8 *\r\nqlcnic_get_fw_offs(struct qlcnic_adapter *adapter)\r\n{\r\nu32 offs = QLCNIC_IMAGE_START;\r\nif (adapter->fw_type == QLCNIC_UNIFIED_ROMIMAGE)\r\noffs = cpu_to_le32((qlcnic_get_data_desc(adapter,\r\nQLCNIC_UNI_DIR_SECT_FW,\r\nQLCNIC_UNI_FIRMWARE_IDX_OFF))->findex);\r\nreturn (u8 *)&adapter->fw->data[offs];\r\n}\r\nstatic __le32\r\nqlcnic_get_fw_size(struct qlcnic_adapter *adapter)\r\n{\r\nif (adapter->fw_type == QLCNIC_UNIFIED_ROMIMAGE)\r\nreturn cpu_to_le32((qlcnic_get_data_desc(adapter,\r\nQLCNIC_UNI_DIR_SECT_FW,\r\nQLCNIC_UNI_FIRMWARE_IDX_OFF))->size);\r\nelse\r\nreturn cpu_to_le32(\r\n*(u32 *)&adapter->fw->data[QLCNIC_FW_SIZE_OFFSET]);\r\n}\r\nstatic __le32\r\nqlcnic_get_fw_version(struct qlcnic_adapter *adapter)\r\n{\r\nstruct uni_data_desc *fw_data_desc;\r\nconst struct firmware *fw = adapter->fw;\r\n__le32 major, minor, sub;\r\nconst u8 *ver_str;\r\nint i, ret;\r\nif (adapter->fw_type != QLCNIC_UNIFIED_ROMIMAGE)\r\nreturn cpu_to_le32(*(u32 *)&fw->data[QLCNIC_FW_VERSION_OFFSET]);\r\nfw_data_desc = qlcnic_get_data_desc(adapter, QLCNIC_UNI_DIR_SECT_FW,\r\nQLCNIC_UNI_FIRMWARE_IDX_OFF);\r\nver_str = fw->data + cpu_to_le32(fw_data_desc->findex) +\r\ncpu_to_le32(fw_data_desc->size) - 17;\r\nfor (i = 0; i < 12; i++) {\r\nif (!strncmp(&ver_str[i], "REV=", 4)) {\r\nret = sscanf(&ver_str[i+4], "%u.%u.%u ",\r\n&major, &minor, &sub);\r\nif (ret != 3)\r\nreturn 0;\r\nelse\r\nreturn major + (minor << 8) + (sub << 16);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic __le32\r\nqlcnic_get_bios_version(struct qlcnic_adapter *adapter)\r\n{\r\nconst struct firmware *fw = adapter->fw;\r\n__le32 bios_ver, prd_off = adapter->file_prd_off;\r\nif (adapter->fw_type != QLCNIC_UNIFIED_ROMIMAGE)\r\nreturn cpu_to_le32(\r\n*(u32 *)&fw->data[QLCNIC_BIOS_VERSION_OFFSET]);\r\nbios_ver = cpu_to_le32(*((u32 *) (&fw->data[prd_off])\r\n+ QLCNIC_UNI_BIOS_VERSION_OFF));\r\nreturn (bios_ver << 16) + ((bios_ver >> 8) & 0xff00) + (bios_ver >> 24);\r\n}\r\nstatic void qlcnic_rom_lock_recovery(struct qlcnic_adapter *adapter)\r\n{\r\nif (qlcnic_pcie_sem_lock(adapter, 2, QLCNIC_ROM_LOCK_ID))\r\ndev_info(&adapter->pdev->dev, "Resetting rom_lock\n");\r\nqlcnic_pcie_sem_unlock(adapter, 2);\r\n}\r\nstatic int\r\nqlcnic_check_fw_hearbeat(struct qlcnic_adapter *adapter)\r\n{\r\nu32 heartbeat, ret = -EIO;\r\nint retries = QLCNIC_HEARTBEAT_CHECK_RETRY_COUNT;\r\nadapter->heartbeat = QLCRD32(adapter, QLCNIC_PEG_ALIVE_COUNTER);\r\ndo {\r\nmsleep(QLCNIC_HEARTBEAT_PERIOD_MSECS);\r\nheartbeat = QLCRD32(adapter, QLCNIC_PEG_ALIVE_COUNTER);\r\nif (heartbeat != adapter->heartbeat) {\r\nret = QLCNIC_RCODE_SUCCESS;\r\nbreak;\r\n}\r\n} while (--retries);\r\nreturn ret;\r\n}\r\nint\r\nqlcnic_need_fw_reset(struct qlcnic_adapter *adapter)\r\n{\r\nif ((adapter->flags & QLCNIC_FW_HANG) ||\r\nqlcnic_check_fw_hearbeat(adapter)) {\r\nqlcnic_rom_lock_recovery(adapter);\r\nreturn 1;\r\n}\r\nif (adapter->need_fw_reset)\r\nreturn 1;\r\nif (adapter->fw)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint\r\nqlcnic_load_firmware(struct qlcnic_adapter *adapter)\r\n{\r\nu64 *ptr64;\r\nu32 i, flashaddr, size;\r\nconst struct firmware *fw = adapter->fw;\r\nstruct pci_dev *pdev = adapter->pdev;\r\ndev_info(&pdev->dev, "loading firmware from %s\n",\r\nfw_name[adapter->fw_type]);\r\nif (fw) {\r\n__le64 data;\r\nsize = (QLCNIC_IMAGE_START - QLCNIC_BOOTLD_START) / 8;\r\nptr64 = (u64 *)qlcnic_get_bootld_offs(adapter);\r\nflashaddr = QLCNIC_BOOTLD_START;\r\nfor (i = 0; i < size; i++) {\r\ndata = cpu_to_le64(ptr64[i]);\r\nif (qlcnic_pci_mem_write_2M(adapter, flashaddr, data))\r\nreturn -EIO;\r\nflashaddr += 8;\r\n}\r\nsize = (__force u32)qlcnic_get_fw_size(adapter) / 8;\r\nptr64 = (u64 *)qlcnic_get_fw_offs(adapter);\r\nflashaddr = QLCNIC_IMAGE_START;\r\nfor (i = 0; i < size; i++) {\r\ndata = cpu_to_le64(ptr64[i]);\r\nif (qlcnic_pci_mem_write_2M(adapter,\r\nflashaddr, data))\r\nreturn -EIO;\r\nflashaddr += 8;\r\n}\r\nsize = (__force u32)qlcnic_get_fw_size(adapter) % 8;\r\nif (size) {\r\ndata = cpu_to_le64(ptr64[i]);\r\nif (qlcnic_pci_mem_write_2M(adapter,\r\nflashaddr, data))\r\nreturn -EIO;\r\n}\r\n} else {\r\nu64 data;\r\nu32 hi, lo;\r\nint ret;\r\nstruct qlcnic_flt_entry bootld_entry;\r\nret = qlcnic_get_flt_entry(adapter, QLCNIC_BOOTLD_REGION,\r\n&bootld_entry);\r\nif (!ret) {\r\nsize = bootld_entry.size / 8;\r\nflashaddr = bootld_entry.start_addr;\r\n} else {\r\nsize = (QLCNIC_IMAGE_START - QLCNIC_BOOTLD_START) / 8;\r\nflashaddr = QLCNIC_BOOTLD_START;\r\ndev_info(&pdev->dev,\r\n"using legacy method to get flash fw region");\r\n}\r\nfor (i = 0; i < size; i++) {\r\nif (qlcnic_rom_fast_read(adapter,\r\nflashaddr, (int *)&lo) != 0)\r\nreturn -EIO;\r\nif (qlcnic_rom_fast_read(adapter,\r\nflashaddr + 4, (int *)&hi) != 0)\r\nreturn -EIO;\r\ndata = (((u64)hi << 32) | lo);\r\nif (qlcnic_pci_mem_write_2M(adapter,\r\nflashaddr, data))\r\nreturn -EIO;\r\nflashaddr += 8;\r\n}\r\n}\r\nmsleep(1);\r\nQLCWR32(adapter, QLCNIC_CRB_PEG_NET_0 + 0x18, 0x1020);\r\nQLCWR32(adapter, QLCNIC_ROMUSB_GLB_SW_RESET, 0x80001e);\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_validate_firmware(struct qlcnic_adapter *adapter)\r\n{\r\n__le32 val;\r\nu32 ver, bios, min_size;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nconst struct firmware *fw = adapter->fw;\r\nu8 fw_type = adapter->fw_type;\r\nif (fw_type == QLCNIC_UNIFIED_ROMIMAGE) {\r\nif (qlcnic_validate_unified_romimage(adapter))\r\nreturn -EINVAL;\r\nmin_size = QLCNIC_UNI_FW_MIN_SIZE;\r\n} else {\r\nval = cpu_to_le32(*(u32 *)&fw->data[QLCNIC_FW_MAGIC_OFFSET]);\r\nif ((__force u32)val != QLCNIC_BDINFO_MAGIC)\r\nreturn -EINVAL;\r\nmin_size = QLCNIC_FW_MIN_SIZE;\r\n}\r\nif (fw->size < min_size)\r\nreturn -EINVAL;\r\nval = qlcnic_get_fw_version(adapter);\r\nver = QLCNIC_DECODE_VERSION(val);\r\nif (ver < QLCNIC_MIN_FW_VERSION) {\r\ndev_err(&pdev->dev,\r\n"%s: firmware version %d.%d.%d unsupported\n",\r\nfw_name[fw_type], _major(ver), _minor(ver), _build(ver));\r\nreturn -EINVAL;\r\n}\r\nval = qlcnic_get_bios_version(adapter);\r\nqlcnic_rom_fast_read(adapter, QLCNIC_BIOS_VERSION_OFFSET, (int *)&bios);\r\nif ((__force u32)val != bios) {\r\ndev_err(&pdev->dev, "%s: firmware bios is incompatible\n",\r\nfw_name[fw_type]);\r\nreturn -EINVAL;\r\n}\r\nQLCWR32(adapter, QLCNIC_CAM_RAM(0x1fc), QLCNIC_BDINFO_MAGIC);\r\nreturn 0;\r\n}\r\nstatic void\r\nqlcnic_get_next_fwtype(struct qlcnic_adapter *adapter)\r\n{\r\nu8 fw_type;\r\nswitch (adapter->fw_type) {\r\ncase QLCNIC_UNKNOWN_ROMIMAGE:\r\nfw_type = QLCNIC_UNIFIED_ROMIMAGE;\r\nbreak;\r\ncase QLCNIC_UNIFIED_ROMIMAGE:\r\ndefault:\r\nfw_type = QLCNIC_FLASH_ROMIMAGE;\r\nbreak;\r\n}\r\nadapter->fw_type = fw_type;\r\n}\r\nvoid qlcnic_request_firmware(struct qlcnic_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint rc;\r\nadapter->fw_type = QLCNIC_UNKNOWN_ROMIMAGE;\r\nnext:\r\nqlcnic_get_next_fwtype(adapter);\r\nif (adapter->fw_type == QLCNIC_FLASH_ROMIMAGE) {\r\nadapter->fw = NULL;\r\n} else {\r\nrc = request_firmware(&adapter->fw,\r\nfw_name[adapter->fw_type], &pdev->dev);\r\nif (rc != 0)\r\ngoto next;\r\nrc = qlcnic_validate_firmware(adapter);\r\nif (rc != 0) {\r\nrelease_firmware(adapter->fw);\r\nmsleep(1);\r\ngoto next;\r\n}\r\n}\r\n}\r\nvoid\r\nqlcnic_release_firmware(struct qlcnic_adapter *adapter)\r\n{\r\nif (adapter->fw)\r\nrelease_firmware(adapter->fw);\r\nadapter->fw = NULL;\r\n}\r\nstatic void\r\nqlcnic_handle_linkevent(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_fw_msg *msg)\r\n{\r\nu32 cable_OUI;\r\nu16 cable_len;\r\nu16 link_speed;\r\nu8 link_status, module, duplex, autoneg;\r\nu8 lb_status = 0;\r\nstruct net_device *netdev = adapter->netdev;\r\nadapter->has_link_events = 1;\r\ncable_OUI = msg->body[1] & 0xffffffff;\r\ncable_len = (msg->body[1] >> 32) & 0xffff;\r\nlink_speed = (msg->body[1] >> 48) & 0xffff;\r\nlink_status = msg->body[2] & 0xff;\r\nduplex = (msg->body[2] >> 16) & 0xff;\r\nautoneg = (msg->body[2] >> 24) & 0xff;\r\nlb_status = (msg->body[2] >> 32) & 0x3;\r\nmodule = (msg->body[2] >> 8) & 0xff;\r\nif (module == LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLE)\r\ndev_info(&netdev->dev, "unsupported cable: OUI 0x%x, "\r\n"length %d\n", cable_OUI, cable_len);\r\nelse if (module == LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLELEN)\r\ndev_info(&netdev->dev, "unsupported cable length %d\n",\r\ncable_len);\r\nif (!link_status && (lb_status == QLCNIC_ILB_MODE ||\r\nlb_status == QLCNIC_ELB_MODE))\r\nadapter->ahw->loopback_state |= QLCNIC_LINKEVENT;\r\nqlcnic_advert_link_change(adapter, link_status);\r\nif (duplex == LINKEVENT_FULL_DUPLEX)\r\nadapter->link_duplex = DUPLEX_FULL;\r\nelse\r\nadapter->link_duplex = DUPLEX_HALF;\r\nadapter->module_type = module;\r\nadapter->link_autoneg = autoneg;\r\nadapter->link_speed = link_speed;\r\n}\r\nstatic void\r\nqlcnic_handle_fw_message(int desc_cnt, int index,\r\nstruct qlcnic_host_sds_ring *sds_ring)\r\n{\r\nstruct qlcnic_fw_msg msg;\r\nstruct status_desc *desc;\r\nstruct qlcnic_adapter *adapter;\r\nstruct device *dev;\r\nint i = 0, opcode, ret;\r\nwhile (desc_cnt > 0 && i < 8) {\r\ndesc = &sds_ring->desc_head[index];\r\nmsg.words[i++] = le64_to_cpu(desc->status_desc_data[0]);\r\nmsg.words[i++] = le64_to_cpu(desc->status_desc_data[1]);\r\nindex = get_next_index(index, sds_ring->num_desc);\r\ndesc_cnt--;\r\n}\r\nadapter = sds_ring->adapter;\r\ndev = &adapter->pdev->dev;\r\nopcode = qlcnic_get_nic_msg_opcode(msg.body[0]);\r\nswitch (opcode) {\r\ncase QLCNIC_C2H_OPCODE_GET_LINKEVENT_RESPONSE:\r\nqlcnic_handle_linkevent(adapter, &msg);\r\nbreak;\r\ncase QLCNIC_C2H_OPCODE_CONFIG_LOOPBACK:\r\nret = (u32)(msg.body[1]);\r\nswitch (ret) {\r\ncase 0:\r\nadapter->ahw->loopback_state |= QLCNIC_LB_RESPONSE;\r\nbreak;\r\ncase 1:\r\ndev_info(dev, "loopback already in progress\n");\r\nadapter->diag_cnt = -QLCNIC_TEST_IN_PROGRESS;\r\nbreak;\r\ncase 2:\r\ndev_info(dev, "loopback cable is not connected\n");\r\nadapter->diag_cnt = -QLCNIC_LB_CABLE_NOT_CONN;\r\nbreak;\r\ndefault:\r\ndev_info(dev, "loopback configure request failed,"\r\n" ret %x\n", ret);\r\nadapter->diag_cnt = -QLCNIC_UNDEFINED_ERROR;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nqlcnic_alloc_rx_skb(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_host_rds_ring *rds_ring,\r\nstruct qlcnic_rx_buffer *buffer)\r\n{\r\nstruct sk_buff *skb;\r\ndma_addr_t dma;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nskb = dev_alloc_skb(rds_ring->skb_size);\r\nif (!skb) {\r\nadapter->stats.skb_alloc_failure++;\r\nreturn -ENOMEM;\r\n}\r\nskb_reserve(skb, NET_IP_ALIGN);\r\ndma = pci_map_single(pdev, skb->data,\r\nrds_ring->dma_size, PCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(pdev, dma)) {\r\nadapter->stats.rx_dma_map_error++;\r\ndev_kfree_skb_any(skb);\r\nreturn -ENOMEM;\r\n}\r\nbuffer->skb = skb;\r\nbuffer->dma = dma;\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *qlcnic_process_rxbuf(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_host_rds_ring *rds_ring, u16 index, u16 cksum)\r\n{\r\nstruct qlcnic_rx_buffer *buffer;\r\nstruct sk_buff *skb;\r\nbuffer = &rds_ring->rx_buf_arr[index];\r\nif (unlikely(buffer->skb == NULL)) {\r\nWARN_ON(1);\r\nreturn NULL;\r\n}\r\npci_unmap_single(adapter->pdev, buffer->dma, rds_ring->dma_size,\r\nPCI_DMA_FROMDEVICE);\r\nskb = buffer->skb;\r\nif (likely((adapter->netdev->features & NETIF_F_RXCSUM) &&\r\n(cksum == STATUS_CKSUM_OK || cksum == STATUS_CKSUM_LOOP))) {\r\nadapter->stats.csummed++;\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n} else {\r\nskb_checksum_none_assert(skb);\r\n}\r\nskb->dev = adapter->netdev;\r\nbuffer->skb = NULL;\r\nreturn skb;\r\n}\r\nstatic inline int\r\nqlcnic_check_rx_tagging(struct qlcnic_adapter *adapter, struct sk_buff *skb,\r\nu16 *vlan_tag)\r\n{\r\nstruct ethhdr *eth_hdr;\r\nif (!__vlan_get_tag(skb, vlan_tag)) {\r\neth_hdr = (struct ethhdr *) skb->data;\r\nmemmove(skb->data + VLAN_HLEN, eth_hdr, ETH_ALEN * 2);\r\nskb_pull(skb, VLAN_HLEN);\r\n}\r\nif (!adapter->pvid)\r\nreturn 0;\r\nif (*vlan_tag == adapter->pvid) {\r\n*vlan_tag = 0xffff;\r\nreturn 0;\r\n}\r\nif (adapter->flags & QLCNIC_TAGGING_ENABLED)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic struct qlcnic_rx_buffer *\r\nqlcnic_process_rcv(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_host_sds_ring *sds_ring,\r\nint ring, u64 sts_data0)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nstruct qlcnic_rx_buffer *buffer;\r\nstruct sk_buff *skb;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nint index, length, cksum, pkt_offset;\r\nu16 vid = 0xffff;\r\nif (unlikely(ring >= adapter->max_rds_rings))\r\nreturn NULL;\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nindex = qlcnic_get_sts_refhandle(sts_data0);\r\nif (unlikely(index >= rds_ring->num_desc))\r\nreturn NULL;\r\nbuffer = &rds_ring->rx_buf_arr[index];\r\nlength = qlcnic_get_sts_totallength(sts_data0);\r\ncksum = qlcnic_get_sts_status(sts_data0);\r\npkt_offset = qlcnic_get_sts_pkt_offset(sts_data0);\r\nskb = qlcnic_process_rxbuf(adapter, rds_ring, index, cksum);\r\nif (!skb)\r\nreturn buffer;\r\nif (length > rds_ring->skb_size)\r\nskb_put(skb, rds_ring->skb_size);\r\nelse\r\nskb_put(skb, length);\r\nif (pkt_offset)\r\nskb_pull(skb, pkt_offset);\r\nif (unlikely(qlcnic_check_rx_tagging(adapter, skb, &vid))) {\r\nadapter->stats.rxdropped++;\r\ndev_kfree_skb(skb);\r\nreturn buffer;\r\n}\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nif (vid != 0xffff)\r\n__vlan_hwaccel_put_tag(skb, vid);\r\nnapi_gro_receive(&sds_ring->napi, skb);\r\nadapter->stats.rx_pkts++;\r\nadapter->stats.rxbytes += length;\r\nreturn buffer;\r\n}\r\nstatic struct qlcnic_rx_buffer *\r\nqlcnic_process_lro(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_host_sds_ring *sds_ring,\r\nint ring, u64 sts_data0, u64 sts_data1)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nstruct qlcnic_rx_buffer *buffer;\r\nstruct sk_buff *skb;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nstruct iphdr *iph;\r\nstruct tcphdr *th;\r\nbool push, timestamp;\r\nint l2_hdr_offset, l4_hdr_offset;\r\nint index;\r\nu16 lro_length, length, data_offset;\r\nu32 seq_number;\r\nu16 vid = 0xffff;\r\nif (unlikely(ring > adapter->max_rds_rings))\r\nreturn NULL;\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nindex = qlcnic_get_lro_sts_refhandle(sts_data0);\r\nif (unlikely(index > rds_ring->num_desc))\r\nreturn NULL;\r\nbuffer = &rds_ring->rx_buf_arr[index];\r\ntimestamp = qlcnic_get_lro_sts_timestamp(sts_data0);\r\nlro_length = qlcnic_get_lro_sts_length(sts_data0);\r\nl2_hdr_offset = qlcnic_get_lro_sts_l2_hdr_offset(sts_data0);\r\nl4_hdr_offset = qlcnic_get_lro_sts_l4_hdr_offset(sts_data0);\r\npush = qlcnic_get_lro_sts_push_flag(sts_data0);\r\nseq_number = qlcnic_get_lro_sts_seq_number(sts_data1);\r\nskb = qlcnic_process_rxbuf(adapter, rds_ring, index, STATUS_CKSUM_OK);\r\nif (!skb)\r\nreturn buffer;\r\nif (timestamp)\r\ndata_offset = l4_hdr_offset + QLC_TCP_TS_HDR_SIZE;\r\nelse\r\ndata_offset = l4_hdr_offset + QLC_TCP_HDR_SIZE;\r\nskb_put(skb, lro_length + data_offset);\r\nskb_pull(skb, l2_hdr_offset);\r\nif (unlikely(qlcnic_check_rx_tagging(adapter, skb, &vid))) {\r\nadapter->stats.rxdropped++;\r\ndev_kfree_skb(skb);\r\nreturn buffer;\r\n}\r\nskb->protocol = eth_type_trans(skb, netdev);\r\niph = (struct iphdr *)skb->data;\r\nth = (struct tcphdr *)(skb->data + (iph->ihl << 2));\r\nlength = (iph->ihl << 2) + (th->doff << 2) + lro_length;\r\niph->tot_len = htons(length);\r\niph->check = 0;\r\niph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);\r\nth->psh = push;\r\nth->seq = htonl(seq_number);\r\nlength = skb->len;\r\nif (vid != 0xffff)\r\n__vlan_hwaccel_put_tag(skb, vid);\r\nnetif_receive_skb(skb);\r\nadapter->stats.lro_pkts++;\r\nadapter->stats.lrobytes += length;\r\nreturn buffer;\r\n}\r\nint\r\nqlcnic_process_rcv_ring(struct qlcnic_host_sds_ring *sds_ring, int max)\r\n{\r\nstruct qlcnic_adapter *adapter = sds_ring->adapter;\r\nstruct list_head *cur;\r\nstruct status_desc *desc;\r\nstruct qlcnic_rx_buffer *rxbuf;\r\nu64 sts_data0, sts_data1;\r\nint count = 0;\r\nint opcode, ring, desc_cnt;\r\nu32 consumer = sds_ring->consumer;\r\nwhile (count < max) {\r\ndesc = &sds_ring->desc_head[consumer];\r\nsts_data0 = le64_to_cpu(desc->status_desc_data[0]);\r\nif (!(sts_data0 & STATUS_OWNER_HOST))\r\nbreak;\r\ndesc_cnt = qlcnic_get_sts_desc_cnt(sts_data0);\r\nopcode = qlcnic_get_sts_opcode(sts_data0);\r\nswitch (opcode) {\r\ncase QLCNIC_RXPKT_DESC:\r\ncase QLCNIC_OLD_RXPKT_DESC:\r\ncase QLCNIC_SYN_OFFLOAD:\r\nring = qlcnic_get_sts_type(sts_data0);\r\nrxbuf = qlcnic_process_rcv(adapter, sds_ring,\r\nring, sts_data0);\r\nbreak;\r\ncase QLCNIC_LRO_DESC:\r\nring = qlcnic_get_lro_sts_type(sts_data0);\r\nsts_data1 = le64_to_cpu(desc->status_desc_data[1]);\r\nrxbuf = qlcnic_process_lro(adapter, sds_ring,\r\nring, sts_data0, sts_data1);\r\nbreak;\r\ncase QLCNIC_RESPONSE_DESC:\r\nqlcnic_handle_fw_message(desc_cnt, consumer, sds_ring);\r\ndefault:\r\ngoto skip;\r\n}\r\nWARN_ON(desc_cnt > 1);\r\nif (likely(rxbuf))\r\nlist_add_tail(&rxbuf->list, &sds_ring->free_list[ring]);\r\nelse\r\nadapter->stats.null_rxbuf++;\r\nskip:\r\nfor (; desc_cnt > 0; desc_cnt--) {\r\ndesc = &sds_ring->desc_head[consumer];\r\ndesc->status_desc_data[0] =\r\ncpu_to_le64(STATUS_OWNER_PHANTOM);\r\nconsumer = get_next_index(consumer, sds_ring->num_desc);\r\n}\r\ncount++;\r\n}\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nstruct qlcnic_host_rds_ring *rds_ring =\r\n&adapter->recv_ctx->rds_rings[ring];\r\nif (!list_empty(&sds_ring->free_list[ring])) {\r\nlist_for_each(cur, &sds_ring->free_list[ring]) {\r\nrxbuf = list_entry(cur,\r\nstruct qlcnic_rx_buffer, list);\r\nqlcnic_alloc_rx_skb(adapter, rds_ring, rxbuf);\r\n}\r\nspin_lock(&rds_ring->lock);\r\nlist_splice_tail_init(&sds_ring->free_list[ring],\r\n&rds_ring->free_list);\r\nspin_unlock(&rds_ring->lock);\r\n}\r\nqlcnic_post_rx_buffers_nodb(adapter, rds_ring);\r\n}\r\nif (count) {\r\nsds_ring->consumer = consumer;\r\nwritel(consumer, sds_ring->crb_sts_consumer);\r\n}\r\nreturn count;\r\n}\r\nvoid\r\nqlcnic_post_rx_buffers(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_host_rds_ring *rds_ring)\r\n{\r\nstruct rcv_desc *pdesc;\r\nstruct qlcnic_rx_buffer *buffer;\r\nint count = 0;\r\nu32 producer;\r\nstruct list_head *head;\r\nproducer = rds_ring->producer;\r\nhead = &rds_ring->free_list;\r\nwhile (!list_empty(head)) {\r\nbuffer = list_entry(head->next, struct qlcnic_rx_buffer, list);\r\nif (!buffer->skb) {\r\nif (qlcnic_alloc_rx_skb(adapter, rds_ring, buffer))\r\nbreak;\r\n}\r\ncount++;\r\nlist_del(&buffer->list);\r\npdesc = &rds_ring->desc_head[producer];\r\npdesc->addr_buffer = cpu_to_le64(buffer->dma);\r\npdesc->reference_handle = cpu_to_le16(buffer->ref_handle);\r\npdesc->buffer_length = cpu_to_le32(rds_ring->dma_size);\r\nproducer = get_next_index(producer, rds_ring->num_desc);\r\n}\r\nif (count) {\r\nrds_ring->producer = producer;\r\nwritel((producer-1) & (rds_ring->num_desc-1),\r\nrds_ring->crb_rcv_producer);\r\n}\r\n}\r\nstatic void\r\nqlcnic_post_rx_buffers_nodb(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_host_rds_ring *rds_ring)\r\n{\r\nstruct rcv_desc *pdesc;\r\nstruct qlcnic_rx_buffer *buffer;\r\nint count = 0;\r\nuint32_t producer;\r\nstruct list_head *head;\r\nif (!spin_trylock(&rds_ring->lock))\r\nreturn;\r\nproducer = rds_ring->producer;\r\nhead = &rds_ring->free_list;\r\nwhile (!list_empty(head)) {\r\nbuffer = list_entry(head->next, struct qlcnic_rx_buffer, list);\r\nif (!buffer->skb) {\r\nif (qlcnic_alloc_rx_skb(adapter, rds_ring, buffer))\r\nbreak;\r\n}\r\ncount++;\r\nlist_del(&buffer->list);\r\npdesc = &rds_ring->desc_head[producer];\r\npdesc->reference_handle = cpu_to_le16(buffer->ref_handle);\r\npdesc->buffer_length = cpu_to_le32(rds_ring->dma_size);\r\npdesc->addr_buffer = cpu_to_le64(buffer->dma);\r\nproducer = get_next_index(producer, rds_ring->num_desc);\r\n}\r\nif (count) {\r\nrds_ring->producer = producer;\r\nwritel((producer - 1) & (rds_ring->num_desc - 1),\r\nrds_ring->crb_rcv_producer);\r\n}\r\nspin_unlock(&rds_ring->lock);\r\n}\r\nstatic void dump_skb(struct sk_buff *skb, struct qlcnic_adapter *adapter)\r\n{\r\nint i;\r\nunsigned char *data = skb->data;\r\nprintk(KERN_INFO "\n");\r\nfor (i = 0; i < skb->len; i++) {\r\nQLCDB(adapter, DRV, "%02x ", data[i]);\r\nif ((i & 0x0f) == 8)\r\nprintk(KERN_INFO "\n");\r\n}\r\n}\r\nvoid qlcnic_process_rcv_diag(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_host_sds_ring *sds_ring,\r\nint ring, u64 sts_data0)\r\n{\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nstruct sk_buff *skb;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nint index, length, cksum, pkt_offset;\r\nif (unlikely(ring >= adapter->max_rds_rings))\r\nreturn;\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nindex = qlcnic_get_sts_refhandle(sts_data0);\r\nlength = qlcnic_get_sts_totallength(sts_data0);\r\nif (unlikely(index >= rds_ring->num_desc))\r\nreturn;\r\ncksum = qlcnic_get_sts_status(sts_data0);\r\npkt_offset = qlcnic_get_sts_pkt_offset(sts_data0);\r\nskb = qlcnic_process_rxbuf(adapter, rds_ring, index, cksum);\r\nif (!skb)\r\nreturn;\r\nif (length > rds_ring->skb_size)\r\nskb_put(skb, rds_ring->skb_size);\r\nelse\r\nskb_put(skb, length);\r\nif (pkt_offset)\r\nskb_pull(skb, pkt_offset);\r\nif (!qlcnic_check_loopback_buff(skb->data, adapter->mac_addr))\r\nadapter->diag_cnt++;\r\nelse\r\ndump_skb(skb, adapter);\r\ndev_kfree_skb_any(skb);\r\nadapter->stats.rx_pkts++;\r\nadapter->stats.rxbytes += length;\r\nreturn;\r\n}\r\nvoid\r\nqlcnic_process_rcv_ring_diag(struct qlcnic_host_sds_ring *sds_ring)\r\n{\r\nstruct qlcnic_adapter *adapter = sds_ring->adapter;\r\nstruct status_desc *desc;\r\nu64 sts_data0;\r\nint ring, opcode, desc_cnt;\r\nu32 consumer = sds_ring->consumer;\r\ndesc = &sds_ring->desc_head[consumer];\r\nsts_data0 = le64_to_cpu(desc->status_desc_data[0]);\r\nif (!(sts_data0 & STATUS_OWNER_HOST))\r\nreturn;\r\ndesc_cnt = qlcnic_get_sts_desc_cnt(sts_data0);\r\nopcode = qlcnic_get_sts_opcode(sts_data0);\r\nswitch (opcode) {\r\ncase QLCNIC_RESPONSE_DESC:\r\nqlcnic_handle_fw_message(desc_cnt, consumer, sds_ring);\r\nbreak;\r\ndefault:\r\nring = qlcnic_get_sts_type(sts_data0);\r\nqlcnic_process_rcv_diag(adapter, sds_ring, ring, sts_data0);\r\nbreak;\r\n}\r\nfor (; desc_cnt > 0; desc_cnt--) {\r\ndesc = &sds_ring->desc_head[consumer];\r\ndesc->status_desc_data[0] = cpu_to_le64(STATUS_OWNER_PHANTOM);\r\nconsumer = get_next_index(consumer, sds_ring->num_desc);\r\n}\r\nsds_ring->consumer = consumer;\r\nwritel(consumer, sds_ring->crb_sts_consumer);\r\n}\r\nvoid\r\nqlcnic_fetch_mac(struct qlcnic_adapter *adapter, u32 off1, u32 off2,\r\nu8 alt_mac, u8 *mac)\r\n{\r\nu32 mac_low, mac_high;\r\nint i;\r\nmac_low = off1;\r\nmac_high = off2;\r\nif (alt_mac) {\r\nmac_low |= (mac_low >> 16) | (mac_high << 16);\r\nmac_high >>= 16;\r\n}\r\nfor (i = 0; i < 2; i++)\r\nmac[i] = (u8)(mac_high >> ((1 - i) * 8));\r\nfor (i = 2; i < 6; i++)\r\nmac[i] = (u8)(mac_low >> ((5 - i) * 8));\r\n}
