static int maceps2_write(struct serio *dev, unsigned char val)\r\n{\r\nstruct mace_ps2port *port = ((struct maceps2_data *)dev->port_data)->port;\r\nunsigned int timeout = MACE_PS2_TIMEOUT;\r\ndo {\r\nif (port->status & PS2_STATUS_TX_EMPTY) {\r\nport->tx = val;\r\nreturn 0;\r\n}\r\nudelay(50);\r\n} while (timeout--);\r\nreturn -1;\r\n}\r\nstatic irqreturn_t maceps2_interrupt(int irq, void *dev_id)\r\n{\r\nstruct serio *dev = dev_id;\r\nstruct mace_ps2port *port = ((struct maceps2_data *)dev->port_data)->port;\r\nunsigned long byte;\r\nif (port->status & PS2_STATUS_RX_FULL) {\r\nbyte = port->rx;\r\nserio_interrupt(dev, byte & 0xff, 0);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int maceps2_open(struct serio *dev)\r\n{\r\nstruct maceps2_data *data = (struct maceps2_data *)dev->port_data;\r\nif (request_irq(data->irq, maceps2_interrupt, 0, "PS2 port", dev)) {\r\nprintk(KERN_ERR "Could not allocate PS/2 IRQ\n");\r\nreturn -EBUSY;\r\n}\r\ndata->port->control = PS2_CONTROL_TX_CLOCK_DISABLE | PS2_CONTROL_RESET;\r\nudelay(100);\r\ndata->port->control = PS2_CONTROL_RX_CLOCK_ENABLE |\r\nPS2_CONTROL_TX_ENABLE |\r\nPS2_CONTROL_RX_INT_ENABLE;\r\nreturn 0;\r\n}\r\nstatic void maceps2_close(struct serio *dev)\r\n{\r\nstruct maceps2_data *data = (struct maceps2_data *)dev->port_data;\r\ndata->port->control = PS2_CONTROL_TX_CLOCK_DISABLE | PS2_CONTROL_RESET;\r\nudelay(100);\r\nfree_irq(data->irq, dev);\r\n}\r\nstatic struct serio * __devinit maceps2_allocate_port(int idx)\r\n{\r\nstruct serio *serio;\r\nserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (serio) {\r\nserio->id.type = SERIO_8042;\r\nserio->write = maceps2_write;\r\nserio->open = maceps2_open;\r\nserio->close = maceps2_close;\r\nsnprintf(serio->name, sizeof(serio->name), "MACE PS/2 port%d", idx);\r\nsnprintf(serio->phys, sizeof(serio->phys), "mace/serio%d", idx);\r\nserio->port_data = &port_data[idx];\r\nserio->dev.parent = &maceps2_device->dev;\r\n}\r\nreturn serio;\r\n}\r\nstatic int __devinit maceps2_probe(struct platform_device *dev)\r\n{\r\nmaceps2_port[0] = maceps2_allocate_port(0);\r\nmaceps2_port[1] = maceps2_allocate_port(1);\r\nif (!maceps2_port[0] || !maceps2_port[1]) {\r\nkfree(maceps2_port[0]);\r\nkfree(maceps2_port[1]);\r\nreturn -ENOMEM;\r\n}\r\nserio_register_port(maceps2_port[0]);\r\nserio_register_port(maceps2_port[1]);\r\nreturn 0;\r\n}\r\nstatic int __devexit maceps2_remove(struct platform_device *dev)\r\n{\r\nserio_unregister_port(maceps2_port[0]);\r\nserio_unregister_port(maceps2_port[1]);\r\nreturn 0;\r\n}\r\nstatic int __init maceps2_init(void)\r\n{\r\nint error;\r\nerror = platform_driver_register(&maceps2_driver);\r\nif (error)\r\nreturn error;\r\nmaceps2_device = platform_device_alloc("maceps2", -1);\r\nif (!maceps2_device) {\r\nerror = -ENOMEM;\r\ngoto err_unregister_driver;\r\n}\r\nport_data[0].port = &mace->perif.ps2.keyb;\r\nport_data[0].irq = MACEISA_KEYB_IRQ;\r\nport_data[1].port = &mace->perif.ps2.mouse;\r\nport_data[1].irq = MACEISA_MOUSE_IRQ;\r\nerror = platform_device_add(maceps2_device);\r\nif (error)\r\ngoto err_free_device;\r\nreturn 0;\r\nerr_free_device:\r\nplatform_device_put(maceps2_device);\r\nerr_unregister_driver:\r\nplatform_driver_unregister(&maceps2_driver);\r\nreturn error;\r\n}\r\nstatic void __exit maceps2_exit(void)\r\n{\r\nplatform_device_unregister(maceps2_device);\r\nplatform_driver_unregister(&maceps2_driver);\r\n}
