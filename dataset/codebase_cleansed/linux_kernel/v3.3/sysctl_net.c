static struct ctl_table_set *\r\nnet_ctl_header_lookup(struct ctl_table_root *root, struct nsproxy *namespaces)\r\n{\r\nreturn &namespaces->net_ns->sysctls;\r\n}\r\nstatic int is_seen(struct ctl_table_set *set)\r\n{\r\nreturn &current->nsproxy->net_ns->sysctls == set;\r\n}\r\nstatic int net_ctl_permissions(struct ctl_table_root *root,\r\nstruct nsproxy *nsproxy,\r\nstruct ctl_table *table)\r\n{\r\nif (capable(CAP_NET_ADMIN)) {\r\nint mode = (table->mode >> 6) & 7;\r\nreturn (mode << 6) | (mode << 3) | mode;\r\n}\r\nreturn table->mode;\r\n}\r\nstatic int net_ctl_ro_header_perms(struct ctl_table_root *root,\r\nstruct nsproxy *namespaces, struct ctl_table *table)\r\n{\r\nif (net_eq(namespaces->net_ns, &init_net))\r\nreturn table->mode;\r\nelse\r\nreturn table->mode & ~0222;\r\n}\r\nstatic int __net_init sysctl_net_init(struct net *net)\r\n{\r\nsetup_sysctl_set(&net->sysctls,\r\n&net_sysctl_ro_root.default_set,\r\nis_seen);\r\nreturn 0;\r\n}\r\nstatic void __net_exit sysctl_net_exit(struct net *net)\r\n{\r\nWARN_ON(!list_empty(&net->sysctls.list));\r\n}\r\nstatic __init int sysctl_init(void)\r\n{\r\nint ret;\r\nret = register_pernet_subsys(&sysctl_pernet_ops);\r\nif (ret)\r\ngoto out;\r\nregister_sysctl_root(&net_sysctl_root);\r\nsetup_sysctl_set(&net_sysctl_ro_root.default_set, NULL, NULL);\r\nregister_sysctl_root(&net_sysctl_ro_root);\r\nout:\r\nreturn ret;\r\n}\r\nstruct ctl_table_header *register_net_sysctl_table(struct net *net,\r\nconst struct ctl_path *path, struct ctl_table *table)\r\n{\r\nstruct nsproxy namespaces;\r\nnamespaces = *current->nsproxy;\r\nnamespaces.net_ns = net;\r\nreturn __register_sysctl_paths(&net_sysctl_root,\r\n&namespaces, path, table);\r\n}\r\nstruct ctl_table_header *register_net_sysctl_rotable(const\r\nstruct ctl_path *path, struct ctl_table *table)\r\n{\r\nreturn __register_sysctl_paths(&net_sysctl_ro_root,\r\n&init_nsproxy, path, table);\r\n}\r\nvoid unregister_net_sysctl_table(struct ctl_table_header *header)\r\n{\r\nunregister_sysctl_table(header);\r\n}
