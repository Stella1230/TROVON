static struct drm_mm_node *drm_mm_kmalloc(struct drm_mm *mm, int atomic)\r\n{\r\nstruct drm_mm_node *child;\r\nif (atomic)\r\nchild = kzalloc(sizeof(*child), GFP_ATOMIC);\r\nelse\r\nchild = kzalloc(sizeof(*child), GFP_KERNEL);\r\nif (unlikely(child == NULL)) {\r\nspin_lock(&mm->unused_lock);\r\nif (list_empty(&mm->unused_nodes))\r\nchild = NULL;\r\nelse {\r\nchild =\r\nlist_entry(mm->unused_nodes.next,\r\nstruct drm_mm_node, node_list);\r\nlist_del(&child->node_list);\r\n--mm->num_unused;\r\n}\r\nspin_unlock(&mm->unused_lock);\r\n}\r\nreturn child;\r\n}\r\nint drm_mm_pre_get(struct drm_mm *mm)\r\n{\r\nstruct drm_mm_node *node;\r\nspin_lock(&mm->unused_lock);\r\nwhile (mm->num_unused < MM_UNUSED_TARGET) {\r\nspin_unlock(&mm->unused_lock);\r\nnode = kzalloc(sizeof(*node), GFP_KERNEL);\r\nspin_lock(&mm->unused_lock);\r\nif (unlikely(node == NULL)) {\r\nint ret = (mm->num_unused < 2) ? -ENOMEM : 0;\r\nspin_unlock(&mm->unused_lock);\r\nreturn ret;\r\n}\r\n++mm->num_unused;\r\nlist_add_tail(&node->node_list, &mm->unused_nodes);\r\n}\r\nspin_unlock(&mm->unused_lock);\r\nreturn 0;\r\n}\r\nstatic inline unsigned long drm_mm_hole_node_start(struct drm_mm_node *hole_node)\r\n{\r\nreturn hole_node->start + hole_node->size;\r\n}\r\nstatic inline unsigned long drm_mm_hole_node_end(struct drm_mm_node *hole_node)\r\n{\r\nstruct drm_mm_node *next_node =\r\nlist_entry(hole_node->node_list.next, struct drm_mm_node,\r\nnode_list);\r\nreturn next_node->start;\r\n}\r\nstatic void drm_mm_insert_helper(struct drm_mm_node *hole_node,\r\nstruct drm_mm_node *node,\r\nunsigned long size, unsigned alignment)\r\n{\r\nstruct drm_mm *mm = hole_node->mm;\r\nunsigned long tmp = 0, wasted = 0;\r\nunsigned long hole_start = drm_mm_hole_node_start(hole_node);\r\nunsigned long hole_end = drm_mm_hole_node_end(hole_node);\r\nBUG_ON(!hole_node->hole_follows || node->allocated);\r\nif (alignment)\r\ntmp = hole_start % alignment;\r\nif (!tmp) {\r\nhole_node->hole_follows = 0;\r\nlist_del_init(&hole_node->hole_stack);\r\n} else\r\nwasted = alignment - tmp;\r\nnode->start = hole_start + wasted;\r\nnode->size = size;\r\nnode->mm = mm;\r\nnode->allocated = 1;\r\nINIT_LIST_HEAD(&node->hole_stack);\r\nlist_add(&node->node_list, &hole_node->node_list);\r\nBUG_ON(node->start + node->size > hole_end);\r\nif (node->start + node->size < hole_end) {\r\nlist_add(&node->hole_stack, &mm->hole_stack);\r\nnode->hole_follows = 1;\r\n} else {\r\nnode->hole_follows = 0;\r\n}\r\n}\r\nstruct drm_mm_node *drm_mm_get_block_generic(struct drm_mm_node *hole_node,\r\nunsigned long size,\r\nunsigned alignment,\r\nint atomic)\r\n{\r\nstruct drm_mm_node *node;\r\nnode = drm_mm_kmalloc(hole_node->mm, atomic);\r\nif (unlikely(node == NULL))\r\nreturn NULL;\r\ndrm_mm_insert_helper(hole_node, node, size, alignment);\r\nreturn node;\r\n}\r\nint drm_mm_insert_node(struct drm_mm *mm, struct drm_mm_node *node,\r\nunsigned long size, unsigned alignment)\r\n{\r\nstruct drm_mm_node *hole_node;\r\nhole_node = drm_mm_search_free(mm, size, alignment, 0);\r\nif (!hole_node)\r\nreturn -ENOSPC;\r\ndrm_mm_insert_helper(hole_node, node, size, alignment);\r\nreturn 0;\r\n}\r\nstatic void drm_mm_insert_helper_range(struct drm_mm_node *hole_node,\r\nstruct drm_mm_node *node,\r\nunsigned long size, unsigned alignment,\r\nunsigned long start, unsigned long end)\r\n{\r\nstruct drm_mm *mm = hole_node->mm;\r\nunsigned long tmp = 0, wasted = 0;\r\nunsigned long hole_start = drm_mm_hole_node_start(hole_node);\r\nunsigned long hole_end = drm_mm_hole_node_end(hole_node);\r\nBUG_ON(!hole_node->hole_follows || node->allocated);\r\nif (hole_start < start)\r\nwasted += start - hole_start;\r\nif (alignment)\r\ntmp = (hole_start + wasted) % alignment;\r\nif (tmp)\r\nwasted += alignment - tmp;\r\nif (!wasted) {\r\nhole_node->hole_follows = 0;\r\nlist_del_init(&hole_node->hole_stack);\r\n}\r\nnode->start = hole_start + wasted;\r\nnode->size = size;\r\nnode->mm = mm;\r\nnode->allocated = 1;\r\nINIT_LIST_HEAD(&node->hole_stack);\r\nlist_add(&node->node_list, &hole_node->node_list);\r\nBUG_ON(node->start + node->size > hole_end);\r\nBUG_ON(node->start + node->size > end);\r\nif (node->start + node->size < hole_end) {\r\nlist_add(&node->hole_stack, &mm->hole_stack);\r\nnode->hole_follows = 1;\r\n} else {\r\nnode->hole_follows = 0;\r\n}\r\n}\r\nstruct drm_mm_node *drm_mm_get_block_range_generic(struct drm_mm_node *hole_node,\r\nunsigned long size,\r\nunsigned alignment,\r\nunsigned long start,\r\nunsigned long end,\r\nint atomic)\r\n{\r\nstruct drm_mm_node *node;\r\nnode = drm_mm_kmalloc(hole_node->mm, atomic);\r\nif (unlikely(node == NULL))\r\nreturn NULL;\r\ndrm_mm_insert_helper_range(hole_node, node, size, alignment,\r\nstart, end);\r\nreturn node;\r\n}\r\nint drm_mm_insert_node_in_range(struct drm_mm *mm, struct drm_mm_node *node,\r\nunsigned long size, unsigned alignment,\r\nunsigned long start, unsigned long end)\r\n{\r\nstruct drm_mm_node *hole_node;\r\nhole_node = drm_mm_search_free_in_range(mm, size, alignment,\r\nstart, end, 0);\r\nif (!hole_node)\r\nreturn -ENOSPC;\r\ndrm_mm_insert_helper_range(hole_node, node, size, alignment,\r\nstart, end);\r\nreturn 0;\r\n}\r\nvoid drm_mm_remove_node(struct drm_mm_node *node)\r\n{\r\nstruct drm_mm *mm = node->mm;\r\nstruct drm_mm_node *prev_node;\r\nBUG_ON(node->scanned_block || node->scanned_prev_free\r\n|| node->scanned_next_free);\r\nprev_node =\r\nlist_entry(node->node_list.prev, struct drm_mm_node, node_list);\r\nif (node->hole_follows) {\r\nBUG_ON(drm_mm_hole_node_start(node)\r\n== drm_mm_hole_node_end(node));\r\nlist_del(&node->hole_stack);\r\n} else\r\nBUG_ON(drm_mm_hole_node_start(node)\r\n!= drm_mm_hole_node_end(node));\r\nif (!prev_node->hole_follows) {\r\nprev_node->hole_follows = 1;\r\nlist_add(&prev_node->hole_stack, &mm->hole_stack);\r\n} else\r\nlist_move(&prev_node->hole_stack, &mm->hole_stack);\r\nlist_del(&node->node_list);\r\nnode->allocated = 0;\r\n}\r\nvoid drm_mm_put_block(struct drm_mm_node *node)\r\n{\r\nstruct drm_mm *mm = node->mm;\r\ndrm_mm_remove_node(node);\r\nspin_lock(&mm->unused_lock);\r\nif (mm->num_unused < MM_UNUSED_TARGET) {\r\nlist_add(&node->node_list, &mm->unused_nodes);\r\n++mm->num_unused;\r\n} else\r\nkfree(node);\r\nspin_unlock(&mm->unused_lock);\r\n}\r\nstatic int check_free_hole(unsigned long start, unsigned long end,\r\nunsigned long size, unsigned alignment)\r\n{\r\nunsigned wasted = 0;\r\nif (end - start < size)\r\nreturn 0;\r\nif (alignment) {\r\nunsigned tmp = start % alignment;\r\nif (tmp)\r\nwasted = alignment - tmp;\r\n}\r\nif (end >= start + size + wasted) {\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstruct drm_mm_node *drm_mm_search_free(const struct drm_mm *mm,\r\nunsigned long size,\r\nunsigned alignment, int best_match)\r\n{\r\nstruct drm_mm_node *entry;\r\nstruct drm_mm_node *best;\r\nunsigned long best_size;\r\nBUG_ON(mm->scanned_blocks);\r\nbest = NULL;\r\nbest_size = ~0UL;\r\nlist_for_each_entry(entry, &mm->hole_stack, hole_stack) {\r\nBUG_ON(!entry->hole_follows);\r\nif (!check_free_hole(drm_mm_hole_node_start(entry),\r\ndrm_mm_hole_node_end(entry),\r\nsize, alignment))\r\ncontinue;\r\nif (!best_match)\r\nreturn entry;\r\nif (entry->size < best_size) {\r\nbest = entry;\r\nbest_size = entry->size;\r\n}\r\n}\r\nreturn best;\r\n}\r\nstruct drm_mm_node *drm_mm_search_free_in_range(const struct drm_mm *mm,\r\nunsigned long size,\r\nunsigned alignment,\r\nunsigned long start,\r\nunsigned long end,\r\nint best_match)\r\n{\r\nstruct drm_mm_node *entry;\r\nstruct drm_mm_node *best;\r\nunsigned long best_size;\r\nBUG_ON(mm->scanned_blocks);\r\nbest = NULL;\r\nbest_size = ~0UL;\r\nlist_for_each_entry(entry, &mm->hole_stack, hole_stack) {\r\nunsigned long adj_start = drm_mm_hole_node_start(entry) < start ?\r\nstart : drm_mm_hole_node_start(entry);\r\nunsigned long adj_end = drm_mm_hole_node_end(entry) > end ?\r\nend : drm_mm_hole_node_end(entry);\r\nBUG_ON(!entry->hole_follows);\r\nif (!check_free_hole(adj_start, adj_end, size, alignment))\r\ncontinue;\r\nif (!best_match)\r\nreturn entry;\r\nif (entry->size < best_size) {\r\nbest = entry;\r\nbest_size = entry->size;\r\n}\r\n}\r\nreturn best;\r\n}\r\nvoid drm_mm_replace_node(struct drm_mm_node *old, struct drm_mm_node *new)\r\n{\r\nlist_replace(&old->node_list, &new->node_list);\r\nlist_replace(&old->hole_stack, &new->hole_stack);\r\nnew->hole_follows = old->hole_follows;\r\nnew->mm = old->mm;\r\nnew->start = old->start;\r\nnew->size = old->size;\r\nold->allocated = 0;\r\nnew->allocated = 1;\r\n}\r\nvoid drm_mm_init_scan(struct drm_mm *mm, unsigned long size,\r\nunsigned alignment)\r\n{\r\nmm->scan_alignment = alignment;\r\nmm->scan_size = size;\r\nmm->scanned_blocks = 0;\r\nmm->scan_hit_start = 0;\r\nmm->scan_hit_size = 0;\r\nmm->scan_check_range = 0;\r\nmm->prev_scanned_node = NULL;\r\n}\r\nvoid drm_mm_init_scan_with_range(struct drm_mm *mm, unsigned long size,\r\nunsigned alignment,\r\nunsigned long start,\r\nunsigned long end)\r\n{\r\nmm->scan_alignment = alignment;\r\nmm->scan_size = size;\r\nmm->scanned_blocks = 0;\r\nmm->scan_hit_start = 0;\r\nmm->scan_hit_size = 0;\r\nmm->scan_start = start;\r\nmm->scan_end = end;\r\nmm->scan_check_range = 1;\r\nmm->prev_scanned_node = NULL;\r\n}\r\nint drm_mm_scan_add_block(struct drm_mm_node *node)\r\n{\r\nstruct drm_mm *mm = node->mm;\r\nstruct drm_mm_node *prev_node;\r\nunsigned long hole_start, hole_end;\r\nunsigned long adj_start;\r\nunsigned long adj_end;\r\nmm->scanned_blocks++;\r\nBUG_ON(node->scanned_block);\r\nnode->scanned_block = 1;\r\nprev_node = list_entry(node->node_list.prev, struct drm_mm_node,\r\nnode_list);\r\nnode->scanned_preceeds_hole = prev_node->hole_follows;\r\nprev_node->hole_follows = 1;\r\nlist_del(&node->node_list);\r\nnode->node_list.prev = &prev_node->node_list;\r\nnode->node_list.next = &mm->prev_scanned_node->node_list;\r\nmm->prev_scanned_node = node;\r\nhole_start = drm_mm_hole_node_start(prev_node);\r\nhole_end = drm_mm_hole_node_end(prev_node);\r\nif (mm->scan_check_range) {\r\nadj_start = hole_start < mm->scan_start ?\r\nmm->scan_start : hole_start;\r\nadj_end = hole_end > mm->scan_end ?\r\nmm->scan_end : hole_end;\r\n} else {\r\nadj_start = hole_start;\r\nadj_end = hole_end;\r\n}\r\nif (check_free_hole(adj_start , adj_end,\r\nmm->scan_size, mm->scan_alignment)) {\r\nmm->scan_hit_start = hole_start;\r\nmm->scan_hit_size = hole_end;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint drm_mm_scan_remove_block(struct drm_mm_node *node)\r\n{\r\nstruct drm_mm *mm = node->mm;\r\nstruct drm_mm_node *prev_node;\r\nmm->scanned_blocks--;\r\nBUG_ON(!node->scanned_block);\r\nnode->scanned_block = 0;\r\nprev_node = list_entry(node->node_list.prev, struct drm_mm_node,\r\nnode_list);\r\nprev_node->hole_follows = node->scanned_preceeds_hole;\r\nINIT_LIST_HEAD(&node->node_list);\r\nlist_add(&node->node_list, &prev_node->node_list);\r\nif (node->start >= mm->scan_hit_start &&\r\nnode->start + node->size\r\n<= mm->scan_hit_start + mm->scan_hit_size) {\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint drm_mm_clean(struct drm_mm * mm)\r\n{\r\nstruct list_head *head = &mm->head_node.node_list;\r\nreturn (head->next->next == head);\r\n}\r\nint drm_mm_init(struct drm_mm * mm, unsigned long start, unsigned long size)\r\n{\r\nINIT_LIST_HEAD(&mm->hole_stack);\r\nINIT_LIST_HEAD(&mm->unused_nodes);\r\nmm->num_unused = 0;\r\nmm->scanned_blocks = 0;\r\nspin_lock_init(&mm->unused_lock);\r\nINIT_LIST_HEAD(&mm->head_node.node_list);\r\nINIT_LIST_HEAD(&mm->head_node.hole_stack);\r\nmm->head_node.hole_follows = 1;\r\nmm->head_node.scanned_block = 0;\r\nmm->head_node.scanned_prev_free = 0;\r\nmm->head_node.scanned_next_free = 0;\r\nmm->head_node.mm = mm;\r\nmm->head_node.start = start + size;\r\nmm->head_node.size = start - mm->head_node.start;\r\nlist_add_tail(&mm->head_node.hole_stack, &mm->hole_stack);\r\nreturn 0;\r\n}\r\nvoid drm_mm_takedown(struct drm_mm * mm)\r\n{\r\nstruct drm_mm_node *entry, *next;\r\nif (!list_empty(&mm->head_node.node_list)) {\r\nDRM_ERROR("Memory manager not clean. Delaying takedown\n");\r\nreturn;\r\n}\r\nspin_lock(&mm->unused_lock);\r\nlist_for_each_entry_safe(entry, next, &mm->unused_nodes, node_list) {\r\nlist_del(&entry->node_list);\r\nkfree(entry);\r\n--mm->num_unused;\r\n}\r\nspin_unlock(&mm->unused_lock);\r\nBUG_ON(mm->num_unused != 0);\r\n}\r\nvoid drm_mm_debug_table(struct drm_mm *mm, const char *prefix)\r\n{\r\nstruct drm_mm_node *entry;\r\nunsigned long total_used = 0, total_free = 0, total = 0;\r\nunsigned long hole_start, hole_end, hole_size;\r\nhole_start = drm_mm_hole_node_start(&mm->head_node);\r\nhole_end = drm_mm_hole_node_end(&mm->head_node);\r\nhole_size = hole_end - hole_start;\r\nif (hole_size)\r\nprintk(KERN_DEBUG "%s 0x%08lx-0x%08lx: %8lu: free\n",\r\nprefix, hole_start, hole_end,\r\nhole_size);\r\ntotal_free += hole_size;\r\ndrm_mm_for_each_node(entry, mm) {\r\nprintk(KERN_DEBUG "%s 0x%08lx-0x%08lx: %8lu: used\n",\r\nprefix, entry->start, entry->start + entry->size,\r\nentry->size);\r\ntotal_used += entry->size;\r\nif (entry->hole_follows) {\r\nhole_start = drm_mm_hole_node_start(entry);\r\nhole_end = drm_mm_hole_node_end(entry);\r\nhole_size = hole_end - hole_start;\r\nprintk(KERN_DEBUG "%s 0x%08lx-0x%08lx: %8lu: free\n",\r\nprefix, hole_start, hole_end,\r\nhole_size);\r\ntotal_free += hole_size;\r\n}\r\n}\r\ntotal = total_free + total_used;\r\nprintk(KERN_DEBUG "%s total: %lu, used %lu free %lu\n", prefix, total,\r\ntotal_used, total_free);\r\n}\r\nint drm_mm_dump_table(struct seq_file *m, struct drm_mm *mm)\r\n{\r\nstruct drm_mm_node *entry;\r\nunsigned long total_used = 0, total_free = 0, total = 0;\r\nunsigned long hole_start, hole_end, hole_size;\r\nhole_start = drm_mm_hole_node_start(&mm->head_node);\r\nhole_end = drm_mm_hole_node_end(&mm->head_node);\r\nhole_size = hole_end - hole_start;\r\nif (hole_size)\r\nseq_printf(m, "0x%08lx-0x%08lx: 0x%08lx: free\n",\r\nhole_start, hole_end, hole_size);\r\ntotal_free += hole_size;\r\ndrm_mm_for_each_node(entry, mm) {\r\nseq_printf(m, "0x%08lx-0x%08lx: 0x%08lx: used\n",\r\nentry->start, entry->start + entry->size,\r\nentry->size);\r\ntotal_used += entry->size;\r\nif (entry->hole_follows) {\r\nhole_start = drm_mm_hole_node_start(entry);\r\nhole_end = drm_mm_hole_node_end(entry);\r\nhole_size = hole_end - hole_start;\r\nseq_printf(m, "0x%08lx-0x%08lx: 0x%08lx: free\n",\r\nhole_start, hole_end, hole_size);\r\ntotal_free += hole_size;\r\n}\r\n}\r\ntotal = total_free + total_used;\r\nseq_printf(m, "total: %lu, used %lu free %lu\n", total, total_used, total_free);\r\nreturn 0;\r\n}
