static int __find_main_battery(struct device *dev, void *data)\r\n{\r\nstruct find_bat_param *bp = (struct find_bat_param *)data;\r\nbp->bat = dev_get_drvdata(dev);\r\nif (bp->bat->use_for_apm) {\r\nbp->main = bp->bat;\r\nreturn 1;\r\n}\r\nif (!PSY_PROP(bp->bat, CHARGE_FULL_DESIGN, &bp->full) ||\r\n!PSY_PROP(bp->bat, CHARGE_FULL, &bp->full)) {\r\nif (bp->full.intval > bp->max_charge) {\r\nbp->max_charge_bat = bp->bat;\r\nbp->max_charge = bp->full.intval;\r\n}\r\n} else if (!PSY_PROP(bp->bat, ENERGY_FULL_DESIGN, &bp->full) ||\r\n!PSY_PROP(bp->bat, ENERGY_FULL, &bp->full)) {\r\nif (bp->full.intval > bp->max_energy) {\r\nbp->max_energy_bat = bp->bat;\r\nbp->max_energy = bp->full.intval;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void find_main_battery(void)\r\n{\r\nstruct find_bat_param bp;\r\nint error;\r\nmemset(&bp, 0, sizeof(struct find_bat_param));\r\nmain_battery = NULL;\r\nbp.main = main_battery;\r\nerror = class_for_each_device(power_supply_class, NULL, &bp,\r\n__find_main_battery);\r\nif (error) {\r\nmain_battery = bp.main;\r\nreturn;\r\n}\r\nif ((bp.max_energy_bat && bp.max_charge_bat) &&\r\n(bp.max_energy_bat != bp.max_charge_bat)) {\r\nif (!PSY_PROP(bp.max_charge_bat, VOLTAGE_MAX_DESIGN,\r\n&bp.full)) {\r\nif (bp.max_energy > bp.max_charge * bp.full.intval)\r\nmain_battery = bp.max_energy_bat;\r\nelse\r\nmain_battery = bp.max_charge_bat;\r\n} else if (!PSY_PROP(bp.max_energy_bat, VOLTAGE_MAX_DESIGN,\r\n&bp.full)) {\r\nif (bp.max_charge > bp.max_energy / bp.full.intval)\r\nmain_battery = bp.max_charge_bat;\r\nelse\r\nmain_battery = bp.max_energy_bat;\r\n} else {\r\nmain_battery = bp.max_energy_bat;\r\n}\r\n} else if (bp.max_charge_bat) {\r\nmain_battery = bp.max_charge_bat;\r\n} else if (bp.max_energy_bat) {\r\nmain_battery = bp.max_energy_bat;\r\n} else {\r\nmain_battery = bp.bat;\r\n}\r\n}\r\nstatic int do_calculate_time(int status, enum apm_source source)\r\n{\r\nunion power_supply_propval full;\r\nunion power_supply_propval empty;\r\nunion power_supply_propval cur;\r\nunion power_supply_propval I;\r\nenum power_supply_property full_prop;\r\nenum power_supply_property full_design_prop;\r\nenum power_supply_property empty_prop;\r\nenum power_supply_property empty_design_prop;\r\nenum power_supply_property cur_avg_prop;\r\nenum power_supply_property cur_now_prop;\r\nif (MPSY_PROP(CURRENT_AVG, &I)) {\r\nif (MPSY_PROP(CURRENT_NOW, &I))\r\nreturn -1;\r\n}\r\nif (!I.intval)\r\nreturn 0;\r\nswitch (source) {\r\ncase SOURCE_CHARGE:\r\nfull_prop = POWER_SUPPLY_PROP_CHARGE_FULL;\r\nfull_design_prop = POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN;\r\nempty_prop = POWER_SUPPLY_PROP_CHARGE_EMPTY;\r\nempty_design_prop = POWER_SUPPLY_PROP_CHARGE_EMPTY;\r\ncur_avg_prop = POWER_SUPPLY_PROP_CHARGE_AVG;\r\ncur_now_prop = POWER_SUPPLY_PROP_CHARGE_NOW;\r\nbreak;\r\ncase SOURCE_ENERGY:\r\nfull_prop = POWER_SUPPLY_PROP_ENERGY_FULL;\r\nfull_design_prop = POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN;\r\nempty_prop = POWER_SUPPLY_PROP_ENERGY_EMPTY;\r\nempty_design_prop = POWER_SUPPLY_PROP_CHARGE_EMPTY;\r\ncur_avg_prop = POWER_SUPPLY_PROP_ENERGY_AVG;\r\ncur_now_prop = POWER_SUPPLY_PROP_ENERGY_NOW;\r\nbreak;\r\ncase SOURCE_VOLTAGE:\r\nfull_prop = POWER_SUPPLY_PROP_VOLTAGE_MAX;\r\nfull_design_prop = POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN;\r\nempty_prop = POWER_SUPPLY_PROP_VOLTAGE_MIN;\r\nempty_design_prop = POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN;\r\ncur_avg_prop = POWER_SUPPLY_PROP_VOLTAGE_AVG;\r\ncur_now_prop = POWER_SUPPLY_PROP_VOLTAGE_NOW;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Unsupported source: %d\n", source);\r\nreturn -1;\r\n}\r\nif (_MPSY_PROP(full_prop, &full)) {\r\nif (_MPSY_PROP(full_design_prop, &full))\r\nreturn -1;\r\n}\r\nif (_MPSY_PROP(empty_prop, &empty)) {\r\nif (_MPSY_PROP(empty_design_prop, &empty))\r\nempty.intval = 0;\r\n}\r\nif (_MPSY_PROP(cur_avg_prop, &cur)) {\r\nif (_MPSY_PROP(cur_now_prop, &cur))\r\nreturn -1;\r\n}\r\nif (status == POWER_SUPPLY_STATUS_CHARGING)\r\nreturn ((cur.intval - full.intval) * 60L) / I.intval;\r\nelse\r\nreturn -((cur.intval - empty.intval) * 60L) / I.intval;\r\n}\r\nstatic int calculate_time(int status)\r\n{\r\nint time;\r\ntime = do_calculate_time(status, SOURCE_ENERGY);\r\nif (time != -1)\r\nreturn time;\r\ntime = do_calculate_time(status, SOURCE_CHARGE);\r\nif (time != -1)\r\nreturn time;\r\ntime = do_calculate_time(status, SOURCE_VOLTAGE);\r\nif (time != -1)\r\nreturn time;\r\nreturn -1;\r\n}\r\nstatic int calculate_capacity(enum apm_source source)\r\n{\r\nenum power_supply_property full_prop, empty_prop;\r\nenum power_supply_property full_design_prop, empty_design_prop;\r\nenum power_supply_property now_prop, avg_prop;\r\nunion power_supply_propval empty, full, cur;\r\nint ret;\r\nswitch (source) {\r\ncase SOURCE_CHARGE:\r\nfull_prop = POWER_SUPPLY_PROP_CHARGE_FULL;\r\nempty_prop = POWER_SUPPLY_PROP_CHARGE_EMPTY;\r\nfull_design_prop = POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN;\r\nempty_design_prop = POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN;\r\nnow_prop = POWER_SUPPLY_PROP_CHARGE_NOW;\r\navg_prop = POWER_SUPPLY_PROP_CHARGE_AVG;\r\nbreak;\r\ncase SOURCE_ENERGY:\r\nfull_prop = POWER_SUPPLY_PROP_ENERGY_FULL;\r\nempty_prop = POWER_SUPPLY_PROP_ENERGY_EMPTY;\r\nfull_design_prop = POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN;\r\nempty_design_prop = POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN;\r\nnow_prop = POWER_SUPPLY_PROP_ENERGY_NOW;\r\navg_prop = POWER_SUPPLY_PROP_ENERGY_AVG;\r\nbreak;\r\ncase SOURCE_VOLTAGE:\r\nfull_prop = POWER_SUPPLY_PROP_VOLTAGE_MAX;\r\nempty_prop = POWER_SUPPLY_PROP_VOLTAGE_MIN;\r\nfull_design_prop = POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN;\r\nempty_design_prop = POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN;\r\nnow_prop = POWER_SUPPLY_PROP_VOLTAGE_NOW;\r\navg_prop = POWER_SUPPLY_PROP_VOLTAGE_AVG;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Unsupported source: %d\n", source);\r\nreturn -1;\r\n}\r\nif (_MPSY_PROP(full_prop, &full)) {\r\nif (_MPSY_PROP(full_design_prop, &full))\r\nreturn -1;\r\n}\r\nif (_MPSY_PROP(avg_prop, &cur)) {\r\nif (_MPSY_PROP(now_prop, &cur))\r\nreturn -1;\r\n}\r\nif (_MPSY_PROP(empty_prop, &empty)) {\r\nif (_MPSY_PROP(empty_design_prop, &empty))\r\nempty.intval = 0;\r\n}\r\nif (full.intval - empty.intval)\r\nret = ((cur.intval - empty.intval) * 100L) /\r\n(full.intval - empty.intval);\r\nelse\r\nreturn -1;\r\nif (ret > 100)\r\nreturn 100;\r\nelse if (ret < 0)\r\nreturn 0;\r\nreturn ret;\r\n}\r\nstatic void apm_battery_apm_get_power_status(struct apm_power_info *info)\r\n{\r\nunion power_supply_propval status;\r\nunion power_supply_propval capacity, time_to_full, time_to_empty;\r\nmutex_lock(&apm_mutex);\r\nfind_main_battery();\r\nif (!main_battery) {\r\nmutex_unlock(&apm_mutex);\r\nreturn;\r\n}\r\nif (MPSY_PROP(STATUS, &status))\r\nstatus.intval = POWER_SUPPLY_STATUS_UNKNOWN;\r\nif ((status.intval == POWER_SUPPLY_STATUS_CHARGING) ||\r\n(status.intval == POWER_SUPPLY_STATUS_NOT_CHARGING) ||\r\n(status.intval == POWER_SUPPLY_STATUS_FULL))\r\ninfo->ac_line_status = APM_AC_ONLINE;\r\nelse\r\ninfo->ac_line_status = APM_AC_OFFLINE;\r\nif (MPSY_PROP(CAPACITY, &capacity) == 0) {\r\ninfo->battery_life = capacity.intval;\r\n} else {\r\ninfo->battery_life = calculate_capacity(SOURCE_ENERGY);\r\nif (info->battery_life == -1)\r\ninfo->battery_life = calculate_capacity(SOURCE_CHARGE);\r\nif (info->battery_life == -1)\r\ninfo->battery_life = calculate_capacity(SOURCE_VOLTAGE);\r\n}\r\nif (status.intval == POWER_SUPPLY_STATUS_CHARGING) {\r\ninfo->battery_status = APM_BATTERY_STATUS_CHARGING;\r\n} else {\r\nif (info->battery_life > 50)\r\ninfo->battery_status = APM_BATTERY_STATUS_HIGH;\r\nelse if (info->battery_life > 5)\r\ninfo->battery_status = APM_BATTERY_STATUS_LOW;\r\nelse\r\ninfo->battery_status = APM_BATTERY_STATUS_CRITICAL;\r\n}\r\ninfo->battery_flag = info->battery_status;\r\ninfo->units = APM_UNITS_MINS;\r\nif (status.intval == POWER_SUPPLY_STATUS_CHARGING) {\r\nif (!MPSY_PROP(TIME_TO_FULL_AVG, &time_to_full) ||\r\n!MPSY_PROP(TIME_TO_FULL_NOW, &time_to_full))\r\ninfo->time = time_to_full.intval / 60;\r\nelse\r\ninfo->time = calculate_time(status.intval);\r\n} else {\r\nif (!MPSY_PROP(TIME_TO_EMPTY_AVG, &time_to_empty) ||\r\n!MPSY_PROP(TIME_TO_EMPTY_NOW, &time_to_empty))\r\ninfo->time = time_to_empty.intval / 60;\r\nelse\r\ninfo->time = calculate_time(status.intval);\r\n}\r\nmutex_unlock(&apm_mutex);\r\n}\r\nstatic int __init apm_battery_init(void)\r\n{\r\nprintk(KERN_INFO "APM Battery Driver\n");\r\napm_get_power_status = apm_battery_apm_get_power_status;\r\nreturn 0;\r\n}\r\nstatic void __exit apm_battery_exit(void)\r\n{\r\napm_get_power_status = NULL;\r\n}
