static inline struct mthca_cqe *get_cqe_from_buf(struct mthca_cq_buf *buf,\r\nint entry)\r\n{\r\nif (buf->is_direct)\r\nreturn buf->queue.direct.buf + (entry * MTHCA_CQ_ENTRY_SIZE);\r\nelse\r\nreturn buf->queue.page_list[entry * MTHCA_CQ_ENTRY_SIZE / PAGE_SIZE].buf\r\n+ (entry * MTHCA_CQ_ENTRY_SIZE) % PAGE_SIZE;\r\n}\r\nstatic inline struct mthca_cqe *get_cqe(struct mthca_cq *cq, int entry)\r\n{\r\nreturn get_cqe_from_buf(&cq->buf, entry);\r\n}\r\nstatic inline struct mthca_cqe *cqe_sw(struct mthca_cqe *cqe)\r\n{\r\nreturn MTHCA_CQ_ENTRY_OWNER_HW & cqe->owner ? NULL : cqe;\r\n}\r\nstatic inline struct mthca_cqe *next_cqe_sw(struct mthca_cq *cq)\r\n{\r\nreturn cqe_sw(get_cqe(cq, cq->cons_index & cq->ibcq.cqe));\r\n}\r\nstatic inline void set_cqe_hw(struct mthca_cqe *cqe)\r\n{\r\ncqe->owner = MTHCA_CQ_ENTRY_OWNER_HW;\r\n}\r\nstatic void dump_cqe(struct mthca_dev *dev, void *cqe_ptr)\r\n{\r\n__be32 *cqe = cqe_ptr;\r\n(void) cqe;\r\nmthca_dbg(dev, "CQE contents %08x %08x %08x %08x %08x %08x %08x %08x\n",\r\nbe32_to_cpu(cqe[0]), be32_to_cpu(cqe[1]), be32_to_cpu(cqe[2]),\r\nbe32_to_cpu(cqe[3]), be32_to_cpu(cqe[4]), be32_to_cpu(cqe[5]),\r\nbe32_to_cpu(cqe[6]), be32_to_cpu(cqe[7]));\r\n}\r\nstatic inline void update_cons_index(struct mthca_dev *dev, struct mthca_cq *cq,\r\nint incr)\r\n{\r\nif (mthca_is_memfree(dev)) {\r\n*cq->set_ci_db = cpu_to_be32(cq->cons_index);\r\nwmb();\r\n} else {\r\nmthca_write64(MTHCA_TAVOR_CQ_DB_INC_CI | cq->cqn, incr - 1,\r\ndev->kar + MTHCA_CQ_DOORBELL,\r\nMTHCA_GET_DOORBELL_LOCK(&dev->doorbell_lock));\r\nmmiowb();\r\n}\r\n}\r\nvoid mthca_cq_completion(struct mthca_dev *dev, u32 cqn)\r\n{\r\nstruct mthca_cq *cq;\r\ncq = mthca_array_get(&dev->cq_table.cq, cqn & (dev->limits.num_cqs - 1));\r\nif (!cq) {\r\nmthca_warn(dev, "Completion event for bogus CQ %08x\n", cqn);\r\nreturn;\r\n}\r\n++cq->arm_sn;\r\ncq->ibcq.comp_handler(&cq->ibcq, cq->ibcq.cq_context);\r\n}\r\nvoid mthca_cq_event(struct mthca_dev *dev, u32 cqn,\r\nenum ib_event_type event_type)\r\n{\r\nstruct mthca_cq *cq;\r\nstruct ib_event event;\r\nspin_lock(&dev->cq_table.lock);\r\ncq = mthca_array_get(&dev->cq_table.cq, cqn & (dev->limits.num_cqs - 1));\r\nif (cq)\r\n++cq->refcount;\r\nspin_unlock(&dev->cq_table.lock);\r\nif (!cq) {\r\nmthca_warn(dev, "Async event for bogus CQ %08x\n", cqn);\r\nreturn;\r\n}\r\nevent.device = &dev->ib_dev;\r\nevent.event = event_type;\r\nevent.element.cq = &cq->ibcq;\r\nif (cq->ibcq.event_handler)\r\ncq->ibcq.event_handler(&event, cq->ibcq.cq_context);\r\nspin_lock(&dev->cq_table.lock);\r\nif (!--cq->refcount)\r\nwake_up(&cq->wait);\r\nspin_unlock(&dev->cq_table.lock);\r\n}\r\nstatic inline int is_recv_cqe(struct mthca_cqe *cqe)\r\n{\r\nif ((cqe->opcode & MTHCA_ERROR_CQE_OPCODE_MASK) ==\r\nMTHCA_ERROR_CQE_OPCODE_MASK)\r\nreturn !(cqe->opcode & 0x01);\r\nelse\r\nreturn !(cqe->is_send & 0x80);\r\n}\r\nvoid mthca_cq_clean(struct mthca_dev *dev, struct mthca_cq *cq, u32 qpn,\r\nstruct mthca_srq *srq)\r\n{\r\nstruct mthca_cqe *cqe;\r\nu32 prod_index;\r\nint i, nfreed = 0;\r\nspin_lock_irq(&cq->lock);\r\nfor (prod_index = cq->cons_index;\r\ncqe_sw(get_cqe(cq, prod_index & cq->ibcq.cqe));\r\n++prod_index)\r\nif (prod_index == cq->cons_index + cq->ibcq.cqe)\r\nbreak;\r\nif (0)\r\nmthca_dbg(dev, "Cleaning QPN %06x from CQN %06x; ci %d, pi %d\n",\r\nqpn, cq->cqn, cq->cons_index, prod_index);\r\nwhile ((int) --prod_index - (int) cq->cons_index >= 0) {\r\ncqe = get_cqe(cq, prod_index & cq->ibcq.cqe);\r\nif (cqe->my_qpn == cpu_to_be32(qpn)) {\r\nif (srq && is_recv_cqe(cqe))\r\nmthca_free_srq_wqe(srq, be32_to_cpu(cqe->wqe));\r\n++nfreed;\r\n} else if (nfreed)\r\nmemcpy(get_cqe(cq, (prod_index + nfreed) & cq->ibcq.cqe),\r\ncqe, MTHCA_CQ_ENTRY_SIZE);\r\n}\r\nif (nfreed) {\r\nfor (i = 0; i < nfreed; ++i)\r\nset_cqe_hw(get_cqe(cq, (cq->cons_index + i) & cq->ibcq.cqe));\r\nwmb();\r\ncq->cons_index += nfreed;\r\nupdate_cons_index(dev, cq, nfreed);\r\n}\r\nspin_unlock_irq(&cq->lock);\r\n}\r\nvoid mthca_cq_resize_copy_cqes(struct mthca_cq *cq)\r\n{\r\nint i;\r\nif (!mthca_is_memfree(to_mdev(cq->ibcq.device)) &&\r\ncq->ibcq.cqe < cq->resize_buf->cqe) {\r\ncq->cons_index &= cq->ibcq.cqe;\r\nif (cqe_sw(get_cqe(cq, cq->ibcq.cqe)))\r\ncq->cons_index -= cq->ibcq.cqe + 1;\r\n}\r\nfor (i = cq->cons_index; cqe_sw(get_cqe(cq, i & cq->ibcq.cqe)); ++i)\r\nmemcpy(get_cqe_from_buf(&cq->resize_buf->buf,\r\ni & cq->resize_buf->cqe),\r\nget_cqe(cq, i & cq->ibcq.cqe), MTHCA_CQ_ENTRY_SIZE);\r\n}\r\nint mthca_alloc_cq_buf(struct mthca_dev *dev, struct mthca_cq_buf *buf, int nent)\r\n{\r\nint ret;\r\nint i;\r\nret = mthca_buf_alloc(dev, nent * MTHCA_CQ_ENTRY_SIZE,\r\nMTHCA_MAX_DIRECT_CQ_SIZE,\r\n&buf->queue, &buf->is_direct,\r\n&dev->driver_pd, 1, &buf->mr);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < nent; ++i)\r\nset_cqe_hw(get_cqe_from_buf(buf, i));\r\nreturn 0;\r\n}\r\nvoid mthca_free_cq_buf(struct mthca_dev *dev, struct mthca_cq_buf *buf, int cqe)\r\n{\r\nmthca_buf_free(dev, (cqe + 1) * MTHCA_CQ_ENTRY_SIZE, &buf->queue,\r\nbuf->is_direct, &buf->mr);\r\n}\r\nstatic void handle_error_cqe(struct mthca_dev *dev, struct mthca_cq *cq,\r\nstruct mthca_qp *qp, int wqe_index, int is_send,\r\nstruct mthca_err_cqe *cqe,\r\nstruct ib_wc *entry, int *free_cqe)\r\n{\r\nint dbd;\r\n__be32 new_wqe;\r\nif (cqe->syndrome == SYNDROME_LOCAL_QP_OP_ERR) {\r\nmthca_dbg(dev, "local QP operation err "\r\n"(QPN %06x, WQE @ %08x, CQN %06x, index %d)\n",\r\nbe32_to_cpu(cqe->my_qpn), be32_to_cpu(cqe->wqe),\r\ncq->cqn, cq->cons_index);\r\ndump_cqe(dev, cqe);\r\n}\r\nswitch (cqe->syndrome) {\r\ncase SYNDROME_LOCAL_LENGTH_ERR:\r\nentry->status = IB_WC_LOC_LEN_ERR;\r\nbreak;\r\ncase SYNDROME_LOCAL_QP_OP_ERR:\r\nentry->status = IB_WC_LOC_QP_OP_ERR;\r\nbreak;\r\ncase SYNDROME_LOCAL_EEC_OP_ERR:\r\nentry->status = IB_WC_LOC_EEC_OP_ERR;\r\nbreak;\r\ncase SYNDROME_LOCAL_PROT_ERR:\r\nentry->status = IB_WC_LOC_PROT_ERR;\r\nbreak;\r\ncase SYNDROME_WR_FLUSH_ERR:\r\nentry->status = IB_WC_WR_FLUSH_ERR;\r\nbreak;\r\ncase SYNDROME_MW_BIND_ERR:\r\nentry->status = IB_WC_MW_BIND_ERR;\r\nbreak;\r\ncase SYNDROME_BAD_RESP_ERR:\r\nentry->status = IB_WC_BAD_RESP_ERR;\r\nbreak;\r\ncase SYNDROME_LOCAL_ACCESS_ERR:\r\nentry->status = IB_WC_LOC_ACCESS_ERR;\r\nbreak;\r\ncase SYNDROME_REMOTE_INVAL_REQ_ERR:\r\nentry->status = IB_WC_REM_INV_REQ_ERR;\r\nbreak;\r\ncase SYNDROME_REMOTE_ACCESS_ERR:\r\nentry->status = IB_WC_REM_ACCESS_ERR;\r\nbreak;\r\ncase SYNDROME_REMOTE_OP_ERR:\r\nentry->status = IB_WC_REM_OP_ERR;\r\nbreak;\r\ncase SYNDROME_RETRY_EXC_ERR:\r\nentry->status = IB_WC_RETRY_EXC_ERR;\r\nbreak;\r\ncase SYNDROME_RNR_RETRY_EXC_ERR:\r\nentry->status = IB_WC_RNR_RETRY_EXC_ERR;\r\nbreak;\r\ncase SYNDROME_LOCAL_RDD_VIOL_ERR:\r\nentry->status = IB_WC_LOC_RDD_VIOL_ERR;\r\nbreak;\r\ncase SYNDROME_REMOTE_INVAL_RD_REQ_ERR:\r\nentry->status = IB_WC_REM_INV_RD_REQ_ERR;\r\nbreak;\r\ncase SYNDROME_REMOTE_ABORTED_ERR:\r\nentry->status = IB_WC_REM_ABORT_ERR;\r\nbreak;\r\ncase SYNDROME_INVAL_EECN_ERR:\r\nentry->status = IB_WC_INV_EECN_ERR;\r\nbreak;\r\ncase SYNDROME_INVAL_EEC_STATE_ERR:\r\nentry->status = IB_WC_INV_EEC_STATE_ERR;\r\nbreak;\r\ndefault:\r\nentry->status = IB_WC_GENERAL_ERR;\r\nbreak;\r\n}\r\nentry->vendor_err = cqe->vendor_err;\r\nif (mthca_is_memfree(dev))\r\nreturn;\r\nmthca_free_err_wqe(dev, qp, is_send, wqe_index, &dbd, &new_wqe);\r\nif (!(new_wqe & cpu_to_be32(0x3f)) || (!cqe->db_cnt && dbd))\r\nreturn;\r\nbe16_add_cpu(&cqe->db_cnt, -dbd);\r\ncqe->wqe = new_wqe;\r\ncqe->syndrome = SYNDROME_WR_FLUSH_ERR;\r\n*free_cqe = 0;\r\n}\r\nstatic inline int mthca_poll_one(struct mthca_dev *dev,\r\nstruct mthca_cq *cq,\r\nstruct mthca_qp **cur_qp,\r\nint *freed,\r\nstruct ib_wc *entry)\r\n{\r\nstruct mthca_wq *wq;\r\nstruct mthca_cqe *cqe;\r\nint wqe_index;\r\nint is_error;\r\nint is_send;\r\nint free_cqe = 1;\r\nint err = 0;\r\nu16 checksum;\r\ncqe = next_cqe_sw(cq);\r\nif (!cqe)\r\nreturn -EAGAIN;\r\nrmb();\r\nif (0) {\r\nmthca_dbg(dev, "%x/%d: CQE -> QPN %06x, WQE @ %08x\n",\r\ncq->cqn, cq->cons_index, be32_to_cpu(cqe->my_qpn),\r\nbe32_to_cpu(cqe->wqe));\r\ndump_cqe(dev, cqe);\r\n}\r\nis_error = (cqe->opcode & MTHCA_ERROR_CQE_OPCODE_MASK) ==\r\nMTHCA_ERROR_CQE_OPCODE_MASK;\r\nis_send = is_error ? cqe->opcode & 0x01 : cqe->is_send & 0x80;\r\nif (!*cur_qp || be32_to_cpu(cqe->my_qpn) != (*cur_qp)->qpn) {\r\n*cur_qp = mthca_array_get(&dev->qp_table.qp,\r\nbe32_to_cpu(cqe->my_qpn) &\r\n(dev->limits.num_qps - 1));\r\nif (!*cur_qp) {\r\nmthca_warn(dev, "CQ entry for unknown QP %06x\n",\r\nbe32_to_cpu(cqe->my_qpn) & 0xffffff);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nentry->qp = &(*cur_qp)->ibqp;\r\nif (is_send) {\r\nwq = &(*cur_qp)->sq;\r\nwqe_index = ((be32_to_cpu(cqe->wqe) - (*cur_qp)->send_wqe_offset)\r\n>> wq->wqe_shift);\r\nentry->wr_id = (*cur_qp)->wrid[wqe_index +\r\n(*cur_qp)->rq.max];\r\n} else if ((*cur_qp)->ibqp.srq) {\r\nstruct mthca_srq *srq = to_msrq((*cur_qp)->ibqp.srq);\r\nu32 wqe = be32_to_cpu(cqe->wqe);\r\nwq = NULL;\r\nwqe_index = wqe >> srq->wqe_shift;\r\nentry->wr_id = srq->wrid[wqe_index];\r\nmthca_free_srq_wqe(srq, wqe);\r\n} else {\r\ns32 wqe;\r\nwq = &(*cur_qp)->rq;\r\nwqe = be32_to_cpu(cqe->wqe);\r\nwqe_index = wqe >> wq->wqe_shift;\r\nif (unlikely(wqe_index < 0))\r\nwqe_index = wq->max - 1;\r\nentry->wr_id = (*cur_qp)->wrid[wqe_index];\r\n}\r\nif (wq) {\r\nif (wq->last_comp < wqe_index)\r\nwq->tail += wqe_index - wq->last_comp;\r\nelse\r\nwq->tail += wqe_index + wq->max - wq->last_comp;\r\nwq->last_comp = wqe_index;\r\n}\r\nif (is_error) {\r\nhandle_error_cqe(dev, cq, *cur_qp, wqe_index, is_send,\r\n(struct mthca_err_cqe *) cqe,\r\nentry, &free_cqe);\r\ngoto out;\r\n}\r\nif (is_send) {\r\nentry->wc_flags = 0;\r\nswitch (cqe->opcode) {\r\ncase MTHCA_OPCODE_RDMA_WRITE:\r\nentry->opcode = IB_WC_RDMA_WRITE;\r\nbreak;\r\ncase MTHCA_OPCODE_RDMA_WRITE_IMM:\r\nentry->opcode = IB_WC_RDMA_WRITE;\r\nentry->wc_flags |= IB_WC_WITH_IMM;\r\nbreak;\r\ncase MTHCA_OPCODE_SEND:\r\nentry->opcode = IB_WC_SEND;\r\nbreak;\r\ncase MTHCA_OPCODE_SEND_IMM:\r\nentry->opcode = IB_WC_SEND;\r\nentry->wc_flags |= IB_WC_WITH_IMM;\r\nbreak;\r\ncase MTHCA_OPCODE_RDMA_READ:\r\nentry->opcode = IB_WC_RDMA_READ;\r\nentry->byte_len = be32_to_cpu(cqe->byte_cnt);\r\nbreak;\r\ncase MTHCA_OPCODE_ATOMIC_CS:\r\nentry->opcode = IB_WC_COMP_SWAP;\r\nentry->byte_len = MTHCA_ATOMIC_BYTE_LEN;\r\nbreak;\r\ncase MTHCA_OPCODE_ATOMIC_FA:\r\nentry->opcode = IB_WC_FETCH_ADD;\r\nentry->byte_len = MTHCA_ATOMIC_BYTE_LEN;\r\nbreak;\r\ncase MTHCA_OPCODE_BIND_MW:\r\nentry->opcode = IB_WC_BIND_MW;\r\nbreak;\r\ndefault:\r\nentry->opcode = MTHCA_OPCODE_INVALID;\r\nbreak;\r\n}\r\n} else {\r\nentry->byte_len = be32_to_cpu(cqe->byte_cnt);\r\nswitch (cqe->opcode & 0x1f) {\r\ncase IB_OPCODE_SEND_LAST_WITH_IMMEDIATE:\r\ncase IB_OPCODE_SEND_ONLY_WITH_IMMEDIATE:\r\nentry->wc_flags = IB_WC_WITH_IMM;\r\nentry->ex.imm_data = cqe->imm_etype_pkey_eec;\r\nentry->opcode = IB_WC_RECV;\r\nbreak;\r\ncase IB_OPCODE_RDMA_WRITE_LAST_WITH_IMMEDIATE:\r\ncase IB_OPCODE_RDMA_WRITE_ONLY_WITH_IMMEDIATE:\r\nentry->wc_flags = IB_WC_WITH_IMM;\r\nentry->ex.imm_data = cqe->imm_etype_pkey_eec;\r\nentry->opcode = IB_WC_RECV_RDMA_WITH_IMM;\r\nbreak;\r\ndefault:\r\nentry->wc_flags = 0;\r\nentry->opcode = IB_WC_RECV;\r\nbreak;\r\n}\r\nentry->slid = be16_to_cpu(cqe->rlid);\r\nentry->sl = cqe->sl_ipok >> 4;\r\nentry->src_qp = be32_to_cpu(cqe->rqpn) & 0xffffff;\r\nentry->dlid_path_bits = cqe->g_mlpath & 0x7f;\r\nentry->pkey_index = be32_to_cpu(cqe->imm_etype_pkey_eec) >> 16;\r\nentry->wc_flags |= cqe->g_mlpath & 0x80 ? IB_WC_GRH : 0;\r\nchecksum = (be32_to_cpu(cqe->rqpn) >> 24) |\r\n((be32_to_cpu(cqe->my_ee) >> 16) & 0xff00);\r\nentry->csum_ok = (cqe->sl_ipok & 1 && checksum == 0xffff);\r\n}\r\nentry->status = IB_WC_SUCCESS;\r\nout:\r\nif (likely(free_cqe)) {\r\nset_cqe_hw(cqe);\r\n++(*freed);\r\n++cq->cons_index;\r\n}\r\nreturn err;\r\n}\r\nint mthca_poll_cq(struct ib_cq *ibcq, int num_entries,\r\nstruct ib_wc *entry)\r\n{\r\nstruct mthca_dev *dev = to_mdev(ibcq->device);\r\nstruct mthca_cq *cq = to_mcq(ibcq);\r\nstruct mthca_qp *qp = NULL;\r\nunsigned long flags;\r\nint err = 0;\r\nint freed = 0;\r\nint npolled;\r\nspin_lock_irqsave(&cq->lock, flags);\r\nnpolled = 0;\r\nrepoll:\r\nwhile (npolled < num_entries) {\r\nerr = mthca_poll_one(dev, cq, &qp,\r\n&freed, entry + npolled);\r\nif (err)\r\nbreak;\r\n++npolled;\r\n}\r\nif (freed) {\r\nwmb();\r\nupdate_cons_index(dev, cq, freed);\r\n}\r\nif (unlikely(err == -EAGAIN && cq->resize_buf &&\r\ncq->resize_buf->state == CQ_RESIZE_READY)) {\r\nif (!mthca_is_memfree(dev))\r\ncq->cons_index &= cq->ibcq.cqe;\r\nif (cqe_sw(get_cqe_from_buf(&cq->resize_buf->buf,\r\ncq->cons_index & cq->resize_buf->cqe))) {\r\nstruct mthca_cq_buf tbuf;\r\nint tcqe;\r\ntbuf = cq->buf;\r\ntcqe = cq->ibcq.cqe;\r\ncq->buf = cq->resize_buf->buf;\r\ncq->ibcq.cqe = cq->resize_buf->cqe;\r\ncq->resize_buf->buf = tbuf;\r\ncq->resize_buf->cqe = tcqe;\r\ncq->resize_buf->state = CQ_RESIZE_SWAPPED;\r\ngoto repoll;\r\n}\r\n}\r\nspin_unlock_irqrestore(&cq->lock, flags);\r\nreturn err == 0 || err == -EAGAIN ? npolled : err;\r\n}\r\nint mthca_tavor_arm_cq(struct ib_cq *cq, enum ib_cq_notify_flags flags)\r\n{\r\nu32 dbhi = ((flags & IB_CQ_SOLICITED_MASK) == IB_CQ_SOLICITED ?\r\nMTHCA_TAVOR_CQ_DB_REQ_NOT_SOL :\r\nMTHCA_TAVOR_CQ_DB_REQ_NOT) |\r\nto_mcq(cq)->cqn;\r\nmthca_write64(dbhi, 0xffffffff, to_mdev(cq->device)->kar + MTHCA_CQ_DOORBELL,\r\nMTHCA_GET_DOORBELL_LOCK(&to_mdev(cq->device)->doorbell_lock));\r\nreturn 0;\r\n}\r\nint mthca_arbel_arm_cq(struct ib_cq *ibcq, enum ib_cq_notify_flags flags)\r\n{\r\nstruct mthca_cq *cq = to_mcq(ibcq);\r\n__be32 db_rec[2];\r\nu32 dbhi;\r\nu32 sn = cq->arm_sn & 3;\r\ndb_rec[0] = cpu_to_be32(cq->cons_index);\r\ndb_rec[1] = cpu_to_be32((cq->cqn << 8) | (2 << 5) | (sn << 3) |\r\n((flags & IB_CQ_SOLICITED_MASK) ==\r\nIB_CQ_SOLICITED ? 1 : 2));\r\nmthca_write_db_rec(db_rec, cq->arm_db);\r\nwmb();\r\ndbhi = (sn << 28) |\r\n((flags & IB_CQ_SOLICITED_MASK) == IB_CQ_SOLICITED ?\r\nMTHCA_ARBEL_CQ_DB_REQ_NOT_SOL :\r\nMTHCA_ARBEL_CQ_DB_REQ_NOT) | cq->cqn;\r\nmthca_write64(dbhi, cq->cons_index,\r\nto_mdev(ibcq->device)->kar + MTHCA_CQ_DOORBELL,\r\nMTHCA_GET_DOORBELL_LOCK(&to_mdev(ibcq->device)->doorbell_lock));\r\nreturn 0;\r\n}\r\nint mthca_init_cq(struct mthca_dev *dev, int nent,\r\nstruct mthca_ucontext *ctx, u32 pdn,\r\nstruct mthca_cq *cq)\r\n{\r\nstruct mthca_mailbox *mailbox;\r\nstruct mthca_cq_context *cq_context;\r\nint err = -ENOMEM;\r\ncq->ibcq.cqe = nent - 1;\r\ncq->is_kernel = !ctx;\r\ncq->cqn = mthca_alloc(&dev->cq_table.alloc);\r\nif (cq->cqn == -1)\r\nreturn -ENOMEM;\r\nif (mthca_is_memfree(dev)) {\r\nerr = mthca_table_get(dev, dev->cq_table.table, cq->cqn);\r\nif (err)\r\ngoto err_out;\r\nif (cq->is_kernel) {\r\ncq->arm_sn = 1;\r\nerr = -ENOMEM;\r\ncq->set_ci_db_index = mthca_alloc_db(dev, MTHCA_DB_TYPE_CQ_SET_CI,\r\ncq->cqn, &cq->set_ci_db);\r\nif (cq->set_ci_db_index < 0)\r\ngoto err_out_icm;\r\ncq->arm_db_index = mthca_alloc_db(dev, MTHCA_DB_TYPE_CQ_ARM,\r\ncq->cqn, &cq->arm_db);\r\nif (cq->arm_db_index < 0)\r\ngoto err_out_ci;\r\n}\r\n}\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(mailbox))\r\ngoto err_out_arm;\r\ncq_context = mailbox->buf;\r\nif (cq->is_kernel) {\r\nerr = mthca_alloc_cq_buf(dev, &cq->buf, nent);\r\nif (err)\r\ngoto err_out_mailbox;\r\n}\r\nspin_lock_init(&cq->lock);\r\ncq->refcount = 1;\r\ninit_waitqueue_head(&cq->wait);\r\nmutex_init(&cq->mutex);\r\nmemset(cq_context, 0, sizeof *cq_context);\r\ncq_context->flags = cpu_to_be32(MTHCA_CQ_STATUS_OK |\r\nMTHCA_CQ_STATE_DISARMED |\r\nMTHCA_CQ_FLAG_TR);\r\ncq_context->logsize_usrpage = cpu_to_be32((ffs(nent) - 1) << 24);\r\nif (ctx)\r\ncq_context->logsize_usrpage |= cpu_to_be32(ctx->uar.index);\r\nelse\r\ncq_context->logsize_usrpage |= cpu_to_be32(dev->driver_uar.index);\r\ncq_context->error_eqn = cpu_to_be32(dev->eq_table.eq[MTHCA_EQ_ASYNC].eqn);\r\ncq_context->comp_eqn = cpu_to_be32(dev->eq_table.eq[MTHCA_EQ_COMP].eqn);\r\ncq_context->pd = cpu_to_be32(pdn);\r\ncq_context->lkey = cpu_to_be32(cq->buf.mr.ibmr.lkey);\r\ncq_context->cqn = cpu_to_be32(cq->cqn);\r\nif (mthca_is_memfree(dev)) {\r\ncq_context->ci_db = cpu_to_be32(cq->set_ci_db_index);\r\ncq_context->state_db = cpu_to_be32(cq->arm_db_index);\r\n}\r\nerr = mthca_SW2HW_CQ(dev, mailbox, cq->cqn);\r\nif (err) {\r\nmthca_warn(dev, "SW2HW_CQ failed (%d)\n", err);\r\ngoto err_out_free_mr;\r\n}\r\nspin_lock_irq(&dev->cq_table.lock);\r\nif (mthca_array_set(&dev->cq_table.cq,\r\ncq->cqn & (dev->limits.num_cqs - 1),\r\ncq)) {\r\nspin_unlock_irq(&dev->cq_table.lock);\r\ngoto err_out_free_mr;\r\n}\r\nspin_unlock_irq(&dev->cq_table.lock);\r\ncq->cons_index = 0;\r\nmthca_free_mailbox(dev, mailbox);\r\nreturn 0;\r\nerr_out_free_mr:\r\nif (cq->is_kernel)\r\nmthca_free_cq_buf(dev, &cq->buf, cq->ibcq.cqe);\r\nerr_out_mailbox:\r\nmthca_free_mailbox(dev, mailbox);\r\nerr_out_arm:\r\nif (cq->is_kernel && mthca_is_memfree(dev))\r\nmthca_free_db(dev, MTHCA_DB_TYPE_CQ_ARM, cq->arm_db_index);\r\nerr_out_ci:\r\nif (cq->is_kernel && mthca_is_memfree(dev))\r\nmthca_free_db(dev, MTHCA_DB_TYPE_CQ_SET_CI, cq->set_ci_db_index);\r\nerr_out_icm:\r\nmthca_table_put(dev, dev->cq_table.table, cq->cqn);\r\nerr_out:\r\nmthca_free(&dev->cq_table.alloc, cq->cqn);\r\nreturn err;\r\n}\r\nstatic inline int get_cq_refcount(struct mthca_dev *dev, struct mthca_cq *cq)\r\n{\r\nint c;\r\nspin_lock_irq(&dev->cq_table.lock);\r\nc = cq->refcount;\r\nspin_unlock_irq(&dev->cq_table.lock);\r\nreturn c;\r\n}\r\nvoid mthca_free_cq(struct mthca_dev *dev,\r\nstruct mthca_cq *cq)\r\n{\r\nstruct mthca_mailbox *mailbox;\r\nint err;\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(mailbox)) {\r\nmthca_warn(dev, "No memory for mailbox to free CQ.\n");\r\nreturn;\r\n}\r\nerr = mthca_HW2SW_CQ(dev, mailbox, cq->cqn);\r\nif (err)\r\nmthca_warn(dev, "HW2SW_CQ failed (%d)\n", err);\r\nif (0) {\r\n__be32 *ctx = mailbox->buf;\r\nint j;\r\nprintk(KERN_ERR "context for CQN %x (cons index %x, next sw %d)\n",\r\ncq->cqn, cq->cons_index,\r\ncq->is_kernel ? !!next_cqe_sw(cq) : 0);\r\nfor (j = 0; j < 16; ++j)\r\nprintk(KERN_ERR "[%2x] %08x\n", j * 4, be32_to_cpu(ctx[j]));\r\n}\r\nspin_lock_irq(&dev->cq_table.lock);\r\nmthca_array_clear(&dev->cq_table.cq,\r\ncq->cqn & (dev->limits.num_cqs - 1));\r\n--cq->refcount;\r\nspin_unlock_irq(&dev->cq_table.lock);\r\nif (dev->mthca_flags & MTHCA_FLAG_MSI_X)\r\nsynchronize_irq(dev->eq_table.eq[MTHCA_EQ_COMP].msi_x_vector);\r\nelse\r\nsynchronize_irq(dev->pdev->irq);\r\nwait_event(cq->wait, !get_cq_refcount(dev, cq));\r\nif (cq->is_kernel) {\r\nmthca_free_cq_buf(dev, &cq->buf, cq->ibcq.cqe);\r\nif (mthca_is_memfree(dev)) {\r\nmthca_free_db(dev, MTHCA_DB_TYPE_CQ_ARM, cq->arm_db_index);\r\nmthca_free_db(dev, MTHCA_DB_TYPE_CQ_SET_CI, cq->set_ci_db_index);\r\n}\r\n}\r\nmthca_table_put(dev, dev->cq_table.table, cq->cqn);\r\nmthca_free(&dev->cq_table.alloc, cq->cqn);\r\nmthca_free_mailbox(dev, mailbox);\r\n}\r\nint mthca_init_cq_table(struct mthca_dev *dev)\r\n{\r\nint err;\r\nspin_lock_init(&dev->cq_table.lock);\r\nerr = mthca_alloc_init(&dev->cq_table.alloc,\r\ndev->limits.num_cqs,\r\n(1 << 24) - 1,\r\ndev->limits.reserved_cqs);\r\nif (err)\r\nreturn err;\r\nerr = mthca_array_init(&dev->cq_table.cq,\r\ndev->limits.num_cqs);\r\nif (err)\r\nmthca_alloc_cleanup(&dev->cq_table.alloc);\r\nreturn err;\r\n}\r\nvoid mthca_cleanup_cq_table(struct mthca_dev *dev)\r\n{\r\nmthca_array_cleanup(&dev->cq_table.cq, dev->limits.num_cqs);\r\nmthca_alloc_cleanup(&dev->cq_table.alloc);\r\n}
