static inline void phy_on(void)\r\n{\r\nu32 cfgchip2 = __raw_readl(CFGCHIP2);\r\ncfgchip2 &= ~(CFGCHIP2_RESET | CFGCHIP2_PHYPWRDN | CFGCHIP2_OTGPWRDN);\r\ncfgchip2 |= CFGCHIP2_PHY_PLLON;\r\n__raw_writel(cfgchip2, CFGCHIP2);\r\npr_info("Waiting for USB PHY clock good...\n");\r\nwhile (!(__raw_readl(CFGCHIP2) & CFGCHIP2_PHYCLKGD))\r\ncpu_relax();\r\n}\r\nstatic inline void phy_off(void)\r\n{\r\nu32 cfgchip2 = __raw_readl(CFGCHIP2);\r\nif (!(cfgchip2 & CFGCHIP2_USB1PHYCLKMUX) &&\r\n(cfgchip2 & CFGCHIP2_USB1SUSPENDM)) {\r\npr_warning("USB 1.1 clocked from USB 2.0 PHY -- "\r\n"can't power it down\n");\r\nreturn;\r\n}\r\ncfgchip2 |= CFGCHIP2_PHYPWRDN | CFGCHIP2_OTGPWRDN;\r\n__raw_writel(cfgchip2, CFGCHIP2);\r\n}\r\nstatic void da8xx_musb_enable(struct musb *musb)\r\n{\r\nvoid __iomem *reg_base = musb->ctrl_base;\r\nu32 mask;\r\nmask = ((musb->epmask & DA8XX_USB_TX_EP_MASK) << DA8XX_INTR_TX_SHIFT) |\r\n((musb->epmask & DA8XX_USB_RX_EP_MASK) << DA8XX_INTR_RX_SHIFT) |\r\nDA8XX_INTR_USB_MASK;\r\nmusb_writel(reg_base, DA8XX_USB_INTR_MASK_SET_REG, mask);\r\nif (is_otg_enabled(musb))\r\nmusb_writel(reg_base, DA8XX_USB_INTR_SRC_SET_REG,\r\nDA8XX_INTR_DRVVBUS << DA8XX_INTR_USB_SHIFT);\r\n}\r\nstatic void da8xx_musb_disable(struct musb *musb)\r\n{\r\nvoid __iomem *reg_base = musb->ctrl_base;\r\nmusb_writel(reg_base, DA8XX_USB_INTR_MASK_CLEAR_REG,\r\nDA8XX_INTR_USB_MASK |\r\nDA8XX_INTR_TX_MASK | DA8XX_INTR_RX_MASK);\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, 0);\r\nmusb_writel(reg_base, DA8XX_USB_END_OF_INTR_REG, 0);\r\n}\r\nstatic void da8xx_musb_set_vbus(struct musb *musb, int is_on)\r\n{\r\nWARN_ON(is_on && is_peripheral_active(musb));\r\n}\r\nstatic void otg_timer(unsigned long _musb)\r\n{\r\nstruct musb *musb = (void *)_musb;\r\nvoid __iomem *mregs = musb->mregs;\r\nu8 devctl;\r\nunsigned long flags;\r\ndevctl = musb_readb(mregs, MUSB_DEVCTL);\r\ndev_dbg(musb->controller, "Poll devctl %02x (%s)\n", devctl,\r\notg_state_string(musb->xceiv->state));\r\nspin_lock_irqsave(&musb->lock, flags);\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_A_WAIT_BCON:\r\ndevctl &= ~MUSB_DEVCTL_SESSION;\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nif (devctl & MUSB_DEVCTL_BDEVICE) {\r\nmusb->xceiv->state = OTG_STATE_B_IDLE;\r\nMUSB_DEV_MODE(musb);\r\n} else {\r\nmusb->xceiv->state = OTG_STATE_A_IDLE;\r\nMUSB_HST_MODE(musb);\r\n}\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nif (devctl & MUSB_DEVCTL_VBUS) {\r\nmod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);\r\nbreak;\r\n}\r\nmusb->xceiv->state = OTG_STATE_A_WAIT_VRISE;\r\nmusb_writel(musb->ctrl_base, DA8XX_USB_INTR_SRC_SET_REG,\r\nMUSB_INTR_VBUSERROR << DA8XX_INTR_USB_SHIFT);\r\nbreak;\r\ncase OTG_STATE_B_IDLE:\r\nif (!is_peripheral_enabled(musb))\r\nbreak;\r\nmusb_writeb(mregs, MUSB_DEVCTL, devctl | MUSB_DEVCTL_SESSION);\r\ndevctl = musb_readb(mregs, MUSB_DEVCTL);\r\nif (devctl & MUSB_DEVCTL_BDEVICE)\r\nmod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);\r\nelse\r\nmusb->xceiv->state = OTG_STATE_A_IDLE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nstatic void da8xx_musb_try_idle(struct musb *musb, unsigned long timeout)\r\n{\r\nstatic unsigned long last_timer;\r\nif (!is_otg_enabled(musb))\r\nreturn;\r\nif (timeout == 0)\r\ntimeout = jiffies + msecs_to_jiffies(3);\r\nif (musb->is_active || (musb->a_wait_bcon == 0 &&\r\nmusb->xceiv->state == OTG_STATE_A_WAIT_BCON)) {\r\ndev_dbg(musb->controller, "%s active, deleting timer\n",\r\notg_state_string(musb->xceiv->state));\r\ndel_timer(&otg_workaround);\r\nlast_timer = jiffies;\r\nreturn;\r\n}\r\nif (time_after(last_timer, timeout) && timer_pending(&otg_workaround)) {\r\ndev_dbg(musb->controller, "Longer idle timer already pending, ignoring...\n");\r\nreturn;\r\n}\r\nlast_timer = timeout;\r\ndev_dbg(musb->controller, "%s inactive, starting idle timer for %u ms\n",\r\notg_state_string(musb->xceiv->state),\r\njiffies_to_msecs(timeout - jiffies));\r\nmod_timer(&otg_workaround, timeout);\r\n}\r\nstatic irqreturn_t da8xx_musb_interrupt(int irq, void *hci)\r\n{\r\nstruct musb *musb = hci;\r\nvoid __iomem *reg_base = musb->ctrl_base;\r\nunsigned long flags;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 status;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nstatus = musb_readl(reg_base, DA8XX_USB_INTR_SRC_MASKED_REG);\r\nif (!status)\r\ngoto eoi;\r\nmusb_writel(reg_base, DA8XX_USB_INTR_SRC_CLEAR_REG, status);\r\ndev_dbg(musb->controller, "USB IRQ %08x\n", status);\r\nmusb->int_rx = (status & DA8XX_INTR_RX_MASK) >> DA8XX_INTR_RX_SHIFT;\r\nmusb->int_tx = (status & DA8XX_INTR_TX_MASK) >> DA8XX_INTR_TX_SHIFT;\r\nmusb->int_usb = (status & DA8XX_INTR_USB_MASK) >> DA8XX_INTR_USB_SHIFT;\r\nif (status & (DA8XX_INTR_DRVVBUS << DA8XX_INTR_USB_SHIFT)) {\r\nint drvvbus = musb_readl(reg_base, DA8XX_USB_STAT_REG);\r\nvoid __iomem *mregs = musb->mregs;\r\nu8 devctl = musb_readb(mregs, MUSB_DEVCTL);\r\nint err;\r\nerr = is_host_enabled(musb) && (musb->int_usb &\r\nMUSB_INTR_VBUSERROR);\r\nif (err) {\r\nmusb->int_usb &= ~MUSB_INTR_VBUSERROR;\r\nmusb->xceiv->state = OTG_STATE_A_WAIT_VFALL;\r\nmod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);\r\nWARNING("VBUS error workaround (delay coming)\n");\r\n} else if (is_host_enabled(musb) && drvvbus) {\r\nMUSB_HST_MODE(musb);\r\nmusb->xceiv->default_a = 1;\r\nmusb->xceiv->state = OTG_STATE_A_WAIT_VRISE;\r\nportstate(musb->port1_status |= USB_PORT_STAT_POWER);\r\ndel_timer(&otg_workaround);\r\n} else {\r\nmusb->is_active = 0;\r\nMUSB_DEV_MODE(musb);\r\nmusb->xceiv->default_a = 0;\r\nmusb->xceiv->state = OTG_STATE_B_IDLE;\r\nportstate(musb->port1_status &= ~USB_PORT_STAT_POWER);\r\n}\r\ndev_dbg(musb->controller, "VBUS %s (%s)%s, devctl %02x\n",\r\ndrvvbus ? "on" : "off",\r\notg_state_string(musb->xceiv->state),\r\nerr ? " ERROR" : "",\r\ndevctl);\r\nret = IRQ_HANDLED;\r\n}\r\nif (musb->int_tx || musb->int_rx || musb->int_usb)\r\nret |= musb_interrupt(musb);\r\neoi:\r\nif (ret == IRQ_HANDLED || status)\r\nmusb_writel(reg_base, DA8XX_USB_END_OF_INTR_REG, 0);\r\nif (is_otg_enabled(musb) && musb->xceiv->state == OTG_STATE_B_IDLE)\r\nmod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int da8xx_musb_set_mode(struct musb *musb, u8 musb_mode)\r\n{\r\nu32 cfgchip2 = __raw_readl(CFGCHIP2);\r\ncfgchip2 &= ~CFGCHIP2_OTGMODE;\r\nswitch (musb_mode) {\r\ncase MUSB_HOST:\r\ncfgchip2 |= CFGCHIP2_FORCE_HOST;\r\nbreak;\r\ncase MUSB_PERIPHERAL:\r\ncfgchip2 |= CFGCHIP2_FORCE_DEVICE;\r\nbreak;\r\ncase MUSB_OTG:\r\ncfgchip2 |= CFGCHIP2_NO_OVERRIDE;\r\nbreak;\r\ndefault:\r\ndev_dbg(musb->controller, "Trying to set unsupported mode %u\n", musb_mode);\r\n}\r\n__raw_writel(cfgchip2, CFGCHIP2);\r\nreturn 0;\r\n}\r\nstatic int da8xx_musb_init(struct musb *musb)\r\n{\r\nvoid __iomem *reg_base = musb->ctrl_base;\r\nu32 rev;\r\nmusb->mregs += DA8XX_MENTOR_CORE_OFFSET;\r\nrev = musb_readl(reg_base, DA8XX_USB_REVISION_REG);\r\nif (!rev)\r\ngoto fail;\r\nusb_nop_xceiv_register();\r\nmusb->xceiv = otg_get_transceiver();\r\nif (!musb->xceiv)\r\ngoto fail;\r\nif (is_host_enabled(musb))\r\nsetup_timer(&otg_workaround, otg_timer, (unsigned long)musb);\r\nmusb_writel(reg_base, DA8XX_USB_CTRL_REG, DA8XX_SOFT_RESET_MASK);\r\nphy_on();\r\nmsleep(5);\r\npr_debug("DA8xx OTG revision %08x, PHY %03x, control %02x\n",\r\nrev, __raw_readl(CFGCHIP2),\r\nmusb_readb(reg_base, DA8XX_USB_CTRL_REG));\r\nmusb->isr = da8xx_musb_interrupt;\r\nreturn 0;\r\nfail:\r\nreturn -ENODEV;\r\n}\r\nstatic int da8xx_musb_exit(struct musb *musb)\r\n{\r\nif (is_host_enabled(musb))\r\ndel_timer_sync(&otg_workaround);\r\nphy_off();\r\notg_put_transceiver(musb->xceiv);\r\nusb_nop_xceiv_unregister();\r\nreturn 0;\r\n}\r\nstatic int __init da8xx_probe(struct platform_device *pdev)\r\n{\r\nstruct musb_hdrc_platform_data *pdata = pdev->dev.platform_data;\r\nstruct platform_device *musb;\r\nstruct da8xx_glue *glue;\r\nstruct clk *clk;\r\nint ret = -ENOMEM;\r\nglue = kzalloc(sizeof(*glue), GFP_KERNEL);\r\nif (!glue) {\r\ndev_err(&pdev->dev, "failed to allocate glue context\n");\r\ngoto err0;\r\n}\r\nmusb = platform_device_alloc("musb-hdrc", -1);\r\nif (!musb) {\r\ndev_err(&pdev->dev, "failed to allocate musb device\n");\r\ngoto err1;\r\n}\r\nclk = clk_get(&pdev->dev, "usb20");\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nret = PTR_ERR(clk);\r\ngoto err2;\r\n}\r\nret = clk_enable(clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable clock\n");\r\ngoto err3;\r\n}\r\nmusb->dev.parent = &pdev->dev;\r\nmusb->dev.dma_mask = &da8xx_dmamask;\r\nmusb->dev.coherent_dma_mask = da8xx_dmamask;\r\nglue->dev = &pdev->dev;\r\nglue->musb = musb;\r\nglue->clk = clk;\r\npdata->platform_ops = &da8xx_ops;\r\nplatform_set_drvdata(pdev, glue);\r\nret = platform_device_add_resources(musb, pdev->resource,\r\npdev->num_resources);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add resources\n");\r\ngoto err4;\r\n}\r\nret = platform_device_add_data(musb, pdata, sizeof(*pdata));\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add platform_data\n");\r\ngoto err4;\r\n}\r\nret = platform_device_add(musb);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register musb device\n");\r\ngoto err4;\r\n}\r\nreturn 0;\r\nerr4:\r\nclk_disable(clk);\r\nerr3:\r\nclk_put(clk);\r\nerr2:\r\nplatform_device_put(musb);\r\nerr1:\r\nkfree(glue);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int __exit da8xx_remove(struct platform_device *pdev)\r\n{\r\nstruct da8xx_glue *glue = platform_get_drvdata(pdev);\r\nplatform_device_del(glue->musb);\r\nplatform_device_put(glue->musb);\r\nclk_disable(glue->clk);\r\nclk_put(glue->clk);\r\nkfree(glue);\r\nreturn 0;\r\n}\r\nstatic int __init da8xx_init(void)\r\n{\r\nreturn platform_driver_probe(&da8xx_driver, da8xx_probe);\r\n}\r\nstatic void __exit da8xx_exit(void)\r\n{\r\nplatform_driver_unregister(&da8xx_driver);\r\n}
