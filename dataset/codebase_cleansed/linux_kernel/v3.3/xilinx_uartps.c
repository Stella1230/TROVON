static irqreturn_t xuartps_isr(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = (struct uart_port *)dev_id;\r\nstruct tty_struct *tty;\r\nunsigned long flags;\r\nunsigned int isrstatus, numbytes;\r\nunsigned int data;\r\nchar status = TTY_NORMAL;\r\ntty = tty_port_tty_get(&port->state->port);\r\nspin_lock_irqsave(&port->lock, flags);\r\nisrstatus = xuartps_readl(XUARTPS_ISR_OFFSET);\r\nif (isrstatus & port->ignore_status_mask & XUARTPS_IXR_PARITY)\r\nisrstatus &= ~(XUARTPS_IXR_RXTRIG | XUARTPS_IXR_TOUT);\r\nisrstatus &= port->read_status_mask;\r\nisrstatus &= ~port->ignore_status_mask;\r\nif ((isrstatus & XUARTPS_IXR_TOUT) ||\r\n(isrstatus & XUARTPS_IXR_RXTRIG)) {\r\nwhile ((xuartps_readl(XUARTPS_SR_OFFSET) &\r\nXUARTPS_SR_RXEMPTY) != XUARTPS_SR_RXEMPTY) {\r\ndata = xuartps_readl(XUARTPS_FIFO_OFFSET);\r\nport->icount.rx++;\r\nif (isrstatus & XUARTPS_IXR_PARITY) {\r\nport->icount.parity++;\r\nstatus = TTY_PARITY;\r\n} else if (isrstatus & XUARTPS_IXR_FRAMING) {\r\nport->icount.frame++;\r\nstatus = TTY_FRAME;\r\n} else if (isrstatus & XUARTPS_IXR_OVERRUN)\r\nport->icount.overrun++;\r\nif (tty)\r\nuart_insert_char(port, isrstatus,\r\nXUARTPS_IXR_OVERRUN, data,\r\nstatus);\r\n}\r\nspin_unlock(&port->lock);\r\nif (tty)\r\ntty_flip_buffer_push(tty);\r\nspin_lock(&port->lock);\r\n}\r\nif ((isrstatus & XUARTPS_IXR_TXEMPTY) == XUARTPS_IXR_TXEMPTY) {\r\nif (uart_circ_empty(&port->state->xmit)) {\r\nxuartps_writel(XUARTPS_IXR_TXEMPTY,\r\nXUARTPS_IDR_OFFSET);\r\n} else {\r\nnumbytes = port->fifosize;\r\nwhile (numbytes--) {\r\nif (uart_circ_empty(&port->state->xmit))\r\nbreak;\r\nxuartps_writel(\r\nport->state->xmit.buf[port->state->xmit.\r\ntail], XUARTPS_FIFO_OFFSET);\r\nport->icount.tx++;\r\nport->state->xmit.tail =\r\n(port->state->xmit.tail + 1) & \\r\n(UART_XMIT_SIZE - 1);\r\n}\r\nif (uart_circ_chars_pending(\r\n&port->state->xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\n}\r\nxuartps_writel(isrstatus, XUARTPS_ISR_OFFSET);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ntty_kref_put(tty);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int xuartps_set_baud_rate(struct uart_port *port,\r\nunsigned int baud)\r\n{\r\nunsigned int sel_clk;\r\nunsigned int calc_baud = 0;\r\nunsigned int brgr_val, brdiv_val;\r\nunsigned int bauderror;\r\nsel_clk = port->uartclk;\r\nif (xuartps_readl(XUARTPS_MR_OFFSET) & XUARTPS_MR_CLKSEL)\r\nsel_clk = sel_clk / 8;\r\nfor (brdiv_val = 4; brdiv_val < 255; brdiv_val++) {\r\nbrgr_val = sel_clk / (baud * (brdiv_val + 1));\r\nif (brgr_val < 2 || brgr_val > 65535)\r\ncontinue;\r\ncalc_baud = sel_clk / (brgr_val * (brdiv_val + 1));\r\nif (baud > calc_baud)\r\nbauderror = baud - calc_baud;\r\nelse\r\nbauderror = calc_baud - baud;\r\nif (((bauderror * 100) / baud) < 3) {\r\ncalc_baud = baud;\r\nbreak;\r\n}\r\n}\r\nxuartps_writel(brgr_val, XUARTPS_BAUDGEN_OFFSET);\r\nxuartps_writel(brdiv_val, XUARTPS_BAUDDIV_OFFSET);\r\nreturn calc_baud;\r\n}\r\nstatic void xuartps_start_tx(struct uart_port *port)\r\n{\r\nunsigned int status, numbytes = port->fifosize;\r\nif (uart_circ_empty(&port->state->xmit) || uart_tx_stopped(port))\r\nreturn;\r\nstatus = xuartps_readl(XUARTPS_CR_OFFSET);\r\nxuartps_writel((status & ~XUARTPS_CR_TX_DIS) | XUARTPS_CR_TX_EN,\r\nXUARTPS_CR_OFFSET);\r\nwhile (numbytes-- && ((xuartps_readl(XUARTPS_SR_OFFSET)\r\n& XUARTPS_SR_TXFULL)) != XUARTPS_SR_TXFULL) {\r\nif (uart_circ_empty(&port->state->xmit))\r\nbreak;\r\nxuartps_writel(\r\nport->state->xmit.buf[port->state->xmit.tail],\r\nXUARTPS_FIFO_OFFSET);\r\nport->icount.tx++;\r\nport->state->xmit.tail = (port->state->xmit.tail + 1) &\r\n(UART_XMIT_SIZE - 1);\r\n}\r\nxuartps_writel(XUARTPS_IXR_TXEMPTY, XUARTPS_IER_OFFSET);\r\nif (uart_circ_chars_pending(&port->state->xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic void xuartps_stop_tx(struct uart_port *port)\r\n{\r\nunsigned int regval;\r\nregval = xuartps_readl(XUARTPS_CR_OFFSET);\r\nregval |= XUARTPS_CR_TX_DIS;\r\nxuartps_writel(regval, XUARTPS_CR_OFFSET);\r\n}\r\nstatic void xuartps_stop_rx(struct uart_port *port)\r\n{\r\nunsigned int regval;\r\nregval = xuartps_readl(XUARTPS_CR_OFFSET);\r\nregval |= XUARTPS_CR_RX_DIS;\r\nxuartps_writel(regval, XUARTPS_CR_OFFSET);\r\n}\r\nstatic unsigned int xuartps_tx_empty(struct uart_port *port)\r\n{\r\nunsigned int status;\r\nstatus = xuartps_readl(XUARTPS_ISR_OFFSET) & XUARTPS_IXR_TXEMPTY;\r\nreturn status ? TIOCSER_TEMT : 0;\r\n}\r\nstatic void xuartps_break_ctl(struct uart_port *port, int ctl)\r\n{\r\nunsigned int status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nstatus = xuartps_readl(XUARTPS_CR_OFFSET);\r\nif (ctl == -1)\r\nxuartps_writel(XUARTPS_CR_STARTBRK | status,\r\nXUARTPS_CR_OFFSET);\r\nelse {\r\nif ((status & XUARTPS_CR_STOPBRK) == 0)\r\nxuartps_writel(XUARTPS_CR_STOPBRK | status,\r\nXUARTPS_CR_OFFSET);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void xuartps_set_termios(struct uart_port *port,\r\nstruct ktermios *termios, struct ktermios *old)\r\n{\r\nunsigned int cval = 0;\r\nunsigned int baud;\r\nunsigned long flags;\r\nunsigned int ctrl_reg, mode_reg;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwhile ((xuartps_readl(XUARTPS_SR_OFFSET) &\r\nXUARTPS_SR_RXEMPTY) != XUARTPS_SR_RXEMPTY) {\r\nxuartps_readl(XUARTPS_FIFO_OFFSET);\r\n}\r\nxuartps_writel(xuartps_readl(XUARTPS_CR_OFFSET) |\r\n(XUARTPS_CR_TX_DIS | XUARTPS_CR_RX_DIS),\r\nXUARTPS_CR_OFFSET);\r\nbaud = uart_get_baud_rate(port, termios, old, 0, 10000000);\r\nbaud = xuartps_set_baud_rate(port, baud);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nxuartps_writel(xuartps_readl(XUARTPS_CR_OFFSET) |\r\n(XUARTPS_CR_TXRST | XUARTPS_CR_RXRST),\r\nXUARTPS_CR_OFFSET);\r\nctrl_reg = xuartps_readl(XUARTPS_CR_OFFSET);\r\nxuartps_writel(\r\n(ctrl_reg & ~(XUARTPS_CR_TX_DIS | XUARTPS_CR_RX_DIS))\r\n| (XUARTPS_CR_TX_EN | XUARTPS_CR_RX_EN),\r\nXUARTPS_CR_OFFSET);\r\nxuartps_writel(10, XUARTPS_RXTOUT_OFFSET);\r\nport->read_status_mask = XUARTPS_IXR_TXEMPTY | XUARTPS_IXR_RXTRIG |\r\nXUARTPS_IXR_OVERRUN | XUARTPS_IXR_TOUT;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= XUARTPS_IXR_PARITY |\r\nXUARTPS_IXR_FRAMING;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= XUARTPS_IXR_PARITY |\r\nXUARTPS_IXR_FRAMING | XUARTPS_IXR_OVERRUN;\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->ignore_status_mask |= XUARTPS_IXR_RXTRIG |\r\nXUARTPS_IXR_TOUT | XUARTPS_IXR_PARITY |\r\nXUARTPS_IXR_FRAMING | XUARTPS_IXR_OVERRUN;\r\nmode_reg = xuartps_readl(XUARTPS_MR_OFFSET);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS6:\r\ncval |= XUARTPS_MR_CHARLEN_6_BIT;\r\nbreak;\r\ncase CS7:\r\ncval |= XUARTPS_MR_CHARLEN_7_BIT;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\ncval |= XUARTPS_MR_CHARLEN_8_BIT;\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= CS8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\ncval |= XUARTPS_MR_STOPMODE_2_BIT;\r\nelse\r\ncval |= XUARTPS_MR_STOPMODE_1_BIT;\r\nif (termios->c_cflag & PARENB) {\r\nif (termios->c_cflag & CMSPAR) {\r\nif (termios->c_cflag & PARODD)\r\ncval |= XUARTPS_MR_PARITY_MARK;\r\nelse\r\ncval |= XUARTPS_MR_PARITY_SPACE;\r\n} else if (termios->c_cflag & PARODD)\r\ncval |= XUARTPS_MR_PARITY_ODD;\r\nelse\r\ncval |= XUARTPS_MR_PARITY_EVEN;\r\n} else\r\ncval |= XUARTPS_MR_PARITY_NONE;\r\nxuartps_writel(cval , XUARTPS_MR_OFFSET);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int xuartps_startup(struct uart_port *port)\r\n{\r\nunsigned int retval = 0, status = 0;\r\nretval = request_irq(port->irq, xuartps_isr, 0, XUARTPS_NAME,\r\n(void *)port);\r\nif (retval)\r\nreturn retval;\r\nxuartps_writel(XUARTPS_CR_TX_DIS | XUARTPS_CR_RX_DIS,\r\nXUARTPS_CR_OFFSET);\r\nxuartps_writel(XUARTPS_CR_TXRST | XUARTPS_CR_RXRST,\r\nXUARTPS_CR_OFFSET);\r\nstatus = xuartps_readl(XUARTPS_CR_OFFSET);\r\nxuartps_writel((status & ~(XUARTPS_CR_TX_DIS | XUARTPS_CR_RX_DIS))\r\n| (XUARTPS_CR_TX_EN | XUARTPS_CR_RX_EN |\r\nXUARTPS_CR_STOPBRK), XUARTPS_CR_OFFSET);\r\nxuartps_writel(XUARTPS_MR_CHMODE_NORM | XUARTPS_MR_STOPMODE_1_BIT\r\n| XUARTPS_MR_PARITY_NONE | XUARTPS_MR_CHARLEN_8_BIT,\r\nXUARTPS_MR_OFFSET);\r\nxuartps_writel(14, XUARTPS_RXWM_OFFSET);\r\nxuartps_writel(10, XUARTPS_RXTOUT_OFFSET);\r\nxuartps_writel(XUARTPS_IXR_TXEMPTY | XUARTPS_IXR_PARITY |\r\nXUARTPS_IXR_FRAMING | XUARTPS_IXR_OVERRUN |\r\nXUARTPS_IXR_RXTRIG | XUARTPS_IXR_TOUT, XUARTPS_IER_OFFSET);\r\nxuartps_writel(~(XUARTPS_IXR_TXEMPTY | XUARTPS_IXR_PARITY |\r\nXUARTPS_IXR_FRAMING | XUARTPS_IXR_OVERRUN |\r\nXUARTPS_IXR_RXTRIG | XUARTPS_IXR_TOUT), XUARTPS_IDR_OFFSET);\r\nreturn retval;\r\n}\r\nstatic void xuartps_shutdown(struct uart_port *port)\r\n{\r\nint status;\r\nstatus = xuartps_readl(XUARTPS_IMR_OFFSET);\r\nxuartps_writel(status, XUARTPS_IDR_OFFSET);\r\nxuartps_writel(XUARTPS_CR_TX_DIS | XUARTPS_CR_RX_DIS,\r\nXUARTPS_CR_OFFSET);\r\nfree_irq(port->irq, port);\r\n}\r\nstatic const char *xuartps_type(struct uart_port *port)\r\n{\r\nreturn port->type == PORT_XUARTPS ? XUARTPS_NAME : NULL;\r\n}\r\nstatic int xuartps_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_XUARTPS)\r\nreturn -EINVAL;\r\nif (port->irq != ser->irq)\r\nreturn -EINVAL;\r\nif (ser->io_type != UPIO_MEM)\r\nreturn -EINVAL;\r\nif (port->iobase != ser->port)\r\nreturn -EINVAL;\r\nif (ser->hub6 != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int xuartps_request_port(struct uart_port *port)\r\n{\r\nif (!request_mem_region(port->mapbase, XUARTPS_REGISTER_SPACE,\r\nXUARTPS_NAME)) {\r\nreturn -ENOMEM;\r\n}\r\nport->membase = ioremap(port->mapbase, XUARTPS_REGISTER_SPACE);\r\nif (!port->membase) {\r\ndev_err(port->dev, "Unable to map registers\n");\r\nrelease_mem_region(port->mapbase, XUARTPS_REGISTER_SPACE);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void xuartps_release_port(struct uart_port *port)\r\n{\r\nrelease_mem_region(port->mapbase, XUARTPS_REGISTER_SPACE);\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\nstatic void xuartps_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE && xuartps_request_port(port) == 0)\r\nport->type = PORT_XUARTPS;\r\n}\r\nstatic unsigned int xuartps_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void xuartps_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void xuartps_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic struct uart_port *xuartps_get_port(void)\r\n{\r\nstruct uart_port *port;\r\nint id;\r\nfor (id = 0; id < XUARTPS_NR_PORTS; id++)\r\nif (xuartps_port[id].mapbase == 0)\r\nbreak;\r\nif (id >= XUARTPS_NR_PORTS)\r\nreturn NULL;\r\nport = &xuartps_port[id];\r\nspin_lock_init(&port->lock);\r\nport->membase = NULL;\r\nport->iobase = 1;\r\nport->irq = 0;\r\nport->type = PORT_UNKNOWN;\r\nport->iotype = UPIO_MEM32;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\nport->ops = &xuartps_ops;\r\nport->fifosize = XUARTPS_FIFO_SIZE;\r\nport->line = id;\r\nport->dev = NULL;\r\nreturn port;\r\n}\r\nstatic void xuartps_console_wait_tx(struct uart_port *port)\r\n{\r\nwhile ((xuartps_readl(XUARTPS_SR_OFFSET) & XUARTPS_SR_TXEMPTY)\r\n!= XUARTPS_SR_TXEMPTY)\r\nbarrier();\r\n}\r\nstatic void xuartps_console_putchar(struct uart_port *port, int ch)\r\n{\r\nxuartps_console_wait_tx(port);\r\nxuartps_writel(ch, XUARTPS_FIFO_OFFSET);\r\n}\r\nstatic void xuartps_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_port *port = &xuartps_port[co->index];\r\nunsigned long flags;\r\nunsigned int imr;\r\nint locked = 1;\r\nif (oops_in_progress)\r\nlocked = spin_trylock_irqsave(&port->lock, flags);\r\nelse\r\nspin_lock_irqsave(&port->lock, flags);\r\nimr = xuartps_readl(XUARTPS_IMR_OFFSET);\r\nxuartps_writel(imr, XUARTPS_IDR_OFFSET);\r\nuart_console_write(port, s, count, xuartps_console_putchar);\r\nxuartps_console_wait_tx(port);\r\nxuartps_writel(~imr, XUARTPS_IDR_OFFSET);\r\nxuartps_writel(imr, XUARTPS_IER_OFFSET);\r\nif (locked)\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int __init xuartps_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port = &xuartps_port[co->index];\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index < 0 || co->index >= XUARTPS_NR_PORTS)\r\nreturn -EINVAL;\r\nif (!port->mapbase) {\r\npr_debug("console on ttyPS%i not present\n", co->index);\r\nreturn -ENODEV;\r\n}\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init xuartps_console_init(void)\r\n{\r\nregister_console(&xuartps_console);\r\nreturn 0;\r\n}\r\nstatic int __devinit xuartps_probe(struct platform_device *pdev)\r\n{\r\nint rc;\r\nstruct uart_port *port;\r\nstruct resource *res, *res2;\r\nint clk = 0;\r\n#ifdef CONFIG_OF\r\nconst unsigned int *prop;\r\nprop = of_get_property(pdev->dev.of_node, "clock", NULL);\r\nif (prop)\r\nclk = be32_to_cpup(prop);\r\n#else\r\nclk = *((unsigned int *)(pdev->dev.platform_data));\r\n#endif\r\nif (!clk) {\r\ndev_err(&pdev->dev, "no clock specified\n");\r\nreturn -ENODEV;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nres2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res2)\r\nreturn -ENODEV;\r\nport = xuartps_get_port();\r\nif (!port) {\r\ndev_err(&pdev->dev, "Cannot get uart_port structure\n");\r\nreturn -ENODEV;\r\n} else {\r\nport->mapbase = res->start;\r\nport->irq = res2->start;\r\nport->dev = &pdev->dev;\r\nport->uartclk = clk;\r\ndev_set_drvdata(&pdev->dev, port);\r\nrc = uart_add_one_port(&xuartps_uart_driver, port);\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"uart_add_one_port() failed; err=%i\n", rc);\r\ndev_set_drvdata(&pdev->dev, NULL);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\n}\r\nstatic int __devexit xuartps_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port = dev_get_drvdata(&pdev->dev);\r\nint rc = 0;\r\nif (port) {\r\nrc = uart_remove_one_port(&xuartps_uart_driver, port);\r\ndev_set_drvdata(&pdev->dev, NULL);\r\nport->mapbase = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic int xuartps_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nuart_suspend_port(&xuartps_uart_driver, &xuartps_port[pdev->id]);\r\nreturn 0;\r\n}\r\nstatic int xuartps_resume(struct platform_device *pdev)\r\n{\r\nuart_resume_port(&xuartps_uart_driver, &xuartps_port[pdev->id]);\r\nreturn 0;\r\n}\r\nstatic int __init xuartps_init(void)\r\n{\r\nint retval = 0;\r\nretval = uart_register_driver(&xuartps_uart_driver);\r\nif (retval)\r\nreturn retval;\r\nretval = platform_driver_register(&xuartps_platform_driver);\r\nif (retval)\r\nuart_unregister_driver(&xuartps_uart_driver);\r\nreturn retval;\r\n}\r\nstatic void __exit xuartps_exit(void)\r\n{\r\nplatform_driver_unregister(&xuartps_platform_driver);\r\nuart_unregister_driver(&xuartps_uart_driver);\r\n}
