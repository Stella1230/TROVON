static inline int __tps6586x_read(struct i2c_client *client,\r\nint reg, uint8_t *val)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed reading at 0x%02x\n", reg);\r\nreturn ret;\r\n}\r\n*val = (uint8_t)ret;\r\nreturn 0;\r\n}\r\nstatic inline int __tps6586x_reads(struct i2c_client *client, int reg,\r\nint len, uint8_t *val)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_i2c_block_data(client, reg, len, val);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed reading from 0x%02x\n", reg);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int __tps6586x_write(struct i2c_client *client,\r\nint reg, uint8_t val)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, reg, val);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed writing 0x%02x to 0x%02x\n",\r\nval, reg);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int __tps6586x_writes(struct i2c_client *client, int reg,\r\nint len, uint8_t *val)\r\n{\r\nint ret, i;\r\nfor (i = 0; i < len; i++) {\r\nret = __tps6586x_write(client, reg + i, *(val + i));\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint tps6586x_write(struct device *dev, int reg, uint8_t val)\r\n{\r\nreturn __tps6586x_write(to_i2c_client(dev), reg, val);\r\n}\r\nint tps6586x_writes(struct device *dev, int reg, int len, uint8_t *val)\r\n{\r\nreturn __tps6586x_writes(to_i2c_client(dev), reg, len, val);\r\n}\r\nint tps6586x_read(struct device *dev, int reg, uint8_t *val)\r\n{\r\nreturn __tps6586x_read(to_i2c_client(dev), reg, val);\r\n}\r\nint tps6586x_reads(struct device *dev, int reg, int len, uint8_t *val)\r\n{\r\nreturn __tps6586x_reads(to_i2c_client(dev), reg, len, val);\r\n}\r\nint tps6586x_set_bits(struct device *dev, int reg, uint8_t bit_mask)\r\n{\r\nstruct tps6586x *tps6586x = dev_get_drvdata(dev);\r\nuint8_t reg_val;\r\nint ret = 0;\r\nmutex_lock(&tps6586x->lock);\r\nret = __tps6586x_read(to_i2c_client(dev), reg, &reg_val);\r\nif (ret)\r\ngoto out;\r\nif ((reg_val & bit_mask) != bit_mask) {\r\nreg_val |= bit_mask;\r\nret = __tps6586x_write(to_i2c_client(dev), reg, reg_val);\r\n}\r\nout:\r\nmutex_unlock(&tps6586x->lock);\r\nreturn ret;\r\n}\r\nint tps6586x_clr_bits(struct device *dev, int reg, uint8_t bit_mask)\r\n{\r\nstruct tps6586x *tps6586x = dev_get_drvdata(dev);\r\nuint8_t reg_val;\r\nint ret = 0;\r\nmutex_lock(&tps6586x->lock);\r\nret = __tps6586x_read(to_i2c_client(dev), reg, &reg_val);\r\nif (ret)\r\ngoto out;\r\nif (reg_val & bit_mask) {\r\nreg_val &= ~bit_mask;\r\nret = __tps6586x_write(to_i2c_client(dev), reg, reg_val);\r\n}\r\nout:\r\nmutex_unlock(&tps6586x->lock);\r\nreturn ret;\r\n}\r\nint tps6586x_update(struct device *dev, int reg, uint8_t val, uint8_t mask)\r\n{\r\nstruct tps6586x *tps6586x = dev_get_drvdata(dev);\r\nuint8_t reg_val;\r\nint ret = 0;\r\nmutex_lock(&tps6586x->lock);\r\nret = __tps6586x_read(tps6586x->client, reg, &reg_val);\r\nif (ret)\r\ngoto out;\r\nif ((reg_val & mask) != val) {\r\nreg_val = (reg_val & ~mask) | val;\r\nret = __tps6586x_write(tps6586x->client, reg, reg_val);\r\n}\r\nout:\r\nmutex_unlock(&tps6586x->lock);\r\nreturn ret;\r\n}\r\nstatic int tps6586x_gpio_get(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct tps6586x *tps6586x = container_of(gc, struct tps6586x, gpio);\r\nuint8_t val;\r\nint ret;\r\nret = __tps6586x_read(tps6586x->client, TPS6586X_GPIOSET2, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn !!(val & (1 << offset));\r\n}\r\nstatic void tps6586x_gpio_set(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct tps6586x *tps6586x = container_of(chip, struct tps6586x, gpio);\r\ntps6586x_update(tps6586x->dev, TPS6586X_GPIOSET2,\r\nvalue << offset, 1 << offset);\r\n}\r\nstatic int tps6586x_gpio_output(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\nstruct tps6586x *tps6586x = container_of(gc, struct tps6586x, gpio);\r\nuint8_t val, mask;\r\ntps6586x_gpio_set(gc, offset, value);\r\nval = 0x1 << (offset * 2);\r\nmask = 0x3 << (offset * 2);\r\nreturn tps6586x_update(tps6586x->dev, TPS6586X_GPIOSET1, val, mask);\r\n}\r\nstatic int tps6586x_gpio_init(struct tps6586x *tps6586x, int gpio_base)\r\n{\r\nif (!gpio_base)\r\nreturn 0;\r\ntps6586x->gpio.owner = THIS_MODULE;\r\ntps6586x->gpio.label = tps6586x->client->name;\r\ntps6586x->gpio.dev = tps6586x->dev;\r\ntps6586x->gpio.base = gpio_base;\r\ntps6586x->gpio.ngpio = 4;\r\ntps6586x->gpio.can_sleep = 1;\r\ntps6586x->gpio.direction_output = tps6586x_gpio_output;\r\ntps6586x->gpio.set = tps6586x_gpio_set;\r\ntps6586x->gpio.get = tps6586x_gpio_get;\r\nreturn gpiochip_add(&tps6586x->gpio);\r\n}\r\nstatic int __remove_subdev(struct device *dev, void *unused)\r\n{\r\nplatform_device_unregister(to_platform_device(dev));\r\nreturn 0;\r\n}\r\nstatic int tps6586x_remove_subdevs(struct tps6586x *tps6586x)\r\n{\r\nreturn device_for_each_child(tps6586x->dev, NULL, __remove_subdev);\r\n}\r\nstatic void tps6586x_irq_lock(struct irq_data *data)\r\n{\r\nstruct tps6586x *tps6586x = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&tps6586x->irq_lock);\r\n}\r\nstatic void tps6586x_irq_enable(struct irq_data *irq_data)\r\n{\r\nstruct tps6586x *tps6586x = irq_data_get_irq_chip_data(irq_data);\r\nunsigned int __irq = irq_data->irq - tps6586x->irq_base;\r\nconst struct tps6586x_irq_data *data = &tps6586x_irqs[__irq];\r\ntps6586x->mask_reg[data->mask_reg] &= ~data->mask_mask;\r\ntps6586x->irq_en |= (1 << __irq);\r\n}\r\nstatic void tps6586x_irq_disable(struct irq_data *irq_data)\r\n{\r\nstruct tps6586x *tps6586x = irq_data_get_irq_chip_data(irq_data);\r\nunsigned int __irq = irq_data->irq - tps6586x->irq_base;\r\nconst struct tps6586x_irq_data *data = &tps6586x_irqs[__irq];\r\ntps6586x->mask_reg[data->mask_reg] |= data->mask_mask;\r\ntps6586x->irq_en &= ~(1 << __irq);\r\n}\r\nstatic void tps6586x_irq_sync_unlock(struct irq_data *data)\r\n{\r\nstruct tps6586x *tps6586x = irq_data_get_irq_chip_data(data);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(tps6586x->mask_reg); i++) {\r\nif (tps6586x->mask_reg[i] != tps6586x->mask_cache[i]) {\r\nif (!WARN_ON(tps6586x_write(tps6586x->dev,\r\nTPS6586X_INT_MASK1 + i,\r\ntps6586x->mask_reg[i])))\r\ntps6586x->mask_cache[i] = tps6586x->mask_reg[i];\r\n}\r\n}\r\nmutex_unlock(&tps6586x->irq_lock);\r\n}\r\nstatic irqreturn_t tps6586x_irq(int irq, void *data)\r\n{\r\nstruct tps6586x *tps6586x = data;\r\nu32 acks;\r\nint ret = 0;\r\nret = tps6586x_reads(tps6586x->dev, TPS6586X_INT_ACK1,\r\nsizeof(acks), (uint8_t *)&acks);\r\nif (ret < 0) {\r\ndev_err(tps6586x->dev, "failed to read interrupt status\n");\r\nreturn IRQ_NONE;\r\n}\r\nacks = le32_to_cpu(acks);\r\nwhile (acks) {\r\nint i = __ffs(acks);\r\nif (tps6586x->irq_en & (1 << i))\r\nhandle_nested_irq(tps6586x->irq_base + i);\r\nacks &= ~(1 << i);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit tps6586x_irq_init(struct tps6586x *tps6586x, int irq,\r\nint irq_base)\r\n{\r\nint i, ret;\r\nu8 tmp[4];\r\nif (!irq_base) {\r\ndev_warn(tps6586x->dev, "No interrupt support on IRQ base\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_init(&tps6586x->irq_lock);\r\nfor (i = 0; i < 5; i++) {\r\ntps6586x->mask_cache[i] = 0xff;\r\ntps6586x->mask_reg[i] = 0xff;\r\ntps6586x_write(tps6586x->dev, TPS6586X_INT_MASK1 + i, 0xff);\r\n}\r\ntps6586x_reads(tps6586x->dev, TPS6586X_INT_ACK1, sizeof(tmp), tmp);\r\ntps6586x->irq_base = irq_base;\r\ntps6586x->irq_chip.name = "tps6586x";\r\ntps6586x->irq_chip.irq_enable = tps6586x_irq_enable;\r\ntps6586x->irq_chip.irq_disable = tps6586x_irq_disable;\r\ntps6586x->irq_chip.irq_bus_lock = tps6586x_irq_lock;\r\ntps6586x->irq_chip.irq_bus_sync_unlock = tps6586x_irq_sync_unlock;\r\nfor (i = 0; i < ARRAY_SIZE(tps6586x_irqs); i++) {\r\nint __irq = i + tps6586x->irq_base;\r\nirq_set_chip_data(__irq, tps6586x);\r\nirq_set_chip_and_handler(__irq, &tps6586x->irq_chip,\r\nhandle_simple_irq);\r\nirq_set_nested_thread(__irq, 1);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(__irq, IRQF_VALID);\r\n#endif\r\n}\r\nret = request_threaded_irq(irq, NULL, tps6586x_irq, IRQF_ONESHOT,\r\n"tps6586x", tps6586x);\r\nif (!ret) {\r\ndevice_init_wakeup(tps6586x->dev, 1);\r\nenable_irq_wake(irq);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devinit tps6586x_add_subdevs(struct tps6586x *tps6586x,\r\nstruct tps6586x_platform_data *pdata)\r\n{\r\nstruct tps6586x_subdev_info *subdev;\r\nstruct platform_device *pdev;\r\nint i, ret = 0;\r\nfor (i = 0; i < pdata->num_subdevs; i++) {\r\nsubdev = &pdata->subdevs[i];\r\npdev = platform_device_alloc(subdev->name, subdev->id);\r\nif (!pdev) {\r\nret = -ENOMEM;\r\ngoto failed;\r\n}\r\npdev->dev.parent = tps6586x->dev;\r\npdev->dev.platform_data = subdev->platform_data;\r\nret = platform_device_add(pdev);\r\nif (ret) {\r\nplatform_device_put(pdev);\r\ngoto failed;\r\n}\r\n}\r\nreturn 0;\r\nfailed:\r\ntps6586x_remove_subdevs(tps6586x);\r\nreturn ret;\r\n}\r\nstatic int __devinit tps6586x_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tps6586x_platform_data *pdata = client->dev.platform_data;\r\nstruct tps6586x *tps6586x;\r\nint ret;\r\nif (!pdata) {\r\ndev_err(&client->dev, "tps6586x requires platform data\n");\r\nreturn -ENOTSUPP;\r\n}\r\nret = i2c_smbus_read_byte_data(client, TPS6586X_VERSIONCRC);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Chip ID read failed: %d\n", ret);\r\nreturn -EIO;\r\n}\r\ndev_info(&client->dev, "VERSIONCRC is %02x\n", ret);\r\ntps6586x = kzalloc(sizeof(struct tps6586x), GFP_KERNEL);\r\nif (tps6586x == NULL)\r\nreturn -ENOMEM;\r\ntps6586x->client = client;\r\ntps6586x->dev = &client->dev;\r\ni2c_set_clientdata(client, tps6586x);\r\nmutex_init(&tps6586x->lock);\r\nif (client->irq) {\r\nret = tps6586x_irq_init(tps6586x, client->irq,\r\npdata->irq_base);\r\nif (ret) {\r\ndev_err(&client->dev, "IRQ init failed: %d\n", ret);\r\ngoto err_irq_init;\r\n}\r\n}\r\nret = tps6586x_gpio_init(tps6586x, pdata->gpio_base);\r\nif (ret) {\r\ndev_err(&client->dev, "GPIO registration failed: %d\n", ret);\r\ngoto err_gpio_init;\r\n}\r\nret = tps6586x_add_subdevs(tps6586x, pdata);\r\nif (ret) {\r\ndev_err(&client->dev, "add devices failed: %d\n", ret);\r\ngoto err_add_devs;\r\n}\r\nreturn 0;\r\nerr_add_devs:\r\nif (pdata->gpio_base) {\r\nret = gpiochip_remove(&tps6586x->gpio);\r\nif (ret)\r\ndev_err(&client->dev, "Can't remove gpio chip: %d\n",\r\nret);\r\n}\r\nerr_gpio_init:\r\nif (client->irq)\r\nfree_irq(client->irq, tps6586x);\r\nerr_irq_init:\r\nkfree(tps6586x);\r\nreturn ret;\r\n}\r\nstatic int __devexit tps6586x_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct tps6586x *tps6586x = i2c_get_clientdata(client);\r\nstruct tps6586x_platform_data *pdata = client->dev.platform_data;\r\nint ret;\r\nif (client->irq)\r\nfree_irq(client->irq, tps6586x);\r\nif (pdata->gpio_base) {\r\nret = gpiochip_remove(&tps6586x->gpio);\r\nif (ret)\r\ndev_err(&client->dev, "Can't remove gpio chip: %d\n",\r\nret);\r\n}\r\ntps6586x_remove_subdevs(tps6586x);\r\nkfree(tps6586x);\r\nreturn 0;\r\n}\r\nstatic int __init tps6586x_init(void)\r\n{\r\nreturn i2c_add_driver(&tps6586x_driver);\r\n}\r\nstatic void __exit tps6586x_exit(void)\r\n{\r\ni2c_del_driver(&tps6586x_driver);\r\n}
