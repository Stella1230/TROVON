static inline u64 readq(void __iomem *addr)\r\n{\r\nreturn readl(addr) | (((u64) readl(addr + 4)) << 32LL);\r\n}\r\nstatic inline void writeq(u64 val, void __iomem *addr)\r\n{\r\nwritel(((u32) (val)), (addr));\r\nwritel(((u32) (val >> 32)), (addr + 4));\r\n}\r\nstatic void __iomem *pci_base_offset(struct netxen_adapter *adapter,\r\nunsigned long off)\r\n{\r\nif (ADDR_IN_RANGE(off, FIRST_PAGE_GROUP_START, FIRST_PAGE_GROUP_END))\r\nreturn PCI_OFFSET_FIRST_RANGE(adapter, off);\r\nif (ADDR_IN_RANGE(off, SECOND_PAGE_GROUP_START, SECOND_PAGE_GROUP_END))\r\nreturn PCI_OFFSET_SECOND_RANGE(adapter, off);\r\nif (ADDR_IN_RANGE(off, THIRD_PAGE_GROUP_START, THIRD_PAGE_GROUP_END))\r\nreturn PCI_OFFSET_THIRD_RANGE(adapter, off);\r\nreturn NULL;\r\n}\r\nint\r\nnetxen_pcie_sem_lock(struct netxen_adapter *adapter, int sem, u32 id_reg)\r\n{\r\nint done = 0, timeout = 0;\r\nwhile (!done) {\r\ndone = NXRD32(adapter, NETXEN_PCIE_REG(PCIE_SEM_LOCK(sem)));\r\nif (done == 1)\r\nbreak;\r\nif (++timeout >= NETXEN_PCIE_SEM_TIMEOUT)\r\nreturn -EIO;\r\nmsleep(1);\r\n}\r\nif (id_reg)\r\nNXWR32(adapter, id_reg, adapter->portnum);\r\nreturn 0;\r\n}\r\nvoid\r\nnetxen_pcie_sem_unlock(struct netxen_adapter *adapter, int sem)\r\n{\r\nNXRD32(adapter, NETXEN_PCIE_REG(PCIE_SEM_UNLOCK(sem)));\r\n}\r\nstatic int netxen_niu_xg_init_port(struct netxen_adapter *adapter, int port)\r\n{\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\nNXWR32(adapter, NETXEN_NIU_XGE_CONFIG_1+(0x10000*port), 0x1447);\r\nNXWR32(adapter, NETXEN_NIU_XGE_CONFIG_0+(0x10000*port), 0x5);\r\n}\r\nreturn 0;\r\n}\r\nstatic int netxen_niu_disable_xg_port(struct netxen_adapter *adapter)\r\n{\r\n__u32 mac_cfg;\r\nu32 port = adapter->physical_port;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nreturn 0;\r\nif (port > NETXEN_NIU_MAX_XG_PORTS)\r\nreturn -EINVAL;\r\nmac_cfg = 0;\r\nif (NXWR32(adapter,\r\nNETXEN_NIU_XGE_CONFIG_0 + (0x10000 * port), mac_cfg))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int netxen_p2_nic_set_promisc(struct netxen_adapter *adapter, u32 mode)\r\n{\r\nu32 mac_cfg;\r\nu32 cnt = 0;\r\n__u32 reg = 0x0200;\r\nu32 port = adapter->physical_port;\r\nu16 board_type = adapter->ahw.board_type;\r\nif (port > NETXEN_NIU_MAX_XG_PORTS)\r\nreturn -EINVAL;\r\nmac_cfg = NXRD32(adapter, NETXEN_NIU_XGE_CONFIG_0 + (0x10000 * port));\r\nmac_cfg &= ~0x4;\r\nNXWR32(adapter, NETXEN_NIU_XGE_CONFIG_0 + (0x10000 * port), mac_cfg);\r\nif ((board_type == NETXEN_BRDTYPE_P2_SB31_10G_IMEZ) ||\r\n(board_type == NETXEN_BRDTYPE_P2_SB31_10G_HMEZ))\r\nreg = (0x20 << port);\r\nNXWR32(adapter, NETXEN_NIU_FRAME_COUNT_SELECT, reg);\r\nmdelay(10);\r\nwhile (NXRD32(adapter, NETXEN_NIU_FRAME_COUNT) && ++cnt < 20)\r\nmdelay(10);\r\nif (cnt < 20) {\r\nreg = NXRD32(adapter,\r\nNETXEN_NIU_XGE_CONFIG_1 + (0x10000 * port));\r\nif (mode == NETXEN_NIU_PROMISC_MODE)\r\nreg = (reg | 0x2000UL);\r\nelse\r\nreg = (reg & ~0x2000UL);\r\nif (mode == NETXEN_NIU_ALLMULTI_MODE)\r\nreg = (reg | 0x1000UL);\r\nelse\r\nreg = (reg & ~0x1000UL);\r\nNXWR32(adapter,\r\nNETXEN_NIU_XGE_CONFIG_1 + (0x10000 * port), reg);\r\n}\r\nmac_cfg |= 0x4;\r\nNXWR32(adapter, NETXEN_NIU_XGE_CONFIG_0 + (0x10000 * port), mac_cfg);\r\nreturn 0;\r\n}\r\nstatic int netxen_p2_nic_set_mac_addr(struct netxen_adapter *adapter, u8 *addr)\r\n{\r\nu32 mac_hi, mac_lo;\r\nu32 reg_hi, reg_lo;\r\nu8 phy = adapter->physical_port;\r\nif (phy >= NETXEN_NIU_MAX_XG_PORTS)\r\nreturn -EINVAL;\r\nmac_lo = ((u32)addr[0] << 16) | ((u32)addr[1] << 24);\r\nmac_hi = addr[2] | ((u32)addr[3] << 8) |\r\n((u32)addr[4] << 16) | ((u32)addr[5] << 24);\r\nreg_lo = NETXEN_NIU_XGE_STATION_ADDR_0_1 + (0x10000 * phy);\r\nreg_hi = NETXEN_NIU_XGE_STATION_ADDR_0_HI + (0x10000 * phy);\r\nif (NXWR32(adapter, reg_lo, mac_lo) || NXWR32(adapter, reg_hi, mac_hi))\r\nreturn -EIO;\r\nif (NXWR32(adapter, reg_lo, mac_lo) || NXWR32(adapter, reg_hi, mac_hi))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_nic_enable_mcast_filter(struct netxen_adapter *adapter)\r\n{\r\nu32 val = 0;\r\nu16 port = adapter->physical_port;\r\nu8 *addr = adapter->mac_addr;\r\nif (adapter->mc_enabled)\r\nreturn 0;\r\nval = NXRD32(adapter, NETXEN_MAC_ADDR_CNTL_REG);\r\nval |= (1UL << (28+port));\r\nNXWR32(adapter, NETXEN_MAC_ADDR_CNTL_REG, val);\r\nval = 0xffffff;\r\nNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 0), val);\r\nNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 0)+4, val);\r\nval = MAC_HI(addr);\r\nNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 1), val);\r\nval = MAC_LO(addr);\r\nNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 1)+4, val);\r\nadapter->mc_enabled = 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_nic_disable_mcast_filter(struct netxen_adapter *adapter)\r\n{\r\nu32 val = 0;\r\nu16 port = adapter->physical_port;\r\nu8 *addr = adapter->mac_addr;\r\nif (!adapter->mc_enabled)\r\nreturn 0;\r\nval = NXRD32(adapter, NETXEN_MAC_ADDR_CNTL_REG);\r\nval &= ~(1UL << (28+port));\r\nNXWR32(adapter, NETXEN_MAC_ADDR_CNTL_REG, val);\r\nval = MAC_HI(addr);\r\nNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 0), val);\r\nval = MAC_LO(addr);\r\nNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 0)+4, val);\r\nNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 1), 0);\r\nNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 1)+4, 0);\r\nadapter->mc_enabled = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_nic_set_mcast_addr(struct netxen_adapter *adapter,\r\nint index, u8 *addr)\r\n{\r\nu32 hi = 0, lo = 0;\r\nu16 port = adapter->physical_port;\r\nlo = MAC_LO(addr);\r\nhi = MAC_HI(addr);\r\nNXWR32(adapter, NETXEN_MCAST_ADDR(port, index), hi);\r\nNXWR32(adapter, NETXEN_MCAST_ADDR(port, index)+4, lo);\r\nreturn 0;\r\n}\r\nstatic void netxen_p2_nic_set_multi(struct net_device *netdev)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nstruct netdev_hw_addr *ha;\r\nu8 null_addr[6];\r\nint i;\r\nmemset(null_addr, 0, 6);\r\nif (netdev->flags & IFF_PROMISC) {\r\nadapter->set_promisc(adapter,\r\nNETXEN_NIU_PROMISC_MODE);\r\nnetxen_nic_disable_mcast_filter(adapter);\r\nreturn;\r\n}\r\nif (netdev_mc_empty(netdev)) {\r\nadapter->set_promisc(adapter,\r\nNETXEN_NIU_NON_PROMISC_MODE);\r\nnetxen_nic_disable_mcast_filter(adapter);\r\nreturn;\r\n}\r\nadapter->set_promisc(adapter, NETXEN_NIU_ALLMULTI_MODE);\r\nif (netdev->flags & IFF_ALLMULTI ||\r\nnetdev_mc_count(netdev) > adapter->max_mc_count) {\r\nnetxen_nic_disable_mcast_filter(adapter);\r\nreturn;\r\n}\r\nnetxen_nic_enable_mcast_filter(adapter);\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, netdev)\r\nnetxen_nic_set_mcast_addr(adapter, i++, ha->addr);\r\nwhile (i < adapter->max_mc_count)\r\nnetxen_nic_set_mcast_addr(adapter, i++, null_addr);\r\n}\r\nstatic int\r\nnetxen_send_cmd_descs(struct netxen_adapter *adapter,\r\nstruct cmd_desc_type0 *cmd_desc_arr, int nr_desc)\r\n{\r\nu32 i, producer, consumer;\r\nstruct netxen_cmd_buffer *pbuf;\r\nstruct cmd_desc_type0 *cmd_desc;\r\nstruct nx_host_tx_ring *tx_ring;\r\ni = 0;\r\nif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\r\nreturn -EIO;\r\ntx_ring = adapter->tx_ring;\r\n__netif_tx_lock_bh(tx_ring->txq);\r\nproducer = tx_ring->producer;\r\nconsumer = tx_ring->sw_consumer;\r\nif (nr_desc >= netxen_tx_avail(tx_ring)) {\r\nnetif_tx_stop_queue(tx_ring->txq);\r\nsmp_mb();\r\nif (netxen_tx_avail(tx_ring) > nr_desc) {\r\nif (netxen_tx_avail(tx_ring) > TX_STOP_THRESH)\r\nnetif_tx_wake_queue(tx_ring->txq);\r\n} else {\r\n__netif_tx_unlock_bh(tx_ring->txq);\r\nreturn -EBUSY;\r\n}\r\n}\r\ndo {\r\ncmd_desc = &cmd_desc_arr[i];\r\npbuf = &tx_ring->cmd_buf_arr[producer];\r\npbuf->skb = NULL;\r\npbuf->frag_count = 0;\r\nmemcpy(&tx_ring->desc_head[producer],\r\n&cmd_desc_arr[i], sizeof(struct cmd_desc_type0));\r\nproducer = get_next_index(producer, tx_ring->num_desc);\r\ni++;\r\n} while (i != nr_desc);\r\ntx_ring->producer = producer;\r\nnetxen_nic_update_cmd_producer(adapter, tx_ring);\r\n__netif_tx_unlock_bh(tx_ring->txq);\r\nreturn 0;\r\n}\r\nstatic int\r\nnx_p3_sre_macaddr_change(struct netxen_adapter *adapter, u8 *addr, unsigned op)\r\n{\r\nnx_nic_req_t req;\r\nnx_mac_req_t *mac_req;\r\nu64 word;\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nreq.qhdr = cpu_to_le64(NX_NIC_REQUEST << 23);\r\nword = NX_MAC_EVENT | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nmac_req = (nx_mac_req_t *)&req.words[0];\r\nmac_req->op = op;\r\nmemcpy(mac_req->mac_addr, addr, 6);\r\nreturn netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\n}\r\nstatic int nx_p3_nic_add_mac(struct netxen_adapter *adapter,\r\nconst u8 *addr, struct list_head *del_list)\r\n{\r\nstruct list_head *head;\r\nnx_mac_list_t *cur;\r\nlist_for_each(head, del_list) {\r\ncur = list_entry(head, nx_mac_list_t, list);\r\nif (memcmp(addr, cur->mac_addr, ETH_ALEN) == 0) {\r\nlist_move_tail(head, &adapter->mac_list);\r\nreturn 0;\r\n}\r\n}\r\ncur = kzalloc(sizeof(nx_mac_list_t), GFP_ATOMIC);\r\nif (cur == NULL) {\r\nprintk(KERN_ERR "%s: failed to add mac address filter\n",\r\nadapter->netdev->name);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(cur->mac_addr, addr, ETH_ALEN);\r\nlist_add_tail(&cur->list, &adapter->mac_list);\r\nreturn nx_p3_sre_macaddr_change(adapter,\r\ncur->mac_addr, NETXEN_MAC_ADD);\r\n}\r\nstatic void netxen_p3_nic_set_multi(struct net_device *netdev)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nstruct netdev_hw_addr *ha;\r\nstatic const u8 bcast_addr[ETH_ALEN] = {\r\n0xff, 0xff, 0xff, 0xff, 0xff, 0xff\r\n};\r\nu32 mode = VPORT_MISS_MODE_DROP;\r\nLIST_HEAD(del_list);\r\nstruct list_head *head;\r\nnx_mac_list_t *cur;\r\nif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\r\nreturn;\r\nlist_splice_tail_init(&adapter->mac_list, &del_list);\r\nnx_p3_nic_add_mac(adapter, adapter->mac_addr, &del_list);\r\nnx_p3_nic_add_mac(adapter, bcast_addr, &del_list);\r\nif (netdev->flags & IFF_PROMISC) {\r\nmode = VPORT_MISS_MODE_ACCEPT_ALL;\r\ngoto send_fw_cmd;\r\n}\r\nif ((netdev->flags & IFF_ALLMULTI) ||\r\n(netdev_mc_count(netdev) > adapter->max_mc_count)) {\r\nmode = VPORT_MISS_MODE_ACCEPT_MULTI;\r\ngoto send_fw_cmd;\r\n}\r\nif (!netdev_mc_empty(netdev)) {\r\nnetdev_for_each_mc_addr(ha, netdev)\r\nnx_p3_nic_add_mac(adapter, ha->addr, &del_list);\r\n}\r\nsend_fw_cmd:\r\nadapter->set_promisc(adapter, mode);\r\nhead = &del_list;\r\nwhile (!list_empty(head)) {\r\ncur = list_entry(head->next, nx_mac_list_t, list);\r\nnx_p3_sre_macaddr_change(adapter,\r\ncur->mac_addr, NETXEN_MAC_DEL);\r\nlist_del(&cur->list);\r\nkfree(cur);\r\n}\r\n}\r\nstatic int netxen_p3_nic_set_promisc(struct netxen_adapter *adapter, u32 mode)\r\n{\r\nnx_nic_req_t req;\r\nu64 word;\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nreq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\r\nword = NX_NIC_H2C_OPCODE_PROXY_SET_VPORT_MISS_MODE |\r\n((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(mode);\r\nreturn netxen_send_cmd_descs(adapter,\r\n(struct cmd_desc_type0 *)&req, 1);\r\n}\r\nvoid netxen_p3_free_mac_list(struct netxen_adapter *adapter)\r\n{\r\nnx_mac_list_t *cur;\r\nstruct list_head *head = &adapter->mac_list;\r\nwhile (!list_empty(head)) {\r\ncur = list_entry(head->next, nx_mac_list_t, list);\r\nnx_p3_sre_macaddr_change(adapter,\r\ncur->mac_addr, NETXEN_MAC_DEL);\r\nlist_del(&cur->list);\r\nkfree(cur);\r\n}\r\n}\r\nstatic int netxen_p3_nic_set_mac_addr(struct netxen_adapter *adapter, u8 *addr)\r\n{\r\nnetxen_p3_nic_set_multi(adapter->netdev);\r\nreturn 0;\r\n}\r\nint netxen_config_intr_coalesce(struct netxen_adapter *adapter)\r\n{\r\nnx_nic_req_t req;\r\nu64 word[6];\r\nint rv, i;\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nmemset(word, 0, sizeof(word));\r\nreq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\r\nword[0] = NETXEN_CONFIG_INTR_COALESCE | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word[0]);\r\nmemcpy(&word[0], &adapter->coal, sizeof(adapter->coal));\r\nfor (i = 0; i < 6; i++)\r\nreq.words[i] = cpu_to_le64(word[i]);\r\nrv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0) {\r\nprintk(KERN_ERR "ERROR. Could not send "\r\n"interrupt coalescing parameters\n");\r\n}\r\nreturn rv;\r\n}\r\nint netxen_config_hw_lro(struct netxen_adapter *adapter, int enable)\r\n{\r\nnx_nic_req_t req;\r\nu64 word;\r\nint rv = 0;\r\nif (!test_bit(__NX_FW_ATTACHED, &adapter->state))\r\nreturn 0;\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nreq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\r\nword = NX_NIC_H2C_OPCODE_CONFIG_HW_LRO | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(enable);\r\nrv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0) {\r\nprintk(KERN_ERR "ERROR. Could not send "\r\n"configure hw lro request\n");\r\n}\r\nreturn rv;\r\n}\r\nint netxen_config_bridged_mode(struct netxen_adapter *adapter, int enable)\r\n{\r\nnx_nic_req_t req;\r\nu64 word;\r\nint rv = 0;\r\nif (!!(adapter->flags & NETXEN_NIC_BRIDGE_ENABLED) == enable)\r\nreturn rv;\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nreq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\r\nword = NX_NIC_H2C_OPCODE_CONFIG_BRIDGING |\r\n((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(enable);\r\nrv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0) {\r\nprintk(KERN_ERR "ERROR. Could not send "\r\n"configure bridge mode request\n");\r\n}\r\nadapter->flags ^= NETXEN_NIC_BRIDGE_ENABLED;\r\nreturn rv;\r\n}\r\nint netxen_config_rss(struct netxen_adapter *adapter, int enable)\r\n{\r\nnx_nic_req_t req;\r\nu64 word;\r\nint i, rv;\r\nstatic const u64 key[] = {\r\n0xbeac01fa6a42b73bULL, 0x8030f20c77cb2da3ULL,\r\n0xae7b30b4d0ca2bcbULL, 0x43a38fb04167253dULL,\r\n0x255b0ec26d5a56daULL\r\n};\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nreq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\r\nword = NX_NIC_H2C_OPCODE_CONFIG_RSS | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nword = ((u64)(RSS_HASHTYPE_IP_TCP & 0x3) << 4) |\r\n((u64)(RSS_HASHTYPE_IP_TCP & 0x3) << 6) |\r\n((u64)(enable & 0x1) << 8) |\r\n((0x7ULL) << 48);\r\nreq.words[0] = cpu_to_le64(word);\r\nfor (i = 0; i < ARRAY_SIZE(key); i++)\r\nreq.words[i+1] = cpu_to_le64(key[i]);\r\nrv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0) {\r\nprintk(KERN_ERR "%s: could not configure RSS\n",\r\nadapter->netdev->name);\r\n}\r\nreturn rv;\r\n}\r\nint netxen_config_ipaddr(struct netxen_adapter *adapter, u32 ip, int cmd)\r\n{\r\nnx_nic_req_t req;\r\nu64 word;\r\nint rv;\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nreq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\r\nword = NX_NIC_H2C_OPCODE_CONFIG_IPADDR | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(cmd);\r\nreq.words[1] = cpu_to_le64(ip);\r\nrv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0) {\r\nprintk(KERN_ERR "%s: could not notify %s IP 0x%x reuqest\n",\r\nadapter->netdev->name,\r\n(cmd == NX_IP_UP) ? "Add" : "Remove", ip);\r\n}\r\nreturn rv;\r\n}\r\nint netxen_linkevent_request(struct netxen_adapter *adapter, int enable)\r\n{\r\nnx_nic_req_t req;\r\nu64 word;\r\nint rv;\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nreq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\r\nword = NX_NIC_H2C_OPCODE_GET_LINKEVENT | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(enable | (enable << 8));\r\nrv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0) {\r\nprintk(KERN_ERR "%s: could not configure link notification\n",\r\nadapter->netdev->name);\r\n}\r\nreturn rv;\r\n}\r\nint netxen_send_lro_cleanup(struct netxen_adapter *adapter)\r\n{\r\nnx_nic_req_t req;\r\nu64 word;\r\nint rv;\r\nif (!test_bit(__NX_FW_ATTACHED, &adapter->state))\r\nreturn 0;\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nreq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\r\nword = NX_NIC_H2C_OPCODE_LRO_REQUEST |\r\n((u64)adapter->portnum << 16) |\r\n((u64)NX_NIC_LRO_REQUEST_CLEANUP << 56) ;\r\nreq.req_hdr = cpu_to_le64(word);\r\nrv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0) {\r\nprintk(KERN_ERR "%s: could not cleanup lro flows\n",\r\nadapter->netdev->name);\r\n}\r\nreturn rv;\r\n}\r\nint netxen_nic_change_mtu(struct net_device *netdev, int mtu)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nint max_mtu;\r\nint rc = 0;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nmax_mtu = P3_MAX_MTU;\r\nelse\r\nmax_mtu = P2_MAX_MTU;\r\nif (mtu > max_mtu) {\r\nprintk(KERN_ERR "%s: mtu > %d bytes unsupported\n",\r\nnetdev->name, max_mtu);\r\nreturn -EINVAL;\r\n}\r\nif (adapter->set_mtu)\r\nrc = adapter->set_mtu(adapter, mtu);\r\nif (!rc)\r\nnetdev->mtu = mtu;\r\nreturn rc;\r\n}\r\nstatic int netxen_get_flash_block(struct netxen_adapter *adapter, int base,\r\nint size, __le32 * buf)\r\n{\r\nint i, v, addr;\r\n__le32 *ptr32;\r\naddr = base;\r\nptr32 = buf;\r\nfor (i = 0; i < size / sizeof(u32); i++) {\r\nif (netxen_rom_fast_read(adapter, addr, &v) == -1)\r\nreturn -1;\r\n*ptr32 = cpu_to_le32(v);\r\nptr32++;\r\naddr += sizeof(u32);\r\n}\r\nif ((char *)buf + size > (char *)ptr32) {\r\n__le32 local;\r\nif (netxen_rom_fast_read(adapter, addr, &v) == -1)\r\nreturn -1;\r\nlocal = cpu_to_le32(v);\r\nmemcpy(ptr32, &local, (char *)buf + size - (char *)ptr32);\r\n}\r\nreturn 0;\r\n}\r\nint netxen_get_flash_mac_addr(struct netxen_adapter *adapter, u64 *mac)\r\n{\r\n__le32 *pmac = (__le32 *) mac;\r\nu32 offset;\r\noffset = NX_FW_MAC_ADDR_OFFSET + (adapter->portnum * sizeof(u64));\r\nif (netxen_get_flash_block(adapter, offset, sizeof(u64), pmac) == -1)\r\nreturn -1;\r\nif (*mac == cpu_to_le64(~0ULL)) {\r\noffset = NX_OLD_MAC_ADDR_OFFSET +\r\n(adapter->portnum * sizeof(u64));\r\nif (netxen_get_flash_block(adapter,\r\noffset, sizeof(u64), pmac) == -1)\r\nreturn -1;\r\nif (*mac == cpu_to_le64(~0ULL))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint netxen_p3_get_mac_addr(struct netxen_adapter *adapter, u64 *mac)\r\n{\r\nuint32_t crbaddr, mac_hi, mac_lo;\r\nint pci_func = adapter->ahw.pci_func;\r\ncrbaddr = CRB_MAC_BLOCK_START +\r\n(4 * ((pci_func/2) * 3)) + (4 * (pci_func & 1));\r\nmac_lo = NXRD32(adapter, crbaddr);\r\nmac_hi = NXRD32(adapter, crbaddr+4);\r\nif (pci_func & 1)\r\n*mac = le64_to_cpu((mac_lo >> 16) | ((u64)mac_hi << 16));\r\nelse\r\n*mac = le64_to_cpu((u64)mac_lo | ((u64)mac_hi << 32));\r\nreturn 0;\r\n}\r\nstatic void\r\nnetxen_nic_pci_set_crbwindow_128M(struct netxen_adapter *adapter,\r\nu32 window)\r\n{\r\nvoid __iomem *offset;\r\nint count = 10;\r\nu8 func = adapter->ahw.pci_func;\r\nif (adapter->ahw.crb_win == window)\r\nreturn;\r\noffset = PCI_OFFSET_SECOND_RANGE(adapter,\r\nNETXEN_PCIX_PH_REG(PCIE_CRB_WINDOW_REG(func)));\r\nwritel(window, offset);\r\ndo {\r\nif (window == readl(offset))\r\nbreak;\r\nif (printk_ratelimit())\r\ndev_warn(&adapter->pdev->dev,\r\n"failed to set CRB window to %d\n",\r\n(window == NETXEN_WINDOW_ONE));\r\nudelay(1);\r\n} while (--count > 0);\r\nif (count > 0)\r\nadapter->ahw.crb_win = window;\r\n}\r\nstatic int\r\nnetxen_nic_pci_get_crb_addr_2M(struct netxen_adapter *adapter,\r\nulong off, void __iomem **addr)\r\n{\r\ncrb_128M_2M_sub_block_map_t *m;\r\nif ((off >= NETXEN_CRB_MAX) || (off < NETXEN_PCI_CRBSPACE))\r\nreturn -EINVAL;\r\noff -= NETXEN_PCI_CRBSPACE;\r\nm = &crb_128M_2M_map[CRB_BLK(off)].sub_block[CRB_SUBBLK(off)];\r\nif (m->valid && (m->start_128M <= off) && (m->end_128M > off)) {\r\n*addr = adapter->ahw.pci_base0 + m->start_2M +\r\n(off - m->start_128M);\r\nreturn 0;\r\n}\r\n*addr = adapter->ahw.pci_base0 + CRB_INDIRECT_2M +\r\n(off & MASK(16));\r\nreturn 1;\r\n}\r\nstatic void\r\nnetxen_nic_pci_set_crbwindow_2M(struct netxen_adapter *adapter, ulong off)\r\n{\r\nu32 window;\r\nvoid __iomem *addr = adapter->ahw.pci_base0 + CRB_WINDOW_2M;\r\noff -= NETXEN_PCI_CRBSPACE;\r\nwindow = CRB_HI(off);\r\nwritel(window, addr);\r\nif (readl(addr) != window) {\r\nif (printk_ratelimit())\r\ndev_warn(&adapter->pdev->dev,\r\n"failed to set CRB window to %d off 0x%lx\n",\r\nwindow, off);\r\n}\r\n}\r\nstatic void __iomem *\r\nnetxen_nic_map_indirect_address_128M(struct netxen_adapter *adapter,\r\nulong win_off, void __iomem **mem_ptr)\r\n{\r\nulong off = win_off;\r\nvoid __iomem *addr;\r\nresource_size_t mem_base;\r\nif (ADDR_IN_WINDOW1(win_off))\r\noff = NETXEN_CRB_NORMAL(win_off);\r\naddr = pci_base_offset(adapter, off);\r\nif (addr)\r\nreturn addr;\r\nif (adapter->ahw.pci_len0 == 0)\r\noff -= NETXEN_PCI_CRBSPACE;\r\nmem_base = pci_resource_start(adapter->pdev, 0);\r\n*mem_ptr = ioremap(mem_base + (off & PAGE_MASK), PAGE_SIZE);\r\nif (*mem_ptr)\r\naddr = *mem_ptr + (off & (PAGE_SIZE - 1));\r\nreturn addr;\r\n}\r\nstatic int\r\nnetxen_nic_hw_write_wx_128M(struct netxen_adapter *adapter, ulong off, u32 data)\r\n{\r\nunsigned long flags;\r\nvoid __iomem *addr, *mem_ptr = NULL;\r\naddr = netxen_nic_map_indirect_address_128M(adapter, off, &mem_ptr);\r\nif (!addr)\r\nreturn -EIO;\r\nif (ADDR_IN_WINDOW1(off)) {\r\nnetxen_nic_io_write_128M(adapter, addr, data);\r\n} else {\r\nwrite_lock_irqsave(&adapter->ahw.crb_lock, flags);\r\nnetxen_nic_pci_set_crbwindow_128M(adapter, 0);\r\nwritel(data, addr);\r\nnetxen_nic_pci_set_crbwindow_128M(adapter,\r\nNETXEN_WINDOW_ONE);\r\nwrite_unlock_irqrestore(&adapter->ahw.crb_lock, flags);\r\n}\r\nif (mem_ptr)\r\niounmap(mem_ptr);\r\nreturn 0;\r\n}\r\nstatic u32\r\nnetxen_nic_hw_read_wx_128M(struct netxen_adapter *adapter, ulong off)\r\n{\r\nunsigned long flags;\r\nvoid __iomem *addr, *mem_ptr = NULL;\r\nu32 data;\r\naddr = netxen_nic_map_indirect_address_128M(adapter, off, &mem_ptr);\r\nif (!addr)\r\nreturn -EIO;\r\nif (ADDR_IN_WINDOW1(off)) {\r\ndata = netxen_nic_io_read_128M(adapter, addr);\r\n} else {\r\nwrite_lock_irqsave(&adapter->ahw.crb_lock, flags);\r\nnetxen_nic_pci_set_crbwindow_128M(adapter, 0);\r\ndata = readl(addr);\r\nnetxen_nic_pci_set_crbwindow_128M(adapter,\r\nNETXEN_WINDOW_ONE);\r\nwrite_unlock_irqrestore(&adapter->ahw.crb_lock, flags);\r\n}\r\nif (mem_ptr)\r\niounmap(mem_ptr);\r\nreturn data;\r\n}\r\nstatic int\r\nnetxen_nic_hw_write_wx_2M(struct netxen_adapter *adapter, ulong off, u32 data)\r\n{\r\nunsigned long flags;\r\nint rv;\r\nvoid __iomem *addr = NULL;\r\nrv = netxen_nic_pci_get_crb_addr_2M(adapter, off, &addr);\r\nif (rv == 0) {\r\nwritel(data, addr);\r\nreturn 0;\r\n}\r\nif (rv > 0) {\r\nwrite_lock_irqsave(&adapter->ahw.crb_lock, flags);\r\ncrb_win_lock(adapter);\r\nnetxen_nic_pci_set_crbwindow_2M(adapter, off);\r\nwritel(data, addr);\r\ncrb_win_unlock(adapter);\r\nwrite_unlock_irqrestore(&adapter->ahw.crb_lock, flags);\r\nreturn 0;\r\n}\r\ndev_err(&adapter->pdev->dev,\r\n"%s: invalid offset: 0x%016lx\n", __func__, off);\r\ndump_stack();\r\nreturn -EIO;\r\n}\r\nstatic u32\r\nnetxen_nic_hw_read_wx_2M(struct netxen_adapter *adapter, ulong off)\r\n{\r\nunsigned long flags;\r\nint rv;\r\nu32 data;\r\nvoid __iomem *addr = NULL;\r\nrv = netxen_nic_pci_get_crb_addr_2M(adapter, off, &addr);\r\nif (rv == 0)\r\nreturn readl(addr);\r\nif (rv > 0) {\r\nwrite_lock_irqsave(&adapter->ahw.crb_lock, flags);\r\ncrb_win_lock(adapter);\r\nnetxen_nic_pci_set_crbwindow_2M(adapter, off);\r\ndata = readl(addr);\r\ncrb_win_unlock(adapter);\r\nwrite_unlock_irqrestore(&adapter->ahw.crb_lock, flags);\r\nreturn data;\r\n}\r\ndev_err(&adapter->pdev->dev,\r\n"%s: invalid offset: 0x%016lx\n", __func__, off);\r\ndump_stack();\r\nreturn -1;\r\n}\r\nstatic void netxen_nic_io_write_128M(struct netxen_adapter *adapter,\r\nvoid __iomem *addr, u32 data)\r\n{\r\nread_lock(&adapter->ahw.crb_lock);\r\nwritel(data, addr);\r\nread_unlock(&adapter->ahw.crb_lock);\r\n}\r\nstatic u32 netxen_nic_io_read_128M(struct netxen_adapter *adapter,\r\nvoid __iomem *addr)\r\n{\r\nu32 val;\r\nread_lock(&adapter->ahw.crb_lock);\r\nval = readl(addr);\r\nread_unlock(&adapter->ahw.crb_lock);\r\nreturn val;\r\n}\r\nstatic void netxen_nic_io_write_2M(struct netxen_adapter *adapter,\r\nvoid __iomem *addr, u32 data)\r\n{\r\nwritel(data, addr);\r\n}\r\nstatic u32 netxen_nic_io_read_2M(struct netxen_adapter *adapter,\r\nvoid __iomem *addr)\r\n{\r\nreturn readl(addr);\r\n}\r\nvoid __iomem *\r\nnetxen_get_ioaddr(struct netxen_adapter *adapter, u32 offset)\r\n{\r\nvoid __iomem *addr = NULL;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\nif ((offset < NETXEN_CRB_PCIX_HOST2) &&\r\n(offset > NETXEN_CRB_PCIX_HOST))\r\naddr = PCI_OFFSET_SECOND_RANGE(adapter, offset);\r\nelse\r\naddr = NETXEN_CRB_NORMALIZE(adapter, offset);\r\n} else {\r\nWARN_ON(netxen_nic_pci_get_crb_addr_2M(adapter,\r\noffset, &addr));\r\n}\r\nreturn addr;\r\n}\r\nstatic int\r\nnetxen_nic_pci_set_window_128M(struct netxen_adapter *adapter,\r\nu64 addr, u32 *start)\r\n{\r\nif (ADDR_IN_RANGE(addr, NETXEN_ADDR_OCM0, NETXEN_ADDR_OCM0_MAX)) {\r\n*start = (addr - NETXEN_ADDR_OCM0 + NETXEN_PCI_OCM0);\r\nreturn 0;\r\n} else if (ADDR_IN_RANGE(addr,\r\nNETXEN_ADDR_OCM1, NETXEN_ADDR_OCM1_MAX)) {\r\n*start = (addr - NETXEN_ADDR_OCM1 + NETXEN_PCI_OCM1);\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int\r\nnetxen_nic_pci_set_window_2M(struct netxen_adapter *adapter,\r\nu64 addr, u32 *start)\r\n{\r\nu32 window;\r\nwindow = OCM_WIN(addr);\r\nwritel(window, adapter->ahw.ocm_win_crb);\r\nreadl(adapter->ahw.ocm_win_crb);\r\nadapter->ahw.ocm_win = window;\r\n*start = NETXEN_PCI_OCM0_2M + GET_MEM_OFFS_2M(addr);\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_nic_pci_mem_access_direct(struct netxen_adapter *adapter, u64 off,\r\nu64 *data, int op)\r\n{\r\nvoid __iomem *addr, *mem_ptr = NULL;\r\nresource_size_t mem_base;\r\nint ret;\r\nu32 start;\r\nspin_lock(&adapter->ahw.mem_lock);\r\nret = adapter->pci_set_window(adapter, off, &start);\r\nif (ret != 0)\r\ngoto unlock;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\naddr = adapter->ahw.pci_base0 + start;\r\n} else {\r\naddr = pci_base_offset(adapter, start);\r\nif (addr)\r\ngoto noremap;\r\nmem_base = pci_resource_start(adapter->pdev, 0) +\r\n(start & PAGE_MASK);\r\nmem_ptr = ioremap(mem_base, PAGE_SIZE);\r\nif (mem_ptr == NULL) {\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\naddr = mem_ptr + (start & (PAGE_SIZE-1));\r\n}\r\nnoremap:\r\nif (op == 0)\r\n*data = readq(addr);\r\nelse\r\nwriteq(*data, addr);\r\nunlock:\r\nspin_unlock(&adapter->ahw.mem_lock);\r\nif (mem_ptr)\r\niounmap(mem_ptr);\r\nreturn ret;\r\n}\r\nvoid\r\nnetxen_pci_camqm_read_2M(struct netxen_adapter *adapter, u64 off, u64 *data)\r\n{\r\nvoid __iomem *addr = adapter->ahw.pci_base0 +\r\nNETXEN_PCI_CAMQM_2M_BASE + (off - NETXEN_PCI_CAMQM);\r\nspin_lock(&adapter->ahw.mem_lock);\r\n*data = readq(addr);\r\nspin_unlock(&adapter->ahw.mem_lock);\r\n}\r\nvoid\r\nnetxen_pci_camqm_write_2M(struct netxen_adapter *adapter, u64 off, u64 data)\r\n{\r\nvoid __iomem *addr = adapter->ahw.pci_base0 +\r\nNETXEN_PCI_CAMQM_2M_BASE + (off - NETXEN_PCI_CAMQM);\r\nspin_lock(&adapter->ahw.mem_lock);\r\nwriteq(data, addr);\r\nspin_unlock(&adapter->ahw.mem_lock);\r\n}\r\nstatic int\r\nnetxen_nic_pci_mem_write_128M(struct netxen_adapter *adapter,\r\nu64 off, u64 data)\r\n{\r\nint j, ret;\r\nu32 temp, off_lo, off_hi, addr_hi, data_hi, data_lo;\r\nvoid __iomem *mem_crb;\r\nif (off & 7)\r\nreturn -EIO;\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_QDR_NET,\r\nNETXEN_ADDR_QDR_NET_MAX_P2)) {\r\nmem_crb = pci_base_offset(adapter,\r\nNETXEN_CRB_QDR_NET+SIU_TEST_AGT_BASE);\r\naddr_hi = SIU_TEST_AGT_ADDR_HI;\r\ndata_lo = SIU_TEST_AGT_WRDATA_LO;\r\ndata_hi = SIU_TEST_AGT_WRDATA_HI;\r\noff_lo = off & SIU_TEST_AGT_ADDR_MASK;\r\noff_hi = SIU_TEST_AGT_UPPER_ADDR(off);\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_DDR_NET, NETXEN_ADDR_DDR_NET_MAX)) {\r\nmem_crb = pci_base_offset(adapter,\r\nNETXEN_CRB_DDR_NET+MIU_TEST_AGT_BASE);\r\naddr_hi = MIU_TEST_AGT_ADDR_HI;\r\ndata_lo = MIU_TEST_AGT_WRDATA_LO;\r\ndata_hi = MIU_TEST_AGT_WRDATA_HI;\r\noff_lo = off & MIU_TEST_AGT_ADDR_MASK;\r\noff_hi = 0;\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_OCM0, NETXEN_ADDR_OCM0_MAX) ||\r\nADDR_IN_RANGE(off, NETXEN_ADDR_OCM1, NETXEN_ADDR_OCM1_MAX)) {\r\nif (adapter->ahw.pci_len0 != 0) {\r\nreturn netxen_nic_pci_mem_access_direct(adapter,\r\noff, &data, 1);\r\n}\r\n}\r\nreturn -EIO;\r\ncorrect:\r\nspin_lock(&adapter->ahw.mem_lock);\r\nnetxen_nic_pci_set_crbwindow_128M(adapter, 0);\r\nwritel(off_lo, (mem_crb + MIU_TEST_AGT_ADDR_LO));\r\nwritel(off_hi, (mem_crb + addr_hi));\r\nwritel(data & 0xffffffff, (mem_crb + data_lo));\r\nwritel((data >> 32) & 0xffffffff, (mem_crb + data_hi));\r\nwritel((TA_CTL_ENABLE | TA_CTL_WRITE), (mem_crb + TEST_AGT_CTRL));\r\nwritel((TA_CTL_START | TA_CTL_ENABLE | TA_CTL_WRITE),\r\n(mem_crb + TEST_AGT_CTRL));\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = readl((mem_crb + TEST_AGT_CTRL));\r\nif ((temp & TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\ndev_err(&adapter->pdev->dev,\r\n"failed to write through agent\n");\r\nret = -EIO;\r\n} else\r\nret = 0;\r\nnetxen_nic_pci_set_crbwindow_128M(adapter, NETXEN_WINDOW_ONE);\r\nspin_unlock(&adapter->ahw.mem_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\nnetxen_nic_pci_mem_read_128M(struct netxen_adapter *adapter,\r\nu64 off, u64 *data)\r\n{\r\nint j, ret;\r\nu32 temp, off_lo, off_hi, addr_hi, data_hi, data_lo;\r\nu64 val;\r\nvoid __iomem *mem_crb;\r\nif (off & 7)\r\nreturn -EIO;\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_QDR_NET,\r\nNETXEN_ADDR_QDR_NET_MAX_P2)) {\r\nmem_crb = pci_base_offset(adapter,\r\nNETXEN_CRB_QDR_NET+SIU_TEST_AGT_BASE);\r\naddr_hi = SIU_TEST_AGT_ADDR_HI;\r\ndata_lo = SIU_TEST_AGT_RDDATA_LO;\r\ndata_hi = SIU_TEST_AGT_RDDATA_HI;\r\noff_lo = off & SIU_TEST_AGT_ADDR_MASK;\r\noff_hi = SIU_TEST_AGT_UPPER_ADDR(off);\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_DDR_NET, NETXEN_ADDR_DDR_NET_MAX)) {\r\nmem_crb = pci_base_offset(adapter,\r\nNETXEN_CRB_DDR_NET+MIU_TEST_AGT_BASE);\r\naddr_hi = MIU_TEST_AGT_ADDR_HI;\r\ndata_lo = MIU_TEST_AGT_RDDATA_LO;\r\ndata_hi = MIU_TEST_AGT_RDDATA_HI;\r\noff_lo = off & MIU_TEST_AGT_ADDR_MASK;\r\noff_hi = 0;\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_OCM0, NETXEN_ADDR_OCM0_MAX) ||\r\nADDR_IN_RANGE(off, NETXEN_ADDR_OCM1, NETXEN_ADDR_OCM1_MAX)) {\r\nif (adapter->ahw.pci_len0 != 0) {\r\nreturn netxen_nic_pci_mem_access_direct(adapter,\r\noff, data, 0);\r\n}\r\n}\r\nreturn -EIO;\r\ncorrect:\r\nspin_lock(&adapter->ahw.mem_lock);\r\nnetxen_nic_pci_set_crbwindow_128M(adapter, 0);\r\nwritel(off_lo, (mem_crb + MIU_TEST_AGT_ADDR_LO));\r\nwritel(off_hi, (mem_crb + addr_hi));\r\nwritel(TA_CTL_ENABLE, (mem_crb + TEST_AGT_CTRL));\r\nwritel((TA_CTL_START|TA_CTL_ENABLE), (mem_crb + TEST_AGT_CTRL));\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = readl(mem_crb + TEST_AGT_CTRL);\r\nif ((temp & TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\ndev_err(&adapter->pdev->dev,\r\n"failed to read through agent\n");\r\nret = -EIO;\r\n} else {\r\ntemp = readl(mem_crb + data_hi);\r\nval = ((u64)temp << 32);\r\nval |= readl(mem_crb + data_lo);\r\n*data = val;\r\nret = 0;\r\n}\r\nnetxen_nic_pci_set_crbwindow_128M(adapter, NETXEN_WINDOW_ONE);\r\nspin_unlock(&adapter->ahw.mem_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\nnetxen_nic_pci_mem_write_2M(struct netxen_adapter *adapter,\r\nu64 off, u64 data)\r\n{\r\nint j, ret;\r\nu32 temp, off8;\r\nvoid __iomem *mem_crb;\r\nif (off & 7)\r\nreturn -EIO;\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_QDR_NET,\r\nNETXEN_ADDR_QDR_NET_MAX_P3)) {\r\nmem_crb = netxen_get_ioaddr(adapter,\r\nNETXEN_CRB_QDR_NET+MIU_TEST_AGT_BASE);\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_DDR_NET, NETXEN_ADDR_DDR_NET_MAX)) {\r\nmem_crb = netxen_get_ioaddr(adapter,\r\nNETXEN_CRB_DDR_NET+MIU_TEST_AGT_BASE);\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_OCM0, NETXEN_ADDR_OCM0_MAX))\r\nreturn netxen_nic_pci_mem_access_direct(adapter, off, &data, 1);\r\nreturn -EIO;\r\ncorrect:\r\noff8 = off & 0xfffffff8;\r\nspin_lock(&adapter->ahw.mem_lock);\r\nwritel(off8, (mem_crb + MIU_TEST_AGT_ADDR_LO));\r\nwritel(0, (mem_crb + MIU_TEST_AGT_ADDR_HI));\r\nwritel(data & 0xffffffff,\r\nmem_crb + MIU_TEST_AGT_WRDATA_LO);\r\nwritel((data >> 32) & 0xffffffff,\r\nmem_crb + MIU_TEST_AGT_WRDATA_HI);\r\nwritel((TA_CTL_ENABLE | TA_CTL_WRITE), (mem_crb + TEST_AGT_CTRL));\r\nwritel((TA_CTL_START | TA_CTL_ENABLE | TA_CTL_WRITE),\r\n(mem_crb + TEST_AGT_CTRL));\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = readl(mem_crb + TEST_AGT_CTRL);\r\nif ((temp & TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\ndev_err(&adapter->pdev->dev,\r\n"failed to write through agent\n");\r\nret = -EIO;\r\n} else\r\nret = 0;\r\nspin_unlock(&adapter->ahw.mem_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\nnetxen_nic_pci_mem_read_2M(struct netxen_adapter *adapter,\r\nu64 off, u64 *data)\r\n{\r\nint j, ret;\r\nu32 temp, off8;\r\nu64 val;\r\nvoid __iomem *mem_crb;\r\nif (off & 7)\r\nreturn -EIO;\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_QDR_NET,\r\nNETXEN_ADDR_QDR_NET_MAX_P3)) {\r\nmem_crb = netxen_get_ioaddr(adapter,\r\nNETXEN_CRB_QDR_NET+MIU_TEST_AGT_BASE);\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_DDR_NET, NETXEN_ADDR_DDR_NET_MAX)) {\r\nmem_crb = netxen_get_ioaddr(adapter,\r\nNETXEN_CRB_DDR_NET+MIU_TEST_AGT_BASE);\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_OCM0, NETXEN_ADDR_OCM0_MAX)) {\r\nreturn netxen_nic_pci_mem_access_direct(adapter,\r\noff, data, 0);\r\n}\r\nreturn -EIO;\r\ncorrect:\r\noff8 = off & 0xfffffff8;\r\nspin_lock(&adapter->ahw.mem_lock);\r\nwritel(off8, (mem_crb + MIU_TEST_AGT_ADDR_LO));\r\nwritel(0, (mem_crb + MIU_TEST_AGT_ADDR_HI));\r\nwritel(TA_CTL_ENABLE, (mem_crb + TEST_AGT_CTRL));\r\nwritel((TA_CTL_START | TA_CTL_ENABLE), (mem_crb + TEST_AGT_CTRL));\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = readl(mem_crb + TEST_AGT_CTRL);\r\nif ((temp & TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\ndev_err(&adapter->pdev->dev,\r\n"failed to read through agent\n");\r\nret = -EIO;\r\n} else {\r\nval = (u64)(readl(mem_crb + MIU_TEST_AGT_RDDATA_HI)) << 32;\r\nval |= readl(mem_crb + MIU_TEST_AGT_RDDATA_LO);\r\n*data = val;\r\nret = 0;\r\n}\r\nspin_unlock(&adapter->ahw.mem_lock);\r\nreturn ret;\r\n}\r\nvoid\r\nnetxen_setup_hwops(struct netxen_adapter *adapter)\r\n{\r\nadapter->init_port = netxen_niu_xg_init_port;\r\nadapter->stop_port = netxen_niu_disable_xg_port;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\nadapter->crb_read = netxen_nic_hw_read_wx_128M,\r\nadapter->crb_write = netxen_nic_hw_write_wx_128M,\r\nadapter->pci_set_window = netxen_nic_pci_set_window_128M,\r\nadapter->pci_mem_read = netxen_nic_pci_mem_read_128M,\r\nadapter->pci_mem_write = netxen_nic_pci_mem_write_128M,\r\nadapter->io_read = netxen_nic_io_read_128M,\r\nadapter->io_write = netxen_nic_io_write_128M,\r\nadapter->macaddr_set = netxen_p2_nic_set_mac_addr;\r\nadapter->set_multi = netxen_p2_nic_set_multi;\r\nadapter->set_mtu = netxen_nic_set_mtu_xgb;\r\nadapter->set_promisc = netxen_p2_nic_set_promisc;\r\n} else {\r\nadapter->crb_read = netxen_nic_hw_read_wx_2M,\r\nadapter->crb_write = netxen_nic_hw_write_wx_2M,\r\nadapter->pci_set_window = netxen_nic_pci_set_window_2M,\r\nadapter->pci_mem_read = netxen_nic_pci_mem_read_2M,\r\nadapter->pci_mem_write = netxen_nic_pci_mem_write_2M,\r\nadapter->io_read = netxen_nic_io_read_2M,\r\nadapter->io_write = netxen_nic_io_write_2M,\r\nadapter->set_mtu = nx_fw_cmd_set_mtu;\r\nadapter->set_promisc = netxen_p3_nic_set_promisc;\r\nadapter->macaddr_set = netxen_p3_nic_set_mac_addr;\r\nadapter->set_multi = netxen_p3_nic_set_multi;\r\nadapter->phy_read = nx_fw_cmd_query_phy;\r\nadapter->phy_write = nx_fw_cmd_set_phy;\r\n}\r\n}\r\nint netxen_nic_get_board_info(struct netxen_adapter *adapter)\r\n{\r\nint offset, board_type, magic;\r\nstruct pci_dev *pdev = adapter->pdev;\r\noffset = NX_FW_MAGIC_OFFSET;\r\nif (netxen_rom_fast_read(adapter, offset, &magic))\r\nreturn -EIO;\r\nif (magic != NETXEN_BDINFO_MAGIC) {\r\ndev_err(&pdev->dev, "invalid board config, magic=%08x\n",\r\nmagic);\r\nreturn -EIO;\r\n}\r\noffset = NX_BRDTYPE_OFFSET;\r\nif (netxen_rom_fast_read(adapter, offset, &board_type))\r\nreturn -EIO;\r\nif (board_type == NETXEN_BRDTYPE_P3_4_GB_MM) {\r\nu32 gpio = NXRD32(adapter, NETXEN_ROMUSB_GLB_PAD_GPIO_I);\r\nif ((gpio & 0x8000) == 0)\r\nboard_type = NETXEN_BRDTYPE_P3_10G_TP;\r\n}\r\nadapter->ahw.board_type = board_type;\r\nswitch (board_type) {\r\ncase NETXEN_BRDTYPE_P2_SB35_4G:\r\nadapter->ahw.port_type = NETXEN_NIC_GBE;\r\nbreak;\r\ncase NETXEN_BRDTYPE_P2_SB31_10G:\r\ncase NETXEN_BRDTYPE_P2_SB31_10G_IMEZ:\r\ncase NETXEN_BRDTYPE_P2_SB31_10G_HMEZ:\r\ncase NETXEN_BRDTYPE_P2_SB31_10G_CX4:\r\ncase NETXEN_BRDTYPE_P3_HMEZ:\r\ncase NETXEN_BRDTYPE_P3_XG_LOM:\r\ncase NETXEN_BRDTYPE_P3_10G_CX4:\r\ncase NETXEN_BRDTYPE_P3_10G_CX4_LP:\r\ncase NETXEN_BRDTYPE_P3_IMEZ:\r\ncase NETXEN_BRDTYPE_P3_10G_SFP_PLUS:\r\ncase NETXEN_BRDTYPE_P3_10G_SFP_CT:\r\ncase NETXEN_BRDTYPE_P3_10G_SFP_QT:\r\ncase NETXEN_BRDTYPE_P3_10G_XFP:\r\ncase NETXEN_BRDTYPE_P3_10000_BASE_T:\r\nadapter->ahw.port_type = NETXEN_NIC_XGBE;\r\nbreak;\r\ncase NETXEN_BRDTYPE_P1_BD:\r\ncase NETXEN_BRDTYPE_P1_SB:\r\ncase NETXEN_BRDTYPE_P1_SMAX:\r\ncase NETXEN_BRDTYPE_P1_SOCK:\r\ncase NETXEN_BRDTYPE_P3_REF_QG:\r\ncase NETXEN_BRDTYPE_P3_4_GB:\r\ncase NETXEN_BRDTYPE_P3_4_GB_MM:\r\nadapter->ahw.port_type = NETXEN_NIC_GBE;\r\nbreak;\r\ncase NETXEN_BRDTYPE_P3_10G_TP:\r\nadapter->ahw.port_type = (adapter->portnum < 2) ?\r\nNETXEN_NIC_XGBE : NETXEN_NIC_GBE;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "unknown board type %x\n", board_type);\r\nadapter->ahw.port_type = NETXEN_NIC_XGBE;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int netxen_nic_set_mtu_xgb(struct netxen_adapter *adapter, int new_mtu)\r\n{\r\nnew_mtu += MTU_FUDGE_FACTOR;\r\nif (adapter->physical_port == 0)\r\nNXWR32(adapter, NETXEN_NIU_XGE_MAX_FRAME_SIZE, new_mtu);\r\nelse\r\nNXWR32(adapter, NETXEN_NIU_XG1_MAX_FRAME_SIZE, new_mtu);\r\nreturn 0;\r\n}\r\nvoid netxen_nic_set_link_parameters(struct netxen_adapter *adapter)\r\n{\r\n__u32 status;\r\n__u32 autoneg;\r\n__u32 port_mode;\r\nif (!netif_carrier_ok(adapter->netdev)) {\r\nadapter->link_speed = 0;\r\nadapter->link_duplex = -1;\r\nadapter->link_autoneg = AUTONEG_ENABLE;\r\nreturn;\r\n}\r\nif (adapter->ahw.port_type == NETXEN_NIC_GBE) {\r\nport_mode = NXRD32(adapter, NETXEN_PORT_MODE_ADDR);\r\nif (port_mode == NETXEN_PORT_MODE_802_3_AP) {\r\nadapter->link_speed = SPEED_1000;\r\nadapter->link_duplex = DUPLEX_FULL;\r\nadapter->link_autoneg = AUTONEG_DISABLE;\r\nreturn;\r\n}\r\nif (adapter->phy_read &&\r\nadapter->phy_read(adapter,\r\nNETXEN_NIU_GB_MII_MGMT_ADDR_PHY_STATUS,\r\n&status) == 0) {\r\nif (netxen_get_phy_link(status)) {\r\nswitch (netxen_get_phy_speed(status)) {\r\ncase 0:\r\nadapter->link_speed = SPEED_10;\r\nbreak;\r\ncase 1:\r\nadapter->link_speed = SPEED_100;\r\nbreak;\r\ncase 2:\r\nadapter->link_speed = SPEED_1000;\r\nbreak;\r\ndefault:\r\nadapter->link_speed = 0;\r\nbreak;\r\n}\r\nswitch (netxen_get_phy_duplex(status)) {\r\ncase 0:\r\nadapter->link_duplex = DUPLEX_HALF;\r\nbreak;\r\ncase 1:\r\nadapter->link_duplex = DUPLEX_FULL;\r\nbreak;\r\ndefault:\r\nadapter->link_duplex = -1;\r\nbreak;\r\n}\r\nif (adapter->phy_read &&\r\nadapter->phy_read(adapter,\r\nNETXEN_NIU_GB_MII_MGMT_ADDR_AUTONEG,\r\n&autoneg) != 0)\r\nadapter->link_autoneg = autoneg;\r\n} else\r\ngoto link_down;\r\n} else {\r\nlink_down:\r\nadapter->link_speed = 0;\r\nadapter->link_duplex = -1;\r\n}\r\n}\r\n}\r\nint\r\nnetxen_nic_wol_supported(struct netxen_adapter *adapter)\r\n{\r\nu32 wol_cfg;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nreturn 0;\r\nwol_cfg = NXRD32(adapter, NETXEN_WOL_CONFIG_NV);\r\nif (wol_cfg & (1UL << adapter->portnum)) {\r\nwol_cfg = NXRD32(adapter, NETXEN_WOL_CONFIG);\r\nif (wol_cfg & (1 << adapter->portnum))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}
