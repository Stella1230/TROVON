static int selinux_netlbl_sidlookup_cached(struct sk_buff *skb,\r\nstruct netlbl_lsm_secattr *secattr,\r\nu32 *sid)\r\n{\r\nint rc;\r\nrc = security_netlbl_secattr_to_sid(secattr, sid);\r\nif (rc == 0 &&\r\n(secattr->flags & NETLBL_SECATTR_CACHEABLE) &&\r\n(secattr->flags & NETLBL_SECATTR_CACHE))\r\nnetlbl_cache_add(skb, secattr);\r\nreturn rc;\r\n}\r\nstatic struct netlbl_lsm_secattr *selinux_netlbl_sock_genattr(struct sock *sk)\r\n{\r\nint rc;\r\nstruct sk_security_struct *sksec = sk->sk_security;\r\nstruct netlbl_lsm_secattr *secattr;\r\nif (sksec->nlbl_secattr != NULL)\r\nreturn sksec->nlbl_secattr;\r\nsecattr = netlbl_secattr_alloc(GFP_ATOMIC);\r\nif (secattr == NULL)\r\nreturn NULL;\r\nrc = security_netlbl_sid_to_secattr(sksec->sid, secattr);\r\nif (rc != 0) {\r\nnetlbl_secattr_free(secattr);\r\nreturn NULL;\r\n}\r\nsksec->nlbl_secattr = secattr;\r\nreturn secattr;\r\n}\r\nvoid selinux_netlbl_cache_invalidate(void)\r\n{\r\nnetlbl_cache_invalidate();\r\n}\r\nvoid selinux_netlbl_err(struct sk_buff *skb, int error, int gateway)\r\n{\r\nnetlbl_skbuff_err(skb, error, gateway);\r\n}\r\nvoid selinux_netlbl_sk_security_free(struct sk_security_struct *sksec)\r\n{\r\nif (sksec->nlbl_secattr != NULL)\r\nnetlbl_secattr_free(sksec->nlbl_secattr);\r\n}\r\nvoid selinux_netlbl_sk_security_reset(struct sk_security_struct *sksec)\r\n{\r\nsksec->nlbl_state = NLBL_UNSET;\r\n}\r\nint selinux_netlbl_skbuff_getsid(struct sk_buff *skb,\r\nu16 family,\r\nu32 *type,\r\nu32 *sid)\r\n{\r\nint rc;\r\nstruct netlbl_lsm_secattr secattr;\r\nif (!netlbl_enabled()) {\r\n*sid = SECSID_NULL;\r\nreturn 0;\r\n}\r\nnetlbl_secattr_init(&secattr);\r\nrc = netlbl_skbuff_getattr(skb, family, &secattr);\r\nif (rc == 0 && secattr.flags != NETLBL_SECATTR_NONE)\r\nrc = selinux_netlbl_sidlookup_cached(skb, &secattr, sid);\r\nelse\r\n*sid = SECSID_NULL;\r\n*type = secattr.type;\r\nnetlbl_secattr_destroy(&secattr);\r\nreturn rc;\r\n}\r\nint selinux_netlbl_skbuff_setsid(struct sk_buff *skb,\r\nu16 family,\r\nu32 sid)\r\n{\r\nint rc;\r\nstruct netlbl_lsm_secattr secattr_storage;\r\nstruct netlbl_lsm_secattr *secattr = NULL;\r\nstruct sock *sk;\r\nsk = skb->sk;\r\nif (sk != NULL) {\r\nstruct sk_security_struct *sksec = sk->sk_security;\r\nif (sksec->nlbl_state != NLBL_REQSKB)\r\nreturn 0;\r\nsecattr = sksec->nlbl_secattr;\r\n}\r\nif (secattr == NULL) {\r\nsecattr = &secattr_storage;\r\nnetlbl_secattr_init(secattr);\r\nrc = security_netlbl_sid_to_secattr(sid, secattr);\r\nif (rc != 0)\r\ngoto skbuff_setsid_return;\r\n}\r\nrc = netlbl_skbuff_setattr(skb, family, secattr);\r\nskbuff_setsid_return:\r\nif (secattr == &secattr_storage)\r\nnetlbl_secattr_destroy(secattr);\r\nreturn rc;\r\n}\r\nint selinux_netlbl_inet_conn_request(struct request_sock *req, u16 family)\r\n{\r\nint rc;\r\nstruct netlbl_lsm_secattr secattr;\r\nif (family != PF_INET)\r\nreturn 0;\r\nnetlbl_secattr_init(&secattr);\r\nrc = security_netlbl_sid_to_secattr(req->secid, &secattr);\r\nif (rc != 0)\r\ngoto inet_conn_request_return;\r\nrc = netlbl_req_setattr(req, &secattr);\r\ninet_conn_request_return:\r\nnetlbl_secattr_destroy(&secattr);\r\nreturn rc;\r\n}\r\nvoid selinux_netlbl_inet_csk_clone(struct sock *sk, u16 family)\r\n{\r\nstruct sk_security_struct *sksec = sk->sk_security;\r\nif (family == PF_INET)\r\nsksec->nlbl_state = NLBL_LABELED;\r\nelse\r\nsksec->nlbl_state = NLBL_UNSET;\r\n}\r\nint selinux_netlbl_socket_post_create(struct sock *sk, u16 family)\r\n{\r\nint rc;\r\nstruct sk_security_struct *sksec = sk->sk_security;\r\nstruct netlbl_lsm_secattr *secattr;\r\nif (family != PF_INET)\r\nreturn 0;\r\nsecattr = selinux_netlbl_sock_genattr(sk);\r\nif (secattr == NULL)\r\nreturn -ENOMEM;\r\nrc = netlbl_sock_setattr(sk, family, secattr);\r\nswitch (rc) {\r\ncase 0:\r\nsksec->nlbl_state = NLBL_LABELED;\r\nbreak;\r\ncase -EDESTADDRREQ:\r\nsksec->nlbl_state = NLBL_REQSKB;\r\nrc = 0;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint selinux_netlbl_sock_rcv_skb(struct sk_security_struct *sksec,\r\nstruct sk_buff *skb,\r\nu16 family,\r\nstruct common_audit_data *ad)\r\n{\r\nint rc;\r\nu32 nlbl_sid;\r\nu32 perm;\r\nstruct netlbl_lsm_secattr secattr;\r\nif (!netlbl_enabled())\r\nreturn 0;\r\nnetlbl_secattr_init(&secattr);\r\nrc = netlbl_skbuff_getattr(skb, family, &secattr);\r\nif (rc == 0 && secattr.flags != NETLBL_SECATTR_NONE)\r\nrc = selinux_netlbl_sidlookup_cached(skb, &secattr, &nlbl_sid);\r\nelse\r\nnlbl_sid = SECINITSID_UNLABELED;\r\nnetlbl_secattr_destroy(&secattr);\r\nif (rc != 0)\r\nreturn rc;\r\nswitch (sksec->sclass) {\r\ncase SECCLASS_UDP_SOCKET:\r\nperm = UDP_SOCKET__RECVFROM;\r\nbreak;\r\ncase SECCLASS_TCP_SOCKET:\r\nperm = TCP_SOCKET__RECVFROM;\r\nbreak;\r\ndefault:\r\nperm = RAWIP_SOCKET__RECVFROM;\r\n}\r\nrc = avc_has_perm(sksec->sid, nlbl_sid, sksec->sclass, perm, ad);\r\nif (rc == 0)\r\nreturn 0;\r\nif (nlbl_sid != SECINITSID_UNLABELED)\r\nnetlbl_skbuff_err(skb, rc, 0);\r\nreturn rc;\r\n}\r\nint selinux_netlbl_socket_setsockopt(struct socket *sock,\r\nint level,\r\nint optname)\r\n{\r\nint rc = 0;\r\nstruct sock *sk = sock->sk;\r\nstruct sk_security_struct *sksec = sk->sk_security;\r\nstruct netlbl_lsm_secattr secattr;\r\nif (level == IPPROTO_IP && optname == IP_OPTIONS &&\r\n(sksec->nlbl_state == NLBL_LABELED ||\r\nsksec->nlbl_state == NLBL_CONNLABELED)) {\r\nnetlbl_secattr_init(&secattr);\r\nlock_sock(sk);\r\nrc = netlbl_sock_getattr(sk, &secattr);\r\nrelease_sock(sk);\r\nif (rc == 0)\r\nrc = -EACCES;\r\nelse if (rc == -ENOMSG)\r\nrc = 0;\r\nnetlbl_secattr_destroy(&secattr);\r\n}\r\nreturn rc;\r\n}\r\nint selinux_netlbl_socket_connect(struct sock *sk, struct sockaddr *addr)\r\n{\r\nint rc;\r\nstruct sk_security_struct *sksec = sk->sk_security;\r\nstruct netlbl_lsm_secattr *secattr;\r\nif (sksec->nlbl_state != NLBL_REQSKB &&\r\nsksec->nlbl_state != NLBL_CONNLABELED)\r\nreturn 0;\r\nlocal_bh_disable();\r\nbh_lock_sock_nested(sk);\r\nif (addr->sa_family == AF_UNSPEC) {\r\nnetlbl_sock_delattr(sk);\r\nsksec->nlbl_state = NLBL_REQSKB;\r\nrc = 0;\r\ngoto socket_connect_return;\r\n}\r\nsecattr = selinux_netlbl_sock_genattr(sk);\r\nif (secattr == NULL) {\r\nrc = -ENOMEM;\r\ngoto socket_connect_return;\r\n}\r\nrc = netlbl_conn_setattr(sk, addr, secattr);\r\nif (rc == 0)\r\nsksec->nlbl_state = NLBL_CONNLABELED;\r\nsocket_connect_return:\r\nbh_unlock_sock(sk);\r\nlocal_bh_enable();\r\nreturn rc;\r\n}
