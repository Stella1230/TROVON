static inline u16 __er16flash(struct e1000_hw *hw, unsigned long reg)\r\n{\r\nreturn readw(hw->flash_address + reg);\r\n}\r\nstatic inline u32 __er32flash(struct e1000_hw *hw, unsigned long reg)\r\n{\r\nreturn readl(hw->flash_address + reg);\r\n}\r\nstatic inline void __ew16flash(struct e1000_hw *hw, unsigned long reg, u16 val)\r\n{\r\nwritew(val, hw->flash_address + reg);\r\n}\r\nstatic inline void __ew32flash(struct e1000_hw *hw, unsigned long reg, u32 val)\r\n{\r\nwritel(val, hw->flash_address + reg);\r\n}\r\nstatic void e1000_toggle_lanphypc_value_ich8lan(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\nctrl = er32(CTRL);\r\nctrl |= E1000_CTRL_LANPHYPC_OVERRIDE;\r\nctrl &= ~E1000_CTRL_LANPHYPC_VALUE;\r\new32(CTRL, ctrl);\r\ne1e_flush();\r\nudelay(10);\r\nctrl &= ~E1000_CTRL_LANPHYPC_OVERRIDE;\r\new32(CTRL, ctrl);\r\n}\r\nstatic s32 e1000_init_phy_params_pchlan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\nu32 fwsm;\r\ns32 ret_val = 0;\r\nphy->addr = 1;\r\nphy->reset_delay_us = 100;\r\nphy->ops.set_page = e1000_set_page_igp;\r\nphy->ops.read_reg = e1000_read_phy_reg_hv;\r\nphy->ops.read_reg_locked = e1000_read_phy_reg_hv_locked;\r\nphy->ops.read_reg_page = e1000_read_phy_reg_page_hv;\r\nphy->ops.set_d0_lplu_state = e1000_set_lplu_state_pchlan;\r\nphy->ops.set_d3_lplu_state = e1000_set_lplu_state_pchlan;\r\nphy->ops.write_reg = e1000_write_phy_reg_hv;\r\nphy->ops.write_reg_locked = e1000_write_phy_reg_hv_locked;\r\nphy->ops.write_reg_page = e1000_write_phy_reg_page_hv;\r\nphy->ops.power_up = e1000_power_up_phy_copper;\r\nphy->ops.power_down = e1000_power_down_phy_copper_ich8lan;\r\nphy->autoneg_mask = AUTONEG_ADVERTISE_SPEED_DEFAULT;\r\nfwsm = er32(FWSM);\r\nif (!(fwsm & E1000_ICH_FWSM_FW_VALID) && !e1000_check_reset_block(hw)) {\r\ne1000_toggle_lanphypc_value_ich8lan(hw);\r\nmsleep(50);\r\nif (hw->mac.type == e1000_pch2lan)\r\ne1000_gate_hw_phy_config_ich8lan(hw, true);\r\n}\r\nret_val = e1000e_phy_hw_reset_generic(hw);\r\nif (ret_val)\r\ngoto out;\r\nif ((hw->mac.type == e1000_pch2lan) &&\r\n!(fwsm & E1000_ICH_FWSM_FW_VALID)) {\r\nusleep_range(10000, 20000);\r\ne1000_gate_hw_phy_config_ich8lan(hw, false);\r\n}\r\nphy->id = e1000_phy_unknown;\r\nswitch (hw->mac.type) {\r\ndefault:\r\nret_val = e1000e_get_phy_id(hw);\r\nif (ret_val)\r\ngoto out;\r\nif ((phy->id != 0) && (phy->id != PHY_REVISION_MASK))\r\nbreak;\r\ncase e1000_pch2lan:\r\nret_val = e1000_set_mdio_slow_mode_hv(hw);\r\nif (ret_val)\r\ngoto out;\r\nret_val = e1000e_get_phy_id(hw);\r\nif (ret_val)\r\ngoto out;\r\nbreak;\r\n}\r\nphy->type = e1000e_get_phy_type_from_id(phy->id);\r\nswitch (phy->type) {\r\ncase e1000_phy_82577:\r\ncase e1000_phy_82579:\r\nphy->ops.check_polarity = e1000_check_polarity_82577;\r\nphy->ops.force_speed_duplex =\r\ne1000_phy_force_speed_duplex_82577;\r\nphy->ops.get_cable_length = e1000_get_cable_length_82577;\r\nphy->ops.get_info = e1000_get_phy_info_82577;\r\nphy->ops.commit = e1000e_phy_sw_reset;\r\nbreak;\r\ncase e1000_phy_82578:\r\nphy->ops.check_polarity = e1000_check_polarity_m88;\r\nphy->ops.force_speed_duplex = e1000e_phy_force_speed_duplex_m88;\r\nphy->ops.get_cable_length = e1000e_get_cable_length_m88;\r\nphy->ops.get_info = e1000e_get_phy_info_m88;\r\nbreak;\r\ndefault:\r\nret_val = -E1000_ERR_PHY;\r\nbreak;\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_init_phy_params_ich8lan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\ns32 ret_val;\r\nu16 i = 0;\r\nphy->addr = 1;\r\nphy->reset_delay_us = 100;\r\nphy->ops.power_up = e1000_power_up_phy_copper;\r\nphy->ops.power_down = e1000_power_down_phy_copper_ich8lan;\r\nret_val = e1000e_determine_phy_address(hw);\r\nif (ret_val) {\r\nphy->ops.write_reg = e1000e_write_phy_reg_bm;\r\nphy->ops.read_reg = e1000e_read_phy_reg_bm;\r\nret_val = e1000e_determine_phy_address(hw);\r\nif (ret_val) {\r\ne_dbg("Cannot determine PHY addr. Erroring out\n");\r\nreturn ret_val;\r\n}\r\n}\r\nphy->id = 0;\r\nwhile ((e1000_phy_unknown == e1000e_get_phy_type_from_id(phy->id)) &&\r\n(i++ < 100)) {\r\nusleep_range(1000, 2000);\r\nret_val = e1000e_get_phy_id(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nswitch (phy->id) {\r\ncase IGP03E1000_E_PHY_ID:\r\nphy->type = e1000_phy_igp_3;\r\nphy->autoneg_mask = AUTONEG_ADVERTISE_SPEED_DEFAULT;\r\nphy->ops.read_reg_locked = e1000e_read_phy_reg_igp_locked;\r\nphy->ops.write_reg_locked = e1000e_write_phy_reg_igp_locked;\r\nphy->ops.get_info = e1000e_get_phy_info_igp;\r\nphy->ops.check_polarity = e1000_check_polarity_igp;\r\nphy->ops.force_speed_duplex = e1000e_phy_force_speed_duplex_igp;\r\nbreak;\r\ncase IFE_E_PHY_ID:\r\ncase IFE_PLUS_E_PHY_ID:\r\ncase IFE_C_E_PHY_ID:\r\nphy->type = e1000_phy_ife;\r\nphy->autoneg_mask = E1000_ALL_NOT_GIG;\r\nphy->ops.get_info = e1000_get_phy_info_ife;\r\nphy->ops.check_polarity = e1000_check_polarity_ife;\r\nphy->ops.force_speed_duplex = e1000_phy_force_speed_duplex_ife;\r\nbreak;\r\ncase BME1000_E_PHY_ID:\r\nphy->type = e1000_phy_bm;\r\nphy->autoneg_mask = AUTONEG_ADVERTISE_SPEED_DEFAULT;\r\nphy->ops.read_reg = e1000e_read_phy_reg_bm;\r\nphy->ops.write_reg = e1000e_write_phy_reg_bm;\r\nphy->ops.commit = e1000e_phy_sw_reset;\r\nphy->ops.get_info = e1000e_get_phy_info_m88;\r\nphy->ops.check_polarity = e1000_check_polarity_m88;\r\nphy->ops.force_speed_duplex = e1000e_phy_force_speed_duplex_m88;\r\nbreak;\r\ndefault:\r\nreturn -E1000_ERR_PHY;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 e1000_init_nvm_params_ich8lan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\r\nu32 gfpreg, sector_base_addr, sector_end_addr;\r\nu16 i;\r\nif (!hw->flash_address) {\r\ne_dbg("ERROR: Flash registers not mapped\n");\r\nreturn -E1000_ERR_CONFIG;\r\n}\r\nnvm->type = e1000_nvm_flash_sw;\r\ngfpreg = er32flash(ICH_FLASH_GFPREG);\r\nsector_base_addr = gfpreg & FLASH_GFPREG_BASE_MASK;\r\nsector_end_addr = ((gfpreg >> 16) & FLASH_GFPREG_BASE_MASK) + 1;\r\nnvm->flash_base_addr = sector_base_addr << FLASH_SECTOR_ADDR_SHIFT;\r\nnvm->flash_bank_size = (sector_end_addr - sector_base_addr)\r\n<< FLASH_SECTOR_ADDR_SHIFT;\r\nnvm->flash_bank_size /= 2;\r\nnvm->flash_bank_size /= sizeof(u16);\r\nnvm->word_size = E1000_ICH8_SHADOW_RAM_WORDS;\r\nfor (i = 0; i < nvm->word_size; i++) {\r\ndev_spec->shadow_ram[i].modified = false;\r\ndev_spec->shadow_ram[i].value = 0xFFFF;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 e1000_init_mac_params_ich8lan(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct e1000_mac_info *mac = &hw->mac;\r\nhw->phy.media_type = e1000_media_type_copper;\r\nmac->mta_reg_count = 32;\r\nmac->rar_entry_count = E1000_ICH_RAR_ENTRIES;\r\nif (mac->type == e1000_ich8lan)\r\nmac->rar_entry_count--;\r\nmac->has_fwsm = true;\r\nmac->arc_subsystem_valid = false;\r\nmac->adaptive_ifs = true;\r\nswitch (mac->type) {\r\ncase e1000_ich8lan:\r\ncase e1000_ich9lan:\r\ncase e1000_ich10lan:\r\nmac->ops.check_mng_mode = e1000_check_mng_mode_ich8lan;\r\nmac->ops.id_led_init = e1000e_id_led_init;\r\nmac->ops.blink_led = e1000e_blink_led_generic;\r\nmac->ops.setup_led = e1000e_setup_led_generic;\r\nmac->ops.cleanup_led = e1000_cleanup_led_ich8lan;\r\nmac->ops.led_on = e1000_led_on_ich8lan;\r\nmac->ops.led_off = e1000_led_off_ich8lan;\r\nbreak;\r\ncase e1000_pchlan:\r\ncase e1000_pch2lan:\r\nmac->ops.check_mng_mode = e1000_check_mng_mode_pchlan;\r\nmac->ops.id_led_init = e1000_id_led_init_pchlan;\r\nmac->ops.setup_led = e1000_setup_led_pchlan;\r\nmac->ops.cleanup_led = e1000_cleanup_led_pchlan;\r\nmac->ops.led_on = e1000_led_on_pchlan;\r\nmac->ops.led_off = e1000_led_off_pchlan;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (mac->type == e1000_ich8lan)\r\ne1000e_set_kmrn_lock_loss_workaround_ich8lan(hw, true);\r\nif ((mac->type == e1000_pch2lan) &&\r\n(er32(FWSM) & E1000_ICH_FWSM_FW_VALID))\r\ne1000_gate_hw_phy_config_ich8lan(hw, true);\r\nreturn 0;\r\n}\r\nstatic s32 e1000_set_eee_pchlan(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nu16 phy_reg;\r\nif (hw->phy.type != e1000_phy_82579)\r\ngoto out;\r\nret_val = e1e_rphy(hw, I82579_LPI_CTRL, &phy_reg);\r\nif (ret_val)\r\ngoto out;\r\nif (hw->dev_spec.ich8lan.eee_disable)\r\nphy_reg &= ~I82579_LPI_CTRL_ENABLE_MASK;\r\nelse\r\nphy_reg |= I82579_LPI_CTRL_ENABLE_MASK;\r\nret_val = e1e_wphy(hw, I82579_LPI_CTRL, phy_reg);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_check_for_copper_link_ich8lan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mac_info *mac = &hw->mac;\r\ns32 ret_val;\r\nbool link;\r\nu16 phy_reg;\r\nif (!mac->get_link_status) {\r\nret_val = 0;\r\ngoto out;\r\n}\r\nret_val = e1000e_phy_has_link_generic(hw, 1, 0, &link);\r\nif (ret_val)\r\ngoto out;\r\nif (hw->mac.type == e1000_pchlan) {\r\nret_val = e1000_k1_gig_workaround_hv(hw, link);\r\nif (ret_val)\r\ngoto out;\r\n}\r\nif (!link)\r\ngoto out;\r\nmac->get_link_status = false;\r\nswitch (hw->mac.type) {\r\ncase e1000_pch2lan:\r\nret_val = e1000_k1_workaround_lv(hw);\r\nif (ret_val)\r\ngoto out;\r\ncase e1000_pchlan:\r\nif (hw->phy.type == e1000_phy_82578) {\r\nret_val = e1000_link_stall_workaround_hv(hw);\r\nif (ret_val)\r\ngoto out;\r\n}\r\ne1e_rphy(hw, HV_KMRN_FIFO_CTRLSTA, &phy_reg);\r\nphy_reg &= ~HV_KMRN_FIFO_CTRLSTA_PREAMBLE_MASK;\r\nif ((er32(STATUS) & E1000_STATUS_FD) != E1000_STATUS_FD)\r\nphy_reg |= (1 << HV_KMRN_FIFO_CTRLSTA_PREAMBLE_SHIFT);\r\ne1e_wphy(hw, HV_KMRN_FIFO_CTRLSTA, phy_reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ne1000e_check_downshift(hw);\r\nret_val = e1000_set_eee_pchlan(hw);\r\nif (ret_val)\r\ngoto out;\r\nif (!mac->autoneg) {\r\nret_val = -E1000_ERR_CONFIG;\r\ngoto out;\r\n}\r\ne1000e_config_collision_dist(hw);\r\nret_val = e1000e_config_fc_after_link_up(hw);\r\nif (ret_val)\r\ne_dbg("Error configuring flow control\n");\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_get_variants_ich8lan(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\ns32 rc;\r\nrc = e1000_init_mac_params_ich8lan(adapter);\r\nif (rc)\r\nreturn rc;\r\nrc = e1000_init_nvm_params_ich8lan(hw);\r\nif (rc)\r\nreturn rc;\r\nswitch (hw->mac.type) {\r\ncase e1000_ich8lan:\r\ncase e1000_ich9lan:\r\ncase e1000_ich10lan:\r\nrc = e1000_init_phy_params_ich8lan(hw);\r\nbreak;\r\ncase e1000_pchlan:\r\ncase e1000_pch2lan:\r\nrc = e1000_init_phy_params_pchlan(hw);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (rc)\r\nreturn rc;\r\nif ((adapter->hw.phy.type == e1000_phy_ife) ||\r\n((adapter->hw.mac.type >= e1000_pch2lan) &&\r\n(!(er32(CTRL_EXT) & E1000_CTRL_EXT_LSECCK)))) {\r\nadapter->flags &= ~FLAG_HAS_JUMBO_FRAMES;\r\nadapter->max_hw_frame_size = ETH_FRAME_LEN + ETH_FCS_LEN;\r\nhw->mac.ops.blink_led = NULL;\r\n}\r\nif ((adapter->hw.mac.type == e1000_ich8lan) &&\r\n(adapter->hw.phy.type != e1000_phy_ife))\r\nadapter->flags |= FLAG_LSC_GIG_SPEED_DROP;\r\nif ((adapter->hw.mac.type == e1000_pch2lan) &&\r\n(er32(FWSM) & E1000_ICH_FWSM_FW_VALID))\r\nadapter->flags2 |= FLAG2_PCIM2PCI_ARBITER_WA;\r\nif (adapter->flags2 & FLAG2_HAS_EEE)\r\nadapter->hw.dev_spec.ich8lan.eee_disable = true;\r\nreturn 0;\r\n}\r\nstatic s32 e1000_acquire_nvm_ich8lan(struct e1000_hw *hw)\r\n{\r\nmutex_lock(&nvm_mutex);\r\nreturn 0;\r\n}\r\nstatic void e1000_release_nvm_ich8lan(struct e1000_hw *hw)\r\n{\r\nmutex_unlock(&nvm_mutex);\r\n}\r\nstatic s32 e1000_acquire_swflag_ich8lan(struct e1000_hw *hw)\r\n{\r\nu32 extcnf_ctrl, timeout = PHY_CFG_TIMEOUT;\r\ns32 ret_val = 0;\r\nif (test_and_set_bit(__E1000_ACCESS_SHARED_RESOURCE,\r\n&hw->adapter->state)) {\r\ne_dbg("contention for Phy access\n");\r\nreturn -E1000_ERR_PHY;\r\n}\r\nwhile (timeout) {\r\nextcnf_ctrl = er32(EXTCNF_CTRL);\r\nif (!(extcnf_ctrl & E1000_EXTCNF_CTRL_SWFLAG))\r\nbreak;\r\nmdelay(1);\r\ntimeout--;\r\n}\r\nif (!timeout) {\r\ne_dbg("SW has already locked the resource.\n");\r\nret_val = -E1000_ERR_CONFIG;\r\ngoto out;\r\n}\r\ntimeout = SW_FLAG_TIMEOUT;\r\nextcnf_ctrl |= E1000_EXTCNF_CTRL_SWFLAG;\r\new32(EXTCNF_CTRL, extcnf_ctrl);\r\nwhile (timeout) {\r\nextcnf_ctrl = er32(EXTCNF_CTRL);\r\nif (extcnf_ctrl & E1000_EXTCNF_CTRL_SWFLAG)\r\nbreak;\r\nmdelay(1);\r\ntimeout--;\r\n}\r\nif (!timeout) {\r\ne_dbg("Failed to acquire the semaphore, FW or HW has it: "\r\n"FWSM=0x%8.8x EXTCNF_CTRL=0x%8.8x)\n",\r\ner32(FWSM), extcnf_ctrl);\r\nextcnf_ctrl &= ~E1000_EXTCNF_CTRL_SWFLAG;\r\new32(EXTCNF_CTRL, extcnf_ctrl);\r\nret_val = -E1000_ERR_CONFIG;\r\ngoto out;\r\n}\r\nout:\r\nif (ret_val)\r\nclear_bit(__E1000_ACCESS_SHARED_RESOURCE, &hw->adapter->state);\r\nreturn ret_val;\r\n}\r\nstatic void e1000_release_swflag_ich8lan(struct e1000_hw *hw)\r\n{\r\nu32 extcnf_ctrl;\r\nextcnf_ctrl = er32(EXTCNF_CTRL);\r\nif (extcnf_ctrl & E1000_EXTCNF_CTRL_SWFLAG) {\r\nextcnf_ctrl &= ~E1000_EXTCNF_CTRL_SWFLAG;\r\new32(EXTCNF_CTRL, extcnf_ctrl);\r\n} else {\r\ne_dbg("Semaphore unexpectedly released by sw/fw/hw\n");\r\n}\r\nclear_bit(__E1000_ACCESS_SHARED_RESOURCE, &hw->adapter->state);\r\n}\r\nstatic bool e1000_check_mng_mode_ich8lan(struct e1000_hw *hw)\r\n{\r\nu32 fwsm;\r\nfwsm = er32(FWSM);\r\nreturn (fwsm & E1000_ICH_FWSM_FW_VALID) &&\r\n((fwsm & E1000_FWSM_MODE_MASK) ==\r\n(E1000_ICH_MNG_IAMT_MODE << E1000_FWSM_MODE_SHIFT));\r\n}\r\nstatic bool e1000_check_mng_mode_pchlan(struct e1000_hw *hw)\r\n{\r\nu32 fwsm;\r\nfwsm = er32(FWSM);\r\nreturn (fwsm & E1000_ICH_FWSM_FW_VALID) &&\r\n(fwsm & (E1000_ICH_MNG_IAMT_MODE << E1000_FWSM_MODE_SHIFT));\r\n}\r\nstatic s32 e1000_check_reset_block_ich8lan(struct e1000_hw *hw)\r\n{\r\nu32 fwsm;\r\nfwsm = er32(FWSM);\r\nreturn (fwsm & E1000_ICH_FWSM_RSPCIPHY) ? 0 : E1000_BLK_PHY_RESET;\r\n}\r\nstatic s32 e1000_write_smbus_addr(struct e1000_hw *hw)\r\n{\r\nu16 phy_data;\r\nu32 strap = er32(STRAP);\r\ns32 ret_val = 0;\r\nstrap &= E1000_STRAP_SMBUS_ADDRESS_MASK;\r\nret_val = e1000_read_phy_reg_hv_locked(hw, HV_SMB_ADDR, &phy_data);\r\nif (ret_val)\r\ngoto out;\r\nphy_data &= ~HV_SMB_ADDR_MASK;\r\nphy_data |= (strap >> E1000_STRAP_SMBUS_ADDRESS_SHIFT);\r\nphy_data |= HV_SMB_ADDR_PEC_EN | HV_SMB_ADDR_VALID;\r\nret_val = e1000_write_phy_reg_hv_locked(hw, HV_SMB_ADDR, phy_data);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_sw_lcd_config_ich8lan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\nu32 i, data, cnf_size, cnf_base_addr, sw_cfg_mask;\r\ns32 ret_val = 0;\r\nu16 word_addr, reg_data, reg_addr, phy_page = 0;\r\nswitch (hw->mac.type) {\r\ncase e1000_ich8lan:\r\nif (phy->type != e1000_phy_igp_3)\r\nreturn ret_val;\r\nif ((hw->adapter->pdev->device == E1000_DEV_ID_ICH8_IGP_AMT) ||\r\n(hw->adapter->pdev->device == E1000_DEV_ID_ICH8_IGP_C)) {\r\nsw_cfg_mask = E1000_FEXTNVM_SW_CONFIG;\r\nbreak;\r\n}\r\ncase e1000_pchlan:\r\ncase e1000_pch2lan:\r\nsw_cfg_mask = E1000_FEXTNVM_SW_CONFIG_ICH8M;\r\nbreak;\r\ndefault:\r\nreturn ret_val;\r\n}\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\ndata = er32(FEXTNVM);\r\nif (!(data & sw_cfg_mask))\r\ngoto out;\r\ndata = er32(EXTCNF_CTRL);\r\nif (!(hw->mac.type == e1000_pch2lan)) {\r\nif (data & E1000_EXTCNF_CTRL_LCD_WRITE_ENABLE)\r\ngoto out;\r\n}\r\ncnf_size = er32(EXTCNF_SIZE);\r\ncnf_size &= E1000_EXTCNF_SIZE_EXT_PCIE_LENGTH_MASK;\r\ncnf_size >>= E1000_EXTCNF_SIZE_EXT_PCIE_LENGTH_SHIFT;\r\nif (!cnf_size)\r\ngoto out;\r\ncnf_base_addr = data & E1000_EXTCNF_CTRL_EXT_CNF_POINTER_MASK;\r\ncnf_base_addr >>= E1000_EXTCNF_CTRL_EXT_CNF_POINTER_SHIFT;\r\nif ((!(data & E1000_EXTCNF_CTRL_OEM_WRITE_ENABLE) &&\r\n(hw->mac.type == e1000_pchlan)) ||\r\n(hw->mac.type == e1000_pch2lan)) {\r\nret_val = e1000_write_smbus_addr(hw);\r\nif (ret_val)\r\ngoto out;\r\ndata = er32(LEDCTL);\r\nret_val = e1000_write_phy_reg_hv_locked(hw, HV_LED_CONFIG,\r\n(u16)data);\r\nif (ret_val)\r\ngoto out;\r\n}\r\nword_addr = (u16)(cnf_base_addr << 1);\r\nfor (i = 0; i < cnf_size; i++) {\r\nret_val = e1000_read_nvm(hw, (word_addr + i * 2), 1,\r\n&reg_data);\r\nif (ret_val)\r\ngoto out;\r\nret_val = e1000_read_nvm(hw, (word_addr + i * 2 + 1),\r\n1, &reg_addr);\r\nif (ret_val)\r\ngoto out;\r\nif (reg_addr == IGP01E1000_PHY_PAGE_SELECT) {\r\nphy_page = reg_data;\r\ncontinue;\r\n}\r\nreg_addr &= PHY_REG_MASK;\r\nreg_addr |= phy_page;\r\nret_val = phy->ops.write_reg_locked(hw, (u32)reg_addr,\r\nreg_data);\r\nif (ret_val)\r\ngoto out;\r\n}\r\nout:\r\nhw->phy.ops.release(hw);\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_k1_gig_workaround_hv(struct e1000_hw *hw, bool link)\r\n{\r\ns32 ret_val = 0;\r\nu16 status_reg = 0;\r\nbool k1_enable = hw->dev_spec.ich8lan.nvm_k1_enabled;\r\nif (hw->mac.type != e1000_pchlan)\r\ngoto out;\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val)\r\ngoto out;\r\nif (link) {\r\nif (hw->phy.type == e1000_phy_82578) {\r\nret_val = hw->phy.ops.read_reg_locked(hw, BM_CS_STATUS,\r\n&status_reg);\r\nif (ret_val)\r\ngoto release;\r\nstatus_reg &= BM_CS_STATUS_LINK_UP |\r\nBM_CS_STATUS_RESOLVED |\r\nBM_CS_STATUS_SPEED_MASK;\r\nif (status_reg == (BM_CS_STATUS_LINK_UP |\r\nBM_CS_STATUS_RESOLVED |\r\nBM_CS_STATUS_SPEED_1000))\r\nk1_enable = false;\r\n}\r\nif (hw->phy.type == e1000_phy_82577) {\r\nret_val = hw->phy.ops.read_reg_locked(hw, HV_M_STATUS,\r\n&status_reg);\r\nif (ret_val)\r\ngoto release;\r\nstatus_reg &= HV_M_STATUS_LINK_UP |\r\nHV_M_STATUS_AUTONEG_COMPLETE |\r\nHV_M_STATUS_SPEED_MASK;\r\nif (status_reg == (HV_M_STATUS_LINK_UP |\r\nHV_M_STATUS_AUTONEG_COMPLETE |\r\nHV_M_STATUS_SPEED_1000))\r\nk1_enable = false;\r\n}\r\nret_val = hw->phy.ops.write_reg_locked(hw, PHY_REG(770, 19),\r\n0x0100);\r\nif (ret_val)\r\ngoto release;\r\n} else {\r\nret_val = hw->phy.ops.write_reg_locked(hw, PHY_REG(770, 19),\r\n0x4100);\r\nif (ret_val)\r\ngoto release;\r\n}\r\nret_val = e1000_configure_k1_ich8lan(hw, k1_enable);\r\nrelease:\r\nhw->phy.ops.release(hw);\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 e1000_configure_k1_ich8lan(struct e1000_hw *hw, bool k1_enable)\r\n{\r\ns32 ret_val = 0;\r\nu32 ctrl_reg = 0;\r\nu32 ctrl_ext = 0;\r\nu32 reg = 0;\r\nu16 kmrn_reg = 0;\r\nret_val = e1000e_read_kmrn_reg_locked(hw,\r\nE1000_KMRNCTRLSTA_K1_CONFIG,\r\n&kmrn_reg);\r\nif (ret_val)\r\ngoto out;\r\nif (k1_enable)\r\nkmrn_reg |= E1000_KMRNCTRLSTA_K1_ENABLE;\r\nelse\r\nkmrn_reg &= ~E1000_KMRNCTRLSTA_K1_ENABLE;\r\nret_val = e1000e_write_kmrn_reg_locked(hw,\r\nE1000_KMRNCTRLSTA_K1_CONFIG,\r\nkmrn_reg);\r\nif (ret_val)\r\ngoto out;\r\nudelay(20);\r\nctrl_ext = er32(CTRL_EXT);\r\nctrl_reg = er32(CTRL);\r\nreg = ctrl_reg & ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);\r\nreg |= E1000_CTRL_FRCSPD;\r\new32(CTRL, reg);\r\new32(CTRL_EXT, ctrl_ext | E1000_CTRL_EXT_SPD_BYPS);\r\ne1e_flush();\r\nudelay(20);\r\new32(CTRL, ctrl_reg);\r\new32(CTRL_EXT, ctrl_ext);\r\ne1e_flush();\r\nudelay(20);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_oem_bits_config_ich8lan(struct e1000_hw *hw, bool d0_state)\r\n{\r\ns32 ret_val = 0;\r\nu32 mac_reg;\r\nu16 oem_reg;\r\nif ((hw->mac.type != e1000_pch2lan) && (hw->mac.type != e1000_pchlan))\r\nreturn ret_val;\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (!(hw->mac.type == e1000_pch2lan)) {\r\nmac_reg = er32(EXTCNF_CTRL);\r\nif (mac_reg & E1000_EXTCNF_CTRL_OEM_WRITE_ENABLE)\r\ngoto out;\r\n}\r\nmac_reg = er32(FEXTNVM);\r\nif (!(mac_reg & E1000_FEXTNVM_SW_CONFIG_ICH8M))\r\ngoto out;\r\nmac_reg = er32(PHY_CTRL);\r\nret_val = hw->phy.ops.read_reg_locked(hw, HV_OEM_BITS, &oem_reg);\r\nif (ret_val)\r\ngoto out;\r\noem_reg &= ~(HV_OEM_BITS_GBE_DIS | HV_OEM_BITS_LPLU);\r\nif (d0_state) {\r\nif (mac_reg & E1000_PHY_CTRL_GBE_DISABLE)\r\noem_reg |= HV_OEM_BITS_GBE_DIS;\r\nif (mac_reg & E1000_PHY_CTRL_D0A_LPLU)\r\noem_reg |= HV_OEM_BITS_LPLU;\r\nif (!e1000_check_reset_block(hw))\r\noem_reg |= HV_OEM_BITS_RESTART_AN;\r\n} else {\r\nif (mac_reg & (E1000_PHY_CTRL_GBE_DISABLE |\r\nE1000_PHY_CTRL_NOND0A_GBE_DISABLE))\r\noem_reg |= HV_OEM_BITS_GBE_DIS;\r\nif (mac_reg & (E1000_PHY_CTRL_D0A_LPLU |\r\nE1000_PHY_CTRL_NOND0A_LPLU))\r\noem_reg |= HV_OEM_BITS_LPLU;\r\n}\r\nret_val = hw->phy.ops.write_reg_locked(hw, HV_OEM_BITS, oem_reg);\r\nout:\r\nhw->phy.ops.release(hw);\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_set_mdio_slow_mode_hv(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 data;\r\nret_val = e1e_rphy(hw, HV_KMRN_MODE_CTRL, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\ndata |= HV_KMRN_MDIO_SLOW;\r\nret_val = e1e_wphy(hw, HV_KMRN_MODE_CTRL, data);\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_hv_phy_workarounds_ich8lan(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nu16 phy_data;\r\nif (hw->mac.type != e1000_pchlan)\r\nreturn ret_val;\r\nif (hw->phy.type == e1000_phy_82577) {\r\nret_val = e1000_set_mdio_slow_mode_hv(hw);\r\nif (ret_val)\r\ngoto out;\r\n}\r\nif (((hw->phy.type == e1000_phy_82577) &&\r\n((hw->phy.revision == 1) || (hw->phy.revision == 2))) ||\r\n((hw->phy.type == e1000_phy_82578) && (hw->phy.revision == 1))) {\r\nret_val = e1e_wphy(hw, PHY_REG(769, 25), 0x4431);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1e_wphy(hw, HV_KMRN_FIFO_CTRLSTA, 0xA204);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nif (hw->phy.type == e1000_phy_82578) {\r\nif (hw->phy.revision < 2) {\r\ne1000e_phy_sw_reset(hw);\r\nret_val = e1e_wphy(hw, PHY_CONTROL, 0x3140);\r\n}\r\n}\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nhw->phy.addr = 1;\r\nret_val = e1000e_write_phy_reg_mdic(hw, IGP01E1000_PHY_PAGE_SELECT, 0);\r\nhw->phy.ops.release(hw);\r\nif (ret_val)\r\ngoto out;\r\nret_val = e1000_k1_gig_workaround_hv(hw, true);\r\nif (ret_val)\r\ngoto out;\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val)\r\ngoto out;\r\nret_val = hw->phy.ops.read_reg_locked(hw, BM_PORT_GEN_CFG, &phy_data);\r\nif (ret_val)\r\ngoto release;\r\nret_val = hw->phy.ops.write_reg_locked(hw, BM_PORT_GEN_CFG,\r\nphy_data & 0x00FF);\r\nrelease:\r\nhw->phy.ops.release(hw);\r\nout:\r\nreturn ret_val;\r\n}\r\nvoid e1000_copy_rx_addrs_to_phy_ich8lan(struct e1000_hw *hw)\r\n{\r\nu32 mac_reg;\r\nu16 i, phy_reg = 0;\r\ns32 ret_val;\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val)\r\nreturn;\r\nret_val = e1000_enable_phy_wakeup_reg_access_bm(hw, &phy_reg);\r\nif (ret_val)\r\ngoto release;\r\nfor (i = 0; i < (hw->mac.rar_entry_count + 4); i++) {\r\nmac_reg = er32(RAL(i));\r\nhw->phy.ops.write_reg_page(hw, BM_RAR_L(i),\r\n(u16)(mac_reg & 0xFFFF));\r\nhw->phy.ops.write_reg_page(hw, BM_RAR_M(i),\r\n(u16)((mac_reg >> 16) & 0xFFFF));\r\nmac_reg = er32(RAH(i));\r\nhw->phy.ops.write_reg_page(hw, BM_RAR_H(i),\r\n(u16)(mac_reg & 0xFFFF));\r\nhw->phy.ops.write_reg_page(hw, BM_RAR_CTRL(i),\r\n(u16)((mac_reg & E1000_RAH_AV)\r\n>> 16));\r\n}\r\ne1000_disable_phy_wakeup_reg_access_bm(hw, &phy_reg);\r\nrelease:\r\nhw->phy.ops.release(hw);\r\n}\r\ns32 e1000_lv_jumbo_workaround_ich8lan(struct e1000_hw *hw, bool enable)\r\n{\r\ns32 ret_val = 0;\r\nu16 phy_reg, data;\r\nu32 mac_reg;\r\nu16 i;\r\nif (hw->mac.type != e1000_pch2lan)\r\ngoto out;\r\ne1e_rphy(hw, PHY_REG(769, 20), &phy_reg);\r\nret_val = e1e_wphy(hw, PHY_REG(769, 20), phy_reg | (1 << 14));\r\nif (ret_val)\r\ngoto out;\r\nif (enable) {\r\nfor (i = 0; i < (hw->mac.rar_entry_count + 4); i++) {\r\nu8 mac_addr[ETH_ALEN] = {0};\r\nu32 addr_high, addr_low;\r\naddr_high = er32(RAH(i));\r\nif (!(addr_high & E1000_RAH_AV))\r\ncontinue;\r\naddr_low = er32(RAL(i));\r\nmac_addr[0] = (addr_low & 0xFF);\r\nmac_addr[1] = ((addr_low >> 8) & 0xFF);\r\nmac_addr[2] = ((addr_low >> 16) & 0xFF);\r\nmac_addr[3] = ((addr_low >> 24) & 0xFF);\r\nmac_addr[4] = (addr_high & 0xFF);\r\nmac_addr[5] = ((addr_high >> 8) & 0xFF);\r\new32(PCH_RAICC(i), ~ether_crc_le(ETH_ALEN, mac_addr));\r\n}\r\ne1000_copy_rx_addrs_to_phy_ich8lan(hw);\r\nmac_reg = er32(FFLT_DBG);\r\nmac_reg &= ~(1 << 14);\r\nmac_reg |= (7 << 15);\r\new32(FFLT_DBG, mac_reg);\r\nmac_reg = er32(RCTL);\r\nmac_reg |= E1000_RCTL_SECRC;\r\new32(RCTL, mac_reg);\r\nret_val = e1000e_read_kmrn_reg(hw,\r\nE1000_KMRNCTRLSTA_CTRL_OFFSET,\r\n&data);\r\nif (ret_val)\r\ngoto out;\r\nret_val = e1000e_write_kmrn_reg(hw,\r\nE1000_KMRNCTRLSTA_CTRL_OFFSET,\r\ndata | (1 << 0));\r\nif (ret_val)\r\ngoto out;\r\nret_val = e1000e_read_kmrn_reg(hw,\r\nE1000_KMRNCTRLSTA_HD_CTRL,\r\n&data);\r\nif (ret_val)\r\ngoto out;\r\ndata &= ~(0xF << 8);\r\ndata |= (0xB << 8);\r\nret_val = e1000e_write_kmrn_reg(hw,\r\nE1000_KMRNCTRLSTA_HD_CTRL,\r\ndata);\r\nif (ret_val)\r\ngoto out;\r\ne1e_rphy(hw, PHY_REG(769, 23), &data);\r\ndata &= ~(0x7F << 5);\r\ndata |= (0x37 << 5);\r\nret_val = e1e_wphy(hw, PHY_REG(769, 23), data);\r\nif (ret_val)\r\ngoto out;\r\ne1e_rphy(hw, PHY_REG(769, 16), &data);\r\ndata &= ~(1 << 13);\r\nret_val = e1e_wphy(hw, PHY_REG(769, 16), data);\r\nif (ret_val)\r\ngoto out;\r\ne1e_rphy(hw, PHY_REG(776, 20), &data);\r\ndata &= ~(0x3FF << 2);\r\ndata |= (0x1A << 2);\r\nret_val = e1e_wphy(hw, PHY_REG(776, 20), data);\r\nif (ret_val)\r\ngoto out;\r\nret_val = e1e_wphy(hw, PHY_REG(776, 23), 0xF100);\r\nif (ret_val)\r\ngoto out;\r\ne1e_rphy(hw, HV_PM_CTRL, &data);\r\nret_val = e1e_wphy(hw, HV_PM_CTRL, data | (1 << 10));\r\nif (ret_val)\r\ngoto out;\r\n} else {\r\nmac_reg = er32(FFLT_DBG);\r\nmac_reg &= ~(0xF << 14);\r\new32(FFLT_DBG, mac_reg);\r\nmac_reg = er32(RCTL);\r\nmac_reg &= ~E1000_RCTL_SECRC;\r\new32(RCTL, mac_reg);\r\nret_val = e1000e_read_kmrn_reg(hw,\r\nE1000_KMRNCTRLSTA_CTRL_OFFSET,\r\n&data);\r\nif (ret_val)\r\ngoto out;\r\nret_val = e1000e_write_kmrn_reg(hw,\r\nE1000_KMRNCTRLSTA_CTRL_OFFSET,\r\ndata & ~(1 << 0));\r\nif (ret_val)\r\ngoto out;\r\nret_val = e1000e_read_kmrn_reg(hw,\r\nE1000_KMRNCTRLSTA_HD_CTRL,\r\n&data);\r\nif (ret_val)\r\ngoto out;\r\ndata &= ~(0xF << 8);\r\ndata |= (0xB << 8);\r\nret_val = e1000e_write_kmrn_reg(hw,\r\nE1000_KMRNCTRLSTA_HD_CTRL,\r\ndata);\r\nif (ret_val)\r\ngoto out;\r\ne1e_rphy(hw, PHY_REG(769, 23), &data);\r\ndata &= ~(0x7F << 5);\r\nret_val = e1e_wphy(hw, PHY_REG(769, 23), data);\r\nif (ret_val)\r\ngoto out;\r\ne1e_rphy(hw, PHY_REG(769, 16), &data);\r\ndata |= (1 << 13);\r\nret_val = e1e_wphy(hw, PHY_REG(769, 16), data);\r\nif (ret_val)\r\ngoto out;\r\ne1e_rphy(hw, PHY_REG(776, 20), &data);\r\ndata &= ~(0x3FF << 2);\r\ndata |= (0x8 << 2);\r\nret_val = e1e_wphy(hw, PHY_REG(776, 20), data);\r\nif (ret_val)\r\ngoto out;\r\nret_val = e1e_wphy(hw, PHY_REG(776, 23), 0x7E00);\r\nif (ret_val)\r\ngoto out;\r\ne1e_rphy(hw, HV_PM_CTRL, &data);\r\nret_val = e1e_wphy(hw, HV_PM_CTRL, data & ~(1 << 10));\r\nif (ret_val)\r\ngoto out;\r\n}\r\nret_val = e1e_wphy(hw, PHY_REG(769, 20), phy_reg & ~(1 << 14));\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_lv_phy_workarounds_ich8lan(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nif (hw->mac.type != e1000_pch2lan)\r\ngoto out;\r\nret_val = e1000_set_mdio_slow_mode_hv(hw);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_k1_workaround_lv(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nu16 status_reg = 0;\r\nu32 mac_reg;\r\nu16 phy_reg;\r\nif (hw->mac.type != e1000_pch2lan)\r\ngoto out;\r\nret_val = e1e_rphy(hw, HV_M_STATUS, &status_reg);\r\nif (ret_val)\r\ngoto out;\r\nif ((status_reg & (HV_M_STATUS_LINK_UP | HV_M_STATUS_AUTONEG_COMPLETE))\r\n== (HV_M_STATUS_LINK_UP | HV_M_STATUS_AUTONEG_COMPLETE)) {\r\nmac_reg = er32(FEXTNVM4);\r\nmac_reg &= ~E1000_FEXTNVM4_BEACON_DURATION_MASK;\r\nret_val = e1e_rphy(hw, I82579_LPI_CTRL, &phy_reg);\r\nif (ret_val)\r\ngoto out;\r\nif (status_reg & HV_M_STATUS_SPEED_1000) {\r\nmac_reg |= E1000_FEXTNVM4_BEACON_DURATION_8USEC;\r\nphy_reg &= ~I82579_LPI_CTRL_FORCE_PLL_LOCK_COUNT;\r\n} else {\r\nmac_reg |= E1000_FEXTNVM4_BEACON_DURATION_16USEC;\r\nphy_reg |= I82579_LPI_CTRL_FORCE_PLL_LOCK_COUNT;\r\n}\r\new32(FEXTNVM4, mac_reg);\r\nret_val = e1e_wphy(hw, I82579_LPI_CTRL, phy_reg);\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic void e1000_gate_hw_phy_config_ich8lan(struct e1000_hw *hw, bool gate)\r\n{\r\nu32 extcnf_ctrl;\r\nif (hw->mac.type != e1000_pch2lan)\r\nreturn;\r\nextcnf_ctrl = er32(EXTCNF_CTRL);\r\nif (gate)\r\nextcnf_ctrl |= E1000_EXTCNF_CTRL_GATE_PHY_CFG;\r\nelse\r\nextcnf_ctrl &= ~E1000_EXTCNF_CTRL_GATE_PHY_CFG;\r\new32(EXTCNF_CTRL, extcnf_ctrl);\r\nreturn;\r\n}\r\nstatic void e1000_lan_init_done_ich8lan(struct e1000_hw *hw)\r\n{\r\nu32 data, loop = E1000_ICH8_LAN_INIT_TIMEOUT;\r\ndo {\r\ndata = er32(STATUS);\r\ndata &= E1000_STATUS_LAN_INIT_DONE;\r\nudelay(100);\r\n} while ((!data) && --loop);\r\nif (loop == 0)\r\ne_dbg("LAN_INIT_DONE not set, increase timeout\n");\r\ndata = er32(STATUS);\r\ndata &= ~E1000_STATUS_LAN_INIT_DONE;\r\new32(STATUS, data);\r\n}\r\nstatic s32 e1000_post_phy_reset_ich8lan(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nu16 reg;\r\nif (e1000_check_reset_block(hw))\r\ngoto out;\r\nusleep_range(10000, 20000);\r\nswitch (hw->mac.type) {\r\ncase e1000_pchlan:\r\nret_val = e1000_hv_phy_workarounds_ich8lan(hw);\r\nif (ret_val)\r\ngoto out;\r\nbreak;\r\ncase e1000_pch2lan:\r\nret_val = e1000_lv_phy_workarounds_ich8lan(hw);\r\nif (ret_val)\r\ngoto out;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (hw->mac.type >= e1000_pchlan) {\r\ne1e_rphy(hw, BM_PORT_GEN_CFG, &reg);\r\nreg &= ~BM_WUC_HOST_WU_BIT;\r\ne1e_wphy(hw, BM_PORT_GEN_CFG, reg);\r\n}\r\nret_val = e1000_sw_lcd_config_ich8lan(hw);\r\nif (ret_val)\r\ngoto out;\r\nret_val = e1000_oem_bits_config_ich8lan(hw, true);\r\nif (hw->mac.type == e1000_pch2lan) {\r\nif (!(er32(FWSM) & E1000_ICH_FWSM_FW_VALID)) {\r\nusleep_range(10000, 20000);\r\ne1000_gate_hw_phy_config_ich8lan(hw, false);\r\n}\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val)\r\ngoto out;\r\nret_val = hw->phy.ops.write_reg_locked(hw, I82579_EMI_ADDR,\r\nI82579_LPI_UPDATE_TIMER);\r\nif (ret_val)\r\ngoto release;\r\nret_val = hw->phy.ops.write_reg_locked(hw, I82579_EMI_DATA,\r\n0x1387);\r\nrelease:\r\nhw->phy.ops.release(hw);\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_phy_hw_reset_ich8lan(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nif ((hw->mac.type == e1000_pch2lan) &&\r\n!(er32(FWSM) & E1000_ICH_FWSM_FW_VALID))\r\ne1000_gate_hw_phy_config_ich8lan(hw, true);\r\nret_val = e1000e_phy_hw_reset_generic(hw);\r\nif (ret_val)\r\ngoto out;\r\nret_val = e1000_post_phy_reset_ich8lan(hw);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_set_lplu_state_pchlan(struct e1000_hw *hw, bool active)\r\n{\r\ns32 ret_val = 0;\r\nu16 oem_reg;\r\nret_val = e1e_rphy(hw, HV_OEM_BITS, &oem_reg);\r\nif (ret_val)\r\ngoto out;\r\nif (active)\r\noem_reg |= HV_OEM_BITS_LPLU;\r\nelse\r\noem_reg &= ~HV_OEM_BITS_LPLU;\r\noem_reg |= HV_OEM_BITS_RESTART_AN;\r\nret_val = e1e_wphy(hw, HV_OEM_BITS, oem_reg);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_set_d0_lplu_state_ich8lan(struct e1000_hw *hw, bool active)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\nu32 phy_ctrl;\r\ns32 ret_val = 0;\r\nu16 data;\r\nif (phy->type == e1000_phy_ife)\r\nreturn ret_val;\r\nphy_ctrl = er32(PHY_CTRL);\r\nif (active) {\r\nphy_ctrl |= E1000_PHY_CTRL_D0A_LPLU;\r\new32(PHY_CTRL, phy_ctrl);\r\nif (phy->type != e1000_phy_igp_3)\r\nreturn 0;\r\nif (hw->mac.type == e1000_ich8lan)\r\ne1000e_gig_downshift_workaround_ich8lan(hw);\r\nret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG, &data);\r\ndata &= ~IGP01E1000_PSCFR_SMART_SPEED;\r\nret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG, data);\r\nif (ret_val)\r\nreturn ret_val;\r\n} else {\r\nphy_ctrl &= ~E1000_PHY_CTRL_D0A_LPLU;\r\new32(PHY_CTRL, phy_ctrl);\r\nif (phy->type != e1000_phy_igp_3)\r\nreturn 0;\r\nif (phy->smart_speed == e1000_smart_speed_on) {\r\nret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG,\r\n&data);\r\nif (ret_val)\r\nreturn ret_val;\r\ndata |= IGP01E1000_PSCFR_SMART_SPEED;\r\nret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG,\r\ndata);\r\nif (ret_val)\r\nreturn ret_val;\r\n} else if (phy->smart_speed == e1000_smart_speed_off) {\r\nret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG,\r\n&data);\r\nif (ret_val)\r\nreturn ret_val;\r\ndata &= ~IGP01E1000_PSCFR_SMART_SPEED;\r\nret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG,\r\ndata);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 e1000_set_d3_lplu_state_ich8lan(struct e1000_hw *hw, bool active)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\nu32 phy_ctrl;\r\ns32 ret_val;\r\nu16 data;\r\nphy_ctrl = er32(PHY_CTRL);\r\nif (!active) {\r\nphy_ctrl &= ~E1000_PHY_CTRL_NOND0A_LPLU;\r\new32(PHY_CTRL, phy_ctrl);\r\nif (phy->type != e1000_phy_igp_3)\r\nreturn 0;\r\nif (phy->smart_speed == e1000_smart_speed_on) {\r\nret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG,\r\n&data);\r\nif (ret_val)\r\nreturn ret_val;\r\ndata |= IGP01E1000_PSCFR_SMART_SPEED;\r\nret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG,\r\ndata);\r\nif (ret_val)\r\nreturn ret_val;\r\n} else if (phy->smart_speed == e1000_smart_speed_off) {\r\nret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG,\r\n&data);\r\nif (ret_val)\r\nreturn ret_val;\r\ndata &= ~IGP01E1000_PSCFR_SMART_SPEED;\r\nret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG,\r\ndata);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\n} else if ((phy->autoneg_advertised == E1000_ALL_SPEED_DUPLEX) ||\r\n(phy->autoneg_advertised == E1000_ALL_NOT_GIG) ||\r\n(phy->autoneg_advertised == E1000_ALL_10_SPEED)) {\r\nphy_ctrl |= E1000_PHY_CTRL_NOND0A_LPLU;\r\new32(PHY_CTRL, phy_ctrl);\r\nif (phy->type != e1000_phy_igp_3)\r\nreturn 0;\r\nif (hw->mac.type == e1000_ich8lan)\r\ne1000e_gig_downshift_workaround_ich8lan(hw);\r\nret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\ndata &= ~IGP01E1000_PSCFR_SMART_SPEED;\r\nret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG, data);\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 e1000_valid_nvm_bank_detect_ich8lan(struct e1000_hw *hw, u32 *bank)\r\n{\r\nu32 eecd;\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nu32 bank1_offset = nvm->flash_bank_size * sizeof(u16);\r\nu32 act_offset = E1000_ICH_NVM_SIG_WORD * 2 + 1;\r\nu8 sig_byte = 0;\r\ns32 ret_val = 0;\r\nswitch (hw->mac.type) {\r\ncase e1000_ich8lan:\r\ncase e1000_ich9lan:\r\neecd = er32(EECD);\r\nif ((eecd & E1000_EECD_SEC1VAL_VALID_MASK) ==\r\nE1000_EECD_SEC1VAL_VALID_MASK) {\r\nif (eecd & E1000_EECD_SEC1VAL)\r\n*bank = 1;\r\nelse\r\n*bank = 0;\r\nreturn 0;\r\n}\r\ne_dbg("Unable to determine valid NVM bank via EEC - "\r\n"reading flash signature\n");\r\ndefault:\r\n*bank = 0;\r\nret_val = e1000_read_flash_byte_ich8lan(hw, act_offset,\r\n&sig_byte);\r\nif (ret_val)\r\nreturn ret_val;\r\nif ((sig_byte & E1000_ICH_NVM_VALID_SIG_MASK) ==\r\nE1000_ICH_NVM_SIG_VALUE) {\r\n*bank = 0;\r\nreturn 0;\r\n}\r\nret_val = e1000_read_flash_byte_ich8lan(hw, act_offset +\r\nbank1_offset,\r\n&sig_byte);\r\nif (ret_val)\r\nreturn ret_val;\r\nif ((sig_byte & E1000_ICH_NVM_VALID_SIG_MASK) ==\r\nE1000_ICH_NVM_SIG_VALUE) {\r\n*bank = 1;\r\nreturn 0;\r\n}\r\ne_dbg("ERROR: No valid NVM bank present\n");\r\nreturn -E1000_ERR_NVM;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 e1000_read_nvm_ich8lan(struct e1000_hw *hw, u16 offset, u16 words,\r\nu16 *data)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\r\nu32 act_offset;\r\ns32 ret_val = 0;\r\nu32 bank = 0;\r\nu16 i, word;\r\nif ((offset >= nvm->word_size) || (words > nvm->word_size - offset) ||\r\n(words == 0)) {\r\ne_dbg("nvm parameter(s) out of bounds\n");\r\nret_val = -E1000_ERR_NVM;\r\ngoto out;\r\n}\r\nnvm->ops.acquire(hw);\r\nret_val = e1000_valid_nvm_bank_detect_ich8lan(hw, &bank);\r\nif (ret_val) {\r\ne_dbg("Could not detect valid bank, assuming bank 0\n");\r\nbank = 0;\r\n}\r\nact_offset = (bank) ? nvm->flash_bank_size : 0;\r\nact_offset += offset;\r\nret_val = 0;\r\nfor (i = 0; i < words; i++) {\r\nif (dev_spec->shadow_ram[offset+i].modified) {\r\ndata[i] = dev_spec->shadow_ram[offset+i].value;\r\n} else {\r\nret_val = e1000_read_flash_word_ich8lan(hw,\r\nact_offset + i,\r\n&word);\r\nif (ret_val)\r\nbreak;\r\ndata[i] = word;\r\n}\r\n}\r\nnvm->ops.release(hw);\r\nout:\r\nif (ret_val)\r\ne_dbg("NVM read error: %d\n", ret_val);\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_flash_cycle_init_ich8lan(struct e1000_hw *hw)\r\n{\r\nunion ich8_hws_flash_status hsfsts;\r\ns32 ret_val = -E1000_ERR_NVM;\r\nhsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\r\nif (hsfsts.hsf_status.fldesvalid == 0) {\r\ne_dbg("Flash descriptor invalid. "\r\n"SW Sequencing must be used.\n");\r\nreturn -E1000_ERR_NVM;\r\n}\r\nhsfsts.hsf_status.flcerr = 1;\r\nhsfsts.hsf_status.dael = 1;\r\new16flash(ICH_FLASH_HSFSTS, hsfsts.regval);\r\nif (hsfsts.hsf_status.flcinprog == 0) {\r\nhsfsts.hsf_status.flcdone = 1;\r\new16flash(ICH_FLASH_HSFSTS, hsfsts.regval);\r\nret_val = 0;\r\n} else {\r\ns32 i = 0;\r\nfor (i = 0; i < ICH_FLASH_READ_COMMAND_TIMEOUT; i++) {\r\nhsfsts.regval = __er16flash(hw, ICH_FLASH_HSFSTS);\r\nif (hsfsts.hsf_status.flcinprog == 0) {\r\nret_val = 0;\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nif (ret_val == 0) {\r\nhsfsts.hsf_status.flcdone = 1;\r\new16flash(ICH_FLASH_HSFSTS, hsfsts.regval);\r\n} else {\r\ne_dbg("Flash controller busy, cannot get access\n");\r\n}\r\n}\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_flash_cycle_ich8lan(struct e1000_hw *hw, u32 timeout)\r\n{\r\nunion ich8_hws_flash_ctrl hsflctl;\r\nunion ich8_hws_flash_status hsfsts;\r\ns32 ret_val = -E1000_ERR_NVM;\r\nu32 i = 0;\r\nhsflctl.regval = er16flash(ICH_FLASH_HSFCTL);\r\nhsflctl.hsf_ctrl.flcgo = 1;\r\new16flash(ICH_FLASH_HSFCTL, hsflctl.regval);\r\ndo {\r\nhsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\r\nif (hsfsts.hsf_status.flcdone == 1)\r\nbreak;\r\nudelay(1);\r\n} while (i++ < timeout);\r\nif (hsfsts.hsf_status.flcdone == 1 && hsfsts.hsf_status.flcerr == 0)\r\nreturn 0;\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_read_flash_word_ich8lan(struct e1000_hw *hw, u32 offset,\r\nu16 *data)\r\n{\r\noffset <<= 1;\r\nreturn e1000_read_flash_data_ich8lan(hw, offset, 2, data);\r\n}\r\nstatic s32 e1000_read_flash_byte_ich8lan(struct e1000_hw *hw, u32 offset,\r\nu8 *data)\r\n{\r\ns32 ret_val;\r\nu16 word = 0;\r\nret_val = e1000_read_flash_data_ich8lan(hw, offset, 1, &word);\r\nif (ret_val)\r\nreturn ret_val;\r\n*data = (u8)word;\r\nreturn 0;\r\n}\r\nstatic s32 e1000_read_flash_data_ich8lan(struct e1000_hw *hw, u32 offset,\r\nu8 size, u16 *data)\r\n{\r\nunion ich8_hws_flash_status hsfsts;\r\nunion ich8_hws_flash_ctrl hsflctl;\r\nu32 flash_linear_addr;\r\nu32 flash_data = 0;\r\ns32 ret_val = -E1000_ERR_NVM;\r\nu8 count = 0;\r\nif (size < 1 || size > 2 || offset > ICH_FLASH_LINEAR_ADDR_MASK)\r\nreturn -E1000_ERR_NVM;\r\nflash_linear_addr = (ICH_FLASH_LINEAR_ADDR_MASK & offset) +\r\nhw->nvm.flash_base_addr;\r\ndo {\r\nudelay(1);\r\nret_val = e1000_flash_cycle_init_ich8lan(hw);\r\nif (ret_val != 0)\r\nbreak;\r\nhsflctl.regval = er16flash(ICH_FLASH_HSFCTL);\r\nhsflctl.hsf_ctrl.fldbcount = size - 1;\r\nhsflctl.hsf_ctrl.flcycle = ICH_CYCLE_READ;\r\new16flash(ICH_FLASH_HSFCTL, hsflctl.regval);\r\new32flash(ICH_FLASH_FADDR, flash_linear_addr);\r\nret_val = e1000_flash_cycle_ich8lan(hw,\r\nICH_FLASH_READ_COMMAND_TIMEOUT);\r\nif (ret_val == 0) {\r\nflash_data = er32flash(ICH_FLASH_FDATA0);\r\nif (size == 1)\r\n*data = (u8)(flash_data & 0x000000FF);\r\nelse if (size == 2)\r\n*data = (u16)(flash_data & 0x0000FFFF);\r\nbreak;\r\n} else {\r\nhsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\r\nif (hsfsts.hsf_status.flcerr == 1) {\r\ncontinue;\r\n} else if (hsfsts.hsf_status.flcdone == 0) {\r\ne_dbg("Timeout error - flash cycle "\r\n"did not complete.\n");\r\nbreak;\r\n}\r\n}\r\n} while (count++ < ICH_FLASH_CYCLE_REPEAT_COUNT);\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_write_nvm_ich8lan(struct e1000_hw *hw, u16 offset, u16 words,\r\nu16 *data)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\r\nu16 i;\r\nif ((offset >= nvm->word_size) || (words > nvm->word_size - offset) ||\r\n(words == 0)) {\r\ne_dbg("nvm parameter(s) out of bounds\n");\r\nreturn -E1000_ERR_NVM;\r\n}\r\nnvm->ops.acquire(hw);\r\nfor (i = 0; i < words; i++) {\r\ndev_spec->shadow_ram[offset+i].modified = true;\r\ndev_spec->shadow_ram[offset+i].value = data[i];\r\n}\r\nnvm->ops.release(hw);\r\nreturn 0;\r\n}\r\nstatic s32 e1000_update_nvm_checksum_ich8lan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\r\nu32 i, act_offset, new_bank_offset, old_bank_offset, bank;\r\ns32 ret_val;\r\nu16 data;\r\nret_val = e1000e_update_nvm_checksum_generic(hw);\r\nif (ret_val)\r\ngoto out;\r\nif (nvm->type != e1000_nvm_flash_sw)\r\ngoto out;\r\nnvm->ops.acquire(hw);\r\nret_val = e1000_valid_nvm_bank_detect_ich8lan(hw, &bank);\r\nif (ret_val) {\r\ne_dbg("Could not detect valid bank, assuming bank 0\n");\r\nbank = 0;\r\n}\r\nif (bank == 0) {\r\nnew_bank_offset = nvm->flash_bank_size;\r\nold_bank_offset = 0;\r\nret_val = e1000_erase_flash_bank_ich8lan(hw, 1);\r\nif (ret_val)\r\ngoto release;\r\n} else {\r\nold_bank_offset = nvm->flash_bank_size;\r\nnew_bank_offset = 0;\r\nret_val = e1000_erase_flash_bank_ich8lan(hw, 0);\r\nif (ret_val)\r\ngoto release;\r\n}\r\nfor (i = 0; i < E1000_ICH8_SHADOW_RAM_WORDS; i++) {\r\nif (dev_spec->shadow_ram[i].modified) {\r\ndata = dev_spec->shadow_ram[i].value;\r\n} else {\r\nret_val = e1000_read_flash_word_ich8lan(hw, i +\r\nold_bank_offset,\r\n&data);\r\nif (ret_val)\r\nbreak;\r\n}\r\nif (i == E1000_ICH_NVM_SIG_WORD)\r\ndata |= E1000_ICH_NVM_SIG_MASK;\r\nact_offset = (i + new_bank_offset) << 1;\r\nudelay(100);\r\nret_val = e1000_retry_write_flash_byte_ich8lan(hw,\r\nact_offset,\r\n(u8)data);\r\nif (ret_val)\r\nbreak;\r\nudelay(100);\r\nret_val = e1000_retry_write_flash_byte_ich8lan(hw,\r\nact_offset + 1,\r\n(u8)(data >> 8));\r\nif (ret_val)\r\nbreak;\r\n}\r\nif (ret_val) {\r\ne_dbg("Flash commit failed.\n");\r\ngoto release;\r\n}\r\nact_offset = new_bank_offset + E1000_ICH_NVM_SIG_WORD;\r\nret_val = e1000_read_flash_word_ich8lan(hw, act_offset, &data);\r\nif (ret_val)\r\ngoto release;\r\ndata &= 0xBFFF;\r\nret_val = e1000_retry_write_flash_byte_ich8lan(hw,\r\nact_offset * 2 + 1,\r\n(u8)(data >> 8));\r\nif (ret_val)\r\ngoto release;\r\nact_offset = (old_bank_offset + E1000_ICH_NVM_SIG_WORD) * 2 + 1;\r\nret_val = e1000_retry_write_flash_byte_ich8lan(hw, act_offset, 0);\r\nif (ret_val)\r\ngoto release;\r\nfor (i = 0; i < E1000_ICH8_SHADOW_RAM_WORDS; i++) {\r\ndev_spec->shadow_ram[i].modified = false;\r\ndev_spec->shadow_ram[i].value = 0xFFFF;\r\n}\r\nrelease:\r\nnvm->ops.release(hw);\r\nif (!ret_val) {\r\ne1000e_reload_nvm(hw);\r\nusleep_range(10000, 20000);\r\n}\r\nout:\r\nif (ret_val)\r\ne_dbg("NVM update error: %d\n", ret_val);\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_validate_nvm_checksum_ich8lan(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 data;\r\nret_val = e1000_read_nvm(hw, 0x19, 1, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif ((data & 0x40) == 0) {\r\ndata |= 0x40;\r\nret_val = e1000_write_nvm(hw, 0x19, 1, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000e_update_nvm_checksum(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nreturn e1000e_validate_nvm_checksum_generic(hw);\r\n}\r\nvoid e1000e_write_protect_nvm_ich8lan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nunion ich8_flash_protected_range pr0;\r\nunion ich8_hws_flash_status hsfsts;\r\nu32 gfpreg;\r\nnvm->ops.acquire(hw);\r\ngfpreg = er32flash(ICH_FLASH_GFPREG);\r\npr0.regval = er32flash(ICH_FLASH_PR0);\r\npr0.range.base = gfpreg & FLASH_GFPREG_BASE_MASK;\r\npr0.range.limit = ((gfpreg >> 16) & FLASH_GFPREG_BASE_MASK);\r\npr0.range.wpe = true;\r\new32flash(ICH_FLASH_PR0, pr0.regval);\r\nhsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\r\nhsfsts.hsf_status.flockdn = true;\r\new32flash(ICH_FLASH_HSFSTS, hsfsts.regval);\r\nnvm->ops.release(hw);\r\n}\r\nstatic s32 e1000_write_flash_data_ich8lan(struct e1000_hw *hw, u32 offset,\r\nu8 size, u16 data)\r\n{\r\nunion ich8_hws_flash_status hsfsts;\r\nunion ich8_hws_flash_ctrl hsflctl;\r\nu32 flash_linear_addr;\r\nu32 flash_data = 0;\r\ns32 ret_val;\r\nu8 count = 0;\r\nif (size < 1 || size > 2 || data > size * 0xff ||\r\noffset > ICH_FLASH_LINEAR_ADDR_MASK)\r\nreturn -E1000_ERR_NVM;\r\nflash_linear_addr = (ICH_FLASH_LINEAR_ADDR_MASK & offset) +\r\nhw->nvm.flash_base_addr;\r\ndo {\r\nudelay(1);\r\nret_val = e1000_flash_cycle_init_ich8lan(hw);\r\nif (ret_val)\r\nbreak;\r\nhsflctl.regval = er16flash(ICH_FLASH_HSFCTL);\r\nhsflctl.hsf_ctrl.fldbcount = size -1;\r\nhsflctl.hsf_ctrl.flcycle = ICH_CYCLE_WRITE;\r\new16flash(ICH_FLASH_HSFCTL, hsflctl.regval);\r\new32flash(ICH_FLASH_FADDR, flash_linear_addr);\r\nif (size == 1)\r\nflash_data = (u32)data & 0x00FF;\r\nelse\r\nflash_data = (u32)data;\r\new32flash(ICH_FLASH_FDATA0, flash_data);\r\nret_val = e1000_flash_cycle_ich8lan(hw,\r\nICH_FLASH_WRITE_COMMAND_TIMEOUT);\r\nif (!ret_val)\r\nbreak;\r\nhsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\r\nif (hsfsts.hsf_status.flcerr == 1)\r\ncontinue;\r\nif (hsfsts.hsf_status.flcdone == 0) {\r\ne_dbg("Timeout error - flash cycle "\r\n"did not complete.");\r\nbreak;\r\n}\r\n} while (count++ < ICH_FLASH_CYCLE_REPEAT_COUNT);\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_write_flash_byte_ich8lan(struct e1000_hw *hw, u32 offset,\r\nu8 data)\r\n{\r\nu16 word = (u16)data;\r\nreturn e1000_write_flash_data_ich8lan(hw, offset, 1, word);\r\n}\r\nstatic s32 e1000_retry_write_flash_byte_ich8lan(struct e1000_hw *hw,\r\nu32 offset, u8 byte)\r\n{\r\ns32 ret_val;\r\nu16 program_retries;\r\nret_val = e1000_write_flash_byte_ich8lan(hw, offset, byte);\r\nif (!ret_val)\r\nreturn ret_val;\r\nfor (program_retries = 0; program_retries < 100; program_retries++) {\r\ne_dbg("Retrying Byte %2.2X at offset %u\n", byte, offset);\r\nudelay(100);\r\nret_val = e1000_write_flash_byte_ich8lan(hw, offset, byte);\r\nif (!ret_val)\r\nbreak;\r\n}\r\nif (program_retries == 100)\r\nreturn -E1000_ERR_NVM;\r\nreturn 0;\r\n}\r\nstatic s32 e1000_erase_flash_bank_ich8lan(struct e1000_hw *hw, u32 bank)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nunion ich8_hws_flash_status hsfsts;\r\nunion ich8_hws_flash_ctrl hsflctl;\r\nu32 flash_linear_addr;\r\nu32 flash_bank_size = nvm->flash_bank_size * 2;\r\ns32 ret_val;\r\ns32 count = 0;\r\ns32 j, iteration, sector_size;\r\nhsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\r\nswitch (hsfsts.hsf_status.berasesz) {\r\ncase 0:\r\nsector_size = ICH_FLASH_SEG_SIZE_256;\r\niteration = flash_bank_size / ICH_FLASH_SEG_SIZE_256;\r\nbreak;\r\ncase 1:\r\nsector_size = ICH_FLASH_SEG_SIZE_4K;\r\niteration = 1;\r\nbreak;\r\ncase 2:\r\nsector_size = ICH_FLASH_SEG_SIZE_8K;\r\niteration = 1;\r\nbreak;\r\ncase 3:\r\nsector_size = ICH_FLASH_SEG_SIZE_64K;\r\niteration = 1;\r\nbreak;\r\ndefault:\r\nreturn -E1000_ERR_NVM;\r\n}\r\nflash_linear_addr = hw->nvm.flash_base_addr;\r\nflash_linear_addr += (bank) ? flash_bank_size : 0;\r\nfor (j = 0; j < iteration ; j++) {\r\ndo {\r\nret_val = e1000_flash_cycle_init_ich8lan(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nhsflctl.regval = er16flash(ICH_FLASH_HSFCTL);\r\nhsflctl.hsf_ctrl.flcycle = ICH_CYCLE_ERASE;\r\new16flash(ICH_FLASH_HSFCTL, hsflctl.regval);\r\nflash_linear_addr += (j * sector_size);\r\new32flash(ICH_FLASH_FADDR, flash_linear_addr);\r\nret_val = e1000_flash_cycle_ich8lan(hw,\r\nICH_FLASH_ERASE_COMMAND_TIMEOUT);\r\nif (ret_val == 0)\r\nbreak;\r\nhsfsts.regval = er16flash(ICH_FLASH_HSFSTS);\r\nif (hsfsts.hsf_status.flcerr == 1)\r\ncontinue;\r\nelse if (hsfsts.hsf_status.flcdone == 0)\r\nreturn ret_val;\r\n} while (++count < ICH_FLASH_CYCLE_REPEAT_COUNT);\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 e1000_valid_led_default_ich8lan(struct e1000_hw *hw, u16 *data)\r\n{\r\ns32 ret_val;\r\nret_val = e1000_read_nvm(hw, NVM_ID_LED_SETTINGS, 1, data);\r\nif (ret_val) {\r\ne_dbg("NVM Read Error\n");\r\nreturn ret_val;\r\n}\r\nif (*data == ID_LED_RESERVED_0000 ||\r\n*data == ID_LED_RESERVED_FFFF)\r\n*data = ID_LED_DEFAULT_ICH8LAN;\r\nreturn 0;\r\n}\r\nstatic s32 e1000_id_led_init_pchlan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mac_info *mac = &hw->mac;\r\ns32 ret_val;\r\nconst u32 ledctl_on = E1000_LEDCTL_MODE_LINK_UP;\r\nconst u32 ledctl_off = E1000_LEDCTL_MODE_LINK_UP | E1000_PHY_LED0_IVRT;\r\nu16 data, i, temp, shift;\r\nret_val = hw->nvm.ops.valid_led_default(hw, &data);\r\nif (ret_val)\r\ngoto out;\r\nmac->ledctl_default = er32(LEDCTL);\r\nmac->ledctl_mode1 = mac->ledctl_default;\r\nmac->ledctl_mode2 = mac->ledctl_default;\r\nfor (i = 0; i < 4; i++) {\r\ntemp = (data >> (i << 2)) & E1000_LEDCTL_LED0_MODE_MASK;\r\nshift = (i * 5);\r\nswitch (temp) {\r\ncase ID_LED_ON1_DEF2:\r\ncase ID_LED_ON1_ON2:\r\ncase ID_LED_ON1_OFF2:\r\nmac->ledctl_mode1 &= ~(E1000_PHY_LED0_MASK << shift);\r\nmac->ledctl_mode1 |= (ledctl_on << shift);\r\nbreak;\r\ncase ID_LED_OFF1_DEF2:\r\ncase ID_LED_OFF1_ON2:\r\ncase ID_LED_OFF1_OFF2:\r\nmac->ledctl_mode1 &= ~(E1000_PHY_LED0_MASK << shift);\r\nmac->ledctl_mode1 |= (ledctl_off << shift);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (temp) {\r\ncase ID_LED_DEF1_ON2:\r\ncase ID_LED_ON1_ON2:\r\ncase ID_LED_OFF1_ON2:\r\nmac->ledctl_mode2 &= ~(E1000_PHY_LED0_MASK << shift);\r\nmac->ledctl_mode2 |= (ledctl_on << shift);\r\nbreak;\r\ncase ID_LED_DEF1_OFF2:\r\ncase ID_LED_ON1_OFF2:\r\ncase ID_LED_OFF1_OFF2:\r\nmac->ledctl_mode2 &= ~(E1000_PHY_LED0_MASK << shift);\r\nmac->ledctl_mode2 |= (ledctl_off << shift);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_get_bus_info_ich8lan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_bus_info *bus = &hw->bus;\r\ns32 ret_val;\r\nret_val = e1000e_get_bus_info_pcie(hw);\r\nif (bus->width == e1000_bus_width_unknown)\r\nbus->width = e1000_bus_width_pcie_x1;\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_reset_hw_ich8lan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\r\nu16 reg;\r\nu32 ctrl, kab;\r\ns32 ret_val;\r\nret_val = e1000e_disable_pcie_master(hw);\r\nif (ret_val)\r\ne_dbg("PCI-E Master disable polling has failed.\n");\r\ne_dbg("Masking off all interrupts\n");\r\new32(IMC, 0xffffffff);\r\new32(RCTL, 0);\r\new32(TCTL, E1000_TCTL_PSP);\r\ne1e_flush();\r\nusleep_range(10000, 20000);\r\nif (hw->mac.type == e1000_ich8lan) {\r\new32(PBA, E1000_PBA_8K);\r\new32(PBS, E1000_PBS_16K);\r\n}\r\nif (hw->mac.type == e1000_pchlan) {\r\nret_val = e1000_read_nvm(hw, E1000_NVM_K1_CONFIG, 1, &reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (reg & E1000_NVM_K1_ENABLE)\r\ndev_spec->nvm_k1_enabled = true;\r\nelse\r\ndev_spec->nvm_k1_enabled = false;\r\n}\r\nctrl = er32(CTRL);\r\nif (!e1000_check_reset_block(hw)) {\r\nctrl |= E1000_CTRL_PHY_RST;\r\nif ((hw->mac.type == e1000_pch2lan) &&\r\n!(er32(FWSM) & E1000_ICH_FWSM_FW_VALID))\r\ne1000_gate_hw_phy_config_ich8lan(hw, true);\r\n}\r\nret_val = e1000_acquire_swflag_ich8lan(hw);\r\ne_dbg("Issuing a global reset to ich8lan\n");\r\new32(CTRL, (ctrl | E1000_CTRL_RST));\r\nmsleep(20);\r\nif (!ret_val)\r\nclear_bit(__E1000_ACCESS_SHARED_RESOURCE, &hw->adapter->state);\r\nif (ctrl & E1000_CTRL_PHY_RST) {\r\nret_val = hw->phy.ops.get_cfg_done(hw);\r\nif (ret_val)\r\ngoto out;\r\nret_val = e1000_post_phy_reset_ich8lan(hw);\r\nif (ret_val)\r\ngoto out;\r\n}\r\nif (hw->mac.type == e1000_pchlan)\r\new32(CRC_OFFSET, 0x65656565);\r\new32(IMC, 0xffffffff);\r\ner32(ICR);\r\nkab = er32(KABGTXD);\r\nkab |= E1000_KABGTXD_BGSQLBIAS;\r\new32(KABGTXD, kab);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_init_hw_ich8lan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mac_info *mac = &hw->mac;\r\nu32 ctrl_ext, txdctl, snoop;\r\ns32 ret_val;\r\nu16 i;\r\ne1000_initialize_hw_bits_ich8lan(hw);\r\nret_val = mac->ops.id_led_init(hw);\r\nif (ret_val)\r\ne_dbg("Error initializing identification LED\n");\r\ne1000e_init_rx_addrs(hw, mac->rar_entry_count);\r\ne_dbg("Zeroing the MTA\n");\r\nfor (i = 0; i < mac->mta_reg_count; i++)\r\nE1000_WRITE_REG_ARRAY(hw, E1000_MTA, i, 0);\r\nif (hw->phy.type == e1000_phy_82578) {\r\ne1e_rphy(hw, BM_PORT_GEN_CFG, &i);\r\ni &= ~BM_WUC_HOST_WU_BIT;\r\ne1e_wphy(hw, BM_PORT_GEN_CFG, i);\r\nret_val = e1000_phy_hw_reset_ich8lan(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nret_val = e1000_setup_link_ich8lan(hw);\r\ntxdctl = er32(TXDCTL(0));\r\ntxdctl = (txdctl & ~E1000_TXDCTL_WTHRESH) |\r\nE1000_TXDCTL_FULL_TX_DESC_WB;\r\ntxdctl = (txdctl & ~E1000_TXDCTL_PTHRESH) |\r\nE1000_TXDCTL_MAX_TX_DESC_PREFETCH;\r\new32(TXDCTL(0), txdctl);\r\ntxdctl = er32(TXDCTL(1));\r\ntxdctl = (txdctl & ~E1000_TXDCTL_WTHRESH) |\r\nE1000_TXDCTL_FULL_TX_DESC_WB;\r\ntxdctl = (txdctl & ~E1000_TXDCTL_PTHRESH) |\r\nE1000_TXDCTL_MAX_TX_DESC_PREFETCH;\r\new32(TXDCTL(1), txdctl);\r\nif (mac->type == e1000_ich8lan)\r\nsnoop = PCIE_ICH8_SNOOP_ALL;\r\nelse\r\nsnoop = (u32) ~(PCIE_NO_SNOOP_ALL);\r\ne1000e_set_pcie_no_snoop(hw, snoop);\r\nctrl_ext = er32(CTRL_EXT);\r\nctrl_ext |= E1000_CTRL_EXT_RO_DIS;\r\new32(CTRL_EXT, ctrl_ext);\r\ne1000_clear_hw_cntrs_ich8lan(hw);\r\nreturn 0;\r\n}\r\nstatic void e1000_initialize_hw_bits_ich8lan(struct e1000_hw *hw)\r\n{\r\nu32 reg;\r\nreg = er32(CTRL_EXT);\r\nreg |= (1 << 22);\r\nif (hw->mac.type >= e1000_pchlan)\r\nreg |= E1000_CTRL_EXT_PHYPDEN;\r\new32(CTRL_EXT, reg);\r\nreg = er32(TXDCTL(0));\r\nreg |= (1 << 22);\r\new32(TXDCTL(0), reg);\r\nreg = er32(TXDCTL(1));\r\nreg |= (1 << 22);\r\new32(TXDCTL(1), reg);\r\nreg = er32(TARC(0));\r\nif (hw->mac.type == e1000_ich8lan)\r\nreg |= (1 << 28) | (1 << 29);\r\nreg |= (1 << 23) | (1 << 24) | (1 << 26) | (1 << 27);\r\new32(TARC(0), reg);\r\nreg = er32(TARC(1));\r\nif (er32(TCTL) & E1000_TCTL_MULR)\r\nreg &= ~(1 << 28);\r\nelse\r\nreg |= (1 << 28);\r\nreg |= (1 << 24) | (1 << 26) | (1 << 30);\r\new32(TARC(1), reg);\r\nif (hw->mac.type == e1000_ich8lan) {\r\nreg = er32(STATUS);\r\nreg &= ~(1 << 31);\r\new32(STATUS, reg);\r\n}\r\nreg = er32(RFCTL);\r\nreg |= (E1000_RFCTL_NFSW_DIS | E1000_RFCTL_NFSR_DIS);\r\new32(RFCTL, reg);\r\n}\r\nstatic s32 e1000_setup_link_ich8lan(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nif (e1000_check_reset_block(hw))\r\nreturn 0;\r\nif (hw->fc.requested_mode == e1000_fc_default) {\r\nif (hw->mac.type == e1000_pchlan)\r\nhw->fc.requested_mode = e1000_fc_rx_pause;\r\nelse\r\nhw->fc.requested_mode = e1000_fc_full;\r\n}\r\nhw->fc.current_mode = hw->fc.requested_mode;\r\ne_dbg("After fix-ups FlowControl is now = %x\n",\r\nhw->fc.current_mode);\r\nret_val = e1000_setup_copper_link_ich8lan(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\new32(FCTTV, hw->fc.pause_time);\r\nif ((hw->phy.type == e1000_phy_82578) ||\r\n(hw->phy.type == e1000_phy_82579) ||\r\n(hw->phy.type == e1000_phy_82577)) {\r\new32(FCRTV_PCH, hw->fc.refresh_time);\r\nret_val = e1e_wphy(hw, PHY_REG(BM_PORT_CTRL_PAGE, 27),\r\nhw->fc.pause_time);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nreturn e1000e_set_fc_watermarks(hw);\r\n}\r\nstatic s32 e1000_setup_copper_link_ich8lan(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\ns32 ret_val;\r\nu16 reg_data;\r\nctrl = er32(CTRL);\r\nctrl |= E1000_CTRL_SLU;\r\nctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\r\new32(CTRL, ctrl);\r\nret_val = e1000e_write_kmrn_reg(hw, E1000_KMRNCTRLSTA_TIMEOUTS, 0xFFFF);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000e_read_kmrn_reg(hw, E1000_KMRNCTRLSTA_INBAND_PARAM,\r\n&reg_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nreg_data |= 0x3F;\r\nret_val = e1000e_write_kmrn_reg(hw, E1000_KMRNCTRLSTA_INBAND_PARAM,\r\nreg_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nswitch (hw->phy.type) {\r\ncase e1000_phy_igp_3:\r\nret_val = e1000e_copper_link_setup_igp(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nbreak;\r\ncase e1000_phy_bm:\r\ncase e1000_phy_82578:\r\nret_val = e1000e_copper_link_setup_m88(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nbreak;\r\ncase e1000_phy_82577:\r\ncase e1000_phy_82579:\r\nret_val = e1000_copper_link_setup_82577(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nbreak;\r\ncase e1000_phy_ife:\r\nret_val = e1e_rphy(hw, IFE_PHY_MDIX_CONTROL, &reg_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nreg_data &= ~IFE_PMC_AUTO_MDIX;\r\nswitch (hw->phy.mdix) {\r\ncase 1:\r\nreg_data &= ~IFE_PMC_FORCE_MDIX;\r\nbreak;\r\ncase 2:\r\nreg_data |= IFE_PMC_FORCE_MDIX;\r\nbreak;\r\ncase 0:\r\ndefault:\r\nreg_data |= IFE_PMC_AUTO_MDIX;\r\nbreak;\r\n}\r\nret_val = e1e_wphy(hw, IFE_PHY_MDIX_CONTROL, reg_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn e1000e_setup_copper_link(hw);\r\n}\r\nstatic s32 e1000_get_link_up_info_ich8lan(struct e1000_hw *hw, u16 *speed,\r\nu16 *duplex)\r\n{\r\ns32 ret_val;\r\nret_val = e1000e_get_speed_and_duplex_copper(hw, speed, duplex);\r\nif (ret_val)\r\nreturn ret_val;\r\nif ((hw->mac.type == e1000_ich8lan) &&\r\n(hw->phy.type == e1000_phy_igp_3) &&\r\n(*speed == SPEED_1000)) {\r\nret_val = e1000_kmrn_lock_loss_workaround_ich8lan(hw);\r\n}\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_kmrn_lock_loss_workaround_ich8lan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\r\nu32 phy_ctrl;\r\ns32 ret_val;\r\nu16 i, data;\r\nbool link;\r\nif (!dev_spec->kmrn_lock_loss_workaround_enabled)\r\nreturn 0;\r\nret_val = e1000e_phy_has_link_generic(hw, 1, 0, &link);\r\nif (!link)\r\nreturn 0;\r\nfor (i = 0; i < 10; i++) {\r\nret_val = e1e_rphy(hw, IGP3_KMRN_DIAG, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1e_rphy(hw, IGP3_KMRN_DIAG, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (!(data & IGP3_KMRN_DIAG_PCS_LOCK_LOSS))\r\nreturn 0;\r\ne1000_phy_hw_reset(hw);\r\nmdelay(5);\r\n}\r\nphy_ctrl = er32(PHY_CTRL);\r\nphy_ctrl |= (E1000_PHY_CTRL_GBE_DISABLE |\r\nE1000_PHY_CTRL_NOND0A_GBE_DISABLE);\r\new32(PHY_CTRL, phy_ctrl);\r\ne1000e_gig_downshift_workaround_ich8lan(hw);\r\nreturn -E1000_ERR_PHY;\r\n}\r\nvoid e1000e_set_kmrn_lock_loss_workaround_ich8lan(struct e1000_hw *hw,\r\nbool state)\r\n{\r\nstruct e1000_dev_spec_ich8lan *dev_spec = &hw->dev_spec.ich8lan;\r\nif (hw->mac.type != e1000_ich8lan) {\r\ne_dbg("Workaround applies to ICH8 only.\n");\r\nreturn;\r\n}\r\ndev_spec->kmrn_lock_loss_workaround_enabled = state;\r\n}\r\nvoid e1000e_igp3_phy_powerdown_workaround_ich8lan(struct e1000_hw *hw)\r\n{\r\nu32 reg;\r\nu16 data;\r\nu8 retry = 0;\r\nif (hw->phy.type != e1000_phy_igp_3)\r\nreturn;\r\ndo {\r\nreg = er32(PHY_CTRL);\r\nreg |= (E1000_PHY_CTRL_GBE_DISABLE |\r\nE1000_PHY_CTRL_NOND0A_GBE_DISABLE);\r\new32(PHY_CTRL, reg);\r\nif (hw->mac.type == e1000_ich8lan)\r\ne1000e_gig_downshift_workaround_ich8lan(hw);\r\ne1e_rphy(hw, IGP3_VR_CTRL, &data);\r\ndata &= ~IGP3_VR_CTRL_DEV_POWERDOWN_MODE_MASK;\r\ne1e_wphy(hw, IGP3_VR_CTRL, data | IGP3_VR_CTRL_MODE_SHUTDOWN);\r\ne1e_rphy(hw, IGP3_VR_CTRL, &data);\r\ndata &= IGP3_VR_CTRL_DEV_POWERDOWN_MODE_MASK;\r\nif ((data == IGP3_VR_CTRL_MODE_SHUTDOWN) || retry)\r\nbreak;\r\nreg = er32(CTRL);\r\new32(CTRL, reg | E1000_CTRL_PHY_RST);\r\nretry++;\r\n} while (retry);\r\n}\r\nvoid e1000e_gig_downshift_workaround_ich8lan(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 reg_data;\r\nif ((hw->mac.type != e1000_ich8lan) || (hw->phy.type == e1000_phy_ife))\r\nreturn;\r\nret_val = e1000e_read_kmrn_reg(hw, E1000_KMRNCTRLSTA_DIAG_OFFSET,\r\n&reg_data);\r\nif (ret_val)\r\nreturn;\r\nreg_data |= E1000_KMRNCTRLSTA_DIAG_NELPBK;\r\nret_val = e1000e_write_kmrn_reg(hw, E1000_KMRNCTRLSTA_DIAG_OFFSET,\r\nreg_data);\r\nif (ret_val)\r\nreturn;\r\nreg_data &= ~E1000_KMRNCTRLSTA_DIAG_NELPBK;\r\nret_val = e1000e_write_kmrn_reg(hw, E1000_KMRNCTRLSTA_DIAG_OFFSET,\r\nreg_data);\r\n}\r\nvoid e1000_suspend_workarounds_ich8lan(struct e1000_hw *hw)\r\n{\r\nu32 phy_ctrl;\r\ns32 ret_val;\r\nphy_ctrl = er32(PHY_CTRL);\r\nphy_ctrl |= E1000_PHY_CTRL_D0A_LPLU | E1000_PHY_CTRL_GBE_DISABLE;\r\new32(PHY_CTRL, phy_ctrl);\r\nif (hw->mac.type == e1000_ich8lan)\r\ne1000e_gig_downshift_workaround_ich8lan(hw);\r\nif (hw->mac.type >= e1000_pchlan) {\r\ne1000_oem_bits_config_ich8lan(hw, false);\r\ne1000_phy_hw_reset_ich8lan(hw);\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val)\r\nreturn;\r\ne1000_write_smbus_addr(hw);\r\nhw->phy.ops.release(hw);\r\n}\r\n}\r\nvoid e1000_resume_workarounds_pchlan(struct e1000_hw *hw)\r\n{\r\nu32 fwsm;\r\nif (hw->mac.type != e1000_pch2lan)\r\nreturn;\r\nfwsm = er32(FWSM);\r\nif (!(fwsm & E1000_ICH_FWSM_FW_VALID) || !e1000_check_reset_block(hw)) {\r\nu16 phy_id1, phy_id2;\r\ns32 ret_val;\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val) {\r\ne_dbg("Failed to acquire PHY semaphore in resume\n");\r\nreturn;\r\n}\r\nret_val = hw->phy.ops.read_reg_locked(hw, PHY_ID1, &phy_id1);\r\nif (ret_val)\r\ngoto release;\r\nret_val = hw->phy.ops.read_reg_locked(hw, PHY_ID2, &phy_id2);\r\nif (ret_val)\r\ngoto release;\r\nif (hw->phy.id == ((u32)(phy_id1 << 16) |\r\n(u32)(phy_id2 & PHY_REVISION_MASK)))\r\ngoto release;\r\ne1000_toggle_lanphypc_value_ich8lan(hw);\r\nhw->phy.ops.release(hw);\r\nmsleep(50);\r\ne1000_phy_hw_reset(hw);\r\nmsleep(50);\r\nreturn;\r\n}\r\nrelease:\r\nhw->phy.ops.release(hw);\r\nreturn;\r\n}\r\nstatic s32 e1000_cleanup_led_ich8lan(struct e1000_hw *hw)\r\n{\r\nif (hw->phy.type == e1000_phy_ife)\r\nreturn e1e_wphy(hw, IFE_PHY_SPECIAL_CONTROL_LED, 0);\r\new32(LEDCTL, hw->mac.ledctl_default);\r\nreturn 0;\r\n}\r\nstatic s32 e1000_led_on_ich8lan(struct e1000_hw *hw)\r\n{\r\nif (hw->phy.type == e1000_phy_ife)\r\nreturn e1e_wphy(hw, IFE_PHY_SPECIAL_CONTROL_LED,\r\n(IFE_PSCL_PROBE_MODE | IFE_PSCL_PROBE_LEDS_ON));\r\new32(LEDCTL, hw->mac.ledctl_mode2);\r\nreturn 0;\r\n}\r\nstatic s32 e1000_led_off_ich8lan(struct e1000_hw *hw)\r\n{\r\nif (hw->phy.type == e1000_phy_ife)\r\nreturn e1e_wphy(hw, IFE_PHY_SPECIAL_CONTROL_LED,\r\n(IFE_PSCL_PROBE_MODE |\r\nIFE_PSCL_PROBE_LEDS_OFF));\r\new32(LEDCTL, hw->mac.ledctl_mode1);\r\nreturn 0;\r\n}\r\nstatic s32 e1000_setup_led_pchlan(struct e1000_hw *hw)\r\n{\r\nreturn e1e_wphy(hw, HV_LED_CONFIG, (u16)hw->mac.ledctl_mode1);\r\n}\r\nstatic s32 e1000_cleanup_led_pchlan(struct e1000_hw *hw)\r\n{\r\nreturn e1e_wphy(hw, HV_LED_CONFIG, (u16)hw->mac.ledctl_default);\r\n}\r\nstatic s32 e1000_led_on_pchlan(struct e1000_hw *hw)\r\n{\r\nu16 data = (u16)hw->mac.ledctl_mode2;\r\nu32 i, led;\r\nif (!(er32(STATUS) & E1000_STATUS_LU)) {\r\nfor (i = 0; i < 3; i++) {\r\nled = (data >> (i * 5)) & E1000_PHY_LED0_MASK;\r\nif ((led & E1000_PHY_LED0_MODE_MASK) !=\r\nE1000_LEDCTL_MODE_LINK_UP)\r\ncontinue;\r\nif (led & E1000_PHY_LED0_IVRT)\r\ndata &= ~(E1000_PHY_LED0_IVRT << (i * 5));\r\nelse\r\ndata |= (E1000_PHY_LED0_IVRT << (i * 5));\r\n}\r\n}\r\nreturn e1e_wphy(hw, HV_LED_CONFIG, data);\r\n}\r\nstatic s32 e1000_led_off_pchlan(struct e1000_hw *hw)\r\n{\r\nu16 data = (u16)hw->mac.ledctl_mode1;\r\nu32 i, led;\r\nif (!(er32(STATUS) & E1000_STATUS_LU)) {\r\nfor (i = 0; i < 3; i++) {\r\nled = (data >> (i * 5)) & E1000_PHY_LED0_MASK;\r\nif ((led & E1000_PHY_LED0_MODE_MASK) !=\r\nE1000_LEDCTL_MODE_LINK_UP)\r\ncontinue;\r\nif (led & E1000_PHY_LED0_IVRT)\r\ndata &= ~(E1000_PHY_LED0_IVRT << (i * 5));\r\nelse\r\ndata |= (E1000_PHY_LED0_IVRT << (i * 5));\r\n}\r\n}\r\nreturn e1e_wphy(hw, HV_LED_CONFIG, data);\r\n}\r\nstatic s32 e1000_get_cfg_done_ich8lan(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nu32 bank = 0;\r\nu32 status;\r\ne1000e_get_cfg_done(hw);\r\nif (hw->mac.type >= e1000_ich10lan) {\r\ne1000_lan_init_done_ich8lan(hw);\r\n} else {\r\nret_val = e1000e_get_auto_rd_done(hw);\r\nif (ret_val) {\r\ne_dbg("Auto Read Done did not complete\n");\r\nret_val = 0;\r\n}\r\n}\r\nstatus = er32(STATUS);\r\nif (status & E1000_STATUS_PHYRA)\r\new32(STATUS, status & ~E1000_STATUS_PHYRA);\r\nelse\r\ne_dbg("PHY Reset Asserted not set - needs delay\n");\r\nif (hw->mac.type <= e1000_ich9lan) {\r\nif (((er32(EECD) & E1000_EECD_PRES) == 0) &&\r\n(hw->phy.type == e1000_phy_igp_3)) {\r\ne1000e_phy_init_script_igp3(hw);\r\n}\r\n} else {\r\nif (e1000_valid_nvm_bank_detect_ich8lan(hw, &bank)) {\r\ne_dbg("EEPROM not present\n");\r\nret_val = -E1000_ERR_CONFIG;\r\n}\r\n}\r\nreturn ret_val;\r\n}\r\nstatic void e1000_power_down_phy_copper_ich8lan(struct e1000_hw *hw)\r\n{\r\nif (!(hw->mac.ops.check_mng_mode(hw) ||\r\nhw->phy.ops.check_reset_block(hw)))\r\ne1000_power_down_phy_copper(hw);\r\n}\r\nstatic void e1000_clear_hw_cntrs_ich8lan(struct e1000_hw *hw)\r\n{\r\nu16 phy_data;\r\ns32 ret_val;\r\ne1000e_clear_hw_cntrs_base(hw);\r\ner32(ALGNERRC);\r\ner32(RXERRC);\r\ner32(TNCRS);\r\ner32(CEXTERR);\r\ner32(TSCTC);\r\ner32(TSCTFC);\r\ner32(MGTPRC);\r\ner32(MGTPDC);\r\ner32(MGTPTC);\r\ner32(IAC);\r\ner32(ICRXOC);\r\nif ((hw->phy.type == e1000_phy_82578) ||\r\n(hw->phy.type == e1000_phy_82579) ||\r\n(hw->phy.type == e1000_phy_82577)) {\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val)\r\nreturn;\r\nret_val = hw->phy.ops.set_page(hw,\r\nHV_STATS_PAGE << IGP_PAGE_SHIFT);\r\nif (ret_val)\r\ngoto release;\r\nhw->phy.ops.read_reg_page(hw, HV_SCC_UPPER, &phy_data);\r\nhw->phy.ops.read_reg_page(hw, HV_SCC_LOWER, &phy_data);\r\nhw->phy.ops.read_reg_page(hw, HV_ECOL_UPPER, &phy_data);\r\nhw->phy.ops.read_reg_page(hw, HV_ECOL_LOWER, &phy_data);\r\nhw->phy.ops.read_reg_page(hw, HV_MCC_UPPER, &phy_data);\r\nhw->phy.ops.read_reg_page(hw, HV_MCC_LOWER, &phy_data);\r\nhw->phy.ops.read_reg_page(hw, HV_LATECOL_UPPER, &phy_data);\r\nhw->phy.ops.read_reg_page(hw, HV_LATECOL_LOWER, &phy_data);\r\nhw->phy.ops.read_reg_page(hw, HV_COLC_UPPER, &phy_data);\r\nhw->phy.ops.read_reg_page(hw, HV_COLC_LOWER, &phy_data);\r\nhw->phy.ops.read_reg_page(hw, HV_DC_UPPER, &phy_data);\r\nhw->phy.ops.read_reg_page(hw, HV_DC_LOWER, &phy_data);\r\nhw->phy.ops.read_reg_page(hw, HV_TNCRS_UPPER, &phy_data);\r\nhw->phy.ops.read_reg_page(hw, HV_TNCRS_LOWER, &phy_data);\r\nrelease:\r\nhw->phy.ops.release(hw);\r\n}\r\n}
