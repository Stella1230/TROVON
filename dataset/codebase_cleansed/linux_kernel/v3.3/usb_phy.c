static inline bool phy_is_ulpi(struct tegra_usb_phy *phy)\r\n{\r\nreturn (phy->instance == 1);\r\n}\r\nstatic int utmip_pad_open(struct tegra_usb_phy *phy)\r\n{\r\nphy->pad_clk = clk_get_sys("utmip-pad", NULL);\r\nif (IS_ERR(phy->pad_clk)) {\r\npr_err("%s: can't get utmip pad clock\n", __func__);\r\nreturn PTR_ERR(phy->pad_clk);\r\n}\r\nif (phy->instance == 0) {\r\nphy->pad_regs = phy->regs;\r\n} else {\r\nphy->pad_regs = ioremap(TEGRA_USB_BASE, TEGRA_USB_SIZE);\r\nif (!phy->pad_regs) {\r\npr_err("%s: can't remap usb registers\n", __func__);\r\nclk_put(phy->pad_clk);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void utmip_pad_close(struct tegra_usb_phy *phy)\r\n{\r\nif (phy->instance != 0)\r\niounmap(phy->pad_regs);\r\nclk_put(phy->pad_clk);\r\n}\r\nstatic void utmip_pad_power_on(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val, flags;\r\nvoid __iomem *base = phy->pad_regs;\r\nclk_enable(phy->pad_clk);\r\nspin_lock_irqsave(&utmip_pad_lock, flags);\r\nif (utmip_pad_count++ == 0) {\r\nval = readl(base + UTMIP_BIAS_CFG0);\r\nval &= ~(UTMIP_OTGPD | UTMIP_BIASPD);\r\nwritel(val, base + UTMIP_BIAS_CFG0);\r\n}\r\nspin_unlock_irqrestore(&utmip_pad_lock, flags);\r\nclk_disable(phy->pad_clk);\r\n}\r\nstatic int utmip_pad_power_off(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val, flags;\r\nvoid __iomem *base = phy->pad_regs;\r\nif (!utmip_pad_count) {\r\npr_err("%s: utmip pad already powered off\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nclk_enable(phy->pad_clk);\r\nspin_lock_irqsave(&utmip_pad_lock, flags);\r\nif (--utmip_pad_count == 0) {\r\nval = readl(base + UTMIP_BIAS_CFG0);\r\nval |= UTMIP_OTGPD | UTMIP_BIASPD;\r\nwritel(val, base + UTMIP_BIAS_CFG0);\r\n}\r\nspin_unlock_irqrestore(&utmip_pad_lock, flags);\r\nclk_disable(phy->pad_clk);\r\nreturn 0;\r\n}\r\nstatic int utmi_wait_register(void __iomem *reg, u32 mask, u32 result)\r\n{\r\nunsigned long timeout = 2000;\r\ndo {\r\nif ((readl(reg) & mask) == result)\r\nreturn 0;\r\nudelay(1);\r\ntimeout--;\r\n} while (timeout);\r\nreturn -1;\r\n}\r\nstatic void utmi_phy_clk_disable(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nif (phy->instance == 0) {\r\nval = readl(base + USB_SUSP_CTRL);\r\nval |= USB_SUSP_SET;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nudelay(10);\r\nval = readl(base + USB_SUSP_CTRL);\r\nval &= ~USB_SUSP_SET;\r\nwritel(val, base + USB_SUSP_CTRL);\r\n}\r\nif (phy->instance == 2) {\r\nval = readl(base + USB_PORTSC1);\r\nval |= USB_PORTSC1_PHCD;\r\nwritel(val, base + USB_PORTSC1);\r\n}\r\nif (utmi_wait_register(base + USB_SUSP_CTRL, USB_PHY_CLK_VALID, 0) < 0)\r\npr_err("%s: timeout waiting for phy to stabilize\n", __func__);\r\n}\r\nstatic void utmi_phy_clk_enable(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nif (phy->instance == 0) {\r\nval = readl(base + USB_SUSP_CTRL);\r\nval |= USB_SUSP_CLR;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nudelay(10);\r\nval = readl(base + USB_SUSP_CTRL);\r\nval &= ~USB_SUSP_CLR;\r\nwritel(val, base + USB_SUSP_CTRL);\r\n}\r\nif (phy->instance == 2) {\r\nval = readl(base + USB_PORTSC1);\r\nval &= ~USB_PORTSC1_PHCD;\r\nwritel(val, base + USB_PORTSC1);\r\n}\r\nif (utmi_wait_register(base + USB_SUSP_CTRL, USB_PHY_CLK_VALID,\r\nUSB_PHY_CLK_VALID))\r\npr_err("%s: timeout waiting for phy to stabilize\n", __func__);\r\n}\r\nstatic int utmi_phy_power_on(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nstruct tegra_utmip_config *config = phy->config;\r\nval = readl(base + USB_SUSP_CTRL);\r\nval |= UTMIP_RESET;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nif (phy->instance == 0) {\r\nval = readl(base + USB1_LEGACY_CTRL);\r\nval |= USB1_NO_LEGACY_MODE;\r\nwritel(val, base + USB1_LEGACY_CTRL);\r\n}\r\nval = readl(base + UTMIP_TX_CFG0);\r\nval &= ~UTMIP_FS_PREABMLE_J;\r\nwritel(val, base + UTMIP_TX_CFG0);\r\nval = readl(base + UTMIP_HSRX_CFG0);\r\nval &= ~(UTMIP_IDLE_WAIT(~0) | UTMIP_ELASTIC_LIMIT(~0));\r\nval |= UTMIP_IDLE_WAIT(config->idle_wait_delay);\r\nval |= UTMIP_ELASTIC_LIMIT(config->elastic_limit);\r\nwritel(val, base + UTMIP_HSRX_CFG0);\r\nval = readl(base + UTMIP_HSRX_CFG1);\r\nval &= ~UTMIP_HS_SYNC_START_DLY(~0);\r\nval |= UTMIP_HS_SYNC_START_DLY(config->hssync_start_delay);\r\nwritel(val, base + UTMIP_HSRX_CFG1);\r\nval = readl(base + UTMIP_DEBOUNCE_CFG0);\r\nval &= ~UTMIP_BIAS_DEBOUNCE_A(~0);\r\nval |= UTMIP_BIAS_DEBOUNCE_A(phy->freq->debounce);\r\nwritel(val, base + UTMIP_DEBOUNCE_CFG0);\r\nval = readl(base + UTMIP_MISC_CFG0);\r\nval &= ~UTMIP_SUSPEND_EXIT_ON_EDGE;\r\nwritel(val, base + UTMIP_MISC_CFG0);\r\nval = readl(base + UTMIP_MISC_CFG1);\r\nval &= ~(UTMIP_PLL_ACTIVE_DLY_COUNT(~0) | UTMIP_PLLU_STABLE_COUNT(~0));\r\nval |= UTMIP_PLL_ACTIVE_DLY_COUNT(phy->freq->active_delay) |\r\nUTMIP_PLLU_STABLE_COUNT(phy->freq->stable_count);\r\nwritel(val, base + UTMIP_MISC_CFG1);\r\nval = readl(base + UTMIP_PLL_CFG1);\r\nval &= ~(UTMIP_XTAL_FREQ_COUNT(~0) | UTMIP_PLLU_ENABLE_DLY_COUNT(~0));\r\nval |= UTMIP_XTAL_FREQ_COUNT(phy->freq->xtal_freq_count) |\r\nUTMIP_PLLU_ENABLE_DLY_COUNT(phy->freq->enable_delay);\r\nwritel(val, base + UTMIP_PLL_CFG1);\r\nif (phy->mode == TEGRA_USB_PHY_MODE_DEVICE) {\r\nval = readl(base + USB_SUSP_CTRL);\r\nval &= ~(USB_WAKE_ON_CNNT_EN_DEV | USB_WAKE_ON_DISCON_EN_DEV);\r\nwritel(val, base + USB_SUSP_CTRL);\r\n}\r\nutmip_pad_power_on(phy);\r\nval = readl(base + UTMIP_XCVR_CFG0);\r\nval &= ~(UTMIP_FORCE_PD_POWERDOWN | UTMIP_FORCE_PD2_POWERDOWN |\r\nUTMIP_FORCE_PDZI_POWERDOWN | UTMIP_XCVR_SETUP(~0) |\r\nUTMIP_XCVR_LSFSLEW(~0) | UTMIP_XCVR_LSRSLEW(~0) |\r\nUTMIP_XCVR_HSSLEW_MSB(~0));\r\nval |= UTMIP_XCVR_SETUP(config->xcvr_setup);\r\nval |= UTMIP_XCVR_LSFSLEW(config->xcvr_lsfslew);\r\nval |= UTMIP_XCVR_LSRSLEW(config->xcvr_lsrslew);\r\nwritel(val, base + UTMIP_XCVR_CFG0);\r\nval = readl(base + UTMIP_XCVR_CFG1);\r\nval &= ~(UTMIP_FORCE_PDDISC_POWERDOWN | UTMIP_FORCE_PDCHRP_POWERDOWN |\r\nUTMIP_FORCE_PDDR_POWERDOWN | UTMIP_XCVR_TERM_RANGE_ADJ(~0));\r\nval |= UTMIP_XCVR_TERM_RANGE_ADJ(config->term_range_adj);\r\nwritel(val, base + UTMIP_XCVR_CFG1);\r\nval = readl(base + UTMIP_BAT_CHRG_CFG0);\r\nval &= ~UTMIP_PD_CHRG;\r\nwritel(val, base + UTMIP_BAT_CHRG_CFG0);\r\nval = readl(base + UTMIP_BIAS_CFG1);\r\nval &= ~UTMIP_BIAS_PDTRK_COUNT(~0);\r\nval |= UTMIP_BIAS_PDTRK_COUNT(0x5);\r\nwritel(val, base + UTMIP_BIAS_CFG1);\r\nif (phy->instance == 0) {\r\nval = readl(base + UTMIP_SPARE_CFG0);\r\nif (phy->mode == TEGRA_USB_PHY_MODE_DEVICE)\r\nval &= ~FUSE_SETUP_SEL;\r\nelse\r\nval |= FUSE_SETUP_SEL;\r\nwritel(val, base + UTMIP_SPARE_CFG0);\r\n}\r\nif (phy->instance == 2) {\r\nval = readl(base + USB_SUSP_CTRL);\r\nval |= UTMIP_PHY_ENABLE;\r\nwritel(val, base + USB_SUSP_CTRL);\r\n}\r\nval = readl(base + USB_SUSP_CTRL);\r\nval &= ~UTMIP_RESET;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nif (phy->instance == 0) {\r\nval = readl(base + USB1_LEGACY_CTRL);\r\nval &= ~USB1_VBUS_SENSE_CTL_MASK;\r\nval |= USB1_VBUS_SENSE_CTL_A_SESS_VLD;\r\nwritel(val, base + USB1_LEGACY_CTRL);\r\nval = readl(base + USB_SUSP_CTRL);\r\nval &= ~USB_SUSP_SET;\r\nwritel(val, base + USB_SUSP_CTRL);\r\n}\r\nutmi_phy_clk_enable(phy);\r\nif (phy->instance == 2) {\r\nval = readl(base + USB_PORTSC1);\r\nval &= ~USB_PORTSC1_PTS(~0);\r\nwritel(val, base + USB_PORTSC1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void utmi_phy_power_off(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nutmi_phy_clk_disable(phy);\r\nif (phy->mode == TEGRA_USB_PHY_MODE_DEVICE) {\r\nval = readl(base + USB_SUSP_CTRL);\r\nval &= ~USB_WAKEUP_DEBOUNCE_COUNT(~0);\r\nval |= USB_WAKE_ON_CNNT_EN_DEV | USB_WAKEUP_DEBOUNCE_COUNT(5);\r\nwritel(val, base + USB_SUSP_CTRL);\r\n}\r\nval = readl(base + USB_SUSP_CTRL);\r\nval |= UTMIP_RESET;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nval = readl(base + UTMIP_BAT_CHRG_CFG0);\r\nval |= UTMIP_PD_CHRG;\r\nwritel(val, base + UTMIP_BAT_CHRG_CFG0);\r\nval = readl(base + UTMIP_XCVR_CFG0);\r\nval |= UTMIP_FORCE_PD_POWERDOWN | UTMIP_FORCE_PD2_POWERDOWN |\r\nUTMIP_FORCE_PDZI_POWERDOWN;\r\nwritel(val, base + UTMIP_XCVR_CFG0);\r\nval = readl(base + UTMIP_XCVR_CFG1);\r\nval |= UTMIP_FORCE_PDDISC_POWERDOWN | UTMIP_FORCE_PDCHRP_POWERDOWN |\r\nUTMIP_FORCE_PDDR_POWERDOWN;\r\nwritel(val, base + UTMIP_XCVR_CFG1);\r\nutmip_pad_power_off(phy);\r\n}\r\nstatic void utmi_phy_preresume(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nval = readl(base + UTMIP_TX_CFG0);\r\nval |= UTMIP_HS_DISCON_DISABLE;\r\nwritel(val, base + UTMIP_TX_CFG0);\r\n}\r\nstatic void utmi_phy_postresume(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nval = readl(base + UTMIP_TX_CFG0);\r\nval &= ~UTMIP_HS_DISCON_DISABLE;\r\nwritel(val, base + UTMIP_TX_CFG0);\r\n}\r\nstatic void utmi_phy_restore_start(struct tegra_usb_phy *phy,\r\nenum tegra_usb_phy_port_speed port_speed)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nval = readl(base + UTMIP_MISC_CFG0);\r\nval &= ~UTMIP_DPDM_OBSERVE_SEL(~0);\r\nif (port_speed == TEGRA_USB_PHY_PORT_SPEED_LOW)\r\nval |= UTMIP_DPDM_OBSERVE_SEL_FS_K;\r\nelse\r\nval |= UTMIP_DPDM_OBSERVE_SEL_FS_J;\r\nwritel(val, base + UTMIP_MISC_CFG0);\r\nudelay(1);\r\nval = readl(base + UTMIP_MISC_CFG0);\r\nval |= UTMIP_DPDM_OBSERVE;\r\nwritel(val, base + UTMIP_MISC_CFG0);\r\nudelay(10);\r\n}\r\nstatic void utmi_phy_restore_end(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nval = readl(base + UTMIP_MISC_CFG0);\r\nval &= ~UTMIP_DPDM_OBSERVE;\r\nwritel(val, base + UTMIP_MISC_CFG0);\r\nudelay(10);\r\n}\r\nstatic int ulpi_phy_power_on(struct tegra_usb_phy *phy)\r\n{\r\nint ret;\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nstruct tegra_ulpi_config *config = phy->config;\r\ngpio_direction_output(config->reset_gpio, 0);\r\nmsleep(5);\r\ngpio_direction_output(config->reset_gpio, 1);\r\nclk_enable(phy->clk);\r\nmsleep(1);\r\nval = readl(base + USB_SUSP_CTRL);\r\nval |= UHSIC_RESET;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nval = readl(base + ULPI_TIMING_CTRL_0);\r\nval |= ULPI_OUTPUT_PINMUX_BYP | ULPI_CLKOUT_PINMUX_BYP;\r\nwritel(val, base + ULPI_TIMING_CTRL_0);\r\nval = readl(base + USB_SUSP_CTRL);\r\nval |= ULPI_PHY_ENABLE;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nval = 0;\r\nwritel(val, base + ULPI_TIMING_CTRL_1);\r\nval |= ULPI_DATA_TRIMMER_SEL(4);\r\nval |= ULPI_STPDIRNXT_TRIMMER_SEL(4);\r\nval |= ULPI_DIR_TRIMMER_SEL(4);\r\nwritel(val, base + ULPI_TIMING_CTRL_1);\r\nudelay(10);\r\nval |= ULPI_DATA_TRIMMER_LOAD;\r\nval |= ULPI_STPDIRNXT_TRIMMER_LOAD;\r\nval |= ULPI_DIR_TRIMMER_LOAD;\r\nwritel(val, base + ULPI_TIMING_CTRL_1);\r\nret = otg_io_write(phy->ulpi, 0x40, 0x08);\r\nif (ret) {\r\npr_err("%s: ulpi write failed\n", __func__);\r\nreturn ret;\r\n}\r\nret = otg_io_write(phy->ulpi, 0x80, 0x0B);\r\nif (ret) {\r\npr_err("%s: ulpi write failed\n", __func__);\r\nreturn ret;\r\n}\r\nval = readl(base + USB_PORTSC1);\r\nval |= USB_PORTSC1_WKOC | USB_PORTSC1_WKDS | USB_PORTSC1_WKCN;\r\nwritel(val, base + USB_PORTSC1);\r\nval = readl(base + USB_SUSP_CTRL);\r\nval |= USB_SUSP_CLR;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nudelay(100);\r\nval = readl(base + USB_SUSP_CTRL);\r\nval &= ~USB_SUSP_CLR;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nreturn 0;\r\n}\r\nstatic void ulpi_phy_power_off(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nstruct tegra_ulpi_config *config = phy->config;\r\nval = readl(base + USB_PORTSC1);\r\nval &= ~(USB_PORTSC1_WKOC | USB_PORTSC1_WKDS | USB_PORTSC1_WKCN);\r\nwritel(val, base + USB_PORTSC1);\r\ngpio_direction_output(config->reset_gpio, 0);\r\nclk_disable(phy->clk);\r\n}\r\nstruct tegra_usb_phy *tegra_usb_phy_open(int instance, void __iomem *regs,\r\nvoid *config, enum tegra_usb_phy_mode phy_mode)\r\n{\r\nstruct tegra_usb_phy *phy;\r\nstruct tegra_ulpi_config *ulpi_config;\r\nunsigned long parent_rate;\r\nint i;\r\nint err;\r\nphy = kmalloc(sizeof(struct tegra_usb_phy), GFP_KERNEL);\r\nif (!phy)\r\nreturn ERR_PTR(-ENOMEM);\r\nphy->instance = instance;\r\nphy->regs = regs;\r\nphy->config = config;\r\nphy->mode = phy_mode;\r\nif (!phy->config) {\r\nif (phy_is_ulpi(phy)) {\r\npr_err("%s: ulpi phy configuration missing", __func__);\r\nerr = -EINVAL;\r\ngoto err0;\r\n} else {\r\nphy->config = &utmip_default[instance];\r\n}\r\n}\r\nphy->pll_u = clk_get_sys(NULL, "pll_u");\r\nif (IS_ERR(phy->pll_u)) {\r\npr_err("Can't get pll_u clock\n");\r\nerr = PTR_ERR(phy->pll_u);\r\ngoto err0;\r\n}\r\nclk_enable(phy->pll_u);\r\nparent_rate = clk_get_rate(clk_get_parent(phy->pll_u));\r\nfor (i = 0; i < ARRAY_SIZE(tegra_freq_table); i++) {\r\nif (tegra_freq_table[i].freq == parent_rate) {\r\nphy->freq = &tegra_freq_table[i];\r\nbreak;\r\n}\r\n}\r\nif (!phy->freq) {\r\npr_err("invalid pll_u parent rate %ld\n", parent_rate);\r\nerr = -EINVAL;\r\ngoto err1;\r\n}\r\nif (phy_is_ulpi(phy)) {\r\nulpi_config = config;\r\nphy->clk = clk_get_sys(NULL, ulpi_config->clk);\r\nif (IS_ERR(phy->clk)) {\r\npr_err("%s: can't get ulpi clock\n", __func__);\r\nerr = -ENXIO;\r\ngoto err1;\r\n}\r\ntegra_gpio_enable(ulpi_config->reset_gpio);\r\ngpio_request(ulpi_config->reset_gpio, "ulpi_phy_reset_b");\r\ngpio_direction_output(ulpi_config->reset_gpio, 0);\r\nphy->ulpi = otg_ulpi_create(&ulpi_viewport_access_ops, 0);\r\nphy->ulpi->io_priv = regs + ULPI_VIEWPORT;\r\n} else {\r\nerr = utmip_pad_open(phy);\r\nif (err < 0)\r\ngoto err1;\r\n}\r\nreturn phy;\r\nerr1:\r\nclk_disable(phy->pll_u);\r\nclk_put(phy->pll_u);\r\nerr0:\r\nkfree(phy);\r\nreturn ERR_PTR(err);\r\n}\r\nint tegra_usb_phy_power_on(struct tegra_usb_phy *phy)\r\n{\r\nif (phy_is_ulpi(phy))\r\nreturn ulpi_phy_power_on(phy);\r\nelse\r\nreturn utmi_phy_power_on(phy);\r\n}\r\nvoid tegra_usb_phy_power_off(struct tegra_usb_phy *phy)\r\n{\r\nif (phy_is_ulpi(phy))\r\nulpi_phy_power_off(phy);\r\nelse\r\nutmi_phy_power_off(phy);\r\n}\r\nvoid tegra_usb_phy_preresume(struct tegra_usb_phy *phy)\r\n{\r\nif (!phy_is_ulpi(phy))\r\nutmi_phy_preresume(phy);\r\n}\r\nvoid tegra_usb_phy_postresume(struct tegra_usb_phy *phy)\r\n{\r\nif (!phy_is_ulpi(phy))\r\nutmi_phy_postresume(phy);\r\n}\r\nvoid tegra_ehci_phy_restore_start(struct tegra_usb_phy *phy,\r\nenum tegra_usb_phy_port_speed port_speed)\r\n{\r\nif (!phy_is_ulpi(phy))\r\nutmi_phy_restore_start(phy, port_speed);\r\n}\r\nvoid tegra_ehci_phy_restore_end(struct tegra_usb_phy *phy)\r\n{\r\nif (!phy_is_ulpi(phy))\r\nutmi_phy_restore_end(phy);\r\n}\r\nvoid tegra_usb_phy_clk_disable(struct tegra_usb_phy *phy)\r\n{\r\nif (!phy_is_ulpi(phy))\r\nutmi_phy_clk_disable(phy);\r\n}\r\nvoid tegra_usb_phy_clk_enable(struct tegra_usb_phy *phy)\r\n{\r\nif (!phy_is_ulpi(phy))\r\nutmi_phy_clk_enable(phy);\r\n}\r\nvoid tegra_usb_phy_close(struct tegra_usb_phy *phy)\r\n{\r\nif (phy_is_ulpi(phy))\r\nclk_put(phy->clk);\r\nelse\r\nutmip_pad_close(phy);\r\nclk_disable(phy->pll_u);\r\nclk_put(phy->pll_u);\r\nkfree(phy);\r\n}
