static inline void *get_rloc_data(u32 *dl)\r\n{\r\nreturn (u8 *)dl + get_rloc_offs(*dl);\r\n}\r\nstatic inline void *get_loc_data(u32 *dl, void *ent)\r\n{\r\nreturn (u8 *)ent + get_rloc_offs(*dl);\r\n}\r\nstatic __kprobes int PRINT_TYPE_FUNC_NAME(string)(struct trace_seq *s,\r\nconst char *name,\r\nvoid *data, void *ent)\r\n{\r\nint len = *(u32 *)data >> 16;\r\nif (!len)\r\nreturn trace_seq_printf(s, " %s=(fault)", name);\r\nelse\r\nreturn trace_seq_printf(s, " %s=\"%s\"", name,\r\n(const char *)get_loc_data(data, ent));\r\n}\r\nstatic __kprobes void call_fetch(struct fetch_param *fprm,\r\nstruct pt_regs *regs, void *dest)\r\n{\r\nreturn fprm->fn(regs, fprm->data, dest);\r\n}\r\nstatic unsigned long update_symbol_cache(struct symbol_cache *sc)\r\n{\r\nsc->addr = (unsigned long)kallsyms_lookup_name(sc->symbol);\r\nif (sc->addr)\r\nsc->addr += sc->offset;\r\nreturn sc->addr;\r\n}\r\nstatic void free_symbol_cache(struct symbol_cache *sc)\r\n{\r\nkfree(sc->symbol);\r\nkfree(sc);\r\n}\r\nstatic struct symbol_cache *alloc_symbol_cache(const char *sym, long offset)\r\n{\r\nstruct symbol_cache *sc;\r\nif (!sym || strlen(sym) == 0)\r\nreturn NULL;\r\nsc = kzalloc(sizeof(struct symbol_cache), GFP_KERNEL);\r\nif (!sc)\r\nreturn NULL;\r\nsc->symbol = kstrdup(sym, GFP_KERNEL);\r\nif (!sc->symbol) {\r\nkfree(sc);\r\nreturn NULL;\r\n}\r\nsc->offset = offset;\r\nupdate_symbol_cache(sc);\r\nreturn sc;\r\n}\r\nstatic __kprobes void update_deref_fetch_param(struct deref_fetch_param *data)\r\n{\r\nif (CHECK_FETCH_FUNCS(deref, data->orig.fn))\r\nupdate_deref_fetch_param(data->orig.data);\r\nelse if (CHECK_FETCH_FUNCS(symbol, data->orig.fn))\r\nupdate_symbol_cache(data->orig.data);\r\n}\r\nstatic __kprobes void free_deref_fetch_param(struct deref_fetch_param *data)\r\n{\r\nif (CHECK_FETCH_FUNCS(deref, data->orig.fn))\r\nfree_deref_fetch_param(data->orig.data);\r\nelse if (CHECK_FETCH_FUNCS(symbol, data->orig.fn))\r\nfree_symbol_cache(data->orig.data);\r\nkfree(data);\r\n}\r\nstatic __kprobes void\r\nupdate_bitfield_fetch_param(struct bitfield_fetch_param *data)\r\n{\r\nif (CHECK_FETCH_FUNCS(deref, data->orig.fn))\r\nupdate_deref_fetch_param(data->orig.data);\r\nelse if (CHECK_FETCH_FUNCS(symbol, data->orig.fn))\r\nupdate_symbol_cache(data->orig.data);\r\n}\r\nstatic __kprobes void\r\nfree_bitfield_fetch_param(struct bitfield_fetch_param *data)\r\n{\r\nif (CHECK_FETCH_FUNCS(deref, data->orig.fn))\r\nfree_deref_fetch_param(data->orig.data);\r\nelse if (CHECK_FETCH_FUNCS(symbol, data->orig.fn))\r\nfree_symbol_cache(data->orig.data);\r\nkfree(data);\r\n}\r\nstatic const struct fetch_type *find_fetch_type(const char *type)\r\n{\r\nint i;\r\nif (!type)\r\ntype = DEFAULT_FETCH_TYPE_STR;\r\nif (*type == 'b') {\r\nunsigned long bs;\r\ntype = strchr(type, '/');\r\nif (!type)\r\ngoto fail;\r\ntype++;\r\nif (strict_strtoul(type, 0, &bs))\r\ngoto fail;\r\nswitch (bs) {\r\ncase 8:\r\nreturn find_fetch_type("u8");\r\ncase 16:\r\nreturn find_fetch_type("u16");\r\ncase 32:\r\nreturn find_fetch_type("u32");\r\ncase 64:\r\nreturn find_fetch_type("u64");\r\ndefault:\r\ngoto fail;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(fetch_type_table); i++)\r\nif (strcmp(type, fetch_type_table[i].name) == 0)\r\nreturn &fetch_type_table[i];\r\nfail:\r\nreturn NULL;\r\n}\r\nstatic __kprobes void fetch_stack_address(struct pt_regs *regs,\r\nvoid *dummy, void *dest)\r\n{\r\n*(unsigned long *)dest = kernel_stack_pointer(regs);\r\n}\r\nstatic fetch_func_t get_fetch_size_function(const struct fetch_type *type,\r\nfetch_func_t orig_fn)\r\n{\r\nint i;\r\nif (type != &fetch_type_table[FETCH_TYPE_STRING])\r\nreturn NULL;\r\nfor (i = 0; i < FETCH_MTD_END; i++)\r\nif (type->fetch[i] == orig_fn)\r\nreturn fetch_type_table[FETCH_TYPE_STRSIZE].fetch[i];\r\nWARN_ON(1);\r\nreturn NULL;\r\n}\r\nstatic __kprobes int trace_probe_is_return(struct trace_probe *tp)\r\n{\r\nreturn tp->rp.handler != NULL;\r\n}\r\nstatic __kprobes const char *trace_probe_symbol(struct trace_probe *tp)\r\n{\r\nreturn tp->symbol ? tp->symbol : "unknown";\r\n}\r\nstatic __kprobes unsigned long trace_probe_offset(struct trace_probe *tp)\r\n{\r\nreturn tp->rp.kp.offset;\r\n}\r\nstatic __kprobes bool trace_probe_is_enabled(struct trace_probe *tp)\r\n{\r\nreturn !!(tp->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE));\r\n}\r\nstatic __kprobes bool trace_probe_is_registered(struct trace_probe *tp)\r\n{\r\nreturn !!(tp->flags & TP_FLAG_REGISTERED);\r\n}\r\nstatic __kprobes bool trace_probe_has_gone(struct trace_probe *tp)\r\n{\r\nreturn !!(kprobe_gone(&tp->rp.kp));\r\n}\r\nstatic __kprobes bool trace_probe_within_module(struct trace_probe *tp,\r\nstruct module *mod)\r\n{\r\nint len = strlen(mod->name);\r\nconst char *name = trace_probe_symbol(tp);\r\nreturn strncmp(mod->name, name, len) == 0 && name[len] == ':';\r\n}\r\nstatic __kprobes bool trace_probe_is_on_module(struct trace_probe *tp)\r\n{\r\nreturn !!strchr(trace_probe_symbol(tp), ':');\r\n}\r\nstatic int is_good_name(const char *name)\r\n{\r\nif (!isalpha(*name) && *name != '_')\r\nreturn 0;\r\nwhile (*++name != '\0') {\r\nif (!isalpha(*name) && !isdigit(*name) && *name != '_')\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic struct trace_probe *alloc_trace_probe(const char *group,\r\nconst char *event,\r\nvoid *addr,\r\nconst char *symbol,\r\nunsigned long offs,\r\nint nargs, int is_return)\r\n{\r\nstruct trace_probe *tp;\r\nint ret = -ENOMEM;\r\ntp = kzalloc(SIZEOF_TRACE_PROBE(nargs), GFP_KERNEL);\r\nif (!tp)\r\nreturn ERR_PTR(ret);\r\nif (symbol) {\r\ntp->symbol = kstrdup(symbol, GFP_KERNEL);\r\nif (!tp->symbol)\r\ngoto error;\r\ntp->rp.kp.symbol_name = tp->symbol;\r\ntp->rp.kp.offset = offs;\r\n} else\r\ntp->rp.kp.addr = addr;\r\nif (is_return)\r\ntp->rp.handler = kretprobe_dispatcher;\r\nelse\r\ntp->rp.kp.pre_handler = kprobe_dispatcher;\r\nif (!event || !is_good_name(event)) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ntp->call.class = &tp->class;\r\ntp->call.name = kstrdup(event, GFP_KERNEL);\r\nif (!tp->call.name)\r\ngoto error;\r\nif (!group || !is_good_name(group)) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ntp->class.system = kstrdup(group, GFP_KERNEL);\r\nif (!tp->class.system)\r\ngoto error;\r\nINIT_LIST_HEAD(&tp->list);\r\nreturn tp;\r\nerror:\r\nkfree(tp->call.name);\r\nkfree(tp->symbol);\r\nkfree(tp);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void update_probe_arg(struct probe_arg *arg)\r\n{\r\nif (CHECK_FETCH_FUNCS(bitfield, arg->fetch.fn))\r\nupdate_bitfield_fetch_param(arg->fetch.data);\r\nelse if (CHECK_FETCH_FUNCS(deref, arg->fetch.fn))\r\nupdate_deref_fetch_param(arg->fetch.data);\r\nelse if (CHECK_FETCH_FUNCS(symbol, arg->fetch.fn))\r\nupdate_symbol_cache(arg->fetch.data);\r\n}\r\nstatic void free_probe_arg(struct probe_arg *arg)\r\n{\r\nif (CHECK_FETCH_FUNCS(bitfield, arg->fetch.fn))\r\nfree_bitfield_fetch_param(arg->fetch.data);\r\nelse if (CHECK_FETCH_FUNCS(deref, arg->fetch.fn))\r\nfree_deref_fetch_param(arg->fetch.data);\r\nelse if (CHECK_FETCH_FUNCS(symbol, arg->fetch.fn))\r\nfree_symbol_cache(arg->fetch.data);\r\nkfree(arg->name);\r\nkfree(arg->comm);\r\n}\r\nstatic void free_trace_probe(struct trace_probe *tp)\r\n{\r\nint i;\r\nfor (i = 0; i < tp->nr_args; i++)\r\nfree_probe_arg(&tp->args[i]);\r\nkfree(tp->call.class->system);\r\nkfree(tp->call.name);\r\nkfree(tp->symbol);\r\nkfree(tp);\r\n}\r\nstatic struct trace_probe *find_trace_probe(const char *event,\r\nconst char *group)\r\n{\r\nstruct trace_probe *tp;\r\nlist_for_each_entry(tp, &probe_list, list)\r\nif (strcmp(tp->call.name, event) == 0 &&\r\nstrcmp(tp->call.class->system, group) == 0)\r\nreturn tp;\r\nreturn NULL;\r\n}\r\nstatic int enable_trace_probe(struct trace_probe *tp, int flag)\r\n{\r\nint ret = 0;\r\ntp->flags |= flag;\r\nif (trace_probe_is_enabled(tp) && trace_probe_is_registered(tp) &&\r\n!trace_probe_has_gone(tp)) {\r\nif (trace_probe_is_return(tp))\r\nret = enable_kretprobe(&tp->rp);\r\nelse\r\nret = enable_kprobe(&tp->rp.kp);\r\n}\r\nreturn ret;\r\n}\r\nstatic void disable_trace_probe(struct trace_probe *tp, int flag)\r\n{\r\ntp->flags &= ~flag;\r\nif (!trace_probe_is_enabled(tp) && trace_probe_is_registered(tp)) {\r\nif (trace_probe_is_return(tp))\r\ndisable_kretprobe(&tp->rp);\r\nelse\r\ndisable_kprobe(&tp->rp.kp);\r\n}\r\n}\r\nstatic int __register_trace_probe(struct trace_probe *tp)\r\n{\r\nint i, ret;\r\nif (trace_probe_is_registered(tp))\r\nreturn -EINVAL;\r\nfor (i = 0; i < tp->nr_args; i++)\r\nupdate_probe_arg(&tp->args[i]);\r\nif (trace_probe_is_enabled(tp))\r\ntp->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\r\nelse\r\ntp->rp.kp.flags |= KPROBE_FLAG_DISABLED;\r\nif (trace_probe_is_return(tp))\r\nret = register_kretprobe(&tp->rp);\r\nelse\r\nret = register_kprobe(&tp->rp.kp);\r\nif (ret == 0)\r\ntp->flags |= TP_FLAG_REGISTERED;\r\nelse {\r\npr_warning("Could not insert probe at %s+%lu: %d\n",\r\ntrace_probe_symbol(tp), trace_probe_offset(tp), ret);\r\nif (ret == -ENOENT && trace_probe_is_on_module(tp)) {\r\npr_warning("This probe might be able to register after"\r\n"target module is loaded. Continue.\n");\r\nret = 0;\r\n} else if (ret == -EILSEQ) {\r\npr_warning("Probing address(0x%p) is not an "\r\n"instruction boundary.\n",\r\ntp->rp.kp.addr);\r\nret = -EINVAL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void __unregister_trace_probe(struct trace_probe *tp)\r\n{\r\nif (trace_probe_is_registered(tp)) {\r\nif (trace_probe_is_return(tp))\r\nunregister_kretprobe(&tp->rp);\r\nelse\r\nunregister_kprobe(&tp->rp.kp);\r\ntp->flags &= ~TP_FLAG_REGISTERED;\r\nif (tp->rp.kp.symbol_name)\r\ntp->rp.kp.addr = NULL;\r\n}\r\n}\r\nstatic int unregister_trace_probe(struct trace_probe *tp)\r\n{\r\nif (trace_probe_is_enabled(tp))\r\nreturn -EBUSY;\r\n__unregister_trace_probe(tp);\r\nlist_del(&tp->list);\r\nunregister_probe_event(tp);\r\nreturn 0;\r\n}\r\nstatic int register_trace_probe(struct trace_probe *tp)\r\n{\r\nstruct trace_probe *old_tp;\r\nint ret;\r\nmutex_lock(&probe_lock);\r\nold_tp = find_trace_probe(tp->call.name, tp->call.class->system);\r\nif (old_tp) {\r\nret = unregister_trace_probe(old_tp);\r\nif (ret < 0)\r\ngoto end;\r\nfree_trace_probe(old_tp);\r\n}\r\nret = register_probe_event(tp);\r\nif (ret) {\r\npr_warning("Failed to register probe event(%d)\n", ret);\r\ngoto end;\r\n}\r\nret = __register_trace_probe(tp);\r\nif (ret < 0)\r\nunregister_probe_event(tp);\r\nelse\r\nlist_add_tail(&tp->list, &probe_list);\r\nend:\r\nmutex_unlock(&probe_lock);\r\nreturn ret;\r\n}\r\nstatic int trace_probe_module_callback(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct module *mod = data;\r\nstruct trace_probe *tp;\r\nint ret;\r\nif (val != MODULE_STATE_COMING)\r\nreturn NOTIFY_DONE;\r\nmutex_lock(&probe_lock);\r\nlist_for_each_entry(tp, &probe_list, list) {\r\nif (trace_probe_within_module(tp, mod)) {\r\n__unregister_trace_probe(tp);\r\nret = __register_trace_probe(tp);\r\nif (ret)\r\npr_warning("Failed to re-register probe %s on"\r\n"%s: %d\n",\r\ntp->call.name, mod->name, ret);\r\n}\r\n}\r\nmutex_unlock(&probe_lock);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int split_symbol_offset(char *symbol, unsigned long *offset)\r\n{\r\nchar *tmp;\r\nint ret;\r\nif (!offset)\r\nreturn -EINVAL;\r\ntmp = strchr(symbol, '+');\r\nif (tmp) {\r\nret = strict_strtoul(tmp + 1, 0, offset);\r\nif (ret)\r\nreturn ret;\r\n*tmp = '\0';\r\n} else\r\n*offset = 0;\r\nreturn 0;\r\n}\r\nstatic int parse_probe_vars(char *arg, const struct fetch_type *t,\r\nstruct fetch_param *f, int is_return)\r\n{\r\nint ret = 0;\r\nunsigned long param;\r\nif (strcmp(arg, "retval") == 0) {\r\nif (is_return)\r\nf->fn = t->fetch[FETCH_MTD_retval];\r\nelse\r\nret = -EINVAL;\r\n} else if (strncmp(arg, "stack", 5) == 0) {\r\nif (arg[5] == '\0') {\r\nif (strcmp(t->name, DEFAULT_FETCH_TYPE_STR) == 0)\r\nf->fn = fetch_stack_address;\r\nelse\r\nret = -EINVAL;\r\n} else if (isdigit(arg[5])) {\r\nret = strict_strtoul(arg + 5, 10, &param);\r\nif (ret || param > PARAM_MAX_STACK)\r\nret = -EINVAL;\r\nelse {\r\nf->fn = t->fetch[FETCH_MTD_stack];\r\nf->data = (void *)param;\r\n}\r\n} else\r\nret = -EINVAL;\r\n} else\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int __parse_probe_arg(char *arg, const struct fetch_type *t,\r\nstruct fetch_param *f, int is_return)\r\n{\r\nint ret = 0;\r\nunsigned long param;\r\nlong offset;\r\nchar *tmp;\r\nswitch (arg[0]) {\r\ncase '$':\r\nret = parse_probe_vars(arg + 1, t, f, is_return);\r\nbreak;\r\ncase '%':\r\nret = regs_query_register_offset(arg + 1);\r\nif (ret >= 0) {\r\nf->fn = t->fetch[FETCH_MTD_reg];\r\nf->data = (void *)(unsigned long)ret;\r\nret = 0;\r\n}\r\nbreak;\r\ncase '@':\r\nif (isdigit(arg[1])) {\r\nret = strict_strtoul(arg + 1, 0, &param);\r\nif (ret)\r\nbreak;\r\nf->fn = t->fetch[FETCH_MTD_memory];\r\nf->data = (void *)param;\r\n} else {\r\nret = split_symbol_offset(arg + 1, &offset);\r\nif (ret)\r\nbreak;\r\nf->data = alloc_symbol_cache(arg + 1, offset);\r\nif (f->data)\r\nf->fn = t->fetch[FETCH_MTD_symbol];\r\n}\r\nbreak;\r\ncase '+':\r\narg++;\r\ncase '-':\r\ntmp = strchr(arg, '(');\r\nif (!tmp)\r\nbreak;\r\n*tmp = '\0';\r\nret = strict_strtol(arg, 0, &offset);\r\nif (ret)\r\nbreak;\r\narg = tmp + 1;\r\ntmp = strrchr(arg, ')');\r\nif (tmp) {\r\nstruct deref_fetch_param *dprm;\r\nconst struct fetch_type *t2 = find_fetch_type(NULL);\r\n*tmp = '\0';\r\ndprm = kzalloc(sizeof(struct deref_fetch_param),\r\nGFP_KERNEL);\r\nif (!dprm)\r\nreturn -ENOMEM;\r\ndprm->offset = offset;\r\nret = __parse_probe_arg(arg, t2, &dprm->orig,\r\nis_return);\r\nif (ret)\r\nkfree(dprm);\r\nelse {\r\nf->fn = t->fetch[FETCH_MTD_deref];\r\nf->data = (void *)dprm;\r\n}\r\n}\r\nbreak;\r\n}\r\nif (!ret && !f->fn) {\r\npr_info("%s type has no corresponding fetch method.\n",\r\nt->name);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __parse_bitfield_probe_arg(const char *bf,\r\nconst struct fetch_type *t,\r\nstruct fetch_param *f)\r\n{\r\nstruct bitfield_fetch_param *bprm;\r\nunsigned long bw, bo;\r\nchar *tail;\r\nif (*bf != 'b')\r\nreturn 0;\r\nbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\r\nif (!bprm)\r\nreturn -ENOMEM;\r\nbprm->orig = *f;\r\nf->fn = t->fetch[FETCH_MTD_bitfield];\r\nf->data = (void *)bprm;\r\nbw = simple_strtoul(bf + 1, &tail, 0);\r\nif (bw == 0 || *tail != '@')\r\nreturn -EINVAL;\r\nbf = tail + 1;\r\nbo = simple_strtoul(bf, &tail, 0);\r\nif (tail == bf || *tail != '/')\r\nreturn -EINVAL;\r\nbprm->hi_shift = BYTES_TO_BITS(t->size) - (bw + bo);\r\nbprm->low_shift = bprm->hi_shift + bo;\r\nreturn (BYTES_TO_BITS(t->size) < (bw + bo)) ? -EINVAL : 0;\r\n}\r\nstatic int parse_probe_arg(char *arg, struct trace_probe *tp,\r\nstruct probe_arg *parg, int is_return)\r\n{\r\nconst char *t;\r\nint ret;\r\nif (strlen(arg) > MAX_ARGSTR_LEN) {\r\npr_info("Argument is too long.: %s\n", arg);\r\nreturn -ENOSPC;\r\n}\r\nparg->comm = kstrdup(arg, GFP_KERNEL);\r\nif (!parg->comm) {\r\npr_info("Failed to allocate memory for command '%s'.\n", arg);\r\nreturn -ENOMEM;\r\n}\r\nt = strchr(parg->comm, ':');\r\nif (t) {\r\narg[t - parg->comm] = '\0';\r\nt++;\r\n}\r\nparg->type = find_fetch_type(t);\r\nif (!parg->type) {\r\npr_info("Unsupported type: %s\n", t);\r\nreturn -EINVAL;\r\n}\r\nparg->offset = tp->size;\r\ntp->size += parg->type->size;\r\nret = __parse_probe_arg(arg, parg->type, &parg->fetch, is_return);\r\nif (ret >= 0 && t != NULL)\r\nret = __parse_bitfield_probe_arg(t, parg->type, &parg->fetch);\r\nif (ret >= 0) {\r\nparg->fetch_size.fn = get_fetch_size_function(parg->type,\r\nparg->fetch.fn);\r\nparg->fetch_size.data = parg->fetch.data;\r\n}\r\nreturn ret;\r\n}\r\nstatic int conflict_field_name(const char *name,\r\nstruct probe_arg *args, int narg)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(reserved_field_names); i++)\r\nif (strcmp(reserved_field_names[i], name) == 0)\r\nreturn 1;\r\nfor (i = 0; i < narg; i++)\r\nif (strcmp(args[i].name, name) == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int create_trace_probe(int argc, char **argv)\r\n{\r\nstruct trace_probe *tp;\r\nint i, ret = 0;\r\nint is_return = 0, is_delete = 0;\r\nchar *symbol = NULL, *event = NULL, *group = NULL;\r\nchar *arg;\r\nunsigned long offset = 0;\r\nvoid *addr = NULL;\r\nchar buf[MAX_EVENT_NAME_LEN];\r\nif (argv[0][0] == 'p')\r\nis_return = 0;\r\nelse if (argv[0][0] == 'r')\r\nis_return = 1;\r\nelse if (argv[0][0] == '-')\r\nis_delete = 1;\r\nelse {\r\npr_info("Probe definition must be started with 'p', 'r' or"\r\n" '-'.\n");\r\nreturn -EINVAL;\r\n}\r\nif (argv[0][1] == ':') {\r\nevent = &argv[0][2];\r\nif (strchr(event, '/')) {\r\ngroup = event;\r\nevent = strchr(group, '/') + 1;\r\nevent[-1] = '\0';\r\nif (strlen(group) == 0) {\r\npr_info("Group name is not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (strlen(event) == 0) {\r\npr_info("Event name is not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!group)\r\ngroup = KPROBE_EVENT_SYSTEM;\r\nif (is_delete) {\r\nif (!event) {\r\npr_info("Delete command needs an event name.\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&probe_lock);\r\ntp = find_trace_probe(event, group);\r\nif (!tp) {\r\nmutex_unlock(&probe_lock);\r\npr_info("Event %s/%s doesn't exist.\n", group, event);\r\nreturn -ENOENT;\r\n}\r\nret = unregister_trace_probe(tp);\r\nif (ret == 0)\r\nfree_trace_probe(tp);\r\nmutex_unlock(&probe_lock);\r\nreturn ret;\r\n}\r\nif (argc < 2) {\r\npr_info("Probe point is not specified.\n");\r\nreturn -EINVAL;\r\n}\r\nif (isdigit(argv[1][0])) {\r\nif (is_return) {\r\npr_info("Return probe point must be a symbol.\n");\r\nreturn -EINVAL;\r\n}\r\nret = strict_strtoul(&argv[1][0], 0, (unsigned long *)&addr);\r\nif (ret) {\r\npr_info("Failed to parse address.\n");\r\nreturn ret;\r\n}\r\n} else {\r\nsymbol = argv[1];\r\nret = split_symbol_offset(symbol, &offset);\r\nif (ret) {\r\npr_info("Failed to parse symbol.\n");\r\nreturn ret;\r\n}\r\nif (offset && is_return) {\r\npr_info("Return probe must be used without offset.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nargc -= 2; argv += 2;\r\nif (!event) {\r\nif (symbol)\r\nsnprintf(buf, MAX_EVENT_NAME_LEN, "%c_%s_%ld",\r\nis_return ? 'r' : 'p', symbol, offset);\r\nelse\r\nsnprintf(buf, MAX_EVENT_NAME_LEN, "%c_0x%p",\r\nis_return ? 'r' : 'p', addr);\r\nevent = buf;\r\n}\r\ntp = alloc_trace_probe(group, event, addr, symbol, offset, argc,\r\nis_return);\r\nif (IS_ERR(tp)) {\r\npr_info("Failed to allocate trace_probe.(%d)\n",\r\n(int)PTR_ERR(tp));\r\nreturn PTR_ERR(tp);\r\n}\r\nret = 0;\r\nfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\r\ntp->nr_args++;\r\narg = strchr(argv[i], '=');\r\nif (arg) {\r\n*arg++ = '\0';\r\ntp->args[i].name = kstrdup(argv[i], GFP_KERNEL);\r\n} else {\r\narg = argv[i];\r\nsnprintf(buf, MAX_EVENT_NAME_LEN, "arg%d", i + 1);\r\ntp->args[i].name = kstrdup(buf, GFP_KERNEL);\r\n}\r\nif (!tp->args[i].name) {\r\npr_info("Failed to allocate argument[%d] name.\n", i);\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (!is_good_name(tp->args[i].name)) {\r\npr_info("Invalid argument[%d] name: %s\n",\r\ni, tp->args[i].name);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (conflict_field_name(tp->args[i].name, tp->args, i)) {\r\npr_info("Argument[%d] name '%s' conflicts with "\r\n"another field.\n", i, argv[i]);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = parse_probe_arg(arg, tp, &tp->args[i], is_return);\r\nif (ret) {\r\npr_info("Parse error at argument[%d]. (%d)\n", i, ret);\r\ngoto error;\r\n}\r\n}\r\nret = register_trace_probe(tp);\r\nif (ret)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nfree_trace_probe(tp);\r\nreturn ret;\r\n}\r\nstatic int release_all_trace_probes(void)\r\n{\r\nstruct trace_probe *tp;\r\nint ret = 0;\r\nmutex_lock(&probe_lock);\r\nlist_for_each_entry(tp, &probe_list, list)\r\nif (trace_probe_is_enabled(tp)) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nwhile (!list_empty(&probe_list)) {\r\ntp = list_entry(probe_list.next, struct trace_probe, list);\r\nunregister_trace_probe(tp);\r\nfree_trace_probe(tp);\r\n}\r\nend:\r\nmutex_unlock(&probe_lock);\r\nreturn ret;\r\n}\r\nstatic void *probes_seq_start(struct seq_file *m, loff_t *pos)\r\n{\r\nmutex_lock(&probe_lock);\r\nreturn seq_list_start(&probe_list, *pos);\r\n}\r\nstatic void *probes_seq_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nreturn seq_list_next(v, &probe_list, pos);\r\n}\r\nstatic void probes_seq_stop(struct seq_file *m, void *v)\r\n{\r\nmutex_unlock(&probe_lock);\r\n}\r\nstatic int probes_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct trace_probe *tp = v;\r\nint i;\r\nseq_printf(m, "%c", trace_probe_is_return(tp) ? 'r' : 'p');\r\nseq_printf(m, ":%s/%s", tp->call.class->system, tp->call.name);\r\nif (!tp->symbol)\r\nseq_printf(m, " 0x%p", tp->rp.kp.addr);\r\nelse if (tp->rp.kp.offset)\r\nseq_printf(m, " %s+%u", trace_probe_symbol(tp),\r\ntp->rp.kp.offset);\r\nelse\r\nseq_printf(m, " %s", trace_probe_symbol(tp));\r\nfor (i = 0; i < tp->nr_args; i++)\r\nseq_printf(m, " %s=%s", tp->args[i].name, tp->args[i].comm);\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nstatic int probes_open(struct inode *inode, struct file *file)\r\n{\r\nint ret;\r\nif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\r\nret = release_all_trace_probes();\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn seq_open(file, &probes_seq_op);\r\n}\r\nstatic int command_trace_probe(const char *buf)\r\n{\r\nchar **argv;\r\nint argc = 0, ret = 0;\r\nargv = argv_split(GFP_KERNEL, buf, &argc);\r\nif (!argv)\r\nreturn -ENOMEM;\r\nif (argc)\r\nret = create_trace_probe(argc, argv);\r\nargv_free(argv);\r\nreturn ret;\r\n}\r\nstatic ssize_t probes_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *kbuf, *tmp;\r\nint ret;\r\nsize_t done;\r\nsize_t size;\r\nkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\r\nif (!kbuf)\r\nreturn -ENOMEM;\r\nret = done = 0;\r\nwhile (done < count) {\r\nsize = count - done;\r\nif (size >= WRITE_BUFSIZE)\r\nsize = WRITE_BUFSIZE - 1;\r\nif (copy_from_user(kbuf, buffer + done, size)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nkbuf[size] = '\0';\r\ntmp = strchr(kbuf, '\n');\r\nif (tmp) {\r\n*tmp = '\0';\r\nsize = tmp - kbuf + 1;\r\n} else if (done + size < count) {\r\npr_warning("Line length is too long: "\r\n"Should be less than %d.", WRITE_BUFSIZE);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ndone += size;\r\ntmp = strchr(kbuf, '#');\r\nif (tmp)\r\n*tmp = '\0';\r\nret = command_trace_probe(kbuf);\r\nif (ret)\r\ngoto out;\r\n}\r\nret = done;\r\nout:\r\nkfree(kbuf);\r\nreturn ret;\r\n}\r\nstatic int probes_profile_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct trace_probe *tp = v;\r\nseq_printf(m, " %-44s %15lu %15lu\n", tp->call.name, tp->nhit,\r\ntp->rp.kp.nmissed);\r\nreturn 0;\r\n}\r\nstatic int profile_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &profile_seq_op);\r\n}\r\nstatic __kprobes int __get_data_size(struct trace_probe *tp,\r\nstruct pt_regs *regs)\r\n{\r\nint i, ret = 0;\r\nu32 len;\r\nfor (i = 0; i < tp->nr_args; i++)\r\nif (unlikely(tp->args[i].fetch_size.fn)) {\r\ncall_fetch(&tp->args[i].fetch_size, regs, &len);\r\nret += len;\r\n}\r\nreturn ret;\r\n}\r\nstatic __kprobes void store_trace_args(int ent_size, struct trace_probe *tp,\r\nstruct pt_regs *regs,\r\nu8 *data, int maxlen)\r\n{\r\nint i;\r\nu32 end = tp->size;\r\nu32 *dl;\r\nfor (i = 0; i < tp->nr_args; i++) {\r\nif (unlikely(tp->args[i].fetch_size.fn)) {\r\ndl = (u32 *)(data + tp->args[i].offset);\r\n*dl = make_data_rloc(maxlen, end - tp->args[i].offset);\r\ncall_fetch(&tp->args[i].fetch, regs, dl);\r\nend += get_rloc_len(*dl);\r\nmaxlen -= get_rloc_len(*dl);\r\n*dl = convert_rloc_to_loc(*dl,\r\nent_size + tp->args[i].offset);\r\n} else\r\ncall_fetch(&tp->args[i].fetch, regs,\r\ndata + tp->args[i].offset);\r\n}\r\n}\r\nstatic __kprobes void kprobe_trace_func(struct kprobe *kp, struct pt_regs *regs)\r\n{\r\nstruct trace_probe *tp = container_of(kp, struct trace_probe, rp.kp);\r\nstruct kprobe_trace_entry_head *entry;\r\nstruct ring_buffer_event *event;\r\nstruct ring_buffer *buffer;\r\nint size, dsize, pc;\r\nunsigned long irq_flags;\r\nstruct ftrace_event_call *call = &tp->call;\r\ntp->nhit++;\r\nlocal_save_flags(irq_flags);\r\npc = preempt_count();\r\ndsize = __get_data_size(tp, regs);\r\nsize = sizeof(*entry) + tp->size + dsize;\r\nevent = trace_current_buffer_lock_reserve(&buffer, call->event.type,\r\nsize, irq_flags, pc);\r\nif (!event)\r\nreturn;\r\nentry = ring_buffer_event_data(event);\r\nentry->ip = (unsigned long)kp->addr;\r\nstore_trace_args(sizeof(*entry), tp, regs, (u8 *)&entry[1], dsize);\r\nif (!filter_current_check_discard(buffer, call, entry, event))\r\ntrace_nowake_buffer_unlock_commit_regs(buffer, event,\r\nirq_flags, pc, regs);\r\n}\r\nstatic __kprobes void kretprobe_trace_func(struct kretprobe_instance *ri,\r\nstruct pt_regs *regs)\r\n{\r\nstruct trace_probe *tp = container_of(ri->rp, struct trace_probe, rp);\r\nstruct kretprobe_trace_entry_head *entry;\r\nstruct ring_buffer_event *event;\r\nstruct ring_buffer *buffer;\r\nint size, pc, dsize;\r\nunsigned long irq_flags;\r\nstruct ftrace_event_call *call = &tp->call;\r\nlocal_save_flags(irq_flags);\r\npc = preempt_count();\r\ndsize = __get_data_size(tp, regs);\r\nsize = sizeof(*entry) + tp->size + dsize;\r\nevent = trace_current_buffer_lock_reserve(&buffer, call->event.type,\r\nsize, irq_flags, pc);\r\nif (!event)\r\nreturn;\r\nentry = ring_buffer_event_data(event);\r\nentry->func = (unsigned long)tp->rp.kp.addr;\r\nentry->ret_ip = (unsigned long)ri->ret_addr;\r\nstore_trace_args(sizeof(*entry), tp, regs, (u8 *)&entry[1], dsize);\r\nif (!filter_current_check_discard(buffer, call, entry, event))\r\ntrace_nowake_buffer_unlock_commit_regs(buffer, event,\r\nirq_flags, pc, regs);\r\n}\r\nenum print_line_t\r\nprint_kprobe_event(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nstruct kprobe_trace_entry_head *field;\r\nstruct trace_seq *s = &iter->seq;\r\nstruct trace_probe *tp;\r\nu8 *data;\r\nint i;\r\nfield = (struct kprobe_trace_entry_head *)iter->ent;\r\ntp = container_of(event, struct trace_probe, call.event);\r\nif (!trace_seq_printf(s, "%s: (", tp->call.name))\r\ngoto partial;\r\nif (!seq_print_ip_sym(s, field->ip, flags | TRACE_ITER_SYM_OFFSET))\r\ngoto partial;\r\nif (!trace_seq_puts(s, ")"))\r\ngoto partial;\r\ndata = (u8 *)&field[1];\r\nfor (i = 0; i < tp->nr_args; i++)\r\nif (!tp->args[i].type->print(s, tp->args[i].name,\r\ndata + tp->args[i].offset, field))\r\ngoto partial;\r\nif (!trace_seq_puts(s, "\n"))\r\ngoto partial;\r\nreturn TRACE_TYPE_HANDLED;\r\npartial:\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nenum print_line_t\r\nprint_kretprobe_event(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nstruct kretprobe_trace_entry_head *field;\r\nstruct trace_seq *s = &iter->seq;\r\nstruct trace_probe *tp;\r\nu8 *data;\r\nint i;\r\nfield = (struct kretprobe_trace_entry_head *)iter->ent;\r\ntp = container_of(event, struct trace_probe, call.event);\r\nif (!trace_seq_printf(s, "%s: (", tp->call.name))\r\ngoto partial;\r\nif (!seq_print_ip_sym(s, field->ret_ip, flags | TRACE_ITER_SYM_OFFSET))\r\ngoto partial;\r\nif (!trace_seq_puts(s, " <- "))\r\ngoto partial;\r\nif (!seq_print_ip_sym(s, field->func, flags & ~TRACE_ITER_SYM_OFFSET))\r\ngoto partial;\r\nif (!trace_seq_puts(s, ")"))\r\ngoto partial;\r\ndata = (u8 *)&field[1];\r\nfor (i = 0; i < tp->nr_args; i++)\r\nif (!tp->args[i].type->print(s, tp->args[i].name,\r\ndata + tp->args[i].offset, field))\r\ngoto partial;\r\nif (!trace_seq_puts(s, "\n"))\r\ngoto partial;\r\nreturn TRACE_TYPE_HANDLED;\r\npartial:\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nstatic int kprobe_event_define_fields(struct ftrace_event_call *event_call)\r\n{\r\nint ret, i;\r\nstruct kprobe_trace_entry_head field;\r\nstruct trace_probe *tp = (struct trace_probe *)event_call->data;\r\nDEFINE_FIELD(unsigned long, ip, FIELD_STRING_IP, 0);\r\nfor (i = 0; i < tp->nr_args; i++) {\r\nret = trace_define_field(event_call, tp->args[i].type->fmttype,\r\ntp->args[i].name,\r\nsizeof(field) + tp->args[i].offset,\r\ntp->args[i].type->size,\r\ntp->args[i].type->is_signed,\r\nFILTER_OTHER);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kretprobe_event_define_fields(struct ftrace_event_call *event_call)\r\n{\r\nint ret, i;\r\nstruct kretprobe_trace_entry_head field;\r\nstruct trace_probe *tp = (struct trace_probe *)event_call->data;\r\nDEFINE_FIELD(unsigned long, func, FIELD_STRING_FUNC, 0);\r\nDEFINE_FIELD(unsigned long, ret_ip, FIELD_STRING_RETIP, 0);\r\nfor (i = 0; i < tp->nr_args; i++) {\r\nret = trace_define_field(event_call, tp->args[i].type->fmttype,\r\ntp->args[i].name,\r\nsizeof(field) + tp->args[i].offset,\r\ntp->args[i].type->size,\r\ntp->args[i].type->is_signed,\r\nFILTER_OTHER);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __set_print_fmt(struct trace_probe *tp, char *buf, int len)\r\n{\r\nint i;\r\nint pos = 0;\r\nconst char *fmt, *arg;\r\nif (!trace_probe_is_return(tp)) {\r\nfmt = "(%lx)";\r\narg = "REC->" FIELD_STRING_IP;\r\n} else {\r\nfmt = "(%lx <- %lx)";\r\narg = "REC->" FIELD_STRING_FUNC ", REC->" FIELD_STRING_RETIP;\r\n}\r\n#define LEN_OR_ZERO (len ? len - pos : 0)\r\npos += snprintf(buf + pos, LEN_OR_ZERO, "\"%s", fmt);\r\nfor (i = 0; i < tp->nr_args; i++) {\r\npos += snprintf(buf + pos, LEN_OR_ZERO, " %s=%s",\r\ntp->args[i].name, tp->args[i].type->fmt);\r\n}\r\npos += snprintf(buf + pos, LEN_OR_ZERO, "\", %s", arg);\r\nfor (i = 0; i < tp->nr_args; i++) {\r\nif (strcmp(tp->args[i].type->name, "string") == 0)\r\npos += snprintf(buf + pos, LEN_OR_ZERO,\r\n", __get_str(%s)",\r\ntp->args[i].name);\r\nelse\r\npos += snprintf(buf + pos, LEN_OR_ZERO, ", REC->%s",\r\ntp->args[i].name);\r\n}\r\n#undef LEN_OR_ZERO\r\nreturn pos;\r\n}\r\nstatic int set_print_fmt(struct trace_probe *tp)\r\n{\r\nint len;\r\nchar *print_fmt;\r\nlen = __set_print_fmt(tp, NULL, 0);\r\nprint_fmt = kmalloc(len + 1, GFP_KERNEL);\r\nif (!print_fmt)\r\nreturn -ENOMEM;\r\n__set_print_fmt(tp, print_fmt, len + 1);\r\ntp->call.print_fmt = print_fmt;\r\nreturn 0;\r\n}\r\nstatic __kprobes void kprobe_perf_func(struct kprobe *kp,\r\nstruct pt_regs *regs)\r\n{\r\nstruct trace_probe *tp = container_of(kp, struct trace_probe, rp.kp);\r\nstruct ftrace_event_call *call = &tp->call;\r\nstruct kprobe_trace_entry_head *entry;\r\nstruct hlist_head *head;\r\nint size, __size, dsize;\r\nint rctx;\r\ndsize = __get_data_size(tp, regs);\r\n__size = sizeof(*entry) + tp->size + dsize;\r\nsize = ALIGN(__size + sizeof(u32), sizeof(u64));\r\nsize -= sizeof(u32);\r\nif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\r\n"profile buffer not large enough"))\r\nreturn;\r\nentry = perf_trace_buf_prepare(size, call->event.type, regs, &rctx);\r\nif (!entry)\r\nreturn;\r\nentry->ip = (unsigned long)kp->addr;\r\nmemset(&entry[1], 0, dsize);\r\nstore_trace_args(sizeof(*entry), tp, regs, (u8 *)&entry[1], dsize);\r\nhead = this_cpu_ptr(call->perf_events);\r\nperf_trace_buf_submit(entry, size, rctx, entry->ip, 1, regs, head);\r\n}\r\nstatic __kprobes void kretprobe_perf_func(struct kretprobe_instance *ri,\r\nstruct pt_regs *regs)\r\n{\r\nstruct trace_probe *tp = container_of(ri->rp, struct trace_probe, rp);\r\nstruct ftrace_event_call *call = &tp->call;\r\nstruct kretprobe_trace_entry_head *entry;\r\nstruct hlist_head *head;\r\nint size, __size, dsize;\r\nint rctx;\r\ndsize = __get_data_size(tp, regs);\r\n__size = sizeof(*entry) + tp->size + dsize;\r\nsize = ALIGN(__size + sizeof(u32), sizeof(u64));\r\nsize -= sizeof(u32);\r\nif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\r\n"profile buffer not large enough"))\r\nreturn;\r\nentry = perf_trace_buf_prepare(size, call->event.type, regs, &rctx);\r\nif (!entry)\r\nreturn;\r\nentry->func = (unsigned long)tp->rp.kp.addr;\r\nentry->ret_ip = (unsigned long)ri->ret_addr;\r\nstore_trace_args(sizeof(*entry), tp, regs, (u8 *)&entry[1], dsize);\r\nhead = this_cpu_ptr(call->perf_events);\r\nperf_trace_buf_submit(entry, size, rctx, entry->ret_ip, 1, regs, head);\r\n}\r\nstatic __kprobes\r\nint kprobe_register(struct ftrace_event_call *event, enum trace_reg type)\r\n{\r\nstruct trace_probe *tp = (struct trace_probe *)event->data;\r\nswitch (type) {\r\ncase TRACE_REG_REGISTER:\r\nreturn enable_trace_probe(tp, TP_FLAG_TRACE);\r\ncase TRACE_REG_UNREGISTER:\r\ndisable_trace_probe(tp, TP_FLAG_TRACE);\r\nreturn 0;\r\n#ifdef CONFIG_PERF_EVENTS\r\ncase TRACE_REG_PERF_REGISTER:\r\nreturn enable_trace_probe(tp, TP_FLAG_PROFILE);\r\ncase TRACE_REG_PERF_UNREGISTER:\r\ndisable_trace_probe(tp, TP_FLAG_PROFILE);\r\nreturn 0;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic __kprobes\r\nint kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs)\r\n{\r\nstruct trace_probe *tp = container_of(kp, struct trace_probe, rp.kp);\r\nif (tp->flags & TP_FLAG_TRACE)\r\nkprobe_trace_func(kp, regs);\r\n#ifdef CONFIG_PERF_EVENTS\r\nif (tp->flags & TP_FLAG_PROFILE)\r\nkprobe_perf_func(kp, regs);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic __kprobes\r\nint kretprobe_dispatcher(struct kretprobe_instance *ri, struct pt_regs *regs)\r\n{\r\nstruct trace_probe *tp = container_of(ri->rp, struct trace_probe, rp);\r\nif (tp->flags & TP_FLAG_TRACE)\r\nkretprobe_trace_func(ri, regs);\r\n#ifdef CONFIG_PERF_EVENTS\r\nif (tp->flags & TP_FLAG_PROFILE)\r\nkretprobe_perf_func(ri, regs);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int register_probe_event(struct trace_probe *tp)\r\n{\r\nstruct ftrace_event_call *call = &tp->call;\r\nint ret;\r\nINIT_LIST_HEAD(&call->class->fields);\r\nif (trace_probe_is_return(tp)) {\r\ncall->event.funcs = &kretprobe_funcs;\r\ncall->class->define_fields = kretprobe_event_define_fields;\r\n} else {\r\ncall->event.funcs = &kprobe_funcs;\r\ncall->class->define_fields = kprobe_event_define_fields;\r\n}\r\nif (set_print_fmt(tp) < 0)\r\nreturn -ENOMEM;\r\nret = register_ftrace_event(&call->event);\r\nif (!ret) {\r\nkfree(call->print_fmt);\r\nreturn -ENODEV;\r\n}\r\ncall->flags = 0;\r\ncall->class->reg = kprobe_register;\r\ncall->data = tp;\r\nret = trace_add_event_call(call);\r\nif (ret) {\r\npr_info("Failed to register kprobe event: %s\n", call->name);\r\nkfree(call->print_fmt);\r\nunregister_ftrace_event(&call->event);\r\n}\r\nreturn ret;\r\n}\r\nstatic void unregister_probe_event(struct trace_probe *tp)\r\n{\r\ntrace_remove_event_call(&tp->call);\r\nkfree(tp->call.print_fmt);\r\n}\r\nstatic __init int init_kprobe_trace(void)\r\n{\r\nstruct dentry *d_tracer;\r\nstruct dentry *entry;\r\nif (register_module_notifier(&trace_probe_module_nb))\r\nreturn -EINVAL;\r\nd_tracer = tracing_init_dentry();\r\nif (!d_tracer)\r\nreturn 0;\r\nentry = debugfs_create_file("kprobe_events", 0644, d_tracer,\r\nNULL, &kprobe_events_ops);\r\nif (!entry)\r\npr_warning("Could not create debugfs "\r\n"'kprobe_events' entry\n");\r\nentry = debugfs_create_file("kprobe_profile", 0444, d_tracer,\r\nNULL, &kprobe_profile_ops);\r\nif (!entry)\r\npr_warning("Could not create debugfs "\r\n"'kprobe_profile' entry\n");\r\nreturn 0;\r\n}\r\nstatic __used int kprobe_trace_selftest_target(int a1, int a2, int a3,\r\nint a4, int a5, int a6)\r\n{\r\nreturn a1 + a2 + a3 + a4 + a5 + a6;\r\n}\r\nstatic __init int kprobe_trace_self_tests_init(void)\r\n{\r\nint ret, warn = 0;\r\nint (*target)(int, int, int, int, int, int);\r\nstruct trace_probe *tp;\r\ntarget = kprobe_trace_selftest_target;\r\npr_info("Testing kprobe tracing: ");\r\nret = command_trace_probe("p:testprobe kprobe_trace_selftest_target "\r\n"$stack $stack0 +0($stack)");\r\nif (WARN_ON_ONCE(ret)) {\r\npr_warning("error on probing function entry.\n");\r\nwarn++;\r\n} else {\r\ntp = find_trace_probe("testprobe", KPROBE_EVENT_SYSTEM);\r\nif (WARN_ON_ONCE(tp == NULL)) {\r\npr_warning("error on getting new probe.\n");\r\nwarn++;\r\n} else\r\nenable_trace_probe(tp, TP_FLAG_TRACE);\r\n}\r\nret = command_trace_probe("r:testprobe2 kprobe_trace_selftest_target "\r\n"$retval");\r\nif (WARN_ON_ONCE(ret)) {\r\npr_warning("error on probing function return.\n");\r\nwarn++;\r\n} else {\r\ntp = find_trace_probe("testprobe2", KPROBE_EVENT_SYSTEM);\r\nif (WARN_ON_ONCE(tp == NULL)) {\r\npr_warning("error on getting new probe.\n");\r\nwarn++;\r\n} else\r\nenable_trace_probe(tp, TP_FLAG_TRACE);\r\n}\r\nif (warn)\r\ngoto end;\r\nret = target(1, 2, 3, 4, 5, 6);\r\ntp = find_trace_probe("testprobe", KPROBE_EVENT_SYSTEM);\r\nif (WARN_ON_ONCE(tp == NULL)) {\r\npr_warning("error on getting test probe.\n");\r\nwarn++;\r\n} else\r\ndisable_trace_probe(tp, TP_FLAG_TRACE);\r\ntp = find_trace_probe("testprobe2", KPROBE_EVENT_SYSTEM);\r\nif (WARN_ON_ONCE(tp == NULL)) {\r\npr_warning("error on getting 2nd test probe.\n");\r\nwarn++;\r\n} else\r\ndisable_trace_probe(tp, TP_FLAG_TRACE);\r\nret = command_trace_probe("-:testprobe");\r\nif (WARN_ON_ONCE(ret)) {\r\npr_warning("error on deleting a probe.\n");\r\nwarn++;\r\n}\r\nret = command_trace_probe("-:testprobe2");\r\nif (WARN_ON_ONCE(ret)) {\r\npr_warning("error on deleting a probe.\n");\r\nwarn++;\r\n}\r\nend:\r\nrelease_all_trace_probes();\r\nif (warn)\r\npr_cont("NG: Some tests are failed. Please check them.\n");\r\nelse\r\npr_cont("OK\n");\r\nreturn 0;\r\n}
