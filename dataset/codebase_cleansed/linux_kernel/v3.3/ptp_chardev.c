int ptp_open(struct posix_clock *pc, fmode_t fmode)\r\n{\r\nreturn 0;\r\n}\r\nlong ptp_ioctl(struct posix_clock *pc, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct ptp_clock_caps caps;\r\nstruct ptp_clock_request req;\r\nstruct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);\r\nstruct ptp_clock_info *ops = ptp->info;\r\nint enable, err = 0;\r\nswitch (cmd) {\r\ncase PTP_CLOCK_GETCAPS:\r\nmemset(&caps, 0, sizeof(caps));\r\ncaps.max_adj = ptp->info->max_adj;\r\ncaps.n_alarm = ptp->info->n_alarm;\r\ncaps.n_ext_ts = ptp->info->n_ext_ts;\r\ncaps.n_per_out = ptp->info->n_per_out;\r\ncaps.pps = ptp->info->pps;\r\nif (copy_to_user((void __user *)arg, &caps, sizeof(caps)))\r\nerr = -EFAULT;\r\nbreak;\r\ncase PTP_EXTTS_REQUEST:\r\nif (copy_from_user(&req.extts, (void __user *)arg,\r\nsizeof(req.extts))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (req.extts.index >= ops->n_ext_ts) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreq.type = PTP_CLK_REQ_EXTTS;\r\nenable = req.extts.flags & PTP_ENABLE_FEATURE ? 1 : 0;\r\nerr = ops->enable(ops, &req, enable);\r\nbreak;\r\ncase PTP_PEROUT_REQUEST:\r\nif (copy_from_user(&req.perout, (void __user *)arg,\r\nsizeof(req.perout))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (req.perout.index >= ops->n_per_out) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreq.type = PTP_CLK_REQ_PEROUT;\r\nenable = req.perout.period.sec || req.perout.period.nsec;\r\nerr = ops->enable(ops, &req, enable);\r\nbreak;\r\ncase PTP_ENABLE_PPS:\r\nif (!capable(CAP_SYS_TIME))\r\nreturn -EPERM;\r\nreq.type = PTP_CLK_REQ_PPS;\r\nenable = arg ? 1 : 0;\r\nerr = ops->enable(ops, &req, enable);\r\nbreak;\r\ndefault:\r\nerr = -ENOTTY;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nunsigned int ptp_poll(struct posix_clock *pc, struct file *fp, poll_table *wait)\r\n{\r\nstruct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);\r\npoll_wait(fp, &ptp->tsev_wq, wait);\r\nreturn queue_cnt(&ptp->tsevq) ? POLLIN : 0;\r\n}\r\nssize_t ptp_read(struct posix_clock *pc,\r\nuint rdflags, char __user *buf, size_t cnt)\r\n{\r\nstruct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);\r\nstruct timestamp_event_queue *queue = &ptp->tsevq;\r\nstruct ptp_extts_event event[PTP_BUF_TIMESTAMPS];\r\nunsigned long flags;\r\nsize_t qcnt, i;\r\nif (cnt % sizeof(struct ptp_extts_event) != 0)\r\nreturn -EINVAL;\r\nif (cnt > sizeof(event))\r\ncnt = sizeof(event);\r\ncnt = cnt / sizeof(struct ptp_extts_event);\r\nif (mutex_lock_interruptible(&ptp->tsevq_mux))\r\nreturn -ERESTARTSYS;\r\nif (wait_event_interruptible(ptp->tsev_wq,\r\nptp->defunct || queue_cnt(queue))) {\r\nmutex_unlock(&ptp->tsevq_mux);\r\nreturn -ERESTARTSYS;\r\n}\r\nif (ptp->defunct) {\r\nmutex_unlock(&ptp->tsevq_mux);\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irqsave(&queue->lock, flags);\r\nqcnt = queue_cnt(queue);\r\nif (cnt > qcnt)\r\ncnt = qcnt;\r\nfor (i = 0; i < cnt; i++) {\r\nevent[i] = queue->buf[queue->head];\r\nqueue->head = (queue->head + 1) % PTP_MAX_TIMESTAMPS;\r\n}\r\nspin_unlock_irqrestore(&queue->lock, flags);\r\ncnt = cnt * sizeof(struct ptp_extts_event);\r\nmutex_unlock(&ptp->tsevq_mux);\r\nif (copy_to_user(buf, event, cnt))\r\nreturn -EFAULT;\r\nreturn cnt;\r\n}
