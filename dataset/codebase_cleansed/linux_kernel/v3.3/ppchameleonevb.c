static void ppchameleon_hwcontrol(struct mtd_info *mtdinfo, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\n#error Missing headerfiles. No way to fix this. -tglx\r\nswitch (cmd) {\r\ncase NAND_CTL_SETCLE:\r\nMACRO_NAND_CTL_SETCLE((unsigned long)CFG_NAND0_PADDR);\r\nbreak;\r\ncase NAND_CTL_CLRCLE:\r\nMACRO_NAND_CTL_CLRCLE((unsigned long)CFG_NAND0_PADDR);\r\nbreak;\r\ncase NAND_CTL_SETALE:\r\nMACRO_NAND_CTL_SETALE((unsigned long)CFG_NAND0_PADDR);\r\nbreak;\r\ncase NAND_CTL_CLRALE:\r\nMACRO_NAND_CTL_CLRALE((unsigned long)CFG_NAND0_PADDR);\r\nbreak;\r\ncase NAND_CTL_SETNCE:\r\nMACRO_NAND_ENABLE_CE((unsigned long)CFG_NAND0_PADDR);\r\nbreak;\r\ncase NAND_CTL_CLRNCE:\r\nMACRO_NAND_DISABLE_CE((unsigned long)CFG_NAND0_PADDR);\r\nbreak;\r\n}\r\n}\r\nif (cmd != NAND_CMD_NONE)\r\nwriteb(cmd, chip->IO_ADDR_W);\r\n}\r\nstatic void ppchameleonevb_hwcontrol(struct mtd_info *mtdinfo, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\n#error Missing headerfiles. No way to fix this. -tglx\r\nswitch (cmd) {\r\ncase NAND_CTL_SETCLE:\r\nMACRO_NAND_CTL_SETCLE((unsigned long)CFG_NAND1_PADDR);\r\nbreak;\r\ncase NAND_CTL_CLRCLE:\r\nMACRO_NAND_CTL_CLRCLE((unsigned long)CFG_NAND1_PADDR);\r\nbreak;\r\ncase NAND_CTL_SETALE:\r\nMACRO_NAND_CTL_SETALE((unsigned long)CFG_NAND1_PADDR);\r\nbreak;\r\ncase NAND_CTL_CLRALE:\r\nMACRO_NAND_CTL_CLRALE((unsigned long)CFG_NAND1_PADDR);\r\nbreak;\r\ncase NAND_CTL_SETNCE:\r\nMACRO_NAND_ENABLE_CE((unsigned long)CFG_NAND1_PADDR);\r\nbreak;\r\ncase NAND_CTL_CLRNCE:\r\nMACRO_NAND_DISABLE_CE((unsigned long)CFG_NAND1_PADDR);\r\nbreak;\r\n}\r\n}\r\nif (cmd != NAND_CMD_NONE)\r\nwriteb(cmd, chip->IO_ADDR_W);\r\n}\r\nstatic int ppchameleon_device_ready(struct mtd_info *minfo)\r\n{\r\nif (in_be32((volatile unsigned *)GPIO0_IR) & NAND_RB_GPIO_PIN)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ppchameleonevb_device_ready(struct mtd_info *minfo)\r\n{\r\nif (in_be32((volatile unsigned *)GPIO0_IR) & NAND_EVB_RB_GPIO_PIN)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __init ppchameleonevb_init(void)\r\n{\r\nstruct nand_chip *this;\r\nvoid __iomem *ppchameleon_fio_base;\r\nvoid __iomem *ppchameleonevb_fio_base;\r\nppchameleon_mtd = kmalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip), GFP_KERNEL);\r\nif (!ppchameleon_mtd) {\r\nprintk("Unable to allocate PPChameleon NAND MTD device structure.\n");\r\nreturn -ENOMEM;\r\n}\r\nppchameleon_fio_base = ioremap(ppchameleon_fio_pbase, SZ_4M);\r\nif (!ppchameleon_fio_base) {\r\nprintk("ioremap PPChameleon NAND flash failed\n");\r\nkfree(ppchameleon_mtd);\r\nreturn -EIO;\r\n}\r\nthis = (struct nand_chip *)(&ppchameleon_mtd[1]);\r\nmemset(ppchameleon_mtd, 0, sizeof(struct mtd_info));\r\nmemset(this, 0, sizeof(struct nand_chip));\r\nppchameleon_mtd->priv = this;\r\nppchameleon_mtd->owner = THIS_MODULE;\r\nout_be32((volatile unsigned *)GPIO0_OSRH, in_be32((volatile unsigned *)GPIO0_OSRH) & 0xC0FFFFFF);\r\nout_be32((volatile unsigned *)GPIO0_TSRH, in_be32((volatile unsigned *)GPIO0_TSRH) & 0xC0FFFFFF);\r\nout_be32((volatile unsigned *)GPIO0_TCR,\r\nin_be32((volatile unsigned *)GPIO0_TCR) | NAND_nCE_GPIO_PIN | NAND_CLE_GPIO_PIN | NAND_ALE_GPIO_PIN);\r\n#ifdef USE_READY_BUSY_PIN\r\nout_be32((volatile unsigned *)GPIO0_TSRH, in_be32((volatile unsigned *)GPIO0_TSRH) & 0xFF3FFFFF);\r\nout_be32((volatile unsigned *)GPIO0_TCR, in_be32((volatile unsigned *)GPIO0_TCR) & (~NAND_RB_GPIO_PIN));\r\nout_be32((volatile unsigned *)GPIO0_ISR1H,\r\n(in_be32((volatile unsigned *)GPIO0_ISR1H) & 0xFF3FFFFF) | 0x00400000);\r\n#endif\r\nthis->IO_ADDR_R = ppchameleon_fio_base;\r\nthis->IO_ADDR_W = ppchameleon_fio_base;\r\nthis->cmd_ctrl = ppchameleon_hwcontrol;\r\n#ifdef USE_READY_BUSY_PIN\r\nthis->dev_ready = ppchameleon_device_ready;\r\n#endif\r\nthis->chip_delay = NAND_BIG_DELAY_US;\r\nthis->ecc.mode = NAND_ECC_SOFT;\r\nif (nand_scan(ppchameleon_mtd, 1)) {\r\niounmap((void *)ppchameleon_fio_base);\r\nppchameleon_fio_base = NULL;\r\nkfree(ppchameleon_mtd);\r\ngoto nand_evb_init;\r\n}\r\n#ifndef USE_READY_BUSY_PIN\r\nif (ppchameleon_mtd->size == NAND_SMALL_SIZE)\r\nthis->chip_delay = NAND_SMALL_DELAY_US;\r\n#endif\r\nppchameleon_mtd->name = "ppchameleon-nand";\r\nmtd_device_parse_register(ppchameleon_mtd, NULL, 0,\r\nppchameleon_mtd->size == NAND_SMALL_SIZE ?\r\npartition_info_me :\r\npartition_info_hi,\r\nNUM_PARTITIONS);\r\nnand_evb_init:\r\nppchameleonevb_mtd = kmalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip), GFP_KERNEL);\r\nif (!ppchameleonevb_mtd) {\r\nprintk("Unable to allocate PPChameleonEVB NAND MTD device structure.\n");\r\nif (ppchameleon_fio_base)\r\niounmap(ppchameleon_fio_base);\r\nreturn -ENOMEM;\r\n}\r\nppchameleonevb_fio_base = ioremap(ppchameleonevb_fio_pbase, SZ_4M);\r\nif (!ppchameleonevb_fio_base) {\r\nprintk("ioremap PPChameleonEVB NAND flash failed\n");\r\nkfree(ppchameleonevb_mtd);\r\nif (ppchameleon_fio_base)\r\niounmap(ppchameleon_fio_base);\r\nreturn -EIO;\r\n}\r\nthis = (struct nand_chip *)(&ppchameleonevb_mtd[1]);\r\nmemset(ppchameleonevb_mtd, 0, sizeof(struct mtd_info));\r\nmemset(this, 0, sizeof(struct nand_chip));\r\nppchameleonevb_mtd->priv = this;\r\nout_be32((volatile unsigned *)GPIO0_OSRH, in_be32((volatile unsigned *)GPIO0_OSRH) & 0xFFFFFFF0);\r\nout_be32((volatile unsigned *)GPIO0_OSRL, in_be32((volatile unsigned *)GPIO0_OSRL) & 0x3FFFFFFF);\r\nout_be32((volatile unsigned *)GPIO0_TSRH, in_be32((volatile unsigned *)GPIO0_TSRH) & 0xFFFFFFF0);\r\nout_be32((volatile unsigned *)GPIO0_TSRL, in_be32((volatile unsigned *)GPIO0_TSRL) & 0x3FFFFFFF);\r\nout_be32((volatile unsigned *)GPIO0_TCR, in_be32((volatile unsigned *)GPIO0_TCR) | NAND_EVB_nCE_GPIO_PIN |\r\nNAND_EVB_CLE_GPIO_PIN | NAND_EVB_ALE_GPIO_PIN);\r\n#ifdef USE_READY_BUSY_PIN\r\nout_be32((volatile unsigned *)GPIO0_TSRL, in_be32((volatile unsigned *)GPIO0_TSRL) & 0xFFFFFFFC);\r\nout_be32((volatile unsigned *)GPIO0_TCR, in_be32((volatile unsigned *)GPIO0_TCR) & (~NAND_EVB_RB_GPIO_PIN));\r\nout_be32((volatile unsigned *)GPIO0_ISR1L,\r\n(in_be32((volatile unsigned *)GPIO0_ISR1L) & 0xFFFFFFFC) | 0x00000001);\r\n#endif\r\nthis->IO_ADDR_R = ppchameleonevb_fio_base;\r\nthis->IO_ADDR_W = ppchameleonevb_fio_base;\r\nthis->cmd_ctrl = ppchameleonevb_hwcontrol;\r\n#ifdef USE_READY_BUSY_PIN\r\nthis->dev_ready = ppchameleonevb_device_ready;\r\n#endif\r\nthis->chip_delay = NAND_SMALL_DELAY_US;\r\nthis->ecc.mode = NAND_ECC_SOFT;\r\nif (nand_scan(ppchameleonevb_mtd, 1)) {\r\niounmap((void *)ppchameleonevb_fio_base);\r\nkfree(ppchameleonevb_mtd);\r\nif (ppchameleon_fio_base)\r\niounmap(ppchameleon_fio_base);\r\nreturn -ENXIO;\r\n}\r\nppchameleonevb_mtd->name = NAND_EVB_MTD_NAME;\r\nmtd_device_parse_register(ppchameleonevb_mtd, NULL, 0,\r\nppchameleon_mtd->size == NAND_SMALL_SIZE ?\r\npartition_info_me :\r\npartition_info_hi,\r\nNUM_PARTITIONS);\r\nreturn 0;\r\n}\r\nstatic void __exit ppchameleonevb_cleanup(void)\r\n{\r\nstruct nand_chip *this;\r\nnand_release(ppchameleon_mtd);\r\nnand_release(ppchameleonevb_mtd);\r\nthis = (struct nand_chip *) &ppchameleon_mtd[1];\r\niounmap((void *) this->IO_ADDR_R);\r\nthis = (struct nand_chip *) &ppchameleonevb_mtd[1];\r\niounmap((void *) this->IO_ADDR_R);\r\nkfree (ppchameleon_mtd);\r\nkfree (ppchameleonevb_mtd);\r\n}
