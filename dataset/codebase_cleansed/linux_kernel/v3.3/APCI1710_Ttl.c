int i_APCI1710_InsnConfigInitTTLIO(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned char b_ModulNbr;\r\nunsigned char b_InitType;\r\nunsigned char b_PortAMode;\r\nunsigned char b_PortBMode;\r\nunsigned char b_PortCMode;\r\nunsigned char b_PortDMode;\r\nb_ModulNbr = (unsigned char) CR_AREF(insn->chanspec);\r\nb_InitType = (unsigned char) data[0];\r\ni_ReturnValue = insn->n;\r\nif (b_ModulNbr < 4) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] &\r\n0xFFFF0000UL) == APCI1710_TTL_IO) {\r\nswitch (b_InitType) {\r\ncase APCI1710_TTL_INIT:\r\ndevpriv->s_ModuleInfo[b_ModulNbr].\r\ns_TTLIOInfo.b_TTLInit = 1;\r\ndevpriv->s_ModuleInfo[b_ModulNbr].\r\ns_TTLIOInfo.b_PortConfiguration[0] = 0;\r\ndevpriv->s_ModuleInfo[b_ModulNbr].\r\ns_TTLIOInfo.b_PortConfiguration[1] = 0;\r\ndevpriv->s_ModuleInfo[b_ModulNbr].\r\ns_TTLIOInfo.b_PortConfiguration[2] = 0;\r\ndevpriv->s_ModuleInfo[b_ModulNbr].\r\ns_TTLIOInfo.b_PortConfiguration[3] = 1;\r\noutl(0x8,\r\ndevpriv->s_BoardInfos.ui_Address + 20 +\r\n(64 * b_ModulNbr));\r\nbreak;\r\ncase APCI1710_TTL_INITDIRECTION:\r\nb_PortAMode = (unsigned char) data[1];\r\nb_PortBMode = (unsigned char) data[2];\r\nb_PortCMode = (unsigned char) data[3];\r\nb_PortDMode = (unsigned char) data[4];\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration\r\n[b_ModulNbr] & 0xFFFF) >=\r\n0x3230) {\r\nif ((b_PortAMode == 0)\r\n|| (b_PortAMode == 1)) {\r\nif ((b_PortBMode == 0)\r\n|| (b_PortBMode == 1)) {\r\nif ((b_PortCMode == 0)\r\n|| (b_PortCMode\r\n== 1)) {\r\nif ((b_PortDMode == 0) || (b_PortDMode == 1)) {\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_TTLIOInfo.\r\nb_TTLInit\r\n=\r\n1;\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_TTLIOInfo.\r\nb_PortConfiguration\r\n[0]\r\n=\r\nb_PortAMode;\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_TTLIOInfo.\r\nb_PortConfiguration\r\n[1]\r\n=\r\nb_PortBMode;\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_TTLIOInfo.\r\nb_PortConfiguration\r\n[2]\r\n=\r\nb_PortCMode;\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_TTLIOInfo.\r\nb_PortConfiguration\r\n[3]\r\n=\r\nb_PortDMode;\r\noutl((b_PortAMode << 0) | (b_PortBMode << 1) | (b_PortCMode << 2) | (b_PortDMode << 3), devpriv->s_BoardInfos.ui_Address + 20 + (64 * b_ModulNbr));\r\n} else {\r\nDPRINTK("Port D mode selection is wrong\n");\r\ni_ReturnValue\r\n=\r\n-8;\r\n}\r\n} else {\r\nDPRINTK("Port C mode selection is wrong\n");\r\ni_ReturnValue =\r\n-7;\r\n}\r\n} else {\r\nDPRINTK("Port B mode selection is wrong\n");\r\ni_ReturnValue = -6;\r\n}\r\n} else {\r\nDPRINTK("Port A mode selection is wrong\n");\r\ni_ReturnValue = -5;\r\n}\r\n} else {\r\nDPRINTK("Function not available for this version\n");\r\ni_ReturnValue = -4;\r\n}\r\nbreak;\r\nDPRINTK("\n");\r\ndefault:\r\nprintk("Bad Config Type\n");\r\n}\r\n} else {\r\nDPRINTK("The module is not a TTL module\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("Module number error\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_InsnBitsReadTTLIO(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int dw_StatusReg;\r\nunsigned char b_ModulNbr;\r\nunsigned char b_SelectedPort;\r\nunsigned char b_InputChannel;\r\nunsigned char b_ReadType;\r\nunsigned char *pb_ChannelStatus;\r\nunsigned char *pb_PortValue;\r\ni_ReturnValue = insn->n;\r\nb_ReadType = (unsigned char) data[0];\r\nb_ModulNbr = CR_AREF(insn->chanspec);\r\nb_SelectedPort = CR_RANGE(insn->chanspec);\r\nb_InputChannel = CR_CHAN(insn->chanspec);\r\nif (b_ModulNbr < 4) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] &\r\n0xFFFF0000UL) == APCI1710_TTL_IO) {\r\nswitch (b_ReadType) {\r\ncase APCI1710_TTL_READCHANNEL:\r\npb_ChannelStatus = (unsigned char *) &data[0];\r\nif (((b_SelectedPort <= 2)\r\n&& ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration\r\n[b_ModulNbr] &\r\n0xFFFF) ==\r\n0x3130))\r\n|| ((b_SelectedPort <= 3)\r\n&& ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration\r\n[b_ModulNbr] &\r\n0xFFFF) >=\r\n0x3230))) {\r\nif (((b_InputChannel <= 7)\r\n&& (b_SelectedPort < 3))\r\n|| ((b_InputChannel <= 1)\r\n&& (b_SelectedPort ==\r\n3))) {\r\nif (devpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_TTLIOInfo.b_TTLInit ==\r\n1) {\r\nif (((devpriv->s_BoardInfos.dw_MolduleConfiguration[b_ModulNbr] & 0xFFFF) == 0x3130) || (((devpriv->s_BoardInfos.dw_MolduleConfiguration[b_ModulNbr] & 0xFFFF) >= 0x3230) && (devpriv->s_ModuleInfo[b_ModulNbr].s_TTLIOInfo.b_PortConfiguration[b_SelectedPort] == 0))) {\r\ndw_StatusReg =\r\ninl\r\n(devpriv->\r\ns_BoardInfos.\r\nui_Address\r\n+\r\n(64 * b_ModulNbr));\r\n*pb_ChannelStatus\r\n=\r\n(unsigned char) (\r\n(dw_StatusReg\r\n>>\r\n(8 * b_SelectedPort)) >> b_InputChannel) & 1;\r\n} else {\r\nDPRINTK("Selected TTL I/O port error\n");\r\ni_ReturnValue =\r\n-4;\r\n}\r\n} else {\r\nDPRINTK("TTL I/O not initialised\n");\r\ni_ReturnValue = -6;\r\n}\r\n} else {\r\nDPRINTK("Selected digital input error\n");\r\ni_ReturnValue = -5;\r\n}\r\n} else {\r\nDPRINTK("Selected TTL I/O port error\n");\r\ni_ReturnValue = -4;\r\n}\r\nbreak;\r\ncase APCI1710_TTL_READPORT:\r\npb_PortValue = (unsigned char *) &data[0];\r\nif (((b_SelectedPort <= 2)\r\n&& ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration\r\n[b_ModulNbr] &\r\n0xFFFF) ==\r\n0x3130))\r\n|| ((b_SelectedPort <= 3)\r\n&& ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration\r\n[b_ModulNbr] &\r\n0xFFFF) >=\r\n0x3230))) {\r\nif (devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_TTLIOInfo.b_TTLInit == 1) {\r\nif (((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration\r\n[b_ModulNbr]\r\n&\r\n0xFFFF)\r\n== 0x3130)\r\n|| (((devpriv->s_BoardInfos.dw_MolduleConfiguration[b_ModulNbr] & 0xFFFF) >= 0x3230) && (devpriv->s_ModuleInfo[b_ModulNbr].s_TTLIOInfo.b_PortConfiguration[b_SelectedPort] == 0))) {\r\ndw_StatusReg =\r\ninl(devpriv->\r\ns_BoardInfos.\r\nui_Address +\r\n(64 * b_ModulNbr));\r\n*pb_PortValue =\r\n(unsigned char) (\r\n(dw_StatusReg >>\r\n(8 * b_SelectedPort)) & 0xFF);\r\n} else {\r\nDPRINTK("Selected TTL I/O port error\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("TTL I/O not initialised\n");\r\ni_ReturnValue = -5;\r\n}\r\n} else {\r\nDPRINTK("Selected TTL I/O port error\n");\r\ni_ReturnValue = -4;\r\n}\r\nbreak;\r\ndefault:\r\nprintk("Bad ReadType\n");\r\n}\r\n} else {\r\nDPRINTK("The module is not a TTL module\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("Module number error\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_InsnReadTTLIOAllPortValue(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int dw_StatusReg;\r\nunsigned char b_ModulNbr;\r\nunsigned int *pul_PortValue;\r\nb_ModulNbr = (unsigned char) CR_AREF(insn->chanspec);\r\ni_ReturnValue = insn->n;\r\npul_PortValue = (unsigned int *) &data[0];\r\nif (b_ModulNbr < 4) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] &\r\n0xFFFF0000UL) == APCI1710_TTL_IO) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_TTLIOInfo.b_TTLInit == 1) {\r\ndw_StatusReg = inl(devpriv->s_BoardInfos.\r\nui_Address + (64 * b_ModulNbr));\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration\r\n[b_ModulNbr] & 0xFFFF) ==\r\n0x3130) {\r\n*pul_PortValue =\r\ndw_StatusReg & 0xFFFFFFUL;\r\n} else {\r\nif (devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_TTLIOInfo.\r\nb_PortConfiguration[0] == 1) {\r\n*pul_PortValue =\r\ndw_StatusReg &\r\n0x3FFFF00UL;\r\n}\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_TTLIOInfo.\r\nb_PortConfiguration[1] == 1) {\r\n*pul_PortValue =\r\ndw_StatusReg &\r\n0x3FF00FFUL;\r\n}\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_TTLIOInfo.\r\nb_PortConfiguration[2] == 1) {\r\n*pul_PortValue =\r\ndw_StatusReg &\r\n0x300FFFFUL;\r\n}\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_TTLIOInfo.\r\nb_PortConfiguration[3] == 1) {\r\n*pul_PortValue =\r\ndw_StatusReg &\r\n0xFFFFFFUL;\r\n}\r\n}\r\n} else {\r\nDPRINTK("TTL I/O not initialised\n");\r\ni_ReturnValue = -5;\r\n}\r\n} else {\r\nDPRINTK("The module is not a TTL module\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("Module number error\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}
