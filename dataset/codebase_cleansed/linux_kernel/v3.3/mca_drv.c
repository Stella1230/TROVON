static int\r\nfatal_mca(const char *fmt, ...)\r\n{\r\nva_list args;\r\nchar buf[256];\r\nva_start(args, fmt);\r\nvsnprintf(buf, sizeof(buf), fmt, args);\r\nva_end(args);\r\nia64_mca_printk(KERN_ALERT "MCA: %s\n", buf);\r\nreturn MCA_NOT_RECOVERED;\r\n}\r\nstatic int\r\nmca_recovered(const char *fmt, ...)\r\n{\r\nva_list args;\r\nchar buf[256];\r\nva_start(args, fmt);\r\nvsnprintf(buf, sizeof(buf), fmt, args);\r\nva_end(args);\r\nia64_mca_printk(KERN_INFO "MCA: %s\n", buf);\r\nreturn MCA_RECOVERED;\r\n}\r\nstatic isolate_status_t\r\nmca_page_isolate(unsigned long paddr)\r\n{\r\nint i;\r\nstruct page *p;\r\nif (!ia64_phys_addr_valid(paddr))\r\nreturn ISOLATE_NONE;\r\nif (!pfn_valid(paddr >> PAGE_SHIFT))\r\nreturn ISOLATE_NONE;\r\np = pfn_to_page(paddr>>PAGE_SHIFT);\r\nfor (i = 0; i < num_page_isolate; i++)\r\nif (page_isolate[i] == p)\r\nreturn ISOLATE_OK;\r\nif (num_page_isolate == MAX_PAGE_ISOLATE)\r\nreturn ISOLATE_NG;\r\nif (PageSlab(p) || PageReserved(p))\r\nreturn ISOLATE_NG;\r\nget_page(p);\r\nSetPageReserved(p);\r\npage_isolate[num_page_isolate++] = p;\r\nreturn ISOLATE_OK;\r\n}\r\nvoid\r\nmca_handler_bh(unsigned long paddr, void *iip, unsigned long ipsr)\r\n{\r\nia64_mlogbuf_dump();\r\nprintk(KERN_ERR "OS_MCA: process [cpu %d, pid: %d, uid: %d, "\r\n"iip: %p, psr: 0x%lx,paddr: 0x%lx](%s) encounters MCA.\n",\r\nraw_smp_processor_id(), current->pid, current_uid(),\r\niip, ipsr, paddr, current->comm);\r\nspin_lock(&mca_bh_lock);\r\nswitch (mca_page_isolate(paddr)) {\r\ncase ISOLATE_OK:\r\nprintk(KERN_DEBUG "Page isolation: ( %lx ) success.\n", paddr);\r\nbreak;\r\ncase ISOLATE_NG:\r\nprintk(KERN_CRIT "Page isolation: ( %lx ) failure.\n", paddr);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock(&mca_bh_lock);\r\ndo_exit(SIGKILL);\r\n}\r\nstatic void\r\nmca_make_peidx(sal_log_processor_info_t *slpi, peidx_table_t *peidx)\r\n{\r\nu64 total_check_num = slpi->valid.num_cache_check\r\n+ slpi->valid.num_tlb_check\r\n+ slpi->valid.num_bus_check\r\n+ slpi->valid.num_reg_file_check\r\n+ slpi->valid.num_ms_check;\r\nu64 head_size = sizeof(sal_log_mod_error_info_t) * total_check_num\r\n+ sizeof(sal_log_processor_info_t);\r\nu64 mid_size = slpi->valid.cpuid_info * sizeof(struct sal_cpuid_info);\r\npeidx_head(peidx) = slpi;\r\npeidx_mid(peidx) = (struct sal_cpuid_info *)\r\n(slpi->valid.cpuid_info ? ((char*)slpi + head_size) : NULL);\r\npeidx_bottom(peidx) = (sal_processor_static_info_t *)\r\n(slpi->valid.psi_static_struct ?\r\n((char*)slpi + head_size + mid_size) : NULL);\r\n}\r\nstatic int\r\nmca_make_slidx(void *buffer, slidx_table_t *slidx)\r\n{\r\nint platform_err = 0;\r\nint record_len = ((sal_log_record_header_t*)buffer)->len;\r\nu32 ercd_pos;\r\nint sects;\r\nsal_log_section_hdr_t *sp;\r\nINIT_LIST_HEAD(&(slidx->proc_err));\r\nINIT_LIST_HEAD(&(slidx->mem_dev_err));\r\nINIT_LIST_HEAD(&(slidx->sel_dev_err));\r\nINIT_LIST_HEAD(&(slidx->pci_bus_err));\r\nINIT_LIST_HEAD(&(slidx->smbios_dev_err));\r\nINIT_LIST_HEAD(&(slidx->pci_comp_err));\r\nINIT_LIST_HEAD(&(slidx->plat_specific_err));\r\nINIT_LIST_HEAD(&(slidx->host_ctlr_err));\r\nINIT_LIST_HEAD(&(slidx->plat_bus_err));\r\nINIT_LIST_HEAD(&(slidx->unsupported));\r\nslidx->header = buffer;\r\nfor (ercd_pos = sizeof(sal_log_record_header_t), sects = 0;\r\nercd_pos < record_len; ercd_pos += sp->len, sects++) {\r\nsp = (sal_log_section_hdr_t *)((char*)buffer + ercd_pos);\r\nif (!efi_guidcmp(sp->guid, SAL_PROC_DEV_ERR_SECT_GUID)) {\r\nLOG_INDEX_ADD_SECT_PTR(slidx->proc_err, sp);\r\n} else if (!efi_guidcmp(sp->guid,\r\nSAL_PLAT_MEM_DEV_ERR_SECT_GUID)) {\r\nplatform_err = 1;\r\nLOG_INDEX_ADD_SECT_PTR(slidx->mem_dev_err, sp);\r\n} else if (!efi_guidcmp(sp->guid,\r\nSAL_PLAT_SEL_DEV_ERR_SECT_GUID)) {\r\nplatform_err = 1;\r\nLOG_INDEX_ADD_SECT_PTR(slidx->sel_dev_err, sp);\r\n} else if (!efi_guidcmp(sp->guid,\r\nSAL_PLAT_PCI_BUS_ERR_SECT_GUID)) {\r\nplatform_err = 1;\r\nLOG_INDEX_ADD_SECT_PTR(slidx->pci_bus_err, sp);\r\n} else if (!efi_guidcmp(sp->guid,\r\nSAL_PLAT_SMBIOS_DEV_ERR_SECT_GUID)) {\r\nplatform_err = 1;\r\nLOG_INDEX_ADD_SECT_PTR(slidx->smbios_dev_err, sp);\r\n} else if (!efi_guidcmp(sp->guid,\r\nSAL_PLAT_PCI_COMP_ERR_SECT_GUID)) {\r\nplatform_err = 1;\r\nLOG_INDEX_ADD_SECT_PTR(slidx->pci_comp_err, sp);\r\n} else if (!efi_guidcmp(sp->guid,\r\nSAL_PLAT_SPECIFIC_ERR_SECT_GUID)) {\r\nplatform_err = 1;\r\nLOG_INDEX_ADD_SECT_PTR(slidx->plat_specific_err, sp);\r\n} else if (!efi_guidcmp(sp->guid,\r\nSAL_PLAT_HOST_CTLR_ERR_SECT_GUID)) {\r\nplatform_err = 1;\r\nLOG_INDEX_ADD_SECT_PTR(slidx->host_ctlr_err, sp);\r\n} else if (!efi_guidcmp(sp->guid,\r\nSAL_PLAT_BUS_ERR_SECT_GUID)) {\r\nplatform_err = 1;\r\nLOG_INDEX_ADD_SECT_PTR(slidx->plat_bus_err, sp);\r\n} else {\r\nLOG_INDEX_ADD_SECT_PTR(slidx->unsupported, sp);\r\n}\r\n}\r\nslidx->n_sections = sects;\r\nreturn platform_err;\r\n}\r\nstatic int\r\ninit_record_index_pools(void)\r\n{\r\nint i;\r\nint rec_max_size;\r\nint sect_min_size;\r\nstatic int sal_log_sect_min_sizes[] = {\r\nsizeof(sal_log_processor_info_t)\r\n+ sizeof(sal_processor_static_info_t),\r\nsizeof(sal_log_mem_dev_err_info_t),\r\nsizeof(sal_log_sel_dev_err_info_t),\r\nsizeof(sal_log_pci_bus_err_info_t),\r\nsizeof(sal_log_smbios_dev_err_info_t),\r\nsizeof(sal_log_pci_comp_err_info_t),\r\nsizeof(sal_log_plat_specific_err_info_t),\r\nsizeof(sal_log_host_ctlr_err_info_t),\r\nsizeof(sal_log_plat_bus_err_info_t),\r\n};\r\nrec_max_size = sal_rec_max;\r\nsect_min_size = sal_log_sect_min_sizes[0];\r\nfor (i = 1; i < sizeof sal_log_sect_min_sizes/sizeof(size_t); i++)\r\nif (sect_min_size > sal_log_sect_min_sizes[i])\r\nsect_min_size = sal_log_sect_min_sizes[i];\r\nslidx_pool.max_idx = (rec_max_size/sect_min_size) * 2 + 1;\r\nslidx_pool.buffer = (slidx_list_t *)\r\nkmalloc(slidx_pool.max_idx * sizeof(slidx_list_t), GFP_KERNEL);\r\nreturn slidx_pool.buffer ? 0 : -ENOMEM;\r\n}\r\nstatic mca_type_t\r\nis_mca_global(peidx_table_t *peidx, pal_bus_check_info_t *pbci,\r\nstruct ia64_sal_os_state *sos)\r\n{\r\npal_processor_state_info_t *psp =\r\n(pal_processor_state_info_t*)peidx_psp(peidx);\r\nswitch (sos->rv_rc) {\r\ncase -1:\r\nreturn MCA_IS_GLOBAL;\r\ncase 0:\r\nreturn MCA_IS_LOCAL;\r\ncase 1:\r\ncase 2:\r\ndefault:\r\nbreak;\r\n}\r\nif (psp->tc || psp->cc || psp->rc || psp->uc)\r\nreturn MCA_IS_LOCAL;\r\nif (!pbci || pbci->ib)\r\nreturn MCA_IS_GLOBAL;\r\nif (pbci->eb)\r\nswitch (pbci->bsi) {\r\ncase 0:\r\nreturn MCA_IS_LOCAL;\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nreturn MCA_IS_GLOBAL;\r\n}\r\nreturn MCA_IS_GLOBAL;\r\n}\r\nstatic u64\r\nget_target_identifier(peidx_table_t *peidx)\r\n{\r\nu64 target_address = 0;\r\nsal_log_mod_error_info_t *smei;\r\npal_cache_check_info_t *pcci;\r\nint i, level = 9;\r\nfor (i = 0; i < peidx_cache_check_num(peidx); i++) {\r\nsmei = (sal_log_mod_error_info_t *)peidx_cache_check(peidx, i);\r\nif (smei->valid.target_identifier && smei->target_identifier) {\r\npcci = (pal_cache_check_info_t *)&(smei->check_info);\r\nif (!target_address || (pcci->level < level)) {\r\ntarget_address = smei->target_identifier;\r\nlevel = pcci->level;\r\ncontinue;\r\n}\r\n}\r\n}\r\nif (target_address)\r\nreturn target_address;\r\nsmei = peidx_bus_check(peidx, 0);\r\nif (smei && smei->valid.target_identifier)\r\nreturn smei->target_identifier;\r\nreturn 0;\r\n}\r\nstatic int\r\nrecover_from_read_error(slidx_table_t *slidx,\r\npeidx_table_t *peidx, pal_bus_check_info_t *pbci,\r\nstruct ia64_sal_os_state *sos)\r\n{\r\nu64 target_identifier;\r\npal_min_state_area_t *pmsa;\r\nstruct ia64_psr *psr1, *psr2;\r\nia64_fptr_t *mca_hdlr_bh = (ia64_fptr_t*)mca_handler_bhhook;\r\ntarget_identifier = get_target_identifier(peidx);\r\nif (!target_identifier)\r\nreturn fatal_mca("target address not valid");\r\nif (!peidx_bottom(peidx) || !(peidx_bottom(peidx)->valid.minstate))\r\nreturn fatal_mca("minstate not valid");\r\npsr1 =(struct ia64_psr *)&(peidx_minstate_area(peidx)->pmsa_ipsr);\r\npsr2 =(struct ia64_psr *)&(peidx_minstate_area(peidx)->pmsa_xpsr);\r\npmsa = sos->pal_min_state;\r\nif (psr1->cpl != 0 ||\r\n((psr2->cpl != 0) && mca_recover_range(pmsa->pmsa_iip))) {\r\npmsa->pmsa_gr[8-1] = target_identifier;\r\npmsa->pmsa_gr[9-1] = pmsa->pmsa_iip;\r\npmsa->pmsa_gr[10-1] = pmsa->pmsa_ipsr;\r\npmsa->pmsa_br0 = pmsa->pmsa_iip;\r\npmsa->pmsa_iip = mca_hdlr_bh->fp;\r\npmsa->pmsa_gr[1-1] = mca_hdlr_bh->gp;\r\npsr2 = (struct ia64_psr *)&pmsa->pmsa_ipsr;\r\npsr2->cpl = 0;\r\npsr2->ri = 0;\r\npsr2->bn = 1;\r\npsr2->i = 0;\r\nreturn mca_recovered("user memory corruption. "\r\n"kill affected process - recovered.");\r\n}\r\nreturn fatal_mca("kernel context not recovered, iip 0x%lx\n",\r\npmsa->pmsa_iip);\r\n}\r\nstatic int\r\nrecover_from_platform_error(slidx_table_t *slidx, peidx_table_t *peidx,\r\npal_bus_check_info_t *pbci,\r\nstruct ia64_sal_os_state *sos)\r\n{\r\nint status = 0;\r\npal_processor_state_info_t *psp =\r\n(pal_processor_state_info_t*)peidx_psp(peidx);\r\nif (psp->bc && pbci->eb && pbci->bsi == 0) {\r\nswitch(pbci->type) {\r\ncase 1:\r\ncase 3:\r\ncase 9:\r\nstatus = recover_from_read_error(slidx, peidx, pbci,\r\nsos);\r\nbreak;\r\ncase 0:\r\ncase 2:\r\ncase 4:\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\ncase 8:\r\ncase 10:\r\ncase 11:\r\ncase 12:\r\ndefault:\r\nbreak;\r\n}\r\n} else if (psp->cc && !psp->bc) {\r\nstatus = recover_from_read_error(slidx, peidx, pbci, sos);\r\n}\r\nreturn status;\r\n}\r\nstatic int\r\nrecover_from_tlb_check(peidx_table_t *peidx)\r\n{\r\nsal_log_mod_error_info_t *smei;\r\npal_tlb_check_info_t *ptci;\r\nsmei = (sal_log_mod_error_info_t *)peidx_tlb_check(peidx, 0);\r\nptci = (pal_tlb_check_info_t *)&(smei->check_info);\r\nif (ptci->op == PAL_TLB_CHECK_OP_PURGE\r\n&& !(ptci->itr || ptci->dtc || ptci->itc))\r\nreturn fatal_mca("Duplicate TLB entry");\r\nreturn mca_recovered("TLB check recovered");\r\n}\r\nstatic int\r\nrecover_from_processor_error(int platform, slidx_table_t *slidx,\r\npeidx_table_t *peidx, pal_bus_check_info_t *pbci,\r\nstruct ia64_sal_os_state *sos)\r\n{\r\npal_processor_state_info_t *psp =\r\n(pal_processor_state_info_t*)peidx_psp(peidx);\r\nif (psp->cm == 1)\r\nreturn mca_recovered("machine check is already corrected.");\r\nif (psp->us || psp->ci == 0)\r\nreturn fatal_mca("error not contained");\r\nif (psp->tc && !(psp->cc || psp->bc || psp->rc || psp->uc))\r\nreturn recover_from_tlb_check(peidx);\r\nif (psp->cc == 0 && (psp->bc == 0 || pbci == NULL))\r\nreturn fatal_mca("No cache or bus check");\r\nif (peidx_bus_check_num(peidx) > 1)\r\nreturn fatal_mca("Too many bus checks");\r\nif (pbci->ib)\r\nreturn fatal_mca("Internal Bus error");\r\nif (pbci->eb && pbci->bsi > 0)\r\nreturn fatal_mca("External bus check fatal status");\r\nif (platform)\r\nreturn recover_from_platform_error(slidx, peidx, pbci, sos);\r\nreturn fatal_mca("Strange SAL record");\r\n}\r\nstatic int\r\nmca_try_to_recover(void *rec, struct ia64_sal_os_state *sos)\r\n{\r\nint platform_err;\r\nint n_proc_err;\r\nslidx_table_t slidx;\r\npeidx_table_t peidx;\r\npal_bus_check_info_t pbci;\r\nplatform_err = mca_make_slidx(rec, &slidx);\r\nn_proc_err = slidx_count(&slidx, proc_err);\r\nif (n_proc_err > 1)\r\nreturn fatal_mca("Too Many Errors");\r\nelse if (n_proc_err == 0)\r\nreturn fatal_mca("Weird SAL record");\r\nmca_make_peidx((sal_log_processor_info_t*)\r\nslidx_first_entry(&slidx.proc_err)->hdr, &peidx);\r\n*((u64*)&pbci) = peidx_check_info(&peidx, bus_check, 0);\r\nif (is_mca_global(&peidx, &pbci, sos))\r\nreturn fatal_mca("global MCA");\r\nreturn recover_from_processor_error(platform_err, &slidx, &peidx,\r\n&pbci, sos);\r\n}\r\nint __init mca_external_handler_init(void)\r\n{\r\nif (init_record_index_pools())\r\nreturn -ENOMEM;\r\nif (ia64_reg_MCA_extension(mca_try_to_recover)) {\r\nprintk(KERN_ERR "ia64_reg_MCA_extension failed.\n");\r\nkfree(slidx_pool.buffer);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nvoid __exit mca_external_handler_exit(void)\r\n{\r\nia64_unreg_MCA_extension();\r\nkfree(slidx_pool.buffer);\r\n}
