static u32 *count_ports(u32 *sid, int *total_port_count, int *child_port_count)\r\n{\r\nu32 q;\r\nint port_type, shift, seq;\r\n*total_port_count = 0;\r\n*child_port_count = 0;\r\nshift = 6;\r\nq = *sid;\r\nseq = 0;\r\nwhile (1) {\r\nport_type = (q >> shift) & 0x03;\r\nswitch (port_type) {\r\ncase SELFID_PORT_CHILD:\r\n(*child_port_count)++;\r\ncase SELFID_PORT_PARENT:\r\ncase SELFID_PORT_NCONN:\r\n(*total_port_count)++;\r\ncase SELFID_PORT_NONE:\r\nbreak;\r\n}\r\nshift -= 2;\r\nif (shift == 0) {\r\nif (!SELF_ID_MORE_PACKETS(q))\r\nreturn sid + 1;\r\nshift = 16;\r\nsid++;\r\nq = *sid;\r\nif (!SELF_ID_EXTENDED(q) ||\r\nseq != SELF_ID_EXT_SEQUENCE(q))\r\nreturn NULL;\r\nseq++;\r\n}\r\n}\r\n}\r\nstatic int get_port_type(u32 *sid, int port_index)\r\n{\r\nint index, shift;\r\nindex = (port_index + 5) / 8;\r\nshift = 16 - ((port_index + 5) & 7) * 2;\r\nreturn (sid[index] >> shift) & 0x03;\r\n}\r\nstatic struct fw_node *fw_node_create(u32 sid, int port_count, int color)\r\n{\r\nstruct fw_node *node;\r\nnode = kzalloc(sizeof(*node) + port_count * sizeof(node->ports[0]),\r\nGFP_ATOMIC);\r\nif (node == NULL)\r\nreturn NULL;\r\nnode->color = color;\r\nnode->node_id = LOCAL_BUS | SELF_ID_PHY_ID(sid);\r\nnode->link_on = SELF_ID_LINK_ON(sid);\r\nnode->phy_speed = SELF_ID_PHY_SPEED(sid);\r\nnode->initiated_reset = SELF_ID_PHY_INITIATOR(sid);\r\nnode->port_count = port_count;\r\natomic_set(&node->ref_count, 1);\r\nINIT_LIST_HEAD(&node->link);\r\nreturn node;\r\n}\r\nstatic void update_hop_count(struct fw_node *node)\r\n{\r\nint depths[2] = { -1, -1 };\r\nint max_child_hops = 0;\r\nint i;\r\nfor (i = 0; i < node->port_count; i++) {\r\nif (node->ports[i] == NULL)\r\ncontinue;\r\nif (node->ports[i]->max_hops > max_child_hops)\r\nmax_child_hops = node->ports[i]->max_hops;\r\nif (node->ports[i]->max_depth > depths[0]) {\r\ndepths[1] = depths[0];\r\ndepths[0] = node->ports[i]->max_depth;\r\n} else if (node->ports[i]->max_depth > depths[1])\r\ndepths[1] = node->ports[i]->max_depth;\r\n}\r\nnode->max_depth = depths[0] + 1;\r\nnode->max_hops = max(max_child_hops, depths[0] + depths[1] + 2);\r\n}\r\nstatic inline struct fw_node *fw_node(struct list_head *l)\r\n{\r\nreturn list_entry(l, struct fw_node, link);\r\n}\r\nstatic struct fw_node *build_tree(struct fw_card *card,\r\nu32 *sid, int self_id_count)\r\n{\r\nstruct fw_node *node, *child, *local_node, *irm_node;\r\nstruct list_head stack, *h;\r\nu32 *next_sid, *end, q;\r\nint i, port_count, child_port_count, phy_id, parent_count, stack_depth;\r\nint gap_count;\r\nbool beta_repeaters_present;\r\nlocal_node = NULL;\r\nnode = NULL;\r\nINIT_LIST_HEAD(&stack);\r\nstack_depth = 0;\r\nend = sid + self_id_count;\r\nphy_id = 0;\r\nirm_node = NULL;\r\ngap_count = SELF_ID_GAP_COUNT(*sid);\r\nbeta_repeaters_present = false;\r\nwhile (sid < end) {\r\nnext_sid = count_ports(sid, &port_count, &child_port_count);\r\nif (next_sid == NULL) {\r\nfw_error("Inconsistent extended self IDs.\n");\r\nreturn NULL;\r\n}\r\nq = *sid;\r\nif (phy_id != SELF_ID_PHY_ID(q)) {\r\nfw_error("PHY ID mismatch in self ID: %d != %d.\n",\r\nphy_id, SELF_ID_PHY_ID(q));\r\nreturn NULL;\r\n}\r\nif (child_port_count > stack_depth) {\r\nfw_error("Topology stack underflow\n");\r\nreturn NULL;\r\n}\r\nfor (i = 0, h = &stack; i < child_port_count; i++)\r\nh = h->prev;\r\nchild = fw_node(h);\r\nnode = fw_node_create(q, port_count, card->color);\r\nif (node == NULL) {\r\nfw_error("Out of memory while building topology.\n");\r\nreturn NULL;\r\n}\r\nif (phy_id == (card->node_id & 0x3f))\r\nlocal_node = node;\r\nif (SELF_ID_CONTENDER(q))\r\nirm_node = node;\r\nparent_count = 0;\r\nfor (i = 0; i < port_count; i++) {\r\nswitch (get_port_type(sid, i)) {\r\ncase SELFID_PORT_PARENT:\r\nparent_count++;\r\nnode->color = i;\r\nbreak;\r\ncase SELFID_PORT_CHILD:\r\nnode->ports[i] = child;\r\nchild->ports[child->color] = node;\r\nchild->color = card->color;\r\nchild = fw_node(child->link.next);\r\nbreak;\r\n}\r\n}\r\nif ((next_sid == end && parent_count != 0) ||\r\n(next_sid < end && parent_count != 1)) {\r\nfw_error("Parent port inconsistency for node %d: "\r\n"parent_count=%d\n", phy_id, parent_count);\r\nreturn NULL;\r\n}\r\n__list_del(h->prev, &stack);\r\nlist_add_tail(&node->link, &stack);\r\nstack_depth += 1 - child_port_count;\r\nif (node->phy_speed == SCODE_BETA &&\r\nparent_count + child_port_count > 1)\r\nbeta_repeaters_present = true;\r\nif (SELF_ID_GAP_COUNT(q) != gap_count)\r\ngap_count = 0;\r\nupdate_hop_count(node);\r\nsid = next_sid;\r\nphy_id++;\r\n}\r\ncard->root_node = node;\r\ncard->irm_node = irm_node;\r\ncard->gap_count = gap_count;\r\ncard->beta_repeaters_present = beta_repeaters_present;\r\nreturn local_node;\r\n}\r\nstatic void for_each_fw_node(struct fw_card *card, struct fw_node *root,\r\nfw_node_callback_t callback)\r\n{\r\nstruct list_head list;\r\nstruct fw_node *node, *next, *child, *parent;\r\nint i;\r\nINIT_LIST_HEAD(&list);\r\nfw_node_get(root);\r\nlist_add_tail(&root->link, &list);\r\nparent = NULL;\r\nlist_for_each_entry(node, &list, link) {\r\nnode->color = card->color;\r\nfor (i = 0; i < node->port_count; i++) {\r\nchild = node->ports[i];\r\nif (!child)\r\ncontinue;\r\nif (child->color == card->color)\r\nparent = child;\r\nelse {\r\nfw_node_get(child);\r\nlist_add_tail(&child->link, &list);\r\n}\r\n}\r\ncallback(card, node, parent);\r\n}\r\nlist_for_each_entry_safe(node, next, &list, link)\r\nfw_node_put(node);\r\n}\r\nstatic void report_lost_node(struct fw_card *card,\r\nstruct fw_node *node, struct fw_node *parent)\r\n{\r\nfw_node_event(card, node, FW_NODE_DESTROYED);\r\nfw_node_put(node);\r\ncard->bm_retries = 0;\r\n}\r\nstatic void report_found_node(struct fw_card *card,\r\nstruct fw_node *node, struct fw_node *parent)\r\n{\r\nint b_path = (node->phy_speed == SCODE_BETA);\r\nif (parent != NULL) {\r\nnode->max_speed = parent->max_speed < node->phy_speed ?\r\nparent->max_speed : node->phy_speed;\r\nnode->b_path = parent->b_path && b_path;\r\n} else {\r\nnode->max_speed = node->phy_speed;\r\nnode->b_path = b_path;\r\n}\r\nfw_node_event(card, node, FW_NODE_CREATED);\r\ncard->bm_retries = 0;\r\n}\r\nvoid fw_destroy_nodes(struct fw_card *card)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\ncard->color++;\r\nif (card->local_node != NULL)\r\nfor_each_fw_node(card, card->local_node, report_lost_node);\r\ncard->local_node = NULL;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nstatic void move_tree(struct fw_node *node0, struct fw_node *node1, int port)\r\n{\r\nstruct fw_node *tree;\r\nint i;\r\ntree = node1->ports[port];\r\nnode0->ports[port] = tree;\r\nfor (i = 0; i < tree->port_count; i++) {\r\nif (tree->ports[i] == node1) {\r\ntree->ports[i] = node0;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void update_tree(struct fw_card *card, struct fw_node *root)\r\n{\r\nstruct list_head list0, list1;\r\nstruct fw_node *node0, *node1, *next1;\r\nint i, event;\r\nINIT_LIST_HEAD(&list0);\r\nlist_add_tail(&card->local_node->link, &list0);\r\nINIT_LIST_HEAD(&list1);\r\nlist_add_tail(&root->link, &list1);\r\nnode0 = fw_node(list0.next);\r\nnode1 = fw_node(list1.next);\r\nwhile (&node0->link != &list0) {\r\nWARN_ON(node0->port_count != node1->port_count);\r\nif (node0->link_on && !node1->link_on)\r\nevent = FW_NODE_LINK_OFF;\r\nelse if (!node0->link_on && node1->link_on)\r\nevent = FW_NODE_LINK_ON;\r\nelse if (node1->initiated_reset && node1->link_on)\r\nevent = FW_NODE_INITIATED_RESET;\r\nelse\r\nevent = FW_NODE_UPDATED;\r\nnode0->node_id = node1->node_id;\r\nnode0->color = card->color;\r\nnode0->link_on = node1->link_on;\r\nnode0->initiated_reset = node1->initiated_reset;\r\nnode0->max_hops = node1->max_hops;\r\nnode1->color = card->color;\r\nfw_node_event(card, node0, event);\r\nif (card->root_node == node1)\r\ncard->root_node = node0;\r\nif (card->irm_node == node1)\r\ncard->irm_node = node0;\r\nfor (i = 0; i < node0->port_count; i++) {\r\nif (node0->ports[i] && node1->ports[i]) {\r\nif (node0->ports[i]->color == card->color)\r\ncontinue;\r\nlist_add_tail(&node0->ports[i]->link, &list0);\r\nlist_add_tail(&node1->ports[i]->link, &list1);\r\n} else if (node0->ports[i]) {\r\nfor_each_fw_node(card, node0->ports[i],\r\nreport_lost_node);\r\nnode0->ports[i] = NULL;\r\n} else if (node1->ports[i]) {\r\nmove_tree(node0, node1, i);\r\nfor_each_fw_node(card, node0->ports[i],\r\nreport_found_node);\r\n}\r\n}\r\nnode0 = fw_node(node0->link.next);\r\nnext1 = fw_node(node1->link.next);\r\nfw_node_put(node1);\r\nnode1 = next1;\r\n}\r\n}\r\nstatic void update_topology_map(struct fw_card *card,\r\nu32 *self_ids, int self_id_count)\r\n{\r\nint node_count = (card->root_node->node_id & 0x3f) + 1;\r\n__be32 *map = card->topology_map;\r\n*map++ = cpu_to_be32((self_id_count + 2) << 16);\r\n*map++ = cpu_to_be32(be32_to_cpu(card->topology_map[1]) + 1);\r\n*map++ = cpu_to_be32((node_count << 16) | self_id_count);\r\nwhile (self_id_count--)\r\n*map++ = cpu_to_be32p(self_ids++);\r\nfw_compute_block_crc(card->topology_map);\r\n}\r\nvoid fw_core_handle_bus_reset(struct fw_card *card, int node_id, int generation,\r\nint self_id_count, u32 *self_ids, bool bm_abdicate)\r\n{\r\nstruct fw_node *local_node;\r\nunsigned long flags;\r\nif (!is_next_generation(generation, card->generation) &&\r\ncard->local_node != NULL) {\r\nfw_notify("skipped bus generations, destroying all nodes\n");\r\nfw_destroy_nodes(card);\r\ncard->bm_retries = 0;\r\n}\r\nspin_lock_irqsave(&card->lock, flags);\r\ncard->broadcast_channel_allocated = card->broadcast_channel_auto_allocated;\r\ncard->node_id = node_id;\r\nsmp_wmb();\r\ncard->generation = generation;\r\ncard->reset_jiffies = get_jiffies_64();\r\ncard->bm_node_id = 0xffff;\r\ncard->bm_abdicate = bm_abdicate;\r\nfw_schedule_bm_work(card, 0);\r\nlocal_node = build_tree(card, self_ids, self_id_count);\r\nupdate_topology_map(card, self_ids, self_id_count);\r\ncard->color++;\r\nif (local_node == NULL) {\r\nfw_error("topology build failed\n");\r\n} else if (card->local_node == NULL) {\r\ncard->local_node = local_node;\r\nfor_each_fw_node(card, local_node, report_found_node);\r\n} else {\r\nupdate_tree(card, local_node);\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}
