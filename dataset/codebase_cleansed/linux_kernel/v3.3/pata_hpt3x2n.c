static u32 hpt3x2n_find_mode(struct ata_port *ap, int speed)\r\n{\r\nstruct hpt_clock *clocks = hpt3x2n_clocks;\r\nwhile (clocks->xfer_speed) {\r\nif (clocks->xfer_speed == speed)\r\nreturn clocks->timing;\r\nclocks++;\r\n}\r\nBUG();\r\nreturn 0xffffffffU;\r\n}\r\nstatic unsigned long hpt372n_filter(struct ata_device *adev, unsigned long mask)\r\n{\r\nif (ata_id_is_sata(adev->id))\r\nmask &= ~((0xE << ATA_SHIFT_UDMA) | ATA_MASK_MWDMA);\r\nreturn mask;\r\n}\r\nstatic int hpt3x2n_cable_detect(struct ata_port *ap)\r\n{\r\nu8 scr2, ata66;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\npci_read_config_byte(pdev, 0x5B, &scr2);\r\npci_write_config_byte(pdev, 0x5B, scr2 & ~0x01);\r\nudelay(10);\r\npci_read_config_byte(pdev, 0x5A, &ata66);\r\npci_write_config_byte(pdev, 0x5B, scr2);\r\nif (ata66 & (2 >> ap->port_no))\r\nreturn ATA_CBL_PATA40;\r\nelse\r\nreturn ATA_CBL_PATA80;\r\n}\r\nstatic int hpt3x2n_pre_reset(struct ata_link *link, unsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\npci_write_config_byte(pdev, 0x50 + 4 * ap->port_no, 0x37);\r\nudelay(100);\r\nreturn ata_sff_prereset(link, deadline);\r\n}\r\nstatic void hpt3x2n_set_mode(struct ata_port *ap, struct ata_device *adev,\r\nu8 mode)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu32 addr1, addr2;\r\nu32 reg, timing, mask;\r\nu8 fast;\r\naddr1 = 0x40 + 4 * (adev->devno + 2 * ap->port_no);\r\naddr2 = 0x51 + 4 * ap->port_no;\r\npci_read_config_byte(pdev, addr2, &fast);\r\nfast &= ~0x07;\r\npci_write_config_byte(pdev, addr2, fast);\r\nif (mode < XFER_MW_DMA_0)\r\nmask = 0xcfc3ffff;\r\nelse if (mode < XFER_UDMA_0)\r\nmask = 0x31c001ff;\r\nelse\r\nmask = 0x303c0000;\r\ntiming = hpt3x2n_find_mode(ap, mode);\r\npci_read_config_dword(pdev, addr1, &reg);\r\nreg = (reg & ~mask) | (timing & mask);\r\npci_write_config_dword(pdev, addr1, reg);\r\n}\r\nstatic void hpt3x2n_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nhpt3x2n_set_mode(ap, adev, adev->pio_mode);\r\n}\r\nstatic void hpt3x2n_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nhpt3x2n_set_mode(ap, adev, adev->dma_mode);\r\n}\r\nstatic void hpt3x2n_bmdma_stop(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nint mscreg = 0x50 + 2 * ap->port_no;\r\nu8 bwsr_stat, msc_stat;\r\npci_read_config_byte(pdev, 0x6A, &bwsr_stat);\r\npci_read_config_byte(pdev, mscreg, &msc_stat);\r\nif (bwsr_stat & (1 << ap->port_no))\r\npci_write_config_byte(pdev, mscreg, msc_stat | 0x30);\r\nata_bmdma_stop(qc);\r\n}\r\nstatic void hpt3x2n_set_clock(struct ata_port *ap, int source)\r\n{\r\nvoid __iomem *bmdma = ap->ioaddr.bmdma_addr - ap->port_no * 8;\r\niowrite8(0x80, bmdma+0x73);\r\niowrite8(0x80, bmdma+0x77);\r\niowrite8(source, bmdma+0x7B);\r\niowrite8(0xC0, bmdma+0x79);\r\niowrite8(ioread8(bmdma+0x70) | 0x32, bmdma+0x70);\r\niowrite8(ioread8(bmdma+0x74) | 0x32, bmdma+0x74);\r\niowrite8(0x00, bmdma+0x79);\r\niowrite8(0x00, bmdma+0x73);\r\niowrite8(0x00, bmdma+0x77);\r\n}\r\nstatic int hpt3x2n_use_dpll(struct ata_port *ap, int writing)\r\n{\r\nlong flags = (long)ap->host->private_data;\r\nif (writing)\r\nreturn USE_DPLL;\r\nif (flags & PCI66)\r\nreturn USE_DPLL;\r\nreturn 0;\r\n}\r\nstatic int hpt3x2n_qc_defer(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ata_port *alt = ap->host->ports[ap->port_no ^ 1];\r\nint rc, flags = (long)ap->host->private_data;\r\nint dpll = hpt3x2n_use_dpll(ap, qc->tf.flags & ATA_TFLAG_WRITE);\r\nrc = ata_std_qc_defer(qc);\r\nif (rc != 0)\r\nreturn rc;\r\nif ((flags & USE_DPLL) != dpll && alt->qc_active)\r\nreturn ATA_DEFER_PORT;\r\nreturn 0;\r\n}\r\nstatic unsigned int hpt3x2n_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nint flags = (long)ap->host->private_data;\r\nint dpll = hpt3x2n_use_dpll(ap, qc->tf.flags & ATA_TFLAG_WRITE);\r\nif ((flags & USE_DPLL) != dpll) {\r\nflags &= ~USE_DPLL;\r\nflags |= dpll;\r\nap->host->private_data = (void *)(long)flags;\r\nhpt3x2n_set_clock(ap, dpll ? 0x21 : 0x23);\r\n}\r\nreturn ata_bmdma_qc_issue(qc);\r\n}\r\nstatic int hpt3xn_calibrate_dpll(struct pci_dev *dev)\r\n{\r\nu8 reg5b;\r\nu32 reg5c;\r\nint tries;\r\nfor (tries = 0; tries < 0x5000; tries++) {\r\nudelay(50);\r\npci_read_config_byte(dev, 0x5b, &reg5b);\r\nif (reg5b & 0x80) {\r\nfor (tries = 0; tries < 0x1000; tries++) {\r\npci_read_config_byte(dev, 0x5b, &reg5b);\r\nif ((reg5b & 0x80) == 0)\r\nreturn 0;\r\n}\r\npci_read_config_dword(dev, 0x5c, &reg5c);\r\npci_write_config_dword(dev, 0x5c, reg5c & ~0x100);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int hpt3x2n_pci_clock(struct pci_dev *pdev)\r\n{\r\nunsigned long freq;\r\nu32 fcnt;\r\nunsigned long iobase = pci_resource_start(pdev, 4);\r\nfcnt = inl(iobase + 0x90);\r\nif ((fcnt >> 12) != 0xABCDE) {\r\nint i;\r\nu16 sr;\r\nu32 total = 0;\r\npr_warn("BIOS clock data not set\n");\r\nfor (i = 0; i < 128; i++) {\r\npci_read_config_word(pdev, 0x78, &sr);\r\ntotal += sr & 0x1FF;\r\nudelay(15);\r\n}\r\nfcnt = total / 128;\r\n}\r\nfcnt &= 0x1FF;\r\nfreq = (fcnt * 77) / 192;\r\nif (freq < 40)\r\nreturn 33;\r\nif (freq < 45)\r\nreturn 40;\r\nif (freq < 55)\r\nreturn 50;\r\nreturn 66;\r\n}\r\nstatic int hpt3x2n_init_one(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstatic const struct ata_port_info info_hpt372n = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA6,\r\n.port_ops = &hpt372n_port_ops\r\n};\r\nstatic const struct ata_port_info info_hpt3xxn = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA6,\r\n.port_ops = &hpt3xxn_port_ops\r\n};\r\nconst struct ata_port_info *ppi[] = { &info_hpt3xxn, NULL };\r\nu8 rev = dev->revision;\r\nu8 irqmask;\r\nunsigned int pci_mhz;\r\nunsigned int f_low, f_high;\r\nint adjust;\r\nunsigned long iobase = pci_resource_start(dev, 4);\r\nvoid *hpriv = (void *)USE_DPLL;\r\nint rc;\r\nrc = pcim_enable_device(dev);\r\nif (rc)\r\nreturn rc;\r\nswitch (dev->device) {\r\ncase PCI_DEVICE_ID_TTI_HPT366:\r\nif (rev < 6)\r\nreturn -ENODEV;\r\ngoto hpt372n;\r\ncase PCI_DEVICE_ID_TTI_HPT371:\r\nif (rev < 2)\r\nreturn -ENODEV;\r\nbreak;\r\ncase PCI_DEVICE_ID_TTI_HPT372:\r\nif (rev < 2)\r\nreturn -ENODEV;\r\ngoto hpt372n;\r\ncase PCI_DEVICE_ID_TTI_HPT302:\r\nif (rev < 2)\r\nreturn -ENODEV;\r\nbreak;\r\ncase PCI_DEVICE_ID_TTI_HPT372N:\r\nhpt372n:\r\nppi[0] = &info_hpt372n;\r\nbreak;\r\ndefault:\r\npr_err("PCI table is bogus, please report (%d)\n", dev->device);\r\nreturn -ENODEV;\r\n}\r\npci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, (L1_CACHE_BYTES / 4));\r\npci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x78);\r\npci_write_config_byte(dev, PCI_MIN_GNT, 0x08);\r\npci_write_config_byte(dev, PCI_MAX_LAT, 0x08);\r\npci_read_config_byte(dev, 0x5A, &irqmask);\r\nirqmask &= ~0x10;\r\npci_write_config_byte(dev, 0x5a, irqmask);\r\nif (dev->device == PCI_DEVICE_ID_TTI_HPT371) {\r\nu8 mcr1;\r\npci_read_config_byte(dev, 0x50, &mcr1);\r\nmcr1 &= ~0x04;\r\npci_write_config_byte(dev, 0x50, mcr1);\r\n}\r\npci_mhz = hpt3x2n_pci_clock(dev);\r\nf_low = (pci_mhz * 48) / 66;\r\nf_high = f_low + 2;\r\npci_write_config_dword(dev, 0x5C, (f_high << 16) | f_low | 0x100);\r\npci_write_config_byte(dev, 0x5B, 0x21);\r\nfor (adjust = 0; adjust < 8; adjust++) {\r\nif (hpt3xn_calibrate_dpll(dev))\r\nbreak;\r\npci_write_config_dword(dev, 0x5C, (f_high << 16) | f_low);\r\n}\r\nif (adjust == 8) {\r\npr_err("DPLL did not stabilize!\n");\r\nreturn -ENODEV;\r\n}\r\npr_info("bus clock %dMHz, using 66MHz DPLL\n", pci_mhz);\r\nif (pci_mhz > 60)\r\nhpriv = (void *)(PCI66 | USE_DPLL);\r\nif (dev->device == PCI_DEVICE_ID_TTI_HPT371)\r\noutb(inb(iobase + 0x9c) | 0x04, iobase + 0x9c);\r\nreturn ata_pci_bmdma_init_one(dev, ppi, &hpt3x2n_sht, hpriv, 0);\r\n}\r\nstatic int __init hpt3x2n_init(void)\r\n{\r\nreturn pci_register_driver(&hpt3x2n_pci_driver);\r\n}\r\nstatic void __exit hpt3x2n_exit(void)\r\n{\r\npci_unregister_driver(&hpt3x2n_pci_driver);\r\n}
