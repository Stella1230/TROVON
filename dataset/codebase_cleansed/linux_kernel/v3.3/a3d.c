static int a3d_read_packet(struct gameport *gameport, int length, char *data)\r\n{\r\nunsigned long flags;\r\nunsigned char u, v;\r\nunsigned int t, s;\r\nint i;\r\ni = 0;\r\nt = gameport_time(gameport, A3D_MAX_START);\r\ns = gameport_time(gameport, A3D_MAX_STROBE);\r\nlocal_irq_save(flags);\r\ngameport_trigger(gameport);\r\nv = gameport_read(gameport);\r\nwhile (t > 0 && i < length) {\r\nt--;\r\nu = v; v = gameport_read(gameport);\r\nif (~v & u & 0x10) {\r\ndata[i++] = v >> 5;\r\nt = s;\r\n}\r\n}\r\nlocal_irq_restore(flags);\r\nreturn i;\r\n}\r\nstatic int a3d_csum(char *data, int count)\r\n{\r\nint i, csum = 0;\r\nfor (i = 0; i < count - 2; i++)\r\ncsum += data[i];\r\nreturn (csum & 0x3f) != ((data[count - 2] << 3) | data[count - 1]);\r\n}\r\nstatic void a3d_read(struct a3d *a3d, unsigned char *data)\r\n{\r\nstruct input_dev *dev = a3d->dev;\r\nswitch (a3d->mode) {\r\ncase A3D_MODE_A3D:\r\ncase A3D_MODE_OEM:\r\ncase A3D_MODE_PAN:\r\ninput_report_rel(dev, REL_X, ((data[5] << 6) | (data[6] << 3) | data[ 7]) - ((data[5] & 4) << 7));\r\ninput_report_rel(dev, REL_Y, ((data[8] << 6) | (data[9] << 3) | data[10]) - ((data[8] & 4) << 7));\r\ninput_report_key(dev, BTN_RIGHT, data[2] & 1);\r\ninput_report_key(dev, BTN_LEFT, data[3] & 2);\r\ninput_report_key(dev, BTN_MIDDLE, data[3] & 4);\r\ninput_sync(dev);\r\na3d->axes[0] = ((signed char)((data[11] << 6) | (data[12] << 3) | (data[13]))) + 128;\r\na3d->axes[1] = ((signed char)((data[14] << 6) | (data[15] << 3) | (data[16]))) + 128;\r\na3d->axes[2] = ((signed char)((data[17] << 6) | (data[18] << 3) | (data[19]))) + 128;\r\na3d->axes[3] = ((signed char)((data[20] << 6) | (data[21] << 3) | (data[22]))) + 128;\r\na3d->buttons = ((data[3] << 3) | data[4]) & 0xf;\r\nbreak;\r\ncase A3D_MODE_PXL:\r\ninput_report_rel(dev, REL_X, ((data[ 9] << 6) | (data[10] << 3) | data[11]) - ((data[ 9] & 4) << 7));\r\ninput_report_rel(dev, REL_Y, ((data[12] << 6) | (data[13] << 3) | data[14]) - ((data[12] & 4) << 7));\r\ninput_report_key(dev, BTN_RIGHT, data[2] & 1);\r\ninput_report_key(dev, BTN_LEFT, data[3] & 2);\r\ninput_report_key(dev, BTN_MIDDLE, data[3] & 4);\r\ninput_report_key(dev, BTN_SIDE, data[7] & 2);\r\ninput_report_key(dev, BTN_EXTRA, data[7] & 4);\r\ninput_report_abs(dev, ABS_X, ((signed char)((data[15] << 6) | (data[16] << 3) | (data[17]))) + 128);\r\ninput_report_abs(dev, ABS_Y, ((signed char)((data[18] << 6) | (data[19] << 3) | (data[20]))) + 128);\r\ninput_report_abs(dev, ABS_RUDDER, ((signed char)((data[21] << 6) | (data[22] << 3) | (data[23]))) + 128);\r\ninput_report_abs(dev, ABS_THROTTLE, ((signed char)((data[24] << 6) | (data[25] << 3) | (data[26]))) + 128);\r\ninput_report_abs(dev, ABS_HAT0X, ( data[5] & 1) - ((data[5] >> 2) & 1));\r\ninput_report_abs(dev, ABS_HAT0Y, ((data[5] >> 1) & 1) - ((data[6] >> 2) & 1));\r\ninput_report_abs(dev, ABS_HAT1X, ((data[4] >> 1) & 1) - ( data[3] & 1));\r\ninput_report_abs(dev, ABS_HAT1Y, ((data[4] >> 2) & 1) - ( data[4] & 1));\r\ninput_report_key(dev, BTN_TRIGGER, data[8] & 1);\r\ninput_report_key(dev, BTN_THUMB, data[8] & 2);\r\ninput_report_key(dev, BTN_TOP, data[8] & 4);\r\ninput_report_key(dev, BTN_PINKIE, data[7] & 1);\r\ninput_sync(dev);\r\nbreak;\r\n}\r\n}\r\nstatic void a3d_poll(struct gameport *gameport)\r\n{\r\nstruct a3d *a3d = gameport_get_drvdata(gameport);\r\nunsigned char data[A3D_MAX_LENGTH];\r\na3d->reads++;\r\nif (a3d_read_packet(a3d->gameport, a3d->length, data) != a3d->length ||\r\ndata[0] != a3d->mode || a3d_csum(data, a3d->length))\r\na3d->bads++;\r\nelse\r\na3d_read(a3d, data);\r\n}\r\nstatic int a3d_adc_cooked_read(struct gameport *gameport, int *axes, int *buttons)\r\n{\r\nstruct a3d *a3d = gameport->port_data;\r\nint i;\r\nfor (i = 0; i < 4; i++)\r\naxes[i] = (a3d->axes[i] < 254) ? a3d->axes[i] : -1;\r\n*buttons = a3d->buttons;\r\nreturn 0;\r\n}\r\nstatic int a3d_adc_open(struct gameport *gameport, int mode)\r\n{\r\nstruct a3d *a3d = gameport->port_data;\r\nif (mode != GAMEPORT_MODE_COOKED)\r\nreturn -1;\r\ngameport_start_polling(a3d->gameport);\r\nreturn 0;\r\n}\r\nstatic void a3d_adc_close(struct gameport *gameport)\r\n{\r\nstruct a3d *a3d = gameport->port_data;\r\ngameport_stop_polling(a3d->gameport);\r\n}\r\nstatic int a3d_open(struct input_dev *dev)\r\n{\r\nstruct a3d *a3d = input_get_drvdata(dev);\r\ngameport_start_polling(a3d->gameport);\r\nreturn 0;\r\n}\r\nstatic void a3d_close(struct input_dev *dev)\r\n{\r\nstruct a3d *a3d = input_get_drvdata(dev);\r\ngameport_stop_polling(a3d->gameport);\r\n}\r\nstatic int a3d_connect(struct gameport *gameport, struct gameport_driver *drv)\r\n{\r\nstruct a3d *a3d;\r\nstruct input_dev *input_dev;\r\nstruct gameport *adc;\r\nunsigned char data[A3D_MAX_LENGTH];\r\nint i;\r\nint err;\r\na3d = kzalloc(sizeof(struct a3d), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!a3d || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto fail1;\r\n}\r\na3d->dev = input_dev;\r\na3d->gameport = gameport;\r\ngameport_set_drvdata(gameport, a3d);\r\nerr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\r\nif (err)\r\ngoto fail1;\r\ni = a3d_read_packet(gameport, A3D_MAX_LENGTH, data);\r\nif (!i || a3d_csum(data, i)) {\r\nerr = -ENODEV;\r\ngoto fail2;\r\n}\r\na3d->mode = data[0];\r\nif (!a3d->mode || a3d->mode > 5) {\r\nprintk(KERN_WARNING "a3d.c: Unknown A3D device detected "\r\n"(%s, id=%d), contact <vojtech@ucw.cz>\n", gameport->phys, a3d->mode);\r\nerr = -ENODEV;\r\ngoto fail2;\r\n}\r\ngameport_set_poll_handler(gameport, a3d_poll);\r\ngameport_set_poll_interval(gameport, 20);\r\nsnprintf(a3d->phys, sizeof(a3d->phys), "%s/input0", gameport->phys);\r\ninput_dev->name = a3d_names[a3d->mode];\r\ninput_dev->phys = a3d->phys;\r\ninput_dev->id.bustype = BUS_GAMEPORT;\r\ninput_dev->id.vendor = GAMEPORT_ID_VENDOR_MADCATZ;\r\ninput_dev->id.product = a3d->mode;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &gameport->dev;\r\ninput_dev->open = a3d_open;\r\ninput_dev->close = a3d_close;\r\ninput_set_drvdata(input_dev, a3d);\r\nif (a3d->mode == A3D_MODE_PXL) {\r\nint axes[] = { ABS_X, ABS_Y, ABS_THROTTLE, ABS_RUDDER };\r\na3d->length = 33;\r\ninput_dev->evbit[0] |= BIT_MASK(EV_ABS) | BIT_MASK(EV_KEY) |\r\nBIT_MASK(EV_REL);\r\ninput_dev->relbit[0] |= BIT_MASK(REL_X) | BIT_MASK(REL_Y);\r\ninput_dev->absbit[0] |= BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) |\r\nBIT_MASK(ABS_THROTTLE) | BIT_MASK(ABS_RUDDER) |\r\nBIT_MASK(ABS_HAT0X) | BIT_MASK(ABS_HAT0Y) |\r\nBIT_MASK(ABS_HAT1X) | BIT_MASK(ABS_HAT1Y);\r\ninput_dev->keybit[BIT_WORD(BTN_MOUSE)] |= BIT_MASK(BTN_RIGHT) |\r\nBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_MIDDLE) |\r\nBIT_MASK(BTN_SIDE) | BIT_MASK(BTN_EXTRA);\r\ninput_dev->keybit[BIT_WORD(BTN_JOYSTICK)] |=\r\nBIT_MASK(BTN_TRIGGER) | BIT_MASK(BTN_THUMB) |\r\nBIT_MASK(BTN_TOP) | BIT_MASK(BTN_PINKIE);\r\na3d_read(a3d, data);\r\nfor (i = 0; i < 4; i++) {\r\nif (i < 2)\r\ninput_set_abs_params(input_dev, axes[i],\r\n48, input_abs_get_val(input_dev, axes[i]) * 2 - 48, 0, 8);\r\nelse\r\ninput_set_abs_params(input_dev, axes[i], 2, 253, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_HAT0X + i, -1, 1, 0, 0);\r\n}\r\n} else {\r\na3d->length = 29;\r\ninput_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\r\ninput_dev->relbit[0] |= BIT_MASK(REL_X) | BIT_MASK(REL_Y);\r\ninput_dev->keybit[BIT_WORD(BTN_MOUSE)] |= BIT_MASK(BTN_RIGHT) |\r\nBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_MIDDLE);\r\na3d_read(a3d, data);\r\nif (!(a3d->adc = adc = gameport_allocate_port()))\r\nprintk(KERN_ERR "a3d: Not enough memory for ADC port\n");\r\nelse {\r\nadc->port_data = a3d;\r\nadc->open = a3d_adc_open;\r\nadc->close = a3d_adc_close;\r\nadc->cooked_read = a3d_adc_cooked_read;\r\nadc->fuzz = 1;\r\ngameport_set_name(adc, a3d_names[a3d->mode]);\r\ngameport_set_phys(adc, "%s/gameport0", gameport->phys);\r\nadc->dev.parent = &gameport->dev;\r\ngameport_register_port(adc);\r\n}\r\n}\r\nerr = input_register_device(a3d->dev);\r\nif (err)\r\ngoto fail3;\r\nreturn 0;\r\nfail3: if (a3d->adc)\r\ngameport_unregister_port(a3d->adc);\r\nfail2: gameport_close(gameport);\r\nfail1: gameport_set_drvdata(gameport, NULL);\r\ninput_free_device(input_dev);\r\nkfree(a3d);\r\nreturn err;\r\n}\r\nstatic void a3d_disconnect(struct gameport *gameport)\r\n{\r\nstruct a3d *a3d = gameport_get_drvdata(gameport);\r\ninput_unregister_device(a3d->dev);\r\nif (a3d->adc)\r\ngameport_unregister_port(a3d->adc);\r\ngameport_close(gameport);\r\ngameport_set_drvdata(gameport, NULL);\r\nkfree(a3d);\r\n}\r\nstatic int __init a3d_init(void)\r\n{\r\nreturn gameport_register_driver(&a3d_drv);\r\n}\r\nstatic void __exit a3d_exit(void)\r\n{\r\ngameport_unregister_driver(&a3d_drv);\r\n}
