static void __oct5066_page(struct map_info *map, __u8 byte)\r\n{\r\noutb(byte,PAGE_IO);\r\npage_n_dev = byte;\r\n}\r\nstatic inline void oct5066_page(struct map_info *map, unsigned long ofs)\r\n{\r\n__u8 byte = map->map_priv_1 | (ofs >> WINDOW_SHIFT);\r\nif (page_n_dev != byte)\r\n__oct5066_page(map, byte);\r\n}\r\nstatic map_word oct5066_read8(struct map_info *map, unsigned long ofs)\r\n{\r\nmap_word ret;\r\nspin_lock(&oct5066_spin);\r\noct5066_page(map, ofs);\r\nret.x[0] = readb(iomapadr + (ofs & WINDOW_MASK));\r\nspin_unlock(&oct5066_spin);\r\nreturn ret;\r\n}\r\nstatic void oct5066_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)\r\n{\r\nwhile(len) {\r\nunsigned long thislen = len;\r\nif (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))\r\nthislen = WINDOW_LENGTH-(from & WINDOW_MASK);\r\nspin_lock(&oct5066_spin);\r\noct5066_page(map, from);\r\nmemcpy_fromio(to, iomapadr + from, thislen);\r\nspin_unlock(&oct5066_spin);\r\nto += thislen;\r\nfrom += thislen;\r\nlen -= thislen;\r\n}\r\n}\r\nstatic void oct5066_write8(struct map_info *map, map_word d, unsigned long adr)\r\n{\r\nspin_lock(&oct5066_spin);\r\noct5066_page(map, adr);\r\nwriteb(d.x[0], iomapadr + (adr & WINDOW_MASK));\r\nspin_unlock(&oct5066_spin);\r\n}\r\nstatic void oct5066_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)\r\n{\r\nwhile(len) {\r\nunsigned long thislen = len;\r\nif (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))\r\nthislen = WINDOW_LENGTH-(to & WINDOW_MASK);\r\nspin_lock(&oct5066_spin);\r\noct5066_page(map, to);\r\nmemcpy_toio(iomapadr + to, from, thislen);\r\nspin_unlock(&oct5066_spin);\r\nto += thislen;\r\nfrom += thislen;\r\nlen -= thislen;\r\n}\r\n}\r\nstatic int __init OctProbe(void)\r\n{\r\nunsigned int Base = (1 << 6);\r\nunsigned long I;\r\nunsigned long Values[10];\r\nfor (I = 0; I != 20; I++)\r\n{\r\noutb(Base + (I%10),PAGE_IO);\r\nif (I < 10)\r\n{\r\nValues[I%10] = readl(iomapadr);\r\nif (I > 0 && Values[I%10] == Values[0])\r\nreturn -EAGAIN;\r\n}\r\nelse\r\n{\r\nif (Values[I%10] != readl(iomapadr))\r\nreturn -EAGAIN;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid cleanup_oct5066(void)\r\n{\r\nint i;\r\nfor (i=0; i<2; i++) {\r\nif (oct5066_mtd[i]) {\r\nmtd_device_unregister(oct5066_mtd[i]);\r\nmap_destroy(oct5066_mtd[i]);\r\n}\r\n}\r\niounmap((void *)iomapadr);\r\nrelease_region(PAGE_IO, 1);\r\n}\r\nstatic int __init init_oct5066(void)\r\n{\r\nint i;\r\nint ret = 0;\r\nif (!request_region(PAGE_IO,1,"Octagon SSD")) {\r\nprintk(KERN_NOTICE "5066: Page Register in Use\n");\r\nreturn -EAGAIN;\r\n}\r\niomapadr = (unsigned long)ioremap(WINDOW_START, WINDOW_LENGTH);\r\nif (!iomapadr) {\r\nprintk(KERN_NOTICE "Failed to ioremap memory region\n");\r\nret = -EIO;\r\ngoto out_rel;\r\n}\r\nif (OctProbe() != 0) {\r\nprintk(KERN_NOTICE "5066: Octagon Probe Failed, is this an Octagon 5066 SBC?\n");\r\niounmap((void *)iomapadr);\r\nret = -EAGAIN;\r\ngoto out_unmap;\r\n}\r\nprintk("Octagon 5066 SSD IO:0x%x MEM:0x%x-0x%x\n",PAGE_IO,WINDOW_START,\r\nWINDOW_START+WINDOW_LENGTH);\r\nfor (i=0; i<2; i++) {\r\noct5066_mtd[i] = do_map_probe("cfi_probe", &oct5066_map[i]);\r\nif (!oct5066_mtd[i])\r\noct5066_mtd[i] = do_map_probe("jedec", &oct5066_map[i]);\r\nif (!oct5066_mtd[i])\r\noct5066_mtd[i] = do_map_probe("map_ram", &oct5066_map[i]);\r\nif (!oct5066_mtd[i])\r\noct5066_mtd[i] = do_map_probe("map_rom", &oct5066_map[i]);\r\nif (oct5066_mtd[i]) {\r\noct5066_mtd[i]->owner = THIS_MODULE;\r\nmtd_device_register(oct5066_mtd[i], NULL, 0);\r\n}\r\n}\r\nif (!oct5066_mtd[0] && !oct5066_mtd[1]) {\r\ncleanup_oct5066();\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\nout_unmap:\r\niounmap((void *)iomapadr);\r\nout_rel:\r\nrelease_region(PAGE_IO, 1);\r\nreturn ret;\r\n}
