static struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,\r\nstruct device_driver *driver,\r\nstruct device *device)\r\n{\r\nstruct w1_master *dev;\r\nint err;\r\ndev = kzalloc(sizeof(struct w1_master) + sizeof(struct w1_bus_master), GFP_KERNEL);\r\nif (!dev) {\r\nprintk(KERN_ERR\r\n"Failed to allocate %zd bytes for new w1 device.\n",\r\nsizeof(struct w1_master));\r\nreturn NULL;\r\n}\r\ndev->bus_master = (struct w1_bus_master *)(dev + 1);\r\ndev->owner = THIS_MODULE;\r\ndev->max_slave_count = slave_count;\r\ndev->slave_count = 0;\r\ndev->attempts = 0;\r\ndev->initialized = 0;\r\ndev->id = id;\r\ndev->slave_ttl = slave_ttl;\r\ndev->search_count = w1_search_count;\r\ndev->enable_pullup = w1_enable_pullup;\r\natomic_set(&dev->refcnt, 2);\r\nINIT_LIST_HEAD(&dev->slist);\r\nmutex_init(&dev->mutex);\r\nmemcpy(&dev->dev, device, sizeof(struct device));\r\ndev_set_name(&dev->dev, "w1_bus_master%u", dev->id);\r\nsnprintf(dev->name, sizeof(dev->name), "w1_bus_master%u", dev->id);\r\ndev->dev.init_name = dev->name;\r\ndev->driver = driver;\r\ndev->seq = 1;\r\nerr = device_register(&dev->dev);\r\nif (err) {\r\nprintk(KERN_ERR "Failed to register master device. err=%d\n", err);\r\nmemset(dev, 0, sizeof(struct w1_master));\r\nkfree(dev);\r\ndev = NULL;\r\n}\r\nreturn dev;\r\n}\r\nstatic void w1_free_dev(struct w1_master *dev)\r\n{\r\ndevice_unregister(&dev->dev);\r\n}\r\nint w1_add_master_device(struct w1_bus_master *master)\r\n{\r\nstruct w1_master *dev, *entry;\r\nint retval = 0;\r\nstruct w1_netlink_msg msg;\r\nint id, found;\r\nif (!(master->touch_bit && master->reset_bus) &&\r\n!(master->write_bit && master->read_bit) &&\r\n!(master->write_byte && master->read_byte && master->reset_bus)) {\r\nprintk(KERN_ERR "w1_add_master_device: invalid function set\n");\r\nreturn(-EINVAL);\r\n}\r\nif (!master->write_byte && !master->touch_bit && master->set_pullup) {\r\nprintk(KERN_ERR "w1_add_master_device: set_pullup requires "\r\n"write_byte or touch_bit, disabling\n");\r\nmaster->set_pullup = NULL;\r\n}\r\nmutex_lock(&w1_mlock);\r\nid = 0;\r\ndo {\r\n++id;\r\nfound = 0;\r\nlist_for_each_entry(entry, &w1_masters, w1_master_entry) {\r\nif (entry->id == id) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\n} while (found);\r\ndev = w1_alloc_dev(id, w1_max_slave_count, w1_max_slave_ttl,\r\n&w1_master_driver, &w1_master_device);\r\nif (!dev) {\r\nmutex_unlock(&w1_mlock);\r\nreturn -ENOMEM;\r\n}\r\nretval = w1_create_master_attributes(dev);\r\nif (retval) {\r\nmutex_unlock(&w1_mlock);\r\ngoto err_out_free_dev;\r\n}\r\nmemcpy(dev->bus_master, master, sizeof(struct w1_bus_master));\r\ndev->initialized = 1;\r\ndev->thread = kthread_run(&w1_process, dev, "%s", dev->name);\r\nif (IS_ERR(dev->thread)) {\r\nretval = PTR_ERR(dev->thread);\r\ndev_err(&dev->dev,\r\n"Failed to create new kernel thread. err=%d\n",\r\nretval);\r\nmutex_unlock(&w1_mlock);\r\ngoto err_out_rm_attr;\r\n}\r\nlist_add(&dev->w1_master_entry, &w1_masters);\r\nmutex_unlock(&w1_mlock);\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.id.mst.id = dev->id;\r\nmsg.type = W1_MASTER_ADD;\r\nw1_netlink_send(dev, &msg);\r\nreturn 0;\r\n#if 0\r\nerr_out_kill_thread:\r\nkthread_stop(dev->thread);\r\n#endif\r\nerr_out_rm_attr:\r\nw1_destroy_master_attributes(dev);\r\nerr_out_free_dev:\r\nw1_free_dev(dev);\r\nreturn retval;\r\n}\r\nvoid __w1_remove_master_device(struct w1_master *dev)\r\n{\r\nstruct w1_netlink_msg msg;\r\nstruct w1_slave *sl, *sln;\r\nkthread_stop(dev->thread);\r\nmutex_lock(&w1_mlock);\r\nlist_del(&dev->w1_master_entry);\r\nmutex_unlock(&w1_mlock);\r\nmutex_lock(&dev->mutex);\r\nlist_for_each_entry_safe(sl, sln, &dev->slist, w1_slave_entry)\r\nw1_slave_detach(sl);\r\nw1_destroy_master_attributes(dev);\r\nmutex_unlock(&dev->mutex);\r\natomic_dec(&dev->refcnt);\r\nwhile (atomic_read(&dev->refcnt)) {\r\ndev_info(&dev->dev, "Waiting for %s to become free: refcnt=%d.\n",\r\ndev->name, atomic_read(&dev->refcnt));\r\nif (msleep_interruptible(1000))\r\nflush_signals(current);\r\n}\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.id.mst.id = dev->id;\r\nmsg.type = W1_MASTER_REMOVE;\r\nw1_netlink_send(dev, &msg);\r\nw1_free_dev(dev);\r\n}\r\nvoid w1_remove_master_device(struct w1_bus_master *bm)\r\n{\r\nstruct w1_master *dev, *found = NULL;\r\nlist_for_each_entry(dev, &w1_masters, w1_master_entry) {\r\nif (!dev->initialized)\r\ncontinue;\r\nif (dev->bus_master->data == bm->data) {\r\nfound = dev;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nprintk(KERN_ERR "Device doesn't exist.\n");\r\nreturn;\r\n}\r\n__w1_remove_master_device(found);\r\n}
