int iscsi_login_rx_data(\r\nstruct iscsi_conn *conn,\r\nchar *buf,\r\nint length)\r\n{\r\nint rx_got;\r\nstruct kvec iov;\r\nmemset(&iov, 0, sizeof(struct kvec));\r\niov.iov_len = length;\r\niov.iov_base = buf;\r\nconn->of_marker += length;\r\nrx_got = rx_data(conn, &iov, 1, length);\r\nif (rx_got != length) {\r\npr_err("rx_data returned %d, expecting %d.\n",\r\nrx_got, length);\r\nreturn -1;\r\n}\r\nreturn 0 ;\r\n}\r\nint iscsi_login_tx_data(\r\nstruct iscsi_conn *conn,\r\nchar *pdu_buf,\r\nchar *text_buf,\r\nint text_length)\r\n{\r\nint length, tx_sent;\r\nstruct kvec iov[2];\r\nlength = (ISCSI_HDR_LEN + text_length);\r\nmemset(&iov[0], 0, 2 * sizeof(struct kvec));\r\niov[0].iov_len = ISCSI_HDR_LEN;\r\niov[0].iov_base = pdu_buf;\r\niov[1].iov_len = text_length;\r\niov[1].iov_base = text_buf;\r\nconn->if_marker += length;\r\ntx_sent = tx_data(conn, &iov[0], 2, length);\r\nif (tx_sent != length) {\r\npr_err("tx_data returned %d, expecting %d.\n",\r\ntx_sent, length);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid iscsi_dump_conn_ops(struct iscsi_conn_ops *conn_ops)\r\n{\r\npr_debug("HeaderDigest: %s\n", (conn_ops->HeaderDigest) ?\r\n"CRC32C" : "None");\r\npr_debug("DataDigest: %s\n", (conn_ops->DataDigest) ?\r\n"CRC32C" : "None");\r\npr_debug("MaxRecvDataSegmentLength: %u\n",\r\nconn_ops->MaxRecvDataSegmentLength);\r\npr_debug("OFMarker: %s\n", (conn_ops->OFMarker) ? "Yes" : "No");\r\npr_debug("IFMarker: %s\n", (conn_ops->IFMarker) ? "Yes" : "No");\r\nif (conn_ops->OFMarker)\r\npr_debug("OFMarkInt: %u\n", conn_ops->OFMarkInt);\r\nif (conn_ops->IFMarker)\r\npr_debug("IFMarkInt: %u\n", conn_ops->IFMarkInt);\r\n}\r\nvoid iscsi_dump_sess_ops(struct iscsi_sess_ops *sess_ops)\r\n{\r\npr_debug("InitiatorName: %s\n", sess_ops->InitiatorName);\r\npr_debug("InitiatorAlias: %s\n", sess_ops->InitiatorAlias);\r\npr_debug("TargetName: %s\n", sess_ops->TargetName);\r\npr_debug("TargetAlias: %s\n", sess_ops->TargetAlias);\r\npr_debug("TargetPortalGroupTag: %hu\n",\r\nsess_ops->TargetPortalGroupTag);\r\npr_debug("MaxConnections: %hu\n", sess_ops->MaxConnections);\r\npr_debug("InitialR2T: %s\n",\r\n(sess_ops->InitialR2T) ? "Yes" : "No");\r\npr_debug("ImmediateData: %s\n", (sess_ops->ImmediateData) ?\r\n"Yes" : "No");\r\npr_debug("MaxBurstLength: %u\n", sess_ops->MaxBurstLength);\r\npr_debug("FirstBurstLength: %u\n", sess_ops->FirstBurstLength);\r\npr_debug("DefaultTime2Wait: %hu\n", sess_ops->DefaultTime2Wait);\r\npr_debug("DefaultTime2Retain: %hu\n",\r\nsess_ops->DefaultTime2Retain);\r\npr_debug("MaxOutstandingR2T: %hu\n",\r\nsess_ops->MaxOutstandingR2T);\r\npr_debug("DataPDUInOrder: %s\n",\r\n(sess_ops->DataPDUInOrder) ? "Yes" : "No");\r\npr_debug("DataSequenceInOrder: %s\n",\r\n(sess_ops->DataSequenceInOrder) ? "Yes" : "No");\r\npr_debug("ErrorRecoveryLevel: %hu\n",\r\nsess_ops->ErrorRecoveryLevel);\r\npr_debug("SessionType: %s\n", (sess_ops->SessionType) ?\r\n"Discovery" : "Normal");\r\n}\r\nvoid iscsi_print_params(struct iscsi_param_list *param_list)\r\n{\r\nstruct iscsi_param *param;\r\nlist_for_each_entry(param, &param_list->param_list, p_list)\r\npr_debug("%s: %s\n", param->name, param->value);\r\n}\r\nstatic struct iscsi_param *iscsi_set_default_param(struct iscsi_param_list *param_list,\r\nchar *name, char *value, u8 phase, u8 scope, u8 sender,\r\nu16 type_range, u8 use)\r\n{\r\nstruct iscsi_param *param = NULL;\r\nparam = kzalloc(sizeof(struct iscsi_param), GFP_KERNEL);\r\nif (!param) {\r\npr_err("Unable to allocate memory for parameter.\n");\r\ngoto out;\r\n}\r\nINIT_LIST_HEAD(&param->p_list);\r\nparam->name = kzalloc(strlen(name) + 1, GFP_KERNEL);\r\nif (!param->name) {\r\npr_err("Unable to allocate memory for parameter name.\n");\r\ngoto out;\r\n}\r\nparam->value = kzalloc(strlen(value) + 1, GFP_KERNEL);\r\nif (!param->value) {\r\npr_err("Unable to allocate memory for parameter value.\n");\r\ngoto out;\r\n}\r\nmemcpy(param->name, name, strlen(name));\r\nparam->name[strlen(name)] = '\0';\r\nmemcpy(param->value, value, strlen(value));\r\nparam->value[strlen(value)] = '\0';\r\nparam->phase = phase;\r\nparam->scope = scope;\r\nparam->sender = sender;\r\nparam->use = use;\r\nparam->type_range = type_range;\r\nswitch (param->type_range) {\r\ncase TYPERANGE_BOOL_AND:\r\nparam->type = TYPE_BOOL_AND;\r\nbreak;\r\ncase TYPERANGE_BOOL_OR:\r\nparam->type = TYPE_BOOL_OR;\r\nbreak;\r\ncase TYPERANGE_0_TO_2:\r\ncase TYPERANGE_0_TO_3600:\r\ncase TYPERANGE_0_TO_32767:\r\ncase TYPERANGE_0_TO_65535:\r\ncase TYPERANGE_1_TO_65535:\r\ncase TYPERANGE_2_TO_3600:\r\ncase TYPERANGE_512_TO_16777215:\r\nparam->type = TYPE_NUMBER;\r\nbreak;\r\ncase TYPERANGE_AUTH:\r\ncase TYPERANGE_DIGEST:\r\nparam->type = TYPE_VALUE_LIST | TYPE_STRING;\r\nbreak;\r\ncase TYPERANGE_MARKINT:\r\nparam->type = TYPE_NUMBER_RANGE;\r\nparam->type_range |= TYPERANGE_1_TO_65535;\r\nbreak;\r\ncase TYPERANGE_ISCSINAME:\r\ncase TYPERANGE_SESSIONTYPE:\r\ncase TYPERANGE_TARGETADDRESS:\r\ncase TYPERANGE_UTF8:\r\nparam->type = TYPE_STRING;\r\nbreak;\r\ndefault:\r\npr_err("Unknown type_range 0x%02x\n",\r\nparam->type_range);\r\ngoto out;\r\n}\r\nlist_add_tail(&param->p_list, &param_list->param_list);\r\nreturn param;\r\nout:\r\nif (param) {\r\nkfree(param->value);\r\nkfree(param->name);\r\nkfree(param);\r\n}\r\nreturn NULL;\r\n}\r\nint iscsi_create_default_params(struct iscsi_param_list **param_list_ptr)\r\n{\r\nstruct iscsi_param *param = NULL;\r\nstruct iscsi_param_list *pl;\r\npl = kzalloc(sizeof(struct iscsi_param_list), GFP_KERNEL);\r\nif (!pl) {\r\npr_err("Unable to allocate memory for"\r\n" struct iscsi_param_list.\n");\r\nreturn -1 ;\r\n}\r\nINIT_LIST_HEAD(&pl->param_list);\r\nINIT_LIST_HEAD(&pl->extra_response_list);\r\nparam = iscsi_set_default_param(pl, AUTHMETHOD, INITIAL_AUTHMETHOD,\r\nPHASE_SECURITY, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\r\nTYPERANGE_AUTH, USE_INITIAL_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, HEADERDIGEST, INITIAL_HEADERDIGEST,\r\nPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\r\nTYPERANGE_DIGEST, USE_INITIAL_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, DATADIGEST, INITIAL_DATADIGEST,\r\nPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\r\nTYPERANGE_DIGEST, USE_INITIAL_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, MAXCONNECTIONS,\r\nINITIAL_MAXCONNECTIONS, PHASE_OPERATIONAL,\r\nSCOPE_SESSION_WIDE, SENDER_BOTH,\r\nTYPERANGE_1_TO_65535, USE_LEADING_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, SENDTARGETS, INITIAL_SENDTARGETS,\r\nPHASE_FFP0, SCOPE_SESSION_WIDE, SENDER_INITIATOR,\r\nTYPERANGE_UTF8, 0);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, TARGETNAME, INITIAL_TARGETNAME,\r\nPHASE_DECLARATIVE, SCOPE_SESSION_WIDE, SENDER_BOTH,\r\nTYPERANGE_ISCSINAME, USE_ALL);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, INITIATORNAME,\r\nINITIAL_INITIATORNAME, PHASE_DECLARATIVE,\r\nSCOPE_SESSION_WIDE, SENDER_INITIATOR,\r\nTYPERANGE_ISCSINAME, USE_INITIAL_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, TARGETALIAS, INITIAL_TARGETALIAS,\r\nPHASE_DECLARATIVE, SCOPE_SESSION_WIDE, SENDER_TARGET,\r\nTYPERANGE_UTF8, USE_ALL);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, INITIATORALIAS,\r\nINITIAL_INITIATORALIAS, PHASE_DECLARATIVE,\r\nSCOPE_SESSION_WIDE, SENDER_INITIATOR, TYPERANGE_UTF8,\r\nUSE_ALL);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, TARGETADDRESS,\r\nINITIAL_TARGETADDRESS, PHASE_DECLARATIVE,\r\nSCOPE_SESSION_WIDE, SENDER_TARGET,\r\nTYPERANGE_TARGETADDRESS, USE_ALL);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, TARGETPORTALGROUPTAG,\r\nINITIAL_TARGETPORTALGROUPTAG,\r\nPHASE_DECLARATIVE, SCOPE_SESSION_WIDE, SENDER_TARGET,\r\nTYPERANGE_0_TO_65535, USE_INITIAL_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, INITIALR2T, INITIAL_INITIALR2T,\r\nPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\r\nTYPERANGE_BOOL_OR, USE_LEADING_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, IMMEDIATEDATA,\r\nINITIAL_IMMEDIATEDATA, PHASE_OPERATIONAL,\r\nSCOPE_SESSION_WIDE, SENDER_BOTH, TYPERANGE_BOOL_AND,\r\nUSE_LEADING_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, MAXRECVDATASEGMENTLENGTH,\r\nINITIAL_MAXRECVDATASEGMENTLENGTH,\r\nPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\r\nTYPERANGE_512_TO_16777215, USE_ALL);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, MAXBURSTLENGTH,\r\nINITIAL_MAXBURSTLENGTH, PHASE_OPERATIONAL,\r\nSCOPE_SESSION_WIDE, SENDER_BOTH,\r\nTYPERANGE_512_TO_16777215, USE_LEADING_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, FIRSTBURSTLENGTH,\r\nINITIAL_FIRSTBURSTLENGTH,\r\nPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\r\nTYPERANGE_512_TO_16777215, USE_LEADING_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, DEFAULTTIME2WAIT,\r\nINITIAL_DEFAULTTIME2WAIT,\r\nPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\r\nTYPERANGE_0_TO_3600, USE_LEADING_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, DEFAULTTIME2RETAIN,\r\nINITIAL_DEFAULTTIME2RETAIN,\r\nPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\r\nTYPERANGE_0_TO_3600, USE_LEADING_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, MAXOUTSTANDINGR2T,\r\nINITIAL_MAXOUTSTANDINGR2T,\r\nPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\r\nTYPERANGE_1_TO_65535, USE_LEADING_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, DATAPDUINORDER,\r\nINITIAL_DATAPDUINORDER, PHASE_OPERATIONAL,\r\nSCOPE_SESSION_WIDE, SENDER_BOTH, TYPERANGE_BOOL_OR,\r\nUSE_LEADING_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, DATASEQUENCEINORDER,\r\nINITIAL_DATASEQUENCEINORDER,\r\nPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\r\nTYPERANGE_BOOL_OR, USE_LEADING_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, ERRORRECOVERYLEVEL,\r\nINITIAL_ERRORRECOVERYLEVEL,\r\nPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\r\nTYPERANGE_0_TO_2, USE_LEADING_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, SESSIONTYPE, INITIAL_SESSIONTYPE,\r\nPHASE_DECLARATIVE, SCOPE_SESSION_WIDE, SENDER_INITIATOR,\r\nTYPERANGE_SESSIONTYPE, USE_LEADING_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, IFMARKER, INITIAL_IFMARKER,\r\nPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\r\nTYPERANGE_BOOL_AND, USE_INITIAL_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, OFMARKER, INITIAL_OFMARKER,\r\nPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\r\nTYPERANGE_BOOL_AND, USE_INITIAL_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, IFMARKINT, INITIAL_IFMARKINT,\r\nPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\r\nTYPERANGE_MARKINT, USE_INITIAL_ONLY);\r\nif (!param)\r\ngoto out;\r\nparam = iscsi_set_default_param(pl, OFMARKINT, INITIAL_OFMARKINT,\r\nPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\r\nTYPERANGE_MARKINT, USE_INITIAL_ONLY);\r\nif (!param)\r\ngoto out;\r\n*param_list_ptr = pl;\r\nreturn 0;\r\nout:\r\niscsi_release_param_list(pl);\r\nreturn -1;\r\n}\r\nint iscsi_set_keys_to_negotiate(\r\nint sessiontype,\r\nstruct iscsi_param_list *param_list)\r\n{\r\nstruct iscsi_param *param;\r\nlist_for_each_entry(param, &param_list->param_list, p_list) {\r\nparam->state = 0;\r\nif (!strcmp(param->name, AUTHMETHOD)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, HEADERDIGEST)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, DATADIGEST)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, MAXCONNECTIONS)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, TARGETNAME)) {\r\ncontinue;\r\n} else if (!strcmp(param->name, INITIATORNAME)) {\r\ncontinue;\r\n} else if (!strcmp(param->name, TARGETALIAS)) {\r\nif (param->value)\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, INITIATORALIAS)) {\r\ncontinue;\r\n} else if (!strcmp(param->name, TARGETPORTALGROUPTAG)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, INITIALR2T)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, IMMEDIATEDATA)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, MAXBURSTLENGTH)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, FIRSTBURSTLENGTH)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, DEFAULTTIME2WAIT)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, DEFAULTTIME2RETAIN)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, MAXOUTSTANDINGR2T)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, DATAPDUINORDER)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, DATASEQUENCEINORDER)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, ERRORRECOVERYLEVEL)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, SESSIONTYPE)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, IFMARKER)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, OFMARKER)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, IFMARKINT)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n} else if (!strcmp(param->name, OFMARKINT)) {\r\nSET_PSTATE_NEGOTIATE(param);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint iscsi_set_keys_irrelevant_for_discovery(\r\nstruct iscsi_param_list *param_list)\r\n{\r\nstruct iscsi_param *param;\r\nlist_for_each_entry(param, &param_list->param_list, p_list) {\r\nif (!strcmp(param->name, MAXCONNECTIONS))\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nelse if (!strcmp(param->name, INITIALR2T))\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nelse if (!strcmp(param->name, IMMEDIATEDATA))\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nelse if (!strcmp(param->name, MAXBURSTLENGTH))\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nelse if (!strcmp(param->name, FIRSTBURSTLENGTH))\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nelse if (!strcmp(param->name, MAXOUTSTANDINGR2T))\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nelse if (!strcmp(param->name, DATAPDUINORDER))\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nelse if (!strcmp(param->name, DATASEQUENCEINORDER))\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nelse if (!strcmp(param->name, ERRORRECOVERYLEVEL))\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nelse if (!strcmp(param->name, DEFAULTTIME2WAIT))\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nelse if (!strcmp(param->name, DEFAULTTIME2RETAIN))\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nelse if (!strcmp(param->name, IFMARKER))\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nelse if (!strcmp(param->name, OFMARKER))\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nelse if (!strcmp(param->name, IFMARKINT))\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nelse if (!strcmp(param->name, OFMARKINT))\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\n}\r\nreturn 0;\r\n}\r\nint iscsi_copy_param_list(\r\nstruct iscsi_param_list **dst_param_list,\r\nstruct iscsi_param_list *src_param_list,\r\nint leading)\r\n{\r\nstruct iscsi_param *param = NULL;\r\nstruct iscsi_param *new_param = NULL;\r\nstruct iscsi_param_list *param_list = NULL;\r\nparam_list = kzalloc(sizeof(struct iscsi_param_list), GFP_KERNEL);\r\nif (!param_list) {\r\npr_err("Unable to allocate memory for struct iscsi_param_list.\n");\r\ngoto err_out;\r\n}\r\nINIT_LIST_HEAD(&param_list->param_list);\r\nINIT_LIST_HEAD(&param_list->extra_response_list);\r\nlist_for_each_entry(param, &src_param_list->param_list, p_list) {\r\nif (!leading && (param->scope & SCOPE_SESSION_WIDE)) {\r\nif ((strcmp(param->name, "TargetName") != 0) &&\r\n(strcmp(param->name, "InitiatorName") != 0) &&\r\n(strcmp(param->name, "TargetPortalGroupTag") != 0))\r\ncontinue;\r\n}\r\nnew_param = kzalloc(sizeof(struct iscsi_param), GFP_KERNEL);\r\nif (!new_param) {\r\npr_err("Unable to allocate memory for struct iscsi_param.\n");\r\ngoto err_out;\r\n}\r\nnew_param->name = kstrdup(param->name, GFP_KERNEL);\r\nnew_param->value = kstrdup(param->value, GFP_KERNEL);\r\nif (!new_param->value || !new_param->name) {\r\nkfree(new_param->value);\r\nkfree(new_param->name);\r\nkfree(new_param);\r\npr_err("Unable to allocate memory for parameter name/value.\n");\r\ngoto err_out;\r\n}\r\nnew_param->set_param = param->set_param;\r\nnew_param->phase = param->phase;\r\nnew_param->scope = param->scope;\r\nnew_param->sender = param->sender;\r\nnew_param->type = param->type;\r\nnew_param->use = param->use;\r\nnew_param->type_range = param->type_range;\r\nlist_add_tail(&new_param->p_list, &param_list->param_list);\r\n}\r\nif (!list_empty(&param_list->param_list)) {\r\n*dst_param_list = param_list;\r\n} else {\r\npr_err("No parameters allocated.\n");\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\niscsi_release_param_list(param_list);\r\nreturn -1;\r\n}\r\nstatic void iscsi_release_extra_responses(struct iscsi_param_list *param_list)\r\n{\r\nstruct iscsi_extra_response *er, *er_tmp;\r\nlist_for_each_entry_safe(er, er_tmp, &param_list->extra_response_list,\r\ner_list) {\r\nlist_del(&er->er_list);\r\nkfree(er);\r\n}\r\n}\r\nvoid iscsi_release_param_list(struct iscsi_param_list *param_list)\r\n{\r\nstruct iscsi_param *param, *param_tmp;\r\nlist_for_each_entry_safe(param, param_tmp, &param_list->param_list,\r\np_list) {\r\nlist_del(&param->p_list);\r\nkfree(param->name);\r\nparam->name = NULL;\r\nkfree(param->value);\r\nparam->value = NULL;\r\nkfree(param);\r\nparam = NULL;\r\n}\r\niscsi_release_extra_responses(param_list);\r\nkfree(param_list);\r\n}\r\nstruct iscsi_param *iscsi_find_param_from_key(\r\nchar *key,\r\nstruct iscsi_param_list *param_list)\r\n{\r\nstruct iscsi_param *param;\r\nif (!key || !param_list) {\r\npr_err("Key or parameter list pointer is NULL.\n");\r\nreturn NULL;\r\n}\r\nlist_for_each_entry(param, &param_list->param_list, p_list) {\r\nif (!strcmp(key, param->name))\r\nreturn param;\r\n}\r\npr_err("Unable to locate key \"%s\".\n", key);\r\nreturn NULL;\r\n}\r\nint iscsi_extract_key_value(char *textbuf, char **key, char **value)\r\n{\r\n*value = strchr(textbuf, '=');\r\nif (!*value) {\r\npr_err("Unable to locate \"=\" seperator for key,"\r\n" ignoring request.\n");\r\nreturn -1;\r\n}\r\n*key = textbuf;\r\n**value = '\0';\r\n*value = *value + 1;\r\nreturn 0;\r\n}\r\nint iscsi_update_param_value(struct iscsi_param *param, char *value)\r\n{\r\nkfree(param->value);\r\nparam->value = kzalloc(strlen(value) + 1, GFP_KERNEL);\r\nif (!param->value) {\r\npr_err("Unable to allocate memory for value.\n");\r\nreturn -1;\r\n}\r\nmemcpy(param->value, value, strlen(value));\r\nparam->value[strlen(value)] = '\0';\r\npr_debug("iSCSI Parameter updated to %s=%s\n",\r\nparam->name, param->value);\r\nreturn 0;\r\n}\r\nstatic int iscsi_add_notunderstood_response(\r\nchar *key,\r\nchar *value,\r\nstruct iscsi_param_list *param_list)\r\n{\r\nstruct iscsi_extra_response *extra_response;\r\nif (strlen(value) > VALUE_MAXLEN) {\r\npr_err("Value for notunderstood key \"%s\" exceeds %d,"\r\n" protocol error.\n", key, VALUE_MAXLEN);\r\nreturn -1;\r\n}\r\nextra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\r\nif (!extra_response) {\r\npr_err("Unable to allocate memory for"\r\n" struct iscsi_extra_response.\n");\r\nreturn -1;\r\n}\r\nINIT_LIST_HEAD(&extra_response->er_list);\r\nstrncpy(extra_response->key, key, strlen(key) + 1);\r\nstrncpy(extra_response->value, NOTUNDERSTOOD,\r\nstrlen(NOTUNDERSTOOD) + 1);\r\nlist_add_tail(&extra_response->er_list,\r\n&param_list->extra_response_list);\r\nreturn 0;\r\n}\r\nstatic int iscsi_check_for_auth_key(char *key)\r\n{\r\nif (!strcmp(key, "CHAP_A") || !strcmp(key, "CHAP_I") ||\r\n!strcmp(key, "CHAP_C") || !strcmp(key, "CHAP_N") ||\r\n!strcmp(key, "CHAP_R"))\r\nreturn 1;\r\nif (!strcmp(key, "SRP_U") || !strcmp(key, "SRP_N") ||\r\n!strcmp(key, "SRP_g") || !strcmp(key, "SRP_s") ||\r\n!strcmp(key, "SRP_A") || !strcmp(key, "SRP_B") ||\r\n!strcmp(key, "SRP_M") || !strcmp(key, "SRP_HM"))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void iscsi_check_proposer_for_optional_reply(struct iscsi_param *param)\r\n{\r\nif (IS_TYPE_BOOL_AND(param)) {\r\nif (!strcmp(param->value, NO))\r\nSET_PSTATE_REPLY_OPTIONAL(param);\r\n} else if (IS_TYPE_BOOL_OR(param)) {\r\nif (!strcmp(param->value, YES))\r\nSET_PSTATE_REPLY_OPTIONAL(param);\r\nif (!strcmp(param->name, IMMEDIATEDATA))\r\nSET_PSTATE_REPLY_OPTIONAL(param);\r\n} else if (IS_TYPE_NUMBER(param)) {\r\nif (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH))\r\nSET_PSTATE_REPLY_OPTIONAL(param);\r\nif (!strcmp(param->name, MAXBURSTLENGTH))\r\nSET_PSTATE_REPLY_OPTIONAL(param);\r\nif (!strcmp(param->name, FIRSTBURSTLENGTH))\r\nSET_PSTATE_REPLY_OPTIONAL(param);\r\nif (!strcmp(param->name, DEFAULTTIME2WAIT))\r\nSET_PSTATE_REPLY_OPTIONAL(param);\r\nif (!strcmp(param->name, DEFAULTTIME2RETAIN))\r\nSET_PSTATE_REPLY_OPTIONAL(param);\r\nif (!strcmp(param->name, MAXCONNECTIONS))\r\nSET_PSTATE_REPLY_OPTIONAL(param);\r\n} else if (IS_PHASE_DECLARATIVE(param))\r\nSET_PSTATE_REPLY_OPTIONAL(param);\r\n}\r\nstatic int iscsi_check_boolean_value(struct iscsi_param *param, char *value)\r\n{\r\nif (strcmp(value, YES) && strcmp(value, NO)) {\r\npr_err("Illegal value for \"%s\", must be either"\r\n" \"%s\" or \"%s\".\n", param->name, YES, NO);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_check_numerical_value(struct iscsi_param *param, char *value_ptr)\r\n{\r\nchar *tmpptr;\r\nint value = 0;\r\nvalue = simple_strtoul(value_ptr, &tmpptr, 0);\r\n#if 0\r\nif (strspn(endptr, WHITE_SPACE) != strlen(endptr)) {\r\npr_err("Illegal value \"%s\" for \"%s\".\n",\r\nvalue, param->name);\r\nreturn -1;\r\n}\r\n#endif\r\nif (IS_TYPERANGE_0_TO_2(param)) {\r\nif ((value < 0) || (value > 2)) {\r\npr_err("Illegal value for \"%s\", must be"\r\n" between 0 and 2.\n", param->name);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nif (IS_TYPERANGE_0_TO_3600(param)) {\r\nif ((value < 0) || (value > 3600)) {\r\npr_err("Illegal value for \"%s\", must be"\r\n" between 0 and 3600.\n", param->name);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nif (IS_TYPERANGE_0_TO_32767(param)) {\r\nif ((value < 0) || (value > 32767)) {\r\npr_err("Illegal value for \"%s\", must be"\r\n" between 0 and 32767.\n", param->name);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nif (IS_TYPERANGE_0_TO_65535(param)) {\r\nif ((value < 0) || (value > 65535)) {\r\npr_err("Illegal value for \"%s\", must be"\r\n" between 0 and 65535.\n", param->name);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nif (IS_TYPERANGE_1_TO_65535(param)) {\r\nif ((value < 1) || (value > 65535)) {\r\npr_err("Illegal value for \"%s\", must be"\r\n" between 1 and 65535.\n", param->name);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nif (IS_TYPERANGE_2_TO_3600(param)) {\r\nif ((value < 2) || (value > 3600)) {\r\npr_err("Illegal value for \"%s\", must be"\r\n" between 2 and 3600.\n", param->name);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nif (IS_TYPERANGE_512_TO_16777215(param)) {\r\nif ((value < 512) || (value > 16777215)) {\r\npr_err("Illegal value for \"%s\", must be"\r\n" between 512 and 16777215.\n", param->name);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_check_numerical_range_value(struct iscsi_param *param, char *value)\r\n{\r\nchar *left_val_ptr = NULL, *right_val_ptr = NULL;\r\nchar *tilde_ptr = NULL, *tmp_ptr = NULL;\r\nu32 left_val, right_val, local_left_val, local_right_val;\r\nif (strcmp(param->name, IFMARKINT) &&\r\nstrcmp(param->name, OFMARKINT)) {\r\npr_err("Only parameters \"%s\" or \"%s\" may contain a"\r\n" numerical range value.\n", IFMARKINT, OFMARKINT);\r\nreturn -1;\r\n}\r\nif (IS_PSTATE_PROPOSER(param))\r\nreturn 0;\r\ntilde_ptr = strchr(value, '~');\r\nif (!tilde_ptr) {\r\npr_err("Unable to locate numerical range indicator"\r\n" \"~\" for \"%s\".\n", param->name);\r\nreturn -1;\r\n}\r\n*tilde_ptr = '\0';\r\nleft_val_ptr = value;\r\nright_val_ptr = value + strlen(left_val_ptr) + 1;\r\nif (iscsi_check_numerical_value(param, left_val_ptr) < 0)\r\nreturn -1;\r\nif (iscsi_check_numerical_value(param, right_val_ptr) < 0)\r\nreturn -1;\r\nleft_val = simple_strtoul(left_val_ptr, &tmp_ptr, 0);\r\nright_val = simple_strtoul(right_val_ptr, &tmp_ptr, 0);\r\n*tilde_ptr = '~';\r\nif (right_val < left_val) {\r\npr_err("Numerical range for parameter \"%s\" contains"\r\n" a right value which is less than the left.\n",\r\nparam->name);\r\nreturn -1;\r\n}\r\ntilde_ptr = strchr(param->value, '~');\r\nif (!tilde_ptr) {\r\npr_err("Unable to locate numerical range indicator"\r\n" \"~\" for \"%s\".\n", param->name);\r\nreturn -1;\r\n}\r\n*tilde_ptr = '\0';\r\nleft_val_ptr = param->value;\r\nright_val_ptr = param->value + strlen(left_val_ptr) + 1;\r\nlocal_left_val = simple_strtoul(left_val_ptr, &tmp_ptr, 0);\r\nlocal_right_val = simple_strtoul(right_val_ptr, &tmp_ptr, 0);\r\n*tilde_ptr = '~';\r\nif (param->set_param) {\r\nif ((left_val < local_left_val) ||\r\n(right_val < local_left_val)) {\r\npr_err("Passed value range \"%u~%u\" is below"\r\n" minimum left value \"%u\" for key \"%s\","\r\n" rejecting.\n", left_val, right_val,\r\nlocal_left_val, param->name);\r\nreturn -1;\r\n}\r\n} else {\r\nif ((left_val < local_left_val) &&\r\n(right_val < local_left_val)) {\r\npr_err("Received value range \"%u~%u\" is"\r\n" below minimum left value \"%u\" for key"\r\n" \"%s\", rejecting.\n", left_val, right_val,\r\nlocal_left_val, param->name);\r\nSET_PSTATE_REJECT(param);\r\nif (iscsi_update_param_value(param, REJECT) < 0)\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_check_string_or_list_value(struct iscsi_param *param, char *value)\r\n{\r\nif (IS_PSTATE_PROPOSER(param))\r\nreturn 0;\r\nif (IS_TYPERANGE_AUTH_PARAM(param)) {\r\nif (strcmp(value, KRB5) && strcmp(value, SPKM1) &&\r\nstrcmp(value, SPKM2) && strcmp(value, SRP) &&\r\nstrcmp(value, CHAP) && strcmp(value, NONE)) {\r\npr_err("Illegal value for \"%s\", must be"\r\n" \"%s\", \"%s\", \"%s\", \"%s\", \"%s\""\r\n" or \"%s\".\n", param->name, KRB5,\r\nSPKM1, SPKM2, SRP, CHAP, NONE);\r\nreturn -1;\r\n}\r\n}\r\nif (IS_TYPERANGE_DIGEST_PARAM(param)) {\r\nif (strcmp(value, CRC32C) && strcmp(value, NONE)) {\r\npr_err("Illegal value for \"%s\", must be"\r\n" \"%s\" or \"%s\".\n", param->name,\r\nCRC32C, NONE);\r\nreturn -1;\r\n}\r\n}\r\nif (IS_TYPERANGE_SESSIONTYPE(param)) {\r\nif (strcmp(value, DISCOVERY) && strcmp(value, NORMAL)) {\r\npr_err("Illegal value for \"%s\", must be"\r\n" \"%s\" or \"%s\".\n", param->name,\r\nDISCOVERY, NORMAL);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic char *iscsi_get_value_from_number_range(\r\nstruct iscsi_param *param,\r\nchar *value)\r\n{\r\nchar *end_ptr, *tilde_ptr1 = NULL, *tilde_ptr2 = NULL;\r\nu32 acceptor_right_value, proposer_right_value;\r\ntilde_ptr1 = strchr(value, '~');\r\nif (!tilde_ptr1)\r\nreturn NULL;\r\n*tilde_ptr1++ = '\0';\r\nproposer_right_value = simple_strtoul(tilde_ptr1, &end_ptr, 0);\r\ntilde_ptr2 = strchr(param->value, '~');\r\nif (!tilde_ptr2)\r\nreturn NULL;\r\n*tilde_ptr2++ = '\0';\r\nacceptor_right_value = simple_strtoul(tilde_ptr2, &end_ptr, 0);\r\nreturn (acceptor_right_value >= proposer_right_value) ?\r\ntilde_ptr1 : tilde_ptr2;\r\n}\r\nstatic char *iscsi_check_valuelist_for_support(\r\nstruct iscsi_param *param,\r\nchar *value)\r\n{\r\nchar *tmp1 = NULL, *tmp2 = NULL;\r\nchar *acceptor_values = NULL, *proposer_values = NULL;\r\nacceptor_values = param->value;\r\nproposer_values = value;\r\ndo {\r\nif (!proposer_values)\r\nreturn NULL;\r\ntmp1 = strchr(proposer_values, ',');\r\nif (tmp1)\r\n*tmp1 = '\0';\r\nacceptor_values = param->value;\r\ndo {\r\nif (!acceptor_values) {\r\nif (tmp1)\r\n*tmp1 = ',';\r\nreturn NULL;\r\n}\r\ntmp2 = strchr(acceptor_values, ',');\r\nif (tmp2)\r\n*tmp2 = '\0';\r\nif (!acceptor_values || !proposer_values) {\r\nif (tmp1)\r\n*tmp1 = ',';\r\nif (tmp2)\r\n*tmp2 = ',';\r\nreturn NULL;\r\n}\r\nif (!strcmp(acceptor_values, proposer_values)) {\r\nif (tmp2)\r\n*tmp2 = ',';\r\ngoto out;\r\n}\r\nif (tmp2)\r\n*tmp2++ = ',';\r\nacceptor_values = tmp2;\r\nif (!acceptor_values)\r\nbreak;\r\n} while (acceptor_values);\r\nif (tmp1)\r\n*tmp1++ = ',';\r\nproposer_values = tmp1;\r\n} while (proposer_values);\r\nout:\r\nreturn proposer_values;\r\n}\r\nstatic int iscsi_check_acceptor_state(struct iscsi_param *param, char *value)\r\n{\r\nu8 acceptor_boolean_value = 0, proposer_boolean_value = 0;\r\nchar *negoitated_value = NULL;\r\nif (IS_PSTATE_ACCEPTOR(param)) {\r\npr_err("Received key \"%s\" twice, protocol error.\n",\r\nparam->name);\r\nreturn -1;\r\n}\r\nif (IS_PSTATE_REJECT(param))\r\nreturn 0;\r\nif (IS_TYPE_BOOL_AND(param)) {\r\nif (!strcmp(value, YES))\r\nproposer_boolean_value = 1;\r\nif (!strcmp(param->value, YES))\r\nacceptor_boolean_value = 1;\r\nif (acceptor_boolean_value && proposer_boolean_value)\r\ndo {} while (0);\r\nelse {\r\nif (iscsi_update_param_value(param, NO) < 0)\r\nreturn -1;\r\nif (!proposer_boolean_value)\r\nSET_PSTATE_REPLY_OPTIONAL(param);\r\n}\r\n} else if (IS_TYPE_BOOL_OR(param)) {\r\nif (!strcmp(value, YES))\r\nproposer_boolean_value = 1;\r\nif (!strcmp(param->value, YES))\r\nacceptor_boolean_value = 1;\r\nif (acceptor_boolean_value || proposer_boolean_value) {\r\nif (iscsi_update_param_value(param, YES) < 0)\r\nreturn -1;\r\nif (proposer_boolean_value)\r\nSET_PSTATE_REPLY_OPTIONAL(param);\r\n}\r\n} else if (IS_TYPE_NUMBER(param)) {\r\nchar *tmpptr, buf[10];\r\nu32 acceptor_value = simple_strtoul(param->value, &tmpptr, 0);\r\nu32 proposer_value = simple_strtoul(value, &tmpptr, 0);\r\nmemset(buf, 0, 10);\r\nif (!strcmp(param->name, MAXCONNECTIONS) ||\r\n!strcmp(param->name, MAXBURSTLENGTH) ||\r\n!strcmp(param->name, FIRSTBURSTLENGTH) ||\r\n!strcmp(param->name, MAXOUTSTANDINGR2T) ||\r\n!strcmp(param->name, DEFAULTTIME2RETAIN) ||\r\n!strcmp(param->name, ERRORRECOVERYLEVEL)) {\r\nif (proposer_value > acceptor_value) {\r\nsprintf(buf, "%u", acceptor_value);\r\nif (iscsi_update_param_value(param,\r\n&buf[0]) < 0)\r\nreturn -1;\r\n} else {\r\nif (iscsi_update_param_value(param, value) < 0)\r\nreturn -1;\r\n}\r\n} else if (!strcmp(param->name, DEFAULTTIME2WAIT)) {\r\nif (acceptor_value > proposer_value) {\r\nsprintf(buf, "%u", acceptor_value);\r\nif (iscsi_update_param_value(param,\r\n&buf[0]) < 0)\r\nreturn -1;\r\n} else {\r\nif (iscsi_update_param_value(param, value) < 0)\r\nreturn -1;\r\n}\r\n} else {\r\nif (iscsi_update_param_value(param, value) < 0)\r\nreturn -1;\r\n}\r\nif (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH))\r\nSET_PSTATE_REPLY_OPTIONAL(param);\r\n} else if (IS_TYPE_NUMBER_RANGE(param)) {\r\nnegoitated_value = iscsi_get_value_from_number_range(\r\nparam, value);\r\nif (!negoitated_value)\r\nreturn -1;\r\nif (iscsi_update_param_value(param, negoitated_value) < 0)\r\nreturn -1;\r\n} else if (IS_TYPE_VALUE_LIST(param)) {\r\nnegoitated_value = iscsi_check_valuelist_for_support(\r\nparam, value);\r\nif (!negoitated_value) {\r\npr_err("Proposer's value list \"%s\" contains"\r\n" no valid values from Acceptor's value list"\r\n" \"%s\".\n", value, param->value);\r\nreturn -1;\r\n}\r\nif (iscsi_update_param_value(param, negoitated_value) < 0)\r\nreturn -1;\r\n} else if (IS_PHASE_DECLARATIVE(param)) {\r\nif (iscsi_update_param_value(param, value) < 0)\r\nreturn -1;\r\nSET_PSTATE_REPLY_OPTIONAL(param);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_check_proposer_state(struct iscsi_param *param, char *value)\r\n{\r\nif (IS_PSTATE_RESPONSE_GOT(param)) {\r\npr_err("Received key \"%s\" twice, protocol error.\n",\r\nparam->name);\r\nreturn -1;\r\n}\r\nif (IS_TYPE_NUMBER_RANGE(param)) {\r\nu32 left_val = 0, right_val = 0, recieved_value = 0;\r\nchar *left_val_ptr = NULL, *right_val_ptr = NULL;\r\nchar *tilde_ptr = NULL, *tmp_ptr = NULL;\r\nif (!strcmp(value, IRRELEVANT) || !strcmp(value, REJECT)) {\r\nif (iscsi_update_param_value(param, value) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\ntilde_ptr = strchr(value, '~');\r\nif (tilde_ptr) {\r\npr_err("Illegal \"~\" in response for \"%s\".\n",\r\nparam->name);\r\nreturn -1;\r\n}\r\ntilde_ptr = strchr(param->value, '~');\r\nif (!tilde_ptr) {\r\npr_err("Unable to locate numerical range"\r\n" indicator \"~\" for \"%s\".\n", param->name);\r\nreturn -1;\r\n}\r\n*tilde_ptr = '\0';\r\nleft_val_ptr = param->value;\r\nright_val_ptr = param->value + strlen(left_val_ptr) + 1;\r\nleft_val = simple_strtoul(left_val_ptr, &tmp_ptr, 0);\r\nright_val = simple_strtoul(right_val_ptr, &tmp_ptr, 0);\r\nrecieved_value = simple_strtoul(value, &tmp_ptr, 0);\r\n*tilde_ptr = '~';\r\nif ((recieved_value < left_val) ||\r\n(recieved_value > right_val)) {\r\npr_err("Illegal response \"%s=%u\", value must"\r\n" be between %u and %u.\n", param->name,\r\nrecieved_value, left_val, right_val);\r\nreturn -1;\r\n}\r\n} else if (IS_TYPE_VALUE_LIST(param)) {\r\nchar *comma_ptr = NULL, *tmp_ptr = NULL;\r\ncomma_ptr = strchr(value, ',');\r\nif (comma_ptr) {\r\npr_err("Illegal \",\" in response for \"%s\".\n",\r\nparam->name);\r\nreturn -1;\r\n}\r\ntmp_ptr = iscsi_check_valuelist_for_support(param, value);\r\nif (!tmp_ptr)\r\nreturn -1;\r\n}\r\nif (iscsi_update_param_value(param, value) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int iscsi_check_value(struct iscsi_param *param, char *value)\r\n{\r\nchar *comma_ptr = NULL;\r\nif (!strcmp(value, REJECT)) {\r\nif (!strcmp(param->name, IFMARKINT) ||\r\n!strcmp(param->name, OFMARKINT)) {\r\nSET_PSTATE_REJECT(param);\r\nreturn 0;\r\n}\r\npr_err("Received %s=%s\n", param->name, value);\r\nreturn -1;\r\n}\r\nif (!strcmp(value, IRRELEVANT)) {\r\npr_debug("Received %s=%s\n", param->name, value);\r\nSET_PSTATE_IRRELEVANT(param);\r\nreturn 0;\r\n}\r\nif (!strcmp(value, NOTUNDERSTOOD)) {\r\nif (!IS_PSTATE_PROPOSER(param)) {\r\npr_err("Received illegal offer %s=%s\n",\r\nparam->name, value);\r\nreturn -1;\r\n}\r\npr_err("Standard iSCSI key \"%s\" cannot be answered"\r\n" with \"%s\", protocol error.\n", param->name, value);\r\nreturn -1;\r\n}\r\ndo {\r\ncomma_ptr = NULL;\r\ncomma_ptr = strchr(value, ',');\r\nif (comma_ptr && !IS_TYPE_VALUE_LIST(param)) {\r\npr_err("Detected value seperator \",\", but"\r\n" key \"%s\" does not allow a value list,"\r\n" protocol error.\n", param->name);\r\nreturn -1;\r\n}\r\nif (comma_ptr)\r\n*comma_ptr = '\0';\r\nif (strlen(value) > VALUE_MAXLEN) {\r\npr_err("Value for key \"%s\" exceeds %d,"\r\n" protocol error.\n", param->name,\r\nVALUE_MAXLEN);\r\nreturn -1;\r\n}\r\nif (IS_TYPE_BOOL_AND(param) || IS_TYPE_BOOL_OR(param)) {\r\nif (iscsi_check_boolean_value(param, value) < 0)\r\nreturn -1;\r\n} else if (IS_TYPE_NUMBER(param)) {\r\nif (iscsi_check_numerical_value(param, value) < 0)\r\nreturn -1;\r\n} else if (IS_TYPE_NUMBER_RANGE(param)) {\r\nif (iscsi_check_numerical_range_value(param, value) < 0)\r\nreturn -1;\r\n} else if (IS_TYPE_STRING(param) || IS_TYPE_VALUE_LIST(param)) {\r\nif (iscsi_check_string_or_list_value(param, value) < 0)\r\nreturn -1;\r\n} else {\r\npr_err("Huh? 0x%02x\n", param->type);\r\nreturn -1;\r\n}\r\nif (comma_ptr)\r\n*comma_ptr++ = ',';\r\nvalue = comma_ptr;\r\n} while (value);\r\nreturn 0;\r\n}\r\nstatic struct iscsi_param *__iscsi_check_key(\r\nchar *key,\r\nint sender,\r\nstruct iscsi_param_list *param_list)\r\n{\r\nstruct iscsi_param *param;\r\nif (strlen(key) > KEY_MAXLEN) {\r\npr_err("Length of key name \"%s\" exceeds %d.\n",\r\nkey, KEY_MAXLEN);\r\nreturn NULL;\r\n}\r\nparam = iscsi_find_param_from_key(key, param_list);\r\nif (!param)\r\nreturn NULL;\r\nif ((sender & SENDER_INITIATOR) && !IS_SENDER_INITIATOR(param)) {\r\npr_err("Key \"%s\" may not be sent to %s,"\r\n" protocol error.\n", param->name,\r\n(sender & SENDER_RECEIVER) ? "target" : "initiator");\r\nreturn NULL;\r\n}\r\nif ((sender & SENDER_TARGET) && !IS_SENDER_TARGET(param)) {\r\npr_err("Key \"%s\" may not be sent to %s,"\r\n" protocol error.\n", param->name,\r\n(sender & SENDER_RECEIVER) ? "initiator" : "target");\r\nreturn NULL;\r\n}\r\nreturn param;\r\n}\r\nstatic struct iscsi_param *iscsi_check_key(\r\nchar *key,\r\nint phase,\r\nint sender,\r\nstruct iscsi_param_list *param_list)\r\n{\r\nstruct iscsi_param *param;\r\nif (strlen(key) > KEY_MAXLEN) {\r\npr_err("Length of key name \"%s\" exceeds %d.\n",\r\nkey, KEY_MAXLEN);\r\nreturn NULL;\r\n}\r\nparam = iscsi_find_param_from_key(key, param_list);\r\nif (!param)\r\nreturn NULL;\r\nif ((sender & SENDER_INITIATOR) && !IS_SENDER_INITIATOR(param)) {\r\npr_err("Key \"%s\" may not be sent to %s,"\r\n" protocol error.\n", param->name,\r\n(sender & SENDER_RECEIVER) ? "target" : "initiator");\r\nreturn NULL;\r\n}\r\nif ((sender & SENDER_TARGET) && !IS_SENDER_TARGET(param)) {\r\npr_err("Key \"%s\" may not be sent to %s,"\r\n" protocol error.\n", param->name,\r\n(sender & SENDER_RECEIVER) ? "initiator" : "target");\r\nreturn NULL;\r\n}\r\nif (IS_PSTATE_ACCEPTOR(param)) {\r\npr_err("Key \"%s\" received twice, protocol error.\n",\r\nkey);\r\nreturn NULL;\r\n}\r\nif (!phase)\r\nreturn param;\r\nif (!(param->phase & phase)) {\r\npr_err("Key \"%s\" may not be negotiated during ",\r\nparam->name);\r\nswitch (phase) {\r\ncase PHASE_SECURITY:\r\npr_debug("Security phase.\n");\r\nbreak;\r\ncase PHASE_OPERATIONAL:\r\npr_debug("Operational phase.\n");\r\ndefault:\r\npr_debug("Unknown phase.\n");\r\n}\r\nreturn NULL;\r\n}\r\nreturn param;\r\n}\r\nstatic int iscsi_enforce_integrity_rules(\r\nu8 phase,\r\nstruct iscsi_param_list *param_list)\r\n{\r\nchar *tmpptr;\r\nu8 DataSequenceInOrder = 0;\r\nu8 ErrorRecoveryLevel = 0, SessionType = 0;\r\nu8 IFMarker = 0, OFMarker = 0;\r\nu8 IFMarkInt_Reject = 1, OFMarkInt_Reject = 1;\r\nu32 FirstBurstLength = 0, MaxBurstLength = 0;\r\nstruct iscsi_param *param = NULL;\r\nlist_for_each_entry(param, &param_list->param_list, p_list) {\r\nif (!(param->phase & phase))\r\ncontinue;\r\nif (!strcmp(param->name, SESSIONTYPE))\r\nif (!strcmp(param->value, NORMAL))\r\nSessionType = 1;\r\nif (!strcmp(param->name, ERRORRECOVERYLEVEL))\r\nErrorRecoveryLevel = simple_strtoul(param->value,\r\n&tmpptr, 0);\r\nif (!strcmp(param->name, DATASEQUENCEINORDER))\r\nif (!strcmp(param->value, YES))\r\nDataSequenceInOrder = 1;\r\nif (!strcmp(param->name, MAXBURSTLENGTH))\r\nMaxBurstLength = simple_strtoul(param->value,\r\n&tmpptr, 0);\r\nif (!strcmp(param->name, IFMARKER))\r\nif (!strcmp(param->value, YES))\r\nIFMarker = 1;\r\nif (!strcmp(param->name, OFMARKER))\r\nif (!strcmp(param->value, YES))\r\nOFMarker = 1;\r\nif (!strcmp(param->name, IFMARKINT))\r\nif (!strcmp(param->value, REJECT))\r\nIFMarkInt_Reject = 1;\r\nif (!strcmp(param->name, OFMARKINT))\r\nif (!strcmp(param->value, REJECT))\r\nOFMarkInt_Reject = 1;\r\n}\r\nlist_for_each_entry(param, &param_list->param_list, p_list) {\r\nif (!(param->phase & phase))\r\ncontinue;\r\nif (!SessionType && (!IS_PSTATE_ACCEPTOR(param) &&\r\n(strcmp(param->name, IFMARKER) &&\r\nstrcmp(param->name, OFMARKER) &&\r\nstrcmp(param->name, IFMARKINT) &&\r\nstrcmp(param->name, OFMARKINT))))\r\ncontinue;\r\nif (!strcmp(param->name, MAXOUTSTANDINGR2T) &&\r\nDataSequenceInOrder && (ErrorRecoveryLevel > 0)) {\r\nif (strcmp(param->value, "1")) {\r\nif (iscsi_update_param_value(param, "1") < 0)\r\nreturn -1;\r\npr_debug("Reset \"%s\" to \"%s\".\n",\r\nparam->name, param->value);\r\n}\r\n}\r\nif (!strcmp(param->name, MAXCONNECTIONS) && !SessionType) {\r\nif (strcmp(param->value, "1")) {\r\nif (iscsi_update_param_value(param, "1") < 0)\r\nreturn -1;\r\npr_debug("Reset \"%s\" to \"%s\".\n",\r\nparam->name, param->value);\r\n}\r\n}\r\nif (!strcmp(param->name, FIRSTBURSTLENGTH)) {\r\nFirstBurstLength = simple_strtoul(param->value,\r\n&tmpptr, 0);\r\nif (FirstBurstLength > MaxBurstLength) {\r\nchar tmpbuf[10];\r\nmemset(tmpbuf, 0, 10);\r\nsprintf(tmpbuf, "%u", MaxBurstLength);\r\nif (iscsi_update_param_value(param, tmpbuf))\r\nreturn -1;\r\npr_debug("Reset \"%s\" to \"%s\".\n",\r\nparam->name, param->value);\r\n}\r\n}\r\nif (!strcmp(param->name, IFMARKER) && IFMarkInt_Reject) {\r\nif (iscsi_update_param_value(param, NO) < 0)\r\nreturn -1;\r\nIFMarker = 0;\r\npr_debug("Reset \"%s\" to \"%s\".\n",\r\nparam->name, param->value);\r\n}\r\nif (!strcmp(param->name, OFMARKER) && OFMarkInt_Reject) {\r\nif (iscsi_update_param_value(param, NO) < 0)\r\nreturn -1;\r\nOFMarker = 0;\r\npr_debug("Reset \"%s\" to \"%s\".\n",\r\nparam->name, param->value);\r\n}\r\nif (!strcmp(param->name, IFMARKINT) && !IFMarker) {\r\nif (!strcmp(param->value, REJECT))\r\ncontinue;\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nif (iscsi_update_param_value(param, IRRELEVANT) < 0)\r\nreturn -1;\r\npr_debug("Reset \"%s\" to \"%s\".\n",\r\nparam->name, param->value);\r\n}\r\nif (!strcmp(param->name, OFMARKINT) && !OFMarker) {\r\nif (!strcmp(param->value, REJECT))\r\ncontinue;\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nif (iscsi_update_param_value(param, IRRELEVANT) < 0)\r\nreturn -1;\r\npr_debug("Reset \"%s\" to \"%s\".\n",\r\nparam->name, param->value);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint iscsi_decode_text_input(\r\nu8 phase,\r\nu8 sender,\r\nchar *textbuf,\r\nu32 length,\r\nstruct iscsi_param_list *param_list)\r\n{\r\nchar *tmpbuf, *start = NULL, *end = NULL;\r\ntmpbuf = kzalloc(length + 1, GFP_KERNEL);\r\nif (!tmpbuf) {\r\npr_err("Unable to allocate memory for tmpbuf.\n");\r\nreturn -1;\r\n}\r\nmemcpy(tmpbuf, textbuf, length);\r\ntmpbuf[length] = '\0';\r\nstart = tmpbuf;\r\nend = (start + length);\r\nwhile (start < end) {\r\nchar *key, *value;\r\nstruct iscsi_param *param;\r\nif (iscsi_extract_key_value(start, &key, &value) < 0) {\r\nkfree(tmpbuf);\r\nreturn -1;\r\n}\r\npr_debug("Got key: %s=%s\n", key, value);\r\nif (phase & PHASE_SECURITY) {\r\nif (iscsi_check_for_auth_key(key) > 0) {\r\nchar *tmpptr = key + strlen(key);\r\n*tmpptr = '=';\r\nkfree(tmpbuf);\r\nreturn 1;\r\n}\r\n}\r\nparam = iscsi_check_key(key, phase, sender, param_list);\r\nif (!param) {\r\nif (iscsi_add_notunderstood_response(key,\r\nvalue, param_list) < 0) {\r\nkfree(tmpbuf);\r\nreturn -1;\r\n}\r\nstart += strlen(key) + strlen(value) + 2;\r\ncontinue;\r\n}\r\nif (iscsi_check_value(param, value) < 0) {\r\nkfree(tmpbuf);\r\nreturn -1;\r\n}\r\nstart += strlen(key) + strlen(value) + 2;\r\nif (IS_PSTATE_PROPOSER(param)) {\r\nif (iscsi_check_proposer_state(param, value) < 0) {\r\nkfree(tmpbuf);\r\nreturn -1;\r\n}\r\nSET_PSTATE_RESPONSE_GOT(param);\r\n} else {\r\nif (iscsi_check_acceptor_state(param, value) < 0) {\r\nkfree(tmpbuf);\r\nreturn -1;\r\n}\r\nSET_PSTATE_ACCEPTOR(param);\r\n}\r\n}\r\nkfree(tmpbuf);\r\nreturn 0;\r\n}\r\nint iscsi_encode_text_output(\r\nu8 phase,\r\nu8 sender,\r\nchar *textbuf,\r\nu32 *length,\r\nstruct iscsi_param_list *param_list)\r\n{\r\nchar *output_buf = NULL;\r\nstruct iscsi_extra_response *er;\r\nstruct iscsi_param *param;\r\noutput_buf = textbuf + *length;\r\nif (iscsi_enforce_integrity_rules(phase, param_list) < 0)\r\nreturn -1;\r\nlist_for_each_entry(param, &param_list->param_list, p_list) {\r\nif (!(param->sender & sender))\r\ncontinue;\r\nif (IS_PSTATE_ACCEPTOR(param) &&\r\n!IS_PSTATE_RESPONSE_SENT(param) &&\r\n!IS_PSTATE_REPLY_OPTIONAL(param) &&\r\n(param->phase & phase)) {\r\n*length += sprintf(output_buf, "%s=%s",\r\nparam->name, param->value);\r\n*length += 1;\r\noutput_buf = textbuf + *length;\r\nSET_PSTATE_RESPONSE_SENT(param);\r\npr_debug("Sending key: %s=%s\n",\r\nparam->name, param->value);\r\ncontinue;\r\n}\r\nif (IS_PSTATE_NEGOTIATE(param) &&\r\n!IS_PSTATE_ACCEPTOR(param) &&\r\n!IS_PSTATE_PROPOSER(param) &&\r\n(param->phase & phase)) {\r\n*length += sprintf(output_buf, "%s=%s",\r\nparam->name, param->value);\r\n*length += 1;\r\noutput_buf = textbuf + *length;\r\nSET_PSTATE_PROPOSER(param);\r\niscsi_check_proposer_for_optional_reply(param);\r\npr_debug("Sending key: %s=%s\n",\r\nparam->name, param->value);\r\n}\r\n}\r\nlist_for_each_entry(er, &param_list->extra_response_list, er_list) {\r\n*length += sprintf(output_buf, "%s=%s", er->key, er->value);\r\n*length += 1;\r\noutput_buf = textbuf + *length;\r\npr_debug("Sending key: %s=%s\n", er->key, er->value);\r\n}\r\niscsi_release_extra_responses(param_list);\r\nreturn 0;\r\n}\r\nint iscsi_check_negotiated_keys(struct iscsi_param_list *param_list)\r\n{\r\nint ret = 0;\r\nstruct iscsi_param *param;\r\nlist_for_each_entry(param, &param_list->param_list, p_list) {\r\nif (IS_PSTATE_NEGOTIATE(param) &&\r\nIS_PSTATE_PROPOSER(param) &&\r\n!IS_PSTATE_RESPONSE_GOT(param) &&\r\n!IS_PSTATE_REPLY_OPTIONAL(param) &&\r\n!IS_PHASE_DECLARATIVE(param)) {\r\npr_err("No response for proposed key \"%s\".\n",\r\nparam->name);\r\nret = -1;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint iscsi_change_param_value(\r\nchar *keyvalue,\r\nstruct iscsi_param_list *param_list,\r\nint check_key)\r\n{\r\nchar *key = NULL, *value = NULL;\r\nstruct iscsi_param *param;\r\nint sender = 0;\r\nif (iscsi_extract_key_value(keyvalue, &key, &value) < 0)\r\nreturn -1;\r\nif (!check_key) {\r\nparam = __iscsi_check_key(keyvalue, sender, param_list);\r\nif (!param)\r\nreturn -1;\r\n} else {\r\nparam = iscsi_check_key(keyvalue, 0, sender, param_list);\r\nif (!param)\r\nreturn -1;\r\nparam->set_param = 1;\r\nif (iscsi_check_value(param, value) < 0) {\r\nparam->set_param = 0;\r\nreturn -1;\r\n}\r\nparam->set_param = 0;\r\n}\r\nif (iscsi_update_param_value(param, value) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nvoid iscsi_set_connection_parameters(\r\nstruct iscsi_conn_ops *ops,\r\nstruct iscsi_param_list *param_list)\r\n{\r\nchar *tmpptr;\r\nstruct iscsi_param *param;\r\npr_debug("---------------------------------------------------"\r\n"---------------\n");\r\nlist_for_each_entry(param, &param_list->param_list, p_list) {\r\nif (!IS_PSTATE_ACCEPTOR(param) && !IS_PSTATE_PROPOSER(param))\r\ncontinue;\r\nif (!strcmp(param->name, AUTHMETHOD)) {\r\npr_debug("AuthMethod: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, HEADERDIGEST)) {\r\nops->HeaderDigest = !strcmp(param->value, CRC32C);\r\npr_debug("HeaderDigest: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, DATADIGEST)) {\r\nops->DataDigest = !strcmp(param->value, CRC32C);\r\npr_debug("DataDigest: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH)) {\r\nops->MaxRecvDataSegmentLength =\r\nsimple_strtoul(param->value, &tmpptr, 0);\r\npr_debug("MaxRecvDataSegmentLength: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, OFMARKER)) {\r\nops->OFMarker = !strcmp(param->value, YES);\r\npr_debug("OFMarker: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, IFMARKER)) {\r\nops->IFMarker = !strcmp(param->value, YES);\r\npr_debug("IFMarker: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, OFMARKINT)) {\r\nops->OFMarkInt =\r\nsimple_strtoul(param->value, &tmpptr, 0);\r\npr_debug("OFMarkInt: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, IFMARKINT)) {\r\nops->IFMarkInt =\r\nsimple_strtoul(param->value, &tmpptr, 0);\r\npr_debug("IFMarkInt: %s\n",\r\nparam->value);\r\n}\r\n}\r\npr_debug("----------------------------------------------------"\r\n"--------------\n");\r\n}\r\nvoid iscsi_set_session_parameters(\r\nstruct iscsi_sess_ops *ops,\r\nstruct iscsi_param_list *param_list,\r\nint leading)\r\n{\r\nchar *tmpptr;\r\nstruct iscsi_param *param;\r\npr_debug("----------------------------------------------------"\r\n"--------------\n");\r\nlist_for_each_entry(param, &param_list->param_list, p_list) {\r\nif (!IS_PSTATE_ACCEPTOR(param) && !IS_PSTATE_PROPOSER(param))\r\ncontinue;\r\nif (!strcmp(param->name, INITIATORNAME)) {\r\nif (!param->value)\r\ncontinue;\r\nif (leading)\r\nsnprintf(ops->InitiatorName,\r\nsizeof(ops->InitiatorName),\r\n"%s", param->value);\r\npr_debug("InitiatorName: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, INITIATORALIAS)) {\r\nif (!param->value)\r\ncontinue;\r\nsnprintf(ops->InitiatorAlias,\r\nsizeof(ops->InitiatorAlias),\r\n"%s", param->value);\r\npr_debug("InitiatorAlias: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, TARGETNAME)) {\r\nif (!param->value)\r\ncontinue;\r\nif (leading)\r\nsnprintf(ops->TargetName,\r\nsizeof(ops->TargetName),\r\n"%s", param->value);\r\npr_debug("TargetName: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, TARGETALIAS)) {\r\nif (!param->value)\r\ncontinue;\r\nsnprintf(ops->TargetAlias, sizeof(ops->TargetAlias),\r\n"%s", param->value);\r\npr_debug("TargetAlias: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, TARGETPORTALGROUPTAG)) {\r\nops->TargetPortalGroupTag =\r\nsimple_strtoul(param->value, &tmpptr, 0);\r\npr_debug("TargetPortalGroupTag: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, MAXCONNECTIONS)) {\r\nops->MaxConnections =\r\nsimple_strtoul(param->value, &tmpptr, 0);\r\npr_debug("MaxConnections: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, INITIALR2T)) {\r\nops->InitialR2T = !strcmp(param->value, YES);\r\npr_debug("InitialR2T: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, IMMEDIATEDATA)) {\r\nops->ImmediateData = !strcmp(param->value, YES);\r\npr_debug("ImmediateData: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, MAXBURSTLENGTH)) {\r\nops->MaxBurstLength =\r\nsimple_strtoul(param->value, &tmpptr, 0);\r\npr_debug("MaxBurstLength: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, FIRSTBURSTLENGTH)) {\r\nops->FirstBurstLength =\r\nsimple_strtoul(param->value, &tmpptr, 0);\r\npr_debug("FirstBurstLength: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, DEFAULTTIME2WAIT)) {\r\nops->DefaultTime2Wait =\r\nsimple_strtoul(param->value, &tmpptr, 0);\r\npr_debug("DefaultTime2Wait: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, DEFAULTTIME2RETAIN)) {\r\nops->DefaultTime2Retain =\r\nsimple_strtoul(param->value, &tmpptr, 0);\r\npr_debug("DefaultTime2Retain: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, MAXOUTSTANDINGR2T)) {\r\nops->MaxOutstandingR2T =\r\nsimple_strtoul(param->value, &tmpptr, 0);\r\npr_debug("MaxOutstandingR2T: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, DATAPDUINORDER)) {\r\nops->DataPDUInOrder = !strcmp(param->value, YES);\r\npr_debug("DataPDUInOrder: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, DATASEQUENCEINORDER)) {\r\nops->DataSequenceInOrder = !strcmp(param->value, YES);\r\npr_debug("DataSequenceInOrder: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, ERRORRECOVERYLEVEL)) {\r\nops->ErrorRecoveryLevel =\r\nsimple_strtoul(param->value, &tmpptr, 0);\r\npr_debug("ErrorRecoveryLevel: %s\n",\r\nparam->value);\r\n} else if (!strcmp(param->name, SESSIONTYPE)) {\r\nops->SessionType = !strcmp(param->value, DISCOVERY);\r\npr_debug("SessionType: %s\n",\r\nparam->value);\r\n}\r\n}\r\npr_debug("----------------------------------------------------"\r\n"--------------\n");\r\n}
