struct sas_task *sas_alloc_task(gfp_t flags)\r\n{\r\nstruct sas_task *task = kmem_cache_zalloc(sas_task_cache, flags);\r\nif (task) {\r\nINIT_LIST_HEAD(&task->list);\r\nspin_lock_init(&task->task_state_lock);\r\ntask->task_state_flags = SAS_TASK_STATE_PENDING;\r\ninit_timer(&task->timer);\r\ninit_completion(&task->completion);\r\n}\r\nreturn task;\r\n}\r\nvoid sas_free_task(struct sas_task *task)\r\n{\r\nif (task) {\r\nBUG_ON(!list_empty(&task->list));\r\nkmem_cache_free(sas_task_cache, task);\r\n}\r\n}\r\nvoid sas_hash_addr(u8 *hashed, const u8 *sas_addr)\r\n{\r\nconst u32 poly = 0x00DB2777;\r\nu32 r = 0;\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nint b;\r\nfor (b = 7; b >= 0; b--) {\r\nr <<= 1;\r\nif ((1 << b) & sas_addr[i]) {\r\nif (!(r & 0x01000000))\r\nr ^= poly;\r\n} else if (r & 0x01000000)\r\nr ^= poly;\r\n}\r\n}\r\nhashed[0] = (r >> 16) & 0xFF;\r\nhashed[1] = (r >> 8) & 0xFF ;\r\nhashed[2] = r & 0xFF;\r\n}\r\nvoid sas_hae_reset(struct work_struct *work)\r\n{\r\nstruct sas_ha_event *ev =\r\ncontainer_of(work, struct sas_ha_event, work);\r\nstruct sas_ha_struct *ha = ev->ha;\r\nsas_begin_event(HAE_RESET, &ha->event_lock,\r\n&ha->pending);\r\n}\r\nint sas_register_ha(struct sas_ha_struct *sas_ha)\r\n{\r\nint error = 0;\r\nspin_lock_init(&sas_ha->phy_port_lock);\r\nsas_hash_addr(sas_ha->hashed_sas_addr, sas_ha->sas_addr);\r\nif (sas_ha->lldd_queue_size == 0)\r\nsas_ha->lldd_queue_size = 1;\r\nelse if (sas_ha->lldd_queue_size == -1)\r\nsas_ha->lldd_queue_size = 128;\r\nsas_ha->state = SAS_HA_REGISTERED;\r\nspin_lock_init(&sas_ha->state_lock);\r\nerror = sas_register_phys(sas_ha);\r\nif (error) {\r\nprintk(KERN_NOTICE "couldn't register sas phys:%d\n", error);\r\nreturn error;\r\n}\r\nerror = sas_register_ports(sas_ha);\r\nif (error) {\r\nprintk(KERN_NOTICE "couldn't register sas ports:%d\n", error);\r\ngoto Undo_phys;\r\n}\r\nerror = sas_init_events(sas_ha);\r\nif (error) {\r\nprintk(KERN_NOTICE "couldn't start event thread:%d\n", error);\r\ngoto Undo_ports;\r\n}\r\nif (sas_ha->lldd_max_execute_num > 1) {\r\nerror = sas_init_queue(sas_ha);\r\nif (error) {\r\nprintk(KERN_NOTICE "couldn't start queue thread:%d, "\r\n"running in direct mode\n", error);\r\nsas_ha->lldd_max_execute_num = 1;\r\n}\r\n}\r\nINIT_LIST_HEAD(&sas_ha->eh_done_q);\r\nreturn 0;\r\nUndo_ports:\r\nsas_unregister_ports(sas_ha);\r\nUndo_phys:\r\nreturn error;\r\n}\r\nint sas_unregister_ha(struct sas_ha_struct *sas_ha)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sas_ha->state_lock, flags);\r\nsas_ha->state = SAS_HA_UNREGISTERED;\r\nspin_unlock_irqrestore(&sas_ha->state_lock, flags);\r\nscsi_flush_work(sas_ha->core.shost);\r\nsas_unregister_ports(sas_ha);\r\nif (sas_ha->lldd_max_execute_num > 1) {\r\nsas_shutdown_queue(sas_ha);\r\nsas_ha->lldd_max_execute_num = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sas_get_linkerrors(struct sas_phy *phy)\r\n{\r\nif (scsi_is_sas_phy_local(phy)) {\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\r\nstruct asd_sas_phy *asd_phy = sas_ha->sas_phy[phy->number];\r\nstruct sas_internal *i =\r\nto_sas_internal(sas_ha->core.shost->transportt);\r\nreturn i->dft->lldd_control_phy(asd_phy, PHY_FUNC_GET_EVENTS, NULL);\r\n}\r\nreturn sas_smp_get_phy_events(phy);\r\n}\r\nint sas_phy_enable(struct sas_phy *phy, int enable)\r\n{\r\nint ret;\r\nenum phy_func command;\r\nif (enable)\r\ncommand = PHY_FUNC_LINK_RESET;\r\nelse\r\ncommand = PHY_FUNC_DISABLE;\r\nif (scsi_is_sas_phy_local(phy)) {\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\r\nstruct asd_sas_phy *asd_phy = sas_ha->sas_phy[phy->number];\r\nstruct sas_internal *i =\r\nto_sas_internal(sas_ha->core.shost->transportt);\r\nif (!enable) {\r\nsas_phy_disconnected(asd_phy);\r\nsas_ha->notify_phy_event(asd_phy, PHYE_LOSS_OF_SIGNAL);\r\n}\r\nret = i->dft->lldd_control_phy(asd_phy, command, NULL);\r\n} else {\r\nstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\r\nstruct domain_device *ddev = sas_find_dev_by_rphy(rphy);\r\nret = sas_smp_phy_control(ddev, phy->number, command, NULL);\r\n}\r\nreturn ret;\r\n}\r\nint sas_phy_reset(struct sas_phy *phy, int hard_reset)\r\n{\r\nint ret;\r\nenum phy_func reset_type;\r\nif (hard_reset)\r\nreset_type = PHY_FUNC_HARD_RESET;\r\nelse\r\nreset_type = PHY_FUNC_LINK_RESET;\r\nif (scsi_is_sas_phy_local(phy)) {\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\r\nstruct asd_sas_phy *asd_phy = sas_ha->sas_phy[phy->number];\r\nstruct sas_internal *i =\r\nto_sas_internal(sas_ha->core.shost->transportt);\r\nret = i->dft->lldd_control_phy(asd_phy, reset_type, NULL);\r\n} else {\r\nstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\r\nstruct domain_device *ddev = sas_find_dev_by_rphy(rphy);\r\nret = sas_smp_phy_control(ddev, phy->number, reset_type, NULL);\r\n}\r\nreturn ret;\r\n}\r\nint sas_set_phy_speed(struct sas_phy *phy,\r\nstruct sas_phy_linkrates *rates)\r\n{\r\nint ret;\r\nif ((rates->minimum_linkrate &&\r\nrates->minimum_linkrate > phy->maximum_linkrate) ||\r\n(rates->maximum_linkrate &&\r\nrates->maximum_linkrate < phy->minimum_linkrate))\r\nreturn -EINVAL;\r\nif (rates->minimum_linkrate &&\r\nrates->minimum_linkrate < phy->minimum_linkrate_hw)\r\nrates->minimum_linkrate = phy->minimum_linkrate_hw;\r\nif (rates->maximum_linkrate &&\r\nrates->maximum_linkrate > phy->maximum_linkrate_hw)\r\nrates->maximum_linkrate = phy->maximum_linkrate_hw;\r\nif (scsi_is_sas_phy_local(phy)) {\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\r\nstruct asd_sas_phy *asd_phy = sas_ha->sas_phy[phy->number];\r\nstruct sas_internal *i =\r\nto_sas_internal(sas_ha->core.shost->transportt);\r\nret = i->dft->lldd_control_phy(asd_phy, PHY_FUNC_SET_LINK_RATE,\r\nrates);\r\n} else {\r\nstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\r\nstruct domain_device *ddev = sas_find_dev_by_rphy(rphy);\r\nret = sas_smp_phy_control(ddev, phy->number,\r\nPHY_FUNC_LINK_RESET, rates);\r\n}\r\nreturn ret;\r\n}\r\nstruct scsi_transport_template *\r\nsas_domain_attach_transport(struct sas_domain_function_template *dft)\r\n{\r\nstruct scsi_transport_template *stt = sas_attach_transport(&sft);\r\nstruct sas_internal *i;\r\nif (!stt)\r\nreturn stt;\r\ni = to_sas_internal(stt);\r\ni->dft = dft;\r\nstt->create_work_queue = 1;\r\nstt->eh_timed_out = sas_scsi_timed_out;\r\nstt->eh_strategy_handler = sas_scsi_recover_host;\r\nreturn stt;\r\n}\r\nvoid sas_domain_release_transport(struct scsi_transport_template *stt)\r\n{\r\nsas_release_transport(stt);\r\n}\r\nstatic int __init sas_class_init(void)\r\n{\r\nsas_task_cache = KMEM_CACHE(sas_task, SLAB_HWCACHE_ALIGN);\r\nif (!sas_task_cache)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __exit sas_class_exit(void)\r\n{\r\nkmem_cache_destroy(sas_task_cache);\r\n}
