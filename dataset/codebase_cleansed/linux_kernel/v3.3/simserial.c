static void rs_stop(struct tty_struct *tty)\r\n{\r\n#ifdef SIMSERIAL_DEBUG\r\nprintk("rs_stop: tty->stopped=%d tty->hw_stopped=%d tty->flow_stopped=%d\n",\r\ntty->stopped, tty->hw_stopped, tty->flow_stopped);\r\n#endif\r\n}\r\nstatic void rs_start(struct tty_struct *tty)\r\n{\r\n#ifdef SIMSERIAL_DEBUG\r\nprintk("rs_start: tty->stopped=%d tty->hw_stopped=%d tty->flow_stopped=%d\n",\r\ntty->stopped, tty->hw_stopped, tty->flow_stopped);\r\n#endif\r\n}\r\nstatic void receive_chars(struct tty_struct *tty)\r\n{\r\nunsigned char ch;\r\nstatic unsigned char seen_esc = 0;\r\nwhile ( (ch = ia64_ssc(0, 0, 0, 0, SSC_GETCHAR)) ) {\r\nif ( ch == 27 && seen_esc == 0 ) {\r\nseen_esc = 1;\r\ncontinue;\r\n} else {\r\nif ( seen_esc==1 && ch == 'O' ) {\r\nseen_esc = 2;\r\ncontinue;\r\n} else if ( seen_esc == 2 ) {\r\nif ( ch == 'P' )\r\nshow_state();\r\n#ifdef CONFIG_MAGIC_SYSRQ\r\nif ( ch == 'S' ) {\r\ndo\r\nch = ia64_ssc(0, 0, 0, 0,\r\nSSC_GETCHAR);\r\nwhile (!ch);\r\nhandle_sysrq(ch);\r\n}\r\n#endif\r\nseen_esc = 0;\r\ncontinue;\r\n}\r\n}\r\nseen_esc = 0;\r\nif (tty_insert_flip_char(tty, ch, TTY_NORMAL) == 0)\r\nbreak;\r\n}\r\ntty_flip_buffer_push(tty);\r\n}\r\nstatic irqreturn_t rs_interrupt_single(int irq, void *dev_id)\r\n{\r\nstruct async_struct * info;\r\ninfo = IRQ_ports[irq];\r\nif (!info || !info->tty) {\r\nprintk(KERN_INFO "simrs_interrupt_single: info|tty=0 info=%p problem\n", info);\r\nreturn IRQ_NONE;\r\n}\r\nreceive_chars(info->tty);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void do_softint(struct work_struct *private_)\r\n{\r\nprintk(KERN_ERR "simserial: do_softint called\n");\r\n}\r\nstatic int rs_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nstruct async_struct *info = (struct async_struct *)tty->driver_data;\r\nunsigned long flags;\r\nif (!tty || !info->xmit.buf)\r\nreturn 0;\r\nlocal_irq_save(flags);\r\nif (CIRC_SPACE(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE) == 0) {\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\ninfo->xmit.buf[info->xmit.head] = ch;\r\ninfo->xmit.head = (info->xmit.head + 1) & (SERIAL_XMIT_SIZE-1);\r\nlocal_irq_restore(flags);\r\nreturn 1;\r\n}\r\nstatic void transmit_chars(struct async_struct *info, int *intr_done)\r\n{\r\nint count;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (info->x_char) {\r\nchar c = info->x_char;\r\nconsole->write(console, &c, 1);\r\ninfo->state->icount.tx++;\r\ninfo->x_char = 0;\r\ngoto out;\r\n}\r\nif (info->xmit.head == info->xmit.tail || info->tty->stopped || info->tty->hw_stopped) {\r\n#ifdef SIMSERIAL_DEBUG\r\nprintk("transmit_chars: head=%d, tail=%d, stopped=%d\n",\r\ninfo->xmit.head, info->xmit.tail, info->tty->stopped);\r\n#endif\r\ngoto out;\r\n}\r\ncount = min(CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE),\r\nSERIAL_XMIT_SIZE - info->xmit.tail);\r\nconsole->write(console, info->xmit.buf+info->xmit.tail, count);\r\ninfo->xmit.tail = (info->xmit.tail+count) & (SERIAL_XMIT_SIZE-1);\r\ncount = CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);\r\nif (count) {\r\nconsole->write(console, info->xmit.buf, count);\r\ninfo->xmit.tail += count;\r\n}\r\nout:\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void rs_flush_chars(struct tty_struct *tty)\r\n{\r\nstruct async_struct *info = (struct async_struct *)tty->driver_data;\r\nif (info->xmit.head == info->xmit.tail || tty->stopped || tty->hw_stopped ||\r\n!info->xmit.buf)\r\nreturn;\r\ntransmit_chars(info, NULL);\r\n}\r\nstatic int rs_write(struct tty_struct * tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nint c, ret = 0;\r\nstruct async_struct *info = (struct async_struct *)tty->driver_data;\r\nunsigned long flags;\r\nif (!tty || !info->xmit.buf || !tmp_buf) return 0;\r\nlocal_irq_save(flags);\r\nwhile (1) {\r\nc = CIRC_SPACE_TO_END(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);\r\nif (count < c)\r\nc = count;\r\nif (c <= 0) {\r\nbreak;\r\n}\r\nmemcpy(info->xmit.buf + info->xmit.head, buf, c);\r\ninfo->xmit.head = ((info->xmit.head + c) &\r\n(SERIAL_XMIT_SIZE-1));\r\nbuf += c;\r\ncount -= c;\r\nret += c;\r\n}\r\nlocal_irq_restore(flags);\r\nif (CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE)\r\n&& !tty->stopped && !tty->hw_stopped) {\r\ntransmit_chars(info, NULL);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rs_write_room(struct tty_struct *tty)\r\n{\r\nstruct async_struct *info = (struct async_struct *)tty->driver_data;\r\nreturn CIRC_SPACE(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);\r\n}\r\nstatic int rs_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct async_struct *info = (struct async_struct *)tty->driver_data;\r\nreturn CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);\r\n}\r\nstatic void rs_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct async_struct *info = (struct async_struct *)tty->driver_data;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ninfo->xmit.head = info->xmit.tail = 0;\r\nlocal_irq_restore(flags);\r\ntty_wakeup(tty);\r\n}\r\nstatic void rs_send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nstruct async_struct *info = (struct async_struct *)tty->driver_data;\r\ninfo->x_char = ch;\r\nif (ch) {\r\ntransmit_chars(info, NULL);\r\n}\r\n}\r\nstatic void rs_throttle(struct tty_struct * tty)\r\n{\r\nif (I_IXOFF(tty)) rs_send_xchar(tty, STOP_CHAR(tty));\r\nprintk(KERN_INFO "simrs_throttle called\n");\r\n}\r\nstatic void rs_unthrottle(struct tty_struct * tty)\r\n{\r\nstruct async_struct *info = (struct async_struct *)tty->driver_data;\r\nif (I_IXOFF(tty)) {\r\nif (info->x_char)\r\ninfo->x_char = 0;\r\nelse\r\nrs_send_xchar(tty, START_CHAR(tty));\r\n}\r\nprintk(KERN_INFO "simrs_unthrottle called\n");\r\n}\r\nstatic int rs_ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg)\r\n{\r\nif ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&\r\n(cmd != TIOCSERCONFIG) && (cmd != TIOCSERGSTRUCT) &&\r\n(cmd != TIOCMIWAIT)) {\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\n}\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nprintk(KERN_INFO "simrs_ioctl TIOCGSERIAL called\n");\r\nreturn 0;\r\ncase TIOCSSERIAL:\r\nprintk(KERN_INFO "simrs_ioctl TIOCSSERIAL called\n");\r\nreturn 0;\r\ncase TIOCSERCONFIG:\r\nprintk(KERN_INFO "rs_ioctl: TIOCSERCONFIG called\n");\r\nreturn -EINVAL;\r\ncase TIOCSERGETLSR:\r\nprintk(KERN_INFO "rs_ioctl: TIOCSERGETLSR called\n");\r\nreturn -EINVAL;\r\ncase TIOCSERGSTRUCT:\r\nprintk(KERN_INFO "rs_ioctl: TIOCSERGSTRUCT called\n");\r\n#if 0\r\nif (copy_to_user((struct async_struct *) arg,\r\ninfo, sizeof(struct async_struct)))\r\nreturn -EFAULT;\r\n#endif\r\nreturn 0;\r\ncase TIOCMIWAIT:\r\nprintk(KERN_INFO "rs_ioctl: TIOCMIWAIT: called\n");\r\nreturn 0;\r\ncase TIOCSERGWILD:\r\ncase TIOCSERSWILD:\r\nprintk (KERN_INFO "TIOCSER?WILD ioctl obsolete, ignored.\n");\r\nreturn 0;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rs_set_termios(struct tty_struct *tty, struct ktermios *old_termios)\r\n{\r\nif ((old_termios->c_cflag & CRTSCTS) &&\r\n!(tty->termios->c_cflag & CRTSCTS)) {\r\ntty->hw_stopped = 0;\r\nrs_start(tty);\r\n}\r\n}\r\nstatic void shutdown(struct async_struct * info)\r\n{\r\nunsigned long flags;\r\nstruct serial_state *state;\r\nint retval;\r\nif (!(info->flags & ASYNC_INITIALIZED)) return;\r\nstate = info->state;\r\n#ifdef SIMSERIAL_DEBUG\r\nprintk("Shutting down serial port %d (irq %d)....", info->line,\r\nstate->irq);\r\n#endif\r\nlocal_irq_save(flags);\r\n{\r\nif (info->next_port)\r\ninfo->next_port->prev_port = info->prev_port;\r\nif (info->prev_port)\r\ninfo->prev_port->next_port = info->next_port;\r\nelse\r\nIRQ_ports[state->irq] = info->next_port;\r\nif (state->irq && (!IRQ_ports[state->irq] ||\r\n!IRQ_ports[state->irq]->next_port)) {\r\nif (IRQ_ports[state->irq]) {\r\nfree_irq(state->irq, NULL);\r\nretval = request_irq(state->irq, rs_interrupt_single,\r\nIRQ_T(info), "serial", NULL);\r\nif (retval)\r\nprintk(KERN_ERR "serial shutdown: request_irq: error %d"\r\n" Couldn't reacquire IRQ.\n", retval);\r\n} else\r\nfree_irq(state->irq, NULL);\r\n}\r\nif (info->xmit.buf) {\r\nfree_page((unsigned long) info->xmit.buf);\r\ninfo->xmit.buf = NULL;\r\n}\r\nif (info->tty) set_bit(TTY_IO_ERROR, &info->tty->flags);\r\ninfo->flags &= ~ASYNC_INITIALIZED;\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void rs_close(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct async_struct * info = (struct async_struct *)tty->driver_data;\r\nstruct serial_state *state;\r\nunsigned long flags;\r\nif (!info ) return;\r\nstate = info->state;\r\nlocal_irq_save(flags);\r\nif (tty_hung_up_p(filp)) {\r\n#ifdef SIMSERIAL_DEBUG\r\nprintk("rs_close: hung_up\n");\r\n#endif\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\n#ifdef SIMSERIAL_DEBUG\r\nprintk("rs_close ttys%d, count = %d\n", info->line, state->count);\r\n#endif\r\nif ((tty->count == 1) && (state->count != 1)) {\r\nprintk(KERN_ERR "rs_close: bad serial port count; tty->count is 1, "\r\n"state->count is %d\n", state->count);\r\nstate->count = 1;\r\n}\r\nif (--state->count < 0) {\r\nprintk(KERN_ERR "rs_close: bad serial port count for ttys%d: %d\n",\r\ninfo->line, state->count);\r\nstate->count = 0;\r\n}\r\nif (state->count) {\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\ninfo->flags |= ASYNC_CLOSING;\r\nlocal_irq_restore(flags);\r\nshutdown(info);\r\nrs_flush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\ninfo->event = 0;\r\ninfo->tty = NULL;\r\nif (info->blocked_open) {\r\nif (info->close_delay)\r\nschedule_timeout_interruptible(info->close_delay);\r\nwake_up_interruptible(&info->open_wait);\r\n}\r\ninfo->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);\r\nwake_up_interruptible(&info->close_wait);\r\n}\r\nstatic void rs_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\n}\r\nstatic void rs_hangup(struct tty_struct *tty)\r\n{\r\nstruct async_struct * info = (struct async_struct *)tty->driver_data;\r\nstruct serial_state *state = info->state;\r\n#ifdef SIMSERIAL_DEBUG\r\nprintk("rs_hangup: called\n");\r\n#endif\r\nstate = info->state;\r\nrs_flush_buffer(tty);\r\nif (info->flags & ASYNC_CLOSING)\r\nreturn;\r\nshutdown(info);\r\ninfo->event = 0;\r\nstate->count = 0;\r\ninfo->flags &= ~ASYNC_NORMAL_ACTIVE;\r\ninfo->tty = NULL;\r\nwake_up_interruptible(&info->open_wait);\r\n}\r\nstatic int get_async_struct(int line, struct async_struct **ret_info)\r\n{\r\nstruct async_struct *info;\r\nstruct serial_state *sstate;\r\nsstate = rs_table + line;\r\nsstate->count++;\r\nif (sstate->info) {\r\n*ret_info = sstate->info;\r\nreturn 0;\r\n}\r\ninfo = kzalloc(sizeof(struct async_struct), GFP_KERNEL);\r\nif (!info) {\r\nsstate->count--;\r\nreturn -ENOMEM;\r\n}\r\ninit_waitqueue_head(&info->open_wait);\r\ninit_waitqueue_head(&info->close_wait);\r\ninit_waitqueue_head(&info->delta_msr_wait);\r\ninfo->magic = SERIAL_MAGIC;\r\ninfo->port = sstate->port;\r\ninfo->flags = sstate->flags;\r\ninfo->xmit_fifo_size = sstate->xmit_fifo_size;\r\ninfo->line = line;\r\nINIT_WORK(&info->work, do_softint);\r\ninfo->state = sstate;\r\nif (sstate->info) {\r\nkfree(info);\r\n*ret_info = sstate->info;\r\nreturn 0;\r\n}\r\n*ret_info = sstate->info = info;\r\nreturn 0;\r\n}\r\nstatic int\r\nstartup(struct async_struct *info)\r\n{\r\nunsigned long flags;\r\nint retval=0;\r\nirq_handler_t handler;\r\nstruct serial_state *state= info->state;\r\nunsigned long page;\r\npage = get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\nreturn -ENOMEM;\r\nlocal_irq_save(flags);\r\nif (info->flags & ASYNC_INITIALIZED) {\r\nfree_page(page);\r\ngoto errout;\r\n}\r\nif (!state->port || !state->type) {\r\nif (info->tty) set_bit(TTY_IO_ERROR, &info->tty->flags);\r\nfree_page(page);\r\ngoto errout;\r\n}\r\nif (info->xmit.buf)\r\nfree_page(page);\r\nelse\r\ninfo->xmit.buf = (unsigned char *) page;\r\n#ifdef SIMSERIAL_DEBUG\r\nprintk("startup: ttys%d (irq %d)...", info->line, state->irq);\r\n#endif\r\nif (state->irq && (!IRQ_ports[state->irq] ||\r\n!IRQ_ports[state->irq]->next_port)) {\r\nif (IRQ_ports[state->irq]) {\r\nretval = -EBUSY;\r\ngoto errout;\r\n} else\r\nhandler = rs_interrupt_single;\r\nretval = request_irq(state->irq, handler, IRQ_T(info), "simserial", NULL);\r\nif (retval) {\r\nif (capable(CAP_SYS_ADMIN)) {\r\nif (info->tty)\r\nset_bit(TTY_IO_ERROR,\r\n&info->tty->flags);\r\nretval = 0;\r\n}\r\ngoto errout;\r\n}\r\n}\r\ninfo->prev_port = NULL;\r\ninfo->next_port = IRQ_ports[state->irq];\r\nif (info->next_port)\r\ninfo->next_port->prev_port = info;\r\nIRQ_ports[state->irq] = info;\r\nif (info->tty) clear_bit(TTY_IO_ERROR, &info->tty->flags);\r\ninfo->xmit.head = info->xmit.tail = 0;\r\n#if 0\r\ntimer_table[RS_TIMER].expires = jiffies + 2*HZ/100;\r\ntimer_active |= 1 << RS_TIMER;\r\n#endif\r\nif (info->tty) {\r\nif ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)\r\ninfo->tty->alt_speed = 57600;\r\nif ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)\r\ninfo->tty->alt_speed = 115200;\r\nif ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)\r\ninfo->tty->alt_speed = 230400;\r\nif ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)\r\ninfo->tty->alt_speed = 460800;\r\n}\r\ninfo->flags |= ASYNC_INITIALIZED;\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\nerrout:\r\nlocal_irq_restore(flags);\r\nreturn retval;\r\n}\r\nstatic int rs_open(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct async_struct *info;\r\nint retval, line;\r\nunsigned long page;\r\nline = tty->index;\r\nif ((line < 0) || (line >= NR_PORTS))\r\nreturn -ENODEV;\r\nretval = get_async_struct(line, &info);\r\nif (retval)\r\nreturn retval;\r\ntty->driver_data = info;\r\ninfo->tty = tty;\r\n#ifdef SIMSERIAL_DEBUG\r\nprintk("rs_open %s, count = %d\n", tty->name, info->state->count);\r\n#endif\r\ninfo->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;\r\nif (!tmp_buf) {\r\npage = get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\nreturn -ENOMEM;\r\nif (tmp_buf)\r\nfree_page(page);\r\nelse\r\ntmp_buf = (unsigned char *) page;\r\n}\r\nif (tty_hung_up_p(filp) ||\r\n(info->flags & ASYNC_CLOSING)) {\r\nif (info->flags & ASYNC_CLOSING)\r\ninterruptible_sleep_on(&info->close_wait);\r\n#ifdef SERIAL_DO_RESTART\r\nreturn ((info->flags & ASYNC_HUP_NOTIFY) ?\r\n-EAGAIN : -ERESTARTSYS);\r\n#else\r\nreturn -EAGAIN;\r\n#endif\r\n}\r\nretval = startup(info);\r\nif (retval) {\r\nreturn retval;\r\n}\r\nconsole = console_drivers;\r\nwhile (console) {\r\nif ((console->flags & CON_ENABLED) && console->write) break;\r\nconsole = console->next;\r\n}\r\n#ifdef SIMSERIAL_DEBUG\r\nprintk("rs_open ttys%d successful\n", info->line);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic inline void line_info(struct seq_file *m, struct serial_state *state)\r\n{\r\nseq_printf(m, "%d: uart:%s port:%lX irq:%d\n",\r\nstate->line, uart_config[state->type].name,\r\nstate->port, state->irq);\r\n}\r\nstatic int rs_proc_show(struct seq_file *m, void *v)\r\n{\r\nint i;\r\nseq_printf(m, "simserinfo:1.0 driver:%s\n", serial_version);\r\nfor (i = 0; i < NR_PORTS; i++)\r\nline_info(m, &rs_table[i]);\r\nreturn 0;\r\n}\r\nstatic int rs_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, rs_proc_show, NULL);\r\n}\r\nstatic inline void show_serial_version(void)\r\n{\r\nprintk(KERN_INFO "%s version %s with", serial_name, serial_version);\r\nprintk(KERN_INFO " no serial options enabled\n");\r\n}\r\nstatic int __init\r\nsimrs_init (void)\r\n{\r\nint i, rc;\r\nstruct serial_state *state;\r\nif (!ia64_platform_is("hpsim"))\r\nreturn -ENODEV;\r\nhp_simserial_driver = alloc_tty_driver(1);\r\nif (!hp_simserial_driver)\r\nreturn -ENOMEM;\r\nshow_serial_version();\r\nhp_simserial_driver->owner = THIS_MODULE;\r\nhp_simserial_driver->driver_name = "simserial";\r\nhp_simserial_driver->name = "ttyS";\r\nhp_simserial_driver->major = TTY_MAJOR;\r\nhp_simserial_driver->minor_start = 64;\r\nhp_simserial_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nhp_simserial_driver->subtype = SERIAL_TYPE_NORMAL;\r\nhp_simserial_driver->init_termios = tty_std_termios;\r\nhp_simserial_driver->init_termios.c_cflag =\r\nB9600 | CS8 | CREAD | HUPCL | CLOCAL;\r\nhp_simserial_driver->flags = TTY_DRIVER_REAL_RAW;\r\ntty_set_operations(hp_simserial_driver, &hp_ops);\r\nfor (i = 0, state = rs_table; i < NR_PORTS; i++,state++) {\r\nif (state->type == PORT_UNKNOWN) continue;\r\nif (!state->irq) {\r\nif ((rc = assign_irq_vector(AUTO_ASSIGN)) < 0)\r\npanic("%s: out of interrupt vectors!\n",\r\n__func__);\r\nstate->irq = rc;\r\nia64_ssc_connect_irq(KEYBOARD_INTR, state->irq);\r\n}\r\nprintk(KERN_INFO "ttyS%d at 0x%04lx (irq = %d) is a %s\n",\r\nstate->line,\r\nstate->port, state->irq,\r\nuart_config[state->type].name);\r\n}\r\nif (tty_register_driver(hp_simserial_driver))\r\npanic("Couldn't register simserial driver\n");\r\nreturn 0;\r\n}
