static void printk_prot(struct seq_file *m, pgprot_t prot, int level)\r\n{\r\npgprotval_t pr = pgprot_val(prot);\r\nstatic const char * const level_name[] =\r\n{ "cr3", "pgd", "pud", "pmd", "pte" };\r\nif (!pgprot_val(prot)) {\r\nseq_printf(m, " ");\r\n} else {\r\nif (pr & _PAGE_USER)\r\nseq_printf(m, "USR ");\r\nelse\r\nseq_printf(m, " ");\r\nif (pr & _PAGE_RW)\r\nseq_printf(m, "RW ");\r\nelse\r\nseq_printf(m, "ro ");\r\nif (pr & _PAGE_PWT)\r\nseq_printf(m, "PWT ");\r\nelse\r\nseq_printf(m, " ");\r\nif (pr & _PAGE_PCD)\r\nseq_printf(m, "PCD ");\r\nelse\r\nseq_printf(m, " ");\r\nif (level <= 3) {\r\nif (pr & _PAGE_PSE)\r\nseq_printf(m, "PSE ");\r\nelse\r\nseq_printf(m, " ");\r\n} else {\r\nif (pr & _PAGE_PAT)\r\nseq_printf(m, "pat ");\r\nelse\r\nseq_printf(m, " ");\r\n}\r\nif (pr & _PAGE_GLOBAL)\r\nseq_printf(m, "GLB ");\r\nelse\r\nseq_printf(m, " ");\r\nif (pr & _PAGE_NX)\r\nseq_printf(m, "NX ");\r\nelse\r\nseq_printf(m, "x ");\r\n}\r\nseq_printf(m, "%s\n", level_name[level]);\r\n}\r\nstatic unsigned long normalize_addr(unsigned long u)\r\n{\r\n#ifdef CONFIG_X86_64\r\nreturn (signed long)(u << 16) >> 16;\r\n#else\r\nreturn u;\r\n#endif\r\n}\r\nstatic void note_page(struct seq_file *m, struct pg_state *st,\r\npgprot_t new_prot, int level)\r\n{\r\npgprotval_t prot, cur;\r\nstatic const char units[] = "KMGTPE";\r\nprot = pgprot_val(new_prot) & PTE_FLAGS_MASK;\r\ncur = pgprot_val(st->current_prot) & PTE_FLAGS_MASK;\r\nif (!st->level) {\r\nst->current_prot = new_prot;\r\nst->level = level;\r\nst->marker = address_markers;\r\nseq_printf(m, "---[ %s ]---\n", st->marker->name);\r\n} else if (prot != cur || level != st->level ||\r\nst->current_address >= st->marker[1].start_address) {\r\nconst char *unit = units;\r\nunsigned long delta;\r\nint width = sizeof(unsigned long) * 2;\r\nseq_printf(m, "0x%0*lx-0x%0*lx ",\r\nwidth, st->start_address,\r\nwidth, st->current_address);\r\ndelta = (st->current_address - st->start_address) >> 10;\r\nwhile (!(delta & 1023) && unit[1]) {\r\ndelta >>= 10;\r\nunit++;\r\n}\r\nseq_printf(m, "%9lu%c ", delta, *unit);\r\nprintk_prot(m, st->current_prot, st->level);\r\nif (st->current_address >= st->marker[1].start_address) {\r\nst->marker++;\r\nseq_printf(m, "---[ %s ]---\n", st->marker->name);\r\n}\r\nst->start_address = st->current_address;\r\nst->current_prot = new_prot;\r\nst->level = level;\r\n}\r\n}\r\nstatic void walk_pte_level(struct seq_file *m, struct pg_state *st, pmd_t addr,\r\nunsigned long P)\r\n{\r\nint i;\r\npte_t *start;\r\nstart = (pte_t *) pmd_page_vaddr(addr);\r\nfor (i = 0; i < PTRS_PER_PTE; i++) {\r\npgprot_t prot = pte_pgprot(*start);\r\nst->current_address = normalize_addr(P + i * PTE_LEVEL_MULT);\r\nnote_page(m, st, prot, 4);\r\nstart++;\r\n}\r\n}\r\nstatic void walk_pmd_level(struct seq_file *m, struct pg_state *st, pud_t addr,\r\nunsigned long P)\r\n{\r\nint i;\r\npmd_t *start;\r\nstart = (pmd_t *) pud_page_vaddr(addr);\r\nfor (i = 0; i < PTRS_PER_PMD; i++) {\r\nst->current_address = normalize_addr(P + i * PMD_LEVEL_MULT);\r\nif (!pmd_none(*start)) {\r\npgprotval_t prot = pmd_val(*start) & PTE_FLAGS_MASK;\r\nif (pmd_large(*start) || !pmd_present(*start))\r\nnote_page(m, st, __pgprot(prot), 3);\r\nelse\r\nwalk_pte_level(m, st, *start,\r\nP + i * PMD_LEVEL_MULT);\r\n} else\r\nnote_page(m, st, __pgprot(0), 3);\r\nstart++;\r\n}\r\n}\r\nstatic void walk_pud_level(struct seq_file *m, struct pg_state *st, pgd_t addr,\r\nunsigned long P)\r\n{\r\nint i;\r\npud_t *start;\r\nstart = (pud_t *) pgd_page_vaddr(addr);\r\nfor (i = 0; i < PTRS_PER_PUD; i++) {\r\nst->current_address = normalize_addr(P + i * PUD_LEVEL_MULT);\r\nif (!pud_none(*start)) {\r\npgprotval_t prot = pud_val(*start) & PTE_FLAGS_MASK;\r\nif (pud_large(*start) || !pud_present(*start))\r\nnote_page(m, st, __pgprot(prot), 2);\r\nelse\r\nwalk_pmd_level(m, st, *start,\r\nP + i * PUD_LEVEL_MULT);\r\n} else\r\nnote_page(m, st, __pgprot(0), 2);\r\nstart++;\r\n}\r\n}\r\nstatic void walk_pgd_level(struct seq_file *m)\r\n{\r\n#ifdef CONFIG_X86_64\r\npgd_t *start = (pgd_t *) &init_level4_pgt;\r\n#else\r\npgd_t *start = swapper_pg_dir;\r\n#endif\r\nint i;\r\nstruct pg_state st;\r\nmemset(&st, 0, sizeof(st));\r\nfor (i = 0; i < PTRS_PER_PGD; i++) {\r\nst.current_address = normalize_addr(i * PGD_LEVEL_MULT);\r\nif (!pgd_none(*start)) {\r\npgprotval_t prot = pgd_val(*start) & PTE_FLAGS_MASK;\r\nif (pgd_large(*start) || !pgd_present(*start))\r\nnote_page(m, &st, __pgprot(prot), 1);\r\nelse\r\nwalk_pud_level(m, &st, *start,\r\ni * PGD_LEVEL_MULT);\r\n} else\r\nnote_page(m, &st, __pgprot(0), 1);\r\nstart++;\r\n}\r\nst.current_address = normalize_addr(PTRS_PER_PGD*PGD_LEVEL_MULT);\r\nnote_page(m, &st, __pgprot(0), 0);\r\n}\r\nstatic int ptdump_show(struct seq_file *m, void *v)\r\n{\r\nwalk_pgd_level(m);\r\nreturn 0;\r\n}\r\nstatic int ptdump_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn single_open(filp, ptdump_show, NULL);\r\n}\r\nstatic int pt_dump_init(void)\r\n{\r\nstruct dentry *pe;\r\n#ifdef CONFIG_X86_32\r\naddress_markers[VMALLOC_START_NR].start_address = VMALLOC_START;\r\naddress_markers[VMALLOC_END_NR].start_address = VMALLOC_END;\r\n# ifdef CONFIG_HIGHMEM\r\naddress_markers[PKMAP_BASE_NR].start_address = PKMAP_BASE;\r\n# endif\r\naddress_markers[FIXADDR_START_NR].start_address = FIXADDR_START;\r\n#endif\r\npe = debugfs_create_file("kernel_page_tables", 0600, NULL, NULL,\r\n&ptdump_fops);\r\nif (!pe)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}
