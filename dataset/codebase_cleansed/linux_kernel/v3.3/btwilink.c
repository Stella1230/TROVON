static inline void ti_st_tx_complete(struct ti_st *hst, int pkt_type)\r\n{\r\nstruct hci_dev *hdev = hst->hdev;\r\nswitch (pkt_type) {\r\ncase HCI_COMMAND_PKT:\r\nhdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nhdev->stat.acl_tx++;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nhdev->stat.sco_tx++;\r\nbreak;\r\n}\r\n}\r\nstatic void st_reg_completion_cb(void *priv_data, char data)\r\n{\r\nstruct ti_st *lhst = priv_data;\r\nlhst->reg_status = data;\r\ncomplete(&lhst->wait_reg_completion);\r\n}\r\nstatic long st_receive(void *priv_data, struct sk_buff *skb)\r\n{\r\nstruct ti_st *lhst = priv_data;\r\nint err;\r\nif (!skb)\r\nreturn -EFAULT;\r\nif (!lhst) {\r\nkfree_skb(skb);\r\nreturn -EFAULT;\r\n}\r\nskb->dev = (void *) lhst->hdev;\r\nerr = hci_recv_frame(skb);\r\nif (err < 0) {\r\nBT_ERR("Unable to push skb to HCI core(%d)", err);\r\nreturn err;\r\n}\r\nlhst->hdev->stat.byte_rx += skb->len;\r\nreturn 0;\r\n}\r\nstatic int ti_st_open(struct hci_dev *hdev)\r\n{\r\nunsigned long timeleft;\r\nstruct ti_st *hst;\r\nint err, i;\r\nBT_DBG("%s %p", hdev->name, hdev);\r\nif (test_and_set_bit(HCI_RUNNING, &hdev->flags))\r\nreturn -EBUSY;\r\nhst = hdev->driver_data;\r\nfor (i = 0; i < MAX_BT_CHNL_IDS; i++) {\r\nti_st_proto[i].priv_data = hst;\r\nti_st_proto[i].max_frame_size = HCI_MAX_FRAME_SIZE;\r\nti_st_proto[i].recv = st_receive;\r\nti_st_proto[i].reg_complete_cb = st_reg_completion_cb;\r\ninit_completion(&hst->wait_reg_completion);\r\nhst->reg_status = -EINPROGRESS;\r\nerr = st_register(&ti_st_proto[i]);\r\nif (!err)\r\ngoto done;\r\nif (err != -EINPROGRESS) {\r\nclear_bit(HCI_RUNNING, &hdev->flags);\r\nBT_ERR("st_register failed %d", err);\r\nreturn err;\r\n}\r\nBT_DBG("waiting for registration "\r\n"completion signal from ST");\r\ntimeleft = wait_for_completion_timeout\r\n(&hst->wait_reg_completion,\r\nmsecs_to_jiffies(BT_REGISTER_TIMEOUT));\r\nif (!timeleft) {\r\nclear_bit(HCI_RUNNING, &hdev->flags);\r\nBT_ERR("Timeout(%d sec),didn't get reg "\r\n"completion signal from ST",\r\nBT_REGISTER_TIMEOUT / 1000);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (hst->reg_status != 0) {\r\nclear_bit(HCI_RUNNING, &hdev->flags);\r\nBT_ERR("ST registration completed with invalid "\r\n"status %d", hst->reg_status);\r\nreturn -EAGAIN;\r\n}\r\ndone:\r\nhst->st_write = ti_st_proto[i].write;\r\nif (!hst->st_write) {\r\nBT_ERR("undefined ST write function");\r\nclear_bit(HCI_RUNNING, &hdev->flags);\r\nfor (i = 0; i < MAX_BT_CHNL_IDS; i++) {\r\nerr = st_unregister(&ti_st_proto[i]);\r\nif (err)\r\nBT_ERR("st_unregister() failed with "\r\n"error %d", err);\r\nhst->st_write = NULL;\r\n}\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_st_close(struct hci_dev *hdev)\r\n{\r\nint err, i;\r\nstruct ti_st *hst = hdev->driver_data;\r\nif (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))\r\nreturn 0;\r\nfor (i = MAX_BT_CHNL_IDS-1; i >= 0; i--) {\r\nerr = st_unregister(&ti_st_proto[i]);\r\nif (err)\r\nBT_ERR("st_unregister(%d) failed with error %d",\r\nti_st_proto[i].chnl_id, err);\r\n}\r\nhst->st_write = NULL;\r\nreturn err;\r\n}\r\nstatic int ti_st_send_frame(struct sk_buff *skb)\r\n{\r\nstruct hci_dev *hdev;\r\nstruct ti_st *hst;\r\nlong len;\r\nhdev = (struct hci_dev *)skb->dev;\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\nreturn -EBUSY;\r\nhst = hdev->driver_data;\r\nmemcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);\r\nBT_DBG("%s: type %d len %d", hdev->name, bt_cb(skb)->pkt_type,\r\nskb->len);\r\nlen = hst->st_write(skb);\r\nif (len < 0) {\r\nkfree_skb(skb);\r\nBT_ERR("ST write failed (%ld)", len);\r\nreturn -EAGAIN;\r\n}\r\nhdev->stat.byte_tx += len;\r\nti_st_tx_complete(hst, bt_cb(skb)->pkt_type);\r\nreturn 0;\r\n}\r\nstatic void ti_st_destruct(struct hci_dev *hdev)\r\n{\r\nBT_DBG("%s", hdev->name);\r\n}\r\nstatic int bt_ti_probe(struct platform_device *pdev)\r\n{\r\nstatic struct ti_st *hst;\r\nstruct hci_dev *hdev;\r\nint err;\r\nhst = kzalloc(sizeof(struct ti_st), GFP_KERNEL);\r\nif (!hst)\r\nreturn -ENOMEM;\r\nhdev = hci_alloc_dev();\r\nif (!hdev) {\r\nkfree(hst);\r\nreturn -ENOMEM;\r\n}\r\nBT_DBG("hdev %p", hdev);\r\nhst->hdev = hdev;\r\nhdev->bus = HCI_UART;\r\nhdev->driver_data = hst;\r\nhdev->open = ti_st_open;\r\nhdev->close = ti_st_close;\r\nhdev->flush = NULL;\r\nhdev->send = ti_st_send_frame;\r\nhdev->destruct = ti_st_destruct;\r\nhdev->owner = THIS_MODULE;\r\nerr = hci_register_dev(hdev);\r\nif (err < 0) {\r\nBT_ERR("Can't register HCI device error %d", err);\r\nkfree(hst);\r\nhci_free_dev(hdev);\r\nreturn err;\r\n}\r\nBT_DBG("HCI device registered (hdev %p)", hdev);\r\ndev_set_drvdata(&pdev->dev, hst);\r\nreturn err;\r\n}\r\nstatic int bt_ti_remove(struct platform_device *pdev)\r\n{\r\nstruct hci_dev *hdev;\r\nstruct ti_st *hst = dev_get_drvdata(&pdev->dev);\r\nif (!hst)\r\nreturn -EFAULT;\r\nBT_DBG("%s", hst->hdev->name);\r\nhdev = hst->hdev;\r\nti_st_close(hdev);\r\nhci_unregister_dev(hdev);\r\nhci_free_dev(hdev);\r\nkfree(hst);\r\ndev_set_drvdata(&pdev->dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init btwilink_init(void)\r\n{\r\nBT_INFO("Bluetooth Driver for TI WiLink - Version %s", VERSION);\r\nreturn platform_driver_register(&btwilink_driver);\r\n}\r\nstatic void __exit btwilink_exit(void)\r\n{\r\nplatform_driver_unregister(&btwilink_driver);\r\n}
