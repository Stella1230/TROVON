bool\r\nnv50_vram_flags_valid(struct drm_device *dev, u32 tile_flags)\r\n{\r\nint type = (tile_flags & NOUVEAU_GEM_TILE_LAYOUT_MASK) >> 8;\r\nif (likely(type < ARRAY_SIZE(types) && types[type]))\r\nreturn true;\r\nreturn false;\r\n}\r\nvoid\r\nnv50_vram_del(struct drm_device *dev, struct nouveau_mem **pmem)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_mm *mm = &dev_priv->engine.vram.mm;\r\nstruct nouveau_mm_node *this;\r\nstruct nouveau_mem *mem;\r\nmem = *pmem;\r\n*pmem = NULL;\r\nif (unlikely(mem == NULL))\r\nreturn;\r\nmutex_lock(&mm->mutex);\r\nwhile (!list_empty(&mem->regions)) {\r\nthis = list_first_entry(&mem->regions, struct nouveau_mm_node, rl_entry);\r\nlist_del(&this->rl_entry);\r\nnouveau_mm_put(mm, this);\r\n}\r\nif (mem->tag) {\r\ndrm_mm_put_block(mem->tag);\r\nmem->tag = NULL;\r\n}\r\nmutex_unlock(&mm->mutex);\r\nkfree(mem);\r\n}\r\nint\r\nnv50_vram_new(struct drm_device *dev, u64 size, u32 align, u32 size_nc,\r\nu32 memtype, struct nouveau_mem **pmem)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_mm *mm = &dev_priv->engine.vram.mm;\r\nstruct nouveau_mm_node *r;\r\nstruct nouveau_mem *mem;\r\nint comp = (memtype & 0x300) >> 8;\r\nint type = (memtype & 0x07f);\r\nint ret;\r\nif (!types[type])\r\nreturn -EINVAL;\r\nsize >>= 12;\r\nalign >>= 12;\r\nsize_nc >>= 12;\r\nmem = kzalloc(sizeof(*mem), GFP_KERNEL);\r\nif (!mem)\r\nreturn -ENOMEM;\r\nmutex_lock(&mm->mutex);\r\nif (comp) {\r\nif (align == 16) {\r\nstruct nouveau_fb_engine *pfb = &dev_priv->engine.fb;\r\nint n = (size >> 4) * comp;\r\nmem->tag = drm_mm_search_free(&pfb->tag_heap, n, 0, 0);\r\nif (mem->tag)\r\nmem->tag = drm_mm_get_block(mem->tag, n, 0);\r\n}\r\nif (unlikely(!mem->tag))\r\ncomp = 0;\r\n}\r\nINIT_LIST_HEAD(&mem->regions);\r\nmem->dev = dev_priv->dev;\r\nmem->memtype = (comp << 7) | type;\r\nmem->size = size;\r\ndo {\r\nret = nouveau_mm_get(mm, types[type], size, size_nc, align, &r);\r\nif (ret) {\r\nmutex_unlock(&mm->mutex);\r\nnv50_vram_del(dev, &mem);\r\nreturn ret;\r\n}\r\nlist_add_tail(&r->rl_entry, &mem->regions);\r\nsize -= r->length;\r\n} while (size);\r\nmutex_unlock(&mm->mutex);\r\nr = list_first_entry(&mem->regions, struct nouveau_mm_node, rl_entry);\r\nmem->offset = (u64)r->offset << 12;\r\n*pmem = mem;\r\nreturn 0;\r\n}\r\nstatic u32\r\nnv50_vram_rblock(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nint i, parts, colbits, rowbitsa, rowbitsb, banks;\r\nu64 rowsize, predicted;\r\nu32 r0, r4, rt, ru, rblock_size;\r\nr0 = nv_rd32(dev, 0x100200);\r\nr4 = nv_rd32(dev, 0x100204);\r\nrt = nv_rd32(dev, 0x100250);\r\nru = nv_rd32(dev, 0x001540);\r\nNV_DEBUG(dev, "memcfg 0x%08x 0x%08x 0x%08x 0x%08x\n", r0, r4, rt, ru);\r\nfor (i = 0, parts = 0; i < 8; i++) {\r\nif (ru & (0x00010000 << i))\r\nparts++;\r\n}\r\ncolbits = (r4 & 0x0000f000) >> 12;\r\nrowbitsa = ((r4 & 0x000f0000) >> 16) + 8;\r\nrowbitsb = ((r4 & 0x00f00000) >> 20) + 8;\r\nbanks = 1 << (((r4 & 0x03000000) >> 24) + 2);\r\nrowsize = parts * banks * (1 << colbits) * 8;\r\npredicted = rowsize << rowbitsa;\r\nif (r0 & 0x00000004)\r\npredicted += rowsize << rowbitsb;\r\nif (predicted != dev_priv->vram_size) {\r\nNV_WARN(dev, "memory controller reports %dMiB VRAM\n",\r\n(u32)(dev_priv->vram_size >> 20));\r\nNV_WARN(dev, "we calculated %dMiB VRAM\n",\r\n(u32)(predicted >> 20));\r\n}\r\nrblock_size = rowsize;\r\nif (rt & 1)\r\nrblock_size *= 3;\r\nNV_DEBUG(dev, "rblock %d bytes\n", rblock_size);\r\nreturn rblock_size;\r\n}\r\nint\r\nnv50_vram_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_vram_engine *vram = &dev_priv->engine.vram;\r\nconst u32 rsvd_head = ( 256 * 1024) >> 12;\r\nconst u32 rsvd_tail = (1024 * 1024) >> 12;\r\nu32 rblock, length;\r\ndev_priv->vram_size = nv_rd32(dev, 0x10020c);\r\ndev_priv->vram_size |= (dev_priv->vram_size & 0xff) << 32;\r\ndev_priv->vram_size &= 0xffffffff00ULL;\r\nif (dev_priv->chipset == 0xaa ||\r\ndev_priv->chipset == 0xac ||\r\ndev_priv->chipset == 0xaf) {\r\ndev_priv->vram_sys_base = (u64)nv_rd32(dev, 0x100e10) << 12;\r\nrblock = 4096 >> 12;\r\n} else {\r\nrblock = nv50_vram_rblock(dev) >> 12;\r\n}\r\nlength = (dev_priv->vram_size >> 12) - rsvd_head - rsvd_tail;\r\nreturn nouveau_mm_init(&vram->mm, rsvd_head, length, rblock);\r\n}\r\nvoid\r\nnv50_vram_fini(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_vram_engine *vram = &dev_priv->engine.vram;\r\nnouveau_mm_fini(&vram->mm);\r\n}
