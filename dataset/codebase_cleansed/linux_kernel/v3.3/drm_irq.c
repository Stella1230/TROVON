int drm_irq_by_busid(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_irq_busid *p = data;\r\nif (!dev->driver->bus->irq_by_busid)\r\nreturn -EINVAL;\r\nif (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))\r\nreturn -EINVAL;\r\nreturn dev->driver->bus->irq_by_busid(dev, p);\r\n}\r\nstatic void clear_vblank_timestamps(struct drm_device *dev, int crtc)\r\n{\r\nmemset(&dev->_vblank_time[crtc * DRM_VBLANKTIME_RBSIZE], 0,\r\nDRM_VBLANKTIME_RBSIZE * sizeof(struct timeval));\r\n}\r\nstatic void vblank_disable_and_save(struct drm_device *dev, int crtc)\r\n{\r\nunsigned long irqflags;\r\nu32 vblcount;\r\ns64 diff_ns;\r\nint vblrc;\r\nstruct timeval tvblank;\r\nspin_lock_irqsave(&dev->vblank_time_lock, irqflags);\r\ndev->driver->disable_vblank(dev, crtc);\r\ndev->vblank_enabled[crtc] = 0;\r\ndo {\r\ndev->last_vblank[crtc] = dev->driver->get_vblank_counter(dev, crtc);\r\nvblrc = drm_get_last_vbltimestamp(dev, crtc, &tvblank, 0);\r\n} while (dev->last_vblank[crtc] != dev->driver->get_vblank_counter(dev, crtc));\r\nvblcount = atomic_read(&dev->_vblank_count[crtc]);\r\ndiff_ns = timeval_to_ns(&tvblank) -\r\ntimeval_to_ns(&vblanktimestamp(dev, crtc, vblcount));\r\nif ((vblrc > 0) && (abs64(diff_ns) > 1000000)) {\r\natomic_inc(&dev->_vblank_count[crtc]);\r\nsmp_mb__after_atomic_inc();\r\n}\r\nclear_vblank_timestamps(dev, crtc);\r\nspin_unlock_irqrestore(&dev->vblank_time_lock, irqflags);\r\n}\r\nstatic void vblank_disable_fn(unsigned long arg)\r\n{\r\nstruct drm_device *dev = (struct drm_device *)arg;\r\nunsigned long irqflags;\r\nint i;\r\nif (!dev->vblank_disable_allowed)\r\nreturn;\r\nfor (i = 0; i < dev->num_crtcs; i++) {\r\nspin_lock_irqsave(&dev->vbl_lock, irqflags);\r\nif (atomic_read(&dev->vblank_refcount[i]) == 0 &&\r\ndev->vblank_enabled[i]) {\r\nDRM_DEBUG("disabling vblank on crtc %d\n", i);\r\nvblank_disable_and_save(dev, i);\r\n}\r\nspin_unlock_irqrestore(&dev->vbl_lock, irqflags);\r\n}\r\n}\r\nvoid drm_vblank_cleanup(struct drm_device *dev)\r\n{\r\nif (dev->num_crtcs == 0)\r\nreturn;\r\ndel_timer(&dev->vblank_disable_timer);\r\nvblank_disable_fn((unsigned long)dev);\r\nkfree(dev->vbl_queue);\r\nkfree(dev->_vblank_count);\r\nkfree(dev->vblank_refcount);\r\nkfree(dev->vblank_enabled);\r\nkfree(dev->last_vblank);\r\nkfree(dev->last_vblank_wait);\r\nkfree(dev->vblank_inmodeset);\r\nkfree(dev->_vblank_time);\r\ndev->num_crtcs = 0;\r\n}\r\nint drm_vblank_init(struct drm_device *dev, int num_crtcs)\r\n{\r\nint i, ret = -ENOMEM;\r\nsetup_timer(&dev->vblank_disable_timer, vblank_disable_fn,\r\n(unsigned long)dev);\r\nspin_lock_init(&dev->vbl_lock);\r\nspin_lock_init(&dev->vblank_time_lock);\r\ndev->num_crtcs = num_crtcs;\r\ndev->vbl_queue = kmalloc(sizeof(wait_queue_head_t) * num_crtcs,\r\nGFP_KERNEL);\r\nif (!dev->vbl_queue)\r\ngoto err;\r\ndev->_vblank_count = kmalloc(sizeof(atomic_t) * num_crtcs, GFP_KERNEL);\r\nif (!dev->_vblank_count)\r\ngoto err;\r\ndev->vblank_refcount = kmalloc(sizeof(atomic_t) * num_crtcs,\r\nGFP_KERNEL);\r\nif (!dev->vblank_refcount)\r\ngoto err;\r\ndev->vblank_enabled = kcalloc(num_crtcs, sizeof(int), GFP_KERNEL);\r\nif (!dev->vblank_enabled)\r\ngoto err;\r\ndev->last_vblank = kcalloc(num_crtcs, sizeof(u32), GFP_KERNEL);\r\nif (!dev->last_vblank)\r\ngoto err;\r\ndev->last_vblank_wait = kcalloc(num_crtcs, sizeof(u32), GFP_KERNEL);\r\nif (!dev->last_vblank_wait)\r\ngoto err;\r\ndev->vblank_inmodeset = kcalloc(num_crtcs, sizeof(int), GFP_KERNEL);\r\nif (!dev->vblank_inmodeset)\r\ngoto err;\r\ndev->_vblank_time = kcalloc(num_crtcs * DRM_VBLANKTIME_RBSIZE,\r\nsizeof(struct timeval), GFP_KERNEL);\r\nif (!dev->_vblank_time)\r\ngoto err;\r\nDRM_INFO("Supports vblank timestamp caching Rev 1 (10.10.2010).\n");\r\nif (dev->driver->get_vblank_timestamp)\r\nDRM_INFO("Driver supports precise vblank timestamp query.\n");\r\nelse\r\nDRM_INFO("No driver support for vblank timestamp query.\n");\r\nfor (i = 0; i < num_crtcs; i++) {\r\ninit_waitqueue_head(&dev->vbl_queue[i]);\r\natomic_set(&dev->_vblank_count[i], 0);\r\natomic_set(&dev->vblank_refcount[i], 0);\r\n}\r\ndev->vblank_disable_allowed = 0;\r\nreturn 0;\r\nerr:\r\ndrm_vblank_cleanup(dev);\r\nreturn ret;\r\n}\r\nstatic void drm_irq_vgaarb_nokms(void *cookie, bool state)\r\n{\r\nstruct drm_device *dev = cookie;\r\nif (dev->driver->vgaarb_irq) {\r\ndev->driver->vgaarb_irq(dev, state);\r\nreturn;\r\n}\r\nif (!dev->irq_enabled)\r\nreturn;\r\nif (state) {\r\nif (dev->driver->irq_uninstall)\r\ndev->driver->irq_uninstall(dev);\r\n} else {\r\nif (dev->driver->irq_preinstall)\r\ndev->driver->irq_preinstall(dev);\r\nif (dev->driver->irq_postinstall)\r\ndev->driver->irq_postinstall(dev);\r\n}\r\n}\r\nint drm_irq_install(struct drm_device *dev)\r\n{\r\nint ret = 0;\r\nunsigned long sh_flags = 0;\r\nchar *irqname;\r\nif (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))\r\nreturn -EINVAL;\r\nif (drm_dev_to_irq(dev) == 0)\r\nreturn -EINVAL;\r\nmutex_lock(&dev->struct_mutex);\r\nif (!dev->dev_private) {\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EINVAL;\r\n}\r\nif (dev->irq_enabled) {\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EBUSY;\r\n}\r\ndev->irq_enabled = 1;\r\nmutex_unlock(&dev->struct_mutex);\r\nDRM_DEBUG("irq=%d\n", drm_dev_to_irq(dev));\r\nif (dev->driver->irq_preinstall)\r\ndev->driver->irq_preinstall(dev);\r\nif (drm_core_check_feature(dev, DRIVER_IRQ_SHARED))\r\nsh_flags = IRQF_SHARED;\r\nif (dev->devname)\r\nirqname = dev->devname;\r\nelse\r\nirqname = dev->driver->name;\r\nret = request_irq(drm_dev_to_irq(dev), dev->driver->irq_handler,\r\nsh_flags, irqname, dev);\r\nif (ret < 0) {\r\nmutex_lock(&dev->struct_mutex);\r\ndev->irq_enabled = 0;\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}\r\nif (!drm_core_check_feature(dev, DRIVER_MODESET))\r\nvga_client_register(dev->pdev, (void *)dev, drm_irq_vgaarb_nokms, NULL);\r\nif (dev->driver->irq_postinstall)\r\nret = dev->driver->irq_postinstall(dev);\r\nif (ret < 0) {\r\nmutex_lock(&dev->struct_mutex);\r\ndev->irq_enabled = 0;\r\nmutex_unlock(&dev->struct_mutex);\r\nif (!drm_core_check_feature(dev, DRIVER_MODESET))\r\nvga_client_register(dev->pdev, NULL, NULL, NULL);\r\nfree_irq(drm_dev_to_irq(dev), dev);\r\n}\r\nreturn ret;\r\n}\r\nint drm_irq_uninstall(struct drm_device *dev)\r\n{\r\nunsigned long irqflags;\r\nint irq_enabled, i;\r\nif (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))\r\nreturn -EINVAL;\r\nmutex_lock(&dev->struct_mutex);\r\nirq_enabled = dev->irq_enabled;\r\ndev->irq_enabled = 0;\r\nmutex_unlock(&dev->struct_mutex);\r\nif (dev->num_crtcs) {\r\nspin_lock_irqsave(&dev->vbl_lock, irqflags);\r\nfor (i = 0; i < dev->num_crtcs; i++) {\r\nDRM_WAKEUP(&dev->vbl_queue[i]);\r\ndev->vblank_enabled[i] = 0;\r\ndev->last_vblank[i] =\r\ndev->driver->get_vblank_counter(dev, i);\r\n}\r\nspin_unlock_irqrestore(&dev->vbl_lock, irqflags);\r\n}\r\nif (!irq_enabled)\r\nreturn -EINVAL;\r\nDRM_DEBUG("irq=%d\n", drm_dev_to_irq(dev));\r\nif (!drm_core_check_feature(dev, DRIVER_MODESET))\r\nvga_client_register(dev->pdev, NULL, NULL, NULL);\r\nif (dev->driver->irq_uninstall)\r\ndev->driver->irq_uninstall(dev);\r\nfree_irq(drm_dev_to_irq(dev), dev);\r\nreturn 0;\r\n}\r\nint drm_control(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_control *ctl = data;\r\nswitch (ctl->func) {\r\ncase DRM_INST_HANDLER:\r\nif (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))\r\nreturn 0;\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\nreturn 0;\r\nif (dev->if_version < DRM_IF_VERSION(1, 2) &&\r\nctl->irq != drm_dev_to_irq(dev))\r\nreturn -EINVAL;\r\nreturn drm_irq_install(dev);\r\ncase DRM_UNINST_HANDLER:\r\nif (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))\r\nreturn 0;\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\nreturn 0;\r\nreturn drm_irq_uninstall(dev);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nvoid drm_calc_timestamping_constants(struct drm_crtc *crtc)\r\n{\r\ns64 linedur_ns = 0, pixeldur_ns = 0, framedur_ns = 0;\r\nu64 dotclock;\r\ndotclock = (u64) crtc->hwmode.clock * 1000;\r\nif (crtc->hwmode.flags & DRM_MODE_FLAG_INTERLACE)\r\ndotclock *= 2;\r\nif (dotclock > 0) {\r\npixeldur_ns = (s64) div64_u64(1000000000, dotclock);\r\nlinedur_ns = (s64) div64_u64(((u64) crtc->hwmode.crtc_htotal *\r\n1000000000), dotclock);\r\nframedur_ns = (s64) crtc->hwmode.crtc_vtotal * linedur_ns;\r\n} else\r\nDRM_ERROR("crtc %d: Can't calculate constants, dotclock = 0!\n",\r\ncrtc->base.id);\r\ncrtc->pixeldur_ns = pixeldur_ns;\r\ncrtc->linedur_ns = linedur_ns;\r\ncrtc->framedur_ns = framedur_ns;\r\nDRM_DEBUG("crtc %d: hwmode: htotal %d, vtotal %d, vdisplay %d\n",\r\ncrtc->base.id, crtc->hwmode.crtc_htotal,\r\ncrtc->hwmode.crtc_vtotal, crtc->hwmode.crtc_vdisplay);\r\nDRM_DEBUG("crtc %d: clock %d kHz framedur %d linedur %d, pixeldur %d\n",\r\ncrtc->base.id, (int) dotclock/1000, (int) framedur_ns,\r\n(int) linedur_ns, (int) pixeldur_ns);\r\n}\r\nint drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev, int crtc,\r\nint *max_error,\r\nstruct timeval *vblank_time,\r\nunsigned flags,\r\nstruct drm_crtc *refcrtc)\r\n{\r\nstruct timeval stime, raw_time;\r\nstruct drm_display_mode *mode;\r\nint vbl_status, vtotal, vdisplay;\r\nint vpos, hpos, i;\r\ns64 framedur_ns, linedur_ns, pixeldur_ns, delta_ns, duration_ns;\r\nbool invbl;\r\nif (crtc < 0 || crtc >= dev->num_crtcs) {\r\nDRM_ERROR("Invalid crtc %d\n", crtc);\r\nreturn -EINVAL;\r\n}\r\nif (!dev->driver->get_scanout_position) {\r\nDRM_ERROR("Called from driver w/o get_scanout_position()!?\n");\r\nreturn -EIO;\r\n}\r\nmode = &refcrtc->hwmode;\r\nvtotal = mode->crtc_vtotal;\r\nvdisplay = mode->crtc_vdisplay;\r\nframedur_ns = refcrtc->framedur_ns;\r\nlinedur_ns = refcrtc->linedur_ns;\r\npixeldur_ns = refcrtc->pixeldur_ns;\r\nif (vtotal <= 0 || vdisplay <= 0 || framedur_ns == 0) {\r\nDRM_DEBUG("crtc %d: Noop due to uninitialized mode.\n", crtc);\r\nreturn -EAGAIN;\r\n}\r\nfor (i = 0; i < DRM_TIMESTAMP_MAXRETRIES; i++) {\r\npreempt_disable();\r\ndo_gettimeofday(&stime);\r\nvbl_status = dev->driver->get_scanout_position(dev, crtc, &vpos, &hpos);\r\ndo_gettimeofday(&raw_time);\r\npreempt_enable();\r\nif (!(vbl_status & DRM_SCANOUTPOS_VALID)) {\r\nDRM_DEBUG("crtc %d : scanoutpos query failed [%d].\n",\r\ncrtc, vbl_status);\r\nreturn -EIO;\r\n}\r\nduration_ns = timeval_to_ns(&raw_time) - timeval_to_ns(&stime);\r\nif (duration_ns <= (s64) *max_error)\r\nbreak;\r\n}\r\nif (i == DRM_TIMESTAMP_MAXRETRIES) {\r\nDRM_DEBUG("crtc %d: Noisy timestamp %d us > %d us [%d reps].\n",\r\ncrtc, (int) duration_ns/1000, *max_error/1000, i);\r\n}\r\n*max_error = (int) duration_ns;\r\ninvbl = vbl_status & DRM_SCANOUTPOS_INVBL;\r\ndelta_ns = (s64) vpos * linedur_ns + (s64) hpos * pixeldur_ns;\r\nif ((flags & DRM_CALLED_FROM_VBLIRQ) && !invbl &&\r\n((vdisplay - vpos) < vtotal / 100)) {\r\ndelta_ns = delta_ns - framedur_ns;\r\nvbl_status |= 0x8;\r\n}\r\n*vblank_time = ns_to_timeval(timeval_to_ns(&raw_time) - delta_ns);\r\nDRM_DEBUG("crtc %d : v %d p(%d,%d)@ %ld.%ld -> %ld.%ld [e %d us, %d rep]\n",\r\ncrtc, (int)vbl_status, hpos, vpos,\r\n(long)raw_time.tv_sec, (long)raw_time.tv_usec,\r\n(long)vblank_time->tv_sec, (long)vblank_time->tv_usec,\r\n(int)duration_ns/1000, i);\r\nvbl_status = DRM_VBLANKTIME_SCANOUTPOS_METHOD;\r\nif (invbl)\r\nvbl_status |= DRM_VBLANKTIME_INVBL;\r\nreturn vbl_status;\r\n}\r\nu32 drm_get_last_vbltimestamp(struct drm_device *dev, int crtc,\r\nstruct timeval *tvblank, unsigned flags)\r\n{\r\nint ret = 0;\r\nint max_error = (int) drm_timestamp_precision * 1000;\r\nif (dev->driver->get_vblank_timestamp && (max_error > 0)) {\r\nret = dev->driver->get_vblank_timestamp(dev, crtc, &max_error,\r\ntvblank, flags);\r\nif (ret > 0)\r\nreturn (u32) ret;\r\n}\r\ndo_gettimeofday(tvblank);\r\nreturn 0;\r\n}\r\nu32 drm_vblank_count(struct drm_device *dev, int crtc)\r\n{\r\nreturn atomic_read(&dev->_vblank_count[crtc]);\r\n}\r\nu32 drm_vblank_count_and_time(struct drm_device *dev, int crtc,\r\nstruct timeval *vblanktime)\r\n{\r\nu32 cur_vblank;\r\ndo {\r\ncur_vblank = atomic_read(&dev->_vblank_count[crtc]);\r\n*vblanktime = vblanktimestamp(dev, crtc, cur_vblank);\r\nsmp_rmb();\r\n} while (cur_vblank != atomic_read(&dev->_vblank_count[crtc]));\r\nreturn cur_vblank;\r\n}\r\nstatic void drm_update_vblank_count(struct drm_device *dev, int crtc)\r\n{\r\nu32 cur_vblank, diff, tslot, rc;\r\nstruct timeval t_vblank;\r\ndo {\r\ncur_vblank = dev->driver->get_vblank_counter(dev, crtc);\r\nrc = drm_get_last_vbltimestamp(dev, crtc, &t_vblank, 0);\r\n} while (cur_vblank != dev->driver->get_vblank_counter(dev, crtc));\r\ndiff = cur_vblank - dev->last_vblank[crtc];\r\nif (cur_vblank < dev->last_vblank[crtc]) {\r\ndiff += dev->max_vblank_count;\r\nDRM_DEBUG("last_vblank[%d]=0x%x, cur_vblank=0x%x => diff=0x%x\n",\r\ncrtc, dev->last_vblank[crtc], cur_vblank, diff);\r\n}\r\nDRM_DEBUG("enabling vblank interrupts on crtc %d, missed %d\n",\r\ncrtc, diff);\r\nif (rc) {\r\ntslot = atomic_read(&dev->_vblank_count[crtc]) + diff;\r\nvblanktimestamp(dev, crtc, tslot) = t_vblank;\r\n}\r\nsmp_mb__before_atomic_inc();\r\natomic_add(diff, &dev->_vblank_count[crtc]);\r\nsmp_mb__after_atomic_inc();\r\n}\r\nint drm_vblank_get(struct drm_device *dev, int crtc)\r\n{\r\nunsigned long irqflags, irqflags2;\r\nint ret = 0;\r\nspin_lock_irqsave(&dev->vbl_lock, irqflags);\r\nif (atomic_add_return(1, &dev->vblank_refcount[crtc]) == 1) {\r\nspin_lock_irqsave(&dev->vblank_time_lock, irqflags2);\r\nif (!dev->vblank_enabled[crtc]) {\r\nret = dev->driver->enable_vblank(dev, crtc);\r\nDRM_DEBUG("enabling vblank on crtc %d, ret: %d\n",\r\ncrtc, ret);\r\nif (ret)\r\natomic_dec(&dev->vblank_refcount[crtc]);\r\nelse {\r\ndev->vblank_enabled[crtc] = 1;\r\ndrm_update_vblank_count(dev, crtc);\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->vblank_time_lock, irqflags2);\r\n} else {\r\nif (!dev->vblank_enabled[crtc]) {\r\natomic_dec(&dev->vblank_refcount[crtc]);\r\nret = -EINVAL;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->vbl_lock, irqflags);\r\nreturn ret;\r\n}\r\nvoid drm_vblank_put(struct drm_device *dev, int crtc)\r\n{\r\nBUG_ON(atomic_read(&dev->vblank_refcount[crtc]) == 0);\r\nif (atomic_dec_and_test(&dev->vblank_refcount[crtc]) &&\r\n(drm_vblank_offdelay > 0))\r\nmod_timer(&dev->vblank_disable_timer,\r\njiffies + ((drm_vblank_offdelay * DRM_HZ)/1000));\r\n}\r\nvoid drm_vblank_off(struct drm_device *dev, int crtc)\r\n{\r\nstruct drm_pending_vblank_event *e, *t;\r\nstruct timeval now;\r\nunsigned long irqflags;\r\nunsigned int seq;\r\nspin_lock_irqsave(&dev->vbl_lock, irqflags);\r\nvblank_disable_and_save(dev, crtc);\r\nDRM_WAKEUP(&dev->vbl_queue[crtc]);\r\nseq = drm_vblank_count_and_time(dev, crtc, &now);\r\nlist_for_each_entry_safe(e, t, &dev->vblank_event_list, base.link) {\r\nif (e->pipe != crtc)\r\ncontinue;\r\nDRM_DEBUG("Sending premature vblank event on disable: \\r\nwanted %d, current %d\n",\r\ne->event.sequence, seq);\r\ne->event.sequence = seq;\r\ne->event.tv_sec = now.tv_sec;\r\ne->event.tv_usec = now.tv_usec;\r\ndrm_vblank_put(dev, e->pipe);\r\nlist_move_tail(&e->base.link, &e->base.file_priv->event_list);\r\nwake_up_interruptible(&e->base.file_priv->event_wait);\r\ntrace_drm_vblank_event_delivered(e->base.pid, e->pipe,\r\ne->event.sequence);\r\n}\r\nspin_unlock_irqrestore(&dev->vbl_lock, irqflags);\r\n}\r\nvoid drm_vblank_pre_modeset(struct drm_device *dev, int crtc)\r\n{\r\nif (!dev->num_crtcs)\r\nreturn;\r\nif (!dev->vblank_inmodeset[crtc]) {\r\ndev->vblank_inmodeset[crtc] = 0x1;\r\nif (drm_vblank_get(dev, crtc) == 0)\r\ndev->vblank_inmodeset[crtc] |= 0x2;\r\n}\r\n}\r\nvoid drm_vblank_post_modeset(struct drm_device *dev, int crtc)\r\n{\r\nunsigned long irqflags;\r\nif (dev->vblank_inmodeset[crtc]) {\r\nspin_lock_irqsave(&dev->vbl_lock, irqflags);\r\ndev->vblank_disable_allowed = 1;\r\nspin_unlock_irqrestore(&dev->vbl_lock, irqflags);\r\nif (dev->vblank_inmodeset[crtc] & 0x2)\r\ndrm_vblank_put(dev, crtc);\r\ndev->vblank_inmodeset[crtc] = 0;\r\n}\r\n}\r\nint drm_modeset_ctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_modeset_ctl *modeset = data;\r\nint ret = 0;\r\nunsigned int crtc;\r\nif (!dev->num_crtcs)\r\ngoto out;\r\ncrtc = modeset->crtc;\r\nif (crtc >= dev->num_crtcs) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (modeset->cmd) {\r\ncase _DRM_PRE_MODESET:\r\ndrm_vblank_pre_modeset(dev, crtc);\r\nbreak;\r\ncase _DRM_POST_MODESET:\r\ndrm_vblank_post_modeset(dev, crtc);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int drm_queue_vblank_event(struct drm_device *dev, int pipe,\r\nunion drm_wait_vblank *vblwait,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_pending_vblank_event *e;\r\nstruct timeval now;\r\nunsigned long flags;\r\nunsigned int seq;\r\nint ret;\r\ne = kzalloc(sizeof *e, GFP_KERNEL);\r\nif (e == NULL) {\r\nret = -ENOMEM;\r\ngoto err_put;\r\n}\r\ne->pipe = pipe;\r\ne->base.pid = current->pid;\r\ne->event.base.type = DRM_EVENT_VBLANK;\r\ne->event.base.length = sizeof e->event;\r\ne->event.user_data = vblwait->request.signal;\r\ne->base.event = &e->event.base;\r\ne->base.file_priv = file_priv;\r\ne->base.destroy = (void (*) (struct drm_pending_event *)) kfree;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nif (file_priv->event_space < sizeof e->event) {\r\nret = -EBUSY;\r\ngoto err_unlock;\r\n}\r\nfile_priv->event_space -= sizeof e->event;\r\nseq = drm_vblank_count_and_time(dev, pipe, &now);\r\nif ((vblwait->request.type & _DRM_VBLANK_NEXTONMISS) &&\r\n(seq - vblwait->request.sequence) <= (1 << 23)) {\r\nvblwait->request.sequence = seq + 1;\r\nvblwait->reply.sequence = vblwait->request.sequence;\r\n}\r\nDRM_DEBUG("event on vblank count %d, current %d, crtc %d\n",\r\nvblwait->request.sequence, seq, pipe);\r\ntrace_drm_vblank_event_queued(current->pid, pipe,\r\nvblwait->request.sequence);\r\ne->event.sequence = vblwait->request.sequence;\r\nif ((seq - vblwait->request.sequence) <= (1 << 23)) {\r\ne->event.sequence = seq;\r\ne->event.tv_sec = now.tv_sec;\r\ne->event.tv_usec = now.tv_usec;\r\ndrm_vblank_put(dev, pipe);\r\nlist_add_tail(&e->base.link, &e->base.file_priv->event_list);\r\nwake_up_interruptible(&e->base.file_priv->event_wait);\r\nvblwait->reply.sequence = seq;\r\ntrace_drm_vblank_event_delivered(current->pid, pipe,\r\nvblwait->request.sequence);\r\n} else {\r\nlist_add_tail(&e->base.link, &dev->vblank_event_list);\r\nvblwait->reply.sequence = vblwait->request.sequence;\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nreturn 0;\r\nerr_unlock:\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nkfree(e);\r\nerr_put:\r\ndrm_vblank_put(dev, pipe);\r\nreturn ret;\r\n}\r\nint drm_wait_vblank(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nunion drm_wait_vblank *vblwait = data;\r\nint ret = 0;\r\nunsigned int flags, seq, crtc, high_crtc;\r\nif ((!drm_dev_to_irq(dev)) || (!dev->irq_enabled))\r\nreturn -EINVAL;\r\nif (vblwait->request.type & _DRM_VBLANK_SIGNAL)\r\nreturn -EINVAL;\r\nif (vblwait->request.type &\r\n~(_DRM_VBLANK_TYPES_MASK | _DRM_VBLANK_FLAGS_MASK |\r\n_DRM_VBLANK_HIGH_CRTC_MASK)) {\r\nDRM_ERROR("Unsupported type value 0x%x, supported mask 0x%x\n",\r\nvblwait->request.type,\r\n(_DRM_VBLANK_TYPES_MASK | _DRM_VBLANK_FLAGS_MASK |\r\n_DRM_VBLANK_HIGH_CRTC_MASK));\r\nreturn -EINVAL;\r\n}\r\nflags = vblwait->request.type & _DRM_VBLANK_FLAGS_MASK;\r\nhigh_crtc = (vblwait->request.type & _DRM_VBLANK_HIGH_CRTC_MASK);\r\nif (high_crtc)\r\ncrtc = high_crtc >> _DRM_VBLANK_HIGH_CRTC_SHIFT;\r\nelse\r\ncrtc = flags & _DRM_VBLANK_SECONDARY ? 1 : 0;\r\nif (crtc >= dev->num_crtcs)\r\nreturn -EINVAL;\r\nret = drm_vblank_get(dev, crtc);\r\nif (ret) {\r\nDRM_DEBUG("failed to acquire vblank counter, %d\n", ret);\r\nreturn ret;\r\n}\r\nseq = drm_vblank_count(dev, crtc);\r\nswitch (vblwait->request.type & _DRM_VBLANK_TYPES_MASK) {\r\ncase _DRM_VBLANK_RELATIVE:\r\nvblwait->request.sequence += seq;\r\nvblwait->request.type &= ~_DRM_VBLANK_RELATIVE;\r\ncase _DRM_VBLANK_ABSOLUTE:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (flags & _DRM_VBLANK_EVENT) {\r\nreturn drm_queue_vblank_event(dev, crtc, vblwait, file_priv);\r\n}\r\nif ((flags & _DRM_VBLANK_NEXTONMISS) &&\r\n(seq - vblwait->request.sequence) <= (1<<23)) {\r\nvblwait->request.sequence = seq + 1;\r\n}\r\nDRM_DEBUG("waiting on vblank count %d, crtc %d\n",\r\nvblwait->request.sequence, crtc);\r\ndev->last_vblank_wait[crtc] = vblwait->request.sequence;\r\nDRM_WAIT_ON(ret, dev->vbl_queue[crtc], 3 * DRM_HZ,\r\n(((drm_vblank_count(dev, crtc) -\r\nvblwait->request.sequence) <= (1 << 23)) ||\r\n!dev->irq_enabled));\r\nif (ret != -EINTR) {\r\nstruct timeval now;\r\nvblwait->reply.sequence = drm_vblank_count_and_time(dev, crtc, &now);\r\nvblwait->reply.tval_sec = now.tv_sec;\r\nvblwait->reply.tval_usec = now.tv_usec;\r\nDRM_DEBUG("returning %d to client\n",\r\nvblwait->reply.sequence);\r\n} else {\r\nDRM_DEBUG("vblank wait interrupted by signal\n");\r\n}\r\ndone:\r\ndrm_vblank_put(dev, crtc);\r\nreturn ret;\r\n}\r\nvoid drm_handle_vblank_events(struct drm_device *dev, int crtc)\r\n{\r\nstruct drm_pending_vblank_event *e, *t;\r\nstruct timeval now;\r\nunsigned long flags;\r\nunsigned int seq;\r\nseq = drm_vblank_count_and_time(dev, crtc, &now);\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nlist_for_each_entry_safe(e, t, &dev->vblank_event_list, base.link) {\r\nif (e->pipe != crtc)\r\ncontinue;\r\nif ((seq - e->event.sequence) > (1<<23))\r\ncontinue;\r\nDRM_DEBUG("vblank event on %d, current %d\n",\r\ne->event.sequence, seq);\r\ne->event.sequence = seq;\r\ne->event.tv_sec = now.tv_sec;\r\ne->event.tv_usec = now.tv_usec;\r\ndrm_vblank_put(dev, e->pipe);\r\nlist_move_tail(&e->base.link, &e->base.file_priv->event_list);\r\nwake_up_interruptible(&e->base.file_priv->event_wait);\r\ntrace_drm_vblank_event_delivered(e->base.pid, e->pipe,\r\ne->event.sequence);\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\ntrace_drm_vblank_event(crtc, seq);\r\n}\r\nbool drm_handle_vblank(struct drm_device *dev, int crtc)\r\n{\r\nu32 vblcount;\r\ns64 diff_ns;\r\nstruct timeval tvblank;\r\nunsigned long irqflags;\r\nif (!dev->num_crtcs)\r\nreturn false;\r\nspin_lock_irqsave(&dev->vblank_time_lock, irqflags);\r\nif (!dev->vblank_enabled[crtc]) {\r\nspin_unlock_irqrestore(&dev->vblank_time_lock, irqflags);\r\nreturn false;\r\n}\r\nvblcount = atomic_read(&dev->_vblank_count[crtc]);\r\ndrm_get_last_vbltimestamp(dev, crtc, &tvblank, DRM_CALLED_FROM_VBLIRQ);\r\ndiff_ns = timeval_to_ns(&tvblank) -\r\ntimeval_to_ns(&vblanktimestamp(dev, crtc, vblcount));\r\nif (abs64(diff_ns) > DRM_REDUNDANT_VBLIRQ_THRESH_NS) {\r\nvblanktimestamp(dev, crtc, vblcount + 1) = tvblank;\r\nsmp_mb__before_atomic_inc();\r\natomic_inc(&dev->_vblank_count[crtc]);\r\nsmp_mb__after_atomic_inc();\r\n} else {\r\nDRM_DEBUG("crtc %d: Redundant vblirq ignored. diff_ns = %d\n",\r\ncrtc, (int) diff_ns);\r\n}\r\nDRM_WAKEUP(&dev->vbl_queue[crtc]);\r\ndrm_handle_vblank_events(dev, crtc);\r\nspin_unlock_irqrestore(&dev->vblank_time_lock, irqflags);\r\nreturn true;\r\n}
