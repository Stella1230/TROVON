static int t4_wait_op_done_val(struct adapter *adapter, int reg, u32 mask,\r\nint polarity, int attempts, int delay, u32 *valp)\r\n{\r\nwhile (1) {\r\nu32 val = t4_read_reg(adapter, reg);\r\nif (!!(val & mask) == polarity) {\r\nif (valp)\r\n*valp = val;\r\nreturn 0;\r\n}\r\nif (--attempts == 0)\r\nreturn -EAGAIN;\r\nif (delay)\r\nudelay(delay);\r\n}\r\n}\r\nstatic inline int t4_wait_op_done(struct adapter *adapter, int reg, u32 mask,\r\nint polarity, int attempts, int delay)\r\n{\r\nreturn t4_wait_op_done_val(adapter, reg, mask, polarity, attempts,\r\ndelay, NULL);\r\n}\r\nvoid t4_set_reg_field(struct adapter *adapter, unsigned int addr, u32 mask,\r\nu32 val)\r\n{\r\nu32 v = t4_read_reg(adapter, addr) & ~mask;\r\nt4_write_reg(adapter, addr, v | val);\r\n(void) t4_read_reg(adapter, addr);\r\n}\r\nstatic void t4_read_indirect(struct adapter *adap, unsigned int addr_reg,\r\nunsigned int data_reg, u32 *vals,\r\nunsigned int nregs, unsigned int start_idx)\r\n{\r\nwhile (nregs--) {\r\nt4_write_reg(adap, addr_reg, start_idx);\r\n*vals++ = t4_read_reg(adap, data_reg);\r\nstart_idx++;\r\n}\r\n}\r\nstatic void get_mbox_rpl(struct adapter *adap, __be64 *rpl, int nflit,\r\nu32 mbox_addr)\r\n{\r\nfor ( ; nflit; nflit--, mbox_addr += 8)\r\n*rpl++ = cpu_to_be64(t4_read_reg64(adap, mbox_addr));\r\n}\r\nstatic void fw_asrt(struct adapter *adap, u32 mbox_addr)\r\n{\r\nstruct fw_debug_cmd asrt;\r\nget_mbox_rpl(adap, (__be64 *)&asrt, sizeof(asrt) / 8, mbox_addr);\r\ndev_alert(adap->pdev_dev,\r\n"FW assertion at %.16s:%u, val0 %#x, val1 %#x\n",\r\nasrt.u.assert.filename_0_7, ntohl(asrt.u.assert.line),\r\nntohl(asrt.u.assert.x), ntohl(asrt.u.assert.y));\r\n}\r\nstatic void dump_mbox(struct adapter *adap, int mbox, u32 data_reg)\r\n{\r\ndev_err(adap->pdev_dev,\r\n"mbox %d: %llx %llx %llx %llx %llx %llx %llx %llx\n", mbox,\r\n(unsigned long long)t4_read_reg64(adap, data_reg),\r\n(unsigned long long)t4_read_reg64(adap, data_reg + 8),\r\n(unsigned long long)t4_read_reg64(adap, data_reg + 16),\r\n(unsigned long long)t4_read_reg64(adap, data_reg + 24),\r\n(unsigned long long)t4_read_reg64(adap, data_reg + 32),\r\n(unsigned long long)t4_read_reg64(adap, data_reg + 40),\r\n(unsigned long long)t4_read_reg64(adap, data_reg + 48),\r\n(unsigned long long)t4_read_reg64(adap, data_reg + 56));\r\n}\r\nint t4_wr_mbox_meat(struct adapter *adap, int mbox, const void *cmd, int size,\r\nvoid *rpl, bool sleep_ok)\r\n{\r\nstatic const int delay[] = {\r\n1, 1, 3, 5, 10, 10, 20, 50, 100, 200\r\n};\r\nu32 v;\r\nu64 res;\r\nint i, ms, delay_idx;\r\nconst __be64 *p = cmd;\r\nu32 data_reg = PF_REG(mbox, CIM_PF_MAILBOX_DATA);\r\nu32 ctl_reg = PF_REG(mbox, CIM_PF_MAILBOX_CTRL);\r\nif ((size & 15) || size > MBOX_LEN)\r\nreturn -EINVAL;\r\nif (adap->pdev->error_state != pci_channel_io_normal)\r\nreturn -EIO;\r\nv = MBOWNER_GET(t4_read_reg(adap, ctl_reg));\r\nfor (i = 0; v == MBOX_OWNER_NONE && i < 3; i++)\r\nv = MBOWNER_GET(t4_read_reg(adap, ctl_reg));\r\nif (v != MBOX_OWNER_DRV)\r\nreturn v ? -EBUSY : -ETIMEDOUT;\r\nfor (i = 0; i < size; i += 8)\r\nt4_write_reg64(adap, data_reg + i, be64_to_cpu(*p++));\r\nt4_write_reg(adap, ctl_reg, MBMSGVALID | MBOWNER(MBOX_OWNER_FW));\r\nt4_read_reg(adap, ctl_reg);\r\ndelay_idx = 0;\r\nms = delay[0];\r\nfor (i = 0; i < FW_CMD_MAX_TIMEOUT; i += ms) {\r\nif (sleep_ok) {\r\nms = delay[delay_idx];\r\nif (delay_idx < ARRAY_SIZE(delay) - 1)\r\ndelay_idx++;\r\nmsleep(ms);\r\n} else\r\nmdelay(ms);\r\nv = t4_read_reg(adap, ctl_reg);\r\nif (MBOWNER_GET(v) == MBOX_OWNER_DRV) {\r\nif (!(v & MBMSGVALID)) {\r\nt4_write_reg(adap, ctl_reg, 0);\r\ncontinue;\r\n}\r\nres = t4_read_reg64(adap, data_reg);\r\nif (FW_CMD_OP_GET(res >> 32) == FW_DEBUG_CMD) {\r\nfw_asrt(adap, data_reg);\r\nres = FW_CMD_RETVAL(EIO);\r\n} else if (rpl)\r\nget_mbox_rpl(adap, rpl, size / 8, data_reg);\r\nif (FW_CMD_RETVAL_GET((int)res))\r\ndump_mbox(adap, mbox, data_reg);\r\nt4_write_reg(adap, ctl_reg, 0);\r\nreturn -FW_CMD_RETVAL_GET((int)res);\r\n}\r\n}\r\ndump_mbox(adap, mbox, data_reg);\r\ndev_err(adap->pdev_dev, "command %#x in mailbox %d timed out\n",\r\n*(const u8 *)cmd, mbox);\r\nreturn -ETIMEDOUT;\r\n}\r\nint t4_mc_read(struct adapter *adap, u32 addr, __be32 *data, u64 *ecc)\r\n{\r\nint i;\r\nif (t4_read_reg(adap, MC_BIST_CMD) & START_BIST)\r\nreturn -EBUSY;\r\nt4_write_reg(adap, MC_BIST_CMD_ADDR, addr & ~0x3fU);\r\nt4_write_reg(adap, MC_BIST_CMD_LEN, 64);\r\nt4_write_reg(adap, MC_BIST_DATA_PATTERN, 0xc);\r\nt4_write_reg(adap, MC_BIST_CMD, BIST_OPCODE(1) | START_BIST |\r\nBIST_CMD_GAP(1));\r\ni = t4_wait_op_done(adap, MC_BIST_CMD, START_BIST, 0, 10, 1);\r\nif (i)\r\nreturn i;\r\n#define MC_DATA(i) MC_BIST_STATUS_REG(MC_BIST_STATUS_RDATA, i)\r\nfor (i = 15; i >= 0; i--)\r\n*data++ = htonl(t4_read_reg(adap, MC_DATA(i)));\r\nif (ecc)\r\n*ecc = t4_read_reg64(adap, MC_DATA(16));\r\n#undef MC_DATA\r\nreturn 0;\r\n}\r\nint t4_edc_read(struct adapter *adap, int idx, u32 addr, __be32 *data, u64 *ecc)\r\n{\r\nint i;\r\nidx *= EDC_STRIDE;\r\nif (t4_read_reg(adap, EDC_BIST_CMD + idx) & START_BIST)\r\nreturn -EBUSY;\r\nt4_write_reg(adap, EDC_BIST_CMD_ADDR + idx, addr & ~0x3fU);\r\nt4_write_reg(adap, EDC_BIST_CMD_LEN + idx, 64);\r\nt4_write_reg(adap, EDC_BIST_DATA_PATTERN + idx, 0xc);\r\nt4_write_reg(adap, EDC_BIST_CMD + idx,\r\nBIST_OPCODE(1) | BIST_CMD_GAP(1) | START_BIST);\r\ni = t4_wait_op_done(adap, EDC_BIST_CMD + idx, START_BIST, 0, 10, 1);\r\nif (i)\r\nreturn i;\r\n#define EDC_DATA(i) (EDC_BIST_STATUS_REG(EDC_BIST_STATUS_RDATA, i) + idx)\r\nfor (i = 15; i >= 0; i--)\r\n*data++ = htonl(t4_read_reg(adap, EDC_DATA(i)));\r\nif (ecc)\r\n*ecc = t4_read_reg64(adap, EDC_DATA(16));\r\n#undef EDC_DATA\r\nreturn 0;\r\n}\r\nint t4_seeprom_wp(struct adapter *adapter, bool enable)\r\n{\r\nunsigned int v = enable ? 0xc : 0;\r\nint ret = pci_write_vpd(adapter->pdev, EEPROM_STAT_ADDR, 4, &v);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int get_vpd_params(struct adapter *adapter, struct vpd_params *p)\r\n{\r\nint i, ret;\r\nint ec, sn;\r\nu8 vpd[VPD_LEN], csum;\r\nunsigned int vpdr_len, kw_offset, id_len;\r\nret = pci_read_vpd(adapter->pdev, VPD_BASE, sizeof(vpd), vpd);\r\nif (ret < 0)\r\nreturn ret;\r\nif (vpd[0] != PCI_VPD_LRDT_ID_STRING) {\r\ndev_err(adapter->pdev_dev, "missing VPD ID string\n");\r\nreturn -EINVAL;\r\n}\r\nid_len = pci_vpd_lrdt_size(vpd);\r\nif (id_len > ID_LEN)\r\nid_len = ID_LEN;\r\ni = pci_vpd_find_tag(vpd, 0, VPD_LEN, PCI_VPD_LRDT_RO_DATA);\r\nif (i < 0) {\r\ndev_err(adapter->pdev_dev, "missing VPD-R section\n");\r\nreturn -EINVAL;\r\n}\r\nvpdr_len = pci_vpd_lrdt_size(&vpd[i]);\r\nkw_offset = i + PCI_VPD_LRDT_TAG_SIZE;\r\nif (vpdr_len + kw_offset > VPD_LEN) {\r\ndev_err(adapter->pdev_dev, "bad VPD-R length %u\n", vpdr_len);\r\nreturn -EINVAL;\r\n}\r\n#define FIND_VPD_KW(var, name) do { \\r\nvar = pci_vpd_find_info_keyword(vpd, kw_offset, vpdr_len, name); \\r\nif (var < 0) { \\r\ndev_err(adapter->pdev_dev, "missing VPD keyword " name "\n"); \\r\nreturn -EINVAL; \\r\n} \\r\nvar += PCI_VPD_INFO_FLD_HDR_SIZE; \\r\n} while (0)\r\nFIND_VPD_KW(i, "RV");\r\nfor (csum = 0; i >= 0; i--)\r\ncsum += vpd[i];\r\nif (csum) {\r\ndev_err(adapter->pdev_dev,\r\n"corrupted VPD EEPROM, actual csum %u\n", csum);\r\nreturn -EINVAL;\r\n}\r\nFIND_VPD_KW(ec, "EC");\r\nFIND_VPD_KW(sn, "SN");\r\n#undef FIND_VPD_KW\r\nmemcpy(p->id, vpd + PCI_VPD_LRDT_TAG_SIZE, id_len);\r\nstrim(p->id);\r\nmemcpy(p->ec, vpd + ec, EC_LEN);\r\nstrim(p->ec);\r\ni = pci_vpd_info_field_size(vpd + sn - PCI_VPD_INFO_FLD_HDR_SIZE);\r\nmemcpy(p->sn, vpd + sn, min(i, SERNUM_LEN));\r\nstrim(p->sn);\r\nreturn 0;\r\n}\r\nstatic int sf1_read(struct adapter *adapter, unsigned int byte_cnt, int cont,\r\nint lock, u32 *valp)\r\n{\r\nint ret;\r\nif (!byte_cnt || byte_cnt > 4)\r\nreturn -EINVAL;\r\nif (t4_read_reg(adapter, SF_OP) & BUSY)\r\nreturn -EBUSY;\r\ncont = cont ? SF_CONT : 0;\r\nlock = lock ? SF_LOCK : 0;\r\nt4_write_reg(adapter, SF_OP, lock | cont | BYTECNT(byte_cnt - 1));\r\nret = t4_wait_op_done(adapter, SF_OP, BUSY, 0, SF_ATTEMPTS, 5);\r\nif (!ret)\r\n*valp = t4_read_reg(adapter, SF_DATA);\r\nreturn ret;\r\n}\r\nstatic int sf1_write(struct adapter *adapter, unsigned int byte_cnt, int cont,\r\nint lock, u32 val)\r\n{\r\nif (!byte_cnt || byte_cnt > 4)\r\nreturn -EINVAL;\r\nif (t4_read_reg(adapter, SF_OP) & BUSY)\r\nreturn -EBUSY;\r\ncont = cont ? SF_CONT : 0;\r\nlock = lock ? SF_LOCK : 0;\r\nt4_write_reg(adapter, SF_DATA, val);\r\nt4_write_reg(adapter, SF_OP, lock |\r\ncont | BYTECNT(byte_cnt - 1) | OP_WR);\r\nreturn t4_wait_op_done(adapter, SF_OP, BUSY, 0, SF_ATTEMPTS, 5);\r\n}\r\nstatic int flash_wait_op(struct adapter *adapter, int attempts, int delay)\r\n{\r\nint ret;\r\nu32 status;\r\nwhile (1) {\r\nif ((ret = sf1_write(adapter, 1, 1, 1, SF_RD_STATUS)) != 0 ||\r\n(ret = sf1_read(adapter, 1, 0, 1, &status)) != 0)\r\nreturn ret;\r\nif (!(status & 1))\r\nreturn 0;\r\nif (--attempts == 0)\r\nreturn -EAGAIN;\r\nif (delay)\r\nmsleep(delay);\r\n}\r\n}\r\nstatic int t4_read_flash(struct adapter *adapter, unsigned int addr,\r\nunsigned int nwords, u32 *data, int byte_oriented)\r\n{\r\nint ret;\r\nif (addr + nwords * sizeof(u32) > adapter->params.sf_size || (addr & 3))\r\nreturn -EINVAL;\r\naddr = swab32(addr) | SF_RD_DATA_FAST;\r\nif ((ret = sf1_write(adapter, 4, 1, 0, addr)) != 0 ||\r\n(ret = sf1_read(adapter, 1, 1, 0, data)) != 0)\r\nreturn ret;\r\nfor ( ; nwords; nwords--, data++) {\r\nret = sf1_read(adapter, 4, nwords > 1, nwords == 1, data);\r\nif (nwords == 1)\r\nt4_write_reg(adapter, SF_OP, 0);\r\nif (ret)\r\nreturn ret;\r\nif (byte_oriented)\r\n*data = htonl(*data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int t4_write_flash(struct adapter *adapter, unsigned int addr,\r\nunsigned int n, const u8 *data)\r\n{\r\nint ret;\r\nu32 buf[64];\r\nunsigned int i, c, left, val, offset = addr & 0xff;\r\nif (addr >= adapter->params.sf_size || offset + n > SF_PAGE_SIZE)\r\nreturn -EINVAL;\r\nval = swab32(addr) | SF_PROG_PAGE;\r\nif ((ret = sf1_write(adapter, 1, 0, 1, SF_WR_ENABLE)) != 0 ||\r\n(ret = sf1_write(adapter, 4, 1, 1, val)) != 0)\r\ngoto unlock;\r\nfor (left = n; left; left -= c) {\r\nc = min(left, 4U);\r\nfor (val = 0, i = 0; i < c; ++i)\r\nval = (val << 8) + *data++;\r\nret = sf1_write(adapter, c, c != left, 1, val);\r\nif (ret)\r\ngoto unlock;\r\n}\r\nret = flash_wait_op(adapter, 8, 1);\r\nif (ret)\r\ngoto unlock;\r\nt4_write_reg(adapter, SF_OP, 0);\r\nret = t4_read_flash(adapter, addr & ~0xff, ARRAY_SIZE(buf), buf, 1);\r\nif (ret)\r\nreturn ret;\r\nif (memcmp(data - n, (u8 *)buf + offset, n)) {\r\ndev_err(adapter->pdev_dev,\r\n"failed to correctly write the flash page at %#x\n",\r\naddr);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\nunlock:\r\nt4_write_reg(adapter, SF_OP, 0);\r\nreturn ret;\r\n}\r\nstatic int get_fw_version(struct adapter *adapter, u32 *vers)\r\n{\r\nreturn t4_read_flash(adapter, adapter->params.sf_fw_start +\r\noffsetof(struct fw_hdr, fw_ver), 1, vers, 0);\r\n}\r\nstatic int get_tp_version(struct adapter *adapter, u32 *vers)\r\n{\r\nreturn t4_read_flash(adapter, adapter->params.sf_fw_start +\r\noffsetof(struct fw_hdr, tp_microcode_ver),\r\n1, vers, 0);\r\n}\r\nint t4_check_fw_version(struct adapter *adapter)\r\n{\r\nu32 api_vers[2];\r\nint ret, major, minor, micro;\r\nret = get_fw_version(adapter, &adapter->params.fw_vers);\r\nif (!ret)\r\nret = get_tp_version(adapter, &adapter->params.tp_vers);\r\nif (!ret)\r\nret = t4_read_flash(adapter, adapter->params.sf_fw_start +\r\noffsetof(struct fw_hdr, intfver_nic),\r\n2, api_vers, 1);\r\nif (ret)\r\nreturn ret;\r\nmajor = FW_HDR_FW_VER_MAJOR_GET(adapter->params.fw_vers);\r\nminor = FW_HDR_FW_VER_MINOR_GET(adapter->params.fw_vers);\r\nmicro = FW_HDR_FW_VER_MICRO_GET(adapter->params.fw_vers);\r\nmemcpy(adapter->params.api_vers, api_vers,\r\nsizeof(adapter->params.api_vers));\r\nif (major != FW_VERSION_MAJOR) {\r\ndev_err(adapter->pdev_dev,\r\n"card FW has major version %u, driver wants %u\n",\r\nmajor, FW_VERSION_MAJOR);\r\nreturn -EINVAL;\r\n}\r\nif (minor == FW_VERSION_MINOR && micro == FW_VERSION_MICRO)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int t4_flash_erase_sectors(struct adapter *adapter, int start, int end)\r\n{\r\nint ret = 0;\r\nwhile (start <= end) {\r\nif ((ret = sf1_write(adapter, 1, 0, 1, SF_WR_ENABLE)) != 0 ||\r\n(ret = sf1_write(adapter, 4, 0, 1,\r\nSF_ERASE_SECTOR | (start << 8))) != 0 ||\r\n(ret = flash_wait_op(adapter, 14, 500)) != 0) {\r\ndev_err(adapter->pdev_dev,\r\n"erase of flash sector %d failed, error %d\n",\r\nstart, ret);\r\nbreak;\r\n}\r\nstart++;\r\n}\r\nt4_write_reg(adapter, SF_OP, 0);\r\nreturn ret;\r\n}\r\nint t4_load_fw(struct adapter *adap, const u8 *fw_data, unsigned int size)\r\n{\r\nu32 csum;\r\nint ret, addr;\r\nunsigned int i;\r\nu8 first_page[SF_PAGE_SIZE];\r\nconst u32 *p = (const u32 *)fw_data;\r\nconst struct fw_hdr *hdr = (const struct fw_hdr *)fw_data;\r\nunsigned int sf_sec_size = adap->params.sf_size / adap->params.sf_nsec;\r\nunsigned int fw_img_start = adap->params.sf_fw_start;\r\nunsigned int fw_start_sec = fw_img_start / sf_sec_size;\r\nif (!size) {\r\ndev_err(adap->pdev_dev, "FW image has no data\n");\r\nreturn -EINVAL;\r\n}\r\nif (size & 511) {\r\ndev_err(adap->pdev_dev,\r\n"FW image size not multiple of 512 bytes\n");\r\nreturn -EINVAL;\r\n}\r\nif (ntohs(hdr->len512) * 512 != size) {\r\ndev_err(adap->pdev_dev,\r\n"FW image size differs from size in FW header\n");\r\nreturn -EINVAL;\r\n}\r\nif (size > FW_MAX_SIZE) {\r\ndev_err(adap->pdev_dev, "FW image too large, max is %u bytes\n",\r\nFW_MAX_SIZE);\r\nreturn -EFBIG;\r\n}\r\nfor (csum = 0, i = 0; i < size / sizeof(csum); i++)\r\ncsum += ntohl(p[i]);\r\nif (csum != 0xffffffff) {\r\ndev_err(adap->pdev_dev,\r\n"corrupted firmware image, checksum %#x\n", csum);\r\nreturn -EINVAL;\r\n}\r\ni = DIV_ROUND_UP(size, sf_sec_size);\r\nret = t4_flash_erase_sectors(adap, fw_start_sec, fw_start_sec + i - 1);\r\nif (ret)\r\ngoto out;\r\nmemcpy(first_page, fw_data, SF_PAGE_SIZE);\r\n((struct fw_hdr *)first_page)->fw_ver = htonl(0xffffffff);\r\nret = t4_write_flash(adap, fw_img_start, SF_PAGE_SIZE, first_page);\r\nif (ret)\r\ngoto out;\r\naddr = fw_img_start;\r\nfor (size -= SF_PAGE_SIZE; size; size -= SF_PAGE_SIZE) {\r\naddr += SF_PAGE_SIZE;\r\nfw_data += SF_PAGE_SIZE;\r\nret = t4_write_flash(adap, addr, SF_PAGE_SIZE, fw_data);\r\nif (ret)\r\ngoto out;\r\n}\r\nret = t4_write_flash(adap,\r\nfw_img_start + offsetof(struct fw_hdr, fw_ver),\r\nsizeof(hdr->fw_ver), (const u8 *)&hdr->fw_ver);\r\nout:\r\nif (ret)\r\ndev_err(adap->pdev_dev, "firmware download failed, error %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nint t4_link_start(struct adapter *adap, unsigned int mbox, unsigned int port,\r\nstruct link_config *lc)\r\n{\r\nstruct fw_port_cmd c;\r\nunsigned int fc = 0, mdi = FW_PORT_MDI(FW_PORT_MDI_AUTO);\r\nlc->link_ok = 0;\r\nif (lc->requested_fc & PAUSE_RX)\r\nfc |= FW_PORT_CAP_FC_RX;\r\nif (lc->requested_fc & PAUSE_TX)\r\nfc |= FW_PORT_CAP_FC_TX;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_portid = htonl(FW_CMD_OP(FW_PORT_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_EXEC | FW_PORT_CMD_PORTID(port));\r\nc.action_to_len16 = htonl(FW_PORT_CMD_ACTION(FW_PORT_ACTION_L1_CFG) |\r\nFW_LEN16(c));\r\nif (!(lc->supported & FW_PORT_CAP_ANEG)) {\r\nc.u.l1cfg.rcap = htonl((lc->supported & ADVERT_MASK) | fc);\r\nlc->fc = lc->requested_fc & (PAUSE_RX | PAUSE_TX);\r\n} else if (lc->autoneg == AUTONEG_DISABLE) {\r\nc.u.l1cfg.rcap = htonl(lc->requested_speed | fc | mdi);\r\nlc->fc = lc->requested_fc & (PAUSE_RX | PAUSE_TX);\r\n} else\r\nc.u.l1cfg.rcap = htonl(lc->advertising | fc | mdi);\r\nreturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\r\n}\r\nint t4_restart_aneg(struct adapter *adap, unsigned int mbox, unsigned int port)\r\n{\r\nstruct fw_port_cmd c;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_portid = htonl(FW_CMD_OP(FW_PORT_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_EXEC | FW_PORT_CMD_PORTID(port));\r\nc.action_to_len16 = htonl(FW_PORT_CMD_ACTION(FW_PORT_ACTION_L1_CFG) |\r\nFW_LEN16(c));\r\nc.u.l1cfg.rcap = htonl(FW_PORT_CAP_ANEG);\r\nreturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\r\n}\r\nstatic int t4_handle_intr_status(struct adapter *adapter, unsigned int reg,\r\nconst struct intr_info *acts)\r\n{\r\nint fatal = 0;\r\nunsigned int mask = 0;\r\nunsigned int status = t4_read_reg(adapter, reg);\r\nfor ( ; acts->mask; ++acts) {\r\nif (!(status & acts->mask))\r\ncontinue;\r\nif (acts->fatal) {\r\nfatal++;\r\ndev_alert(adapter->pdev_dev, "%s (0x%x)\n", acts->msg,\r\nstatus & acts->mask);\r\n} else if (acts->msg && printk_ratelimit())\r\ndev_warn(adapter->pdev_dev, "%s (0x%x)\n", acts->msg,\r\nstatus & acts->mask);\r\nmask |= acts->mask;\r\n}\r\nstatus &= mask;\r\nif (status)\r\nt4_write_reg(adapter, reg, status);\r\nreturn fatal;\r\n}\r\nstatic void pcie_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info sysbus_intr_info[] = {\r\n{ RNPP, "RXNP array parity error", -1, 1 },\r\n{ RPCP, "RXPC array parity error", -1, 1 },\r\n{ RCIP, "RXCIF array parity error", -1, 1 },\r\n{ RCCP, "Rx completions control array parity error", -1, 1 },\r\n{ RFTP, "RXFT array parity error", -1, 1 },\r\n{ 0 }\r\n};\r\nstatic const struct intr_info pcie_port_intr_info[] = {\r\n{ TPCP, "TXPC array parity error", -1, 1 },\r\n{ TNPP, "TXNP array parity error", -1, 1 },\r\n{ TFTP, "TXFT array parity error", -1, 1 },\r\n{ TCAP, "TXCA array parity error", -1, 1 },\r\n{ TCIP, "TXCIF array parity error", -1, 1 },\r\n{ RCAP, "RXCA array parity error", -1, 1 },\r\n{ OTDD, "outbound request TLP discarded", -1, 1 },\r\n{ RDPE, "Rx data parity error", -1, 1 },\r\n{ TDUE, "Tx uncorrectable data error", -1, 1 },\r\n{ 0 }\r\n};\r\nstatic const struct intr_info pcie_intr_info[] = {\r\n{ MSIADDRLPERR, "MSI AddrL parity error", -1, 1 },\r\n{ MSIADDRHPERR, "MSI AddrH parity error", -1, 1 },\r\n{ MSIDATAPERR, "MSI data parity error", -1, 1 },\r\n{ MSIXADDRLPERR, "MSI-X AddrL parity error", -1, 1 },\r\n{ MSIXADDRHPERR, "MSI-X AddrH parity error", -1, 1 },\r\n{ MSIXDATAPERR, "MSI-X data parity error", -1, 1 },\r\n{ MSIXDIPERR, "MSI-X DI parity error", -1, 1 },\r\n{ PIOCPLPERR, "PCI PIO completion FIFO parity error", -1, 1 },\r\n{ PIOREQPERR, "PCI PIO request FIFO parity error", -1, 1 },\r\n{ TARTAGPERR, "PCI PCI target tag FIFO parity error", -1, 1 },\r\n{ CCNTPERR, "PCI CMD channel count parity error", -1, 1 },\r\n{ CREQPERR, "PCI CMD channel request parity error", -1, 1 },\r\n{ CRSPPERR, "PCI CMD channel response parity error", -1, 1 },\r\n{ DCNTPERR, "PCI DMA channel count parity error", -1, 1 },\r\n{ DREQPERR, "PCI DMA channel request parity error", -1, 1 },\r\n{ DRSPPERR, "PCI DMA channel response parity error", -1, 1 },\r\n{ HCNTPERR, "PCI HMA channel count parity error", -1, 1 },\r\n{ HREQPERR, "PCI HMA channel request parity error", -1, 1 },\r\n{ HRSPPERR, "PCI HMA channel response parity error", -1, 1 },\r\n{ CFGSNPPERR, "PCI config snoop FIFO parity error", -1, 1 },\r\n{ FIDPERR, "PCI FID parity error", -1, 1 },\r\n{ INTXCLRPERR, "PCI INTx clear parity error", -1, 1 },\r\n{ MATAGPERR, "PCI MA tag parity error", -1, 1 },\r\n{ PIOTAGPERR, "PCI PIO tag parity error", -1, 1 },\r\n{ RXCPLPERR, "PCI Rx completion parity error", -1, 1 },\r\n{ RXWRPERR, "PCI Rx write parity error", -1, 1 },\r\n{ RPLPERR, "PCI replay buffer parity error", -1, 1 },\r\n{ PCIESINT, "PCI core secondary fault", -1, 1 },\r\n{ PCIEPINT, "PCI core primary fault", -1, 1 },\r\n{ UNXSPLCPLERR, "PCI unexpected split completion error", -1, 0 },\r\n{ 0 }\r\n};\r\nint fat;\r\nfat = t4_handle_intr_status(adapter,\r\nPCIE_CORE_UTL_SYSTEM_BUS_AGENT_STATUS,\r\nsysbus_intr_info) +\r\nt4_handle_intr_status(adapter,\r\nPCIE_CORE_UTL_PCI_EXPRESS_PORT_STATUS,\r\npcie_port_intr_info) +\r\nt4_handle_intr_status(adapter, PCIE_INT_CAUSE, pcie_intr_info);\r\nif (fat)\r\nt4_fatal_err(adapter);\r\n}\r\nstatic void tp_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info tp_intr_info[] = {\r\n{ 0x3fffffff, "TP parity error", -1, 1 },\r\n{ FLMTXFLSTEMPTY, "TP out of Tx pages", -1, 1 },\r\n{ 0 }\r\n};\r\nif (t4_handle_intr_status(adapter, TP_INT_CAUSE, tp_intr_info))\r\nt4_fatal_err(adapter);\r\n}\r\nstatic void sge_intr_handler(struct adapter *adapter)\r\n{\r\nu64 v;\r\nstatic const struct intr_info sge_intr_info[] = {\r\n{ ERR_CPL_EXCEED_IQE_SIZE,\r\n"SGE received CPL exceeding IQE size", -1, 1 },\r\n{ ERR_INVALID_CIDX_INC,\r\n"SGE GTS CIDX increment too large", -1, 0 },\r\n{ ERR_CPL_OPCODE_0, "SGE received 0-length CPL", -1, 0 },\r\n{ ERR_DROPPED_DB, "SGE doorbell dropped", -1, 0 },\r\n{ ERR_DATA_CPL_ON_HIGH_QID1 | ERR_DATA_CPL_ON_HIGH_QID0,\r\n"SGE IQID > 1023 received CPL for FL", -1, 0 },\r\n{ ERR_BAD_DB_PIDX3, "SGE DBP 3 pidx increment too large", -1,\r\n0 },\r\n{ ERR_BAD_DB_PIDX2, "SGE DBP 2 pidx increment too large", -1,\r\n0 },\r\n{ ERR_BAD_DB_PIDX1, "SGE DBP 1 pidx increment too large", -1,\r\n0 },\r\n{ ERR_BAD_DB_PIDX0, "SGE DBP 0 pidx increment too large", -1,\r\n0 },\r\n{ ERR_ING_CTXT_PRIO,\r\n"SGE too many priority ingress contexts", -1, 0 },\r\n{ ERR_EGR_CTXT_PRIO,\r\n"SGE too many priority egress contexts", -1, 0 },\r\n{ INGRESS_SIZE_ERR, "SGE illegal ingress QID", -1, 0 },\r\n{ EGRESS_SIZE_ERR, "SGE illegal egress QID", -1, 0 },\r\n{ 0 }\r\n};\r\nv = (u64)t4_read_reg(adapter, SGE_INT_CAUSE1) |\r\n((u64)t4_read_reg(adapter, SGE_INT_CAUSE2) << 32);\r\nif (v) {\r\ndev_alert(adapter->pdev_dev, "SGE parity error (%#llx)\n",\r\n(unsigned long long)v);\r\nt4_write_reg(adapter, SGE_INT_CAUSE1, v);\r\nt4_write_reg(adapter, SGE_INT_CAUSE2, v >> 32);\r\n}\r\nif (t4_handle_intr_status(adapter, SGE_INT_CAUSE3, sge_intr_info) ||\r\nv != 0)\r\nt4_fatal_err(adapter);\r\n}\r\nstatic void cim_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info cim_intr_info[] = {\r\n{ PREFDROPINT, "CIM control register prefetch drop", -1, 1 },\r\n{ OBQPARERR, "CIM OBQ parity error", -1, 1 },\r\n{ IBQPARERR, "CIM IBQ parity error", -1, 1 },\r\n{ MBUPPARERR, "CIM mailbox uP parity error", -1, 1 },\r\n{ MBHOSTPARERR, "CIM mailbox host parity error", -1, 1 },\r\n{ TIEQINPARERRINT, "CIM TIEQ outgoing parity error", -1, 1 },\r\n{ TIEQOUTPARERRINT, "CIM TIEQ incoming parity error", -1, 1 },\r\n{ 0 }\r\n};\r\nstatic const struct intr_info cim_upintr_info[] = {\r\n{ RSVDSPACEINT, "CIM reserved space access", -1, 1 },\r\n{ ILLTRANSINT, "CIM illegal transaction", -1, 1 },\r\n{ ILLWRINT, "CIM illegal write", -1, 1 },\r\n{ ILLRDINT, "CIM illegal read", -1, 1 },\r\n{ ILLRDBEINT, "CIM illegal read BE", -1, 1 },\r\n{ ILLWRBEINT, "CIM illegal write BE", -1, 1 },\r\n{ SGLRDBOOTINT, "CIM single read from boot space", -1, 1 },\r\n{ SGLWRBOOTINT, "CIM single write to boot space", -1, 1 },\r\n{ BLKWRBOOTINT, "CIM block write to boot space", -1, 1 },\r\n{ SGLRDFLASHINT, "CIM single read from flash space", -1, 1 },\r\n{ SGLWRFLASHINT, "CIM single write to flash space", -1, 1 },\r\n{ BLKWRFLASHINT, "CIM block write to flash space", -1, 1 },\r\n{ SGLRDEEPROMINT, "CIM single EEPROM read", -1, 1 },\r\n{ SGLWREEPROMINT, "CIM single EEPROM write", -1, 1 },\r\n{ BLKRDEEPROMINT, "CIM block EEPROM read", -1, 1 },\r\n{ BLKWREEPROMINT, "CIM block EEPROM write", -1, 1 },\r\n{ SGLRDCTLINT , "CIM single read from CTL space", -1, 1 },\r\n{ SGLWRCTLINT , "CIM single write to CTL space", -1, 1 },\r\n{ BLKRDCTLINT , "CIM block read from CTL space", -1, 1 },\r\n{ BLKWRCTLINT , "CIM block write to CTL space", -1, 1 },\r\n{ SGLRDPLINT , "CIM single read from PL space", -1, 1 },\r\n{ SGLWRPLINT , "CIM single write to PL space", -1, 1 },\r\n{ BLKRDPLINT , "CIM block read from PL space", -1, 1 },\r\n{ BLKWRPLINT , "CIM block write to PL space", -1, 1 },\r\n{ REQOVRLOOKUPINT , "CIM request FIFO overwrite", -1, 1 },\r\n{ RSPOVRLOOKUPINT , "CIM response FIFO overwrite", -1, 1 },\r\n{ TIMEOUTINT , "CIM PIF timeout", -1, 1 },\r\n{ TIMEOUTMAINT , "CIM PIF MA timeout", -1, 1 },\r\n{ 0 }\r\n};\r\nint fat;\r\nfat = t4_handle_intr_status(adapter, CIM_HOST_INT_CAUSE,\r\ncim_intr_info) +\r\nt4_handle_intr_status(adapter, CIM_HOST_UPACC_INT_CAUSE,\r\ncim_upintr_info);\r\nif (fat)\r\nt4_fatal_err(adapter);\r\n}\r\nstatic void ulprx_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info ulprx_intr_info[] = {\r\n{ 0x1800000, "ULPRX context error", -1, 1 },\r\n{ 0x7fffff, "ULPRX parity error", -1, 1 },\r\n{ 0 }\r\n};\r\nif (t4_handle_intr_status(adapter, ULP_RX_INT_CAUSE, ulprx_intr_info))\r\nt4_fatal_err(adapter);\r\n}\r\nstatic void ulptx_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info ulptx_intr_info[] = {\r\n{ PBL_BOUND_ERR_CH3, "ULPTX channel 3 PBL out of bounds", -1,\r\n0 },\r\n{ PBL_BOUND_ERR_CH2, "ULPTX channel 2 PBL out of bounds", -1,\r\n0 },\r\n{ PBL_BOUND_ERR_CH1, "ULPTX channel 1 PBL out of bounds", -1,\r\n0 },\r\n{ PBL_BOUND_ERR_CH0, "ULPTX channel 0 PBL out of bounds", -1,\r\n0 },\r\n{ 0xfffffff, "ULPTX parity error", -1, 1 },\r\n{ 0 }\r\n};\r\nif (t4_handle_intr_status(adapter, ULP_TX_INT_CAUSE, ulptx_intr_info))\r\nt4_fatal_err(adapter);\r\n}\r\nstatic void pmtx_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info pmtx_intr_info[] = {\r\n{ PCMD_LEN_OVFL0, "PMTX channel 0 pcmd too large", -1, 1 },\r\n{ PCMD_LEN_OVFL1, "PMTX channel 1 pcmd too large", -1, 1 },\r\n{ PCMD_LEN_OVFL2, "PMTX channel 2 pcmd too large", -1, 1 },\r\n{ ZERO_C_CMD_ERROR, "PMTX 0-length pcmd", -1, 1 },\r\n{ PMTX_FRAMING_ERROR, "PMTX framing error", -1, 1 },\r\n{ OESPI_PAR_ERROR, "PMTX oespi parity error", -1, 1 },\r\n{ DB_OPTIONS_PAR_ERROR, "PMTX db_options parity error", -1, 1 },\r\n{ ICSPI_PAR_ERROR, "PMTX icspi parity error", -1, 1 },\r\n{ C_PCMD_PAR_ERROR, "PMTX c_pcmd parity error", -1, 1},\r\n{ 0 }\r\n};\r\nif (t4_handle_intr_status(adapter, PM_TX_INT_CAUSE, pmtx_intr_info))\r\nt4_fatal_err(adapter);\r\n}\r\nstatic void pmrx_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info pmrx_intr_info[] = {\r\n{ ZERO_E_CMD_ERROR, "PMRX 0-length pcmd", -1, 1 },\r\n{ PMRX_FRAMING_ERROR, "PMRX framing error", -1, 1 },\r\n{ OCSPI_PAR_ERROR, "PMRX ocspi parity error", -1, 1 },\r\n{ DB_OPTIONS_PAR_ERROR, "PMRX db_options parity error", -1, 1 },\r\n{ IESPI_PAR_ERROR, "PMRX iespi parity error", -1, 1 },\r\n{ E_PCMD_PAR_ERROR, "PMRX e_pcmd parity error", -1, 1},\r\n{ 0 }\r\n};\r\nif (t4_handle_intr_status(adapter, PM_RX_INT_CAUSE, pmrx_intr_info))\r\nt4_fatal_err(adapter);\r\n}\r\nstatic void cplsw_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info cplsw_intr_info[] = {\r\n{ CIM_OP_MAP_PERR, "CPLSW CIM op_map parity error", -1, 1 },\r\n{ CIM_OVFL_ERROR, "CPLSW CIM overflow", -1, 1 },\r\n{ TP_FRAMING_ERROR, "CPLSW TP framing error", -1, 1 },\r\n{ SGE_FRAMING_ERROR, "CPLSW SGE framing error", -1, 1 },\r\n{ CIM_FRAMING_ERROR, "CPLSW CIM framing error", -1, 1 },\r\n{ ZERO_SWITCH_ERROR, "CPLSW no-switch error", -1, 1 },\r\n{ 0 }\r\n};\r\nif (t4_handle_intr_status(adapter, CPL_INTR_CAUSE, cplsw_intr_info))\r\nt4_fatal_err(adapter);\r\n}\r\nstatic void le_intr_handler(struct adapter *adap)\r\n{\r\nstatic const struct intr_info le_intr_info[] = {\r\n{ LIPMISS, "LE LIP miss", -1, 0 },\r\n{ LIP0, "LE 0 LIP error", -1, 0 },\r\n{ PARITYERR, "LE parity error", -1, 1 },\r\n{ UNKNOWNCMD, "LE unknown command", -1, 1 },\r\n{ REQQPARERR, "LE request queue parity error", -1, 1 },\r\n{ 0 }\r\n};\r\nif (t4_handle_intr_status(adap, LE_DB_INT_CAUSE, le_intr_info))\r\nt4_fatal_err(adap);\r\n}\r\nstatic void mps_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info mps_rx_intr_info[] = {\r\n{ 0xffffff, "MPS Rx parity error", -1, 1 },\r\n{ 0 }\r\n};\r\nstatic const struct intr_info mps_tx_intr_info[] = {\r\n{ TPFIFO, "MPS Tx TP FIFO parity error", -1, 1 },\r\n{ NCSIFIFO, "MPS Tx NC-SI FIFO parity error", -1, 1 },\r\n{ TXDATAFIFO, "MPS Tx data FIFO parity error", -1, 1 },\r\n{ TXDESCFIFO, "MPS Tx desc FIFO parity error", -1, 1 },\r\n{ BUBBLE, "MPS Tx underflow", -1, 1 },\r\n{ SECNTERR, "MPS Tx SOP/EOP error", -1, 1 },\r\n{ FRMERR, "MPS Tx framing error", -1, 1 },\r\n{ 0 }\r\n};\r\nstatic const struct intr_info mps_trc_intr_info[] = {\r\n{ FILTMEM, "MPS TRC filter parity error", -1, 1 },\r\n{ PKTFIFO, "MPS TRC packet FIFO parity error", -1, 1 },\r\n{ MISCPERR, "MPS TRC misc parity error", -1, 1 },\r\n{ 0 }\r\n};\r\nstatic const struct intr_info mps_stat_sram_intr_info[] = {\r\n{ 0x1fffff, "MPS statistics SRAM parity error", -1, 1 },\r\n{ 0 }\r\n};\r\nstatic const struct intr_info mps_stat_tx_intr_info[] = {\r\n{ 0xfffff, "MPS statistics Tx FIFO parity error", -1, 1 },\r\n{ 0 }\r\n};\r\nstatic const struct intr_info mps_stat_rx_intr_info[] = {\r\n{ 0xffffff, "MPS statistics Rx FIFO parity error", -1, 1 },\r\n{ 0 }\r\n};\r\nstatic const struct intr_info mps_cls_intr_info[] = {\r\n{ MATCHSRAM, "MPS match SRAM parity error", -1, 1 },\r\n{ MATCHTCAM, "MPS match TCAM parity error", -1, 1 },\r\n{ HASHSRAM, "MPS hash SRAM parity error", -1, 1 },\r\n{ 0 }\r\n};\r\nint fat;\r\nfat = t4_handle_intr_status(adapter, MPS_RX_PERR_INT_CAUSE,\r\nmps_rx_intr_info) +\r\nt4_handle_intr_status(adapter, MPS_TX_INT_CAUSE,\r\nmps_tx_intr_info) +\r\nt4_handle_intr_status(adapter, MPS_TRC_INT_CAUSE,\r\nmps_trc_intr_info) +\r\nt4_handle_intr_status(adapter, MPS_STAT_PERR_INT_CAUSE_SRAM,\r\nmps_stat_sram_intr_info) +\r\nt4_handle_intr_status(adapter, MPS_STAT_PERR_INT_CAUSE_TX_FIFO,\r\nmps_stat_tx_intr_info) +\r\nt4_handle_intr_status(adapter, MPS_STAT_PERR_INT_CAUSE_RX_FIFO,\r\nmps_stat_rx_intr_info) +\r\nt4_handle_intr_status(adapter, MPS_CLS_INT_CAUSE,\r\nmps_cls_intr_info);\r\nt4_write_reg(adapter, MPS_INT_CAUSE, CLSINT | TRCINT |\r\nRXINT | TXINT | STATINT);\r\nt4_read_reg(adapter, MPS_INT_CAUSE);\r\nif (fat)\r\nt4_fatal_err(adapter);\r\n}\r\nstatic void mem_intr_handler(struct adapter *adapter, int idx)\r\n{\r\nstatic const char name[3][5] = { "EDC0", "EDC1", "MC" };\r\nunsigned int addr, cnt_addr, v;\r\nif (idx <= MEM_EDC1) {\r\naddr = EDC_REG(EDC_INT_CAUSE, idx);\r\ncnt_addr = EDC_REG(EDC_ECC_STATUS, idx);\r\n} else {\r\naddr = MC_INT_CAUSE;\r\ncnt_addr = MC_ECC_STATUS;\r\n}\r\nv = t4_read_reg(adapter, addr) & MEM_INT_MASK;\r\nif (v & PERR_INT_CAUSE)\r\ndev_alert(adapter->pdev_dev, "%s FIFO parity error\n",\r\nname[idx]);\r\nif (v & ECC_CE_INT_CAUSE) {\r\nu32 cnt = ECC_CECNT_GET(t4_read_reg(adapter, cnt_addr));\r\nt4_write_reg(adapter, cnt_addr, ECC_CECNT_MASK);\r\nif (printk_ratelimit())\r\ndev_warn(adapter->pdev_dev,\r\n"%u %s correctable ECC data error%s\n",\r\ncnt, name[idx], cnt > 1 ? "s" : "");\r\n}\r\nif (v & ECC_UE_INT_CAUSE)\r\ndev_alert(adapter->pdev_dev,\r\n"%s uncorrectable ECC data error\n", name[idx]);\r\nt4_write_reg(adapter, addr, v);\r\nif (v & (PERR_INT_CAUSE | ECC_UE_INT_CAUSE))\r\nt4_fatal_err(adapter);\r\n}\r\nstatic void ma_intr_handler(struct adapter *adap)\r\n{\r\nu32 v, status = t4_read_reg(adap, MA_INT_CAUSE);\r\nif (status & MEM_PERR_INT_CAUSE)\r\ndev_alert(adap->pdev_dev,\r\n"MA parity error, parity status %#x\n",\r\nt4_read_reg(adap, MA_PARITY_ERROR_STATUS));\r\nif (status & MEM_WRAP_INT_CAUSE) {\r\nv = t4_read_reg(adap, MA_INT_WRAP_STATUS);\r\ndev_alert(adap->pdev_dev, "MA address wrap-around error by "\r\n"client %u to address %#x\n",\r\nMEM_WRAP_CLIENT_NUM_GET(v),\r\nMEM_WRAP_ADDRESS_GET(v) << 4);\r\n}\r\nt4_write_reg(adap, MA_INT_CAUSE, status);\r\nt4_fatal_err(adap);\r\n}\r\nstatic void smb_intr_handler(struct adapter *adap)\r\n{\r\nstatic const struct intr_info smb_intr_info[] = {\r\n{ MSTTXFIFOPARINT, "SMB master Tx FIFO parity error", -1, 1 },\r\n{ MSTRXFIFOPARINT, "SMB master Rx FIFO parity error", -1, 1 },\r\n{ SLVFIFOPARINT, "SMB slave FIFO parity error", -1, 1 },\r\n{ 0 }\r\n};\r\nif (t4_handle_intr_status(adap, SMB_INT_CAUSE, smb_intr_info))\r\nt4_fatal_err(adap);\r\n}\r\nstatic void ncsi_intr_handler(struct adapter *adap)\r\n{\r\nstatic const struct intr_info ncsi_intr_info[] = {\r\n{ CIM_DM_PRTY_ERR, "NC-SI CIM parity error", -1, 1 },\r\n{ MPS_DM_PRTY_ERR, "NC-SI MPS parity error", -1, 1 },\r\n{ TXFIFO_PRTY_ERR, "NC-SI Tx FIFO parity error", -1, 1 },\r\n{ RXFIFO_PRTY_ERR, "NC-SI Rx FIFO parity error", -1, 1 },\r\n{ 0 }\r\n};\r\nif (t4_handle_intr_status(adap, NCSI_INT_CAUSE, ncsi_intr_info))\r\nt4_fatal_err(adap);\r\n}\r\nstatic void xgmac_intr_handler(struct adapter *adap, int port)\r\n{\r\nu32 v = t4_read_reg(adap, PORT_REG(port, XGMAC_PORT_INT_CAUSE));\r\nv &= TXFIFO_PRTY_ERR | RXFIFO_PRTY_ERR;\r\nif (!v)\r\nreturn;\r\nif (v & TXFIFO_PRTY_ERR)\r\ndev_alert(adap->pdev_dev, "XGMAC %d Tx FIFO parity error\n",\r\nport);\r\nif (v & RXFIFO_PRTY_ERR)\r\ndev_alert(adap->pdev_dev, "XGMAC %d Rx FIFO parity error\n",\r\nport);\r\nt4_write_reg(adap, PORT_REG(port, XGMAC_PORT_INT_CAUSE), v);\r\nt4_fatal_err(adap);\r\n}\r\nstatic void pl_intr_handler(struct adapter *adap)\r\n{\r\nstatic const struct intr_info pl_intr_info[] = {\r\n{ FATALPERR, "T4 fatal parity error", -1, 1 },\r\n{ PERRVFID, "PL VFID_MAP parity error", -1, 1 },\r\n{ 0 }\r\n};\r\nif (t4_handle_intr_status(adap, PL_PL_INT_CAUSE, pl_intr_info))\r\nt4_fatal_err(adap);\r\n}\r\nint t4_slow_intr_handler(struct adapter *adapter)\r\n{\r\nu32 cause = t4_read_reg(adapter, PL_INT_CAUSE);\r\nif (!(cause & GLBL_INTR_MASK))\r\nreturn 0;\r\nif (cause & CIM)\r\ncim_intr_handler(adapter);\r\nif (cause & MPS)\r\nmps_intr_handler(adapter);\r\nif (cause & NCSI)\r\nncsi_intr_handler(adapter);\r\nif (cause & PL)\r\npl_intr_handler(adapter);\r\nif (cause & SMB)\r\nsmb_intr_handler(adapter);\r\nif (cause & XGMAC0)\r\nxgmac_intr_handler(adapter, 0);\r\nif (cause & XGMAC1)\r\nxgmac_intr_handler(adapter, 1);\r\nif (cause & XGMAC_KR0)\r\nxgmac_intr_handler(adapter, 2);\r\nif (cause & XGMAC_KR1)\r\nxgmac_intr_handler(adapter, 3);\r\nif (cause & PCIE)\r\npcie_intr_handler(adapter);\r\nif (cause & MC)\r\nmem_intr_handler(adapter, MEM_MC);\r\nif (cause & EDC0)\r\nmem_intr_handler(adapter, MEM_EDC0);\r\nif (cause & EDC1)\r\nmem_intr_handler(adapter, MEM_EDC1);\r\nif (cause & LE)\r\nle_intr_handler(adapter);\r\nif (cause & TP)\r\ntp_intr_handler(adapter);\r\nif (cause & MA)\r\nma_intr_handler(adapter);\r\nif (cause & PM_TX)\r\npmtx_intr_handler(adapter);\r\nif (cause & PM_RX)\r\npmrx_intr_handler(adapter);\r\nif (cause & ULP_RX)\r\nulprx_intr_handler(adapter);\r\nif (cause & CPL_SWITCH)\r\ncplsw_intr_handler(adapter);\r\nif (cause & SGE)\r\nsge_intr_handler(adapter);\r\nif (cause & ULP_TX)\r\nulptx_intr_handler(adapter);\r\nt4_write_reg(adapter, PL_INT_CAUSE, cause & GLBL_INTR_MASK);\r\n(void) t4_read_reg(adapter, PL_INT_CAUSE);\r\nreturn 1;\r\n}\r\nvoid t4_intr_enable(struct adapter *adapter)\r\n{\r\nu32 pf = SOURCEPF_GET(t4_read_reg(adapter, PL_WHOAMI));\r\nt4_write_reg(adapter, SGE_INT_ENABLE3, ERR_CPL_EXCEED_IQE_SIZE |\r\nERR_INVALID_CIDX_INC | ERR_CPL_OPCODE_0 |\r\nERR_DROPPED_DB | ERR_DATA_CPL_ON_HIGH_QID1 |\r\nERR_DATA_CPL_ON_HIGH_QID0 | ERR_BAD_DB_PIDX3 |\r\nERR_BAD_DB_PIDX2 | ERR_BAD_DB_PIDX1 |\r\nERR_BAD_DB_PIDX0 | ERR_ING_CTXT_PRIO |\r\nERR_EGR_CTXT_PRIO | INGRESS_SIZE_ERR |\r\nEGRESS_SIZE_ERR);\r\nt4_write_reg(adapter, MYPF_REG(PL_PF_INT_ENABLE), PF_INTR_MASK);\r\nt4_set_reg_field(adapter, PL_INT_MAP0, 0, 1 << pf);\r\n}\r\nvoid t4_intr_disable(struct adapter *adapter)\r\n{\r\nu32 pf = SOURCEPF_GET(t4_read_reg(adapter, PL_WHOAMI));\r\nt4_write_reg(adapter, MYPF_REG(PL_PF_INT_ENABLE), 0);\r\nt4_set_reg_field(adapter, PL_INT_MAP0, 1 << pf, 0);\r\n}\r\nstatic int hash_mac_addr(const u8 *addr)\r\n{\r\nu32 a = ((u32)addr[0] << 16) | ((u32)addr[1] << 8) | addr[2];\r\nu32 b = ((u32)addr[3] << 16) | ((u32)addr[4] << 8) | addr[5];\r\na ^= b;\r\na ^= (a >> 12);\r\na ^= (a >> 6);\r\nreturn a & 0x3f;\r\n}\r\nint t4_config_rss_range(struct adapter *adapter, int mbox, unsigned int viid,\r\nint start, int n, const u16 *rspq, unsigned int nrspq)\r\n{\r\nint ret;\r\nconst u16 *rsp = rspq;\r\nconst u16 *rsp_end = rspq + nrspq;\r\nstruct fw_rss_ind_tbl_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = htonl(FW_CMD_OP(FW_RSS_IND_TBL_CMD) |\r\nFW_CMD_REQUEST | FW_CMD_WRITE |\r\nFW_RSS_IND_TBL_CMD_VIID(viid));\r\ncmd.retval_len16 = htonl(FW_LEN16(cmd));\r\nwhile (n > 0) {\r\nint nq = min(n, 32);\r\n__be32 *qp = &cmd.iq0_to_iq2;\r\ncmd.niqid = htons(nq);\r\ncmd.startidx = htons(start);\r\nstart += nq;\r\nn -= nq;\r\nwhile (nq > 0) {\r\nunsigned int v;\r\nv = FW_RSS_IND_TBL_CMD_IQ0(*rsp);\r\nif (++rsp >= rsp_end)\r\nrsp = rspq;\r\nv |= FW_RSS_IND_TBL_CMD_IQ1(*rsp);\r\nif (++rsp >= rsp_end)\r\nrsp = rspq;\r\nv |= FW_RSS_IND_TBL_CMD_IQ2(*rsp);\r\nif (++rsp >= rsp_end)\r\nrsp = rspq;\r\n*qp++ = htonl(v);\r\nnq -= 3;\r\n}\r\nret = t4_wr_mbox(adapter, mbox, &cmd, sizeof(cmd), NULL);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint t4_config_glbl_rss(struct adapter *adapter, int mbox, unsigned int mode,\r\nunsigned int flags)\r\n{\r\nstruct fw_rss_glb_config_cmd c;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_write = htonl(FW_CMD_OP(FW_RSS_GLB_CONFIG_CMD) |\r\nFW_CMD_REQUEST | FW_CMD_WRITE);\r\nc.retval_len16 = htonl(FW_LEN16(c));\r\nif (mode == FW_RSS_GLB_CONFIG_CMD_MODE_MANUAL) {\r\nc.u.manual.mode_pkd = htonl(FW_RSS_GLB_CONFIG_CMD_MODE(mode));\r\n} else if (mode == FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL) {\r\nc.u.basicvirtual.mode_pkd =\r\nhtonl(FW_RSS_GLB_CONFIG_CMD_MODE(mode));\r\nc.u.basicvirtual.synmapen_to_hashtoeplitz = htonl(flags);\r\n} else\r\nreturn -EINVAL;\r\nreturn t4_wr_mbox(adapter, mbox, &c, sizeof(c), NULL);\r\n}\r\nvoid t4_tp_get_tcp_stats(struct adapter *adap, struct tp_tcp_stats *v4,\r\nstruct tp_tcp_stats *v6)\r\n{\r\nu32 val[TP_MIB_TCP_RXT_SEG_LO - TP_MIB_TCP_OUT_RST + 1];\r\n#define STAT_IDX(x) ((TP_MIB_TCP_##x) - TP_MIB_TCP_OUT_RST)\r\n#define STAT(x) val[STAT_IDX(x)]\r\n#define STAT64(x) (((u64)STAT(x##_HI) << 32) | STAT(x##_LO))\r\nif (v4) {\r\nt4_read_indirect(adap, TP_MIB_INDEX, TP_MIB_DATA, val,\r\nARRAY_SIZE(val), TP_MIB_TCP_OUT_RST);\r\nv4->tcpOutRsts = STAT(OUT_RST);\r\nv4->tcpInSegs = STAT64(IN_SEG);\r\nv4->tcpOutSegs = STAT64(OUT_SEG);\r\nv4->tcpRetransSegs = STAT64(RXT_SEG);\r\n}\r\nif (v6) {\r\nt4_read_indirect(adap, TP_MIB_INDEX, TP_MIB_DATA, val,\r\nARRAY_SIZE(val), TP_MIB_TCP_V6OUT_RST);\r\nv6->tcpOutRsts = STAT(OUT_RST);\r\nv6->tcpInSegs = STAT64(IN_SEG);\r\nv6->tcpOutSegs = STAT64(OUT_SEG);\r\nv6->tcpRetransSegs = STAT64(RXT_SEG);\r\n}\r\n#undef STAT64\r\n#undef STAT\r\n#undef STAT_IDX\r\n}\r\nvoid t4_read_mtu_tbl(struct adapter *adap, u16 *mtus, u8 *mtu_log)\r\n{\r\nu32 v;\r\nint i;\r\nfor (i = 0; i < NMTUS; ++i) {\r\nt4_write_reg(adap, TP_MTU_TABLE,\r\nMTUINDEX(0xff) | MTUVALUE(i));\r\nv = t4_read_reg(adap, TP_MTU_TABLE);\r\nmtus[i] = MTUVALUE_GET(v);\r\nif (mtu_log)\r\nmtu_log[i] = MTUWIDTH_GET(v);\r\n}\r\n}\r\nstatic void __devinit init_cong_ctrl(unsigned short *a, unsigned short *b)\r\n{\r\na[0] = a[1] = a[2] = a[3] = a[4] = a[5] = a[6] = a[7] = a[8] = 1;\r\na[9] = 2;\r\na[10] = 3;\r\na[11] = 4;\r\na[12] = 5;\r\na[13] = 6;\r\na[14] = 7;\r\na[15] = 8;\r\na[16] = 9;\r\na[17] = 10;\r\na[18] = 14;\r\na[19] = 17;\r\na[20] = 21;\r\na[21] = 25;\r\na[22] = 30;\r\na[23] = 35;\r\na[24] = 45;\r\na[25] = 60;\r\na[26] = 80;\r\na[27] = 100;\r\na[28] = 200;\r\na[29] = 300;\r\na[30] = 400;\r\na[31] = 500;\r\nb[0] = b[1] = b[2] = b[3] = b[4] = b[5] = b[6] = b[7] = b[8] = 0;\r\nb[9] = b[10] = 1;\r\nb[11] = b[12] = 2;\r\nb[13] = b[14] = b[15] = b[16] = 3;\r\nb[17] = b[18] = b[19] = b[20] = b[21] = 4;\r\nb[22] = b[23] = b[24] = b[25] = b[26] = b[27] = 5;\r\nb[28] = b[29] = 6;\r\nb[30] = b[31] = 7;\r\n}\r\nvoid t4_load_mtus(struct adapter *adap, const unsigned short *mtus,\r\nconst unsigned short *alpha, const unsigned short *beta)\r\n{\r\nstatic const unsigned int avg_pkts[NCCTRL_WIN] = {\r\n2, 6, 10, 14, 20, 28, 40, 56, 80, 112, 160, 224, 320, 448, 640,\r\n896, 1281, 1792, 2560, 3584, 5120, 7168, 10240, 14336, 20480,\r\n28672, 40960, 57344, 81920, 114688, 163840, 229376\r\n};\r\nunsigned int i, w;\r\nfor (i = 0; i < NMTUS; ++i) {\r\nunsigned int mtu = mtus[i];\r\nunsigned int log2 = fls(mtu);\r\nif (!(mtu & ((1 << log2) >> 2)))\r\nlog2--;\r\nt4_write_reg(adap, TP_MTU_TABLE, MTUINDEX(i) |\r\nMTUWIDTH(log2) | MTUVALUE(mtu));\r\nfor (w = 0; w < NCCTRL_WIN; ++w) {\r\nunsigned int inc;\r\ninc = max(((mtu - 40) * alpha[w]) / avg_pkts[w],\r\nCC_MIN_INCR);\r\nt4_write_reg(adap, TP_CCTRL_TABLE, (i << 21) |\r\n(w << 16) | (beta[w] << 13) | inc);\r\n}\r\n}\r\n}\r\nstatic unsigned int get_mps_bg_map(struct adapter *adap, int idx)\r\n{\r\nu32 n = NUMPORTS_GET(t4_read_reg(adap, MPS_CMN_CTL));\r\nif (n == 0)\r\nreturn idx == 0 ? 0xf : 0;\r\nif (n == 1)\r\nreturn idx < 2 ? (3 << (2 * idx)) : 0;\r\nreturn 1 << idx;\r\n}\r\nvoid t4_get_port_stats(struct adapter *adap, int idx, struct port_stats *p)\r\n{\r\nu32 bgmap = get_mps_bg_map(adap, idx);\r\n#define GET_STAT(name) \\r\nt4_read_reg64(adap, PORT_REG(idx, MPS_PORT_STAT_##name##_L))\r\n#define GET_STAT_COM(name) t4_read_reg64(adap, MPS_STAT_##name##_L)\r\np->tx_octets = GET_STAT(TX_PORT_BYTES);\r\np->tx_frames = GET_STAT(TX_PORT_FRAMES);\r\np->tx_bcast_frames = GET_STAT(TX_PORT_BCAST);\r\np->tx_mcast_frames = GET_STAT(TX_PORT_MCAST);\r\np->tx_ucast_frames = GET_STAT(TX_PORT_UCAST);\r\np->tx_error_frames = GET_STAT(TX_PORT_ERROR);\r\np->tx_frames_64 = GET_STAT(TX_PORT_64B);\r\np->tx_frames_65_127 = GET_STAT(TX_PORT_65B_127B);\r\np->tx_frames_128_255 = GET_STAT(TX_PORT_128B_255B);\r\np->tx_frames_256_511 = GET_STAT(TX_PORT_256B_511B);\r\np->tx_frames_512_1023 = GET_STAT(TX_PORT_512B_1023B);\r\np->tx_frames_1024_1518 = GET_STAT(TX_PORT_1024B_1518B);\r\np->tx_frames_1519_max = GET_STAT(TX_PORT_1519B_MAX);\r\np->tx_drop = GET_STAT(TX_PORT_DROP);\r\np->tx_pause = GET_STAT(TX_PORT_PAUSE);\r\np->tx_ppp0 = GET_STAT(TX_PORT_PPP0);\r\np->tx_ppp1 = GET_STAT(TX_PORT_PPP1);\r\np->tx_ppp2 = GET_STAT(TX_PORT_PPP2);\r\np->tx_ppp3 = GET_STAT(TX_PORT_PPP3);\r\np->tx_ppp4 = GET_STAT(TX_PORT_PPP4);\r\np->tx_ppp5 = GET_STAT(TX_PORT_PPP5);\r\np->tx_ppp6 = GET_STAT(TX_PORT_PPP6);\r\np->tx_ppp7 = GET_STAT(TX_PORT_PPP7);\r\np->rx_octets = GET_STAT(RX_PORT_BYTES);\r\np->rx_frames = GET_STAT(RX_PORT_FRAMES);\r\np->rx_bcast_frames = GET_STAT(RX_PORT_BCAST);\r\np->rx_mcast_frames = GET_STAT(RX_PORT_MCAST);\r\np->rx_ucast_frames = GET_STAT(RX_PORT_UCAST);\r\np->rx_too_long = GET_STAT(RX_PORT_MTU_ERROR);\r\np->rx_jabber = GET_STAT(RX_PORT_MTU_CRC_ERROR);\r\np->rx_fcs_err = GET_STAT(RX_PORT_CRC_ERROR);\r\np->rx_len_err = GET_STAT(RX_PORT_LEN_ERROR);\r\np->rx_symbol_err = GET_STAT(RX_PORT_SYM_ERROR);\r\np->rx_runt = GET_STAT(RX_PORT_LESS_64B);\r\np->rx_frames_64 = GET_STAT(RX_PORT_64B);\r\np->rx_frames_65_127 = GET_STAT(RX_PORT_65B_127B);\r\np->rx_frames_128_255 = GET_STAT(RX_PORT_128B_255B);\r\np->rx_frames_256_511 = GET_STAT(RX_PORT_256B_511B);\r\np->rx_frames_512_1023 = GET_STAT(RX_PORT_512B_1023B);\r\np->rx_frames_1024_1518 = GET_STAT(RX_PORT_1024B_1518B);\r\np->rx_frames_1519_max = GET_STAT(RX_PORT_1519B_MAX);\r\np->rx_pause = GET_STAT(RX_PORT_PAUSE);\r\np->rx_ppp0 = GET_STAT(RX_PORT_PPP0);\r\np->rx_ppp1 = GET_STAT(RX_PORT_PPP1);\r\np->rx_ppp2 = GET_STAT(RX_PORT_PPP2);\r\np->rx_ppp3 = GET_STAT(RX_PORT_PPP3);\r\np->rx_ppp4 = GET_STAT(RX_PORT_PPP4);\r\np->rx_ppp5 = GET_STAT(RX_PORT_PPP5);\r\np->rx_ppp6 = GET_STAT(RX_PORT_PPP6);\r\np->rx_ppp7 = GET_STAT(RX_PORT_PPP7);\r\np->rx_ovflow0 = (bgmap & 1) ? GET_STAT_COM(RX_BG_0_MAC_DROP_FRAME) : 0;\r\np->rx_ovflow1 = (bgmap & 2) ? GET_STAT_COM(RX_BG_1_MAC_DROP_FRAME) : 0;\r\np->rx_ovflow2 = (bgmap & 4) ? GET_STAT_COM(RX_BG_2_MAC_DROP_FRAME) : 0;\r\np->rx_ovflow3 = (bgmap & 8) ? GET_STAT_COM(RX_BG_3_MAC_DROP_FRAME) : 0;\r\np->rx_trunc0 = (bgmap & 1) ? GET_STAT_COM(RX_BG_0_MAC_TRUNC_FRAME) : 0;\r\np->rx_trunc1 = (bgmap & 2) ? GET_STAT_COM(RX_BG_1_MAC_TRUNC_FRAME) : 0;\r\np->rx_trunc2 = (bgmap & 4) ? GET_STAT_COM(RX_BG_2_MAC_TRUNC_FRAME) : 0;\r\np->rx_trunc3 = (bgmap & 8) ? GET_STAT_COM(RX_BG_3_MAC_TRUNC_FRAME) : 0;\r\n#undef GET_STAT\r\n#undef GET_STAT_COM\r\n}\r\nvoid t4_wol_magic_enable(struct adapter *adap, unsigned int port,\r\nconst u8 *addr)\r\n{\r\nif (addr) {\r\nt4_write_reg(adap, PORT_REG(port, XGMAC_PORT_MAGIC_MACID_LO),\r\n(addr[2] << 24) | (addr[3] << 16) |\r\n(addr[4] << 8) | addr[5]);\r\nt4_write_reg(adap, PORT_REG(port, XGMAC_PORT_MAGIC_MACID_HI),\r\n(addr[0] << 8) | addr[1]);\r\n}\r\nt4_set_reg_field(adap, PORT_REG(port, XGMAC_PORT_CFG2), MAGICEN,\r\naddr ? MAGICEN : 0);\r\n}\r\nint t4_wol_pat_enable(struct adapter *adap, unsigned int port, unsigned int map,\r\nu64 mask0, u64 mask1, unsigned int crc, bool enable)\r\n{\r\nint i;\r\nif (!enable) {\r\nt4_set_reg_field(adap, PORT_REG(port, XGMAC_PORT_CFG2),\r\nPATEN, 0);\r\nreturn 0;\r\n}\r\nif (map > 0xff)\r\nreturn -EINVAL;\r\n#define EPIO_REG(name) PORT_REG(port, XGMAC_PORT_EPIO_##name)\r\nt4_write_reg(adap, EPIO_REG(DATA1), mask0 >> 32);\r\nt4_write_reg(adap, EPIO_REG(DATA2), mask1);\r\nt4_write_reg(adap, EPIO_REG(DATA3), mask1 >> 32);\r\nfor (i = 0; i < NWOL_PAT; i++, map >>= 1) {\r\nif (!(map & 1))\r\ncontinue;\r\nt4_write_reg(adap, EPIO_REG(DATA0), mask0);\r\nt4_write_reg(adap, EPIO_REG(OP), ADDRESS(i) | EPIOWR);\r\nt4_read_reg(adap, EPIO_REG(OP));\r\nif (t4_read_reg(adap, EPIO_REG(OP)) & BUSY)\r\nreturn -ETIMEDOUT;\r\nt4_write_reg(adap, EPIO_REG(DATA0), crc);\r\nt4_write_reg(adap, EPIO_REG(OP), ADDRESS(i + 32) | EPIOWR);\r\nt4_read_reg(adap, EPIO_REG(OP));\r\nif (t4_read_reg(adap, EPIO_REG(OP)) & BUSY)\r\nreturn -ETIMEDOUT;\r\n}\r\n#undef EPIO_REG\r\nt4_set_reg_field(adap, PORT_REG(port, XGMAC_PORT_CFG2), 0, PATEN);\r\nreturn 0;\r\n}\r\nint t4_mdio_rd(struct adapter *adap, unsigned int mbox, unsigned int phy_addr,\r\nunsigned int mmd, unsigned int reg, u16 *valp)\r\n{\r\nint ret;\r\nstruct fw_ldst_cmd c;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_addrspace = htonl(FW_CMD_OP(FW_LDST_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_READ | FW_LDST_CMD_ADDRSPACE(FW_LDST_ADDRSPC_MDIO));\r\nc.cycles_to_len16 = htonl(FW_LEN16(c));\r\nc.u.mdio.paddr_mmd = htons(FW_LDST_CMD_PADDR(phy_addr) |\r\nFW_LDST_CMD_MMD(mmd));\r\nc.u.mdio.raddr = htons(reg);\r\nret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);\r\nif (ret == 0)\r\n*valp = ntohs(c.u.mdio.rval);\r\nreturn ret;\r\n}\r\nint t4_mdio_wr(struct adapter *adap, unsigned int mbox, unsigned int phy_addr,\r\nunsigned int mmd, unsigned int reg, u16 val)\r\n{\r\nstruct fw_ldst_cmd c;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_addrspace = htonl(FW_CMD_OP(FW_LDST_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_WRITE | FW_LDST_CMD_ADDRSPACE(FW_LDST_ADDRSPC_MDIO));\r\nc.cycles_to_len16 = htonl(FW_LEN16(c));\r\nc.u.mdio.paddr_mmd = htons(FW_LDST_CMD_PADDR(phy_addr) |\r\nFW_LDST_CMD_MMD(mmd));\r\nc.u.mdio.raddr = htons(reg);\r\nc.u.mdio.rval = htons(val);\r\nreturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\r\n}\r\nint t4_fw_hello(struct adapter *adap, unsigned int mbox, unsigned int evt_mbox,\r\nenum dev_master master, enum dev_state *state)\r\n{\r\nint ret;\r\nstruct fw_hello_cmd c;\r\nINIT_CMD(c, HELLO, WRITE);\r\nc.err_to_mbasyncnot = htonl(\r\nFW_HELLO_CMD_MASTERDIS(master == MASTER_CANT) |\r\nFW_HELLO_CMD_MASTERFORCE(master == MASTER_MUST) |\r\nFW_HELLO_CMD_MBMASTER(master == MASTER_MUST ? mbox : 0xff) |\r\nFW_HELLO_CMD_MBASYNCNOT(evt_mbox));\r\nret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);\r\nif (ret == 0 && state) {\r\nu32 v = ntohl(c.err_to_mbasyncnot);\r\nif (v & FW_HELLO_CMD_INIT)\r\n*state = DEV_STATE_INIT;\r\nelse if (v & FW_HELLO_CMD_ERR)\r\n*state = DEV_STATE_ERR;\r\nelse\r\n*state = DEV_STATE_UNINIT;\r\n}\r\nreturn ret;\r\n}\r\nint t4_fw_bye(struct adapter *adap, unsigned int mbox)\r\n{\r\nstruct fw_bye_cmd c;\r\nINIT_CMD(c, BYE, WRITE);\r\nreturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\r\n}\r\nint t4_early_init(struct adapter *adap, unsigned int mbox)\r\n{\r\nstruct fw_initialize_cmd c;\r\nINIT_CMD(c, INITIALIZE, WRITE);\r\nreturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\r\n}\r\nint t4_fw_reset(struct adapter *adap, unsigned int mbox, int reset)\r\n{\r\nstruct fw_reset_cmd c;\r\nINIT_CMD(c, RESET, WRITE);\r\nc.val = htonl(reset);\r\nreturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\r\n}\r\nint t4_query_params(struct adapter *adap, unsigned int mbox, unsigned int pf,\r\nunsigned int vf, unsigned int nparams, const u32 *params,\r\nu32 *val)\r\n{\r\nint i, ret;\r\nstruct fw_params_cmd c;\r\n__be32 *p = &c.param[0].mnem;\r\nif (nparams > 7)\r\nreturn -EINVAL;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_vfn = htonl(FW_CMD_OP(FW_PARAMS_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_READ | FW_PARAMS_CMD_PFN(pf) |\r\nFW_PARAMS_CMD_VFN(vf));\r\nc.retval_len16 = htonl(FW_LEN16(c));\r\nfor (i = 0; i < nparams; i++, p += 2)\r\n*p = htonl(*params++);\r\nret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);\r\nif (ret == 0)\r\nfor (i = 0, p = &c.param[0].val; i < nparams; i++, p += 2)\r\n*val++ = ntohl(*p);\r\nreturn ret;\r\n}\r\nint t4_set_params(struct adapter *adap, unsigned int mbox, unsigned int pf,\r\nunsigned int vf, unsigned int nparams, const u32 *params,\r\nconst u32 *val)\r\n{\r\nstruct fw_params_cmd c;\r\n__be32 *p = &c.param[0].mnem;\r\nif (nparams > 7)\r\nreturn -EINVAL;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_vfn = htonl(FW_CMD_OP(FW_PARAMS_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_WRITE | FW_PARAMS_CMD_PFN(pf) |\r\nFW_PARAMS_CMD_VFN(vf));\r\nc.retval_len16 = htonl(FW_LEN16(c));\r\nwhile (nparams--) {\r\n*p++ = htonl(*params++);\r\n*p++ = htonl(*val++);\r\n}\r\nreturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\r\n}\r\nint t4_cfg_pfvf(struct adapter *adap, unsigned int mbox, unsigned int pf,\r\nunsigned int vf, unsigned int txq, unsigned int txq_eth_ctrl,\r\nunsigned int rxqi, unsigned int rxq, unsigned int tc,\r\nunsigned int vi, unsigned int cmask, unsigned int pmask,\r\nunsigned int nexact, unsigned int rcaps, unsigned int wxcaps)\r\n{\r\nstruct fw_pfvf_cmd c;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_vfn = htonl(FW_CMD_OP(FW_PFVF_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_WRITE | FW_PFVF_CMD_PFN(pf) |\r\nFW_PFVF_CMD_VFN(vf));\r\nc.retval_len16 = htonl(FW_LEN16(c));\r\nc.niqflint_niq = htonl(FW_PFVF_CMD_NIQFLINT(rxqi) |\r\nFW_PFVF_CMD_NIQ(rxq));\r\nc.type_to_neq = htonl(FW_PFVF_CMD_CMASK(cmask) |\r\nFW_PFVF_CMD_PMASK(pmask) |\r\nFW_PFVF_CMD_NEQ(txq));\r\nc.tc_to_nexactf = htonl(FW_PFVF_CMD_TC(tc) | FW_PFVF_CMD_NVI(vi) |\r\nFW_PFVF_CMD_NEXACTF(nexact));\r\nc.r_caps_to_nethctrl = htonl(FW_PFVF_CMD_R_CAPS(rcaps) |\r\nFW_PFVF_CMD_WX_CAPS(wxcaps) |\r\nFW_PFVF_CMD_NETHCTRL(txq_eth_ctrl));\r\nreturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\r\n}\r\nint t4_alloc_vi(struct adapter *adap, unsigned int mbox, unsigned int port,\r\nunsigned int pf, unsigned int vf, unsigned int nmac, u8 *mac,\r\nunsigned int *rss_size)\r\n{\r\nint ret;\r\nstruct fw_vi_cmd c;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_vfn = htonl(FW_CMD_OP(FW_VI_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_WRITE | FW_CMD_EXEC |\r\nFW_VI_CMD_PFN(pf) | FW_VI_CMD_VFN(vf));\r\nc.alloc_to_len16 = htonl(FW_VI_CMD_ALLOC | FW_LEN16(c));\r\nc.portid_pkd = FW_VI_CMD_PORTID(port);\r\nc.nmac = nmac - 1;\r\nret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);\r\nif (ret)\r\nreturn ret;\r\nif (mac) {\r\nmemcpy(mac, c.mac, sizeof(c.mac));\r\nswitch (nmac) {\r\ncase 5:\r\nmemcpy(mac + 24, c.nmac3, sizeof(c.nmac3));\r\ncase 4:\r\nmemcpy(mac + 18, c.nmac2, sizeof(c.nmac2));\r\ncase 3:\r\nmemcpy(mac + 12, c.nmac1, sizeof(c.nmac1));\r\ncase 2:\r\nmemcpy(mac + 6, c.nmac0, sizeof(c.nmac0));\r\n}\r\n}\r\nif (rss_size)\r\n*rss_size = FW_VI_CMD_RSSSIZE_GET(ntohs(c.rsssize_pkd));\r\nreturn FW_VI_CMD_VIID_GET(ntohs(c.type_viid));\r\n}\r\nint t4_set_rxmode(struct adapter *adap, unsigned int mbox, unsigned int viid,\r\nint mtu, int promisc, int all_multi, int bcast, int vlanex,\r\nbool sleep_ok)\r\n{\r\nstruct fw_vi_rxmode_cmd c;\r\nif (mtu < 0)\r\nmtu = FW_RXMODE_MTU_NO_CHG;\r\nif (promisc < 0)\r\npromisc = FW_VI_RXMODE_CMD_PROMISCEN_MASK;\r\nif (all_multi < 0)\r\nall_multi = FW_VI_RXMODE_CMD_ALLMULTIEN_MASK;\r\nif (bcast < 0)\r\nbcast = FW_VI_RXMODE_CMD_BROADCASTEN_MASK;\r\nif (vlanex < 0)\r\nvlanex = FW_VI_RXMODE_CMD_VLANEXEN_MASK;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_viid = htonl(FW_CMD_OP(FW_VI_RXMODE_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_WRITE | FW_VI_RXMODE_CMD_VIID(viid));\r\nc.retval_len16 = htonl(FW_LEN16(c));\r\nc.mtu_to_vlanexen = htonl(FW_VI_RXMODE_CMD_MTU(mtu) |\r\nFW_VI_RXMODE_CMD_PROMISCEN(promisc) |\r\nFW_VI_RXMODE_CMD_ALLMULTIEN(all_multi) |\r\nFW_VI_RXMODE_CMD_BROADCASTEN(bcast) |\r\nFW_VI_RXMODE_CMD_VLANEXEN(vlanex));\r\nreturn t4_wr_mbox_meat(adap, mbox, &c, sizeof(c), NULL, sleep_ok);\r\n}\r\nint t4_alloc_mac_filt(struct adapter *adap, unsigned int mbox,\r\nunsigned int viid, bool free, unsigned int naddr,\r\nconst u8 **addr, u16 *idx, u64 *hash, bool sleep_ok)\r\n{\r\nint i, ret;\r\nstruct fw_vi_mac_cmd c;\r\nstruct fw_vi_mac_exact *p;\r\nif (naddr > 7)\r\nreturn -EINVAL;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_viid = htonl(FW_CMD_OP(FW_VI_MAC_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_WRITE | (free ? FW_CMD_EXEC : 0) |\r\nFW_VI_MAC_CMD_VIID(viid));\r\nc.freemacs_to_len16 = htonl(FW_VI_MAC_CMD_FREEMACS(free) |\r\nFW_CMD_LEN16((naddr + 2) / 2));\r\nfor (i = 0, p = c.u.exact; i < naddr; i++, p++) {\r\np->valid_to_idx = htons(FW_VI_MAC_CMD_VALID |\r\nFW_VI_MAC_CMD_IDX(FW_VI_MAC_ADD_MAC));\r\nmemcpy(p->macaddr, addr[i], sizeof(p->macaddr));\r\n}\r\nret = t4_wr_mbox_meat(adap, mbox, &c, sizeof(c), &c, sleep_ok);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0, p = c.u.exact; i < naddr; i++, p++) {\r\nu16 index = FW_VI_MAC_CMD_IDX_GET(ntohs(p->valid_to_idx));\r\nif (idx)\r\nidx[i] = index >= NEXACT_MAC ? 0xffff : index;\r\nif (index < NEXACT_MAC)\r\nret++;\r\nelse if (hash)\r\n*hash |= (1ULL << hash_mac_addr(addr[i]));\r\n}\r\nreturn ret;\r\n}\r\nint t4_change_mac(struct adapter *adap, unsigned int mbox, unsigned int viid,\r\nint idx, const u8 *addr, bool persist, bool add_smt)\r\n{\r\nint ret, mode;\r\nstruct fw_vi_mac_cmd c;\r\nstruct fw_vi_mac_exact *p = c.u.exact;\r\nif (idx < 0)\r\nidx = persist ? FW_VI_MAC_ADD_PERSIST_MAC : FW_VI_MAC_ADD_MAC;\r\nmode = add_smt ? FW_VI_MAC_SMT_AND_MPSTCAM : FW_VI_MAC_MPS_TCAM_ENTRY;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_viid = htonl(FW_CMD_OP(FW_VI_MAC_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_WRITE | FW_VI_MAC_CMD_VIID(viid));\r\nc.freemacs_to_len16 = htonl(FW_CMD_LEN16(1));\r\np->valid_to_idx = htons(FW_VI_MAC_CMD_VALID |\r\nFW_VI_MAC_CMD_SMAC_RESULT(mode) |\r\nFW_VI_MAC_CMD_IDX(idx));\r\nmemcpy(p->macaddr, addr, sizeof(p->macaddr));\r\nret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);\r\nif (ret == 0) {\r\nret = FW_VI_MAC_CMD_IDX_GET(ntohs(p->valid_to_idx));\r\nif (ret >= NEXACT_MAC)\r\nret = -ENOMEM;\r\n}\r\nreturn ret;\r\n}\r\nint t4_set_addr_hash(struct adapter *adap, unsigned int mbox, unsigned int viid,\r\nbool ucast, u64 vec, bool sleep_ok)\r\n{\r\nstruct fw_vi_mac_cmd c;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_viid = htonl(FW_CMD_OP(FW_VI_MAC_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_WRITE | FW_VI_ENABLE_CMD_VIID(viid));\r\nc.freemacs_to_len16 = htonl(FW_VI_MAC_CMD_HASHVECEN |\r\nFW_VI_MAC_CMD_HASHUNIEN(ucast) |\r\nFW_CMD_LEN16(1));\r\nc.u.hash.hashvec = cpu_to_be64(vec);\r\nreturn t4_wr_mbox_meat(adap, mbox, &c, sizeof(c), NULL, sleep_ok);\r\n}\r\nint t4_enable_vi(struct adapter *adap, unsigned int mbox, unsigned int viid,\r\nbool rx_en, bool tx_en)\r\n{\r\nstruct fw_vi_enable_cmd c;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_viid = htonl(FW_CMD_OP(FW_VI_ENABLE_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_EXEC | FW_VI_ENABLE_CMD_VIID(viid));\r\nc.ien_to_len16 = htonl(FW_VI_ENABLE_CMD_IEN(rx_en) |\r\nFW_VI_ENABLE_CMD_EEN(tx_en) | FW_LEN16(c));\r\nreturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\r\n}\r\nint t4_identify_port(struct adapter *adap, unsigned int mbox, unsigned int viid,\r\nunsigned int nblinks)\r\n{\r\nstruct fw_vi_enable_cmd c;\r\nc.op_to_viid = htonl(FW_CMD_OP(FW_VI_ENABLE_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_EXEC | FW_VI_ENABLE_CMD_VIID(viid));\r\nc.ien_to_len16 = htonl(FW_VI_ENABLE_CMD_LED | FW_LEN16(c));\r\nc.blinkdur = htons(nblinks);\r\nreturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\r\n}\r\nint t4_iq_free(struct adapter *adap, unsigned int mbox, unsigned int pf,\r\nunsigned int vf, unsigned int iqtype, unsigned int iqid,\r\nunsigned int fl0id, unsigned int fl1id)\r\n{\r\nstruct fw_iq_cmd c;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_vfn = htonl(FW_CMD_OP(FW_IQ_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_EXEC | FW_IQ_CMD_PFN(pf) |\r\nFW_IQ_CMD_VFN(vf));\r\nc.alloc_to_len16 = htonl(FW_IQ_CMD_FREE | FW_LEN16(c));\r\nc.type_to_iqandstindex = htonl(FW_IQ_CMD_TYPE(iqtype));\r\nc.iqid = htons(iqid);\r\nc.fl0id = htons(fl0id);\r\nc.fl1id = htons(fl1id);\r\nreturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\r\n}\r\nint t4_eth_eq_free(struct adapter *adap, unsigned int mbox, unsigned int pf,\r\nunsigned int vf, unsigned int eqid)\r\n{\r\nstruct fw_eq_eth_cmd c;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_vfn = htonl(FW_CMD_OP(FW_EQ_ETH_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_EXEC | FW_EQ_ETH_CMD_PFN(pf) |\r\nFW_EQ_ETH_CMD_VFN(vf));\r\nc.alloc_to_len16 = htonl(FW_EQ_ETH_CMD_FREE | FW_LEN16(c));\r\nc.eqid_pkd = htonl(FW_EQ_ETH_CMD_EQID(eqid));\r\nreturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\r\n}\r\nint t4_ctrl_eq_free(struct adapter *adap, unsigned int mbox, unsigned int pf,\r\nunsigned int vf, unsigned int eqid)\r\n{\r\nstruct fw_eq_ctrl_cmd c;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_vfn = htonl(FW_CMD_OP(FW_EQ_CTRL_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_EXEC | FW_EQ_CTRL_CMD_PFN(pf) |\r\nFW_EQ_CTRL_CMD_VFN(vf));\r\nc.alloc_to_len16 = htonl(FW_EQ_CTRL_CMD_FREE | FW_LEN16(c));\r\nc.cmpliqid_eqid = htonl(FW_EQ_CTRL_CMD_EQID(eqid));\r\nreturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\r\n}\r\nint t4_ofld_eq_free(struct adapter *adap, unsigned int mbox, unsigned int pf,\r\nunsigned int vf, unsigned int eqid)\r\n{\r\nstruct fw_eq_ofld_cmd c;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_vfn = htonl(FW_CMD_OP(FW_EQ_OFLD_CMD) | FW_CMD_REQUEST |\r\nFW_CMD_EXEC | FW_EQ_OFLD_CMD_PFN(pf) |\r\nFW_EQ_OFLD_CMD_VFN(vf));\r\nc.alloc_to_len16 = htonl(FW_EQ_OFLD_CMD_FREE | FW_LEN16(c));\r\nc.eqid_pkd = htonl(FW_EQ_OFLD_CMD_EQID(eqid));\r\nreturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\r\n}\r\nint t4_handle_fw_rpl(struct adapter *adap, const __be64 *rpl)\r\n{\r\nu8 opcode = *(const u8 *)rpl;\r\nif (opcode == FW_PORT_CMD) {\r\nint speed = 0, fc = 0;\r\nconst struct fw_port_cmd *p = (void *)rpl;\r\nint chan = FW_PORT_CMD_PORTID_GET(ntohl(p->op_to_portid));\r\nint port = adap->chan_map[chan];\r\nstruct port_info *pi = adap2pinfo(adap, port);\r\nstruct link_config *lc = &pi->link_cfg;\r\nu32 stat = ntohl(p->u.info.lstatus_to_modtype);\r\nint link_ok = (stat & FW_PORT_CMD_LSTATUS) != 0;\r\nu32 mod = FW_PORT_CMD_MODTYPE_GET(stat);\r\nif (stat & FW_PORT_CMD_RXPAUSE)\r\nfc |= PAUSE_RX;\r\nif (stat & FW_PORT_CMD_TXPAUSE)\r\nfc |= PAUSE_TX;\r\nif (stat & FW_PORT_CMD_LSPEED(FW_PORT_CAP_SPEED_100M))\r\nspeed = SPEED_100;\r\nelse if (stat & FW_PORT_CMD_LSPEED(FW_PORT_CAP_SPEED_1G))\r\nspeed = SPEED_1000;\r\nelse if (stat & FW_PORT_CMD_LSPEED(FW_PORT_CAP_SPEED_10G))\r\nspeed = SPEED_10000;\r\nif (link_ok != lc->link_ok || speed != lc->speed ||\r\nfc != lc->fc) {\r\nlc->link_ok = link_ok;\r\nlc->speed = speed;\r\nlc->fc = fc;\r\nt4_os_link_changed(adap, port, link_ok);\r\n}\r\nif (mod != pi->mod_type) {\r\npi->mod_type = mod;\r\nt4_os_portmod_changed(adap, port);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void __devinit get_pci_mode(struct adapter *adapter,\r\nstruct pci_params *p)\r\n{\r\nu16 val;\r\nu32 pcie_cap = pci_pcie_cap(adapter->pdev);\r\nif (pcie_cap) {\r\npci_read_config_word(adapter->pdev, pcie_cap + PCI_EXP_LNKSTA,\r\n&val);\r\np->speed = val & PCI_EXP_LNKSTA_CLS;\r\np->width = (val & PCI_EXP_LNKSTA_NLW) >> 4;\r\n}\r\n}\r\nstatic void __devinit init_link_config(struct link_config *lc,\r\nunsigned int caps)\r\n{\r\nlc->supported = caps;\r\nlc->requested_speed = 0;\r\nlc->speed = 0;\r\nlc->requested_fc = lc->fc = PAUSE_RX | PAUSE_TX;\r\nif (lc->supported & FW_PORT_CAP_ANEG) {\r\nlc->advertising = lc->supported & ADVERT_MASK;\r\nlc->autoneg = AUTONEG_ENABLE;\r\nlc->requested_fc |= PAUSE_AUTONEG;\r\n} else {\r\nlc->advertising = 0;\r\nlc->autoneg = AUTONEG_DISABLE;\r\n}\r\n}\r\nint t4_wait_dev_ready(struct adapter *adap)\r\n{\r\nif (t4_read_reg(adap, PL_WHOAMI) != 0xffffffff)\r\nreturn 0;\r\nmsleep(500);\r\nreturn t4_read_reg(adap, PL_WHOAMI) != 0xffffffff ? 0 : -EIO;\r\n}\r\nstatic int __devinit get_flash_params(struct adapter *adap)\r\n{\r\nint ret;\r\nu32 info;\r\nret = sf1_write(adap, 1, 1, 0, SF_RD_ID);\r\nif (!ret)\r\nret = sf1_read(adap, 3, 0, 1, &info);\r\nt4_write_reg(adap, SF_OP, 0);\r\nif (ret)\r\nreturn ret;\r\nif ((info & 0xff) != 0x20)\r\nreturn -EINVAL;\r\ninfo >>= 16;\r\nif (info >= 0x14 && info < 0x18)\r\nadap->params.sf_nsec = 1 << (info - 16);\r\nelse if (info == 0x18)\r\nadap->params.sf_nsec = 64;\r\nelse\r\nreturn -EINVAL;\r\nadap->params.sf_size = 1 << info;\r\nadap->params.sf_fw_start =\r\nt4_read_reg(adap, CIM_BOOT_CFG) & BOOTADDR_MASK;\r\nreturn 0;\r\n}\r\nint __devinit t4_prep_adapter(struct adapter *adapter)\r\n{\r\nint ret;\r\nret = t4_wait_dev_ready(adapter);\r\nif (ret < 0)\r\nreturn ret;\r\nget_pci_mode(adapter, &adapter->params.pci);\r\nadapter->params.rev = t4_read_reg(adapter, PL_REV);\r\nret = get_flash_params(adapter);\r\nif (ret < 0) {\r\ndev_err(adapter->pdev_dev, "error %d identifying flash\n", ret);\r\nreturn ret;\r\n}\r\nret = get_vpd_params(adapter, &adapter->params.vpd);\r\nif (ret < 0)\r\nreturn ret;\r\ninit_cong_ctrl(adapter->params.a_wnd, adapter->params.b_wnd);\r\nadapter->params.nports = 1;\r\nadapter->params.portvec = 1;\r\nreturn 0;\r\n}\r\nint __devinit t4_port_init(struct adapter *adap, int mbox, int pf, int vf)\r\n{\r\nu8 addr[6];\r\nint ret, i, j = 0;\r\nstruct fw_port_cmd c;\r\nstruct fw_rss_vi_config_cmd rvc;\r\nmemset(&c, 0, sizeof(c));\r\nmemset(&rvc, 0, sizeof(rvc));\r\nfor_each_port(adap, i) {\r\nunsigned int rss_size;\r\nstruct port_info *p = adap2pinfo(adap, i);\r\nwhile ((adap->params.portvec & (1 << j)) == 0)\r\nj++;\r\nc.op_to_portid = htonl(FW_CMD_OP(FW_PORT_CMD) |\r\nFW_CMD_REQUEST | FW_CMD_READ |\r\nFW_PORT_CMD_PORTID(j));\r\nc.action_to_len16 = htonl(\r\nFW_PORT_CMD_ACTION(FW_PORT_ACTION_GET_PORT_INFO) |\r\nFW_LEN16(c));\r\nret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);\r\nif (ret)\r\nreturn ret;\r\nret = t4_alloc_vi(adap, mbox, j, pf, vf, 1, addr, &rss_size);\r\nif (ret < 0)\r\nreturn ret;\r\np->viid = ret;\r\np->tx_chan = j;\r\np->lport = j;\r\np->rss_size = rss_size;\r\nmemcpy(adap->port[i]->dev_addr, addr, ETH_ALEN);\r\nmemcpy(adap->port[i]->perm_addr, addr, ETH_ALEN);\r\nadap->port[i]->dev_id = j;\r\nret = ntohl(c.u.info.lstatus_to_modtype);\r\np->mdio_addr = (ret & FW_PORT_CMD_MDIOCAP) ?\r\nFW_PORT_CMD_MDIOADDR_GET(ret) : -1;\r\np->port_type = FW_PORT_CMD_PTYPE_GET(ret);\r\np->mod_type = FW_PORT_MOD_TYPE_NA;\r\nrvc.op_to_viid = htonl(FW_CMD_OP(FW_RSS_VI_CONFIG_CMD) |\r\nFW_CMD_REQUEST | FW_CMD_READ |\r\nFW_RSS_VI_CONFIG_CMD_VIID(p->viid));\r\nrvc.retval_len16 = htonl(FW_LEN16(rvc));\r\nret = t4_wr_mbox(adap, mbox, &rvc, sizeof(rvc), &rvc);\r\nif (ret)\r\nreturn ret;\r\np->rss_mode = ntohl(rvc.u.basicvirtual.defaultq_to_udpen);\r\ninit_link_config(&p->link_cfg, ntohs(c.u.info.pcap));\r\nj++;\r\n}\r\nreturn 0;\r\n}
