static inline int ieee80211_networks_allocate(struct ieee80211_device *ieee)\r\n{\r\nif (ieee->networks)\r\nreturn 0;\r\nieee->networks = kcalloc(\r\nMAX_NETWORK_COUNT, sizeof(struct ieee80211_network),\r\nGFP_KERNEL);\r\nif (!ieee->networks) {\r\nprintk(KERN_WARNING "%s: Out of memory allocating beacons\n",\r\nieee->dev->name);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void ieee80211_networks_free(struct ieee80211_device *ieee)\r\n{\r\nif (!ieee->networks)\r\nreturn;\r\nkfree(ieee->networks);\r\nieee->networks = NULL;\r\n}\r\nstatic inline void ieee80211_networks_initialize(struct ieee80211_device *ieee)\r\n{\r\nint i;\r\nINIT_LIST_HEAD(&ieee->network_free_list);\r\nINIT_LIST_HEAD(&ieee->network_list);\r\nfor (i = 0; i < MAX_NETWORK_COUNT; i++)\r\nlist_add_tail(&ieee->networks[i].list, &ieee->network_free_list);\r\n}\r\nstruct net_device *alloc_ieee80211(int sizeof_priv)\r\n{\r\nstruct ieee80211_device *ieee;\r\nstruct net_device *dev;\r\nint i,err;\r\nIEEE80211_DEBUG_INFO("Initializing...\n");\r\ndev = alloc_etherdev(sizeof(struct ieee80211_device) + sizeof_priv);\r\nif (!dev) {\r\nIEEE80211_ERROR("Unable to network device.\n");\r\ngoto failed;\r\n}\r\nieee = netdev_priv(dev);\r\nieee->dev = dev;\r\nerr = ieee80211_networks_allocate(ieee);\r\nif (err) {\r\nIEEE80211_ERROR("Unable to allocate beacon storage: %d\n",\r\nerr);\r\ngoto failed;\r\n}\r\nieee80211_networks_initialize(ieee);\r\nieee->fts = DEFAULT_FTS;\r\nieee->scan_age = DEFAULT_MAX_SCAN_AGE;\r\nieee->open_wep = 1;\r\nieee->host_encrypt = 1;\r\nieee->host_decrypt = 1;\r\nieee->ieee802_1x = 1;\r\nINIT_LIST_HEAD(&ieee->crypt_deinit_list);\r\ninit_timer(&ieee->crypt_deinit_timer);\r\nieee->crypt_deinit_timer.data = (unsigned long)ieee;\r\nieee->crypt_deinit_timer.function = ieee80211_crypt_deinit_handler;\r\nspin_lock_init(&ieee->lock);\r\nspin_lock_init(&ieee->wpax_suitlist_lock);\r\nieee->wpax_type_set = 0;\r\nieee->wpa_enabled = 0;\r\nieee->tkip_countermeasures = 0;\r\nieee->drop_unencrypted = 0;\r\nieee->privacy_invoked = 0;\r\nieee->ieee802_1x = 1;\r\nieee->raw_tx = 0;\r\nieee80211_softmac_init(ieee);\r\nfor (i = 0; i < IEEE_IBSS_MAC_HASH_SIZE; i++)\r\nINIT_LIST_HEAD(&ieee->ibss_mac_hash[i]);\r\nfor (i = 0; i < 17; i++) {\r\nieee->last_rxseq_num[i] = -1;\r\nieee->last_rxfrag_num[i] = -1;\r\nieee->last_packet_time[i] = 0;\r\n}\r\nieee80211_tkip_null();\r\nieee80211_wep_null();\r\nieee80211_ccmp_null();\r\nreturn dev;\r\nfailed:\r\nif (dev)\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\nvoid free_ieee80211(struct net_device *dev)\r\n{\r\nstruct ieee80211_device *ieee = netdev_priv(dev);\r\nint i;\r\nstruct list_head *p, *q;\r\nieee80211_softmac_free(ieee);\r\ndel_timer_sync(&ieee->crypt_deinit_timer);\r\nieee80211_crypt_deinit_entries(ieee, 1);\r\nfor (i = 0; i < WEP_KEYS; i++) {\r\nstruct ieee80211_crypt_data *crypt = ieee->crypt[i];\r\nif (crypt) {\r\nif (crypt->ops)\r\ncrypt->ops->deinit(crypt->priv);\r\nkfree(crypt);\r\nieee->crypt[i] = NULL;\r\n}\r\n}\r\nieee80211_networks_free(ieee);\r\nfor (i = 0; i < IEEE_IBSS_MAC_HASH_SIZE; i++) {\r\nlist_for_each_safe(p, q, &ieee->ibss_mac_hash[i]) {\r\nkfree(list_entry(p, struct ieee_ibss_seq, list));\r\nlist_del(p);\r\n}\r\n}\r\nfree_netdev(dev);\r\n}
