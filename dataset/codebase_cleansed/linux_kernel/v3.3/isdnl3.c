int\r\nnewcallref(void)\r\n{\r\nif (OrigCallRef == 127)\r\nOrigCallRef = 1;\r\nelse\r\nOrigCallRef++;\r\nreturn (OrigCallRef);\r\n}\r\nvoid\r\nnewl3state(struct l3_process *pc, int state)\r\n{\r\nif (pc->debug & L3_DEB_STATE)\r\nl3_debug(pc->st, "newstate cr %d %d --> %d",\r\npc->callref & 0x7F,\r\npc->state, state);\r\npc->state = state;\r\n}\r\nstatic void\r\nL3ExpireTimer(struct L3Timer *t)\r\n{\r\nt->pc->st->lli.l4l3(t->pc->st, t->event, t->pc);\r\n}\r\nvoid\r\nL3InitTimer(struct l3_process *pc, struct L3Timer *t)\r\n{\r\nt->pc = pc;\r\nt->tl.function = (void *) L3ExpireTimer;\r\nt->tl.data = (long) t;\r\ninit_timer(&t->tl);\r\n}\r\nvoid\r\nL3DelTimer(struct L3Timer *t)\r\n{\r\ndel_timer(&t->tl);\r\n}\r\nint\r\nL3AddTimer(struct L3Timer *t,\r\nint millisec, int event)\r\n{\r\nif (timer_pending(&t->tl)) {\r\nprintk(KERN_WARNING "L3AddTimer: timer already active!\n");\r\nreturn -1;\r\n}\r\ninit_timer(&t->tl);\r\nt->event = event;\r\nt->tl.expires = jiffies + (millisec * HZ) / 1000;\r\nadd_timer(&t->tl);\r\nreturn 0;\r\n}\r\nvoid\r\nStopAllL3Timer(struct l3_process *pc)\r\n{\r\nL3DelTimer(&pc->timer);\r\n}\r\nstruct sk_buff *\r\nl3_alloc_skb(int len)\r\n{\r\nstruct sk_buff *skb;\r\nif (!(skb = alloc_skb(len + MAX_HEADER_LEN, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING "HiSax: No skb for D-channel\n");\r\nreturn (NULL);\r\n}\r\nskb_reserve(skb, MAX_HEADER_LEN);\r\nreturn (skb);\r\n}\r\nstatic void\r\nno_l3_proto(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nHiSax_putstatus(st->l1.hardware, "L3", "no D protocol");\r\nif (skb) {\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\nstatic int\r\nno_l3_proto_spec(struct PStack *st, isdn_ctrl *ic)\r\n{\r\nprintk(KERN_WARNING "HiSax: no specific protocol handler for proto %lu\n",ic->arg & 0xFF);\r\nreturn(-1);\r\n}\r\nstruct l3_process\r\n*getl3proc(struct PStack *st, int cr)\r\n{\r\nstruct l3_process *p = st->l3.proc;\r\nwhile (p)\r\nif (p->callref == cr)\r\nreturn (p);\r\nelse\r\np = p->next;\r\nreturn (NULL);\r\n}\r\nstruct l3_process\r\n*new_l3_process(struct PStack *st, int cr)\r\n{\r\nstruct l3_process *p, *np;\r\nif (!(p = kmalloc(sizeof(struct l3_process), GFP_ATOMIC))) {\r\nprintk(KERN_ERR "HiSax can't get memory for cr %d\n", cr);\r\nreturn (NULL);\r\n}\r\nif (!st->l3.proc)\r\nst->l3.proc = p;\r\nelse {\r\nnp = st->l3.proc;\r\nwhile (np->next)\r\nnp = np->next;\r\nnp->next = p;\r\n}\r\np->next = NULL;\r\np->debug = st->l3.debug;\r\np->callref = cr;\r\np->state = 0;\r\np->chan = NULL;\r\np->st = st;\r\np->N303 = st->l3.N303;\r\nL3InitTimer(p, &p->timer);\r\nreturn (p);\r\n}\r\nvoid\r\nrelease_l3_process(struct l3_process *p)\r\n{\r\nstruct l3_process *np, *pp = NULL;\r\nif (!p)\r\nreturn;\r\nnp = p->st->l3.proc;\r\nwhile (np) {\r\nif (np == p) {\r\nStopAllL3Timer(p);\r\nif (pp)\r\npp->next = np->next;\r\nelse if (!(p->st->l3.proc = np->next) &&\r\n!test_bit(FLG_PTP, &p->st->l2.flag)) {\r\nif (p->debug)\r\nl3_debug(p->st, "release_l3_process: last process");\r\nif (skb_queue_empty(&p->st->l3.squeue)) {\r\nif (p->debug)\r\nl3_debug(p->st, "release_l3_process: release link");\r\nif (p->st->protocol != ISDN_PTYPE_NI1)\r\nFsmEvent(&p->st->l3.l3m, EV_RELEASE_REQ, NULL);\r\nelse\r\nFsmEvent(&p->st->l3.l3m, EV_RELEASE_IND, NULL);\r\n} else {\r\nif (p->debug)\r\nl3_debug(p->st, "release_l3_process: not release link");\r\n}\r\n}\r\nkfree(p);\r\nreturn;\r\n}\r\npp = np;\r\nnp = np->next;\r\n}\r\nprintk(KERN_ERR "HiSax internal L3 error CR(%d) not in list\n", p->callref);\r\nl3_debug(p->st, "HiSax internal L3 error CR(%d) not in list", p->callref);\r\n}\r\nstatic void\r\nl3ml3p(struct PStack *st, int pr)\r\n{\r\nstruct l3_process *p = st->l3.proc;\r\nstruct l3_process *np;\r\nwhile (p) {\r\nnp = p->next;\r\nst->l3.l3ml3(st, pr, p);\r\np = np;\r\n}\r\n}\r\nvoid\r\nsetstack_l3dc(struct PStack *st, struct Channel *chanp)\r\n{\r\nchar tmp[64];\r\nst->l3.proc = NULL;\r\nst->l3.global = NULL;\r\nskb_queue_head_init(&st->l3.squeue);\r\nst->l3.l3m.fsm = &l3fsm;\r\nst->l3.l3m.state = ST_L3_LC_REL;\r\nst->l3.l3m.debug = 1;\r\nst->l3.l3m.userdata = st;\r\nst->l3.l3m.userint = 0;\r\nst->l3.l3m.printdebug = l3m_debug;\r\nFsmInitTimer(&st->l3.l3m, &st->l3.l3m_timer);\r\nstrcpy(st->l3.debug_id, "L3DC ");\r\nst->lli.l4l3_proto = no_l3_proto_spec;\r\n#ifdef CONFIG_HISAX_EURO\r\nif (st->protocol == ISDN_PTYPE_EURO) {\r\nsetstack_dss1(st);\r\n} else\r\n#endif\r\n#ifdef CONFIG_HISAX_NI1\r\nif (st->protocol == ISDN_PTYPE_NI1) {\r\nsetstack_ni1(st);\r\n} else\r\n#endif\r\n#ifdef CONFIG_HISAX_1TR6\r\nif (st->protocol == ISDN_PTYPE_1TR6) {\r\nsetstack_1tr6(st);\r\n} else\r\n#endif\r\nif (st->protocol == ISDN_PTYPE_LEASED) {\r\nst->lli.l4l3 = no_l3_proto;\r\nst->l2.l2l3 = no_l3_proto;\r\nst->l3.l3ml3 = no_l3_proto;\r\nprintk(KERN_INFO "HiSax: Leased line mode\n");\r\n} else {\r\nst->lli.l4l3 = no_l3_proto;\r\nst->l2.l2l3 = no_l3_proto;\r\nst->l3.l3ml3 = no_l3_proto;\r\nsprintf(tmp, "protocol %s not supported",\r\n(st->protocol == ISDN_PTYPE_1TR6) ? "1tr6" :\r\n(st->protocol == ISDN_PTYPE_EURO) ? "euro" :\r\n(st->protocol == ISDN_PTYPE_NI1) ? "ni1" :\r\n"unknown");\r\nprintk(KERN_WARNING "HiSax: %s\n", tmp);\r\nst->protocol = -1;\r\n}\r\n}\r\nstatic void\r\nisdnl3_trans(struct PStack *st, int pr, void *arg) {\r\nst->l3.l3l2(st, pr, arg);\r\n}\r\nvoid\r\nreleasestack_isdnl3(struct PStack *st)\r\n{\r\nwhile (st->l3.proc)\r\nrelease_l3_process(st->l3.proc);\r\nif (st->l3.global) {\r\nStopAllL3Timer(st->l3.global);\r\nkfree(st->l3.global);\r\nst->l3.global = NULL;\r\n}\r\nFsmDelTimer(&st->l3.l3m_timer, 54);\r\nskb_queue_purge(&st->l3.squeue);\r\n}\r\nvoid\r\nsetstack_l3bc(struct PStack *st, struct Channel *chanp)\r\n{\r\nst->l3.proc = NULL;\r\nst->l3.global = NULL;\r\nskb_queue_head_init(&st->l3.squeue);\r\nst->l3.l3m.fsm = &l3fsm;\r\nst->l3.l3m.state = ST_L3_LC_REL;\r\nst->l3.l3m.debug = 1;\r\nst->l3.l3m.userdata = st;\r\nst->l3.l3m.userint = 0;\r\nst->l3.l3m.printdebug = l3m_debug;\r\nstrcpy(st->l3.debug_id, "L3BC ");\r\nst->lli.l4l3 = isdnl3_trans;\r\n}\r\nstatic void\r\nlc_activate(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nFsmChangeState(fi, ST_L3_LC_ESTAB_WAIT);\r\nst->l3.l3l2(st, DL_ESTABLISH | REQUEST, NULL);\r\n}\r\nstatic void\r\nlc_connect(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nint dequeued = 0;\r\nFsmChangeState(fi, ST_L3_LC_ESTAB);\r\nwhile ((skb = skb_dequeue(&st->l3.squeue))) {\r\nst->l3.l3l2(st, DL_DATA | REQUEST, skb);\r\ndequeued++;\r\n}\r\nif ((!st->l3.proc) && dequeued) {\r\nif (st->l3.debug)\r\nl3_debug(st, "lc_connect: release link");\r\nFsmEvent(&st->l3.l3m, EV_RELEASE_REQ, NULL);\r\n} else\r\nl3ml3p(st, DL_ESTABLISH | INDICATION);\r\n}\r\nstatic void\r\nlc_connected(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nint dequeued = 0;\r\nFsmDelTimer(&st->l3.l3m_timer, 51);\r\nFsmChangeState(fi, ST_L3_LC_ESTAB);\r\nwhile ((skb = skb_dequeue(&st->l3.squeue))) {\r\nst->l3.l3l2(st, DL_DATA | REQUEST, skb);\r\ndequeued++;\r\n}\r\nif ((!st->l3.proc) && dequeued) {\r\nif (st->l3.debug)\r\nl3_debug(st, "lc_connected: release link");\r\nFsmEvent(&st->l3.l3m, EV_RELEASE_REQ, NULL);\r\n} else\r\nl3ml3p(st, DL_ESTABLISH | CONFIRM);\r\n}\r\nstatic void\r\nlc_start_delay(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nFsmChangeState(fi, ST_L3_LC_REL_DELAY);\r\nFsmAddTimer(&st->l3.l3m_timer, DREL_TIMER_VALUE, EV_TIMEOUT, NULL, 50);\r\n}\r\nstatic void\r\nlc_start_delay_check(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nFsmChangeState(fi, ST_L3_LC_REL_DELAY);\r\nif (st->protocol != ISDN_PTYPE_NI1)\r\nFsmAddTimer(&st->l3.l3m_timer, DREL_TIMER_VALUE, EV_TIMEOUT, NULL, 50);\r\n}\r\nstatic void\r\nlc_release_req(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nif (test_bit(FLG_L2BLOCK, &st->l2.flag)) {\r\nif (st->l3.debug)\r\nl3_debug(st, "lc_release_req: l2 blocked");\r\nFsmAddTimer(&st->l3.l3m_timer, DREL_TIMER_VALUE, EV_TIMEOUT, NULL, 51);\r\n} else {\r\nFsmChangeState(fi, ST_L3_LC_REL_WAIT);\r\nst->l3.l3l2(st, DL_RELEASE | REQUEST, NULL);\r\n}\r\n}\r\nstatic void\r\nlc_release_ind(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nFsmDelTimer(&st->l3.l3m_timer, 52);\r\nFsmChangeState(fi, ST_L3_LC_REL);\r\nskb_queue_purge(&st->l3.squeue);\r\nl3ml3p(st, DL_RELEASE | INDICATION);\r\n}\r\nstatic void\r\nlc_release_cnf(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nFsmChangeState(fi, ST_L3_LC_REL);\r\nskb_queue_purge(&st->l3.squeue);\r\nl3ml3p(st, DL_RELEASE | CONFIRM);\r\n}\r\nvoid\r\nl3_msg(struct PStack *st, int pr, void *arg)\r\n{\r\nswitch (pr) {\r\ncase (DL_DATA | REQUEST):\r\nif (st->l3.l3m.state == ST_L3_LC_ESTAB) {\r\nst->l3.l3l2(st, pr, arg);\r\n} else {\r\nstruct sk_buff *skb = arg;\r\nskb_queue_tail(&st->l3.squeue, skb);\r\nFsmEvent(&st->l3.l3m, EV_ESTABLISH_REQ, NULL);\r\n}\r\nbreak;\r\ncase (DL_ESTABLISH | REQUEST):\r\nFsmEvent(&st->l3.l3m, EV_ESTABLISH_REQ, NULL);\r\nbreak;\r\ncase (DL_ESTABLISH | CONFIRM):\r\nFsmEvent(&st->l3.l3m, EV_ESTABLISH_CNF, NULL);\r\nbreak;\r\ncase (DL_ESTABLISH | INDICATION):\r\nFsmEvent(&st->l3.l3m, EV_ESTABLISH_IND, NULL);\r\nbreak;\r\ncase (DL_RELEASE | INDICATION):\r\nFsmEvent(&st->l3.l3m, EV_RELEASE_IND, NULL);\r\nbreak;\r\ncase (DL_RELEASE | CONFIRM):\r\nFsmEvent(&st->l3.l3m, EV_RELEASE_CNF, NULL);\r\nbreak;\r\ncase (DL_RELEASE | REQUEST):\r\nFsmEvent(&st->l3.l3m, EV_RELEASE_REQ, NULL);\r\nbreak;\r\n}\r\n}\r\nint __init\r\nIsdnl3New(void)\r\n{\r\nl3fsm.state_count = L3_STATE_COUNT;\r\nl3fsm.event_count = L3_EVENT_COUNT;\r\nl3fsm.strEvent = strL3Event;\r\nl3fsm.strState = strL3State;\r\nreturn FsmNew(&l3fsm, L3FnList, ARRAY_SIZE(L3FnList));\r\n}\r\nvoid\r\nIsdnl3Free(void)\r\n{\r\nFsmFree(&l3fsm);\r\n}
