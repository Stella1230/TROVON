static enum xp_retval\r\nxp_register_nofault_code_sn2(void)\r\n{\r\nint ret;\r\nu64 func_addr;\r\nu64 err_func_addr;\r\nfunc_addr = *(u64 *)xp_nofault_PIOR;\r\nerr_func_addr = *(u64 *)xp_error_PIOR;\r\nret = sn_register_nofault_code(func_addr, err_func_addr, err_func_addr,\r\n1, 1);\r\nif (ret != 0) {\r\ndev_err(xp, "can't register nofault code, error=%d\n", ret);\r\nreturn xpSalError;\r\n}\r\nif (is_shub1())\r\nxp_nofault_PIOR_target = SH1_IPI_ACCESS;\r\nelse if (is_shub2())\r\nxp_nofault_PIOR_target = SH2_IPI_ACCESS0;\r\nreturn xpSuccess;\r\n}\r\nstatic void\r\nxp_unregister_nofault_code_sn2(void)\r\n{\r\nu64 func_addr = *(u64 *)xp_nofault_PIOR;\r\nu64 err_func_addr = *(u64 *)xp_error_PIOR;\r\n(void)sn_register_nofault_code(func_addr, err_func_addr,\r\nerr_func_addr, 1, 0);\r\n}\r\nstatic unsigned long\r\nxp_pa_sn2(void *addr)\r\n{\r\nreturn __pa(addr);\r\n}\r\nstatic unsigned long\r\nxp_socket_pa_sn2(unsigned long gpa)\r\n{\r\nreturn gpa;\r\n}\r\nstatic enum xp_retval\r\nxp_remote_memcpy_sn2(unsigned long dst_pa, const unsigned long src_pa,\r\nsize_t len)\r\n{\r\nbte_result_t ret;\r\nret = bte_copy(src_pa, dst_pa, len, (BTE_NOTIFY | BTE_WACQUIRE), NULL);\r\nif (ret == BTE_SUCCESS)\r\nreturn xpSuccess;\r\nif (is_shub2()) {\r\ndev_err(xp, "bte_copy() on shub2 failed, error=0x%x dst_pa="\r\n"0x%016lx src_pa=0x%016lx len=%ld\\n", ret, dst_pa,\r\nsrc_pa, len);\r\n} else {\r\ndev_err(xp, "bte_copy() failed, error=%d dst_pa=0x%016lx "\r\n"src_pa=0x%016lx len=%ld\\n", ret, dst_pa, src_pa, len);\r\n}\r\nreturn xpBteCopyError;\r\n}\r\nstatic int\r\nxp_cpu_to_nasid_sn2(int cpuid)\r\n{\r\nreturn cpuid_to_nasid(cpuid);\r\n}\r\nstatic enum xp_retval\r\nxp_expand_memprotect_sn2(unsigned long phys_addr, unsigned long size)\r\n{\r\nu64 nasid_array = 0;\r\nint ret;\r\nret = sn_change_memprotect(phys_addr, size, SN_MEMPROT_ACCESS_CLASS_1,\r\n&nasid_array);\r\nif (ret != 0) {\r\ndev_err(xp, "sn_change_memprotect(,, "\r\n"SN_MEMPROT_ACCESS_CLASS_1,) failed ret=%d\n", ret);\r\nreturn xpSalError;\r\n}\r\nreturn xpSuccess;\r\n}\r\nstatic enum xp_retval\r\nxp_restrict_memprotect_sn2(unsigned long phys_addr, unsigned long size)\r\n{\r\nu64 nasid_array = 0;\r\nint ret;\r\nret = sn_change_memprotect(phys_addr, size, SN_MEMPROT_ACCESS_CLASS_0,\r\n&nasid_array);\r\nif (ret != 0) {\r\ndev_err(xp, "sn_change_memprotect(,, "\r\n"SN_MEMPROT_ACCESS_CLASS_0,) failed ret=%d\n", ret);\r\nreturn xpSalError;\r\n}\r\nreturn xpSuccess;\r\n}\r\nenum xp_retval\r\nxp_init_sn2(void)\r\n{\r\nBUG_ON(!is_shub());\r\nxp_max_npartitions = XP_MAX_NPARTITIONS_SN2;\r\nxp_partition_id = sn_partition_id;\r\nxp_region_size = sn_region_size;\r\nxp_pa = xp_pa_sn2;\r\nxp_socket_pa = xp_socket_pa_sn2;\r\nxp_remote_memcpy = xp_remote_memcpy_sn2;\r\nxp_cpu_to_nasid = xp_cpu_to_nasid_sn2;\r\nxp_expand_memprotect = xp_expand_memprotect_sn2;\r\nxp_restrict_memprotect = xp_restrict_memprotect_sn2;\r\nreturn xp_register_nofault_code_sn2();\r\n}\r\nvoid\r\nxp_exit_sn2(void)\r\n{\r\nBUG_ON(!is_shub());\r\nxp_unregister_nofault_code_sn2();\r\n}
