static void dump_packet(struct sbuff *m,\r\nconst struct nf_loginfo *info,\r\nconst struct sk_buff *skb, unsigned int ip6hoff,\r\nint recurse)\r\n{\r\nu_int8_t currenthdr;\r\nint fragment;\r\nstruct ipv6hdr _ip6h;\r\nconst struct ipv6hdr *ih;\r\nunsigned int ptr;\r\nunsigned int hdrlen = 0;\r\nunsigned int logflags;\r\nif (info->type == NF_LOG_TYPE_LOG)\r\nlogflags = info->u.log.logflags;\r\nelse\r\nlogflags = NF_LOG_MASK;\r\nih = skb_header_pointer(skb, ip6hoff, sizeof(_ip6h), &_ip6h);\r\nif (ih == NULL) {\r\nsb_add(m, "TRUNCATED");\r\nreturn;\r\n}\r\nsb_add(m, "SRC=%pI6 DST=%pI6 ", &ih->saddr, &ih->daddr);\r\nsb_add(m, "LEN=%Zu TC=%u HOPLIMIT=%u FLOWLBL=%u ",\r\nntohs(ih->payload_len) + sizeof(struct ipv6hdr),\r\n(ntohl(*(__be32 *)ih) & 0x0ff00000) >> 20,\r\nih->hop_limit,\r\n(ntohl(*(__be32 *)ih) & 0x000fffff));\r\nfragment = 0;\r\nptr = ip6hoff + sizeof(struct ipv6hdr);\r\ncurrenthdr = ih->nexthdr;\r\nwhile (currenthdr != NEXTHDR_NONE && ip6t_ext_hdr(currenthdr)) {\r\nstruct ipv6_opt_hdr _hdr;\r\nconst struct ipv6_opt_hdr *hp;\r\nhp = skb_header_pointer(skb, ptr, sizeof(_hdr), &_hdr);\r\nif (hp == NULL) {\r\nsb_add(m, "TRUNCATED");\r\nreturn;\r\n}\r\nif (logflags & IP6T_LOG_IPOPT)\r\nsb_add(m, "OPT ( ");\r\nswitch (currenthdr) {\r\ncase IPPROTO_FRAGMENT: {\r\nstruct frag_hdr _fhdr;\r\nconst struct frag_hdr *fh;\r\nsb_add(m, "FRAG:");\r\nfh = skb_header_pointer(skb, ptr, sizeof(_fhdr),\r\n&_fhdr);\r\nif (fh == NULL) {\r\nsb_add(m, "TRUNCATED ");\r\nreturn;\r\n}\r\nsb_add(m, "%u ", ntohs(fh->frag_off) & 0xFFF8);\r\nif (fh->frag_off & htons(0x0001))\r\nsb_add(m, "INCOMPLETE ");\r\nsb_add(m, "ID:%08x ", ntohl(fh->identification));\r\nif (ntohs(fh->frag_off) & 0xFFF8)\r\nfragment = 1;\r\nhdrlen = 8;\r\nbreak;\r\n}\r\ncase IPPROTO_DSTOPTS:\r\ncase IPPROTO_ROUTING:\r\ncase IPPROTO_HOPOPTS:\r\nif (fragment) {\r\nif (logflags & IP6T_LOG_IPOPT)\r\nsb_add(m, ")");\r\nreturn;\r\n}\r\nhdrlen = ipv6_optlen(hp);\r\nbreak;\r\ncase IPPROTO_AH:\r\nif (logflags & IP6T_LOG_IPOPT) {\r\nstruct ip_auth_hdr _ahdr;\r\nconst struct ip_auth_hdr *ah;\r\nsb_add(m, "AH ");\r\nif (fragment) {\r\nsb_add(m, ")");\r\nreturn;\r\n}\r\nah = skb_header_pointer(skb, ptr, sizeof(_ahdr),\r\n&_ahdr);\r\nif (ah == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] )",\r\nskb->len - ptr);\r\nreturn;\r\n}\r\nsb_add(m, "SPI=0x%x ", ntohl(ah->spi));\r\n}\r\nhdrlen = (hp->hdrlen+2)<<2;\r\nbreak;\r\ncase IPPROTO_ESP:\r\nif (logflags & IP6T_LOG_IPOPT) {\r\nstruct ip_esp_hdr _esph;\r\nconst struct ip_esp_hdr *eh;\r\nsb_add(m, "ESP ");\r\nif (fragment) {\r\nsb_add(m, ")");\r\nreturn;\r\n}\r\neh = skb_header_pointer(skb, ptr, sizeof(_esph),\r\n&_esph);\r\nif (eh == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] )",\r\nskb->len - ptr);\r\nreturn;\r\n}\r\nsb_add(m, "SPI=0x%x )", ntohl(eh->spi) );\r\n}\r\nreturn;\r\ndefault:\r\nsb_add(m, "Unknown Ext Hdr %u", currenthdr);\r\nreturn;\r\n}\r\nif (logflags & IP6T_LOG_IPOPT)\r\nsb_add(m, ") ");\r\ncurrenthdr = hp->nexthdr;\r\nptr += hdrlen;\r\n}\r\nswitch (currenthdr) {\r\ncase IPPROTO_TCP: {\r\nstruct tcphdr _tcph;\r\nconst struct tcphdr *th;\r\nsb_add(m, "PROTO=TCP ");\r\nif (fragment)\r\nbreak;\r\nth = skb_header_pointer(skb, ptr, sizeof(_tcph), &_tcph);\r\nif (th == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] ", skb->len - ptr);\r\nreturn;\r\n}\r\nsb_add(m, "SPT=%u DPT=%u ",\r\nntohs(th->source), ntohs(th->dest));\r\nif (logflags & IP6T_LOG_TCPSEQ)\r\nsb_add(m, "SEQ=%u ACK=%u ",\r\nntohl(th->seq), ntohl(th->ack_seq));\r\nsb_add(m, "WINDOW=%u ", ntohs(th->window));\r\nsb_add(m, "RES=0x%02x ", (u_int8_t)(ntohl(tcp_flag_word(th) & TCP_RESERVED_BITS) >> 22));\r\nif (th->cwr)\r\nsb_add(m, "CWR ");\r\nif (th->ece)\r\nsb_add(m, "ECE ");\r\nif (th->urg)\r\nsb_add(m, "URG ");\r\nif (th->ack)\r\nsb_add(m, "ACK ");\r\nif (th->psh)\r\nsb_add(m, "PSH ");\r\nif (th->rst)\r\nsb_add(m, "RST ");\r\nif (th->syn)\r\nsb_add(m, "SYN ");\r\nif (th->fin)\r\nsb_add(m, "FIN ");\r\nsb_add(m, "URGP=%u ", ntohs(th->urg_ptr));\r\nif ((logflags & IP6T_LOG_TCPOPT) &&\r\nth->doff * 4 > sizeof(struct tcphdr)) {\r\nu_int8_t _opt[60 - sizeof(struct tcphdr)];\r\nconst u_int8_t *op;\r\nunsigned int i;\r\nunsigned int optsize = th->doff * 4\r\n- sizeof(struct tcphdr);\r\nop = skb_header_pointer(skb,\r\nptr + sizeof(struct tcphdr),\r\noptsize, _opt);\r\nif (op == NULL) {\r\nsb_add(m, "OPT (TRUNCATED)");\r\nreturn;\r\n}\r\nsb_add(m, "OPT (");\r\nfor (i =0; i < optsize; i++)\r\nsb_add(m, "%02X", op[i]);\r\nsb_add(m, ") ");\r\n}\r\nbreak;\r\n}\r\ncase IPPROTO_UDP:\r\ncase IPPROTO_UDPLITE: {\r\nstruct udphdr _udph;\r\nconst struct udphdr *uh;\r\nif (currenthdr == IPPROTO_UDP)\r\nsb_add(m, "PROTO=UDP " );\r\nelse\r\nsb_add(m, "PROTO=UDPLITE ");\r\nif (fragment)\r\nbreak;\r\nuh = skb_header_pointer(skb, ptr, sizeof(_udph), &_udph);\r\nif (uh == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] ", skb->len - ptr);\r\nreturn;\r\n}\r\nsb_add(m, "SPT=%u DPT=%u LEN=%u ",\r\nntohs(uh->source), ntohs(uh->dest),\r\nntohs(uh->len));\r\nbreak;\r\n}\r\ncase IPPROTO_ICMPV6: {\r\nstruct icmp6hdr _icmp6h;\r\nconst struct icmp6hdr *ic;\r\nsb_add(m, "PROTO=ICMPv6 ");\r\nif (fragment)\r\nbreak;\r\nic = skb_header_pointer(skb, ptr, sizeof(_icmp6h), &_icmp6h);\r\nif (ic == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] ", skb->len - ptr);\r\nreturn;\r\n}\r\nsb_add(m, "TYPE=%u CODE=%u ", ic->icmp6_type, ic->icmp6_code);\r\nswitch (ic->icmp6_type) {\r\ncase ICMPV6_ECHO_REQUEST:\r\ncase ICMPV6_ECHO_REPLY:\r\nsb_add(m, "ID=%u SEQ=%u ",\r\nntohs(ic->icmp6_identifier),\r\nntohs(ic->icmp6_sequence));\r\nbreak;\r\ncase ICMPV6_MGM_QUERY:\r\ncase ICMPV6_MGM_REPORT:\r\ncase ICMPV6_MGM_REDUCTION:\r\nbreak;\r\ncase ICMPV6_PARAMPROB:\r\nsb_add(m, "POINTER=%08x ", ntohl(ic->icmp6_pointer));\r\ncase ICMPV6_DEST_UNREACH:\r\ncase ICMPV6_PKT_TOOBIG:\r\ncase ICMPV6_TIME_EXCEED:\r\nif (recurse) {\r\nsb_add(m, "[");\r\ndump_packet(m, info, skb,\r\nptr + sizeof(_icmp6h), 0);\r\nsb_add(m, "] ");\r\n}\r\nif (ic->icmp6_type == ICMPV6_PKT_TOOBIG)\r\nsb_add(m, "MTU=%u ", ntohl(ic->icmp6_mtu));\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nsb_add(m, "PROTO=%u ", currenthdr);\r\n}\r\nif ((logflags & IP6T_LOG_UID) && recurse && skb->sk) {\r\nread_lock_bh(&skb->sk->sk_callback_lock);\r\nif (skb->sk->sk_socket && skb->sk->sk_socket->file)\r\nsb_add(m, "UID=%u GID=%u ",\r\nskb->sk->sk_socket->file->f_cred->fsuid,\r\nskb->sk->sk_socket->file->f_cred->fsgid);\r\nread_unlock_bh(&skb->sk->sk_callback_lock);\r\n}\r\nif (!recurse && skb->mark)\r\nsb_add(m, "MARK=0x%x ", skb->mark);\r\n}\r\nstatic void dump_mac_header(struct sbuff *m,\r\nconst struct nf_loginfo *info,\r\nconst struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nunsigned int logflags = 0;\r\nif (info->type == NF_LOG_TYPE_LOG)\r\nlogflags = info->u.log.logflags;\r\nif (!(logflags & IP6T_LOG_MACDECODE))\r\ngoto fallback;\r\nswitch (dev->type) {\r\ncase ARPHRD_ETHER:\r\nsb_add(m, "MACSRC=%pM MACDST=%pM MACPROTO=%04x ",\r\neth_hdr(skb)->h_source, eth_hdr(skb)->h_dest,\r\nntohs(eth_hdr(skb)->h_proto));\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\nfallback:\r\nsb_add(m, "MAC=");\r\nif (dev->hard_header_len &&\r\nskb->mac_header != skb->network_header) {\r\nconst unsigned char *p = skb_mac_header(skb);\r\nunsigned int len = dev->hard_header_len;\r\nunsigned int i;\r\nif (dev->type == ARPHRD_SIT &&\r\n(p -= ETH_HLEN) < skb->head)\r\np = NULL;\r\nif (p != NULL) {\r\nsb_add(m, "%02x", *p++);\r\nfor (i = 1; i < len; i++)\r\nsb_add(m, ":%02x", *p++);\r\n}\r\nsb_add(m, " ");\r\nif (dev->type == ARPHRD_SIT) {\r\nconst struct iphdr *iph =\r\n(struct iphdr *)skb_mac_header(skb);\r\nsb_add(m, "TUNNEL=%pI4->%pI4 ", &iph->saddr, &iph->daddr);\r\n}\r\n} else\r\nsb_add(m, " ");\r\n}\r\nstatic void\r\nip6t_log_packet(u_int8_t pf,\r\nunsigned int hooknum,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *loginfo,\r\nconst char *prefix)\r\n{\r\nstruct sbuff *m = sb_open();\r\nif (!loginfo)\r\nloginfo = &default_loginfo;\r\nsb_add(m, "<%d>%sIN=%s OUT=%s ", loginfo->u.log.level,\r\nprefix,\r\nin ? in->name : "",\r\nout ? out->name : "");\r\nif (in != NULL)\r\ndump_mac_header(m, loginfo, skb);\r\ndump_packet(m, loginfo, skb, skb_network_offset(skb), 1);\r\nsb_close(m);\r\n}\r\nstatic unsigned int\r\nlog_tg6(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct ip6t_log_info *loginfo = par->targinfo;\r\nstruct nf_loginfo li;\r\nli.type = NF_LOG_TYPE_LOG;\r\nli.u.log.level = loginfo->level;\r\nli.u.log.logflags = loginfo->logflags;\r\nip6t_log_packet(NFPROTO_IPV6, par->hooknum, skb, par->in, par->out,\r\n&li, loginfo->prefix);\r\nreturn XT_CONTINUE;\r\n}\r\nstatic int log_tg6_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct ip6t_log_info *loginfo = par->targinfo;\r\nif (loginfo->level >= 8) {\r\npr_debug("level %u >= 8\n", loginfo->level);\r\nreturn -EINVAL;\r\n}\r\nif (loginfo->prefix[sizeof(loginfo->prefix)-1] != '\0') {\r\npr_debug("prefix not null-terminated\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init log_tg6_init(void)\r\n{\r\nint ret;\r\nret = xt_register_target(&log_tg6_reg);\r\nif (ret < 0)\r\nreturn ret;\r\nnf_log_register(NFPROTO_IPV6, &ip6t_logger);\r\nreturn 0;\r\n}\r\nstatic void __exit log_tg6_exit(void)\r\n{\r\nnf_log_unregister(&ip6t_logger);\r\nxt_unregister_target(&log_tg6_reg);\r\n}
