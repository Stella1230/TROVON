static void print_wrong_arg_exit(void)\r\n{\r\nprintf(_("invalid or unknown argument\n"));\r\nexit(EXIT_FAILURE);\r\n}\r\nlong long timespec_diff_us(struct timespec start, struct timespec end)\r\n{\r\nstruct timespec temp;\r\nif ((end.tv_nsec - start.tv_nsec) < 0) {\r\ntemp.tv_sec = end.tv_sec - start.tv_sec - 1;\r\ntemp.tv_nsec = 1000000000 + end.tv_nsec - start.tv_nsec;\r\n} else {\r\ntemp.tv_sec = end.tv_sec - start.tv_sec;\r\ntemp.tv_nsec = end.tv_nsec - start.tv_nsec;\r\n}\r\nreturn (temp.tv_sec * 1000000) + (temp.tv_nsec / 1000);\r\n}\r\nvoid print_n_spaces(int n)\r\n{\r\nint x;\r\nfor (x = 0; x < n; x++)\r\nprintf(" ");\r\n}\r\nint fill_string_with_spaces(char *s, int n)\r\n{\r\nint len = strlen(s);\r\nif (len > n)\r\nreturn -1;\r\nfor (; len < n; len++)\r\ns[len] = ' ';\r\ns[len] = '\0';\r\nreturn 0;\r\n}\r\nvoid print_header(int topology_depth)\r\n{\r\nint unsigned mon;\r\nint state, need_len, pr_mon_len;\r\ncstate_t s;\r\nchar buf[128] = "";\r\nint percent_width = 4;\r\nfill_string_with_spaces(buf, topology_depth * 5 - 1);\r\nprintf("%s|", buf);\r\nfor (mon = 0; mon < avail_monitors; mon++) {\r\npr_mon_len = 0;\r\nneed_len = monitors[mon]->hw_states_num * (percent_width + 3)\r\n- 1;\r\nif (mon != 0) {\r\nprintf("|| ");\r\nneed_len--;\r\n}\r\nsprintf(buf, "%s", monitors[mon]->name);\r\nfill_string_with_spaces(buf, need_len);\r\nprintf("%s", buf);\r\n}\r\nprintf("\n");\r\nif (topology_depth > 2)\r\nprintf("PKG |");\r\nif (topology_depth > 1)\r\nprintf("CORE|");\r\nif (topology_depth > 0)\r\nprintf("CPU |");\r\nfor (mon = 0; mon < avail_monitors; mon++) {\r\nif (mon != 0)\r\nprintf("|| ");\r\nelse\r\nprintf(" ");\r\nfor (state = 0; state < monitors[mon]->hw_states_num; state++) {\r\nif (state != 0)\r\nprintf(" | ");\r\ns = monitors[mon]->hw_states[state];\r\nsprintf(buf, "%s", s.name);\r\nfill_string_with_spaces(buf, percent_width);\r\nprintf("%s", buf);\r\n}\r\nprintf(" ");\r\n}\r\nprintf("\n");\r\n}\r\nvoid print_results(int topology_depth, int cpu)\r\n{\r\nunsigned int mon;\r\nint state, ret;\r\ndouble percent;\r\nunsigned long long result;\r\ncstate_t s;\r\nif (!bitmask_isbitset(cpus_chosen, cpu_top.core_info[cpu].cpu))\r\nreturn;\r\nif (topology_depth > 2)\r\nprintf("%4d|", cpu_top.core_info[cpu].pkg);\r\nif (topology_depth > 1)\r\nprintf("%4d|", cpu_top.core_info[cpu].core);\r\nif (topology_depth > 0)\r\nprintf("%4d|", cpu_top.core_info[cpu].cpu);\r\nfor (mon = 0; mon < avail_monitors; mon++) {\r\nif (mon != 0)\r\nprintf("||");\r\nfor (state = 0; state < monitors[mon]->hw_states_num; state++) {\r\nif (state != 0)\r\nprintf("|");\r\ns = monitors[mon]->hw_states[state];\r\nif (s.get_count_percent) {\r\nret = s.get_count_percent(s.id, &percent,\r\ncpu_top.core_info[cpu].cpu);\r\nif (ret)\r\nprintf("******");\r\nelse if (percent >= 100.0)\r\nprintf("%6.1f", percent);\r\nelse\r\nprintf("%6.2f", percent);\r\n} else if (s.get_count) {\r\nret = s.get_count(s.id, &result,\r\ncpu_top.core_info[cpu].cpu);\r\nif (ret)\r\nprintf("******");\r\nelse\r\nprintf("%6llu", result);\r\n} else {\r\nprintf(_("Monitor %s, Counter %s has no count "\r\n"function. Implementation error\n"),\r\nmonitors[mon]->name, s.name);\r\nexit(EXIT_FAILURE);\r\n}\r\n}\r\n}\r\nif (!cpu_top.core_info[cpu].is_online) {\r\nprintf(_(" *is offline\n"));\r\nreturn;\r\n} else\r\nprintf("\n");\r\n}\r\nstatic void parse_monitor_param(char *param)\r\n{\r\nunsigned int num;\r\nint mon, hits = 0;\r\nchar *tmp = param, *token;\r\nstruct cpuidle_monitor *tmp_mons[MONITORS_MAX];\r\nfor (mon = 0; mon < MONITORS_MAX; mon++, tmp = NULL) {\r\ntoken = strtok(tmp, ",");\r\nif (token == NULL)\r\nbreak;\r\nif (strlen(token) >= MONITOR_NAME_LEN) {\r\nprintf(_("%s: max monitor name length"\r\n" (%d) exceeded\n"), token, MONITOR_NAME_LEN);\r\ncontinue;\r\n}\r\nfor (num = 0; num < avail_monitors; num++) {\r\nif (!strcmp(monitors[num]->name, token)) {\r\ndprint("Found requested monitor: %s\n", token);\r\ntmp_mons[hits] = monitors[num];\r\nhits++;\r\n}\r\n}\r\n}\r\nif (hits == 0) {\r\nprintf(_("No matching monitor found in %s, "\r\n"try -l option\n"), param);\r\nexit(EXIT_FAILURE);\r\n}\r\nmemcpy(monitors, tmp_mons,\r\nsizeof(struct cpuidle_monitor *) * MONITORS_MAX);\r\navail_monitors = hits;\r\n}\r\nvoid list_monitors(void)\r\n{\r\nunsigned int mon;\r\nint state;\r\ncstate_t s;\r\nfor (mon = 0; mon < avail_monitors; mon++) {\r\nprintf(_("Monitor \"%s\" (%d states) - Might overflow after %u "\r\n"s\n"),\r\nmonitors[mon]->name, monitors[mon]->hw_states_num,\r\nmonitors[mon]->overflow_s);\r\nfor (state = 0; state < monitors[mon]->hw_states_num; state++) {\r\ns = monitors[mon]->hw_states[state];\r\nprintf("%s\t[%c] -> %s\n", s.name, range_abbr[s.range],\r\ngettext(s.desc));\r\n}\r\n}\r\n}\r\nint fork_it(char **argv)\r\n{\r\nint status;\r\nunsigned int num;\r\nunsigned long long timediff;\r\npid_t child_pid;\r\nstruct timespec start, end;\r\nchild_pid = fork();\r\nclock_gettime(CLOCK_REALTIME, &start);\r\nfor (num = 0; num < avail_monitors; num++)\r\nmonitors[num]->start();\r\nif (!child_pid) {\r\nexecvp(argv[0], argv);\r\n} else {\r\nif (child_pid == -1) {\r\nperror("fork");\r\nexit(1);\r\n}\r\nsignal(SIGINT, SIG_IGN);\r\nsignal(SIGQUIT, SIG_IGN);\r\nif (waitpid(child_pid, &status, 0) == -1) {\r\nperror("wait");\r\nexit(1);\r\n}\r\n}\r\nclock_gettime(CLOCK_REALTIME, &end);\r\nfor (num = 0; num < avail_monitors; num++)\r\nmonitors[num]->stop();\r\ntimediff = timespec_diff_us(start, end);\r\nif (WIFEXITED(status))\r\nprintf(_("%s took %.5f seconds and exited with status %d\n"),\r\nargv[0], timediff / (1000.0 * 1000),\r\nWEXITSTATUS(status));\r\nreturn 0;\r\n}\r\nint do_interval_measure(int i)\r\n{\r\nunsigned int num;\r\nfor (num = 0; num < avail_monitors; num++) {\r\ndprint("HW C-state residency monitor: %s - States: %d\n",\r\nmonitors[num]->name, monitors[num]->hw_states_num);\r\nmonitors[num]->start();\r\n}\r\nsleep(i);\r\nfor (num = 0; num < avail_monitors; num++)\r\nmonitors[num]->stop();\r\nreturn 0;\r\n}\r\nstatic void cmdline(int argc, char *argv[])\r\n{\r\nint opt;\r\nprogname = basename(argv[0]);\r\nwhile ((opt = getopt(argc, argv, "+li:m:")) != -1) {\r\nswitch (opt) {\r\ncase 'l':\r\nif (mode)\r\nprint_wrong_arg_exit();\r\nmode = list;\r\nbreak;\r\ncase 'i':\r\nif (mode && mode != show)\r\nprint_wrong_arg_exit();\r\ninterval = atoi(optarg);\r\nbreak;\r\ncase 'm':\r\nif (mode)\r\nprint_wrong_arg_exit();\r\nmode = show;\r\nshow_monitors_param = optarg;\r\nbreak;\r\ndefault:\r\nprint_wrong_arg_exit();\r\n}\r\n}\r\nif (!mode)\r\nmode = show_all;\r\n}\r\nint cmd_monitor(int argc, char **argv)\r\n{\r\nunsigned int num;\r\nstruct cpuidle_monitor *test_mon;\r\nint cpu;\r\ncmdline(argc, argv);\r\ncpu_count = get_cpu_topology(&cpu_top);\r\nif (cpu_count < 0) {\r\nprintf(_("Cannot read number of available processors\n"));\r\nreturn EXIT_FAILURE;\r\n}\r\nif (bitmask_isallclear(cpus_chosen))\r\nbitmask_setall(cpus_chosen);\r\ndprint("System has up to %d CPU cores\n", cpu_count);\r\nfor (num = 0; all_monitors[num]; num++) {\r\ndprint("Try to register: %s\n", all_monitors[num]->name);\r\ntest_mon = all_monitors[num]->do_register();\r\nif (test_mon) {\r\nif (test_mon->needs_root && !run_as_root) {\r\nfprintf(stderr, _("Available monitor %s needs "\r\n"root access\n"), test_mon->name);\r\ncontinue;\r\n}\r\nmonitors[avail_monitors] = test_mon;\r\ndprint("%s registered\n", all_monitors[num]->name);\r\navail_monitors++;\r\n}\r\n}\r\nif (avail_monitors == 0) {\r\nprintf(_("No HW Cstate monitors found\n"));\r\nreturn 1;\r\n}\r\nif (mode == list) {\r\nlist_monitors();\r\nexit(EXIT_SUCCESS);\r\n}\r\nif (mode == show)\r\nparse_monitor_param(show_monitors_param);\r\ndprint("Packages: %d - Cores: %d - CPUs: %d\n",\r\ncpu_top.pkgs, cpu_top.cores, cpu_count);\r\nif (argc - optind)\r\nfork_it(argv + optind);\r\nelse\r\ndo_interval_measure(interval);\r\nif (cpu_top.pkgs > 1)\r\nprint_header(3);\r\nelse\r\nprint_header(1);\r\nfor (cpu = 0; cpu < cpu_count; cpu++) {\r\nif (cpu_top.pkgs > 1)\r\nprint_results(3, cpu);\r\nelse\r\nprint_results(1, cpu);\r\n}\r\nfor (num = 0; num < avail_monitors; num++)\r\nmonitors[num]->unregister();\r\ncpu_topology_release(cpu_top);\r\nreturn 0;\r\n}
