static void uwb_dbg_rsv_cb(struct uwb_rsv *rsv)\r\n{\r\nstruct uwb_dbg *dbg = rsv->pal_priv;\r\nuwb_rsv_dump("debug", rsv);\r\nif (rsv->state == UWB_RSV_STATE_NONE) {\r\nspin_lock(&dbg->list_lock);\r\nlist_del(&rsv->pal_node);\r\nspin_unlock(&dbg->list_lock);\r\nuwb_rsv_destroy(rsv);\r\n}\r\n}\r\nstatic int cmd_rsv_establish(struct uwb_rc *rc,\r\nstruct uwb_dbg_cmd_rsv_establish *cmd)\r\n{\r\nstruct uwb_mac_addr macaddr;\r\nstruct uwb_rsv *rsv;\r\nstruct uwb_dev *target;\r\nint ret;\r\nmemcpy(&macaddr, cmd->target, sizeof(macaddr));\r\ntarget = uwb_dev_get_by_macaddr(rc, &macaddr);\r\nif (target == NULL)\r\nreturn -ENODEV;\r\nrsv = uwb_rsv_create(rc, uwb_dbg_rsv_cb, rc->dbg);\r\nif (rsv == NULL) {\r\nuwb_dev_put(target);\r\nreturn -ENOMEM;\r\n}\r\nrsv->target.type = UWB_RSV_TARGET_DEV;\r\nrsv->target.dev = target;\r\nrsv->type = cmd->type;\r\nrsv->max_mas = cmd->max_mas;\r\nrsv->min_mas = cmd->min_mas;\r\nrsv->max_interval = cmd->max_interval;\r\nret = uwb_rsv_establish(rsv);\r\nif (ret)\r\nuwb_rsv_destroy(rsv);\r\nelse {\r\nspin_lock(&(rc->dbg)->list_lock);\r\nlist_add_tail(&rsv->pal_node, &rc->dbg->rsvs);\r\nspin_unlock(&(rc->dbg)->list_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic int cmd_rsv_terminate(struct uwb_rc *rc,\r\nstruct uwb_dbg_cmd_rsv_terminate *cmd)\r\n{\r\nstruct uwb_rsv *rsv, *found = NULL;\r\nint i = 0;\r\nspin_lock(&(rc->dbg)->list_lock);\r\nlist_for_each_entry(rsv, &rc->dbg->rsvs, pal_node) {\r\nif (i == cmd->index) {\r\nfound = rsv;\r\nuwb_rsv_get(found);\r\nbreak;\r\n}\r\ni++;\r\n}\r\nspin_unlock(&(rc->dbg)->list_lock);\r\nif (!found)\r\nreturn -EINVAL;\r\nuwb_rsv_terminate(found);\r\nuwb_rsv_put(found);\r\nreturn 0;\r\n}\r\nstatic int cmd_ie_add(struct uwb_rc *rc, struct uwb_dbg_cmd_ie *ie_to_add)\r\n{\r\nreturn uwb_rc_ie_add(rc,\r\n(const struct uwb_ie_hdr *) ie_to_add->data,\r\nie_to_add->len);\r\n}\r\nstatic int cmd_ie_rm(struct uwb_rc *rc, struct uwb_dbg_cmd_ie *ie_to_rm)\r\n{\r\nreturn uwb_rc_ie_rm(rc, ie_to_rm->data[0]);\r\n}\r\nstatic int command_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = inode->i_private;\r\nreturn 0;\r\n}\r\nstatic ssize_t command_write(struct file *file, const char __user *buf,\r\nsize_t len, loff_t *off)\r\n{\r\nstruct uwb_rc *rc = file->private_data;\r\nstruct uwb_dbg_cmd cmd;\r\nint ret = 0;\r\nif (len != sizeof(struct uwb_dbg_cmd))\r\nreturn -EINVAL;\r\nif (copy_from_user(&cmd, buf, len) != 0)\r\nreturn -EFAULT;\r\nswitch (cmd.type) {\r\ncase UWB_DBG_CMD_RSV_ESTABLISH:\r\nret = cmd_rsv_establish(rc, &cmd.rsv_establish);\r\nbreak;\r\ncase UWB_DBG_CMD_RSV_TERMINATE:\r\nret = cmd_rsv_terminate(rc, &cmd.rsv_terminate);\r\nbreak;\r\ncase UWB_DBG_CMD_IE_ADD:\r\nret = cmd_ie_add(rc, &cmd.ie_add);\r\nbreak;\r\ncase UWB_DBG_CMD_IE_RM:\r\nret = cmd_ie_rm(rc, &cmd.ie_rm);\r\nbreak;\r\ncase UWB_DBG_CMD_RADIO_START:\r\nret = uwb_radio_start(&rc->dbg->pal);\r\nbreak;\r\ncase UWB_DBG_CMD_RADIO_STOP:\r\nuwb_radio_stop(&rc->dbg->pal);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret < 0 ? ret : len;\r\n}\r\nstatic int reservations_print(struct seq_file *s, void *p)\r\n{\r\nstruct uwb_rc *rc = s->private;\r\nstruct uwb_rsv *rsv;\r\nmutex_lock(&rc->rsvs_mutex);\r\nlist_for_each_entry(rsv, &rc->reservations, rc_node) {\r\nstruct uwb_dev_addr devaddr;\r\nchar owner[UWB_ADDR_STRSIZE], target[UWB_ADDR_STRSIZE];\r\nbool is_owner;\r\nchar buf[72];\r\nuwb_dev_addr_print(owner, sizeof(owner), &rsv->owner->dev_addr);\r\nif (rsv->target.type == UWB_RSV_TARGET_DEV) {\r\ndevaddr = rsv->target.dev->dev_addr;\r\nis_owner = &rc->uwb_dev == rsv->owner;\r\n} else {\r\ndevaddr = rsv->target.devaddr;\r\nis_owner = true;\r\n}\r\nuwb_dev_addr_print(target, sizeof(target), &devaddr);\r\nseq_printf(s, "%c %s -> %s: %s\n",\r\nis_owner ? 'O' : 'T',\r\nowner, target, uwb_rsv_state_str(rsv->state));\r\nseq_printf(s, " stream: %d type: %s\n",\r\nrsv->stream, uwb_rsv_type_str(rsv->type));\r\nbitmap_scnprintf(buf, sizeof(buf), rsv->mas.bm, UWB_NUM_MAS);\r\nseq_printf(s, " %s\n", buf);\r\n}\r\nmutex_unlock(&rc->rsvs_mutex);\r\nreturn 0;\r\n}\r\nstatic int reservations_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, reservations_print, inode->i_private);\r\n}\r\nstatic int drp_avail_print(struct seq_file *s, void *p)\r\n{\r\nstruct uwb_rc *rc = s->private;\r\nchar buf[72];\r\nbitmap_scnprintf(buf, sizeof(buf), rc->drp_avail.global, UWB_NUM_MAS);\r\nseq_printf(s, "global: %s\n", buf);\r\nbitmap_scnprintf(buf, sizeof(buf), rc->drp_avail.local, UWB_NUM_MAS);\r\nseq_printf(s, "local: %s\n", buf);\r\nbitmap_scnprintf(buf, sizeof(buf), rc->drp_avail.pending, UWB_NUM_MAS);\r\nseq_printf(s, "pending: %s\n", buf);\r\nreturn 0;\r\n}\r\nstatic int drp_avail_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, drp_avail_print, inode->i_private);\r\n}\r\nstatic void uwb_dbg_channel_changed(struct uwb_pal *pal, int channel)\r\n{\r\nstruct device *dev = &pal->rc->uwb_dev.dev;\r\nif (channel > 0)\r\ndev_info(dev, "debug: channel %d started\n", channel);\r\nelse\r\ndev_info(dev, "debug: channel stopped\n");\r\n}\r\nstatic void uwb_dbg_new_rsv(struct uwb_pal *pal, struct uwb_rsv *rsv)\r\n{\r\nstruct uwb_dbg *dbg = container_of(pal, struct uwb_dbg, pal);\r\nif (dbg->accept) {\r\nspin_lock(&dbg->list_lock);\r\nlist_add_tail(&rsv->pal_node, &dbg->rsvs);\r\nspin_unlock(&dbg->list_lock);\r\nuwb_rsv_accept(rsv, uwb_dbg_rsv_cb, dbg);\r\n}\r\n}\r\nvoid uwb_dbg_add_rc(struct uwb_rc *rc)\r\n{\r\nrc->dbg = kzalloc(sizeof(struct uwb_dbg), GFP_KERNEL);\r\nif (rc->dbg == NULL)\r\nreturn;\r\nINIT_LIST_HEAD(&rc->dbg->rsvs);\r\nspin_lock_init(&(rc->dbg)->list_lock);\r\nuwb_pal_init(&rc->dbg->pal);\r\nrc->dbg->pal.rc = rc;\r\nrc->dbg->pal.channel_changed = uwb_dbg_channel_changed;\r\nrc->dbg->pal.new_rsv = uwb_dbg_new_rsv;\r\nuwb_pal_register(&rc->dbg->pal);\r\nif (root_dir) {\r\nrc->dbg->root_d = debugfs_create_dir(dev_name(&rc->uwb_dev.dev),\r\nroot_dir);\r\nrc->dbg->command_f = debugfs_create_file("command", 0200,\r\nrc->dbg->root_d, rc,\r\n&command_fops);\r\nrc->dbg->reservations_f = debugfs_create_file("reservations", 0444,\r\nrc->dbg->root_d, rc,\r\n&reservations_fops);\r\nrc->dbg->accept_f = debugfs_create_bool("accept", 0644,\r\nrc->dbg->root_d,\r\n&rc->dbg->accept);\r\nrc->dbg->drp_avail_f = debugfs_create_file("drp_avail", 0444,\r\nrc->dbg->root_d, rc,\r\n&drp_avail_fops);\r\n}\r\n}\r\nvoid uwb_dbg_del_rc(struct uwb_rc *rc)\r\n{\r\nstruct uwb_rsv *rsv, *t;\r\nif (rc->dbg == NULL)\r\nreturn;\r\nlist_for_each_entry_safe(rsv, t, &rc->dbg->rsvs, pal_node) {\r\nuwb_rsv_terminate(rsv);\r\n}\r\nuwb_pal_unregister(&rc->dbg->pal);\r\nif (root_dir) {\r\ndebugfs_remove(rc->dbg->drp_avail_f);\r\ndebugfs_remove(rc->dbg->accept_f);\r\ndebugfs_remove(rc->dbg->reservations_f);\r\ndebugfs_remove(rc->dbg->command_f);\r\ndebugfs_remove(rc->dbg->root_d);\r\n}\r\n}\r\nvoid uwb_dbg_init(void)\r\n{\r\nroot_dir = debugfs_create_dir("uwb", NULL);\r\n}\r\nvoid uwb_dbg_exit(void)\r\n{\r\ndebugfs_remove(root_dir);\r\n}\r\nstruct dentry *uwb_dbg_create_pal_dir(struct uwb_pal *pal)\r\n{\r\nstruct uwb_rc *rc = pal->rc;\r\nif (root_dir && rc->dbg && rc->dbg->root_d && pal->name)\r\nreturn debugfs_create_dir(pal->name, rc->dbg->root_d);\r\nreturn NULL;\r\n}
