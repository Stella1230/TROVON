static void spaceball_process_packet(struct spaceball* spaceball)\r\n{\r\nstruct input_dev *dev = spaceball->dev;\r\nunsigned char *data = spaceball->data;\r\nint i;\r\nif (spaceball->idx < 2) return;\r\nswitch (spaceball->data[0]) {\r\ncase 'D':\r\nif (spaceball->idx != 15) return;\r\nfor (i = 0; i < 6; i++)\r\ninput_report_abs(dev, spaceball_axes[i],\r\n(__s16)((data[2 * i + 3] << 8) | data[2 * i + 2]));\r\nbreak;\r\ncase 'K':\r\nif (spaceball->idx != 3) return;\r\ninput_report_key(dev, BTN_1, (data[2] & 0x01) || (data[2] & 0x20));\r\ninput_report_key(dev, BTN_2, data[2] & 0x02);\r\ninput_report_key(dev, BTN_3, data[2] & 0x04);\r\ninput_report_key(dev, BTN_4, data[2] & 0x08);\r\ninput_report_key(dev, BTN_5, data[1] & 0x01);\r\ninput_report_key(dev, BTN_6, data[1] & 0x02);\r\ninput_report_key(dev, BTN_7, data[1] & 0x04);\r\ninput_report_key(dev, BTN_8, data[1] & 0x10);\r\nbreak;\r\ncase '.':\r\nif (spaceball->idx != 3) return;\r\ninput_report_key(dev, BTN_1, data[2] & 0x01);\r\ninput_report_key(dev, BTN_2, data[2] & 0x02);\r\ninput_report_key(dev, BTN_3, data[2] & 0x04);\r\ninput_report_key(dev, BTN_4, data[2] & 0x08);\r\ninput_report_key(dev, BTN_5, data[2] & 0x10);\r\ninput_report_key(dev, BTN_6, data[2] & 0x20);\r\ninput_report_key(dev, BTN_7, data[2] & 0x80);\r\ninput_report_key(dev, BTN_8, data[1] & 0x01);\r\ninput_report_key(dev, BTN_9, data[1] & 0x02);\r\ninput_report_key(dev, BTN_A, data[1] & 0x04);\r\ninput_report_key(dev, BTN_B, data[1] & 0x08);\r\ninput_report_key(dev, BTN_C, data[1] & 0x10);\r\ninput_report_key(dev, BTN_MODE, data[1] & 0x20);\r\nbreak;\r\ncase 'E':\r\nspaceball->data[spaceball->idx - 1] = 0;\r\nprintk(KERN_ERR "spaceball: Device error. [%s]\n", spaceball->data + 1);\r\nbreak;\r\ncase '?':\r\nspaceball->data[spaceball->idx - 1] = 0;\r\nprintk(KERN_ERR "spaceball: Bad command. [%s]\n", spaceball->data + 1);\r\nbreak;\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic irqreturn_t spaceball_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int flags)\r\n{\r\nstruct spaceball *spaceball = serio_get_drvdata(serio);\r\nswitch (data) {\r\ncase 0xd:\r\nspaceball_process_packet(spaceball);\r\nspaceball->idx = 0;\r\nspaceball->escape = 0;\r\nbreak;\r\ncase '^':\r\nif (!spaceball->escape) {\r\nspaceball->escape = 1;\r\nbreak;\r\n}\r\nspaceball->escape = 0;\r\ncase 'M':\r\ncase 'Q':\r\ncase 'S':\r\nif (spaceball->escape) {\r\nspaceball->escape = 0;\r\ndata &= 0x1f;\r\n}\r\ndefault:\r\nif (spaceball->escape)\r\nspaceball->escape = 0;\r\nif (spaceball->idx < SPACEBALL_MAX_LENGTH)\r\nspaceball->data[spaceball->idx++] = data;\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void spaceball_disconnect(struct serio *serio)\r\n{\r\nstruct spaceball* spaceball = serio_get_drvdata(serio);\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\ninput_unregister_device(spaceball->dev);\r\nkfree(spaceball);\r\n}\r\nstatic int spaceball_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct spaceball *spaceball;\r\nstruct input_dev *input_dev;\r\nint err = -ENOMEM;\r\nint i, id;\r\nif ((id = serio->id.id) > SPACEBALL_MAX_ID)\r\nreturn -ENODEV;\r\nspaceball = kmalloc(sizeof(struct spaceball), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!spaceball || !input_dev)\r\ngoto fail1;\r\nspaceball->dev = input_dev;\r\nsnprintf(spaceball->phys, sizeof(spaceball->phys), "%s/input0", serio->phys);\r\ninput_dev->name = spaceball_names[id];\r\ninput_dev->phys = spaceball->phys;\r\ninput_dev->id.bustype = BUS_RS232;\r\ninput_dev->id.vendor = SERIO_SPACEBALL;\r\ninput_dev->id.product = id;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &serio->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nswitch (id) {\r\ncase SPACEBALL_4000FLX:\r\ncase SPACEBALL_4000FLX_L:\r\ninput_dev->keybit[BIT_WORD(BTN_0)] |= BIT_MASK(BTN_9);\r\ninput_dev->keybit[BIT_WORD(BTN_A)] |= BIT_MASK(BTN_A) |\r\nBIT_MASK(BTN_B) | BIT_MASK(BTN_C) |\r\nBIT_MASK(BTN_MODE);\r\ndefault:\r\ninput_dev->keybit[BIT_WORD(BTN_0)] |= BIT_MASK(BTN_2) |\r\nBIT_MASK(BTN_3) | BIT_MASK(BTN_4) |\r\nBIT_MASK(BTN_5) | BIT_MASK(BTN_6) |\r\nBIT_MASK(BTN_7) | BIT_MASK(BTN_8);\r\ncase SPACEBALL_3003C:\r\ninput_dev->keybit[BIT_WORD(BTN_0)] |= BIT_MASK(BTN_1) |\r\nBIT_MASK(BTN_8);\r\n}\r\nfor (i = 0; i < 3; i++) {\r\ninput_set_abs_params(input_dev, ABS_X + i, -8000, 8000, 8, 40);\r\ninput_set_abs_params(input_dev, ABS_RX + i, -1600, 1600, 2, 8);\r\n}\r\nserio_set_drvdata(serio, spaceball);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto fail2;\r\nerr = input_register_device(spaceball->dev);\r\nif (err)\r\ngoto fail3;\r\nreturn 0;\r\nfail3: serio_close(serio);\r\nfail2: serio_set_drvdata(serio, NULL);\r\nfail1: input_free_device(input_dev);\r\nkfree(spaceball);\r\nreturn err;\r\n}\r\nstatic int __init spaceball_init(void)\r\n{\r\nreturn serio_register_driver(&spaceball_drv);\r\n}\r\nstatic void __exit spaceball_exit(void)\r\n{\r\nserio_unregister_driver(&spaceball_drv);\r\n}
