static void driver_bound(struct device *dev)\r\n{\r\nif (klist_node_attached(&dev->p->knode_driver)) {\r\nprintk(KERN_WARNING "%s: device %s already bound\n",\r\n__func__, kobject_name(&dev->kobj));\r\nreturn;\r\n}\r\npr_debug("driver: '%s': %s: bound to device '%s'\n", dev_name(dev),\r\n__func__, dev->driver->name);\r\nklist_add_tail(&dev->p->knode_driver, &dev->driver->p->klist_devices);\r\nif (dev->bus)\r\nblocking_notifier_call_chain(&dev->bus->p->bus_notifier,\r\nBUS_NOTIFY_BOUND_DRIVER, dev);\r\n}\r\nstatic int driver_sysfs_add(struct device *dev)\r\n{\r\nint ret;\r\nif (dev->bus)\r\nblocking_notifier_call_chain(&dev->bus->p->bus_notifier,\r\nBUS_NOTIFY_BIND_DRIVER, dev);\r\nret = sysfs_create_link(&dev->driver->p->kobj, &dev->kobj,\r\nkobject_name(&dev->kobj));\r\nif (ret == 0) {\r\nret = sysfs_create_link(&dev->kobj, &dev->driver->p->kobj,\r\n"driver");\r\nif (ret)\r\nsysfs_remove_link(&dev->driver->p->kobj,\r\nkobject_name(&dev->kobj));\r\n}\r\nreturn ret;\r\n}\r\nstatic void driver_sysfs_remove(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nif (drv) {\r\nsysfs_remove_link(&drv->p->kobj, kobject_name(&dev->kobj));\r\nsysfs_remove_link(&dev->kobj, "driver");\r\n}\r\n}\r\nint device_bind_driver(struct device *dev)\r\n{\r\nint ret;\r\nret = driver_sysfs_add(dev);\r\nif (!ret)\r\ndriver_bound(dev);\r\nreturn ret;\r\n}\r\nstatic int really_probe(struct device *dev, struct device_driver *drv)\r\n{\r\nint ret = 0;\r\natomic_inc(&probe_count);\r\npr_debug("bus: '%s': %s: probing driver %s with device %s\n",\r\ndrv->bus->name, __func__, drv->name, dev_name(dev));\r\nWARN_ON(!list_empty(&dev->devres_head));\r\ndev->driver = drv;\r\nif (driver_sysfs_add(dev)) {\r\nprintk(KERN_ERR "%s: driver_sysfs_add(%s) failed\n",\r\n__func__, dev_name(dev));\r\ngoto probe_failed;\r\n}\r\nif (dev->bus->probe) {\r\nret = dev->bus->probe(dev);\r\nif (ret)\r\ngoto probe_failed;\r\n} else if (drv->probe) {\r\nret = drv->probe(dev);\r\nif (ret)\r\ngoto probe_failed;\r\n}\r\ndriver_bound(dev);\r\nret = 1;\r\npr_debug("bus: '%s': %s: bound device %s to driver %s\n",\r\ndrv->bus->name, __func__, dev_name(dev), drv->name);\r\ngoto done;\r\nprobe_failed:\r\ndevres_release_all(dev);\r\ndriver_sysfs_remove(dev);\r\ndev->driver = NULL;\r\nif (ret != -ENODEV && ret != -ENXIO) {\r\nprintk(KERN_WARNING\r\n"%s: probe of %s failed with error %d\n",\r\ndrv->name, dev_name(dev), ret);\r\n} else {\r\npr_debug("%s: probe of %s rejects match %d\n",\r\ndrv->name, dev_name(dev), ret);\r\n}\r\nret = 0;\r\ndone:\r\natomic_dec(&probe_count);\r\nwake_up(&probe_waitqueue);\r\nreturn ret;\r\n}\r\nint driver_probe_done(void)\r\n{\r\npr_debug("%s: probe_count = %d\n", __func__,\r\natomic_read(&probe_count));\r\nif (atomic_read(&probe_count))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nvoid wait_for_device_probe(void)\r\n{\r\nwait_event(probe_waitqueue, atomic_read(&probe_count) == 0);\r\nasync_synchronize_full();\r\n}\r\nint driver_probe_device(struct device_driver *drv, struct device *dev)\r\n{\r\nint ret = 0;\r\nif (!device_is_registered(dev))\r\nreturn -ENODEV;\r\npr_debug("bus: '%s': %s: matched device %s with driver %s\n",\r\ndrv->bus->name, __func__, dev_name(dev), drv->name);\r\npm_runtime_get_noresume(dev);\r\npm_runtime_barrier(dev);\r\nret = really_probe(dev, drv);\r\npm_runtime_put_sync(dev);\r\nreturn ret;\r\n}\r\nstatic int __device_attach(struct device_driver *drv, void *data)\r\n{\r\nstruct device *dev = data;\r\nif (!driver_match_device(drv, dev))\r\nreturn 0;\r\nreturn driver_probe_device(drv, dev);\r\n}\r\nint device_attach(struct device *dev)\r\n{\r\nint ret = 0;\r\ndevice_lock(dev);\r\nif (dev->driver) {\r\nif (klist_node_attached(&dev->p->knode_driver)) {\r\nret = 1;\r\ngoto out_unlock;\r\n}\r\nret = device_bind_driver(dev);\r\nif (ret == 0)\r\nret = 1;\r\nelse {\r\ndev->driver = NULL;\r\nret = 0;\r\n}\r\n} else {\r\npm_runtime_get_noresume(dev);\r\nret = bus_for_each_drv(dev->bus, NULL, dev, __device_attach);\r\npm_runtime_put_sync(dev);\r\n}\r\nout_unlock:\r\ndevice_unlock(dev);\r\nreturn ret;\r\n}\r\nstatic int __driver_attach(struct device *dev, void *data)\r\n{\r\nstruct device_driver *drv = data;\r\nif (!driver_match_device(drv, dev))\r\nreturn 0;\r\nif (dev->parent)\r\ndevice_lock(dev->parent);\r\ndevice_lock(dev);\r\nif (!dev->driver)\r\ndriver_probe_device(drv, dev);\r\ndevice_unlock(dev);\r\nif (dev->parent)\r\ndevice_unlock(dev->parent);\r\nreturn 0;\r\n}\r\nint driver_attach(struct device_driver *drv)\r\n{\r\nreturn bus_for_each_dev(drv->bus, NULL, drv, __driver_attach);\r\n}\r\nstatic void __device_release_driver(struct device *dev)\r\n{\r\nstruct device_driver *drv;\r\ndrv = dev->driver;\r\nif (drv) {\r\npm_runtime_get_sync(dev);\r\ndriver_sysfs_remove(dev);\r\nif (dev->bus)\r\nblocking_notifier_call_chain(&dev->bus->p->bus_notifier,\r\nBUS_NOTIFY_UNBIND_DRIVER,\r\ndev);\r\npm_runtime_put_sync(dev);\r\nif (dev->bus && dev->bus->remove)\r\ndev->bus->remove(dev);\r\nelse if (drv->remove)\r\ndrv->remove(dev);\r\ndevres_release_all(dev);\r\ndev->driver = NULL;\r\nklist_remove(&dev->p->knode_driver);\r\nif (dev->bus)\r\nblocking_notifier_call_chain(&dev->bus->p->bus_notifier,\r\nBUS_NOTIFY_UNBOUND_DRIVER,\r\ndev);\r\n}\r\n}\r\nvoid device_release_driver(struct device *dev)\r\n{\r\ndevice_lock(dev);\r\n__device_release_driver(dev);\r\ndevice_unlock(dev);\r\n}\r\nvoid driver_detach(struct device_driver *drv)\r\n{\r\nstruct device_private *dev_prv;\r\nstruct device *dev;\r\nfor (;;) {\r\nspin_lock(&drv->p->klist_devices.k_lock);\r\nif (list_empty(&drv->p->klist_devices.k_list)) {\r\nspin_unlock(&drv->p->klist_devices.k_lock);\r\nbreak;\r\n}\r\ndev_prv = list_entry(drv->p->klist_devices.k_list.prev,\r\nstruct device_private,\r\nknode_driver.n_node);\r\ndev = dev_prv->device;\r\nget_device(dev);\r\nspin_unlock(&drv->p->klist_devices.k_lock);\r\nif (dev->parent)\r\ndevice_lock(dev->parent);\r\ndevice_lock(dev);\r\nif (dev->driver == drv)\r\n__device_release_driver(dev);\r\ndevice_unlock(dev);\r\nif (dev->parent)\r\ndevice_unlock(dev->parent);\r\nput_device(dev);\r\n}\r\n}\r\nvoid *dev_get_drvdata(const struct device *dev)\r\n{\r\nif (dev && dev->p)\r\nreturn dev->p->driver_data;\r\nreturn NULL;\r\n}\r\nint dev_set_drvdata(struct device *dev, void *data)\r\n{\r\nint error;\r\nif (!dev->p) {\r\nerror = device_private_init(dev);\r\nif (error)\r\nreturn error;\r\n}\r\ndev->p->driver_data = data;\r\nreturn 0;\r\n}
