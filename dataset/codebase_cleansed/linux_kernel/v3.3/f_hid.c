static inline struct f_hidg *func_to_hidg(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_hidg, func);\r\n}\r\nstatic ssize_t f_hidg_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ptr)\r\n{\r\nstruct f_hidg *hidg = file->private_data;\r\nchar *tmp_buff = NULL;\r\nunsigned long flags;\r\nif (!count)\r\nreturn 0;\r\nif (!access_ok(VERIFY_WRITE, buffer, count))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&hidg->spinlock, flags);\r\n#define READ_COND (hidg->set_report_buff != NULL)\r\nwhile (!READ_COND) {\r\nspin_unlock_irqrestore(&hidg->spinlock, flags);\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (wait_event_interruptible(hidg->read_queue, READ_COND))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irqsave(&hidg->spinlock, flags);\r\n}\r\ncount = min_t(unsigned, count, hidg->set_report_length);\r\ntmp_buff = hidg->set_report_buff;\r\nhidg->set_report_buff = NULL;\r\nspin_unlock_irqrestore(&hidg->spinlock, flags);\r\nif (tmp_buff != NULL) {\r\ncount -= copy_to_user(buffer, tmp_buff, count);\r\nkfree(tmp_buff);\r\n} else\r\ncount = -ENOMEM;\r\nreturn count;\r\n}\r\nstatic void f_hidg_req_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_hidg *hidg = (struct f_hidg *)ep->driver_data;\r\nif (req->status != 0) {\r\nERROR(hidg->func.config->cdev,\r\n"End Point Request ERROR: %d\n", req->status);\r\n}\r\nhidg->write_pending = 0;\r\nwake_up(&hidg->write_queue);\r\n}\r\nstatic ssize_t f_hidg_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *offp)\r\n{\r\nstruct f_hidg *hidg = file->private_data;\r\nssize_t status = -ENOMEM;\r\nif (!access_ok(VERIFY_READ, buffer, count))\r\nreturn -EFAULT;\r\nmutex_lock(&hidg->lock);\r\n#define WRITE_COND (!hidg->write_pending)\r\nwhile (!WRITE_COND) {\r\nmutex_unlock(&hidg->lock);\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (wait_event_interruptible_exclusive(\r\nhidg->write_queue, WRITE_COND))\r\nreturn -ERESTARTSYS;\r\nmutex_lock(&hidg->lock);\r\n}\r\ncount = min_t(unsigned, count, hidg->report_length);\r\nstatus = copy_from_user(hidg->req->buf, buffer, count);\r\nif (status != 0) {\r\nERROR(hidg->func.config->cdev,\r\n"copy_from_user error\n");\r\nmutex_unlock(&hidg->lock);\r\nreturn -EINVAL;\r\n}\r\nhidg->req->status = 0;\r\nhidg->req->zero = 0;\r\nhidg->req->length = count;\r\nhidg->req->complete = f_hidg_req_complete;\r\nhidg->req->context = hidg;\r\nhidg->write_pending = 1;\r\nstatus = usb_ep_queue(hidg->in_ep, hidg->req, GFP_ATOMIC);\r\nif (status < 0) {\r\nERROR(hidg->func.config->cdev,\r\n"usb_ep_queue error on int endpoint %zd\n", status);\r\nhidg->write_pending = 0;\r\nwake_up(&hidg->write_queue);\r\n} else {\r\nstatus = count;\r\n}\r\nmutex_unlock(&hidg->lock);\r\nreturn status;\r\n}\r\nstatic unsigned int f_hidg_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct f_hidg *hidg = file->private_data;\r\nunsigned int ret = 0;\r\npoll_wait(file, &hidg->read_queue, wait);\r\npoll_wait(file, &hidg->write_queue, wait);\r\nif (WRITE_COND)\r\nret |= POLLOUT | POLLWRNORM;\r\nif (READ_COND)\r\nret |= POLLIN | POLLRDNORM;\r\nreturn ret;\r\n}\r\nstatic int f_hidg_release(struct inode *inode, struct file *fd)\r\n{\r\nfd->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int f_hidg_open(struct inode *inode, struct file *fd)\r\n{\r\nstruct f_hidg *hidg =\r\ncontainer_of(inode->i_cdev, struct f_hidg, cdev);\r\nfd->private_data = hidg;\r\nreturn 0;\r\n}\r\nstatic void hidg_set_report_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_hidg *hidg = (struct f_hidg *)req->context;\r\nif (req->status != 0 || req->buf == NULL || req->actual == 0) {\r\nERROR(hidg->func.config->cdev, "%s FAILED\n", __func__);\r\nreturn;\r\n}\r\nspin_lock(&hidg->spinlock);\r\nhidg->set_report_buff = krealloc(hidg->set_report_buff,\r\nreq->actual, GFP_ATOMIC);\r\nif (hidg->set_report_buff == NULL) {\r\nspin_unlock(&hidg->spinlock);\r\nreturn;\r\n}\r\nhidg->set_report_length = req->actual;\r\nmemcpy(hidg->set_report_buff, req->buf, req->actual);\r\nspin_unlock(&hidg->spinlock);\r\nwake_up(&hidg->read_queue);\r\n}\r\nstatic int hidg_setup(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct f_hidg *hidg = func_to_hidg(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_request *req = cdev->req;\r\nint status = 0;\r\n__u16 value, length;\r\nvalue = __le16_to_cpu(ctrl->wValue);\r\nlength = __le16_to_cpu(ctrl->wLength);\r\nVDBG(cdev, "hid_setup crtl_request : bRequestType:0x%x bRequest:0x%x "\r\n"Value:0x%x\n", ctrl->bRequestType, ctrl->bRequest, value);\r\nswitch ((ctrl->bRequestType << 8) | ctrl->bRequest) {\r\ncase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8\r\n| HID_REQ_GET_REPORT):\r\nVDBG(cdev, "get_report\n");\r\nlength = min_t(unsigned, length, hidg->report_length);\r\nmemset(req->buf, 0x0, length);\r\ngoto respond;\r\nbreak;\r\ncase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8\r\n| HID_REQ_GET_PROTOCOL):\r\nVDBG(cdev, "get_protocol\n");\r\ngoto stall;\r\nbreak;\r\ncase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8\r\n| HID_REQ_SET_REPORT):\r\nVDBG(cdev, "set_report | wLenght=%d\n", ctrl->wLength);\r\nreq->context = hidg;\r\nreq->complete = hidg_set_report_complete;\r\ngoto respond;\r\nbreak;\r\ncase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8\r\n| HID_REQ_SET_PROTOCOL):\r\nVDBG(cdev, "set_protocol\n");\r\ngoto stall;\r\nbreak;\r\ncase ((USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_INTERFACE) << 8\r\n| USB_REQ_GET_DESCRIPTOR):\r\nswitch (value >> 8) {\r\ncase HID_DT_HID:\r\nVDBG(cdev, "USB_REQ_GET_DESCRIPTOR: HID\n");\r\nlength = min_t(unsigned short, length,\r\nhidg_desc.bLength);\r\nmemcpy(req->buf, &hidg_desc, length);\r\ngoto respond;\r\nbreak;\r\ncase HID_DT_REPORT:\r\nVDBG(cdev, "USB_REQ_GET_DESCRIPTOR: REPORT\n");\r\nlength = min_t(unsigned short, length,\r\nhidg->report_desc_length);\r\nmemcpy(req->buf, hidg->report_desc, length);\r\ngoto respond;\r\nbreak;\r\ndefault:\r\nVDBG(cdev, "Unknown decriptor request 0x%x\n",\r\nvalue >> 8);\r\ngoto stall;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nVDBG(cdev, "Unknown request 0x%x\n",\r\nctrl->bRequest);\r\ngoto stall;\r\nbreak;\r\n}\r\nstall:\r\nreturn -EOPNOTSUPP;\r\nrespond:\r\nreq->zero = 0;\r\nreq->length = length;\r\nstatus = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (status < 0)\r\nERROR(cdev, "usb_ep_queue error on ep0 %d\n", value);\r\nreturn status;\r\n}\r\nstatic void hidg_disable(struct usb_function *f)\r\n{\r\nstruct f_hidg *hidg = func_to_hidg(f);\r\nusb_ep_disable(hidg->in_ep);\r\nhidg->in_ep->driver_data = NULL;\r\n}\r\nstatic int hidg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct f_hidg *hidg = func_to_hidg(f);\r\nint status = 0;\r\nVDBG(cdev, "hidg_set_alt intf:%d alt:%d\n", intf, alt);\r\nif (hidg->in_ep != NULL) {\r\nif (hidg->in_ep->driver_data != NULL)\r\nusb_ep_disable(hidg->in_ep);\r\nstatus = config_ep_by_speed(f->config->cdev->gadget, f,\r\nhidg->in_ep);\r\nif (status) {\r\nERROR(cdev, "config_ep_by_speed FAILED!\n");\r\ngoto fail;\r\n}\r\nstatus = usb_ep_enable(hidg->in_ep);\r\nif (status < 0) {\r\nERROR(cdev, "Enable endpoint FAILED!\n");\r\ngoto fail;\r\n}\r\nhidg->in_ep->driver_data = hidg;\r\n}\r\nfail:\r\nreturn status;\r\n}\r\nstatic int __init hidg_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_ep *ep;\r\nstruct f_hidg *hidg = func_to_hidg(f);\r\nint status;\r\ndev_t dev;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nhidg_interface_desc.bInterfaceNumber = status;\r\nstatus = -ENODEV;\r\nep = usb_ep_autoconfig(c->cdev->gadget, &hidg_fs_in_ep_desc);\r\nif (!ep)\r\ngoto fail;\r\nep->driver_data = c->cdev;\r\nhidg->in_ep = ep;\r\nstatus = -ENOMEM;\r\nhidg->req = usb_ep_alloc_request(hidg->in_ep, GFP_KERNEL);\r\nif (!hidg->req)\r\ngoto fail;\r\nhidg->req->buf = kmalloc(hidg->report_length, GFP_KERNEL);\r\nif (!hidg->req->buf)\r\ngoto fail;\r\nhidg_interface_desc.bInterfaceSubClass = hidg->bInterfaceSubClass;\r\nhidg_interface_desc.bInterfaceProtocol = hidg->bInterfaceProtocol;\r\nhidg_hs_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\r\nhidg_fs_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\r\nhidg_desc.desc[0].bDescriptorType = HID_DT_REPORT;\r\nhidg_desc.desc[0].wDescriptorLength =\r\ncpu_to_le16(hidg->report_desc_length);\r\nhidg->set_report_buff = NULL;\r\nf->descriptors = usb_copy_descriptors(hidg_fs_descriptors);\r\nif (!f->descriptors)\r\ngoto fail;\r\nif (gadget_is_dualspeed(c->cdev->gadget)) {\r\nhidg_hs_in_ep_desc.bEndpointAddress =\r\nhidg_fs_in_ep_desc.bEndpointAddress;\r\nf->hs_descriptors = usb_copy_descriptors(hidg_hs_descriptors);\r\nif (!f->hs_descriptors)\r\ngoto fail;\r\n}\r\nmutex_init(&hidg->lock);\r\nspin_lock_init(&hidg->spinlock);\r\ninit_waitqueue_head(&hidg->write_queue);\r\ninit_waitqueue_head(&hidg->read_queue);\r\ncdev_init(&hidg->cdev, &f_hidg_fops);\r\ndev = MKDEV(major, hidg->minor);\r\nstatus = cdev_add(&hidg->cdev, dev, 1);\r\nif (status)\r\ngoto fail;\r\ndevice_create(hidg_class, NULL, dev, NULL, "%s%d", "hidg", hidg->minor);\r\nreturn 0;\r\nfail:\r\nERROR(f->config->cdev, "hidg_bind FAILED\n");\r\nif (hidg->req != NULL) {\r\nkfree(hidg->req->buf);\r\nif (hidg->in_ep != NULL)\r\nusb_ep_free_request(hidg->in_ep, hidg->req);\r\n}\r\nusb_free_descriptors(f->hs_descriptors);\r\nusb_free_descriptors(f->descriptors);\r\nreturn status;\r\n}\r\nstatic void hidg_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct f_hidg *hidg = func_to_hidg(f);\r\ndevice_destroy(hidg_class, MKDEV(major, hidg->minor));\r\ncdev_del(&hidg->cdev);\r\nusb_ep_disable(hidg->in_ep);\r\nusb_ep_dequeue(hidg->in_ep, hidg->req);\r\nkfree(hidg->req->buf);\r\nusb_ep_free_request(hidg->in_ep, hidg->req);\r\nusb_free_descriptors(f->hs_descriptors);\r\nusb_free_descriptors(f->descriptors);\r\nkfree(hidg->report_desc);\r\nkfree(hidg->set_report_buff);\r\nkfree(hidg);\r\n}\r\nint __init hidg_bind_config(struct usb_configuration *c,\r\nstruct hidg_func_descriptor *fdesc, int index)\r\n{\r\nstruct f_hidg *hidg;\r\nint status;\r\nif (index >= minors)\r\nreturn -ENOENT;\r\nif (ct_func_string_defs[CT_FUNC_HID_IDX].id == 0) {\r\nstatus = usb_string_id(c->cdev);\r\nif (status < 0)\r\nreturn status;\r\nct_func_string_defs[CT_FUNC_HID_IDX].id = status;\r\nhidg_interface_desc.iInterface = status;\r\n}\r\nhidg = kzalloc(sizeof *hidg, GFP_KERNEL);\r\nif (!hidg)\r\nreturn -ENOMEM;\r\nhidg->minor = index;\r\nhidg->bInterfaceSubClass = fdesc->subclass;\r\nhidg->bInterfaceProtocol = fdesc->protocol;\r\nhidg->report_length = fdesc->report_length;\r\nhidg->report_desc_length = fdesc->report_desc_length;\r\nhidg->report_desc = kmemdup(fdesc->report_desc,\r\nfdesc->report_desc_length,\r\nGFP_KERNEL);\r\nif (!hidg->report_desc) {\r\nkfree(hidg);\r\nreturn -ENOMEM;\r\n}\r\nhidg->func.name = "hid";\r\nhidg->func.strings = ct_func_strings;\r\nhidg->func.bind = hidg_bind;\r\nhidg->func.unbind = hidg_unbind;\r\nhidg->func.set_alt = hidg_set_alt;\r\nhidg->func.disable = hidg_disable;\r\nhidg->func.setup = hidg_setup;\r\nstatus = usb_add_function(c, &hidg->func);\r\nif (status)\r\nkfree(hidg);\r\nreturn status;\r\n}\r\nint __init ghid_setup(struct usb_gadget *g, int count)\r\n{\r\nint status;\r\ndev_t dev;\r\nhidg_class = class_create(THIS_MODULE, "hidg");\r\nstatus = alloc_chrdev_region(&dev, 0, count, "hidg");\r\nif (!status) {\r\nmajor = MAJOR(dev);\r\nminors = count;\r\n}\r\nreturn status;\r\n}\r\nvoid ghid_cleanup(void)\r\n{\r\nif (major) {\r\nunregister_chrdev_region(MKDEV(major, 0), minors);\r\nmajor = minors = 0;\r\n}\r\nclass_destroy(hidg_class);\r\nhidg_class = NULL;\r\n}
