static irqreturn_t ps2_rxint(int irq, void *dev_id)\r\n{\r\nstruct ps2if *ps2if = dev_id;\r\nunsigned int scancode, flag, status;\r\nstatus = sa1111_readl(ps2if->base + SA1111_PS2STAT);\r\nwhile (status & PS2STAT_RXF) {\r\nif (status & PS2STAT_STP)\r\nsa1111_writel(PS2STAT_STP, ps2if->base + SA1111_PS2STAT);\r\nflag = (status & PS2STAT_STP ? SERIO_FRAME : 0) |\r\n(status & PS2STAT_RXP ? 0 : SERIO_PARITY);\r\nscancode = sa1111_readl(ps2if->base + SA1111_PS2DATA) & 0xff;\r\nif (hweight8(scancode) & 1)\r\nflag ^= SERIO_PARITY;\r\nserio_interrupt(ps2if->io, scancode, flag);\r\nstatus = sa1111_readl(ps2if->base + SA1111_PS2STAT);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ps2_txint(int irq, void *dev_id)\r\n{\r\nstruct ps2if *ps2if = dev_id;\r\nunsigned int status;\r\nspin_lock(&ps2if->lock);\r\nstatus = sa1111_readl(ps2if->base + SA1111_PS2STAT);\r\nif (ps2if->head == ps2if->tail) {\r\ndisable_irq_nosync(irq);\r\n} else if (status & PS2STAT_TXE) {\r\nsa1111_writel(ps2if->buf[ps2if->tail], ps2if->base + SA1111_PS2DATA);\r\nps2if->tail = (ps2if->tail + 1) & (sizeof(ps2if->buf) - 1);\r\n}\r\nspin_unlock(&ps2if->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ps2_write(struct serio *io, unsigned char val)\r\n{\r\nstruct ps2if *ps2if = io->port_data;\r\nunsigned long flags;\r\nunsigned int head;\r\nspin_lock_irqsave(&ps2if->lock, flags);\r\nif (sa1111_readl(ps2if->base + SA1111_PS2STAT) & PS2STAT_TXE) {\r\nsa1111_writel(val, ps2if->base + SA1111_PS2DATA);\r\n} else {\r\nif (ps2if->head == ps2if->tail)\r\nenable_irq(ps2if->dev->irq[1]);\r\nhead = (ps2if->head + 1) & (sizeof(ps2if->buf) - 1);\r\nif (head != ps2if->tail) {\r\nps2if->buf[ps2if->head] = val;\r\nps2if->head = head;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ps2if->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ps2_open(struct serio *io)\r\n{\r\nstruct ps2if *ps2if = io->port_data;\r\nint ret;\r\nsa1111_enable_device(ps2if->dev);\r\nret = request_irq(ps2if->dev->irq[0], ps2_rxint, 0,\r\nSA1111_DRIVER_NAME(ps2if->dev), ps2if);\r\nif (ret) {\r\nprintk(KERN_ERR "sa1111ps2: could not allocate IRQ%d: %d\n",\r\nps2if->dev->irq[0], ret);\r\nreturn ret;\r\n}\r\nret = request_irq(ps2if->dev->irq[1], ps2_txint, 0,\r\nSA1111_DRIVER_NAME(ps2if->dev), ps2if);\r\nif (ret) {\r\nprintk(KERN_ERR "sa1111ps2: could not allocate IRQ%d: %d\n",\r\nps2if->dev->irq[1], ret);\r\nfree_irq(ps2if->dev->irq[0], ps2if);\r\nreturn ret;\r\n}\r\nps2if->open = 1;\r\nenable_irq_wake(ps2if->dev->irq[0]);\r\nsa1111_writel(PS2CR_ENA, ps2if->base + SA1111_PS2CR);\r\nreturn 0;\r\n}\r\nstatic void ps2_close(struct serio *io)\r\n{\r\nstruct ps2if *ps2if = io->port_data;\r\nsa1111_writel(0, ps2if->base + SA1111_PS2CR);\r\ndisable_irq_wake(ps2if->dev->irq[0]);\r\nps2if->open = 0;\r\nfree_irq(ps2if->dev->irq[1], ps2if);\r\nfree_irq(ps2if->dev->irq[0], ps2if);\r\nsa1111_disable_device(ps2if->dev);\r\n}\r\nstatic void __devinit ps2_clear_input(struct ps2if *ps2if)\r\n{\r\nint maxread = 100;\r\nwhile (maxread--) {\r\nif ((sa1111_readl(ps2if->base + SA1111_PS2DATA) & 0xff) == 0xff)\r\nbreak;\r\n}\r\n}\r\nstatic unsigned int __devinit ps2_test_one(struct ps2if *ps2if,\r\nunsigned int mask)\r\n{\r\nunsigned int val;\r\nsa1111_writel(PS2CR_ENA | mask, ps2if->base + SA1111_PS2CR);\r\nudelay(2);\r\nval = sa1111_readl(ps2if->base + SA1111_PS2STAT);\r\nreturn val & (PS2STAT_KBC | PS2STAT_KBD);\r\n}\r\nstatic int __devinit ps2_test(struct ps2if *ps2if)\r\n{\r\nunsigned int stat;\r\nint ret = 0;\r\nstat = ps2_test_one(ps2if, PS2CR_FKC);\r\nif (stat != PS2STAT_KBD) {\r\nprintk("PS/2 interface test failed[1]: %02x\n", stat);\r\nret = -ENODEV;\r\n}\r\nstat = ps2_test_one(ps2if, 0);\r\nif (stat != (PS2STAT_KBC | PS2STAT_KBD)) {\r\nprintk("PS/2 interface test failed[2]: %02x\n", stat);\r\nret = -ENODEV;\r\n}\r\nstat = ps2_test_one(ps2if, PS2CR_FKD);\r\nif (stat != PS2STAT_KBC) {\r\nprintk("PS/2 interface test failed[3]: %02x\n", stat);\r\nret = -ENODEV;\r\n}\r\nsa1111_writel(0, ps2if->base + SA1111_PS2CR);\r\nreturn ret;\r\n}\r\nstatic int __devinit ps2_probe(struct sa1111_dev *dev)\r\n{\r\nstruct ps2if *ps2if;\r\nstruct serio *serio;\r\nint ret;\r\nps2if = kzalloc(sizeof(struct ps2if), GFP_KERNEL);\r\nserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!ps2if || !serio) {\r\nret = -ENOMEM;\r\ngoto free;\r\n}\r\nserio->id.type = SERIO_8042;\r\nserio->write = ps2_write;\r\nserio->open = ps2_open;\r\nserio->close = ps2_close;\r\nstrlcpy(serio->name, dev_name(&dev->dev), sizeof(serio->name));\r\nstrlcpy(serio->phys, dev_name(&dev->dev), sizeof(serio->phys));\r\nserio->port_data = ps2if;\r\nserio->dev.parent = &dev->dev;\r\nps2if->io = serio;\r\nps2if->dev = dev;\r\nsa1111_set_drvdata(dev, ps2if);\r\nspin_lock_init(&ps2if->lock);\r\nif (!request_mem_region(dev->res.start,\r\ndev->res.end - dev->res.start + 1,\r\nSA1111_DRIVER_NAME(dev))) {\r\nret = -EBUSY;\r\ngoto free;\r\n}\r\nps2if->base = dev->mapbase;\r\nsa1111_enable_device(ps2if->dev);\r\nsa1111_writel(0, ps2if->base + SA1111_PS2CLKDIV);\r\nsa1111_writel(127, ps2if->base + SA1111_PS2PRECNT);\r\nps2_clear_input(ps2if);\r\nret = ps2_test(ps2if);\r\nif (ret)\r\ngoto out;\r\nps2_clear_input(ps2if);\r\nsa1111_disable_device(ps2if->dev);\r\nserio_register_port(ps2if->io);\r\nreturn 0;\r\nout:\r\nsa1111_disable_device(ps2if->dev);\r\nrelease_mem_region(dev->res.start, resource_size(&dev->res));\r\nfree:\r\nsa1111_set_drvdata(dev, NULL);\r\nkfree(ps2if);\r\nkfree(serio);\r\nreturn ret;\r\n}\r\nstatic int __devexit ps2_remove(struct sa1111_dev *dev)\r\n{\r\nstruct ps2if *ps2if = sa1111_get_drvdata(dev);\r\nserio_unregister_port(ps2if->io);\r\nrelease_mem_region(dev->res.start, resource_size(&dev->res));\r\nsa1111_set_drvdata(dev, NULL);\r\nkfree(ps2if);\r\nreturn 0;\r\n}\r\nstatic int __init ps2_init(void)\r\n{\r\nreturn sa1111_driver_register(&ps2_driver);\r\n}\r\nstatic void __exit ps2_exit(void)\r\n{\r\nsa1111_driver_unregister(&ps2_driver);\r\n}
