static void __init search_IAR(void)\r\n{\r\nunsigned ivg, irq_pos = 0;\r\nfor (ivg = 0; ivg <= IVG13 - IVG7; ivg++) {\r\nint irqN;\r\nivg7_13[ivg].istop = ivg7_13[ivg].ifirst = &ivg_table[irq_pos];\r\nfor (irqN = 0; irqN < NR_PERI_INTS; irqN += 4) {\r\nint irqn;\r\nu32 iar = bfin_read32((unsigned long *)SIC_IAR0 +\r\n#if defined(CONFIG_BF51x) || defined(CONFIG_BF52x) || \\r\ndefined(CONFIG_BF538) || defined(CONFIG_BF539)\r\n((irqN % 32) >> 3) + ((irqN / 32) * ((SIC_IAR4 - SIC_IAR0) / 4))\r\n#else\r\n(irqN >> 3)\r\n#endif\r\n);\r\nfor (irqn = irqN; irqn < irqN + 4; ++irqn) {\r\nint iar_shift = (irqn & 7) * 4;\r\nif (ivg == (0xf & (iar >> iar_shift))) {\r\nivg_table[irq_pos].irqno = IVG7 + irqn;\r\nivg_table[irq_pos].isrflag = 1 << (irqn % 32);\r\nivg7_13[ivg].istop++;\r\nirq_pos++;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nvoid bfin_ack_noop(struct irq_data *d)\r\n{\r\n}\r\nstatic void bfin_core_mask_irq(struct irq_data *d)\r\n{\r\nbfin_irq_flags &= ~(1 << d->irq);\r\nif (!hard_irqs_disabled())\r\nhard_local_irq_enable();\r\n}\r\nstatic void bfin_core_unmask_irq(struct irq_data *d)\r\n{\r\nbfin_irq_flags |= 1 << d->irq;\r\nif (!hard_irqs_disabled())\r\nhard_local_irq_enable();\r\nreturn;\r\n}\r\nvoid bfin_internal_mask_irq(unsigned int irq)\r\n{\r\nunsigned long flags = hard_local_irq_save();\r\n#ifdef SIC_IMASK0\r\nunsigned mask_bank = SIC_SYSIRQ(irq) / 32;\r\nunsigned mask_bit = SIC_SYSIRQ(irq) % 32;\r\nbfin_write_SIC_IMASK(mask_bank, bfin_read_SIC_IMASK(mask_bank) &\r\n~(1 << mask_bit));\r\n# ifdef CONFIG_SMP\r\nbfin_write_SICB_IMASK(mask_bank, bfin_read_SICB_IMASK(mask_bank) &\r\n~(1 << mask_bit));\r\n# endif\r\n#else\r\nbfin_write_SIC_IMASK(bfin_read_SIC_IMASK() &\r\n~(1 << SIC_SYSIRQ(irq)));\r\n#endif\r\nhard_local_irq_restore(flags);\r\n}\r\nstatic void bfin_internal_mask_irq_chip(struct irq_data *d)\r\n{\r\nbfin_internal_mask_irq(d->irq);\r\n}\r\nstatic void bfin_internal_unmask_irq_chip(struct irq_data *d)\r\n{\r\nbfin_internal_unmask_irq_affinity(d->irq, d->affinity);\r\n}\r\nstatic int bfin_internal_set_affinity(struct irq_data *d,\r\nconst struct cpumask *mask, bool force)\r\n{\r\nbfin_internal_mask_irq(d->irq);\r\nbfin_internal_unmask_irq_affinity(d->irq, mask);\r\nreturn 0;\r\n}\r\nstatic void bfin_internal_unmask_irq_chip(struct irq_data *d)\r\n{\r\nbfin_internal_unmask_irq(d->irq);\r\n}\r\nint bfin_internal_set_wake(unsigned int irq, unsigned int state)\r\n{\r\nu32 bank, bit, wakeup = 0;\r\nunsigned long flags;\r\nbank = SIC_SYSIRQ(irq) / 32;\r\nbit = SIC_SYSIRQ(irq) % 32;\r\nswitch (irq) {\r\n#ifdef IRQ_RTC\r\ncase IRQ_RTC:\r\nwakeup |= WAKE;\r\nbreak;\r\n#endif\r\n#ifdef IRQ_CAN0_RX\r\ncase IRQ_CAN0_RX:\r\nwakeup |= CANWE;\r\nbreak;\r\n#endif\r\n#ifdef IRQ_CAN1_RX\r\ncase IRQ_CAN1_RX:\r\nwakeup |= CANWE;\r\nbreak;\r\n#endif\r\n#ifdef IRQ_USB_INT0\r\ncase IRQ_USB_INT0:\r\nwakeup |= USBWE;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_BF54x\r\ncase IRQ_CNT:\r\nwakeup |= ROTWE;\r\nbreak;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\nflags = hard_local_irq_save();\r\nif (state) {\r\nbfin_sic_iwr[bank] |= (1 << bit);\r\nvr_wakeup |= wakeup;\r\n} else {\r\nbfin_sic_iwr[bank] &= ~(1 << bit);\r\nvr_wakeup &= ~wakeup;\r\n}\r\nhard_local_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int bfin_internal_set_wake_chip(struct irq_data *d, unsigned int state)\r\n{\r\nreturn bfin_internal_set_wake(d->irq, state);\r\n}\r\nvoid bfin_handle_irq(unsigned irq)\r\n{\r\n#ifdef CONFIG_IPIPE\r\nstruct pt_regs regs;\r\nipipe_trace_irq_entry(irq);\r\n__ipipe_handle_irq(irq, &regs);\r\nipipe_trace_irq_exit(irq);\r\n#else\r\ngeneric_handle_irq(irq);\r\n#endif\r\n}\r\nstatic void bfin_mac_status_ack_irq(unsigned int irq)\r\n{\r\nswitch (irq) {\r\ncase IRQ_MAC_MMCINT:\r\nbfin_write_EMAC_MMC_TIRQS(\r\nbfin_read_EMAC_MMC_TIRQE() &\r\nbfin_read_EMAC_MMC_TIRQS());\r\nbfin_write_EMAC_MMC_RIRQS(\r\nbfin_read_EMAC_MMC_RIRQE() &\r\nbfin_read_EMAC_MMC_RIRQS());\r\nbreak;\r\ncase IRQ_MAC_RXFSINT:\r\nbfin_write_EMAC_RX_STKY(\r\nbfin_read_EMAC_RX_IRQE() &\r\nbfin_read_EMAC_RX_STKY());\r\nbreak;\r\ncase IRQ_MAC_TXFSINT:\r\nbfin_write_EMAC_TX_STKY(\r\nbfin_read_EMAC_TX_IRQE() &\r\nbfin_read_EMAC_TX_STKY());\r\nbreak;\r\ncase IRQ_MAC_WAKEDET:\r\nbfin_write_EMAC_WKUP_CTL(\r\nbfin_read_EMAC_WKUP_CTL() | MPKS | RWKS);\r\nbreak;\r\ndefault:\r\nbfin_write_EMAC_SYSTAT(1L << (irq - IRQ_MAC_PHYINT));\r\nbreak;\r\n}\r\n}\r\nstatic void bfin_mac_status_mask_irq(struct irq_data *d)\r\n{\r\nunsigned int irq = d->irq;\r\nmac_stat_int_mask &= ~(1L << (irq - IRQ_MAC_PHYINT));\r\n#ifdef BF537_FAMILY\r\nswitch (irq) {\r\ncase IRQ_MAC_PHYINT:\r\nbfin_write_EMAC_SYSCTL(bfin_read_EMAC_SYSCTL() & ~PHYIE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n#else\r\nif (!mac_stat_int_mask)\r\nbfin_internal_mask_irq(IRQ_MAC_ERROR);\r\n#endif\r\nbfin_mac_status_ack_irq(irq);\r\n}\r\nstatic void bfin_mac_status_unmask_irq(struct irq_data *d)\r\n{\r\nunsigned int irq = d->irq;\r\n#ifdef BF537_FAMILY\r\nswitch (irq) {\r\ncase IRQ_MAC_PHYINT:\r\nbfin_write_EMAC_SYSCTL(bfin_read_EMAC_SYSCTL() | PHYIE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n#else\r\nif (!mac_stat_int_mask)\r\nbfin_internal_unmask_irq(IRQ_MAC_ERROR);\r\n#endif\r\nmac_stat_int_mask |= 1L << (irq - IRQ_MAC_PHYINT);\r\n}\r\nint bfin_mac_status_set_wake(struct irq_data *d, unsigned int state)\r\n{\r\n#ifdef BF537_FAMILY\r\nreturn bfin_internal_set_wake(IRQ_GENERIC_ERROR, state);\r\n#else\r\nreturn bfin_internal_set_wake(IRQ_MAC_ERROR, state);\r\n#endif\r\n}\r\nvoid bfin_demux_mac_status_irq(unsigned int int_err_irq,\r\nstruct irq_desc *inta_desc)\r\n{\r\nint i, irq = 0;\r\nu32 status = bfin_read_EMAC_SYSTAT();\r\nfor (i = 0; i <= (IRQ_MAC_STMDONE - IRQ_MAC_PHYINT); i++)\r\nif (status & (1L << i)) {\r\nirq = IRQ_MAC_PHYINT + i;\r\nbreak;\r\n}\r\nif (irq) {\r\nif (mac_stat_int_mask & (1L << (irq - IRQ_MAC_PHYINT))) {\r\nbfin_handle_irq(irq);\r\n} else {\r\nbfin_mac_status_ack_irq(irq);\r\npr_debug("IRQ %d:"\r\n" MASKED MAC ERROR INTERRUPT ASSERTED\n",\r\nirq);\r\n}\r\n} else\r\nprintk(KERN_ERR\r\n"%s : %s : LINE %d :\nIRQ ?: MAC ERROR"\r\n" INTERRUPT ASSERTED BUT NO SOURCE FOUND"\r\n"(EMAC_SYSTAT=0x%X)\n",\r\n__func__, __FILE__, __LINE__, status);\r\n}\r\nstatic inline void bfin_set_irq_handler(unsigned irq, irq_flow_handler_t handle)\r\n{\r\n#ifdef CONFIG_IPIPE\r\nhandle = handle_level_irq;\r\n#endif\r\n__irq_set_handler_locked(irq, handle);\r\n}\r\nstatic void bfin_gpio_ack_irq(struct irq_data *d)\r\n{\r\nset_gpio_data(irq_to_gpio(d->irq), 0);\r\n}\r\nstatic void bfin_gpio_mask_ack_irq(struct irq_data *d)\r\n{\r\nunsigned int irq = d->irq;\r\nu32 gpionr = irq_to_gpio(irq);\r\nif (!irqd_is_level_type(d))\r\nset_gpio_data(gpionr, 0);\r\nset_gpio_maska(gpionr, 0);\r\n}\r\nstatic void bfin_gpio_mask_irq(struct irq_data *d)\r\n{\r\nset_gpio_maska(irq_to_gpio(d->irq), 0);\r\n}\r\nstatic void bfin_gpio_unmask_irq(struct irq_data *d)\r\n{\r\nset_gpio_maska(irq_to_gpio(d->irq), 1);\r\n}\r\nstatic unsigned int bfin_gpio_irq_startup(struct irq_data *d)\r\n{\r\nu32 gpionr = irq_to_gpio(d->irq);\r\nif (__test_and_set_bit(gpionr, gpio_enabled))\r\nbfin_gpio_irq_prepare(gpionr);\r\nbfin_gpio_unmask_irq(d);\r\nreturn 0;\r\n}\r\nstatic void bfin_gpio_irq_shutdown(struct irq_data *d)\r\n{\r\nu32 gpionr = irq_to_gpio(d->irq);\r\nbfin_gpio_mask_irq(d);\r\n__clear_bit(gpionr, gpio_enabled);\r\nbfin_gpio_irq_free(gpionr);\r\n}\r\nstatic int bfin_gpio_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nunsigned int irq = d->irq;\r\nint ret;\r\nchar buf[16];\r\nu32 gpionr = irq_to_gpio(irq);\r\nif (type == IRQ_TYPE_PROBE) {\r\nif (test_bit(gpionr, gpio_enabled))\r\nreturn 0;\r\ntype = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;\r\n}\r\nif (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING |\r\nIRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {\r\nsnprintf(buf, 16, "gpio-irq%d", irq);\r\nret = bfin_gpio_irq_request(gpionr, buf);\r\nif (ret)\r\nreturn ret;\r\nif (__test_and_set_bit(gpionr, gpio_enabled))\r\nbfin_gpio_irq_prepare(gpionr);\r\n} else {\r\n__clear_bit(gpionr, gpio_enabled);\r\nreturn 0;\r\n}\r\nset_gpio_inen(gpionr, 0);\r\nset_gpio_dir(gpionr, 0);\r\nif ((type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING))\r\n== (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING))\r\nset_gpio_both(gpionr, 1);\r\nelse\r\nset_gpio_both(gpionr, 0);\r\nif ((type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_LEVEL_LOW)))\r\nset_gpio_polar(gpionr, 1);\r\nelse\r\nset_gpio_polar(gpionr, 0);\r\nif (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) {\r\nset_gpio_edge(gpionr, 1);\r\nset_gpio_inen(gpionr, 1);\r\nset_gpio_data(gpionr, 0);\r\n} else {\r\nset_gpio_edge(gpionr, 0);\r\nset_gpio_inen(gpionr, 1);\r\n}\r\nif (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING))\r\nbfin_set_irq_handler(irq, handle_edge_irq);\r\nelse\r\nbfin_set_irq_handler(irq, handle_level_irq);\r\nreturn 0;\r\n}\r\nstatic int bfin_gpio_set_wake(struct irq_data *d, unsigned int state)\r\n{\r\nreturn gpio_pm_wakeup_ctrl(irq_to_gpio(d->irq), state);\r\n}\r\nstatic void bfin_demux_gpio_block(unsigned int irq)\r\n{\r\nunsigned int gpio, mask;\r\ngpio = irq_to_gpio(irq);\r\nmask = get_gpiop_data(gpio) & get_gpiop_maska(gpio);\r\nwhile (mask) {\r\nif (mask & 1)\r\nbfin_handle_irq(irq);\r\nirq++;\r\nmask >>= 1;\r\n}\r\n}\r\nvoid bfin_demux_gpio_irq(unsigned int inta_irq,\r\nstruct irq_desc *desc)\r\n{\r\nunsigned int irq;\r\nswitch (inta_irq) {\r\n#if defined(BF537_FAMILY)\r\ncase IRQ_PF_INTA_PG_INTA:\r\nbfin_demux_gpio_block(IRQ_PF0);\r\nirq = IRQ_PG0;\r\nbreak;\r\ncase IRQ_PH_INTA_MAC_RX:\r\nirq = IRQ_PH0;\r\nbreak;\r\n#elif defined(BF533_FAMILY)\r\ncase IRQ_PROG_INTA:\r\nirq = IRQ_PF0;\r\nbreak;\r\n#elif defined(BF538_FAMILY)\r\ncase IRQ_PORTF_INTA:\r\nirq = IRQ_PF0;\r\nbreak;\r\n#elif defined(CONFIG_BF52x) || defined(CONFIG_BF51x)\r\ncase IRQ_PORTF_INTA:\r\nirq = IRQ_PF0;\r\nbreak;\r\ncase IRQ_PORTG_INTA:\r\nirq = IRQ_PG0;\r\nbreak;\r\ncase IRQ_PORTH_INTA:\r\nirq = IRQ_PH0;\r\nbreak;\r\n#elif defined(CONFIG_BF561)\r\ncase IRQ_PROG0_INTA:\r\nirq = IRQ_PF0;\r\nbreak;\r\ncase IRQ_PROG1_INTA:\r\nirq = IRQ_PF16;\r\nbreak;\r\ncase IRQ_PROG2_INTA:\r\nirq = IRQ_PF32;\r\nbreak;\r\n#endif\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\nbfin_demux_gpio_block(irq);\r\n}\r\ninline unsigned int get_irq_base(u32 bank, u8 bmap)\r\n{\r\nunsigned int irq_base;\r\nif (bank < 2) {\r\nirq_base = IRQ_PA0 + bmap * 16;\r\n} else {\r\nirq_base = IRQ_PC0 + bmap * 16;\r\n}\r\nreturn irq_base;\r\n}\r\nvoid init_pint_lut(void)\r\n{\r\nu16 bank, bit, irq_base, bit_pos;\r\nu32 pint_assign;\r\nu8 bmap;\r\nmemset(irq2pint_lut, IRQ_NOT_AVAIL, sizeof(irq2pint_lut));\r\nfor (bank = 0; bank < NR_PINT_SYS_IRQS; bank++) {\r\npint_assign = pint[bank]->assign;\r\nfor (bit = 0; bit < NR_PINT_BITS; bit++) {\r\nbmap = (pint_assign >> ((bit / 8) * 8)) & 0xFF;\r\nirq_base = get_irq_base(bank, bmap);\r\nirq_base += (bit % 8) + ((bit / 8) & 1 ? 8 : 0);\r\nbit_pos = bit + bank * NR_PINT_BITS;\r\npint2irq_lut[bit_pos] = irq_base - SYS_IRQS;\r\nirq2pint_lut[irq_base - SYS_IRQS] = bit_pos;\r\n}\r\n}\r\n}\r\nstatic void bfin_gpio_ack_irq(struct irq_data *d)\r\n{\r\nu32 pint_val = irq2pint_lut[d->irq - SYS_IRQS];\r\nu32 pintbit = PINT_BIT(pint_val);\r\nu32 bank = PINT_2_BANK(pint_val);\r\nif (irqd_get_trigger_type(d) == IRQ_TYPE_EDGE_BOTH) {\r\nif (pint[bank]->invert_set & pintbit)\r\npint[bank]->invert_clear = pintbit;\r\nelse\r\npint[bank]->invert_set = pintbit;\r\n}\r\npint[bank]->request = pintbit;\r\n}\r\nstatic void bfin_gpio_mask_ack_irq(struct irq_data *d)\r\n{\r\nu32 pint_val = irq2pint_lut[d->irq - SYS_IRQS];\r\nu32 pintbit = PINT_BIT(pint_val);\r\nu32 bank = PINT_2_BANK(pint_val);\r\nif (irqd_get_trigger_type(d) == IRQ_TYPE_EDGE_BOTH) {\r\nif (pint[bank]->invert_set & pintbit)\r\npint[bank]->invert_clear = pintbit;\r\nelse\r\npint[bank]->invert_set = pintbit;\r\n}\r\npint[bank]->request = pintbit;\r\npint[bank]->mask_clear = pintbit;\r\n}\r\nstatic void bfin_gpio_mask_irq(struct irq_data *d)\r\n{\r\nu32 pint_val = irq2pint_lut[d->irq - SYS_IRQS];\r\npint[PINT_2_BANK(pint_val)]->mask_clear = PINT_BIT(pint_val);\r\n}\r\nstatic void bfin_gpio_unmask_irq(struct irq_data *d)\r\n{\r\nu32 pint_val = irq2pint_lut[d->irq - SYS_IRQS];\r\nu32 pintbit = PINT_BIT(pint_val);\r\nu32 bank = PINT_2_BANK(pint_val);\r\npint[bank]->mask_set = pintbit;\r\n}\r\nstatic unsigned int bfin_gpio_irq_startup(struct irq_data *d)\r\n{\r\nunsigned int irq = d->irq;\r\nu32 gpionr = irq_to_gpio(irq);\r\nu32 pint_val = irq2pint_lut[irq - SYS_IRQS];\r\nif (pint_val == IRQ_NOT_AVAIL) {\r\nprintk(KERN_ERR\r\n"GPIO IRQ %d :Not in PINT Assign table "\r\n"Reconfigure Interrupt to Port Assignemt\n", irq);\r\nreturn -ENODEV;\r\n}\r\nif (__test_and_set_bit(gpionr, gpio_enabled))\r\nbfin_gpio_irq_prepare(gpionr);\r\nbfin_gpio_unmask_irq(d);\r\nreturn 0;\r\n}\r\nstatic void bfin_gpio_irq_shutdown(struct irq_data *d)\r\n{\r\nu32 gpionr = irq_to_gpio(d->irq);\r\nbfin_gpio_mask_irq(d);\r\n__clear_bit(gpionr, gpio_enabled);\r\nbfin_gpio_irq_free(gpionr);\r\n}\r\nstatic int bfin_gpio_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nunsigned int irq = d->irq;\r\nint ret;\r\nchar buf[16];\r\nu32 gpionr = irq_to_gpio(irq);\r\nu32 pint_val = irq2pint_lut[irq - SYS_IRQS];\r\nu32 pintbit = PINT_BIT(pint_val);\r\nu32 bank = PINT_2_BANK(pint_val);\r\nif (pint_val == IRQ_NOT_AVAIL)\r\nreturn -ENODEV;\r\nif (type == IRQ_TYPE_PROBE) {\r\nif (test_bit(gpionr, gpio_enabled))\r\nreturn 0;\r\ntype = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;\r\n}\r\nif (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING |\r\nIRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {\r\nsnprintf(buf, 16, "gpio-irq%d", irq);\r\nret = bfin_gpio_irq_request(gpionr, buf);\r\nif (ret)\r\nreturn ret;\r\nif (__test_and_set_bit(gpionr, gpio_enabled))\r\nbfin_gpio_irq_prepare(gpionr);\r\n} else {\r\n__clear_bit(gpionr, gpio_enabled);\r\nreturn 0;\r\n}\r\nif ((type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_LEVEL_LOW)))\r\npint[bank]->invert_set = pintbit;\r\nelse\r\npint[bank]->invert_clear = pintbit;\r\nif ((type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING))\r\n== (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) {\r\nif (gpio_get_value(gpionr))\r\npint[bank]->invert_set = pintbit;\r\nelse\r\npint[bank]->invert_clear = pintbit;\r\n}\r\nif (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) {\r\npint[bank]->edge_set = pintbit;\r\nbfin_set_irq_handler(irq, handle_edge_irq);\r\n} else {\r\npint[bank]->edge_clear = pintbit;\r\nbfin_set_irq_handler(irq, handle_level_irq);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bfin_gpio_set_wake(struct irq_data *d, unsigned int state)\r\n{\r\nu32 pint_irq;\r\nu32 pint_val = irq2pint_lut[d->irq - SYS_IRQS];\r\nu32 bank = PINT_2_BANK(pint_val);\r\nswitch (bank) {\r\ncase 0:\r\npint_irq = IRQ_PINT0;\r\nbreak;\r\ncase 2:\r\npint_irq = IRQ_PINT2;\r\nbreak;\r\ncase 3:\r\npint_irq = IRQ_PINT3;\r\nbreak;\r\ncase 1:\r\npint_irq = IRQ_PINT1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbfin_internal_set_wake(pint_irq, state);\r\nreturn 0;\r\n}\r\nvoid bfin_demux_gpio_irq(unsigned int inta_irq,\r\nstruct irq_desc *desc)\r\n{\r\nu32 bank, pint_val;\r\nu32 request, irq;\r\nswitch (inta_irq) {\r\ncase IRQ_PINT0:\r\nbank = 0;\r\nbreak;\r\ncase IRQ_PINT2:\r\nbank = 2;\r\nbreak;\r\ncase IRQ_PINT3:\r\nbank = 3;\r\nbreak;\r\ncase IRQ_PINT1:\r\nbank = 1;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\npint_val = bank * NR_PINT_BITS;\r\nrequest = pint[bank]->request;\r\nwhile (request) {\r\nif (request & 1) {\r\nirq = pint2irq_lut[pint_val] + SYS_IRQS;\r\nbfin_handle_irq(irq);\r\n}\r\npint_val++;\r\nrequest >>= 1;\r\n}\r\n}\r\nvoid __cpuinit init_exception_vectors(void)\r\n{\r\nbfin_write_EVT2(evt_nmi);\r\nbfin_write_EVT3(trap);\r\nbfin_write_EVT5(evt_ivhw);\r\nbfin_write_EVT6(evt_timer);\r\nbfin_write_EVT7(evt_evt7);\r\nbfin_write_EVT8(evt_evt8);\r\nbfin_write_EVT9(evt_evt9);\r\nbfin_write_EVT10(evt_evt10);\r\nbfin_write_EVT11(evt_evt11);\r\nbfin_write_EVT12(evt_evt12);\r\nbfin_write_EVT13(evt_evt13);\r\nbfin_write_EVT14(evt_evt14);\r\nbfin_write_EVT15(evt_system_call);\r\nCSYNC();\r\n}\r\nint __init init_arch_irq(void)\r\n{\r\nint irq;\r\nunsigned long ilat = 0;\r\n#ifdef SIC_IMASK0\r\nbfin_write_SIC_IMASK0(SIC_UNMASK_ALL);\r\nbfin_write_SIC_IMASK1(SIC_UNMASK_ALL);\r\n# ifdef SIC_IMASK2\r\nbfin_write_SIC_IMASK2(SIC_UNMASK_ALL);\r\n# endif\r\n# ifdef CONFIG_SMP\r\nbfin_write_SICB_IMASK0(SIC_UNMASK_ALL);\r\nbfin_write_SICB_IMASK1(SIC_UNMASK_ALL);\r\n# endif\r\n#else\r\nbfin_write_SIC_IMASK(SIC_UNMASK_ALL);\r\n#endif\r\nlocal_irq_disable();\r\n#if BFIN_GPIO_PINT\r\n# ifdef CONFIG_PINTx_REASSIGN\r\npint[0]->assign = CONFIG_PINT0_ASSIGN;\r\npint[1]->assign = CONFIG_PINT1_ASSIGN;\r\npint[2]->assign = CONFIG_PINT2_ASSIGN;\r\npint[3]->assign = CONFIG_PINT3_ASSIGN;\r\n# endif\r\ninit_pint_lut();\r\n#endif\r\nfor (irq = 0; irq <= SYS_IRQS; irq++) {\r\nif (irq <= IRQ_CORETMR)\r\nirq_set_chip(irq, &bfin_core_irqchip);\r\nelse\r\nirq_set_chip(irq, &bfin_internal_irqchip);\r\nswitch (irq) {\r\n#if BFIN_GPIO_PINT\r\ncase IRQ_PINT0:\r\ncase IRQ_PINT1:\r\ncase IRQ_PINT2:\r\ncase IRQ_PINT3:\r\n#elif defined(BF537_FAMILY)\r\ncase IRQ_PH_INTA_MAC_RX:\r\ncase IRQ_PF_INTA_PG_INTA:\r\n#elif defined(BF533_FAMILY)\r\ncase IRQ_PROG_INTA:\r\n#elif defined(CONFIG_BF52x) || defined(CONFIG_BF51x)\r\ncase IRQ_PORTF_INTA:\r\ncase IRQ_PORTG_INTA:\r\ncase IRQ_PORTH_INTA:\r\n#elif defined(CONFIG_BF561)\r\ncase IRQ_PROG0_INTA:\r\ncase IRQ_PROG1_INTA:\r\ncase IRQ_PROG2_INTA:\r\n#elif defined(BF538_FAMILY)\r\ncase IRQ_PORTF_INTA:\r\n#endif\r\nirq_set_chained_handler(irq, bfin_demux_gpio_irq);\r\nbreak;\r\n#if defined(CONFIG_BFIN_MAC) || defined(CONFIG_BFIN_MAC_MODULE)\r\ncase IRQ_MAC_ERROR:\r\nirq_set_chained_handler(irq,\r\nbfin_demux_mac_status_irq);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_SMP\r\ncase IRQ_SUPPLE_0:\r\ncase IRQ_SUPPLE_1:\r\nirq_set_handler(irq, handle_percpu_irq);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_TICKSOURCE_CORETMR\r\ncase IRQ_CORETMR:\r\n# ifdef CONFIG_SMP\r\nirq_set_handler(irq, handle_percpu_irq);\r\n# else\r\nirq_set_handler(irq, handle_simple_irq);\r\n# endif\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_TICKSOURCE_GPTMR0\r\ncase IRQ_TIMER0:\r\nirq_set_handler(irq, handle_simple_irq);\r\nbreak;\r\n#endif\r\ndefault:\r\n#ifdef CONFIG_IPIPE\r\nirq_set_handler(irq, handle_level_irq);\r\n#else\r\nirq_set_handler(irq, handle_simple_irq);\r\n#endif\r\nbreak;\r\n}\r\n}\r\ninit_mach_irq();\r\n#if defined(CONFIG_BFIN_MAC) || defined(CONFIG_BFIN_MAC_MODULE)\r\nfor (irq = IRQ_MAC_PHYINT; irq <= IRQ_MAC_STMDONE; irq++)\r\nirq_set_chip_and_handler(irq, &bfin_mac_status_irqchip,\r\nhandle_level_irq);\r\n#endif\r\nfor (irq = GPIO_IRQ_BASE;\r\nirq < (GPIO_IRQ_BASE + MAX_BLACKFIN_GPIOS); irq++)\r\nirq_set_chip_and_handler(irq, &bfin_gpio_irqchip,\r\nhandle_level_irq);\r\nbfin_write_IMASK(0);\r\nCSYNC();\r\nilat = bfin_read_ILAT();\r\nCSYNC();\r\nbfin_write_ILAT(ilat);\r\nCSYNC();\r\nprintk(KERN_INFO "Configuring Blackfin Priority Driven Interrupts\n");\r\nprogram_IAR();\r\nsearch_IAR();\r\nbfin_irq_flags |= IMASK_IVG15 |\r\nIMASK_IVG14 | IMASK_IVG13 | IMASK_IVG12 | IMASK_IVG11 |\r\nIMASK_IVG10 | IMASK_IVG9 | IMASK_IVG8 | IMASK_IVG7 | IMASK_IVGHW;\r\n#ifdef SIC_IWR0\r\nbfin_write_SIC_IWR0(IWR_DISABLE_ALL);\r\n# ifdef SIC_IWR1\r\nif (ANOMALY_05000435)\r\nbfin_write_SIC_IWR1(IWR_ENABLE(10) | IWR_ENABLE(11));\r\nelse\r\nbfin_write_SIC_IWR1(IWR_DISABLE_ALL);\r\n# endif\r\n# ifdef SIC_IWR2\r\nbfin_write_SIC_IWR2(IWR_DISABLE_ALL);\r\n# endif\r\n#else\r\nbfin_write_SIC_IWR(IWR_DISABLE_ALL);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int vec_to_irq(int vec)\r\n{\r\nstruct ivgx *ivg = ivg7_13[vec - IVG7].ifirst;\r\nstruct ivgx *ivg_stop = ivg7_13[vec - IVG7].istop;\r\nunsigned long sic_status[3];\r\nif (likely(vec == EVT_IVTMR_P))\r\nreturn IRQ_CORETMR;\r\n#ifdef SIC_ISR\r\nsic_status[0] = bfin_read_SIC_IMASK() & bfin_read_SIC_ISR();\r\n#else\r\nif (smp_processor_id()) {\r\n# ifdef SICB_ISR0\r\nsic_status[0] = bfin_read_SICB_ISR0() & bfin_read_SICB_IMASK0();\r\nsic_status[1] = bfin_read_SICB_ISR1() & bfin_read_SICB_IMASK1();\r\n# endif\r\n} else {\r\nsic_status[0] = bfin_read_SIC_ISR0() & bfin_read_SIC_IMASK0();\r\nsic_status[1] = bfin_read_SIC_ISR1() & bfin_read_SIC_IMASK1();\r\n}\r\n#endif\r\n#ifdef SIC_ISR2\r\nsic_status[2] = bfin_read_SIC_ISR2() & bfin_read_SIC_IMASK2();\r\n#endif\r\nfor (;; ivg++) {\r\nif (ivg >= ivg_stop)\r\nreturn -1;\r\n#ifdef SIC_ISR\r\nif (sic_status[0] & ivg->isrflag)\r\n#else\r\nif (sic_status[(ivg->irqno - IVG7) / 32] & ivg->isrflag)\r\n#endif\r\nreturn ivg->irqno;\r\n}\r\n}\r\nvoid do_irq(int vec, struct pt_regs *fp)\r\n{\r\nint irq = vec_to_irq(vec);\r\nif (irq == -1)\r\nreturn;\r\nasm_do_IRQ(irq, fp);\r\n}\r\nint __ipipe_get_irq_priority(unsigned irq)\r\n{\r\nint ient, prio;\r\nif (irq <= IRQ_CORETMR)\r\nreturn irq;\r\nfor (ient = 0; ient < NR_PERI_INTS; ient++) {\r\nstruct ivgx *ivg = ivg_table + ient;\r\nif (ivg->irqno == irq) {\r\nfor (prio = 0; prio <= IVG13-IVG7; prio++) {\r\nif (ivg7_13[prio].ifirst <= ivg &&\r\nivg7_13[prio].istop > ivg)\r\nreturn IVG7 + prio;\r\n}\r\n}\r\n}\r\nreturn IVG15;\r\n}\r\nasmlinkage int __ipipe_grab_irq(int vec, struct pt_regs *regs)\r\n{\r\nstruct ipipe_percpu_domain_data *p = ipipe_root_cpudom_ptr();\r\nstruct ipipe_domain *this_domain = __ipipe_current_domain;\r\nstruct ivgx *ivg_stop = ivg7_13[vec-IVG7].istop;\r\nstruct ivgx *ivg = ivg7_13[vec-IVG7].ifirst;\r\nint irq, s = 0;\r\nirq = vec_to_irq(vec);\r\nif (irq == -1)\r\nreturn 0;\r\nif (irq == IRQ_SYSTMR) {\r\n#if !defined(CONFIG_GENERIC_CLOCKEVENTS) || defined(CONFIG_TICKSOURCE_GPTMR0)\r\nbfin_write_TIMER_STATUS(1);\r\n#endif\r\n__raw_get_cpu_var(__ipipe_tick_regs).ipend = regs->ipend;\r\n__raw_get_cpu_var(__ipipe_tick_regs).pc = regs->pc;\r\nif (this_domain != ipipe_root_domain)\r\n__raw_get_cpu_var(__ipipe_tick_regs).ipend &= ~0x10;\r\nelse\r\n__raw_get_cpu_var(__ipipe_tick_regs).ipend |= 0x10;\r\n}\r\nif (this_domain == ipipe_root_domain) {\r\ns = __test_and_set_bit(IPIPE_SYNCDEFER_FLAG, &p->status);\r\nbarrier();\r\n}\r\nipipe_trace_irq_entry(irq);\r\n__ipipe_handle_irq(irq, regs);\r\nipipe_trace_irq_exit(irq);\r\nif (user_mode(regs) &&\r\n!ipipe_test_foreign_stack() &&\r\n(current->ipipe_flags & PF_EVTRET) != 0) {\r\ncurrent->ipipe_flags &= ~PF_EVTRET;\r\n__ipipe_dispatch_event(IPIPE_EVENT_RETURN, regs);\r\n}\r\nif (this_domain == ipipe_root_domain) {\r\nset_thread_flag(TIF_IRQ_SYNC);\r\nif (!s) {\r\n__clear_bit(IPIPE_SYNCDEFER_FLAG, &p->status);\r\nreturn !test_bit(IPIPE_STALL_FLAG, &p->status);\r\n}\r\n}\r\nreturn 0;\r\n}
