static void nv10_graph_save_pipe(struct nouveau_channel *chan)\r\n{\r\nstruct graph_state *pgraph_ctx = chan->engctx[NVOBJ_ENGINE_GR];\r\nstruct pipe_state *pipe = &pgraph_ctx->pipe_state;\r\nstruct drm_device *dev = chan->dev;\r\nPIPE_SAVE(dev, pipe->pipe_0x4400, 0x4400);\r\nPIPE_SAVE(dev, pipe->pipe_0x0200, 0x0200);\r\nPIPE_SAVE(dev, pipe->pipe_0x6400, 0x6400);\r\nPIPE_SAVE(dev, pipe->pipe_0x6800, 0x6800);\r\nPIPE_SAVE(dev, pipe->pipe_0x6c00, 0x6c00);\r\nPIPE_SAVE(dev, pipe->pipe_0x7000, 0x7000);\r\nPIPE_SAVE(dev, pipe->pipe_0x7400, 0x7400);\r\nPIPE_SAVE(dev, pipe->pipe_0x7800, 0x7800);\r\nPIPE_SAVE(dev, pipe->pipe_0x0040, 0x0040);\r\nPIPE_SAVE(dev, pipe->pipe_0x0000, 0x0000);\r\n}\r\nstatic void nv10_graph_load_pipe(struct nouveau_channel *chan)\r\n{\r\nstruct graph_state *pgraph_ctx = chan->engctx[NVOBJ_ENGINE_GR];\r\nstruct pipe_state *pipe = &pgraph_ctx->pipe_state;\r\nstruct drm_device *dev = chan->dev;\r\nuint32_t xfmode0, xfmode1;\r\nint i;\r\nnouveau_wait_for_idle(dev);\r\nxfmode0 = nv_rd32(dev, NV10_PGRAPH_XFMODE0);\r\nxfmode1 = nv_rd32(dev, NV10_PGRAPH_XFMODE1);\r\nnv_wr32(dev, NV10_PGRAPH_XFMODE0, 0x10000000);\r\nnv_wr32(dev, NV10_PGRAPH_XFMODE1, 0x00000000);\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_ADDRESS, 0x000064c0);\r\nfor (i = 0; i < 4; i++)\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_DATA, 0x3f800000);\r\nfor (i = 0; i < 4; i++)\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_DATA, 0x00000000);\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_ADDRESS, 0x00006ab0);\r\nfor (i = 0; i < 3; i++)\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_DATA, 0x3f800000);\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_ADDRESS, 0x00006a80);\r\nfor (i = 0; i < 3; i++)\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_DATA, 0x00000000);\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_ADDRESS, 0x00000040);\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_DATA, 0x00000008);\r\nPIPE_RESTORE(dev, pipe->pipe_0x0200, 0x0200);\r\nnouveau_wait_for_idle(dev);\r\nnv_wr32(dev, NV10_PGRAPH_XFMODE0, xfmode0);\r\nnv_wr32(dev, NV10_PGRAPH_XFMODE1, xfmode1);\r\nPIPE_RESTORE(dev, pipe->pipe_0x6400, 0x6400);\r\nPIPE_RESTORE(dev, pipe->pipe_0x6800, 0x6800);\r\nPIPE_RESTORE(dev, pipe->pipe_0x6c00, 0x6c00);\r\nPIPE_RESTORE(dev, pipe->pipe_0x7000, 0x7000);\r\nPIPE_RESTORE(dev, pipe->pipe_0x7400, 0x7400);\r\nPIPE_RESTORE(dev, pipe->pipe_0x7800, 0x7800);\r\nPIPE_RESTORE(dev, pipe->pipe_0x4400, 0x4400);\r\nPIPE_RESTORE(dev, pipe->pipe_0x0000, 0x0000);\r\nPIPE_RESTORE(dev, pipe->pipe_0x0040, 0x0040);\r\nnouveau_wait_for_idle(dev);\r\n}\r\nstatic void nv10_graph_create_pipe(struct nouveau_channel *chan)\r\n{\r\nstruct graph_state *pgraph_ctx = chan->engctx[NVOBJ_ENGINE_GR];\r\nstruct pipe_state *fifo_pipe_state = &pgraph_ctx->pipe_state;\r\nstruct drm_device *dev = chan->dev;\r\nuint32_t *fifo_pipe_state_addr;\r\nint i;\r\n#define PIPE_INIT(addr) \\r\ndo { \\r\nfifo_pipe_state_addr = fifo_pipe_state->pipe_##addr; \\r\n} while (0)\r\n#define PIPE_INIT_END(addr) \\r\ndo { \\r\nuint32_t *__end_addr = fifo_pipe_state->pipe_##addr + \\r\nARRAY_SIZE(fifo_pipe_state->pipe_##addr); \\r\nif (fifo_pipe_state_addr != __end_addr) \\r\nNV_ERROR(dev, "incomplete pipe init for 0x%x : %p/%p\n", \\r\naddr, fifo_pipe_state_addr, __end_addr); \\r\n} while (0)\r\n#define NV_WRITE_PIPE_INIT(value) *(fifo_pipe_state_addr++) = value\r\nPIPE_INIT(0x0200);\r\nfor (i = 0; i < 48; i++)\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nPIPE_INIT_END(0x0200);\r\nPIPE_INIT(0x6400);\r\nfor (i = 0; i < 211; i++)\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x3f800000);\r\nNV_WRITE_PIPE_INIT(0x40000000);\r\nNV_WRITE_PIPE_INIT(0x40000000);\r\nNV_WRITE_PIPE_INIT(0x40000000);\r\nNV_WRITE_PIPE_INIT(0x40000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x3f800000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x3f000000);\r\nNV_WRITE_PIPE_INIT(0x3f000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x3f800000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x3f800000);\r\nNV_WRITE_PIPE_INIT(0x3f800000);\r\nNV_WRITE_PIPE_INIT(0x3f800000);\r\nNV_WRITE_PIPE_INIT(0x3f800000);\r\nPIPE_INIT_END(0x6400);\r\nPIPE_INIT(0x6800);\r\nfor (i = 0; i < 162; i++)\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x3f800000);\r\nfor (i = 0; i < 25; i++)\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nPIPE_INIT_END(0x6800);\r\nPIPE_INIT(0x6c00);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0xbf800000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nPIPE_INIT_END(0x6c00);\r\nPIPE_INIT(0x7000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x7149f2ca);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x7149f2ca);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x7149f2ca);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x7149f2ca);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x7149f2ca);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x7149f2ca);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x7149f2ca);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nNV_WRITE_PIPE_INIT(0x7149f2ca);\r\nfor (i = 0; i < 35; i++)\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nPIPE_INIT_END(0x7000);\r\nPIPE_INIT(0x7400);\r\nfor (i = 0; i < 48; i++)\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nPIPE_INIT_END(0x7400);\r\nPIPE_INIT(0x7800);\r\nfor (i = 0; i < 48; i++)\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nPIPE_INIT_END(0x7800);\r\nPIPE_INIT(0x4400);\r\nfor (i = 0; i < 32; i++)\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nPIPE_INIT_END(0x4400);\r\nPIPE_INIT(0x0000);\r\nfor (i = 0; i < 16; i++)\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nPIPE_INIT_END(0x0000);\r\nPIPE_INIT(0x0040);\r\nfor (i = 0; i < 4; i++)\r\nNV_WRITE_PIPE_INIT(0x00000000);\r\nPIPE_INIT_END(0x0040);\r\n#undef PIPE_INIT\r\n#undef PIPE_INIT_END\r\n#undef NV_WRITE_PIPE_INIT\r\n}\r\nstatic int nv10_graph_ctx_regs_find_offset(struct drm_device *dev, int reg)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(nv10_graph_ctx_regs); i++) {\r\nif (nv10_graph_ctx_regs[i] == reg)\r\nreturn i;\r\n}\r\nNV_ERROR(dev, "unknow offset nv10_ctx_regs %d\n", reg);\r\nreturn -1;\r\n}\r\nstatic int nv17_graph_ctx_regs_find_offset(struct drm_device *dev, int reg)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(nv17_graph_ctx_regs); i++) {\r\nif (nv17_graph_ctx_regs[i] == reg)\r\nreturn i;\r\n}\r\nNV_ERROR(dev, "unknow offset nv17_ctx_regs %d\n", reg);\r\nreturn -1;\r\n}\r\nstatic void nv10_graph_load_dma_vtxbuf(struct nouveau_channel *chan,\r\nuint32_t inst)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nuint32_t st2, st2_dl, st2_dh, fifo_ptr, fifo[0x60/4];\r\nuint32_t ctx_user, ctx_switch[5];\r\nint i, subchan = -1;\r\nfor (i = 0; i < 8; i++) {\r\nint class = nv_rd32(dev, NV10_PGRAPH_CTX_CACHE(i, 0)) & 0xfff;\r\nif (class == 0x56 || class == 0x96 || class == 0x99) {\r\nsubchan = i;\r\nbreak;\r\n}\r\n}\r\nif (subchan < 0 || !inst)\r\nreturn;\r\nctx_user = nv_rd32(dev, NV10_PGRAPH_CTX_USER);\r\nfor (i = 0; i < 5; i++)\r\nctx_switch[i] = nv_rd32(dev, NV10_PGRAPH_CTX_SWITCH(i));\r\nst2 = nv_rd32(dev, NV10_PGRAPH_FFINTFC_ST2);\r\nst2_dl = nv_rd32(dev, NV10_PGRAPH_FFINTFC_ST2_DL);\r\nst2_dh = nv_rd32(dev, NV10_PGRAPH_FFINTFC_ST2_DH);\r\nfifo_ptr = nv_rd32(dev, NV10_PGRAPH_FFINTFC_FIFO_PTR);\r\nfor (i = 0; i < ARRAY_SIZE(fifo); i++)\r\nfifo[i] = nv_rd32(dev, 0x4007a0 + 4 * i);\r\nfor (i = 0; i < 5; i++)\r\nnv_wr32(dev, NV10_PGRAPH_CTX_SWITCH(i),\r\nnv_rd32(dev, NV10_PGRAPH_CTX_CACHE(subchan, i)));\r\nnv_mask(dev, NV10_PGRAPH_CTX_USER, 0xe000, subchan << 13);\r\nnv_wr32(dev, NV10_PGRAPH_FFINTFC_FIFO_PTR, 0);\r\nnv_wr32(dev, NV10_PGRAPH_FFINTFC_ST2,\r\n0x2c000000 | chan->id << 20 | subchan << 16 | 0x18c);\r\nnv_wr32(dev, NV10_PGRAPH_FFINTFC_ST2_DL, inst);\r\nnv_mask(dev, NV10_PGRAPH_CTX_CONTROL, 0, 0x10000);\r\nnv_mask(dev, NV04_PGRAPH_FIFO, 0x00000001, 0x00000001);\r\nnv_mask(dev, NV04_PGRAPH_FIFO, 0x00000001, 0x00000000);\r\nfor (i = 0; i < ARRAY_SIZE(fifo); i++)\r\nnv_wr32(dev, 0x4007a0 + 4 * i, fifo[i]);\r\nnv_wr32(dev, NV10_PGRAPH_FFINTFC_FIFO_PTR, fifo_ptr);\r\nnv_wr32(dev, NV10_PGRAPH_FFINTFC_ST2, st2);\r\nnv_wr32(dev, NV10_PGRAPH_FFINTFC_ST2_DL, st2_dl);\r\nnv_wr32(dev, NV10_PGRAPH_FFINTFC_ST2_DH, st2_dh);\r\nfor (i = 0; i < 5; i++)\r\nnv_wr32(dev, NV10_PGRAPH_CTX_SWITCH(i), ctx_switch[i]);\r\nnv_wr32(dev, NV10_PGRAPH_CTX_USER, ctx_user);\r\n}\r\nstatic int\r\nnv10_graph_load_context(struct nouveau_channel *chan)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct graph_state *pgraph_ctx = chan->engctx[NVOBJ_ENGINE_GR];\r\nuint32_t tmp;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(nv10_graph_ctx_regs); i++)\r\nnv_wr32(dev, nv10_graph_ctx_regs[i], pgraph_ctx->nv10[i]);\r\nif (dev_priv->chipset >= 0x17) {\r\nfor (i = 0; i < ARRAY_SIZE(nv17_graph_ctx_regs); i++)\r\nnv_wr32(dev, nv17_graph_ctx_regs[i],\r\npgraph_ctx->nv17[i]);\r\n}\r\nnv10_graph_load_pipe(chan);\r\nnv10_graph_load_dma_vtxbuf(chan, (nv_rd32(dev, NV10_PGRAPH_GLOBALSTATE1)\r\n& 0xffff));\r\nnv_wr32(dev, NV10_PGRAPH_CTX_CONTROL, 0x10010100);\r\ntmp = nv_rd32(dev, NV10_PGRAPH_CTX_USER);\r\nnv_wr32(dev, NV10_PGRAPH_CTX_USER, (tmp & 0xffffff) | chan->id << 24);\r\ntmp = nv_rd32(dev, NV10_PGRAPH_FFINTFC_ST2);\r\nnv_wr32(dev, NV10_PGRAPH_FFINTFC_ST2, tmp & 0xcfffffff);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv10_graph_unload_context(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_fifo_engine *pfifo = &dev_priv->engine.fifo;\r\nstruct nouveau_channel *chan;\r\nstruct graph_state *ctx;\r\nuint32_t tmp;\r\nint i;\r\nchan = nv10_graph_channel(dev);\r\nif (!chan)\r\nreturn 0;\r\nctx = chan->engctx[NVOBJ_ENGINE_GR];\r\nfor (i = 0; i < ARRAY_SIZE(nv10_graph_ctx_regs); i++)\r\nctx->nv10[i] = nv_rd32(dev, nv10_graph_ctx_regs[i]);\r\nif (dev_priv->chipset >= 0x17) {\r\nfor (i = 0; i < ARRAY_SIZE(nv17_graph_ctx_regs); i++)\r\nctx->nv17[i] = nv_rd32(dev, nv17_graph_ctx_regs[i]);\r\n}\r\nnv10_graph_save_pipe(chan);\r\nnv_wr32(dev, NV10_PGRAPH_CTX_CONTROL, 0x10000000);\r\ntmp = nv_rd32(dev, NV10_PGRAPH_CTX_USER) & 0x00ffffff;\r\ntmp |= (pfifo->channels - 1) << 24;\r\nnv_wr32(dev, NV10_PGRAPH_CTX_USER, tmp);\r\nreturn 0;\r\n}\r\nstatic void\r\nnv10_graph_context_switch(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_channel *chan = NULL;\r\nint chid;\r\nnouveau_wait_for_idle(dev);\r\nnv10_graph_unload_context(dev);\r\nchid = (nv_rd32(dev, NV04_PGRAPH_TRAPPED_ADDR) >> 20) & 0x1f;\r\nchan = dev_priv->channels.ptr[chid];\r\nif (chan && chan->engctx[NVOBJ_ENGINE_GR])\r\nnv10_graph_load_context(chan);\r\n}\r\nstruct nouveau_channel *\r\nnv10_graph_channel(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nint chid = dev_priv->engine.fifo.channels;\r\nif (nv_rd32(dev, NV10_PGRAPH_CTX_CONTROL) & 0x00010000)\r\nchid = nv_rd32(dev, NV10_PGRAPH_CTX_USER) >> 24;\r\nif (chid >= dev_priv->engine.fifo.channels)\r\nreturn NULL;\r\nreturn dev_priv->channels.ptr[chid];\r\n}\r\nstatic int\r\nnv10_graph_context_new(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct graph_state *pgraph_ctx;\r\nNV_DEBUG(dev, "nv10_graph_context_create %d\n", chan->id);\r\npgraph_ctx = kzalloc(sizeof(*pgraph_ctx), GFP_KERNEL);\r\nif (pgraph_ctx == NULL)\r\nreturn -ENOMEM;\r\nchan->engctx[engine] = pgraph_ctx;\r\nNV_WRITE_CTX(0x00400e88, 0x08000000);\r\nNV_WRITE_CTX(0x00400e9c, 0x4b7fffff);\r\nNV_WRITE_CTX(NV03_PGRAPH_XY_LOGIC_MISC0, 0x0001ffff);\r\nNV_WRITE_CTX(0x00400e10, 0x00001000);\r\nNV_WRITE_CTX(0x00400e14, 0x00001000);\r\nNV_WRITE_CTX(0x00400e30, 0x00080008);\r\nNV_WRITE_CTX(0x00400e34, 0x00080008);\r\nif (dev_priv->chipset >= 0x17) {\r\nNV17_WRITE_CTX(NV10_PGRAPH_DEBUG_4,\r\nnv_rd32(dev, NV10_PGRAPH_DEBUG_4));\r\nNV17_WRITE_CTX(0x004006b0, nv_rd32(dev, 0x004006b0));\r\nNV17_WRITE_CTX(0x00400eac, 0x0fff0000);\r\nNV17_WRITE_CTX(0x00400eb0, 0x0fff0000);\r\nNV17_WRITE_CTX(0x00400ec0, 0x00000080);\r\nNV17_WRITE_CTX(0x00400ed0, 0x00000080);\r\n}\r\nNV_WRITE_CTX(NV10_PGRAPH_CTX_USER, chan->id << 24);\r\nnv10_graph_create_pipe(chan);\r\nreturn 0;\r\n}\r\nstatic void\r\nnv10_graph_context_del(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct graph_state *pgraph_ctx = chan->engctx[engine];\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev_priv->context_switch_lock, flags);\r\nnv_mask(dev, NV04_PGRAPH_FIFO, 0x00000001, 0x00000000);\r\nif (nv10_graph_channel(dev) == chan)\r\nnv10_graph_unload_context(dev);\r\nnv_mask(dev, NV04_PGRAPH_FIFO, 0x00000001, 0x00000001);\r\nspin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);\r\nchan->engctx[engine] = NULL;\r\nkfree(pgraph_ctx);\r\n}\r\nstatic void\r\nnv10_graph_set_tile_region(struct drm_device *dev, int i)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_tile_reg *tile = &dev_priv->tile.reg[i];\r\nnv_wr32(dev, NV10_PGRAPH_TLIMIT(i), tile->limit);\r\nnv_wr32(dev, NV10_PGRAPH_TSIZE(i), tile->pitch);\r\nnv_wr32(dev, NV10_PGRAPH_TILE(i), tile->addr);\r\n}\r\nstatic int\r\nnv10_graph_init(struct drm_device *dev, int engine)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu32 tmp;\r\nint i;\r\nnv_wr32(dev, NV03_PMC_ENABLE, nv_rd32(dev, NV03_PMC_ENABLE) &\r\n~NV_PMC_ENABLE_PGRAPH);\r\nnv_wr32(dev, NV03_PMC_ENABLE, nv_rd32(dev, NV03_PMC_ENABLE) |\r\nNV_PMC_ENABLE_PGRAPH);\r\nnv_wr32(dev, NV03_PGRAPH_INTR , 0xFFFFFFFF);\r\nnv_wr32(dev, NV03_PGRAPH_INTR_EN, 0xFFFFFFFF);\r\nnv_wr32(dev, NV04_PGRAPH_DEBUG_0, 0xFFFFFFFF);\r\nnv_wr32(dev, NV04_PGRAPH_DEBUG_0, 0x00000000);\r\nnv_wr32(dev, NV04_PGRAPH_DEBUG_1, 0x00118700);\r\nnv_wr32(dev, NV04_PGRAPH_DEBUG_2, 0x25f92ad9);\r\nnv_wr32(dev, NV04_PGRAPH_DEBUG_3, 0x55DE0830 |\r\n(1<<29) |\r\n(1<<31));\r\nif (dev_priv->chipset >= 0x17) {\r\nnv_wr32(dev, NV10_PGRAPH_DEBUG_4, 0x1f000000);\r\nnv_wr32(dev, 0x400a10, 0x3ff3fb6);\r\nnv_wr32(dev, 0x400838, 0x2f8684);\r\nnv_wr32(dev, 0x40083c, 0x115f3f);\r\nnv_wr32(dev, 0x004006b0, 0x40000020);\r\n} else\r\nnv_wr32(dev, NV10_PGRAPH_DEBUG_4, 0x00000000);\r\nfor (i = 0; i < NV10_PFB_TILE__SIZE; i++)\r\nnv10_graph_set_tile_region(dev, i);\r\nnv_wr32(dev, NV10_PGRAPH_CTX_SWITCH(0), 0x00000000);\r\nnv_wr32(dev, NV10_PGRAPH_CTX_SWITCH(1), 0x00000000);\r\nnv_wr32(dev, NV10_PGRAPH_CTX_SWITCH(2), 0x00000000);\r\nnv_wr32(dev, NV10_PGRAPH_CTX_SWITCH(3), 0x00000000);\r\nnv_wr32(dev, NV10_PGRAPH_CTX_SWITCH(4), 0x00000000);\r\nnv_wr32(dev, NV10_PGRAPH_STATE, 0xFFFFFFFF);\r\ntmp = nv_rd32(dev, NV10_PGRAPH_CTX_USER) & 0x00ffffff;\r\ntmp |= (dev_priv->engine.fifo.channels - 1) << 24;\r\nnv_wr32(dev, NV10_PGRAPH_CTX_USER, tmp);\r\nnv_wr32(dev, NV10_PGRAPH_CTX_CONTROL, 0x10000100);\r\nnv_wr32(dev, NV10_PGRAPH_FFINTFC_ST2, 0x08000000);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv10_graph_fini(struct drm_device *dev, int engine, bool suspend)\r\n{\r\nnv_mask(dev, NV04_PGRAPH_FIFO, 0x00000001, 0x00000000);\r\nif (!nv_wait(dev, NV04_PGRAPH_STATUS, ~0, 0) && suspend) {\r\nnv_mask(dev, NV04_PGRAPH_FIFO, 0x00000001, 0x00000001);\r\nreturn -EBUSY;\r\n}\r\nnv10_graph_unload_context(dev);\r\nnv_wr32(dev, NV03_PGRAPH_INTR_EN, 0x00000000);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv17_graph_mthd_lma_window(struct nouveau_channel *chan,\r\nu32 class, u32 mthd, u32 data)\r\n{\r\nstruct graph_state *ctx = chan->engctx[NVOBJ_ENGINE_GR];\r\nstruct drm_device *dev = chan->dev;\r\nstruct pipe_state *pipe = &ctx->pipe_state;\r\nuint32_t pipe_0x0040[1], pipe_0x64c0[8], pipe_0x6a80[3], pipe_0x6ab0[3];\r\nuint32_t xfmode0, xfmode1;\r\nint i;\r\nctx->lma_window[(mthd - 0x1638) / 4] = data;\r\nif (mthd != 0x1644)\r\nreturn 0;\r\nnouveau_wait_for_idle(dev);\r\nPIPE_SAVE(dev, pipe_0x0040, 0x0040);\r\nPIPE_SAVE(dev, pipe->pipe_0x0200, 0x0200);\r\nPIPE_RESTORE(dev, ctx->lma_window, 0x6790);\r\nnouveau_wait_for_idle(dev);\r\nxfmode0 = nv_rd32(dev, NV10_PGRAPH_XFMODE0);\r\nxfmode1 = nv_rd32(dev, NV10_PGRAPH_XFMODE1);\r\nPIPE_SAVE(dev, pipe->pipe_0x4400, 0x4400);\r\nPIPE_SAVE(dev, pipe_0x64c0, 0x64c0);\r\nPIPE_SAVE(dev, pipe_0x6ab0, 0x6ab0);\r\nPIPE_SAVE(dev, pipe_0x6a80, 0x6a80);\r\nnouveau_wait_for_idle(dev);\r\nnv_wr32(dev, NV10_PGRAPH_XFMODE0, 0x10000000);\r\nnv_wr32(dev, NV10_PGRAPH_XFMODE1, 0x00000000);\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_ADDRESS, 0x000064c0);\r\nfor (i = 0; i < 4; i++)\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_DATA, 0x3f800000);\r\nfor (i = 0; i < 4; i++)\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_DATA, 0x00000000);\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_ADDRESS, 0x00006ab0);\r\nfor (i = 0; i < 3; i++)\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_DATA, 0x3f800000);\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_ADDRESS, 0x00006a80);\r\nfor (i = 0; i < 3; i++)\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_DATA, 0x00000000);\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_ADDRESS, 0x00000040);\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_DATA, 0x00000008);\r\nPIPE_RESTORE(dev, pipe->pipe_0x0200, 0x0200);\r\nnouveau_wait_for_idle(dev);\r\nPIPE_RESTORE(dev, pipe_0x0040, 0x0040);\r\nnv_wr32(dev, NV10_PGRAPH_XFMODE0, xfmode0);\r\nnv_wr32(dev, NV10_PGRAPH_XFMODE1, xfmode1);\r\nPIPE_RESTORE(dev, pipe_0x64c0, 0x64c0);\r\nPIPE_RESTORE(dev, pipe_0x6ab0, 0x6ab0);\r\nPIPE_RESTORE(dev, pipe_0x6a80, 0x6a80);\r\nPIPE_RESTORE(dev, pipe->pipe_0x4400, 0x4400);\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_ADDRESS, 0x000000c0);\r\nnv_wr32(dev, NV10_PGRAPH_PIPE_DATA, 0x00000000);\r\nnouveau_wait_for_idle(dev);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv17_graph_mthd_lma_enable(struct nouveau_channel *chan,\r\nu32 class, u32 mthd, u32 data)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nnouveau_wait_for_idle(dev);\r\nnv_wr32(dev, NV10_PGRAPH_DEBUG_4,\r\nnv_rd32(dev, NV10_PGRAPH_DEBUG_4) | 0x1 << 8);\r\nnv_wr32(dev, 0x004006b0,\r\nnv_rd32(dev, 0x004006b0) | 0x8 << 24);\r\nreturn 0;\r\n}\r\nstatic void\r\nnv10_graph_isr(struct drm_device *dev)\r\n{\r\nu32 stat;\r\nwhile ((stat = nv_rd32(dev, NV03_PGRAPH_INTR))) {\r\nu32 nsource = nv_rd32(dev, NV03_PGRAPH_NSOURCE);\r\nu32 nstatus = nv_rd32(dev, NV03_PGRAPH_NSTATUS);\r\nu32 addr = nv_rd32(dev, NV04_PGRAPH_TRAPPED_ADDR);\r\nu32 chid = (addr & 0x01f00000) >> 20;\r\nu32 subc = (addr & 0x00070000) >> 16;\r\nu32 mthd = (addr & 0x00001ffc);\r\nu32 data = nv_rd32(dev, NV04_PGRAPH_TRAPPED_DATA);\r\nu32 class = nv_rd32(dev, 0x400160 + subc * 4) & 0xfff;\r\nu32 show = stat;\r\nif (stat & NV_PGRAPH_INTR_ERROR) {\r\nif (nsource & NV03_PGRAPH_NSOURCE_ILLEGAL_MTHD) {\r\nif (!nouveau_gpuobj_mthd_call2(dev, chid, class, mthd, data))\r\nshow &= ~NV_PGRAPH_INTR_ERROR;\r\n}\r\n}\r\nif (stat & NV_PGRAPH_INTR_CONTEXT_SWITCH) {\r\nnv_wr32(dev, NV03_PGRAPH_INTR, NV_PGRAPH_INTR_CONTEXT_SWITCH);\r\nstat &= ~NV_PGRAPH_INTR_CONTEXT_SWITCH;\r\nshow &= ~NV_PGRAPH_INTR_CONTEXT_SWITCH;\r\nnv10_graph_context_switch(dev);\r\n}\r\nnv_wr32(dev, NV03_PGRAPH_INTR, stat);\r\nnv_wr32(dev, NV04_PGRAPH_FIFO, 0x00000001);\r\nif (show && nouveau_ratelimit()) {\r\nNV_INFO(dev, "PGRAPH -");\r\nnouveau_bitfield_print(nv10_graph_intr, show);\r\nprintk(" nsource:");\r\nnouveau_bitfield_print(nv04_graph_nsource, nsource);\r\nprintk(" nstatus:");\r\nnouveau_bitfield_print(nv10_graph_nstatus, nstatus);\r\nprintk("\n");\r\nNV_INFO(dev, "PGRAPH - ch %d/%d class 0x%04x "\r\n"mthd 0x%04x data 0x%08x\n",\r\nchid, subc, class, mthd, data);\r\n}\r\n}\r\n}\r\nstatic void\r\nnv10_graph_destroy(struct drm_device *dev, int engine)\r\n{\r\nstruct nv10_graph_engine *pgraph = nv_engine(dev, engine);\r\nnouveau_irq_unregister(dev, 12);\r\nkfree(pgraph);\r\n}\r\nint\r\nnv10_graph_create(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv10_graph_engine *pgraph;\r\npgraph = kzalloc(sizeof(*pgraph), GFP_KERNEL);\r\nif (!pgraph)\r\nreturn -ENOMEM;\r\npgraph->base.destroy = nv10_graph_destroy;\r\npgraph->base.init = nv10_graph_init;\r\npgraph->base.fini = nv10_graph_fini;\r\npgraph->base.context_new = nv10_graph_context_new;\r\npgraph->base.context_del = nv10_graph_context_del;\r\npgraph->base.object_new = nv04_graph_object_new;\r\npgraph->base.set_tile_region = nv10_graph_set_tile_region;\r\nNVOBJ_ENGINE_ADD(dev, GR, &pgraph->base);\r\nnouveau_irq_register(dev, 12, nv10_graph_isr);\r\nNVOBJ_CLASS(dev, 0x506e, SW);\r\nNVOBJ_MTHD (dev, 0x506e, 0x0500, nv04_graph_mthd_page_flip);\r\nNVOBJ_CLASS(dev, 0x0030, GR);\r\nNVOBJ_CLASS(dev, 0x0039, GR);\r\nNVOBJ_CLASS(dev, 0x004a, GR);\r\nNVOBJ_CLASS(dev, 0x005f, GR);\r\nNVOBJ_CLASS(dev, 0x009f, GR);\r\nNVOBJ_CLASS(dev, 0x008a, GR);\r\nNVOBJ_CLASS(dev, 0x0089, GR);\r\nNVOBJ_CLASS(dev, 0x0062, GR);\r\nNVOBJ_CLASS(dev, 0x0043, GR);\r\nNVOBJ_CLASS(dev, 0x0012, GR);\r\nNVOBJ_CLASS(dev, 0x0072, GR);\r\nNVOBJ_CLASS(dev, 0x0019, GR);\r\nNVOBJ_CLASS(dev, 0x0044, GR);\r\nNVOBJ_CLASS(dev, 0x0052, GR);\r\nNVOBJ_CLASS(dev, 0x0093, GR);\r\nNVOBJ_CLASS(dev, 0x0094, GR);\r\nNVOBJ_CLASS(dev, 0x0095, GR);\r\nif (dev_priv->chipset <= 0x10) {\r\nNVOBJ_CLASS(dev, 0x0056, GR);\r\n} else\r\nif (dev_priv->chipset < 0x17 || dev_priv->chipset == 0x1a) {\r\nNVOBJ_CLASS(dev, 0x0096, GR);\r\n} else {\r\nNVOBJ_CLASS(dev, 0x0099, GR);\r\nNVOBJ_MTHD (dev, 0x0099, 0x1638, nv17_graph_mthd_lma_window);\r\nNVOBJ_MTHD (dev, 0x0099, 0x163c, nv17_graph_mthd_lma_window);\r\nNVOBJ_MTHD (dev, 0x0099, 0x1640, nv17_graph_mthd_lma_window);\r\nNVOBJ_MTHD (dev, 0x0099, 0x1644, nv17_graph_mthd_lma_window);\r\nNVOBJ_MTHD (dev, 0x0099, 0x1658, nv17_graph_mthd_lma_enable);\r\n}\r\nreturn 0;\r\n}
