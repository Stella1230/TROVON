static int __devinit teles_probe(struct pcmcia_device *link)\r\n{\r\nlocal_info_t *local;\r\ndev_dbg(&link->dev, "teles_attach()\n");\r\nlocal = kzalloc(sizeof(local_info_t), GFP_KERNEL);\r\nif (!local) return -ENOMEM;\r\nlocal->cardnr = -1;\r\nlocal->p_dev = link;\r\nlink->priv = local;\r\nlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\r\nreturn teles_cs_config(link);\r\n}\r\nstatic void __devexit teles_detach(struct pcmcia_device *link)\r\n{\r\nlocal_info_t *info = link->priv;\r\ndev_dbg(&link->dev, "teles_detach(0x%p)\n", link);\r\ninfo->busy = 1;\r\nteles_cs_release(link);\r\nkfree(info);\r\n}\r\nstatic int teles_cs_configcheck(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nint j;\r\np_dev->io_lines = 5;\r\np_dev->resource[0]->end = 96;\r\np_dev->resource[0]->flags &= IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\r\nif ((p_dev->resource[0]->end) && p_dev->resource[0]->start) {\r\nprintk(KERN_INFO "(teles_cs: looks like the 96 model)\n");\r\nif (!pcmcia_request_io(p_dev))\r\nreturn 0;\r\n} else {\r\nprintk(KERN_INFO "(teles_cs: looks like the 97 model)\n");\r\nfor (j = 0x2f0; j > 0x100; j -= 0x10) {\r\np_dev->resource[0]->start = j;\r\nif (!pcmcia_request_io(p_dev))\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __devinit teles_cs_config(struct pcmcia_device *link)\r\n{\r\nint i;\r\nIsdnCard_t icard;\r\ndev_dbg(&link->dev, "teles_config(0x%p)\n", link);\r\ni = pcmcia_loop_config(link, teles_cs_configcheck, NULL);\r\nif (i != 0)\r\ngoto cs_failed;\r\nif (!link->irq)\r\ngoto cs_failed;\r\ni = pcmcia_enable_device(link);\r\nif (i != 0)\r\ngoto cs_failed;\r\nicard.para[0] = link->irq;\r\nicard.para[1] = link->resource[0]->start;\r\nicard.protocol = protocol;\r\nicard.typ = ISDN_CTYPE_TELESPCMCIA;\r\ni = hisax_init_pcmcia(link, &(((local_info_t*)link->priv)->busy), &icard);\r\nif (i < 0) {\r\nprintk(KERN_ERR "teles_cs: failed to initialize Teles PCMCIA %d at i/o %#x\n",\r\ni, (unsigned int) link->resource[0]->start);\r\nteles_cs_release(link);\r\nreturn -ENODEV;\r\n}\r\n((local_info_t*)link->priv)->cardnr = i;\r\nreturn 0;\r\ncs_failed:\r\nteles_cs_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic void teles_cs_release(struct pcmcia_device *link)\r\n{\r\nlocal_info_t *local = link->priv;\r\ndev_dbg(&link->dev, "teles_cs_release(0x%p)\n", link);\r\nif (local) {\r\nif (local->cardnr >= 0) {\r\nHiSax_closecard(local->cardnr);\r\n}\r\n}\r\npcmcia_disable_device(link);\r\n}\r\nstatic int teles_suspend(struct pcmcia_device *link)\r\n{\r\nlocal_info_t *dev = link->priv;\r\ndev->busy = 1;\r\nreturn 0;\r\n}\r\nstatic int teles_resume(struct pcmcia_device *link)\r\n{\r\nlocal_info_t *dev = link->priv;\r\ndev->busy = 0;\r\nreturn 0;\r\n}\r\nstatic int __init init_teles_cs(void)\r\n{\r\nreturn pcmcia_register_driver(&teles_cs_driver);\r\n}\r\nstatic void __exit exit_teles_cs(void)\r\n{\r\npcmcia_unregister_driver(&teles_cs_driver);\r\n}
