static struct imx074 *to_imx074(const struct i2c_client *client)\r\n{\r\nreturn container_of(i2c_get_clientdata(client), struct imx074, subdev);\r\n}\r\nstatic const struct imx074_datafmt *imx074_find_datafmt(enum v4l2_mbus_pixelcode code)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(imx074_colour_fmts); i++)\r\nif (imx074_colour_fmts[i].code == code)\r\nreturn imx074_colour_fmts + i;\r\nreturn NULL;\r\n}\r\nstatic int reg_write(struct i2c_client *client, const u16 addr, const u8 data)\r\n{\r\nstruct i2c_adapter *adap = client->adapter;\r\nstruct i2c_msg msg;\r\nunsigned char tx[3];\r\nint ret;\r\nmsg.addr = client->addr;\r\nmsg.buf = tx;\r\nmsg.len = 3;\r\nmsg.flags = 0;\r\ntx[0] = addr >> 8;\r\ntx[1] = addr & 0xff;\r\ntx[2] = data;\r\nret = i2c_transfer(adap, &msg, 1);\r\nmdelay(2);\r\nreturn ret == 1 ? 0 : -EIO;\r\n}\r\nstatic int reg_read(struct i2c_client *client, const u16 addr)\r\n{\r\nu8 buf[2] = {addr >> 8, addr & 0xff};\r\nint ret;\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = buf,\r\n}, {\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 2,\r\n.buf = buf,\r\n},\r\n};\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret < 0) {\r\ndev_warn(&client->dev, "Reading register %x from %x failed\n",\r\naddr, client->addr);\r\nreturn ret;\r\n}\r\nreturn buf[0] & 0xff;\r\n}\r\nstatic int imx074_try_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nconst struct imx074_datafmt *fmt = imx074_find_datafmt(mf->code);\r\ndev_dbg(sd->v4l2_dev->dev, "%s(%u)\n", __func__, mf->code);\r\nif (!fmt) {\r\nmf->code = imx074_colour_fmts[0].code;\r\nmf->colorspace = imx074_colour_fmts[0].colorspace;\r\n}\r\nmf->width = IMX074_WIDTH;\r\nmf->height = IMX074_HEIGHT;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int imx074_s_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct imx074 *priv = to_imx074(client);\r\ndev_dbg(sd->v4l2_dev->dev, "%s(%u)\n", __func__, mf->code);\r\nif (!imx074_find_datafmt(mf->code))\r\nreturn -EINVAL;\r\nimx074_try_fmt(sd, mf);\r\npriv->fmt = imx074_find_datafmt(mf->code);\r\nreturn 0;\r\n}\r\nstatic int imx074_g_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct imx074 *priv = to_imx074(client);\r\nconst struct imx074_datafmt *fmt = priv->fmt;\r\nmf->code = fmt->code;\r\nmf->colorspace = fmt->colorspace;\r\nmf->width = IMX074_WIDTH;\r\nmf->height = IMX074_HEIGHT;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int imx074_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\nstruct v4l2_rect *rect = &a->c;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nrect->top = 0;\r\nrect->left = 0;\r\nrect->width = IMX074_WIDTH;\r\nrect->height = IMX074_HEIGHT;\r\nreturn 0;\r\n}\r\nstatic int imx074_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)\r\n{\r\na->bounds.left = 0;\r\na->bounds.top = 0;\r\na->bounds.width = IMX074_WIDTH;\r\na->bounds.height = IMX074_HEIGHT;\r\na->defrect = a->bounds;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\na->pixelaspect.numerator = 1;\r\na->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int imx074_enum_fmt(struct v4l2_subdev *sd, unsigned int index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif ((unsigned int)index >= ARRAY_SIZE(imx074_colour_fmts))\r\nreturn -EINVAL;\r\n*code = imx074_colour_fmts[index].code;\r\nreturn 0;\r\n}\r\nstatic int imx074_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn reg_write(client, MODE_SELECT, !!enable);\r\n}\r\nstatic int imx074_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *id)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)\r\nreturn -EINVAL;\r\nif (id->match.addr != client->addr)\r\nreturn -ENODEV;\r\nid->ident = V4L2_IDENT_IMX074;\r\nid->revision = 0;\r\nreturn 0;\r\n}\r\nstatic int imx074_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\ncfg->type = V4L2_MBUS_CSI2;\r\ncfg->flags = V4L2_MBUS_CSI2_2_LANE |\r\nV4L2_MBUS_CSI2_CHANNEL_0 |\r\nV4L2_MBUS_CSI2_CONTINUOUS_CLOCK;\r\nreturn 0;\r\n}\r\nstatic int imx074_video_probe(struct i2c_client *client)\r\n{\r\nint ret;\r\nu16 id;\r\nret = reg_read(client, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nid = ret << 8;\r\nret = reg_read(client, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nid |= ret;\r\ndev_info(&client->dev, "Chip ID 0x%04x detected\n", id);\r\nif (id != 0x74)\r\nreturn -ENODEV;\r\nreg_write(client, PLL_MULTIPLIER, 0x2D);\r\nreg_write(client, PRE_PLL_CLK_DIV, 0x02);\r\nreg_write(client, PLSTATIM, 0x4B);\r\nreg_write(client, 0x3024, 0x00);\r\nreg_write(client, IMAGE_ORIENTATION, 0x00);\r\nreg_write(client, 0x0112, 0x08);\r\nreg_write(client, 0x0113, 0x08);\r\nreg_write(client, VNDMY_ABLMGSHLMT, 0x80);\r\nreg_write(client, Y_OPBADDR_START_DI, 0x08);\r\nreg_write(client, 0x3015, 0x37);\r\nreg_write(client, 0x301C, 0x01);\r\nreg_write(client, 0x302C, 0x05);\r\nreg_write(client, 0x3031, 0x26);\r\nreg_write(client, 0x3041, 0x60);\r\nreg_write(client, 0x3051, 0x24);\r\nreg_write(client, 0x3053, 0x34);\r\nreg_write(client, 0x3057, 0xC0);\r\nreg_write(client, 0x305C, 0x09);\r\nreg_write(client, 0x305D, 0x07);\r\nreg_write(client, 0x3060, 0x30);\r\nreg_write(client, 0x3065, 0x00);\r\nreg_write(client, 0x30AA, 0x08);\r\nreg_write(client, 0x30AB, 0x1C);\r\nreg_write(client, 0x30B0, 0x32);\r\nreg_write(client, 0x30B2, 0x83);\r\nreg_write(client, 0x30D3, 0x04);\r\nreg_write(client, 0x3106, 0x78);\r\nreg_write(client, 0x310C, 0x82);\r\nreg_write(client, 0x3304, 0x05);\r\nreg_write(client, 0x3305, 0x04);\r\nreg_write(client, 0x3306, 0x11);\r\nreg_write(client, 0x3307, 0x02);\r\nreg_write(client, 0x3308, 0x0C);\r\nreg_write(client, 0x3309, 0x06);\r\nreg_write(client, 0x330A, 0x08);\r\nreg_write(client, 0x330B, 0x04);\r\nreg_write(client, 0x330C, 0x08);\r\nreg_write(client, 0x330D, 0x06);\r\nreg_write(client, 0x330E, 0x01);\r\nreg_write(client, 0x3381, 0x00);\r\nreg_write(client, FRAME_LENGTH_LINES_HI, 0x06);\r\nreg_write(client, FRAME_LENGTH_LINES_LO, 0x48);\r\nreg_write(client, YADDR_START, 0x00);\r\nreg_write(client, YADDR_END, 0x2F);\r\nreg_write(client, X_OUTPUT_SIZE_MSB, 0x08);\r\nreg_write(client, X_OUTPUT_SIZE_LSB, 0x38);\r\nreg_write(client, Y_OUTPUT_SIZE_MSB, 0x06);\r\nreg_write(client, Y_OUTPUT_SIZE_LSB, 0x18);\r\nreg_write(client, X_EVEN_INC, 0x01);\r\nreg_write(client, X_ODD_INC, 0x03);\r\nreg_write(client, Y_EVEN_INC, 0x01);\r\nreg_write(client, Y_ODD_INC, 0x03);\r\nreg_write(client, HMODEADD, 0x00);\r\nreg_write(client, VMODEADD, 0x16);\r\nreg_write(client, VAPPLINE_START, 0x24);\r\nreg_write(client, VAPPLINE_END, 0x53);\r\nreg_write(client, SHUTTER, 0x00);\r\nreg_write(client, HADDAVE, 0x80);\r\nreg_write(client, LANESEL, 0x00);\r\nreg_write(client, GROUPED_PARAMETER_HOLD, 0x00);\r\nreturn 0;\r\n}\r\nstatic int imx074_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct imx074 *priv;\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nint ret;\r\nif (!icl) {\r\ndev_err(&client->dev, "IMX074: missing platform data!\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_warn(&adapter->dev,\r\n"I2C-Adapter doesn't support I2C_FUNC_SMBUS_BYTE\n");\r\nreturn -EIO;\r\n}\r\npriv = kzalloc(sizeof(struct imx074), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nv4l2_i2c_subdev_init(&priv->subdev, client, &imx074_subdev_ops);\r\npriv->fmt = &imx074_colour_fmts[0];\r\nret = imx074_video_probe(client);\r\nif (ret < 0) {\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int imx074_remove(struct i2c_client *client)\r\n{\r\nstruct imx074 *priv = to_imx074(client);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nif (icl->free_bus)\r\nicl->free_bus(icl);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int __init imx074_mod_init(void)\r\n{\r\nreturn i2c_add_driver(&imx074_i2c_driver);\r\n}\r\nstatic void __exit imx074_mod_exit(void)\r\n{\r\ni2c_del_driver(&imx074_i2c_driver);\r\n}
