static inline unsigned short scb_status(struct net_device *dev)\r\n{\r\nreturn inw(dev->base_addr + 0xc008);\r\n}\r\nstatic inline unsigned short scb_rdcmd(struct net_device *dev)\r\n{\r\nreturn inw(dev->base_addr + 0xc00a);\r\n}\r\nstatic inline void scb_command(struct net_device *dev, unsigned short cmd)\r\n{\r\noutw(cmd, dev->base_addr + 0xc00a);\r\n}\r\nstatic inline void scb_wrcbl(struct net_device *dev, unsigned short val)\r\n{\r\noutw(val, dev->base_addr + 0xc00c);\r\n}\r\nstatic inline void scb_wrrfa(struct net_device *dev, unsigned short val)\r\n{\r\noutw(val, dev->base_addr + 0xc00e);\r\n}\r\nstatic inline void set_loopback(struct net_device *dev)\r\n{\r\noutb(inb(dev->base_addr + Config) | 2, dev->base_addr + Config);\r\n}\r\nstatic inline void clear_loopback(struct net_device *dev)\r\n{\r\noutb(inb(dev->base_addr + Config) & ~2, dev->base_addr + Config);\r\n}\r\nstatic inline unsigned short int SHADOW(short int addr)\r\n{\r\naddr &= 0x1f;\r\nif (addr > 0xf) addr += 0x3ff0;\r\nreturn addr + 0x4000;\r\n}\r\nstatic int __init do_express_probe(struct net_device *dev)\r\n{\r\nunsigned short *port;\r\nstatic unsigned short ports[] = { 0x240,0x300,0x310,0x270,0x320,0x340,0 };\r\nunsigned short ioaddr = dev->base_addr;\r\nint dev_irq = dev->irq;\r\nint err;\r\ndev->if_port = 0xff;\r\n#ifdef CONFIG_MCA_LEGACY\r\nif (MCA_bus) {\r\nint slot = 0;\r\nwhile (slot != MCA_NOTFOUND) {\r\nint pos0, pos1;\r\nslot = mca_find_unused_adapter(0x628B, slot);\r\nif (slot == MCA_NOTFOUND)\r\nbreak;\r\npos0 = mca_read_stored_pos(slot, 2);\r\npos1 = mca_read_stored_pos(slot, 3);\r\nioaddr = mca_iomap[pos1&0xf];\r\ndev->irq = mca_irqmap[(pos1>>4)&0x7];\r\nif ((pos0 & 0x7) == 0x1)\r\ndev->if_port = AUI;\r\nelse if ((pos0 & 0x7) == 0x5) {\r\nif (pos1 & 0x80)\r\ndev->if_port = BNC;\r\nelse\r\ndev->if_port = TPE;\r\n}\r\nmca_set_adapter_name(slot, "Intel EtherExpress 16 MCA");\r\nmca_set_adapter_procfn(slot, NULL, dev);\r\nmca_mark_as_used(slot);\r\nbreak;\r\n}\r\n}\r\n#endif\r\nif (ioaddr&0xfe00) {\r\nif (!request_region(ioaddr, EEXP_IO_EXTENT, "EtherExpress"))\r\nreturn -EBUSY;\r\nerr = eexp_hw_probe(dev,ioaddr);\r\nrelease_region(ioaddr, EEXP_IO_EXTENT);\r\nreturn err;\r\n} else if (ioaddr)\r\nreturn -ENXIO;\r\nfor (port=&ports[0] ; *port ; port++ )\r\n{\r\nunsigned short sum = 0;\r\nint i;\r\nif (!request_region(*port, EEXP_IO_EXTENT, "EtherExpress"))\r\ncontinue;\r\nfor ( i=0 ; i<4 ; i++ )\r\n{\r\nunsigned short t;\r\nt = inb(*port + ID_PORT);\r\nsum |= (t>>4) << ((t & 0x03)<<2);\r\n}\r\nif (sum==0xbaba && !eexp_hw_probe(dev,*port)) {\r\nrelease_region(*port, EEXP_IO_EXTENT);\r\nreturn 0;\r\n}\r\nrelease_region(*port, EEXP_IO_EXTENT);\r\ndev->irq = dev_irq;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstruct net_device * __init express_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct net_local));\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nerr = do_express_probe(dev);\r\nif (!err)\r\nreturn dev;\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int eexp_open(struct net_device *dev)\r\n{\r\nint ret;\r\nunsigned short ioaddr = dev->base_addr;\r\nstruct net_local *lp = netdev_priv(dev);\r\n#if NET_DEBUG > 6\r\nprintk(KERN_DEBUG "%s: eexp_open()\n", dev->name);\r\n#endif\r\nif (!dev->irq || !irqrmap[dev->irq])\r\nreturn -ENXIO;\r\nret = request_irq(dev->irq, eexp_irq, 0, dev->name, dev);\r\nif (ret)\r\nreturn ret;\r\nif (!request_region(ioaddr, EEXP_IO_EXTENT, "EtherExpress")) {\r\nprintk(KERN_WARNING "EtherExpress io port %x, is busy.\n"\r\n, ioaddr);\r\ngoto err_out1;\r\n}\r\nif (!request_region(ioaddr+0x4000, EEXP_IO_EXTENT, "EtherExpress shadow")) {\r\nprintk(KERN_WARNING "EtherExpress io port %x, is busy.\n"\r\n, ioaddr+0x4000);\r\ngoto err_out2;\r\n}\r\nif (!request_region(ioaddr+0x8000, EEXP_IO_EXTENT, "EtherExpress shadow")) {\r\nprintk(KERN_WARNING "EtherExpress io port %x, is busy.\n"\r\n, ioaddr+0x8000);\r\ngoto err_out3;\r\n}\r\nif (!request_region(ioaddr+0xc000, EEXP_IO_EXTENT, "EtherExpress shadow")) {\r\nprintk(KERN_WARNING "EtherExpress io port %x, is busy.\n"\r\n, ioaddr+0xc000);\r\ngoto err_out4;\r\n}\r\nif (lp->width) {\r\nprintk("%s: forcing ASIC to 8-bit mode\n", dev->name);\r\noutb(inb(dev->base_addr+Config)&~4, dev->base_addr+Config);\r\n}\r\neexp_hw_init586(dev);\r\nnetif_start_queue(dev);\r\n#if NET_DEBUG > 6\r\nprintk(KERN_DEBUG "%s: leaving eexp_open()\n", dev->name);\r\n#endif\r\nreturn 0;\r\nerr_out4:\r\nrelease_region(ioaddr+0x8000, EEXP_IO_EXTENT);\r\nerr_out3:\r\nrelease_region(ioaddr+0x4000, EEXP_IO_EXTENT);\r\nerr_out2:\r\nrelease_region(ioaddr, EEXP_IO_EXTENT);\r\nerr_out1:\r\nfree_irq(dev->irq, dev);\r\nreturn -EBUSY;\r\n}\r\nstatic int eexp_close(struct net_device *dev)\r\n{\r\nunsigned short ioaddr = dev->base_addr;\r\nstruct net_local *lp = netdev_priv(dev);\r\nint irq = dev->irq;\r\nnetif_stop_queue(dev);\r\noutb(SIRQ_dis|irqrmap[irq],ioaddr+SET_IRQ);\r\nlp->started = 0;\r\nscb_command(dev, SCB_CUsuspend|SCB_RUsuspend);\r\noutb(0,ioaddr+SIGNAL_CA);\r\nfree_irq(irq,dev);\r\noutb(i586_RST,ioaddr+EEPROM_Ctrl);\r\nrelease_region(ioaddr, EEXP_IO_EXTENT);\r\nrelease_region(ioaddr+0x4000, 16);\r\nrelease_region(ioaddr+0x8000, 16);\r\nrelease_region(ioaddr+0xc000, 16);\r\nreturn 0;\r\n}\r\nstatic void unstick_cu(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned short ioaddr = dev->base_addr;\r\nif (lp->started)\r\n{\r\nif (time_after(jiffies, dev_trans_start(dev) + HZ/2))\r\n{\r\nif (lp->tx_link==lp->last_tx_restart)\r\n{\r\nunsigned short boguscount=200,rsst;\r\nprintk(KERN_WARNING "%s: Retransmit timed out, status %04x, resetting...\n",\r\ndev->name, scb_status(dev));\r\neexp_hw_txinit(dev);\r\nlp->last_tx_restart = 0;\r\nscb_wrcbl(dev, lp->tx_link);\r\nscb_command(dev, SCB_CUstart);\r\noutb(0,ioaddr+SIGNAL_CA);\r\nwhile (!SCB_complete(rsst=scb_status(dev)))\r\n{\r\nif (!--boguscount)\r\n{\r\nboguscount=200;\r\nprintk(KERN_WARNING "%s: Reset timed out status %04x, retrying...\n",\r\ndev->name,rsst);\r\nscb_wrcbl(dev, lp->tx_link);\r\nscb_command(dev, SCB_CUstart);\r\noutb(0,ioaddr+SIGNAL_CA);\r\n}\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\nelse\r\n{\r\nunsigned short status = scb_status(dev);\r\nif (SCB_CUdead(status))\r\n{\r\nunsigned short txstatus = eexp_hw_lasttxstat(dev);\r\nprintk(KERN_WARNING "%s: Transmit timed out, CU not active status %04x %04x, restarting...\n",\r\ndev->name, status, txstatus);\r\neexp_hw_txrestart(dev);\r\n}\r\nelse\r\n{\r\nunsigned short txstatus = eexp_hw_lasttxstat(dev);\r\nif (netif_queue_stopped(dev) && !txstatus)\r\n{\r\nprintk(KERN_WARNING "%s: CU wedged, status %04x %04x, resetting...\n",\r\ndev->name,status,txstatus);\r\neexp_hw_init586(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nelse\r\n{\r\nprintk(KERN_WARNING "%s: transmit timed out\n", dev->name);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nif (time_after(jiffies, lp->init_time + 10))\r\n{\r\nunsigned short status = scb_status(dev);\r\nprintk(KERN_WARNING "%s: i82586 startup timed out, status %04x, resetting...\n",\r\ndev->name, status);\r\neexp_hw_init586(dev);\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\n}\r\nstatic void eexp_timeout(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\n#ifdef CONFIG_SMP\r\nunsigned long flags;\r\n#endif\r\nint status;\r\ndisable_irq(dev->irq);\r\n#ifdef CONFIG_SMP\r\nspin_lock_irqsave(&lp->lock, flags);\r\n#endif\r\nstatus = scb_status(dev);\r\nunstick_cu(dev);\r\nprintk(KERN_INFO "%s: transmit timed out, %s?\n", dev->name,\r\n(SCB_complete(status)?"lost interrupt":\r\n"board on fire"));\r\ndev->stats.tx_errors++;\r\nlp->last_tx = jiffies;\r\nif (!SCB_complete(status)) {\r\nscb_command(dev, SCB_CUabort);\r\noutb(0,dev->base_addr+SIGNAL_CA);\r\n}\r\nnetif_wake_queue(dev);\r\n#ifdef CONFIG_SMP\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n#endif\r\n}\r\nstatic netdev_tx_t eexp_xmit(struct sk_buff *buf, struct net_device *dev)\r\n{\r\nshort length = buf->len;\r\n#ifdef CONFIG_SMP\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned long flags;\r\n#endif\r\n#if NET_DEBUG > 6\r\nprintk(KERN_DEBUG "%s: eexp_xmit()\n", dev->name);\r\n#endif\r\nif (buf->len < ETH_ZLEN) {\r\nif (skb_padto(buf, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nlength = ETH_ZLEN;\r\n}\r\ndisable_irq(dev->irq);\r\n#ifdef CONFIG_SMP\r\nspin_lock_irqsave(&lp->lock, flags);\r\n#endif\r\n{\r\nunsigned short *data = (unsigned short *)buf->data;\r\ndev->stats.tx_bytes += length;\r\neexp_hw_tx_pio(dev,data,length);\r\n}\r\ndev_kfree_skb(buf);\r\n#ifdef CONFIG_SMP\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n#endif\r\nenable_irq(dev->irq);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic unsigned short eexp_start_irq(struct net_device *dev,\r\nunsigned short status)\r\n{\r\nunsigned short ack_cmd = SCB_ack(status);\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned short ioaddr = dev->base_addr;\r\nif ((dev->flags & IFF_UP) && !(lp->started & STARTED_CU)) {\r\nshort diag_status, tdr_status;\r\nwhile (SCB_CUstat(status)==2)\r\nstatus = scb_status(dev);\r\n#if NET_DEBUG > 4\r\nprintk("%s: CU went non-active (status %04x)\n",\r\ndev->name, status);\r\n#endif\r\noutw(CONF_DIAG_RESULT & ~31, ioaddr + SM_PTR);\r\ndiag_status = inw(ioaddr + SHADOW(CONF_DIAG_RESULT));\r\nif (diag_status & 1<<11) {\r\nprintk(KERN_WARNING "%s: 82586 failed self-test\n",\r\ndev->name);\r\n} else if (!(diag_status & 1<<13)) {\r\nprintk(KERN_WARNING "%s: 82586 self-test failed to complete\n", dev->name);\r\n}\r\noutw(CONF_TDR_RESULT & ~31, ioaddr + SM_PTR);\r\ntdr_status = inw(ioaddr + SHADOW(CONF_TDR_RESULT));\r\nif (tdr_status & (TDR_SHORT|TDR_OPEN)) {\r\nprintk(KERN_WARNING "%s: TDR reports cable %s at %d tick%s\n", dev->name, (tdr_status & TDR_SHORT)?"short":"broken", tdr_status & TDR_TIME, ((tdr_status & TDR_TIME) != 1) ? "s" : "");\r\n}\r\nelse if (tdr_status & TDR_XCVRPROBLEM) {\r\nprintk(KERN_WARNING "%s: TDR reports transceiver problem\n", dev->name);\r\n}\r\nelse if (tdr_status & TDR_LINKOK) {\r\n#if NET_DEBUG > 4\r\nprintk(KERN_DEBUG "%s: TDR reports link OK\n", dev->name);\r\n#endif\r\n} else {\r\nprintk("%s: TDR is ga-ga (status %04x)\n", dev->name,\r\ntdr_status);\r\n}\r\nlp->started |= STARTED_CU;\r\nscb_wrcbl(dev, lp->tx_link);\r\nif (!(lp->started & STARTED_RU)) {\r\nack_cmd |= SCB_RUstart;\r\nscb_wrrfa(dev, lp->rx_buf_start);\r\nlp->rx_ptr = lp->rx_buf_start;\r\nlp->started |= STARTED_RU;\r\n}\r\nack_cmd |= SCB_CUstart | 0x2000;\r\n}\r\nif ((dev->flags & IFF_UP) && !(lp->started & STARTED_RU) && SCB_RUstat(status)==4)\r\nlp->started|=STARTED_RU;\r\nreturn ack_cmd;\r\n}\r\nstatic void eexp_cmd_clear(struct net_device *dev)\r\n{\r\nunsigned long int oldtime = jiffies;\r\nwhile (scb_rdcmd(dev) && (time_before(jiffies, oldtime + 10)));\r\nif (scb_rdcmd(dev)) {\r\nprintk("%s: command didn't clear\n", dev->name);\r\n}\r\n}\r\nstatic irqreturn_t eexp_irq(int dummy, void *dev_info)\r\n{\r\nstruct net_device *dev = dev_info;\r\nstruct net_local *lp;\r\nunsigned short ioaddr,status,ack_cmd;\r\nunsigned short old_read_ptr, old_write_ptr;\r\nlp = netdev_priv(dev);\r\nioaddr = dev->base_addr;\r\nspin_lock(&lp->lock);\r\nold_read_ptr = inw(ioaddr+READ_PTR);\r\nold_write_ptr = inw(ioaddr+WRITE_PTR);\r\noutb(SIRQ_dis|irqrmap[dev->irq], ioaddr+SET_IRQ);\r\nstatus = scb_status(dev);\r\n#if NET_DEBUG > 4\r\nprintk(KERN_DEBUG "%s: interrupt (status %x)\n", dev->name, status);\r\n#endif\r\nif (lp->started == (STARTED_CU | STARTED_RU)) {\r\ndo {\r\neexp_cmd_clear(dev);\r\nack_cmd = SCB_ack(status);\r\nscb_command(dev, ack_cmd);\r\noutb(0,ioaddr+SIGNAL_CA);\r\neexp_cmd_clear(dev);\r\nif (SCB_complete(status)) {\r\nif (!eexp_hw_lasttxstat(dev)) {\r\nprintk("%s: tx interrupt but no status\n", dev->name);\r\n}\r\n}\r\nif (SCB_rxdframe(status))\r\neexp_hw_rx_pio(dev);\r\nstatus = scb_status(dev);\r\n} while (status & 0xc000);\r\nif (SCB_RUdead(status))\r\n{\r\nprintk(KERN_WARNING "%s: RU stopped: status %04x\n",\r\ndev->name,status);\r\n#if 0\r\nprintk(KERN_WARNING "%s: cur_rfd=%04x, cur_rbd=%04x\n", dev->name, lp->cur_rfd, lp->cur_rbd);\r\noutw(lp->cur_rfd, ioaddr+READ_PTR);\r\nprintk(KERN_WARNING "%s: [%04x]\n", dev->name, inw(ioaddr+DATAPORT));\r\noutw(lp->cur_rfd+6, ioaddr+READ_PTR);\r\nprintk(KERN_WARNING "%s: rbd is %04x\n", dev->name, rbd= inw(ioaddr+DATAPORT));\r\noutw(rbd, ioaddr+READ_PTR);\r\nprintk(KERN_WARNING "%s: [%04x %04x] ", dev->name, inw(ioaddr+DATAPORT), inw(ioaddr+DATAPORT));\r\noutw(rbd+8, ioaddr+READ_PTR);\r\nprintk("[%04x]\n", inw(ioaddr+DATAPORT));\r\n#endif\r\ndev->stats.rx_errors++;\r\n#if 1\r\neexp_hw_rxinit(dev);\r\n#else\r\nlp->cur_rfd = lp->first_rfd;\r\n#endif\r\nscb_wrrfa(dev, lp->rx_buf_start);\r\nscb_command(dev, SCB_RUstart);\r\noutb(0,ioaddr+SIGNAL_CA);\r\n}\r\n} else {\r\nif (status & 0x8000)\r\nack_cmd = eexp_start_irq(dev, status);\r\nelse\r\nack_cmd = SCB_ack(status);\r\nscb_command(dev, ack_cmd);\r\noutb(0,ioaddr+SIGNAL_CA);\r\n}\r\neexp_cmd_clear(dev);\r\noutb(SIRQ_en|irqrmap[dev->irq], ioaddr+SET_IRQ);\r\n#if NET_DEBUG > 6\r\nprintk("%s: leaving eexp_irq()\n", dev->name);\r\n#endif\r\noutw(old_read_ptr, ioaddr+READ_PTR);\r\noutw(old_write_ptr, ioaddr+WRITE_PTR);\r\nspin_unlock(&lp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void eexp_hw_set_interface(struct net_device *dev)\r\n{\r\nunsigned char oldval = inb(dev->base_addr + 0x300e);\r\noldval &= ~0x82;\r\nswitch (dev->if_port) {\r\ncase TPE:\r\noldval |= 0x2;\r\ncase BNC:\r\noldval |= 0x80;\r\nbreak;\r\n}\r\noutb(oldval, dev->base_addr+0x300e);\r\nmdelay(20);\r\n}\r\nstatic void eexp_hw_rx_pio(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned short rx_block = lp->rx_ptr;\r\nunsigned short boguscount = lp->num_rx_bufs;\r\nunsigned short ioaddr = dev->base_addr;\r\nunsigned short status;\r\n#if NET_DEBUG > 6\r\nprintk(KERN_DEBUG "%s: eexp_hw_rx()\n", dev->name);\r\n#endif\r\ndo {\r\nunsigned short rfd_cmd, rx_next, pbuf, pkt_len;\r\noutw(rx_block, ioaddr + READ_PTR);\r\nstatus = inw(ioaddr + DATAPORT);\r\nif (FD_Done(status))\r\n{\r\nrfd_cmd = inw(ioaddr + DATAPORT);\r\nrx_next = inw(ioaddr + DATAPORT);\r\npbuf = inw(ioaddr + DATAPORT);\r\noutw(pbuf, ioaddr + READ_PTR);\r\npkt_len = inw(ioaddr + DATAPORT);\r\nif (rfd_cmd!=0x0000)\r\n{\r\nprintk(KERN_WARNING "%s: rfd_cmd not zero:0x%04x\n",\r\ndev->name, rfd_cmd);\r\ncontinue;\r\n}\r\nelse if (pbuf!=rx_block+0x16)\r\n{\r\nprintk(KERN_WARNING "%s: rfd and rbd out of sync 0x%04x 0x%04x\n",\r\ndev->name, rx_block+0x16, pbuf);\r\ncontinue;\r\n}\r\nelse if ((pkt_len & 0xc000)!=0xc000)\r\n{\r\nprintk(KERN_WARNING "%s: EOF or F not set on received buffer (%04x)\n",\r\ndev->name, pkt_len & 0xc000);\r\ncontinue;\r\n}\r\nelse if (!FD_OK(status))\r\n{\r\ndev->stats.rx_errors++;\r\nif (FD_CRC(status))\r\ndev->stats.rx_crc_errors++;\r\nif (FD_Align(status))\r\ndev->stats.rx_frame_errors++;\r\nif (FD_Resrc(status))\r\ndev->stats.rx_fifo_errors++;\r\nif (FD_DMA(status))\r\ndev->stats.rx_over_errors++;\r\nif (FD_Short(status))\r\ndev->stats.rx_length_errors++;\r\n}\r\nelse\r\n{\r\nstruct sk_buff *skb;\r\npkt_len &= 0x3fff;\r\nskb = dev_alloc_skb(pkt_len+16);\r\nif (skb == NULL)\r\n{\r\nprintk(KERN_WARNING "%s: Memory squeeze, dropping packet\n",dev->name);\r\ndev->stats.rx_dropped++;\r\nbreak;\r\n}\r\nskb_reserve(skb, 2);\r\noutw(pbuf+10, ioaddr+READ_PTR);\r\ninsw(ioaddr+DATAPORT, skb_put(skb,pkt_len),(pkt_len+1)>>1);\r\nskb->protocol = eth_type_trans(skb,dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n}\r\noutw(rx_block, ioaddr+WRITE_PTR);\r\noutw(0, ioaddr+DATAPORT);\r\noutw(0, ioaddr+DATAPORT);\r\nrx_block = rx_next;\r\n}\r\n} while (FD_Done(status) && boguscount--);\r\nlp->rx_ptr = rx_block;\r\n}\r\nstatic void eexp_hw_tx_pio(struct net_device *dev, unsigned short *buf,\r\nunsigned short len)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned short ioaddr = dev->base_addr;\r\nif (LOCKUP16 || lp->width) {\r\nscb_command(dev, SCB_CUsuspend);\r\noutw(0xFFFF, ioaddr+SIGNAL_CA);\r\n}\r\noutw(lp->tx_head, ioaddr + WRITE_PTR);\r\noutw(0x0000, ioaddr + DATAPORT);\r\noutw(Cmd_INT|Cmd_Xmit, ioaddr + DATAPORT);\r\noutw(lp->tx_head+0x08, ioaddr + DATAPORT);\r\noutw(lp->tx_head+0x0e, ioaddr + DATAPORT);\r\noutw(0x0000, ioaddr + DATAPORT);\r\noutw(0x0000, ioaddr + DATAPORT);\r\noutw(lp->tx_head+0x08, ioaddr + DATAPORT);\r\noutw(0x8000|len, ioaddr + DATAPORT);\r\noutw(-1, ioaddr + DATAPORT);\r\noutw(lp->tx_head+0x16, ioaddr + DATAPORT);\r\noutw(0, ioaddr + DATAPORT);\r\noutsw(ioaddr + DATAPORT, buf, (len+1)>>1);\r\noutw(lp->tx_tail+0xc, ioaddr + WRITE_PTR);\r\noutw(lp->tx_head, ioaddr + DATAPORT);\r\ndev->trans_start = jiffies;\r\nlp->tx_tail = lp->tx_head;\r\nif (lp->tx_head==TX_BUF_START+((lp->num_tx_bufs-1)*TX_BUF_SIZE))\r\nlp->tx_head = TX_BUF_START;\r\nelse\r\nlp->tx_head += TX_BUF_SIZE;\r\nif (lp->tx_head != lp->tx_reap)\r\nnetif_wake_queue(dev);\r\nif (LOCKUP16 || lp->width) {\r\nscb_command(dev, SCB_CUresume);\r\noutw(0xFFFF, ioaddr+SIGNAL_CA);\r\n}\r\ndev->stats.tx_packets++;\r\nlp->last_tx = jiffies;\r\n}\r\nstatic int __init eexp_hw_probe(struct net_device *dev, unsigned short ioaddr)\r\n{\r\nunsigned short hw_addr[3];\r\nunsigned char buswidth;\r\nunsigned int memory_size;\r\nint i;\r\nunsigned short xsum = 0;\r\nstruct net_local *lp = netdev_priv(dev);\r\nprintk("%s: EtherExpress 16 at %#x ",dev->name,ioaddr);\r\noutb(ASIC_RST, ioaddr+EEPROM_Ctrl);\r\noutb(0, ioaddr+EEPROM_Ctrl);\r\nudelay(500);\r\noutb(i586_RST, ioaddr+EEPROM_Ctrl);\r\nhw_addr[0] = eexp_hw_readeeprom(ioaddr,2);\r\nhw_addr[1] = eexp_hw_readeeprom(ioaddr,3);\r\nhw_addr[2] = eexp_hw_readeeprom(ioaddr,4);\r\nif (!((hw_addr[2]==0x00aa && ((hw_addr[1] & 0xff00)==0x0000)) ||\r\n(hw_addr[2]==0x0080 && ((hw_addr[1] & 0xff00)==0x5F00))))\r\n{\r\nprintk(" rejected: invalid address %04x%04x%04x\n",\r\nhw_addr[2],hw_addr[1],hw_addr[0]);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < 64; i++)\r\nxsum += eexp_hw_readeeprom(ioaddr, i);\r\nif (xsum != 0xbaba)\r\nprintk(" (bad EEPROM xsum 0x%02x)", xsum);\r\ndev->base_addr = ioaddr;\r\nfor ( i=0 ; i<6 ; i++ )\r\ndev->dev_addr[i] = ((unsigned char *)hw_addr)[5-i];\r\n{\r\nstatic const char irqmap[] = { 0, 9, 3, 4, 5, 10, 11, 0 };\r\nunsigned short setupval = eexp_hw_readeeprom(ioaddr,0);\r\nif (!dev->irq)\r\ndev->irq = irqmap[setupval>>13];\r\nif (dev->if_port == 0xff) {\r\ndev->if_port = !(setupval & 0x1000) ? AUI :\r\neexp_hw_readeeprom(ioaddr,5) & 0x1 ? TPE : BNC;\r\n}\r\nbuswidth = !((setupval & 0x400) >> 10);\r\n}\r\nmemset(lp, 0, sizeof(struct net_local));\r\nspin_lock_init(&lp->lock);\r\nprintk("(IRQ %d, %s connector, %d-bit bus", dev->irq,\r\neexp_ifmap[dev->if_port], buswidth?8:16);\r\nif (!request_region(dev->base_addr + 0x300e, 1, "EtherExpress"))\r\nreturn -EBUSY;\r\neexp_hw_set_interface(dev);\r\nrelease_region(dev->base_addr + 0x300e, 1);\r\noutw(0, dev->base_addr + WRITE_PTR);\r\nfor (i = 0; i < 32768; i++)\r\noutw(0, dev->base_addr + DATAPORT);\r\nfor (memory_size = 0; memory_size < 64; memory_size++)\r\n{\r\noutw(memory_size<<10, dev->base_addr + READ_PTR);\r\nif (inw(dev->base_addr+DATAPORT))\r\nbreak;\r\noutw(memory_size<<10, dev->base_addr + WRITE_PTR);\r\noutw(memory_size | 0x5000, dev->base_addr+DATAPORT);\r\noutw(memory_size<<10, dev->base_addr + READ_PTR);\r\nif (inw(dev->base_addr+DATAPORT) != (memory_size | 0x5000))\r\nbreak;\r\n}\r\nlp->num_tx_bufs = 4;\r\nlp->rx_buf_end = 0x3ff6;\r\nswitch (memory_size)\r\n{\r\ncase 64:\r\nlp->rx_buf_end += 0x4000;\r\ncase 48:\r\nlp->num_tx_bufs += 4;\r\nlp->rx_buf_end += 0x4000;\r\ncase 32:\r\nlp->rx_buf_end += 0x4000;\r\ncase 16:\r\nprintk(", %dk RAM)\n", memory_size);\r\nbreak;\r\ndefault:\r\nprintk(") bad memory size (%dk).\n", memory_size);\r\nreturn -ENODEV;\r\nbreak;\r\n}\r\nlp->rx_buf_start = TX_BUF_START + (lp->num_tx_bufs*TX_BUF_SIZE);\r\nlp->width = buswidth;\r\ndev->netdev_ops = &eexp_netdev_ops;\r\ndev->watchdog_timeo = 2*HZ;\r\nreturn register_netdev(dev);\r\n}\r\nstatic unsigned short __init eexp_hw_readeeprom(unsigned short ioaddr,\r\nunsigned char location)\r\n{\r\nunsigned short cmd = 0x180|(location&0x7f);\r\nunsigned short rval = 0,wval = EC_CS|i586_RST;\r\nint i;\r\noutb(EC_CS|i586_RST,ioaddr+EEPROM_Ctrl);\r\nfor (i=0x100 ; i ; i>>=1 )\r\n{\r\nif (cmd&i)\r\nwval |= EC_Wr;\r\nelse\r\nwval &= ~EC_Wr;\r\noutb(wval,ioaddr+EEPROM_Ctrl);\r\noutb(wval|EC_Clk,ioaddr+EEPROM_Ctrl);\r\neeprom_delay();\r\noutb(wval,ioaddr+EEPROM_Ctrl);\r\neeprom_delay();\r\n}\r\nwval &= ~EC_Wr;\r\noutb(wval,ioaddr+EEPROM_Ctrl);\r\nfor (i=0x8000 ; i ; i>>=1 )\r\n{\r\noutb(wval|EC_Clk,ioaddr+EEPROM_Ctrl);\r\neeprom_delay();\r\nif (inb(ioaddr+EEPROM_Ctrl)&EC_Rd)\r\nrval |= i;\r\noutb(wval,ioaddr+EEPROM_Ctrl);\r\neeprom_delay();\r\n}\r\nwval &= ~EC_CS;\r\noutb(wval|EC_Clk,ioaddr+EEPROM_Ctrl);\r\neeprom_delay();\r\noutb(wval,ioaddr+EEPROM_Ctrl);\r\neeprom_delay();\r\nreturn rval;\r\n}\r\nstatic unsigned short eexp_hw_lasttxstat(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned short tx_block = lp->tx_reap;\r\nunsigned short status;\r\nif (!netif_queue_stopped(dev) && lp->tx_head==lp->tx_reap)\r\nreturn 0x0000;\r\ndo\r\n{\r\noutw(tx_block & ~31, dev->base_addr + SM_PTR);\r\nstatus = inw(dev->base_addr + SHADOW(tx_block));\r\nif (!Stat_Done(status))\r\n{\r\nlp->tx_link = tx_block;\r\nreturn status;\r\n}\r\nelse\r\n{\r\nlp->last_tx_restart = 0;\r\ndev->stats.collisions += Stat_NoColl(status);\r\nif (!Stat_OK(status))\r\n{\r\nchar *whatsup = NULL;\r\ndev->stats.tx_errors++;\r\nif (Stat_Abort(status))\r\ndev->stats.tx_aborted_errors++;\r\nif (Stat_TNoCar(status)) {\r\nwhatsup = "aborted, no carrier";\r\ndev->stats.tx_carrier_errors++;\r\n}\r\nif (Stat_TNoCTS(status)) {\r\nwhatsup = "aborted, lost CTS";\r\ndev->stats.tx_carrier_errors++;\r\n}\r\nif (Stat_TNoDMA(status)) {\r\nwhatsup = "FIFO underran";\r\ndev->stats.tx_fifo_errors++;\r\n}\r\nif (Stat_TXColl(status)) {\r\nwhatsup = "aborted, too many collisions";\r\ndev->stats.tx_aborted_errors++;\r\n}\r\nif (whatsup)\r\nprintk(KERN_INFO "%s: transmit %s\n",\r\ndev->name, whatsup);\r\n}\r\nelse\r\ndev->stats.tx_packets++;\r\n}\r\nif (tx_block == TX_BUF_START+((lp->num_tx_bufs-1)*TX_BUF_SIZE))\r\nlp->tx_reap = tx_block = TX_BUF_START;\r\nelse\r\nlp->tx_reap = tx_block += TX_BUF_SIZE;\r\nnetif_wake_queue(dev);\r\n}\r\nwhile (lp->tx_reap != lp->tx_head);\r\nlp->tx_link = lp->tx_tail + 0x08;\r\nreturn status;\r\n}\r\nstatic void eexp_hw_txrestart(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned short ioaddr = dev->base_addr;\r\nlp->last_tx_restart = lp->tx_link;\r\nscb_wrcbl(dev, lp->tx_link);\r\nscb_command(dev, SCB_CUstart);\r\noutb(0,ioaddr+SIGNAL_CA);\r\n{\r\nunsigned short boguscount=50,failcount=5;\r\nwhile (!scb_status(dev))\r\n{\r\nif (!--boguscount)\r\n{\r\nif (--failcount)\r\n{\r\nprintk(KERN_WARNING "%s: CU start timed out, status %04x, cmd %04x\n", dev->name, scb_status(dev), scb_rdcmd(dev));\r\nscb_wrcbl(dev, lp->tx_link);\r\nscb_command(dev, SCB_CUstart);\r\noutb(0,ioaddr+SIGNAL_CA);\r\nboguscount = 100;\r\n}\r\nelse\r\n{\r\nprintk(KERN_WARNING "%s: Failed to restart CU, resetting board...\n",dev->name);\r\neexp_hw_init586(dev);\r\nnetif_wake_queue(dev);\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void eexp_hw_txinit(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned short tx_block = TX_BUF_START;\r\nunsigned short curtbuf;\r\nunsigned short ioaddr = dev->base_addr;\r\nfor ( curtbuf=0 ; curtbuf<lp->num_tx_bufs ; curtbuf++ )\r\n{\r\noutw(tx_block, ioaddr + WRITE_PTR);\r\noutw(0x0000, ioaddr + DATAPORT);\r\noutw(Cmd_INT|Cmd_Xmit, ioaddr + DATAPORT);\r\noutw(tx_block+0x08, ioaddr + DATAPORT);\r\noutw(tx_block+0x0e, ioaddr + DATAPORT);\r\noutw(0x0000, ioaddr + DATAPORT);\r\noutw(0x0000, ioaddr + DATAPORT);\r\noutw(tx_block+0x08, ioaddr + DATAPORT);\r\noutw(0x8000, ioaddr + DATAPORT);\r\noutw(-1, ioaddr + DATAPORT);\r\noutw(tx_block+0x16, ioaddr + DATAPORT);\r\noutw(0x0000, ioaddr + DATAPORT);\r\ntx_block += TX_BUF_SIZE;\r\n}\r\nlp->tx_head = TX_BUF_START;\r\nlp->tx_reap = TX_BUF_START;\r\nlp->tx_tail = tx_block - TX_BUF_SIZE;\r\nlp->tx_link = lp->tx_tail + 0x08;\r\nlp->rx_buf_start = tx_block;\r\n}\r\nstatic void eexp_hw_rxinit(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned short rx_block = lp->rx_buf_start;\r\nunsigned short ioaddr = dev->base_addr;\r\nlp->num_rx_bufs = 0;\r\nlp->rx_first = lp->rx_ptr = rx_block;\r\ndo\r\n{\r\nlp->num_rx_bufs++;\r\noutw(rx_block, ioaddr + WRITE_PTR);\r\noutw(0, ioaddr + DATAPORT); outw(0, ioaddr+DATAPORT);\r\noutw(rx_block + RX_BUF_SIZE, ioaddr+DATAPORT);\r\noutw(0xffff, ioaddr+DATAPORT);\r\noutw(0x0000, ioaddr+DATAPORT);\r\noutw(0xdead, ioaddr+DATAPORT);\r\noutw(0xdead, ioaddr+DATAPORT);\r\noutw(0xdead, ioaddr+DATAPORT);\r\noutw(0xdead, ioaddr+DATAPORT);\r\noutw(0xdead, ioaddr+DATAPORT);\r\noutw(0xdead, ioaddr+DATAPORT);\r\noutw(0x0000, ioaddr+DATAPORT);\r\noutw(rx_block + RX_BUF_SIZE + 0x16, ioaddr+DATAPORT);\r\noutw(rx_block + 0x20, ioaddr+DATAPORT);\r\noutw(0, ioaddr+DATAPORT);\r\noutw(RX_BUF_SIZE-0x20, ioaddr+DATAPORT);\r\nlp->rx_last = rx_block;\r\nrx_block += RX_BUF_SIZE;\r\n} while (rx_block <= lp->rx_buf_end-RX_BUF_SIZE);\r\noutw(lp->rx_first + 6, ioaddr+WRITE_PTR);\r\noutw(lp->rx_first + 0x16, ioaddr+DATAPORT);\r\noutw(lp->rx_last + 4, ioaddr+WRITE_PTR);\r\noutw(lp->rx_first, ioaddr+DATAPORT);\r\noutw(lp->rx_last + 0x16 + 2, ioaddr+WRITE_PTR);\r\noutw(lp->rx_first + 0x16, ioaddr+DATAPORT);\r\n}\r\nstatic void eexp_hw_init586(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned short ioaddr = dev->base_addr;\r\nint i;\r\n#if NET_DEBUG > 6\r\nprintk("%s: eexp_hw_init586()\n", dev->name);\r\n#endif\r\nlp->started = 0;\r\nset_loopback(dev);\r\noutb(SIRQ_dis|irqrmap[dev->irq],ioaddr+SET_IRQ);\r\noutw(lp->rx_buf_end & ~31, ioaddr + SM_PTR);\r\noutw(lp->width?0x0001:0x0000, ioaddr + 0x8006);\r\noutw(0x0000, ioaddr + 0x8008);\r\noutw(0x0000, ioaddr + 0x800a);\r\noutw(0x0000, ioaddr + 0x800c);\r\noutw(0x0000, ioaddr + 0x800e);\r\nfor (i = 0; i < ARRAY_SIZE(start_code) * 2; i+=32) {\r\nint j;\r\noutw(i, ioaddr + SM_PTR);\r\nfor (j = 0; j < 16 && (i+j)/2 < ARRAY_SIZE(start_code); j+=2)\r\noutw(start_code[(i+j)/2],\r\nioaddr+0x4000+j);\r\nfor (j = 0; j < 16 && (i+j+16)/2 < ARRAY_SIZE(start_code); j+=2)\r\noutw(start_code[(i+j+16)/2],\r\nioaddr+0x8000+j);\r\n}\r\noutw(CONF_PROMISC & ~31, ioaddr+SM_PTR);\r\ni = inw(ioaddr+SHADOW(CONF_PROMISC));\r\noutw((dev->flags & IFF_PROMISC)?(i|1):(i & ~1),\r\nioaddr+SHADOW(CONF_PROMISC));\r\nlp->was_promisc = dev->flags & IFF_PROMISC;\r\n#if 0\r\neexp_setup_filter(dev);\r\n#endif\r\noutw(CONF_HWADDR & ~31, ioaddr+SM_PTR);\r\noutw(((unsigned short *)dev->dev_addr)[0], ioaddr+SHADOW(CONF_HWADDR));\r\noutw(((unsigned short *)dev->dev_addr)[1],\r\nioaddr+SHADOW(CONF_HWADDR+2));\r\noutw(((unsigned short *)dev->dev_addr)[2],\r\nioaddr+SHADOW(CONF_HWADDR+4));\r\neexp_hw_txinit(dev);\r\neexp_hw_rxinit(dev);\r\noutb(0,ioaddr+EEPROM_Ctrl);\r\nmdelay(5);\r\nscb_command(dev, 0xf000);\r\noutb(0,ioaddr+SIGNAL_CA);\r\noutw(0, ioaddr+SM_PTR);\r\n{\r\nunsigned short rboguscount=50,rfailcount=5;\r\nwhile (inw(ioaddr+0x4000))\r\n{\r\nif (!--rboguscount)\r\n{\r\nprintk(KERN_WARNING "%s: i82586 reset timed out, kicking...\n",\r\ndev->name);\r\nscb_command(dev, 0);\r\noutb(0,ioaddr+SIGNAL_CA);\r\nrboguscount = 100;\r\nif (!--rfailcount)\r\n{\r\nprintk(KERN_WARNING "%s: i82586 not responding, giving up.\n",\r\ndev->name);\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nscb_wrcbl(dev, CONF_LINK);\r\nscb_command(dev, 0xf000|SCB_CUstart);\r\noutb(0,ioaddr+SIGNAL_CA);\r\n{\r\nunsigned short iboguscount=50,ifailcount=5;\r\nwhile (!scb_status(dev))\r\n{\r\nif (!--iboguscount)\r\n{\r\nif (--ifailcount)\r\n{\r\nprintk(KERN_WARNING "%s: i82586 initialization timed out, status %04x, cmd %04x\n",\r\ndev->name, scb_status(dev), scb_rdcmd(dev));\r\nscb_wrcbl(dev, CONF_LINK);\r\nscb_command(dev, 0xf000|SCB_CUstart);\r\noutb(0,ioaddr+SIGNAL_CA);\r\niboguscount = 100;\r\n}\r\nelse\r\n{\r\nprintk(KERN_WARNING "%s: Failed to initialize i82586, giving up.\n",dev->name);\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nclear_loopback(dev);\r\noutb(SIRQ_en|irqrmap[dev->irq],ioaddr+SET_IRQ);\r\nlp->init_time = jiffies;\r\n#if NET_DEBUG > 6\r\nprintk("%s: leaving eexp_hw_init586()\n", dev->name);\r\n#endif\r\n}\r\nstatic void eexp_setup_filter(struct net_device *dev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nunsigned short ioaddr = dev->base_addr;\r\nint count = netdev_mc_count(dev);\r\nint i;\r\nif (count > 8) {\r\nprintk(KERN_INFO "%s: too many multicast addresses (%d)\n",\r\ndev->name, count);\r\ncount = 8;\r\n}\r\noutw(CONF_NR_MULTICAST & ~31, ioaddr+SM_PTR);\r\noutw(6*count, ioaddr+SHADOW(CONF_NR_MULTICAST));\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nunsigned short *data = (unsigned short *) ha->addr;\r\nif (i == count)\r\nbreak;\r\noutw((CONF_MULTICAST+(6*i)) & ~31, ioaddr+SM_PTR);\r\noutw(data[0], ioaddr+SHADOW(CONF_MULTICAST+(6*i)));\r\noutw((CONF_MULTICAST+(6*i)+2) & ~31, ioaddr+SM_PTR);\r\noutw(data[1], ioaddr+SHADOW(CONF_MULTICAST+(6*i)+2));\r\noutw((CONF_MULTICAST+(6*i)+4) & ~31, ioaddr+SM_PTR);\r\noutw(data[2], ioaddr+SHADOW(CONF_MULTICAST+(6*i)+4));\r\ni++;\r\n}\r\n}\r\nstatic void\r\neexp_set_multicast(struct net_device *dev)\r\n{\r\nunsigned short ioaddr = dev->base_addr;\r\nstruct net_local *lp = netdev_priv(dev);\r\nint kick = 0, i;\r\nif ((dev->flags & IFF_PROMISC) != lp->was_promisc) {\r\noutw(CONF_PROMISC & ~31, ioaddr+SM_PTR);\r\ni = inw(ioaddr+SHADOW(CONF_PROMISC));\r\noutw((dev->flags & IFF_PROMISC)?(i|1):(i & ~1),\r\nioaddr+SHADOW(CONF_PROMISC));\r\nlp->was_promisc = dev->flags & IFF_PROMISC;\r\nkick = 1;\r\n}\r\nif (!(dev->flags & IFF_PROMISC)) {\r\neexp_setup_filter(dev);\r\nif (lp->old_mc_count != netdev_mc_count(dev)) {\r\nkick = 1;\r\nlp->old_mc_count = netdev_mc_count(dev);\r\n}\r\n}\r\nif (kick) {\r\nunsigned long oj;\r\nscb_command(dev, SCB_CUsuspend);\r\noutb(0, ioaddr+SIGNAL_CA);\r\noutb(0, ioaddr+SIGNAL_CA);\r\n#if 0\r\nprintk("%s: waiting for CU to go suspended\n", dev->name);\r\n#endif\r\noj = jiffies;\r\nwhile ((SCB_CUstat(scb_status(dev)) == 2) &&\r\n(time_before(jiffies, oj + 2000)));\r\nif (SCB_CUstat(scb_status(dev)) == 2)\r\nprintk("%s: warning, CU didn't stop\n", dev->name);\r\nlp->started &= ~(STARTED_CU);\r\nscb_wrcbl(dev, CONF_LINK);\r\nscb_command(dev, SCB_CUstart);\r\noutb(0, ioaddr+SIGNAL_CA);\r\n}\r\n}\r\nint __init init_module(void)\r\n{\r\nstruct net_device *dev;\r\nint this_dev, found = 0;\r\nfor (this_dev = 0; this_dev < EEXP_MAX_CARDS; this_dev++) {\r\ndev = alloc_etherdev(sizeof(struct net_local));\r\ndev->irq = irq[this_dev];\r\ndev->base_addr = io[this_dev];\r\nif (io[this_dev] == 0) {\r\nif (this_dev)\r\nbreak;\r\nprintk(KERN_NOTICE "eexpress.c: Module autoprobe not recommended, give io=xx.\n");\r\n}\r\nif (do_express_probe(dev) == 0) {\r\ndev_eexp[this_dev] = dev;\r\nfound++;\r\ncontinue;\r\n}\r\nprintk(KERN_WARNING "eexpress.c: Failed to register card at 0x%x.\n", io[this_dev]);\r\nfree_netdev(dev);\r\nbreak;\r\n}\r\nif (found)\r\nreturn 0;\r\nreturn -ENXIO;\r\n}\r\nvoid __exit cleanup_module(void)\r\n{\r\nint this_dev;\r\nfor (this_dev = 0; this_dev < EEXP_MAX_CARDS; this_dev++) {\r\nstruct net_device *dev = dev_eexp[this_dev];\r\nif (dev) {\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}
