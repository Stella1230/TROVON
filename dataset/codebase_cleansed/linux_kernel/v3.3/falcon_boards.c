static int efx_poke_lm87(struct i2c_client *client, const u8 *reg_values)\r\n{\r\nwhile (*reg_values) {\r\nu8 reg = *reg_values++;\r\nu8 value = *reg_values++;\r\nint rc = i2c_smbus_write_byte_data(client, reg, value);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int efx_init_lm87(struct efx_nic *efx, struct i2c_board_info *info,\r\nconst u8 *reg_values)\r\n{\r\nstruct falcon_board *board = falcon_board(efx);\r\nstruct i2c_client *client = i2c_new_device(&board->i2c_adap, info);\r\nint rc;\r\nif (!client)\r\nreturn -EIO;\r\ni2c_smbus_read_byte_data(client, LM87_REG_ALARMS1);\r\ni2c_smbus_read_byte_data(client, LM87_REG_ALARMS2);\r\nrc = efx_poke_lm87(client, reg_values);\r\nif (rc)\r\ngoto err;\r\nrc = efx_poke_lm87(client, falcon_lm87_common_regs);\r\nif (rc)\r\ngoto err;\r\nboard->hwmon_client = client;\r\nreturn 0;\r\nerr:\r\ni2c_unregister_device(client);\r\nreturn rc;\r\n}\r\nstatic void efx_fini_lm87(struct efx_nic *efx)\r\n{\r\ni2c_unregister_device(falcon_board(efx)->hwmon_client);\r\n}\r\nstatic int efx_check_lm87(struct efx_nic *efx, unsigned mask)\r\n{\r\nstruct i2c_client *client = falcon_board(efx)->hwmon_client;\r\nbool temp_crit, elec_fault, is_failure;\r\nu16 alarms;\r\ns32 reg;\r\nif (EFX_WORKAROUND_7884(efx) && efx->link_state.up)\r\nreturn 0;\r\nreg = i2c_smbus_read_byte_data(client, LM87_REG_ALARMS1);\r\nif (reg < 0)\r\nreturn reg;\r\nalarms = reg;\r\nreg = i2c_smbus_read_byte_data(client, LM87_REG_ALARMS2);\r\nif (reg < 0)\r\nreturn reg;\r\nalarms |= reg << 8;\r\nalarms &= mask;\r\ntemp_crit = false;\r\nif (alarms & LM87_ALARM_TEMP_INT) {\r\nreg = i2c_smbus_read_byte_data(client, LM87_REG_TEMP_INT);\r\nif (reg < 0)\r\nreturn reg;\r\nif (reg > FALCON_BOARD_TEMP_CRIT)\r\ntemp_crit = true;\r\n}\r\nif (alarms & LM87_ALARM_TEMP_EXT1) {\r\nreg = i2c_smbus_read_byte_data(client, LM87_REG_TEMP_EXT1);\r\nif (reg < 0)\r\nreturn reg;\r\nif (reg > FALCON_JUNC_TEMP_CRIT)\r\ntemp_crit = true;\r\n}\r\nelec_fault = alarms & ~(LM87_ALARM_TEMP_INT | LM87_ALARM_TEMP_EXT1);\r\nis_failure = temp_crit || elec_fault;\r\nif (alarms)\r\nnetif_err(efx, hw, efx->net_dev,\r\n"LM87 detected a hardware %s (status %02x:%02x)"\r\n"%s%s%s%s\n",\r\nis_failure ? "failure" : "problem",\r\nalarms & 0xff, alarms >> 8,\r\n(alarms & LM87_ALARM_TEMP_INT) ?\r\n"; board is overheating" : "",\r\n(alarms & LM87_ALARM_TEMP_EXT1) ?\r\n"; controller is overheating" : "",\r\ntemp_crit ? "; reached critical temperature" : "",\r\nelec_fault ? "; electrical fault" : "");\r\nreturn is_failure ? -ERANGE : 0;\r\n}\r\nstatic inline int\r\nefx_init_lm87(struct efx_nic *efx, struct i2c_board_info *info,\r\nconst u8 *reg_values)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void efx_fini_lm87(struct efx_nic *efx)\r\n{\r\n}\r\nstatic inline int efx_check_lm87(struct efx_nic *efx, unsigned mask)\r\n{\r\nreturn 0;\r\n}\r\nstatic void sfe4001_poweroff(struct efx_nic *efx)\r\n{\r\nstruct i2c_client *ioexp_client = falcon_board(efx)->ioexp_client;\r\nstruct i2c_client *hwmon_client = falcon_board(efx)->hwmon_client;\r\ni2c_smbus_write_byte_data(ioexp_client, P0_OUT, 0xff);\r\ni2c_smbus_write_byte_data(ioexp_client, P1_CONFIG, 0xff);\r\ni2c_smbus_write_byte_data(ioexp_client, P0_CONFIG, 0xff);\r\ni2c_smbus_read_byte_data(hwmon_client, MAX664X_REG_RSL);\r\n}\r\nstatic int sfe4001_poweron(struct efx_nic *efx)\r\n{\r\nstruct i2c_client *ioexp_client = falcon_board(efx)->ioexp_client;\r\nstruct i2c_client *hwmon_client = falcon_board(efx)->hwmon_client;\r\nunsigned int i, j;\r\nint rc;\r\nu8 out;\r\nrc = i2c_smbus_read_byte_data(hwmon_client, MAX664X_REG_RSL);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = i2c_smbus_write_byte_data(ioexp_client, P0_CONFIG, 0x00);\r\nif (rc)\r\nreturn rc;\r\nrc = i2c_smbus_write_byte_data(ioexp_client, P1_CONFIG,\r\n0xff & ~(1 << P1_SPARE_LBN));\r\nif (rc)\r\ngoto fail_on;\r\nrc = i2c_smbus_read_byte_data(ioexp_client, P0_OUT);\r\nif (rc < 0)\r\ngoto fail_on;\r\nout = 0xff & ~((0 << P0_EN_1V2_LBN) | (0 << P0_EN_2V5_LBN) |\r\n(0 << P0_EN_3V3X_LBN) | (0 << P0_EN_5V_LBN) |\r\n(0 << P0_EN_1V0X_LBN));\r\nif (rc != out) {\r\nnetif_info(efx, hw, efx->net_dev, "power-cycling PHY\n");\r\nrc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);\r\nif (rc)\r\ngoto fail_on;\r\nschedule_timeout_uninterruptible(HZ);\r\n}\r\nfor (i = 0; i < 20; ++i) {\r\nout = 0xff & ~((1 << P0_EN_1V2_LBN) | (1 << P0_EN_2V5_LBN) |\r\n(1 << P0_EN_3V3X_LBN) | (1 << P0_EN_5V_LBN) |\r\n(1 << P0_X_TRST_LBN));\r\nif (efx->phy_mode & PHY_MODE_SPECIAL)\r\nout |= 1 << P0_EN_3V3X_LBN;\r\nrc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);\r\nif (rc)\r\ngoto fail_on;\r\nmsleep(10);\r\nout &= ~(1 << P0_EN_1V0X_LBN);\r\nrc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);\r\nif (rc)\r\ngoto fail_on;\r\nnetif_info(efx, hw, efx->net_dev,\r\n"waiting for DSP boot (attempt %d)...\n", i);\r\nif (efx->phy_mode & PHY_MODE_SPECIAL) {\r\nschedule_timeout_uninterruptible(HZ);\r\nreturn 0;\r\n}\r\nfor (j = 0; j < 10; ++j) {\r\nmsleep(100);\r\nrc = i2c_smbus_read_byte_data(ioexp_client, P1_IN);\r\nif (rc < 0)\r\ngoto fail_on;\r\nif (rc & (1 << P1_AFE_PWD_LBN))\r\nreturn 0;\r\n}\r\n}\r\nnetif_info(efx, hw, efx->net_dev, "timed out waiting for DSP boot\n");\r\nrc = -ETIMEDOUT;\r\nfail_on:\r\nsfe4001_poweroff(efx);\r\nreturn rc;\r\n}\r\nstatic ssize_t show_phy_flash_cfg(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));\r\nreturn sprintf(buf, "%d\n", !!(efx->phy_mode & PHY_MODE_SPECIAL));\r\n}\r\nstatic ssize_t set_phy_flash_cfg(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));\r\nenum efx_phy_mode old_mode, new_mode;\r\nint err;\r\nrtnl_lock();\r\nold_mode = efx->phy_mode;\r\nif (count == 0 || *buf == '0')\r\nnew_mode = old_mode & ~PHY_MODE_SPECIAL;\r\nelse\r\nnew_mode = PHY_MODE_SPECIAL;\r\nif (!((old_mode ^ new_mode) & PHY_MODE_SPECIAL)) {\r\nerr = 0;\r\n} else if (efx->state != STATE_RUNNING || netif_running(efx->net_dev)) {\r\nerr = -EBUSY;\r\n} else {\r\nefx->phy_mode = new_mode;\r\nif (new_mode & PHY_MODE_SPECIAL)\r\nfalcon_stop_nic_stats(efx);\r\nerr = sfe4001_poweron(efx);\r\nif (!err)\r\nerr = efx_reconfigure_port(efx);\r\nif (!(new_mode & PHY_MODE_SPECIAL))\r\nfalcon_start_nic_stats(efx);\r\n}\r\nrtnl_unlock();\r\nreturn err ? err : count;\r\n}\r\nstatic void sfe4001_fini(struct efx_nic *efx)\r\n{\r\nstruct falcon_board *board = falcon_board(efx);\r\nnetif_info(efx, drv, efx->net_dev, "%s\n", __func__);\r\ndevice_remove_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);\r\nsfe4001_poweroff(efx);\r\ni2c_unregister_device(board->ioexp_client);\r\ni2c_unregister_device(board->hwmon_client);\r\n}\r\nstatic int sfe4001_check_hw(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\ns32 status;\r\nif (EFX_WORKAROUND_7884(efx) && !nic_data->xmac_poll_required)\r\nreturn 0;\r\nstatus = i2c_smbus_read_byte_data(falcon_board(efx)->ioexp_client, P1_IN);\r\nif (status >= 0 &&\r\n(status & ((1 << P1_AFE_PWD_LBN) | (1 << P1_DSP_PWD25_LBN))) != 0)\r\nreturn 0;\r\nsfe4001_poweroff(efx);\r\nefx->phy_mode = PHY_MODE_OFF;\r\nreturn (status < 0) ? -EIO : -ERANGE;\r\n}\r\nstatic int sfe4001_init(struct efx_nic *efx)\r\n{\r\nstruct falcon_board *board = falcon_board(efx);\r\nint rc;\r\n#if defined(CONFIG_SENSORS_LM90) || defined(CONFIG_SENSORS_LM90_MODULE)\r\nboard->hwmon_client =\r\ni2c_new_device(&board->i2c_adap, &sfe4001_hwmon_info);\r\n#else\r\nboard->hwmon_client =\r\ni2c_new_dummy(&board->i2c_adap, sfe4001_hwmon_info.addr);\r\n#endif\r\nif (!board->hwmon_client)\r\nreturn -EIO;\r\nrc = i2c_smbus_write_byte_data(board->hwmon_client,\r\nMAX664X_REG_WLHO, 90);\r\nif (rc)\r\ngoto fail_hwmon;\r\nboard->ioexp_client = i2c_new_dummy(&board->i2c_adap, PCA9539);\r\nif (!board->ioexp_client) {\r\nrc = -EIO;\r\ngoto fail_hwmon;\r\n}\r\nif (efx->phy_mode & PHY_MODE_SPECIAL) {\r\nfalcon_stop_nic_stats(efx);\r\n}\r\nrc = sfe4001_poweron(efx);\r\nif (rc)\r\ngoto fail_ioexp;\r\nrc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);\r\nif (rc)\r\ngoto fail_on;\r\nnetif_info(efx, hw, efx->net_dev, "PHY is powered on\n");\r\nreturn 0;\r\nfail_on:\r\nsfe4001_poweroff(efx);\r\nfail_ioexp:\r\ni2c_unregister_device(board->ioexp_client);\r\nfail_hwmon:\r\ni2c_unregister_device(board->hwmon_client);\r\nreturn rc;\r\n}\r\nstatic void sfe4002_init_phy(struct efx_nic *efx)\r\n{\r\nfalcon_qt202x_set_led(efx, SFE4002_TX_LED,\r\nQUAKE_LED_TXLINK | QUAKE_LED_LINK_ACTSTAT);\r\nfalcon_qt202x_set_led(efx, SFE4002_RX_LED,\r\nQUAKE_LED_RXLINK | QUAKE_LED_LINK_ACTSTAT);\r\nfalcon_qt202x_set_led(efx, SFE4002_FAULT_LED, QUAKE_LED_OFF);\r\n}\r\nstatic void sfe4002_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)\r\n{\r\nfalcon_qt202x_set_led(\r\nefx, SFE4002_FAULT_LED,\r\n(mode == EFX_LED_ON) ? QUAKE_LED_ON : QUAKE_LED_OFF);\r\n}\r\nstatic int sfe4002_check_hw(struct efx_nic *efx)\r\n{\r\nstruct falcon_board *board = falcon_board(efx);\r\nunsigned alarm_mask =\r\n(board->major == 0 && board->minor == 0) ?\r\n~LM87_ALARM_TEMP_EXT1 : ~0;\r\nreturn efx_check_lm87(efx, alarm_mask);\r\n}\r\nstatic int sfe4002_init(struct efx_nic *efx)\r\n{\r\nreturn efx_init_lm87(efx, &sfe4002_hwmon_info, sfe4002_lm87_regs);\r\n}\r\nstatic void sfn4112f_init_phy(struct efx_nic *efx)\r\n{\r\nfalcon_qt202x_set_led(efx, SFN4112F_ACT_LED,\r\nQUAKE_LED_RXLINK | QUAKE_LED_LINK_ACT);\r\nfalcon_qt202x_set_led(efx, SFN4112F_LINK_LED,\r\nQUAKE_LED_RXLINK | QUAKE_LED_LINK_STAT);\r\n}\r\nstatic void sfn4112f_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)\r\n{\r\nint reg;\r\nswitch (mode) {\r\ncase EFX_LED_OFF:\r\nreg = QUAKE_LED_OFF;\r\nbreak;\r\ncase EFX_LED_ON:\r\nreg = QUAKE_LED_ON;\r\nbreak;\r\ndefault:\r\nreg = QUAKE_LED_RXLINK | QUAKE_LED_LINK_STAT;\r\nbreak;\r\n}\r\nfalcon_qt202x_set_led(efx, SFN4112F_LINK_LED, reg);\r\n}\r\nstatic int sfn4112f_check_hw(struct efx_nic *efx)\r\n{\r\nreturn efx_check_lm87(efx, ~0x48);\r\n}\r\nstatic int sfn4112f_init(struct efx_nic *efx)\r\n{\r\nreturn efx_init_lm87(efx, &sfn4112f_hwmon_info, sfn4112f_lm87_regs);\r\n}\r\nstatic void sfe4003_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)\r\n{\r\nstruct falcon_board *board = falcon_board(efx);\r\nif (board->minor < 3 && board->major == 0)\r\nreturn;\r\nfalcon_txc_set_gpio_val(\r\nefx, SFE4003_RED_LED_GPIO,\r\n(mode == EFX_LED_ON) ? SFE4003_LED_ON : SFE4003_LED_OFF);\r\n}\r\nstatic void sfe4003_init_phy(struct efx_nic *efx)\r\n{\r\nstruct falcon_board *board = falcon_board(efx);\r\nif (board->minor < 3 && board->major == 0)\r\nreturn;\r\nfalcon_txc_set_gpio_dir(efx, SFE4003_RED_LED_GPIO, TXC_GPIO_DIR_OUTPUT);\r\nfalcon_txc_set_gpio_val(efx, SFE4003_RED_LED_GPIO, SFE4003_LED_OFF);\r\n}\r\nstatic int sfe4003_check_hw(struct efx_nic *efx)\r\n{\r\nstruct falcon_board *board = falcon_board(efx);\r\nunsigned alarm_mask =\r\n(board->major == 0 && board->minor <= 2) ?\r\n~LM87_ALARM_TEMP_EXT1 : ~0;\r\nreturn efx_check_lm87(efx, alarm_mask);\r\n}\r\nstatic int sfe4003_init(struct efx_nic *efx)\r\n{\r\nreturn efx_init_lm87(efx, &sfe4003_hwmon_info, sfe4003_lm87_regs);\r\n}\r\nint falcon_probe_board(struct efx_nic *efx, u16 revision_info)\r\n{\r\nstruct falcon_board *board = falcon_board(efx);\r\nu8 type_id = FALCON_BOARD_TYPE(revision_info);\r\nint i;\r\nboard->major = FALCON_BOARD_MAJOR(revision_info);\r\nboard->minor = FALCON_BOARD_MINOR(revision_info);\r\nfor (i = 0; i < ARRAY_SIZE(board_types); i++)\r\nif (board_types[i].id == type_id)\r\nboard->type = &board_types[i];\r\nif (board->type) {\r\nnetif_info(efx, probe, efx->net_dev, "board is %s rev %c%d\n",\r\n(efx->pci_dev->subsystem_vendor ==\r\nPCI_VENDOR_ID_SOLARFLARE)\r\n? board->type->ref_model : board->type->gen_type,\r\n'A' + board->major, board->minor);\r\nreturn 0;\r\n} else {\r\nnetif_err(efx, probe, efx->net_dev, "unknown board type %d\n",\r\ntype_id);\r\nreturn -ENODEV;\r\n}\r\n}
