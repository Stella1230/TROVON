static int __init cycx_init(void)\r\n{\r\nint cnt, err = -ENOMEM;\r\npr_info("%s v%u.%u %s\n",\r\ncycx_fullname, CYCX_DRV_VERSION, CYCX_DRV_RELEASE,\r\ncycx_copyright);\r\ncycx_ncards = min_t(int, cycx_ncards, CYCX_MAX_CARDS);\r\ncycx_ncards = max_t(int, cycx_ncards, 1);\r\ncycx_card_array = kcalloc(cycx_ncards, sizeof(struct cycx_device), GFP_KERNEL);\r\nif (!cycx_card_array)\r\ngoto out;\r\nfor (cnt = 0; cnt < cycx_ncards; ++cnt) {\r\nstruct cycx_device *card = &cycx_card_array[cnt];\r\nstruct wan_device *wandev = &card->wandev;\r\nsprintf(card->devname, "%s%d", cycx_drvname, cnt + 1);\r\nwandev->magic = ROUTER_MAGIC;\r\nwandev->name = card->devname;\r\nwandev->private = card;\r\nwandev->setup = cycx_wan_setup;\r\nwandev->shutdown = cycx_wan_shutdown;\r\nerr = register_wan_device(wandev);\r\nif (err) {\r\npr_err("%s registration failed with error %d!\n",\r\ncard->devname, err);\r\nbreak;\r\n}\r\n}\r\nerr = -ENODEV;\r\nif (!cnt) {\r\nkfree(cycx_card_array);\r\ngoto out;\r\n}\r\nerr = 0;\r\ncycx_ncards = cnt;\r\nout: return err;\r\n}\r\nstatic void __exit cycx_exit(void)\r\n{\r\nint i = 0;\r\nfor (; i < cycx_ncards; ++i) {\r\nstruct cycx_device *card = &cycx_card_array[i];\r\nunregister_wan_device(card->devname);\r\n}\r\nkfree(cycx_card_array);\r\n}\r\nstatic int cycx_wan_setup(struct wan_device *wandev, wandev_conf_t *conf)\r\n{\r\nint rc = -EFAULT;\r\nstruct cycx_device *card;\r\nint irq;\r\nif (!wandev || !wandev->private || !conf)\r\ngoto out;\r\ncard = wandev->private;\r\nrc = -EBUSY;\r\nif (wandev->state != WAN_UNCONFIGURED)\r\ngoto out;\r\nrc = -EINVAL;\r\nif (!conf->data_size || !conf->data) {\r\npr_err("%s: firmware not found in configuration data!\n",\r\nwandev->name);\r\ngoto out;\r\n}\r\nif (conf->irq <= 0) {\r\npr_err("%s: can't configure without IRQ!\n", wandev->name);\r\ngoto out;\r\n}\r\nirq = conf->irq == 2 ? 9 : conf->irq;\r\nif (request_irq(irq, cycx_isr, 0, wandev->name, card)) {\r\npr_err("%s: can't reserve IRQ %d!\n", wandev->name, irq);\r\ngoto out;\r\n}\r\nmemset(&card->hw, 0, sizeof(card->hw));\r\ncard->hw.irq = irq;\r\ncard->hw.dpmsize = CYCX_WINDOWSIZE;\r\ncard->hw.fwid = CFID_X25_2X;\r\nspin_lock_init(&card->lock);\r\ninit_waitqueue_head(&card->wait_stats);\r\nrc = cycx_setup(&card->hw, conf->data, conf->data_size, conf->maddr);\r\nif (rc)\r\ngoto out_irq;\r\nwandev->irq = irq;\r\nwandev->dma = wandev->ioport = 0;\r\nwandev->maddr = (unsigned long)card->hw.dpmbase;\r\nwandev->msize = card->hw.dpmsize;\r\nwandev->hw_opt[2] = 0;\r\nwandev->hw_opt[3] = card->hw.fwid;\r\nswitch (card->hw.fwid) {\r\n#ifdef CONFIG_CYCLOMX_X25\r\ncase CFID_X25_2X:\r\nrc = cycx_x25_wan_init(card, conf);\r\nbreak;\r\n#endif\r\ndefault:\r\npr_err("%s: this firmware is not supported!\n", wandev->name);\r\nrc = -EINVAL;\r\n}\r\nif (rc) {\r\ncycx_down(&card->hw);\r\ngoto out_irq;\r\n}\r\nrc = 0;\r\nout:\r\nreturn rc;\r\nout_irq:\r\nfree_irq(irq, card);\r\ngoto out;\r\n}\r\nstatic int cycx_wan_shutdown(struct wan_device *wandev)\r\n{\r\nint ret = -EFAULT;\r\nstruct cycx_device *card;\r\nif (!wandev || !wandev->private)\r\ngoto out;\r\nret = 0;\r\nif (wandev->state == WAN_UNCONFIGURED)\r\ngoto out;\r\ncard = wandev->private;\r\nwandev->state = WAN_UNCONFIGURED;\r\ncycx_down(&card->hw);\r\npr_info("%s: irq %d being freed!\n", wandev->name, wandev->irq);\r\nfree_irq(wandev->irq, card);\r\nout: return ret;\r\n}\r\nstatic irqreturn_t cycx_isr(int irq, void *dev_id)\r\n{\r\nstruct cycx_device *card = dev_id;\r\nif (card->wandev.state == WAN_UNCONFIGURED)\r\ngoto out;\r\nif (card->in_isr) {\r\npr_warn("%s: interrupt re-entrancy on IRQ %d!\n",\r\ncard->devname, card->wandev.irq);\r\ngoto out;\r\n}\r\nif (card->isr)\r\ncard->isr(card);\r\nreturn IRQ_HANDLED;\r\nout:\r\nreturn IRQ_NONE;\r\n}\r\nvoid cycx_set_state(struct cycx_device *card, int state)\r\n{\r\nunsigned long flags;\r\nchar *string_state = NULL;\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (card->wandev.state != state) {\r\nswitch (state) {\r\ncase WAN_CONNECTED:\r\nstring_state = "connected!";\r\nbreak;\r\ncase WAN_DISCONNECTED:\r\nstring_state = "disconnected!";\r\nbreak;\r\n}\r\npr_info("%s: link %s\n", card->devname, string_state);\r\ncard->wandev.state = state;\r\n}\r\ncard->state_tick = jiffies;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}
