static int s3c_hwmon_read_ch(struct device *dev,\r\nstruct s3c_hwmon *hwmon, int channel)\r\n{\r\nint ret;\r\nret = mutex_lock_interruptible(&hwmon->lock);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(dev, "reading channel %d\n", channel);\r\nret = s3c_adc_read(hwmon->client, channel);\r\nmutex_unlock(&hwmon->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t s3c_hwmon_show_raw(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct s3c_hwmon *adc = platform_get_drvdata(to_platform_device(dev));\r\nstruct sensor_device_attribute *sa = to_sensor_dev_attr(attr);\r\nint ret;\r\nret = s3c_hwmon_read_ch(dev, adc, sa->index);\r\nreturn (ret < 0) ? ret : snprintf(buf, PAGE_SIZE, "%d\n", ret);\r\n}\r\nstatic inline int s3c_hwmon_add_raw(struct device *dev)\r\n{\r\nreturn sysfs_create_group(&dev->kobj, &s3c_hwmon_attrgroup);\r\n}\r\nstatic inline void s3c_hwmon_remove_raw(struct device *dev)\r\n{\r\nsysfs_remove_group(&dev->kobj, &s3c_hwmon_attrgroup);\r\n}\r\nstatic inline int s3c_hwmon_add_raw(struct device *dev) { return 0; }\r\nstatic inline void s3c_hwmon_remove_raw(struct device *dev) { }\r\nstatic ssize_t s3c_hwmon_ch_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sen_attr = to_sensor_dev_attr(attr);\r\nstruct s3c_hwmon *hwmon = platform_get_drvdata(to_platform_device(dev));\r\nstruct s3c_hwmon_pdata *pdata = dev->platform_data;\r\nstruct s3c_hwmon_chcfg *cfg;\r\nint ret;\r\ncfg = pdata->in[sen_attr->index];\r\nret = s3c_hwmon_read_ch(dev, hwmon, sen_attr->index);\r\nif (ret < 0)\r\nreturn ret;\r\nret *= cfg->mult;\r\nret = DIV_ROUND_CLOSEST(ret, cfg->div);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ret);\r\n}\r\nstatic ssize_t s3c_hwmon_label_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sen_attr = to_sensor_dev_attr(attr);\r\nstruct s3c_hwmon_pdata *pdata = dev->platform_data;\r\nstruct s3c_hwmon_chcfg *cfg;\r\ncfg = pdata->in[sen_attr->index];\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", cfg->name);\r\n}\r\nstatic int s3c_hwmon_create_attr(struct device *dev,\r\nstruct s3c_hwmon_chcfg *cfg,\r\nstruct s3c_hwmon_attr *attrs,\r\nint channel)\r\n{\r\nstruct sensor_device_attribute *attr;\r\nint ret;\r\nsnprintf(attrs->in_name, sizeof(attrs->in_name), "in%d_input", channel);\r\nattr = &attrs->in;\r\nattr->index = channel;\r\nsysfs_attr_init(&attr->dev_attr.attr);\r\nattr->dev_attr.attr.name = attrs->in_name;\r\nattr->dev_attr.attr.mode = S_IRUGO;\r\nattr->dev_attr.show = s3c_hwmon_ch_show;\r\nret = device_create_file(dev, &attr->dev_attr);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to create input attribute\n");\r\nreturn ret;\r\n}\r\nif (cfg->name) {\r\nsnprintf(attrs->label_name, sizeof(attrs->label_name),\r\n"in%d_label", channel);\r\nattr = &attrs->label;\r\nattr->index = channel;\r\nsysfs_attr_init(&attr->dev_attr.attr);\r\nattr->dev_attr.attr.name = attrs->label_name;\r\nattr->dev_attr.attr.mode = S_IRUGO;\r\nattr->dev_attr.show = s3c_hwmon_label_show;\r\nret = device_create_file(dev, &attr->dev_attr);\r\nif (ret < 0) {\r\ndevice_remove_file(dev, &attrs->in.dev_attr);\r\ndev_err(dev, "failed to create label attribute\n");\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void s3c_hwmon_remove_attr(struct device *dev,\r\nstruct s3c_hwmon_attr *attrs)\r\n{\r\ndevice_remove_file(dev, &attrs->in.dev_attr);\r\ndevice_remove_file(dev, &attrs->label.dev_attr);\r\n}\r\nstatic int __devinit s3c_hwmon_probe(struct platform_device *dev)\r\n{\r\nstruct s3c_hwmon_pdata *pdata = dev->dev.platform_data;\r\nstruct s3c_hwmon *hwmon;\r\nint ret = 0;\r\nint i;\r\nif (!pdata) {\r\ndev_err(&dev->dev, "no platform data supplied\n");\r\nreturn -EINVAL;\r\n}\r\nhwmon = kzalloc(sizeof(struct s3c_hwmon), GFP_KERNEL);\r\nif (hwmon == NULL) {\r\ndev_err(&dev->dev, "no memory\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(dev, hwmon);\r\nmutex_init(&hwmon->lock);\r\nhwmon->client = s3c_adc_register(dev, NULL, NULL, 0);\r\nif (IS_ERR(hwmon->client)) {\r\ndev_err(&dev->dev, "cannot register adc\n");\r\nret = PTR_ERR(hwmon->client);\r\ngoto err_mem;\r\n}\r\nret = s3c_hwmon_add_raw(&dev->dev);\r\nif (ret)\r\ngoto err_registered;\r\nhwmon->hwmon_dev = hwmon_device_register(&dev->dev);\r\nif (IS_ERR(hwmon->hwmon_dev)) {\r\ndev_err(&dev->dev, "error registering with hwmon\n");\r\nret = PTR_ERR(hwmon->hwmon_dev);\r\ngoto err_raw_attribute;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(pdata->in); i++) {\r\nstruct s3c_hwmon_chcfg *cfg = pdata->in[i];\r\nif (!cfg)\r\ncontinue;\r\nif (cfg->mult >= 0x10000)\r\ndev_warn(&dev->dev,\r\n"channel %d multiplier too large\n",\r\ni);\r\nif (cfg->div == 0) {\r\ndev_err(&dev->dev, "channel %d divider zero\n", i);\r\ncontinue;\r\n}\r\nret = s3c_hwmon_create_attr(&dev->dev, pdata->in[i],\r\n&hwmon->attrs[i], i);\r\nif (ret) {\r\ndev_err(&dev->dev,\r\n"error creating channel %d\n", i);\r\nfor (i--; i >= 0; i--)\r\ns3c_hwmon_remove_attr(&dev->dev,\r\n&hwmon->attrs[i]);\r\ngoto err_hwmon_register;\r\n}\r\n}\r\nreturn 0;\r\nerr_hwmon_register:\r\nhwmon_device_unregister(hwmon->hwmon_dev);\r\nerr_raw_attribute:\r\ns3c_hwmon_remove_raw(&dev->dev);\r\nerr_registered:\r\ns3c_adc_release(hwmon->client);\r\nerr_mem:\r\nkfree(hwmon);\r\nreturn ret;\r\n}\r\nstatic int __devexit s3c_hwmon_remove(struct platform_device *dev)\r\n{\r\nstruct s3c_hwmon *hwmon = platform_get_drvdata(dev);\r\nint i;\r\ns3c_hwmon_remove_raw(&dev->dev);\r\nfor (i = 0; i < ARRAY_SIZE(hwmon->attrs); i++)\r\ns3c_hwmon_remove_attr(&dev->dev, &hwmon->attrs[i]);\r\nhwmon_device_unregister(hwmon->hwmon_dev);\r\ns3c_adc_release(hwmon->client);\r\nreturn 0;\r\n}
