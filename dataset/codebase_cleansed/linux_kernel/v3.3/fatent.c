static void fat12_ent_blocknr(struct super_block *sb, int entry,\r\nint *offset, sector_t *blocknr)\r\n{\r\nstruct msdos_sb_info *sbi = MSDOS_SB(sb);\r\nint bytes = entry + (entry >> 1);\r\nWARN_ON(entry < FAT_START_ENT || sbi->max_cluster <= entry);\r\n*offset = bytes & (sb->s_blocksize - 1);\r\n*blocknr = sbi->fat_start + (bytes >> sb->s_blocksize_bits);\r\n}\r\nstatic void fat_ent_blocknr(struct super_block *sb, int entry,\r\nint *offset, sector_t *blocknr)\r\n{\r\nstruct msdos_sb_info *sbi = MSDOS_SB(sb);\r\nint bytes = (entry << sbi->fatent_shift);\r\nWARN_ON(entry < FAT_START_ENT || sbi->max_cluster <= entry);\r\n*offset = bytes & (sb->s_blocksize - 1);\r\n*blocknr = sbi->fat_start + (bytes >> sb->s_blocksize_bits);\r\n}\r\nstatic void fat12_ent_set_ptr(struct fat_entry *fatent, int offset)\r\n{\r\nstruct buffer_head **bhs = fatent->bhs;\r\nif (fatent->nr_bhs == 1) {\r\nWARN_ON(offset >= (bhs[0]->b_size - 1));\r\nfatent->u.ent12_p[0] = bhs[0]->b_data + offset;\r\nfatent->u.ent12_p[1] = bhs[0]->b_data + (offset + 1);\r\n} else {\r\nWARN_ON(offset != (bhs[0]->b_size - 1));\r\nfatent->u.ent12_p[0] = bhs[0]->b_data + offset;\r\nfatent->u.ent12_p[1] = bhs[1]->b_data;\r\n}\r\n}\r\nstatic void fat16_ent_set_ptr(struct fat_entry *fatent, int offset)\r\n{\r\nWARN_ON(offset & (2 - 1));\r\nfatent->u.ent16_p = (__le16 *)(fatent->bhs[0]->b_data + offset);\r\n}\r\nstatic void fat32_ent_set_ptr(struct fat_entry *fatent, int offset)\r\n{\r\nWARN_ON(offset & (4 - 1));\r\nfatent->u.ent32_p = (__le32 *)(fatent->bhs[0]->b_data + offset);\r\n}\r\nstatic int fat12_ent_bread(struct super_block *sb, struct fat_entry *fatent,\r\nint offset, sector_t blocknr)\r\n{\r\nstruct buffer_head **bhs = fatent->bhs;\r\nWARN_ON(blocknr < MSDOS_SB(sb)->fat_start);\r\nfatent->fat_inode = MSDOS_SB(sb)->fat_inode;\r\nbhs[0] = sb_bread(sb, blocknr);\r\nif (!bhs[0])\r\ngoto err;\r\nif ((offset + 1) < sb->s_blocksize)\r\nfatent->nr_bhs = 1;\r\nelse {\r\nblocknr++;\r\nbhs[1] = sb_bread(sb, blocknr);\r\nif (!bhs[1])\r\ngoto err_brelse;\r\nfatent->nr_bhs = 2;\r\n}\r\nfat12_ent_set_ptr(fatent, offset);\r\nreturn 0;\r\nerr_brelse:\r\nbrelse(bhs[0]);\r\nerr:\r\nfat_msg(sb, KERN_ERR, "FAT read failed (blocknr %llu)", (llu)blocknr);\r\nreturn -EIO;\r\n}\r\nstatic int fat_ent_bread(struct super_block *sb, struct fat_entry *fatent,\r\nint offset, sector_t blocknr)\r\n{\r\nstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\r\nWARN_ON(blocknr < MSDOS_SB(sb)->fat_start);\r\nfatent->fat_inode = MSDOS_SB(sb)->fat_inode;\r\nfatent->bhs[0] = sb_bread(sb, blocknr);\r\nif (!fatent->bhs[0]) {\r\nfat_msg(sb, KERN_ERR, "FAT read failed (blocknr %llu)",\r\n(llu)blocknr);\r\nreturn -EIO;\r\n}\r\nfatent->nr_bhs = 1;\r\nops->ent_set_ptr(fatent, offset);\r\nreturn 0;\r\n}\r\nstatic int fat12_ent_get(struct fat_entry *fatent)\r\n{\r\nu8 **ent12_p = fatent->u.ent12_p;\r\nint next;\r\nspin_lock(&fat12_entry_lock);\r\nif (fatent->entry & 1)\r\nnext = (*ent12_p[0] >> 4) | (*ent12_p[1] << 4);\r\nelse\r\nnext = (*ent12_p[1] << 8) | *ent12_p[0];\r\nspin_unlock(&fat12_entry_lock);\r\nnext &= 0x0fff;\r\nif (next >= BAD_FAT12)\r\nnext = FAT_ENT_EOF;\r\nreturn next;\r\n}\r\nstatic int fat16_ent_get(struct fat_entry *fatent)\r\n{\r\nint next = le16_to_cpu(*fatent->u.ent16_p);\r\nWARN_ON((unsigned long)fatent->u.ent16_p & (2 - 1));\r\nif (next >= BAD_FAT16)\r\nnext = FAT_ENT_EOF;\r\nreturn next;\r\n}\r\nstatic int fat32_ent_get(struct fat_entry *fatent)\r\n{\r\nint next = le32_to_cpu(*fatent->u.ent32_p) & 0x0fffffff;\r\nWARN_ON((unsigned long)fatent->u.ent32_p & (4 - 1));\r\nif (next >= BAD_FAT32)\r\nnext = FAT_ENT_EOF;\r\nreturn next;\r\n}\r\nstatic void fat12_ent_put(struct fat_entry *fatent, int new)\r\n{\r\nu8 **ent12_p = fatent->u.ent12_p;\r\nif (new == FAT_ENT_EOF)\r\nnew = EOF_FAT12;\r\nspin_lock(&fat12_entry_lock);\r\nif (fatent->entry & 1) {\r\n*ent12_p[0] = (new << 4) | (*ent12_p[0] & 0x0f);\r\n*ent12_p[1] = new >> 4;\r\n} else {\r\n*ent12_p[0] = new & 0xff;\r\n*ent12_p[1] = (*ent12_p[1] & 0xf0) | (new >> 8);\r\n}\r\nspin_unlock(&fat12_entry_lock);\r\nmark_buffer_dirty_inode(fatent->bhs[0], fatent->fat_inode);\r\nif (fatent->nr_bhs == 2)\r\nmark_buffer_dirty_inode(fatent->bhs[1], fatent->fat_inode);\r\n}\r\nstatic void fat16_ent_put(struct fat_entry *fatent, int new)\r\n{\r\nif (new == FAT_ENT_EOF)\r\nnew = EOF_FAT16;\r\n*fatent->u.ent16_p = cpu_to_le16(new);\r\nmark_buffer_dirty_inode(fatent->bhs[0], fatent->fat_inode);\r\n}\r\nstatic void fat32_ent_put(struct fat_entry *fatent, int new)\r\n{\r\nif (new == FAT_ENT_EOF)\r\nnew = EOF_FAT32;\r\nWARN_ON(new & 0xf0000000);\r\nnew |= le32_to_cpu(*fatent->u.ent32_p) & ~0x0fffffff;\r\n*fatent->u.ent32_p = cpu_to_le32(new);\r\nmark_buffer_dirty_inode(fatent->bhs[0], fatent->fat_inode);\r\n}\r\nstatic int fat12_ent_next(struct fat_entry *fatent)\r\n{\r\nu8 **ent12_p = fatent->u.ent12_p;\r\nstruct buffer_head **bhs = fatent->bhs;\r\nu8 *nextp = ent12_p[1] + 1 + (fatent->entry & 1);\r\nfatent->entry++;\r\nif (fatent->nr_bhs == 1) {\r\nWARN_ON(ent12_p[0] > (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 2)));\r\nWARN_ON(ent12_p[1] > (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 1)));\r\nif (nextp < (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 1))) {\r\nent12_p[0] = nextp - 1;\r\nent12_p[1] = nextp;\r\nreturn 1;\r\n}\r\n} else {\r\nWARN_ON(ent12_p[0] != (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 1)));\r\nWARN_ON(ent12_p[1] != (u8 *)bhs[1]->b_data);\r\nent12_p[0] = nextp - 1;\r\nent12_p[1] = nextp;\r\nbrelse(bhs[0]);\r\nbhs[0] = bhs[1];\r\nfatent->nr_bhs = 1;\r\nreturn 1;\r\n}\r\nent12_p[0] = NULL;\r\nent12_p[1] = NULL;\r\nreturn 0;\r\n}\r\nstatic int fat16_ent_next(struct fat_entry *fatent)\r\n{\r\nconst struct buffer_head *bh = fatent->bhs[0];\r\nfatent->entry++;\r\nif (fatent->u.ent16_p < (__le16 *)(bh->b_data + (bh->b_size - 2))) {\r\nfatent->u.ent16_p++;\r\nreturn 1;\r\n}\r\nfatent->u.ent16_p = NULL;\r\nreturn 0;\r\n}\r\nstatic int fat32_ent_next(struct fat_entry *fatent)\r\n{\r\nconst struct buffer_head *bh = fatent->bhs[0];\r\nfatent->entry++;\r\nif (fatent->u.ent32_p < (__le32 *)(bh->b_data + (bh->b_size - 4))) {\r\nfatent->u.ent32_p++;\r\nreturn 1;\r\n}\r\nfatent->u.ent32_p = NULL;\r\nreturn 0;\r\n}\r\nstatic inline void lock_fat(struct msdos_sb_info *sbi)\r\n{\r\nmutex_lock(&sbi->fat_lock);\r\n}\r\nstatic inline void unlock_fat(struct msdos_sb_info *sbi)\r\n{\r\nmutex_unlock(&sbi->fat_lock);\r\n}\r\nvoid fat_ent_access_init(struct super_block *sb)\r\n{\r\nstruct msdos_sb_info *sbi = MSDOS_SB(sb);\r\nmutex_init(&sbi->fat_lock);\r\nswitch (sbi->fat_bits) {\r\ncase 32:\r\nsbi->fatent_shift = 2;\r\nsbi->fatent_ops = &fat32_ops;\r\nbreak;\r\ncase 16:\r\nsbi->fatent_shift = 1;\r\nsbi->fatent_ops = &fat16_ops;\r\nbreak;\r\ncase 12:\r\nsbi->fatent_shift = -1;\r\nsbi->fatent_ops = &fat12_ops;\r\nbreak;\r\n}\r\n}\r\nstatic inline int fat_ent_update_ptr(struct super_block *sb,\r\nstruct fat_entry *fatent,\r\nint offset, sector_t blocknr)\r\n{\r\nstruct msdos_sb_info *sbi = MSDOS_SB(sb);\r\nstruct fatent_operations *ops = sbi->fatent_ops;\r\nstruct buffer_head **bhs = fatent->bhs;\r\nif (!fatent->nr_bhs || bhs[0]->b_blocknr != blocknr)\r\nreturn 0;\r\nif (sbi->fat_bits == 12) {\r\nif ((offset + 1) < sb->s_blocksize) {\r\nif (fatent->nr_bhs == 2) {\r\nbrelse(bhs[1]);\r\nfatent->nr_bhs = 1;\r\n}\r\n} else {\r\nif (fatent->nr_bhs != 2)\r\nreturn 0;\r\nif (bhs[1]->b_blocknr != (blocknr + 1))\r\nreturn 0;\r\n}\r\n}\r\nops->ent_set_ptr(fatent, offset);\r\nreturn 1;\r\n}\r\nint fat_ent_read(struct inode *inode, struct fat_entry *fatent, int entry)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\r\nstruct fatent_operations *ops = sbi->fatent_ops;\r\nint err, offset;\r\nsector_t blocknr;\r\nif (entry < FAT_START_ENT || sbi->max_cluster <= entry) {\r\nfatent_brelse(fatent);\r\nfat_fs_error(sb, "invalid access to FAT (entry 0x%08x)", entry);\r\nreturn -EIO;\r\n}\r\nfatent_set_entry(fatent, entry);\r\nops->ent_blocknr(sb, entry, &offset, &blocknr);\r\nif (!fat_ent_update_ptr(sb, fatent, offset, blocknr)) {\r\nfatent_brelse(fatent);\r\nerr = ops->ent_bread(sb, fatent, offset, blocknr);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn ops->ent_get(fatent);\r\n}\r\nstatic int fat_mirror_bhs(struct super_block *sb, struct buffer_head **bhs,\r\nint nr_bhs)\r\n{\r\nstruct msdos_sb_info *sbi = MSDOS_SB(sb);\r\nstruct buffer_head *c_bh;\r\nint err, n, copy;\r\nerr = 0;\r\nfor (copy = 1; copy < sbi->fats; copy++) {\r\nsector_t backup_fat = sbi->fat_length * copy;\r\nfor (n = 0; n < nr_bhs; n++) {\r\nc_bh = sb_getblk(sb, backup_fat + bhs[n]->b_blocknr);\r\nif (!c_bh) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nmemcpy(c_bh->b_data, bhs[n]->b_data, sb->s_blocksize);\r\nset_buffer_uptodate(c_bh);\r\nmark_buffer_dirty_inode(c_bh, sbi->fat_inode);\r\nif (sb->s_flags & MS_SYNCHRONOUS)\r\nerr = sync_dirty_buffer(c_bh);\r\nbrelse(c_bh);\r\nif (err)\r\ngoto error;\r\n}\r\n}\r\nerror:\r\nreturn err;\r\n}\r\nint fat_ent_write(struct inode *inode, struct fat_entry *fatent,\r\nint new, int wait)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\r\nint err;\r\nops->ent_put(fatent, new);\r\nif (wait) {\r\nerr = fat_sync_bhs(fatent->bhs, fatent->nr_bhs);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn fat_mirror_bhs(sb, fatent->bhs, fatent->nr_bhs);\r\n}\r\nstatic inline int fat_ent_next(struct msdos_sb_info *sbi,\r\nstruct fat_entry *fatent)\r\n{\r\nif (sbi->fatent_ops->ent_next(fatent)) {\r\nif (fatent->entry < sbi->max_cluster)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int fat_ent_read_block(struct super_block *sb,\r\nstruct fat_entry *fatent)\r\n{\r\nstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\r\nsector_t blocknr;\r\nint offset;\r\nfatent_brelse(fatent);\r\nops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\r\nreturn ops->ent_bread(sb, fatent, offset, blocknr);\r\n}\r\nstatic void fat_collect_bhs(struct buffer_head **bhs, int *nr_bhs,\r\nstruct fat_entry *fatent)\r\n{\r\nint n, i;\r\nfor (n = 0; n < fatent->nr_bhs; n++) {\r\nfor (i = 0; i < *nr_bhs; i++) {\r\nif (fatent->bhs[n] == bhs[i])\r\nbreak;\r\n}\r\nif (i == *nr_bhs) {\r\nget_bh(fatent->bhs[n]);\r\nbhs[i] = fatent->bhs[n];\r\n(*nr_bhs)++;\r\n}\r\n}\r\n}\r\nint fat_alloc_clusters(struct inode *inode, int *cluster, int nr_cluster)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct msdos_sb_info *sbi = MSDOS_SB(sb);\r\nstruct fatent_operations *ops = sbi->fatent_ops;\r\nstruct fat_entry fatent, prev_ent;\r\nstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\r\nint i, count, err, nr_bhs, idx_clus;\r\nBUG_ON(nr_cluster > (MAX_BUF_PER_PAGE / 2));\r\nlock_fat(sbi);\r\nif (sbi->free_clusters != -1 && sbi->free_clus_valid &&\r\nsbi->free_clusters < nr_cluster) {\r\nunlock_fat(sbi);\r\nreturn -ENOSPC;\r\n}\r\nerr = nr_bhs = idx_clus = 0;\r\ncount = FAT_START_ENT;\r\nfatent_init(&prev_ent);\r\nfatent_init(&fatent);\r\nfatent_set_entry(&fatent, sbi->prev_free + 1);\r\nwhile (count < sbi->max_cluster) {\r\nif (fatent.entry >= sbi->max_cluster)\r\nfatent.entry = FAT_START_ENT;\r\nfatent_set_entry(&fatent, fatent.entry);\r\nerr = fat_ent_read_block(sb, &fatent);\r\nif (err)\r\ngoto out;\r\ndo {\r\nif (ops->ent_get(&fatent) == FAT_ENT_FREE) {\r\nint entry = fatent.entry;\r\nops->ent_put(&fatent, FAT_ENT_EOF);\r\nif (prev_ent.nr_bhs)\r\nops->ent_put(&prev_ent, entry);\r\nfat_collect_bhs(bhs, &nr_bhs, &fatent);\r\nsbi->prev_free = entry;\r\nif (sbi->free_clusters != -1)\r\nsbi->free_clusters--;\r\nsb->s_dirt = 1;\r\ncluster[idx_clus] = entry;\r\nidx_clus++;\r\nif (idx_clus == nr_cluster)\r\ngoto out;\r\nprev_ent = fatent;\r\n}\r\ncount++;\r\nif (count == sbi->max_cluster)\r\nbreak;\r\n} while (fat_ent_next(sbi, &fatent));\r\n}\r\nsbi->free_clusters = 0;\r\nsbi->free_clus_valid = 1;\r\nsb->s_dirt = 1;\r\nerr = -ENOSPC;\r\nout:\r\nunlock_fat(sbi);\r\nfatent_brelse(&fatent);\r\nif (!err) {\r\nif (inode_needs_sync(inode))\r\nerr = fat_sync_bhs(bhs, nr_bhs);\r\nif (!err)\r\nerr = fat_mirror_bhs(sb, bhs, nr_bhs);\r\n}\r\nfor (i = 0; i < nr_bhs; i++)\r\nbrelse(bhs[i]);\r\nif (err && idx_clus)\r\nfat_free_clusters(inode, cluster[0]);\r\nreturn err;\r\n}\r\nint fat_free_clusters(struct inode *inode, int cluster)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct msdos_sb_info *sbi = MSDOS_SB(sb);\r\nstruct fatent_operations *ops = sbi->fatent_ops;\r\nstruct fat_entry fatent;\r\nstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\r\nint i, err, nr_bhs;\r\nint first_cl = cluster;\r\nnr_bhs = 0;\r\nfatent_init(&fatent);\r\nlock_fat(sbi);\r\ndo {\r\ncluster = fat_ent_read(inode, &fatent, cluster);\r\nif (cluster < 0) {\r\nerr = cluster;\r\ngoto error;\r\n} else if (cluster == FAT_ENT_FREE) {\r\nfat_fs_error(sb, "%s: deleting FAT entry beyond EOF",\r\n__func__);\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nif (sbi->options.discard) {\r\nif (cluster != fatent.entry + 1) {\r\nint nr_clus = fatent.entry - first_cl + 1;\r\nsb_issue_discard(sb,\r\nfat_clus_to_blknr(sbi, first_cl),\r\nnr_clus * sbi->sec_per_clus,\r\nGFP_NOFS, 0);\r\nfirst_cl = cluster;\r\n}\r\n}\r\nops->ent_put(&fatent, FAT_ENT_FREE);\r\nif (sbi->free_clusters != -1) {\r\nsbi->free_clusters++;\r\nsb->s_dirt = 1;\r\n}\r\nif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\r\nif (sb->s_flags & MS_SYNCHRONOUS) {\r\nerr = fat_sync_bhs(bhs, nr_bhs);\r\nif (err)\r\ngoto error;\r\n}\r\nerr = fat_mirror_bhs(sb, bhs, nr_bhs);\r\nif (err)\r\ngoto error;\r\nfor (i = 0; i < nr_bhs; i++)\r\nbrelse(bhs[i]);\r\nnr_bhs = 0;\r\n}\r\nfat_collect_bhs(bhs, &nr_bhs, &fatent);\r\n} while (cluster != FAT_ENT_EOF);\r\nif (sb->s_flags & MS_SYNCHRONOUS) {\r\nerr = fat_sync_bhs(bhs, nr_bhs);\r\nif (err)\r\ngoto error;\r\n}\r\nerr = fat_mirror_bhs(sb, bhs, nr_bhs);\r\nerror:\r\nfatent_brelse(&fatent);\r\nfor (i = 0; i < nr_bhs; i++)\r\nbrelse(bhs[i]);\r\nunlock_fat(sbi);\r\nreturn err;\r\n}\r\nstatic void fat_ent_reada(struct super_block *sb, struct fat_entry *fatent,\r\nunsigned long reada_blocks)\r\n{\r\nstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\r\nsector_t blocknr;\r\nint i, offset;\r\nops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\r\nfor (i = 0; i < reada_blocks; i++)\r\nsb_breadahead(sb, blocknr + i);\r\n}\r\nint fat_count_free_clusters(struct super_block *sb)\r\n{\r\nstruct msdos_sb_info *sbi = MSDOS_SB(sb);\r\nstruct fatent_operations *ops = sbi->fatent_ops;\r\nstruct fat_entry fatent;\r\nunsigned long reada_blocks, reada_mask, cur_block;\r\nint err = 0, free;\r\nlock_fat(sbi);\r\nif (sbi->free_clusters != -1 && sbi->free_clus_valid)\r\ngoto out;\r\nreada_blocks = FAT_READA_SIZE >> sb->s_blocksize_bits;\r\nreada_mask = reada_blocks - 1;\r\ncur_block = 0;\r\nfree = 0;\r\nfatent_init(&fatent);\r\nfatent_set_entry(&fatent, FAT_START_ENT);\r\nwhile (fatent.entry < sbi->max_cluster) {\r\nif ((cur_block & reada_mask) == 0) {\r\nunsigned long rest = sbi->fat_length - cur_block;\r\nfat_ent_reada(sb, &fatent, min(reada_blocks, rest));\r\n}\r\ncur_block++;\r\nerr = fat_ent_read_block(sb, &fatent);\r\nif (err)\r\ngoto out;\r\ndo {\r\nif (ops->ent_get(&fatent) == FAT_ENT_FREE)\r\nfree++;\r\n} while (fat_ent_next(sbi, &fatent));\r\n}\r\nsbi->free_clusters = free;\r\nsbi->free_clus_valid = 1;\r\nsb->s_dirt = 1;\r\nfatent_brelse(&fatent);\r\nout:\r\nunlock_fat(sbi);\r\nreturn err;\r\n}
