static struct sctp_association *sctp_association_init(struct sctp_association *asoc,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sock *sk,\r\nsctp_scope_t scope,\r\ngfp_t gfp)\r\n{\r\nstruct sctp_sock *sp;\r\nint i;\r\nsctp_paramhdr_t *p;\r\nint err;\r\nsp = sctp_sk((struct sock *)sk);\r\nasoc->ep = (struct sctp_endpoint *)ep;\r\nsctp_endpoint_hold(asoc->ep);\r\nasoc->base.sk = (struct sock *)sk;\r\nsock_hold(asoc->base.sk);\r\nasoc->base.type = SCTP_EP_TYPE_ASSOCIATION;\r\natomic_set(&asoc->base.refcnt, 1);\r\nasoc->base.dead = 0;\r\nasoc->base.malloced = 0;\r\nsctp_bind_addr_init(&asoc->base.bind_addr, ep->base.bind_addr.port);\r\nasoc->state = SCTP_STATE_CLOSED;\r\nasoc->cookie_life.tv_sec = sp->assocparams.sasoc_cookie_life / 1000;\r\nasoc->cookie_life.tv_usec = (sp->assocparams.sasoc_cookie_life % 1000)\r\n* 1000;\r\nasoc->frag_point = 0;\r\nasoc->user_frag = sp->user_frag;\r\nasoc->max_retrans = sp->assocparams.sasoc_asocmaxrxt;\r\nasoc->rto_initial = msecs_to_jiffies(sp->rtoinfo.srto_initial);\r\nasoc->rto_max = msecs_to_jiffies(sp->rtoinfo.srto_max);\r\nasoc->rto_min = msecs_to_jiffies(sp->rtoinfo.srto_min);\r\nasoc->overall_error_count = 0;\r\nasoc->hbinterval = msecs_to_jiffies(sp->hbinterval);\r\nasoc->pathmaxrxt = sp->pathmaxrxt;\r\nasoc->pathmtu = sp->pathmtu;\r\nasoc->sackdelay = msecs_to_jiffies(sp->sackdelay);\r\nasoc->sackfreq = sp->sackfreq;\r\nasoc->param_flags = sp->param_flags;\r\nasoc->max_burst = sp->max_burst;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_NONE] = 0;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_COOKIE] = asoc->rto_initial;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_INIT] = asoc->rto_initial;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_T2_SHUTDOWN] = asoc->rto_initial;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_T3_RTX] = 0;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_T4_RTO] = 0;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD]\r\n= 5 * asoc->rto_max;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_HEARTBEAT] = 0;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_SACK] = asoc->sackdelay;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE] =\r\nmin_t(unsigned long, sp->autoclose, sctp_max_autoclose) * HZ;\r\nfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i)\r\nsetup_timer(&asoc->timers[i], sctp_timer_events[i],\r\n(unsigned long)asoc);\r\nasoc->c.sinit_max_instreams = sp->initmsg.sinit_max_instreams;\r\nasoc->c.sinit_num_ostreams = sp->initmsg.sinit_num_ostreams;\r\nasoc->max_init_attempts = sp->initmsg.sinit_max_attempts;\r\nasoc->max_init_timeo =\r\nmsecs_to_jiffies(sp->initmsg.sinit_max_init_timeo);\r\nasoc->ssnmap = NULL;\r\nif ((sk->sk_rcvbuf/2) < SCTP_DEFAULT_MINWINDOW)\r\nasoc->rwnd = SCTP_DEFAULT_MINWINDOW;\r\nelse\r\nasoc->rwnd = sk->sk_rcvbuf/2;\r\nasoc->a_rwnd = asoc->rwnd;\r\nasoc->rwnd_over = 0;\r\nasoc->rwnd_press = 0;\r\nasoc->peer.rwnd = SCTP_DEFAULT_MAXWINDOW;\r\nasoc->sndbuf_used = 0;\r\natomic_set(&asoc->rmem_alloc, 0);\r\ninit_waitqueue_head(&asoc->wait);\r\nasoc->c.my_vtag = sctp_generate_tag(ep);\r\nasoc->peer.i.init_tag = 0;\r\nasoc->c.peer_vtag = 0;\r\nasoc->c.my_ttag = 0;\r\nasoc->c.peer_ttag = 0;\r\nasoc->c.my_port = ep->base.bind_addr.port;\r\nasoc->c.initial_tsn = sctp_generate_tsn(ep);\r\nasoc->next_tsn = asoc->c.initial_tsn;\r\nasoc->ctsn_ack_point = asoc->next_tsn - 1;\r\nasoc->adv_peer_ack_point = asoc->ctsn_ack_point;\r\nasoc->highest_sacked = asoc->ctsn_ack_point;\r\nasoc->last_cwr_tsn = asoc->ctsn_ack_point;\r\nasoc->unack_data = 0;\r\nasoc->addip_serial = asoc->c.initial_tsn;\r\nINIT_LIST_HEAD(&asoc->addip_chunk_list);\r\nINIT_LIST_HEAD(&asoc->asconf_ack_list);\r\nINIT_LIST_HEAD(&asoc->peer.transport_addr_list);\r\nasoc->peer.transport_count = 0;\r\nasoc->peer.sack_needed = 1;\r\nasoc->peer.sack_cnt = 0;\r\nasoc->peer.asconf_capable = 0;\r\nif (sctp_addip_noauth)\r\nasoc->peer.asconf_capable = 1;\r\nasoc->asconf_addr_del_pending = NULL;\r\nasoc->src_out_of_asoc_ok = 0;\r\nasoc->new_transport = NULL;\r\nsctp_inq_init(&asoc->base.inqueue);\r\nsctp_inq_set_th_handler(&asoc->base.inqueue, sctp_assoc_bh_rcv);\r\nsctp_outq_init(asoc, &asoc->outqueue);\r\nif (!sctp_ulpq_init(&asoc->ulpq, asoc))\r\ngoto fail_init;\r\nmemset(&asoc->peer.tsn_map, 0, sizeof(struct sctp_tsnmap));\r\nasoc->need_ecne = 0;\r\nasoc->assoc_id = 0;\r\nasoc->peer.ipv4_address = 1;\r\nif (asoc->base.sk->sk_family == PF_INET6)\r\nasoc->peer.ipv6_address = 1;\r\nINIT_LIST_HEAD(&asoc->asocs);\r\nasoc->autoclose = sp->autoclose;\r\nasoc->default_stream = sp->default_stream;\r\nasoc->default_ppid = sp->default_ppid;\r\nasoc->default_flags = sp->default_flags;\r\nasoc->default_context = sp->default_context;\r\nasoc->default_timetolive = sp->default_timetolive;\r\nasoc->default_rcv_context = sp->default_rcv_context;\r\nINIT_LIST_HEAD(&asoc->endpoint_shared_keys);\r\nerr = sctp_auth_asoc_copy_shkeys(ep, asoc, gfp);\r\nif (err)\r\ngoto fail_init;\r\nasoc->active_key_id = ep->active_key_id;\r\nasoc->asoc_shared_key = NULL;\r\nasoc->default_hmac_id = 0;\r\nif (ep->auth_hmacs_list)\r\nmemcpy(asoc->c.auth_hmacs, ep->auth_hmacs_list,\r\nntohs(ep->auth_hmacs_list->param_hdr.length));\r\nif (ep->auth_chunk_list)\r\nmemcpy(asoc->c.auth_chunks, ep->auth_chunk_list,\r\nntohs(ep->auth_chunk_list->param_hdr.length));\r\np = (sctp_paramhdr_t *)asoc->c.auth_random;\r\np->type = SCTP_PARAM_RANDOM;\r\np->length = htons(sizeof(sctp_paramhdr_t) + SCTP_AUTH_RANDOM_LENGTH);\r\nget_random_bytes(p+1, SCTP_AUTH_RANDOM_LENGTH);\r\nreturn asoc;\r\nfail_init:\r\nsctp_endpoint_put(asoc->ep);\r\nsock_put(asoc->base.sk);\r\nreturn NULL;\r\n}\r\nstruct sctp_association *sctp_association_new(const struct sctp_endpoint *ep,\r\nconst struct sock *sk,\r\nsctp_scope_t scope,\r\ngfp_t gfp)\r\n{\r\nstruct sctp_association *asoc;\r\nasoc = t_new(struct sctp_association, gfp);\r\nif (!asoc)\r\ngoto fail;\r\nif (!sctp_association_init(asoc, ep, sk, scope, gfp))\r\ngoto fail_init;\r\nasoc->base.malloced = 1;\r\nSCTP_DBG_OBJCNT_INC(assoc);\r\nSCTP_DEBUG_PRINTK("Created asoc %p\n", asoc);\r\nreturn asoc;\r\nfail_init:\r\nkfree(asoc);\r\nfail:\r\nreturn NULL;\r\n}\r\nvoid sctp_association_free(struct sctp_association *asoc)\r\n{\r\nstruct sock *sk = asoc->base.sk;\r\nstruct sctp_transport *transport;\r\nstruct list_head *pos, *temp;\r\nint i;\r\nif (!asoc->temp) {\r\nlist_del(&asoc->asocs);\r\nif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\r\nsk->sk_ack_backlog--;\r\n}\r\nasoc->base.dead = 1;\r\nsctp_outq_free(&asoc->outqueue);\r\nsctp_ulpq_free(&asoc->ulpq);\r\nsctp_inq_free(&asoc->base.inqueue);\r\nsctp_tsnmap_free(&asoc->peer.tsn_map);\r\nsctp_ssnmap_free(asoc->ssnmap);\r\nsctp_bind_addr_free(&asoc->base.bind_addr);\r\nfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i) {\r\nif (timer_pending(&asoc->timers[i]) &&\r\ndel_timer(&asoc->timers[i]))\r\nsctp_association_put(asoc);\r\n}\r\nkfree(asoc->peer.cookie);\r\nkfree(asoc->peer.peer_random);\r\nkfree(asoc->peer.peer_chunks);\r\nkfree(asoc->peer.peer_hmacs);\r\nlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\r\ntransport = list_entry(pos, struct sctp_transport, transports);\r\nlist_del(pos);\r\nsctp_transport_free(transport);\r\n}\r\nasoc->peer.transport_count = 0;\r\nsctp_asconf_queue_teardown(asoc);\r\nif (asoc->asconf_addr_del_pending != NULL)\r\nkfree(asoc->asconf_addr_del_pending);\r\nsctp_auth_destroy_keys(&asoc->endpoint_shared_keys);\r\nsctp_auth_key_put(asoc->asoc_shared_key);\r\nsctp_association_put(asoc);\r\n}\r\nstatic void sctp_association_destroy(struct sctp_association *asoc)\r\n{\r\nSCTP_ASSERT(asoc->base.dead, "Assoc is not dead", return);\r\nsctp_endpoint_put(asoc->ep);\r\nsock_put(asoc->base.sk);\r\nif (asoc->assoc_id != 0) {\r\nspin_lock_bh(&sctp_assocs_id_lock);\r\nidr_remove(&sctp_assocs_id, asoc->assoc_id);\r\nspin_unlock_bh(&sctp_assocs_id_lock);\r\n}\r\nWARN_ON(atomic_read(&asoc->rmem_alloc));\r\nif (asoc->base.malloced) {\r\nkfree(asoc);\r\nSCTP_DBG_OBJCNT_DEC(assoc);\r\n}\r\n}\r\nvoid sctp_assoc_set_primary(struct sctp_association *asoc,\r\nstruct sctp_transport *transport)\r\n{\r\nint changeover = 0;\r\nif (asoc->peer.primary_path != NULL &&\r\nasoc->peer.primary_path != transport)\r\nchangeover = 1 ;\r\nasoc->peer.primary_path = transport;\r\nmemcpy(&asoc->peer.primary_addr, &transport->ipaddr,\r\nsizeof(union sctp_addr));\r\nif ((transport->state == SCTP_ACTIVE) ||\r\n(transport->state == SCTP_UNKNOWN))\r\nasoc->peer.active_path = transport;\r\nif (!asoc->outqueue.outstanding_bytes && !asoc->outqueue.out_qlen)\r\nreturn;\r\nif (transport->cacc.changeover_active)\r\ntransport->cacc.cycling_changeover = changeover;\r\ntransport->cacc.changeover_active = changeover;\r\ntransport->cacc.next_tsn_at_change = asoc->next_tsn;\r\n}\r\nvoid sctp_assoc_rm_peer(struct sctp_association *asoc,\r\nstruct sctp_transport *peer)\r\n{\r\nstruct list_head *pos;\r\nstruct sctp_transport *transport;\r\nSCTP_DEBUG_PRINTK_IPADDR("sctp_assoc_rm_peer:association %p addr: ",\r\n" port: %d\n",\r\nasoc,\r\n(&peer->ipaddr),\r\nntohs(peer->ipaddr.v4.sin_port));\r\nif (asoc->peer.retran_path == peer)\r\nsctp_assoc_update_retran_path(asoc);\r\nlist_del(&peer->transports);\r\npos = asoc->peer.transport_addr_list.next;\r\ntransport = list_entry(pos, struct sctp_transport, transports);\r\nif (asoc->peer.primary_path == peer)\r\nsctp_assoc_set_primary(asoc, transport);\r\nif (asoc->peer.active_path == peer)\r\nasoc->peer.active_path = transport;\r\nif (asoc->peer.retran_path == peer)\r\nasoc->peer.retran_path = transport;\r\nif (asoc->peer.last_data_from == peer)\r\nasoc->peer.last_data_from = transport;\r\nif (asoc->init_last_sent_to == peer)\r\nasoc->init_last_sent_to = NULL;\r\nif (asoc->shutdown_last_sent_to == peer)\r\nasoc->shutdown_last_sent_to = NULL;\r\nif (asoc->addip_last_asconf &&\r\nasoc->addip_last_asconf->transport == peer)\r\nasoc->addip_last_asconf->transport = NULL;\r\nif (!list_empty(&peer->transmitted)) {\r\nstruct sctp_transport *active = asoc->peer.active_path;\r\nstruct sctp_chunk *ch;\r\nlist_for_each_entry(ch, &peer->transmitted,\r\ntransmitted_list) {\r\nch->transport = NULL;\r\nch->rtt_in_progress = 0;\r\n}\r\nlist_splice_tail_init(&peer->transmitted,\r\n&active->transmitted);\r\nif (!timer_pending(&active->T3_rtx_timer))\r\nif (!mod_timer(&active->T3_rtx_timer,\r\njiffies + active->rto))\r\nsctp_transport_hold(active);\r\n}\r\nasoc->peer.transport_count--;\r\nsctp_transport_free(peer);\r\n}\r\nstruct sctp_transport *sctp_assoc_add_peer(struct sctp_association *asoc,\r\nconst union sctp_addr *addr,\r\nconst gfp_t gfp,\r\nconst int peer_state)\r\n{\r\nstruct sctp_transport *peer;\r\nstruct sctp_sock *sp;\r\nunsigned short port;\r\nsp = sctp_sk(asoc->base.sk);\r\nport = ntohs(addr->v4.sin_port);\r\nSCTP_DEBUG_PRINTK_IPADDR("sctp_assoc_add_peer:association %p addr: ",\r\n" port: %d state:%d\n",\r\nasoc,\r\naddr,\r\nport,\r\npeer_state);\r\nif (0 == asoc->peer.port)\r\nasoc->peer.port = port;\r\npeer = sctp_assoc_lookup_paddr(asoc, addr);\r\nif (peer) {\r\nif (peer->state == SCTP_UNKNOWN) {\r\npeer->state = SCTP_ACTIVE;\r\n}\r\nreturn peer;\r\n}\r\npeer = sctp_transport_new(addr, gfp);\r\nif (!peer)\r\nreturn NULL;\r\nsctp_transport_set_owner(peer, asoc);\r\npeer->hbinterval = asoc->hbinterval;\r\npeer->pathmaxrxt = asoc->pathmaxrxt;\r\npeer->sackdelay = asoc->sackdelay;\r\npeer->sackfreq = asoc->sackfreq;\r\npeer->param_flags = asoc->param_flags;\r\nsctp_transport_route(peer, NULL, sp);\r\nif (peer->param_flags & SPP_PMTUD_DISABLE) {\r\nif (asoc->pathmtu)\r\npeer->pathmtu = asoc->pathmtu;\r\nelse\r\npeer->pathmtu = SCTP_DEFAULT_MAXSEGMENT;\r\n}\r\nif (asoc->pathmtu)\r\nasoc->pathmtu = min_t(int, peer->pathmtu, asoc->pathmtu);\r\nelse\r\nasoc->pathmtu = peer->pathmtu;\r\nSCTP_DEBUG_PRINTK("sctp_assoc_add_peer:association %p PMTU set to "\r\n"%d\n", asoc, asoc->pathmtu);\r\npeer->pmtu_pending = 0;\r\nasoc->frag_point = sctp_frag_point(asoc, asoc->pathmtu);\r\nsctp_packet_init(&peer->packet, peer, asoc->base.bind_addr.port,\r\nasoc->peer.port);\r\npeer->cwnd = min(4*asoc->pathmtu, max_t(__u32, 2*asoc->pathmtu, 4380));\r\npeer->ssthresh = SCTP_DEFAULT_MAXWINDOW;\r\npeer->partial_bytes_acked = 0;\r\npeer->flight_size = 0;\r\npeer->burst_limited = 0;\r\npeer->rto = asoc->rto_initial;\r\npeer->state = peer_state;\r\nlist_add_tail(&peer->transports, &asoc->peer.transport_addr_list);\r\nasoc->peer.transport_count++;\r\nif (!asoc->peer.primary_path) {\r\nsctp_assoc_set_primary(asoc, peer);\r\nasoc->peer.retran_path = peer;\r\n}\r\nif (asoc->peer.active_path == asoc->peer.retran_path &&\r\npeer->state != SCTP_UNCONFIRMED) {\r\nasoc->peer.retran_path = peer;\r\n}\r\nreturn peer;\r\n}\r\nvoid sctp_assoc_del_peer(struct sctp_association *asoc,\r\nconst union sctp_addr *addr)\r\n{\r\nstruct list_head *pos;\r\nstruct list_head *temp;\r\nstruct sctp_transport *transport;\r\nlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\r\ntransport = list_entry(pos, struct sctp_transport, transports);\r\nif (sctp_cmp_addr_exact(addr, &transport->ipaddr)) {\r\nsctp_assoc_rm_peer(asoc, transport);\r\nbreak;\r\n}\r\n}\r\n}\r\nstruct sctp_transport *sctp_assoc_lookup_paddr(\r\nconst struct sctp_association *asoc,\r\nconst union sctp_addr *address)\r\n{\r\nstruct sctp_transport *t;\r\nlist_for_each_entry(t, &asoc->peer.transport_addr_list,\r\ntransports) {\r\nif (sctp_cmp_addr_exact(address, &t->ipaddr))\r\nreturn t;\r\n}\r\nreturn NULL;\r\n}\r\nvoid sctp_assoc_del_nonprimary_peers(struct sctp_association *asoc,\r\nstruct sctp_transport *primary)\r\n{\r\nstruct sctp_transport *temp;\r\nstruct sctp_transport *t;\r\nlist_for_each_entry_safe(t, temp, &asoc->peer.transport_addr_list,\r\ntransports) {\r\nif (t != primary)\r\nsctp_assoc_rm_peer(asoc, t);\r\n}\r\n}\r\nvoid sctp_assoc_control_transport(struct sctp_association *asoc,\r\nstruct sctp_transport *transport,\r\nsctp_transport_cmd_t command,\r\nsctp_sn_error_t error)\r\n{\r\nstruct sctp_transport *t = NULL;\r\nstruct sctp_transport *first;\r\nstruct sctp_transport *second;\r\nstruct sctp_ulpevent *event;\r\nstruct sockaddr_storage addr;\r\nint spc_state = 0;\r\nswitch (command) {\r\ncase SCTP_TRANSPORT_UP:\r\nif (SCTP_UNCONFIRMED == transport->state &&\r\nSCTP_HEARTBEAT_SUCCESS == error)\r\nspc_state = SCTP_ADDR_CONFIRMED;\r\nelse\r\nspc_state = SCTP_ADDR_AVAILABLE;\r\ntransport->state = SCTP_ACTIVE;\r\nbreak;\r\ncase SCTP_TRANSPORT_DOWN:\r\nif (transport->state != SCTP_UNCONFIRMED)\r\ntransport->state = SCTP_INACTIVE;\r\nelse {\r\ndst_release(transport->dst);\r\ntransport->dst = NULL;\r\n}\r\nspc_state = SCTP_ADDR_UNREACHABLE;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nmemset(&addr, 0, sizeof(struct sockaddr_storage));\r\nmemcpy(&addr, &transport->ipaddr, transport->af_specific->sockaddr_len);\r\nevent = sctp_ulpevent_make_peer_addr_change(asoc, &addr,\r\n0, spc_state, error, GFP_ATOMIC);\r\nif (event)\r\nsctp_ulpq_tail_event(&asoc->ulpq, event);\r\nfirst = NULL; second = NULL;\r\nlist_for_each_entry(t, &asoc->peer.transport_addr_list,\r\ntransports) {\r\nif ((t->state == SCTP_INACTIVE) ||\r\n(t->state == SCTP_UNCONFIRMED))\r\ncontinue;\r\nif (!first || t->last_time_heard > first->last_time_heard) {\r\nsecond = first;\r\nfirst = t;\r\n}\r\nif (!second || t->last_time_heard > second->last_time_heard)\r\nsecond = t;\r\n}\r\nif (((asoc->peer.primary_path->state == SCTP_ACTIVE) ||\r\n(asoc->peer.primary_path->state == SCTP_UNKNOWN)) &&\r\nfirst != asoc->peer.primary_path) {\r\nsecond = first;\r\nfirst = asoc->peer.primary_path;\r\n}\r\nif (!first) {\r\nfirst = asoc->peer.primary_path;\r\nsecond = asoc->peer.primary_path;\r\n}\r\nasoc->peer.active_path = first;\r\nasoc->peer.retran_path = second;\r\n}\r\nvoid sctp_association_hold(struct sctp_association *asoc)\r\n{\r\natomic_inc(&asoc->base.refcnt);\r\n}\r\nvoid sctp_association_put(struct sctp_association *asoc)\r\n{\r\nif (atomic_dec_and_test(&asoc->base.refcnt))\r\nsctp_association_destroy(asoc);\r\n}\r\n__u32 sctp_association_get_next_tsn(struct sctp_association *asoc)\r\n{\r\n__u32 retval = asoc->next_tsn;\r\nasoc->next_tsn++;\r\nasoc->unack_data++;\r\nreturn retval;\r\n}\r\nint sctp_cmp_addr_exact(const union sctp_addr *ss1,\r\nconst union sctp_addr *ss2)\r\n{\r\nstruct sctp_af *af;\r\naf = sctp_get_af_specific(ss1->sa.sa_family);\r\nif (unlikely(!af))\r\nreturn 0;\r\nreturn af->cmp_addr(ss1, ss2);\r\n}\r\nstruct sctp_chunk *sctp_get_ecne_prepend(struct sctp_association *asoc)\r\n{\r\nstruct sctp_chunk *chunk;\r\nif (asoc->need_ecne)\r\nchunk = sctp_make_ecne(asoc, asoc->last_ecne_tsn);\r\nelse\r\nchunk = NULL;\r\nreturn chunk;\r\n}\r\nstruct sctp_transport *sctp_assoc_lookup_tsn(struct sctp_association *asoc,\r\n__u32 tsn)\r\n{\r\nstruct sctp_transport *active;\r\nstruct sctp_transport *match;\r\nstruct sctp_transport *transport;\r\nstruct sctp_chunk *chunk;\r\n__be32 key = htonl(tsn);\r\nmatch = NULL;\r\nactive = asoc->peer.active_path;\r\nlist_for_each_entry(chunk, &active->transmitted,\r\ntransmitted_list) {\r\nif (key == chunk->subh.data_hdr->tsn) {\r\nmatch = active;\r\ngoto out;\r\n}\r\n}\r\nlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\r\ntransports) {\r\nif (transport == active)\r\nbreak;\r\nlist_for_each_entry(chunk, &transport->transmitted,\r\ntransmitted_list) {\r\nif (key == chunk->subh.data_hdr->tsn) {\r\nmatch = transport;\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nreturn match;\r\n}\r\nstruct sctp_transport *sctp_assoc_is_match(struct sctp_association *asoc,\r\nconst union sctp_addr *laddr,\r\nconst union sctp_addr *paddr)\r\n{\r\nstruct sctp_transport *transport;\r\nif ((htons(asoc->base.bind_addr.port) == laddr->v4.sin_port) &&\r\n(htons(asoc->peer.port) == paddr->v4.sin_port)) {\r\ntransport = sctp_assoc_lookup_paddr(asoc, paddr);\r\nif (!transport)\r\ngoto out;\r\nif (sctp_bind_addr_match(&asoc->base.bind_addr, laddr,\r\nsctp_sk(asoc->base.sk)))\r\ngoto out;\r\n}\r\ntransport = NULL;\r\nout:\r\nreturn transport;\r\n}\r\nstatic void sctp_assoc_bh_rcv(struct work_struct *work)\r\n{\r\nstruct sctp_association *asoc =\r\ncontainer_of(work, struct sctp_association,\r\nbase.inqueue.immediate);\r\nstruct sctp_endpoint *ep;\r\nstruct sctp_chunk *chunk;\r\nstruct sctp_inq *inqueue;\r\nint state;\r\nsctp_subtype_t subtype;\r\nint error = 0;\r\nep = asoc->ep;\r\ninqueue = &asoc->base.inqueue;\r\nsctp_association_hold(asoc);\r\nwhile (NULL != (chunk = sctp_inq_pop(inqueue))) {\r\nstate = asoc->state;\r\nsubtype = SCTP_ST_CHUNK(chunk->chunk_hdr->type);\r\nif (sctp_auth_recv_cid(subtype.chunk, asoc) && !chunk->auth)\r\ncontinue;\r\nif (sctp_chunk_is_data(chunk))\r\nasoc->peer.last_data_from = chunk->transport;\r\nelse\r\nSCTP_INC_STATS(SCTP_MIB_INCTRLCHUNKS);\r\nif (chunk->transport)\r\nchunk->transport->last_time_heard = jiffies;\r\nerror = sctp_do_sm(SCTP_EVENT_T_CHUNK, subtype,\r\nstate, ep, asoc, chunk, GFP_ATOMIC);\r\nif (asoc->base.dead)\r\nbreak;\r\nif (error && chunk)\r\nchunk->pdiscard = 1;\r\n}\r\nsctp_association_put(asoc);\r\n}\r\nvoid sctp_assoc_migrate(struct sctp_association *assoc, struct sock *newsk)\r\n{\r\nstruct sctp_sock *newsp = sctp_sk(newsk);\r\nstruct sock *oldsk = assoc->base.sk;\r\nlist_del_init(&assoc->asocs);\r\nif (sctp_style(oldsk, TCP))\r\noldsk->sk_ack_backlog--;\r\nsctp_endpoint_put(assoc->ep);\r\nsock_put(assoc->base.sk);\r\nassoc->ep = newsp->ep;\r\nsctp_endpoint_hold(assoc->ep);\r\nassoc->base.sk = newsk;\r\nsock_hold(assoc->base.sk);\r\nsctp_endpoint_add_asoc(newsp->ep, assoc);\r\n}\r\nvoid sctp_assoc_update(struct sctp_association *asoc,\r\nstruct sctp_association *new)\r\n{\r\nstruct sctp_transport *trans;\r\nstruct list_head *pos, *temp;\r\nasoc->c = new->c;\r\nasoc->peer.rwnd = new->peer.rwnd;\r\nasoc->peer.sack_needed = new->peer.sack_needed;\r\nasoc->peer.i = new->peer.i;\r\nsctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_INITIAL,\r\nasoc->peer.i.initial_tsn, GFP_ATOMIC);\r\nlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\r\ntrans = list_entry(pos, struct sctp_transport, transports);\r\nif (!sctp_assoc_lookup_paddr(new, &trans->ipaddr)) {\r\nsctp_assoc_rm_peer(asoc, trans);\r\ncontinue;\r\n}\r\nif (asoc->state >= SCTP_STATE_ESTABLISHED)\r\nsctp_transport_reset(trans);\r\n}\r\nif (asoc->state >= SCTP_STATE_ESTABLISHED) {\r\nasoc->next_tsn = new->next_tsn;\r\nasoc->ctsn_ack_point = new->ctsn_ack_point;\r\nasoc->adv_peer_ack_point = new->adv_peer_ack_point;\r\nsctp_ssnmap_clear(asoc->ssnmap);\r\nsctp_ulpq_flush(&asoc->ulpq);\r\nasoc->overall_error_count = 0;\r\n} else {\r\nlist_for_each_entry(trans, &new->peer.transport_addr_list,\r\ntransports) {\r\nif (!sctp_assoc_lookup_paddr(asoc, &trans->ipaddr))\r\nsctp_assoc_add_peer(asoc, &trans->ipaddr,\r\nGFP_ATOMIC, trans->state);\r\n}\r\nasoc->ctsn_ack_point = asoc->next_tsn - 1;\r\nasoc->adv_peer_ack_point = asoc->ctsn_ack_point;\r\nif (!asoc->ssnmap) {\r\nasoc->ssnmap = new->ssnmap;\r\nnew->ssnmap = NULL;\r\n}\r\nif (!asoc->assoc_id) {\r\nsctp_assoc_set_id(asoc, GFP_ATOMIC);\r\n}\r\n}\r\nkfree(asoc->peer.peer_random);\r\nasoc->peer.peer_random = new->peer.peer_random;\r\nnew->peer.peer_random = NULL;\r\nkfree(asoc->peer.peer_chunks);\r\nasoc->peer.peer_chunks = new->peer.peer_chunks;\r\nnew->peer.peer_chunks = NULL;\r\nkfree(asoc->peer.peer_hmacs);\r\nasoc->peer.peer_hmacs = new->peer.peer_hmacs;\r\nnew->peer.peer_hmacs = NULL;\r\nsctp_auth_key_put(asoc->asoc_shared_key);\r\nsctp_auth_asoc_init_active_key(asoc, GFP_ATOMIC);\r\n}\r\nvoid sctp_assoc_update_retran_path(struct sctp_association *asoc)\r\n{\r\nstruct sctp_transport *t, *next;\r\nstruct list_head *head = &asoc->peer.transport_addr_list;\r\nstruct list_head *pos;\r\nif (asoc->peer.transport_count == 1)\r\nreturn;\r\nt = asoc->peer.retran_path;\r\npos = &t->transports;\r\nnext = NULL;\r\nwhile (1) {\r\nif (pos->next == head)\r\npos = head->next;\r\nelse\r\npos = pos->next;\r\nt = list_entry(pos, struct sctp_transport, transports);\r\nif (t == asoc->peer.retran_path) {\r\nt = next;\r\nbreak;\r\n}\r\nif ((t->state == SCTP_ACTIVE) ||\r\n(t->state == SCTP_UNKNOWN)) {\r\nbreak;\r\n} else {\r\nif (t->state != SCTP_UNCONFIRMED && !next)\r\nnext = t;\r\n}\r\n}\r\nif (t)\r\nasoc->peer.retran_path = t;\r\nelse\r\nt = asoc->peer.retran_path;\r\nSCTP_DEBUG_PRINTK_IPADDR("sctp_assoc_update_retran_path:association"\r\n" %p addr: ",\r\n" port: %d\n",\r\nasoc,\r\n(&t->ipaddr),\r\nntohs(t->ipaddr.v4.sin_port));\r\n}\r\nstruct sctp_transport *sctp_assoc_choose_alter_transport(\r\nstruct sctp_association *asoc, struct sctp_transport *last_sent_to)\r\n{\r\nif (!last_sent_to)\r\nreturn asoc->peer.active_path;\r\nelse {\r\nif (last_sent_to == asoc->peer.retran_path)\r\nsctp_assoc_update_retran_path(asoc);\r\nreturn asoc->peer.retran_path;\r\n}\r\n}\r\nvoid sctp_assoc_sync_pmtu(struct sctp_association *asoc)\r\n{\r\nstruct sctp_transport *t;\r\n__u32 pmtu = 0;\r\nif (!asoc)\r\nreturn;\r\nlist_for_each_entry(t, &asoc->peer.transport_addr_list,\r\ntransports) {\r\nif (t->pmtu_pending && t->dst) {\r\nsctp_transport_update_pmtu(t, dst_mtu(t->dst));\r\nt->pmtu_pending = 0;\r\n}\r\nif (!pmtu || (t->pathmtu < pmtu))\r\npmtu = t->pathmtu;\r\n}\r\nif (pmtu) {\r\nasoc->pathmtu = pmtu;\r\nasoc->frag_point = sctp_frag_point(asoc, pmtu);\r\n}\r\nSCTP_DEBUG_PRINTK("%s: asoc:%p, pmtu:%d, frag_point:%d\n",\r\n__func__, asoc, asoc->pathmtu, asoc->frag_point);\r\n}\r\nstatic inline int sctp_peer_needs_update(struct sctp_association *asoc)\r\n{\r\nswitch (asoc->state) {\r\ncase SCTP_STATE_ESTABLISHED:\r\ncase SCTP_STATE_SHUTDOWN_PENDING:\r\ncase SCTP_STATE_SHUTDOWN_RECEIVED:\r\ncase SCTP_STATE_SHUTDOWN_SENT:\r\nif ((asoc->rwnd > asoc->a_rwnd) &&\r\n((asoc->rwnd - asoc->a_rwnd) >= max_t(__u32,\r\n(asoc->base.sk->sk_rcvbuf >> sctp_rwnd_upd_shift),\r\nasoc->pathmtu)))\r\nreturn 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid sctp_assoc_rwnd_increase(struct sctp_association *asoc, unsigned len)\r\n{\r\nstruct sctp_chunk *sack;\r\nstruct timer_list *timer;\r\nif (asoc->rwnd_over) {\r\nif (asoc->rwnd_over >= len) {\r\nasoc->rwnd_over -= len;\r\n} else {\r\nasoc->rwnd += (len - asoc->rwnd_over);\r\nasoc->rwnd_over = 0;\r\n}\r\n} else {\r\nasoc->rwnd += len;\r\n}\r\nif (asoc->rwnd_press && asoc->rwnd >= asoc->rwnd_press) {\r\nint change = min(asoc->pathmtu, asoc->rwnd_press);\r\nasoc->rwnd += change;\r\nasoc->rwnd_press -= change;\r\n}\r\nSCTP_DEBUG_PRINTK("%s: asoc %p rwnd increased by %d to (%u, %u) "\r\n"- %u\n", __func__, asoc, len, asoc->rwnd,\r\nasoc->rwnd_over, asoc->a_rwnd);\r\nif (sctp_peer_needs_update(asoc)) {\r\nasoc->a_rwnd = asoc->rwnd;\r\nSCTP_DEBUG_PRINTK("%s: Sending window update SACK- asoc: %p "\r\n"rwnd: %u a_rwnd: %u\n", __func__,\r\nasoc, asoc->rwnd, asoc->a_rwnd);\r\nsack = sctp_make_sack(asoc);\r\nif (!sack)\r\nreturn;\r\nasoc->peer.sack_needed = 0;\r\nsctp_outq_tail(&asoc->outqueue, sack);\r\ntimer = &asoc->timers[SCTP_EVENT_TIMEOUT_SACK];\r\nif (timer_pending(timer) && del_timer(timer))\r\nsctp_association_put(asoc);\r\n}\r\n}\r\nvoid sctp_assoc_rwnd_decrease(struct sctp_association *asoc, unsigned len)\r\n{\r\nint rx_count;\r\nint over = 0;\r\nSCTP_ASSERT(asoc->rwnd, "rwnd zero", return);\r\nSCTP_ASSERT(!asoc->rwnd_over, "rwnd_over not zero", return);\r\nif (asoc->ep->rcvbuf_policy)\r\nrx_count = atomic_read(&asoc->rmem_alloc);\r\nelse\r\nrx_count = atomic_read(&asoc->base.sk->sk_rmem_alloc);\r\nif (rx_count >= asoc->base.sk->sk_rcvbuf)\r\nover = 1;\r\nif (asoc->rwnd >= len) {\r\nasoc->rwnd -= len;\r\nif (over) {\r\nasoc->rwnd_press += asoc->rwnd;\r\nasoc->rwnd = 0;\r\n}\r\n} else {\r\nasoc->rwnd_over = len - asoc->rwnd;\r\nasoc->rwnd = 0;\r\n}\r\nSCTP_DEBUG_PRINTK("%s: asoc %p rwnd decreased by %d to (%u, %u, %u)\n",\r\n__func__, asoc, len, asoc->rwnd,\r\nasoc->rwnd_over, asoc->rwnd_press);\r\n}\r\nint sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,\r\nsctp_scope_t scope, gfp_t gfp)\r\n{\r\nint flags;\r\nflags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;\r\nif (asoc->peer.ipv4_address)\r\nflags |= SCTP_ADDR4_PEERSUPP;\r\nif (asoc->peer.ipv6_address)\r\nflags |= SCTP_ADDR6_PEERSUPP;\r\nreturn sctp_bind_addr_copy(&asoc->base.bind_addr,\r\n&asoc->ep->base.bind_addr,\r\nscope, gfp, flags);\r\n}\r\nint sctp_assoc_set_bind_addr_from_cookie(struct sctp_association *asoc,\r\nstruct sctp_cookie *cookie,\r\ngfp_t gfp)\r\n{\r\nint var_size2 = ntohs(cookie->peer_init->chunk_hdr.length);\r\nint var_size3 = cookie->raw_addr_list_len;\r\n__u8 *raw = (__u8 *)cookie->peer_init + var_size2;\r\nreturn sctp_raw_to_bind_addrs(&asoc->base.bind_addr, raw, var_size3,\r\nasoc->ep->base.bind_addr.port, gfp);\r\n}\r\nint sctp_assoc_lookup_laddr(struct sctp_association *asoc,\r\nconst union sctp_addr *laddr)\r\n{\r\nint found = 0;\r\nif ((asoc->base.bind_addr.port == ntohs(laddr->v4.sin_port)) &&\r\nsctp_bind_addr_match(&asoc->base.bind_addr, laddr,\r\nsctp_sk(asoc->base.sk)))\r\nfound = 1;\r\nreturn found;\r\n}\r\nint sctp_assoc_set_id(struct sctp_association *asoc, gfp_t gfp)\r\n{\r\nint assoc_id;\r\nint error = 0;\r\nif (asoc->assoc_id)\r\nreturn error;\r\nretry:\r\nif (unlikely(!idr_pre_get(&sctp_assocs_id, gfp)))\r\nreturn -ENOMEM;\r\nspin_lock_bh(&sctp_assocs_id_lock);\r\nerror = idr_get_new_above(&sctp_assocs_id, (void *)asoc,\r\nidr_low, &assoc_id);\r\nif (!error) {\r\nidr_low = assoc_id + 1;\r\nif (idr_low == INT_MAX)\r\nidr_low = 1;\r\n}\r\nspin_unlock_bh(&sctp_assocs_id_lock);\r\nif (error == -EAGAIN)\r\ngoto retry;\r\nelse if (error)\r\nreturn error;\r\nasoc->assoc_id = (sctp_assoc_t) assoc_id;\r\nreturn error;\r\n}\r\nstatic void sctp_assoc_free_asconf_queue(struct sctp_association *asoc)\r\n{\r\nstruct sctp_chunk *asconf;\r\nstruct sctp_chunk *tmp;\r\nlist_for_each_entry_safe(asconf, tmp, &asoc->addip_chunk_list, list) {\r\nlist_del_init(&asconf->list);\r\nsctp_chunk_free(asconf);\r\n}\r\n}\r\nstatic void sctp_assoc_free_asconf_acks(struct sctp_association *asoc)\r\n{\r\nstruct sctp_chunk *ack;\r\nstruct sctp_chunk *tmp;\r\nlist_for_each_entry_safe(ack, tmp, &asoc->asconf_ack_list,\r\ntransmitted_list) {\r\nlist_del_init(&ack->transmitted_list);\r\nsctp_chunk_free(ack);\r\n}\r\n}\r\nvoid sctp_assoc_clean_asconf_ack_cache(const struct sctp_association *asoc)\r\n{\r\nstruct sctp_chunk *ack;\r\nstruct sctp_chunk *tmp;\r\nlist_for_each_entry_safe(ack, tmp, &asoc->asconf_ack_list,\r\ntransmitted_list) {\r\nif (ack->subh.addip_hdr->serial ==\r\nhtonl(asoc->peer.addip_serial))\r\nbreak;\r\nlist_del_init(&ack->transmitted_list);\r\nsctp_chunk_free(ack);\r\n}\r\n}\r\nstruct sctp_chunk *sctp_assoc_lookup_asconf_ack(\r\nconst struct sctp_association *asoc,\r\n__be32 serial)\r\n{\r\nstruct sctp_chunk *ack;\r\nlist_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {\r\nif (ack->subh.addip_hdr->serial == serial) {\r\nsctp_chunk_hold(ack);\r\nreturn ack;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nvoid sctp_asconf_queue_teardown(struct sctp_association *asoc)\r\n{\r\nsctp_assoc_free_asconf_acks(asoc);\r\nsctp_assoc_free_asconf_queue(asoc);\r\nif (asoc->addip_last_asconf)\r\nsctp_chunk_free(asoc->addip_last_asconf);\r\n}
