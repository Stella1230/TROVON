static void\r\nev6_reg_setup(struct op_register_config *reg,\r\nstruct op_counter_config *ctr,\r\nstruct op_system_config *sys)\r\n{\r\nunsigned long ctl, reset, need_reset, i;\r\nctl = 0;\r\nif (ctr[0].enabled && ctr[0].event)\r\nctl |= (ctr[0].event & 1) << 4;\r\nif (ctr[1].enabled)\r\nctl |= (ctr[1].event - 2) & 15;\r\nreg->mux_select = ctl;\r\nreg->proc_mode = 0;\r\nreset = need_reset = 0;\r\nfor (i = 0; i < 2; ++i) {\r\nunsigned long count = ctr[i].count;\r\nif (!ctr[i].enabled)\r\ncontinue;\r\nif (count > 0x100000)\r\ncount = 0x100000;\r\nctr[i].count = count;\r\nreset |= (0x100000 - count) << (i ? 6 : 28);\r\nif (count != 0x100000)\r\nneed_reset |= 1 << i;\r\n}\r\nreg->reset_values = reset;\r\nreg->need_reset = need_reset;\r\n}\r\nstatic void\r\nev6_cpu_setup (void *x)\r\n{\r\nstruct op_register_config *reg = x;\r\nwrperfmon(2, reg->mux_select);\r\nwrperfmon(3, reg->proc_mode);\r\nwrperfmon(6, reg->reset_values | 3);\r\n}\r\nstatic void\r\nev6_reset_ctr(struct op_register_config *reg, unsigned long ctr)\r\n{\r\nwrperfmon(6, reg->reset_values | (1 << ctr));\r\n}\r\nstatic void\r\nev6_handle_interrupt(unsigned long which, struct pt_regs *regs,\r\nstruct op_counter_config *ctr)\r\n{\r\noprofile_add_sample(regs, which);\r\n}
