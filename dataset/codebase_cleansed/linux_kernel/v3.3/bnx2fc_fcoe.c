static inline struct net_device *bnx2fc_netdev(const struct fc_lport *lport)\r\n{\r\nreturn ((struct bnx2fc_interface *)\r\n((struct fcoe_port *)lport_priv(lport))->priv)->netdev;\r\n}\r\nstatic void bnx2fc_get_lesb(struct fc_lport *lport,\r\nstruct fc_els_lesb *fc_lesb)\r\n{\r\nstruct net_device *netdev = bnx2fc_netdev(lport);\r\n__fcoe_get_lesb(lport, fc_lesb, netdev);\r\n}\r\nstatic void bnx2fc_clean_rx_queue(struct fc_lport *lp)\r\n{\r\nstruct fcoe_percpu_s *bg;\r\nstruct fcoe_rcv_info *fr;\r\nstruct sk_buff_head *list;\r\nstruct sk_buff *skb, *next;\r\nstruct sk_buff *head;\r\nbg = &bnx2fc_global;\r\nspin_lock_bh(&bg->fcoe_rx_list.lock);\r\nlist = &bg->fcoe_rx_list;\r\nhead = list->next;\r\nfor (skb = head; skb != (struct sk_buff *)list;\r\nskb = next) {\r\nnext = skb->next;\r\nfr = fcoe_dev_from_skb(skb);\r\nif (fr->fr_dev == lp) {\r\n__skb_unlink(skb, list);\r\nkfree_skb(skb);\r\n}\r\n}\r\nspin_unlock_bh(&bg->fcoe_rx_list.lock);\r\n}\r\nint bnx2fc_get_paged_crc_eof(struct sk_buff *skb, int tlen)\r\n{\r\nint rc;\r\nspin_lock(&bnx2fc_global_lock);\r\nrc = fcoe_get_paged_crc_eof(skb, tlen, &bnx2fc_global);\r\nspin_unlock(&bnx2fc_global_lock);\r\nreturn rc;\r\n}\r\nstatic void bnx2fc_abort_io(struct fc_lport *lport)\r\n{\r\n}\r\nstatic void bnx2fc_cleanup(struct fc_lport *lport)\r\n{\r\nstruct fcoe_port *port = lport_priv(lport);\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct bnx2fc_hba *hba = interface->hba;\r\nstruct bnx2fc_rport *tgt;\r\nint i;\r\nBNX2FC_MISC_DBG("Entered %s\n", __func__);\r\nmutex_lock(&hba->hba_mutex);\r\nspin_lock_bh(&hba->hba_lock);\r\nfor (i = 0; i < BNX2FC_NUM_MAX_SESS; i++) {\r\ntgt = hba->tgt_ofld_list[i];\r\nif (tgt) {\r\nif (tgt->port == port) {\r\nspin_unlock_bh(&hba->hba_lock);\r\nBNX2FC_TGT_DBG(tgt, "flush/cleanup\n");\r\nbnx2fc_flush_active_ios(tgt);\r\nspin_lock_bh(&hba->hba_lock);\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&hba->hba_lock);\r\nmutex_unlock(&hba->hba_mutex);\r\n}\r\nstatic int bnx2fc_xmit_l2_frame(struct bnx2fc_rport *tgt,\r\nstruct fc_frame *fp)\r\n{\r\nstruct fc_rport_priv *rdata = tgt->rdata;\r\nstruct fc_frame_header *fh;\r\nint rc = 0;\r\nfh = fc_frame_header_get(fp);\r\nBNX2FC_TGT_DBG(tgt, "Xmit L2 frame rport = 0x%x, oxid = 0x%x, "\r\n"r_ctl = 0x%x\n", rdata->ids.port_id,\r\nntohs(fh->fh_ox_id), fh->fh_r_ctl);\r\nif ((fh->fh_type == FC_TYPE_ELS) &&\r\n(fh->fh_r_ctl == FC_RCTL_ELS_REQ)) {\r\nswitch (fc_frame_payload_op(fp)) {\r\ncase ELS_ADISC:\r\nrc = bnx2fc_send_adisc(tgt, fp);\r\nbreak;\r\ncase ELS_LOGO:\r\nrc = bnx2fc_send_logo(tgt, fp);\r\nbreak;\r\ncase ELS_RLS:\r\nrc = bnx2fc_send_rls(tgt, fp);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else if ((fh->fh_type == FC_TYPE_BLS) &&\r\n(fh->fh_r_ctl == FC_RCTL_BA_ABTS))\r\nBNX2FC_TGT_DBG(tgt, "ABTS frame\n");\r\nelse {\r\nBNX2FC_TGT_DBG(tgt, "Send L2 frame type 0x%x "\r\n"rctl 0x%x thru non-offload path\n",\r\nfh->fh_type, fh->fh_r_ctl);\r\nreturn -ENODEV;\r\n}\r\nif (rc)\r\nreturn -ENOMEM;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int bnx2fc_xmit(struct fc_lport *lport, struct fc_frame *fp)\r\n{\r\nstruct ethhdr *eh;\r\nstruct fcoe_crc_eof *cp;\r\nstruct sk_buff *skb;\r\nstruct fc_frame_header *fh;\r\nstruct bnx2fc_interface *interface;\r\nstruct bnx2fc_hba *hba;\r\nstruct fcoe_port *port;\r\nstruct fcoe_hdr *hp;\r\nstruct bnx2fc_rport *tgt;\r\nstruct fcoe_dev_stats *stats;\r\nu8 sof, eof;\r\nu32 crc;\r\nunsigned int hlen, tlen, elen;\r\nint wlen, rc = 0;\r\nport = (struct fcoe_port *)lport_priv(lport);\r\ninterface = port->priv;\r\nhba = interface->hba;\r\nfh = fc_frame_header_get(fp);\r\nskb = fp_skb(fp);\r\nif (!lport->link_up) {\r\nBNX2FC_HBA_DBG(lport, "bnx2fc_xmit link down\n");\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nif (unlikely(fh->fh_r_ctl == FC_RCTL_ELS_REQ)) {\r\nif (!interface->ctlr.sel_fcf) {\r\nBNX2FC_HBA_DBG(lport, "FCF not selected yet!\n");\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nif (fcoe_ctlr_els_send(&interface->ctlr, lport, skb))\r\nreturn 0;\r\n}\r\nsof = fr_sof(fp);\r\neof = fr_eof(fp);\r\nspin_lock_bh(&hba->hba_lock);\r\ntgt = bnx2fc_tgt_lookup(port, ntoh24(fh->fh_d_id));\r\nif (tgt && (test_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags))) {\r\nBNX2FC_HBA_DBG(lport, "xmit: Frame is for offloaded session "\r\n"port_id = 0x%x\n", ntoh24(fh->fh_d_id));\r\nspin_unlock_bh(&hba->hba_lock);\r\nrc = bnx2fc_xmit_l2_frame(tgt, fp);\r\nif (rc != -ENODEV) {\r\nkfree_skb(skb);\r\nreturn rc;\r\n}\r\n} else {\r\nspin_unlock_bh(&hba->hba_lock);\r\n}\r\nelen = sizeof(struct ethhdr);\r\nhlen = sizeof(struct fcoe_hdr);\r\ntlen = sizeof(struct fcoe_crc_eof);\r\nwlen = (skb->len - tlen + sizeof(crc)) / FCOE_WORD_TO_BYTE;\r\nskb->ip_summed = CHECKSUM_NONE;\r\ncrc = fcoe_fc_crc(fp);\r\nif (skb_is_nonlinear(skb)) {\r\nskb_frag_t *frag;\r\nif (bnx2fc_get_paged_crc_eof(skb, tlen)) {\r\nkfree_skb(skb);\r\nreturn -ENOMEM;\r\n}\r\nfrag = &skb_shinfo(skb)->frags[skb_shinfo(skb)->nr_frags - 1];\r\ncp = kmap_atomic(skb_frag_page(frag), KM_SKB_DATA_SOFTIRQ)\r\n+ frag->page_offset;\r\n} else {\r\ncp = (struct fcoe_crc_eof *)skb_put(skb, tlen);\r\n}\r\nmemset(cp, 0, sizeof(*cp));\r\ncp->fcoe_eof = eof;\r\ncp->fcoe_crc32 = cpu_to_le32(~crc);\r\nif (skb_is_nonlinear(skb)) {\r\nkunmap_atomic(cp, KM_SKB_DATA_SOFTIRQ);\r\ncp = NULL;\r\n}\r\nskb_push(skb, elen + hlen);\r\nskb_reset_mac_header(skb);\r\nskb_reset_network_header(skb);\r\nskb->mac_len = elen;\r\nskb->protocol = htons(ETH_P_FCOE);\r\nskb->dev = interface->netdev;\r\neh = eth_hdr(skb);\r\neh->h_proto = htons(ETH_P_FCOE);\r\nif (interface->ctlr.map_dest)\r\nfc_fcoe_set_mac(eh->h_dest, fh->fh_d_id);\r\nelse\r\nmemcpy(eh->h_dest, interface->ctlr.dest_addr, ETH_ALEN);\r\nif (unlikely(interface->ctlr.flogi_oxid != FC_XID_UNKNOWN))\r\nmemcpy(eh->h_source, interface->ctlr.ctl_src_addr, ETH_ALEN);\r\nelse\r\nmemcpy(eh->h_source, port->data_src_addr, ETH_ALEN);\r\nhp = (struct fcoe_hdr *)(eh + 1);\r\nmemset(hp, 0, sizeof(*hp));\r\nif (FC_FCOE_VER)\r\nFC_FCOE_ENCAPS_VER(hp, FC_FCOE_VER);\r\nhp->fcoe_sof = sof;\r\nif (lport->seq_offload && fr_max_payload(fp)) {\r\nskb_shinfo(skb)->gso_type = SKB_GSO_FCOE;\r\nskb_shinfo(skb)->gso_size = fr_max_payload(fp);\r\n} else {\r\nskb_shinfo(skb)->gso_type = 0;\r\nskb_shinfo(skb)->gso_size = 0;\r\n}\r\nstats = per_cpu_ptr(lport->dev_stats, get_cpu());\r\nstats->TxFrames++;\r\nstats->TxWords += wlen;\r\nput_cpu();\r\nfr_dev(fp) = lport;\r\nif (port->fcoe_pending_queue.qlen)\r\nfcoe_check_wait_queue(lport, skb);\r\nelse if (fcoe_start_io(skb))\r\nfcoe_check_wait_queue(lport, skb);\r\nreturn 0;\r\n}\r\nstatic int bnx2fc_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *ptype, struct net_device *olddev)\r\n{\r\nstruct fc_lport *lport;\r\nstruct bnx2fc_interface *interface;\r\nstruct fc_frame_header *fh;\r\nstruct fcoe_rcv_info *fr;\r\nstruct fcoe_percpu_s *bg;\r\nunsigned short oxid;\r\ninterface = container_of(ptype, struct bnx2fc_interface,\r\nfcoe_packet_type);\r\nlport = interface->ctlr.lp;\r\nif (unlikely(lport == NULL)) {\r\nprintk(KERN_ERR PFX "bnx2fc_rcv: lport is NULL\n");\r\ngoto err;\r\n}\r\nif (unlikely(eth_hdr(skb)->h_proto != htons(ETH_P_FCOE))) {\r\nprintk(KERN_ERR PFX "bnx2fc_rcv: Wrong FC type frame\n");\r\ngoto err;\r\n}\r\nif (unlikely((skb->len < FCOE_MIN_FRAME) ||\r\n!pskb_may_pull(skb, FCOE_HEADER_LEN)))\r\ngoto err;\r\nskb_set_transport_header(skb, sizeof(struct fcoe_hdr));\r\nfh = (struct fc_frame_header *) skb_transport_header(skb);\r\noxid = ntohs(fh->fh_ox_id);\r\nfr = fcoe_dev_from_skb(skb);\r\nfr->fr_dev = lport;\r\nbg = &bnx2fc_global;\r\nspin_lock_bh(&bg->fcoe_rx_list.lock);\r\n__skb_queue_tail(&bg->fcoe_rx_list, skb);\r\nif (bg->fcoe_rx_list.qlen == 1)\r\nwake_up_process(bg->thread);\r\nspin_unlock_bh(&bg->fcoe_rx_list.lock);\r\nreturn 0;\r\nerr:\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nstatic int bnx2fc_l2_rcv_thread(void *arg)\r\n{\r\nstruct fcoe_percpu_s *bg = arg;\r\nstruct sk_buff *skb;\r\nset_user_nice(current, -20);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (!kthread_should_stop()) {\r\nschedule();\r\nspin_lock_bh(&bg->fcoe_rx_list.lock);\r\nwhile ((skb = __skb_dequeue(&bg->fcoe_rx_list)) != NULL) {\r\nspin_unlock_bh(&bg->fcoe_rx_list.lock);\r\nbnx2fc_recv_frame(skb);\r\nspin_lock_bh(&bg->fcoe_rx_list.lock);\r\n}\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_bh(&bg->fcoe_rx_list.lock);\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nreturn 0;\r\n}\r\nstatic void bnx2fc_recv_frame(struct sk_buff *skb)\r\n{\r\nu32 fr_len;\r\nstruct fc_lport *lport;\r\nstruct fcoe_rcv_info *fr;\r\nstruct fcoe_dev_stats *stats;\r\nstruct fc_frame_header *fh;\r\nstruct fcoe_crc_eof crc_eof;\r\nstruct fc_frame *fp;\r\nstruct fc_lport *vn_port;\r\nstruct fcoe_port *port;\r\nu8 *mac = NULL;\r\nu8 *dest_mac = NULL;\r\nstruct fcoe_hdr *hp;\r\nfr = fcoe_dev_from_skb(skb);\r\nlport = fr->fr_dev;\r\nif (unlikely(lport == NULL)) {\r\nprintk(KERN_ERR PFX "Invalid lport struct\n");\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (skb_is_nonlinear(skb))\r\nskb_linearize(skb);\r\nmac = eth_hdr(skb)->h_source;\r\ndest_mac = eth_hdr(skb)->h_dest;\r\nhp = (struct fcoe_hdr *) skb_network_header(skb);\r\nfh = (struct fc_frame_header *) skb_transport_header(skb);\r\nskb_pull(skb, sizeof(struct fcoe_hdr));\r\nfr_len = skb->len - sizeof(struct fcoe_crc_eof);\r\nstats = per_cpu_ptr(lport->dev_stats, get_cpu());\r\nstats->RxFrames++;\r\nstats->RxWords += fr_len / FCOE_WORD_TO_BYTE;\r\nfp = (struct fc_frame *)skb;\r\nfc_frame_init(fp);\r\nfr_dev(fp) = lport;\r\nfr_sof(fp) = hp->fcoe_sof;\r\nif (skb_copy_bits(skb, fr_len, &crc_eof, sizeof(crc_eof))) {\r\nput_cpu();\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nfr_eof(fp) = crc_eof.fcoe_eof;\r\nfr_crc(fp) = crc_eof.fcoe_crc32;\r\nif (pskb_trim(skb, fr_len)) {\r\nput_cpu();\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nfh = fc_frame_header_get(fp);\r\nvn_port = fc_vport_id_lookup(lport, ntoh24(fh->fh_d_id));\r\nif (vn_port) {\r\nport = lport_priv(vn_port);\r\nif (compare_ether_addr(port->data_src_addr, dest_mac)\r\n!= 0) {\r\nBNX2FC_HBA_DBG(lport, "fpma mismatch\n");\r\nput_cpu();\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\n}\r\nif (fh->fh_r_ctl == FC_RCTL_DD_SOL_DATA &&\r\nfh->fh_type == FC_TYPE_FCP) {\r\nput_cpu();\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (fh->fh_r_ctl == FC_RCTL_ELS_REQ &&\r\nfh->fh_type == FC_TYPE_ELS) {\r\nswitch (fc_frame_payload_op(fp)) {\r\ncase ELS_LOGO:\r\nif (ntoh24(fh->fh_s_id) == FC_FID_FLOGI) {\r\nput_cpu();\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (fh->fh_r_ctl == FC_RCTL_BA_ABTS) {\r\nput_cpu();\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (le32_to_cpu(fr_crc(fp)) !=\r\n~crc32(~0, skb->data, fr_len)) {\r\nif (stats->InvalidCRCCount < 5)\r\nprintk(KERN_WARNING PFX "dropping frame with "\r\n"CRC error\n");\r\nstats->InvalidCRCCount++;\r\nput_cpu();\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nput_cpu();\r\nfc_exch_recv(lport, fp);\r\n}\r\nint bnx2fc_percpu_io_thread(void *arg)\r\n{\r\nstruct bnx2fc_percpu_s *p = arg;\r\nstruct bnx2fc_work *work, *tmp;\r\nLIST_HEAD(work_list);\r\nset_user_nice(current, -20);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (!kthread_should_stop()) {\r\nschedule();\r\nspin_lock_bh(&p->fp_work_lock);\r\nwhile (!list_empty(&p->work_list)) {\r\nlist_splice_init(&p->work_list, &work_list);\r\nspin_unlock_bh(&p->fp_work_lock);\r\nlist_for_each_entry_safe(work, tmp, &work_list, list) {\r\nlist_del_init(&work->list);\r\nbnx2fc_process_cq_compl(work->tgt, work->wqe);\r\nkfree(work);\r\n}\r\nspin_lock_bh(&p->fp_work_lock);\r\n}\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_bh(&p->fp_work_lock);\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nreturn 0;\r\n}\r\nstatic struct fc_host_statistics *bnx2fc_get_host_stats(struct Scsi_Host *shost)\r\n{\r\nstruct fc_host_statistics *bnx2fc_stats;\r\nstruct fc_lport *lport = shost_priv(shost);\r\nstruct fcoe_port *port = lport_priv(lport);\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct bnx2fc_hba *hba = interface->hba;\r\nstruct fcoe_statistics_params *fw_stats;\r\nint rc = 0;\r\nfw_stats = (struct fcoe_statistics_params *)hba->stats_buffer;\r\nif (!fw_stats)\r\nreturn NULL;\r\nbnx2fc_stats = fc_get_host_stats(shost);\r\ninit_completion(&hba->stat_req_done);\r\nif (bnx2fc_send_stat_req(hba))\r\nreturn bnx2fc_stats;\r\nrc = wait_for_completion_timeout(&hba->stat_req_done, (2 * HZ));\r\nif (!rc) {\r\nBNX2FC_HBA_DBG(lport, "FW stat req timed out\n");\r\nreturn bnx2fc_stats;\r\n}\r\nbnx2fc_stats->invalid_crc_count += fw_stats->rx_stat2.fc_crc_cnt;\r\nbnx2fc_stats->tx_frames += fw_stats->tx_stat.fcoe_tx_pkt_cnt;\r\nbnx2fc_stats->tx_words += (fw_stats->tx_stat.fcoe_tx_byte_cnt) / 4;\r\nbnx2fc_stats->rx_frames += fw_stats->rx_stat0.fcoe_rx_pkt_cnt;\r\nbnx2fc_stats->rx_words += (fw_stats->rx_stat0.fcoe_rx_byte_cnt) / 4;\r\nbnx2fc_stats->dumped_frames = 0;\r\nbnx2fc_stats->lip_count = 0;\r\nbnx2fc_stats->nos_count = 0;\r\nbnx2fc_stats->loss_of_sync_count = 0;\r\nbnx2fc_stats->loss_of_signal_count = 0;\r\nbnx2fc_stats->prim_seq_protocol_err_count = 0;\r\nreturn bnx2fc_stats;\r\n}\r\nstatic int bnx2fc_shost_config(struct fc_lport *lport, struct device *dev)\r\n{\r\nstruct fcoe_port *port = lport_priv(lport);\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct Scsi_Host *shost = lport->host;\r\nint rc = 0;\r\nshost->max_cmd_len = BNX2FC_MAX_CMD_LEN;\r\nshost->max_lun = BNX2FC_MAX_LUN;\r\nshost->max_id = BNX2FC_MAX_FCP_TGT;\r\nshost->max_channel = 0;\r\nif (lport->vport)\r\nshost->transportt = bnx2fc_vport_xport_template;\r\nelse\r\nshost->transportt = bnx2fc_transport_template;\r\nrc = scsi_add_host(lport->host, dev);\r\nif (rc) {\r\nprintk(KERN_ERR PFX "Error on scsi_add_host\n");\r\nreturn rc;\r\n}\r\nif (!lport->vport)\r\nfc_host_max_npiv_vports(lport->host) = USHRT_MAX;\r\nsprintf(fc_host_symbolic_name(lport->host), "%s v%s over %s",\r\nBNX2FC_NAME, BNX2FC_VERSION,\r\ninterface->netdev->name);\r\nreturn 0;\r\n}\r\nstatic void bnx2fc_link_speed_update(struct fc_lport *lport)\r\n{\r\nstruct fcoe_port *port = lport_priv(lport);\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct net_device *netdev = interface->netdev;\r\nstruct ethtool_cmd ecmd;\r\nif (!__ethtool_get_settings(netdev, &ecmd)) {\r\nlport->link_supported_speeds &=\r\n~(FC_PORTSPEED_1GBIT | FC_PORTSPEED_10GBIT);\r\nif (ecmd.supported & (SUPPORTED_1000baseT_Half |\r\nSUPPORTED_1000baseT_Full))\r\nlport->link_supported_speeds |= FC_PORTSPEED_1GBIT;\r\nif (ecmd.supported & SUPPORTED_10000baseT_Full)\r\nlport->link_supported_speeds |= FC_PORTSPEED_10GBIT;\r\nswitch (ethtool_cmd_speed(&ecmd)) {\r\ncase SPEED_1000:\r\nlport->link_speed = FC_PORTSPEED_1GBIT;\r\nbreak;\r\ncase SPEED_2500:\r\nlport->link_speed = FC_PORTSPEED_2GBIT;\r\nbreak;\r\ncase SPEED_10000:\r\nlport->link_speed = FC_PORTSPEED_10GBIT;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int bnx2fc_link_ok(struct fc_lport *lport)\r\n{\r\nstruct fcoe_port *port = lport_priv(lport);\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct bnx2fc_hba *hba = interface->hba;\r\nstruct net_device *dev = hba->phys_dev;\r\nint rc = 0;\r\nif ((dev->flags & IFF_UP) && netif_carrier_ok(dev))\r\nclear_bit(ADAPTER_STATE_LINK_DOWN, &hba->adapter_state);\r\nelse {\r\nset_bit(ADAPTER_STATE_LINK_DOWN, &hba->adapter_state);\r\nrc = -1;\r\n}\r\nreturn rc;\r\n}\r\nvoid bnx2fc_get_link_state(struct bnx2fc_hba *hba)\r\n{\r\nif (test_bit(__LINK_STATE_NOCARRIER, &hba->phys_dev->state))\r\nset_bit(ADAPTER_STATE_LINK_DOWN, &hba->adapter_state);\r\nelse\r\nclear_bit(ADAPTER_STATE_LINK_DOWN, &hba->adapter_state);\r\n}\r\nstatic int bnx2fc_net_config(struct fc_lport *lport, struct net_device *netdev)\r\n{\r\nstruct bnx2fc_hba *hba;\r\nstruct bnx2fc_interface *interface;\r\nstruct fcoe_port *port;\r\nu64 wwnn, wwpn;\r\nport = lport_priv(lport);\r\ninterface = port->priv;\r\nhba = interface->hba;\r\nif (!hba->phys_dev->ethtool_ops ||\r\n!hba->phys_dev->ethtool_ops->get_pauseparam)\r\nreturn -EOPNOTSUPP;\r\nif (fc_set_mfs(lport, BNX2FC_MFS))\r\nreturn -EINVAL;\r\nskb_queue_head_init(&port->fcoe_pending_queue);\r\nport->fcoe_pending_queue_active = 0;\r\nsetup_timer(&port->timer, fcoe_queue_timer, (unsigned long) lport);\r\nbnx2fc_link_speed_update(lport);\r\nif (!lport->vport) {\r\nif (fcoe_get_wwn(netdev, &wwnn, NETDEV_FCOE_WWNN))\r\nwwnn = fcoe_wwn_from_mac(interface->ctlr.ctl_src_addr,\r\n1, 0);\r\nBNX2FC_HBA_DBG(lport, "WWNN = 0x%llx\n", wwnn);\r\nfc_set_wwnn(lport, wwnn);\r\nif (fcoe_get_wwn(netdev, &wwpn, NETDEV_FCOE_WWPN))\r\nwwpn = fcoe_wwn_from_mac(interface->ctlr.ctl_src_addr,\r\n2, 0);\r\nBNX2FC_HBA_DBG(lport, "WWPN = 0x%llx\n", wwpn);\r\nfc_set_wwpn(lport, wwpn);\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2fc_destroy_timer(unsigned long data)\r\n{\r\nstruct bnx2fc_hba *hba = (struct bnx2fc_hba *)data;\r\nprintk(KERN_ERR PFX "ERROR:bnx2fc_destroy_timer - "\r\n"Destroy compl not received!!\n");\r\nset_bit(BNX2FC_FLAG_DESTROY_CMPL, &hba->flags);\r\nwake_up_interruptible(&hba->destroy_wait);\r\n}\r\nstatic void bnx2fc_indicate_netevent(void *context, unsigned long event,\r\nu16 vlan_id)\r\n{\r\nstruct bnx2fc_hba *hba = (struct bnx2fc_hba *)context;\r\nstruct fc_lport *lport;\r\nstruct fc_lport *vport;\r\nstruct bnx2fc_interface *interface, *tmp;\r\nint wait_for_upload = 0;\r\nu32 link_possible = 1;\r\nif (vlan_id != 0 && event != NETDEV_UNREGISTER)\r\nreturn;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nif (!test_bit(ADAPTER_STATE_UP, &hba->adapter_state))\r\nprintk(KERN_ERR "indicate_netevent: "\\r\n"hba is not UP!!\n");\r\nbreak;\r\ncase NETDEV_DOWN:\r\nclear_bit(ADAPTER_STATE_GOING_DOWN, &hba->adapter_state);\r\nclear_bit(ADAPTER_STATE_UP, &hba->adapter_state);\r\nlink_possible = 0;\r\nbreak;\r\ncase NETDEV_GOING_DOWN:\r\nset_bit(ADAPTER_STATE_GOING_DOWN, &hba->adapter_state);\r\nlink_possible = 0;\r\nbreak;\r\ncase NETDEV_CHANGE:\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nif (!vlan_id)\r\nreturn;\r\nmutex_lock(&bnx2fc_dev_lock);\r\nlist_for_each_entry_safe(interface, tmp, &if_list, list) {\r\nif (interface->hba == hba &&\r\ninterface->vlan_id == (vlan_id & VLAN_VID_MASK))\r\n__bnx2fc_destroy(interface);\r\n}\r\nmutex_unlock(&bnx2fc_dev_lock);\r\nreturn;\r\ndefault:\r\nprintk(KERN_ERR PFX "Unkonwn netevent %ld", event);\r\nreturn;\r\n}\r\nmutex_lock(&bnx2fc_dev_lock);\r\nlist_for_each_entry(interface, &if_list, list) {\r\nif (interface->hba != hba)\r\ncontinue;\r\nlport = interface->ctlr.lp;\r\nBNX2FC_HBA_DBG(lport, "netevent handler - event=%s %ld\n",\r\ninterface->netdev->name, event);\r\nbnx2fc_link_speed_update(lport);\r\nif (link_possible && !bnx2fc_link_ok(lport)) {\r\nfc_set_mfs(lport, BNX2FC_MFS);\r\nif (interface->enabled)\r\nfcoe_ctlr_link_up(&interface->ctlr);\r\n} else if (fcoe_ctlr_link_down(&interface->ctlr)) {\r\nmutex_lock(&lport->lp_mutex);\r\nlist_for_each_entry(vport, &lport->vports, list)\r\nfc_host_port_type(vport->host) =\r\nFC_PORTTYPE_UNKNOWN;\r\nmutex_unlock(&lport->lp_mutex);\r\nfc_host_port_type(lport->host) = FC_PORTTYPE_UNKNOWN;\r\nper_cpu_ptr(lport->dev_stats,\r\nget_cpu())->LinkFailureCount++;\r\nput_cpu();\r\nfcoe_clean_pending_queue(lport);\r\nwait_for_upload = 1;\r\n}\r\n}\r\nmutex_unlock(&bnx2fc_dev_lock);\r\nif (wait_for_upload) {\r\nclear_bit(ADAPTER_STATE_READY, &hba->adapter_state);\r\ninit_waitqueue_head(&hba->shutdown_wait);\r\nBNX2FC_MISC_DBG("indicate_netevent "\r\n"num_ofld_sess = %d\n",\r\nhba->num_ofld_sess);\r\nhba->wait_for_link_down = 1;\r\nwait_event_interruptible(hba->shutdown_wait,\r\n(hba->num_ofld_sess == 0));\r\nBNX2FC_MISC_DBG("wakeup - num_ofld_sess = %d\n",\r\nhba->num_ofld_sess);\r\nhba->wait_for_link_down = 0;\r\nif (signal_pending(current))\r\nflush_signals(current);\r\n}\r\n}\r\nstatic int bnx2fc_libfc_config(struct fc_lport *lport)\r\n{\r\nmemcpy(&lport->tt, &bnx2fc_libfc_fcn_templ,\r\nsizeof(struct libfc_function_template));\r\nfc_elsct_init(lport);\r\nfc_exch_init(lport);\r\nfc_rport_init(lport);\r\nfc_disc_init(lport);\r\nreturn 0;\r\n}\r\nstatic int bnx2fc_em_config(struct fc_lport *lport)\r\n{\r\nif (!fc_exch_mgr_alloc(lport, FC_CLASS_3, FCOE_MIN_XID,\r\nFCOE_MAX_XID, NULL)) {\r\nprintk(KERN_ERR PFX "em_config:fc_exch_mgr_alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2fc_lport_config(struct fc_lport *lport)\r\n{\r\nlport->link_up = 0;\r\nlport->qfull = 0;\r\nlport->max_retry_count = 3;\r\nlport->max_rport_retry_count = 3;\r\nlport->e_d_tov = 2 * 1000;\r\nlport->r_a_tov = 10 * 1000;\r\nlport->service_params = (FCP_SPPF_INIT_FCN | FCP_SPPF_RD_XRDY_DIS |\r\nFCP_SPPF_RETRY | FCP_SPPF_CONF_COMPL);\r\nlport->does_npiv = 1;\r\nmemset(&lport->rnid_gen, 0, sizeof(struct fc_els_rnid_gen));\r\nlport->rnid_gen.rnid_atype = BNX2FC_RNID_HBA;\r\nif (fc_lport_init_stats(lport))\r\nreturn -ENOMEM;\r\nfc_lport_config(lport);\r\nreturn 0;\r\n}\r\nstatic int bnx2fc_fip_recv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *ptype,\r\nstruct net_device *orig_dev)\r\n{\r\nstruct bnx2fc_interface *interface;\r\ninterface = container_of(ptype, struct bnx2fc_interface,\r\nfip_packet_type);\r\nfcoe_ctlr_recv(&interface->ctlr, skb);\r\nreturn 0;\r\n}\r\nstatic void bnx2fc_update_src_mac(struct fc_lport *lport, u8 *addr)\r\n{\r\nstruct fcoe_port *port = lport_priv(lport);\r\nmemcpy(port->data_src_addr, addr, ETH_ALEN);\r\n}\r\nstatic u8 *bnx2fc_get_src_mac(struct fc_lport *lport)\r\n{\r\nstruct fcoe_port *port;\r\nport = (struct fcoe_port *)lport_priv(lport);\r\nreturn port->data_src_addr;\r\n}\r\nstatic void bnx2fc_fip_send(struct fcoe_ctlr *fip, struct sk_buff *skb)\r\n{\r\nskb->dev = bnx2fc_from_ctlr(fip)->netdev;\r\ndev_queue_xmit(skb);\r\n}\r\nstatic int bnx2fc_vport_create(struct fc_vport *vport, bool disabled)\r\n{\r\nstruct Scsi_Host *shost = vport_to_shost(vport);\r\nstruct fc_lport *n_port = shost_priv(shost);\r\nstruct fcoe_port *port = lport_priv(n_port);\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct net_device *netdev = interface->netdev;\r\nstruct fc_lport *vn_port;\r\nint rc;\r\nchar buf[32];\r\nrc = fcoe_validate_vport_create(vport);\r\nif (rc) {\r\nfcoe_wwn_to_str(vport->port_name, buf, sizeof(buf));\r\nprintk(KERN_ERR PFX "Failed to create vport, "\r\n"WWPN (0x%s) already exists\n",\r\nbuf);\r\nreturn rc;\r\n}\r\nif (!test_bit(BNX2FC_FLAG_FW_INIT_DONE, &interface->hba->flags)) {\r\nprintk(KERN_ERR PFX "vn ports cannot be created on"\r\n"this interface\n");\r\nreturn -EIO;\r\n}\r\nrtnl_lock();\r\nmutex_lock(&bnx2fc_dev_lock);\r\nvn_port = bnx2fc_if_create(interface, &vport->dev, 1);\r\nmutex_unlock(&bnx2fc_dev_lock);\r\nrtnl_unlock();\r\nif (IS_ERR(vn_port)) {\r\nprintk(KERN_ERR PFX "bnx2fc_vport_create (%s) failed\n",\r\nnetdev->name);\r\nreturn -EIO;\r\n}\r\nif (disabled) {\r\nfc_vport_set_state(vport, FC_VPORT_DISABLED);\r\n} else {\r\nvn_port->boot_time = jiffies;\r\nfc_lport_init(vn_port);\r\nfc_fabric_login(vn_port);\r\nfc_vport_setlink(vn_port);\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2fc_free_vport(struct bnx2fc_hba *hba, struct fc_lport *lport)\r\n{\r\nstruct bnx2fc_lport *blport, *tmp;\r\nspin_lock_bh(&hba->hba_lock);\r\nlist_for_each_entry_safe(blport, tmp, &hba->vports, list) {\r\nif (blport->lport == lport) {\r\nlist_del(&blport->list);\r\nkfree(blport);\r\n}\r\n}\r\nspin_unlock_bh(&hba->hba_lock);\r\n}\r\nstatic int bnx2fc_vport_destroy(struct fc_vport *vport)\r\n{\r\nstruct Scsi_Host *shost = vport_to_shost(vport);\r\nstruct fc_lport *n_port = shost_priv(shost);\r\nstruct fc_lport *vn_port = vport->dd_data;\r\nstruct fcoe_port *port = lport_priv(vn_port);\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct fc_lport *v_port;\r\nbool found = false;\r\nmutex_lock(&n_port->lp_mutex);\r\nlist_for_each_entry(v_port, &n_port->vports, list)\r\nif (v_port->vport == vport) {\r\nfound = true;\r\nbreak;\r\n}\r\nif (!found) {\r\nmutex_unlock(&n_port->lp_mutex);\r\nreturn -ENOENT;\r\n}\r\nlist_del(&vn_port->list);\r\nmutex_unlock(&n_port->lp_mutex);\r\nbnx2fc_free_vport(interface->hba, port->lport);\r\nbnx2fc_port_shutdown(port->lport);\r\nbnx2fc_interface_put(interface);\r\nqueue_work(bnx2fc_wq, &port->destroy_work);\r\nreturn 0;\r\n}\r\nstatic int bnx2fc_vport_disable(struct fc_vport *vport, bool disable)\r\n{\r\nstruct fc_lport *lport = vport->dd_data;\r\nif (disable) {\r\nfc_vport_set_state(vport, FC_VPORT_DISABLED);\r\nfc_fabric_logoff(lport);\r\n} else {\r\nlport->boot_time = jiffies;\r\nfc_fabric_login(lport);\r\nfc_vport_setlink(lport);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2fc_interface_setup(struct bnx2fc_interface *interface)\r\n{\r\nstruct net_device *netdev = interface->netdev;\r\nstruct net_device *physdev = interface->hba->phys_dev;\r\nstruct netdev_hw_addr *ha;\r\nint sel_san_mac = 0;\r\nrcu_read_lock();\r\nfor_each_dev_addr(physdev, ha) {\r\nBNX2FC_MISC_DBG("net_config: ha->type = %d, fip_mac = ",\r\nha->type);\r\nprintk(KERN_INFO "%2x:%2x:%2x:%2x:%2x:%2x\n", ha->addr[0],\r\nha->addr[1], ha->addr[2], ha->addr[3],\r\nha->addr[4], ha->addr[5]);\r\nif ((ha->type == NETDEV_HW_ADDR_T_SAN) &&\r\n(is_valid_ether_addr(ha->addr))) {\r\nmemcpy(interface->ctlr.ctl_src_addr, ha->addr,\r\nETH_ALEN);\r\nsel_san_mac = 1;\r\nBNX2FC_MISC_DBG("Found SAN MAC\n");\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (!sel_san_mac)\r\nreturn -ENODEV;\r\ninterface->fip_packet_type.func = bnx2fc_fip_recv;\r\ninterface->fip_packet_type.type = htons(ETH_P_FIP);\r\ninterface->fip_packet_type.dev = netdev;\r\ndev_add_pack(&interface->fip_packet_type);\r\ninterface->fcoe_packet_type.func = bnx2fc_rcv;\r\ninterface->fcoe_packet_type.type = __constant_htons(ETH_P_FCOE);\r\ninterface->fcoe_packet_type.dev = netdev;\r\ndev_add_pack(&interface->fcoe_packet_type);\r\nreturn 0;\r\n}\r\nstatic int bnx2fc_attach_transport(void)\r\n{\r\nbnx2fc_transport_template =\r\nfc_attach_transport(&bnx2fc_transport_function);\r\nif (bnx2fc_transport_template == NULL) {\r\nprintk(KERN_ERR PFX "Failed to attach FC transport\n");\r\nreturn -ENODEV;\r\n}\r\nbnx2fc_vport_xport_template =\r\nfc_attach_transport(&bnx2fc_vport_xport_function);\r\nif (bnx2fc_vport_xport_template == NULL) {\r\nprintk(KERN_ERR PFX\r\n"Failed to attach FC transport for vport\n");\r\nfc_release_transport(bnx2fc_transport_template);\r\nbnx2fc_transport_template = NULL;\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2fc_release_transport(void)\r\n{\r\nfc_release_transport(bnx2fc_transport_template);\r\nfc_release_transport(bnx2fc_vport_xport_template);\r\nbnx2fc_transport_template = NULL;\r\nbnx2fc_vport_xport_template = NULL;\r\n}\r\nstatic void bnx2fc_interface_release(struct kref *kref)\r\n{\r\nstruct bnx2fc_interface *interface;\r\nstruct net_device *netdev;\r\ninterface = container_of(kref, struct bnx2fc_interface, kref);\r\nBNX2FC_MISC_DBG("Interface is being released\n");\r\nnetdev = interface->netdev;\r\nif (test_and_clear_bit(BNX2FC_CTLR_INIT_DONE, &interface->if_flags))\r\nfcoe_ctlr_destroy(&interface->ctlr);\r\nkfree(interface);\r\ndev_put(netdev);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic inline void bnx2fc_interface_get(struct bnx2fc_interface *interface)\r\n{\r\nkref_get(&interface->kref);\r\n}\r\nstatic inline void bnx2fc_interface_put(struct bnx2fc_interface *interface)\r\n{\r\nkref_put(&interface->kref, bnx2fc_interface_release);\r\n}\r\nstatic void bnx2fc_hba_destroy(struct bnx2fc_hba *hba)\r\n{\r\nif (hba->cmd_mgr) {\r\nbnx2fc_cmd_mgr_free(hba->cmd_mgr);\r\nhba->cmd_mgr = NULL;\r\n}\r\nkfree(hba->tgt_ofld_list);\r\nbnx2fc_unbind_pcidev(hba);\r\nkfree(hba);\r\n}\r\nstatic struct bnx2fc_hba *bnx2fc_hba_create(struct cnic_dev *cnic)\r\n{\r\nstruct bnx2fc_hba *hba;\r\nint rc;\r\nhba = kzalloc(sizeof(*hba), GFP_KERNEL);\r\nif (!hba) {\r\nprintk(KERN_ERR PFX "Unable to allocate hba structure\n");\r\nreturn NULL;\r\n}\r\nspin_lock_init(&hba->hba_lock);\r\nmutex_init(&hba->hba_mutex);\r\nhba->cnic = cnic;\r\nrc = bnx2fc_bind_pcidev(hba);\r\nif (rc) {\r\nprintk(KERN_ERR PFX "create_adapter: bind error\n");\r\ngoto bind_err;\r\n}\r\nhba->phys_dev = cnic->netdev;\r\nhba->next_conn_id = 0;\r\nhba->tgt_ofld_list =\r\nkzalloc(sizeof(struct bnx2fc_rport *) * BNX2FC_NUM_MAX_SESS,\r\nGFP_KERNEL);\r\nif (!hba->tgt_ofld_list) {\r\nprintk(KERN_ERR PFX "Unable to allocate tgt offload list\n");\r\ngoto tgtofld_err;\r\n}\r\nhba->num_ofld_sess = 0;\r\nhba->cmd_mgr = bnx2fc_cmd_mgr_alloc(hba, BNX2FC_MIN_XID,\r\nBNX2FC_MAX_XID);\r\nif (!hba->cmd_mgr) {\r\nprintk(KERN_ERR PFX "em_config:bnx2fc_cmd_mgr_alloc failed\n");\r\ngoto cmgr_err;\r\n}\r\ninit_waitqueue_head(&hba->shutdown_wait);\r\ninit_waitqueue_head(&hba->destroy_wait);\r\nINIT_LIST_HEAD(&hba->vports);\r\nreturn hba;\r\ncmgr_err:\r\nkfree(hba->tgt_ofld_list);\r\ntgtofld_err:\r\nbnx2fc_unbind_pcidev(hba);\r\nbind_err:\r\nkfree(hba);\r\nreturn NULL;\r\n}\r\nstruct bnx2fc_interface *bnx2fc_interface_create(struct bnx2fc_hba *hba,\r\nstruct net_device *netdev,\r\nenum fip_state fip_mode)\r\n{\r\nstruct bnx2fc_interface *interface;\r\nint rc = 0;\r\ninterface = kzalloc(sizeof(*interface), GFP_KERNEL);\r\nif (!interface) {\r\nprintk(KERN_ERR PFX "Unable to allocate interface structure\n");\r\nreturn NULL;\r\n}\r\ndev_hold(netdev);\r\nkref_init(&interface->kref);\r\ninterface->hba = hba;\r\ninterface->netdev = netdev;\r\nfcoe_ctlr_init(&interface->ctlr, fip_mode);\r\ninterface->ctlr.send = bnx2fc_fip_send;\r\ninterface->ctlr.update_mac = bnx2fc_update_src_mac;\r\ninterface->ctlr.get_src_addr = bnx2fc_get_src_mac;\r\nset_bit(BNX2FC_CTLR_INIT_DONE, &interface->if_flags);\r\nrc = bnx2fc_interface_setup(interface);\r\nif (!rc)\r\nreturn interface;\r\nfcoe_ctlr_destroy(&interface->ctlr);\r\ndev_put(netdev);\r\nkfree(interface);\r\nreturn NULL;\r\n}\r\nstatic struct fc_lport *bnx2fc_if_create(struct bnx2fc_interface *interface,\r\nstruct device *parent, int npiv)\r\n{\r\nstruct fc_lport *lport, *n_port;\r\nstruct fcoe_port *port;\r\nstruct Scsi_Host *shost;\r\nstruct fc_vport *vport = dev_to_vport(parent);\r\nstruct bnx2fc_lport *blport;\r\nstruct bnx2fc_hba *hba;\r\nint rc = 0;\r\nblport = kzalloc(sizeof(struct bnx2fc_lport), GFP_KERNEL);\r\nif (!blport) {\r\nBNX2FC_HBA_DBG(interface->ctlr.lp, "Unable to alloc blport\n");\r\nreturn NULL;\r\n}\r\nif (!npiv)\r\nlport = libfc_host_alloc(&bnx2fc_shost_template, sizeof(*port));\r\nelse\r\nlport = libfc_vport_create(vport, sizeof(*port));\r\nif (!lport) {\r\nprintk(KERN_ERR PFX "could not allocate scsi host structure\n");\r\ngoto free_blport;\r\n}\r\nshost = lport->host;\r\nport = lport_priv(lport);\r\nport->lport = lport;\r\nport->priv = interface;\r\nINIT_WORK(&port->destroy_work, bnx2fc_destroy_work);\r\nrc = bnx2fc_lport_config(lport);\r\nif (rc)\r\ngoto lp_config_err;\r\nif (npiv) {\r\nprintk(KERN_ERR PFX "Setting vport names, 0x%llX 0x%llX\n",\r\nvport->node_name, vport->port_name);\r\nfc_set_wwnn(lport, vport->node_name);\r\nfc_set_wwpn(lport, vport->port_name);\r\n}\r\nrc = bnx2fc_net_config(lport, interface->netdev);\r\nif (rc) {\r\nprintk(KERN_ERR PFX "Error on bnx2fc_net_config\n");\r\ngoto lp_config_err;\r\n}\r\nrc = bnx2fc_shost_config(lport, parent);\r\nif (rc) {\r\nprintk(KERN_ERR PFX "Couldnt configure shost for %s\n",\r\ninterface->netdev->name);\r\ngoto lp_config_err;\r\n}\r\nrc = bnx2fc_libfc_config(lport);\r\nif (rc) {\r\nprintk(KERN_ERR PFX "Couldnt configure libfc\n");\r\ngoto shost_err;\r\n}\r\nfc_host_port_type(lport->host) = FC_PORTTYPE_UNKNOWN;\r\nif (!npiv)\r\nrc = bnx2fc_em_config(lport);\r\nelse {\r\nshost = vport_to_shost(vport);\r\nn_port = shost_priv(shost);\r\nrc = fc_exch_mgr_list_clone(n_port, lport);\r\n}\r\nif (rc) {\r\nprintk(KERN_ERR PFX "Error on bnx2fc_em_config\n");\r\ngoto shost_err;\r\n}\r\nbnx2fc_interface_get(interface);\r\nhba = interface->hba;\r\nspin_lock_bh(&hba->hba_lock);\r\nblport->lport = lport;\r\nlist_add_tail(&blport->list, &hba->vports);\r\nspin_unlock_bh(&hba->hba_lock);\r\nreturn lport;\r\nshost_err:\r\nscsi_remove_host(shost);\r\nlp_config_err:\r\nscsi_host_put(lport->host);\r\nfree_blport:\r\nkfree(blport);\r\nreturn NULL;\r\n}\r\nstatic void bnx2fc_net_cleanup(struct bnx2fc_interface *interface)\r\n{\r\n__dev_remove_pack(&interface->fcoe_packet_type);\r\n__dev_remove_pack(&interface->fip_packet_type);\r\nsynchronize_net();\r\n}\r\nstatic void bnx2fc_interface_cleanup(struct bnx2fc_interface *interface)\r\n{\r\nstruct fc_lport *lport = interface->ctlr.lp;\r\nstruct fcoe_port *port = lport_priv(lport);\r\nstruct bnx2fc_hba *hba = interface->hba;\r\ndel_timer_sync(&port->timer);\r\nfcoe_clean_pending_queue(lport);\r\nbnx2fc_net_cleanup(interface);\r\nbnx2fc_free_vport(hba, lport);\r\n}\r\nstatic void bnx2fc_if_destroy(struct fc_lport *lport)\r\n{\r\nbnx2fc_clean_rx_queue(lport);\r\nfc_remove_host(lport->host);\r\nscsi_remove_host(lport->host);\r\nfc_exch_mgr_free(lport);\r\nfc_lport_free_stats(lport);\r\nscsi_host_put(lport->host);\r\n}\r\nstatic void __bnx2fc_destroy(struct bnx2fc_interface *interface)\r\n{\r\nstruct fc_lport *lport = interface->ctlr.lp;\r\nstruct fcoe_port *port = lport_priv(lport);\r\nbnx2fc_interface_cleanup(interface);\r\nbnx2fc_stop(interface);\r\nlist_del(&interface->list);\r\nbnx2fc_interface_put(interface);\r\nqueue_work(bnx2fc_wq, &port->destroy_work);\r\n}\r\nstatic int bnx2fc_destroy(struct net_device *netdev)\r\n{\r\nstruct bnx2fc_interface *interface = NULL;\r\nint rc = 0;\r\nrtnl_lock();\r\nmutex_lock(&bnx2fc_dev_lock);\r\ninterface = bnx2fc_interface_lookup(netdev);\r\nif (!interface || !interface->ctlr.lp) {\r\nrc = -ENODEV;\r\nprintk(KERN_ERR PFX "bnx2fc_destroy: interface or lport not found\n");\r\ngoto netdev_err;\r\n}\r\ndestroy_workqueue(interface->timer_work_queue);\r\n__bnx2fc_destroy(interface);\r\nnetdev_err:\r\nmutex_unlock(&bnx2fc_dev_lock);\r\nrtnl_unlock();\r\nreturn rc;\r\n}\r\nstatic void bnx2fc_destroy_work(struct work_struct *work)\r\n{\r\nstruct fcoe_port *port;\r\nstruct fc_lport *lport;\r\nport = container_of(work, struct fcoe_port, destroy_work);\r\nlport = port->lport;\r\nBNX2FC_HBA_DBG(lport, "Entered bnx2fc_destroy_work\n");\r\nbnx2fc_if_destroy(lport);\r\n}\r\nstatic void bnx2fc_unbind_adapter_devices(struct bnx2fc_hba *hba)\r\n{\r\nbnx2fc_free_fw_resc(hba);\r\nbnx2fc_free_task_ctx(hba);\r\n}\r\nstatic int bnx2fc_bind_adapter_devices(struct bnx2fc_hba *hba)\r\n{\r\nif (bnx2fc_setup_task_ctx(hba))\r\ngoto mem_err;\r\nif (bnx2fc_setup_fw_resc(hba))\r\ngoto mem_err;\r\nreturn 0;\r\nmem_err:\r\nbnx2fc_unbind_adapter_devices(hba);\r\nreturn -ENOMEM;\r\n}\r\nstatic int bnx2fc_bind_pcidev(struct bnx2fc_hba *hba)\r\n{\r\nstruct cnic_dev *cnic;\r\nif (!hba->cnic) {\r\nprintk(KERN_ERR PFX "cnic is NULL\n");\r\nreturn -ENODEV;\r\n}\r\ncnic = hba->cnic;\r\nhba->pcidev = cnic->pcidev;\r\nif (hba->pcidev)\r\npci_dev_get(hba->pcidev);\r\nreturn 0;\r\n}\r\nstatic void bnx2fc_unbind_pcidev(struct bnx2fc_hba *hba)\r\n{\r\nif (hba->pcidev)\r\npci_dev_put(hba->pcidev);\r\nhba->pcidev = NULL;\r\n}\r\nstatic void bnx2fc_ulp_start(void *handle)\r\n{\r\nstruct bnx2fc_hba *hba = handle;\r\nstruct bnx2fc_interface *interface;\r\nstruct fc_lport *lport;\r\nmutex_lock(&bnx2fc_dev_lock);\r\nif (!test_bit(BNX2FC_FLAG_FW_INIT_DONE, &hba->flags))\r\nbnx2fc_fw_init(hba);\r\nBNX2FC_MISC_DBG("bnx2fc started.\n");\r\nlist_for_each_entry(interface, &if_list, list) {\r\nif (interface->hba == hba) {\r\nlport = interface->ctlr.lp;\r\nprintk(KERN_ERR PFX "ulp_init: start discovery\n");\r\nlport->tt.frame_send = bnx2fc_xmit;\r\nbnx2fc_start_disc(interface);\r\n}\r\n}\r\nmutex_unlock(&bnx2fc_dev_lock);\r\n}\r\nstatic void bnx2fc_port_shutdown(struct fc_lport *lport)\r\n{\r\nBNX2FC_MISC_DBG("Entered %s\n", __func__);\r\nfc_fabric_logoff(lport);\r\nfc_lport_destroy(lport);\r\n}\r\nstatic void bnx2fc_stop(struct bnx2fc_interface *interface)\r\n{\r\nstruct fc_lport *lport;\r\nstruct fc_lport *vport;\r\nif (!test_bit(BNX2FC_FLAG_FW_INIT_DONE, &interface->hba->flags))\r\nreturn;\r\nlport = interface->ctlr.lp;\r\nbnx2fc_port_shutdown(lport);\r\nmutex_lock(&lport->lp_mutex);\r\nlist_for_each_entry(vport, &lport->vports, list)\r\nfc_host_port_type(vport->host) =\r\nFC_PORTTYPE_UNKNOWN;\r\nmutex_unlock(&lport->lp_mutex);\r\nfc_host_port_type(lport->host) = FC_PORTTYPE_UNKNOWN;\r\nfcoe_ctlr_link_down(&interface->ctlr);\r\nfcoe_clean_pending_queue(lport);\r\n}\r\nstatic int bnx2fc_fw_init(struct bnx2fc_hba *hba)\r\n{\r\n#define BNX2FC_INIT_POLL_TIME (1000 / HZ)\r\nint rc = -1;\r\nint i = HZ;\r\nrc = bnx2fc_bind_adapter_devices(hba);\r\nif (rc) {\r\nprintk(KERN_ALERT PFX\r\n"bnx2fc_bind_adapter_devices failed - rc = %d\n", rc);\r\ngoto err_out;\r\n}\r\nrc = bnx2fc_send_fw_fcoe_init_msg(hba);\r\nif (rc) {\r\nprintk(KERN_ALERT PFX\r\n"bnx2fc_send_fw_fcoe_init_msg failed - rc = %d\n", rc);\r\ngoto err_unbind;\r\n}\r\nwhile (!test_bit(ADAPTER_STATE_UP, &hba->adapter_state) && i--)\r\nmsleep(BNX2FC_INIT_POLL_TIME);\r\nif (!test_bit(ADAPTER_STATE_UP, &hba->adapter_state)) {\r\nprintk(KERN_ERR PFX "bnx2fc_start: %s failed to initialize. "\r\n"Ignoring...\n",\r\nhba->cnic->netdev->name);\r\nrc = -1;\r\ngoto err_unbind;\r\n}\r\nset_bit(BNX2FC_FLAG_FW_INIT_DONE, &hba->flags);\r\nreturn 0;\r\nerr_unbind:\r\nbnx2fc_unbind_adapter_devices(hba);\r\nerr_out:\r\nreturn rc;\r\n}\r\nstatic void bnx2fc_fw_destroy(struct bnx2fc_hba *hba)\r\n{\r\nif (test_and_clear_bit(BNX2FC_FLAG_FW_INIT_DONE, &hba->flags)) {\r\nif (bnx2fc_send_fw_fcoe_destroy_msg(hba) == 0) {\r\ninit_timer(&hba->destroy_timer);\r\nhba->destroy_timer.expires = BNX2FC_FW_TIMEOUT +\r\njiffies;\r\nhba->destroy_timer.function = bnx2fc_destroy_timer;\r\nhba->destroy_timer.data = (unsigned long)hba;\r\nadd_timer(&hba->destroy_timer);\r\nwait_event_interruptible(hba->destroy_wait,\r\ntest_bit(BNX2FC_FLAG_DESTROY_CMPL,\r\n&hba->flags));\r\nclear_bit(BNX2FC_FLAG_DESTROY_CMPL, &hba->flags);\r\nif (signal_pending(current))\r\nflush_signals(current);\r\ndel_timer_sync(&hba->destroy_timer);\r\n}\r\nbnx2fc_unbind_adapter_devices(hba);\r\n}\r\n}\r\nstatic void bnx2fc_ulp_stop(void *handle)\r\n{\r\nstruct bnx2fc_hba *hba = handle;\r\nstruct bnx2fc_interface *interface;\r\nprintk(KERN_ERR "ULP_STOP\n");\r\nmutex_lock(&bnx2fc_dev_lock);\r\nif (!test_bit(BNX2FC_FLAG_FW_INIT_DONE, &hba->flags))\r\ngoto exit;\r\nlist_for_each_entry(interface, &if_list, list) {\r\nif (interface->hba == hba)\r\nbnx2fc_stop(interface);\r\n}\r\nBUG_ON(hba->num_ofld_sess != 0);\r\nmutex_lock(&hba->hba_mutex);\r\nclear_bit(ADAPTER_STATE_UP, &hba->adapter_state);\r\nclear_bit(ADAPTER_STATE_GOING_DOWN,\r\n&hba->adapter_state);\r\nclear_bit(ADAPTER_STATE_READY, &hba->adapter_state);\r\nmutex_unlock(&hba->hba_mutex);\r\nbnx2fc_fw_destroy(hba);\r\nexit:\r\nmutex_unlock(&bnx2fc_dev_lock);\r\n}\r\nstatic void bnx2fc_start_disc(struct bnx2fc_interface *interface)\r\n{\r\nstruct fc_lport *lport;\r\nint wait_cnt = 0;\r\nBNX2FC_MISC_DBG("Entered %s\n", __func__);\r\nif (!test_bit(BNX2FC_FLAG_FW_INIT_DONE, &interface->hba->flags)) {\r\nprintk(KERN_ERR PFX "Init not done yet\n");\r\nreturn;\r\n}\r\nlport = interface->ctlr.lp;\r\nBNX2FC_HBA_DBG(lport, "calling fc_fabric_login\n");\r\nif (!bnx2fc_link_ok(lport) && interface->enabled) {\r\nBNX2FC_HBA_DBG(lport, "ctlr_link_up\n");\r\nfcoe_ctlr_link_up(&interface->ctlr);\r\nfc_host_port_type(lport->host) = FC_PORTTYPE_NPORT;\r\nset_bit(ADAPTER_STATE_READY, &interface->hba->adapter_state);\r\n}\r\nwhile (!interface->ctlr.sel_fcf) {\r\nmsleep(250);\r\nif (++wait_cnt > 12)\r\nbreak;\r\n}\r\nif (fc_set_mfs(lport, BNX2FC_MFS))\r\nreturn;\r\nfc_lport_init(lport);\r\nfc_fabric_login(lport);\r\n}\r\nstatic void bnx2fc_ulp_init(struct cnic_dev *dev)\r\n{\r\nstruct bnx2fc_hba *hba;\r\nint rc = 0;\r\nBNX2FC_MISC_DBG("Entered %s\n", __func__);\r\nif (!test_bit(CNIC_F_BNX2X_CLASS, &dev->flags) ||\r\n(dev->max_fcoe_conn == 0)) {\r\nprintk(KERN_ERR PFX "bnx2fc FCoE not supported on %s,"\r\n" flags: %lx fcoe_conn: %d\n",\r\ndev->netdev->name, dev->flags, dev->max_fcoe_conn);\r\nreturn;\r\n}\r\nhba = bnx2fc_hba_create(dev);\r\nif (!hba) {\r\nprintk(KERN_ERR PFX "hba initialization failed\n");\r\nreturn;\r\n}\r\nmutex_lock(&bnx2fc_dev_lock);\r\nlist_add_tail(&hba->list, &adapter_list);\r\nadapter_count++;\r\nmutex_unlock(&bnx2fc_dev_lock);\r\nclear_bit(BNX2FC_CNIC_REGISTERED, &hba->reg_with_cnic);\r\nrc = dev->register_device(dev, CNIC_ULP_FCOE,\r\n(void *) hba);\r\nif (rc)\r\nprintk(KERN_ERR PFX "register_device failed, rc = %d\n", rc);\r\nelse\r\nset_bit(BNX2FC_CNIC_REGISTERED, &hba->reg_with_cnic);\r\n}\r\nstatic int bnx2fc_disable(struct net_device *netdev)\r\n{\r\nstruct bnx2fc_interface *interface;\r\nint rc = 0;\r\nrtnl_lock();\r\nmutex_lock(&bnx2fc_dev_lock);\r\ninterface = bnx2fc_interface_lookup(netdev);\r\nif (!interface || !interface->ctlr.lp) {\r\nrc = -ENODEV;\r\nprintk(KERN_ERR PFX "bnx2fc_disable: interface or lport not found\n");\r\n} else {\r\ninterface->enabled = false;\r\nfcoe_ctlr_link_down(&interface->ctlr);\r\nfcoe_clean_pending_queue(interface->ctlr.lp);\r\n}\r\nmutex_unlock(&bnx2fc_dev_lock);\r\nrtnl_unlock();\r\nreturn rc;\r\n}\r\nstatic int bnx2fc_enable(struct net_device *netdev)\r\n{\r\nstruct bnx2fc_interface *interface;\r\nint rc = 0;\r\nrtnl_lock();\r\nmutex_lock(&bnx2fc_dev_lock);\r\ninterface = bnx2fc_interface_lookup(netdev);\r\nif (!interface || !interface->ctlr.lp) {\r\nrc = -ENODEV;\r\nprintk(KERN_ERR PFX "bnx2fc_enable: interface or lport not found\n");\r\n} else if (!bnx2fc_link_ok(interface->ctlr.lp)) {\r\nfcoe_ctlr_link_up(&interface->ctlr);\r\ninterface->enabled = true;\r\n}\r\nmutex_unlock(&bnx2fc_dev_lock);\r\nrtnl_unlock();\r\nreturn rc;\r\n}\r\nstatic int bnx2fc_create(struct net_device *netdev, enum fip_state fip_mode)\r\n{\r\nstruct bnx2fc_interface *interface;\r\nstruct bnx2fc_hba *hba;\r\nstruct net_device *phys_dev;\r\nstruct fc_lport *lport;\r\nstruct ethtool_drvinfo drvinfo;\r\nint rc = 0;\r\nint vlan_id;\r\nBNX2FC_MISC_DBG("Entered bnx2fc_create\n");\r\nif (fip_mode != FIP_MODE_FABRIC) {\r\nprintk(KERN_ERR "fip mode not FABRIC\n");\r\nreturn -EIO;\r\n}\r\nrtnl_lock();\r\nmutex_lock(&bnx2fc_dev_lock);\r\nif (!try_module_get(THIS_MODULE)) {\r\nrc = -EINVAL;\r\ngoto mod_err;\r\n}\r\nif (netdev->priv_flags & IFF_802_1Q_VLAN) {\r\nphys_dev = vlan_dev_real_dev(netdev);\r\nvlan_id = vlan_dev_vlan_id(netdev);\r\n} else {\r\nprintk(KERN_ERR PFX "Not a vlan device\n");\r\nrc = -EINVAL;\r\ngoto netdev_err;\r\n}\r\nif (phys_dev->ethtool_ops && phys_dev->ethtool_ops->get_drvinfo) {\r\nmemset(&drvinfo, 0, sizeof(drvinfo));\r\nphys_dev->ethtool_ops->get_drvinfo(phys_dev, &drvinfo);\r\nif (strncmp(drvinfo.driver, "bnx2x", strlen("bnx2x"))) {\r\nprintk(KERN_ERR PFX "Not a netxtreme2 device\n");\r\nrc = -EINVAL;\r\ngoto netdev_err;\r\n}\r\n} else {\r\nprintk(KERN_ERR PFX "unable to obtain drv_info\n");\r\nrc = -EINVAL;\r\ngoto netdev_err;\r\n}\r\nhba = bnx2fc_hba_lookup(phys_dev);\r\nif (!hba) {\r\nrc = -ENODEV;\r\nprintk(KERN_ERR PFX "bnx2fc_create: hba not found\n");\r\ngoto netdev_err;\r\n}\r\nif (bnx2fc_interface_lookup(netdev)) {\r\nrc = -EEXIST;\r\ngoto netdev_err;\r\n}\r\ninterface = bnx2fc_interface_create(hba, netdev, fip_mode);\r\nif (!interface) {\r\nprintk(KERN_ERR PFX "bnx2fc_interface_create failed\n");\r\ngoto ifput_err;\r\n}\r\ninterface->vlan_id = vlan_id;\r\ninterface->vlan_enabled = 1;\r\ninterface->timer_work_queue =\r\ncreate_singlethread_workqueue("bnx2fc_timer_wq");\r\nif (!interface->timer_work_queue) {\r\nprintk(KERN_ERR PFX "ulp_init could not create timer_wq\n");\r\nrc = -EINVAL;\r\ngoto ifput_err;\r\n}\r\nlport = bnx2fc_if_create(interface, &interface->hba->pcidev->dev, 0);\r\nif (!lport) {\r\nprintk(KERN_ERR PFX "Failed to create interface (%s)\n",\r\nnetdev->name);\r\nrc = -EINVAL;\r\ngoto if_create_err;\r\n}\r\nlist_add_tail(&interface->list, &if_list);\r\nlport->boot_time = jiffies;\r\ninterface->ctlr.lp = lport;\r\nif (!bnx2fc_link_ok(lport)) {\r\nfcoe_ctlr_link_up(&interface->ctlr);\r\nfc_host_port_type(lport->host) = FC_PORTTYPE_NPORT;\r\nset_bit(ADAPTER_STATE_READY, &interface->hba->adapter_state);\r\n}\r\nBNX2FC_HBA_DBG(lport, "create: START DISC\n");\r\nbnx2fc_start_disc(interface);\r\ninterface->enabled = true;\r\nbnx2fc_interface_put(interface);\r\nmutex_unlock(&bnx2fc_dev_lock);\r\nrtnl_unlock();\r\nreturn 0;\r\nif_create_err:\r\ndestroy_workqueue(interface->timer_work_queue);\r\nifput_err:\r\nbnx2fc_net_cleanup(interface);\r\nbnx2fc_interface_put(interface);\r\nnetdev_err:\r\nmodule_put(THIS_MODULE);\r\nmod_err:\r\nmutex_unlock(&bnx2fc_dev_lock);\r\nrtnl_unlock();\r\nreturn rc;\r\n}\r\nstatic struct bnx2fc_hba *bnx2fc_find_hba_for_cnic(struct cnic_dev *cnic)\r\n{\r\nstruct list_head *list;\r\nstruct list_head *temp;\r\nstruct bnx2fc_hba *hba;\r\nlist_for_each_safe(list, temp, &adapter_list) {\r\nhba = (struct bnx2fc_hba *)list;\r\nif (hba->cnic == cnic)\r\nreturn hba;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct bnx2fc_interface *bnx2fc_interface_lookup(struct net_device\r\n*netdev)\r\n{\r\nstruct bnx2fc_interface *interface;\r\nlist_for_each_entry(interface, &if_list, list) {\r\nif (interface->netdev == netdev)\r\nreturn interface;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct bnx2fc_hba *bnx2fc_hba_lookup(struct net_device\r\n*phys_dev)\r\n{\r\nstruct bnx2fc_hba *hba;\r\nlist_for_each_entry(hba, &adapter_list, list) {\r\nif (hba->phys_dev == phys_dev)\r\nreturn hba;\r\n}\r\nprintk(KERN_ERR PFX "adapter_lookup: hba NULL\n");\r\nreturn NULL;\r\n}\r\nstatic void bnx2fc_ulp_exit(struct cnic_dev *dev)\r\n{\r\nstruct bnx2fc_hba *hba;\r\nstruct bnx2fc_interface *interface, *tmp;\r\nBNX2FC_MISC_DBG("Entered bnx2fc_ulp_exit\n");\r\nif (!test_bit(CNIC_F_BNX2X_CLASS, &dev->flags)) {\r\nprintk(KERN_ERR PFX "bnx2fc port check: %s, flags: %lx\n",\r\ndev->netdev->name, dev->flags);\r\nreturn;\r\n}\r\nmutex_lock(&bnx2fc_dev_lock);\r\nhba = bnx2fc_find_hba_for_cnic(dev);\r\nif (!hba) {\r\nprintk(KERN_ERR PFX "bnx2fc_ulp_exit: hba not found, dev 0%p\n",\r\ndev);\r\nmutex_unlock(&bnx2fc_dev_lock);\r\nreturn;\r\n}\r\nlist_del_init(&hba->list);\r\nadapter_count--;\r\nlist_for_each_entry_safe(interface, tmp, &if_list, list)\r\nif (interface->hba == hba)\r\n__bnx2fc_destroy(interface);\r\nmutex_unlock(&bnx2fc_dev_lock);\r\nbnx2fc_ulp_stop(hba);\r\nif (test_and_clear_bit(BNX2FC_CNIC_REGISTERED, &hba->reg_with_cnic))\r\nhba->cnic->unregister_device(hba->cnic, CNIC_ULP_FCOE);\r\nbnx2fc_hba_destroy(hba);\r\n}\r\nstatic int bnx2fc_fcoe_reset(struct Scsi_Host *shost)\r\n{\r\nstruct fc_lport *lport = shost_priv(shost);\r\nfc_lport_reset(lport);\r\nreturn 0;\r\n}\r\nstatic bool bnx2fc_match(struct net_device *netdev)\r\n{\r\nmutex_lock(&bnx2fc_dev_lock);\r\nif (netdev->priv_flags & IFF_802_1Q_VLAN) {\r\nstruct net_device *phys_dev = vlan_dev_real_dev(netdev);\r\nif (bnx2fc_hba_lookup(phys_dev)) {\r\nmutex_unlock(&bnx2fc_dev_lock);\r\nreturn true;\r\n}\r\n}\r\nmutex_unlock(&bnx2fc_dev_lock);\r\nreturn false;\r\n}\r\nstatic void bnx2fc_percpu_thread_create(unsigned int cpu)\r\n{\r\nstruct bnx2fc_percpu_s *p;\r\nstruct task_struct *thread;\r\np = &per_cpu(bnx2fc_percpu, cpu);\r\nthread = kthread_create(bnx2fc_percpu_io_thread,\r\n(void *)p,\r\n"bnx2fc_thread/%d", cpu);\r\nif (likely(!IS_ERR(thread))) {\r\nkthread_bind(thread, cpu);\r\np->iothread = thread;\r\nwake_up_process(thread);\r\n}\r\n}\r\nstatic void bnx2fc_percpu_thread_destroy(unsigned int cpu)\r\n{\r\nstruct bnx2fc_percpu_s *p;\r\nstruct task_struct *thread;\r\nstruct bnx2fc_work *work, *tmp;\r\nBNX2FC_MISC_DBG("destroying io thread for CPU %d\n", cpu);\r\np = &per_cpu(bnx2fc_percpu, cpu);\r\nspin_lock_bh(&p->fp_work_lock);\r\nthread = p->iothread;\r\np->iothread = NULL;\r\nlist_for_each_entry_safe(work, tmp, &p->work_list, list) {\r\nlist_del_init(&work->list);\r\nbnx2fc_process_cq_compl(work->tgt, work->wqe);\r\nkfree(work);\r\n}\r\nspin_unlock_bh(&p->fp_work_lock);\r\nif (thread)\r\nkthread_stop(thread);\r\n}\r\nstatic int bnx2fc_cpu_callback(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned cpu = (unsigned long)hcpu;\r\nswitch (action) {\r\ncase CPU_ONLINE:\r\ncase CPU_ONLINE_FROZEN:\r\nprintk(PFX "CPU %x online: Create Rx thread\n", cpu);\r\nbnx2fc_percpu_thread_create(cpu);\r\nbreak;\r\ncase CPU_DEAD:\r\ncase CPU_DEAD_FROZEN:\r\nprintk(PFX "CPU %x offline: Remove Rx thread\n", cpu);\r\nbnx2fc_percpu_thread_destroy(cpu);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init bnx2fc_mod_init(void)\r\n{\r\nstruct fcoe_percpu_s *bg;\r\nstruct task_struct *l2_thread;\r\nint rc = 0;\r\nunsigned int cpu = 0;\r\nstruct bnx2fc_percpu_s *p;\r\nprintk(KERN_INFO PFX "%s", version);\r\nrc = fcoe_transport_attach(&bnx2fc_transport);\r\nif (rc) {\r\nprintk(KERN_ERR "failed to register an fcoe transport, check "\r\n"if libfcoe is loaded\n");\r\ngoto out;\r\n}\r\nINIT_LIST_HEAD(&adapter_list);\r\nINIT_LIST_HEAD(&if_list);\r\nmutex_init(&bnx2fc_dev_lock);\r\nadapter_count = 0;\r\nrc = bnx2fc_attach_transport();\r\nif (rc)\r\ngoto detach_ft;\r\nbnx2fc_wq = alloc_workqueue("bnx2fc", 0, 0);\r\nif (!bnx2fc_wq) {\r\nrc = -ENOMEM;\r\ngoto release_bt;\r\n}\r\nbg = &bnx2fc_global;\r\nskb_queue_head_init(&bg->fcoe_rx_list);\r\nl2_thread = kthread_create(bnx2fc_l2_rcv_thread,\r\n(void *)bg,\r\n"bnx2fc_l2_thread");\r\nif (IS_ERR(l2_thread)) {\r\nrc = PTR_ERR(l2_thread);\r\ngoto free_wq;\r\n}\r\nwake_up_process(l2_thread);\r\nspin_lock_bh(&bg->fcoe_rx_list.lock);\r\nbg->thread = l2_thread;\r\nspin_unlock_bh(&bg->fcoe_rx_list.lock);\r\nfor_each_possible_cpu(cpu) {\r\np = &per_cpu(bnx2fc_percpu, cpu);\r\nINIT_LIST_HEAD(&p->work_list);\r\nspin_lock_init(&p->fp_work_lock);\r\n}\r\nfor_each_online_cpu(cpu) {\r\nbnx2fc_percpu_thread_create(cpu);\r\n}\r\nregister_hotcpu_notifier(&bnx2fc_cpu_notifier);\r\ncnic_register_driver(CNIC_ULP_FCOE, &bnx2fc_cnic_cb);\r\nreturn 0;\r\nfree_wq:\r\ndestroy_workqueue(bnx2fc_wq);\r\nrelease_bt:\r\nbnx2fc_release_transport();\r\ndetach_ft:\r\nfcoe_transport_detach(&bnx2fc_transport);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __exit bnx2fc_mod_exit(void)\r\n{\r\nLIST_HEAD(to_be_deleted);\r\nstruct bnx2fc_hba *hba, *next;\r\nstruct fcoe_percpu_s *bg;\r\nstruct task_struct *l2_thread;\r\nstruct sk_buff *skb;\r\nunsigned int cpu = 0;\r\nmutex_lock(&bnx2fc_dev_lock);\r\nlist_splice(&adapter_list, &to_be_deleted);\r\nINIT_LIST_HEAD(&adapter_list);\r\nadapter_count = 0;\r\nmutex_unlock(&bnx2fc_dev_lock);\r\nlist_for_each_entry_safe(hba, next, &to_be_deleted, list) {\r\nlist_del_init(&hba->list);\r\nprintk(KERN_ERR PFX "MOD_EXIT:destroy hba = 0x%p\n",\r\nhba);\r\nbnx2fc_ulp_stop(hba);\r\nif (test_and_clear_bit(BNX2FC_CNIC_REGISTERED,\r\n&hba->reg_with_cnic))\r\nhba->cnic->unregister_device(hba->cnic,\r\nCNIC_ULP_FCOE);\r\nbnx2fc_hba_destroy(hba);\r\n}\r\ncnic_unregister_driver(CNIC_ULP_FCOE);\r\nbg = &bnx2fc_global;\r\nspin_lock_bh(&bg->fcoe_rx_list.lock);\r\nl2_thread = bg->thread;\r\nbg->thread = NULL;\r\nwhile ((skb = __skb_dequeue(&bg->fcoe_rx_list)) != NULL)\r\nkfree_skb(skb);\r\nspin_unlock_bh(&bg->fcoe_rx_list.lock);\r\nif (l2_thread)\r\nkthread_stop(l2_thread);\r\nunregister_hotcpu_notifier(&bnx2fc_cpu_notifier);\r\nfor_each_online_cpu(cpu) {\r\nbnx2fc_percpu_thread_destroy(cpu);\r\n}\r\ndestroy_workqueue(bnx2fc_wq);\r\nbnx2fc_release_transport();\r\nfcoe_transport_detach(&bnx2fc_transport);\r\n}
