void __cpuinit smp_store_cpu_info(int id)\r\n{\r\nint cpu_node;\r\nint mid;\r\ncpu_data(id).udelay_val = loops_per_jiffy;\r\ncpu_find_by_mid(id, &cpu_node);\r\ncpu_data(id).clock_tick = prom_getintdefault(cpu_node,\r\n"clock-frequency", 0);\r\ncpu_data(id).prom_node = cpu_node;\r\nmid = cpu_get_hwmid(cpu_node);\r\nif (mid < 0) {\r\nprintk(KERN_NOTICE "No MID found for CPU%d at node 0x%08d", id, cpu_node);\r\nmid = 0;\r\n}\r\ncpu_data(id).mid = mid;\r\n}\r\nvoid __init smp_cpus_done(unsigned int max_cpus)\r\n{\r\nextern void smp4m_smp_done(void);\r\nextern void smp4d_smp_done(void);\r\nunsigned long bogosum = 0;\r\nint cpu, num = 0;\r\nfor_each_online_cpu(cpu) {\r\nnum++;\r\nbogosum += cpu_data(cpu).udelay_val;\r\n}\r\nprintk("Total of %d processors activated (%lu.%02lu BogoMIPS).\n",\r\nnum, bogosum/(500000/HZ),\r\n(bogosum/(5000/HZ))%100);\r\nswitch(sparc_cpu_model) {\r\ncase sun4:\r\nprintk("SUN4\n");\r\nBUG();\r\nbreak;\r\ncase sun4c:\r\nprintk("SUN4C\n");\r\nBUG();\r\nbreak;\r\ncase sun4m:\r\nsmp4m_smp_done();\r\nbreak;\r\ncase sun4d:\r\nsmp4d_smp_done();\r\nbreak;\r\ncase sparc_leon:\r\nleon_smp_done();\r\nbreak;\r\ncase sun4e:\r\nprintk("SUN4E\n");\r\nBUG();\r\nbreak;\r\ncase sun4u:\r\nprintk("SUN4U\n");\r\nBUG();\r\nbreak;\r\ndefault:\r\nprintk("UNKNOWN!\n");\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nvoid cpu_panic(void)\r\n{\r\nprintk("CPU[%d]: Returns from cpu_idle!\n", smp_processor_id());\r\npanic("SMP bolixed\n");\r\n}\r\nvoid smp_send_reschedule(int cpu)\r\n{\r\nBTFIXUP_CALL(smp_ipi_resched)(cpu);\r\n}\r\nvoid smp_send_stop(void)\r\n{\r\n}\r\nvoid arch_send_call_function_single_ipi(int cpu)\r\n{\r\nBTFIXUP_CALL(smp_ipi_single)(cpu);\r\n}\r\nvoid arch_send_call_function_ipi_mask(const struct cpumask *mask)\r\n{\r\nint cpu;\r\nfor_each_cpu(cpu, mask)\r\nBTFIXUP_CALL(smp_ipi_mask_one)(cpu);\r\n}\r\nvoid smp_resched_interrupt(void)\r\n{\r\nirq_enter();\r\nscheduler_ipi();\r\nlocal_cpu_data().irq_resched_count++;\r\nirq_exit();\r\n}\r\nvoid smp_call_function_single_interrupt(void)\r\n{\r\nirq_enter();\r\ngeneric_smp_call_function_single_interrupt();\r\nlocal_cpu_data().irq_call_count++;\r\nirq_exit();\r\n}\r\nvoid smp_call_function_interrupt(void)\r\n{\r\nirq_enter();\r\ngeneric_smp_call_function_interrupt();\r\nlocal_cpu_data().irq_call_count++;\r\nirq_exit();\r\n}\r\nvoid smp_flush_cache_all(void)\r\n{\r\nxc0((smpfunc_t) BTFIXUP_CALL(local_flush_cache_all));\r\nlocal_flush_cache_all();\r\n}\r\nvoid smp_flush_tlb_all(void)\r\n{\r\nxc0((smpfunc_t) BTFIXUP_CALL(local_flush_tlb_all));\r\nlocal_flush_tlb_all();\r\n}\r\nvoid smp_flush_cache_mm(struct mm_struct *mm)\r\n{\r\nif(mm->context != NO_CONTEXT) {\r\ncpumask_t cpu_mask;\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nif (!cpumask_empty(&cpu_mask))\r\nxc1((smpfunc_t) BTFIXUP_CALL(local_flush_cache_mm), (unsigned long) mm);\r\nlocal_flush_cache_mm(mm);\r\n}\r\n}\r\nvoid smp_flush_tlb_mm(struct mm_struct *mm)\r\n{\r\nif(mm->context != NO_CONTEXT) {\r\ncpumask_t cpu_mask;\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nif (!cpumask_empty(&cpu_mask)) {\r\nxc1((smpfunc_t) BTFIXUP_CALL(local_flush_tlb_mm), (unsigned long) mm);\r\nif(atomic_read(&mm->mm_users) == 1 && current->active_mm == mm)\r\ncpumask_copy(mm_cpumask(mm),\r\ncpumask_of(smp_processor_id()));\r\n}\r\nlocal_flush_tlb_mm(mm);\r\n}\r\n}\r\nvoid smp_flush_cache_range(struct vm_area_struct *vma, unsigned long start,\r\nunsigned long end)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nif (mm->context != NO_CONTEXT) {\r\ncpumask_t cpu_mask;\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nif (!cpumask_empty(&cpu_mask))\r\nxc3((smpfunc_t) BTFIXUP_CALL(local_flush_cache_range), (unsigned long) vma, start, end);\r\nlocal_flush_cache_range(vma, start, end);\r\n}\r\n}\r\nvoid smp_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,\r\nunsigned long end)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nif (mm->context != NO_CONTEXT) {\r\ncpumask_t cpu_mask;\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nif (!cpumask_empty(&cpu_mask))\r\nxc3((smpfunc_t) BTFIXUP_CALL(local_flush_tlb_range), (unsigned long) vma, start, end);\r\nlocal_flush_tlb_range(vma, start, end);\r\n}\r\n}\r\nvoid smp_flush_cache_page(struct vm_area_struct *vma, unsigned long page)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nif(mm->context != NO_CONTEXT) {\r\ncpumask_t cpu_mask;\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nif (!cpumask_empty(&cpu_mask))\r\nxc2((smpfunc_t) BTFIXUP_CALL(local_flush_cache_page), (unsigned long) vma, page);\r\nlocal_flush_cache_page(vma, page);\r\n}\r\n}\r\nvoid smp_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nif(mm->context != NO_CONTEXT) {\r\ncpumask_t cpu_mask;\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nif (!cpumask_empty(&cpu_mask))\r\nxc2((smpfunc_t) BTFIXUP_CALL(local_flush_tlb_page), (unsigned long) vma, page);\r\nlocal_flush_tlb_page(vma, page);\r\n}\r\n}\r\nvoid smp_flush_page_to_ram(unsigned long page)\r\n{\r\n#if 1\r\nxc1((smpfunc_t) BTFIXUP_CALL(local_flush_page_to_ram), page);\r\n#endif\r\nlocal_flush_page_to_ram(page);\r\n}\r\nvoid smp_flush_sig_insns(struct mm_struct *mm, unsigned long insn_addr)\r\n{\r\ncpumask_t cpu_mask;\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nif (!cpumask_empty(&cpu_mask))\r\nxc2((smpfunc_t) BTFIXUP_CALL(local_flush_sig_insns), (unsigned long) mm, insn_addr);\r\nlocal_flush_sig_insns(mm, insn_addr);\r\n}\r\nint setup_profiling_timer(unsigned int multiplier)\r\n{\r\nint i;\r\nunsigned long flags;\r\nif((!multiplier) || (lvl14_resolution / multiplier) < 500)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&prof_setup_lock, flags);\r\nfor_each_possible_cpu(i) {\r\nload_profile_irq(i, lvl14_resolution / multiplier);\r\nprof_multiplier(i) = multiplier;\r\n}\r\nspin_unlock_irqrestore(&prof_setup_lock, flags);\r\nreturn 0;\r\n}\r\nvoid __init smp_prepare_cpus(unsigned int max_cpus)\r\n{\r\nextern void __init smp4m_boot_cpus(void);\r\nextern void __init smp4d_boot_cpus(void);\r\nint i, cpuid, extra;\r\nprintk("Entering SMP Mode...\n");\r\nextra = 0;\r\nfor (i = 0; !cpu_find_by_instance(i, NULL, &cpuid); i++) {\r\nif (cpuid >= NR_CPUS)\r\nextra++;\r\n}\r\nif (extra && max_cpus > i - extra)\r\nprintk("Warning: NR_CPUS is too low to start all cpus\n");\r\nsmp_store_cpu_info(boot_cpu_id);\r\nswitch(sparc_cpu_model) {\r\ncase sun4:\r\nprintk("SUN4\n");\r\nBUG();\r\nbreak;\r\ncase sun4c:\r\nprintk("SUN4C\n");\r\nBUG();\r\nbreak;\r\ncase sun4m:\r\nsmp4m_boot_cpus();\r\nbreak;\r\ncase sun4d:\r\nsmp4d_boot_cpus();\r\nbreak;\r\ncase sparc_leon:\r\nleon_boot_cpus();\r\nbreak;\r\ncase sun4e:\r\nprintk("SUN4E\n");\r\nBUG();\r\nbreak;\r\ncase sun4u:\r\nprintk("SUN4U\n");\r\nBUG();\r\nbreak;\r\ndefault:\r\nprintk("UNKNOWN!\n");\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nvoid __init smp_setup_cpu_possible_map(void)\r\n{\r\nint instance, mid;\r\ninstance = 0;\r\nwhile (!cpu_find_by_instance(instance, NULL, &mid)) {\r\nif (mid < NR_CPUS) {\r\nset_cpu_possible(mid, true);\r\nset_cpu_present(mid, true);\r\n}\r\ninstance++;\r\n}\r\n}\r\nvoid __init smp_prepare_boot_cpu(void)\r\n{\r\nint cpuid = hard_smp_processor_id();\r\nif (cpuid >= NR_CPUS) {\r\nprom_printf("Serious problem, boot cpu id >= NR_CPUS\n");\r\nprom_halt();\r\n}\r\nif (cpuid != 0)\r\nprintk("boot cpu id != 0, this could work but is untested\n");\r\ncurrent_thread_info()->cpu = cpuid;\r\nset_cpu_online(cpuid, true);\r\nset_cpu_possible(cpuid, true);\r\n}\r\nint __cpuinit __cpu_up(unsigned int cpu)\r\n{\r\nextern int __cpuinit smp4m_boot_one_cpu(int);\r\nextern int __cpuinit smp4d_boot_one_cpu(int);\r\nint ret=0;\r\nswitch(sparc_cpu_model) {\r\ncase sun4:\r\nprintk("SUN4\n");\r\nBUG();\r\nbreak;\r\ncase sun4c:\r\nprintk("SUN4C\n");\r\nBUG();\r\nbreak;\r\ncase sun4m:\r\nret = smp4m_boot_one_cpu(cpu);\r\nbreak;\r\ncase sun4d:\r\nret = smp4d_boot_one_cpu(cpu);\r\nbreak;\r\ncase sparc_leon:\r\nret = leon_boot_one_cpu(cpu);\r\nbreak;\r\ncase sun4e:\r\nprintk("SUN4E\n");\r\nBUG();\r\nbreak;\r\ncase sun4u:\r\nprintk("SUN4U\n");\r\nBUG();\r\nbreak;\r\ndefault:\r\nprintk("UNKNOWN!\n");\r\nBUG();\r\nbreak;\r\n}\r\nif (!ret) {\r\ncpumask_set_cpu(cpu, &smp_commenced_mask);\r\nwhile (!cpu_online(cpu))\r\nmb();\r\n}\r\nreturn ret;\r\n}\r\nvoid smp_bogo(struct seq_file *m)\r\n{\r\nint i;\r\nfor_each_online_cpu(i) {\r\nseq_printf(m,\r\n"Cpu%dBogo\t: %lu.%02lu\n",\r\ni,\r\ncpu_data(i).udelay_val/(500000/HZ),\r\n(cpu_data(i).udelay_val/(5000/HZ))%100);\r\n}\r\n}\r\nvoid smp_info(struct seq_file *m)\r\n{\r\nint i;\r\nseq_printf(m, "State:\n");\r\nfor_each_online_cpu(i)\r\nseq_printf(m, "CPU%d\t\t: online\n", i);\r\n}
