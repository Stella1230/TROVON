void bat_ogm_init(struct hard_iface *hard_iface)\r\n{\r\nstruct batman_ogm_packet *batman_ogm_packet;\r\nhard_iface->packet_len = BATMAN_OGM_LEN;\r\nhard_iface->packet_buff = kmalloc(hard_iface->packet_len, GFP_ATOMIC);\r\nbatman_ogm_packet = (struct batman_ogm_packet *)hard_iface->packet_buff;\r\nbatman_ogm_packet->packet_type = BAT_OGM;\r\nbatman_ogm_packet->version = COMPAT_VERSION;\r\nbatman_ogm_packet->flags = NO_FLAGS;\r\nbatman_ogm_packet->ttl = 2;\r\nbatman_ogm_packet->tq = TQ_MAX_VALUE;\r\nbatman_ogm_packet->tt_num_changes = 0;\r\nbatman_ogm_packet->ttvn = 0;\r\n}\r\nvoid bat_ogm_init_primary(struct hard_iface *hard_iface)\r\n{\r\nstruct batman_ogm_packet *batman_ogm_packet;\r\nbatman_ogm_packet = (struct batman_ogm_packet *)hard_iface->packet_buff;\r\nbatman_ogm_packet->flags = PRIMARIES_FIRST_HOP;\r\nbatman_ogm_packet->ttl = TTL;\r\n}\r\nvoid bat_ogm_update_mac(struct hard_iface *hard_iface)\r\n{\r\nstruct batman_ogm_packet *batman_ogm_packet;\r\nbatman_ogm_packet = (struct batman_ogm_packet *)hard_iface->packet_buff;\r\nmemcpy(batman_ogm_packet->orig,\r\nhard_iface->net_dev->dev_addr, ETH_ALEN);\r\nmemcpy(batman_ogm_packet->prev_sender,\r\nhard_iface->net_dev->dev_addr, ETH_ALEN);\r\n}\r\nstatic unsigned long bat_ogm_emit_send_time(const struct bat_priv *bat_priv)\r\n{\r\nreturn jiffies + msecs_to_jiffies(\r\natomic_read(&bat_priv->orig_interval) -\r\nJITTER + (random32() % 2*JITTER));\r\n}\r\nstatic unsigned long bat_ogm_fwd_send_time(void)\r\n{\r\nreturn jiffies + msecs_to_jiffies(random32() % (JITTER/2));\r\n}\r\nstatic uint8_t hop_penalty(uint8_t tq, const struct bat_priv *bat_priv)\r\n{\r\nint hop_penalty = atomic_read(&bat_priv->hop_penalty);\r\nreturn (tq * (TQ_MAX_VALUE - hop_penalty)) / (TQ_MAX_VALUE);\r\n}\r\nstatic int bat_ogm_aggr_packet(int buff_pos, int packet_len,\r\nint tt_num_changes)\r\n{\r\nint next_buff_pos = buff_pos + BATMAN_OGM_LEN + tt_len(tt_num_changes);\r\nreturn (next_buff_pos <= packet_len) &&\r\n(next_buff_pos <= MAX_AGGREGATION_BYTES);\r\n}\r\nstatic void bat_ogm_send_to_if(struct forw_packet *forw_packet,\r\nstruct hard_iface *hard_iface)\r\n{\r\nstruct bat_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nchar *fwd_str;\r\nuint8_t packet_num;\r\nint16_t buff_pos;\r\nstruct batman_ogm_packet *batman_ogm_packet;\r\nstruct sk_buff *skb;\r\nif (hard_iface->if_status != IF_ACTIVE)\r\nreturn;\r\npacket_num = 0;\r\nbuff_pos = 0;\r\nbatman_ogm_packet = (struct batman_ogm_packet *)forw_packet->skb->data;\r\nwhile (bat_ogm_aggr_packet(buff_pos, forw_packet->packet_len,\r\nbatman_ogm_packet->tt_num_changes)) {\r\nif ((forw_packet->direct_link_flags & (1 << packet_num)) &&\r\n(forw_packet->if_incoming == hard_iface))\r\nbatman_ogm_packet->flags |= DIRECTLINK;\r\nelse\r\nbatman_ogm_packet->flags &= ~DIRECTLINK;\r\nfwd_str = (packet_num > 0 ? "Forwarding" : (forw_packet->own ?\r\n"Sending own" :\r\n"Forwarding"));\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"%s %spacket (originator %pM, seqno %d, TQ %d, TTL %d,"\r\n" IDF %s, ttvn %d) on interface %s [%pM]\n",\r\nfwd_str, (packet_num > 0 ? "aggregated " : ""),\r\nbatman_ogm_packet->orig,\r\nntohl(batman_ogm_packet->seqno),\r\nbatman_ogm_packet->tq, batman_ogm_packet->ttl,\r\n(batman_ogm_packet->flags & DIRECTLINK ?\r\n"on" : "off"),\r\nbatman_ogm_packet->ttvn, hard_iface->net_dev->name,\r\nhard_iface->net_dev->dev_addr);\r\nbuff_pos += BATMAN_OGM_LEN +\r\ntt_len(batman_ogm_packet->tt_num_changes);\r\npacket_num++;\r\nbatman_ogm_packet = (struct batman_ogm_packet *)\r\n(forw_packet->skb->data + buff_pos);\r\n}\r\nskb = skb_clone(forw_packet->skb, GFP_ATOMIC);\r\nif (skb)\r\nsend_skb_packet(skb, hard_iface, broadcast_addr);\r\n}\r\nvoid bat_ogm_emit(struct forw_packet *forw_packet)\r\n{\r\nstruct hard_iface *hard_iface;\r\nstruct net_device *soft_iface;\r\nstruct bat_priv *bat_priv;\r\nstruct hard_iface *primary_if = NULL;\r\nstruct batman_ogm_packet *batman_ogm_packet;\r\nunsigned char directlink;\r\nbatman_ogm_packet = (struct batman_ogm_packet *)\r\n(forw_packet->skb->data);\r\ndirectlink = (batman_ogm_packet->flags & DIRECTLINK ? 1 : 0);\r\nif (!forw_packet->if_incoming) {\r\npr_err("Error - can't forward packet: incoming iface not "\r\n"specified\n");\r\ngoto out;\r\n}\r\nsoft_iface = forw_packet->if_incoming->soft_iface;\r\nbat_priv = netdev_priv(soft_iface);\r\nif (forw_packet->if_incoming->if_status != IF_ACTIVE)\r\ngoto out;\r\nprimary_if = primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\nif ((directlink && (batman_ogm_packet->ttl == 1)) ||\r\n(forw_packet->own && (forw_packet->if_incoming != primary_if))) {\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"%s packet (originator %pM, seqno %d, TTL %d) "\r\n"on interface %s [%pM]\n",\r\n(forw_packet->own ? "Sending own" : "Forwarding"),\r\nbatman_ogm_packet->orig,\r\nntohl(batman_ogm_packet->seqno),\r\nbatman_ogm_packet->ttl,\r\nforw_packet->if_incoming->net_dev->name,\r\nforw_packet->if_incoming->net_dev->dev_addr);\r\nsend_skb_packet(forw_packet->skb, forw_packet->if_incoming,\r\nbroadcast_addr);\r\nforw_packet->skb = NULL;\r\ngoto out;\r\n}\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &hardif_list, list) {\r\nif (hard_iface->soft_iface != soft_iface)\r\ncontinue;\r\nbat_ogm_send_to_if(forw_packet, hard_iface);\r\n}\r\nrcu_read_unlock();\r\nout:\r\nif (primary_if)\r\nhardif_free_ref(primary_if);\r\n}\r\nstatic bool bat_ogm_can_aggregate(const struct batman_ogm_packet\r\n*new_batman_ogm_packet,\r\nstruct bat_priv *bat_priv,\r\nint packet_len, unsigned long send_time,\r\nbool directlink,\r\nconst struct hard_iface *if_incoming,\r\nconst struct forw_packet *forw_packet)\r\n{\r\nstruct batman_ogm_packet *batman_ogm_packet;\r\nint aggregated_bytes = forw_packet->packet_len + packet_len;\r\nstruct hard_iface *primary_if = NULL;\r\nbool res = false;\r\nbatman_ogm_packet = (struct batman_ogm_packet *)forw_packet->skb->data;\r\nif (time_before(send_time, forw_packet->send_time) &&\r\ntime_after_eq(send_time + msecs_to_jiffies(MAX_AGGREGATION_MS),\r\nforw_packet->send_time) &&\r\n(aggregated_bytes <= MAX_AGGREGATION_BYTES)) {\r\nprimary_if = primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\nif ((!directlink) &&\r\n(!(batman_ogm_packet->flags & DIRECTLINK)) &&\r\n(batman_ogm_packet->ttl != 1) &&\r\n((!forw_packet->own) ||\r\n(forw_packet->if_incoming == primary_if))) {\r\nres = true;\r\ngoto out;\r\n}\r\nif ((directlink) &&\r\n(new_batman_ogm_packet->ttl == 1) &&\r\n(forw_packet->if_incoming == if_incoming) &&\r\n(batman_ogm_packet->flags & DIRECTLINK ||\r\n(forw_packet->own &&\r\nforw_packet->if_incoming != primary_if))) {\r\nres = true;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nif (primary_if)\r\nhardif_free_ref(primary_if);\r\nreturn res;\r\n}\r\nstatic void bat_ogm_aggregate_new(const unsigned char *packet_buff,\r\nint packet_len, unsigned long send_time,\r\nbool direct_link,\r\nstruct hard_iface *if_incoming,\r\nint own_packet)\r\n{\r\nstruct bat_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\r\nstruct forw_packet *forw_packet_aggr;\r\nunsigned char *skb_buff;\r\nif (!atomic_inc_not_zero(&if_incoming->refcount))\r\nreturn;\r\nif (!own_packet) {\r\nif (!atomic_dec_not_zero(&bat_priv->batman_queue_left)) {\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"batman packet queue full\n");\r\ngoto out;\r\n}\r\n}\r\nforw_packet_aggr = kmalloc(sizeof(*forw_packet_aggr), GFP_ATOMIC);\r\nif (!forw_packet_aggr) {\r\nif (!own_packet)\r\natomic_inc(&bat_priv->batman_queue_left);\r\ngoto out;\r\n}\r\nif ((atomic_read(&bat_priv->aggregated_ogms)) &&\r\n(packet_len < MAX_AGGREGATION_BYTES))\r\nforw_packet_aggr->skb = dev_alloc_skb(MAX_AGGREGATION_BYTES +\r\nsizeof(struct ethhdr));\r\nelse\r\nforw_packet_aggr->skb = dev_alloc_skb(packet_len +\r\nsizeof(struct ethhdr));\r\nif (!forw_packet_aggr->skb) {\r\nif (!own_packet)\r\natomic_inc(&bat_priv->batman_queue_left);\r\nkfree(forw_packet_aggr);\r\ngoto out;\r\n}\r\nskb_reserve(forw_packet_aggr->skb, sizeof(struct ethhdr));\r\nINIT_HLIST_NODE(&forw_packet_aggr->list);\r\nskb_buff = skb_put(forw_packet_aggr->skb, packet_len);\r\nforw_packet_aggr->packet_len = packet_len;\r\nmemcpy(skb_buff, packet_buff, packet_len);\r\nforw_packet_aggr->own = own_packet;\r\nforw_packet_aggr->if_incoming = if_incoming;\r\nforw_packet_aggr->num_packets = 0;\r\nforw_packet_aggr->direct_link_flags = NO_FLAGS;\r\nforw_packet_aggr->send_time = send_time;\r\nif (direct_link)\r\nforw_packet_aggr->direct_link_flags |= 1;\r\nspin_lock_bh(&bat_priv->forw_bat_list_lock);\r\nhlist_add_head(&forw_packet_aggr->list, &bat_priv->forw_bat_list);\r\nspin_unlock_bh(&bat_priv->forw_bat_list_lock);\r\nINIT_DELAYED_WORK(&forw_packet_aggr->delayed_work,\r\nsend_outstanding_bat_ogm_packet);\r\nqueue_delayed_work(bat_event_workqueue,\r\n&forw_packet_aggr->delayed_work,\r\nsend_time - jiffies);\r\nreturn;\r\nout:\r\nhardif_free_ref(if_incoming);\r\n}\r\nstatic void bat_ogm_aggregate(struct forw_packet *forw_packet_aggr,\r\nconst unsigned char *packet_buff,\r\nint packet_len, bool direct_link)\r\n{\r\nunsigned char *skb_buff;\r\nskb_buff = skb_put(forw_packet_aggr->skb, packet_len);\r\nmemcpy(skb_buff, packet_buff, packet_len);\r\nforw_packet_aggr->packet_len += packet_len;\r\nforw_packet_aggr->num_packets++;\r\nif (direct_link)\r\nforw_packet_aggr->direct_link_flags |=\r\n(1 << forw_packet_aggr->num_packets);\r\n}\r\nstatic void bat_ogm_queue_add(struct bat_priv *bat_priv,\r\nunsigned char *packet_buff,\r\nint packet_len, struct hard_iface *if_incoming,\r\nint own_packet, unsigned long send_time)\r\n{\r\nstruct forw_packet *forw_packet_aggr = NULL, *forw_packet_pos = NULL;\r\nstruct hlist_node *tmp_node;\r\nstruct batman_ogm_packet *batman_ogm_packet;\r\nbool direct_link;\r\nbatman_ogm_packet = (struct batman_ogm_packet *)packet_buff;\r\ndirect_link = batman_ogm_packet->flags & DIRECTLINK ? 1 : 0;\r\nspin_lock_bh(&bat_priv->forw_bat_list_lock);\r\nif ((atomic_read(&bat_priv->aggregated_ogms)) && (!own_packet)) {\r\nhlist_for_each_entry(forw_packet_pos, tmp_node,\r\n&bat_priv->forw_bat_list, list) {\r\nif (bat_ogm_can_aggregate(batman_ogm_packet,\r\nbat_priv, packet_len,\r\nsend_time, direct_link,\r\nif_incoming,\r\nforw_packet_pos)) {\r\nforw_packet_aggr = forw_packet_pos;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!forw_packet_aggr) {\r\nspin_unlock_bh(&bat_priv->forw_bat_list_lock);\r\nif ((!own_packet) &&\r\n(atomic_read(&bat_priv->aggregated_ogms)))\r\nsend_time += msecs_to_jiffies(MAX_AGGREGATION_MS);\r\nbat_ogm_aggregate_new(packet_buff, packet_len,\r\nsend_time, direct_link,\r\nif_incoming, own_packet);\r\n} else {\r\nbat_ogm_aggregate(forw_packet_aggr, packet_buff, packet_len,\r\ndirect_link);\r\nspin_unlock_bh(&bat_priv->forw_bat_list_lock);\r\n}\r\n}\r\nstatic void bat_ogm_forward(struct orig_node *orig_node,\r\nconst struct ethhdr *ethhdr,\r\nstruct batman_ogm_packet *batman_ogm_packet,\r\nint directlink, struct hard_iface *if_incoming)\r\n{\r\nstruct bat_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\r\nstruct neigh_node *router;\r\nuint8_t in_tq, in_ttl, tq_avg = 0;\r\nuint8_t tt_num_changes;\r\nif (batman_ogm_packet->ttl <= 1) {\r\nbat_dbg(DBG_BATMAN, bat_priv, "ttl exceeded\n");\r\nreturn;\r\n}\r\nrouter = orig_node_get_router(orig_node);\r\nin_tq = batman_ogm_packet->tq;\r\nin_ttl = batman_ogm_packet->ttl;\r\ntt_num_changes = batman_ogm_packet->tt_num_changes;\r\nbatman_ogm_packet->ttl--;\r\nmemcpy(batman_ogm_packet->prev_sender, ethhdr->h_source, ETH_ALEN);\r\nif (router && router->tq_avg != 0) {\r\nif (!compare_eth(router->addr, ethhdr->h_source)) {\r\nbatman_ogm_packet->tq = router->tq_avg;\r\nif (router->last_ttl)\r\nbatman_ogm_packet->ttl = router->last_ttl - 1;\r\n}\r\ntq_avg = router->tq_avg;\r\n}\r\nif (router)\r\nneigh_node_free_ref(router);\r\nbatman_ogm_packet->tq = hop_penalty(batman_ogm_packet->tq, bat_priv);\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Forwarding packet: tq_orig: %i, tq_avg: %i, "\r\n"tq_forw: %i, ttl_orig: %i, ttl_forw: %i\n",\r\nin_tq, tq_avg, batman_ogm_packet->tq, in_ttl - 1,\r\nbatman_ogm_packet->ttl);\r\nbatman_ogm_packet->seqno = htonl(batman_ogm_packet->seqno);\r\nbatman_ogm_packet->tt_crc = htons(batman_ogm_packet->tt_crc);\r\nbatman_ogm_packet->flags &= ~PRIMARIES_FIRST_HOP;\r\nif (directlink)\r\nbatman_ogm_packet->flags |= DIRECTLINK;\r\nelse\r\nbatman_ogm_packet->flags &= ~DIRECTLINK;\r\nbat_ogm_queue_add(bat_priv, (unsigned char *)batman_ogm_packet,\r\nBATMAN_OGM_LEN + tt_len(tt_num_changes),\r\nif_incoming, 0, bat_ogm_fwd_send_time());\r\n}\r\nvoid bat_ogm_schedule(struct hard_iface *hard_iface, int tt_num_changes)\r\n{\r\nstruct bat_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nstruct batman_ogm_packet *batman_ogm_packet;\r\nstruct hard_iface *primary_if;\r\nint vis_server;\r\nvis_server = atomic_read(&bat_priv->vis_mode);\r\nprimary_if = primary_if_get_selected(bat_priv);\r\nbatman_ogm_packet = (struct batman_ogm_packet *)hard_iface->packet_buff;\r\nbatman_ogm_packet->seqno =\r\nhtonl((uint32_t)atomic_read(&hard_iface->seqno));\r\nbatman_ogm_packet->ttvn = atomic_read(&bat_priv->ttvn);\r\nbatman_ogm_packet->tt_crc = htons((uint16_t)\r\natomic_read(&bat_priv->tt_crc));\r\nif (tt_num_changes >= 0)\r\nbatman_ogm_packet->tt_num_changes = tt_num_changes;\r\nif (vis_server == VIS_TYPE_SERVER_SYNC)\r\nbatman_ogm_packet->flags |= VIS_SERVER;\r\nelse\r\nbatman_ogm_packet->flags &= ~VIS_SERVER;\r\nif ((hard_iface == primary_if) &&\r\n(atomic_read(&bat_priv->gw_mode) == GW_MODE_SERVER))\r\nbatman_ogm_packet->gw_flags =\r\n(uint8_t)atomic_read(&bat_priv->gw_bandwidth);\r\nelse\r\nbatman_ogm_packet->gw_flags = NO_FLAGS;\r\natomic_inc(&hard_iface->seqno);\r\nslide_own_bcast_window(hard_iface);\r\nbat_ogm_queue_add(bat_priv, hard_iface->packet_buff,\r\nhard_iface->packet_len, hard_iface, 1,\r\nbat_ogm_emit_send_time(bat_priv));\r\nif (primary_if)\r\nhardif_free_ref(primary_if);\r\n}\r\nstatic void bat_ogm_orig_update(struct bat_priv *bat_priv,\r\nstruct orig_node *orig_node,\r\nconst struct ethhdr *ethhdr,\r\nconst struct batman_ogm_packet\r\n*batman_ogm_packet,\r\nstruct hard_iface *if_incoming,\r\nconst unsigned char *tt_buff, int is_duplicate)\r\n{\r\nstruct neigh_node *neigh_node = NULL, *tmp_neigh_node = NULL;\r\nstruct neigh_node *router = NULL;\r\nstruct orig_node *orig_node_tmp;\r\nstruct hlist_node *node;\r\nuint8_t bcast_own_sum_orig, bcast_own_sum_neigh;\r\nbat_dbg(DBG_BATMAN, bat_priv, "update_originator(): "\r\n"Searching and updating originator entry of received packet\n");\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tmp_neigh_node, node,\r\n&orig_node->neigh_list, list) {\r\nif (compare_eth(tmp_neigh_node->addr, ethhdr->h_source) &&\r\n(tmp_neigh_node->if_incoming == if_incoming) &&\r\natomic_inc_not_zero(&tmp_neigh_node->refcount)) {\r\nif (neigh_node)\r\nneigh_node_free_ref(neigh_node);\r\nneigh_node = tmp_neigh_node;\r\ncontinue;\r\n}\r\nif (is_duplicate)\r\ncontinue;\r\nspin_lock_bh(&tmp_neigh_node->tq_lock);\r\nring_buffer_set(tmp_neigh_node->tq_recv,\r\n&tmp_neigh_node->tq_index, 0);\r\ntmp_neigh_node->tq_avg =\r\nring_buffer_avg(tmp_neigh_node->tq_recv);\r\nspin_unlock_bh(&tmp_neigh_node->tq_lock);\r\n}\r\nif (!neigh_node) {\r\nstruct orig_node *orig_tmp;\r\norig_tmp = get_orig_node(bat_priv, ethhdr->h_source);\r\nif (!orig_tmp)\r\ngoto unlock;\r\nneigh_node = create_neighbor(orig_node, orig_tmp,\r\nethhdr->h_source, if_incoming);\r\norig_node_free_ref(orig_tmp);\r\nif (!neigh_node)\r\ngoto unlock;\r\n} else\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Updating existing last-hop neighbor of originator\n");\r\nrcu_read_unlock();\r\norig_node->flags = batman_ogm_packet->flags;\r\nneigh_node->last_valid = jiffies;\r\nspin_lock_bh(&neigh_node->tq_lock);\r\nring_buffer_set(neigh_node->tq_recv,\r\n&neigh_node->tq_index,\r\nbatman_ogm_packet->tq);\r\nneigh_node->tq_avg = ring_buffer_avg(neigh_node->tq_recv);\r\nspin_unlock_bh(&neigh_node->tq_lock);\r\nif (!is_duplicate) {\r\norig_node->last_ttl = batman_ogm_packet->ttl;\r\nneigh_node->last_ttl = batman_ogm_packet->ttl;\r\n}\r\nbonding_candidate_add(orig_node, neigh_node);\r\nrouter = orig_node_get_router(orig_node);\r\nif (router == neigh_node)\r\ngoto update_tt;\r\nif (router && (router->tq_avg > neigh_node->tq_avg))\r\ngoto update_tt;\r\nif (router && (neigh_node->tq_avg == router->tq_avg)) {\r\norig_node_tmp = router->orig_node;\r\nspin_lock_bh(&orig_node_tmp->ogm_cnt_lock);\r\nbcast_own_sum_orig =\r\norig_node_tmp->bcast_own_sum[if_incoming->if_num];\r\nspin_unlock_bh(&orig_node_tmp->ogm_cnt_lock);\r\norig_node_tmp = neigh_node->orig_node;\r\nspin_lock_bh(&orig_node_tmp->ogm_cnt_lock);\r\nbcast_own_sum_neigh =\r\norig_node_tmp->bcast_own_sum[if_incoming->if_num];\r\nspin_unlock_bh(&orig_node_tmp->ogm_cnt_lock);\r\nif (bcast_own_sum_orig >= bcast_own_sum_neigh)\r\ngoto update_tt;\r\n}\r\nupdate_route(bat_priv, orig_node, neigh_node);\r\nupdate_tt:\r\nif (((batman_ogm_packet->orig != ethhdr->h_source) &&\r\n(batman_ogm_packet->ttl > 2)) ||\r\n(batman_ogm_packet->flags & PRIMARIES_FIRST_HOP))\r\ntt_update_orig(bat_priv, orig_node, tt_buff,\r\nbatman_ogm_packet->tt_num_changes,\r\nbatman_ogm_packet->ttvn,\r\nbatman_ogm_packet->tt_crc);\r\nif (orig_node->gw_flags != batman_ogm_packet->gw_flags)\r\ngw_node_update(bat_priv, orig_node,\r\nbatman_ogm_packet->gw_flags);\r\norig_node->gw_flags = batman_ogm_packet->gw_flags;\r\nif ((orig_node->gw_flags) &&\r\n(atomic_read(&bat_priv->gw_mode) == GW_MODE_CLIENT) &&\r\n(atomic_read(&bat_priv->gw_sel_class) > 2))\r\ngw_check_election(bat_priv, orig_node);\r\ngoto out;\r\nunlock:\r\nrcu_read_unlock();\r\nout:\r\nif (neigh_node)\r\nneigh_node_free_ref(neigh_node);\r\nif (router)\r\nneigh_node_free_ref(router);\r\n}\r\nstatic int bat_ogm_calc_tq(struct orig_node *orig_node,\r\nstruct orig_node *orig_neigh_node,\r\nstruct batman_ogm_packet *batman_ogm_packet,\r\nstruct hard_iface *if_incoming)\r\n{\r\nstruct bat_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\r\nstruct neigh_node *neigh_node = NULL, *tmp_neigh_node;\r\nstruct hlist_node *node;\r\nuint8_t total_count;\r\nuint8_t orig_eq_count, neigh_rq_count, tq_own;\r\nint tq_asym_penalty, ret = 0;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tmp_neigh_node, node,\r\n&orig_neigh_node->neigh_list, list) {\r\nif (!compare_eth(tmp_neigh_node->addr, orig_neigh_node->orig))\r\ncontinue;\r\nif (tmp_neigh_node->if_incoming != if_incoming)\r\ncontinue;\r\nif (!atomic_inc_not_zero(&tmp_neigh_node->refcount))\r\ncontinue;\r\nneigh_node = tmp_neigh_node;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nif (!neigh_node)\r\nneigh_node = create_neighbor(orig_neigh_node,\r\norig_neigh_node,\r\norig_neigh_node->orig,\r\nif_incoming);\r\nif (!neigh_node)\r\ngoto out;\r\nif (orig_node == orig_neigh_node)\r\nneigh_node->last_valid = jiffies;\r\norig_node->last_valid = jiffies;\r\nspin_lock_bh(&orig_node->ogm_cnt_lock);\r\norig_eq_count = orig_neigh_node->bcast_own_sum[if_incoming->if_num];\r\nneigh_rq_count = neigh_node->real_packet_count;\r\nspin_unlock_bh(&orig_node->ogm_cnt_lock);\r\ntotal_count = (orig_eq_count > neigh_rq_count ?\r\nneigh_rq_count : orig_eq_count);\r\nif ((total_count < TQ_LOCAL_BIDRECT_SEND_MINIMUM) ||\r\n(neigh_rq_count < TQ_LOCAL_BIDRECT_RECV_MINIMUM))\r\ntq_own = 0;\r\nelse\r\ntq_own = (TQ_MAX_VALUE * total_count) / neigh_rq_count;\r\ntq_asym_penalty = TQ_MAX_VALUE - (TQ_MAX_VALUE *\r\n(TQ_LOCAL_WINDOW_SIZE - neigh_rq_count) *\r\n(TQ_LOCAL_WINDOW_SIZE - neigh_rq_count) *\r\n(TQ_LOCAL_WINDOW_SIZE - neigh_rq_count)) /\r\n(TQ_LOCAL_WINDOW_SIZE *\r\nTQ_LOCAL_WINDOW_SIZE *\r\nTQ_LOCAL_WINDOW_SIZE);\r\nbatman_ogm_packet->tq = ((batman_ogm_packet->tq * tq_own\r\n* tq_asym_penalty) /\r\n(TQ_MAX_VALUE * TQ_MAX_VALUE));\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"bidirectional: "\r\n"orig = %-15pM neigh = %-15pM => own_bcast = %2i, "\r\n"real recv = %2i, local tq: %3i, asym_penalty: %3i, "\r\n"total tq: %3i\n",\r\norig_node->orig, orig_neigh_node->orig, total_count,\r\nneigh_rq_count, tq_own, tq_asym_penalty, batman_ogm_packet->tq);\r\nif (batman_ogm_packet->tq >= TQ_TOTAL_BIDRECT_LIMIT)\r\nret = 1;\r\nout:\r\nif (neigh_node)\r\nneigh_node_free_ref(neigh_node);\r\nreturn ret;\r\n}\r\nstatic int bat_ogm_update_seqnos(const struct ethhdr *ethhdr,\r\nconst struct batman_ogm_packet\r\n*batman_ogm_packet,\r\nconst struct hard_iface *if_incoming)\r\n{\r\nstruct bat_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\r\nstruct orig_node *orig_node;\r\nstruct neigh_node *tmp_neigh_node;\r\nstruct hlist_node *node;\r\nint is_duplicate = 0;\r\nint32_t seq_diff;\r\nint need_update = 0;\r\nint set_mark, ret = -1;\r\norig_node = get_orig_node(bat_priv, batman_ogm_packet->orig);\r\nif (!orig_node)\r\nreturn 0;\r\nspin_lock_bh(&orig_node->ogm_cnt_lock);\r\nseq_diff = batman_ogm_packet->seqno - orig_node->last_real_seqno;\r\nif (window_protected(bat_priv, seq_diff,\r\n&orig_node->batman_seqno_reset))\r\ngoto out;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tmp_neigh_node, node,\r\n&orig_node->neigh_list, list) {\r\nis_duplicate |= get_bit_status(tmp_neigh_node->real_bits,\r\norig_node->last_real_seqno,\r\nbatman_ogm_packet->seqno);\r\nif (compare_eth(tmp_neigh_node->addr, ethhdr->h_source) &&\r\n(tmp_neigh_node->if_incoming == if_incoming))\r\nset_mark = 1;\r\nelse\r\nset_mark = 0;\r\nneed_update |= bit_get_packet(bat_priv,\r\ntmp_neigh_node->real_bits,\r\nseq_diff, set_mark);\r\ntmp_neigh_node->real_packet_count =\r\nbit_packet_count(tmp_neigh_node->real_bits);\r\n}\r\nrcu_read_unlock();\r\nif (need_update) {\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"updating last_seqno: old %d, new %d\n",\r\norig_node->last_real_seqno, batman_ogm_packet->seqno);\r\norig_node->last_real_seqno = batman_ogm_packet->seqno;\r\n}\r\nret = is_duplicate;\r\nout:\r\nspin_unlock_bh(&orig_node->ogm_cnt_lock);\r\norig_node_free_ref(orig_node);\r\nreturn ret;\r\n}\r\nstatic void bat_ogm_process(const struct ethhdr *ethhdr,\r\nstruct batman_ogm_packet *batman_ogm_packet,\r\nconst unsigned char *tt_buff,\r\nstruct hard_iface *if_incoming)\r\n{\r\nstruct bat_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\r\nstruct hard_iface *hard_iface;\r\nstruct orig_node *orig_neigh_node, *orig_node;\r\nstruct neigh_node *router = NULL, *router_router = NULL;\r\nstruct neigh_node *orig_neigh_router = NULL;\r\nint has_directlink_flag;\r\nint is_my_addr = 0, is_my_orig = 0, is_my_oldorig = 0;\r\nint is_broadcast = 0, is_bidirectional, is_single_hop_neigh;\r\nint is_duplicate;\r\nuint32_t if_incoming_seqno;\r\nif (batman_ogm_packet->packet_type != BAT_OGM)\r\nreturn;\r\nif_incoming_seqno = atomic_read(&if_incoming->seqno);\r\nhas_directlink_flag = (batman_ogm_packet->flags & DIRECTLINK ? 1 : 0);\r\nis_single_hop_neigh = (compare_eth(ethhdr->h_source,\r\nbatman_ogm_packet->orig) ? 1 : 0);\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Received BATMAN packet via NB: %pM, IF: %s [%pM] "\r\n"(from OG: %pM, via prev OG: %pM, seqno %d, ttvn %u, "\r\n"crc %u, changes %u, td %d, TTL %d, V %d, IDF %d)\n",\r\nethhdr->h_source, if_incoming->net_dev->name,\r\nif_incoming->net_dev->dev_addr, batman_ogm_packet->orig,\r\nbatman_ogm_packet->prev_sender, batman_ogm_packet->seqno,\r\nbatman_ogm_packet->ttvn, batman_ogm_packet->tt_crc,\r\nbatman_ogm_packet->tt_num_changes, batman_ogm_packet->tq,\r\nbatman_ogm_packet->ttl, batman_ogm_packet->version,\r\nhas_directlink_flag);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &hardif_list, list) {\r\nif (hard_iface->if_status != IF_ACTIVE)\r\ncontinue;\r\nif (hard_iface->soft_iface != if_incoming->soft_iface)\r\ncontinue;\r\nif (compare_eth(ethhdr->h_source,\r\nhard_iface->net_dev->dev_addr))\r\nis_my_addr = 1;\r\nif (compare_eth(batman_ogm_packet->orig,\r\nhard_iface->net_dev->dev_addr))\r\nis_my_orig = 1;\r\nif (compare_eth(batman_ogm_packet->prev_sender,\r\nhard_iface->net_dev->dev_addr))\r\nis_my_oldorig = 1;\r\nif (is_broadcast_ether_addr(ethhdr->h_source))\r\nis_broadcast = 1;\r\n}\r\nrcu_read_unlock();\r\nif (batman_ogm_packet->version != COMPAT_VERSION) {\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Drop packet: incompatible batman version (%i)\n",\r\nbatman_ogm_packet->version);\r\nreturn;\r\n}\r\nif (is_my_addr) {\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Drop packet: received my own broadcast (sender: %pM"\r\n")\n",\r\nethhdr->h_source);\r\nreturn;\r\n}\r\nif (is_broadcast) {\r\nbat_dbg(DBG_BATMAN, bat_priv, "Drop packet: "\r\n"ignoring all packets with broadcast source addr (sender: %pM"\r\n")\n", ethhdr->h_source);\r\nreturn;\r\n}\r\nif (is_my_orig) {\r\nunsigned long *word;\r\nint offset;\r\norig_neigh_node = get_orig_node(bat_priv, ethhdr->h_source);\r\nif (!orig_neigh_node)\r\nreturn;\r\nif (has_directlink_flag &&\r\ncompare_eth(if_incoming->net_dev->dev_addr,\r\nbatman_ogm_packet->orig)) {\r\noffset = if_incoming->if_num * NUM_WORDS;\r\nspin_lock_bh(&orig_neigh_node->ogm_cnt_lock);\r\nword = &(orig_neigh_node->bcast_own[offset]);\r\nbit_mark(word,\r\nif_incoming_seqno -\r\nbatman_ogm_packet->seqno - 2);\r\norig_neigh_node->bcast_own_sum[if_incoming->if_num] =\r\nbit_packet_count(word);\r\nspin_unlock_bh(&orig_neigh_node->ogm_cnt_lock);\r\n}\r\nbat_dbg(DBG_BATMAN, bat_priv, "Drop packet: "\r\n"originator packet from myself (via neighbor)\n");\r\norig_node_free_ref(orig_neigh_node);\r\nreturn;\r\n}\r\nif (is_my_oldorig) {\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Drop packet: ignoring all rebroadcast echos (sender: "\r\n"%pM)\n", ethhdr->h_source);\r\nreturn;\r\n}\r\norig_node = get_orig_node(bat_priv, batman_ogm_packet->orig);\r\nif (!orig_node)\r\nreturn;\r\nis_duplicate = bat_ogm_update_seqnos(ethhdr, batman_ogm_packet,\r\nif_incoming);\r\nif (is_duplicate == -1) {\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Drop packet: packet within seqno protection time "\r\n"(sender: %pM)\n", ethhdr->h_source);\r\ngoto out;\r\n}\r\nif (batman_ogm_packet->tq == 0) {\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Drop packet: originator packet with tq equal 0\n");\r\ngoto out;\r\n}\r\nrouter = orig_node_get_router(orig_node);\r\nif (router)\r\nrouter_router = orig_node_get_router(router->orig_node);\r\nif (router && router_router &&\r\n(compare_eth(router->addr, batman_ogm_packet->prev_sender)) &&\r\n!(compare_eth(batman_ogm_packet->orig,\r\nbatman_ogm_packet->prev_sender)) &&\r\n(compare_eth(router->addr, router_router->addr))) {\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Drop packet: ignoring all rebroadcast packets that "\r\n"may make me loop (sender: %pM)\n", ethhdr->h_source);\r\ngoto out;\r\n}\r\norig_neigh_node = (is_single_hop_neigh ?\r\norig_node :\r\nget_orig_node(bat_priv, ethhdr->h_source));\r\nif (!orig_neigh_node)\r\ngoto out;\r\norig_neigh_router = orig_node_get_router(orig_neigh_node);\r\nif (!is_single_hop_neigh && (!orig_neigh_router)) {\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Drop packet: OGM via unknown neighbor!\n");\r\ngoto out_neigh;\r\n}\r\nis_bidirectional = bat_ogm_calc_tq(orig_node, orig_neigh_node,\r\nbatman_ogm_packet, if_incoming);\r\nbonding_save_primary(orig_node, orig_neigh_node, batman_ogm_packet);\r\nif (is_bidirectional &&\r\n(!is_duplicate ||\r\n((orig_node->last_real_seqno == batman_ogm_packet->seqno) &&\r\n(orig_node->last_ttl - 3 <= batman_ogm_packet->ttl))))\r\nbat_ogm_orig_update(bat_priv, orig_node, ethhdr,\r\nbatman_ogm_packet, if_incoming,\r\ntt_buff, is_duplicate);\r\nif (is_single_hop_neigh) {\r\nbat_ogm_forward(orig_node, ethhdr, batman_ogm_packet,\r\n1, if_incoming);\r\nbat_dbg(DBG_BATMAN, bat_priv, "Forwarding packet: "\r\n"rebroadcast neighbor packet with direct link flag\n");\r\ngoto out_neigh;\r\n}\r\nif (!is_bidirectional) {\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Drop packet: not received via bidirectional link\n");\r\ngoto out_neigh;\r\n}\r\nif (is_duplicate) {\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Drop packet: duplicate packet received\n");\r\ngoto out_neigh;\r\n}\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Forwarding packet: rebroadcast originator packet\n");\r\nbat_ogm_forward(orig_node, ethhdr, batman_ogm_packet, 0, if_incoming);\r\nout_neigh:\r\nif ((orig_neigh_node) && (!is_single_hop_neigh))\r\norig_node_free_ref(orig_neigh_node);\r\nout:\r\nif (router)\r\nneigh_node_free_ref(router);\r\nif (router_router)\r\nneigh_node_free_ref(router_router);\r\nif (orig_neigh_router)\r\nneigh_node_free_ref(orig_neigh_router);\r\norig_node_free_ref(orig_node);\r\n}\r\nvoid bat_ogm_receive(const struct ethhdr *ethhdr, unsigned char *packet_buff,\r\nint packet_len, struct hard_iface *if_incoming)\r\n{\r\nstruct batman_ogm_packet *batman_ogm_packet;\r\nint buff_pos = 0;\r\nunsigned char *tt_buff;\r\nbatman_ogm_packet = (struct batman_ogm_packet *)packet_buff;\r\ndo {\r\nbatman_ogm_packet->seqno = ntohl(batman_ogm_packet->seqno);\r\nbatman_ogm_packet->tt_crc = ntohs(batman_ogm_packet->tt_crc);\r\ntt_buff = packet_buff + buff_pos + BATMAN_OGM_LEN;\r\nbat_ogm_process(ethhdr, batman_ogm_packet,\r\ntt_buff, if_incoming);\r\nbuff_pos += BATMAN_OGM_LEN +\r\ntt_len(batman_ogm_packet->tt_num_changes);\r\nbatman_ogm_packet = (struct batman_ogm_packet *)\r\n(packet_buff + buff_pos);\r\n} while (bat_ogm_aggr_packet(buff_pos, packet_len,\r\nbatman_ogm_packet->tt_num_changes));\r\n}
