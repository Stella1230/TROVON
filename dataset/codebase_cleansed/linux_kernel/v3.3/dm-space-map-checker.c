static int ca_get_count(struct count_array *ca, dm_block_t b, uint32_t *count)\r\n{\r\nif (b >= ca->nr)\r\nreturn -EINVAL;\r\n*count = ca->counts[b];\r\nreturn 0;\r\n}\r\nstatic int ca_count_more_than_one(struct count_array *ca, dm_block_t b, int *r)\r\n{\r\nif (b >= ca->nr)\r\nreturn -EINVAL;\r\n*r = ca->counts[b] > 1;\r\nreturn 0;\r\n}\r\nstatic int ca_set_count(struct count_array *ca, dm_block_t b, uint32_t count)\r\n{\r\nuint32_t old_count;\r\nif (b >= ca->nr)\r\nreturn -EINVAL;\r\nold_count = ca->counts[b];\r\nif (!count && old_count)\r\nca->nr_free++;\r\nelse if (count && !old_count)\r\nca->nr_free--;\r\nca->counts[b] = count;\r\nreturn 0;\r\n}\r\nstatic int ca_inc_block(struct count_array *ca, dm_block_t b)\r\n{\r\nif (b >= ca->nr)\r\nreturn -EINVAL;\r\nca_set_count(ca, b, ca->counts[b] + 1);\r\nreturn 0;\r\n}\r\nstatic int ca_dec_block(struct count_array *ca, dm_block_t b)\r\n{\r\nif (b >= ca->nr)\r\nreturn -EINVAL;\r\nBUG_ON(ca->counts[b] == 0);\r\nca_set_count(ca, b, ca->counts[b] - 1);\r\nreturn 0;\r\n}\r\nstatic int ca_create(struct count_array *ca, struct dm_space_map *sm)\r\n{\r\nint r;\r\ndm_block_t nr_blocks;\r\nr = dm_sm_get_nr_blocks(sm, &nr_blocks);\r\nif (r)\r\nreturn r;\r\nca->nr = nr_blocks;\r\nca->nr_free = nr_blocks;\r\nca->counts = kzalloc(sizeof(*ca->counts) * nr_blocks, GFP_KERNEL);\r\nif (!ca->counts)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int ca_load(struct count_array *ca, struct dm_space_map *sm)\r\n{\r\nint r;\r\nuint32_t count;\r\ndm_block_t nr_blocks, i;\r\nr = dm_sm_get_nr_blocks(sm, &nr_blocks);\r\nif (r)\r\nreturn r;\r\nBUG_ON(ca->nr != nr_blocks);\r\nDMWARN("Loading debug space map from disk. This may take some time");\r\nfor (i = 0; i < nr_blocks; i++) {\r\nr = dm_sm_get_count(sm, i, &count);\r\nif (r) {\r\nDMERR("load failed");\r\nreturn r;\r\n}\r\nca_set_count(ca, i, count);\r\n}\r\nDMWARN("Load complete");\r\nreturn 0;\r\n}\r\nstatic int ca_extend(struct count_array *ca, dm_block_t extra_blocks)\r\n{\r\ndm_block_t nr_blocks = ca->nr + extra_blocks;\r\nuint32_t *counts = kzalloc(sizeof(*counts) * nr_blocks, GFP_KERNEL);\r\nif (!counts)\r\nreturn -ENOMEM;\r\nmemcpy(counts, ca->counts, sizeof(*counts) * ca->nr);\r\nkfree(ca->counts);\r\nca->nr = nr_blocks;\r\nca->nr_free += extra_blocks;\r\nca->counts = counts;\r\nreturn 0;\r\n}\r\nstatic int ca_commit(struct count_array *old, struct count_array *new)\r\n{\r\nif (old->nr != new->nr) {\r\nBUG_ON(old->nr > new->nr);\r\nca_extend(old, new->nr - old->nr);\r\n}\r\nBUG_ON(old->nr != new->nr);\r\nold->nr_free = new->nr_free;\r\nmemcpy(old->counts, new->counts, sizeof(*old->counts) * old->nr);\r\nreturn 0;\r\n}\r\nstatic void ca_destroy(struct count_array *ca)\r\n{\r\nkfree(ca->counts);\r\n}\r\nstatic void sm_checker_destroy(struct dm_space_map *sm)\r\n{\r\nstruct sm_checker *smc = container_of(sm, struct sm_checker, sm);\r\ndm_sm_destroy(smc->real_sm);\r\nca_destroy(&smc->old_counts);\r\nca_destroy(&smc->counts);\r\nkfree(smc);\r\n}\r\nstatic int sm_checker_get_nr_blocks(struct dm_space_map *sm, dm_block_t *count)\r\n{\r\nstruct sm_checker *smc = container_of(sm, struct sm_checker, sm);\r\nint r = dm_sm_get_nr_blocks(smc->real_sm, count);\r\nif (!r)\r\nBUG_ON(smc->old_counts.nr != *count);\r\nreturn r;\r\n}\r\nstatic int sm_checker_get_nr_free(struct dm_space_map *sm, dm_block_t *count)\r\n{\r\nstruct sm_checker *smc = container_of(sm, struct sm_checker, sm);\r\nint r = dm_sm_get_nr_free(smc->real_sm, count);\r\nif (!r) {\r\ndm_block_t b, n = 0;\r\nfor (b = 0; b < smc->old_counts.nr; b++)\r\nif (smc->old_counts.counts[b] == 0 &&\r\nsmc->counts.counts[b] == 0)\r\nn++;\r\nif (n != *count)\r\nDMERR("free block counts differ, checker %u, sm-disk:%u",\r\n(unsigned) n, (unsigned) *count);\r\n}\r\nreturn r;\r\n}\r\nstatic int sm_checker_new_block(struct dm_space_map *sm, dm_block_t *b)\r\n{\r\nstruct sm_checker *smc = container_of(sm, struct sm_checker, sm);\r\nint r = dm_sm_new_block(smc->real_sm, b);\r\nif (!r) {\r\nBUG_ON(*b >= smc->old_counts.nr);\r\nBUG_ON(smc->old_counts.counts[*b] != 0);\r\nBUG_ON(*b >= smc->counts.nr);\r\nBUG_ON(smc->counts.counts[*b] != 0);\r\nca_set_count(&smc->counts, *b, 1);\r\n}\r\nreturn r;\r\n}\r\nstatic int sm_checker_inc_block(struct dm_space_map *sm, dm_block_t b)\r\n{\r\nstruct sm_checker *smc = container_of(sm, struct sm_checker, sm);\r\nint r = dm_sm_inc_block(smc->real_sm, b);\r\nint r2 = ca_inc_block(&smc->counts, b);\r\nBUG_ON(r != r2);\r\nreturn r;\r\n}\r\nstatic int sm_checker_dec_block(struct dm_space_map *sm, dm_block_t b)\r\n{\r\nstruct sm_checker *smc = container_of(sm, struct sm_checker, sm);\r\nint r = dm_sm_dec_block(smc->real_sm, b);\r\nint r2 = ca_dec_block(&smc->counts, b);\r\nBUG_ON(r != r2);\r\nreturn r;\r\n}\r\nstatic int sm_checker_get_count(struct dm_space_map *sm, dm_block_t b, uint32_t *result)\r\n{\r\nstruct sm_checker *smc = container_of(sm, struct sm_checker, sm);\r\nuint32_t result2 = 0;\r\nint r = dm_sm_get_count(smc->real_sm, b, result);\r\nint r2 = ca_get_count(&smc->counts, b, &result2);\r\nBUG_ON(r != r2);\r\nif (!r)\r\nBUG_ON(*result != result2);\r\nreturn r;\r\n}\r\nstatic int sm_checker_count_more_than_one(struct dm_space_map *sm, dm_block_t b, int *result)\r\n{\r\nstruct sm_checker *smc = container_of(sm, struct sm_checker, sm);\r\nint result2 = 0;\r\nint r = dm_sm_count_is_more_than_one(smc->real_sm, b, result);\r\nint r2 = ca_count_more_than_one(&smc->counts, b, &result2);\r\nBUG_ON(r != r2);\r\nif (!r)\r\nBUG_ON(!(*result) && result2);\r\nreturn r;\r\n}\r\nstatic int sm_checker_set_count(struct dm_space_map *sm, dm_block_t b, uint32_t count)\r\n{\r\nstruct sm_checker *smc = container_of(sm, struct sm_checker, sm);\r\nuint32_t old_rc;\r\nint r = dm_sm_set_count(smc->real_sm, b, count);\r\nint r2;\r\nBUG_ON(b >= smc->counts.nr);\r\nold_rc = smc->counts.counts[b];\r\nr2 = ca_set_count(&smc->counts, b, count);\r\nBUG_ON(r != r2);\r\nreturn r;\r\n}\r\nstatic int sm_checker_commit(struct dm_space_map *sm)\r\n{\r\nstruct sm_checker *smc = container_of(sm, struct sm_checker, sm);\r\nint r;\r\nr = dm_sm_commit(smc->real_sm);\r\nif (r)\r\nreturn r;\r\nr = ca_commit(&smc->old_counts, &smc->counts);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nstatic int sm_checker_extend(struct dm_space_map *sm, dm_block_t extra_blocks)\r\n{\r\nstruct sm_checker *smc = container_of(sm, struct sm_checker, sm);\r\nint r = dm_sm_extend(smc->real_sm, extra_blocks);\r\nif (r)\r\nreturn r;\r\nreturn ca_extend(&smc->counts, extra_blocks);\r\n}\r\nstatic int sm_checker_root_size(struct dm_space_map *sm, size_t *result)\r\n{\r\nstruct sm_checker *smc = container_of(sm, struct sm_checker, sm);\r\nreturn dm_sm_root_size(smc->real_sm, result);\r\n}\r\nstatic int sm_checker_copy_root(struct dm_space_map *sm, void *copy_to_here_le, size_t len)\r\n{\r\nstruct sm_checker *smc = container_of(sm, struct sm_checker, sm);\r\nreturn dm_sm_copy_root(smc->real_sm, copy_to_here_le, len);\r\n}\r\nstruct dm_space_map *dm_sm_checker_create(struct dm_space_map *sm)\r\n{\r\nint r;\r\nstruct sm_checker *smc;\r\nif (!sm)\r\nreturn NULL;\r\nsmc = kmalloc(sizeof(*smc), GFP_KERNEL);\r\nif (!smc)\r\nreturn NULL;\r\nmemcpy(&smc->sm, &ops_, sizeof(smc->sm));\r\nr = ca_create(&smc->old_counts, sm);\r\nif (r) {\r\nkfree(smc);\r\nreturn NULL;\r\n}\r\nr = ca_create(&smc->counts, sm);\r\nif (r) {\r\nca_destroy(&smc->old_counts);\r\nkfree(smc);\r\nreturn NULL;\r\n}\r\nsmc->real_sm = sm;\r\nr = ca_load(&smc->counts, sm);\r\nif (r) {\r\nca_destroy(&smc->counts);\r\nca_destroy(&smc->old_counts);\r\nkfree(smc);\r\nreturn NULL;\r\n}\r\nr = ca_commit(&smc->old_counts, &smc->counts);\r\nif (r) {\r\nca_destroy(&smc->counts);\r\nca_destroy(&smc->old_counts);\r\nkfree(smc);\r\nreturn NULL;\r\n}\r\nreturn &smc->sm;\r\n}\r\nstruct dm_space_map *dm_sm_checker_create_fresh(struct dm_space_map *sm)\r\n{\r\nint r;\r\nstruct sm_checker *smc;\r\nif (!sm)\r\nreturn NULL;\r\nsmc = kmalloc(sizeof(*smc), GFP_KERNEL);\r\nif (!smc)\r\nreturn NULL;\r\nmemcpy(&smc->sm, &ops_, sizeof(smc->sm));\r\nr = ca_create(&smc->old_counts, sm);\r\nif (r) {\r\nkfree(smc);\r\nreturn NULL;\r\n}\r\nr = ca_create(&smc->counts, sm);\r\nif (r) {\r\nca_destroy(&smc->old_counts);\r\nkfree(smc);\r\nreturn NULL;\r\n}\r\nsmc->real_sm = sm;\r\nreturn &smc->sm;\r\n}\r\nstruct dm_space_map *dm_sm_checker_create(struct dm_space_map *sm)\r\n{\r\nreturn sm;\r\n}\r\nstruct dm_space_map *dm_sm_checker_create_fresh(struct dm_space_map *sm)\r\n{\r\nreturn sm;\r\n}
