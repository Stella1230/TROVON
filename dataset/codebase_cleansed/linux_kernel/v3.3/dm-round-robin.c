static void free_paths(struct list_head *paths)\r\n{\r\nstruct path_info *pi, *next;\r\nlist_for_each_entry_safe(pi, next, paths, list) {\r\nlist_del(&pi->list);\r\nkfree(pi);\r\n}\r\n}\r\nstatic struct selector *alloc_selector(void)\r\n{\r\nstruct selector *s = kmalloc(sizeof(*s), GFP_KERNEL);\r\nif (s) {\r\nINIT_LIST_HEAD(&s->valid_paths);\r\nINIT_LIST_HEAD(&s->invalid_paths);\r\n}\r\nreturn s;\r\n}\r\nstatic int rr_create(struct path_selector *ps, unsigned argc, char **argv)\r\n{\r\nstruct selector *s;\r\ns = alloc_selector();\r\nif (!s)\r\nreturn -ENOMEM;\r\nps->context = s;\r\nreturn 0;\r\n}\r\nstatic void rr_destroy(struct path_selector *ps)\r\n{\r\nstruct selector *s = (struct selector *) ps->context;\r\nfree_paths(&s->valid_paths);\r\nfree_paths(&s->invalid_paths);\r\nkfree(s);\r\nps->context = NULL;\r\n}\r\nstatic int rr_status(struct path_selector *ps, struct dm_path *path,\r\nstatus_type_t type, char *result, unsigned int maxlen)\r\n{\r\nstruct path_info *pi;\r\nint sz = 0;\r\nif (!path)\r\nDMEMIT("0 ");\r\nelse {\r\nswitch(type) {\r\ncase STATUSTYPE_INFO:\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\npi = path->pscontext;\r\nDMEMIT("%u ", pi->repeat_count);\r\nbreak;\r\n}\r\n}\r\nreturn sz;\r\n}\r\nstatic int rr_add_path(struct path_selector *ps, struct dm_path *path,\r\nint argc, char **argv, char **error)\r\n{\r\nstruct selector *s = (struct selector *) ps->context;\r\nstruct path_info *pi;\r\nunsigned repeat_count = RR_MIN_IO;\r\nif (argc > 1) {\r\n*error = "round-robin ps: incorrect number of arguments";\r\nreturn -EINVAL;\r\n}\r\nif ((argc == 1) && (sscanf(argv[0], "%u", &repeat_count) != 1)) {\r\n*error = "round-robin ps: invalid repeat count";\r\nreturn -EINVAL;\r\n}\r\npi = kmalloc(sizeof(*pi), GFP_KERNEL);\r\nif (!pi) {\r\n*error = "round-robin ps: Error allocating path context";\r\nreturn -ENOMEM;\r\n}\r\npi->path = path;\r\npi->repeat_count = repeat_count;\r\npath->pscontext = pi;\r\nlist_add_tail(&pi->list, &s->valid_paths);\r\nreturn 0;\r\n}\r\nstatic void rr_fail_path(struct path_selector *ps, struct dm_path *p)\r\n{\r\nstruct selector *s = (struct selector *) ps->context;\r\nstruct path_info *pi = p->pscontext;\r\nlist_move(&pi->list, &s->invalid_paths);\r\n}\r\nstatic int rr_reinstate_path(struct path_selector *ps, struct dm_path *p)\r\n{\r\nstruct selector *s = (struct selector *) ps->context;\r\nstruct path_info *pi = p->pscontext;\r\nlist_move(&pi->list, &s->valid_paths);\r\nreturn 0;\r\n}\r\nstatic struct dm_path *rr_select_path(struct path_selector *ps,\r\nunsigned *repeat_count, size_t nr_bytes)\r\n{\r\nstruct selector *s = (struct selector *) ps->context;\r\nstruct path_info *pi = NULL;\r\nif (!list_empty(&s->valid_paths)) {\r\npi = list_entry(s->valid_paths.next, struct path_info, list);\r\nlist_move_tail(&pi->list, &s->valid_paths);\r\n*repeat_count = pi->repeat_count;\r\n}\r\nreturn pi ? pi->path : NULL;\r\n}\r\nstatic int __init dm_rr_init(void)\r\n{\r\nint r = dm_register_path_selector(&rr_ps);\r\nif (r < 0)\r\nDMERR("register failed %d", r);\r\nDMINFO("version 1.0.0 loaded");\r\nreturn r;\r\n}\r\nstatic void __exit dm_rr_exit(void)\r\n{\r\nint r = dm_unregister_path_selector(&rr_ps);\r\nif (r < 0)\r\nDMERR("unregister failed %d", r);\r\n}
