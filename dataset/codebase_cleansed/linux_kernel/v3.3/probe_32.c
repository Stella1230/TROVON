static __init int no_ipi_broadcast(char *str)\r\n{\r\nget_option(&str, &no_broadcast);\r\npr_info("Using %s mode\n",\r\nno_broadcast ? "No IPI Broadcast" : "IPI Broadcast");\r\nreturn 1;\r\n}\r\nstatic int __init print_ipi_mode(void)\r\n{\r\npr_info("Using IPI %s mode\n",\r\nno_broadcast ? "No-Shortcut" : "Shortcut");\r\nreturn 0;\r\n}\r\nstatic int default_x86_32_early_logical_apicid(int cpu)\r\n{\r\nreturn 1 << cpu;\r\n}\r\nstatic void setup_apic_flat_routing(void)\r\n{\r\n#ifdef CONFIG_X86_IO_APIC\r\nprintk(KERN_INFO\r\n"Enabling APIC mode: Flat. Using %d I/O APICs\n",\r\nnr_ioapics);\r\n#endif\r\n}\r\nstatic void default_vector_allocation_domain(int cpu, struct cpumask *retmask)\r\n{\r\ncpumask_clear(retmask);\r\ncpumask_bits(retmask)[0] = APIC_ALL_CPUS;\r\n}\r\nstatic int probe_default(void)\r\n{\r\nreturn 1;\r\n}\r\nstatic int __init parse_apic(char *arg)\r\n{\r\nstruct apic **drv;\r\nif (!arg)\r\nreturn -EINVAL;\r\nfor (drv = __apicdrivers; drv < __apicdrivers_end; drv++) {\r\nif (!strcmp((*drv)->name, arg)) {\r\napic = *drv;\r\ncmdline_apic = 1;\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid __init default_setup_apic_routing(void)\r\n{\r\nint version = apic_version[boot_cpu_physical_apicid];\r\nif (num_possible_cpus() > 8) {\r\nswitch (boot_cpu_data.x86_vendor) {\r\ncase X86_VENDOR_INTEL:\r\nif (!APIC_XAPIC(version)) {\r\ndef_to_bigsmp = 0;\r\nbreak;\r\n}\r\ncase X86_VENDOR_AMD:\r\ndef_to_bigsmp = 1;\r\n}\r\n}\r\n#ifdef CONFIG_X86_BIGSMP\r\nif (!cmdline_apic && apic == &apic_default)\r\ngeneric_bigsmp_probe();\r\n#endif\r\nif (apic->setup_apic_routing)\r\napic->setup_apic_routing();\r\n}\r\nvoid __init generic_apic_probe(void)\r\n{\r\nif (!cmdline_apic) {\r\nstruct apic **drv;\r\nfor (drv = __apicdrivers; drv < __apicdrivers_end; drv++) {\r\nif ((*drv)->probe()) {\r\napic = *drv;\r\nbreak;\r\n}\r\n}\r\nif (drv == __apicdrivers_end)\r\npanic("Didn't find an APIC driver");\r\n}\r\nprintk(KERN_INFO "Using APIC driver %s\n", apic->name);\r\n}\r\nint __init\r\ngeneric_mps_oem_check(struct mpc_table *mpc, char *oem, char *productid)\r\n{\r\nstruct apic **drv;\r\nfor (drv = __apicdrivers; drv < __apicdrivers_end; drv++) {\r\nif (!((*drv)->mps_oem_check))\r\ncontinue;\r\nif (!(*drv)->mps_oem_check(mpc, oem, productid))\r\ncontinue;\r\nif (!cmdline_apic) {\r\napic = *drv;\r\nprintk(KERN_INFO "Switched to APIC driver `%s'.\n",\r\napic->name);\r\n}\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint __init default_acpi_madt_oem_check(char *oem_id, char *oem_table_id)\r\n{\r\nstruct apic **drv;\r\nfor (drv = __apicdrivers; drv < __apicdrivers_end; drv++) {\r\nif (!(*drv)->acpi_madt_oem_check)\r\ncontinue;\r\nif (!(*drv)->acpi_madt_oem_check(oem_id, oem_table_id))\r\ncontinue;\r\nif (!cmdline_apic) {\r\napic = *drv;\r\nprintk(KERN_INFO "Switched to APIC driver `%s'.\n",\r\napic->name);\r\n}\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}
