static const char * __init dmi_string_nosave(const struct dmi_header *dm, u8 s)\r\n{\r\nconst u8 *bp = ((u8 *) dm) + dm->length;\r\nif (s) {\r\ns--;\r\nwhile (s > 0 && *bp) {\r\nbp += strlen(bp) + 1;\r\ns--;\r\n}\r\nif (*bp != 0) {\r\nsize_t len = strlen(bp)+1;\r\nsize_t cmp_len = len > 8 ? 8 : len;\r\nif (!memcmp(bp, dmi_empty_string, cmp_len))\r\nreturn dmi_empty_string;\r\nreturn bp;\r\n}\r\n}\r\nreturn "";\r\n}\r\nstatic char * __init dmi_string(const struct dmi_header *dm, u8 s)\r\n{\r\nconst char *bp = dmi_string_nosave(dm, s);\r\nchar *str;\r\nsize_t len;\r\nif (bp == dmi_empty_string)\r\nreturn dmi_empty_string;\r\nlen = strlen(bp) + 1;\r\nstr = dmi_alloc(len);\r\nif (str != NULL)\r\nstrcpy(str, bp);\r\nelse\r\nprintk(KERN_ERR "dmi_string: cannot allocate %Zu bytes.\n", len);\r\nreturn str;\r\n}\r\nstatic void dmi_table(u8 *buf, int len, int num,\r\nvoid (*decode)(const struct dmi_header *, void *),\r\nvoid *private_data)\r\n{\r\nu8 *data = buf;\r\nint i = 0;\r\nwhile ((i < num) && (data - buf + sizeof(struct dmi_header)) <= len) {\r\nconst struct dmi_header *dm = (const struct dmi_header *)data;\r\ndata += dm->length;\r\nwhile ((data - buf < len - 1) && (data[0] || data[1]))\r\ndata++;\r\nif (data - buf < len - 1)\r\ndecode(dm, private_data);\r\ndata += 2;\r\ni++;\r\n}\r\n}\r\nstatic int __init dmi_walk_early(void (*decode)(const struct dmi_header *,\r\nvoid *))\r\n{\r\nu8 *buf;\r\nbuf = dmi_ioremap(dmi_base, dmi_len);\r\nif (buf == NULL)\r\nreturn -1;\r\ndmi_table(buf, dmi_len, dmi_num, decode, NULL);\r\ndmi_iounmap(buf, dmi_len);\r\nreturn 0;\r\n}\r\nstatic int __init dmi_checksum(const u8 *buf)\r\n{\r\nu8 sum = 0;\r\nint a;\r\nfor (a = 0; a < 15; a++)\r\nsum += buf[a];\r\nreturn sum == 0;\r\n}\r\nstatic void __init dmi_save_ident(const struct dmi_header *dm, int slot, int string)\r\n{\r\nconst char *d = (const char*) dm;\r\nchar *p;\r\nif (dmi_ident[slot])\r\nreturn;\r\np = dmi_string(dm, d[string]);\r\nif (p == NULL)\r\nreturn;\r\ndmi_ident[slot] = p;\r\n}\r\nstatic void __init dmi_save_uuid(const struct dmi_header *dm, int slot, int index)\r\n{\r\nconst u8 *d = (u8*) dm + index;\r\nchar *s;\r\nint is_ff = 1, is_00 = 1, i;\r\nif (dmi_ident[slot])\r\nreturn;\r\nfor (i = 0; i < 16 && (is_ff || is_00); i++) {\r\nif(d[i] != 0x00) is_ff = 0;\r\nif(d[i] != 0xFF) is_00 = 0;\r\n}\r\nif (is_ff || is_00)\r\nreturn;\r\ns = dmi_alloc(16*2+4+1);\r\nif (!s)\r\nreturn;\r\nsprintf(s, "%pUB", d);\r\ndmi_ident[slot] = s;\r\n}\r\nstatic void __init dmi_save_type(const struct dmi_header *dm, int slot, int index)\r\n{\r\nconst u8 *d = (u8*) dm + index;\r\nchar *s;\r\nif (dmi_ident[slot])\r\nreturn;\r\ns = dmi_alloc(4);\r\nif (!s)\r\nreturn;\r\nsprintf(s, "%u", *d & 0x7F);\r\ndmi_ident[slot] = s;\r\n}\r\nstatic void __init dmi_save_one_device(int type, const char *name)\r\n{\r\nstruct dmi_device *dev;\r\nif (dmi_find_device(type, name, NULL))\r\nreturn;\r\ndev = dmi_alloc(sizeof(*dev) + strlen(name) + 1);\r\nif (!dev) {\r\nprintk(KERN_ERR "dmi_save_one_device: out of memory.\n");\r\nreturn;\r\n}\r\ndev->type = type;\r\nstrcpy((char *)(dev + 1), name);\r\ndev->name = (char *)(dev + 1);\r\ndev->device_data = NULL;\r\nlist_add(&dev->list, &dmi_devices);\r\n}\r\nstatic void __init dmi_save_devices(const struct dmi_header *dm)\r\n{\r\nint i, count = (dm->length - sizeof(struct dmi_header)) / 2;\r\nfor (i = 0; i < count; i++) {\r\nconst char *d = (char *)(dm + 1) + (i * 2);\r\nif ((*d & 0x80) == 0)\r\ncontinue;\r\ndmi_save_one_device(*d & 0x7f, dmi_string_nosave(dm, *(d + 1)));\r\n}\r\n}\r\nstatic void __init dmi_save_oem_strings_devices(const struct dmi_header *dm)\r\n{\r\nint i, count = *(u8 *)(dm + 1);\r\nstruct dmi_device *dev;\r\nfor (i = 1; i <= count; i++) {\r\nchar *devname = dmi_string(dm, i);\r\nif (devname == dmi_empty_string)\r\ncontinue;\r\ndev = dmi_alloc(sizeof(*dev));\r\nif (!dev) {\r\nprintk(KERN_ERR\r\n"dmi_save_oem_strings_devices: out of memory.\n");\r\nbreak;\r\n}\r\ndev->type = DMI_DEV_TYPE_OEM_STRING;\r\ndev->name = devname;\r\ndev->device_data = NULL;\r\nlist_add(&dev->list, &dmi_devices);\r\n}\r\n}\r\nstatic void __init dmi_save_ipmi_device(const struct dmi_header *dm)\r\n{\r\nstruct dmi_device *dev;\r\nvoid * data;\r\ndata = dmi_alloc(dm->length);\r\nif (data == NULL) {\r\nprintk(KERN_ERR "dmi_save_ipmi_device: out of memory.\n");\r\nreturn;\r\n}\r\nmemcpy(data, dm, dm->length);\r\ndev = dmi_alloc(sizeof(*dev));\r\nif (!dev) {\r\nprintk(KERN_ERR "dmi_save_ipmi_device: out of memory.\n");\r\nreturn;\r\n}\r\ndev->type = DMI_DEV_TYPE_IPMI;\r\ndev->name = "IPMI controller";\r\ndev->device_data = data;\r\nlist_add_tail(&dev->list, &dmi_devices);\r\n}\r\nstatic void __init dmi_save_dev_onboard(int instance, int segment, int bus,\r\nint devfn, const char *name)\r\n{\r\nstruct dmi_dev_onboard *onboard_dev;\r\nonboard_dev = dmi_alloc(sizeof(*onboard_dev) + strlen(name) + 1);\r\nif (!onboard_dev) {\r\nprintk(KERN_ERR "dmi_save_dev_onboard: out of memory.\n");\r\nreturn;\r\n}\r\nonboard_dev->instance = instance;\r\nonboard_dev->segment = segment;\r\nonboard_dev->bus = bus;\r\nonboard_dev->devfn = devfn;\r\nstrcpy((char *)&onboard_dev[1], name);\r\nonboard_dev->dev.type = DMI_DEV_TYPE_DEV_ONBOARD;\r\nonboard_dev->dev.name = (char *)&onboard_dev[1];\r\nonboard_dev->dev.device_data = onboard_dev;\r\nlist_add(&onboard_dev->dev.list, &dmi_devices);\r\n}\r\nstatic void __init dmi_save_extended_devices(const struct dmi_header *dm)\r\n{\r\nconst u8 *d = (u8*) dm + 5;\r\nif ((*d & 0x80) == 0)\r\nreturn;\r\ndmi_save_dev_onboard(*(d+1), *(u16 *)(d+2), *(d+4), *(d+5),\r\ndmi_string_nosave(dm, *(d-1)));\r\ndmi_save_one_device(*d & 0x7f, dmi_string_nosave(dm, *(d - 1)));\r\n}\r\nstatic void __init dmi_decode(const struct dmi_header *dm, void *dummy)\r\n{\r\nswitch(dm->type) {\r\ncase 0:\r\ndmi_save_ident(dm, DMI_BIOS_VENDOR, 4);\r\ndmi_save_ident(dm, DMI_BIOS_VERSION, 5);\r\ndmi_save_ident(dm, DMI_BIOS_DATE, 8);\r\nbreak;\r\ncase 1:\r\ndmi_save_ident(dm, DMI_SYS_VENDOR, 4);\r\ndmi_save_ident(dm, DMI_PRODUCT_NAME, 5);\r\ndmi_save_ident(dm, DMI_PRODUCT_VERSION, 6);\r\ndmi_save_ident(dm, DMI_PRODUCT_SERIAL, 7);\r\ndmi_save_uuid(dm, DMI_PRODUCT_UUID, 8);\r\nbreak;\r\ncase 2:\r\ndmi_save_ident(dm, DMI_BOARD_VENDOR, 4);\r\ndmi_save_ident(dm, DMI_BOARD_NAME, 5);\r\ndmi_save_ident(dm, DMI_BOARD_VERSION, 6);\r\ndmi_save_ident(dm, DMI_BOARD_SERIAL, 7);\r\ndmi_save_ident(dm, DMI_BOARD_ASSET_TAG, 8);\r\nbreak;\r\ncase 3:\r\ndmi_save_ident(dm, DMI_CHASSIS_VENDOR, 4);\r\ndmi_save_type(dm, DMI_CHASSIS_TYPE, 5);\r\ndmi_save_ident(dm, DMI_CHASSIS_VERSION, 6);\r\ndmi_save_ident(dm, DMI_CHASSIS_SERIAL, 7);\r\ndmi_save_ident(dm, DMI_CHASSIS_ASSET_TAG, 8);\r\nbreak;\r\ncase 10:\r\ndmi_save_devices(dm);\r\nbreak;\r\ncase 11:\r\ndmi_save_oem_strings_devices(dm);\r\nbreak;\r\ncase 38:\r\ndmi_save_ipmi_device(dm);\r\nbreak;\r\ncase 41:\r\ndmi_save_extended_devices(dm);\r\n}\r\n}\r\nstatic void __init print_filtered(const char *info)\r\n{\r\nconst char *p;\r\nif (!info)\r\nreturn;\r\nfor (p = info; *p; p++)\r\nif (isprint(*p))\r\nprintk(KERN_CONT "%c", *p);\r\nelse\r\nprintk(KERN_CONT "\\x%02x", *p & 0xff);\r\n}\r\nstatic void __init dmi_dump_ids(void)\r\n{\r\nconst char *board;\r\nprintk(KERN_DEBUG "DMI: ");\r\nprint_filtered(dmi_get_system_info(DMI_SYS_VENDOR));\r\nprintk(KERN_CONT " ");\r\nprint_filtered(dmi_get_system_info(DMI_PRODUCT_NAME));\r\nboard = dmi_get_system_info(DMI_BOARD_NAME);\r\nif (board) {\r\nprintk(KERN_CONT "/");\r\nprint_filtered(board);\r\n}\r\nprintk(KERN_CONT ", BIOS ");\r\nprint_filtered(dmi_get_system_info(DMI_BIOS_VERSION));\r\nprintk(KERN_CONT " ");\r\nprint_filtered(dmi_get_system_info(DMI_BIOS_DATE));\r\nprintk(KERN_CONT "\n");\r\n}\r\nstatic int __init dmi_present(const char __iomem *p)\r\n{\r\nu8 buf[15];\r\nmemcpy_fromio(buf, p, 15);\r\nif ((memcmp(buf, "_DMI_", 5) == 0) && dmi_checksum(buf)) {\r\ndmi_num = (buf[13] << 8) | buf[12];\r\ndmi_len = (buf[7] << 8) | buf[6];\r\ndmi_base = (buf[11] << 24) | (buf[10] << 16) |\r\n(buf[9] << 8) | buf[8];\r\nif (buf[14] != 0)\r\nprintk(KERN_INFO "DMI %d.%d present.\n",\r\nbuf[14] >> 4, buf[14] & 0xF);\r\nelse\r\nprintk(KERN_INFO "DMI present.\n");\r\nif (dmi_walk_early(dmi_decode) == 0) {\r\ndmi_dump_ids();\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nvoid __init dmi_scan_machine(void)\r\n{\r\nchar __iomem *p, *q;\r\nint rc;\r\nif (efi_enabled) {\r\nif (efi.smbios == EFI_INVALID_TABLE_ADDR)\r\ngoto error;\r\np = dmi_ioremap(efi.smbios, 32);\r\nif (p == NULL)\r\ngoto error;\r\nrc = dmi_present(p + 0x10);\r\ndmi_iounmap(p, 32);\r\nif (!rc) {\r\ndmi_available = 1;\r\ngoto out;\r\n}\r\n}\r\nelse {\r\np = dmi_ioremap(0xF0000, 0x10000);\r\nif (p == NULL)\r\ngoto error;\r\nfor (q = p; q < p + 0x10000; q += 16) {\r\nrc = dmi_present(q);\r\nif (!rc) {\r\ndmi_available = 1;\r\ndmi_iounmap(p, 0x10000);\r\ngoto out;\r\n}\r\n}\r\ndmi_iounmap(p, 0x10000);\r\n}\r\nerror:\r\nprintk(KERN_INFO "DMI not present or invalid.\n");\r\nout:\r\ndmi_initialized = 1;\r\n}\r\nstatic bool dmi_matches(const struct dmi_system_id *dmi)\r\n{\r\nint i;\r\nWARN(!dmi_initialized, KERN_ERR "dmi check: not initialized yet.\n");\r\nfor (i = 0; i < ARRAY_SIZE(dmi->matches); i++) {\r\nint s = dmi->matches[i].slot;\r\nif (s == DMI_NONE)\r\nbreak;\r\nif (dmi_ident[s]\r\n&& strstr(dmi_ident[s], dmi->matches[i].substr))\r\ncontinue;\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool dmi_is_end_of_table(const struct dmi_system_id *dmi)\r\n{\r\nreturn dmi->matches[0].slot == DMI_NONE;\r\n}\r\nint dmi_check_system(const struct dmi_system_id *list)\r\n{\r\nint count = 0;\r\nconst struct dmi_system_id *d;\r\nfor (d = list; !dmi_is_end_of_table(d); d++)\r\nif (dmi_matches(d)) {\r\ncount++;\r\nif (d->callback && d->callback(d))\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nconst struct dmi_system_id *dmi_first_match(const struct dmi_system_id *list)\r\n{\r\nconst struct dmi_system_id *d;\r\nfor (d = list; !dmi_is_end_of_table(d); d++)\r\nif (dmi_matches(d))\r\nreturn d;\r\nreturn NULL;\r\n}\r\nconst char *dmi_get_system_info(int field)\r\n{\r\nreturn dmi_ident[field];\r\n}\r\nint dmi_name_in_serial(const char *str)\r\n{\r\nint f = DMI_PRODUCT_SERIAL;\r\nif (dmi_ident[f] && strstr(dmi_ident[f], str))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint dmi_name_in_vendors(const char *str)\r\n{\r\nstatic int fields[] = { DMI_SYS_VENDOR, DMI_BOARD_VENDOR, DMI_NONE };\r\nint i;\r\nfor (i = 0; fields[i] != DMI_NONE; i++) {\r\nint f = fields[i];\r\nif (dmi_ident[f] && strstr(dmi_ident[f], str))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nconst struct dmi_device * dmi_find_device(int type, const char *name,\r\nconst struct dmi_device *from)\r\n{\r\nconst struct list_head *head = from ? &from->list : &dmi_devices;\r\nstruct list_head *d;\r\nfor(d = head->next; d != &dmi_devices; d = d->next) {\r\nconst struct dmi_device *dev =\r\nlist_entry(d, struct dmi_device, list);\r\nif (((type == DMI_DEV_TYPE_ANY) || (dev->type == type)) &&\r\n((name == NULL) || (strcmp(dev->name, name) == 0)))\r\nreturn dev;\r\n}\r\nreturn NULL;\r\n}\r\nbool dmi_get_date(int field, int *yearp, int *monthp, int *dayp)\r\n{\r\nint year = 0, month = 0, day = 0;\r\nbool exists;\r\nconst char *s, *y;\r\nchar *e;\r\ns = dmi_get_system_info(field);\r\nexists = s;\r\nif (!exists)\r\ngoto out;\r\ny = strrchr(s, '/');\r\nif (!y)\r\ngoto out;\r\ny++;\r\nyear = simple_strtoul(y, &e, 10);\r\nif (y != e && year < 100) {\r\nyear += 1900;\r\nif (year < 1996)\r\nyear += 100;\r\n}\r\nif (year > 9999)\r\nyear = 0;\r\nmonth = simple_strtoul(s, &e, 10);\r\nif (s == e || *e != '/' || !month || month > 12) {\r\nmonth = 0;\r\ngoto out;\r\n}\r\ns = e + 1;\r\nday = simple_strtoul(s, &e, 10);\r\nif (s == y || s == e || *e != '/' || day > 31)\r\nday = 0;\r\nout:\r\nif (yearp)\r\n*yearp = year;\r\nif (monthp)\r\n*monthp = month;\r\nif (dayp)\r\n*dayp = day;\r\nreturn exists;\r\n}\r\nint dmi_walk(void (*decode)(const struct dmi_header *, void *),\r\nvoid *private_data)\r\n{\r\nu8 *buf;\r\nif (!dmi_available)\r\nreturn -1;\r\nbuf = ioremap(dmi_base, dmi_len);\r\nif (buf == NULL)\r\nreturn -1;\r\ndmi_table(buf, dmi_len, dmi_num, decode, private_data);\r\niounmap(buf);\r\nreturn 0;\r\n}\r\nbool dmi_match(enum dmi_field f, const char *str)\r\n{\r\nconst char *info = dmi_get_system_info(f);\r\nif (info == NULL || str == NULL)\r\nreturn info == str;\r\nreturn !strcmp(info, str);\r\n}
