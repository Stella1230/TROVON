static inline void __iomem *spi_reg(struct orion_spi *orion_spi, u32 reg)\r\n{\r\nreturn orion_spi->base + reg;\r\n}\r\nstatic inline void\r\norion_spi_setbits(struct orion_spi *orion_spi, u32 reg, u32 mask)\r\n{\r\nvoid __iomem *reg_addr = spi_reg(orion_spi, reg);\r\nu32 val;\r\nval = readl(reg_addr);\r\nval |= mask;\r\nwritel(val, reg_addr);\r\n}\r\nstatic inline void\r\norion_spi_clrbits(struct orion_spi *orion_spi, u32 reg, u32 mask)\r\n{\r\nvoid __iomem *reg_addr = spi_reg(orion_spi, reg);\r\nu32 val;\r\nval = readl(reg_addr);\r\nval &= ~mask;\r\nwritel(val, reg_addr);\r\n}\r\nstatic int orion_spi_set_transfer_size(struct orion_spi *orion_spi, int size)\r\n{\r\nif (size == 16) {\r\norion_spi_setbits(orion_spi, ORION_SPI_IF_CONFIG_REG,\r\nORION_SPI_IF_8_16_BIT_MODE);\r\n} else if (size == 8) {\r\norion_spi_clrbits(orion_spi, ORION_SPI_IF_CONFIG_REG,\r\nORION_SPI_IF_8_16_BIT_MODE);\r\n} else {\r\npr_debug("Bad bits per word value %d (only 8 or 16 are "\r\n"allowed).\n", size);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int orion_spi_baudrate_set(struct spi_device *spi, unsigned int speed)\r\n{\r\nu32 tclk_hz;\r\nu32 rate;\r\nu32 prescale;\r\nu32 reg;\r\nstruct orion_spi *orion_spi;\r\norion_spi = spi_master_get_devdata(spi->master);\r\ntclk_hz = orion_spi->spi_info->tclk;\r\nrate = DIV_ROUND_UP(tclk_hz, speed);\r\nrate = roundup(rate, 2);\r\nif (rate > 30)\r\nreturn -EINVAL;\r\nif (rate < 4)\r\nrate = 4;\r\nprescale = 0x10 + rate/2;\r\nreg = readl(spi_reg(orion_spi, ORION_SPI_IF_CONFIG_REG));\r\nreg = ((reg & ~ORION_SPI_CLK_PRESCALE_MASK) | prescale);\r\nwritel(reg, spi_reg(orion_spi, ORION_SPI_IF_CONFIG_REG));\r\nreturn 0;\r\n}\r\nstatic int\r\norion_spi_setup_transfer(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct orion_spi *orion_spi;\r\nunsigned int speed = spi->max_speed_hz;\r\nunsigned int bits_per_word = spi->bits_per_word;\r\nint rc;\r\norion_spi = spi_master_get_devdata(spi->master);\r\nif ((t != NULL) && t->speed_hz)\r\nspeed = t->speed_hz;\r\nif ((t != NULL) && t->bits_per_word)\r\nbits_per_word = t->bits_per_word;\r\nrc = orion_spi_baudrate_set(spi, speed);\r\nif (rc)\r\nreturn rc;\r\nreturn orion_spi_set_transfer_size(orion_spi, bits_per_word);\r\n}\r\nstatic void orion_spi_set_cs(struct orion_spi *orion_spi, int enable)\r\n{\r\nif (enable)\r\norion_spi_setbits(orion_spi, ORION_SPI_IF_CTRL_REG, 0x1);\r\nelse\r\norion_spi_clrbits(orion_spi, ORION_SPI_IF_CTRL_REG, 0x1);\r\n}\r\nstatic inline int orion_spi_wait_till_ready(struct orion_spi *orion_spi)\r\n{\r\nint i;\r\nfor (i = 0; i < ORION_SPI_WAIT_RDY_MAX_LOOP; i++) {\r\nif (readl(spi_reg(orion_spi, ORION_SPI_INT_CAUSE_REG)))\r\nreturn 1;\r\nelse\r\nudelay(1);\r\n}\r\nreturn -1;\r\n}\r\nstatic inline int\r\norion_spi_write_read_8bit(struct spi_device *spi,\r\nconst u8 **tx_buf, u8 **rx_buf)\r\n{\r\nvoid __iomem *tx_reg, *rx_reg, *int_reg;\r\nstruct orion_spi *orion_spi;\r\norion_spi = spi_master_get_devdata(spi->master);\r\ntx_reg = spi_reg(orion_spi, ORION_SPI_DATA_OUT_REG);\r\nrx_reg = spi_reg(orion_spi, ORION_SPI_DATA_IN_REG);\r\nint_reg = spi_reg(orion_spi, ORION_SPI_INT_CAUSE_REG);\r\nwritel(0x0, int_reg);\r\nif (tx_buf && *tx_buf)\r\nwritel(*(*tx_buf)++, tx_reg);\r\nelse\r\nwritel(0, tx_reg);\r\nif (orion_spi_wait_till_ready(orion_spi) < 0) {\r\ndev_err(&spi->dev, "TXS timed out\n");\r\nreturn -1;\r\n}\r\nif (rx_buf && *rx_buf)\r\n*(*rx_buf)++ = readl(rx_reg);\r\nreturn 1;\r\n}\r\nstatic inline int\r\norion_spi_write_read_16bit(struct spi_device *spi,\r\nconst u16 **tx_buf, u16 **rx_buf)\r\n{\r\nvoid __iomem *tx_reg, *rx_reg, *int_reg;\r\nstruct orion_spi *orion_spi;\r\norion_spi = spi_master_get_devdata(spi->master);\r\ntx_reg = spi_reg(orion_spi, ORION_SPI_DATA_OUT_REG);\r\nrx_reg = spi_reg(orion_spi, ORION_SPI_DATA_IN_REG);\r\nint_reg = spi_reg(orion_spi, ORION_SPI_INT_CAUSE_REG);\r\nwritel(0x0, int_reg);\r\nif (tx_buf && *tx_buf)\r\nwritel(__cpu_to_le16(get_unaligned((*tx_buf)++)), tx_reg);\r\nelse\r\nwritel(0, tx_reg);\r\nif (orion_spi_wait_till_ready(orion_spi) < 0) {\r\ndev_err(&spi->dev, "TXS timed out\n");\r\nreturn -1;\r\n}\r\nif (rx_buf && *rx_buf)\r\nput_unaligned(__le16_to_cpu(readl(rx_reg)), (*rx_buf)++);\r\nreturn 1;\r\n}\r\nstatic unsigned int\r\norion_spi_write_read(struct spi_device *spi, struct spi_transfer *xfer)\r\n{\r\nstruct orion_spi *orion_spi;\r\nunsigned int count;\r\nint word_len;\r\norion_spi = spi_master_get_devdata(spi->master);\r\nword_len = spi->bits_per_word;\r\ncount = xfer->len;\r\nif (word_len == 8) {\r\nconst u8 *tx = xfer->tx_buf;\r\nu8 *rx = xfer->rx_buf;\r\ndo {\r\nif (orion_spi_write_read_8bit(spi, &tx, &rx) < 0)\r\ngoto out;\r\ncount--;\r\n} while (count);\r\n} else if (word_len == 16) {\r\nconst u16 *tx = xfer->tx_buf;\r\nu16 *rx = xfer->rx_buf;\r\ndo {\r\nif (orion_spi_write_read_16bit(spi, &tx, &rx) < 0)\r\ngoto out;\r\ncount -= 2;\r\n} while (count);\r\n}\r\nout:\r\nreturn xfer->len - count;\r\n}\r\nstatic void orion_spi_work(struct work_struct *work)\r\n{\r\nstruct orion_spi *orion_spi =\r\ncontainer_of(work, struct orion_spi, work);\r\nspin_lock_irq(&orion_spi->lock);\r\nwhile (!list_empty(&orion_spi->msg_queue)) {\r\nstruct spi_message *m;\r\nstruct spi_device *spi;\r\nstruct spi_transfer *t = NULL;\r\nint par_override = 0;\r\nint status = 0;\r\nint cs_active = 0;\r\nm = container_of(orion_spi->msg_queue.next, struct spi_message,\r\nqueue);\r\nlist_del_init(&m->queue);\r\nspin_unlock_irq(&orion_spi->lock);\r\nspi = m->spi;\r\nstatus = orion_spi_setup_transfer(spi, NULL);\r\nif (status < 0)\r\ngoto msg_done;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (par_override || t->speed_hz || t->bits_per_word) {\r\npar_override = 1;\r\nstatus = orion_spi_setup_transfer(spi, t);\r\nif (status < 0)\r\nbreak;\r\nif (!t->speed_hz && !t->bits_per_word)\r\npar_override = 0;\r\n}\r\nif (!cs_active) {\r\norion_spi_set_cs(orion_spi, 1);\r\ncs_active = 1;\r\n}\r\nif (t->len)\r\nm->actual_length +=\r\norion_spi_write_read(spi, t);\r\nif (t->delay_usecs)\r\nudelay(t->delay_usecs);\r\nif (t->cs_change) {\r\norion_spi_set_cs(orion_spi, 0);\r\ncs_active = 0;\r\n}\r\n}\r\nmsg_done:\r\nif (cs_active)\r\norion_spi_set_cs(orion_spi, 0);\r\nm->status = status;\r\nm->complete(m->context);\r\nspin_lock_irq(&orion_spi->lock);\r\n}\r\nspin_unlock_irq(&orion_spi->lock);\r\n}\r\nstatic int __init orion_spi_reset(struct orion_spi *orion_spi)\r\n{\r\norion_spi_set_cs(orion_spi, 0);\r\nreturn 0;\r\n}\r\nstatic int orion_spi_setup(struct spi_device *spi)\r\n{\r\nstruct orion_spi *orion_spi;\r\norion_spi = spi_master_get_devdata(spi->master);\r\nif (orion_spi->spi_info->enable_clock_fix)\r\norion_spi_setbits(orion_spi, ORION_SPI_IF_CONFIG_REG,\r\n(1 << 14));\r\nif ((spi->max_speed_hz == 0)\r\n|| (spi->max_speed_hz > orion_spi->max_speed))\r\nspi->max_speed_hz = orion_spi->max_speed;\r\nif (spi->max_speed_hz < orion_spi->min_speed) {\r\ndev_err(&spi->dev, "setup: requested speed too low %d Hz\n",\r\nspi->max_speed_hz);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int orion_spi_transfer(struct spi_device *spi, struct spi_message *m)\r\n{\r\nstruct orion_spi *orion_spi;\r\nstruct spi_transfer *t = NULL;\r\nunsigned long flags;\r\nm->actual_length = 0;\r\nm->status = 0;\r\nif (list_empty(&m->transfers) || !m->complete)\r\nreturn -EINVAL;\r\norion_spi = spi_master_get_devdata(spi->master);\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nunsigned int bits_per_word = spi->bits_per_word;\r\nif (t->tx_buf == NULL && t->rx_buf == NULL && t->len) {\r\ndev_err(&spi->dev,\r\n"message rejected : "\r\n"invalid transfer data buffers\n");\r\ngoto msg_rejected;\r\n}\r\nif (t->bits_per_word)\r\nbits_per_word = t->bits_per_word;\r\nif ((bits_per_word != 8) && (bits_per_word != 16)) {\r\ndev_err(&spi->dev,\r\n"message rejected : "\r\n"invalid transfer bits_per_word (%d bits)\n",\r\nbits_per_word);\r\ngoto msg_rejected;\r\n}\r\nif ((t->bits_per_word == 16) && (t->len & 1)) {\r\ndev_err(&spi->dev,\r\n"message rejected : "\r\n"odd data length (%d) while in 16 bit mode\n",\r\nt->len);\r\ngoto msg_rejected;\r\n}\r\nif (t->speed_hz && t->speed_hz < orion_spi->min_speed) {\r\ndev_err(&spi->dev,\r\n"message rejected : "\r\n"device min speed (%d Hz) exceeds "\r\n"required transfer speed (%d Hz)\n",\r\norion_spi->min_speed, t->speed_hz);\r\ngoto msg_rejected;\r\n}\r\n}\r\nspin_lock_irqsave(&orion_spi->lock, flags);\r\nlist_add_tail(&m->queue, &orion_spi->msg_queue);\r\nqueue_work(orion_spi_wq, &orion_spi->work);\r\nspin_unlock_irqrestore(&orion_spi->lock, flags);\r\nreturn 0;\r\nmsg_rejected:\r\nm->status = -EINVAL;\r\nif (m->complete)\r\nm->complete(m->context);\r\nreturn -EINVAL;\r\n}\r\nstatic int __init orion_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct orion_spi *spi;\r\nstruct resource *r;\r\nstruct orion_spi_info *spi_info;\r\nint status = 0;\r\nspi_info = pdev->dev.platform_data;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof *spi);\r\nif (master == NULL) {\r\ndev_dbg(&pdev->dev, "master allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nif (pdev->id != -1)\r\nmaster->bus_num = pdev->id;\r\nmaster->mode_bits = 0;\r\nmaster->setup = orion_spi_setup;\r\nmaster->transfer = orion_spi_transfer;\r\nmaster->num_chipselect = ORION_NUM_CHIPSELECTS;\r\ndev_set_drvdata(&pdev->dev, master);\r\nspi = spi_master_get_devdata(master);\r\nspi->master = master;\r\nspi->spi_info = spi_info;\r\nspi->max_speed = DIV_ROUND_UP(spi_info->tclk, 4);\r\nspi->min_speed = DIV_ROUND_UP(spi_info->tclk, 30);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (r == NULL) {\r\nstatus = -ENODEV;\r\ngoto out;\r\n}\r\nif (!request_mem_region(r->start, resource_size(r),\r\ndev_name(&pdev->dev))) {\r\nstatus = -EBUSY;\r\ngoto out;\r\n}\r\nspi->base = ioremap(r->start, SZ_1K);\r\nINIT_WORK(&spi->work, orion_spi_work);\r\nspin_lock_init(&spi->lock);\r\nINIT_LIST_HEAD(&spi->msg_queue);\r\nif (orion_spi_reset(spi) < 0)\r\ngoto out_rel_mem;\r\nstatus = spi_register_master(master);\r\nif (status < 0)\r\ngoto out_rel_mem;\r\nreturn status;\r\nout_rel_mem:\r\nrelease_mem_region(r->start, resource_size(r));\r\nout:\r\nspi_master_put(master);\r\nreturn status;\r\n}\r\nstatic int __exit orion_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct orion_spi *spi;\r\nstruct resource *r;\r\nmaster = dev_get_drvdata(&pdev->dev);\r\nspi = spi_master_get_devdata(master);\r\ncancel_work_sync(&spi->work);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(r->start, resource_size(r));\r\nspi_unregister_master(master);\r\nreturn 0;\r\n}\r\nstatic int __init orion_spi_init(void)\r\n{\r\norion_spi_wq = create_singlethread_workqueue(\r\norion_spi_driver.driver.name);\r\nif (orion_spi_wq == NULL)\r\nreturn -ENOMEM;\r\nreturn platform_driver_probe(&orion_spi_driver, orion_spi_probe);\r\n}\r\nstatic void __exit orion_spi_exit(void)\r\n{\r\nflush_workqueue(orion_spi_wq);\r\nplatform_driver_unregister(&orion_spi_driver);\r\ndestroy_workqueue(orion_spi_wq);\r\n}
