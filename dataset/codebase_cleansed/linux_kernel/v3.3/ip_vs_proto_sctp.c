static int\r\nsctp_conn_schedule(int af, struct sk_buff *skb, struct ip_vs_proto_data *pd,\r\nint *verdict, struct ip_vs_conn **cpp)\r\n{\r\nstruct net *net;\r\nstruct ip_vs_service *svc;\r\nsctp_chunkhdr_t _schunkh, *sch;\r\nsctp_sctphdr_t *sh, _sctph;\r\nstruct ip_vs_iphdr iph;\r\nip_vs_fill_iphdr(af, skb_network_header(skb), &iph);\r\nsh = skb_header_pointer(skb, iph.len, sizeof(_sctph), &_sctph);\r\nif (sh == NULL)\r\nreturn 0;\r\nsch = skb_header_pointer(skb, iph.len + sizeof(sctp_sctphdr_t),\r\nsizeof(_schunkh), &_schunkh);\r\nif (sch == NULL)\r\nreturn 0;\r\nnet = skb_net(skb);\r\nif ((sch->type == SCTP_CID_INIT) &&\r\n(svc = ip_vs_service_get(net, af, skb->mark, iph.protocol,\r\n&iph.daddr, sh->dest))) {\r\nint ignored;\r\nif (ip_vs_todrop(net_ipvs(net))) {\r\nip_vs_service_put(svc);\r\n*verdict = NF_DROP;\r\nreturn 0;\r\n}\r\n*cpp = ip_vs_schedule(svc, skb, pd, &ignored);\r\nif (!*cpp && ignored <= 0) {\r\nif (!ignored)\r\n*verdict = ip_vs_leave(svc, skb, pd);\r\nelse {\r\nip_vs_service_put(svc);\r\n*verdict = NF_DROP;\r\n}\r\nreturn 0;\r\n}\r\nip_vs_service_put(svc);\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nsctp_snat_handler(struct sk_buff *skb,\r\nstruct ip_vs_protocol *pp, struct ip_vs_conn *cp)\r\n{\r\nsctp_sctphdr_t *sctph;\r\nunsigned int sctphoff;\r\nstruct sk_buff *iter;\r\n__be32 crc32;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6)\r\nsctphoff = sizeof(struct ipv6hdr);\r\nelse\r\n#endif\r\nsctphoff = ip_hdrlen(skb);\r\nif (!skb_make_writable(skb, sctphoff + sizeof(*sctph)))\r\nreturn 0;\r\nif (unlikely(cp->app != NULL)) {\r\nif (pp->csum_check && !pp->csum_check(cp->af, skb, pp))\r\nreturn 0;\r\nif (!ip_vs_app_pkt_out(cp, skb))\r\nreturn 0;\r\n}\r\nsctph = (void *) skb_network_header(skb) + sctphoff;\r\nsctph->source = cp->vport;\r\ncrc32 = sctp_start_cksum((u8 *) sctph, skb_headlen(skb) - sctphoff);\r\nskb_walk_frags(skb, iter)\r\ncrc32 = sctp_update_cksum((u8 *) iter->data, skb_headlen(iter),\r\ncrc32);\r\ncrc32 = sctp_end_cksum(crc32);\r\nsctph->checksum = crc32;\r\nreturn 1;\r\n}\r\nstatic int\r\nsctp_dnat_handler(struct sk_buff *skb,\r\nstruct ip_vs_protocol *pp, struct ip_vs_conn *cp)\r\n{\r\nsctp_sctphdr_t *sctph;\r\nunsigned int sctphoff;\r\nstruct sk_buff *iter;\r\n__be32 crc32;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6)\r\nsctphoff = sizeof(struct ipv6hdr);\r\nelse\r\n#endif\r\nsctphoff = ip_hdrlen(skb);\r\nif (!skb_make_writable(skb, sctphoff + sizeof(*sctph)))\r\nreturn 0;\r\nif (unlikely(cp->app != NULL)) {\r\nif (pp->csum_check && !pp->csum_check(cp->af, skb, pp))\r\nreturn 0;\r\nif (!ip_vs_app_pkt_in(cp, skb))\r\nreturn 0;\r\n}\r\nsctph = (void *) skb_network_header(skb) + sctphoff;\r\nsctph->dest = cp->dport;\r\ncrc32 = sctp_start_cksum((u8 *) sctph, skb_headlen(skb) - sctphoff);\r\nskb_walk_frags(skb, iter)\r\ncrc32 = sctp_update_cksum((u8 *) iter->data, skb_headlen(iter),\r\ncrc32);\r\ncrc32 = sctp_end_cksum(crc32);\r\nsctph->checksum = crc32;\r\nreturn 1;\r\n}\r\nstatic int\r\nsctp_csum_check(int af, struct sk_buff *skb, struct ip_vs_protocol *pp)\r\n{\r\nunsigned int sctphoff;\r\nstruct sctphdr *sh, _sctph;\r\nstruct sk_buff *iter;\r\n__le32 cmp;\r\n__le32 val;\r\n__u32 tmp;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\nsctphoff = sizeof(struct ipv6hdr);\r\nelse\r\n#endif\r\nsctphoff = ip_hdrlen(skb);\r\nsh = skb_header_pointer(skb, sctphoff, sizeof(_sctph), &_sctph);\r\nif (sh == NULL)\r\nreturn 0;\r\ncmp = sh->checksum;\r\ntmp = sctp_start_cksum((__u8 *) sh, skb_headlen(skb));\r\nskb_walk_frags(skb, iter)\r\ntmp = sctp_update_cksum((__u8 *) iter->data,\r\nskb_headlen(iter), tmp);\r\nval = sctp_end_cksum(tmp);\r\nif (val != cmp) {\r\nIP_VS_DBG_RL_PKT(0, af, pp, skb, 0,\r\n"Failed checksum for");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic const char *sctp_state_name(int state)\r\n{\r\nif (state >= IP_VS_SCTP_S_LAST)\r\nreturn "ERR!";\r\nif (sctp_state_name_table[state])\r\nreturn sctp_state_name_table[state];\r\nreturn "?";\r\n}\r\nstatic inline void\r\nset_sctp_state(struct ip_vs_proto_data *pd, struct ip_vs_conn *cp,\r\nint direction, const struct sk_buff *skb)\r\n{\r\nsctp_chunkhdr_t _sctpch, *sch;\r\nunsigned char chunk_type;\r\nint event, next_state;\r\nint ihl;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nihl = cp->af == AF_INET ? ip_hdrlen(skb) : sizeof(struct ipv6hdr);\r\n#else\r\nihl = ip_hdrlen(skb);\r\n#endif\r\nsch = skb_header_pointer(skb, ihl + sizeof(sctp_sctphdr_t),\r\nsizeof(_sctpch), &_sctpch);\r\nif (sch == NULL)\r\nreturn;\r\nchunk_type = sch->type;\r\nif ((sch->type == SCTP_CID_COOKIE_ECHO) ||\r\n(sch->type == SCTP_CID_COOKIE_ACK)) {\r\nsch = skb_header_pointer(skb, (ihl + sizeof(sctp_sctphdr_t) +\r\nsch->length), sizeof(_sctpch), &_sctpch);\r\nif (sch) {\r\nif (sch->type == SCTP_CID_ABORT)\r\nchunk_type = sch->type;\r\n}\r\n}\r\nevent = sctp_events[chunk_type];\r\nif (direction == IP_VS_DIR_OUTPUT)\r\nevent++;\r\nnext_state = sctp_states_table[cp->state][event].next_state;\r\nif (next_state != cp->state) {\r\nstruct ip_vs_dest *dest = cp->dest;\r\nIP_VS_DBG_BUF(8, "%s %s %s:%d->"\r\n"%s:%d state: %s->%s conn->refcnt:%d\n",\r\npd->pp->name,\r\n((direction == IP_VS_DIR_OUTPUT) ?\r\n"output " : "input "),\r\nIP_VS_DBG_ADDR(cp->af, &cp->daddr),\r\nntohs(cp->dport),\r\nIP_VS_DBG_ADDR(cp->af, &cp->caddr),\r\nntohs(cp->cport),\r\nsctp_state_name(cp->state),\r\nsctp_state_name(next_state),\r\natomic_read(&cp->refcnt));\r\nif (dest) {\r\nif (!(cp->flags & IP_VS_CONN_F_INACTIVE) &&\r\n(next_state != IP_VS_SCTP_S_ESTABLISHED)) {\r\natomic_dec(&dest->activeconns);\r\natomic_inc(&dest->inactconns);\r\ncp->flags |= IP_VS_CONN_F_INACTIVE;\r\n} else if ((cp->flags & IP_VS_CONN_F_INACTIVE) &&\r\n(next_state == IP_VS_SCTP_S_ESTABLISHED)) {\r\natomic_inc(&dest->activeconns);\r\natomic_dec(&dest->inactconns);\r\ncp->flags &= ~IP_VS_CONN_F_INACTIVE;\r\n}\r\n}\r\n}\r\nif (likely(pd))\r\ncp->timeout = pd->timeout_table[cp->state = next_state];\r\nelse\r\ncp->timeout = sctp_timeouts[cp->state = next_state];\r\n}\r\nstatic void\r\nsctp_state_transition(struct ip_vs_conn *cp, int direction,\r\nconst struct sk_buff *skb, struct ip_vs_proto_data *pd)\r\n{\r\nspin_lock(&cp->lock);\r\nset_sctp_state(pd, cp, direction, skb);\r\nspin_unlock(&cp->lock);\r\n}\r\nstatic inline __u16 sctp_app_hashkey(__be16 port)\r\n{\r\nreturn (((__force u16)port >> SCTP_APP_TAB_BITS) ^ (__force u16)port)\r\n& SCTP_APP_TAB_MASK;\r\n}\r\nstatic int sctp_register_app(struct net *net, struct ip_vs_app *inc)\r\n{\r\nstruct ip_vs_app *i;\r\n__u16 hash;\r\n__be16 port = inc->port;\r\nint ret = 0;\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(net, IPPROTO_SCTP);\r\nhash = sctp_app_hashkey(port);\r\nspin_lock_bh(&ipvs->sctp_app_lock);\r\nlist_for_each_entry(i, &ipvs->sctp_apps[hash], p_list) {\r\nif (i->port == port) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nlist_add(&inc->p_list, &ipvs->sctp_apps[hash]);\r\natomic_inc(&pd->appcnt);\r\nout:\r\nspin_unlock_bh(&ipvs->sctp_app_lock);\r\nreturn ret;\r\n}\r\nstatic void sctp_unregister_app(struct net *net, struct ip_vs_app *inc)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(net, IPPROTO_SCTP);\r\nspin_lock_bh(&ipvs->sctp_app_lock);\r\natomic_dec(&pd->appcnt);\r\nlist_del(&inc->p_list);\r\nspin_unlock_bh(&ipvs->sctp_app_lock);\r\n}\r\nstatic int sctp_app_conn_bind(struct ip_vs_conn *cp)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(ip_vs_conn_net(cp));\r\nint hash;\r\nstruct ip_vs_app *inc;\r\nint result = 0;\r\nif (IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ)\r\nreturn 0;\r\nhash = sctp_app_hashkey(cp->vport);\r\nspin_lock(&ipvs->sctp_app_lock);\r\nlist_for_each_entry(inc, &ipvs->sctp_apps[hash], p_list) {\r\nif (inc->port == cp->vport) {\r\nif (unlikely(!ip_vs_app_inc_get(inc)))\r\nbreak;\r\nspin_unlock(&ipvs->sctp_app_lock);\r\nIP_VS_DBG_BUF(9, "%s: Binding conn %s:%u->"\r\n"%s:%u to app %s on port %u\n",\r\n__func__,\r\nIP_VS_DBG_ADDR(cp->af, &cp->caddr),\r\nntohs(cp->cport),\r\nIP_VS_DBG_ADDR(cp->af, &cp->vaddr),\r\nntohs(cp->vport),\r\ninc->name, ntohs(inc->port));\r\ncp->app = inc;\r\nif (inc->init_conn)\r\nresult = inc->init_conn(inc, cp);\r\ngoto out;\r\n}\r\n}\r\nspin_unlock(&ipvs->sctp_app_lock);\r\nout:\r\nreturn result;\r\n}\r\nstatic void __ip_vs_sctp_init(struct net *net, struct ip_vs_proto_data *pd)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nip_vs_init_hash_table(ipvs->sctp_apps, SCTP_APP_TAB_SIZE);\r\nspin_lock_init(&ipvs->sctp_app_lock);\r\npd->timeout_table = ip_vs_create_timeout_table((int *)sctp_timeouts,\r\nsizeof(sctp_timeouts));\r\n}\r\nstatic void __ip_vs_sctp_exit(struct net *net, struct ip_vs_proto_data *pd)\r\n{\r\nkfree(pd->timeout_table);\r\n}
