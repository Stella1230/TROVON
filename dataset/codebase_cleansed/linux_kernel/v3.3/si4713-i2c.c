static int usecs_to_dev(unsigned long usecs, unsigned long const array[],\r\nint size)\r\n{\r\nint i;\r\nint rval = -EINVAL;\r\nfor (i = 0; i < size / 2; i++)\r\nif (array[(i * 2) + 1] >= usecs) {\r\nrval = array[i * 2];\r\nbreak;\r\n}\r\nreturn rval;\r\n}\r\nstatic unsigned long dev_to_usecs(int value, unsigned long const array[],\r\nint size)\r\n{\r\nint i;\r\nint rval = -EINVAL;\r\nfor (i = 0; i < size / 2; i++)\r\nif (array[i * 2] == value) {\r\nrval = array[(i * 2) + 1];\r\nbreak;\r\n}\r\nreturn rval;\r\n}\r\nstatic irqreturn_t si4713_handler(int irq, void *dev)\r\n{\r\nstruct si4713_device *sdev = dev;\r\nv4l2_dbg(2, debug, &sdev->sd,\r\n"%s: sending signal to completion work.\n", __func__);\r\ncomplete(&sdev->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int si4713_send_command(struct si4713_device *sdev, const u8 command,\r\nconst u8 args[], const int argn,\r\nu8 response[], const int respn, const int usecs)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sdev->sd);\r\nu8 data1[MAX_ARGS + 1];\r\nint err;\r\nif (!client->adapter)\r\nreturn -ENODEV;\r\ndata1[0] = command;\r\nmemcpy(data1 + 1, args, argn);\r\nDBG_BUFFER(&sdev->sd, "Parameters", data1, argn + 1);\r\nerr = i2c_master_send(client, data1, argn + 1);\r\nif (err != argn + 1) {\r\nv4l2_err(&sdev->sd, "Error while sending command 0x%02x\n",\r\ncommand);\r\nreturn (err > 0) ? -EIO : err;\r\n}\r\nif (!wait_for_completion_timeout(&sdev->work,\r\nusecs_to_jiffies(usecs) + 1))\r\nv4l2_warn(&sdev->sd,\r\n"(%s) Device took too much time to answer.\n",\r\n__func__);\r\nerr = i2c_master_recv(client, response, respn);\r\nif (err != respn) {\r\nv4l2_err(&sdev->sd,\r\n"Error while reading response for command 0x%02x\n",\r\ncommand);\r\nreturn (err > 0) ? -EIO : err;\r\n}\r\nDBG_BUFFER(&sdev->sd, "Response", response, respn);\r\nif (check_command_failed(response[0]))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int si4713_read_property(struct si4713_device *sdev, u16 prop, u32 *pv)\r\n{\r\nint err;\r\nu8 val[SI4713_GET_PROP_NRESP];\r\nconst u8 args[SI4713_GET_PROP_NARGS] = {\r\n0x00,\r\nmsb(prop),\r\nlsb(prop),\r\n};\r\nerr = si4713_send_command(sdev, SI4713_CMD_GET_PROPERTY,\r\nargs, ARRAY_SIZE(args), val,\r\nARRAY_SIZE(val), DEFAULT_TIMEOUT);\r\nif (err < 0)\r\nreturn err;\r\n*pv = compose_u16(val[2], val[3]);\r\nv4l2_dbg(1, debug, &sdev->sd,\r\n"%s: property=0x%02x value=0x%02x status=0x%02x\n",\r\n__func__, prop, *pv, val[0]);\r\nreturn err;\r\n}\r\nstatic int si4713_write_property(struct si4713_device *sdev, u16 prop, u16 val)\r\n{\r\nint rval;\r\nu8 resp[SI4713_SET_PROP_NRESP];\r\nconst u8 args[SI4713_SET_PROP_NARGS] = {\r\n0x00,\r\nmsb(prop),\r\nlsb(prop),\r\nmsb(val),\r\nlsb(val),\r\n};\r\nrval = si4713_send_command(sdev, SI4713_CMD_SET_PROPERTY,\r\nargs, ARRAY_SIZE(args),\r\nresp, ARRAY_SIZE(resp),\r\nDEFAULT_TIMEOUT);\r\nif (rval < 0)\r\nreturn rval;\r\nv4l2_dbg(1, debug, &sdev->sd,\r\n"%s: property=0x%02x value=0x%02x status=0x%02x\n",\r\n__func__, prop, val, resp[0]);\r\nmsleep(TIMEOUT_SET_PROPERTY);\r\nreturn rval;\r\n}\r\nstatic int si4713_powerup(struct si4713_device *sdev)\r\n{\r\nint err;\r\nu8 resp[SI4713_PWUP_NRESP];\r\nconst u8 args[SI4713_PWUP_NARGS] = {\r\nSI4713_PWUP_CTSIEN | SI4713_PWUP_GPO2OEN | SI4713_PWUP_FUNC_TX,\r\nSI4713_PWUP_OPMOD_ANALOG,\r\n};\r\nif (sdev->power_state)\r\nreturn 0;\r\nerr = regulator_bulk_enable(ARRAY_SIZE(sdev->supplies),\r\nsdev->supplies);\r\nif (err) {\r\nv4l2_err(&sdev->sd, "Failed to enable supplies: %d\n", err);\r\nreturn err;\r\n}\r\nif (gpio_is_valid(sdev->gpio_reset)) {\r\nudelay(50);\r\ngpio_set_value(sdev->gpio_reset, 1);\r\n}\r\nerr = si4713_send_command(sdev, SI4713_CMD_POWER_UP,\r\nargs, ARRAY_SIZE(args),\r\nresp, ARRAY_SIZE(resp),\r\nTIMEOUT_POWER_UP);\r\nif (!err) {\r\nv4l2_dbg(1, debug, &sdev->sd, "Powerup response: 0x%02x\n",\r\nresp[0]);\r\nv4l2_dbg(1, debug, &sdev->sd, "Device in power up mode\n");\r\nsdev->power_state = POWER_ON;\r\nerr = si4713_write_property(sdev, SI4713_GPO_IEN,\r\nSI4713_STC_INT | SI4713_CTS);\r\n} else {\r\nif (gpio_is_valid(sdev->gpio_reset))\r\ngpio_set_value(sdev->gpio_reset, 0);\r\nerr = regulator_bulk_disable(ARRAY_SIZE(sdev->supplies),\r\nsdev->supplies);\r\nif (err)\r\nv4l2_err(&sdev->sd,\r\n"Failed to disable supplies: %d\n", err);\r\n}\r\nreturn err;\r\n}\r\nstatic int si4713_powerdown(struct si4713_device *sdev)\r\n{\r\nint err;\r\nu8 resp[SI4713_PWDN_NRESP];\r\nif (!sdev->power_state)\r\nreturn 0;\r\nerr = si4713_send_command(sdev, SI4713_CMD_POWER_DOWN,\r\nNULL, 0,\r\nresp, ARRAY_SIZE(resp),\r\nDEFAULT_TIMEOUT);\r\nif (!err) {\r\nv4l2_dbg(1, debug, &sdev->sd, "Power down response: 0x%02x\n",\r\nresp[0]);\r\nv4l2_dbg(1, debug, &sdev->sd, "Device in reset mode\n");\r\nif (gpio_is_valid(sdev->gpio_reset))\r\ngpio_set_value(sdev->gpio_reset, 0);\r\nerr = regulator_bulk_disable(ARRAY_SIZE(sdev->supplies),\r\nsdev->supplies);\r\nif (err)\r\nv4l2_err(&sdev->sd,\r\n"Failed to disable supplies: %d\n", err);\r\nsdev->power_state = POWER_OFF;\r\n}\r\nreturn err;\r\n}\r\nstatic int si4713_checkrev(struct si4713_device *sdev)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sdev->sd);\r\nint rval;\r\nu8 resp[SI4713_GETREV_NRESP];\r\nmutex_lock(&sdev->mutex);\r\nrval = si4713_send_command(sdev, SI4713_CMD_GET_REV,\r\nNULL, 0,\r\nresp, ARRAY_SIZE(resp),\r\nDEFAULT_TIMEOUT);\r\nif (rval < 0)\r\ngoto unlock;\r\nif (resp[1] == SI4713_PRODUCT_NUMBER) {\r\nv4l2_info(&sdev->sd, "chip found @ 0x%02x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\n} else {\r\nv4l2_err(&sdev->sd, "Invalid product number\n");\r\nrval = -EINVAL;\r\n}\r\nunlock:\r\nmutex_unlock(&sdev->mutex);\r\nreturn rval;\r\n}\r\nstatic int si4713_wait_stc(struct si4713_device *sdev, const int usecs)\r\n{\r\nint err;\r\nu8 resp[SI4713_GET_STATUS_NRESP];\r\nif (!wait_for_completion_timeout(&sdev->work,\r\nusecs_to_jiffies(usecs) + 1))\r\nv4l2_warn(&sdev->sd,\r\n"%s: device took too much time to answer (%d usec).\n",\r\n__func__, usecs);\r\nerr = si4713_send_command(sdev, SI4713_CMD_GET_INT_STATUS,\r\nNULL, 0,\r\nresp, ARRAY_SIZE(resp),\r\nDEFAULT_TIMEOUT);\r\nif (err < 0)\r\ngoto exit;\r\nv4l2_dbg(1, debug, &sdev->sd,\r\n"%s: status bits: 0x%02x\n", __func__, resp[0]);\r\nif (!(resp[0] & SI4713_STC_INT))\r\nerr = -EIO;\r\nexit:\r\nreturn err;\r\n}\r\nstatic int si4713_tx_tune_freq(struct si4713_device *sdev, u16 frequency)\r\n{\r\nint err;\r\nu8 val[SI4713_TXFREQ_NRESP];\r\nconst u8 args[SI4713_TXFREQ_NARGS] = {\r\n0x00,\r\nmsb(frequency),\r\nlsb(frequency),\r\n};\r\nerr = si4713_send_command(sdev, SI4713_CMD_TX_TUNE_FREQ,\r\nargs, ARRAY_SIZE(args), val,\r\nARRAY_SIZE(val), DEFAULT_TIMEOUT);\r\nif (err < 0)\r\nreturn err;\r\nv4l2_dbg(1, debug, &sdev->sd,\r\n"%s: frequency=0x%02x status=0x%02x\n", __func__,\r\nfrequency, val[0]);\r\nerr = si4713_wait_stc(sdev, TIMEOUT_TX_TUNE);\r\nif (err < 0)\r\nreturn err;\r\nreturn compose_u16(args[1], args[2]);\r\n}\r\nstatic int si4713_tx_tune_power(struct si4713_device *sdev, u8 power,\r\nu8 antcap)\r\n{\r\nint err;\r\nu8 val[SI4713_TXPWR_NRESP];\r\nconst u8 args[SI4713_TXPWR_NARGS] = {\r\n0x00,\r\n0x00,\r\npower,\r\nantcap,\r\n};\r\nif (((power > 0) && (power < SI4713_MIN_POWER)) ||\r\npower > SI4713_MAX_POWER || antcap > SI4713_MAX_ANTCAP)\r\nreturn -EDOM;\r\nerr = si4713_send_command(sdev, SI4713_CMD_TX_TUNE_POWER,\r\nargs, ARRAY_SIZE(args), val,\r\nARRAY_SIZE(val), DEFAULT_TIMEOUT);\r\nif (err < 0)\r\nreturn err;\r\nv4l2_dbg(1, debug, &sdev->sd,\r\n"%s: power=0x%02x antcap=0x%02x status=0x%02x\n",\r\n__func__, power, antcap, val[0]);\r\nreturn si4713_wait_stc(sdev, TIMEOUT_TX_TUNE_POWER);\r\n}\r\nstatic int si4713_tx_tune_measure(struct si4713_device *sdev, u16 frequency,\r\nu8 antcap)\r\n{\r\nint err;\r\nu8 val[SI4713_TXMEA_NRESP];\r\nconst u8 args[SI4713_TXMEA_NARGS] = {\r\n0x00,\r\nmsb(frequency),\r\nlsb(frequency),\r\nantcap,\r\n};\r\nsdev->tune_rnl = DEFAULT_TUNE_RNL;\r\nif (antcap > SI4713_MAX_ANTCAP)\r\nreturn -EDOM;\r\nerr = si4713_send_command(sdev, SI4713_CMD_TX_TUNE_MEASURE,\r\nargs, ARRAY_SIZE(args), val,\r\nARRAY_SIZE(val), DEFAULT_TIMEOUT);\r\nif (err < 0)\r\nreturn err;\r\nv4l2_dbg(1, debug, &sdev->sd,\r\n"%s: frequency=0x%02x antcap=0x%02x status=0x%02x\n",\r\n__func__, frequency, antcap, val[0]);\r\nreturn si4713_wait_stc(sdev, TIMEOUT_TX_TUNE);\r\n}\r\nstatic int si4713_tx_tune_status(struct si4713_device *sdev, u8 intack,\r\nu16 *frequency, u8 *power,\r\nu8 *antcap, u8 *noise)\r\n{\r\nint err;\r\nu8 val[SI4713_TXSTATUS_NRESP];\r\nconst u8 args[SI4713_TXSTATUS_NARGS] = {\r\nintack & SI4713_INTACK_MASK,\r\n};\r\nerr = si4713_send_command(sdev, SI4713_CMD_TX_TUNE_STATUS,\r\nargs, ARRAY_SIZE(args), val,\r\nARRAY_SIZE(val), DEFAULT_TIMEOUT);\r\nif (!err) {\r\nv4l2_dbg(1, debug, &sdev->sd,\r\n"%s: status=0x%02x\n", __func__, val[0]);\r\n*frequency = compose_u16(val[2], val[3]);\r\nsdev->frequency = *frequency;\r\n*power = val[5];\r\n*antcap = val[6];\r\n*noise = val[7];\r\nv4l2_dbg(1, debug, &sdev->sd, "%s: response: %d x 10 kHz "\r\n"(power %d, antcap %d, rnl %d)\n", __func__,\r\n*frequency, *power, *antcap, *noise);\r\n}\r\nreturn err;\r\n}\r\nstatic int si4713_tx_rds_buff(struct si4713_device *sdev, u8 mode, u16 rdsb,\r\nu16 rdsc, u16 rdsd, s8 *cbleft)\r\n{\r\nint err;\r\nu8 val[SI4713_RDSBUFF_NRESP];\r\nconst u8 args[SI4713_RDSBUFF_NARGS] = {\r\nmode & SI4713_RDSBUFF_MODE_MASK,\r\nmsb(rdsb),\r\nlsb(rdsb),\r\nmsb(rdsc),\r\nlsb(rdsc),\r\nmsb(rdsd),\r\nlsb(rdsd),\r\n};\r\nerr = si4713_send_command(sdev, SI4713_CMD_TX_RDS_BUFF,\r\nargs, ARRAY_SIZE(args), val,\r\nARRAY_SIZE(val), DEFAULT_TIMEOUT);\r\nif (!err) {\r\nv4l2_dbg(1, debug, &sdev->sd,\r\n"%s: status=0x%02x\n", __func__, val[0]);\r\n*cbleft = (s8)val[2] - val[3];\r\nv4l2_dbg(1, debug, &sdev->sd, "%s: response: interrupts"\r\n" 0x%02x cb avail: %d cb used %d fifo avail"\r\n" %d fifo used %d\n", __func__, val[1],\r\nval[2], val[3], val[4], val[5]);\r\n}\r\nreturn err;\r\n}\r\nstatic int si4713_tx_rds_ps(struct si4713_device *sdev, u8 psid,\r\nunsigned char *pschar)\r\n{\r\nint err;\r\nu8 val[SI4713_RDSPS_NRESP];\r\nconst u8 args[SI4713_RDSPS_NARGS] = {\r\npsid & SI4713_RDSPS_PSID_MASK,\r\npschar[0],\r\npschar[1],\r\npschar[2],\r\npschar[3],\r\n};\r\nerr = si4713_send_command(sdev, SI4713_CMD_TX_RDS_PS,\r\nargs, ARRAY_SIZE(args), val,\r\nARRAY_SIZE(val), DEFAULT_TIMEOUT);\r\nif (err < 0)\r\nreturn err;\r\nv4l2_dbg(1, debug, &sdev->sd, "%s: status=0x%02x\n", __func__, val[0]);\r\nreturn err;\r\n}\r\nstatic int si4713_set_power_state(struct si4713_device *sdev, u8 value)\r\n{\r\nint rval;\r\nmutex_lock(&sdev->mutex);\r\nif (value)\r\nrval = si4713_powerup(sdev);\r\nelse\r\nrval = si4713_powerdown(sdev);\r\nmutex_unlock(&sdev->mutex);\r\nreturn rval;\r\n}\r\nstatic int si4713_set_mute(struct si4713_device *sdev, u16 mute)\r\n{\r\nint rval = 0;\r\nmute = set_mute(mute);\r\nmutex_lock(&sdev->mutex);\r\nif (sdev->power_state)\r\nrval = si4713_write_property(sdev,\r\nSI4713_TX_LINE_INPUT_MUTE, mute);\r\nif (rval >= 0)\r\nsdev->mute = get_mute(mute);\r\nmutex_unlock(&sdev->mutex);\r\nreturn rval;\r\n}\r\nstatic int si4713_set_rds_ps_name(struct si4713_device *sdev, char *ps_name)\r\n{\r\nint rval = 0, i;\r\nu8 len = 0;\r\nif (!strlen(ps_name))\r\nmemset(ps_name, 0, MAX_RDS_PS_NAME + 1);\r\nmutex_lock(&sdev->mutex);\r\nif (sdev->power_state) {\r\nfor (i = 0; i < MAX_RDS_PS_NAME; i += (RDS_BLOCK / 2)) {\r\nrval = si4713_tx_rds_ps(sdev, (i / (RDS_BLOCK / 2)),\r\nps_name + i);\r\nif (rval < 0)\r\ngoto unlock;\r\n}\r\nif (strlen(ps_name))\r\nlen = strlen(ps_name) - 1;\r\nelse\r\nlen = 1;\r\nrval = si4713_write_property(sdev,\r\nSI4713_TX_RDS_PS_MESSAGE_COUNT,\r\nrds_ps_nblocks(len));\r\nif (rval < 0)\r\ngoto unlock;\r\nrval = si4713_write_property(sdev,\r\nSI4713_TX_RDS_PS_REPEAT_COUNT,\r\nDEFAULT_RDS_PS_REPEAT_COUNT * 2);\r\nif (rval < 0)\r\ngoto unlock;\r\n}\r\nstrncpy(sdev->rds_info.ps_name, ps_name, MAX_RDS_PS_NAME);\r\nunlock:\r\nmutex_unlock(&sdev->mutex);\r\nreturn rval;\r\n}\r\nstatic int si4713_set_rds_radio_text(struct si4713_device *sdev, char *rt)\r\n{\r\nint rval = 0, i;\r\nu16 t_index = 0;\r\nu8 b_index = 0, cr_inserted = 0;\r\ns8 left;\r\nmutex_lock(&sdev->mutex);\r\nif (!sdev->power_state)\r\ngoto copy;\r\nrval = si4713_tx_rds_buff(sdev, RDS_BLOCK_CLEAR, 0, 0, 0, &left);\r\nif (rval < 0)\r\ngoto unlock;\r\nif (!strlen(rt))\r\ngoto copy;\r\ndo {\r\nif (t_index < (RDS_RADIOTEXT_INDEX_MAX *\r\nRDS_RADIOTEXT_BLK_SIZE)) {\r\nfor (i = 0; i < RDS_RADIOTEXT_BLK_SIZE; i++) {\r\nif (!rt[t_index + i] || rt[t_index + i] ==\r\nRDS_CARRIAGE_RETURN) {\r\nrt[t_index + i] = RDS_CARRIAGE_RETURN;\r\ncr_inserted = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nrval = si4713_tx_rds_buff(sdev, RDS_BLOCK_LOAD,\r\ncompose_u16(RDS_RADIOTEXT_2A, b_index++),\r\ncompose_u16(rt[t_index], rt[t_index + 1]),\r\ncompose_u16(rt[t_index + 2], rt[t_index + 3]),\r\n&left);\r\nif (rval < 0)\r\ngoto unlock;\r\nt_index += RDS_RADIOTEXT_BLK_SIZE;\r\nif (cr_inserted)\r\nbreak;\r\n} while (left > 0);\r\ncopy:\r\nstrncpy(sdev->rds_info.radio_text, rt, MAX_RDS_RADIO_TEXT);\r\nunlock:\r\nmutex_unlock(&sdev->mutex);\r\nreturn rval;\r\n}\r\nstatic int si4713_choose_econtrol_action(struct si4713_device *sdev, u32 id,\r\nu32 **shadow, s32 *bit, s32 *mask, u16 *property, int *mul,\r\nunsigned long **table, int *size)\r\n{\r\ns32 rval = 0;\r\nswitch (id) {\r\ncase V4L2_CID_RDS_TX_PI:\r\n*property = SI4713_TX_RDS_PI;\r\n*mul = 1;\r\n*shadow = &sdev->rds_info.pi;\r\nbreak;\r\ncase V4L2_CID_AUDIO_COMPRESSION_THRESHOLD:\r\n*property = SI4713_TX_ACOMP_THRESHOLD;\r\n*mul = 1;\r\n*shadow = &sdev->acomp_info.threshold;\r\nbreak;\r\ncase V4L2_CID_AUDIO_COMPRESSION_GAIN:\r\n*property = SI4713_TX_ACOMP_GAIN;\r\n*mul = 1;\r\n*shadow = &sdev->acomp_info.gain;\r\nbreak;\r\ncase V4L2_CID_PILOT_TONE_FREQUENCY:\r\n*property = SI4713_TX_PILOT_FREQUENCY;\r\n*mul = 1;\r\n*shadow = &sdev->pilot_info.frequency;\r\nbreak;\r\ncase V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME:\r\n*property = SI4713_TX_ACOMP_ATTACK_TIME;\r\n*mul = ATTACK_TIME_UNIT;\r\n*shadow = &sdev->acomp_info.attack_time;\r\nbreak;\r\ncase V4L2_CID_PILOT_TONE_DEVIATION:\r\n*property = SI4713_TX_PILOT_DEVIATION;\r\n*mul = 10;\r\n*shadow = &sdev->pilot_info.deviation;\r\nbreak;\r\ncase V4L2_CID_AUDIO_LIMITER_DEVIATION:\r\n*property = SI4713_TX_AUDIO_DEVIATION;\r\n*mul = 10;\r\n*shadow = &sdev->limiter_info.deviation;\r\nbreak;\r\ncase V4L2_CID_RDS_TX_DEVIATION:\r\n*property = SI4713_TX_RDS_DEVIATION;\r\n*mul = 1;\r\n*shadow = &sdev->rds_info.deviation;\r\nbreak;\r\ncase V4L2_CID_RDS_TX_PTY:\r\n*property = SI4713_TX_RDS_PS_MISC;\r\n*bit = 5;\r\n*mask = 0x1F << 5;\r\n*shadow = &sdev->rds_info.pty;\r\nbreak;\r\ncase V4L2_CID_AUDIO_LIMITER_ENABLED:\r\n*property = SI4713_TX_ACOMP_ENABLE;\r\n*bit = 1;\r\n*mask = 1 << 1;\r\n*shadow = &sdev->limiter_info.enabled;\r\nbreak;\r\ncase V4L2_CID_AUDIO_COMPRESSION_ENABLED:\r\n*property = SI4713_TX_ACOMP_ENABLE;\r\n*bit = 0;\r\n*mask = 1 << 0;\r\n*shadow = &sdev->acomp_info.enabled;\r\nbreak;\r\ncase V4L2_CID_PILOT_TONE_ENABLED:\r\n*property = SI4713_TX_COMPONENT_ENABLE;\r\n*bit = 0;\r\n*mask = 1 << 0;\r\n*shadow = &sdev->pilot_info.enabled;\r\nbreak;\r\ncase V4L2_CID_AUDIO_LIMITER_RELEASE_TIME:\r\n*property = SI4713_TX_LIMITER_RELEASE_TIME;\r\n*table = limiter_times;\r\n*size = ARRAY_SIZE(limiter_times);\r\n*shadow = &sdev->limiter_info.release_time;\r\nbreak;\r\ncase V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME:\r\n*property = SI4713_TX_ACOMP_RELEASE_TIME;\r\n*table = acomp_rtimes;\r\n*size = ARRAY_SIZE(acomp_rtimes);\r\n*shadow = &sdev->acomp_info.release_time;\r\nbreak;\r\ncase V4L2_CID_TUNE_PREEMPHASIS:\r\n*property = SI4713_TX_PREEMPHASIS;\r\n*table = preemphasis_values;\r\n*size = ARRAY_SIZE(preemphasis_values);\r\n*shadow = &sdev->preemphasis;\r\nbreak;\r\ndefault:\r\nrval = -EINVAL;\r\n};\r\nreturn rval;\r\n}\r\nstatic int si4713_write_econtrol_string(struct si4713_device *sdev,\r\nstruct v4l2_ext_control *control)\r\n{\r\nstruct v4l2_queryctrl vqc;\r\nint len;\r\ns32 rval = 0;\r\nvqc.id = control->id;\r\nrval = si4713_queryctrl(&sdev->sd, &vqc);\r\nif (rval < 0)\r\ngoto exit;\r\nswitch (control->id) {\r\ncase V4L2_CID_RDS_TX_PS_NAME: {\r\nchar ps_name[MAX_RDS_PS_NAME + 1];\r\nlen = control->size - 1;\r\nif (len < 0 || len > MAX_RDS_PS_NAME) {\r\nrval = -ERANGE;\r\ngoto exit;\r\n}\r\nrval = copy_from_user(ps_name, control->string, len);\r\nif (rval) {\r\nrval = -EFAULT;\r\ngoto exit;\r\n}\r\nps_name[len] = '\0';\r\nif (strlen(ps_name) % vqc.step) {\r\nrval = -ERANGE;\r\ngoto exit;\r\n}\r\nrval = si4713_set_rds_ps_name(sdev, ps_name);\r\n}\r\nbreak;\r\ncase V4L2_CID_RDS_TX_RADIO_TEXT: {\r\nchar radio_text[MAX_RDS_RADIO_TEXT + 1];\r\nlen = control->size - 1;\r\nif (len < 0 || len > MAX_RDS_RADIO_TEXT) {\r\nrval = -ERANGE;\r\ngoto exit;\r\n}\r\nrval = copy_from_user(radio_text, control->string, len);\r\nif (rval) {\r\nrval = -EFAULT;\r\ngoto exit;\r\n}\r\nradio_text[len] = '\0';\r\nif (strlen(radio_text) % vqc.step) {\r\nrval = -ERANGE;\r\ngoto exit;\r\n}\r\nrval = si4713_set_rds_radio_text(sdev, radio_text);\r\n}\r\nbreak;\r\ndefault:\r\nrval = -EINVAL;\r\nbreak;\r\n};\r\nexit:\r\nreturn rval;\r\n}\r\nstatic int validate_range(struct v4l2_subdev *sd,\r\nstruct v4l2_ext_control *control)\r\n{\r\nstruct v4l2_queryctrl vqc;\r\nint rval;\r\nvqc.id = control->id;\r\nrval = si4713_queryctrl(sd, &vqc);\r\nif (rval < 0)\r\ngoto exit;\r\nif (control->value < vqc.minimum || control->value > vqc.maximum)\r\nrval = -ERANGE;\r\nexit:\r\nreturn rval;\r\n}\r\nstatic int si4713_write_econtrol_tune(struct si4713_device *sdev,\r\nstruct v4l2_ext_control *control)\r\n{\r\ns32 rval = 0;\r\nu8 power, antcap;\r\nrval = validate_range(&sdev->sd, control);\r\nif (rval < 0)\r\ngoto exit;\r\nmutex_lock(&sdev->mutex);\r\nswitch (control->id) {\r\ncase V4L2_CID_TUNE_POWER_LEVEL:\r\npower = control->value;\r\nantcap = sdev->antenna_capacitor;\r\nbreak;\r\ncase V4L2_CID_TUNE_ANTENNA_CAPACITOR:\r\npower = sdev->power_level;\r\nantcap = control->value;\r\nbreak;\r\ndefault:\r\nrval = -EINVAL;\r\ngoto unlock;\r\n};\r\nif (sdev->power_state)\r\nrval = si4713_tx_tune_power(sdev, power, antcap);\r\nif (rval == 0) {\r\nsdev->power_level = power;\r\nsdev->antenna_capacitor = antcap;\r\n}\r\nunlock:\r\nmutex_unlock(&sdev->mutex);\r\nexit:\r\nreturn rval;\r\n}\r\nstatic int si4713_write_econtrol_integers(struct si4713_device *sdev,\r\nstruct v4l2_ext_control *control)\r\n{\r\ns32 rval;\r\nu32 *shadow = NULL, val = 0;\r\ns32 bit = 0, mask = 0;\r\nu16 property = 0;\r\nint mul = 0;\r\nunsigned long *table = NULL;\r\nint size = 0;\r\nrval = validate_range(&sdev->sd, control);\r\nif (rval < 0)\r\ngoto exit;\r\nrval = si4713_choose_econtrol_action(sdev, control->id, &shadow, &bit,\r\n&mask, &property, &mul, &table, &size);\r\nif (rval < 0)\r\ngoto exit;\r\nval = control->value;\r\nif (mul) {\r\nval = control->value / mul;\r\n} else if (table) {\r\nrval = usecs_to_dev(control->value, table, size);\r\nif (rval < 0)\r\ngoto exit;\r\nval = rval;\r\nrval = 0;\r\n}\r\nmutex_lock(&sdev->mutex);\r\nif (sdev->power_state) {\r\nif (mask) {\r\nrval = si4713_read_property(sdev, property, &val);\r\nif (rval < 0)\r\ngoto unlock;\r\nval = set_bits(val, control->value, bit, mask);\r\n}\r\nrval = si4713_write_property(sdev, property, val);\r\nif (rval < 0)\r\ngoto unlock;\r\nif (mask)\r\nval = control->value;\r\n}\r\nif (mul) {\r\n*shadow = val * mul;\r\n} else if (table) {\r\nrval = dev_to_usecs(val, table, size);\r\nif (rval < 0)\r\ngoto unlock;\r\n*shadow = rval;\r\nrval = 0;\r\n} else {\r\n*shadow = val;\r\n}\r\nunlock:\r\nmutex_unlock(&sdev->mutex);\r\nexit:\r\nreturn rval;\r\n}\r\nstatic int si4713_setup(struct si4713_device *sdev)\r\n{\r\nstruct v4l2_ext_control ctrl;\r\nstruct v4l2_frequency f;\r\nstruct v4l2_modulator vm;\r\nstruct si4713_device *tmp;\r\nint rval = 0;\r\ntmp = kmalloc(sizeof(*tmp), GFP_KERNEL);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nmutex_lock(&sdev->mutex);\r\nmemcpy(tmp, sdev, sizeof(*sdev));\r\nmutex_unlock(&sdev->mutex);\r\nctrl.id = V4L2_CID_RDS_TX_PI;\r\nctrl.value = tmp->rds_info.pi;\r\nrval |= si4713_write_econtrol_integers(sdev, &ctrl);\r\nctrl.id = V4L2_CID_AUDIO_COMPRESSION_THRESHOLD;\r\nctrl.value = tmp->acomp_info.threshold;\r\nrval |= si4713_write_econtrol_integers(sdev, &ctrl);\r\nctrl.id = V4L2_CID_AUDIO_COMPRESSION_GAIN;\r\nctrl.value = tmp->acomp_info.gain;\r\nrval |= si4713_write_econtrol_integers(sdev, &ctrl);\r\nctrl.id = V4L2_CID_PILOT_TONE_FREQUENCY;\r\nctrl.value = tmp->pilot_info.frequency;\r\nrval |= si4713_write_econtrol_integers(sdev, &ctrl);\r\nctrl.id = V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME;\r\nctrl.value = tmp->acomp_info.attack_time;\r\nrval |= si4713_write_econtrol_integers(sdev, &ctrl);\r\nctrl.id = V4L2_CID_PILOT_TONE_DEVIATION;\r\nctrl.value = tmp->pilot_info.deviation;\r\nrval |= si4713_write_econtrol_integers(sdev, &ctrl);\r\nctrl.id = V4L2_CID_AUDIO_LIMITER_DEVIATION;\r\nctrl.value = tmp->limiter_info.deviation;\r\nrval |= si4713_write_econtrol_integers(sdev, &ctrl);\r\nctrl.id = V4L2_CID_RDS_TX_DEVIATION;\r\nctrl.value = tmp->rds_info.deviation;\r\nrval |= si4713_write_econtrol_integers(sdev, &ctrl);\r\nctrl.id = V4L2_CID_RDS_TX_PTY;\r\nctrl.value = tmp->rds_info.pty;\r\nrval |= si4713_write_econtrol_integers(sdev, &ctrl);\r\nctrl.id = V4L2_CID_AUDIO_LIMITER_ENABLED;\r\nctrl.value = tmp->limiter_info.enabled;\r\nrval |= si4713_write_econtrol_integers(sdev, &ctrl);\r\nctrl.id = V4L2_CID_AUDIO_COMPRESSION_ENABLED;\r\nctrl.value = tmp->acomp_info.enabled;\r\nrval |= si4713_write_econtrol_integers(sdev, &ctrl);\r\nctrl.id = V4L2_CID_PILOT_TONE_ENABLED;\r\nctrl.value = tmp->pilot_info.enabled;\r\nrval |= si4713_write_econtrol_integers(sdev, &ctrl);\r\nctrl.id = V4L2_CID_AUDIO_LIMITER_RELEASE_TIME;\r\nctrl.value = tmp->limiter_info.release_time;\r\nrval |= si4713_write_econtrol_integers(sdev, &ctrl);\r\nctrl.id = V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME;\r\nctrl.value = tmp->acomp_info.release_time;\r\nrval |= si4713_write_econtrol_integers(sdev, &ctrl);\r\nctrl.id = V4L2_CID_TUNE_PREEMPHASIS;\r\nctrl.value = tmp->preemphasis;\r\nrval |= si4713_write_econtrol_integers(sdev, &ctrl);\r\nctrl.id = V4L2_CID_RDS_TX_PS_NAME;\r\nrval |= si4713_set_rds_ps_name(sdev, tmp->rds_info.ps_name);\r\nctrl.id = V4L2_CID_RDS_TX_RADIO_TEXT;\r\nrval |= si4713_set_rds_radio_text(sdev, tmp->rds_info.radio_text);\r\nf.frequency = tmp->frequency ? tmp->frequency : DEFAULT_FREQUENCY;\r\nf.frequency = si4713_to_v4l2(f.frequency);\r\nrval |= si4713_s_frequency(&sdev->sd, &f);\r\nctrl.id = V4L2_CID_TUNE_POWER_LEVEL;\r\nctrl.value = tmp->power_level;\r\nrval |= si4713_write_econtrol_tune(sdev, &ctrl);\r\nctrl.id = V4L2_CID_TUNE_ANTENNA_CAPACITOR;\r\nctrl.value = tmp->antenna_capacitor;\r\nrval |= si4713_write_econtrol_tune(sdev, &ctrl);\r\nvm.index = 0;\r\nif (tmp->stereo)\r\nvm.txsubchans = V4L2_TUNER_SUB_STEREO;\r\nelse\r\nvm.txsubchans = V4L2_TUNER_SUB_MONO;\r\nif (tmp->rds_info.enabled)\r\nvm.txsubchans |= V4L2_TUNER_SUB_RDS;\r\nsi4713_s_modulator(&sdev->sd, &vm);\r\nkfree(tmp);\r\nreturn rval;\r\n}\r\nstatic int si4713_initialize(struct si4713_device *sdev)\r\n{\r\nint rval;\r\nrval = si4713_set_power_state(sdev, POWER_ON);\r\nif (rval < 0)\r\ngoto exit;\r\nrval = si4713_checkrev(sdev);\r\nif (rval < 0)\r\ngoto exit;\r\nrval = si4713_set_power_state(sdev, POWER_OFF);\r\nif (rval < 0)\r\ngoto exit;\r\nmutex_lock(&sdev->mutex);\r\nsdev->rds_info.pi = DEFAULT_RDS_PI;\r\nsdev->rds_info.pty = DEFAULT_RDS_PTY;\r\nsdev->rds_info.deviation = DEFAULT_RDS_DEVIATION;\r\nstrlcpy(sdev->rds_info.ps_name, DEFAULT_RDS_PS_NAME, MAX_RDS_PS_NAME);\r\nstrlcpy(sdev->rds_info.radio_text, DEFAULT_RDS_RADIO_TEXT,\r\nMAX_RDS_RADIO_TEXT);\r\nsdev->rds_info.enabled = 1;\r\nsdev->limiter_info.release_time = DEFAULT_LIMITER_RTIME;\r\nsdev->limiter_info.deviation = DEFAULT_LIMITER_DEV;\r\nsdev->limiter_info.enabled = 1;\r\nsdev->pilot_info.deviation = DEFAULT_PILOT_DEVIATION;\r\nsdev->pilot_info.frequency = DEFAULT_PILOT_FREQUENCY;\r\nsdev->pilot_info.enabled = 1;\r\nsdev->acomp_info.release_time = DEFAULT_ACOMP_RTIME;\r\nsdev->acomp_info.attack_time = DEFAULT_ACOMP_ATIME;\r\nsdev->acomp_info.threshold = DEFAULT_ACOMP_THRESHOLD;\r\nsdev->acomp_info.gain = DEFAULT_ACOMP_GAIN;\r\nsdev->acomp_info.enabled = 1;\r\nsdev->frequency = DEFAULT_FREQUENCY;\r\nsdev->preemphasis = DEFAULT_PREEMPHASIS;\r\nsdev->mute = DEFAULT_MUTE;\r\nsdev->power_level = DEFAULT_POWER_LEVEL;\r\nsdev->antenna_capacitor = 0;\r\nsdev->stereo = 1;\r\nsdev->tune_rnl = DEFAULT_TUNE_RNL;\r\nmutex_unlock(&sdev->mutex);\r\nexit:\r\nreturn rval;\r\n}\r\nstatic int si4713_read_econtrol_string(struct si4713_device *sdev,\r\nstruct v4l2_ext_control *control)\r\n{\r\ns32 rval = 0;\r\nswitch (control->id) {\r\ncase V4L2_CID_RDS_TX_PS_NAME:\r\nif (strlen(sdev->rds_info.ps_name) + 1 > control->size) {\r\ncontrol->size = MAX_RDS_PS_NAME + 1;\r\nrval = -ENOSPC;\r\ngoto exit;\r\n}\r\nrval = copy_to_user(control->string, sdev->rds_info.ps_name,\r\nstrlen(sdev->rds_info.ps_name) + 1);\r\nif (rval)\r\nrval = -EFAULT;\r\nbreak;\r\ncase V4L2_CID_RDS_TX_RADIO_TEXT:\r\nif (strlen(sdev->rds_info.radio_text) + 1 > control->size) {\r\ncontrol->size = MAX_RDS_RADIO_TEXT + 1;\r\nrval = -ENOSPC;\r\ngoto exit;\r\n}\r\nrval = copy_to_user(control->string, sdev->rds_info.radio_text,\r\nstrlen(sdev->rds_info.radio_text) + 1);\r\nif (rval)\r\nrval = -EFAULT;\r\nbreak;\r\ndefault:\r\nrval = -EINVAL;\r\nbreak;\r\n};\r\nexit:\r\nreturn rval;\r\n}\r\nstatic int si4713_update_tune_status(struct si4713_device *sdev)\r\n{\r\nint rval;\r\nu16 f = 0;\r\nu8 p = 0, a = 0, n = 0;\r\nrval = si4713_tx_tune_status(sdev, 0x00, &f, &p, &a, &n);\r\nif (rval < 0)\r\ngoto exit;\r\nsdev->power_level = p;\r\nsdev->antenna_capacitor = a;\r\nsdev->tune_rnl = n;\r\nexit:\r\nreturn rval;\r\n}\r\nstatic int si4713_read_econtrol_tune(struct si4713_device *sdev,\r\nstruct v4l2_ext_control *control)\r\n{\r\ns32 rval = 0;\r\nmutex_lock(&sdev->mutex);\r\nif (sdev->power_state) {\r\nrval = si4713_update_tune_status(sdev);\r\nif (rval < 0)\r\ngoto unlock;\r\n}\r\nswitch (control->id) {\r\ncase V4L2_CID_TUNE_POWER_LEVEL:\r\ncontrol->value = sdev->power_level;\r\nbreak;\r\ncase V4L2_CID_TUNE_ANTENNA_CAPACITOR:\r\ncontrol->value = sdev->antenna_capacitor;\r\nbreak;\r\ndefault:\r\nrval = -EINVAL;\r\n};\r\nunlock:\r\nmutex_unlock(&sdev->mutex);\r\nreturn rval;\r\n}\r\nstatic int si4713_read_econtrol_integers(struct si4713_device *sdev,\r\nstruct v4l2_ext_control *control)\r\n{\r\ns32 rval;\r\nu32 *shadow = NULL, val = 0;\r\ns32 bit = 0, mask = 0;\r\nu16 property = 0;\r\nint mul = 0;\r\nunsigned long *table = NULL;\r\nint size = 0;\r\nrval = si4713_choose_econtrol_action(sdev, control->id, &shadow, &bit,\r\n&mask, &property, &mul, &table, &size);\r\nif (rval < 0)\r\ngoto exit;\r\nmutex_lock(&sdev->mutex);\r\nif (sdev->power_state) {\r\nrval = si4713_read_property(sdev, property, &val);\r\nif (rval < 0)\r\ngoto unlock;\r\nif (control->id == V4L2_CID_AUDIO_COMPRESSION_THRESHOLD)\r\n*shadow = (s16)val;\r\nelse if (mask)\r\n*shadow = get_status_bit(val, bit, mask);\r\nelse if (mul)\r\n*shadow = val * mul;\r\nelse\r\n*shadow = dev_to_usecs(val, table, size);\r\n}\r\ncontrol->value = *shadow;\r\nunlock:\r\nmutex_unlock(&sdev->mutex);\r\nexit:\r\nreturn rval;\r\n}\r\nstatic int si4713_s_ext_ctrls(struct v4l2_subdev *sd,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nstruct si4713_device *sdev = to_si4713_device(sd);\r\nint i;\r\nif (ctrls->ctrl_class != V4L2_CTRL_CLASS_FM_TX)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ctrls->count; i++) {\r\nint err;\r\nswitch ((ctrls->controls + i)->id) {\r\ncase V4L2_CID_RDS_TX_PS_NAME:\r\ncase V4L2_CID_RDS_TX_RADIO_TEXT:\r\nerr = si4713_write_econtrol_string(sdev,\r\nctrls->controls + i);\r\nbreak;\r\ncase V4L2_CID_TUNE_ANTENNA_CAPACITOR:\r\ncase V4L2_CID_TUNE_POWER_LEVEL:\r\nerr = si4713_write_econtrol_tune(sdev,\r\nctrls->controls + i);\r\nbreak;\r\ndefault:\r\nerr = si4713_write_econtrol_integers(sdev,\r\nctrls->controls + i);\r\n}\r\nif (err < 0) {\r\nctrls->error_idx = i;\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int si4713_g_ext_ctrls(struct v4l2_subdev *sd,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nstruct si4713_device *sdev = to_si4713_device(sd);\r\nint i;\r\nif (ctrls->ctrl_class != V4L2_CTRL_CLASS_FM_TX)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ctrls->count; i++) {\r\nint err;\r\nswitch ((ctrls->controls + i)->id) {\r\ncase V4L2_CID_RDS_TX_PS_NAME:\r\ncase V4L2_CID_RDS_TX_RADIO_TEXT:\r\nerr = si4713_read_econtrol_string(sdev,\r\nctrls->controls + i);\r\nbreak;\r\ncase V4L2_CID_TUNE_ANTENNA_CAPACITOR:\r\ncase V4L2_CID_TUNE_POWER_LEVEL:\r\nerr = si4713_read_econtrol_tune(sdev,\r\nctrls->controls + i);\r\nbreak;\r\ndefault:\r\nerr = si4713_read_econtrol_integers(sdev,\r\nctrls->controls + i);\r\n}\r\nif (err < 0) {\r\nctrls->error_idx = i;\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int si4713_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)\r\n{\r\nint rval = 0;\r\nswitch (qc->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nrval = v4l2_ctrl_query_fill(qc, 0, 1, 1, DEFAULT_MUTE);\r\nbreak;\r\ncase V4L2_CID_RDS_TX_PI:\r\nrval = v4l2_ctrl_query_fill(qc, 0, 0xFFFF, 1, DEFAULT_RDS_PI);\r\nbreak;\r\ncase V4L2_CID_RDS_TX_PTY:\r\nrval = v4l2_ctrl_query_fill(qc, 0, 31, 1, DEFAULT_RDS_PTY);\r\nbreak;\r\ncase V4L2_CID_RDS_TX_DEVIATION:\r\nrval = v4l2_ctrl_query_fill(qc, 0, MAX_RDS_DEVIATION,\r\n10, DEFAULT_RDS_DEVIATION);\r\nbreak;\r\ncase V4L2_CID_RDS_TX_PS_NAME:\r\nrval = v4l2_ctrl_query_fill(qc, 0, MAX_RDS_PS_NAME, 8, 0);\r\nbreak;\r\ncase V4L2_CID_RDS_TX_RADIO_TEXT:\r\nrval = v4l2_ctrl_query_fill(qc, 0, MAX_RDS_RADIO_TEXT, 32, 0);\r\nbreak;\r\ncase V4L2_CID_AUDIO_LIMITER_ENABLED:\r\nrval = v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);\r\nbreak;\r\ncase V4L2_CID_AUDIO_LIMITER_RELEASE_TIME:\r\nrval = v4l2_ctrl_query_fill(qc, 250, MAX_LIMITER_RELEASE_TIME,\r\n50, DEFAULT_LIMITER_RTIME);\r\nbreak;\r\ncase V4L2_CID_AUDIO_LIMITER_DEVIATION:\r\nrval = v4l2_ctrl_query_fill(qc, 0, MAX_LIMITER_DEVIATION,\r\n10, DEFAULT_LIMITER_DEV);\r\nbreak;\r\ncase V4L2_CID_AUDIO_COMPRESSION_ENABLED:\r\nrval = v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);\r\nbreak;\r\ncase V4L2_CID_AUDIO_COMPRESSION_GAIN:\r\nrval = v4l2_ctrl_query_fill(qc, 0, MAX_ACOMP_GAIN, 1,\r\nDEFAULT_ACOMP_GAIN);\r\nbreak;\r\ncase V4L2_CID_AUDIO_COMPRESSION_THRESHOLD:\r\nrval = v4l2_ctrl_query_fill(qc, MIN_ACOMP_THRESHOLD,\r\nMAX_ACOMP_THRESHOLD, 1,\r\nDEFAULT_ACOMP_THRESHOLD);\r\nbreak;\r\ncase V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME:\r\nrval = v4l2_ctrl_query_fill(qc, 0, MAX_ACOMP_ATTACK_TIME,\r\n500, DEFAULT_ACOMP_ATIME);\r\nbreak;\r\ncase V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME:\r\nrval = v4l2_ctrl_query_fill(qc, 100000, MAX_ACOMP_RELEASE_TIME,\r\n100000, DEFAULT_ACOMP_RTIME);\r\nbreak;\r\ncase V4L2_CID_PILOT_TONE_ENABLED:\r\nrval = v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);\r\nbreak;\r\ncase V4L2_CID_PILOT_TONE_DEVIATION:\r\nrval = v4l2_ctrl_query_fill(qc, 0, MAX_PILOT_DEVIATION,\r\n10, DEFAULT_PILOT_DEVIATION);\r\nbreak;\r\ncase V4L2_CID_PILOT_TONE_FREQUENCY:\r\nrval = v4l2_ctrl_query_fill(qc, 0, MAX_PILOT_FREQUENCY,\r\n1, DEFAULT_PILOT_FREQUENCY);\r\nbreak;\r\ncase V4L2_CID_TUNE_PREEMPHASIS:\r\nrval = v4l2_ctrl_query_fill(qc, V4L2_PREEMPHASIS_DISABLED,\r\nV4L2_PREEMPHASIS_75_uS, 1,\r\nV4L2_PREEMPHASIS_50_uS);\r\nbreak;\r\ncase V4L2_CID_TUNE_POWER_LEVEL:\r\nrval = v4l2_ctrl_query_fill(qc, 0, 120, 1, DEFAULT_POWER_LEVEL);\r\nbreak;\r\ncase V4L2_CID_TUNE_ANTENNA_CAPACITOR:\r\nrval = v4l2_ctrl_query_fill(qc, 0, 191, 1, 0);\r\nbreak;\r\ndefault:\r\nrval = -EINVAL;\r\nbreak;\r\n};\r\nreturn rval;\r\n}\r\nstatic int si4713_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)\r\n{\r\nstruct si4713_device *sdev = to_si4713_device(sd);\r\nint rval = 0;\r\nif (!sdev)\r\nreturn -ENODEV;\r\nmutex_lock(&sdev->mutex);\r\nif (sdev->power_state) {\r\nrval = si4713_read_property(sdev, SI4713_TX_LINE_INPUT_MUTE,\r\n&sdev->mute);\r\nif (rval < 0)\r\ngoto unlock;\r\n}\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nctrl->value = get_mute(sdev->mute);\r\nbreak;\r\n}\r\nunlock:\r\nmutex_unlock(&sdev->mutex);\r\nreturn rval;\r\n}\r\nstatic int si4713_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)\r\n{\r\nstruct si4713_device *sdev = to_si4713_device(sd);\r\nint rval = 0;\r\nif (!sdev)\r\nreturn -ENODEV;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nif (ctrl->value) {\r\nrval = si4713_set_mute(sdev, ctrl->value);\r\nif (rval < 0)\r\ngoto exit;\r\nrval = si4713_set_power_state(sdev, POWER_DOWN);\r\n} else {\r\nrval = si4713_set_power_state(sdev, POWER_UP);\r\nif (rval < 0)\r\ngoto exit;\r\nrval = si4713_setup(sdev);\r\nif (rval < 0)\r\ngoto exit;\r\nrval = si4713_set_mute(sdev, ctrl->value);\r\n}\r\nbreak;\r\n}\r\nexit:\r\nreturn rval;\r\n}\r\nlong si4713_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\r\n{\r\nstruct si4713_device *sdev = to_si4713_device(sd);\r\nstruct si4713_rnl *rnl = arg;\r\nu16 frequency;\r\nint rval = 0;\r\nif (!arg)\r\nreturn -EINVAL;\r\nmutex_lock(&sdev->mutex);\r\nswitch (cmd) {\r\ncase SI4713_IOC_MEASURE_RNL:\r\nfrequency = v4l2_to_si4713(rnl->frequency);\r\nif (sdev->power_state) {\r\nrval = si4713_tx_tune_measure(sdev, frequency, 0);\r\nif (rval < 0)\r\ngoto unlock;\r\nrval = si4713_update_tune_status(sdev);\r\nif (rval < 0)\r\ngoto unlock;\r\n}\r\nrnl->rnl = sdev->tune_rnl;\r\nbreak;\r\ndefault:\r\nrval = -ENOIOCTLCMD;\r\n}\r\nunlock:\r\nmutex_unlock(&sdev->mutex);\r\nreturn rval;\r\n}\r\nstatic int si4713_g_modulator(struct v4l2_subdev *sd, struct v4l2_modulator *vm)\r\n{\r\nstruct si4713_device *sdev = to_si4713_device(sd);\r\nint rval = 0;\r\nif (!sdev) {\r\nrval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (vm->index > 0) {\r\nrval = -EINVAL;\r\ngoto exit;\r\n}\r\nstrncpy(vm->name, "FM Modulator", 32);\r\nvm->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LOW |\r\nV4L2_TUNER_CAP_RDS | V4L2_TUNER_CAP_RDS_CONTROLS;\r\nvm->rangelow = si4713_to_v4l2(FREQ_RANGE_LOW);\r\nvm->rangehigh = si4713_to_v4l2(FREQ_RANGE_HIGH);\r\nmutex_lock(&sdev->mutex);\r\nif (sdev->power_state) {\r\nu32 comp_en = 0;\r\nrval = si4713_read_property(sdev, SI4713_TX_COMPONENT_ENABLE,\r\n&comp_en);\r\nif (rval < 0)\r\ngoto unlock;\r\nsdev->stereo = get_status_bit(comp_en, 1, 1 << 1);\r\nsdev->rds_info.enabled = get_status_bit(comp_en, 2, 1 << 2);\r\n}\r\nif (sdev->stereo)\r\nvm->txsubchans = V4L2_TUNER_SUB_STEREO;\r\nelse\r\nvm->txsubchans = V4L2_TUNER_SUB_MONO;\r\nif (sdev->rds_info.enabled)\r\nvm->txsubchans |= V4L2_TUNER_SUB_RDS;\r\nelse\r\nvm->txsubchans &= ~V4L2_TUNER_SUB_RDS;\r\nunlock:\r\nmutex_unlock(&sdev->mutex);\r\nexit:\r\nreturn rval;\r\n}\r\nstatic int si4713_s_modulator(struct v4l2_subdev *sd, struct v4l2_modulator *vm)\r\n{\r\nstruct si4713_device *sdev = to_si4713_device(sd);\r\nint rval = 0;\r\nu16 stereo, rds;\r\nu32 p;\r\nif (!sdev)\r\nreturn -ENODEV;\r\nif (vm->index > 0)\r\nreturn -EINVAL;\r\nif (vm->txsubchans & V4L2_TUNER_SUB_STEREO)\r\nstereo = 1;\r\nelse if (vm->txsubchans & V4L2_TUNER_SUB_MONO)\r\nstereo = 0;\r\nelse\r\nreturn -EINVAL;\r\nrds = !!(vm->txsubchans & V4L2_TUNER_SUB_RDS);\r\nmutex_lock(&sdev->mutex);\r\nif (sdev->power_state) {\r\nrval = si4713_read_property(sdev,\r\nSI4713_TX_COMPONENT_ENABLE, &p);\r\nif (rval < 0)\r\ngoto unlock;\r\np = set_bits(p, stereo, 1, 1 << 1);\r\np = set_bits(p, rds, 2, 1 << 2);\r\nrval = si4713_write_property(sdev,\r\nSI4713_TX_COMPONENT_ENABLE, p);\r\nif (rval < 0)\r\ngoto unlock;\r\n}\r\nsdev->stereo = stereo;\r\nsdev->rds_info.enabled = rds;\r\nunlock:\r\nmutex_unlock(&sdev->mutex);\r\nreturn rval;\r\n}\r\nstatic int si4713_g_frequency(struct v4l2_subdev *sd, struct v4l2_frequency *f)\r\n{\r\nstruct si4713_device *sdev = to_si4713_device(sd);\r\nint rval = 0;\r\nf->type = V4L2_TUNER_RADIO;\r\nmutex_lock(&sdev->mutex);\r\nif (sdev->power_state) {\r\nu16 freq;\r\nu8 p, a, n;\r\nrval = si4713_tx_tune_status(sdev, 0x00, &freq, &p, &a, &n);\r\nif (rval < 0)\r\ngoto unlock;\r\nsdev->frequency = freq;\r\n}\r\nf->frequency = si4713_to_v4l2(sdev->frequency);\r\nunlock:\r\nmutex_unlock(&sdev->mutex);\r\nreturn rval;\r\n}\r\nstatic int si4713_s_frequency(struct v4l2_subdev *sd, struct v4l2_frequency *f)\r\n{\r\nstruct si4713_device *sdev = to_si4713_device(sd);\r\nint rval = 0;\r\nu16 frequency = v4l2_to_si4713(f->frequency);\r\nif (frequency < FREQ_RANGE_LOW || frequency > FREQ_RANGE_HIGH)\r\nreturn -EDOM;\r\nmutex_lock(&sdev->mutex);\r\nif (sdev->power_state) {\r\nrval = si4713_tx_tune_freq(sdev, frequency);\r\nif (rval < 0)\r\ngoto unlock;\r\nfrequency = rval;\r\nrval = 0;\r\n}\r\nsdev->frequency = frequency;\r\nf->frequency = si4713_to_v4l2(frequency);\r\nunlock:\r\nmutex_unlock(&sdev->mutex);\r\nreturn rval;\r\n}\r\nstatic int si4713_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct si4713_device *sdev;\r\nstruct si4713_platform_data *pdata = client->dev.platform_data;\r\nint rval, i;\r\nsdev = kzalloc(sizeof *sdev, GFP_KERNEL);\r\nif (!sdev) {\r\ndev_err(&client->dev, "Failed to alloc video device.\n");\r\nrval = -ENOMEM;\r\ngoto exit;\r\n}\r\nsdev->gpio_reset = -1;\r\nif (pdata && gpio_is_valid(pdata->gpio_reset)) {\r\nrval = gpio_request(pdata->gpio_reset, "si4713 reset");\r\nif (rval) {\r\ndev_err(&client->dev,\r\n"Failed to request gpio: %d\n", rval);\r\ngoto free_sdev;\r\n}\r\nsdev->gpio_reset = pdata->gpio_reset;\r\ngpio_direction_output(sdev->gpio_reset, 0);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(sdev->supplies); i++)\r\nsdev->supplies[i].supply = si4713_supply_names[i];\r\nrval = regulator_bulk_get(&client->dev, ARRAY_SIZE(sdev->supplies),\r\nsdev->supplies);\r\nif (rval) {\r\ndev_err(&client->dev, "Cannot get regulators: %d\n", rval);\r\ngoto free_gpio;\r\n}\r\nv4l2_i2c_subdev_init(&sdev->sd, client, &si4713_subdev_ops);\r\nmutex_init(&sdev->mutex);\r\ninit_completion(&sdev->work);\r\nif (client->irq) {\r\nrval = request_irq(client->irq,\r\nsi4713_handler, IRQF_TRIGGER_FALLING | IRQF_DISABLED,\r\nclient->name, sdev);\r\nif (rval < 0) {\r\nv4l2_err(&sdev->sd, "Could not request IRQ\n");\r\ngoto put_reg;\r\n}\r\nv4l2_dbg(1, debug, &sdev->sd, "IRQ requested.\n");\r\n} else {\r\nv4l2_warn(&sdev->sd, "IRQ not configured. Using timeouts.\n");\r\n}\r\nrval = si4713_initialize(sdev);\r\nif (rval < 0) {\r\nv4l2_err(&sdev->sd, "Failed to probe device information.\n");\r\ngoto free_irq;\r\n}\r\nreturn 0;\r\nfree_irq:\r\nif (client->irq)\r\nfree_irq(client->irq, sdev);\r\nput_reg:\r\nregulator_bulk_free(ARRAY_SIZE(sdev->supplies), sdev->supplies);\r\nfree_gpio:\r\nif (gpio_is_valid(sdev->gpio_reset))\r\ngpio_free(sdev->gpio_reset);\r\nfree_sdev:\r\nkfree(sdev);\r\nexit:\r\nreturn rval;\r\n}\r\nstatic int si4713_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct si4713_device *sdev = to_si4713_device(sd);\r\nif (sdev->power_state)\r\nsi4713_set_power_state(sdev, POWER_DOWN);\r\nif (client->irq > 0)\r\nfree_irq(client->irq, sdev);\r\nv4l2_device_unregister_subdev(sd);\r\nregulator_bulk_free(ARRAY_SIZE(sdev->supplies), sdev->supplies);\r\nif (gpio_is_valid(sdev->gpio_reset))\r\ngpio_free(sdev->gpio_reset);\r\nkfree(sdev);\r\nreturn 0;\r\n}\r\nstatic int __init si4713_module_init(void)\r\n{\r\nreturn i2c_add_driver(&si4713_i2c_driver);\r\n}\r\nstatic void __exit si4713_module_exit(void)\r\n{\r\ni2c_del_driver(&si4713_i2c_driver);\r\n}
