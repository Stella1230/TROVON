static inline int s3c24xx_i2c_is2440(struct s3c24xx_i2c *i2c)\r\n{\r\nstruct platform_device *pdev = to_platform_device(i2c->dev);\r\nenum s3c24xx_i2c_type type;\r\n#ifdef CONFIG_OF\r\nif (i2c->dev->of_node)\r\nreturn of_device_is_compatible(i2c->dev->of_node,\r\n"samsung,s3c2440-i2c");\r\n#endif\r\ntype = platform_get_device_id(pdev)->driver_data;\r\nreturn type == TYPE_S3C2440;\r\n}\r\nstatic inline void s3c24xx_i2c_master_complete(struct s3c24xx_i2c *i2c, int ret)\r\n{\r\ndev_dbg(i2c->dev, "master_complete %d\n", ret);\r\ni2c->msg_ptr = 0;\r\ni2c->msg = NULL;\r\ni2c->msg_idx++;\r\ni2c->msg_num = 0;\r\nif (ret)\r\ni2c->msg_idx = ret;\r\nwake_up(&i2c->wait);\r\n}\r\nstatic inline void s3c24xx_i2c_disable_ack(struct s3c24xx_i2c *i2c)\r\n{\r\nunsigned long tmp;\r\ntmp = readl(i2c->regs + S3C2410_IICCON);\r\nwritel(tmp & ~S3C2410_IICCON_ACKEN, i2c->regs + S3C2410_IICCON);\r\n}\r\nstatic inline void s3c24xx_i2c_enable_ack(struct s3c24xx_i2c *i2c)\r\n{\r\nunsigned long tmp;\r\ntmp = readl(i2c->regs + S3C2410_IICCON);\r\nwritel(tmp | S3C2410_IICCON_ACKEN, i2c->regs + S3C2410_IICCON);\r\n}\r\nstatic inline void s3c24xx_i2c_disable_irq(struct s3c24xx_i2c *i2c)\r\n{\r\nunsigned long tmp;\r\ntmp = readl(i2c->regs + S3C2410_IICCON);\r\nwritel(tmp & ~S3C2410_IICCON_IRQEN, i2c->regs + S3C2410_IICCON);\r\n}\r\nstatic inline void s3c24xx_i2c_enable_irq(struct s3c24xx_i2c *i2c)\r\n{\r\nunsigned long tmp;\r\ntmp = readl(i2c->regs + S3C2410_IICCON);\r\nwritel(tmp | S3C2410_IICCON_IRQEN, i2c->regs + S3C2410_IICCON);\r\n}\r\nstatic void s3c24xx_i2c_message_start(struct s3c24xx_i2c *i2c,\r\nstruct i2c_msg *msg)\r\n{\r\nunsigned int addr = (msg->addr & 0x7f) << 1;\r\nunsigned long stat;\r\nunsigned long iiccon;\r\nstat = 0;\r\nstat |= S3C2410_IICSTAT_TXRXEN;\r\nif (msg->flags & I2C_M_RD) {\r\nstat |= S3C2410_IICSTAT_MASTER_RX;\r\naddr |= 1;\r\n} else\r\nstat |= S3C2410_IICSTAT_MASTER_TX;\r\nif (msg->flags & I2C_M_REV_DIR_ADDR)\r\naddr ^= 1;\r\ns3c24xx_i2c_enable_ack(i2c);\r\niiccon = readl(i2c->regs + S3C2410_IICCON);\r\nwritel(stat, i2c->regs + S3C2410_IICSTAT);\r\ndev_dbg(i2c->dev, "START: %08lx to IICSTAT, %02x to DS\n", stat, addr);\r\nwriteb(addr, i2c->regs + S3C2410_IICDS);\r\nndelay(i2c->tx_setup);\r\ndev_dbg(i2c->dev, "iiccon, %08lx\n", iiccon);\r\nwritel(iiccon, i2c->regs + S3C2410_IICCON);\r\nstat |= S3C2410_IICSTAT_START;\r\nwritel(stat, i2c->regs + S3C2410_IICSTAT);\r\n}\r\nstatic inline void s3c24xx_i2c_stop(struct s3c24xx_i2c *i2c, int ret)\r\n{\r\nunsigned long iicstat = readl(i2c->regs + S3C2410_IICSTAT);\r\ndev_dbg(i2c->dev, "STOP\n");\r\niicstat &= ~S3C2410_IICSTAT_START;\r\nwritel(iicstat, i2c->regs + S3C2410_IICSTAT);\r\ni2c->state = STATE_STOP;\r\ns3c24xx_i2c_master_complete(i2c, ret);\r\ns3c24xx_i2c_disable_irq(i2c);\r\n}\r\nstatic inline int is_lastmsg(struct s3c24xx_i2c *i2c)\r\n{\r\nreturn i2c->msg_idx >= (i2c->msg_num - 1);\r\n}\r\nstatic inline int is_msglast(struct s3c24xx_i2c *i2c)\r\n{\r\nreturn i2c->msg_ptr == i2c->msg->len-1;\r\n}\r\nstatic inline int is_msgend(struct s3c24xx_i2c *i2c)\r\n{\r\nreturn i2c->msg_ptr >= i2c->msg->len;\r\n}\r\nstatic int i2c_s3c_irq_nextbyte(struct s3c24xx_i2c *i2c, unsigned long iicstat)\r\n{\r\nunsigned long tmp;\r\nunsigned char byte;\r\nint ret = 0;\r\nswitch (i2c->state) {\r\ncase STATE_IDLE:\r\ndev_err(i2c->dev, "%s: called in STATE_IDLE\n", __func__);\r\ngoto out;\r\ncase STATE_STOP:\r\ndev_err(i2c->dev, "%s: called in STATE_STOP\n", __func__);\r\ns3c24xx_i2c_disable_irq(i2c);\r\ngoto out_ack;\r\ncase STATE_START:\r\nif (iicstat & S3C2410_IICSTAT_LASTBIT &&\r\n!(i2c->msg->flags & I2C_M_IGNORE_NAK)) {\r\ndev_dbg(i2c->dev, "ack was not received\n");\r\ns3c24xx_i2c_stop(i2c, -ENXIO);\r\ngoto out_ack;\r\n}\r\nif (i2c->msg->flags & I2C_M_RD)\r\ni2c->state = STATE_READ;\r\nelse\r\ni2c->state = STATE_WRITE;\r\nif (is_lastmsg(i2c) && i2c->msg->len == 0) {\r\ns3c24xx_i2c_stop(i2c, 0);\r\ngoto out_ack;\r\n}\r\nif (i2c->state == STATE_READ)\r\ngoto prepare_read;\r\ncase STATE_WRITE:\r\nif (!(i2c->msg->flags & I2C_M_IGNORE_NAK)) {\r\nif (iicstat & S3C2410_IICSTAT_LASTBIT) {\r\ndev_dbg(i2c->dev, "WRITE: No Ack\n");\r\ns3c24xx_i2c_stop(i2c, -ECONNREFUSED);\r\ngoto out_ack;\r\n}\r\n}\r\nretry_write:\r\nif (!is_msgend(i2c)) {\r\nbyte = i2c->msg->buf[i2c->msg_ptr++];\r\nwriteb(byte, i2c->regs + S3C2410_IICDS);\r\nndelay(i2c->tx_setup);\r\n} else if (!is_lastmsg(i2c)) {\r\ndev_dbg(i2c->dev, "WRITE: Next Message\n");\r\ni2c->msg_ptr = 0;\r\ni2c->msg_idx++;\r\ni2c->msg++;\r\nif (i2c->msg->flags & I2C_M_NOSTART) {\r\nif (i2c->msg->flags & I2C_M_RD) {\r\ns3c24xx_i2c_stop(i2c, -EINVAL);\r\n}\r\ngoto retry_write;\r\n} else {\r\ns3c24xx_i2c_message_start(i2c, i2c->msg);\r\ni2c->state = STATE_START;\r\n}\r\n} else {\r\ns3c24xx_i2c_stop(i2c, 0);\r\n}\r\nbreak;\r\ncase STATE_READ:\r\nbyte = readb(i2c->regs + S3C2410_IICDS);\r\ni2c->msg->buf[i2c->msg_ptr++] = byte;\r\nprepare_read:\r\nif (is_msglast(i2c)) {\r\nif (is_lastmsg(i2c))\r\ns3c24xx_i2c_disable_ack(i2c);\r\n} else if (is_msgend(i2c)) {\r\nif (is_lastmsg(i2c)) {\r\ndev_dbg(i2c->dev, "READ: Send Stop\n");\r\ns3c24xx_i2c_stop(i2c, 0);\r\n} else {\r\ndev_dbg(i2c->dev, "READ: Next Transfer\n");\r\ni2c->msg_ptr = 0;\r\ni2c->msg_idx++;\r\ni2c->msg++;\r\n}\r\n}\r\nbreak;\r\n}\r\nout_ack:\r\ntmp = readl(i2c->regs + S3C2410_IICCON);\r\ntmp &= ~S3C2410_IICCON_IRQPEND;\r\nwritel(tmp, i2c->regs + S3C2410_IICCON);\r\nout:\r\nreturn ret;\r\n}\r\nstatic irqreturn_t s3c24xx_i2c_irq(int irqno, void *dev_id)\r\n{\r\nstruct s3c24xx_i2c *i2c = dev_id;\r\nunsigned long status;\r\nunsigned long tmp;\r\nstatus = readl(i2c->regs + S3C2410_IICSTAT);\r\nif (status & S3C2410_IICSTAT_ARBITR) {\r\ndev_err(i2c->dev, "deal with arbitration loss\n");\r\n}\r\nif (i2c->state == STATE_IDLE) {\r\ndev_dbg(i2c->dev, "IRQ: error i2c->state == IDLE\n");\r\ntmp = readl(i2c->regs + S3C2410_IICCON);\r\ntmp &= ~S3C2410_IICCON_IRQPEND;\r\nwritel(tmp, i2c->regs + S3C2410_IICCON);\r\ngoto out;\r\n}\r\ni2c_s3c_irq_nextbyte(i2c, status);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s3c24xx_i2c_set_master(struct s3c24xx_i2c *i2c)\r\n{\r\nunsigned long iicstat;\r\nint timeout = 400;\r\nwhile (timeout-- > 0) {\r\niicstat = readl(i2c->regs + S3C2410_IICSTAT);\r\nif (!(iicstat & S3C2410_IICSTAT_BUSBUSY))\r\nreturn 0;\r\nmsleep(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int s3c24xx_i2c_doxfer(struct s3c24xx_i2c *i2c,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nunsigned long iicstat, timeout;\r\nint spins = 20;\r\nint ret;\r\nif (i2c->suspended)\r\nreturn -EIO;\r\nret = s3c24xx_i2c_set_master(i2c);\r\nif (ret != 0) {\r\ndev_err(i2c->dev, "cannot get bus (error %d)\n", ret);\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nspin_lock_irq(&i2c->lock);\r\ni2c->msg = msgs;\r\ni2c->msg_num = num;\r\ni2c->msg_ptr = 0;\r\ni2c->msg_idx = 0;\r\ni2c->state = STATE_START;\r\ns3c24xx_i2c_enable_irq(i2c);\r\ns3c24xx_i2c_message_start(i2c, msgs);\r\nspin_unlock_irq(&i2c->lock);\r\ntimeout = wait_event_timeout(i2c->wait, i2c->msg_num == 0, HZ * 5);\r\nret = i2c->msg_idx;\r\nif (timeout == 0)\r\ndev_dbg(i2c->dev, "timeout\n");\r\nelse if (ret != num)\r\ndev_dbg(i2c->dev, "incomplete xfer (%d)\n", ret);\r\ndev_dbg(i2c->dev, "waiting for bus idle\n");\r\ndo {\r\ncpu_relax();\r\niicstat = readl(i2c->regs + S3C2410_IICSTAT);\r\n} while ((iicstat & S3C2410_IICSTAT_START) && --spins);\r\nif (!spins) {\r\nmsleep(1);\r\niicstat = readl(i2c->regs + S3C2410_IICSTAT);\r\n}\r\nif (iicstat & S3C2410_IICSTAT_START)\r\ndev_warn(i2c->dev, "timeout waiting for bus idle\n");\r\nout:\r\nreturn ret;\r\n}\r\nstatic int s3c24xx_i2c_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct s3c24xx_i2c *i2c = (struct s3c24xx_i2c *)adap->algo_data;\r\nint retry;\r\nint ret;\r\nclk_enable(i2c->clk);\r\nfor (retry = 0; retry < adap->retries; retry++) {\r\nret = s3c24xx_i2c_doxfer(i2c, msgs, num);\r\nif (ret != -EAGAIN) {\r\nclk_disable(i2c->clk);\r\nreturn ret;\r\n}\r\ndev_dbg(i2c->dev, "Retrying transmission (%d)\n", retry);\r\nudelay(100);\r\n}\r\nclk_disable(i2c->clk);\r\nreturn -EREMOTEIO;\r\n}\r\nstatic u32 s3c24xx_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;\r\n}\r\nstatic int s3c24xx_i2c_calcdivisor(unsigned long clkin, unsigned int wanted,\r\nunsigned int *div1, unsigned int *divs)\r\n{\r\nunsigned int calc_divs = clkin / wanted;\r\nunsigned int calc_div1;\r\nif (calc_divs > (16*16))\r\ncalc_div1 = 512;\r\nelse\r\ncalc_div1 = 16;\r\ncalc_divs += calc_div1-1;\r\ncalc_divs /= calc_div1;\r\nif (calc_divs == 0)\r\ncalc_divs = 1;\r\nif (calc_divs > 17)\r\ncalc_divs = 17;\r\n*divs = calc_divs;\r\n*div1 = calc_div1;\r\nreturn clkin / (calc_divs * calc_div1);\r\n}\r\nstatic int s3c24xx_i2c_clockrate(struct s3c24xx_i2c *i2c, unsigned int *got)\r\n{\r\nstruct s3c2410_platform_i2c *pdata = i2c->pdata;\r\nunsigned long clkin = clk_get_rate(i2c->clk);\r\nunsigned int divs, div1;\r\nunsigned long target_frequency;\r\nu32 iiccon;\r\nint freq;\r\ni2c->clkrate = clkin;\r\nclkin /= 1000;\r\ndev_dbg(i2c->dev, "pdata desired frequency %lu\n", pdata->frequency);\r\ntarget_frequency = pdata->frequency ? pdata->frequency : 100000;\r\ntarget_frequency /= 1000;\r\nfreq = s3c24xx_i2c_calcdivisor(clkin, target_frequency, &div1, &divs);\r\nif (freq > target_frequency) {\r\ndev_err(i2c->dev,\r\n"Unable to achieve desired frequency %luKHz." \\r\n" Lowest achievable %dKHz\n", target_frequency, freq);\r\nreturn -EINVAL;\r\n}\r\n*got = freq;\r\niiccon = readl(i2c->regs + S3C2410_IICCON);\r\niiccon &= ~(S3C2410_IICCON_SCALEMASK | S3C2410_IICCON_TXDIV_512);\r\niiccon |= (divs-1);\r\nif (div1 == 512)\r\niiccon |= S3C2410_IICCON_TXDIV_512;\r\nwritel(iiccon, i2c->regs + S3C2410_IICCON);\r\nif (s3c24xx_i2c_is2440(i2c)) {\r\nunsigned long sda_delay;\r\nif (pdata->sda_delay) {\r\nsda_delay = clkin * pdata->sda_delay;\r\nsda_delay = DIV_ROUND_UP(sda_delay, 1000000);\r\nsda_delay = DIV_ROUND_UP(sda_delay, 5);\r\nif (sda_delay > 3)\r\nsda_delay = 3;\r\nsda_delay |= S3C2410_IICLC_FILTER_ON;\r\n} else\r\nsda_delay = 0;\r\ndev_dbg(i2c->dev, "IICLC=%08lx\n", sda_delay);\r\nwritel(sda_delay, i2c->regs + S3C2440_IICLC);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3c24xx_i2c_cpufreq_transition(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct s3c24xx_i2c *i2c = freq_to_i2c(nb);\r\nunsigned long flags;\r\nunsigned int got;\r\nint delta_f;\r\nint ret;\r\ndelta_f = clk_get_rate(i2c->clk) - i2c->clkrate;\r\nif ((val == CPUFREQ_POSTCHANGE && delta_f < 0) ||\r\n(val == CPUFREQ_PRECHANGE && delta_f > 0)) {\r\nspin_lock_irqsave(&i2c->lock, flags);\r\nret = s3c24xx_i2c_clockrate(i2c, &got);\r\nspin_unlock_irqrestore(&i2c->lock, flags);\r\nif (ret < 0)\r\ndev_err(i2c->dev, "cannot find frequency\n");\r\nelse\r\ndev_info(i2c->dev, "setting freq %d\n", got);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int s3c24xx_i2c_register_cpufreq(struct s3c24xx_i2c *i2c)\r\n{\r\ni2c->freq_transition.notifier_call = s3c24xx_i2c_cpufreq_transition;\r\nreturn cpufreq_register_notifier(&i2c->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline void s3c24xx_i2c_deregister_cpufreq(struct s3c24xx_i2c *i2c)\r\n{\r\ncpufreq_unregister_notifier(&i2c->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline int s3c24xx_i2c_register_cpufreq(struct s3c24xx_i2c *i2c)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void s3c24xx_i2c_deregister_cpufreq(struct s3c24xx_i2c *i2c)\r\n{\r\n}\r\nstatic int s3c24xx_i2c_parse_dt_gpio(struct s3c24xx_i2c *i2c)\r\n{\r\nint idx, gpio, ret;\r\nfor (idx = 0; idx < 2; idx++) {\r\ngpio = of_get_gpio(i2c->dev->of_node, idx);\r\nif (!gpio_is_valid(gpio)) {\r\ndev_err(i2c->dev, "invalid gpio[%d]: %d\n", idx, gpio);\r\ngoto free_gpio;\r\n}\r\nret = gpio_request(gpio, "i2c-bus");\r\nif (ret) {\r\ndev_err(i2c->dev, "gpio [%d] request failed\n", gpio);\r\ngoto free_gpio;\r\n}\r\n}\r\nreturn 0;\r\nfree_gpio:\r\nwhile (--idx >= 0)\r\ngpio_free(i2c->gpios[idx]);\r\nreturn -EINVAL;\r\n}\r\nstatic void s3c24xx_i2c_dt_gpio_free(struct s3c24xx_i2c *i2c)\r\n{\r\nunsigned int idx;\r\nfor (idx = 0; idx < 2; idx++)\r\ngpio_free(i2c->gpios[idx]);\r\n}\r\nstatic int s3c24xx_i2c_parse_dt_gpio(struct s3c24xx_i2c *i2c)\r\n{\r\nreturn 0;\r\n}\r\nstatic void s3c24xx_i2c_dt_gpio_free(struct s3c24xx_i2c *i2c)\r\n{\r\n}\r\nstatic int s3c24xx_i2c_init(struct s3c24xx_i2c *i2c)\r\n{\r\nunsigned long iicon = S3C2410_IICCON_IRQEN | S3C2410_IICCON_ACKEN;\r\nstruct s3c2410_platform_i2c *pdata;\r\nunsigned int freq;\r\npdata = i2c->pdata;\r\nif (pdata->cfg_gpio)\r\npdata->cfg_gpio(to_platform_device(i2c->dev));\r\nelse\r\nif (s3c24xx_i2c_parse_dt_gpio(i2c))\r\nreturn -EINVAL;\r\nwriteb(pdata->slave_addr, i2c->regs + S3C2410_IICADD);\r\ndev_info(i2c->dev, "slave address 0x%02x\n", pdata->slave_addr);\r\nwritel(iicon, i2c->regs + S3C2410_IICCON);\r\nif (s3c24xx_i2c_clockrate(i2c, &freq) != 0) {\r\nwritel(0, i2c->regs + S3C2410_IICCON);\r\ndev_err(i2c->dev, "cannot meet bus frequency required\n");\r\nreturn -EINVAL;\r\n}\r\ndev_info(i2c->dev, "bus frequency set to %d KHz\n", freq);\r\ndev_dbg(i2c->dev, "S3C2410_IICCON=0x%02lx\n", iicon);\r\nreturn 0;\r\n}\r\nstatic void\r\ns3c24xx_i2c_parse_dt(struct device_node *np, struct s3c24xx_i2c *i2c)\r\n{\r\nstruct s3c2410_platform_i2c *pdata = i2c->pdata;\r\nif (!np)\r\nreturn;\r\npdata->bus_num = -1;\r\nof_property_read_u32(np, "samsung,i2c-sda-delay", &pdata->sda_delay);\r\nof_property_read_u32(np, "samsung,i2c-slave-addr", &pdata->slave_addr);\r\nof_property_read_u32(np, "samsung,i2c-max-bus-freq",\r\n(u32 *)&pdata->frequency);\r\n}\r\nstatic void\r\ns3c24xx_i2c_parse_dt(struct device_node *np, struct s3c24xx_i2c *i2c)\r\n{\r\nreturn;\r\n}\r\nstatic int s3c24xx_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct s3c24xx_i2c *i2c;\r\nstruct s3c2410_platform_i2c *pdata = NULL;\r\nstruct resource *res;\r\nint ret;\r\nif (!pdev->dev.of_node) {\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\ni2c = kzalloc(sizeof(struct s3c24xx_i2c), GFP_KERNEL);\r\nif (!i2c) {\r\ndev_err(&pdev->dev, "no memory for state\n");\r\nreturn -ENOMEM;\r\n}\r\ni2c->pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!i2c->pdata) {\r\nret = -ENOMEM;\r\ngoto err_noclk;\r\n}\r\nif (pdata)\r\nmemcpy(i2c->pdata, pdata, sizeof(*pdata));\r\nelse\r\ns3c24xx_i2c_parse_dt(pdev->dev.of_node, i2c);\r\nstrlcpy(i2c->adap.name, "s3c2410-i2c", sizeof(i2c->adap.name));\r\ni2c->adap.owner = THIS_MODULE;\r\ni2c->adap.algo = &s3c24xx_i2c_algorithm;\r\ni2c->adap.retries = 2;\r\ni2c->adap.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\ni2c->tx_setup = 50;\r\nspin_lock_init(&i2c->lock);\r\ninit_waitqueue_head(&i2c->wait);\r\ni2c->dev = &pdev->dev;\r\ni2c->clk = clk_get(&pdev->dev, "i2c");\r\nif (IS_ERR(i2c->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock\n");\r\nret = -ENOENT;\r\ngoto err_noclk;\r\n}\r\ndev_dbg(&pdev->dev, "clock source %p\n", i2c->clk);\r\nclk_enable(i2c->clk);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "cannot find IO resource\n");\r\nret = -ENOENT;\r\ngoto err_clk;\r\n}\r\ni2c->ioarea = request_mem_region(res->start, resource_size(res),\r\npdev->name);\r\nif (i2c->ioarea == NULL) {\r\ndev_err(&pdev->dev, "cannot request IO\n");\r\nret = -ENXIO;\r\ngoto err_clk;\r\n}\r\ni2c->regs = ioremap(res->start, resource_size(res));\r\nif (i2c->regs == NULL) {\r\ndev_err(&pdev->dev, "cannot map IO\n");\r\nret = -ENXIO;\r\ngoto err_ioarea;\r\n}\r\ndev_dbg(&pdev->dev, "registers %p (%p, %p)\n",\r\ni2c->regs, i2c->ioarea, res);\r\ni2c->adap.algo_data = i2c;\r\ni2c->adap.dev.parent = &pdev->dev;\r\nret = s3c24xx_i2c_init(i2c);\r\nif (ret != 0)\r\ngoto err_iomap;\r\ni2c->irq = ret = platform_get_irq(pdev, 0);\r\nif (ret <= 0) {\r\ndev_err(&pdev->dev, "cannot find IRQ\n");\r\ngoto err_iomap;\r\n}\r\nret = request_irq(i2c->irq, s3c24xx_i2c_irq, 0,\r\ndev_name(&pdev->dev), i2c);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "cannot claim IRQ %d\n", i2c->irq);\r\ngoto err_iomap;\r\n}\r\nret = s3c24xx_i2c_register_cpufreq(i2c);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to register cpufreq notifier\n");\r\ngoto err_irq;\r\n}\r\ni2c->adap.nr = i2c->pdata->bus_num;\r\ni2c->adap.dev.of_node = pdev->dev.of_node;\r\nret = i2c_add_numbered_adapter(&i2c->adap);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to add bus to i2c core\n");\r\ngoto err_cpufreq;\r\n}\r\nof_i2c_register_devices(&i2c->adap);\r\nplatform_set_drvdata(pdev, i2c);\r\ndev_info(&pdev->dev, "%s: S3C I2C adapter\n", dev_name(&i2c->adap.dev));\r\nclk_disable(i2c->clk);\r\nreturn 0;\r\nerr_cpufreq:\r\ns3c24xx_i2c_deregister_cpufreq(i2c);\r\nerr_irq:\r\nfree_irq(i2c->irq, i2c);\r\nerr_iomap:\r\niounmap(i2c->regs);\r\nerr_ioarea:\r\nrelease_resource(i2c->ioarea);\r\nkfree(i2c->ioarea);\r\nerr_clk:\r\nclk_disable(i2c->clk);\r\nclk_put(i2c->clk);\r\nerr_noclk:\r\nkfree(i2c);\r\nreturn ret;\r\n}\r\nstatic int s3c24xx_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct s3c24xx_i2c *i2c = platform_get_drvdata(pdev);\r\ns3c24xx_i2c_deregister_cpufreq(i2c);\r\ni2c_del_adapter(&i2c->adap);\r\nfree_irq(i2c->irq, i2c);\r\nclk_disable(i2c->clk);\r\nclk_put(i2c->clk);\r\niounmap(i2c->regs);\r\nrelease_resource(i2c->ioarea);\r\ns3c24xx_i2c_dt_gpio_free(i2c);\r\nkfree(i2c->ioarea);\r\nkfree(i2c);\r\nreturn 0;\r\n}\r\nstatic int s3c24xx_i2c_suspend_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct s3c24xx_i2c *i2c = platform_get_drvdata(pdev);\r\ni2c->suspended = 1;\r\nreturn 0;\r\n}\r\nstatic int s3c24xx_i2c_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct s3c24xx_i2c *i2c = platform_get_drvdata(pdev);\r\ni2c->suspended = 0;\r\nclk_enable(i2c->clk);\r\ns3c24xx_i2c_init(i2c);\r\nclk_disable(i2c->clk);\r\nreturn 0;\r\n}\r\nstatic int __init i2c_adap_s3c_init(void)\r\n{\r\nreturn platform_driver_register(&s3c24xx_i2c_driver);\r\n}\r\nstatic void __exit i2c_adap_s3c_exit(void)\r\n{\r\nplatform_driver_unregister(&s3c24xx_i2c_driver);\r\n}
