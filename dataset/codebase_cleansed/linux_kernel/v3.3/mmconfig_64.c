static char __iomem *pci_dev_base(unsigned int seg, unsigned int bus, unsigned int devfn)\r\n{\r\nstruct pci_mmcfg_region *cfg = pci_mmconfig_lookup(seg, bus);\r\nif (cfg && cfg->virt)\r\nreturn cfg->virt + (PCI_MMCFG_BUS_OFFSET(bus) | (devfn << 12));\r\nreturn NULL;\r\n}\r\nstatic int pci_mmcfg_read(unsigned int seg, unsigned int bus,\r\nunsigned int devfn, int reg, int len, u32 *value)\r\n{\r\nchar __iomem *addr;\r\nif (unlikely((bus > 255) || (devfn > 255) || (reg > 4095))) {\r\nerr: *value = -1;\r\nreturn -EINVAL;\r\n}\r\naddr = pci_dev_base(seg, bus, devfn);\r\nif (!addr)\r\ngoto err;\r\nswitch (len) {\r\ncase 1:\r\n*value = mmio_config_readb(addr + reg);\r\nbreak;\r\ncase 2:\r\n*value = mmio_config_readw(addr + reg);\r\nbreak;\r\ncase 4:\r\n*value = mmio_config_readl(addr + reg);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci_mmcfg_write(unsigned int seg, unsigned int bus,\r\nunsigned int devfn, int reg, int len, u32 value)\r\n{\r\nchar __iomem *addr;\r\nif (unlikely((bus > 255) || (devfn > 255) || (reg > 4095)))\r\nreturn -EINVAL;\r\naddr = pci_dev_base(seg, bus, devfn);\r\nif (!addr)\r\nreturn -EINVAL;\r\nswitch (len) {\r\ncase 1:\r\nmmio_config_writeb(addr + reg, value);\r\nbreak;\r\ncase 2:\r\nmmio_config_writew(addr + reg, value);\r\nbreak;\r\ncase 4:\r\nmmio_config_writel(addr + reg, value);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __iomem * __init mcfg_ioremap(struct pci_mmcfg_region *cfg)\r\n{\r\nvoid __iomem *addr;\r\nu64 start, size;\r\nint num_buses;\r\nstart = cfg->address + PCI_MMCFG_BUS_OFFSET(cfg->start_bus);\r\nnum_buses = cfg->end_bus - cfg->start_bus + 1;\r\nsize = PCI_MMCFG_BUS_OFFSET(num_buses);\r\naddr = ioremap_nocache(start, size);\r\nif (addr)\r\naddr -= PCI_MMCFG_BUS_OFFSET(cfg->start_bus);\r\nreturn addr;\r\n}\r\nint __init pci_mmcfg_arch_init(void)\r\n{\r\nstruct pci_mmcfg_region *cfg;\r\nlist_for_each_entry(cfg, &pci_mmcfg_list, list) {\r\ncfg->virt = mcfg_ioremap(cfg);\r\nif (!cfg->virt) {\r\nprintk(KERN_ERR PREFIX "can't map MMCONFIG at %pR\n",\r\n&cfg->res);\r\npci_mmcfg_arch_free();\r\nreturn 0;\r\n}\r\n}\r\nraw_pci_ext_ops = &pci_mmcfg;\r\nreturn 1;\r\n}\r\nvoid __init pci_mmcfg_arch_free(void)\r\n{\r\nstruct pci_mmcfg_region *cfg;\r\nlist_for_each_entry(cfg, &pci_mmcfg_list, list) {\r\nif (cfg->virt) {\r\niounmap(cfg->virt + PCI_MMCFG_BUS_OFFSET(cfg->start_bus));\r\ncfg->virt = NULL;\r\n}\r\n}\r\n}
