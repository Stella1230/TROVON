int amdtp_out_stream_init(struct amdtp_out_stream *s, struct fw_unit *unit,\r\nenum cip_out_flags flags)\r\n{\r\nif (flags != CIP_NONBLOCKING)\r\nreturn -EINVAL;\r\ns->unit = fw_unit_get(unit);\r\ns->flags = flags;\r\ns->context = ERR_PTR(-1);\r\nmutex_init(&s->mutex);\r\ns->packet_index = 0;\r\nreturn 0;\r\n}\r\nvoid amdtp_out_stream_destroy(struct amdtp_out_stream *s)\r\n{\r\nWARN_ON(!IS_ERR(s->context));\r\nmutex_destroy(&s->mutex);\r\nfw_unit_put(s->unit);\r\n}\r\nvoid amdtp_out_stream_set_rate(struct amdtp_out_stream *s, unsigned int rate)\r\n{\r\nstatic const struct {\r\nunsigned int rate;\r\nunsigned int syt_interval;\r\n} rate_info[] = {\r\n[CIP_SFC_32000] = { 32000, 8, },\r\n[CIP_SFC_44100] = { 44100, 8, },\r\n[CIP_SFC_48000] = { 48000, 8, },\r\n[CIP_SFC_88200] = { 88200, 16, },\r\n[CIP_SFC_96000] = { 96000, 16, },\r\n[CIP_SFC_176400] = { 176400, 32, },\r\n[CIP_SFC_192000] = { 192000, 32, },\r\n};\r\nunsigned int sfc;\r\nif (WARN_ON(!IS_ERR(s->context)))\r\nreturn;\r\nfor (sfc = 0; sfc < ARRAY_SIZE(rate_info); ++sfc)\r\nif (rate_info[sfc].rate == rate) {\r\ns->sfc = sfc;\r\ns->syt_interval = rate_info[sfc].syt_interval;\r\nreturn;\r\n}\r\nWARN_ON(1);\r\n}\r\nunsigned int amdtp_out_stream_get_max_payload(struct amdtp_out_stream *s)\r\n{\r\nstatic const unsigned int max_data_blocks[] = {\r\n[CIP_SFC_32000] = 4,\r\n[CIP_SFC_44100] = 6,\r\n[CIP_SFC_48000] = 6,\r\n[CIP_SFC_88200] = 12,\r\n[CIP_SFC_96000] = 12,\r\n[CIP_SFC_176400] = 23,\r\n[CIP_SFC_192000] = 24,\r\n};\r\ns->data_block_quadlets = s->pcm_channels;\r\ns->data_block_quadlets += DIV_ROUND_UP(s->midi_ports, 8);\r\nreturn 8 + max_data_blocks[s->sfc] * 4 * s->data_block_quadlets;\r\n}\r\nvoid amdtp_out_stream_set_pcm_format(struct amdtp_out_stream *s,\r\nsnd_pcm_format_t format)\r\n{\r\nif (WARN_ON(!IS_ERR(s->context)))\r\nreturn;\r\nswitch (format) {\r\ndefault:\r\nWARN_ON(1);\r\ncase SNDRV_PCM_FORMAT_S16:\r\ns->transfer_samples = amdtp_write_s16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32:\r\ns->transfer_samples = amdtp_write_s32;\r\nbreak;\r\n}\r\n}\r\nstatic unsigned int calculate_data_blocks(struct amdtp_out_stream *s)\r\n{\r\nunsigned int phase, data_blocks;\r\nif (!cip_sfc_is_base_44100(s->sfc)) {\r\ndata_blocks = s->data_block_state;\r\n} else {\r\nphase = s->data_block_state;\r\nif (s->sfc == CIP_SFC_44100)\r\ndata_blocks = 5 + ((phase & 1) ^\r\n(phase == 0 || phase >= 40));\r\nelse\r\ndata_blocks = 11 * (s->sfc >> 1) + (phase == 0);\r\nif (++phase >= (80 >> (s->sfc >> 1)))\r\nphase = 0;\r\ns->data_block_state = phase;\r\n}\r\nreturn data_blocks;\r\n}\r\nstatic unsigned int calculate_syt(struct amdtp_out_stream *s,\r\nunsigned int cycle)\r\n{\r\nunsigned int syt_offset, phase, index, syt;\r\nif (s->last_syt_offset < TICKS_PER_CYCLE) {\r\nif (!cip_sfc_is_base_44100(s->sfc))\r\nsyt_offset = s->last_syt_offset + s->syt_offset_state;\r\nelse {\r\nphase = s->syt_offset_state;\r\nindex = phase % 13;\r\nsyt_offset = s->last_syt_offset;\r\nsyt_offset += 1386 + ((index && !(index & 3)) ||\r\nphase == 146);\r\nif (++phase >= 147)\r\nphase = 0;\r\ns->syt_offset_state = phase;\r\n}\r\n} else\r\nsyt_offset = s->last_syt_offset - TICKS_PER_CYCLE;\r\ns->last_syt_offset = syt_offset;\r\nif (syt_offset < TICKS_PER_CYCLE) {\r\nsyt_offset += TRANSFER_DELAY_TICKS - TICKS_PER_CYCLE;\r\nsyt = (cycle + syt_offset / TICKS_PER_CYCLE) << 12;\r\nsyt += syt_offset % TICKS_PER_CYCLE;\r\nreturn syt & 0xffff;\r\n} else {\r\nreturn 0xffff;\r\n}\r\n}\r\nstatic void amdtp_write_s32(struct amdtp_out_stream *s,\r\nstruct snd_pcm_substream *pcm,\r\n__be32 *buffer, unsigned int frames)\r\n{\r\nstruct snd_pcm_runtime *runtime = pcm->runtime;\r\nunsigned int channels, remaining_frames, frame_step, i, c;\r\nconst u32 *src;\r\nchannels = s->pcm_channels;\r\nsrc = (void *)runtime->dma_area +\r\ns->pcm_buffer_pointer * (runtime->frame_bits / 8);\r\nremaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;\r\nframe_step = s->data_block_quadlets - channels;\r\nfor (i = 0; i < frames; ++i) {\r\nfor (c = 0; c < channels; ++c) {\r\n*buffer = cpu_to_be32((*src >> 8) | 0x40000000);\r\nsrc++;\r\nbuffer++;\r\n}\r\nbuffer += frame_step;\r\nif (--remaining_frames == 0)\r\nsrc = (void *)runtime->dma_area;\r\n}\r\n}\r\nstatic void amdtp_write_s16(struct amdtp_out_stream *s,\r\nstruct snd_pcm_substream *pcm,\r\n__be32 *buffer, unsigned int frames)\r\n{\r\nstruct snd_pcm_runtime *runtime = pcm->runtime;\r\nunsigned int channels, remaining_frames, frame_step, i, c;\r\nconst u16 *src;\r\nchannels = s->pcm_channels;\r\nsrc = (void *)runtime->dma_area +\r\ns->pcm_buffer_pointer * (runtime->frame_bits / 8);\r\nremaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;\r\nframe_step = s->data_block_quadlets - channels;\r\nfor (i = 0; i < frames; ++i) {\r\nfor (c = 0; c < channels; ++c) {\r\n*buffer = cpu_to_be32((*src << 8) | 0x40000000);\r\nsrc++;\r\nbuffer++;\r\n}\r\nbuffer += frame_step;\r\nif (--remaining_frames == 0)\r\nsrc = (void *)runtime->dma_area;\r\n}\r\n}\r\nstatic void amdtp_fill_pcm_silence(struct amdtp_out_stream *s,\r\n__be32 *buffer, unsigned int frames)\r\n{\r\nunsigned int i, c;\r\nfor (i = 0; i < frames; ++i) {\r\nfor (c = 0; c < s->pcm_channels; ++c)\r\nbuffer[c] = cpu_to_be32(0x40000000);\r\nbuffer += s->data_block_quadlets;\r\n}\r\n}\r\nstatic void amdtp_fill_midi(struct amdtp_out_stream *s,\r\n__be32 *buffer, unsigned int frames)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < frames; ++i)\r\nbuffer[s->pcm_channels + i * s->data_block_quadlets] =\r\ncpu_to_be32(0x80000000);\r\n}\r\nstatic void queue_out_packet(struct amdtp_out_stream *s, unsigned int cycle)\r\n{\r\n__be32 *buffer;\r\nunsigned int index, data_blocks, syt, ptr;\r\nstruct snd_pcm_substream *pcm;\r\nstruct fw_iso_packet packet;\r\nint err;\r\nif (s->packet_index < 0)\r\nreturn;\r\nindex = s->packet_index;\r\ndata_blocks = calculate_data_blocks(s);\r\nsyt = calculate_syt(s, cycle);\r\nbuffer = s->buffer.packets[index].buffer;\r\nbuffer[0] = cpu_to_be32(ACCESS_ONCE(s->source_node_id_field) |\r\n(s->data_block_quadlets << 16) |\r\ns->data_block_counter);\r\nbuffer[1] = cpu_to_be32(CIP_EOH | CIP_FMT_AM | AMDTP_FDF_AM824 |\r\n(s->sfc << AMDTP_FDF_SFC_SHIFT) | syt);\r\nbuffer += 2;\r\npcm = ACCESS_ONCE(s->pcm);\r\nif (pcm)\r\ns->transfer_samples(s, pcm, buffer, data_blocks);\r\nelse\r\namdtp_fill_pcm_silence(s, buffer, data_blocks);\r\nif (s->midi_ports)\r\namdtp_fill_midi(s, buffer, data_blocks);\r\ns->data_block_counter = (s->data_block_counter + data_blocks) & 0xff;\r\npacket.payload_length = 8 + data_blocks * 4 * s->data_block_quadlets;\r\npacket.interrupt = IS_ALIGNED(index + 1, INTERRUPT_INTERVAL);\r\npacket.skip = 0;\r\npacket.tag = TAG_CIP;\r\npacket.sy = 0;\r\npacket.header_length = 0;\r\nerr = fw_iso_context_queue(s->context, &packet, &s->buffer.iso_buffer,\r\ns->buffer.packets[index].offset);\r\nif (err < 0) {\r\ndev_err(&s->unit->device, "queueing error: %d\n", err);\r\ns->packet_index = -1;\r\namdtp_out_stream_pcm_abort(s);\r\nreturn;\r\n}\r\nif (++index >= QUEUE_LENGTH)\r\nindex = 0;\r\ns->packet_index = index;\r\nif (pcm) {\r\nptr = s->pcm_buffer_pointer + data_blocks;\r\nif (ptr >= pcm->runtime->buffer_size)\r\nptr -= pcm->runtime->buffer_size;\r\nACCESS_ONCE(s->pcm_buffer_pointer) = ptr;\r\ns->pcm_period_pointer += data_blocks;\r\nif (s->pcm_period_pointer >= pcm->runtime->period_size) {\r\ns->pcm_period_pointer -= pcm->runtime->period_size;\r\nsnd_pcm_period_elapsed(pcm);\r\n}\r\n}\r\n}\r\nstatic void out_packet_callback(struct fw_iso_context *context, u32 cycle,\r\nsize_t header_length, void *header, void *data)\r\n{\r\nstruct amdtp_out_stream *s = data;\r\nunsigned int i, packets = header_length / 4;\r\ncycle += QUEUE_LENGTH - packets;\r\nfor (i = 0; i < packets; ++i)\r\nqueue_out_packet(s, ++cycle);\r\nfw_iso_context_queue_flush(s->context);\r\n}\r\nstatic int queue_initial_skip_packets(struct amdtp_out_stream *s)\r\n{\r\nstruct fw_iso_packet skip_packet = {\r\n.skip = 1,\r\n};\r\nunsigned int i;\r\nint err;\r\nfor (i = 0; i < QUEUE_LENGTH; ++i) {\r\nskip_packet.interrupt = IS_ALIGNED(s->packet_index + 1,\r\nINTERRUPT_INTERVAL);\r\nerr = fw_iso_context_queue(s->context, &skip_packet, NULL, 0);\r\nif (err < 0)\r\nreturn err;\r\nif (++s->packet_index >= QUEUE_LENGTH)\r\ns->packet_index = 0;\r\n}\r\nreturn 0;\r\n}\r\nint amdtp_out_stream_start(struct amdtp_out_stream *s, int channel, int speed)\r\n{\r\nstatic const struct {\r\nunsigned int data_block;\r\nunsigned int syt_offset;\r\n} initial_state[] = {\r\n[CIP_SFC_32000] = { 4, 3072 },\r\n[CIP_SFC_48000] = { 6, 1024 },\r\n[CIP_SFC_96000] = { 12, 1024 },\r\n[CIP_SFC_192000] = { 24, 1024 },\r\n[CIP_SFC_44100] = { 0, 67 },\r\n[CIP_SFC_88200] = { 0, 67 },\r\n[CIP_SFC_176400] = { 0, 67 },\r\n};\r\nint err;\r\nmutex_lock(&s->mutex);\r\nif (WARN_ON(!IS_ERR(s->context) ||\r\n(!s->pcm_channels && !s->midi_ports))) {\r\nerr = -EBADFD;\r\ngoto err_unlock;\r\n}\r\ns->data_block_state = initial_state[s->sfc].data_block;\r\ns->syt_offset_state = initial_state[s->sfc].syt_offset;\r\ns->last_syt_offset = TICKS_PER_CYCLE;\r\nerr = iso_packets_buffer_init(&s->buffer, s->unit, QUEUE_LENGTH,\r\namdtp_out_stream_get_max_payload(s),\r\nDMA_TO_DEVICE);\r\nif (err < 0)\r\ngoto err_unlock;\r\ns->context = fw_iso_context_create(fw_parent_device(s->unit)->card,\r\nFW_ISO_CONTEXT_TRANSMIT,\r\nchannel, speed, 0,\r\nout_packet_callback, s);\r\nif (IS_ERR(s->context)) {\r\nerr = PTR_ERR(s->context);\r\nif (err == -EBUSY)\r\ndev_err(&s->unit->device,\r\n"no free output stream on this controller\n");\r\ngoto err_buffer;\r\n}\r\namdtp_out_stream_update(s);\r\ns->packet_index = 0;\r\ns->data_block_counter = 0;\r\nerr = queue_initial_skip_packets(s);\r\nif (err < 0)\r\ngoto err_context;\r\nerr = fw_iso_context_start(s->context, -1, 0, 0);\r\nif (err < 0)\r\ngoto err_context;\r\nmutex_unlock(&s->mutex);\r\nreturn 0;\r\nerr_context:\r\nfw_iso_context_destroy(s->context);\r\ns->context = ERR_PTR(-1);\r\nerr_buffer:\r\niso_packets_buffer_destroy(&s->buffer, s->unit);\r\nerr_unlock:\r\nmutex_unlock(&s->mutex);\r\nreturn err;\r\n}\r\nvoid amdtp_out_stream_update(struct amdtp_out_stream *s)\r\n{\r\nACCESS_ONCE(s->source_node_id_field) =\r\n(fw_parent_device(s->unit)->card->node_id & 0x3f) << 24;\r\n}\r\nvoid amdtp_out_stream_stop(struct amdtp_out_stream *s)\r\n{\r\nmutex_lock(&s->mutex);\r\nif (IS_ERR(s->context)) {\r\nmutex_unlock(&s->mutex);\r\nreturn;\r\n}\r\nfw_iso_context_stop(s->context);\r\nfw_iso_context_destroy(s->context);\r\ns->context = ERR_PTR(-1);\r\niso_packets_buffer_destroy(&s->buffer, s->unit);\r\nmutex_unlock(&s->mutex);\r\n}\r\nvoid amdtp_out_stream_pcm_abort(struct amdtp_out_stream *s)\r\n{\r\nstruct snd_pcm_substream *pcm;\r\npcm = ACCESS_ONCE(s->pcm);\r\nif (pcm) {\r\nsnd_pcm_stream_lock_irq(pcm);\r\nif (snd_pcm_running(pcm))\r\nsnd_pcm_stop(pcm, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock_irq(pcm);\r\n}\r\n}
