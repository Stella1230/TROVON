static inline void\r\nwritereg(unsigned int padr, signed int addr, u_char off, u_char val) {\r\noutb_p(0x1c,padr+2);\r\noutb_p(0x14,padr+2);\r\noutb_p((addr+off)&0x7f,padr);\r\noutb_p(0x16,padr+2);\r\noutb_p(val,padr);\r\noutb_p(0x17,padr+2);\r\noutb_p(0x14,padr+2);\r\noutb_p(0x1c,padr+2);\r\n}\r\nstatic inline u_char\r\nreadreg(unsigned int padr, signed int addr, u_char off) {\r\nregister u_char n1, n2;\r\noutb_p(0x1c,padr+2);\r\noutb_p(0x14,padr+2);\r\noutb_p((addr+off)|0x80,padr);\r\noutb_p(0x16,padr+2);\r\noutb_p(0x17,padr+2);\r\nn1 = (inb_p(padr+1) >> 3) & 0x17;\r\noutb_p(0x16,padr+2);\r\nn2 = (inb_p(padr+1) >> 3) & 0x17;\r\noutb_p(0x14,padr+2);\r\noutb_p(0x1c,padr+2);\r\nreturn nibtab[n1] | (nibtab[n2] << 4);\r\n}\r\nstatic inline void\r\nread_fifo(unsigned int padr, signed int adr, u_char * data, int size)\r\n{\r\nint i;\r\nregister u_char n1, n2;\r\noutb_p(0x1c, padr+2);\r\noutb_p(0x14, padr+2);\r\noutb_p(adr|0x80, padr);\r\noutb_p(0x16, padr+2);\r\nfor (i=0; i<size; i++) {\r\noutb_p(0x17, padr+2);\r\nn1 = (inb_p(padr+1) >> 3) & 0x17;\r\noutb_p(0x16,padr+2);\r\nn2 = (inb_p(padr+1) >> 3) & 0x17;\r\n*(data++)=nibtab[n1] | (nibtab[n2] << 4);\r\n}\r\noutb_p(0x14,padr+2);\r\noutb_p(0x1c,padr+2);\r\nreturn;\r\n}\r\nstatic inline void\r\nwrite_fifo(unsigned int padr, signed int adr, u_char * data, int size)\r\n{\r\nint i;\r\noutb_p(0x1c, padr+2);\r\noutb_p(0x14, padr+2);\r\noutb_p(adr&0x7f, padr);\r\nfor (i=0; i<size; i++) {\r\noutb_p(0x16, padr+2);\r\noutb_p(*(data++), padr);\r\noutb_p(0x17, padr+2);\r\n}\r\noutb_p(0x14,padr+2);\r\noutb_p(0x1c,padr+2);\r\nreturn;\r\n}\r\nstatic u_char\r\nReadISAC(struct IsdnCardState *cs, u_char offset)\r\n{\r\nreturn (readreg(cs->hw.teles3.cfg_reg, cs->hw.teles3.isac, offset));\r\n}\r\nstatic void\r\nWriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)\r\n{\r\nwritereg(cs->hw.teles3.cfg_reg, cs->hw.teles3.isac, offset, value);\r\n}\r\nstatic void\r\nReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)\r\n{\r\nread_fifo(cs->hw.teles3.cfg_reg, cs->hw.teles3.isacfifo, data, size);\r\n}\r\nstatic void\r\nWriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)\r\n{\r\nwrite_fifo(cs->hw.teles3.cfg_reg, cs->hw.teles3.isacfifo, data, size);\r\n}\r\nstatic u_char\r\nReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)\r\n{\r\nreturn (readreg(cs->hw.teles3.cfg_reg, cs->hw.teles3.hscx[hscx], offset));\r\n}\r\nstatic void\r\nWriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)\r\n{\r\nwritereg(cs->hw.teles3.cfg_reg, cs->hw.teles3.hscx[hscx], offset, value);\r\n}\r\nstatic irqreturn_t\r\ns0box_interrupt(int intno, void *dev_id)\r\n{\r\n#define MAXCOUNT 5\r\nstruct IsdnCardState *cs = dev_id;\r\nu_char val;\r\nu_long flags;\r\nint count = 0;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nval = readreg(cs->hw.teles3.cfg_reg, cs->hw.teles3.hscx[1], HSCX_ISTA);\r\nStart_HSCX:\r\nif (val)\r\nhscx_int_main(cs, val);\r\nval = readreg(cs->hw.teles3.cfg_reg, cs->hw.teles3.isac, ISAC_ISTA);\r\nStart_ISAC:\r\nif (val)\r\nisac_interrupt(cs, val);\r\ncount++;\r\nval = readreg(cs->hw.teles3.cfg_reg, cs->hw.teles3.hscx[1], HSCX_ISTA);\r\nif (val && count < MAXCOUNT) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "HSCX IntStat after IntRoutine");\r\ngoto Start_HSCX;\r\n}\r\nval = readreg(cs->hw.teles3.cfg_reg, cs->hw.teles3.isac, ISAC_ISTA);\r\nif (val && count < MAXCOUNT) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ISAC IntStat after IntRoutine");\r\ngoto Start_ISAC;\r\n}\r\nif (count >= MAXCOUNT)\r\nprintk(KERN_WARNING "S0Box: more than %d loops in s0box_interrupt\n", count);\r\nwritereg(cs->hw.teles3.cfg_reg, cs->hw.teles3.hscx[0], HSCX_MASK, 0xFF);\r\nwritereg(cs->hw.teles3.cfg_reg, cs->hw.teles3.hscx[1], HSCX_MASK, 0xFF);\r\nwritereg(cs->hw.teles3.cfg_reg, cs->hw.teles3.isac, ISAC_MASK, 0xFF);\r\nwritereg(cs->hw.teles3.cfg_reg, cs->hw.teles3.isac, ISAC_MASK, 0x0);\r\nwritereg(cs->hw.teles3.cfg_reg, cs->hw.teles3.hscx[0], HSCX_MASK, 0x0);\r\nwritereg(cs->hw.teles3.cfg_reg, cs->hw.teles3.hscx[1], HSCX_MASK, 0x0);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nrelease_io_s0box(struct IsdnCardState *cs)\r\n{\r\nrelease_region(cs->hw.teles3.cfg_reg, 8);\r\n}\r\nstatic int\r\nS0Box_card_msg(struct IsdnCardState *cs, int mt, void *arg)\r\n{\r\nu_long flags;\r\nswitch (mt) {\r\ncase CARD_RESET:\r\nbreak;\r\ncase CARD_RELEASE:\r\nrelease_io_s0box(cs);\r\nbreak;\r\ncase CARD_INIT:\r\nspin_lock_irqsave(&cs->lock, flags);\r\ninithscxisac(cs, 3);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase CARD_TEST:\r\nbreak;\r\n}\r\nreturn(0);\r\n}\r\nint __devinit\r\nsetup_s0box(struct IsdnCard *card)\r\n{\r\nstruct IsdnCardState *cs = card->cs;\r\nchar tmp[64];\r\nstrcpy(tmp, s0box_revision);\r\nprintk(KERN_INFO "HiSax: S0Box IO driver Rev. %s\n", HiSax_getrev(tmp));\r\nif (cs->typ != ISDN_CTYPE_S0BOX)\r\nreturn (0);\r\ncs->hw.teles3.cfg_reg = card->para[1];\r\ncs->hw.teles3.hscx[0] = -0x20;\r\ncs->hw.teles3.hscx[1] = 0x0;\r\ncs->hw.teles3.isac = 0x20;\r\ncs->hw.teles3.isacfifo = cs->hw.teles3.isac + 0x3e;\r\ncs->hw.teles3.hscxfifo[0] = cs->hw.teles3.hscx[0] + 0x3e;\r\ncs->hw.teles3.hscxfifo[1] = cs->hw.teles3.hscx[1] + 0x3e;\r\ncs->irq = card->para[0];\r\nif (!request_region(cs->hw.teles3.cfg_reg,8, "S0Box parallel I/O")) {\r\nprintk(KERN_WARNING "HiSax: S0Box ports %x-%x already in use\n",\r\ncs->hw.teles3.cfg_reg,\r\ncs->hw.teles3.cfg_reg + 7);\r\nreturn 0;\r\n}\r\nprintk(KERN_INFO "HiSax: S0Box config irq:%d isac:0x%x cfg:0x%x\n",\r\ncs->irq,\r\ncs->hw.teles3.isac, cs->hw.teles3.cfg_reg);\r\nprintk(KERN_INFO "HiSax: hscx A:0x%x hscx B:0x%x\n",\r\ncs->hw.teles3.hscx[0], cs->hw.teles3.hscx[1]);\r\nsetup_isac(cs);\r\ncs->readisac = &ReadISAC;\r\ncs->writeisac = &WriteISAC;\r\ncs->readisacfifo = &ReadISACfifo;\r\ncs->writeisacfifo = &WriteISACfifo;\r\ncs->BC_Read_Reg = &ReadHSCX;\r\ncs->BC_Write_Reg = &WriteHSCX;\r\ncs->BC_Send_Data = &hscx_fill_fifo;\r\ncs->cardmsg = &S0Box_card_msg;\r\ncs->irq_func = &s0box_interrupt;\r\nISACVersion(cs, "S0Box:");\r\nif (HscxVersion(cs, "S0Box:")) {\r\nprintk(KERN_WARNING\r\n"S0Box: wrong HSCX versions check IO address\n");\r\nrelease_io_s0box(cs);\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}
