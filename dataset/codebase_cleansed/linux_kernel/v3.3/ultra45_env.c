static u8 env_read(struct env *p, u8 ireg)\r\n{\r\nu8 ret;\r\nspin_lock(&p->lock);\r\nwriteb(ireg, p->regs + REG_ADDR);\r\nret = readb(p->regs + REG_DATA);\r\nspin_unlock(&p->lock);\r\nreturn ret;\r\n}\r\nstatic void env_write(struct env *p, u8 ireg, u8 val)\r\n{\r\nspin_lock(&p->lock);\r\nwriteb(ireg, p->regs + REG_ADDR);\r\nwriteb(val, p->regs + REG_DATA);\r\nspin_unlock(&p->lock);\r\n}\r\nstatic ssize_t show_fan_speed(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nint fan_nr = to_sensor_dev_attr(attr)->index;\r\nstruct env *p = dev_get_drvdata(dev);\r\nint rpm, period;\r\nu8 val;\r\nval = env_read(p, IREG_FAN0 + fan_nr);\r\nperiod = (int) val << 8;\r\nif (FAN_DATA_VALID(period))\r\nrpm = FAN_PERIOD_TO_RPM(period);\r\nelse\r\nrpm = 0;\r\nreturn sprintf(buf, "%d\n", rpm);\r\n}\r\nstatic ssize_t set_fan_speed(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint fan_nr = to_sensor_dev_attr(attr)->index;\r\nint rpm = simple_strtol(buf, NULL, 10);\r\nstruct env *p = dev_get_drvdata(dev);\r\nint period;\r\nu8 val;\r\nif (!rpm)\r\nreturn -EINVAL;\r\nperiod = FAN_RPM_TO_PERIOD(rpm);\r\nval = period >> 8;\r\nenv_write(p, IREG_FAN0 + fan_nr, val);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan_fault(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nint fan_nr = to_sensor_dev_attr(attr)->index;\r\nstruct env *p = dev_get_drvdata(dev);\r\nu8 val = env_read(p, IREG_FAN_STAT);\r\nreturn sprintf(buf, "%d\n", (val & (1 << fan_nr)) ? 1 : 0);\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nint temp_nr = to_sensor_dev_attr(attr)->index;\r\nstruct env *p = dev_get_drvdata(dev);\r\ns8 val;\r\nval = env_read(p, IREG_LCL_TEMP + temp_nr);\r\nreturn sprintf(buf, "%d\n", ((int) val) - 64);\r\n}\r\nstatic ssize_t show_stat_bit(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(attr)->index;\r\nstruct env *p = dev_get_drvdata(dev);\r\nu8 val;\r\nval = readb(p->regs + REG_STAT);\r\nreturn sprintf(buf, "%d\n", (val & (1 << index)) ? 1 : 0);\r\n}\r\nstatic ssize_t show_fwver(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct env *p = dev_get_drvdata(dev);\r\nu8 val;\r\nval = readb(p->regs + REG_STAT);\r\nreturn sprintf(buf, "%d\n", val >> 4);\r\n}\r\nstatic ssize_t show_name(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "ultra45\n");\r\n}\r\nstatic int __devinit env_probe(struct platform_device *op)\r\n{\r\nstruct env *p = kzalloc(sizeof(*p), GFP_KERNEL);\r\nint err = -ENOMEM;\r\nif (!p)\r\ngoto out;\r\nspin_lock_init(&p->lock);\r\np->regs = of_ioremap(&op->resource[0], 0, REG_SIZE, "pic16f747");\r\nif (!p->regs)\r\ngoto out_free;\r\nerr = sysfs_create_group(&op->dev.kobj, &env_group);\r\nif (err)\r\ngoto out_iounmap;\r\np->hwmon_dev = hwmon_device_register(&op->dev);\r\nif (IS_ERR(p->hwmon_dev)) {\r\nerr = PTR_ERR(p->hwmon_dev);\r\ngoto out_sysfs_remove_group;\r\n}\r\nplatform_set_drvdata(op, p);\r\nerr = 0;\r\nout:\r\nreturn err;\r\nout_sysfs_remove_group:\r\nsysfs_remove_group(&op->dev.kobj, &env_group);\r\nout_iounmap:\r\nof_iounmap(&op->resource[0], p->regs, REG_SIZE);\r\nout_free:\r\nkfree(p);\r\ngoto out;\r\n}\r\nstatic int __devexit env_remove(struct platform_device *op)\r\n{\r\nstruct env *p = platform_get_drvdata(op);\r\nif (p) {\r\nsysfs_remove_group(&op->dev.kobj, &env_group);\r\nhwmon_device_unregister(p->hwmon_dev);\r\nof_iounmap(&op->resource[0], p->regs, REG_SIZE);\r\nkfree(p);\r\n}\r\nreturn 0;\r\n}
