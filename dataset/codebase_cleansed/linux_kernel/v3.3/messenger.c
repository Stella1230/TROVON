const char *ceph_pr_addr(const struct sockaddr_storage *ss)\r\n{\r\nint i;\r\nchar *s;\r\nstruct sockaddr_in *in4 = (void *)ss;\r\nstruct sockaddr_in6 *in6 = (void *)ss;\r\nspin_lock(&addr_str_lock);\r\ni = last_addr_str++;\r\nif (last_addr_str == MAX_ADDR_STR)\r\nlast_addr_str = 0;\r\nspin_unlock(&addr_str_lock);\r\ns = addr_str[i];\r\nswitch (ss->ss_family) {\r\ncase AF_INET:\r\nsnprintf(s, MAX_ADDR_STR_LEN, "%pI4:%u", &in4->sin_addr,\r\n(unsigned int)ntohs(in4->sin_port));\r\nbreak;\r\ncase AF_INET6:\r\nsnprintf(s, MAX_ADDR_STR_LEN, "[%pI6c]:%u", &in6->sin6_addr,\r\n(unsigned int)ntohs(in6->sin6_port));\r\nbreak;\r\ndefault:\r\nsnprintf(s, MAX_ADDR_STR_LEN, "(unknown sockaddr family %d)",\r\n(int)ss->ss_family);\r\n}\r\nreturn s;\r\n}\r\nstatic void encode_my_addr(struct ceph_messenger *msgr)\r\n{\r\nmemcpy(&msgr->my_enc_addr, &msgr->inst.addr, sizeof(msgr->my_enc_addr));\r\nceph_encode_addr(&msgr->my_enc_addr);\r\n}\r\nint ceph_msgr_init(void)\r\n{\r\nceph_msgr_wq = alloc_workqueue("ceph-msgr", WQ_NON_REENTRANT, 0);\r\nif (!ceph_msgr_wq) {\r\npr_err("msgr_init failed to create workqueue\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid ceph_msgr_exit(void)\r\n{\r\ndestroy_workqueue(ceph_msgr_wq);\r\n}\r\nvoid ceph_msgr_flush(void)\r\n{\r\nflush_workqueue(ceph_msgr_wq);\r\n}\r\nstatic void ceph_data_ready(struct sock *sk, int count_unused)\r\n{\r\nstruct ceph_connection *con =\r\n(struct ceph_connection *)sk->sk_user_data;\r\nif (sk->sk_state != TCP_CLOSE_WAIT) {\r\ndout("ceph_data_ready on %p state = %lu, queueing work\n",\r\ncon, con->state);\r\nqueue_con(con);\r\n}\r\n}\r\nstatic void ceph_write_space(struct sock *sk)\r\n{\r\nstruct ceph_connection *con =\r\n(struct ceph_connection *)sk->sk_user_data;\r\nif (test_bit(WRITE_PENDING, &con->state)) {\r\ndout("ceph_write_space %p queueing write work\n", con);\r\nqueue_con(con);\r\n} else {\r\ndout("ceph_write_space %p nothing to write\n", con);\r\n}\r\nclear_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\r\n}\r\nstatic void ceph_state_change(struct sock *sk)\r\n{\r\nstruct ceph_connection *con =\r\n(struct ceph_connection *)sk->sk_user_data;\r\ndout("ceph_state_change %p state = %lu sk_state = %u\n",\r\ncon, con->state, sk->sk_state);\r\nif (test_bit(CLOSED, &con->state))\r\nreturn;\r\nswitch (sk->sk_state) {\r\ncase TCP_CLOSE:\r\ndout("ceph_state_change TCP_CLOSE\n");\r\ncase TCP_CLOSE_WAIT:\r\ndout("ceph_state_change TCP_CLOSE_WAIT\n");\r\nif (test_and_set_bit(SOCK_CLOSED, &con->state) == 0) {\r\nif (test_bit(CONNECTING, &con->state))\r\ncon->error_msg = "connection failed";\r\nelse\r\ncon->error_msg = "socket closed";\r\nqueue_con(con);\r\n}\r\nbreak;\r\ncase TCP_ESTABLISHED:\r\ndout("ceph_state_change TCP_ESTABLISHED\n");\r\nqueue_con(con);\r\nbreak;\r\n}\r\n}\r\nstatic void set_sock_callbacks(struct socket *sock,\r\nstruct ceph_connection *con)\r\n{\r\nstruct sock *sk = sock->sk;\r\nsk->sk_user_data = (void *)con;\r\nsk->sk_data_ready = ceph_data_ready;\r\nsk->sk_write_space = ceph_write_space;\r\nsk->sk_state_change = ceph_state_change;\r\n}\r\nstatic struct socket *ceph_tcp_connect(struct ceph_connection *con)\r\n{\r\nstruct sockaddr_storage *paddr = &con->peer_addr.in_addr;\r\nstruct socket *sock;\r\nint ret;\r\nBUG_ON(con->sock);\r\nret = sock_create_kern(con->peer_addr.in_addr.ss_family, SOCK_STREAM,\r\nIPPROTO_TCP, &sock);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\ncon->sock = sock;\r\nsock->sk->sk_allocation = GFP_NOFS;\r\n#ifdef CONFIG_LOCKDEP\r\nlockdep_set_class(&sock->sk->sk_lock, &socket_class);\r\n#endif\r\nset_sock_callbacks(sock, con);\r\ndout("connect %s\n", ceph_pr_addr(&con->peer_addr.in_addr));\r\nret = sock->ops->connect(sock, (struct sockaddr *)paddr, sizeof(*paddr),\r\nO_NONBLOCK);\r\nif (ret == -EINPROGRESS) {\r\ndout("connect %s EINPROGRESS sk_state = %u\n",\r\nceph_pr_addr(&con->peer_addr.in_addr),\r\nsock->sk->sk_state);\r\nret = 0;\r\n}\r\nif (ret < 0) {\r\npr_err("connect %s error %d\n",\r\nceph_pr_addr(&con->peer_addr.in_addr), ret);\r\nsock_release(sock);\r\ncon->sock = NULL;\r\ncon->error_msg = "connect error";\r\n}\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nreturn sock;\r\n}\r\nstatic int ceph_tcp_recvmsg(struct socket *sock, void *buf, size_t len)\r\n{\r\nstruct kvec iov = {buf, len};\r\nstruct msghdr msg = { .msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL };\r\nint r;\r\nr = kernel_recvmsg(sock, &msg, &iov, 1, len, msg.msg_flags);\r\nif (r == -EAGAIN)\r\nr = 0;\r\nreturn r;\r\n}\r\nstatic int ceph_tcp_sendmsg(struct socket *sock, struct kvec *iov,\r\nsize_t kvlen, size_t len, int more)\r\n{\r\nstruct msghdr msg = { .msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL };\r\nint r;\r\nif (more)\r\nmsg.msg_flags |= MSG_MORE;\r\nelse\r\nmsg.msg_flags |= MSG_EOR;\r\nr = kernel_sendmsg(sock, &msg, iov, kvlen, len);\r\nif (r == -EAGAIN)\r\nr = 0;\r\nreturn r;\r\n}\r\nstatic int con_close_socket(struct ceph_connection *con)\r\n{\r\nint rc;\r\ndout("con_close_socket on %p sock %p\n", con, con->sock);\r\nif (!con->sock)\r\nreturn 0;\r\nset_bit(SOCK_CLOSED, &con->state);\r\nrc = con->sock->ops->shutdown(con->sock, SHUT_RDWR);\r\nsock_release(con->sock);\r\ncon->sock = NULL;\r\nclear_bit(SOCK_CLOSED, &con->state);\r\nreturn rc;\r\n}\r\nstatic void ceph_msg_remove(struct ceph_msg *msg)\r\n{\r\nlist_del_init(&msg->list_head);\r\nceph_msg_put(msg);\r\n}\r\nstatic void ceph_msg_remove_list(struct list_head *head)\r\n{\r\nwhile (!list_empty(head)) {\r\nstruct ceph_msg *msg = list_first_entry(head, struct ceph_msg,\r\nlist_head);\r\nceph_msg_remove(msg);\r\n}\r\n}\r\nstatic void reset_connection(struct ceph_connection *con)\r\n{\r\nceph_msg_remove_list(&con->out_queue);\r\nceph_msg_remove_list(&con->out_sent);\r\nif (con->in_msg) {\r\nceph_msg_put(con->in_msg);\r\ncon->in_msg = NULL;\r\n}\r\ncon->connect_seq = 0;\r\ncon->out_seq = 0;\r\nif (con->out_msg) {\r\nceph_msg_put(con->out_msg);\r\ncon->out_msg = NULL;\r\n}\r\ncon->in_seq = 0;\r\ncon->in_seq_acked = 0;\r\n}\r\nvoid ceph_con_close(struct ceph_connection *con)\r\n{\r\ndout("con_close %p peer %s\n", con,\r\nceph_pr_addr(&con->peer_addr.in_addr));\r\nset_bit(CLOSED, &con->state);\r\nclear_bit(STANDBY, &con->state);\r\nclear_bit(LOSSYTX, &con->state);\r\nclear_bit(KEEPALIVE_PENDING, &con->state);\r\nclear_bit(WRITE_PENDING, &con->state);\r\nmutex_lock(&con->mutex);\r\nreset_connection(con);\r\ncon->peer_global_seq = 0;\r\ncancel_delayed_work(&con->work);\r\nmutex_unlock(&con->mutex);\r\nqueue_con(con);\r\n}\r\nvoid ceph_con_open(struct ceph_connection *con, struct ceph_entity_addr *addr)\r\n{\r\ndout("con_open %p %s\n", con, ceph_pr_addr(&addr->in_addr));\r\nset_bit(OPENING, &con->state);\r\nclear_bit(CLOSED, &con->state);\r\nmemcpy(&con->peer_addr, addr, sizeof(*addr));\r\ncon->delay = 0;\r\nqueue_con(con);\r\n}\r\nbool ceph_con_opened(struct ceph_connection *con)\r\n{\r\nreturn con->connect_seq > 0;\r\n}\r\nstruct ceph_connection *ceph_con_get(struct ceph_connection *con)\r\n{\r\ndout("con_get %p nref = %d -> %d\n", con,\r\natomic_read(&con->nref), atomic_read(&con->nref) + 1);\r\nif (atomic_inc_not_zero(&con->nref))\r\nreturn con;\r\nreturn NULL;\r\n}\r\nvoid ceph_con_put(struct ceph_connection *con)\r\n{\r\ndout("con_put %p nref = %d -> %d\n", con,\r\natomic_read(&con->nref), atomic_read(&con->nref) - 1);\r\nBUG_ON(atomic_read(&con->nref) == 0);\r\nif (atomic_dec_and_test(&con->nref)) {\r\nBUG_ON(con->sock);\r\nkfree(con);\r\n}\r\n}\r\nvoid ceph_con_init(struct ceph_messenger *msgr, struct ceph_connection *con)\r\n{\r\ndout("con_init %p\n", con);\r\nmemset(con, 0, sizeof(*con));\r\natomic_set(&con->nref, 1);\r\ncon->msgr = msgr;\r\nmutex_init(&con->mutex);\r\nINIT_LIST_HEAD(&con->out_queue);\r\nINIT_LIST_HEAD(&con->out_sent);\r\nINIT_DELAYED_WORK(&con->work, con_work);\r\n}\r\nstatic u32 get_global_seq(struct ceph_messenger *msgr, u32 gt)\r\n{\r\nu32 ret;\r\nspin_lock(&msgr->global_seq_lock);\r\nif (msgr->global_seq < gt)\r\nmsgr->global_seq = gt;\r\nret = ++msgr->global_seq;\r\nspin_unlock(&msgr->global_seq_lock);\r\nreturn ret;\r\n}\r\nstatic void prepare_write_message_footer(struct ceph_connection *con, int v)\r\n{\r\nstruct ceph_msg *m = con->out_msg;\r\ndout("prepare_write_message_footer %p\n", con);\r\ncon->out_kvec_is_msg = true;\r\ncon->out_kvec[v].iov_base = &m->footer;\r\ncon->out_kvec[v].iov_len = sizeof(m->footer);\r\ncon->out_kvec_bytes += sizeof(m->footer);\r\ncon->out_kvec_left++;\r\ncon->out_more = m->more_to_follow;\r\ncon->out_msg_done = true;\r\n}\r\nstatic void prepare_write_message(struct ceph_connection *con)\r\n{\r\nstruct ceph_msg *m;\r\nint v = 0;\r\ncon->out_kvec_bytes = 0;\r\ncon->out_kvec_is_msg = true;\r\ncon->out_msg_done = false;\r\nif (con->in_seq > con->in_seq_acked) {\r\ncon->in_seq_acked = con->in_seq;\r\ncon->out_kvec[v].iov_base = &tag_ack;\r\ncon->out_kvec[v++].iov_len = 1;\r\ncon->out_temp_ack = cpu_to_le64(con->in_seq_acked);\r\ncon->out_kvec[v].iov_base = &con->out_temp_ack;\r\ncon->out_kvec[v++].iov_len = sizeof(con->out_temp_ack);\r\ncon->out_kvec_bytes = 1 + sizeof(con->out_temp_ack);\r\n}\r\nm = list_first_entry(&con->out_queue,\r\nstruct ceph_msg, list_head);\r\ncon->out_msg = m;\r\nceph_msg_get(m);\r\nlist_move_tail(&m->list_head, &con->out_sent);\r\nif (m->needs_out_seq) {\r\nm->hdr.seq = cpu_to_le64(++con->out_seq);\r\nm->needs_out_seq = false;\r\n}\r\ndout("prepare_write_message %p seq %lld type %d len %d+%d+%d %d pgs\n",\r\nm, con->out_seq, le16_to_cpu(m->hdr.type),\r\nle32_to_cpu(m->hdr.front_len), le32_to_cpu(m->hdr.middle_len),\r\nle32_to_cpu(m->hdr.data_len),\r\nm->nr_pages);\r\nBUG_ON(le32_to_cpu(m->hdr.front_len) != m->front.iov_len);\r\ncon->out_kvec[v].iov_base = &tag_msg;\r\ncon->out_kvec[v++].iov_len = 1;\r\ncon->out_kvec[v].iov_base = &m->hdr;\r\ncon->out_kvec[v++].iov_len = sizeof(m->hdr);\r\ncon->out_kvec[v++] = m->front;\r\nif (m->middle)\r\ncon->out_kvec[v++] = m->middle->vec;\r\ncon->out_kvec_left = v;\r\ncon->out_kvec_bytes += 1 + sizeof(m->hdr) + m->front.iov_len +\r\n(m->middle ? m->middle->vec.iov_len : 0);\r\ncon->out_kvec_cur = con->out_kvec;\r\ncon->out_msg->hdr.crc =\r\ncpu_to_le32(crc32c(0, (void *)&m->hdr,\r\nsizeof(m->hdr) - sizeof(m->hdr.crc)));\r\ncon->out_msg->footer.flags = CEPH_MSG_FOOTER_COMPLETE;\r\ncon->out_msg->footer.front_crc =\r\ncpu_to_le32(crc32c(0, m->front.iov_base, m->front.iov_len));\r\nif (m->middle)\r\ncon->out_msg->footer.middle_crc =\r\ncpu_to_le32(crc32c(0, m->middle->vec.iov_base,\r\nm->middle->vec.iov_len));\r\nelse\r\ncon->out_msg->footer.middle_crc = 0;\r\ncon->out_msg->footer.data_crc = 0;\r\ndout("prepare_write_message front_crc %u data_crc %u\n",\r\nle32_to_cpu(con->out_msg->footer.front_crc),\r\nle32_to_cpu(con->out_msg->footer.middle_crc));\r\nif (le32_to_cpu(m->hdr.data_len) > 0) {\r\ncon->out_msg_pos.page = 0;\r\nif (m->pages)\r\ncon->out_msg_pos.page_pos = m->page_alignment;\r\nelse\r\ncon->out_msg_pos.page_pos = 0;\r\ncon->out_msg_pos.data_pos = 0;\r\ncon->out_msg_pos.did_page_crc = 0;\r\ncon->out_more = 1;\r\n} else {\r\nprepare_write_message_footer(con, v);\r\n}\r\nset_bit(WRITE_PENDING, &con->state);\r\n}\r\nstatic void prepare_write_ack(struct ceph_connection *con)\r\n{\r\ndout("prepare_write_ack %p %llu -> %llu\n", con,\r\ncon->in_seq_acked, con->in_seq);\r\ncon->in_seq_acked = con->in_seq;\r\ncon->out_kvec[0].iov_base = &tag_ack;\r\ncon->out_kvec[0].iov_len = 1;\r\ncon->out_temp_ack = cpu_to_le64(con->in_seq_acked);\r\ncon->out_kvec[1].iov_base = &con->out_temp_ack;\r\ncon->out_kvec[1].iov_len = sizeof(con->out_temp_ack);\r\ncon->out_kvec_left = 2;\r\ncon->out_kvec_bytes = 1 + sizeof(con->out_temp_ack);\r\ncon->out_kvec_cur = con->out_kvec;\r\ncon->out_more = 1;\r\nset_bit(WRITE_PENDING, &con->state);\r\n}\r\nstatic void prepare_write_keepalive(struct ceph_connection *con)\r\n{\r\ndout("prepare_write_keepalive %p\n", con);\r\ncon->out_kvec[0].iov_base = &tag_keepalive;\r\ncon->out_kvec[0].iov_len = 1;\r\ncon->out_kvec_left = 1;\r\ncon->out_kvec_bytes = 1;\r\ncon->out_kvec_cur = con->out_kvec;\r\nset_bit(WRITE_PENDING, &con->state);\r\n}\r\nstatic int prepare_connect_authorizer(struct ceph_connection *con)\r\n{\r\nvoid *auth_buf;\r\nint auth_len = 0;\r\nint auth_protocol = 0;\r\nmutex_unlock(&con->mutex);\r\nif (con->ops->get_authorizer)\r\ncon->ops->get_authorizer(con, &auth_buf, &auth_len,\r\n&auth_protocol, &con->auth_reply_buf,\r\n&con->auth_reply_buf_len,\r\ncon->auth_retry);\r\nmutex_lock(&con->mutex);\r\nif (test_bit(CLOSED, &con->state) ||\r\ntest_bit(OPENING, &con->state))\r\nreturn -EAGAIN;\r\ncon->out_connect.authorizer_protocol = cpu_to_le32(auth_protocol);\r\ncon->out_connect.authorizer_len = cpu_to_le32(auth_len);\r\nif (auth_len) {\r\ncon->out_kvec[con->out_kvec_left].iov_base = auth_buf;\r\ncon->out_kvec[con->out_kvec_left].iov_len = auth_len;\r\ncon->out_kvec_left++;\r\ncon->out_kvec_bytes += auth_len;\r\n}\r\nreturn 0;\r\n}\r\nstatic void prepare_write_banner(struct ceph_messenger *msgr,\r\nstruct ceph_connection *con)\r\n{\r\nint len = strlen(CEPH_BANNER);\r\ncon->out_kvec[0].iov_base = CEPH_BANNER;\r\ncon->out_kvec[0].iov_len = len;\r\ncon->out_kvec[1].iov_base = &msgr->my_enc_addr;\r\ncon->out_kvec[1].iov_len = sizeof(msgr->my_enc_addr);\r\ncon->out_kvec_left = 2;\r\ncon->out_kvec_bytes = len + sizeof(msgr->my_enc_addr);\r\ncon->out_kvec_cur = con->out_kvec;\r\ncon->out_more = 0;\r\nset_bit(WRITE_PENDING, &con->state);\r\n}\r\nstatic int prepare_write_connect(struct ceph_messenger *msgr,\r\nstruct ceph_connection *con,\r\nint after_banner)\r\n{\r\nunsigned global_seq = get_global_seq(con->msgr, 0);\r\nint proto;\r\nswitch (con->peer_name.type) {\r\ncase CEPH_ENTITY_TYPE_MON:\r\nproto = CEPH_MONC_PROTOCOL;\r\nbreak;\r\ncase CEPH_ENTITY_TYPE_OSD:\r\nproto = CEPH_OSDC_PROTOCOL;\r\nbreak;\r\ncase CEPH_ENTITY_TYPE_MDS:\r\nproto = CEPH_MDSC_PROTOCOL;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\ndout("prepare_write_connect %p cseq=%d gseq=%d proto=%d\n", con,\r\ncon->connect_seq, global_seq, proto);\r\ncon->out_connect.features = cpu_to_le64(msgr->supported_features);\r\ncon->out_connect.host_type = cpu_to_le32(CEPH_ENTITY_TYPE_CLIENT);\r\ncon->out_connect.connect_seq = cpu_to_le32(con->connect_seq);\r\ncon->out_connect.global_seq = cpu_to_le32(global_seq);\r\ncon->out_connect.protocol_version = cpu_to_le32(proto);\r\ncon->out_connect.flags = 0;\r\nif (!after_banner) {\r\ncon->out_kvec_left = 0;\r\ncon->out_kvec_bytes = 0;\r\n}\r\ncon->out_kvec[con->out_kvec_left].iov_base = &con->out_connect;\r\ncon->out_kvec[con->out_kvec_left].iov_len = sizeof(con->out_connect);\r\ncon->out_kvec_left++;\r\ncon->out_kvec_bytes += sizeof(con->out_connect);\r\ncon->out_kvec_cur = con->out_kvec;\r\ncon->out_more = 0;\r\nset_bit(WRITE_PENDING, &con->state);\r\nreturn prepare_connect_authorizer(con);\r\n}\r\nstatic int write_partial_kvec(struct ceph_connection *con)\r\n{\r\nint ret;\r\ndout("write_partial_kvec %p %d left\n", con, con->out_kvec_bytes);\r\nwhile (con->out_kvec_bytes > 0) {\r\nret = ceph_tcp_sendmsg(con->sock, con->out_kvec_cur,\r\ncon->out_kvec_left, con->out_kvec_bytes,\r\ncon->out_more);\r\nif (ret <= 0)\r\ngoto out;\r\ncon->out_kvec_bytes -= ret;\r\nif (con->out_kvec_bytes == 0)\r\nbreak;\r\nwhile (ret > 0) {\r\nif (ret >= con->out_kvec_cur->iov_len) {\r\nret -= con->out_kvec_cur->iov_len;\r\ncon->out_kvec_cur++;\r\ncon->out_kvec_left--;\r\n} else {\r\ncon->out_kvec_cur->iov_len -= ret;\r\ncon->out_kvec_cur->iov_base += ret;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\ncon->out_kvec_left = 0;\r\ncon->out_kvec_is_msg = false;\r\nret = 1;\r\nout:\r\ndout("write_partial_kvec %p %d left in %d kvecs ret = %d\n", con,\r\ncon->out_kvec_bytes, con->out_kvec_left, ret);\r\nreturn ret;\r\n}\r\nstatic void init_bio_iter(struct bio *bio, struct bio **iter, int *seg)\r\n{\r\nif (!bio) {\r\n*iter = NULL;\r\n*seg = 0;\r\nreturn;\r\n}\r\n*iter = bio;\r\n*seg = bio->bi_idx;\r\n}\r\nstatic void iter_bio_next(struct bio **bio_iter, int *seg)\r\n{\r\nif (*bio_iter == NULL)\r\nreturn;\r\nBUG_ON(*seg >= (*bio_iter)->bi_vcnt);\r\n(*seg)++;\r\nif (*seg == (*bio_iter)->bi_vcnt)\r\ninit_bio_iter((*bio_iter)->bi_next, bio_iter, seg);\r\n}\r\nstatic int write_partial_msg_pages(struct ceph_connection *con)\r\n{\r\nstruct ceph_msg *msg = con->out_msg;\r\nunsigned data_len = le32_to_cpu(msg->hdr.data_len);\r\nsize_t len;\r\nint crc = con->msgr->nocrc;\r\nint ret;\r\nint total_max_write;\r\nint in_trail = 0;\r\nsize_t trail_len = (msg->trail ? msg->trail->length : 0);\r\ndout("write_partial_msg_pages %p msg %p page %d/%d offset %d\n",\r\ncon, con->out_msg, con->out_msg_pos.page, con->out_msg->nr_pages,\r\ncon->out_msg_pos.page_pos);\r\n#ifdef CONFIG_BLOCK\r\nif (msg->bio && !msg->bio_iter)\r\ninit_bio_iter(msg->bio, &msg->bio_iter, &msg->bio_seg);\r\n#endif\r\nwhile (data_len > con->out_msg_pos.data_pos) {\r\nstruct page *page = NULL;\r\nvoid *kaddr = NULL;\r\nint max_write = PAGE_SIZE;\r\nint page_shift = 0;\r\ntotal_max_write = data_len - trail_len -\r\ncon->out_msg_pos.data_pos;\r\nif (con->out_msg_pos.data_pos >= data_len - trail_len) {\r\nin_trail = 1;\r\ntotal_max_write = data_len - con->out_msg_pos.data_pos;\r\npage = list_first_entry(&msg->trail->head,\r\nstruct page, lru);\r\nif (crc)\r\nkaddr = kmap(page);\r\nmax_write = PAGE_SIZE;\r\n} else if (msg->pages) {\r\npage = msg->pages[con->out_msg_pos.page];\r\nif (crc)\r\nkaddr = kmap(page);\r\n} else if (msg->pagelist) {\r\npage = list_first_entry(&msg->pagelist->head,\r\nstruct page, lru);\r\nif (crc)\r\nkaddr = kmap(page);\r\n#ifdef CONFIG_BLOCK\r\n} else if (msg->bio) {\r\nstruct bio_vec *bv;\r\nbv = bio_iovec_idx(msg->bio_iter, msg->bio_seg);\r\npage = bv->bv_page;\r\npage_shift = bv->bv_offset;\r\nif (crc)\r\nkaddr = kmap(page) + page_shift;\r\nmax_write = bv->bv_len;\r\n#endif\r\n} else {\r\npage = con->msgr->zero_page;\r\nif (crc)\r\nkaddr = page_address(con->msgr->zero_page);\r\n}\r\nlen = min_t(int, max_write - con->out_msg_pos.page_pos,\r\ntotal_max_write);\r\nif (crc && !con->out_msg_pos.did_page_crc) {\r\nvoid *base = kaddr + con->out_msg_pos.page_pos;\r\nu32 tmpcrc = le32_to_cpu(con->out_msg->footer.data_crc);\r\nBUG_ON(kaddr == NULL);\r\ncon->out_msg->footer.data_crc =\r\ncpu_to_le32(crc32c(tmpcrc, base, len));\r\ncon->out_msg_pos.did_page_crc = 1;\r\n}\r\nret = kernel_sendpage(con->sock, page,\r\ncon->out_msg_pos.page_pos + page_shift,\r\nlen,\r\nMSG_DONTWAIT | MSG_NOSIGNAL |\r\nMSG_MORE);\r\nif (crc &&\r\n(msg->pages || msg->pagelist || msg->bio || in_trail))\r\nkunmap(page);\r\nif (ret == -EAGAIN)\r\nret = 0;\r\nif (ret <= 0)\r\ngoto out;\r\ncon->out_msg_pos.data_pos += ret;\r\ncon->out_msg_pos.page_pos += ret;\r\nif (ret == len) {\r\ncon->out_msg_pos.page_pos = 0;\r\ncon->out_msg_pos.page++;\r\ncon->out_msg_pos.did_page_crc = 0;\r\nif (in_trail)\r\nlist_move_tail(&page->lru,\r\n&msg->trail->head);\r\nelse if (msg->pagelist)\r\nlist_move_tail(&page->lru,\r\n&msg->pagelist->head);\r\n#ifdef CONFIG_BLOCK\r\nelse if (msg->bio)\r\niter_bio_next(&msg->bio_iter, &msg->bio_seg);\r\n#endif\r\n}\r\n}\r\ndout("write_partial_msg_pages %p msg %p done\n", con, msg);\r\nif (!crc)\r\ncon->out_msg->footer.flags |= CEPH_MSG_FOOTER_NOCRC;\r\ncon->out_kvec_bytes = 0;\r\ncon->out_kvec_left = 0;\r\ncon->out_kvec_cur = con->out_kvec;\r\nprepare_write_message_footer(con, 0);\r\nret = 1;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int write_partial_skip(struct ceph_connection *con)\r\n{\r\nint ret;\r\nwhile (con->out_skip > 0) {\r\nstruct kvec iov = {\r\n.iov_base = page_address(con->msgr->zero_page),\r\n.iov_len = min(con->out_skip, (int)PAGE_CACHE_SIZE)\r\n};\r\nret = ceph_tcp_sendmsg(con->sock, &iov, 1, iov.iov_len, 1);\r\nif (ret <= 0)\r\ngoto out;\r\ncon->out_skip -= ret;\r\n}\r\nret = 1;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void prepare_read_banner(struct ceph_connection *con)\r\n{\r\ndout("prepare_read_banner %p\n", con);\r\ncon->in_base_pos = 0;\r\n}\r\nstatic void prepare_read_connect(struct ceph_connection *con)\r\n{\r\ndout("prepare_read_connect %p\n", con);\r\ncon->in_base_pos = 0;\r\n}\r\nstatic void prepare_read_ack(struct ceph_connection *con)\r\n{\r\ndout("prepare_read_ack %p\n", con);\r\ncon->in_base_pos = 0;\r\n}\r\nstatic void prepare_read_tag(struct ceph_connection *con)\r\n{\r\ndout("prepare_read_tag %p\n", con);\r\ncon->in_base_pos = 0;\r\ncon->in_tag = CEPH_MSGR_TAG_READY;\r\n}\r\nstatic int prepare_read_message(struct ceph_connection *con)\r\n{\r\ndout("prepare_read_message %p\n", con);\r\nBUG_ON(con->in_msg != NULL);\r\ncon->in_base_pos = 0;\r\ncon->in_front_crc = con->in_middle_crc = con->in_data_crc = 0;\r\nreturn 0;\r\n}\r\nstatic int read_partial(struct ceph_connection *con,\r\nint *to, int size, void *object)\r\n{\r\n*to += size;\r\nwhile (con->in_base_pos < *to) {\r\nint left = *to - con->in_base_pos;\r\nint have = size - left;\r\nint ret = ceph_tcp_recvmsg(con->sock, object + have, left);\r\nif (ret <= 0)\r\nreturn ret;\r\ncon->in_base_pos += ret;\r\n}\r\nreturn 1;\r\n}\r\nstatic int read_partial_banner(struct ceph_connection *con)\r\n{\r\nint ret, to = 0;\r\ndout("read_partial_banner %p at %d\n", con, con->in_base_pos);\r\nret = read_partial(con, &to, strlen(CEPH_BANNER), con->in_banner);\r\nif (ret <= 0)\r\ngoto out;\r\nret = read_partial(con, &to, sizeof(con->actual_peer_addr),\r\n&con->actual_peer_addr);\r\nif (ret <= 0)\r\ngoto out;\r\nret = read_partial(con, &to, sizeof(con->peer_addr_for_me),\r\n&con->peer_addr_for_me);\r\nif (ret <= 0)\r\ngoto out;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int read_partial_connect(struct ceph_connection *con)\r\n{\r\nint ret, to = 0;\r\ndout("read_partial_connect %p at %d\n", con, con->in_base_pos);\r\nret = read_partial(con, &to, sizeof(con->in_reply), &con->in_reply);\r\nif (ret <= 0)\r\ngoto out;\r\nret = read_partial(con, &to, le32_to_cpu(con->in_reply.authorizer_len),\r\ncon->auth_reply_buf);\r\nif (ret <= 0)\r\ngoto out;\r\ndout("read_partial_connect %p tag %d, con_seq = %u, g_seq = %u\n",\r\ncon, (int)con->in_reply.tag,\r\nle32_to_cpu(con->in_reply.connect_seq),\r\nle32_to_cpu(con->in_reply.global_seq));\r\nout:\r\nreturn ret;\r\n}\r\nstatic int verify_hello(struct ceph_connection *con)\r\n{\r\nif (memcmp(con->in_banner, CEPH_BANNER, strlen(CEPH_BANNER))) {\r\npr_err("connect to %s got bad banner\n",\r\nceph_pr_addr(&con->peer_addr.in_addr));\r\ncon->error_msg = "protocol error, bad banner";\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool addr_is_blank(struct sockaddr_storage *ss)\r\n{\r\nswitch (ss->ss_family) {\r\ncase AF_INET:\r\nreturn ((struct sockaddr_in *)ss)->sin_addr.s_addr == 0;\r\ncase AF_INET6:\r\nreturn\r\n((struct sockaddr_in6 *)ss)->sin6_addr.s6_addr32[0] == 0 &&\r\n((struct sockaddr_in6 *)ss)->sin6_addr.s6_addr32[1] == 0 &&\r\n((struct sockaddr_in6 *)ss)->sin6_addr.s6_addr32[2] == 0 &&\r\n((struct sockaddr_in6 *)ss)->sin6_addr.s6_addr32[3] == 0;\r\n}\r\nreturn false;\r\n}\r\nstatic int addr_port(struct sockaddr_storage *ss)\r\n{\r\nswitch (ss->ss_family) {\r\ncase AF_INET:\r\nreturn ntohs(((struct sockaddr_in *)ss)->sin_port);\r\ncase AF_INET6:\r\nreturn ntohs(((struct sockaddr_in6 *)ss)->sin6_port);\r\n}\r\nreturn 0;\r\n}\r\nstatic void addr_set_port(struct sockaddr_storage *ss, int p)\r\n{\r\nswitch (ss->ss_family) {\r\ncase AF_INET:\r\n((struct sockaddr_in *)ss)->sin_port = htons(p);\r\nbreak;\r\ncase AF_INET6:\r\n((struct sockaddr_in6 *)ss)->sin6_port = htons(p);\r\nbreak;\r\n}\r\n}\r\nstatic int ceph_pton(const char *str, size_t len, struct sockaddr_storage *ss,\r\nchar delim, const char **ipend)\r\n{\r\nstruct sockaddr_in *in4 = (void *)ss;\r\nstruct sockaddr_in6 *in6 = (void *)ss;\r\nmemset(ss, 0, sizeof(*ss));\r\nif (in4_pton(str, len, (u8 *)&in4->sin_addr.s_addr, delim, ipend)) {\r\nss->ss_family = AF_INET;\r\nreturn 0;\r\n}\r\nif (in6_pton(str, len, (u8 *)&in6->sin6_addr.s6_addr, delim, ipend)) {\r\nss->ss_family = AF_INET6;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ceph_dns_resolve_name(const char *name, size_t namelen,\r\nstruct sockaddr_storage *ss, char delim, const char **ipend)\r\n{\r\nconst char *end, *delim_p;\r\nchar *colon_p, *ip_addr = NULL;\r\nint ip_len, ret;\r\ndelim_p = memchr(name, delim, namelen);\r\ncolon_p = memchr(name, ':', namelen);\r\nif (delim_p && colon_p)\r\nend = delim_p < colon_p ? delim_p : colon_p;\r\nelse if (!delim_p && colon_p)\r\nend = colon_p;\r\nelse {\r\nend = delim_p;\r\nif (!end)\r\nend = name + namelen;\r\n}\r\nif (end <= name)\r\nreturn -EINVAL;\r\nip_len = dns_query(NULL, name, end - name, NULL, &ip_addr, NULL);\r\nif (ip_len > 0)\r\nret = ceph_pton(ip_addr, ip_len, ss, -1, NULL);\r\nelse\r\nret = -ESRCH;\r\nkfree(ip_addr);\r\n*ipend = end;\r\npr_info("resolve '%.*s' (ret=%d): %s\n", (int)(end - name), name,\r\nret, ret ? "failed" : ceph_pr_addr(ss));\r\nreturn ret;\r\n}\r\nstatic inline int ceph_dns_resolve_name(const char *name, size_t namelen,\r\nstruct sockaddr_storage *ss, char delim, const char **ipend)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int ceph_parse_server_name(const char *name, size_t namelen,\r\nstruct sockaddr_storage *ss, char delim, const char **ipend)\r\n{\r\nint ret;\r\nret = ceph_pton(name, namelen, ss, delim, ipend);\r\nif (ret)\r\nret = ceph_dns_resolve_name(name, namelen, ss, delim, ipend);\r\nreturn ret;\r\n}\r\nint ceph_parse_ips(const char *c, const char *end,\r\nstruct ceph_entity_addr *addr,\r\nint max_count, int *count)\r\n{\r\nint i, ret = -EINVAL;\r\nconst char *p = c;\r\ndout("parse_ips on '%.*s'\n", (int)(end-c), c);\r\nfor (i = 0; i < max_count; i++) {\r\nconst char *ipend;\r\nstruct sockaddr_storage *ss = &addr[i].in_addr;\r\nint port;\r\nchar delim = ',';\r\nif (*p == '[') {\r\ndelim = ']';\r\np++;\r\n}\r\nret = ceph_parse_server_name(p, end - p, ss, delim, &ipend);\r\nif (ret)\r\ngoto bad;\r\nret = -EINVAL;\r\np = ipend;\r\nif (delim == ']') {\r\nif (*p != ']') {\r\ndout("missing matching ']'\n");\r\ngoto bad;\r\n}\r\np++;\r\n}\r\nif (p < end && *p == ':') {\r\nport = 0;\r\np++;\r\nwhile (p < end && *p >= '0' && *p <= '9') {\r\nport = (port * 10) + (*p - '0');\r\np++;\r\n}\r\nif (port > 65535 || port == 0)\r\ngoto bad;\r\n} else {\r\nport = CEPH_MON_PORT;\r\n}\r\naddr_set_port(ss, port);\r\ndout("parse_ips got %s\n", ceph_pr_addr(ss));\r\nif (p == end)\r\nbreak;\r\nif (*p != ',')\r\ngoto bad;\r\np++;\r\n}\r\nif (p != end)\r\ngoto bad;\r\nif (count)\r\n*count = i + 1;\r\nreturn 0;\r\nbad:\r\npr_err("parse_ips bad ip '%.*s'\n", (int)(end - c), c);\r\nreturn ret;\r\n}\r\nstatic int process_banner(struct ceph_connection *con)\r\n{\r\ndout("process_banner on %p\n", con);\r\nif (verify_hello(con) < 0)\r\nreturn -1;\r\nceph_decode_addr(&con->actual_peer_addr);\r\nceph_decode_addr(&con->peer_addr_for_me);\r\nif (memcmp(&con->peer_addr, &con->actual_peer_addr,\r\nsizeof(con->peer_addr)) != 0 &&\r\n!(addr_is_blank(&con->actual_peer_addr.in_addr) &&\r\ncon->actual_peer_addr.nonce == con->peer_addr.nonce)) {\r\npr_warning("wrong peer, want %s/%d, got %s/%d\n",\r\nceph_pr_addr(&con->peer_addr.in_addr),\r\n(int)le32_to_cpu(con->peer_addr.nonce),\r\nceph_pr_addr(&con->actual_peer_addr.in_addr),\r\n(int)le32_to_cpu(con->actual_peer_addr.nonce));\r\ncon->error_msg = "wrong peer at address";\r\nreturn -1;\r\n}\r\nif (addr_is_blank(&con->msgr->inst.addr.in_addr)) {\r\nint port = addr_port(&con->msgr->inst.addr.in_addr);\r\nmemcpy(&con->msgr->inst.addr.in_addr,\r\n&con->peer_addr_for_me.in_addr,\r\nsizeof(con->peer_addr_for_me.in_addr));\r\naddr_set_port(&con->msgr->inst.addr.in_addr, port);\r\nencode_my_addr(con->msgr);\r\ndout("process_banner learned my addr is %s\n",\r\nceph_pr_addr(&con->msgr->inst.addr.in_addr));\r\n}\r\nset_bit(NEGOTIATING, &con->state);\r\nprepare_read_connect(con);\r\nreturn 0;\r\n}\r\nstatic void fail_protocol(struct ceph_connection *con)\r\n{\r\nreset_connection(con);\r\nset_bit(CLOSED, &con->state);\r\nmutex_unlock(&con->mutex);\r\nif (con->ops->bad_proto)\r\ncon->ops->bad_proto(con);\r\nmutex_lock(&con->mutex);\r\n}\r\nstatic int process_connect(struct ceph_connection *con)\r\n{\r\nu64 sup_feat = con->msgr->supported_features;\r\nu64 req_feat = con->msgr->required_features;\r\nu64 server_feat = le64_to_cpu(con->in_reply.features);\r\nint ret;\r\ndout("process_connect on %p tag %d\n", con, (int)con->in_tag);\r\nswitch (con->in_reply.tag) {\r\ncase CEPH_MSGR_TAG_FEATURES:\r\npr_err("%s%lld %s feature set mismatch,"\r\n" my %llx < server's %llx, missing %llx\n",\r\nENTITY_NAME(con->peer_name),\r\nceph_pr_addr(&con->peer_addr.in_addr),\r\nsup_feat, server_feat, server_feat & ~sup_feat);\r\ncon->error_msg = "missing required protocol features";\r\nfail_protocol(con);\r\nreturn -1;\r\ncase CEPH_MSGR_TAG_BADPROTOVER:\r\npr_err("%s%lld %s protocol version mismatch,"\r\n" my %d != server's %d\n",\r\nENTITY_NAME(con->peer_name),\r\nceph_pr_addr(&con->peer_addr.in_addr),\r\nle32_to_cpu(con->out_connect.protocol_version),\r\nle32_to_cpu(con->in_reply.protocol_version));\r\ncon->error_msg = "protocol version mismatch";\r\nfail_protocol(con);\r\nreturn -1;\r\ncase CEPH_MSGR_TAG_BADAUTHORIZER:\r\ncon->auth_retry++;\r\ndout("process_connect %p got BADAUTHORIZER attempt %d\n", con,\r\ncon->auth_retry);\r\nif (con->auth_retry == 2) {\r\ncon->error_msg = "connect authorization failure";\r\nreturn -1;\r\n}\r\ncon->auth_retry = 1;\r\nret = prepare_write_connect(con->msgr, con, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nprepare_read_connect(con);\r\nbreak;\r\ncase CEPH_MSGR_TAG_RESETSESSION:\r\ndout("process_connect got RESET peer seq %u\n",\r\nle32_to_cpu(con->in_connect.connect_seq));\r\npr_err("%s%lld %s connection reset\n",\r\nENTITY_NAME(con->peer_name),\r\nceph_pr_addr(&con->peer_addr.in_addr));\r\nreset_connection(con);\r\nprepare_write_connect(con->msgr, con, 0);\r\nprepare_read_connect(con);\r\nmutex_unlock(&con->mutex);\r\npr_info("reset on %s%lld\n", ENTITY_NAME(con->peer_name));\r\nif (con->ops->peer_reset)\r\ncon->ops->peer_reset(con);\r\nmutex_lock(&con->mutex);\r\nif (test_bit(CLOSED, &con->state) ||\r\ntest_bit(OPENING, &con->state))\r\nreturn -EAGAIN;\r\nbreak;\r\ncase CEPH_MSGR_TAG_RETRY_SESSION:\r\ndout("process_connect got RETRY my seq = %u, peer_seq = %u\n",\r\nle32_to_cpu(con->out_connect.connect_seq),\r\nle32_to_cpu(con->in_connect.connect_seq));\r\ncon->connect_seq = le32_to_cpu(con->in_connect.connect_seq);\r\nprepare_write_connect(con->msgr, con, 0);\r\nprepare_read_connect(con);\r\nbreak;\r\ncase CEPH_MSGR_TAG_RETRY_GLOBAL:\r\ndout("process_connect got RETRY_GLOBAL my %u peer_gseq %u\n",\r\ncon->peer_global_seq,\r\nle32_to_cpu(con->in_connect.global_seq));\r\nget_global_seq(con->msgr,\r\nle32_to_cpu(con->in_connect.global_seq));\r\nprepare_write_connect(con->msgr, con, 0);\r\nprepare_read_connect(con);\r\nbreak;\r\ncase CEPH_MSGR_TAG_READY:\r\nif (req_feat & ~server_feat) {\r\npr_err("%s%lld %s protocol feature mismatch,"\r\n" my required %llx > server's %llx, need %llx\n",\r\nENTITY_NAME(con->peer_name),\r\nceph_pr_addr(&con->peer_addr.in_addr),\r\nreq_feat, server_feat, req_feat & ~server_feat);\r\ncon->error_msg = "missing required protocol features";\r\nfail_protocol(con);\r\nreturn -1;\r\n}\r\nclear_bit(CONNECTING, &con->state);\r\ncon->peer_global_seq = le32_to_cpu(con->in_reply.global_seq);\r\ncon->connect_seq++;\r\ncon->peer_features = server_feat;\r\ndout("process_connect got READY gseq %d cseq %d (%d)\n",\r\ncon->peer_global_seq,\r\nle32_to_cpu(con->in_reply.connect_seq),\r\ncon->connect_seq);\r\nWARN_ON(con->connect_seq !=\r\nle32_to_cpu(con->in_reply.connect_seq));\r\nif (con->in_reply.flags & CEPH_MSG_CONNECT_LOSSY)\r\nset_bit(LOSSYTX, &con->state);\r\nprepare_read_tag(con);\r\nbreak;\r\ncase CEPH_MSGR_TAG_WAIT:\r\npr_err("process_connect got WAIT as client\n");\r\ncon->error_msg = "protocol error, got WAIT as client";\r\nreturn -1;\r\ndefault:\r\npr_err("connect protocol error, will retry\n");\r\ncon->error_msg = "protocol error, garbage tag during connect";\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_partial_ack(struct ceph_connection *con)\r\n{\r\nint to = 0;\r\nreturn read_partial(con, &to, sizeof(con->in_temp_ack),\r\n&con->in_temp_ack);\r\n}\r\nstatic void process_ack(struct ceph_connection *con)\r\n{\r\nstruct ceph_msg *m;\r\nu64 ack = le64_to_cpu(con->in_temp_ack);\r\nu64 seq;\r\nwhile (!list_empty(&con->out_sent)) {\r\nm = list_first_entry(&con->out_sent, struct ceph_msg,\r\nlist_head);\r\nseq = le64_to_cpu(m->hdr.seq);\r\nif (seq > ack)\r\nbreak;\r\ndout("got ack for seq %llu type %d at %p\n", seq,\r\nle16_to_cpu(m->hdr.type), m);\r\nm->ack_stamp = jiffies;\r\nceph_msg_remove(m);\r\n}\r\nprepare_read_tag(con);\r\n}\r\nstatic int read_partial_message_section(struct ceph_connection *con,\r\nstruct kvec *section,\r\nunsigned int sec_len, u32 *crc)\r\n{\r\nint ret, left;\r\nBUG_ON(!section);\r\nwhile (section->iov_len < sec_len) {\r\nBUG_ON(section->iov_base == NULL);\r\nleft = sec_len - section->iov_len;\r\nret = ceph_tcp_recvmsg(con->sock, (char *)section->iov_base +\r\nsection->iov_len, left);\r\nif (ret <= 0)\r\nreturn ret;\r\nsection->iov_len += ret;\r\nif (section->iov_len == sec_len)\r\n*crc = crc32c(0, section->iov_base,\r\nsection->iov_len);\r\n}\r\nreturn 1;\r\n}\r\nstatic int read_partial_message_pages(struct ceph_connection *con,\r\nstruct page **pages,\r\nunsigned data_len, int datacrc)\r\n{\r\nvoid *p;\r\nint ret;\r\nint left;\r\nleft = min((int)(data_len - con->in_msg_pos.data_pos),\r\n(int)(PAGE_SIZE - con->in_msg_pos.page_pos));\r\nBUG_ON(pages == NULL);\r\np = kmap(pages[con->in_msg_pos.page]);\r\nret = ceph_tcp_recvmsg(con->sock, p + con->in_msg_pos.page_pos,\r\nleft);\r\nif (ret > 0 && datacrc)\r\ncon->in_data_crc =\r\ncrc32c(con->in_data_crc,\r\np + con->in_msg_pos.page_pos, ret);\r\nkunmap(pages[con->in_msg_pos.page]);\r\nif (ret <= 0)\r\nreturn ret;\r\ncon->in_msg_pos.data_pos += ret;\r\ncon->in_msg_pos.page_pos += ret;\r\nif (con->in_msg_pos.page_pos == PAGE_SIZE) {\r\ncon->in_msg_pos.page_pos = 0;\r\ncon->in_msg_pos.page++;\r\n}\r\nreturn ret;\r\n}\r\nstatic int read_partial_message_bio(struct ceph_connection *con,\r\nstruct bio **bio_iter, int *bio_seg,\r\nunsigned data_len, int datacrc)\r\n{\r\nstruct bio_vec *bv = bio_iovec_idx(*bio_iter, *bio_seg);\r\nvoid *p;\r\nint ret, left;\r\nif (IS_ERR(bv))\r\nreturn PTR_ERR(bv);\r\nleft = min((int)(data_len - con->in_msg_pos.data_pos),\r\n(int)(bv->bv_len - con->in_msg_pos.page_pos));\r\np = kmap(bv->bv_page) + bv->bv_offset;\r\nret = ceph_tcp_recvmsg(con->sock, p + con->in_msg_pos.page_pos,\r\nleft);\r\nif (ret > 0 && datacrc)\r\ncon->in_data_crc =\r\ncrc32c(con->in_data_crc,\r\np + con->in_msg_pos.page_pos, ret);\r\nkunmap(bv->bv_page);\r\nif (ret <= 0)\r\nreturn ret;\r\ncon->in_msg_pos.data_pos += ret;\r\ncon->in_msg_pos.page_pos += ret;\r\nif (con->in_msg_pos.page_pos == bv->bv_len) {\r\ncon->in_msg_pos.page_pos = 0;\r\niter_bio_next(bio_iter, bio_seg);\r\n}\r\nreturn ret;\r\n}\r\nstatic int read_partial_message(struct ceph_connection *con)\r\n{\r\nstruct ceph_msg *m = con->in_msg;\r\nint ret;\r\nint to, left;\r\nunsigned front_len, middle_len, data_len;\r\nint datacrc = con->msgr->nocrc;\r\nint skip;\r\nu64 seq;\r\ndout("read_partial_message con %p msg %p\n", con, m);\r\nwhile (con->in_base_pos < sizeof(con->in_hdr)) {\r\nleft = sizeof(con->in_hdr) - con->in_base_pos;\r\nret = ceph_tcp_recvmsg(con->sock,\r\n(char *)&con->in_hdr + con->in_base_pos,\r\nleft);\r\nif (ret <= 0)\r\nreturn ret;\r\ncon->in_base_pos += ret;\r\nif (con->in_base_pos == sizeof(con->in_hdr)) {\r\nu32 crc = crc32c(0, (void *)&con->in_hdr,\r\nsizeof(con->in_hdr) - sizeof(con->in_hdr.crc));\r\nif (crc != le32_to_cpu(con->in_hdr.crc)) {\r\npr_err("read_partial_message bad hdr "\r\n" crc %u != expected %u\n",\r\ncrc, con->in_hdr.crc);\r\nreturn -EBADMSG;\r\n}\r\n}\r\n}\r\nfront_len = le32_to_cpu(con->in_hdr.front_len);\r\nif (front_len > CEPH_MSG_MAX_FRONT_LEN)\r\nreturn -EIO;\r\nmiddle_len = le32_to_cpu(con->in_hdr.middle_len);\r\nif (middle_len > CEPH_MSG_MAX_DATA_LEN)\r\nreturn -EIO;\r\ndata_len = le32_to_cpu(con->in_hdr.data_len);\r\nif (data_len > CEPH_MSG_MAX_DATA_LEN)\r\nreturn -EIO;\r\nseq = le64_to_cpu(con->in_hdr.seq);\r\nif ((s64)seq - (s64)con->in_seq < 1) {\r\npr_info("skipping %s%lld %s seq %lld expected %lld\n",\r\nENTITY_NAME(con->peer_name),\r\nceph_pr_addr(&con->peer_addr.in_addr),\r\nseq, con->in_seq + 1);\r\ncon->in_base_pos = -front_len - middle_len - data_len -\r\nsizeof(m->footer);\r\ncon->in_tag = CEPH_MSGR_TAG_READY;\r\nreturn 0;\r\n} else if ((s64)seq - (s64)con->in_seq > 1) {\r\npr_err("read_partial_message bad seq %lld expected %lld\n",\r\nseq, con->in_seq + 1);\r\ncon->error_msg = "bad message sequence # for incoming message";\r\nreturn -EBADMSG;\r\n}\r\nif (!con->in_msg) {\r\ndout("got hdr type %d front %d data %d\n", con->in_hdr.type,\r\ncon->in_hdr.front_len, con->in_hdr.data_len);\r\nskip = 0;\r\ncon->in_msg = ceph_alloc_msg(con, &con->in_hdr, &skip);\r\nif (skip) {\r\ndout("alloc_msg said skip message\n");\r\nBUG_ON(con->in_msg);\r\ncon->in_base_pos = -front_len - middle_len - data_len -\r\nsizeof(m->footer);\r\ncon->in_tag = CEPH_MSGR_TAG_READY;\r\ncon->in_seq++;\r\nreturn 0;\r\n}\r\nif (!con->in_msg) {\r\ncon->error_msg =\r\n"error allocating memory for incoming message";\r\nreturn -ENOMEM;\r\n}\r\nm = con->in_msg;\r\nm->front.iov_len = 0;\r\nif (m->middle)\r\nm->middle->vec.iov_len = 0;\r\ncon->in_msg_pos.page = 0;\r\nif (m->pages)\r\ncon->in_msg_pos.page_pos = m->page_alignment;\r\nelse\r\ncon->in_msg_pos.page_pos = 0;\r\ncon->in_msg_pos.data_pos = 0;\r\n}\r\nret = read_partial_message_section(con, &m->front, front_len,\r\n&con->in_front_crc);\r\nif (ret <= 0)\r\nreturn ret;\r\nif (m->middle) {\r\nret = read_partial_message_section(con, &m->middle->vec,\r\nmiddle_len,\r\n&con->in_middle_crc);\r\nif (ret <= 0)\r\nreturn ret;\r\n}\r\n#ifdef CONFIG_BLOCK\r\nif (m->bio && !m->bio_iter)\r\ninit_bio_iter(m->bio, &m->bio_iter, &m->bio_seg);\r\n#endif\r\nwhile (con->in_msg_pos.data_pos < data_len) {\r\nif (m->pages) {\r\nret = read_partial_message_pages(con, m->pages,\r\ndata_len, datacrc);\r\nif (ret <= 0)\r\nreturn ret;\r\n#ifdef CONFIG_BLOCK\r\n} else if (m->bio) {\r\nret = read_partial_message_bio(con,\r\n&m->bio_iter, &m->bio_seg,\r\ndata_len, datacrc);\r\nif (ret <= 0)\r\nreturn ret;\r\n#endif\r\n} else {\r\nBUG_ON(1);\r\n}\r\n}\r\nto = sizeof(m->hdr) + sizeof(m->footer);\r\nwhile (con->in_base_pos < to) {\r\nleft = to - con->in_base_pos;\r\nret = ceph_tcp_recvmsg(con->sock, (char *)&m->footer +\r\n(con->in_base_pos - sizeof(m->hdr)),\r\nleft);\r\nif (ret <= 0)\r\nreturn ret;\r\ncon->in_base_pos += ret;\r\n}\r\ndout("read_partial_message got msg %p %d (%u) + %d (%u) + %d (%u)\n",\r\nm, front_len, m->footer.front_crc, middle_len,\r\nm->footer.middle_crc, data_len, m->footer.data_crc);\r\nif (con->in_front_crc != le32_to_cpu(m->footer.front_crc)) {\r\npr_err("read_partial_message %p front crc %u != exp. %u\n",\r\nm, con->in_front_crc, m->footer.front_crc);\r\nreturn -EBADMSG;\r\n}\r\nif (con->in_middle_crc != le32_to_cpu(m->footer.middle_crc)) {\r\npr_err("read_partial_message %p middle crc %u != exp %u\n",\r\nm, con->in_middle_crc, m->footer.middle_crc);\r\nreturn -EBADMSG;\r\n}\r\nif (datacrc &&\r\n(m->footer.flags & CEPH_MSG_FOOTER_NOCRC) == 0 &&\r\ncon->in_data_crc != le32_to_cpu(m->footer.data_crc)) {\r\npr_err("read_partial_message %p data crc %u != exp. %u\n", m,\r\ncon->in_data_crc, le32_to_cpu(m->footer.data_crc));\r\nreturn -EBADMSG;\r\n}\r\nreturn 1;\r\n}\r\nstatic void process_message(struct ceph_connection *con)\r\n{\r\nstruct ceph_msg *msg;\r\nmsg = con->in_msg;\r\ncon->in_msg = NULL;\r\nif (con->peer_name.type == 0)\r\ncon->peer_name = msg->hdr.src;\r\ncon->in_seq++;\r\nmutex_unlock(&con->mutex);\r\ndout("===== %p %llu from %s%lld %d=%s len %d+%d (%u %u %u) =====\n",\r\nmsg, le64_to_cpu(msg->hdr.seq),\r\nENTITY_NAME(msg->hdr.src),\r\nle16_to_cpu(msg->hdr.type),\r\nceph_msg_type_name(le16_to_cpu(msg->hdr.type)),\r\nle32_to_cpu(msg->hdr.front_len),\r\nle32_to_cpu(msg->hdr.data_len),\r\ncon->in_front_crc, con->in_middle_crc, con->in_data_crc);\r\ncon->ops->dispatch(con, msg);\r\nmutex_lock(&con->mutex);\r\nprepare_read_tag(con);\r\n}\r\nstatic int try_write(struct ceph_connection *con)\r\n{\r\nstruct ceph_messenger *msgr = con->msgr;\r\nint ret = 1;\r\ndout("try_write start %p state %lu nref %d\n", con, con->state,\r\natomic_read(&con->nref));\r\nmore:\r\ndout("try_write out_kvec_bytes %d\n", con->out_kvec_bytes);\r\nif (con->sock == NULL) {\r\nprepare_write_banner(msgr, con);\r\nprepare_write_connect(msgr, con, 1);\r\nprepare_read_banner(con);\r\nset_bit(CONNECTING, &con->state);\r\nclear_bit(NEGOTIATING, &con->state);\r\nBUG_ON(con->in_msg);\r\ncon->in_tag = CEPH_MSGR_TAG_READY;\r\ndout("try_write initiating connect on %p new state %lu\n",\r\ncon, con->state);\r\ncon->sock = ceph_tcp_connect(con);\r\nif (IS_ERR(con->sock)) {\r\ncon->sock = NULL;\r\ncon->error_msg = "connect error";\r\nret = -1;\r\ngoto out;\r\n}\r\n}\r\nmore_kvec:\r\nif (con->out_skip) {\r\nret = write_partial_skip(con);\r\nif (ret <= 0)\r\ngoto out;\r\n}\r\nif (con->out_kvec_left) {\r\nret = write_partial_kvec(con);\r\nif (ret <= 0)\r\ngoto out;\r\n}\r\nif (con->out_msg) {\r\nif (con->out_msg_done) {\r\nceph_msg_put(con->out_msg);\r\ncon->out_msg = NULL;\r\ngoto do_next;\r\n}\r\nret = write_partial_msg_pages(con);\r\nif (ret == 1)\r\ngoto more_kvec;\r\nif (ret == 0)\r\ngoto out;\r\nif (ret < 0) {\r\ndout("try_write write_partial_msg_pages err %d\n",\r\nret);\r\ngoto out;\r\n}\r\n}\r\ndo_next:\r\nif (!test_bit(CONNECTING, &con->state)) {\r\nif (!list_empty(&con->out_queue)) {\r\nprepare_write_message(con);\r\ngoto more;\r\n}\r\nif (con->in_seq > con->in_seq_acked) {\r\nprepare_write_ack(con);\r\ngoto more;\r\n}\r\nif (test_and_clear_bit(KEEPALIVE_PENDING, &con->state)) {\r\nprepare_write_keepalive(con);\r\ngoto more;\r\n}\r\n}\r\nclear_bit(WRITE_PENDING, &con->state);\r\ndout("try_write nothing else to write.\n");\r\nret = 0;\r\nout:\r\ndout("try_write done on %p ret %d\n", con, ret);\r\nreturn ret;\r\n}\r\nstatic int try_read(struct ceph_connection *con)\r\n{\r\nint ret = -1;\r\nif (!con->sock)\r\nreturn 0;\r\nif (test_bit(STANDBY, &con->state))\r\nreturn 0;\r\ndout("try_read start on %p\n", con);\r\nmore:\r\ndout("try_read tag %d in_base_pos %d\n", (int)con->in_tag,\r\ncon->in_base_pos);\r\nif (test_bit(CLOSED, &con->state) ||\r\ntest_bit(OPENING, &con->state)) {\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nif (test_bit(CONNECTING, &con->state)) {\r\nif (!test_bit(NEGOTIATING, &con->state)) {\r\ndout("try_read connecting\n");\r\nret = read_partial_banner(con);\r\nif (ret <= 0)\r\ngoto out;\r\nret = process_banner(con);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nret = read_partial_connect(con);\r\nif (ret <= 0)\r\ngoto out;\r\nret = process_connect(con);\r\nif (ret < 0)\r\ngoto out;\r\ngoto more;\r\n}\r\nif (con->in_base_pos < 0) {\r\nstatic char buf[1024];\r\nint skip = min(1024, -con->in_base_pos);\r\ndout("skipping %d / %d bytes\n", skip, -con->in_base_pos);\r\nret = ceph_tcp_recvmsg(con->sock, buf, skip);\r\nif (ret <= 0)\r\ngoto out;\r\ncon->in_base_pos += ret;\r\nif (con->in_base_pos)\r\ngoto more;\r\n}\r\nif (con->in_tag == CEPH_MSGR_TAG_READY) {\r\nret = ceph_tcp_recvmsg(con->sock, &con->in_tag, 1);\r\nif (ret <= 0)\r\ngoto out;\r\ndout("try_read got tag %d\n", (int)con->in_tag);\r\nswitch (con->in_tag) {\r\ncase CEPH_MSGR_TAG_MSG:\r\nprepare_read_message(con);\r\nbreak;\r\ncase CEPH_MSGR_TAG_ACK:\r\nprepare_read_ack(con);\r\nbreak;\r\ncase CEPH_MSGR_TAG_CLOSE:\r\nset_bit(CLOSED, &con->state);\r\ngoto out;\r\ndefault:\r\ngoto bad_tag;\r\n}\r\n}\r\nif (con->in_tag == CEPH_MSGR_TAG_MSG) {\r\nret = read_partial_message(con);\r\nif (ret <= 0) {\r\nswitch (ret) {\r\ncase -EBADMSG:\r\ncon->error_msg = "bad crc";\r\nret = -EIO;\r\nbreak;\r\ncase -EIO:\r\ncon->error_msg = "io error";\r\nbreak;\r\n}\r\ngoto out;\r\n}\r\nif (con->in_tag == CEPH_MSGR_TAG_READY)\r\ngoto more;\r\nprocess_message(con);\r\ngoto more;\r\n}\r\nif (con->in_tag == CEPH_MSGR_TAG_ACK) {\r\nret = read_partial_ack(con);\r\nif (ret <= 0)\r\ngoto out;\r\nprocess_ack(con);\r\ngoto more;\r\n}\r\nout:\r\ndout("try_read done on %p ret %d\n", con, ret);\r\nreturn ret;\r\nbad_tag:\r\npr_err("try_read bad con->in_tag = %d\n", (int)con->in_tag);\r\ncon->error_msg = "protocol error, garbage tag";\r\nret = -1;\r\ngoto out;\r\n}\r\nstatic void queue_con(struct ceph_connection *con)\r\n{\r\nif (test_bit(DEAD, &con->state)) {\r\ndout("queue_con %p ignoring: DEAD\n",\r\ncon);\r\nreturn;\r\n}\r\nif (!con->ops->get(con)) {\r\ndout("queue_con %p ref count 0\n", con);\r\nreturn;\r\n}\r\nif (!queue_delayed_work(ceph_msgr_wq, &con->work, 0)) {\r\ndout("queue_con %p - already queued\n", con);\r\ncon->ops->put(con);\r\n} else {\r\ndout("queue_con %p\n", con);\r\n}\r\n}\r\nstatic void con_work(struct work_struct *work)\r\n{\r\nstruct ceph_connection *con = container_of(work, struct ceph_connection,\r\nwork.work);\r\nint ret;\r\nmutex_lock(&con->mutex);\r\nrestart:\r\nif (test_and_clear_bit(BACKOFF, &con->state)) {\r\ndout("con_work %p backing off\n", con);\r\nif (queue_delayed_work(ceph_msgr_wq, &con->work,\r\nround_jiffies_relative(con->delay))) {\r\ndout("con_work %p backoff %lu\n", con, con->delay);\r\nmutex_unlock(&con->mutex);\r\nreturn;\r\n} else {\r\ncon->ops->put(con);\r\ndout("con_work %p FAILED to back off %lu\n", con,\r\ncon->delay);\r\n}\r\n}\r\nif (test_bit(STANDBY, &con->state)) {\r\ndout("con_work %p STANDBY\n", con);\r\ngoto done;\r\n}\r\nif (test_bit(CLOSED, &con->state)) {\r\ndout("con_work CLOSED\n");\r\ncon_close_socket(con);\r\ngoto done;\r\n}\r\nif (test_and_clear_bit(OPENING, &con->state)) {\r\ndout("con_work OPENING\n");\r\ncon_close_socket(con);\r\n}\r\nif (test_and_clear_bit(SOCK_CLOSED, &con->state))\r\ngoto fault;\r\nret = try_read(con);\r\nif (ret == -EAGAIN)\r\ngoto restart;\r\nif (ret < 0)\r\ngoto fault;\r\nret = try_write(con);\r\nif (ret == -EAGAIN)\r\ngoto restart;\r\nif (ret < 0)\r\ngoto fault;\r\ndone:\r\nmutex_unlock(&con->mutex);\r\ndone_unlocked:\r\ncon->ops->put(con);\r\nreturn;\r\nfault:\r\nmutex_unlock(&con->mutex);\r\nceph_fault(con);\r\ngoto done_unlocked;\r\n}\r\nstatic void ceph_fault(struct ceph_connection *con)\r\n{\r\npr_err("%s%lld %s %s\n", ENTITY_NAME(con->peer_name),\r\nceph_pr_addr(&con->peer_addr.in_addr), con->error_msg);\r\ndout("fault %p state %lu to peer %s\n",\r\ncon, con->state, ceph_pr_addr(&con->peer_addr.in_addr));\r\nif (test_bit(LOSSYTX, &con->state)) {\r\ndout("fault on LOSSYTX channel\n");\r\ngoto out;\r\n}\r\nmutex_lock(&con->mutex);\r\nif (test_bit(CLOSED, &con->state))\r\ngoto out_unlock;\r\ncon_close_socket(con);\r\nif (con->in_msg) {\r\nceph_msg_put(con->in_msg);\r\ncon->in_msg = NULL;\r\n}\r\nlist_splice_init(&con->out_sent, &con->out_queue);\r\nif (list_empty(&con->out_queue) &&\r\n!test_bit(KEEPALIVE_PENDING, &con->state)) {\r\ndout("fault %p setting STANDBY clearing WRITE_PENDING\n", con);\r\nclear_bit(WRITE_PENDING, &con->state);\r\nset_bit(STANDBY, &con->state);\r\n} else {\r\nif (con->delay == 0)\r\ncon->delay = BASE_DELAY_INTERVAL;\r\nelse if (con->delay < MAX_DELAY_INTERVAL)\r\ncon->delay *= 2;\r\ncon->ops->get(con);\r\nif (queue_delayed_work(ceph_msgr_wq, &con->work,\r\nround_jiffies_relative(con->delay))) {\r\ndout("fault queued %p delay %lu\n", con, con->delay);\r\n} else {\r\ncon->ops->put(con);\r\ndout("fault failed to queue %p delay %lu, backoff\n",\r\ncon, con->delay);\r\nset_bit(BACKOFF, &con->state);\r\n}\r\n}\r\nout_unlock:\r\nmutex_unlock(&con->mutex);\r\nout:\r\nif (con->auth_retry && con->ops->invalidate_authorizer) {\r\ndout("calling invalidate_authorizer()\n");\r\ncon->ops->invalidate_authorizer(con);\r\n}\r\nif (con->ops->fault)\r\ncon->ops->fault(con);\r\n}\r\nstruct ceph_messenger *ceph_messenger_create(struct ceph_entity_addr *myaddr,\r\nu32 supported_features,\r\nu32 required_features)\r\n{\r\nstruct ceph_messenger *msgr;\r\nmsgr = kzalloc(sizeof(*msgr), GFP_KERNEL);\r\nif (msgr == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nmsgr->supported_features = supported_features;\r\nmsgr->required_features = required_features;\r\nspin_lock_init(&msgr->global_seq_lock);\r\nmsgr->zero_page = __page_cache_alloc(GFP_KERNEL | __GFP_ZERO);\r\nif (!msgr->zero_page) {\r\nkfree(msgr);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nkmap(msgr->zero_page);\r\nif (myaddr)\r\nmsgr->inst.addr = *myaddr;\r\nmsgr->inst.addr.type = 0;\r\nget_random_bytes(&msgr->inst.addr.nonce, sizeof(msgr->inst.addr.nonce));\r\nencode_my_addr(msgr);\r\ndout("messenger_create %p\n", msgr);\r\nreturn msgr;\r\n}\r\nvoid ceph_messenger_destroy(struct ceph_messenger *msgr)\r\n{\r\ndout("destroy %p\n", msgr);\r\nkunmap(msgr->zero_page);\r\n__free_page(msgr->zero_page);\r\nkfree(msgr);\r\ndout("destroyed messenger %p\n", msgr);\r\n}\r\nstatic void clear_standby(struct ceph_connection *con)\r\n{\r\nif (test_and_clear_bit(STANDBY, &con->state)) {\r\nmutex_lock(&con->mutex);\r\ndout("clear_standby %p and ++connect_seq\n", con);\r\ncon->connect_seq++;\r\nWARN_ON(test_bit(WRITE_PENDING, &con->state));\r\nWARN_ON(test_bit(KEEPALIVE_PENDING, &con->state));\r\nmutex_unlock(&con->mutex);\r\n}\r\n}\r\nvoid ceph_con_send(struct ceph_connection *con, struct ceph_msg *msg)\r\n{\r\nif (test_bit(CLOSED, &con->state)) {\r\ndout("con_send %p closed, dropping %p\n", con, msg);\r\nceph_msg_put(msg);\r\nreturn;\r\n}\r\nmsg->hdr.src = con->msgr->inst.name;\r\nBUG_ON(msg->front.iov_len != le32_to_cpu(msg->hdr.front_len));\r\nmsg->needs_out_seq = true;\r\nmutex_lock(&con->mutex);\r\nBUG_ON(!list_empty(&msg->list_head));\r\nlist_add_tail(&msg->list_head, &con->out_queue);\r\ndout("----- %p to %s%lld %d=%s len %d+%d+%d -----\n", msg,\r\nENTITY_NAME(con->peer_name), le16_to_cpu(msg->hdr.type),\r\nceph_msg_type_name(le16_to_cpu(msg->hdr.type)),\r\nle32_to_cpu(msg->hdr.front_len),\r\nle32_to_cpu(msg->hdr.middle_len),\r\nle32_to_cpu(msg->hdr.data_len));\r\nmutex_unlock(&con->mutex);\r\nclear_standby(con);\r\nif (test_and_set_bit(WRITE_PENDING, &con->state) == 0)\r\nqueue_con(con);\r\n}\r\nvoid ceph_con_revoke(struct ceph_connection *con, struct ceph_msg *msg)\r\n{\r\nmutex_lock(&con->mutex);\r\nif (!list_empty(&msg->list_head)) {\r\ndout("con_revoke %p msg %p - was on queue\n", con, msg);\r\nlist_del_init(&msg->list_head);\r\nceph_msg_put(msg);\r\nmsg->hdr.seq = 0;\r\n}\r\nif (con->out_msg == msg) {\r\ndout("con_revoke %p msg %p - was sending\n", con, msg);\r\ncon->out_msg = NULL;\r\nif (con->out_kvec_is_msg) {\r\ncon->out_skip = con->out_kvec_bytes;\r\ncon->out_kvec_is_msg = false;\r\n}\r\nceph_msg_put(msg);\r\nmsg->hdr.seq = 0;\r\n}\r\nmutex_unlock(&con->mutex);\r\n}\r\nvoid ceph_con_revoke_message(struct ceph_connection *con, struct ceph_msg *msg)\r\n{\r\nmutex_lock(&con->mutex);\r\nif (con->in_msg && con->in_msg == msg) {\r\nunsigned front_len = le32_to_cpu(con->in_hdr.front_len);\r\nunsigned middle_len = le32_to_cpu(con->in_hdr.middle_len);\r\nunsigned data_len = le32_to_cpu(con->in_hdr.data_len);\r\ndout("con_revoke_pages %p msg %p revoked\n", con, msg);\r\ncon->in_base_pos = con->in_base_pos -\r\nsizeof(struct ceph_msg_header) -\r\nfront_len -\r\nmiddle_len -\r\ndata_len -\r\nsizeof(struct ceph_msg_footer);\r\nceph_msg_put(con->in_msg);\r\ncon->in_msg = NULL;\r\ncon->in_tag = CEPH_MSGR_TAG_READY;\r\ncon->in_seq++;\r\n} else {\r\ndout("con_revoke_pages %p msg %p pages %p no-op\n",\r\ncon, con->in_msg, msg);\r\n}\r\nmutex_unlock(&con->mutex);\r\n}\r\nvoid ceph_con_keepalive(struct ceph_connection *con)\r\n{\r\ndout("con_keepalive %p\n", con);\r\nclear_standby(con);\r\nif (test_and_set_bit(KEEPALIVE_PENDING, &con->state) == 0 &&\r\ntest_and_set_bit(WRITE_PENDING, &con->state) == 0)\r\nqueue_con(con);\r\n}\r\nstruct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags,\r\nbool can_fail)\r\n{\r\nstruct ceph_msg *m;\r\nm = kmalloc(sizeof(*m), flags);\r\nif (m == NULL)\r\ngoto out;\r\nkref_init(&m->kref);\r\nINIT_LIST_HEAD(&m->list_head);\r\nm->hdr.tid = 0;\r\nm->hdr.type = cpu_to_le16(type);\r\nm->hdr.priority = cpu_to_le16(CEPH_MSG_PRIO_DEFAULT);\r\nm->hdr.version = 0;\r\nm->hdr.front_len = cpu_to_le32(front_len);\r\nm->hdr.middle_len = 0;\r\nm->hdr.data_len = 0;\r\nm->hdr.data_off = 0;\r\nm->hdr.reserved = 0;\r\nm->footer.front_crc = 0;\r\nm->footer.middle_crc = 0;\r\nm->footer.data_crc = 0;\r\nm->footer.flags = 0;\r\nm->front_max = front_len;\r\nm->front_is_vmalloc = false;\r\nm->more_to_follow = false;\r\nm->ack_stamp = 0;\r\nm->pool = NULL;\r\nm->middle = NULL;\r\nm->nr_pages = 0;\r\nm->page_alignment = 0;\r\nm->pages = NULL;\r\nm->pagelist = NULL;\r\nm->bio = NULL;\r\nm->bio_iter = NULL;\r\nm->bio_seg = 0;\r\nm->trail = NULL;\r\nif (front_len) {\r\nif (front_len > PAGE_CACHE_SIZE) {\r\nm->front.iov_base = __vmalloc(front_len, flags,\r\nPAGE_KERNEL);\r\nm->front_is_vmalloc = true;\r\n} else {\r\nm->front.iov_base = kmalloc(front_len, flags);\r\n}\r\nif (m->front.iov_base == NULL) {\r\ndout("ceph_msg_new can't allocate %d bytes\n",\r\nfront_len);\r\ngoto out2;\r\n}\r\n} else {\r\nm->front.iov_base = NULL;\r\n}\r\nm->front.iov_len = front_len;\r\ndout("ceph_msg_new %p front %d\n", m, front_len);\r\nreturn m;\r\nout2:\r\nceph_msg_put(m);\r\nout:\r\nif (!can_fail) {\r\npr_err("msg_new can't create type %d front %d\n", type,\r\nfront_len);\r\nWARN_ON(1);\r\n} else {\r\ndout("msg_new can't create type %d front %d\n", type,\r\nfront_len);\r\n}\r\nreturn NULL;\r\n}\r\nstatic int ceph_alloc_middle(struct ceph_connection *con, struct ceph_msg *msg)\r\n{\r\nint type = le16_to_cpu(msg->hdr.type);\r\nint middle_len = le32_to_cpu(msg->hdr.middle_len);\r\ndout("alloc_middle %p type %d %s middle_len %d\n", msg, type,\r\nceph_msg_type_name(type), middle_len);\r\nBUG_ON(!middle_len);\r\nBUG_ON(msg->middle);\r\nmsg->middle = ceph_buffer_new(middle_len, GFP_NOFS);\r\nif (!msg->middle)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic struct ceph_msg *ceph_alloc_msg(struct ceph_connection *con,\r\nstruct ceph_msg_header *hdr,\r\nint *skip)\r\n{\r\nint type = le16_to_cpu(hdr->type);\r\nint front_len = le32_to_cpu(hdr->front_len);\r\nint middle_len = le32_to_cpu(hdr->middle_len);\r\nstruct ceph_msg *msg = NULL;\r\nint ret;\r\nif (con->ops->alloc_msg) {\r\nmutex_unlock(&con->mutex);\r\nmsg = con->ops->alloc_msg(con, hdr, skip);\r\nmutex_lock(&con->mutex);\r\nif (!msg || *skip)\r\nreturn NULL;\r\n}\r\nif (!msg) {\r\n*skip = 0;\r\nmsg = ceph_msg_new(type, front_len, GFP_NOFS, false);\r\nif (!msg) {\r\npr_err("unable to allocate msg type %d len %d\n",\r\ntype, front_len);\r\nreturn NULL;\r\n}\r\nmsg->page_alignment = le16_to_cpu(hdr->data_off);\r\n}\r\nmemcpy(&msg->hdr, &con->in_hdr, sizeof(con->in_hdr));\r\nif (middle_len && !msg->middle) {\r\nret = ceph_alloc_middle(con, msg);\r\nif (ret < 0) {\r\nceph_msg_put(msg);\r\nreturn NULL;\r\n}\r\n}\r\nreturn msg;\r\n}\r\nvoid ceph_msg_kfree(struct ceph_msg *m)\r\n{\r\ndout("msg_kfree %p\n", m);\r\nif (m->front_is_vmalloc)\r\nvfree(m->front.iov_base);\r\nelse\r\nkfree(m->front.iov_base);\r\nkfree(m);\r\n}\r\nvoid ceph_msg_last_put(struct kref *kref)\r\n{\r\nstruct ceph_msg *m = container_of(kref, struct ceph_msg, kref);\r\ndout("ceph_msg_put last one on %p\n", m);\r\nWARN_ON(!list_empty(&m->list_head));\r\nif (m->middle) {\r\nceph_buffer_put(m->middle);\r\nm->middle = NULL;\r\n}\r\nm->nr_pages = 0;\r\nm->pages = NULL;\r\nif (m->pagelist) {\r\nceph_pagelist_release(m->pagelist);\r\nkfree(m->pagelist);\r\nm->pagelist = NULL;\r\n}\r\nm->trail = NULL;\r\nif (m->pool)\r\nceph_msgpool_put(m->pool, m);\r\nelse\r\nceph_msg_kfree(m);\r\n}\r\nvoid ceph_msg_dump(struct ceph_msg *msg)\r\n{\r\npr_debug("msg_dump %p (front_max %d nr_pages %d)\n", msg,\r\nmsg->front_max, msg->nr_pages);\r\nprint_hex_dump(KERN_DEBUG, "header: ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\n&msg->hdr, sizeof(msg->hdr), true);\r\nprint_hex_dump(KERN_DEBUG, " front: ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\nmsg->front.iov_base, msg->front.iov_len, true);\r\nif (msg->middle)\r\nprint_hex_dump(KERN_DEBUG, "middle: ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\nmsg->middle->vec.iov_base,\r\nmsg->middle->vec.iov_len, true);\r\nprint_hex_dump(KERN_DEBUG, "footer: ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\n&msg->footer, sizeof(msg->footer), true);\r\n}
