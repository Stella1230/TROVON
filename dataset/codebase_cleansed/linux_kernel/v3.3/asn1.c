static void\r\nasn1_open(struct asn1_ctx *ctx, unsigned char *buf, unsigned int len)\r\n{\r\nctx->begin = buf;\r\nctx->end = buf + len;\r\nctx->pointer = buf;\r\nctx->error = ASN1_ERR_NOERROR;\r\n}\r\nstatic unsigned char\r\nasn1_octet_decode(struct asn1_ctx *ctx, unsigned char *ch)\r\n{\r\nif (ctx->pointer >= ctx->end) {\r\nctx->error = ASN1_ERR_DEC_EMPTY;\r\nreturn 0;\r\n}\r\n*ch = *(ctx->pointer)++;\r\nreturn 1;\r\n}\r\nstatic unsigned char\r\nasn1_tag_decode(struct asn1_ctx *ctx, unsigned int *tag)\r\n{\r\nunsigned char ch;\r\n*tag = 0;\r\ndo {\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\n*tag <<= 7;\r\n*tag |= ch & 0x7F;\r\n} while ((ch & 0x80) == 0x80);\r\nreturn 1;\r\n}\r\nstatic unsigned char\r\nasn1_id_decode(struct asn1_ctx *ctx,\r\nunsigned int *cls, unsigned int *con, unsigned int *tag)\r\n{\r\nunsigned char ch;\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\n*cls = (ch & 0xC0) >> 6;\r\n*con = (ch & 0x20) >> 5;\r\n*tag = (ch & 0x1F);\r\nif (*tag == 0x1F) {\r\nif (!asn1_tag_decode(ctx, tag))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned char\r\nasn1_length_decode(struct asn1_ctx *ctx, unsigned int *def, unsigned int *len)\r\n{\r\nunsigned char ch, cnt;\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\nif (ch == 0x80)\r\n*def = 0;\r\nelse {\r\n*def = 1;\r\nif (ch < 0x80)\r\n*len = ch;\r\nelse {\r\ncnt = (unsigned char) (ch & 0x7F);\r\n*len = 0;\r\nwhile (cnt > 0) {\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\n*len <<= 8;\r\n*len |= ch;\r\ncnt--;\r\n}\r\n}\r\n}\r\nif (*len > ctx->end - ctx->pointer)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic unsigned char\r\nasn1_header_decode(struct asn1_ctx *ctx,\r\nunsigned char **eoc,\r\nunsigned int *cls, unsigned int *con, unsigned int *tag)\r\n{\r\nunsigned int def = 0;\r\nunsigned int len = 0;\r\nif (!asn1_id_decode(ctx, cls, con, tag))\r\nreturn 0;\r\nif (!asn1_length_decode(ctx, &def, &len))\r\nreturn 0;\r\nif (*con == ASN1_PRI && !def)\r\nreturn 0;\r\nif (def)\r\n*eoc = ctx->pointer + len;\r\nelse\r\n*eoc = NULL;\r\nreturn 1;\r\n}\r\nstatic unsigned char\r\nasn1_eoc_decode(struct asn1_ctx *ctx, unsigned char *eoc)\r\n{\r\nunsigned char ch;\r\nif (eoc == NULL) {\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\nif (ch != 0x00) {\r\nctx->error = ASN1_ERR_DEC_EOC_MISMATCH;\r\nreturn 0;\r\n}\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\nif (ch != 0x00) {\r\nctx->error = ASN1_ERR_DEC_EOC_MISMATCH;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n} else {\r\nif (ctx->pointer != eoc) {\r\nctx->error = ASN1_ERR_DEC_LENGTH_MISMATCH;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\n}\r\nstatic unsigned char\r\nasn1_subid_decode(struct asn1_ctx *ctx, unsigned long *subid)\r\n{\r\nunsigned char ch;\r\n*subid = 0;\r\ndo {\r\nif (!asn1_octet_decode(ctx, &ch))\r\nreturn 0;\r\n*subid <<= 7;\r\n*subid |= ch & 0x7F;\r\n} while ((ch & 0x80) == 0x80);\r\nreturn 1;\r\n}\r\nstatic int\r\nasn1_oid_decode(struct asn1_ctx *ctx,\r\nunsigned char *eoc, unsigned long **oid, unsigned int *len)\r\n{\r\nunsigned long subid;\r\nunsigned int size;\r\nunsigned long *optr;\r\nsize = eoc - ctx->pointer + 1;\r\nif (size < 2 || size > UINT_MAX/sizeof(unsigned long))\r\nreturn 0;\r\n*oid = kmalloc(size * sizeof(unsigned long), GFP_ATOMIC);\r\nif (*oid == NULL)\r\nreturn 0;\r\noptr = *oid;\r\nif (!asn1_subid_decode(ctx, &subid)) {\r\nkfree(*oid);\r\n*oid = NULL;\r\nreturn 0;\r\n}\r\nif (subid < 40) {\r\noptr[0] = 0;\r\noptr[1] = subid;\r\n} else if (subid < 80) {\r\noptr[0] = 1;\r\noptr[1] = subid - 40;\r\n} else {\r\noptr[0] = 2;\r\noptr[1] = subid - 80;\r\n}\r\n*len = 2;\r\noptr += 2;\r\nwhile (ctx->pointer < eoc) {\r\nif (++(*len) > size) {\r\nctx->error = ASN1_ERR_DEC_BADVALUE;\r\nkfree(*oid);\r\n*oid = NULL;\r\nreturn 0;\r\n}\r\nif (!asn1_subid_decode(ctx, optr++)) {\r\nkfree(*oid);\r\n*oid = NULL;\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\ncompare_oid(unsigned long *oid1, unsigned int oid1len,\r\nunsigned long *oid2, unsigned int oid2len)\r\n{\r\nunsigned int i;\r\nif (oid1len != oid2len)\r\nreturn 0;\r\nelse {\r\nfor (i = 0; i < oid1len; i++) {\r\nif (oid1[i] != oid2[i])\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\n}\r\nint\r\ndecode_negTokenInit(unsigned char *security_blob, int length,\r\nstruct TCP_Server_Info *server)\r\n{\r\nstruct asn1_ctx ctx;\r\nunsigned char *end;\r\nunsigned char *sequence_end;\r\nunsigned long *oid = NULL;\r\nunsigned int cls, con, tag, oidlen, rc;\r\nasn1_open(&ctx, security_blob, length);\r\nif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\r\ncFYI(1, "Error decoding negTokenInit header");\r\nreturn 0;\r\n} else if ((cls != ASN1_APL) || (con != ASN1_CON)\r\n|| (tag != ASN1_EOC)) {\r\ncFYI(1, "cls = %d con = %d tag = %d", cls, con, tag);\r\nreturn 0;\r\n}\r\nrc = asn1_header_decode(&ctx, &end, &cls, &con, &tag);\r\nif (rc) {\r\nif ((tag == ASN1_OJI) && (con == ASN1_PRI) &&\r\n(cls == ASN1_UNI)) {\r\nrc = asn1_oid_decode(&ctx, end, &oid, &oidlen);\r\nif (rc) {\r\nrc = compare_oid(oid, oidlen, SPNEGO_OID,\r\nSPNEGO_OID_LEN);\r\nkfree(oid);\r\n}\r\n} else\r\nrc = 0;\r\n}\r\nif (!rc) {\r\ncFYI(1, "Error decoding negTokenInit header");\r\nreturn 0;\r\n}\r\nif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\r\ncFYI(1, "Error decoding negTokenInit");\r\nreturn 0;\r\n} else if ((cls != ASN1_CTX) || (con != ASN1_CON)\r\n|| (tag != ASN1_EOC)) {\r\ncFYI(1, "cls = %d con = %d tag = %d end = %p (%d) exit 0",\r\ncls, con, tag, end, *end);\r\nreturn 0;\r\n}\r\nif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\r\ncFYI(1, "Error decoding negTokenInit");\r\nreturn 0;\r\n} else if ((cls != ASN1_UNI) || (con != ASN1_CON)\r\n|| (tag != ASN1_SEQ)) {\r\ncFYI(1, "cls = %d con = %d tag = %d end = %p (%d) exit 1",\r\ncls, con, tag, end, *end);\r\nreturn 0;\r\n}\r\nif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\r\ncFYI(1, "Error decoding 2nd part of negTokenInit");\r\nreturn 0;\r\n} else if ((cls != ASN1_CTX) || (con != ASN1_CON)\r\n|| (tag != ASN1_EOC)) {\r\ncFYI(1, "cls = %d con = %d tag = %d end = %p (%d) exit 0",\r\ncls, con, tag, end, *end);\r\nreturn 0;\r\n}\r\nif (asn1_header_decode\r\n(&ctx, &sequence_end, &cls, &con, &tag) == 0) {\r\ncFYI(1, "Error decoding 2nd part of negTokenInit");\r\nreturn 0;\r\n} else if ((cls != ASN1_UNI) || (con != ASN1_CON)\r\n|| (tag != ASN1_SEQ)) {\r\ncFYI(1, "cls = %d con = %d tag = %d end = %p (%d) exit 1",\r\ncls, con, tag, end, *end);\r\nreturn 0;\r\n}\r\nwhile (!asn1_eoc_decode(&ctx, sequence_end)) {\r\nrc = asn1_header_decode(&ctx, &end, &cls, &con, &tag);\r\nif (!rc) {\r\ncFYI(1, "Error decoding negTokenInit hdr exit2");\r\nreturn 0;\r\n}\r\nif ((tag == ASN1_OJI) && (con == ASN1_PRI)) {\r\nif (asn1_oid_decode(&ctx, end, &oid, &oidlen)) {\r\ncFYI(1, "OID len = %d oid = 0x%lx 0x%lx "\r\n"0x%lx 0x%lx", oidlen, *oid,\r\n*(oid + 1), *(oid + 2), *(oid + 3));\r\nif (compare_oid(oid, oidlen, MSKRB5_OID,\r\nMSKRB5_OID_LEN))\r\nserver->sec_mskerberos = true;\r\nelse if (compare_oid(oid, oidlen, KRB5U2U_OID,\r\nKRB5U2U_OID_LEN))\r\nserver->sec_kerberosu2u = true;\r\nelse if (compare_oid(oid, oidlen, KRB5_OID,\r\nKRB5_OID_LEN))\r\nserver->sec_kerberos = true;\r\nelse if (compare_oid(oid, oidlen, NTLMSSP_OID,\r\nNTLMSSP_OID_LEN))\r\nserver->sec_ntlmssp = true;\r\nkfree(oid);\r\n}\r\n} else {\r\ncFYI(1, "Should be an oid what is going on?");\r\n}\r\n}\r\nif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\r\nif (ctx.error == ASN1_ERR_DEC_EMPTY)\r\ngoto decode_negtoken_exit;\r\ncFYI(1, "Error decoding last part negTokenInit exit3");\r\nreturn 0;\r\n} else if ((cls != ASN1_CTX) || (con != ASN1_CON)) {\r\ncFYI(1, "Exit 4 cls = %d con = %d tag = %d end = %p (%d)",\r\ncls, con, tag, end, *end);\r\nreturn 0;\r\n}\r\nif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\r\ncFYI(1, "Error decoding last part negTokenInit exit5");\r\nreturn 0;\r\n} else if ((cls != ASN1_UNI) || (con != ASN1_CON)\r\n|| (tag != ASN1_SEQ)) {\r\ncFYI(1, "cls = %d con = %d tag = %d end = %p (%d)",\r\ncls, con, tag, end, *end);\r\n}\r\nif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\r\ncFYI(1, "Error decoding last part negTokenInit exit 7");\r\nreturn 0;\r\n} else if ((cls != ASN1_CTX) || (con != ASN1_CON)) {\r\ncFYI(1, "Exit 8 cls = %d con = %d tag = %d end = %p (%d)",\r\ncls, con, tag, end, *end);\r\nreturn 0;\r\n}\r\nif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\r\ncFYI(1, "Error decoding last part negTokenInit exit9");\r\nreturn 0;\r\n} else if ((cls != ASN1_UNI) || (con != ASN1_PRI)\r\n|| (tag != ASN1_GENSTR)) {\r\ncFYI(1, "Exit10 cls = %d con = %d tag = %d end = %p (%d)",\r\ncls, con, tag, end, *end);\r\nreturn 0;\r\n}\r\ncFYI(1, "Need to call asn1_octets_decode() function for %s",\r\nctx.pointer);\r\ndecode_negtoken_exit:\r\nreturn 1;\r\n}
