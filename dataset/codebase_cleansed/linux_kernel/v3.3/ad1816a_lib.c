static inline int snd_ad1816a_busy_wait(struct snd_ad1816a *chip)\r\n{\r\nint timeout;\r\nfor (timeout = 1000; timeout-- > 0; udelay(10))\r\nif (inb(AD1816A_REG(AD1816A_CHIP_STATUS)) & AD1816A_READY)\r\nreturn 0;\r\nsnd_printk(KERN_WARNING "chip busy.\n");\r\nreturn -EBUSY;\r\n}\r\nstatic inline unsigned char snd_ad1816a_in(struct snd_ad1816a *chip, unsigned char reg)\r\n{\r\nsnd_ad1816a_busy_wait(chip);\r\nreturn inb(AD1816A_REG(reg));\r\n}\r\nstatic inline void snd_ad1816a_out(struct snd_ad1816a *chip, unsigned char reg,\r\nunsigned char value)\r\n{\r\nsnd_ad1816a_busy_wait(chip);\r\noutb(value, AD1816A_REG(reg));\r\n}\r\nstatic inline void snd_ad1816a_out_mask(struct snd_ad1816a *chip, unsigned char reg,\r\nunsigned char mask, unsigned char value)\r\n{\r\nsnd_ad1816a_out(chip, reg,\r\n(value & mask) | (snd_ad1816a_in(chip, reg) & ~mask));\r\n}\r\nstatic unsigned short snd_ad1816a_read(struct snd_ad1816a *chip, unsigned char reg)\r\n{\r\nsnd_ad1816a_out(chip, AD1816A_INDIR_ADDR, reg & 0x3f);\r\nreturn snd_ad1816a_in(chip, AD1816A_INDIR_DATA_LOW) |\r\n(snd_ad1816a_in(chip, AD1816A_INDIR_DATA_HIGH) << 8);\r\n}\r\nstatic void snd_ad1816a_write(struct snd_ad1816a *chip, unsigned char reg,\r\nunsigned short value)\r\n{\r\nsnd_ad1816a_out(chip, AD1816A_INDIR_ADDR, reg & 0x3f);\r\nsnd_ad1816a_out(chip, AD1816A_INDIR_DATA_LOW, value & 0xff);\r\nsnd_ad1816a_out(chip, AD1816A_INDIR_DATA_HIGH, (value >> 8) & 0xff);\r\n}\r\nstatic void snd_ad1816a_write_mask(struct snd_ad1816a *chip, unsigned char reg,\r\nunsigned short mask, unsigned short value)\r\n{\r\nsnd_ad1816a_write(chip, reg,\r\n(value & mask) | (snd_ad1816a_read(chip, reg) & ~mask));\r\n}\r\nstatic unsigned char snd_ad1816a_get_format(struct snd_ad1816a *chip,\r\nunsigned int format, int channels)\r\n{\r\nunsigned char retval = AD1816A_FMT_LINEAR_8;\r\nswitch (format) {\r\ncase SNDRV_PCM_FORMAT_MU_LAW:\r\nretval = AD1816A_FMT_ULAW_8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_A_LAW:\r\nretval = AD1816A_FMT_ALAW_8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nretval = AD1816A_FMT_LINEAR_16_LIT;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_BE:\r\nretval = AD1816A_FMT_LINEAR_16_BIG;\r\n}\r\nreturn (channels > 1) ? (retval | AD1816A_FMT_STEREO) : retval;\r\n}\r\nstatic int snd_ad1816a_open(struct snd_ad1816a *chip, unsigned int mode)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nif (chip->mode & mode) {\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn -EAGAIN;\r\n}\r\nswitch ((mode &= AD1816A_MODE_OPEN)) {\r\ncase AD1816A_MODE_PLAYBACK:\r\nsnd_ad1816a_out_mask(chip, AD1816A_INTERRUPT_STATUS,\r\nAD1816A_PLAYBACK_IRQ_PENDING, 0x00);\r\nsnd_ad1816a_write_mask(chip, AD1816A_INTERRUPT_ENABLE,\r\nAD1816A_PLAYBACK_IRQ_ENABLE, 0xffff);\r\nbreak;\r\ncase AD1816A_MODE_CAPTURE:\r\nsnd_ad1816a_out_mask(chip, AD1816A_INTERRUPT_STATUS,\r\nAD1816A_CAPTURE_IRQ_PENDING, 0x00);\r\nsnd_ad1816a_write_mask(chip, AD1816A_INTERRUPT_ENABLE,\r\nAD1816A_CAPTURE_IRQ_ENABLE, 0xffff);\r\nbreak;\r\ncase AD1816A_MODE_TIMER:\r\nsnd_ad1816a_out_mask(chip, AD1816A_INTERRUPT_STATUS,\r\nAD1816A_TIMER_IRQ_PENDING, 0x00);\r\nsnd_ad1816a_write_mask(chip, AD1816A_INTERRUPT_ENABLE,\r\nAD1816A_TIMER_IRQ_ENABLE, 0xffff);\r\n}\r\nchip->mode |= mode;\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void snd_ad1816a_close(struct snd_ad1816a *chip, unsigned int mode)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nswitch ((mode &= AD1816A_MODE_OPEN)) {\r\ncase AD1816A_MODE_PLAYBACK:\r\nsnd_ad1816a_out_mask(chip, AD1816A_INTERRUPT_STATUS,\r\nAD1816A_PLAYBACK_IRQ_PENDING, 0x00);\r\nsnd_ad1816a_write_mask(chip, AD1816A_INTERRUPT_ENABLE,\r\nAD1816A_PLAYBACK_IRQ_ENABLE, 0x0000);\r\nbreak;\r\ncase AD1816A_MODE_CAPTURE:\r\nsnd_ad1816a_out_mask(chip, AD1816A_INTERRUPT_STATUS,\r\nAD1816A_CAPTURE_IRQ_PENDING, 0x00);\r\nsnd_ad1816a_write_mask(chip, AD1816A_INTERRUPT_ENABLE,\r\nAD1816A_CAPTURE_IRQ_ENABLE, 0x0000);\r\nbreak;\r\ncase AD1816A_MODE_TIMER:\r\nsnd_ad1816a_out_mask(chip, AD1816A_INTERRUPT_STATUS,\r\nAD1816A_TIMER_IRQ_PENDING, 0x00);\r\nsnd_ad1816a_write_mask(chip, AD1816A_INTERRUPT_ENABLE,\r\nAD1816A_TIMER_IRQ_ENABLE, 0x0000);\r\n}\r\nif (!((chip->mode &= ~mode) & AD1816A_MODE_OPEN))\r\nchip->mode = 0;\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nstatic int snd_ad1816a_trigger(struct snd_ad1816a *chip, unsigned char what,\r\nint channel, int cmd, int iscapture)\r\n{\r\nint error = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nspin_lock(&chip->lock);\r\ncmd = (cmd == SNDRV_PCM_TRIGGER_START) ? 0xff: 0x00;\r\nif (! iscapture)\r\nsnd_ad1816a_out_mask(chip, AD1816A_PLAYBACK_CONFIG,\r\nAD1816A_PLAYBACK_ENABLE, cmd);\r\nelse\r\nsnd_ad1816a_out_mask(chip, AD1816A_CAPTURE_CONFIG,\r\nAD1816A_CAPTURE_ENABLE, cmd);\r\nspin_unlock(&chip->lock);\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_WARNING "invalid trigger mode 0x%x.\n", what);\r\nerror = -EINVAL;\r\n}\r\nreturn error;\r\n}\r\nstatic int snd_ad1816a_playback_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\r\nreturn snd_ad1816a_trigger(chip, AD1816A_PLAYBACK_ENABLE,\r\nSNDRV_PCM_STREAM_PLAYBACK, cmd, 0);\r\n}\r\nstatic int snd_ad1816a_capture_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\r\nreturn snd_ad1816a_trigger(chip, AD1816A_CAPTURE_ENABLE,\r\nSNDRV_PCM_STREAM_CAPTURE, cmd, 1);\r\n}\r\nstatic int snd_ad1816a_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_ad1816a_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_ad1816a_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\r\nunsigned long flags;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int size, rate;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nchip->p_dma_size = size = snd_pcm_lib_buffer_bytes(substream);\r\nsnd_ad1816a_out_mask(chip, AD1816A_PLAYBACK_CONFIG,\r\nAD1816A_PLAYBACK_ENABLE | AD1816A_PLAYBACK_PIO, 0x00);\r\nsnd_dma_program(chip->dma1, runtime->dma_addr, size,\r\nDMA_MODE_WRITE | DMA_AUTOINIT);\r\nrate = runtime->rate;\r\nif (chip->clock_freq)\r\nrate = (rate * 33000) / chip->clock_freq;\r\nsnd_ad1816a_write(chip, AD1816A_PLAYBACK_SAMPLE_RATE, rate);\r\nsnd_ad1816a_out_mask(chip, AD1816A_PLAYBACK_CONFIG,\r\nAD1816A_FMT_ALL | AD1816A_FMT_STEREO,\r\nsnd_ad1816a_get_format(chip, runtime->format,\r\nruntime->channels));\r\nsnd_ad1816a_write(chip, AD1816A_PLAYBACK_BASE_COUNT,\r\nsnd_pcm_lib_period_bytes(substream) / 4 - 1);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_ad1816a_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\r\nunsigned long flags;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int size, rate;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nchip->c_dma_size = size = snd_pcm_lib_buffer_bytes(substream);\r\nsnd_ad1816a_out_mask(chip, AD1816A_CAPTURE_CONFIG,\r\nAD1816A_CAPTURE_ENABLE | AD1816A_CAPTURE_PIO, 0x00);\r\nsnd_dma_program(chip->dma2, runtime->dma_addr, size,\r\nDMA_MODE_READ | DMA_AUTOINIT);\r\nrate = runtime->rate;\r\nif (chip->clock_freq)\r\nrate = (rate * 33000) / chip->clock_freq;\r\nsnd_ad1816a_write(chip, AD1816A_CAPTURE_SAMPLE_RATE, rate);\r\nsnd_ad1816a_out_mask(chip, AD1816A_CAPTURE_CONFIG,\r\nAD1816A_FMT_ALL | AD1816A_FMT_STEREO,\r\nsnd_ad1816a_get_format(chip, runtime->format,\r\nruntime->channels));\r\nsnd_ad1816a_write(chip, AD1816A_CAPTURE_BASE_COUNT,\r\nsnd_pcm_lib_period_bytes(substream) / 4 - 1);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_ad1816a_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nif (!(chip->mode & AD1816A_MODE_PLAYBACK))\r\nreturn 0;\r\nptr = snd_dma_pointer(chip->dma1, chip->p_dma_size);\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n}\r\nstatic snd_pcm_uframes_t snd_ad1816a_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nif (!(chip->mode & AD1816A_MODE_CAPTURE))\r\nreturn 0;\r\nptr = snd_dma_pointer(chip->dma2, chip->c_dma_size);\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n}\r\nstatic irqreturn_t snd_ad1816a_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_ad1816a *chip = dev_id;\r\nunsigned char status;\r\nspin_lock(&chip->lock);\r\nstatus = snd_ad1816a_in(chip, AD1816A_INTERRUPT_STATUS);\r\nspin_unlock(&chip->lock);\r\nif ((status & AD1816A_PLAYBACK_IRQ_PENDING) && chip->playback_substream)\r\nsnd_pcm_period_elapsed(chip->playback_substream);\r\nif ((status & AD1816A_CAPTURE_IRQ_PENDING) && chip->capture_substream)\r\nsnd_pcm_period_elapsed(chip->capture_substream);\r\nif ((status & AD1816A_TIMER_IRQ_PENDING) && chip->timer)\r\nsnd_timer_interrupt(chip->timer, chip->timer->sticks);\r\nspin_lock(&chip->lock);\r\nsnd_ad1816a_out(chip, AD1816A_INTERRUPT_STATUS, 0x00);\r\nspin_unlock(&chip->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_ad1816a_timer_close(struct snd_timer *timer)\r\n{\r\nstruct snd_ad1816a *chip = snd_timer_chip(timer);\r\nsnd_ad1816a_close(chip, AD1816A_MODE_TIMER);\r\nreturn 0;\r\n}\r\nstatic int snd_ad1816a_timer_open(struct snd_timer *timer)\r\n{\r\nstruct snd_ad1816a *chip = snd_timer_chip(timer);\r\nsnd_ad1816a_open(chip, AD1816A_MODE_TIMER);\r\nreturn 0;\r\n}\r\nstatic unsigned long snd_ad1816a_timer_resolution(struct snd_timer *timer)\r\n{\r\nif (snd_BUG_ON(!timer))\r\nreturn 0;\r\nreturn 10000;\r\n}\r\nstatic int snd_ad1816a_timer_start(struct snd_timer *timer)\r\n{\r\nunsigned short bits;\r\nunsigned long flags;\r\nstruct snd_ad1816a *chip = snd_timer_chip(timer);\r\nspin_lock_irqsave(&chip->lock, flags);\r\nbits = snd_ad1816a_read(chip, AD1816A_INTERRUPT_ENABLE);\r\nif (!(bits & AD1816A_TIMER_ENABLE)) {\r\nsnd_ad1816a_write(chip, AD1816A_TIMER_BASE_COUNT,\r\ntimer->sticks & 0xffff);\r\nsnd_ad1816a_write_mask(chip, AD1816A_INTERRUPT_ENABLE,\r\nAD1816A_TIMER_ENABLE, 0xffff);\r\n}\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_ad1816a_timer_stop(struct snd_timer *timer)\r\n{\r\nunsigned long flags;\r\nstruct snd_ad1816a *chip = snd_timer_chip(timer);\r\nspin_lock_irqsave(&chip->lock, flags);\r\nsnd_ad1816a_write_mask(chip, AD1816A_INTERRUPT_ENABLE,\r\nAD1816A_TIMER_ENABLE, 0x0000);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_ad1816a_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint error;\r\nif ((error = snd_ad1816a_open(chip, AD1816A_MODE_PLAYBACK)) < 0)\r\nreturn error;\r\nruntime->hw = snd_ad1816a_playback;\r\nsnd_pcm_limit_isa_dma_size(chip->dma1, &runtime->hw.buffer_bytes_max);\r\nsnd_pcm_limit_isa_dma_size(chip->dma1, &runtime->hw.period_bytes_max);\r\nchip->playback_substream = substream;\r\nreturn 0;\r\n}\r\nstatic int snd_ad1816a_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint error;\r\nif ((error = snd_ad1816a_open(chip, AD1816A_MODE_CAPTURE)) < 0)\r\nreturn error;\r\nruntime->hw = snd_ad1816a_capture;\r\nsnd_pcm_limit_isa_dma_size(chip->dma2, &runtime->hw.buffer_bytes_max);\r\nsnd_pcm_limit_isa_dma_size(chip->dma2, &runtime->hw.period_bytes_max);\r\nchip->capture_substream = substream;\r\nreturn 0;\r\n}\r\nstatic int snd_ad1816a_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\r\nchip->playback_substream = NULL;\r\nsnd_ad1816a_close(chip, AD1816A_MODE_PLAYBACK);\r\nreturn 0;\r\n}\r\nstatic int snd_ad1816a_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\r\nchip->capture_substream = NULL;\r\nsnd_ad1816a_close(chip, AD1816A_MODE_CAPTURE);\r\nreturn 0;\r\n}\r\nstatic void __devinit snd_ad1816a_init(struct snd_ad1816a *chip)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nsnd_ad1816a_out(chip, AD1816A_INTERRUPT_STATUS, 0x00);\r\nsnd_ad1816a_out_mask(chip, AD1816A_PLAYBACK_CONFIG,\r\nAD1816A_PLAYBACK_ENABLE | AD1816A_PLAYBACK_PIO, 0x00);\r\nsnd_ad1816a_out_mask(chip, AD1816A_CAPTURE_CONFIG,\r\nAD1816A_CAPTURE_ENABLE | AD1816A_CAPTURE_PIO, 0x00);\r\nsnd_ad1816a_write(chip, AD1816A_INTERRUPT_ENABLE, 0x0000);\r\nsnd_ad1816a_write_mask(chip, AD1816A_CHIP_CONFIG,\r\nAD1816A_CAPTURE_NOT_EQUAL | AD1816A_WSS_ENABLE, 0xffff);\r\nsnd_ad1816a_write(chip, AD1816A_DSP_CONFIG, 0x0000);\r\nsnd_ad1816a_write(chip, AD1816A_POWERDOWN_CTRL, 0x0000);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nstatic int __devinit snd_ad1816a_probe(struct snd_ad1816a *chip)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nswitch (chip->version = snd_ad1816a_read(chip, AD1816A_VERSION_ID)) {\r\ncase 0:\r\nchip->hardware = AD1816A_HW_AD1815;\r\nbreak;\r\ncase 1:\r\nchip->hardware = AD1816A_HW_AD18MAX10;\r\nbreak;\r\ncase 3:\r\nchip->hardware = AD1816A_HW_AD1816A;\r\nbreak;\r\ndefault:\r\nchip->hardware = AD1816A_HW_AUTO;\r\n}\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_ad1816a_free(struct snd_ad1816a *chip)\r\n{\r\nrelease_and_free_resource(chip->res_port);\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, (void *) chip);\r\nif (chip->dma1 >= 0) {\r\nsnd_dma_disable(chip->dma1);\r\nfree_dma(chip->dma1);\r\n}\r\nif (chip->dma2 >= 0) {\r\nsnd_dma_disable(chip->dma2);\r\nfree_dma(chip->dma2);\r\n}\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_ad1816a_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_ad1816a *chip = device->device_data;\r\nreturn snd_ad1816a_free(chip);\r\n}\r\nstatic const char __devinit *snd_ad1816a_chip_id(struct snd_ad1816a *chip)\r\n{\r\nswitch (chip->hardware) {\r\ncase AD1816A_HW_AD1816A: return "AD1816A";\r\ncase AD1816A_HW_AD1815: return "AD1815";\r\ncase AD1816A_HW_AD18MAX10: return "AD18max10";\r\ndefault:\r\nsnd_printk(KERN_WARNING "Unknown chip version %d:%d.\n",\r\nchip->version, chip->hardware);\r\nreturn "AD1816A - unknown";\r\n}\r\n}\r\nint __devinit snd_ad1816a_create(struct snd_card *card,\r\nunsigned long port, int irq, int dma1, int dma2,\r\nstruct snd_ad1816a **rchip)\r\n{\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_ad1816a_dev_free,\r\n};\r\nint error;\r\nstruct snd_ad1816a *chip;\r\n*rchip = NULL;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nchip->irq = -1;\r\nchip->dma1 = -1;\r\nchip->dma2 = -1;\r\nif ((chip->res_port = request_region(port, 16, "AD1816A")) == NULL) {\r\nsnd_printk(KERN_ERR "ad1816a: can't grab port 0x%lx\n", port);\r\nsnd_ad1816a_free(chip);\r\nreturn -EBUSY;\r\n}\r\nif (request_irq(irq, snd_ad1816a_interrupt, 0, "AD1816A", (void *) chip)) {\r\nsnd_printk(KERN_ERR "ad1816a: can't grab IRQ %d\n", irq);\r\nsnd_ad1816a_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = irq;\r\nif (request_dma(dma1, "AD1816A - 1")) {\r\nsnd_printk(KERN_ERR "ad1816a: can't grab DMA1 %d\n", dma1);\r\nsnd_ad1816a_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->dma1 = dma1;\r\nif (request_dma(dma2, "AD1816A - 2")) {\r\nsnd_printk(KERN_ERR "ad1816a: can't grab DMA2 %d\n", dma2);\r\nsnd_ad1816a_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->dma2 = dma2;\r\nchip->card = card;\r\nchip->port = port;\r\nspin_lock_init(&chip->lock);\r\nif ((error = snd_ad1816a_probe(chip))) {\r\nsnd_ad1816a_free(chip);\r\nreturn error;\r\n}\r\nsnd_ad1816a_init(chip);\r\nif ((error = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\nsnd_ad1816a_free(chip);\r\nreturn error;\r\n}\r\n*rchip = chip;\r\nreturn 0;\r\n}\r\nint __devinit snd_ad1816a_pcm(struct snd_ad1816a *chip, int device, struct snd_pcm **rpcm)\r\n{\r\nint error;\r\nstruct snd_pcm *pcm;\r\nif ((error = snd_pcm_new(chip->card, "AD1816A", device, 1, 1, &pcm)))\r\nreturn error;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ad1816a_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ad1816a_capture_ops);\r\npcm->private_data = chip;\r\npcm->info_flags = (chip->dma1 == chip->dma2 ) ? SNDRV_PCM_INFO_JOINT_DUPLEX : 0;\r\nstrcpy(pcm->name, snd_ad1816a_chip_id(chip));\r\nsnd_ad1816a_init(chip);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_isa_data(),\r\n64*1024, chip->dma1 > 3 || chip->dma2 > 3 ? 128*1024 : 64*1024);\r\nchip->pcm = pcm;\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nint __devinit snd_ad1816a_timer(struct snd_ad1816a *chip, int device, struct snd_timer **rtimer)\r\n{\r\nstruct snd_timer *timer;\r\nstruct snd_timer_id tid;\r\nint error;\r\ntid.dev_class = SNDRV_TIMER_CLASS_CARD;\r\ntid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\r\ntid.card = chip->card->number;\r\ntid.device = device;\r\ntid.subdevice = 0;\r\nif ((error = snd_timer_new(chip->card, "AD1816A", &tid, &timer)) < 0)\r\nreturn error;\r\nstrcpy(timer->name, snd_ad1816a_chip_id(chip));\r\ntimer->private_data = chip;\r\nchip->timer = timer;\r\ntimer->hw = snd_ad1816a_timer_table;\r\nif (rtimer)\r\n*rtimer = timer;\r\nreturn 0;\r\n}\r\nstatic int snd_ad1816a_info_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[8] = {\r\n"Line", "Mix", "CD", "Synth", "Video",\r\n"Mic", "Phone",\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 2;\r\nuinfo->value.enumerated.items = 7;\r\nif (uinfo->value.enumerated.item > 6)\r\nuinfo->value.enumerated.item = 6;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_ad1816a_get_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ad1816a *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nunsigned short val;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nval = snd_ad1816a_read(chip, AD1816A_ADC_SOURCE_SEL);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nucontrol->value.enumerated.item[0] = (val >> 12) & 7;\r\nucontrol->value.enumerated.item[1] = (val >> 4) & 7;\r\nreturn 0;\r\n}\r\nstatic int snd_ad1816a_put_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ad1816a *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nunsigned short val;\r\nint change;\r\nif (ucontrol->value.enumerated.item[0] > 6 ||\r\nucontrol->value.enumerated.item[1] > 6)\r\nreturn -EINVAL;\r\nval = (ucontrol->value.enumerated.item[0] << 12) |\r\n(ucontrol->value.enumerated.item[1] << 4);\r\nspin_lock_irqsave(&chip->lock, flags);\r\nchange = snd_ad1816a_read(chip, AD1816A_ADC_SOURCE_SEL) != val;\r\nsnd_ad1816a_write(chip, AD1816A_ADC_SOURCE_SEL, val);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_ad1816a_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_ad1816a_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ad1816a *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nucontrol->value.integer.value[0] = (snd_ad1816a_read(chip, reg) >> shift) & mask;\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nif (invert)\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic int snd_ad1816a_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ad1816a *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nint change;\r\nunsigned short old_val, val;\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nif (invert)\r\nval = mask - val;\r\nval <<= shift;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nold_val = snd_ad1816a_read(chip, reg);\r\nval = (old_val & ~(mask << shift)) | val;\r\nchange = val != old_val;\r\nsnd_ad1816a_write(chip, reg, val);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_ad1816a_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_ad1816a_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ad1816a *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift_left = (kcontrol->private_value >> 8) & 0x0f;\r\nint shift_right = (kcontrol->private_value >> 12) & 0x0f;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nunsigned short val;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nval = snd_ad1816a_read(chip, reg);\r\nucontrol->value.integer.value[0] = (val >> shift_left) & mask;\r\nucontrol->value.integer.value[1] = (val >> shift_right) & mask;\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nif (invert) {\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ad1816a_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ad1816a *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift_left = (kcontrol->private_value >> 8) & 0x0f;\r\nint shift_right = (kcontrol->private_value >> 12) & 0x0f;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nint change;\r\nunsigned short old_val, val1, val2;\r\nval1 = ucontrol->value.integer.value[0] & mask;\r\nval2 = ucontrol->value.integer.value[1] & mask;\r\nif (invert) {\r\nval1 = mask - val1;\r\nval2 = mask - val2;\r\n}\r\nval1 <<= shift_left;\r\nval2 <<= shift_right;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nold_val = snd_ad1816a_read(chip, reg);\r\nval1 = (old_val & ~((mask << shift_left) | (mask << shift_right))) | val1 | val2;\r\nchange = val1 != old_val;\r\nsnd_ad1816a_write(chip, reg, val1);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn change;\r\n}\r\nint __devinit snd_ad1816a_mixer(struct snd_ad1816a *chip)\r\n{\r\nstruct snd_card *card;\r\nunsigned int idx;\r\nint err;\r\nif (snd_BUG_ON(!chip || !chip->card))\r\nreturn -EINVAL;\r\ncard = chip->card;\r\nstrcpy(card->mixername, snd_ad1816a_chip_id(chip));\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_ad1816a_controls); idx++) {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_ad1816a_controls[idx], chip))) < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
