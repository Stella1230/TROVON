asmlinkage int sys_sh_pipe(unsigned long r4, unsigned long r5,\r\nunsigned long r6, unsigned long r7,\r\nstruct pt_regs __regs)\r\n{\r\nstruct pt_regs *regs = RELOC_HIDE(&__regs, 0);\r\nint fd[2];\r\nint error;\r\nerror = do_pipe_flags(fd, 0);\r\nif (!error) {\r\nregs->regs[1] = fd[1];\r\nreturn fd[0];\r\n}\r\nreturn error;\r\n}\r\nasmlinkage ssize_t sys_pread_wrapper(unsigned int fd, char __user *buf,\r\nsize_t count, long dummy, loff_t pos)\r\n{\r\nreturn sys_pread64(fd, buf, count, pos);\r\n}\r\nasmlinkage ssize_t sys_pwrite_wrapper(unsigned int fd, const char __user *buf,\r\nsize_t count, long dummy, loff_t pos)\r\n{\r\nreturn sys_pwrite64(fd, buf, count, pos);\r\n}\r\nasmlinkage int sys_fadvise64_64_wrapper(int fd, u32 offset0, u32 offset1,\r\nu32 len0, u32 len1, int advice)\r\n{\r\n#ifdef __LITTLE_ENDIAN__\r\nreturn sys_fadvise64_64(fd, (u64)offset1 << 32 | offset0,\r\n(u64)len1 << 32 | len0, advice);\r\n#else\r\nreturn sys_fadvise64_64(fd, (u64)offset0 << 32 | offset1,\r\n(u64)len0 << 32 | len1, advice);\r\n#endif\r\n}\r\nint kernel_execve(const char *filename,\r\nconst char *const argv[],\r\nconst char *const envp[])\r\n{\r\nregister long __sc0 __asm__ ("r3") = __NR_execve;\r\nregister long __sc4 __asm__ ("r4") = (long) filename;\r\nregister long __sc5 __asm__ ("r5") = (long) argv;\r\nregister long __sc6 __asm__ ("r6") = (long) envp;\r\n__asm__ __volatile__ (SYSCALL_ARG3 : "=z" (__sc0)\r\n: "0" (__sc0), "r" (__sc4), "r" (__sc5), "r" (__sc6)\r\n: "memory");\r\nreturn __sc0;\r\n}
