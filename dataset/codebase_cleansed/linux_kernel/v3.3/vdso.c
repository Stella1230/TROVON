static int __init vdso_init(void)\r\n{\r\nstruct hexagon_vdso *vdso;\r\nvdso_page = alloc_page(GFP_KERNEL);\r\nif (!vdso_page)\r\npanic("Cannot allocate vdso");\r\nvdso = vmap(&vdso_page, 1, 0, PAGE_KERNEL);\r\nif (!vdso)\r\npanic("Cannot map vdso");\r\nclear_page(vdso);\r\nvdso->rt_signal_trampoline[0] = __rt_sigtramp_template[0];\r\nvdso->rt_signal_trampoline[1] = __rt_sigtramp_template[1];\r\nvunmap(vdso);\r\nreturn 0;\r\n}\r\nint arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)\r\n{\r\nint ret;\r\nunsigned long vdso_base;\r\nstruct mm_struct *mm = current->mm;\r\ndown_write(&mm->mmap_sem);\r\nvdso_base = STACK_TOP;\r\nvdso_base = get_unmapped_area(NULL, vdso_base, PAGE_SIZE, 0, 0);\r\nif (IS_ERR_VALUE(vdso_base)) {\r\nret = vdso_base;\r\ngoto up_fail;\r\n}\r\nret = install_special_mapping(mm, vdso_base, PAGE_SIZE,\r\nVM_READ|VM_EXEC|\r\nVM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC|\r\nVM_ALWAYSDUMP,\r\n&vdso_page);\r\nif (ret)\r\ngoto up_fail;\r\nmm->context.vdso = (void *)vdso_base;\r\nup_fail:\r\nup_write(&mm->mmap_sem);\r\nreturn ret;\r\n}\r\nconst char *arch_vma_name(struct vm_area_struct *vma)\r\n{\r\nif (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso)\r\nreturn "[vdso]";\r\nreturn NULL;\r\n}
