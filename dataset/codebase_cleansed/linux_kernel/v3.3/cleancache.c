struct cleancache_ops cleancache_register_ops(struct cleancache_ops *ops)\r\n{\r\nstruct cleancache_ops old = cleancache_ops;\r\ncleancache_ops = *ops;\r\ncleancache_enabled = 1;\r\nreturn old;\r\n}\r\nvoid __cleancache_init_fs(struct super_block *sb)\r\n{\r\nsb->cleancache_poolid = (*cleancache_ops.init_fs)(PAGE_SIZE);\r\n}\r\nvoid __cleancache_init_shared_fs(char *uuid, struct super_block *sb)\r\n{\r\nsb->cleancache_poolid =\r\n(*cleancache_ops.init_shared_fs)(uuid, PAGE_SIZE);\r\n}\r\nstatic int cleancache_get_key(struct inode *inode,\r\nstruct cleancache_filekey *key)\r\n{\r\nint (*fhfn)(struct dentry *, __u32 *fh, int *, int);\r\nint len = 0, maxlen = CLEANCACHE_KEY_MAX;\r\nstruct super_block *sb = inode->i_sb;\r\nkey->u.ino = inode->i_ino;\r\nif (sb->s_export_op != NULL) {\r\nfhfn = sb->s_export_op->encode_fh;\r\nif (fhfn) {\r\nstruct dentry d;\r\nd.d_inode = inode;\r\nlen = (*fhfn)(&d, &key->u.fh[0], &maxlen, 0);\r\nif (len <= 0 || len == 255)\r\nreturn -1;\r\nif (maxlen > CLEANCACHE_KEY_MAX)\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint __cleancache_get_page(struct page *page)\r\n{\r\nint ret = -1;\r\nint pool_id;\r\nstruct cleancache_filekey key = { .u.key = { 0 } };\r\nVM_BUG_ON(!PageLocked(page));\r\npool_id = page->mapping->host->i_sb->cleancache_poolid;\r\nif (pool_id < 0)\r\ngoto out;\r\nif (cleancache_get_key(page->mapping->host, &key) < 0)\r\ngoto out;\r\nret = (*cleancache_ops.get_page)(pool_id, key, page->index, page);\r\nif (ret == 0)\r\ncleancache_succ_gets++;\r\nelse\r\ncleancache_failed_gets++;\r\nout:\r\nreturn ret;\r\n}\r\nvoid __cleancache_put_page(struct page *page)\r\n{\r\nint pool_id;\r\nstruct cleancache_filekey key = { .u.key = { 0 } };\r\nVM_BUG_ON(!PageLocked(page));\r\npool_id = page->mapping->host->i_sb->cleancache_poolid;\r\nif (pool_id >= 0 &&\r\ncleancache_get_key(page->mapping->host, &key) >= 0) {\r\n(*cleancache_ops.put_page)(pool_id, key, page->index, page);\r\ncleancache_puts++;\r\n}\r\n}\r\nvoid __cleancache_flush_page(struct address_space *mapping, struct page *page)\r\n{\r\nint pool_id = mapping->host->i_sb->cleancache_poolid;\r\nstruct cleancache_filekey key = { .u.key = { 0 } };\r\nif (pool_id >= 0) {\r\nVM_BUG_ON(!PageLocked(page));\r\nif (cleancache_get_key(mapping->host, &key) >= 0) {\r\n(*cleancache_ops.flush_page)(pool_id, key, page->index);\r\ncleancache_flushes++;\r\n}\r\n}\r\n}\r\nvoid __cleancache_flush_inode(struct address_space *mapping)\r\n{\r\nint pool_id = mapping->host->i_sb->cleancache_poolid;\r\nstruct cleancache_filekey key = { .u.key = { 0 } };\r\nif (pool_id >= 0 && cleancache_get_key(mapping->host, &key) >= 0)\r\n(*cleancache_ops.flush_inode)(pool_id, key);\r\n}\r\nvoid __cleancache_flush_fs(struct super_block *sb)\r\n{\r\nif (sb->cleancache_poolid >= 0) {\r\nint old_poolid = sb->cleancache_poolid;\r\nsb->cleancache_poolid = -1;\r\n(*cleancache_ops.flush_fs)(old_poolid);\r\n}\r\n}\r\nstatic int __init init_cleancache(void)\r\n{\r\n#ifdef CONFIG_SYSFS\r\nint err;\r\nerr = sysfs_create_group(mm_kobj, &cleancache_attr_group);\r\n#endif\r\nreturn 0;\r\n}
