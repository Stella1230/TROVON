static int pmx_mode_set(struct pmx_mode *mode)\r\n{\r\nu32 val;\r\nif (!mode->name)\r\nreturn -EFAULT;\r\npmx->active_mode = mode;\r\nval = readl(pmx->base + pmx->mode_reg.offset);\r\nval &= ~pmx->mode_reg.mask;\r\nval |= mode->mask & pmx->mode_reg.mask;\r\nwritel(val, pmx->base + pmx->mode_reg.offset);\r\nreturn 0;\r\n}\r\nstatic int pmx_devs_enable(struct pmx_dev **devs, u8 count)\r\n{\r\nu32 val, i, mask;\r\nif (!count)\r\nreturn -EINVAL;\r\nval = readl(pmx->base + pmx->mux_reg.offset);\r\nfor (i = 0; i < count; i++) {\r\nu8 j = 0;\r\nif (!devs[i]->name || !devs[i]->modes) {\r\nprintk(KERN_ERR "padmux: dev name or modes is null\n");\r\ncontinue;\r\n}\r\nif (pmx->active_mode) {\r\nbool found = false;\r\nfor (j = 0; j < devs[i]->mode_count; j++) {\r\nif (devs[i]->modes[j].ids &\r\npmx->active_mode->id) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (found == false) {\r\nprintk(KERN_ERR "%s device not available in %s"\\r\n"mode\n", devs[i]->name,\r\npmx->active_mode->name);\r\ncontinue;\r\n}\r\n}\r\nmask = devs[i]->modes[j].mask & pmx->mux_reg.mask;\r\nif (devs[i]->enb_on_reset)\r\nval &= ~mask;\r\nelse\r\nval |= mask;\r\ndevs[i]->is_active = true;\r\n}\r\nwritel(val, pmx->base + pmx->mux_reg.offset);\r\nkfree(pmx);\r\npmx = (struct pmx *)-1;\r\nreturn 0;\r\n}\r\nint pmx_register(struct pmx_driver *driver)\r\n{\r\nint ret = 0;\r\nif (pmx)\r\nreturn -EPERM;\r\nif (!driver->base || !driver->devs)\r\nreturn -EFAULT;\r\npmx = kzalloc(sizeof(*pmx), GFP_KERNEL);\r\nif (!pmx)\r\nreturn -ENOMEM;\r\npmx->base = (u32)driver->base;\r\npmx->mode_reg.offset = driver->mode_reg.offset;\r\npmx->mode_reg.mask = driver->mode_reg.mask;\r\npmx->mux_reg.offset = driver->mux_reg.offset;\r\npmx->mux_reg.mask = driver->mux_reg.mask;\r\nif (driver->mode) {\r\nret = pmx_mode_set(driver->mode);\r\nif (ret)\r\ngoto pmx_fail;\r\n}\r\nret = pmx_devs_enable(driver->devs, driver->devs_count);\r\nif (ret)\r\ngoto pmx_fail;\r\nreturn 0;\r\npmx_fail:\r\nreturn ret;\r\n}
