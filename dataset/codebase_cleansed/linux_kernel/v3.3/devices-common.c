struct amba_device *\r\ndbx500_add_amba_device(const char *name, resource_size_t base,\r\nint irq, void *pdata, unsigned int periphid)\r\n{\r\nstruct amba_device *dev;\r\nint ret;\r\ndev = kzalloc(sizeof *dev, GFP_KERNEL);\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\ndev->dev.init_name = name;\r\ndev->res.start = base;\r\ndev->res.end = base + SZ_4K - 1;\r\ndev->res.flags = IORESOURCE_MEM;\r\ndev->dma_mask = DMA_BIT_MASK(32);\r\ndev->dev.coherent_dma_mask = DMA_BIT_MASK(32);\r\ndev->irq[0] = irq;\r\ndev->irq[1] = NO_IRQ;\r\ndev->periphid = periphid;\r\ndev->dev.platform_data = pdata;\r\nret = amba_device_register(dev, &iomem_resource);\r\nif (ret) {\r\nkfree(dev);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn dev;\r\n}\r\nstatic struct platform_device *\r\ndbx500_add_platform_device(const char *name, int id, void *pdata,\r\nstruct resource *res, int resnum)\r\n{\r\nstruct platform_device *dev;\r\nint ret;\r\ndev = platform_device_alloc(name, id);\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\ndev->dev.coherent_dma_mask = DMA_BIT_MASK(32);\r\ndev->dev.dma_mask = &dev->dev.coherent_dma_mask;\r\nret = platform_device_add_resources(dev, res, resnum);\r\nif (ret)\r\ngoto out_free;\r\ndev->dev.platform_data = pdata;\r\nret = platform_device_add(dev);\r\nif (ret)\r\ngoto out_free;\r\nreturn dev;\r\nout_free:\r\nplatform_device_put(dev);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct platform_device *\r\ndbx500_add_platform_device_4k1irq(const char *name, int id,\r\nresource_size_t base,\r\nint irq, void *pdata)\r\n{\r\nstruct resource resources[] = {\r\n[0] = {\r\n.start = base,\r\n.end = base + SZ_4K - 1,\r\n.flags = IORESOURCE_MEM,\r\n},\r\n[1] = {\r\n.start = irq,\r\n.end = irq,\r\n.flags = IORESOURCE_IRQ,\r\n}\r\n};\r\nreturn dbx500_add_platform_device(name, id, pdata, resources,\r\nARRAY_SIZE(resources));\r\n}\r\nstatic struct platform_device *\r\ndbx500_add_gpio(int id, resource_size_t addr, int irq,\r\nstruct nmk_gpio_platform_data *pdata)\r\n{\r\nstruct resource resources[] = {\r\n{\r\n.start = addr,\r\n.end = addr + 127,\r\n.flags = IORESOURCE_MEM,\r\n},\r\n{\r\n.start = irq,\r\n.end = irq,\r\n.flags = IORESOURCE_IRQ,\r\n}\r\n};\r\nreturn platform_device_register_resndata(NULL, "gpio", id,\r\nresources, ARRAY_SIZE(resources),\r\npdata, sizeof(*pdata));\r\n}\r\nvoid dbx500_add_gpios(resource_size_t *base, int num, int irq,\r\nstruct nmk_gpio_platform_data *pdata)\r\n{\r\nint first = 0;\r\nint i;\r\nfor (i = 0; i < num; i++, first += 32, irq++) {\r\npdata->first_gpio = first;\r\npdata->first_irq = NOMADIK_GPIO_TO_IRQ(first);\r\npdata->num_gpio = 32;\r\ndbx500_add_gpio(i, base[i], irq, pdata);\r\n}\r\n}
