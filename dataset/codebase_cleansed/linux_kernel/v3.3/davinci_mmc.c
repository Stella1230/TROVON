static void mmc_davinci_sg_to_buf(struct mmc_davinci_host *host)\r\n{\r\nhost->buffer_bytes_left = sg_dma_len(host->sg);\r\nhost->buffer = sg_virt(host->sg);\r\nif (host->buffer_bytes_left > host->bytes_left)\r\nhost->buffer_bytes_left = host->bytes_left;\r\n}\r\nstatic void davinci_fifo_data_trans(struct mmc_davinci_host *host,\r\nunsigned int n)\r\n{\r\nu8 *p;\r\nunsigned int i;\r\nif (host->buffer_bytes_left == 0) {\r\nhost->sg = sg_next(host->data->sg);\r\nmmc_davinci_sg_to_buf(host);\r\n}\r\np = host->buffer;\r\nif (n > host->buffer_bytes_left)\r\nn = host->buffer_bytes_left;\r\nhost->buffer_bytes_left -= n;\r\nhost->bytes_left -= n;\r\nif (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {\r\nfor (i = 0; i < (n >> 2); i++) {\r\nwritel(*((u32 *)p), host->base + DAVINCI_MMCDXR);\r\np = p + 4;\r\n}\r\nif (n & 3) {\r\niowrite8_rep(host->base + DAVINCI_MMCDXR, p, (n & 3));\r\np = p + (n & 3);\r\n}\r\n} else {\r\nfor (i = 0; i < (n >> 2); i++) {\r\n*((u32 *)p) = readl(host->base + DAVINCI_MMCDRR);\r\np = p + 4;\r\n}\r\nif (n & 3) {\r\nioread8_rep(host->base + DAVINCI_MMCDRR, p, (n & 3));\r\np = p + (n & 3);\r\n}\r\n}\r\nhost->buffer = p;\r\n}\r\nstatic void mmc_davinci_start_command(struct mmc_davinci_host *host,\r\nstruct mmc_command *cmd)\r\n{\r\nu32 cmd_reg = 0;\r\nu32 im_val;\r\ndev_dbg(mmc_dev(host->mmc), "CMD%d, arg 0x%08x%s\n",\r\ncmd->opcode, cmd->arg,\r\n({ char *s;\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_R1:\r\ns = ", R1/R5/R6/R7 response";\r\nbreak;\r\ncase MMC_RSP_R1B:\r\ns = ", R1b response";\r\nbreak;\r\ncase MMC_RSP_R2:\r\ns = ", R2 response";\r\nbreak;\r\ncase MMC_RSP_R3:\r\ns = ", R3/R4 response";\r\nbreak;\r\ndefault:\r\ns = ", (R? response)";\r\nbreak;\r\n}; s; }));\r\nhost->cmd = cmd;\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_R1B:\r\ncmd_reg |= MMCCMD_BSYEXP;\r\ncase MMC_RSP_R1:\r\ncmd_reg |= MMCCMD_RSPFMT_R1456;\r\nbreak;\r\ncase MMC_RSP_R2:\r\ncmd_reg |= MMCCMD_RSPFMT_R2;\r\nbreak;\r\ncase MMC_RSP_R3:\r\ncmd_reg |= MMCCMD_RSPFMT_R3;\r\nbreak;\r\ndefault:\r\ncmd_reg |= MMCCMD_RSPFMT_NONE;\r\ndev_dbg(mmc_dev(host->mmc), "unknown resp_type %04x\n",\r\nmmc_resp_type(cmd));\r\nbreak;\r\n}\r\ncmd_reg |= cmd->opcode;\r\nif (host->do_dma)\r\ncmd_reg |= MMCCMD_DMATRIG;\r\nif (host->version == MMC_CTLR_VERSION_2 && host->data != NULL &&\r\nhost->data_dir == DAVINCI_MMC_DATADIR_READ)\r\ncmd_reg |= MMCCMD_DMATRIG;\r\nif (cmd->data)\r\ncmd_reg |= MMCCMD_WDATX;\r\nif (cmd->flags & MMC_DATA_STREAM)\r\ncmd_reg |= MMCCMD_STRMTP;\r\nif (host->data_dir == DAVINCI_MMC_DATADIR_WRITE)\r\ncmd_reg |= MMCCMD_DTRW;\r\nif (host->bus_mode == MMC_BUSMODE_PUSHPULL)\r\ncmd_reg |= MMCCMD_PPLEN;\r\nwritel(0x1FFF, host->base + DAVINCI_MMCTOR);\r\nim_val = MMCST0_RSPDNE | MMCST0_CRCRS | MMCST0_TOUTRS;\r\nif (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {\r\nim_val |= MMCST0_DATDNE | MMCST0_CRCWR;\r\nif (!host->do_dma)\r\nim_val |= MMCST0_DXRDY;\r\n} else if (host->data_dir == DAVINCI_MMC_DATADIR_READ) {\r\nim_val |= MMCST0_DATDNE | MMCST0_CRCRD | MMCST0_TOUTRD;\r\nif (!host->do_dma)\r\nim_val |= MMCST0_DRRDY;\r\n}\r\nif (!host->do_dma && (host->data_dir == DAVINCI_MMC_DATADIR_WRITE))\r\ndavinci_fifo_data_trans(host, rw_threshold);\r\nwritel(cmd->arg, host->base + DAVINCI_MMCARGHL);\r\nwritel(cmd_reg, host->base + DAVINCI_MMCCMD);\r\nwritel(im_val, host->base + DAVINCI_MMCIM);\r\n}\r\nstatic void davinci_abort_dma(struct mmc_davinci_host *host)\r\n{\r\nint sync_dev;\r\nif (host->data_dir == DAVINCI_MMC_DATADIR_READ)\r\nsync_dev = host->rxdma;\r\nelse\r\nsync_dev = host->txdma;\r\nedma_stop(sync_dev);\r\nedma_clean_channel(sync_dev);\r\n}\r\nstatic void mmc_davinci_dma_cb(unsigned channel, u16 ch_status, void *data)\r\n{\r\nif (DMA_COMPLETE != ch_status) {\r\nstruct mmc_davinci_host *host = data;\r\ndev_warn(mmc_dev(host->mmc), "DMA %s error\n",\r\n(host->data->flags & MMC_DATA_WRITE)\r\n? "write" : "read");\r\nhost->data->error = -EIO;\r\nmmc_davinci_xfer_done(host, host->data);\r\n}\r\n}\r\nstatic void __init mmc_davinci_dma_setup(struct mmc_davinci_host *host,\r\nbool tx, struct edmacc_param *template)\r\n{\r\nunsigned sync_dev;\r\nconst u16 acnt = 4;\r\nconst u16 bcnt = rw_threshold >> 2;\r\nconst u16 ccnt = 0;\r\nu32 src_port = 0;\r\nu32 dst_port = 0;\r\ns16 src_bidx, dst_bidx;\r\ns16 src_cidx, dst_cidx;\r\nif (tx) {\r\nsync_dev = host->txdma;\r\nsrc_bidx = acnt;\r\nsrc_cidx = acnt * bcnt;\r\ndst_port = host->mem_res->start + DAVINCI_MMCDXR;\r\ndst_bidx = 0;\r\ndst_cidx = 0;\r\n} else {\r\nsync_dev = host->rxdma;\r\nsrc_port = host->mem_res->start + DAVINCI_MMCDRR;\r\nsrc_bidx = 0;\r\nsrc_cidx = 0;\r\ndst_bidx = acnt;\r\ndst_cidx = acnt * bcnt;\r\n}\r\nedma_set_src(sync_dev, src_port, INCR, W8BIT);\r\nedma_set_dest(sync_dev, dst_port, INCR, W8BIT);\r\nedma_set_src_index(sync_dev, src_bidx, src_cidx);\r\nedma_set_dest_index(sync_dev, dst_bidx, dst_cidx);\r\nedma_set_transfer_params(sync_dev, acnt, bcnt, ccnt, 8, ABSYNC);\r\nedma_read_slot(sync_dev, template);\r\ntemplate->opt |= EDMA_CHAN_SLOT(sync_dev) << 12;\r\n}\r\nstatic void mmc_davinci_send_dma_request(struct mmc_davinci_host *host,\r\nstruct mmc_data *data)\r\n{\r\nstruct edmacc_param *template;\r\nint channel, slot;\r\nunsigned link;\r\nstruct scatterlist *sg;\r\nunsigned sg_len;\r\nunsigned bytes_left = host->bytes_left;\r\nconst unsigned shift = ffs(rw_threshold) - 1;\r\nif (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {\r\ntemplate = &host->tx_template;\r\nchannel = host->txdma;\r\n} else {\r\ntemplate = &host->rx_template;\r\nchannel = host->rxdma;\r\n}\r\nfor (slot = channel, link = 0, sg = data->sg, sg_len = host->sg_len;\r\nsg_len-- != 0 && bytes_left;\r\nsg = sg_next(sg), slot = host->links[link++]) {\r\nu32 buf = sg_dma_address(sg);\r\nunsigned count = sg_dma_len(sg);\r\ntemplate->link_bcntrld = sg_len\r\n? (EDMA_CHAN_SLOT(host->links[link]) << 5)\r\n: 0xffff;\r\nif (count > bytes_left)\r\ncount = bytes_left;\r\nbytes_left -= count;\r\nif (host->data_dir == DAVINCI_MMC_DATADIR_WRITE)\r\ntemplate->src = buf;\r\nelse\r\ntemplate->dst = buf;\r\ntemplate->ccnt = count >> shift;\r\nedma_write_slot(slot, template);\r\n}\r\nif (host->version == MMC_CTLR_VERSION_2)\r\nedma_clear_event(channel);\r\nedma_start(channel);\r\n}\r\nstatic int mmc_davinci_start_dma_transfer(struct mmc_davinci_host *host,\r\nstruct mmc_data *data)\r\n{\r\nint i;\r\nint mask = rw_threshold - 1;\r\nhost->sg_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\r\n((data->flags & MMC_DATA_WRITE)\r\n? DMA_TO_DEVICE\r\n: DMA_FROM_DEVICE));\r\nfor (i = 0; i < host->sg_len; i++) {\r\nif (sg_dma_len(data->sg + i) & mask) {\r\ndma_unmap_sg(mmc_dev(host->mmc),\r\ndata->sg, data->sg_len,\r\n(data->flags & MMC_DATA_WRITE)\r\n? DMA_TO_DEVICE\r\n: DMA_FROM_DEVICE);\r\nreturn -1;\r\n}\r\n}\r\nhost->do_dma = 1;\r\nmmc_davinci_send_dma_request(host, data);\r\nreturn 0;\r\n}\r\nstatic void __init_or_module\r\ndavinci_release_dma_channels(struct mmc_davinci_host *host)\r\n{\r\nunsigned i;\r\nif (!host->use_dma)\r\nreturn;\r\nfor (i = 0; i < host->n_link; i++)\r\nedma_free_slot(host->links[i]);\r\nedma_free_channel(host->txdma);\r\nedma_free_channel(host->rxdma);\r\n}\r\nstatic int __init davinci_acquire_dma_channels(struct mmc_davinci_host *host)\r\n{\r\nu32 link_size;\r\nint r, i;\r\nr = edma_alloc_channel(host->txdma, mmc_davinci_dma_cb, host,\r\nEVENTQ_DEFAULT);\r\nif (r < 0) {\r\ndev_warn(mmc_dev(host->mmc), "alloc %s channel err %d\n",\r\n"tx", r);\r\nreturn r;\r\n}\r\nmmc_davinci_dma_setup(host, true, &host->tx_template);\r\nr = edma_alloc_channel(host->rxdma, mmc_davinci_dma_cb, host,\r\nEVENTQ_DEFAULT);\r\nif (r < 0) {\r\ndev_warn(mmc_dev(host->mmc), "alloc %s channel err %d\n",\r\n"rx", r);\r\ngoto free_master_write;\r\n}\r\nmmc_davinci_dma_setup(host, false, &host->rx_template);\r\nlink_size = min_t(unsigned, host->nr_sg, ARRAY_SIZE(host->links));\r\nfor (i = 0; i < link_size; i++) {\r\nr = edma_alloc_slot(EDMA_CTLR(host->txdma), EDMA_SLOT_ANY);\r\nif (r < 0) {\r\ndev_dbg(mmc_dev(host->mmc), "dma PaRAM alloc --> %d\n",\r\nr);\r\nbreak;\r\n}\r\nhost->links[i] = r;\r\n}\r\nhost->n_link = i;\r\nreturn 0;\r\nfree_master_write:\r\nedma_free_channel(host->txdma);\r\nreturn r;\r\n}\r\nstatic void\r\nmmc_davinci_prepare_data(struct mmc_davinci_host *host, struct mmc_request *req)\r\n{\r\nint fifo_lev = (rw_threshold == 32) ? MMCFIFOCTL_FIFOLEV : 0;\r\nint timeout;\r\nstruct mmc_data *data = req->data;\r\nif (host->version == MMC_CTLR_VERSION_2)\r\nfifo_lev = (rw_threshold == 64) ? MMCFIFOCTL_FIFOLEV : 0;\r\nhost->data = data;\r\nif (data == NULL) {\r\nhost->data_dir = DAVINCI_MMC_DATADIR_NONE;\r\nwritel(0, host->base + DAVINCI_MMCBLEN);\r\nwritel(0, host->base + DAVINCI_MMCNBLK);\r\nreturn;\r\n}\r\ndev_dbg(mmc_dev(host->mmc), "%s %s, %d blocks of %d bytes\n",\r\n(data->flags & MMC_DATA_STREAM) ? "stream" : "block",\r\n(data->flags & MMC_DATA_WRITE) ? "write" : "read",\r\ndata->blocks, data->blksz);\r\ndev_dbg(mmc_dev(host->mmc), " DTO %d cycles + %d ns\n",\r\ndata->timeout_clks, data->timeout_ns);\r\ntimeout = data->timeout_clks +\r\n(data->timeout_ns / host->ns_in_one_cycle);\r\nif (timeout > 0xffff)\r\ntimeout = 0xffff;\r\nwritel(timeout, host->base + DAVINCI_MMCTOD);\r\nwritel(data->blocks, host->base + DAVINCI_MMCNBLK);\r\nwritel(data->blksz, host->base + DAVINCI_MMCBLEN);\r\nswitch (data->flags & MMC_DATA_WRITE) {\r\ncase MMC_DATA_WRITE:\r\nhost->data_dir = DAVINCI_MMC_DATADIR_WRITE;\r\nwritel(fifo_lev | MMCFIFOCTL_FIFODIR_WR | MMCFIFOCTL_FIFORST,\r\nhost->base + DAVINCI_MMCFIFOCTL);\r\nwritel(fifo_lev | MMCFIFOCTL_FIFODIR_WR,\r\nhost->base + DAVINCI_MMCFIFOCTL);\r\nbreak;\r\ndefault:\r\nhost->data_dir = DAVINCI_MMC_DATADIR_READ;\r\nwritel(fifo_lev | MMCFIFOCTL_FIFODIR_RD | MMCFIFOCTL_FIFORST,\r\nhost->base + DAVINCI_MMCFIFOCTL);\r\nwritel(fifo_lev | MMCFIFOCTL_FIFODIR_RD,\r\nhost->base + DAVINCI_MMCFIFOCTL);\r\nbreak;\r\n}\r\nhost->buffer = NULL;\r\nhost->bytes_left = data->blocks * data->blksz;\r\nif (host->use_dma && (host->bytes_left & (rw_threshold - 1)) == 0\r\n&& mmc_davinci_start_dma_transfer(host, data) == 0) {\r\nhost->bytes_left = 0;\r\n} else {\r\nhost->sg_len = data->sg_len;\r\nhost->sg = host->data->sg;\r\nmmc_davinci_sg_to_buf(host);\r\n}\r\n}\r\nstatic void mmc_davinci_request(struct mmc_host *mmc, struct mmc_request *req)\r\n{\r\nstruct mmc_davinci_host *host = mmc_priv(mmc);\r\nunsigned long timeout = jiffies + msecs_to_jiffies(900);\r\nu32 mmcst1 = 0;\r\nwhile (time_before(jiffies, timeout)) {\r\nmmcst1 = readl(host->base + DAVINCI_MMCST1);\r\nif (!(mmcst1 & MMCST1_BUSY))\r\nbreak;\r\ncpu_relax();\r\n}\r\nif (mmcst1 & MMCST1_BUSY) {\r\ndev_err(mmc_dev(host->mmc), "still BUSY? bad ... \n");\r\nreq->cmd->error = -ETIMEDOUT;\r\nmmc_request_done(mmc, req);\r\nreturn;\r\n}\r\nhost->do_dma = 0;\r\nmmc_davinci_prepare_data(host, req);\r\nmmc_davinci_start_command(host, req->cmd);\r\n}\r\nstatic unsigned int calculate_freq_for_card(struct mmc_davinci_host *host,\r\nunsigned int mmc_req_freq)\r\n{\r\nunsigned int mmc_freq = 0, mmc_pclk = 0, mmc_push_pull_divisor = 0;\r\nmmc_pclk = host->mmc_input_clk;\r\nif (mmc_req_freq && mmc_pclk > (2 * mmc_req_freq))\r\nmmc_push_pull_divisor = ((unsigned int)mmc_pclk\r\n/ (2 * mmc_req_freq)) - 1;\r\nelse\r\nmmc_push_pull_divisor = 0;\r\nmmc_freq = (unsigned int)mmc_pclk\r\n/ (2 * (mmc_push_pull_divisor + 1));\r\nif (mmc_freq > mmc_req_freq)\r\nmmc_push_pull_divisor = mmc_push_pull_divisor + 1;\r\nif (mmc_req_freq <= 400000)\r\nhost->ns_in_one_cycle = (1000000) / (((mmc_pclk\r\n/ (2 * (mmc_push_pull_divisor + 1)))/1000));\r\nelse\r\nhost->ns_in_one_cycle = (1000000) / (((mmc_pclk\r\n/ (2 * (mmc_push_pull_divisor + 1)))/1000000));\r\nreturn mmc_push_pull_divisor;\r\n}\r\nstatic void calculate_clk_divider(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nunsigned int open_drain_freq = 0, mmc_pclk = 0;\r\nunsigned int mmc_push_pull_freq = 0;\r\nstruct mmc_davinci_host *host = mmc_priv(mmc);\r\nif (ios->bus_mode == MMC_BUSMODE_OPENDRAIN) {\r\nu32 temp;\r\nopen_drain_freq = ((unsigned int)mmc_pclk\r\n/ (2 * MMCSD_INIT_CLOCK)) - 1;\r\nif (open_drain_freq > 0xFF)\r\nopen_drain_freq = 0xFF;\r\ntemp = readl(host->base + DAVINCI_MMCCLK) & ~MMCCLK_CLKRT_MASK;\r\ntemp |= open_drain_freq;\r\nwritel(temp, host->base + DAVINCI_MMCCLK);\r\nhost->ns_in_one_cycle = (1000000) / (MMCSD_INIT_CLOCK/1000);\r\n} else {\r\nu32 temp;\r\nmmc_push_pull_freq = calculate_freq_for_card(host, ios->clock);\r\nif (mmc_push_pull_freq > 0xFF)\r\nmmc_push_pull_freq = 0xFF;\r\ntemp = readl(host->base + DAVINCI_MMCCLK) & ~MMCCLK_CLKEN;\r\nwritel(temp, host->base + DAVINCI_MMCCLK);\r\nudelay(10);\r\ntemp = readl(host->base + DAVINCI_MMCCLK) & ~MMCCLK_CLKRT_MASK;\r\ntemp |= mmc_push_pull_freq;\r\nwritel(temp, host->base + DAVINCI_MMCCLK);\r\nwritel(temp | MMCCLK_CLKEN, host->base + DAVINCI_MMCCLK);\r\nudelay(10);\r\n}\r\n}\r\nstatic void mmc_davinci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct mmc_davinci_host *host = mmc_priv(mmc);\r\nstruct platform_device *pdev = to_platform_device(mmc->parent);\r\nstruct davinci_mmc_config *config = pdev->dev.platform_data;\r\ndev_dbg(mmc_dev(host->mmc),\r\n"clock %dHz busmode %d powermode %d Vdd %04x\n",\r\nios->clock, ios->bus_mode, ios->power_mode,\r\nios->vdd);\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_OFF:\r\nif (config && config->set_power)\r\nconfig->set_power(pdev->id, false);\r\nbreak;\r\ncase MMC_POWER_UP:\r\nif (config && config->set_power)\r\nconfig->set_power(pdev->id, true);\r\nbreak;\r\n}\r\nswitch (ios->bus_width) {\r\ncase MMC_BUS_WIDTH_8:\r\ndev_dbg(mmc_dev(host->mmc), "Enabling 8 bit mode\n");\r\nwritel((readl(host->base + DAVINCI_MMCCTL) &\r\n~MMCCTL_WIDTH_4_BIT) | MMCCTL_WIDTH_8_BIT,\r\nhost->base + DAVINCI_MMCCTL);\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\ndev_dbg(mmc_dev(host->mmc), "Enabling 4 bit mode\n");\r\nif (host->version == MMC_CTLR_VERSION_2)\r\nwritel((readl(host->base + DAVINCI_MMCCTL) &\r\n~MMCCTL_WIDTH_8_BIT) | MMCCTL_WIDTH_4_BIT,\r\nhost->base + DAVINCI_MMCCTL);\r\nelse\r\nwritel(readl(host->base + DAVINCI_MMCCTL) |\r\nMMCCTL_WIDTH_4_BIT,\r\nhost->base + DAVINCI_MMCCTL);\r\nbreak;\r\ncase MMC_BUS_WIDTH_1:\r\ndev_dbg(mmc_dev(host->mmc), "Enabling 1 bit mode\n");\r\nif (host->version == MMC_CTLR_VERSION_2)\r\nwritel(readl(host->base + DAVINCI_MMCCTL) &\r\n~(MMCCTL_WIDTH_8_BIT | MMCCTL_WIDTH_4_BIT),\r\nhost->base + DAVINCI_MMCCTL);\r\nelse\r\nwritel(readl(host->base + DAVINCI_MMCCTL) &\r\n~MMCCTL_WIDTH_4_BIT,\r\nhost->base + DAVINCI_MMCCTL);\r\nbreak;\r\n}\r\ncalculate_clk_divider(mmc, ios);\r\nhost->bus_mode = ios->bus_mode;\r\nif (ios->power_mode == MMC_POWER_UP) {\r\nunsigned long timeout = jiffies + msecs_to_jiffies(50);\r\nbool lose = true;\r\nwritel(0, host->base + DAVINCI_MMCARGHL);\r\nwritel(MMCCMD_INITCK, host->base + DAVINCI_MMCCMD);\r\nwhile (time_before(jiffies, timeout)) {\r\nu32 tmp = readl(host->base + DAVINCI_MMCST0);\r\nif (tmp & MMCST0_RSPDNE) {\r\nlose = false;\r\nbreak;\r\n}\r\ncpu_relax();\r\n}\r\nif (lose)\r\ndev_warn(mmc_dev(host->mmc), "powerup timeout\n");\r\n}\r\n}\r\nstatic void\r\nmmc_davinci_xfer_done(struct mmc_davinci_host *host, struct mmc_data *data)\r\n{\r\nhost->data = NULL;\r\nif (host->mmc->caps & MMC_CAP_SDIO_IRQ) {\r\nif (host->sdio_int && !(readl(host->base + DAVINCI_SDIOST0) &\r\nSDIOST0_DAT1_HI)) {\r\nwritel(SDIOIST_IOINT, host->base + DAVINCI_SDIOIST);\r\nmmc_signal_sdio_irq(host->mmc);\r\n}\r\n}\r\nif (host->do_dma) {\r\ndavinci_abort_dma(host);\r\ndma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\r\n(data->flags & MMC_DATA_WRITE)\r\n? DMA_TO_DEVICE\r\n: DMA_FROM_DEVICE);\r\nhost->do_dma = false;\r\n}\r\nhost->data_dir = DAVINCI_MMC_DATADIR_NONE;\r\nif (!data->stop || (host->cmd && host->cmd->error)) {\r\nmmc_request_done(host->mmc, data->mrq);\r\nwritel(0, host->base + DAVINCI_MMCIM);\r\n} else\r\nmmc_davinci_start_command(host, data->stop);\r\n}\r\nstatic void mmc_davinci_cmd_done(struct mmc_davinci_host *host,\r\nstruct mmc_command *cmd)\r\n{\r\nhost->cmd = NULL;\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nif (cmd->flags & MMC_RSP_136) {\r\ncmd->resp[3] = readl(host->base + DAVINCI_MMCRSP01);\r\ncmd->resp[2] = readl(host->base + DAVINCI_MMCRSP23);\r\ncmd->resp[1] = readl(host->base + DAVINCI_MMCRSP45);\r\ncmd->resp[0] = readl(host->base + DAVINCI_MMCRSP67);\r\n} else {\r\ncmd->resp[0] = readl(host->base + DAVINCI_MMCRSP67);\r\n}\r\n}\r\nif (host->data == NULL || cmd->error) {\r\nif (cmd->error == -ETIMEDOUT)\r\ncmd->mrq->cmd->retries = 0;\r\nmmc_request_done(host->mmc, cmd->mrq);\r\nwritel(0, host->base + DAVINCI_MMCIM);\r\n}\r\n}\r\nstatic inline void mmc_davinci_reset_ctrl(struct mmc_davinci_host *host,\r\nint val)\r\n{\r\nu32 temp;\r\ntemp = readl(host->base + DAVINCI_MMCCTL);\r\nif (val)\r\ntemp |= MMCCTL_CMDRST | MMCCTL_DATRST;\r\nelse\r\ntemp &= ~(MMCCTL_CMDRST | MMCCTL_DATRST);\r\nwritel(temp, host->base + DAVINCI_MMCCTL);\r\nudelay(10);\r\n}\r\nstatic void\r\ndavinci_abort_data(struct mmc_davinci_host *host, struct mmc_data *data)\r\n{\r\nmmc_davinci_reset_ctrl(host, 1);\r\nmmc_davinci_reset_ctrl(host, 0);\r\n}\r\nstatic irqreturn_t mmc_davinci_sdio_irq(int irq, void *dev_id)\r\n{\r\nstruct mmc_davinci_host *host = dev_id;\r\nunsigned int status;\r\nstatus = readl(host->base + DAVINCI_SDIOIST);\r\nif (status & SDIOIST_IOINT) {\r\ndev_dbg(mmc_dev(host->mmc),\r\n"SDIO interrupt status %x\n", status);\r\nwritel(status | SDIOIST_IOINT, host->base + DAVINCI_SDIOIST);\r\nmmc_signal_sdio_irq(host->mmc);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mmc_davinci_irq(int irq, void *dev_id)\r\n{\r\nstruct mmc_davinci_host *host = (struct mmc_davinci_host *)dev_id;\r\nunsigned int status, qstatus;\r\nint end_command = 0;\r\nint end_transfer = 0;\r\nstruct mmc_data *data = host->data;\r\nif (host->cmd == NULL && host->data == NULL) {\r\nstatus = readl(host->base + DAVINCI_MMCST0);\r\ndev_dbg(mmc_dev(host->mmc),\r\n"Spurious interrupt 0x%04x\n", status);\r\nwritel(0, host->base + DAVINCI_MMCIM);\r\nreturn IRQ_NONE;\r\n}\r\nstatus = readl(host->base + DAVINCI_MMCST0);\r\nqstatus = status;\r\nwhile (host->bytes_left && (status & (MMCST0_DXRDY | MMCST0_DRRDY))) {\r\ndavinci_fifo_data_trans(host, rw_threshold);\r\nstatus = readl(host->base + DAVINCI_MMCST0);\r\nif (!status)\r\nbreak;\r\nqstatus |= status;\r\n}\r\nif (qstatus & MMCST0_DATDNE) {\r\nif (data != NULL) {\r\nif ((host->do_dma == 0) && (host->bytes_left > 0)) {\r\ndavinci_fifo_data_trans(host, host->bytes_left);\r\n}\r\nend_transfer = 1;\r\ndata->bytes_xfered = data->blocks * data->blksz;\r\n} else {\r\ndev_err(mmc_dev(host->mmc),\r\n"DATDNE with no host->data\n");\r\n}\r\n}\r\nif (qstatus & MMCST0_TOUTRD) {\r\ndata->error = -ETIMEDOUT;\r\nend_transfer = 1;\r\ndev_dbg(mmc_dev(host->mmc),\r\n"read data timeout, status %x\n",\r\nqstatus);\r\ndavinci_abort_data(host, data);\r\n}\r\nif (qstatus & (MMCST0_CRCWR | MMCST0_CRCRD)) {\r\ndata->error = -EILSEQ;\r\nend_transfer = 1;\r\nif (qstatus & MMCST0_CRCWR) {\r\nu32 temp = readb(host->base + DAVINCI_MMCDRSP);\r\nif (temp == 0x9f)\r\ndata->error = -ETIMEDOUT;\r\n}\r\ndev_dbg(mmc_dev(host->mmc), "data %s %s error\n",\r\n(qstatus & MMCST0_CRCWR) ? "write" : "read",\r\n(data->error == -ETIMEDOUT) ? "timeout" : "CRC");\r\ndavinci_abort_data(host, data);\r\n}\r\nif (qstatus & MMCST0_TOUTRS) {\r\nif (host->cmd) {\r\ndev_dbg(mmc_dev(host->mmc),\r\n"CMD%d timeout, status %x\n",\r\nhost->cmd->opcode, qstatus);\r\nhost->cmd->error = -ETIMEDOUT;\r\nif (data) {\r\nend_transfer = 1;\r\ndavinci_abort_data(host, data);\r\n} else\r\nend_command = 1;\r\n}\r\n}\r\nif (qstatus & MMCST0_CRCRS) {\r\ndev_dbg(mmc_dev(host->mmc), "Command CRC error\n");\r\nif (host->cmd) {\r\nhost->cmd->error = -EILSEQ;\r\nend_command = 1;\r\n}\r\n}\r\nif (qstatus & MMCST0_RSPDNE) {\r\nend_command = (int) host->cmd;\r\n}\r\nif (end_command)\r\nmmc_davinci_cmd_done(host, host->cmd);\r\nif (end_transfer)\r\nmmc_davinci_xfer_done(host, data);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mmc_davinci_get_cd(struct mmc_host *mmc)\r\n{\r\nstruct platform_device *pdev = to_platform_device(mmc->parent);\r\nstruct davinci_mmc_config *config = pdev->dev.platform_data;\r\nif (!config || !config->get_cd)\r\nreturn -ENOSYS;\r\nreturn config->get_cd(pdev->id);\r\n}\r\nstatic int mmc_davinci_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct platform_device *pdev = to_platform_device(mmc->parent);\r\nstruct davinci_mmc_config *config = pdev->dev.platform_data;\r\nif (!config || !config->get_ro)\r\nreturn -ENOSYS;\r\nreturn config->get_ro(pdev->id);\r\n}\r\nstatic void mmc_davinci_enable_sdio_irq(struct mmc_host *mmc, int enable)\r\n{\r\nstruct mmc_davinci_host *host = mmc_priv(mmc);\r\nif (enable) {\r\nif (!(readl(host->base + DAVINCI_SDIOST0) & SDIOST0_DAT1_HI)) {\r\nwritel(SDIOIST_IOINT, host->base + DAVINCI_SDIOIST);\r\nmmc_signal_sdio_irq(host->mmc);\r\n} else {\r\nhost->sdio_int = true;\r\nwritel(readl(host->base + DAVINCI_SDIOIEN) |\r\nSDIOIEN_IOINTEN, host->base + DAVINCI_SDIOIEN);\r\n}\r\n} else {\r\nhost->sdio_int = false;\r\nwritel(readl(host->base + DAVINCI_SDIOIEN) & ~SDIOIEN_IOINTEN,\r\nhost->base + DAVINCI_SDIOIEN);\r\n}\r\n}\r\nstatic int mmc_davinci_cpufreq_transition(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct mmc_davinci_host *host;\r\nunsigned int mmc_pclk;\r\nstruct mmc_host *mmc;\r\nunsigned long flags;\r\nhost = container_of(nb, struct mmc_davinci_host, freq_transition);\r\nmmc = host->mmc;\r\nmmc_pclk = clk_get_rate(host->clk);\r\nif (val == CPUFREQ_POSTCHANGE) {\r\nspin_lock_irqsave(&mmc->lock, flags);\r\nhost->mmc_input_clk = mmc_pclk;\r\ncalculate_clk_divider(mmc, &mmc->ios);\r\nspin_unlock_irqrestore(&mmc->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int mmc_davinci_cpufreq_register(struct mmc_davinci_host *host)\r\n{\r\nhost->freq_transition.notifier_call = mmc_davinci_cpufreq_transition;\r\nreturn cpufreq_register_notifier(&host->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline void mmc_davinci_cpufreq_deregister(struct mmc_davinci_host *host)\r\n{\r\ncpufreq_unregister_notifier(&host->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline int mmc_davinci_cpufreq_register(struct mmc_davinci_host *host)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void mmc_davinci_cpufreq_deregister(struct mmc_davinci_host *host)\r\n{\r\n}\r\nstatic void __init init_mmcsd_host(struct mmc_davinci_host *host)\r\n{\r\nmmc_davinci_reset_ctrl(host, 1);\r\nwritel(0, host->base + DAVINCI_MMCCLK);\r\nwritel(MMCCLK_CLKEN, host->base + DAVINCI_MMCCLK);\r\nwritel(0x1FFF, host->base + DAVINCI_MMCTOR);\r\nwritel(0xFFFF, host->base + DAVINCI_MMCTOD);\r\nmmc_davinci_reset_ctrl(host, 0);\r\n}\r\nstatic int __init davinci_mmcsd_probe(struct platform_device *pdev)\r\n{\r\nstruct davinci_mmc_config *pdata = pdev->dev.platform_data;\r\nstruct mmc_davinci_host *host = NULL;\r\nstruct mmc_host *mmc = NULL;\r\nstruct resource *r, *mem = NULL;\r\nint ret = 0, irq = 0;\r\nsize_t mem_size;\r\nret = -ENODEV;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!r || irq == NO_IRQ)\r\ngoto out;\r\nret = -EBUSY;\r\nmem_size = resource_size(r);\r\nmem = request_mem_region(r->start, mem_size, pdev->name);\r\nif (!mem)\r\ngoto out;\r\nret = -ENOMEM;\r\nmmc = mmc_alloc_host(sizeof(struct mmc_davinci_host), &pdev->dev);\r\nif (!mmc)\r\ngoto out;\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\nr = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!r)\r\ngoto out;\r\nhost->rxdma = r->start;\r\nr = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (!r)\r\ngoto out;\r\nhost->txdma = r->start;\r\nhost->mem_res = mem;\r\nhost->base = ioremap(mem->start, mem_size);\r\nif (!host->base)\r\ngoto out;\r\nret = -ENXIO;\r\nhost->clk = clk_get(&pdev->dev, "MMCSDCLK");\r\nif (IS_ERR(host->clk)) {\r\nret = PTR_ERR(host->clk);\r\ngoto out;\r\n}\r\nclk_enable(host->clk);\r\nhost->mmc_input_clk = clk_get_rate(host->clk);\r\ninit_mmcsd_host(host);\r\nif (pdata->nr_sg)\r\nhost->nr_sg = pdata->nr_sg - 1;\r\nif (host->nr_sg > MAX_NR_SG || !host->nr_sg)\r\nhost->nr_sg = MAX_NR_SG;\r\nhost->use_dma = use_dma;\r\nhost->mmc_irq = irq;\r\nhost->sdio_irq = platform_get_irq(pdev, 1);\r\nif (host->use_dma && davinci_acquire_dma_channels(host) != 0)\r\nhost->use_dma = 0;\r\nmmc->caps |= MMC_CAP_NEEDS_POLL;\r\nmmc->caps |= MMC_CAP_WAIT_WHILE_BUSY;\r\nif (pdata && (pdata->wires == 4 || pdata->wires == 0))\r\nmmc->caps |= MMC_CAP_4_BIT_DATA;\r\nif (pdata && (pdata->wires == 8))\r\nmmc->caps |= (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA);\r\nhost->version = pdata->version;\r\nmmc->ops = &mmc_davinci_ops;\r\nmmc->f_min = 312500;\r\nmmc->f_max = 25000000;\r\nif (pdata && pdata->max_freq)\r\nmmc->f_max = pdata->max_freq;\r\nif (pdata && pdata->caps)\r\nmmc->caps |= pdata->caps;\r\nmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\r\nmmc->max_segs = 1 + host->n_link;\r\nmmc->max_seg_size = MAX_CCNT * rw_threshold;\r\nmmc->max_blk_size = 4095;\r\nmmc->max_blk_count = 65535;\r\nmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\r\ndev_dbg(mmc_dev(host->mmc), "max_segs=%d\n", mmc->max_segs);\r\ndev_dbg(mmc_dev(host->mmc), "max_blk_size=%d\n", mmc->max_blk_size);\r\ndev_dbg(mmc_dev(host->mmc), "max_req_size=%d\n", mmc->max_req_size);\r\ndev_dbg(mmc_dev(host->mmc), "max_seg_size=%d\n", mmc->max_seg_size);\r\nplatform_set_drvdata(pdev, host);\r\nret = mmc_davinci_cpufreq_register(host);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register cpufreq\n");\r\ngoto cpu_freq_fail;\r\n}\r\nret = mmc_add_host(mmc);\r\nif (ret < 0)\r\ngoto out;\r\nret = request_irq(irq, mmc_davinci_irq, 0, mmc_hostname(mmc), host);\r\nif (ret)\r\ngoto out;\r\nif (host->sdio_irq >= 0) {\r\nret = request_irq(host->sdio_irq, mmc_davinci_sdio_irq, 0,\r\nmmc_hostname(mmc), host);\r\nif (!ret)\r\nmmc->caps |= MMC_CAP_SDIO_IRQ;\r\n}\r\nrename_region(mem, mmc_hostname(mmc));\r\ndev_info(mmc_dev(host->mmc), "Using %s, %d-bit mode\n",\r\nhost->use_dma ? "DMA" : "PIO",\r\n(mmc->caps & MMC_CAP_4_BIT_DATA) ? 4 : 1);\r\nreturn 0;\r\nout:\r\nmmc_davinci_cpufreq_deregister(host);\r\ncpu_freq_fail:\r\nif (host) {\r\ndavinci_release_dma_channels(host);\r\nif (host->clk) {\r\nclk_disable(host->clk);\r\nclk_put(host->clk);\r\n}\r\nif (host->base)\r\niounmap(host->base);\r\n}\r\nif (mmc)\r\nmmc_free_host(mmc);\r\nif (mem)\r\nrelease_resource(mem);\r\ndev_dbg(&pdev->dev, "probe err %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int __exit davinci_mmcsd_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_davinci_host *host = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nif (host) {\r\nmmc_davinci_cpufreq_deregister(host);\r\nmmc_remove_host(host->mmc);\r\nfree_irq(host->mmc_irq, host);\r\nif (host->mmc->caps & MMC_CAP_SDIO_IRQ)\r\nfree_irq(host->sdio_irq, host);\r\ndavinci_release_dma_channels(host);\r\nclk_disable(host->clk);\r\nclk_put(host->clk);\r\niounmap(host->base);\r\nrelease_resource(host->mem_res);\r\nmmc_free_host(host->mmc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int davinci_mmcsd_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct mmc_davinci_host *host = platform_get_drvdata(pdev);\r\nint ret;\r\nmmc_host_enable(host->mmc);\r\nret = mmc_suspend_host(host->mmc);\r\nif (!ret) {\r\nwritel(0, host->base + DAVINCI_MMCIM);\r\nmmc_davinci_reset_ctrl(host, 1);\r\nmmc_host_disable(host->mmc);\r\nclk_disable(host->clk);\r\nhost->suspended = 1;\r\n} else {\r\nhost->suspended = 0;\r\nmmc_host_disable(host->mmc);\r\n}\r\nreturn ret;\r\n}\r\nstatic int davinci_mmcsd_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct mmc_davinci_host *host = platform_get_drvdata(pdev);\r\nint ret;\r\nif (!host->suspended)\r\nreturn 0;\r\nclk_enable(host->clk);\r\nmmc_host_enable(host->mmc);\r\nmmc_davinci_reset_ctrl(host, 0);\r\nret = mmc_resume_host(host->mmc);\r\nif (!ret)\r\nhost->suspended = 0;\r\nreturn ret;\r\n}\r\nstatic int __init davinci_mmcsd_init(void)\r\n{\r\nreturn platform_driver_probe(&davinci_mmcsd_driver,\r\ndavinci_mmcsd_probe);\r\n}\r\nstatic void __exit davinci_mmcsd_exit(void)\r\n{\r\nplatform_driver_unregister(&davinci_mmcsd_driver);\r\n}
