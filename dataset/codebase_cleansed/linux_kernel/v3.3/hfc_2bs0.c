static inline int\r\nWaitForBusy(struct IsdnCardState *cs)\r\n{\r\nint to = 130;\r\nu_char val;\r\nwhile (!(cs->BC_Read_Reg(cs, HFC_STATUS, 0) & HFC_BUSY) && to) {\r\nval = cs->BC_Read_Reg(cs, HFC_DATA, HFC_CIP | HFC_F2 |\r\n(cs->hw.hfc.cip & 3));\r\nudelay(1);\r\nto--;\r\n}\r\nif (!to) {\r\nprintk(KERN_WARNING "HiSax: waitforBusy timeout\n");\r\nreturn (0);\r\n} else\r\nreturn (to);\r\n}\r\nstatic inline int\r\nWaitNoBusy(struct IsdnCardState *cs)\r\n{\r\nint to = 125;\r\nwhile ((cs->BC_Read_Reg(cs, HFC_STATUS, 0) & HFC_BUSY) && to) {\r\nudelay(1);\r\nto--;\r\n}\r\nif (!to) {\r\nprintk(KERN_WARNING "HiSax: waitforBusy timeout\n");\r\nreturn (0);\r\n} else\r\nreturn (to);\r\n}\r\nstatic int\r\nGetFreeFifoBytes(struct BCState *bcs)\r\n{\r\nint s;\r\nif (bcs->hw.hfc.f1 == bcs->hw.hfc.f2)\r\nreturn (bcs->cs->hw.hfc.fifosize);\r\ns = bcs->hw.hfc.send[bcs->hw.hfc.f1] - bcs->hw.hfc.send[bcs->hw.hfc.f2];\r\nif (s <= 0)\r\ns += bcs->cs->hw.hfc.fifosize;\r\ns = bcs->cs->hw.hfc.fifosize - s;\r\nreturn (s);\r\n}\r\nstatic int\r\nReadZReg(struct BCState *bcs, u_char reg)\r\n{\r\nint val;\r\nWaitNoBusy(bcs->cs);\r\nval = 256 * bcs->cs->BC_Read_Reg(bcs->cs, HFC_DATA, reg | HFC_CIP | HFC_Z_HIGH);\r\nWaitNoBusy(bcs->cs);\r\nval += bcs->cs->BC_Read_Reg(bcs->cs, HFC_DATA, reg | HFC_CIP | HFC_Z_LOW);\r\nreturn (val);\r\n}\r\nstatic void\r\nhfc_clear_fifo(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint idx, cnt;\r\nint rcnt, z1, z2;\r\nu_char cip, f1, f2;\r\nif ((cs->debug & L1_DEB_HSCX) && !(cs->debug & L1_DEB_HSCX_FIFO))\r\ndebugl1(cs, "hfc_clear_fifo");\r\ncip = HFC_CIP | HFC_F1 | HFC_REC | HFC_CHANNEL(bcs->channel);\r\nif ((cip & 0xc3) != (cs->hw.hfc.cip & 0xc3)) {\r\ncs->BC_Write_Reg(cs, HFC_STATUS, cip, cip);\r\nWaitForBusy(cs);\r\n}\r\nWaitNoBusy(cs);\r\nf1 = cs->BC_Read_Reg(cs, HFC_DATA, cip);\r\ncip = HFC_CIP | HFC_F2 | HFC_REC | HFC_CHANNEL(bcs->channel);\r\nWaitNoBusy(cs);\r\nf2 = cs->BC_Read_Reg(cs, HFC_DATA, cip);\r\nz1 = ReadZReg(bcs, HFC_Z1 | HFC_REC | HFC_CHANNEL(bcs->channel));\r\nz2 = ReadZReg(bcs, HFC_Z2 | HFC_REC | HFC_CHANNEL(bcs->channel));\r\ncnt = 32;\r\nwhile (((f1 != f2) || (z1 != z2)) && cnt--) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc clear %d f1(%d) f2(%d)",\r\nbcs->channel, f1, f2);\r\nrcnt = z1 - z2;\r\nif (rcnt < 0)\r\nrcnt += cs->hw.hfc.fifosize;\r\nif (rcnt)\r\nrcnt++;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc clear %d z1(%x) z2(%x) cnt(%d)",\r\nbcs->channel, z1, z2, rcnt);\r\ncip = HFC_CIP | HFC_FIFO_OUT | HFC_REC | HFC_CHANNEL(bcs->channel);\r\nidx = 0;\r\nwhile ((idx < rcnt) && WaitNoBusy(cs)) {\r\ncs->BC_Read_Reg(cs, HFC_DATA_NODEB, cip);\r\nidx++;\r\n}\r\nif (f1 != f2) {\r\nWaitNoBusy(cs);\r\ncs->BC_Read_Reg(cs, HFC_DATA, HFC_CIP | HFC_F2_INC | HFC_REC |\r\nHFC_CHANNEL(bcs->channel));\r\nWaitForBusy(cs);\r\n}\r\ncip = HFC_CIP | HFC_F1 | HFC_REC | HFC_CHANNEL(bcs->channel);\r\nWaitNoBusy(cs);\r\nf1 = cs->BC_Read_Reg(cs, HFC_DATA, cip);\r\ncip = HFC_CIP | HFC_F2 | HFC_REC | HFC_CHANNEL(bcs->channel);\r\nWaitNoBusy(cs);\r\nf2 = cs->BC_Read_Reg(cs, HFC_DATA, cip);\r\nz1 = ReadZReg(bcs, HFC_Z1 | HFC_REC | HFC_CHANNEL(bcs->channel));\r\nz2 = ReadZReg(bcs, HFC_Z2 | HFC_REC | HFC_CHANNEL(bcs->channel));\r\n}\r\nreturn;\r\n}\r\nstatic struct sk_buff\r\n*\r\nhfc_empty_fifo(struct BCState *bcs, int count)\r\n{\r\nu_char *ptr;\r\nstruct sk_buff *skb;\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint idx;\r\nint chksum;\r\nu_char stat, cip;\r\nif ((cs->debug & L1_DEB_HSCX) && !(cs->debug & L1_DEB_HSCX_FIFO))\r\ndebugl1(cs, "hfc_empty_fifo");\r\nidx = 0;\r\nif (count > HSCX_BUFMAX + 3) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "hfc_empty_fifo: incoming packet too large");\r\ncip = HFC_CIP | HFC_FIFO_OUT | HFC_REC | HFC_CHANNEL(bcs->channel);\r\nwhile ((idx++ < count) && WaitNoBusy(cs))\r\ncs->BC_Read_Reg(cs, HFC_DATA_NODEB, cip);\r\nWaitNoBusy(cs);\r\nstat = cs->BC_Read_Reg(cs, HFC_DATA, HFC_CIP | HFC_F2_INC | HFC_REC |\r\nHFC_CHANNEL(bcs->channel));\r\nWaitForBusy(cs);\r\nreturn (NULL);\r\n}\r\nif ((count < 4) && (bcs->mode != L1_MODE_TRANS)) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "hfc_empty_fifo: incoming packet too small");\r\ncip = HFC_CIP | HFC_FIFO_OUT | HFC_REC | HFC_CHANNEL(bcs->channel);\r\nwhile ((idx++ < count) && WaitNoBusy(cs))\r\ncs->BC_Read_Reg(cs, HFC_DATA_NODEB, cip);\r\nWaitNoBusy(cs);\r\nstat = cs->BC_Read_Reg(cs, HFC_DATA, HFC_CIP | HFC_F2_INC | HFC_REC |\r\nHFC_CHANNEL(bcs->channel));\r\nWaitForBusy(cs);\r\n#ifdef ERROR_STATISTIC\r\nbcs->err_inv++;\r\n#endif\r\nreturn (NULL);\r\n}\r\nif (bcs->mode == L1_MODE_TRANS)\r\ncount -= 1;\r\nelse\r\ncount -= 3;\r\nif (!(skb = dev_alloc_skb(count)))\r\nprintk(KERN_WARNING "HFC: receive out of memory\n");\r\nelse {\r\nptr = skb_put(skb, count);\r\nidx = 0;\r\ncip = HFC_CIP | HFC_FIFO_OUT | HFC_REC | HFC_CHANNEL(bcs->channel);\r\nwhile ((idx < count) && WaitNoBusy(cs)) {\r\n*ptr++ = cs->BC_Read_Reg(cs, HFC_DATA_NODEB, cip);\r\nidx++;\r\n}\r\nif (idx != count) {\r\ndebugl1(cs, "RFIFO BUSY error");\r\nprintk(KERN_WARNING "HFC FIFO channel %d BUSY Error\n", bcs->channel);\r\ndev_kfree_skb_any(skb);\r\nif (bcs->mode != L1_MODE_TRANS) {\r\nWaitNoBusy(cs);\r\nstat = cs->BC_Read_Reg(cs, HFC_DATA, HFC_CIP | HFC_F2_INC | HFC_REC |\r\nHFC_CHANNEL(bcs->channel));\r\nWaitForBusy(cs);\r\n}\r\nreturn (NULL);\r\n}\r\nif (bcs->mode != L1_MODE_TRANS) {\r\nWaitNoBusy(cs);\r\nchksum = (cs->BC_Read_Reg(cs, HFC_DATA, cip) << 8);\r\nWaitNoBusy(cs);\r\nchksum += cs->BC_Read_Reg(cs, HFC_DATA, cip);\r\nWaitNoBusy(cs);\r\nstat = cs->BC_Read_Reg(cs, HFC_DATA, cip);\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc_empty_fifo %d chksum %x stat %x",\r\nbcs->channel, chksum, stat);\r\nif (stat) {\r\ndebugl1(cs, "FIFO CRC error");\r\ndev_kfree_skb_any(skb);\r\nskb = NULL;\r\n#ifdef ERROR_STATISTIC\r\nbcs->err_crc++;\r\n#endif\r\n}\r\nWaitNoBusy(cs);\r\nstat = cs->BC_Read_Reg(cs, HFC_DATA, HFC_CIP | HFC_F2_INC | HFC_REC |\r\nHFC_CHANNEL(bcs->channel));\r\nWaitForBusy(cs);\r\n}\r\n}\r\nreturn (skb);\r\n}\r\nstatic void\r\nhfc_fill_fifo(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint idx, fcnt;\r\nint count;\r\nint z1, z2;\r\nu_char cip;\r\nif (!bcs->tx_skb)\r\nreturn;\r\nif (bcs->tx_skb->len <= 0)\r\nreturn;\r\ncip = HFC_CIP | HFC_F1 | HFC_SEND | HFC_CHANNEL(bcs->channel);\r\nif ((cip & 0xc3) != (cs->hw.hfc.cip & 0xc3)) {\r\ncs->BC_Write_Reg(cs, HFC_STATUS, cip, cip);\r\nWaitForBusy(cs);\r\n}\r\nWaitNoBusy(cs);\r\nif (bcs->mode != L1_MODE_TRANS) {\r\nbcs->hw.hfc.f1 = cs->BC_Read_Reg(cs, HFC_DATA, cip);\r\ncip = HFC_CIP | HFC_F2 | HFC_SEND | HFC_CHANNEL(bcs->channel);\r\nWaitNoBusy(cs);\r\nbcs->hw.hfc.f2 = cs->BC_Read_Reg(cs, HFC_DATA, cip);\r\nbcs->hw.hfc.send[bcs->hw.hfc.f1] = ReadZReg(bcs, HFC_Z1 | HFC_SEND | HFC_CHANNEL(bcs->channel));\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc_fill_fifo %d f1(%d) f2(%d) z1(%x)",\r\nbcs->channel, bcs->hw.hfc.f1, bcs->hw.hfc.f2,\r\nbcs->hw.hfc.send[bcs->hw.hfc.f1]);\r\nfcnt = bcs->hw.hfc.f1 - bcs->hw.hfc.f2;\r\nif (fcnt < 0)\r\nfcnt += 32;\r\nif (fcnt > 30) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc_fill_fifo more as 30 frames");\r\nreturn;\r\n}\r\ncount = GetFreeFifoBytes(bcs);\r\n}\r\nelse {\r\nWaitForBusy(cs);\r\nz1 = ReadZReg(bcs, HFC_Z1 | HFC_REC | HFC_CHANNEL(bcs->channel));\r\nz2 = ReadZReg(bcs, HFC_Z2 | HFC_REC | HFC_CHANNEL(bcs->channel));\r\ncount = z1 - z2;\r\nif (count < 0)\r\ncount += cs->hw.hfc.fifosize;\r\n}\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc_fill_fifo %d count(%u/%d)",\r\nbcs->channel, bcs->tx_skb->len,\r\ncount);\r\nif (count < bcs->tx_skb->len) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc_fill_fifo no fifo mem");\r\nreturn;\r\n}\r\ncip = HFC_CIP | HFC_FIFO_IN | HFC_SEND | HFC_CHANNEL(bcs->channel);\r\nidx = 0;\r\nwhile ((idx < bcs->tx_skb->len) && WaitNoBusy(cs))\r\ncs->BC_Write_Reg(cs, HFC_DATA_NODEB, cip, bcs->tx_skb->data[idx++]);\r\nif (idx != bcs->tx_skb->len) {\r\ndebugl1(cs, "FIFO Send BUSY error");\r\nprintk(KERN_WARNING "HFC S FIFO channel %d BUSY Error\n", bcs->channel);\r\n} else {\r\ncount = bcs->tx_skb->len;\r\nbcs->tx_cnt -= count;\r\nif (PACKET_NOACK == bcs->tx_skb->pkt_type)\r\ncount = -1;\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\nif (bcs->mode != L1_MODE_TRANS) {\r\nWaitForBusy(cs);\r\nWaitNoBusy(cs);\r\ncs->BC_Read_Reg(cs, HFC_DATA, HFC_CIP | HFC_F1_INC | HFC_SEND | HFC_CHANNEL(bcs->channel));\r\n}\r\nif (test_bit(FLG_LLI_L1WAKEUP,&bcs->st->lli.flag) &&\r\n(count >= 0)) {\r\nu_long flags;\r\nspin_lock_irqsave(&bcs->aclock, flags);\r\nbcs->ackcnt += count;\r\nspin_unlock_irqrestore(&bcs->aclock, flags);\r\nschedule_event(bcs, B_ACKPENDING);\r\n}\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\n}\r\nreturn;\r\n}\r\nvoid\r\nmain_irq_hfc(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint z1, z2, rcnt;\r\nu_char f1, f2, cip;\r\nint receive, transmit, count = 5;\r\nstruct sk_buff *skb;\r\nBegin:\r\ncount--;\r\ncip = HFC_CIP | HFC_F1 | HFC_REC | HFC_CHANNEL(bcs->channel);\r\nif ((cip & 0xc3) != (cs->hw.hfc.cip & 0xc3)) {\r\ncs->BC_Write_Reg(cs, HFC_STATUS, cip, cip);\r\nWaitForBusy(cs);\r\n}\r\nWaitNoBusy(cs);\r\nreceive = 0;\r\nif (bcs->mode == L1_MODE_HDLC) {\r\nf1 = cs->BC_Read_Reg(cs, HFC_DATA, cip);\r\ncip = HFC_CIP | HFC_F2 | HFC_REC | HFC_CHANNEL(bcs->channel);\r\nWaitNoBusy(cs);\r\nf2 = cs->BC_Read_Reg(cs, HFC_DATA, cip);\r\nif (f1 != f2) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc rec %d f1(%d) f2(%d)",\r\nbcs->channel, f1, f2);\r\nreceive = 1;\r\n}\r\n}\r\nif (receive || (bcs->mode == L1_MODE_TRANS)) {\r\nWaitForBusy(cs);\r\nz1 = ReadZReg(bcs, HFC_Z1 | HFC_REC | HFC_CHANNEL(bcs->channel));\r\nz2 = ReadZReg(bcs, HFC_Z2 | HFC_REC | HFC_CHANNEL(bcs->channel));\r\nrcnt = z1 - z2;\r\nif (rcnt < 0)\r\nrcnt += cs->hw.hfc.fifosize;\r\nif ((bcs->mode == L1_MODE_HDLC) || (rcnt)) {\r\nrcnt++;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc rec %d z1(%x) z2(%x) cnt(%d)",\r\nbcs->channel, z1, z2, rcnt);\r\nif ((skb = hfc_empty_fifo(bcs, rcnt))) {\r\nskb_queue_tail(&bcs->rqueue, skb);\r\nschedule_event(bcs, B_RCVBUFREADY);\r\n}\r\n}\r\nreceive = 1;\r\n}\r\nif (bcs->tx_skb) {\r\ntransmit = 1;\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nhfc_fill_fifo(bcs);\r\nif (test_bit(BC_FLG_BUSY, &bcs->Flag))\r\ntransmit = 0;\r\n} else {\r\nif ((bcs->tx_skb = skb_dequeue(&bcs->squeue))) {\r\ntransmit = 1;\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nhfc_fill_fifo(bcs);\r\nif (test_bit(BC_FLG_BUSY, &bcs->Flag))\r\ntransmit = 0;\r\n} else {\r\ntransmit = 0;\r\nschedule_event(bcs, B_XMTBUFREADY);\r\n}\r\n}\r\nif ((receive || transmit) && count)\r\ngoto Begin;\r\nreturn;\r\n}\r\nstatic void\r\nmode_hfc(struct BCState *bcs, int mode, int bc)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "HFC 2BS0 mode %d bchan %d/%d",\r\nmode, bc, bcs->channel);\r\nbcs->mode = mode;\r\nbcs->channel = bc;\r\nswitch (mode) {\r\ncase (L1_MODE_NULL):\r\nif (bc) {\r\ncs->hw.hfc.ctmt &= ~1;\r\ncs->hw.hfc.isac_spcr &= ~0x03;\r\n}\r\nelse {\r\ncs->hw.hfc.ctmt &= ~2;\r\ncs->hw.hfc.isac_spcr &= ~0x0c;\r\n}\r\nbreak;\r\ncase (L1_MODE_TRANS):\r\ncs->hw.hfc.ctmt &= ~(1 << bc);\r\ncs->BC_Write_Reg(cs, HFC_STATUS, cs->hw.hfc.ctmt, cs->hw.hfc.ctmt);\r\nhfc_clear_fifo(bcs);\r\nif (bc) {\r\ncs->hw.hfc.ctmt |= 1;\r\ncs->hw.hfc.isac_spcr &= ~0x03;\r\ncs->hw.hfc.isac_spcr |= 0x02;\r\n} else {\r\ncs->hw.hfc.ctmt |= 2;\r\ncs->hw.hfc.isac_spcr &= ~0x0c;\r\ncs->hw.hfc.isac_spcr |= 0x08;\r\n}\r\nbreak;\r\ncase (L1_MODE_HDLC):\r\nif (bc) {\r\ncs->hw.hfc.ctmt &= ~1;\r\ncs->hw.hfc.isac_spcr &= ~0x03;\r\ncs->hw.hfc.isac_spcr |= 0x02;\r\n} else {\r\ncs->hw.hfc.ctmt &= ~2;\r\ncs->hw.hfc.isac_spcr &= ~0x0c;\r\ncs->hw.hfc.isac_spcr |= 0x08;\r\n}\r\nbreak;\r\n}\r\ncs->BC_Write_Reg(cs, HFC_STATUS, cs->hw.hfc.ctmt, cs->hw.hfc.ctmt);\r\ncs->writeisac(cs, ISAC_SPCR, cs->hw.hfc.isac_spcr);\r\nif (mode == L1_MODE_HDLC)\r\nhfc_clear_fifo(bcs);\r\n}\r\nstatic void\r\nhfc_l2l1(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct BCState *bcs = st->l1.bcs;\r\nstruct sk_buff *skb = arg;\r\nu_long flags;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nskb_queue_tail(&bcs->squeue, skb);\r\n} else {\r\nbcs->tx_skb = skb;\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nprintk(KERN_WARNING "hfc_l2l1: this shouldn't happen\n");\r\n} else {\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->tx_skb = skb;\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\nif (!bcs->tx_skb) {\r\ntest_and_clear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\ntest_and_set_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (PH_ACTIVATE | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_set_bit(BC_FLG_ACTIV, &bcs->Flag);\r\nmode_hfc(bcs, st->l1.mode, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | REQUEST):\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | CONFIRM):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_clear_bit(BC_FLG_ACTIV, &bcs->Flag);\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nmode_hfc(bcs, 0, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nst->l1.l1l2(st, PH_DEACTIVATE | CONFIRM, NULL);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nclose_hfcstate(struct BCState *bcs)\r\n{\r\nmode_hfc(bcs, 0, bcs->channel);\r\nif (test_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nskb_queue_purge(&bcs->rqueue);\r\nskb_queue_purge(&bcs->squeue);\r\nif (bcs->tx_skb) {\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\n}\r\n}\r\ntest_and_clear_bit(BC_FLG_INIT, &bcs->Flag);\r\n}\r\nstatic int\r\nopen_hfcstate(struct IsdnCardState *cs, struct BCState *bcs)\r\n{\r\nif (!test_and_set_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nskb_queue_head_init(&bcs->rqueue);\r\nskb_queue_head_init(&bcs->squeue);\r\n}\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->event = 0;\r\nbcs->tx_cnt = 0;\r\nreturn (0);\r\n}\r\nstatic int\r\nsetstack_hfc(struct PStack *st, struct BCState *bcs)\r\n{\r\nbcs->channel = st->l1.bc;\r\nif (open_hfcstate(st->l1.hardware, bcs))\r\nreturn (-1);\r\nst->l1.bcs = bcs;\r\nst->l2.l2l1 = hfc_l2l1;\r\nsetstack_manager(st);\r\nbcs->st = st;\r\nsetstack_l1_B(st);\r\nreturn (0);\r\n}\r\nstatic void\r\ninit_send(struct BCState *bcs)\r\n{\r\nint i;\r\nif (!(bcs->hw.hfc.send = kmalloc(32 * sizeof(unsigned int), GFP_ATOMIC))) {\r\nprintk(KERN_WARNING\r\n"HiSax: No memory for hfc.send\n");\r\nreturn;\r\n}\r\nfor (i = 0; i < 32; i++)\r\nbcs->hw.hfc.send[i] = 0x1fff;\r\n}\r\nvoid\r\ninithfc(struct IsdnCardState *cs)\r\n{\r\ninit_send(&cs->bcs[0]);\r\ninit_send(&cs->bcs[1]);\r\ncs->BC_Send_Data = &hfc_fill_fifo;\r\ncs->bcs[0].BC_SetStack = setstack_hfc;\r\ncs->bcs[1].BC_SetStack = setstack_hfc;\r\ncs->bcs[0].BC_Close = close_hfcstate;\r\ncs->bcs[1].BC_Close = close_hfcstate;\r\nmode_hfc(cs->bcs, 0, 0);\r\nmode_hfc(cs->bcs + 1, 0, 0);\r\n}\r\nvoid\r\nreleasehfc(struct IsdnCardState *cs)\r\n{\r\nkfree(cs->bcs[0].hw.hfc.send);\r\ncs->bcs[0].hw.hfc.send = NULL;\r\nkfree(cs->bcs[1].hw.hfc.send);\r\ncs->bcs[1].hw.hfc.send = NULL;\r\n}
