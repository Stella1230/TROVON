static bool\r\nhbh_mt6(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstruct ipv6_opt_hdr _optsh;\r\nconst struct ipv6_opt_hdr *oh;\r\nconst struct ip6t_opts *optinfo = par->matchinfo;\r\nunsigned int temp;\r\nunsigned int ptr;\r\nunsigned int hdrlen = 0;\r\nbool ret = false;\r\nu8 _opttype;\r\nu8 _optlen;\r\nconst u_int8_t *tp = NULL;\r\nconst u_int8_t *lp = NULL;\r\nunsigned int optlen;\r\nint err;\r\nerr = ipv6_find_hdr(skb, &ptr,\r\n(par->match == &hbh_mt6_reg[0]) ?\r\nNEXTHDR_HOP : NEXTHDR_DEST, NULL);\r\nif (err < 0) {\r\nif (err != -ENOENT)\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\noh = skb_header_pointer(skb, ptr, sizeof(_optsh), &_optsh);\r\nif (oh == NULL) {\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nhdrlen = ipv6_optlen(oh);\r\nif (skb->len - ptr < hdrlen) {\r\nreturn false;\r\n}\r\npr_debug("IPv6 OPTS LEN %u %u ", hdrlen, oh->hdrlen);\r\npr_debug("len %02X %04X %02X ",\r\noptinfo->hdrlen, hdrlen,\r\n(!(optinfo->flags & IP6T_OPTS_LEN) ||\r\n((optinfo->hdrlen == hdrlen) ^\r\n!!(optinfo->invflags & IP6T_OPTS_INV_LEN))));\r\nret = (oh != NULL) &&\r\n(!(optinfo->flags & IP6T_OPTS_LEN) ||\r\n((optinfo->hdrlen == hdrlen) ^\r\n!!(optinfo->invflags & IP6T_OPTS_INV_LEN)));\r\nptr += 2;\r\nhdrlen -= 2;\r\nif (!(optinfo->flags & IP6T_OPTS_OPTS)) {\r\nreturn ret;\r\n} else {\r\npr_debug("Strict ");\r\npr_debug("#%d ", optinfo->optsnr);\r\nfor (temp = 0; temp < optinfo->optsnr; temp++) {\r\nif (hdrlen < 1)\r\nbreak;\r\ntp = skb_header_pointer(skb, ptr, sizeof(_opttype),\r\n&_opttype);\r\nif (tp == NULL)\r\nbreak;\r\nif (*tp != (optinfo->opts[temp] & 0xFF00) >> 8) {\r\npr_debug("Tbad %02X %02X\n", *tp,\r\n(optinfo->opts[temp] & 0xFF00) >> 8);\r\nreturn false;\r\n} else {\r\npr_debug("Tok ");\r\n}\r\nif (*tp) {\r\nu16 spec_len;\r\nif (hdrlen < 2)\r\nbreak;\r\nlp = skb_header_pointer(skb, ptr + 1,\r\nsizeof(_optlen),\r\n&_optlen);\r\nif (lp == NULL)\r\nbreak;\r\nspec_len = optinfo->opts[temp] & 0x00FF;\r\nif (spec_len != 0x00FF && spec_len != *lp) {\r\npr_debug("Lbad %02X %04X\n", *lp,\r\nspec_len);\r\nreturn false;\r\n}\r\npr_debug("Lok ");\r\noptlen = *lp + 2;\r\n} else {\r\npr_debug("Pad1\n");\r\noptlen = 1;\r\n}\r\npr_debug("len%04X\n", optlen);\r\nif ((ptr > skb->len - optlen || hdrlen < optlen) &&\r\ntemp < optinfo->optsnr - 1) {\r\npr_debug("new pointer is too large!\n");\r\nbreak;\r\n}\r\nptr += optlen;\r\nhdrlen -= optlen;\r\n}\r\nif (temp == optinfo->optsnr)\r\nreturn ret;\r\nelse\r\nreturn false;\r\n}\r\nreturn false;\r\n}\r\nstatic int hbh_mt6_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct ip6t_opts *optsinfo = par->matchinfo;\r\nif (optsinfo->invflags & ~IP6T_OPTS_INV_MASK) {\r\npr_debug("unknown flags %X\n", optsinfo->invflags);\r\nreturn -EINVAL;\r\n}\r\nif (optsinfo->flags & IP6T_OPTS_NSTRICT) {\r\npr_debug("Not strict - not implemented");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init hbh_mt6_init(void)\r\n{\r\nreturn xt_register_matches(hbh_mt6_reg, ARRAY_SIZE(hbh_mt6_reg));\r\n}\r\nstatic void __exit hbh_mt6_exit(void)\r\n{\r\nxt_unregister_matches(hbh_mt6_reg, ARRAY_SIZE(hbh_mt6_reg));\r\n}
