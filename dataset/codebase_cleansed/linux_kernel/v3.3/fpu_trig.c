static int trig_arg(FPU_REG *st0_ptr, int even)\r\n{\r\nFPU_REG tmp;\r\nu_char tmptag;\r\nunsigned long long q;\r\nint old_cw = control_word, saved_status = partial_status;\r\nint tag, st0_tag = TAG_Valid;\r\nif (exponent(st0_ptr) >= 63) {\r\npartial_status |= SW_C2;\r\nreturn -1;\r\n}\r\ncontrol_word &= ~CW_RC;\r\ncontrol_word |= RC_CHOP;\r\nsetpositive(st0_ptr);\r\ntag = FPU_u_div(st0_ptr, &CONST_PI2, &tmp, PR_64_BITS | RC_CHOP | 0x3f,\r\nSIGN_POS);\r\nFPU_round_to_int(&tmp, tag);\r\nq = significand(&tmp);\r\nif (q) {\r\nrem_kernel(significand(st0_ptr),\r\n&significand(&tmp),\r\nsignificand(&CONST_PI2),\r\nq, exponent(st0_ptr) - exponent(&CONST_PI2));\r\nsetexponent16(&tmp, exponent(&CONST_PI2));\r\nst0_tag = FPU_normalize(&tmp);\r\nFPU_copy_to_reg0(&tmp, st0_tag);\r\n}\r\nif ((even && !(q & 1)) || (!even && (q & 1))) {\r\nst0_tag =\r\nFPU_sub(REV | LOADED | TAG_Valid, (int)&CONST_PI2,\r\nFULL_PRECISION);\r\n#ifdef BETTER_THAN_486\r\nif ((exponent(st0_ptr) <= exponent(&CONST_PI2extra) + 64)\r\n|| (q > 1)) {\r\nsignificand(&tmp) = q + 1;\r\nsetexponent16(&tmp, 63);\r\nFPU_normalize(&tmp);\r\ntmptag =\r\nFPU_u_mul(&CONST_PI2extra, &tmp, &tmp,\r\nFULL_PRECISION, SIGN_POS,\r\nexponent(&CONST_PI2extra) +\r\nexponent(&tmp));\r\nsetsign(&tmp, getsign(&CONST_PI2extra));\r\nst0_tag = FPU_add(&tmp, tmptag, 0, FULL_PRECISION);\r\nif (signnegative(st0_ptr)) {\r\nsetpositive(st0_ptr);\r\nq++;\r\n}\r\n}\r\n#endif\r\n}\r\n#ifdef BETTER_THAN_486\r\nelse {\r\nif (((q > 0)\r\n&& (exponent(st0_ptr) <= exponent(&CONST_PI2extra) + 64))\r\n|| (q > 1)) {\r\nsignificand(&tmp) = q;\r\nsetexponent16(&tmp, 63);\r\nFPU_normalize(&tmp);\r\ntmptag =\r\nFPU_u_mul(&CONST_PI2extra, &tmp, &tmp,\r\nFULL_PRECISION, SIGN_POS,\r\nexponent(&CONST_PI2extra) +\r\nexponent(&tmp));\r\nsetsign(&tmp, getsign(&CONST_PI2extra));\r\nst0_tag = FPU_sub(LOADED | (tmptag & 0x0f), (int)&tmp,\r\nFULL_PRECISION);\r\nif ((exponent(st0_ptr) == exponent(&CONST_PI2)) &&\r\n((st0_ptr->sigh > CONST_PI2.sigh)\r\n|| ((st0_ptr->sigh == CONST_PI2.sigh)\r\n&& (st0_ptr->sigl > CONST_PI2.sigl)))) {\r\nst0_tag =\r\nFPU_sub(REV | LOADED | TAG_Valid,\r\n(int)&CONST_PI2, FULL_PRECISION);\r\nq++;\r\n}\r\n}\r\n}\r\n#endif\r\nFPU_settag0(st0_tag);\r\ncontrol_word = old_cw;\r\npartial_status = saved_status & ~SW_C2;\r\nreturn (q & 3) | even;\r\n}\r\nstatic void convert_l2reg(long const *arg, int deststnr)\r\n{\r\nint tag;\r\nlong num = *arg;\r\nu_char sign;\r\nFPU_REG *dest = &st(deststnr);\r\nif (num == 0) {\r\nFPU_copy_to_regi(&CONST_Z, TAG_Zero, deststnr);\r\nreturn;\r\n}\r\nif (num > 0) {\r\nsign = SIGN_POS;\r\n} else {\r\nnum = -num;\r\nsign = SIGN_NEG;\r\n}\r\ndest->sigh = num;\r\ndest->sigl = 0;\r\nsetexponent16(dest, 31);\r\ntag = FPU_normalize(dest);\r\nFPU_settagi(deststnr, tag);\r\nsetsign(dest, sign);\r\nreturn;\r\n}\r\nstatic void single_arg_error(FPU_REG *st0_ptr, u_char st0_tag)\r\n{\r\nif (st0_tag == TAG_Empty)\r\nFPU_stack_underflow();\r\nelse if (st0_tag == TW_NaN)\r\nreal_1op_NaN(st0_ptr);\r\n#ifdef PARANOID\r\nelse\r\nEXCEPTION(EX_INTERNAL | 0x0112);\r\n#endif\r\n}\r\nstatic void single_arg_2_error(FPU_REG *st0_ptr, u_char st0_tag)\r\n{\r\nint isNaN;\r\nswitch (st0_tag) {\r\ncase TW_NaN:\r\nisNaN = (exponent(st0_ptr) == EXP_OVER)\r\n&& (st0_ptr->sigh & 0x80000000);\r\nif (isNaN && !(st0_ptr->sigh & 0x40000000)) {\r\nEXCEPTION(EX_Invalid);\r\nif (control_word & CW_Invalid) {\r\nst0_ptr->sigh |= 0x40000000;\r\npush();\r\nFPU_copy_to_reg0(st0_ptr, TAG_Special);\r\n}\r\n} else if (isNaN) {\r\npush();\r\nFPU_copy_to_reg0(st0_ptr, TAG_Special);\r\n} else {\r\nEXCEPTION(EX_Invalid);\r\nif (control_word & CW_Invalid) {\r\nFPU_copy_to_reg0(&CONST_QNaN, TAG_Special);\r\npush();\r\nFPU_copy_to_reg0(&CONST_QNaN, TAG_Special);\r\n}\r\n}\r\nbreak;\r\n#ifdef PARANOID\r\ndefault:\r\nEXCEPTION(EX_INTERNAL | 0x0112);\r\n#endif\r\n}\r\n}\r\nstatic void f2xm1(FPU_REG *st0_ptr, u_char tag)\r\n{\r\nFPU_REG a;\r\nclear_C1();\r\nif (tag == TAG_Valid) {\r\nif (exponent(st0_ptr) < 0) {\r\ndenormal_arg:\r\nFPU_to_exp16(st0_ptr, &a);\r\npoly_2xm1(getsign(st0_ptr), &a, st0_ptr);\r\n}\r\nset_precision_flag_up();\r\nreturn;\r\n}\r\nif (tag == TAG_Zero)\r\nreturn;\r\nif (tag == TAG_Special)\r\ntag = FPU_Special(st0_ptr);\r\nswitch (tag) {\r\ncase TW_Denormal:\r\nif (denormal_operand() < 0)\r\nreturn;\r\ngoto denormal_arg;\r\ncase TW_Infinity:\r\nif (signnegative(st0_ptr)) {\r\nFPU_copy_to_reg0(&CONST_1, TAG_Valid);\r\nsetnegative(st0_ptr);\r\n}\r\nreturn;\r\ndefault:\r\nsingle_arg_error(st0_ptr, tag);\r\n}\r\n}\r\nstatic void fptan(FPU_REG *st0_ptr, u_char st0_tag)\r\n{\r\nFPU_REG *st_new_ptr;\r\nint q;\r\nu_char arg_sign = getsign(st0_ptr);\r\nif (st0_tag == TAG_Empty) {\r\nFPU_stack_underflow();\r\nif (control_word & CW_Invalid) {\r\nst_new_ptr = &st(-1);\r\npush();\r\nFPU_stack_underflow();\r\n}\r\nreturn;\r\n}\r\nif (STACK_OVERFLOW) {\r\nFPU_stack_overflow();\r\nreturn;\r\n}\r\nif (st0_tag == TAG_Valid) {\r\nif (exponent(st0_ptr) > -40) {\r\nif ((q = trig_arg(st0_ptr, 0)) == -1) {\r\nreturn;\r\n}\r\npoly_tan(st0_ptr);\r\nsetsign(st0_ptr, (q & 1) ^ (arg_sign != 0));\r\nset_precision_flag_up();\r\n} else {\r\ndenormal_arg:\r\nFPU_to_exp16(st0_ptr, st0_ptr);\r\nst0_tag =\r\nFPU_round(st0_ptr, 1, 0, FULL_PRECISION, arg_sign);\r\nFPU_settag0(st0_tag);\r\n}\r\npush();\r\nFPU_copy_to_reg0(&CONST_1, TAG_Valid);\r\nreturn;\r\n}\r\nif (st0_tag == TAG_Zero) {\r\npush();\r\nFPU_copy_to_reg0(&CONST_1, TAG_Valid);\r\nsetcc(0);\r\nreturn;\r\n}\r\nif (st0_tag == TAG_Special)\r\nst0_tag = FPU_Special(st0_ptr);\r\nif (st0_tag == TW_Denormal) {\r\nif (denormal_operand() < 0)\r\nreturn;\r\ngoto denormal_arg;\r\n}\r\nif (st0_tag == TW_Infinity) {\r\nif (arith_invalid(0) >= 0) {\r\nst_new_ptr = &st(-1);\r\npush();\r\narith_invalid(0);\r\n}\r\nreturn;\r\n}\r\nsingle_arg_2_error(st0_ptr, st0_tag);\r\n}\r\nstatic void fxtract(FPU_REG *st0_ptr, u_char st0_tag)\r\n{\r\nFPU_REG *st_new_ptr;\r\nu_char sign;\r\nregister FPU_REG *st1_ptr = st0_ptr;\r\nif (STACK_OVERFLOW) {\r\nFPU_stack_overflow();\r\nreturn;\r\n}\r\nclear_C1();\r\nif (st0_tag == TAG_Valid) {\r\nlong e;\r\npush();\r\nsign = getsign(st1_ptr);\r\nreg_copy(st1_ptr, st_new_ptr);\r\nsetexponent16(st_new_ptr, exponent(st_new_ptr));\r\ndenormal_arg:\r\ne = exponent16(st_new_ptr);\r\nconvert_l2reg(&e, 1);\r\nsetexponentpos(st_new_ptr, 0);\r\nsetsign(st_new_ptr, sign);\r\nFPU_settag0(TAG_Valid);\r\nreturn;\r\n} else if (st0_tag == TAG_Zero) {\r\nsign = getsign(st0_ptr);\r\nif (FPU_divide_by_zero(0, SIGN_NEG) < 0)\r\nreturn;\r\npush();\r\nFPU_copy_to_reg0(&CONST_Z, TAG_Zero);\r\nsetsign(st_new_ptr, sign);\r\nreturn;\r\n}\r\nif (st0_tag == TAG_Special)\r\nst0_tag = FPU_Special(st0_ptr);\r\nif (st0_tag == TW_Denormal) {\r\nif (denormal_operand() < 0)\r\nreturn;\r\npush();\r\nsign = getsign(st1_ptr);\r\nFPU_to_exp16(st1_ptr, st_new_ptr);\r\ngoto denormal_arg;\r\n} else if (st0_tag == TW_Infinity) {\r\nsign = getsign(st0_ptr);\r\nsetpositive(st0_ptr);\r\npush();\r\nFPU_copy_to_reg0(&CONST_INF, TAG_Special);\r\nsetsign(st_new_ptr, sign);\r\nreturn;\r\n} else if (st0_tag == TW_NaN) {\r\nif (real_1op_NaN(st0_ptr) < 0)\r\nreturn;\r\npush();\r\nFPU_copy_to_reg0(st0_ptr, TAG_Special);\r\nreturn;\r\n} else if (st0_tag == TAG_Empty) {\r\nif (control_word & EX_Invalid) {\r\nFPU_stack_underflow();\r\npush();\r\nFPU_stack_underflow();\r\n} else\r\nEXCEPTION(EX_StackUnder);\r\n}\r\n#ifdef PARANOID\r\nelse\r\nEXCEPTION(EX_INTERNAL | 0x119);\r\n#endif\r\n}\r\nstatic void fdecstp(void)\r\n{\r\nclear_C1();\r\ntop--;\r\n}\r\nstatic void fincstp(void)\r\n{\r\nclear_C1();\r\ntop++;\r\n}\r\nstatic void fsqrt_(FPU_REG *st0_ptr, u_char st0_tag)\r\n{\r\nint expon;\r\nclear_C1();\r\nif (st0_tag == TAG_Valid) {\r\nu_char tag;\r\nif (signnegative(st0_ptr)) {\r\narith_invalid(0);\r\nreturn;\r\n}\r\nexpon = exponent(st0_ptr);\r\ndenormal_arg:\r\nsetexponent16(st0_ptr, (expon & 1));\r\ntag = wm_sqrt(st0_ptr, 0, 0, control_word, SIGN_POS);\r\naddexponent(st0_ptr, expon >> 1);\r\nFPU_settag0(tag);\r\nreturn;\r\n}\r\nif (st0_tag == TAG_Zero)\r\nreturn;\r\nif (st0_tag == TAG_Special)\r\nst0_tag = FPU_Special(st0_ptr);\r\nif (st0_tag == TW_Infinity) {\r\nif (signnegative(st0_ptr))\r\narith_invalid(0);\r\nreturn;\r\n} else if (st0_tag == TW_Denormal) {\r\nif (signnegative(st0_ptr)) {\r\narith_invalid(0);\r\nreturn;\r\n}\r\nif (denormal_operand() < 0)\r\nreturn;\r\nFPU_to_exp16(st0_ptr, st0_ptr);\r\nexpon = exponent16(st0_ptr);\r\ngoto denormal_arg;\r\n}\r\nsingle_arg_error(st0_ptr, st0_tag);\r\n}\r\nstatic void frndint_(FPU_REG *st0_ptr, u_char st0_tag)\r\n{\r\nint flags, tag;\r\nif (st0_tag == TAG_Valid) {\r\nu_char sign;\r\ndenormal_arg:\r\nsign = getsign(st0_ptr);\r\nif (exponent(st0_ptr) > 63)\r\nreturn;\r\nif (st0_tag == TW_Denormal) {\r\nif (denormal_operand() < 0)\r\nreturn;\r\n}\r\nif ((flags = FPU_round_to_int(st0_ptr, st0_tag)))\r\nset_precision_flag(flags);\r\nsetexponent16(st0_ptr, 63);\r\ntag = FPU_normalize(st0_ptr);\r\nsetsign(st0_ptr, sign);\r\nFPU_settag0(tag);\r\nreturn;\r\n}\r\nif (st0_tag == TAG_Zero)\r\nreturn;\r\nif (st0_tag == TAG_Special)\r\nst0_tag = FPU_Special(st0_ptr);\r\nif (st0_tag == TW_Denormal)\r\ngoto denormal_arg;\r\nelse if (st0_tag == TW_Infinity)\r\nreturn;\r\nelse\r\nsingle_arg_error(st0_ptr, st0_tag);\r\n}\r\nstatic int fsin(FPU_REG *st0_ptr, u_char tag)\r\n{\r\nu_char arg_sign = getsign(st0_ptr);\r\nif (tag == TAG_Valid) {\r\nint q;\r\nif (exponent(st0_ptr) > -40) {\r\nif ((q = trig_arg(st0_ptr, 0)) == -1) {\r\nreturn 1;\r\n}\r\npoly_sine(st0_ptr);\r\nif (q & 2)\r\nchangesign(st0_ptr);\r\nsetsign(st0_ptr, getsign(st0_ptr) ^ arg_sign);\r\nset_precision_flag_up();\r\nreturn 0;\r\n} else {\r\nset_precision_flag_up();\r\nreturn 0;\r\n}\r\n}\r\nif (tag == TAG_Zero) {\r\nsetcc(0);\r\nreturn 0;\r\n}\r\nif (tag == TAG_Special)\r\ntag = FPU_Special(st0_ptr);\r\nif (tag == TW_Denormal) {\r\nif (denormal_operand() < 0)\r\nreturn 1;\r\nFPU_to_exp16(st0_ptr, st0_ptr);\r\ntag = FPU_round(st0_ptr, 1, 0, FULL_PRECISION, arg_sign);\r\nFPU_settag0(tag);\r\nreturn 0;\r\n} else if (tag == TW_Infinity) {\r\narith_invalid(0);\r\nreturn 1;\r\n} else {\r\nsingle_arg_error(st0_ptr, tag);\r\nreturn 1;\r\n}\r\n}\r\nstatic int f_cos(FPU_REG *st0_ptr, u_char tag)\r\n{\r\nu_char st0_sign;\r\nst0_sign = getsign(st0_ptr);\r\nif (tag == TAG_Valid) {\r\nint q;\r\nif (exponent(st0_ptr) > -40) {\r\nif ((exponent(st0_ptr) < 0)\r\n|| ((exponent(st0_ptr) == 0)\r\n&& (significand(st0_ptr) <=\r\n0xc90fdaa22168c234LL))) {\r\npoly_cos(st0_ptr);\r\nset_precision_flag_down();\r\nreturn 0;\r\n} else if ((q = trig_arg(st0_ptr, FCOS)) != -1) {\r\npoly_sine(st0_ptr);\r\nif ((q + 1) & 2)\r\nchangesign(st0_ptr);\r\nset_precision_flag_down();\r\nreturn 0;\r\n} else {\r\nreturn 1;\r\n}\r\n} else {\r\ndenormal_arg:\r\nsetcc(0);\r\nFPU_copy_to_reg0(&CONST_1, TAG_Valid);\r\n#ifdef PECULIAR_486\r\nset_precision_flag_down();\r\n#else\r\nset_precision_flag_up();\r\n#endif\r\nreturn 0;\r\n}\r\n} else if (tag == TAG_Zero) {\r\nFPU_copy_to_reg0(&CONST_1, TAG_Valid);\r\nsetcc(0);\r\nreturn 0;\r\n}\r\nif (tag == TAG_Special)\r\ntag = FPU_Special(st0_ptr);\r\nif (tag == TW_Denormal) {\r\nif (denormal_operand() < 0)\r\nreturn 1;\r\ngoto denormal_arg;\r\n} else if (tag == TW_Infinity) {\r\narith_invalid(0);\r\nreturn 1;\r\n} else {\r\nsingle_arg_error(st0_ptr, tag);\r\nreturn 1;\r\n}\r\n}\r\nstatic void fcos(FPU_REG *st0_ptr, u_char st0_tag)\r\n{\r\nf_cos(st0_ptr, st0_tag);\r\n}\r\nstatic void fsincos(FPU_REG *st0_ptr, u_char st0_tag)\r\n{\r\nFPU_REG *st_new_ptr;\r\nFPU_REG arg;\r\nu_char tag;\r\nif (st0_tag == TAG_Empty) {\r\nFPU_stack_underflow();\r\nif (control_word & CW_Invalid) {\r\nst_new_ptr = &st(-1);\r\npush();\r\nFPU_stack_underflow();\r\n}\r\nreturn;\r\n}\r\nif (STACK_OVERFLOW) {\r\nFPU_stack_overflow();\r\nreturn;\r\n}\r\nif (st0_tag == TAG_Special)\r\ntag = FPU_Special(st0_ptr);\r\nelse\r\ntag = st0_tag;\r\nif (tag == TW_NaN) {\r\nsingle_arg_2_error(st0_ptr, TW_NaN);\r\nreturn;\r\n} else if (tag == TW_Infinity) {\r\nif (arith_invalid(0) >= 0) {\r\npush();\r\narith_invalid(0);\r\n}\r\nreturn;\r\n}\r\nreg_copy(st0_ptr, &arg);\r\nif (!fsin(st0_ptr, st0_tag)) {\r\npush();\r\nFPU_copy_to_reg0(&arg, st0_tag);\r\nf_cos(&st(0), st0_tag);\r\n} else {\r\nFPU_copy_to_reg0(&arg, st0_tag);\r\n}\r\n}\r\nstatic void rem_kernel(unsigned long long st0, unsigned long long *y,\r\nunsigned long long st1, unsigned long long q, int n)\r\n{\r\nint dummy;\r\nunsigned long long x;\r\nx = st0 << n;\r\nasm volatile ("mull %4; subl %%eax,%0; sbbl %%edx,%1":"=m"\r\n(((unsigned *)&x)[0]), "=m"(((unsigned *)&x)[1]),\r\n"=a"(dummy)\r\n:"2"(((unsigned *)&st1)[0]), "m"(((unsigned *)&q)[0])\r\n:"%dx");\r\nasm volatile ("mull %3; subl %%eax,%0":"=m" (((unsigned *)&x)[1]),\r\n"=a"(dummy)\r\n:"1"(((unsigned *)&st1)[1]), "m"(((unsigned *)&q)[0])\r\n:"%dx");\r\nasm volatile ("mull %3; subl %%eax,%0":"=m" (((unsigned *)&x)[1]),\r\n"=a"(dummy)\r\n:"1"(((unsigned *)&st1)[0]), "m"(((unsigned *)&q)[1])\r\n:"%dx");\r\n*y = x;\r\n}\r\nstatic void do_fprem(FPU_REG *st0_ptr, u_char st0_tag, int round)\r\n{\r\nFPU_REG *st1_ptr = &st(1);\r\nu_char st1_tag = FPU_gettagi(1);\r\nif (!((st0_tag ^ TAG_Valid) | (st1_tag ^ TAG_Valid))) {\r\nFPU_REG tmp, st0, st1;\r\nu_char st0_sign, st1_sign;\r\nu_char tmptag;\r\nint tag;\r\nint old_cw;\r\nint expdif;\r\nlong long q;\r\nunsigned short saved_status;\r\nint cc;\r\nfprem_valid:\r\nst0_sign = FPU_to_exp16(st0_ptr, &st0);\r\nst1_sign = FPU_to_exp16(st1_ptr, &st1);\r\nexpdif = exponent16(&st0) - exponent16(&st1);\r\nold_cw = control_word;\r\ncc = 0;\r\nsaved_status = partial_status;\r\ncontrol_word &= ~CW_RC;\r\ncontrol_word |= RC_CHOP;\r\nif (expdif < 64) {\r\nif (expdif > -2) {\r\nu_char sign = st0_sign ^ st1_sign;\r\ntag = FPU_u_div(&st0, &st1, &tmp,\r\nPR_64_BITS | RC_CHOP | 0x3f,\r\nsign);\r\nsetsign(&tmp, sign);\r\nif (exponent(&tmp) >= 0) {\r\nFPU_round_to_int(&tmp, tag);\r\nq = significand(&tmp);\r\nrem_kernel(significand(&st0),\r\n&significand(&tmp),\r\nsignificand(&st1),\r\nq, expdif);\r\nsetexponent16(&tmp, exponent16(&st1));\r\n} else {\r\nreg_copy(&st0, &tmp);\r\nq = 0;\r\n}\r\nif ((round == RC_RND)\r\n&& (tmp.sigh & 0xc0000000)) {\r\nunsigned long long x;\r\nexpdif =\r\nexponent16(&st1) - exponent16(&tmp);\r\nif (expdif <= 1) {\r\nif (expdif == 0)\r\nx = significand(&st1) -\r\nsignificand(&tmp);\r\nelse\r\nx = (significand(&st1)\r\n<< 1) -\r\nsignificand(&tmp);\r\nif ((x < significand(&tmp)) ||\r\n((x == significand(&tmp))\r\n&& (q & 1))) {\r\nst0_sign = !st0_sign;\r\nsignificand(&tmp) = x;\r\nq++;\r\n}\r\n}\r\n}\r\nif (q & 4)\r\ncc |= SW_C0;\r\nif (q & 2)\r\ncc |= SW_C3;\r\nif (q & 1)\r\ncc |= SW_C1;\r\n} else {\r\ncontrol_word = old_cw;\r\nsetcc(0);\r\nreturn;\r\n}\r\n} else {\r\nint exp_1, N;\r\nu_char sign;\r\nreg_copy(&st0, &tmp);\r\ntmptag = st0_tag;\r\nN = (expdif & 0x0000001f) + 32;\r\nsetexponent16(&tmp, N);\r\nexp_1 = exponent16(&st1);\r\nsetexponent16(&st1, 0);\r\nexpdif -= N;\r\nsign = getsign(&tmp) ^ st1_sign;\r\ntag =\r\nFPU_u_div(&tmp, &st1, &tmp,\r\nPR_64_BITS | RC_CHOP | 0x3f, sign);\r\nsetsign(&tmp, sign);\r\nFPU_round_to_int(&tmp, tag);\r\nrem_kernel(significand(&st0),\r\n&significand(&tmp),\r\nsignificand(&st1),\r\nsignificand(&tmp), exponent(&tmp)\r\n);\r\nsetexponent16(&tmp, exp_1 + expdif);\r\nif (!(tmp.sigh | tmp.sigl)) {\r\ncontrol_word = old_cw;\r\npartial_status = saved_status;\r\nFPU_copy_to_reg0(&CONST_Z, TAG_Zero);\r\nsetsign(&st0, st0_sign);\r\n#ifdef PECULIAR_486\r\nsetcc(SW_C2);\r\n#else\r\nsetcc(0);\r\n#endif\r\nreturn;\r\n}\r\ncc = SW_C2;\r\n}\r\ncontrol_word = old_cw;\r\npartial_status = saved_status;\r\ntag = FPU_normalize_nuo(&tmp);\r\nreg_copy(&tmp, st0_ptr);\r\nif ((exponent16(&tmp) <= EXP_UNDER) && (tag != TAG_Zero)\r\n&& !(control_word & CW_Underflow)) {\r\nsetcc(cc);\r\ntag = arith_underflow(st0_ptr);\r\nsetsign(st0_ptr, st0_sign);\r\nFPU_settag0(tag);\r\nreturn;\r\n} else if ((exponent16(&tmp) > EXP_UNDER) || (tag == TAG_Zero)) {\r\nstdexp(st0_ptr);\r\nsetsign(st0_ptr, st0_sign);\r\n} else {\r\ntag =\r\nFPU_round(st0_ptr, 0, 0, FULL_PRECISION, st0_sign);\r\n}\r\nFPU_settag0(tag);\r\nsetcc(cc);\r\nreturn;\r\n}\r\nif (st0_tag == TAG_Special)\r\nst0_tag = FPU_Special(st0_ptr);\r\nif (st1_tag == TAG_Special)\r\nst1_tag = FPU_Special(st1_ptr);\r\nif (((st0_tag == TAG_Valid) && (st1_tag == TW_Denormal))\r\n|| ((st0_tag == TW_Denormal) && (st1_tag == TAG_Valid))\r\n|| ((st0_tag == TW_Denormal) && (st1_tag == TW_Denormal))) {\r\nif (denormal_operand() < 0)\r\nreturn;\r\ngoto fprem_valid;\r\n} else if ((st0_tag == TAG_Empty) || (st1_tag == TAG_Empty)) {\r\nFPU_stack_underflow();\r\nreturn;\r\n} else if (st0_tag == TAG_Zero) {\r\nif (st1_tag == TAG_Valid) {\r\nsetcc(0);\r\nreturn;\r\n} else if (st1_tag == TW_Denormal) {\r\nif (denormal_operand() < 0)\r\nreturn;\r\nsetcc(0);\r\nreturn;\r\n} else if (st1_tag == TAG_Zero) {\r\narith_invalid(0);\r\nreturn;\r\n}\r\nelse if (st1_tag == TW_Infinity) {\r\nsetcc(0);\r\nreturn;\r\n}\r\n} else if ((st0_tag == TAG_Valid) || (st0_tag == TW_Denormal)) {\r\nif (st1_tag == TAG_Zero) {\r\narith_invalid(0);\r\nreturn;\r\n} else if (st1_tag != TW_NaN) {\r\nif (((st0_tag == TW_Denormal)\r\n|| (st1_tag == TW_Denormal))\r\n&& (denormal_operand() < 0))\r\nreturn;\r\nif (st1_tag == TW_Infinity) {\r\nsetcc(0);\r\nreturn;\r\n}\r\n}\r\n} else if (st0_tag == TW_Infinity) {\r\nif (st1_tag != TW_NaN) {\r\narith_invalid(0);\r\nreturn;\r\n}\r\n}\r\n#ifdef PARANOID\r\nif ((st0_tag != TW_NaN) && (st1_tag != TW_NaN))\r\nEXCEPTION(EX_INTERNAL | 0x118);\r\n#endif\r\nreal_2op_NaN(st1_ptr, st1_tag, 0, st1_ptr);\r\n}\r\nstatic void fyl2x(FPU_REG *st0_ptr, u_char st0_tag)\r\n{\r\nFPU_REG *st1_ptr = &st(1), exponent;\r\nu_char st1_tag = FPU_gettagi(1);\r\nu_char sign;\r\nint e, tag;\r\nclear_C1();\r\nif ((st0_tag == TAG_Valid) && (st1_tag == TAG_Valid)) {\r\nboth_valid:\r\nif (signpositive(st0_ptr)) {\r\nif (st0_tag == TW_Denormal)\r\nFPU_to_exp16(st0_ptr, st0_ptr);\r\nelse\r\nsetexponent16(st0_ptr, exponent(st0_ptr));\r\nif ((st0_ptr->sigh == 0x80000000)\r\n&& (st0_ptr->sigl == 0)) {\r\nu_char esign;\r\ne = exponent16(st0_ptr);\r\nif (e >= 0) {\r\nexponent.sigh = e;\r\nesign = SIGN_POS;\r\n} else {\r\nexponent.sigh = -e;\r\nesign = SIGN_NEG;\r\n}\r\nexponent.sigl = 0;\r\nsetexponent16(&exponent, 31);\r\ntag = FPU_normalize_nuo(&exponent);\r\nstdexp(&exponent);\r\nsetsign(&exponent, esign);\r\ntag =\r\nFPU_mul(&exponent, tag, 1, FULL_PRECISION);\r\nif (tag >= 0)\r\nFPU_settagi(1, tag);\r\n} else {\r\nsign = getsign(st1_ptr);\r\nif (st1_tag == TW_Denormal)\r\nFPU_to_exp16(st1_ptr, st1_ptr);\r\nelse\r\nsetexponent16(st1_ptr,\r\nexponent(st1_ptr));\r\npoly_l2(st0_ptr, st1_ptr, sign);\r\n}\r\n} else {\r\nif (arith_invalid(1) < 0)\r\nreturn;\r\n}\r\nFPU_pop();\r\nreturn;\r\n}\r\nif (st0_tag == TAG_Special)\r\nst0_tag = FPU_Special(st0_ptr);\r\nif (st1_tag == TAG_Special)\r\nst1_tag = FPU_Special(st1_ptr);\r\nif ((st0_tag == TAG_Empty) || (st1_tag == TAG_Empty)) {\r\nFPU_stack_underflow_pop(1);\r\nreturn;\r\n} else if ((st0_tag <= TW_Denormal) && (st1_tag <= TW_Denormal)) {\r\nif (st0_tag == TAG_Zero) {\r\nif (st1_tag == TAG_Zero) {\r\nif (arith_invalid(1) < 0)\r\nreturn;\r\n} else {\r\nu_char sign;\r\nsign = getsign(st1_ptr) ^ SIGN_NEG;\r\nif (FPU_divide_by_zero(1, sign) < 0)\r\nreturn;\r\nsetsign(st1_ptr, sign);\r\n}\r\n} else if (st1_tag == TAG_Zero) {\r\nsign = getsign(st1_ptr);\r\nif (signnegative(st0_ptr)) {\r\nif (arith_invalid(1) < 0)\r\nreturn;\r\n} else if ((st0_tag == TW_Denormal)\r\n&& (denormal_operand() < 0))\r\nreturn;\r\nelse {\r\nif (exponent(st0_ptr) < 0)\r\nsign ^= SIGN_NEG;\r\nFPU_copy_to_reg1(&CONST_Z, TAG_Zero);\r\nsetsign(st1_ptr, sign);\r\n}\r\n} else {\r\nif (denormal_operand() < 0)\r\nreturn;\r\ngoto both_valid;\r\n}\r\n} else if ((st0_tag == TW_NaN) || (st1_tag == TW_NaN)) {\r\nif (real_2op_NaN(st0_ptr, st0_tag, 1, st0_ptr) < 0)\r\nreturn;\r\n}\r\nelse if (st0_tag == TW_Infinity) {\r\nif ((signnegative(st0_ptr)) || (st1_tag == TAG_Zero)) {\r\nif (arith_invalid(1) < 0)\r\nreturn;\r\n} else {\r\nu_char sign = getsign(st1_ptr);\r\nif ((st1_tag == TW_Denormal)\r\n&& (denormal_operand() < 0))\r\nreturn;\r\nFPU_copy_to_reg1(&CONST_INF, TAG_Special);\r\nsetsign(st1_ptr, sign);\r\n}\r\n}\r\nelse if (((st0_tag == TAG_Valid) || (st0_tag == TW_Denormal))\r\n&& (signpositive(st0_ptr))) {\r\nif (exponent(st0_ptr) >= 0) {\r\nif ((exponent(st0_ptr) == 0) &&\r\n(st0_ptr->sigh == 0x80000000) &&\r\n(st0_ptr->sigl == 0)) {\r\nif (arith_invalid(1) < 0)\r\nreturn;\r\n}\r\n} else {\r\nif ((st0_tag == TW_Denormal)\r\n&& (denormal_operand() < 0))\r\nreturn;\r\nchangesign(st1_ptr);\r\n}\r\n} else {\r\nif (st0_tag == TAG_Zero) {\r\n#ifndef PECULIAR_486\r\nsign = getsign(st1_ptr);\r\nif (FPU_divide_by_zero(1, sign) < 0)\r\nreturn;\r\n#endif\r\nchangesign(st1_ptr);\r\n} else if (arith_invalid(1) < 0)\r\nreturn;\r\n}\r\nFPU_pop();\r\n}\r\nstatic void fpatan(FPU_REG *st0_ptr, u_char st0_tag)\r\n{\r\nFPU_REG *st1_ptr = &st(1);\r\nu_char st1_tag = FPU_gettagi(1);\r\nint tag;\r\nclear_C1();\r\nif (!((st0_tag ^ TAG_Valid) | (st1_tag ^ TAG_Valid))) {\r\nvalid_atan:\r\npoly_atan(st0_ptr, st0_tag, st1_ptr, st1_tag);\r\nFPU_pop();\r\nreturn;\r\n}\r\nif (st0_tag == TAG_Special)\r\nst0_tag = FPU_Special(st0_ptr);\r\nif (st1_tag == TAG_Special)\r\nst1_tag = FPU_Special(st1_ptr);\r\nif (((st0_tag == TAG_Valid) && (st1_tag == TW_Denormal))\r\n|| ((st0_tag == TW_Denormal) && (st1_tag == TAG_Valid))\r\n|| ((st0_tag == TW_Denormal) && (st1_tag == TW_Denormal))) {\r\nif (denormal_operand() < 0)\r\nreturn;\r\ngoto valid_atan;\r\n} else if ((st0_tag == TAG_Empty) || (st1_tag == TAG_Empty)) {\r\nFPU_stack_underflow_pop(1);\r\nreturn;\r\n} else if ((st0_tag == TW_NaN) || (st1_tag == TW_NaN)) {\r\nif (real_2op_NaN(st0_ptr, st0_tag, 1, st0_ptr) >= 0)\r\nFPU_pop();\r\nreturn;\r\n} else if ((st0_tag == TW_Infinity) || (st1_tag == TW_Infinity)) {\r\nu_char sign = getsign(st1_ptr);\r\nif (st0_tag == TW_Infinity) {\r\nif (st1_tag == TW_Infinity) {\r\nif (signpositive(st0_ptr)) {\r\nFPU_copy_to_reg1(&CONST_PI4, TAG_Valid);\r\n} else {\r\nsetpositive(st1_ptr);\r\ntag =\r\nFPU_u_add(&CONST_PI4, &CONST_PI2,\r\nst1_ptr, FULL_PRECISION,\r\nSIGN_POS,\r\nexponent(&CONST_PI4),\r\nexponent(&CONST_PI2));\r\nif (tag >= 0)\r\nFPU_settagi(1, tag);\r\n}\r\n} else {\r\nif ((st1_tag == TW_Denormal)\r\n&& (denormal_operand() < 0))\r\nreturn;\r\nif (signpositive(st0_ptr)) {\r\nFPU_copy_to_reg1(&CONST_Z, TAG_Zero);\r\nsetsign(st1_ptr, sign);\r\nFPU_pop();\r\nreturn;\r\n} else {\r\nFPU_copy_to_reg1(&CONST_PI, TAG_Valid);\r\n}\r\n}\r\n} else {\r\nif ((st0_tag == TW_Denormal)\r\n&& (denormal_operand() < 0))\r\nreturn;\r\nFPU_copy_to_reg1(&CONST_PI2, TAG_Valid);\r\n}\r\nsetsign(st1_ptr, sign);\r\n} else if (st1_tag == TAG_Zero) {\r\nu_char sign = getsign(st1_ptr);\r\nif ((st0_tag == TW_Denormal) && (denormal_operand() < 0))\r\nreturn;\r\nif (signpositive(st0_ptr)) {\r\nFPU_pop();\r\nreturn;\r\n}\r\nFPU_copy_to_reg1(&CONST_PI, TAG_Valid);\r\nsetsign(st1_ptr, sign);\r\n} else if (st0_tag == TAG_Zero) {\r\nu_char sign = getsign(st1_ptr);\r\nif ((st1_tag == TW_Denormal) && (denormal_operand() < 0))\r\nreturn;\r\nFPU_copy_to_reg1(&CONST_PI2, TAG_Valid);\r\nsetsign(st1_ptr, sign);\r\n}\r\n#ifdef PARANOID\r\nelse\r\nEXCEPTION(EX_INTERNAL | 0x125);\r\n#endif\r\nFPU_pop();\r\nset_precision_flag_up();\r\n}\r\nstatic void fprem(FPU_REG *st0_ptr, u_char st0_tag)\r\n{\r\ndo_fprem(st0_ptr, st0_tag, RC_CHOP);\r\n}\r\nstatic void fprem1(FPU_REG *st0_ptr, u_char st0_tag)\r\n{\r\ndo_fprem(st0_ptr, st0_tag, RC_RND);\r\n}\r\nstatic void fyl2xp1(FPU_REG *st0_ptr, u_char st0_tag)\r\n{\r\nu_char sign, sign1;\r\nFPU_REG *st1_ptr = &st(1), a, b;\r\nu_char st1_tag = FPU_gettagi(1);\r\nclear_C1();\r\nif (!((st0_tag ^ TAG_Valid) | (st1_tag ^ TAG_Valid))) {\r\nvalid_yl2xp1:\r\nsign = getsign(st0_ptr);\r\nsign1 = getsign(st1_ptr);\r\nFPU_to_exp16(st0_ptr, &a);\r\nFPU_to_exp16(st1_ptr, &b);\r\nif (poly_l2p1(sign, sign1, &a, &b, st1_ptr))\r\nreturn;\r\nFPU_pop();\r\nreturn;\r\n}\r\nif (st0_tag == TAG_Special)\r\nst0_tag = FPU_Special(st0_ptr);\r\nif (st1_tag == TAG_Special)\r\nst1_tag = FPU_Special(st1_ptr);\r\nif (((st0_tag == TAG_Valid) && (st1_tag == TW_Denormal))\r\n|| ((st0_tag == TW_Denormal) && (st1_tag == TAG_Valid))\r\n|| ((st0_tag == TW_Denormal) && (st1_tag == TW_Denormal))) {\r\nif (denormal_operand() < 0)\r\nreturn;\r\ngoto valid_yl2xp1;\r\n} else if ((st0_tag == TAG_Empty) | (st1_tag == TAG_Empty)) {\r\nFPU_stack_underflow_pop(1);\r\nreturn;\r\n} else if (st0_tag == TAG_Zero) {\r\nswitch (st1_tag) {\r\ncase TW_Denormal:\r\nif (denormal_operand() < 0)\r\nreturn;\r\ncase TAG_Zero:\r\ncase TAG_Valid:\r\nsetsign(st0_ptr, getsign(st0_ptr) ^ getsign(st1_ptr));\r\nFPU_copy_to_reg1(st0_ptr, st0_tag);\r\nbreak;\r\ncase TW_Infinity:\r\nif (arith_invalid(1) < 0)\r\nreturn;\r\nbreak;\r\ncase TW_NaN:\r\nif (real_2op_NaN(st0_ptr, st0_tag, 1, st0_ptr) < 0)\r\nreturn;\r\nbreak;\r\ndefault:\r\n#ifdef PARANOID\r\nEXCEPTION(EX_INTERNAL | 0x116);\r\nreturn;\r\n#endif\r\nbreak;\r\n}\r\n} else if ((st0_tag == TAG_Valid) || (st0_tag == TW_Denormal)) {\r\nswitch (st1_tag) {\r\ncase TAG_Zero:\r\nif (signnegative(st0_ptr)) {\r\nif (exponent(st0_ptr) >= 0) {\r\n#ifdef PECULIAR_486\r\nchangesign(st1_ptr);\r\n#else\r\nif (arith_invalid(1) < 0)\r\nreturn;\r\n#endif\r\n} else if ((st0_tag == TW_Denormal)\r\n&& (denormal_operand() < 0))\r\nreturn;\r\nelse\r\nchangesign(st1_ptr);\r\n} else if ((st0_tag == TW_Denormal)\r\n&& (denormal_operand() < 0))\r\nreturn;\r\nbreak;\r\ncase TW_Infinity:\r\nif (signnegative(st0_ptr)) {\r\nif ((exponent(st0_ptr) >= 0) &&\r\n!((st0_ptr->sigh == 0x80000000) &&\r\n(st0_ptr->sigl == 0))) {\r\n#ifdef PECULIAR_486\r\nchangesign(st1_ptr);\r\n#else\r\nif (arith_invalid(1) < 0)\r\nreturn;\r\n#endif\r\n} else if ((st0_tag == TW_Denormal)\r\n&& (denormal_operand() < 0))\r\nreturn;\r\nelse\r\nchangesign(st1_ptr);\r\n} else if ((st0_tag == TW_Denormal)\r\n&& (denormal_operand() < 0))\r\nreturn;\r\nbreak;\r\ncase TW_NaN:\r\nif (real_2op_NaN(st0_ptr, st0_tag, 1, st0_ptr) < 0)\r\nreturn;\r\n}\r\n} else if (st0_tag == TW_NaN) {\r\nif (real_2op_NaN(st0_ptr, st0_tag, 1, st0_ptr) < 0)\r\nreturn;\r\n} else if (st0_tag == TW_Infinity) {\r\nif (st1_tag == TW_NaN) {\r\nif (real_2op_NaN(st0_ptr, st0_tag, 1, st0_ptr) < 0)\r\nreturn;\r\n} else if (signnegative(st0_ptr)) {\r\n#ifndef PECULIAR_486\r\nif (arith_invalid(1) < 0)\r\nreturn;\r\n#endif\r\nif ((st1_tag == TW_Denormal)\r\n&& (denormal_operand() < 0))\r\nreturn;\r\n#ifdef PECULIAR_486\r\nif (arith_invalid(1) < 0)\r\nreturn;\r\n#endif\r\n} else if (st1_tag == TAG_Zero) {\r\nif (arith_invalid(1) < 0)\r\nreturn;\r\n}\r\nelse if ((st1_tag == TW_Denormal) && (denormal_operand() < 0))\r\nreturn;\r\nelse {\r\nu_char sign = getsign(st1_ptr);\r\nFPU_copy_to_reg1(&CONST_INF, TAG_Special);\r\nsetsign(st1_ptr, sign);\r\n}\r\n}\r\n#ifdef PARANOID\r\nelse {\r\nEXCEPTION(EX_INTERNAL | 0x117);\r\nreturn;\r\n}\r\n#endif\r\nFPU_pop();\r\nreturn;\r\n}\r\nstatic void fscale(FPU_REG *st0_ptr, u_char st0_tag)\r\n{\r\nFPU_REG *st1_ptr = &st(1);\r\nu_char st1_tag = FPU_gettagi(1);\r\nint old_cw = control_word;\r\nu_char sign = getsign(st0_ptr);\r\nclear_C1();\r\nif (!((st0_tag ^ TAG_Valid) | (st1_tag ^ TAG_Valid))) {\r\nlong scale;\r\nFPU_REG tmp;\r\nsetexponent16(st0_ptr, exponent(st0_ptr));\r\nvalid_scale:\r\nif (exponent(st1_ptr) > 30) {\r\nif (signpositive(st1_ptr)) {\r\nEXCEPTION(EX_Overflow);\r\nFPU_copy_to_reg0(&CONST_INF, TAG_Special);\r\n} else {\r\nEXCEPTION(EX_Underflow);\r\nFPU_copy_to_reg0(&CONST_Z, TAG_Zero);\r\n}\r\nsetsign(st0_ptr, sign);\r\nreturn;\r\n}\r\ncontrol_word &= ~CW_RC;\r\ncontrol_word |= RC_CHOP;\r\nreg_copy(st1_ptr, &tmp);\r\nFPU_round_to_int(&tmp, st1_tag);\r\ncontrol_word = old_cw;\r\nscale = signnegative(st1_ptr) ? -tmp.sigl : tmp.sigl;\r\nscale += exponent16(st0_ptr);\r\nsetexponent16(st0_ptr, scale);\r\nFPU_round(st0_ptr, 0, 0, control_word, sign);\r\nreturn;\r\n}\r\nif (st0_tag == TAG_Special)\r\nst0_tag = FPU_Special(st0_ptr);\r\nif (st1_tag == TAG_Special)\r\nst1_tag = FPU_Special(st1_ptr);\r\nif ((st0_tag == TAG_Valid) || (st0_tag == TW_Denormal)) {\r\nswitch (st1_tag) {\r\ncase TAG_Valid:\r\nif ((st0_tag == TW_Denormal)\r\n&& (denormal_operand() < 0))\r\nreturn;\r\nFPU_to_exp16(st0_ptr, st0_ptr);\r\ngoto valid_scale;\r\ncase TAG_Zero:\r\nif (st0_tag == TW_Denormal)\r\ndenormal_operand();\r\nreturn;\r\ncase TW_Denormal:\r\ndenormal_operand();\r\nreturn;\r\ncase TW_Infinity:\r\nif ((st0_tag == TW_Denormal)\r\n&& (denormal_operand() < 0))\r\nreturn;\r\nif (signpositive(st1_ptr))\r\nFPU_copy_to_reg0(&CONST_INF, TAG_Special);\r\nelse\r\nFPU_copy_to_reg0(&CONST_Z, TAG_Zero);\r\nsetsign(st0_ptr, sign);\r\nreturn;\r\ncase TW_NaN:\r\nreal_2op_NaN(st1_ptr, st1_tag, 0, st0_ptr);\r\nreturn;\r\n}\r\n} else if (st0_tag == TAG_Zero) {\r\nswitch (st1_tag) {\r\ncase TAG_Valid:\r\ncase TAG_Zero:\r\nreturn;\r\ncase TW_Denormal:\r\ndenormal_operand();\r\nreturn;\r\ncase TW_Infinity:\r\nif (signpositive(st1_ptr))\r\narith_invalid(0);\r\nreturn;\r\ncase TW_NaN:\r\nreal_2op_NaN(st1_ptr, st1_tag, 0, st0_ptr);\r\nreturn;\r\n}\r\n} else if (st0_tag == TW_Infinity) {\r\nswitch (st1_tag) {\r\ncase TAG_Valid:\r\ncase TAG_Zero:\r\nreturn;\r\ncase TW_Denormal:\r\ndenormal_operand();\r\nreturn;\r\ncase TW_Infinity:\r\nif (signnegative(st1_ptr))\r\narith_invalid(0);\r\nreturn;\r\ncase TW_NaN:\r\nreal_2op_NaN(st1_ptr, st1_tag, 0, st0_ptr);\r\nreturn;\r\n}\r\n} else if (st0_tag == TW_NaN) {\r\nif (st1_tag != TAG_Empty) {\r\nreal_2op_NaN(st1_ptr, st1_tag, 0, st0_ptr);\r\nreturn;\r\n}\r\n}\r\n#ifdef PARANOID\r\nif (!((st0_tag == TAG_Empty) || (st1_tag == TAG_Empty))) {\r\nEXCEPTION(EX_INTERNAL | 0x115);\r\nreturn;\r\n}\r\n#endif\r\nFPU_stack_underflow();\r\n}\r\nvoid FPU_triga(void)\r\n{\r\n(trig_table_a[FPU_rm]) (&st(0), FPU_gettag0());\r\n}\r\nvoid FPU_trigb(void)\r\n{\r\n(trig_table_b[FPU_rm]) (&st(0), FPU_gettag0());\r\n}
