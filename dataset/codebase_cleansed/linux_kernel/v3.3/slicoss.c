static void slic_assert_fail(void)\r\n{\r\nu32 cpuid;\r\nu32 curr_pid;\r\ncpuid = smp_processor_id();\r\ncurr_pid = current->pid;\r\nprintk(KERN_ERR "%s CPU # %d ---- PID # %d\n",\r\n__func__, cpuid, curr_pid);\r\n}\r\nstatic inline void slic_reg32_write(void __iomem *reg, u32 value, bool flush)\r\n{\r\nwritel(value, reg);\r\nif (flush)\r\nmb();\r\n}\r\nstatic inline void slic_reg64_write(struct adapter *adapter, void __iomem *reg,\r\nu32 value, void __iomem *regh, u32 paddrh,\r\nbool flush)\r\n{\r\nspin_lock_irqsave(&adapter->bit64reglock.lock,\r\nadapter->bit64reglock.flags);\r\nif (paddrh != adapter->curaddrupper) {\r\nadapter->curaddrupper = paddrh;\r\nwritel(paddrh, regh);\r\n}\r\nwritel(value, reg);\r\nif (flush)\r\nmb();\r\nspin_unlock_irqrestore(&adapter->bit64reglock.lock,\r\nadapter->bit64reglock.flags);\r\n}\r\nstatic void slic_mcast_init_crc32(void)\r\n{\r\nu32 c;\r\nu32 e = 0;\r\nint i;\r\nint k;\r\nstatic int p[] = { 0, 1, 2, 4, 5, 7, 8, 10, 11, 12, 16, 22, 23, 26 };\r\nfor (i = 0; i < ARRAY_SIZE(p); i++)\r\ne |= 1L << (31 - p[i]);\r\nfor (i = 1; i < 256; i++) {\r\nc = i;\r\nfor (k = 8; k; k--)\r\nc = c & 1 ? (c >> 1) ^ e : c >> 1;\r\nslic_crc_table[i] = c;\r\n}\r\n}\r\nstatic unsigned char slic_mcast_get_mac_hash(char *macaddr)\r\n{\r\nu32 crc;\r\nchar *p;\r\nint i;\r\nunsigned char machash = 0;\r\nif (!slic_crc_init) {\r\nslic_mcast_init_crc32();\r\nslic_crc_init = 1;\r\n}\r\ncrc = 0xFFFFFFFF;\r\nfor (i = 0, p = macaddr; i < 6; ++p, ++i)\r\ncrc = (crc >> 8) ^ slic_crc_table[(crc ^ *p) & 0xFF];\r\nfor (i = 1; i < 9; i++)\r\nmachash |= (((crc >> i) & 1) << (8 - i));\r\nreturn machash;\r\n}\r\nstatic void slic_mcast_set_bit(struct adapter *adapter, char *address)\r\n{\r\nunsigned char crcpoly;\r\ncrcpoly = slic_mcast_get_mac_hash(address);\r\ncrcpoly &= 0x3F;\r\nadapter->mcastmask |= (u64) 1 << crcpoly;\r\n}\r\nstatic void slic_mcast_set_mask(struct adapter *adapter)\r\n{\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nif (adapter->macopts & (MAC_ALLMCAST | MAC_PROMISC)) {\r\nslic_reg32_write(&slic_regs->slic_mcastlow, 0xFFFFFFFF, FLUSH);\r\nslic_reg32_write(&slic_regs->slic_mcasthigh, 0xFFFFFFFF,\r\nFLUSH);\r\n} else {\r\nslic_reg32_write(&slic_regs->slic_mcastlow,\r\n(u32)(adapter->mcastmask & 0xFFFFFFFF), FLUSH);\r\nslic_reg32_write(&slic_regs->slic_mcasthigh,\r\n(u32)((adapter->mcastmask >> 32) & 0xFFFFFFFF), FLUSH);\r\n}\r\n}\r\nstatic void slic_timer_ping(ulong dev)\r\n{\r\nstruct adapter *adapter;\r\nstruct sliccard *card;\r\nASSERT(dev);\r\nadapter = netdev_priv((struct net_device *)dev);\r\nASSERT(adapter);\r\ncard = adapter->card;\r\nASSERT(card);\r\nadapter->pingtimer.expires = jiffies + (PING_TIMER_INTERVAL * HZ);\r\nadd_timer(&adapter->pingtimer);\r\n}\r\nstatic void slic_unmap_mmio_space(struct adapter *adapter)\r\n{\r\nif (adapter->slic_regs)\r\niounmap(adapter->slic_regs);\r\nadapter->slic_regs = NULL;\r\n}\r\nstatic void slic_link_config(struct adapter *adapter,\r\nu32 linkspeed, u32 linkduplex)\r\n{\r\nu32 __iomem *wphy;\r\nu32 speed;\r\nu32 duplex;\r\nu32 phy_config;\r\nu32 phy_advreg;\r\nu32 phy_gctlreg;\r\nif (adapter->state != ADAPT_UP)\r\nreturn;\r\nASSERT((adapter->devid == SLIC_1GB_DEVICE_ID)\r\n|| (adapter->devid == SLIC_2GB_DEVICE_ID));\r\nif (linkspeed > LINK_1000MB)\r\nlinkspeed = LINK_AUTOSPEED;\r\nif (linkduplex > LINK_AUTOD)\r\nlinkduplex = LINK_AUTOD;\r\nwphy = &adapter->slic_regs->slic_wphy;\r\nif ((linkspeed == LINK_AUTOSPEED) || (linkspeed == LINK_1000MB)) {\r\nif (adapter->flags & ADAPT_FLAGS_FIBERMEDIA) {\r\nphy_advreg = (MIICR_REG_4 | (PAR_ADV1000XFD));\r\nphy_advreg |= PAR_ASYMPAUSE_FIBER;\r\nslic_reg32_write(wphy, phy_advreg, FLUSH);\r\nif (linkspeed == LINK_AUTOSPEED) {\r\nphy_config =\r\n(MIICR_REG_PCR |\r\n(PCR_RESET | PCR_AUTONEG |\r\nPCR_AUTONEG_RST));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\n} else {\r\nphy_config = (MIICR_REG_PCR | PCR_POWERDOWN);\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\nmdelay(10);\r\nphy_config =\r\n(MIICR_REG_PCR |\r\n(PCR_RESET | PCR_SPEED_1000 |\r\nPCR_DUPLEX_FULL));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\n}\r\n} else {\r\nif (linkspeed == LINK_AUTOSPEED) {\r\nphy_advreg =\r\n(MIICR_REG_4 |\r\n(PAR_ADV100FD | PAR_ADV100HD | PAR_ADV10FD\r\n| PAR_ADV10HD));\r\n} else {\r\nphy_advreg = MIICR_REG_4;\r\n}\r\nphy_advreg |= PAR_ASYMPAUSE;\r\nphy_advreg |= PAR_802_3;\r\nslic_reg32_write(wphy, phy_advreg, FLUSH);\r\nphy_gctlreg = (MIICR_REG_9 | (PGC_ADV1000FD));\r\nslic_reg32_write(wphy, phy_gctlreg, FLUSH);\r\nif (adapter->subsysid != SLIC_1GB_CICADA_SUBSYS_ID) {\r\nphy_config =\r\n(MIICR_REG_16 | (MRV_REG16_XOVERON));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\nphy_config =\r\n(MIICR_REG_PCR |\r\n(PCR_RESET | PCR_AUTONEG |\r\nPCR_AUTONEG_RST));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\n} else {\r\nphy_config =\r\n(MIICR_REG_PCR |\r\n(PCR_AUTONEG | PCR_AUTONEG_RST));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\n}\r\n}\r\n} else {\r\nif (linkspeed == LINK_10MB)\r\nspeed = 0;\r\nelse\r\nspeed = PCR_SPEED_100;\r\nif (linkduplex == LINK_HALFD)\r\nduplex = 0;\r\nelse\r\nduplex = PCR_DUPLEX_FULL;\r\nif (adapter->subsysid != SLIC_1GB_CICADA_SUBSYS_ID) {\r\nphy_config = (MIICR_REG_16 | (MRV_REG16_XOVEROFF));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\n}\r\nphy_config = (MIICR_REG_PCR | (PCR_POWERDOWN | speed | duplex));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\nmdelay(10);\r\nif (adapter->subsysid != SLIC_1GB_CICADA_SUBSYS_ID) {\r\nphy_config =\r\n(MIICR_REG_PCR | (PCR_RESET | speed | duplex));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\n} else {\r\nphy_config = (MIICR_REG_PCR | (speed | duplex));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\n}\r\n}\r\n}\r\nstatic int slic_card_download_gbrcv(struct adapter *adapter)\r\n{\r\nconst struct firmware *fw;\r\nconst char *file = "";\r\nint ret;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nu32 codeaddr;\r\nu32 instruction;\r\nint index = 0;\r\nu32 rcvucodelen = 0;\r\nswitch (adapter->devid) {\r\ncase SLIC_2GB_DEVICE_ID:\r\nfile = "slicoss/oasisrcvucode.sys";\r\nbreak;\r\ncase SLIC_1GB_DEVICE_ID:\r\nfile = "slicoss/gbrcvucode.sys";\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\nbreak;\r\n}\r\nret = request_firmware(&fw, file, &adapter->pcidev->dev);\r\nif (ret) {\r\ndev_err(&adapter->pcidev->dev,\r\n"SLICOSS: Failed to load firmware %s\n", file);\r\nreturn ret;\r\n}\r\nrcvucodelen = *(u32 *)(fw->data + index);\r\nindex += 4;\r\nswitch (adapter->devid) {\r\ncase SLIC_2GB_DEVICE_ID:\r\nif (rcvucodelen != OasisRcvUCodeLen)\r\nreturn -EINVAL;\r\nbreak;\r\ncase SLIC_1GB_DEVICE_ID:\r\nif (rcvucodelen != GBRcvUCodeLen)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\nbreak;\r\n}\r\nslic_reg32_write(&slic_regs->slic_rcv_wcs, SLIC_RCVWCS_BEGIN, FLUSH);\r\nfor (codeaddr = 0; codeaddr < rcvucodelen; codeaddr++) {\r\nslic_reg32_write(&slic_regs->slic_rcv_wcs, codeaddr, FLUSH);\r\ninstruction = *(u32 *)(fw->data + index);\r\nindex += 4;\r\nslic_reg32_write(&slic_regs->slic_rcv_wcs, instruction, FLUSH);\r\ninstruction = *(u8 *)(fw->data + index);\r\nindex++;\r\nslic_reg32_write(&slic_regs->slic_rcv_wcs, (u8)instruction,\r\nFLUSH);\r\n}\r\nrelease_firmware(fw);\r\nslic_reg32_write(&slic_regs->slic_rcv_wcs, SLIC_RCVWCS_FINISH, FLUSH);\r\nreturn 0;\r\n}\r\nstatic int slic_card_download(struct adapter *adapter)\r\n{\r\nconst struct firmware *fw;\r\nconst char *file = "";\r\nint ret;\r\nu32 section;\r\nint thissectionsize;\r\nint codeaddr;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nu32 instruction;\r\nu32 baseaddress;\r\nu32 i;\r\nu32 numsects = 0;\r\nu32 sectsize[3];\r\nu32 sectstart[3];\r\nint ucode_start, index = 0;\r\nswitch (adapter->devid) {\r\ncase SLIC_2GB_DEVICE_ID:\r\nfile = "slicoss/oasisdownload.sys";\r\nbreak;\r\ncase SLIC_1GB_DEVICE_ID:\r\nfile = "slicoss/gbdownload.sys";\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\nbreak;\r\n}\r\nret = request_firmware(&fw, file, &adapter->pcidev->dev);\r\nif (ret) {\r\ndev_err(&adapter->pcidev->dev,\r\n"SLICOSS: Failed to load firmware %s\n", file);\r\nreturn ret;\r\n}\r\nnumsects = *(u32 *)(fw->data + index);\r\nindex += 4;\r\nASSERT(numsects <= 3);\r\nfor (i = 0; i < numsects; i++) {\r\nsectsize[i] = *(u32 *)(fw->data + index);\r\nindex += 4;\r\n}\r\nfor (i = 0; i < numsects; i++) {\r\nsectstart[i] = *(u32 *)(fw->data + index);\r\nindex += 4;\r\n}\r\nucode_start = index;\r\ninstruction = *(u32 *)(fw->data + index);\r\nindex += 4;\r\nfor (section = 0; section < numsects; section++) {\r\nbaseaddress = sectstart[section];\r\nthissectionsize = sectsize[section] >> 3;\r\nfor (codeaddr = 0; codeaddr < thissectionsize; codeaddr++) {\r\nslic_reg32_write(&slic_regs->slic_wcs,\r\nbaseaddress + codeaddr, FLUSH);\r\nslic_reg32_write(&slic_regs->slic_wcs, instruction, FLUSH);\r\ninstruction = *(u32 *)(fw->data + index);\r\nindex += 4;\r\nslic_reg32_write(&slic_regs->slic_wcs, instruction, FLUSH);\r\ninstruction = *(u32 *)(fw->data + index);\r\nindex += 4;\r\n}\r\n}\r\nindex = ucode_start;\r\nfor (section = 0; section < numsects; section++) {\r\ninstruction = *(u32 *)(fw->data + index);\r\nbaseaddress = sectstart[section];\r\nif (baseaddress < 0x8000)\r\ncontinue;\r\nthissectionsize = sectsize[section] >> 3;\r\nfor (codeaddr = 0; codeaddr < thissectionsize; codeaddr++) {\r\nslic_reg32_write(&slic_regs->slic_wcs,\r\nSLIC_WCS_COMPARE | (baseaddress + codeaddr),\r\nFLUSH);\r\nslic_reg32_write(&slic_regs->slic_wcs, instruction,\r\nFLUSH);\r\ninstruction = *(u32 *)(fw->data + index);\r\nindex += 4;\r\nslic_reg32_write(&slic_regs->slic_wcs, instruction,\r\nFLUSH);\r\ninstruction = *(u32 *)(fw->data + index);\r\nindex += 4;\r\n}\r\n}\r\nrelease_firmware(fw);\r\nmdelay(10);\r\nslic_reg32_write(&slic_regs->slic_wcs, SLIC_WCS_START, FLUSH);\r\nmdelay(20);\r\nreturn 0;\r\n}\r\nstatic void slic_adapter_set_hwaddr(struct adapter *adapter)\r\n{\r\nstruct sliccard *card = adapter->card;\r\nif ((adapter->card) && (card->config_set)) {\r\nmemcpy(adapter->macaddr,\r\ncard->config.MacInfo[adapter->functionnumber].macaddrA,\r\nsizeof(struct slic_config_mac));\r\nif (!(adapter->currmacaddr[0] || adapter->currmacaddr[1] ||\r\nadapter->currmacaddr[2] || adapter->currmacaddr[3] ||\r\nadapter->currmacaddr[4] || adapter->currmacaddr[5])) {\r\nmemcpy(adapter->currmacaddr, adapter->macaddr, 6);\r\n}\r\nif (adapter->netdev) {\r\nmemcpy(adapter->netdev->dev_addr, adapter->currmacaddr,\r\n6);\r\n}\r\n}\r\n}\r\nstatic void slic_intagg_set(struct adapter *adapter, u32 value)\r\n{\r\nslic_reg32_write(&adapter->slic_regs->slic_intagg, value, FLUSH);\r\nadapter->card->loadlevel_current = value;\r\n}\r\nstatic void slic_soft_reset(struct adapter *adapter)\r\n{\r\nif (adapter->card->state == CARD_UP) {\r\nslic_reg32_write(&adapter->slic_regs->slic_quiesce, 0, FLUSH);\r\nmdelay(1);\r\n}\r\nslic_reg32_write(&adapter->slic_regs->slic_reset, SLIC_RESET_MAGIC,\r\nFLUSH);\r\nmdelay(1);\r\n}\r\nstatic void slic_mac_address_config(struct adapter *adapter)\r\n{\r\nu32 value;\r\nu32 value2;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nvalue = *(u32 *) &adapter->currmacaddr[2];\r\nvalue = ntohl(value);\r\nslic_reg32_write(&slic_regs->slic_wraddral, value, FLUSH);\r\nslic_reg32_write(&slic_regs->slic_wraddrbl, value, FLUSH);\r\nvalue2 = (u32) ((adapter->currmacaddr[0] << 8 |\r\nadapter->currmacaddr[1]) & 0xFFFF);\r\nslic_reg32_write(&slic_regs->slic_wraddrah, value2, FLUSH);\r\nslic_reg32_write(&slic_regs->slic_wraddrbh, value2, FLUSH);\r\nslic_mcast_set_mask(adapter);\r\n}\r\nstatic void slic_mac_config(struct adapter *adapter)\r\n{\r\nu32 value;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nif (adapter->linkspeed == LINK_1000MB) {\r\nvalue = ((GMCR_GAPBB_1000 << GMCR_GAPBB_SHIFT) |\r\n(GMCR_GAPR1_1000 << GMCR_GAPR1_SHIFT) |\r\n(GMCR_GAPR2_1000 << GMCR_GAPR2_SHIFT));\r\n} else {\r\nvalue = ((GMCR_GAPBB_100 << GMCR_GAPBB_SHIFT) |\r\n(GMCR_GAPR1_100 << GMCR_GAPR1_SHIFT) |\r\n(GMCR_GAPR2_100 << GMCR_GAPR2_SHIFT));\r\n}\r\nif (adapter->linkspeed == LINK_1000MB)\r\nvalue |= GMCR_GBIT;\r\nif ((adapter->linkduplex == LINK_FULLD)\r\n|| (adapter->macopts & MAC_LOOPBACK)) {\r\nvalue |= GMCR_FULLD;\r\n}\r\nslic_reg32_write(&slic_regs->slic_wmcfg, value, FLUSH);\r\nslic_mac_address_config(adapter);\r\n}\r\nstatic void slic_config_set(struct adapter *adapter, bool linkchange)\r\n{\r\nu32 value;\r\nu32 RcrReset;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nif (linkchange) {\r\nslic_mac_config(adapter);\r\nRcrReset = GRCR_RESET;\r\n} else {\r\nslic_mac_address_config(adapter);\r\nRcrReset = 0;\r\n}\r\nif (adapter->linkduplex == LINK_FULLD) {\r\nvalue = (GXCR_RESET |\r\nGXCR_XMTEN |\r\nGXCR_PAUSEEN);\r\nslic_reg32_write(&slic_regs->slic_wxcfg, value, FLUSH);\r\nvalue = (RcrReset |\r\nGRCR_CTLEN |\r\nGRCR_ADDRAEN |\r\nGRCR_RCVBAD |\r\n(GRCR_HASHSIZE << GRCR_HASHSIZE_SHIFT));\r\n} else {\r\nvalue = (GXCR_RESET |\r\nGXCR_XMTEN);\r\nslic_reg32_write(&slic_regs->slic_wxcfg, value, FLUSH);\r\nvalue = (RcrReset |\r\nGRCR_ADDRAEN |\r\nGRCR_RCVBAD |\r\n(GRCR_HASHSIZE << GRCR_HASHSIZE_SHIFT));\r\n}\r\nif (adapter->state != ADAPT_DOWN) {\r\nvalue |= GRCR_RCVEN;\r\n}\r\nif (adapter->macopts & MAC_PROMISC)\r\nvalue |= GRCR_RCVALL;\r\nslic_reg32_write(&slic_regs->slic_wrcfg, value, FLUSH);\r\n}\r\nstatic void slic_config_clear(struct adapter *adapter)\r\n{\r\nu32 value;\r\nu32 phy_config;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nvalue = (GXCR_RESET |\r\nGXCR_PAUSEEN);\r\nslic_reg32_write(&slic_regs->slic_wxcfg, value, FLUSH);\r\nvalue = (GRCR_RESET |\r\nGRCR_CTLEN |\r\nGRCR_ADDRAEN |\r\n(GRCR_HASHSIZE << GRCR_HASHSIZE_SHIFT));\r\nslic_reg32_write(&slic_regs->slic_wrcfg, value, FLUSH);\r\nphy_config = (MIICR_REG_PCR | (PCR_POWERDOWN));\r\nslic_reg32_write(&slic_regs->slic_wphy, phy_config, FLUSH);\r\n}\r\nstatic bool slic_mac_filter(struct adapter *adapter,\r\nstruct ether_header *ether_frame)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nu32 opts = adapter->macopts;\r\nu32 *dhost4 = (u32 *)&ether_frame->ether_dhost[0];\r\nu16 *dhost2 = (u16 *)&ether_frame->ether_dhost[4];\r\nif (opts & MAC_PROMISC)\r\nreturn true;\r\nif ((*dhost4 == 0xFFFFFFFF) && (*dhost2 == 0xFFFF)) {\r\nif (opts & MAC_BCAST) {\r\nadapter->rcv_broadcasts++;\r\nreturn true;\r\n} else {\r\nreturn false;\r\n}\r\n}\r\nif (ether_frame->ether_dhost[0] & 0x01) {\r\nif (opts & MAC_ALLMCAST) {\r\nadapter->rcv_multicasts++;\r\nnetdev->stats.multicast++;\r\nreturn true;\r\n}\r\nif (opts & MAC_MCAST) {\r\nstruct mcast_address *mcaddr = adapter->mcastaddrs;\r\nwhile (mcaddr) {\r\nif (!compare_ether_addr(mcaddr->address,\r\nether_frame->ether_dhost)) {\r\nadapter->rcv_multicasts++;\r\nnetdev->stats.multicast++;\r\nreturn true;\r\n}\r\nmcaddr = mcaddr->next;\r\n}\r\nreturn false;\r\n} else {\r\nreturn false;\r\n}\r\n}\r\nif (opts & MAC_DIRECTED) {\r\nadapter->rcv_unicasts++;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int slic_mac_set_address(struct net_device *dev, void *ptr)\r\n{\r\nstruct adapter *adapter = netdev_priv(dev);\r\nstruct sockaddr *addr = ptr;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (!adapter)\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EINVAL;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nmemcpy(adapter->currmacaddr, addr->sa_data, dev->addr_len);\r\nslic_config_set(adapter, true);\r\nreturn 0;\r\n}\r\nstatic void slic_timer_load_check(ulong cardaddr)\r\n{\r\nstruct sliccard *card = (struct sliccard *)cardaddr;\r\nstruct adapter *adapter = card->master;\r\nu32 __iomem *intagg;\r\nu32 load = card->events;\r\nu32 level = 0;\r\nintagg = &adapter->slic_regs->slic_intagg;\r\nif ((adapter) && (adapter->state == ADAPT_UP) &&\r\n(card->state == CARD_UP) && (slic_global.dynamic_intagg)) {\r\nif (adapter->devid == SLIC_1GB_DEVICE_ID) {\r\nif (adapter->linkspeed == LINK_1000MB)\r\nlevel = 100;\r\nelse {\r\nif (load > SLIC_LOAD_5)\r\nlevel = SLIC_INTAGG_5;\r\nelse if (load > SLIC_LOAD_4)\r\nlevel = SLIC_INTAGG_4;\r\nelse if (load > SLIC_LOAD_3)\r\nlevel = SLIC_INTAGG_3;\r\nelse if (load > SLIC_LOAD_2)\r\nlevel = SLIC_INTAGG_2;\r\nelse if (load > SLIC_LOAD_1)\r\nlevel = SLIC_INTAGG_1;\r\nelse\r\nlevel = SLIC_INTAGG_0;\r\n}\r\nif (card->loadlevel_current != level) {\r\ncard->loadlevel_current = level;\r\nslic_reg32_write(intagg, level, FLUSH);\r\n}\r\n} else {\r\nif (load > SLIC_LOAD_5)\r\nlevel = SLIC_INTAGG_5;\r\nelse if (load > SLIC_LOAD_4)\r\nlevel = SLIC_INTAGG_4;\r\nelse if (load > SLIC_LOAD_3)\r\nlevel = SLIC_INTAGG_3;\r\nelse if (load > SLIC_LOAD_2)\r\nlevel = SLIC_INTAGG_2;\r\nelse if (load > SLIC_LOAD_1)\r\nlevel = SLIC_INTAGG_1;\r\nelse\r\nlevel = SLIC_INTAGG_0;\r\nif (card->loadlevel_current != level) {\r\ncard->loadlevel_current = level;\r\nslic_reg32_write(intagg, level, FLUSH);\r\n}\r\n}\r\n}\r\ncard->events = 0;\r\ncard->loadtimer.expires = jiffies + (SLIC_LOADTIMER_PERIOD * HZ);\r\nadd_timer(&card->loadtimer);\r\n}\r\nstatic int slic_upr_queue_request(struct adapter *adapter,\r\nu32 upr_request,\r\nu32 upr_data,\r\nu32 upr_data_h,\r\nu32 upr_buffer, u32 upr_buffer_h)\r\n{\r\nstruct slic_upr *upr;\r\nstruct slic_upr *uprqueue;\r\nupr = kmalloc(sizeof(struct slic_upr), GFP_ATOMIC);\r\nif (!upr)\r\nreturn -ENOMEM;\r\nupr->adapter = adapter->port;\r\nupr->upr_request = upr_request;\r\nupr->upr_data = upr_data;\r\nupr->upr_buffer = upr_buffer;\r\nupr->upr_data_h = upr_data_h;\r\nupr->upr_buffer_h = upr_buffer_h;\r\nupr->next = NULL;\r\nif (adapter->upr_list) {\r\nuprqueue = adapter->upr_list;\r\nwhile (uprqueue->next)\r\nuprqueue = uprqueue->next;\r\nuprqueue->next = upr;\r\n} else {\r\nadapter->upr_list = upr;\r\n}\r\nreturn 0;\r\n}\r\nstatic void slic_upr_start(struct adapter *adapter)\r\n{\r\nstruct slic_upr *upr;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nupr = adapter->upr_list;\r\nif (!upr)\r\nreturn;\r\nif (adapter->upr_busy)\r\nreturn;\r\nadapter->upr_busy = 1;\r\nswitch (upr->upr_request) {\r\ncase SLIC_UPR_STATS:\r\nif (upr->upr_data_h == 0) {\r\nslic_reg32_write(&slic_regs->slic_stats, upr->upr_data,\r\nFLUSH);\r\n} else {\r\nslic_reg64_write(adapter, &slic_regs->slic_stats64,\r\nupr->upr_data,\r\n&slic_regs->slic_addr_upper,\r\nupr->upr_data_h, FLUSH);\r\n}\r\nbreak;\r\ncase SLIC_UPR_RLSR:\r\nslic_reg64_write(adapter, &slic_regs->slic_rlsr, upr->upr_data,\r\n&slic_regs->slic_addr_upper, upr->upr_data_h,\r\nFLUSH);\r\nbreak;\r\ncase SLIC_UPR_RCONFIG:\r\nslic_reg64_write(adapter, &slic_regs->slic_rconfig,\r\nupr->upr_data, &slic_regs->slic_addr_upper,\r\nupr->upr_data_h, FLUSH);\r\nbreak;\r\ncase SLIC_UPR_PING:\r\nslic_reg32_write(&slic_regs->slic_ping, 1, FLUSH);\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\n}\r\n}\r\nstatic int slic_upr_request(struct adapter *adapter,\r\nu32 upr_request,\r\nu32 upr_data,\r\nu32 upr_data_h,\r\nu32 upr_buffer, u32 upr_buffer_h)\r\n{\r\nint rc;\r\nspin_lock_irqsave(&adapter->upr_lock.lock, adapter->upr_lock.flags);\r\nrc = slic_upr_queue_request(adapter,\r\nupr_request,\r\nupr_data,\r\nupr_data_h, upr_buffer, upr_buffer_h);\r\nif (rc)\r\ngoto err_unlock_irq;\r\nslic_upr_start(adapter);\r\nerr_unlock_irq:\r\nspin_unlock_irqrestore(&adapter->upr_lock.lock,\r\nadapter->upr_lock.flags);\r\nreturn rc;\r\n}\r\nstatic void slic_link_upr_complete(struct adapter *adapter, u32 isr)\r\n{\r\nu32 linkstatus = adapter->pshmem->linkstatus;\r\nuint linkup;\r\nunsigned char linkspeed;\r\nunsigned char linkduplex;\r\nif ((isr & ISR_UPCERR) || (isr & ISR_UPCBSY)) {\r\nstruct slic_shmem *pshmem;\r\npshmem = (struct slic_shmem *)adapter->phys_shmem;\r\n#if BITS_PER_LONG == 64\r\nslic_upr_queue_request(adapter,\r\nSLIC_UPR_RLSR,\r\nSLIC_GET_ADDR_LOW(&pshmem->linkstatus),\r\nSLIC_GET_ADDR_HIGH(&pshmem->linkstatus),\r\n0, 0);\r\n#else\r\nslic_upr_queue_request(adapter,\r\nSLIC_UPR_RLSR,\r\n(u32) &pshmem->linkstatus,\r\nSLIC_GET_ADDR_HIGH(pshmem), 0, 0);\r\n#endif\r\nreturn;\r\n}\r\nif (adapter->state != ADAPT_UP)\r\nreturn;\r\nASSERT((adapter->devid == SLIC_1GB_DEVICE_ID)\r\n|| (adapter->devid == SLIC_2GB_DEVICE_ID));\r\nlinkup = linkstatus & GIG_LINKUP ? LINK_UP : LINK_DOWN;\r\nif (linkstatus & GIG_SPEED_1000)\r\nlinkspeed = LINK_1000MB;\r\nelse if (linkstatus & GIG_SPEED_100)\r\nlinkspeed = LINK_100MB;\r\nelse\r\nlinkspeed = LINK_10MB;\r\nif (linkstatus & GIG_FULLDUPLEX)\r\nlinkduplex = LINK_FULLD;\r\nelse\r\nlinkduplex = LINK_HALFD;\r\nif ((adapter->linkstate == LINK_DOWN) && (linkup == LINK_DOWN))\r\nreturn;\r\nif ((adapter->linkstate == LINK_UP) &&\r\n(linkup == LINK_UP) &&\r\n(adapter->linkspeed == linkspeed) &&\r\n(adapter->linkduplex == linkduplex))\r\nreturn;\r\nif (linkup == LINK_DOWN) {\r\nadapter->linkstate = LINK_DOWN;\r\nreturn;\r\n}\r\nadapter->linkspeed = linkspeed;\r\nadapter->linkduplex = linkduplex;\r\nif (adapter->linkstate != LINK_UP) {\r\nslic_config_set(adapter, true);\r\nadapter->linkstate = LINK_UP;\r\nnetif_start_queue(adapter->netdev);\r\n}\r\n}\r\nstatic void slic_upr_request_complete(struct adapter *adapter, u32 isr)\r\n{\r\nstruct sliccard *card = adapter->card;\r\nstruct slic_upr *upr;\r\nspin_lock_irqsave(&adapter->upr_lock.lock, adapter->upr_lock.flags);\r\nupr = adapter->upr_list;\r\nif (!upr) {\r\nASSERT(0);\r\nspin_unlock_irqrestore(&adapter->upr_lock.lock,\r\nadapter->upr_lock.flags);\r\nreturn;\r\n}\r\nadapter->upr_list = upr->next;\r\nupr->next = NULL;\r\nadapter->upr_busy = 0;\r\nASSERT(adapter->port == upr->adapter);\r\nswitch (upr->upr_request) {\r\ncase SLIC_UPR_STATS:\r\n{\r\nstruct slic_stats *slicstats =\r\n(struct slic_stats *) &adapter->pshmem->inicstats;\r\nstruct slic_stats *newstats = slicstats;\r\nstruct slic_stats *old = &adapter->inicstats_prev;\r\nstruct slicnet_stats *stst = &adapter->slic_stats;\r\nif (isr & ISR_UPCERR) {\r\ndev_err(&adapter->netdev->dev,\r\n"SLIC_UPR_STATS command failed isr[%x]\n",\r\nisr);\r\nbreak;\r\n}\r\nUPDATE_STATS_GB(stst->tcp.xmit_tcp_segs,\r\nnewstats->xmit_tcp_segs_gb,\r\nold->xmit_tcp_segs_gb);\r\nUPDATE_STATS_GB(stst->tcp.xmit_tcp_bytes,\r\nnewstats->xmit_tcp_bytes_gb,\r\nold->xmit_tcp_bytes_gb);\r\nUPDATE_STATS_GB(stst->tcp.rcv_tcp_segs,\r\nnewstats->rcv_tcp_segs_gb,\r\nold->rcv_tcp_segs_gb);\r\nUPDATE_STATS_GB(stst->tcp.rcv_tcp_bytes,\r\nnewstats->rcv_tcp_bytes_gb,\r\nold->rcv_tcp_bytes_gb);\r\nUPDATE_STATS_GB(stst->iface.xmt_bytes,\r\nnewstats->xmit_bytes_gb,\r\nold->xmit_bytes_gb);\r\nUPDATE_STATS_GB(stst->iface.xmt_ucast,\r\nnewstats->xmit_unicasts_gb,\r\nold->xmit_unicasts_gb);\r\nUPDATE_STATS_GB(stst->iface.rcv_bytes,\r\nnewstats->rcv_bytes_gb,\r\nold->rcv_bytes_gb);\r\nUPDATE_STATS_GB(stst->iface.rcv_ucast,\r\nnewstats->rcv_unicasts_gb,\r\nold->rcv_unicasts_gb);\r\nUPDATE_STATS_GB(stst->iface.xmt_errors,\r\nnewstats->xmit_collisions_gb,\r\nold->xmit_collisions_gb);\r\nUPDATE_STATS_GB(stst->iface.xmt_errors,\r\nnewstats->xmit_excess_collisions_gb,\r\nold->xmit_excess_collisions_gb);\r\nUPDATE_STATS_GB(stst->iface.xmt_errors,\r\nnewstats->xmit_other_error_gb,\r\nold->xmit_other_error_gb);\r\nUPDATE_STATS_GB(stst->iface.rcv_errors,\r\nnewstats->rcv_other_error_gb,\r\nold->rcv_other_error_gb);\r\nUPDATE_STATS_GB(stst->iface.rcv_discards,\r\nnewstats->rcv_drops_gb,\r\nold->rcv_drops_gb);\r\nif (newstats->rcv_drops_gb > old->rcv_drops_gb) {\r\nadapter->rcv_drops +=\r\n(newstats->rcv_drops_gb -\r\nold->rcv_drops_gb);\r\n}\r\nmemcpy(old, newstats, sizeof(struct slic_stats));\r\nbreak;\r\n}\r\ncase SLIC_UPR_RLSR:\r\nslic_link_upr_complete(adapter, isr);\r\nbreak;\r\ncase SLIC_UPR_RCONFIG:\r\nbreak;\r\ncase SLIC_UPR_RPHY:\r\nASSERT(0);\r\nbreak;\r\ncase SLIC_UPR_ENLB:\r\nASSERT(0);\r\nbreak;\r\ncase SLIC_UPR_ENCT:\r\nASSERT(0);\r\nbreak;\r\ncase SLIC_UPR_PDWN:\r\nASSERT(0);\r\nbreak;\r\ncase SLIC_UPR_PING:\r\ncard->pingstatus |= (isr & ISR_PINGDSMASK);\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\n}\r\nkfree(upr);\r\nslic_upr_start(adapter);\r\nspin_unlock_irqrestore(&adapter->upr_lock.lock,\r\nadapter->upr_lock.flags);\r\n}\r\nstatic void slic_config_get(struct adapter *adapter, u32 config,\r\nu32 config_h)\r\n{\r\nint status;\r\nstatus = slic_upr_request(adapter,\r\nSLIC_UPR_RCONFIG,\r\n(u32) config, (u32) config_h, 0, 0);\r\nASSERT(status == 0);\r\n}\r\nstatic ushort slic_eeprom_cksum(char *m, int len)\r\n{\r\n#define ADDCARRY(x) (x > 65535 ? x -= 65535 : x)\r\n#define REDUCE {l_util.l = sum; sum = l_util.s[0] + l_util.s[1]; ADDCARRY(sum);\\r\n}\r\nu16 *w;\r\nu32 sum = 0;\r\nu32 byte_swapped = 0;\r\nu32 w_int;\r\nunion {\r\nchar c[2];\r\nushort s;\r\n} s_util;\r\nunion {\r\nushort s[2];\r\nint l;\r\n} l_util;\r\nl_util.l = 0;\r\ns_util.s = 0;\r\nw = (u16 *)m;\r\n#if BITS_PER_LONG == 64\r\nw_int = (u32) ((ulong) w & 0x00000000FFFFFFFF);\r\n#else\r\nw_int = (u32) (w);\r\n#endif\r\nif ((1 & w_int) && (len > 0)) {\r\nREDUCE;\r\nsum <<= 8;\r\ns_util.c[0] = *(unsigned char *)w;\r\nw = (u16 *)((char *)w + 1);\r\nlen--;\r\nbyte_swapped = 1;\r\n}\r\nwhile ((len -= 32) >= 0) {\r\nsum += w[0];\r\nsum += w[1];\r\nsum += w[2];\r\nsum += w[3];\r\nsum += w[4];\r\nsum += w[5];\r\nsum += w[6];\r\nsum += w[7];\r\nsum += w[8];\r\nsum += w[9];\r\nsum += w[10];\r\nsum += w[11];\r\nsum += w[12];\r\nsum += w[13];\r\nsum += w[14];\r\nsum += w[15];\r\nw = (u16 *)((ulong) w + 16);\r\n}\r\nlen += 32;\r\nwhile ((len -= 8) >= 0) {\r\nsum += w[0];\r\nsum += w[1];\r\nsum += w[2];\r\nsum += w[3];\r\nw = (u16 *)((ulong) w + 4);\r\n}\r\nlen += 8;\r\nif (len != 0 || byte_swapped != 0) {\r\nREDUCE;\r\nwhile ((len -= 2) >= 0)\r\nsum += *w++;\r\nif (byte_swapped) {\r\nREDUCE;\r\nsum <<= 8;\r\nbyte_swapped = 0;\r\nif (len == -1) {\r\ns_util.c[1] = *(char *) w;\r\nsum += s_util.s;\r\nlen = 0;\r\n} else {\r\nlen = -1;\r\n}\r\n} else if (len == -1) {\r\ns_util.c[0] = *(char *) w;\r\n}\r\nif (len == -1) {\r\ns_util.c[1] = 0;\r\nsum += s_util.s;\r\n}\r\n}\r\nREDUCE;\r\nreturn (ushort) sum;\r\n}\r\nstatic void slic_rspqueue_free(struct adapter *adapter)\r\n{\r\nint i;\r\nstruct slic_rspqueue *rspq = &adapter->rspqueue;\r\nfor (i = 0; i < rspq->num_pages; i++) {\r\nif (rspq->vaddr[i]) {\r\npci_free_consistent(adapter->pcidev, PAGE_SIZE,\r\nrspq->vaddr[i], rspq->paddr[i]);\r\n}\r\nrspq->vaddr[i] = NULL;\r\nrspq->paddr[i] = 0;\r\n}\r\nrspq->offset = 0;\r\nrspq->pageindex = 0;\r\nrspq->rspbuf = NULL;\r\n}\r\nstatic int slic_rspqueue_init(struct adapter *adapter)\r\n{\r\nint i;\r\nstruct slic_rspqueue *rspq = &adapter->rspqueue;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nu32 paddrh = 0;\r\nASSERT(adapter->state == ADAPT_DOWN);\r\nmemset(rspq, 0, sizeof(struct slic_rspqueue));\r\nrspq->num_pages = SLIC_RSPQ_PAGES_GB;\r\nfor (i = 0; i < rspq->num_pages; i++) {\r\nrspq->vaddr[i] = pci_alloc_consistent(adapter->pcidev,\r\nPAGE_SIZE,\r\n&rspq->paddr[i]);\r\nif (!rspq->vaddr[i]) {\r\ndev_err(&adapter->pcidev->dev,\r\n"pci_alloc_consistent failed\n");\r\nslic_rspqueue_free(adapter);\r\nreturn -ENOMEM;\r\n}\r\n#if 0\r\n#ifndef CONFIG_X86_64\r\nASSERT(((u32) rspq->vaddr[i] & 0xFFFFF000) ==\r\n(u32) rspq->vaddr[i]);\r\nASSERT(((u32) rspq->paddr[i] & 0xFFFFF000) ==\r\n(u32) rspq->paddr[i]);\r\n#endif\r\n#endif\r\nmemset(rspq->vaddr[i], 0, PAGE_SIZE);\r\nif (paddrh == 0) {\r\nslic_reg32_write(&slic_regs->slic_rbar,\r\n(rspq->paddr[i] | SLIC_RSPQ_BUFSINPAGE),\r\nDONT_FLUSH);\r\n} else {\r\nslic_reg64_write(adapter, &slic_regs->slic_rbar64,\r\n(rspq->paddr[i] | SLIC_RSPQ_BUFSINPAGE),\r\n&slic_regs->slic_addr_upper,\r\npaddrh, DONT_FLUSH);\r\n}\r\n}\r\nrspq->offset = 0;\r\nrspq->pageindex = 0;\r\nrspq->rspbuf = (struct slic_rspbuf *)rspq->vaddr[0];\r\nreturn 0;\r\n}\r\nstatic struct slic_rspbuf *slic_rspqueue_getnext(struct adapter *adapter)\r\n{\r\nstruct slic_rspqueue *rspq = &adapter->rspqueue;\r\nstruct slic_rspbuf *buf;\r\nif (!(rspq->rspbuf->status))\r\nreturn NULL;\r\nbuf = rspq->rspbuf;\r\n#if BITS_PER_LONG == 32\r\nASSERT((buf->status & 0xFFFFFFE0) == 0);\r\n#endif\r\nASSERT(buf->hosthandle);\r\nif (++rspq->offset < SLIC_RSPQ_BUFSINPAGE) {\r\nrspq->rspbuf++;\r\n#if BITS_PER_LONG == 32\r\nASSERT(((u32) rspq->rspbuf & 0xFFFFFFE0) ==\r\n(u32) rspq->rspbuf);\r\n#endif\r\n} else {\r\nASSERT(rspq->offset == SLIC_RSPQ_BUFSINPAGE);\r\nslic_reg64_write(adapter, &adapter->slic_regs->slic_rbar64,\r\n(rspq->paddr[rspq->pageindex] | SLIC_RSPQ_BUFSINPAGE),\r\n&adapter->slic_regs->slic_addr_upper, 0, DONT_FLUSH);\r\nrspq->pageindex = (++rspq->pageindex) % rspq->num_pages;\r\nrspq->offset = 0;\r\nrspq->rspbuf = (struct slic_rspbuf *)\r\nrspq->vaddr[rspq->pageindex];\r\n#if BITS_PER_LONG == 32\r\nASSERT(((u32) rspq->rspbuf & 0xFFFFF000) ==\r\n(u32) rspq->rspbuf);\r\n#endif\r\n}\r\n#if BITS_PER_LONG == 32\r\nASSERT(((u32) buf & 0xFFFFFFE0) == (u32) buf);\r\n#endif\r\nreturn buf;\r\n}\r\nstatic void slic_cmdqmem_init(struct adapter *adapter)\r\n{\r\nstruct slic_cmdqmem *cmdqmem = &adapter->cmdqmem;\r\nmemset(cmdqmem, 0, sizeof(struct slic_cmdqmem));\r\n}\r\nstatic void slic_cmdqmem_free(struct adapter *adapter)\r\n{\r\nstruct slic_cmdqmem *cmdqmem = &adapter->cmdqmem;\r\nint i;\r\nfor (i = 0; i < SLIC_CMDQ_MAXPAGES; i++) {\r\nif (cmdqmem->pages[i]) {\r\npci_free_consistent(adapter->pcidev,\r\nPAGE_SIZE,\r\n(void *) cmdqmem->pages[i],\r\ncmdqmem->dma_pages[i]);\r\n}\r\n}\r\nmemset(cmdqmem, 0, sizeof(struct slic_cmdqmem));\r\n}\r\nstatic u32 *slic_cmdqmem_addpage(struct adapter *adapter)\r\n{\r\nstruct slic_cmdqmem *cmdqmem = &adapter->cmdqmem;\r\nu32 *pageaddr;\r\nif (cmdqmem->pagecnt >= SLIC_CMDQ_MAXPAGES)\r\nreturn NULL;\r\npageaddr = pci_alloc_consistent(adapter->pcidev,\r\nPAGE_SIZE,\r\n&cmdqmem->dma_pages[cmdqmem->pagecnt]);\r\nif (!pageaddr)\r\nreturn NULL;\r\n#if BITS_PER_LONG == 32\r\nASSERT(((u32) pageaddr & 0xFFFFF000) == (u32) pageaddr);\r\n#endif\r\ncmdqmem->pages[cmdqmem->pagecnt] = pageaddr;\r\ncmdqmem->pagecnt++;\r\nreturn pageaddr;\r\n}\r\nstatic void slic_cmdq_free(struct adapter *adapter)\r\n{\r\nstruct slic_hostcmd *cmd;\r\ncmd = adapter->cmdq_all.head;\r\nwhile (cmd) {\r\nif (cmd->busy) {\r\nstruct sk_buff *tempskb;\r\ntempskb = cmd->skb;\r\nif (tempskb) {\r\ncmd->skb = NULL;\r\ndev_kfree_skb_irq(tempskb);\r\n}\r\n}\r\ncmd = cmd->next_all;\r\n}\r\nmemset(&adapter->cmdq_all, 0, sizeof(struct slic_cmdqueue));\r\nmemset(&adapter->cmdq_free, 0, sizeof(struct slic_cmdqueue));\r\nmemset(&adapter->cmdq_done, 0, sizeof(struct slic_cmdqueue));\r\nslic_cmdqmem_free(adapter);\r\n}\r\nstatic void slic_cmdq_addcmdpage(struct adapter *adapter, u32 *page)\r\n{\r\nstruct slic_hostcmd *cmd;\r\nstruct slic_hostcmd *prev;\r\nstruct slic_hostcmd *tail;\r\nstruct slic_cmdqueue *cmdq;\r\nint cmdcnt;\r\nvoid *cmdaddr;\r\nulong phys_addr;\r\nu32 phys_addrl;\r\nu32 phys_addrh;\r\nstruct slic_handle *pslic_handle;\r\ncmdaddr = page;\r\ncmd = (struct slic_hostcmd *)cmdaddr;\r\ncmdcnt = 0;\r\nphys_addr = virt_to_bus((void *)page);\r\nphys_addrl = SLIC_GET_ADDR_LOW(phys_addr);\r\nphys_addrh = SLIC_GET_ADDR_HIGH(phys_addr);\r\nprev = NULL;\r\ntail = cmd;\r\nwhile ((cmdcnt < SLIC_CMDQ_CMDSINPAGE) &&\r\n(adapter->slic_handle_ix < 256)) {\r\nSLIC_GET_SLIC_HANDLE(adapter, pslic_handle);\r\nif (pslic_handle == NULL)\r\nASSERT(0);\r\nASSERT(pslic_handle ==\r\n&adapter->slic_handles[pslic_handle->token.\r\nhandle_index]);\r\npslic_handle->type = SLIC_HANDLE_CMD;\r\npslic_handle->address = (void *) cmd;\r\npslic_handle->offset = (ushort) adapter->slic_handle_ix++;\r\npslic_handle->other_handle = NULL;\r\npslic_handle->next = NULL;\r\ncmd->pslic_handle = pslic_handle;\r\ncmd->cmd64.hosthandle = pslic_handle->token.handle_token;\r\ncmd->busy = false;\r\ncmd->paddrl = phys_addrl;\r\ncmd->paddrh = phys_addrh;\r\ncmd->next_all = prev;\r\ncmd->next = prev;\r\nprev = cmd;\r\nphys_addrl += SLIC_HOSTCMD_SIZE;\r\ncmdaddr += SLIC_HOSTCMD_SIZE;\r\ncmd = (struct slic_hostcmd *)cmdaddr;\r\ncmdcnt++;\r\n}\r\ncmdq = &adapter->cmdq_all;\r\ncmdq->count += cmdcnt;\r\ntail->next_all = cmdq->head;\r\ncmdq->head = prev;\r\ncmdq = &adapter->cmdq_free;\r\nspin_lock_irqsave(&cmdq->lock.lock, cmdq->lock.flags);\r\ncmdq->count += cmdcnt;\r\ntail->next = cmdq->head;\r\ncmdq->head = prev;\r\nspin_unlock_irqrestore(&cmdq->lock.lock, cmdq->lock.flags);\r\n}\r\nstatic int slic_cmdq_init(struct adapter *adapter)\r\n{\r\nint i;\r\nu32 *pageaddr;\r\nASSERT(adapter->state == ADAPT_DOWN);\r\nmemset(&adapter->cmdq_all, 0, sizeof(struct slic_cmdqueue));\r\nmemset(&adapter->cmdq_free, 0, sizeof(struct slic_cmdqueue));\r\nmemset(&adapter->cmdq_done, 0, sizeof(struct slic_cmdqueue));\r\nspin_lock_init(&adapter->cmdq_all.lock.lock);\r\nspin_lock_init(&adapter->cmdq_free.lock.lock);\r\nspin_lock_init(&adapter->cmdq_done.lock.lock);\r\nslic_cmdqmem_init(adapter);\r\nadapter->slic_handle_ix = 1;\r\nfor (i = 0; i < SLIC_CMDQ_INITPAGES; i++) {\r\npageaddr = slic_cmdqmem_addpage(adapter);\r\n#if BITS_PER_LONG == 32\r\nASSERT(((u32) pageaddr & 0xFFFFF000) == (u32) pageaddr);\r\n#endif\r\nif (!pageaddr) {\r\nslic_cmdq_free(adapter);\r\nreturn -ENOMEM;\r\n}\r\nslic_cmdq_addcmdpage(adapter, pageaddr);\r\n}\r\nadapter->slic_handle_ix = 1;\r\nreturn 0;\r\n}\r\nstatic void slic_cmdq_reset(struct adapter *adapter)\r\n{\r\nstruct slic_hostcmd *hcmd;\r\nstruct sk_buff *skb;\r\nu32 outstanding;\r\nspin_lock_irqsave(&adapter->cmdq_free.lock.lock,\r\nadapter->cmdq_free.lock.flags);\r\nspin_lock_irqsave(&adapter->cmdq_done.lock.lock,\r\nadapter->cmdq_done.lock.flags);\r\noutstanding = adapter->cmdq_all.count - adapter->cmdq_done.count;\r\noutstanding -= adapter->cmdq_free.count;\r\nhcmd = adapter->cmdq_all.head;\r\nwhile (hcmd) {\r\nif (hcmd->busy) {\r\nskb = hcmd->skb;\r\nASSERT(skb);\r\nhcmd->busy = 0;\r\nhcmd->skb = NULL;\r\ndev_kfree_skb_irq(skb);\r\n}\r\nhcmd = hcmd->next_all;\r\n}\r\nadapter->cmdq_free.count = 0;\r\nadapter->cmdq_free.head = NULL;\r\nadapter->cmdq_free.tail = NULL;\r\nadapter->cmdq_done.count = 0;\r\nadapter->cmdq_done.head = NULL;\r\nadapter->cmdq_done.tail = NULL;\r\nadapter->cmdq_free.head = adapter->cmdq_all.head;\r\nhcmd = adapter->cmdq_all.head;\r\nwhile (hcmd) {\r\nadapter->cmdq_free.count++;\r\nhcmd->next = hcmd->next_all;\r\nhcmd = hcmd->next_all;\r\n}\r\nif (adapter->cmdq_free.count != adapter->cmdq_all.count) {\r\ndev_err(&adapter->netdev->dev,\r\n"free_count %d != all count %d\n",\r\nadapter->cmdq_free.count, adapter->cmdq_all.count);\r\n}\r\nspin_unlock_irqrestore(&adapter->cmdq_done.lock.lock,\r\nadapter->cmdq_done.lock.flags);\r\nspin_unlock_irqrestore(&adapter->cmdq_free.lock.lock,\r\nadapter->cmdq_free.lock.flags);\r\n}\r\nstatic void slic_cmdq_getdone(struct adapter *adapter)\r\n{\r\nstruct slic_cmdqueue *done_cmdq = &adapter->cmdq_done;\r\nstruct slic_cmdqueue *free_cmdq = &adapter->cmdq_free;\r\nASSERT(free_cmdq->head == NULL);\r\nspin_lock_irqsave(&done_cmdq->lock.lock, done_cmdq->lock.flags);\r\nfree_cmdq->head = done_cmdq->head;\r\nfree_cmdq->count = done_cmdq->count;\r\ndone_cmdq->head = NULL;\r\ndone_cmdq->tail = NULL;\r\ndone_cmdq->count = 0;\r\nspin_unlock_irqrestore(&done_cmdq->lock.lock, done_cmdq->lock.flags);\r\n}\r\nstatic struct slic_hostcmd *slic_cmdq_getfree(struct adapter *adapter)\r\n{\r\nstruct slic_cmdqueue *cmdq = &adapter->cmdq_free;\r\nstruct slic_hostcmd *cmd = NULL;\r\nlock_and_retry:\r\nspin_lock_irqsave(&cmdq->lock.lock, cmdq->lock.flags);\r\nretry:\r\ncmd = cmdq->head;\r\nif (cmd) {\r\ncmdq->head = cmd->next;\r\ncmdq->count--;\r\nspin_unlock_irqrestore(&cmdq->lock.lock, cmdq->lock.flags);\r\n} else {\r\nslic_cmdq_getdone(adapter);\r\ncmd = cmdq->head;\r\nif (cmd) {\r\ngoto retry;\r\n} else {\r\nu32 *pageaddr;\r\nspin_unlock_irqrestore(&cmdq->lock.lock,\r\ncmdq->lock.flags);\r\npageaddr = slic_cmdqmem_addpage(adapter);\r\nif (pageaddr) {\r\nslic_cmdq_addcmdpage(adapter, pageaddr);\r\ngoto lock_and_retry;\r\n}\r\n}\r\n}\r\nreturn cmd;\r\n}\r\nstatic void slic_cmdq_putdone_irq(struct adapter *adapter,\r\nstruct slic_hostcmd *cmd)\r\n{\r\nstruct slic_cmdqueue *cmdq = &adapter->cmdq_done;\r\nspin_lock(&cmdq->lock.lock);\r\ncmd->busy = 0;\r\ncmd->next = cmdq->head;\r\ncmdq->head = cmd;\r\ncmdq->count++;\r\nif ((adapter->xmitq_full) && (cmdq->count > 10))\r\nnetif_wake_queue(adapter->netdev);\r\nspin_unlock(&cmdq->lock.lock);\r\n}\r\nstatic int slic_rcvqueue_fill(struct adapter *adapter)\r\n{\r\nvoid *paddr;\r\nu32 paddrl;\r\nu32 paddrh;\r\nstruct slic_rcvqueue *rcvq = &adapter->rcvqueue;\r\nint i = 0;\r\nstruct device *dev = &adapter->netdev->dev;\r\nwhile (i < SLIC_RCVQ_FILLENTRIES) {\r\nstruct slic_rcvbuf *rcvbuf;\r\nstruct sk_buff *skb;\r\n#ifdef KLUDGE_FOR_4GB_BOUNDARY\r\nretry_rcvqfill:\r\n#endif\r\nskb = alloc_skb(SLIC_RCVQ_RCVBUFSIZE, GFP_ATOMIC);\r\nif (skb) {\r\npaddr = (void *)pci_map_single(adapter->pcidev,\r\nskb->data,\r\nSLIC_RCVQ_RCVBUFSIZE,\r\nPCI_DMA_FROMDEVICE);\r\npaddrl = SLIC_GET_ADDR_LOW(paddr);\r\npaddrh = SLIC_GET_ADDR_HIGH(paddr);\r\nskb->len = SLIC_RCVBUF_HEADSIZE;\r\nrcvbuf = (struct slic_rcvbuf *)skb->head;\r\nrcvbuf->status = 0;\r\nskb->next = NULL;\r\n#ifdef KLUDGE_FOR_4GB_BOUNDARY\r\nif (paddrl == 0) {\r\ndev_err(dev, "%s: LOW 32bits PHYSICAL ADDRESS == 0\n",\r\n__func__);\r\ndev_err(dev, "skb[%p] PROBLEM\n", skb);\r\ndev_err(dev, " skbdata[%p]\n", skb->data);\r\ndev_err(dev, " skblen[%x]\n", skb->len);\r\ndev_err(dev, " paddr[%p]\n", paddr);\r\ndev_err(dev, " paddrl[%x]\n", paddrl);\r\ndev_err(dev, " paddrh[%x]\n", paddrh);\r\ndev_err(dev, " rcvq->head[%p]\n", rcvq->head);\r\ndev_err(dev, " rcvq->tail[%p]\n", rcvq->tail);\r\ndev_err(dev, " rcvq->count[%x]\n", rcvq->count);\r\ndev_err(dev, "SKIP THIS SKB!!!!!!!!\n");\r\ngoto retry_rcvqfill;\r\n}\r\n#else\r\nif (paddrl == 0) {\r\ndev_err(dev, "%s: LOW 32bits PHYSICAL ADDRESS == 0\n",\r\n__func__);\r\ndev_err(dev, "skb[%p] PROBLEM\n", skb);\r\ndev_err(dev, " skbdata[%p]\n", skb->data);\r\ndev_err(dev, " skblen[%x]\n", skb->len);\r\ndev_err(dev, " paddr[%p]\n", paddr);\r\ndev_err(dev, " paddrl[%x]\n", paddrl);\r\ndev_err(dev, " paddrh[%x]\n", paddrh);\r\ndev_err(dev, " rcvq->head[%p]\n", rcvq->head);\r\ndev_err(dev, " rcvq->tail[%p]\n", rcvq->tail);\r\ndev_err(dev, " rcvq->count[%x]\n", rcvq->count);\r\ndev_err(dev, "GIVE TO CARD ANYWAY\n");\r\n}\r\n#endif\r\nif (paddrh == 0) {\r\nslic_reg32_write(&adapter->slic_regs->slic_hbar,\r\n(u32)paddrl, DONT_FLUSH);\r\n} else {\r\nslic_reg64_write(adapter,\r\n&adapter->slic_regs->slic_hbar64,\r\npaddrl,\r\n&adapter->slic_regs->slic_addr_upper,\r\npaddrh, DONT_FLUSH);\r\n}\r\nif (rcvq->head)\r\nrcvq->tail->next = skb;\r\nelse\r\nrcvq->head = skb;\r\nrcvq->tail = skb;\r\nrcvq->count++;\r\ni++;\r\n} else {\r\ndev_err(&adapter->netdev->dev,\r\n"slic_rcvqueue_fill could only get [%d] skbuffs\n",\r\ni);\r\nbreak;\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic void slic_rcvqueue_free(struct adapter *adapter)\r\n{\r\nstruct slic_rcvqueue *rcvq = &adapter->rcvqueue;\r\nstruct sk_buff *skb;\r\nwhile (rcvq->head) {\r\nskb = rcvq->head;\r\nrcvq->head = rcvq->head->next;\r\ndev_kfree_skb(skb);\r\n}\r\nrcvq->tail = NULL;\r\nrcvq->head = NULL;\r\nrcvq->count = 0;\r\n}\r\nstatic int slic_rcvqueue_init(struct adapter *adapter)\r\n{\r\nint i, count;\r\nstruct slic_rcvqueue *rcvq = &adapter->rcvqueue;\r\nASSERT(adapter->state == ADAPT_DOWN);\r\nrcvq->tail = NULL;\r\nrcvq->head = NULL;\r\nrcvq->size = SLIC_RCVQ_ENTRIES;\r\nrcvq->errors = 0;\r\nrcvq->count = 0;\r\ni = (SLIC_RCVQ_ENTRIES / SLIC_RCVQ_FILLENTRIES);\r\ncount = 0;\r\nwhile (i) {\r\ncount += slic_rcvqueue_fill(adapter);\r\ni--;\r\n}\r\nif (rcvq->count < SLIC_RCVQ_MINENTRIES) {\r\nslic_rcvqueue_free(adapter);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *slic_rcvqueue_getnext(struct adapter *adapter)\r\n{\r\nstruct slic_rcvqueue *rcvq = &adapter->rcvqueue;\r\nstruct sk_buff *skb;\r\nstruct slic_rcvbuf *rcvbuf;\r\nint count;\r\nif (rcvq->count) {\r\nskb = rcvq->head;\r\nrcvbuf = (struct slic_rcvbuf *)skb->head;\r\nASSERT(rcvbuf);\r\nif (rcvbuf->status & IRHDDR_SVALID) {\r\nrcvq->head = rcvq->head->next;\r\nskb->next = NULL;\r\nrcvq->count--;\r\n} else {\r\nskb = NULL;\r\n}\r\n} else {\r\ndev_err(&adapter->netdev->dev,\r\n"RcvQ Empty!! rcvq[%p] count[%x]\n", rcvq, rcvq->count);\r\nskb = NULL;\r\n}\r\nwhile (rcvq->count < SLIC_RCVQ_FILLTHRESH) {\r\ncount = slic_rcvqueue_fill(adapter);\r\nif (!count)\r\nbreak;\r\n}\r\nif (skb)\r\nrcvq->errors = 0;\r\nreturn skb;\r\n}\r\nstatic u32 slic_rcvqueue_reinsert(struct adapter *adapter, struct sk_buff *skb)\r\n{\r\nstruct slic_rcvqueue *rcvq = &adapter->rcvqueue;\r\nvoid *paddr;\r\nu32 paddrl;\r\nu32 paddrh;\r\nstruct slic_rcvbuf *rcvbuf = (struct slic_rcvbuf *)skb->head;\r\nstruct device *dev;\r\nASSERT(skb->len == SLIC_RCVBUF_HEADSIZE);\r\npaddr = (void *)pci_map_single(adapter->pcidev, skb->head,\r\nSLIC_RCVQ_RCVBUFSIZE, PCI_DMA_FROMDEVICE);\r\nrcvbuf->status = 0;\r\nskb->next = NULL;\r\npaddrl = SLIC_GET_ADDR_LOW(paddr);\r\npaddrh = SLIC_GET_ADDR_HIGH(paddr);\r\nif (paddrl == 0) {\r\ndev = &adapter->netdev->dev;\r\ndev_err(dev, "%s: LOW 32bits PHYSICAL ADDRESS == 0\n",\r\n__func__);\r\ndev_err(dev, "skb[%p] PROBLEM\n", skb);\r\ndev_err(dev, " skbdata[%p]\n", skb->data);\r\ndev_err(dev, " skblen[%x]\n", skb->len);\r\ndev_err(dev, " paddr[%p]\n", paddr);\r\ndev_err(dev, " paddrl[%x]\n", paddrl);\r\ndev_err(dev, " paddrh[%x]\n", paddrh);\r\ndev_err(dev, " rcvq->head[%p]\n", rcvq->head);\r\ndev_err(dev, " rcvq->tail[%p]\n", rcvq->tail);\r\ndev_err(dev, " rcvq->count[%x]\n", rcvq->count);\r\n}\r\nif (paddrh == 0) {\r\nslic_reg32_write(&adapter->slic_regs->slic_hbar, (u32)paddrl,\r\nDONT_FLUSH);\r\n} else {\r\nslic_reg64_write(adapter, &adapter->slic_regs->slic_hbar64,\r\npaddrl, &adapter->slic_regs->slic_addr_upper,\r\npaddrh, DONT_FLUSH);\r\n}\r\nif (rcvq->head)\r\nrcvq->tail->next = skb;\r\nelse\r\nrcvq->head = skb;\r\nrcvq->tail = skb;\r\nrcvq->count++;\r\nreturn rcvq->count;\r\n}\r\nstatic int slic_debug_card_show(struct seq_file *seq, void *v)\r\n{\r\n#ifdef MOOKTODO\r\nint i;\r\nstruct sliccard *card = seq->private;\r\nstruct slic_config *config = &card->config;\r\nunsigned char *fru = (unsigned char *)(&card->config.atk_fru);\r\nunsigned char *oemfru = (unsigned char *)(&card->config.OemFru);\r\n#endif\r\nseq_printf(seq, "driver_version : %s\n", slic_proc_version);\r\nseq_printf(seq, "Microcode versions: \n");\r\nseq_printf(seq, " Gigabit (gb) : %s %s\n",\r\nMOJAVE_UCODE_VERS_STRING, MOJAVE_UCODE_VERS_DATE);\r\nseq_printf(seq, " Gigabit Receiver : %s %s\n",\r\nGB_RCVUCODE_VERS_STRING, GB_RCVUCODE_VERS_DATE);\r\nseq_printf(seq, "Vendor : %s\n", slic_vendor);\r\nseq_printf(seq, "Product Name : %s\n", slic_product_name);\r\n#ifdef MOOKTODO\r\nseq_printf(seq, "VendorId : %4.4X\n",\r\nconfig->VendorId);\r\nseq_printf(seq, "DeviceId : %4.4X\n",\r\nconfig->DeviceId);\r\nseq_printf(seq, "RevisionId : %2.2x\n",\r\nconfig->RevisionId);\r\nseq_printf(seq, "Bus # : %d\n", card->busnumber);\r\nseq_printf(seq, "Device # : %d\n", card->slotnumber);\r\nseq_printf(seq, "Interfaces : %d\n", card->card_size);\r\nseq_printf(seq, " Initialized : %d\n",\r\ncard->adapters_activated);\r\nseq_printf(seq, " Allocated : %d\n",\r\ncard->adapters_allocated);\r\nASSERT(card->card_size <= SLIC_NBR_MACS);\r\nfor (i = 0; i < card->card_size; i++) {\r\nseq_printf(seq,\r\n" MAC%d : %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X\n",\r\ni, config->macinfo[i].macaddrA[0],\r\nconfig->macinfo[i].macaddrA[1],\r\nconfig->macinfo[i].macaddrA[2],\r\nconfig->macinfo[i].macaddrA[3],\r\nconfig->macinfo[i].macaddrA[4],\r\nconfig->macinfo[i].macaddrA[5]);\r\n}\r\nseq_printf(seq, " IF Init State Duplex/Speed irq\n");\r\nseq_printf(seq, " -------------------------------\n");\r\nfor (i = 0; i < card->adapters_allocated; i++) {\r\nstruct adapter *adapter;\r\nadapter = card->adapter[i];\r\nif (adapter) {\r\nseq_printf(seq,\r\n" %d %d %s %s %s 0x%X\n",\r\nadapter->physport, adapter->state,\r\nSLIC_LINKSTATE(adapter->linkstate),\r\nSLIC_DUPLEX(adapter->linkduplex),\r\nSLIC_SPEED(adapter->linkspeed),\r\n(uint) adapter->irq);\r\n}\r\n}\r\nseq_printf(seq, "Generation # : %4.4X\n", card->gennumber);\r\nseq_printf(seq, "RcvQ max entries : %4.4X\n",\r\nSLIC_RCVQ_ENTRIES);\r\nseq_printf(seq, "Ping Status : %8.8X\n",\r\ncard->pingstatus);\r\nseq_printf(seq, "Minimum grant : %2.2x\n",\r\nconfig->MinGrant);\r\nseq_printf(seq, "Maximum Latency : %2.2x\n", config->MaxLat);\r\nseq_printf(seq, "PciStatus : %4.4x\n",\r\nconfig->Pcistatus);\r\nseq_printf(seq, "Debug Device Id : %4.4x\n",\r\nconfig->DbgDevId);\r\nseq_printf(seq, "DRAM ROM Function : %4.4x\n",\r\nconfig->DramRomFn);\r\nseq_printf(seq, "Network interface Pin 1 : %2.2x\n",\r\nconfig->NetIntPin1);\r\nseq_printf(seq, "Network interface Pin 2 : %2.2x\n",\r\nconfig->NetIntPin1);\r\nseq_printf(seq, "Network interface Pin 3 : %2.2x\n",\r\nconfig->NetIntPin1);\r\nseq_printf(seq, "PM capabilities : %4.4X\n",\r\nconfig->PMECapab);\r\nseq_printf(seq, "Network Clock Controls : %4.4X\n",\r\nconfig->NwClkCtrls);\r\nswitch (config->FruFormat) {\r\ncase ATK_FRU_FORMAT:\r\n{\r\nseq_printf(seq,\r\n"Vendor : Alacritech, Inc.\n");\r\nseq_printf(seq,\r\n"Assembly # : %c%c%c%c%c%c\n",\r\nfru[0], fru[1], fru[2], fru[3], fru[4],\r\nfru[5]);\r\nseq_printf(seq,\r\n"Revision # : %c%c\n",\r\nfru[6], fru[7]);\r\nif (config->OEMFruFormat == VENDOR4_FRU_FORMAT) {\r\nseq_printf(seq,\r\n"Serial # : "\r\n"%c%c%c%c%c%c%c%c%c%c%c%c\n",\r\nfru[8], fru[9], fru[10],\r\nfru[11], fru[12], fru[13],\r\nfru[16], fru[17], fru[18],\r\nfru[19], fru[20], fru[21]);\r\n} else {\r\nseq_printf(seq,\r\n"Serial # : "\r\n"%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n",\r\nfru[8], fru[9], fru[10],\r\nfru[11], fru[12], fru[13],\r\nfru[14], fru[15], fru[16],\r\nfru[17], fru[18], fru[19],\r\nfru[20], fru[21]);\r\n}\r\nbreak;\r\n}\r\ndefault:\r\n{\r\nseq_printf(seq,\r\n"Vendor : Alacritech, Inc.\n");\r\nseq_printf(seq,\r\n"Serial # : Empty FRU\n");\r\nbreak;\r\n}\r\n}\r\nswitch (config->OEMFruFormat) {\r\ncase VENDOR1_FRU_FORMAT:\r\n{\r\nseq_printf(seq, "FRU Information:\n");\r\nseq_printf(seq, " Commodity # : %c\n",\r\noemfru[0]);\r\nseq_printf(seq,\r\n" Assembly # : %c%c%c%c\n",\r\noemfru[1], oemfru[2], oemfru[3], oemfru[4]);\r\nseq_printf(seq,\r\n" Revision # : %c%c\n",\r\noemfru[5], oemfru[6]);\r\nseq_printf(seq,\r\n" Supplier # : %c%c\n",\r\noemfru[7], oemfru[8]);\r\nseq_printf(seq,\r\n" Date : %c%c\n",\r\noemfru[9], oemfru[10]);\r\nseq_sprintf(seq,\r\n" Sequence # : %c%c%c\n",\r\noemfru[11], oemfru[12], oemfru[13]);\r\nbreak;\r\n}\r\ncase VENDOR2_FRU_FORMAT:\r\n{\r\nseq_printf(seq, "FRU Information:\n");\r\nseq_printf(seq,\r\n" Part # : "\r\n"%c%c%c%c%c%c%c%c\n",\r\noemfru[0], oemfru[1], oemfru[2],\r\noemfru[3], oemfru[4], oemfru[5],\r\noemfru[6], oemfru[7]);\r\nseq_printf(seq,\r\n" Supplier # : %c%c%c%c%c\n",\r\noemfru[8], oemfru[9], oemfru[10],\r\noemfru[11], oemfru[12]);\r\nseq_printf(seq,\r\n" Date : %c%c%c\n",\r\noemfru[13], oemfru[14], oemfru[15]);\r\nseq_sprintf(seq,\r\n" Sequence # : %c%c%c%c\n",\r\noemfru[16], oemfru[17], oemfru[18],\r\noemfru[19]);\r\nbreak;\r\n}\r\ncase VENDOR3_FRU_FORMAT:\r\n{\r\nseq_printf(seq, "FRU Information:\n");\r\n}\r\ncase VENDOR4_FRU_FORMAT:\r\n{\r\nseq_printf(seq, "FRU Information:\n");\r\nseq_printf(seq,\r\n" FRU Number : "\r\n"%c%c%c%c%c%c%c%c\n",\r\noemfru[0], oemfru[1], oemfru[2],\r\noemfru[3], oemfru[4], oemfru[5],\r\noemfru[6], oemfru[7]);\r\nseq_sprintf(seq,\r\n" Part Number : "\r\n"%c%c%c%c%c%c%c%c\n",\r\noemfru[8], oemfru[9], oemfru[10],\r\noemfru[11], oemfru[12], oemfru[13],\r\noemfru[14], oemfru[15]);\r\nseq_printf(seq,\r\n" EC Level : "\r\n"%c%c%c%c%c%c%c%c\n",\r\noemfru[16], oemfru[17], oemfru[18],\r\noemfru[19], oemfru[20], oemfru[21],\r\noemfru[22], oemfru[23]);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int slic_debug_adapter_show(struct seq_file *seq, void *v)\r\n{\r\nstruct adapter *adapter = seq->private;\r\nstruct net_device *netdev = adapter->netdev;\r\nseq_printf(seq, "info: interface : %s\n",\r\nadapter->netdev->name);\r\nseq_printf(seq, "info: status : %s\n",\r\nSLIC_LINKSTATE(adapter->linkstate));\r\nseq_printf(seq, "info: port : %d\n",\r\nadapter->physport);\r\nseq_printf(seq, "info: speed : %s\n",\r\nSLIC_SPEED(adapter->linkspeed));\r\nseq_printf(seq, "info: duplex : %s\n",\r\nSLIC_DUPLEX(adapter->linkduplex));\r\nseq_printf(seq, "info: irq : 0x%X\n",\r\n(uint) adapter->irq);\r\nseq_printf(seq, "info: Interrupt Agg Delay: %d usec\n",\r\nadapter->card->loadlevel_current);\r\nseq_printf(seq, "info: RcvQ max entries : %4.4X\n",\r\nSLIC_RCVQ_ENTRIES);\r\nseq_printf(seq, "info: RcvQ current : %4.4X\n",\r\nadapter->rcvqueue.count);\r\nseq_printf(seq, "rx stats: packets : %8.8lX\n",\r\nnetdev->stats.rx_packets);\r\nseq_printf(seq, "rx stats: bytes : %8.8lX\n",\r\nnetdev->stats.rx_bytes);\r\nseq_printf(seq, "rx stats: broadcasts : %8.8X\n",\r\nadapter->rcv_broadcasts);\r\nseq_printf(seq, "rx stats: multicasts : %8.8X\n",\r\nadapter->rcv_multicasts);\r\nseq_printf(seq, "rx stats: unicasts : %8.8X\n",\r\nadapter->rcv_unicasts);\r\nseq_printf(seq, "rx stats: errors : %8.8X\n",\r\n(u32) adapter->slic_stats.iface.rcv_errors);\r\nseq_printf(seq, "rx stats: Missed errors : %8.8X\n",\r\n(u32) adapter->slic_stats.iface.rcv_discards);\r\nseq_printf(seq, "rx stats: drops : %8.8X\n",\r\n(u32) adapter->rcv_drops);\r\nseq_printf(seq, "tx stats: packets : %8.8lX\n",\r\nnetdev->stats.tx_packets);\r\nseq_printf(seq, "tx stats: bytes : %8.8lX\n",\r\nnetdev->stats.tx_bytes);\r\nseq_printf(seq, "tx stats: errors : %8.8X\n",\r\n(u32) adapter->slic_stats.iface.xmt_errors);\r\nseq_printf(seq, "rx stats: multicasts : %8.8lX\n",\r\nnetdev->stats.multicast);\r\nseq_printf(seq, "tx stats: collision errors : %8.8X\n",\r\n(u32) adapter->slic_stats.iface.xmit_collisions);\r\nseq_printf(seq, "perf: Max rcv frames/isr : %8.8X\n",\r\nadapter->max_isr_rcvs);\r\nseq_printf(seq, "perf: Rcv interrupt yields : %8.8X\n",\r\nadapter->rcv_interrupt_yields);\r\nseq_printf(seq, "perf: Max xmit complete/isr : %8.8X\n",\r\nadapter->max_isr_xmits);\r\nseq_printf(seq, "perf: error interrupts : %8.8X\n",\r\nadapter->error_interrupts);\r\nseq_printf(seq, "perf: error rmiss interrupts : %8.8X\n",\r\nadapter->error_rmiss_interrupts);\r\nseq_printf(seq, "perf: rcv interrupts : %8.8X\n",\r\nadapter->rcv_interrupts);\r\nseq_printf(seq, "perf: xmit interrupts : %8.8X\n",\r\nadapter->xmit_interrupts);\r\nseq_printf(seq, "perf: link event interrupts : %8.8X\n",\r\nadapter->linkevent_interrupts);\r\nseq_printf(seq, "perf: UPR interrupts : %8.8X\n",\r\nadapter->upr_interrupts);\r\nseq_printf(seq, "perf: interrupt count : %8.8X\n",\r\nadapter->num_isrs);\r\nseq_printf(seq, "perf: false interrupts : %8.8X\n",\r\nadapter->false_interrupts);\r\nseq_printf(seq, "perf: All register writes : %8.8X\n",\r\nadapter->all_reg_writes);\r\nseq_printf(seq, "perf: ICR register writes : %8.8X\n",\r\nadapter->icr_reg_writes);\r\nseq_printf(seq, "perf: ISR register writes : %8.8X\n",\r\nadapter->isr_reg_writes);\r\nseq_printf(seq, "ifevents: overflow 802 errors : %8.8X\n",\r\nadapter->if_events.oflow802);\r\nseq_printf(seq, "ifevents: transport overflow errors: %8.8X\n",\r\nadapter->if_events.Tprtoflow);\r\nseq_printf(seq, "ifevents: underflow errors : %8.8X\n",\r\nadapter->if_events.uflow802);\r\nseq_printf(seq, "ifevents: receive early : %8.8X\n",\r\nadapter->if_events.rcvearly);\r\nseq_printf(seq, "ifevents: buffer overflows : %8.8X\n",\r\nadapter->if_events.Bufov);\r\nseq_printf(seq, "ifevents: carrier errors : %8.8X\n",\r\nadapter->if_events.Carre);\r\nseq_printf(seq, "ifevents: Long : %8.8X\n",\r\nadapter->if_events.Longe);\r\nseq_printf(seq, "ifevents: invalid preambles : %8.8X\n",\r\nadapter->if_events.Invp);\r\nseq_printf(seq, "ifevents: CRC errors : %8.8X\n",\r\nadapter->if_events.Crc);\r\nseq_printf(seq, "ifevents: dribble nibbles : %8.8X\n",\r\nadapter->if_events.Drbl);\r\nseq_printf(seq, "ifevents: Code violations : %8.8X\n",\r\nadapter->if_events.Code);\r\nseq_printf(seq, "ifevents: TCP checksum errors : %8.8X\n",\r\nadapter->if_events.TpCsum);\r\nseq_printf(seq, "ifevents: TCP header short errors : %8.8X\n",\r\nadapter->if_events.TpHlen);\r\nseq_printf(seq, "ifevents: IP checksum errors : %8.8X\n",\r\nadapter->if_events.IpCsum);\r\nseq_printf(seq, "ifevents: IP frame incompletes : %8.8X\n",\r\nadapter->if_events.IpLen);\r\nseq_printf(seq, "ifevents: IP headers shorts : %8.8X\n",\r\nadapter->if_events.IpHlen);\r\nreturn 0;\r\n}\r\nstatic int slic_debug_adapter_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, slic_debug_adapter_show, inode->i_private);\r\n}\r\nstatic int slic_debug_card_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, slic_debug_card_show, inode->i_private);\r\n}\r\nstatic void slic_debug_adapter_create(struct adapter *adapter)\r\n{\r\nstruct dentry *d;\r\nchar name[7];\r\nstruct sliccard *card = adapter->card;\r\nif (!card->debugfs_dir)\r\nreturn;\r\nsprintf(name, "port%d", adapter->port);\r\nd = debugfs_create_file(name, S_IRUGO,\r\ncard->debugfs_dir, adapter,\r\n&slic_debug_adapter_fops);\r\nif (!d || IS_ERR(d))\r\npr_info(PFX "%s: debugfs create failed\n", name);\r\nelse\r\nadapter->debugfs_entry = d;\r\n}\r\nstatic void slic_debug_adapter_destroy(struct adapter *adapter)\r\n{\r\ndebugfs_remove(adapter->debugfs_entry);\r\nadapter->debugfs_entry = NULL;\r\n}\r\nstatic void slic_debug_card_create(struct sliccard *card)\r\n{\r\nstruct dentry *d;\r\nchar name[IFNAMSIZ];\r\nsnprintf(name, sizeof(name), "slic%d", card->cardnum);\r\nd = debugfs_create_dir(name, slic_debugfs);\r\nif (!d || IS_ERR(d))\r\npr_info(PFX "%s: debugfs create dir failed\n",\r\nname);\r\nelse {\r\ncard->debugfs_dir = d;\r\nd = debugfs_create_file("cardinfo", S_IRUGO,\r\nslic_debugfs, card,\r\n&slic_debug_card_fops);\r\nif (!d || IS_ERR(d))\r\npr_info(PFX "%s: debugfs create failed\n",\r\nname);\r\nelse\r\ncard->debugfs_cardinfo = d;\r\n}\r\n}\r\nstatic void slic_debug_card_destroy(struct sliccard *card)\r\n{\r\nint i;\r\nfor (i = 0; i < card->card_size; i++) {\r\nstruct adapter *adapter;\r\nadapter = card->adapter[i];\r\nif (adapter)\r\nslic_debug_adapter_destroy(adapter);\r\n}\r\nif (card->debugfs_cardinfo) {\r\ndebugfs_remove(card->debugfs_cardinfo);\r\ncard->debugfs_cardinfo = NULL;\r\n}\r\nif (card->debugfs_dir) {\r\ndebugfs_remove(card->debugfs_dir);\r\ncard->debugfs_dir = NULL;\r\n}\r\n}\r\nstatic void slic_debug_init(void)\r\n{\r\nstruct dentry *ent;\r\nent = debugfs_create_dir("slic", NULL);\r\nif (!ent || IS_ERR(ent)) {\r\npr_info(PFX "debugfs create directory failed\n");\r\nreturn;\r\n}\r\nslic_debugfs = ent;\r\n}\r\nstatic void slic_debug_cleanup(void)\r\n{\r\nif (slic_debugfs) {\r\ndebugfs_remove(slic_debugfs);\r\nslic_debugfs = NULL;\r\n}\r\n}\r\nstatic void slic_link_event_handler(struct adapter *adapter)\r\n{\r\nint status;\r\nstruct slic_shmem *pshmem;\r\nif (adapter->state != ADAPT_UP) {\r\nreturn;\r\n}\r\npshmem = (struct slic_shmem *)adapter->phys_shmem;\r\n#if BITS_PER_LONG == 64\r\nstatus = slic_upr_request(adapter,\r\nSLIC_UPR_RLSR,\r\nSLIC_GET_ADDR_LOW(&pshmem->linkstatus),\r\nSLIC_GET_ADDR_HIGH(&pshmem->linkstatus),\r\n0, 0);\r\n#else\r\nstatus = slic_upr_request(adapter, SLIC_UPR_RLSR,\r\n(u32) &pshmem->linkstatus,\r\n0, 0, 0);\r\n#endif\r\nASSERT(status == 0);\r\n}\r\nstatic void slic_init_cleanup(struct adapter *adapter)\r\n{\r\nif (adapter->intrregistered) {\r\nadapter->intrregistered = 0;\r\nfree_irq(adapter->netdev->irq, adapter->netdev);\r\n}\r\nif (adapter->pshmem) {\r\npci_free_consistent(adapter->pcidev,\r\nsizeof(struct slic_shmem),\r\nadapter->pshmem, adapter->phys_shmem);\r\nadapter->pshmem = NULL;\r\nadapter->phys_shmem = (dma_addr_t) NULL;\r\n}\r\nif (adapter->pingtimerset) {\r\nadapter->pingtimerset = 0;\r\ndel_timer(&adapter->pingtimer);\r\n}\r\nslic_rspqueue_free(adapter);\r\nslic_cmdq_free(adapter);\r\nslic_rcvqueue_free(adapter);\r\n}\r\nstatic int slic_mcast_add_list(struct adapter *adapter, char *address)\r\n{\r\nstruct mcast_address *mcaddr, *mlist;\r\nmlist = adapter->mcastaddrs;\r\nwhile (mlist) {\r\nif (!compare_ether_addr(mlist->address, address))\r\nreturn 0;\r\nmlist = mlist->next;\r\n}\r\nmcaddr = kmalloc(sizeof(struct mcast_address), GFP_ATOMIC);\r\nif (mcaddr == NULL)\r\nreturn 1;\r\nmemcpy(mcaddr->address, address, 6);\r\nmcaddr->next = adapter->mcastaddrs;\r\nadapter->mcastaddrs = mcaddr;\r\nreturn 0;\r\n}\r\nstatic void slic_mcast_set_list(struct net_device *dev)\r\n{\r\nstruct adapter *adapter = netdev_priv(dev);\r\nint status = 0;\r\nchar *addresses;\r\nstruct netdev_hw_addr *ha;\r\nASSERT(adapter);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\naddresses = (char *) &ha->addr;\r\nstatus = slic_mcast_add_list(adapter, addresses);\r\nif (status != 0)\r\nbreak;\r\nslic_mcast_set_bit(adapter, addresses);\r\n}\r\nif (adapter->devflags_prev != dev->flags) {\r\nadapter->macopts = MAC_DIRECTED;\r\nif (dev->flags) {\r\nif (dev->flags & IFF_BROADCAST)\r\nadapter->macopts |= MAC_BCAST;\r\nif (dev->flags & IFF_PROMISC)\r\nadapter->macopts |= MAC_PROMISC;\r\nif (dev->flags & IFF_ALLMULTI)\r\nadapter->macopts |= MAC_ALLMCAST;\r\nif (dev->flags & IFF_MULTICAST)\r\nadapter->macopts |= MAC_MCAST;\r\n}\r\nadapter->devflags_prev = dev->flags;\r\nslic_config_set(adapter, true);\r\n} else {\r\nif (status == 0)\r\nslic_mcast_set_mask(adapter);\r\n}\r\nreturn;\r\n}\r\nstatic void slic_xmit_build_request(struct adapter *adapter,\r\nstruct slic_hostcmd *hcmd, struct sk_buff *skb)\r\n{\r\nstruct slic_host64_cmd *ihcmd;\r\nulong phys_addr;\r\nihcmd = &hcmd->cmd64;\r\nihcmd->flags = (adapter->port << IHFLG_IFSHFT);\r\nihcmd->command = IHCMD_XMT_REQ;\r\nihcmd->u.slic_buffers.totlen = skb->len;\r\nphys_addr = pci_map_single(adapter->pcidev, skb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\nihcmd->u.slic_buffers.bufs[0].paddrl = SLIC_GET_ADDR_LOW(phys_addr);\r\nihcmd->u.slic_buffers.bufs[0].paddrh = SLIC_GET_ADDR_HIGH(phys_addr);\r\nihcmd->u.slic_buffers.bufs[0].length = skb->len;\r\n#if BITS_PER_LONG == 64\r\nhcmd->cmdsize = (u32) ((((u64)&ihcmd->u.slic_buffers.bufs[1] -\r\n(u64) hcmd) + 31) >> 5);\r\n#else\r\nhcmd->cmdsize = ((((u32) &ihcmd->u.slic_buffers.bufs[1] -\r\n(u32) hcmd) + 31) >> 5);\r\n#endif\r\n}\r\nstatic void slic_xmit_fail(struct adapter *adapter,\r\nstruct sk_buff *skb,\r\nvoid *cmd, u32 skbtype, u32 status)\r\n{\r\nif (adapter->xmitq_full)\r\nnetif_stop_queue(adapter->netdev);\r\nif ((cmd == NULL) && (status <= XMIT_FAIL_HOSTCMD_FAIL)) {\r\nswitch (status) {\r\ncase XMIT_FAIL_LINK_STATE:\r\ndev_err(&adapter->netdev->dev,\r\n"reject xmit skb[%p: %x] linkstate[%s] "\r\n"adapter[%s:%d] card[%s:%d]\n",\r\nskb, skb->pkt_type,\r\nSLIC_LINKSTATE(adapter->linkstate),\r\nSLIC_ADAPTER_STATE(adapter->state),\r\nadapter->state,\r\nSLIC_CARD_STATE(adapter->card->state),\r\nadapter->card->state);\r\nbreak;\r\ncase XMIT_FAIL_ZERO_LENGTH:\r\ndev_err(&adapter->netdev->dev,\r\n"xmit_start skb->len == 0 skb[%p] type[%x]\n",\r\nskb, skb->pkt_type);\r\nbreak;\r\ncase XMIT_FAIL_HOSTCMD_FAIL:\r\ndev_err(&adapter->netdev->dev,\r\n"xmit_start skb[%p] type[%x] No host commands "\r\n"available\n", skb, skb->pkt_type);\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\n}\r\n}\r\ndev_kfree_skb(skb);\r\nadapter->netdev->stats.tx_dropped++;\r\n}\r\nstatic void slic_rcv_handle_error(struct adapter *adapter,\r\nstruct slic_rcvbuf *rcvbuf)\r\n{\r\nstruct slic_hddr_wds *hdr = (struct slic_hddr_wds *)rcvbuf->data;\r\nstruct net_device *netdev = adapter->netdev;\r\nif (adapter->devid != SLIC_1GB_DEVICE_ID) {\r\nif (hdr->frame_status14 & VRHSTAT_802OE)\r\nadapter->if_events.oflow802++;\r\nif (hdr->frame_status14 & VRHSTAT_TPOFLO)\r\nadapter->if_events.Tprtoflow++;\r\nif (hdr->frame_status_b14 & VRHSTATB_802UE)\r\nadapter->if_events.uflow802++;\r\nif (hdr->frame_status_b14 & VRHSTATB_RCVE) {\r\nadapter->if_events.rcvearly++;\r\nnetdev->stats.rx_fifo_errors++;\r\n}\r\nif (hdr->frame_status_b14 & VRHSTATB_BUFF) {\r\nadapter->if_events.Bufov++;\r\nnetdev->stats.rx_over_errors++;\r\n}\r\nif (hdr->frame_status_b14 & VRHSTATB_CARRE) {\r\nadapter->if_events.Carre++;\r\nnetdev->stats.tx_carrier_errors++;\r\n}\r\nif (hdr->frame_status_b14 & VRHSTATB_LONGE)\r\nadapter->if_events.Longe++;\r\nif (hdr->frame_status_b14 & VRHSTATB_PREA)\r\nadapter->if_events.Invp++;\r\nif (hdr->frame_status_b14 & VRHSTATB_CRC) {\r\nadapter->if_events.Crc++;\r\nnetdev->stats.rx_crc_errors++;\r\n}\r\nif (hdr->frame_status_b14 & VRHSTATB_DRBL)\r\nadapter->if_events.Drbl++;\r\nif (hdr->frame_status_b14 & VRHSTATB_CODE)\r\nadapter->if_events.Code++;\r\nif (hdr->frame_status_b14 & VRHSTATB_TPCSUM)\r\nadapter->if_events.TpCsum++;\r\nif (hdr->frame_status_b14 & VRHSTATB_TPHLEN)\r\nadapter->if_events.TpHlen++;\r\nif (hdr->frame_status_b14 & VRHSTATB_IPCSUM)\r\nadapter->if_events.IpCsum++;\r\nif (hdr->frame_status_b14 & VRHSTATB_IPLERR)\r\nadapter->if_events.IpLen++;\r\nif (hdr->frame_status_b14 & VRHSTATB_IPHERR)\r\nadapter->if_events.IpHlen++;\r\n} else {\r\nif (hdr->frame_statusGB & VGBSTAT_XPERR) {\r\nu32 xerr = hdr->frame_statusGB >> VGBSTAT_XERRSHFT;\r\nif (xerr == VGBSTAT_XCSERR)\r\nadapter->if_events.TpCsum++;\r\nif (xerr == VGBSTAT_XUFLOW)\r\nadapter->if_events.Tprtoflow++;\r\nif (xerr == VGBSTAT_XHLEN)\r\nadapter->if_events.TpHlen++;\r\n}\r\nif (hdr->frame_statusGB & VGBSTAT_NETERR) {\r\nu32 nerr =\r\n(hdr->\r\nframe_statusGB >> VGBSTAT_NERRSHFT) &\r\nVGBSTAT_NERRMSK;\r\nif (nerr == VGBSTAT_NCSERR)\r\nadapter->if_events.IpCsum++;\r\nif (nerr == VGBSTAT_NUFLOW)\r\nadapter->if_events.IpLen++;\r\nif (nerr == VGBSTAT_NHLEN)\r\nadapter->if_events.IpHlen++;\r\n}\r\nif (hdr->frame_statusGB & VGBSTAT_LNKERR) {\r\nu32 lerr = hdr->frame_statusGB & VGBSTAT_LERRMSK;\r\nif (lerr == VGBSTAT_LDEARLY)\r\nadapter->if_events.rcvearly++;\r\nif (lerr == VGBSTAT_LBOFLO)\r\nadapter->if_events.Bufov++;\r\nif (lerr == VGBSTAT_LCODERR)\r\nadapter->if_events.Code++;\r\nif (lerr == VGBSTAT_LDBLNBL)\r\nadapter->if_events.Drbl++;\r\nif (lerr == VGBSTAT_LCRCERR)\r\nadapter->if_events.Crc++;\r\nif (lerr == VGBSTAT_LOFLO)\r\nadapter->if_events.oflow802++;\r\nif (lerr == VGBSTAT_LUFLO)\r\nadapter->if_events.uflow802++;\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic void slic_rcv_handler(struct adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct sk_buff *skb;\r\nstruct slic_rcvbuf *rcvbuf;\r\nu32 frames = 0;\r\nwhile ((skb = slic_rcvqueue_getnext(adapter))) {\r\nu32 rx_bytes;\r\nASSERT(skb->head);\r\nrcvbuf = (struct slic_rcvbuf *)skb->head;\r\nadapter->card->events++;\r\nif (rcvbuf->status & IRHDDR_ERR) {\r\nadapter->rx_errors++;\r\nslic_rcv_handle_error(adapter, rcvbuf);\r\nslic_rcvqueue_reinsert(adapter, skb);\r\ncontinue;\r\n}\r\nif (!slic_mac_filter(adapter, (struct ether_header *)\r\nrcvbuf->data)) {\r\nslic_rcvqueue_reinsert(adapter, skb);\r\ncontinue;\r\n}\r\nskb_pull(skb, SLIC_RCVBUF_HEADSIZE);\r\nrx_bytes = (rcvbuf->length & IRHDDR_FLEN_MSK);\r\nskb_put(skb, rx_bytes);\r\nnetdev->stats.rx_packets++;\r\nnetdev->stats.rx_bytes += rx_bytes;\r\n#if SLIC_OFFLOAD_IP_CHECKSUM\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n#endif\r\nskb->dev = adapter->netdev;\r\nskb->protocol = eth_type_trans(skb, skb->dev);\r\nnetif_rx(skb);\r\n++frames;\r\n#if SLIC_INTERRUPT_PROCESS_LIMIT\r\nif (frames >= SLIC_RCVQ_MAX_PROCESS_ISR) {\r\nadapter->rcv_interrupt_yields++;\r\nbreak;\r\n}\r\n#endif\r\n}\r\nadapter->max_isr_rcvs = max(adapter->max_isr_rcvs, frames);\r\n}\r\nstatic void slic_xmit_complete(struct adapter *adapter)\r\n{\r\nstruct slic_hostcmd *hcmd;\r\nstruct slic_rspbuf *rspbuf;\r\nu32 frames = 0;\r\nstruct slic_handle_word slic_handle_word;\r\ndo {\r\nrspbuf = slic_rspqueue_getnext(adapter);\r\nif (!rspbuf)\r\nbreak;\r\nadapter->xmit_completes++;\r\nadapter->card->events++;\r\nslic_handle_word.handle_token = rspbuf->hosthandle;\r\nASSERT(slic_handle_word.handle_index);\r\nASSERT(slic_handle_word.handle_index <= SLIC_CMDQ_MAXCMDS);\r\nhcmd =\r\n(struct slic_hostcmd *)\r\nadapter->slic_handles[slic_handle_word.handle_index].\r\naddress;\r\nASSERT(hcmd);\r\nASSERT(hcmd->pslic_handle ==\r\n&adapter->slic_handles[slic_handle_word.handle_index]);\r\nif (hcmd->type == SLIC_CMD_DUMB) {\r\nif (hcmd->skb)\r\ndev_kfree_skb_irq(hcmd->skb);\r\nslic_cmdq_putdone_irq(adapter, hcmd);\r\n}\r\nrspbuf->status = 0;\r\nrspbuf->hosthandle = 0;\r\nframes++;\r\n} while (1);\r\nadapter->max_isr_xmits = max(adapter->max_isr_xmits, frames);\r\n}\r\nstatic irqreturn_t slic_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct adapter *adapter = netdev_priv(dev);\r\nu32 isr;\r\nif ((adapter->pshmem) && (adapter->pshmem->isr)) {\r\nslic_reg32_write(&adapter->slic_regs->slic_icr,\r\nICR_INT_MASK, FLUSH);\r\nisr = adapter->isrcopy = adapter->pshmem->isr;\r\nadapter->pshmem->isr = 0;\r\nadapter->num_isrs++;\r\nswitch (adapter->card->state) {\r\ncase CARD_UP:\r\nif (isr & ~ISR_IO) {\r\nif (isr & ISR_ERR) {\r\nadapter->error_interrupts++;\r\nif (isr & ISR_RMISS) {\r\nint count;\r\nint pre_count;\r\nint errors;\r\nstruct slic_rcvqueue *rcvq =\r\n&adapter->rcvqueue;\r\nadapter->\r\nerror_rmiss_interrupts++;\r\nif (!rcvq->errors)\r\nrcv_count = rcvq->count;\r\npre_count = rcvq->count;\r\nerrors = rcvq->errors;\r\nwhile (rcvq->count <\r\nSLIC_RCVQ_FILLTHRESH) {\r\ncount =\r\nslic_rcvqueue_fill\r\n(adapter);\r\nif (!count)\r\nbreak;\r\n}\r\n} else if (isr & ISR_XDROP) {\r\ndev_err(&dev->dev,\r\n"isr & ISR_ERR [%x] "\r\n"ISR_XDROP \n", isr);\r\n} else {\r\ndev_err(&dev->dev,\r\n"isr & ISR_ERR [%x]\n",\r\nisr);\r\n}\r\n}\r\nif (isr & ISR_LEVENT) {\r\nadapter->linkevent_interrupts++;\r\nslic_link_event_handler(adapter);\r\n}\r\nif ((isr & ISR_UPC) ||\r\n(isr & ISR_UPCERR) || (isr & ISR_UPCBSY)) {\r\nadapter->upr_interrupts++;\r\nslic_upr_request_complete(adapter, isr);\r\n}\r\n}\r\nif (isr & ISR_RCV) {\r\nadapter->rcv_interrupts++;\r\nslic_rcv_handler(adapter);\r\n}\r\nif (isr & ISR_CMD) {\r\nadapter->xmit_interrupts++;\r\nslic_xmit_complete(adapter);\r\n}\r\nbreak;\r\ncase CARD_DOWN:\r\nif ((isr & ISR_UPC) ||\r\n(isr & ISR_UPCERR) || (isr & ISR_UPCBSY)) {\r\nadapter->upr_interrupts++;\r\nslic_upr_request_complete(adapter, isr);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nadapter->isrcopy = 0;\r\nadapter->all_reg_writes += 2;\r\nadapter->isr_reg_writes++;\r\nslic_reg32_write(&adapter->slic_regs->slic_isr, 0, FLUSH);\r\n} else {\r\nadapter->false_interrupts++;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic netdev_tx_t slic_xmit_start(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct sliccard *card;\r\nstruct adapter *adapter = netdev_priv(dev);\r\nstruct slic_hostcmd *hcmd = NULL;\r\nu32 status = 0;\r\nu32 skbtype = NORMAL_ETHFRAME;\r\nvoid *offloadcmd = NULL;\r\ncard = adapter->card;\r\nASSERT(card);\r\nif ((adapter->linkstate != LINK_UP) ||\r\n(adapter->state != ADAPT_UP) || (card->state != CARD_UP)) {\r\nstatus = XMIT_FAIL_LINK_STATE;\r\ngoto xmit_fail;\r\n} else if (skb->len == 0) {\r\nstatus = XMIT_FAIL_ZERO_LENGTH;\r\ngoto xmit_fail;\r\n}\r\nif (skbtype == NORMAL_ETHFRAME) {\r\nhcmd = slic_cmdq_getfree(adapter);\r\nif (!hcmd) {\r\nadapter->xmitq_full = 1;\r\nstatus = XMIT_FAIL_HOSTCMD_FAIL;\r\ngoto xmit_fail;\r\n}\r\nASSERT(hcmd->pslic_handle);\r\nASSERT(hcmd->cmd64.hosthandle ==\r\nhcmd->pslic_handle->token.handle_token);\r\nhcmd->skb = skb;\r\nhcmd->busy = 1;\r\nhcmd->type = SLIC_CMD_DUMB;\r\nif (skbtype == NORMAL_ETHFRAME)\r\nslic_xmit_build_request(adapter, hcmd, skb);\r\n}\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\n#ifdef DEBUG_DUMP\r\nif (adapter->kill_card) {\r\nstruct slic_host64_cmd ihcmd;\r\nihcmd = &hcmd->cmd64;\r\nihcmd->flags |= 0x40;\r\nadapter->kill_card = 0;\r\n}\r\n#endif\r\nif (hcmd->paddrh == 0) {\r\nslic_reg32_write(&adapter->slic_regs->slic_cbar,\r\n(hcmd->paddrl | hcmd->cmdsize), DONT_FLUSH);\r\n} else {\r\nslic_reg64_write(adapter, &adapter->slic_regs->slic_cbar64,\r\n(hcmd->paddrl | hcmd->cmdsize),\r\n&adapter->slic_regs->slic_addr_upper,\r\nhcmd->paddrh, DONT_FLUSH);\r\n}\r\nxmit_done:\r\nreturn NETDEV_TX_OK;\r\nxmit_fail:\r\nslic_xmit_fail(adapter, skb, offloadcmd, skbtype, status);\r\ngoto xmit_done;\r\n}\r\nstatic void slic_adapter_freeresources(struct adapter *adapter)\r\n{\r\nslic_init_cleanup(adapter);\r\nadapter->error_interrupts = 0;\r\nadapter->rcv_interrupts = 0;\r\nadapter->xmit_interrupts = 0;\r\nadapter->linkevent_interrupts = 0;\r\nadapter->upr_interrupts = 0;\r\nadapter->num_isrs = 0;\r\nadapter->xmit_completes = 0;\r\nadapter->rcv_broadcasts = 0;\r\nadapter->rcv_multicasts = 0;\r\nadapter->rcv_unicasts = 0;\r\n}\r\nstatic int slic_adapter_allocresources(struct adapter *adapter)\r\n{\r\nif (!adapter->intrregistered) {\r\nint retval;\r\nspin_unlock_irqrestore(&slic_global.driver_lock.lock,\r\nslic_global.driver_lock.flags);\r\nretval = request_irq(adapter->netdev->irq,\r\n&slic_interrupt,\r\nIRQF_SHARED,\r\nadapter->netdev->name, adapter->netdev);\r\nspin_lock_irqsave(&slic_global.driver_lock.lock,\r\nslic_global.driver_lock.flags);\r\nif (retval) {\r\ndev_err(&adapter->netdev->dev,\r\n"request_irq (%s) FAILED [%x]\n",\r\nadapter->netdev->name, retval);\r\nreturn retval;\r\n}\r\nadapter->intrregistered = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int slic_if_init(struct adapter *adapter)\r\n{\r\nstruct sliccard *card = adapter->card;\r\nstruct net_device *dev = adapter->netdev;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nstruct slic_shmem *pshmem;\r\nint rc;\r\nASSERT(card);\r\nif (adapter->state != ADAPT_DOWN) {\r\ndev_err(&dev->dev, "%s: adapter->state != ADAPT_DOWN\n",\r\n__func__);\r\nrc = -EIO;\r\ngoto err;\r\n}\r\nASSERT(adapter->linkstate == LINK_DOWN);\r\nadapter->devflags_prev = dev->flags;\r\nadapter->macopts = MAC_DIRECTED;\r\nif (dev->flags) {\r\nif (dev->flags & IFF_BROADCAST)\r\nadapter->macopts |= MAC_BCAST;\r\nif (dev->flags & IFF_PROMISC)\r\nadapter->macopts |= MAC_PROMISC;\r\nif (dev->flags & IFF_ALLMULTI)\r\nadapter->macopts |= MAC_ALLMCAST;\r\nif (dev->flags & IFF_MULTICAST)\r\nadapter->macopts |= MAC_MCAST;\r\n}\r\nrc = slic_adapter_allocresources(adapter);\r\nif (rc) {\r\ndev_err(&dev->dev,\r\n"%s: slic_adapter_allocresources FAILED %x\n",\r\n__func__, rc);\r\nslic_adapter_freeresources(adapter);\r\ngoto err;\r\n}\r\nif (!adapter->queues_initialized) {\r\nif ((rc = slic_rspqueue_init(adapter)))\r\ngoto err;\r\nif ((rc = slic_cmdq_init(adapter)))\r\ngoto err;\r\nif ((rc = slic_rcvqueue_init(adapter)))\r\ngoto err;\r\nadapter->queues_initialized = 1;\r\n}\r\nslic_reg32_write(&slic_regs->slic_icr, ICR_INT_OFF, FLUSH);\r\nmdelay(1);\r\nif (!adapter->isp_initialized) {\r\npshmem = (struct slic_shmem *)adapter->phys_shmem;\r\nspin_lock_irqsave(&adapter->bit64reglock.lock,\r\nadapter->bit64reglock.flags);\r\n#if BITS_PER_LONG == 64\r\nslic_reg32_write(&slic_regs->slic_addr_upper,\r\nSLIC_GET_ADDR_HIGH(&pshmem->isr), DONT_FLUSH);\r\nslic_reg32_write(&slic_regs->slic_isp,\r\nSLIC_GET_ADDR_LOW(&pshmem->isr), FLUSH);\r\n#else\r\nslic_reg32_write(&slic_regs->slic_addr_upper, 0, DONT_FLUSH);\r\nslic_reg32_write(&slic_regs->slic_isp, (u32)&pshmem->isr, FLUSH);\r\n#endif\r\nspin_unlock_irqrestore(&adapter->bit64reglock.lock,\r\nadapter->bit64reglock.flags);\r\nadapter->isp_initialized = 1;\r\n}\r\nadapter->state = ADAPT_UP;\r\nif (!card->loadtimerset) {\r\ninit_timer(&card->loadtimer);\r\ncard->loadtimer.expires =\r\njiffies + (SLIC_LOADTIMER_PERIOD * HZ);\r\ncard->loadtimer.data = (ulong) card;\r\ncard->loadtimer.function = &slic_timer_load_check;\r\nadd_timer(&card->loadtimer);\r\ncard->loadtimerset = 1;\r\n}\r\nif (!adapter->pingtimerset) {\r\ninit_timer(&adapter->pingtimer);\r\nadapter->pingtimer.expires =\r\njiffies + (PING_TIMER_INTERVAL * HZ);\r\nadapter->pingtimer.data = (ulong) dev;\r\nadapter->pingtimer.function = &slic_timer_ping;\r\nadd_timer(&adapter->pingtimer);\r\nadapter->pingtimerset = 1;\r\nadapter->card->pingstatus = ISR_PINGMASK;\r\n}\r\nadapter->isrcopy = 0;\r\nadapter->pshmem->isr = 0;\r\nslic_reg32_write(&slic_regs->slic_isr, 0, FLUSH);\r\nslic_reg32_write(&slic_regs->slic_icr, ICR_INT_ON, FLUSH);\r\nslic_link_config(adapter, LINK_AUTOSPEED, LINK_AUTOD);\r\nslic_link_event_handler(adapter);\r\nerr:\r\nreturn rc;\r\n}\r\nstatic int slic_entry_open(struct net_device *dev)\r\n{\r\nstruct adapter *adapter = netdev_priv(dev);\r\nstruct sliccard *card = adapter->card;\r\nu32 locked = 0;\r\nint status;\r\nASSERT(adapter);\r\nASSERT(card);\r\nnetif_stop_queue(adapter->netdev);\r\nspin_lock_irqsave(&slic_global.driver_lock.lock,\r\nslic_global.driver_lock.flags);\r\nlocked = 1;\r\nif (!adapter->activated) {\r\ncard->adapters_activated++;\r\nslic_global.num_slic_ports_active++;\r\nadapter->activated = 1;\r\n}\r\nstatus = slic_if_init(adapter);\r\nif (status != 0) {\r\nif (adapter->activated) {\r\ncard->adapters_activated--;\r\nslic_global.num_slic_ports_active--;\r\nadapter->activated = 0;\r\n}\r\nif (locked) {\r\nspin_unlock_irqrestore(&slic_global.driver_lock.lock,\r\nslic_global.driver_lock.flags);\r\nlocked = 0;\r\n}\r\nreturn status;\r\n}\r\nif (!card->master)\r\ncard->master = adapter;\r\nif (locked) {\r\nspin_unlock_irqrestore(&slic_global.driver_lock.lock,\r\nslic_global.driver_lock.flags);\r\nlocked = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void slic_card_cleanup(struct sliccard *card)\r\n{\r\nif (card->loadtimerset) {\r\ncard->loadtimerset = 0;\r\ndel_timer(&card->loadtimer);\r\n}\r\nslic_debug_card_destroy(card);\r\nkfree(card);\r\n}\r\nstatic void __devexit slic_entry_remove(struct pci_dev *pcidev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pcidev);\r\nu32 mmio_start = 0;\r\nuint mmio_len = 0;\r\nstruct adapter *adapter = netdev_priv(dev);\r\nstruct sliccard *card;\r\nstruct mcast_address *mcaddr, *mlist;\r\nASSERT(adapter);\r\nslic_adapter_freeresources(adapter);\r\nslic_unmap_mmio_space(adapter);\r\nunregister_netdev(dev);\r\nmmio_start = pci_resource_start(pcidev, 0);\r\nmmio_len = pci_resource_len(pcidev, 0);\r\nrelease_mem_region(mmio_start, mmio_len);\r\niounmap((void __iomem *)dev->base_addr);\r\nmlist = adapter->mcastaddrs;\r\nwhile (mlist) {\r\nmcaddr = mlist;\r\nmlist = mlist->next;\r\nkfree(mcaddr);\r\n}\r\nASSERT(adapter->card);\r\ncard = adapter->card;\r\nASSERT(card->adapters_allocated);\r\ncard->adapters_allocated--;\r\nadapter->allocated = 0;\r\nif (!card->adapters_allocated) {\r\nstruct sliccard *curr_card = slic_global.slic_card;\r\nif (curr_card == card) {\r\nslic_global.slic_card = card->next;\r\n} else {\r\nwhile (curr_card->next != card)\r\ncurr_card = curr_card->next;\r\nASSERT(curr_card);\r\ncurr_card->next = card->next;\r\n}\r\nASSERT(slic_global.num_slic_cards);\r\nslic_global.num_slic_cards--;\r\nslic_card_cleanup(card);\r\n}\r\nfree_netdev(dev);\r\npci_release_regions(pcidev);\r\n}\r\nstatic int slic_entry_halt(struct net_device *dev)\r\n{\r\nstruct adapter *adapter = netdev_priv(dev);\r\nstruct sliccard *card = adapter->card;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nspin_lock_irqsave(&slic_global.driver_lock.lock,\r\nslic_global.driver_lock.flags);\r\nASSERT(card);\r\nnetif_stop_queue(adapter->netdev);\r\nadapter->state = ADAPT_DOWN;\r\nadapter->linkstate = LINK_DOWN;\r\nadapter->upr_list = NULL;\r\nadapter->upr_busy = 0;\r\nadapter->devflags_prev = 0;\r\nASSERT(card->adapter[adapter->cardindex] == adapter);\r\nslic_reg32_write(&slic_regs->slic_icr, ICR_INT_OFF, FLUSH);\r\nadapter->all_reg_writes++;\r\nadapter->icr_reg_writes++;\r\nslic_config_clear(adapter);\r\nif (adapter->activated) {\r\ncard->adapters_activated--;\r\nslic_global.num_slic_ports_active--;\r\nadapter->activated = 0;\r\n}\r\n#ifdef AUTOMATIC_RESET\r\nslic_reg32_write(&slic_regs->slic_reset_iface, 0, FLUSH);\r\n#endif\r\nslic_cmdq_reset(adapter);\r\n#ifdef AUTOMATIC_RESET\r\nif (!card->adapters_activated)\r\nslic_card_init(card, adapter);\r\n#endif\r\nspin_unlock_irqrestore(&slic_global.driver_lock.lock,\r\nslic_global.driver_lock.flags);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *slic_get_stats(struct net_device *dev)\r\n{\r\nstruct adapter *adapter = netdev_priv(dev);\r\nASSERT(adapter);\r\ndev->stats.collisions = adapter->slic_stats.iface.xmit_collisions;\r\ndev->stats.rx_errors = adapter->slic_stats.iface.rcv_errors;\r\ndev->stats.tx_errors = adapter->slic_stats.iface.xmt_errors;\r\ndev->stats.rx_missed_errors = adapter->slic_stats.iface.rcv_discards;\r\ndev->stats.tx_heartbeat_errors = 0;\r\ndev->stats.tx_aborted_errors = 0;\r\ndev->stats.tx_window_errors = 0;\r\ndev->stats.tx_fifo_errors = 0;\r\ndev->stats.rx_frame_errors = 0;\r\ndev->stats.rx_length_errors = 0;\r\nreturn &dev->stats;\r\n}\r\nstatic int slic_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct adapter *adapter = netdev_priv(dev);\r\nstruct ethtool_cmd edata;\r\nstruct ethtool_cmd ecmd;\r\nu32 data[7];\r\nu32 intagg;\r\nASSERT(rq);\r\nswitch (cmd) {\r\ncase SIOCSLICSETINTAGG:\r\nif (copy_from_user(data, rq->ifr_data, 28))\r\nreturn -EFAULT;\r\nintagg = data[0];\r\ndev_err(&dev->dev, "%s: set interrupt aggregation to %d\n",\r\n__func__, intagg);\r\nslic_intagg_set(adapter, intagg);\r\nreturn 0;\r\n#ifdef SLIC_TRACE_DUMP_ENABLED\r\ncase SIOCSLICTRACEDUMP:\r\n{\r\nu32 value;\r\nDBG_IOCTL("slic_ioctl SIOCSLIC_TRACE_DUMP\n");\r\nif (copy_from_user(data, rq->ifr_data, 28)) {\r\nPRINT_ERROR\r\n("slic: copy_from_user FAILED getting initial simba param\n");\r\nreturn -EFAULT;\r\n}\r\nvalue = data[0];\r\nif (tracemon_request == SLIC_DUMP_DONE) {\r\nPRINT_ERROR\r\n("ATK Diagnostic Trace Dump Requested\n");\r\ntracemon_request = SLIC_DUMP_REQUESTED;\r\ntracemon_request_type = value;\r\ntracemon_timestamp = jiffies;\r\n} else if ((tracemon_request == SLIC_DUMP_REQUESTED) ||\r\n(tracemon_request ==\r\nSLIC_DUMP_IN_PROGRESS)) {\r\nPRINT_ERROR\r\n("ATK Diagnostic Trace Dump Requested but already in progress... ignore\n");\r\n} else {\r\nPRINT_ERROR\r\n("ATK Diagnostic Trace Dump Requested\n");\r\ntracemon_request = SLIC_DUMP_REQUESTED;\r\ntracemon_request_type = value;\r\ntracemon_timestamp = jiffies;\r\n}\r\nreturn 0;\r\n}\r\n#endif\r\ncase SIOCETHTOOL:\r\nASSERT(adapter);\r\nif (copy_from_user(&ecmd, rq->ifr_data, sizeof(ecmd)))\r\nreturn -EFAULT;\r\nif (ecmd.cmd == ETHTOOL_GSET) {\r\nedata.supported = (SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_Autoneg | SUPPORTED_MII);\r\nedata.port = PORT_MII;\r\nedata.transceiver = XCVR_INTERNAL;\r\nedata.phy_address = 0;\r\nif (adapter->linkspeed == LINK_100MB)\r\nedata.speed = SPEED_100;\r\nelse if (adapter->linkspeed == LINK_10MB)\r\nedata.speed = SPEED_10;\r\nelse\r\nedata.speed = 0;\r\nif (adapter->linkduplex == LINK_FULLD)\r\nedata.duplex = DUPLEX_FULL;\r\nelse\r\nedata.duplex = DUPLEX_HALF;\r\nedata.autoneg = AUTONEG_ENABLE;\r\nedata.maxtxpkt = 1;\r\nedata.maxrxpkt = 1;\r\nif (copy_to_user(rq->ifr_data, &edata, sizeof(edata)))\r\nreturn -EFAULT;\r\n} else if (ecmd.cmd == ETHTOOL_SSET) {\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (adapter->linkspeed == LINK_100MB)\r\nedata.speed = SPEED_100;\r\nelse if (adapter->linkspeed == LINK_10MB)\r\nedata.speed = SPEED_10;\r\nelse\r\nedata.speed = 0;\r\nif (adapter->linkduplex == LINK_FULLD)\r\nedata.duplex = DUPLEX_FULL;\r\nelse\r\nedata.duplex = DUPLEX_HALF;\r\nedata.autoneg = AUTONEG_ENABLE;\r\nedata.maxtxpkt = 1;\r\nedata.maxrxpkt = 1;\r\nif ((ecmd.speed != edata.speed) ||\r\n(ecmd.duplex != edata.duplex)) {\r\nu32 speed;\r\nu32 duplex;\r\nif (ecmd.speed == SPEED_10)\r\nspeed = 0;\r\nelse\r\nspeed = PCR_SPEED_100;\r\nif (ecmd.duplex == DUPLEX_FULL)\r\nduplex = PCR_DUPLEX_FULL;\r\nelse\r\nduplex = 0;\r\nslic_link_config(adapter, speed, duplex);\r\nslic_link_event_handler(adapter);\r\n}\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void slic_config_pci(struct pci_dev *pcidev)\r\n{\r\nu16 pci_command;\r\nu16 new_command;\r\npci_read_config_word(pcidev, PCI_COMMAND, &pci_command);\r\nnew_command = pci_command | PCI_COMMAND_MASTER\r\n| PCI_COMMAND_MEMORY\r\n| PCI_COMMAND_INVALIDATE\r\n| PCI_COMMAND_PARITY | PCI_COMMAND_SERR | PCI_COMMAND_FAST_BACK;\r\nif (pci_command != new_command)\r\npci_write_config_word(pcidev, PCI_COMMAND, new_command);\r\n}\r\nstatic int slic_card_init(struct sliccard *card, struct adapter *adapter)\r\n{\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nstruct slic_eeprom *peeprom;\r\nstruct oslic_eeprom *pOeeprom;\r\ndma_addr_t phys_config;\r\nu32 phys_configh;\r\nu32 phys_configl;\r\nu32 i = 0;\r\nstruct slic_shmem *pshmem;\r\nint status;\r\nuint macaddrs = card->card_size;\r\nushort eecodesize;\r\nushort dramsize;\r\nushort ee_chksum;\r\nushort calc_chksum;\r\nstruct slic_config_mac *pmac;\r\nunsigned char fruformat;\r\nunsigned char oemfruformat;\r\nstruct atk_fru *patkfru;\r\nunion oemfru *poemfru;\r\nslic_soft_reset(adapter);\r\nstatus = slic_card_download(adapter);\r\nif (status != 0) {\r\ndev_err(&adapter->pcidev->dev,\r\n"download failed bus %d slot %d\n",\r\nadapter->busnumber, adapter->slotnumber);\r\nreturn status;\r\n}\r\nif (!card->config_set) {\r\npeeprom = pci_alloc_consistent(adapter->pcidev,\r\nsizeof(struct slic_eeprom),\r\n&phys_config);\r\nphys_configl = SLIC_GET_ADDR_LOW(phys_config);\r\nphys_configh = SLIC_GET_ADDR_HIGH(phys_config);\r\nif (!peeprom) {\r\ndev_err(&adapter->pcidev->dev,\r\n"eeprom read failed to get memory "\r\n"bus %d slot %d\n", adapter->busnumber,\r\nadapter->slotnumber);\r\nreturn -ENOMEM;\r\n} else {\r\nmemset(peeprom, 0, sizeof(struct slic_eeprom));\r\n}\r\nslic_reg32_write(&slic_regs->slic_icr, ICR_INT_OFF, FLUSH);\r\nmdelay(1);\r\npshmem = (struct slic_shmem *)adapter->phys_shmem;\r\nspin_lock_irqsave(&adapter->bit64reglock.lock,\r\nadapter->bit64reglock.flags);\r\nslic_reg32_write(&slic_regs->slic_addr_upper, 0, DONT_FLUSH);\r\nslic_reg32_write(&slic_regs->slic_isp,\r\nSLIC_GET_ADDR_LOW(&pshmem->isr), FLUSH);\r\nspin_unlock_irqrestore(&adapter->bit64reglock.lock,\r\nadapter->bit64reglock.flags);\r\nslic_config_get(adapter, phys_configl, phys_configh);\r\nfor (;;) {\r\nif (adapter->pshmem->isr) {\r\nif (adapter->pshmem->isr & ISR_UPC) {\r\nadapter->pshmem->isr = 0;\r\nslic_reg64_write(adapter,\r\n&slic_regs->slic_isp, 0,\r\n&slic_regs->slic_addr_upper,\r\n0, FLUSH);\r\nslic_reg32_write(&slic_regs->slic_isr,\r\n0, FLUSH);\r\nslic_upr_request_complete(adapter, 0);\r\nbreak;\r\n} else {\r\nadapter->pshmem->isr = 0;\r\nslic_reg32_write(&slic_regs->slic_isr,\r\n0, FLUSH);\r\n}\r\n} else {\r\nmdelay(1);\r\ni++;\r\nif (i > 5000) {\r\ndev_err(&adapter->pcidev->dev,\r\n"%d config data fetch timed out!\n",\r\nadapter->port);\r\nslic_reg64_write(adapter,\r\n&slic_regs->slic_isp, 0,\r\n&slic_regs->slic_addr_upper,\r\n0, FLUSH);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nswitch (adapter->devid) {\r\ncase SLIC_2GB_DEVICE_ID:\r\npOeeprom = (struct oslic_eeprom *) peeprom;\r\neecodesize = pOeeprom->EecodeSize;\r\ndramsize = pOeeprom->DramSize;\r\npmac = pOeeprom->MacInfo;\r\nfruformat = pOeeprom->FruFormat;\r\npatkfru = &pOeeprom->AtkFru;\r\noemfruformat = pOeeprom->OemFruFormat;\r\npoemfru = &pOeeprom->OemFru;\r\nmacaddrs = 2;\r\nbreak;\r\ndefault:\r\neecodesize = peeprom->EecodeSize;\r\ndramsize = peeprom->DramSize;\r\npmac = peeprom->u2.mac.MacInfo;\r\nfruformat = peeprom->FruFormat;\r\npatkfru = &peeprom->AtkFru;\r\noemfruformat = peeprom->OemFruFormat;\r\npoemfru = &peeprom->OemFru;\r\nbreak;\r\n}\r\ncard->config.EepromValid = false;\r\nif ((eecodesize <= MAX_EECODE_SIZE) &&\r\n(eecodesize >= MIN_EECODE_SIZE)) {\r\nee_chksum =\r\n*(u16 *) ((char *) peeprom + (eecodesize - 2));\r\ncalc_chksum =\r\n~slic_eeprom_cksum((char *) peeprom,\r\n(eecodesize - 2));\r\nif (ee_chksum == calc_chksum)\r\ncard->config.EepromValid = true;\r\n}\r\ncard->config.DramSize = dramsize;\r\nfor (i = 0; i < macaddrs; i++) {\r\nmemcpy(&card->config.MacInfo[i],\r\n&pmac[i], sizeof(struct slic_config_mac));\r\n}\r\ncard->config.FruFormat = fruformat;\r\nmemcpy(&card->config.AtkFru, patkfru,\r\nsizeof(struct atk_fru));\r\npci_free_consistent(adapter->pcidev,\r\nsizeof(struct slic_eeprom),\r\npeeprom, phys_config);\r\nif ((!card->config.EepromValid) &&\r\n(adapter->reg_params.fail_on_bad_eeprom)) {\r\nslic_reg64_write(adapter, &slic_regs->slic_isp, 0,\r\n&slic_regs->slic_addr_upper,\r\n0, FLUSH);\r\ndev_err(&adapter->pcidev->dev,\r\n"unsupported CONFIGURATION EEPROM invalid\n");\r\nreturn -EINVAL;\r\n}\r\ncard->config_set = 1;\r\n}\r\nif (slic_card_download_gbrcv(adapter)) {\r\ndev_err(&adapter->pcidev->dev,\r\n"unable to download GB receive microcode\n");\r\nreturn -EINVAL;\r\n}\r\nif (slic_global.dynamic_intagg)\r\nslic_intagg_set(adapter, 0);\r\nelse\r\nslic_intagg_set(adapter, intagg_delay);\r\ncard->pingstatus = ISR_PINGMASK;\r\ncard->state = CARD_UP;\r\ncard->reset_in_progress = 0;\r\nreturn 0;\r\n}\r\nstatic void slic_init_driver(void)\r\n{\r\nif (slic_first_init) {\r\nslic_first_init = 0;\r\nspin_lock_init(&slic_global.driver_lock.lock);\r\nslic_debug_init();\r\n}\r\n}\r\nstatic void slic_init_adapter(struct net_device *netdev,\r\nstruct pci_dev *pcidev,\r\nconst struct pci_device_id *pci_tbl_entry,\r\nvoid __iomem *memaddr, int chip_idx)\r\n{\r\nushort index;\r\nstruct slic_handle *pslic_handle;\r\nstruct adapter *adapter = netdev_priv(netdev);\r\nadapter->vendid = pci_tbl_entry->vendor;\r\nadapter->devid = pci_tbl_entry->device;\r\nadapter->subsysid = pci_tbl_entry->subdevice;\r\nadapter->busnumber = pcidev->bus->number;\r\nadapter->slotnumber = ((pcidev->devfn >> 3) & 0x1F);\r\nadapter->functionnumber = (pcidev->devfn & 0x7);\r\nadapter->memorylength = pci_resource_len(pcidev, 0);\r\nadapter->slic_regs = (__iomem struct slic_regs *)memaddr;\r\nadapter->irq = pcidev->irq;\r\nadapter->next_netdevice = head_netdevice;\r\nhead_netdevice = netdev;\r\nadapter->chipid = chip_idx;\r\nadapter->port = 0;\r\nadapter->cardindex = adapter->port;\r\nadapter->memorybase = memaddr;\r\nspin_lock_init(&adapter->upr_lock.lock);\r\nspin_lock_init(&adapter->bit64reglock.lock);\r\nspin_lock_init(&adapter->adapter_lock.lock);\r\nspin_lock_init(&adapter->reset_lock.lock);\r\nspin_lock_init(&adapter->handle_lock.lock);\r\nadapter->card_size = 1;\r\nASSERT(SLIC_CMDQ_MAXCMDS <= 0xFFFF);\r\nfor (index = 1, pslic_handle = &adapter->slic_handles[1];\r\nindex < SLIC_CMDQ_MAXCMDS; index++, pslic_handle++) {\r\npslic_handle->token.handle_index = index;\r\npslic_handle->type = SLIC_HANDLE_FREE;\r\npslic_handle->next = adapter->pfree_slic_handles;\r\nadapter->pfree_slic_handles = pslic_handle;\r\n}\r\nadapter->pshmem = (struct slic_shmem *)\r\npci_alloc_consistent(adapter->pcidev,\r\nsizeof(struct slic_shmem),\r\n&adapter->\r\nphys_shmem);\r\nASSERT(adapter->pshmem);\r\nmemset(adapter->pshmem, 0, sizeof(struct slic_shmem));\r\nreturn;\r\n}\r\nstatic u32 slic_card_locate(struct adapter *adapter)\r\n{\r\nstruct sliccard *card = slic_global.slic_card;\r\nstruct physcard *physcard = slic_global.phys_card;\r\nushort card_hostid;\r\nu16 __iomem *hostid_reg;\r\nuint i;\r\nuint rdhostid_offset = 0;\r\nswitch (adapter->devid) {\r\ncase SLIC_2GB_DEVICE_ID:\r\nrdhostid_offset = SLIC_RDHOSTID_2GB;\r\nbreak;\r\ncase SLIC_1GB_DEVICE_ID:\r\nrdhostid_offset = SLIC_RDHOSTID_1GB;\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\nbreak;\r\n}\r\nhostid_reg =\r\n(u16 __iomem *) (((u8 __iomem *) (adapter->slic_regs)) +\r\nrdhostid_offset);\r\ncard_hostid = (ushort) readw(hostid_reg);\r\nif (card_hostid == SLIC_HOSTID_DEFAULT) {\r\ncard = kzalloc(sizeof(struct sliccard), GFP_KERNEL);\r\nif (card == NULL)\r\nreturn -ENOMEM;\r\ncard->next = slic_global.slic_card;\r\nslic_global.slic_card = card;\r\ncard->busnumber = adapter->busnumber;\r\ncard->slotnumber = adapter->slotnumber;\r\nfor (i = 0; i < SLIC_MAX_CARDS; i++) {\r\nif (slic_global.cardnuminuse[i] == 0) {\r\nslic_global.cardnuminuse[i] = 1;\r\ncard->cardnum = i;\r\nbreak;\r\n}\r\n}\r\nslic_global.num_slic_cards++;\r\nslic_debug_card_create(card);\r\n} else {\r\nwhile (card) {\r\nif (card->cardnum == card_hostid)\r\nbreak;\r\ncard = card->next;\r\n}\r\n}\r\nASSERT(card);\r\nif (!card)\r\nreturn -ENXIO;\r\nASSERT(card->adapter[adapter->port] == NULL);\r\nif (!card->adapter[adapter->port]) {\r\ncard->adapter[adapter->port] = adapter;\r\nadapter->card = card;\r\n}\r\ncard->card_size = 1;\r\nwhile (physcard) {\r\nfor (i = 0; i < SLIC_MAX_PORTS; i++) {\r\nif (!physcard->adapter[i])\r\ncontinue;\r\nelse\r\nbreak;\r\n}\r\nASSERT(i != SLIC_MAX_PORTS);\r\nif (physcard->adapter[i]->slotnumber == adapter->slotnumber)\r\nbreak;\r\nphyscard = physcard->next;\r\n}\r\nif (!physcard) {\r\nphyscard = kzalloc(sizeof(struct physcard), GFP_ATOMIC);\r\nASSERT(physcard);\r\nphyscard->next = slic_global.phys_card;\r\nslic_global.phys_card = physcard;\r\nphyscard->adapters_allocd = 1;\r\n} else {\r\nphyscard->adapters_allocd++;\r\n}\r\nadapter->physport = physcard->adapters_allocd - 1;\r\nASSERT(physcard->adapter[adapter->physport] == NULL);\r\nphyscard->adapter[adapter->physport] = adapter;\r\nadapter->physcard = physcard;\r\nreturn 0;\r\n}\r\nstatic int __devinit slic_entry_probe(struct pci_dev *pcidev,\r\nconst struct pci_device_id *pci_tbl_entry)\r\n{\r\nstatic int cards_found;\r\nstatic int did_version;\r\nint err = -ENODEV;\r\nstruct net_device *netdev;\r\nstruct adapter *adapter;\r\nvoid __iomem *memmapped_ioaddr = NULL;\r\nu32 status = 0;\r\nulong mmio_start = 0;\r\nulong mmio_len = 0;\r\nstruct sliccard *card = NULL;\r\nint pci_using_dac = 0;\r\nslic_global.dynamic_intagg = dynamic_intagg;\r\nerr = pci_enable_device(pcidev);\r\nif (err)\r\nreturn err;\r\nif (slic_debug > 0 && did_version++ == 0) {\r\nprintk(KERN_DEBUG "%s\n", slic_banner);\r\nprintk(KERN_DEBUG "%s\n", slic_proc_version);\r\n}\r\nif (!pci_set_dma_mask(pcidev, DMA_BIT_MASK(64))) {\r\npci_using_dac = 1;\r\nif (pci_set_consistent_dma_mask(pcidev, DMA_BIT_MASK(64))) {\r\ndev_err(&pcidev->dev, "unable to obtain 64-bit DMA for "\r\n"consistent allocations\n");\r\ngoto err_out_disable_pci;\r\n}\r\n} else if (pci_set_dma_mask(pcidev, DMA_BIT_MASK(32))) {\r\npci_using_dac = 0;\r\npci_set_consistent_dma_mask(pcidev, DMA_BIT_MASK(32));\r\n} else {\r\ndev_err(&pcidev->dev, "no usable DMA configuration\n");\r\ngoto err_out_disable_pci;\r\n}\r\nerr = pci_request_regions(pcidev, DRV_NAME);\r\nif (err) {\r\ndev_err(&pcidev->dev, "can't obtain PCI resources\n");\r\ngoto err_out_disable_pci;\r\n}\r\npci_set_master(pcidev);\r\nnetdev = alloc_etherdev(sizeof(struct adapter));\r\nif (!netdev) {\r\nerr = -ENOMEM;\r\ngoto err_out_exit_slic_probe;\r\n}\r\nSET_NETDEV_DEV(netdev, &pcidev->dev);\r\npci_set_drvdata(pcidev, netdev);\r\nadapter = netdev_priv(netdev);\r\nadapter->netdev = netdev;\r\nadapter->pcidev = pcidev;\r\nif (pci_using_dac)\r\nnetdev->features |= NETIF_F_HIGHDMA;\r\nmmio_start = pci_resource_start(pcidev, 0);\r\nmmio_len = pci_resource_len(pcidev, 0);\r\nmemmapped_ioaddr = ioremap(mmio_start, mmio_len);\r\nif (!memmapped_ioaddr) {\r\ndev_err(&pcidev->dev, "cannot remap MMIO region %lx @ %lx\n",\r\nmmio_len, mmio_start);\r\ngoto err_out_free_netdev;\r\n}\r\nslic_config_pci(pcidev);\r\nslic_init_driver();\r\nslic_init_adapter(netdev,\r\npcidev, pci_tbl_entry, memmapped_ioaddr, cards_found);\r\nstatus = slic_card_locate(adapter);\r\nif (status) {\r\ndev_err(&pcidev->dev, "cannot locate card\n");\r\ngoto err_out_free_mmio_region;\r\n}\r\ncard = adapter->card;\r\nif (!adapter->allocated) {\r\ncard->adapters_allocated++;\r\nadapter->allocated = 1;\r\n}\r\nstatus = slic_card_init(card, adapter);\r\nif (status != 0) {\r\ncard->state = CARD_FAIL;\r\nadapter->state = ADAPT_FAIL;\r\nadapter->linkstate = LINK_DOWN;\r\ndev_err(&pcidev->dev, "FAILED status[%x]\n", status);\r\n} else {\r\nslic_adapter_set_hwaddr(adapter);\r\n}\r\nnetdev->base_addr = (unsigned long)adapter->memorybase;\r\nnetdev->irq = adapter->irq;\r\nnetdev->netdev_ops = &slic_netdev_ops;\r\nslic_debug_adapter_create(adapter);\r\nstrcpy(netdev->name, "eth%d");\r\nerr = register_netdev(netdev);\r\nif (err) {\r\ndev_err(&pcidev->dev, "Cannot register net device, aborting.\n");\r\ngoto err_out_unmap;\r\n}\r\ncards_found++;\r\nreturn status;\r\nerr_out_unmap:\r\niounmap(memmapped_ioaddr);\r\nerr_out_free_mmio_region:\r\nrelease_mem_region(mmio_start, mmio_len);\r\nerr_out_free_netdev:\r\nfree_netdev(netdev);\r\nerr_out_exit_slic_probe:\r\npci_release_regions(pcidev);\r\nerr_out_disable_pci:\r\npci_disable_device(pcidev);\r\nreturn err;\r\n}\r\nstatic int __init slic_module_init(void)\r\n{\r\nslic_init_driver();\r\nif (debug >= 0 && slic_debug != debug)\r\nprintk(KERN_DEBUG KBUILD_MODNAME ": debug level is %d.\n",\r\ndebug);\r\nif (debug >= 0)\r\nslic_debug = debug;\r\nreturn pci_register_driver(&slic_driver);\r\n}\r\nstatic void __exit slic_module_cleanup(void)\r\n{\r\npci_unregister_driver(&slic_driver);\r\nslic_debug_cleanup();\r\n}
