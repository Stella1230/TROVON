void hardif_free_rcu(struct rcu_head *rcu)\r\n{\r\nstruct hard_iface *hard_iface;\r\nhard_iface = container_of(rcu, struct hard_iface, rcu);\r\ndev_put(hard_iface->net_dev);\r\nkfree(hard_iface);\r\n}\r\nstruct hard_iface *hardif_get_by_netdev(const struct net_device *net_dev)\r\n{\r\nstruct hard_iface *hard_iface;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &hardif_list, list) {\r\nif (hard_iface->net_dev == net_dev &&\r\natomic_inc_not_zero(&hard_iface->refcount))\r\ngoto out;\r\n}\r\nhard_iface = NULL;\r\nout:\r\nrcu_read_unlock();\r\nreturn hard_iface;\r\n}\r\nstatic int is_valid_iface(const struct net_device *net_dev)\r\n{\r\nif (net_dev->flags & IFF_LOOPBACK)\r\nreturn 0;\r\nif (net_dev->type != ARPHRD_ETHER)\r\nreturn 0;\r\nif (net_dev->addr_len != ETH_ALEN)\r\nreturn 0;\r\nif (softif_is_valid(net_dev))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic struct hard_iface *hardif_get_active(const struct net_device *soft_iface)\r\n{\r\nstruct hard_iface *hard_iface;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &hardif_list, list) {\r\nif (hard_iface->soft_iface != soft_iface)\r\ncontinue;\r\nif (hard_iface->if_status == IF_ACTIVE &&\r\natomic_inc_not_zero(&hard_iface->refcount))\r\ngoto out;\r\n}\r\nhard_iface = NULL;\r\nout:\r\nrcu_read_unlock();\r\nreturn hard_iface;\r\n}\r\nstatic void primary_if_update_addr(struct bat_priv *bat_priv)\r\n{\r\nstruct vis_packet *vis_packet;\r\nstruct hard_iface *primary_if;\r\nprimary_if = primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\nvis_packet = (struct vis_packet *)\r\nbat_priv->my_vis_info->skb_packet->data;\r\nmemcpy(vis_packet->vis_orig, primary_if->net_dev->dev_addr, ETH_ALEN);\r\nmemcpy(vis_packet->sender_orig,\r\nprimary_if->net_dev->dev_addr, ETH_ALEN);\r\nout:\r\nif (primary_if)\r\nhardif_free_ref(primary_if);\r\n}\r\nstatic void primary_if_select(struct bat_priv *bat_priv,\r\nstruct hard_iface *new_hard_iface)\r\n{\r\nstruct hard_iface *curr_hard_iface;\r\nASSERT_RTNL();\r\nif (new_hard_iface && !atomic_inc_not_zero(&new_hard_iface->refcount))\r\nnew_hard_iface = NULL;\r\ncurr_hard_iface = rcu_dereference_protected(bat_priv->primary_if, 1);\r\nrcu_assign_pointer(bat_priv->primary_if, new_hard_iface);\r\nif (curr_hard_iface)\r\nhardif_free_ref(curr_hard_iface);\r\nif (!new_hard_iface)\r\nreturn;\r\nbat_ogm_init_primary(new_hard_iface);\r\nprimary_if_update_addr(bat_priv);\r\n}\r\nstatic bool hardif_is_iface_up(const struct hard_iface *hard_iface)\r\n{\r\nif (hard_iface->net_dev->flags & IFF_UP)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void check_known_mac_addr(const struct net_device *net_dev)\r\n{\r\nconst struct hard_iface *hard_iface;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &hardif_list, list) {\r\nif ((hard_iface->if_status != IF_ACTIVE) &&\r\n(hard_iface->if_status != IF_TO_BE_ACTIVATED))\r\ncontinue;\r\nif (hard_iface->net_dev == net_dev)\r\ncontinue;\r\nif (!compare_eth(hard_iface->net_dev->dev_addr,\r\nnet_dev->dev_addr))\r\ncontinue;\r\npr_warning("The newly added mac address (%pM) already exists "\r\n"on: %s\n", net_dev->dev_addr,\r\nhard_iface->net_dev->name);\r\npr_warning("It is strongly recommended to keep mac addresses "\r\n"unique to avoid problems!\n");\r\n}\r\nrcu_read_unlock();\r\n}\r\nint hardif_min_mtu(struct net_device *soft_iface)\r\n{\r\nconst struct bat_priv *bat_priv = netdev_priv(soft_iface);\r\nconst struct hard_iface *hard_iface;\r\nint min_mtu = ETH_DATA_LEN;\r\nif (atomic_read(&bat_priv->fragmentation))\r\ngoto out;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &hardif_list, list) {\r\nif ((hard_iface->if_status != IF_ACTIVE) &&\r\n(hard_iface->if_status != IF_TO_BE_ACTIVATED))\r\ncontinue;\r\nif (hard_iface->soft_iface != soft_iface)\r\ncontinue;\r\nmin_mtu = min_t(int, hard_iface->net_dev->mtu - BAT_HEADER_LEN,\r\nmin_mtu);\r\n}\r\nrcu_read_unlock();\r\nout:\r\nreturn min_mtu;\r\n}\r\nvoid update_min_mtu(struct net_device *soft_iface)\r\n{\r\nint min_mtu;\r\nmin_mtu = hardif_min_mtu(soft_iface);\r\nif (soft_iface->mtu != min_mtu)\r\nsoft_iface->mtu = min_mtu;\r\n}\r\nstatic void hardif_activate_interface(struct hard_iface *hard_iface)\r\n{\r\nstruct bat_priv *bat_priv;\r\nstruct hard_iface *primary_if = NULL;\r\nif (hard_iface->if_status != IF_INACTIVE)\r\ngoto out;\r\nbat_priv = netdev_priv(hard_iface->soft_iface);\r\nbat_ogm_update_mac(hard_iface);\r\nhard_iface->if_status = IF_TO_BE_ACTIVATED;\r\nprimary_if = primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\nprimary_if_select(bat_priv, hard_iface);\r\nbat_info(hard_iface->soft_iface, "Interface activated: %s\n",\r\nhard_iface->net_dev->name);\r\nupdate_min_mtu(hard_iface->soft_iface);\r\nout:\r\nif (primary_if)\r\nhardif_free_ref(primary_if);\r\n}\r\nstatic void hardif_deactivate_interface(struct hard_iface *hard_iface)\r\n{\r\nif ((hard_iface->if_status != IF_ACTIVE) &&\r\n(hard_iface->if_status != IF_TO_BE_ACTIVATED))\r\nreturn;\r\nhard_iface->if_status = IF_INACTIVE;\r\nbat_info(hard_iface->soft_iface, "Interface deactivated: %s\n",\r\nhard_iface->net_dev->name);\r\nupdate_min_mtu(hard_iface->soft_iface);\r\n}\r\nint hardif_enable_interface(struct hard_iface *hard_iface,\r\nconst char *iface_name)\r\n{\r\nstruct bat_priv *bat_priv;\r\nstruct net_device *soft_iface;\r\nint ret;\r\nif (hard_iface->if_status != IF_NOT_IN_USE)\r\ngoto out;\r\nif (!atomic_inc_not_zero(&hard_iface->refcount))\r\ngoto out;\r\nsoft_iface = dev_get_by_name(&init_net, iface_name);\r\nif (!soft_iface) {\r\nsoft_iface = softif_create(iface_name);\r\nif (!soft_iface) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev_hold(soft_iface);\r\n}\r\nif (!softif_is_valid(soft_iface)) {\r\npr_err("Can't create batman mesh interface %s: "\r\n"already exists as regular interface\n",\r\nsoft_iface->name);\r\ndev_put(soft_iface);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nhard_iface->soft_iface = soft_iface;\r\nbat_priv = netdev_priv(hard_iface->soft_iface);\r\nbat_ogm_init(hard_iface);\r\nif (!hard_iface->packet_buff) {\r\nbat_err(hard_iface->soft_iface, "Can't add interface packet "\r\n"(%s): out of memory\n", hard_iface->net_dev->name);\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nhard_iface->if_num = bat_priv->num_ifaces;\r\nbat_priv->num_ifaces++;\r\nhard_iface->if_status = IF_INACTIVE;\r\norig_hash_add_if(hard_iface, bat_priv->num_ifaces);\r\nhard_iface->batman_adv_ptype.type = __constant_htons(ETH_P_BATMAN);\r\nhard_iface->batman_adv_ptype.func = batman_skb_recv;\r\nhard_iface->batman_adv_ptype.dev = hard_iface->net_dev;\r\ndev_add_pack(&hard_iface->batman_adv_ptype);\r\natomic_set(&hard_iface->seqno, 1);\r\natomic_set(&hard_iface->frag_seqno, 1);\r\nbat_info(hard_iface->soft_iface, "Adding interface: %s\n",\r\nhard_iface->net_dev->name);\r\nif (atomic_read(&bat_priv->fragmentation) && hard_iface->net_dev->mtu <\r\nETH_DATA_LEN + BAT_HEADER_LEN)\r\nbat_info(hard_iface->soft_iface,\r\n"The MTU of interface %s is too small (%i) to handle "\r\n"the transport of batman-adv packets. Packets going "\r\n"over this interface will be fragmented on layer2 "\r\n"which could impact the performance. Setting the MTU "\r\n"to %zi would solve the problem.\n",\r\nhard_iface->net_dev->name, hard_iface->net_dev->mtu,\r\nETH_DATA_LEN + BAT_HEADER_LEN);\r\nif (!atomic_read(&bat_priv->fragmentation) && hard_iface->net_dev->mtu <\r\nETH_DATA_LEN + BAT_HEADER_LEN)\r\nbat_info(hard_iface->soft_iface,\r\n"The MTU of interface %s is too small (%i) to handle "\r\n"the transport of batman-adv packets. If you experience"\r\n" problems getting traffic through try increasing the "\r\n"MTU to %zi.\n",\r\nhard_iface->net_dev->name, hard_iface->net_dev->mtu,\r\nETH_DATA_LEN + BAT_HEADER_LEN);\r\nif (hardif_is_iface_up(hard_iface))\r\nhardif_activate_interface(hard_iface);\r\nelse\r\nbat_err(hard_iface->soft_iface, "Not using interface %s "\r\n"(retrying later): interface not active\n",\r\nhard_iface->net_dev->name);\r\nschedule_bat_ogm(hard_iface);\r\nout:\r\nreturn 0;\r\nerr:\r\nhardif_free_ref(hard_iface);\r\nreturn ret;\r\n}\r\nvoid hardif_disable_interface(struct hard_iface *hard_iface)\r\n{\r\nstruct bat_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nstruct hard_iface *primary_if = NULL;\r\nif (hard_iface->if_status == IF_ACTIVE)\r\nhardif_deactivate_interface(hard_iface);\r\nif (hard_iface->if_status != IF_INACTIVE)\r\ngoto out;\r\nbat_info(hard_iface->soft_iface, "Removing interface: %s\n",\r\nhard_iface->net_dev->name);\r\ndev_remove_pack(&hard_iface->batman_adv_ptype);\r\nbat_priv->num_ifaces--;\r\norig_hash_del_if(hard_iface, bat_priv->num_ifaces);\r\nprimary_if = primary_if_get_selected(bat_priv);\r\nif (hard_iface == primary_if) {\r\nstruct hard_iface *new_if;\r\nnew_if = hardif_get_active(hard_iface->soft_iface);\r\nprimary_if_select(bat_priv, new_if);\r\nif (new_if)\r\nhardif_free_ref(new_if);\r\n}\r\nkfree(hard_iface->packet_buff);\r\nhard_iface->packet_buff = NULL;\r\nhard_iface->if_status = IF_NOT_IN_USE;\r\npurge_orig_ref(bat_priv);\r\npurge_outstanding_packets(bat_priv, hard_iface);\r\ndev_put(hard_iface->soft_iface);\r\nif (!bat_priv->num_ifaces)\r\nsoftif_destroy(hard_iface->soft_iface);\r\nhard_iface->soft_iface = NULL;\r\nhardif_free_ref(hard_iface);\r\nout:\r\nif (primary_if)\r\nhardif_free_ref(primary_if);\r\n}\r\nstatic struct hard_iface *hardif_add_interface(struct net_device *net_dev)\r\n{\r\nstruct hard_iface *hard_iface;\r\nint ret;\r\nASSERT_RTNL();\r\nret = is_valid_iface(net_dev);\r\nif (ret != 1)\r\ngoto out;\r\ndev_hold(net_dev);\r\nhard_iface = kmalloc(sizeof(*hard_iface), GFP_ATOMIC);\r\nif (!hard_iface)\r\ngoto release_dev;\r\nret = sysfs_add_hardif(&hard_iface->hardif_obj, net_dev);\r\nif (ret)\r\ngoto free_if;\r\nhard_iface->if_num = -1;\r\nhard_iface->net_dev = net_dev;\r\nhard_iface->soft_iface = NULL;\r\nhard_iface->if_status = IF_NOT_IN_USE;\r\nINIT_LIST_HEAD(&hard_iface->list);\r\natomic_set(&hard_iface->refcount, 2);\r\ncheck_known_mac_addr(hard_iface->net_dev);\r\nlist_add_tail_rcu(&hard_iface->list, &hardif_list);\r\nreturn hard_iface;\r\nfree_if:\r\nkfree(hard_iface);\r\nrelease_dev:\r\ndev_put(net_dev);\r\nout:\r\nreturn NULL;\r\n}\r\nstatic void hardif_remove_interface(struct hard_iface *hard_iface)\r\n{\r\nASSERT_RTNL();\r\nif (hard_iface->if_status != IF_NOT_IN_USE)\r\nhardif_disable_interface(hard_iface);\r\nif (hard_iface->if_status != IF_NOT_IN_USE)\r\nreturn;\r\nhard_iface->if_status = IF_TO_BE_REMOVED;\r\nsysfs_del_hardif(&hard_iface->hardif_obj);\r\nhardif_free_ref(hard_iface);\r\n}\r\nvoid hardif_remove_interfaces(void)\r\n{\r\nstruct hard_iface *hard_iface, *hard_iface_tmp;\r\nrtnl_lock();\r\nlist_for_each_entry_safe(hard_iface, hard_iface_tmp,\r\n&hardif_list, list) {\r\nlist_del_rcu(&hard_iface->list);\r\nhardif_remove_interface(hard_iface);\r\n}\r\nrtnl_unlock();\r\n}\r\nstatic int hard_if_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *net_dev = ptr;\r\nstruct hard_iface *hard_iface = hardif_get_by_netdev(net_dev);\r\nstruct hard_iface *primary_if = NULL;\r\nstruct bat_priv *bat_priv;\r\nif (!hard_iface && event == NETDEV_REGISTER)\r\nhard_iface = hardif_add_interface(net_dev);\r\nif (!hard_iface)\r\ngoto out;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nhardif_activate_interface(hard_iface);\r\nbreak;\r\ncase NETDEV_GOING_DOWN:\r\ncase NETDEV_DOWN:\r\nhardif_deactivate_interface(hard_iface);\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nlist_del_rcu(&hard_iface->list);\r\nhardif_remove_interface(hard_iface);\r\nbreak;\r\ncase NETDEV_CHANGEMTU:\r\nif (hard_iface->soft_iface)\r\nupdate_min_mtu(hard_iface->soft_iface);\r\nbreak;\r\ncase NETDEV_CHANGEADDR:\r\nif (hard_iface->if_status == IF_NOT_IN_USE)\r\ngoto hardif_put;\r\ncheck_known_mac_addr(hard_iface->net_dev);\r\nbat_ogm_update_mac(hard_iface);\r\nbat_priv = netdev_priv(hard_iface->soft_iface);\r\nprimary_if = primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto hardif_put;\r\nif (hard_iface == primary_if)\r\nprimary_if_update_addr(bat_priv);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nhardif_put:\r\nhardif_free_ref(hard_iface);\r\nout:\r\nif (primary_if)\r\nhardif_free_ref(primary_if);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int batman_skb_recv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *ptype,\r\nstruct net_device *orig_dev)\r\n{\r\nstruct bat_priv *bat_priv;\r\nstruct batman_ogm_packet *batman_ogm_packet;\r\nstruct hard_iface *hard_iface;\r\nint ret;\r\nhard_iface = container_of(ptype, struct hard_iface, batman_adv_ptype);\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (!skb)\r\ngoto err_out;\r\nif (unlikely(!pskb_may_pull(skb, 2)))\r\ngoto err_free;\r\nif (unlikely(skb->mac_len != sizeof(struct ethhdr)\r\n|| !skb_mac_header(skb)))\r\ngoto err_free;\r\nif (!hard_iface->soft_iface)\r\ngoto err_free;\r\nbat_priv = netdev_priv(hard_iface->soft_iface);\r\nif (atomic_read(&bat_priv->mesh_state) != MESH_ACTIVE)\r\ngoto err_free;\r\nif (hard_iface->if_status != IF_ACTIVE)\r\ngoto err_free;\r\nbatman_ogm_packet = (struct batman_ogm_packet *)skb->data;\r\nif (batman_ogm_packet->version != COMPAT_VERSION) {\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Drop packet: incompatible batman version (%i)\n",\r\nbatman_ogm_packet->version);\r\ngoto err_free;\r\n}\r\nswitch (batman_ogm_packet->packet_type) {\r\ncase BAT_OGM:\r\nret = recv_bat_ogm_packet(skb, hard_iface);\r\nbreak;\r\ncase BAT_ICMP:\r\nret = recv_icmp_packet(skb, hard_iface);\r\nbreak;\r\ncase BAT_UNICAST:\r\nret = recv_unicast_packet(skb, hard_iface);\r\nbreak;\r\ncase BAT_UNICAST_FRAG:\r\nret = recv_ucast_frag_packet(skb, hard_iface);\r\nbreak;\r\ncase BAT_BCAST:\r\nret = recv_bcast_packet(skb, hard_iface);\r\nbreak;\r\ncase BAT_VIS:\r\nret = recv_vis_packet(skb, hard_iface);\r\nbreak;\r\ncase BAT_TT_QUERY:\r\nret = recv_tt_query(skb, hard_iface);\r\nbreak;\r\ncase BAT_ROAM_ADV:\r\nret = recv_roam_adv(skb, hard_iface);\r\nbreak;\r\ndefault:\r\nret = NET_RX_DROP;\r\n}\r\nif (ret == NET_RX_DROP)\r\nkfree_skb(skb);\r\nreturn NET_RX_SUCCESS;\r\nerr_free:\r\nkfree_skb(skb);\r\nerr_out:\r\nreturn NET_RX_DROP;\r\n}\r\nbool is_wifi_iface(int ifindex)\r\n{\r\nstruct net_device *net_device = NULL;\r\nbool ret = false;\r\nif (ifindex == NULL_IFINDEX)\r\ngoto out;\r\nnet_device = dev_get_by_index(&init_net, ifindex);\r\nif (!net_device)\r\ngoto out;\r\n#ifdef CONFIG_WIRELESS_EXT\r\nif (net_device->wireless_handlers)\r\nret = true;\r\nelse\r\n#endif\r\nif (net_device->ieee80211_ptr)\r\nret = true;\r\nout:\r\nif (net_device)\r\ndev_put(net_device);\r\nreturn ret;\r\n}
