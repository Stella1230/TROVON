static int __devinit elsa_cs_probe(struct pcmcia_device *link)\r\n{\r\nlocal_info_t *local;\r\ndev_dbg(&link->dev, "elsa_cs_attach()\n");\r\nlocal = kzalloc(sizeof(local_info_t), GFP_KERNEL);\r\nif (!local) return -ENOMEM;\r\nlocal->p_dev = link;\r\nlink->priv = local;\r\nlocal->cardnr = -1;\r\nreturn elsa_cs_config(link);\r\n}\r\nstatic void __devexit elsa_cs_detach(struct pcmcia_device *link)\r\n{\r\nlocal_info_t *info = link->priv;\r\ndev_dbg(&link->dev, "elsa_cs_detach(0x%p)\n", link);\r\ninfo->busy = 1;\r\nelsa_cs_release(link);\r\nkfree(info);\r\n}\r\nstatic int elsa_cs_configcheck(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nint j;\r\np_dev->io_lines = 3;\r\np_dev->resource[0]->end = 8;\r\np_dev->resource[0]->flags &= IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\r\nif ((p_dev->resource[0]->end) && p_dev->resource[0]->start) {\r\nprintk(KERN_INFO "(elsa_cs: looks like the 96 model)\n");\r\nif (!pcmcia_request_io(p_dev))\r\nreturn 0;\r\n} else {\r\nprintk(KERN_INFO "(elsa_cs: looks like the 97 model)\n");\r\nfor (j = 0x2f0; j > 0x100; j -= 0x10) {\r\np_dev->resource[0]->start = j;\r\nif (!pcmcia_request_io(p_dev))\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __devinit elsa_cs_config(struct pcmcia_device *link)\r\n{\r\nint i;\r\nIsdnCard_t icard;\r\ndev_dbg(&link->dev, "elsa_config(0x%p)\n", link);\r\nlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\r\ni = pcmcia_loop_config(link, elsa_cs_configcheck, NULL);\r\nif (i != 0)\r\ngoto failed;\r\nif (!link->irq)\r\ngoto failed;\r\ni = pcmcia_enable_device(link);\r\nif (i != 0)\r\ngoto failed;\r\nicard.para[0] = link->irq;\r\nicard.para[1] = link->resource[0]->start;\r\nicard.protocol = protocol;\r\nicard.typ = ISDN_CTYPE_ELSA_PCMCIA;\r\ni = hisax_init_pcmcia(link, &(((local_info_t*)link->priv)->busy), &icard);\r\nif (i < 0) {\r\nprintk(KERN_ERR "elsa_cs: failed to initialize Elsa "\r\n"PCMCIA %d with %pR\n", i, link->resource[0]);\r\nelsa_cs_release(link);\r\n} else\r\n((local_info_t*)link->priv)->cardnr = i;\r\nreturn 0;\r\nfailed:\r\nelsa_cs_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic void elsa_cs_release(struct pcmcia_device *link)\r\n{\r\nlocal_info_t *local = link->priv;\r\ndev_dbg(&link->dev, "elsa_cs_release(0x%p)\n", link);\r\nif (local) {\r\nif (local->cardnr >= 0) {\r\nHiSax_closecard(local->cardnr);\r\n}\r\n}\r\npcmcia_disable_device(link);\r\n}\r\nstatic int elsa_suspend(struct pcmcia_device *link)\r\n{\r\nlocal_info_t *dev = link->priv;\r\ndev->busy = 1;\r\nreturn 0;\r\n}\r\nstatic int elsa_resume(struct pcmcia_device *link)\r\n{\r\nlocal_info_t *dev = link->priv;\r\ndev->busy = 0;\r\nreturn 0;\r\n}\r\nstatic int __init init_elsa_cs(void)\r\n{\r\nreturn pcmcia_register_driver(&elsa_cs_driver);\r\n}\r\nstatic void __exit exit_elsa_cs(void)\r\n{\r\npcmcia_unregister_driver(&elsa_cs_driver);\r\n}
