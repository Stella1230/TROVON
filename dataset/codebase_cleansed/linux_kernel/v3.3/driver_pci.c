static u32 bcma_pcie_read(struct bcma_drv_pci *pc, u32 address)\r\n{\r\npcicore_write32(pc, 0x130, address);\r\npcicore_read32(pc, 0x130);\r\nreturn pcicore_read32(pc, 0x134);\r\n}\r\nstatic void bcma_pcie_mdio_set_phy(struct bcma_drv_pci *pc, u8 phy)\r\n{\r\nconst u16 mdio_control = 0x128;\r\nconst u16 mdio_data = 0x12C;\r\nu32 v;\r\nint i;\r\nv = (1 << 30);\r\nv |= (1 << 28);\r\nv |= (1 << 17);\r\nv |= (0x1F << 18);\r\nv |= (phy << 4);\r\npcicore_write32(pc, mdio_data, v);\r\nudelay(10);\r\nfor (i = 0; i < 200; i++) {\r\nv = pcicore_read32(pc, mdio_control);\r\nif (v & 0x100 )\r\nbreak;\r\nmsleep(1);\r\n}\r\n}\r\nstatic u16 bcma_pcie_mdio_read(struct bcma_drv_pci *pc, u8 device, u8 address)\r\n{\r\nconst u16 mdio_control = 0x128;\r\nconst u16 mdio_data = 0x12C;\r\nint max_retries = 10;\r\nu16 ret = 0;\r\nu32 v;\r\nint i;\r\nv = 0x80;\r\nv |= 0x2;\r\npcicore_write32(pc, mdio_control, v);\r\nif (pc->core->id.rev >= 10) {\r\nmax_retries = 200;\r\nbcma_pcie_mdio_set_phy(pc, device);\r\n}\r\nv = (1 << 30);\r\nv |= (1 << 29);\r\nv |= (1 << 17);\r\nif (pc->core->id.rev < 10)\r\nv |= (u32)device << 22;\r\nv |= (u32)address << 18;\r\npcicore_write32(pc, mdio_data, v);\r\nudelay(10);\r\nfor (i = 0; i < max_retries; i++) {\r\nv = pcicore_read32(pc, mdio_control);\r\nif (v & 0x100 ) {\r\nudelay(10);\r\nret = pcicore_read32(pc, mdio_data);\r\nbreak;\r\n}\r\nmsleep(1);\r\n}\r\npcicore_write32(pc, mdio_control, 0);\r\nreturn ret;\r\n}\r\nstatic void bcma_pcie_mdio_write(struct bcma_drv_pci *pc, u8 device,\r\nu8 address, u16 data)\r\n{\r\nconst u16 mdio_control = 0x128;\r\nconst u16 mdio_data = 0x12C;\r\nint max_retries = 10;\r\nu32 v;\r\nint i;\r\nv = 0x80;\r\nv |= 0x2;\r\npcicore_write32(pc, mdio_control, v);\r\nif (pc->core->id.rev >= 10) {\r\nmax_retries = 200;\r\nbcma_pcie_mdio_set_phy(pc, device);\r\n}\r\nv = (1 << 30);\r\nv |= (1 << 28);\r\nv |= (1 << 17);\r\nif (pc->core->id.rev < 10)\r\nv |= (u32)device << 22;\r\nv |= (u32)address << 18;\r\nv |= data;\r\npcicore_write32(pc, mdio_data, v);\r\nudelay(10);\r\nfor (i = 0; i < max_retries; i++) {\r\nv = pcicore_read32(pc, mdio_control);\r\nif (v & 0x100 )\r\nbreak;\r\nmsleep(1);\r\n}\r\npcicore_write32(pc, mdio_control, 0);\r\n}\r\nstatic u8 bcma_pcicore_polarity_workaround(struct bcma_drv_pci *pc)\r\n{\r\nreturn (bcma_pcie_read(pc, 0x204) & 0x10) ? 0xC0 : 0x80;\r\n}\r\nstatic void bcma_pcicore_serdes_workaround(struct bcma_drv_pci *pc)\r\n{\r\nconst u8 serdes_pll_device = 0x1D;\r\nconst u8 serdes_rx_device = 0x1F;\r\nu16 tmp;\r\nbcma_pcie_mdio_write(pc, serdes_rx_device, 1 ,\r\nbcma_pcicore_polarity_workaround(pc));\r\ntmp = bcma_pcie_mdio_read(pc, serdes_pll_device, 1 );\r\nif (tmp & 0x4000)\r\nbcma_pcie_mdio_write(pc, serdes_pll_device, 1, tmp & ~0x4000);\r\n}\r\nstatic void bcma_core_pci_clientmode_init(struct bcma_drv_pci *pc)\r\n{\r\nbcma_pcicore_serdes_workaround(pc);\r\n}\r\nstatic bool bcma_core_pci_is_in_hostmode(struct bcma_drv_pci *pc)\r\n{\r\nstruct bcma_bus *bus = pc->core->bus;\r\nu16 chipid_top;\r\nchipid_top = (bus->chipinfo.id & 0xFF00);\r\nif (chipid_top != 0x4700 &&\r\nchipid_top != 0x5300)\r\nreturn false;\r\n#ifdef CONFIG_SSB_DRIVER_PCICORE\r\nif (bus->sprom.boardflags_lo & SSB_BFL_NOPCI)\r\nreturn false;\r\n#endif\r\n#if 0\r\nu32 tmp;\r\nreturn !mips_busprobe32(tmp, (bus->mmio +\r\n(pc->core->core_index * BCMA_CORE_SIZE)));\r\n#endif\r\nreturn true;\r\n}\r\nvoid bcma_core_pci_init(struct bcma_drv_pci *pc)\r\n{\r\nif (pc->setup_done)\r\nreturn;\r\nif (bcma_core_pci_is_in_hostmode(pc)) {\r\n#ifdef CONFIG_BCMA_DRIVER_PCI_HOSTMODE\r\nbcma_core_pci_hostmode_init(pc);\r\n#else\r\npr_err("Driver compiled without support for hostmode PCI\n");\r\n#endif\r\n} else {\r\nbcma_core_pci_clientmode_init(pc);\r\n}\r\npc->setup_done = true;\r\n}\r\nint bcma_core_pci_irq_ctl(struct bcma_drv_pci *pc, struct bcma_device *core,\r\nbool enable)\r\n{\r\nstruct pci_dev *pdev = pc->core->bus->host_pci;\r\nu32 coremask, tmp;\r\nint err = 0;\r\nif (core->bus->hosttype != BCMA_HOSTTYPE_PCI) {\r\ngoto out;\r\n}\r\nerr = pci_read_config_dword(pdev, BCMA_PCI_IRQMASK, &tmp);\r\nif (err)\r\ngoto out;\r\ncoremask = BIT(core->core_index) << 8;\r\nif (enable)\r\ntmp |= coremask;\r\nelse\r\ntmp &= ~coremask;\r\nerr = pci_write_config_dword(pdev, BCMA_PCI_IRQMASK, tmp);\r\nout:\r\nreturn err;\r\n}
