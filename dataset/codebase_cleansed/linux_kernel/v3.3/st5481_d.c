static inline void D_L1L2(struct st5481_adapter *adapter, int pr, void *arg)\r\n{\r\nstruct hisax_if *ifc = (struct hisax_if *) &adapter->hisax_d_if;\r\nifc->l1l2(ifc, pr, arg);\r\n}\r\nstatic void\r\nl1_go_f3(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fi->userdata;\r\nif (fi->state == ST_L1_F7)\r\nph_disconnect(adapter);\r\nFsmChangeState(fi, ST_L1_F3);\r\nD_L1L2(adapter, PH_DEACTIVATE | INDICATION, NULL);\r\n}\r\nstatic void\r\nl1_go_f6(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fi->userdata;\r\nif (fi->state == ST_L1_F7)\r\nph_disconnect(adapter);\r\nFsmChangeState(fi, ST_L1_F6);\r\n}\r\nstatic void\r\nl1_go_f7(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fi->userdata;\r\nFsmDelTimer(&adapter->timer, 0);\r\nph_connect(adapter);\r\nFsmChangeState(fi, ST_L1_F7);\r\nD_L1L2(adapter, PH_ACTIVATE | INDICATION, NULL);\r\n}\r\nstatic void\r\nl1_go_f8(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fi->userdata;\r\nif (fi->state == ST_L1_F7)\r\nph_disconnect(adapter);\r\nFsmChangeState(fi, ST_L1_F8);\r\n}\r\nstatic void\r\nl1_timer3(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fi->userdata;\r\nst5481_ph_command(adapter, ST5481_CMD_DR);\r\nFsmChangeState(fi, ST_L1_F3);\r\nD_L1L2(adapter, PH_DEACTIVATE | INDICATION, NULL);\r\n}\r\nstatic void\r\nl1_ignore(struct FsmInst *fi, int event, void *arg)\r\n{\r\n}\r\nstatic void\r\nl1_activate(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fi->userdata;\r\nst5481_ph_command(adapter, ST5481_CMD_DR);\r\nst5481_ph_command(adapter, ST5481_CMD_PUP);\r\nFsmRestartTimer(&adapter->timer, TIMER3_VALUE, EV_TIMER3, NULL, 2);\r\nst5481_ph_command(adapter, ST5481_CMD_AR8);\r\nFsmChangeState(fi, ST_L1_F4);\r\n}\r\nvoid fifo_reseted(void *context)\r\n{\r\nstruct st5481_adapter *adapter = context;\r\nFsmEvent(&adapter->d_out.fsm, EV_DOUT_RESETED, NULL);\r\n}\r\nstatic void usb_d_out_complete(struct urb *urb)\r\n{\r\nstruct st5481_adapter *adapter = urb->context;\r\nstruct st5481_d_out *d_out = &adapter->d_out;\r\nlong buf_nr;\r\nDBG(2, "");\r\nbuf_nr = get_buf_nr(d_out->urb, urb);\r\ntest_and_clear_bit(buf_nr, &d_out->busy);\r\nif (unlikely(urb->status < 0)) {\r\nswitch (urb->status) {\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ECONNRESET:\r\nDBG(1,"urb killed status %d", urb->status);\r\nbreak;\r\ndefault:\r\nWARNING("urb status %d",urb->status);\r\nif (d_out->busy == 0) {\r\nst5481_usb_pipe_reset(adapter, EP_D_OUT | USB_DIR_OUT, fifo_reseted, adapter);\r\n}\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nFsmEvent(&adapter->d_out.fsm, EV_DOUT_COMPLETE, (void *) buf_nr);\r\n}\r\nstatic void dout_start_xmit(struct FsmInst *fsm, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fsm->userdata;\r\nstruct st5481_d_out *d_out = &adapter->d_out;\r\nstruct urb *urb;\r\nint len, bytes_sent;\r\nstruct sk_buff *skb;\r\nint buf_nr = 0;\r\nskb = d_out->tx_skb;\r\nDBG(2,"len=%d",skb->len);\r\nisdnhdlc_out_init(&d_out->hdlc_state, HDLC_DCHANNEL | HDLC_BITREVERSE);\r\nif (test_and_set_bit(buf_nr, &d_out->busy)) {\r\nWARNING("ep %d urb %d busy %#lx", EP_D_OUT, buf_nr, d_out->busy);\r\nreturn;\r\n}\r\nurb = d_out->urb[buf_nr];\r\nDBG_SKB(0x10, skb);\r\nlen = isdnhdlc_encode(&d_out->hdlc_state,\r\nskb->data, skb->len, &bytes_sent,\r\nurb->transfer_buffer, 16);\r\nskb_pull(skb, bytes_sent);\r\nif(len < 16)\r\nFsmChangeState(&d_out->fsm, ST_DOUT_SHORT_INIT);\r\nelse\r\nFsmChangeState(&d_out->fsm, ST_DOUT_LONG_INIT);\r\nif (skb->len == 0) {\r\nd_out->tx_skb = NULL;\r\nD_L1L2(adapter, PH_DATA | CONFIRM, NULL);\r\ndev_kfree_skb_any(skb);\r\n}\r\nurb->transfer_buffer_length = len;\r\nurb->iso_frame_desc[0].offset = 0;\r\nurb->iso_frame_desc[0].length = len;\r\nurb->number_of_packets = 1;\r\nurb->dev = adapter->usb_dev;\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nDBG_ISO_PACKET(0x20,urb);\r\nSUBMIT_URB(urb, GFP_KERNEL);\r\n}\r\nstatic void dout_short_fifo(struct FsmInst *fsm, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fsm->userdata;\r\nstruct st5481_d_out *d_out = &adapter->d_out;\r\nFsmChangeState(&d_out->fsm, ST_DOUT_SHORT_WAIT_DEN);\r\nst5481_usb_device_ctrl_msg(adapter, OUT_D_COUNTER, 16, NULL, NULL);\r\n}\r\nstatic void dout_end_short_frame(struct FsmInst *fsm, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fsm->userdata;\r\nstruct st5481_d_out *d_out = &adapter->d_out;\r\nFsmChangeState(&d_out->fsm, ST_DOUT_WAIT_FOR_UNDERRUN);\r\n}\r\nstatic void dout_long_enable_fifo(struct FsmInst *fsm, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fsm->userdata;\r\nstruct st5481_d_out *d_out = &adapter->d_out;\r\nst5481_usb_device_ctrl_msg(adapter, OUT_D_COUNTER, 16, NULL, NULL);\r\nFsmChangeState(&d_out->fsm, ST_DOUT_LONG_WAIT_DEN);\r\n}\r\nstatic void dout_long_den(struct FsmInst *fsm, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fsm->userdata;\r\nstruct st5481_d_out *d_out = &adapter->d_out;\r\nFsmChangeState(&d_out->fsm, ST_DOUT_NORMAL);\r\nusb_d_out(adapter, 0);\r\nusb_d_out(adapter, 1);\r\n}\r\nstatic void dout_reset(struct FsmInst *fsm, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fsm->userdata;\r\nstruct st5481_d_out *d_out = &adapter->d_out;\r\nFsmChangeState(&d_out->fsm, ST_DOUT_WAIT_FOR_RESET);\r\nst5481_usb_pipe_reset(adapter, EP_D_OUT | USB_DIR_OUT, fifo_reseted, adapter);\r\n}\r\nstatic void dout_stop(struct FsmInst *fsm, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fsm->userdata;\r\nstruct st5481_d_out *d_out = &adapter->d_out;\r\nFsmChangeState(&d_out->fsm, ST_DOUT_WAIT_FOR_STOP);\r\nst5481_usb_device_ctrl_msg(adapter, OUT_D_COUNTER, 0, dout_stop_event, adapter);\r\n}\r\nstatic void dout_underrun(struct FsmInst *fsm, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fsm->userdata;\r\nstruct st5481_d_out *d_out = &adapter->d_out;\r\nif (test_bit(0, &d_out->busy) || test_bit(1, &d_out->busy)) {\r\nFsmChangeState(&d_out->fsm, ST_DOUT_WAIT_FOR_NOT_BUSY);\r\n} else {\r\ndout_stop(fsm, event, arg);\r\n}\r\n}\r\nstatic void dout_check_busy(struct FsmInst *fsm, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fsm->userdata;\r\nstruct st5481_d_out *d_out = &adapter->d_out;\r\nif (!test_bit(0, &d_out->busy) && !test_bit(1, &d_out->busy))\r\ndout_stop(fsm, event, arg);\r\n}\r\nstatic void dout_reseted(struct FsmInst *fsm, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fsm->userdata;\r\nstruct st5481_d_out *d_out = &adapter->d_out;\r\nFsmChangeState(&d_out->fsm, ST_DOUT_NONE);\r\nif (d_out->tx_skb)\r\nFsmEvent(&d_out->fsm, EV_DOUT_START_XMIT, NULL);\r\n}\r\nstatic void dout_complete(struct FsmInst *fsm, int event, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = fsm->userdata;\r\nlong buf_nr = (long) arg;\r\nusb_d_out(adapter, buf_nr);\r\n}\r\nstatic void dout_ignore(struct FsmInst *fsm, int event, void *arg)\r\n{\r\n}\r\nvoid st5481_d_l2l1(struct hisax_if *hisax_d_if, int pr, void *arg)\r\n{\r\nstruct st5481_adapter *adapter = hisax_d_if->priv;\r\nstruct sk_buff *skb = arg;\r\nswitch (pr) {\r\ncase PH_ACTIVATE | REQUEST:\r\nFsmEvent(&adapter->l1m, EV_PH_ACTIVATE_REQ, NULL);\r\nbreak;\r\ncase PH_DEACTIVATE | REQUEST:\r\nFsmEvent(&adapter->l1m, EV_PH_DEACTIVATE_REQ, NULL);\r\nbreak;\r\ncase PH_DATA | REQUEST:\r\nDBG(2, "PH_DATA REQUEST len %d", skb->len);\r\nBUG_ON(adapter->d_out.tx_skb);\r\nadapter->d_out.tx_skb = skb;\r\nFsmEvent(&adapter->d_out.fsm, EV_DOUT_START_XMIT, NULL);\r\nbreak;\r\ndefault:\r\nWARNING("pr %#x\n", pr);\r\nbreak;\r\n}\r\n}\r\nstatic void ph_connect(struct st5481_adapter *adapter)\r\n{\r\nstruct st5481_d_out *d_out = &adapter->d_out;\r\nstruct st5481_in *d_in = &adapter->d_in;\r\nDBG(8,"");\r\nFsmChangeState(&d_out->fsm, ST_DOUT_NONE);\r\nst5481_usb_device_ctrl_msg(adapter, FFMSK_D, 0xfc, NULL, NULL);\r\nst5481_in_mode(d_in, L1_MODE_HDLC);\r\n#ifdef LOOPBACK\r\nst5481_usb_device_ctrl_msg(cs, LBB, 0x04, NULL, NULL);\r\n#endif\r\nst5481_usb_pipe_reset(adapter, EP_D_OUT | USB_DIR_OUT, NULL, NULL);\r\nadapter->leds |= GREEN_LED;\r\nst5481_usb_device_ctrl_msg(adapter, GPIO_OUT, adapter->leds, NULL, NULL);\r\n}\r\nstatic void ph_disconnect(struct st5481_adapter *adapter)\r\n{\r\nDBG(8,"");\r\nst5481_in_mode(&adapter->d_in, L1_MODE_NULL);\r\nadapter->leds &= ~GREEN_LED;\r\nst5481_usb_device_ctrl_msg(adapter, GPIO_OUT, adapter->leds, NULL, NULL);\r\n}\r\nstatic int st5481_setup_d_out(struct st5481_adapter *adapter)\r\n{\r\nstruct usb_device *dev = adapter->usb_dev;\r\nstruct usb_interface *intf;\r\nstruct usb_host_interface *altsetting = NULL;\r\nstruct usb_host_endpoint *endpoint;\r\nstruct st5481_d_out *d_out = &adapter->d_out;\r\nDBG(2,"");\r\nintf = usb_ifnum_to_if(dev, 0);\r\nif (intf)\r\naltsetting = usb_altnum_to_altsetting(intf, 3);\r\nif (!altsetting)\r\nreturn -ENXIO;\r\nendpoint = &altsetting->endpoint[EP_D_OUT-1];\r\nDBG(2,"endpoint address=%02x,packet size=%d",\r\nendpoint->desc.bEndpointAddress, le16_to_cpu(endpoint->desc.wMaxPacketSize));\r\nreturn st5481_setup_isocpipes(d_out->urb, dev,\r\nusb_sndisocpipe(dev, endpoint->desc.bEndpointAddress),\r\nNUM_ISO_PACKETS_D, SIZE_ISO_PACKETS_D_OUT,\r\nNUM_ISO_PACKETS_D * SIZE_ISO_PACKETS_D_OUT,\r\nusb_d_out_complete, adapter);\r\n}\r\nstatic void st5481_release_d_out(struct st5481_adapter *adapter)\r\n{\r\nstruct st5481_d_out *d_out = &adapter->d_out;\r\nDBG(2,"");\r\nst5481_release_isocpipes(d_out->urb);\r\n}\r\nint st5481_setup_d(struct st5481_adapter *adapter)\r\n{\r\nint retval;\r\nDBG(2,"");\r\nretval = st5481_setup_d_out(adapter);\r\nif (retval)\r\ngoto err;\r\nadapter->d_in.bufsize = MAX_DFRAME_LEN_L1;\r\nadapter->d_in.num_packets = NUM_ISO_PACKETS_D;\r\nadapter->d_in.packet_size = SIZE_ISO_PACKETS_D_IN;\r\nadapter->d_in.ep = EP_D_IN | USB_DIR_IN;\r\nadapter->d_in.counter = IN_D_COUNTER;\r\nadapter->d_in.adapter = adapter;\r\nadapter->d_in.hisax_if = &adapter->hisax_d_if.ifc;\r\nretval = st5481_setup_in(&adapter->d_in);\r\nif (retval)\r\ngoto err_d_out;\r\nadapter->l1m.fsm = &l1fsm;\r\nadapter->l1m.state = ST_L1_F3;\r\nadapter->l1m.debug = st5481_debug & 0x100;\r\nadapter->l1m.userdata = adapter;\r\nadapter->l1m.printdebug = l1m_debug;\r\nFsmInitTimer(&adapter->l1m, &adapter->timer);\r\nadapter->d_out.fsm.fsm = &dout_fsm;\r\nadapter->d_out.fsm.state = ST_DOUT_NONE;\r\nadapter->d_out.fsm.debug = st5481_debug & 0x100;\r\nadapter->d_out.fsm.userdata = adapter;\r\nadapter->d_out.fsm.printdebug = dout_debug;\r\nreturn 0;\r\nerr_d_out:\r\nst5481_release_d_out(adapter);\r\nerr:\r\nreturn retval;\r\n}\r\nvoid st5481_release_d(struct st5481_adapter *adapter)\r\n{\r\nDBG(2,"");\r\nst5481_release_in(&adapter->d_in);\r\nst5481_release_d_out(adapter);\r\n}\r\nint __init st5481_d_init(void)\r\n{\r\nint retval;\r\nl1fsm.state_count = L1_STATE_COUNT;\r\nl1fsm.event_count = L1_EVENT_COUNT;\r\nl1fsm.strEvent = strL1Event;\r\nl1fsm.strState = strL1State;\r\nretval = FsmNew(&l1fsm, L1FnList, ARRAY_SIZE(L1FnList));\r\nif (retval)\r\ngoto err;\r\ndout_fsm.state_count = DOUT_STATE_COUNT;\r\ndout_fsm.event_count = DOUT_EVENT_COUNT;\r\ndout_fsm.strEvent = strDoutEvent;\r\ndout_fsm.strState = strDoutState;\r\nretval = FsmNew(&dout_fsm, DoutFnList, ARRAY_SIZE(DoutFnList));\r\nif (retval)\r\ngoto err_l1;\r\nreturn 0;\r\nerr_l1:\r\nFsmFree(&l1fsm);\r\nerr:\r\nreturn retval;\r\n}\r\nvoid st5481_d_exit(void)\r\n{\r\nFsmFree(&l1fsm);\r\nFsmFree(&dout_fsm);\r\n}
