static int\r\ndissect_openflow_ofp_match_v1(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset)\r\n{\r\nproto_tree_add_item(tree, hf_openflow_wildcards, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_openflow_in_port, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(tree, hf_openflow_eth_src, tvb, offset, 6, ENC_NA);\r\noffset+=6;\r\nproto_tree_add_item(tree, hf_openflow_eth_dst, tvb, offset, 6, ENC_NA);\r\noffset+=6;\r\nproto_tree_add_item(tree, hf_openflow_dl_vlan, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(tree, hf_openflow_dl_vlan_pcp, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(tree, hf_openflow_ofp_match_pad, tvb, offset, 1, ENC_NA);\r\noffset++;\r\nproto_tree_add_item(tree, hf_openflow_match_dl_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_openflow_ofp_match_tos, tvb, offset, 1, ENC_NA);\r\noffset++;\r\nproto_tree_add_item(tree, hf_openflow_ofp_match_nw_proto, tvb, offset, 1, ENC_NA);\r\noffset++;\r\nproto_tree_add_item(tree, hf_openflow_ofp_match_pad, tvb, offset, 2, ENC_NA);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_openflow_ofp_source_addr, tvb, offset, 4, ENC_NA);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_openflow_ofp_dest_addr, tvb, offset, 4, ENC_NA);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_openflow_ofp_source_port, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_openflow_ofp_dest_port, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_openflow_flow_stats_request_v1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset)\r\n{\r\noffset = dissect_openflow_ofp_match_v1(tvb, pinfo, tree, offset);\r\nproto_tree_add_item(tree, hf_openflow_table_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(tree, hf_openflow_v1_flow_stats_request_pad, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(tree, hf_openflow_out_port, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_openflow_action_header(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset)\r\n{\r\nguint16 action_type, action_len;\r\nproto_item* ti;\r\naction_type = tvb_get_ntohs(tvb, offset);\r\nti = proto_tree_add_item(tree, hf_openflow_action_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\naction_len = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(tree, hf_openflow_action_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nswitch(action_type){\r\ncase OFPAT_OUTPUT:\r\nproto_tree_add_item(tree, hf_openflow_output_port, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(tree, hf_openflow_max_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nbreak;\r\ndefault:\r\nexpert_add_info(pinfo, ti, &ei_openflow_action_type);\r\noffset+=(action_len-4);\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic void\r\ndissect_openflow_phy_port(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset)\r\n{\r\nproto_item *ti;\r\nproto_tree *port_cnf_tree, *port_state_tree, *port_cf_tree;\r\nproto_tree_add_item(tree, hf_openflow_port_no, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(tree, hf_openflow_hw_addr, tvb, offset, 6, ENC_NA);\r\noffset+=6;\r\nproto_tree_add_item(tree, hf_openflow_port_name, tvb, offset, OFP_MAX_PORT_NAME_LEN, ENC_ASCII|ENC_NA);\r\noffset+=OFP_MAX_PORT_NAME_LEN;\r\nti = proto_tree_add_item(tree, hf_openflow_port_config, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nport_cnf_tree = proto_item_add_subtree(ti, ett_openflow_port_cnf);\r\nproto_tree_add_item(port_cnf_tree, hf_openflow_port_down, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cnf_tree, hf_openflow_no_stp, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cnf_tree, hf_openflow_no_recv, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cnf_tree, hf_openflow_no_recv_stp, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cnf_tree, hf_openflow_no_flood, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cnf_tree, hf_openflow_no_fwd, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cnf_tree, hf_openflow_no_packet_in, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nti = proto_tree_add_item(tree, hf_openflow_port_state, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nport_state_tree = proto_item_add_subtree(ti, ett_openflow_port_state);\r\nproto_tree_add_item(port_state_tree, hf_openflow_link_down, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nti = proto_tree_add_item(tree, hf_openflow_port_curr, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nport_cf_tree = proto_item_add_subtree(ti, ett_openflow_port_cf);\r\nproto_tree_add_item(port_cf_tree, hf_openflow_10mb_hd, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cf_tree, hf_openflow_10mb_fd, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cf_tree, hf_openflow_100mb_hd, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cf_tree, hf_openflow_100mb_fd, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cf_tree, hf_openflow_1gb_hd, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cf_tree, hf_openflow_1gb_fd, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cf_tree, hf_openflow_10gb_fd, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cf_tree, hf_openflow_copper, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cf_tree, hf_openflow_fiber, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cf_tree, hf_openflow_autoneg, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cf_tree, hf_openflow_pause, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(port_cf_tree, hf_openflow_pause_asym, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_openflow_port_advertised, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_openflow_port_supported, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_openflow_port_peer, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_openflow_features_reply_v1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, guint16 length)\r\n{\r\nproto_item *ti;\r\nproto_tree *path_id_tree, *cap_tree, *act_tree;\r\nguint16 length_remaining;\r\nti = proto_tree_add_item(tree, hf_openflow_datapath_id, tvb, offset, 8, ENC_BIG_ENDIAN);\r\npath_id_tree = proto_item_add_subtree(ti, ett_openflow_path_id);\r\nproto_tree_add_item(path_id_tree, hf_openflow_datapath_mac, tvb, offset, 6, ENC_NA);\r\noffset+=6;\r\nproto_tree_add_item(path_id_tree, hf_openflow_datapath_impl, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(tree, hf_openflow_n_buffers, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_openflow_n_tables, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(tree, hf_openflow_features_reply_pad, tvb, offset, 3, ENC_NA);\r\noffset+=3;\r\nti = proto_tree_add_item(tree, hf_openflow_capabilities, tvb, offset, 4, ENC_BIG_ENDIAN);\r\ncap_tree = proto_item_add_subtree(ti, ett_openflow_cap);\r\nproto_tree_add_item(cap_tree, hf_openflow_cap_flow_stats, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(cap_tree, hf_openflow_table_stats, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(cap_tree, hf_openflow_port_stats, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(cap_tree, hf_openflow_group_stats, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(cap_tree, hf_openflow_ip_reasm, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(cap_tree, hf_openflow_queue_stats, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(cap_tree, hf_openflow_port_blocked, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nti = proto_tree_add_item(tree, hf_openflow_actions, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nact_tree = proto_item_add_subtree(ti, ett_openflow_act);\r\nproto_tree_add_item(act_tree, hf_openflow_output, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(act_tree, hf_openflow_set_vlan_vid, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(act_tree, hf_openflow_set_vlan_pcp, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(act_tree, hf_openflow_strip_vlan, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(act_tree, hf_openflow_set_dl_src, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(act_tree, hf_openflow_set_dl_dst, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(act_tree, hf_openflow_set_nw_src, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(act_tree, hf_openflow_set_nw_dst, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(act_tree, hf_openflow_set_nw_tos, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(act_tree, hf_openflow_set_tp_src, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(act_tree, hf_openflow_set_tp_dst, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(act_tree, hf_openflow_enqueue, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nlength_remaining = length-32;\r\nif(length_remaining > 0){\r\nguint16 num_ports = length_remaining/48;\r\nint i;\r\nif((length_remaining&0x003f) != 0){\r\n}\r\nfor(i=0; i<num_ports ;i++){\r\nproto_tree *port_tree;\r\nport_tree = proto_tree_add_subtree_format(tree, tvb, offset, 48, ett_openflow_port, NULL, "Port data %u",i+1);\r\ndissect_openflow_phy_port(tvb, pinfo, port_tree, offset);\r\noffset+=48;\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_openflow_switch_config(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\r\n{\r\nproto_tree_add_item(tree, hf_openflow_config_flags, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(tree, hf_openflow_miss_send_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_openflow_pkt_in(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length)\r\n{\r\ntvbuff_t *next_tvb;\r\nproto_tree_add_item(tree, hf_openflow_buffer_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_openflow_total_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(tree, hf_openflow_in_port, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(tree, hf_openflow_reason, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(tree, hf_openflow_pkt_in_pad, tvb, offset, 1, ENC_NA);\r\noffset+=1;\r\nnext_tvb = tvb_new_subset_length(tvb, offset, length-offset);\r\ncall_dissector(eth_withoutfcs_handle, next_tvb, pinfo, tree);\r\n}\r\nstatic void\r\ndissect_openflow_pkt_out(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\r\n{\r\ntvbuff_t *next_tvb;\r\ngint32 buffer_id;\r\nbuffer_id = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_openflow_buffer_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_openflow_in_port, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(tree, hf_openflow_actions_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\noffset = dissect_openflow_action_header(tvb, pinfo, tree, offset);\r\nif(buffer_id == -1){\r\nnext_tvb = tvb_new_subset_length(tvb, offset, length-offset);\r\ncall_dissector(eth_withoutfcs_handle, next_tvb, pinfo, tree);\r\n}\r\n}\r\nstatic void\r\ndissect_openflow_flow_mod(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, guint16 length _U_)\r\n{\r\noffset = dissect_openflow_ofp_match_v1(tvb, pinfo, tree, offset);\r\nproto_tree_add_item(tree, hf_openflow_cookie, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\nproto_tree_add_item(tree, hf_openflow_command, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_openflow_idle_timeout, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_openflow_hard_timeout, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_openflow_priority, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_openflow_buffer_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_openflow_out_port, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_openflow_flags, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n}\r\nstatic int\r\ndissect_openflow_stats_req(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, guint16 length _U_)\r\n{\r\nproto_item *type_item;\r\nguint32 type;\r\ntype_item = proto_tree_add_item_ret_uint(tree, hf_openflow_v1_stats_type, tvb, offset, 2, ENC_BIG_ENDIAN, &type);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_openflow_flags, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nswitch (type) {\r\ncase OFPST_DESC:\r\nbreak;\r\ncase OFPST_FLOW:\r\ndissect_openflow_flow_stats_request_v1(tvb, pinfo, tree, offset);\r\nbreak;\r\ndefault:\r\nexpert_add_info(pinfo, type_item, &ei_openflow_1_0_type);\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_openflow_stats_resp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, guint16 length)\r\n{\r\nproto_item *type_item;\r\nguint32 type;\r\ntype_item = proto_tree_add_item_ret_uint(tree, hf_openflow_v1_stats_type, tvb, offset, 2, ENC_BIG_ENDIAN, &type);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_openflow_flags, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif (length == 12 ) {\r\nreturn offset;\r\n}\r\nswitch (type) {\r\ncase OFPST_DESC:\r\nbreak;\r\ncase OFPST_FLOW:\r\ndefault:\r\nexpert_add_info(pinfo, type_item, &ei_openflow_1_0_type);\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_openflow_v1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *ti, *type_item;\r\nproto_tree *openflow_tree;\r\nguint offset = 0;\r\nguint8 type;\r\nguint16 length;\r\ntype = tvb_get_guint8(tvb, 1);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Type: %s",\r\nval_to_str_ext_const(type, &openflow_1_0_type_values_ext, "Unknown message type"));\r\nif((type == OFPT_1_0_PACKET_IN) || (type == OFPT_1_0_PACKET_OUT)){\r\ncol_set_writable(pinfo->cinfo, -1, FALSE);\r\n}\r\nti = proto_tree_add_item(tree, proto_openflow_v1, tvb, 0, -1, ENC_NA);\r\nopenflow_tree = proto_item_add_subtree(ti, ett_openflow);\r\nproto_tree_add_item(openflow_tree, hf_openflow_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\ntype_item = proto_tree_add_item(openflow_tree, hf_openflow_1_0_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nlength = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(openflow_tree, hf_openflow_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(openflow_tree, hf_openflow_xid, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nswitch(type){\r\ncase OFPT_1_0_HELLO:\r\nbreak;\r\ncase OFPT_1_0_FEATURES_REQUEST:\r\nbreak;\r\ncase OFPT_1_0_FEATURES_REPLY:\r\ndissect_openflow_features_reply_v1(tvb, pinfo, openflow_tree, offset, length);\r\nbreak;\r\ncase OFPT_1_0_GET_CONFIG_REQUEST:\r\nbreak;\r\ncase OFPT_1_0_GET_CONFIG_REPLY:\r\ncase OFPT_1_0_SET_CONFIG:\r\ndissect_openflow_switch_config(tvb, pinfo, openflow_tree, offset, length);\r\nbreak;\r\ncase OFPT_1_0_PACKET_IN:\r\ndissect_openflow_pkt_in(tvb, pinfo, openflow_tree, offset, length);\r\nbreak;\r\ncase OFPT_1_0_PACKET_OUT:\r\ndissect_openflow_pkt_out(tvb, pinfo, openflow_tree, offset, length);\r\nbreak;\r\ncase OFPT_1_0_FLOW_MOD:\r\ndissect_openflow_flow_mod(tvb, pinfo, openflow_tree, offset, length);\r\nbreak;\r\ncase OFPT_1_0_STATS_REQUEST:\r\ndissect_openflow_stats_req(tvb, pinfo, openflow_tree, offset, length);\r\nbreak;\r\ncase OFPT_1_0_STATS_REPLY:\r\ndissect_openflow_stats_resp(tvb, pinfo, openflow_tree, offset, length);\r\nbreak;\r\ndefault:\r\nif(length>8){\r\nexpert_add_info(pinfo, type_item, &ei_openflow_1_0_type);\r\n}\r\nbreak;\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nvoid\r\nproto_register_openflow_v1(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_openflow_version,\r\n{ "Version", "openflow.version",\r\nFT_UINT8, BASE_HEX, VALS(openflow_version_values), 0x7f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_1_0_type,\r\n{ "Type", "openflow_1_0.type",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING, &openflow_1_0_type_values_ext, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_xid,\r\n{ "Transaction ID", "openflow.xid",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_length,\r\n{ "Length", "openflow.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_datapath_id,\r\n{ "Datapath unique ID", "openflow.datapath_id",\r\nFT_UINT64, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_datapath_mac,\r\n{ "MAC addr", "openflow.datapath_mac",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_datapath_impl,\r\n{ "Implementers part", "openflow.datapath_imp",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_n_buffers,\r\n{ "n_buffers", "openflow.n_buffers",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_n_tables,\r\n{ "n_tables", "openflow.n_tables",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n#if 0\r\n{ &hf_openflow_auxiliary_id,\r\n{ "auxiliary_id", "openflow.auxiliary_id",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n#endif\r\n{ &hf_openflow_capabilities,\r\n{ "capabilities", "openflow.capabilities",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_actions,\r\n{ "actions", "openflow.actions",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n#if 0\r\n{ &hf_openflow_reserved32,\r\n{ "Reserved", "openflow.reserved32",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n#endif\r\n{ &hf_openflow_cap_flow_stats,\r\n{ "Flow statistics", "openflow.flow_stats",\r\nFT_BOOLEAN, 32, NULL, OFPC_FLOW_STATS,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_table_stats,\r\n{ "Table statistics", "openflow.table_stats",\r\nFT_BOOLEAN, 32, NULL, OFPC_TABLE_STATS,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_port_stats,\r\n{ "Port statistics", "openflow.port_stats",\r\nFT_BOOLEAN, 32, NULL, OFPC_PORT_STATS,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_group_stats,\r\n{ "Group statistics", "openflow.group_stats",\r\nFT_BOOLEAN, 32, NULL, OFPC_GROUP_STATS,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_ip_reasm,\r\n{ "Can reassemble IP fragments", "openflow.ip_reasm",\r\nFT_BOOLEAN, 32, NULL, OFPC_IP_REASM,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_queue_stats,\r\n{ "Queue statistics", "openflow.queue_stats",\r\nFT_BOOLEAN, 32, NULL, OFPC_QUEUE_STATS,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_port_blocked,\r\n{ "Switch will block looping ports", "openflow.port_blocked",\r\nFT_BOOLEAN, 32, NULL, OFPC_PORT_BLOCKED,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_output,\r\n{ "Output to switch port", "openflow.output",\r\nFT_BOOLEAN, 32, NULL, OFPAT_OUTPUT_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_set_vlan_vid,\r\n{ "Set the 802.1q VLAN id", "openflow.set_vlan_vid",\r\nFT_BOOLEAN, 32, NULL, OFPAT_SET_VLAN_VID_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_set_vlan_pcp,\r\n{ "Set the 802.1q priority", "openflow.set_vlan_pcp",\r\nFT_BOOLEAN, 32, NULL, OFPAT_SET_VLAN_PCP_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_strip_vlan,\r\n{ "Strip the 802.1q header", "openflow.strip_vlan",\r\nFT_BOOLEAN, 32, NULL, OFPAT_STRIP_VLAN_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_set_dl_src,\r\n{ "Ethernet source address", "openflow.set_dl_src",\r\nFT_BOOLEAN, 32, NULL, OFPAT_SET_DL_SRC_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_set_dl_dst,\r\n{ "Ethernet destination address", "openflow.set_dl_ds",\r\nFT_BOOLEAN, 32, NULL, OFPAT_SET_DL_DST_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_set_nw_src,\r\n{ "IP source address", "openflow.set_nw_src",\r\nFT_BOOLEAN, 32, NULL, OFPAT_SET_NW_SRC_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_set_nw_dst,\r\n{ "IP destination address", "openflow.set_nw_ds",\r\nFT_BOOLEAN, 32, NULL, OFPAT_SET_NW_DST_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_set_nw_tos,\r\n{ "IP ToS (DSCP field, 6 bits)", "openflow.set_nw_tos",\r\nFT_BOOLEAN, 32, NULL, OFPAT_SET_NW_TOS_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_set_tp_src,\r\n{ "TCP/UDP source port", "openflow.set_tp_src",\r\nFT_BOOLEAN, 32, NULL, OFPAT_SET_TP_SRC_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_set_tp_dst,\r\n{ "TCP/UDP destination port", "openflow.set_tp_dst",\r\nFT_BOOLEAN, 32, NULL, OFPAT_SET_TP_DST_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_enqueue,\r\n{ "Output to queue", "openflow.enqueue",\r\nFT_BOOLEAN, 32, NULL, OFPAT_ENQUEUE_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_port_no,\r\n{ "Port number", "openflow.port_no",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_hw_addr,\r\n{ "HW Address", "openflow.hw_add",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_port_name,\r\n{ "Port Name", "openflow.port_name",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_port_config,\r\n{ "Config flags", "openflow.port_config",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_port_state,\r\n{ "State flags", "openflow.port_state",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_port_curr,\r\n{ "Current features", "openflow.port_curr",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_port_advertised,\r\n{ "Advertised features", "openflow.port_advertised",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_port_supported,\r\n{ "Features supported", "openflow.port_supported",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_port_peer,\r\n{ "Features advertised by peer", "openflow.port_peer",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_port_down,\r\n{ "Port is administratively down", "openflow.port_down",\r\nFT_BOOLEAN, 32, NULL, OFPPC_PORT_DOWN,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_no_stp,\r\n{ "Disable 802.1D spanning tree on port", "openflow.no_stp",\r\nFT_BOOLEAN, 32, NULL, OFPPC_NO_STP,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_no_recv,\r\n{ "Drop all packets except 802.1D spanning tree packets", "openflow.no_recv",\r\nFT_BOOLEAN, 32, NULL, OFPPC_NO_RECV,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_no_recv_stp,\r\n{ "Drop received 802.1D STP packets", "openflow.no_recv_stp",\r\nFT_BOOLEAN, 32, NULL, OFPPC_NO_RECV_STP,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_no_flood,\r\n{ "Do not include this port when flooding", "openflow.no_flood",\r\nFT_BOOLEAN, 32, NULL, OFPPC_NO_FLOOD,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_no_fwd,\r\n{ "Drop packets forwarded to port", "openflow.no_fwd",\r\nFT_BOOLEAN, 32, NULL, OFPPC_NO_FWD,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_no_packet_in,\r\n{ "Do not send packet-in msgs for port", "openflow.no_packet_in",\r\nFT_BOOLEAN, 32, NULL, OFPPC_NO_PACKET_IN,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_link_down,\r\n{ "No physical link present", "openflow.link_down",\r\nFT_BOOLEAN, 32, NULL, OFPPS_LINK_DOWN,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_10mb_hd,\r\n{ "10 Mb half-duplex rate support", "openflow.10mb_hd",\r\nFT_BOOLEAN, 32, NULL, OFPPF_10MB_HD,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_10mb_fd,\r\n{ "10 Mb full-duplex rate support", "openflow.10mb_fd",\r\nFT_BOOLEAN, 32, NULL, OFPPF_10MB_FD,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_100mb_hd,\r\n{ "100 Mb half-duplex rate support", "openflow.100mb_hd",\r\nFT_BOOLEAN, 32, NULL, OFPPF_100MB_HD,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_100mb_fd,\r\n{ "100 Mb full-duplex rate support", "openflow.100mb_0fd",\r\nFT_BOOLEAN, 32, NULL, OFPPF_100MB_FD,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_1gb_hd,\r\n{ "1 Gb half-duplex rate support", "openflow.1gb_hd",\r\nFT_BOOLEAN, 32, NULL, OFPPF_1GB_HD,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_1gb_fd,\r\n{ "1 Gb full-duplex rate support", "openflow.1gb_fd",\r\nFT_BOOLEAN, 32, NULL, OFPPF_1GB_FD,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_10gb_fd,\r\n{ "10 Gb full-duplex rate support", "openflow.10gb_fd",\r\nFT_BOOLEAN, 32, NULL, OFPPF_10GB_FD,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_copper,\r\n{ "Copper medium", "openflow.copper",\r\nFT_BOOLEAN, 32, NULL, OFPPF_COPPER,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_fiber,\r\n{ "Fiber medium", "openflow.fiber",\r\nFT_BOOLEAN, 32, NULL, OFPPF_FIBER,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_autoneg,\r\n{ "Auto-negotiation", "openflow.autoneg",\r\nFT_BOOLEAN, 32, NULL, OFPPF_AUTONEG,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_pause,\r\n{ "Pause", "openflow.pause",\r\nFT_BOOLEAN, 32, NULL, OFPPF_PAUSE,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_pause_asym,\r\n{ "Asymmetric pause", "openflow.pause_asym",\r\nFT_BOOLEAN, 32, NULL, OFPPF_PAUSE_ASYM,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_config_flags,\r\n{ "Config flags", "openflow.config_flags",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_miss_send_len,\r\n{ "Max bytes of packet", "openflow.miss_send_len",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_buffer_id,\r\n{ "Buffer Id", "openflow.buffer_id",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_total_len,\r\n{ "Total length", "openflow.total_len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_in_port,\r\n{ "In port", "openflow.in_port",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_reason,\r\n{ "Reason", "openflow.reason",\r\nFT_UINT8, BASE_DEC, VALS(openflow_reason_values), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_pkt_in_pad,\r\n{ "Pad", "openflow.pkt_in.pad",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_table_id,\r\n{ "Table Id", "openflow.table_id",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_cookie,\r\n{ "Cookie", "openflow.cookie",\r\nFT_UINT64, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n#if 0\r\n{ &hf_openflow_cookie_mask,\r\n{ "Cookie mask", "openflow.cookie_mask",\r\nFT_UINT64, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n#endif\r\n{ &hf_openflow_features_reply_pad,\r\n{ "Pad", "openflow.features_reply.pad",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_actions_len,\r\n{ "Actions length", "openflow.actions_len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_action_type,\r\n{ "Actions type", "openflow.action_typ",\r\nFT_UINT16, BASE_DEC, VALS(openflow_action_values), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_action_len,\r\n{ "Action length", "openflow.action_len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_output_port,\r\n{ "Output port", "openflow.output_port",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_max_len,\r\n{ "Max length", "openflow.max_len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_wildcards,\r\n{ "Wildcards", "openflow.wildcards",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_command,\r\n{ "Command", "openflow.command",\r\nFT_UINT16, BASE_DEC, VALS(openflow_command_values), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_eth_src,\r\n{ "Ethernet source address", "openflow.eth_src",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_eth_dst,\r\n{ "Ethernet destination address", "openflow.eth_dst",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_dl_vlan,\r\n{ "Input VLAN id", "openflow.dl_vlan",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_dl_vlan_pcp,\r\n{ "Input VLAN priority", "openflow.dl_vlan_pcp",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_ofp_match_pad,\r\n{ "Pad", "openflow.ofp_match.pad",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_match_dl_type,\r\n{ "Dl type", "openflow.ofp_match.dl_type",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_ofp_match_tos,\r\n{ "IP ToS", "openflow.ofp_match.tos",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_ofp_match_nw_proto,\r\n{ "IP protocol", "openflow.ofp_match.nw_proto",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_ofp_source_addr,\r\n{ "Source Address", "openflow.ofp_match.source_addr",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_ofp_dest_addr,\r\n{ "Destination Address", "openflow.ofp_match.dest_addr",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_ofp_source_port,\r\n{ "Source Port", "openflow.ofp_match.source_port",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_ofp_dest_port,\r\n{ "Destination Port", "openflow.ofp_match.dest_port",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_idle_timeout,\r\n{ "Idle time-out", "openflow.idle_timeout",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_hard_timeout,\r\n{ "hard time-out", "openflow.hard_timeout",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_priority,\r\n{ "Priority", "openflow.priority",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_out_port,\r\n{ "Out port", "openflow.out_port",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n#if 0\r\n{ &hf_openflow_out_group,\r\n{ "Out group", "openflow.out_group",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n#endif\r\n{ &hf_openflow_flags,\r\n{ "Flags", "openflow.flags",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_v1_stats_type,\r\n{ "Type", "openflow.stats.type",\r\nFT_UINT16, BASE_DEC, VALS(openflow_stats_type_values), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openflow_v1_flow_stats_request_pad,\r\n{ "Pad", "openflow.stats.request_pad",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_openflow,\r\n&ett_openflow_path_id,\r\n&ett_openflow_cap,\r\n&ett_openflow_act,\r\n&ett_openflow_port,\r\n&ett_openflow_port_cnf,\r\n&ett_openflow_port_state,\r\n&ett_openflow_port_cf\r\n};\r\nstatic ei_register_info ei[] = {\r\n#if 0\r\n{ &ei_openflow_undecoded_data, { "openflow.undecoded_data", PI_UNDECODED, PI_WARN, "Data not dissected yet", EXPFILL }},\r\n#endif\r\n{ &ei_openflow_action_type, { "openflow.action_typ.undecoded", PI_UNDECODED, PI_WARN, "Action not dissected yet", EXPFILL }},\r\n{ &ei_openflow_1_0_type, { "openflow_1_0.type.undecoded", PI_UNDECODED, PI_WARN, "Message data not dissected yet", EXPFILL }},\r\n};\r\nexpert_module_t* expert_openflow_v1;\r\nproto_openflow_v1 = proto_register_protocol("OpenFlow 1.0",\r\n"openflow_v1", "openflow_v1");\r\nregister_dissector("openflow_v1", dissect_openflow_v1, proto_openflow_v1);\r\nproto_register_field_array(proto_openflow_v1, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_openflow_v1 = expert_register_protocol(proto_openflow_v1);\r\nexpert_register_field_array(expert_openflow_v1, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_openflow_v1(void)\r\n{\r\neth_withoutfcs_handle = find_dissector_add_dependency("eth_withoutfcs", proto_openflow_v1);\r\n}
