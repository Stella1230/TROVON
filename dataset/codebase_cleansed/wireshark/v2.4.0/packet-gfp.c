static void gfp_prompt(packet_info *pinfo, gchar* result)\r\n{\r\ng_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, "UPI %u as",\r\nGPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_gfp, 0)));\r\n}\r\nstatic gpointer gfp_value(packet_info *pinfo)\r\n{\r\nreturn p_get_proto_data(pinfo->pool, pinfo, proto_gfp, 0);\r\n}\r\nstatic void\r\ngfp_add_hec_tree(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint *offset, const guint len, const int field, const int field_status, expert_field *ei_bad)\r\n{\r\nguint hec_calc;\r\nhec_calc = crc16_r3_ccitt_tvb(tvb, *offset, len);\r\n*offset += len;\r\nproto_tree_add_checksum(tree, tvb, *offset, field, field_status, ei_bad, pinfo, hec_calc, ENC_BIG_ENDIAN, PROTO_CHECKSUM_VERIFY);\r\n*offset += 2;\r\n}\r\nstatic void\r\ndissect_gfp_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_tree *gfp_tree, guint *offset, guint payload_len)\r\n{\r\ntvbuff_t *payload_tvb;\r\nproto_item *type_ti = NULL;\r\nproto_item *fcs_ti;\r\nproto_tree *fcs_tree = NULL;\r\nguint pti, pfi, exi, upi;\r\nguint fcs, fcs_calc;\r\nguint fcs_len = 0;\r\ntvb_ensure_bytes_exist(tvb, *offset, 4);\r\npayload_len -= 4;\r\npti = tvb_get_bits8(tvb, 8*(*offset), 3);\r\npfi = tvb_get_bits8(tvb, 8*(*offset)+3, 1);\r\nexi = tvb_get_bits8(tvb, 8*(*offset)+4, 4);\r\nupi = tvb_get_guint8(tvb, *offset+1);\r\np_add_proto_data(pinfo->pool, pinfo, proto_gfp, 0, GUINT_TO_POINTER(upi));\r\ncol_add_str(pinfo->cinfo, COL_INFO, val_to_str(pti, gfp_pti_vals, "Reserved PTI (%d)"));\r\nif (pti == GFP_USER_DATA ||\r\npti == GFP_MANAGEMENT_COMMUNICATIONS) {\r\ntype_ti = proto_tree_add_bitmask_with_flags(gfp_tree, tvb, *offset, hf_gfp_type,\r\nett_gfp_type, gfp_type_data_fields, ENC_BIG_ENDIAN, BMT_NO_FLAGS);\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, ": ", rval_to_str(upi, gfp_upi_data_rvals, "Unknown 0x%02x"));\r\n} else if (pti == GFP_CLIENT_MANAGEMENT) {\r\ntype_ti = proto_tree_add_bitmask_with_flags(gfp_tree, tvb, *offset, hf_gfp_type,\r\nett_gfp_type, gfp_type_management_fields, ENC_BIG_ENDIAN, BMT_NO_FLAGS);\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, ": ", rval_to_str(upi, gfp_upi_management_rvals, "Unknown 0x%02x"));\r\n}\r\ngfp_add_hec_tree(tvb, pinfo, gfp_tree, offset, 2, hf_gfp_thec, hf_gfp_thec_status, &ei_gfp_thec_bad);\r\nswitch (exi) {\r\ncase GFP_EXT_NULL:\r\nbreak;\r\ncase GFP_EXT_LINEAR:\r\nif (payload_len < 4) {\r\nexpert_add_info(pinfo, type_ti, &ei_gfp_exi_short);\r\npayload_len = 0;\r\n}\r\nelse {\r\npayload_len -= 4;\r\n}\r\nproto_tree_add_item(gfp_tree, hf_gfp_cid, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\ngfp_add_hec_tree(tvb, pinfo, gfp_tree, offset, 2, hf_gfp_ehec, hf_gfp_ehec_status, &ei_gfp_ehec_bad);\r\nbreak;\r\ncase GFP_EXT_RING:\r\ndefault:\r\nbreak;\r\n}\r\nproto_item_set_end(gfp_tree, tvb, *offset);\r\nif (pfi == 1) {\r\nif (payload_len < 4) {\r\nexpert_add_info(pinfo, type_ti, &ei_gfp_pfi_short);\r\nfcs_len = payload_len;\r\npayload_len = 0;\r\n} else {\r\nfcs_len = 4;\r\npayload_len -= 4;\r\n}\r\nproto_tree_set_appendix(gfp_tree, tvb, *offset + payload_len, fcs_len);\r\nfcs = tvb_get_ntohl(tvb, *offset + payload_len);\r\nfcs_calc = crc32_mpeg2_tvb_offset(tvb, *offset, payload_len);\r\nif (fcs == ~fcs_calc) {\r\nfcs_ti = proto_tree_add_uint_format_value(gfp_tree, hf_gfp_fcs, tvb, *offset+payload_len, 4, fcs, "0x%08x [correct]", fcs);\r\nfcs_tree = proto_item_add_subtree(fcs_ti, ett_gfp_fcs);\r\nfcs_ti = proto_tree_add_boolean(fcs_tree, hf_gfp_fcs_good, tvb, *offset+payload_len, 4, TRUE);\r\nPROTO_ITEM_SET_GENERATED(fcs_ti);\r\nfcs_ti = proto_tree_add_boolean(fcs_tree, hf_gfp_fcs_bad, tvb, *offset+payload_len, 4, FALSE);\r\nPROTO_ITEM_SET_GENERATED(fcs_ti);\r\n} else {\r\nfcs_ti = proto_tree_add_uint_format_value(gfp_tree, hf_gfp_fcs, tvb, *offset+payload_len, 4, fcs, "0x%08x [incorrect, should be 0x%08x]", fcs, fcs_calc);\r\nfcs_tree = proto_item_add_subtree(fcs_ti, ett_gfp_fcs);\r\nfcs_ti = proto_tree_add_boolean(fcs_tree, hf_gfp_fcs_good, tvb, *offset+payload_len, 4, FALSE);\r\nPROTO_ITEM_SET_GENERATED(fcs_ti);\r\nfcs_ti = proto_tree_add_boolean(fcs_tree, hf_gfp_fcs_bad, tvb, *offset+payload_len, 4, TRUE);\r\nPROTO_ITEM_SET_GENERATED(fcs_ti);\r\nexpert_add_info(pinfo, fcs_ti, &ei_gfp_fcs_bad);\r\n}\r\n}\r\npayload_tvb = tvb_new_subset_length(tvb, *offset, payload_len);\r\nswitch (pti) {\r\ncase GFP_USER_DATA:\r\ncase GFP_MANAGEMENT_COMMUNICATIONS:\r\nif (!dissector_try_uint(gfp_dissector_table, upi, payload_tvb, pinfo, tree)) {\r\nexpert_add_info_format(pinfo, type_ti, &ei_gfp_payload_undecoded, "Payload type 0x%02x (%s) unsupported", upi, rval_to_str_const(upi, gfp_upi_data_rvals, "UNKNOWN"));\r\ncall_data_dissector(payload_tvb, pinfo, tree);\r\n}\r\nbreak;\r\ncase GFP_CLIENT_MANAGEMENT:\r\ncall_data_dissector(payload_tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n*offset += payload_len;\r\n*offset += fcs_len;\r\n}\r\nstatic int\r\ndissect_gfp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nvoid *data _U_)\r\n{\r\nproto_item *ti, *pli_ti;\r\nproto_tree *gfp_tree;\r\nguint offset = 0;\r\nint len = 0;\r\nguint pli;\r\nif (tvb_reported_length(tvb) < GFP_MIN_LENGTH)\r\nreturn 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "GFP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_SRC, "N/A");\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_DST, "N/A");\r\nti = proto_tree_add_item(tree, proto_gfp, tvb, 0, GFP_MIN_LENGTH, ENC_NA);\r\ngfp_tree = proto_item_add_subtree(ti, ett_gfp);\r\nlen = 2;\r\npli_ti = proto_tree_add_item_ret_uint(gfp_tree, hf_gfp_pli, tvb,\r\noffset, len, ENC_BIG_ENDIAN, &pli);\r\nif (pli < 4) {\r\nproto_item_append_text(pli_ti, " (%s)", rval_to_str_const(pli, gfp_pli_rvals, "Unknown"));\r\n}\r\ncol_set_str(pinfo->cinfo, COL_INFO, rval_to_str_const(pli, gfp_pli_rvals, "Unknown"));\r\ngfp_add_hec_tree(tvb, pinfo, gfp_tree, &offset, len, hf_gfp_chec, hf_gfp_chec_status, &ei_gfp_chec_bad);\r\nif (pli == 0) {\r\nif (tvb_reported_length_remaining(tvb, offset)) {\r\nexpert_add_info(pinfo, pli_ti, &ei_gfp_pli_idle_nonempty);\r\n}\r\n} else if (pli < 4) {\r\nexpert_add_info(pinfo, pli_ti, &ei_gfp_pli_unknown);\r\n} else {\r\nif (tvb_reported_length(tvb) < pli + offset) {\r\nproto_item_append_text(pli_ti, " (invalid, reported length is %u)", tvb_reported_length_remaining(tvb, offset));\r\nexpert_add_info(pinfo, pli_ti, &ei_gfp_pli_invalid);\r\n}\r\ndissect_gfp_payload(tvb, pinfo, tree, gfp_tree, &offset, pli);\r\n}\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_gfp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_gfp_pli,\r\n{ "Payload Length Indicator", "gfp.pli", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_gfp_chec,\r\n{ "Core HEC", "gfp.chec", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_gfp_chec_status,\r\n{ "cHEC Status", "gfp.chec.status", FT_UINT8, BASE_NONE, VALS(proto_checksum_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gfp_type,\r\n{ "Type Field", "gfp.type", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gfp_pti,\r\n{ "PTI", "gfp.pti", FT_UINT16, BASE_HEX, VALS(gfp_pti_vals),\r\n0xE000, "Payload Type Identifier", HFILL }\r\n},\r\n{ &hf_gfp_pfi,\r\n{ "PFI", "gfp.pfi", FT_BOOLEAN, 16, TFS(&tfs_present_absent),\r\n0x1000, "Payload FCS Indicator", HFILL }\r\n},\r\n{ &hf_gfp_exi,\r\n{ "EXI", "gfp.exi", FT_UINT16, BASE_HEX, VALS(gfp_exi_vals),\r\n0x0F00, "Extension Header Identifier", HFILL }\r\n},\r\n{ &hf_gfp_upi_data,\r\n{ "UPI", "gfp.upi", FT_UINT16, BASE_HEX|BASE_RANGE_STRING,\r\nRVALS(gfp_upi_data_rvals),\r\n0xFF, "User Payload Identifier for Client Data Frame (or Management Communications Frame)", HFILL }\r\n},\r\n{ &hf_gfp_upi_management,\r\n{ "UPI", "gfp.upi", FT_UINT16, BASE_HEX|BASE_RANGE_STRING,\r\nRVALS(gfp_upi_management_rvals),\r\n0xFF, "User Payload Identifier for Client Management Frame", HFILL }\r\n},\r\n{ &hf_gfp_thec,\r\n{ "Type HEC", "gfp.thec", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gfp_thec_status,\r\n{ "tHEC Status", "gfp.thec.status", FT_UINT8, BASE_NONE, VALS(proto_checksum_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gfp_cid,\r\n{ "Channel ID", "gfp.cid", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gfp_ehec,\r\n{ "Extension HEC", "gfp.ehec", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gfp_ehec_status,\r\n{ "eHEC Status", "gfp.ehec.status", FT_UINT8, BASE_NONE, VALS(proto_checksum_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gfp_fcs,\r\n{ "Payload FCS", "gfp.fcs", FT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gfp_fcs_good,\r\n{ "Good FCS", "gfp.fcs_good", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"True: FCS matches payload; False: doesn't match", HFILL }\r\n},\r\n{ &hf_gfp_fcs_bad,\r\n{ "Bad eHEC", "gfp.fcs_bad", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"True: FCS doesn't match payload; False: matches", HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_gfp,\r\n&ett_gfp_type,\r\n&ett_gfp_fcs\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_gfp_pli_idle_nonempty,\r\n{ "gfp.pli.idle.nonempty", PI_MALFORMED, PI_ERROR,\r\n"Payload present on idle frame", EXPFILL }\r\n},\r\n{ &ei_gfp_pli_unknown,\r\n{ "gfp.pli.unknown", PI_UNDECODED, PI_WARN,\r\n"Unknown control frame type", EXPFILL }\r\n},\r\n{ &ei_gfp_pli_invalid,\r\n{ "gfp.pli.invalid", PI_MALFORMED, PI_WARN,\r\n"Bogus PLI does not match reported length", EXPFILL }\r\n},\r\n{ &ei_gfp_chec_bad,\r\n{ "gfp.chec.bad", PI_CHECKSUM, PI_WARN,\r\n"Bad cHEC", EXPFILL }\r\n},\r\n{ &ei_gfp_thec_bad,\r\n{ "gfp.thec.bad", PI_CHECKSUM, PI_WARN,\r\n"Bad tHEC", EXPFILL }\r\n},\r\n{ &ei_gfp_ehec_bad,\r\n{ "gfp.ehec.bad", PI_CHECKSUM, PI_WARN,\r\n"Bad eHEC", EXPFILL }\r\n},\r\n{ &ei_gfp_exi_short,\r\n{ "gfp.exi.missing", PI_MALFORMED, PI_ERROR,\r\n"EXI bit set but PLI too short for extension header", EXPFILL}\r\n},\r\n{ &ei_gfp_pfi_short,\r\n{ "gfp.pfi.missing", PI_MALFORMED, PI_ERROR,\r\n"PFI bit set but PLI too short for payload FCS", EXPFILL}\r\n},\r\n{ &ei_gfp_payload_undecoded,\r\n{ "gfp.payload.undecoded", PI_UNDECODED, PI_WARN,\r\n"Payload type not supported yet by the dissector", EXPFILL}\r\n},\r\n{ &ei_gfp_fcs_bad,\r\n{ "gfp.fcs.bad", PI_CHECKSUM, PI_WARN,\r\n"Bad FCS", EXPFILL }\r\n}\r\n};\r\nstatic build_valid_func gfp_da_build_value[1] = {gfp_value};\r\nstatic decode_as_value_t gfp_da_values = {gfp_prompt, 1, gfp_da_build_value};\r\nstatic decode_as_t gfp_da = {"gfp", "GFP", "gfp.upi", 1, 0, &gfp_da_values, NULL, NULL,\r\ndecode_as_default_populate_list, decode_as_default_reset, decode_as_default_change, NULL};\r\nexpert_module_t *expert_gfp;\r\nproto_gfp = proto_register_protocol("Generic Framing Procedure",\r\n"GFP", "gfp");\r\nproto_register_field_array(proto_gfp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_gfp = expert_register_protocol(proto_gfp);\r\nexpert_register_field_array(expert_gfp, ei, array_length(ei));\r\ngfp_dissector_table = register_dissector_table("gfp.upi", "GFP UPI (for Client Data frames)",\r\nproto_gfp, FT_UINT8, BASE_DEC);\r\nregister_decode_as(&gfp_da);\r\n}\r\nvoid\r\nproto_reg_handoff_gfp(void)\r\n{\r\nstatic dissector_handle_t gfp_handle;\r\ngfp_handle = create_dissector_handle(dissect_gfp,\r\nproto_gfp);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_GFP_T, gfp_handle);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_GFP_F, gfp_handle);\r\ndissector_add_uint("gfp.upi", 1, find_dissector("eth_withfcs"));\r\ndissector_add_uint("gfp.upi", 2, find_dissector("ppp_hdlc"));\r\ndissector_add_uint("gfp.upi", 12, find_dissector("mpls"));\r\ndissector_add_uint("gfp.upi", 13, find_dissector("mpls"));\r\ndissector_add_uint("gfp.upi", 16, find_dissector("ip"));\r\ndissector_add_uint("gfp.upi", 17, find_dissector("ipv6"));\r\n}
