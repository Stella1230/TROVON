static int\r\ndissect_ipnet(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *fh_tree;\r\nproto_item *ti;\r\ntvbuff_t *next_tvb;\r\nguint32 pktlen;\r\nguint8 family;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "IPNET");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Solaris IPNET");\r\nif(tree) {\r\nti = proto_tree_add_item (tree, proto_ipnet, tvb, 0, 24, ENC_NA);\r\nfh_tree = proto_item_add_subtree(ti, ett_raw);\r\nproto_tree_add_item(fh_tree, hf_version, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fh_tree, hf_family, tvb, 1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fh_tree, hf_htype, tvb, 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fh_tree, hf_pktlen, tvb, 4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fh_tree, hf_ifindex, tvb, 8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fh_tree, hf_grifindex, tvb, 12, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fh_tree, hf_zsrc, tvb, 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fh_tree, hf_zdst, tvb, 20, 4, ENC_BIG_ENDIAN);\r\n}\r\npktlen = tvb_get_ntohl(tvb, 4);\r\nnext_tvb = tvb_new_subset_remaining(tvb, tvb_captured_length(tvb) - pktlen);\r\nfamily = tvb_get_guint8(tvb, 1);\r\nswitch (family) {\r\ncase SOLARIS_AF_INET:\r\ncall_dissector(ip_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ncase SOLARIS_AF_INET6:\r\ncall_dissector(ipv6_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ipnet(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_version, { "Header version", "ipnet.version",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_family, { "Address family", "ipnet.family",\r\nFT_UINT8, BASE_DEC, VALS(solaris_family_vals), 0x0, NULL, HFILL }},\r\n{ &hf_htype, { "Hook type", "ipnet.htype",\r\nFT_UINT16, BASE_DEC, VALS(htype_vals), 0x0, NULL, HFILL }},\r\n{ &hf_pktlen, { "Data length", "ipnet.pktlen",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ifindex, { "Interface index", "ipnet.ifindex",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_grifindex, { "Group interface index", "ipnet.grifindex",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_zsrc, { "Source Zone ID", "ipnet.zsrc",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_zdst, { "Destination Zone ID", "ipnet.zdst",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_raw,\r\n};\r\nproto_ipnet = proto_register_protocol("Solaris IPNET", "IPNET", "ipnet");\r\nproto_register_field_array(proto_ipnet, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_ipnet(void)\r\n{\r\ndissector_handle_t ipnet_handle;\r\nip_handle = find_dissector_add_dependency("ip", proto_ipnet);\r\nipv6_handle = find_dissector_add_dependency("ipv6", proto_ipnet);\r\nipnet_handle = create_dissector_handle(dissect_ipnet, proto_ipnet);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_IPNET, ipnet_handle);\r\n}
