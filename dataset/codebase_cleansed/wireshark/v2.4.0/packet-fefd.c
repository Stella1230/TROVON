static int\r\ndissect_fefd(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *fefd_tree = NULL;\r\nint offset = 0;\r\nguint16 type;\r\nguint16 length;\r\nproto_tree *tlv_tree;\r\nint real_length;\r\nstatic const int * flags[] = {\r\n&hf_fefd_flags_rt,\r\n&hf_fefd_flags_rsy,\r\nNULL\r\n};\r\nstatic const int * headers[] = {\r\n&hf_fefd_version,\r\n&hf_fefd_opcode,\r\nNULL\r\n};\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "FEFD");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nti = proto_tree_add_item(tree, proto_fefd, tvb, offset, -1, ENC_NA);\r\nfefd_tree = proto_item_add_subtree(ti, ett_fefd);\r\nproto_tree_add_bitmask_list(fefd_tree, tvb, offset, 1, headers, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_bitmask(fefd_tree, tvb, offset, hf_fefd_flags, ett_fefd_flags, flags, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_checksum(fefd_tree, tvb, offset, hf_fefd_checksum, -1, NULL, pinfo, 0, ENC_BIG_ENDIAN, PROTO_CHECKSUM_NO_FLAGS);\r\noffset += 2;\r\nwhile (tvb_reported_length_remaining(tvb, offset) != 0) {\r\ntype = tvb_get_ntohs(tvb, offset + TLV_TYPE);\r\nlength = tvb_get_ntohs(tvb, offset + TLV_LENGTH);\r\nif (length < 4) {\r\nif (tree) {\r\ntlv_tree = proto_tree_add_subtree_format(fefd_tree, tvb, offset, 4,\r\nett_fefd_tlv, NULL, "TLV with invalid length %u (< 4)",\r\nlength);\r\nproto_tree_add_uint(tlv_tree, hf_fefd_tlvtype, tvb,\r\noffset + TLV_TYPE, 2, type);\r\nproto_tree_add_uint(tlv_tree, hf_fefd_tlvlength, tvb,\r\noffset + TLV_LENGTH, 2, length);\r\n}\r\noffset += 4;\r\nbreak;\r\n}\r\nswitch (type) {\r\ncase TYPE_DEVICE_ID:\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, NULL,\r\n"Device ID: %s",\r\ntvb_format_stringzpad(tvb, offset + 4,\r\nlength - 4));\r\nif (tree) {\r\ntlv_tree = proto_tree_add_subtree_format(fefd_tree, tvb, offset,\r\nlength, ett_fefd_tlv, NULL, "Device ID: %s",\r\ntvb_format_stringzpad(tvb, offset + 4, length - 4));\r\nproto_tree_add_uint(tlv_tree, hf_fefd_tlvtype, tvb,\r\noffset + TLV_TYPE, 2, type);\r\nproto_tree_add_uint(tlv_tree, hf_fefd_tlvlength, tvb,\r\noffset + TLV_LENGTH, 2, length);\r\nproto_tree_add_item(tlv_tree, hf_fefd_device_id, tvb, offset + 4,\r\nlength - 4, ENC_NA|ENC_ASCII);\r\n}\r\noffset += length;\r\nbreak;\r\ncase TYPE_PORT_ID:\r\nreal_length = length;\r\nif (tvb_get_guint8(tvb, offset + real_length) != 0x00) {\r\nreal_length = length + 3;\r\n}\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, NULL,\r\n"Port ID: %s",\r\ntvb_format_stringzpad(tvb, offset + 4, real_length - 4));\r\nif (tree) {\r\ntlv_tree = proto_tree_add_subtree_format(fefd_tree, tvb, offset,\r\nreal_length, ett_fefd_tlv, NULL, "Port ID: %s",\r\ntvb_format_text(tvb, offset + 4, real_length - 4));\r\nproto_tree_add_uint(tlv_tree, hf_fefd_tlvtype, tvb,\r\noffset + TLV_TYPE, 2, type);\r\nproto_tree_add_uint(tlv_tree, hf_fefd_tlvlength, tvb,\r\noffset + TLV_LENGTH, 2, length);\r\nproto_tree_add_item(tlv_tree, hf_fefd_sent_through_interface, tvb, offset + 4,\r\nreal_length - 4, ENC_NA|ENC_ASCII);\r\n}\r\noffset += real_length;\r\nbreak;\r\ncase TYPE_ECHO:\r\ncase TYPE_MESSAGE_INTERVAL:\r\ncase TYPE_TIMEOUT_INTERVAL:\r\ncase TYPE_DEVICE_NAME:\r\ncase TYPE_SEQUENCE_NUMBER:\r\ndefault:\r\ntlv_tree = proto_tree_add_subtree_format(fefd_tree, tvb, offset,\r\nlength, ett_fefd_tlv, NULL, "Type: %s, length: %u",\r\nval_to_str(type, type_vals, "Unknown (0x%04x)"),\r\nlength);\r\nproto_tree_add_uint(tlv_tree, hf_fefd_tlvtype, tvb,\r\noffset + TLV_TYPE, 2, type);\r\nproto_tree_add_uint(tlv_tree, hf_fefd_tlvlength, tvb,\r\noffset + TLV_LENGTH, 2, length);\r\nif (length > 4) {\r\nproto_tree_add_item(tlv_tree, hf_fefd_data, tvb, offset + 4,\r\nlength - 4, ENC_NA);\r\n} else {\r\nreturn tvb_captured_length(tvb);\r\n}\r\noffset += length;\r\n}\r\n}\r\ncall_data_dissector(tvb_new_subset_remaining(tvb, offset), pinfo, fefd_tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_fefd(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_fefd_version,\r\n{ "Version", "fefd.version", FT_UINT8, BASE_DEC, NULL, 0xE0,\r\nNULL, HFILL }},\r\n{ &hf_fefd_opcode,\r\n{ "Opcode", "fefd.opcode", FT_UINT8, BASE_DEC, VALS(opcode_vals), 0x1F,\r\nNULL, HFILL }},\r\n{ &hf_fefd_flags,\r\n{ "Flags", "fefd.flags", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_fefd_flags_rt,\r\n{ "Recommended timeout", "fefd.flags.rt", FT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }},\r\n{ &hf_fefd_flags_rsy,\r\n{ "ReSynch", "fefd.flags.rsy", FT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL }},\r\n{ &hf_fefd_checksum,\r\n{ "Checksum", "fefd.checksum", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_fefd_tlvtype,\r\n{ "Type", "fefd.tlv.type", FT_UINT16, BASE_HEX, VALS(type_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_fefd_tlvlength,\r\n{ "Length", "fefd.tlv.len", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_fefd_device_id,\r\n{ "Device ID", "fefd.device_id", FT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_fefd_sent_through_interface,\r\n{ "Sent through Interface", "fefd.sent_through_interface", FT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_fefd_data,\r\n{ "Data", "fefd.data", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_fefd,\r\n&ett_fefd_flags,\r\n&ett_fefd_tlv\r\n};\r\nproto_fefd = proto_register_protocol("Far End Failure Detection", "FEFD", "fefd");\r\nproto_register_field_array(proto_fefd, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_fefd(void)\r\n{\r\ndissector_handle_t fefd_handle;\r\nfefd_handle = create_dissector_handle(dissect_fefd, proto_fefd);\r\ndissector_add_uint("llc.force10_pid", 0x0111, fefd_handle);\r\n}
