static int\r\ndissect_fhstatus(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, rpc_call_info_value* civ)\r\n{\r\ngint32 status;\r\nstatus=tvb_get_ntohl(tvb,offset);\r\noffset = dissect_rpc_uint32(tvb,tree,hf_mount3_status,offset);\r\nswitch (status) {\r\ncase 0:\r\noffset = dissect_fhandle(tvb,offset,pinfo,tree,"fhandle", NULL, civ);\r\nbreak;\r\ndefault:\r\ncol_append_fstr(\r\npinfo->cinfo, COL_INFO, " Error:%s",\r\nval_to_str(status, mount3_mountstat3,\r\n"Unknown (0x%08X)"));\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_mount_dirpath_call(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data)\r\n{\r\nconst char *mountpoint=NULL;\r\nint offset = 0;\r\nif((!pinfo->fd->flags.visited) && nfs_file_name_snooping){\r\nrpc_call_info_value *civ=(rpc_call_info_value *)data;\r\nif(civ->request && (civ->proc==1)){\r\nguint32 len_field;\r\nlen_field = tvb_get_ntohl(tvb, offset);\r\nif (len_field < ITEM_LABEL_LENGTH) {\r\ngchar *name, *ptr;\r\nint addr_len, name_len;\r\nname = address_to_str(wmem_packet_scope(), &pinfo->dst);\r\naddr_len = (int)strlen(name);\r\nname_len = addr_len + 1 + len_field + 1;\r\nname = (gchar *)wmem_realloc(wmem_packet_scope(),\r\n(void *)name, name_len);\r\nptr = name + addr_len;\r\n*ptr++ = ':';\r\ntvb_memcpy(tvb, ptr, offset+4, len_field);\r\nptr += len_field;\r\n*ptr = 0;\r\nnfs_name_snoop_add_name(civ->xid, tvb, -1, name_len, 0, 0, name);\r\n}\r\n}\r\n}\r\noffset = dissect_rpc_string(tvb,tree,hf_mount_path,offset,&mountpoint);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO," %s", mountpoint);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_mount1_mnt_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\nreturn dissect_fhstatus(tvb,0,pinfo,tree,(rpc_call_info_value*)data);\r\n}\r\nstatic int\r\ndissect_mountlist(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item* lock_item;\r\nproto_tree* lock_tree;\r\nint old_offset = offset;\r\nconst char* hostname;\r\nconst char* directory;\r\nlock_item = proto_tree_add_item(tree, hf_mount_mountlist, tvb,\r\noffset, -1, ENC_NA);\r\nlock_tree = proto_item_add_subtree(lock_item, ett_mount_mountlist);\r\noffset = dissect_rpc_string(tvb, lock_tree,\r\nhf_mount_mountlist_hostname, offset, &hostname);\r\noffset = dissect_rpc_string(tvb, lock_tree,\r\nhf_mount_mountlist_directory, offset, &directory);\r\nif (lock_item) {\r\nproto_item_set_text(lock_item, "Mount List Entry: %s:%s", hostname, directory);\r\nproto_item_set_len(lock_item, offset - old_offset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_mount_dump_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nreturn dissect_rpc_list(tvb, pinfo, tree, 0,\r\ndissect_mountlist, NULL);\r\n}\r\nstatic int\r\ndissect_group(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint str_len;\r\nif (group_names_len < MAX_GROUP_NAME_LIST - 5) {\r\nstr_len=tvb_get_nstringz(tvb,offset+4,\r\nMAX_GROUP_NAME_LIST-5-group_names_len,\r\ngroup_name_list+group_names_len);\r\nif((group_names_len>=(MAX_GROUP_NAME_LIST-5))||(str_len<0)){\r\ng_snprintf(group_name_list+(MAX_GROUP_NAME_LIST-5), 5, "...");\r\ngroup_names_len=MAX_GROUP_NAME_LIST - 1;\r\n} else {\r\ngroup_names_len+=str_len;\r\ngroup_name_list[group_names_len++]=' ';\r\n}\r\ngroup_name_list[group_names_len]=0;\r\n}\r\noffset = dissect_rpc_string(tvb, tree,\r\nhf_mount_groups_group, offset, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_exportlist(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item* exportlist_item = NULL;\r\nproto_tree* exportlist_tree = NULL;\r\nint old_offset = offset;\r\nint groups_offset;\r\nproto_item* groups_item = NULL;\r\nproto_item* groups_tree = NULL;\r\nconst char* directory;\r\ngroup_name_list[0]=0;\r\ngroup_names_len=0;\r\nif (tree) {\r\nexportlist_item = proto_tree_add_item(tree, hf_mount_exportlist, tvb, offset, -1, ENC_NA);\r\nexportlist_tree = proto_item_add_subtree(exportlist_item, ett_mount_exportlist);\r\n}\r\noffset = dissect_rpc_string(tvb, exportlist_tree,\r\nhf_mount_exportlist_directory, offset, &directory);\r\ngroups_offset = offset;\r\ngroups_item = proto_tree_add_item(exportlist_tree, hf_mount_groups, tvb, offset, -1, ENC_NA);\r\ngroups_tree = proto_item_add_subtree(groups_item, ett_mount_groups);\r\noffset = dissect_rpc_list(tvb, pinfo, groups_tree, offset,\r\ndissect_group, NULL);\r\nif (groups_item) {\r\nif (offset - groups_offset == 4) {\r\nproto_item_set_text(groups_item, "Groups: empty");\r\n}\r\nproto_item_set_len(groups_item, offset - groups_offset);\r\n}\r\nif (exportlist_item) {\r\nproto_item_set_text(exportlist_item, "Export List Entry: %s -> %s", directory,group_name_list);\r\nproto_item_set_len(exportlist_item, offset - old_offset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_mount_export_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nreturn dissect_rpc_list(tvb, pinfo, tree, 0,\r\ndissect_exportlist, NULL);\r\n}\r\nstatic int\r\ndissect_mount_pathconf_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nguint32 pc_mask;\r\nstatic const int * flags[] = {\r\n&hf_mount_pathconf_error_all,\r\n&hf_mount_pathconf_error_link_max,\r\n&hf_mount_pathconf_error_max_canon,\r\n&hf_mount_pathconf_error_max_input,\r\n&hf_mount_pathconf_error_name_max,\r\n&hf_mount_pathconf_error_path_max,\r\n&hf_mount_pathconf_error_pipe_buf,\r\n&hf_mount_pathconf_chown_restricted,\r\n&hf_mount_pathconf_no_trunc,\r\n&hf_mount_pathconf_error_vdisable,\r\nNULL\r\n};\r\nint offset = 0;\r\npc_mask = tvb_get_ntohl(tvb, offset+OFFS_MASK) & 0xffff;\r\nif (!(pc_mask & (PC_ERROR_LINK_MAX|PC_ERROR_ALL))) {\r\ndissect_rpc_uint32(tvb,tree,hf_mount_pathconf_link_max,offset);\r\n}\r\noffset += 4;\r\nif (!(pc_mask & (PC_ERROR_MAX_CANON|PC_ERROR_ALL))) {\r\nproto_tree_add_item(tree,\r\nhf_mount_pathconf_max_canon,tvb,offset+2,2,\r\ntvb_get_ntohs(tvb,offset)&0xffff);\r\n}\r\noffset += 4;\r\nif (!(pc_mask & (PC_ERROR_MAX_INPUT|PC_ERROR_ALL))) {\r\nproto_tree_add_item(tree,\r\nhf_mount_pathconf_max_input,tvb,offset+2,2,\r\ntvb_get_ntohs(tvb,offset)&0xffff);\r\n}\r\noffset += 4;\r\nif (!(pc_mask & (PC_ERROR_NAME_MAX|PC_ERROR_ALL))) {\r\nproto_tree_add_item(tree,\r\nhf_mount_pathconf_name_max,tvb,offset+2,2,\r\ntvb_get_ntohs(tvb,offset)&0xffff);\r\n}\r\noffset += 4;\r\nif (!(pc_mask & (PC_ERROR_PATH_MAX|PC_ERROR_ALL))) {\r\nproto_tree_add_item(tree,\r\nhf_mount_pathconf_path_max,tvb,offset+2,2,\r\ntvb_get_ntohs(tvb,offset)&0xffff);\r\n}\r\noffset += 4;\r\nif (!(pc_mask & (PC_ERROR_PIPE_BUF|PC_ERROR_ALL))) {\r\nproto_tree_add_item(tree,\r\nhf_mount_pathconf_pipe_buf,tvb,offset+2,2,\r\ntvb_get_ntohs(tvb,offset)&0xffff);\r\n}\r\noffset += 4;\r\noffset += 4;\r\nif (!(pc_mask & (PC_ERROR_VDISABLE|PC_ERROR_ALL))) {\r\nproto_tree_add_item(tree,\r\nhf_mount_pathconf_vdisable,tvb,offset+3,1,\r\ntvb_get_ntohs(tvb,offset)&0xffff);\r\n}\r\noffset += 4;\r\nproto_tree_add_bitmask(tree, tvb, offset+2, hf_mount_pathconf_mask, ett_mount_pathconf_mask, flags, ENC_BIG_ENDIAN);\r\noffset += 8;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_mountstat3(packet_info *pinfo, tvbuff_t *tvb, proto_tree *tree, int offset, int hfindex, guint32 *status)\r\n{\r\nguint32 mountstat3;\r\nmountstat3 = tvb_get_ntohl(tvb, offset);\r\nif(mountstat3){\r\ncol_append_fstr(\r\npinfo->cinfo, COL_INFO, " Error:%s",\r\nval_to_str(mountstat3, mount3_mountstat3,\r\n"Unknown (0x%08X)"));\r\n}\r\noffset = dissect_rpc_uint32(tvb,tree,hfindex,offset);\r\n*status = mountstat3;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_mount3_mnt_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\nguint32 status;\r\nguint32 auth_flavors;\r\nguint32 auth_flavor;\r\nguint32 auth_flavor_i;\r\nint offset = 0;\r\noffset = dissect_mountstat3(pinfo,tvb,tree,offset,hf_mount3_status,&status);\r\nswitch (status) {\r\ncase 0:\r\noffset = dissect_nfs3_fh(tvb,offset,pinfo,tree,"fhandle",NULL,(rpc_call_info_value*)data);\r\nauth_flavors = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_uint(tree,hf_mount_flavors, tvb,\r\noffset, 4, auth_flavors);\r\noffset += 4;\r\nfor (auth_flavor_i = 0 ; auth_flavor_i < auth_flavors ; auth_flavor_i++) {\r\nauth_flavor = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_uint(tree,hf_mount_flavor, tvb,\r\noffset, 4, auth_flavor);\r\noffset += 4;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_sgi_exportlist(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item* exportlist_item = NULL;\r\nproto_tree* exportlist_tree = NULL;\r\nint old_offset = offset;\r\nconst char* directory, *options;\r\nif (tree) {\r\nexportlist_item = proto_tree_add_item(tree, hf_mount_exportlist,\r\ntvb, offset, -1, ENC_NA);\r\nif (exportlist_item)\r\nexportlist_tree = proto_item_add_subtree(exportlist_item,\r\nett_mount_exportlist);\r\n}\r\noffset = dissect_rpc_string(tvb, exportlist_tree,\r\nhf_mount_exportlist_directory, offset, &directory);\r\noffset = dissect_rpc_bool(tvb, exportlist_tree,\r\nhf_mount_has_options, offset);\r\noffset = dissect_rpc_string(tvb, exportlist_tree, hf_mount_options,\r\noffset, &options);\r\nif (exportlist_item) {\r\nproto_item_set_text(exportlist_item,\r\n"Export List Entry: %s %s", directory,\r\noptions);\r\nproto_item_set_len(exportlist_item, offset - old_offset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_mount_exportlist_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nreturn dissect_rpc_list(tvb, pinfo, tree, 0,\r\ndissect_sgi_exportlist, NULL);\r\n}\r\nstatic int\r\ndissect_mount_statvfs_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nstatic const int * flags[] = {\r\n&hf_mount_statvfs_flag_rdonly,\r\n&hf_mount_statvfs_flag_nosuid,\r\n&hf_mount_statvfs_flag_notrunc,\r\n&hf_mount_statvfs_flag_nodev,\r\n&hf_mount_statvfs_flag_grpid,\r\n&hf_mount_statvfs_flag_local,\r\nNULL\r\n};\r\nint offset = 0;\r\ndissect_rpc_uint32(tvb, tree, hf_mount_statvfs_bsize, offset);\r\noffset += 4;\r\ndissect_rpc_uint32(tvb, tree, hf_mount_statvfs_frsize, offset);\r\noffset += 4;\r\ndissect_rpc_uint32(tvb, tree, hf_mount_statvfs_blocks, offset);\r\noffset += 4;\r\ndissect_rpc_uint32(tvb, tree, hf_mount_statvfs_bfree, offset);\r\noffset += 4;\r\ndissect_rpc_uint32(tvb, tree, hf_mount_statvfs_bavail, offset);\r\noffset += 4;\r\ndissect_rpc_uint32(tvb, tree, hf_mount_statvfs_files, offset);\r\noffset += 4;\r\ndissect_rpc_uint32(tvb, tree, hf_mount_statvfs_ffree, offset);\r\noffset += 4;\r\ndissect_rpc_uint32(tvb, tree, hf_mount_statvfs_favail, offset);\r\noffset += 4;\r\ndissect_rpc_bytes(tvb, tree, hf_mount_statvfs_basetype, offset,\r\n16, TRUE, NULL);\r\noffset += 16;\r\ndissect_rpc_bytes(tvb, tree, hf_mount_statvfs_fstr, offset, 32, FALSE, NULL);\r\noffset += 32;\r\ndissect_rpc_uint32(tvb, tree, hf_mount_statvfs_fsid, offset);\r\noffset += 4;\r\nproto_tree_add_bitmask(tree, tvb, offset, hf_mount_statvfs_flag, ett_mount_statvfs_flag, flags, ENC_BIG_ENDIAN);\r\noffset += 4;\r\ndissect_rpc_uint32(tvb, tree, hf_mount_statvfs_namemax, offset);\r\noffset += 4;\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_mount(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_mount_procedure_v1, {\r\n"V1 Procedure", "mount.procedure_v1", FT_UINT32, BASE_DEC,\r\nVALS(mount1_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_mount_procedure_v2, {\r\n"V2 Procedure", "mount.procedure_v2", FT_UINT32, BASE_DEC,\r\nVALS(mount2_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_mount_procedure_v3, {\r\n"V3 Procedure", "mount.procedure_v3", FT_UINT32, BASE_DEC,\r\nVALS(mount3_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_sgi_mount_procedure_v1, {\r\n"SGI V1 procedure", "mount.procedure_sgi_v1", FT_UINT32, BASE_DEC,\r\nVALS(sgi_mount1_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_mount_path, {\r\n"Path", "mount.path", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_mount3_status, {\r\n"Status", "mount.status", FT_UINT32, BASE_DEC,\r\nVALS(mount3_mountstat3), 0, NULL, HFILL }},\r\n{ &hf_mount_mountlist_hostname, {\r\n"Hostname", "mount.dump.hostname", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_mount_mountlist_directory, {\r\n"Directory", "mount.dump.directory", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_mount_mountlist, {\r\n"Mount List Entry", "mount.dump.entry", FT_NONE, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_mount_groups_group, {\r\n"Group", "mount.export.group", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_mount_groups, {\r\n"Groups", "mount.export.groups", FT_NONE, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_mount_has_options, {\r\n"Has options", "mount.export.has_options", FT_UINT32,\r\nBASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_mount_options, {\r\n"Options", "mount.export.options", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_mount_exportlist_directory, {\r\n"Directory", "mount.export.directory", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_mount_exportlist, {\r\n"Export List Entry", "mount.export.entry", FT_NONE, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_mount_pathconf_link_max, {\r\n"Maximum number of links to a file", "mount.pathconf.link_max",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, "Maximum number of links allowed to a file", HFILL }},\r\n{ &hf_mount_pathconf_max_canon, {\r\n"Maximum terminal input line length", "mount.pathconf.max_canon",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0, "Max tty input line length", HFILL }},\r\n{ &hf_mount_pathconf_max_input, {\r\n"Terminal input buffer size", "mount.pathconf.max_input",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_mount_pathconf_name_max, {\r\n"Maximum file name length", "mount.pathconf.name_max",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_mount_pathconf_path_max, {\r\n"Maximum path name length", "mount.pathconf.path_max",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_mount_pathconf_pipe_buf, {\r\n"Pipe buffer size", "mount.pathconf.pipe_buf",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0, "Maximum amount of data that can be written atomically to a pipe", HFILL }},\r\n{ &hf_mount_pathconf_vdisable, {\r\n"VDISABLE character", "mount.pathconf.vdisable_char",\r\nFT_UINT8, BASE_HEX,\r\nNULL, 0, "Character value to disable a terminal special character", HFILL }},\r\n{ &hf_mount_pathconf_mask, {\r\n"Reply error/status bits", "mount.pathconf.mask",\r\nFT_UINT16, BASE_HEX,\r\nNULL, 0, "Bit mask with error and status bits", HFILL }},\r\n{ &hf_mount_pathconf_error_all, {\r\n"ERROR_ALL", "mount.pathconf.mask.error_all",\r\nFT_BOOLEAN, 16, TFS(&tos_error_all),\r\nPC_ERROR_ALL, NULL, HFILL }},\r\n{ &hf_mount_pathconf_error_link_max, {\r\n"ERROR_LINK_MAX", "mount.pathconf.mask.error_link_max",\r\nFT_BOOLEAN, 16, TFS(&tos_error_link_max),\r\nPC_ERROR_LINK_MAX, NULL, HFILL }},\r\n{ &hf_mount_pathconf_error_max_canon, {\r\n"ERROR_MAX_CANON", "mount.pathconf.mask.error_max_canon",\r\nFT_BOOLEAN, 16, TFS(&tos_error_max_canon),\r\nPC_ERROR_MAX_CANON, NULL, HFILL }},\r\n{ &hf_mount_pathconf_error_max_input, {\r\n"ERROR_MAX_INPUT", "mount.pathconf.mask.error_max_input",\r\nFT_BOOLEAN, 16, TFS(&tos_error_max_input),\r\nPC_ERROR_MAX_INPUT, NULL, HFILL }},\r\n{ &hf_mount_pathconf_error_name_max, {\r\n"ERROR_NAME_MAX", "mount.pathconf.mask.error_name_max",\r\nFT_BOOLEAN, 16, TFS(&tos_error_name_max),\r\nPC_ERROR_NAME_MAX, NULL, HFILL }},\r\n{ &hf_mount_pathconf_error_path_max, {\r\n"ERROR_PATH_MAX", "mount.pathconf.mask.error_path_max",\r\nFT_BOOLEAN, 16, TFS(&tos_error_path_max),\r\nPC_ERROR_PATH_MAX, NULL, HFILL }},\r\n{ &hf_mount_pathconf_error_pipe_buf, {\r\n"ERROR_PIPE_BUF", "mount.pathconf.mask.error_pipe_buf",\r\nFT_BOOLEAN, 16, TFS(&tos_error_pipe_buf),\r\nPC_ERROR_PIPE_BUF, NULL, HFILL }},\r\n{ &hf_mount_pathconf_chown_restricted, {\r\n"CHOWN_RESTRICTED", "mount.pathconf.mask.chown_restricted",\r\nFT_BOOLEAN, 16, TFS(&tos_chown_restricted),\r\nPC_CHOWN_RESTRICTED, NULL, HFILL }},\r\n{ &hf_mount_pathconf_no_trunc, {\r\n"NO_TRUNC", "mount.pathconf.mask.no_trunc",\r\nFT_BOOLEAN, 16, TFS(&tos_no_trunc),\r\nPC_NO_TRUNC, NULL, HFILL }},\r\n{ &hf_mount_pathconf_error_vdisable, {\r\n"ERROR_VDISABLE", "mount.pathconf.mask.error_vdisable",\r\nFT_BOOLEAN, 16, TFS(&tos_error_vdisable),\r\nPC_ERROR_VDISABLE, NULL, HFILL }},\r\n{ &hf_mount_statvfs_bsize, {\r\n"Block size", "mount.statvfs.f_bsize",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"File system block size", HFILL }},\r\n{ &hf_mount_statvfs_frsize, {\r\n"Fragment size", "mount.statvfs.f_frsize",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"File system fragment size", HFILL }},\r\n{ &hf_mount_statvfs_blocks, {\r\n"Blocks", "mount.statvfs.f_blocks",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Total fragment sized blocks", HFILL }},\r\n{ &hf_mount_statvfs_bfree, {\r\n"Blocks Free", "mount.statvfs.f_bfree",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Free fragment sized blocks", HFILL }},\r\n{ &hf_mount_statvfs_bavail, {\r\n"Blocks Available", "mount.statvfs.f_bavail",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Available fragment sized blocks", HFILL }},\r\n{ &hf_mount_statvfs_files, {\r\n"Files", "mount.statvfs.f_files",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Total files/inodes", HFILL }},\r\n{ &hf_mount_statvfs_ffree, {\r\n"Files Free", "mount.statvfs.f_ffree",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Free files/inodes", HFILL }},\r\n{ &hf_mount_statvfs_favail, {\r\n"Files Available", "mount.statvfs.f_favail",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Available files/inodes", HFILL }},\r\n{ &hf_mount_statvfs_fsid, {\r\n"File system ID", "mount.statvfs.f_fsid",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"File system identifier", HFILL }},\r\n{ &hf_mount_statvfs_basetype, {\r\n"Type", "mount.statvfs.f_basetype",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\n"File system type", HFILL }},\r\n{ &hf_mount_statvfs_flag, {\r\n"Flags", "mount.statvfs.f_flag",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Flags bit-mask", HFILL }},\r\n{ &hf_mount_statvfs_flag_rdonly, {\r\n"ST_RDONLY", "mount.statvfs.f_flag.st_rdonly",\r\nFT_BOOLEAN, 32, TFS(&tos_st_rdonly), ST_RDONLY,\r\nNULL, HFILL }},\r\n{ &hf_mount_statvfs_flag_nosuid, {\r\n"ST_NOSUID", "mount.statvfs.f_flag.st_nosuid",\r\nFT_BOOLEAN, 32, TFS(&tos_st_nosuid), ST_NOSUID,\r\nNULL, HFILL }},\r\n{ &hf_mount_statvfs_flag_notrunc, {\r\n"ST_NOTRUNC", "mount.statvfs.f_flag.st_notrunc",\r\nFT_BOOLEAN, 32, TFS(&tos_st_notrunc), ST_NOTRUNC,\r\nNULL, HFILL }},\r\n{ &hf_mount_statvfs_flag_nodev, {\r\n"ST_NODEV", "mount.statvfs.f_flag.st_nodev",\r\nFT_BOOLEAN, 32, TFS(&tos_st_nodev), ST_NODEV,\r\nNULL, HFILL }},\r\n{ &hf_mount_statvfs_flag_grpid, {\r\n"ST_GRPID", "mount.statvfs.f_flag.st_grpid",\r\nFT_BOOLEAN, 32, TFS(&tos_st_grpid), ST_GRPID,\r\nNULL, HFILL }},\r\n{ &hf_mount_statvfs_flag_local, {\r\n"ST_LOCAL", "mount.statvfs.f_flag.st_local",\r\nFT_BOOLEAN, 32, TFS(&tos_st_local), ST_LOCAL,\r\nNULL, HFILL }},\r\n{ &hf_mount_statvfs_namemax, {\r\n"Maximum file name length", "mount.statvfs.f_namemax",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_mount_statvfs_fstr, {\r\n"File system specific string", "mount.statvfs.f_fstr",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_mount_flavors, {\r\n"Flavors", "mount.flavors", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_mount_flavor, {\r\n"Flavor", "mount.flavor", FT_UINT32, BASE_DEC,\r\nVALS(rpc_auth_flavor), 0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_mount,\r\n&ett_mount_mountlist,\r\n&ett_mount_groups,\r\n&ett_mount_exportlist,\r\n&ett_mount_pathconf_mask,\r\n&ett_mount_statvfs_flag,\r\n};\r\nproto_mount = proto_register_protocol("Mount Service", "MOUNT",\r\n"mount");\r\nproto_sgi_mount = proto_register_protocol("SGI Mount Service",\r\n"SGI MOUNT", "sgimount");\r\nproto_register_field_array(proto_mount, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_mount(void)\r\n{\r\nrpc_init_prog(proto_mount, MOUNT_PROGRAM, ett_mount,\r\nG_N_ELEMENTS(mount_vers_info), mount_vers_info);\r\nrpc_init_prog(proto_sgi_mount, SGI_MOUNT_PROGRAM, ett_mount,\r\nG_N_ELEMENTS(sgi_mount_vers_info), sgi_mount_vers_info);\r\n}
