static int\r\ndissect_cosine(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *fh_tree;\r\nproto_item *ti;\r\nunion wtap_pseudo_header *pseudo_header = pinfo->pseudo_header;\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_SRC, "N/A");\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_DST, "N/A");\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "N/A");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "CoSine IPNOS L2 debug output");\r\nif(tree) {\r\nti = proto_tree_add_protocol_format(tree, proto_cosine, tvb, 0, 0,\r\n"CoSine IPNOS L2 debug output (%s)",\r\npseudo_header->cosine.if_name);\r\nfh_tree = proto_item_add_subtree(ti, ett_raw);\r\nproto_tree_add_uint(fh_tree, hf_pro, tvb, 0, 0, pseudo_header->cosine.pro);\r\nproto_tree_add_uint(fh_tree, hf_off, tvb, 0, 0, pseudo_header->cosine.off);\r\nproto_tree_add_uint(fh_tree, hf_pri, tvb, 0, 0, pseudo_header->cosine.pri);\r\nproto_tree_add_uint(fh_tree, hf_rm, tvb, 0, 0, pseudo_header->cosine.rm);\r\nproto_tree_add_uint(fh_tree, hf_err, tvb, 0, 0, pseudo_header->cosine.err);\r\nswitch (pseudo_header->cosine.encap) {\r\ncase COSINE_ENCAP_ETH:\r\nbreak;\r\ncase COSINE_ENCAP_ATM:\r\ncase COSINE_ENCAP_PPoATM:\r\nproto_tree_add_item(fh_tree, hf_sar, tvb, 0, 16, ENC_NA);\r\nbreak;\r\ncase COSINE_ENCAP_PPP:\r\ncase COSINE_ENCAP_FR:\r\ncase COSINE_ENCAP_PPoFR:\r\nproto_tree_add_item(fh_tree, hf_channel_id, tvb, 0, 4, ENC_NA);\r\nbreak;\r\ncase COSINE_ENCAP_HDLC:\r\nif (pseudo_header->cosine.direction == COSINE_DIR_TX) {\r\nproto_tree_add_item(fh_tree, hf_channel_id, tvb, 0, 2, ENC_NA);\r\n} else if (pseudo_header->cosine.direction == COSINE_DIR_RX) {\r\nproto_tree_add_item(fh_tree, hf_channel_id, tvb, 0, 4, ENC_NA);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nswitch (pseudo_header->cosine.encap) {\r\ncase COSINE_ENCAP_ETH:\r\ncall_dissector(eth_withoutfcs_handle, tvb_new_subset_remaining(tvb, 0),\r\npinfo, tree);\r\nbreak;\r\ncase COSINE_ENCAP_ATM:\r\ncase COSINE_ENCAP_PPoATM:\r\ncall_dissector(llc_handle, tvb_new_subset_remaining(tvb, 16),\r\npinfo, tree);\r\nbreak;\r\ncase COSINE_ENCAP_PPP:\r\ncall_dissector(ppp_hdlc_handle, tvb_new_subset_remaining(tvb, 4),\r\npinfo, tree);\r\nbreak;\r\ncase COSINE_ENCAP_HDLC:\r\nif (pseudo_header->cosine.direction == COSINE_DIR_TX) {\r\ncall_dissector(chdlc_handle, tvb_new_subset_remaining(tvb, 2),\r\npinfo, tree);\r\n} else if (pseudo_header->cosine.direction == COSINE_DIR_RX) {\r\ncall_dissector(chdlc_handle, tvb_new_subset_remaining(tvb, 4),\r\npinfo, tree);\r\n}\r\nbreak;\r\ncase COSINE_ENCAP_FR:\r\ncase COSINE_ENCAP_PPoFR:\r\ncall_dissector(fr_handle, tvb_new_subset_remaining(tvb, 4),\r\npinfo, tree);\r\nbreak;\r\ncase COSINE_ENCAP_TEST:\r\ncase COSINE_ENCAP_UNKNOWN:\r\ncall_data_dissector(tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_cosine(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_pro,\r\n{ "Protocol", "cosine.pro", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_off,\r\n{ "Offset", "cosine.off", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_pri,\r\n{ "Priority", "cosine.pri", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_rm,\r\n{ "Rate Marking", "cosine.rm", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_err,\r\n{ "Error Code", "cosine.err", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_sar,\r\n{ "SAR header", "cosine.sar", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_channel_id,\r\n{ "Channel handle ID", "cosine.channel_id", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_raw,\r\n};\r\nproto_cosine = proto_register_protocol("CoSine IPNOS L2 debug output",\r\n"CoSine", "cosine");\r\nproto_register_field_array(proto_cosine, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_cosine(void)\r\n{\r\ndissector_handle_t cosine_handle;\r\neth_withoutfcs_handle = find_dissector_add_dependency("eth_withoutfcs", proto_cosine);\r\nppp_hdlc_handle = find_dissector_add_dependency("ppp_hdlc", proto_cosine);\r\nllc_handle = find_dissector_add_dependency("llc", proto_cosine);\r\nchdlc_handle = find_dissector_add_dependency("chdlc", proto_cosine);\r\nfr_handle = find_dissector_add_dependency("fr", proto_cosine);\r\ncosine_handle = create_dissector_handle(dissect_cosine, proto_cosine);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_COSINE, cosine_handle);\r\n}
