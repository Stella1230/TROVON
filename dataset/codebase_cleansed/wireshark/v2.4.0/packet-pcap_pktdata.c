static int\r\ndissect_pcap_pktdata(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\ngint offset = 0;\r\nguint32 *link_type;\r\ntvbuff_t *next_tvb;\r\nproto_item *pseudoheader_item;\r\nproto_tree *pseudoheader_tree = NULL;\r\nproto_item *packet_item;\r\nstruct eth_phdr eth;\r\nvoid *phdr;\r\nDISSECTOR_ASSERT(data);\r\nlink_type = (guint32 *) data;\r\npinfo->phdr->pkt_encap = wtap_pcap_encap_to_wtap_encap(*link_type);\r\nif (pinfo->phdr->pkt_encap == WTAP_ENCAP_UNKNOWN) {\r\npacket_item = proto_tree_add_item(tree, hf_pcap_pktdata_undecoded_data, tvb, offset, tvb_reported_length(tvb), ENC_NA);\r\nexpert_add_info_format(pinfo, packet_item,\r\n&ei_pcap_pktdata_linktype_unknown,\r\n"Link-layer header type %u is not supported",\r\n*link_type);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nif (wtap_encap_requires_phdr(pinfo->phdr->pkt_encap)) {\r\nswitch (pinfo->phdr->pkt_encap) {\r\ncase WTAP_ENCAP_BLUETOOTH_H4_WITH_PHDR:\r\npseudoheader_item = proto_tree_add_item(tree, hf_pcap_pktdata_pseudoheader, tvb, offset, 4, ENC_NA);\r\npseudoheader_tree = proto_item_add_subtree(pseudoheader_item, ett_pcap_pktdata_pseudoheader);\r\nproto_tree_add_item(pseudoheader_tree, hf_pcap_pktdata_pseudoheader_bluetooth_direction, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nif (tvb_get_guint32(tvb, offset, ENC_BIG_ENDIAN) == 0)\r\npinfo->p2p_dir = P2P_DIR_SENT;\r\nelse if (tvb_get_guint32(tvb, offset, ENC_BIG_ENDIAN) == 1)\r\npinfo->p2p_dir = P2P_DIR_RECV;\r\nelse\r\npinfo->p2p_dir = P2P_DIR_UNKNOWN;\r\noffset += 4;\r\nphdr = NULL;\r\nbreak;\r\ncase WTAP_ENCAP_ATM_PDUS:\r\ncase WTAP_ENCAP_IRDA:\r\ncase WTAP_ENCAP_MTP2_WITH_PHDR:\r\ncase WTAP_ENCAP_LINUX_LAPD:\r\ncase WTAP_ENCAP_SITA:\r\ncase WTAP_ENCAP_BLUETOOTH_LINUX_MONITOR:\r\ncase WTAP_ENCAP_NFC_LLCP:\r\ncase WTAP_ENCAP_PPP_WITH_PHDR:\r\ncase WTAP_ENCAP_ERF:\r\ncase WTAP_ENCAP_I2C:\r\ndefault:\r\npacket_item = proto_tree_add_item(tree, hf_pcap_pktdata_undecoded_data, tvb, offset, tvb_reported_length(tvb), ENC_NA);\r\nexpert_add_info_format(pinfo, packet_item,\r\n&ei_pcap_pktdata_cant_generate_phdr,\r\n"No pseudo-header can be generated for link-layer header type %u",\r\n*link_type);\r\nreturn tvb_captured_length(tvb);\r\n}\r\n} else {\r\nswitch (pinfo->phdr->pkt_encap) {\r\ncase WTAP_ENCAP_ETHERNET:\r\neth.fcs_len = -1;\r\nphdr = &eth;\r\nbreak;\r\ndefault:\r\nphdr = NULL;\r\nbreak;\r\n}\r\n}\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\noffset = dissector_try_uint_new(wtap_encap_table, pinfo->phdr->pkt_encap, next_tvb, pinfo, tree, TRUE, phdr);\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_pcap_pktdata(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_pcap_pktdata_pseudoheader,\r\n{ "Pseudoheader", "pcap_pktdata.data.pseudoheader",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pcap_pktdata_pseudoheader_bluetooth_direction,\r\n{ "Direction", "pcap_pktdata.pseudoheader.bluetooth.direction",\r\nFT_UINT32, BASE_HEX, VALS(pseudoheader_bluetooth_direction_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pcap_pktdata_undecoded_data,\r\n{ "Undecoded data", "pcap_pktdata.undecoded_data",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_pcap_pktdata_pseudoheader,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_pcap_pktdata_linktype_unknown, { "pcap_pktdata.linktype_unknown", PI_UNDECODED, PI_NOTE, "That link-layer header type is not supported", EXPFILL }},\r\n{ &ei_pcap_pktdata_cant_generate_phdr, { "pcap_pktdata.cant_generate_phdr", PI_UNDECODED, PI_NOTE, "No pseudo-header can be generated for that link-layer header type", EXPFILL }},\r\n};\r\nexpert_module_t *expert_pcap_pktdata;\r\nproto_pcap_pktdata = proto_register_protocol("pcap/pcapng packet data", "pcap_pktdata", "pcap_pktdata");\r\nproto_register_field_array(proto_pcap_pktdata, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_pcap_pktdata = expert_register_protocol(proto_pcap_pktdata);\r\nexpert_register_field_array(expert_pcap_pktdata, ei, array_length(ei));\r\nregister_dissector("pcap_pktdata", dissect_pcap_pktdata, proto_pcap_pktdata);\r\n}\r\nvoid\r\nproto_reg_handoff_pcap_pktdata(void)\r\n{\r\nwtap_encap_table = find_dissector_table("wtap_encap");\r\n}
