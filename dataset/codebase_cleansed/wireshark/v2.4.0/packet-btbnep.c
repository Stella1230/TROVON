static int\r\ndissect_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset)\r\n{\r\nproto_item *pitem = NULL;\r\nguint control_type;\r\nguint8 unknown_control_type;\r\nguint8 uuid_size;\r\nguint16 uuid_dst;\r\nguint16 uuid_src;\r\nguint16 response_message;\r\nguint16 list_length;\r\nguint i_item;\r\nproto_tree_add_item(tree, hf_btbnep_control_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\ncontrol_type = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - %s", val_to_str_const(control_type, control_type_vals, "Unknown type"));\r\nswitch(control_type) {\r\ncase 0x00:\r\nproto_tree_add_item(tree, hf_btbnep_unknown_control_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nunknown_control_type = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - Unknown(%s)", val_to_str_const(unknown_control_type, control_type_vals, "Unknown type"));\r\nbreak;\r\ncase 0x01:\r\nproto_tree_add_item(tree, hf_btbnep_uuid_size, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nuuid_size = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\npitem = proto_tree_add_item(tree, hf_btbnep_destination_service_uuid, tvb, offset, uuid_size, ENC_NA);\r\nuuid_dst = tvb_get_ntohs(tvb, offset);\r\nproto_item_append_text(pitem, " (%s)", val_to_str_ext(uuid_dst, &bluetooth_uuid_vals_ext, "Unknown uuid"));\r\noffset += uuid_size;\r\npitem = proto_tree_add_item(tree, hf_btbnep_source_service_uuid, tvb, offset, uuid_size, ENC_NA);\r\nuuid_src = tvb_get_ntohs(tvb, offset);\r\nproto_item_append_text(pitem, " (%s)", val_to_str_ext(uuid_src, &bluetooth_uuid_vals_ext, "Unknown uuid"));\r\noffset += uuid_size;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - dst: <%s>, src: <%s>",\r\nval_to_str_ext(uuid_dst, &bluetooth_uuid_vals_ext, "Unknown uuid"),\r\nval_to_str_ext(uuid_src, &bluetooth_uuid_vals_ext, "Unknown uuid"));\r\nbreak;\r\ncase 0x02:\r\nproto_tree_add_item(tree, hf_btbnep_setup_connection_response_message, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nresponse_message = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - %s",\r\nval_to_str_const(response_message, setup_connection_response_message_vals, "Unknown response message"));\r\nbreak;\r\ncase 0x03:\r\nproto_tree_add_item(tree, hf_btbnep_list_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nlist_length = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\nfor (i_item = 0; i_item + 4 > i_item && i_item < list_length; i_item += 4) {\r\nproto_tree_add_item(tree, hf_btbnep_network_type_start, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_btbnep_network_type_end, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n}\r\nbreak;\r\ncase 0x04:\r\nproto_tree_add_item(tree, hf_btbnep_filter_net_type_response_message, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nresponse_message = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - %s",\r\nval_to_str_const(response_message, filter_net_type_response_message_vals, "Unknown response message"));\r\nbreak;\r\ncase 0x05:\r\nproto_tree_add_item(tree, hf_btbnep_list_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nlist_length = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\nfor (i_item = 0; i_item + 12 > i_item && i_item < list_length; i_item += 12) {\r\nproto_tree_add_item(tree, hf_btbnep_multicast_address_start, tvb, offset, 6, ENC_NA);\r\noffset += 6;\r\nproto_tree_add_item(tree, hf_btbnep_multicast_address_end, tvb, offset, 6, ENC_NA);\r\noffset += 6;\r\n}\r\nbreak;\r\ncase 0x06:\r\nproto_tree_add_item(tree, hf_btbnep_filter_multi_addr_response_message, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nresponse_message = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - %s",\r\nval_to_str_const(response_message, filter_multi_addr_response_message_vals, "Unknown response message"));\r\nbreak;\r\n};\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_extension(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset)\r\n{\r\nguint8 extension_flag;\r\nguint8 extension_type;\r\nguint16 extension_length;\r\nguint8 type;\r\nproto_tree_add_item(tree, hf_btbnep_extension_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_btbnep_extension_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\ntype = tvb_get_guint8(tvb, offset);\r\nextension_flag = type & 0x01;\r\nextension_type = type >> 1;\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_btbnep_extension_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nextension_length = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\nif (extension_type == 0x00) {\r\noffset = dissect_control(tvb, pinfo, tree, offset);\r\n} else {\r\noffset += extension_length;\r\n}\r\nif (extension_flag) offset = dissect_extension(tvb, pinfo, tree, offset);\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_btbnep(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *pi;\r\nproto_tree *btbnep_tree;\r\ngint offset = 0;\r\nguint bnep_type;\r\nguint extension_flag;\r\nguint len_type = 0;\r\nproto_item *addr_item;\r\nproto_tree *addr_tree = NULL;\r\nproto_item *length_ti = NULL;\r\npi = proto_tree_add_item(tree, proto_btbnep, tvb, offset, -1, ENC_NA);\r\nbtbnep_tree = proto_item_add_subtree(pi, ett_btbnep);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "BNEP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nswitch (pinfo->p2p_dir) {\r\ncase P2P_DIR_SENT:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Sent ");\r\nbreak;\r\ncase P2P_DIR_RECV:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");\r\nbreak;\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");\r\nbreak;\r\n}\r\nproto_tree_add_item(btbnep_tree, hf_btbnep_extension_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(btbnep_tree, hf_btbnep_bnep_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbnep_type = tvb_get_guint8(tvb, offset);\r\nextension_flag = bnep_type & 0x80;\r\nbnep_type = bnep_type & 0x7F;\r\noffset += 1;\r\ncol_append_str(pinfo->cinfo, COL_INFO, val_to_str_const(bnep_type, bnep_type_vals, "Unknown type"));\r\nif (extension_flag) col_append_str(pinfo->cinfo, COL_INFO, "+E");\r\nif (bnep_type == BNEP_TYPE_GENERAL_ETHERNET || bnep_type == BNEP_TYPE_COMPRESSED_ETHERNET_DESTINATION_ONLY) {\r\nset_address_tvb(&pinfo->dl_dst, AT_ETHER, 6, tvb, offset);\r\ncopy_address_shallow(&pinfo->dst, &pinfo->dl_dst);\r\naddr_item = proto_tree_add_item(btbnep_tree, hf_btbnep_dst, tvb, offset, 6, ENC_NA);\r\naddr_tree = proto_item_add_subtree(addr_item, ett_addr);\r\nproto_tree_add_item(addr_tree, hf_btbnep_addr, tvb, offset, 6, ENC_NA);\r\nproto_tree_add_item(addr_tree, hf_btbnep_lg, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(addr_tree, hf_btbnep_ig, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 6;\r\n}\r\nif (bnep_type == BNEP_TYPE_GENERAL_ETHERNET || bnep_type == BNEP_TYPE_COMPRESSED_ETHERNET_SOURCE_ONLY) {\r\nset_address_tvb(&pinfo->dl_src, AT_ETHER, 6, tvb, offset);\r\ncopy_address_shallow(&pinfo->src, &pinfo->dl_src);\r\naddr_item = proto_tree_add_item(btbnep_tree, hf_btbnep_src, tvb, offset, 6, ENC_NA);\r\naddr_tree = proto_item_add_subtree(addr_item, ett_addr);\r\nif (tvb_get_guint8(tvb, offset) & 0x01) {\r\nexpert_add_info(pinfo, addr_item, &ei_btbnep_src_not_group_address);\r\n}\r\nproto_tree_add_item(addr_tree, hf_btbnep_addr, tvb, offset, 6, ENC_NA);\r\nproto_tree_add_item(addr_tree, hf_btbnep_lg, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(addr_tree, hf_btbnep_ig, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 6;\r\n}\r\nif (bnep_type != BNEP_TYPE_CONTROL) {\r\nlen_type = tvb_get_ntohs(tvb, offset);\r\nif (len_type <= IEEE_802_3_MAX_LEN) {\r\nlength_ti = proto_tree_add_item(btbnep_tree, hf_btbnep_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n} else if (len_type < ETHERNET_II_MIN_LEN) {\r\nproto_item *ti;\r\nti = proto_tree_add_item(btbnep_tree, hf_btbnep_invalid_lentype, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nexpert_add_info_format(pinfo, ti, &ei_btbnep_invalid_lentype,\r\n"Invalid length/type: 0x%04x (%u)",\r\nlen_type, len_type);\r\n} else {\r\nif (!top_dissect)\r\nproto_tree_add_item(btbnep_tree, hf_btbnep_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - Type: %s", val_to_str_const(len_type, etype_vals, "unknown"));\r\n}\r\noffset += 2;\r\n} else {\r\noffset = dissect_control(tvb, pinfo, btbnep_tree, offset);\r\n}\r\nif (extension_flag) {\r\noffset = dissect_extension(tvb, pinfo, btbnep_tree, offset);\r\n}\r\nif (bnep_type != BNEP_TYPE_CONTROL) {\r\nif (top_dissect) {\r\nif (len_type <= IEEE_802_3_MAX_LEN) {\r\ngboolean is_802_2;\r\ngint reported_length;\r\ntvbuff_t *next_tvb;\r\nis_802_2 = TRUE;\r\nif (tvb_bytes_exist(tvb, offset, 2)) {\r\nif (tvb_get_ntohs(tvb, offset) == 0xffff) {\r\nis_802_2 = FALSE;\r\n}\r\n}\r\nreported_length = tvb_reported_length_remaining(tvb, offset);\r\nif (reported_length >= 0 && len_type > (guint)reported_length) {\r\nlen_type = reported_length;\r\nexpert_add_info(pinfo, length_ti, &ei_btbnep_len_past_end);\r\n}\r\nnext_tvb = tvb_new_subset_length(tvb, offset, len_type);\r\nif (is_802_2) {\r\ncall_dissector(llc_handle, next_tvb, pinfo, tree);\r\n} else {\r\ncall_dissector(ipx_handle, next_tvb, pinfo, tree);\r\n}\r\n} else if (len_type < ETHERNET_II_MIN_LEN) {\r\ntvbuff_t *next_tvb;\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n} else {\r\nethertype_data_t ethertype_data;\r\nethertype_data.etype = len_type;\r\nethertype_data.offset_after_ethertype = offset;\r\nethertype_data.fh_tree = btbnep_tree;\r\nethertype_data.etype_id = hf_btbnep_type;\r\nethertype_data.trailer_id = 0;\r\nethertype_data.fcs_len = 0;\r\ncall_dissector_with_data(ethertype_handle, tvb, pinfo, tree, &ethertype_data);\r\n}\r\n} else {\r\ntvbuff_t *next_tvb;\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\n}\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_btbnep(void)\r\n{\r\nmodule_t *module;\r\nexpert_module_t* expert_btbnep;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_btbnep_bnep_type,\r\n{ "BNEP Type", "btbnep.bnep_type",\r\nFT_UINT8, BASE_HEX, VALS(bnep_type_vals), 0x7F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_extension_flag,\r\n{ "Extension Flag", "btbnep.extension_flag",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_control_type,\r\n{ "Control Type", "btbnep.control_type",\r\nFT_UINT8, BASE_HEX, VALS(control_type_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_extension_type,\r\n{ "Extension Type", "btbnep.extension_type",\r\nFT_UINT8, BASE_HEX, VALS(extension_type_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_extension_length,\r\n{ "Extension Length", "btbnep.extension_length",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_unknown_control_type,\r\n{ "Unknown Control Type", "btbnep.uknown_control_type",\r\nFT_UINT8, BASE_HEX, VALS(control_type_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_uuid_size,\r\n{ "UIDD Size", "btbnep.uuid_size",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_destination_service_uuid,\r\n{ "Destination Service UUID", "btbnep.destination_service_uuid",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_source_service_uuid,\r\n{ "Source Service UUID", "btbnep.source_service_uuid",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_setup_connection_response_message,\r\n{ "Response Message", "btbnep.setup_connection_response_message",\r\nFT_UINT16, BASE_HEX, VALS(setup_connection_response_message_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_filter_net_type_response_message,\r\n{ "Response Message", "btbnep.filter_net_type_response_message",\r\nFT_UINT16, BASE_HEX, VALS(filter_net_type_response_message_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_filter_multi_addr_response_message,\r\n{ "Response Message", "btbnep.filter_multi_addr_response_message",\r\nFT_UINT16, BASE_HEX, VALS(filter_multi_addr_response_message_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_list_length,\r\n{ "List Length", "btbnep.list_length",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_network_type_start,\r\n{ "Network Protocol Type Range Start", "btbnep.network_type_start",\r\nFT_UINT16, BASE_HEX, VALS(etype_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_network_type_end,\r\n{ "Network Protocol Type Range End", "btbnep.network_type_end",\r\nFT_UINT16, BASE_HEX, VALS(etype_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_multicast_address_start,\r\n{ "Multicast Address Start", "btbnep.multicast_address_start",\r\nFT_ETHER, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_multicast_address_end,\r\n{ "Multicast Address End", "btbnep.multicast_address_end",\r\nFT_ETHER, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_dst,\r\n{ "Destination", "btbnep.dst",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\n"Destination Hardware Address", HFILL }\r\n},\r\n{ &hf_btbnep_src,\r\n{ "Source", "btbnep.src",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\n"Source Hardware Address", HFILL }\r\n},\r\n{ &hf_btbnep_len,\r\n{ "Length", "btbnep.len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_invalid_lentype,\r\n{ "Invalid length/type", "btbnep.invalid_lentype",\r\nFT_UINT16, BASE_HEX_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_type,\r\n{ "Type", "btbnep.type",\r\nFT_UINT16, BASE_HEX, VALS(etype_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btbnep_addr,\r\n{ "Address", "btbnep.addr",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\n"Source or Destination Hardware Address", HFILL }\r\n},\r\n{ &hf_btbnep_lg,\r\n{ "LG bit", "btbnep.lg",\r\nFT_BOOLEAN, 24, TFS(&lg_tfs), 0x020000,\r\n"Specifies if this is a locally administered or globally unique (IEEE assigned) address", HFILL }\r\n},\r\n{ &hf_btbnep_ig,\r\n{ "IG bit", "btbnep.ig",\r\nFT_BOOLEAN, 24, TFS(&ig_tfs), 0x010000,\r\n"Specifies if this is an individual (unicast) or group (broadcast/multicast) address", HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_btbnep,\r\n&ett_addr\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_btbnep_src_not_group_address, { "btbnep.src.not_group_address", PI_PROTOCOL, PI_WARN, "Source MAC must not be a group address: IEEE 802.3-2002, Section 3.2.3(b)", EXPFILL }},\r\n{ &ei_btbnep_invalid_lentype, { "btbnep.invalid_lentype.expert", PI_PROTOCOL, PI_WARN, "Invalid length/type", EXPFILL }},\r\n{ &ei_btbnep_len_past_end, { "btbnep.len.past_end", PI_MALFORMED, PI_ERROR, "Length field value goes past the end of the payload", EXPFILL }},\r\n};\r\nproto_btbnep = proto_register_protocol("Bluetooth BNEP Protocol", "BT BNEP", "btbnep");\r\nbtbnep_handle = register_dissector("btbnep", dissect_btbnep, proto_btbnep);\r\nproto_register_field_array(proto_btbnep, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_btbnep = expert_register_protocol(proto_btbnep);\r\nexpert_register_field_array(expert_btbnep, ei, array_length(ei));\r\nmodule = prefs_register_protocol(proto_btbnep, NULL);\r\nprefs_register_static_text_preference(module, "bnep.version",\r\n"Bluetooth Protocol BNEP version: 1.0",\r\n"Version of protocol supported by this dissector.");\r\nprefs_register_bool_preference(module, "bnep.top_dissect",\r\n"Dissecting the top protocols", "Dissecting the top protocols",\r\n&top_dissect);\r\n}\r\nvoid\r\nproto_reg_handoff_btbnep(void)\r\n{\r\nipx_handle = find_dissector_add_dependency("ipx", proto_btbnep);\r\nllc_handle = find_dissector_add_dependency("llc", proto_btbnep);\r\nethertype_handle = find_dissector_add_dependency("ethertype", proto_btbnep);\r\ndissector_add_string("bluetooth.uuid", "1115", btbnep_handle);\r\ndissector_add_string("bluetooth.uuid", "1116", btbnep_handle);\r\ndissector_add_string("bluetooth.uuid", "1117", btbnep_handle);\r\ndissector_add_uint("btl2cap.psm", BTL2CAP_PSM_BNEP, btbnep_handle);\r\ndissector_add_for_decode_as("btl2cap.cid", btbnep_handle);\r\n}
