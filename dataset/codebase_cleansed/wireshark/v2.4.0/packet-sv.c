static int\r\ndissect_PhsMeas1(gboolean implicit_tag, packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id _U_)\r\n{\r\ngint8 ber_class;\r\ngboolean pc;\r\ngint32 tag;\r\nguint32 len;\r\nproto_tree *subtree;\r\ngint32 value;\r\nguint32 qual;\r\nguint32 i;\r\nstatic const int *q_flags[] = {\r\n&hf_sv_phsmeas_q_validity,\r\n&hf_sv_phsmeas_q_overflow,\r\n&hf_sv_phsmeas_q_outofrange,\r\n&hf_sv_phsmeas_q_badreference,\r\n&hf_sv_phsmeas_q_oscillatory,\r\n&hf_sv_phsmeas_q_failure,\r\n&hf_sv_phsmeas_q_olddata,\r\n&hf_sv_phsmeas_q_inconsistent,\r\n&hf_sv_phsmeas_q_inaccurate,\r\n&hf_sv_phsmeas_q_source,\r\n&hf_sv_phsmeas_q_test,\r\n&hf_sv_phsmeas_q_operatorblocked,\r\n&hf_sv_phsmeas_q_derived,\r\nNULL\r\n};\r\nif (!implicit_tag) {\r\noffset=dissect_ber_identifier(pinfo, tree, tvb, offset, &ber_class, &pc, &tag);\r\noffset=dissect_ber_length(pinfo, tree, tvb, offset, &len, NULL);\r\n} else {\r\nlen=tvb_reported_length_remaining(tvb, offset);\r\n}\r\nsubtree = proto_tree_add_subtree(tree, tvb, offset, len, ett_phsmeas, NULL, "PhsMeas1");\r\nsv_data.num_phsMeas = 0;\r\nfor (i = 0; i < len/8; i++) {\r\nif (tree && subtree) {\r\nvalue = tvb_get_ntohl(tvb, offset);\r\nqual = tvb_get_ntohl(tvb, offset + 4);\r\nproto_tree_add_item(subtree, hf_sv_phmeas_instmag_i, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(subtree, tvb, offset + 4, hf_sv_phsmeas_q, ett_phsmeas_q, q_flags, ENC_BIG_ENDIAN);\r\nif (i < IEC61850_SV_MAX_PHSMEAS_ENTRIES) {\r\nsv_data.phsMeas[i].value = value;\r\nsv_data.phsMeas[i].qual = qual;\r\nsv_data.num_phsMeas++;\r\n}\r\n}\r\noffset += 8;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_sv_INTEGER_0_65535(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\r\noffset = dissect_ber_integer(implicit_tag, actx, tree, tvb, offset, hf_index,\r\nNULL);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_sv_VisibleString(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\r\noffset = dissect_ber_restricted_string(implicit_tag, BER_UNI_TAG_VisibleString,\r\nactx, tree, tvb, offset, hf_index,\r\nNULL);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_sv_T_smpCnt(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\r\n#line 18 "./asn1/sv/sv.cnf"\r\nguint32 value;\r\noffset = dissect_ber_integer(implicit_tag, actx, tree, tvb, offset, hf_index,\r\n&value);\r\nsv_data.smpCnt = value;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_sv_INTEGER_0_4294967295(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\r\noffset = dissect_ber_integer(implicit_tag, actx, tree, tvb, offset, hf_index,\r\nNULL);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_sv_UtcTime(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\r\n#line 24 "./asn1/sv/sv.cnf"\r\nguint32 len;\r\nguint32 seconds;\r\nguint32 fraction;\r\nguint32 nanoseconds;\r\nnstime_t ts;\r\ngchar * ptime;\r\nlen = tvb_reported_length_remaining(tvb, offset);\r\nif(len != 8)\r\n{\r\nproto_tree_add_expert_format(tree, actx->pinfo, &ei_sv_mal_utctime, tvb, offset, len,\r\n"BER Error: malformed UTCTime encoding, length must be 8 bytes");\r\nif(hf_index >= 0)\r\n{\r\nproto_tree_add_string(tree, hf_index, tvb, offset, len, "????");\r\n}\r\nreturn offset;\r\n}\r\nseconds = tvb_get_ntohl(tvb, offset);\r\nfraction = tvb_get_ntoh24(tvb, offset+4) * 0x100;\r\nnanoseconds = (guint32)( ((guint64)fraction * G_GUINT64_CONSTANT(1000000000)) / G_GUINT64_CONSTANT(0x100000000) ) ;\r\nts.secs = seconds;\r\nts.nsecs = nanoseconds;\r\nptime = abs_time_to_str(wmem_packet_scope(), &ts, ABSOLUTE_TIME_UTC, TRUE);\r\nif(hf_index >= 0)\r\n{\r\nproto_tree_add_string(tree, hf_index, tvb, offset, len, ptime);\r\n}\r\noffset += 8;\r\nreturn offset;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_sv_T_smpSynch(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\r\n#line 65 "./asn1/sv/sv.cnf"\r\nguint32 value;\r\noffset = dissect_ber_integer(implicit_tag, actx, tree, tvb, offset, hf_index,\r\n&value);\r\nsv_data.smpSynch = value;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_sv_Data(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\r\n#line 77 "./asn1/sv/sv.cnf"\r\nif (sv_decode_data_as_phsmeas) {\r\noffset = dissect_PhsMeas1(implicit_tag, actx->pinfo, tree, tvb, offset, hf_index);\r\n} else {\r\noffset = dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_index, NULL);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_sv_T_smpMod(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\r\n#line 71 "./asn1/sv/sv.cnf"\r\nguint32 value;\r\noffset = dissect_ber_integer(implicit_tag, actx, tree, tvb, offset, hf_index,\r\n&value);\r\nsv_data.smpMod = value;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_sv_ASDU(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\r\noffset = dissect_ber_sequence(implicit_tag, actx, tree, tvb, offset,\r\nASDU_sequence, hf_index, ett_sv_ASDU);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_sv_SEQUENCE_OF_ASDU(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\r\noffset = dissect_ber_sequence_of(implicit_tag, actx, tree, tvb, offset,\r\nSEQUENCE_OF_ASDU_sequence_of, hf_index, ett_sv_SEQUENCE_OF_ASDU);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_sv_SavPdu(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\r\noffset = dissect_ber_sequence(implicit_tag, actx, tree, tvb, offset,\r\nSavPdu_sequence, hf_index, ett_sv_SavPdu);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_sv_SampledValues(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\r\noffset = dissect_ber_choice(actx, tree, tvb, offset,\r\nSampledValues_choice, hf_index, ett_sv_SampledValues,\r\nNULL);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_sv(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data _U_)\r\n{\r\nint offset = 0;\r\nint old_offset;\r\nproto_item *item;\r\nproto_tree *tree;\r\nasn1_ctx_t asn1_ctx;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\r\nitem = proto_tree_add_item(parent_tree, proto_sv, tvb, 0, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_sv);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, PNAME);\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nproto_tree_add_item(tree, hf_sv_appid, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_sv_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_sv_reserve1, tvb, offset + 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_sv_reserve2, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\r\noffset = 8;\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0){\r\nold_offset = offset;\r\noffset = dissect_sv_SampledValues(FALSE, tvb, offset, &asn1_ctx , tree, -1);\r\nif (offset == old_offset) {\r\nproto_tree_add_expert(tree, pinfo, &ei_sv_zero_pdu, tvb, offset, -1);\r\nbreak;\r\n}\r\n}\r\ntap_queue_packet(sv_tap, pinfo, &sv_data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_sv(void) {\r\nstatic hf_register_info hf[] = {\r\n{ &hf_sv_appid,\r\n{ "APPID", "sv.appid", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sv_length,\r\n{ "Length", "sv.length", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sv_reserve1,\r\n{ "Reserved 1", "sv.reserve1", FT_UINT16, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sv_reserve2,\r\n{ "Reserved 2", "sv.reserve2", FT_UINT16, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sv_phmeas_instmag_i,\r\n{ "value", "sv.meas_value", FT_INT32, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_sv_phsmeas_q,\r\n{ "quality", "sv.meas_quality", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_sv_phsmeas_q_validity,\r\n{ "validity", "sv.meas_quality.validity", FT_UINT32, BASE_HEX, VALS(sv_q_validity_vals), Q_VALIDITY_MASK, NULL, HFILL}},\r\n{ &hf_sv_phsmeas_q_overflow,\r\n{ "overflow", "sv.meas_quality.overflow", FT_BOOLEAN, 32, NULL, Q_OVERFLOW, NULL, HFILL}},\r\n{ &hf_sv_phsmeas_q_outofrange,\r\n{ "out of range", "sv.meas_quality.outofrange", FT_BOOLEAN, 32, NULL, Q_OUTOFRANGE, NULL, HFILL}},\r\n{ &hf_sv_phsmeas_q_badreference,\r\n{ "bad reference", "sv.meas_quality.badreference", FT_BOOLEAN, 32, NULL, Q_BADREFERENCE, NULL, HFILL}},\r\n{ &hf_sv_phsmeas_q_oscillatory,\r\n{ "oscillatory", "sv.meas_quality.oscillatory", FT_BOOLEAN, 32, NULL, Q_OSCILLATORY, NULL, HFILL}},\r\n{ &hf_sv_phsmeas_q_failure,\r\n{ "failure", "sv.meas_quality.failure", FT_BOOLEAN, 32, NULL, Q_FAILURE, NULL, HFILL}},\r\n{ &hf_sv_phsmeas_q_olddata,\r\n{ "old data", "sv.meas_quality.olddata", FT_BOOLEAN, 32, NULL, Q_OLDDATA, NULL, HFILL}},\r\n{ &hf_sv_phsmeas_q_inconsistent,\r\n{ "inconsistent", "sv.meas_quality.inconsistent", FT_BOOLEAN, 32, NULL, Q_INCONSISTENT, NULL, HFILL}},\r\n{ &hf_sv_phsmeas_q_inaccurate,\r\n{ "inaccurate", "sv.meas_quality.inaccurate", FT_BOOLEAN, 32, NULL, Q_INACCURATE, NULL, HFILL}},\r\n{ &hf_sv_phsmeas_q_source,\r\n{ "source", "sv.meas_quality.source", FT_UINT32, BASE_HEX, VALS(sv_q_source_vals), Q_SOURCE_MASK, NULL, HFILL}},\r\n{ &hf_sv_phsmeas_q_test,\r\n{ "test", "sv.meas_quality.teset", FT_BOOLEAN, 32, NULL, Q_TEST, NULL, HFILL}},\r\n{ &hf_sv_phsmeas_q_operatorblocked,\r\n{ "operator blocked", "sv.meas_quality.operatorblocked", FT_BOOLEAN, 32, NULL, Q_OPERATORBLOCKED, NULL, HFILL}},\r\n{ &hf_sv_phsmeas_q_derived,\r\n{ "derived", "sv.meas_quality.derived", FT_BOOLEAN, 32, NULL, Q_DERIVED, NULL, HFILL}},\r\n#line 1 "./asn1/sv/packet-sv-hfarr.c"\r\n{ &hf_sv_savPdu,\r\n{ "savPdu", "sv.savPdu_element",\r\nFT_NONE, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_sv_noASDU,\r\n{ "noASDU", "sv.noASDU",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"INTEGER_0_65535", HFILL }},\r\n{ &hf_sv_seqASDU,\r\n{ "seqASDU", "sv.seqASDU",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"SEQUENCE_OF_ASDU", HFILL }},\r\n{ &hf_sv_seqASDU_item,\r\n{ "ASDU", "sv.ASDU_element",\r\nFT_NONE, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_sv_svID,\r\n{ "svID", "sv.svID",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\n"VisibleString", HFILL }},\r\n{ &hf_sv_datSet,\r\n{ "datSet", "sv.datSet",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\n"VisibleString", HFILL }},\r\n{ &hf_sv_smpCnt,\r\n{ "smpCnt", "sv.smpCnt",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_sv_confRef,\r\n{ "confRef", "sv.confRef",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"INTEGER_0_4294967295", HFILL }},\r\n{ &hf_sv_refrTm,\r\n{ "refrTm", "sv.refrTm",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\n"UtcTime", HFILL }},\r\n{ &hf_sv_smpSynch,\r\n{ "smpSynch", "sv.smpSynch",\r\nFT_INT32, BASE_DEC, VALS(sv_T_smpSynch_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_sv_smpRate,\r\n{ "smpRate", "sv.smpRate",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"INTEGER_0_65535", HFILL }},\r\n{ &hf_sv_seqData,\r\n{ "seqData", "sv.seqData",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Data", HFILL }},\r\n{ &hf_sv_smpMod,\r\n{ "smpMod", "sv.smpMod",\r\nFT_INT32, BASE_DEC, VALS(sv_T_smpMod_vals), 0,\r\nNULL, HFILL }},\r\n#line 299 "./asn1/sv/packet-sv-template.c"\r\n};\r\nstatic gint *ett[] = {\r\n&ett_sv,\r\n&ett_phsmeas,\r\n&ett_phsmeas_q,\r\n#line 1 "./asn1/sv/packet-sv-ettarr.c"\r\n&ett_sv_SampledValues,\r\n&ett_sv_SavPdu,\r\n&ett_sv_SEQUENCE_OF_ASDU,\r\n&ett_sv_ASDU,\r\n#line 307 "./asn1/sv/packet-sv-template.c"\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_sv_mal_utctime, { "sv.malformed.utctime", PI_MALFORMED, PI_WARN, "BER Error: malformed UTCTime encoding", EXPFILL }},\r\n{ &ei_sv_zero_pdu, { "sv.zero_pdu", PI_PROTOCOL, PI_ERROR, "Internal error, zero-byte SV PDU", EXPFILL }},\r\n};\r\nexpert_module_t* expert_sv;\r\nmodule_t *sv_module;\r\nproto_sv = proto_register_protocol(PNAME, PSNAME, PFNAME);\r\nsv_handle = register_dissector("sv", dissect_sv, proto_sv);\r\nproto_register_field_array(proto_sv, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_sv = expert_register_protocol(proto_sv);\r\nexpert_register_field_array(expert_sv, ei, array_length(ei));\r\nsv_module = prefs_register_protocol(proto_sv, NULL);\r\nprefs_register_bool_preference(sv_module, "decode_data_as_phsmeas",\r\n"Force decoding of seqData as PhsMeas",\r\nNULL, &sv_decode_data_as_phsmeas);\r\nsv_tap = register_tap("sv");\r\n}\r\nvoid proto_reg_handoff_sv(void) {\r\ndissector_add_uint("ethertype", ETHERTYPE_IEC61850_SV, sv_handle);\r\n}
