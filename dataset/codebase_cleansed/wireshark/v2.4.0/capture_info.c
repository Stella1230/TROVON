void capture_info_open(capture_session *cap_session, info_data_t* cap_info)\r\n{\r\nif (cap_info->counts.counts_hash != NULL)\r\n{\r\ng_hash_table_destroy(cap_info->counts.counts_hash);\r\n}\r\ncap_info->counts.counts_hash = g_hash_table_new_full( g_direct_hash, g_direct_equal, NULL, g_free );\r\ncap_info->counts.other = 0;\r\ncap_info->counts.total = 0;\r\ncap_info->wtap = NULL;\r\ncap_info->ui.counts = &cap_info->counts;\r\ncapture_info_ui_create(&cap_info->ui, cap_session);\r\n}\r\nstatic const char *\r\ncf_open_error_message(int err, gchar *err_info, gboolean for_writing,\r\nint file_type)\r\n{\r\nconst char *errmsg;\r\nstatic char errmsg_errno[1024+1];\r\nif (err < 0) {\r\nswitch (err) {\r\ncase WTAP_ERR_NOT_REGULAR_FILE:\r\nerrmsg = "The file \"%s\" is a \"special file\" or socket or other non-regular file.";\r\nbreak;\r\ncase WTAP_ERR_FILE_UNKNOWN_FORMAT:\r\nerrmsg = "The file \"%s\" isn't a capture file in a format Wireshark understands.";\r\nbreak;\r\ncase WTAP_ERR_UNSUPPORTED:\r\ng_snprintf(errmsg_errno, sizeof(errmsg_errno),\r\n"The file \"%%s\" contains record data that Wireshark doesn't support.\n"\r\n"(%s)", err_info != NULL ? err_info : "no information supplied");\r\ng_free(err_info);\r\nerrmsg = errmsg_errno;\r\nbreak;\r\ncase WTAP_ERR_CANT_WRITE_TO_PIPE:\r\ng_snprintf(errmsg_errno, sizeof(errmsg_errno),\r\n"The file \"%%s\" is a pipe, and %s capture files can't be "\r\n"written to a pipe.", wtap_file_type_subtype_string(file_type));\r\nerrmsg = errmsg_errno;\r\nbreak;\r\ncase WTAP_ERR_UNWRITABLE_FILE_TYPE:\r\nerrmsg = "Wireshark doesn't support writing capture files in that format.";\r\nbreak;\r\ncase WTAP_ERR_UNWRITABLE_ENCAP:\r\nerrmsg = "Wireshark can't save this capture in that format.";\r\nbreak;\r\ncase WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED:\r\nif (for_writing)\r\nerrmsg = "Wireshark can't save this capture in that format.";\r\nelse\r\nerrmsg = "The file \"%s\" is a capture for a network type that Wireshark doesn't support.";\r\nbreak;\r\ncase WTAP_ERR_BAD_FILE:\r\ng_snprintf(errmsg_errno, sizeof(errmsg_errno),\r\n"The file \"%%s\" appears to be damaged or corrupt.\n"\r\n"(%s)", err_info != NULL ? err_info : "no information supplied");\r\ng_free(err_info);\r\nerrmsg = errmsg_errno;\r\nbreak;\r\ncase WTAP_ERR_CANT_OPEN:\r\nif (for_writing)\r\nerrmsg = "The file \"%s\" could not be created for some unknown reason.";\r\nelse\r\nerrmsg = "The file \"%s\" could not be opened for some unknown reason.";\r\nbreak;\r\ncase WTAP_ERR_SHORT_READ:\r\nerrmsg = "The file \"%s\" appears to have been cut short"\r\n" in the middle of a packet or other data.";\r\nbreak;\r\ncase WTAP_ERR_SHORT_WRITE:\r\nerrmsg = "A full header couldn't be written to the file \"%s\".";\r\nbreak;\r\ncase WTAP_ERR_DECOMPRESS:\r\ng_snprintf(errmsg_errno, sizeof(errmsg_errno),\r\n"The compressed file \"%%s\" appears to be damaged or corrupt.\n"\r\n"(%s)", err_info != NULL ? err_info : "no information supplied");\r\ng_free(err_info);\r\nerrmsg = errmsg_errno;\r\nbreak;\r\ndefault:\r\ng_snprintf(errmsg_errno, sizeof(errmsg_errno),\r\n"The file \"%%s\" could not be %s: %s.",\r\nfor_writing ? "created" : "opened",\r\nwtap_strerror(err));\r\nerrmsg = errmsg_errno;\r\nbreak;\r\n}\r\n} else\r\nerrmsg = file_open_error_message(err, for_writing);\r\nreturn errmsg;\r\n}\r\ngboolean capture_info_new_file(const char *new_filename, info_data_t* cap_info)\r\n{\r\nint err;\r\ngchar *err_info;\r\ngchar *err_msg;\r\nif(cap_info->wtap != NULL) {\r\nwtap_close(cap_info->wtap);\r\n}\r\ncap_info->wtap = wtap_open_offline(new_filename, WTAP_TYPE_AUTO, &err, &err_info, FALSE);\r\nif (!cap_info->wtap) {\r\nerr_msg = g_strdup_printf(cf_open_error_message(err, err_info, FALSE, WTAP_FILE_TYPE_SUBTYPE_UNKNOWN),\r\nnew_filename);\r\ng_warning("capture_info_new_file: %d (%s)", err, err_msg);\r\ng_free (err_msg);\r\nreturn FALSE;\r\n} else\r\nreturn TRUE;\r\n}\r\nstatic void\r\ncapture_info_packet(info_data_t* cap_info, gint wtap_linktype, const guchar *pd, guint32 caplen, union wtap_pseudo_header *pseudo_header)\r\n{\r\ncapture_packet_info_t cpinfo;\r\ncpinfo.counts = cap_info->counts.counts_hash;\r\ncap_info->counts.total++;\r\nif (!try_capture_dissector("wtap_encap", wtap_linktype, pd, 0, caplen, &cpinfo, pseudo_header))\r\ncap_info->counts.other++;\r\n}\r\nvoid capture_info_new_packets(int to_read, info_data_t* cap_info)\r\n{\r\nint err;\r\ngchar *err_info;\r\ngint64 data_offset;\r\nstruct wtap_pkthdr *phdr;\r\nunion wtap_pseudo_header *pseudo_header;\r\nint wtap_linktype;\r\nconst guchar *buf;\r\ncap_info->ui.new_packets = to_read;\r\nwhile (to_read > 0) {\r\nwtap_cleareof(cap_info->wtap);\r\nif (wtap_read(cap_info->wtap, &err, &err_info, &data_offset)) {\r\nphdr = wtap_phdr(cap_info->wtap);\r\npseudo_header = &phdr->pseudo_header;\r\nwtap_linktype = phdr->pkt_encap;\r\nbuf = wtap_buf_ptr(cap_info->wtap);\r\ncapture_info_packet(cap_info, wtap_linktype, buf, phdr->caplen, pseudo_header);\r\nto_read--;\r\n}\r\n}\r\ncapture_info_ui_update(&cap_info->ui);\r\n}\r\nvoid capture_info_close(info_data_t* cap_info)\r\n{\r\ncapture_info_ui_destroy(&cap_info->ui);\r\nif(cap_info->wtap)\r\nwtap_close(cap_info->wtap);\r\n}
