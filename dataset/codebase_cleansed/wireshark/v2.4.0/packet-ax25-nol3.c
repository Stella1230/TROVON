static int\r\ndissect_dx(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *dx_tree;\r\nint data_len;\r\nint offset;\r\noffset = 0;\r\ndata_len = tvb_reported_length_remaining( tvb, offset );\r\ncol_set_str( pinfo->cinfo, COL_PROTOCOL, "DX" );\r\ncol_add_fstr( pinfo->cinfo, COL_INFO, "%s", tvb_format_text( tvb, offset, 15 ) );\r\nif ( parent_tree )\r\n{\r\nti = proto_tree_add_protocol_format( parent_tree, proto_dx, tvb, 0, -1,\r\n"DX (%s)", tvb_format_text( tvb, offset, 15 ) );\r\ndx_tree = proto_item_add_subtree( ti, ett_dx );\r\noffset = 0;\r\nproto_tree_add_item( dx_tree, hf_dx_report, tvb, offset, data_len, ENC_ASCII|ENC_NA );\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\nisaprs( guint8 dti )\r\n{\r\ngboolean b = FALSE;\r\nswitch ( dti )\r\n{\r\ncase 0x1c :\r\ncase 0x1d :\r\ncase '!' :\r\ncase '#' :\r\ncase '$' :\r\ncase '%' :\r\ncase '&' :\r\ncase ')' :\r\ncase '*' :\r\ncase '+' :\r\ncase ',' :\r\ncase '.' :\r\ncase '/' :\r\ncase ':' :\r\ncase ';' :\r\ncase '<' :\r\ncase '=' :\r\ncase '>' :\r\ncase '?' :\r\ncase '@' :\r\ncase 'T' :\r\ncase '[' :\r\ncase '\'' :\r\ncase '_' :\r\ncase '`' :\r\ncase '{' :\r\ncase '}' : b = TRUE; break;\r\ndefault : break;\r\n}\r\nreturn b;\r\n}\r\nstatic int\r\ndissect_ax25_nol3(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data _U_ )\r\n{\r\nproto_item *ti;\r\nproto_tree *ax25_nol3_tree;\r\nchar *info_buffer;\r\nint offset;\r\ntvbuff_t *next_tvb = NULL;\r\nguint8 dti = 0;\r\ngboolean dissected;\r\ninfo_buffer = (char *)wmem_alloc( wmem_packet_scope(), STRLEN );\r\ninfo_buffer[0] = '\0';\r\ncol_set_str( pinfo->cinfo, COL_PROTOCOL, "AX.25-NoL3");\r\ncol_clear( pinfo->cinfo, COL_INFO);\r\noffset = 0;\r\ng_snprintf( info_buffer, STRLEN, "Text" );\r\nif ( gPREF_APRS )\r\n{\r\ndti = tvb_get_guint8( tvb, offset );\r\nif ( isaprs( dti ) )\r\ng_snprintf( info_buffer, STRLEN, "APRS" );\r\n}\r\nif ( gPREF_DX )\r\n{\r\nif ( tvb_get_guint8( tvb, offset ) == 'D' && tvb_get_guint8( tvb, offset + 1 ) == 'X' )\r\ng_snprintf( info_buffer, STRLEN, "DX cluster" );\r\n}\r\ncol_add_str( pinfo->cinfo, COL_INFO, info_buffer );\r\nti = proto_tree_add_protocol_format( parent_tree,\r\nproto_ax25_nol3,\r\ntvb,\r\n0,\r\n-1,\r\n"AX.25 No Layer 3 - (%s)", info_buffer );\r\nax25_nol3_tree = proto_item_add_subtree( ti, ett_ax25_nol3 );\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ndissected = FALSE;\r\nif ( gPREF_APRS )\r\n{\r\nif ( isaprs( dti ) )\r\n{\r\ndissected = TRUE;\r\ncall_dissector( aprs_handle , next_tvb, pinfo, ax25_nol3_tree );\r\n}\r\n}\r\nif ( gPREF_DX )\r\n{\r\nif ( tvb_get_guint8( tvb, offset ) == 'D' && tvb_get_guint8( tvb, offset + 1 ) == 'X' )\r\n{\r\ndissected = TRUE;\r\ndissect_dx( next_tvb, pinfo, ax25_nol3_tree, NULL );\r\n}\r\n}\r\nif ( ! dissected )\r\ncall_data_dissector(next_tvb, pinfo, ax25_nol3_tree );\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ax25_nol3(void)\r\n{\r\nmodule_t *ax25_nol3_module;\r\n#if 0\r\nstatic hf_register_info hf[] = {\r\n{ &hf_text,\r\n{ "Text", "ax25_nol3.text",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n};\r\n#endif\r\nstatic hf_register_info hf_dx[] = {\r\n{ &hf_dx_report,\r\n{ "DX", "ax25_nol3.dx",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"DX cluster", HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ax25_nol3,\r\n&ett_dx,\r\n};\r\nproto_ax25_nol3 = proto_register_protocol("AX.25 no Layer 3", "AX.25 no L3", "ax25_nol3");\r\nproto_register_subtree_array( ett, array_length( ett ) );\r\nax25_nol3_module = prefs_register_protocol( proto_ax25_nol3, NULL);\r\nprefs_register_bool_preference(ax25_nol3_module, "showaprs",\r\n"Decode the APRS info field",\r\n"Enable decoding of the payload as APRS.",\r\n&gPREF_APRS );\r\nprefs_register_bool_preference(ax25_nol3_module, "showcluster",\r\n"Decode DX cluster info field",\r\n"Enable decoding of the payload as DX cluster info.",\r\n&gPREF_DX );\r\nproto_dx = proto_register_protocol("DX cluster", "DX", "dx");\r\nregister_dissector( "dx", dissect_dx, proto_dx);\r\nproto_register_field_array( proto_dx, hf_dx, array_length( hf_dx ) );\r\n}\r\nvoid\r\nproto_reg_handoff_ax25_nol3(void)\r\n{\r\ndissector_add_uint( "ax25.pid", AX25_P_NO_L3, create_dissector_handle( dissect_ax25_nol3, proto_ax25_nol3 ) );\r\naprs_handle = find_dissector_add_dependency( "aprs", proto_ax25_nol3 );\r\n}
