static int\r\ndissect_gpef_efskey(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *parent_tree)\r\n{\r\nproto_item *item = NULL;\r\nproto_tree *tree = NULL;\r\nint old_offset = offset;\r\nguint32 length1, sid_offset;\r\nguint32 cert_length, cert_offset;\r\ntvbuff_t *next_tvb;\r\nasn1_ctx_t asn1_ctx;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\r\nif (parent_tree) {\r\nitem = proto_tree_add_item(parent_tree, hf_gpef_efskey, tvb, -1, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_gpef_efskey);\r\n}\r\nlength1 = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_gpef_efskey_length1, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_gpef_efskey_length2, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nsid_offset = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_gpef_efskey_sid_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\noffset += 4;\r\ncert_length = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_gpef_efskey_cert_length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\ncert_offset = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_gpef_efskey_cert_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\ndissect_nt_sid(tvb, old_offset+4+sid_offset, tree, "sid", NULL, -1);\r\nnext_tvb = tvb_new_subset_length(tvb, old_offset+4+cert_offset, cert_length);\r\n(void)dissect_x509af_Certificate(FALSE, next_tvb, 0, &asn1_ctx, tree, hf_gpef_efskey_certificate);\r\noffset = old_offset + length1;\r\nproto_item_set_len(item, offset-old_offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_gpef_efsblob(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data _U_)\r\n{\r\nint offset = 0;\r\nproto_tree *tree;\r\nproto_item *item;\r\nguint32 count;\r\nitem = proto_tree_add_item(parent_tree, proto_gpef, tvb, 0, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_gpef);\r\noffset += 4;\r\ncount = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_gpef_keycount, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nwhile (count--) {\r\noffset = dissect_gpef_efskey(tvb, offset, pinfo, tree);\r\n}\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_gpef(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_gpef_keycount,\r\n{ "Key Count", "gpef.key_count", FT_UINT32, BASE_DEC, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_gpef_efskey_length1,\r\n{ "Length1", "gpef.efskey.length1", FT_UINT32, BASE_DEC, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_gpef_efskey_length2,\r\n{ "Length2", "gpef.efskey.length2", FT_UINT32, BASE_DEC, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_gpef_efskey_sid_offset,\r\n{ "SID Offset", "gpef.efskey.sid_offset", FT_UINT32, BASE_DEC, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_gpef_efskey_cert_offset,\r\n{ "Cert Offset", "gpef.efskey.cert_offset", FT_UINT32, BASE_DEC, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_gpef_efskey_cert_length,\r\n{ "Cert Length", "gpef.efskey.cert_length", FT_UINT32, BASE_DEC, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_gpef_efskey,\r\n{ "EfsKey", "gpef.efskey", FT_NONE, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_gpef_efskey_certificate,\r\n{ "Certificate", "gpef.efskey.certificate", FT_NONE, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_gpef,\r\n&ett_gpef_efskey,\r\n};\r\nproto_gpef = proto_register_protocol("GPEF", "GPEF", "gpef");\r\nproto_register_field_array(proto_gpef, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nregister_dissector("efsblob", dissect_gpef_efsblob, proto_gpef);\r\n}
