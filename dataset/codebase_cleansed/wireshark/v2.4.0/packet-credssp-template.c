static int\r\ndissect_credssp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data)\r\n{\r\nproto_item *item=NULL;\r\nproto_tree *tree=NULL;\r\nif(parent_tree){\r\nitem = proto_tree_add_item(parent_tree, proto_credssp, tvb, 0, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_credssp);\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "CredSSP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ncreds_type = -1;\r\nreturn dissect_TSRequest_PDU(tvb, pinfo, tree, data);\r\n}\r\nstatic gboolean\r\ndissect_credssp_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data _U_)\r\n{\r\nasn1_ctx_t asn1_ctx;\r\nint offset = 0;\r\ngint8 ber_class;\r\ngboolean pc;\r\ngint32 tag;\r\nguint32 length;\r\ngint8 ver;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\r\nif(tvb_captured_length(tvb) > 7) {\r\noffset = get_ber_identifier(tvb, offset, &ber_class, &pc, &tag);\r\nif((ber_class == BER_CLASS_UNI) && (tag == BER_UNI_TAG_SEQUENCE) && (pc == TRUE)) {\r\noffset = get_ber_length(tvb, offset, NULL, NULL);\r\noffset = get_ber_identifier(tvb, offset, &ber_class, &pc, &tag);\r\nif((ber_class == BER_CLASS_CON) && (tag == 0)) {\r\noffset = get_ber_length(tvb, offset, NULL, NULL);\r\noffset = get_ber_identifier(tvb, offset, &ber_class, &pc, &tag);\r\nif((ber_class == BER_CLASS_UNI) && (tag == BER_UNI_TAG_INTEGER)) {\r\noffset = get_ber_length(tvb, offset, &length, NULL);\r\nver = tvb_get_guint8(tvb, offset);\r\nif((length == 1) && ((ver == 2) || (ver == 3))) {\r\nif (have_tap_listener(exported_pdu_tap)) {\r\nexp_pdu_data_t *exp_pdu_data = export_pdu_create_common_tags(pinfo, "credssp", EXP_PDU_TAG_PROTO_NAME);\r\nexp_pdu_data->tvb_captured_length = tvb_captured_length(tvb);\r\nexp_pdu_data->tvb_reported_length = tvb_reported_length(tvb);\r\nexp_pdu_data->pdu_tvb = tvb;\r\ntap_queue_packet(exported_pdu_tap, pinfo, exp_pdu_data);\r\n}\r\ndissect_credssp(tvb, pinfo, parent_tree, NULL);\r\nreturn TRUE;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nvoid proto_register_credssp(void) {\r\nstatic hf_register_info hf[] =\r\n{\r\n{ &hf_credssp_TSPasswordCreds,\r\n{ "TSPasswordCreds", "credssp.TSPasswordCreds",\r\nFT_NONE, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_credssp_TSSmartCardCreds,\r\n{ "TSSmartCardCreds", "credssp.TSSmartCardCreds",\r\nFT_NONE, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_credssp_TSCredentials,\r\n{ "TSCredentials", "credssp.TSCredentials",\r\nFT_NONE, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n#include "packet-credssp-hfarr.c"\r\n};\r\nstatic gint *ett[] = {\r\n&ett_credssp,\r\n#include "packet-credssp-ettarr.c"\r\n};\r\nproto_credssp = proto_register_protocol(PNAME, PSNAME, PFNAME);\r\nregister_dissector("credssp", dissect_credssp, proto_credssp);\r\nproto_register_field_array(proto_credssp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\ncredssp_heur_subdissector_list = register_heur_dissector_list("credssp", proto_credssp);\r\n}\r\nvoid proto_reg_handoff_credssp(void) {\r\nheur_dissector_add("ssl", dissect_credssp_heur, "CredSSP over SSL", "credssp_ssl", proto_credssp, HEURISTIC_ENABLE);\r\nexported_pdu_tap = find_tap_id(EXPORT_PDU_TAP_NAME_LAYER_7);\r\n}
