static gboolean mplog_read_packet(FILE_T fh, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nguint8 *p, *start_p;\r\nguint64 last_ctr = 0;\r\nguint8 block[MPLOG_BLOCK_SIZE];\r\nguint8 data, type;\r\nguint64 ctr;\r\ngint pkt_bytes = 0;\r\nguint8 pkt_type = TYPE_UNKNOWN;\r\nguint64 pkt_ctr = 0;\r\nws_buffer_assure_space(buf, PKT_BUF_LEN);\r\np = ws_buffer_start_ptr(buf);\r\nstart_p = p;\r\np += ISO14443_PSEUDO_HDR_LEN;\r\ndo {\r\nif (!wtap_read_bytes_or_eof(fh, block, sizeof(block), err, err_info)) {\r\nif (pkt_bytes != 0) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nbreak;\r\n}\r\ndata = block[0];\r\ntype = block[1];\r\nctr = pletoh48(&block[2]);\r\nif (pkt_type == TYPE_UNKNOWN) {\r\nif (KNOWN_TYPE(type)) {\r\npkt_type = type;\r\npkt_ctr = ctr;\r\n}\r\n}\r\nif (type == pkt_type) {\r\nif (last_ctr != 0) {\r\nif (ctr - last_ctr > 200*100) {\r\nfile_seek(fh, -MPLOG_BLOCK_SIZE, SEEK_CUR, err);\r\nbreak;\r\n}\r\n}\r\n*p++ = data;\r\npkt_bytes++;\r\nlast_ctr = ctr;\r\n}\r\nelse if (KNOWN_TYPE(type)) {\r\nfile_seek(fh, -MPLOG_BLOCK_SIZE, SEEK_CUR, err);\r\nbreak;\r\n}\r\n} while (pkt_bytes < ISO14443_MAX_PKT_LEN);\r\nif (pkt_type == TYPE_UNKNOWN)\r\nreturn FALSE;\r\nstart_p[0] = ISO14443_PSEUDO_HDR_VER;\r\nif (pkt_type==TYPE_PCD_PICC_A || pkt_type==TYPE_PCD_PICC_B)\r\nstart_p[1] = ISO14443_PSEUDO_HDR_PCD_TO_PICC;\r\nelse\r\nstart_p[1] = ISO14443_PSEUDO_HDR_PICC_TO_PCD;\r\nstart_p[2] = pkt_bytes >> 8;\r\nstart_p[3] = pkt_bytes & 0xFF;\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->pkt_encap = WTAP_ENCAP_ISO14443;\r\nphdr->presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN;\r\nphdr->ts.secs = (time_t)((pkt_ctr*10)/(1000*1000*1000));\r\nphdr->ts.nsecs = (int)((pkt_ctr*10)%(1000*1000*1000));\r\nphdr->caplen = ISO14443_PSEUDO_HDR_LEN + pkt_bytes;\r\nphdr->len = phdr->caplen;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nmplog_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\r\n{\r\n*data_offset = file_tell(wth->fh);\r\nreturn mplog_read_packet(\r\nwth->fh, &wth->phdr, wth->frame_buffer, err, err_info);\r\n}\r\nstatic gboolean\r\nmplog_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *pkthdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nif (-1 == file_seek(wth->random_fh, seek_off, SEEK_SET, err))\r\nreturn FALSE;\r\nif (!mplog_read_packet(wth->random_fh, pkthdr, buf, err, err_info)) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nwtap_open_return_val mplog_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\ngboolean ok;\r\nguint8 magic[6];\r\nok = wtap_read_bytes(wth->fh, magic, 6, err, err_info);\r\nif (!ok) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (memcmp(magic, "MPCSII", 6) != 0)\r\nreturn WTAP_OPEN_NOT_MINE;\r\nwth->file_encap = WTAP_ENCAP_ISO14443;\r\nwth->snapshot_length = 0;\r\nwth->file_tsprec = WTAP_TSPREC_NSEC;\r\nwth->priv = NULL;\r\nwth->subtype_read = mplog_read;\r\nwth->subtype_seek_read = mplog_seek_read;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_MPLOG;\r\nif (-1 == file_seek(wth->fh, 0x80, SEEK_SET, err))\r\nreturn WTAP_OPEN_ERROR;\r\n*err = 0;\r\nreturn WTAP_OPEN_MINE;\r\n}
