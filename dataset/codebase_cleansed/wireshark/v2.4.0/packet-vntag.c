static int\r\ndissect_vntag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nguint16 encap_proto;\r\nproto_tree *vntag_tree = NULL;\r\nethertype_data_t ethertype_data;\r\nstatic const int * fields[] = {\r\n&hf_vntag_dir,\r\n&hf_vntag_ptr,\r\n&hf_vntag_vif_list_id,\r\n&hf_vntag_dst,\r\n&hf_vntag_looped,\r\n&hf_vntag_r,\r\n&hf_vntag_version,\r\n&hf_vntag_src,\r\nNULL\r\n};\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "VNTAG");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (tree) {\r\nproto_item *ti = proto_tree_add_item(tree, proto_vntag, tvb, 0, 4, ENC_NA);\r\nvntag_tree = proto_item_add_subtree(ti, ett_vntag);\r\nproto_tree_add_bitmask_list(vntag_tree, tvb, 0, 4, fields, ENC_BIG_ENDIAN);\r\n}\r\nencap_proto = tvb_get_ntohs(tvb, 4);\r\n#if 0\r\nif (encap_proto <= IEEE_802_3_MAX_LEN) {\r\ngboolean is_802_2;\r\nis_802_2 = TRUE;\r\nif (tvb_captured_length_remaining(tvb, 4) >= 2) {\r\nif (tvb_get_ntohs(tvb, 4) == 0xffff)\r\nis_802_2 = FALSE;\r\n}\r\ndissect_802_3(encap_proto, is_802_2, tvb, 4, pinfo, tree, vntag_tree, hf_vntag_len, hf_vntag_trailer, 0);\r\n} else {\r\n#endif\r\nethertype_data.etype = encap_proto;\r\nethertype_data.offset_after_ethertype = 6;\r\nethertype_data.fh_tree = vntag_tree;\r\nethertype_data.etype_id = hf_vntag_etype;\r\nethertype_data.trailer_id = hf_vntag_trailer;\r\nethertype_data.fcs_len = 0;\r\ncall_dissector_with_data(ethertype_handle, tvb, pinfo, tree, &ethertype_data);\r\n#if 0\r\n}\r\n#endif\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_vntag(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_vntag_etype,\r\n{ "Type", "vntag.etype", FT_UINT16, BASE_HEX, VALS(etype_vals), 0x0, NULL, HFILL }\r\n},\r\n{ &hf_vntag_dir,\r\n{ "Direction", "vntag.dir", FT_UINT32, BASE_DEC, NULL, 0x80000000, NULL, HFILL }\r\n},\r\n{ &hf_vntag_ptr,\r\n{ "Pointer", "vntag.ptr", FT_UINT32, BASE_DEC, NULL, 0x40000000, NULL, HFILL }\r\n},\r\n{ &hf_vntag_vif_list_id,\r\n{ "Downlink Ports", "vntag.vif_list_id", FT_UINT32, BASE_DEC, NULL, 0x30000000, NULL, HFILL }\r\n},\r\n{ &hf_vntag_dst,\r\n{ "Destination", "vntag.dst", FT_UINT32, BASE_DEC, NULL, 0x0FFF0000, NULL, HFILL }\r\n},\r\n{ &hf_vntag_looped,\r\n{ "Looped", "vntag.looped", FT_UINT32, BASE_DEC, NULL, 0x00008000, NULL, HFILL }\r\n},\r\n{ &hf_vntag_r,\r\n{ "Reserved", "vntag.r", FT_UINT32, BASE_DEC, NULL, 0x00004000, NULL, HFILL }\r\n},\r\n{ &hf_vntag_version,\r\n{ "Version", "vntag.version", FT_UINT32, BASE_DEC, NULL, 0x00003000, NULL, HFILL }\r\n},\r\n{ &hf_vntag_src,\r\n{ "Source", "vntag.src", FT_UINT32, BASE_DEC, NULL, 0x00000FFF, NULL, HFILL }\r\n},\r\n#if 0\r\n{ &hf_vntag_len,\r\n{ "Length", "vntag.len", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n#endif\r\n{ &hf_vntag_trailer,\r\n{ "Trailer", "vntag.trailer", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_vntag\r\n};\r\nproto_vntag = proto_register_protocol("VN-Tag", "VNTAG", "vntag");\r\nproto_register_field_array(proto_vntag, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_vntag(void)\r\n{\r\ndissector_handle_t vntag_handle;\r\nvntag_handle = create_dissector_handle(dissect_vntag, proto_vntag);\r\ndissector_add_uint("ethertype", ETHERTYPE_VNTAG, vntag_handle);\r\nethertype_handle = find_dissector_add_dependency("ethertype", proto_vntag);\r\n}
