static int\r\ndissect_ypbind_domain_v2_request(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nreturn dissect_rpc_string(tvb, tree, hf_ypbind_domain, 0, NULL);\r\n}\r\nstatic int\r\ndissect_ypbind_domain_v2_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nguint32 type;\r\nint offset = 0;\r\ntype=tvb_get_ntohl(tvb, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_ypbind_resp_type, offset);\r\nswitch(type){\r\ncase YPBIND_RESP_TYPE_SUCC_VAL:\r\nproto_tree_add_item(tree, hf_ypbind_addr,\r\ntvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\noffset = dissect_rpc_uint32(tvb, tree,\r\nhf_ypbind_port, offset);\r\nbreak;\r\ncase YPBIND_RESP_TYPE_FAIL_VAL:\r\noffset = dissect_rpc_uint32(tvb, tree,\r\nhf_ypbind_resp_type, offset);\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_ypbind_setdomain_v2_request(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_string(tvb, tree,\r\nhf_ypbind_domain, offset, NULL);\r\nproto_tree_add_item(tree, hf_ypbind_addr,\r\ntvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\noffset = dissect_rpc_uint32(tvb, tree,\r\nhf_ypbind_port, offset);\r\noffset = dissect_rpc_uint32(tvb, tree,\r\nhf_ypbind_setdom_version, offset);\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_ypbind(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ypbind_procedure_v1, {\r\n"V1 Procedure", "ypbind.procedure_v1", FT_UINT32, BASE_DEC,\r\nVALS(ypbind1_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_ypbind_procedure_v2, {\r\n"V2 Procedure", "ypbind.procedure_v2", FT_UINT32, BASE_DEC,\r\nVALS(ypbind2_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_ypbind_domain, {\r\n"Domain", "ypbind.domain", FT_STRING, BASE_NONE,\r\nNULL, 0, "Name of the NIS/YP Domain", HFILL }},\r\n{ &hf_ypbind_resp_type, {\r\n"Response Type", "ypbind.resp_type", FT_UINT32, BASE_DEC,\r\nVALS(resp_type_vals), 0, NULL, HFILL }},\r\n#if 0\r\n{ &hf_ypbind_error, {\r\n"Error", "ypbind.error", FT_UINT32, BASE_DEC,\r\nVALS(error_vals), 0, "YPBIND Error code", HFILL }},\r\n#endif\r\n{ &hf_ypbind_addr, {\r\n"IP Addr", "ypbind.addr", FT_IPv4, BASE_NONE,\r\nNULL, 0, "IP Address of server", HFILL }},\r\n{ &hf_ypbind_port, {\r\n"Port", "ypbind.port", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Port to use", HFILL }},\r\n{ &hf_ypbind_setdom_version, {\r\n"Version", "ypbind.setdom.version", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Version of setdom", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ypbind,\r\n};\r\nproto_ypbind = proto_register_protocol("Yellow Pages Bind",\r\n"YPBIND", "ypbind");\r\nproto_register_field_array(proto_ypbind, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_ypbind(void)\r\n{\r\nrpc_init_prog(proto_ypbind, YPBIND_PROGRAM, ett_ypbind,\r\nG_N_ELEMENTS(ypbind_vers_info), ypbind_vers_info);\r\n}
