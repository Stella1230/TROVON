static int\r\ndissect_tte(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nint is_frame_pcf;\r\nethertype_data_t ethertype_data;\r\nproto_item *tte_root_item, *tte_macdest_item;\r\nproto_tree *tte_tree, *tte_macdest_tree;\r\nif (tvb_reported_length(tvb) < TTE_HEADER_LENGTH)\r\nreturn 0;\r\nis_frame_pcf =\r\n(tvb_get_ntohs(tvb, TTE_MAC_LENGTH * 2) == ETHERTYPE_TTE_PCF);\r\nif (!is_frame_pcf)\r\n{\r\nif ( (tvb_get_ntohl(tvb, 0) & tte_pref_ct_mask) != tte_pref_ct_marker)\r\nreturn 0;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "TTE ");\r\nif (tvb_get_ntohs(tvb, TTE_MAC_LENGTH * 2) <= IEEE_802_3_MAX_LEN)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_INFO, "TTEthernet Frame");\r\n}\r\nelse\r\n{\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Bogus TTEthernet Frame");\r\n}\r\nif (tree) {\r\ntte_root_item = proto_tree_add_item(tree, proto_tte, tvb, 0,\r\nTTE_HEADER_LENGTH, ENC_NA);\r\ntte_tree = proto_item_add_subtree(tte_root_item, ett_tte);\r\ntte_macdest_item = proto_tree_add_item(tte_tree,\r\nhf_eth_dst, tvb, 0, TTE_MAC_LENGTH, ENC_NA);\r\nproto_tree_add_item(tte_tree,\r\nhf_eth_src, tvb, TTE_MAC_LENGTH, TTE_MAC_LENGTH, ENC_NA);\r\nproto_tree_add_item(tte_tree,\r\nhf_eth_type, tvb, TTE_MAC_LENGTH*2, TTE_ETHERTYPE_LENGTH,\r\nENC_BIG_ENDIAN);\r\ntte_macdest_tree = proto_item_add_subtree(tte_macdest_item,\r\nett_tte_macdest);\r\nproto_tree_add_item(tte_macdest_tree,\r\nhf_tte_dst_cf, tvb, 0, TTE_MACDEST_CF_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tte_macdest_tree,\r\nhf_tte_ctid, tvb, TTE_MACDEST_CF_LENGTH,\r\nTTE_MACDEST_CTID_LENGTH, ENC_BIG_ENDIAN);\r\n}\r\ncol_set_fence(pinfo->cinfo, COL_PROTOCOL);\r\nethertype_data.etype = tvb_get_ntohs(tvb, TTE_MAC_LENGTH * 2);\r\nethertype_data.offset_after_ethertype = 14;\r\nethertype_data.fh_tree = NULL;\r\nethertype_data.etype_id = hf_eth_type;\r\nethertype_data.trailer_id = 0;\r\nethertype_data.fcs_len = 0;\r\ncall_dissector_with_data(ethertype_handle, tvb, pinfo, tree, &ethertype_data);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nvoid\r\nproto_register_tte(void)\r\n{\r\nmodule_t *tte_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_tte_dst_cf,\r\n{ "Constant Field", "tte.cf",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_tte_ctid,\r\n{ "Critical Traffic Identifier", "tte.ctid",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_tte,\r\n&ett_tte_macdest\r\n};\r\nproto_tte = proto_register_protocol("TTEthernet", "TTE", "tte");\r\nproto_register_field_array(proto_tte, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\ntte_module = prefs_register_protocol(proto_tte, NULL);\r\nprefs_register_uint_preference(tte_module, "ct_mask_value",\r\n"CT Mask (in hex)",\r\n"Critical Traffic Mask (base hex)",\r\n16, &tte_pref_ct_mask);\r\nprefs_register_uint_preference(tte_module, "ct_marker_value",\r\n"CT Marker (in hex)",\r\n"Critical Traffic Marker (base hex)",\r\n16, &tte_pref_ct_marker);\r\n}\r\nvoid\r\nproto_reg_handoff_tte(void)\r\n{\r\nheur_dissector_add("eth", dissect_tte, "TTEthernet", "tte_eth", proto_tte, HEURISTIC_ENABLE);\r\nhf_eth_dst = proto_registrar_get_id_byname ("eth.dst");\r\nhf_eth_src = proto_registrar_get_id_byname ("eth.src");\r\nhf_eth_type = proto_registrar_get_id_byname ("eth.type");\r\nethertype_handle = find_dissector_add_dependency("ethertype", proto_tte);\r\n}
