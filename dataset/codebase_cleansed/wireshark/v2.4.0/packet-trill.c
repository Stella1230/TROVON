static int\r\ndissect_trill( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_ )\r\n{\r\nproto_item *ti ;\r\nproto_tree *trill_tree ;\r\nguint32 op_len ;\r\ntvbuff_t *next_tvb ;\r\nint offset = 0 ;\r\ncol_set_str( pinfo->cinfo, COL_PROTOCOL, TRILL_PROTO_COL_NAME ) ;\r\ncol_set_str( pinfo->cinfo, COL_INFO, TRILL_PROTO_COL_INFO ) ;\r\nop_len = tvb_get_bits( tvb, 5, 5, ENC_BIG_ENDIAN ) * TRILL_OP_LENGTH_BYTE_UNITS ;\r\nif (tree) {\r\nti = proto_tree_add_item( tree, proto_trill, tvb, 0,\r\nTRILL_MIN_FRAME_LENGTH + op_len, ENC_NA ) ;\r\ntrill_tree = proto_item_add_subtree( ti, ett_trill ) ;\r\nproto_tree_add_item( trill_tree, hf_trill_version, tvb, offset,\r\nTRILL_BIT_FIELDS_LEN, ENC_BIG_ENDIAN ) ;\r\nproto_tree_add_item( trill_tree, hf_trill_reserved, tvb, offset,\r\nTRILL_BIT_FIELDS_LEN, ENC_BIG_ENDIAN ) ;\r\nproto_tree_add_item( trill_tree, hf_trill_multi_dst, tvb, offset,\r\nTRILL_BIT_FIELDS_LEN, ENC_BIG_ENDIAN ) ;\r\nproto_tree_add_item( trill_tree, hf_trill_op_len, tvb, offset,\r\nTRILL_BIT_FIELDS_LEN, ENC_BIG_ENDIAN ) ;\r\nproto_tree_add_item( trill_tree, hf_trill_hop_cnt, tvb, offset,\r\nTRILL_BIT_FIELDS_LEN, ENC_BIG_ENDIAN ) ;\r\noffset += TRILL_BIT_FIELDS_LEN ;\r\nproto_tree_add_item( trill_tree, hf_trill_egress_nick, tvb, offset,\r\nTRILL_NICKNAME_LEN, ENC_BIG_ENDIAN ) ;\r\noffset += TRILL_NICKNAME_LEN ;\r\nproto_tree_add_item( trill_tree, hf_trill_ingress_nick, tvb, offset,\r\nTRILL_NICKNAME_LEN , ENC_BIG_ENDIAN ) ;\r\noffset += TRILL_NICKNAME_LEN ;\r\nif( op_len != 0 ) {\r\nproto_tree_add_item( trill_tree, hf_trill_options, tvb,\r\noffset, op_len, ENC_NA ) ;\r\n}\r\n}\r\nnext_tvb = tvb_new_subset_remaining( tvb, TRILL_MIN_FRAME_LENGTH + op_len ) ;\r\ncall_dissector( eth_dissector, next_tvb, pinfo, tree ) ;\r\nreturn tvb_reported_length( tvb ) ;\r\n}\r\nvoid\r\nproto_register_trill(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_trill_version,\r\n{ "Version", "trill.version",\r\nFT_UINT16, BASE_DEC_HEX|BASE_RANGE_STRING, RVALS(version_strings),\r\nTRILL_VERSION_MASK, "The TRILL version number.", HFILL }},\r\n{ &hf_trill_reserved,\r\n{ "Reserved", "trill.reserved",\r\nFT_UINT16, BASE_DEC_HEX|BASE_RANGE_STRING, RVALS(reserved_strings),\r\nTRILL_RESERVED_MASK, "Bits reserved for future specification.", HFILL }},\r\n{ &hf_trill_multi_dst,\r\n{ "Multi Destination", "trill.multi_dst",\r\nFT_BOOLEAN, 16, TFS(&multi_dst_strings), TRILL_MULTI_DST_MASK,\r\n"A boolean specifying if this is a multi-destination frame.", HFILL }},\r\n{ &hf_trill_op_len,\r\n{ "Option Length", "trill.op_len",\r\nFT_UINT16, BASE_DEC_HEX, NULL, TRILL_OP_LEN_MASK,\r\n"The length of the options field of this frame.", HFILL }},\r\n{ &hf_trill_hop_cnt,\r\n{ "Hop Count", "trill.hop_cnt",\r\nFT_UINT16, BASE_DEC_HEX, NULL, TRILL_HOP_CNT_MASK,\r\n"The remaining hop count for this frame.", HFILL }},\r\n{ &hf_trill_egress_nick,\r\n{ "Egress/Root RBridge Nickname", "trill.egress_nick",\r\nFT_UINT16, BASE_DEC_HEX|BASE_RANGE_STRING, RVALS(nickname_strings), 0x0,\r\n"The Egress or Distribution Tree Root RBridge Nickname.", HFILL }},\r\n{ &hf_trill_ingress_nick,\r\n{ "Ingress RBridge Nickname", "trill.ingress_nick",\r\nFT_UINT16, BASE_DEC_HEX|BASE_RANGE_STRING, RVALS(nickname_strings), 0x0,\r\n"The Ingress RBridge Nickname.", HFILL }},\r\n{ &hf_trill_options,\r\n{ "Options", "trill.options",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"The TRILL Options field.", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_trill\r\n};\r\nproto_trill = proto_register_protocol("TRILL", "TRILL", "trill");\r\nproto_register_field_array(proto_trill, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_trill(void)\r\n{\r\ndissector_handle_t trill_handle;\r\ntrill_handle = create_dissector_handle(dissect_trill, proto_trill);\r\ndissector_add_uint("ethertype", ETHERTYPE_TRILL, trill_handle);\r\neth_dissector = find_dissector_add_dependency( "eth_withoutfcs", proto_trill );\r\n}
