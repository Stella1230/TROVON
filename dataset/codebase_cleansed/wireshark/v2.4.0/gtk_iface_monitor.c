static void\r\ngtk_iface_mon_event_cb(const char *iface, int up)\r\n{\r\nint present = 0;\r\nguint ifs, j;\r\ninterface_t device;\r\ninterface_options interface_opts;\r\nfor (ifs = 0; ifs < global_capture_opts.all_ifaces->len; ifs++) {\r\ndevice = g_array_index(global_capture_opts.all_ifaces, interface_t, ifs);\r\nif (strcmp(device.name, iface) == 0) {\r\npresent = 1;\r\nif (!up) {\r\nfor (j = 0; j < global_capture_opts.ifaces->len; j++) {\r\ninterface_opts = g_array_index(global_capture_opts.ifaces, interface_options, j);\r\nif (strcmp(interface_opts.name, device.name) == 0) {\r\ng_array_remove_index(global_capture_opts.ifaces, j);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif (present == up)\r\nreturn;\r\nrefresh_local_interface_lists();\r\n}\r\nstatic gboolean\r\ngtk_iface_mon_event(GIOChannel *source _U_, GIOCondition condition _U_, gpointer data _U_)\r\n{\r\niface_mon_event();\r\nreturn TRUE;\r\n}\r\nint\r\ngtk_iface_mon_start(void)\r\n{\r\nint sock, err;\r\nerr = iface_mon_start(&gtk_iface_mon_event_cb);\r\nif (err)\r\nreturn err;\r\nsock = iface_mon_get_sock();\r\niface_mon_channel = g_io_channel_unix_new(sock);\r\ng_io_channel_set_encoding(iface_mon_channel, NULL, NULL);\r\ng_io_add_watch(iface_mon_channel,\r\n(GIOCondition)(G_IO_IN|G_IO_ERR|G_IO_HUP),\r\n&gtk_iface_mon_event,\r\nNULL);\r\nreturn 0;\r\n}\r\nint\r\ngtk_iface_mon_stop(void)\r\n{\r\niface_mon_stop();\r\nreturn 0;\r\n}
