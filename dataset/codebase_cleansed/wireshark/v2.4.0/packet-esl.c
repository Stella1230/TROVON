static guint16 flags_to_port(guint16 flagsValue) {\r\nif ( (flagsValue & esl_port0_bitmask) != 0 )\r\nreturn 0;\r\nelse if ( (flagsValue & esl_port1_bitmask) != 0 )\r\nreturn 1;\r\nelse if ( (flagsValue & esl_port2_bitmask) != 0 )\r\nreturn 2;\r\nelse if ( (flagsValue & esl_port3_bitmask) != 0 )\r\nreturn 3;\r\nelse if ( (flagsValue & esl_port4_bitmask) != 0 )\r\nreturn 4;\r\nelse if ( (flagsValue & esl_port5_bitmask) != 0 )\r\nreturn 5;\r\nelse if ( (flagsValue & esl_port6_bitmask) != 0 )\r\nreturn 6;\r\nelse if ( (flagsValue & esl_port7_bitmask) != 0 )\r\nreturn 7;\r\nelse if ( (flagsValue & esl_port8_bitmask) != 0 )\r\nreturn 8;\r\nelse if ( (flagsValue & esl_port9_bitmask) != 0 )\r\nreturn 9;\r\nelse if ( (flagsValue & esl_port10_bitmask) != 0 )\r\nreturn 10;\r\nelse if ( (flagsValue & esl_port11_bitmask) != 0 )\r\nreturn 11;\r\nreturn -1;\r\n}\r\nstatic int\r\ndissect_esl_header(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_) {\r\nproto_item *ti = NULL;\r\nproto_tree *esl_header_tree;\r\ngint offset = 0;\r\nguint esl_length = tvb_reported_length(tvb);\r\nif ( esl_length >= SIZEOF_ESLHEADER )\r\n{\r\nif (tree)\r\n{\r\nguint16 flags;\r\nti = proto_tree_add_item(tree, proto_esl, tvb, 0, SIZEOF_ESLHEADER, ENC_NA);\r\nesl_header_tree = proto_item_add_subtree(ti, ett_esl);\r\noffset+=6;\r\nflags = tvb_get_letohs(tvb, offset);\r\nproto_tree_add_uint(esl_header_tree, hf_esl_port, tvb, offset, 2, flags_to_port(flags));\r\nproto_tree_add_item(esl_header_tree, hf_esl_alignerror, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(esl_header_tree, hf_esl_crcerror, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(esl_header_tree, hf_esl_timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean is_esl_header(tvbuff_t *tvb, gint offset)\r\n{\r\nreturn tvb_get_guint8(tvb, offset) == 0x01 &&\r\ntvb_get_guint8(tvb, offset+1) == 0x01 &&\r\ntvb_get_guint8(tvb, offset+2) == 0x05 &&\r\n(tvb_get_guint8(tvb, offset+3) == 0x10 ||tvb_get_guint8(tvb, offset+3) == 0x11)&&\r\ntvb_get_guint8(tvb, offset+4) == 0x00 &&\r\ntvb_get_guint8(tvb, offset+5) == 0x00;\r\n}\r\nstatic void modify_times(tvbuff_t *tvb, gint offset, packet_info *pinfo)\r\n{\r\nif ( ref_time_frame.fd == NULL )\r\n{\r\nref_time_frame.esl_ts = tvb_get_letoh64(tvb, offset+8);\r\nref_time_frame.fd = pinfo->fd;\r\nref_time_frame.num = pinfo->num;\r\nref_time_frame.abs_ts = pinfo->abs_ts;\r\n}\r\nelse if ( !pinfo->fd->flags.visited )\r\n{\r\nguint64 nsecs = tvb_get_letoh64(tvb, offset+8) - ref_time_frame.esl_ts;\r\nguint64 secs = nsecs/1000000000;\r\nnstime_t ts;\r\nnstime_t ts_delta;\r\nts.nsecs = ref_time_frame.abs_ts.nsecs + (int)(nsecs-(secs*1000000000));\r\nif ( ts.nsecs > 1000000000 )\r\n{\r\nts.nsecs-=1000000000;\r\nsecs++;\r\n}\r\nts.secs = ref_time_frame.abs_ts.secs+(int)secs;\r\nnstime_delta(&ts_delta, &ts, &pinfo->abs_ts);\r\npinfo->abs_ts = ts;\r\nnstime_add(&pinfo->rel_ts, &ts_delta);\r\n}\r\n}\r\nstatic gboolean\r\ndissect_esl_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nstatic gboolean in_heur = FALSE;\r\ngboolean result;\r\ntvbuff_t *next_tvb;\r\nguint esl_length = tvb_captured_length(tvb);\r\nif ( in_heur )\r\nreturn FALSE;\r\nin_heur = TRUE;\r\n{\r\nif ( ref_time_frame.fd != NULL && !pinfo->fd->flags.visited && pinfo->num <= ref_time_frame.num )\r\nref_time_frame.fd = NULL;\r\nif ( esl_length < SIZEOF_ESLHEADER )\r\nreturn FALSE;\r\nif ( is_esl_header(tvb, 0) )\r\n{\r\ndissect_esl_header(tvb, pinfo, tree, data);\r\nif ( eth_withoutfcs_handle != NULL )\r\n{\r\nnext_tvb = tvb_new_subset_remaining(tvb, SIZEOF_ESLHEADER);\r\ncall_dissector(eth_withoutfcs_handle, next_tvb, pinfo, tree);\r\n}\r\nmodify_times(tvb, 0, pinfo);\r\nresult = TRUE;\r\n}\r\nelse if ( is_esl_header(tvb, esl_length-SIZEOF_ESLHEADER) )\r\n{\r\nif ( eth_withoutfcs_handle != NULL )\r\n{\r\nnext_tvb = tvb_new_subset_length(tvb, 0, esl_length-SIZEOF_ESLHEADER);\r\ncall_dissector(eth_withoutfcs_handle, next_tvb, pinfo, tree);\r\n}\r\nnext_tvb = tvb_new_subset_length(tvb, esl_length-SIZEOF_ESLHEADER, SIZEOF_ESLHEADER);\r\ndissect_esl_header(next_tvb, pinfo, tree, data);\r\nmodify_times(tvb, esl_length-SIZEOF_ESLHEADER, pinfo);\r\nresult = TRUE;\r\n}\r\nelse\r\n{\r\nresult = FALSE;\r\n}\r\n}\r\nin_heur = FALSE;\r\nreturn result;\r\n}\r\nvoid\r\nproto_register_esl(void) {\r\nstatic hf_register_info hf[] = {\r\n{ &hf_esl_port,\r\n{ "Port", "esl.port",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esl_crcerror,\r\n{ "Crc Error", "esl.crcerror",\r\nFT_BOOLEAN, 16, TFS(&flags_yes_no), esl_crcError_bitmask,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esl_alignerror,\r\n{ "Alignment Error", "esl.alignerror",\r\nFT_BOOLEAN, 16, TFS(&flags_yes_no), esl_alignError_bitmask,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esl_timestamp,\r\n{ "timestamp", "esl.timestamp",\r\nFT_UINT64, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_esl,\r\n};\r\nmodule_t *esl_module;\r\nproto_esl = proto_register_protocol("EtherCAT Switch Link",\r\n"ESL","esl");\r\nesl_module = prefs_register_protocol(proto_esl, proto_reg_handoff_esl);\r\nprefs_register_obsolete_preference(esl_module, "enable");\r\nproto_register_field_array(proto_esl,hf,array_length(hf));\r\nproto_register_subtree_array(ett,array_length(ett));\r\nregister_dissector("esl", dissect_esl_header, proto_esl);\r\n}\r\nvoid\r\nproto_reg_handoff_esl(void) {\r\nstatic gboolean initialized = FALSE;\r\nif (!initialized) {\r\neth_withoutfcs_handle = find_dissector_add_dependency("eth_withoutfcs", proto_esl);\r\nheur_dissector_add("eth", dissect_esl_heur, "EtherCAT over Ethernet", "esl_eth", proto_esl, HEURISTIC_DISABLE);\r\ninitialized = TRUE;\r\n}\r\n}
