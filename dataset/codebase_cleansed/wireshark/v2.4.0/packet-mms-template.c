static int\r\ndissect_mms(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data _U_)\r\n{\r\nint offset = 0;\r\nint old_offset;\r\nproto_item *item=NULL;\r\nproto_tree *tree=NULL;\r\nasn1_ctx_t asn1_ctx;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\r\nif(parent_tree){\r\nitem = proto_tree_add_item(parent_tree, proto_mms, tvb, 0, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_mms);\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MMS");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0){\r\nold_offset=offset;\r\noffset=dissect_mms_MMSpdu(FALSE, tvb, offset, &asn1_ctx , tree, -1);\r\nif(offset == old_offset){\r\nproto_tree_add_expert(tree, pinfo, &ei_mms_zero_pdu, tvb, offset, -1);\r\nbreak;\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_mms(void) {\r\nstatic hf_register_info hf[] =\r\n{\r\n#include "packet-mms-hfarr.c"\r\n};\r\nstatic gint *ett[] = {\r\n&ett_mms,\r\n#include "packet-mms-ettarr.c"\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_mms_mal_timeofday_encoding, { "mms.malformed.timeofday_encoding", PI_MALFORMED, PI_WARN, "BER Error: malformed TimeOfDay encoding", EXPFILL }},\r\n{ &ei_mms_mal_utctime_encoding, { "mms.malformed.utctime", PI_MALFORMED, PI_WARN, "BER Error: malformed IEC61850 UTCTime encoding", EXPFILL }},\r\n{ &ei_mms_zero_pdu, { "mms.zero_pdu", PI_PROTOCOL, PI_ERROR, "Internal error, zero-byte MMS PDU", EXPFILL }},\r\n};\r\nexpert_module_t* expert_mms;\r\nproto_mms = proto_register_protocol(PNAME, PSNAME, PFNAME);\r\nregister_dissector("mms", dissect_mms, proto_mms);\r\nproto_register_field_array(proto_mms, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_mms = expert_register_protocol(proto_mms);\r\nexpert_register_field_array(expert_mms, ei, array_length(ei));\r\n}\r\nstatic gboolean\r\ndissect_mms_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data _U_)\r\n{\r\nint offset = 0;\r\nguint32 length = 0 ;\r\nguint32 oct;\r\ngint idx = 0 ;\r\ngint8 tmp_class;\r\ngboolean tmp_pc;\r\ngint32 tmp_tag;\r\nif (!tvb_bytes_exist(tvb, 0, 2))\r\nreturn FALSE;\r\noffset = get_ber_identifier(tvb, offset, &tmp_class, &tmp_pc, &tmp_tag);\r\nif (tmp_class!=BER_CLASS_CON)\r\nreturn FALSE;\r\ntry_val_to_str_idx(tmp_tag, mms_MMSpdu_vals, &idx);\r\nif (idx == -1) {\r\nreturn FALSE;\r\n}\r\noct = tvb_get_guint8(tvb, offset)& 0x7F;\r\nif (oct==0)\r\nreturn FALSE;\r\noffset = get_ber_length(tvb, offset, &length, NULL);\r\nif (!tvb_bytes_exist(tvb, offset, length))\r\nreturn FALSE;\r\ndissect_mms(tvb, pinfo, parent_tree, data);\r\nreturn TRUE;\r\n}\r\nvoid proto_reg_handoff_mms(void) {\r\nregister_ber_oid_dissector("1.0.9506.2.3", dissect_mms, proto_mms,"MMS");\r\nregister_ber_oid_dissector("1.0.9506.2.1", dissect_mms, proto_mms,"mms-abstract-syntax-version1(1)");\r\nheur_dissector_add("cotp", dissect_mms_heur, "MMS over COTP", "mms_cotp", proto_mms, HEURISTIC_ENABLE);\r\nheur_dissector_add("cotp_is", dissect_mms_heur, "MMS over COTP (inactive subset)", "mms_cotp_is", proto_mms, HEURISTIC_ENABLE);\r\n}
