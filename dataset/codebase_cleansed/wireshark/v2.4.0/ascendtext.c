static gint64 ascend_seek(wtap *wth, int *err, gchar **err_info)\r\n{\r\nint byte;\r\ngint64 date_off = -1, cur_off, packet_off;\r\nsize_t string_level[ASCEND_MAGIC_STRINGS];\r\nguint string_i = 0, type = 0;\r\nstatic const gchar ascend_date[] = ASCEND_DATE;\r\nsize_t ascend_date_len = sizeof ascend_date - 1;\r\nsize_t ascend_date_string_level;\r\nguint excessive_read_count = 262144;\r\nmemset(&string_level, 0, sizeof(string_level));\r\nascend_date_string_level = 0;\r\nwhile (((byte = file_getc(wth->fh)) != EOF)) {\r\nexcessive_read_count--;\r\nif (!excessive_read_count) {\r\n*err = 0;\r\nreturn -1;\r\n}\r\nfor (string_i = 0; string_i < ASCEND_MAGIC_STRINGS; string_i++) {\r\nconst gchar *strptr = ascend_magic[string_i].strptr;\r\nsize_t len = ascend_magic[string_i].strlength;\r\nif (byte == *(strptr + string_level[string_i])) {\r\nstring_level[string_i]++;\r\nif (string_level[string_i] >= len) {\r\ncur_off = file_tell(wth->fh);\r\nif (cur_off == -1) {\r\n*err = file_error(wth->fh, err_info);\r\nreturn -1;\r\n}\r\nif (date_off == -1) {\r\npacket_off = cur_off - len;\r\n} else {\r\npacket_off = date_off;\r\n}\r\ntype = ascend_magic[string_i].type;\r\ngoto found;\r\n}\r\n} else {\r\nstring_level[string_i] = 0;\r\n}\r\n}\r\nif (byte == *(ascend_date + ascend_date_string_level)) {\r\nascend_date_string_level++;\r\nif (ascend_date_string_level >= ascend_date_len) {\r\ncur_off = file_tell(wth->fh);\r\nif (cur_off == -1) {\r\n*err = file_error(wth->fh, err_info);\r\nreturn -1;\r\n}\r\ndate_off = cur_off - ascend_date_len;\r\nascend_date_string_level = 0;\r\n}\r\n} else {\r\nascend_date_string_level = 0;\r\n}\r\n}\r\n*err = file_error(wth->fh, err_info);\r\nreturn -1;\r\nfound:\r\nif (file_seek(wth->fh, packet_off, SEEK_SET, err) == -1)\r\nreturn -1;\r\nwth->phdr.pseudo_header.ascend.type = type;\r\nreturn packet_off;\r\n}\r\nwtap_open_return_val ascend_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\ngint64 offset;\r\nguint8 buf[ASCEND_MAX_PKT_LEN];\r\nascend_state_t parser_state;\r\nws_statb64 statbuf;\r\nascend_t *ascend;\r\nwth->priv = NULL;\r\noffset = ascend_seek(wth, err, err_info);\r\nif (offset == -1) {\r\nif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (run_ascend_parser(wth->fh, &wth->phdr, buf, &parser_state, err,\r\nerr_info) != 0 && *err != 0) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (parser_state.caplen == 0) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_ASCEND;\r\nswitch(wth->phdr.pseudo_header.ascend.type) {\r\ncase ASCEND_PFX_ISDN_X:\r\ncase ASCEND_PFX_ISDN_R:\r\nwth->file_encap = WTAP_ENCAP_ISDN;\r\nbreak;\r\ncase ASCEND_PFX_ETHER:\r\nwth->file_encap = WTAP_ENCAP_ETHERNET;\r\nbreak;\r\ndefault:\r\nwth->file_encap = WTAP_ENCAP_ASCEND;\r\n}\r\nwth->snapshot_length = ASCEND_MAX_PKT_LEN;\r\nwth->subtype_read = ascend_read;\r\nwth->subtype_seek_read = ascend_seek_read;\r\nascend = (ascend_t *)g_malloc(sizeof(ascend_t));\r\nwth->priv = (void *)ascend;\r\nascend->next_packet_seek_start = offset;\r\nif (wtap_fstat(wth, &statbuf, err) == -1) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nascend->inittime = statbuf.st_ctime;\r\nascend->adjusted = FALSE;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean\r\nparse_ascend(ascend_t *ascend, FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\r\nguint length, int *err, gchar **err_info)\r\n{\r\nascend_state_t parser_state;\r\nint retval;\r\nws_buffer_assure_space(buf, length);\r\nretval = run_ascend_parser(fh, phdr, ws_buffer_start_ptr(buf), &parser_state,\r\nerr, err_info);\r\nif (parser_state.first_hexbyte) {\r\nascend->next_packet_seek_start = parser_state.first_hexbyte;\r\n} else {\r\nascend->next_packet_seek_start = file_tell(fh);\r\nretval = 0;\r\n}\r\nif (parser_state.caplen) {\r\nif (! ascend->adjusted) {\r\nascend->adjusted = TRUE;\r\nif (parser_state.saw_timestamp) {\r\nascend->inittime = parser_state.timestamp;\r\n}\r\nif (ascend->inittime > parser_state.secs)\r\nascend->inittime -= parser_state.secs;\r\n}\r\nphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\nphdr->ts.secs = parser_state.secs + ascend->inittime;\r\nphdr->ts.nsecs = parser_state.usecs * 1000;\r\nphdr->caplen = parser_state.caplen;\r\nphdr->len = parser_state.wirelen;\r\nswitch(phdr->pseudo_header.ascend.type) {\r\ncase ASCEND_PFX_ISDN_X:\r\nphdr->pseudo_header.isdn.uton = TRUE;\r\nphdr->pseudo_header.isdn.channel = 0;\r\nbreak;\r\ncase ASCEND_PFX_ISDN_R:\r\nphdr->pseudo_header.isdn.uton = FALSE;\r\nphdr->pseudo_header.isdn.channel = 0;\r\nbreak;\r\ncase ASCEND_PFX_ETHER:\r\nphdr->pseudo_header.eth.fcs_len = 0;\r\nbreak;\r\n}\r\nreturn TRUE;\r\n}\r\nif (retval) {\r\nif (*err == 0) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup((parser_state.ascend_parse_error != NULL) ? parser_state.ascend_parse_error : "parse error");\r\n}\r\n} else {\r\nif (*err == 0) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("no data returned by parse");\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean ascend_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\nascend_t *ascend = (ascend_t *)wth->priv;\r\ngint64 offset;\r\nif (file_seek(wth->fh, ascend->next_packet_seek_start,\r\nSEEK_SET, err) == -1)\r\nreturn FALSE;\r\noffset = ascend_seek(wth, err, err_info);\r\nif (offset == -1)\r\nreturn FALSE;\r\nif (!parse_ascend(ascend, wth->fh, &wth->phdr, wth->frame_buffer,\r\nwth->snapshot_length, err, err_info))\r\nreturn FALSE;\r\n*data_offset = offset;\r\nreturn TRUE;\r\n}\r\nstatic gboolean ascend_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf,\r\nint *err, gchar **err_info)\r\n{\r\nascend_t *ascend = (ascend_t *)wth->priv;\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (!parse_ascend(ascend, wth->random_fh, phdr, buf,\r\nwth->snapshot_length, err, err_info))\r\nreturn FALSE;\r\nreturn TRUE;\r\n}
