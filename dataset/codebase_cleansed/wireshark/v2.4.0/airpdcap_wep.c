int AirPDcapWepDecrypt(\r\nconst guchar *seed,\r\nconst size_t seed_len,\r\nguchar *cypher_text,\r\nconst size_t data_len)\r\n{\r\nguint32 i, j, k, crc;\r\nguint8 S[256];\r\nguint8 icv[4];\r\nsize_t buflen;\r\nfor (i = 0; i < 256; i++)\r\nS[i] = (guint8)i;\r\nfor (j = i = 0; i < 256; i++) {\r\nj = (j + S[i] + seed[i % seed_len]) & 0xff;\r\nS_SWAP(i, j);\r\n}\r\ncrc = ~(guint32)0;\r\nbuflen = data_len;\r\nfor (i = j = k = 0; k < buflen; k++) {\r\ni = (i + 1) & 0xff;\r\nj = (j + S[i]) & 0xff;\r\nS_SWAP(i, j);\r\n*cypher_text ^= S[(S[i] + S[j]) & 0xff];\r\ncrc = crc32_ccitt_table_lookup((crc ^ *cypher_text) & 0xff) ^ (crc >> 8);\r\ncypher_text++;\r\n}\r\ncrc = ~crc;\r\nicv[0] = (guint8)crc;\r\nicv[1] = (guint8)(crc >> 8);\r\nicv[2] = (guint8)(crc >> 16);\r\nicv[3] = (guint8)(crc >> 24);\r\nfor (k = 0; k < 4; k++) {\r\ni = (i + 1) & 0xff;\r\nj = (j + S[i]) & 0xff;\r\nS_SWAP(i, j);\r\nif ((icv[k] ^ S[(S[i] + S[j]) & 0xff]) != *cypher_text++) {\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}
