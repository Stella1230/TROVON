static int\r\ndissect_zbee_zcl_illum_meas(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, void* data _U_)\r\n{\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_zcl_illum_meas_attr_data(proto_tree *tree, tvbuff_t *tvb, guint *offset, guint16 attr_id, guint data_type)\r\n{\r\nswitch ( attr_id ) {\r\ncase ZBEE_ZCL_ATTR_ID_ILLUM_MEAS_MEASURED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_illum_meas_measured_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_ILLUM_MEAS_MIN_MEASURED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_illum_meas_min_measured_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_ILLUM_MEAS_MAX_MEASURED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_illum_meas_max_measured_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_ILLUM_MEAS_TOLERANCE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_illum_meas_tolerance, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_ILLUM_MEAS_LIGHT_SENSOR_TYPE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_illum_meas_sensor_type, tvb, *offset, 1, ENC_LITTLE_ENDIAN);\r\n*offset += 1;\r\nbreak;\r\ndefault:\r\ndissect_zcl_attr_data(tvb, tree, offset, data_type);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndecode_illum_meas_value(gchar *s, guint16 value)\r\n{\r\nif (value == ZBEE_ZCL_ATTR_ID_ILLUM_MEAS_TOO_LOW_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Value too low to be measured");\r\nelse if (value == ZBEE_ZCL_ATTR_ID_ILLUM_MEAS_INVALID_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Invalid value");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d (=%f [lx])", value, pow(10,value/10000.0)-1);\r\nreturn;\r\n}\r\nstatic void\r\ndecode_illum_meas_min_value(gchar *s, guint16 value)\r\n{\r\nif ( (value < ZBEE_ZCL_ATTR_ID_ILLUM_MEAS_MIN_LO_VALUE) ||\r\n(value > ZBEE_ZCL_ATTR_ID_ILLUM_MEAS_MIN_HI_VALUE) )\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Out of range");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d (=%f [lx])", value, pow(10,value/10000.0)-1);\r\nreturn;\r\n}\r\nstatic void\r\ndecode_illum_meas_max_value(gchar *s, guint16 value)\r\n{\r\nif ( (value < ZBEE_ZCL_ATTR_ID_ILLUM_MEAS_MAX_LO_VALUE) ||\r\n(value > ZBEE_ZCL_ATTR_ID_ILLUM_MEAS_MAX_HI_VALUE) )\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Out of range");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d (=%f [lx])", value, pow(10,value/10000.0)-1);\r\nreturn;\r\n}\r\nstatic void\r\ndecode_illum_meas_tolerance(gchar *s, guint16 value)\r\n{\r\nif (value > ZBEE_ZCL_ATTR_ID_ILLUM_MEAS_TOL_HI_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Out of range");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d", value);\r\nreturn;\r\n}\r\nvoid\r\nproto_register_zbee_zcl_illum_meas(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_zbee_zcl_illum_meas_attr_id,\r\n{ "Attribute", "zbee_zcl_meas_sensing.illummeas.attr_id", FT_UINT16, BASE_HEX, VALS(zbee_zcl_illum_meas_attr_names),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_illum_meas_measured_value,\r\n{ "Measured Value", "zbee_zcl_meas_sensing.illummeas.attr.value", FT_UINT16, BASE_CUSTOM, CF_FUNC(decode_illum_meas_value),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_illum_meas_min_measured_value,\r\n{ "Min Measured Value", "zbee_zcl_meas_sensing.illummeas.attr.value.min", FT_UINT16, BASE_CUSTOM, CF_FUNC(decode_illum_meas_min_value),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_illum_meas_max_measured_value,\r\n{ "Max Measured Value", "zbee_zcl_meas_sensing.illummeas.attr.value.max", FT_UINT16, BASE_CUSTOM, CF_FUNC(decode_illum_meas_max_value),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_illum_meas_tolerance,\r\n{ "Tolerance", "zbee_zcl_meas_sensing.illummeas.attr.tolerance", FT_UINT16, BASE_CUSTOM, CF_FUNC(decode_illum_meas_tolerance),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_illum_meas_sensor_type,\r\n{ "Sensor Type", "zbee_zcl_meas_sensing.illummeas.attr.sensor_type", FT_UINT8, BASE_HEX, VALS(zbee_zcl_illum_meas_sensor_type_names),\r\n0x00, NULL, HFILL } }\r\n};\r\nproto_zbee_zcl_illum_meas = proto_register_protocol("ZigBee ZCL Illuminance Meas.", "ZCL Illuminance Meas.", ZBEE_PROTOABBREV_ZCL_ILLUMMEAS);\r\nproto_register_field_array(proto_zbee_zcl_illum_meas, hf, array_length(hf));\r\nregister_dissector(ZBEE_PROTOABBREV_ZCL_ILLUMMEAS, dissect_zbee_zcl_illum_meas, proto_zbee_zcl_illum_meas);\r\n}\r\nvoid\r\nproto_reg_handoff_zbee_zcl_illum_meas(void)\r\n{\r\nzbee_zcl_init_cluster( proto_zbee_zcl_illum_meas,\r\nett_zbee_zcl_illum_meas,\r\nZBEE_ZCL_CID_ILLUMINANCE_MEASUREMENT,\r\nhf_zbee_zcl_illum_meas_attr_id,\r\n-1, -1,\r\n(zbee_zcl_fn_attr_data)dissect_zcl_illum_meas_attr_data\r\n);\r\n}\r\nstatic int\r\ndissect_zbee_zcl_illum_level_sen(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, void* data _U_)\r\n{\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_zcl_illum_level_sen_attr_data(proto_tree *tree, tvbuff_t *tvb, guint *offset, guint16 attr_id, guint data_type)\r\n{\r\nswitch ( attr_id ) {\r\ncase ZBEE_ZCL_ATTR_ID_ILLUM_LEVEL_SEN_LEVEL_STATUS:\r\nproto_tree_add_item(tree, hf_zbee_zcl_illum_level_sen_level_status, tvb, *offset, 1, ENC_LITTLE_ENDIAN);\r\n*offset += 1;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_ILLUM_LEVEL_SEN_LIGHT_SENSOR_TYPE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_illum_level_sen_light_sensor_type, tvb, *offset, 1, ENC_LITTLE_ENDIAN);\r\n*offset += 1;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_ILLUM_LEVEL_SEN_ILLUM_TARGET_LEVEL:\r\nproto_tree_add_item(tree, hf_zbee_zcl_illum_level_sen_illum_target_level, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ndefault:\r\ndissect_zcl_attr_data(tvb, tree, offset, data_type);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndecode_illum_level_sen_target_level(gchar *s, guint16 value)\r\n{\r\nif (value == ZBEE_ZCL_ATTR_ID_ILLUM_LEVEL_SEN_TOO_LOW_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Value too low to be measured");\r\nelse if (value == ZBEE_ZCL_ATTR_ID_ILLUM_LEVEL_SEN_INVALID_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Invalid value");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d (=%f [lx])", value, pow(10,value/10000.0)-1);\r\nreturn;\r\n}\r\nvoid\r\nproto_register_zbee_zcl_illum_level_sen(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_zbee_zcl_illum_level_sen_attr_id,\r\n{ "Attribute", "zbee_zcl_meas_sensing.illumlevelsen.attr_id", FT_UINT16, BASE_HEX, VALS(zbee_zcl_illum_level_sen_attr_names),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_illum_level_sen_level_status,\r\n{ "Level Status", "zbee_zcl_meas_sensing.illumlevelsen.attr.level_status", FT_UINT8, BASE_HEX, VALS(zbee_zcl_illum_level_sen_level_status_names),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_illum_level_sen_light_sensor_type,\r\n{ "Light Sensor Type", "zbee_zcl_meas_sensing.illumlevelsen.attr.light_sensor_type", FT_UINT8, BASE_HEX, VALS(zbee_zcl_illum_level_sen_sensor_type_names),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_illum_level_sen_illum_target_level,\r\n{ "Target Level", "zbee_zcl_meas_sensing.illumlevelsen.attr.target_level", FT_UINT16, BASE_CUSTOM, CF_FUNC(decode_illum_level_sen_target_level),\r\n0x00, NULL, HFILL } }\r\n};\r\nproto_zbee_zcl_illum_level_sen = proto_register_protocol("ZigBee ZCL Illuminance Level Sensing", "ZCL Illuminance Level Sensing", ZBEE_PROTOABBREV_ZCL_ILLUMLEVELSEN);\r\nproto_register_field_array(proto_zbee_zcl_illum_level_sen, hf, array_length(hf));\r\nregister_dissector(ZBEE_PROTOABBREV_ZCL_ILLUMLEVELSEN, dissect_zbee_zcl_illum_level_sen, proto_zbee_zcl_illum_level_sen);\r\n}\r\nvoid\r\nproto_reg_handoff_zbee_zcl_illum_level_sen(void)\r\n{\r\nzbee_zcl_init_cluster( proto_zbee_zcl_illum_level_sen,\r\nett_zbee_zcl_illum_level_sen,\r\nZBEE_ZCL_CID_ILLUMINANCE_LEVEL_SENSING,\r\nhf_zbee_zcl_illum_level_sen_attr_id,\r\n-1, -1,\r\n(zbee_zcl_fn_attr_data)dissect_zcl_illum_level_sen_attr_data\r\n);\r\n}\r\nstatic int\r\ndissect_zbee_zcl_temp_meas(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, void* data _U_)\r\n{\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_zcl_temp_meas_attr_data(proto_tree *tree, tvbuff_t *tvb, guint *offset, guint16 attr_id, guint data_type)\r\n{\r\nswitch ( attr_id ) {\r\ncase ZBEE_ZCL_ATTR_ID_TEMP_MEAS_MEASURED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_temp_meas_measured_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_TEMP_MEAS_MIN_MEASURED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_temp_meas_min_measured_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_TEMP_MEAS_MAX_MEASURED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_temp_meas_max_measured_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_TEMP_MEAS_TOLERANCE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_temp_meas_tolerance, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ndefault:\r\ndissect_zcl_attr_data(tvb, tree, offset, data_type);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndecode_temp_meas_value(gchar *s, gint16 value)\r\n{\r\nif (value == (gint16)ZBEE_ZCL_ATTR_ID_TEMP_MEAS_INVALID_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Invalid value");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%.2f [" UTF8_DEGREE_SIGN "C]", value/100.0);\r\nreturn;\r\n}\r\nstatic void\r\ndecode_temp_meas_min_value(gchar *s, gint16 value)\r\n{\r\nif ( (value < (gint16)ZBEE_ZCL_ATTR_ID_TEMP_MEAS_MIN_LO_VALUE) ||\r\n(value > (gint16)ZBEE_ZCL_ATTR_ID_TEMP_MEAS_MIN_HI_VALUE) )\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Out of range");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%.2f [" UTF8_DEGREE_SIGN "C]", value/100.0);\r\nreturn;\r\n}\r\nstatic void\r\ndecode_temp_meas_max_value(gchar *s, gint16 value)\r\n{\r\nif (value < (gint16)ZBEE_ZCL_ATTR_ID_TEMP_MEAS_MAX_LO_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Out of range");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%.2f [" UTF8_DEGREE_SIGN "C]", value/100.0);\r\nreturn;\r\n}\r\nstatic void\r\ndecode_temp_meas_tolerance(gchar *s, guint16 value)\r\n{\r\nif (value > ZBEE_ZCL_ATTR_ID_TEMP_MEAS_TOL_HI_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Out of range");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d.%d [" UTF8_DEGREE_SIGN "C]", value/100, value%100);\r\nreturn;\r\n}\r\nvoid\r\nproto_register_zbee_zcl_temp_meas(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_zbee_zcl_temp_meas_attr_id,\r\n{ "Attribute", "zbee_zcl_meas_sensing.tempmeas.attr_idd", FT_UINT16, BASE_HEX, VALS(zbee_zcl_temp_meas_attr_names),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_temp_meas_measured_value,\r\n{ "Measured Value", "zbee_zcl_meas_sensing.tempmeas.attr.value", FT_INT16, BASE_CUSTOM, CF_FUNC(decode_temp_meas_value),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_temp_meas_min_measured_value,\r\n{ "Min Measured Value", "zbee_zcl_meas_sensing.tempmeas.attr.value.min", FT_INT16, BASE_CUSTOM, CF_FUNC(decode_temp_meas_min_value),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_temp_meas_max_measured_value,\r\n{ "Max Measured Value", "zbee_zcl_meas_sensing.tempmeas.attr.value.max", FT_INT16, BASE_CUSTOM, CF_FUNC(decode_temp_meas_max_value),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_temp_meas_tolerance,\r\n{ "Tolerance", "zbee_zcl_meas_sensing.tempmeas.attr.tolerance", FT_UINT16, BASE_CUSTOM, CF_FUNC(decode_temp_meas_tolerance),\r\n0x00, NULL, HFILL } }\r\n};\r\nproto_zbee_zcl_temp_meas = proto_register_protocol("ZigBee ZCL Temperature Meas.", "ZCL Temperature Meas.", ZBEE_PROTOABBREV_ZCL_TEMPMEAS);\r\nproto_register_field_array(proto_zbee_zcl_temp_meas, hf, array_length(hf));\r\nregister_dissector(ZBEE_PROTOABBREV_ZCL_TEMPMEAS, dissect_zbee_zcl_temp_meas, proto_zbee_zcl_temp_meas);\r\n}\r\nvoid\r\nproto_reg_handoff_zbee_zcl_temp_meas(void)\r\n{\r\nzbee_zcl_init_cluster( proto_zbee_zcl_temp_meas,\r\nett_zbee_zcl_temp_meas,\r\nZBEE_ZCL_CID_TEMPERATURE_MEASUREMENT,\r\nhf_zbee_zcl_temp_meas_attr_id,\r\n-1, -1,\r\n(zbee_zcl_fn_attr_data)dissect_zcl_temp_meas_attr_data\r\n);\r\n}\r\nstatic int\r\ndissect_zbee_zcl_press_meas(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, void* data _U_)\r\n{\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_zcl_press_meas_attr_data(proto_tree *tree, tvbuff_t *tvb, guint *offset, guint16 attr_id, guint data_type)\r\n{\r\nswitch ( attr_id ) {\r\ncase ZBEE_ZCL_ATTR_ID_PRESS_MEAS_MEASURED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_press_meas_measured_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_PRESS_MEAS_MIN_MEASURED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_press_meas_min_measured_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_PRESS_MEAS_MAX_MEASURED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_press_meas_max_measured_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_PRESS_MEAS_TOLERANCE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_press_meas_tolerance, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_PRESS_MEAS_SCALED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_press_meas_scaled_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_PRESS_MEAS_MIN_SCALED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_press_meas_min_scaled_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_PRESS_MEAS_MAX_SCALED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_press_meas_max_scaled_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_PRESS_MEAS_SCALED_TOLERANCE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_press_meas_scaled_tolerance, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_PRESS_MEAS_SCALE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_press_meas_scale, tvb, *offset, 1, ENC_LITTLE_ENDIAN);\r\n*offset += 1;\r\nbreak;\r\ndefault:\r\ndissect_zcl_attr_data(tvb, tree, offset, data_type);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndecode_press_meas_value(gchar *s, gint16 value)\r\n{\r\nif (value == (gint16)ZBEE_ZCL_ATTR_ID_PRESS_MEAS_INVALID_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Invalid value");\r\nif (value < (gint16)ZBEE_ZCL_ATTR_ID_PRESS_MEAS_MIN_LO_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Out of range");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d.%d [kPa]", value/10, value%10);\r\nreturn;\r\n}\r\nstatic void\r\ndecode_press_meas_min_value(gchar *s, gint16 value)\r\n{\r\nif (value > (gint16)ZBEE_ZCL_ATTR_ID_PRESS_MEAS_MIN_HI_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Out of range");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d.%d [kPa]", value/10, value%10);\r\nreturn;\r\n}\r\nstatic void\r\ndecode_press_meas_max_value(gchar *s, gint16 value)\r\n{\r\nif (value < (gint16)ZBEE_ZCL_ATTR_ID_PRESS_MEAS_MAX_LO_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Out of range");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d.%d [kPa]", value/10, value%10);\r\nreturn;\r\n}\r\nstatic void\r\ndecode_press_meas_tolerance(gchar *s, guint16 value)\r\n{\r\nif (value > (guint16)ZBEE_ZCL_ATTR_ID_PRESS_MEAS_TOL_HI_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Out of range");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d.%d [kPa]", value/10, value%10);\r\nreturn;\r\n}\r\nvoid\r\nproto_register_zbee_zcl_press_meas(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_zbee_zcl_press_meas_attr_id,\r\n{ "Attribute", "zbee_zcl_meas_sensing.pressmeas.attr_id", FT_UINT16, BASE_HEX, VALS(zbee_zcl_press_meas_attr_names),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_press_meas_measured_value,\r\n{ "Measured Value", "zbee_zcl_meas_sensing.pressmeas.attr.value", FT_INT16, BASE_CUSTOM, CF_FUNC(decode_press_meas_value),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_press_meas_min_measured_value,\r\n{ "Min Measured Value", "zbee_zcl_meas_sensing.pressmeas.attr.value.min", FT_INT16, BASE_CUSTOM, CF_FUNC(decode_press_meas_min_value),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_press_meas_max_measured_value,\r\n{ "Max Measured Value", "zbee_zcl_meas_sensing.pressmeas.attr.value.max", FT_INT16, BASE_CUSTOM, CF_FUNC(decode_press_meas_max_value),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_press_meas_tolerance,\r\n{ "Tolerance", "zbee_zcl_meas_sensing.pressmeas.attr.tolerance", FT_UINT16, BASE_CUSTOM, CF_FUNC(decode_press_meas_tolerance),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_press_meas_scaled_value,\r\n{ "Scaled Value", "zbee_zcl_meas_sensing.pressmeas.attr.scaled_value", FT_INT16, BASE_DEC, NULL,\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_press_meas_min_scaled_value,\r\n{ "Min Scaled Value", "zbee_zcl_meas_sensing.pressmeas.attr.scaled_value.min", FT_INT16, BASE_DEC, NULL,\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_press_meas_max_scaled_value,\r\n{ "Max Scaled Value", "zbee_zcl_meas_sensing.pressmeas.attr.scaled_value.max", FT_INT16, BASE_DEC, NULL,\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_press_meas_scaled_tolerance,\r\n{ "Scaled Tolerance", "zbee_zcl_meas_sensing.pressmeas.attr.scaled_tolerance", FT_UINT16, BASE_DEC, NULL,\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_press_meas_scale,\r\n{ "Scale", "zbee_zcl_meas_sensing.pressmeas.attr.scale", FT_UINT8, BASE_DEC, NULL,\r\n0x00, NULL, HFILL } }\r\n};\r\nproto_zbee_zcl_press_meas = proto_register_protocol("ZigBee ZCL Pressure Meas.", "ZCL Pressure Meas.", ZBEE_PROTOABBREV_ZCL_PRESSMEAS);\r\nproto_register_field_array(proto_zbee_zcl_press_meas, hf, array_length(hf));\r\nregister_dissector(ZBEE_PROTOABBREV_ZCL_PRESSMEAS, dissect_zbee_zcl_press_meas, proto_zbee_zcl_press_meas);\r\n}\r\nvoid\r\nproto_reg_handoff_zbee_zcl_press_meas(void)\r\n{\r\nzbee_zcl_init_cluster( proto_zbee_zcl_press_meas,\r\nett_zbee_zcl_press_meas,\r\nZBEE_ZCL_CID_PRESSURE_MEASUREMENT,\r\nhf_zbee_zcl_press_meas_attr_id,\r\n-1, -1,\r\n(zbee_zcl_fn_attr_data)dissect_zcl_press_meas_attr_data\r\n);\r\n}\r\nstatic int\r\ndissect_zbee_zcl_flow_meas(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, void* data _U_)\r\n{\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_zcl_flow_meas_attr_data(proto_tree *tree, tvbuff_t *tvb, guint *offset, guint16 attr_id, guint data_type)\r\n{\r\nswitch ( attr_id ) {\r\ncase ZBEE_ZCL_ATTR_ID_FLOW_MEAS_MEASURED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_flow_meas_measured_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_FLOW_MEAS_MIN_MEASURED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_flow_meas_min_measured_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_FLOW_MEAS_MAX_MEASURED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_flow_meas_max_measured_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_FLOW_MEAS_TOLERANCE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_flow_meas_tolerance, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ndefault:\r\ndissect_zcl_attr_data(tvb, tree, offset, data_type);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndecode_flow_meas_value(gchar *s, guint16 value)\r\n{\r\nif (value == ZBEE_ZCL_ATTR_ID_FLOW_MEAS_TOO_LOW_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Value too low to be measured");\r\nelse if (value == ZBEE_ZCL_ATTR_ID_FLOW_MEAS_INVALID_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Invalid value");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d (=%f [m^3/h])", value, value/10.0);\r\nreturn;\r\n}\r\nstatic void\r\ndecode_flow_meas_min_value(gchar *s, guint16 value)\r\n{\r\nif ( (value > ZBEE_ZCL_ATTR_ID_FLOW_MEAS_MIN_LO_VALUE) ||\r\n(value > ZBEE_ZCL_ATTR_ID_FLOW_MEAS_MIN_HI_VALUE) )\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Out of range");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d (=%f [m^3/h])", value, value/10.0);\r\nreturn;\r\n}\r\nstatic void\r\ndecode_flow_meas_max_value(gchar *s, guint16 value)\r\n{\r\nif ( (value < ZBEE_ZCL_ATTR_ID_FLOW_MEAS_MAX_LO_VALUE) ||\r\n(value > ZBEE_ZCL_ATTR_ID_FLOW_MEAS_MAX_HI_VALUE) )\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Out of range");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d (=%f [m^3/h])", value, value/10.0);\r\nreturn;\r\n}\r\nstatic void\r\ndecode_flow_meas_tolerance(gchar *s, guint16 value)\r\n{\r\nif (value > ZBEE_ZCL_ATTR_ID_FLOW_MEAS_TOL_HI_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Out of range");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d", value);\r\nreturn;\r\n}\r\nvoid\r\nproto_register_zbee_zcl_flow_meas(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_zbee_zcl_flow_meas_attr_id,\r\n{ "Attribute", "zbee_zcl_meas_sensing.flowmeas.attr_id", FT_UINT16, BASE_HEX, VALS(zbee_zcl_flow_meas_attr_names),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_flow_meas_measured_value,\r\n{ "Measured Value", "zbee_zcl_meas_sensing.flowmeas.attr.value", FT_UINT16, BASE_CUSTOM, CF_FUNC(decode_flow_meas_value),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_flow_meas_min_measured_value,\r\n{ "Min Measured Value", "zbee_zcl_meas_sensing.flowmeas.attr.value.min", FT_UINT16, BASE_CUSTOM, CF_FUNC(decode_flow_meas_min_value),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_flow_meas_max_measured_value,\r\n{ "Max Measured Value", "zbee_zcl_meas_sensing.flowmeas.attr.value.max", FT_UINT16, BASE_CUSTOM, CF_FUNC(decode_flow_meas_max_value),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_flow_meas_tolerance,\r\n{ "Tolerance", "zbee_zcl_meas_sensing.flowmeas.attr.tolerance", FT_UINT16, BASE_CUSTOM, CF_FUNC(decode_flow_meas_tolerance),\r\n0x00, NULL, HFILL } }\r\n};\r\nproto_zbee_zcl_flow_meas = proto_register_protocol("ZigBee ZCL Flow Meas.", "ZCL Flow Meas.", ZBEE_PROTOABBREV_ZCL_FLOWMEAS);\r\nproto_register_field_array(proto_zbee_zcl_flow_meas, hf, array_length(hf));\r\nregister_dissector(ZBEE_PROTOABBREV_ZCL_FLOWMEAS, dissect_zbee_zcl_flow_meas, proto_zbee_zcl_flow_meas);\r\n}\r\nvoid\r\nproto_reg_handoff_zbee_zcl_flow_meas(void)\r\n{\r\nzbee_zcl_init_cluster( proto_zbee_zcl_flow_meas,\r\nett_zbee_zcl_flow_meas,\r\nZBEE_ZCL_CID_FLOW_MEASUREMENT,\r\nhf_zbee_zcl_flow_meas_attr_id,\r\n-1, -1,\r\n(zbee_zcl_fn_attr_data)dissect_zcl_flow_meas_attr_data\r\n);\r\n}\r\nstatic int\r\ndissect_zbee_zcl_relhum_meas(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, void* data _U_)\r\n{\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_zcl_relhum_meas_attr_data(proto_tree *tree, tvbuff_t *tvb, guint *offset, guint16 attr_id, guint data_type)\r\n{\r\nswitch ( attr_id ) {\r\ncase ZBEE_ZCL_ATTR_ID_RELHUM_MEAS_MEASURED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_relhum_meas_measured_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_RELHUM_MEAS_MIN_MEASURED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_relhum_meas_min_measured_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_RELHUM_MEAS_MAX_MEASURED_VALUE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_relhum_meas_max_measured_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_RELHUM_MEAS_TOLERANCE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_relhum_meas_tolerance, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ndefault:\r\ndissect_zcl_attr_data(tvb, tree, offset, data_type);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndecode_relhum_meas_value(gchar *s, guint16 value)\r\n{\r\nif (value == ZBEE_ZCL_ATTR_ID_RELHUM_MEAS_INVALID_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Invalid value");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d.%02d [%%]", value/100, value%100);\r\nreturn;\r\n}\r\nstatic void\r\ndecode_relhum_meas_min_value(gchar *s, guint16 value)\r\n{\r\nif (value > ZBEE_ZCL_ATTR_ID_RELHUM_MEAS_MIN_HI_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Out of range");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d.%02d [%%]", value/100, value%100);\r\nreturn;\r\n}\r\nstatic void\r\ndecode_relhum_meas_max_value(gchar *s, guint16 value)\r\n{\r\nif (value > ZBEE_ZCL_ATTR_ID_RELHUM_MEAS_MAX_HI_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Out of range");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d.%02d [%%]", value/100, value%100);\r\nreturn;\r\n}\r\nstatic void\r\ndecode_relhum_meas_tolerance(gchar *s, guint16 value)\r\n{\r\nif (value > ZBEE_ZCL_ATTR_ID_RELHUM_MEAS_TOL_HI_VALUE)\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Out of range");\r\nelse\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d.%02d [%%]", value/100, value%100);\r\nreturn;\r\n}\r\nvoid\r\nproto_register_zbee_zcl_relhum_meas(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_zbee_zcl_relhum_meas_attr_id,\r\n{ "Attribute", "zbee_zcl_meas_sensing.relhummeas.attr_id", FT_UINT16, BASE_HEX, VALS(zbee_zcl_relhum_meas_attr_names),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_relhum_meas_measured_value,\r\n{ "Measured Value", "zbee_zcl_meas_sensing.relhummeas.attr.value", FT_UINT16, BASE_CUSTOM, CF_FUNC(decode_relhum_meas_value),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_relhum_meas_min_measured_value,\r\n{ "Min Measured Value", "zbee_zcl_meas_sensing.relhummeas.attr.value.min", FT_UINT16, BASE_CUSTOM, CF_FUNC(decode_relhum_meas_min_value),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_relhum_meas_max_measured_value,\r\n{ "Max Measured Value", "zbee_zcl_meas_sensing.relhummeas.attr.value.max", FT_UINT16, BASE_CUSTOM, CF_FUNC(decode_relhum_meas_max_value),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_relhum_meas_tolerance,\r\n{ "Tolerance", "zbee_zcl_meas_sensing.relhummeas.attr.tolerance", FT_UINT16, BASE_CUSTOM, CF_FUNC(decode_relhum_meas_tolerance),\r\n0x00, NULL, HFILL } }\r\n};\r\nproto_zbee_zcl_relhum_meas = proto_register_protocol("ZigBee ZCL Rel. Humidity Meas.", "ZCL Relative Humidity Meas.", ZBEE_PROTOABBREV_ZCL_RELHUMMEAS);\r\nproto_register_field_array(proto_zbee_zcl_relhum_meas, hf, array_length(hf));\r\nregister_dissector(ZBEE_PROTOABBREV_ZCL_RELHUMMEAS, dissect_zbee_zcl_relhum_meas, proto_zbee_zcl_relhum_meas);\r\n}\r\nvoid\r\nproto_reg_handoff_zbee_zcl_relhum_meas(void)\r\n{\r\nzbee_zcl_init_cluster( proto_zbee_zcl_relhum_meas,\r\nett_zbee_zcl_relhum_meas,\r\nZBEE_ZCL_CID_REL_HUMIDITY_MEASUREMENT,\r\nhf_zbee_zcl_relhum_meas_attr_id,\r\n-1, -1,\r\n(zbee_zcl_fn_attr_data)dissect_zcl_relhum_meas_attr_data\r\n);\r\n}\r\nstatic int\r\ndissect_zbee_zcl_occ_sen(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, void* data _U_)\r\n{\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_zcl_occ_sen_attr_data(proto_tree *tree, tvbuff_t *tvb, guint *offset, guint16 attr_id, guint data_type)\r\n{\r\nstatic const int *occupancy[] = {\r\n&hf_zbee_zcl_occ_sen_occupancy,\r\nNULL\r\n};\r\nswitch ( attr_id ) {\r\ncase ZBEE_ZCL_ATTR_ID_OCC_SEN_OCCUPANCY:\r\nproto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_occ_sen_occupancy, ett_zbee_zcl_occ, occupancy, ENC_LITTLE_ENDIAN);\r\n*offset += 1;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_OCC_SEN_OCC_SENSOR_TYPE:\r\nproto_tree_add_item(tree, hf_zbee_zcl_occ_sen_occ_sensor_type, tvb, *offset, 1, ENC_LITTLE_ENDIAN);\r\n*offset += 1;\r\nbreak;\r\ncase ZBEE_ZCL_ATTR_ID_OCC_SEN_PIR_OCC_TO_UNOCC_DELAY:\r\ncase ZBEE_ZCL_ATTR_ID_OCC_SEN_PIR_UNOCC_TO_OCC_DELAY:\r\ncase ZBEE_ZCL_ATTR_ID_OCC_SEN_PIR_UNOCC_TO_OCC_THOLD:\r\ncase ZBEE_ZCL_ATTR_ID_OCC_SEN_USONIC_OCC_TO_UNOCC_DELAY:\r\ncase ZBEE_ZCL_ATTR_ID_OCC_SEN_USONIC_UNOCC_TO_OCC_DELAY:\r\ncase ZBEE_ZCL_ATTR_ID_OCC_SEN_USONIC_UNOCC_TO_OCC_THOLD:\r\ndefault:\r\ndissect_zcl_attr_data(tvb, tree, offset, data_type);\r\nbreak;\r\n}\r\n}\r\nvoid\r\nproto_register_zbee_zcl_occ_sen(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_zbee_zcl_occ_sen_attr_id,\r\n{ "Attribute", "zbee_zcl_meas_sensing.occsen.attr_id", FT_UINT16, BASE_HEX, VALS(zbee_zcl_occ_sen_attr_names),\r\n0x00, NULL, HFILL } },\r\n{ &hf_zbee_zcl_occ_sen_occupancy,\r\n{ "Occupancy", "zbee_zcl_meas_sensing.occsen.attr.occupancy", FT_UINT8, BASE_HEX, VALS(zbee_zcl_occ_sen_sensed_occ_names),\r\nZBEE_ZCL_OCCUPANCY_SENSED_OCC, NULL, HFILL } },\r\n{ &hf_zbee_zcl_occ_sen_occ_sensor_type,\r\n{ "Occupancy Sensor Type", "zbee_zcl_meas_sensing.occsen.attr.occ_sensor_type", FT_UINT8, BASE_HEX, VALS(zbee_zcl_occ_sen_sensor_type_names),\r\n0x00, NULL, HFILL } }\r\n};\r\nproto_zbee_zcl_occ_sen = proto_register_protocol("ZigBee ZCL Occupancy Sensing", "ZCL Occupancy Sensing", ZBEE_PROTOABBREV_ZCL_OCCSEN);\r\nproto_register_field_array(proto_zbee_zcl_occ_sen, hf, array_length(hf));\r\nregister_dissector(ZBEE_PROTOABBREV_ZCL_OCCSEN, dissect_zbee_zcl_occ_sen, proto_zbee_zcl_occ_sen);\r\n}\r\nvoid\r\nproto_reg_handoff_zbee_zcl_occ_sen(void)\r\n{\r\nzbee_zcl_init_cluster( proto_zbee_zcl_occ_sen,\r\nett_zbee_zcl_occ_sen,\r\nZBEE_ZCL_CID_ILLUMINANCE_LEVEL_SENSING,\r\nhf_zbee_zcl_occ_sen_attr_id,\r\n-1, -1,\r\n(zbee_zcl_fn_attr_data)dissect_zcl_occ_sen_attr_data\r\n);\r\n}
