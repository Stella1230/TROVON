static int\r\ndissect_ossp_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ngint offset = 0;\r\nconst gchar *str;\r\nproto_item *oui_item, *ossp_item;\r\nproto_tree *ossp_tree;\r\ntvbuff_t *ossp_tvb;\r\nconst guint8 itu_oui[] = {ITU_OUI_0, ITU_OUI_1, ITU_OUI_2};\r\nstr = tvb_get_manuf_name(tvb, offset);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "OSSP");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "OUI: %s", str);\r\nossp_item = proto_tree_add_protocol_format(tree, proto_ossp, tvb, 0, -1,\r\n"Organization Specific Slow Protocol");\r\nossp_tree = proto_item_add_subtree(ossp_item, ett_ossppdu);\r\noui_item = proto_tree_add_item(ossp_tree, hf_ossp_oui,\r\ntvb, offset, OUI_SIZE, ENC_NA);\r\nproto_item_append_text(oui_item, " (%s)", str);\r\noffset += 3;\r\nossp_tvb = tvb_new_subset_remaining(tvb, offset);\r\nif (tvb_memeql(tvb, 0, itu_oui, OUI_SIZE) == 0)\r\n{\r\ndissect_itu_ossp(ossp_tvb, pinfo, ossp_tree);\r\n}\r\n#if 0\r\nelse if (tvb_memeql(tvb, 0, xxx_oui, OUI_SIZE) == 0)\r\n{\r\ndissect_xxx_ossp(ossp_tvb, pinfo, ossp_tree);\r\n}\r\nelse if (tvb_memeql(tvb, 0, yyy_oui, OUI_SIZE) == 0)\r\n{\r\ndissect_yyy_ossp(ossp_tvb, pinfo, ossp_tree);\r\n}\r\n#endif\r\nelse\r\n{\r\nproto_item_append_text(oui_item, " (Unknown OSSP organization)");\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_itu_ossp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint16 subtype;\r\nproto_tree *itu_ossp_tree, *ti;\r\nsubtype = tvb_get_ntohs(tvb, 0);\r\nti = proto_tree_add_item(tree, hf_itu_subtype, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nitu_ossp_tree = proto_item_add_subtree(ti, ett_itu_ossp);\r\nswitch (subtype)\r\n{\r\ncase ESMC_ITU_SUBTYPE:\r\ndissect_esmc_pdu(tvb, pinfo, itu_ossp_tree);\r\nbreak;\r\n#if 0\r\ncase XXXX_ITU_SUBTYPE:\r\ndissect_xxxx_pdu(tvb, pinfo, itu_ossp_tree);\r\nbreak;\r\n#endif\r\ndefault:\r\nproto_item_append_text(itu_ossp_tree, " (Unknown)");\r\n}\r\n}\r\nstatic void\r\ndissect_esmc_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *treex)\r\n{\r\ngint offset = 2;\r\ngboolean event_flag;\r\ngboolean malformed = FALSE;\r\ngint ql = -1;\r\ngboolean timestamp_valid_flag = FALSE;\r\ngint32 timestamp = -1;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ESMC");\r\nproto_item_append_text(treex, ": ESMC");\r\n{\r\nproto_tree *tree_a;\r\ntree_a = proto_item_add_subtree(treex, ett_esmc);\r\n{\r\nproto_item *item_b;\r\nitem_b = proto_tree_add_item(tree_a, hf_esmc_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif ((tvb_get_guint8(tvb, offset) >> 4) != ESMC_VERSION_1)\r\n{\r\nmalformed = TRUE;\r\nexpert_add_info_format(pinfo, item_b, &ei_esmc_version_compliance, "Version must be 0x%.1x claim compliance with Version 1 of this protocol", ESMC_VERSION_1);\r\n}\r\n}\r\n{\r\nevent_flag = ((tvb_get_guint8(tvb, offset) & 0x08) != 0);\r\nproto_tree_add_item(tree_a, hf_esmc_event_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nif (pref_decode_esmc_timestamp)\r\n{\r\ntimestamp_valid_flag = ((tvb_get_guint8(tvb, offset) & 0x04) != 0);\r\nproto_tree_add_item(tree_a, hf_esmc_timestamp_valid_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\n{\r\nproto_item *item_b;\r\nguint32 reserved;\r\nreserved = tvb_get_ntohl(tvb, offset)\r\n& (pref_decode_esmc_timestamp ? 0x3ffffff : 0x7ffffff);\r\nitem_b = proto_tree_add_uint_format_value(tree_a, hf_esmc_reserved_32, tvb, offset, 4\r\n, reserved, "0x%.7x", reserved);\r\nif (reserved != 0x0)\r\n{\r\nmalformed = TRUE;\r\nexpert_add_info_format(pinfo, item_b, &ei_esmc_reserved_not_zero, "Reserved bits must be set to all zero on transmitter");\r\n}\r\noffset += 4;\r\n}\r\nproto_item_append_text(treex, ", Event:%s", event_flag ?\r\n"Time-critical" : "Information");\r\n{\r\nproto_item *item_b;\r\nguint8 type;\r\nitem_b = proto_tree_add_item(tree_a, hf_esmc_tlv, tvb, offset, 4, ENC_NA);\r\n{\r\nproto_tree *tree_b;\r\ntree_b = proto_item_add_subtree(item_b, ett_esmc);\r\n{\r\nproto_item *item_c;\r\nguint16 length;\r\nguint8 unused;\r\ntype = tvb_get_guint8(tvb, offset);\r\nitem_c = proto_tree_add_item(tree_b, hf_esmc_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif (type != ESMC_QL_TLV_TYPE)\r\n{\r\nmalformed = TRUE;\r\nexpert_add_info_format(pinfo, item_c, &ei_esmc_tlv_type_ql_type_not_first, "TLV Type must be == 0x%.2x (QL) because QL TLV must be first in the ESMC PDU", ESMC_QL_TLV_TYPE);\r\nexpert_add_info(pinfo, item_c, &ei_esmc_tlv_type_decoded_as_ql_type);\r\n}\r\noffset += 1;\r\nlength = tvb_get_ntohs(tvb, offset);\r\nitem_c = proto_tree_add_item(tree_b, hf_esmc_tlv_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nif (length != ESMC_QL_TLV_LENGTH)\r\n{\r\nmalformed = TRUE;\r\nexpert_add_info_format(pinfo, item_c, &ei_esmc_tlv_length_bad, "QL TLV Length must be == 0x%.4x", ESMC_QL_TLV_LENGTH);\r\nexpert_add_info_format(pinfo, item_c, &ei_esmc_tlv_type_decoded_as_ql_type, "Let's decode this TLV as if Length has valid value");\r\n}\r\noffset += 2;\r\nunused = tvb_get_guint8(tvb, offset);\r\nql = unused & 0x0f;\r\nunused &= 0xf0;\r\nitem_c = proto_tree_add_item(tree_b, hf_esmc_tlv_ql_unused, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif (unused != 0x00)\r\n{\r\nmalformed = TRUE;\r\nexpert_add_info(pinfo, item_c, &ei_esmc_tlv_ql_unused_not_zero);\r\n}\r\nif (NULL != try_val_to_str(ql, esmc_quality_level_opt_1_vals))\r\n{\r\nproto_tree_add_item(tree_b, hf_esmc_quality_level_opt_1, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nitem_c = proto_tree_add_item(tree_b, hf_esmc_quality_level_invalid, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nexpert_add_info(pinfo, item_c, &ei_esmc_quality_level_invalid);\r\n}\r\noffset += 1;\r\n}\r\n}\r\nproto_item_append_text(item_b, ", %s"\r\n, val_to_str(ql, esmc_quality_level_opt_1_vals_short, "QL-INV%d"));\r\n}\r\nproto_item_append_text(treex, ", %s"\r\n, val_to_str(ql, esmc_quality_level_opt_1_vals_short, "QL-INV%d"));\r\nif (pref_decode_esmc_timestamp)\r\n{\r\nguint8 type;\r\ntype = tvb_get_guint8(tvb, offset);\r\nif (timestamp_valid_flag || type == ESMC_TIMESTAMP_TLV_TYPE)\r\n{\r\nproto_item *item_b;\r\nitem_b = proto_tree_add_item(tree_a, hf_esmc_tlv, tvb, offset, 8, ENC_NA);\r\n{\r\nproto_tree *tree_b;\r\ntree_b = proto_item_add_subtree(item_b, ett_esmc);\r\n{\r\nproto_item *item_c;\r\nguint16 length;\r\nguint8 reserved;\r\nitem_c = proto_tree_add_item(tree_b, hf_esmc_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif (type != ESMC_TIMESTAMP_TLV_TYPE)\r\n{\r\nmalformed = TRUE;\r\nexpert_add_info_format(pinfo, item_c, &ei_esmc_tlv_type_not_timestamp, "TLV Type must be == 0x%.2x (Timestamp) because Timestamp Valid Flag is set", ESMC_TIMESTAMP_TLV_TYPE);\r\nexpert_add_info(pinfo, item_c, &ei_esmc_tlv_type_decoded_as_timestamp);\r\n}\r\noffset += 1;\r\nlength = tvb_get_ntohs(tvb, offset);\r\nitem_c = proto_tree_add_item(tree_b, hf_esmc_tlv_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nif (length != ESMC_TIMESTAMP_TLV_LENGTH)\r\n{\r\nmalformed = TRUE;\r\nexpert_add_info_format(pinfo, item_c, &ei_esmc_tlv_length_bad, "Timestamp TLV Length must be == 0x%.4x", ESMC_TIMESTAMP_TLV_LENGTH);\r\nexpert_add_info_format(pinfo, item_c, &ei_esmc_tlv_type_decoded_as_timestamp, "Let's decode this TLV as if Length has valid value");\r\n}\r\noffset += 2;\r\ntimestamp = (gint32)tvb_get_ntohl(tvb, offset);\r\nitem_c = proto_tree_add_item(tree_b, hf_esmc_timestamp, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nif (!timestamp_valid_flag) proto_item_append_text(item_c, " [invalid]");\r\noffset += 4;\r\nreserved = tvb_get_guint8(tvb, offset);\r\nitem_c = proto_tree_add_item(tree_b, hf_esmc_tlv_ts_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif (reserved != 0x0)\r\n{\r\nexpert_add_info(pinfo, item_c, &ei_esmc_reserved_not_zero);\r\n}\r\noffset += 1;\r\n}\r\n}\r\nproto_item_append_text(item_b, ", Timestamp: %d ns", timestamp);\r\nif (!timestamp_valid_flag) proto_item_append_text(item_b, " [invalid]");\r\n}\r\n}\r\nif (timestamp_valid_flag)\r\n{\r\nproto_item_append_text(treex, ", Timestamp:%d", timestamp);\r\n}\r\n}\r\n{\r\ngint padding_size;\r\npadding_size = tvb_captured_length_remaining(tvb, offset);\r\nif (0 != padding_size)\r\n{\r\nproto_tree* tree_a;\r\ntree_a = proto_item_add_subtree(treex, ett_esmc);\r\n{\r\nproto_item* item_b;\r\ntvbuff_t* tvb_next;\r\ntvb_next = tvb_new_subset_remaining(tvb, offset);\r\nitem_b = proto_tree_add_item(tree_a, hf_esmc_padding, tvb_next, 0, -1, ENC_NA);\r\nproto_item_append_text(item_b, ", %d %s%s", padding_size\r\n, "octet", plurality(padding_size,"","s"));\r\n{\r\nproto_tree* tree_b;\r\ntree_b = proto_item_add_subtree(item_b, ett_esmc);\r\ncall_data_dissector(tvb_next, pinfo, tree_b);\r\n}\r\n}\r\n}\r\n}\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Event:%s", event_flag ?\r\n"Time-critical" : "Information");\r\nif (ql >= 0)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %s"\r\n, val_to_str(ql, esmc_quality_level_opt_1_vals_short, "QL-INVALID-%d"));\r\n}\r\nif (timestamp_valid_flag)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", TS:%d", timestamp);\r\n}\r\nif (malformed)\r\n{\r\ncol_append_str(pinfo->cinfo, COL_INFO, ", Malformed PDU");\r\n}\r\n}\r\nvoid\r\nproto_register_ossp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ossp_oui,\r\n{ "OUI", "ossp.oui",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"IEEE assigned Organizationally Unique Identifier", HFILL }},\r\n{ &hf_itu_subtype,\r\n{ "ITU-T OSSP Subtype", "ossp.itu.subtype",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\n"Subtype assigned by the ITU-T", HFILL }},\r\n{ &hf_esmc_version,\r\n{ "Version", "ossp.esmc.version",\r\nFT_UINT8, BASE_HEX, NULL, 0xf0,\r\n"This field indicates the version of ITU-T SG15 Q13 OSSP frame format", HFILL }},\r\n{ &hf_esmc_event_flag,\r\n{ "Event Flag", "ossp.esmc.event_flag",\r\nFT_UINT8, BASE_HEX, VALS(esmc_event_flag_vals), 0x08,\r\n"This bit distinguishes the critical, time sensitive behaviour of the"\r\n" ESMC Event PDU from the ESMC Information PDU", HFILL }},\r\n{ &hf_esmc_timestamp_valid_flag,\r\n{ "Timestamp Valid Flag", "ossp.esmc.timestamp_valid_flag",\r\nFT_UINT8, BASE_HEX, VALS(esmc_timestamp_valid_flag_vals), 0x04,\r\n"Indicates validity (i.e. presence) of the Timestamp TLV", HFILL }},\r\n{ &hf_esmc_reserved_32,\r\n{ "Reserved", "ossp.esmc.reserved",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Reserved. Set to all zero at the transmitter and ignored by the receiver", HFILL }},\r\n{ &hf_esmc_tlv,\r\n{ "ESMC TLV", "ossp.esmc.tlv",\r\nFT_NONE, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_esmc_tlv_type,\r\n{ "TLV Type", "ossp.esmc.tlv_type",\r\nFT_UINT8, BASE_HEX, VALS(esmc_tlv_type_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_esmc_tlv_length,\r\n{ "TLV Length", "ossp.esmc.tlv_length",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_esmc_tlv_ql_unused,\r\n{ "Unused", "ossp.esmc.tlv_ql_unused",\r\nFT_UINT8, BASE_HEX, NULL, 0xf0,\r\n"This field is not used in QL TLV", HFILL }},\r\n{ &hf_esmc_quality_level_opt_1,\r\n{ "SSM Code", "ossp.esmc.ql",\r\nFT_UINT8, BASE_HEX, VALS(esmc_quality_level_opt_1_vals), 0x0f,\r\n"Quality Level information", HFILL }},\r\n#if 0\r\n{ &hf_esmc_quality_level_opt_2,\r\n{ "SSM Code", "ossp.esmc.ql",\r\nFT_UINT8, BASE_HEX, VALS(esmc_quality_level_opt_2_vals), 0x0f,\r\n"Quality Level information", HFILL }},\r\n#endif\r\n{ &hf_esmc_quality_level_invalid,\r\n{ "SSM Code", "ossp.esmc.ql",\r\nFT_UINT8, BASE_HEX, VALS(esmc_quality_level_invalid_vals), 0x0f,\r\n"Quality Level information", HFILL }},\r\n{ &hf_esmc_timestamp,\r\n{ "Timestamp (ns)", "ossp.esmc.timestamp",\r\nFT_INT32, BASE_DEC, NULL, 0,\r\n"Timestamp according to the \"whole nanoseconds\" part of the IEEE 1588 originTimestamp", HFILL }},\r\n{ &hf_esmc_tlv_ts_reserved,\r\n{ "Reserved", "ossp.esmc.tlv_ts_reserved",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Reserved. Set to all zero at the transmitter and ignored by the receiver", HFILL }},\r\n{ &hf_esmc_padding,\r\n{ "Padding", "ossp.esmc.padding",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"This field contains necessary padding to achieve the minimum frame size of 64 bytes at least", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_esmc,\r\n&ett_ossppdu,\r\n&ett_itu_ossp\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_esmc_version_compliance, { "ossp.esmc.version.compliance", PI_MALFORMED, PI_ERROR, "Version must claim compliance with Version 1 of this protocol", EXPFILL }},\r\n{ &ei_esmc_tlv_type_ql_type_not_first, { "ossp.esmc.tlv_type.ql_type_not_first", PI_MALFORMED, PI_ERROR, "TLV Type must be QL because QL TLV must be first in the ESMC PDU", EXPFILL }},\r\n{ &ei_esmc_tlv_type_decoded_as_ql_type, { "ossp.esmc.tlv_type.decoded_as_ql_type", PI_UNDECODED, PI_NOTE, "Let's decode as if this is QL TLV", EXPFILL }},\r\n{ &ei_esmc_tlv_length_bad, { "ossp.esmc.tlv_length.bad", PI_MALFORMED, PI_ERROR, "QL TLV Length must be X", EXPFILL }},\r\n{ &ei_esmc_tlv_ql_unused_not_zero, { "ossp.esmc.tlv_ql_unused.not_zero", PI_MALFORMED, PI_WARN, "Unused bits of TLV must be all zeroes", EXPFILL }},\r\n{ &ei_esmc_quality_level_invalid, { "ossp.esmc.ql.invalid", PI_UNDECODED, PI_WARN, "Invalid SSM message, unknown QL code", EXPFILL }},\r\n{ &ei_esmc_tlv_type_not_timestamp, { "ossp.esmc.tlv_type.not_timestamp", PI_MALFORMED, PI_ERROR, "TLV Type must be == Timestamp because Timestamp Valid Flag is set", EXPFILL }},\r\n{ &ei_esmc_tlv_type_decoded_as_timestamp, { "ossp.esmc.tlv_type.decoded_as_timestamp", PI_UNDECODED, PI_NOTE, "Let's decode as if this is Timestamp TLV", EXPFILL }},\r\n{ &ei_esmc_reserved_not_zero, { "ossp.esmc.reserved_bits_must_be_set_to_all_zero", PI_PROTOCOL, PI_WARN, "Reserved bits must be set to all zero", EXPFILL }},\r\n};\r\nexpert_module_t* expert_ossp;\r\nproto_ossp = proto_register_protocol("OSSP", "Organization Specific Slow Protocol", "ossp");\r\nproto_register_field_array(proto_ossp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_ossp = expert_register_protocol(proto_ossp);\r\nexpert_register_field_array(expert_ossp, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_ossp(void)\r\n{\r\ndissector_handle_t ossp_handle;\r\nossp_handle = create_dissector_handle(dissect_ossp_pdu, proto_ossp);\r\ndissector_add_uint("slow.subtype", OSSP_SUBTYPE, ossp_handle);\r\n}
