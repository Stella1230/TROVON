static void\r\ndrda_init(void)\r\n{\r\niPreviousFrameNumber = 0;\r\n}\r\nstatic int\r\ndissect_drda(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ngint offset = 0;\r\nguint16 iCommand;\r\nguint16 iLength;\r\nguint16 iCommandEnd = 0;\r\nguint16 iParameterCP;\r\ngint iLengthParam;\r\nstatic const int * format_flags[] = {\r\n&hf_drda_ddm_fmt_reserved,\r\n&hf_drda_ddm_fmt_chained,\r\n&hf_drda_ddm_fmt_errcont,\r\n&hf_drda_ddm_fmt_samecorr,\r\n&hf_drda_ddm_fmt_dsstyp,\r\nNULL\r\n};\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "DRDA");\r\nif (iPreviousFrameNumber != pinfo->num)\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nelse\r\ncol_append_str(pinfo->cinfo, COL_INFO, " | ");\r\niPreviousFrameNumber = pinfo->num;\r\nwhile ((guint) (offset + 10) <= tvb_reported_length(tvb))\r\n{\r\niCommand = tvb_get_ntohs(tvb, offset + 8);\r\niLength = tvb_get_ntohs(tvb, offset + 0);\r\nif (iLength < 10) {\r\nexpert_add_info_format(pinfo, NULL, &ei_drda_opcode_invalid_length, "Invalid length detected (%u): should be at least 10 bytes long", iLength);\r\nbreak;\r\n}\r\niCommandEnd += iLength;\r\nif (offset > 0)\r\ncol_append_str(pinfo->cinfo, COL_INFO, " | ");\r\ncol_append_str(pinfo->cinfo, COL_INFO, val_to_str_ext(iCommand, &drda_opcode_abbr_ext, "Unknown (0x%02x)"));\r\nif (tree)\r\n{\r\nproto_tree *drda_tree;\r\nproto_tree *drdaroot_tree;\r\nproto_tree *drda_tree_sub;\r\nproto_item *ti;\r\nti = proto_tree_add_item(tree, proto_drda, tvb, offset, -1, ENC_NA);\r\nproto_item_append_text(ti, " (%s)", val_to_str_ext(iCommand, &drda_opcode_vals_ext, "Unknown (0x%02x)"));\r\ndrdaroot_tree = proto_item_add_subtree(ti, ett_drda);\r\ndrda_tree = proto_tree_add_subtree(drdaroot_tree, tvb, offset, 10, ett_drda_ddm, &ti, DRDA_TEXT_DDM);\r\nproto_item_append_text(ti, " (%s)", val_to_str_ext(iCommand, &drda_opcode_abbr_ext, "Unknown (0x%02x)"));\r\nproto_tree_add_item(drda_tree, hf_drda_ddm_length, tvb, offset + 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(drda_tree, hf_drda_ddm_magic, tvb, offset + 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(drda_tree, tvb, offset + 3, hf_drda_ddm_format, ett_drda_ddm_format, format_flags, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(drda_tree, hf_drda_ddm_rc, tvb, offset + 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(drda_tree, hf_drda_ddm_length2, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(drda_tree, hf_drda_ddm_codepoint, tvb, offset + 8, 2, ENC_BIG_ENDIAN);\r\nfor (offset += 10; offset < iCommandEnd; )\r\n{\r\nif (tvb_reported_length_remaining(tvb, offset) >= 2)\r\n{\r\niLengthParam = tvb_get_ntohs(tvb, offset + 0);\r\nif (iLengthParam == 0 || iLengthParam == 1) iLengthParam = iLength - 10;\r\nif (tvb_reported_length_remaining(tvb, offset) >= iLengthParam)\r\n{\r\niParameterCP = tvb_get_ntohs(tvb, offset + 2);\r\ndrda_tree_sub = proto_tree_add_subtree(drdaroot_tree, tvb, offset, iLengthParam,\r\nett_drda_param, &ti, DRDA_TEXT_PARAM);\r\nproto_item_append_text(ti, " (%s)", val_to_str_ext(iParameterCP, &drda_opcode_vals_ext, "Unknown (0x%02x)"));\r\nproto_tree_add_item(drda_tree_sub, hf_drda_param_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(drda_tree_sub, hf_drda_param_codepoint, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(drda_tree_sub, hf_drda_param_data, tvb, offset + 4, iLengthParam - 4, ENC_UTF_8|ENC_NA);\r\nproto_tree_add_item(drda_tree_sub, hf_drda_param_data_ebcdic, tvb, offset + 4, iLengthParam - 4, ENC_EBCDIC|ENC_NA);\r\nif (iCommand == DRDA_CP_SQLSTT)\r\n{\r\ntvbuff_t* next_tvb = NULL;\r\nnext_tvb = tvb_new_subset_length(tvb, offset + 4, iLengthParam - 4);\r\nadd_new_data_source(pinfo, next_tvb, "SQL statement");\r\nproto_tree_add_item(drdaroot_tree, hf_drda_sqlstatement, next_tvb, 0, iLengthParam - 5, ENC_UTF_8|ENC_NA);\r\nproto_tree_add_item(drdaroot_tree, hf_drda_sqlstatement_ebcdic, next_tvb, 0, iLengthParam - 4, ENC_EBCDIC|ENC_NA);\r\n}\r\n}\r\noffset += iLengthParam;\r\n}\r\nelse\r\n{\r\nbreak;\r\n}\r\n}\r\n}\r\nelse\r\n{\r\noffset += iLength;\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic guint\r\nget_drda_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nreturn (tvb_get_ntohs(tvb, offset));\r\n}\r\nstatic int\r\ndissect_drda_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, tree, drda_desegment, 10, get_drda_pdu_len, dissect_drda, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\ndissect_drda_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nconversation_t * conversation;\r\nif (tvb_captured_length(tvb) >= 10)\r\n{\r\nguint16 cOuterLength, cInnerLength;\r\ncOuterLength = tvb_get_ntohs(tvb, 0);\r\ncInnerLength = tvb_get_ntohs(tvb, 6);\r\nif ((tvb_get_guint8(tvb, 2) == DRDA_MAGIC) && ((cOuterLength - cInnerLength) == 6))\r\n{\r\nconversation = find_or_create_conversation(pinfo);\r\nconversation_set_dissector(conversation, drda_tcp_handle);\r\ndissect_drda(tvb, pinfo, tree, data);\r\nreturn TRUE;\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nvoid\r\nproto_register_drda(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_drda_ddm_length,\r\n{ "Length", "drda.ddm.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"DDM length", HFILL }},\r\n{ &hf_drda_ddm_magic,\r\n{ "Magic", "drda.ddm.ddmid",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\n"DDM magic", HFILL }},\r\n{ &hf_drda_ddm_format,\r\n{ "Format", "drda.ddm.format",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\n"DDM format", HFILL }},\r\n{ &hf_drda_ddm_fmt_reserved,\r\n{ "Reserved", "drda.ddm.fmt.bit0",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), DRDA_DSSFMT_RESERVED,\r\n"DSSFMT reserved", HFILL }},\r\n{ &hf_drda_ddm_fmt_chained,\r\n{ "Chained", "drda.ddm.fmt.bit1",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), DRDA_DSSFMT_CHAINED,\r\n"DSSFMT chained", HFILL }},\r\n{ &hf_drda_ddm_fmt_errcont,\r\n{ "Continue", "drda.ddm.fmt.bit2",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), DRDA_DSSFMT_CONTINUE,\r\n"DSSFMT continue on error", HFILL }},\r\n{ &hf_drda_ddm_fmt_samecorr,\r\n{ "Same correlation", "drda.ddm.fmt.bit3",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), DRDA_DSSFMT_SAME_CORR,\r\n"DSSFMT same correlation", HFILL }},\r\n{ &hf_drda_ddm_fmt_dsstyp,\r\n{ "DSS type", "drda.ddm.fmt.dsstyp",\r\nFT_UINT8, BASE_DEC, VALS(drda_dsstyp_abbr), 0x0F,\r\n"DSSFMT type", HFILL }},\r\n{ &hf_drda_ddm_rc,\r\n{ "CorrelId", "drda.ddm.rqscrr",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"DDM correlation identifier", HFILL }},\r\n{ &hf_drda_ddm_length2,\r\n{ "Length2", "drda.ddm.length2",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"DDM length2", HFILL }},\r\n{ &hf_drda_ddm_codepoint,\r\n{ "Code point", "drda.ddm.codepoint",\r\nFT_UINT16, BASE_HEX|BASE_EXT_STRING, &drda_opcode_abbr_ext, 0x0,\r\n"DDM code point", HFILL }},\r\n{ &hf_drda_param_length,\r\n{ "Length", "drda.param.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Param length", HFILL }},\r\n{ &hf_drda_param_codepoint,\r\n{ "Code point", "drda.param.codepoint",\r\nFT_UINT16, BASE_HEX|BASE_EXT_STRING, &drda_opcode_abbr_ext, 0x0,\r\n"Param code point", HFILL }},\r\n{ &hf_drda_param_data,\r\n{ "Data (ASCII)", "drda.param.data",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Param data left as ASCII for display", HFILL }},\r\n{ &hf_drda_param_data_ebcdic,\r\n{ "Data (EBCDIC)", "drda.param.data.ebcdic",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Param data converted from EBCDIC to ASCII for display", HFILL }},\r\n{ &hf_drda_sqlstatement,\r\n{ "SQL statement (ASCII)", "drda.sqlstatement",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"SQL statement left as ASCII for display", HFILL }},\r\n{ &hf_drda_sqlstatement_ebcdic,\r\n{ "SQL statement (EBCDIC)", "drda.sqlstatement.ebcdic",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"SQL statement converted from EBCDIC to ASCII for display", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_drda,\r\n&ett_drda_ddm,\r\n&ett_drda_ddm_format,\r\n&ett_drda_param\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_drda_opcode_invalid_length, { "drda.opcode.invalid_length", PI_MALFORMED, PI_ERROR, "Invalid length detected", EXPFILL }},\r\n};\r\nmodule_t *drda_module;\r\nexpert_module_t* expert_drda;\r\nproto_drda = proto_register_protocol("DRDA", "DRDA", "drda");\r\nproto_register_field_array(proto_drda, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_drda = expert_register_protocol(proto_drda);\r\nexpert_register_field_array(expert_drda, ei, array_length(ei));\r\ndrda_module = prefs_register_protocol(proto_drda, NULL);\r\nprefs_register_bool_preference(drda_module, "desegment",\r\n"Reassemble DRDA messages spanning multiple TCP segments",\r\n"Whether the DRDA dissector should reassemble messages spanning"\r\n" multiple TCP segments."\r\n" To use this option, you must also enable"\r\n" \"Allow subdissectors to reassemble TCP streams\""\r\n" in the TCP protocol settings.",\r\n&drda_desegment);\r\nregister_init_routine(&drda_init);\r\n}\r\nvoid\r\nproto_reg_handoff_drda(void)\r\n{\r\nheur_dissector_add("tcp", dissect_drda_heur, "DRDA over TCP", "drda_tcp", proto_drda, HEURISTIC_ENABLE);\r\ndrda_tcp_handle = create_dissector_handle(dissect_drda_tcp, proto_drda);\r\n}
