static gboolean dissect_pktgen(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *ti = NULL;\r\nproto_item *tmp = NULL;\r\nproto_tree *pktgen_tree = NULL;\r\nguint32 offset = 0;\r\nnstime_t tstamp;\r\nguint32 magic;\r\nif (tvb_reported_length(tvb) < 16) {\r\nreturn FALSE;\r\n}\r\nmagic = tvb_get_ntohl(tvb,0);\r\nif (magic != PKTGEN_MAGIC) {\r\nreturn FALSE;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "PKTGEN");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Seq: %u", tvb_get_ntohl(tvb, 4));\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_pktgen, tvb, 0, -1, ENC_NA);\r\npktgen_tree = proto_item_add_subtree(ti, ett_pktgen);\r\nproto_tree_add_item(pktgen_tree, hf_pktgen_magic, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(pktgen_tree, hf_pktgen_seqnum, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\ntstamp.secs = tvb_get_ntohl(tvb, offset);\r\ntmp = proto_tree_add_item(pktgen_tree, hf_pktgen_tvsec, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nPROTO_ITEM_SET_GENERATED(tmp);\r\noffset += 4;\r\ntstamp.nsecs = tvb_get_ntohl(tvb, offset) * 1000;\r\ntmp = proto_tree_add_item(pktgen_tree, hf_pktgen_tvusec, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nPROTO_ITEM_SET_GENERATED(tmp);\r\noffset += 4;\r\nproto_tree_add_time(pktgen_tree, hf_pktgen_timestamp, tvb, offset - 8, 8, &tstamp);\r\nif (tvb_reported_length_remaining(tvb, offset))\r\ncall_data_dissector(tvb_new_subset_remaining(tvb, offset), pinfo,\r\npktgen_tree);\r\n}\r\nreturn TRUE;\r\n}\r\nvoid proto_register_pktgen(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_pktgen_magic,\r\n{\r\n"Magic number", "pktgen.magic",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"The pktgen magic number", HFILL\r\n}\r\n},\r\n{ &hf_pktgen_seqnum,\r\n{\r\n"Sequence number", "pktgen.seqnum",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_pktgen_tvsec,\r\n{\r\n"Timestamp tvsec", "pktgen.tvsec",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Timestamp tvsec part", HFILL\r\n}\r\n},\r\n{ &hf_pktgen_tvusec,\r\n{\r\n"Timestamp tvusec", "pktgen.tvusec",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Timestamp tvusec part", HFILL\r\n}\r\n},\r\n{ &hf_pktgen_timestamp,\r\n{\r\n"Timestamp", "pktgen.timestamp",\r\nFT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0,\r\nNULL, HFILL\r\n}\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_pktgen\r\n};\r\nproto_pktgen = proto_register_protocol("Linux Kernel Packet Generator", "PKTGEN", "pktgen");\r\nproto_register_field_array(proto_pktgen, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid proto_reg_handoff_pktgen(void)\r\n{\r\nheur_dissector_add("udp", dissect_pktgen, "Linux Kernel Packet Generator over UDP", "pktgen_udp", proto_pktgen, HEURISTIC_ENABLE);\r\n}
