void print_mswin(const char *file_name)\r\n{\r\nHDC hDC;\r\nDOCINFO di;\r\nshort int width, height;\r\nhDC = get_printer_dc(&width, &height);\r\nif (!hDC) {\r\nreturn;\r\n}\r\nif (SetAbortProc(hDC, abort_proc) == SP_ERROR) {\r\nMessageBox(NULL, "Error setting up AbortProc",\r\n"Error", MB_APPLMODAL | MB_OK);\r\nreturn;\r\n}\r\ninit_doc_struct(&di, "MyDoc");\r\nStartDoc(hDC, &di);\r\nStartPage(hDC);\r\nprint_file(file_name, hDC, width, height);\r\nEndPage(hDC);\r\nEndDoc(hDC);\r\nDeleteDC(hDC);\r\n}\r\nstatic HDC get_printer_dc(short *width, short *height)\r\n{\r\nPRINTDLG pdlg;\r\nPDEVMODE returnedDevmode;\r\nmemset(&pdlg, 0, sizeof(PRINTDLG));\r\npdlg.lStructSize = sizeof(PRINTDLG);\r\npdlg.Flags =\r\nPD_RETURNDC |\r\nPD_NOPAGENUMS |\r\nPD_NOSELECTION |\r\nPD_USEDEVMODECOPIESANDCOLLATE;\r\nif (PrintDlg(&pdlg)) {\r\nreturnedDevmode = (PDEVMODE)GlobalLock(pdlg.hDevMode);\r\nif (returnedDevmode == NULL) {\r\nif (pdlg.hDevMode)\r\nGlobalFree(pdlg.hDevMode);\r\nif (pdlg.hDevNames)\r\nGlobalFree(pdlg.hDevNames);\r\nreturn NULL;\r\n}\r\nif (returnedDevmode->dmOrientation == DMORIENT_LANDSCAPE) {\r\n*width = returnedDevmode->dmPaperLength;\r\n*height = returnedDevmode->dmPaperWidth;\r\n}\r\nelse {\r\n*width = returnedDevmode->dmPaperWidth;\r\n*height = returnedDevmode->dmPaperLength;\r\n}\r\nGlobalUnlock(pdlg.hDevMode);\r\nif (pdlg.hDevMode)\r\nGlobalFree(pdlg.hDevMode);\r\nif (pdlg.hDevNames)\r\nGlobalFree(pdlg.hDevNames);\r\n}\r\nreturn pdlg.hDC;\r\n}\r\nstatic BOOL CALLBACK abort_proc(HDC hDC, int Error)\r\n{\r\nMSG msg;\r\nwhile (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {\r\nTranslateMessage(&msg);\r\nDispatchMessage(&msg);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic void init_doc_struct(DOCINFO* di, char* docname)\r\n{\r\nmemset(di, 0, sizeof(DOCINFO));\r\ndi->cbSize = sizeof(DOCINFO);\r\ndi->lpszDocName = docname;\r\n}\r\nstatic void print_file(const char *file_name, HDC hdc, int width, int height)\r\n{\r\n#define MAX_BUF_SIZE 1024\r\n#define X_OFFSET 5\r\n#define Y_OFFSET 5\r\nFILE* fh1;\r\nint cnt=0, y_pos = Y_OFFSET, y_cnt = 0;\r\nchar buf[MAX_BUF_SIZE];\r\nchar ch;\r\nTEXTMETRIC tm;\r\nint max_chars_per_line, max_lines_per_page;\r\nSetMapMode(hdc, MM_LOMETRIC);\r\nGetTextMetrics(hdc, &tm);\r\nmax_chars_per_line = MIN(width / (tm.tmMaxCharWidth + 1), MAX_BUF_SIZE);\r\nmax_lines_per_page = height / (tm.tmHeight + 1);\r\nSetMapMode(hdc, MM_TEXT);\r\nGetTextMetrics(hdc, &tm);\r\nfh1 = ws_fopen(file_name, "r");\r\nif (!fh1) {\r\nMessageBox(NULL, "Open failed on input file",\r\n"Error", MB_APPLMODAL | MB_OK);\r\nreturn;\r\n}\r\nwhile (fread(&ch, 1, 1, fh1) != 0) {\r\nif (ch == 0x0c) {\r\nbuf[cnt] = 0;\r\nTextOut(hdc, X_OFFSET,y_pos, buf, (int) strlen(buf));\r\ncnt = 0;\r\nEndPage(hdc);\r\nStartPage(hdc);\r\ny_pos = Y_OFFSET;\r\ny_cnt = 0;\r\ncontinue;\r\n}\r\nif (ch == 0x0a) {\r\nbuf[cnt] = 0;\r\nTextOut(hdc, X_OFFSET,y_pos, buf, (int) strlen(buf));\r\ny_pos += tm.tmHeight;\r\ncnt = 0;\r\nif (++y_cnt == max_lines_per_page) {\r\nEndPage(hdc);\r\nStartPage(hdc);\r\ny_pos = Y_OFFSET;\r\ny_cnt = 0;\r\n}\r\ncontinue;\r\n}\r\nif (cnt == (max_chars_per_line - 1)) {\r\nbuf[cnt] = 0;\r\nTextOut(hdc, X_OFFSET, y_pos, buf, (int) strlen(buf));\r\ny_pos += tm.tmHeight;\r\ncnt = 0;\r\nif (++y_cnt == max_lines_per_page) {\r\nEndPage(hdc);\r\nStartPage(hdc);\r\ny_pos = Y_OFFSET;\r\ny_cnt = 0;\r\n}\r\n}\r\nbuf[cnt++] = ch;\r\n}\r\nif (cnt > 0) {\r\nbuf[cnt] = 0;\r\nTextOut(hdc, 0,y_pos, buf, (int) strlen(buf));\r\n}\r\nfclose(fh1);\r\n}
