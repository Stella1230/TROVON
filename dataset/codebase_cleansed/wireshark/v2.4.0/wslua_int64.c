static gint64 getInt64(lua_State *L, int i)\r\n{\r\ngchar *end = NULL;\r\n(void) end;\r\nswitch (lua_type(L,i))\r\n{\r\ncase LUA_TNUMBER:\r\nreturn wslua_checkgint64(L,i);\r\ncase LUA_TSTRING:\r\nreturn g_ascii_strtoll(luaL_checkstring(L,i),&end,10);\r\ncase LUA_TUSERDATA:\r\nif (isUInt64(L, i)) {\r\nreturn (Int64) toUInt64(L, i);\r\n}\r\ndefault:\r\nreturn checkInt64(L,i);\r\n}\r\n}\r\nvoid Int64_pack(lua_State* L, luaL_Buffer *b, gint idx, gboolean asLittleEndian) {\r\ngint64 value = checkInt64(L,idx);\r\ngint8 buff[sizeof(gint64)];\r\nif (asLittleEndian) {\r\nguint i;\r\nfor (i = 0; i < sizeof(gint64); i++) {\r\nbuff[i] = (value & 0xff);\r\nvalue >>= 8;\r\n}\r\n}\r\nelse {\r\ngint i;\r\nfor (i = sizeof(gint64) - 1; i >= 0; i--) {\r\nbuff[i] = (value & 0xff);\r\nvalue >>= 8;\r\n}\r\n}\r\nluaL_addlstring(b, (char*)buff, sizeof(gint64));\r\n}\r\nWSLUA_METHOD Int64_encode(lua_State* L) {\r\n#define WSLUA_OPTARG_Int64_encode_ENDIAN 2\r\nluaL_Buffer b;\r\ngboolean asLittleEndian = IS_LITTLE_ENDIAN;\r\nif (lua_gettop(L) >= WSLUA_OPTARG_Int64_encode_ENDIAN) {\r\nif (lua_type(L,WSLUA_OPTARG_Int64_encode_ENDIAN) == LUA_TBOOLEAN)\r\nasLittleEndian = lua_toboolean(L,WSLUA_OPTARG_Int64_encode_ENDIAN);\r\n}\r\nluaL_buffinit(L, &b);\r\nInt64_pack(L, &b, 1, asLittleEndian);\r\nluaL_pushresult(&b);\r\nWSLUA_RETURN(1);\r\n}\r\nint Int64_unpack(lua_State* L, const gchar *buff, gboolean asLittleEndian) {\r\ngint64 value = 0;\r\ngint i;\r\nif (asLittleEndian) {\r\nfor (i = sizeof(gint64) - 1; i >= 0; i--) {\r\nvalue <<= 8;\r\nvalue |= (gint64)(guchar)buff[i];\r\n}\r\n}\r\nelse {\r\nfor (i = 0; i < (gint) sizeof(gint64); i++) {\r\nvalue <<= 8;\r\nvalue |= (gint64)(guchar)buff[i];\r\n}\r\n}\r\npushInt64(L,value);\r\nreturn 1;\r\n}\r\nWSLUA_CONSTRUCTOR Int64_decode(lua_State* L) {\r\n#define WSLUA_ARG_Int64_decode_STRING 1\r\n#define WSLUA_OPTARG_Int64_decode_ENDIAN 2\r\ngboolean asLittleEndian = IS_LITTLE_ENDIAN;\r\nsize_t len = 0;\r\nconst gchar *s = luaL_checklstring(L, WSLUA_ARG_Int64_decode_STRING, &len);\r\nif (lua_gettop(L) >= WSLUA_OPTARG_Int64_decode_ENDIAN) {\r\nif (lua_type(L,WSLUA_OPTARG_Int64_decode_ENDIAN) == LUA_TBOOLEAN)\r\nasLittleEndian = lua_toboolean(L,WSLUA_OPTARG_Int64_decode_ENDIAN);\r\n}\r\nif (len == sizeof(gint64)) {\r\nInt64_unpack(L, s, asLittleEndian);\r\n} else {\r\nlua_pushnil(L);\r\n}\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_CONSTRUCTOR Int64_new(lua_State* L) {\r\n#define WSLUA_OPTARG_Int64_new_VALUE 1\r\n#define WSLUA_OPTARG_Int64_new_HIGHVALUE 2\r\ngint64 value = 0;\r\nif (lua_gettop(L) >= 1) {\r\nswitch(lua_type(L, WSLUA_OPTARG_Int64_new_VALUE)) {\r\ncase LUA_TNUMBER:\r\nvalue = wslua_togint64(L, WSLUA_OPTARG_Int64_new_VALUE);\r\nif (lua_gettop(L) == 2 &&\r\nlua_type(L, WSLUA_OPTARG_Int64_new_HIGHVALUE) == LUA_TNUMBER) {\r\ngint64 h = wslua_togint64(L, WSLUA_OPTARG_Int64_new_HIGHVALUE);\r\nvalue &= G_GUINT64_CONSTANT(0x00000000FFFFFFFF);\r\nh <<= 32; h &= G_GUINT64_CONSTANT(0xFFFFFFFF00000000);\r\nvalue += h;\r\n}\r\nbreak;\r\ncase LUA_TSTRING:\r\ncase LUA_TUSERDATA:\r\nvalue = getInt64(L,WSLUA_OPTARG_Int64_new_VALUE);\r\nbreak;\r\ndefault:\r\nWSLUA_OPTARG_ERROR(Int64_new,VALUE,"must be a number, UInt64, Int64, or string");\r\nbreak;\r\n}\r\n}\r\npushInt64(L,value);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METAMETHOD Int64__call(lua_State* L) {\r\nlua_remove(L,1);\r\nWSLUA_RETURN(Int64_new(L));\r\n}\r\nWSLUA_CONSTRUCTOR Int64_max(lua_State* L) {\r\npushInt64(L, G_MAXINT64);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_CONSTRUCTOR Int64_min(lua_State* L) {\r\npushInt64(L, G_MININT64);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD Int64_tonumber(lua_State* L) {\r\nlua_pushnumber(L, (lua_Number)(checkInt64(L,1)));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_CONSTRUCTOR Int64_fromhex(lua_State* L) {\r\n#define WSLUA_ARG_Int64_fromhex_HEX 1\r\nguint64 result = 0;\r\nsize_t len = 0;\r\nconst gchar *s = luaL_checklstring(L,WSLUA_ARG_Int64_fromhex_HEX,&len);\r\nif (len > 0) {\r\nif (sscanf(s, "%" G_GINT64_MODIFIER "x", &result) != 1) {\r\nreturn luaL_error(L, "Error decoding the passed-in hex string");\r\n}\r\n}\r\npushInt64(L,(gint64)result);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD Int64_tohex(lua_State* L) {\r\n#define WSLUA_OPTARG_Int64_new_NUMBYTES 2\r\ngint64 b = getInt64(L,1);\r\nlua_Integer n = luaL_optinteger(L, WSLUA_OPTARG_Int64_new_NUMBYTES, 16);\r\nconst gchar *hexdigits = "0123456789abcdef";\r\ngchar buf[16];\r\nlua_Integer i;\r\nif (n < 0) { n = -n; hexdigits = "0123456789ABCDEF"; }\r\nif (n > 16) n = 16;\r\nfor (i = n-1; i >= 0; --i) { buf[i] = hexdigits[b & 15]; b >>= 4; }\r\nlua_pushlstring(L, buf, (size_t)n);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD Int64_higher(lua_State* L) {\r\ngint64 num = getInt64(L,1);\r\ngint64 b = num;\r\nlua_Number n = 0;\r\nif (b < 0) b = -b;\r\nb &= G_GUINT64_CONSTANT(0x7FFFFFFF00000000);\r\nb >>= 32;\r\nn = (lua_Number)(guint32)(b & G_GUINT64_CONSTANT(0x00000000FFFFFFFFF));\r\nif (num < 0) n = -n;\r\nlua_pushnumber(L,n);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD Int64_lower(lua_State* L) {\r\ngint64 b = getInt64(L,1);\r\nif (b < 0) b = -b;\r\nlua_pushnumber(L,(guint32)(b & G_GUINT64_CONSTANT(0x00000000FFFFFFFFF)));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METAMETHOD Int64__tostring(lua_State* L) {\r\ngint64 num = getInt64(L,1);\r\ngchar s[LUATYPE64_STRING_SIZE];\r\nif (g_snprintf(s, LUATYPE64_STRING_SIZE, "%" G_GINT64_MODIFIER "d", num) < 0) {\r\nreturn luaL_error(L, "Error writing Int64 to a string");\r\n}\r\nlua_pushstring(L,s);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METAMETHOD Int64__unm(lua_State* L) {\r\npushInt64(L,-(getInt64(L,1)));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METAMETHOD Int64__add(lua_State* L) {\r\nWSLUA_MATH_OP_FUNC(Int64,+);\r\n}\r\nWSLUA_METAMETHOD Int64__sub(lua_State* L) {\r\nWSLUA_MATH_OP_FUNC(Int64,-);\r\n}\r\nWSLUA_METAMETHOD Int64__mul(lua_State* L) {\r\nWSLUA_MATH_OP_FUNC(Int64,*);\r\n}\r\nWSLUA_METAMETHOD Int64__div(lua_State* L) {\r\nInt64 num1 = getInt64(L,1);\r\nInt64 num2 = getInt64(L,2);\r\nif (num2 == 0) {\r\nreturn luaL_error(L, "Trying to divide Int64 by zero");\r\n}\r\npushInt64(L, num1 / num2);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METAMETHOD Int64__mod(lua_State* L) {\r\nInt64 num1 = getInt64(L,1);\r\nInt64 num2 = getInt64(L,2);\r\nif (num2 == 0) {\r\nreturn luaL_error(L, "Trying to modulo Int64 by zero");\r\n}\r\npushInt64(L, num1 % num2);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METAMETHOD Int64__pow(lua_State* L) {\r\ngint64 num1 = getInt64(L,1);\r\ngint64 num2 = getInt64(L,2);\r\ngint64 result;\r\nif (num1 == 2) {\r\nresult = (num2 >= 8 * (gint64) sizeof(gint64)) ? 0 : ((gint64)1 << num2);\r\n}\r\nelse {\r\nfor (result = 1; num2 > 0; num2 >>= 1) {\r\nif (num2 & 1) result *= num1;\r\nnum1 *= num1;\r\n}\r\n}\r\npushInt64(L,result);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METAMETHOD Int64__eq(lua_State* L) {\r\nWSLUA_COMP_OP_FUNC(Int64,==);\r\n}\r\nWSLUA_METAMETHOD Int64__lt(lua_State* L) {\r\nWSLUA_COMP_OP_FUNC(Int64,<);\r\n}\r\nWSLUA_METAMETHOD Int64__le(lua_State* L) {\r\nWSLUA_COMP_OP_FUNC(Int64,<=);\r\n}\r\nWSLUA_METHOD Int64_bnot(lua_State* L) {\r\npushInt64(L,~(getInt64(L,1)));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD Int64_band(lua_State* L) {\r\nWSLUA_BIT_OP_FUNC(Int64,&=);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD Int64_bor(lua_State* L) {\r\nWSLUA_BIT_OP_FUNC(Int64,|=);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD Int64_bxor(lua_State* L) {\r\nWSLUA_BIT_OP_FUNC(Int64,^=);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD Int64_lshift(lua_State* L) {\r\n#define WSLUA_ARG_Int64_lshift_NUMBITS 2\r\nguint64 b = (guint64) getInt64(L,1);\r\nguint32 n = wslua_checkguint32(L,WSLUA_ARG_Int64_lshift_NUMBITS);\r\npushInt64(L,(gint64)(b << n));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD Int64_rshift(lua_State* L) {\r\n#define WSLUA_ARG_Int64_rshift_NUMBITS 2\r\nguint64 b = (guint64) getInt64(L,1);\r\nguint32 n = wslua_checkguint32(L,WSLUA_ARG_Int64_rshift_NUMBITS);\r\npushInt64(L,(gint64)(b >> n));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD Int64_arshift(lua_State* L) {\r\n#define WSLUA_ARG_Int64_arshift_NUMBITS 2\r\ngint64 b = getInt64(L,1);\r\ngint32 n = wslua_checkgint32(L,WSLUA_ARG_Int64_arshift_NUMBITS);\r\npushInt64(L,(b >> n));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD Int64_rol(lua_State* L) {\r\n#define WSLUA_ARG_Int64_rol_NUMBITS 2\r\nguint64 b = (guint64) getInt64(L,1);\r\nguint32 n = wslua_checkguint32(L,WSLUA_ARG_Int64_rol_NUMBITS);\r\npushInt64(L,(gint64)((b << n) | (b >> (64-n))));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD Int64_ror(lua_State* L) {\r\n#define WSLUA_ARG_Int64_ror_NUMBITS 2\r\nguint64 b = (guint64) getInt64(L,1);\r\nguint32 n = wslua_checkguint32(L,WSLUA_ARG_Int64_ror_NUMBITS);\r\npushInt64(L,(gint64)((b << (64-n)) | (b >> n)));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD Int64_bswap(lua_State* L) {\r\nguint64 b = (guint64) getInt64(L,1);\r\nguint64 result = 0;\r\nsize_t i;\r\nfor (i = 0; i < sizeof(gint64); i++) {\r\nresult <<= 8;\r\nresult |= (b & G_GUINT64_CONSTANT(0x00000000000000FF));\r\nb >>= 8;\r\n}\r\npushInt64(L,(gint64)result);\r\nWSLUA_RETURN(1);\r\n}\r\nstatic int Int64__gc(lua_State* L _U_) {\r\nreturn 0;\r\n}\r\nLUALIB_API int Int64_register(lua_State* L) {\r\nWSLUA_REGISTER_CLASS(Int64);\r\nreturn 0;\r\n}\r\nstatic guint64 getUInt64(lua_State *L, int i)\r\n{\r\ngchar *end = NULL;\r\n(void) end;\r\nswitch (lua_type(L,i))\r\n{\r\ncase LUA_TNUMBER:\r\nreturn wslua_checkguint64(L,i);\r\ncase LUA_TSTRING:\r\nreturn g_ascii_strtoull(luaL_checkstring(L,i), &end, 10);\r\ncase LUA_TUSERDATA:\r\nif (isInt64(L, i)) {\r\nreturn (UInt64) toInt64(L, i);\r\n}\r\ndefault:\r\nreturn checkUInt64(L,i);\r\n}\r\n}\r\nvoid UInt64_pack(lua_State* L, luaL_Buffer *b, gint idx, gboolean asLittleEndian) {\r\nguint64 value = checkUInt64(L,idx);\r\ngint8 buff[sizeof(guint64)];\r\nif (asLittleEndian) {\r\nguint i;\r\nfor (i = 0; i < sizeof(guint64); i++) {\r\nbuff[i] = (value & 0xff);\r\nvalue >>= 8;\r\n}\r\n}\r\nelse {\r\ngint i;\r\nfor (i = sizeof(guint64) - 1; i >= 0; i--) {\r\nbuff[i] = (value & 0xff);\r\nvalue >>= 8;\r\n}\r\n}\r\nluaL_addlstring(b, (char*)buff, sizeof(guint64));\r\n}\r\nWSLUA_METHOD UInt64_encode(lua_State* L) {\r\n#define WSLUA_OPTARG_UInt64_encode_ENDIAN 2\r\nluaL_Buffer b;\r\ngboolean asLittleEndian = IS_LITTLE_ENDIAN;\r\nif (lua_gettop(L) >= 2) {\r\nif (lua_type(L,2) == LUA_TBOOLEAN)\r\nasLittleEndian = lua_toboolean(L,2);\r\n}\r\nluaL_buffinit(L, &b);\r\nUInt64_pack(L, &b, 1, asLittleEndian);\r\nluaL_pushresult(&b);\r\nWSLUA_RETURN(1);\r\n}\r\nint UInt64_unpack(lua_State* L, const gchar *buff, gboolean asLittleEndian) {\r\nguint64 value = 0;\r\ngint i;\r\nif (asLittleEndian) {\r\nfor (i = sizeof(guint64) - 1; i >= 0; i--) {\r\nvalue <<= 8;\r\nvalue |= (guint64)(guchar)buff[i];\r\n}\r\n}\r\nelse {\r\nfor (i = 0; i < (gint) sizeof(guint64); i++) {\r\nvalue <<= 8;\r\nvalue |= (guint64)(guchar)buff[i];\r\n}\r\n}\r\npushUInt64(L,value);\r\nreturn 1;\r\n}\r\nWSLUA_CONSTRUCTOR UInt64_decode(lua_State* L) {\r\n#define WSLUA_ARG_UInt64_decode_STRING 1\r\n#define WSLUA_OPTARG_UInt64_decode_ENDIAN 2\r\ngboolean asLittleEndian = IS_LITTLE_ENDIAN;\r\nsize_t len = 0;\r\nconst gchar *s = luaL_checklstring(L, WSLUA_ARG_UInt64_decode_STRING, &len);\r\nif (lua_gettop(L) >= WSLUA_OPTARG_UInt64_decode_ENDIAN) {\r\nif (lua_type(L,WSLUA_OPTARG_UInt64_decode_ENDIAN) == LUA_TBOOLEAN)\r\nasLittleEndian = lua_toboolean(L,WSLUA_OPTARG_UInt64_decode_ENDIAN);\r\n}\r\nif (len == sizeof(guint64)) {\r\nUInt64_unpack(L, s, asLittleEndian);\r\n} else {\r\nlua_pushnil(L);\r\n}\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_CONSTRUCTOR UInt64_new(lua_State* L) {\r\n#define WSLUA_OPTARG_UInt64_new_VALUE 1\r\n#define WSLUA_OPTARG_UInt64_new_HIGHVALUE 2\r\nguint64 value = 0;\r\nif (lua_gettop(L) >= 1) {\r\nswitch(lua_type(L, WSLUA_OPTARG_UInt64_new_VALUE)) {\r\ncase LUA_TNUMBER:\r\nvalue = wslua_toguint64(L, WSLUA_OPTARG_UInt64_new_VALUE);\r\nif (lua_gettop(L) == 2 &&\r\nlua_type(L, WSLUA_OPTARG_UInt64_new_HIGHVALUE) == LUA_TNUMBER) {\r\nguint64 h = wslua_toguint64(L, WSLUA_OPTARG_UInt64_new_HIGHVALUE);\r\nvalue &= G_GUINT64_CONSTANT(0x00000000FFFFFFFF);\r\nh <<= 32; h &= G_GUINT64_CONSTANT(0xFFFFFFFF00000000);\r\nvalue += h;\r\n}\r\nbreak;\r\ncase LUA_TSTRING:\r\ncase LUA_TUSERDATA:\r\nvalue = getUInt64(L, WSLUA_OPTARG_UInt64_new_VALUE);\r\nbreak;\r\ndefault:\r\nWSLUA_OPTARG_ERROR(UInt64_new,VALUE,"must be a number, UInt64, Int64, or string");\r\nbreak;\r\n}\r\n}\r\npushUInt64(L,value);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METAMETHOD UInt64__call(lua_State* L) {\r\nlua_remove(L,1);\r\nWSLUA_RETURN(UInt64_new(L));\r\n}\r\nWSLUA_CONSTRUCTOR UInt64_max(lua_State* L) {\r\npushUInt64(L,G_MAXUINT64);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_CONSTRUCTOR UInt64_min(lua_State* L) {\r\npushUInt64(L,0);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD UInt64_tonumber(lua_State* L) {\r\nlua_pushnumber(L,(lua_Number)(checkUInt64(L,1)));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METAMETHOD UInt64__tostring(lua_State* L) {\r\nguint64 num = getUInt64(L,1);\r\ngchar s[LUATYPE64_STRING_SIZE];\r\nif (g_snprintf(s, LUATYPE64_STRING_SIZE, "%" G_GINT64_MODIFIER "u",(guint64)num) < 0) {\r\nreturn luaL_error(L, "Error writing UInt64 to a string");\r\n}\r\nlua_pushstring(L,s);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_CONSTRUCTOR UInt64_fromhex(lua_State* L) {\r\n#define WSLUA_ARG_UInt64_fromhex_HEX 1\r\nguint64 result = 0;\r\nsize_t len = 0;\r\nconst gchar *s = luaL_checklstring(L,WSLUA_ARG_UInt64_fromhex_HEX,&len);\r\nif (len > 0) {\r\nif (sscanf(s, "%" G_GINT64_MODIFIER "x", &result) != 1) {\r\nreturn luaL_error(L, "Error decoding the passed-in hex string");\r\n}\r\n}\r\npushUInt64(L,result);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD UInt64_tohex(lua_State* L) {\r\n#define WSLUA_OPTARG_UInt64_new_NUMBYTES 2\r\nguint64 b = getUInt64(L,1);\r\nlua_Integer n = luaL_optinteger(L, WSLUA_OPTARG_UInt64_new_NUMBYTES, 16);\r\nconst gchar *hexdigits = "0123456789abcdef";\r\ngchar buf[16];\r\nlua_Integer i;\r\nif (n < 0) { n = -n; hexdigits = "0123456789ABCDEF"; }\r\nif (n > 16) n = 16;\r\nfor (i = n-1; i >= 0; --i) { buf[i] = hexdigits[b & 15]; b >>= 4; }\r\nlua_pushlstring(L, buf, (size_t)n);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD UInt64_higher(lua_State* L) {\r\nguint64 num = getUInt64(L,1);\r\nguint64 b = num;\r\nlua_Number n = 0;\r\nb &= G_GUINT64_CONSTANT(0xFFFFFFFF00000000);\r\nb >>= 32;\r\nn = (lua_Number)(guint32)(b & G_GUINT64_CONSTANT(0x00000000FFFFFFFFF));\r\nlua_pushnumber(L,n);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD UInt64_lower(lua_State* L) {\r\nguint64 b = getUInt64(L,1);\r\nlua_pushnumber(L,(guint32)(b & G_GUINT64_CONSTANT(0x00000000FFFFFFFFF)));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METAMETHOD UInt64__unm(lua_State* L) {\r\npushUInt64(L,getUInt64(L,1));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METAMETHOD UInt64__add(lua_State* L) {\r\nWSLUA_MATH_OP_FUNC(UInt64,+);\r\n}\r\nWSLUA_METAMETHOD UInt64__sub(lua_State* L) {\r\nWSLUA_MATH_OP_FUNC(UInt64,-);\r\n}\r\nWSLUA_METAMETHOD UInt64__mul(lua_State* L) {\r\nWSLUA_MATH_OP_FUNC(UInt64,*);\r\n}\r\nWSLUA_METAMETHOD UInt64__div(lua_State* L) {\r\nUInt64 num1 = getUInt64(L,1);\r\nUInt64 num2 = getUInt64(L,2);\r\nif (num2 == 0) {\r\nreturn luaL_error(L, "Trying to divide UInt64 by zero");\r\n}\r\npushUInt64(L, num1 / num2);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METAMETHOD UInt64__mod(lua_State* L) {\r\nUInt64 num1 = getUInt64(L,1);\r\nUInt64 num2 = getUInt64(L,2);\r\nif (num2 == 0) {\r\nreturn luaL_error(L, "Trying to modulo UInt64 by zero");\r\n}\r\npushUInt64(L, num1 % num2);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METAMETHOD UInt64__pow(lua_State* L) {\r\nguint64 num1 = getUInt64(L,1);\r\nguint64 num2 = getUInt64(L,2);\r\nguint64 result;\r\nif (num1 == 2) {\r\nresult = (num2 >= 8 * (guint64) sizeof(guint64)) ? 0 : ((guint64)1 << num2);\r\n}\r\nelse {\r\nfor (result = 1; num2 > 0; num2 >>= 1) {\r\nif (num2 & 1) result *= num1;\r\nnum1 *= num1;\r\n}\r\n}\r\npushUInt64(L,result);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METAMETHOD UInt64__eq(lua_State* L) {\r\nWSLUA_COMP_OP_FUNC(UInt64,==);\r\n}\r\nWSLUA_METAMETHOD UInt64__lt(lua_State* L) {\r\nWSLUA_COMP_OP_FUNC(UInt64,<);\r\n}\r\nWSLUA_METAMETHOD UInt64__le(lua_State* L) {\r\nWSLUA_COMP_OP_FUNC(UInt64,<=);\r\n}\r\nWSLUA_METHOD UInt64_bnot(lua_State* L) {\r\npushUInt64(L,~(getUInt64(L,1)));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD UInt64_band(lua_State* L) {\r\nWSLUA_BIT_OP_FUNC(UInt64,&=);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD UInt64_bor(lua_State* L) {\r\nWSLUA_BIT_OP_FUNC(UInt64,|=);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD UInt64_bxor(lua_State* L) {\r\nWSLUA_BIT_OP_FUNC(UInt64,^=);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD UInt64_lshift(lua_State* L) {\r\n#define WSLUA_ARG_UInt64_lshift_NUMBITS 2\r\nguint64 b = getUInt64(L,1);\r\nguint32 n = wslua_checkguint32(L,WSLUA_ARG_UInt64_lshift_NUMBITS);\r\npushUInt64(L,(b << n));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD UInt64_rshift(lua_State* L) {\r\n#define WSLUA_ARG_UInt64_rshift_NUMBITS 2\r\nguint64 b = getUInt64(L,1);\r\nguint32 n = wslua_checkguint32(L,WSLUA_ARG_UInt64_rshift_NUMBITS);\r\npushUInt64(L,(b >> n));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD UInt64_arshift(lua_State* L) {\r\n#define WSLUA_ARG_UInt64_arshift_NUMBITS 2\r\nguint64 b = getUInt64(L,1);\r\nguint32 n = wslua_checkguint32(L,WSLUA_ARG_UInt64_arshift_NUMBITS);\r\npushUInt64(L,(b >> n));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD UInt64_rol(lua_State* L) {\r\n#define WSLUA_ARG_UInt64_rol_NUMBITS 2\r\nguint64 b = getUInt64(L,1);\r\nguint32 n = wslua_checkguint32(L,WSLUA_ARG_UInt64_rol_NUMBITS);\r\npushUInt64(L,((b << n) | (b >> (64-n))));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD UInt64_ror(lua_State* L) {\r\n#define WSLUA_ARG_UInt64_ror_NUMBITS 2\r\nguint64 b = getUInt64(L,1);\r\nguint32 n = wslua_checkguint32(L,WSLUA_ARG_UInt64_ror_NUMBITS);\r\npushUInt64(L,((b << (64-n)) | (b >> n)));\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD UInt64_bswap(lua_State* L) {\r\nguint64 b = getUInt64(L,1);\r\nguint64 result = 0;\r\nsize_t i;\r\nfor (i = 0; i < sizeof(guint64); i++) {\r\nresult <<= 8;\r\nresult |= (b & G_GUINT64_CONSTANT(0x00000000000000FF));\r\nb >>= 8;\r\n}\r\npushUInt64(L,result);\r\nWSLUA_RETURN(1);\r\n}\r\nstatic int UInt64__gc(lua_State* L _U_) {\r\nreturn 0;\r\n}\r\nLUALIB_API int UInt64_register(lua_State* L) {\r\nWSLUA_REGISTER_CLASS(UInt64);\r\nreturn 0;\r\n}
