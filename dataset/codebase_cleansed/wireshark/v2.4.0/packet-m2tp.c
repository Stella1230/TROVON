static guint\r\nnr_of_padding_bytes (guint length)\r\n{\r\nguint remainder;\r\nremainder = length % 4;\r\nif (remainder == 0)\r\nreturn 0;\r\nelse\r\nreturn 4 - remainder;\r\n}\r\nstatic void\r\ndissect_m2tp_common_header(tvbuff_t *common_header_tvb, packet_info *pinfo, proto_tree *m2tp_tree)\r\n{\r\nguint8 version, reserved, message_class, message_type;\r\nguint32 message_length;\r\nversion = tvb_get_guint8(common_header_tvb, VERSION_OFFSET);\r\nreserved = tvb_get_guint8(common_header_tvb, RESERVED_OFFSET);\r\nmessage_class = tvb_get_guint8(common_header_tvb, MESSAGE_CLASS_OFFSET);\r\nmessage_type = tvb_get_guint8(common_header_tvb, MESSAGE_TYPE_OFFSET);\r\nmessage_length = tvb_get_ntohl (common_header_tvb, MESSAGE_LENGTH_OFFSET);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s ", val_to_str_const(message_class * 256 + message_type, m2tp_message_class_type_acro_values, "reserved"));\r\nif (m2tp_tree) {\r\nproto_tree_add_uint(m2tp_tree, hf_m2tp_version, common_header_tvb, VERSION_OFFSET, VERSION_LENGTH, version);\r\nproto_tree_add_uint(m2tp_tree, hf_m2tp_reserved, common_header_tvb, RESERVED_OFFSET, RESERVED_LENGTH, reserved);\r\nproto_tree_add_uint(m2tp_tree, hf_m2tp_message_class, common_header_tvb, MESSAGE_CLASS_OFFSET, MESSAGE_CLASS_LENGTH, message_class);\r\nproto_tree_add_uint_format_value(m2tp_tree, hf_m2tp_message_type,\r\ncommon_header_tvb, MESSAGE_TYPE_OFFSET, MESSAGE_TYPE_LENGTH,\r\nmessage_type, "%u (%s)",\r\nmessage_type, val_to_str_const(message_class * 256 + message_type, m2tp_message_class_type_values, "reserved"));\r\nproto_tree_add_uint(m2tp_tree, hf_m2tp_message_length, common_header_tvb, MESSAGE_LENGTH_OFFSET, MESSAGE_LENGTH_LENGTH, message_length);\r\n};\r\n}\r\nstatic void\r\ndissect_m2tp_interface_identifier_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint32 parameter_value;\r\nif (parameter_tree) {\r\nparameter_value = tvb_get_ntohl(parameter_tvb, PARAMETER_VALUE_OFFSET);\r\nproto_tree_add_uint(parameter_tree, hf_m2tp_interface_identifier, parameter_tvb, INTERFACE_IDENTIFIER_OFFSET, INTERFACE_IDENTIFIER_LENGTH, parameter_value);\r\nproto_item_set_text(parameter_item, "Interface Identifier (%u)", parameter_value);\r\n}\r\n}\r\nstatic void\r\ndissect_m2tp_master_slave_parameter (tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint32 parameter_value;\r\nif (parameter_tree) {\r\nparameter_value = tvb_get_ntohl(parameter_tvb, PARAMETER_VALUE_OFFSET);\r\nproto_tree_add_uint(parameter_tree, hf_m2tp_master_slave, parameter_tvb, MASTER_SLAVE_OFFSET, MASTER_SLAVE_LENGTH, parameter_value);\r\nproto_item_set_text(parameter_item, "Master Slave Indicator (%s)", val_to_str_const(parameter_value, m2tp_mode_values, "unknown"));\r\n}\r\n}\r\nstatic void\r\ndissect_m2tp_user_identifier_parameter (tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint32 parameter_value;\r\nif (parameter_tree) {\r\nparameter_value = tvb_get_ntohl(parameter_tvb, PARAMETER_VALUE_OFFSET);\r\nproto_tree_add_uint(parameter_tree, hf_m2tp_user, parameter_tvb, M2TP_USER_OFFSET, M2TP_USER_LENGTH, parameter_value);\r\nproto_item_set_text(parameter_item, "M2TP User Identifier (%u)", parameter_value);\r\n}\r\n}\r\nstatic void\r\ndissect_m2tp_info_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 length, info_string_length;\r\nconst guint8 *info_string;\r\nif (parameter_tree) {\r\nlength = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET);\r\ninfo_string_length = length - PARAMETER_HEADER_LENGTH;\r\nproto_tree_add_item_ret_string(parameter_tree, hf_m2tp_info_string, parameter_tvb, INFO_STRING_OFFSET, info_string_length, ENC_ASCII, wmem_packet_scope(), &info_string);\r\nproto_item_set_text(parameter_item, "Info String (%.*s)", info_string_length, info_string);\r\n}\r\n}\r\nstatic void\r\ndissect_m2tp_diagnostic_information_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 length, diagnostic_info_length;\r\nif (parameter_tree) {\r\nlength = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET);\r\ndiagnostic_info_length = length - PARAMETER_HEADER_LENGTH;\r\nproto_tree_add_item(parameter_tree, hf_m2tp_diagnostic_info, parameter_tvb, PARAMETER_VALUE_OFFSET, diagnostic_info_length, ENC_NA);\r\nproto_item_set_text(parameter_item, "Diagnostic information (%u byte%s)", diagnostic_info_length, plurality(diagnostic_info_length, "", "s"));\r\n}\r\n}\r\nstatic void\r\ndissect_m2tp_heartbeat_data_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 length, heartbeat_data_length;\r\nif (parameter_tree) {\r\nlength = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET);\r\nheartbeat_data_length = length - PARAMETER_HEADER_LENGTH;\r\nproto_tree_add_item(parameter_tree, hf_m2tp_heartbeat_data, parameter_tvb, PARAMETER_VALUE_OFFSET, heartbeat_data_length, ENC_NA);\r\nproto_item_set_text(parameter_item, "Heartbeat data (%u byte%s)", heartbeat_data_length, plurality(heartbeat_data_length, "", "s"));\r\n}\r\n}\r\nstatic void\r\ndissect_m2tp_reason_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint32 reason;\r\nif (parameter_tree) {\r\nreason = tvb_get_ntohl(parameter_tvb, REASON_OFFSET);\r\nproto_tree_add_uint(parameter_tree, hf_m2tp_reason, parameter_tvb, REASON_OFFSET, REASON_LENGTH, reason);\r\nproto_item_set_text(parameter_item, "Reason parameter (%s)", val_to_str_const(reason, m2tp_reason_code_values, "unknown"));\r\n}\r\n}\r\nstatic void\r\ndissect_m2tp_error_code_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint32 error_code;\r\nif (parameter_tree) {\r\nerror_code = tvb_get_ntohl(parameter_tvb, ERROR_CODE_OFFSET);\r\nproto_tree_add_uint(parameter_tree, hf_m2tp_error_code, parameter_tvb, ERROR_CODE_OFFSET, ERROR_CODE_LENGTH, error_code);\r\nproto_item_set_text(parameter_item, "Error code parameter (%s)", val_to_str_const(error_code, m2tp_error_code_values, "unknown"));\r\n}\r\n}\r\nstatic void\r\ndissect_m2tp_protocol_data_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item, packet_info *pinfo, proto_item *m2tp_item, proto_tree *tree)\r\n{\r\nguint16 length, protocol_data_length, padding_length;\r\ntvbuff_t *mtp2_tvb;\r\nlength = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET);\r\npadding_length = nr_of_padding_bytes(length);\r\nprotocol_data_length = length - PARAMETER_HEADER_LENGTH;\r\nmtp2_tvb = tvb_new_subset_length(parameter_tvb, PARAMETER_VALUE_OFFSET, protocol_data_length);\r\ncall_dissector(mtp2_handle, mtp2_tvb, pinfo, tree);\r\nif (parameter_tree) {\r\nproto_item_set_text(parameter_item, "Protocol data (SS7 message)");\r\nproto_item_set_len(parameter_item, proto_item_get_len(parameter_item) - protocol_data_length - padding_length);\r\nproto_item_set_len(m2tp_item, proto_item_get_len(m2tp_item) - protocol_data_length - padding_length);\r\n}\r\n}\r\nstatic void\r\ndissect_m2tp_unknown_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 tag, length, parameter_value_length;\r\nif (parameter_tree) {\r\ntag = tvb_get_ntohs(parameter_tvb, PARAMETER_TAG_OFFSET);\r\nlength = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET);\r\nparameter_value_length = length - PARAMETER_HEADER_LENGTH;\r\nproto_tree_add_item(parameter_tree, hf_m2tp_parameter_value, parameter_tvb, PARAMETER_VALUE_OFFSET, parameter_value_length, ENC_NA);\r\nproto_item_set_text(parameter_item, "Parameter with tag %u and %u byte%s value", tag, parameter_value_length, plurality(parameter_value_length, "", "s"));\r\n}\r\n}\r\nstatic void\r\ndissect_m2tp_parameter(tvbuff_t *parameter_tvb, packet_info *pinfo, proto_tree *m2tp_tree, proto_item *m2tp_item, proto_tree *tree)\r\n{\r\nguint16 tag, length, padding_length, total_length;\r\nproto_item *parameter_item = NULL;\r\nproto_tree *parameter_tree = NULL;\r\ntag = tvb_get_ntohs(parameter_tvb, PARAMETER_TAG_OFFSET);\r\nlength = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET);\r\npadding_length = nr_of_padding_bytes(length);\r\ntotal_length = length + padding_length;\r\nif (tree) {\r\nparameter_tree = proto_tree_add_subtree(m2tp_tree, parameter_tvb, PARAMETER_HEADER_OFFSET, total_length,\r\nett_m2tp_parameter, &parameter_item, "Incomplete parameter");\r\nproto_tree_add_uint(parameter_tree, hf_m2tp_parameter_tag, parameter_tvb, PARAMETER_TAG_OFFSET, PARAMETER_TAG_LENGTH, tag);\r\nproto_tree_add_uint(parameter_tree, hf_m2tp_parameter_length, parameter_tvb, PARAMETER_LENGTH_OFFSET, PARAMETER_LENGTH_LENGTH, length);\r\n}\r\nswitch(tag) {\r\ncase INTERFACE_IDENTIFIER_PARAMETER_TAG:\r\ndissect_m2tp_interface_identifier_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase MASTER_SLAVE_INDICATOR_PARAMETER_TAG:\r\ndissect_m2tp_master_slave_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase M2TP_USER_IDENTIFIER_PARAMETER_TAG:\r\ndissect_m2tp_user_identifier_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase INFO_PARAMETER_TAG:\r\ndissect_m2tp_info_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase DIAGNOSTIC_INFORMATION_PARAMETER_TAG:\r\ndissect_m2tp_diagnostic_information_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase HEARTBEAT_DATA_PARAMETER_TAG:\r\ndissect_m2tp_heartbeat_data_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase REASON_PARAMETER_TAG:\r\ndissect_m2tp_reason_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase ERROR_CODE_PARAMETER_TAG:\r\ndissect_m2tp_error_code_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase PROTOCOL_DATA_PARAMETER_TAG:\r\ndissect_m2tp_protocol_data_parameter(parameter_tvb, parameter_tree, parameter_item, pinfo, m2tp_item, tree);\r\nbreak;\r\ndefault:\r\ndissect_m2tp_unknown_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\n};\r\nif ((parameter_tree) && (padding_length > 0))\r\nproto_tree_add_item(parameter_tree, hf_m2tp_parameter_padding, parameter_tvb, PARAMETER_HEADER_OFFSET + length, padding_length, ENC_NA);\r\n}\r\nstatic void\r\ndissect_m2tp_message(tvbuff_t *message_tvb, packet_info *pinfo, proto_item *m2tp_item, proto_tree *m2tp_tree, proto_tree *tree)\r\n{\r\ngint offset, length, padding_length, total_length;\r\ntvbuff_t *common_header_tvb, *parameter_tvb;\r\noffset = 0;\r\ncommon_header_tvb = tvb_new_subset_length(message_tvb, offset, COMMON_HEADER_LENGTH);\r\ndissect_m2tp_common_header(common_header_tvb, pinfo, m2tp_tree);\r\noffset += COMMON_HEADER_LENGTH;\r\nwhile(tvb_reported_length_remaining(message_tvb, offset) > 0) {\r\nlength = tvb_get_ntohs(message_tvb, offset + PARAMETER_LENGTH_OFFSET);\r\npadding_length = nr_of_padding_bytes(length);\r\ntotal_length = length + padding_length;\r\nparameter_tvb = tvb_new_subset_length(message_tvb, offset, total_length);\r\ndissect_m2tp_parameter(parameter_tvb, pinfo, m2tp_tree, m2tp_item, tree);\r\noffset += total_length;\r\n}\r\n}\r\nstatic int\r\ndissect_m2tp(tvbuff_t *message_tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *m2tp_item;\r\nproto_tree *m2tp_tree;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "M2TP");\r\nm2tp_item = proto_tree_add_item(tree, proto_m2tp, message_tvb, 0, -1, ENC_NA);\r\nm2tp_tree = proto_item_add_subtree(m2tp_item, ett_m2tp);\r\ndissect_m2tp_message(message_tvb, pinfo, m2tp_item, m2tp_tree, tree);\r\nreturn tvb_captured_length(message_tvb);\r\n}\r\nvoid\r\nproto_register_m2tp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_m2tp_version,\r\n{ "Version", "m2tp.version",\r\nFT_UINT8, BASE_DEC, VALS(m2tp_protocol_version_values), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_m2tp_reserved,\r\n{ "Reserved", "m2tp.reserved",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_m2tp_message_class,\r\n{ "Message class", "m2tp.message_class",\r\nFT_UINT8, BASE_DEC, VALS(m2tp_message_class_values), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_m2tp_message_type,\r\n{ "Message Type", "m2tp.message_type",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_m2tp_message_length,\r\n{ "Message length", "m2tp.message_length",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_m2tp_parameter_tag,\r\n{ "Parameter Tag", "m2tp.parameter_tag",\r\nFT_UINT16, BASE_DEC, VALS(m2tp_parameter_tag_values), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_m2tp_parameter_length,\r\n{ "Parameter length", "m2tp.parameter_length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_m2tp_parameter_value,\r\n{ "Parameter Value", "m2tp.parameter_value",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_m2tp_parameter_padding,\r\n{ "Padding", "m2tp.parameter_padding",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_m2tp_interface_identifier,\r\n{ "Interface Identifier", "m2tp.interface_identifier",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_m2tp_user,\r\n{ "M2tp User Identifier", "m2tp.user_identifier",\r\nFT_UINT32, BASE_DEC, VALS(m2tp_user_identifier_values), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_m2tp_master_slave,\r\n{ "Master Slave Indicator", "m2tp.master_slave",\r\nFT_UINT32, BASE_DEC, VALS(m2tp_mode_values), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_m2tp_info_string,\r\n{ "Info string", "m2tp.info_string",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_m2tp_diagnostic_info,\r\n{ "Diagnostic information", "m2tp.diagnostic_info",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_m2tp_heartbeat_data,\r\n{ "Heartbeat data", "m2tp.heartbeat_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_m2tp_error_code,\r\n{ "Error code", "m2tp.error_code",\r\nFT_UINT32, BASE_DEC, VALS(m2tp_error_code_values), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_m2tp_reason,\r\n{ "Reason", "m2tp.reason",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_m2tp,\r\n&ett_m2tp_parameter,\r\n};\r\nproto_m2tp = proto_register_protocol("MTP 2 Transparent Proxy", "M2TP", "m2tp");\r\nproto_register_field_array(proto_m2tp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_m2tp(void)\r\n{\r\ndissector_handle_t m2tp_handle;\r\nmtp2_handle = find_dissector_add_dependency("mtp2", proto_m2tp);\r\nm2tp_handle = create_dissector_handle(dissect_m2tp, proto_m2tp);\r\ndissector_add_uint("sctp.ppi", M2TP_PAYLOAD_PROTOCOL_ID, m2tp_handle);\r\ndissector_add_uint("sctp.port", SCTP_PORT_M2TP, m2tp_handle);\r\n}
