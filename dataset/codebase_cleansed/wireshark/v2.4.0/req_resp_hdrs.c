gboolean\r\nreq_resp_hdrs_do_reassembly(tvbuff_t *tvb, const int offset, packet_info *pinfo,\r\nconst gboolean desegment_headers, const gboolean desegment_body)\r\n{\r\ngint next_offset;\r\ngint next_offset_sav;\r\ngint length_remaining, reported_length_remaining;\r\nint linelen;\r\ngchar *header_val;\r\nint content_length;\r\ngboolean content_length_found = FALSE;\r\ngboolean content_type_found = FALSE;\r\ngboolean chunked_encoding = FALSE;\r\ngboolean keepalive_found = FALSE;\r\ngchar *line;\r\ngchar *content_type = NULL;\r\nif (desegment_headers && pinfo->can_desegment) {\r\nnext_offset = offset;\r\nfor (;;) {\r\nnext_offset_sav = next_offset;\r\nreported_length_remaining =\r\ntvb_reported_length_remaining(tvb, next_offset);\r\nif (reported_length_remaining < 1) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn FALSE;\r\n}\r\nlength_remaining = tvb_captured_length_remaining(tvb,\r\nnext_offset);\r\nlinelen = tvb_find_line_end(tvb, next_offset,\r\nlength_remaining, &next_offset, TRUE);\r\nif (linelen == -1 &&\r\nlength_remaining >= reported_length_remaining) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn FALSE;\r\n}\r\nif (linelen == 0) {\r\nbreak;\r\n}\r\nif (desegment_body) {\r\nguchar first_byte = tvb_get_guint8(tvb, next_offset_sav);\r\nif (! (first_byte == 'c' || first_byte == 'C' ||\r\nfirst_byte == 't' || first_byte == 'T')) {\r\ncontinue;\r\n}\r\nline = tvb_get_string_enc(wmem_packet_scope(), tvb, next_offset_sav, linelen, ENC_UTF_8|ENC_NA);\r\nif (g_ascii_strncasecmp(line, "Content-Length:", 15) == 0) {\r\nif (sscanf(line+15,"%i", &content_length) == 1)\r\ncontent_length_found = TRUE;\r\n} else if (g_ascii_strncasecmp(line, "Content-Type:", 13) == 0) {\r\ncontent_type_found = TRUE;\r\ncontent_type = line+13;\r\nwhile (*content_type == ' ') {\r\ncontent_type++;\r\n}\r\n} else if (g_ascii_strncasecmp(line, "Connection:", 11) == 0) {\r\nheader_val = line+11;\r\nif(header_val){\r\nwhile(*header_val==' '){\r\nheader_val++;\r\n}\r\nif(!g_ascii_strncasecmp(header_val, "Keep-Alive", 10)){\r\nkeepalive_found = TRUE;\r\n}\r\n}\r\n} else if (g_ascii_strncasecmp( line, "Transfer-Encoding:", 18) == 0) {\r\ngchar *p;\r\nguint len;\r\nheader_val = line+18;\r\np = header_val;\r\nlen = (guint) strlen(header_val);\r\nwhile (p < header_val + len &&\r\n(*p == ' ' || *p == '\t'))\r\np++;\r\nif (p <= header_val + len) {\r\nif (g_ascii_strncasecmp(p, "chunked", 7)\r\n== 0) {\r\nchunked_encoding = TRUE;\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif (desegment_body) {\r\nif (chunked_encoding) {\r\ngboolean done_chunking = FALSE;\r\nwhile (!done_chunking) {\r\nguint chunk_size = 0;\r\ngint chunk_offset = 0;\r\ngchar *chunk_string = NULL;\r\ngchar *c = NULL;\r\nreported_length_remaining =\r\ntvb_reported_length_remaining(tvb,\r\nnext_offset);\r\nif (reported_length_remaining < 1) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn FALSE;\r\n}\r\nlength_remaining = tvb_captured_length_remaining(tvb,\r\nnext_offset);\r\nlinelen = tvb_find_line_end(tvb, next_offset,\r\nlength_remaining, &chunk_offset, TRUE);\r\nif (linelen == -1 &&\r\nlength_remaining >=\r\nreported_length_remaining) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn FALSE;\r\n}\r\nchunk_string = tvb_get_string_enc(wmem_packet_scope(), tvb, next_offset,\r\nlinelen, ENC_ASCII);\r\nc = chunk_string;\r\nif ((c = strchr(c, ';'))) {\r\n*c = '\0';\r\n}\r\nif (sscanf(chunk_string, "%x", &chunk_size) < 1) {\r\nreturn TRUE;\r\n}\r\nif (chunk_size > 1U<<31) {\r\nreturn TRUE;\r\n}\r\nif (chunk_size == 0) {\r\nlinelen = tvb_find_line_end(tvb,\r\nchunk_offset, length_remaining, &chunk_offset, TRUE);\r\nif (linelen == -1 &&\r\nlength_remaining >=\r\nreported_length_remaining) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn FALSE;\r\n}\r\npinfo->desegment_offset = chunk_offset;\r\npinfo->desegment_len = 0;\r\ndone_chunking = TRUE;\r\n} else {\r\nif (reported_length_remaining >\r\n(gint) chunk_size) {\r\nnext_offset = chunk_offset\r\n+ chunk_size + 2;\r\n} else {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn FALSE;\r\n}\r\n}\r\n}\r\n} else if (content_length_found) {\r\nif (content_length >= 128*1024) {\r\ngchar *tmp;\r\nif (content_type_found &&\r\nstrncmp(content_type, "application/rpc", 15) == 0) {\r\nreturn TRUE;\r\n}\r\ntmp = tvb_get_string_enc(wmem_packet_scope(), tvb, 0, sizeof("RPC_OUT_DATA") - 1, ENC_ASCII);\r\nif ((strncmp(tmp, "RPC_IN_DATA", sizeof("RPC_IN_DATA") - 1) == 0) ||\r\n(strncmp(tmp, "RPC_OUT_DATA", sizeof("RPC_OUT_DATA") - 1) == 0)) {\r\nreturn TRUE;\r\n}\r\n}\r\nif (!tvb_bytes_exist(tvb, next_offset, content_length)) {\r\nlength_remaining = tvb_captured_length_remaining(tvb,\r\nnext_offset);\r\nreported_length_remaining =\r\ntvb_reported_length_remaining(tvb, next_offset);\r\nif (length_remaining < reported_length_remaining) {\r\nreturn TRUE;\r\n}\r\nif (length_remaining == -1)\r\nlength_remaining = 0;\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len =\r\ncontent_length - length_remaining;\r\nreturn FALSE;\r\n}\r\n} else if (content_type_found && pinfo->can_desegment) {\r\nlength_remaining = tvb_captured_length_remaining(tvb, next_offset);\r\nreported_length_remaining = tvb_reported_length_remaining(tvb, next_offset);\r\nif (length_remaining < reported_length_remaining) {\r\nreturn TRUE;\r\n}\r\nif (keepalive_found) {\r\nreturn TRUE;\r\n}\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_UNTIL_FIN;\r\nreturn FALSE;\r\n}\r\n}\r\nreturn TRUE;\r\n}
