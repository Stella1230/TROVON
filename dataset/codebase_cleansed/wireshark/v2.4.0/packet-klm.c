static int\r\ndissect_holder(tvbuff_t *tvb, proto_tree *tree, int offset)\r\n{\r\nproto_item* lock_item = NULL;\r\nproto_tree* lock_tree = NULL;\r\nlock_item = proto_tree_add_item(tree, hf_klm_holder, tvb,\r\noffset, -1, ENC_NA);\r\nlock_tree = proto_item_add_subtree(lock_item, ett_klm_holder);\r\noffset = dissect_rpc_bool( tvb, lock_tree,\r\nhf_klm_exclusive, offset);\r\noffset = dissect_rpc_uint32(tvb, lock_tree,\r\nhf_klm_pid, offset);\r\noffset = dissect_rpc_uint32(tvb, lock_tree,\r\nhf_klm_offset, offset);\r\noffset = dissect_rpc_uint32(tvb, lock_tree,\r\nhf_klm_len, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_lock(tvbuff_t *tvb, packet_info* pinfo, proto_tree *tree, int offset, rpc_call_info_value *civ)\r\n{\r\nproto_item* lock_item = NULL;\r\nproto_tree* lock_tree = NULL;\r\nlock_item = proto_tree_add_item(tree, hf_klm_lock, tvb,\r\noffset, -1, ENC_NA);\r\nlock_tree = proto_item_add_subtree(lock_item, ett_klm_lock);\r\noffset = dissect_rpc_string(tvb, lock_tree,\r\nhf_klm_servername, offset, NULL);\r\noffset = dissect_nfs3_fh(tvb, offset, pinfo, lock_tree,"fh", NULL, civ);\r\noffset = dissect_rpc_uint32(tvb, lock_tree,\r\nhf_klm_pid, offset);\r\noffset = dissect_rpc_uint32(tvb, lock_tree,\r\nhf_klm_offset, offset);\r\noffset = dissect_rpc_uint32(tvb, lock_tree,\r\nhf_klm_len, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_klm_unlock_call(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\nreturn dissect_lock(tvb, pinfo, tree, 0, (rpc_call_info_value*)data);\r\n}\r\nstatic int\r\ndissect_klm_stat_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nreturn dissect_rpc_uint32(tvb, tree, hf_klm_stats, 0);\r\n}\r\nstatic int\r\ndissect_klm_lock_call(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_bool( tvb, tree,\r\nhf_klm_block, offset);\r\noffset = dissect_rpc_bool( tvb, tree,\r\nhf_klm_exclusive, offset);\r\noffset = dissect_lock(tvb, pinfo, tree, offset, (rpc_call_info_value*)data);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_klm_test_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\ngint32 stats;\r\nint offset = 0;\r\nstats = tvb_get_ntohl(tvb, offset);\r\noffset = dissect_rpc_uint32(tvb, tree,\r\nhf_klm_stats, offset);\r\nif (stats == KLM_DENIED) {\r\noffset = dissect_holder(tvb, tree, offset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_klm_test_call(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_bool( tvb, tree,\r\nhf_klm_exclusive, offset);\r\noffset = dissect_lock(tvb, pinfo, tree, offset, (rpc_call_info_value*)data);\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_klm(void)\r\n{\r\nstatic struct true_false_string tfs_exclusive = { "Exclusive", "Not exclusive" };\r\nstatic struct true_false_string tfs_block = { "Block", "Do not block" };\r\nstatic hf_register_info hf[] = {\r\n{ &hf_klm_procedure_v1, {\r\n"V1 Procedure", "klm.procedure_v1", FT_UINT32, BASE_DEC,\r\nVALS(klm1_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_klm_exclusive, {\r\n"exclusive", "klm.exclusive", FT_BOOLEAN, BASE_NONE,\r\nTFS(&tfs_exclusive), 0x0, "Exclusive lock", HFILL }},\r\n{ &hf_klm_lock, {\r\n"lock", "klm.lock", FT_NONE, BASE_NONE,\r\nNULL, 0, "KLM lock structure", HFILL }},\r\n{ &hf_klm_servername, {\r\n"server name", "klm.servername", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_klm_pid, {\r\n"pid", "klm.pid", FT_UINT32, BASE_DEC,\r\nNULL, 0, "ProcessID", HFILL }},\r\n{ &hf_klm_offset, {\r\n"offset", "klm.offset", FT_UINT32, BASE_DEC,\r\nNULL, 0, "File offset", HFILL }},\r\n{ &hf_klm_len, {\r\n"length", "klm.len", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Length of lock region", HFILL }},\r\n{ &hf_klm_stats, {\r\n"stats", "klm.stats", FT_UINT32, BASE_DEC,\r\nVALS(names_klm_stats), 0, NULL, HFILL }},\r\n{ &hf_klm_holder, {\r\n"holder", "klm.holder", FT_NONE, BASE_NONE,\r\nNULL, 0, "KLM lock holder", HFILL }},\r\n{ &hf_klm_block, {\r\n"block", "klm.block", FT_BOOLEAN, BASE_NONE,\r\nTFS(&tfs_block), 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_klm,\r\n&ett_klm_lock,\r\n&ett_klm_holder,\r\n};\r\nproto_klm = proto_register_protocol("Kernel Lock Manager",\r\n"KLM", "klm");\r\nproto_register_field_array(proto_klm, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_klm(void)\r\n{\r\nrpc_init_prog(proto_klm, KLM_PROGRAM, ett_klm,\r\nG_N_ELEMENTS(klm_vers_info), klm_vers_info);\r\n}
