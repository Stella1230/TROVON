static proto_item *\r\ndissect_cbor_unsigned_integer(tvbuff_t *tvb, packet_info *pinfo, proto_tree *cbor_tree, gint *offset, guint8 type_minor)\r\n{\r\nproto_item *item;\r\nswitch (type_minor) {\r\ncase 0x18:\r\n*offset += 1;\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_uint8, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset += 1;\r\nreturn item;\r\ncase 0x19:\r\n*offset += 1;\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_uint16, tvb, *offset, 2, ENC_BIG_ENDIAN);\r\n*offset += 2;\r\nreturn item;\r\ncase 0x1a:\r\n*offset += 1;\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_uint32, tvb, *offset, 4, ENC_BIG_ENDIAN);\r\n*offset += 4;\r\nreturn item;\r\ncase 0x1b:\r\n*offset += 1;\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_uint64, tvb, *offset, 8, ENC_BIG_ENDIAN);\r\n*offset += 8;\r\nreturn item;\r\ndefault:\r\nif (type_minor <= 0x17) {\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_uints, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset += 1;\r\nreturn item;\r\n}\r\nexpert_add_info_format(pinfo, cbor_tree, &ei_cbor_invalid_minor_type,\r\n"invalid minor type %i in unsigned integer", type_minor);\r\nreturn NULL;\r\n}\r\n}\r\nstatic proto_item *\r\ndissect_cbor_negative_integer(tvbuff_t *tvb, packet_info *pinfo, proto_tree *cbor_tree, gint *offset, guint8 type_minor)\r\n{\r\ngint64 value;\r\nproto_item *item;\r\nswitch (type_minor) {\r\ncase 0x18:\r\n*offset += 1;\r\nvalue = (gint64)-1 - tvb_get_guint8(tvb, *offset);\r\nitem = proto_tree_add_int64(cbor_tree, hf_cbor_type_nint, tvb, *offset, 1, value);\r\n*offset += 1;\r\nreturn item;\r\ncase 0x19:\r\n*offset += 1;\r\nvalue = (gint64)-1 - tvb_get_ntohs(tvb, *offset);\r\nitem = proto_tree_add_int64(cbor_tree, hf_cbor_type_nint, tvb, *offset, 2, value);\r\n*offset += 2;\r\nreturn item;\r\ncase 0x1a:\r\n*offset += 1;\r\nvalue = (gint64)-1 - tvb_get_ntohl(tvb, *offset);\r\nitem = proto_tree_add_int64(cbor_tree, hf_cbor_type_nint, tvb, *offset, 4, value);\r\n*offset += 4;\r\nreturn item;\r\ncase 0x1b:\r\n*offset += 1;\r\nvalue = (gint64)-1 - tvb_get_ntoh64(tvb, *offset);\r\nif (value > -1) {\r\nexpert_add_info_format(pinfo, cbor_tree, &ei_cbor_too_long_length,\r\n"The value is too small, we can not display it correctly");\r\n}\r\nitem = proto_tree_add_int64(cbor_tree, hf_cbor_type_nint, tvb, *offset, 8, value);\r\n*offset += 8;\r\nreturn item;\r\ndefault:\r\nif (type_minor <= 0x17) {\r\nvalue = -1 - type_minor;\r\nitem = proto_tree_add_int64(cbor_tree, hf_cbor_type_nint, tvb, *offset, 1, value);\r\n*offset += 1;\r\nreturn item;\r\n}\r\nexpert_add_info_format(pinfo, cbor_tree, &ei_cbor_invalid_minor_type,\r\n"invalid minor type %i in negative integer", type_minor);\r\nreturn NULL;\r\n}\r\n}\r\nstatic proto_item *\r\ndissect_cbor_byte_string(tvbuff_t *tvb, packet_info *pinfo, proto_tree *cbor_tree, gint *offset, guint8 type_minor)\r\n{\r\nguint64 length;\r\ngint eof_type;\r\nproto_tree *subtree;\r\nproto_item *item;\r\nproto_item *elem;\r\nswitch (type_minor) {\r\ncase 0x18:\r\n*offset += 1;\r\nlength = tvb_get_guint8(tvb, *offset);\r\n*offset += 1;\r\nbreak;\r\ncase 0x19:\r\n*offset += 1;\r\nlength = tvb_get_ntohs(tvb, *offset);\r\n*offset += 2;\r\nbreak;\r\ncase 0x1a:\r\n*offset += 1;\r\nlength = tvb_get_ntohl(tvb, *offset);\r\n*offset += 4;\r\nbreak;\r\ncase 0x1b:\r\n*offset += 1;\r\nlength = tvb_get_ntoh64(tvb, *offset);\r\n*offset += 8;\r\nbreak;\r\ncase 0x1f:\r\n*offset += 1;\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_byte_string_undef, tvb, *offset, 1, ENC_NA);\r\nsubtree = proto_item_add_subtree(item, ett_cbor_byte_string_undef);\r\nwhile (1)\r\n{\r\neof_type = tvb_get_guint8(tvb, *offset);\r\nif (eof_type == 0xff) {\r\n*offset += 1;\r\nproto_item_set_end(item, tvb, *offset);\r\nreturn item;\r\n}\r\nif (((eof_type & 0xe0) >> 5) != CBOR_TYPE_BYTE_STRING) {\r\nexpert_add_info_format(pinfo, cbor_tree, &ei_cbor_invalid_element,\r\n"invalid element %i, expected byte string", (eof_type & 0xe0) >> 5);\r\nreturn NULL;\r\n}\r\nelem = dissect_cbor_byte_string(tvb, pinfo, subtree, offset, eof_type & 0x1f);\r\nif (!elem)\r\nreturn NULL;\r\n}\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nreturn item;\r\ndefault:\r\nif (type_minor <= 0x17) {\r\nlength = type_minor;\r\n*offset += 1;\r\nbreak;\r\n}\r\nexpert_add_info_format(pinfo, cbor_tree, &ei_cbor_invalid_minor_type,\r\n"invalid minor type %i in byte string", type_minor);\r\nreturn NULL;\r\n}\r\nif (length > G_MAXINT32 || *offset + (gint)length < *offset) {\r\nexpert_add_info_format(pinfo, cbor_tree, &ei_cbor_too_long_length,\r\n"the length (%" G_GUINT64_FORMAT ") of the byte string too long", length);\r\nreturn NULL;\r\n}\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_byte_string, tvb, *offset, (gint)length, ENC_BIG_ENDIAN|ENC_NA);\r\n*offset += (gint)length;\r\nreturn item;\r\n}\r\nstatic proto_item *\r\ndissect_cbor_text_string(tvbuff_t *tvb, packet_info *pinfo, proto_tree *cbor_tree, gint *offset, guint8 type_minor)\r\n{\r\nguint64 length = 0;\r\ngint eof_type;\r\nproto_tree *subtree;\r\nproto_item *item;\r\nproto_item *elem;\r\nswitch (type_minor) {\r\ncase 0x18:\r\n*offset += 1;\r\nlength = tvb_get_guint8(tvb, *offset);\r\n*offset += 1;\r\nbreak;\r\ncase 0x19:\r\n*offset += 1;\r\nlength = tvb_get_ntohs(tvb, *offset);\r\n*offset += 2;\r\nbreak;\r\ncase 0x1a:\r\n*offset += 1;\r\nlength = tvb_get_ntohl(tvb, *offset);\r\n*offset += 4;\r\nbreak;\r\ncase 0x1b:\r\n*offset += 1;\r\nlength = tvb_get_ntoh64(tvb, *offset);\r\n*offset += 8;\r\nbreak;\r\ncase 0x1f:\r\n*offset += 1;\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_text_string_undef, tvb, *offset, 1, ENC_NA);\r\nsubtree = proto_item_add_subtree(item, ett_cbor_text_string_undef);\r\nwhile (1)\r\n{\r\neof_type = tvb_get_guint8(tvb, *offset);\r\nif (eof_type == 0xff) {\r\n*offset += 1;\r\nproto_item_set_end(item, tvb, *offset);\r\nreturn item;\r\n}\r\nif (((eof_type & 0xe0) >> 5) != CBOR_TYPE_TEXT_STRING) {\r\nexpert_add_info_format(pinfo, cbor_tree, &ei_cbor_invalid_element,\r\n"invalid element %i, expected text string", (eof_type & 0xe0) >> 5);\r\nreturn NULL;\r\n}\r\nelem = dissect_cbor_text_string(tvb, pinfo, subtree, offset, eof_type & 0x1f);\r\nif (!elem)\r\nreturn NULL;\r\n}\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nreturn item;\r\ndefault:\r\nif (type_minor <= 0x17) {\r\nlength = type_minor;\r\n*offset += 1;\r\nbreak;\r\n}\r\nexpert_add_info_format(pinfo, cbor_tree, &ei_cbor_invalid_minor_type,\r\n"invalid minor type %i in text string", type_minor);\r\nreturn NULL;\r\n}\r\nif (length > G_MAXINT32 || *offset + (gint)length < *offset) {\r\nexpert_add_info_format(pinfo, cbor_tree, &ei_cbor_too_long_length,\r\n"the length (%" G_GUINT64_FORMAT ") of the text string too long", length);\r\nreturn NULL;\r\n}\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_text_string, tvb, *offset, (gint)length, ENC_BIG_ENDIAN|ENC_UTF_8);\r\n*offset += (gint)length;\r\nreturn item;\r\n}\r\nstatic proto_item *\r\ndissect_cbor_array(tvbuff_t *tvb, packet_info *pinfo, proto_tree *cbor_tree, gint *offset, guint8 type_minor)\r\n{\r\nguint64 length = 0;\r\nguint64 i;\r\ngint orig_offset = *offset;\r\nproto_tree *subtree;\r\nproto_item *item;\r\nproto_item *elem;\r\ngboolean eof = 0;\r\nswitch (type_minor) {\r\ncase 0x18:\r\n*offset += 1;\r\nlength = tvb_get_guint8(tvb, *offset);\r\n*offset += 1;\r\nbreak;\r\ncase 0x19:\r\n*offset += 1;\r\nlength = tvb_get_ntohs(tvb, *offset);\r\n*offset += 2;\r\nbreak;\r\ncase 0x1a:\r\n*offset += 1;\r\nlength = tvb_get_ntohl(tvb, *offset);\r\n*offset += 4;\r\nbreak;\r\ncase 0x1b:\r\n*offset += 1;\r\nlength = tvb_get_ntoh64(tvb, *offset);\r\n*offset += 8;\r\nbreak;\r\ncase 0x1f:\r\n*offset += 1;\r\nlength = INT_MAX;\r\neof = 1;\r\nbreak;\r\ndefault:\r\nif (type_minor <= 0x17) {\r\nlength = type_minor;\r\n*offset += 1;\r\nbreak;\r\n}\r\nexpert_add_info_format(pinfo, cbor_tree, &ei_cbor_invalid_minor_type,\r\n"invalid minor type %i in array", type_minor);\r\nreturn NULL;\r\n}\r\nif (eof) {\r\nitem = proto_tree_add_string_format_value(cbor_tree, hf_cbor_type_array,\r\ntvb, orig_offset, -1, "Array", "(undefined elements)");\r\n} else {\r\nitem = proto_tree_add_string_format_value(cbor_tree, hf_cbor_type_array,\r\ntvb, orig_offset, -1, "Array", "(%"G_GINT64_MODIFIER"u elements)", length);\r\n}\r\nsubtree = proto_item_add_subtree(item, ett_cbor_array);\r\nfor (i = 0; i < length; i++)\r\n{\r\nif (eof) {\r\ngint value = tvb_get_guint8(tvb, *offset);\r\nif (value == 0xff) {\r\n*offset += 1;\r\nbreak;\r\n}\r\n}\r\nelem = dissect_cbor_main_type(tvb, pinfo, subtree, offset);\r\nif (!elem)\r\nreturn NULL;\r\n}\r\nproto_item_set_end(item, tvb, *offset);\r\nreturn item;\r\n}\r\nstatic proto_item *\r\ndissect_cbor_map(tvbuff_t *tvb, packet_info *pinfo, proto_tree *cbor_tree, gint *offset, guint8 type_minor)\r\n{\r\nguint64 length = 0;\r\nguint64 i;\r\ngint orig_offset = *offset;\r\nproto_tree *subtree;\r\nproto_item *item;\r\ngboolean eof = 0;\r\nproto_tree *key_tree;\r\nproto_item *key;\r\nswitch (type_minor) {\r\ncase 0x18:\r\n*offset += 1;\r\nlength = tvb_get_guint8(tvb, *offset);\r\n*offset += 1;\r\nbreak;\r\ncase 0x19:\r\n*offset += 1;\r\nlength = tvb_get_ntohs(tvb, *offset);\r\n*offset += 2;\r\nbreak;\r\ncase 0x1a:\r\n*offset += 1;\r\nlength = tvb_get_ntohl(tvb, *offset);\r\n*offset += 4;\r\nbreak;\r\ncase 0x1b:\r\n*offset += 1;\r\nlength = tvb_get_ntoh64(tvb, *offset);\r\n*offset += 8;\r\nbreak;\r\ncase 0x1f:\r\n*offset += 1;\r\nlength = INT_MAX;\r\neof = 1;\r\nbreak;\r\ndefault:\r\nif (type_minor <= 0x17) {\r\nlength = type_minor;\r\n*offset += 1;\r\nbreak;\r\n}\r\nexpert_add_info_format(pinfo, cbor_tree, &ei_cbor_invalid_minor_type,\r\n"invalid minor type %i in map", type_minor);\r\nreturn NULL;\r\n}\r\nif (eof) {\r\nitem = proto_tree_add_string_format_value(cbor_tree, hf_cbor_type_map,\r\ntvb, orig_offset, -1, "Map", "(undefined entries)");\r\n} else {\r\nitem = proto_tree_add_string_format_value(cbor_tree, hf_cbor_type_map,\r\ntvb, orig_offset, -1, "Map", "(%"G_GINT64_MODIFIER"u entries)", length);\r\n}\r\nsubtree = proto_item_add_subtree(item, ett_cbor_map);\r\nfor (i = 0; i < length; i++)\r\n{\r\nif (eof) {\r\ngint value = tvb_get_guint8(tvb, *offset);\r\nif (value == 0xff) {\r\n*offset += 1;\r\nbreak;\r\n}\r\n}\r\nkey = dissect_cbor_main_type(tvb, pinfo, subtree, offset);\r\nif (!key)\r\nreturn NULL;\r\nkey_tree = proto_item_add_subtree(key, ett_cbor_map_entry);\r\nkey = dissect_cbor_main_type(tvb, pinfo, key_tree, offset);\r\nif (!key)\r\nreturn NULL;\r\n}\r\nproto_item_set_end(item, tvb, *offset);\r\nreturn item;\r\n}\r\nstatic proto_item *\r\ndissect_cbor_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *cbor_tree, gint *offset, guint8 type_minor)\r\n{\r\nproto_item *item;\r\nproto_item *tagged;\r\nproto_tree *tagged_tree;\r\nswitch (type_minor) {\r\ncase 0x18:\r\n*offset += 1;\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_tag8, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset += 1;\r\nbreak;\r\ncase 0x19:\r\n*offset += 1;\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_tag16, tvb, *offset, 2, ENC_BIG_ENDIAN);\r\n*offset += 2;\r\nbreak;\r\ncase 0x1a:\r\n*offset += 1;\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_tag32, tvb, *offset, 4, ENC_BIG_ENDIAN);\r\n*offset += 4;\r\nbreak;\r\ncase 0x1b:\r\n*offset += 1;\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_tag64, tvb, *offset, 8, ENC_BIG_ENDIAN);\r\n*offset += 8;\r\nbreak;\r\ndefault:\r\nif (type_minor <= 0x17) {\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_tags, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset += 1;\r\nbreak;\r\n}\r\nexpert_add_info_format(pinfo, cbor_tree, &ei_cbor_invalid_minor_type,\r\n"invalid minor type %i in tag", type_minor);\r\nreturn NULL;\r\n}\r\ntagged_tree = proto_item_add_subtree(item, ett_cbor_tag);\r\ntagged = dissect_cbor_main_type(tvb, pinfo, tagged_tree, offset);\r\nif (!tagged)\r\nreturn NULL;\r\nreturn item;\r\n}\r\nstatic proto_item *decode_half(tvbuff_t *tvb, proto_tree *tree, gint *offset, int hfindex) {\r\nint half, exponent, mantissa;\r\nfloat val;\r\nproto_item *item;\r\nhalf = tvb_get_ntohs(tvb, *offset);\r\nexponent = (half >> 10) & 0x1f;\r\nmantissa = half & 0x3ff;\r\nif (exponent == 0) {\r\nval = ldexpf((float)mantissa, -24);\r\nitem = proto_tree_add_float(tree, hfindex, tvb, *offset, 2,\r\nhalf & 0x8000 ? -val : val);\r\n} else if (exponent != 31) {\r\nval = ldexpf((float)(mantissa + 1024), exponent - 25);\r\nitem = proto_tree_add_float(tree, hfindex, tvb, *offset, 2,\r\nhalf & 0x8000 ? -val : val);\r\n} else {\r\nitem = proto_tree_add_float_format_value(tree, hfindex, tvb, *offset, 2,\r\n0, "%s", mantissa == 0 ? "INFINITY" : "NAN");\r\n}\r\n*offset += 2;\r\nreturn item;\r\n}\r\nstatic proto_item *\r\ndissect_cbor_float_simple_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *cbor_tree, gint *offset, guint8 type_minor)\r\n{\r\nproto_item *item;\r\nswitch (type_minor) {\r\ncase 0x18:\r\n*offset += 1;\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_simple_data8, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset += 1;\r\nreturn item;\r\ncase 0x19:\r\n*offset += 1;\r\nitem = decode_half(tvb, cbor_tree, offset, hf_cbor_type_float16);\r\nreturn item;\r\ncase 0x1a:\r\n*offset += 1;\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_float32, tvb, *offset, 4, ENC_BIG_ENDIAN);\r\n*offset += 4;\r\nreturn item;\r\ncase 0x1b:\r\n*offset += 1;\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_float64, tvb, *offset, 8, ENC_BIG_ENDIAN);\r\n*offset += 8;\r\nreturn item;\r\ndefault:\r\nif (type_minor <= 0x17) {\r\nitem = proto_tree_add_item(cbor_tree, hf_cbor_type_simple_datas, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset += 1;\r\nreturn item;\r\n}\r\nexpert_add_info_format(pinfo, cbor_tree, &ei_cbor_invalid_minor_type,\r\n"invalid minor type %i in fimple data and float", type_minor);\r\nreturn NULL;\r\n}\r\n}\r\nstatic proto_item *\r\ndissect_cbor_main_type(tvbuff_t *tvb, packet_info *pinfo, proto_tree *cbor_tree, gint *offset)\r\n{\r\nguint8 type;\r\nguint8 type_major;\r\nguint8 type_minor;\r\ntype = tvb_get_guint8(tvb, *offset);\r\ntype_major = (type & 0xe0) >> 5;\r\ntype_minor = (type & 0x1f);\r\nswitch (type_major) {\r\ncase CBOR_TYPE_USIGNED_INT:\r\nreturn dissect_cbor_unsigned_integer(tvb, pinfo, cbor_tree, offset, type_minor);\r\ncase CBOR_TYPE_NEGATIVE_INT:\r\nreturn dissect_cbor_negative_integer(tvb, pinfo, cbor_tree, offset, type_minor);\r\ncase CBOR_TYPE_BYTE_STRING:\r\nreturn dissect_cbor_byte_string(tvb, pinfo, cbor_tree, offset, type_minor);\r\ncase CBOR_TYPE_TEXT_STRING:\r\nreturn dissect_cbor_text_string(tvb, pinfo, cbor_tree, offset, type_minor);\r\ncase CBOR_TYPE_ARRAY:\r\nreturn dissect_cbor_array(tvb, pinfo, cbor_tree, offset, type_minor);\r\ncase CBOR_TYPE_MAP:\r\nreturn dissect_cbor_map(tvb, pinfo, cbor_tree, offset, type_minor);\r\ncase CBOR_TYPE_TAGGED:\r\nreturn dissect_cbor_tag(tvb, pinfo, cbor_tree, offset, type_minor);\r\ncase CBOR_TYPE_FLOAT:\r\nreturn dissect_cbor_float_simple_data(tvb, pinfo, cbor_tree, offset, type_minor);\r\n}\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nreturn NULL;\r\n}\r\nstatic int\r\ndissect_cbor(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data _U_)\r\n{\r\ngint offset = 0;\r\nproto_item *cbor_root;\r\nproto_tree *cbor_tree;\r\ncbor_root = proto_tree_add_item(parent_tree, proto_cbor, tvb, offset, -1, ENC_NA);\r\ncbor_tree = proto_item_add_subtree(cbor_root, ett_cbor);\r\ndissect_cbor_main_type(tvb, pinfo, cbor_tree, &offset);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_cbor(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_cbor_type_uints,\r\n{ "Unsigned Integer", "cbor.type.uints",\r\nFT_UINT8, BASE_DEC, NULL, 0x1f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_uint8,\r\n{ "Unsigned Integer", "cbor.type.uint8",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_uint16,\r\n{ "Unsigned Integer", "cbor.type.uint16",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_uint32,\r\n{ "Unsigned Integer", "cbor.type.uint32",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_uint64,\r\n{ "Unsigned Integer", "cbor.type.uint64",\r\nFT_UINT64, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_nint,\r\n{ "Negative Integer", "cbor.type.nint",\r\nFT_INT64, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_byte_string,\r\n{ "Byte String", "cbor.type.bytestring",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_byte_string_undef,\r\n{ "Byte String (undefined length)", "cbor.type.bytestring.undef",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_text_string,\r\n{ "Text String", "cbor.type.textstring",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_text_string_undef,\r\n{ "Text String (undefined length)", "cbor.type.textstring.undef",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_array,\r\n{ "Array", "cbor.type.array",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_map,\r\n{ "Map", "cbor.type.map",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_tags,\r\n{ "Tag", "cbor.type.tags",\r\nFT_UINT8, BASE_DEC, VALS(vals_tags), 0x1f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_tag8,\r\n{ "Tag", "cbor.type.tag8",\r\nFT_UINT8, BASE_DEC, VALS(vals_tags), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_tag16,\r\n{ "Tag", "cbor.type.tag16",\r\nFT_UINT16, BASE_DEC, VALS(vals_tags), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_tag32,\r\n{ "Tag", "cbor.type.tag32",\r\nFT_UINT32, BASE_DEC, VALS(vals_tags), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_tag64,\r\n{ "Tag", "cbor.type.tag64",\r\nFT_UINT64, BASE_DEC|BASE_VAL64_STRING, VALS64(vals64_tags), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_simple_datas,\r\n{ "Simple data", "cbor.type.simple_datas",\r\nFT_UINT8, BASE_DEC, VALS(vals_simple_data), 0x1f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_simple_data8,\r\n{ "Simple data", "cbor.type.simple_data8",\r\nFT_UINT8, BASE_DEC, VALS(vals_simple_data), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_float16,\r\n{ "Float 16 Bit", "cbor.type.float16",\r\nFT_FLOAT, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_float32,\r\n{ "Float 32 Bit", "cbor.type.float32",\r\nFT_FLOAT, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cbor_type_float64,\r\n{ "Float 64 Bit", "cbor.type.float64",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_cbor,\r\n&ett_cbor_byte_string_undef,\r\n&ett_cbor_text_string_undef,\r\n&ett_cbor_array,\r\n&ett_cbor_map,\r\n&ett_cbor_map_entry,\r\n&ett_cbor_tag,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_cbor_invalid_minor_type,\r\n{ "cbor.invalid_minor_type", PI_MALFORMED, PI_WARN, "Invalid minor type", EXPFILL }},\r\n{ &ei_cbor_invalid_element,\r\n{ "cbor.invalid_element", PI_MALFORMED, PI_WARN, "Invalid element", EXPFILL }},\r\n{ &ei_cbor_too_long_length,\r\n{ "cbor.too_long_length", PI_MALFORMED, PI_WARN, "Too long length", EXPFILL }},\r\n};\r\nexpert_module_t *expert_cbor;\r\nproto_cbor = proto_register_protocol("Concise Binary Object Representation", "CBOR", "cbor");\r\nproto_register_field_array(proto_cbor, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_cbor = expert_register_protocol(proto_cbor);\r\nexpert_register_field_array(expert_cbor, ei, array_length(ei));\r\ncbor_handle = register_dissector("cbor", dissect_cbor, proto_cbor);\r\n}\r\nvoid\r\nproto_reg_handoff_cbor(void)\r\n{\r\ndissector_add_string("media_type", "application/cbor", cbor_handle);\r\n}
