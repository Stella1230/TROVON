static void\r\ndissect_ipmb_state_notify(tvbuff_t * tvb, proto_tree * tree)\r\n{\r\nproto_tree_add_item(tree, hf_trace_notify_format,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, 1,\r\nhf_trace_ipmb_state, ett_trace_ipmb_state,\r\nbits_chn_state_info, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic int\r\ndissect_ipmi_trace(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nguint block_type, chn_num, data_type, tmp;\r\ntvbuff_t * next_tvb;\r\nif (tvb_captured_length(tvb) < 11) {\r\ncall_data_dissector(tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\ntmp = tvb_get_guint8(tvb, 0);\r\nblock_type = (tmp >> 4) & 3;\r\nchn_num = tmp & 0xF;\r\ndata_type = tvb_get_guint8(tvb, 7);\r\ncol_add_fstr(pinfo->cinfo, COL_DEF_SRC, "Channel %d", chn_num);\r\ncol_add_str(pinfo->cinfo, COL_PROTOCOL,\r\nval_to_str(data_type, str_protocol_types,\r\n"Reserved (0x%02x)"));\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (block_type == HPM2_TRACE_PACKET_DATA) {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Trace Packet Data");\r\n} else if (block_type == HPM2_CHN_STATE_NOTIFY) {\r\ncol_set_str(pinfo->cinfo, COL_INFO,\r\n"Channel State Change Notification");\r\n} else if (block_type == HPM2_EMBED_ASCII_MSG) {\r\nchar str[257];\r\nguint str_len = tvb_get_guint8(tvb, 10);\r\nif (str_len) {\r\ntvb_memcpy(tvb, str, 11, str_len);\r\nstr[str_len] = 0;\r\ncol_add_str(pinfo->cinfo, COL_INFO, str);\r\n}\r\n} else {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Reserved");\r\n}\r\nif ( tree ) {\r\nproto_item * ti;\r\nproto_tree * trace_tree;\r\nproto_tree * stamp_tree;\r\nnstime_t timestamp;\r\nti = proto_tree_add_item(tree, proto_ipmi_trace, tvb, 0, -1, ENC_NA);\r\ntrace_tree = proto_item_add_subtree(ti, ett_ipmi_trace);\r\nproto_tree_add_bitmask(trace_tree, tvb, 0, hf_trace_block_type,\r\nett_trace_block_type, bits_trace_block_type,\r\nENC_LITTLE_ENDIAN);\r\ntimestamp.secs = tvb_get_letohl(tvb, 1);\r\ntimestamp.nsecs = (int) tvb_get_letohs(tvb, 5) * 1000000;\r\nti = proto_tree_add_time(trace_tree, hf_trace_timestamp, tvb, 1,\r\n6, &timestamp);\r\nstamp_tree = proto_item_add_subtree(ti, ett_trace_timestamp);\r\nproto_tree_add_item(stamp_tree, hf_trace_timestamp_sec,\r\ntvb, 1, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(stamp_tree, hf_trace_timestamp_msec,\r\ntvb, 5, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(trace_tree, hf_trace_data_type,\r\ntvb, 7, 1, ENC_LITTLE_ENDIAN);\r\nif (data_type == IPMI_PROTO_IPMB_1_0) {\r\nproto_tree_add_bitmask(trace_tree, tvb, 8,\r\nhf_trace_protocol_data, ett_trace_protocol_data,\r\nbits_ipmb_protocol_data, ENC_LITTLE_ENDIAN);\r\n} else if (data_type == IPMI_PROTO_KCS\r\n|| data_type == IPMI_PROTO_SMIC\r\n|| data_type == IPMI_PROTO_BT_10\r\n|| data_type == IPMI_PROTO_BT_15) {\r\nproto_tree_add_bitmask(trace_tree, tvb, 8,\r\nhf_trace_protocol_data, ett_trace_protocol_data,\r\nbits_host_protocol_data, ENC_LITTLE_ENDIAN);\r\n} else {\r\nproto_tree_add_item(trace_tree, hf_trace_protocol_data, tvb,\r\n8, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nproto_tree_add_item(trace_tree, hf_trace_data_len, tvb,\r\n10, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nnext_tvb = tvb_new_subset_remaining(tvb, 11);\r\nif (block_type == HPM2_TRACE_PACKET_DATA) {\r\nipmi_dissect_arg_t arg;\r\narg.context = IPMI_E_NONE;\r\narg.channel = chn_num;\r\narg.flags = tvb_get_guint8(tvb, 8);\r\nif (!dissector_try_uint_new(proto_dissector_table,\r\ndata_type, next_tvb, pinfo, tree, TRUE, &arg)) {\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\n} else if (block_type == HPM2_CHN_STATE_NOTIFY\r\n&& data_type == IPMI_PROTO_IPMB_1_0) {\r\ndissect_ipmb_state_notify(next_tvb, tree);\r\n} else {\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ipmi_trace(void)\r\n{\r\nproto_ipmi_trace = proto_register_protocol("IPMI Trace Data Collection",\r\n"ipmi-trace", "ipmi.trace");\r\nproto_register_field_array(proto_ipmi_trace, ipmi_trace_hf,\r\narray_length(ipmi_trace_hf));\r\nproto_register_subtree_array(ipmi_trace_ett,\r\narray_length(ipmi_trace_ett));\r\nproto_dissector_table = register_dissector_table("ipmi.protocol",\r\n"IPMI Channel Protocol Type", proto_ipmi_trace, FT_UINT8, BASE_HEX);\r\n}\r\nvoid\r\nproto_reg_handoff_ipmi_trace(void)\r\n{\r\ndissector_handle_t ipmi_trace_handle;\r\nipmi_trace_handle = create_dissector_handle(dissect_ipmi_trace,\r\nproto_ipmi_trace);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_IPMI_TRACE, ipmi_trace_handle);\r\ndissector_add_uint("ipmi.protocol", IPMI_PROTO_IPMB_1_0,\r\nfind_dissector("ipmb"));\r\ndissector_add_uint("ipmi.protocol", IPMI_PROTO_KCS,\r\nfind_dissector("kcs"));\r\ndissector_add_uint("ipmi.protocol", IPMI_PROTO_TMODE,\r\nfind_dissector("tmode"));\r\n}
