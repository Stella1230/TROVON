static int\r\ndissect_v120(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *v120_tree, *address_tree;\r\nproto_item *ti, *tc;\r\nint is_response;\r\nint v120len;\r\nguint8 byte0, byte1;\r\nguint16 control;\r\ntvbuff_t *next_tvb;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "V.120");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nbyte0 = tvb_get_guint8(tvb, 0);\r\ncol_add_fstr(pinfo->cinfo, COL_RES_DL_SRC, "0x%02X", byte0);\r\nbyte1 = tvb_get_guint8(tvb, 1);\r\nif ( ((byte0 & 0x01) != 0x00) && ((byte1 & 0x01) != 0x01) )\r\n{\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Invalid V.120 frame");\r\nif (tree)\r\nproto_tree_add_protocol_format(tree, proto_v120, tvb, 0, -1,\r\n"Invalid V.120 frame");\r\nreturn 2;\r\n}\r\nif (pinfo->p2p_dir == P2P_DIR_SENT) {\r\nis_response = (byte0 & 0x02) ? FALSE: TRUE;\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_DST, "DCE");\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_SRC, "DTE");\r\n} else {\r\nis_response = (byte0 & 0x02) ? TRUE : FALSE;\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_DST, "DTE");\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_SRC, "DCE");\r\n}\r\nti = proto_tree_add_protocol_format(tree, proto_v120, tvb, 0, -1, "V.120");\r\nv120_tree = proto_item_add_subtree(ti, ett_v120);\r\ntc = proto_tree_add_item(v120_tree, hf_v120_address, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(tc, "LLI: %d C/R: %s",\r\n((byte0 & 0xfc) << 5) | ((byte1 & 0xfe) >> 1),\r\nbyte0 & 0x02 ? "R" : "C");\r\naddress_tree = proto_item_add_subtree(tc, ett_v120_address);\r\nproto_tree_add_item(address_tree, hf_v120_rc, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(address_tree, hf_v120_lli, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(address_tree, hf_v120_ea0, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(address_tree, hf_v120_ea1, tvb, 0, 2, ENC_BIG_ENDIAN);\r\ncontrol = dissect_xdlc_control(tvb, 2, pinfo, v120_tree, hf_v120_control,\r\nett_v120_control, &v120_cf_items, &v120_cf_items_ext,\r\nNULL, NULL, is_response, TRUE, FALSE);\r\nv120len = 2 + XDLC_CONTROL_LEN(control, TRUE);\r\nif (tvb_bytes_exist(tvb, v120len, 1))\r\nv120len += dissect_v120_header(tvb, v120len, v120_tree);\r\nproto_item_set_len(ti, v120len);\r\nnext_tvb = tvb_new_subset_remaining(tvb, v120len);\r\ncall_data_dissector(next_tvb, pinfo, v120_tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_v120_header(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nint header_len;\r\nguint8 byte0;\r\nproto_tree *h_tree;\r\nproto_item *tc;\r\nbyte0 = tvb_get_guint8(tvb, offset);\r\nif (byte0 & 0x80) {\r\nheader_len = 1;\r\ntc = proto_tree_add_item(tree, hf_v120_header8, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nh_tree = proto_item_add_subtree(tc, ett_v120_header);\r\nproto_tree_add_item(h_tree, hf_v120_header_ext8, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(h_tree, hf_v120_header_break8, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(h_tree, hf_v120_header_error_control8, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h_tree, hf_v120_header_segb8, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(h_tree, hf_v120_header_segf8, tvb, 0, 1, ENC_NA);\r\n} else {\r\nheader_len = 2;\r\ntc = proto_tree_add_item(tree, hf_v120_header16, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nh_tree = proto_item_add_subtree(tc, ett_v120_header);\r\nproto_tree_add_item(h_tree, hf_v120_header_ext16, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h_tree, hf_v120_header_break16, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h_tree, hf_v120_header_error_control16, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h_tree, hf_v120_header_segb16, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h_tree, hf_v120_header_segf16, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h_tree, hf_v120_header_e, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h_tree, hf_v120_header_dr, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h_tree, hf_v120_header_sr, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h_tree, hf_v120_header_rr, tvb, 0, 2, ENC_BIG_ENDIAN);\r\n}\r\nproto_item_append_text(tc, " B: %d F: %d",\r\nbyte0 & 0x02 ? 1:0, byte0 & 0x01 ? 1:0);\r\nreturn header_len;\r\n}\r\nvoid\r\nproto_register_v120(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_v120_address,\r\n{ "Link Address", "v120.address", FT_UINT16, BASE_HEX, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_v120_rc,\r\n{ "R/C", "v120.rc", FT_BOOLEAN, 16, TFS(&tfs_response_command),\r\n0x0002, NULL, HFILL }},\r\n{ &hf_v120_lli,\r\n{ "LLI", "v120.lli", FT_UINT16, BASE_HEX, NULL,\r\n0xfefc, NULL, HFILL }},\r\n{ &hf_v120_ea0,\r\n{ "EA0", "v120.ea0", FT_BOOLEAN, 16, TFS(&tfs_error_ok),\r\n0x0001, NULL, HFILL }},\r\n{ &hf_v120_ea1,\r\n{ "EA1", "v120.ea1", FT_BOOLEAN, 16, TFS(&tfs_ok_error),\r\n0x0100, NULL, HFILL }},\r\n{ &hf_v120_control,\r\n{ "Control Field", "v120.control", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_v120_n_r,\r\n{ "N(R)", "v120.control.n_r", FT_UINT16, BASE_DEC,\r\nNULL, XDLC_N_R_EXT_MASK, NULL, HFILL }},\r\n{ &hf_v120_n_s,\r\n{ "N(S)", "v120.control.n_s", FT_UINT16, BASE_DEC,\r\nNULL, XDLC_N_S_EXT_MASK, NULL, HFILL }},\r\n{ &hf_v120_p,\r\n{ "Poll", "v120.control.p", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), XDLC_P_F, NULL, HFILL }},\r\n{ &hf_v120_p_ext,\r\n{ "Poll", "v120.control.p", FT_BOOLEAN, 16,\r\nTFS(&tfs_set_notset), XDLC_P_F_EXT, NULL, HFILL }},\r\n{ &hf_v120_f,\r\n{ "Final", "v120.control.f", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), XDLC_P_F, NULL, HFILL }},\r\n{ &hf_v120_f_ext,\r\n{ "Final", "v120.control.f", FT_BOOLEAN, 16,\r\nTFS(&tfs_set_notset), XDLC_P_F_EXT, NULL, HFILL }},\r\n{ &hf_v120_s_ftype,\r\n{ "Supervisory frame type", "v120.control.s_ftype", FT_UINT16, BASE_HEX,\r\nVALS(stype_vals), XDLC_S_FTYPE_MASK, NULL, HFILL }},\r\n{ &hf_v120_u_modifier_cmd,\r\n{ "Command", "v120.control.u_modifier_cmd", FT_UINT8, BASE_HEX,\r\nVALS(modifier_vals_cmd), XDLC_U_MODIFIER_MASK, NULL, HFILL }},\r\n{ &hf_v120_u_modifier_resp,\r\n{ "Response", "v120.control.u_modifier_resp", FT_UINT8, BASE_HEX,\r\nVALS(modifier_vals_resp), XDLC_U_MODIFIER_MASK, NULL, HFILL }},\r\n{ &hf_v120_ftype_i,\r\n{ "Frame type", "v120.control.ftype", FT_UINT16, BASE_HEX,\r\nVALS(ftype_vals), XDLC_I_MASK, NULL, HFILL }},\r\n{ &hf_v120_ftype_s_u,\r\n{ "Frame type", "v120.control.ftype", FT_UINT8, BASE_HEX,\r\nVALS(ftype_vals), XDLC_S_U_MASK, NULL, HFILL }},\r\n{ &hf_v120_ftype_s_u_ext,\r\n{ "Frame type", "v120.control.ftype", FT_UINT16, BASE_HEX,\r\nVALS(ftype_vals), XDLC_S_U_MASK, NULL, HFILL }},\r\n{ &hf_v120_header8,\r\n{ "Header", "v120.header", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_v120_header_ext8,\r\n{ "Extension octet", "v120.header.ext", FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x80,\r\nNULL, HFILL }},\r\n{ &hf_v120_header_break8,\r\n{ "Break condition", "v120.header.break", FT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x40,\r\nNULL, HFILL }},\r\n{ &hf_v120_header_error_control8,\r\n{ "Error control C1/C2", "v120.error_control", FT_UINT8, BASE_HEX, NULL, 0x0C,\r\nNULL, HFILL }},\r\n{ &hf_v120_header_segb8,\r\n{ "Bit B", "v120.header.segb", FT_BOOLEAN, 8, TFS(&tfs_segmentation_no_segmentation), 0x02,\r\nNULL, HFILL }},\r\n{ &hf_v120_header_segf8,\r\n{ "Bit F", "v120.header.segf", FT_BOOLEAN, 8, TFS(&tfs_segmentation_no_segmentation), 0x01,\r\nNULL, HFILL }},\r\n{ &hf_v120_header16,\r\n{ "Header", "v120.header", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_v120_header_ext16,\r\n{ "Extension octet", "v120.header.ext", FT_BOOLEAN, 16, TFS(&tfs_yes_no), 0x80,\r\nNULL, HFILL }},\r\n{ &hf_v120_header_break16,\r\n{ "Break condition", "v120.header.break", FT_BOOLEAN, 16, TFS(&tfs_yes_no), 0x40,\r\nNULL, HFILL }},\r\n{ &hf_v120_header_error_control16,\r\n{ "Error control C1/C2", "v120.error_control", FT_UINT16, BASE_HEX, NULL, 0x0C,\r\nNULL, HFILL }},\r\n{ &hf_v120_header_segb16,\r\n{ "Bit B", "v120.header.segb", FT_BOOLEAN, 16, TFS(&tfs_segmentation_no_segmentation), 0x02,\r\nNULL, HFILL }},\r\n{ &hf_v120_header_segf16,\r\n{ "Bit F", "v120.header.segf", FT_BOOLEAN, 16, TFS(&tfs_segmentation_no_segmentation), 0x01,\r\nNULL, HFILL }},\r\n{ &hf_v120_header_e,\r\n{ "E", "v120.header.e", FT_BOOLEAN, 16, TFS(&tfs_yes_no), 0x8000,\r\nNULL, HFILL }},\r\n{ &hf_v120_header_dr,\r\n{ "DR", "v120.header.dr", FT_BOOLEAN, 16, TFS(&tfs_yes_no), 0x4000,\r\nNULL, HFILL }},\r\n{ &hf_v120_header_sr,\r\n{ "SR", "v120.header.sr", FT_BOOLEAN, 16, TFS(&tfs_yes_no), 0x2000,\r\nNULL, HFILL }},\r\n{ &hf_v120_header_rr,\r\n{ "RR", "v120.header.rr", FT_BOOLEAN, 16, TFS(&tfs_yes_no), 0x1000,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_v120,\r\n&ett_v120_address,\r\n&ett_v120_control,\r\n&ett_v120_header,\r\n};\r\nproto_v120 = proto_register_protocol("Async data over ISDN (V.120)",\r\n"V.120", "v120");\r\nproto_register_field_array (proto_v120, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nregister_dissector("v120", dissect_v120, proto_v120);\r\n}
