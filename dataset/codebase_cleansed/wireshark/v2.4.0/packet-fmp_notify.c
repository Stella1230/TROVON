static int\r\ndissect_fmp_notify_status(tvbuff_t *tvb, int offset, proto_tree *tree, int *rval)\r\n{\r\nfmpStat status;\r\nstatus = (fmpStat)tvb_get_ntohl(tvb, offset);\r\nswitch (status) {\r\ncase FMP_OK:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_IOERROR:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_NOMEM:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_NOACCESS:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_INVALIDARG:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_FSFULL:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_QUEUE_FULL:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_WRONG_MSG_NUM:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_SESSION_LOST:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_HOT_SESSION:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_COLD_SESSION:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_CLIENT_TERMINATED:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_WRITER_LOST_BLK:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_REQUEST_QUEUED:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_FALL_BACK:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_REQUEST_CANCELLED:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_WRITER_ZEROED_BLK:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_NOTIFY_ERROR:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_WRONG_HANDLE:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_DUPLICATE_OPEN:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_PLUGIN_NOFUNC:\r\n*rval = 1;\r\nbreak;\r\ndefault:\r\n*rval = 1;\r\nbreak;\r\n}\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_status , offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_revokeHandleListReason(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_fmp_revokeHandleListReason, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_handleList(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\r\nproto_tree *tree)\r\n{\r\nint numHandles;\r\nint listLength;\r\nint i;\r\nproto_tree *handleListTree;\r\nnumHandles = tvb_get_ntohl(tvb, offset);\r\nlistLength = 4;\r\nfor (i = 0; i < numHandles; i++) {\r\nlistLength += (4 + tvb_get_ntohl(tvb, offset + listLength));\r\n}\r\nhandleListTree = proto_tree_add_subtree(tree, tvb, offset, listLength,\r\nett_fmp_notify_hlist, NULL, "Handle List");\r\noffset = dissect_rpc_uint32(tvb, handleListTree,\r\nhf_fmp_handleListLen, offset);\r\nfor (i = 0; i < numHandles; i++) {\r\noffset = dissect_rpc_data(tvb, handleListTree,\r\nhf_fmp_fmpFHandle, offset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_NOTIFY_DownGrade_request(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_sessionHandle,\r\noffset);\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_firstLogBlk,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_numBlksReq, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_NOTIFY_DownGrade_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nreturn dissect_fmp_notify_status(tvb, 0,tree, &rval);\r\n}\r\nstatic int\r\ndissect_FMP_NOTIFY_RevokeList_request(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_sessionHandle,\r\noffset);\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_firstLogBlk,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_numBlksReq, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_NOTIFY_RevokeList_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nreturn dissect_fmp_notify_status(tvb, 0, tree, &rval);\r\n}\r\nstatic int\r\ndissect_FMP_NOTIFY_RevokeAll_request(tvbuff_t *tvb,\r\npacket_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_sessionHandle,\r\noffset);\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_NOTIFY_RevokeAll_reply(tvbuff_t *tvb,\r\npacket_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nreturn dissect_fmp_notify_status(tvb, 0, tree, &rval);\r\n}\r\nstatic int\r\ndissect_FMP_NOTIFY_FileSetEof_request(tvbuff_t *tvb,\r\npacket_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_sessionHandle,\r\noffset);\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\noffset = dissect_rpc_uint64(tvb, tree, hf_fmp_fileSize, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_NOTIFY_FileSetEof_reply(tvbuff_t *tvb,\r\npacket_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nreturn dissect_fmp_notify_status(tvb, 0, tree, &rval);\r\n}\r\nstatic int\r\ndissect_FMP_NOTIFY_RequestDone_request(tvbuff_t *tvb,\r\npacket_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_notify_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_data(tvb, tree,\r\nhf_fmp_sessionHandle, offset);\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_cookie,\r\noffset);\r\noffset = dissect_fmp_notify_extentList(tvb, offset, pinfo, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_NOTIFY_RequestDone_reply(tvbuff_t *tvb,\r\npacket_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nreturn dissect_fmp_notify_status(tvb, 0, tree, &rval);\r\n}\r\nstatic int\r\ndissect_FMP_NOTIFY_volFreeze_request(tvbuff_t *tvb,\r\npacket_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_sessionHandle,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_fsID, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_NOTIFY_volFreeze_reply(tvbuff_t *tvb,\r\npacket_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nreturn dissect_fmp_notify_status(tvb, 0, tree, &rval);\r\n}\r\nstatic int\r\ndissect_FMP_NOTIFY_revokeHandleList_request(tvbuff_t *tvb,\r\npacket_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_sessionHandle,\r\noffset);\r\noffset = dissect_revokeHandleListReason(tvb, offset, tree);\r\noffset = dissect_handleList(tvb, offset, pinfo, tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_NOTIFY_revokeHandleList_reply(tvbuff_t *tvb,\r\npacket_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nreturn dissect_fmp_notify_status(tvb, 0, tree, &rval);\r\n}\r\nstatic int\r\ndissect_fmp_notify_extentState(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_extent_state,\r\noffset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_fmp_notify_extent(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\r\nproto_tree *tree, guint32 ext_num)\r\n{\r\nproto_tree *extTree;\r\nextTree = proto_tree_add_subtree_format(tree, tvb, offset, 20 ,\r\nett_fmp_ext, NULL, "Extent (%u)", (guint32) ext_num);\r\noffset = dissect_rpc_uint32(tvb, extTree, hf_fmp_firstLogBlk,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, extTree, hf_fmp_numBlks,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, extTree, hf_fmp_volID, offset);\r\noffset = dissect_rpc_uint32(tvb, extTree, hf_fmp_startOffset,\r\noffset);\r\noffset = dissect_fmp_notify_extentState(tvb, offset, extTree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_fmp_notify_extentList(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\nproto_tree *tree)\r\n{\r\nguint32 numExtents;\r\nguint32 totalLength;\r\nproto_tree *extListTree;\r\nguint32 i;\r\nnumExtents = tvb_get_ntohl(tvb, offset);\r\ntotalLength = 4 + (20 * numExtents);\r\nextListTree = proto_tree_add_subtree(tree, tvb, offset, totalLength,\r\nett_fmp_extList, NULL, "Extent List");\r\noffset = dissect_rpc_uint32(tvb, extListTree,\r\nhf_fmp_extentList_len, offset);\r\nfor (i = 0; i < numExtents; i++) {\r\noffset = dissect_fmp_notify_extent(tvb, offset, pinfo, extListTree, i+1);\r\n}\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_fmp_notify(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_fmp_notify_procedure, {\r\n"Procedure", "fmp_notify.notify_procedure", FT_UINT32, BASE_DEC,\r\nVALS(fmp_notify_proc_vals) , 0, NULL, HFILL }},\r\n{ &hf_fmp_status, {\r\n"Status", "fmp_notify.status", FT_UINT32, BASE_DEC,\r\nVALS(fmp_status_vals), 0, "Reply Status", HFILL }},\r\n{ &hf_fmp_extentList_len, {\r\n"Extent List length", "fmp_notify.extentListLength",\r\nFT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_fmp_numBlks, {\r\n"Number Blocks", "fmp_notify.numBlks", FT_UINT32,\r\nBASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_fmp_volID, {\r\n"Volume ID", "fmp_notify.volID", FT_UINT32,\r\nBASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_fmp_startOffset, {\r\n"Start Offset", "fmp_notify.startOffset", FT_UINT32,\r\nBASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_fmp_extent_state, {\r\n"Extent State", "fmp_notify.extentState", FT_UINT32,\r\nBASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_fmp_handleListLen, {\r\n"Number of File Handles", "fmp_notify.handleListLength",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_sessionHandle, {\r\n"Session Handle", "fmp_notify.sessHandle", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_fmp_fsID, {\r\n"File System ID", "fmp_notify.fsID", FT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n#if 0\r\n{ &hf_fmp_fsBlkSz, {\r\n"FS Block Size", "fmp_notify.fsBlkSz", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n#endif\r\n{ &hf_fmp_numBlksReq, {\r\n"Number Blocks Requested", "fmp_notify.numBlksReq", FT_UINT32,\r\nBASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_fmp_msgNum, {\r\n"Message Number", "fmp_notify.msgNum", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_fmp_cookie, {\r\n"Cookie", "fmp_notify.cookie", FT_UINT32, BASE_HEX,\r\nNULL, 0, "Cookie for FMP_REQUEST_QUEUED Resp", HFILL }},\r\n{ &hf_fmp_firstLogBlk, {\r\n"First Logical Block", "fmp_notify.firstLogBlk", FT_UINT32,\r\nBASE_DEC, NULL, 0, "First Logical File Block", HFILL }},\r\n{ &hf_fmp_fileSize, {\r\n"File Size", "fmp_notify.fileSize", FT_UINT64, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_fmp_fmpFHandle, {\r\n"FMP File Handle", "fmp_notify.fmpFHandle",\r\nFT_BYTES, BASE_NONE, NULL, 0, NULL,\r\nHFILL }},\r\n{ &hf_fmp_revokeHandleListReason,\r\n{ "Reason", "fmp.revokeHandleListReason",\r\nFT_UINT32, BASE_DEC, VALS(fmp_revokeHandleListReason_vals), 0,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_fmp_notify,\r\n&ett_fmp_notify_hlist,\r\n&ett_fmp_extList,\r\n&ett_fmp_ext\r\n};\r\nproto_fmp_notify =\r\nproto_register_protocol("File Mapping Protocol Nofity",\r\n"FMP/NOTIFY", "fmp_notify");\r\nproto_register_field_array(proto_fmp_notify, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_fmp_notify(void)\r\n{\r\nrpc_init_prog(proto_fmp_notify, FMP_NOTIFY_PROG, ett_fmp_notify,\r\nG_N_ELEMENTS(fmp_notify_vers_info), fmp_notify_vers_info);\r\n}
