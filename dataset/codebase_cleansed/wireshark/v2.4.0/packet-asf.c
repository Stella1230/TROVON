static int\r\ndissect_asf(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_tree *asf_tree = NULL;\r\nproto_item *ti;\r\nguint8 type;\r\nguint8 len;\r\ntvbuff_t *next_tvb;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ASF");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ntype = tvb_get_guint8(tvb, 4);\r\nlen = tvb_get_guint8(tvb, 7);\r\ncol_add_str(pinfo->cinfo, COL_INFO,\r\nval_to_str(type, asf_type_vals, "Unknown (0x%02x)"));\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_asf, tvb, 0, 8,ENC_NA);\r\nasf_tree = proto_item_add_subtree(ti, ett_asf);\r\nproto_tree_add_item(asf_tree, hf_asf_iana, tvb, 0, 4,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(asf_tree, hf_asf_type, tvb, 4, 1,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(asf_tree, hf_asf_tag, tvb, 5, 1,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(asf_tree, hf_asf_len, tvb, 7, 1,ENC_BIG_ENDIAN);\r\n}\r\nif (len) {\r\nswitch(type) {\r\ncase ASF_TYPE_OPEN_SESS_RQST:\r\ndissect_asf_open_session_request(tvb, pinfo, asf_tree, 8, len);\r\nbreak;\r\ncase ASF_TYPE_OPEN_SESS_RESP:\r\ndissect_asf_open_session_response(tvb, pinfo, asf_tree, 8, len);\r\nbreak;\r\ndefault:\r\nnext_tvb = tvb_new_subset_length(tvb, 8, len);\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\nbreak;\r\n}\r\n}\r\nreturn 8 + len;\r\n}\r\nstatic void\r\ndissect_asf_open_session_request(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, gint offset, gint len)\r\n{\r\nproto_tree_add_item(tree, hf_asf_mgt_console_id, tvb, offset, 4,ENC_BIG_ENDIAN);\r\noffset += 4;\r\nlen -= 4;\r\ndissect_asf_payloads(tvb, pinfo, tree, offset, len);\r\n}\r\nstatic void\r\ndissect_asf_open_session_response(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, gint offset, gint len)\r\n{\r\nproto_tree_add_item(tree, hf_asf_rssp_status_code, tvb, offset, 1,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_asf_mgt_console_id, tvb, offset + 4, 4,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_asf_client_id, tvb, offset + 8, 4,ENC_BIG_ENDIAN);\r\noffset += 12;\r\nlen -= 12;\r\ndissect_asf_payloads(tvb, pinfo, tree, offset, len);\r\n}\r\nstatic void\r\ndissect_asf_payloads(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint len)\r\n{\r\nguint8 ptype;\r\nguint16 plen;\r\nproto_item *ti;\r\nproto_tree *ptree;\r\nwhile ( len >= 4 )\r\n{\r\nptype = tvb_get_guint8(tvb, offset);\r\nplen = tvb_get_ntohs(tvb, offset + 2);\r\nti = proto_tree_add_none_format(tree, hf_asf_payload, tvb, offset,\r\nplen, "%s: %u bytes",\r\nval_to_str(ptype, asf_payload_type_vals, "Unknown (%u)"), plen);\r\nptree = proto_item_add_subtree(ti, ett_asf_payload);\r\nproto_tree_add_item(ptree, hf_asf_payload_type, tvb, offset, 1,ENC_BIG_ENDIAN);\r\nti = proto_tree_add_item(ptree, hf_asf_payload_len, tvb, offset + 2, 2,ENC_BIG_ENDIAN);\r\nif (plen < 4)\r\n{\r\nexpert_add_info(pinfo, ti, &ei_asf_payload_too_short);\r\nbreak;\r\n}\r\nif ( ptype && (plen > 4) )\r\n{\r\nswitch ( ptype )\r\n{\r\ncase ASF_PAYLOAD_TYPE_AUTHENTICATION:\r\ndissect_asf_payload_authentication(tvb, ptree,\r\noffset + 4, plen - 4);\r\nbreak;\r\ncase ASF_PAYLOAD_TYPE_INTEGRITY:\r\ndissect_asf_payload_integrity(tvb, ptree,\r\noffset + 4, plen - 4);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(ptree, hf_asf_payload_data, tvb,\r\noffset + 4, plen - 4,ENC_NA);\r\nbreak;\r\n}\r\n}\r\noffset += plen;\r\nlen -= plen;\r\n}\r\n}\r\nstatic void\r\ndissect_asf_payload_authentication(tvbuff_t *tvb, proto_tree *tree,\r\ngint offset, gint len)\r\n{\r\nguint8 alg;\r\nproto_item *ti;\r\nproto_tree *atree;\r\nalg = tvb_get_guint8(tvb, offset);\r\nti = proto_tree_add_none_format(tree, hf_asf_payload_data, tvb, offset,\r\nlen, "Authentication Algorithm: %s",\r\nval_to_str(alg, asf_authentication_type_vals, "Unknown (%u)"));\r\natree = proto_item_add_subtree(ti, ett_asf_alg_payload);\r\nproto_tree_add_item(atree, hf_asf_auth_alg, tvb, offset, 1,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(atree, hf_asf_reserved, tvb, offset + 1, len - 1,ENC_NA);\r\n}\r\nstatic void\r\ndissect_asf_payload_integrity(tvbuff_t *tvb, proto_tree *tree,\r\ngint offset, gint len)\r\n{\r\nguint8 alg;\r\nproto_item *ti;\r\nproto_tree *atree;\r\nalg = tvb_get_guint8(tvb, offset);\r\nti = proto_tree_add_none_format(tree, hf_asf_payload_data, tvb, offset,\r\nlen, "Integrity Algorithm: %s",\r\nval_to_str(alg, asf_integrity_type_vals, "Unknown (%u)"));\r\natree = proto_item_add_subtree(ti, ett_asf_alg_payload);\r\nproto_tree_add_item(atree, hf_asf_integrity_alg, tvb, offset, 1,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(atree, hf_asf_reserved, tvb, offset + 1, len - 1,ENC_NA);\r\n}\r\nvoid\r\nproto_register_asf(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_asf_iana, {\r\n"IANA Enterprise Number", "asf.iana",\r\nFT_UINT32, BASE_DEC|BASE_EXT_STRING, &sminmpec_values_ext, 0,\r\nNULL, HFILL }},\r\n{ &hf_asf_type, {\r\n"Message Type", "asf.type",\r\nFT_UINT8, BASE_HEX, VALS(asf_type_vals), 0,\r\n"ASF Message Type", HFILL }},\r\n{ &hf_asf_tag, {\r\n"Message Tag", "asf.tag",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"ASF Message Tag", HFILL }},\r\n{ &hf_asf_len, {\r\n"Data Length", "asf.len",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"ASF Data Length", HFILL }},\r\n{ &hf_asf_rssp_status_code, {\r\n"Status Code", "asf.rssp_status_code",\r\nFT_UINT8, BASE_DEC, VALS(asf_rssp_status_code_vals), 0,\r\n"Identifies the status of the previous message", HFILL }},\r\n{ &hf_asf_mgt_console_id, {\r\n"Mgt Console Session ID", "asf.mgt_console_id",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_asf_client_id, {\r\n"Managed Client Session ID", "asf.client_id",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_asf_payload, {\r\n"Payload", "asf.payload",\r\nFT_NONE, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_asf_payload_type, {\r\n"Payload Type", "asf.payload.type",\r\nFT_UINT8, BASE_DEC, VALS(asf_payload_type_vals), 0,\r\n"Identifies the type of payload that follows", HFILL }},\r\n{ &hf_asf_payload_len, {\r\n"Payload Length", "asf.payload.len",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"The total length in bytes of the payload including the header",\r\nHFILL }},\r\n{ &hf_asf_payload_data, {\r\n"Data", "asf.payload.data",\r\nFT_NONE, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_asf_auth_alg, {\r\n"Authentication Algorithm", "asf.auth_alg",\r\nFT_UINT8, BASE_DEC, VALS(asf_authentication_type_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_asf_integrity_alg, {\r\n"Integrity Algorithm", "asf.integrity_alg",\r\nFT_UINT8, BASE_DEC, VALS(asf_integrity_type_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_asf_reserved, {\r\n"Reserved", "asf.reserved",\r\nFT_NONE, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_asf,\r\n&ett_asf_payload,\r\n&ett_asf_alg_payload\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_asf_payload_too_short, { "asf.payload_too_short", PI_MALFORMED, PI_ERROR, "Payload length too short to include the type and length", EXPFILL }},\r\n};\r\nexpert_module_t* expert_asf;\r\nproto_asf = proto_register_protocol(\r\n"Alert Standard Forum", "ASF", "asf");\r\nproto_register_field_array(proto_asf, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_asf = expert_register_protocol(proto_asf);\r\nexpert_register_field_array(expert_asf, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_asf(void)\r\n{\r\ndissector_handle_t asf_handle;\r\nasf_handle = create_dissector_handle(dissect_asf, proto_asf);\r\ndissector_add_uint("rmcp.class", RMCP_CLASS_ASF, asf_handle);\r\n}
