static guint8 reverse_bits(guint8 value)\r\n{\r\nreturn (value & 0x80) >> 7 | (value & 0x40) >> 5 | (value & 0x20) >> 3 |\r\n(value & 0x10) >> 1 | (value & 0x08) << 1 | (value & 0x04) << 3 |\r\n(value & 0x02) << 5 | (value & 0x01) << 7;\r\n}\r\nstatic gboolean check_hec(guint8 uap, guint32 header)\r\n{\r\nguint8 hec;\r\nguint16 header_data;\r\nguint8 lfsr;\r\ngint8 i;\r\nhec = header & 0xFF;\r\nheader_data = (header >> 8) & 0x3F;\r\nlfsr = uap;\r\nfor (i = 9; i >= 0; i -= 1) {\r\nif (lfsr & 0x80)\r\nlfsr ^= 0x65;\r\nlfsr = (lfsr << 1) | (((lfsr >> 7) ^ (header_data >> i)) & 0x01);\r\n}\r\nlfsr = reverse_bits(lfsr);\r\nreturn lfsr == hec;\r\n}\r\nstatic gint\r\ndissect_btbredr_rf(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nproto_item *btbredr_rf_item;\r\nproto_tree *btbredr_rf_tree;\r\nproto_item *flags_item;\r\nproto_tree *flags_tree;\r\nproto_item *header_item;\r\nproto_tree *header_tree;\r\nproto_item *reserved_item;\r\nproto_item *hec_item = NULL;\r\ngint offset = 0;\r\ngint hf_x;\r\nguint16 flags;\r\nguint8 payload_and_transport;\r\ngint16 packet_type = PACKET_TYPE_UNKNOWN;\r\nconst gchar *packet_type_str = "Unknown";\r\ndissector_table_t packet_type_table = NULL;\r\nbluetooth_data_t *bluetooth_data = (bluetooth_data_t *) data;\r\nbtbredr_rf_item = proto_tree_add_item(tree, proto_btbredr_rf, tvb, offset, -1, ENC_NA);\r\nbtbredr_rf_tree = proto_item_add_subtree(btbredr_rf_item, ett_btbredr_rf);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "BT BR/EDR RF");\r\nif (tvb_captured_length(tvb) >= 21) {\r\nflags = tvb_get_guint16(tvb, 20, ENC_LITTLE_ENDIAN);\r\n} else {\r\nflags = 0;\r\n}\r\nif (flags & FLAGS_RF_CHANNEL_ALIASING)\r\nhf_x = hf_uncertain_rf_channel;\r\nelse\r\nhf_x = hf_rf_channel;\r\nproto_tree_add_item(btbredr_rf_tree, hf_x, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nif (flags & FLAGS_SIGNAL_POWER_VALID)\r\nhf_x = hf_signal_power;\r\nelse\r\nhf_x = hf_invalid_signal_power;\r\nproto_tree_add_item(btbredr_rf_tree, hf_x, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nif (flags & FLAGS_NOISE_POWER_VALID)\r\nhf_x = hf_noise_power;\r\nelse\r\nhf_x = hf_invalid_noise_power;\r\nproto_tree_add_item(btbredr_rf_tree, hf_x, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(btbredr_rf_tree, hf_access_address_offenses, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\npayload_and_transport = tvb_get_guint8(tvb, offset);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Transport: %s (%s), RF Channel: %s%2u",\r\nval_to_str_const(payload_and_transport >> 4, payload_transport_rate_transport_vals, "Unknown"),\r\nval_to_str_const(payload_and_transport & 0xF, payload_transport_rate_payload_abbrev_vals, "Unknown"),\r\n(flags & FLAGS_RF_CHANNEL_ALIASING) ? "~" : "",\r\ntvb_get_guint8(tvb, 0));\r\nif (payload_and_transport == 0xFF)\r\nproto_tree_add_item(btbredr_rf_tree, hf_payload_transport_rate_ignored, tvb, offset, 1, ENC_NA);\r\nelse\r\nproto_tree_add_bitmask(btbredr_rf_tree, tvb, offset, hf_payload_transport_rate, ett_payload_transport_rate, hfx_payload_transport_rate, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(btbredr_rf_tree, hf_corrected_header_bits, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(btbredr_rf_tree, hf_corrected_payload_bits, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(btbredr_rf_tree, hf_lower_address_part, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nif (flags & FLAGS_REFERENCE_LOWER_ADDRESS_PART_VALID)\r\nhf_x = hf_reference_lower_address_part;\r\nelse\r\nhf_x = hf_invalid_reference_lower_address_part;\r\nproto_tree_add_item(btbredr_rf_tree, hf_x, tvb, offset, 3, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\nif (flags & FLAGS_REFERENCE_UPPER_ADDRES_PART_VALID)\r\nhf_x = hf_reference_upper_addres_part;\r\nelse\r\nhf_x = hf_invalid_reference_upper_addres_part;\r\nproto_tree_add_item(btbredr_rf_tree, hf_x, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nif (!(flags & FLAGS_PACKET_HEADER_AND_BR_EDR_PAYLOAD_DEWHITENED)) {\r\nproto_tree_add_item(btbredr_rf_tree, hf_whitened_packet_header, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n} else {\r\nheader_item = proto_tree_add_item(btbredr_rf_tree, hf_packet_header, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nheader_tree = proto_item_add_subtree(header_item, ett_bluetooth_header);\r\nproto_tree_add_item(header_tree, hf_packet_header_reserved, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_packet_header_lt_addr, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nif (payload_and_transport == (TRANSPORT_SCO | PAYLOAD_BR)) {\r\nproto_tree_add_item(header_tree, hf_packet_header_type_sco_br, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\npacket_type = (tvb_get_guint8(tvb, offset + 1) >> 3) & 0xF;\r\npacket_type_str = val_to_str_const(packet_type, packet_type_sco_br_vals, "Unknown");\r\npacket_type_table = packet_type_sco_br_table;\r\n} else if (payload_and_transport == (TRANSPORT_eSCO | PAYLOAD_BR)) {\r\nproto_tree_add_item(header_tree, hf_packet_header_type_esco_br, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\npacket_type = (tvb_get_guint8(tvb, offset + 1) >> 3) & 0xF;\r\npacket_type_str = val_to_str_const(packet_type, packet_type_esco_br_vals, "Unknown");\r\npacket_type_table = packet_type_esco_br_table;\r\n} else if (payload_and_transport == (TRANSPORT_eSCO | PAYLOAD_EDR_2) || payload_and_transport == (TRANSPORT_eSCO | PAYLOAD_EDR_3)) {\r\nproto_tree_add_item(header_tree, hf_packet_header_type_esco_edr, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\npacket_type = (tvb_get_guint8(tvb, offset + 1) >> 3) & 0xF;\r\npacket_type_str = val_to_str_const(packet_type, packet_type_esco_edr_vals, "Unknown");\r\npacket_type_table = packet_type_esco_edr_table;\r\n} else if (payload_and_transport == (TRANSPORT_ACL | PAYLOAD_BR)) {\r\nproto_tree_add_item(header_tree, hf_packet_header_type_acl_br, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\npacket_type = (tvb_get_guint8(tvb, offset + 1) >> 3) & 0xF;\r\npacket_type_str = val_to_str_const(packet_type, packet_type_acl_br_vals, "Unknown");\r\npacket_type_table = packet_type_acl_br_table;\r\n} else if (payload_and_transport == (TRANSPORT_ACL | PAYLOAD_EDR_2) || payload_and_transport == (TRANSPORT_ACL | PAYLOAD_EDR_3)) {\r\nproto_tree_add_item(header_tree, hf_packet_header_type_acl_edr, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\npacket_type = (tvb_get_guint8(tvb, offset + 1) >> 3) & 0xF;\r\npacket_type_str = val_to_str_const(packet_type, packet_type_acl_edr_vals, "Unknown");\r\npacket_type_table = packet_type_acl_edr_table;\r\n} else if (payload_and_transport == (TRANSPORT_CSB | PAYLOAD_BR)) {\r\nproto_tree_add_item(header_tree, hf_packet_header_type_csb_br, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\npacket_type = (tvb_get_guint8(tvb, offset + 1) >> 3) & 0xF;\r\npacket_type_str = val_to_str_const(packet_type, packet_type_csb_br_vals, "Unknown");\r\npacket_type_table = packet_type_csb_br_table;\r\n} else if (payload_and_transport == (TRANSPORT_CSB | PAYLOAD_EDR_2) || payload_and_transport == (TRANSPORT_ACL | PAYLOAD_EDR_3)) {\r\nproto_tree_add_item(header_tree, hf_packet_header_type_csb_edr, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\npacket_type = (tvb_get_guint8(tvb, offset + 1) >> 3) & 0xF;\r\npacket_type_str = val_to_str_const(packet_type, packet_type_csb_edr_vals, "Unknown");\r\npacket_type_table = packet_type_csb_edr_table;\r\n} else if ((payload_and_transport >> 4) == TRANSPORT_ANY) {\r\nproto_tree_add_item(header_tree, hf_packet_header_type_any, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\npacket_type = (tvb_get_guint8(tvb, offset + 1) >> 3) & 0xF;\r\npacket_type_str = val_to_str_const(packet_type, packet_type_any_vals, "Unknown");\r\n} else {\r\nproto_tree_add_item(header_tree, hf_packet_header_type, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n}\r\nproto_tree_add_item(header_tree, hf_packet_header_flow_control, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_packet_header_acknowledge_indication, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_packet_header_sequence_number, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nhec_item = proto_tree_add_item(header_tree, hf_packet_header_header_error_check, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n}\r\nif ((flags & FLAGS_REFERENCE_UPPER_ADDRES_PART_VALID) &&\r\n(flags & FLAGS_PACKET_HEADER_AND_BR_EDR_PAYLOAD_DEWHITENED) &&\r\n!check_hec(tvb_get_guint8(tvb, offset - 1), tvb_get_guint32(tvb, offset, ENC_LITTLE_ENDIAN))) {\r\nexpert_add_info(pinfo, hec_item, &ei_incorrect_packet_header_or_hec);\r\n}\r\nif (!((flags & FLAGS_REFERENCE_UPPER_ADDRES_PART_VALID) &&\r\n(flags & FLAGS_PACKET_HEADER_AND_BR_EDR_PAYLOAD_DEWHITENED))) {\r\nexpert_add_info(pinfo, hec_item, &ei_packet_header_with_hec_not_checked);\r\n}\r\noffset += 4;\r\nflags_item = proto_tree_add_item(btbredr_rf_tree, hf_flags, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nflags_tree = proto_item_add_subtree(flags_item, ett_flags);\r\nflags = tvb_get_guint16(tvb, offset, ENC_LITTLE_ENDIAN);\r\nreserved_item = proto_tree_add_item(flags_tree, hf_flags_reserved_15_14, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nif (flags & 0xC000) {\r\nexpert_add_info(pinfo, reserved_item, &ei_reserved_not_zero);\r\n}\r\nproto_tree_add_item(flags_tree, hf_flags_mic_pass, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_flags_mic_checked, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_flags_crc_pass, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_flags_crc_checked, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_flags_hec_pass, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_flags_hec_checked, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_flags_reference_upper_addres_part_valid, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_flags_rf_channel_aliasing, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_flags_br_edr_data_present, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_flags_reference_lower_address_part_valid, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_flags_bredr_payload_decrypted, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_flags_noise_power_valid, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_flags_signal_power_valid, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_flags_packet_header_and_br_edr_payload_dewhitened, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nif ((flags & (FLAGS_SIGNAL_POWER_VALID | FLAGS_NOISE_POWER_VALID)) == (FLAGS_SIGNAL_POWER_VALID | FLAGS_NOISE_POWER_VALID)) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (SP: %4i, NP: %4i)",\r\n(gint)(gint8)tvb_get_guint8(tvb, 1), (gint)(gint8)tvb_get_guint8(tvb, 2));\r\n} else if (flags & FLAGS_SIGNAL_POWER_VALID) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (SP: %4i)",\r\n(gint)(gint8)tvb_get_guint8(tvb, 1));\r\n} else if (flags & FLAGS_NOISE_POWER_VALID) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (NP: %4i)",\r\n(gint)(gint8)tvb_get_guint8(tvb, 2));\r\n}\r\nif (flags & FLAGS_PACKET_HEADER_AND_BR_EDR_PAYLOAD_DEWHITENED)\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Packet Type: %s", packet_type_str);\r\nif (flags & FLAGS_BR_EDR_DATA_PRESENT) {\r\nif (flags & FLAGS_PACKET_HEADER_AND_BR_EDR_PAYLOAD_DEWHITENED) {\r\nif (flags & FLAGS_BREDR_PAYLOAD_DECRYPTED) {\r\ntvbuff_t *next_tvb;\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nif (!(packet_type_table && packet_type > PACKET_TYPE_UNKNOWN &&\r\ndissector_try_uint_new(packet_type_table, packet_type, next_tvb, pinfo, tree, TRUE, bluetooth_data)))\r\nproto_tree_add_item(btbredr_rf_tree, hf_data, tvb, offset, tvb_captured_length_remaining(tvb, offset), ENC_NA);\r\noffset = tvb_reported_length(tvb);\r\n} else {\r\nproto_tree_add_item(btbredr_rf_tree, hf_encrypted_data, tvb, offset, tvb_captured_length_remaining(tvb, offset), ENC_NA);\r\noffset = tvb_reported_length(tvb);\r\n}\r\n} else {\r\nproto_tree_add_item(btbredr_rf_tree, hf_whitened_data, tvb, offset, tvb_captured_length_remaining(tvb, offset), ENC_NA);\r\noffset = tvb_reported_length(tvb);\r\n}\r\n} else {\r\nif (tvb_captured_length_remaining(tvb, offset) > 0)\r\nproto_tree_add_expert(btbredr_rf_tree, pinfo, &ei_unexpected_data, tvb, offset, tvb_captured_length_remaining(tvb, offset));\r\noffset = tvb_reported_length(tvb);\r\n}\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_btbredr_rf(void)\r\n{\r\nexpert_module_t *expert_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_rf_channel,\r\n{ "RF Channel", "btbredr_rf.rf_channel",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_uncertain_rf_channel,\r\n{ "Uncertain RF Channel", "btbredr_rf.uncertain_rf_channel",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_signal_power,\r\n{ "Signal Power", "btbredr_rf.signal_power",\r\nFT_INT8, BASE_DEC, NULL, 0x00,\r\n"Signal Power in dBm", HFILL }\r\n},\r\n{ &hf_invalid_signal_power,\r\n{ "Invalid Signal Power", "btbredr_rf.invalid.signal_power",\r\nFT_INT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_noise_power,\r\n{ "Noise Power", "btbredr_rf.noise_power",\r\nFT_INT8, BASE_DEC, NULL, 0x00,\r\n"Noise Power in dBm", HFILL }\r\n},\r\n{ &hf_invalid_noise_power,\r\n{ "Invalid Noise Power", "btbredr_rf.invalid.noise_power",\r\nFT_INT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_access_address_offenses,\r\n{ "Access Address Offenses", "btbredr_rf.access_address_offenses",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_payload_transport_rate,\r\n{ "Payload Transport Rate", "btbredr_rf.payload_transport_rate",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_payload_transport_rate_ignored,\r\n{ "Payload Transport Rate: Ignored", "btbredr_rf.payload_transport_rate.ignored",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\n"BT Packet Header is ignored and there is no payload", HFILL }\r\n},\r\n{ &hf_payload_transport_rate_transport,\r\n{ "Transport", "btbredr_rf.payload_transport_rate.transport",\r\nFT_UINT8, BASE_HEX, VALS(payload_transport_rate_transport_vals), 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_payload_transport_rate_payload,\r\n{ "Payload", "btbredr_rf.payload_transport_rate.payload",\r\nFT_UINT8, BASE_HEX, VALS(payload_transport_rate_payload_vals), 0x0F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_corrected_header_bits,\r\n{ "Corrected Header Bits", "btbredr_rf.corrected_header_bits",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_corrected_payload_bits,\r\n{ "Corrected Payload Bits", "btbredr_rf.corrected_payload_bits",\r\nFT_INT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_lower_address_part,\r\n{ "Lower Address Part", "btbredr_rf.lower_address_part",\r\nFT_UINT32, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_reference_lower_address_part,\r\n{ "Reference Lower Address Part", "btbredr_rf.reference_lower_address_part",\r\nFT_UINT24, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_invalid_reference_lower_address_part,\r\n{ "Invalid Reference Lower Address Part", "btbredr_rf.invalid.reference_lower_address_part",\r\nFT_UINT24, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_reference_upper_addres_part,\r\n{ "Reference Upper Address Part", "btbredr_rf.reference_upper_addres_part",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_invalid_reference_upper_addres_part,\r\n{ "Invalid Reference Upper Address Part", "btbredr_rf.invalid.reference_upper_addres_part",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_whitened_packet_header,\r\n{ "Whitened Packet Header", "btbredr_rf.whitened.packet_header",\r\nFT_UINT32, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_packet_header,\r\n{ "Packet Header", "btbredr_rf.packet_header",\r\nFT_UINT32, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_packet_header_reserved,\r\n{ "Reserved", "btbredr_rf.packet_header.reserved",\r\nFT_UINT32, BASE_HEX, NULL, 0xFFFC0000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_packet_header_lt_addr,\r\n{ "LT_ADDR", "btbredr_rf.packet_header.lt_addr",\r\nFT_UINT32, BASE_HEX, NULL, 0x00038000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_packet_header_type,\r\n{ "Type", "btbredr_rf.packet_header.type",\r\nFT_UINT32, BASE_HEX, NULL, 0x00007800,\r\nNULL, HFILL }\r\n},\r\n{ &hf_packet_header_type_any,\r\n{ "Type", "btbredr_rf.packet_header.type",\r\nFT_UINT32, BASE_HEX, VALS(packet_type_any_vals), 0x00007800,\r\nNULL, HFILL }\r\n},\r\n{ &hf_packet_header_type_sco_br,\r\n{ "Type", "btbredr_rf.packet_header.type",\r\nFT_UINT32, BASE_HEX, VALS(packet_type_sco_br_vals), 0x00007800,\r\nNULL, HFILL }\r\n},\r\n{ &hf_packet_header_type_esco_br,\r\n{ "Type", "btbredr_rf.packet_header.type",\r\nFT_UINT32, BASE_HEX, VALS(packet_type_esco_br_vals), 0x00007800,\r\nNULL, HFILL }\r\n},\r\n{ &hf_packet_header_type_esco_edr,\r\n{ "Type", "btbredr_rf.packet_header.type",\r\nFT_UINT32, BASE_HEX, VALS(packet_type_esco_edr_vals), 0x00007800,\r\nNULL, HFILL }\r\n},\r\n{ &hf_packet_header_type_acl_br,\r\n{ "Type", "btbredr_rf.packet_header.type",\r\nFT_UINT32, BASE_HEX, VALS(packet_type_acl_br_vals), 0x00007800,\r\nNULL, HFILL }\r\n},\r\n{ &hf_packet_header_type_acl_edr,\r\n{ "Type", "btbredr_rf.packet_header.type",\r\nFT_UINT32, BASE_HEX, VALS(packet_type_acl_edr_vals), 0x00007800,\r\nNULL, HFILL }\r\n},\r\n{ &hf_packet_header_type_csb_br,\r\n{ "Type", "btbredr_rf.packet_header.type",\r\nFT_UINT32, BASE_HEX, VALS(packet_type_csb_br_vals), 0x00007800,\r\nNULL, HFILL }\r\n},\r\n{ &hf_packet_header_type_csb_edr,\r\n{ "Type", "btbredr_rf.packet_header.type",\r\nFT_UINT32, BASE_HEX, VALS(packet_type_csb_edr_vals), 0x00007800,\r\nNULL, HFILL }\r\n},\r\n{ &hf_packet_header_flow_control,\r\n{ "Flow Control", "btbredr_rf.packet_header.flow_control",\r\nFT_BOOLEAN, 32, NULL, 0x00000400,\r\nNULL, HFILL }\r\n},\r\n{ &hf_packet_header_acknowledge_indication,\r\n{ "ARQN", "btbredr_rf.packet_header.arqn",\r\nFT_BOOLEAN, 32, NULL, 0x00000200,\r\n"Acknowledge Indication", HFILL }\r\n},\r\n{ &hf_packet_header_sequence_number,\r\n{ "SEQN", "btbredr_rf.packet_header.seqn",\r\nFT_BOOLEAN, 32, NULL, 0x00000100,\r\n"Sequence Number", HFILL }\r\n},\r\n{ &hf_packet_header_header_error_check,\r\n{ "HEC", "btbredr_rf.packet_header.hec",\r\nFT_UINT32, BASE_HEX, NULL, 0x000000FF,\r\n"Header Error Check", HFILL }\r\n},\r\n{ &hf_flags,\r\n{ "Flags", "btbredr_rf.flags",\r\nFT_UINT16, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_whitened_data,\r\n{ "Whitened Data", "btbredr_rf.whitened.data",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_encrypted_data,\r\n{ "Encrypted Data", "btbredr_rf.encrypted.data",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_data,\r\n{ "Data", "btbredr_rf.data",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flags_reserved_15_14,\r\n{ "Reserved", "btbredr_rf.flags.reserved.15_14",\r\nFT_UINT16, BASE_HEX, NULL, 0xC000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flags_mic_pass,\r\n{ "MIC Pass", "btbredr_rf.flags.mic_pass",\r\nFT_BOOLEAN, 16, NULL, 0x2000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flags_mic_checked,\r\n{ "MIC Checked", "btbredr_rf.flags.mic_check",\r\nFT_BOOLEAN, 16, NULL, 0x1000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flags_crc_pass,\r\n{ "CRC Pass", "btbredr_rf.flags.crc_pass",\r\nFT_BOOLEAN, 16, NULL, 0x0800,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flags_crc_checked,\r\n{ "CRC Checked", "btbredr_rf.flags.crc_check",\r\nFT_BOOLEAN, 16, NULL, 0x0400,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flags_hec_pass,\r\n{ "HEC Pass", "btbredr_rf.flags.hec_pass",\r\nFT_BOOLEAN, 16, NULL, 0x0200,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flags_hec_checked,\r\n{ "HEC Checked", "btbredr_rf.flags.hec_check",\r\nFT_BOOLEAN, 16, NULL, 0x0100,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flags_reference_upper_addres_part_valid,\r\n{ "Reference Upper Address Part Valid", "btbredr_rf.flags.reference_upper_addres_part_valid",\r\nFT_BOOLEAN, 16, NULL, 0x0080,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flags_rf_channel_aliasing,\r\n{ "RF Channel Aliasing", "btbredr_rf.flags.rf_channel_aliasing",\r\nFT_BOOLEAN, 16, NULL, 0x0040,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flags_br_edr_data_present,\r\n{ "BR or EDR Data Present", "btbredr_rf.flags.bredr_data_present",\r\nFT_BOOLEAN, 16, NULL, 0x0020,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flags_reference_lower_address_part_valid,\r\n{ "Reference Lower Address Part Valid", "btbredr_rf.flags.reference_lower_address_part_valid",\r\nFT_BOOLEAN, 16, NULL, 0x0010,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flags_bredr_payload_decrypted,\r\n{ "BR or EDR Payload Decrypted", "btbredr_rf.flags.bredr_payload_decrypted",\r\nFT_BOOLEAN, 16, NULL, 0x0008,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flags_noise_power_valid,\r\n{ "Noise Power Valid", "btbredr_rf.flags.noise_power_valid",\r\nFT_BOOLEAN, 16, NULL, 0x0004,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flags_signal_power_valid,\r\n{ "Signal Power Valid", "btbredr_rf.flags.signal_power_valid",\r\nFT_BOOLEAN, 16, NULL, 0x0002,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flags_packet_header_and_br_edr_payload_dewhitened,\r\n{ "Packet Header and BR/EDR Payload Dewhitened", "btbredr_rf.flags.pkt_hdr_and_br_edr_payload_dewhitened",\r\nFT_BOOLEAN, 16, NULL, 0x0001,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_btbredr_rf,\r\n&ett_flags,\r\n&ett_payload_transport_rate,\r\n&ett_packet_header,\r\n&ett_bluetooth_header\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_unexpected_data, { "btbredr_rf.unexpected_data", PI_PROTOCOL, PI_WARN, "Unexpected data, BR or EDR Data Present flag is set to False", EXPFILL }},\r\n{ &ei_reserved_not_zero, { "btbredr_rf.reserved_not_zero", PI_PROTOCOL, PI_WARN, "Reserved values are not zeros", EXPFILL }},\r\n{ &ei_incorrect_packet_header_or_hec, { "btbredr_rf.incorrect_packet_header_or_hec", PI_PROTOCOL, PI_WARN, "Incorrect Packet Header or HEC", EXPFILL }},\r\n{ &ei_packet_header_with_hec_not_checked, { "btbredr_rf.packet_header_with_hec_not_checked", PI_PROTOCOL, PI_NOTE, "Packet Header with HEC is not checked", EXPFILL }},\r\n};\r\nproto_btbredr_rf = proto_register_protocol("Bluetooth Pseudoheader for BR/EDR", "BT BR/EDR RF", "btbredr_rf");\r\nproto_register_field_array(proto_btbredr_rf, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nbtbredr_rf_handle = register_dissector("btbredr_rf", dissect_btbredr_rf, proto_btbredr_rf);\r\npacket_type_sco_br_table = register_dissector_table("btbredr_rf.packet_type.sco.br", "BT Packet Type for SCO BR", proto_btbredr_rf, FT_UINT8, BASE_HEX);\r\npacket_type_esco_br_table = register_dissector_table("btbredr_rf.packet_type.esco.br", "BT Packet Type for eSCO BR", proto_btbredr_rf, FT_UINT8, BASE_HEX);\r\npacket_type_esco_edr_table = register_dissector_table("btbredr_rf.packet_type.esco.edr", "BT Packet Type for eSCO EDR", proto_btbredr_rf, FT_UINT8, BASE_HEX);\r\npacket_type_acl_br_table = register_dissector_table("btbredr_rf.packet_type.acl.br", "BT Packet Type for ACL BR", proto_btbredr_rf, FT_UINT8, BASE_HEX);\r\npacket_type_acl_edr_table = register_dissector_table("btbredr_rf.packet_type.acl.edr", "BT Packet Type for ACL EDR", proto_btbredr_rf, FT_UINT8, BASE_HEX);\r\npacket_type_csb_br_table = register_dissector_table("btbredr_rf.packet_type.csb.br", "BT Packet Type for CSB BR", proto_btbredr_rf, FT_UINT8, BASE_HEX);\r\npacket_type_csb_edr_table = register_dissector_table("btbredr_rf.packet_type.csb.edr", "BT Packet Type for CSB EDR", proto_btbredr_rf, FT_UINT8, BASE_HEX);\r\nexpert_module = expert_register_protocol(proto_btbredr_rf);\r\nexpert_register_field_array(expert_module, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_btbredr_rf(void)\r\n{\r\ndissector_add_uint("bluetooth.encap", WTAP_ENCAP_BLUETOOTH_BREDR_BB, btbredr_rf_handle);\r\n}
