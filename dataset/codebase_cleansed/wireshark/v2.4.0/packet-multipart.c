static tvbuff_t *\r\nbase64_decode(packet_info *pinfo, tvbuff_t *b64_tvb, char *name)\r\n{\r\nchar *data;\r\ntvbuff_t *tvb;\r\ndata = tvb_get_string_enc(wmem_packet_scope(), b64_tvb, 0, tvb_reported_length(b64_tvb), ENC_ASCII);\r\ntvb = base64_to_tvb(b64_tvb, data);\r\nadd_new_data_source(pinfo, tvb, name);\r\nreturn tvb;\r\n}\r\nstatic char *\r\nunfold_and_compact_mime_header(const char *lines, gint *first_colon_offset)\r\n{\r\nconst char *p = lines;\r\nchar c;\r\nchar *ret, *q;\r\nchar sep_seen = 0;\r\nchar lws = FALSE;\r\ngint colon = -1;\r\nif (! lines) return NULL;\r\nc = *p;\r\nret = (char *)wmem_alloc(wmem_packet_scope(), strlen(lines) + 1);\r\nq = ret;\r\nwhile (c) {\r\nif (c == ':') {\r\nlws = FALSE;\r\nif (colon == -1) {\r\ncolon = (gint) (q - ret);\r\n}\r\n*(q++) = sep_seen = c;\r\np++;\r\n} else if (c == ';' || c == ',' || c == '=') {\r\nlws = FALSE;\r\n*(q++) = sep_seen = c;\r\np++;\r\n} else if (c == ' ' || c == '\t') {\r\nlws = TRUE;\r\np++;\r\n} else if (c == '\n') {\r\nlws = FALSE;\r\nif ((c = *(p+1))) {\r\nif (c == ' ' || c == '\t') {\r\nlws = TRUE;\r\np += 2;\r\n} else {\r\n*q = c = 0;\r\n}\r\n}\r\n} else if (c == '\r') {\r\nlws = FALSE;\r\nif ((c = *(p+1))) {\r\nif (c == '\n') {\r\nif ((c = *(p+2))) {\r\nif (c == ' ' || c == '\t') {\r\nlws = TRUE;\r\np += 3;\r\n} else {\r\n*q = c = 0;\r\n}\r\n}\r\n} else if (c == ' ' || c == '\t') {\r\nlws = TRUE;\r\np += 2;\r\n} else {\r\n*q = c = 0;\r\n}\r\n}\r\n} else if (c == '"') {\r\nlws = FALSE;\r\n*(q++) = c;\r\nwhile (c) {\r\nc = *(q++) = *(++p);\r\nif (c == '\\') {\r\nc = *(q++) = *(++p);\r\n} else {\r\nif (c == '"') {\r\np++;\r\nbreak;\r\n}\r\n}\r\n}\r\nif(c == 0) {\r\nq--;\r\n}\r\n} else {\r\nif (sep_seen) {\r\nsep_seen = 0;\r\n} else {\r\nif (lws) {\r\n*(q++) = ' ';\r\n}\r\n}\r\nlws = FALSE;\r\n*(q++) = c;\r\np++;\r\n}\r\nif (c) {\r\nc = *p;\r\n}\r\n}\r\n*q = 0;\r\n*first_colon_offset = colon;\r\nreturn (ret);\r\n}\r\nstatic multipart_info_t *\r\nget_multipart_info(packet_info *pinfo, http_message_info_t *message_info)\r\n{\r\nchar *start_boundary, *start_protocol = NULL;\r\nmultipart_info_t *m_info = NULL;\r\nconst char *type = pinfo->match_string;\r\nchar *parameters;\r\ngint dummy;\r\nif (type == NULL) {\r\nreturn NULL;\r\n}\r\nif (message_info == NULL) {\r\nreturn NULL;\r\n}\r\nif (message_info->media_str == NULL) {\r\nreturn NULL;\r\n}\r\nparameters = unfold_and_compact_mime_header(message_info->media_str, &dummy);\r\nstart_boundary = ws_find_media_type_parameter(parameters, "boundary");\r\nif(!start_boundary) {\r\nreturn NULL;\r\n}\r\nif(strncmp(type, "multipart/encrypted", sizeof("multipart/encrypted")-1) == 0) {\r\nstart_protocol = ws_find_media_type_parameter(parameters, "protocol");\r\nif(!start_protocol) {\r\ng_free(start_boundary);\r\nreturn NULL;\r\n}\r\n}\r\nm_info = wmem_new(wmem_packet_scope(), multipart_info_t);\r\nm_info->type = type;\r\nm_info->boundary = wmem_strdup(wmem_packet_scope(), start_boundary);\r\nm_info->boundary_length = (guint)strlen(start_boundary);\r\ng_free(start_boundary);\r\nif(start_protocol) {\r\nm_info->protocol = wmem_strdup(wmem_packet_scope(), start_protocol);\r\nm_info->protocol_length = (guint)strlen(start_protocol);\r\ng_free(start_protocol);\r\n} else {\r\nm_info->protocol = NULL;\r\nm_info->protocol_length = -1;\r\n}\r\nm_info->orig_content_type = NULL;\r\nm_info->orig_parameters = NULL;\r\nreturn m_info;\r\n}\r\nstatic gint\r\nfind_first_boundary(tvbuff_t *tvb, gint start, const guint8 *boundary,\r\ngint boundary_len, gint *boundary_line_len, gboolean *last_boundary)\r\n{\r\ngint offset = start, next_offset, line_len, boundary_start;\r\nwhile (tvb_offset_exists(tvb, offset + 2 + boundary_len)) {\r\nboundary_start = offset;\r\nif (((tvb_strneql(tvb, offset, (const guint8 *)"--", 2) == 0)\r\n&& (tvb_strneql(tvb, offset + 2, boundary, boundary_len) == 0)))\r\n{\r\nif ((tvb_reported_length_remaining(tvb, offset + 2 + boundary_len + 2) >= 0)\r\n&& (tvb_strneql(tvb, offset + 2 + boundary_len,\r\n(const guint8 *)"--", 2) == 0)) {\r\n*last_boundary = TRUE;\r\n} else {\r\n*last_boundary = FALSE;\r\n}\r\nline_len = tvb_find_line_end(tvb, offset, -1, &offset, FALSE);\r\nif (line_len == -1) {\r\n*boundary_line_len = -1;\r\n} else {\r\n*boundary_line_len = offset - boundary_start;\r\n}\r\nreturn boundary_start;\r\n}\r\nline_len = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\r\nif (line_len == -1) {\r\nreturn -1;\r\n}\r\noffset = next_offset;\r\n}\r\nreturn -1;\r\n}\r\nstatic gint\r\nfind_next_boundary(tvbuff_t *tvb, gint start, const guint8 *boundary,\r\ngint boundary_len, gint *boundary_line_len, gboolean *last_boundary)\r\n{\r\ngint offset = start, next_offset, line_len, boundary_start;\r\nwhile (tvb_offset_exists(tvb, offset + 2 + boundary_len)) {\r\nline_len = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\r\nif (line_len == -1) {\r\nreturn -1;\r\n}\r\nboundary_start = offset + line_len;\r\nif (((tvb_strneql(tvb, next_offset, (const guint8 *)"--", 2) == 0)\r\n&& (tvb_strneql(tvb, next_offset + 2, boundary, boundary_len) == 0)))\r\n{\r\nif ((tvb_reported_length_remaining(tvb, next_offset + 2 + boundary_len + 2) >= 0)\r\n&& (tvb_strneql(tvb, next_offset + 2 + boundary_len,\r\n(const guint8 *)"--", 2) == 0)) {\r\n*last_boundary = TRUE;\r\n} else {\r\n*last_boundary = FALSE;\r\n}\r\nline_len = tvb_find_line_end(tvb, next_offset, -1, &offset, FALSE);\r\nif (line_len == -1) {\r\n*boundary_line_len = -1;\r\n} else {\r\n*boundary_line_len = offset - boundary_start;\r\n}\r\nreturn boundary_start;\r\n} else if ((tvb_strneql(tvb, boundary_start - 2, (const guint8 *)"--", 2) == 0)\r\n&& (tvb_strneql(tvb, boundary_start - (2 + boundary_len), boundary, boundary_len) == 0)\r\n&& (tvb_strneql(tvb, boundary_start - (2 + boundary_len + 2),\r\n(const guint8 *)"--", 2) == 0)) {\r\nboundary_start -= 2 + boundary_len + 2;\r\n*boundary_line_len = next_offset - boundary_start;\r\n*last_boundary = TRUE;\r\nreturn boundary_start;\r\n}\r\noffset = next_offset;\r\n}\r\nreturn -1;\r\n}\r\nstatic gint\r\nprocess_preamble(proto_tree *tree, tvbuff_t *tvb, multipart_info_t *m_info,\r\ngboolean *last_boundary)\r\n{\r\ngint boundary_start, boundary_line_len;\r\nconst guint8 *boundary = (guint8 *)m_info->boundary;\r\ngint boundary_len = m_info->boundary_length;\r\nboundary_start = find_first_boundary(tvb, 0, boundary, boundary_len,\r\n&boundary_line_len, last_boundary);\r\nif (boundary_start == 0) {\r\nproto_tree_add_item(tree, hf_multipart_first_boundary, tvb, boundary_start, boundary_line_len, ENC_NA|ENC_ASCII);\r\nreturn boundary_start + boundary_line_len;\r\n} else if (boundary_start > 0) {\r\nif (boundary_line_len > 0) {\r\ngint body_part_start = boundary_start + boundary_line_len;\r\nif (boundary_start > 0) {\r\nproto_tree_add_item(tree, hf_multipart_preamble, tvb, 0, boundary_start, ENC_NA);\r\n}\r\nproto_tree_add_item(tree, hf_multipart_first_boundary, tvb, boundary_start, boundary_line_len, ENC_NA|ENC_ASCII);\r\nreturn body_part_start;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic void\r\ndissect_kerberos_encrypted_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gssapi_encrypt_info_t* encrypt)\r\n{\r\ntvbuff_t *kerberos_tvb;\r\ngint offset = 0, len;\r\nguint8 *data;\r\nproto_tree_add_item(tree, hf_multipart_sec_token_len, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nlen = tvb_reported_length_remaining(tvb, offset);\r\nDISSECTOR_ASSERT(tvb_bytes_exist(tvb, offset, len));\r\ndata = (guint8 *)tvb_memdup(pinfo->pool, tvb, offset, len);\r\nkerberos_tvb = tvb_new_child_real_data(tvb, data, len, len);\r\nadd_new_data_source(pinfo, kerberos_tvb, "Kerberos Data");\r\ncall_dissector_with_data(gssapi_handle, kerberos_tvb, pinfo, tree, encrypt);\r\n}\r\nstatic gint\r\nprocess_body_part(proto_tree *tree, tvbuff_t *tvb,\r\nhttp_message_info_t *input_message_info, multipart_info_t *m_info,\r\npacket_info *pinfo, gint start, gint idx,\r\ngboolean *last_boundary)\r\n{\r\nproto_tree *subtree;\r\nproto_item *ti;\r\ngint offset = start, next_offset = 0;\r\nhttp_message_info_t message_info = { input_message_info->type, NULL };\r\ngint body_start, boundary_start, boundary_line_len;\r\ngchar *content_type_str = NULL;\r\ngchar *content_encoding_str = NULL;\r\nchar *filename = NULL;\r\nchar *mimetypename = NULL;\r\ngboolean last_field = FALSE;\r\ngboolean is_raw_data = FALSE;\r\nconst guint8 *boundary = (guint8 *)m_info->boundary;\r\ngint boundary_len = m_info->boundary_length;\r\nti = proto_tree_add_item(tree, hf_multipart_part, tvb, start, 0, ENC_ASCII|ENC_NA);\r\nsubtree = proto_item_add_subtree(ti, ett_multipart_body);\r\nboundary_start = find_next_boundary(tvb, offset, boundary, boundary_len,\r\n&boundary_line_len, last_boundary);\r\nif (boundary_start <= 0) {\r\nreturn -1;\r\n}\r\nwhile (!last_field)\r\n{\r\ngint colon_offset;\r\nchar *hdr_str;\r\nchar *header_str;\r\nnext_offset = imf_find_field_end(tvb, offset, tvb_reported_length_remaining(tvb, offset)+offset, &last_field);\r\nif (last_field && (next_offset+2) <= boundary_start) {\r\nnext_offset += 2;\r\n} else if((next_offset-2) == boundary_start) {\r\nlast_field = TRUE;\r\nnext_offset -= 2;\r\n} else if (next_offset > boundary_start) {\r\nnext_offset = boundary_start;\r\n}\r\nhdr_str = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, next_offset - offset, ENC_ASCII);\r\nheader_str = unfold_and_compact_mime_header(hdr_str, &colon_offset);\r\nif (colon_offset <= 0) {\r\nnext_offset = offset;\r\nbreak;\r\n} else {\r\ngint hf_index;\r\nheader_str[colon_offset] = '\0';\r\nhf_index = is_known_multipart_header(header_str, colon_offset);\r\nif (hf_index == -1) {\r\nif(isprint_string(hdr_str)) {\r\nproto_tree_add_format_text(subtree, tvb, offset, next_offset - offset);\r\n} else {\r\nnext_offset = offset;\r\nbreak;\r\n}\r\n} else {\r\nchar *value_str = g_strdup(header_str + colon_offset + 1);\r\nproto_tree_add_string_format(subtree,\r\nhf_header_array[hf_index], tvb,\r\noffset, next_offset - offset,\r\n(const char *)value_str, "%s",\r\ntvb_format_text(tvb, offset, next_offset - offset));\r\nswitch (hf_index) {\r\ncase POS_ORIGINALCONTENT:\r\n{\r\nchar *semicolonp;\r\nchar* type_str = ws_find_media_type_parameter(value_str, "type");\r\nif(type_str != NULL) {\r\ng_free(value_str);\r\nvalue_str = type_str;\r\n}\r\nsemicolonp = strchr(value_str, ';');\r\nif (semicolonp != NULL) {\r\n*semicolonp = '\0';\r\nm_info->orig_parameters = wmem_strdup(wmem_packet_scope(),\r\nsemicolonp + 1);\r\n}\r\nm_info->orig_content_type = wmem_ascii_strdown(wmem_packet_scope(), value_str, -1);\r\n}\r\nbreak;\r\ncase POS_CONTENT_TYPE:\r\n{\r\nchar *semicolonp = strchr(value_str, ';');\r\nif (semicolonp != NULL) {\r\n*semicolonp = '\0';\r\nmessage_info.media_str = wmem_strdup(wmem_packet_scope(), semicolonp + 1);\r\n} else {\r\nmessage_info.media_str = NULL;\r\n}\r\ncontent_type_str = wmem_ascii_strdown(wmem_packet_scope(), value_str, -1);\r\nproto_item_append_text(ti, " (%s)", content_type_str);\r\nmimetypename = ws_find_media_type_parameter(message_info.media_str, "name");\r\nif(strncmp(content_type_str, "application/octet-stream",\r\nsizeof("application/octet-stream")-1) == 0) {\r\nis_raw_data = TRUE;\r\n}\r\nif(m_info->protocol && idx == 0\r\n&& (is_raw_data || g_ascii_strncasecmp(content_type_str, m_info->protocol,\r\nstrlen(m_info->protocol)) != 0))\r\n{\r\nreturn -1;\r\n}\r\n}\r\nbreak;\r\ncase POS_CONTENT_TRANSFER_ENCODING:\r\n{\r\nchar *crp = strchr(value_str, '\r');\r\nif (crp != NULL) {\r\n*crp = '\0';\r\n}\r\ncontent_encoding_str = wmem_ascii_strdown(wmem_packet_scope(), value_str, -1);\r\n}\r\nbreak;\r\ncase POS_CONTENT_DISPOSITION:\r\n{\r\nfilename = ws_find_media_type_parameter(value_str, "filename");\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ng_free(value_str);\r\n}\r\n}\r\noffset = next_offset;\r\n}\r\nbody_start = next_offset;\r\n{\r\ngint body_len = boundary_start - body_start;\r\ntvbuff_t *tmp_tvb = tvb_new_subset_length(tvb, body_start, body_len);\r\nif(m_info->protocol && idx == 1 && is_raw_data)\r\n{\r\ngssapi_encrypt_info_t encrypt;\r\nmemset(&encrypt, 0, sizeof(encrypt));\r\nencrypt.decrypt_gssapi_tvb=DECRYPT_GSSAPI_NORMAL;\r\ndissect_kerberos_encrypted_message(tmp_tvb, pinfo, subtree, &encrypt);\r\nif(encrypt.gssapi_decrypted_tvb){\r\ntmp_tvb = encrypt.gssapi_decrypted_tvb;\r\nis_raw_data = FALSE;\r\ncontent_type_str = m_info->orig_content_type;\r\nmessage_info.media_str = m_info->orig_parameters;\r\n} else if(encrypt.gssapi_encrypted_tvb) {\r\ntmp_tvb = encrypt.gssapi_encrypted_tvb;\r\nproto_tree_add_expert(tree, pinfo, &ei_multipart_decryption_not_possible, tmp_tvb, 0, -1);\r\n}\r\n}\r\nif (!is_raw_data &&\r\ncontent_type_str) {\r\ngboolean dissected;\r\nif(content_encoding_str && remove_base64_encoding) {\r\nif(!g_ascii_strncasecmp(content_encoding_str, "base64", 6))\r\ntmp_tvb = base64_decode(pinfo, tmp_tvb, filename ? filename : (mimetypename ? mimetypename : content_type_str));\r\n}\r\ndissected = dissector_try_string(multipart_media_subdissector_table,\r\ncontent_type_str, tmp_tvb, pinfo, subtree, &message_info);\r\nif (! dissected) {\r\ndissected = dissector_try_string(media_type_dissector_table,\r\ncontent_type_str, tmp_tvb, pinfo, subtree, &message_info);\r\n}\r\nif (! dissected) {\r\nconst char *save_match_string = pinfo->match_string;\r\npinfo->match_string = content_type_str;\r\ncall_dissector_with_data(media_handle, tmp_tvb, pinfo, subtree, &message_info);\r\npinfo->match_string = save_match_string;\r\n}\r\nmessage_info.media_str = NULL;\r\n} else {\r\ncall_data_dissector(tmp_tvb, pinfo, subtree);\r\n}\r\nproto_item_set_len(ti, boundary_start - start);\r\nif (*last_boundary == TRUE) {\r\nproto_tree_add_item(tree, hf_multipart_last_boundary, tvb, boundary_start, boundary_line_len, ENC_NA|ENC_ASCII);\r\n} else {\r\nproto_tree_add_item(tree, hf_multipart_boundary, tvb, boundary_start, boundary_line_len, ENC_NA|ENC_ASCII);\r\n}\r\ng_free(filename);\r\ng_free(mimetypename);\r\nreturn boundary_start + boundary_line_len;\r\n}\r\n}\r\nstatic int dissect_multipart(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\nproto_tree *subtree;\r\nproto_item *ti;\r\nproto_item *type_ti;\r\nhttp_message_info_t *message_info = (http_message_info_t *)data;\r\nmultipart_info_t *m_info = get_multipart_info(pinfo, message_info);\r\ngint header_start = 0;\r\ngint body_index = 0;\r\ngboolean last_boundary = FALSE;\r\nif (m_info == NULL) {\r\nproto_tree_add_expert(tree, pinfo, &ei_multipart_no_required_parameter, tvb, 0, -1);\r\ncall_data_dissector(tvb, pinfo, tree);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nti = proto_tree_add_item(tree, proto_multipart,\r\ntvb, 0, -1, ENC_NA);\r\nsubtree = proto_item_add_subtree(ti, ett_multipart);\r\nproto_item_append_text(ti, ", Type: %s, Boundary: \"%s\"",\r\nm_info->type, m_info->boundary);\r\ntype_ti = proto_tree_add_string(subtree, hf_multipart_type,\r\ntvb, 0, 0, pinfo->match_string);\r\nPROTO_ITEM_SET_GENERATED(type_ti);\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\nheader_start = process_preamble(subtree, tvb, m_info, &last_boundary);\r\nif (header_start == -1) {\r\ncall_data_dissector(tvb, pinfo, subtree);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nwhile (last_boundary == FALSE) {\r\nheader_start = process_body_part(subtree, tvb, message_info, m_info,\r\npinfo, header_start, body_index++, &last_boundary);\r\nif (header_start == -1) {\r\nreturn tvb_reported_length(tvb);\r\n}\r\n}\r\nif (tvb_reported_length_remaining(tvb, header_start) > 0) {\r\nproto_tree_add_item(subtree, hf_multipart_trailer, tvb, header_start, -1, ENC_NA);\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic gint\r\nis_known_multipart_header(const char *header_str, guint len)\r\n{\r\nguint i;\r\nfor (i = 1; i < array_length(multipart_headers); i++) {\r\nif (len == strlen(multipart_headers[i].name) &&\r\ng_ascii_strncasecmp(header_str, multipart_headers[i].name, len) == 0)\r\nreturn i;\r\nif (multipart_headers[i].compact_name != NULL &&\r\nlen == strlen(multipart_headers[i].compact_name) &&\r\ng_ascii_strncasecmp(header_str, multipart_headers[i].compact_name, len) == 0)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nvoid\r\nproto_register_multipart(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_multipart_type,\r\n{ "Type",\r\n"mime_multipart.type",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\n"MIME multipart encapsulation type", HFILL\r\n}\r\n},\r\n{ &hf_multipart_part,\r\n{ "Encapsulated multipart part",\r\n"mime_multipart.part",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_multipart_sec_token_len,\r\n{ "Length of security token",\r\n"mime_multipart.header.sectoken-length",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\n"Length of the Kerberos BLOB which follows this token", HFILL\r\n}\r\n},\r\n{ &hf_header_array[POS_CONTENT_DESCRIPTION],\r\n{ "Content-Description",\r\n"mime_multipart.header.content-description",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\n"Content-Description Header", HFILL\r\n}\r\n},\r\n{ &hf_header_array[POS_CONTENT_DISPOSITION],\r\n{ "Content-Disposition",\r\n"mime_multipart.header.content-disposition",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\n"RFC 2183: Content-Disposition Header", HFILL\r\n}\r\n},\r\n{ &hf_header_array[POS_CONTENT_ENCODING],\r\n{ "Content-Encoding",\r\n"mime_multipart.header.content-encoding",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\n"Content-Encoding Header", HFILL\r\n}\r\n},\r\n{ &hf_header_array[POS_CONTENT_ID],\r\n{ "Content-Id",\r\n"mime_multipart.header.content-id",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\n"RFC 2045: Content-Id Header", HFILL\r\n}\r\n},\r\n{ &hf_header_array[POS_CONTENT_LANGUAGE],\r\n{ "Content-Language",\r\n"mime_multipart.header.content-language",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\n"Content-Language Header", HFILL\r\n}\r\n},\r\n{ &hf_header_array[POS_CONTENT_LENGTH],\r\n{ "Content-Length",\r\n"mime_multipart.header.content-length",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Content-Length Header", HFILL\r\n}\r\n},\r\n{ &hf_header_array[POS_CONTENT_TRANSFER_ENCODING],\r\n{ "Content-Transfer-Encoding",\r\n"mime_multipart.header.content-transfer-encoding",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\n"RFC 2045: Content-Transfer-Encoding Header", HFILL\r\n}\r\n},\r\n{ &hf_header_array[POS_CONTENT_TYPE],\r\n{ "Content-Type",\r\n"mime_multipart.header.content-type",\r\nFT_STRING, BASE_NONE,NULL,0x0,\r\n"Content-Type Header", HFILL\r\n}\r\n},\r\n{ &hf_header_array[POS_ORIGINALCONTENT],\r\n{ "OriginalContent",\r\n"mime_multipart.header.originalcontent",\r\nFT_STRING, BASE_NONE,NULL,0x0,\r\n"Original Content-Type Header", HFILL\r\n}\r\n},\r\n{ &hf_multipart_first_boundary, { "First boundary", "mime_multipart.first_boundary", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_multipart_preamble, { "Preamble", "mime_multipart.preamble", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_multipart_last_boundary, { "Last boundary", "mime_multipart.last_boundary", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_multipart_boundary, { "Boundary", "mime_multipart.boundary", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_multipart_trailer, { "Trailer", "mime_multipart.trailer", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n};\r\nmodule_t *multipart_module;\r\nexpert_module_t* expert_multipart;\r\nstatic gint *ett[] = {\r\n&ett_multipart,\r\n&ett_multipart_main,\r\n&ett_multipart_body,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_multipart_no_required_parameter, { "mime_multipart.no_required_parameter", PI_PROTOCOL, PI_ERROR, "The multipart dissector could not find a required parameter.", EXPFILL }},\r\n{ &ei_multipart_decryption_not_possible, { "mime_multipart.decryption_not_possible", PI_UNDECODED, PI_WARN, "The multipart dissector could not decrypt the message.", EXPFILL }},\r\n};\r\nproto_multipart = proto_register_protocol(\r\n"MIME Multipart Media Encapsulation",\r\n"MIME multipart",\r\n"mime_multipart");\r\nproto_register_field_array(proto_multipart, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_multipart = expert_register_protocol(proto_multipart);\r\nexpert_register_field_array(expert_multipart, ei, array_length(ei));\r\nmultipart_module = prefs_register_protocol(proto_multipart, NULL);\r\nprefs_register_bool_preference(multipart_module,\r\n"display_unknown_body_as_text",\r\n"Display bodies without media type as text",\r\n"Display multipart bodies with no media type dissector"\r\n" as raw text (may cause problems with binary data).",\r\n&display_unknown_body_as_text);\r\nprefs_register_bool_preference(multipart_module,\r\n"remove_base64_encoding",\r\n"Remove base64 encoding from bodies",\r\n"Remove any base64 content-transfer encoding from bodies. "\r\n"This supports export of the body and its further dissection.",\r\n&remove_base64_encoding);\r\nmultipart_media_subdissector_table = register_dissector_table(\r\n"multipart_media_type",\r\n"Internet media type (for multipart processing)",\r\nproto_multipart, FT_STRING, BASE_NONE);\r\n}\r\nvoid\r\nproto_reg_handoff_multipart(void)\r\n{\r\ndissector_handle_t multipart_handle;\r\nmedia_handle = find_dissector_add_dependency("media", proto_multipart);\r\ngssapi_handle = find_dissector_add_dependency("gssapi", proto_multipart);\r\nmedia_type_dissector_table = find_dissector_table("media_type");\r\nmultipart_handle = create_dissector_handle(\r\ndissect_multipart, proto_multipart);\r\ndissector_add_string("media_type",\r\n"multipart/mixed", multipart_handle);\r\ndissector_add_string("media_type",\r\n"multipart/related", multipart_handle);\r\ndissector_add_string("media_type",\r\n"multipart/alternative", multipart_handle);\r\ndissector_add_string("media_type",\r\n"multipart/form-data", multipart_handle);\r\ndissector_add_string("media_type",\r\n"multipart/report", multipart_handle);\r\ndissector_add_string("media_type",\r\n"multipart/signed", multipart_handle);\r\ndissector_add_string("media_type",\r\n"multipart/encrypted", multipart_handle);\r\ndissector_add_string("media_type",\r\n"multipart/", multipart_handle);\r\n}
