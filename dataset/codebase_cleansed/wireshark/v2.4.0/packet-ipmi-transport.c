static void\r\nlan_serial_00(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_lan00_sip, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_trn_lan00_byte1,\r\nbyte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nlan_serial_01(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Authentication types supported: ",\r\n"No authentication types supported for this channel", ett_ipmi_trn_lan01_byte1,\r\nlanXX_authtypes_byte, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nlan_serial_02(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Authentication types for Callback level: ",\r\n"No authentication types enabled", ett_ipmi_trn_lan02_byte1,\r\nlanXX_authtypes_byte, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, "Authentication types for User level: ",\r\n"No authentication types enabled", ett_ipmi_trn_lan02_byte2,\r\nlanXX_authtypes_byte, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 2, 1, "Authentication types for Operator level: ",\r\n"No authentication types enabled", ett_ipmi_trn_lan02_byte3,\r\nlanXX_authtypes_byte, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 3, 1, "Authentication types for Administrator level: ",\r\n"No authentication types enabled", ett_ipmi_trn_lan02_byte4,\r\nlanXX_authtypes_byte, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 4, 1, "Authentication types for OEM level: ",\r\n"No authentication types enabled", ett_ipmi_trn_lan02_byte5,\r\nlanXX_authtypes_byte, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nlan_03(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan03_ip, tvb, 0, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\nlan_04(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_lan04_ipsrc, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_trn_lan04_byte1,\r\nbyte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nlan_05(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan05_ether, tvb, 0, 6, ENC_NA);\r\n}\r\nstatic void\r\nlan_06(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan06_subnet, tvb, 0, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\nlan_07(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte2[] = { &hf_ipmi_trn_lan07_flags, NULL };\r\nstatic const int *byte3[] = { &hf_ipmi_trn_lan07_precedence, &hf_ipmi_trn_lan07_tos, NULL };\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan07_ttl, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_trn_lan07_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 2, 1, NULL, NULL, ett_ipmi_trn_lan07_byte3, byte3, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nlan_08(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan08_rmcp_port, tvb, 0, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nlan_09(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan09_rmcp_port, tvb, 0, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nlan_10(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_lan10_responses, &hf_ipmi_trn_lan10_gratuitous, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_trn_lan10_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nlan_11(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan11_arp_interval, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nlan_12(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan12_def_gw_ip, tvb, 0, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\nlan_13(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan13_def_gw_mac, tvb, 0, 6, ENC_NA);\r\n}\r\nstatic void\r\nlan_14(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan14_bkp_gw_ip, tvb, 0, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\nlan_15(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan15_bkp_gw_mac, tvb, 0, 6, ENC_NA);\r\n}\r\nstatic void\r\nlan_16(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan16_comm_string, tvb, 0, 18, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nlan_17(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_lan17_num_dst, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_trn_lan17_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nlan_18(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_lan18_dst_selector, NULL };\r\nstatic const int *byte2[] = { &hf_ipmi_trn_lan18_ack, &hf_ipmi_trn_lan18_dst_type, NULL };\r\nstatic const int *byte4[] = { &hf_ipmi_trn_lan18_retries, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_trn_lan18_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_trn_lan18_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan18_tout, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_trn_lan18_byte4, byte4, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nlan_19(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_lan19_dst_selector, NULL };\r\nstatic const int *byte2[] = { &hf_ipmi_trn_lan19_addr_format, NULL };\r\nstatic const int *byte3[] = { &hf_ipmi_trn_lan19_gw_sel, NULL };\r\nguint8 v;\r\nv = tvb_get_guint8(tvb, 1) >> 4;\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_trn_lan19_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_trn_lan19_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nif (v == 0) {\r\nproto_tree_add_bitmask_text(tree, tvb, 2, 1, NULL, NULL, ett_ipmi_trn_lan19_byte3, byte3, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan19_ip, tvb, 3, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan19_mac, tvb, 7, 6, ENC_NA);\r\nreturn;\r\n} else if (v == 1) {\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_addr, tvb, 2, 16, ENC_NA);\r\nreturn;\r\n}\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan19_address, tvb, 2, -1, ENC_NA);\r\n}\r\nstatic void\r\nlan_20(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte12[] = { &hf_ipmi_trn_lan20_vlan_id_enable, &hf_ipmi_trn_lan20_vlan_id, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 2, NULL, NULL, ett_ipmi_trn_lan20_byte12, byte12, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nlan_21(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_lan21_vlan_prio, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_trn_lan21_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nlan_22(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_lan22_num_cs_entries, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_trn_lan22_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nlan_23(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nguint i;\r\nguint8 v;\r\nfor (i = 0; i < 16; i++) {\r\nv = tvb_get_guint8(tvb, i + 1);\r\nproto_tree_add_uint_format(tree, hf_ipmi_trn_lan23_cs_entry, tvb, i + 1, 1,\r\nv, "Cipher Suite ID entry %c: %u", 'A' + i, v);\r\n}\r\n}\r\nstatic void\r\nlan_24(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *ett[] = { &ett_ipmi_trn_lan24_byte1, &ett_ipmi_trn_lan24_byte2, &ett_ipmi_trn_lan24_byte3,\r\n&ett_ipmi_trn_lan24_byte4, &ett_ipmi_trn_lan24_byte5, &ett_ipmi_trn_lan24_byte6, &ett_ipmi_trn_lan24_byte7,\r\n&ett_ipmi_trn_lan24_byte8 };\r\nproto_tree *s_tree;\r\nguint i;\r\nguint8 v, v1, v2;\r\nfor (i = 0; i < 8; i++) {\r\nv = tvb_get_guint8(tvb, i + 1);\r\nv1 = v & 0x0f;\r\nv2 = v >> 4;\r\ns_tree = proto_tree_add_subtree_format(tree, tvb, i + 1, 1,\r\n*ett[i], NULL, "Cipher Suite #%d: %s (0x%02x), Cipher Suite #%d: %s (0x%02x)",\r\ni * 2 + 1, val_to_str_const(v1, lan24_priv_vals, "Reserved"), v1,\r\ni * 2 + 2, val_to_str_const(v2, lan24_priv_vals, "Reserved"), v2);\r\nproto_tree_add_uint_format_value(s_tree, hf_ipmi_trn_lan24_priv1, tvb, i + 1, 1,\r\nv2 << 4, " #%d: %s (0x%02x)", i * 2 + 2, val_to_str_const(v2, lan24_priv_vals, "Reserved"), v2);\r\nproto_tree_add_uint_format_value(s_tree, hf_ipmi_trn_lan24_priv2, tvb, i + 1, 1,\r\nv1, " #%d: %s (0x%02x)", i * 2 + 1, val_to_str_const(v1, lan24_priv_vals, "Reserved"), v1);\r\n}\r\n}\r\nstatic void\r\nlan_25(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_lan25_dst_selector, NULL };\r\nstatic const int *byte2[] = { &hf_ipmi_trn_lan25_addr_format, NULL };\r\nstatic const int *byte34[] = { &hf_ipmi_trn_lan25_uprio, &hf_ipmi_trn_lan25_cfi, &hf_ipmi_trn_lan25_vlan_id, NULL };\r\nguint8 v;\r\nv = tvb_get_guint8(tvb, 1) >> 4;\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_trn_lan25_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_trn_lan25_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nswitch (v) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nproto_tree_add_bitmask_text(tree, tvb, 2, 2, NULL, NULL, ett_ipmi_trn_lan25_byte34,\r\nbyte34, ENC_LITTLE_ENDIAN, 0);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan25_address, tvb, 2, -1, ENC_LITTLE_ENDIAN);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nlan_26(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan26_gen_event, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan26_thresh_number, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan26_reset_interval, tvb, 2, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan26_lock_interval, tvb, 4, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nlan_50(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_lan50_ipv6_only,\r\n&hf_ipmi_trn_lan50_both_ipv4_ipv6,\r\n&hf_ipmi_trn_lan50_ipv6_alerting, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Data 1", NULL, ett_ipmi_trn_lan50_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nlan_51(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan51_enables, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nlan_52(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan52_traffic_class, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nlan_53_78(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_hop_limit, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nlan_54(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan54_flow_label, tvb, 0, 3, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\nlan_55(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte3[] = { &hf_ipmi_trn_lan55_dhcpv6_support,\r\n&hf_ipmi_trn_lan55_slaac_support, NULL };\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan55_static_addr_max, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan55_dynamic_addr_max, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 2, 1, NULL, NULL, ett_ipmi_trn_lan55_byte3, byte3, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nlan_56(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte2[] = { &hf_ipmi_trn_lanXX_addr_type,\r\n&hf_ipmi_trn_lanXX_addr_enable, NULL };\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_addr_selector, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_trn_lan56_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_addr, tvb, 2, 16, ENC_NA);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_prefix_len, tvb, 18, 1, ENC_LITTLE_ENDIAN);\r\nif (tvb_captured_length(tvb) > 19) {\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_addr_status, tvb, 19, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nlan_57_60(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_max_duid_blocks, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nlan_58_61(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_duid_selector, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_block_selector, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_duid, tvb, 2, -1, ENC_NA);\r\n}\r\nstatic void\r\nlan_59(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_addr_selector, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_addr_type, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_addr, tvb, 2, 16, ENC_NA);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_prefix_len, tvb, 18, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_addr_status, tvb, 19, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nlan_62_79(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_timing_support, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nlan_63(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nguint8 v;\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_iface_selector, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_block_selector, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nv = tvb_get_guint8(tvb, 1);\r\nif (v == 0) {\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_sol_max_delay, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_sol_timeout, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_sol_max_rt, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_req_timeout, tvb, 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_req_max_rt, tvb, 6, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_req_max_rc, tvb, 7, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_cnf_max_delay, tvb, 8, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_cnf_timeout, tvb, 9, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_cnf_max_rt, tvb, 10, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_cnf_max_rd, tvb, 11, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_ren_timeout, tvb, 12, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_ren_max_rt, tvb, 13, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_reb_timeout, tvb, 14, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_reb_max_rt, tvb, 15, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_inf_max_delay, tvb, 16, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_inf_timeout, tvb, 17, 1, ENC_LITTLE_ENDIAN);\r\n} else if (v == 1) {\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_inf_max_rt, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_rel_timeout, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_rel_max_rc, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_dec_timeout, tvb, 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_dec_max_rc, tvb, 6, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan63_hop_count_limit, tvb, 7, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_01_param_data, tvb, 8, -1, ENC_NA);\r\n} else {\r\nproto_tree_add_item(tree, hf_ipmi_trn_01_param_data, tvb, 2, -1, ENC_NA);\r\n}\r\n}\r\nstatic void\r\nlan_64(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_lan64_static_cfg,\r\n&hf_ipmi_trn_lan64_dynamic_cfg, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_trn_lan64_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nlan_65_69(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_addr, tvb, 0, 16, ENC_NA);\r\n}\r\nstatic void\r\nlan_66_70(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_router_mac, tvb, 0, 6, ENC_NA);\r\n}\r\nstatic void\r\nlan_67_71(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_prefix_len, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nlan_68_72(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_router_prefix, tvb, 0, 16, ENC_NA);\r\n}\r\nstatic void\r\nlan_73(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan73_num_dynamic_sets, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nlan_74(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_router_selector, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_addr, tvb, 1, 16, ENC_NA);\r\n}\r\nstatic void\r\nlan_75(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_router_selector, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_router_mac, tvb, 1, 6, ENC_NA);\r\n}\r\nstatic void\r\nlan_76(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_router_selector, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_prefix_len, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nlan_77(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_router_selector, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_router_prefix, tvb, 1, 16, ENC_NA);\r\n}\r\nstatic void\r\nlan_80(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nguint8 v;\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_iface_selector, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lanXX_block_selector, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nv = tvb_get_guint8(tvb, 1);\r\nif (v == 0) {\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan80_max_rtr_solicitation_delay, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan80_rtr_solicitation_interval, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan80_max_rtr_solicitations, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan80_dup_addr_detect_transmits, tvb, 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan80_max_multicast_solicit, tvb, 6, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan80_max_unicast_solicit, tvb, 7, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan80_max_anycast_delay_time, tvb, 8, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan80_max_neighbor_advertisement, tvb, 9, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan80_reachable_time, tvb, 10, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan80_retrans_timer, tvb, 11, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan80_delay_first_probe_time, tvb, 12, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan80_max_random_factor, tvb, 13, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_lan80_min_random_factor, tvb, 14, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_01_param_data, tvb, 15, -1, ENC_NA);\r\n} else {\r\nproto_tree_add_item(tree, hf_ipmi_trn_01_param_data, tvb, 2, -1, ENC_NA);\r\n}\r\n}\r\nstatic void\r\nrq01(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_01_chan, NULL };\r\ntvbuff_t *next;\r\nconst char *desc;\r\nguint8 pno;\r\npno = tvb_get_guint8(tvb, 1);\r\nif (pno < array_length(lan_options)) {\r\ndesc = lan_options[pno].name;\r\n} else if (pno >= 0xC0) {\r\ndesc = "OEM";\r\n} else {\r\ndesc = "Reserved";\r\n}\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_trn_01_byte1,\r\nbyte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_trn_01_param, tvb, 1, 1,\r\npno, "%s (0x%02x)", desc, pno);\r\nif (pno < array_length(lan_options) && lan_options[pno].intrp) {\r\nnext = tvb_new_subset_remaining(tvb, 2);\r\nlan_options[pno].intrp(next, tree);\r\n} else {\r\nproto_tree_add_item(tree, hf_ipmi_trn_01_param_data, tvb, 2, -1, ENC_NA);\r\n}\r\n}\r\nstatic void\r\nrq02(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_02_getrev, &hf_ipmi_trn_02_chan, NULL };\r\nconst char *desc;\r\nguint8 pno;\r\npno = tvb_get_guint8(tvb, 1);\r\nipmi_set_data(pinfo, 0, pno);\r\nipmi_set_data(pinfo, 1, tvb_get_guint8(tvb, 0) & 0x80);\r\nif (!tree) {\r\nreturn;\r\n}\r\nif (pno < array_length(lan_options)) {\r\ndesc = lan_options[pno].name;\r\n} else if (pno >= 0xC0) {\r\ndesc = "OEM";\r\n} else {\r\ndesc = "Reserved";\r\n}\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_02_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_trn_02_param, tvb, 1, 1,\r\npno, "%s (0x%02x)", desc, pno);\r\nproto_tree_add_item(tree, hf_ipmi_trn_02_set, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_02_block, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs02(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_02_rev_present, &hf_ipmi_trn_02_rev_compat, NULL };\r\nproto_item *ti;\r\nproto_tree *subtree;\r\ntvbuff_t *next;\r\nconst char *desc;\r\nguint32 pno, req;\r\nti = proto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_02_rev, byte1, ENC_LITTLE_ENDIAN, 0);\r\nif (!ipmi_get_data(pinfo, 0, &pno) || !ipmi_get_data(pinfo, 1, &req)) {\r\nif (tvb_captured_length(tvb) > 1) {\r\nproto_tree_add_item(tree, hf_ipmi_trn_02_param_data, tvb, 1, -1, ENC_NA);\r\n};\r\nreturn;\r\n}\r\nif ((req & 0x80) && tvb_captured_length(tvb) > 1) {\r\nexpert_add_info(pinfo, ti, &ei_ipmi_trn_02_request_param_rev);\r\n} else if (!(req & 0x80) && tvb_captured_length(tvb) == 1) {\r\nexpert_add_info(pinfo, ti, &ei_ipmi_trn_02_request_param_data);\r\n}\r\nif (pno < array_length(lan_options)) {\r\ndesc = lan_options[pno].name;\r\n} else if (pno >= 0xC0) {\r\ndesc = "OEM";\r\n} else {\r\ndesc = "Reserved";\r\n}\r\nsubtree = proto_tree_add_subtree_format(tree, tvb, 0, 0, ett_ipmi_trn_parameter, NULL, "Parameter: %s", desc);\r\nif (tvb_captured_length(tvb) > 1) {\r\nif (pno < array_length(lan_options) && lan_options[pno].intrp) {\r\nnext = tvb_new_subset_remaining(tvb, 1);\r\nlan_options[pno].intrp(next, subtree);\r\n} else {\r\nproto_tree_add_item(subtree, hf_ipmi_trn_02_param_data, tvb, 1, -1, ENC_NA);\r\n}\r\n}\r\n}\r\nstatic void\r\nrq03(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_03_chan, NULL };\r\nstatic const int *byte2[] = { &hf_ipmi_trn_03_arp_resp, &hf_ipmi_trn_03_gratuitous_arp, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_03_rq_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_03_rq_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrs03(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_03_status_arp_resp,\r\n&hf_ipmi_trn_03_status_gratuitous_arp, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_03_rs_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrq04(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_04_chan, NULL };\r\nstatic const int *byte2[] = { &hf_ipmi_trn_04_clear, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_04_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_04_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrs04(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_04_rx_ippkts, tvb, 0, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_04_rx_iphdr_err, tvb, 2, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_04_rx_ipaddr_err, tvb, 4, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_04_rx_ippkts_frag, tvb, 6, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_04_tx_ippkts, tvb, 8, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_04_rx_udppkts, tvb, 10, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_04_rx_validrmcp, tvb, 12, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_04_rx_udpproxy, tvb, 14, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_04_dr_udpproxy, tvb, 16, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nserial_03(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_serial03_connmode, &hf_ipmi_trn_serial03_terminal,\r\n&hf_ipmi_trn_serial03_ppp, &hf_ipmi_trn_serial03_basic, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial03_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial04_timeout_fmt(gchar *s, guint32 v)\r\n{\r\nif (v) {\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d sec", 30 * v);\r\n}\r\nelse {\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "Does not timeout");\r\n}\r\n}\r\nstatic void\r\nserial_04(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial04_timeout, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial04_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_05(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_serial05_cbcp_callback,\r\n&hf_ipmi_trn_serial05_ipmi_callback, NULL };\r\nstatic const int *byte2[] = { &hf_ipmi_trn_serial05_cb_list, &hf_ipmi_trn_serial05_cb_user,\r\n&hf_ipmi_trn_serial05_cb_prespec, &hf_ipmi_trn_serial05_no_cb, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Callback capabilities: ", "None",\r\nett_ipmi_trn_serial05_byte1, byte1, ENC_LITTLE_ENDIAN, BMT_NO_TFS);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, "CBCP negotiation options: ", "None",\r\nett_ipmi_trn_serial05_byte2, byte2, ENC_LITTLE_ENDIAN, BMT_NO_TFS);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial05_cb_dest1, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial05_cb_dest2, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial05_cb_dest3, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nserial_06(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial06_inactivity,\r\n&hf_ipmi_trn_serial06_dcd, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial06_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_07(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial07_flowctl, &hf_ipmi_trn_serial07_dtrhangup, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_trn_serial07_bitrate, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial07_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_serial07_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_08(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial08_esc_powerup,\r\n&hf_ipmi_trn_serial08_esc_reset, &hf_ipmi_trn_serial08_switch_authcap,\r\n&hf_ipmi_trn_serial08_switch_rmcp, &hf_ipmi_trn_serial08_esc_switch1,\r\n&hf_ipmi_trn_serial08_esc_switch2, &hf_ipmi_trn_serial08_switch_dcdloss, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_trn_serial08_sharing,\r\n&hf_ipmi_trn_serial08_ping_callback, &hf_ipmi_trn_serial08_ping_direct,\r\n&hf_ipmi_trn_serial08_ping_retry, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Switch/escape settings", NULL,\r\nett_ipmi_trn_serial08_byte1, byte1, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, "Sharing/ping settings", NULL,\r\nett_ipmi_trn_serial08_byte2, byte2, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);\r\n}\r\nstatic void\r\nserial_09(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial09_ring_duration, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_trn_serial09_ring_dead, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial09_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_serial09_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_10(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial10_set_sel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial10_init_str, tvb, 1, -1, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nserial_11(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial11_esc_seq, tvb, 0, 5, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nserial_12(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial12_hangup_seq, tvb, 0, 8, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nserial_13(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial13_dial_cmd, tvb, 0, 8, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nserial_14(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial14_page_blackout, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nserial_15(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial15_comm_string, tvb, 0, 18, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nserial_16(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial16_ndest, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial16_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_17(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial17_dest_sel, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_trn_serial17_ack, &hf_ipmi_trn_serial17_dest_type, NULL };\r\nstatic const gint *byte4[] = { &hf_ipmi_trn_serial17_alert_retries, &hf_ipmi_trn_serial17_call_retries, NULL };\r\nconst gint *byte5[3] = { NULL, NULL, NULL };\r\nguint8 v;\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial17_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_serial17_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial17_alert_ack_timeout, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 3, 1, NULL, NULL,\r\nett_ipmi_trn_serial17_byte4, byte4, ENC_LITTLE_ENDIAN, 0);\r\nv = tvb_get_guint8(tvb, 1) & 0x0f;\r\nswitch (v) {\r\ncase 0:\r\ncase 3:\r\nbyte5[0] = &hf_ipmi_trn_serial17_dialstr_sel;\r\nbreak;\r\ncase 1:\r\nbyte5[0] = &hf_ipmi_trn_serial17_tap_sel;\r\nbreak;\r\ncase 2:\r\ncase 4:\r\nbyte5[0] = &hf_ipmi_trn_serial17_ipaddr_sel;\r\nbyte5[1] = &hf_ipmi_trn_serial17_ppp_sel;\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial17_unknown, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\nreturn;\r\n}\r\nproto_tree_add_bitmask_text(tree, tvb, 4, 1, NULL, NULL,\r\nett_ipmi_trn_serial17_byte5, byte5, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_18(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial18_call_retry, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nserial_19(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial19_destsel, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_trn_serial19_flowctl, &hf_ipmi_trn_serial19_dtrhangup,\r\n&hf_ipmi_trn_serial19_stopbits, &hf_ipmi_trn_serial19_charsize, &hf_ipmi_trn_serial19_parity, NULL };\r\nstatic const gint *byte3[] = { &hf_ipmi_trn_serial19_bitrate, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial19_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_serial19_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 2, 1, NULL, NULL,\r\nett_ipmi_trn_serial19_byte3, byte3, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_20(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial20_num_dial_strings, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial20_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_21(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial21_dialsel, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial21_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial21_blockno, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial21_dialstr, tvb, 2, 1, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nserial_22(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial22_num_ipaddrs, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial22_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_23(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial23_destsel, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial23_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial23_ipaddr, tvb, 1, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\nserial_24(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial24_num_tap_accounts, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial24_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_25(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte2[] = { &hf_ipmi_trn_serial25_dialstr_sel, &hf_ipmi_trn_serial25_tapsrv_sel, NULL };\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial25_tap_acct, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_serial25_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_26(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial26_tap_acct, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial26_tap_passwd, tvb, 1, 6, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nserial_27(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial27_tap_acct, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial27_tap_pager_id, tvb, 1, 16, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nserial_28(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial28_tapsrv_sel, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_trn_serial28_confirm, NULL };\r\nstatic const gint *byte10[] = { &hf_ipmi_trn_serial28_t2, &hf_ipmi_trn_serial28_t1, NULL };\r\nstatic const gint *byte11[] = { &hf_ipmi_trn_serial28_t4, &hf_ipmi_trn_serial28_t3, NULL };\r\nstatic const gint *byte12[] = { &hf_ipmi_trn_serial28_t6, &hf_ipmi_trn_serial28_t5, NULL };\r\nstatic const gint *byte13[] = { &hf_ipmi_trn_serial28_n2, &hf_ipmi_trn_serial28_n1, NULL };\r\nstatic const gint *byte14[] = { &hf_ipmi_trn_serial28_n4, &hf_ipmi_trn_serial28_n3, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial28_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_serial28_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial28_srvtype, tvb, 2, 3, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial28_ctrl_esc, tvb, 5, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 9, 1, NULL, NULL,\r\nett_ipmi_trn_serial28_byte10, byte10, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 10, 1, NULL, NULL,\r\nett_ipmi_trn_serial28_byte11, byte11, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 11, 1, NULL, NULL,\r\nett_ipmi_trn_serial28_byte12, byte12, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 12, 1, NULL, NULL,\r\nett_ipmi_trn_serial28_byte13, byte13, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 13, 1, NULL, NULL,\r\nett_ipmi_trn_serial28_byte14, byte14, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_29(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial29_op, &hf_ipmi_trn_serial29_lineedit,\r\n&hf_ipmi_trn_serial29_deletectl, &hf_ipmi_trn_serial29_echo, &hf_ipmi_trn_serial29_handshake, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_trn_serial29_o_newline, &hf_ipmi_trn_serial29_i_newline, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial29_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_serial29_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_30(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial30_snooping, &hf_ipmi_trn_serial30_snoopctl, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_trn_serial30_negot_ctl, &hf_ipmi_trn_serial30_use_xmit_accm,\r\n&hf_ipmi_trn_serial30_xmit_addr_comp, &hf_ipmi_trn_serial30_xmit_proto_comp, NULL };\r\nstatic const gint *byte3[] = { &hf_ipmi_trn_serial30_ipaddr, &hf_ipmi_trn_serial30_accm,\r\n&hf_ipmi_trn_serial30_addr_comp, &hf_ipmi_trn_serial30_proto_comp, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial30_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_serial30_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 2, 1, NULL, NULL,\r\nett_ipmi_trn_serial30_byte3, byte3, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_31(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial31_port, tvb, 0, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nserial_32(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial32_port, tvb, 0, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nserial_33(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial33_auth_proto, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial33_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_34(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial34_chap_name, tvb, 0, 16, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nserial_35(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial35_recv_accm, tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial35_xmit_accm, tvb, 4, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\nserial_36(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial36_snoop_accm, tvb, 0, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\nserial_37(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial37_num_ppp, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_serial37_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_38(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial38_acct_sel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial38_dialstr_sel, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nserial_39(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial39_acct_sel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial39_ipaddr, tvb, 1, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\nserial_40(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nint slen;\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial40_acct_sel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nslen = tvb_captured_length(tvb) - 1;\r\nif (slen > 16) {\r\nslen = 16;\r\n}\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial40_username, tvb, 1, slen, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nserial_41(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nint slen;\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial41_acct_sel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nslen = tvb_captured_length(tvb) - 1;\r\nif (slen > 16) {\r\nslen = 16;\r\n}\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial41_userdomain, tvb, 1, slen, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nserial_42(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nint slen;\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial42_acct_sel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nslen = tvb_captured_length(tvb) - 1;\r\nif (slen > 16) {\r\nslen = 16;\r\n}\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial42_userpass, tvb, 1, slen, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nserial_43(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial43_auth_proto, NULL };\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial43_acct_sel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_serial43_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_44(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial44_acct_sel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial44_hold_time, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nserial_45(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial45_src_ipaddr, tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial45_dst_ipaddr, tvb, 4, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\nserial_46(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial46_tx_bufsize, tvb, 0, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nserial_47(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial47_rx_bufsize, tvb, 0, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nserial_48(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial48_ipaddr, tvb, 0, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\nserial_49(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nint slen;\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial49_blockno, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nslen = tvb_captured_length(tvb) - 1;\r\nif (slen > 16) {\r\nslen = 16;\r\n}\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial49_dialstr, tvb, 1, slen, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nserial_50(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_serial50_115200, &hf_ipmi_trn_serial50_57600,\r\n&hf_ipmi_trn_serial50_38400, &hf_ipmi_trn_serial50_19200, &hf_ipmi_trn_serial50_9600, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Bit rate support: ", "None",\r\nett_ipmi_trn_serial50_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_51(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte2[] = { &hf_ipmi_trn_serial51_ipmi_channel, &hf_ipmi_trn_serial51_conn_num, NULL };\r\nstatic const gint *byte3[] = { &hf_ipmi_trn_serial51_ipmi_sharing,\r\n&hf_ipmi_trn_serial51_ipmi_sol, &hf_ipmi_trn_serial51_chan_num, NULL };\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial51_port_assoc_sel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_serial51_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 2, 1, NULL, NULL,\r\nett_ipmi_trn_serial51_byte3, byte3, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nserial_52(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial52_port_assoc_sel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial52_conn_name, tvb, 1, 16, ENC_NA);\r\n}\r\nstatic void\r\nserial_53(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial53_port_assoc_sel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_serial53_chan_name, tvb, 1, 16, ENC_NA);\r\n}\r\nstatic void\r\nrq10(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_10_chan, NULL };\r\ntvbuff_t *next;\r\nconst char *desc;\r\nguint8 pno;\r\npno = tvb_get_guint8(tvb, 1);\r\nif (pno < array_length(serial_options)) {\r\ndesc = serial_options[pno].name;\r\n} else if (pno >= 0xC0) {\r\ndesc = "OEM";\r\n} else {\r\ndesc = "Reserved";\r\n}\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_trn_10_byte1,\r\nbyte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_trn_10_param, tvb, 1, 1,\r\npno, "%s (0x%02x)", desc, pno);\r\nif (pno < array_length(serial_options)) {\r\nnext = tvb_new_subset_remaining(tvb, 2);\r\nserial_options[pno].intrp(next, tree);\r\n} else {\r\nproto_tree_add_item(tree, hf_ipmi_trn_10_param_data, tvb, 2, -1, ENC_NA);\r\n}\r\n}\r\nstatic void\r\nrq11(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_11_getrev, &hf_ipmi_trn_11_chan, NULL };\r\nconst char *desc;\r\nguint8 pno;\r\npno = tvb_get_guint8(tvb, 1);\r\nipmi_set_data(pinfo, 0, pno);\r\nipmi_set_data(pinfo, 1, tvb_get_guint8(tvb, 0));\r\nif (!tree) {\r\nreturn;\r\n}\r\nif (pno < array_length(serial_options)) {\r\ndesc = serial_options[pno].name;\r\n} else if (pno >= 0xC0) {\r\ndesc = "OEM";\r\n} else {\r\ndesc = "Reserved";\r\n}\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_11_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_trn_11_param, tvb, 1, 1,\r\npno, "%s (0x%02x)", desc, pno);\r\nproto_tree_add_item(tree, hf_ipmi_trn_11_set, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_11_block, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs11(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_trn_11_rev_present, &hf_ipmi_trn_11_rev_compat, NULL };\r\nproto_item *ti;\r\nproto_tree *subtree;\r\ntvbuff_t *next;\r\nconst char *desc;\r\nguint32 pno, req;\r\nti = proto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_11_rev, byte1, ENC_LITTLE_ENDIAN, 0);\r\nif (!ipmi_get_data(pinfo, 0, &pno) || !ipmi_get_data(pinfo, 1, &req)) {\r\nif (tvb_captured_length(tvb) > 1) {\r\nproto_tree_add_item(tree, hf_ipmi_trn_11_param_data, tvb, 1, -1, ENC_NA);\r\n};\r\nreturn;\r\n}\r\nif (pno < array_length(serial_options)) {\r\ndesc = serial_options[pno].name;\r\n} else if (pno >= 0xC0) {\r\ndesc = "OEM";\r\n} else {\r\ndesc = "Reserved";\r\n}\r\nif ((req & 0x80) && tvb_captured_length(tvb) > 1) {\r\nexpert_add_info(pinfo, ti, &ei_ipmi_trn_11_request_param_rev);\r\n} else if (!(req & 0x80) && tvb_captured_length(tvb) == 1) {\r\nexpert_add_info(pinfo, ti, &ei_ipmi_trn_11_request_param_data);\r\n}\r\nsubtree = proto_tree_add_subtree_format(tree, tvb, 0, 0, ett_ipmi_trn_parameter, NULL, "Parameter: %s", desc);\r\nif (tvb_captured_length(tvb) > 1) {\r\nif (pno < array_length(serial_options)) {\r\nnext = tvb_new_subset_remaining(tvb, 1);\r\nserial_options[pno].intrp(next, subtree);\r\n} else {\r\nproto_tree_add_item(subtree, hf_ipmi_trn_11_param_data, tvb, 1, -1, ENC_NA);\r\n}\r\n}\r\n}\r\nstatic void\r\nrq12(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_12_chan, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_trn_12_mux_setting, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_12_rq_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_12_rq_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrs12(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_12_sw_to_sys, &hf_ipmi_trn_12_sw_to_bmc,\r\n&hf_ipmi_trn_12_alert, &hf_ipmi_trn_12_msg, &hf_ipmi_trn_12_req, &hf_ipmi_trn_12_mux_state, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_12_rs_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrq13(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_13_chan, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_13_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrs13(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_13_code1, tvb, 0, 3, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(tree, hf_ipmi_trn_13_code2, tvb, 3, 3, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(tree, hf_ipmi_trn_13_code3, tvb, 6, 3, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(tree, hf_ipmi_trn_13_code4, tvb, 9, 3, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(tree, hf_ipmi_trn_13_code5, tvb, 12, 3, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nrq14(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_14_chan, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_14_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_trn_14_block, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_14_data, tvb, 2, 16, ENC_NA);\r\n}\r\nstatic void\r\nrq15(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_15_chan, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_15_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_trn_15_block, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs15(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_trn_15_data, tvb, 0, 16, ENC_NA);\r\n}\r\nstatic void\r\nrq16(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_16_chan, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_16_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_trn_16_src_port, tvb, 1, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_16_dst_port, tvb, 3, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_16_src_addr, tvb, 5, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_16_dst_addr, tvb, 9, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_16_bytes, tvb, 13, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\ntr17_fmt_blockno(gchar *s, guint32 v)\r\n{\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d%s",\r\nv, v ? "" : " (get received data length)");\r\n}\r\nstatic void\r\nrq17(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_17_chan, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_trn_17_clear, &hf_ipmi_trn_17_block_num, NULL };\r\nipmi_set_data(pinfo, 0, tvb_get_guint8(tvb, 1) & 0x7f);\r\nif (!tree) {\r\nreturn;\r\n}\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_17_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_17_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrs17(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nguint32 bno;\r\nif (ipmi_get_data(pinfo, 0, &bno) && bno == 0) {\r\nproto_tree_add_item(tree, hf_ipmi_trn_17_size, tvb, 0, 2, ENC_LITTLE_ENDIAN);\r\n} else {\r\nproto_tree_add_item(tree, hf_ipmi_trn_17_data, tvb, 0,\r\ntvb_captured_length(tvb) < 16 ? tvb_captured_length(tvb) : 16, ENC_NA);\r\n}\r\n}\r\nstatic void\r\nrq18(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_18_state, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_18_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_trn_18_ipmi_ver, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq19(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_19_chan, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_trn_19_dest_sel, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_19_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_19_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nparse_callback_options(tvbuff_t *tvb, guint offs, proto_tree *tree)\r\n{\r\nstatic const gint *usercap[] = { &hf_ipmi_trn_XX_cap_cbcp, &hf_ipmi_trn_XX_cap_ipmi, NULL };\r\nstatic const gint *cbcp[] = { &hf_ipmi_trn_XX_cbcp_from_list, &hf_ipmi_trn_XX_cbcp_user,\r\n&hf_ipmi_trn_XX_cbcp_prespec, &hf_ipmi_trn_XX_cbcp_nocb, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, offs, 1,\r\n"User callback capabilities: ", "None",\r\nett_ipmi_trn_XX_usercap, usercap, ENC_LITTLE_ENDIAN, BMT_NO_TFS);\r\nproto_tree_add_bitmask_text(tree, tvb, offs + 1, 1,\r\n"CBCP negotiation options: ", "None",\r\nett_ipmi_trn_XX_cbcp, cbcp, ENC_LITTLE_ENDIAN, BMT_NO_TFS);\r\nproto_tree_add_item(tree, hf_ipmi_trn_XX_dst1, tvb, offs + 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_XX_dst2, tvb, offs + 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_trn_XX_dst3, tvb, offs + 4, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq1a(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_1a_user, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_trn_1a_chan, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_1a_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_1a_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nparse_callback_options(tvb, 2, tree);\r\n}\r\nstatic void\r\nrq1b(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_trn_1b_user, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_trn_1b_chan, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_trn_1b_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_trn_1b_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrs1b(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nparse_callback_options(tvb, 0, tree);\r\n}\r\nvoid\r\nproto_register_ipmi_transport(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ipmi_trn_lan00_sip,\r\n{ "Set In Progress",\r\n"ipmi.lan00.sip", FT_UINT8, BASE_HEX, VALS(lan00_sip_vals), 0x03, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_oem,\r\n{ "OEM Proprietary",\r\n"ipmi.lanXX.oem", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_passwd,\r\n{ "Straight password/key",\r\n"ipmi.lanXX.passwd", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_md5,\r\n{ "MD5",\r\n"ipmi.lanXX.md5", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_md2,\r\n{ "MD2",\r\n"ipmi.lanXX.md2", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_none,\r\n{ "None",\r\n"ipmi.lanXX.none", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan03_ip,\r\n{ "IP Address",\r\n"ipmi.lan03.ip", FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan04_ipsrc,\r\n{ "IP Address Source",\r\n"ipmi.lan04.ipsrc", FT_UINT8, BASE_HEX, VALS(lan04_ipsrc_vals), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan05_ether,\r\n{ "MAC Address",\r\n"ipmi.lan05.mac", FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan06_subnet,\r\n{ "Subnet Mask",\r\n"ipmi.lan06.subnet", FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan07_ttl,\r\n{ "Time-to-live",\r\n"ipmi.lan07.ttl", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan07_flags,\r\n{ "Flags",\r\n"ipmi.lan07.flags", FT_UINT8, BASE_HEX, NULL, 0xe0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan07_precedence,\r\n{ "Precedence",\r\n"ipmi.lan07.precedence", FT_UINT8, BASE_DEC, NULL, 0xe0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan07_tos,\r\n{ "Type of service",\r\n"ipmi.lan07.tos", FT_UINT8, BASE_HEX, NULL, 0x1e, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan08_rmcp_port,\r\n{ "Primary RMCP Port Number",\r\n"ipmi.lan08.rmcp_port", FT_UINT16, BASE_CUSTOM, CF_FUNC(ipmi_fmt_udpport), 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan09_rmcp_port,\r\n{ "Secondary RMCP Port Number",\r\n"ipmi.lan09.rmcp_port", FT_UINT16, BASE_CUSTOM, CF_FUNC(ipmi_fmt_udpport), 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan10_responses,\r\n{ "ARP responses",\r\n"ipmi.lan10.responses", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan10_gratuitous,\r\n{ "Gratuitous ARPs",\r\n"ipmi.lan10.gratuitous", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan11_arp_interval,\r\n{ "Gratuitous ARP interval",\r\n"ipmi.lan10.arp_interval", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_500ms_0based), 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan12_def_gw_ip,\r\n{ "Default Gateway Address",\r\n"ipmi.lan12.def_gw_ip", FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan13_def_gw_mac,\r\n{ "Default Gateway MAC Address",\r\n"ipmi.lan13.def_gw_mac", FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan14_bkp_gw_ip,\r\n{ "Backup Gateway Address",\r\n"ipmi.lan14.bkp_gw_ip", FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan15_bkp_gw_mac,\r\n{ "Backup Gateway MAC Address",\r\n"ipmi.lan15.bkp_gw_mac", FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan16_comm_string,\r\n{ "Community String",\r\n"ipmi.lan16.comm_string", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan17_num_dst,\r\n{ "Number of Destinations",\r\n"ipmi.lan17.num_dst", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan18_dst_selector,\r\n{ "Destination Selector",\r\n"ipmi.lan18.dst_selector", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan18_ack,\r\n{ "Alert Acknowledged",\r\n"ipmi.lan18.ack", FT_BOOLEAN, 8, TFS(&lan18_ack_tfs), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan18_dst_type,\r\n{ "Destination Type",\r\n"ipmi.lan18.dst_type", FT_UINT8, BASE_HEX, VALS(lan18_dst_type_vals), 0x07, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan18_tout,\r\n{ "Timeout/Retry Interval",\r\n"ipmi.lan18.tout", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_1s_0based), 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan18_retries,\r\n{ "Retries",\r\n"ipmi.lan18.retries", FT_UINT8, BASE_DEC, NULL, 0x07, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan19_dst_selector,\r\n{ "Destination Selector",\r\n"ipmi.lan19.dst_selector", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan19_addr_format,\r\n{ "Address Format",\r\n"ipmi.lan19.addr_format", FT_UINT8, BASE_HEX, VALS(lan19_af_vals), 0xf0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan19_address,\r\n{ "Address (format unknown)",\r\n"ipmi.lan19.address", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan19_gw_sel,\r\n{ "Gateway selector",\r\n"ipmi.lan19.gw_sel", FT_BOOLEAN, 8, TFS(&lan19_gw_sel_tfs), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan19_ip,\r\n{ "Alerting IP Address",\r\n"ipmi.lan19.ip", FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan19_mac,\r\n{ "Alerting MAC Address",\r\n"ipmi.lan19.mac", FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan20_vlan_id_enable,\r\n{ "VLAN ID Enable",\r\n"ipmi.lan20.vlan_id_enable", FT_BOOLEAN, 16, TFS(&lan20_enable_tfs), 0x8000, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan20_vlan_id,\r\n{ "VLAN ID",\r\n"ipmi.lan20.vlan_id", FT_UINT16, BASE_HEX, NULL, 0x0fff, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan21_vlan_prio,\r\n{ "VLAN Priority",\r\n"ipmi.lan21.vlan_prio", FT_UINT8, BASE_DEC, NULL, 0x07, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan22_num_cs_entries,\r\n{ "Number of Cipher Suite Entries",\r\n"ipmi.lan22.num_cs_entries", FT_UINT8, BASE_DEC, NULL, 0x1f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan23_cs_entry,\r\n{ "Cipher Suite ID",\r\n"ipmi.lan23.cs_entry", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan24_priv1,\r\n{ "Maximum Privilege Level for Cipher Suite",\r\n"ipmi.lan24.priv", FT_UINT8, BASE_HEX, NULL, 0xF0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan24_priv2,\r\n{ "Maximum Privilege Level for Cipher Suite",\r\n"ipmi.lan24.priv", FT_UINT8, BASE_HEX, NULL, 0x0F, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan25_dst_selector,\r\n{ "Destination Selector",\r\n"ipmi.lan25.dst_selector", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan25_addr_format,\r\n{ "Address Format",\r\n"ipmi.lan25.addr_format", FT_UINT8, BASE_HEX, VALS(lan25_af_vals), 0xf0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan25_address,\r\n{ "Address (format unknown)",\r\n"ipmi.lan25.address", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan25_uprio,\r\n{ "User priority",\r\n"ipmi.lan25.uprio", FT_UINT16, BASE_DEC, NULL, 0xe000, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan25_cfi,\r\n{ "CFI",\r\n"ipmi.lan25.cfi", FT_BOOLEAN, 16, NULL, 0x1000, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan25_vlan_id,\r\n{ "VLAN ID",\r\n"ipmi.lan25.vlan_id", FT_UINT16, BASE_HEX, NULL, 0x0fff, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan26_gen_event,\r\n{ "Generate a Session Audit sensor \"Invalid password disable\" event message",\r\n"ipmi.lan26.gen_event", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan26_thresh_number,\r\n{ "Bad Password Threshold number",\r\n"ipmi.lan26.thresh_number", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan26_reset_interval,\r\n{ "Attempt Count Reset Interval",\r\n"ipmi.lan26.reset_interval", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan26_lock_interval,\r\n{ "User Lockout Interval",\r\n"ipmi.lan26.lock_interval", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan50_ipv6_only,\r\n{ "Support IPv6 addressing only",\r\n"ipmi.lan50.ipv6_only", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan50_both_ipv4_ipv6,\r\n{ "Support both IPv4 and IPv6 simultaneously",\r\n"ipmi.lan50.both", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan50_ipv6_alerting,\r\n{ "Support IPv6 destinations for LAN Alerting",\r\n"ipmi.lan50.both", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan51_enables,\r\n{ "Enables",\r\n"ipmi.lan51.enables", FT_UINT8, BASE_HEX, VALS(lan51_enables), 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan52_traffic_class,\r\n{ "Traffic Class",\r\n"ipmi.lan52.class", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_hop_limit,\r\n{ "Hop Limit",\r\n"ipmi.lanXX.hop_limit", FT_UINT8, BASE_DEC_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan54_flow_label,\r\n{ "Flow Label",\r\n"ipmi.lan.flow_label", FT_UINT24, BASE_HEX, NULL, 0xFFFFF, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan55_static_addr_max,\r\n{ "Static Address Max",\r\n"ipmi.lan55.static_max", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan55_dynamic_addr_max,\r\n{ "Dynamic Address Max",\r\n"ipmi.lan55.dynamic_max", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan55_dhcpv6_support,\r\n{ "DHCPv6 is supported",\r\n"ipmi.lan55.dhcpv6", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan55_slaac_support,\r\n{ "SLAAC is supported",\r\n"ipmi.lan55.slaac", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_addr_selector,\r\n{ "Address Selector",\r\n"ipmi.lanXX.addr_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_addr_type,\r\n{ "Address source/type",\r\n"ipmi.lanXX.addr_type", FT_UINT8, BASE_DEC, VALS(lanXX_addr_type), 0xF, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_addr_enable,\r\n{ "Address is enabled",\r\n"ipmi.lanXX.addr_enable", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_addr,\r\n{ "IPv6 Address",\r\n"ipmi.lanXX.addr", FT_IPv6, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_prefix_len,\r\n{ "Prefix Length",\r\n"ipmi.lanXX.prefix_len", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_addr_status,\r\n{ "Address status",\r\n"ipmi.lanXX.addr_status", FT_UINT8, BASE_DEC, VALS(lanXX_addr_status), 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_max_duid_blocks,\r\n{ "Maximum number of 16-byte blocks",\r\n"ipmi.lanXX.max_duid_blocks", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_duid_selector,\r\n{ "DUID selector",\r\n"ipmi.lanXX.duid_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_block_selector,\r\n{ "Block selector",\r\n"ipmi.lanXX.block_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_duid,\r\n{ "DUID data",\r\n"ipmi.lanXX.duid", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_timing_support,\r\n{ "Timing Configuration Support",\r\n"ipmi.lanXX.timing_support", FT_UINT8, BASE_DEC, VALS(lanXX_timing_support), 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_iface_selector,\r\n{ "IPv6 Interface selector",\r\n"ipmi.lanXX.iface_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_sol_max_delay,\r\n{ "SOL_MAX_DELAY",\r\n"ipmi.lan63.sol_max_delay", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_sol_timeout,\r\n{ "SOL_TIMEOUT",\r\n"ipmi.lan63.sol_timeout", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_sol_max_rt,\r\n{ "SOL_MAX_RT",\r\n"ipmi.lan63.sol_max_rt", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_req_timeout,\r\n{ "REQ_TIMEOUT",\r\n"ipmi.lan63.req_timeout", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_req_max_rt,\r\n{ "REQ_MAX_RT",\r\n"ipmi.lan63.req_max_rt", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_req_max_rc,\r\n{ "REQ_MAX_RC",\r\n"ipmi.lan63.req_max_rc", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_cnf_max_delay,\r\n{ "CNF_MAX_DELAY",\r\n"ipmi.lan63.cnf_max_delay", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_cnf_timeout,\r\n{ "CNF_TIMEOUT",\r\n"ipmi.lan63.cnf_timeout", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_cnf_max_rt,\r\n{ "CNF_MAX_RT",\r\n"ipmi.lan63.cnf_max_rt", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_cnf_max_rd,\r\n{ "CNF_MAX_RD",\r\n"ipmi.lan63.cnf_max_rd", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_ren_timeout,\r\n{ "REN_TIMEOUT",\r\n"ipmi.lan63.ren_timeout", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_ren_max_rt,\r\n{ "REN_MAX_RT",\r\n"ipmi.lan63.ren_max_rt", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_reb_timeout,\r\n{ "REB_TIMEOUT",\r\n"ipmi.lan63.reb_timeout", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_reb_max_rt,\r\n{ "REB_MAX_RT",\r\n"ipmi.lan63.reb_max_rt", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_inf_max_delay,\r\n{ "INF_MAX_DELAY",\r\n"ipmi.lan63.inf_max_delay", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_inf_timeout,\r\n{ "INF_TIMEOUT",\r\n"ipmi.lan63.inf_timeout", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_inf_max_rt,\r\n{ "INF_MAX_RT",\r\n"ipmi.lan63.inf_max_rt", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_rel_timeout,\r\n{ "REL_TIMEOUT",\r\n"ipmi.lan63.rel_timeout", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_rel_max_rc,\r\n{ "REL_MAX_RC",\r\n"ipmi.lan63.rel_max_rc", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_dec_timeout,\r\n{ "DEC_TIMEOUT",\r\n"ipmi.lan63.dec_timeout", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_dec_max_rc,\r\n{ "DEC_MAX_RC",\r\n"ipmi.lan63.dec_max_rc", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan63_hop_count_limit,\r\n{ "HOP_COUNT_LIMIT",\r\n"ipmi.lan63.hop_count_limit", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan64_static_cfg,\r\n{ "Enable static router address",\r\n"ipmi.lan64.static_cfg", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan64_dynamic_cfg,\r\n{ "Enable dynamic router address configuration",\r\n"ipmi.lan64.dynamic_cfg", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_router_selector,\r\n{ "Router selector",\r\n"ipmi.lanXX.router_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_router_mac,\r\n{ "MAC Address",\r\n"ipmi.lanXX.mac", FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lanXX_router_prefix,\r\n{ "Prefix Value",\r\n"ipmi.lanXX.prefix", FT_IPv6, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan73_num_dynamic_sets,\r\n{ "Number of Dynamic Router Info sets",\r\n"ipmi.lanXX.num_dynamic_sets", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan80_max_rtr_solicitation_delay,\r\n{ "MAX_RTR_SOLICITATIOIN_DELAY",\r\n"ipmi.lan80.max_rtr_sol_delay", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan80_rtr_solicitation_interval,\r\n{ "RTR_SOLICITATIOIN_INTERVAL",\r\n"ipmi.lan80.rtr_sol_interval", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan80_max_rtr_solicitations,\r\n{ "MAX_RTR_SOLICITATIOINS",\r\n"ipmi.lan80.max_rtr_sols", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan80_dup_addr_detect_transmits,\r\n{ "DupAddrDetectTransmits",\r\n"ipmi.lan80.dup_addr_transmits", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan80_max_multicast_solicit,\r\n{ "MAX_MULTICAST_SOLICIT",\r\n"ipmi.lan80.max_mcast_sol", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan80_max_unicast_solicit,\r\n{ "MAX_UNICAST_SOLICIT",\r\n"ipmi.lan80.max_ucast_sol", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan80_max_anycast_delay_time,\r\n{ "MAX_ANYCAST_DELAY_TIME",\r\n"ipmi.lan80.max_anycast_delay", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan80_max_neighbor_advertisement,\r\n{ "MAX_NEIGHBOR_ADVERTISEMENT",\r\n"ipmi.lan80.max_neigh_adv", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan80_reachable_time,\r\n{ "REACHABLE_TIME",\r\n"ipmi.lan80.reach_time", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan80_retrans_timer,\r\n{ "RETRANS_TIMER",\r\n"ipmi.lan80.retrans_timer", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan80_delay_first_probe_time,\r\n{ "DELAY_FIRST_PROBE_TIME",\r\n"ipmi.lan80.delay_first_probe", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan80_max_random_factor,\r\n{ "MAX_RANDOM_FACTOR",\r\n"ipmi.lan80.max_rand", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_lan80_min_random_factor,\r\n{ "MIN_RANDOM_FACTOR",\r\n"ipmi.lan80.min_rand", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial03_connmode,\r\n{ "Connection Mode",\r\n"ipmi.serial03.connmode", FT_BOOLEAN, 8, TFS(&serial03_connmode_tfs), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial03_terminal,\r\n{ "Terminal Mode",\r\n"ipmi.serial03.terminal", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial03_ppp,\r\n{ "PPP Mode",\r\n"ipmi.serial03.ppp", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial03_basic,\r\n{ "Basic Mode",\r\n"ipmi.serial03.basic", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial04_timeout,\r\n{ "Session Inactivity Timeout",\r\n"ipmi.serial04.timeout", FT_UINT8, BASE_CUSTOM, CF_FUNC(serial04_timeout_fmt), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial05_cbcp_callback,\r\n{ "CBCP Callback",\r\n"ipmi.serial05.cbcp", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial05_ipmi_callback,\r\n{ "IPMI Callback",\r\n"ipmi.serial05.ipmi", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial05_cb_list,\r\n{ "Callback to list of possible numbers",\r\n"ipmi.serial05.cb_list", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial05_cb_user,\r\n{ "Callback to user-specifiable number",\r\n"ipmi.serial05.cb_user", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial05_cb_prespec,\r\n{ "Callback to pre-specified number",\r\n"ipmi.serial05.cb_prespec", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial05_no_cb,\r\n{ "No callback",\r\n"ipmi.serial05.no_cb", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial05_cb_dest1,\r\n{ "Callback destination 1",\r\n"ipmi.serial05.cb_dest1", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial05_cb_dest2,\r\n{ "Callback destination 2",\r\n"ipmi.serial05.cb_dest2", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial05_cb_dest3,\r\n{ "Callback destination 3",\r\n"ipmi.serial05.cb_dest3", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial06_inactivity,\r\n{ "Session Inactivity Timeout",\r\n"ipmi.serial06.inactivity", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial06_dcd,\r\n{ "Close on DCD Loss",\r\n"ipmi.serial06.dcd", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial07_flowctl,\r\n{ "Flow Control",\r\n"ipmi.serial07.flowctl", FT_UINT8, BASE_HEX, VALS(serialXX_flowctl_vals), 0xc0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial07_dtrhangup,\r\n{ "DTR Hang-up",\r\n"ipmi.serial07.dtrhangup", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial07_bitrate,\r\n{ "Bit rate",\r\n"ipmi.serial07.bitrate", FT_UINT8, BASE_HEX, VALS(serialXX_bitrate_vals), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial08_esc_powerup,\r\n{ "Power-up/wakeup via ESC-^",\r\n"ipmi.serial08.esc_powerup", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial08_esc_reset,\r\n{ "Hard reset via ESC-R-ESC-r-ESC-R",\r\n"ipmi.serial08.esc_reset", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial08_switch_authcap,\r\n{ "Baseboard-to-BMC switch on Get Channel Auth Capabilities",\r\n"ipmi.serial08.switch_authcap", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial08_switch_rmcp,\r\n{ "Switch to BMC on IPMI-RMCP pattern",\r\n"ipmi.serial08.switch_rmcp", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial08_esc_switch1,\r\n{ "BMC-to-Baseboard switch via ESC-Q",\r\n"ipmi.serial08.esc_switch1", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial08_esc_switch2,\r\n{ "Baseboard-to-BMC switch via ESC-(",\r\n"ipmi.serial08.esc_switch2", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial08_switch_dcdloss,\r\n{ "Switch to BMC on DCD loss",\r\n"ipmi.serial08.switch_dcdloss", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial08_sharing,\r\n{ "Serial Port Sharing",\r\n"ipmi.serial08.sharing", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial08_ping_callback,\r\n{ "Serial/Modem Connection Active during callback",\r\n"ipmi.serial08.ping_callback", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial08_ping_direct,\r\n{ "Serial/Modem Connection Active during direct call",\r\n"ipmi.serial08.ping_direct", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial08_ping_retry,\r\n{ "Retry Serial/Modem Connection Active",\r\n"ipmi.serial08.ping_retry", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial09_ring_duration,\r\n{ "Ring Duration",\r\n"ipmi.serial09.ring_duration", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_500ms_1based), 0x3f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial09_ring_dead,\r\n{ "Ring Dead Time",\r\n"ipmi.serial09.ring_dead", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_500ms_0based), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial10_set_sel,\r\n{ "Set selector (16-byte block #)",\r\n"ipmi.serial10.set_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial10_init_str,\r\n{ "Modem Init String",\r\n"ipmi.serial10.init_str", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial11_esc_seq,\r\n{ "Modem Escape Sequence",\r\n"ipmi.serial11.esc_seq", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial12_hangup_seq,\r\n{ "Modem Hang-up Sequence",\r\n"ipmi.serial12.hangup_seq", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial13_dial_cmd,\r\n{ "Modem Dial Command",\r\n"ipmi.serial13.dial_cmd", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial14_page_blackout,\r\n{ "Page Blackout Interval (minutes)",\r\n"ipmi.serial14.page_blackout", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial15_comm_string,\r\n{ "Community String",\r\n"ipmi.serial15.comm_string", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial16_ndest,\r\n{ "Number of non-volatile Alert Destinations",\r\n"ipmi.serial16.ndest", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial17_dest_sel,\r\n{ "Destination Selector",\r\n"ipmi.serial17.dest_sel", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial17_ack,\r\n{ "Alert Acknowledge",\r\n"ipmi.serial17.ack", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial17_dest_type,\r\n{ "Destination Type",\r\n"ipmi.serial17.dest_type", FT_UINT8, BASE_HEX, VALS(serial17_dest_type_vals), 0x0f, NULL, HFILL }},\r\n#if 0\r\n{ &hf_ipmi_trn_serial17_ack_timeout,\r\n{ "Alert Acknowledge Timeout",\r\n"ipmi.serial17.ack_timeout", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n#endif\r\n{ &hf_ipmi_trn_serial17_alert_retries,\r\n{ "Alert retries",\r\n"ipmi.serial17.alert_retries", FT_UINT8, BASE_DEC, NULL, 0x70, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial17_call_retries,\r\n{ "Call retries",\r\n"ipmi.serial17.call_retries", FT_UINT8, BASE_DEC, NULL, 0x07, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial17_alert_ack_timeout,\r\n{ "Alert Acknowledge Timeout",\r\n"ipmi.serial17.alert_ack_timeout", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_1s_0based), 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial17_dialstr_sel,\r\n{ "Dial String Selector",\r\n"ipmi.serial17.dialstr_sel", FT_UINT8, BASE_DEC, NULL, 0xf0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial17_tap_sel,\r\n{ "TAP Account Selector",\r\n"ipmi.serial17.tap_sel", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial17_ipaddr_sel,\r\n{ "Destination IP Address Selector",\r\n"ipmi.serial17.ipaddr_sel", FT_UINT8, BASE_DEC, NULL, 0xf0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial17_ppp_sel,\r\n{ "PPP Account Set Selector",\r\n"ipmi.serial17.ppp_sel", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial17_unknown,\r\n{ "Destination-specific (format unknown)",\r\n"ipmi.serial17.unknown", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial18_call_retry,\r\n{ "Call Retry Interval",\r\n"ipmi.serial18.call_retry", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial19_destsel,\r\n{ "Destination selector",\r\n"ipmi.serial19.destsel", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial19_flowctl,\r\n{ "Flow Control",\r\n"ipmi.serial19.flowctl", FT_UINT8, BASE_HEX, VALS(serialXX_flowctl_vals), 0xc0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial19_dtrhangup,\r\n{ "DTR Hang-up",\r\n"ipmi.serial19.dtrhangup", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial19_stopbits,\r\n{ "Stop bits",\r\n"ipmi.serial19.stopbits", FT_BOOLEAN, 8, TFS(&serial19_stopbits_tfs), 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial19_charsize,\r\n{ "Character size",\r\n"ipmi.serial19.charsize", FT_BOOLEAN, 8, TFS(&serial19_charsize_tfs), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial19_parity,\r\n{ "Parity",\r\n"ipmi.serial19.parity", FT_UINT8, BASE_HEX, VALS(serial19_parity_vals), 0x07, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial19_bitrate,\r\n{ "Bit rate",\r\n"ipmi.serial19.bitrate", FT_UINT8, BASE_HEX, VALS(serialXX_bitrate_vals), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial20_num_dial_strings,\r\n{ "Number of Dial Strings",\r\n"ipmi.serial20.num_dial_strings", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial21_dialsel,\r\n{ "Dial String Selector",\r\n"ipmi.serial21.dialsel", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial21_blockno,\r\n{ "Block number",\r\n"ipmi.serial21.blockno", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial21_dialstr,\r\n{ "Dial string",\r\n"ipmi.serial21.dialstr", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial22_num_ipaddrs,\r\n{ "Number of Alert Destination IP Addresses",\r\n"ipmi.serial22.num_ipaddrs", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial23_destsel,\r\n{ "Destination IP Address selector",\r\n"ipmi.serial23.destsel", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial23_ipaddr,\r\n{ "Destination IP Address",\r\n"ipmi.serial23.ipaddr", FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial24_num_tap_accounts,\r\n{ "Number of TAP Accounts",\r\n"ipmi.serial24.num_tap_accounts", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial25_tap_acct,\r\n{ "TAP Account Selector",\r\n"ipmi.serial25.tap_acct", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial25_dialstr_sel,\r\n{ "Dial String Selector",\r\n"ipmi.serial25.dialstr_sel", FT_UINT8, BASE_DEC, NULL, 0xf0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial25_tapsrv_sel,\r\n{ "TAP Service Settings Selector",\r\n"ipmi.serial25.tapsrv_sel", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial26_tap_acct,\r\n{ "TAP Account Selector",\r\n"ipmi.serial26.tap_acct", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial26_tap_passwd,\r\n{ "TAP Password",\r\n"ipmi.serial26.tap_passwd", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial27_tap_acct,\r\n{ "TAP Account Selector",\r\n"ipmi.serial27.tap_acct", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial27_tap_pager_id,\r\n{ "TAP Pager ID String",\r\n"ipmi.serial27.tap_pager_id", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial28_tapsrv_sel,\r\n{ "TAP Service Settings Selector",\r\n"ipmi.serial28.tapsrv_sel", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial28_confirm,\r\n{ "TAP Confirmation",\r\n"ipmi.serial28.confirm", FT_UINT8, BASE_HEX, VALS(serial28_confirm_vals), 0x03, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial28_srvtype,\r\n{ "TAP 'SST' Service Type",\r\n"ipmi.serial28.srvtype", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial28_ctrl_esc,\r\n{ "TAP Control-character escaping mask",\r\n"ipmi.serial28.ctrl_esc", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial28_t2,\r\n{ "TAP T2",\r\n"ipmi.serial28.tap_t2", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_500ms_0based), 0xf0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial28_t1,\r\n{ "TAP T1",\r\n"ipmi.serial28.tap_t1", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_1s_0based), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial28_t4,\r\n{ "TAP T4",\r\n"ipmi.serial28.tap_t4", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_1s_0based), 0xf0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial28_t3,\r\n{ "TAP T3",\r\n"ipmi.serial28.tap_t3", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_2s_0based), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial28_t6,\r\n{ "IPMI T6",\r\n"ipmi.serial28.ipmi_t6", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_1s_0based), 0xf0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial28_t5,\r\n{ "TAP T5",\r\n"ipmi.serial28.tap_t5", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_2s_0based), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial28_n2,\r\n{ "TAP N2",\r\n"ipmi.serial28.tap_n2", FT_UINT8, BASE_DEC, NULL, 0xf0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial28_n1,\r\n{ "TAP N1",\r\n"ipmi.serial28.tap_n1", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial28_n4,\r\n{ "IPMI N4",\r\n"ipmi.serial28.ipmi_n4", FT_UINT8, BASE_DEC, NULL, 0xf0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial28_n3,\r\n{ "TAP N3",\r\n"ipmi.serial28.tap_n3", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial29_op,\r\n{ "Parameter Operation",\r\n"ipmi.serial29.op", FT_UINT8, BASE_HEX, VALS(serial29_op_vals), 0xc0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial29_lineedit,\r\n{ "Line Editing",\r\n"ipmi.serial29.lineedit", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial29_deletectl,\r\n{ "Delete control",\r\n"ipmi.serial29.deletectl", FT_UINT8, BASE_HEX, VALS(serial29_delete_vals), 0x0c, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial29_echo,\r\n{ "Echo",\r\n"ipmi.serial29.echo", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial29_handshake,\r\n{ "Handshake",\r\n"ipmi.serial29.handshake", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial29_o_newline,\r\n{ "Output newline sequence",\r\n"ipmi.serial29.o_newline", FT_UINT8, BASE_HEX, VALS(serial29_o_nl_vals), 0xf0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial29_i_newline,\r\n{ "Input newline sequence",\r\n"ipmi.serial29.i_newline", FT_UINT8, BASE_HEX, VALS(serial29_i_nl_vals), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial30_snooping,\r\n{ "System Negotiation Snooping",\r\n"ipmi.serial30.snooping", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial30_snoopctl,\r\n{ "Snoop ACCM Control",\r\n"ipmi.serial30.snoopctl", FT_UINT8, BASE_HEX, VALS(serial30_snoopctl_vals), 0x03, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial30_negot_ctl,\r\n{ "BMC negotiates link parameters",\r\n"ipmi.serial30.negot_ctl", FT_UINT8, BASE_HEX, VALS(serial30_negoctl_vals), 0x30, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial30_use_xmit_accm,\r\n{ "Filtering incoming chars",\r\n"ipmi.serial30.filter", FT_BOOLEAN, 8, TFS(&serial30_filter_tfs), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial30_xmit_addr_comp,\r\n{ "Transmit with Address and Ctl Field Compression",\r\n"ipmi.serial30.xmit_addr_comp", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial30_xmit_proto_comp,\r\n{ "Transmit with Protocol Field Compression",\r\n"ipmi.serial30.xmit_proto_comp", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial30_ipaddr,\r\n{ "IP Address negotiation",\r\n"ipmi.serial30.ipaddr", FT_UINT8, BASE_HEX, VALS(serial30_ipaddr_val), 0x18, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial30_accm,\r\n{ "ACCM Negotiation",\r\n"ipmi.serial30.accm", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial30_addr_comp,\r\n{ "Address and Ctl Field Compression",\r\n"ipmi.serial30.addr_comp", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial30_proto_comp,\r\n{ "Protocol Field Compression",\r\n"ipmi.serial30.proto_comp", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial31_port,\r\n{ "Primary RMCP Port Number",\r\n"ipmi.serial31.port", FT_UINT16, BASE_CUSTOM, CF_FUNC(ipmi_fmt_udpport), 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial32_port,\r\n{ "Secondary RMCP Port Number",\r\n"ipmi.serial32.port", FT_UINT16, BASE_CUSTOM, CF_FUNC(ipmi_fmt_udpport), 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial33_auth_proto,\r\n{ "PPP Link Authentication Protocol",\r\n"ipmi.serial33.auth_proto", FT_UINT8, BASE_HEX, VALS(serialXX_proto_vals), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial34_chap_name,\r\n{ "CHAP Name",\r\n"ipmi.serial34.chap_name", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial35_recv_accm,\r\n{ "Receive ACCM",\r\n"ipmi.serial35.recv_accm", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial35_xmit_accm,\r\n{ "Transmit ACCM",\r\n"ipmi.serial35.xmit_accm", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial36_snoop_accm,\r\n{ "Snoop Receive ACCM",\r\n"ipmi.serial36.snoop_accm", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial37_num_ppp,\r\n{ "Number of PPP Accounts",\r\n"ipmi.serial37.num_ppp", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial38_acct_sel,\r\n{ "PPP Account Selector",\r\n"ipmi.serial38.acct_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial38_dialstr_sel,\r\n{ "Dial String Selector",\r\n"ipmi.serial38.dialstr_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial39_acct_sel,\r\n{ "PPP Account Selector",\r\n"ipmi.serial39.acct_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial39_ipaddr,\r\n{ "IP Address",\r\n"ipmi.serial39.ipaddr", FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial40_acct_sel,\r\n{ "PPP Account Selector",\r\n"ipmi.serial40.acct_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial40_username,\r\n{ "User Name",\r\n"ipmi.serial40.username", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial41_acct_sel,\r\n{ "PPP Account Selector",\r\n"ipmi.serial41.acct_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial41_userdomain,\r\n{ "User Domain",\r\n"ipmi.serial41.userdomain", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial42_acct_sel,\r\n{ "PPP Account Selector",\r\n"ipmi.serial42.acct_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial42_userpass,\r\n{ "User Password",\r\n"ipmi.serial42.userpass", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial43_acct_sel,\r\n{ "PPP Account Selector",\r\n"ipmi.serial43.acct_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial43_auth_proto,\r\n{ "Link Auth Type",\r\n"ipmi.serial43.auth_proto", FT_UINT8, BASE_HEX, VALS(serialXX_proto_vals), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial44_acct_sel,\r\n{ "PPP Account Selector",\r\n"ipmi.serial44.acct_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial44_hold_time,\r\n{ "Connection Hold Time",\r\n"ipmi.serial44.hold_time", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_1s_1based), 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial45_src_ipaddr,\r\n{ "Source IP Address",\r\n"ipmi.serial45.src_ipaddr", FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial45_dst_ipaddr,\r\n{ "Destination IP Address",\r\n"ipmi.serial45.dst_ipaddr", FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial46_tx_bufsize,\r\n{ "Transmit Buffer Size",\r\n"ipmi.serial46.tx_size", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial47_rx_bufsize,\r\n{ "Receive Buffer Size",\r\n"ipmi.serial47.rx_size", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial48_ipaddr,\r\n{ "Remote Console IP Address",\r\n"ipmi.serial48.ipaddr", FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial49_blockno,\r\n{ "Block number",\r\n"ipmi.serial49.blockno", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial49_dialstr,\r\n{ "Dial string",\r\n"ipmi.serial49.dialstr", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial50_115200,\r\n{ "115200",\r\n"ipmi.serial50.115200", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial50_57600,\r\n{ "57600",\r\n"ipmi.serial50.57600", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial50_38400,\r\n{ "38400",\r\n"ipmi.serial50.38400", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial50_19200,\r\n{ "19200",\r\n"ipmi.serial50.19200", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial50_9600,\r\n{ "9600",\r\n"ipmi.serial50.9600", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial51_port_assoc_sel,\r\n{ "Serial Port Association Entry",\r\n"ipmi.serial51.port_assoc_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial51_ipmi_channel,\r\n{ "IPMI Channel",\r\n"ipmi.serial51.ipmi_channel", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0xf0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial51_conn_num,\r\n{ "Connector number",\r\n"ipmi.serial51.conn_num", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial51_ipmi_sharing,\r\n{ "Used with IPMI Serial Port Sharing",\r\n"ipmi.serial51.ipmi_sharing", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial51_ipmi_sol,\r\n{ "Used with IPMI Serial-over-LAN",\r\n"ipmi.serial51.ipmi_sol", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial51_chan_num,\r\n{ "Serial controller channel number",\r\n"ipmi.serial51.chan_num", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial52_port_assoc_sel,\r\n{ "Serial Port Association Entry",\r\n"ipmi.serial52.port_assoc_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial52_conn_name,\r\n{ "Connector Name",\r\n"ipmi.serial52_conn_name", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial53_port_assoc_sel,\r\n{ "Serial Port Association Entry",\r\n"ipmi.serial53.port_assoc_sel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_serial53_chan_name,\r\n{ "Channel Name",\r\n"ipmi.serial52_chan_name", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_01_chan,\r\n{ "Channel",\r\n"ipmi.tr01.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_01_param,\r\n{ "Parameter Selector",\r\n"ipmi.tr01.param", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_01_param_data,\r\n{ "Parameter data",\r\n"ipmi.tr01.param_data", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_02_getrev,\r\n{ "Get parameter revision only",\r\n"ipmi.tr02.getrev", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_trn_02_chan,\r\n{ "Channel",\r\n"ipmi.tr02.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_02_param,\r\n{ "Parameter selector",\r\n"ipmi.tr02.param", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_02_set,\r\n{ "Set selector",\r\n"ipmi.tr02.set", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_02_block,\r\n{ "Block selector",\r\n"ipmi.tr02.block", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_02_rev_present,\r\n{ "Present parameter revision",\r\n"ipmi.tr02.rev.present", FT_UINT8, BASE_DEC, NULL, 0xf0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_02_rev_compat,\r\n{ "Oldest forward-compatible",\r\n"ipmi.tr02.rev.compat", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_02_param_data,\r\n{ "Parameter data",\r\n"ipmi.tr02.param_data", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_03_chan,\r\n{ "Channel",\r\n"ipmi.tr03.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_03_arp_resp,\r\n{ "BMC-generated ARP responses",\r\n"ipmi.tr03.arp_resp", FT_BOOLEAN, 8, TFS(&tfs_03_suspend), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_03_gratuitous_arp,\r\n{ "Gratuitous ARPs",\r\n"ipmi.tr03.gratuitous_arp", FT_BOOLEAN, 8, TFS(&tfs_03_suspend), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_03_status_arp_resp,\r\n{ "ARP Response status",\r\n"ipmi.tr03.status_arp_resp", FT_BOOLEAN, 8, TFS(&tfs_03_arp_status), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_03_status_gratuitous_arp,\r\n{ "Gratuitous ARP status",\r\n"ipmi.tr03.status_gratuitous_arp", FT_BOOLEAN, 8, TFS(&tfs_03_arp_status), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_04_chan,\r\n{ "Channel",\r\n"ipmi.tr04.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_04_clear,\r\n{ "Statistics",\r\n"ipmi.tr04.clear", FT_BOOLEAN, 8, TFS(&tfs_04_clear), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_04_rx_ippkts,\r\n{ "Received IP Packets",\r\n"ipmi.tr04.rx_ippkts", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_04_rx_iphdr_err,\r\n{ "Received IP Header Errors",\r\n"ipmi.tr04.rx_iphdr_err", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_04_rx_ipaddr_err,\r\n{ "Received IP Address Errors",\r\n"ipmi.tr04.rx_ipaddr_err", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_04_rx_ippkts_frag,\r\n{ "Received Fragmented IP Packets",\r\n"ipmi.tr04.rx_ippkts_frag", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_04_tx_ippkts,\r\n{ "Transmitted IP Packets",\r\n"ipmi.tr04.tx_ippkts", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_04_rx_udppkts,\r\n{ "Received UDP Packets",\r\n"ipmi.tr04.rx_udppkts", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_04_rx_validrmcp,\r\n{ "Received Valid RMCP Packets",\r\n"ipmi.tr04.rx_validrmcp", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_04_rx_udpproxy,\r\n{ "Received UDP Proxy Packets",\r\n"ipmi.tr04.rx_udpproxy", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_04_dr_udpproxy,\r\n{ "Dropped UDP Proxy Packets",\r\n"ipmi.tr04.dr_udpproxy", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_10_chan,\r\n{ "Channel",\r\n"ipmi.tr10.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_10_param,\r\n{ "Parameter Selector",\r\n"ipmi.tr10.param", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_10_param_data,\r\n{ "Parameter data",\r\n"ipmi.tr10.param_data", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_11_getrev,\r\n{ "Get parameter revision only",\r\n"ipmi.tr11.getrev", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_trn_11_chan,\r\n{ "Channel",\r\n"ipmi.tr11.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_11_param,\r\n{ "Parameter selector",\r\n"ipmi.tr11.param", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_11_set,\r\n{ "Set selector",\r\n"ipmi.tr11.set", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_11_block,\r\n{ "Block selector",\r\n"ipmi.tr11.block", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_11_rev_present,\r\n{ "Present parameter revision",\r\n"ipmi.tr11.rev.present", FT_UINT8, BASE_DEC, NULL, 0xf0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_11_rev_compat,\r\n{ "Oldest forward-compatible",\r\n"ipmi.tr11.rev.compat", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_11_param_data,\r\n{ "Parameter data",\r\n"ipmi.tr11.param_data", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_12_chan,\r\n{ "Channel",\r\n"ipmi.tr12.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_12_mux_setting,\r\n{ "Mux Setting",\r\n"ipmi.tr12.mux_setting", FT_UINT8, BASE_HEX, VALS(vals_12_mux), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_12_sw_to_sys,\r\n{ "Requests to switch to system",\r\n"ipmi.tr12.sw_to_sys", FT_BOOLEAN, 8, TFS(&tfs_12_blocked), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_trn_12_sw_to_bmc,\r\n{ "Requests to switch to BMC",\r\n"ipmi.tr12.sw_to_bmc", FT_BOOLEAN, 8, TFS(&tfs_12_blocked), 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_trn_12_alert,\r\n{ "Alert in progress",\r\n"ipmi.tr12.alert", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_trn_12_msg,\r\n{ "IPMI/OEM messaging active",\r\n"ipmi.tr12.msg", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_trn_12_req,\r\n{ "Request",\r\n"ipmi.tr12.req", FT_BOOLEAN, 8, TFS(&tfs_12_req), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_12_mux_state,\r\n{ "Mux set to",\r\n"ipmi.tr12.mux_state", FT_BOOLEAN, 8, TFS(&tfs_12_mux_state), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_13_chan,\r\n{ "Channel",\r\n"ipmi.tr13.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_13_code1,\r\n{ "Last code",\r\n"ipmi.tr13.code1", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_13_code2,\r\n{ "2nd code",\r\n"ipmi.tr13.code2", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_13_code3,\r\n{ "3rd code",\r\n"ipmi.tr13.code3", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_13_code4,\r\n{ "4th code",\r\n"ipmi.tr13.code4", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_13_code5,\r\n{ "5th code",\r\n"ipmi.tr13.code5", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_14_chan,\r\n{ "Channel",\r\n"ipmi.tr14.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_14_block,\r\n{ "Block number",\r\n"ipmi.tr14.block", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_14_data,\r\n{ "Block data",\r\n"ipmi.tr14.data", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_15_chan,\r\n{ "Channel",\r\n"ipmi.tr15.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_15_block,\r\n{ "Block number",\r\n"ipmi.tr15.block", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_15_data,\r\n{ "Block data",\r\n"ipmi.tr15.data", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_16_chan,\r\n{ "Channel",\r\n"ipmi.tr16.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_16_src_port,\r\n{ "Source Port",\r\n"ipmi.tr16.src_port", FT_UINT16, BASE_CUSTOM, CF_FUNC(ipmi_fmt_udpport), 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_16_dst_port,\r\n{ "Destination Port",\r\n"ipmi.tr16.dst_port", FT_UINT16, BASE_CUSTOM, CF_FUNC(ipmi_fmt_udpport), 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_16_src_addr,\r\n{ "Source IP Address",\r\n"ipmi.tr16.src_addr", FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_16_dst_addr,\r\n{ "Destination IP Address",\r\n"ipmi.tr16.dst_addr", FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_16_bytes,\r\n{ "Bytes to send",\r\n"ipmi.tr16.bytes", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_17_chan,\r\n{ "Channel",\r\n"ipmi.tr17.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_17_clear,\r\n{ "Clear buffer",\r\n"ipmi.tr17.clear", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_trn_17_block_num,\r\n{ "Block number",\r\n"ipmi.tr17.block_num", FT_UINT8, BASE_CUSTOM, CF_FUNC(tr17_fmt_blockno), 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_17_size,\r\n{ "Number of received bytes",\r\n"ipmi.tr17.size", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_17_data,\r\n{ "Block Data",\r\n"ipmi.tr17.data", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_18_state,\r\n{ "Session state",\r\n"ipmi.tr18.state", FT_UINT8, BASE_HEX, VALS(vals_18_state), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_18_ipmi_ver,\r\n{ "IPMI Version",\r\n"ipmi.tr18.ipmi_ver", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_version), 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_19_chan,\r\n{ "Channel",\r\n"ipmi.tr19.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_19_dest_sel,\r\n{ "Destination selector",\r\n"ipmi.tr19.dest_sel", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_XX_cap_cbcp,\r\n{ "CBCP callback",\r\n"ipmi.trXX.cap_cbcp", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_XX_cap_ipmi,\r\n{ "IPMI callback",\r\n"ipmi.trXX.cap_ipmi", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_XX_cbcp_from_list,\r\n{ "Callback to one from list of numbers",\r\n"ipmi.trXX.cbcp_from_list", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_trn_XX_cbcp_user,\r\n{ "Callback to user-specified number",\r\n"ipmi.trXX.cbcp_user", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_trn_XX_cbcp_prespec,\r\n{ "Callback to pre-specified number",\r\n"ipmi.trXX.cbcp_prespec", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_trn_XX_cbcp_nocb,\r\n{ "No callback",\r\n"ipmi.trXX.cbcp_nocb", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_trn_XX_dst1,\r\n{ "Callback destination 1",\r\n"ipmi.trXX.dst1", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_XX_dst2,\r\n{ "Callback destination 2",\r\n"ipmi.trXX.dst2", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_XX_dst3,\r\n{ "Callback destination 3",\r\n"ipmi.trXX.dst3", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_trn_1a_user,\r\n{ "User ID",\r\n"ipmi.tr1a.user", FT_UINT8, BASE_DEC, NULL, 0x3f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_1a_chan,\r\n{ "Channel",\r\n"ipmi.tr1a.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_1b_user,\r\n{ "User ID",\r\n"ipmi.tr1b.user", FT_UINT8, BASE_DEC, NULL, 0x3f, NULL, HFILL }},\r\n{ &hf_ipmi_trn_1b_chan,\r\n{ "Channel",\r\n"ipmi.tr1b.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ipmi_trn_lan00_byte1,\r\n&ett_ipmi_trn_lan01_byte1,\r\n&ett_ipmi_trn_lan02_byte1,\r\n&ett_ipmi_trn_lan02_byte2,\r\n&ett_ipmi_trn_lan02_byte3,\r\n&ett_ipmi_trn_lan02_byte4,\r\n&ett_ipmi_trn_lan02_byte5,\r\n&ett_ipmi_trn_lan04_byte1,\r\n&ett_ipmi_trn_lan07_byte2,\r\n&ett_ipmi_trn_lan07_byte3,\r\n&ett_ipmi_trn_lan10_byte1,\r\n&ett_ipmi_trn_lan17_byte1,\r\n&ett_ipmi_trn_lan18_byte1,\r\n&ett_ipmi_trn_lan18_byte2,\r\n&ett_ipmi_trn_lan18_byte4,\r\n&ett_ipmi_trn_lan19_byte1,\r\n&ett_ipmi_trn_lan19_byte2,\r\n&ett_ipmi_trn_lan19_byte3,\r\n&ett_ipmi_trn_lan20_byte12,\r\n&ett_ipmi_trn_lan21_byte1,\r\n&ett_ipmi_trn_lan22_byte1,\r\n&ett_ipmi_trn_lan24_byte1,\r\n&ett_ipmi_trn_lan24_byte2,\r\n&ett_ipmi_trn_lan24_byte3,\r\n&ett_ipmi_trn_lan24_byte4,\r\n&ett_ipmi_trn_lan24_byte5,\r\n&ett_ipmi_trn_lan24_byte6,\r\n&ett_ipmi_trn_lan24_byte7,\r\n&ett_ipmi_trn_lan24_byte8,\r\n&ett_ipmi_trn_lan25_byte1,\r\n&ett_ipmi_trn_lan25_byte2,\r\n&ett_ipmi_trn_lan25_byte34,\r\n&ett_ipmi_trn_lan50_byte1,\r\n&ett_ipmi_trn_lan55_byte3,\r\n&ett_ipmi_trn_lan56_byte2,\r\n&ett_ipmi_trn_lan64_byte1,\r\n&ett_ipmi_trn_serial03_byte1,\r\n&ett_ipmi_trn_serial04_byte1,\r\n&ett_ipmi_trn_serial05_byte1,\r\n&ett_ipmi_trn_serial05_byte2,\r\n&ett_ipmi_trn_serial06_byte1,\r\n&ett_ipmi_trn_serial07_byte1,\r\n&ett_ipmi_trn_serial07_byte2,\r\n&ett_ipmi_trn_serial08_byte1,\r\n&ett_ipmi_trn_serial08_byte2,\r\n&ett_ipmi_trn_serial09_byte1,\r\n&ett_ipmi_trn_serial09_byte2,\r\n&ett_ipmi_trn_serial16_byte1,\r\n&ett_ipmi_trn_serial17_byte1,\r\n&ett_ipmi_trn_serial17_byte2,\r\n&ett_ipmi_trn_serial17_byte4,\r\n&ett_ipmi_trn_serial17_byte5,\r\n&ett_ipmi_trn_serial19_byte1,\r\n&ett_ipmi_trn_serial19_byte2,\r\n&ett_ipmi_trn_serial19_byte3,\r\n&ett_ipmi_trn_serial20_byte1,\r\n&ett_ipmi_trn_serial21_byte1,\r\n&ett_ipmi_trn_serial22_byte1,\r\n&ett_ipmi_trn_serial23_byte1,\r\n&ett_ipmi_trn_serial24_byte1,\r\n&ett_ipmi_trn_serial25_byte2,\r\n&ett_ipmi_trn_serial28_byte1,\r\n&ett_ipmi_trn_serial28_byte2,\r\n&ett_ipmi_trn_serial28_byte10,\r\n&ett_ipmi_trn_serial28_byte11,\r\n&ett_ipmi_trn_serial28_byte12,\r\n&ett_ipmi_trn_serial28_byte13,\r\n&ett_ipmi_trn_serial28_byte14,\r\n&ett_ipmi_trn_serial29_byte1,\r\n&ett_ipmi_trn_serial29_byte2,\r\n&ett_ipmi_trn_serial30_byte1,\r\n&ett_ipmi_trn_serial30_byte2,\r\n&ett_ipmi_trn_serial30_byte3,\r\n&ett_ipmi_trn_serial33_byte1,\r\n&ett_ipmi_trn_serial37_byte1,\r\n&ett_ipmi_trn_serial43_byte1,\r\n&ett_ipmi_trn_serial50_byte1,\r\n&ett_ipmi_trn_serial51_byte2,\r\n&ett_ipmi_trn_serial51_byte3,\r\n&ett_ipmi_trn_01_byte1,\r\n&ett_ipmi_trn_02_byte1,\r\n&ett_ipmi_trn_02_rev,\r\n&ett_ipmi_trn_03_rq_byte1,\r\n&ett_ipmi_trn_03_rq_byte2,\r\n&ett_ipmi_trn_03_rs_byte1,\r\n&ett_ipmi_trn_04_byte1,\r\n&ett_ipmi_trn_04_byte2,\r\n&ett_ipmi_trn_10_byte1,\r\n&ett_ipmi_trn_11_byte1,\r\n&ett_ipmi_trn_11_rev,\r\n&ett_ipmi_trn_12_rq_byte1,\r\n&ett_ipmi_trn_12_rq_byte2,\r\n&ett_ipmi_trn_12_rs_byte1,\r\n&ett_ipmi_trn_13_byte1,\r\n&ett_ipmi_trn_14_byte1,\r\n&ett_ipmi_trn_15_byte1,\r\n&ett_ipmi_trn_16_byte1,\r\n&ett_ipmi_trn_17_byte1,\r\n&ett_ipmi_trn_17_byte2,\r\n&ett_ipmi_trn_18_byte1,\r\n&ett_ipmi_trn_19_byte1,\r\n&ett_ipmi_trn_19_byte2,\r\n&ett_ipmi_trn_XX_usercap,\r\n&ett_ipmi_trn_XX_cbcp,\r\n&ett_ipmi_trn_1a_byte1,\r\n&ett_ipmi_trn_1a_byte2,\r\n&ett_ipmi_trn_1b_byte1,\r\n&ett_ipmi_trn_1b_byte2,\r\n&ett_ipmi_trn_parameter\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_ipmi_trn_02_request_param_rev, { "ipmi.tr02.request_param_rev", PI_PROTOCOL, PI_NOTE, "Requested parameter revision; parameter data returned", EXPFILL }},\r\n{ &ei_ipmi_trn_02_request_param_data, { "ipmi.tr02.mrequest_param_data", PI_PROTOCOL, PI_NOTE, "Requested parameter data; only parameter version returned", EXPFILL }},\r\n{ &ei_ipmi_trn_11_request_param_rev, { "ipmi.tr11.request_param_rev", PI_PROTOCOL, PI_NOTE, "Requested parameter revision; parameter data returned", EXPFILL }},\r\n{ &ei_ipmi_trn_11_request_param_data, { "ipmi.tr11.mrequest_param_data", PI_PROTOCOL, PI_NOTE, "Requested parameter data; only parameter version returned", EXPFILL }},\r\n};\r\nexpert_module_t* expert_ipmi_trn;\r\nproto_register_field_array(proto_ipmi, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_ipmi_trn = expert_register_protocol(proto_ipmi);\r\nexpert_register_field_array(expert_ipmi_trn, ei, array_length(ei));\r\nipmi_register_netfn_cmdtab(IPMI_TRANSPORT_REQ, IPMI_OEM_NONE, NULL, 0, NULL,\r\ncmd_transport, array_length(cmd_transport));\r\n}
