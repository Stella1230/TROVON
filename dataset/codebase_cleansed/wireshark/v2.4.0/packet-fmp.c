static int\r\ndissect_fmp_genString(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_fmp_encoding_mode, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nif (try_val_to_str(tvb_get_ntohl(tvb, offset), fmp_encoding_mode_vals) == NULL)\r\nreturn offset;\r\noffset = dissect_rpc_string(tvb, tree, hf_fmp_path,\r\noffset, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\nget_fileHandleSrc_size(tvbuff_t *tvb, int offset)\r\n{\r\nint length;\r\nnativeProtocol np;\r\nnp = (nativeProtocol)tvb_get_ntohl(tvb, offset);\r\nswitch (np) {\r\ncase FMP_PATH:\r\nlength = 4 + FMP_MAX_PATH_LEN;\r\nbreak;\r\ncase FMP_NFS:\r\nlength = 8 + tvb_get_ntohl(tvb, offset + 4);\r\nbreak;\r\ncase FMP_CIFS:\r\nlength = 10;\r\nbreak;\r\ncase FMP_FMP:\r\nlength = 8 + tvb_get_ntohl(tvb, offset + 4);\r\nbreak;\r\ncase FMP_FS_ONLY:\r\nlength = 8;\r\nbreak;\r\ncase FMP_SHARE:\r\ncase FMP_MOUNT:\r\nlength = 8 + FMP_MAX_PATH_LEN;\r\nbreak;\r\ndefault:\r\nlength = 4;\r\nbreak;\r\n}\r\nreturn length;\r\n}\r\nstatic int\r\ndissect_fmp_fileHandleSrc(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\r\nproto_tree *tree)\r\n{\r\nnativeProtocol np;\r\nproto_tree *fileHandleTree;\r\nint length;\r\nlength = get_fileHandleSrc_size(tvb, offset);\r\nfileHandleTree = proto_tree_add_subtree(tree, tvb, offset, length,\r\nett_fmp_fileHandle, NULL, "Source File Handle");\r\nnp = (nativeProtocol)tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(fileHandleTree, hf_fmp_native_protocol, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nswitch (np) {\r\ncase FMP_PATH:\r\noffset = dissect_rpc_string(tvb, fileHandleTree,\r\nhf_fmp_mount_path, offset, NULL);\r\nbreak;\r\ncase FMP_NFS:\r\noffset = dissect_rpc_data(tvb, fileHandleTree,\r\nhf_fmp_nfsFHandle, offset);\r\nbreak;\r\ncase FMP_CIFS:\r\nproto_tree_add_item(fileHandleTree, hf_fmp_fid, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(fileHandleTree, hf_fmp_tid, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(fileHandleTree, hf_fmp_uid, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nbreak;\r\ncase FMP_FMP:\r\noffset = dissect_rpc_string(tvb, fileHandleTree,\r\nhf_fmp_fmpFHandle, offset, NULL);\r\nbreak;\r\ncase FMP_FS_ONLY:\r\nproto_tree_add_item(fileHandleTree, hf_fmp_fsid, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase FMP_SHARE:\r\noffset = dissect_fmp_genString(tvb, offset, fileHandleTree);\r\nbreak;\r\ncase FMP_MOUNT:\r\noffset = dissect_fmp_genString(tvb, offset, fileHandleTree);\r\nbreak;\r\ncase FMP_CIFSV2:\r\nproto_tree_add_item(fileHandleTree, hf_fmp_fid, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(fileHandleTree, hf_fmp_tid, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(fileHandleTree, hf_fmp_uid, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(fileHandleTree, hf_fmp_cifsport, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nbreak;\r\ncase FMP_UNC:\r\noffset = dissect_fmp_genString(tvb, offset, fileHandleTree);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_fmp_extentState(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_extent_state,\r\noffset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_fmp_extent(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree, guint32 ext_num)\r\n{\r\nproto_tree *extTree;\r\nextTree = proto_tree_add_subtree_format(tree, tvb, offset, 20 ,\r\nett_fmp_ext, NULL, "Extent (%u)", (guint32) ext_num);\r\noffset = dissect_rpc_uint32(tvb, extTree, hf_fmp_firstLogBlk,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, extTree, hf_fmp_numBlks,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, extTree, hf_fmp_volID, offset);\r\noffset = dissect_rpc_uint32(tvb, extTree, hf_fmp_startOffset,\r\noffset);\r\noffset = dissect_fmp_extentState(tvb, offset, extTree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_fmp_extentList(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\nproto_tree *tree)\r\n{\r\nguint32 numExtents;\r\nguint32 totalLength;\r\nproto_tree *extListTree;\r\nguint32 i;\r\nnumExtents = tvb_get_ntohl(tvb, offset);\r\ntotalLength = 4 + (20 * numExtents);\r\nextListTree = proto_tree_add_subtree(tree, tvb, offset, totalLength,\r\nett_fmp_extList, NULL, "Extent List");\r\noffset = dissect_rpc_uint32(tvb, extListTree,\r\nhf_fmp_extentList_len, offset);\r\nfor (i = 0; i < numExtents; i++) {\r\noffset = dissect_fmp_extent(tvb, offset, pinfo, extListTree, i+1);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_fmp_extentListEx(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\r\nproto_tree *tree)\r\n{\r\nguint32 numExtents;\r\nproto_tree *extListTree;\r\nguint32 i;\r\nnumExtents = tvb_get_ntohl(tvb, offset);\r\noffset += 4;\r\nfor (i = 0; i < numExtents; i++) {\r\nextListTree = proto_tree_add_subtree(tree, tvb, offset, 28,\r\nett_fmp_extList, NULL, "Extent List");\r\noffset = dissect_rpc_uint64(tvb,extListTree , hf_fmp_firstLogBlk64, offset);\r\noffset = dissect_rpc_uint32(tvb,extListTree , hf_fmp_numBlksReq,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb,extListTree , hf_fmp_volID, offset);\r\noffset = dissect_rpc_uint64(tvb,extListTree , hf_fmp_start_offset64, offset);\r\noffset = dissect_fmp_extentState(tvb, offset, extListTree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_plugInID(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nif (!tree) {\r\nreturn offset;\r\n}\r\nproto_tree_add_item(tree, hf_fmp_plugInID, tvb, offset, FMP_PLUG_IN_ID_SZ,\r\nENC_NA);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_fmp_flushCmd(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nguint32 cmd;\r\nchar msg[MAX_MSG_SIZE];\r\nguint32 bitValue;\r\nint i;\r\nif (tree) {\r\ncmd = tvb_get_ntohl(tvb, offset);\r\nmsg[0] = '\0';\r\nfor (i = 0; cmd != 0 && i < 32; i++) {\r\nbitValue = 1 << i;\r\nif (cmd & bitValue) {\r\nswitch (bitValue) {\r\ncase FMP_COMMIT_SPECIFIED:\r\ng_strlcat(msg, "COMMIT_SPECIFIED", MAX_MSG_SIZE);\r\nbreak;\r\ncase FMP_RELEASE_SPECIFIED:\r\ng_strlcat(msg, "RELEASE_SPECIFIED", MAX_MSG_SIZE);\r\nbreak;\r\ncase FMP_RELEASE_ALL:\r\ng_strlcat(msg, "RELEASE_ALL", MAX_MSG_SIZE);\r\nbreak;\r\ncase FMP_CLOSE_FILE:\r\ng_strlcat(msg, "CLOSE_FILE", MAX_MSG_SIZE);\r\nbreak;\r\ncase FMP_UPDATE_TIME:\r\ng_strlcat(msg, "UPDATE_TIME", MAX_MSG_SIZE);\r\nbreak;\r\ncase FMP_ACCESS_TIME:\r\ng_strlcat(msg, "ACCESS_TIME", MAX_MSG_SIZE);\r\nbreak;\r\ndefault:\r\ng_strlcat(msg, "UNKNOWN", MAX_MSG_SIZE);\r\nbreak;\r\n}\r\ncmd &= ~bitValue;\r\nif (cmd) {\r\ng_strlcat(msg, " | ", MAX_MSG_SIZE);\r\n}\r\n}\r\n}\r\nif (strlen(msg) == 0) {\r\ng_strlcpy(msg, "No command specified", MAX_MSG_SIZE);\r\n}\r\nproto_tree_add_uint_format_value(tree, hf_fmp_cmd, tvb, offset, 4, cmd, "%s", msg);\r\n}\r\noffset += 4;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_InterpretVolMgtStuff(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nint length, numdisks, i, j;\r\nnumdisks = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_fmp_number_of_disk, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nfor (i=0; i<numdisks; i++) {\r\noffset = dissect_rpc_uint64(tvb, tree, hf_fmp_sig_offset, offset);\r\nlength = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_fmp_length_of_list, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nfor (j=0; j<length; j++) {\r\nproto_tree_add_item(tree, hf_fmp_sigoffset, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\noffset = dissect_rpc_string(tvb, tree, hf_fmp_dskSigEnt_val,\r\noffset, NULL);\r\n}\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_volID, offset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_fmp_capability(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_fmp_capability, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nreturn offset+4;\r\n}\r\nstatic int\r\ndissect_fmp_timeval(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\r\nproto_tree *tree, int hf_time, int hf_time_sec,\r\nint hf_time_nsec)\r\n{\r\nif (tree) {\r\nnstime_t ts;\r\nproto_item* time_item;\r\nproto_tree* time_tree;\r\nts.secs = tvb_get_ntohl(tvb, offset+0);\r\nts.nsecs = tvb_get_ntohl(tvb, offset+4);\r\ntime_item = proto_tree_add_time(tree, hf_time, tvb, offset, 8, &ts);\r\ntime_tree = proto_item_add_subtree(time_item, ett_fmp_timeval);\r\nproto_tree_add_uint(time_tree, hf_time_sec, tvb, offset, 4,\r\n(guint32) ts.secs);\r\nproto_tree_add_uint(time_tree, hf_time_nsec, tvb, offset+4, 4,\r\nts.nsecs);\r\n}\r\noffset += 8;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_fmp_heartBeatIntv(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\r\nproto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_fmp_heartbeat_interval, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_fmp_status(tvbuff_t *tvb, int offset, proto_tree *tree, int *rval)\r\n{\r\nfmpStat status;\r\nstatus = (fmpStat)tvb_get_ntohl(tvb, offset);\r\nswitch (status) {\r\ncase FMP_OK:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_IOERROR:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_NOMEM:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_NOACCESS:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_INVALIDARG:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_FSFULL:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_QUEUE_FULL:\r\ncase FMP_NOTIFY_ERROR:\r\ncase FMP_WRITER_LOST_BLK:\r\ncase FMP_WRONG_MSG_NUM:\r\ncase FMP_SESSION_LOST:\r\ncase FMP_REQUEST_CANCELLED:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_HOT_SESSION:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_COLD_SESSION:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_CLIENT_TERMINATED:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_REQUEST_QUEUED:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_FALL_BACK:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_WRITER_ZEROED_BLK:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_WRONG_HANDLE:\r\n*rval = 0;\r\nbreak;\r\ncase FMP_DUPLICATE_OPEN:\r\n*rval = 1;\r\nbreak;\r\ncase FMP_PLUGIN_NOFUNC:\r\n*rval = 1;\r\nbreak;\r\ndefault:\r\n*rval = 1;\r\nbreak;\r\n}\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_status , offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_fmp_devSerial(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\r\nproto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_fmp_devSerial_query_cmd, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_fmp_sigoffset, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\noffset = dissect_rpc_string(tvb, tree, hf_fmp_devSignature,\r\noffset, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_fmp_VolumeDescription(tvbuff_t *tvb, int offset, proto_tree * tree)\r\n{\r\nint i,length;\r\nproto_tree *Hietree;\r\nproto_item *ti;\r\nfmpVolumeType volumeType;\r\nfmpDiskIdentifierType diskIdentifierType;\r\nvolumeType = (fmpVolumeType)tvb_get_ntohl(tvb, offset);\r\nti = proto_tree_add_item(tree, hf_fmp_volume_desc, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nHietree = proto_item_add_subtree(ti, ett_HierVolumeDescription);\r\noffset += 4;\r\nswitch (volumeType) {\r\ncase FMP_VOLUME_DISK:\r\noffset = dissect_rpc_uint32(tvb, Hietree, hf_fmp_volID, offset);\r\noffset += 8;\r\ndiskIdentifierType = (fmpDiskIdentifierType)tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(Hietree, hf_fmp_disk_identifier, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nswitch (diskIdentifierType) {\r\ncase FMP_DISK_IDENTIFIER_SIGNATURE:\r\noffset = dissect_rpc_uint64(tvb, Hietree, hf_fmp_sig_offset, offset);\r\nlength = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(Hietree, hf_fmp_length_of_list, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nfor (i=0; i<length; i++) {\r\nproto_tree_add_item(Hietree, hf_fmp_sigoffset, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\noffset = dissect_rpc_string(tvb, Hietree, hf_fmp_dskSigEnt_val, offset, NULL);\r\n}\r\nbreak;\r\ncase FMP_DISK_IDENTIFIER_SERIAL:\r\ndissect_fmp_devSerial(tvb, offset, NULL, Hietree);\r\nbreak;\r\n}\r\nbreak;\r\ncase FMP_VOLUME_SLICE:\r\noffset = dissect_rpc_uint32(tvb, Hietree, hf_fmp_volID, offset);\r\noffset = dissect_rpc_uint64(tvb, Hietree, hf_fmp_offset64, offset);\r\noffset = dissect_rpc_uint64(tvb, Hietree, hf_fmp_slice_size, offset);\r\noffset = dissect_rpc_uint32(tvb, Hietree, hf_fmp_volume, offset);\r\nbreak;\r\ncase FMP_VOLUME_STRIPE:\r\noffset = dissect_rpc_uint32(tvb, Hietree, hf_fmp_volID, offset);\r\noffset = dissect_rpc_uint64(tvb, Hietree, hf_fmp_stripeSize, offset);\r\nlength = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(Hietree, hf_fmp_length_of_list, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nfor (i=0; i<length; i++) {\r\noffset = dissect_rpc_uint32(tvb, Hietree, hf_fmp_volume, offset);\r\n}\r\nbreak;\r\ncase FMP_VOLUME_META:\r\noffset = dissect_rpc_uint32(tvb, Hietree, hf_fmp_volID, offset);\r\nlength = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(Hietree, hf_fmp_length_of_list, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nfor (i=0; i<length; i++) {\r\noffset = dissect_rpc_uint32(tvb, Hietree, hf_fmp_volume, offset);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_fmp_Hiervolume(tvbuff_t *tvb, int offset, proto_tree * tree)\r\n{\r\nint vollength;\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_topVolumeId, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_cursor, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_cookie, offset);\r\nvollength = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_fmp_length_of_volume_list, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nwhile (vollength) {\r\noffset = dissect_fmp_VolumeDescription(tvb, offset, tree);\r\nvollength--;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_fmp_vmInfo(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\nproto_tree *tree)\r\n{\r\nint vmType;\r\nguint32 phyVolList_len;\r\nvmType = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_fmp_volume_mgmt_type, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nswitch (vmType) {\r\ncase FMP_SERVER_BASED:\r\nphyVolList_len = tvb_get_ntohl(tvb, offset);\r\noffset += 4;\r\nwhile (phyVolList_len) {\r\noffset = dissect_fmp_devSerial(tvb, offset, pinfo, tree);\r\nproto_tree_add_item(tree, hf_fmp_volindex, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nphyVolList_len--;\r\n}\r\nbreak;\r\ncase FMP_THIRD_PARTY:\r\noffset = dissect_rpc_string(tvb, tree, hf_fmp_volHandle,\r\noffset, NULL);\r\nbreak;\r\ncase FMP_CLIENT_BASED_DART:\r\noffset = dissect_rpc_string(tvb, tree, hf_fmp_volHandle,\r\noffset, NULL);\r\nbreak;\r\ncase FMP_CLIENT_BASED_SIMPLE:\r\noffset = dissect_fmp_devSerial(tvb, offset, pinfo, tree);\r\nproto_tree_add_item(tree, hf_fmp_blockindex, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase FMP_DISK_SIGNATURE:\r\noffset = dissect_InterpretVolMgtStuff(tvb, offset, tree);\r\nbreak;\r\ncase FMP_HIERARCHICAL_VOLUME:\r\ndissect_fmp_Hiervolume(tvb, offset, tree);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_fmp_notifyProtocol(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_fmp_notify_protocol, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nreturn (offset+4);\r\n}\r\nstatic int\r\ndissect_fmp_capabilities(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nstatic const int *capabilities[] = {\r\n&hf_fmp_cap_revoke_handle_list,\r\n&hf_fmp_cap_unc_names,\r\n&hf_fmp_cap_cifsv2,\r\nNULL\r\n};\r\nproto_tree_add_bitmask_with_flags(tree, tvb, offset, hf_fmp_cap, ett_capabilities,\r\ncapabilities, ENC_BIG_ENDIAN, BMT_NO_APPEND);\r\nreturn (offset+4);\r\n}\r\nstatic int\r\ndissect_fmp_cerrInfo(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nint rval;\r\nproto_tree_add_item(tree, hf_fmp_client_error_number, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_fmp_attrs(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nproto_tree *attrsTree;\r\nattrsTree = proto_tree_add_subtree(tree, tvb, offset, 84,\r\nett_attrs, NULL, "Attribute: ");\r\noffset = dissect_rpc_uint32(tvb, attrsTree, hf_fmp_nfsv3Attr_type, offset);\r\noffset = dissect_rpc_uint32(tvb, attrsTree, hf_fmp_nfsv3Attr_mode, offset);\r\noffset = dissect_rpc_uint32(tvb, attrsTree, hf_fmp_nfsv3Attr_nlink, offset);\r\noffset = dissect_rpc_uint32(tvb, attrsTree, hf_fmp_nfsv3Attr_uid, offset);\r\noffset = dissect_rpc_uint32(tvb, attrsTree, hf_fmp_nfsv3Attr_gid, offset);\r\noffset = dissect_rpc_uint64(tvb, attrsTree, hf_fmp_fileSize, offset);\r\noffset = dissect_rpc_uint64(tvb, attrsTree, hf_fmp_nfsv3Attr_used, offset);\r\noffset = dissect_rpc_uint64(tvb, attrsTree, hf_fmp_nfsv3Attr_rdev, offset);\r\noffset = dissect_rpc_uint64(tvb, attrsTree, hf_fmp_nfsv3Attr_fsid, offset);\r\noffset = dissect_rpc_uint64(tvb, attrsTree, hf_fmp_nfsv3Attr_fileid, offset);\r\nproto_tree_add_item(tree, hf_fmp_atime, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset +=8;\r\nproto_tree_add_item(tree, hf_fmp_mtime, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset +=8;\r\nproto_tree_add_item(tree, hf_fmp_ctime, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset +=8;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_SessionCreate_request(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_string(tvb, tree, hf_fmp_hostID,\r\noffset, NULL);\r\noffset = dissect_fmp_timeval(tvb, offset, pinfo, tree, hf_fmp_btime,\r\nhf_fmp_time_sec, hf_fmp_time_nsec);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_notifyPort,\r\noffset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_SessionCreate_reply(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_data(tvb, tree,\r\nhf_fmp_sessionHandle, offset);\r\noffset = dissect_rpc_string(tvb, tree, hf_fmp_hostID,\r\noffset, NULL);\r\noffset = dissect_fmp_timeval(tvb, offset, pinfo, tree,\r\nhf_fmp_btime, hf_fmp_time_sec,\r\nhf_fmp_time_nsec);\r\noffset = dissect_fmp_heartBeatIntv(tvb, offset, pinfo, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_HeartBeat_request(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nreturn dissect_rpc_data(tvb, tree, hf_fmp_sessionHandle, 0);\r\n}\r\nstatic int\r\ndissect_FMP_HeartBeat_reply(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nreturn dissect_fmp_status(tvb, 0, tree, &rval);\r\n}\r\nstatic int\r\ndissect_FMP_Mount_request(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_sessionHandle,\r\noffset);\r\noffset = dissect_fmp_capability(tvb, offset, tree);\r\noffset = dissect_fmp_fileHandleSrc(tvb, offset, pinfo, tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_Mount_reply(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_fsID,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_fsBlkSz,\r\noffset);\r\noffset = dissect_fmp_vmInfo(tvb, offset, pinfo, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_Open_request(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_sessionHandle,\r\noffset);\r\noffset = dissect_fmp_fileHandleSrc(tvb, offset, pinfo, tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_Open_reply(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum,\r\noffset);\r\noffset = dissect_rpc_uint64(tvb, tree, hf_fmp_fileSize,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_fsID,\r\noffset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_Close_request(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_Close_reply(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum,\r\noffset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_OpenGetMap_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_sessionHandle,\r\noffset);\r\noffset = dissect_fmp_fileHandleSrc(tvb, offset, pinfo, tree);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_firstLogBlk,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_numBlksReq,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_minBlks, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_OpenGetMap_reply(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_cookie,\r\noffset);\r\noffset = dissect_rpc_uint64(tvb, tree, hf_fmp_fileSize,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_fsID,\r\noffset);\r\noffset = dissect_fmp_extentList(tvb, offset, pinfo, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_OpenAllocSpace_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_sessionHandle, offset);\r\noffset = dissect_fmp_fileHandleSrc(tvb, offset, pinfo, tree);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_firstLogBlk, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_numBlksReq, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_minBlks, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_OpenAllocSpace_reply(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_cookie,\r\noffset);\r\noffset = dissect_rpc_uint64(tvb, tree, hf_fmp_fileSize,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_fsID,\r\noffset);\r\noffset = dissect_fmp_extentList(tvb, offset, pinfo, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_GetMap_request(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_firstLogBlk,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_numBlksReq,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_minBlks, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_GetMap_reply(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_cookie,\r\noffset);\r\noffset = dissect_rpc_uint64(tvb, tree, hf_fmp_fileSize,\r\noffset);\r\noffset = dissect_fmp_extentList(tvb, offset, pinfo, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_AllocSpace_request(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_firstLogBlk,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_numBlksReq,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_minBlks, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_AllocSpace_reply(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_cookie,\r\noffset);\r\noffset = dissect_rpc_uint64(tvb, tree, hf_fmp_fileSize,\r\noffset);\r\noffset = dissect_fmp_extentList(tvb, offset, pinfo, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_Flush_request(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\noffset = dissect_fmp_flushCmd(tvb, offset, tree);\r\noffset = dissect_rpc_uint64(tvb,tree, hf_fmp_eof, offset);\r\noffset = dissect_fmp_extentList(tvb, offset, pinfo, tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_Flush_reply(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum,\r\noffset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_CancelReq_request(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_cookie, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_CancelReq_reply(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum,\r\noffset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_PlugIn_request(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_plugInID(tvb, offset, tree);\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_plugInBuf, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_PlugIn_reply(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_plugInBuf,\r\noffset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_SessionTerminate_request(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nreturn dissect_rpc_data(tvb, tree, hf_fmp_sessionHandle, 0);\r\n}\r\nstatic int\r\ndissect_FMP_SessionTerminate_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nreturn dissect_fmp_status(tvb, 0,tree, &rval);\r\n}\r\nstatic int\r\ndissect_FMP_SessionCreateEx_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_string(tvb, tree, hf_fmp_hostID,\r\noffset, NULL);\r\noffset = dissect_fmp_timeval(tvb, offset, pinfo ,tree, hf_fmp_btime,\r\nhf_fmp_time_sec, hf_fmp_time_nsec);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_notifyPort,\r\noffset);\r\noffset = dissect_fmp_notifyProtocol(tvb, offset, tree);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_os_major,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_os_minor,\r\noffset);\r\noffset = dissect_rpc_string(tvb, tree, hf_fmp_os_name,\r\noffset, NULL);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_os_patch,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_os_build,\r\noffset);\r\noffset = dissect_fmp_capabilities(tvb, offset, tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_SessionCreateEx_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset, tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_data(tvb, tree,\r\nhf_fmp_sessionHandle, offset);\r\noffset = dissect_rpc_string(tvb, tree, hf_fmp_hostID,\r\noffset, NULL);\r\noffset = dissect_fmp_timeval(tvb, offset, pinfo ,tree,\r\nhf_fmp_btime, hf_fmp_time_sec,\r\nhf_fmp_time_nsec);\r\noffset = dissect_fmp_heartBeatIntv(tvb, offset, pinfo , tree);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_os_major,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_os_minor,\r\noffset);\r\noffset = dissect_rpc_string(tvb, tree, hf_fmp_server_version_string,\r\noffset, NULL);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_os_patch,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_os_build,\r\noffset);\r\noffset = dissect_fmp_capabilities(tvb, offset, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_ReportClientError_request(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_string(tvb, tree, hf_fmp_description,\r\noffset, NULL);\r\noffset = dissect_fmp_cerrInfo(tvb, offset, tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_ReportClientError_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_GetAttr_request(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_GetAttr_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\noffset = dissect_fmp_attrs(tvb, offset, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_OpenGetAttr_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_sessionHandle,\r\noffset);\r\noffset = dissect_fmp_fileHandleSrc(tvb, offset, pinfo, tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_OpenGetAttr_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset, tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\noffset = dissect_rpc_uint64(tvb, tree, hf_fmp_fileSize, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_fsID, offset);\r\noffset = dissect_fmp_attrs(tvb, offset, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_FlushGetAttr_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_fmp_fileHandleSrc(tvb, offset, pinfo, tree);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_cmd, offset);\r\noffset = dissect_rpc_uint64(tvb,tree, hf_fmp_eof, offset);\r\nproto_tree_add_item(tree, hf_fmp_mtime, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\noffset = dissect_fmp_extentList(tvb, offset, pinfo, tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_FlushGetAttr_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\noffset = dissect_fmp_attrs(tvb, offset, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_GetVolumeInfo_request(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_topVolumeId, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_cursor, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_cookie, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_GetVolumeInfo_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_fmp_Hiervolume(tvb,offset, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_OpenGetMapEx_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_sessionHandle,\r\noffset);\r\noffset = dissect_fmp_fileHandleSrc(tvb, offset, pinfo, tree);\r\noffset = dissect_rpc_uint64(tvb, tree, hf_fmp_firstLogBlk64, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_numBlksReq,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_minBlks, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_OpenGetMapEx_reply(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_cookie,\r\noffset);\r\noffset = dissect_rpc_uint64(tvb, tree, hf_fmp_fileSize,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_fsID,\r\noffset);\r\noffset = dissect_fmp_extentListEx(tvb, offset, pinfo, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_OpenAllocSpaceEx_request(tvbuff_t *tvb,\r\npacket_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb , tree, hf_fmp_sessionHandle,\r\noffset);\r\noffset = dissect_fmp_fileHandleSrc(tvb, offset, pinfo, tree);\r\noffset = dissect_rpc_uint64(tvb, tree, hf_fmp_firstLogBlk64, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_numBlksReq,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_minBlks, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_OpenAllocSpaceEx_reply(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_cookie,\r\noffset);\r\noffset = dissect_rpc_uint64(tvb, tree, hf_fmp_fileSize,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_fsID,\r\noffset);\r\noffset = dissect_fmp_extentListEx(tvb, offset, pinfo, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_GetMapEx_request(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\noffset = dissect_rpc_uint64(tvb, tree, hf_fmp_firstLogBlk64, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_numBlksReq,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_minBlks, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_GetMapEx_reply(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_cookie,\r\noffset);\r\noffset = dissect_rpc_uint64(tvb, tree, hf_fmp_fileSize,\r\noffset);\r\noffset = dissect_fmp_extentListEx(tvb, offset, pinfo, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_AllocSpaceEx_request(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\noffset = dissect_rpc_uint64(tvb, tree, hf_fmp_firstLogBlk64, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_numBlksReq,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_minBlks, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_AllocSpaceEx_reply(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum,\r\noffset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_cookie,\r\noffset);\r\noffset = dissect_rpc_uint64(tvb, tree, hf_fmp_fileSize,\r\noffset);\r\noffset = dissect_fmp_extentListEx(tvb, offset, pinfo, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_FlushEx_request(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_data(tvb, tree, hf_fmp_fmpFHandle, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum, offset);\r\noffset = dissect_fmp_flushCmd(tvb, offset, tree);\r\noffset = dissect_rpc_uint64(tvb,tree, hf_fmp_eof, offset);\r\noffset = dissect_fmp_extentListEx(tvb, offset, pinfo, tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_FMP_FlushEx_reply(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint rval;\r\nint offset = 0;\r\noffset = dissect_fmp_status(tvb, offset,tree, &rval);\r\nif (rval == 0) {\r\noffset = dissect_rpc_uint32(tvb, tree, hf_fmp_msgNum,\r\noffset);\r\n}\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_fmp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_fmp_procedure,\r\n{ "Procedure", "fmp.procedure",\r\nFT_UINT32, BASE_DEC, VALS(fmp_proc_vals),\r\n0, NULL, HFILL }},\r\n{ &hf_fmp_hostID,\r\n{ "Host ID", "fmp.hostID",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_btime,\r\n{ "Boot Time", "fmp.btime",\r\nFT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0,\r\n"Machine Boot Time", HFILL }},\r\n{ &hf_fmp_time_sec,\r\n{ "seconds", "fmp.btime.sec",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_time_nsec,\r\n{ "nanoseconds", "fmp.btime.nsec",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_notifyPort,\r\n{ "Notify Port", "fmp.notifyPort",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_sessionHandle,\r\n{ "Session Handle", "fmp.sessHandle",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_fmpFHandle,\r\n{ "FMP File Handle", "fmp.fmpFHandle",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL,\r\nHFILL }},\r\n{ &hf_fmp_nfsFHandle,\r\n{ "NFS File Handle", "fmp.nfsFHandle",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_fsID,\r\n{ "File System ID", "fmp.fsID",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_status,\r\n{ "Status", "fmp.status",\r\nFT_UINT32, BASE_DEC, VALS(fmp_status_vals), 0,\r\n"Reply Status", HFILL }},\r\n{ &hf_fmp_fsBlkSz,\r\n{ "File System Block Size", "fmp.fsBlkSz",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_volHandle,\r\n{ "Volume Handle", "fmp.volHandle",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_dskSigEnt_val,\r\n{ "Celerra Signature", "fmp.dsi.ds.dsList.dskSigLst_val.dse.dskSigEnt_val",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_devSignature,\r\n{ "Signature DATA", "fmp.devSig",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_mount_path,\r\n{ "Native Protocol: PATH", "fmp.mount_path",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\n"Absolute path from the root on the server side", HFILL }},\r\n{ &hf_fmp_sig_offset,\r\n{ "Sig Offset", "fmp.dsi.ds.sig_offset",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_numBlksReq,\r\n{ "Extent Length", "fmp.numBlksReq",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_minBlks,\r\n{ "Minimum Blocks to Grant", "fmp.minBlks",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_msgNum,\r\n{ "Message Number", "fmp.msgNum",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_cookie,\r\n{ "Cookie", "fmp.cookie",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Cookie for FMP_REQUEST_QUEUED Resp", HFILL }},\r\n{ &hf_fmp_fileSize,\r\n{ "File Size", "fmp.fileSize",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_extentList_len,\r\n{ "Extent List Length", "fmp.extentList_len",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_extent_state,\r\n{ "Extent State", "fmp.extentState",\r\nFT_UINT32,BASE_DEC, VALS(fmp_extentState_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_firstLogBlk,\r\n{ "First Logical File Block", "fmp.firstLogBlk",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_numBlks,\r\n{ "Number of Blocks", "fmp.numBlks",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_volID,\r\n{ "Volume ID inside DART", "fmp.volID",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_startOffset,\r\n{ "Start Offset", "fmp.startOffset",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_start_offset64,\r\n{ "Start offset", "fmp.start_offset64",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\n"Start Offset of extentEx", HFILL }},\r\n{ &hf_fmp_eof,\r\n{ "EOF", "fmp.eof",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\n"End Of File", HFILL }},\r\n{ &hf_fmp_plugInID,\r\n{ "Plug In Cmd ID", "fmp.plugInID",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_plugInBuf,\r\n{ "Plug In Args", "fmp.plugIn",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_os_major,\r\n{ "OS Major", "fmp.os_major",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_os_minor,\r\n{ "OS Minor", "fmp.os_minor",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_os_name,\r\n{ "OS Name", "fmp.os_name",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_path,\r\n{ "Mount Path", "fmp.Path",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_os_patch,\r\n{ "OS Path", "fmp.os_patch",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_os_build,\r\n{ "OS Build", "fmp.os_build",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_server_version_string,\r\n{ "Server Version String", "fmp.server_version_string",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_description,\r\n{ "Error Description", "fmp.description",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\n"Client Error Description", HFILL }},\r\n{ &hf_fmp_nfsv3Attr_type,\r\n{ "Type", "fmp.nfsv3Attr_type",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"NFSV3 Attr Type", HFILL }},\r\n{ &hf_fmp_nfsv3Attr_mode,\r\n{ "Mode", "fmp.nfsv3Attr_mod",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_nfsv3Attr_nlink,\r\n{ "nlink", "fmp.nfsv3Attr_nlink",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_nfsv3Attr_uid,\r\n{ "uid", "fmp.nfsv3Attr_uid",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_nfsv3Attr_gid,\r\n{ "gid", "fmp.nfsv3Attr_gid",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_nfsv3Attr_used,\r\n{ "Used", "fmp.nfsv3Attr_used",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_nfsv3Attr_rdev,\r\n{ "rdev", "fmp.nfsv3Attr_rdev",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_nfsv3Attr_fsid,\r\n{ "fsid", "fmp.nfsv3Attr_fsid",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_nfsv3Attr_fileid,\r\n{ "File ID", "fmp.nfsv3Attr_fileid",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_cmd,\r\n{ "Command", "fmp.cmd",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_topVolumeId,\r\n{ "Top Volume ID", "fmp.topVolumeId",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_cursor,\r\n{ "number of volumes", "fmp.cursor",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_offset64,\r\n{ "offset", "fmp.offset64",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_slice_size,\r\n{ "size of the slice", "fmp.slice_size",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_volume,\r\n{ "Volume ID's", "fmp.volume",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_stripeSize,\r\n{ "size of the stripe", "fmp.stripeSize",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_firstLogBlk64,\r\n{ "First Logical Block", "fmp.firstLogBlk64",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_native_protocol,\r\n{ "Native Protocol", "fmp.native_protocol",\r\nFT_UINT32, BASE_DEC, VALS(fmp_native_protocol_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_encoding_mode,\r\n{ "Encoding Mode", "fmp.encoding_mode",\r\nFT_UINT32, BASE_DEC, VALS(fmp_encoding_mode_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_capability,\r\n{ "Volume Mgmt Capability", "fmp.capability",\r\nFT_UINT32, BASE_DEC, VALS(fmp_volume_mgmt_capability_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_devSerial_query_cmd,\r\n{ "Query Command", "fmp.devSerial.query_cmd",\r\nFT_UINT32, BASE_DEC, VALS(fmp_query_cmd_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_volume_desc,\r\n{ "VOLUME", "fmp.volume_desc",\r\nFT_UINT32, BASE_DEC, VALS(fmp_volume_desc_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_disk_identifier,\r\n{ "DISK IDENTIFIER", "fmp.disk_identifier",\r\nFT_UINT32, BASE_DEC, VALS(fmp_disk_identifier_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_volume_mgmt_type,\r\n{ "Volume Mgmt Type", "fmp.volume_mgmt_type",\r\nFT_UINT32, BASE_DEC, VALS(fmp_volume_mgmt_type_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_notify_protocol,\r\n{ "Protocol", "fmp.notify_protocol",\r\nFT_UINT32, BASE_DEC, VALS(fmp_notify_protocol_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_client_error_number,\r\n{ "CLIENT Error Number", "fmp.client_error_number",\r\nFT_UINT32, BASE_DEC, VALS(fmp_client_error_number_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_fmp_fid, { "fid", "fmp.fid", FT_INT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_fmp_tid, { "tid", "fmp.tid", FT_INT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_fmp_uid, { "uid", "fmp.uid", FT_INT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_fmp_fsid, { "FsID", "fmp.fsid", FT_INT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_fmp_cifsport, { "cifsPort", "fmp.cifsport", FT_INT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_fmp_number_of_disk, { "Number of Disk", "fmp.number_of_disk", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_fmp_length_of_list, { "Length of List", "fmp.length_of_list", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_fmp_sigoffset, { "sigOffset", "fmp.sigoffset", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_fmp_length_of_volume_list, { "Length of volume List", "fmp.length_of_volume_list", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_fmp_blockindex, { "blockIndex", "fmp.blockindex", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_fmp_cap, { "Capabilities", "fmp.cap", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_fmp_cap_revoke_handle_list, { "CAP_REVOKE_HANDLE_LIST", "fmp.cap.revoke_handle_list", FT_BOOLEAN, 32, TFS(&tfs_yes_no), FMP_CAP_REVOKE_HANDLE_LIST, NULL, HFILL }},\r\n{ &hf_fmp_cap_unc_names, { "CAP_UNC_NAMES", "fmp.cap.unc_names", FT_BOOLEAN, 32, TFS(&tfs_yes_no), FMP_CAP_UNC_NAMES, NULL, HFILL }},\r\n{ &hf_fmp_cap_cifsv2, { "CAP_CIFSV2", "fmp.cap.cifsv2", FT_BOOLEAN, 32, TFS(&tfs_yes_no), FMP_CAP_CIFSV2, NULL, HFILL }},\r\n{ &hf_fmp_mtime, { "mtime", "fmp.mtime", FT_RELATIVE_TIME, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_fmp_atime, { "atime", "fmp.atime", FT_RELATIVE_TIME, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_fmp_ctime, { "ctime", "fmp.ctime", FT_RELATIVE_TIME, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_fmp_heartbeat_interval, { "Heartbeat interval", "fmp.heartbeat_interval", FT_RELATIVE_TIME, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_fmp_volindex, { "volIndex", "fmp.volindex", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_fmp,\r\n&ett_fmp_timeval,\r\n&ett_fmp_extList,\r\n&ett_fmp_ext,\r\n&ett_fmp_fileHandle,\r\n&ett_capabilities,\r\n&ett_HierVolumeDescription,\r\n&ett_attrs\r\n};\r\nmodule_t *fmp_module;\r\nproto_fmp = proto_register_protocol("File Mapping Protocol", "FMP", "fmp");\r\nproto_register_field_array(proto_fmp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nfmp_module=prefs_register_protocol(proto_fmp, NULL);\r\nprefs_register_bool_preference(fmp_module, "fhandle_find_both_reqrep",\r\n"Fhandle filters finds both request/response",\r\n"With this option display filters for fmp fhandle a RPC call,"\r\n" even if the actual fhandle is only present in one of the packets",\r\n&fmp_fhandle_reqrep_matching);\r\n}\r\nvoid\r\nproto_reg_handoff_fmp(void)\r\n{\r\nrpc_init_prog(proto_fmp, FMP_PROGRAM, ett_fmp,\r\nG_N_ELEMENTS(fmp_vers_info), fmp_vers_info);\r\n}
