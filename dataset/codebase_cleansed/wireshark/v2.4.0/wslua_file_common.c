void create_wth_priv(lua_State* L, wtap *wth) {\r\nfile_priv_t *priv = (file_priv_t*)g_malloc(sizeof(file_priv_t));\r\nif (wth->priv != NULL) {\r\nluaL_error(L, "Cannot create wtap private data because there already is private data");\r\nreturn;\r\n}\r\npriv->table_ref = LUA_NOREF;\r\nwth->priv = (void*) priv;\r\n}\r\nint get_wth_priv_table_ref(lua_State* L, wtap *wth) {\r\nfile_priv_t *priv = (file_priv_t*) wth->priv;\r\nif (!priv) {\r\nluaL_error(L, "Cannot get wtap private data: it is null");\r\nreturn LUA_NOREF;\r\n}\r\nlua_rawgeti(L, LUA_REGISTRYINDEX, priv->table_ref);\r\nreturn 1;\r\n}\r\nint set_wth_priv_table_ref(lua_State* L, wtap *wth) {\r\nfile_priv_t *priv = (file_priv_t*) wth->priv;\r\nif (!priv) {\r\nluaL_error(L, "Cannot get wtap private data: it is null");\r\nreturn 0;\r\n}\r\nif (lua_isnil(L, -1)){\r\nluaL_unref(L, LUA_REGISTRYINDEX, priv->table_ref);\r\npriv->table_ref = LUA_NOREF;\r\nreturn 0;\r\n}\r\nif (!lua_istable(L, -1)) {\r\nluaL_error(L, "The private_table member can only be set to a table or nil");\r\nreturn 0;\r\n}\r\nif (priv->table_ref != LUA_NOREF) {\r\nluaL_unref(L, LUA_REGISTRYINDEX, priv->table_ref);\r\n}\r\npriv->table_ref = luaL_ref(L, LUA_REGISTRYINDEX);\r\nreturn 0;\r\n}\r\nvoid remove_wth_priv(lua_State* L, wtap *wth) {\r\nfile_priv_t *priv = (file_priv_t*) wth->priv;\r\nif (!priv) {\r\nluaL_error(L, "Cannot remove wtap private data: it is null");\r\nreturn;\r\n}\r\nluaL_unref(L, LUA_REGISTRYINDEX, priv->table_ref);\r\ng_free(wth->priv);\r\nwth->priv = NULL;\r\n}\r\nvoid create_wdh_priv(lua_State* L, wtap_dumper *wdh) {\r\nfile_priv_t *priv = (file_priv_t*)g_malloc(sizeof(file_priv_t));\r\nif (wdh->priv != NULL) {\r\nluaL_error(L, "Cannot create wtap_dumper private data because there already is private data");\r\nreturn;\r\n}\r\npriv->table_ref = LUA_NOREF;\r\nwdh->priv = (void*) priv;\r\n}\r\nint get_wdh_priv_table_ref(lua_State* L, wtap_dumper *wdh) {\r\nfile_priv_t *priv = (file_priv_t*) wdh->priv;\r\nif (!priv) {\r\nluaL_error(L, "Cannot get wtap_dumper private data: it is null");\r\nreturn LUA_NOREF;\r\n}\r\nlua_rawgeti(L, LUA_REGISTRYINDEX, priv->table_ref);\r\nreturn 1;\r\n}\r\nint set_wdh_priv_table_ref(lua_State* L, wtap_dumper *wdh) {\r\nfile_priv_t *priv = (file_priv_t*) wdh->priv;\r\nif (!priv) {\r\nluaL_error(L, "Cannot get wtap private data: it is null");\r\nreturn 0;\r\n}\r\nif (lua_isnil(L, -1)){\r\nluaL_unref(L, LUA_REGISTRYINDEX, priv->table_ref);\r\npriv->table_ref = LUA_NOREF;\r\nreturn 0;\r\n}\r\nif (!lua_istable(L, -1)) {\r\nluaL_error(L, "The private_table member can only be set to a table or nil");\r\nreturn 0;\r\n}\r\nif (priv->table_ref != LUA_NOREF) {\r\nluaL_unref(L, LUA_REGISTRYINDEX, priv->table_ref);\r\n}\r\npriv->table_ref = luaL_ref(L, LUA_REGISTRYINDEX);\r\nreturn 0;\r\n}\r\nvoid remove_wdh_priv(lua_State* L, wtap_dumper *wdh) {\r\nfile_priv_t *priv = (file_priv_t*) wdh->priv;\r\nif (!priv) {\r\nluaL_error(L, "Cannot remove wtap_dumper private data: it is null");\r\nreturn;\r\n}\r\nluaL_unref(L, LUA_REGISTRYINDEX, priv->table_ref);\r\n}
