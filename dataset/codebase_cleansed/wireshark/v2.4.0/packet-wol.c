static int\r\ndissect_wol_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nguint len;\r\ngint offset;\r\nguint8 *mac;\r\nconst guint8 *passwd;\r\nguint64 qword;\r\naddress mac_addr;\r\nproto_item *ti;\r\nproto_tree *wol_tree;\r\nproto_tree *mac_tree;\r\nlen = tvb_reported_length(tvb);\r\nif ( len < 102 )\r\nreturn (0);\r\nqword = tvb_get_ntoh48(tvb,0);\r\nif(qword != G_GUINT64_CONSTANT(0xffffffffffff))\r\nreturn (0);\r\nmac = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, 6, 6);\r\nfor ( offset = 12; offset < 102; offset += 6 )\r\nif ( tvb_memeql(tvb, offset, mac, 6) != 0 )\r\nreturn (0);\r\nif ( len >= 106 && len < 108 )\r\n{\r\nlen = 106;\r\npasswd = tvb_ip_to_str(tvb, 102);\r\n}\r\nelse if ( len >= 108 )\r\n{\r\nlen = 108;\r\npasswd = tvb_ether_to_str(tvb, 102);\r\n}\r\nelse\r\n{\r\nlen = 102;\r\npasswd = NULL;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "WOL");\r\nset_address(&mac_addr, AT_ETHER, 6, mac);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MagicPacket for %s",\r\naddress_with_resolution_to_str(wmem_packet_scope(), &mac_addr));\r\nif ( passwd )\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", password %s", passwd);\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_wol, tvb, 0, len, ENC_NA);\r\nproto_item_append_text(ti, ", MAC: %s",\r\naddress_with_resolution_to_str(wmem_packet_scope(), &mac_addr));\r\nif ( passwd )\r\nproto_item_append_text(ti, ", password: %s", passwd);\r\nwol_tree = proto_item_add_subtree(ti, ett_wol);\r\nproto_tree_add_item(wol_tree, hf_wol_sync, tvb, 0, 6, ENC_NA);\r\nmac_tree = proto_tree_add_subtree_format(wol_tree, tvb, 6, 96,\r\nett_wol_macblock, NULL, "MAC: %s",\r\naddress_with_resolution_to_str(wmem_packet_scope(), &mac_addr));\r\nfor ( offset = 6; offset < 102; offset += 6 )\r\nproto_tree_add_ether(mac_tree, hf_wol_mac, tvb, offset, 6, mac);\r\nif ( len == 106 )\r\nproto_tree_add_bytes_format_value(wol_tree, hf_wol_passwd, tvb, offset,\r\n4, passwd, "%s", passwd);\r\nelse if ( len == 108 )\r\nproto_tree_add_bytes_format_value(wol_tree, hf_wol_passwd, tvb, offset,\r\n6, passwd, "%s", passwd);\r\n}\r\nreturn (len);\r\n}\r\nstatic int\r\ndissect_wol(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nreturn dissect_wol_pdu(tvb, pinfo, tree, data);\r\n}\r\nstatic gboolean\r\ndissect_wolheur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nif (dissect_wol_pdu(tvb, pinfo, tree, data) > 0)\r\nreturn TRUE;\r\nreturn FALSE;\r\n}\r\nvoid\r\nproto_register_wol(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_wol_sync,\r\n{ "Sync stream", "wol.sync",\r\nFT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_wol_mac,\r\n{ "MAC", "wol.mac",\r\nFT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_wol_passwd,\r\n{ "Password", "wol.passwd",\r\nFT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_wol,\r\n&ett_wol_macblock\r\n};\r\nproto_wol = proto_register_protocol("Wake On LAN", "WOL", "wol");\r\nproto_register_field_array(proto_wol, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_wol(void)\r\n{\r\ndissector_handle_t wol_handle;\r\nwol_handle = create_dissector_handle(dissect_wol, proto_wol);\r\ndissector_add_uint("ethertype", ETHERTYPE_WOL, wol_handle);\r\nheur_dissector_add("udp", dissect_wolheur, "Wake On LAN over UDP", "wol_udp", proto_wol, HEURISTIC_ENABLE);\r\n}
