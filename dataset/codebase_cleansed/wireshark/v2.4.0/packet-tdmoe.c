static int\r\ndissect_tdmoe(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *tdmoe_tree;\r\ntvbuff_t *next_client;\r\nguint16 channels;\r\nguint16 subaddress;\r\ngint32 offset = 0;\r\nstatic const gint *flags[] = { &hf_tdmoe_yellow_alarm, &hf_tdmoe_sig_bits_present, NULL };\r\nint chan;\r\nif (tvb_captured_length(tvb) < 8)\r\nreturn 0;\r\nsubaddress = tvb_get_ntohs(tvb, 0);\r\nchannels = tvb_get_ntohs(tvb, 6);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "TDMoE");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Subaddress: %d Channels: %d %s",\r\nsubaddress,\r\nchannels,\r\n(tvb_get_guint8(tvb, 3) & TDMOE_YELLOW_ALARM_BITMASK ? "[YELLOW ALARM]" : "")\r\n);\r\nti = proto_tree_add_item(tree, proto_tdmoe, tvb, 0, -1, ENC_NA);\r\ntdmoe_tree = proto_item_add_subtree(ti, ett_tdmoe);\r\nproto_tree_add_item(tdmoe_tree, hf_tdmoe_subaddress, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(tdmoe_tree, hf_tdmoe_samples, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_bitmask(tdmoe_tree, tvb, offset, hf_tdmoe_flags, ett_tdmoe_flags, flags, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(tdmoe_tree, hf_tdmoe_packet_counter, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(tdmoe_tree, hf_tdmoe_channels, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nif (tvb_get_guint8(tvb, 3) & TDMOE_SIGBITS_BITMASK) {\r\nguint16 length = (channels >> 1) + ((channels & 0x01) ? 1 : 0);\r\nproto_tree_add_item(tdmoe_tree, hf_tdmoe_sig_bits, tvb, offset, length, ENC_NA);\r\noffset += length;\r\n}\r\nfor (chan = 1; chan <= channels; chan++) {\r\nnext_client = tvb_new_subset_length(tvb, offset + ((chan - 1) * 8), 8);\r\nif (chan == pref_tdmoe_d_channel) {\r\ncall_dissector(lapd_handle, next_client, pinfo, tree);\r\n} else {\r\ncall_data_dissector(next_client, pinfo, tree);\r\n}\r\n}\r\nreturn 1;\r\n}\r\nvoid\r\nproto_register_tdmoe(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_tdmoe_subaddress,\r\n{ "Subaddress", "tdmoe.subaddress", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tdmoe_samples,\r\n{ "Samples", "tdmoe.samples", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Samples per channel", HFILL }},\r\n{ &hf_tdmoe_flags,\r\n{ "Flags", "tdmoe.flags", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tdmoe_yellow_alarm,\r\n{ "Yellow Alarm", "tdmoe.yellowalarm", FT_BOOLEAN, 8, NULL, TDMOE_YELLOW_ALARM_BITMASK,\r\nNULL, HFILL }},\r\n{ &hf_tdmoe_sig_bits_present,\r\n{ "Sig bits present", "tdmoe.sig_bits_present", FT_BOOLEAN, 8, NULL, TDMOE_SIGBITS_BITMASK,\r\nNULL, HFILL }},\r\n{ &hf_tdmoe_packet_counter,\r\n{ "Counter", "tdmoe.counter", FT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Packet number", HFILL }},\r\n{ &hf_tdmoe_channels,\r\n{ "Channels", "tdmoe.channels", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tdmoe_sig_bits,\r\n{ "Sig bits", "tdmoe.sig_bits", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_tdmoe,\r\n&ett_tdmoe_flags\r\n};\r\nmodule_t *tdmoe_module;\r\nproto_tdmoe = proto_register_protocol("Digium TDMoE Protocol", "TDMoE", "tdmoe");\r\nproto_register_field_array(proto_tdmoe, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\ntdmoe_module = prefs_register_protocol(proto_tdmoe, proto_reg_handoff_tdmoe);\r\nprefs_register_uint_preference(tdmoe_module, "d_channel",\r\n"TDMoE D-Channel",\r\n"The TDMoE channel that contains the D-Channel.",\r\n10, &pref_tdmoe_d_channel);\r\n}\r\nvoid\r\nproto_reg_handoff_tdmoe(void)\r\n{\r\ndissector_handle_t tdmoe_handle;\r\ntdmoe_handle = create_dissector_handle(dissect_tdmoe, proto_tdmoe);\r\ndissector_add_uint("ethertype", ETHERTYPE_TDMOE, tdmoe_handle);\r\nlapd_handle = find_dissector_add_dependency("lapd-bitstream", proto_tdmoe);\r\n}
