void\r\nxmpp_iq_reqresp_track(packet_info *pinfo, xmpp_element_t *packet, xmpp_conv_info_t *xmpp_info)\r\n{\r\nxmpp_transaction_t *xmpp_trans = NULL;\r\nxmpp_attr_t *attr_id;\r\nchar *id;\r\nattr_id = xmpp_get_attr(packet, "id");\r\nif (!attr_id) {\r\nreturn;\r\n}\r\nid = wmem_strdup(wmem_packet_scope(), attr_id->value);\r\nif (!pinfo->fd->flags.visited) {\r\nxmpp_trans = (xmpp_transaction_t *)wmem_tree_lookup_string(xmpp_info->req_resp, id, WMEM_TREE_STRING_NOCASE);\r\nif (xmpp_trans) {\r\nxmpp_trans->resp_frame = pinfo->num;\r\n} else {\r\nchar *se_id = wmem_strdup(wmem_file_scope(), id);\r\nxmpp_trans = wmem_new(wmem_file_scope(), xmpp_transaction_t);\r\nxmpp_trans->req_frame = pinfo->num;\r\nxmpp_trans->resp_frame = 0;\r\nwmem_tree_insert_string(xmpp_info->req_resp, se_id, (void *) xmpp_trans, WMEM_TREE_STRING_NOCASE);\r\n}\r\n} else {\r\nwmem_tree_lookup_string(xmpp_info->req_resp, id, WMEM_TREE_STRING_NOCASE);\r\n}\r\n}\r\nvoid\r\nxmpp_jingle_session_track(packet_info *pinfo, xmpp_element_t *packet, xmpp_conv_info_t *xmpp_info)\r\n{\r\nxmpp_element_t *jingle_packet;\r\nGList *jingle_packet_l;\r\njingle_packet_l = xmpp_find_element_by_name(packet,"jingle");\r\njingle_packet = (xmpp_element_t *)(jingle_packet_l?jingle_packet_l->data:NULL);\r\nif (jingle_packet && !pinfo->fd->flags.visited) {\r\nxmpp_attr_t *attr_id;\r\nxmpp_attr_t *attr_sid;\r\nchar *se_id;\r\nchar *se_sid;\r\nattr_id = xmpp_get_attr(packet, "id");\r\nif (!attr_id) {\r\nreturn;\r\n}\r\nattr_sid = xmpp_get_attr(jingle_packet, "sid");\r\nif (!attr_sid) {\r\nreturn;\r\n}\r\nse_id = wmem_strdup(wmem_file_scope(), attr_id->value);\r\nse_sid = wmem_strdup(wmem_file_scope(), attr_sid->value);\r\nwmem_tree_insert_string(xmpp_info->jingle_sessions, se_id, (void*) se_sid, WMEM_TREE_STRING_NOCASE);\r\n}\r\n}\r\nvoid\r\nxmpp_gtalk_session_track(packet_info *pinfo, xmpp_element_t *packet, xmpp_conv_info_t *xmpp_info)\r\n{\r\nxmpp_element_t *gtalk_packet;\r\nGList *gtalk_packet_l;\r\ngtalk_packet_l = xmpp_find_element_by_name(packet,"session");\r\ngtalk_packet = (xmpp_element_t *)(gtalk_packet_l?gtalk_packet_l->data:NULL);\r\nif (gtalk_packet && !pinfo->fd->flags.visited) {\r\nxmpp_attr_t *attr_id;\r\nxmpp_attr_t *attr_sid;\r\nchar *se_id;\r\nchar *se_sid;\r\nxmpp_attr_t *xmlns = xmpp_get_attr(gtalk_packet, "xmlns");\r\nif(xmlns && strcmp(xmlns->value,"http://www.google.com/session") != 0)\r\nreturn;\r\nattr_id = xmpp_get_attr(packet, "id");\r\nif (!attr_id) {\r\nreturn;\r\n}\r\nattr_sid = xmpp_get_attr(gtalk_packet, "id");\r\nif (!attr_sid) {\r\nreturn;\r\n}\r\nse_id = wmem_strdup(wmem_file_scope(), attr_id->value);\r\nse_sid = wmem_strdup(wmem_file_scope(), attr_sid->value);\r\nwmem_tree_insert_string(xmpp_info->gtalk_sessions, se_id, (void*) se_sid, WMEM_TREE_STRING_NOCASE);\r\n}\r\n}\r\nvoid\r\nxmpp_ibb_session_track(packet_info *pinfo, xmpp_element_t *packet, xmpp_conv_info_t *xmpp_info)\r\n{\r\nxmpp_element_t *ibb_packet = NULL;\r\nGList *ibb_packet_l;\r\nif(strcmp(packet->name, "message") == 0)\r\n{\r\nibb_packet_l = xmpp_find_element_by_name(packet,"data");\r\nibb_packet = (xmpp_element_t *)(ibb_packet_l?ibb_packet_l->data:NULL);\r\n} else if(strcmp(packet->name, "iq") == 0)\r\n{\r\nibb_packet_l = xmpp_find_element_by_name(packet,"open");\r\nif(!ibb_packet_l)\r\nibb_packet_l = xmpp_find_element_by_name(packet,"close");\r\nif(!ibb_packet_l)\r\nibb_packet_l = xmpp_find_element_by_name(packet,"data");\r\nibb_packet = (xmpp_element_t *)(ibb_packet_l?ibb_packet_l->data:NULL);\r\n}\r\nif (ibb_packet && !pinfo->fd->flags.visited) {\r\nxmpp_attr_t *attr_id;\r\nxmpp_attr_t *attr_sid;\r\nchar *se_id;\r\nchar *se_sid;\r\nattr_id = xmpp_get_attr(packet, "id");\r\nattr_sid = xmpp_get_attr(ibb_packet, "sid");\r\nif(attr_id && attr_sid)\r\n{\r\nse_id = wmem_strdup(wmem_file_scope(), attr_id->value);\r\nse_sid = wmem_strdup(wmem_file_scope(), attr_sid->value);\r\nwmem_tree_insert_string(xmpp_info->ibb_sessions, se_id, (void*) se_sid, WMEM_TREE_STRING_NOCASE);\r\n}\r\n}\r\n}\r\nstatic void\r\nxmpp_unknown_items(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, xmpp_element_t *element, guint level)\r\n{\r\nGList *childs = element->elements;\r\nDISSECTOR_ASSERT( level < ETT_UNKNOWN_LEN );\r\nxmpp_unknown_attrs(tree, tvb, pinfo, element, TRUE);\r\nif(element->data)\r\n{\r\nproto_tree_add_string(tree, hf_xmpp_cdata, tvb, element->data->offset, element->data->length, element->data->value);\r\n}\r\nwhile(childs)\r\n{\r\nxmpp_element_t *child = (xmpp_element_t *)childs->data;\r\nproto_item *child_item;\r\nproto_tree *child_tree = proto_tree_add_subtree(tree, tvb, child->offset, child->length,\r\nett_unknown[level], &child_item, xmpp_ep_string_upcase(child->name));\r\nif(child->default_ns_abbrev)\r\nproto_item_append_text(child_item, "(%s)", child->default_ns_abbrev);\r\nxmpp_unknown_items(child_tree, tvb, pinfo, child, level +1);\r\nchilds = childs->next;\r\n}\r\n}\r\nvoid\r\nxmpp_unknown(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, xmpp_element_t *element)\r\n{\r\nGList *childs = element->elements;\r\nwhile(childs)\r\n{\r\nxmpp_element_t *child = (xmpp_element_t *)childs->data;\r\nif(!child->was_read)\r\n{\r\nproto_item *unknown_item;\r\nproto_tree *unknown_tree;\r\nunknown_item = proto_tree_add_string_format(tree,\r\nhf_xmpp_unknown, tvb, child->offset, child->length, child->name,\r\n"%s", xmpp_ep_string_upcase(child->name));\r\nunknown_tree = proto_item_add_subtree(unknown_item, ett_unknown[0]);\r\nif(strcmp(element->name,"iq")==0)\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s ", xmpp_ep_string_upcase(child->name));\r\nif(child->default_ns_abbrev)\r\nproto_item_append_text(unknown_item,"(%s)",child->default_ns_abbrev);\r\nxmpp_unknown_items(unknown_tree, tvb, pinfo, child, 1);\r\nproto_item_append_text(unknown_item, " [UNKNOWN]");\r\nexpert_add_info_format(pinfo, unknown_item, &ei_xmpp_unknown_element, "Unknown element: %s", child->name);\r\n}\r\nchilds = childs->next;\r\n}\r\n}\r\nvoid\r\nxmpp_unknown_attrs(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, xmpp_element_t *element, gboolean displ_short_list)\r\n{\r\nproto_item *item = proto_tree_get_parent(tree);\r\nGList *keys = g_hash_table_get_keys(element->attrs);\r\nGList *values = g_hash_table_get_values(element->attrs);\r\nGList *keys_head = keys, *values_head = values;\r\ngboolean short_list_started = FALSE;\r\nwhile(keys && values)\r\n{\r\nxmpp_attr_t *attr = (xmpp_attr_t*) values->data;\r\nif (!attr->was_read) {\r\nif (displ_short_list) {\r\nif (!short_list_started)\r\nproto_item_append_text(item, " [");\r\nelse\r\nproto_item_append_text(item, " ");\r\nproto_item_append_text(item, "%s=\"%s\"", (gchar*) keys->data, attr->value);\r\nshort_list_started = TRUE;\r\n}\r\nif (strcmp((const char *)keys->data, "xmlns") == 0)\r\nproto_tree_add_string(tree, hf_xmpp_xmlns, tvb, attr->offset, attr->length, attr->value);\r\nelse {\r\nconst gchar *xmlns_needle = epan_strcasestr((const char *)keys->data, "xmlns:");\r\nif (xmlns_needle && xmlns_needle == keys->data) {\r\nproto_tree_add_string_format(tree, hf_xmpp_xmlns, tvb, attr->offset, attr->length, attr->value,"%s: %s", (gchar*)keys->data, attr->value);\r\n} else {\r\nproto_item* unknown_attr_item;\r\nunknown_attr_item = proto_tree_add_string_format(tree,\r\nhf_xmpp_unknown_attr, tvb, attr->offset, attr->length,\r\nattr->name, "%s: %s", attr->name, attr->value);\r\nproto_item_append_text(unknown_attr_item, " [UNKNOWN ATTR]");\r\nexpert_add_info_format(pinfo, unknown_attr_item, &ei_xmpp_unknown_attribute, "Unknown attribute %s", attr->name);\r\n}\r\n}\r\n}\r\nkeys = keys->next;\r\nvalues = values->next;\r\n}\r\nif(short_list_started && displ_short_list)\r\nproto_item_append_text(item, "]");\r\ng_list_free(keys_head);\r\ng_list_free(values_head);\r\n}\r\nvoid\r\nxmpp_cdata(proto_tree *tree, tvbuff_t *tvb, xmpp_element_t *element, gint hf)\r\n{\r\nif(element->data)\r\n{\r\nif (hf == -1) {\r\nproto_tree_add_string(tree, hf_xmpp_cdata, tvb, element->data->offset, element->data->length, element->data->value);\r\n} else {\r\nproto_tree_add_string(tree, hf, tvb, element->data->offset, element->data->length, element->data->value);\r\n}\r\n} else\r\n{\r\nif (hf == -1) {\r\nproto_tree_add_string_format_value(tree, hf_xmpp_cdata, tvb, 0, 0, "", "(empty)");\r\n} else {\r\nproto_tree_add_string(tree, hf, tvb, 0, 0, "");\r\n}\r\n}\r\n}\r\nvoid\r\nxmpp_simple_cdata_elem(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, xmpp_element_t *element)\r\n{\r\nproto_tree_add_string_format(tree, hf_xmpp_cdata, tvb, element->offset, element->length, xmpp_elem_cdata(element),\r\n"%s: %s", xmpp_ep_string_upcase(element->name), xmpp_elem_cdata(element));\r\n}\r\nxmpp_array_t*\r\nxmpp_ep_init_array_t(const gchar** array, gint len)\r\n{\r\nxmpp_array_t *result;\r\nresult = wmem_new(wmem_packet_scope(), xmpp_array_t);\r\nresult->data = (gpointer) array;\r\nresult->length = len;\r\nreturn result;\r\n}\r\nxmpp_attr_t*\r\nxmpp_ep_init_attr_t(const gchar *value, gint offset, gint length)\r\n{\r\nxmpp_attr_t *result;\r\nresult = wmem_new(wmem_packet_scope(), xmpp_attr_t);\r\nresult->value = value;\r\nresult->offset = offset;\r\nresult->length = length;\r\nresult->name = NULL;\r\nreturn result;\r\n}\r\ngchar*\r\nxmpp_ep_string_upcase(const gchar* string)\r\n{\r\ngint len = (int)strlen(string);\r\ngint i;\r\ngchar* result = (gchar *)wmem_alloc0(wmem_packet_scope(), len+1);\r\nfor(i=0; i<len; i++)\r\n{\r\nresult[i] = string[i];\r\nif(string[i]>='a' && string[i]<='z')\r\nresult[i]-='a'-'A';\r\n}\r\nreturn result;\r\n}\r\ngint\r\nxmpp_element_t_cmp(gconstpointer a, gconstpointer b)\r\n{\r\ngint result = strcmp(((const xmpp_element_t*)a)->name,((const xmpp_element_t*)b)->name);\r\nif(result == 0 && ((const xmpp_element_t*)a)->was_read)\r\nresult = -1;\r\nreturn result;\r\n}\r\nGList*\r\nxmpp_find_element_by_name(xmpp_element_t *packet,const gchar *name)\r\n{\r\nGList *found_elements;\r\nxmpp_element_t *search_element;\r\nsearch_element = wmem_new(wmem_packet_scope(), xmpp_element_t);\r\nsearch_element->name = wmem_strdup(wmem_packet_scope(), name);\r\nfound_elements = g_list_find_custom(packet->elements, search_element, xmpp_element_t_cmp);\r\nif(found_elements)\r\nreturn found_elements;\r\nelse\r\nreturn NULL;\r\n}\r\nxmpp_element_t*\r\nxmpp_steal_element_by_name(xmpp_element_t *packet,const gchar *name)\r\n{\r\nGList *element_l;\r\nxmpp_element_t *element = NULL;\r\nelement_l = xmpp_find_element_by_name(packet, name);\r\nif(element_l)\r\n{\r\nelement = (xmpp_element_t *)element_l->data;\r\nelement->was_read = TRUE;\r\n}\r\nreturn element;\r\n}\r\nxmpp_element_t*\r\nxmpp_steal_element_by_names(xmpp_element_t *packet, const gchar **names, gint names_len)\r\n{\r\ngint i;\r\nxmpp_element_t *el = NULL;\r\nfor(i = 0; i<names_len; i++)\r\n{\r\nif((el = xmpp_steal_element_by_name(packet, names[i])))\r\nbreak;\r\n}\r\nreturn el;\r\n}\r\nxmpp_element_t*\r\nxmpp_steal_element_by_attr(xmpp_element_t *packet, const gchar *attr_name, const gchar *attr_value)\r\n{\r\nGList *childs = packet->elements;\r\nxmpp_element_t *result = NULL;\r\nwhile (childs) {\r\nxmpp_element_t *child_elem = (xmpp_element_t *)childs->data;\r\nxmpp_attr_t *attr = xmpp_get_attr(child_elem, attr_name);\r\nif(attr)\r\nattr->was_read = FALSE;\r\nif (!child_elem->was_read && attr && strcmp(attr->value, attr_value) == 0) {\r\nresult = (xmpp_element_t *)childs->data;\r\nresult->was_read = TRUE;\r\nbreak;\r\n} else\r\nchilds = childs->next;\r\n}\r\nreturn result;\r\n}\r\nxmpp_element_t*\r\nxmpp_steal_element_by_name_and_attr(xmpp_element_t *packet, const gchar *name, const gchar *attr_name, const gchar *attr_value)\r\n{\r\nGList *childs = packet->elements;\r\nxmpp_element_t *result = NULL;\r\nwhile (childs) {\r\nxmpp_element_t *child_elem = (xmpp_element_t *)childs->data;\r\nxmpp_attr_t *attr = xmpp_get_attr(child_elem, attr_name);\r\nif(attr)\r\nattr->was_read = FALSE;\r\nif (!child_elem->was_read && attr && strcmp(child_elem->name, name) == 0 && strcmp(attr->value, attr_value) == 0) {\r\nresult = (xmpp_element_t *)childs->data;\r\nresult->was_read = TRUE;\r\nbreak;\r\n} else\r\nchilds = childs->next;\r\n}\r\nreturn result;\r\n}\r\nxmpp_element_t*\r\nxmpp_get_first_element(xmpp_element_t *packet)\r\n{\r\nif(packet->elements && packet->elements->data)\r\nreturn (xmpp_element_t *)packet->elements->data;\r\nelse\r\nreturn NULL;\r\n}\r\nxmpp_element_t*\r\nxmpp_xml_frame_to_element_t(xml_frame_t *xml_frame, xmpp_element_t *parent, tvbuff_t *tvb)\r\n{\r\nxml_frame_t *child;\r\nxmpp_element_t *node = wmem_new0(wmem_packet_scope(), xmpp_element_t);\r\ntvbparse_t* tt;\r\ntvbparse_elem_t* elem;\r\nnode->attrs = g_hash_table_new(g_str_hash, g_str_equal);\r\nnode->elements = NULL;\r\nnode->data = NULL;\r\nnode->was_read = FALSE;\r\nnode->default_ns_abbrev = NULL;\r\nnode->name = wmem_strdup(wmem_packet_scope(), xml_frame->name_orig_case);\r\nnode->offset = 0;\r\nnode->length = 0;\r\nnode->namespaces = g_hash_table_new(g_str_hash, g_str_equal);\r\nif(parent)\r\n{\r\nxmpp_copy_hash_table(parent->namespaces, node->namespaces);\r\n} else\r\n{\r\ng_hash_table_insert(node->namespaces, (gpointer)"", (gpointer)"jabber:client");\r\n}\r\nnode->offset = xml_frame->start_offset;\r\nnode->length = xml_frame->length;\r\ntt = tvbparse_init(tvb,node->offset,-1,NULL,want_ignore);\r\nif((elem = tvbparse_get(tt,want_stream_end_with_ns))!=NULL)\r\n{\r\nnode->default_ns_abbrev = tvb_get_string_enc(wmem_packet_scope(), elem->sub->tvb, elem->sub->offset, elem->sub->len, ENC_ASCII);\r\n}\r\nchild = xml_frame->first_child;\r\nwhile(child)\r\n{\r\nif(child->type != XML_FRAME_TAG)\r\n{\r\nif(child->type == XML_FRAME_ATTRIB)\r\n{\r\ngint l;\r\ngchar *value = NULL;\r\nconst gchar *xmlns_needle = NULL;\r\nxmpp_attr_t *attr = wmem_new(wmem_packet_scope(), xmpp_attr_t);\r\nattr->length = 0;\r\nattr->offset = 0;\r\nattr->was_read = FALSE;\r\nif (child->value != NULL) {\r\nl = tvb_reported_length(child->value);\r\nvalue = (gchar *)wmem_alloc0(wmem_packet_scope(), l + 1);\r\ntvb_memcpy(child->value, value, 0, l);\r\n}\r\nattr->offset = child->start_offset;\r\nattr->length = child->length;\r\nattr->value = value;\r\nattr->name = wmem_strdup(wmem_packet_scope(), child->name_orig_case);\r\ng_hash_table_insert(node->attrs,(gpointer)attr->name,(gpointer)attr);\r\nxmlns_needle = epan_strcasestr(attr->name, "xmlns");\r\nif(xmlns_needle == attr->name)\r\n{\r\nif(attr->name[5] == ':' && strlen(attr->name) > 6)\r\n{\r\ng_hash_table_insert(node->namespaces, (gpointer)wmem_strdup(wmem_packet_scope(), &attr->name[6]), (gpointer)wmem_strdup(wmem_packet_scope(), attr->value));\r\n} else if(attr->name[5] == '\0')\r\n{\r\ng_hash_table_insert(node->namespaces, (gpointer)"", (gpointer)wmem_strdup(wmem_packet_scope(), attr->value));\r\n}\r\n}\r\n}\r\nelse if( child->type == XML_FRAME_CDATA)\r\n{\r\nxmpp_data_t *data = NULL;\r\ngint l;\r\ngchar* value = NULL;\r\ndata = wmem_new(wmem_packet_scope(), xmpp_data_t);\r\ndata->length = 0;\r\ndata->offset = 0;\r\nif (child->value != NULL) {\r\nl = tvb_reported_length(child->value);\r\nvalue = (gchar *)wmem_alloc0(wmem_packet_scope(), l + 1);\r\ntvb_memcpy(child->value, value, 0, l);\r\n}\r\ndata->value = value;\r\ndata->offset = child->start_offset;\r\ndata->length = child->length;\r\nnode->data = data;\r\n}\r\n} else\r\n{\r\nnode->elements = g_list_append(node->elements,(gpointer)xmpp_xml_frame_to_element_t(child, node,tvb));\r\n}\r\nchild = child->next_sibling;\r\n}\r\nreturn node;\r\n}\r\nvoid\r\nxmpp_element_t_tree_free(xmpp_element_t *root)\r\n{\r\nGList *childs = root->elements;\r\ng_hash_table_destroy(root->attrs);\r\ng_hash_table_destroy(root->namespaces);\r\nwhile(childs)\r\n{\r\nxmpp_element_t *child = (xmpp_element_t *)childs->data;\r\nxmpp_element_t_tree_free(child);\r\nchilds = childs->next;\r\n}\r\ng_list_free(root->elements);\r\n}\r\nstatic gboolean\r\nattr_find_pred(gpointer key, gpointer value _U_, gpointer user_data)\r\n{\r\ngchar *attr_name = (gchar*) user_data;\r\nif( strcmp(attr_name, "xmlns") == 0 )\r\n{\r\nconst gchar *first_occur = epan_strcasestr((const char *)key, "xmlns:");\r\nif(first_occur && first_occur == key)\r\nreturn TRUE;\r\nelse\r\nreturn FALSE;\r\n}\r\nreturn FALSE;\r\n}\r\nxmpp_attr_t*\r\nxmpp_get_attr(xmpp_element_t *element, const gchar* attr_name)\r\n{\r\nxmpp_attr_t *result = (xmpp_attr_t *)g_hash_table_lookup(element->attrs, attr_name);\r\nif(!result)\r\n{\r\nresult = (xmpp_attr_t *)g_hash_table_find(element->attrs, attr_find_pred, (gpointer)attr_name);\r\n}\r\nif(result)\r\nresult->was_read = TRUE;\r\nreturn result;\r\n}\r\nstatic xmpp_attr_t*\r\nxmpp_get_attr_ext(xmpp_element_t *element, const gchar* attr_name, const gchar* ns_abbrev)\r\n{\r\ngchar* search_phrase;\r\nxmpp_attr_t *result;\r\nif(strcmp(ns_abbrev,"")==0)\r\nsearch_phrase = wmem_strdup(wmem_packet_scope(), attr_name);\r\nelse if(strcmp(attr_name, "xmlns") == 0)\r\nsearch_phrase = wmem_strdup_printf(wmem_packet_scope(), "%s:%s",attr_name, ns_abbrev);\r\nelse\r\nsearch_phrase = wmem_strdup_printf(wmem_packet_scope(), "%s:%s", ns_abbrev, attr_name);\r\nresult = (xmpp_attr_t *)g_hash_table_lookup(element->attrs, search_phrase);\r\nif(!result)\r\n{\r\nresult = (xmpp_attr_t *)g_hash_table_find(element->attrs, attr_find_pred, (gpointer)attr_name);\r\n}\r\nif(result)\r\nresult->was_read = TRUE;\r\nreturn result;\r\n}\r\ngchar*\r\nxmpp_element_to_string(tvbuff_t *tvb, xmpp_element_t *element)\r\n{\r\ngchar *buff = NULL;\r\nif(tvb_offset_exists(tvb, element->offset+element->length-1))\r\n{\r\nbuff = tvb_get_string_enc(wmem_packet_scope(), tvb, element->offset, element->length, ENC_ASCII);\r\n}\r\nreturn buff;\r\n}\r\ngchar*\r\nxmpp_attr_to_string(tvbuff_t *tvb, xmpp_attr_t *attr)\r\n{\r\ngchar *buff = NULL;\r\nif(tvb_offset_exists(tvb, attr->offset + attr->length-1))\r\n{\r\nbuff = tvb_get_string_enc(wmem_packet_scope(), tvb, attr->offset, attr->length, ENC_ASCII);\r\n}\r\nreturn buff;\r\n}\r\nstatic void\r\nchildren_foreach_hide_func(proto_node *node, gpointer data)\r\n{\r\nint *i = (int *)data;\r\nif((*i) == 0)\r\nPROTO_ITEM_SET_HIDDEN(node);\r\n(*i)++;\r\n}\r\nstatic void\r\nchildren_foreach_show_func(proto_node *node, gpointer data)\r\n{\r\nint *i = (int *)data;\r\nif((*i) == 0)\r\nPROTO_ITEM_SET_VISIBLE(node);\r\n(*i)++;\r\n}\r\nvoid\r\nxmpp_proto_tree_hide_first_child(proto_tree *tree)\r\n{\r\nint i = 0;\r\nproto_tree_children_foreach(tree, children_foreach_hide_func, &i);\r\n}\r\nvoid\r\nxmpp_proto_tree_show_first_child(proto_tree *tree)\r\n{\r\nint i = 0;\r\nproto_tree_children_foreach(tree, children_foreach_show_func, &i);\r\n}\r\ngchar*\r\nproto_item_get_text(proto_item *item)\r\n{\r\nfield_info *fi = NULL;\r\ngchar *result;\r\nif(item == NULL)\r\nreturn NULL;\r\nfi = PITEM_FINFO(item);\r\nif(fi==NULL)\r\nreturn NULL;\r\nif (fi->rep == NULL)\r\nreturn NULL;\r\nresult = wmem_strdup(wmem_packet_scope(), fi->rep->representation);\r\nreturn result;\r\n}\r\nvoid\r\nxmpp_display_attrs(proto_tree *tree, xmpp_element_t *element, packet_info *pinfo, tvbuff_t *tvb, const xmpp_attr_info *attrs, guint n)\r\n{\r\nproto_item *item = proto_tree_get_parent(tree);\r\nxmpp_attr_t *attr;\r\nguint i;\r\ngboolean short_list_started = FALSE;\r\nif(element->default_ns_abbrev)\r\nproto_item_append_text(item, "(%s)",element->default_ns_abbrev);\r\nproto_item_append_text(item," [");\r\nfor(i = 0; i < n && attrs!=NULL; i++)\r\n{\r\nattr = xmpp_get_attr(element, attrs[i].name);\r\nif(attr)\r\n{\r\nif(attrs[i].phf != NULL)\r\n{\r\nif(attr->name)\r\nproto_tree_add_string_format(tree, *attrs[i].phf, tvb, attr->offset, attr->length, attr->value,"%s: %s", attr->name, attr->value);\r\nelse\r\nproto_tree_add_string(tree, *attrs[i].phf, tvb, attr->offset, attr->length, attr->value);\r\n}\r\nelse\r\n{\r\nproto_tree_add_string_format(tree, hf_xmpp_attribute, tvb, attr->offset, attr->length, attr->value,\r\n"%s: %s", attr->name?attr->name:attrs[i].name, attr->value);\r\n}\r\nif(attrs[i].in_short_list)\r\n{\r\nif(short_list_started)\r\n{\r\nproto_item_append_text(item," ");\r\n}\r\nproto_item_append_text(item,"%s=\"%s\"",attr->name?attr->name:attrs[i].name, attr->value);\r\nshort_list_started = TRUE;\r\n}\r\n} else if(attrs[i].is_required)\r\n{\r\nexpert_add_info_format(pinfo, item, &ei_xmpp_required_attribute, "Required attribute \"%s\" doesn't appear in \"%s\".", attrs[i].name, element->name);\r\n}\r\nif(attrs[i].val_func)\r\n{\r\nif(attr)\r\nattrs[i].val_func(pinfo, item, attrs[i].name, attr->value, attrs[i].data);\r\nelse\r\nattrs[i].val_func(pinfo, item, attrs[i].name, NULL, attrs[i].data);\r\n}\r\n}\r\nproto_item_append_text(item,"]");\r\nxmpp_unknown_attrs(tree, tvb, pinfo, element, FALSE);\r\n}\r\nvoid\r\nxmpp_display_attrs_ext(proto_tree *tree, xmpp_element_t *element, packet_info *pinfo, tvbuff_t *tvb, const xmpp_attr_info_ext *attrs, guint n)\r\n{\r\nproto_item *item = proto_tree_get_parent(tree);\r\nxmpp_attr_t *attr;\r\nguint i;\r\ngboolean short_list_started = FALSE;\r\nGList *ns_abbrevs_head, *ns_abbrevs = g_hash_table_get_keys(element->namespaces);\r\nGList *ns_fullnames_head, *ns_fullnames = g_hash_table_get_values(element->namespaces);\r\nns_abbrevs_head = ns_abbrevs;\r\nns_fullnames_head = ns_fullnames;\r\nif(element->default_ns_abbrev)\r\nproto_item_append_text(item, "(%s)",element->default_ns_abbrev);\r\nproto_item_append_text(item," [");\r\nwhile(ns_abbrevs && ns_fullnames)\r\n{\r\nfor (i = 0; i < n && attrs != NULL; i++) {\r\nif(strcmp((const char *)(ns_fullnames->data), attrs[i].ns) == 0)\r\n{\r\nattr = xmpp_get_attr_ext(element, attrs[i].info.name, (const gchar *)(ns_abbrevs->data));\r\nif(!attr && element->default_ns_abbrev && strcmp((const char *)ns_abbrevs->data, element->default_ns_abbrev)==0)\r\nattr = xmpp_get_attr_ext(element, attrs[i].info.name, "");\r\nif (attr) {\r\nif (attrs[i].info.phf != NULL) {\r\nif (attr->name)\r\nproto_tree_add_string_format(tree, *attrs[i].info.phf, tvb, attr->offset, attr->length, attr->value, "%s: %s", attr->name, attr->value);\r\nelse\r\nproto_tree_add_string(tree, *attrs[i].info.phf, tvb, attr->offset, attr->length, attr->value);\r\n} else {\r\nproto_tree_add_string_format(tree, hf_xmpp_attribute, tvb, attr->offset, attr->length, attr->value,\r\n"%s: %s", attr->name ? attr->name : attrs[i].info.name, attr->value);\r\n}\r\nif (attrs[i].info.in_short_list) {\r\nif (short_list_started) {\r\nproto_item_append_text(item, " ");\r\n}\r\nproto_item_append_text(item, "%s=\"%s\"", attr->name ? attr->name : attrs[i].info.name, attr->value);\r\nshort_list_started = TRUE;\r\n}\r\n} else if (attrs[i].info.is_required) {\r\nexpert_add_info_format(pinfo, item, &ei_xmpp_required_attribute, "Required attribute \"%s\" doesn't appear in \"%s\".", attrs[i].info.name, element->name);\r\n}\r\nif (attrs[i].info.val_func) {\r\nif (attr)\r\nattrs[i].info.val_func(pinfo, item, attrs[i].info.name, attr->value, attrs[i].info.data);\r\nelse\r\nattrs[i].info.val_func(pinfo, item, attrs[i].info.name, NULL, attrs[i].info.data);\r\n}\r\n}\r\n}\r\nns_abbrevs = ns_abbrevs->next;\r\nns_fullnames = ns_fullnames->next;\r\n}\r\nproto_item_append_text(item,"]");\r\nxmpp_unknown_attrs(tree, tvb, pinfo, element, FALSE);\r\ng_list_free(ns_abbrevs_head);\r\ng_list_free(ns_fullnames_head);\r\n}\r\ngpointer\r\nxmpp_name_attr_struct(const gchar *name, const gchar *attr_name, const gchar *attr_value)\r\n{\r\nname_attr_t *result;\r\nresult = wmem_new(wmem_packet_scope(), name_attr_t);\r\nresult->name = name;\r\nresult->attr_name = attr_name;\r\nresult->attr_value = attr_value;\r\nreturn result;\r\n}\r\nvoid\r\nxmpp_display_elems(proto_tree *tree, xmpp_element_t *parent, packet_info *pinfo, tvbuff_t *tvb, xmpp_elem_info *elems, guint n)\r\n{\r\nguint i;\r\nfor(i = 0; i < n && elems!=NULL; i++)\r\n{\r\nxmpp_element_t *elem = NULL;\r\nif(elems[i].type == NAME_AND_ATTR)\r\n{\r\ngboolean loop = TRUE;\r\nconst name_attr_t *a = (const name_attr_t *)(elems[i].data);\r\nwhile(loop && (elem = xmpp_steal_element_by_name_and_attr(parent, a->name, a->attr_name, a->attr_value))!=NULL)\r\n{\r\nelems[i].elem_func(tree, tvb, pinfo, elem);\r\nif(elems[i].occurrence == ONE)\r\nloop = FALSE;\r\n}\r\n} else if(elems[i].type == NAME)\r\n{\r\ngboolean loop = TRUE;\r\nconst gchar *name = (const gchar *)(elems[i].data);\r\nwhile(loop && (elem = xmpp_steal_element_by_name(parent, name))!=NULL)\r\n{\r\nelems[i].elem_func(tree, tvb, pinfo, elem);\r\nif(elems[i].occurrence == ONE)\r\nloop = FALSE;\r\n}\r\n}\r\nelse if(elems[i].type == ATTR)\r\n{\r\ngboolean loop = TRUE;\r\nconst name_attr_t *attr = (const name_attr_t *)(elems[i].data);\r\nwhile(loop && (elem = xmpp_steal_element_by_attr(parent, attr->attr_name, attr->attr_value))!=NULL)\r\n{\r\nelems[i].elem_func(tree, tvb, pinfo, elem);\r\nif(elems[i].occurrence == ONE)\r\nloop = FALSE;\r\n}\r\n} else if(elems[i].type == NAMES)\r\n{\r\ngboolean loop = TRUE;\r\nconst xmpp_array_t *names = (const xmpp_array_t *)(elems[i].data);\r\nwhile(loop && (elem = xmpp_steal_element_by_names(parent, (const gchar**)names->data, names->length))!=NULL)\r\n{\r\nelems[i].elem_func(tree, tvb, pinfo, elem);\r\nif(elems[i].occurrence == ONE)\r\nloop = FALSE;\r\n}\r\n}\r\n}\r\nxmpp_unknown(tree, tvb, pinfo, parent);\r\n}\r\nvoid\r\nxmpp_val_enum_list(packet_info *pinfo, proto_item *item, const gchar *name, const gchar *value, gconstpointer data)\r\n{\r\nconst xmpp_array_t *enums_array = (const xmpp_array_t *)data;\r\ngint i;\r\ngboolean value_in_enums = FALSE;\r\ngchar **enums = (char**)enums_array->data;\r\nif (value != NULL) {\r\nfor (i = 0; i < enums_array->length; i++) {\r\nif (strcmp(value, enums[i]) == 0) {\r\nvalue_in_enums = TRUE;\r\nbreak;\r\n}\r\n}\r\nif (!value_in_enums) {\r\nexpert_add_info_format(pinfo, item, &ei_xmpp_field_unexpected_value, "Field \"%s\" has unexpected value \"%s\"", name, value);\r\n}\r\n}\r\n}\r\nvoid\r\nxmpp_change_elem_to_attrib(const gchar *elem_name, const gchar *attr_name, xmpp_element_t *parent, xmpp_attr_t* (*transform_func)(xmpp_element_t *element))\r\n{\r\nxmpp_element_t *element = NULL;\r\nxmpp_attr_t *fake_attr = NULL;\r\nelement = xmpp_steal_element_by_name(parent, elem_name);\r\nif(element)\r\nfake_attr = transform_func(element);\r\nif(fake_attr)\r\ng_hash_table_insert(parent->attrs, (gpointer)attr_name, fake_attr);\r\n}\r\nxmpp_attr_t*\r\nxmpp_transform_func_cdata(xmpp_element_t *elem)\r\n{\r\nxmpp_attr_t *result = xmpp_ep_init_attr_t(elem->data?elem->data->value:"", elem->offset, elem->length);\r\nreturn result;\r\n}\r\nstatic void\r\nxmpp_copy_hash_table_func(gpointer key, gpointer value, gpointer user_data)\r\n{\r\nGHashTable *dst = (GHashTable *)user_data;\r\ng_hash_table_insert(dst, key, value);\r\n}\r\nvoid xmpp_copy_hash_table(GHashTable *src, GHashTable *dst)\r\n{\r\ng_hash_table_foreach(src, xmpp_copy_hash_table_func, dst);\r\n}
