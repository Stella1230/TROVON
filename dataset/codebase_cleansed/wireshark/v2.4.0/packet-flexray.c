static void flexray_prompt(packet_info *pinfo _U_, gchar* result)\r\n{\r\ng_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, "Next level protocol as");\r\n}\r\nstatic gpointer flexray_value(packet_info *pinfo _U_)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\ndissect_flexray(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *flexray_tree, *type_info_tree, *error_flags_tree;\r\nproto_tree *flexray_frame_tree = NULL;\r\ntvbuff_t* next_tvb;\r\ngint frame_length;\r\ngint flexray_frame_length;\r\ngint flexray_current_payload_length;\r\ngint flexray_reported_payload_length;\r\nguint8 frame_type;\r\nguint8 symbol_length;\r\nguint8 error_flag;\r\nguint8 sfi;\r\nguint8 stfi;\r\nguint8 nfi;\r\ngboolean call_subdissector;\r\nflexray_identifier flexray_id;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "FLEXRAY");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nframe_length = tvb_captured_length(tvb);\r\nframe_type = tvb_get_guint8(tvb, 0) & 0x7f;\r\nflexray_id.ch = tvb_get_guint8(tvb, 0) & 0x80;\r\ncall_subdissector = TRUE;\r\nti = proto_tree_add_item(tree, proto_flexray, tvb, 0, -1, ENC_NA);\r\nflexray_tree = proto_item_add_subtree(ti, ett_flexray);\r\nti = proto_tree_add_item(flexray_tree, hf_flexray_measurement_header_field, tvb, 0, 1, ENC_BIG_ENDIAN);\r\ntype_info_tree = proto_item_add_subtree(ti, ett_flexray_measurement_header);\r\nproto_tree_add_item(type_info_tree, hf_flexray_ch, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(type_info_tree, hf_flexray_ti, tvb, 0, 1, ENC_BIG_ENDIAN);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s:", val_to_str(frame_type, flexray_type_names, "Unknown (0x%02x)"));\r\nif (frame_type == FLEXRAY_FRAME) {\r\nflexray_frame_length = frame_length - 2;\r\nerror_flag = tvb_get_guint8(tvb, 1) & 0x1f;\r\nti = proto_tree_add_bitmask(flexray_tree, tvb, 1, hf_flexray_error_flags_field, ett_flexray_error_flags, error_fields, ENC_BIG_ENDIAN);\r\nerror_flags_tree = proto_item_add_subtree(ti, ett_flexray_error_flags);\r\nif (error_flag) {\r\nexpert_add_info(pinfo, error_flags_tree, &ei_flexray_error_flag);\r\ncall_subdissector = FALSE;\r\n}\r\nif (flexray_frame_length < FLEXRAY_HEADER_LENGTH) {\r\nexpert_add_info(pinfo, flexray_tree, &ei_flexray_frame_header);\r\ncall_subdissector = FALSE;\r\n}\r\nif (flexray_frame_length > 0) {\r\nsfi = tvb_get_guint8(tvb, 2) & 0x10;\r\nstfi = tvb_get_guint8(tvb, 2) & 0x08;\r\nti = proto_tree_add_bitmask(flexray_tree, tvb, 2, hf_flexray_frame_field, ett_flexray_frame, frame_fields, ENC_BIG_ENDIAN);\r\nflexray_frame_tree = proto_item_add_subtree(ti, ett_flexray_frame);\r\nproto_tree_add_item(flexray_frame_tree, hf_flexray_nfi, tvb, 2, 1, ENC_BIG_ENDIAN);\r\nif (stfi) {\r\nif (!sfi) {\r\nexpert_add_info(pinfo, flexray_frame_tree, &ei_flexray_stfi_flag);\r\ncall_subdissector = FALSE;\r\n}\r\n}\r\n}\r\nif (flexray_frame_length > 1) {\r\nflexray_id.id = tvb_get_ntohs(tvb, 2) & 0x07ff;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " ID %4d", flexray_id.id);\r\nproto_tree_add_item(flexray_frame_tree, hf_flexray_fid, tvb, 2, 2, ENC_BIG_ENDIAN);\r\nif (flexray_id.id == 0) {\r\ncall_subdissector = FALSE;\r\n}\r\n}\r\nif (flexray_frame_length > 2) {\r\nproto_tree_add_item(flexray_frame_tree, hf_flexray_pl, tvb, 4, 1, ENC_BIG_ENDIAN);\r\n}\r\nif (flexray_frame_length > 4) {\r\nflexray_reported_payload_length = tvb_get_guint8(tvb, 4) & 0xfe;\r\nflexray_reported_payload_length = 2 * (flexray_reported_payload_length >> 1);\r\nflexray_current_payload_length = flexray_frame_length - FLEXRAY_HEADER_LENGTH;\r\nflexray_id.cc = tvb_get_guint8(tvb, 6) & 0x3f;\r\nnfi = tvb_get_guint8(tvb, 2) & 0x20;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " CC %2d", flexray_id.cc);\r\nproto_tree_add_item(flexray_frame_tree, hf_flexray_hcrc, tvb, 4, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flexray_frame_tree, hf_flexray_cc, tvb, 6, 1, ENC_BIG_ENDIAN);\r\nif (nfi) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " %s", tvb_bytes_to_str_punct(wmem_packet_scope(), tvb, 7, flexray_current_payload_length, ' '));\r\nif (flexray_current_payload_length != flexray_reported_payload_length) {\r\nexpert_add_info(pinfo, flexray_frame_tree, &ei_flexray_frame_payload);\r\ncall_subdissector = FALSE;\r\n}\r\n}\r\nelse {\r\ncall_subdissector = FALSE;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " NF");\r\nif (flexray_current_payload_length != flexray_reported_payload_length && flexray_current_payload_length != 0) {\r\nexpert_add_info(pinfo, flexray_frame_tree, &ei_flexray_frame_payload);\r\n}\r\n}\r\nnext_tvb = tvb_new_subset_length(tvb, 7, flexray_current_payload_length);\r\nif (call_subdissector) {\r\nif (!dissector_try_uint_new(subdissector_table, 0, next_tvb, pinfo, tree, FALSE, &flexray_id))\r\n{\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\n}\r\nelse {\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\n}\r\n}\r\nif ((frame_type & 0x07ff) == FLEXRAY_SYMBOL) {\r\nflexray_frame_length = frame_length - 1;\r\nexpert_add_info(pinfo, flexray_tree, &ei_flexray_symbol_frame);\r\nif (flexray_frame_length > 0) {\r\nsymbol_length = tvb_get_guint8(tvb, 1) & 0x7f;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " SL %3d", symbol_length);\r\nproto_tree_add_item(flexray_tree, hf_flexray_sl, tvb, 1, 1, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nexpert_add_info(pinfo, flexray_tree, &ei_flexray_symbol_header);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_flexray(void)\r\n{\r\nexpert_module_t *expert_flexray;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_flexray_measurement_header_field,\r\n{ "Measurement Header", "flexray.mhf",\r\nFT_UINT8, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_ti,\r\n{ "Type Index", "flexray.ti",\r\nFT_UINT8, BASE_HEX,\r\nVALS(flexray_type_names), 0x7f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_ch,\r\n{ "Channel", "flexray.ch",\r\nFT_BOOLEAN, 8,\r\nTFS(&flexray_channel), 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_error_flags_field,\r\n{ "Error Flags", "flexray.eff",\r\nFT_UINT8, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_fcrc_err,\r\n{ "Frame CRC error", "flexray.fcrc_err",\r\nFT_BOOLEAN, 8,\r\nNULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_hcrc_err,\r\n{ "Header CRC error", "flexray.hcrc_err",\r\nFT_BOOLEAN, 8,\r\nNULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_fes_err,\r\n{ "Frame End Sequence error", "flexray.fes_err",\r\nFT_BOOLEAN, 8,\r\nNULL, 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_cod_err,\r\n{ "Coding error", "flexray.cod_err",\r\nFT_BOOLEAN, 8,\r\nNULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_tss_viol,\r\n{ "TSS violation", "flexray.tss_viol",\r\nFT_BOOLEAN, 8,\r\nNULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_frame_field,\r\n{ "FlexRay Frame", "flexray.ff",\r\nFT_UINT8, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_ppi,\r\n{ "Payload preamble Indicator", "flexray.ppi",\r\nFT_BOOLEAN, 8,\r\nNULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_nfi,\r\n{ "Null Frame", "flexray.nfi",\r\nFT_BOOLEAN, 8,\r\nTFS(&flexray_nfi), 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_sfi,\r\n{ "Sync Frame Indicator", "flexray.sfi",\r\nFT_BOOLEAN, 8,\r\nNULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_stfi,\r\n{ "Startup Frame Indicator", "flexray.stfi",\r\nFT_BOOLEAN, 8,\r\nNULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_fid,\r\n{ "Frame ID", "flexray.fid",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0x07ff,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_pl,\r\n{ "Payload length", "flexray.pl",\r\nFT_UINT8, BASE_DEC,\r\nNULL, 0xfe,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_hcrc,\r\n{ "Header CRC", "flexray.hcrc",\r\nFT_UINT24, BASE_DEC,\r\nNULL, 0x01ffc0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_cc,\r\n{ "Cycle Counter", "flexray.cc",\r\nFT_UINT8, BASE_DEC,\r\nNULL, 0x3f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flexray_sl,\r\n{ "Symbol length", "flexray.sl",\r\nFT_UINT8, BASE_DEC,\r\nNULL, 0x7f,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_flexray,\r\n&ett_flexray_measurement_header,\r\n&ett_flexray_error_flags,\r\n&ett_flexray_frame\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_flexray_frame_header,\r\n{ "flexray.frame_header", PI_MALFORMED, PI_ERROR,\r\n"Frame Header is malformed", EXPFILL }\r\n},\r\n{ &ei_flexray_frame_payload,\r\n{ "flexray.malformed_frame_payload", PI_MALFORMED, PI_ERROR,\r\n"Frame Payload is malformed", EXPFILL }\r\n},\r\n{ &ei_flexray_symbol_header,\r\n{ "flexray.malformed_symbol_frame", PI_MALFORMED, PI_ERROR,\r\n"Symbol Frame is malformed", EXPFILL }\r\n},\r\n{ &ei_flexray_symbol_frame,\r\n{ "flexray.symbol_frame", PI_SEQUENCE, PI_CHAT,\r\n"Packet is a Symbol Frame", EXPFILL }\r\n},\r\n{ &ei_flexray_error_flag,\r\n{ "flexray.error_flag", PI_PROTOCOL, PI_WARN,\r\n"Error Flag is set", EXPFILL }\r\n},\r\n{ &ei_flexray_stfi_flag,\r\n{ "flexray.stfi_flag", PI_PROTOCOL, PI_WARN,\r\n"A startup frame must always be a sync frame", EXPFILL }\r\n}\r\n};\r\nstatic build_valid_func flexray_da_build_value[1] = { flexray_value };\r\nstatic decode_as_value_t flexray_da_values = { flexray_prompt, 1, flexray_da_build_value };\r\nstatic decode_as_t flexray_da = { "flexray", "Network", "flexray.subdissector", 1, 0, &flexray_da_values, NULL, NULL,\r\ndecode_as_default_populate_list, decode_as_default_reset, decode_as_default_change, NULL };\r\nproto_flexray = proto_register_protocol(\r\n"FlexRay Protocol",\r\n"FLEXRAY",\r\n"flexray"\r\n);\r\nproto_register_field_array(proto_flexray, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_flexray = expert_register_protocol(proto_flexray);\r\nexpert_register_field_array(expert_flexray, ei, array_length(ei));\r\nregister_dissector("flexray", dissect_flexray, proto_flexray);\r\nregister_decode_as(&flexray_da);\r\nsubdissector_table = register_dissector_table("flexray.subdissector",\r\n"FLEXRAY next level dissector", proto_flexray, FT_UINT32, BASE_HEX);\r\n}\r\nvoid\r\nproto_reg_handoff_flexray(void)\r\n{\r\nstatic dissector_handle_t flexray_handle;\r\nflexray_handle = create_dissector_handle( dissect_flexray, proto_flexray );\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_FLEXRAY, flexray_handle);\r\n}
