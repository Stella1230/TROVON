static guint8\r\nevrc_frame_type_to_octs(guint8 frame_type)\r\n{\r\nswitch (frame_type)\r\n{\r\ndefault:\r\nbreak;\r\ncase 1:\r\nreturn(2);\r\ncase 2:\r\nreturn(5);\r\ncase 3:\r\nreturn(10);\r\ncase 4:\r\nreturn(22);\r\n}\r\nreturn(0);\r\n}\r\nstatic void\r\ndissect_evrc_aux(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, evrc_variant_t evrc_variant)\r\n{\r\nguint8 oct;\r\nguint8 frame_count;\r\nguint8 i;\r\nguint32 offset, saved_offset;\r\ngboolean further_entries;\r\nguint32 len;\r\nproto_item *item = NULL;\r\nproto_tree *evrc_tree = NULL;\r\nproto_tree *toc_tree = NULL;\r\nint hf_mode_request;\r\nint hf_toc_frame_type_high;\r\nint hf_toc_frame_type_low;\r\nguint8 speech_data_len[0x20];\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "EVRC");\r\nif (!tree) return;\r\noffset = 0;\r\nmemset(speech_data_len, 0, sizeof(speech_data_len));\r\nlen = tvb_reported_length(tvb);\r\nitem = proto_tree_add_item(tree, proto_evrc, tvb, 0, len, ENC_NA);\r\nevrc_tree = proto_item_add_subtree(item, ett_evrc);\r\nif (evrc_variant == EVRC_VARIANT_EVRC_LEGACY)\r\n{\r\nproto_tree_add_item(evrc_tree, hf_evrc_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(evrc_tree, hf_evrc_interleave_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(evrc_tree, hf_evrc_interleave_index, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nframe_count = 0;\r\nfurther_entries = TRUE;\r\nwhile (further_entries && (frame_count < sizeof(speech_data_len)) &&\r\n((len - offset) > 0))\r\n{\r\ntoc_tree =\r\nproto_tree_add_subtree_format(evrc_tree, tvb, offset, 1, ett_toc, NULL, "ToC [%u]", frame_count+1);\r\nproto_tree_add_item(toc_tree, hf_evrc_legacy_toc_fe_ind, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(toc_tree, hf_evrc_legacy_toc_reduc_rate, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(toc_tree, hf_evrc_legacy_toc_frame_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noct = tvb_get_guint8(tvb, offset);\r\nfurther_entries = (oct & 0x80) ? TRUE : FALSE;\r\nspeech_data_len[frame_count] = evrc_frame_type_to_octs((guint8)(oct & 0x7f));\r\nframe_count++;\r\noffset++;\r\n}\r\n}\r\nelse\r\n{\r\nswitch (evrc_variant)\r\n{\r\ndefault:\r\nproto_tree_add_expert(evrc_tree, pinfo, &ei_evrc_unknown_variant, tvb, offset, len);\r\nreturn;\r\ncase EVRC_VARIANT_EVRC:\r\nhf_mode_request = hf_evrc_mode_request;\r\nhf_toc_frame_type_high = hf_evrc_toc_frame_type_high;\r\nhf_toc_frame_type_low = hf_evrc_toc_frame_type_low;\r\nproto_tree_add_item(evrc_tree, hf_evrc_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase EVRC_VARIANT_EVRC_B:\r\nhf_mode_request = hf_evrc_b_mode_request;\r\nhf_toc_frame_type_high = hf_evrc_b_toc_frame_type_high;\r\nhf_toc_frame_type_low = hf_evrc_b_toc_frame_type_low;\r\nproto_tree_add_item(evrc_tree, hf_evrc_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase EVRC_VARIANT_EVRC_WB:\r\nhf_mode_request = hf_evrc_wb_mode_request;\r\nhf_toc_frame_type_high = hf_evrc_b_toc_frame_type_high;\r\nhf_toc_frame_type_low = hf_evrc_b_toc_frame_type_low;\r\nproto_tree_add_item(evrc_tree, hf_evrc_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase EVRC_VARIANT_EVRC_NW:\r\nhf_mode_request = hf_evrc_nw_mode_request;\r\nhf_toc_frame_type_high = hf_evrc_b_toc_frame_type_high;\r\nhf_toc_frame_type_low = hf_evrc_b_toc_frame_type_low;\r\nproto_tree_add_item(evrc_tree, hf_evrc_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase EVRC_VARIANT_EVRC_NW2k:\r\nhf_mode_request = hf_evrc_nw2k_mode_request;\r\nhf_toc_frame_type_high = hf_evrc_b_toc_frame_type_high;\r\nhf_toc_frame_type_low = hf_evrc_b_toc_frame_type_low;\r\nproto_tree_add_item(evrc_tree, hf_evrc_reserved_2k, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(evrc_tree, hf_evrc_enc_capability_2k, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\nproto_tree_add_item(evrc_tree, hf_evrc_interleave_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(evrc_tree, hf_evrc_interleave_index, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(evrc_tree, hf_mode_request, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(evrc_tree, hf_evrc_frame_count, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nframe_count = (tvb_get_guint8(tvb, offset) & 0x1f) + 1;\r\noffset++;\r\nsaved_offset = offset;\r\ntoc_tree =\r\nproto_tree_add_subtree_format(evrc_tree, tvb, offset, -1, ett_toc, &item, "ToC - %u frame%s",\r\nframe_count, plurality(frame_count, "", "s"));\r\ni = 0;\r\nwhile ((i < frame_count) &&\r\n((len - offset) > 0))\r\n{\r\noct = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(toc_tree, hf_toc_frame_type_high, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nspeech_data_len[i] = evrc_frame_type_to_octs((guint8)((oct & 0xf0) >> 4));\r\ni++;\r\nif (i < frame_count)\r\n{\r\nproto_tree_add_item(toc_tree, hf_toc_frame_type_low, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nspeech_data_len[i] = evrc_frame_type_to_octs((guint8)(oct & 0x0f));\r\ni++;\r\n}\r\noffset++;\r\n}\r\nif (frame_count & 0x01)\r\n{\r\nproto_tree_add_item(toc_tree, hf_evrc_padding, tvb, offset-1, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_item_set_len(item, offset - saved_offset);\r\n}\r\ni = 0;\r\nwhile ((i < frame_count) &&\r\n((len - offset) >= speech_data_len[i]))\r\n{\r\nproto_tree_add_bytes_format(evrc_tree, hf_evrc_speech_data, tvb, offset, speech_data_len[i], NULL, "Speech Data [%u]", i+1);\r\noffset += speech_data_len[i];\r\ni++;\r\n}\r\n}\r\nstatic int\r\ndissect_evrc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ndissect_evrc_aux(tvb, pinfo, tree, EVRC_VARIANT_EVRC);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_evrcb(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ndissect_evrc_aux(tvb, pinfo, tree, EVRC_VARIANT_EVRC_B);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_evrcwb(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ndissect_evrc_aux(tvb, pinfo, tree, EVRC_VARIANT_EVRC_WB);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_evrcnw(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ndissect_evrc_aux(tvb, pinfo, tree, EVRC_VARIANT_EVRC_NW);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_evrcnw2k(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ndissect_evrc_aux(tvb, pinfo, tree, EVRC_VARIANT_EVRC_NW2k);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_evrc_legacy(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ndissect_evrc_aux(tvb, pinfo, tree, EVRC_VARIANT_EVRC_LEGACY);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_evrc(void)\r\n{\r\nmodule_t *evrc_module;\r\nstatic hf_register_info hf[] =\r\n{\r\n{ &hf_evrc_reserved,\r\n{ "Reserved", "evrc.reserved",\r\nFT_UINT8, BASE_HEX, NULL, 0xc0,\r\n"Reserved bits", HFILL }\r\n},\r\n{ &hf_evrc_reserved_2k,\r\n{ "Reserved", "evrc.reserved",\r\nFT_UINT8, BASE_HEX, NULL, 0x80,\r\n"Reserved bits", HFILL }\r\n},\r\n{ &hf_evrc_enc_capability_2k,\r\n{ "Encoding Capability", "evrc.enc_capability",\r\nFT_BOOLEAN, 8, TFS(&evrc_nw2k_enc_capability_bit_vals), 0x40,\r\n"Encoding Capability Identification", HFILL }\r\n},\r\n{ &hf_evrc_interleave_length,\r\n{ "Interleave Length", "evrc.interleave_len",\r\nFT_UINT8, BASE_DEC, NULL, 0x38,\r\n"Interleave length bits", HFILL }\r\n},\r\n{ &hf_evrc_interleave_index,\r\n{ "Interleave Index", "evrc.interleave_idx",\r\nFT_UINT8, BASE_DEC, NULL, 0x07,\r\n"Interleave index bits", HFILL }\r\n},\r\n{ &hf_evrc_mode_request,\r\n{ "Mode Request", "evrc.mode_request",\r\nFT_UINT8, BASE_DEC, VALS(evrc_mode_request_vals), 0xe0,\r\n"Mode Request bits", HFILL }\r\n},\r\n{ &hf_evrc_b_mode_request,\r\n{ "Mode Request", "evrc.b.mode_request",\r\nFT_UINT8, BASE_DEC, VALS(evrc_b_mode_request_vals), 0xe0,\r\n"Mode Request bits", HFILL }\r\n},\r\n{ &hf_evrc_wb_mode_request,\r\n{ "Mode Request", "evrc.wb.mode_request",\r\nFT_UINT8, BASE_DEC, VALS(evrc_wb_mode_request_vals), 0xe0,\r\n"Mode Request bits", HFILL }\r\n},\r\n{ &hf_evrc_nw_mode_request,\r\n{ "Mode Request", "evrc.nw.mode_request",\r\nFT_UINT8, BASE_DEC, VALS(evrc_nw_mode_request_vals), 0xe0,\r\n"Mode Request bits", HFILL }\r\n},\r\n{ &hf_evrc_nw2k_mode_request,\r\n{ "Mode Request", "evrc.nw2k.mode_request",\r\nFT_UINT8, BASE_DEC, VALS(evrc_nw2k_mode_request_vals), 0xe0,\r\n"Mode Request bits", HFILL }\r\n},\r\n{ &hf_evrc_frame_count,\r\n{ "Frame Count (0 means 1 frame)", "evrc.frame_count",\r\nFT_UINT8, BASE_DEC, NULL, 0x1f,\r\n"Frame Count bits, a value of 0 means 1 frame", HFILL }\r\n},\r\n{ &hf_evrc_toc_frame_type_high,\r\n{ "ToC Frame Type", "evrc.toc.frame_type_hi",\r\nFT_UINT8, BASE_DEC, VALS(evrc_frame_type_vals), 0xf0,\r\n"ToC Frame Type bits", HFILL }\r\n},\r\n{ &hf_evrc_toc_frame_type_low,\r\n{ "ToC Frame Type", "evrc.toc.frame_type_lo",\r\nFT_UINT8, BASE_DEC, VALS(evrc_frame_type_vals), 0x0f,\r\n"ToC Frame Type bits", HFILL }\r\n},\r\n{ &hf_evrc_b_toc_frame_type_high,\r\n{ "ToC Frame Type", "evrc.b.toc.frame_type_hi",\r\nFT_UINT8, BASE_DEC, VALS(evrc_b_frame_type_vals), 0xf0,\r\n"ToC Frame Type bits", HFILL }\r\n},\r\n{ &hf_evrc_b_toc_frame_type_low,\r\n{ "ToC Frame Type", "evrc.b.toc.frame_type_lo",\r\nFT_UINT8, BASE_DEC, VALS(evrc_b_frame_type_vals), 0x0f,\r\n"ToC Frame Type bits", HFILL }\r\n},\r\n{ &hf_evrc_padding,\r\n{ "Padding", "evrc.padding",\r\nFT_UINT8, BASE_DEC, NULL, 0x0f,\r\n"Padding bits", HFILL }\r\n},\r\n{ &hf_evrc_speech_data,\r\n{ "Speech data", "evrc.speech_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_evrc_legacy_toc_fe_ind,\r\n{ "ToC Further Entries Indicator", "evrc.legacy.toc.further_entries_ind",\r\nFT_BOOLEAN, 8, TFS(&toc_further_entries_bit_vals), 0x80,\r\n"ToC Further Entries Indicator bit", HFILL }\r\n},\r\n{ &hf_evrc_legacy_toc_reduc_rate,\r\n{ "ToC Reduced Rate", "evrc.legacy.toc.reduced_rate",\r\nFT_UINT8, BASE_DEC, NULL, 0x40,\r\n"ToC Reduced Rate bits", HFILL }\r\n},\r\n{ &hf_evrc_legacy_toc_frame_type,\r\n{ "ToC Frame Type", "evrc.legacy.toc.frame_type",\r\nFT_UINT8, BASE_DEC, VALS(evrc_legacy_frame_type_vals), 0x3f,\r\n"ToC Frame Type bits", HFILL }\r\n}\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_evrc_unknown_variant,\r\n{ "evrc.unknown_variant", PI_UNDECODED, PI_WARN,\r\n"Variant Unknown/Unsupported - dissector bug/later version spec (report to wireshark.org)",\r\nEXPFILL }\r\n}\r\n};\r\nexpert_module_t *expert_evrc;\r\nstatic gint *ett[] =\r\n{\r\n&ett_evrc,\r\n&ett_toc\r\n};\r\nproto_evrc =\r\nproto_register_protocol("Enhanced Variable Rate Codec", "EVRC", "evrc");\r\nproto_register_field_array(proto_evrc, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_evrc =\r\nexpert_register_protocol(proto_evrc);\r\nexpert_register_field_array(expert_evrc, ei, array_length(ei));\r\nevrc_module = prefs_register_protocol(proto_evrc, proto_reg_handoff_evrc);\r\nprefs_register_bool_preference(evrc_module,\r\n"legacy_pt_60",\r\n"Add dissector for static payload type 60 as legacy EVRC (non-RFC3558)",\r\n"Whether the EVRC dissector should process payload type 60 as legacy EVRC packets",\r\n&legacy_pt_60);\r\n}\r\nvoid\r\nproto_reg_handoff_evrc(void)\r\n{\r\nstatic gboolean evrc_prefs_initialized = FALSE;\r\nstatic dissector_handle_t evrc_legacy_handle;\r\nif (!evrc_prefs_initialized)\r\n{\r\ndissector_handle_t evrc_handle;\r\ndissector_handle_t evrcb_handle;\r\ndissector_handle_t evrcwb_handle;\r\ndissector_handle_t evrcnw_handle;\r\ndissector_handle_t evrcnw2k_handle;\r\nevrc_handle = create_dissector_handle(dissect_evrc, proto_evrc);\r\nevrcb_handle = create_dissector_handle(dissect_evrcb, proto_evrc);\r\nevrcwb_handle = create_dissector_handle(dissect_evrcwb, proto_evrc);\r\nevrcnw_handle = create_dissector_handle(dissect_evrcnw, proto_evrc);\r\nevrcnw2k_handle = create_dissector_handle(dissect_evrcnw2k, proto_evrc);\r\nevrc_legacy_handle = create_dissector_handle(dissect_evrc_legacy, proto_evrc);\r\ndissector_add_string("rtp_dyn_payload_type", "EVRC", evrc_handle);\r\ndissector_add_string("rtp_dyn_payload_type", "EVRCB", evrcb_handle);\r\ndissector_add_string("rtp_dyn_payload_type", "EVRCWB", evrcwb_handle);\r\ndissector_add_string("rtp_dyn_payload_type", "EVRCNW", evrcnw_handle);\r\ndissector_add_string("rtp_dyn_payload_type", "EVRCNW2K", evrcnw2k_handle);\r\nevrc_prefs_initialized = TRUE;\r\n}\r\nelse\r\n{\r\ndissector_delete_uint("rtp.pt", 60, evrc_legacy_handle);\r\n}\r\nif (legacy_pt_60)\r\n{\r\ndissector_add_uint("rtp.pt", 60, evrc_legacy_handle);\r\n}\r\n}
