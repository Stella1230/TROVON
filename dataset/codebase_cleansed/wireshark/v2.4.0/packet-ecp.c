static void\r\nvdp_add_vidstr(tvbuff_t *tvb, proto_tree *tree, guint32 offset)\r\n{\r\nif (tree) {\r\nproto_tree_add_item(tree, hf_vdp_vidstr_ps, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_vdp_vidstr_pcp, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_vdp_vidstr_vid, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_vdp_tlv_assoc(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, proto_item* length_item _U_, int offset, guint8 tlvtype, int tlvlen _U_)\r\n{\r\nproto_tree *vdp_tlv_assoc_tree;\r\nproto_item *associate_item;\r\nguint8 reason, filter_format;\r\nint start_offset = offset;\r\nif (tlvtype == VDP_TLV_ASSOC)\r\nvdp_tlv_assoc_tree = proto_tree_add_subtree(tree, tvb, offset, 0,\r\nett_vdp_tlv_assoc, &associate_item, "VDP Associate");\r\nelse\r\nvdp_tlv_assoc_tree = proto_tree_add_subtree(tree, tvb, offset, 0,\r\nett_vdp_tlv_assoc, &associate_item, "VDP DeAssociate");\r\nreason = tvb_get_guint8(tvb, offset);\r\nif (reason & 0x40) {\r\nstatic const int * response_flags[] = {\r\n&hf_vdp_tlv_assoc_flag_hard_error,\r\n&hf_vdp_tlv_assoc_flag_keep,\r\n&hf_vdp_tlv_assoc_flag_req_rsp,\r\nNULL\r\n};\r\nproto_tree_add_item(vdp_tlv_assoc_tree, hf_vdp_tlv_assoc_error, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(vdp_tlv_assoc_tree, tvb, offset, hf_vdp_tlv_assoc_response_flags, ett_vdp_assoc_flags, response_flags, ENC_BIG_ENDIAN);\r\n} else {\r\nstatic const int * request_flags[] = {\r\n&hf_vdp_tlv_assoc_flag_mbit,\r\n&hf_vdp_tlv_assoc_flag_sbit,\r\n&hf_vdp_tlv_assoc_flag_req_rsp,\r\nNULL\r\n};\r\nproto_tree_add_item(vdp_tlv_assoc_tree, hf_vdp_tlv_assoc_reason, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(vdp_tlv_assoc_tree, tvb, offset, hf_vdp_tlv_assoc_request_flags, ett_vdp_assoc_flags, request_flags, ENC_BIG_ENDIAN);\r\n}\r\noffset++;\r\nproto_tree_add_item(vdp_tlv_assoc_tree, hf_vdp_vsitypeid, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\nproto_tree_add_item(vdp_tlv_assoc_tree, hf_vdp_vsiversion, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(vdp_tlv_assoc_tree, hf_vdp_vsiid_format, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(vdp_tlv_assoc_tree, hf_vdp_vsiid, tvb, offset, 16, ENC_NA);\r\noffset += 16;\r\nproto_tree_add_item(vdp_tlv_assoc_tree, hf_vdp_filter_format, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nfilter_format = tvb_get_guint8(tvb, offset);\r\noffset++;\r\nswitch (filter_format) {\r\ncase VDP_FILTER_VID:\r\nvdp_add_vidstr(tvb, vdp_tlv_assoc_tree, offset);\r\noffset += 2;\r\nbreak;\r\ncase VDP_FILTER_MACVID:\r\nproto_tree_add_item(vdp_tlv_assoc_tree, hf_vdp_assoc_mac_id, tvb, offset, 6, ENC_NA);\r\noffset += 6;\r\nvdp_add_vidstr(tvb, vdp_tlv_assoc_tree, offset);\r\noffset += 2;\r\nbreak;\r\n}\r\nproto_item_set_len(associate_item, offset-start_offset);\r\n}\r\nstatic void\r\ndissect_vdp_tlv_mgrid(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item* length_item, int offset, int tlvlen)\r\n{\r\nif (tlvlen != 16) {\r\nexpert_add_info(pinfo, length_item, &ei_vdp_tlvlen_bad);\r\n} else {\r\nproto_tree_add_item(tree, hf_vdp_manager_id, tvb, offset, 16, ENC_NA);\r\n}\r\n}\r\nstatic void\r\ndissect_oracle_tlv(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, guint32 offset)\r\n{\r\nproto_tree_add_item(tree, hf_oui_oracle_encoding, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_vdp_tlv_org(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item* length_item, int offset, int tlvlen)\r\n{\r\nguint32 oui;\r\nguint8 subtype;\r\nif (tlvlen < 3) {\r\nexpert_add_info(pinfo, length_item, &ei_vdp_tlvlen_bad);\r\nreturn;\r\n}\r\nproto_tree_add_item_ret_uint(tree, hf_vdp_tlv_org_oui, tvb, offset, 3, ENC_BIG_ENDIAN, &oui);\r\noffset += 3;\r\nif (oui != OUI_ORACLE)\r\nreturn;\r\nproto_tree_add_item(tree, hf_vdp_tlv_oracle_subtype, tvb, offset, 1, ENC_NA);\r\nsubtype = tvb_get_guint8(tvb, offset);\r\noffset++;\r\nswitch (subtype) {\r\ncase OUI_ORACLE_VSIMGR_SUBTYPE:\r\ndissect_oracle_tlv(tvb, pinfo, tree, offset);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\ndissect_vdp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_tree *vdp_tlv_tree;\r\nproto_item *ti, *length_item;\r\nint offset = 0;\r\nguint8 tlvtype;\r\nguint16 tlvhdr;\r\nint tlvlen = 0;\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\ntlvhdr = tvb_get_ntohs(tvb, offset);\r\ntlvtype = TLV_TYPE(tlvhdr);\r\ntlvlen = TLV_INFO_LEN(tlvhdr);\r\nif (tlvtype == 0)\r\nbreak;\r\nvdp_tlv_tree = proto_tree_add_subtree(tree, tvb, offset,\r\ntlvlen + 2, ett_vdp_tlv, &ti, "VDP TLV");\r\nproto_tree_add_item(vdp_tlv_tree, hf_vdp_tlv_type, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\nlength_item = proto_tree_add_item(vdp_tlv_tree, hf_vdp_tlv_len, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nswitch (tlvtype) {\r\ncase VDP_TLV_PREASSOC:\r\nbreak;\r\ncase VDP_TLV_PREASSOCRR:\r\nbreak;\r\ncase VDP_TLV_ASSOC:\r\ncase VDP_TLV_DEASSOC:\r\ndissect_vdp_tlv_assoc(tvb, pinfo, vdp_tlv_tree, length_item, offset, tlvtype, tlvlen);\r\nbreak;\r\ncase VDP_TLV_MGRID:\r\ndissect_vdp_tlv_mgrid(tvb, pinfo, vdp_tlv_tree, length_item, offset, tlvlen);\r\nbreak;\r\ncase VDP_TLV_ORG:\r\ndissect_vdp_tlv_org(tvb, pinfo, vdp_tlv_tree, length_item, offset, tlvlen);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(vdp_tlv_tree, hf_vdp_data, tvb, offset, tlvlen, ENC_NA);\r\nbreak;\r\n}\r\noffset += tlvlen;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_ecp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *ecp_tree = NULL;\r\nint offset = 0;\r\ntvbuff_t *next_tvb;\r\nguint16 hdr, ver, op, subtype, seqno;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ECP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nti = proto_tree_add_item(tree, proto_ecp, tvb, 0, -1, ENC_NA);\r\necp_tree = proto_item_add_subtree(ti, ett_ecp);\r\nproto_tree_add_item(ecp_tree, hf_ecp_version, tvb, offset, 2,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(ecp_tree, hf_ecp_op, tvb, offset, 2,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(ecp_tree, hf_ecp_subtype, tvb, offset, 2,\r\nENC_BIG_ENDIAN);\r\nhdr = tvb_get_ntohs(tvb, offset);\r\nver = ECP_VERSION(hdr);\r\nop = ECP_OP(hdr);\r\nsubtype = ECP_SUBTYPE(hdr);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"PDU Version = %x OP = %x Subtype = %x", ver, op, subtype);\r\noffset += 2;\r\nif (tree) {\r\nproto_tree_add_item(ecp_tree, hf_ecp_seqno, tvb, offset, 2,\r\nENC_BIG_ENDIAN);\r\n}\r\nseqno = tvb_get_ntohs(tvb, offset);\r\nswitch (op) {\r\ncase ECP_OP_REQ:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO,\r\n" SEQ = 0x%x", seqno);\r\nbreak;\r\ncase ECP_OP_ACK:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO,\r\n" ACK = 0x%x", seqno);\r\nbreak;\r\n}\r\noffset += 2;\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nif (!dissector_try_uint(ecp_subdissector_table, subtype, next_tvb, pinfo, ecp_tree))\r\n{\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ecp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ecp_version,\r\n{ "Version", "ecp.ver", FT_UINT16, BASE_DEC,\r\nNULL, ECP_VERSION_MASK, NULL, HFILL }},\r\n{ &hf_ecp_op,\r\n{ "Operation", "ecp.op", FT_UINT16, BASE_HEX,\r\nVALS(ecp_op_vals), ECP_OP_MASK, NULL, HFILL }},\r\n{ &hf_ecp_subtype,\r\n{ "Subtype", "ecp.subtype", FT_UINT16, BASE_HEX,\r\nVALS(ecp_subtype_vals), ECP_SUBTYPE_MASK, NULL, HFILL }},\r\n{ &hf_ecp_seqno,\r\n{ "Sequence number", "ecp.seqno", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ecp,\r\n};\r\nproto_ecp = proto_register_protocol("Edge Control Protocol", "ECP21", "ecp21");\r\nproto_register_field_array(proto_ecp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\necp_subdissector_table = register_dissector_table("ecp.subtype", "ECP Subtypes", proto_ecp, FT_UINT32, BASE_DEC);\r\n}\r\nvoid\r\nproto_register_vdp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_vdp_tlv_type,\r\n{ "VDP TLV Type", "vdp21.tlvtype", FT_UINT16, BASE_DEC,\r\nVALS(vdp_tlv_type_vals), TLV_TYPE_MASK, NULL, HFILL }},\r\n{ &hf_vdp_tlv_len,\r\n{ "VDP TLV Length", "vdp21.tlvlen", FT_UINT16, BASE_DEC,\r\nNULL, TLV_INFO_LEN_MASK, NULL, HFILL }},\r\n{ &hf_vdp_tlv_assoc_reason,\r\n{ "Reason", "vdp21.assoc.reason", FT_UINT8, BASE_HEX,\r\nNULL, 0x0F, NULL, HFILL }},\r\n{ &hf_vdp_tlv_assoc_error,\r\n{ "Error", "vdp21.assoc.error", FT_UINT8, BASE_HEX,\r\nVALS(vdp_response_error_type_vals), 0x0F, NULL, HFILL }},\r\n{ &hf_vdp_tlv_assoc_request_flags,\r\n{ "Flags", "vdp21.assoc.request_flags", FT_UINT8, BASE_HEX,\r\nNULL, 0xF0, NULL, HFILL }},\r\n{ &hf_vdp_tlv_assoc_response_flags,\r\n{ "Flags", "vdp21.assoc.response_flags", FT_UINT8, BASE_HEX,\r\nNULL, 0xF0, NULL, HFILL }},\r\n{ &hf_vdp_tlv_assoc_flag_mbit,\r\n{ "M-Bit", "vdp21.assoc.flags.mbit", FT_BOOLEAN, 8,\r\nNULL, 0x10, NULL, HFILL }},\r\n{ &hf_vdp_tlv_assoc_flag_sbit,\r\n{ "S-Bit", "vdp21.assoc.flags.sbit", FT_BOOLEAN, 8,\r\nNULL, 0x20, NULL, HFILL }},\r\n{ &hf_vdp_tlv_assoc_flag_req_rsp,\r\n{ "Response", "vdp21.assoc.flags.req_rsp", FT_BOOLEAN, 8,\r\nTFS(&tfs_true_false), 0x40, NULL, HFILL }},\r\n{ &hf_vdp_tlv_assoc_flag_hard_error,\r\n{ "Hard Error", "vdp21.assoc.flags.hard_error", FT_BOOLEAN, 8,\r\nNULL, 0x10, NULL, HFILL }},\r\n{ &hf_vdp_tlv_assoc_flag_keep,\r\n{ "Keep", "vdp21.assoc.flags.keep", FT_BOOLEAN, 8,\r\nNULL, 0x20, NULL, HFILL }},\r\n{ &hf_oui_oracle_encoding,\r\n{ "VSI Manager ID Encoding", "vdp21.oracle.encoding", FT_UINT8,\r\nBASE_HEX, VALS(oui_oracle_encoding_vals),\r\n0x0, NULL, HFILL}},\r\n{ &hf_vdp_vsitypeid,\r\n{ "VSI Type ID", "vdp21.vsitypeid", FT_UINT24,\r\nBASE_HEX, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_vdp_vsiversion,\r\n{ "VSI Version", "vdp21.vsiversion", FT_UINT8,\r\nBASE_HEX, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_vdp_vsiid_format,\r\n{ "VSIID Format", "vdp21.vsiidformat", FT_UINT8,\r\nBASE_HEX, VALS(vdp_vsiid_format_vals), 0x0,\r\nNULL, HFILL}},\r\n{ &hf_vdp_filter_format,\r\n{ "VDP Filter Format", "vdp21.filterformat", FT_UINT8,\r\nBASE_HEX, VALS(vdp_filter_format_vals), 0x0,\r\nNULL, HFILL}},\r\n{ &hf_vdp_assoc_mac_id,\r\n{ "MAC ID", "vdp21.assoc.mac_id", FT_ETHER, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_vdp_vsiid,\r\n{ "VSIID", "vdp21.VSIID", FT_BYTES, SEP_COLON,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_vdp_vidstr_ps,\r\n{ "VIDSTR PS", "vdp21.vidstr.ps", FT_UINT16, BASE_HEX,\r\nNULL, 0x800, NULL, HFILL }},\r\n{ &hf_vdp_vidstr_pcp,\r\n{ "VIDSTR PCP", "vdp21.vidstr.pcp", FT_UINT16, BASE_HEX,\r\nNULL, 0x700, NULL, HFILL }},\r\n{ &hf_vdp_vidstr_vid,\r\n{ "VIDSTR VID", "vdp21.vidstr.vid", FT_UINT16, BASE_HEX,\r\nNULL, 0x0FFF, NULL, HFILL }},\r\n{ &hf_vdp_manager_id,\r\n{ "VDP Manager ID", "vdp21.manager_id", FT_IPv6, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_vdp_data,\r\n{ "Data", "vdp21.data", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_vdp_tlv_org_oui,\r\n{ "VIDSTR VID", "vdp21.org_oui", FT_UINT24, BASE_HEX,\r\nVALS(oui_vals), 0x0, NULL, HFILL }},\r\n{ &hf_vdp_tlv_oracle_subtype,\r\n{ "Oracle Subtype", "vdp21.org.oracle.subtype", FT_UINT8, BASE_HEX,\r\nVALS(oui_oracle_subtype_vals), 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_vdp_tlv,\r\n&ett_vdp_tlv_assoc,\r\n&ett_vdp_tlv_org,\r\n&ett_vdp_assoc_flags,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_vdp_tlvlen_bad, { "vdp21.tlvlen.bad", PI_MALFORMED, PI_ERROR, "VDP TLV Invalid Length", EXPFILL }},\r\n};\r\nexpert_module_t* expert_vdp;\r\nproto_vdp = proto_register_protocol("VSI protocol", "VDP21", "vdp21");\r\nproto_register_field_array(proto_vdp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_vdp = expert_register_protocol(proto_vdp);\r\nexpert_register_field_array(expert_vdp, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_ecp_21(void)\r\n{\r\ndissector_handle_t ecp_handle;\r\necp_handle = create_dissector_handle(dissect_ecp, proto_ecp);\r\ndissector_add_uint("ethertype", ETHERTYPE_ECP, ecp_handle);\r\n}\r\nvoid\r\nproto_reg_handoff_vdp(void)\r\n{\r\ndissector_handle_t vdp_handle;\r\nvdp_handle = create_dissector_handle(dissect_vdp, proto_vdp);\r\ndissector_add_uint("ecp.subtype", ECP_SUBTYPE_VDP, vdp_handle);\r\n}
