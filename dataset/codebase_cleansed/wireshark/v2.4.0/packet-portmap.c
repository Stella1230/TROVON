static int\r\ndissect_getport_call(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data)\r\n{\r\nguint32 proto, version;\r\nguint32 prog;\r\nconst char *prog_name;\r\nconst char *proto_name;\r\nint offset = 0;\r\nif(!pinfo->fd->flags.visited){\r\nrpc_call_info_value *rpc_call=(rpc_call_info_value *)data;\r\nif(rpc_call){\r\nproto = tvb_get_ntohl(tvb, offset+8);\r\nif(proto==IP_PROTO_UDP){\r\nrpc_call->private_data=(void *)PT_UDP;\r\n}\r\n}\r\n}\r\nprog = tvb_get_ntohl(tvb, offset+0);\r\nprog_name = rpc_prog_name(prog);\r\nproto_tree_add_uint_format_value(tree, hf_portmap_prog, tvb,\r\noffset, 4, prog, "%s (%u)",\r\nprog_name, prog);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " %s(%u)", prog_name, prog);\r\nproto_item_append_text(tree, " GETPORT Call %s(%u)", prog_name, prog);\r\nversion = tvb_get_ntohl(tvb, offset+4);\r\nproto_tree_add_item(tree, hf_portmap_version, tvb,\r\noffset+4, 4, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " V:%d", version);\r\nproto_item_append_text(tree, " Version:%d", version);\r\nproto = tvb_get_ntohl(tvb, offset+8);\r\nproto_name = ipprotostr(proto);\r\nproto_tree_add_uint_format(tree, hf_portmap_proto, tvb,\r\noffset+8, 4, proto, "Proto: %s (%u)", proto_name, proto);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " %s", proto_name);\r\nproto_item_append_text(tree, " %s", proto_name);\r\nproto_tree_add_item(tree, hf_portmap_port, tvb,\r\noffset+12, 4, ENC_BIG_ENDIAN);\r\nreturn offset+16;\r\n}\r\nstatic int\r\ndissect_getport_reply(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data)\r\n{\r\nguint32 portx;\r\nint offset = 0;\r\nif(!pinfo->fd->flags.visited){\r\nrpc_call_info_value *rpc_call=(rpc_call_info_value *)data;\r\nif(rpc_call && (GPOINTER_TO_UINT(rpc_call->private_data)==PT_UDP) ){\r\nguint32 port;\r\nport=tvb_get_ntohl(tvb, offset);\r\nif(port){\r\nconversation_t *conv;\r\nconv=find_conversation(pinfo->num, &pinfo->src, &pinfo->dst, (port_type)rpc_call->private_data, port, 0, NO_ADDR_B|NO_PORT_B);\r\nif(!conv){\r\nconv=conversation_new(pinfo->num, &pinfo->src, &pinfo->dst, (port_type)rpc_call->private_data, port, 0, NO_ADDR2|NO_PORT2);\r\n}\r\nconversation_set_dissector(conv, rpc_handle);\r\n}\r\n}\r\n}\r\nportx = tvb_get_ntohl(tvb, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_portmap_port,\r\noffset);\r\nproto_item_append_text(tree, " GETPORT Reply Port:%d", portx);\r\nif(portx){\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " Port:%d", portx);\r\nproto_item_append_text(tree, " Port:%d", portx);\r\n} else {\r\ncol_append_str(pinfo->cinfo, COL_INFO, " PROGRAM_NOT_AVAILABLE");\r\nproto_item_append_text(tree, " PROGRAM_NOT_AVAILABLE");\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_set_call(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nguint32 proto;\r\nguint32 prog;\r\nint offset = 0;\r\nif ( tree )\r\n{\r\nprog = tvb_get_ntohl(tvb, offset+0);\r\nproto_tree_add_uint_format_value(tree, hf_portmap_prog, tvb,\r\noffset, 4, prog, "%s (%d)",\r\nrpc_prog_name(prog), prog);\r\nproto_tree_add_item(tree, hf_portmap_version, tvb,\r\noffset+4, 4, ENC_BIG_ENDIAN);\r\nproto = tvb_get_ntohl(tvb, offset+8);\r\nproto_tree_add_uint_format(tree, hf_portmap_proto,tvb,\r\noffset+8, 4, proto, "Proto: %s (%d)", ipprotostr(proto), proto);\r\nproto_tree_add_item(tree, hf_portmap_port, tvb,\r\noffset+12, 4, ENC_BIG_ENDIAN);\r\n}\r\nreturn offset+16;\r\n}\r\nstatic int\r\ndissect_unset_call(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nguint32 proto;\r\nguint32 prog;\r\nint offset = 0;\r\nif ( tree )\r\n{\r\nprog = tvb_get_ntohl(tvb, offset+0);\r\nproto_tree_add_uint_format_value(tree, hf_portmap_prog, tvb,\r\noffset, 4, prog, "%s (%d)",\r\nrpc_prog_name(prog), prog);\r\nproto_tree_add_item(tree, hf_portmap_version, tvb,\r\noffset+4, 4, ENC_BIG_ENDIAN);\r\nproto = tvb_get_ntohl(tvb, offset+8);\r\nproto_tree_add_uint(tree, hf_portmap_proto, tvb,\r\noffset+8, 4, proto);\r\nproto_tree_add_item(tree, hf_portmap_port, tvb,\r\noffset+12, 4, ENC_BIG_ENDIAN);\r\n}\r\nreturn offset+16;\r\n}\r\nstatic int\r\ndissect_set_reply(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nreturn dissect_rpc_bool(tvb, tree, hf_portmap_answer, 0);\r\n}\r\nstatic int\r\ndissect_dump_entry(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint prog, version, proto, port;\r\nproto_tree *subtree;\r\nprog = tvb_get_ntohl(tvb, offset+0);\r\nversion = tvb_get_ntohl(tvb, offset+4);\r\nproto = tvb_get_ntohl(tvb, offset+8);\r\nport = tvb_get_ntohl(tvb, offset+12);\r\nif ( tree )\r\n{\r\nsubtree = proto_tree_add_subtree_format(tree, tvb, offset, 16,\r\nett_portmap_entry, NULL, "Map Entry: %s (%u) V%d",\r\nrpc_prog_name(prog), prog, version);\r\nproto_tree_add_uint_format_value(subtree, hf_portmap_prog, tvb,\r\noffset+0, 4, prog,\r\n"%s (%u)", rpc_prog_name(prog), prog);\r\nproto_tree_add_uint(subtree, hf_portmap_version, tvb,\r\noffset+4, 4, version);\r\nproto_tree_add_uint_format_value(subtree, hf_portmap_proto, tvb,\r\noffset+8, 4, proto,\r\n"%s (0x%02x)", ipprotostr(proto), proto);\r\nproto_tree_add_uint(subtree, hf_portmap_port, tvb,\r\noffset+12, 4, port);\r\n}\r\noffset += 16;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_dump_reply(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nreturn dissect_rpc_list(tvb, pinfo, tree, 0, dissect_dump_entry, NULL);\r\n}\r\nstatic int\r\ndissect_callit_call(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nguint32 prog, vers, proc;\r\nint offset = 0;\r\nprog = tvb_get_ntohl(tvb, offset+0);\r\nif ( tree )\r\n{\r\nproto_tree_add_uint_format_value(tree, hf_portmap_prog, tvb,\r\noffset, 4, prog, "%s (%u)",\r\nrpc_prog_name(prog), prog);\r\n}\r\nvers = tvb_get_ntohl(tvb, offset+4);\r\nif ( tree )\r\n{\r\nproto_tree_add_uint(tree, hf_portmap_version, tvb,\r\noffset+4, 4, vers);\r\n}\r\nproc = tvb_get_ntohl(tvb, offset+8);\r\nif ( tree )\r\n{\r\nproto_tree_add_uint_format_value(tree, hf_portmap_proc, tvb,\r\noffset+8, 4, proc, "%s (%u)",\r\nrpc_proc_name(prog, vers, proc), proc);\r\n}\r\noffset += 12;\r\ncol_set_writable(pinfo->cinfo, -1, FALSE);\r\noffset = dissect_rpc_indir_call(tvb, pinfo, tree, offset,\r\nhf_portmap_args, prog, vers, proc);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_callit_reply(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\nproto_tree_add_item(tree, hf_portmap_port, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\ncol_set_writable(pinfo->cinfo, -1, FALSE);\r\noffset = dissect_rpc_indir_reply(tvb, pinfo, tree, offset,\r\nhf_portmap_result, hf_portmap_prog, hf_portmap_version,\r\nhf_portmap_proc);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_rpcb(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item* rpcb_item;\r\nproto_tree* rpcb_tree;\r\nint old_offset = offset;\r\nguint32 prog;\r\nrpcb_item = proto_tree_add_item(tree, hf_portmap_rpcb, tvb,\r\noffset, -1, ENC_NA);\r\nrpcb_tree = proto_item_add_subtree(rpcb_item, ett_portmap_rpcb);\r\nprog = tvb_get_ntohl(tvb, offset);\r\nif (rpcb_tree)\r\nproto_tree_add_uint_format_value(rpcb_tree, hf_portmap_rpcb_prog, tvb,\r\noffset, 4, prog,\r\n"%s (%u)", rpc_prog_name(prog), prog);\r\noffset += 4;\r\noffset = dissect_rpc_uint32(tvb, rpcb_tree,\r\nhf_portmap_rpcb_version, offset);\r\noffset = dissect_rpc_string(tvb, rpcb_tree,\r\nhf_portmap_rpcb_netid, offset, NULL);\r\noffset = dissect_rpc_string(tvb, rpcb_tree,\r\nhf_portmap_rpcb_addr, offset, NULL);\r\noffset = dissect_rpc_string(tvb, rpcb_tree,\r\nhf_portmap_rpcb_owner, offset, NULL);\r\nif (rpcb_item) {\r\nproto_item_set_len(rpcb_item, offset - old_offset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_rpcb3_getaddr_call(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nreturn dissect_rpcb(tvb, 0, pinfo, tree, data);\r\n}\r\nstatic int\r\ndissect_rpcb3_getaddr_reply(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nreturn dissect_rpc_string(tvb, tree, hf_portmap_uaddr, 0, NULL);\r\n}\r\nstatic int\r\ndissect_rpcb3_dump_reply(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nreturn dissect_rpc_list(tvb, pinfo, tree, 0, dissect_rpcb, NULL);\r\n}\r\nstatic int\r\ndissect_rpcb_rmtcallres(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_string(tvb, tree,\r\nhf_portmap_rpcb_addr, offset, NULL);\r\ncol_set_writable(pinfo->cinfo, -1, FALSE);\r\noffset = dissect_rpc_indir_reply(tvb, pinfo, tree, offset,\r\nhf_portmap_result, hf_portmap_prog, hf_portmap_version,\r\nhf_portmap_proc);\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_portmap(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_portmap_procedure_v1, {\r\n"V1 Procedure", "portmap.procedure_v1", FT_UINT32, BASE_DEC,\r\nVALS(portmap1_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_portmap_procedure_v2, {\r\n"V2 Procedure", "portmap.procedure_v2", FT_UINT32, BASE_DEC,\r\nVALS(portmap2_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_portmap_procedure_v3, {\r\n"V3 Procedure", "portmap.procedure_v3", FT_UINT32, BASE_DEC,\r\nVALS(portmap3_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_portmap_procedure_v4, {\r\n"V4 Procedure", "portmap.procedure_v4", FT_UINT32, BASE_DEC,\r\nVALS(portmap4_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_portmap_prog, {\r\n"Program", "portmap.prog", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_portmap_port, {\r\n"Port", "portmap.port", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_portmap_proc, {\r\n"Procedure", "portmap.proc", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_portmap_proto, {\r\n"Protocol", "portmap.proto", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_portmap_version, {\r\n"Version", "portmap.version", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_portmap_answer, {\r\n"Answer", "portmap.answer", FT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_portmap_args, {\r\n"Arguments", "portmap.args", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_portmap_result, {\r\n"Result", "portmap.result", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_portmap_rpcb, {\r\n"RPCB", "portmap.rpcb", FT_NONE, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_portmap_rpcb_prog, {\r\n"Program", "portmap.rpcb.prog", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_portmap_rpcb_version, {\r\n"Version", "portmap.rpcb.version", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_portmap_rpcb_netid, {\r\n"Network Id", "portmap.rpcb.netid", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_portmap_rpcb_addr, {\r\n"Universal Address", "portmap.rpcb.addr", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_portmap_rpcb_owner, {\r\n"Owner of this Service", "portmap.rpcb.owner", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_portmap_uaddr, {\r\n"Universal Address", "portmap.uaddr", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_portmap,\r\n&ett_portmap_rpcb,\r\n&ett_portmap_entry\r\n};\r\nproto_portmap = proto_register_protocol("Portmap", "Portmap", "portmap");\r\nproto_register_field_array(proto_portmap, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_portmap(void)\r\n{\r\nrpc_init_prog(proto_portmap, PORTMAP_PROGRAM, ett_portmap,\r\nG_N_ELEMENTS(portmap_vers_info), portmap_vers_info);\r\nrpc_handle = find_dissector("rpc");\r\n}
