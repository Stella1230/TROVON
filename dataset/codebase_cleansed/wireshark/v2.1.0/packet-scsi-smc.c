static void\r\ndissect_smc_exchangemedium (tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata _U_)\r\n{\r\nstatic const int *exchg_fields[] = {\r\n&hf_scsi_smc_inv1,\r\n&hf_scsi_smc_inv2,\r\nNULL\r\n};\r\nif (!tree)\r\nreturn;\r\nif (isreq && iscdb) {\r\nproto_tree_add_item (tree, hf_scsi_smc_mta, tvb, offset+1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_smc_sa, tvb, offset+3, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_smc_fda, tvb, offset+5, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_smc_sda, tvb, offset+7, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+9, hf_scsi_smc_medium_flags,\r\nett_scsi_exchange_medium, exchg_fields, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+10, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_smc_position_to_element (tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata _U_)\r\n{\r\nstatic const int *pte_fields[] = {\r\n&hf_scsi_smc_invert,\r\nNULL\r\n};\r\nif (!tree)\r\nreturn;\r\nif (isreq && iscdb) {\r\nproto_tree_add_item (tree, hf_scsi_smc_mta, tvb, offset+1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_smc_da, tvb, offset+3, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+7, hf_scsi_smc_medium_flags,\r\nett_scsi_exchange_medium, pte_fields, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+8, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_smc_initialize_element_status (tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata _U_)\r\n{\r\nif (!tree)\r\nreturn;\r\nif (isreq && iscdb) {\r\nproto_tree_add_bitmask(tree, tvb, offset+4, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_smc_initialize_element_status_with_range (tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata _U_)\r\n{\r\nstatic const int *range_fields[] = {\r\n&hf_scsi_smc_fast,\r\n&hf_scsi_smc_range,\r\nNULL\r\n};\r\nif (!tree)\r\nreturn;\r\nif (isreq && iscdb) {\r\nproto_tree_add_bitmask(tree, tvb, offset, hf_scsi_smc_range_flags,\r\nett_scsi_range, range_fields, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_smc_sa, tvb, offset+1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_smc_num_elements, tvb, offset+5, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+8, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_smc_openclose_importexport_element (tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata _U_)\r\n{\r\nif (!tree)\r\nreturn;\r\nif (isreq && iscdb) {\r\nproto_tree_add_item (tree, hf_scsi_smc_ea, tvb, offset+1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_smc_action_code, tvb, offset+3, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+4, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nvoid\r\ndissect_smc_movemedium (tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata _U_)\r\n{\r\nstatic const int *move_fields[] = {\r\n&hf_scsi_smc_invert,\r\nNULL\r\n};\r\nif (!tree)\r\nreturn;\r\nif (isreq && iscdb) {\r\nproto_tree_add_item (tree, hf_scsi_smc_mta, tvb, offset+1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_smc_sa, tvb, offset+3, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_smc_da, tvb, offset+5, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+9, hf_scsi_smc_range_flags,\r\nett_scsi_move, move_fields, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+10, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_scsi_smc_volume_tag (tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, guint offset, int hf_vol_id, int hf_vol_seq_num)\r\n{\r\nchar volid[32+1];\r\nchar *p;\r\ntvb_memcpy (tvb, (guint8 *)volid, offset, 32);\r\np = &volid[32];\r\nfor (;;) {\r\n*p = '\0';\r\nif (p == volid)\r\nbreak;\r\nif (*(p - 1) != ' ')\r\nbreak;\r\np--;\r\n}\r\nproto_tree_add_string(tree, hf_vol_id, tvb, offset, 32, volid);\r\nproto_tree_add_item(tree, hf_vol_seq_num, tvb, offset+34, 2, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_scsi_smc_element (tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, guint offset,\r\nguint elem_bytecnt, guint8 elem_type,\r\nguint8 voltag_flags)\r\n{\r\nguint8 flags;\r\nguint8 ident_len;\r\nproto_tree_add_item(tree, hf_scsi_smc_ea, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nelem_bytecnt -= 2;\r\nif (elem_bytecnt < 1)\r\nreturn;\r\nflags = tvb_get_guint8 (tvb, offset);\r\nswitch (elem_type) {\r\ncase MT_ELEM:\r\nproto_tree_add_item(tree, hf_scsi_smc_except, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_scsi_smc_full, tvb, offset, 1, ENC_NA);\r\nbreak;\r\ncase ST_ELEM:\r\ncase DT_ELEM:\r\nproto_tree_add_item(tree, hf_scsi_smc_access, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_scsi_smc_except, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_scsi_smc_full, tvb, offset, 1, ENC_NA);\r\nbreak;\r\ncase I_E_ELEM:\r\nproto_tree_add_item(tree, hf_scsi_smc_cmc, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_scsi_smc_inenab, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_scsi_smc_exenab, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_scsi_smc_impexp, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_scsi_smc_access, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_scsi_smc_except, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_scsi_smc_full, tvb, offset, 1, ENC_NA);\r\nbreak;\r\n}\r\noffset += 1;\r\nelem_bytecnt -= 1;\r\nif (elem_bytecnt < 1)\r\nreturn;\r\noffset += 1;\r\nelem_bytecnt -= 1;\r\nif (elem_bytecnt < 2)\r\nreturn;\r\nif (flags & EXCEPT) {\r\nproto_tree_add_item(tree, hf_scsi_smc_additional_sense_code_qualifier, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n}\r\noffset += 2;\r\nelem_bytecnt -= 2;\r\nif (elem_bytecnt < 3)\r\nreturn;\r\nswitch (elem_type) {\r\ncase DT_ELEM:\r\nflags = tvb_get_guint8 (tvb, offset);\r\nif (flags & LU_VALID) {\r\nproto_tree_add_item(tree, hf_scsi_smc_lun, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(tree, hf_scsi_smc_not_bus, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_scsi_smc_id_valid, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_scsi_smc_lu_valid, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nif (flags & ID_VALID) {\r\nproto_tree_add_item(tree, hf_scsi_smc_scsi_bus_address, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\noffset += 1;\r\noffset += 1;\r\nbreak;\r\ndefault:\r\noffset += 3;\r\nbreak;\r\n}\r\nelem_bytecnt -= 3;\r\nif (elem_bytecnt < 3)\r\nreturn;\r\nflags = tvb_get_guint8 (tvb, offset);\r\nproto_tree_add_item(tree, hf_scsi_smc_svalid, tvb, offset, 1, ENC_NA);\r\nif (flags & SVALID) {\r\nproto_tree_add_item(tree, hf_scsi_smc_invert, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_scsi_smc_source_storage_element_address, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n} else {\r\noffset += 3;\r\n}\r\nelem_bytecnt -= 3;\r\nif (voltag_flags & PVOLTAG) {\r\nif (elem_bytecnt < 36)\r\nreturn;\r\ndissect_scsi_smc_volume_tag (tvb, pinfo, tree, offset, hf_scsi_smc_primary_vol_tag_id,\r\nhf_scsi_smc_primary_vol_seq_num);\r\noffset += 36;\r\nelem_bytecnt -= 36;\r\n}\r\nif (voltag_flags & AVOLTAG) {\r\nif (elem_bytecnt < 36)\r\nreturn;\r\ndissect_scsi_smc_volume_tag (tvb, pinfo, tree, offset, hf_scsi_smc_alternate_vol_tag_id,\r\nhf_scsi_smc_alternate_vol_seq_num);\r\noffset += 36;\r\nelem_bytecnt -= 36;\r\n}\r\nif (elem_bytecnt < 1)\r\nreturn;\r\nproto_tree_add_item(tree, hf_scsi_smc_code_set, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nelem_bytecnt -= 1;\r\nif (elem_bytecnt < 1)\r\nreturn;\r\nproto_tree_add_item(tree, hf_scsi_smc_identifier_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nelem_bytecnt -= 1;\r\nif (elem_bytecnt < 1)\r\nreturn;\r\noffset += 1;\r\nelem_bytecnt -= 1;\r\nif (elem_bytecnt < 1)\r\nreturn;\r\nident_len = tvb_get_guint8 (tvb, offset);\r\nproto_tree_add_item(tree, hf_scsi_smc_identifier_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nelem_bytecnt -= 1;\r\nif (ident_len != 0) {\r\nif (elem_bytecnt < ident_len)\r\nreturn;\r\nproto_tree_add_item(tree, hf_scsi_smc_identifier, tvb, offset, ident_len, ENC_NA);\r\noffset += ident_len;\r\nelem_bytecnt -= ident_len;\r\n}\r\nif (elem_bytecnt != 0) {\r\nproto_tree_add_item(tree, hf_scsi_smc_vendor_specific_data, tvb, offset, elem_bytecnt, ENC_NA);\r\n}\r\n}\r\nstatic void\r\ndissect_scsi_smc_elements (tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, guint offset,\r\nguint desc_bytecnt, guint8 elem_type,\r\nguint8 voltag_flags, guint16 elem_desc_len)\r\n{\r\nguint elem_bytecnt;\r\nwhile (desc_bytecnt != 0) {\r\nelem_bytecnt = elem_desc_len;\r\nif (elem_bytecnt > desc_bytecnt)\r\nelem_bytecnt = desc_bytecnt;\r\nif (elem_bytecnt < 2)\r\nbreak;\r\ndissect_scsi_smc_element (tvb, pinfo, tree, offset, elem_bytecnt,\r\nelem_type, voltag_flags);\r\noffset += elem_bytecnt;\r\ndesc_bytecnt -= elem_bytecnt;\r\n}\r\n}\r\nvoid\r\ndissect_smc_readelementstatus (tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, guint offset, gboolean isreq,\r\ngboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata _U_)\r\n{\r\nguint bytecnt, desc_bytecnt;\r\nguint8 elem_type;\r\nguint8 voltag_flags;\r\nguint16 elem_desc_len;\r\nif (!tree)\r\nreturn;\r\nif (isreq && iscdb) {\r\nproto_tree_add_item(tree, hf_scsi_smc_voltag, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_scsi_smc_element_type_code_0F, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_scsi_smc_starting_element_address, tvb, offset+1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_scsi_smc_number_of_elements, tvb, offset+3, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_scsi_smc_curdata, tvb, offset+4, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_scsi_smc_dvcid, tvb, offset+4, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_scsi_smc_allocation_length, tvb, offset+6, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+10, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\nelse if (!isreq) {\r\nproto_tree_add_item(tree, hf_scsi_smc_first_element_address_reported, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_scsi_smc_number_of_elements_available, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\noffset += 1;\r\nbytecnt = tvb_get_ntoh24 (tvb, offset);\r\nproto_tree_add_item(tree, hf_scsi_smc_byte_count_of_report_available, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\nwhile (bytecnt != 0) {\r\nif (bytecnt < 1)\r\nbreak;\r\nelem_type = tvb_get_guint8 (tvb, offset);\r\nproto_tree_add_item(tree, hf_scsi_smc_element_type_code, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nbytecnt -= 1;\r\nif (bytecnt < 1)\r\nbreak;\r\nvoltag_flags = tvb_get_guint8 (tvb, offset);\r\nproto_tree_add_item(tree, hf_scsi_smc_pvoltag, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_scsi_smc_avoltag, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nbytecnt -= 1;\r\nif (bytecnt < 2)\r\nbreak;\r\nelem_desc_len = tvb_get_ntohs (tvb, offset);\r\nproto_tree_add_item(tree, hf_scsi_smc_element_descriptor_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nbytecnt -= 2;\r\nif (bytecnt < 1)\r\nbreak;\r\noffset += 1;\r\nbytecnt -= 1;\r\nif (bytecnt < 3)\r\nbreak;\r\ndesc_bytecnt = tvb_get_ntoh24 (tvb, offset);\r\nproto_tree_add_item(tree, hf_scsi_smc_byte_count_of_descriptor_data_available, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\nbytecnt -= 3;\r\nif (desc_bytecnt > bytecnt)\r\ndesc_bytecnt = bytecnt;\r\ndissect_scsi_smc_elements (tvb, pinfo, tree, offset,\r\ndesc_bytecnt, elem_type,\r\nvoltag_flags, elem_desc_len);\r\noffset += desc_bytecnt;\r\nbytecnt -= desc_bytecnt;\r\n}\r\n}\r\n}\r\nvoid\r\nproto_register_scsi_smc(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_scsi_smc_opcode,\r\n{"SMC Opcode", "scsi_smc.opcode",\r\nFT_UINT8, BASE_HEX | BASE_EXT_STRING, &scsi_smc_vals_ext, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_scsi_smc_mta,\r\n{"Medium Transport Address", "scsi_smc.mta",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_scsi_smc_sa,\r\n{"Source Address", "scsi_smc.sa",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_scsi_smc_da,\r\n{"Destination Address", "scsi_smc.da",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_scsi_smc_fda,\r\n{"First Destination Address", "scsi_smc.fda",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_scsi_smc_sda,\r\n{"Second Destination Address", "scsi_smc.sda",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_scsi_smc_medium_flags,\r\n{"Flags", "scsi_smc.medium_flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_scsi_smc_inv1,\r\n{"INV1", "scsi_smc.inv1",\r\nFT_BOOLEAN, 8, NULL, 0x02,\r\nNULL, HFILL}\r\n},\r\n{ &hf_scsi_smc_inv2,\r\n{"INV2", "scsi_smc.inv2",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL}\r\n},\r\n{ &hf_scsi_smc_range_flags,\r\n{"Flags", "scsi_smc.range_flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_scsi_smc_fast,\r\n{"FAST", "scsi_smc.fast",\r\nFT_BOOLEAN, 8, NULL, 0x02,\r\nNULL, HFILL}\r\n},\r\n{ &hf_scsi_smc_range,\r\n{"RANGE", "scsi_smc.range",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL}\r\n},\r\n#if 0\r\n{ &hf_scsi_smc_sea,\r\n{"Starting Element Address", "scsi_smc.sea",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n#endif\r\n{ &hf_scsi_smc_num_elements,\r\n{"Number of Elements", "scsi_smc.num_elements",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_scsi_smc_invert,\r\n{"INVERT", "scsi_smc.invert",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL}\r\n},\r\n{ &hf_scsi_smc_ea,\r\n{"Element Address", "scsi_smc.ea",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_scsi_smc_action_code,\r\n{"Action Code", "scsi_smc.action_code",\r\nFT_UINT8, BASE_HEX, VALS(action_code_vals), 0x1f,\r\nNULL, HFILL}\r\n},\r\n{ &hf_scsi_smc_scsi_bus_address,\r\n{ "SCSI Bus Address", "scsi_smc.scsi_bus_address",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_source_storage_element_address,\r\n{ "Source Storage Element Address", "scsi_smc.source_storage_element_address",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_code_set,\r\n{ "Code Set", "scsi_smc.code_set",\r\nFT_UINT8, BASE_DEC, VALS(scsi_devid_codeset_val), 0x0F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_identifier_type,\r\n{ "Identifier Type", "scsi_smc.identifier_type",\r\nFT_UINT8, BASE_DEC, VALS(scsi_devid_idtype_val), 0x0F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_identifier_length,\r\n{ "Identifier Length", "scsi_smc.identifier_length",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_identifier,\r\n{ "Identifier", "scsi_smc.identifier",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_vendor_specific_data,\r\n{ "Vendor-specific Data", "scsi_smc.vendor_specific_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_voltag,\r\n{ "VOLTAG", "scsi_smc.voltag",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_starting_element_address,\r\n{ "Starting Element Address", "scsi_smc.starting_element_address",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_number_of_elements,\r\n{ "Number of Elements", "scsi_smc.number_of_elements",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_curdata,\r\n{ "CURDATA", "scsi_smc.curdata",\r\nFT_BOOLEAN, 8, NULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_allocation_length,\r\n{ "Allocation Length", "scsi_smc.allocation_length",\r\nFT_UINT24, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_first_element_address_reported,\r\n{ "First Element Address Reported", "scsi_smc.first_element_address_reported",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_number_of_elements_available,\r\n{ "Number of Elements Available", "scsi_smc.number_of_elements_available",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_byte_count_of_report_available,\r\n{ "Byte Count of Report Available", "scsi_smc.byte_count_of_report_available",\r\nFT_UINT24, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_element_type_code,\r\n{ "Element Type Code", "scsi_smc.element_type_code",\r\nFT_UINT8, BASE_DEC, VALS(element_type_code_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_element_type_code_0F,\r\n{ "Element Type Code", "scsi_smc.element_type_code",\r\nFT_UINT8, BASE_DEC, VALS(element_type_code_vals), 0x0F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_pvoltag,\r\n{ "PVOLTAG", "scsi_smc.pvoltag",\r\nFT_BOOLEAN, 8, NULL, PVOLTAG,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_element_descriptor_length,\r\n{ "Element Descriptor Length", "scsi_smc.element_descriptor_length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_byte_count_of_descriptor_data_available,\r\n{ "Byte Count Of Descriptor Data Available", "scsi_smc.byte_count_of_descriptor_data_available",\r\nFT_UINT24, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_except,\r\n{ "EXCEPT", "scsi_smc.except",\r\nFT_BOOLEAN, 8, NULL, EXCEPT,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_access,\r\n{ "ACCESS", "scsi_smc.access",\r\nFT_BOOLEAN, 8, NULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_cmc,\r\n{ "cmc", "scsi_smc.cmc",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_additional_sense_code_qualifier,\r\n{ "Additional Sense Code+Qualifier", "scsi_smc.additional_sense_code_qualifier",\r\nFT_UINT16, BASE_HEX|BASE_EXT_STRING, &scsi_asc_val_ext, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_not_bus,\r\n{ "NOT BUS", "scsi_smc.not_bus",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_id_valid,\r\n{ "ID VALID", "scsi_smc.id_valid",\r\nFT_BOOLEAN, 8, NULL, ID_VALID,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_lu_valid,\r\n{ "LU VALID", "scsi_smc.lu_valid",\r\nFT_BOOLEAN, 8, NULL, LU_VALID,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_svalid,\r\n{ "SVALID", "scsi_smc.svalid",\r\nFT_BOOLEAN, 8, NULL, SVALID,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_dvcid,\r\n{ "DVCID", "scsi_smc.dvcid",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_avoltag,\r\n{ "AVOLTAG", "scsi_smc.pvoltag",\r\nFT_BOOLEAN, 8, NULL, AVOLTAG,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_full,\r\n{ "FULL", "scsi_smc.full",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_exenab,\r\n{ "EXENAB", "scsi_smc.exenab",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_inenab,\r\n{ "INENAB", "scsi_smc.inenab",\r\nFT_BOOLEAN, 8, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_impexp,\r\n{ "IMPEXP", "scsi_smc.impexp",\r\nFT_BOOLEAN, 8, NULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_lun,\r\n{ "LUN", "scsi_smc.lun",\r\nFT_UINT8, BASE_DEC, NULL, 0x07,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_primary_vol_tag_id,\r\n{ "Primary Volume Identification", "scsi_smc.primary_vol_tag_id",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_alternate_vol_tag_id,\r\n{ "Alternate Volume Identification", "scsi_smc.alternate_vol_tag_id",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_primary_vol_seq_num,\r\n{ "Primary Volume Sequence Number", "scsi_smc.primary_vol_seq_num",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_scsi_smc_alternate_vol_seq_num,\r\n{ "Alternate Volume Sequence Number", "scsi_smc.alternate_vol_seq_num",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_scsi_exchange_medium,\r\n&ett_scsi_range,\r\n&ett_scsi_move\r\n};\r\nproto_scsi_smc = proto_register_protocol("SCSI_SMC", "SCSI_SMC", "scsi_smc");\r\nproto_register_field_array(proto_scsi_smc, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}
