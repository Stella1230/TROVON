static gf\r\nmodnn(int x)\r\n{\r\nwhile (x >= NN) {\r\nx -= NN;\r\nx = (x >> MM) + (x & NN);\r\n}\r\nreturn x;\r\n}\r\nstatic void\r\ngen_ltab(void)\r\n{\r\nint i,j,k;\r\nfor(i=0;i<256;i++){\r\ntaltab[i] = 0;\r\nfor(j=0;j<8;j++)\r\nfor(k=0;k<8;k++){\r\nif(i & (1<<k))\r\ntaltab[i] ^= tal[7-k] & (1<<j);\r\n}\r\ntal1tab[taltab[i]] = i;\r\n}\r\n}\r\nstatic void\r\ngen_ldec(void)\r\n{\r\nfor(Ldec=1;(Ldec % PRIM) != 0;Ldec+= NN)\r\n;\r\nLdec /= PRIM;\r\n}\r\nstatic void\r\ngenerate_gf(void)\r\n{\r\nregister int i, mask;\r\nmask = 1;\r\nAlpha_to[MM] = 0;\r\nfor (i = 0; i < MM; i++) {\r\nAlpha_to[i] = mask;\r\nIndex_of[Alpha_to[i]] = i;\r\nif (Pp[i] != 0)\r\nAlpha_to[MM] ^= mask;\r\nmask <<= 1;\r\n}\r\nIndex_of[Alpha_to[MM]] = MM;\r\nmask >>= 1;\r\nfor (i = MM + 1; i < NN; i++) {\r\nif (Alpha_to[i - 1] >= mask)\r\nAlpha_to[i] = Alpha_to[MM] ^ ((Alpha_to[i - 1] ^ mask) << 1);\r\nelse\r\nAlpha_to[i] = Alpha_to[i - 1] << 1;\r\nIndex_of[Alpha_to[i]] = i;\r\n}\r\nIndex_of[0] = A0;\r\nAlpha_to[NN] = 0;\r\n}\r\nstatic void\r\ngen_poly(void)\r\n{\r\nregister int i, j;\r\nGg[0] = 1;\r\nfor (i = 0; i < NN - KK; i++) {\r\nGg[i+1] = 1;\r\nfor (j = i; j > 0; j--)\r\nif (Gg[j] != 0)\r\nGg[j] = Gg[j - 1] ^ Alpha_to[modnn((Index_of[Gg[j]]) + (B0 + i) *PRIM)];\r\nelse\r\nGg[j] = Gg[j - 1];\r\nGg[0] = Alpha_to[modnn(Index_of[Gg[0]] + (B0 + i) * PRIM)];\r\n}\r\nfor (i = 0; i <= NN - KK; i++)\r\nGg[i] = Index_of[Gg[i]];\r\n}\r\nint\r\nencode_rs(dtype data[KK], dtype bb[NN-KK])\r\n{\r\nregister int i, j;\r\ngf feedback;\r\n#if DEBUG >= 1 && MM != 8\r\nfor(i=0;i<KK;i++)\r\nif(MESSAGE(i) > NN)\r\nreturn -1;\r\n#endif\r\nif(!RS_init)\r\ninit_rs();\r\nCLEAR(bb,NN-KK);\r\n#ifdef CCSDS\r\nfor(i=0;i<KK;i++)\r\nMESSAGE(i) = tal1tab[MESSAGE(i)];\r\n#endif\r\nfor(i = KK - 1; i >= 0; i--) {\r\nfeedback = Index_of[MESSAGE(i) ^ REMAINDER(NN - KK - 1)];\r\nif (feedback != A0) {\r\nfor (j = NN - KK - 1; j > 0; j--)\r\nif (Gg[j] != A0)\r\nREMAINDER(j) = REMAINDER(j - 1) ^ Alpha_to[modnn(Gg[j] + feedback)];\r\nelse\r\nREMAINDER(j) = REMAINDER(j - 1);\r\nREMAINDER(0) = Alpha_to[modnn(Gg[0] + feedback)];\r\n} else {\r\nfor (j = NN - KK - 1; j > 0; j--)\r\nREMAINDER(j) = REMAINDER(j - 1);\r\nREMAINDER(0) = 0;\r\n}\r\n}\r\n#ifdef CCSDS\r\nfor(i=0;i<NN;i++)\r\nMESSAGE(i) = taltab[MESSAGE(i)];\r\n#endif\r\nreturn 0;\r\n}\r\nint\r\neras_dec_rs(dtype data[NN], int eras_pos[NN-KK], int no_eras)\r\n{\r\nint deg_lambda, el, deg_omega;\r\nint i, j, r,k;\r\ngf u,q,tmp,num1,num2,den,discr_r;\r\ngf lambda[NN-KK + 1], s[NN-KK + 1];\r\ngf b[NN-KK + 1], t[NN-KK + 1], omega[NN-KK + 1];\r\ngf root[NN-KK], reg[NN-KK + 1], loc[NN-KK];\r\nint syn_error, count;\r\nif(!RS_init)\r\ninit_rs();\r\n#ifdef CCSDS\r\nfor(i=0;i<NN;i++)\r\nRECEIVED(i) = tal1tab[RECEIVED(i)];\r\n#endif\r\n#if DEBUG >= 1 && MM != 8\r\nfor(i=0;i<NN;i++)\r\nif(RECEIVED(i) > NN)\r\nreturn -1;\r\n#endif\r\nfor(i=1;i<=NN-KK;i++){\r\ns[i] = RECEIVED(0);\r\n}\r\nfor(j=1;j<NN;j++){\r\nif(RECEIVED(j) == 0)\r\ncontinue;\r\ntmp = Index_of[RECEIVED(j)];\r\nfor(i=1;i<=NN-KK;i++)\r\ns[i] ^= Alpha_to[modnn(tmp + (B0+i-1)*PRIM*j)];\r\n}\r\nsyn_error = 0;\r\nfor(i=1;i<=NN-KK;i++){\r\nsyn_error |= s[i];\r\ns[i] = Index_of[s[i]];\r\n}\r\nif (!syn_error) {\r\ncount = 0;\r\ngoto finish;\r\n}\r\nCLEAR(&lambda[1],NN-KK);\r\nlambda[0] = 1;\r\nif (no_eras > 0) {\r\nlambda[1] = Alpha_to[modnn(PRIM * ERAS_INDEX(0))];\r\nfor (i = 1; i < no_eras; i++) {\r\nu = modnn(PRIM*ERAS_INDEX(i));\r\nfor (j = i+1; j > 0; j--) {\r\ntmp = Index_of[lambda[j - 1]];\r\nif(tmp != A0)\r\nlambda[j] ^= Alpha_to[modnn(u + tmp)];\r\n}\r\n}\r\n#if DEBUG >= 1\r\nfor(i=1;i<=no_eras;i++)\r\nreg[i] = Index_of[lambda[i]];\r\ncount = 0;\r\nfor (i = 1,k=NN-Ldec; i <= NN; i++,k = modnn(NN+k-Ldec)) {\r\nq = 1;\r\nfor (j = 1; j <= no_eras; j++)\r\nif (reg[j] != A0) {\r\nreg[j] = modnn(reg[j] + j);\r\nq ^= Alpha_to[reg[j]];\r\n}\r\nif (q != 0)\r\ncontinue;\r\nroot[count] = i;\r\nloc[count] = k;\r\ncount++;\r\n}\r\nif (count != no_eras) {\r\nprintf("\n lambda(x) is WRONG\n");\r\ncount = -1;\r\ngoto finish;\r\n}\r\n#if DEBUG >= 2\r\nprintf("\n Erasure positions as determined by roots of Eras Loc Poly:\n");\r\nfor (i = 0; i < count; i++)\r\nprintf("%d ", loc[i]);\r\nprintf("\n");\r\n#endif\r\n#endif\r\n}\r\nfor(i=0;i<NN-KK+1;i++)\r\nb[i] = Index_of[lambda[i]];\r\nr = no_eras;\r\nel = no_eras;\r\nwhile (++r <= NN-KK) {\r\ndiscr_r = 0;\r\nfor (i = 0; i < r; i++){\r\nif ((lambda[i] != 0) && (s[r - i] != A0)) {\r\ndiscr_r ^= Alpha_to[modnn(Index_of[lambda[i]] + s[r - i])];\r\n}\r\n}\r\ndiscr_r = Index_of[discr_r];\r\nif (discr_r == A0) {\r\nCOPYDOWN(&b[1],b,NN-KK);\r\nb[0] = A0;\r\n} else {\r\nt[0] = lambda[0];\r\nfor (i = 0 ; i < NN-KK; i++) {\r\nif(b[i] != A0)\r\nt[i+1] = lambda[i+1] ^ Alpha_to[modnn(discr_r + b[i])];\r\nelse\r\nt[i+1] = lambda[i+1];\r\n}\r\nif (2 * el <= r + no_eras - 1) {\r\nel = r + no_eras - el;\r\nfor (i = 0; i <= NN-KK; i++)\r\nb[i] = (lambda[i] == 0) ? A0 : modnn(Index_of[lambda[i]] - discr_r + NN);\r\n} else {\r\nCOPYDOWN(&b[1],b,NN-KK);\r\nb[0] = A0;\r\n}\r\nCOPY(lambda,t,NN-KK+1);\r\n}\r\n}\r\ndeg_lambda = 0;\r\nfor(i=0;i<NN-KK+1;i++){\r\nlambda[i] = Index_of[lambda[i]];\r\nif(lambda[i] != A0)\r\ndeg_lambda = i;\r\n}\r\nCOPY(&reg[1],&lambda[1],NN-KK);\r\ncount = 0;\r\nfor (i = 1,k=NN-Ldec; i <= NN; i++,k = modnn(NN+k-Ldec)) {\r\nq = 1;\r\nfor (j = deg_lambda; j > 0; j--){\r\nif (reg[j] != A0) {\r\nreg[j] = modnn(reg[j] + j);\r\nq ^= Alpha_to[reg[j]];\r\n}\r\n}\r\nif (q != 0)\r\ncontinue;\r\nroot[count] = i;\r\nloc[count] = k;\r\nif(++count == deg_lambda)\r\nbreak;\r\n}\r\nif (deg_lambda != count) {\r\ncount = -1;\r\ngoto finish;\r\n}\r\ndeg_omega = 0;\r\nfor (i = 0; i < NN-KK;i++){\r\ntmp = 0;\r\nj = (deg_lambda < i) ? deg_lambda : i;\r\nfor(;j >= 0; j--){\r\nif ((s[i + 1 - j] != A0) && (lambda[j] != A0))\r\ntmp ^= Alpha_to[modnn(s[i + 1 - j] + lambda[j])];\r\n}\r\nif(tmp != 0)\r\ndeg_omega = i;\r\nomega[i] = Index_of[tmp];\r\n}\r\nomega[NN-KK] = A0;\r\nfor (j = count-1; j >=0; j--) {\r\nnum1 = 0;\r\nfor (i = deg_omega; i >= 0; i--) {\r\nif (omega[i] != A0)\r\nnum1 ^= Alpha_to[modnn(omega[i] + i * root[j])];\r\n}\r\nnum2 = Alpha_to[modnn(root[j] * (B0 - 1) + NN)];\r\nden = 0;\r\nfor (i = min_(deg_lambda,NN-KK-1) & ~1; i >= 0; i -=2) {\r\nif(lambda[i+1] != A0)\r\nden ^= Alpha_to[modnn(lambda[i+1] + i * root[j])];\r\n}\r\nif (den == 0) {\r\n#if DEBUG >= 1\r\nprintf("\n ERROR: denominator = 0\n");\r\n#endif\r\ncount = -1;\r\ngoto finish;\r\n}\r\nif (num1 != 0) {\r\nRECEIVED(loc[j]) ^= Alpha_to[modnn(Index_of[num1] + Index_of[num2] + NN - Index_of[den])];\r\n}\r\n}\r\nfinish:\r\n#ifdef CCSDS\r\nfor(i=0;i<NN;i++)\r\nRECEIVED(i) = taltab[RECEIVED(i)];\r\n#endif\r\nif(eras_pos != NULL){\r\nfor(i=0;i<count;i++){\r\nif(eras_pos!= NULL)\r\neras_pos[i] = INDEX_TO_POS(loc[i]);\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic void\r\ninit_rs(void)\r\n{\r\ngenerate_gf();\r\ngen_poly();\r\n#ifdef CCSDS\r\ngen_ltab();\r\n#endif\r\n#if PRIM != 1\r\ngen_ldec();\r\n#endif\r\nRS_init = 1;\r\n}
