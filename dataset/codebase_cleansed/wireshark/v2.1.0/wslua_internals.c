WSLUA_API int wslua__concat(lua_State* L) {\r\nif (!luaL_callmeta(L,1,"__tostring"))\r\nlua_pushvalue(L,1);\r\nif (!luaL_callmeta(L,2,"__tostring"))\r\nlua_pushvalue(L,2);\r\nlua_concat(L,2);\r\nreturn 1;\r\n}\r\nWSLUA_API gboolean wslua_toboolean(lua_State* L, int n) {\r\ngboolean val = FALSE;\r\nif ( lua_isboolean(L,n) || lua_isnil(L,n) || lua_gettop(L) < n ) {\r\nval = lua_toboolean(L,n);\r\n} else if ( lua_type(L,n) == LUA_TNUMBER ) {\r\nint num = (int)luaL_checkinteger(L,n);\r\nval = num != 0 ? TRUE : FALSE;\r\n} else {\r\nluaL_argerror(L,n,"must be a boolean or number");\r\n}\r\nreturn val;\r\n}\r\nWSLUA_API gboolean wslua_checkboolean(lua_State* L, int n) {\r\nif (!lua_isboolean(L,n) ) {\r\nluaL_argerror(L,n,"must be a boolean");\r\n}\r\nreturn lua_toboolean(L,n);;\r\n}\r\nWSLUA_API gboolean wslua_optbool(lua_State* L, int n, gboolean def) {\r\ngboolean val = FALSE;\r\nif ( lua_isboolean(L,n) ) {\r\nval = lua_toboolean(L,n);\r\n} else if ( lua_isnil(L,n) || lua_gettop(L) < n ){\r\nval = def;\r\n} else {\r\nluaL_argerror(L,n,"must be a boolean");\r\n}\r\nreturn val;\r\n}\r\nWSLUA_API lua_Integer wslua_tointeger(lua_State* L, int n) {\r\nlua_Integer val = 0;\r\nif ( lua_type(L,n) == LUA_TNUMBER) {\r\nval = lua_tointeger(L,n);\r\n} else if ( lua_isboolean(L,n) ) {\r\nval = (lua_Integer) (lua_toboolean(L,n));\r\n} else if ( lua_isnil(L,n) ) {\r\nval = 0;\r\n} else {\r\nluaL_argerror(L,n,"must be a integer, boolean or nil");\r\n}\r\nreturn val;\r\n}\r\nWSLUA_API int wslua_optboolint(lua_State* L, int n, int def) {\r\nint val = 0;\r\nif ( lua_isnumber(L,n) ) {\r\nval = (int)lua_tointeger(L,n);\r\n} else if ( lua_isboolean(L,n) ) {\r\nval = lua_toboolean(L,n) ? 1 : 0;\r\n} else if ( lua_isnil(L,n) || lua_gettop(L) < n ){\r\nval = def;\r\n} else {\r\nluaL_argerror(L,n,"must be a boolean or integer");\r\n}\r\nreturn val;\r\n}\r\nWSLUA_API const char* wslua_checklstring_only(lua_State* L, int n, size_t *l) {\r\nif (lua_type(L,n) != LUA_TSTRING) {\r\nluaL_argerror(L,n,"must be a Lua string");\r\n}\r\nreturn luaL_checklstring(L, n, l);\r\n}\r\nWSLUA_API const char* wslua_checkstring_only(lua_State* L, int n) {\r\nreturn wslua_checklstring_only(L, n, NULL);\r\n}\r\nWSLUA_API const gchar* lua_shiftstring(lua_State* L, int i) {\r\nconst gchar* p = luaL_checkstring(L, i);\r\nif (p) {\r\nlua_remove(L,i);\r\nreturn p;\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nWSLUA_API void wslua_setfuncs(lua_State *L, const luaL_Reg *l, int nup) {\r\nluaL_checkstack(L, nup, "too many upvalues");\r\nfor (; l->name != NULL; l++) {\r\nint i;\r\nfor (i = 0; i < nup; i++)\r\nlua_pushvalue(L, -nup);\r\nlua_pushcclosure(L, l->func, nup);\r\nlua_setfield(L, -(nup + 2), l->name);\r\n}\r\nlua_pop(L, nup);\r\n}\r\nstatic void lua_rawgetfield(lua_State *L, int idx, const char *k) {\r\nlua_pushstring(L, k);\r\nlua_rawget(L, idx);\r\n}\r\nstatic void lua_rawsetfield (lua_State *L, int idx, const char *k) {\r\nlua_pushstring(L, k);\r\nlua_insert(L, -2);\r\nlua_rawset(L, idx);\r\n}\r\nWSLUA_API void wslua_print_stack(char* s, lua_State* L) {\r\nint i;\r\nfor (i=1;i<=lua_gettop(L);i++) {\r\nprintf("%s-%i: %s\n",s,i,lua_typename (L,lua_type(L, i)));\r\n}\r\nprintf("\n");\r\n}\r\nconst gchar* wslua_typeof(lua_State *L, int idx) {\r\nconst gchar *classname = wslua_typeof_unknown;\r\nif (luaL_getmetafield(L, idx, WSLUA_TYPEOF_FIELD)) {\r\nclassname = luaL_optstring(L, -1, wslua_typeof_unknown);\r\nlua_pop(L,1);\r\n}\r\nelse if (lua_type(L,idx) == LUA_TTABLE) {\r\nlua_rawgetfield(L, idx, WSLUA_TYPEOF_FIELD);\r\nclassname = luaL_optstring(L, -1, wslua_typeof_unknown);\r\nlua_pop(L,1);\r\n}\r\nreturn classname;\r\n}\r\ngboolean wslua_get_table(lua_State *L, int idx, const gchar *name) {\r\ngboolean result = TRUE;\r\nif (idx < 0) idx--;\r\nlua_rawgetfield(L, idx, name);\r\nif (!lua_istable(L,-1)) {\r\nlua_pop(L,1);\r\nresult = FALSE;\r\n}\r\nreturn result;\r\n}\r\ngboolean wslua_get_field(lua_State *L, int idx, const gchar *name) {\r\ngboolean result = TRUE;\r\nif (idx < 0) idx--;\r\nlua_rawgetfield(L, idx, name);\r\nif (lua_isnil(L,-1)) {\r\nlua_pop(L,1);\r\nresult = FALSE;\r\n}\r\nreturn result;\r\n}\r\nvoid wslua_assert_table_field_new(lua_State *L, int idx, const gchar *name) {\r\nlua_rawgetfield(L, idx, name);\r\nif (!lua_isnil (L, -1)) {\r\nfprintf(stderr, "ERROR: Field %s already exists!\n", name);\r\nexit(1);\r\n}\r\nlua_pop (L, 1); \\r\n}\r\nstatic int wslua_attribute_dispatcher (lua_State *L) {\r\nlua_CFunction cfunc = NULL;\r\nconst gchar *fieldname = lua_shiftstring(L,2);\r\nconst gchar *classname = NULL;\r\nconst gchar *type = NULL;\r\nif (!lua_istable(L, lua_upvalueindex(1)))\r\nreturn luaL_error(L, "Accessor dispatcher cannot retrieve the getter/setter table");\r\nlua_rawgetfield(L, lua_upvalueindex(1), fieldname);\r\nif (!lua_iscfunction(L, -1)) {\r\nlua_pop(L,1);\r\nif (lua_istable(L, lua_upvalueindex(2))) {\r\nlua_rawgetfield(L, lua_upvalueindex(2), fieldname);\r\nif (lua_iscfunction(L,-1)) {\r\nreturn 1;\r\n}\r\nlua_pop(L,1);\r\n}\r\nclassname = wslua_typeof(L, 1);\r\ntype = wslua_typeof(L, lua_upvalueindex(1));\r\nlua_pop(L, 1);\r\nreturn luaL_error(L, "No such '%s' %s attribute/field for object type '%s'", fieldname, type, classname);\r\n}\r\ncfunc = lua_tocfunction(L, -1);\r\nlua_pop(L, 1);\r\nreturn (*cfunc)(L);\r\n}\r\nint wslua_reg_attributes(lua_State *L, const wslua_attribute_table *t, gboolean is_getter) {\r\nint midx = lua_gettop(L);\r\nconst gchar *metafield = is_getter ? "__index" : "__newindex";\r\nint idx;\r\nint nup = 1;\r\nif (!lua_istable(L, midx)) {\r\nfprintf(stderr, "No metatable in the Lua stack when registering attributes!\n");\r\nexit(1);\r\n}\r\nlua_rawgetfield(L, midx, metafield);\r\nif (lua_isnil(L, -1)) {\r\nlua_pop(L,1);\r\n}\r\nelse if (lua_istable(L, -1)) {\r\nnup = 2;\r\n}\r\nelse if (lua_iscfunction(L, -1)) {\r\nlua_pop(L,1);\r\nlua_rawgetfield(L, midx, "__methods");\r\nif (!lua_istable(L, -1)) {\r\nfprintf(stderr, "got a __index cfunction but no __methods table when registering attributes!\n");\r\nexit(1);\r\n}\r\nnup = 2;\r\n}\r\nelse {\r\nfprintf(stderr, "'%s' field is not a table in the Lua stack when registering attributes!\n", metafield);\r\nexit(1);\r\n}\r\nlua_newtable(L);\r\nidx = lua_gettop(L);\r\nfor (; t->fieldname != NULL; t++) {\r\nlua_CFunction cfunc = is_getter ? t->getfunc : t->setfunc;\r\nif (cfunc) {\r\nif (nup > 1) {\r\nlua_rawgetfield(L, -2, t->fieldname);\r\nif (!lua_isnil(L,-1)) {\r\nfprintf(stderr, "'%s' attribute name already exists as method name for the class\n", t->fieldname);\r\nexit(1);\r\n}\r\nlua_pop(L,1);\r\n}\r\nlua_pushcfunction(L, cfunc);\r\nlua_rawsetfield(L, idx, t->fieldname);\r\n}\r\n}\r\nlua_pushstring(L, (is_getter ? "getter" : "setter"));\r\nlua_rawsetfield(L, idx, WSLUA_TYPEOF_FIELD);\r\nlua_pushvalue(L, idx);\r\nlua_rawsetfield(L, midx, (is_getter ? "__getters" : "__setters"));\r\nif (nup > 1) {\r\nlua_insert(L,-nup);\r\n}\r\nlua_pushcclosure(L, wslua_attribute_dispatcher, nup);\r\nlua_rawsetfield(L, midx, metafield);\r\nreturn 0;\r\n}\r\nstatic int wslua__index(lua_State *L) {\r\nconst gchar *fieldname = lua_shiftstring(L,2);\r\nif (!lua_getmetatable(L,1)) {\r\nreturn luaL_error(L, "No such '%s' field", fieldname);\r\n}\r\nlua_rawgetfield(L, 2, "__methods");\r\nlua_remove(L,2);\r\nif (!lua_istable(L, -1)) {\r\nconst gchar *classname = wslua_typeof(L, 1);\r\nlua_pop(L, 1);\r\nreturn luaL_error(L, "No such '%s' field for object type '%s'", fieldname, classname);\r\n}\r\nlua_rawgetfield(L, 2, fieldname);\r\nlua_remove(L,2);\r\nif (lua_isnil(L, -1)) {\r\nconst gchar *classname = wslua_typeof(L, 1);\r\nlua_pop(L, 1);\r\nreturn luaL_error(L, "No such '%s' function/method/field for object type '%s'", fieldname, classname);\r\n}\r\nreturn 1;\r\n}\r\nint wslua_set__index(lua_State *L) {\r\nif (!lua_istable(L, 2) || !lua_istable(L, 1)) {\r\nfprintf(stderr, "No metatable or class table in the Lua stack when registering __index!\n");\r\nexit(1);\r\n}\r\nlua_pushvalue (L, 1);\r\nlua_rawsetfield(L, 2, "__methods");\r\nlua_pushcfunction(L, wslua__index);\r\nlua_rawsetfield(L, 2, "__index");\r\nreturn 0;\r\n}\r\nint wslua_bin2hex(lua_State* L, const guint8* data, const guint len, const gboolean lowercase, const gchar* sep) {\r\nluaL_Buffer b;\r\nguint i = 0;\r\nstatic const char byte_to_str_upper[256][3] = {\r\n"00","01","02","03","04","05","06","07","08","09","0A","0B","0C","0D","0E","0F",\r\n"10","11","12","13","14","15","16","17","18","19","1A","1B","1C","1D","1E","1F",\r\n"20","21","22","23","24","25","26","27","28","29","2A","2B","2C","2D","2E","2F",\r\n"30","31","32","33","34","35","36","37","38","39","3A","3B","3C","3D","3E","3F",\r\n"40","41","42","43","44","45","46","47","48","49","4A","4B","4C","4D","4E","4F",\r\n"50","51","52","53","54","55","56","57","58","59","5A","5B","5C","5D","5E","5F",\r\n"60","61","62","63","64","65","66","67","68","69","6A","6B","6C","6D","6E","6F",\r\n"70","71","72","73","74","75","76","77","78","79","7A","7B","7C","7D","7E","7F",\r\n"80","81","82","83","84","85","86","87","88","89","8A","8B","8C","8D","8E","8F",\r\n"90","91","92","93","94","95","96","97","98","99","9A","9B","9C","9D","9E","9F",\r\n"A0","A1","A2","A3","A4","A5","A6","A7","A8","A9","AA","AB","AC","AD","AE","AF",\r\n"B0","B1","B2","B3","B4","B5","B6","B7","B8","B9","BA","BB","BC","BD","BE","BF",\r\n"C0","C1","C2","C3","C4","C5","C6","C7","C8","C9","CA","CB","CC","CD","CE","CF",\r\n"D0","D1","D2","D3","D4","D5","D6","D7","D8","D9","DA","DB","DC","DD","DE","DF",\r\n"E0","E1","E2","E3","E4","E5","E6","E7","E8","E9","EA","EB","EC","ED","EE","EF",\r\n"F0","F1","F2","F3","F4","F5","F6","F7","F8","F9","FA","FB","FC","FD","FE","FF"\r\n};\r\nstatic const char byte_to_str_lower[256][3] = {\r\n"00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f",\r\n"10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f",\r\n"20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f",\r\n"30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f",\r\n"40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f",\r\n"50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f",\r\n"60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f",\r\n"70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f",\r\n"80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f",\r\n"90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f",\r\n"a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af",\r\n"b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf",\r\n"c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf",\r\n"d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df",\r\n"e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef",\r\n"f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"\r\n};\r\nconst char (*byte_to_str)[3] = byte_to_str_upper;\r\nconst guint last = len - 1;\r\nif (lowercase) byte_to_str = byte_to_str_lower;\r\nluaL_buffinit(L, &b);\r\nfor (i = 0; i < len; i++) {\r\nluaL_addlstring(&b, &(*byte_to_str[data[i]]), 2);\r\nif (sep && i < last) luaL_addstring(&b, sep);\r\n}\r\nluaL_pushresult(&b);\r\nreturn 1;\r\n}\r\nint wslua_hex2bin(lua_State* L, const char* data, const guint len, const gchar* sep) {\r\nluaL_Buffer b;\r\nguint i = 0;\r\nguint seplen = 0;\r\ngint8 c, d;\r\nstatic const gint8 str_to_nibble[256] = {\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1,\r\n-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\r\n};\r\nif (sep) seplen = (guint) strlen(sep);\r\nluaL_buffinit(L, &b);\r\nfor (i = 0; i < len;) {\r\nc = str_to_nibble[(guchar)data[i]];\r\nif (c < 0) {\r\nif (seplen && strncmp(&data[i], sep, seplen) == 0) {\r\ni += seplen;\r\ncontinue;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nd = str_to_nibble[(guchar)data[++i]];\r\nif (d < 0) break;\r\nluaL_addchar(&b, (c * 16) + d);\r\ni++;\r\n}\r\nluaL_pushresult(&b);\r\nreturn 1;\r\n}
