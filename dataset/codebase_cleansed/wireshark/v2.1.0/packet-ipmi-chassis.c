static void\r\nbootopt_00(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_chs_bo00_sip, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_chs_bo00_byte1, byte1,\r\nENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nbootopt_01(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_chs_bo01_spsel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nbootopt_02(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_chs_bo02_request, &hf_ipmi_chs_bo02_discovered, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Service partition scan: ",\r\n"Not discovered", ett_ipmi_chs_bo02_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nbootopt_03(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_chs_bo03_pef, &hf_ipmi_chs_bo03_cctrl_timeout,\r\n&hf_ipmi_chs_bo03_wd_timeout, &hf_ipmi_chs_bo03_softreset, &hf_ipmi_chs_bo03_powerup, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "BMC boot flag valid, don't clear on: ",\r\n"None", ett_ipmi_chs_bo03_byte1, byte1, ENC_LITTLE_ENDIAN, BMT_NO_TFS);\r\n}\r\nstatic void\r\nbootopt_04(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte2[] = { &hf_ipmi_chs_bo04_bootinit_ack_oem, &hf_ipmi_chs_bo04_bootinit_ack_sms,\r\n&hf_ipmi_chs_bo04_bootinit_ack_os, &hf_ipmi_chs_bo04_bootinit_ack_osloader,\r\n&hf_ipmi_chs_bo04_bootinit_ack_bios, NULL };\r\nproto_tree_add_item(tree, hf_ipmi_chs_bo04_write_mask, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, "Boot Initiator Acknowledge data: ",\r\n"None", ett_ipmi_chs_bo04_byte2, byte2, ENC_LITTLE_ENDIAN, BMT_NO_TFS);\r\n}\r\nstatic void\r\nbootopt_05(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_chs_bo05_bootflags_valid,\r\n&hf_ipmi_chs_bo05_permanent, &hf_ipmi_chs_bo05_boottype, NULL };\r\nstatic const int *byte2[] = { &hf_ipmi_chs_bo05_cmos_clear, &hf_ipmi_chs_bo05_lock_kbd,\r\n&hf_ipmi_chs_bo05_bootdev, &hf_ipmi_chs_bo05_screen_blank, &hf_ipmi_chs_bo05_lockout_reset, NULL };\r\nstatic const int *byte3[] = { &hf_ipmi_chs_bo05_lockout_poweroff, &hf_ipmi_chs_bo05_bios_verbosity,\r\n&hf_ipmi_chs_bo05_progress_traps, &hf_ipmi_chs_bo05_pwd_bypass, &hf_ipmi_chs_bo05_lock_sleep,\r\n&hf_ipmi_chs_bo05_console_redirection, NULL };\r\nstatic const int *byte4[] = { &hf_ipmi_chs_bo05_bios_shared_override,\r\n&hf_ipmi_chs_bo05_bios_muxctl_override, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_chs_bo05_byte1,\r\nbyte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_chs_bo05_byte2,\r\nbyte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 2, 1, NULL, NULL, ett_ipmi_chs_bo05_byte3,\r\nbyte3, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 3, 1, NULL, NULL, ett_ipmi_chs_bo05_byte4,\r\nbyte4, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_chs_bo05_byte5, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nbootopt_06(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_chs_bo06_chan_num, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_chs_bo06_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_chs_bo06_session_id, tvb, 1, 4, ENC_LITTLE_ENDIAN);\r\nipmi_add_timestamp(tree, hf_ipmi_chs_bo06_bootinfo_timestamp, tvb, 5);\r\n}\r\nstatic void\r\nbootopt_07(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_chs_bo07_block_selector, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_chs_bo07_block_data, tvb, 1, -1, ENC_NA);\r\n}\r\nstatic void\r\nrs00(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_chs_00_capflags_ppi, &hf_ipmi_chs_00_capflags_di,\r\n&hf_ipmi_chs_00_capflags_fpl, &hf_ipmi_chs_00_capflags_is, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Capabilities: ", "None",\r\nett_ipmi_chs_00_capflags, byte1, ENC_LITTLE_ENDIAN, BMT_NO_TFS);\r\nproto_tree_add_item(tree, hf_ipmi_chs_00_fru_dev_addr, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_chs_00_sdr_dev_addr, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_chs_00_sel_dev_addr, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_chs_00_sm_dev_addr, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\nif (tvb_captured_length(tvb) >= 5) {\r\nproto_tree_add_item(tree, hf_ipmi_chs_00_bridge_dev_addr, tvb, 5, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrs01(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_chs_01_pwr_state_policy,\r\n&hf_ipmi_chs_01_pwr_state_ctl_fault, &hf_ipmi_chs_01_pwr_state_fault,\r\n&hf_ipmi_chs_01_pwr_state_ilock, &hf_ipmi_chs_01_pwr_state_overload,\r\n&hf_ipmi_chs_01_pwr_state_powered, NULL };\r\nstatic const int *byte2[] = { &hf_ipmi_chs_01_last_event_via_ipmi,\r\n&hf_ipmi_chs_01_last_event_down_by_fault, &hf_ipmi_chs_01_last_event_interlock,\r\n&hf_ipmi_chs_01_last_event_overload, &hf_ipmi_chs_01_last_event_ac_failed, NULL };\r\nstatic const int *byte3[] = { &hf_ipmi_chs_01_misc_identsupp, &hf_ipmi_chs_01_misc_identstate,\r\n&hf_ipmi_chs_01_misc_fan, &hf_ipmi_chs_01_misc_drive, &hf_ipmi_chs_01_misc_fpl_active,\r\n&hf_ipmi_chs_01_misc_intrusion, NULL };\r\nstatic const int *byte4[] = { &hf_ipmi_chs_01_fpb_standby_allowed,\r\n&hf_ipmi_chs_01_fpb_diagintr_allowed, &hf_ipmi_chs_01_fpb_reset_allowed,\r\n&hf_ipmi_chs_01_fpb_poweroff_allowed, &hf_ipmi_chs_01_fpb_standby_disabled,\r\n&hf_ipmi_chs_01_fpb_diagintr_disabled, &hf_ipmi_chs_01_fpb_reset_disabled,\r\n&hf_ipmi_chs_01_fpb_poweroff_disabled, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Current Power State: ", NULL,\r\nett_ipmi_chs_01_pwr_state, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, "Last Power Event: ", NULL,\r\nett_ipmi_chs_01_last_event, byte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 2, 1, "Misc. State: ", NULL,\r\nett_ipmi_chs_01_misc, byte3, ENC_LITTLE_ENDIAN, 0);\r\nif (tvb_captured_length(tvb) > 3) {\r\nproto_tree_add_bitmask_text(tree, tvb, 3, 1, "Front panel buttons capabilities: ",\r\nNULL, ett_ipmi_chs_01_fpb, byte4, ENC_LITTLE_ENDIAN, BMT_NO_TFS);\r\n};\r\n}\r\nstatic void\r\nrq02(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_chs_02_cctrl, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_chs_02_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrq04(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte2[] = { &hf_ipmi_chs_04_perm_on, NULL };\r\nif (tvb_captured_length(tvb) > 0) {\r\nproto_tree_add_item(tree, hf_ipmi_chs_04_ival, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nif (tvb_captured_length(tvb) > 1) {\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, "Flags: ", "None",\r\nett_ipmi_chs_04_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\n}\r\nstatic void\r\nrq05(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_chs_05_flags_fpl, &hf_ipmi_chs_05_flags_intrusion, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Capabilities: ", "None",\r\nett_ipmi_chs_05_flags, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_chs_05_fru_dev_addr, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_chs_05_sdr_dev_addr, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_chs_05_sel_dev_addr, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_chs_05_sm_dev_addr, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\nif (tvb_captured_length(tvb) > 5) {\r\nproto_tree_add_item(tree, hf_ipmi_chs_05_bridge_dev_addr, tvb, 5, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrq06(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_chs_06_rq_policy, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_chs_06_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrs06(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_chs_06_rs_policy_support_powerup,\r\n&hf_ipmi_chs_06_rs_policy_support_restore, &hf_ipmi_chs_06_rs_policy_support_poweroff, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Power Restore Policy support: ", "None",\r\nett_ipmi_chs_06_policy_support, byte1, ENC_LITTLE_ENDIAN, BMT_NO_TFS);\r\n}\r\nstatic void\r\nrs07(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_chs_07_cause, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_chs_07_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_chs_07_chan, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq08(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree *s_tree;\r\ntvbuff_t *sub;\r\nguint8 pno;\r\nconst char *desc;\r\npno = tvb_get_guint8(tvb, 0) & 0x7f;\r\nif (pno < array_length(boot_options)) {\r\ndesc = boot_options[pno].name;\r\n} else if (pno >= 96 && pno <= 127) {\r\ndesc = "OEM";\r\n} else {\r\ndesc = "Reserved";\r\n}\r\ns_tree = proto_tree_add_subtree_format(tree, tvb, 0, 1,\r\nett_ipmi_chs_08_byte1, NULL, "Boot option parameter selector: %s (0x%02x)",\r\ndesc, pno);\r\nproto_tree_add_item(s_tree, hf_ipmi_chs_08_valid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_uint_format_value(s_tree, hf_ipmi_chs_08_selector, tvb, 0, 1,\r\npno, "Boot option parameter selector: %s (0x%02x)",\r\ndesc, pno);\r\nif (tvb_captured_length(tvb) > 1) {\r\nif (pno < array_length(boot_options)) {\r\nsub = tvb_new_subset_remaining(tvb, 1);\r\nboot_options[pno].intrp(sub, tree);\r\n} else {\r\nproto_tree_add_none_format(tree, hf_ipmi_chs_08_data, tvb, 1,\r\n-1, "Parameter data: %s", desc);\r\n}\r\n}\r\n}\r\nstatic void\r\nrq09(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree *s_tree;\r\nguint8 pno;\r\nconst char *desc;\r\npno = tvb_get_guint8(tvb, 0) & 0x7f;\r\nif (pno < array_length(boot_options)) {\r\ndesc = boot_options[pno].name;\r\n} else if (pno >= 96 && pno <= 127) {\r\ndesc = "OEM";\r\n} else {\r\ndesc = "Reserved";\r\n}\r\ns_tree = proto_tree_add_subtree_format(tree, tvb, 0, 1,\r\nett_ipmi_chs_09_rq_byte1, NULL, "Boot option parameter selector: %s (0x%02x)",\r\ndesc, pno);\r\nproto_tree_add_uint_format_value(s_tree, hf_ipmi_chs_09_rq_param_select, tvb, 0, 1,\r\npno, "Boot option parameter selector: %s (0x%02x)",\r\ndesc, pno);\r\nproto_tree_add_item(tree, hf_ipmi_chs_09_rq_set_select, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_chs_09_rq_block_select, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs09(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_chs_09_rs_param_version, NULL };\r\nproto_tree *s_tree;\r\ntvbuff_t *sub;\r\nguint8 pno;\r\nconst char *desc;\r\npno = tvb_get_guint8(tvb, 1) & 0x7f;\r\nif (pno < array_length(boot_options)) {\r\ndesc = boot_options[pno].name;\r\n} else if (pno >= 96 && pno <= 127) {\r\ndesc = "OEM";\r\n} else {\r\ndesc = "Reserved";\r\n}\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_chs_09_rs_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\ns_tree = proto_tree_add_subtree_format(tree, tvb, 1, 1,\r\nett_ipmi_chs_09_rs_byte2, NULL, "Boot option parameter selector: %s (0x%02x)",\r\ndesc, pno);\r\nproto_tree_add_item(s_tree, hf_ipmi_chs_09_rs_valid, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_uint_format_value(s_tree, hf_ipmi_chs_09_rs_param_select, tvb, 1, 1,\r\npno, "Boot option parameter selector: %s (0x%02x)",\r\ndesc, pno);\r\nif (pno < array_length(boot_options)) {\r\nsub = tvb_new_subset_remaining(tvb, 2);\r\nboot_options[pno].intrp(sub, tree);\r\n} else {\r\nproto_tree_add_item(tree, hf_ipmi_chs_09_rs_param_data, tvb, 2, -1, ENC_NA);\r\n}\r\n}\r\nstatic void\r\nrs0f(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_chs_0f_minpercnt, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_chs_0f_counter, tvb, 1, 4, ENC_LITTLE_ENDIAN);\r\n}\r\nvoid\r\nproto_register_ipmi_chassis(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ipmi_chs_bo00_sip,\r\n{ "Set In Progress",\r\n"ipmi.bootopt00.sip", FT_UINT8, BASE_HEX, VALS(bo00_sip_vals), 0x03, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo01_spsel,\r\n{ "Service Partition Selector",\r\n"ipmi.bootopt01.spsel", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo02_request,\r\n{ "Request BIOS to scan for specified service partition",\r\n"ipmi.bootopt02.spscan.request", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo02_discovered,\r\n{ "Service Partition discovered",\r\n"ipmi.bootopt02.spscan.discovered", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo03_pef,\r\n{ "Reset/power cycle caused by PEF",\r\n"ipmi.bootopt03.bmcboot.pef", FT_BOOLEAN, 8, TFS(&bo03_dontclear_tfs), 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo03_cctrl_timeout,\r\n{ "Chassis Control command not received within 60s timeout",\r\n"ipmi.bootopt03.bmcboot.cctrl_timeout", FT_BOOLEAN, 8, TFS(&bo03_dontclear_tfs), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo03_wd_timeout,\r\n{ "Reset/power cycle caused by watchdog timeout",\r\n"ipmi.bootopt03.bmcboot.wd_timeout", FT_BOOLEAN, 8, TFS(&bo03_dontclear_tfs), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo03_softreset,\r\n{ "Pushbutton reset / soft reset",\r\n"ipmi.bootopt03.bmcboot.softreset", FT_BOOLEAN, 8, TFS(&bo03_dontclear_tfs), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo03_powerup,\r\n{ "Power up via pushbutton or wake event",\r\n"ipmi.bootopt03.bmcboot.powerup", FT_BOOLEAN, 8, TFS(&bo03_dontclear_tfs), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo04_write_mask,\r\n{ "Write mask",\r\n"ipmi.bootopt04.write_mask", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo04_bootinit_ack_oem,\r\n{ "OEM",\r\n"ipmi.bootopt04.bootinit_ack.oem", FT_BOOLEAN, 8, TFS(&bo04_bootinit_ack_tfs), 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo04_bootinit_ack_sms,\r\n{ "SMS",\r\n"ipmi.bootopt04.bootinit_ack.sms", FT_BOOLEAN, 8, TFS(&bo04_bootinit_ack_tfs), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo04_bootinit_ack_os,\r\n{ "OS / Service Partition",\r\n"ipmi.bootopt04.bootinit_ack.os", FT_BOOLEAN, 8, TFS(&bo04_bootinit_ack_tfs), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo04_bootinit_ack_osloader,\r\n{ "OS Loader",\r\n"ipmi.bootopt04.bootinit_ack.osloader", FT_BOOLEAN, 8, TFS(&bo04_bootinit_ack_tfs), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo04_bootinit_ack_bios,\r\n{ "BIOS/POST",\r\n"ipmi.bootopt04.bootinit_ack.bios", FT_BOOLEAN, 8, TFS(&bo04_bootinit_ack_tfs), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_bootflags_valid,\r\n{ "Boot flags valid",\r\n"ipmi.bootopt05.boot_flags_valid", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_permanent,\r\n{ "Permanency",\r\n"ipmi.bootopt05.permanent", FT_BOOLEAN, 8, TFS(&bo05_permanent_tfs), 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_boottype,\r\n{ "Boot type",\r\n"ipmi.bootopt05.boottype", FT_BOOLEAN, 8, TFS(&bo05_boottype_tfs), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_cmos_clear,\r\n{ "CMOS Clear",\r\n"ipmi.bootopt05.cmos_clear", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_lock_kbd,\r\n{ "Lock Keyboard",\r\n"ipmi.bootopt05.lock_kbd", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_bootdev,\r\n{ "Boot Device Selector",\r\n"ipmi.bootopt05.bootdev", FT_UINT8, BASE_HEX, VALS(bo05_bootdev_vals), 0x3c, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_screen_blank,\r\n{ "Screen Blank",\r\n"ipmi.bootopt05.screen_blank", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_lockout_reset,\r\n{ "Lock out Reset buttons",\r\n"ipmi.bootopt05.lockout_reset", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_lockout_poweroff,\r\n{ "Lock out (power off / sleep request) via Power Button",\r\n"ipmi.bootopt05.lockout_poweroff", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_bios_verbosity,\r\n{ "BIOS verbosity",\r\n"ipmi.bootopt05.bios_verbosity", FT_UINT8, BASE_HEX, VALS(bo05_bios_verbosity_vals), 0x60, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_progress_traps,\r\n{ "Force Progress Event Traps",\r\n"ipmi.bootopt05.progress_traps", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_pwd_bypass,\r\n{ "User password bypass",\r\n"ipmi.bootopt05.pwd_bypass", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_lock_sleep,\r\n{ "Lock Out Sleep Button",\r\n"ipmi.bootopt05.lock_sleep", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_console_redirection,\r\n{ "Console redirection",\r\n"ipmi.bootopt05.console_redirection", FT_UINT8, BASE_HEX, VALS(bo05_console_redir_vals), 0x03, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_bios_shared_override,\r\n{ "BIOS Shared Mode Override",\r\n"ipmi.bootopt05.bios_shared_override", FT_BOOLEAN, 8, TFS(&bo05_bios_shared_tfs), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_bios_muxctl_override,\r\n{ "BIOS Mux Control Override",\r\n"ipmi.bootopt05.bios_muxctl_override", FT_UINT8, BASE_HEX, VALS(bo05_bios_muxctl_vals), 0x07, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo05_byte5,\r\n{ "Data 5 (reserved)",\r\n"ipmi.bootopt05.byte5", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo06_chan_num,\r\n{ "Channel",\r\n"ipmi.bootopt06.chan_num", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo06_session_id,\r\n{ "Session ID",\r\n"ipmi.bootopt06.session_id", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo06_bootinfo_timestamp,\r\n{ "Boot Info Timestamp",\r\n"impi.bootopt06.bootinfo_timestamp", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo07_block_selector,\r\n{ "Block selector",\r\n"ipmi.bootopt07.block_selector", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_bo07_block_data,\r\n{ "Block data",\r\n"ipmi.bootopt07.block_data", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_00_capflags_ppi,\r\n{ "Power interlock",\r\n"ipmi.ch00.cap.power_interlock", FT_BOOLEAN, 8, TFS(&tfs_00_provided), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_chs_00_capflags_di,\r\n{ "Diagnostic Interrupt",\r\n"ipmi.ch00.cap.diag_int", FT_BOOLEAN, 8, TFS(&tfs_00_provided), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_chs_00_capflags_fpl,\r\n{ "Front Panel Lockout",\r\n"ipmi.ch00.cap.fpl", FT_BOOLEAN, 8, TFS(&tfs_00_provided), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_chs_00_capflags_is,\r\n{ "Intrusion sensor",\r\n"ipmi.ch00.cap.intrusion", FT_BOOLEAN, 8, TFS(&tfs_00_provided), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_chs_00_fru_dev_addr,\r\n{ "Chassis FRU Info Device Address",\r\n"ipmi.ch00.fru_info", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_00_sdr_dev_addr,\r\n{ "Chassis SDR Device Address",\r\n"ipmi.ch00.sdr", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_00_sel_dev_addr,\r\n{ "Chassis SEL Device Address",\r\n"ipmi.ch00.sel", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_00_sm_dev_addr,\r\n{ "Chassis System Management Device Address",\r\n"ipmi.ch00.sm", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_00_bridge_dev_addr,\r\n{ "Chassis Bridge Device Address",\r\n"ipmi.ch00.bridge", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_pwr_state_policy,\r\n{ "Power Restore Policy",\r\n"ipmi.ch01.cur_pwr.policy", FT_UINT8, BASE_HEX, VALS(vals_01_pwr_policy), 0x60, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_pwr_state_ctl_fault,\r\n{ "Power Control Fault",\r\n"ipmi.ch01.cur_pwr.ctl_fault", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_pwr_state_fault,\r\n{ "Power Fault",\r\n"ipmi.ch01.cur_pwr.fault", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_pwr_state_ilock,\r\n{ "Interlock",\r\n"ipmi.ch01.cur_pwr.interlock", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_pwr_state_overload,\r\n{ "Overload",\r\n"ipmi.ch01.cur_pwr.overload", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_pwr_state_powered,\r\n{ "Power is on",\r\n"ipmi.ch01.cur_pwr.powered", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_last_event_via_ipmi,\r\n{ "Last `Power is on' state was entered via IPMI command",\r\n"ipmi.ch01.last.on_via_ipmi", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_last_event_down_by_fault,\r\n{ "Last power down caused by power fault",\r\n"ipmi.ch01.last.down_by_fault", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_last_event_interlock,\r\n{ "Last power down caused by a power interlock being activated",\r\n"ipmi.ch01.last.interlock", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_last_event_overload,\r\n{ "Last power down caused by a power overload",\r\n"ipmi.ch01.last.overload", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_last_event_ac_failed,\r\n{ "AC failed",\r\n"ipmi.ch01.last.ac_failed", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_misc_identsupp,\r\n{ "Chassis Identify command and state info supported",\r\n"ipmi.ch01.identsupp", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_misc_identstate,\r\n{ "Chassis Identify state (if supported)",\r\n"ipmi.ch01.identstate", FT_UINT8, BASE_HEX, VALS(vals_01_identstate), 0x30, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_misc_fan,\r\n{ "Cooling/fan fault detected",\r\n"ipmi.ch01.misc.fan", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_misc_drive,\r\n{ "Drive Fault",\r\n"ipmi.ch01.misc.drive", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_misc_fpl_active,\r\n{ "Front Panel Lockout active",\r\n"ipmi.ch01.misc.fpl_active", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_misc_intrusion,\r\n{ "Chassis intrusion active",\r\n"ipmi.ch01.misc.intrusion", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_fpb_standby_allowed,\r\n{ "Standby disable allowed",\r\n"ipmi.ch01.fpb.standby_allowed", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_fpb_diagintr_allowed,\r\n{ "Diagnostic interrupt disable allowed",\r\n"ipmi.ch01.fpb.diagintr_allowed", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_fpb_reset_allowed,\r\n{ "Reset disable allowed",\r\n"ipmi.ch01.fpb.reset_allowed", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_fpb_poweroff_allowed,\r\n{ "Poweroff disable allowed",\r\n"ipmi.ch01.fpb.poweroff_allowed", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_fpb_standby_disabled,\r\n{ "Standby disabled",\r\n"ipmi.ch01.fpb.standby_disabled", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_fpb_diagintr_disabled,\r\n{ "Diagnostic interrupt disabled",\r\n"ipmi.ch01.fpb.diagintr_disabled", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_fpb_reset_disabled,\r\n{ "Reset disabled",\r\n"ipmi.ch01.fpb.reset_disabled", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_chs_01_fpb_poweroff_disabled,\r\n{ "Poweroff disabled",\r\n"ipmi.ch01.fpb.poweroff_disabled", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_chs_02_cctrl,\r\n{ "Chassis Control",\r\n"ipmi.ch02.chassis_control", FT_UINT8, BASE_HEX, VALS(vals_02_cctrl), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_chs_04_ival,\r\n{ "Identify Interval in seconds",\r\n"ipmi.ch04.interval", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_1s_1based), 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_04_perm_on,\r\n{ "Turn on Identify indefinitely",\r\n"ipmi.ch04.perm_on", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_chs_05_flags_fpl,\r\n{ "Provides Front Panel Lockout",\r\n"ipmi.ch05.flags.fpl", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_chs_05_flags_intrusion,\r\n{ "Provides intrusion sensor",\r\n"ipmi.ch05.flags.intrusion", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_chs_05_fru_dev_addr,\r\n{ "Chassis FRU Info Device Address",\r\n"ipmi.ch05.fru_info", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_05_sdr_dev_addr,\r\n{ "Chassis SDR Device Address",\r\n"ipmi.ch05.sdr", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_05_sel_dev_addr,\r\n{ "Chassis SEL Device Address",\r\n"ipmi.ch05.sel", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_05_sm_dev_addr,\r\n{ "Chassis System Management Device Address",\r\n"ipmi.ch05.sm", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_05_bridge_dev_addr,\r\n{ "Chassis Bridge Device Address",\r\n"ipmi.ch05.bridge", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_06_rq_policy,\r\n{ "Power Restore Policy",\r\n"ipmi.ch06.rq_policy", FT_UINT8, BASE_HEX, VALS(vals_06_policy), 0x07, NULL, HFILL }},\r\n{ &hf_ipmi_chs_06_rs_policy_support_powerup,\r\n{ "Always powering up",\r\n"ipmi.ch06.rs_support.powerup", FT_BOOLEAN, 8, TFS(&tfs_06_supported), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_chs_06_rs_policy_support_restore,\r\n{ "Restoring previous state",\r\n"ipmi.ch06.rs_support.restore", FT_BOOLEAN, 8, TFS(&tfs_06_supported), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_chs_06_rs_policy_support_poweroff,\r\n{ "Staying powered off",\r\n"ipmi.ch06.rs_support.poweroff", FT_BOOLEAN, 8, TFS(&tfs_06_supported), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_chs_07_cause,\r\n{ "Restart Cause",\r\n"ipmi.ch07.cause", FT_UINT8, BASE_HEX, VALS(vals_07_cause), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_chs_07_chan,\r\n{ "Channel",\r\n"ipmi.ch07.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_08_valid,\r\n{ "Validity",\r\n"ipmi.ch08.valid", FT_BOOLEAN, 8, TFS(&tfs_08_valid), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_chs_08_selector,\r\n{ "Boot option parameter selector",\r\n"ipmi.ch08.selector", FT_UINT8, BASE_HEX, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_chs_08_data,\r\n{ "Boot option parameter data",\r\n"ipmi.ch08.data", FT_NONE, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_09_rq_param_select,\r\n{ "Parameter selector",\r\n"ipmi.ch09.rq_param_select", FT_UINT8, BASE_HEX, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_chs_09_rq_set_select,\r\n{ "Set Selector",\r\n"ipmi.ch09.rq_set_select", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_09_rq_block_select,\r\n{ "Block Selector",\r\n"ipmi.ch09.rq_block_select", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_09_rs_param_version,\r\n{ "Parameter Version",\r\n"ipmi.ch09.rs_param_version", FT_UINT8, BASE_HEX, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_chs_09_rs_valid,\r\n{ "Parameter Valid",\r\n"ipmi.ch09.rs_valid", FT_BOOLEAN, 8, TFS(&tfs_09_valid), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_chs_09_rs_param_select,\r\n{ "Parameter Selector",\r\n"ipmi.ch09.rs_param_select", FT_UINT8, BASE_HEX, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_chs_09_rs_param_data,\r\n{ "Configuration parameter data",\r\n"ipmi.ch09.rs_param_data", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_0f_minpercnt,\r\n{ "Minutes per count",\r\n"ipmi.ch0f.minpercnt", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_chs_0f_counter,\r\n{ "Counter reading",\r\n"ipmi.ch0f.counter", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ipmi_chs_bo00_byte1,\r\n&ett_ipmi_chs_bo02_byte1,\r\n&ett_ipmi_chs_bo03_byte1,\r\n&ett_ipmi_chs_bo04_byte2,\r\n&ett_ipmi_chs_bo05_byte1,\r\n&ett_ipmi_chs_bo05_byte2,\r\n&ett_ipmi_chs_bo05_byte3,\r\n&ett_ipmi_chs_bo05_byte4,\r\n&ett_ipmi_chs_bo06_byte1,\r\n&ett_ipmi_chs_00_capflags,\r\n&ett_ipmi_chs_01_pwr_state,\r\n&ett_ipmi_chs_01_last_event,\r\n&ett_ipmi_chs_01_misc,\r\n&ett_ipmi_chs_01_fpb,\r\n&ett_ipmi_chs_02_byte1,\r\n&ett_ipmi_chs_04_byte2,\r\n&ett_ipmi_chs_05_flags,\r\n&ett_ipmi_chs_06_byte1,\r\n&ett_ipmi_chs_06_policy_support,\r\n&ett_ipmi_chs_07_byte1,\r\n&ett_ipmi_chs_08_byte1,\r\n&ett_ipmi_chs_09_rq_byte1,\r\n&ett_ipmi_chs_09_rs_byte1,\r\n&ett_ipmi_chs_09_rs_byte2,\r\n};\r\nproto_register_field_array(proto_ipmi, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nipmi_register_netfn_cmdtab(IPMI_CHASSIS_REQ, IPMI_OEM_NONE, NULL, 0, NULL,\r\ncmd_chassis, array_length(cmd_chassis));\r\n}
