static void dissect_3gcsd_plmnbc(proto_tree* tree, tvbuff_t* tvb, packet_info* pinfo, int hfid, h248_curr_info_t* cu _U_, void* implicit_param) {\r\nasn1_ctx_t asn1_ctx;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\r\ndissect_ber_octet_string(implicit_param ? *((gboolean*)implicit_param) : FALSE, &asn1_ctx, tree, tvb, 0, hfid, NULL);\r\nde_bearer_cap(tvb, tree, pinfo, 4, tvb_reported_length(tvb)-4, NULL, 0);\r\n}\r\nstatic void dissect_3GTFO_codec_mode(proto_tree* tree, tvbuff_t* tvb, packet_info* pinfo, int hfid, h248_curr_info_t* cu _U_, void* ignored _U_) {\r\ntvbuff_t* sub_tvb = NULL;\r\ngint8 appclass;\r\ngboolean pc;\r\ngint32 tag;\r\nasn1_ctx_t asn1_ctx;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\r\nget_ber_identifier(tvb, 0, &appclass, &pc, &tag);\r\nif (tag==BER_UNI_TAG_OCTETSTRING) {\r\ndissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, 0, hfid, &sub_tvb );\r\nif (sub_tvb) {\r\nproto_tree* pt = proto_item_add_subtree(asn1_ctx.created_item, ett_h248_3GTFO_codec);\r\ndissect_codec_mode(pt, sub_tvb, 0, tvb_reported_length(tvb));\r\n}\r\n} else {\r\nproto_tree_add_item(tree,hfid,tvb,0,-1,ENC_NA);\r\n}\r\n}\r\nstatic void dissect_3GTFO_codec_list(proto_tree* tree, tvbuff_t* tvb, packet_info* pinfo, int hfid, h248_curr_info_t* cu _U_, void* ignored _U_) {\r\ntvbuff_t* sub_tvb = NULL;\r\ngint8 appclass;\r\ngboolean pc;\r\ngint32 tag;\r\nasn1_ctx_t asn1_ctx;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\r\nget_ber_identifier(tvb, 0, &appclass, &pc, &tag);\r\nif (tag==BER_UNI_TAG_OCTETSTRING) {\r\ndissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, 0, hfid, &sub_tvb );\r\nif (sub_tvb) {\r\nproto_tree* pt = proto_item_add_subtree(asn1_ctx.created_item,ett_h248_3GTFO_codec_list);\r\nint len = tvb_reported_length(sub_tvb);\r\nint offset = 0;\r\ndo {\r\noffset = dissect_codec_mode(pt, sub_tvb, offset, len);\r\n} while(offset < len);\r\n}\r\n} else {\r\nproto_tree_add_item(tree,hfid,tvb,0,-1,ENC_NA);\r\n}\r\n}\r\nvoid proto_register_h248_3gpp(void) {\r\nstatic hf_register_info hf[] = {\r\n{ &hf_h248_package_3GUP_Mode,\r\n{ "Mode", "h248.package_3GUP.Mode",\r\nFT_UINT32, BASE_DEC, VALS(h248_3GUP_Mode_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_h248_package_3GUP_UPversions,\r\n{ "UPversions", "h248.package_3GUP.upversions",\r\nFT_UINT32, BASE_DEC, VALS(h248_3GUP_upversions_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_h248_package_3GUP_delerrsdu,\r\n{ "Delivery of erroneous SDUs", "h248.package_3GUP.delerrsdu",\r\nFT_UINT32, BASE_DEC, VALS(h248_3GUP_delerrsdu_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_h248_package_3GUP_interface,\r\n{ "Interface", "h248.package_3GUP.interface",\r\nFT_UINT32, BASE_DEC, VALS(h248_3GUP_interface_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_h248_package_3GUP_initdir,\r\n{ "Initialisation Direction", "h248.package_3GUP.initdir",\r\nFT_UINT32, BASE_DEC, VALS(h248_3GUP_initdir_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_h248_package_3GCSD,\r\n{ "CSD Package", "h248.package_3GCSD",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Circuit Switched Data Package", HFILL }},\r\n{ &hf_h248_package_3GCSD_plmnbc,\r\n{ "PLMN Bearer Capability", "h248.package_3GCSD.plmnbc",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"The PLMN Bearer Capability", HFILL }},\r\n{ &hf_h248_package_3GCSD_gsmchancod,\r\n{ "GSM channel coding", "h248.package_3GCSD.gsmchancod",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Channel information needed for GSM", HFILL }},\r\n{ &hf_h248_pkg_3GCSD_evt_protres,\r\n{ "Protocol Negotiation Result", "h248.package_3GCSD.protres",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"This event is used to report the result of the protocol negotiation", HFILL }},\r\n{ &hf_h248_pkg_3GCSD_evt_protres_result,\r\n{ "Negotiation Result", "h248.package_3GCSD.protres.result",\r\nFT_UINT32, BASE_DEC, VALS(h248_3GCSD_evt_protres_result_vals), 0,\r\n"reports whether the protocol negotiation has been successful", HFILL }},\r\n{ &hf_h248_pkg_3GCSD_evt_protres_cause,\r\n{ "Possible Failure Cause", "h248.package_3GCSD.protres.cause",\r\nFT_UINT32, BASE_DEC, VALS(h248_3GCSD_evt_protres_cause_vals), 0,\r\n"indicates the possible failure cause", HFILL }},\r\n{ &hf_h248_pkg_3GCSD_evt_ratechg,\r\n{ "Rate Change", "h248.package_3GCSD.ratechg",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"This event is used to report a rate change", HFILL }},\r\n{ &hf_h248_pkg_3GCSD_evt_ratechg_rate,\r\n{ "New Rate", "h248.package_3GCSD.ratechg.rate",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"reports the new rate for the termination", HFILL }},\r\n{ &hf_h248_pkg_3GCSD_sig_actprot,\r\n{ "Activate Protocol", "h248.package_3GCSD.actprot",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Activate the higher layer protocol", HFILL }},\r\n{ &hf_h248_pkg_3GCSD_actprot_sig_localpeer,\r\n{ "Local Peer Role", "h248.package_3GCSD.actprot.localpeer",\r\nFT_UINT32, BASE_DEC, VALS(h248_3GCSD_actprot_sig_localpeer_vals), 0,\r\n"It is used to inform the modem whether it should act as originating or terminating peer", HFILL }},\r\n{ &hf_h248_package_3GTFO,\r\n{ "Tandem Free Operation", "h248.package_3GTFO",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"This package defines events and properties for Tandem Free Operation (TFO) control", HFILL }},\r\n{ &hf_h248_pkg_3GTFO_enable,\r\n{ "TFO Activity Control", "h248.package_3GTFO.tfoenable",\r\nFT_UINT32, BASE_DEC, VALS(tfoenable_vals), 0,\r\n"Defines if TFO is enabled or not", HFILL }},\r\n{ &hf_h248_pkg_3GTFO_codeclist,\r\n{ "TFO Codec List", "h248.package_3GTFO.codeclist",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"List of codecs for use in TFO protocol", HFILL }},\r\n{ &hf_h248_pkg_3GTFO_evt_codec_modify,\r\n{ "Optimal Codec Event", "h248.package_3GTFO.codec_modify",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"The event is used to notify the MGC that TFO negotiation has resulted in an optimal codec type being proposed", HFILL }},\r\n{ &hf_h248_pkg_3GTFO_evt_codec_modify_optimalcodec,\r\n{ "Optimal Codec Type", "h248.package_3GTFO.codec_modify.optimalcodec",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"indicates which is the proposed codec type for TFO", HFILL }},\r\n{ &hf_h248_pkg_3GTFO_evt_distant_codec_list,\r\n{ "Codec List Event", "h248.package_3GTFO.distant_codec_list",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"The event is used to notify the MGC of the distant TFO partner's supported codec list", HFILL }},\r\n{ &hf_h248_pkg_3GTFO_evt_distant_codec_list_distlist,\r\n{ "Distant Codec List", "h248.package_3GTFO.distant_codec_list.distlist",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"indicates the codec list for TFO", HFILL }},\r\n{ &hf_h248_pkg_3GTFO_evt_status,\r\n{ "TFO Status Event", "h248.package_3GTFO.status",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"The event is used to notify the MGC that a TFO link has been established or broken", HFILL }},\r\n{ &hf_h248_pkg_3GTFO_evt_status_tfostatus,\r\n{ "TFO Status", "h248.package_3GTFO.status.tfostatus",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"reports whether TFO has been established or broken", HFILL }},\r\n{ &hf_h248_package_threegint,\r\n{ "3G Interface Type", "h248.package_threegint",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"This package contains a property to specify the used interface type for IP terminations", HFILL }},\r\n{ &hf_h248_package_threegint_ipint,\r\n{ "IP Interface Type", "h248.package_threegint.ipint",\r\nFT_UINT32, BASE_DEC, VALS(h248_threegint_ipint_vals), 0,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_h248_package_3GUP,\r\n&ett_h248_package_3GCSD,\r\n&ett_h248_3GCSD_evt_protres,\r\n&ett_h248_3GCSD_evt_ratechg,\r\n&ett_h248_package_3GTFO,\r\n&ett_h248_3GTFO_evt_status,\r\n&ett_h248_3GTFO_evt_distant_codec_list,\r\n&ett_h248_3GTFO_evt_codec_modify,\r\n&ett_h248_3GTFO_codec_list,\r\n&ett_h248_3GTFO_codec,\r\n&ett_pkg_3GCSD_sig_actprot\r\n};\r\nproto_h248_package_3GUP = proto_register_protocol(PNAME, PSNAME, PFNAME);\r\nproto_register_field_array(proto_h248_package_3GUP, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nh248_register_package(&h248_package_3GUP,REPLACE_PKG);\r\nh248_register_package(&h248_package_3GCSD, REPLACE_PKG);\r\nh248_register_package(&h248_package_3GTFO, REPLACE_PKG);\r\nh248_register_package(&h248_package_threegint, REPLACE_PKG);\r\n}
