static void\r\nio_stat_reset(io_stat_t *io)\r\n{\r\nint i, j;\r\nio->needs_redraw = TRUE;\r\nfor (i=0; i<MAX_GRAPHS; i++) {\r\nfor (j=0; j<NUM_IO_ITEMS; j++) {\r\nio_item_t *ioi;\r\nioi = (io_item_t *)io->graphs[i].items[j];\r\nioi->bytes = 0;\r\n}\r\n}\r\nio->num_items = 0;\r\nio->start_time.secs = time(NULL);\r\nio->start_time.nsecs = 0;\r\n}\r\nstatic guint64\r\nget_it_value(io_stat_t *io, int graph, int idx)\r\n{\r\nio_item_t *it;\r\ng_assert(graph < MAX_GRAPHS);\r\ng_assert(idx < NUM_IO_ITEMS);\r\nit = (io_item_t *)io->graphs[graph].items[idx];\r\nreturn it->bytes;\r\n}\r\nstatic void\r\nprint_interval_string(char *buf, int buf_len, guint32 interval, io_stat_t *io)\r\n{\r\nstruct tm *tmp;\r\ntime_t sec_val = interval/1000 + io->start_time.secs;\r\ngint32 nsec_val = interval%1000 + io->start_time.nsecs/1000000;\r\nif (nsec_val >= 1000) {\r\nsec_val++;\r\nnsec_val -= 1000;\r\n}\r\ntmp = localtime (&sec_val);\r\nif (INTERVAL >= 1000) {\r\ng_snprintf(buf, buf_len, "%02d:%02d:%02d", tmp->tm_hour, tmp->tm_min, tmp->tm_sec);\r\n} else if (INTERVAL >= 100) {\r\ng_snprintf(buf, buf_len, "%02d:%02d:%02d.%1d", tmp->tm_hour, tmp->tm_min, tmp->tm_sec, nsec_val/100);\r\n} else if (INTERVAL >= 10) {\r\ng_snprintf(buf, buf_len, "%02d:%02d:%02d.%02d", tmp->tm_hour, tmp->tm_min, tmp->tm_sec, nsec_val/10);\r\n} else {\r\ng_snprintf(buf, buf_len, "%02d:%02d:%02d.%03d", tmp->tm_hour, tmp->tm_min, tmp->tm_sec, nsec_val);\r\n}\r\n}\r\nstatic void\r\nio_stat_draw(io_stat_t *io)\r\n{\r\nint i;\r\nguint32 last_interval, first_interval, interval_delta;\r\ngint32 current_interval;\r\nguint32 top_y_border;\r\nguint32 bottom_y_border;\r\nPangoLayout *layout;\r\nint label_width, label_height;\r\nguint32 draw_width, draw_height;\r\nGtkAllocation widget_alloc;\r\nguint32 num_time_intervals;\r\nguint64 max_value;\r\nguint32 max_y;\r\ncairo_t *cr;\r\nif (!io->needs_redraw) {\r\nreturn;\r\n}\r\nio->needs_redraw = FALSE;\r\nnum_time_intervals = io->num_items+1;\r\nif (num_time_intervals > NUM_IO_ITEMS) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "IO-Stat error. There are too many entries, bailing out");\r\nreturn;\r\n}\r\nmax_value = 0;\r\nfor (i=0; i<MAX_GRAPHS; i++) {\r\nint idx;\r\nif (!io->graphs[i].display) {\r\ncontinue;\r\n}\r\nfor (idx=0; (guint32)(idx) < num_time_intervals; idx++) {\r\nguint64 val;\r\nval = get_it_value(io, i, idx);\r\nif (val>max_value) {\r\nmax_value = val;\r\n}\r\n}\r\n}\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (io->surface);\r\n#else\r\ncr = gdk_cairo_create (io->pixmap);\r\n#endif\r\ncairo_set_source_rgb (cr, 1, 1, 1);\r\ngtk_widget_get_allocation(io->draw_area, &widget_alloc);\r\ncairo_rectangle (cr, 0, 0, widget_alloc.width,widget_alloc.height);\r\ncairo_fill (cr);\r\ncairo_destroy (cr);\r\nmax_y = yscale_max[MAX_YSCALE-1];\r\nfor (i=MAX_YSCALE-1; i>1; i--) {\r\nif (max_value < yscale_max[i]) {\r\nmax_y = yscale_max[i];\r\n}\r\n}\r\nlayout = gtk_widget_create_pango_layout(io->draw_area, "99999 T bytes");\r\npango_layout_get_pixel_size(layout, &label_width, &label_height);\r\nio->left_x_border = 10;\r\nio->right_x_border = label_width + 20;\r\ntop_y_border = 10;\r\nbottom_y_border = label_height + 20;\r\ndraw_width = io->surface_width-io->right_x_border - io->left_x_border;\r\ndraw_height = io->surface_height-top_y_border - bottom_y_border;\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create(io->surface);\r\n#else\r\ncr = gdk_cairo_create(io->pixmap);\r\n#endif\r\ncairo_set_line_width(cr, 1.0);\r\ncairo_move_to(cr, io->surface_width-io->right_x_border+1.5, top_y_border + 0.5);\r\ncairo_line_to(cr, io->surface_width-io->right_x_border+1.5, io->surface_height-bottom_y_border + 0.5);\r\ncairo_stroke(cr);\r\nfor (i=0; i<=10; i++) {\r\nint xwidth, lwidth, ypos;\r\nxwidth = 5;\r\nif (!(i%5)) {\r\nxwidth = 10;\r\n}\r\nypos = io->surface_height-bottom_y_border-draw_height*i/10;\r\ncairo_move_to(cr, io->surface_width-io->right_x_border+1.5, ypos+0.5);\r\ncairo_line_to(cr, io->surface_width-io->right_x_border+1.5+xwidth,ypos+0.5);\r\ncairo_stroke(cr);\r\nif (xwidth == 10) {\r\nguint32 value = (max_y/10)*i;\r\nchar *label_tmp;\r\nlabel_tmp = format_size(value, format_size_unit_bytes);\r\npango_layout_set_text(layout, label_tmp, -1);\r\npango_layout_get_pixel_size(layout, &lwidth, NULL);\r\ncairo_move_to (cr, io->surface_width-io->right_x_border+15+label_width-lwidth, ypos-label_height/2);\r\npango_cairo_show_layout (cr, layout);\r\ng_free(label_tmp);\r\n}\r\n}\r\nlast_interval = (io->num_items) * INTERVAL;\r\ncairo_move_to(cr, io->left_x_border+0.5, io->surface_height-bottom_y_border+1.5);\r\ncairo_line_to(cr, io->surface_width-io->right_x_border+1.5,io->surface_height-bottom_y_border+1.5);\r\ncairo_stroke(cr);\r\nif ((last_interval/INTERVAL) >= draw_width/io->pixels_per_tick) {\r\nfirst_interval = (last_interval/INTERVAL)-draw_width/io->pixels_per_tick+1;\r\nfirst_interval *= INTERVAL;\r\n} else {\r\nfirst_interval = 0;\r\n}\r\ninterval_delta = (100/io->pixels_per_tick)*INTERVAL;\r\nfor (current_interval = last_interval;\r\ncurrent_interval >= (gint32)first_interval;\r\ncurrent_interval = current_interval-INTERVAL) {\r\nint x, xlen;\r\nif (((io->pixels_per_tick < 5) && (current_interval % (10*INTERVAL))) ||\r\n((io->pixels_per_tick == 5) && (current_interval % (5*INTERVAL)))) {\r\ncontinue;\r\n}\r\nif (!(current_interval%interval_delta)) {\r\nxlen = 10;\r\n} else if (!(current_interval%(interval_delta/2))) {\r\nxlen = 8;\r\n} else {\r\nxlen = 5;\r\n}\r\nx = draw_width+io->left_x_border-((last_interval-current_interval)/INTERVAL)*io->pixels_per_tick;\r\ncairo_move_to(cr, x-1-io->pixels_per_tick/2+0.5, io->surface_height-bottom_y_border+1.5);\r\ncairo_line_to(cr, x-1-io->pixels_per_tick/2+0.5, io->surface_height-bottom_y_border+xlen+1.5);\r\ncairo_stroke(cr);\r\nif (xlen == 10) {\r\nchar label_string[64];\r\nint lwidth, x_pos;\r\nprint_interval_string (label_string, sizeof(label_string), current_interval, io);\r\npango_layout_set_text(layout, label_string, -1);\r\npango_layout_get_pixel_size(layout, &lwidth, NULL);\r\nif ((x-1-io->pixels_per_tick/2-lwidth/2) < 5) {\r\nx_pos = 5;\r\n} else if ((x-1-io->pixels_per_tick/2+lwidth/2) > (io->surface_width-5)) {\r\nx_pos = io->surface_width-lwidth-5;\r\n} else {\r\nx_pos = x-1-io->pixels_per_tick/2-lwidth/2;\r\n}\r\ncairo_move_to (cr, x_pos, io->surface_height-bottom_y_border+15);\r\npango_cairo_show_layout (cr, layout);\r\n}\r\n}\r\ncairo_destroy (cr);\r\ncr = NULL;\r\ng_object_unref(G_OBJECT(layout));\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (io->surface);\r\n#else\r\ncr = gdk_cairo_create (io->pixmap);\r\n#endif\r\ncairo_set_line_width (cr, 1.0);\r\nfor (i=MAX_GRAPHS-1; i>=0; i--) {\r\nguint64 val;\r\nguint32 interval, x_pos, y_pos, prev_x_pos, prev_y_pos;\r\nif (!io->graphs[i].display) {\r\ncontinue;\r\n}\r\nprev_x_pos = draw_width-1 -\r\nio->pixels_per_tick * ((last_interval - first_interval) / INTERVAL) +\r\nio->left_x_border;\r\nval = get_it_value(io, i, first_interval / INTERVAL);\r\nif (val>max_y) {\r\nprev_y_pos = 0;\r\n} else {\r\nprev_y_pos = (guint32)(draw_height-1-(val*draw_height)/max_y+top_y_border);\r\n}\r\nfor (interval = first_interval;\r\ninterval < last_interval;\r\ninterval += INTERVAL) {\r\nx_pos = draw_width-1-io->pixels_per_tick*((last_interval-interval)/INTERVAL)+io->left_x_border;\r\nval = get_it_value(io, i, interval/INTERVAL);\r\nif (val>max_y) {\r\ny_pos = 0;\r\n} else {\r\ny_pos = (guint32)(draw_height - 1 -\r\n((val * draw_height) / max_y) +\r\ntop_y_border);\r\n}\r\nif ( (prev_y_pos != 0) || (y_pos != 0) ) {\r\nstatic GdkRGBA red_color = {1.0, 0.0, 0.1, 1.0};\r\ncairo_move_to(cr, prev_x_pos+0.5, prev_y_pos+0.5);\r\ncairo_line_to(cr, x_pos+0.5, y_pos+0.5);\r\ngdk_cairo_set_source_rgba(cr, &red_color);\r\ncairo_stroke(cr);\r\n}\r\nprev_y_pos = y_pos;\r\nprev_x_pos = x_pos;\r\n}\r\n}\r\ncairo_destroy(cr);\r\ncr = gdk_cairo_create(gtk_widget_get_window(io->draw_area));\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncairo_set_source_surface(cr, io->surface, 0, 0);\r\n#else\r\ngdk_cairo_set_source_pixmap(cr, io->pixmap, 0, 0);\r\n#endif\r\ncairo_rectangle(cr, 0, 0, io->surface_width, io->surface_height);\r\ncairo_fill (cr);\r\ncairo_destroy (cr);\r\n}\r\nstatic void\r\nio_stat_redraw(io_stat_t *io)\r\n{\r\nio->needs_redraw = TRUE;\r\nio_stat_draw(io);\r\n}\r\nstatic void\r\ndraw_area_destroy_cb(GtkWidget *widget _U_, gpointer user_data)\r\n{\r\nio_stat_t *io = (io_stat_t *)user_data;\r\nint i,j;\r\nfor (i=0; i<MAX_GRAPHS; i++) {\r\nif (io->graphs[i].display) {\r\nfor (j=0; j<NUM_IO_ITEMS; j++) {\r\ng_free(io->graphs[i].items[j]);\r\nio->graphs[i].items[j] = NULL;\r\n}\r\n}\r\n}\r\ng_source_remove(io->timer_id);\r\ng_free(io);\r\n}\r\nstatic gboolean\r\ndraw_area_configure_event(GtkWidget *widget, GdkEventConfigure *event _U_, gpointer user_data)\r\n{\r\nio_stat_t *io = (io_stat_t *)user_data;\r\nGtkAllocation widget_alloc;\r\ncairo_t *cr;\r\n#if GTK_CHECK_VERSION(2,22,0)\r\nif (io->surface) {\r\ncairo_surface_destroy (io->surface);\r\nio->surface = NULL;\r\n}\r\n#else\r\nif (io->pixmap) {\r\ng_object_unref(io->pixmap);\r\nio->pixmap = NULL;\r\n}\r\n#endif\r\ngtk_widget_get_allocation(widget, &widget_alloc);\r\n#if GTK_CHECK_VERSION(2,22,0)\r\nio->surface = gdk_window_create_similar_surface (gtk_widget_get_window(widget),\r\nCAIRO_CONTENT_COLOR,\r\nwidget_alloc.width,\r\nwidget_alloc.height);\r\n#else\r\nio->pixmap = gdk_pixmap_new(gtk_widget_get_window(widget),\r\nwidget_alloc.width,\r\nwidget_alloc.height,\r\n-1);\r\n#endif\r\nio->surface_width = widget_alloc.width;\r\nio->surface_height = widget_alloc.height;\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create(io->surface);\r\n#else\r\ncr = gdk_cairo_create(io->pixmap);\r\n#endif\r\ncairo_rectangle(cr, 0, 0, widget_alloc.width, widget_alloc.height);\r\ncairo_set_source_rgb(cr, 1, 1, 1);\r\ncairo_fill(cr);\r\ncairo_destroy(cr);\r\nio_stat_redraw(io);\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\ndraw_area_draw(GtkWidget *widget, cairo_t *cr, gpointer user_data)\r\n{\r\nio_stat_t *io = (io_stat_t *)user_data;\r\nGtkAllocation allocation;\r\ngtk_widget_get_allocation(widget, &allocation);\r\ncairo_set_source_surface(cr, io->surface, 0, 0);\r\ncairo_rectangle(cr, 0, 0, allocation.width, allocation.width);\r\ncairo_fill (cr);\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\ndraw_area_expose_event(GtkWidget *widget, GdkEventExpose *event, gpointer user_data)\r\n{\r\nio_stat_t *io = (io_stat_t *)user_data;\r\ncairo_t *cr = gdk_cairo_create (gtk_widget_get_window(widget));\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncairo_set_source_surface (cr, io->surface, 0, 0);\r\n#else\r\ngdk_cairo_set_source_pixmap (cr, io->pixmap, 0, 0);\r\n#endif\r\ncairo_rectangle (cr, event->area.x, event->area.y, event->area.width, event->area.height);\r\ncairo_fill (cr);\r\ncairo_destroy (cr);\r\nreturn FALSE;\r\n}\r\nstatic void\r\ncreate_draw_area(io_stat_t *io, GtkWidget *box)\r\n{\r\nio->draw_area = gtk_drawing_area_new();\r\ng_signal_connect(io->draw_area, "destroy", G_CALLBACK(draw_area_destroy_cb), io);\r\ngtk_widget_set_size_request(io->draw_area, io->surface_width, io->surface_height);\r\n#if GTK_CHECK_VERSION(3,0,0)\r\ng_signal_connect(io->draw_area, "draw", G_CALLBACK(draw_area_draw), io);\r\n#else\r\ng_signal_connect(io->draw_area, "expose-event", G_CALLBACK(draw_area_expose_event), io);\r\n#endif\r\ng_signal_connect(io->draw_area, "configure-event", G_CALLBACK(draw_area_configure_event), io);\r\ngtk_widget_add_events (io->draw_area, GDK_BUTTON_PRESS_MASK);\r\ngtk_widget_show(io->draw_area);\r\ngtk_box_pack_start(GTK_BOX(box), io->draw_area, TRUE, TRUE, 0);\r\n}\r\nstatic void\r\nfilter_callback(GtkWidget *widget _U_, gpointer user_data)\r\n{\r\nio_stat_graph_t *gio = (io_stat_graph_t *)user_data;\r\nif (!gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(gio->display_button))) {\r\ngio->display = FALSE;\r\ngtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(gio->display_button), FALSE);\r\n} else {\r\ngio->display = TRUE;\r\ngtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(gio->display_button), TRUE);\r\n}\r\ngdk_window_raise(gtk_widget_get_window(gio->io->window));\r\nio_stat_redraw(gio->io);\r\n}\r\nstatic void\r\ncreate_filter_area(io_stat_t *io, GtkWidget *box)\r\n{\r\nGtkWidget *frame;\r\nGtkWidget *hbox;\r\nint i;\r\nframe = gtk_frame_new("Memory Graphs");\r\ngtk_box_pack_start(GTK_BOX(box), frame, TRUE, TRUE, 0);\r\ngtk_widget_show(frame);\r\nhbox = ws_gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 1, FALSE);\r\ngtk_container_add(GTK_CONTAINER(frame), hbox);\r\ngtk_container_set_border_width(GTK_CONTAINER(hbox), 3);\r\ngtk_widget_show(hbox);\r\nfor (i=0; i<MAX_GRAPHS; i++) {\r\nconst char *label = memory_usage_get(i, NULL);\r\nGtkWidget *display_button;\r\nif (!label)\r\nbreak;\r\ndisplay_button = gtk_toggle_button_new_with_label(label);\r\ngtk_box_pack_start(GTK_BOX(hbox), display_button, FALSE, FALSE, 0);\r\ng_signal_connect(display_button, "toggled", G_CALLBACK(filter_callback), &io->graphs[i]);\r\ngtk_widget_show(display_button);\r\nio->graphs[i].display_button = display_button;\r\n}\r\n}\r\nstatic void\r\ninit_io_stat_window(io_stat_t *io)\r\n{\r\nGtkWidget *vbox;\r\nGtkWidget *hbox;\r\nGtkWidget *bbox;\r\nGtkWidget *close_bt;\r\nio->window = dlg_window_new("Wireshark memory usage");\r\ngtk_window_set_destroy_with_parent (GTK_WINDOW(io->window), TRUE);\r\nvbox = ws_gtk_box_new(GTK_ORIENTATION_VERTICAL, 0, FALSE);\r\ngtk_container_add(GTK_CONTAINER(io->window), vbox);\r\ngtk_widget_show(vbox);\r\ncreate_draw_area(io, vbox);\r\nhbox = ws_gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 3, FALSE);\r\ngtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 5);\r\ngtk_container_set_border_width(GTK_CONTAINER(hbox), 3);\r\ngtk_widget_show(hbox);\r\ncreate_filter_area(io, hbox);\r\nbbox = dlg_button_row_new(GTK_STOCK_CLOSE, NULL);\r\ngtk_box_pack_start(GTK_BOX(vbox), bbox, FALSE, FALSE, 0);\r\ngtk_widget_show(bbox);\r\nclose_bt = (GtkWidget *)g_object_get_data(G_OBJECT(bbox), GTK_STOCK_CLOSE);\r\nwindow_set_cancel_button(io->window, close_bt, window_cancel_button_cb);\r\ngtk_widget_set_tooltip_text(close_bt, "Close this dialog");\r\ngtk_widget_show(io->window);\r\nwindow_present(io->window);\r\n}\r\nstatic gboolean\r\ncall_it(gpointer user_data)\r\n{\r\nio_stat_t *io = (io_stat_t *) user_data;\r\nchar buf[64];\r\nchar *tmp;\r\nint idx, i;\r\nio->needs_redraw = TRUE;\r\nidx = io->num_items++;\r\nif ((idx < 0) || (idx >= NUM_IO_ITEMS)) {\r\nio->num_items = NUM_IO_ITEMS-1;\r\nreturn FALSE;\r\n}\r\nfor (i = 0; i < MAX_GRAPHS; i++) {\r\nconst char *label;\r\nlabel = memory_usage_get(i, &io->graphs[i].items[idx]->bytes);\r\nif (!label)\r\nbreak;\r\ntmp = format_size(io->graphs[i].items[idx]->bytes, format_size_unit_bytes);\r\ng_snprintf(buf, sizeof(buf), "%s [%s]", label, tmp);\r\ngtk_button_set_label(GTK_BUTTON(io->graphs[i].display_button), buf);\r\ng_free(tmp);\r\n}\r\nio_stat_draw(io);\r\nreturn TRUE;\r\n}\r\nvoid\r\nmemory_stat_init(void)\r\n{\r\nio_stat_t *io;\r\nint i = 0, j = 0;\r\nio = g_new(io_stat_t,1);\r\nio->needs_redraw = TRUE;\r\nio->window = NULL;\r\nio->draw_area = NULL;\r\n#if GTK_CHECK_VERSION(2,22,0)\r\nio->surface = NULL;\r\n#else\r\nio->pixmap = NULL;\r\n#endif\r\nio->surface_width = 500;\r\nio->surface_height = 200;\r\nio->pixels_per_tick = DEFAULT_PIXELS_PER_TICK;\r\nio->num_items = 0;\r\nio->left_x_border = 0;\r\nio->right_x_border = 500;\r\nio->start_time.secs = time(NULL);\r\nio->start_time.nsecs = 0;\r\nfor (i=0; i<MAX_GRAPHS; i++) {\r\nio->graphs[i].display = 0;\r\nio->graphs[i].display_button = NULL;\r\nio->graphs[i].io = io;\r\nfor (j=0; j<NUM_IO_ITEMS; j++) {\r\nio->graphs[i].items[j] = g_new(io_item_t,1);\r\n}\r\n}\r\nio_stat_reset(io);\r\ninit_io_stat_window(io);\r\nio->graphs[0].display = TRUE;\r\ngtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(io->graphs[0].display_button), TRUE);\r\ngdk_window_raise(gtk_widget_get_window(io->window));\r\nio_stat_redraw(io);\r\nio->timer_id = g_timeout_add(INTERVAL, call_it, io);\r\n}
