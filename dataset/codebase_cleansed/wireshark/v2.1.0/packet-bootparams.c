static int\r\ndissect_bp_address(tvbuff_t *tvb, int offset, proto_tree *tree, int hfindex)\r\n{\r\nguint32 type;\r\nguint32 ipaddr;\r\ntype = tvb_get_ntohl(tvb, offset);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_bootparams_addresstype, offset);\r\nswitch(type){\r\ncase 1:\r\nipaddr = ((tvb_get_guint8(tvb, offset+3 )&0xff)<<24)\r\n|((tvb_get_guint8(tvb, offset+7 )&0xff)<<16)\r\n|((tvb_get_guint8(tvb, offset+11)&0xff)<<8 )\r\n|((tvb_get_guint8(tvb, offset+15)&0xff) );\r\nproto_tree_add_ipv4(tree, hfindex, tvb,\r\noffset, 16, g_ntohl(ipaddr));\r\noffset += 16;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_getfile_call(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_string(tvb, tree, hf_bootparams_host, offset, NULL);\r\noffset = dissect_rpc_string(tvb, tree, hf_bootparams_fileid, offset, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_getfile_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_string(tvb, tree, hf_bootparams_host, offset, NULL);\r\noffset = dissect_bp_address(tvb, offset, tree, hf_bootparams_hostaddr);\r\noffset = dissect_rpc_string(tvb, tree, hf_bootparams_filepath, offset, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_whoami_call(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = dissect_bp_address(tvb, 0, tree, hf_bootparams_hostaddr);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_whoami_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_string(tvb, tree, hf_bootparams_host, offset, NULL);\r\noffset = dissect_rpc_string(tvb, tree, hf_bootparams_domain, offset, NULL);\r\noffset = dissect_bp_address(tvb, offset, tree, hf_bootparams_routeraddr);\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_bootparams(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_bootparams_procedure_v1, {\r\n"V1 Procedure", "bootparams.procedure_v1", FT_UINT32, BASE_DEC,\r\nVALS(bootparams1_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_bootparams_host, {\r\n"Client Host", "bootparams.host", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_bootparams_domain, {\r\n"Client Domain", "bootparams.domain", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_bootparams_fileid, {\r\n"File ID", "bootparams.fileid", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_bootparams_filepath, {\r\n"File Path", "bootparams.filepath", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_bootparams_hostaddr, {\r\n"Client Address", "bootparams.hostaddr", FT_IPv4, BASE_NONE,\r\nNULL, 0, "Address", HFILL }},\r\n{ &hf_bootparams_routeraddr, {\r\n"Router Address", "bootparams.routeraddr", FT_IPv4, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_bootparams_addresstype, {\r\n"Address Type", "bootparams.type", FT_UINT32, BASE_DEC,\r\nVALS(addr_type), 0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_bootparams,\r\n};\r\nproto_bootparams = proto_register_protocol("Boot Parameters",\r\n"BOOTPARAMS", "bootparams");\r\nproto_register_field_array(proto_bootparams, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_bootparams(void)\r\n{\r\nrpc_init_prog(proto_bootparams, BOOTPARAMS_PROGRAM, ett_bootparams,\r\nG_N_ELEMENTS(bootparams_vers_info), bootparams_vers_info);\r\n}
