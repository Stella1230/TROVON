static gboolean\r\nstring_walk(GList* arg1list, GList **retval, gchar(*conv_func)(gchar))\r\n{\r\nGList *arg1;\r\nfvalue_t *arg_fvalue;\r\nfvalue_t *new_ft_string;\r\nchar *s, *c;\r\narg1 = arg1list;\r\nwhile (arg1) {\r\narg_fvalue = (fvalue_t *)arg1->data;\r\nif (IS_FT_STRING(fvalue_type_ftenum(arg_fvalue))) {\r\ns = (char *)wmem_strdup(NULL, (gchar *)fvalue_get(arg_fvalue));\r\nfor (c = s; *c; c++) {\r\n*c = conv_func(*c);\r\n}\r\nnew_ft_string = fvalue_new(FT_STRING);\r\nfvalue_set_string(new_ft_string, s);\r\nwmem_free(NULL, s);\r\n*retval = g_list_append(*retval, new_ft_string);\r\n}\r\narg1 = arg1->next;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\ndf_func_lower(GList* arg1list, GList *arg2junk _U_, GList **retval)\r\n{\r\nreturn string_walk(arg1list, retval, g_ascii_tolower);\r\n}\r\nstatic gboolean\r\ndf_func_upper(GList* arg1list, GList *arg2junk _U_, GList **retval)\r\n{\r\nreturn string_walk(arg1list, retval, g_ascii_toupper);\r\n}\r\nstatic gboolean\r\ndf_func_len(GList* arg1list, GList *arg2junk _U_, GList **retval)\r\n{\r\nGList *arg1;\r\nfvalue_t *arg_fvalue;\r\nfvalue_t *ft_len;\r\narg1 = arg1list;\r\nwhile (arg1) {\r\narg_fvalue = (fvalue_t *)arg1->data;\r\nif (IS_FT_STRING(fvalue_type_ftenum(arg_fvalue))) {\r\nft_len = fvalue_new(FT_UINT32);\r\nfvalue_set_uinteger(ft_len, (guint) strlen((char *)fvalue_get(arg_fvalue)));\r\n*retval = g_list_append(*retval, ft_len);\r\n}\r\narg1 = arg1->next;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\ndf_func_size(GList* arg1list, GList *arg2junk _U_, GList **retval)\r\n{\r\nGList *arg1;\r\nfvalue_t *arg_fvalue;\r\nfvalue_t *ft_len;\r\narg1 = arg1list;\r\nwhile (arg1) {\r\narg_fvalue = (fvalue_t *)arg1->data;\r\nft_len = fvalue_new(FT_UINT32);\r\nfvalue_set_uinteger(ft_len, fvalue_length(arg_fvalue));\r\n*retval = g_list_append(*retval, ft_len);\r\narg1 = arg1->next;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\ndf_func_count(GList* arg1list, GList *arg2junk _U_, GList **retval)\r\n{\r\nfvalue_t *ft_ret;\r\nguint32 num_items;\r\nnum_items = (guint32)g_list_length(arg1list);\r\nft_ret = fvalue_new(FT_UINT32);\r\nfvalue_set_uinteger(ft_ret, num_items);\r\n*retval = g_list_append(*retval, ft_ret);\r\nreturn TRUE;\r\n}\r\nstatic void\r\nul_semcheck_params(dfwork_t *dfw, int param_num, stnode_t *st_node)\r\n{\r\nsttype_id_t type;\r\nftenum_t ftype;\r\nheader_field_info *hfinfo;\r\ntype = stnode_type_id(st_node);\r\nif (param_num == 0) {\r\nswitch(type) {\r\ncase STTYPE_FIELD:\r\nhfinfo = (header_field_info *)stnode_data(st_node);\r\nftype = hfinfo->type;\r\nif (!IS_FT_STRING(ftype)) {\r\ndfilter_fail(dfw, "Only strings can be used in upper() or lower() or len()");\r\nTHROW(TypeError);\r\n}\r\nbreak;\r\ndefault:\r\ndfilter_fail(dfw, "Only string-type fields can be used in upper() or lower() or len()");\r\nTHROW(TypeError);\r\n}\r\n}\r\nelse {\r\ng_assert_not_reached();\r\n}\r\n}\r\nstatic void\r\nul_semcheck_field_param(dfwork_t *dfw, int param_num, stnode_t *st_node)\r\n{\r\nsttype_id_t type;\r\ntype = stnode_type_id(st_node);\r\nif (param_num == 0) {\r\nswitch(type) {\r\ncase STTYPE_FIELD:\r\nbreak;\r\ndefault:\r\ndfilter_fail(dfw, "Only type fields can be used as parameter "\r\n"for size() or count()");\r\nTHROW(TypeError);\r\n}\r\n}\r\nelse {\r\ng_assert_not_reached();\r\n}\r\n}\r\ndf_func_def_t*\r\ndf_func_lookup(char *name)\r\n{\r\ndf_func_def_t *func_def;\r\nfunc_def = df_functions;\r\nwhile (func_def->function != NULL) {\r\nif (strcmp(func_def->name, name) == 0) {\r\nreturn func_def;\r\n}\r\nfunc_def++;\r\n}\r\nreturn NULL;\r\n}
