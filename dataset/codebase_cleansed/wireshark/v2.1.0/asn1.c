void asn1_ctx_init(asn1_ctx_t *actx, asn1_enc_e encoding, gboolean aligned, packet_info *pinfo) {\r\nmemset(actx, '\0', sizeof(*actx));\r\nactx->signature = ASN1_CTX_SIGNATURE;\r\nactx->encoding = encoding;\r\nactx->aligned = aligned;\r\nactx->pinfo = pinfo;\r\n}\r\ngboolean asn1_ctx_check_signature(asn1_ctx_t *actx) {\r\nreturn actx && (actx->signature == ASN1_CTX_SIGNATURE);\r\n}\r\nvoid asn1_ctx_clean_external(asn1_ctx_t *actx) {\r\nmemset(&actx->external, '\0', sizeof(actx->external));\r\nactx->external.hf_index = -1;\r\nactx->external.encoding = -1;\r\n}\r\nvoid asn1_ctx_clean_epdv(asn1_ctx_t *actx) {\r\nmemset(&actx->embedded_pdv, '\0', sizeof(actx->embedded_pdv));\r\nactx->embedded_pdv.hf_index = -1;\r\nactx->embedded_pdv.identification = -1;\r\n}\r\nvoid asn1_stack_frame_push(asn1_ctx_t *actx, const gchar *name) {\r\nasn1_stack_frame_t *frame;\r\nframe = wmem_new0(wmem_packet_scope(), asn1_stack_frame_t);\r\nframe->name = name;\r\nframe->next = actx->stack;\r\nactx->stack = frame;\r\n}\r\nvoid asn1_stack_frame_pop(asn1_ctx_t *actx, const gchar *name) {\r\nDISSECTOR_ASSERT(actx->stack);\r\nDISSECTOR_ASSERT(!strcmp(actx->stack->name, name));\r\nactx->stack = actx->stack->next;\r\n}\r\nvoid asn1_stack_frame_check(asn1_ctx_t *actx, const gchar *name, const asn1_par_def_t *par_def) {\r\nconst asn1_par_def_t *pd = par_def;\r\nasn1_par_t *par;\r\nDISSECTOR_ASSERT(actx->stack);\r\nDISSECTOR_ASSERT(!strcmp(actx->stack->name, name));\r\npar = actx->stack->par;\r\nwhile (pd->name) {\r\nDISSECTOR_ASSERT(par);\r\nDISSECTOR_ASSERT((pd->ptype == ASN1_PAR_IRR) || (par->ptype == pd->ptype));\r\npar->name = pd->name;\r\npd++;\r\npar = par->next;\r\n}\r\nDISSECTOR_ASSERT(!par);\r\n}\r\nstatic asn1_par_t *get_par_by_name(asn1_ctx_t *actx, const gchar *name) {\r\nasn1_par_t *par = NULL;\r\nDISSECTOR_ASSERT(actx->stack);\r\npar = actx->stack->par;\r\nwhile (par) {\r\nif (!strcmp(par->name, name))\r\nreturn par;\r\npar = par->next;\r\n}\r\nreturn par;\r\n}\r\nstatic asn1_par_t *push_new_par(asn1_ctx_t *actx) {\r\nasn1_par_t *par, **pp;\r\nDISSECTOR_ASSERT(actx->stack);\r\npar = wmem_new0(wmem_packet_scope(), asn1_par_t);\r\npp = &(actx->stack->par);\r\nwhile (*pp)\r\npp = &((*pp)->next);\r\n*pp = par;\r\nreturn par;\r\n}\r\nvoid asn1_param_push_boolean(asn1_ctx_t *actx, gboolean value) {\r\nasn1_par_t *par;\r\npar = push_new_par(actx);\r\npar->ptype = ASN1_PAR_BOOLEAN;\r\npar->value.v_boolean = value;\r\n}\r\nvoid asn1_param_push_integer(asn1_ctx_t *actx, gint32 value) {\r\nasn1_par_t *par;\r\npar = push_new_par(actx);\r\npar->ptype = ASN1_PAR_INTEGER;\r\npar->value.v_integer = value;\r\n}\r\ngboolean asn1_param_get_boolean(asn1_ctx_t *actx, const gchar *name) {\r\nasn1_par_t *par = NULL;\r\npar = get_par_by_name(actx, name);\r\nDISSECTOR_ASSERT(par);\r\nreturn par->value.v_boolean;\r\n}\r\ngint32 asn1_param_get_integer(asn1_ctx_t *actx, const gchar *name) {\r\nasn1_par_t *par = NULL;\r\npar = get_par_by_name(actx, name);\r\nDISSECTOR_ASSERT(par);\r\nreturn par->value.v_integer;\r\n}\r\nvoid rose_ctx_init(rose_ctx_t *rctx) {\r\nmemset(rctx, '\0', sizeof(*rctx));\r\nrctx->signature = ROSE_CTX_SIGNATURE;\r\n}\r\ngboolean rose_ctx_check_signature(rose_ctx_t *rctx) {\r\nreturn rctx && (rctx->signature == ROSE_CTX_SIGNATURE);\r\n}\r\nvoid rose_ctx_clean_data(rose_ctx_t *rctx) {\r\nmemset(&rctx->d, '\0', sizeof(rctx->d));\r\nrctx->d.code = -1;\r\n}\r\nasn1_ctx_t *get_asn1_ctx(void *ptr) {\r\nasn1_ctx_t *actx = (asn1_ctx_t*)ptr;\r\nif (!asn1_ctx_check_signature(actx))\r\nactx = NULL;\r\nreturn actx;\r\n}\r\nrose_ctx_t *get_rose_ctx(void *ptr) {\r\nrose_ctx_t *rctx = (rose_ctx_t*)ptr;\r\nasn1_ctx_t *actx = (asn1_ctx_t*)ptr;\r\nif (!asn1_ctx_check_signature(actx))\r\nactx = NULL;\r\nif (actx)\r\nrctx = actx->rose_ctx;\r\nif (!rose_ctx_check_signature(rctx))\r\nrctx = NULL;\r\nreturn rctx;\r\n}\r\ndouble asn1_get_real(const guint8 *real_ptr, gint len) {\r\nguint8 octet;\r\nconst guint8 *p;\r\nguint8 *buf;\r\ndouble val = 0;\r\nif (len < 1) return val;\r\noctet = real_ptr[0];\r\np = real_ptr + 1;\r\nlen -= 1;\r\nif (octet & 0x80) {\r\nint i;\r\ngboolean Eneg;\r\ngint8 S;\r\nguint8 B;\r\nguint8 F;\r\ngint32 E = 0;\r\nguint64 N = 0;\r\nguint8 lenE, lenN;\r\nif(octet & 0x40) S = -1; else S = 1;\r\nswitch(octet & 0x30) {\r\ncase 0x00: B = 2; break;\r\ncase 0x10: B = 8; break;\r\ncase 0x20: B = 16; break;\r\ncase 0x30:\r\ndefault:\r\nreturn 0;\r\n}\r\nF = (octet & 0x0c) >> 2;\r\nlenE = (octet & 0x3) + 1;\r\nif(lenE == 4)\r\n{\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\n}\r\nEneg = (*p) & 0x80 ? TRUE : FALSE;\r\nfor (i = 0; i < lenE; i++) {\r\nif(Eneg) {\r\nE = (E<<8) | ((guint8) ~(*p));\r\n} else {\r\nE = (E<<8) | *p;\r\n}\r\np++;\r\n}\r\nif(Eneg) {\r\nE = -(E + 1);\r\n}\r\nlenN = len - lenE;\r\nif(lenN > 8)\r\n{\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\n}\r\nfor (i=0; i<lenN; i++) {\r\nN = (N<<8) | *p;\r\np++;\r\n}\r\nval = (double) S * N * pow(2, F) * pow(B, E);\r\n#ifdef DEBUG\r\nprintf("S = %d, N = %lu, F = %u, B = %u, E = %d -> %f\n", S, N, F, B, E, val);\r\n#endif\r\n} else if (octet & 0x40) {\r\nswitch (octet & 0x3F) {\r\ncase 0x00: val = HUGE_VAL; break;\r\ncase 0x01: val = -HUGE_VAL; break;\r\n}\r\n} else {\r\nbuf = g_strndup(p, len);\r\nval = g_ascii_strtod(buf, NULL);\r\ng_free(buf);\r\n}\r\nreturn val;\r\n}
