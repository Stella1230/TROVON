static int getnum (const gchar **fmt, int df) {\r\nif (!g_ascii_isdigit(**fmt))\r\nreturn df;\r\nelse {\r\nint a = 0;\r\ndo {\r\na = a*10 + *((*fmt)++) - '0';\r\n} while (g_ascii_isdigit(**fmt));\r\nreturn a;\r\n}\r\n}\r\nstatic size_t optsize (lua_State *L, gchar opt, const gchar **fmt) {\r\nswitch (opt) {\r\ncase 'B': case 'b': return sizeof(gchar);\r\ncase 'H': case 'h': return sizeof(gshort);\r\ncase 'L': case 'l': return sizeof(glong);\r\ncase 'E': case 'e': return sizeof(gint64);\r\ncase 'T': return sizeof(size_t);\r\ncase 'f': return sizeof(gfloat);\r\ncase 'd': return sizeof(gdouble);\r\ncase 'x': return getnum(fmt, 1);\r\ncase 'X': return getnum(fmt, MAXALIGN);\r\ncase 'c': return getnum(fmt, 1);\r\ncase 'i': case 'I': {\r\nint sz = getnum(fmt, sizeof(int));\r\nif (sz > MAXINTSIZE)\r\nluaL_error(L, "integral size %d is larger than limit of %d",\r\nsz, MAXINTSIZE);\r\nreturn sz;\r\n}\r\ncase 's': case ' ':\r\ncase '<': case '>':\r\ncase '(': case ')':\r\ncase '!': case '=':\r\nreturn 0;\r\ndefault: {\r\nconst gchar *msg = lua_pushfstring(L, "invalid format option [%c]", opt);\r\nreturn luaL_argerror(L, 1, msg);\r\n}\r\n}\r\n}\r\nstatic int gettoalign (size_t len, Header *h, int opt, size_t size) {\r\nif (size == 0 || opt == 'c' || opt == 's') return 0;\r\nif (size > (size_t)h->align)\r\nsize = h->align;\r\nreturn (int)((size - (len & (size - 1))) & (size - 1));\r\n}\r\nstatic void controloptions (lua_State *L, int opt, const gchar **fmt,\r\nHeader *h) {\r\nswitch (opt) {\r\ncase ' ': return;\r\ncase '>': h->endian = BIG; return;\r\ncase '<': h->endian = LITTLE; return;\r\ncase '(': h->noassign = TRUE; return;\r\ncase ')': h->noassign = FALSE; return;\r\ncase '!': {\r\nint a = getnum(fmt, MAXALIGN);\r\nif (!isp2(a))\r\nluaL_error(L, "alignment %d is not a power of 2", a);\r\nh->align = a;\r\nreturn;\r\n}\r\ndefault: {\r\nconst char *msg = lua_pushfstring(L, "invalid format option '%c'", opt);\r\nluaL_argerror(L, 1, msg);\r\n}\r\n}\r\n}\r\nstatic void putinteger (lua_State *L, luaL_Buffer *b, int arg, int endian,\r\nint size) {\r\nlua_Number n = luaL_checknumber(L, arg);\r\ngint64 value;\r\ngchar buff[MAXINTSIZE];\r\nif (n < 0)\r\nvalue = (guint64)(gint64)n;\r\nelse\r\nvalue = (guint64)n;\r\nif (endian == LITTLE) {\r\nint i;\r\nfor (i = 0; i < size; i++) {\r\nbuff[i] = (value & 0xff);\r\nvalue >>= 8;\r\n}\r\n}\r\nelse {\r\nint i;\r\nfor (i = size - 1; i >= 0; i--) {\r\nbuff[i] = (value & 0xff);\r\nvalue >>= 8;\r\n}\r\n}\r\nluaL_addlstring(b, buff, size);\r\n}\r\nstatic void correctbytes (gchar *b, int size, int endian) {\r\nif (endian != native.endian) {\r\nint i = 0;\r\nwhile (i < --size) {\r\ngchar temp = b[i];\r\nb[i++] = b[size];\r\nb[size] = temp;\r\n}\r\n}\r\n}\r\nWSLUA_CONSTRUCTOR Struct_pack (lua_State *L) {\r\n#define WSLUA_ARG_Struct_pack_FORMAT 1\r\n#define WSLUA_ARG_Struct_pack_VALUE 2\r\nluaL_Buffer b;\r\nconst char *fmt = wslua_checkstring_only(L, WSLUA_ARG_Struct_pack_FORMAT);\r\nHeader h;\r\nint poscnt = 0;\r\nint posBuf[10];\r\nint arg = 2;\r\nsize_t totalsize = 0;\r\ndefaultoptions(&h);\r\nlua_pushnil(L);\r\nluaL_buffinit(L, &b);\r\nwhile (*fmt != '\0') {\r\nint opt = *fmt++;\r\nsize_t size = optsize(L, opt, &fmt);\r\nint toalign = gettoalign(totalsize, &h, opt, size);\r\ntotalsize += toalign;\r\nwhile (toalign-- > 0) luaL_addchar(&b, '\0');\r\nif (opt == 'X') size = 0;\r\nif (h.noassign && size) opt = 'x';\r\nswitch (opt) {\r\ncase 'b': case 'B': case 'h': case 'H':\r\ncase 'l': case 'L': case 'T': case 'i': case 'I': {\r\nputinteger(L, &b, arg++, h.endian, (int)size);\r\nbreak;\r\n}\r\ncase 'e': {\r\nInt64_pack(L, &b, arg++, h.endian == LITTLE);\r\nbreak;\r\n}\r\ncase 'E': {\r\nUInt64_pack(L, &b, arg++, h.endian == LITTLE);\r\nbreak;\r\n}\r\ncase 'x': case 'X': {\r\nsize_t len = size;\r\nwhile (len-- > 0)\r\nluaL_addchar(&b, '\0');\r\nbreak;\r\n}\r\ncase 'f': {\r\ngfloat f = (gfloat)luaL_checknumber(L, arg++);\r\ncorrectbytes((gchar *)&f, (int)size, h.endian);\r\nluaL_addlstring(&b, (gchar *)&f, size);\r\nbreak;\r\n}\r\ncase 'd': {\r\ngdouble d = luaL_checknumber(L, arg++);\r\ncorrectbytes((gchar *)&d, (int)size, h.endian);\r\nluaL_addlstring(&b, (gchar *)&d, size);\r\nbreak;\r\n}\r\ncase 'c': case 's': {\r\nsize_t l;\r\nconst gchar *s = luaL_checklstring(L, arg++, &l);\r\nif (size == 0) size = l;\r\nluaL_argcheck(L, l >= (size_t)size, arg, "string too short");\r\nluaL_addlstring(&b, s, size);\r\nif (opt == 's') {\r\nluaL_addchar(&b, '\0');\r\nsize++;\r\n}\r\nbreak;\r\n}\r\ncase '=': {\r\nif (poscnt < (int)(sizeof(posBuf)/sizeof(posBuf[0])))\r\nposBuf[poscnt++] = (int)totalsize + 1;\r\nbreak;\r\n}\r\ndefault: controloptions(L, opt, &fmt, &h);\r\n}\r\ntotalsize += size;\r\n}\r\nluaL_pushresult(&b);\r\nfor (arg = 0; arg < poscnt; arg++)\r\nlua_pushinteger(L, posBuf[arg]);\r\nWSLUA_RETURN(poscnt + 1);\r\n}\r\nstatic lua_Number getinteger (const gchar *buff, int endian,\r\nint issigned, int size) {\r\nUinttype l = 0;\r\nint i;\r\nif (endian == BIG) {\r\nfor (i = 0; i < size; i++) {\r\nl <<= 8;\r\nl |= (Uinttype)(guchar)buff[i];\r\n}\r\n}\r\nelse {\r\nfor (i = size - 1; i >= 0; i--) {\r\nl <<= 8;\r\nl |= (Uinttype)(guchar)buff[i];\r\n}\r\n}\r\nif (!issigned)\r\nreturn (lua_Number)l;\r\nelse {\r\nUinttype mask = (Uinttype)(~((Uinttype)0)) << (size*8 - 1);\r\nif (l & mask)\r\nl |= mask;\r\nreturn (lua_Number)(Inttype)l;\r\n}\r\n}\r\nWSLUA_CONSTRUCTOR Struct_unpack (lua_State *L) {\r\n#define WSLUA_ARG_Struct_unpack_FORMAT 1\r\n#define WSLUA_ARG_Struct_unpack_STRUCT 2\r\n#define WSLUA_OPTARG_Struct_unpack_BEGIN 3\r\nHeader h;\r\nconst char *fmt = wslua_checkstring_only(L, WSLUA_ARG_Struct_unpack_FORMAT);\r\nsize_t ld;\r\nconst char *data = wslua_checklstring_only(L, WSLUA_ARG_Struct_unpack_STRUCT, &ld);\r\nsize_t pos = luaL_optinteger(L, WSLUA_OPTARG_Struct_unpack_BEGIN, 1) - 1;\r\ndefaultoptions(&h);\r\nlua_settop(L, 2);\r\nwhile (*fmt) {\r\nint opt = *fmt++;\r\nsize_t size = optsize(L, opt, &fmt);\r\npos += gettoalign(pos, &h, opt, size);\r\nluaL_argcheck(L, pos+size <= ld, 2, "data string too short");\r\nif (opt == 'X') size = 0;\r\nif (h.noassign && size > 0) {\r\npos += size;\r\ncontinue;\r\n}\r\nluaL_checkstack(L, 1, "too many results");\r\nswitch (opt) {\r\ncase 'b': case 'B': case 'h': case 'H':\r\ncase 'l': case 'L': case 'T': case 'i': case 'I': {\r\nint issigned = g_ascii_islower(opt);\r\nlua_Number res = getinteger(data+pos, h.endian, issigned, (int)size);\r\nlua_pushnumber(L, res);\r\nbreak;\r\n}\r\ncase 'e': {\r\nInt64_unpack(L, data+pos, h.endian == LITTLE);\r\nbreak;\r\n}\r\ncase 'E': {\r\nUInt64_unpack(L, data+pos, h.endian == LITTLE);\r\nbreak;\r\n}\r\ncase 'x': case 'X': {\r\nbreak;\r\n}\r\ncase 'f': {\r\ngfloat f;\r\nmemcpy(&f, data+pos, size);\r\ncorrectbytes((gchar *)&f, sizeof(f), h.endian);\r\nlua_pushnumber(L, f);\r\nbreak;\r\n}\r\ncase 'd': {\r\ngdouble d;\r\nmemcpy(&d, data+pos, size);\r\ncorrectbytes((gchar *)&d, sizeof(d), h.endian);\r\nlua_pushnumber(L, d);\r\nbreak;\r\n}\r\ncase 'c': {\r\nif (size == 0) {\r\nif (!lua_isnumber(L, -1))\r\nluaL_error(L, "format `c0' needs a previous size");\r\nsize = wslua_toguint32(L, -1);\r\nlua_pop(L, 1);\r\nluaL_argcheck(L, pos+size <= ld, 2, "data string too short");\r\n}\r\nif (!h.noassign)\r\nlua_pushlstring(L, data+pos, size);\r\nbreak;\r\n}\r\ncase 's': {\r\nconst gchar *e = (const char *)memchr(data+pos, '\0', ld - pos);\r\nif (e == NULL)\r\nluaL_error(L, "unfinished string in data");\r\nsize = (e - (data+pos)) + 1;\r\nif (!h.noassign)\r\nlua_pushlstring(L, data+pos, size - 1);\r\nbreak;\r\n}\r\ncase '=': {\r\nlua_pushinteger(L, pos + 1);\r\nbreak;\r\n}\r\ndefault: controloptions(L, opt, &fmt, &h);\r\n}\r\npos += size;\r\n}\r\nlua_pushinteger(L, pos + 1);\r\nWSLUA_RETURN(lua_gettop(L) - 2);\r\n}\r\nWSLUA_CONSTRUCTOR Struct_size (lua_State *L) {\r\n#define WSLUA_ARG_Struct_size_FORMAT 1\r\nHeader h;\r\nconst gchar *fmt = wslua_checkstring_only(L, WSLUA_ARG_Struct_size_FORMAT);\r\nsize_t pos = 0;\r\ndefaultoptions(&h);\r\nwhile (*fmt) {\r\nint opt = *fmt++;\r\nsize_t size = optsize(L, opt, &fmt);\r\npos += gettoalign(pos, &h, opt, size);\r\nif (opt == 's')\r\nluaL_argerror(L, 1, "option 's' has no fixed size");\r\nelse if (opt == 'c' && size == 0)\r\nluaL_argerror(L, 1, "option 'c0' has no fixed size");\r\nif (!g_ascii_isalnum(opt))\r\ncontroloptions(L, opt, &fmt, &h);\r\npos += size;\r\n}\r\nlua_pushinteger(L, pos);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_CONSTRUCTOR Struct_values (lua_State *L) {\r\n#define WSLUA_ARG_Struct_values_FORMAT 1\r\nHeader h;\r\nconst gchar *fmt = wslua_checkstring_only(L, WSLUA_ARG_Struct_values_FORMAT);\r\nsize_t vals = 0;\r\ndefaultoptions(&h);\r\nwhile (*fmt) {\r\nint opt = *fmt++;\r\nsize_t size = optsize(L, opt, &fmt);\r\nswitch (opt) {\r\ncase 's': case 'c':\r\nsize = 1;\r\nbreak;\r\ncase 'x': case 'X':\r\nsize = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!g_ascii_isalnum(opt))\r\ncontroloptions(L, opt, &fmt, &h);\r\nelse if (size && !h.noassign)\r\nvals++;\r\n}\r\nlua_pushinteger(L, vals);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_CONSTRUCTOR Struct_tohex (lua_State *L) {\r\n#define WSLUA_ARG_Struct_tohex_BYTESTRING 1\r\n#define WSLUA_OPTARG_Struct_tohex_LOWERCASE 2\r\n#define WSLUA_OPTARG_Struct_tohex_SEPARATOR 3\r\nconst gchar* s = NULL;\r\nsize_t len = 0;\r\ngboolean lowercase = FALSE;\r\nconst gchar* sep = NULL;\r\ns = luaL_checklstring(L, WSLUA_ARG_Struct_tohex_BYTESTRING, &len);\r\nlowercase = wslua_optbool(L,WSLUA_OPTARG_Struct_tohex_LOWERCASE,FALSE);\r\nsep = luaL_optstring(L,WSLUA_OPTARG_Struct_tohex_SEPARATOR,NULL);\r\nwslua_bin2hex(L, s, (guint)len, lowercase, sep);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_CONSTRUCTOR Struct_fromhex (lua_State *L) {\r\n#define WSLUA_ARG_Struct_fromhex_HEXBYTES 1\r\n#define WSLUA_OPTARG_Struct_fromhex_SEPARATOR 2\r\nconst gchar* s = NULL;\r\nsize_t len = 0;\r\nconst gchar* sep = NULL;\r\ns = wslua_checklstring_only(L, WSLUA_ARG_Struct_fromhex_HEXBYTES, &len);\r\nsep = luaL_optstring(L,WSLUA_OPTARG_Struct_fromhex_SEPARATOR,NULL);\r\nwslua_hex2bin(L, s, (guint)len, sep);\r\nWSLUA_RETURN(1);\r\n}\r\nstatic int Struct__gc(lua_State* L _U_) {\r\nreturn 0;\r\n}\r\nLUALIB_API int Struct_register(lua_State* L) {\r\nWSLUA_REGISTER_CLASS(Struct);\r\nreturn 0;\r\n}
