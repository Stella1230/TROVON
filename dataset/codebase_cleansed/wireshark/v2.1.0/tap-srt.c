static void\r\ndraw_srt_table_data(srt_stat_table *rst, gboolean draw_footer)\r\n{\r\nint i;\r\nguint64 td;\r\nguint64 sum;\r\nif (rst->num_procs > 0) {\r\nprintf("Filter: %s\n", rst->filter_string ? rst->filter_string : "");\r\nprintf("Index %-22s Calls Min SRT Max SRT Avg SRT Sum SRT\n", (rst->proc_column_name != NULL) ? rst->proc_column_name : "Procedure");\r\n}\r\nfor(i=0;i<rst->num_procs;i++){\r\nif(rst->procedures[i].stats.num==0){\r\ncontinue;\r\n}\r\ntd = ((guint64)(rst->procedures[i].stats.tot.secs))*NANOSECS_PER_SEC + rst->procedures[i].stats.tot.nsecs;\r\nsum = (td + 500) / 1000;\r\ntd = ((td / rst->procedures[i].stats.num) + 500) / 1000;\r\nprintf("%5d %-22s %6u %3d.%06d %3d.%06d %3d.%06d %3d.%06d\n",\r\ni, rst->procedures[i].procedure,\r\nrst->procedures[i].stats.num,\r\n(int)rst->procedures[i].stats.min.secs, (rst->procedures[i].stats.min.nsecs+500)/1000,\r\n(int)rst->procedures[i].stats.max.secs, (rst->procedures[i].stats.max.nsecs+500)/1000,\r\n(int)(td/1000000), (int)(td%1000000),\r\n(int)(sum/1000000), (int)(sum%1000000)\r\n);\r\n}\r\nif (draw_footer)\r\nprintf("==================================================================\n");\r\n}\r\nstatic void\r\nsrt_draw(void *arg)\r\n{\r\nguint i = 0;\r\nsrt_data_t* data = (srt_data_t*)arg;\r\nsrt_t *ui = (srt_t *)data->user_data;\r\nsrt_stat_table *srt_table;\r\ngboolean need_newline = FALSE;\r\nprintf("\n");\r\nprintf("===================================================================\n");\r\nprintf("%s SRT Statistics:\n", ui->type);\r\nsrt_table = g_array_index(data->srt_array, srt_stat_table*, i);\r\ndraw_srt_table_data(srt_table, data->srt_array->len == 1);\r\nif (srt_table->num_procs > 0) {\r\nneed_newline = TRUE;\r\n}\r\nfor (i = 1; i < data->srt_array->len; i++)\r\n{\r\nif (need_newline)\r\n{\r\nprintf("\n");\r\nneed_newline = FALSE;\r\n}\r\nsrt_table = g_array_index(data->srt_array, srt_stat_table*, i);\r\ndraw_srt_table_data(srt_table, i == data->srt_array->len-1);\r\nif (srt_table->num_procs > 0) {\r\nneed_newline = TRUE;\r\n}\r\n}\r\n}\r\nstatic void\r\ninit_srt_tables(register_srt_t* srt, const char *filter)\r\n{\r\nsrt_t *ui;\r\nGString *error_string;\r\nui = g_new0(srt_t, 1);\r\nui->type = proto_get_protocol_short_name(find_protocol_by_id(get_srt_proto_id(srt)));\r\nui->filter = g_strdup(filter);\r\nui->data.srt_array = global_srt_array;\r\nui->data.user_data = ui;\r\nerror_string = register_tap_listener(get_srt_tap_listener_name(srt), &ui->data, filter, 0, NULL, get_srt_packet_func(srt), srt_draw);\r\nif (error_string) {\r\nfree_srt_table(srt, global_srt_array, NULL, NULL);\r\ng_free(ui);\r\nfprintf(stderr, "tshark: Couldn't register srt tap: %s\n", error_string->str);\r\ng_string_free(error_string, TRUE);\r\nexit(1);\r\n}\r\n}\r\nstatic void\r\ndissector_srt_init(const char *opt_arg, void* userdata)\r\n{\r\nregister_srt_t *srt = (register_srt_t*)userdata;\r\nconst char *filter=NULL;\r\nchar* err;\r\nsrt_table_get_filter(srt, opt_arg, &filter, &err);\r\nif (err != NULL)\r\n{\r\ngchar* cmd_str = srt_table_get_tap_string(srt);\r\nfprintf(stderr, "tshark: invalid \"-z %s,%s\" argument\n", cmd_str, err);\r\ng_free(cmd_str);\r\ng_free(err);\r\nexit(1);\r\n}\r\nglobal_srt_array = g_array_new(FALSE, TRUE, sizeof(srt_stat_table*));\r\nsrt_table_dissector_init(srt, global_srt_array, NULL, NULL);\r\ninit_srt_tables(srt, filter);\r\n}\r\nvoid\r\nregister_srt_tables(gpointer data, gpointer user_data _U_)\r\n{\r\nregister_srt_t *srt = (register_srt_t*)data;\r\nconst char* short_name = proto_get_protocol_short_name(find_protocol_by_id(get_srt_proto_id(srt)));\r\nstat_tap_ui ui_info;\r\nif (strcmp(short_name, "CAMEL") == 0)\r\nreturn;\r\nui_info.group = REGISTER_STAT_GROUP_RESPONSE_TIME;\r\nui_info.title = NULL;\r\nui_info.cli_string = srt_table_get_tap_string(srt);\r\nui_info.tap_init_cb = dissector_srt_init;\r\nui_info.nparams = 0;\r\nui_info.params = NULL;\r\nregister_stat_tap_ui(&ui_info, srt);\r\n}
