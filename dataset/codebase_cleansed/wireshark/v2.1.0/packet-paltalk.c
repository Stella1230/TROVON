static guint\r\ndissect_paltalk_get_len(packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset, void *data _U_)\r\n{\r\nreturn tvb_get_ntohs(tvb, offset + 4) + PALTALK_HEADER_LENGTH;\r\n}\r\nstatic int\r\ndissect_paltalk_desegmented(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti = NULL;\r\nproto_tree *pt_tree = NULL;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Paltalk");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (tree)\r\n{\r\nti = proto_tree_add_item(tree, proto_paltalk, tvb, 0, -1, ENC_NA);\r\npt_tree = proto_item_add_subtree(ti, ett_paltalk);\r\nproto_tree_add_item(pt_tree, hf_paltalk_pdu_type, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pt_tree, hf_paltalk_version, tvb, 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pt_tree, hf_paltalk_length, tvb, 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pt_tree, hf_paltalk_content, tvb, 6, tvb_get_ntohs(tvb, 4), ENC_NA);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\ndissect_paltalk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nguint32 src32, dst32;\r\nif ((pinfo->net_src.type != AT_IPv4)\r\n|| (pinfo->net_dst.type != AT_IPv4)\r\n|| (pinfo->net_src.len != 4)\r\n|| (pinfo->net_dst.len != 4)\r\n|| !pinfo->net_src.data\r\n|| !pinfo->net_dst.data)\r\nreturn FALSE;\r\nmemcpy((guint8 *)&src32, pinfo->net_src.data, 4);\r\nmemcpy((guint8 *)&dst32, pinfo->net_dst.data, 4);\r\nif ( ((src32 & PALTALK_SERVERS_NETMASK) != PALTALK_SERVERS_ADDRESS)\r\n&&\r\n((dst32 & PALTALK_SERVERS_NETMASK) != PALTALK_SERVERS_ADDRESS))\r\nreturn FALSE;\r\ntcp_dissect_pdus(tvb, pinfo, tree, TRUE, PALTALK_HEADER_LENGTH,\r\ndissect_paltalk_get_len, dissect_paltalk_desegmented, data);\r\nreturn TRUE;\r\n}\r\nvoid\r\nproto_register_paltalk(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_paltalk_pdu_type, { "Packet Type", "paltalk.type",\r\nFT_UINT16, BASE_HEX, NULL, 0x00, NULL, HFILL }},\r\n{ &hf_paltalk_version, { "Protocol Version", "paltalk.version",\r\nFT_INT16, BASE_DEC, NULL, 0x00, NULL, HFILL }},\r\n{ &hf_paltalk_length, { "Payload Length", "paltalk.length",\r\nFT_INT16, BASE_DEC, NULL, 0x00, NULL, HFILL }},\r\n{ &hf_paltalk_content, { "Payload Content", "paltalk.content",\r\nFT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }}\r\n};\r\nstatic gint *ett[] = { &ett_paltalk };\r\nproto_paltalk = proto_register_protocol("Paltalk Messenger Protocol", "Paltalk", "paltalk");\r\nproto_register_field_array(proto_paltalk, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_paltalk(void)\r\n{\r\nheur_dissector_add("tcp", dissect_paltalk, "Paltalk over TCP", "paltalk_tcp", proto_paltalk, HEURISTIC_ENABLE);\r\n}
