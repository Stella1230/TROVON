static void panic(int err, const char* fmt, ...) {\r\nva_list ap;\r\nva_start(ap,fmt);\r\nvfprintf(stderr,fmt,ap);\r\nva_end(ap);\r\nexit(err);\r\n}\r\nstatic void dprintf(int lev, const char* fmt, ...) {\r\nva_list ap;\r\nif (lev <= debug_level) {\r\nva_start(ap,fmt);\r\nvfprintf(stderr,fmt,ap);\r\nva_end(ap);\r\nfflush(stderr);\r\n}\r\n}\r\nstatic void usage(int err) {\r\nconst char* usage_str = "usage:\n"\r\n"trigcap -w outfile -b begin -e end [-f capture] [-i iface] [-s snaplen] [-p] [-q] [-d [-d [-d [-d]]]]\n"\r\n" -w output file\n"\r\n" -b filter to start capturing\n"\r\n" -e filter to stop capturing\n"\r\n" -f capture filter\n"\r\n" -p promiscuous mode\n"\r\n" -s snapshot length\n"\r\n" -q quiet\n"\r\n" -d increase debug level\n"\r\n" -h prints this message\n"\r\n;\r\npanic(err,usage_str);\r\n}\r\nstatic void listener_handler(u_char* u, const struct pcap_pkthdr * ph, const u_char* buf) {\r\nchar errbuf[PCAP_ERRBUF_SIZE];\r\ndprintf(2,"listener handler invoked dumping=%d\n",dumping);\r\nif (dumping) {\r\ndprintf(2,"last round\n");\r\nkeep_going = 0;\r\n} else {\r\nif (pcap_setfilter(listener, &stop_filter) < 0) {\r\npanic(23,"could not apply stop filter to listener: %s\n",pcap_geterr(listener));\r\n}\r\ndprintf(2,"apply stop filter to listener\n");\r\nif (pcap_setnonblock(listener, 1, errbuf) < 0) {\r\npanic(24,"could not set listener in non blocking mode: %s\n",errbuf);\r\n}\r\ndprintf(2,"listener -> non_blocking\n");\r\ndumping = 1;\r\n}\r\n}\r\nstatic void capture_handler(u_char* dumper, const struct pcap_pkthdr * ph, const u_char* buf) {\r\ndprintf(4,"capture handler invoked dumping=%d\n",dumping);\r\nif (dumping) {\r\ncaptured++;\r\npcap_dump(dumper, ph, buf);\r\n}\r\n}\r\nstatic void sig_int(int sig) {\r\nkeep_going = 0;\r\n}\r\nint main(int argc, char** argv) {\r\nchar errbuf[PCAP_ERRBUF_SIZE];\r\nchar* interface = NULL;\r\nchar* outfile = NULL;\r\nguint snaplen = 65536;\r\nchar* start_filter_str = NULL;\r\nchar* stop_filter_str = NULL;\r\nchar* capture_filter_str = NULL;\r\nint promisc = 0;\r\nint quiet = 0;\r\nstruct bpf_program start_filter;\r\nstruct bpf_program capture_filter;\r\npcap_t* capturer = NULL;\r\npcap_dumper_t* dumper = NULL;\r\nint opt;\r\nwhile ((opt = getopt(argc, argv, "i:w:s:b:e:f:phdq")) != -1) {\r\nswitch (opt) {\r\ncase 'i':\r\nif (interface) panic(1,"interface already given");\r\ninterface = g_strdup(optarg);\r\nbreak;\r\ncase 'w':\r\nif (outfile) panic(3,"output file already given");\r\noutfile = g_strdup(optarg);\r\nbreak;\r\ncase 's':\r\nsnaplen = strtoul(optarg,NULL,10);\r\nif ( snaplen == 0 )\r\npanic(4,"invalid snaplen");\r\nbreak;\r\ncase 'b':\r\nif (start_filter_str) panic(5,"start filter already given");\r\nstart_filter_str = g_strdup(optarg);\r\nbreak;\r\ncase 'e':\r\nif (stop_filter_str) panic(6,"stop filter already given");\r\nstop_filter_str = g_strdup(optarg);\r\nbreak;\r\ncase 'f':\r\nif (capture_filter_str) panic(7,"capture filter already given");\r\ncapture_filter_str = g_strdup(optarg);\r\nbreak;\r\ncase 'p':\r\npromisc = 1;\r\nbreak;\r\ncase 'q':\r\nquiet = 1;\r\nbreak;\r\ncase 'd':\r\ndebug_level++;\r\nbreak;\r\ncase 'h':\r\ndefault:\r\nusage(0);\r\nbreak;\r\n}\r\n}\r\ndprintf(1,"starting with:\n interface: %s\n snaplen: %d\n promisc: %d"\r\n"\n outfile: %s\n capture filter: %s\n start: %s\n stop: %s\n debug level: %d\n",\r\ninterface ? interface : "to be chosen",\r\nsnaplen,\r\npromisc,\r\noutfile ? outfile : "** missing **",\r\ncapture_filter_str ? capture_filter_str : "** none given **",\r\nstart_filter_str ? start_filter_str : "** missing **",\r\nstop_filter_str ? stop_filter_str : "** missing **",\r\ndebug_level);\r\nif (! ( start_filter_str && stop_filter_str && outfile ) ) {\r\nusage(10);\r\n}\r\nif (! interface) {\r\ninterface = pcap_lookupdev(errbuf);\r\nif (!interface) {\r\npanic(11, "could not obtain an interface: %s\n",errbuf);\r\n}\r\n}\r\n#ifdef HAVE_PCAP_OPEN\r\nif ( ! ( capturer = pcap_open(interface, snaplen, promisc, 1, NULL, errbuf) )) {\r\n#else\r\nif ( ! ( capturer = pcap_open_live(interface, snaplen, promisc, 1, errbuf) )) {\r\n#endif\r\npanic(12,"could not open interface '%s' for listener: %s\n",interface,errbuf);\r\n}\r\ndprintf(1,"opened listener (%s,%d,%d)\n",interface,snaplen, promisc);\r\nif (pcap_compile(listener, &start_filter, start_filter_str, 1, 0) < 0) {\r\npanic(13,"could not compile start filter: %s\n",pcap_geterr(listener));\r\n}\r\ndprintf(2,"compiled start filter %s\n",start_filter_str);\r\nif (pcap_compile(listener, &stop_filter, stop_filter_str, 1, 0) < 0) {\r\npanic(14,"could not compile stop filter: %s\n",pcap_geterr(listener));\r\n}\r\ndprintf(2,"compiled stop filter %s\n",stop_filter_str);\r\n#ifdef HAVE_PCAP_OPEN\r\nif ( ! ( capturer = pcap_open(interface, snaplen, promisc, 1, NULL, errbuf) )) {\r\n#else\r\nif ( ! ( capturer = pcap_open_live(interface, snaplen, promisc, 1, errbuf) )) {\r\n#endif\r\npanic(15,"could not open interface '%s' for capturer: %s\n",interface, errbuf);\r\n}\r\ndprintf(1,"opened capturer (%s,%d,%d)\n",interface,snaplen, promisc);\r\nif (capture_filter_str) {\r\nif (pcap_compile(capturer, &capture_filter, capture_filter_str, 1, 0) < 0) {\r\npanic(16,"could not compile capture filter: %s\n",pcap_geterr(capturer));\r\n}\r\nif (pcap_setfilter(capturer, &capture_filter) < 0) {\r\npanic(17,"could not apply start filter to capturer: %s\n",pcap_geterr(capturer));\r\n}\r\ndprintf(2,"compiled and set capture filter (%s)\n",capture_filter_str);\r\n}\r\nif (pcap_setfilter(listener, &start_filter) < 0) {\r\npanic(18,"could not apply start filter to listener: %s\n",pcap_geterr(listener));\r\n}\r\ndprintf(2,"set start filter on listener\n");\r\nif (pcap_setnonblock(listener, 0, errbuf) < 0) {\r\npanic(19,"could not set listener in blocking mode: %s\n",errbuf);\r\n}\r\ndprintf(2,"listener -> blocking\n");\r\nif (pcap_setnonblock(capturer, 1, errbuf) < 0) {\r\npanic(20,"could not set capturer in non blocking mode: %s\n",errbuf);\r\n}\r\ndprintf(2,"capturer -> non_blocking\n");\r\nif (! (dumper = pcap_dump_open(listener,outfile)) ) {\r\npanic(21,"open dumper file '%s': %s\n",outfile,pcap_geterr(listener));\r\n}\r\ndprintf(2,"opened dumper file '%s'\n",outfile);\r\nsignal(SIGINT, sig_int);\r\n#ifdef SIGQUIT\r\nsignal(SIGQUIT, sig_int);\r\n#endif\r\n#ifdef SIGTERM\r\nsignal(SIGTERM, sig_int);\r\n#endif\r\n#ifdef SIGSTOP\r\nsignal(SIGSTOP, sig_int);\r\n#endif\r\nkeep_going = 1;\r\ndumping = 0;\r\ndo {\r\nif (pcap_dispatch(listener, -1, listener_handler, NULL) < 0 ) {\r\npanic(22,"pcap_dispatch(listener) failed: %s\n",pcap_geterr(listener));\r\n}\r\nif (pcap_dispatch(capturer, -1, capture_handler, (void*)dumper) < 0 ) {\r\npanic(23,"pcap_dispatch(capturer) failed: %s\n",pcap_geterr(capturer));\r\n}\r\n} while(keep_going);\r\nif (!quiet) {\r\nprintf("%d packets captured\n",captured);\r\n}\r\ndprintf(1,"done!\n");\r\npcap_dump_close(dumper);\r\npcap_close(listener);\r\npcap_close(capturer);\r\nreturn 0;\r\n}
