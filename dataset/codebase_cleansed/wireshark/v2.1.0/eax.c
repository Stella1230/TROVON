gboolean Eax_Decrypt(guint8 *pN, guint8 *pK, guint8 *pC,\r\nguint32 SizeN, guint32 SizeK, guint32 SizeC, MAC_T *pMac,\r\nguint8 Mode)\r\n{\r\nguint8 wsn[EAX_SIZEOF_KEY];\r\nguint8 wsc[EAX_SIZEOF_KEY];\r\nint i;\r\nif (SizeK != EAX_SIZEOF_KEY)\r\nreturn FALSE;\r\nfor (i = 0; i < EAX_SIZEOF_KEY; i++)\r\ninstance.L[i] = 0;\r\nAesEncrypt(instance.L, pK);\r\nDbl(instance.D, instance.L);\r\nDbl(instance.Q, instance.D);\r\nBLK_CPY(wsn, instance.D);\r\nif (Mode == EAX_MODE_CLEARTEXT_AUTH) {\r\ndCMAC(pK, wsn, pN, SizeN, pC, SizeC);\r\n} else {\r\nCMAC(pK, wsn, pN, SizeN);\r\n}\r\nif (Mode == EAX_MODE_CLEARTEXT_AUTH)\r\n{\r\nreturn (memcmp(pMac, &wsn[EAX_SIZEOF_KEY-sizeof(*pMac)], sizeof(*pMac)) ? FALSE : TRUE);\r\n}\r\nelse if (Mode == EAX_MODE_CIPHERTEXT_AUTH)\r\n{\r\nif (SizeC == 0)\r\nreturn (memcmp(pMac, &wsn[EAX_SIZEOF_KEY-sizeof(*pMac)], sizeof(*pMac)) ? FALSE : TRUE);\r\n{\r\nBLK_CPY(wsc, instance.Q);\r\nCMAC(pK, wsc, pC, SizeC);\r\nBLK_XOR(wsc, wsn);\r\n}\r\nif (memcmp(pMac, &wsc[EAX_SIZEOF_KEY-sizeof(*pMac)], sizeof(*pMac)) == 0)\r\n{\r\nCTR(wsn, pK, pC, SizeC);\r\nreturn TRUE;\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nstatic void Dbl(guint8 *out, const guint8 *in)\r\n{\r\nint i;\r\nguint8 carry = 0;\r\nfor (i=0; i < EAX_SIZEOF_KEY; i++)\r\n{\r\nout[i] = ( in[i] << 1 ) | carry;\r\ncarry = (in[i] & 0x80) ? 1 : 0;\r\n}\r\nif (carry)\r\nout[0] ^= 0x87;\r\n}\r\nstatic void CMAC(guint8 *pK, guint8 *ws, const guint8 *pN, guint16 SizeN)\r\n{\r\ndCMAC(pK, ws, pN, SizeN, NULL, 0);\r\n}\r\nstatic void dCMAC(guint8 *pK, guint8 *ws, const guint8 *pN, guint16 SizeN, const guint8 *pC, guint16 SizeC)\r\n{\r\ngcry_cipher_hd_t cipher_hd;\r\nguint8 *work;\r\nguint8 *ptr;\r\nguint16 SizeT = SizeN + SizeC;\r\nguint16 worksize = SizeT;\r\nif (SizeT & 0xf) {\r\nworksize += 0x10 - (worksize & 0xf);\r\n}\r\nwork = (guint8 *)g_malloc(worksize);\r\nif (work == NULL) {\r\nreturn;\r\n}\r\nmemcpy(work, pN, SizeN);\r\nif (pC != NULL) {\r\nmemcpy(&work[SizeN], pC, SizeC);\r\n}\r\nif (worksize != SizeT) {\r\nwork[SizeT] = 0x80;\r\nfor (ptr = &work[SizeT+1]; ptr < &work[worksize]; ptr++)\r\n*ptr = 0;\r\nptr= &work[worksize-0x10];\r\nBLK_XOR(ptr, instance.Q);\r\n} else {\r\nptr = &work[worksize-0x10];\r\nBLK_XOR(ptr, instance.D);\r\n}\r\nif (gcry_cipher_open(&cipher_hd, GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_CBC,0)){\r\ng_free(work);\r\nreturn;\r\n}\r\nif (gcry_cipher_setkey(cipher_hd, pK, EAX_SIZEOF_KEY)) {\r\ng_free(work);\r\ngcry_cipher_close(cipher_hd);\r\nreturn;\r\n}\r\nif (gcry_cipher_setiv(cipher_hd, ws, EAX_SIZEOF_KEY)) {\r\ng_free(work);\r\ngcry_cipher_close(cipher_hd);\r\nreturn;\r\n}\r\nif (gcry_cipher_encrypt(cipher_hd, work, worksize, work, worksize)) {\r\ng_free(work);\r\ngcry_cipher_close(cipher_hd);\r\nreturn;\r\n}\r\nmemcpy(ws, ptr, EAX_SIZEOF_KEY);\r\ng_free(work);\r\ngcry_cipher_close(cipher_hd);\r\nreturn;\r\n}\r\nstatic void CTR(const guint8 *ws, guint8 *pK, guint8 *pN, guint16 SizeN)\r\n{\r\ngcry_cipher_hd_t cipher_hd;\r\nguint8 ctr[EAX_SIZEOF_KEY];\r\nBLK_CPY(ctr, ws);\r\nctr[12] &= 0x7f;\r\nctr[14] &= 0x7f;\r\nif (gcry_cipher_open(&cipher_hd, GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_CTR, 0)) {\r\nreturn;\r\n}\r\nif (gcry_cipher_setkey(cipher_hd, pK, EAX_SIZEOF_KEY)) {\r\ngcry_cipher_close(cipher_hd);\r\nreturn;\r\n}\r\nif (gcry_cipher_setctr(cipher_hd, ctr, EAX_SIZEOF_KEY)) {\r\ngcry_cipher_close(cipher_hd);\r\nreturn;\r\n}\r\nif (gcry_cipher_encrypt(cipher_hd, pN, SizeN, pN, SizeN)) {\r\ngcry_cipher_close(cipher_hd);\r\nreturn;\r\n}\r\ngcry_cipher_close(cipher_hd);\r\nreturn;\r\n}\r\nvoid AesEncrypt(unsigned char msg[EAX_SIZEOF_KEY], unsigned char key[EAX_SIZEOF_KEY])\r\n{\r\ngcry_cipher_hd_t cipher_hd;\r\nif (gcry_cipher_open(&cipher_hd, GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_ECB, 0)) {\r\nreturn;\r\n}\r\nif (gcry_cipher_setkey(cipher_hd, key, EAX_SIZEOF_KEY)) {\r\ngcry_cipher_close(cipher_hd);\r\nreturn;\r\n}\r\nif (gcry_cipher_encrypt(cipher_hd, msg, EAX_SIZEOF_KEY, msg, EAX_SIZEOF_KEY)) {\r\ngcry_cipher_close(cipher_hd);\r\nreturn;\r\n}\r\ngcry_cipher_close(cipher_hd);\r\nreturn;\r\n}
