static int\r\nsearch(\r\nint val,\r\nshort *table,\r\nint size)\r\n{\r\nint i;\r\nfor (i = 0; i < size; i++) {\r\nif (val <= *table++)\r\nreturn (i);\r\n}\r\nreturn (size);\r\n}\r\nunsigned char\r\nlinear2alaw(\r\nint pcm_val)\r\n{\r\nint mask;\r\nint seg;\r\nunsigned char aval;\r\nif (pcm_val >= 0) {\r\nmask = 0xD5;\r\n} else {\r\nmask = 0x55;\r\npcm_val = -pcm_val - 8;\r\n}\r\nseg = search(pcm_val, seg_end, 8);\r\nif (seg >= 8)\r\nreturn (0x7F ^ mask);\r\nelse {\r\naval = seg << SEG_SHIFT;\r\nif (seg < 2)\r\naval |= (pcm_val >> 4) & QUANT_MASK;\r\nelse\r\naval |= (pcm_val >> (seg + 3)) & QUANT_MASK;\r\nreturn (aval ^ mask);\r\n}\r\n}\r\nint\r\nalaw2linear(\r\nunsigned char a_val)\r\n{\r\nint t;\r\nint seg;\r\na_val ^= 0x55;\r\nt = (a_val & QUANT_MASK) << 4;\r\nseg = ((unsigned)a_val & SEG_MASK) >> SEG_SHIFT;\r\nswitch (seg) {\r\ncase 0:\r\nt += 8;\r\nbreak;\r\ncase 1:\r\nt += 0x108;\r\nbreak;\r\ndefault:\r\nt += 0x108;\r\nt <<= seg - 1;\r\n}\r\nreturn ((a_val & SIGN_BIT) ? t : -t);\r\n}\r\nunsigned char\r\nlinear2ulaw(\r\nint pcm_val)\r\n{\r\nint mask;\r\nint seg;\r\nunsigned char uval;\r\nif (pcm_val < 0) {\r\npcm_val = BIAS - pcm_val;\r\nmask = 0x7F;\r\n} else {\r\npcm_val += BIAS;\r\nmask = 0xFF;\r\n}\r\nseg = search(pcm_val, seg_end, 8);\r\nif (seg >= 8)\r\nreturn (0x7F ^ mask);\r\nelse {\r\nuval = (seg << 4) | ((pcm_val >> (seg + 3)) & 0xF);\r\nreturn (uval ^ mask);\r\n}\r\n}\r\nint\r\nulaw2linear(\r\nunsigned char u_val)\r\n{\r\nint t;\r\nu_val = ~u_val;\r\nt = ((u_val & QUANT_MASK) << 3) + BIAS;\r\nt <<= ((unsigned)u_val & SEG_MASK) >> SEG_SHIFT;\r\nreturn ((u_val & SIGN_BIT) ? (BIAS - t) : (t - BIAS));\r\n}
