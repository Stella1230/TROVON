void k12_fprintf(const char* fmt, ...) {\r\nva_list ap;\r\nva_start(ap,fmt);\r\nvfprintf(dbg_out, fmt, ap);\r\nva_end(ap);\r\n}\r\nvoid k12_hex_ascii_dump(guint level, gint64 offset, const char* label, const unsigned char* b, unsigned int len) {\r\nstatic const char* c2t[] = {\r\n"00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f",\r\n"10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f",\r\n"20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f",\r\n"30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f",\r\n"40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f",\r\n"50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f",\r\n"60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f",\r\n"70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f",\r\n"80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f",\r\n"90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f",\r\n"a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af",\r\n"b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf",\r\n"c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf",\r\n"d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df",\r\n"e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef",\r\n"f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"\r\n};\r\nunsigned int i, j;\r\nif (debug_level < level) return;\r\nfprintf(dbg_out,"%s(%.8" G_GINT64_MODIFIER "x,%.4x):\n",label,offset,len);\r\nfor (i=0 ; i<len ; i += 16) {\r\nfor (j=0; j<16; j++) {\r\nif ((j%4)==0)\r\nfprintf(dbg_out," ");\r\nif ((i+j)<len)\r\nfprintf(dbg_out, "%s", c2t[b[i+j]]);\r\nelse\r\nfprintf(dbg_out, " ");\r\n}\r\nfprintf(dbg_out, " ");\r\nfor (j=0; j<16; j++) {\r\nif ((i+j)<len)\r\nfprintf(dbg_out, "%c", g_ascii_isprint(b[i+j]) ? b[i+j] : '.');\r\n}\r\nfprintf(dbg_out,"\n");\r\n}\r\n}\r\nvoid k12_ascii_dump(guint level, guint8 *buf, guint32 len, guint32 buf_offset) {\r\nguint32 i;\r\nif (debug_level < level) return;\r\nfor (i = buf_offset; i < len; i++) {\r\nif (g_ascii_isprint(buf[i]) || buf[i] == '\n' || buf[i] == '\t')\r\nputc(buf[i], dbg_out);\r\nelse if (buf[i] == '\0')\r\nfprintf(dbg_out, "(NUL)\n");\r\n}\r\n}\r\nstatic gint get_record(k12_t *file_data, FILE_T fh, gint64 file_offset,\r\ngboolean is_random, int *err, gchar **err_info) {\r\nguint8 *buffer = is_random ? file_data->rand_read_buff : file_data->seq_read_buff;\r\nguint buffer_len = is_random ? file_data->rand_read_buff_len : file_data->seq_read_buff_len;\r\nguint total_read = 0;\r\nguint left;\r\nguint8* writep;\r\n#ifdef DEBUG_K12\r\nguint actual_len;\r\n#endif\r\nguint junky_offset = 8192 - (gint) ( (file_offset - K12_FILE_HDR_LEN) % 8192 );\r\nK12_DBG(6,("get_record: ENTER: junky_offset=%" G_GINT64_MODIFIER "d, file_offset=%" G_GINT64_MODIFIER "d",junky_offset,file_offset));\r\nif (buffer == NULL) {\r\nbuffer = (guint8*)g_malloc(8192);\r\nbuffer_len = 8192;\r\nif (is_random) {\r\nfile_data->rand_read_buff = buffer;\r\nfile_data->rand_read_buff_len = buffer_len;\r\n} else {\r\nfile_data->seq_read_buff = buffer;\r\nfile_data->seq_read_buff_len = buffer_len;\r\n}\r\n}\r\nif ( junky_offset == 8192 ) {\r\nif ( ! file_skip( fh, K12_FILE_BLOB_LEN, err ) )\r\nreturn -1;\r\ntotal_read += K12_FILE_BLOB_LEN;\r\n}\r\nif ( !wtap_read_bytes( fh, buffer, 4, err, err_info ) )\r\nreturn -1;\r\ntotal_read += 4;\r\nleft = pntoh32(buffer + K12_RECORD_LEN);\r\n#ifdef DEBUG_K12\r\nactual_len = left;\r\n#endif\r\njunky_offset -= 4;\r\nK12_DBG(5,("get_record: GET length=%u",left));\r\nif (left < 8) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("k12: Record length %u is less than 8 bytes long",left);\r\nreturn -1;\r\n}\r\nif (left > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("k12: Record length %u is greater than the maximum %u",left,WTAP_MAX_PACKET_SIZE);\r\nreturn -1;\r\n}\r\nwhile (left > buffer_len) {\r\nbuffer = (guint8*)g_realloc(buffer,buffer_len*=2);\r\nif (is_random) {\r\nfile_data->rand_read_buff = buffer;\r\nfile_data->rand_read_buff_len = buffer_len;\r\n} else {\r\nfile_data->seq_read_buff = buffer;\r\nfile_data->seq_read_buff_len = buffer_len;\r\n}\r\n}\r\nwritep = buffer + 4;\r\nleft -= 4;\r\ndo {\r\nK12_DBG(6,("get_record: looping left=%d junky_offset=%" G_GINT64_MODIFIER "d",left,junky_offset));\r\nif (junky_offset > left) {\r\nif ( !wtap_read_bytes( fh, writep, left, err, err_info ) )\r\nreturn -1;\r\ntotal_read += left;\r\nbreak;\r\n} else {\r\nif ( !wtap_read_bytes( fh, writep, junky_offset, err, err_info ) )\r\nreturn -1;\r\ntotal_read += junky_offset;\r\nwritep += junky_offset;\r\nif ( !file_skip( fh, K12_FILE_BLOB_LEN, err ) )\r\nreturn -1;\r\ntotal_read += K12_FILE_BLOB_LEN;\r\nleft -= junky_offset;\r\njunky_offset = 8192;\r\n}\r\n} while(left);\r\nK12_HEX_ASCII_DUMP(5,file_offset, "GOT record", buffer, actual_len);\r\nreturn total_read;\r\n}\r\nstatic gboolean\r\nmemiszero(const void *ptr, size_t count)\r\n{\r\nconst guint8 *p = (const guint8 *)ptr;\r\nwhile (count != 0) {\r\nif (*p != 0)\r\nreturn FALSE;\r\np++;\r\ncount--;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic void\r\nprocess_packet_data(struct wtap_pkthdr *phdr, Buffer *target, guint8 *buffer,\r\ngint len, k12_t *k12)\r\n{\r\nguint32 type;\r\nguint buffer_offset;\r\nguint64 ts;\r\nguint32 length;\r\nguint32 extra_len;\r\nguint32 src_id;\r\nk12_src_desc_t* src_desc;\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS;\r\nts = pntoh64(buffer + K12_PACKET_TIMESTAMP);\r\nphdr->ts.secs = (guint32) ((ts / 2000000) + 631152000);\r\nphdr->ts.nsecs = (guint32) ( (ts % 2000000) * 500 );\r\nlength = pntoh32(buffer + K12_RECORD_FRAME_LEN) & 0x00001FFF;\r\nphdr->len = phdr->caplen = length;\r\ntype = pntoh32(buffer + K12_RECORD_TYPE);\r\nbuffer_offset = (type == K12_REC_D0020) ? K12_PACKET_FRAME_D0020 : K12_PACKET_FRAME;\r\nws_buffer_assure_space(target, length);\r\nmemcpy(ws_buffer_start_ptr(target), buffer + buffer_offset, length);\r\nextra_len = len - buffer_offset - length;\r\nws_buffer_assure_space(&(k12->extra_info), extra_len);\r\nmemcpy(ws_buffer_start_ptr(&(k12->extra_info)),\r\nbuffer + buffer_offset + length, extra_len);\r\nphdr->pseudo_header.k12.extra_info = (guint8*)ws_buffer_start_ptr(&(k12->extra_info));\r\nphdr->pseudo_header.k12.extra_length = extra_len;\r\nsrc_id = pntoh32(buffer + K12_RECORD_SRC_ID);\r\nK12_DBG(5,("process_packet_data: src_id=%.8x",src_id));\r\nphdr->pseudo_header.k12.input = src_id;\r\nif ( ! (src_desc = (k12_src_desc_t*)g_hash_table_lookup(k12->src_by_id,GUINT_TO_POINTER(src_id))) ) {\r\nsrc_desc = (k12_src_desc_t*)g_hash_table_lookup(k12->src_by_id,GUINT_TO_POINTER(src_id&K12_RECORD_SRC_ID_MASK));\r\n}\r\nif (src_desc) {\r\nK12_DBG(5,("process_packet_data: input_name='%s' stack_file='%s' type=%x",src_desc->input_name,src_desc->stack_file,src_desc->input_type));\r\nphdr->pseudo_header.k12.input_name = src_desc->input_name;\r\nphdr->pseudo_header.k12.stack_file = src_desc->stack_file;\r\nphdr->pseudo_header.k12.input_type = src_desc->input_type;\r\nswitch(src_desc->input_type) {\r\ncase K12_PORT_ATMPVC:\r\nif ((long)(buffer_offset + length + K12_PACKET_OFFSET_CID) < len) {\r\nphdr->pseudo_header.k12.input_info.atm.vp = pntoh16(buffer + buffer_offset + length + K12_PACKET_OFFSET_VP);\r\nphdr->pseudo_header.k12.input_info.atm.vc = pntoh16(buffer + buffer_offset + length + K12_PACKET_OFFSET_VC);\r\nphdr->pseudo_header.k12.input_info.atm.cid = *((unsigned char*)(buffer + buffer_offset + length + K12_PACKET_OFFSET_CID));\r\nbreak;\r\n}\r\ndefault:\r\nmemcpy(&(phdr->pseudo_header.k12.input_info),&(src_desc->input_info),sizeof(src_desc->input_info));\r\nbreak;\r\n}\r\n} else {\r\nK12_DBG(5,("process_packet_data: NO SRC_RECORD FOUND"));\r\nmemset(&(phdr->pseudo_header.k12),0,sizeof(phdr->pseudo_header.k12));\r\nphdr->pseudo_header.k12.input_name = "unknown port";\r\nphdr->pseudo_header.k12.stack_file = "unknown stack file";\r\n}\r\nphdr->pseudo_header.k12.input = src_id;\r\nphdr->pseudo_header.k12.stuff = k12;\r\n}\r\nstatic gboolean k12_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset) {\r\nk12_t *k12 = (k12_t *)wth->priv;\r\nk12_src_desc_t* src_desc;\r\nguint8* buffer;\r\ngint64 offset;\r\ngint len;\r\nguint32 type;\r\nguint32 src_id;\r\noffset = file_tell(wth->fh);\r\ndo {\r\nif ( k12->num_of_records == 0 ) {\r\n*err = 0;\r\nreturn FALSE;\r\n}\r\nK12_DBG(5,("k12_read: offset=%i",offset));\r\n*data_offset = offset;\r\nlen = get_record(k12, wth->fh, offset, FALSE, err, err_info);\r\nif (len < 0) {\r\nreturn FALSE;\r\n} else if (len == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n} else if (len < K12_RECORD_SRC_ID + 4) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("data record length %d too short", len);\r\nreturn FALSE;\r\n}\r\nk12->num_of_records--;\r\nbuffer = k12->seq_read_buff;\r\ntype = pntoh32(buffer + K12_RECORD_TYPE);\r\nsrc_id = pntoh32(buffer + K12_RECORD_SRC_ID);\r\nif ( ! (src_desc = (k12_src_desc_t*)g_hash_table_lookup(k12->src_by_id,GUINT_TO_POINTER(src_id))) ) {\r\nsrc_desc = (k12_src_desc_t*)g_hash_table_lookup(k12->src_by_id,GUINT_TO_POINTER(src_id&K12_RECORD_SRC_ID_MASK));\r\n}\r\nK12_DBG(5,("k12_read: record type=%x src_id=%x",type,src_id));\r\noffset += len;\r\n} while ( ((type & K12_MASK_PACKET) != K12_REC_PACKET && (type & K12_MASK_PACKET) != K12_REC_D0020) || !src_id || !src_desc );\r\nprocess_packet_data(&wth->phdr, wth->frame_buffer, buffer, len, k12);\r\nreturn TRUE;\r\n}\r\nstatic gboolean k12_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info) {\r\nk12_t *k12 = (k12_t *)wth->priv;\r\nguint8* buffer;\r\ngint len;\r\nK12_DBG(5,("k12_seek_read: ENTER"));\r\nif ( file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\r\nK12_DBG(5,("k12_seek_read: SEEK ERROR"));\r\nreturn FALSE;\r\n}\r\nlen = get_record(k12, wth->random_fh, seek_off, TRUE, err, err_info);\r\nif (len < 0) {\r\nK12_DBG(5,("k12_seek_read: READ ERROR"));\r\nreturn FALSE;\r\n} else if (len < K12_RECORD_SRC_ID + 4) {\r\nK12_DBG(5,("k12_seek_read: SHORT READ"));\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nbuffer = k12->rand_read_buff;\r\nprocess_packet_data(phdr, buf, buffer, len, k12);\r\nK12_DBG(5,("k12_seek_read: DONE OK"));\r\nreturn TRUE;\r\n}\r\nstatic k12_t* new_k12_file_data(void) {\r\nk12_t* fd = g_new(k12_t,1);\r\nfd->file_len = 0;\r\nfd->num_of_records = 0;\r\nfd->src_by_name = g_hash_table_new(g_str_hash,g_str_equal);\r\nfd->src_by_id = g_hash_table_new(g_direct_hash,g_direct_equal);\r\nfd->seq_read_buff = NULL;\r\nfd->seq_read_buff_len = 0;\r\nfd->rand_read_buff = NULL;\r\nfd->rand_read_buff_len = 0;\r\nws_buffer_init(&(fd->extra_info), 100);\r\nreturn fd;\r\n}\r\nstatic gboolean destroy_srcdsc(gpointer k _U_, gpointer v, gpointer p _U_) {\r\nk12_src_desc_t* rec = (k12_src_desc_t*)v;\r\ng_free(rec->input_name);\r\ng_free(rec->stack_file);\r\ng_free(rec);\r\nreturn TRUE;\r\n}\r\nstatic void destroy_k12_file_data(k12_t* fd) {\r\ng_hash_table_destroy(fd->src_by_id);\r\ng_hash_table_foreach_remove(fd->src_by_name,destroy_srcdsc,NULL);\r\ng_hash_table_destroy(fd->src_by_name);\r\nws_buffer_free(&(fd->extra_info));\r\ng_free(fd->seq_read_buff);\r\ng_free(fd->rand_read_buff);\r\ng_free(fd);\r\n}\r\nstatic void k12_close(wtap *wth) {\r\nk12_t *k12 = (k12_t *)wth->priv;\r\ndestroy_k12_file_data(k12);\r\nwth->priv = NULL;\r\n#ifdef DEBUG_K12\r\nK12_DBG(5,("k12_close: CLOSED"));\r\nif (env_file) fclose(dbg_out);\r\n#endif\r\n}\r\nwtap_open_return_val k12_open(wtap *wth, int *err, gchar **err_info) {\r\nk12_src_desc_t* rec;\r\nguint8 header_buffer[K12_FILE_HDR_LEN];\r\nguint8* read_buffer;\r\nguint32 type;\r\nlong offset;\r\nlong len;\r\nguint port_type;\r\nguint32 rec_len;\r\nguint32 hwpart_len;\r\nguint32 name_len;\r\nguint32 stack_len;\r\nguint i;\r\nk12_t* file_data;\r\n#ifdef DEBUG_K12\r\ngchar* env_level = getenv("K12_DEBUG_LEVEL");\r\nenv_file = getenv("K12_DEBUG_FILENAME");\r\nif ( env_file ) {\r\ndbg_out = ws_fopen(env_file,"w");\r\nif (dbg_out == NULL) {\r\ndbg_out = stderr;\r\nK12_DBG(1,("unable to open K12 DEBUG FILENAME for writing! Logging to standard error"));\r\n}\r\n}\r\nelse\r\ndbg_out = stderr;\r\nif ( env_level ) debug_level = (unsigned int)strtoul(env_level,NULL,10);\r\nK12_DBG(1,("k12_open: ENTER debug_level=%u",debug_level));\r\n#endif\r\nif ( !wtap_read_bytes(wth->fh,header_buffer,K12_FILE_HDR_LEN,err,err_info) ) {\r\nK12_DBG(1,("k12_open: FILE HEADER TOO SHORT OR READ ERROR"));\r\nif (*err != WTAP_ERR_SHORT_READ) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif ( memcmp(header_buffer,k12_file_magic,8) != 0 ) {\r\nK12_DBG(1,("k12_open: BAD MAGIC"));\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\noffset = K12_FILE_HDR_LEN;\r\nfile_data = new_k12_file_data();\r\nfile_data->file_len = pntoh32( header_buffer + 0x8);\r\nif (memiszero(header_buffer + 0x10, K12_FILE_HDR_LEN - 0x10)) {\r\nfile_data->num_of_records = pntoh32( header_buffer + 0x0C );\r\n} else {\r\nfile_data->num_of_records = pntoh32( header_buffer + K12_FILE_HDR_RECORD_COUNT_1 );\r\nif ( file_data->num_of_records != pntoh32( header_buffer + K12_FILE_HDR_RECORD_COUNT_2 ) ) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("k12: two different record counts, %u at 0x%02x and %u at 0x%02x",\r\nfile_data->num_of_records,\r\nK12_FILE_HDR_RECORD_COUNT_1,\r\npntoh32( header_buffer + K12_FILE_HDR_RECORD_COUNT_2 ),\r\nK12_FILE_HDR_RECORD_COUNT_2 );\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\n}\r\nK12_DBG(5,("k12_open: FILE_HEADER OK: offset=%x file_len=%i records=%i",\r\noffset,\r\nfile_data->file_len,\r\nfile_data->num_of_records ));\r\ndo {\r\nif ( file_data->num_of_records == 0 ) {\r\n*err = WTAP_ERR_SHORT_READ;\r\ndestroy_k12_file_data(file_data);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nlen = get_record(file_data, wth->fh, offset, FALSE, err, err_info);\r\nif ( len < 0 ) {\r\nK12_DBG(1,("k12_open: BAD HEADER RECORD",len));\r\ndestroy_k12_file_data(file_data);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif ( len == 0 ) {\r\nK12_DBG(1,("k12_open: BAD HEADER RECORD",len));\r\n*err = WTAP_ERR_SHORT_READ;\r\ndestroy_k12_file_data(file_data);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nread_buffer = file_data->seq_read_buff;\r\nrec_len = pntoh32( read_buffer + K12_RECORD_LEN );\r\nif (rec_len < K12_RECORD_TYPE + 4) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("k12_open: record length %u < %u",\r\nrec_len, K12_RECORD_TYPE + 4);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\ntype = pntoh32( read_buffer + K12_RECORD_TYPE );\r\nif ( (type & K12_MASK_PACKET) == K12_REC_PACKET ||\r\n(type & K12_MASK_PACKET) == K12_REC_D0020) {\r\nif (file_seek(wth->fh, offset, SEEK_SET, err) == -1) {\r\ndestroy_k12_file_data(file_data);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nK12_DBG(5,("k12_open: FIRST PACKET offset=%x",offset));\r\nbreak;\r\n}\r\nswitch (type) {\r\ncase K12_REC_SRCDSC:\r\ncase K12_REC_SRCDSC2:\r\nrec = g_new0(k12_src_desc_t,1);\r\nif (rec_len < K12_SRCDESC_HWPART) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("k12_open: source descriptor record length %u < %u",\r\nrec_len, K12_SRCDESC_HWPART);\r\ndestroy_k12_file_data(file_data);\r\ng_free(rec);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nport_type = read_buffer[K12_SRCDESC_PORT_TYPE];\r\nhwpart_len = pntoh16( read_buffer + K12_SRCDESC_HWPARTLEN );\r\nname_len = pntoh16( read_buffer + K12_SRCDESC_NAMELEN );\r\nstack_len = pntoh16( read_buffer + K12_SRCDESC_STACKLEN );\r\nrec->input = pntoh32( read_buffer + K12_RECORD_SRC_ID );\r\nK12_DBG(5,("k12_open: INTERFACE RECORD offset=%x interface=%x",offset,rec->input));\r\nif (name_len == 0) {\r\nK12_DBG(5,("k12_open: failed (name_len == 0 in source description"));\r\ndestroy_k12_file_data(file_data);\r\ng_free(rec);\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (stack_len == 0) {\r\nK12_DBG(5,("k12_open: failed (stack_len == 0 in source description"));\r\ndestroy_k12_file_data(file_data);\r\ng_free(rec);\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (rec_len < K12_SRCDESC_HWPART + hwpart_len + name_len + stack_len) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("k12_open: source descriptor record length %u < %u (%u + %u + %u + %u)",\r\nrec_len,\r\nK12_SRCDESC_HWPART + hwpart_len + name_len + stack_len,\r\nK12_SRCDESC_HWPART, hwpart_len, name_len, stack_len);\r\ndestroy_k12_file_data(file_data);\r\ng_free(rec);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (hwpart_len) {\r\nif (hwpart_len < 4) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("k12_open: source descriptor hardware part length %u < 4",\r\nhwpart_len);\r\ndestroy_k12_file_data(file_data);\r\ng_free(rec);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nswitch(( rec->input_type = pntoh32( read_buffer + K12_SRCDESC_HWPART + K12_SRCDESC_HWPARTTYPE ) )) {\r\ncase K12_PORT_DS0S:\r\nrec->input_info.ds0mask = 0x00000000;\r\nif (hwpart_len > K12_SRCDESC_DS0_MASK) {\r\nfor (i = 0; i < hwpart_len - K12_SRCDESC_DS0_MASK; i++) {\r\nrec->input_info.ds0mask |= ( *(read_buffer + K12_SRCDESC_HWPART + K12_SRCDESC_DS0_MASK + i) == 0xff ) ? 1U<<(31-i) : 0x0;\r\n}\r\n}\r\nbreak;\r\ncase K12_PORT_ATMPVC:\r\nif (hwpart_len < K12_SRCDESC_ATM_VCI + 2) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("k12_open: source descriptor hardware part length %u < %u",\r\nhwpart_len,\r\nK12_SRCDESC_ATM_VCI + 2);\r\ndestroy_k12_file_data(file_data);\r\ng_free(rec);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nrec->input_info.atm.vp = pntoh16( read_buffer + K12_SRCDESC_HWPART + K12_SRCDESC_ATM_VPI );\r\nrec->input_info.atm.vc = pntoh16( read_buffer + K12_SRCDESC_HWPART + K12_SRCDESC_ATM_VCI );\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nif (port_type >= 0x14\r\n&& port_type <= 0x17) {\r\nrec->input_type = K12_PORT_ATMPVC;\r\nrec->input_info.atm.vp = 0;\r\nrec->input_info.atm.vc = 0;\r\n}\r\n}\r\nif (read_buffer[K12_SRCDESC_HWPART + hwpart_len + name_len - 1] != '\0') {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("k12_open: source descriptor record contains non-null-terminated link-layer name");\r\ndestroy_k12_file_data(file_data);\r\ng_free(rec);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (read_buffer[K12_SRCDESC_HWPART + hwpart_len + name_len + stack_len - 1] != '\0') {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("k12_open: source descriptor record contains non-null-terminated stack path");\r\ndestroy_k12_file_data(file_data);\r\ng_free(rec);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nrec->input_name = (gchar *)g_memdup(read_buffer + K12_SRCDESC_HWPART + hwpart_len, name_len);\r\nrec->stack_file = (gchar *)g_memdup(read_buffer + K12_SRCDESC_HWPART + hwpart_len + name_len, stack_len);\r\nascii_strdown_inplace (rec->stack_file);\r\ng_hash_table_insert(file_data->src_by_id,GUINT_TO_POINTER(rec->input),rec);\r\ng_hash_table_insert(file_data->src_by_name,rec->stack_file,rec);\r\nbreak;\r\ncase K12_REC_STK_FILE:\r\nK12_DBG(1,("k12_open: K12_REC_STK_FILE"));\r\nK12_DBG(1,("Field 1: 0x%08x",pntoh32( read_buffer + 0x08 )));\r\nK12_DBG(1,("Field 2: 0x%08x",pntoh32( read_buffer + 0x0c )));\r\nK12_ASCII_DUMP(1, read_buffer, rec_len, 16);\r\nbreak;\r\ndefault:\r\nK12_DBG(1,("k12_open: RECORD TYPE 0x%08x",type));\r\nbreak;\r\n}\r\noffset += len;\r\nfile_data->num_of_records--;\r\n} while(1);\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_K12;\r\nwth->file_encap = WTAP_ENCAP_K12;\r\nwth->snapshot_length = 0;\r\nwth->subtype_read = k12_read;\r\nwth->subtype_seek_read = k12_seek_read;\r\nwth->subtype_close = k12_close;\r\nwth->priv = (void *)file_data;\r\nwth->file_tsprec = WTAP_TSPREC_NSEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nint k12_dump_can_write_encap(int encap) {\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nif (encap != WTAP_ENCAP_K12)\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\nreturn 0;\r\n}\r\nstatic gboolean k12_dump_record(wtap_dumper *wdh, guint32 len, guint8* buffer, int *err_p) {\r\nk12_dump_t *k12 = (k12_dump_t *)wdh->priv;\r\nguint32 junky_offset = (8192 - ( (k12->file_offset - K12_FILE_HDR_LEN) % 8192 )) % 8192;\r\nif (len > junky_offset) {\r\nif (junky_offset) {\r\nif (! wtap_dump_file_write(wdh, buffer, junky_offset, err_p))\r\nreturn FALSE;\r\n}\r\nif (! wtap_dump_file_write(wdh, dumpy_junk, K12_FILE_BLOB_LEN, err_p))\r\nreturn FALSE;\r\nif (! wtap_dump_file_write(wdh, buffer+junky_offset, len - junky_offset, err_p))\r\nreturn FALSE;\r\nk12->file_offset += len + K12_FILE_BLOB_LEN;\r\nk12->file_len += len + K12_FILE_BLOB_LEN;\r\n} else {\r\nif (! wtap_dump_file_write(wdh, buffer, len, err_p))\r\nreturn FALSE;\r\nk12->file_offset += len;\r\nk12->file_len += len;\r\n}\r\nk12->num_of_records++;\r\nreturn TRUE;\r\n}\r\nstatic void k12_dump_src_setting(gpointer k _U_, gpointer v, gpointer p) {\r\nk12_src_desc_t* src_desc = (k12_src_desc_t*)v;\r\nwtap_dumper *wdh = (wtap_dumper *)p;\r\nguint32 len;\r\nguint offset;\r\nguint i;\r\nint errxxx;\r\nunion {\r\nguint8 buffer[8192];\r\nstruct {\r\nguint32 len;\r\nguint32 type;\r\nguint32 unk32_1;\r\nguint32 input;\r\nguint16 unk32_2;\r\nguint16 color;\r\nguint32 unk32_3;\r\nguint32 unk32_4;\r\nguint16 unk16_1;\r\nguint16 hwpart_len;\r\nguint16 name_len;\r\nguint16 stack_len;\r\nstruct {\r\nguint32 type;\r\nunion {\r\nstruct {\r\nguint32 unk32;\r\nguint8 mask[32];\r\n} ds0mask;\r\nstruct {\r\nguint8 unk_data[16];\r\nguint16 vp;\r\nguint16 vc;\r\n} atm;\r\nguint32 unk;\r\n} desc;\r\n} extra;\r\n} record;\r\n} obj;\r\nobj.record.type = g_htonl(K12_REC_SRCDSC);\r\nobj.record.unk32_1 = g_htonl(0x00000001);\r\nobj.record.input = g_htonl(src_desc->input);\r\nobj.record.unk32_2 = g_htons(0x0000);\r\nobj.record.color = g_htons(0x060f);\r\nobj.record.unk32_3 = g_htonl(0x00000003);\r\nswitch (src_desc->input_type) {\r\ncase K12_PORT_ATMPVC:\r\nobj.record.unk32_4 = g_htonl(0x01001400);\r\nbreak;\r\ndefault:\r\nobj.record.unk32_4 = g_htonl(0x01000100);\r\n}\r\nobj.record.unk16_1 = g_htons(0x0000);\r\nobj.record.name_len = (guint16) strlen(src_desc->input_name) + 1;\r\nobj.record.stack_len = (guint16) strlen(src_desc->stack_file) + 1;\r\nobj.record.extra.type = g_htonl(src_desc->input_type);\r\nswitch (src_desc->input_type) {\r\ncase K12_PORT_ATMPVC:\r\nobj.record.hwpart_len = g_htons(0x18);\r\nobj.record.extra.desc.atm.vp = g_htons(src_desc->input_info.atm.vp);\r\nobj.record.extra.desc.atm.vc = g_htons(src_desc->input_info.atm.vc);\r\noffset = 0x3c;\r\nbreak;\r\ncase K12_PORT_DS0S:\r\nobj.record.hwpart_len = g_htons(0x18);\r\nfor( i=0; i<32; i++ ) {\r\nobj.record.extra.desc.ds0mask.mask[i] =\r\n(src_desc->input_info.ds0mask & (1 << i)) ? 0xff : 0x00;\r\n}\r\noffset = 0x3c;\r\nbreak;\r\ndefault:\r\nobj.record.hwpart_len = g_htons(0x08);\r\noffset = 0x2c;\r\nbreak;\r\n}\r\nmemcpy(obj.buffer + offset,\r\nsrc_desc->input_name,\r\nobj.record.name_len);\r\nmemcpy(obj.buffer + offset + obj.record.name_len,\r\nsrc_desc->stack_file,\r\nobj.record.stack_len);\r\nlen = offset + obj.record.name_len + obj.record.stack_len;\r\nlen += (len % 4) ? 4 - (len % 4) : 0;\r\nobj.record.len = g_htonl(len);\r\nobj.record.name_len = g_htons(obj.record.name_len);\r\nobj.record.stack_len = g_htons(obj.record.stack_len);\r\nk12_dump_record(wdh,len,obj.buffer, &errxxx);\r\n}\r\nstatic gboolean k12_dump(wtap_dumper *wdh, const struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info _U_) {\r\nconst union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nk12_dump_t *k12 = (k12_dump_t *)wdh->priv;\r\nguint32 len;\r\nunion {\r\nguint8 buffer[8192];\r\nstruct {\r\nguint32 len;\r\nguint32 type;\r\nguint32 frame_len;\r\nguint32 input;\r\nguint32 datum_1;\r\nguint32 datum_2;\r\nguint64 ts;\r\nguint8 frame[0x1fc0];\r\n} record;\r\n} obj;\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\nif (k12->num_of_records == 0) {\r\nk12_t* file_data = (k12_t*)pseudo_header->k12.stuff;\r\ng_hash_table_foreach(file_data->src_by_id,k12_dump_src_setting,wdh);\r\n}\r\nobj.record.len = 0x20 + phdr->caplen;\r\nobj.record.len += (obj.record.len % 4) ? 4 - obj.record.len % 4 : 0;\r\nlen = obj.record.len;\r\nobj.record.len = g_htonl(obj.record.len);\r\nobj.record.type = g_htonl(K12_REC_PACKET);\r\nobj.record.frame_len = g_htonl(phdr->caplen);\r\nobj.record.input = g_htonl(pseudo_header->k12.input);\r\nobj.record.ts = GUINT64_TO_BE((((guint64)phdr->ts.secs - 631152000) * 2000000) + (phdr->ts.nsecs / 1000 * 2));\r\nmemcpy(obj.record.frame,pd,phdr->caplen);\r\nreturn k12_dump_record(wdh,len,obj.buffer, err);\r\n}\r\nstatic gboolean k12_dump_finish(wtap_dumper *wdh, int *err) {\r\nk12_dump_t *k12 = (k12_dump_t *)wdh->priv;\r\nunion {\r\nguint8 b[sizeof(guint32)];\r\nguint32 u;\r\n} d;\r\nif (! wtap_dump_file_write(wdh, k12_eof, 2, err))\r\nreturn FALSE;\r\nk12->file_len += 2;\r\nif (wtap_dump_file_seek(wdh, K12_FILE_HDR_FILE_SIZE, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nd.u = g_htonl(k12->file_len);\r\nif (! wtap_dump_file_write(wdh, d.b, 4, err))\r\nreturn FALSE;\r\nif (wtap_dump_file_seek(wdh, K12_FILE_HDR_PAGE_SIZE, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nd.u = g_htonl(8192);\r\nif (! wtap_dump_file_write(wdh, d.b, 4, err))\r\nreturn FALSE;\r\nif (wtap_dump_file_seek(wdh, K12_FILE_HDR_RECORD_COUNT_1, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nd.u = g_htonl(k12->num_of_records);\r\nif (! wtap_dump_file_write(wdh, d.b, 4, err))\r\nreturn FALSE;\r\nif (wtap_dump_file_seek(wdh, K12_FILE_HDR_RECORD_COUNT_2, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nd.u = g_htonl(k12->num_of_records);\r\nif (! wtap_dump_file_write(wdh, d.b, 4, err))\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\ngboolean k12_dump_open(wtap_dumper *wdh, int *err) {\r\nk12_dump_t *k12;\r\nif ( ! wtap_dump_file_write(wdh, k12_file_magic, 8, err)) {\r\nreturn FALSE;\r\n}\r\nif (wtap_dump_file_seek(wdh, K12_FILE_HDR_LEN, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nwdh->subtype_write = k12_dump;\r\nwdh->subtype_finish = k12_dump_finish;\r\nk12 = (k12_dump_t *)g_malloc(sizeof(k12_dump_t));\r\nwdh->priv = (void *)k12;\r\nk12->file_len = K12_FILE_HDR_LEN;\r\nk12->num_of_records = 0;\r\nk12->file_offset = K12_FILE_HDR_LEN;\r\nreturn TRUE;\r\n}
