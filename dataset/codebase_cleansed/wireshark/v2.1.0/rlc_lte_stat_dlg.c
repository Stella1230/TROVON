static void enable_filter_controls(guint8 enabled, guint8 rlcMode, rlc_lte_stat_t *hs)\r\n{\r\nguint8 show_dct_errors = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(hs->show_dct_errors_cb));\r\ngtk_widget_set_sensitive(hs->ul_filter_bt, enabled);\r\ngtk_widget_set_sensitive(hs->dl_filter_bt, enabled);\r\ngtk_widget_set_sensitive(hs->uldl_filter_bt, enabled);\r\ngtk_widget_set_sensitive(hs->ul_graph_bt, enabled);\r\ngtk_widget_set_sensitive(hs->dl_graph_bt, enabled);\r\ngtk_widget_set_sensitive(hs->show_mac_rach_cb, enabled);\r\ngtk_widget_set_sensitive(hs->show_mac_srs_cb, enabled);\r\ngtk_widget_set_sensitive(hs->show_dct_errors_cb, enabled);\r\ngtk_widget_set_sensitive(hs->dct_error_substring_lb, enabled && show_dct_errors);\r\ngtk_widget_set_sensitive(hs->dct_error_substring_te, enabled && show_dct_errors);\r\nswitch (rlcMode) {\r\ncase RLC_TM_MODE:\r\ngtk_widget_set_sensitive(hs->show_only_control_pdus_cb, FALSE);\r\ngtk_widget_set_sensitive(hs->sn_filter_lb, FALSE);\r\ngtk_widget_set_sensitive(hs->sn_filter_te, FALSE);\r\nbreak;\r\ncase RLC_UM_MODE:\r\ngtk_widget_set_sensitive(hs->show_only_control_pdus_cb, FALSE);\r\ngtk_widget_set_sensitive(hs->sn_filter_lb, TRUE);\r\ngtk_widget_set_sensitive(hs->sn_filter_te, TRUE);\r\nbreak;\r\ncase RLC_AM_MODE:\r\ngtk_widget_set_sensitive(hs->show_only_control_pdus_cb, TRUE);\r\ngtk_widget_set_sensitive(hs->sn_filter_lb, TRUE);\r\ngtk_widget_set_sensitive(hs->sn_filter_te, TRUE);\r\nbreak;\r\ndefault:\r\ngtk_widget_set_sensitive(hs->show_only_control_pdus_cb, FALSE);\r\ngtk_widget_set_sensitive(hs->sn_filter_lb, FALSE);\r\ngtk_widget_set_sensitive(hs->sn_filter_te, FALSE);\r\nbreak;\r\n}\r\n}\r\nstatic void rlc_lte_stat_reset(void *phs)\r\n{\r\nrlc_lte_stat_t *rlc_lte_stat = (rlc_lte_stat_t *)phs;\r\nrlc_lte_ep_t *list = rlc_lte_stat->ep_list;\r\ngchar *display_name;\r\ngchar title[256];\r\nGtkListStore *store;\r\nif (rlc_lte_stat->dlg_w != NULL) {\r\ndisplay_name = cf_get_display_name(&cfile);\r\ng_snprintf(title, sizeof(title), "Wireshark: LTE RLC Traffic Statistics: %s (filter=\"%s\")",\r\ndisplay_name,\r\nstrlen(rlc_lte_stat->filter) ? rlc_lte_stat->filter : "none");\r\ng_free(display_name);\r\ngtk_window_set_title(GTK_WINDOW(rlc_lte_stat->dlg_w), title);\r\n}\r\ng_snprintf(title, sizeof(title), "0 UEs");\r\ngtk_frame_set_label(GTK_FRAME(rlc_lte_stat->ues_lb), title);\r\nrlc_lte_stat->total_frames = 0;\r\nmemset(&rlc_lte_stat->common_stats, 0, sizeof(rlc_lte_common_stats));\r\nstore = GTK_LIST_STORE(gtk_tree_view_get_model(rlc_lte_stat->ue_table));\r\ngtk_list_store_clear(store);\r\nif (!list) {\r\nreturn;\r\n}\r\nrlc_lte_stat->ep_list = NULL;\r\n}\r\nstatic rlc_lte_ep_t* alloc_rlc_lte_ep(const struct rlc_lte_tap_info *si, packet_info *pinfo _U_)\r\n{\r\nrlc_lte_ep_t *ep;\r\nint n;\r\nif (!si) {\r\nreturn NULL;\r\n}\r\nif (!(ep = (rlc_lte_ep_t *)g_malloc(sizeof(rlc_lte_ep_t)))) {\r\nreturn NULL;\r\n}\r\nep->stats.ueid = si->ueid;\r\nep->stats.UL_frames = 0;\r\nep->stats.DL_frames = 0;\r\nep->stats.UL_total_bytes = 0;\r\nep->stats.DL_total_bytes = 0;\r\nmemset(&ep->stats.DL_time_start, 0, sizeof(nstime_t));\r\nmemset(&ep->stats.DL_time_stop, 0, sizeof(nstime_t));\r\nep->stats.UL_total_acks = 0;\r\nep->stats.DL_total_acks = 0;\r\nep->stats.UL_total_nacks = 0;\r\nep->stats.DL_total_nacks = 0;\r\nep->stats.UL_total_missing = 0;\r\nep->stats.DL_total_missing = 0;\r\nmemset(&ep->stats.CCCH_stats, 0, sizeof(rlc_channel_stats));\r\nfor (n=0; n < 2; n++) {\r\nmemset(&ep->stats.srb_stats[n], 0, sizeof(rlc_channel_stats));\r\n}\r\nfor (n=0; n < 32; n++) {\r\nmemset(&ep->stats.drb_stats[n], 0, sizeof(rlc_channel_stats));\r\n}\r\nep->next = NULL;\r\nep->iter_valid = FALSE;\r\nreturn ep;\r\n}\r\nstatic const char *print_rlc_channel_mode(guint8 mode)\r\n{\r\nstatic char unknown[32];\r\nswitch (mode) {\r\ncase RLC_TM_MODE: return "TM";\r\ncase RLC_UM_MODE: return "UM";\r\ncase RLC_AM_MODE: return "AM";\r\ncase RLC_PREDEF: return "Predef";\r\ndefault:\r\ng_snprintf(unknown, sizeof(unknown), "Unknown (%u)", mode);\r\nreturn unknown;\r\n}\r\n}\r\nstatic int rlc_lte_stat_packet(void *phs, packet_info *pinfo, epan_dissect_t *edt _U_,\r\nconst void *phi)\r\n{\r\nrlc_lte_stat_t *hs = (rlc_lte_stat_t *)phs;\r\nrlc_lte_ep_t *tmp = NULL, *te = NULL;\r\nrlc_channel_stats *channel_stats = NULL;\r\nconst struct rlc_lte_tap_info *si = (const struct rlc_lte_tap_info *)phi;\r\nif (!hs) {\r\nreturn 0;\r\n}\r\nif ((!hs->show_mac && si->loggedInMACFrame) ||\r\n(hs->show_mac && !si->loggedInMACFrame)) {\r\nreturn 0;\r\n}\r\nhs->total_frames++;\r\nswitch (si->channelType) {\r\ncase CHANNEL_TYPE_BCCH_BCH:\r\ncase CHANNEL_TYPE_BCCH_DL_SCH:\r\nhs->common_stats.bcch_frames++;\r\nhs->common_stats.bcch_bytes += si->pduLength;\r\nreturn 1;\r\ncase CHANNEL_TYPE_PCCH:\r\nhs->common_stats.pcch_frames++;\r\nhs->common_stats.pcch_bytes += si->pduLength;\r\nreturn 1;\r\ndefault:\r\nbreak;\r\n}\r\nif (!hs->ep_list) {\r\nhs->ep_list = alloc_rlc_lte_ep(si, pinfo);\r\nte = hs->ep_list;\r\n} else {\r\nfor (tmp = hs->ep_list; (tmp != NULL); tmp = tmp->next) {\r\nif (tmp->stats.ueid == si->ueid) {\r\nte = tmp;\r\nbreak;\r\n}\r\n}\r\nif (te == NULL) {\r\nif ((te = alloc_rlc_lte_ep(si, pinfo))) {\r\nrlc_lte_ep_t *p = hs->ep_list;\r\nwhile (p->next) {\r\np = p->next;\r\n}\r\np->next = te;\r\nte->next = NULL;\r\n}\r\n}\r\n}\r\nif (!te) {\r\nreturn 0;\r\n}\r\nte->stats.ueid = si->ueid;\r\nif (si->direction == DIRECTION_UPLINK) {\r\nif (te->stats.UL_frames == 0) {\r\nte->stats.UL_time_start = si->rlc_lte_time;\r\n}\r\nte->stats.UL_time_stop = si->rlc_lte_time;\r\nte->stats.UL_frames++;\r\nte->stats.UL_total_bytes += si->pduLength;\r\n}\r\nelse {\r\nif (te->stats.DL_frames == 0) {\r\nte->stats.DL_time_start = si->rlc_lte_time;\r\n}\r\nte->stats.DL_time_stop = si->rlc_lte_time;\r\nte->stats.DL_frames++;\r\nte->stats.DL_total_bytes += si->pduLength;\r\n}\r\nswitch (si->channelType) {\r\ncase CHANNEL_TYPE_CCCH:\r\nchannel_stats = &te->stats.CCCH_stats;\r\nbreak;\r\ncase CHANNEL_TYPE_SRB:\r\nchannel_stats = &te->stats.srb_stats[si->channelId-1];\r\nbreak;\r\ncase CHANNEL_TYPE_DRB:\r\nchannel_stats = &te->stats.drb_stats[si->channelId-1];\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (channel_stats != NULL) {\r\nchannel_stats->inUse = TRUE;\r\nchannel_stats->iter_valid = FALSE;\r\nchannel_stats->rlcMode = si->rlcMode;\r\nchannel_stats->channelType = si->channelType;\r\nchannel_stats->channelId = si->channelId;\r\nif (si->priority != 0) {\r\nchannel_stats->priority = si->priority;\r\n}\r\n}\r\nelse {\r\nreturn 0;\r\n}\r\nif (si->direction == DIRECTION_UPLINK) {\r\nif (channel_stats->UL_frames == 0) {\r\nchannel_stats->UL_time_start = si->rlc_lte_time;\r\n}\r\nchannel_stats->UL_time_stop = si->rlc_lte_time;\r\nchannel_stats->UL_frames++;\r\nchannel_stats->UL_bytes += si->pduLength;\r\nchannel_stats->UL_nacks += si->noOfNACKs;\r\nchannel_stats->UL_missing += si->missingSNs;\r\nif (si->isControlPDU) {\r\nchannel_stats->UL_acks++;\r\nte->stats.UL_total_acks++;\r\n}\r\nte->stats.UL_total_nacks += si->noOfNACKs;\r\nte->stats.UL_total_missing += si->missingSNs;\r\n}\r\nelse {\r\nif (channel_stats->DL_frames == 0) {\r\nchannel_stats->DL_time_start = si->rlc_lte_time;\r\n}\r\nchannel_stats->DL_time_stop = si->rlc_lte_time;\r\nchannel_stats->DL_frames++;\r\nchannel_stats->DL_bytes += si->pduLength;\r\nchannel_stats->DL_nacks += si->noOfNACKs;\r\nchannel_stats->DL_missing += si->missingSNs;\r\nif (si->isControlPDU) {\r\nchannel_stats->DL_acks++;\r\nte->stats.DL_total_acks++;\r\n}\r\nte->stats.DL_total_nacks += si->noOfNACKs;\r\nte->stats.DL_total_missing += si->missingSNs;\r\n}\r\nreturn 1;\r\n}\r\nstatic void invalidate_channel_iters(rlc_lte_stat_t *hs)\r\n{\r\ngint n;\r\nrlc_lte_ep_t *ep = hs->ep_list;\r\nwhile (ep) {\r\nep->stats.CCCH_stats.iter_valid = FALSE;\r\nfor (n=0; n < 2; n++) {\r\nep->stats.srb_stats[n].iter_valid = FALSE;\r\n}\r\nfor (n=0; n < 32; n++) {\r\nep->stats.drb_stats[n].iter_valid = FALSE;\r\n}\r\nep = ep->next;\r\n}\r\n}\r\nstatic float calculate_bw(nstime_t *start_time, nstime_t *stop_time, guint32 bytes)\r\n{\r\nif (memcmp(start_time, stop_time, sizeof(nstime_t)) != 0) {\r\nfloat elapsed_ms = (((float)stop_time->secs - (float)start_time->secs) * 1000) +\r\n(((float)stop_time->nsecs - (float)start_time->nsecs) / 1000000);\r\nif (elapsed_ms < 2.0) {\r\nreturn 0.0f;\r\n}\r\nreturn ((bytes * 8) / elapsed_ms) / 1000;\r\n}\r\nelse {\r\nreturn 0.0f;\r\n}\r\n}\r\nstatic void rlc_lte_channels(rlc_lte_ep_t *rlc_stat_ep, rlc_lte_stat_t *hs)\r\n{\r\nGtkListStore *channels_store = GTK_LIST_STORE(gtk_tree_view_get_model(hs->channel_table));\r\nrlc_channel_stats *channel_stats;\r\nchar buff[32];\r\nint n;\r\ngtk_list_store_clear(channels_store);\r\ninvalidate_channel_iters(hs);\r\nif (rlc_stat_ep == NULL) {\r\nreturn;\r\n}\r\nchannel_stats = &rlc_stat_ep->stats.CCCH_stats;\r\nif (channel_stats->inUse) {\r\nif (!channel_stats->iter_valid) {\r\ngtk_list_store_append(channels_store, &channel_stats->iter);\r\nchannel_stats->iter_valid = TRUE;\r\n}\r\ngtk_list_store_set(channels_store, &channel_stats->iter,\r\nCHANNEL_NAME, "CCCH",\r\nCHANNEL_MODE, print_rlc_channel_mode(channel_stats->rlcMode),\r\nCHANNEL_PRIORITY, 0,\r\nCHANNEL_UL_FRAMES, channel_stats->UL_frames,\r\nCHANNEL_UL_BYTES, channel_stats->UL_bytes,\r\nCHANNEL_DL_FRAMES, channel_stats->DL_frames,\r\nCHANNEL_DL_BYTES, channel_stats->DL_bytes,\r\nCHANNEL_TABLE_COLUMN, channel_stats,\r\n-1);\r\n}\r\nfor (n=0; n < 2; n++) {\r\nchannel_stats = &rlc_stat_ep->stats.srb_stats[n];\r\nif (channel_stats->inUse) {\r\nfloat UL_bw = calculate_bw(&channel_stats->UL_time_start,\r\n&channel_stats->UL_time_stop,\r\nchannel_stats->UL_bytes);\r\nfloat DL_bw = calculate_bw(&channel_stats->DL_time_start,\r\n&channel_stats->DL_time_stop,\r\nchannel_stats->DL_bytes);\r\nif (!channel_stats->iter_valid) {\r\ngtk_list_store_append(channels_store, &channel_stats->iter);\r\nchannel_stats->iter_valid = TRUE;\r\n}\r\ng_snprintf(buff, sizeof(buff), "SRB-%u", n+1);\r\ngtk_list_store_set(channels_store, &channel_stats->iter,\r\nCHANNEL_NAME, buff,\r\nCHANNEL_MODE, print_rlc_channel_mode(channel_stats->rlcMode),\r\nCHANNEL_PRIORITY, channel_stats->priority,\r\nCHANNEL_UL_FRAMES, channel_stats->UL_frames,\r\nCHANNEL_UL_BYTES, channel_stats->UL_bytes,\r\nCHANNEL_UL_BW, UL_bw,\r\nCHANNEL_UL_ACKS, channel_stats->UL_acks,\r\nCHANNEL_UL_NACKS, channel_stats->UL_nacks,\r\nCHANNEL_UL_MISSING, channel_stats->UL_missing,\r\nCHANNEL_DL_FRAMES, channel_stats->DL_frames,\r\nCHANNEL_DL_BYTES, channel_stats->DL_bytes,\r\nCHANNEL_DL_BW, DL_bw,\r\nCHANNEL_DL_ACKS, channel_stats->DL_acks,\r\nCHANNEL_DL_NACKS, channel_stats->DL_nacks,\r\nCHANNEL_DL_MISSING, channel_stats->DL_missing,\r\nCHANNEL_TABLE_COLUMN, channel_stats,\r\n-1);\r\n}\r\n}\r\nfor (n=0; n < 32; n++) {\r\nchannel_stats = &rlc_stat_ep->stats.drb_stats[n];\r\nif (channel_stats->inUse) {\r\nfloat UL_bw = calculate_bw(&channel_stats->UL_time_start,\r\n&channel_stats->UL_time_stop,\r\nchannel_stats->UL_bytes);\r\nfloat DL_bw = calculate_bw(&channel_stats->DL_time_start,\r\n&channel_stats->DL_time_stop,\r\nchannel_stats->DL_bytes);\r\nif (!channel_stats->iter_valid) {\r\ngtk_list_store_append(channels_store, &channel_stats->iter);\r\nchannel_stats->iter_valid = TRUE;\r\n}\r\ng_snprintf(buff, sizeof(buff), "DRB-%u", n+1);\r\ngtk_list_store_set(channels_store, &channel_stats->iter,\r\nCHANNEL_NAME, buff,\r\nCHANNEL_MODE, print_rlc_channel_mode(channel_stats->rlcMode),\r\nCHANNEL_PRIORITY, channel_stats->priority,\r\nCHANNEL_UL_FRAMES, channel_stats->UL_frames,\r\nCHANNEL_UL_BYTES, channel_stats->UL_bytes,\r\nCHANNEL_UL_BW, UL_bw,\r\nCHANNEL_UL_ACKS, channel_stats->UL_acks,\r\nCHANNEL_UL_NACKS, channel_stats->UL_nacks,\r\nCHANNEL_UL_MISSING, channel_stats->UL_missing,\r\nCHANNEL_DL_FRAMES, channel_stats->DL_frames,\r\nCHANNEL_DL_BYTES, channel_stats->DL_bytes,\r\nCHANNEL_DL_BW, DL_bw,\r\nCHANNEL_DL_ACKS, channel_stats->DL_acks,\r\nCHANNEL_DL_NACKS, channel_stats->DL_nacks,\r\nCHANNEL_DL_MISSING, channel_stats->DL_missing,\r\nCHANNEL_TABLE_COLUMN, channel_stats,\r\n-1);\r\n}\r\n}\r\n}\r\nstatic void rlc_lte_stat_draw(void *phs)\r\n{\r\ngchar buff[32];\r\nguint16 number_of_ues = 0;\r\ngchar *display_name;\r\ngchar title[256];\r\nrlc_lte_stat_t *hs = (rlc_lte_stat_t *)phs;\r\nrlc_lte_ep_t* list = hs->ep_list, *tmp = 0;\r\nGtkListStore *ues_store;\r\nGtkTreeSelection *sel;\r\nGtkTreeModel *model;\r\nGtkTreeIter iter;\r\nrlc_channel_stats *channel_stats = NULL;\r\ng_snprintf(buff, sizeof(buff), "BCCH Frames: %u", hs->common_stats.bcch_frames);\r\ngtk_label_set_text(GTK_LABEL(hs->common_bcch_frames), buff);\r\ng_snprintf(buff, sizeof(buff), "BCCH Bytes: %u", hs->common_stats.bcch_bytes);\r\ngtk_label_set_text(GTK_LABEL(hs->common_bcch_bytes), buff);\r\ng_snprintf(buff, sizeof(buff), "PCCH Frames: %u", hs->common_stats.pcch_frames);\r\ngtk_label_set_text(GTK_LABEL(hs->common_pcch_frames), buff);\r\ng_snprintf(buff, sizeof(buff), "PCCH Bytes: %u", hs->common_stats.pcch_bytes);\r\ngtk_label_set_text(GTK_LABEL(hs->common_pcch_bytes), buff);\r\nues_store = GTK_LIST_STORE(gtk_tree_view_get_model(hs->ue_table));\r\nfor (tmp = list; (tmp!=NULL); tmp=tmp->next, number_of_ues++);\r\ng_snprintf(title, sizeof(title), "%u UEs", number_of_ues);\r\ngtk_frame_set_label(GTK_FRAME(hs->ues_lb), title);\r\ndisplay_name = cf_get_display_name(&cfile);\r\ng_snprintf(title, sizeof(title), "Wireshark: LTE RLC Traffic Statistics: %s (%u UEs, %u frames) (filter=\"%s\")",\r\ndisplay_name,\r\nnumber_of_ues,\r\nhs->total_frames,\r\nstrlen(hs->filter) ? hs->filter : "none");\r\ng_free(display_name);\r\ngtk_window_set_title(GTK_WINDOW(hs->dlg_w), title);\r\nfor (tmp = list; tmp; tmp=tmp->next) {\r\nfloat UL_bw = calculate_bw(&tmp->stats.UL_time_start,\r\n&tmp->stats.UL_time_stop,\r\ntmp->stats.UL_total_bytes);\r\nfloat DL_bw = calculate_bw(&tmp->stats.DL_time_start,\r\n&tmp->stats.DL_time_stop,\r\ntmp->stats.DL_total_bytes);\r\nif (tmp->iter_valid != TRUE) {\r\ngtk_list_store_append(ues_store, &tmp->iter);\r\ntmp->iter_valid = TRUE;\r\n}\r\ngtk_list_store_set(ues_store, &tmp->iter,\r\nUEID_COLUMN, tmp->stats.ueid,\r\nUL_FRAMES_COLUMN, tmp->stats.UL_frames,\r\nUL_BYTES_COLUMN, tmp->stats.UL_total_bytes,\r\nUL_BW_COLUMN, UL_bw,\r\nUL_ACKS_COLUMN, tmp->stats.UL_total_acks,\r\nUL_NACKS_COLUMN, tmp->stats.UL_total_nacks,\r\nUL_MISSING_COLUMN, tmp->stats.UL_total_missing,\r\nDL_FRAMES_COLUMN, tmp->stats.DL_frames,\r\nDL_BYTES_COLUMN, tmp->stats.DL_total_bytes,\r\nDL_BW_COLUMN, DL_bw,\r\nDL_ACKS_COLUMN, tmp->stats.DL_total_acks,\r\nDL_NACKS_COLUMN, tmp->stats.DL_total_nacks,\r\nDL_MISSING_COLUMN, tmp->stats.DL_total_missing,\r\nUE_TABLE_COLUMN, tmp,\r\n-1);\r\n}\r\nif (hs->reselect_ue != 0) {\r\nGtkTreeIter *ue_iter = NULL;\r\nrlc_lte_ep_t *ep = hs->ep_list;\r\nwhile (ep != NULL) {\r\nif (ep->stats.ueid == hs->reselect_ue) {\r\nue_iter = &ep->iter;\r\nbreak;\r\n}\r\nep = ep->next;\r\n}\r\nif (ue_iter != NULL) {\r\ngtk_tree_selection_select_iter(gtk_tree_view_get_selection(hs->ue_table), ue_iter);\r\n}\r\n}\r\nsel = gtk_tree_view_get_selection(GTK_TREE_VIEW(hs->ue_table));\r\nif (gtk_tree_selection_get_selected(sel, &model, &iter)) {\r\nrlc_lte_ep_t *ep;\r\ngtk_tree_model_get(model, &iter, UE_TABLE_COLUMN, &ep, -1);\r\nrlc_lte_channels(ep, hs);\r\nswitch (hs->reselect_channel_type) {\r\ncase CHANNEL_TYPE_CCCH:\r\nchannel_stats = &(ep->stats.CCCH_stats);\r\nbreak;\r\ncase CHANNEL_TYPE_DRB:\r\nchannel_stats = &(ep->stats.drb_stats[hs->reselect_channel_id-1]);\r\nbreak;\r\ncase CHANNEL_TYPE_SRB:\r\nchannel_stats = &(ep->stats.srb_stats[hs->reselect_channel_id-1]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif ((channel_stats != NULL) && channel_stats->inUse && channel_stats->iter_valid) {\r\ngtk_tree_selection_select_iter(gtk_tree_view_get_selection(hs->channel_table), &channel_stats->iter);\r\n}\r\n}\r\n}\r\nstatic void rlc_lte_dct_errors_cb(GtkTreeSelection *sel _U_, gpointer data)\r\n{\r\nrlc_lte_stat_t *hs = (rlc_lte_stat_t*)data;\r\nguint8 show_dct_errors = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(hs->show_dct_errors_cb));\r\ngtk_widget_set_sensitive(hs->dct_error_substring_lb, show_dct_errors);\r\ngtk_widget_set_sensitive(hs->dct_error_substring_te, show_dct_errors);\r\n}\r\nstatic void rlc_lte_select_ue_cb(GtkTreeSelection *sel, gpointer data)\r\n{\r\nrlc_lte_ep_t *ep;\r\nGtkTreeModel *model;\r\nGtkTreeIter iter;\r\nrlc_lte_stat_t *hs = (rlc_lte_stat_t*)data;\r\nif (gtk_tree_selection_get_selected(sel, &model, &iter)) {\r\ngtk_tree_model_get(model, &iter, UE_TABLE_COLUMN, &ep, -1);\r\nhs->reselect_ue = ep->stats.ueid;\r\nrlc_lte_channels(ep, hs);\r\n}\r\nelse {\r\nrlc_lte_channels(NULL, hs);\r\n}\r\nenable_filter_controls(FALSE, 0, hs);\r\n}\r\nstatic void rlc_lte_select_channel_cb(GtkTreeSelection *sel, gpointer data)\r\n{\r\nGtkTreeModel *model;\r\nGtkTreeIter iter;\r\nrlc_lte_stat_t *hs = (rlc_lte_stat_t *)data;\r\nif (gtk_tree_selection_get_selected(sel, &model, &iter)) {\r\nguint16 ueid;\r\nguint8 rlcMode;\r\nif (get_channel_selection(hs, &ueid, &rlcMode,\r\n&(hs->reselect_channel_type), &(hs->reselect_channel_id))) {\r\nenable_filter_controls(TRUE, rlcMode, hs);\r\n}\r\n}\r\nelse {\r\nenable_filter_controls(FALSE, 0, hs);\r\n}\r\n}\r\nstatic void win_destroy_cb(GtkWindow *win _U_, gpointer data)\r\n{\r\nrlc_lte_stat_t *hs = (rlc_lte_stat_t *)data;\r\nremove_tap_listener(hs);\r\nif (hs->dlg_w != NULL) {\r\nwindow_destroy(hs->dlg_w);\r\nhs->dlg_w = NULL;\r\n}\r\nrlc_lte_stat_reset(hs);\r\ng_free(hs);\r\n}\r\nstatic void toggle_show_mac(GtkWidget *widget, gpointer data)\r\n{\r\nrlc_lte_stat_t *hs = (rlc_lte_stat_t *)data;\r\nhs->show_mac = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));\r\nrecent.gui_rlc_use_pdus_from_mac = hs->show_mac;\r\ncf_retap_packets(&cfile);\r\n}\r\nstatic int get_channel_selection(rlc_lte_stat_t *hs,\r\nguint16 *ueid, guint8 *rlcMode,\r\nguint16 *channelType, guint16 *channelId)\r\n{\r\nGtkTreeModel *model;\r\nGtkTreeIter iter;\r\nGtkTreeSelection *sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(hs->ue_table));\r\nif (gtk_tree_selection_get_selected(sel, &model, &iter)) {\r\nrlc_lte_ep_t *ep;\r\ngtk_tree_model_get(model, &iter, UE_TABLE_COLUMN, &ep, -1);\r\n*ueid = ep->stats.ueid;\r\nsel = gtk_tree_view_get_selection(GTK_TREE_VIEW(hs->channel_table));\r\nif (gtk_tree_selection_get_selected(sel, &model, &iter)) {\r\nrlc_channel_stats *channel_stats;\r\ngtk_tree_model_get(model, &iter, CHANNEL_TABLE_COLUMN, &channel_stats, -1);\r\n*rlcMode = channel_stats->rlcMode;\r\n*channelType = channel_stats->channelType;\r\n*channelId = channel_stats->channelId;\r\n}\r\nelse {\r\nreturn FALSE;\r\n}\r\n}\r\nelse {\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic void set_channel_filter_expression(guint16 ueid,\r\nguint8 rlcMode,\r\nguint16 channelType,\r\nguint16 channelId,\r\nChannelDirection_t channelDirection,\r\ngint filterOnSN,\r\ngint statusOnlyPDUs,\r\ngint showMACRACH,\r\ngint showMACSRs,\r\ngint showDCTErrors,\r\nconst gchar *DCTErrorSubstring,\r\nrlc_lte_stat_t *hs)\r\n{\r\n#define MAX_FILTER_LEN 1024\r\nstatic char buffer[MAX_FILTER_LEN];\r\nint offset = 0;\r\nif (showMACRACH) {\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset,\r\n"(mac-lte.rar or (mac-lte.preamble-sent and mac-lte.ueid == %u)) or (",\r\nueid);\r\n}\r\nif (showMACSRs) {\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset,\r\n"(mac-lte.sr-req and mac-lte.ueid == %u) or (",\r\nueid);\r\n}\r\nif (showDCTErrors) {\r\nif (strlen(DCTErrorSubstring) > 0) {\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset,\r\n"(dct2000.error-comment and (dct2000.comment contains \"%s\")) or (",\r\nDCTErrorSubstring);\r\n}\r\nelse {\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset,\r\n"dct2000.error-comment or (");\r\n}\r\n}\r\nif (strlen(hs->filter)) {\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset, "%s and ", hs->filter);\r\n}\r\nif (!hs->show_mac) {\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset, "not mac-lte and ");\r\n}\r\nelse {\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset, "mac-lte and ");\r\n}\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset, "(rlc-lte.ueid == %u) and ", ueid);\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset, "(rlc-lte.channel-type == %u)", channelType);\r\nif ((channelType == CHANNEL_TYPE_SRB) || (channelType == CHANNEL_TYPE_DRB)) {\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset, " and (rlc-lte.channel-id == %u)", channelId);\r\n}\r\nswitch (channelDirection) {\r\ncase UL_Only:\r\nif (rlcMode == RLC_AM_MODE) {\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset,\r\n" and (rlc-lte.direction == 1 and rlc-lte.am.frame-type == 0)");\r\nif (!statusOnlyPDUs) {\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset,\r\n" or (rlc-lte.direction == 0 and rlc-lte.am.frame-type == 1)");\r\n}\r\n}\r\nelse {\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset, " and (rlc-lte.direction == 0)");\r\n}\r\nbreak;\r\ncase DL_Only:\r\nif (rlcMode == RLC_AM_MODE) {\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset,\r\n" and (rlc-lte.direction == 0 and rlc-lte.am.frame-type == 0)");\r\nif (!statusOnlyPDUs) {\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset,\r\n" or (rlc-lte.direction == 1 and rlc-lte.am.frame-type == 1)");\r\n}\r\n}\r\nelse {\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset, " and (rlc-lte.direction == 1)");\r\n}\r\nbreak;\r\ncase UL_and_DL:\r\nif (rlcMode == RLC_AM_MODE) {\r\nif (statusOnlyPDUs) {\r\ng_snprintf(buffer+offset, MAX_FILTER_LEN-offset, " and (rlc-lte.am.frame-type == 0)");\r\n}\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nif (filterOnSN != -1) {\r\nswitch (rlcMode) {\r\ncase RLC_AM_MODE:\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset,\r\n" and ((rlc-lte.am.fixed.sn == %u) or "\r\n"(rlc-lte.am.ack-sn == %u) or "\r\n"(rlc-lte.am.nack-sn == %u))",\r\nfilterOnSN, (filterOnSN+1) % 1024, filterOnSN);\r\nbreak;\r\ncase RLC_UM_MODE:\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset,\r\n" and (rlc-lte.um.sn == %u)", filterOnSN);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (showDCTErrors) {\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset, ")");\r\n}\r\nif (showMACSRs) {\r\noffset += g_snprintf(buffer+offset, MAX_FILTER_LEN-offset, ")");\r\n}\r\nif (showMACRACH) {\r\ng_snprintf(buffer+offset, MAX_FILTER_LEN-offset, ")");\r\n}\r\ngtk_entry_set_text(GTK_ENTRY(main_display_filter_widget), buffer);\r\nmain_filter_packets(&cfile, buffer, TRUE);\r\n}\r\nstatic void ul_filter_clicked(GtkWindow *win _U_, rlc_lte_stat_t* hs)\r\n{\r\nguint16 ueid;\r\nguint8 rlcMode;\r\nguint16 channelType;\r\nguint16 channelId;\r\nint sn = -1;\r\nconst gchar *sn_string;\r\nsn_string = gtk_entry_get_text(GTK_ENTRY(hs->sn_filter_te));\r\nif (strlen(sn_string) > 0) {\r\nsn = atoi(sn_string);\r\n}\r\nif (!get_channel_selection(hs, &ueid, &rlcMode, &channelType, &channelId)) {\r\nreturn;\r\n}\r\nset_channel_filter_expression(ueid, rlcMode, channelType, channelId, UL_Only, sn,\r\ngtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(hs->show_only_control_pdus_cb)),\r\ngtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(hs->show_mac_rach_cb)),\r\ngtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(hs->show_mac_srs_cb)),\r\ngtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(hs->show_dct_errors_cb)),\r\ngtk_entry_get_text(GTK_ENTRY(hs->dct_error_substring_te)),\r\nhs);\r\n}\r\nstatic void dl_filter_clicked(GtkWindow *win _U_, rlc_lte_stat_t* hs)\r\n{\r\nguint16 ueid;\r\nguint8 rlcMode;\r\nguint16 channelType;\r\nguint16 channelId;\r\nint sn = -1;\r\nconst gchar *sn_string;\r\nsn_string = gtk_entry_get_text(GTK_ENTRY(hs->sn_filter_te));\r\nif (strlen(sn_string) > 0) {\r\nsn = atoi(sn_string);\r\n}\r\nif (!get_channel_selection(hs, &ueid, &rlcMode, &channelType, &channelId)) {\r\nreturn;\r\n}\r\nset_channel_filter_expression(ueid, rlcMode, channelType, channelId, DL_Only, sn,\r\ngtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(hs->show_only_control_pdus_cb)),\r\ngtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(hs->show_mac_rach_cb)),\r\ngtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(hs->show_mac_srs_cb)),\r\ngtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(hs->show_dct_errors_cb)),\r\ngtk_entry_get_text(GTK_ENTRY(hs->dct_error_substring_te)),\r\nhs);\r\n}\r\nstatic void uldl_filter_clicked(GtkWindow *win _U_, rlc_lte_stat_t* hs)\r\n{\r\nguint16 ueid;\r\nguint8 rlcMode;\r\nguint16 channelType;\r\nguint16 channelId;\r\nint sn = -1;\r\nconst gchar *sn_string;\r\nsn_string = gtk_entry_get_text(GTK_ENTRY(hs->sn_filter_te));\r\nif (strlen(sn_string) > 0) {\r\nsn = atoi(sn_string);\r\n}\r\nif (!get_channel_selection(hs, &ueid, &rlcMode, &channelType, &channelId)) {\r\nreturn;\r\n}\r\nset_channel_filter_expression(ueid, rlcMode, channelType, channelId, UL_and_DL, sn,\r\ngtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(hs->show_only_control_pdus_cb)),\r\ngtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(hs->show_mac_rach_cb)),\r\ngtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(hs->show_mac_srs_cb)),\r\ngtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(hs->show_dct_errors_cb)),\r\ngtk_entry_get_text(GTK_ENTRY(hs->dct_error_substring_te)),\r\nhs);\r\n}\r\nstatic void ul_graph_clicked(GtkWidget *win _U_, rlc_lte_stat_t* hs)\r\n{\r\nguint16 ueid, channelType, channelId;\r\nguint8 rlcMode;\r\nif (!get_channel_selection(hs, &ueid, &rlcMode, &channelType, &channelId)) {\r\nreturn;\r\n}\r\nrlc_lte_graph_known_channel_launch(ueid, rlcMode, channelType, channelId, DIRECTION_UPLINK);\r\n}\r\nstatic void dl_graph_clicked(GtkWidget *win _U_, rlc_lte_stat_t* hs)\r\n{\r\nguint16 ueid, channelType, channelId;\r\nguint8 rlcMode;\r\nif (!get_channel_selection(hs, &ueid, &rlcMode, &channelType, &channelId)) {\r\nreturn;\r\n}\r\nrlc_lte_graph_known_channel_launch(ueid, rlcMode, channelType, channelId, DIRECTION_DOWNLINK);\r\n}\r\nstatic void gtk_rlc_lte_stat_init(const char *opt_arg, void *userdata _U_)\r\n{\r\nrlc_lte_stat_t *hs;\r\nconst char *filter = NULL;\r\nGString *error_string;\r\nGtkWidget *ues_scrolled_window;\r\nGtkWidget *channels_scrolled_window;\r\nGtkWidget *bbox;\r\nGtkWidget *top_level_vbox;\r\nGtkWidget *pdu_source_lb;\r\nGtkWidget *common_channel_lb;\r\nGtkWidget *channels_lb;\r\nGtkWidget *action_buttons_lb;\r\nGtkWidget *common_row_hbox;\r\nGtkWidget *show_mac_cb;\r\nGtkWidget *ues_vb;\r\nGtkWidget *channels_vb;\r\nGtkWidget *filter_vb;\r\nGtkWidget *action_buttons_hb;\r\nGtkWidget *sn_filter_hb;\r\nGtkWidget *close_bt;\r\nGtkWidget *help_bt;\r\nGtkListStore *store;\r\nGtkTreeView *tree_view;\r\nGtkCellRenderer *renderer;\r\nGtkTreeViewColumn *column;\r\nGtkTreeSelection *sel;\r\ngchar *display_name;\r\ngchar title[256];\r\ngint i;\r\nif (strncmp(opt_arg, "rlc-lte,stat,", 13) == 0) {\r\nfilter = opt_arg + 13;\r\n}\r\nelse {\r\nfilter = NULL;\r\n}\r\nhs = (rlc_lte_stat_t *)g_malloc(sizeof(rlc_lte_stat_t));\r\nhs->ep_list = NULL;\r\nif (filter) {\r\nhs->filter = g_strdup(filter);\r\n}\r\nelse {\r\nhs->filter = NULL;\r\n}\r\ndisplay_name = cf_get_display_name(&cfile);\r\ng_snprintf(title, sizeof(title), "Wireshark: LTE RLC Statistics: %s",\r\ndisplay_name);\r\ng_free(display_name);\r\nhs->dlg_w = window_new_with_geom(GTK_WINDOW_TOPLEVEL, title, "LTE RLC Statistics", GTK_WIN_POS_CENTER_ON_PARENT);\r\ngtk_window_set_default_size(GTK_WINDOW(hs->dlg_w), 600, 300);\r\ntop_level_vbox = ws_gtk_box_new(GTK_ORIENTATION_VERTICAL, 3, FALSE);\r\ngtk_container_add(GTK_CONTAINER(hs->dlg_w), top_level_vbox);\r\ngtk_container_set_border_width(GTK_CONTAINER(top_level_vbox), 6);\r\ngtk_widget_show(top_level_vbox);\r\npdu_source_lb = gtk_frame_new("PDUs to use");\r\nshow_mac_cb = gtk_check_button_new_with_mnemonic("Show RLC PDUs found inside logged MAC frames");\r\ngtk_container_add(GTK_CONTAINER(pdu_source_lb), show_mac_cb);\r\ngtk_widget_set_tooltip_text(show_mac_cb, "Can either use separately-logged RLC PDUs, OR find them "\r\n"decoded inside MAC PDUs (enabled in MAC dissector preferences)");\r\ngtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(show_mac_cb),\r\nrecent.gui_rlc_use_pdus_from_mac);\r\nhs->show_mac = recent.gui_rlc_use_pdus_from_mac;\r\ngtk_box_pack_start(GTK_BOX(top_level_vbox), pdu_source_lb, FALSE, FALSE, 0);\r\ng_signal_connect(show_mac_cb, "toggled", G_CALLBACK(toggle_show_mac), hs);\r\ncommon_channel_lb = gtk_frame_new("Common Channel Data");\r\ncommon_row_hbox = ws_gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0, FALSE);\r\ngtk_container_add(GTK_CONTAINER(common_channel_lb), common_row_hbox);\r\ngtk_container_set_border_width(GTK_CONTAINER(common_row_hbox), 5);\r\ngtk_box_pack_start(GTK_BOX(top_level_vbox), common_channel_lb, FALSE, FALSE, 0);\r\nhs->common_bcch_frames = gtk_label_new("BCCH Frames:");\r\ngtk_misc_set_alignment(GTK_MISC(hs->common_bcch_frames), 0.0f, .5f);\r\ngtk_box_pack_start(GTK_BOX(common_row_hbox), hs->common_bcch_frames, TRUE, TRUE, 0);\r\ngtk_widget_show(hs->common_bcch_frames);\r\nhs->common_bcch_bytes = gtk_label_new("BCCH Bytes:");\r\ngtk_misc_set_alignment(GTK_MISC(hs->common_bcch_bytes), 0.0f, .5f);\r\ngtk_box_pack_start(GTK_BOX(common_row_hbox), hs->common_bcch_bytes, TRUE, TRUE, 0);\r\ngtk_widget_show(hs->common_bcch_bytes);\r\nhs->common_pcch_frames = gtk_label_new("PCCH Frames:");\r\ngtk_misc_set_alignment(GTK_MISC(hs->common_pcch_frames), 0.0f, .5f);\r\ngtk_box_pack_start(GTK_BOX(common_row_hbox), hs->common_pcch_frames, TRUE, TRUE, 0);\r\ngtk_widget_show(hs->common_pcch_frames);\r\nhs->common_pcch_bytes = gtk_label_new("PCCH Bytes:");\r\ngtk_misc_set_alignment(GTK_MISC(hs->common_pcch_bytes), 0.0f, .5f);\r\ngtk_box_pack_start(GTK_BOX(common_row_hbox), hs->common_pcch_bytes, TRUE, TRUE, 0);\r\ngtk_widget_show(hs->common_pcch_bytes);\r\nhs->ues_lb = gtk_frame_new("UE Data (0 UEs)");\r\nues_vb = ws_gtk_box_new(GTK_ORIENTATION_VERTICAL, 0, FALSE);\r\ngtk_container_add(GTK_CONTAINER(hs->ues_lb), ues_vb);\r\ngtk_container_set_border_width(GTK_CONTAINER(ues_vb), 5);\r\nues_scrolled_window = scrolled_window_new(NULL, NULL);\r\ngtk_box_pack_start(GTK_BOX(ues_vb), ues_scrolled_window, TRUE, TRUE, 0);\r\ngtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(ues_scrolled_window),\r\nGTK_SHADOW_IN);\r\nstore = gtk_list_store_new(NUM_UE_COLUMNS, G_TYPE_INT,\r\nG_TYPE_INT, G_TYPE_INT, G_TYPE_FLOAT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT,\r\nG_TYPE_INT, G_TYPE_INT, G_TYPE_FLOAT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT,\r\nG_TYPE_POINTER);\r\nhs->ue_table = GTK_TREE_VIEW(tree_view_new(GTK_TREE_MODEL(store)));\r\ngtk_container_add(GTK_CONTAINER (ues_scrolled_window), GTK_WIDGET(hs->ue_table));\r\ng_object_unref(G_OBJECT(store));\r\ntree_view = hs->ue_table;\r\ngtk_tree_view_set_headers_visible(tree_view, TRUE);\r\ngtk_tree_view_set_headers_clickable(tree_view, TRUE);\r\nfor (i = 0; i < UE_TABLE_COLUMN; i++) {\r\nrenderer = gtk_cell_renderer_text_new();\r\ncolumn = gtk_tree_view_column_new_with_attributes(ue_titles[i], renderer,\r\n"text", i, NULL);\r\ngtk_tree_view_column_set_sort_column_id(column, i);\r\nif (i == 0) {\r\ngtk_tree_view_column_set_expand(column, TRUE);\r\n} else {\r\ng_object_set(G_OBJECT(renderer), "xalign", 1.0, NULL);\r\n}\r\ngtk_tree_view_column_set_sizing(column, GTK_TREE_VIEW_COLUMN_AUTOSIZE);\r\ngtk_tree_view_column_set_resizable(column, TRUE);\r\ngtk_tree_view_append_column(tree_view, column);\r\n}\r\nsel = gtk_tree_view_get_selection(GTK_TREE_VIEW(hs->ue_table));\r\ngtk_tree_selection_set_mode(sel, GTK_SELECTION_SINGLE);\r\ng_signal_connect(sel, "changed", G_CALLBACK(rlc_lte_select_ue_cb), hs);\r\ngtk_box_pack_start(GTK_BOX(top_level_vbox), hs->ues_lb, TRUE, TRUE, 0);\r\nchannels_lb = gtk_frame_new("Channels of selected UE");\r\nchannels_vb = ws_gtk_box_new(GTK_ORIENTATION_VERTICAL, 6, FALSE);\r\ngtk_container_add(GTK_CONTAINER(channels_lb), channels_vb);\r\ngtk_container_set_border_width(GTK_CONTAINER(channels_vb), 5);\r\nchannels_scrolled_window = scrolled_window_new(NULL, NULL);\r\ngtk_box_pack_start(GTK_BOX(channels_vb), channels_scrolled_window, TRUE, TRUE, 0);\r\ngtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(channels_scrolled_window),\r\nGTK_SHADOW_IN);\r\nstore = gtk_list_store_new(NUM_CHANNEL_COLUMNS,\r\nG_TYPE_STRING, G_TYPE_STRING, G_TYPE_INT,\r\nG_TYPE_INT, G_TYPE_INT, G_TYPE_FLOAT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT,\r\nG_TYPE_INT, G_TYPE_INT, G_TYPE_FLOAT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT,\r\nG_TYPE_POINTER);\r\nhs->channel_table = GTK_TREE_VIEW(tree_view_new(GTK_TREE_MODEL(store)));\r\ngtk_container_add(GTK_CONTAINER (channels_scrolled_window), GTK_WIDGET(hs->channel_table));\r\ng_object_unref(G_OBJECT(store));\r\ntree_view = hs->channel_table;\r\ngtk_tree_view_set_headers_visible(tree_view, TRUE);\r\ngtk_tree_view_set_headers_clickable(tree_view, TRUE);\r\nfor (i = 0; i < CHANNEL_TABLE_COLUMN; i++) {\r\nrenderer = gtk_cell_renderer_text_new();\r\ncolumn = gtk_tree_view_column_new_with_attributes(channel_titles[i], renderer,\r\n"text", i, NULL);\r\ngtk_tree_view_column_set_sort_column_id(column, i);\r\nif (i == 0) {\r\ngtk_tree_view_column_set_expand(column, TRUE);\r\n} else {\r\ng_object_set(G_OBJECT(renderer), "xalign", 1.0, NULL);\r\n}\r\ngtk_tree_view_column_set_sizing(column, GTK_TREE_VIEW_COLUMN_AUTOSIZE);\r\ngtk_tree_view_column_set_resizable(column, TRUE);\r\ngtk_tree_view_append_column(tree_view, column);\r\n}\r\nsel = gtk_tree_view_get_selection(GTK_TREE_VIEW(hs->channel_table));\r\ngtk_tree_selection_set_mode(sel, GTK_SELECTION_SINGLE);\r\ng_signal_connect(sel, "changed", G_CALLBACK(rlc_lte_select_channel_cb), hs);\r\ngtk_box_pack_start(GTK_BOX(top_level_vbox), channels_lb, TRUE, TRUE, 0);\r\naction_buttons_lb = gtk_frame_new("Action on selected channel");\r\nfilter_vb = ws_gtk_box_new(GTK_ORIENTATION_VERTICAL, 3, FALSE);\r\ngtk_container_add(GTK_CONTAINER(action_buttons_lb), filter_vb);\r\naction_buttons_hb = ws_gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 6, FALSE);\r\ngtk_box_pack_start(GTK_BOX(filter_vb), action_buttons_hb, FALSE, FALSE, 0);\r\ngtk_container_set_border_width(GTK_CONTAINER(action_buttons_hb), 2);\r\nhs->ul_filter_bt = gtk_button_new_with_label("UL display filter for this channel");\r\ngtk_box_pack_start(GTK_BOX(action_buttons_hb), hs->ul_filter_bt, TRUE, TRUE, 0);\r\ng_signal_connect(hs->ul_filter_bt, "clicked", G_CALLBACK(ul_filter_clicked), hs);\r\ngtk_widget_show(hs->ul_filter_bt);\r\ngtk_widget_set_tooltip_text(hs->ul_filter_bt, "Generate and set a display filter to show frames "\r\n"associated with the channel, in the UL direction only. "\r\n"N.B. DL Status PDUs sent on this channel will also be shown for AM");\r\nhs->dl_filter_bt = gtk_button_new_with_label("DL display filter for this channel");\r\ngtk_box_pack_start(GTK_BOX(action_buttons_hb), hs->dl_filter_bt, TRUE, TRUE, 0);\r\ng_signal_connect(hs->dl_filter_bt, "clicked", G_CALLBACK(dl_filter_clicked), hs);\r\ngtk_widget_show(hs->dl_filter_bt);\r\ngtk_widget_set_tooltip_text(hs->dl_filter_bt, "Generate and set a display filter to show frames "\r\n"associated with the channel, in the DL direction only. "\r\n"N.B. UL Status PDUs sent on this channel will also be shown for AM");\r\nhs->uldl_filter_bt = gtk_button_new_with_label("UL / DL display filter for this channel");\r\ngtk_box_pack_start(GTK_BOX(action_buttons_hb), hs->uldl_filter_bt, TRUE, TRUE, 0);\r\ng_signal_connect(hs->uldl_filter_bt, "clicked", G_CALLBACK(uldl_filter_clicked), hs);\r\ngtk_widget_show(hs->uldl_filter_bt);\r\ngtk_widget_set_tooltip_text(hs->uldl_filter_bt, "Generate and set a display filter to show frames "\r\n"associated with the channel, in UL and DL");\r\nhs->ul_graph_bt = gtk_button_new_with_label("UL Graph");\r\ngtk_box_pack_start(GTK_BOX(action_buttons_hb), hs->ul_graph_bt, TRUE, TRUE, 0);\r\ng_signal_connect(hs->ul_graph_bt, "clicked", G_CALLBACK(ul_graph_clicked), hs);\r\ngtk_widget_show(hs->ul_graph_bt);\r\ngtk_widget_set_tooltip_text(hs->ul_graph_bt, "Launch RLC graph for this channel in UL");\r\nhs->dl_graph_bt = gtk_button_new_with_label("DL Graph");\r\ngtk_box_pack_start(GTK_BOX(action_buttons_hb), hs->dl_graph_bt, TRUE, TRUE, 0);\r\ng_signal_connect(hs->dl_graph_bt, "clicked", G_CALLBACK(dl_graph_clicked), hs);\r\ngtk_widget_show(hs->dl_graph_bt);\r\ngtk_widget_set_tooltip_text(hs->dl_graph_bt, "Launch RLC graph for this channel in DL");\r\nsn_filter_hb = ws_gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 3, FALSE);\r\ngtk_box_pack_start(GTK_BOX(filter_vb), sn_filter_hb, FALSE, FALSE, 0);\r\ngtk_widget_show(sn_filter_hb);\r\nhs->show_only_control_pdus_cb = gtk_check_button_new_with_mnemonic("Show only status PDUs");\r\ngtk_container_add(GTK_CONTAINER(sn_filter_hb), hs->show_only_control_pdus_cb);\r\ngtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(hs->show_only_control_pdus_cb), FALSE);\r\ngtk_widget_set_tooltip_text(hs->show_only_control_pdus_cb, "Generated filters will only show AM status PDUs "\r\n"(i.e. if you filter on UL you'll see ACKs/NACK replies sent in the DL)");\r\nhs->show_mac_rach_cb = gtk_check_button_new_with_mnemonic("Show MAC RACH");\r\ngtk_container_add(GTK_CONTAINER(sn_filter_hb), hs->show_mac_rach_cb);\r\ngtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(hs->show_mac_rach_cb), FALSE);\r\ngtk_widget_set_tooltip_text(hs->show_mac_rach_cb, "When checked, generated filters will show "\r\n"MAC RACH attempts for the UE");\r\nhs->show_mac_srs_cb = gtk_check_button_new_with_mnemonic("Show MAC SRs");\r\ngtk_container_add(GTK_CONTAINER(sn_filter_hb), hs->show_mac_srs_cb);\r\ngtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(hs->show_mac_srs_cb), FALSE);\r\ngtk_widget_set_tooltip_text(hs->show_mac_srs_cb, "When checked, generated filters will show "\r\n"MAC SRs for the UE");\r\nhs->show_dct_errors_cb = gtk_check_button_new_with_mnemonic("Show DCT2000 error strings...");\r\ngtk_container_add(GTK_CONTAINER(sn_filter_hb), hs->show_dct_errors_cb);\r\ngtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(hs->show_dct_errors_cb), FALSE);\r\ng_signal_connect(hs->show_dct_errors_cb, "toggled", G_CALLBACK(rlc_lte_dct_errors_cb), hs);\r\ngtk_widget_set_tooltip_text(hs->show_dct_errors_cb, "When checked, generated filters will "\r\n"include DCT2000 error strings");\r\nhs->dct_error_substring_lb = gtk_label_new("...containing");\r\ngtk_box_pack_start(GTK_BOX(sn_filter_hb), hs->dct_error_substring_lb, FALSE, FALSE, 0);\r\ngtk_widget_show(hs->dct_error_substring_lb);\r\nhs->dct_error_substring_te = gtk_entry_new();\r\ngtk_box_pack_start(GTK_BOX(sn_filter_hb), hs->dct_error_substring_te, FALSE, FALSE, 0);\r\ngtk_widget_show(hs->dct_error_substring_te);\r\ngtk_widget_set_tooltip_text(hs->dct_error_substring_te,\r\n"If given, only match error strings containing this substring");\r\nhs->sn_filter_te = gtk_entry_new();\r\ngtk_box_pack_end(GTK_BOX(sn_filter_hb), hs->sn_filter_te, FALSE, FALSE, 0);\r\ngtk_widget_show(hs->sn_filter_te);\r\ngtk_widget_set_tooltip_text(hs->sn_filter_te, "Can limit generated filters to a given sequence number (0-1023). "\r\n"Will also include relevant AM status PDUs");\r\nhs->sn_filter_lb = gtk_label_new("Sequence number to filter on:");\r\ngtk_box_pack_end(GTK_BOX(sn_filter_hb), hs->sn_filter_lb, FALSE, FALSE, 0);\r\ngtk_widget_show(hs->sn_filter_lb);\r\ngtk_box_pack_start(GTK_BOX(top_level_vbox), action_buttons_lb, FALSE, FALSE, 0);\r\nenable_filter_controls(FALSE, 0, hs);\r\nerror_string = register_tap_listener("rlc-lte", hs,\r\nfilter, 0,\r\nrlc_lte_stat_reset,\r\nrlc_lte_stat_packet,\r\nrlc_lte_stat_draw);\r\nif (error_string) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s", error_string->str);\r\ng_string_free(error_string, TRUE);\r\ng_free(hs);\r\nreturn;\r\n}\r\nbbox = dlg_button_row_new(GTK_STOCK_CLOSE, GTK_STOCK_HELP, NULL);\r\ngtk_box_pack_end(GTK_BOX(top_level_vbox), bbox, FALSE, FALSE, 0);\r\nclose_bt = (GtkWidget *)g_object_get_data(G_OBJECT(bbox), GTK_STOCK_CLOSE);\r\nwindow_set_cancel_button(hs->dlg_w, close_bt, window_cancel_button_cb);\r\nhelp_bt = (GtkWidget *)g_object_get_data(G_OBJECT(bbox), GTK_STOCK_HELP);\r\ng_signal_connect(help_bt, "clicked", G_CALLBACK(topic_cb), (gpointer)HELP_STATS_LTE_RLC_TRAFFIC_DIALOG);\r\ng_signal_connect(hs->dlg_w, "delete_event", G_CALLBACK(window_delete_event_cb), NULL);\r\ng_signal_connect(hs->dlg_w, "destroy", G_CALLBACK(win_destroy_cb), hs);\r\ngtk_widget_show_all(hs->dlg_w);\r\nwindow_present(hs->dlg_w);\r\ncf_retap_packets(&cfile);\r\ngdk_window_raise(gtk_widget_get_window(hs->dlg_w));\r\n}\r\nvoid\r\nregister_tap_listener_rlc_lte_stat(void)\r\n{\r\nregister_param_stat(&rlc_lte_stat_dlg, "_RLC", REGISTER_STAT_GROUP_TELEPHONY_LTE);\r\n}
