static int filehandler_cb_error_handler(lua_State* L) {\r\nconst gchar* error = lua_tostring(L,1);\r\nconst gchar* functype = luaL_optstring(L, lua_upvalueindex(1), "UNKNOWN");\r\nreport_failure("Lua: Error During execution of FileHandler %s callback:\n %s",functype,error);\r\nlua_pop(L, 1);\r\nreturn 0;\r\n}\r\nstatic int push_error_handler(lua_State* L, const gchar* funcname) {\r\nlua_pushstring(L, funcname);\r\nlua_pushcclosure(L, filehandler_cb_error_handler, 1);\r\nreturn 1;\r\n}\r\nstatic wtap_open_return_val\r\nwslua_filehandler_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nFileHandler fh = (FileHandler)(wth->wslua_data);\r\nwtap_open_return_val retval = WTAP_OPEN_NOT_MINE;\r\nlua_State* L = NULL;\r\nFile *fp = NULL;\r\nCaptureInfo *fc = NULL;\r\nINIT_FILEHANDLER_ROUTINE(read_open,WTAP_OPEN_NOT_MINE);\r\ncreate_wth_priv(L, wth);\r\nfp = push_File(L, wth->fh);\r\nfc = push_CaptureInfo(L, wth, TRUE);\r\nerrno = WTAP_ERR_CANT_OPEN;\r\nswitch ( lua_pcall(L,2,1,1) ) {\r\ncase 0:\r\nretval = (wtap_open_return_val)wslua_optboolint(L,-1,0);\r\nbreak;\r\nCASE_ERROR_ERRINFO("read_open")\r\n}\r\nEND_FILEHANDLER_ROUTINE();\r\n(*fp)->expired = TRUE;\r\n(*fc)->expired = TRUE;\r\nif (retval == WTAP_OPEN_MINE) {\r\nif (fh->read_ref != LUA_NOREF) {\r\nwth->subtype_read = wslua_filehandler_read;\r\n}\r\nelse {\r\ng_warning("Lua file format module lacks a read routine");\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (fh->seek_read_ref != LUA_NOREF) {\r\nwth->subtype_seek_read = wslua_filehandler_seek_read;\r\n}\r\nelse {\r\ng_warning("Lua file format module lacks a seek-read routine");\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (fh->read_close_ref != LUA_NOREF)\r\nwth->subtype_close = wslua_filehandler_close;\r\nelse\r\nwth->subtype_close = NULL;\r\nif (fh->seq_read_close_ref != LUA_NOREF)\r\nwth->subtype_sequential_close = wslua_filehandler_sequential_close;\r\nelse\r\nwth->subtype_sequential_close = NULL;\r\nwth->file_type_subtype = fh->file_type;\r\n}\r\nelse if (retval == WTAP_OPEN_ERROR) {\r\nif (err) {\r\n*err = WTAP_ERR_CANT_OPEN;\r\n}\r\n}\r\nelse if (retval == WTAP_OPEN_NOT_MINE) {\r\nremove_wth_priv(L, wth);\r\n}\r\nelse {\r\ng_warning("FileHandler read_open routine returned %d", retval);\r\nif (err) {\r\n*err = WTAP_ERR_INTERNAL;\r\n}\r\nretval = WTAP_OPEN_ERROR;\r\n}\r\nlua_settop(L,0);\r\nreturn retval;\r\n}\r\nstatic gboolean\r\nwslua_filehandler_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\nFileHandler fh = (FileHandler)(wth->wslua_data);\r\nint retval = -1;\r\nlua_State* L = NULL;\r\nFile *fp = NULL;\r\nCaptureInfo *fc = NULL;\r\nFrameInfo *fi = NULL;\r\nINIT_FILEHANDLER_ROUTINE(read,FALSE);\r\nif (err) {\r\n*err = errno = 0;\r\n}\r\nwth->phdr.opt_comment = NULL;\r\nfp = push_File(L, wth->fh);\r\nfc = push_CaptureInfo(L, wth, FALSE);\r\nfi = push_FrameInfo(L, &wth->phdr, wth->frame_buffer);\r\nswitch ( lua_pcall(L,3,1,1) ) {\r\ncase 0:\r\nif (lua_isnumber(L,-1)) {\r\n*data_offset = wslua_togint64(L, -1);\r\nretval = 1;\r\nbreak;\r\n}\r\nretval = wslua_optboolint(L,-1,0);\r\nbreak;\r\nCASE_ERROR_ERRINFO("read")\r\n}\r\nEND_FILEHANDLER_ROUTINE();\r\n(*fp)->expired = TRUE;\r\n(*fc)->expired = TRUE;\r\n(*fi)->expired = TRUE;\r\nlua_settop(L,0);\r\nreturn (retval == 1);\r\n}\r\nstatic gboolean\r\nwslua_filehandler_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf,\r\nint *err, gchar **err_info)\r\n{\r\nFileHandler fh = (FileHandler)(wth->wslua_data);\r\nint retval = -1;\r\nlua_State* L = NULL;\r\nFile *fp = NULL;\r\nCaptureInfo *fc = NULL;\r\nFrameInfo *fi = NULL;\r\nINIT_FILEHANDLER_ROUTINE(seek_read,FALSE);\r\nif (err) {\r\n*err = errno = 0;\r\n}\r\nphdr->opt_comment = NULL;\r\nfp = push_File(L, wth->random_fh);\r\nfc = push_CaptureInfo(L, wth, FALSE);\r\nfi = push_FrameInfo(L, phdr, buf);\r\nlua_pushnumber(L, (lua_Number)seek_off);\r\nswitch ( lua_pcall(L,4,1,1) ) {\r\ncase 0:\r\nif (lua_isstring(L,-1)) {\r\nsize_t len = 0;\r\nconst gchar* fd = lua_tolstring(L, -1, &len);\r\nif (len < WTAP_MAX_PACKET_SIZE)\r\nmemcpy(ws_buffer_start_ptr(buf), fd, len);\r\nretval = 1;\r\nbreak;\r\n}\r\nretval = wslua_optboolint(L,-1,0);\r\nbreak;\r\nCASE_ERROR_ERRINFO("seek_read")\r\n}\r\nEND_FILEHANDLER_ROUTINE();\r\n(*fp)->expired = TRUE;\r\n(*fc)->expired = TRUE;\r\n(*fi)->expired = TRUE;\r\nlua_settop(L,0);\r\nreturn (retval == 1);\r\n}\r\nstatic void\r\nwslua_filehandler_close(wtap *wth)\r\n{\r\nFileHandler fh = (FileHandler)(wth->wslua_data);\r\nlua_State* L = NULL;\r\nFile *fp = NULL;\r\nCaptureInfo *fc = NULL;\r\nINIT_FILEHANDLER_ROUTINE(read_close,);\r\nfp = push_File(L, wth->fh);\r\nfc = push_CaptureInfo(L, wth, FALSE);\r\nswitch ( lua_pcall(L,2,1,1) ) {\r\ncase 0:\r\nbreak;\r\nCASE_ERROR("read_close")\r\n}\r\nEND_FILEHANDLER_ROUTINE();\r\nremove_wth_priv(L, wth);\r\n(*fp)->expired = TRUE;\r\n(*fc)->expired = TRUE;\r\nlua_settop(L,0);\r\nreturn;\r\n}\r\nstatic void\r\nwslua_filehandler_sequential_close(wtap *wth)\r\n{\r\nFileHandler fh = (FileHandler)(wth->wslua_data);\r\nlua_State* L = NULL;\r\nFile *fp = NULL;\r\nCaptureInfo *fc = NULL;\r\nINIT_FILEHANDLER_ROUTINE(seq_read_close,);\r\nfp = push_File(L, wth->fh);\r\nfc = push_CaptureInfo(L, wth, FALSE);\r\nswitch ( lua_pcall(L,2,1,1) ) {\r\ncase 0:\r\nbreak;\r\nCASE_ERROR("seq_read_close")\r\n}\r\nEND_FILEHANDLER_ROUTINE();\r\n(*fp)->expired = TRUE;\r\n(*fc)->expired = TRUE;\r\nlua_settop(L,0);\r\nreturn;\r\n}\r\nstatic int\r\nwslua_dummy_can_write_encap(int encap _U_)\r\n{\r\nreturn WTAP_ERR_CHECK_WSLUA;\r\n}\r\nstatic int\r\nwslua_filehandler_can_write_encap(int encap, void* data)\r\n{\r\nFileHandler fh = (FileHandler)(data);\r\nint retval = WTAP_ERR_UNWRITABLE_ENCAP;\r\nlua_State* L = NULL;\r\nINIT_FILEHANDLER_ROUTINE(can_write_encap,WTAP_ERR_INTERNAL);\r\nlua_pushnumber(L, encap);\r\nswitch ( lua_pcall(L,1,1,1) ) {\r\ncase 0:\r\nretval = wslua_optboolint(L,-1,WTAP_ERR_UNWRITABLE_ENCAP);\r\nbreak;\r\nCASE_ERROR("can_write_encap")\r\n}\r\nEND_FILEHANDLER_ROUTINE();\r\nif (retval == 1) {\r\nretval = 0;\r\n} else if (retval == 0) {\r\nretval = WTAP_ERR_UNWRITABLE_ENCAP;\r\n}\r\nreturn retval;\r\n}\r\nstatic int\r\nwslua_filehandler_dump_open(wtap_dumper *wdh, int *err)\r\n{\r\nFileHandler fh = (FileHandler)(wdh->wslua_data);\r\nint retval = 0;\r\nlua_State* L = NULL;\r\nFile *fp = NULL;\r\nCaptureInfoConst *fc = NULL;\r\nINIT_FILEHANDLER_ROUTINE(write_open,0);\r\ncreate_wdh_priv(L, wdh);\r\nfp = push_Wdh(L, wdh);\r\nfc = push_CaptureInfoConst(L,wdh);\r\nif (err) {\r\n*err = 0;\r\n}\r\nswitch ( lua_pcall(L,2,1,1) ) {\r\ncase 0:\r\nretval = wslua_optboolint(L,-1,0);\r\nbreak;\r\nCASE_ERROR("write_open")\r\n}\r\nEND_FILEHANDLER_ROUTINE();\r\n(*fp)->expired = TRUE;\r\n(*fc)->expired = TRUE;\r\nif (retval == 1) {\r\nif (fh->write_ref != LUA_NOREF) {\r\nwdh->subtype_write = wslua_filehandler_dump;\r\n}\r\nelse {\r\ng_warning("FileHandler was not set with a write function, even though write_open() returned true");\r\nreturn 0;\r\n}\r\nif (fh->write_close_ref != LUA_NOREF)\r\nwdh->subtype_finish = wslua_filehandler_dump_finish;\r\nelse\r\nwdh->subtype_finish = NULL;\r\n}\r\nelse {\r\nremove_wdh_priv(L, wdh);\r\n}\r\nreturn retval;\r\n}\r\nstatic gboolean\r\nwslua_filehandler_dump(wtap_dumper *wdh, const struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info _U_)\r\n{\r\nFileHandler fh = (FileHandler)(wdh->wslua_data);\r\nint retval = -1;\r\nlua_State* L = NULL;\r\nFile *fp = NULL;\r\nCaptureInfoConst *fc = NULL;\r\nFrameInfoConst *fi = NULL;\r\nINIT_FILEHANDLER_ROUTINE(write,FALSE);\r\nif (err) {\r\n*err = errno = 0;\r\n}\r\nfp = push_Wdh(L, wdh);\r\nfc = push_CaptureInfoConst(L,wdh);\r\nfi = push_FrameInfoConst(L, phdr, pd);\r\nerrno = WTAP_ERR_CANT_WRITE;\r\nswitch ( lua_pcall(L,3,1,1) ) {\r\ncase 0:\r\nretval = wslua_optboolint(L,-1,0);\r\nbreak;\r\nCASE_ERROR("write")\r\n}\r\nEND_FILEHANDLER_ROUTINE();\r\n(*fp)->expired = TRUE;\r\n(*fc)->expired = TRUE;\r\n(*fi)->expired = TRUE;\r\nreturn (retval == 1);\r\n}\r\nstatic gboolean\r\nwslua_filehandler_dump_finish(wtap_dumper *wdh, int *err)\r\n{\r\nFileHandler fh = (FileHandler)(wdh->wslua_data);\r\nint retval = -1;\r\nlua_State* L = NULL;\r\nFile *fp = NULL;\r\nCaptureInfoConst *fc = NULL;\r\nINIT_FILEHANDLER_ROUTINE(write_close,FALSE);\r\nif (err) {\r\n*err = errno = 0;\r\n}\r\nfp = push_Wdh(L, wdh);\r\nfc = push_CaptureInfoConst(L,wdh);\r\nerrno = WTAP_ERR_CANT_CLOSE;\r\nswitch ( lua_pcall(L,2,1,1) ) {\r\ncase 0:\r\nretval = wslua_optboolint(L,-1,0);\r\nbreak;\r\nCASE_ERROR("write_close")\r\n}\r\nEND_FILEHANDLER_ROUTINE();\r\nremove_wdh_priv(L, wdh);\r\n(*fp)->expired = TRUE;\r\n(*fc)->expired = TRUE;\r\nreturn (retval == 1);\r\n}\r\nWSLUA_CONSTRUCTOR FileHandler_new(lua_State* L) {\r\n#define WSLUA_ARG_FileHandler_new_NAME 1\r\n#define WSLUA_ARG_FileHandler_new_SHORTNAME 2\r\n#define WSLUA_ARG_FileHandler_new_DESCRIPTION 3\r\n#define WSLUA_ARG_FileHandler_new_TYPE 4\r\nconst gchar* name = luaL_checkstring(L,WSLUA_ARG_FileHandler_new_NAME);\r\nconst gchar* short_name = luaL_checkstring(L,WSLUA_ARG_FileHandler_new_SHORTNAME);\r\nconst gchar* desc = luaL_checkstring(L,WSLUA_ARG_FileHandler_new_DESCRIPTION);\r\nconst gchar* type = luaL_checkstring(L,WSLUA_ARG_FileHandler_new_TYPE);\r\nFileHandler fh = (FileHandler) g_malloc0(sizeof(struct _wslua_filehandler));\r\nfh->is_reader = (strchr(type,'r') != NULL) ? TRUE : FALSE;\r\nfh->is_writer = (strchr(type,'w') != NULL) ? TRUE : FALSE;\r\nif (fh->is_reader && wtap_has_open_info(short_name)) {\r\nreturn luaL_error(L, "FileHandler.new: '%s' short name already exists for a reader!", short_name);\r\n}\r\nif (fh->is_writer && wtap_short_string_to_file_type_subtype(short_name) > -1) {\r\nreturn luaL_error(L, "FileHandler.new: '%s' short name already exists for a writer!", short_name);\r\n}\r\nfh->type = g_strdup(type);\r\nfh->finfo.name = g_strdup(name);\r\nfh->finfo.short_name = g_strdup(short_name);\r\nfh->finfo.default_file_extension = NULL;\r\nfh->finfo.additional_file_extensions = NULL;\r\nfh->finfo.writing_must_seek = FALSE;\r\nfh->finfo.has_name_resolution = FALSE;\r\nfh->finfo.can_write_encap = NULL;\r\nfh->finfo.dump_open = NULL;\r\nfh->file_type = WTAP_FILE_TYPE_SUBTYPE_UNKNOWN;\r\nfh->description = g_strdup(desc);\r\nfh->L = L;\r\nfh->read_open_ref = LUA_NOREF;\r\nfh->read_ref = LUA_NOREF;\r\nfh->seek_read_ref = LUA_NOREF;\r\nfh->read_close_ref = LUA_NOREF;\r\nfh->seq_read_close_ref = LUA_NOREF;\r\nfh->write_open_ref = LUA_NOREF;\r\nfh->write_ref = LUA_NOREF;\r\nfh->write_close_ref = LUA_NOREF;\r\nfh->can_write_encap_ref = LUA_NOREF;\r\nfh->registered = FALSE;\r\npushFileHandler(L,fh);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METAMETHOD FileHandler__tostring(lua_State* L) {\r\nFileHandler fh = toFileHandler(L,1);\r\nif (!fh) {\r\nlua_pushstring(L,"FileHandler pointer is NULL!");\r\n} else {\r\nlua_pushfstring(L, "FileHandler(%s): short-name='%s', description='%s', read_open=%d, read=%d, write=%d",\r\nfh->finfo.name, fh->finfo.short_name, fh->description, fh->read_open_ref, fh->read_ref, fh->write_ref);\r\n}\r\nWSLUA_RETURN(1);\r\n}\r\nstatic int FileHandler__gc(lua_State* L _U_) {\r\nreturn 0;\r\n}\r\nstatic gboolean verify_filehandler_complete(FileHandler fh) {\r\nreturn ((fh->is_reader || fh->is_writer) &&\r\n(!fh->is_reader ||\r\n(fh->is_reader &&\r\nfh->read_open_ref != LUA_NOREF &&\r\nfh->read_ref != LUA_NOREF &&\r\nfh->seek_read_ref != LUA_NOREF)) &&\r\n(!fh->is_writer ||\r\n(fh->is_writer &&\r\nfh->can_write_encap_ref != LUA_NOREF &&\r\nfh->write_open_ref != LUA_NOREF &&\r\nfh->write_ref != LUA_NOREF)) );\r\n}\r\nWSLUA_FUNCTION wslua_register_filehandler(lua_State* L) {\r\n#define WSLUA_ARG_register_filehandler_FILEHANDLER 1\r\nFileHandler fh = checkFileHandler(L,WSLUA_ARG_register_filehandler_FILEHANDLER);\r\nif (in_routine)\r\nreturn luaL_error(L,"a FileHAndler cannot be registered during reading/writing callback functions");\r\nif (fh->registered)\r\nreturn luaL_error(L,"this FileHandler is already registered");\r\nif (!verify_filehandler_complete(fh))\r\nreturn luaL_error(L,"this FileHandler is not complete enough to register");\r\nif (fh->is_writer) {\r\nfh->finfo.can_write_encap = wslua_dummy_can_write_encap;\r\nfh->finfo.wslua_info = (wtap_wslua_file_info_t*) g_malloc0(sizeof(wtap_wslua_file_info_t));\r\nfh->finfo.wslua_info->wslua_can_write_encap = wslua_filehandler_can_write_encap;\r\nfh->finfo.wslua_info->wslua_data = (void*)(fh);\r\nfh->finfo.dump_open = wslua_filehandler_dump_open;\r\n}\r\nfh->file_type = wtap_register_file_type_subtypes(&(fh->finfo),fh->file_type);\r\nif (fh->is_reader) {\r\nstruct open_info oi = { NULL, OPEN_INFO_HEURISTIC, NULL, NULL, NULL, NULL };\r\noi.name = fh->finfo.short_name;\r\noi.open_routine = wslua_filehandler_open;\r\noi.extensions = fh->finfo.additional_file_extensions;\r\noi.wslua_data = (void*)(fh);\r\nif (strchr(fh->type,'m') != NULL) {\r\noi.type = OPEN_INFO_MAGIC;\r\n} else {\r\noi.type = OPEN_INFO_HEURISTIC;\r\n}\r\nwtap_register_open_info(&oi, (strchr(fh->type,'s') != NULL));\r\n}\r\nfh->registered = TRUE;\r\nlua_pushnumber(L, fh->file_type);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_FUNCTION wslua_deregister_filehandler(lua_State* L) {\r\n#define WSLUA_ARG_register_filehandler_FILEHANDLER 1\r\nFileHandler fh = checkFileHandler(L,WSLUA_ARG_register_filehandler_FILEHANDLER);\r\nif (in_routine)\r\nreturn luaL_error(L,"A FileHAndler cannot be de-registered during reading/writing callback functions");\r\nif (!fh->registered)\r\nreturn 0;\r\nfh->finfo.can_write_encap = NULL;\r\nif (fh->finfo.wslua_info) {\r\nfh->finfo.wslua_info->wslua_can_write_encap = NULL;\r\nfh->finfo.wslua_info->wslua_data = NULL;\r\ng_free(fh->finfo.wslua_info);\r\nfh->finfo.wslua_info = NULL;\r\n}\r\nfh->finfo.dump_open = NULL;\r\nif (fh->file_type != WTAP_FILE_TYPE_SUBTYPE_UNKNOWN)\r\nwtap_deregister_file_type_subtype(fh->file_type);\r\nif (fh->is_reader && wtap_has_open_info(fh->finfo.short_name)) {\r\nwtap_deregister_open_info(fh->finfo.short_name);\r\n}\r\nfh->registered = FALSE;\r\nreturn 0;\r\n}\r\nint FileHandler_register(lua_State* L) {\r\nWSLUA_REGISTER_CLASS(FileHandler);\r\nWSLUA_REGISTER_ATTRIBUTES(FileHandler);\r\nreturn 0;\r\n}\r\nint wslua_deregister_filehandlers(lua_State* L _U_) {\r\nreturn 0;\r\n}
