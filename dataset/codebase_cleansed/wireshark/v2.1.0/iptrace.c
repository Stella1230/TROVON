wtap_open_return_val iptrace_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nchar name[NAME_SIZE+1];\r\nif (!wtap_read_bytes(wth->fh, name, NAME_SIZE, err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nname[NAME_SIZE] = '\0';\r\nif (strcmp(name, "iptrace 1.0") == 0) {\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_IPTRACE_1_0;\r\nwth->subtype_read = iptrace_read_1_0;\r\nwth->subtype_seek_read = iptrace_seek_read_1_0;\r\nwth->file_tsprec = WTAP_TSPREC_SEC;\r\n}\r\nelse if (strcmp(name, "iptrace 2.0") == 0) {\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_IPTRACE_2_0;\r\nwth->subtype_read = iptrace_read_2_0;\r\nwth->subtype_seek_read = iptrace_seek_read_2_0;\r\nwth->file_tsprec = WTAP_TSPREC_NSEC;\r\n}\r\nelse {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean\r\niptrace_read_rec_1_0(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\r\nint *err, gchar **err_info)\r\n{\r\nguint8 header[IPTRACE_1_0_PHDR_SIZE];\r\niptrace_1_0_phdr pkt_hdr;\r\nguint32 packet_size;\r\nif (!wtap_read_bytes_or_eof(fh, header, sizeof header, err, err_info)) {\r\nreturn FALSE;\r\n}\r\npkt_hdr.if_type = header[28];\r\nphdr->pkt_encap = wtap_encap_ift(pkt_hdr.if_type);\r\nif (phdr->pkt_encap == WTAP_ENCAP_UNKNOWN) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("iptrace: interface type IFT=0x%02x unknown or unsupported",\r\npkt_hdr.if_type);\r\nreturn FALSE;\r\n}\r\npacket_size = pntoh32(&header[0]);\r\nif (packet_size < IPTRACE_1_0_PDATA_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("iptrace: file has a %u-byte record, too small to have even a packet meta-data header",\r\npacket_size);\r\nreturn FALSE;\r\n}\r\npacket_size -= IPTRACE_1_0_PDATA_SIZE;\r\nif (phdr->pkt_encap == WTAP_ENCAP_FDDI_BITSWAPPED) {\r\nif (packet_size < 3) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("iptrace: file has a %u-byte record, too small to have even a packet meta-data header",\r\npacket_size + IPTRACE_1_0_PDATA_SIZE);\r\nreturn FALSE;\r\n}\r\npacket_size -= 3;\r\nif (!file_skip(fh, 3, err))\r\nreturn FALSE;\r\n}\r\nif (packet_size > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("iptrace: File has %u-byte packet, bigger than maximum of %u",\r\npacket_size, WTAP_MAX_PACKET_SIZE);\r\nreturn FALSE;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS;\r\nphdr->len = packet_size;\r\nphdr->caplen = packet_size;\r\nphdr->ts.secs = pntoh32(&header[4]);\r\nphdr->ts.nsecs = 0;\r\nfill_in_pseudo_header(phdr->pkt_encap, &phdr->pseudo_header, header);\r\nreturn iptrace_read_rec_data(fh, buf, phdr, err, err_info);\r\n}\r\nstatic gboolean iptrace_read_1_0(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\n*data_offset = file_tell(wth->fh);\r\nif (!iptrace_read_rec_1_0(wth->fh, &wth->phdr, wth->frame_buffer,\r\nerr, err_info)) {\r\nreturn FALSE;\r\n}\r\nif (wth->file_encap == WTAP_ENCAP_UNKNOWN)\r\nwth->file_encap = wth->phdr.pkt_encap;\r\nelse {\r\nif (wth->file_encap != wth->phdr.pkt_encap)\r\nwth->file_encap = WTAP_ENCAP_PER_PACKET;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean iptrace_seek_read_1_0(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (!iptrace_read_rec_1_0(wth->random_fh, phdr, buf, err, err_info)) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\niptrace_read_rec_2_0(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\r\nint *err, gchar **err_info)\r\n{\r\nguint8 header[IPTRACE_2_0_PHDR_SIZE];\r\niptrace_2_0_phdr pkt_hdr;\r\nguint32 packet_size;\r\nif (!wtap_read_bytes_or_eof(fh, header, sizeof header, err, err_info)) {\r\nreturn FALSE;\r\n}\r\npkt_hdr.if_type = header[28];\r\nphdr->pkt_encap = wtap_encap_ift(pkt_hdr.if_type);\r\n#if 0\r\nif (phdr->pkt_encap == WTAP_ENCAP_UNKNOWN) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("iptrace: interface type IFT=0x%02x unknown or unsupported",\r\npkt_hdr.if_type);\r\nreturn FALSE;\r\n}\r\n#endif\r\npacket_size = pntoh32(&header[0]);\r\nif (packet_size < IPTRACE_2_0_PDATA_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("iptrace: file has a %u-byte record, too small to have even a packet meta-data header",\r\npacket_size);\r\nreturn FALSE;\r\n}\r\npacket_size -= IPTRACE_2_0_PDATA_SIZE;\r\nif (phdr->pkt_encap == WTAP_ENCAP_FDDI_BITSWAPPED) {\r\nif (packet_size < 3) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("iptrace: file has a %u-byte record, too small to have even a packet meta-data header",\r\npacket_size + IPTRACE_2_0_PDATA_SIZE);\r\nreturn FALSE;\r\n}\r\npacket_size -= 3;\r\nif (!file_skip(fh, 3, err))\r\nreturn FALSE;\r\n}\r\nif (packet_size > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("iptrace: File has %u-byte packet, bigger than maximum of %u",\r\npacket_size, WTAP_MAX_PACKET_SIZE);\r\nreturn FALSE;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS;\r\nphdr->len = packet_size;\r\nphdr->caplen = packet_size;\r\nphdr->ts.secs = pntoh32(&header[32]);\r\nphdr->ts.nsecs = pntoh32(&header[36]);\r\nfill_in_pseudo_header(phdr->pkt_encap, &phdr->pseudo_header, header);\r\nreturn iptrace_read_rec_data(fh, buf, phdr, err, err_info);\r\n}\r\nstatic gboolean iptrace_read_2_0(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\n*data_offset = file_tell(wth->fh);\r\nif (!iptrace_read_rec_2_0(wth->fh, &wth->phdr, wth->frame_buffer,\r\nerr, err_info)) {\r\nreturn FALSE;\r\n}\r\nif (wth->file_encap == WTAP_ENCAP_UNKNOWN)\r\nwth->file_encap = wth->phdr.pkt_encap;\r\nelse {\r\nif (wth->file_encap != wth->phdr.pkt_encap)\r\nwth->file_encap = WTAP_ENCAP_PER_PACKET;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean iptrace_seek_read_2_0(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (!iptrace_read_rec_2_0(wth->random_fh, phdr, buf, err, err_info)) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\niptrace_read_rec_data(FILE_T fh, Buffer *buf, struct wtap_pkthdr *phdr,\r\nint *err, gchar **err_info)\r\n{\r\nif (!wtap_read_packet_bytes(fh, buf, phdr->caplen, err, err_info))\r\nreturn FALSE;\r\nif (phdr->pkt_encap == WTAP_ENCAP_ATM_PDUS) {\r\natm_guess_traffic_type(phdr, ws_buffer_start_ptr(buf));\r\n}\r\nreturn TRUE;\r\n}\r\nstatic void\r\nfill_in_pseudo_header(int encap, union wtap_pseudo_header *pseudo_header,\r\nguint8 *header)\r\n{\r\nchar if_text[9];\r\nchar *decimal;\r\nint Vpi = 0;\r\nint Vci = 0;\r\nswitch (encap) {\r\ncase WTAP_ENCAP_ATM_PDUS:\r\nmemcpy(if_text, &header[20], 8);\r\nif_text[8] = '\0';\r\ndecimal = strchr(if_text, '.');\r\nif (decimal) {\r\n*decimal = '\0';\r\nVpi = (int)strtoul(if_text, NULL, 10);\r\ndecimal++;\r\nVci = (int)strtoul(decimal, NULL, 10);\r\n}\r\npseudo_header->atm.channel = header[29];\r\npseudo_header->atm.vpi = Vpi;\r\npseudo_header->atm.vci = Vci;\r\npseudo_header->atm.flags = 0;\r\npseudo_header->atm.cells = 0;\r\npseudo_header->atm.aal5t_u2u = 0;\r\npseudo_header->atm.aal5t_len = 0;\r\npseudo_header->atm.aal5t_chksum = 0;\r\nbreak;\r\ncase WTAP_ENCAP_ETHERNET:\r\npseudo_header->eth.fcs_len = 0;\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nwtap_encap_ift(unsigned int ift)\r\n{\r\nstatic const int ift_encap[] = {\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_RAW_IP,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_ETHERNET,\r\nWTAP_ENCAP_ETHERNET,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_TOKEN_RING,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_RAW_IP,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_FDDI_BITSWAPPED,\r\nWTAP_ENCAP_LAPB,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_RAW_IP,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_ATM_PDUS,\r\n};\r\n#define NUM_IFT_ENCAPS (sizeof ift_encap / sizeof ift_encap[0])\r\nif (ift < NUM_IFT_ENCAPS) {\r\nreturn ift_encap[ift];\r\n}\r\nelse {\r\nswitch(ift) {\r\ncase IPTRACE_IFT_IB:\r\nreturn WTAP_ENCAP_INFINIBAND;\r\nbreak;\r\ncase IPTRACE_IFT_HF:\r\nreturn WTAP_ENCAP_RAW_IP;\r\nbreak;\r\ndefault:\r\nreturn WTAP_ENCAP_UNKNOWN;\r\n}\r\n}\r\n}
