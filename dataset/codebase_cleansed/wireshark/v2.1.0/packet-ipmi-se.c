static gboolean\r\neti_thr_2(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs _U_, guint32 d)\r\n{\r\nproto_item* ti;\r\nif (b == 0x1) {\r\nti = proto_tree_add_item(tree, hf_ipmi_se_evt_trigger_reading, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nif (d == 0xff)\r\nproto_item_append_text(ti, " (unspecified)");\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\neti_thr_3(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs _U_, guint32 d)\r\n{\r\nproto_item* ti;\r\nif (b == 0x1) {\r\nti = proto_tree_add_item(tree, hf_ipmi_se_evt_trigger_threshold, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nif (d == 0xff)\r\nproto_item_append_text(ti, " (unspecified)");\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\neti_2_pst_sev(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si,\r\nguint32 b, guint32 offs _U_, guint32 d)\r\n{\r\nproto_tree *s_tree;\r\nguint32 tmp;\r\nconst char *desc;\r\nif (b == 0x1) {\r\ns_tree = proto_tree_add_subtree(tree, tvb, 0, 1, ett_ipmi_se_evt_evd_byte2, NULL, "Previous state/severity");\r\nproto_tree_add_item(s_tree, hf_ipmi_se_pst_severity, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\ntmp = d & 0xf;\r\ndesc = (tmp == 0x0f) ? "Unspecified" : val_to_str_const(tmp, si->offsets, "Unknown");\r\nproto_tree_add_uint_format_value(s_tree, hf_ipmi_se_pst_previous_state, tvb, 0, 1,\r\ntmp, "%s (0x%02x)", desc, tmp);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic const struct evtype_info *\r\nget_evtype_info(unsigned int evtype)\r\n{\r\nstatic const struct {\r\nunsigned int id;\r\nstruct evtype_info eti;\r\n} eti_tab[] = {\r\n{ 0x01, { etb2_thr, etb3_thr, etoff_01, eti_thr_2, eti_thr_3}},\r\n{ 0x02, { etb2_dscr, etb3_dscr, etoff_02, eti_2_pst_sev, NULL}},\r\n{ 0x03, { etb2_dscr, etb3_dscr, etoff_03, eti_2_pst_sev, NULL}},\r\n{ 0x04, { etb2_dscr, etb3_dscr, etoff_04, eti_2_pst_sev, NULL}},\r\n{ 0x05, { etb2_dscr, etb3_dscr, etoff_05, eti_2_pst_sev, NULL}},\r\n{ 0x06, { etb2_dscr, etb3_dscr, etoff_06, eti_2_pst_sev, NULL}},\r\n{ 0x07, { etb2_dscr, etb3_dscr, etoff_07, eti_2_pst_sev, NULL}},\r\n{ 0x08, { etb2_dscr, etb3_dscr, etoff_08, eti_2_pst_sev, NULL}},\r\n{ 0x09, { etb2_dscr, etb3_dscr, etoff_09, eti_2_pst_sev, NULL}},\r\n{ 0x0a, { etb2_dscr, etb3_dscr, etoff_0a, eti_2_pst_sev, NULL}},\r\n{ 0x0b, { etb2_dscr, etb3_dscr, etoff_0b, eti_2_pst_sev, NULL}},\r\n{ 0x0c, { etb2_dscr, etb3_dscr, etoff_0c, eti_2_pst_sev, NULL}},\r\n{ 0x6f, { etb2_dscr, etb3_dscr, NULL, eti_2_pst_sev, NULL}}\r\n};\r\nstatic const struct evtype_info eti_oem = {\r\netb2_oem, etb3_oem, et_empty, eti_2_pst_sev, NULL\r\n};\r\nstatic const struct evtype_info eti_rsrv = {\r\net_empty, et_empty, et_empty, NULL, NULL\r\n};\r\nunsigned int i;\r\nfor (i = 0; i < array_length(eti_tab); i++) {\r\nif (eti_tab[i].id == evtype) {\r\nreturn &eti_tab[i].eti;\r\n}\r\n}\r\nif (evtype >= 0x70 && evtype <= 0x7f) {\r\nreturn &eti_oem;\r\n}\r\nreturn &eti_rsrv;\r\n}\r\nstatic gboolean\r\nssi_05_2(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs, guint32 d _U_)\r\n{\r\nif (b == 0x3 && offs == 0x04) {\r\nproto_tree_add_item(tree, hf_ipmi_se_05_network_controller, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_08_3(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs, guint32 d _U_)\r\n{\r\nif (b == 0x3 && offs == 0x06) {\r\nproto_tree_add_item(tree, hf_ipmi_se_08_error_type, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_0c_3(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs _U_, guint32 d _U_)\r\n{\r\nif (b == 0x3) {\r\nproto_tree_add_item(tree, hf_ipmi_se_0c_memory_module, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_0f_2(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs, guint32 d _U_)\r\n{\r\nif (b == 0x3 && offs == 0x00) {\r\nproto_tree_add_item(tree, hf_ipmi_se_0f_extension_code_err, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nif (b == 0x3 && (offs == 0x01 || offs == 0x02)) {\r\nproto_tree_add_item(tree, hf_ipmi_se_0f_extension_code_progress, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_10_2(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs, guint32 d)\r\n{\r\nif (b == 0x3 && offs == 0x00) {\r\nproto_tree_add_item(tree, hf_ipmi_se_10_memory_module, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nif (b == 0x3 && offs == 0x01) {\r\nssi_10_saveptr = get_evtype_info(d);\r\nproto_tree_add_item(tree, hf_ipmi_se_10_evtype, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_10_3(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs, guint32 d)\r\n{\r\nproto_tree *s_tree;\r\nconst value_string *off_vals;\r\nif (b == 0x3 && offs == 0x01) {\r\nif (!ssi_10_saveptr) {\r\nreturn FALSE;\r\n}\r\noff_vals = ssi_10_saveptr->offsets ? ssi_10_saveptr->offsets : et_empty;\r\ns_tree = proto_tree_add_subtree(tree, tvb, 0, 1, ett_ipmi_se_evt_evd_byte3, NULL, "Logging details/Offset");\r\nproto_tree_add_item(s_tree, hf_ipmi_se_10_logging_disable, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_10_event, tvb, 0, 1, ENC_NA);\r\nd &= 0x0f;\r\nproto_tree_add_uint_format_value(s_tree, hf_ipmi_se_10_event_offset, tvb, 0, 1,\r\nd, "%s (0x%02x)", val_to_str_const(d, off_vals, "Unknown"), d);\r\nreturn TRUE;\r\n}\r\nif (b == 0x3 && offs == 0x05) {\r\nproto_tree_add_item(tree, hf_ipmi_se_10_sel_filled, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_12_2(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs, guint32 d _U_)\r\n{\r\nproto_tree *s_tree;\r\nif (b == 0x3 && offs == 0x03) {\r\ns_tree = proto_tree_add_subtree(tree, tvb, 0, 1, ett_ipmi_se_evt_evd_byte2, NULL, "Log action/type");\r\nproto_tree_add_item(s_tree, hf_ipmi_se_12_log_entry_action, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_12_log_type, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nif (b == 0x3 && offs == 0x04) {\r\ns_tree = proto_tree_add_subtree(tree, tvb, 0, 1, ett_ipmi_se_evt_evd_byte2, NULL, "PEF Actions to be taken");\r\nproto_tree_add_item(s_tree, hf_ipmi_se_12_diagnostic_interrupt, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_12_oem_action, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_12_power_cycle, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_12_reset, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_12_power_off, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_12_alert, tvb, 0, 1, ENC_NA);\r\nreturn TRUE;\r\n}\r\nif (b == 0x3 && offs == 0x05) {\r\ns_tree = proto_tree_add_subtree(tree, tvb, 0, 1, ett_ipmi_se_evt_evd_byte2, NULL, "Details");\r\nproto_tree_add_item(s_tree, hf_ipmi_se_12_event, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_12_timestamp_clock_type, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_19_2(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs, guint32 d _U_)\r\n{\r\nif (b == 0x3 && offs == 0x00) {\r\nproto_tree_add_item(tree, hf_ipmi_se_19_requested_power_state, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_19_3(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs, guint32 d _U_)\r\n{\r\nif (b == 0x3 && offs == 0x00) {\r\nproto_tree_add_item(tree, hf_ipmi_se_19_power_state, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_1d_2(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs, guint32 d _U_)\r\n{\r\nif (b == 0x3 && offs == 0x07) {\r\nproto_tree_add_item(tree, hf_ipmi_se_1d_restart_cause, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_1d_3(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs, guint32 d _U_)\r\n{\r\ngchar s[ITEM_LABEL_LENGTH];\r\nipmi_fmt_channel(s, d);\r\nif (b == 0x3 && offs == 0x07) {\r\nproto_tree_add_item(tree, hf_ipmi_se_1d_channel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_21_2(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs _U_, guint32 d _U_)\r\n{\r\nif (b == 0x3) {\r\nproto_tree_add_item(tree, hf_ipmi_se_21_slot_connector_type, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_21_3(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs _U_, guint32 d _U_)\r\n{\r\nif (b == 0x3) {\r\nproto_tree_add_item(tree, hf_ipmi_se_21_slot_connector, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_23_2(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs _U_, guint32 d _U_)\r\n{\r\nproto_tree *s_tree;\r\nif (b == 0x3) {\r\ns_tree = proto_tree_add_subtree(tree, tvb, 0, 1, ett_ipmi_se_evt_evd_byte2, NULL, "Timer use/interrupt");\r\nproto_tree_add_item(s_tree, hf_ipmi_se_23_interrupt_type, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_23_timer_use_at_expiration, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_28_2(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs _U_, guint32 d)\r\n{\r\nproto_tree *s_tree;\r\nif (b == 0x3 && (offs == 0x00 || offs == 0x04)) {\r\nproto_tree_add_item(tree, hf_ipmi_se_28_sensor_number, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nif (b == 0x3 && offs == 0x05) {\r\ns_tree = proto_tree_add_subtree(tree, tvb, 0, 1, ett_ipmi_se_evt_evd_byte2, NULL, "FRU details");\r\nssi28_is_logical_fru = (d & 0x80) ? 1 : 0;\r\nproto_tree_add_item(s_tree, hf_ipmi_se_28_logical_fru_device, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_28_lun_for_master_read_write_command, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_28_private_bus_id, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_28_3(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs _U_, guint32 d _U_)\r\n{\r\nif (b == 0x3 && offs == 0x05) {\r\nif (ssi28_is_logical_fru == -1) {\r\nreturn FALSE;\r\n}\r\nif (ssi28_is_logical_fru) {\r\nproto_tree_add_item(tree, hf_ipmi_se_28_fru_device_id_within_controller, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n} else {\r\nproto_tree_add_item(tree, hf_ipmi_se_28_i2c_slave_address, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_2a_2(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs _U_, guint32 d)\r\n{\r\nproto_item *ti;\r\nif (b == 0x3) {\r\nti = proto_tree_add_item(tree, hf_ipmi_se_2a_user_id, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nif ((d & 0x3f) == 0)\r\nproto_item_append_text(ti, " (unspecified)");\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_2a_3(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs _U_, guint32 d _U_)\r\n{\r\nproto_tree *s_tree;\r\nif (b == 0x3) {\r\ns_tree = proto_tree_add_subtree(tree, tvb, 0, 1, ett_ipmi_se_evt_evd_byte3, NULL, "Deactivation cause/Channel #");\r\nproto_tree_add_item(s_tree, hf_ipmi_se_2a_session_deactivated_by, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_2a_channel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_2b_2(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs _U_, guint32 d _U_)\r\n{\r\nif (b == 0x3) {\r\nproto_tree_add_item(tree, hf_ipmi_se_2b_version_change_type, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_2c_2(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si,\r\nguint32 b, guint32 offs _U_, guint32 d)\r\n{\r\nproto_tree *s_tree;\r\nif (b == 0x3) {\r\ns_tree = proto_tree_add_subtree(tree, tvb, 0, 1, ett_ipmi_se_evt_evd_byte2, NULL, "Previous state/Cause");\r\nproto_tree_add_item(s_tree, hf_ipmi_se_2c_cause, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nd &= 0xf;\r\nproto_tree_add_uint_format_value(s_tree, hf_ipmi_se_2c_previous_state, tvb, 0, 1,\r\nd, "%s (0x%02x)", val_to_str_const(d, si->offsets, "Reserved"), d);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_f0_2(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si,\r\nguint32 b, guint32 offs _U_, guint32 d)\r\n{\r\nproto_tree *s_tree;\r\nif (b == 0x2) {\r\ns_tree = proto_tree_add_subtree(tree, tvb, 0, 1, ett_ipmi_se_evt_evd_byte2, NULL, "Previous state/Cause");\r\nproto_tree_add_item(s_tree, hf_ipmi_se_f0_cause, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nd &= 0xf;\r\nproto_tree_add_uint_format_value(s_tree, hf_ipmi_se_f0_previous_state, tvb, 0, 1,\r\nd, "%s (0x%02x)", val_to_str_const(d, si->offsets, "Reserved"), d);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_f0_3(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs _U_, guint32 d _U_)\r\n{\r\nif (b == 0x2) {\r\nproto_tree_add_item(tree, hf_ipmi_se_f0_fru_id, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_f1_2(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs _U_, guint32 d _U_)\r\n{\r\nif (b == 0x02) {\r\nproto_tree_add_item(tree, hf_ipmi_se_f1_channel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_f1_3(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs _U_, guint32 d _U_)\r\n{\r\nproto_tree *s_tree;\r\nif (b == 0x02) {\r\ns_tree = proto_tree_add_subtree(tree, tvb, 0, 1, ett_ipmi_se_evt_evd_byte3, NULL, "Override state / Local status");\r\nproto_tree_add_item(s_tree, hf_ipmi_se_f1_ipmb_b_override_state, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_f1_ipmb_b_local_status, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_f1_ipmb_a_override_state, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_f1_ipmb_a_local_status, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_f3_2(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs, guint32 d _U_)\r\n{\r\nproto_tree *s_tree;\r\nproto_item *ti;\r\nif (b == 0x02 && offs == 0x00) {\r\nti = proto_tree_add_item(tree, hf_ipmi_se_f3_global_status, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\ns_tree = proto_item_add_subtree(ti, ett_ipmi_se_evt_evd_byte2);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_f3_redundant_pm, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_f3_gs_payload_power, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_f3_gs_management_power, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_f3_role, tvb, 0, 1, ENC_NA);\r\nreturn TRUE;\r\n} else if (b == 0x02 && offs == 0x01) {\r\nti = proto_tree_add_item(tree, hf_ipmi_se_f3_channel_status, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\ns_tree = proto_item_add_subtree(ti, ett_ipmi_se_evt_evd_byte2);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_f3_pwr_on, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_f3_payload_power_overcurrent, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_f3_channel_payload_power, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_f3_enable, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_f3_management_power_overcurrent, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_f3_channel_management_power, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_f3_ps1, tvb, 0, 1, ENC_NA);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nssi_f3_3(proto_tree *tree, tvbuff_t *tvb, const struct sensor_info *si _U_,\r\nguint32 b, guint32 offs, guint32 d _U_)\r\n{\r\nif (b == 0x02 && offs == 0x01) {\r\nproto_tree_add_item(tree, hf_ipmi_se_f3_power_channel_number, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic void\r\nreinit_statics(void)\r\n{\r\nssi_10_saveptr = NULL;\r\nssi28_is_logical_fru = -1;\r\n}\r\nstatic const struct sensor_info *\r\nget_sensor_info(unsigned int stype)\r\n{\r\nstatic const struct {\r\nunsigned int id;\r\nstruct sensor_info si;\r\n} si_tab[] = {\r\n{ 0x01, { NULL, NULL, NULL, "Temperature" }},\r\n{ 0x02, { NULL, NULL, NULL, "Voltage" }},\r\n{ 0x03, { NULL, NULL, NULL, "Current" }},\r\n{ 0x04, { NULL, NULL, NULL, "Fan" }},\r\n{ 0x05, { ssoff_05, ssi_05_2, NULL, "Physical Security (Chassis Intrusion)" }},\r\n{ 0x06, { ssoff_06, NULL, NULL, "Platform Security Violation Attempt" }},\r\n{ 0x07, { ssoff_07, NULL, NULL, "Processor" }},\r\n{ 0x08, { ssoff_08, NULL, ssi_08_3, "Power Supply" }},\r\n{ 0x09, { ssoff_09, NULL, NULL, "Power Unit" }},\r\n{ 0x0a, { NULL, NULL, NULL, "Cooling Device" }},\r\n{ 0x0b, { NULL, NULL, NULL, "Other Units-based Sensor (per units given in SDR)" }},\r\n{ 0x0c, { ssoff_0c, NULL, ssi_0c_3, "Memory" }},\r\n{ 0x0d, { ssoff_0d, NULL, NULL, "Drive Slot (Bay)" }},\r\n{ 0x0e, { NULL, NULL, NULL, "POST Memory Resize" }},\r\n{ 0x0f, { ssoff_0f, ssi_0f_2, NULL, "System Firmware Progress (formerly POST Error)" }},\r\n{ 0x10, { ssoff_10, ssi_10_2, ssi_10_3, "Event Logging Disabled" }},\r\n{ 0x11, { ssoff_11, NULL, NULL, "Watchdog 1" }},\r\n{ 0x12, { ssoff_12, ssi_12_2, NULL, "System Event" }},\r\n{ 0x13, { ssoff_13, NULL, NULL, "Critical Interrupt" }},\r\n{ 0x14, { ssoff_14, NULL, NULL, "Button" }},\r\n{ 0x15, { NULL, NULL, NULL, "Module / Board" }},\r\n{ 0x16, { NULL, NULL, NULL, "Microcontroller / Coprocessor" }},\r\n{ 0x17, { NULL, NULL, NULL, "Add-in Card" }},\r\n{ 0x18, { NULL, NULL, NULL, "Chassis" }},\r\n{ 0x19, { ssoff_19, ssi_19_2, ssi_19_3, "Chip Set" }},\r\n{ 0x1a, { NULL, NULL, NULL, "Other FRU" }},\r\n{ 0x1b, { ssoff_1b, NULL, NULL, "Cable / Interconnect" }},\r\n{ 0x1c, { NULL, NULL, NULL, "Terminator" }},\r\n{ 0x1d, { ssoff_1d, ssi_1d_2, ssi_1d_3, "System Boot / Restart Initiated" }},\r\n{ 0x1e, { ssoff_1e, NULL, NULL, "Boot Error" }},\r\n{ 0x1f, { ssoff_1f, NULL, NULL, "OS Boot" }},\r\n{ 0x20, { ssoff_20, NULL, NULL, "OS Critical Stop" }},\r\n{ 0x21, { ssoff_21, ssi_21_2, ssi_21_3, "Slot / Connector" }},\r\n{ 0x22, { ssoff_22, NULL, NULL, "System ACPI Power State" }},\r\n{ 0x23, { ssoff_23, ssi_23_2, NULL, "Watchdog 2" }},\r\n{ 0x24, { ssoff_24, NULL, NULL, "Platform Alert" }},\r\n{ 0x25, { ssoff_25, NULL, NULL, "Entity Presence" }},\r\n{ 0x26, { NULL, NULL, NULL, "Monitor ASIC / IC" }},\r\n{ 0x27, { ssoff_27, NULL, NULL, "LAN" }},\r\n{ 0x28, { ssoff_28, ssi_28_2, ssi_28_3, "Management Subsystem Health" }},\r\n{ 0x29, { ssoff_29, NULL, NULL, "Battery" }},\r\n{ 0x2a, { ssoff_2a, ssi_2a_2, ssi_2a_3, "Session Audit" }},\r\n{ 0x2b, { ssoff_2b, ssi_2b_2, NULL, "Version Change" }},\r\n{ 0x2c, { ssoff_2c, ssi_2c_2, NULL, "FRU State" }},\r\n{ 0xf0, { ssoff_f0, ssi_f0_2, ssi_f0_3, "Hot Swap (ATCA)" }},\r\n{ 0xf1, { ssoff_f1, ssi_f1_2, ssi_f1_3, "IPMB Physical State (ATCA)" }},\r\n{ 0xf2, { ssoff_f2, NULL, NULL, "Module Hot Swap (AMC.0)" }},\r\n{ 0xf3, { ssoff_f3, ssi_f3_2, ssi_f3_3, "Power Channel Notification" }},\r\n{ 0xf4, { ssoff_f4, NULL, NULL, "Telco Alarm Input" }}\r\n};\r\nstatic const struct sensor_info si_oem = {\r\nNULL, NULL, NULL, "OEM Reserved"\r\n};\r\nstatic const struct sensor_info si_rsrv = {\r\nNULL, NULL, NULL, "Reserved"\r\n};\r\nunsigned int i;\r\nfor (i = 0; i < array_length(si_tab); i++) {\r\nif (si_tab[i].id == stype) {\r\nreturn &si_tab[i].si;\r\n}\r\n}\r\nif (stype >= 0xc0 && stype <= 0xff) {\r\nreturn &si_oem;\r\n}\r\nreturn &si_rsrv;\r\n}\r\nstatic void\r\nparse_platform_event(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_item *ti;\r\nproto_tree *s_tree;\r\ntvbuff_t *next_tvb;\r\nunsigned int stype, evtype;\r\nconst struct sensor_info *si;\r\nconst struct evtype_info *eti;\r\nunsigned int d, b2, b3, offs;\r\nconst value_string *off_vals;\r\nstype = tvb_get_guint8(tvb, 1);\r\nsi = get_sensor_info(stype);\r\nevtype = tvb_get_guint8(tvb, 3) & 0x7f;\r\neti = get_evtype_info(evtype);\r\nproto_tree_add_item(tree, hf_ipmi_se_evt_rev, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_se_evt_sensor_type, tvb, 1, 1, stype,\r\n"%s (0x%02x)", si->desc, stype);\r\nproto_tree_add_item(tree, hf_ipmi_se_evt_sensor_num, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nti = proto_tree_add_item(tree, hf_ipmi_se_evt_byte3, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\ns_tree = proto_item_add_subtree(ti, ett_ipmi_se_evt_byte3);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_evt_dir, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_evt_type, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\noffs = tvb_get_guint8(tvb, 4);\r\nb2 = offs >> 6;\r\nb3 = (offs >> 4) & 0x3;\r\noff_vals = eti->offsets ? eti->offsets : si->offsets ? si->offsets : et_empty;\r\nti = proto_tree_add_item(tree, hf_ipmi_se_evt_data1, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\ns_tree = proto_item_add_subtree(ti, ett_ipmi_se_evt_evd_byte1);\r\nproto_tree_add_uint_format_value(s_tree, hf_ipmi_se_evt_data1_b2, tvb, 4, 1, offs,\r\n"%s (0x%02x)", val_to_str_const(b2, eti->byte2, "Reserved"), b2);\r\nproto_tree_add_uint_format_value(s_tree, hf_ipmi_se_evt_data1_b3, tvb, 4, 1, offs,\r\n"%s (0x%02x)", val_to_str_const(b3, eti->byte3, "Reserved"), b3);\r\noffs &= 0x0f;\r\nproto_tree_add_uint_format_value(s_tree, hf_ipmi_se_evt_data1_offs, tvb, 4, 1, offs,\r\n"%s (0x%02x)", val_to_str_const(offs, off_vals, "Reserved"), offs);\r\nreinit_statics();\r\nif (tvb_captured_length(tvb) <= 5) {\r\nreturn;\r\n}\r\nnext_tvb = tvb_new_subset_length(tvb, 5, 1);\r\nd = tvb_get_guint8(next_tvb, 0);\r\nif ((eti->intrp2 && eti->intrp2(tree, next_tvb, si, b2, offs, d))\r\n|| (si->intrp2 && si->intrp2(tree, next_tvb, si, b2, offs, d))) {\r\nti = proto_tree_add_item(tree, hf_ipmi_se_evt_data2, next_tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(ti);\r\n} else {\r\nproto_tree_add_item(tree, hf_ipmi_se_evt_data2, next_tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nif (tvb_captured_length(tvb) <= 6) {\r\nreturn;\r\n}\r\nnext_tvb = tvb_new_subset_length(tvb, 6, 1);\r\nd = tvb_get_guint8(next_tvb, 0);\r\nif ((eti->intrp3 && eti->intrp3(tree, next_tvb, si, b3, offs, d))\r\n|| (si->intrp3 && si->intrp3(tree, next_tvb, si, b3, offs, d))) {\r\nti = proto_tree_add_item(tree, hf_ipmi_se_evt_data3, next_tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(ti);\r\n} else {\r\nproto_tree_add_item(tree, hf_ipmi_se_evt_data3, next_tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ncfgparam_00(tvbuff_t *tvb, packet_info* pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_cp00_sip, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\ncfgparam_01(tvbuff_t *tvb, packet_info* pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_cp01_alert_startup, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_cp01_startup, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_cp01_event_msg, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_cp01_pef, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\ncfgparam_02(tvbuff_t *tvb, packet_info* pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_cp02_diag_intr, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_cp02_oem_action, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_cp02_pwr_cycle, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_cp02_reset, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_cp02_pwr_down, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_cp02_alert, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\ncfgparam_03(tvbuff_t *tvb, packet_info* pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_cp03_startup, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\ncfgparam_04(tvbuff_t *tvb, packet_info* pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_cp04_alert_startup, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\ncfgparam_05(tvbuff_t *tvb, packet_info* pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_cp05_num_evfilters, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\ncfgparam_06(tvbuff_t *tvb, packet_info* pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_cp06_filter, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_cp06_data, tvb, 1, 20, ENC_NA);\r\n}\r\nstatic void\r\ncfgparam_07(tvbuff_t *tvb, packet_info* pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_cp07_filter, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_cp06_data, tvb, 1, 1, ENC_NA);\r\n}\r\nstatic void\r\ncfgparam_08(tvbuff_t *tvb, packet_info* pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_cp08_policies, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\ncfgparam_09(tvbuff_t *tvb, packet_info* pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_cp09_entry, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_cp09_data, tvb, 1, 3, ENC_NA);\r\n}\r\nstatic void\r\ncfgparam_10(tvbuff_t *tvb, packet_info* pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_cp10_useval, tvb, 0, 1, ENC_NA);\r\nipmi_add_guid(tree, hf_ipmi_se_cp10_guid, tvb, 1);\r\n}\r\nstatic void\r\ncfgparam_11(tvbuff_t *tvb, packet_info* pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_cp11_num_alertstr, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\ncfgparam_12(tvbuff_t *tvb, packet_info* pinfo _U_, proto_tree *tree)\r\n{\r\nproto_item *ti;\r\nproto_tree *s_tree;\r\nguint8 tmp;\r\nti = proto_tree_add_item(tree, hf_ipmi_se_cp12_byte1, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\ns_tree = proto_item_add_subtree(ti, ett_ipmi_se_cp12_byte1);\r\ntmp = tvb_get_guint8(tvb, 0) & 0x7f;\r\nti = proto_tree_add_item(s_tree, hf_ipmi_se_cp12_alert_stringsel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nif (tmp == 0) {\r\nproto_item_append_text(ti, " (Selects volatile string parameters)");\r\n}\r\nproto_tree_add_item(tree, hf_ipmi_se_cp12_evfilter, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_cp12_alert_stringset, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\ncfgparam_13(tvbuff_t *tvb, packet_info* pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_cp13_stringsel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_cp13_blocksel, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_cp13_string, tvb, 2, -1, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\ncfgparam_14(tvbuff_t *tvb, packet_info* pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_cp14_num_gct, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\ncp15_add_group_and_member(proto_tree *tree, tvbuff_t *tvb, guint offs, guint num)\r\n{\r\nstatic const int *byte2[] = { &hf_ipmi_se_cp15_member_check, &hf_ipmi_se_cp15_member_id, NULL };\r\nconst char *gdesc;\r\nguint8 tmp;\r\ntmp = tvb_get_guint8(tvb, offs);\r\nif (tmp == 0x00) {\r\ngdesc = " (unspecified)";\r\n} else if (tmp == 0xff) {\r\ngdesc = " (all groups)";\r\n} else {\r\ngdesc = "";\r\n}\r\nproto_tree_add_uint_format(tree, hf_ipmi_se_cp15_group, tvb, offs, 1, tmp,\r\n"Group ID %d: %d%s", num, tmp, gdesc);\r\nproto_tree_add_bitmask_text(tree, tvb, offs + 1, 1, NULL, NULL, ett_ipmi_se_cp15_member, byte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\ncfgparam_15(tvbuff_t *tvb, packet_info* pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte2[] = { &hf_ipmi_se_cp15_force, &hf_ipmi_se_cp15_delayed, &hf_ipmi_se_cp15_channel, NULL };\r\nstatic const int *byte11[] = { &hf_ipmi_se_cp15_retries, &hf_ipmi_se_cp15_operation, NULL };\r\nproto_tree_add_item(tree, hf_ipmi_se_cp15_gctsel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_se_cp15_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\ncp15_add_group_and_member(tree, tvb, 2, 0);\r\ncp15_add_group_and_member(tree, tvb, 4, 1);\r\ncp15_add_group_and_member(tree, tvb, 6, 2);\r\ncp15_add_group_and_member(tree, tvb, 8, 3);\r\nproto_tree_add_bitmask_text(tree, tvb, 10, 1, NULL, NULL, ett_ipmi_se_cp15_byte11, byte11, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrq00(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nunsigned int addr;\r\nproto_item *ti;\r\naddr = tvb_get_guint8(tvb, 0);\r\nti = proto_tree_add_item(tree, hf_ipmi_se_00_addr, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nif (addr == 0xff)\r\n{\r\nproto_item_append_text(ti, " (Disable Message Generation)");\r\n}\r\nproto_tree_add_item(tree, hf_ipmi_se_00_lun, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs01(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nunsigned int addr;\r\nproto_item *ti;\r\naddr = tvb_get_guint8(tvb, 0);\r\nti = proto_tree_add_item(tree, hf_ipmi_se_01_addr, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nif (addr == 0xff)\r\n{\r\nproto_item_append_text(ti, " (Disable Message Generation)");\r\n}\r\nproto_tree_add_item(tree, hf_ipmi_se_01_lun, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq02(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nparse_platform_event(tvb, tree);\r\n}\r\nstatic void\r\nrs10(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte2[] = { &hf_ipmi_se_10_action_oem_filter, &hf_ipmi_se_10_action_diag_intr,\r\n&hf_ipmi_se_10_action_oem_action, &hf_ipmi_se_10_action_pwr_cycle, &hf_ipmi_se_10_action_reset,\r\n&hf_ipmi_se_10_action_pwr_down, &hf_ipmi_se_10_action_alert, NULL };\r\nproto_tree_add_item(tree, hf_ipmi_se_10_pef_version, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, "Action support: ", "None", ett_ipmi_se_10_action,\r\nbyte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_se_10_entries, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq11(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nguint8 val;\r\nval = tvb_get_guint8(tvb, 0);\r\nproto_tree_add_uint_format(tree, hf_ipmi_se_11_rq_timeout, tvb, 0, 1,\r\nval, "%s", val_to_str(val, vals_11_pef_timer, "Arm Timer for: %d sec"));\r\n}\r\nstatic void\r\nrs11(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nguint8 val;\r\nval = tvb_get_guint8(tvb, 0);\r\nproto_tree_add_uint_format(tree, hf_ipmi_se_11_rs_timeout, tvb, 0, 1,\r\nval, "%s", val_to_str(val, vals_11_pef_timer, "Present Timer Countdown value: %d sec"));\r\n}\r\nstatic void\r\nrq12(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nproto_item *ti;\r\nproto_tree *s_tree;\r\ntvbuff_t *sub;\r\nguint8 pno;\r\nconst char *desc;\r\npno = tvb_get_guint8(tvb, 0) & 0x7f;\r\nif (pno < array_length(conf_params)) {\r\ndesc = conf_params[pno].name;\r\n} else if (pno >= 96 && pno <= 127) {\r\ndesc = "OEM";\r\n} else {\r\ndesc = "Reserved";\r\n}\r\nti = proto_tree_add_uint_format_value(tree, hf_ipmi_se_12_byte1, tvb, 0, 1,\r\npno, "%s (0x%02x)", desc, pno);\r\ns_tree = proto_item_add_subtree(ti, ett_ipmi_se_12_byte1);\r\nproto_tree_add_uint_format_value(s_tree, hf_ipmi_se_12_param, tvb, 0, 1,\r\npno, "Parameter selector: %s (0x%02x)", desc, pno);\r\nif (pno < array_length(conf_params)) {\r\nsub = tvb_new_subset_remaining(tvb, 1);\r\nconf_params[pno].intrp(sub, pinfo, tree);\r\n} else {\r\nproto_tree_add_none_format(tree, hf_ipmi_se_12_data, tvb, 1, -1,\r\n"Configuration parameter data: %s", desc);\r\n}\r\n}\r\nstatic void\r\nrq13(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_item *ti;\r\nproto_tree *s_tree;\r\nguint32 pno;\r\nconst char *desc;\r\npno = tvb_get_guint8(tvb, 0);\r\nipmi_set_data(pinfo, 0, pno);\r\nif (!tree) {\r\nreturn;\r\n}\r\npno &= 0x7f;\r\nif (pno < array_length(conf_params)) {\r\ndesc = conf_params[pno].name;\r\n} else if (pno >= 96 && pno <= 127) {\r\ndesc = "OEM";\r\n} else {\r\ndesc = "Reserved";\r\n}\r\nti = proto_tree_add_uint_format_value(tree, hf_ipmi_se_13_byte1, tvb, 0, 1,\r\npno, "%s (0x%02x)", desc, pno);\r\ns_tree = proto_item_add_subtree(ti, ett_ipmi_se_13_byte1);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_13_getrev, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_uint_format_value(s_tree, hf_ipmi_se_13_param, tvb, 0, 1,\r\npno, "%s (0x%02x)", desc, pno);\r\nproto_tree_add_item(tree, hf_ipmi_se_13_set, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_13_block, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs13(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_se_13_rev_present, &hf_ipmi_se_13_rev_compat, NULL };\r\nproto_item *ti;\r\ntvbuff_t *sub;\r\nguint32 pno;\r\nconst char *desc;\r\nti = proto_tree_add_bitmask_text(tree, tvb, 0, 1, "Parameter revision", NULL,\r\nett_ipmi_se_13_rev, byte1, ENC_LITTLE_ENDIAN, 0);\r\nif (!ipmi_get_data(pinfo, 0, &pno)) {\r\nif (tvb_captured_length(tvb) > 1) {\r\nproto_tree_add_item(tree, hf_ipmi_se_13_data, tvb, 1, -1, ENC_NA);\r\n}\r\nreturn;\r\n}\r\nif ((pno & 0x80) && tvb_captured_length(tvb) > 1) {\r\nexpert_add_info(pinfo, ti, &ei_ipmi_se_13_request_param_rev);\r\n} else if (!(pno & 0x80) && tvb_captured_length(tvb) == 1) {\r\nexpert_add_info(pinfo, ti, &ei_ipmi_se_13_request_param_data);\r\n}\r\npno &= 0x7f;\r\nif (pno < array_length(conf_params)) {\r\ndesc = conf_params[pno].name;\r\n} else if (pno >= 96 && pno <= 127) {\r\ndesc = "OEM";\r\n} else {\r\ndesc = "Reserved";\r\n}\r\nti = proto_tree_add_uint_format_value(tree, hf_ipmi_se_13_parameter, tvb, 0, 0,\r\npno, "%s", desc);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nif (tvb_captured_length(tvb) > 1) {\r\nif (pno < array_length(conf_params)) {\r\nsub = tvb_new_subset_remaining(tvb, 1);\r\nconf_params[pno].intrp(sub, pinfo, tree);\r\n} else {\r\nproto_tree_add_item(tree, hf_ipmi_se_13_data, tvb, 1, -1, ENC_NA);\r\n}\r\n}\r\n}\r\nstatic void\r\nrq14(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_14_processed_by, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_14_rid, tvb, 1, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs15(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nguint16 tmp;\r\nproto_item *ti;\r\nipmi_add_timestamp(tree, hf_ipmi_se_15_tstamp, tvb, 0);\r\ntmp = tvb_get_letohs(tvb, 4);\r\nti = proto_tree_add_item(tree, hf_ipmi_se_15_lastrec, tvb, 4, 2, ENC_LITTLE_ENDIAN);\r\nif (tmp == 0xffff)\r\n{\r\nproto_item_append_text(ti, " (SEL is empty)");\r\n}\r\nproto_tree_add_item(tree, hf_ipmi_se_15_proc_sw, tvb, 6, 2, ENC_LITTLE_ENDIAN);\r\ntmp = tvb_get_letohs(tvb, 8);\r\nti = proto_tree_add_item(tree, hf_ipmi_se_15_proc_bmc, tvb, 8, 2, ENC_LITTLE_ENDIAN);\r\nif (tmp == 0)\r\n{\r\nproto_item_append_text(ti, " (Event processed but cannot be logged)");\r\n}\r\n}\r\nstatic void\r\nrq16(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_se_16_chan, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_se_16_op, &hf_ipmi_se_16_dst, NULL };\r\nstatic const gint *byte3[] = { &hf_ipmi_se_16_send_string, &hf_ipmi_se_16_string_sel, NULL };\r\ntvbuff_t *sub;\r\nipmi_set_data(pinfo, 0, (tvb_get_guint8(tvb, 1) & 0xc0) >> 6);\r\nif (!tree) {\r\nreturn;\r\n}\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_se_16_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_se_16_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 2, 1, NULL, NULL, ett_ipmi_se_16_byte3, byte3, ENC_LITTLE_ENDIAN, 0);\r\nif (tvb_captured_length(tvb) > 3) {\r\nproto_tree_add_item(tree, hf_ipmi_se_16_gen, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nsub = tvb_new_subset_remaining(tvb, 4);\r\nparse_platform_event(sub, tree);\r\n}\r\n}\r\nstatic void\r\nrs16(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nguint32 val;\r\nif (ipmi_get_data(pinfo, 0, &val) && val == 0x01) {\r\nproto_tree_add_item(tree, hf_ipmi_se_16_status, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrq17(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_17_seq, tvb, 0, 2, ENC_LITTLE_ENDIAN);\r\nipmi_add_timestamp(tree, hf_ipmi_se_17_tstamp, tvb, 2);\r\nproto_tree_add_item(tree, hf_ipmi_se_17_evsrc, tvb, 6, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_17_sensor_dev, tvb, 7, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_17_sensor_num, tvb, 8, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_17_evdata1, tvb, 9, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_17_evdata2, tvb, 10, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_17_evdata3, tvb, 11, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq20(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (tvb_captured_length(tvb) > 0) {\r\nipmi_set_data(pinfo, 0, tvb_get_guint8(tvb, 0) & 0x01);\r\nproto_tree_add_item(tree, hf_ipmi_se_20_rq_op, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrs20(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte2[] = { &hf_ipmi_se_20_rs_population, &hf_ipmi_se_20_rs_lun3,\r\n&hf_ipmi_se_20_rs_lun2, &hf_ipmi_se_20_rs_lun1, &hf_ipmi_se_20_rs_lun0, NULL };\r\nguint32 val;\r\nif (ipmi_get_data(pinfo, 0, &val) && val) {\r\nproto_tree_add_item(tree, hf_ipmi_se_20_rs_sdr, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n} else {\r\nproto_tree_add_item(tree, hf_ipmi_se_20_rs_num, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_se_20_rs_byte2,\r\nbyte2, ENC_LITTLE_ENDIAN, 0);\r\nif (tvb_get_guint8(tvb, 1) & 0x80) {\r\nproto_tree_add_item(tree, hf_ipmi_se_20_rs_change, tvb, 2, 4, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrq21(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nguint8 len;\r\nlen = tvb_get_guint8(tvb, 5);\r\nproto_tree_add_item(tree, hf_ipmi_se_21_rid, tvb, 0, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_21_record, tvb, 2, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_21_offset, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_se_21_len, tvb, 5, 1, len,\r\n"%u%s", len, len == 0xff ? "(entire record)" : "");\r\n}\r\nstatic void\r\nrs21(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_21_next, tvb, 0, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_21_recdata, tvb, 2, -1, ENC_NA);\r\n}\r\nstatic void\r\nrs22(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_22_resid, tvb, 0, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq23(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_23_rq_sensor, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_23_rq_reading, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic inline gint16\r\nsign_extend(gint16 v, int bits)\r\n{\r\nif ((v & (1 << (bits - 1))) == 0) {\r\nreturn v;\r\n}\r\nreturn v | (0xffff << bits);\r\n}\r\nstatic void\r\nrs23(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree *s_tree;\r\nguint16 tol, acc, accexp, tmp;\r\ngint16 m, b, bexp, rexp;\r\nproto_tree_add_item(tree, hf_ipmi_se_23_rs_next_reading, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nm = tvb_get_guint8(tvb, 1);\r\ntmp = tvb_get_guint8(tvb, 2);\r\nm |= (tmp & 0xc0) << 2;\r\ntol = tmp & 0x3f;\r\nb = tvb_get_guint8(tvb, 3);\r\ntmp = tvb_get_guint8(tvb, 4);\r\nb |= (tmp & 0xc0) << 2;\r\nacc = tmp & 0x3f;\r\ntmp = tvb_get_guint8(tvb, 5);\r\nacc |= (tmp & 0xf0) << 4;\r\naccexp = (tmp & 0x0c) >> 2;\r\ntmp = tvb_get_guint8(tvb, 6);\r\nrexp = (tmp & 0xf0) >> 4;\r\nbexp = tmp & 0x0f;\r\nm = sign_extend(m, 10);\r\nb = sign_extend(b, 10);\r\nbexp = sign_extend(bexp, 4);\r\nrexp = sign_extend(rexp, 4);\r\ns_tree = proto_tree_add_subtree_format(tree, tvb, 1, 6, ett_ipmi_se_23_readingfactors, NULL,\r\n"Factors: M=%d B=%d K1=%d K2=%d Acc=%u*10^%u Tol=%u",\r\nm, b, bexp, rexp, acc, accexp, tol);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_23_m, tvb, 1, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_23_tolerance, tvb, 1, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_23_b, tvb, 3, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_23_accuracy, tvb, 4, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_23_accuracy_exponent, tvb, 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_23_r_exponent, tvb, 6, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(s_tree, hf_ipmi_se_23_b_exponent, tvb, 6, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq24(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_24_sensor, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_24_mask, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_24_hyst_pos, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_24_hyst_neg, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq25(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_25_sensor, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_25_mask, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs25(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_25_hyst_pos, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_25_hyst_neg, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nadd_thresholds(tvbuff_t *tvb, int offs, proto_tree *tree, const char *desc)\r\n{\r\nstatic const int *threshold_mask[] = { &hf_ipmi_se_XX_m_unr, &hf_ipmi_se_XX_m_uc, &hf_ipmi_se_XX_m_unc,\r\n&hf_ipmi_se_XX_m_lnr, &hf_ipmi_se_XX_m_lc, &hf_ipmi_se_XX_m_lnc, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, offs, 1, desc, "None",\r\nett_ipmi_se_XX_mask, threshold_mask, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_se_XX_thr_lnc, tvb, offs + 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_XX_thr_lc, tvb, offs + 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_XX_thr_lnr, tvb, offs + 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_XX_thr_unc, tvb, offs + 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_XX_thr_uc, tvb, offs + 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_XX_thr_unr, tvb, offs + 6, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq26(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_26_sensor, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nadd_thresholds(tvb, 1, tree, "Set thresholds: ");\r\n}\r\nstatic void\r\nrq27(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_27_sensor, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs27(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nadd_thresholds(tvb, 0, tree, "Readable thresholds: ");\r\n}\r\nstatic void\r\nadd_events(tvbuff_t *tvb, int offs, proto_tree *tree, const struct true_false_string *tfs,\r\nconst char *desc)\r\n{\r\nstatic const int *bsel[4][8] = {\r\n{ &hf_ipmi_se_XX_b1_0, &hf_ipmi_se_XX_b1_1, &hf_ipmi_se_XX_b1_2, &hf_ipmi_se_XX_b1_3,\r\n&hf_ipmi_se_XX_b1_4, &hf_ipmi_se_XX_b1_5, &hf_ipmi_se_XX_b1_6, &hf_ipmi_se_XX_b1_7 },\r\n{ &hf_ipmi_se_XX_b2_0, &hf_ipmi_se_XX_b2_1, &hf_ipmi_se_XX_b2_2, &hf_ipmi_se_XX_b2_3,\r\n&hf_ipmi_se_XX_b2_4, &hf_ipmi_se_XX_b2_5, &hf_ipmi_se_XX_b2_6, NULL },\r\n{ &hf_ipmi_se_XX_b3_0, &hf_ipmi_se_XX_b3_1, &hf_ipmi_se_XX_b3_2, &hf_ipmi_se_XX_b3_3,\r\n&hf_ipmi_se_XX_b3_4, &hf_ipmi_se_XX_b3_5, &hf_ipmi_se_XX_b3_6, &hf_ipmi_se_XX_b3_7 },\r\n{ &hf_ipmi_se_XX_b4_0, &hf_ipmi_se_XX_b4_1, &hf_ipmi_se_XX_b4_2, &hf_ipmi_se_XX_b4_3,\r\n&hf_ipmi_se_XX_b4_4, &hf_ipmi_se_XX_b4_5, &hf_ipmi_se_XX_b4_6, NULL }\r\n};\r\nstatic const int *tsel[] = { &ett_ipmi_se_XX_b1, &ett_ipmi_se_XX_b2, &ett_ipmi_se_XX_b3, &ett_ipmi_se_XX_b4 };\r\nproto_tree *s_tree;\r\nint len = tvb_captured_length(tvb);\r\nint i, j, val, msk;\r\nfor (i = 0; (offs < len) && (i < 4); i++, offs++) {\r\nval = tvb_get_guint8(tvb, offs);\r\ns_tree = proto_tree_add_subtree_format(tree, tvb, offs, 1, *tsel[i], NULL, "%s (byte %d)", desc, i);\r\nfor (j = 7; j >= 0; j--) {\r\nif (!bsel[i][j]) {\r\ncontinue;\r\n}\r\nmsk = 1 << j;\r\nproto_tree_add_boolean_format_value(s_tree, *bsel[i][j], tvb, offs, 1,\r\nval & msk, "%s", (val & msk) ? tfs->true_string : tfs->false_string);\r\n}\r\n}\r\n}\r\nstatic void\r\nrq28(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte2[] = { &hf_ipmi_se_28_fl_evm, &hf_ipmi_se_28_fl_scan, &hf_ipmi_se_28_fl_action, NULL };\r\nstatic const struct true_false_string tfs_lect = { "Select", "Do not select" };\r\nproto_tree_add_item(tree, hf_ipmi_se_28_sensor, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_se_28_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nadd_events(tvb, 2, tree, &tfs_lect, "Selected events");\r\n}\r\nstatic void\r\nrq29(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_29_sensor, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs29(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_se_29_fl_evm, &hf_ipmi_se_29_fl_scan, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_se_29_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nadd_events(tvb, 1, tree, &tfs_29_enabled, "Enabled events");\r\n}\r\nstatic void\r\nrq2a(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const struct true_false_string rearm_tfs = { "Re-arm", "Do not re-arm" };\r\nproto_tree_add_item(tree, hf_ipmi_se_2a_sensor, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_se_2a_fl_sel, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nadd_events(tvb, 2, tree, &rearm_tfs, "Re-arm Events");\r\n}\r\nstatic void\r\nrq2b(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_2b_sensor, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs2b(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_se_2b_fl_evm, &hf_ipmi_se_2b_fl_scan, &hf_ipmi_se_2b_fl_unavail, NULL };\r\nstatic const struct true_false_string occur_tfs = { "Occurred", "Did not occur" };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_se_2b_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nadd_events(tvb, 1, tree, &occur_tfs, "Event Status");\r\n}\r\nstatic void\r\nrq2d(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_2d_sensor, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs2d(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte2[] = { &hf_ipmi_se_2b_fl_evm, &hf_ipmi_se_2b_fl_scan, &hf_ipmi_se_2b_fl_unavail, NULL };\r\nstatic const int *bsel[2][8] = {\r\n{ &hf_ipmi_se_2d_b1_0, &hf_ipmi_se_2d_b1_1, &hf_ipmi_se_2d_b1_2, &hf_ipmi_se_2d_b1_3,\r\n&hf_ipmi_se_2d_b1_4, &hf_ipmi_se_2d_b1_5, &hf_ipmi_se_2d_b1_6, &hf_ipmi_se_2d_b1_7 },\r\n{ &hf_ipmi_se_2d_b2_0, &hf_ipmi_se_2d_b2_1, &hf_ipmi_se_2d_b2_2, &hf_ipmi_se_2d_b2_3,\r\n&hf_ipmi_se_2d_b2_4, &hf_ipmi_se_2d_b2_5, &hf_ipmi_se_2d_b2_6, NULL }\r\n};\r\nstatic const int *tsel[2] = { &ett_ipmi_se_2d_b1, &ett_ipmi_se_2d_b2 };\r\nproto_tree *s_tree;\r\nint i, j, len;\r\nproto_tree_add_item(tree, hf_ipmi_se_2d_reading, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_se_2d_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nlen = tvb_captured_length(tvb);\r\nfor (i = 0; i < 2 && i < len - 2; i++) {\r\ns_tree = proto_tree_add_subtree_format(tree, tvb, i + 2, 1, *tsel[i], NULL,\r\n"Threshold comparisons/assertions (byte %d)", i);\r\nfor (j = 7; j >= 0; j--) {\r\nif (bsel[i][j]) {\r\nproto_tree_add_item(s_tree, *bsel[i][j], tvb, i + 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nrq2e(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nguint8 stype;\r\nconst struct sensor_info *si;\r\nstype = tvb_get_guint8(tvb, 1);\r\nsi = get_sensor_info(stype);\r\nproto_tree_add_item(tree, hf_ipmi_se_2e_sensor, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_se_2e_stype, tvb, 1, 1,\r\nstype, "%s (0x%02x)", si->desc, stype);\r\nproto_tree_add_item(tree, hf_ipmi_se_2e_evtype, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq2f(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_se_2f_sensor, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs2f(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nguint8 stype;\r\nconst struct sensor_info *si;\r\nstype = tvb_get_guint8(tvb, 0);\r\nsi = get_sensor_info(stype);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_se_2f_stype, tvb, 0, 1,\r\nstype, "%s (0x%02x)", si->desc, stype);\r\nproto_tree_add_item(tree, hf_ipmi_se_2f_evtype, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nvoid\r\nproto_register_ipmi_se(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ipmi_se_evt_rev,\r\n{ "Event Message Revision",\r\n"ipmi.evt.evmrev", FT_UINT8, BASE_HEX, VALS(evt_evm_rev_vals), 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_evt_sensor_type,\r\n{ "Sensor Type",\r\n"ipmi.evt.sensor_type", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_evt_sensor_num,\r\n{ "Sensor #",\r\n"ipmi.evt.sensor_num", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_evt_byte3,\r\n{ "Event Dir/Type",\r\n"ipmi.evt.byte3", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_evt_dir,\r\n{ "Event Direction",\r\n"ipmi.evt.evdir", FT_BOOLEAN, 8, TFS(&evt_evdir_tfs), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_se_evt_type,\r\n{ "Event/Reading type",\r\n"ipmi.evt.evtype", FT_UINT8, BASE_HEX|BASE_RANGE_STRING, RVALS(evtype_rvals), 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_evt_data1,\r\n{ "Event Data 1",\r\n"ipmi.evt.data1", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_evt_data1_b2,\r\n{ "Byte 2",\r\n"ipmi.evt.data1.b2", FT_UINT8, BASE_HEX, NULL, 0xc0, NULL, HFILL }},\r\n{ &hf_ipmi_se_evt_data1_b3,\r\n{ "Byte 3",\r\n"ipmi.evt.data1.b3", FT_UINT8, BASE_HEX, NULL, 0x30, NULL, HFILL }},\r\n{ &hf_ipmi_se_evt_data1_offs,\r\n{ "Offset",\r\n"ipmi.evt.data1.offs", FT_UINT8, BASE_HEX, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_se_evt_data2,\r\n{ "Event Data 2",\r\n"ipmi.evt.data2", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_evt_data3,\r\n{ "Event Data 3",\r\n"ipmi.evt.data3", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp00_sip,\r\n{ "Set In Progress",\r\n"ipmi.cp00.sip", FT_UINT8, BASE_HEX, VALS(cp00_sip_vals), 0x03, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp01_alert_startup,\r\n{ "PEF Alert Startup Delay disable",\r\n"ipmi.cp01.alert_startup", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp01_startup,\r\n{ "PEF Startup Delay disable",\r\n"ipmi.cp01.startup", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp01_event_msg,\r\n{ "Enable Event Messages for PEF actions",\r\n"ipmi.cp01.event_msg", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp01_pef,\r\n{ "Enable PEF",\r\n"ipmi.cp01.pef", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp02_diag_intr,\r\n{ "Enable Diagnostic Interrupt",\r\n"ipmi.cp02.diag_intr", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp02_oem_action,\r\n{ "Enable OEM action",\r\n"ipmi.cp02.oem_action", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp02_pwr_cycle,\r\n{ "Enable Power Cycle action",\r\n"ipmi.cp02.pwr_cycle", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp02_reset,\r\n{ "Enable Reset action",\r\n"ipmi.cp02.reset", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp02_pwr_down,\r\n{ "Enable Power Down action",\r\n"ipmi.cp02.pwr_down", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp02_alert,\r\n{ "Enable Alert action",\r\n"ipmi.cp02.alert", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp03_startup,\r\n{ "PEF Startup delay",\r\n"ipmi.cp03.startup", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_1s_1based), 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp04_alert_startup,\r\n{ "PEF Alert Startup delay",\r\n"ipmi.cp04.alert_startup", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_1s_1based), 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp05_num_evfilters,\r\n{ "Number of Event Filters",\r\n"ipmi.cp05.num_evfilters", FT_UINT8, BASE_DEC, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp06_filter,\r\n{ "Filter number (set selector)",\r\n"ipmi.cp06.filter", FT_UINT8, BASE_DEC, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp06_data,\r\n{ "Filter data",\r\n"ipmi.cp06.data", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp07_filter,\r\n{ "Filter number (set selector)",\r\n"ipmi.cp07.filter", FT_UINT8, BASE_DEC, NULL, 0x7f, NULL, HFILL }},\r\n#if 0\r\n{ &hf_ipmi_se_cp07_data,\r\n{ "Filter data (byte 1)",\r\n"ipmi.cp07.data", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n#endif\r\n{ &hf_ipmi_se_cp08_policies,\r\n{ "Number of Alert Policy Entries",\r\n"ipmi.cp08.policies", FT_UINT8, BASE_DEC, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp09_entry,\r\n{ "Entry number (set selector)",\r\n"ipmi.cp09.entry", FT_UINT8, BASE_DEC, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp09_data,\r\n{ "Entry data",\r\n"ipmi.cp09.data", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp10_useval,\r\n{ "Used to fill the GUID field in PET Trap",\r\n"ipmi.cp10.useval", FT_BOOLEAN, 8, TFS(&cp10_use_tfs), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp10_guid,\r\n{ "GUID",\r\n"ipmi.cp10.guid", FT_GUID, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp11_num_alertstr,\r\n{ "Number of Alert Strings",\r\n"ipmi.cp11.num_alertstr", FT_UINT8, BASE_DEC, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp12_byte1,\r\n{ "Alert String Selector",\r\n"ipmi.cp12.byte1", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp12_alert_stringsel,\r\n{ "Alert String Selector (set selector)",\r\n"ipmi.cp12.alert_stringsel", FT_UINT8, BASE_HEX, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp12_evfilter,\r\n{ "Filter Number",\r\n"ipmi.cp12.evfilter", FT_UINT8, BASE_HEX, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp12_alert_stringset,\r\n{ "Set number for string",\r\n"ipmi.cp12.alert_stringset", FT_UINT8, BASE_HEX, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp13_stringsel,\r\n{ "String selector (set selector)",\r\n"ipmi.cp13.stringsel", FT_UINT8, BASE_HEX, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp13_blocksel,\r\n{ "Block selector",\r\n"ipmi.cp13.blocksel", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp13_string,\r\n{ "String data",\r\n"ipmi.cp13.string", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp14_num_gct,\r\n{ "Number of Group Control Table entries",\r\n"ipmi.cp14.num_gct", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp15_gctsel,\r\n{ "Group control table entry selector (set selector)",\r\n"ipmi.cp15.gctsel", FT_UINT8, BASE_HEX, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp15_force,\r\n{ "Request/Force",\r\n"ipmi.cp15.force", FT_BOOLEAN, 8, TFS(&cp15_rq_frc_tfs), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp15_delayed,\r\n{ "Immediate/Delayed",\r\n"ipmi.cp15.delayed", FT_BOOLEAN, 8, TFS(&cp15_imm_delay_tfs), 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp15_channel,\r\n{ "Channel",\r\n"ipmi.cp15.channel", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp15_group,\r\n{ "Group ID",\r\n"ipmi.cp15.group_id", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp15_member_check,\r\n{ "Member ID check disabled",\r\n"ipmi.cp15.member_check", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp15_member_id,\r\n{ "Member ID",\r\n"ipmi.cp15_member_id", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp15_retries,\r\n{ "Retries",\r\n"ipmi.cp15.retries", FT_UINT8, BASE_DEC, NULL, 0x70, NULL, HFILL }},\r\n{ &hf_ipmi_se_cp15_operation,\r\n{ "Operation",\r\n"ipmi.cp15.operation", FT_UINT8, BASE_HEX, VALS(cp15_op_vals), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_se_00_addr,\r\n{ "Event Receiver slave address",\r\n"ipmi.se00.addr", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_00_lun,\r\n{ "Event Receiver LUN",\r\n"ipmi.se00.lun", FT_UINT8, BASE_HEX, NULL, 0x3, NULL, HFILL }},\r\n{ &hf_ipmi_se_01_addr,\r\n{ "Event Receiver slave address",\r\n"ipmi.se01.addr", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_01_lun,\r\n{ "Event Receiver LUN",\r\n"ipmi.se01.lun", FT_UINT8, BASE_HEX, NULL, 0x3, NULL, HFILL }},\r\n{ &hf_ipmi_se_10_pef_version,\r\n{ "PEF Version",\r\n"ipmi.se10.pef_version", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_version), 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_10_action_oem_filter,\r\n{ "OEM Event Record Filtering supported",\r\n"ipmi.se10.action.oem_filter", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_se_10_action_diag_intr,\r\n{ "Diagnostic Interrupt",\r\n"ipmi.se10.action.diag_intr", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_se_10_action_oem_action,\r\n{ "OEM Action",\r\n"ipmi.se10.action.oem_action", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_se_10_action_pwr_cycle,\r\n{ "Power Cycle",\r\n"ipmi.se10.action.pwr_cycle", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_se_10_action_reset,\r\n{ "Reset",\r\n"ipmi.se10.action.reset", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_se_10_action_pwr_down,\r\n{ "Power Down",\r\n"ipmi.se10.action.pwr_down", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_se_10_action_alert,\r\n{ "Alert",\r\n"ipmi.se10.action.alert", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_10_entries,\r\n{ "Number of event filter table entries",\r\n"ipmi.se10.entries", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_10_evtype,\r\n{ "Event/Reading type",\r\n"ipmi.se10.evtype", FT_UINT8, BASE_HEX|BASE_RANGE_STRING, RVALS(evtype_rvals), 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_11_rq_timeout,\r\n{ "Timeout value",\r\n"ipmi.se11.rq_timeout", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_11_rs_timeout,\r\n{ "Timeout value",\r\n"ipmi.se11.rs_timeout", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_12_byte1,\r\n{ "Parameter selector",\r\n"ipmi.se12.byte1", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_12_param,\r\n{ "Parameter selector",\r\n"ipmi.se12.param", FT_UINT8, BASE_HEX, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_12_data,\r\n{ "Parameter data",\r\n"ipmi.se12.data", FT_NONE, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_13_byte1,\r\n{ "Parameter selector",\r\n"ipmi.se13.byte1", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_13_getrev,\r\n{ "Get Parameter Revision only",\r\n"ipmi.se13.getrev", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_se_13_param,\r\n{ "Parameter selector",\r\n"ipmi.se13.param", FT_UINT8, BASE_HEX, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_13_set,\r\n{ "Set Selector",\r\n"ipmi.se13.set", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_13_block,\r\n{ "Block Selector",\r\n"ipmi.se13.block", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_13_rev_present,\r\n{ "Present",\r\n"ipmi.se13.rev.present", FT_UINT8, BASE_DEC, NULL, 0xf0, NULL, HFILL }},\r\n{ &hf_ipmi_se_13_rev_compat,\r\n{ "Oldest forward-compatible",\r\n"ipmi.se13.rev.compat", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_se_13_data,\r\n{ "Parameter data",\r\n"ipmi.se13.data", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_14_processed_by,\r\n{ "Set Record ID for last record processed by",\r\n"ipmi.se14.processed_by", FT_BOOLEAN, 8, TFS(&tfs_14_processed), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_14_rid,\r\n{ "Record ID",\r\n"ipmi.se14.rid", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_15_tstamp,\r\n{ "Most recent addition timestamp",\r\n"ipmi.se15.tstamp", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_15_lastrec,\r\n{ "Record ID for last record in SEL",\r\n"ipmi.se15.lastrec", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_15_proc_sw,\r\n{ "Last SW Processed Event Record ID",\r\n"ipmi.se15.proc_sw", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_15_proc_bmc,\r\n{ "Last BMC Processed Event Record ID",\r\n"ipmi.se15.proc_bmc", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_16_chan,\r\n{ "Channel",\r\n"ipmi.se16.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_se_16_op,\r\n{ "Operation",\r\n"ipmi.se16.op", FT_UINT8, BASE_HEX, VALS(vals_16_op), 0xc0, NULL, HFILL }},\r\n{ &hf_ipmi_se_16_dst,\r\n{ "Destination",\r\n"ipmi.se16.dst", FT_UINT8, BASE_HEX, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_se_16_send_string,\r\n{ "Send Alert String",\r\n"ipmi.se16.send_string", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_se_16_string_sel,\r\n{ "String selector",\r\n"ipmi.se16.string_sel", FT_UINT8, BASE_HEX, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_16_gen,\r\n{ "Generator ID",\r\n"ipmi.se16.gen", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_16_status,\r\n{ "Alert Immediate Status",\r\n"ipmi.se16.status", FT_UINT8, BASE_HEX, VALS(vals_16_status), 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_17_seq,\r\n{ "Sequence Number",\r\n"ipmi.se17.seq", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_17_tstamp,\r\n{ "Local Timestamp",\r\n"ipmi.se17.tstamp", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_17_evsrc,\r\n{ "Event Source Type",\r\n"ipmi.se17.evsrc", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_17_sensor_dev,\r\n{ "Sensor Device",\r\n"ipmi.se17.sensor_dev", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_17_sensor_num,\r\n{ "Sensor Number",\r\n"ipmi.se17.sensor_num", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_17_evdata1,\r\n{ "Event Data 1",\r\n"ipmi.se17.evdata1", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_17_evdata2,\r\n{ "Event Data 2",\r\n"ipmi.se17.evdata2", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_17_evdata3,\r\n{ "Event Data 3",\r\n"ipmi.se17.evdata3", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_20_rq_op,\r\n{ "Operation",\r\n"ipmi.se20.rq_op", FT_BOOLEAN, 8, TFS(&tfs_20_op), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_20_rs_num,\r\n{ "Number of sensors in device for LUN",\r\n"ipmi.se20.rs_num", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_20_rs_sdr,\r\n{ "Total Number of SDRs in the device",\r\n"ipmi.se20.rs_sdr", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_20_rs_population,\r\n{ "Sensor population",\r\n"ipmi.se20.rs_population", FT_BOOLEAN, 8, TFS(&tfs_20_pop), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_se_20_rs_lun3,\r\n{ "LUN3 has sensors",\r\n"ipmi.se20.rs_lun3", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_se_20_rs_lun2,\r\n{ "LUN2 has sensors",\r\n"ipmi.se20.rs_lun2", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_se_20_rs_lun1,\r\n{ "LUN1 has sensors",\r\n"ipmi.se20.rs_lun1", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_se_20_rs_lun0,\r\n{ "LUN0 has sensors",\r\n"ipmi.se20.rs_lun0", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_20_rs_change,\r\n{ "Sensor Population Change Indicator",\r\n"ipmi.se20.rs_change", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_21_rid,\r\n{ "Reservation ID",\r\n"ipmi.se21.rid", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_21_record,\r\n{ "Record ID",\r\n"ipmi.se21.record", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_21_offset,\r\n{ "Offset into data",\r\n"ipmi.se21.offset", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_21_len,\r\n{ "Bytes to read",\r\n"ipmi.se21.len", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_21_next,\r\n{ "Next record ID",\r\n"ipmi.se21.next", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_21_recdata,\r\n{ "Record data",\r\n"ipmi.se21.recdata", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_22_resid,\r\n{ "Reservation ID",\r\n"ipmi.se22.resid", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_23_rq_sensor,\r\n{ "Sensor Number",\r\n"ipmi.se23.rq_sensor", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_23_rq_reading,\r\n{ "Reading",\r\n"ipmi.se23.rq_reading", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_23_rs_next_reading,\r\n{ "Next reading",\r\n"ipmi.se23.rs_next_reading", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_24_sensor,\r\n{ "Sensor Number",\r\n"ipmi.se24.sensor", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_24_mask,\r\n{ "Reserved for future 'hysteresis mask'",\r\n"ipmi.se24.mask", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_24_hyst_pos,\r\n{ "Positive-going hysteresis",\r\n"ipmi.se24.hyst_pos", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_24_hyst_neg,\r\n{ "Negative-going hysteresis",\r\n"ipmi.se24.hyst_neg", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_25_sensor,\r\n{ "Sensor Number",\r\n"ipmi.se25.sensor", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_25_mask,\r\n{ "Reserved for future 'hysteresis mask'",\r\n"ipmi.se25.mask", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_25_hyst_pos,\r\n{ "Positive-going hysteresis",\r\n"ipmi.se25.hyst_pos", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_25_hyst_neg,\r\n{ "Negative-going hysteresis",\r\n"ipmi.se25.hyst_neg", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_26_sensor,\r\n{ "Sensor Number",\r\n"ipmi.seXX.sensor", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_m_unr,\r\n{ "Upper Non-Recoverable",\r\n"ipmi.seXX.mask.unr", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_m_uc,\r\n{ "Upper Critical",\r\n"ipmi.seXX.mask.uc", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_m_unc,\r\n{ "Upper Non-Critical",\r\n"ipmi.seXX.mask.unc", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_m_lnr,\r\n{ "Lower Non-Recoverable",\r\n"ipmi.seXX.mask.lnr", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_m_lc,\r\n{ "Lower Critical",\r\n"ipmi.seXX.mask.lc", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_m_lnc,\r\n{ "Lower Non-Critical",\r\n"ipmi.seXX.mask.lnc", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_thr_lnc,\r\n{ "Lower Non-Critical Threshold",\r\n"ipmi.seXX.lnc", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_thr_lc,\r\n{ "Lower Critical Threshold",\r\n"ipmi.seXX.lc", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_thr_lnr,\r\n{ "Lower Non-Recoverable Threshold",\r\n"ipmi.seXX.lnr", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_thr_unc,\r\n{ "Upper Non-Critical Threshold",\r\n"ipmi.seXX.unc", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_thr_uc,\r\n{ "Upper Critical Threshold",\r\n"ipmi.seXX.uc", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_thr_unr,\r\n{ "Upper Non-Recoverable Threshold",\r\n"ipmi.seXX.unr", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_27_sensor,\r\n{ "Sensor Number",\r\n"ipmi.se27.sensor", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b1_7,\r\n{ "Assertion for UNC (going high) / state bit 7",\r\n"ipmi.seXX.a_7", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b1_6,\r\n{ "Assertion for UNC (going low) / state bit 6",\r\n"ipmi.seXX.a_6", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b1_5,\r\n{ "Assertion for LNR (going high) / state bit 5",\r\n"ipmi.seXX.a_5", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b1_4,\r\n{ "Assertion for LNR (going low) / state bit 4",\r\n"ipmi.seXX.a_4", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b1_3,\r\n{ "Assertion for LC (going high) / state bit 3",\r\n"ipmi.seXX.a_3", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b1_2,\r\n{ "Assertion for LC (going low) / state bit 2",\r\n"ipmi.seXX.a_2", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b1_1,\r\n{ "Assertion for LNC (going high) / state bit 1",\r\n"ipmi.seXX.a_1", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b1_0,\r\n{ "Assertion for LNC (going low) / state bit 0",\r\n"ipmi.seXX.a_0", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b2_6,\r\n{ "Reserved / Assertion for state bit 14",\r\n"ipmi.seXX.a_14", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b2_5,\r\n{ "Reserved / Assertion for state bit 13",\r\n"ipmi.seXX.a_13", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b2_4,\r\n{ "Reserved / Assertion for state bit 12",\r\n"ipmi.seXX.a_12", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b2_3,\r\n{ "Assertion for UNR (going high) / state bit 11",\r\n"ipmi.seXX.a_11", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b2_2,\r\n{ "Assertion for UNR (going low) / state bit 10",\r\n"ipmi.seXX.a_10", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b2_1,\r\n{ "Assertion for UC (going high) / state bit 9",\r\n"ipmi.seXX.a_9", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b2_0,\r\n{ "Assertion for UC (going low) / state bit 8",\r\n"ipmi.seXX.a_8", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b3_7,\r\n{ "Deassertion for UNC (going high) / state bit 7",\r\n"ipmi.seXX.d_7", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b3_6,\r\n{ "Deassertion for UNC (going low) / state bit 6",\r\n"ipmi.seXX.d_6", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b3_5,\r\n{ "Deassertion for LNR (going high) / state bit 5",\r\n"ipmi.seXX.d_5", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b3_4,\r\n{ "Deassertion for LNR (going low) / state bit 4",\r\n"ipmi.seXX.d_4", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b3_3,\r\n{ "Deassertion for LC (going high) / state bit 3",\r\n"ipmi.seXX.d_3", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b3_2,\r\n{ "Deassertion for LC (going low) / state bit 2",\r\n"ipmi.seXX.d_2", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b3_1,\r\n{ "Deassertion for LNC (going high) / state bit 1",\r\n"ipmi.seXX.d_1", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b3_0,\r\n{ "Deassertion for LNC (going low) / state bit 0",\r\n"ipmi.seXX.d_0", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b4_6,\r\n{ "Reserved / Deassertion for state bit 14",\r\n"ipmi.seXX.d_14", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b4_5,\r\n{ "Reserved / Deassertion for state bit 13",\r\n"ipmi.seXX.d_13", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b4_4,\r\n{ "Reserved / Deassertion for state bit 12",\r\n"ipmi.seXX.d_12", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b4_3,\r\n{ "Deassertion for UNR (going high) / state bit 11",\r\n"ipmi.seXX.d_11", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b4_2,\r\n{ "Deassertion for UNR (going low) / state bit 10",\r\n"ipmi.seXX.d_10", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b4_1,\r\n{ "Deassertion for UC (going high) / state bit 9",\r\n"ipmi.seXX.d_9", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_se_XX_b4_0,\r\n{ "Deassertion for UC (going low) / state bit 8",\r\n"ipmi.seXX.d_8", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_28_sensor,\r\n{ "Sensor Number",\r\n"ipmi.se28.sensor", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_28_fl_evm,\r\n{ "Event Messages",\r\n"ipmi.se28.fl_evm", FT_BOOLEAN, 8, TFS(&tfs_28_enable), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_se_28_fl_scan,\r\n{ "Scanning",\r\n"ipmi.se28.fl_scan", FT_BOOLEAN, 8, TFS(&tfs_28_enable), 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_se_28_fl_action,\r\n{ "Action",\r\n"ipmi.se28.fl_action", FT_UINT8, BASE_HEX, VALS(vals_28_act), 0x30, NULL, HFILL }},\r\n{ &hf_ipmi_se_29_sensor,\r\n{ "Sensor Number",\r\n"ipmi.se29.sensor", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_29_fl_evm,\r\n{ "Event Messages",\r\n"ipmi.se29.fl_evm", FT_BOOLEAN, 8, TFS(&tfs_29_enabled), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_se_29_fl_scan,\r\n{ "Scanning",\r\n"ipmi.se29.fl_scan", FT_BOOLEAN, 8, TFS(&tfs_29_enabled), 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_se_2a_sensor,\r\n{ "Sensor Number",\r\n"ipmi.se2a.sensor", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_2a_fl_sel,\r\n{ "Re-arm Events",\r\n"ipmi.se2a.fl_sel", FT_BOOLEAN, 8, TFS(&tfs_2a_sel), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_se_2b_sensor,\r\n{ "Sensor Number",\r\n"ipmi.se2b.sensor", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_2b_fl_evm,\r\n{ "Event Messages",\r\n"ipmi.se2b.fl_evm", FT_BOOLEAN, 8, TFS(&tfs_2b_enabled), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_se_2b_fl_scan,\r\n{ "Sensor scanning",\r\n"ipmi.se2b.fl_scan", FT_BOOLEAN, 8, TFS(&tfs_2b_enabled), 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_se_2b_fl_unavail,\r\n{ "Reading/status unavailable",\r\n"ipmi.se2b.fl_unavail", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_sensor,\r\n{ "Sensor Number",\r\n"ipmi.se2d.sensor", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_reading,\r\n{ "Sensor Reading",\r\n"ipmi.se2d.reading", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_b1_7,\r\n{ "Reserved / State 7 asserted",\r\n"ipmi.se2d.b1_7", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_b1_6,\r\n{ "Reserved / State 6 asserted",\r\n"ipmi.se2d.b1_6", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_b1_5,\r\n{ "At or above UNR threshold / State 5 asserted",\r\n"ipmi.se2d.b1_5", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_b1_4,\r\n{ "At or above UC threshold / State 4 asserted",\r\n"ipmi.se2d.b1_4", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_b1_3,\r\n{ "At or above UNC threshold / State 3 asserted",\r\n"ipmi.se2d.b1_3", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_b1_2,\r\n{ "At or below LNR threshold / State 2 asserted",\r\n"ipmi.se2d.b1_2", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_b1_1,\r\n{ "At or below LC threshold / State 1 asserted",\r\n"ipmi.se2d.b1_1", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_b1_0,\r\n{ "At or below LNC threshold / State 0 asserted",\r\n"ipmi.se2d.b1_0", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_b2_6,\r\n{ "Reserved / State 14 asserted",\r\n"ipmi.se2d.b1_6", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_b2_5,\r\n{ "Reserved / State 13 asserted",\r\n"ipmi.se2d.b1_5", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_b2_4,\r\n{ "Reserved / State 12 asserted",\r\n"ipmi.se2d.b1_4", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_b2_3,\r\n{ "Reserved / State 11 asserted",\r\n"ipmi.se2d.b1_3", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_b2_2,\r\n{ "Reserved / State 10 asserted",\r\n"ipmi.se2d.b1_2", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_b2_1,\r\n{ "Reserved / State 9 asserted",\r\n"ipmi.se2d.b1_1", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_se_2d_b2_0,\r\n{ "Reserved / State 8 asserted",\r\n"ipmi.se2d.b1_0", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_2e_sensor,\r\n{ "Sensor number",\r\n"ipmi.se2e.sensor", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_2e_stype,\r\n{ "Sensor type",\r\n"ipmi.se2e.stype", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_2e_evtype,\r\n{ "Event/Reading type",\r\n"ipmi.se2e.evtype", FT_UINT8, BASE_HEX|BASE_RANGE_STRING, RVALS(evtype_rvals), 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_2f_sensor,\r\n{ "Sensor number",\r\n"ipmi.se2f.sensor", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_2f_stype,\r\n{ "Sensor type",\r\n"ipmi.se2f.stype", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_se_2f_evtype,\r\n{ "Event/Reading type",\r\n"ipmi.se2f.evtype", FT_UINT8, BASE_HEX|BASE_RANGE_STRING, RVALS(evtype_rvals), 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_se_evt_trigger_reading, { "Trigger reading", "ipmi.evt.trigger_reading", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_evt_trigger_threshold, { "Trigger threshold", "ipmi.evt.trigger_threshold", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_pst_severity, { "Severity", "ipmi.pst.severity", FT_UINT8, BASE_HEX, VALS(etoff_07), 0xF0, NULL, HFILL }},\r\n{ &hf_ipmi_se_pst_previous_state, { "Previous state", "ipmi.pst.previous_state", FT_UINT8, BASE_HEX, NULL, 0x0F, NULL, HFILL }},\r\n{ &hf_ipmi_se_05_network_controller, { "Network controller #", "ipmi.se05.network_controller", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_08_error_type, { "Error type", "ipmi.se08.error_type", FT_UINT8, BASE_HEX, VALS(ssi_08_3_err_vals), 0x0F, NULL, HFILL }},\r\n{ &hf_ipmi_se_0c_memory_module, { "Memory module/device ID", "ipmi.se0c.memory_module", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_0f_extension_code_err, { "Extension code", "ipmi.se0f.extension_code", FT_UINT8, BASE_HEX, VALS(ssi_0f_2_err_vals), 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_0f_extension_code_progress, { "Extension code", "ipmi.se0f.extension_code", FT_UINT8, BASE_HEX, VALS(ssi_0f_2_progress_vals), 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_10_memory_module, { "Memory module/device ID", "ipmi.se10.memory_module", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_10_logging_disable, { "Logging disable for all events of given type", "ipmi.se10.logging_disable", FT_BOOLEAN, 8, TFS(&tfs_true_false), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_se_10_event, { "Event", "ipmi.se10.event", FT_BOOLEAN, 8, TFS(&tfs_deassertion_assertion), 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_se_10_event_offset, { "Event Offset", "ipmi.se10.event_offset", FT_UINT8, BASE_HEX, NULL, 0x0F, NULL, HFILL }},\r\n{ &hf_ipmi_se_10_sel_filled, { "SEL filled (%)", "ipmi.se10.sel_filled", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_12_log_entry_action, { "Log entry action", "ipmi.se12.log_entry_action", FT_UINT8, BASE_HEX, VALS(ssi_12_2_act_vals), 0xF0, NULL, HFILL }},\r\n{ &hf_ipmi_se_12_log_type, { "Log type", "ipmi.se12.log_type", FT_UINT8, BASE_HEX, VALS(ssi_12_2_type_vals), 0x0F, NULL, HFILL }},\r\n{ &hf_ipmi_se_12_diagnostic_interrupt, { "Diagnostic interrupt (NMI)", "ipmi.se12.diagnostic_interrupt", FT_BOOLEAN, 8, TFS(&tfs_true_false), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_se_12_oem_action, { "OEM Action", "ipmi.se12.oem_action", FT_BOOLEAN, 8, TFS(&tfs_true_false), 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_se_12_power_cycle, { "Power Cycle", "ipmi.se12.power_cycle", FT_BOOLEAN, 8, TFS(&tfs_true_false), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_se_12_reset, { "Reset", "ipmi.se12.reset", FT_BOOLEAN, 8, TFS(&tfs_true_false), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_se_12_power_off, { "Power Off", "ipmi.se12.power_off", FT_BOOLEAN, 8, TFS(&tfs_true_false), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_se_12_alert, { "Alert", "ipmi.se12.alert", FT_BOOLEAN, 8, TFS(&tfs_true_false), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_12_event, { "Event", "ipmi.se12.event", FT_BOOLEAN, 8, TFS(&tfs_second_first_pair), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_se_12_timestamp_clock_type, { "Timestamp clock type", "ipmi.se12.timestamp_clock_type", FT_UINT8, BASE_HEX, VALS(ssi_12_2_clock_vals), 0x0F, NULL, HFILL }},\r\n{ &hf_ipmi_se_19_requested_power_state, { "Requested power state", "ipmi.se19.requested_power_state", FT_UINT8, BASE_HEX, VALS(ssoff_22), 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_19_power_state, { "Power state at time of request", "ipmi.se19.power_state", FT_UINT8, BASE_HEX, VALS(ssoff_22), 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_1d_restart_cause, { "Restart cause", "ipmi.se1d.restart_cause", FT_UINT8, BASE_HEX, VALS(ssi_1d_2_cause_vals), 0x0F, NULL, HFILL }},\r\n{ &hf_ipmi_se_1d_channel, { "Channel", "ipmi.se1d.channel", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_21_slot_connector_type, { "Slot/connector type", "ipmi.se21.slot_connector_type", FT_UINT8, BASE_HEX, VALS(ssi_21_2_type_vals), 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_21_slot_connector, { "Slot/connector #", "ipmi.se21.slot_connector", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_23_interrupt_type, { "Interrupt type", "ipmi.se23.interrupt_type", FT_UINT8, BASE_HEX, VALS(ssi_23_2_intr_vals), 0xF0, NULL, HFILL }},\r\n{ &hf_ipmi_se_23_timer_use_at_expiration, { "Timer use at expiration", "ipmi.se23.timer_use_at_expiration", FT_UINT8, BASE_HEX, VALS(ssi_23_2_use_vals), 0x0F, NULL, HFILL }},\r\n{ &hf_ipmi_se_28_sensor_number, { "Sensor number", "ipmi.se28.sensor_number", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_28_logical_fru_device, { "Logical FRU device", "ipmi.se28.logical_fru_device", FT_BOOLEAN, 8, TFS(&tfs_true_false), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_se_28_lun_for_master_read_write_command, { "LUN for Master Read-Write command", "ipmi.se28.lun_for_master_read_write_command", FT_UINT8, BASE_HEX, NULL, 0x18, NULL, HFILL }},\r\n{ &hf_ipmi_se_28_private_bus_id, { "Private Bus ID", "ipmi.se28.private_bus_id", FT_UINT8, BASE_HEX, NULL, 0x07, NULL, HFILL }},\r\n{ &hf_ipmi_se_28_fru_device_id_within_controller, { "FRU Device ID within controller", "ipmi.se28.fru_device_id_within_controller", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_28_i2c_slave_address, { "I2C Slave Address", "ipmi.se28.i2c_slave_address", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_2a_user_id, { "User ID", "ipmi.se2a.user_id", FT_UINT8, BASE_DEC, NULL, 0x3F, NULL, HFILL }},\r\n{ &hf_ipmi_se_2a_session_deactivated_by, { "Session deactivated by", "ipmi.se2a.session_deactivated_by", FT_UINT8, BASE_HEX, VALS(ssi_2a_3_deact_vals), 0x30, NULL, HFILL }},\r\n{ &hf_ipmi_se_2a_channel, { "Channel", "ipmi.se2a.channel", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0F, NULL, HFILL }},\r\n{ &hf_ipmi_se_2b_version_change_type, { "Version change type", "ipmi.se2b.version_change_type", FT_UINT8, BASE_DEC, VALS(ssi_2b_2_vctype_vals), 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_2c_cause, { "Cause", "ipmi.se2c.cause", FT_UINT8, BASE_HEX, VALS(ssi_2c_2_cause_vals), 0xF0, NULL, HFILL }},\r\n{ &hf_ipmi_se_2c_previous_state, { "Previous state", "ipmi.se2c.previous_state", FT_UINT8, BASE_HEX, NULL, 0x0F, NULL, HFILL }},\r\n{ &hf_ipmi_se_f0_cause, { "Cause", "ipmi.sef0.cause", FT_UINT8, BASE_HEX, VALS(ssi_f0_2_cause_vals), 0xF0, NULL, HFILL }},\r\n{ &hf_ipmi_se_f0_previous_state, { "Previous state", "ipmi.sef0.previous_state", FT_UINT8, BASE_HEX, NULL, 0x0F, NULL, HFILL }},\r\n{ &hf_ipmi_se_f0_fru_id, { "FRU Id", "ipmi.sef0.fru_id", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_f1_channel, { "Channel", "ipmi.sef1.channel", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0xF0, NULL, HFILL }},\r\n{ &hf_ipmi_se_f1_ipmb_b_override_state, { "IPMB-B Override state", "ipmi.sef1.ipmb_b_override_state", FT_BOOLEAN, 8, TFS(&tfs_f1_3_override_state), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_se_f1_ipmb_b_local_status, { "IPMB-B Local status", "ipmi.sef1.ipmb_b_local_status", FT_UINT8, BASE_HEX, VALS(ssi_f1_3_status_vals), 0x70, NULL, HFILL }},\r\n{ &hf_ipmi_se_f1_ipmb_a_override_state, { "IPMB-A Override state", "ipmi.sef1.ipmb_a_override_state", FT_BOOLEAN, 8, TFS(&tfs_f1_3_override_state), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_se_f1_ipmb_a_local_status, { "IPMB-A Local status", "ipmi.sef1.ipmb_a_local_status", FT_UINT8, BASE_HEX, VALS(ssi_f1_3_status_vals), 0x07, NULL, HFILL }},\r\n{ &hf_ipmi_se_f3_global_status, { "Global Status", "ipmi.sef3.global_status", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_f3_redundant_pm, { "Redundant PM", "ipmi.sef3.redundant_pm", FT_BOOLEAN, 8, TFS(&tfs_provide_not_provide_payload_current), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_se_f3_gs_payload_power, { "Payload Power", "ipmi.sef3.payload_power", FT_BOOLEAN, 8, TFS(&tfs_is_good_not_good), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_se_f3_gs_management_power, { "Management Power", "ipmi.sef3.management_power", FT_BOOLEAN, 8, TFS(&tfs_is_good_not_good), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_se_f3_role, { "Role", "ipmi.sef3.role", FT_BOOLEAN, 8, TFS(&tfs_primary_redundant), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_f3_channel_status, { "Channel Status", "ipmi.sef3.channel_status", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_f3_pwr_on, { "PWR_ON", "ipmi.sef3.pwr_on", FT_BOOLEAN, 8, TFS(&tfs_asserted_not_asserted), 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_se_f3_payload_power_overcurrent, { "Payload Power Overcurrent", "ipmi.sef3.payload_power_overcurrent", FT_BOOLEAN, 8, TFS(&tfs_detected_not_detected), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_se_f3_channel_payload_power, { "Payload Power", "ipmi.sef3.payload_power", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_se_f3_enable, { "ENABLE#", "ipmi.sef3.enable", FT_BOOLEAN, 8, TFS(&tfs_asserted_not_asserted), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_se_f3_management_power_overcurrent, { "Management Power Overcurrent", "ipmi.sef3.management_power_overcurrent", FT_BOOLEAN, 8, TFS(&tfs_detected_not_detected), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_se_f3_channel_management_power, { "Management Power", "ipmi.sef3.management_power", FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_se_f3_ps1, { "PS1#", "ipmi.sef3.ps1", FT_BOOLEAN, 8, TFS(&tfs_asserted_not_asserted), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_se_f3_power_channel_number, { "Power Channel number", "ipmi.sef3.power_channel_number", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_se_13_parameter, { "Parameter", "ipmi.se13.parameter", FT_UINT8, BASE_DEC, NULL, 0x7F, NULL, HFILL }},\r\n{ &hf_ipmi_se_23_m, { "M", "ipmi.se23.m", FT_UINT16, BASE_HEX, NULL, 0xFFC0, NULL, HFILL }},\r\n{ &hf_ipmi_se_23_tolerance, { "Tolerance", "ipmi.se23.tolerance", FT_UINT16, BASE_DEC, NULL, 0x003F, NULL, HFILL }},\r\n{ &hf_ipmi_se_23_b, { "B", "ipmi.se23.b", FT_UINT16, BASE_HEX, NULL, 0xFFC0, NULL, HFILL }},\r\n{ &hf_ipmi_se_23_accuracy, { "Accuracy", "ipmi.se23.accuracy", FT_UINT16, BASE_DEC, NULL, 0x3FF0, NULL, HFILL }},\r\n{ &hf_ipmi_se_23_accuracy_exponent, { "Accuracy exponent", "ipmi.se23.accuracy_exponent", FT_UINT8, BASE_DEC, NULL, 0x0C, NULL, HFILL }},\r\n{ &hf_ipmi_se_23_r_exponent, { "R exponent", "ipmi.se23.r_exponent", FT_UINT8, BASE_DEC, NULL, 0xF0, NULL, HFILL }},\r\n{ &hf_ipmi_se_23_b_exponent, { "B exponent", "ipmi.se23.b_exponent", FT_UINT8, BASE_DEC, NULL, 0x0F, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ipmi_se_evt_byte3,\r\n&ett_ipmi_se_evt_evd_byte1,\r\n&ett_ipmi_se_evt_evd_byte2,\r\n&ett_ipmi_se_evt_evd_byte3,\r\n&ett_ipmi_se_cp06_byte1,\r\n&ett_ipmi_se_cp07_byte1,\r\n&ett_ipmi_se_cp09_byte1,\r\n&ett_ipmi_se_cp10_byte1,\r\n&ett_ipmi_se_cp12_byte1,\r\n&ett_ipmi_se_cp12_byte2,\r\n&ett_ipmi_se_cp12_byte3,\r\n&ett_ipmi_se_cp13_byte1,\r\n&ett_ipmi_se_cp15_byte1,\r\n&ett_ipmi_se_cp15_byte2,\r\n&ett_ipmi_se_cp15_member,\r\n&ett_ipmi_se_cp15_byte11,\r\n&ett_ipmi_se_00_byte2,\r\n&ett_ipmi_se_01_byte2,\r\n&ett_ipmi_se_10_action,\r\n&ett_ipmi_se_12_byte1,\r\n&ett_ipmi_se_13_byte1,\r\n&ett_ipmi_se_13_rev,\r\n&ett_ipmi_se_14_byte1,\r\n&ett_ipmi_se_16_byte1,\r\n&ett_ipmi_se_16_byte2,\r\n&ett_ipmi_se_16_byte3,\r\n&ett_ipmi_se_20_rq_byte1,\r\n&ett_ipmi_se_20_rs_byte2,\r\n&ett_ipmi_se_23_readingfactors,\r\n&ett_ipmi_se_23_byte1,\r\n&ett_ipmi_se_23_byte2,\r\n&ett_ipmi_se_23_byte3,\r\n&ett_ipmi_se_23_byte4,\r\n&ett_ipmi_se_23_byte5,\r\n&ett_ipmi_se_23_byte6,\r\n&ett_ipmi_se_XX_mask,\r\n&ett_ipmi_se_XX_b1,\r\n&ett_ipmi_se_XX_b2,\r\n&ett_ipmi_se_XX_b3,\r\n&ett_ipmi_se_XX_b4,\r\n&ett_ipmi_se_28_byte2,\r\n&ett_ipmi_se_29_byte1,\r\n&ett_ipmi_se_2a_byte2,\r\n&ett_ipmi_se_2b_byte1,\r\n&ett_ipmi_se_2d_byte2,\r\n&ett_ipmi_se_2d_b1,\r\n&ett_ipmi_se_2d_b2,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_ipmi_se_13_request_param_rev, { "ipmi.se13.request_param_rev", PI_PROTOCOL, PI_NOTE, "Requested parameter revision; parameter data returned", EXPFILL }},\r\n{ &ei_ipmi_se_13_request_param_data, { "ipmi.se13.mrequest_param_data", PI_PROTOCOL, PI_NOTE, "Requested parameter data; only parameter version returned", EXPFILL }},\r\n};\r\nexpert_module_t* expert_ipmi_se;\r\nproto_register_field_array(proto_ipmi, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_ipmi_se = expert_register_protocol(proto_ipmi);\r\nexpert_register_field_array(expert_ipmi_se, ei, array_length(ei));\r\nipmi_register_netfn_cmdtab(IPMI_SE_REQ, IPMI_OEM_NONE, NULL, 0, NULL,\r\ncmd_se, array_length(cmd_se));\r\n}
