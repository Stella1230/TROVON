guint get_service_type( void )\r\n{\r\nreturn scheduling_service_type;\r\n}\r\nstatic void set_service_type( guint set_to )\r\n{\r\nif( seen_a_service_type == 0 ){\r\nscheduling_service_type = set_to;\r\nseen_a_service_type = 1;\r\n}\r\n}\r\nvoid proto_register_wimax_utility_decoders(void)\r\n{\r\nstatic hf_register_info hf_sfe[] =\r\n{\r\n{\r\n&hf_sfe_sf_id,\r\n{"Service Flow ID", "wmx.sfe.sf_id", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_cid,\r\n{"CID", "wmx.sfe.cid", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_service_class_name,\r\n{"Service Class Name", "wmx.sfe.service_class_name", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_mbs_service,\r\n{"MBS Service", "wmx.sfe.mbs_service", FT_UINT8, BASE_DEC, VALS(vals_mbs_service), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_qos_params_set,\r\n{"QoS Parameter Set Type", "wmx.sfe.qos_params_set", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_set_provisioned,\r\n{"Provisioned Set", "wmx.sfe.qos_params_set.provisioned", FT_BOOLEAN, 8, NULL, SFE_QOS_PARAMS_SET_PROVISIONED_SET, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_set_admitted,\r\n{"Admitted Set", "wmx.sfe.qos_params_set.admitted", FT_BOOLEAN, 8, NULL, SFE_QOS_PARAMS_SET_ADMITTED_SET, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_set_active,\r\n{"Active Set", "wmx.sfe.qos_params_set.active", FT_BOOLEAN, 8, NULL, SFE_QOS_PARAMS_SET_ACTIVE_SET, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_set_rsvd,\r\n{"Reserved", "wmx.sfe.qos_params_set.rsvd", FT_UINT8, BASE_HEX, NULL, SFE_QOS_PARAMS_SET_RESERVED, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_traffic_priority,\r\n{"Traffic Priority", "wmx.sfe.traffic_priority", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_max_str,\r\n{"Maximum Sustained Traffic Rate", "wmx.sfe.msr", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_max_traffic_burst,\r\n{"Maximum Traffic Burst", "wmx.sfe.max_traffic_burst", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_min_rtr,\r\n{"Minimum Reserved Traffic Rate", "wmx.sfe.mrr", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_reserved_10,\r\n{"Reserved", "wmx.sfe.reserved_10", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n#if 0\r\n{\r\n&hf_sfe_mtr,\r\n{"Minimum tolerable traffic rate", "wmx.sfe.mtr", FT_UINT32, BASE_HEX, NULL, 0x0, "", HFILL}\r\n},\r\n#endif\r\n{\r\n&hf_sfe_ul_grant_scheduling,\r\n{"Uplink Grant Scheduling Type", "wmx.sfe.uplink_grant_scheduling", FT_UINT8, BASE_DEC, VALS(vals_ul_grant_scheduling), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_req_tx_policy,\r\n{"Request/Transmission Policy", "wmx.sfe.req_tx_policy", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_policy_broadcast_bwr,\r\n{"The Service Flow Shall Not Use Broadcast Bandwidth Request Opportunities", "wmx.sfe.policy.broadcast_bwr", FT_BOOLEAN, 8, NULL, SFE_REQ_TX_POLICY_BROADCAST_BWR, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_policy_multicast_bwr,\r\n{"The Service Flow Shall Not Use Multicast Bandwidth Request Opportunities", "wmx.sfe.policy.bit1", FT_BOOLEAN, 8, NULL, SFE_REQ_TX_POLICY_MULTICAST_BWR, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_policy_piggyback,\r\n{"The Service Flow Shall Not Piggyback Requests With Data", "wmx.sfe.policy.piggyback", FT_BOOLEAN, 8, NULL, SFE_REQ_TX_POLICY_PIGGYBACK, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_policy_fragment,\r\n{"The Service Flow Shall Not Fragment Data", "wmx.sfe.policy.fragment", FT_BOOLEAN, 8, NULL, SFE_REQ_TX_POLICY_FRAGMENT_DATA, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_policy_headers,\r\n{"The Service Flow Shall Not Suppress Payload Headers", "wmx.sfe.policy.headers", FT_BOOLEAN, 8, NULL, SFE_REQ_TX_POLICY_PAYLOAD_HEADER, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_policy_packing,\r\n{"The Service Flow Shall Not Pack Multiple SDUs (Or Fragments) Into Single MAC PDUs", "wmx.sfe.policy.packing", FT_BOOLEAN, 8, NULL, SFE_REQ_TX_POLICY_PACKINGS, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_policy_crc,\r\n{"The Service Flow Shall Not Include CRC In The MAC PDU", "wmx.sfe.policy.crc", FT_BOOLEAN, 8, NULL, SFE_REQ_TX_POLICY_CRC, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_policy_rsvd1,\r\n{"Reserved", "wmx.sfe.policy.rsvd1", FT_UINT8, BASE_HEX, NULL, SFE_REQ_TX_POLICY_RESERVED, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_jitter,\r\n{"Tolerated Jitter", "wmx.sfe.jitter", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_max_latency,\r\n{"Maximum Latency", "wmx.sfe.max_latency", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_fixed_len_sdu,\r\n{"Fixed/Variable Length SDU", "wmx.sfe.fixed_len_sdu", FT_UINT8, BASE_DEC, VALS(vals_fixed_len_sdu), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_sdu_size,\r\n{"SDU Size", "wmx.sfe.sdu_size", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_target_said,\r\n{"SAID Onto Which SF Is Mapped", "wmx.sfe.target_said", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_arq_enable,\r\n{"ARQ Enable", "wmx.arq.enable", FT_UINT8, BASE_DEC, VALS(vals_arq_enable), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_arq_window_size,\r\n{"ARQ Window Size", "wmx.arq.window_size", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_arq_transmitter_delay,\r\n{"ARQ Transmitter Delay (10us granularity)", "wmx.arq.transmitter_delay", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_arq_receiver_delay,\r\n{"ARQ Receiver Delay (10us granularity)", "wmx.arq.receiver_delay", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_arq_block_lifetime,\r\n{"ARQ Block Lifetime (10us granularity)", "wmx.arq.block_lifetime", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_arq_sync_loss_timeout,\r\n{"ARQ Sync Loss Timeout (10us granularity)", "wmx.arq.sync_loss_timeout", FT_UINT16, BASE_DEC, VALS(vals_arq_sync_loss_timeout), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_arq_transmitter_delay_cor2,\r\n{"ARQ Transmitter Delay (100us granularity)", "wmx.arq.transmitter_delay", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_arq_receiver_delay_cor2,\r\n{"ARQ Receiver Delay (100us granularity)", "wmx.arq.receiver_delay", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_arq_block_lifetime_cor2,\r\n{"ARQ Block Lifetime (100us granularity)", "wmx.arq.block_lifetime", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_arq_sync_loss_timeout_cor2,\r\n{"ARQ Sync Loss Timeout (100us granularity)", "wmx.arq.sync_loss_timeout", FT_UINT16, BASE_DEC, VALS(vals_arq_sync_loss_timeout), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_arq_deliver_in_order,\r\n{"ARQ Deliver In Order", "wmx.arq.deliver_in_order", FT_UINT8, BASE_DEC, VALS(vals_arq_deliver_in_order), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_arq_rx_purge_timeout,\r\n{"ARQ RX Purge Timeout (100us granularity)", "wmx.arq.rx_purge_timeout", FT_UINT16, BASE_DEC, VALS(vals_arq_rx_purge_timeout), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_arq_block_size,\r\n{"ARQ Block Size", "wmx.arq.block_size", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_arq_block_size_cor2,\r\n{"ARQ Block Size", "wmx.arq.block_size", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_arq_min_block_size,\r\n{"ARQ Minimum Block Size", "wmx.arq.min_block_size", FT_UINT8, BASE_DEC, NULL, 0x0F, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_arq_max_block_size,\r\n{"ARQ Maximum Block Size", "wmx.arq.max_block_size", FT_UINT8, BASE_DEC, NULL, 0xF0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_cs_specification,\r\n{"CS Specification", "wmx.sfe.cs_specification", FT_UINT8, BASE_DEC, VALS(vals_cs_specification), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_type_of_data_delivery_services,\r\n{"Type of Data Delivery Services", "wmx.sfe.type_of_data_delivery_services", FT_UINT8, BASE_DEC, VALS(vals_type_of_data_delivery_services), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_sdu_inter_arrival_interval,\r\n{"SDU Inter-Arrival Interval (in the resolution of 0.5 ms)", "wmx.sfe.sdu_inter_arrival_interval", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_time_base,\r\n{"Time Base", "wmx.sfe.time_base", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_paging_preference,\r\n{"Paging Preference", "wmx.sfe.paging_preference", FT_UINT8, BASE_DEC, VALS(vals_paging_preference), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_mbs_zone_identifier_assignment,\r\n{"MBS Zone Identifier", "wmx.sfe.mbs_zone_identifier", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_reserved_34,\r\n{"Reserved", "wmx.sfe.reserved_34", FT_UINT8, BASE_DEC, NULL , 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_global_service_class_name,\r\n{"Global Service Class Name", "wmx.sfe.global_service_class_name", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_reserved_36,\r\n{"Reserved", "wmx.sfe.reserved_36", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_sn_feedback_enabled,\r\n{"SN Feedback", "wmx.sfe.sn_feedback_enabled", FT_UINT8, BASE_DEC, VALS(vals_sn_fb_enable), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_fsn_size,\r\n{"FSN Size", "wmx.sfe.fsn_size", FT_UINT8, BASE_DEC, VALS(vals_fsn_size), 0x0, NULL, HFILL}\r\n},\r\n#if 0\r\n{\r\n&hf_sfe_cid_alloc_for_active_bs,\r\n{"CID Allocation For Active BSs", "wmx.sfe.cid_alloc_for_active_bs", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n#endif\r\n{\r\n&hf_sfe_cid_alloc_for_active_bs_cid,\r\n{"CID", "wmx.sfe.cid_alloc_for_active_bs_cid", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_unsolicited_grant_interval,\r\n{"Unsolicited Grant Interval", "wmx.sfe.unsolicited_grant_interval", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_unsolicited_polling_interval,\r\n{"Unsolicited Polling Interval", "wmx.sfe.unsolicited_polling_interval", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_pdu_sn_ext_subheader_reorder,\r\n{"PDU SN Extended Subheader For HARQ Reordering", "wmx.sfe.pdu_sn_ext_subheader_reorder", FT_UINT8, BASE_DEC, VALS(vals_pdu_sn_ext_subheader), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_mbs_contents_ids,\r\n{"MBS contents IDs", "wmx.sfe.mbs_contents_ids", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_mbs_contents_ids_id,\r\n{"MBS Contents ID", "wmx.sfe.mbs_contents_ids_id", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_harq_service_flows,\r\n{"HARQ Service Flows", "wmx.sfe.harq_service_flows", FT_UINT8, BASE_DEC, VALS(vals_harq), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_authorization_token,\r\n{"Authorization Token", "wmx.sfe.authorization_token", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n#if 0\r\n{\r\n&hf_sfe_harq_channel_mapping,\r\n{"HARQ Channel Mapping", "wmx.sfe.harq_channel_mapping", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n#endif\r\n{\r\n&hf_sfe_harq_channel_mapping_index,\r\n{"HARQ Channel Index", "wmx.sfe.harq_channel_mapping.index", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_sfe_unknown_type,\r\n{"Unknown SFE TLV type", "wmx.sfe.unknown_type", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n}\r\n};\r\nstatic hf_register_info hf_csper[] =\r\n{\r\n{\r\n&hf_cst_classifier_dsc_action,\r\n{"Classifier DSC Action", "wmx.cst.classifier_action", FT_UINT8, BASE_DEC, VALS(vals_cst_classifier_action), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_error_set_errored_param,\r\n{"Errored Parameter", "wmx.cst.error_set.errored_param", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_error_set_error_code,\r\n{"Error Code", "wmx.cst.error_set.error_code", FT_UINT8, BASE_HEX, VALS(vals_cc), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_error_set_error_msg,\r\n{"Error Message", "wmx.cst.error_set.error_msg", FT_STRINGZ, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule,\r\n{"Packet Classification Rule", "wmx.cst.pkt_class_rule", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_priority,\r\n{"Classification Rule Priority", "wmx.cst.pkt_class_rule.priority", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_range_mask,\r\n{"ToS/Differentiated Services Codepoint (DSCP) Range And Mask", "wmx.cst.pkt_class_rule.range_mask", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_tos_low,\r\n{"ToS-Low", "wmx.cst.pkt_class_rule.tos-low", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_tos_high,\r\n{"ToS-High", "wmx.cst.pkt_class_rule.tos-high", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_tos_mask,\r\n{"ToS-Mask", "wmx.cst.pkt_class_rule.tos-mask", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_protocol,\r\n{"Protocol", "wmx.cst.pkt_class_rule.protocol", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n#if 0\r\n{\r\n&hf_cst_pkt_class_rule_protocol,\r\n{"Protocol", "wmx.cst.pkt_class_rule.protocol", FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_protocol_number,\r\n{"Protocol Number", "wmx.cst.pkt_class_rule.protocol.number", FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL}\r\n},\r\n#endif\r\n{\r\n&hf_cst_pkt_class_rule_ip_masked_src_address,\r\n{"IP Masked Source Address", "wmx.cst.pkt_class_rule.ip_masked_src_address", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_ip_masked_dest_address,\r\n{"IP Masked Destination Address", "wmx.cst.pkt_class_rule.ip_masked_dest_address", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_src_ipv4,\r\n{"IPv4 Source Address", "wmx.cst.pkt_class_rule.src_ipv4", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_dest_ipv4,\r\n{"IPv4 Destination Address", "wmx.cst.pkt_class_rule.dst_ipv4", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_mask_ipv4,\r\n{"IPv4 Mask", "wmx.cst.pkt_class_rule.mask_ipv4", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_src_ipv6,\r\n{"IPv6 Source Address", "wmx.cst.pkt_class_rule.src_ipv6", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_dest_ipv6,\r\n{"IPv6 Destination Address", "wmx.cst.pkt_class_rule.dst_ipv6", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_mask_ipv6,\r\n{"IPv6 Mask", "wmx.cst.pkt_class_rule.mask_ipv6", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_prot_src_port_range,\r\n{"Protocol Source Port Range", "wmx.cst.pkt_class_rule.prot_src_port_range", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_src_port_low,\r\n{"Src-Port Low", "wmx.cst.pkt_class_rule.src_port_low", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_src_port_high,\r\n{"Src-Port High", "wmx.cst.pkt_class_rule.src_port_high", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_prot_dest_port_range,\r\n{"Protocol Destination Port Range", "wmx.cst.pkt_class_rule.prot_dest_port_range", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_dest_port_low,\r\n{"Dst-Port Low", "wmx.cst.pkt_class_rule.dst_port_low", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_dest_port_high,\r\n{"Dst-Port High", "wmx.cst.pkt_class_rule.dst_port_high", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_dest_mac_address,\r\n{"802.3/Ethernet Destination MAC Address", "wmx.cst.pkt_class_rule.dest_mac_address", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_dest_mac,\r\n{"Destination MAC Address", "wmx.cst.pkt_class_rule.dst_mac", FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_src_mac_address,\r\n{"802.3/Ethernet Source MAC Address", "wmx.cst.pkt_class_rule.src_mac_address", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_src_mac,\r\n{"Source MAC Address", "wmx.cst.pkt_class_rule.src_mac", FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_mask_mac,\r\n{"MAC Address Mask", "wmx.cst.pkt_class_rule.mask_mac", FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_ethertype,\r\n{"Ethertype/IEEE Std 802.2-1998 SAP", "wmx.cst.pkt_class_rule.ethertype", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_etype,\r\n{"Ethertype", "wmx.cst.pkt_class_rule.etype", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_eprot1,\r\n{"Eprot1", "wmx.cst.pkt_class_rule.eprot1", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_eprot2,\r\n{"Eprot2", "wmx.cst.pkt_class_rule.eprot2", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_user_priority,\r\n{"IEEE Std 802.1D-1998 User_Priority", "wmx.cst.pkt_class_rule.user_priority", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_pri_low,\r\n{"Pri-Low", "wmx.cst.pkt_class_rule.pri-low", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_pri_high,\r\n{"Pri-High", "wmx.cst.pkt_class_rule.pri-high", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_vlan_id,\r\n{"IEEE Std 802.1Q-1998 VLAN_ID", "wmx.cst.pkt_class_rule.vlan_id", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_vlan_id1,\r\n{"Vlan_Id1", "wmx.cst.pkt_class_rule.vlan_id1", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_vlan_id2,\r\n{"Vlan_Id2", "wmx.cst.pkt_class_rule.vlan_id2", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_phsi,\r\n{"Associated PHSI", "wmx.cst.pkt_class_rule.phsi", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_index,\r\n{"Packet Classifier Rule Index (PCRI)", "wmx.cst.pkt_class_rule.index", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_large_context_id,\r\n{"Large Context ID", "wmx.cst.large_context_id", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_short_format_context_id,\r\n{"Short-Format Context ID", "wmx.cst.short_format_context_id", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_vendor_spec,\r\n{"Vendor-Specific Classifier Parameters", "wmx.cst.pkt_class_rule.vendor_spec", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_classifier_action_rule,\r\n{"Classifier Action Rule", "wmx.cst.pkt_class_rule.classifier.action.rule", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_classifier_action_rule_bit0,\r\n{"Bit #0", "wmx.cst.pkt_class_rule.classifier.action.rule.bit0", FT_UINT8, BASE_HEX, VALS(vals_classification_action_rule), CST_PKT_CLASS_RULE_CLASSIFIER_ACTION_RULE_BIT0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_classifier_action_rule_bit1,\r\n{"Reserved", "wmx.cst.pkt_class_rule.classifier.action.rule.reserved", FT_UINT8, BASE_HEX, NULL, CST_PKT_CLASS_RULE_CLASSIFIER_ACTION_RULE_RSV, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_phs_dsc_action,\r\n{"PHS DSC action", "wmx.cst.phs_dsc_action", FT_UINT8, BASE_DEC, VALS(vals_cst_phs_dsc_action), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_phs_rule,\r\n{"PHS Rule", "wmx.cst.phs_rule", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_phs_phsi,\r\n{"PHSI", "wmx.cst.phs_rule.phsi", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_phs_phsf,\r\n{"PHSF", "wmx.cst.phs_rule.phsf", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_phs_phsm,\r\n{"PHSM (bit x: 0-don't suppress the (x+1) byte; 1-suppress the (x+1) byte)", "wmx.cst.phs_rule.phsm", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_phs_phss,\r\n{"PHSS", "wmx.cst.phs_rule.phss", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_phs_phsv,\r\n{"PHSV", "wmx.cst.phs_rule.phsv", FT_UINT8, BASE_DEC, VALS(vals_verify), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_phs_vendor_spec,\r\n{"Vendor-Specific PHS Parameters", "wmx.cst.phs.vendor_spec", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_pkt_class_rule_ipv6_flow_label,\r\n{"IPv6 Flow Label", "wmx.cst.pkt_class_rule.ipv6_flow_label", FT_UINT24, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_csper_atm_switching_encoding,\r\n{"ATM Switching Encoding", "wmx.csper.atm_switching_encoding", FT_UINT8, BASE_DEC, VALS(vals_atm_switching_encodings), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_csper_atm_classifier,\r\n{"ATM Classifier TLV", "wmx.csper.atm_classifier", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_csper_atm_classifier_vpi,\r\n{"VPI Classifier", "wmx.csper.atm_classifier_vpi", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_csper_atm_classifier_vci,\r\n{"VCI Classifier", "wmx.csper.atm_classifier_vci", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_csper_atm_classifier_id,\r\n{"Classifier ID", "wmx.csper.atm_classifier_tlv", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_csper_unknown_type,\r\n{"Unknown CSPER TLV type", "wmx.csper.unknown_type", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cst_invalid_tlv,\r\n{"Invalid TLV", "wmx.cst.invalid_tlv", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n}\r\n};\r\nstatic hf_register_info hf_xmac[] =\r\n{\r\n{\r\n&hf_xmac_tuple_rsvd,\r\n{"Reserved", "wmx.xmac_tuple.reserved", FT_UINT8, BASE_HEX, NULL, XMAC_TUPLE_RESERVED, NULL, HFILL}\r\n},\r\n{\r\n&hf_xmac_tuple_key_seq_num,\r\n{"Key Sequence Number", "wmx.xmac_tuple.key_sn", FT_UINT8, BASE_DEC, NULL, XMAC_TUPLE_KEY_SEQ_NUM, NULL, HFILL}\r\n},\r\n{\r\n&hf_hmac_tuple_hmac_digest,\r\n{"HMAC Digest", "wmx.xmac_tuple.hmac_digest", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cmac_tuple_bsid,\r\n{"BSID", "wmx.cmac_tuple.bsid", FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_cmac_tuple_cmac_value,\r\n{"CMAC Value", "wmx.cmac_tuple.cmac.value", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_packet_number_counter,\r\n{"Packet Number Counter", "wmx.xmac_tuple.packet_number_count", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n}\r\n};\r\nstatic hf_register_info hf_snp[] =\r\n{\r\n{\r\n&hf_snp_pkm_version_support,\r\n{"PKM Version Support", "wmx.security_negotiation_parameters.pkm_version_support",FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_pkm_version_support_bit0,\r\n{"PKM version 1", "wmx.security_negotiation_parameters.pkm_version_support.bit0",FT_BOOLEAN, 8, TFS(&tfs_supported), SNP_PKM_VERSION_SUPPORT_BIT0, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_pkm_version_support_bit1,\r\n{"PKM version 2", "wmx.security_negotiation_parameters.pkm_version_support.bit1",FT_BOOLEAN, 8, TFS(&tfs_supported), SNP_PKM_VERSION_SUPPORT_BIT1, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_pkm_version_support_reserved,\r\n{"Reserved", "wmx.security_negotiation_parameters.pkm_version_support.reserved",FT_UINT8, BASE_HEX, NULL, SNP_PKM_VERSION_SUPPORT_RSV, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_auth_policy_support,\r\n{"Authorization Policy Support", "wmx.security_negotiation_parameters.auth_policy_support",FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_auth_policy_support_bit0,\r\n{"RSA-based Authorization At The Initial Network Entry", "wmx.security_negotiation_parameters.auth_policy_support.bit0",FT_BOOLEAN, 8, TFS(&tfs_supported), SNP_AUTH_POLICY_SUPPORT_BIT0, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_auth_policy_support_bit1,\r\n{"EAP-based Authorization At The Initial Network Entry", "wmx.security_negotiation_parameters.auth_policy_support.bit1",FT_BOOLEAN, 8, TFS(&tfs_supported), SNP_AUTH_POLICY_SUPPORT_BIT1, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_auth_policy_support_bit2,\r\n{"Authenticated EAP-based Authorization At The Initial Network Entry", "wmx.security_negotiation_parameters.auth_policy_support.bit2",FT_BOOLEAN, 8, TFS(&tfs_supported), SNP_AUTH_POLICY_SUPPORT_BIT2, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_auth_policy_support_bit3,\r\n{"Reserved", "wmx.security_negotiation_parameters.auth_policy_support.bit3",FT_UINT8, BASE_HEX, NULL, SNP_AUTH_POLICY_SUPPORT_BIT3, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_auth_policy_support_bit4,\r\n{"RSA-based Authorization At Re-entry", "wmx.security_negotiation_parameters.auth_policy_support.bit4",FT_BOOLEAN, 8, TFS(&tfs_supported), SNP_AUTH_POLICY_SUPPORT_BIT4, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_auth_policy_support_bit5,\r\n{"EAP-based Authorization At Re-entry", "wmx.security_negotiation_parameters.auth_policy_support.bit5",FT_BOOLEAN, 8, TFS(&tfs_supported), SNP_AUTH_POLICY_SUPPORT_BIT5, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_auth_policy_support_bit6,\r\n{"Authenticated EAP-based Authorization At Re-entry", "wmx.security_negotiation_parameters.auth_policy_support.bit6",FT_BOOLEAN, 8, TFS(&tfs_supported), SNP_AUTH_POLICY_SUPPORT_BIT6, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_auth_policy_support_bit7,\r\n{"Reserved", "wmx.security_negotiation_parameters.auth_policy_support.bit7",FT_UINT8, BASE_HEX, NULL, SNP_AUTH_POLICY_SUPPORT_BIT7, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_mac_mode,\r\n{"MAC (Message Authentication Code) Mode", "wmx.security_negotiation_parameters.mac_mode",FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_mac_mode_bit0,\r\n{"HMAC", "wmx.security_negotiation_parameters.mac_mode.bit0",FT_BOOLEAN, 8, TFS(&tfs_supported), SNP_MAC_MODE_BIT0, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_mac_mode_bit1,\r\n{"CMAC", "wmx.security_negotiation_parameters.mac_mode.bit1",FT_BOOLEAN, 8, TFS(&tfs_supported), SNP_MAC_MODE_BIT1, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_mac_mode_bit1_rsvd,\r\n{"Reserved", "wmx.security_negotiation_parameters.mac_mode.bit1_rsvd",FT_BOOLEAN, 8, TFS(&tfs_supported), SNP_MAC_MODE_BIT1, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_mac_mode_bit2,\r\n{"64-bit Short-HMAC", "wmx.security_negotiation_parameters.mac_mode.bit2",FT_BOOLEAN, 8, TFS(&tfs_supported), SNP_MAC_MODE_BIT2, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_mac_mode_bit3,\r\n{"80-bit Short-HMAC", "wmx.security_negotiation_parameters.mac_mode.bit3",FT_BOOLEAN, 8, TFS(&tfs_supported), SNP_MAC_MODE_BIT3, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_mac_mode_bit4,\r\n{"96-bit Short-HMAC", "wmx.security_negotiation_parameters.mac_mode.bit4",FT_BOOLEAN, 8, TFS(&tfs_supported), SNP_MAC_MODE_BIT4, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_mac_mode_bit5,\r\n{"CMAC", "wmx.security_negotiation_parameters.mac_mode.bit5",FT_BOOLEAN, 8, TFS(&tfs_supported), SNP_MAC_MODE_BIT5, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_mac_mode_reserved,\r\n{"Reserved", "wmx.security_negotiation_parameters.mac_mode.reserved",FT_UINT8, BASE_HEX, NULL, SNP_MAC_MODE_RSV, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_mac_mode_reserved1,\r\n{"Reserved", "wmx.security_negotiation_parameters.mac_mode.reserved",FT_UINT8, BASE_HEX, NULL, SNP_MAC_MODE_RSV1, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_pn_window_size,\r\n{"PN Window Size", "wmx.security_negotiation_parameters.pn_window_size",FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_max_conc_transactions,\r\n{"Maximum concurrent transactions (0 indicates no limit)", "wmx.security_negotiation_parameters.max_conc_transactions",FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_max_suppt_sec_assns,\r\n{"Maximum number of security associations supported by the SS", "wmx.security_negotiation_parameters.max_suppt_sec_assns",FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_snp_unknown_type,\r\n{"Unknown Security Negotiation Parameter type", "wmx.security_negotiation_parameters.unknown.type",FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n}\r\n};\r\nstatic hf_register_info hf_pkm[] =\r\n{\r\n{\r\n&hf_pkm_msg_attr_display,\r\n{"Display String", "wmx.pkm_msg.pkm_attr.display_string", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_msg_attr_auth_key,\r\n{"Auth Key", "wmx.pkm_msg.pkm_attr.auth_key", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_msg_attr_tek,\r\n{"TEK", "wmx.pkm_msg.pkm_attr.tek", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_msg_attr_key_life_time,\r\n{"Key Lifetime", "wmx.pkm_msg.pkm_attr.key_life_time", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_msg_attr_key_seq_num,\r\n{"Key Sequence Number", "wmx.pkm_msg.pkm_attr.key_seq_num", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_msg_attr_hmac_digest,\r\n{"HMAC-Digest", "wmx.pkm_msg.pkm_attr.hmac_digest", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_msg_attr_said,\r\n{"SAID", "wmx.pkm_msg.pkm_attr.said", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n#if 0\r\n{\r\n&hf_pkm_msg_attr_tek_param,\r\n{"TEK Parameters", "wmx.pkm_msg.pkm_attr.tek_parameters", FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL}\r\n},\r\n#endif\r\n{\r\n&hf_pkm_msg_attr_cbc_iv,\r\n{"CBC IV", "wmx.pkm_msg.pkm_attr.cbc_iv", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_msg_attr_error_code,\r\n{"Error Code", "wmx.pkm_msg.pkm_attr.error_code", FT_UINT8, BASE_DEC, VALS(vals_pkm_attr_error_codes), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_msg_attr_ca_certificate,\r\n{"CA Certificate", "wmx.pkm_msg.pkm_attr.ca_certificate", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_msg_attr_ss_certificate,\r\n{"SS Certificate", "wmx.pkm_msg.pkm_attr.ss_certificate", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n#if 0\r\n{\r\n&hf_pkm_msg_attr_security_capabilities,\r\n{"Security Capabilities", "wmx.pkm_msg.pkm_attr.security_capabilities", FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL}\r\n},\r\n#endif\r\n{\r\n&hf_pkm_msg_crypto_suite,\r\n{"Cryptography", "wmx.pkm_msg.pkm_attr.crypto_suite", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_msg_crypto_suite_msb,\r\n{"Data Encryption Algorithm Identifiers", "wmx.pkm_msg.pkm_attr.crypto_suite.msb", FT_UINT8, BASE_DEC, VALS(vals_data_encryption_ids), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_msg_crypto_suite_middle,\r\n{"Data Authentication Algorithm Identifiers", "wmx.pkm_msg.pkm_attr.crypto_suite.middle", FT_UINT8, BASE_DEC, VALS(vals_data_authentication_ids), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_msg_crypto_suite_lsb,\r\n{"TEK Encryption Algorithm Identifiers", "wmx.pkm_msg.pkm_attr.crypto_suite.lsb", FT_UINT8, BASE_DEC, VALS(vals_tek_encryption_ids), 0x0, NULL, HFILL}\r\n},\r\n#if 0\r\n{\r\n&hf_pkm_msg_crypto_list,\r\n{"Cryptographic-Suite List", "wmx.pkm_msg.pkm_attr.crypto_suite_list", FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL}\r\n},\r\n#endif\r\n#if 0\r\n{\r\n&hf_pkm_msg_version,\r\n{"Reserved ", "wmx.pkm_msg.pkm_attr.version", FT_UINT8, BASE_HEX, NULL, 0x0, "", HFILL}\r\n},\r\n#endif\r\n#if 0\r\n{\r\n&hf_pkm_msg_sa_descriptor,\r\n{"SA Descriptor", "wmx.pkm_msg.pkm_attr.sa_descriptor", FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL}\r\n},\r\n#endif\r\n{\r\n&hf_pkm_sa_type,\r\n{"SA Type", "wmx.pkm_msg.pkm_attr.sa_type", FT_UINT8, BASE_DEC, VALS(vs_sa_type), 0x0, NULL, HFILL}\r\n},\r\n#if 0\r\n{\r\n&hf_pkm_attr_security_negotiation_parameters,\r\n{"Security Negotiation Parameters", "wmx.pkm_msg.pkm_attr.security_negotiation_parameters", FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL}\r\n},\r\n#endif\r\n#if 0\r\n{\r\n&hf_pkm_attr_config_settings,\r\n{"PKM Configuration Settings", "wmx.pkm_msg.pkm_attr.config_settings", FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL}\r\n},\r\n#endif\r\n{\r\n&hf_pkm_config_settings_authorize_waitout,\r\n{"Authorize Wait Timeout (in seconds)", "wmx.pkm_msg.pkm_attr.config_settings.authorize_waitout", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_config_settings_reauthorize_waitout,\r\n{"Reauthorize Wait Timeout (in seconds)", "wmx.pkm_msg.pkm_attr.config_settings.reauthorize_waitout", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_config_settings_grace_time,\r\n{"Authorization Grace Time (in seconds)", "wmx.pkm_msg.pkm_attr.config_settings.grace_time", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_config_settings_operational_waittime,\r\n{"Operational Wait Timeout (in seconds)", "wmx.pkm_msg.pkm_attr.config_settings.operational_wait_timeout", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_config_settings_rekey_wait_timeout,\r\n{"Rekey Wait Timeout (in seconds)", "wmx.pkm_msg.pkm_attr.config_settings.rekey_wait_timeout", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_config_settings_tek_grace_time,\r\n{"TEK Grace Time (in seconds)", "wmx.pkm_msg.pkm_attr.config_settings.tek_grace_time", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_config_settings_authorize_reject_wait_timeout,\r\n{"Authorize Reject Wait Timeout(in seconds)", "wmx.pkm_msg.pkm_attr.config_settings.authorize_reject_wait_timeout", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_nonce,\r\n{"Nonce", "wmx.pkm_msg.pkm_attr.nonce", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_ss_random,\r\n{"SS_RANDOM", "wmx.pkm_msg.pkm_attr.ss_random", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_bs_random,\r\n{"BS_RANDOM", "wmx.pkm_msg.pkm_attr.bs_random", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_pre_pak,\r\n{"Pre-PAK", "wmx.pkm_msg.pkm_attr.pre_pak", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n#if 0\r\n{\r\n&hf_pkm_attr_pak_ak_seq_number,\r\n{"PAK/AK Sequence Number", "wmx.pkm_msg.pkm_attr.pak_ak_seq_number", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n#endif\r\n{\r\n&hf_pkm_attr_bs_certificate,\r\n{"BS Certificate", "wmx.pkm_msg.pkm_attr.bs_certificate", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_sig_bs,\r\n{"SigBS", "wmx.pkm_msg.pkm_attr.sig_bs",FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_ms_mac_address,\r\n{"MS-MAC Address", "wmx.pkm_msg.pkm_attr.ms_mac_address",FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_cmac_digest,\r\n{"CMAC Digest", "wmx.pkm_msg.pkm_attr.cmac_digest",FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_cmac_digest_pn,\r\n{"CMAC Packet Number counter, CMAC_PN_*", "wmx.pkm_msg.pkm_attr.cmac_digest.pn",FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_cmac_digest_value,\r\n{"CMAC Value", "wmx.pkm_msg.pkm_attr.cmac_digest.value",FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_push_modes,\r\n{"Key Push Modes", "wmx.pkm_msg.pkm_attr.key_push_modes",FT_UINT8, BASE_DEC, VALS(va_key_push_modes), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_key_push_counter,\r\n{"Key Push Counter", "wmx.pkm_msg.pkm_attr.key_push_counter",FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_gkek,\r\n{"GKEK", "wmx.pkm_msg.pkm_attr.gkek",FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_sig_ss,\r\n{"SigSS", "wmx.pkm_msg.pkm_attr.sig_ss",FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_akid,\r\n{"AKID", "wmx.pkm_msg.pkm_attr.akid",FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_eap_payload,\r\n{"EAP Payload", "wmx.pkm_msg.pkm_attr.eap_payload", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_auth_result_code,\r\n{"Auth Result Code", "wmx.pkm_msg.pkm_attr.auth_result_code", FT_UINT8, BASE_DEC, VALS(vs_success_reject), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_pkm_attr_sa_service_type,\r\n{"SA Service Type", "wmx.pkm_msg.pkm_attr.sa_service_type", FT_UINT8, BASE_DEC, VALS(vs_sa_service_type), 0x0, NULL, HFILL}\r\n},\r\n#if 0\r\n{\r\n&hf_pkm_attr_config_settings,\r\n{"PKMv2 Configuration Settings", "wmx.pkm_msg.pkm_attr.config_settings", FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL}\r\n},\r\n#endif\r\n{\r\n&hf_pkm_attr_frame_number,\r\n{"Frame Number", "wmx.pkm_msg.pkm_attr.frame_number", FT_UINT24, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n#if 1\r\n{\r\n&hf_pkm_attr_associated_gkek_seq_number,\r\n{"Associated GKEK Sequence Number", "wmx.pkm_msg.pkm_attr.associated_gkek_seq_number",FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n#endif\r\n#if 0\r\n{\r\n&hf_pkm_attr_gkek_params,\r\n{"GKEK Parameters", "wmx.pkm_msg.pkm_attr.gkek_params",FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n#endif\r\n{\r\n&hf_pkm_msg_unknown_type,\r\n{"Unknown Type", "wmx.pkm.unknown.type", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n}\r\n};\r\nstatic hf_register_info hf_common_tlv[] =\r\n{\r\n{\r\n&hf_common_tlv_mac_version,\r\n{ "MAC Version", "wmx.common_tlv.mac_version", FT_UINT8, BASE_DEC, VALS(vals_dcd_mac_version), 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_common_tlv_vendor_id,\r\n{ "Vendor ID Encoding", "wmx.common_tlv.vendor_id_encoding", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_common_tlv_vendor_specific_type,\r\n{ "Vendor Specific Type", "wmx.common_tlv.vendor_specific_type", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_common_tlv_vendor_specific_length_size,\r\n{\r\n"Vendor Specific Length Size", "wmx.common_tlv.vendor_specific_length_size",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_common_tlv_vendor_specific_length,\r\n{ "Vendor Specific Length", "wmx.common_tlv.vendor_specific_length", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_common_tlv_vendor_specific_value,\r\n{ "Vendor Specific Value", "wmx.common_tlv.vendor_specific_value", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{\r\n&hf_common_current_transmitted_power,\r\n{ "Current Transmitted Power", "wmx.common_tlv.current_transmitted_power", FT_FLOAT, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n#if 0\r\n{\r\n&hf_common_tlv_unknown_type,\r\n{"Unknown Common TLV Type", "wmx.common_tlv.unknown_type", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n}\r\n#endif\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_common_tlv_info, { "wmx.common_tlv.invalid", PI_PROTOCOL, PI_WARN, "Invalid TLV info", EXPFILL }},\r\n};\r\nexpert_module_t* expert_wimax_utility;\r\nif(proto_wimax_utility_decoders == -1)\r\n{\r\nproto_wimax_utility_decoders = proto_register_protocol (\r\n"WiMax Sub-TLV Messages",\r\n"WiMax Sub-TLV (sub)",\r\n"wmx.sub"\r\n);\r\nproto_register_subtree_array(ett, array_length(ett));\r\nproto_register_field_array(proto_wimax_utility_decoders, hf_sfe, array_length(hf_sfe));\r\nproto_register_field_array(proto_wimax_utility_decoders, hf_csper, array_length(hf_csper));\r\nproto_register_field_array(proto_wimax_utility_decoders, hf_xmac, array_length(hf_xmac));\r\nproto_register_field_array(proto_wimax_utility_decoders, hf_snp, array_length(hf_snp));\r\nproto_register_field_array(proto_wimax_utility_decoders, hf_pkm, array_length(hf_pkm));\r\nproto_register_field_array(proto_wimax_utility_decoders, hf_common_tlv, array_length(hf_common_tlv));\r\nexpert_wimax_utility = expert_register_protocol(proto_wimax_utility_decoders);\r\nexpert_register_field_array(expert_wimax_utility, ei, array_length(ei));\r\neap_handle = find_dissector("eap");\r\n}\r\n}\r\nvoid wimax_error_parameter_set_decoder(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint offset;\r\nguint tvb_len, tlv_len;\r\ngint tlv_type;\r\nproto_item *ceps_item = NULL;\r\nproto_tree *ceps_tree = NULL;\r\ntlv_info_t tlv_info;\r\ntvb_len = tvb_reported_length(tvb);\r\noffset = 0;\r\nceps_item = proto_tree_add_protocol_format(tree, proto_wimax_utility_decoders, tvb, offset, tvb_len, "Error Parameter Set (%u bytes)", tvb_len);\r\nceps_tree = proto_item_add_subtree(ceps_item, ett_wimax_error_parameter_set);\r\nif(!tvb_len)\r\nreturn;\r\nif(tvb_len < 2)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Invalid Error Parameter Set");\r\nreturn;\r\n}\r\nwhile(offset < tvb_len)\r\n{\r\ninit_tlv_info(&tlv_info, tvb, offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\ntlv_len = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || tlv_len > MAX_TLV_LEN || tlv_len < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "EPS TLV error");\r\nproto_tree_add_item(ceps_tree, hf_cst_invalid_tlv, tvb, offset, (tvb_len - offset), ENC_NA);\r\nbreak;\r\n}\r\n#ifdef DEBUG\r\nproto_tree_add_protocol_format(ceps_tree, proto_wimax_utility_decoders, tvb, offset, (tlv_len+2+get_tlv_size_of_length(&tlv_info)), "EPS TLV Type: %u (%u bytes, offset=%u, tvb_len=%u)", tlv_type, tlv_len, offset, tvb_len);\r\n#endif\r\nswitch (tlv_type)\r\n{\r\ncase CST_ERROR_SET_ERRORED_PARAM:\r\nadd_tlv_subtree(&tlv_info, ceps_tree, hf_cst_error_set_errored_param, tvb, offset, ENC_NA);\r\nbreak;\r\ncase CST_ERROR_SET_ERROR_CODE:\r\nadd_tlv_subtree(&tlv_info, ceps_tree, hf_cst_error_set_error_code, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_ERROR_SET_ERROR_MSG:\r\nadd_tlv_subtree(&tlv_info, ceps_tree, hf_cst_error_set_error_msg, tvb, offset, ENC_ASCII|ENC_NA);\r\nbreak;\r\n}\r\noffset += (tlv_len+get_tlv_value_offset(&tlv_info));\r\n}\r\n}\r\nvoid wimax_convengence_service_parameter_encoding_rules_decoder(guint sfe_type, tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint offset, tlv_offset;\r\nguint tvb_len, tlv_len, length;\r\ngint tlv_type;\r\nproto_item *csper_item;\r\nproto_tree *csper_tree;\r\nproto_tree *tlv_tree, *ti_tree;\r\nproto_item *tlv_item, *ti_item;\r\ntlv_info_t tlv_info;\r\ngboolean ipv6 = ((sfe_type == SFE_CSPER_PACKET_IPV6) || (sfe_type == SFE_CSPER_PACKET_IPV6_802_3) || (sfe_type == SFE_CSPER_PACKET_IPV6_802_1Q));\r\nif((sfe_type < SFE_CSPER_ATM) || (sfe_type > SFE_CSPER_PACKET_IP_802_3_ECRTP_COMPRESSION))\r\nreturn;\r\ntvb_len = tvb_reported_length(tvb);\r\noffset = 0;\r\ncsper_item = proto_tree_add_protocol_format(tree, proto_wimax_utility_decoders, tvb, offset, tvb_len, "Convergence Service Parameter Encoding Rules (%u bytes)", tvb_len);\r\ncsper_tree = proto_item_add_subtree(csper_item, ett_wimax_cst_encoding_rules);\r\nif(!tvb_len)\r\nreturn;\r\nif(tvb_len < 2)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Invalid Convergence Service Parameter Encoding Rules");\r\nreturn;\r\n}\r\nwhile(offset < tvb_len)\r\n{\r\ninit_tlv_info(&tlv_info, tvb, offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\ntlv_len = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || tlv_len > MAX_TLV_LEN || tlv_len < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "CSPER TLV error");\r\nproto_tree_add_item(csper_tree, hf_cst_invalid_tlv, tvb, offset, (tvb_len - offset), ENC_NA);\r\nbreak;\r\n}\r\n#ifdef DEBUG\r\nproto_tree_add_protocol_format(csper_tree, proto_wimax_utility_decoders, tvb, offset, (tlv_len+2+get_tlv_size_of_length(&tlv_info)), "CSPER TLV Type: %u (%u bytes, offset=%u, tvb_len=%u)", tlv_type, tlv_len, offset, tvb_len);\r\n#endif\r\noffset += get_tlv_value_offset(&tlv_info);\r\nif(sfe_type == SFE_CSPER_ATM)\r\n{\r\nswitch (tlv_type)\r\n{\r\ncase CST_ATM_SWITCHING:\r\nadd_tlv_subtree(&tlv_info, csper_tree, hf_csper_atm_switching_encoding, tvb, offset-get_tlv_value_offset(&tlv_info), ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_ATM_CLASSIFIER:\r\ntlv_item = add_tlv_subtree(&tlv_info, csper_tree, hf_csper_atm_classifier, tvb, offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_wimax_cst_encoding_rules);\r\ntlv_offset = offset;\r\nwhile(tlv_offset < (tlv_len + offset))\r\n{\r\ninit_tlv_info(&tlv_info, tvb, tlv_offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\nlength = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || length > MAX_TLV_LEN || length < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "ATM Classifier TLV error");\r\nproto_tree_add_item(tlv_tree, hf_cst_invalid_tlv, tvb, offset, (tlv_len - tlv_offset), ENC_NA);\r\nbreak;\r\n}\r\n#ifdef DEBUG\r\nproto_tree_add_protocol_format(csper_tree, proto_wimax_utility_decoders, tvb, offset, (tlv_len+2+get_tlv_size_of_length(&tlv_info)), "ATM Classifier TLV Type: %u (%u bytes, offset=%u, tlv_len=%u)", tlv_type, length, offset, tlv_len);\r\n#endif\r\nswitch (tlv_type)\r\n{\r\ncase ATM_VPI_CLASSIFIER:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_csper_atm_classifier_vpi, tvb, tlv_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase ATM_VCI_CLASSIFIER:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_csper_atm_classifier_vci, tvb, tlv_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase ATM_CLASSIFIER_ID:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_csper_atm_classifier_id, tvb, tlv_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntlv_offset += (length + get_tlv_value_offset(&tlv_info));\r\n}\r\nbreak;\r\ncase CST_ATM_CLASSIFIER_DSC_ACTION:\r\nadd_tlv_subtree(&tlv_info, csper_tree, hf_cst_classifier_dsc_action, tvb, offset-get_tlv_value_offset(&tlv_info), ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_ATM_CLASSIFIER_ERROR_PARAMETER_SET:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_wimax_cst_encoding_rules, csper_tree, proto_wimax_utility_decoders, tvb, offset-get_tlv_value_offset(&tlv_info), tlv_len, "Classifier Error Parameter Set");\r\nwimax_error_parameter_set_decoder(tvb_new_subset_length(tvb, offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\ndefault:\r\nadd_tlv_subtree(&tlv_info, csper_tree, hf_csper_unknown_type, tvb, offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\nbreak;\r\n}\r\n}\r\nelse\r\n{\r\nswitch (tlv_type)\r\n{\r\ncase CST_CLASSIFIER_ACTION:\r\nadd_tlv_subtree(&tlv_info, csper_tree, hf_cst_classifier_dsc_action, tvb, offset-get_tlv_value_offset(&tlv_info), ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_CLASSIFIER_ERROR_PARAM_SET:\r\ncase CST_PHS_ERROR_PARAM_SET:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_wimax_cst_encoding_rules, csper_tree, proto_wimax_utility_decoders, tvb, offset-get_tlv_value_offset(&tlv_info), tlv_len, "Classifier Error Parameter Set");\r\nwimax_error_parameter_set_decoder(tvb_new_subset_length(tvb, offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\ncase CST_PACKET_CLASSIFICATION_RULE:\r\n{\r\ntlv_item = add_tlv_subtree(&tlv_info, csper_tree, hf_cst_pkt_class_rule, tvb, offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_wimax_cst_encoding_rules);\r\ntlv_offset = offset;\r\nwhile(tlv_offset < (tlv_len + offset))\r\n{\r\ninit_tlv_info(&tlv_info, tvb, tlv_offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\nlength = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || length > MAX_TLV_LEN || length < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Packet Classification Rule TLV error");\r\nproto_tree_add_item(tlv_tree, hf_cst_invalid_tlv, tvb, offset, (tlv_len - tlv_offset), ENC_NA);\r\nbreak;\r\n}\r\n#ifdef DEBUG\r\nproto_tree_add_protocol_format(csper_tree, proto_wimax_utility_decoders, tvb, tlv_offset, (length + get_tlv_value_offset(&tlv_info)), "Packet Classification Rule TLV Type: %u (%u bytes, offset=%u, tlv_len=%u)", tlv_type, length, tlv_offset, tlv_len);\r\n#endif\r\ntlv_offset += get_tlv_value_offset(&tlv_info);\r\nswitch (tlv_type)\r\n{\r\ncase CST_PKT_CLASS_RULE_PRIORITY:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_priority, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_RANGE_MASK:\r\nti_item = add_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_range_mask, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\nti_tree = proto_item_add_subtree(ti_item, ett_wimax_cst_encoding_rules);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_tos_low, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_tos_high, tvb, tlv_offset + 1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_tos_mask, tvb, tlv_offset + 2, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_PROTOCOL:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_protocol, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_SRC_IP:\r\nti_item = add_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_ip_masked_src_address, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\nti_tree = proto_item_add_subtree(ti_item, ett_wimax_cst_encoding_rules);\r\nif(ipv6)\r\n{\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_src_ipv6, tvb, tlv_offset, 16, ENC_NA);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_mask_ipv6, tvb, tlv_offset + 16, 16, ENC_NA);\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_src_ipv4, tvb, tlv_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_mask_ipv4, tvb, tlv_offset + 4, 4, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_DST_IP:\r\nti_item = add_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_ip_masked_dest_address, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\nti_tree = proto_item_add_subtree(ti_item, ett_wimax_cst_encoding_rules);\r\nif(ipv6)\r\n{\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_dest_ipv6, tvb, tlv_offset, 16, ENC_NA);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_mask_ipv6, tvb, tlv_offset + 16, 16, ENC_NA);\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_dest_ipv4, tvb, tlv_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_mask_ipv4, tvb, tlv_offset + 4, 4, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_SRCPORT_RANGE:\r\nti_item = add_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_prot_src_port_range, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\nti_tree = proto_item_add_subtree(ti_item, ett_wimax_cst_encoding_rules);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_src_port_low, tvb, tlv_offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_src_port_high, tvb, tlv_offset + 2, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_DSTPORT_RANGE:\r\nti_item = add_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_prot_dest_port_range, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\nti_tree = proto_item_add_subtree(ti_item, ett_wimax_cst_encoding_rules);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_dest_port_low, tvb, tlv_offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_dest_port_high, tvb, tlv_offset + 2, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_DST_MAC:\r\nti_item = add_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_dest_mac_address, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\nti_tree = proto_item_add_subtree(ti_item, ett_wimax_cst_encoding_rules);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_dest_mac, tvb, tlv_offset, 6, ENC_NA);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_mask_mac, tvb, tlv_offset + 6, 6, ENC_NA);\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_SRC_MAC:\r\nti_item = add_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_src_mac_address, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\nti_tree = proto_item_add_subtree(ti_item, ett_wimax_cst_encoding_rules);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_src_mac, tvb, tlv_offset, 6, ENC_NA);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_mask_mac, tvb, tlv_offset + 6, 6, ENC_NA);\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_ETHERTYPE:\r\nti_item = add_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_ethertype, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\nti_tree = proto_item_add_subtree(ti_item, ett_wimax_cst_encoding_rules);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_etype, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_eprot1, tvb, tlv_offset + 1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_eprot2, tvb, tlv_offset + 2, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_USER_PRIORITY:\r\nti_item = add_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_user_priority, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\nti_tree = proto_item_add_subtree(ti_item, ett_wimax_cst_encoding_rules);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_pri_low, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_pri_high, tvb, tlv_offset + 1, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_VLAN_ID:\r\nti_item = add_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_vlan_id, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\nti_tree = proto_item_add_subtree(ti_item, ett_wimax_cst_encoding_rules);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_vlan_id1, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_vlan_id2, tvb, tlv_offset + 1, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_PHSI:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_phsi, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_INDEX:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_index, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_IPv6_FLOW_LABEL:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_ipv6_flow_label, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_VENDOR_SPEC:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_vendor_spec, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\nbreak;\r\ncase CST_CLASSIFIER_ACTION_RULE:\r\nti_item = add_tlv_subtree(&tlv_info, tlv_tree, hf_cst_pkt_class_rule_classifier_action_rule, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_BIG_ENDIAN);\r\nti_tree = proto_item_add_subtree(ti_item, ett_wimax_cst_encoding_rules);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_classifier_action_rule_bit0, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti_tree, hf_cst_pkt_class_rule_classifier_action_rule_bit1, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_LARGE_CONTEXT_ID:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_cst_large_context_id, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PKT_CLASS_RULE_SHORT_FORMAT_CONTEXT_ID:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_cst_short_format_context_id, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntlv_offset += length;\r\n}\r\nbreak;\r\n}\r\ncase CST_PHS_DSC_ACTION:\r\nadd_tlv_subtree(&tlv_info, csper_tree, hf_cst_phs_dsc_action, tvb, offset-get_tlv_value_offset(&tlv_info), ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PHS_RULE:\r\n{\r\ntlv_item = add_tlv_subtree(&tlv_info, csper_tree, hf_cst_phs_rule, tvb, offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_wimax_cst_encoding_rules);\r\ntlv_offset = offset;\r\nwhile(tlv_offset < (tlv_len + offset))\r\n{\r\ninit_tlv_info(&tlv_info, tvb, tlv_offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\nlength = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || length > MAX_TLV_LEN || length < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "PHS n Rule TLV error");\r\nproto_tree_add_item(tlv_tree, hf_cst_invalid_tlv, tvb, offset, (tlv_len - tlv_offset), ENC_NA);\r\nbreak;\r\n}\r\n#ifdef DEBUG\r\nproto_tree_add_protocol_format(csper_tree, proto_wimax_utility_decoders, tvb, offset, (tlv_len+2+get_tlv_size_of_length(&tlv_info)), "PHS Rule TLV Type: %u (%u bytes, offset=%u, tlv_len=%u)", tlv_type, length, offset, tlv_len);\r\n#endif\r\nswitch (tlv_type)\r\n{\r\ncase CST_PHS_PHSI:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_cst_phs_phsi, tvb, tlv_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PHS_PHSF:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_cst_phs_phsf, tvb, tlv_offset, ENC_NA);\r\nbreak;\r\ncase CST_PHS_PHSM:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_cst_phs_phsm, tvb, tlv_offset, ENC_NA);\r\nbreak;\r\ncase CST_PHS_PHSS:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_cst_phs_phss, tvb, tlv_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PHS_PHSV:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_cst_phs_phsv, tvb, tlv_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CST_PHS_VENDOR_SPEC:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_cst_phs_vendor_spec, tvb, tlv_offset, ENC_NA);\r\nbreak;\r\n}\r\ntlv_offset += (length+get_tlv_value_offset(&tlv_info));\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nadd_tlv_subtree(&tlv_info, tree, hf_csper_unknown_type, tvb, offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\nbreak;\r\n}\r\n}\r\noffset += tlv_len;\r\n}\r\n}\r\nvoid wimax_service_flow_encodings_decoder(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint offset, i;\r\nguint tvb_len, tlv_len, tlv_value_offset, tlv_value;\r\ngint tlv_type;\r\nguint value;\r\nproto_item *tlv_item = NULL;\r\nproto_tree *tlv_tree = NULL;\r\ntlv_info_t tlv_info;\r\ntvb_len = tvb_reported_length(tvb);\r\n#ifdef DEBUG\r\nproto_tree_add_protocol_format(tree, proto_wimax_utility_decoders, tvb, 0, tvb_len, "WiMax Service Flow Encodings (%u bytes)", tvb_len);\r\n#endif\r\noffset = 0;\r\nif(!tvb_len)\r\nreturn;\r\nif(tvb_len < 2)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Invalid Service Flow Encodings");\r\nreturn;\r\n}\r\nwhile(offset < tvb_len)\r\n{\r\ninit_tlv_info(&tlv_info, tvb, offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\ntlv_len = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || tlv_len > MAX_TLV_LEN || tlv_len < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Service Flow Encodings TLV error");\r\nproto_tree_add_item(tree, hf_cst_invalid_tlv, tvb, offset, (tvb_len - offset), ENC_NA);\r\nbreak;\r\n}\r\ntlv_value_offset = get_tlv_value_offset(&tlv_info);\r\n#ifdef DEBUG\r\nproto_tree_add_protocol_format(tree, proto_wimax_utility_decoders, tvb, offset, (tlv_len + tlv_value_offset), "Service Flow Encodings TLV Type: %u (%u bytes, offset=%u, tvb_len=%u)", tlv_type, tlv_len, offset, tvb_len);\r\n#endif\r\noffset += tlv_value_offset;\r\nswitch (tlv_type)\r\n{\r\ncase SFE_SF_ID:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_sf_id, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_CID:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_cid, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_SERVICE_CLASS_NAME:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_service_class_name, tvb, offset-tlv_value_offset, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase SFE_MBS_SERVICE:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_mbs_service, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_QOS_PARAMS_SET:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_sfe_qos_params_set, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_wimax_service_flow_encodings);\r\nproto_tree_add_item(tlv_tree, hf_sfe_set_provisioned, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_sfe_set_admitted, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_sfe_set_active, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_sfe_set_rsvd, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_TRAFFIC_PRIORITY:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_sfe_traffic_priority, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nproto_item_append_text(tlv_item, " (allowed values are 0-7)");\r\nbreak;\r\ncase SFE_MAX_STR:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_sfe_max_str, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nproto_item_append_text(tlv_item, " bps");\r\nbreak;\r\ncase SFE_MAX_TRAFFIC_BURST:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_sfe_max_traffic_burst, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nproto_item_append_text(tlv_item, " bytes");\r\nbreak;\r\ncase SFE_MIN_RTR:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_sfe_min_rtr, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nproto_item_append_text(tlv_item, " bps");\r\nbreak;\r\ncase SFE_RESERVED_10:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_reserved_10, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_UL_SCHEDULING:\r\ntlv_value = tvb_get_guint8(tvb, offset);\r\nset_service_type( tlv_value );\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_ul_grant_scheduling, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_TX_POLICY:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_sfe_req_tx_policy, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_wimax_service_flow_encodings);\r\nproto_tree_add_item(tlv_tree, hf_sfe_policy_broadcast_bwr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_sfe_policy_multicast_bwr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_sfe_policy_piggyback, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_sfe_policy_fragment, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_sfe_policy_headers, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_sfe_policy_packing, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_sfe_policy_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_sfe_policy_rsvd1, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_TOLERATED_JITTER:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_sfe_jitter, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nproto_item_append_text(tlv_item, " ms");\r\nbreak;\r\ncase SFE_MAX_LATENCY:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_sfe_max_latency, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nproto_item_append_text(tlv_item, " ms");\r\nbreak;\r\ncase SFE_FIXED_LEN_SDU:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_fixed_len_sdu, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_SDU_SIZE:\r\nmac_sdu_length = tvb_get_guint8(tvb, offset);\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_sfe_sdu_size, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nproto_item_append_text(tlv_item, " bytes");\r\nbreak;\r\ncase SFE_TARGET_SAID:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_target_said, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_ARQ_ENABLE:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_arq_enable, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_ARQ_WINDOW_SIZE:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_arq_window_size, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_ARQ_TRANSMITTER_DELAY:\r\nif (include_cor2_changes)\r\n{\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_arq_transmitter_delay_cor2, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_arq_transmitter_delay, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase SFE_ARQ_RECEIVER_DELAY:\r\nif (include_cor2_changes)\r\n{\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_arq_receiver_delay_cor2, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_arq_receiver_delay, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase SFE_ARQ_BLOCK_LIFETIME:\r\nif (include_cor2_changes)\r\n{\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_arq_block_lifetime_cor2, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_arq_block_lifetime, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase SFE_ARQ_SYNC_LOSS_TIMEOUT:\r\nif (include_cor2_changes)\r\n{\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_arq_sync_loss_timeout_cor2, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_arq_sync_loss_timeout, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase SFE_ARQ_DELIVER_IN_ORDER:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_arq_deliver_in_order, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_ARQ_RX_PURGE_TIMEOUT:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_arq_rx_purge_timeout, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_ARQ_BLOCK_SIZE:\r\nif (include_cor2_changes)\r\n{\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_sfe_arq_block_size_cor2, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_wimax_service_flow_encodings);\r\nvalue = tvb_get_guint8(tvb, offset);\r\ntlv_item = proto_tree_add_item(tlv_tree, hf_sfe_arq_min_block_size, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(tlv_item, " ( %d bytes )", 0x10 << (value & 0x0F));\r\ntlv_item = proto_tree_add_item(tlv_tree, hf_sfe_arq_max_block_size, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif (value & 0xF0)\r\nproto_item_append_text(tlv_item, " ( %d bytes )", 0x10 << ((value & 0xF0) >> 4));\r\n}\r\nelse\r\n{\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_arq_block_size, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase SFE_CS_SPECIFICATION:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_cs_specification, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_TYPE_OF_DATA_DELIVERY_SERVICES:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_type_of_data_delivery_services, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_SDU_INTER_ARRIVAL_INTERVAL:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_sdu_inter_arrival_interval, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_TIME_BASE:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_sfe_time_base, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nproto_item_append_text(tlv_item, " ms");\r\nbreak;\r\ncase SFE_PAGING_PREFERENCE:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_paging_preference, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_MBS_ZONE_IDENTIFIER_ASSIGNMENT:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_mbs_zone_identifier_assignment, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_RESERVED_34:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_reserved_34, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_GLOBAL_SERVICE_CLASS_NAME:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_global_service_class_name, tvb, offset-tlv_value_offset, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase SFE_RESERVED_36:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_reserved_36, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_SN_FEEDBACK_ENABLED:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_sn_feedback_enabled, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_FSN_SIZE:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_fsn_size, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_CID_ALLOCATION_FOR_ACTIVE_BS:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_sfe_cid_alloc_for_active_bs_cid, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_wimax_service_flow_encodings);\r\nfor(i = 0; i < tlv_len; i+=2)\r\nproto_tree_add_item(tlv_tree, hf_sfe_cid_alloc_for_active_bs_cid, tvb, (offset+i), 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_UNSOLICITED_GRANT_INTERVAL:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_sfe_unsolicited_grant_interval, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nproto_item_append_text(tlv_item, " ms");\r\nbreak;\r\ncase SFE_UNSOLOCITED_POLLING_INTERVAL:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_sfe_unsolicited_polling_interval, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nproto_item_append_text(tlv_item, " ms");\r\nbreak;\r\ncase SFE_PDU_SN_EXT_SUBHEADER_HARQ_REORDER:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_pdu_sn_ext_subheader_reorder, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_MBS_CONTENTS_ID:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_sfe_mbs_contents_ids, tvb, offset-tlv_value_offset, ENC_NA);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_wimax_service_flow_encodings);\r\nfor(i = 0; i < tlv_len; i+=2)\r\nproto_tree_add_item(tlv_tree, hf_sfe_mbs_contents_ids_id, tvb, (offset+i), 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_HARQ_SERVICE_FLOWS:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_harq_service_flows, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_AUTHORIZATION_TOKEN:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_authorization_token, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase SFE_HARQ_CHANNEL_MAPPING:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_sfe_harq_channel_mapping_index, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_wimax_service_flow_encodings);\r\nfor(i = 0; i < tlv_len; i++)\r\nproto_tree_add_item(tlv_tree, hf_sfe_harq_channel_mapping_index, tvb, (offset+i), 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SFE_CSPER_ATM:\r\ncase SFE_CSPER_PACKET_IPV4:\r\ncase SFE_CSPER_PACKET_IPV6:\r\ncase SFE_CSPER_PACKET_802_3:\r\ncase SFE_CSPER_PACKET_802_1Q:\r\ncase SFE_CSPER_PACKET_IPV4_802_3:\r\ncase SFE_CSPER_PACKET_IPV6_802_3:\r\ncase SFE_CSPER_PACKET_IPV4_802_1Q:\r\ncase SFE_CSPER_PACKET_IPV6_802_1Q:\r\ncase SFE_CSPER_PACKET_IP_ROCH_COMPRESSION:\r\ncase SFE_CSPER_PACKET_IP_ECRTP_COMPRESSION:\r\ncase SFE_CSPER_PACKET_IP_802_3_ROCH_COMPRESSION:\r\ncase SFE_CSPER_PACKET_IP_802_3_ECRTP_COMPRESSION:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_wimax_service_flow_encodings, tree, proto_wimax_utility_decoders, tvb, offset-tlv_value_offset, tlv_len, "CS Parameter Encoding Rules");\r\nwimax_convengence_service_parameter_encoding_rules_decoder(tlv_type, tvb_new_subset_length(tvb, offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\ndefault:\r\nadd_tlv_subtree(&tlv_info, tree, hf_sfe_unknown_type, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\n}\r\noffset += tlv_len;\r\n}\r\n}\r\nvoid wimax_hmac_tuple_decoder(proto_tree *tree, tvbuff_t *tvb, guint offset, guint length)\r\n{\r\nguint hmac_offset;\r\nproto_item *hmac_item = NULL;\r\nproto_tree *hmac_tree = NULL;\r\nhmac_item = proto_tree_add_protocol_format(tree, proto_wimax_utility_decoders, tvb, offset, length, "HMAC Tuple (%u bytes)", length);\r\nhmac_tree = proto_item_add_subtree(hmac_item, ett_wimax_hmac_tuple);\r\nhmac_offset = offset;\r\nproto_tree_add_item(hmac_tree, hf_xmac_tuple_rsvd, tvb, hmac_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(hmac_tree, hf_xmac_tuple_key_seq_num, tvb, hmac_offset, 1, ENC_BIG_ENDIAN);\r\nhmac_offset++;\r\nproto_tree_add_item(hmac_tree, hf_hmac_tuple_hmac_digest, tvb, hmac_offset, (length-1), ENC_NA);\r\n}\r\nvoid wimax_cmac_tuple_decoder(proto_tree *tree, tvbuff_t *tvb, guint offset, guint length)\r\n{\r\nguint cmac_offset;\r\nproto_item *cmac_item = NULL;\r\nproto_tree *cmac_tree = NULL;\r\ncmac_item = proto_tree_add_protocol_format(tree, proto_wimax_utility_decoders, tvb, offset, length, "CMAC Tuple (%u bytes)", length);\r\ncmac_tree = proto_item_add_subtree(cmac_item, ett_wimax_cmac_tuple);\r\ncmac_offset = offset;\r\nproto_tree_add_item(cmac_tree, hf_xmac_tuple_rsvd, tvb, cmac_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(cmac_tree, hf_xmac_tuple_key_seq_num, tvb, cmac_offset, 1, ENC_BIG_ENDIAN);\r\ncmac_offset++;\r\nif(length > 13)\r\n{\r\nproto_tree_add_item(cmac_tree, hf_cmac_tuple_bsid, tvb, cmac_offset, 6, ENC_NA);\r\ncmac_offset += 6;\r\n}\r\nproto_tree_add_item(cmac_tree, hf_packet_number_counter, tvb, cmac_offset, 4, ENC_BIG_ENDIAN);\r\ncmac_offset += 4;\r\nproto_tree_add_item(cmac_tree, hf_cmac_tuple_cmac_value, tvb, cmac_offset, 8, ENC_NA);\r\n}\r\nvoid wimax_short_hmac_tuple_decoder(proto_tree *tree, tvbuff_t *tvb, guint offset, guint length)\r\n{\r\nguint hmac_offset;\r\nproto_item *hmac_item = NULL;\r\nproto_tree *hmac_tree = NULL;\r\nhmac_item = proto_tree_add_protocol_format(tree, proto_wimax_utility_decoders, tvb, offset, length, "Short-HMAC Tuple (%u bytes)", length);\r\nhmac_tree = proto_item_add_subtree(hmac_item, ett_wimax_short_hmac_tuple);\r\nhmac_offset = offset;\r\nproto_tree_add_item(hmac_tree, hf_xmac_tuple_rsvd, tvb, hmac_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(hmac_tree, hf_xmac_tuple_key_seq_num, tvb, hmac_offset, 1, ENC_BIG_ENDIAN);\r\nhmac_offset++;\r\nproto_tree_add_item(hmac_tree, hf_packet_number_counter, tvb, hmac_offset, 4, ENC_BIG_ENDIAN);\r\nhmac_offset += 4;\r\nproto_tree_add_item(hmac_tree, hf_hmac_tuple_hmac_digest, tvb, hmac_offset, length - offset - 3, ENC_NA);\r\n}\r\nvoid wimax_security_negotiation_parameters_decoder(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint offset;\r\nguint tvb_len, tlv_len, tlv_value_offset;\r\ngint tlv_type;\r\nproto_tree *tlv_tree;\r\nproto_item *tlv_item;\r\ntlv_info_t tlv_info;\r\ntvb_len = tvb_reported_length(tvb);\r\nif(!tvb_len)\r\nreturn;\r\nif(tvb_len < 2)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Invalid Security Negotiation Parameters");\r\nreturn;\r\n}\r\nfor(offset = 0; offset < tvb_len; )\r\n{\r\ninit_tlv_info(&tlv_info, tvb, offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\ntlv_len = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || tlv_len > MAX_TLV_LEN || tlv_len < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Security Negotiation Params TLV error");\r\nproto_tree_add_item(tree, hf_cst_invalid_tlv, tvb, offset, (tvb_len - offset), ENC_NA);\r\nbreak;\r\n}\r\ntlv_value_offset = get_tlv_value_offset(&tlv_info);\r\n#ifdef DEBUG\r\nproto_tree_add_protocol_format(tree, proto_wimax_utility_decoders, tvb, offset, (tlv_len + tlv_value_offset), "Security Negotiation Parameters Type: %u (%u bytes, offset=%u, tvb_len=%u)", tlv_type, (tlv_len + tlv_value_offset), offset, tvb_len);\r\n#endif\r\noffset += tlv_value_offset;\r\nswitch (tlv_type)\r\n{\r\ncase PKM_ATTR_SECURITY_NEGOTIATION_PARAMETER_SUB_PKM_VERSION_SUPPORT:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_snp_pkm_version_support, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_security_negotiation_parameters);\r\nproto_tree_add_item(tlv_tree, hf_snp_pkm_version_support_bit0, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_snp_pkm_version_support_bit1, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_snp_pkm_version_support_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_SECURITY_NEGOTIATION_PARAMETER_SUB_AUTHORIZATION_POLICY_SUPPORT:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_snp_auth_policy_support, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_security_negotiation_parameters);\r\nproto_tree_add_item(tlv_tree, hf_snp_auth_policy_support_bit0, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_snp_auth_policy_support_bit1, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_snp_auth_policy_support_bit2, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_snp_auth_policy_support_bit3, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_snp_auth_policy_support_bit4, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_snp_auth_policy_support_bit5, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_snp_auth_policy_support_bit6, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_snp_auth_policy_support_bit7, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_SECURITY_NEGOTIATION_PARAMETER_SUB_MESSAGE_AUTHENTICATION_CODE:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_snp_mac_mode, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_security_negotiation_parameters);\r\nproto_tree_add_item(tlv_tree, hf_snp_mac_mode_bit0, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif (include_cor2_changes)\r\n{\r\nproto_tree_add_item(tlv_tree, hf_snp_mac_mode_bit1_rsvd, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(tlv_tree, hf_snp_mac_mode_bit1, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(tlv_tree, hf_snp_mac_mode_bit2, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_snp_mac_mode_bit3, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_snp_mac_mode_bit4, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif (include_cor2_changes)\r\n{\r\nproto_tree_add_item(tlv_tree, hf_snp_mac_mode_bit5, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_snp_mac_mode_reserved1, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(tlv_tree, hf_snp_mac_mode_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase PKM_ATTR_SECURITY_NEGOTIATION_PARAMETER_SUB_PN_WINDOW_SIZE:\r\nadd_tlv_subtree(&tlv_info, tree, hf_snp_pn_window_size, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_SECURITY_NEGOTIATION_PARAMETER_SUB_PKM_FLOW_CONTROL:\r\nadd_tlv_subtree(&tlv_info, tree, hf_snp_max_conc_transactions, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_SECURITY_NEGOTIATION_PARAMETER_SUB_MAX_SUPPT_SECURITY_ASSNS:\r\nadd_tlv_subtree(&tlv_info, tree, hf_snp_max_suppt_sec_assns, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nadd_tlv_subtree(&tlv_info, tree, hf_snp_unknown_type, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\n}\r\noffset += tlv_len;\r\n}\r\n}\r\nvoid wimax_cryptographic_suite_list_decoder(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint offset;\r\nguint tvb_len, tlv_len, tlv_value_offset;\r\ngint tlv_type;\r\nproto_tree *tlv_tree;\r\nproto_item *tlv_item;\r\ntlv_info_t tlv_info;\r\ntvb_len = tvb_reported_length(tvb);\r\nif(!tvb_len)\r\nreturn;\r\nif(tvb_len < 2)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Invalid Crypto Suite List");\r\nreturn;\r\n}\r\nfor(offset = 0; offset < tvb_len; )\r\n{\r\ninit_tlv_info(&tlv_info, tvb, offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\ntlv_len = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || tlv_len > MAX_TLV_LEN || tlv_len < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Crypto Suite List TLV error");\r\nproto_tree_add_item(tree, hf_cst_invalid_tlv, tvb, offset, (tvb_len - offset), ENC_NA);\r\nbreak;\r\n}\r\ntlv_value_offset = get_tlv_value_offset(&tlv_info);\r\n#ifdef DEBUG\r\nproto_tree_add_protocol_format(tree, proto_wimax_utility_decoders, tvb, offset, (tlv_len + tlv_value_offset), "Cryptographic Suite List TLV Type: %u (%u bytes, offset=%u, tvb_len=%u)", tlv_type, (tlv_len + tlv_value_offset), offset, tvb_len);\r\n#endif\r\noffset += tlv_value_offset;\r\nswitch (tlv_type)\r\n{\r\ncase PKM_ATTR_CRYPTO_SUITE:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_pkm_msg_crypto_suite, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_cryptographic_suite_list_decoder);\r\nproto_tree_add_item(tlv_tree, hf_pkm_msg_crypto_suite_msb, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_pkm_msg_crypto_suite_middle, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_pkm_msg_crypto_suite_lsb, tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_unknown_type, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\n}\r\noffset += tlv_len;\r\n}\r\n}\r\nvoid wimax_pkm_tlv_encoded_attributes_decoder(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint offset;\r\nguint tvb_len, tlv_len, tlv_value_offset;\r\ngint tlv_type;\r\nproto_tree *tlv_tree;\r\nproto_item *tlv_item;\r\ntlv_info_t tlv_info;\r\ntvb_len = tvb_reported_length(tvb);\r\nif(!tvb_len)\r\nreturn;\r\nif(tvb_len < 2)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Invalid PKM TLV");\r\nreturn;\r\n}\r\nfor(offset = 0; offset < tvb_len; )\r\n{\r\ninit_tlv_info(&tlv_info, tvb, offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\ntlv_len = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || tlv_len > MAX_TLV_LEN || tlv_len < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "PKM TLV error");\r\nproto_tree_add_item(tree, hf_cst_invalid_tlv, tvb, offset, (tvb_len - offset), ENC_NA);\r\nbreak;\r\n}\r\ntlv_value_offset = get_tlv_value_offset(&tlv_info);\r\n#ifdef DEBUG\r\nproto_tree_add_protocol_format(tree, proto_wimax_utility_decoders, tvb, offset, (tlv_len + tlv_value_offset), "PKM TLV Encoded Attributes TLV Type: %u (%u bytes, offset=%u, tvb_len=%u)", tlv_type, (tlv_len + tlv_value_offset), offset, tvb_len);\r\n#endif\r\noffset += tlv_value_offset;\r\nswitch (tlv_type)\r\n{\r\ncase PKM_ATTR_DISPLAY_STRING:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_attr_display, tvb, offset-tlv_value_offset, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_AUTH_KEY:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_attr_auth_key, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_TEK:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_attr_tek, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_KEY_LIFE_TIME:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_attr_key_life_time, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_KEY_SEQ_NUM:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_attr_key_seq_num, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_HMAC_DIGEST:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_attr_hmac_digest, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_SAID:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_attr_said, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_TEK_PARAM:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_pkm_tlv_encoded_attributes_decoder, tree, proto_wimax_utility_decoders, tvb, offset-tlv_value_offset, tlv_len, "TEK Parameters");\r\nwimax_tek_parameters_decoder(tvb_new_subset_length(tvb, offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\ncase PKM_ATTR_CBC_IV:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_attr_cbc_iv, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_ERROR_CODE:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_attr_error_code, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_CA_CERTIFICATE:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_attr_ca_certificate, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_SS_CERTIFICATE:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_attr_ss_certificate, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_SECURITY_CAPABILITIES:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_pkm_tlv_encoded_attributes_decoder, tree, proto_wimax_utility_decoders, tvb, offset-tlv_value_offset, tlv_len, "Security Capabilities");\r\nwimax_security_capabilities_decoder(tvb_new_subset_length(tvb, offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\ncase PKM_ATTR_CRYPTO_SUITE:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_pkm_msg_crypto_suite, tvb, offset-tlv_value_offset, ENC_NA);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_pkm_tlv_encoded_attributes_decoder);\r\nproto_tree_add_item(tlv_tree, hf_pkm_msg_crypto_suite_msb, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_pkm_msg_crypto_suite_middle, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_pkm_msg_crypto_suite_lsb, tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_CRYPTO_LIST:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_pkm_tlv_encoded_attributes_decoder, tree, proto_wimax_utility_decoders, tvb, offset-tlv_value_offset, tlv_len, "Cryptographic-Suite List");\r\nwimax_cryptographic_suite_list_decoder(tvb_new_subset_length(tvb, offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\n#if 0\r\ncase PKM_ATTR_VERSION:\r\nproto_tree_add_item(tree, hf_pkm_msg_version, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\r\nbreak;\r\n#endif\r\ncase PKM_ATTR_SA_DESCRIPTOR:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_pkm_tlv_encoded_attributes_decoder, tree, proto_wimax_utility_decoders, tvb, offset-tlv_value_offset, tlv_len, "SA-Descriptor");\r\nwimax_sa_descriptor_decoder(tvb_new_subset_length(tvb, offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\ncase PKM_ATTR_SA_TYPE:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_sa_type, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_SECURITY_NEGOTIATION_PARAMETERS:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_pkm_tlv_encoded_attributes_decoder, tree, proto_wimax_utility_decoders, tvb, offset-tlv_value_offset, tlv_len, "Security Negotiation Parameters");\r\nwimax_security_negotiation_parameters_decoder(tvb_new_subset_length(tvb, offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\ncase PKM_ATTR_PKM_CONFIG_SETTINGS:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_pkm_tlv_encoded_attributes_decoder, tree, proto_wimax_utility_decoders, tvb, offset-tlv_value_offset, tlv_len, "PKM Configuration Settings");\r\nwimax_pkm_configuration_settings_decoder(tvb_new_subset_length(tvb, offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\ncase PKM_ATTR_PKM_EAP_PAYLOAD:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_pkm_attr_eap_payload, tvb, offset-tlv_value_offset, ENC_NA);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_pkm_tlv_encoded_attributes_decoder);\r\nif (eap_handle)\r\ncall_dissector(eap_handle, tvb_new_subset_length(tvb, offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\ncase PKM_ATTR_PKM_NONCE:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_nonce, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_AUTH_RESULT_CODE:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_auth_result_code, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_SA_SERVICE_TYPE:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_sa_service_type, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_FRAME_NUMBER:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_frame_number, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_SS_RANDOM:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_ss_random, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_BS_RANDOM:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_bs_random, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_PRE_PAK:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_pre_pak, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_BS_CERTIFICATE:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_bs_certificate, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_SIG_BS:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_sig_bs, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_MS_MAC_ADDRESS:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_ms_mac_address, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_CMAC_DIGEST:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_pkm_attr_cmac_digest, tvb, offset-tlv_value_offset, ENC_NA);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_pkm_tlv_encoded_attributes_decoder);\r\nproto_tree_add_item(tlv_tree, hf_pkm_attr_cmac_digest_pn, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_pkm_attr_cmac_digest_value, tvb, (offset + 4), 8, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_KEY_PUSH_MODES:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_push_modes, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_KEY_PUSH_COUNTER:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_key_push_counter, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_GKEK:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_gkek, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_SIG_SS:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_sig_ss, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_AKID:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_akid, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ndefault:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_unknown_type, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\n}\r\noffset += tlv_len;\r\n}\r\n}\r\nvoid wimax_tek_parameters_decoder(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint offset;\r\nguint tvb_len, tlv_len, tlv_value_offset;\r\ngint tlv_type;\r\ntlv_info_t tlv_info;\r\ntvb_len = tvb_reported_length(tvb);\r\nif(!tvb_len)\r\nreturn;\r\nif(tvb_len < 2)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Invalid TEK Params");\r\nreturn;\r\n}\r\nfor(offset = 0; offset < tvb_len; )\r\n{\r\ninit_tlv_info(&tlv_info, tvb, offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\ntlv_len = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || tlv_len > MAX_TLV_LEN || tlv_len < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "TEK Param TLV error");\r\nproto_tree_add_item(tree, hf_cst_invalid_tlv, tvb, offset, (tvb_len - offset), ENC_NA);\r\nbreak;\r\n}\r\ntlv_value_offset = get_tlv_value_offset(&tlv_info);\r\n#ifdef DEBUG\r\nproto_tree_add_protocol_format(tree, proto_wimax_utility_decoders, tvb, offset, (tlv_len + tlv_value_offset), "TEK Parameters Subattributes TLV Type: %u (%u bytes, offset=%u, tvb_len=%u)", tlv_type, (tlv_len + tlv_value_offset), offset, tvb_len);\r\n#endif\r\nswitch (tlv_type)\r\n{\r\ncase PKM_ATTR_TEK:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_attr_tek, tvb, offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_KEY_LIFE_TIME:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_attr_key_life_time, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_KEY_SEQ_NUM:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_attr_key_seq_num, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_CBC_IV:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_attr_cbc_iv, tvb, offset, ENC_NA);\r\nbreak;\r\ncase PKM_ATTR_ASSOCIATED_GKEK_SEQ_NUM:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_associated_gkek_seq_number, tvb, offset, ENC_NA);\r\nbreak;\r\ndefault:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_unknown_type, tvb, offset, ENC_NA);\r\nbreak;\r\n}\r\noffset += (tlv_len+tlv_value_offset);\r\n}\r\n}\r\nvoid wimax_pkm_configuration_settings_decoder(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint offset;\r\nguint tvb_len, tlv_len, tlv_value_offset;\r\ngint tlv_type;\r\ntlv_info_t tlv_info;\r\ntvb_len = tvb_reported_length(tvb);\r\nif(!tvb_len)\r\nreturn;\r\nif(tvb_len < 2)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Invalid PKM Config Settings");\r\nreturn;\r\n}\r\nfor(offset = 0; offset < tvb_len; )\r\n{\r\ninit_tlv_info(&tlv_info, tvb, offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\ntlv_len = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || tlv_len > MAX_TLV_LEN || tlv_len < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "PKM Config Settings TLV error");\r\nproto_tree_add_item(tree, hf_cst_invalid_tlv, tvb, offset, (tvb_len - offset), ENC_NA);\r\nbreak;\r\n}\r\ntlv_value_offset = get_tlv_value_offset(&tlv_info);\r\n#ifdef DEBUG\r\nproto_tree_add_protocol_format(tree, proto_wimax_utility_decoders, tvb, offset, (tlv_len + tlv_value_offset), "PKM Configuration Settings TLV Type: %u (%u bytes, offset=%u, tvb_len=%u)", tlv_type, (tlv_len + tlv_value_offset), offset, tvb_len);\r\n#endif\r\nswitch (tlv_type)\r\n{\r\ncase PKM_ATTR_PKM_CONFIG_SETTINGS_AUTHORIZE_WAIT_TIMEOUT:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_config_settings_authorize_waitout, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_PKM_CONFIG_SETTINGS_REAUTHORIZE_WAIT_TIMEOUT:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_config_settings_reauthorize_waitout, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_PKM_CONFIG_SETTINGS_AUTHORIZATION_GRACE_TIME:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_config_settings_grace_time, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_PKM_CONFIG_SETTINGS_OPERATIONAL_WAIT_TIMEOUT:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_config_settings_operational_waittime, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_PKM_CONFIG_SETTINGS_REKEY_WAIT_TIMEOUT:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_config_settings_rekey_wait_timeout, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_PKM_CONFIG_SETTINGS_TEK_GRACE_TIME:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_config_settings_tek_grace_time, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_PKM_CONFIG_SETTINGS_AUTHORIZE_REJECT_WAIT_TIMEOUT:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_config_settings_authorize_reject_wait_timeout, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_unknown_type, tvb, offset, ENC_NA);\r\nbreak;\r\n}\r\noffset += (tlv_len+tlv_value_offset);\r\n}\r\n}\r\nvoid wimax_sa_descriptor_decoder(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint offset;\r\nguint tvb_len, tlv_len, tlv_value_offset;\r\ngint tlv_type;\r\nproto_tree *tlv_tree;\r\nproto_item *tlv_item;\r\ntlv_info_t tlv_info;\r\ntvb_len = tvb_reported_length(tvb);\r\nif(!tvb_len)\r\nreturn;\r\nif(tvb_len < 2)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Invalid SA-Descriptor");\r\nreturn;\r\n}\r\nfor(offset = 0; offset < tvb_len; )\r\n{\r\ninit_tlv_info(&tlv_info, tvb, offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\ntlv_len = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || tlv_len > MAX_TLV_LEN || tlv_len < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "SA-Descriptor TLV error");\r\nproto_tree_add_item(tree, hf_cst_invalid_tlv, tvb, offset, (tvb_len - offset), ENC_NA);\r\nbreak;\r\n}\r\ntlv_value_offset = get_tlv_value_offset(&tlv_info);\r\n#ifdef DEBUG\r\nproto_tree_add_protocol_format(tree, proto_wimax_utility_decoders, tvb, offset, (tlv_len + tlv_value_offset), "SA-Descriptor TLV Type: %u (%u bytes, offset=%u, tvb_len=%u)", tlv_type, (tlv_len + tlv_value_offset), offset, tvb_len);\r\n#endif\r\noffset += tlv_value_offset;\r\nswitch (tlv_type)\r\n{\r\ncase PKM_ATTR_SAID:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_attr_said, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_SA_TYPE:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_sa_type, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_SA_SERVICE_TYPE:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_attr_sa_service_type, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase PKM_ATTR_CRYPTO_SUITE:\r\ntlv_item = add_tlv_subtree(&tlv_info, tree, hf_pkm_msg_crypto_suite, tvb, offset-tlv_value_offset, ENC_NA);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_sa_descriptor_decoder);\r\nproto_tree_add_item(tlv_tree, hf_pkm_msg_crypto_suite_msb, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_pkm_msg_crypto_suite_middle, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_pkm_msg_crypto_suite_lsb, tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_unknown_type, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\n}\r\noffset += tlv_len;\r\n}\r\n}\r\nvoid wimax_security_capabilities_decoder(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint offset;\r\nguint tvb_len, tlv_len, tlv_value_offset;\r\ngint tlv_type;\r\nproto_tree *tlv_tree = NULL;\r\ntlv_info_t tlv_info;\r\ntvb_len = tvb_reported_length(tvb);\r\nif(!tvb_len)\r\nreturn;\r\nif(tvb_len < 2)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Invalid Security Capabilities");\r\nreturn;\r\n}\r\nfor(offset = 0; offset < tvb_len; )\r\n{\r\ninit_tlv_info(&tlv_info, tvb, offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\ntlv_len = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || tlv_len > MAX_TLV_LEN || tlv_len < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Security Capabilities TLV error");\r\nproto_tree_add_item(tree, hf_cst_invalid_tlv, tvb, offset, (tvb_len - offset), ENC_NA);\r\nbreak;\r\n}\r\ntlv_value_offset = get_tlv_value_offset(&tlv_info);\r\n#ifdef DEBUG\r\nproto_tree_add_protocol_format(tree, proto_wimax_utility_decoders, tvb, offset, (tlv_len + tlv_value_offset), "Security Capabilities TLV Type: %u (%u bytes, offset=%u, tvb_len=%u)", tlv_type, (tlv_len + tlv_value_offset), offset, tvb_len);\r\n#endif\r\nswitch (tlv_type)\r\n{\r\ncase PKM_ATTR_CRYPTO_LIST:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_security_capabilities_decoder, tree, proto_wimax_utility_decoders, tvb, offset, tlv_len, "Cryptographic-Suite List");\r\nwimax_cryptographic_suite_list_decoder(tvb_new_subset_length(tvb, offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\ndefault:\r\nadd_tlv_subtree(&tlv_info, tree, hf_pkm_msg_unknown_type, tvb, offset, ENC_NA);\r\nbreak;\r\n}\r\noffset += (tlv_len+tlv_value_offset);\r\n}\r\n}\r\nvoid wimax_vendor_specific_information_decoder(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint offset;\r\nguint tvb_len, tlv_len, tlv_value_offset;\r\ngint tlv_type;\r\ntlv_info_t tlv_info;\r\ntvb_len = tvb_reported_length(tvb);\r\nif(!tvb_len)\r\nreturn;\r\nif(tvb_len < 2)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Invalid Vendor Specific Info");\r\nproto_tree_add_expert(tree, pinfo, &ei_common_tlv_info, tvb, 0, tvb_len);\r\nreturn;\r\n}\r\nfor(offset = 0; offset < tvb_len; )\r\n{\r\ninit_tlv_info(&tlv_info, tvb, offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\ntlv_len = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || tlv_len > MAX_TLV_LEN || tlv_len < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Vendor Specific Info TLV error");\r\nproto_tree_add_item(tree, hf_cst_invalid_tlv, tvb, offset, (tvb_len - offset), ENC_NA);\r\nbreak;\r\n}\r\ntlv_value_offset = get_tlv_value_offset(&tlv_info);\r\n#ifdef DEBUG\r\nproto_tree_add_protocol_format(tree, proto_wimax_utility_decoders, tvb, offset, (tlv_len + tlv_value_offset), "Vendor Specific Info TLV Type: %u (%u bytes, offset=%u, tvb_len=%u)", tlv_type, (tlv_len + tlv_value_offset), offset, tvb_len);\r\n#endif\r\nif(tlv_type == VENDOR_ID_ENCODING)\r\n{\r\nadd_tlv_subtree(&tlv_info, tree, hf_common_tlv_vendor_id, tvb, offset, ENC_NA);\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(tree, hf_common_tlv_vendor_specific_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif(get_tlv_length_type(&tlv_info) == 0)\r\n{\r\nproto_tree_add_item(tree, hf_common_tlv_vendor_specific_length, tvb, (offset + 1), 1, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(tree, hf_common_tlv_vendor_specific_length_size, tvb, (offset + 1), 1, ENC_BIG_ENDIAN);\r\nif(get_tlv_size_of_length(&tlv_info))\r\n{\r\nproto_tree_add_uint(tree, hf_common_tlv_vendor_specific_length, tvb, (offset + 2), 1, get_tlv_size_of_length(&tlv_info));\r\n}\r\nelse\r\n{\r\ncontinue;\r\n}\r\n}\r\nproto_tree_add_item(tree, hf_common_tlv_vendor_specific_value, tvb, (offset + tlv_value_offset), tlv_len, ENC_NA);\r\n}\r\noffset += tlv_value_offset + tlv_len;\r\n}\r\n}\r\nguint wimax_common_tlv_encoding_decoder(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint offset, value;\r\nguint tvb_len, tlv_len, tlv_value_offset;\r\ngint tlv_type;\r\nproto_tree *tlv_tree = NULL;\r\ntlv_info_t tlv_info;\r\ngfloat current_power;\r\ntvb_len = tvb_reported_length(tvb);\r\nif(!tvb_len)\r\nreturn 0;\r\nif(tvb_len < 2)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Invalid Common TLV encoding");\r\nproto_tree_add_item(tree, hf_cst_invalid_tlv, tvb, 0, tvb_len, ENC_NA);\r\nreturn 0;\r\n}\r\nfor(offset = 0; offset < tvb_len; )\r\n{\r\ninit_tlv_info(&tlv_info, tvb, offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\ntlv_len = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || tlv_len > MAX_TLV_LEN || tlv_len < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Common TLV encoding TLV error");\r\nproto_tree_add_item(tree, hf_cst_invalid_tlv, tvb, offset, (tvb_len - offset), ENC_NA);\r\nbreak;\r\n}\r\ntlv_value_offset = get_tlv_value_offset(&tlv_info);\r\n#ifdef DEBUG\r\nproto_tree_add_protocol_format(tree, proto_wimax_utility_decoders, tvb, offset, (tlv_len + tlv_value_offset), "Common TLV Encoding TLV Type: %u (%u bytes, offset=%u, tvb_len=%u)", tlv_type, (tlv_len + tlv_value_offset), offset, tvb_len);\r\n#endif\r\noffset += tlv_value_offset;\r\nswitch (tlv_type)\r\n{\r\ncase VENDOR_SPECIFIC_INFO:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_vendor_specific_info_decoder, tree, proto_wimax_utility_decoders, tvb, offset-tlv_value_offset, tlv_len, "Vendor-Specific Information");\r\nwimax_vendor_specific_information_decoder(tvb_new_subset_length(tvb, offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\ncase VENDOR_ID_ENCODING:\r\nadd_tlv_subtree(&tlv_info, tree, hf_common_tlv_vendor_id, tvb, offset-tlv_value_offset, ENC_NA);\r\nbreak;\r\ncase DSx_UPLINK_FLOW:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_ul_service_flow_decoder, tree, proto_wimax_utility_decoders, tvb, offset-tlv_value_offset, tlv_len, "Uplink Service Flow Encodings");\r\nwimax_service_flow_encodings_decoder(tvb_new_subset_length(tvb, offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\ncase DSx_DOWNLINK_FLOW:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_dl_service_flow_decoder, tree, proto_wimax_utility_decoders, tvb, offset-tlv_value_offset, tlv_len, "Downlink Service Flow Encodings");\r\nwimax_service_flow_encodings_decoder(tvb_new_subset_length(tvb,offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\ncase CURRENT_TX_POWER:\r\ntlv_tree = add_tlv_subtree_no_item(&tlv_info, tree, hf_common_current_transmitted_power, tvb, offset-tlv_value_offset);\r\nvalue = tvb_get_guint8(tvb, offset);\r\ncurrent_power = (gfloat)((value - 128) / 2.0);\r\nproto_tree_add_float_format_value(tlv_tree, hf_common_current_transmitted_power, tvb, offset, tvb_len, current_power, "%.2f dBm (Value: 0x%x)", current_power, value);\r\nbreak;\r\ncase MAC_VERSION_ENCODING:\r\nadd_tlv_subtree(&tlv_info, tree, hf_common_tlv_mac_version, tvb, offset-tlv_value_offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase HMAC_TUPLE:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_vendor_specific_info_decoder, tree, proto_wimax_utility_decoders, tvb, offset-tlv_value_offset, tlv_len, "HMAC Tuple");\r\nwimax_hmac_tuple_decoder(tlv_tree, tvb, offset, tlv_len);\r\nbreak;\r\ncase CMAC_TUPLE:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_vendor_specific_info_decoder, tree, proto_wimax_utility_decoders, tvb, offset-tlv_value_offset, tlv_len, "CMAC Tuple");\r\nwimax_cmac_tuple_decoder(tlv_tree, tvb, offset, tlv_len);\r\nbreak;\r\ndefault:\r\nreturn offset - tlv_value_offset;\r\nbreak;\r\n}\r\noffset += tlv_len;\r\n}\r\nreturn offset;\r\n}
