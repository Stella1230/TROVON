static void permute(char *out, const char *in, const uchar *p, int n)\r\n{\r\nint i;\r\nfor (i=0;i<n;i++)\r\nout[i] = in[p[i]-1];\r\n}\r\nstatic void lshift(char *d, int count, int n)\r\n{\r\nchar out[64];\r\nint i;\r\nfor (i=0;i<n;i++)\r\nout[i] = d[(i+count)%n];\r\nfor (i=0;i<n;i++)\r\nd[i] = out[i];\r\n}\r\nstatic void concat(char *out, char *in1, char *in2, int l1, int l2)\r\n{\r\nwhile (l1--)\r\n*out++ = *in1++;\r\nwhile (l2--)\r\n*out++ = *in2++;\r\n}\r\nstatic void exor(char *out, char *in1, char *in2, int n)\r\n{\r\nint i;\r\nfor (i=0;i<n;i++)\r\nout[i] = in1[i] ^ in2[i];\r\n}\r\nstatic void dohash(char *out, char *in, char *key, int forw)\r\n{\r\nint i, j, k;\r\nchar pk1[56];\r\nchar c[28];\r\nchar d[28];\r\nchar cd[56];\r\nchar ki[16][48];\r\nchar pd1[64];\r\nchar l[32], r[32];\r\nchar rl[64];\r\npermute(pk1, key, perm1, 56);\r\nfor (i=0;i<28;i++)\r\nc[i] = pk1[i];\r\nfor (i=0;i<28;i++)\r\nd[i] = pk1[i+28];\r\nfor (i=0;i<16;i++) {\r\nlshift(c, sc[i], 28);\r\nlshift(d, sc[i], 28);\r\nconcat(cd, c, d, 28, 28);\r\npermute(ki[i], cd, perm2, 48);\r\n}\r\npermute(pd1, in, perm3, 64);\r\nfor (j=0;j<32;j++) {\r\nl[j] = pd1[j];\r\nr[j] = pd1[j+32];\r\n}\r\nfor (i=0;i<16;i++) {\r\nchar er[48];\r\nchar erk[48];\r\nchar b[8][6];\r\nchar cb[32];\r\nchar pcb[32];\r\nchar r2[32];\r\npermute(er, r, perm4, 48);\r\nexor(erk, er, ki[forw ? i : 15 - i], 48);\r\nfor (j=0;j<8;j++)\r\nfor (k=0;k<6;k++)\r\nb[j][k] = erk[j*6 + k];\r\nfor (j=0;j<8;j++) {\r\nint m, n;\r\nm = (b[j][0]<<1) | b[j][5];\r\nn = (b[j][1]<<3) | (b[j][2]<<2) | (b[j][3]<<1) | b[j][4];\r\nfor (k=0;k<4;k++)\r\nb[j][k] = (sbox[j][m][n] & (1<<(3-k)))?1:0;\r\n}\r\nfor (j=0;j<8;j++)\r\nfor (k=0;k<4;k++)\r\ncb[j*4+k] = b[j][k];\r\npermute(pcb, cb, perm5, 32);\r\nexor(r2, l, pcb, 32);\r\nfor (j=0;j<32;j++)\r\nl[j] = r[j];\r\nfor (j=0;j<32;j++)\r\nr[j] = r2[j];\r\n}\r\nconcat(rl, r, l, 32, 32);\r\npermute(out, rl, perm6, 64);\r\n}\r\nstatic void str_to_key(const unsigned char *str,unsigned char *key)\r\n{\r\nint i;\r\nkey[0] = str[0]>>1;\r\nkey[1] = ((str[0]&0x01)<<6) | (str[1]>>2);\r\nkey[2] = ((str[1]&0x03)<<5) | (str[2]>>3);\r\nkey[3] = ((str[2]&0x07)<<4) | (str[3]>>4);\r\nkey[4] = ((str[3]&0x0F)<<3) | (str[4]>>5);\r\nkey[5] = ((str[4]&0x1F)<<2) | (str[5]>>6);\r\nkey[6] = ((str[5]&0x3F)<<1) | (str[6]>>7);\r\nkey[7] = str[6]&0x7F;\r\nfor (i=0;i<8;i++) {\r\nkey[i] = (key[i]<<1);\r\n}\r\n}\r\nvoid crypt_des_ecb(unsigned char *out, const unsigned char *in, const unsigned char *key, int forw)\r\n{\r\nint i;\r\nchar outb[64];\r\nchar inb[64];\r\nchar keyb[64];\r\nunsigned char key2[8];\r\nstr_to_key(key, key2);\r\nfor (i=0;i<64;i++) {\r\ninb[i] = (in[i/8] & (1<<(7-(i%8)))) ? 1 : 0;\r\nkeyb[i] = (key2[i/8] & (1<<(7-(i%8)))) ? 1 : 0;\r\noutb[i] = 0;\r\n}\r\ndohash(outb, inb, keyb, forw);\r\nfor (i=0;i<8;i++) {\r\nout[i] = 0;\r\n}\r\nfor (i=0;i<64;i++) {\r\nif (outb[i])\r\nout[i/8] |= (1<<(7-(i%8)));\r\n}\r\n}
