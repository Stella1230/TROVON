const gchar *\r\nval_to_str(const guint32 val, const value_string *vs, const char *fmt)\r\n{\r\nconst gchar *ret;\r\nDISSECTOR_ASSERT(fmt != NULL);\r\nret = try_val_to_str(val, vs);\r\nif (ret != NULL)\r\nreturn ret;\r\nreturn wmem_strdup_printf(wmem_packet_scope(), fmt, val);\r\n}\r\ngchar *\r\nval_to_str_wmem(wmem_allocator_t *scope, const guint32 val, const value_string *vs, const char *fmt)\r\n{\r\nconst gchar *ret;\r\nDISSECTOR_ASSERT(fmt != NULL);\r\nret = try_val_to_str(val, vs);\r\nif (ret != NULL)\r\nreturn wmem_strdup(scope, ret);\r\nreturn wmem_strdup_printf(scope, fmt, val);\r\n}\r\nconst gchar *\r\nval_to_str_const(const guint32 val, const value_string *vs,\r\nconst char *unknown_str)\r\n{\r\nconst gchar *ret;\r\nDISSECTOR_ASSERT(unknown_str != NULL);\r\nret = try_val_to_str(val, vs);\r\nif (ret != NULL)\r\nreturn ret;\r\nreturn unknown_str;\r\n}\r\nconst gchar *\r\ntry_val_to_str_idx(const guint32 val, const value_string *vs, gint *idx)\r\n{\r\ngint i = 0;\r\nDISSECTOR_ASSERT(idx != NULL);\r\nif(vs) {\r\nwhile (vs[i].strptr) {\r\nif (vs[i].value == val) {\r\n*idx = i;\r\nreturn(vs[i].strptr);\r\n}\r\ni++;\r\n}\r\n}\r\n*idx = -1;\r\nreturn NULL;\r\n}\r\nconst gchar *\r\ntry_val_to_str(const guint32 val, const value_string *vs)\r\n{\r\ngint ignore_me;\r\nreturn try_val_to_str_idx(val, vs, &ignore_me);\r\n}\r\nconst gchar *\r\nval64_to_str(const guint64 val, const val64_string *vs, const char *fmt)\r\n{\r\nconst gchar *ret;\r\nDISSECTOR_ASSERT(fmt != NULL);\r\nret = try_val64_to_str(val, vs);\r\nif (ret != NULL)\r\nreturn ret;\r\nreturn wmem_strdup_printf(wmem_packet_scope(), fmt, val);\r\n}\r\nconst gchar *\r\nval64_to_str_const(const guint64 val, const val64_string *vs,\r\nconst char *unknown_str)\r\n{\r\nconst gchar *ret;\r\nDISSECTOR_ASSERT(unknown_str != NULL);\r\nret = try_val64_to_str(val, vs);\r\nif (ret != NULL)\r\nreturn ret;\r\nreturn unknown_str;\r\n}\r\nconst gchar *\r\ntry_val64_to_str_idx(const guint64 val, const val64_string *vs, gint *idx)\r\n{\r\ngint i = 0;\r\nDISSECTOR_ASSERT(idx != NULL);\r\nif(vs) {\r\nwhile (vs[i].strptr) {\r\nif (vs[i].value == val) {\r\n*idx = i;\r\nreturn(vs[i].strptr);\r\n}\r\ni++;\r\n}\r\n}\r\n*idx = -1;\r\nreturn NULL;\r\n}\r\nconst gchar *\r\ntry_val64_to_str(const guint64 val, const val64_string *vs)\r\n{\r\ngint ignore_me;\r\nreturn try_val64_to_str_idx(val, vs, &ignore_me);\r\n}\r\nguint32\r\nstr_to_val(const gchar *val, const value_string *vs, const guint32 err_val)\r\n{\r\ngint i;\r\ni = str_to_val_idx(val, vs);\r\nif (i >= 0) {\r\nreturn vs[i].value;\r\n}\r\nreturn err_val;\r\n}\r\ngint\r\nstr_to_val_idx(const gchar *val, const value_string *vs)\r\n{\r\ngint i = 0;\r\nif(vs) {\r\nwhile (vs[i].strptr) {\r\nif (strcmp(vs[i].strptr, val) == 0) {\r\nreturn i;\r\n}\r\ni++;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nvalue_string_ext *\r\nvalue_string_ext_new(const value_string *vs, guint vs_tot_num_entries,\r\nconst gchar *vs_name)\r\n{\r\nvalue_string_ext *vse;\r\nDISSECTOR_ASSERT (vs_name != NULL);\r\nDISSECTOR_ASSERT (vs_tot_num_entries > 0);\r\nDISSECTOR_ASSERT (vs[vs_tot_num_entries-1].strptr == NULL);\r\nvse = wmem_new(wmem_epan_scope(), value_string_ext);\r\nvse->_vs_p = vs;\r\nvse->_vs_num_entries = vs_tot_num_entries - 1;\r\nvse->_vs_first_value = 0;\r\nvse->_vs_match2 = _try_val_to_str_ext_init;\r\nvse->_vs_name = vs_name;\r\nreturn vse;\r\n}\r\nvoid\r\nvalue_string_ext_free(const value_string_ext *vse)\r\n{\r\nwmem_free(wmem_epan_scope(), (void *)vse);\r\n}\r\nconst gchar *\r\ntry_val_to_str_ext(const guint32 val, value_string_ext *vse)\r\n{\r\nif (vse) {\r\nconst value_string *vs = vse->_vs_match2(val, vse);\r\nif (vs) {\r\nreturn vs->strptr;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nconst gchar *\r\ntry_val_to_str_idx_ext(const guint32 val, value_string_ext *vse, gint *idx)\r\n{\r\nif (vse) {\r\nconst value_string *vs = vse->_vs_match2(val, vse);\r\nif (vs) {\r\n*idx = (gint) (vs - vse->_vs_p);\r\nreturn vs->strptr;\r\n}\r\n}\r\n*idx = -1;\r\nreturn NULL;\r\n}\r\nconst gchar *\r\nval_to_str_ext(const guint32 val, value_string_ext *vse, const char *fmt)\r\n{\r\nconst gchar *ret;\r\nDISSECTOR_ASSERT(fmt != NULL);\r\nret = try_val_to_str_ext(val, vse);\r\nif (ret != NULL)\r\nreturn ret;\r\nreturn wmem_strdup_printf(wmem_packet_scope(), fmt, val);\r\n}\r\ngchar *\r\nval_to_str_ext_wmem(wmem_allocator_t *scope, const guint32 val, value_string_ext *vse, const char *fmt)\r\n{\r\nconst gchar *ret;\r\nDISSECTOR_ASSERT(fmt != NULL);\r\nret = try_val_to_str_ext(val, vse);\r\nif (ret != NULL)\r\nreturn wmem_strdup(scope, ret);\r\nreturn wmem_strdup_printf(scope, fmt, val);\r\n}\r\nconst gchar *\r\nval_to_str_ext_const(const guint32 val, value_string_ext *vse,\r\nconst char *unknown_str)\r\n{\r\nconst gchar *ret;\r\nDISSECTOR_ASSERT(unknown_str != NULL);\r\nret = try_val_to_str_ext(val, vse);\r\nif (ret != NULL)\r\nreturn ret;\r\nreturn unknown_str;\r\n}\r\nstatic const value_string *\r\n_try_val_to_str_linear(const guint32 val, value_string_ext *vse)\r\n{\r\nconst value_string *vs_p = vse->_vs_p;\r\nguint i;\r\nfor (i=0; i<vse->_vs_num_entries; i++) {\r\nif (vs_p[i].value == val)\r\nreturn &(vs_p[i]);\r\n}\r\nreturn NULL;\r\n}\r\nstatic const value_string *\r\n_try_val_to_str_index(const guint32 val, value_string_ext *vse)\r\n{\r\nguint i;\r\ni = val - vse->_vs_first_value;\r\nif (i < vse->_vs_num_entries) {\r\ng_assert (val == vse->_vs_p[i].value);\r\nreturn &(vse->_vs_p[i]);\r\n}\r\nreturn NULL;\r\n}\r\nstatic const value_string *\r\n_try_val_to_str_bsearch(const guint32 val, value_string_ext *vse)\r\n{\r\nguint low, i, max;\r\nguint32 item;\r\nfor (low = 0, max = vse->_vs_num_entries; low < max; ) {\r\ni = (low + max) / 2;\r\nitem = vse->_vs_p[i].value;\r\nif (val < item)\r\nmax = i;\r\nelse if (val > item)\r\nlow = i + 1;\r\nelse\r\nreturn &(vse->_vs_p[i]);\r\n}\r\nreturn NULL;\r\n}\r\nconst value_string *\r\n_try_val_to_str_ext_init(const guint32 val, value_string_ext *vse)\r\n{\r\nconst value_string *vs_p = vse->_vs_p;\r\nconst guint vs_num_entries = vse->_vs_num_entries;\r\nenum { VS_SEARCH, VS_BIN_TREE, VS_INDEX } type = VS_INDEX;\r\nguint32 prev_value;\r\nguint first_value;\r\nguint i;\r\nDISSECTOR_ASSERT((vs_p[vs_num_entries].value == 0) &&\r\n(vs_p[vs_num_entries].strptr == NULL));\r\nvse->_vs_first_value = vs_p[0].value;\r\nfirst_value = vs_p[0].value;\r\nprev_value = first_value;\r\nfor (i = 0; i < vs_num_entries; i++) {\r\nDISSECTOR_ASSERT(vs_p[i].strptr != NULL);\r\nif ((type == VS_INDEX) && (vs_p[i].value != (i + first_value))) {\r\ntype = VS_BIN_TREE;\r\n}\r\nif (type == VS_BIN_TREE) {\r\nif (prev_value > vs_p[i].value) {\r\ng_warning("Extended value string '%s' forced to fall back to linear search:\n"\r\n" entry %u, value %u [%#x] < previous entry, value %u [%#x]",\r\nvse->_vs_name, i, vs_p[i].value, vs_p[i].value, prev_value, prev_value);\r\ntype = VS_SEARCH;\r\nbreak;\r\n}\r\nif (first_value > vs_p[i].value) {\r\ng_warning("Extended value string '%s' forced to fall back to linear search:\n"\r\n" entry %u, value %u [%#x] < first entry, value %u [%#x]",\r\nvse->_vs_name, i, vs_p[i].value, vs_p[i].value, first_value, first_value);\r\ntype = VS_SEARCH;\r\nbreak;\r\n}\r\n}\r\nprev_value = vs_p[i].value;\r\n}\r\nswitch (type) {\r\ncase VS_SEARCH:\r\nvse->_vs_match2 = _try_val_to_str_linear;\r\nbreak;\r\ncase VS_BIN_TREE:\r\nvse->_vs_match2 = _try_val_to_str_bsearch;\r\nbreak;\r\ncase VS_INDEX:\r\nvse->_vs_match2 = _try_val_to_str_index;\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\nreturn vse->_vs_match2(val, vse);\r\n}\r\nconst gchar *\r\nstr_to_str(const gchar *val, const string_string *vs, const char *fmt)\r\n{\r\nconst gchar *ret;\r\nDISSECTOR_ASSERT(fmt != NULL);\r\nret = try_str_to_str(val, vs);\r\nif (ret != NULL)\r\nreturn ret;\r\nreturn wmem_strdup_printf(wmem_packet_scope(), fmt, val);\r\n}\r\nconst gchar *\r\ntry_str_to_str_idx(const gchar *val, const string_string *vs, gint *idx)\r\n{\r\ngint i = 0;\r\nif(vs) {\r\nwhile (vs[i].strptr) {\r\nif (!strcmp(vs[i].value,val)) {\r\n*idx = i;\r\nreturn(vs[i].strptr);\r\n}\r\ni++;\r\n}\r\n}\r\n*idx = -1;\r\nreturn NULL;\r\n}\r\nconst gchar *\r\ntry_str_to_str(const gchar *val, const string_string *vs)\r\n{\r\ngint ignore_me;\r\nreturn try_str_to_str_idx(val, vs, &ignore_me);\r\n}\r\nconst gchar *\r\nrval_to_str(const guint32 val, const range_string *rs, const char *fmt)\r\n{\r\nconst gchar *ret = NULL;\r\nDISSECTOR_ASSERT(fmt != NULL);\r\nret = try_rval_to_str(val, rs);\r\nif(ret != NULL)\r\nreturn ret;\r\nreturn wmem_strdup_printf(wmem_packet_scope(), fmt, val);\r\n}\r\nconst gchar *\r\nrval_to_str_const(const guint32 val, const range_string *rs,\r\nconst char *unknown_str)\r\n{\r\nconst gchar *ret = NULL;\r\nDISSECTOR_ASSERT(unknown_str != NULL);\r\nret = try_rval_to_str(val, rs);\r\nif(ret != NULL)\r\nreturn ret;\r\nreturn unknown_str;\r\n}\r\nconst gchar *\r\ntry_rval_to_str_idx(const guint32 val, const range_string *rs, gint *idx)\r\n{\r\ngint i = 0;\r\nif(rs) {\r\nwhile(rs[i].strptr) {\r\nif( (val >= rs[i].value_min) && (val <= rs[i].value_max) ) {\r\n*idx = i;\r\nreturn (rs[i].strptr);\r\n}\r\ni++;\r\n}\r\n}\r\n*idx = -1;\r\nreturn NULL;\r\n}\r\nconst gchar *\r\ntry_rval_to_str(const guint32 val, const range_string *rs)\r\n{\r\ngint ignore_me = 0;\r\nreturn try_rval_to_str_idx(val, rs, &ignore_me);\r\n}\r\ngboolean\r\nvalue_string_ext_validate(const value_string_ext *vse)\r\n{\r\nif (vse == NULL)\r\nreturn FALSE;\r\n#ifndef _WIN32\r\nif ((vse->_vs_match2 != _try_val_to_str_ext_init) &&\r\n(vse->_vs_match2 != _try_val_to_str_linear) &&\r\n(vse->_vs_match2 != _try_val_to_str_bsearch) &&\r\n(vse->_vs_match2 != _try_val_to_str_index))\r\nreturn FALSE;\r\n#endif\r\nreturn TRUE;\r\n}\r\nconst gchar *\r\nvalue_string_ext_match_type_str(const value_string_ext *vse)\r\n{\r\nif (vse->_vs_match2 == _try_val_to_str_ext_init)\r\nreturn "[Not Initialized]";\r\nif (vse->_vs_match2 == _try_val_to_str_linear)\r\nreturn "[Linear Search]";\r\nif (vse->_vs_match2 == _try_val_to_str_bsearch)\r\nreturn "[Binary Search]";\r\nif (vse->_vs_match2 == _try_val_to_str_index)\r\nreturn "[Direct (indexed) Access]";\r\nreturn "[Invalid]";\r\n}
