int display_ms_string(tvbuff_t *tvb, proto_tree *tree, int offset, int hf_index, char **data)\r\n{\r\nchar *str;\r\ngint len;\r\nstr = tvb_get_stringz_enc(wmem_packet_scope(), tvb, offset, &len, ENC_ASCII);\r\nproto_tree_add_string(tree, hf_index, tvb, offset, len, str);\r\nif (data)\r\n*data = str;\r\nreturn offset+len;\r\n}\r\nint display_unicode_string(tvbuff_t *tvb, proto_tree *tree, int offset, int hf_index, char **data)\r\n{\r\nchar *str, *p;\r\nint len;\r\nint charoffset;\r\nguint16 character;\r\nlen = 0;\r\nwhile (tvb_get_letohs(tvb, offset + len) != '\0')\r\nlen += 2;\r\nlen += 2;\r\nstr = (char *)wmem_alloc(wmem_packet_scope(), len/2);\r\ncharoffset = offset;\r\np = str;\r\nwhile ((character = tvb_get_letohs(tvb, charoffset)) != '\0') {\r\n*p++ = (char) character;\r\ncharoffset += 2;\r\n}\r\n*p = '\0';\r\nproto_tree_add_string(tree, hf_index, tvb, offset, len, str);\r\nif (data)\r\n*data = str;\r\nreturn offset+len;\r\n}\r\nint dissect_ms_compressed_string(tvbuff_t *tvb, proto_tree *tree, int offset, int hf_index,\r\nconst char **data)\r\n{\r\nint compr_len;\r\nconst guchar *str = NULL;\r\ncompr_len = expand_dns_name(tvb, offset, MAX_UNICODE_STR_LEN+3+1, 0, &str);\r\nproto_tree_add_string(tree, hf_index, tvb, offset, compr_len, str);\r\nif (data)\r\n*data = str;\r\nreturn offset + compr_len;\r\n}\r\nstatic gchar *\r\nunicode_to_str(tvbuff_t *tvb, int offset, int *us_lenp, gboolean exactlen,\r\nguint16 bc)\r\n{\r\ngchar *cur;\r\ngchar *p;\r\nguint16 uchar;\r\nint len;\r\nint us_len;\r\ngboolean overflow = FALSE;\r\ncur=(gchar *)wmem_alloc(wmem_packet_scope(), MAX_UNICODE_STR_LEN+3+1);\r\np = cur;\r\nlen = MAX_UNICODE_STR_LEN;\r\nus_len = 0;\r\nfor (;;) {\r\nif (bc == 0)\r\nbreak;\r\nif (bc == 1) {\r\nif (!exactlen)\r\nus_len += 1;\r\nbreak;\r\n}\r\nuchar = tvb_get_letohs(tvb, offset);\r\nif (uchar == 0) {\r\nus_len += 2;\r\nbreak;\r\n}\r\nif (len > 0) {\r\nif ((uchar & 0xFF00) == 0)\r\n*p++ = (gchar) uchar;\r\nelse\r\n*p++ = '?';\r\nlen--;\r\n} else\r\noverflow = TRUE;\r\noffset += 2;\r\nbc -= 2;\r\nus_len += 2;\r\nif(exactlen){\r\nif(us_len>= *us_lenp){\r\nbreak;\r\n}\r\n}\r\n}\r\nif (overflow) {\r\n*p++ = '.';\r\n*p++ = '.';\r\n*p++ = '.';\r\n}\r\n*p = '\0';\r\n*us_lenp = us_len;\r\nreturn cur;\r\n}\r\nconst gchar *\r\nget_unicode_or_ascii_string(tvbuff_t *tvb, int *offsetp,\r\ngboolean useunicode, int *len, gboolean nopad, gboolean exactlen,\r\nguint16 *bcp)\r\n{\r\ngchar *cur;\r\nconst gchar *string;\r\nint string_len = 0;\r\nint copylen;\r\ngboolean overflow = FALSE;\r\nif (*bcp == 0) {\r\nreturn NULL;\r\n}\r\nif (useunicode) {\r\nif ((!nopad) && (*offsetp % 2)) {\r\n(*offsetp)++;\r\n(*bcp)--;\r\nif (*bcp == 0) {\r\nreturn NULL;\r\n}\r\n}\r\nif(exactlen){\r\nstring_len = *len;\r\nif (string_len < 0) {\r\nstring_len = INT_MAX;\r\n}\r\n}\r\nstring = unicode_to_str(tvb, *offsetp, &string_len, exactlen, *bcp);\r\n} else {\r\nif(exactlen){\r\ncur=(gchar *)wmem_alloc(wmem_packet_scope(), MAX_UNICODE_STR_LEN+3+1);\r\ncopylen = *len;\r\nif (copylen < 0) {\r\ncopylen = INT_MAX;\r\n}\r\ntvb_ensure_bytes_exist(tvb, *offsetp, copylen);\r\nif (copylen > MAX_UNICODE_STR_LEN) {\r\ncopylen = MAX_UNICODE_STR_LEN;\r\noverflow = TRUE;\r\n}\r\ntvb_memcpy(tvb, (guint8 *)cur, *offsetp, copylen);\r\ncur[copylen] = '\0';\r\nif (overflow)\r\ng_strlcat(cur, "...",MAX_UNICODE_STR_LEN+3+1);\r\nstring_len = *len;\r\nstring = cur;\r\n} else {\r\nstring = tvb_get_const_stringz(tvb, *offsetp, &string_len);\r\n}\r\n}\r\n*len = string_len;\r\nreturn string;\r\n}
