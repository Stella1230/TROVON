static void\r\nsrt_select_filter_cb(GtkWidget *widget _U_, gpointer callback_data, guint callback_action)\r\n{\r\ngtk_srt_table_t *rst_table = (gtk_srt_table_t*)callback_data;\r\nsrt_stat_table* rst = rst_table->rst;\r\nchar *str = NULL;\r\nGtkTreeIter iter;\r\nGtkTreeModel *model;\r\nGtkTreeSelection *sel;\r\nint selection;\r\nif(rst->filter_string==NULL){\r\nreturn;\r\n}\r\nsel = gtk_tree_view_get_selection (GTK_TREE_VIEW(rst_table->table));\r\nif (!gtk_tree_selection_get_selected(sel, &model, &iter))\r\nreturn;\r\ngtk_tree_model_get (model, &iter, SRT_COLUMN_INDEX, &selection, -1);\r\nif(selection>=(int)rst->num_procs){\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "No procedure selected");\r\nreturn;\r\n}\r\nstr = g_strdup_printf("%s==%d", rst->filter_string, selection);\r\napply_selected_filter (callback_action, str);\r\ng_free(str);\r\n}\r\nstatic gboolean\r\nsrt_show_popup_menu_cb(void *widg _U_, GdkEvent *event, gtk_srt_table_t *rst)\r\n{\r\nGdkEventButton *bevent = (GdkEventButton *)event;\r\nif(event->type==GDK_BUTTON_PRESS && bevent->button==3){\r\ngtk_menu_popup(GTK_MENU(rst->menu), NULL, NULL, NULL, NULL,\r\nbevent->button, bevent->time);\r\n}\r\nreturn FALSE;\r\n}\r\nstatic void\r\napply_as_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\napply_as_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\napply_as_and_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_AND_SELECTED, 0));\r\n}\r\nstatic void\r\napply_as_or_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_OR_SELECTED, 0));\r\n}\r\nstatic void\r\napply_as_and_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_AND_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\napply_as_or_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_OR_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_and_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_AND_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_or_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_OR_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_and_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_AND_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_or_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_OR_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_FIND_FRAME(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_FIND_FRAME(ACTYPE_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_prev_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_FIND_PREVIOUS(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_prev_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_FIND_PREVIOUS(ACTYPE_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_next_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_FIND_NEXT(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_next_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_FIND_NEXT(ACTYPE_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\ncolor_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_COLORIZE(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\ncolor_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_COLORIZE(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\nsrt_create_popup_menu(gtk_srt_table_t* rst_table)\r\n{\r\nGtkUIManager *ui_manager;\r\nGtkActionGroup *action_group;\r\nGError *error = NULL;\r\naction_group = gtk_action_group_new ("ServiceRespTFilterPopupActionGroup");\r\ngtk_action_group_add_actions (action_group,\r\n(GtkActionEntry *)service_resp_t__popup_entries,\r\nG_N_ELEMENTS(service_resp_t__popup_entries),\r\nrst_table);\r\nui_manager = gtk_ui_manager_new ();\r\ngtk_ui_manager_insert_action_group (ui_manager,\r\naction_group,\r\n0);\r\ngtk_ui_manager_add_ui_from_string (ui_manager,ui_desc_service_resp_t_filter_popup, -1, &error);\r\nif (error != NULL)\r\n{\r\nfprintf (stderr, "Warning: building service response time filter popup failed: %s\n",\r\nerror->message);\r\ng_error_free (error);\r\nerror = NULL;\r\n}\r\nrst_table->menu = gtk_ui_manager_get_widget(ui_manager, "/ServiceRespTFilterPopup");\r\ng_signal_connect(rst_table->table, "button_press_event", G_CALLBACK(srt_show_popup_menu_cb), rst_table);\r\n}\r\nstatic void\r\nsrt_time_func (GtkTreeViewColumn *column _U_,\r\nGtkCellRenderer *renderer,\r\nGtkTreeModel *model,\r\nGtkTreeIter *iter,\r\ngpointer user_data)\r\n{\r\ngchar *str;\r\nnstime_t *data;\r\ngint data_column = GPOINTER_TO_INT(user_data);\r\ngtk_tree_model_get(model, iter, data_column, &data, -1);\r\nif (!data) {\r\ng_object_set(renderer, "text", "", NULL);\r\nreturn;\r\n}\r\nstr = g_strdup_printf("%3d.%06d", (int)data->secs, (data->nsecs+500)/1000);\r\ng_object_set(renderer, "text", str, NULL);\r\ng_free(str);\r\n}\r\nstatic void\r\nsrt_avg_func (GtkTreeViewColumn *column _U_,\r\nGtkCellRenderer *renderer,\r\nGtkTreeModel *model,\r\nGtkTreeIter *iter,\r\ngpointer user_data)\r\n{\r\ngchar *str;\r\nguint64 td;\r\ngint data_column = GPOINTER_TO_INT(user_data);\r\ngtk_tree_model_get(model, iter, data_column, &td, -1);\r\nstr=g_strdup_printf("%3d.%06d",\r\n(int)(td/1000000), (int)(td%1000000));\r\ng_object_set(renderer, "text", str, NULL);\r\ng_free(str);\r\n}\r\nstatic gint\r\nsrt_time_sort_func(GtkTreeModel *model,\r\nGtkTreeIter *a,\r\nGtkTreeIter *b,\r\ngpointer user_data)\r\n{\r\nnstime_t *ns_a;\r\nnstime_t *ns_b;\r\ngint ret = 0;\r\ngint data_column = GPOINTER_TO_INT(user_data);\r\ngtk_tree_model_get(model, a, data_column, &ns_a, -1);\r\ngtk_tree_model_get(model, b, data_column, &ns_b, -1);\r\nif (ns_a == ns_b) {\r\nret = 0;\r\n}\r\nelse if (ns_a == NULL || ns_b == NULL) {\r\nret = (ns_a == NULL) ? -1 : 1;\r\n}\r\nelse {\r\nret = nstime_cmp(ns_a,ns_b);\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nsrt_set_title(srt_t *ss)\r\n{\r\ngchar *str;\r\nstr = g_strdup_printf("%s Service Response Time statistics", proto_get_protocol_short_name(find_protocol_by_id(get_srt_proto_id(ss->srt))));\r\nset_window_title(ss->gtk_data.win, str);\r\ng_free(str);\r\n}\r\nstatic gtk_srt_table_t*\r\nget_gtk_table_from_srt(srt_stat_table* rst, gtk_srt_t* gtk)\r\n{\r\nguint i;\r\ngtk_srt_table_t* srt;\r\nfor (i = 0; i < gtk->gtk_srt_array->len; i++) {\r\nsrt = g_array_index(gtk->gtk_srt_array, gtk_srt_table_t*, i);\r\nif (srt->rst == rst)\r\nreturn srt;\r\n}\r\nreturn NULL;\r\n}\r\nvoid\r\nfree_table_data(srt_stat_table* rst, void* gui_data)\r\n{\r\ngtk_srt_t* gtk_data = (gtk_srt_t*)gui_data;\r\ngtk_srt_table_t* gtk_table = get_gtk_table_from_srt(rst, gtk_data);\r\ng_assert(gtk_table);\r\ng_free(gtk_table);\r\n}\r\nstatic void\r\nwin_destroy_cb(GtkWindow *win _U_, gpointer data)\r\n{\r\nsrt_t *ss=(srt_t *)data;\r\nremove_tap_listener(&ss->data);\r\nfree_srt_table(ss->srt, ss->data.srt_array, free_table_data, &ss->gtk_data);\r\ng_free(ss);\r\n}\r\nvoid\r\ninit_gtk_srt_table(srt_stat_table* rst, void* gui_data)\r\n{\r\nint i;\r\nGtkListStore *store;\r\nGtkWidget *tree;\r\nGtkTreeViewColumn *column;\r\nGtkCellRenderer *renderer;\r\nGtkTreeSortable *sortable;\r\nGtkWidget *label;\r\nGtkWidget *tab_page;\r\ngtk_srt_t *ss = (gtk_srt_t*)gui_data;\r\nGtkWidget *parent_box = ss->vbox;\r\nGtkTreeSelection *sel;\r\ngtk_srt_table_t *gtk_table_data = g_new0(gtk_srt_table_t, 1);\r\ngtk_table_data->rst = rst;\r\ng_array_insert_val(ss->gtk_srt_array, ss->gtk_srt_array->len, gtk_table_data);\r\nlabel=gtk_label_new(rst->name);\r\nif (ss->main_nb == NULL)\r\n{\r\ngtk_box_pack_start(GTK_BOX(ss->vbox), label, FALSE, FALSE, 0);\r\n}\r\nelse\r\n{\r\nGtkWidget *tab_label=gtk_label_new(rst->short_name);\r\ntab_page = ws_gtk_box_new(GTK_ORIENTATION_VERTICAL, 6, FALSE);\r\ngtk_notebook_append_page(GTK_NOTEBOOK(ss->main_nb), tab_page, tab_label);\r\ngtk_box_pack_start(GTK_BOX(tab_page), label, FALSE, FALSE, 0);\r\nparent_box = tab_page;\r\n}\r\nstore = gtk_list_store_new (NUM_SRT_COLUMNS,\r\nG_TYPE_INT,\r\nG_TYPE_STRING,\r\nG_TYPE_UINT,\r\nG_TYPE_POINTER,\r\nG_TYPE_POINTER,\r\nG_TYPE_UINT64,\r\nG_TYPE_UINT64);\r\ntree = gtk_tree_view_new_with_model (GTK_TREE_MODEL (store));\r\ngtk_table_data->table = GTK_TREE_VIEW(tree);\r\nsortable = GTK_TREE_SORTABLE(store);\r\ng_object_unref (G_OBJECT (store));\r\nfor (i = 0; i < NUM_SRT_COLUMNS; i++) {\r\nrenderer = gtk_cell_renderer_text_new ();\r\nif (i != SRT_COLUMN_PROCEDURE) {\r\ng_object_set(G_OBJECT(renderer), "xalign", 1.0, NULL);\r\n}\r\ng_object_set(renderer, "ypad", 0, NULL);\r\nswitch (i) {\r\ncase SRT_COLUMN_MIN:\r\ncase SRT_COLUMN_MAX:\r\ncolumn = gtk_tree_view_column_new_with_attributes (service_response_time_get_column_name(i), renderer, NULL);\r\ngtk_tree_view_column_set_cell_data_func(column, renderer, srt_time_func, GINT_TO_POINTER(i), NULL);\r\ngtk_tree_sortable_set_sort_func(sortable, i, srt_time_sort_func, GINT_TO_POINTER(i), NULL);\r\nbreak;\r\ncase SRT_COLUMN_AVG:\r\ncase SRT_COLUMN_SUM:\r\ncolumn = gtk_tree_view_column_new_with_attributes (service_response_time_get_column_name(i), renderer, NULL);\r\ngtk_tree_view_column_set_cell_data_func(column, renderer, srt_avg_func, GINT_TO_POINTER(i), NULL);\r\nbreak;\r\ncase PROCEDURE_COLUMN:\r\ncolumn = gtk_tree_view_column_new_with_attributes ((rst->proc_column_name != NULL) ? rst->proc_column_name : service_response_time_get_column_name(i), renderer, "text",\r\ni, NULL);\r\nbreak;\r\ndefault:\r\ncolumn = gtk_tree_view_column_new_with_attributes (service_response_time_get_column_name(i), renderer, "text", i, NULL);\r\nbreak;\r\n}\r\ngtk_tree_view_column_set_sort_column_id(column, i);\r\ngtk_tree_view_column_set_resizable(column, TRUE);\r\ngtk_tree_view_append_column (gtk_table_data->table, column);\r\nif (i == SRT_COLUMN_CALLS) {\r\ngtk_tree_view_column_clicked(column);\r\ngtk_tree_view_column_clicked(column);\r\n}\r\n}\r\ngtk_table_data->scrolled_window=scrolled_window_new(NULL, NULL);\r\ngtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(gtk_table_data->scrolled_window),\r\nGTK_SHADOW_IN);\r\ngtk_container_add(GTK_CONTAINER(gtk_table_data->scrolled_window), GTK_WIDGET (gtk_table_data->table));\r\ngtk_box_pack_start(GTK_BOX(parent_box), gtk_table_data->scrolled_window, TRUE, TRUE, 0);\r\ngtk_tree_view_set_reorderable (gtk_table_data->table, FALSE);\r\ngtk_tree_view_set_rules_hint(gtk_table_data->table, TRUE);\r\ngtk_tree_view_set_headers_clickable(gtk_table_data->table, TRUE);\r\ngtk_widget_show(gtk_table_data->scrolled_window);\r\nsel = gtk_tree_view_get_selection(GTK_TREE_VIEW(gtk_table_data->table));\r\ngtk_tree_selection_set_mode(sel, GTK_SELECTION_SINGLE);\r\nif(rst->filter_string){\r\nsrt_create_popup_menu(gtk_table_data);\r\n}\r\n}\r\nvoid\r\ndraw_srt_table_data(srt_stat_table *rst, gtk_srt_t* gtk_data)\r\n{\r\nint idx, new_idx;\r\nGtkTreeIter iter;\r\ngboolean first = TRUE;\r\ngtk_srt_table_t* gtk_table;\r\nGtkListStore *store;\r\ngboolean iter_valid;\r\ngtk_table = get_gtk_table_from_srt(rst, gtk_data);\r\ng_assert(gtk_table);\r\nstore = GTK_LIST_STORE(gtk_tree_view_get_model(gtk_table->table));\r\niter_valid = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(store), &iter);\r\nnew_idx = gtk_tree_model_iter_n_children(GTK_TREE_MODEL(store), NULL);\r\nwhile (iter_valid || (new_idx < rst->num_procs)) {\r\nsrt_procedure_t* procedure;\r\nguint64 td;\r\nguint64 sum;\r\nif (iter_valid) {\r\ngtk_tree_model_get(GTK_TREE_MODEL(store), &iter, INDEX_COLUMN, &idx, -1);\r\n} else {\r\nidx = new_idx;\r\nnew_idx++;\r\n}\r\nprocedure = &rst->procedures[idx];\r\nif ((procedure->procedure == NULL) || (procedure->stats.num == 0)) {\r\niter_valid = gtk_tree_model_iter_next(GTK_TREE_MODEL(store), &iter);\r\ncontinue;\r\n}\r\nif (first) {\r\ng_object_ref(store);\r\ngtk_tree_view_set_model(GTK_TREE_VIEW(gtk_table->table), NULL);\r\nfirst = FALSE;\r\n}\r\ntd = ((guint64)(procedure->stats.tot.secs))*NANOSECS_PER_SEC + procedure->stats.tot.nsecs;\r\nsum = (td + 500) / 1000;\r\ntd = ((td / procedure->stats.num) + 500) / 1000;\r\nif (iter_valid) {\r\ngtk_list_store_set(store, &iter,\r\nPROCEDURE_COLUMN, procedure->procedure,\r\nCALLS_COLUMN, procedure->stats.num,\r\nMIN_SRT_COLUMN, &procedure->stats.min,\r\nMAX_SRT_COLUMN, &procedure->stats.max,\r\nAVG_SRT_COLUMN, td,\r\nSUM_SRT_COLUMN, sum,\r\n-1);\r\n} else {\r\ngtk_list_store_insert_with_values(store, &iter, G_MAXINT,\r\nPROCEDURE_COLUMN, procedure->procedure,\r\nCALLS_COLUMN, procedure->stats.num,\r\nMIN_SRT_COLUMN, &procedure->stats.min,\r\nMAX_SRT_COLUMN, &procedure->stats.max,\r\nAVG_SRT_COLUMN, td,\r\nSUM_SRT_COLUMN, sum,\r\nINDEX_COLUMN, idx,\r\n-1);\r\n}\r\niter_valid = gtk_tree_model_iter_next(GTK_TREE_MODEL(store), &iter);\r\n}\r\nif (!first) {\r\ngtk_tree_view_set_model(GTK_TREE_VIEW(gtk_table->table), GTK_TREE_MODEL(store));\r\ng_object_unref(store);\r\n}\r\n}\r\nstatic void\r\nsrt_draw(void *arg)\r\n{\r\nguint i = 0;\r\nsrt_stat_table *srt_table;\r\nsrt_data_t *srt = (srt_data_t*)arg;\r\nsrt_t *ss = (srt_t*)srt->user_data;\r\nfor (i = 0; i < srt->srt_array->len; i++)\r\n{\r\nsrt_table = g_array_index(srt->srt_array, srt_stat_table*, i);\r\ndraw_srt_table_data(srt_table, &ss->gtk_data);\r\n}\r\n}\r\nvoid\r\nreset_table_data(srt_stat_table* rst, void* gui_data)\r\n{\r\nGtkListStore *store;\r\ngtk_srt_t* gtk_data = (gtk_srt_t*)gui_data;\r\ngtk_srt_table_t* gtk_table = get_gtk_table_from_srt(rst, gtk_data);\r\ng_assert(gtk_table);\r\nstore = GTK_LIST_STORE(gtk_tree_view_get_model(gtk_table->table));\r\ngtk_list_store_clear(store);\r\n}\r\nstatic void\r\nsrt_reset(void *arg)\r\n{\r\nsrt_data_t *srt = (srt_data_t*)arg;\r\nsrt_t *ss = (srt_t *)srt->user_data;\r\nreset_srt_table(ss->data.srt_array, reset_table_data, &ss->gtk_data);\r\nsrt_set_title(ss);\r\n}\r\nstatic void\r\ninit_srt_tables(register_srt_t* srt, const char *filter)\r\n{\r\nsrt_t *ss;\r\ngchar *str;\r\nGtkWidget *label;\r\nchar *filter_string, *tmp_filter_string;\r\nGString *error_string;\r\nGtkWidget *bbox;\r\nGtkWidget *close_bt;\r\nss = g_new0(srt_t, 1);\r\nstr = g_strdup_printf("%s-stat", proto_get_protocol_filter_name(get_srt_proto_id(srt)));\r\nss->gtk_data.win=dlg_window_new(str);\r\ng_free(str);\r\ngtk_window_set_destroy_with_parent (GTK_WINDOW(ss->gtk_data.win), TRUE);\r\ngtk_window_set_default_size(GTK_WINDOW(ss->gtk_data.win), SRT_PREFERRED_WIDTH, 600);\r\nstr = g_strdup_printf("%s Service Response Time Statistics", proto_get_protocol_short_name(find_protocol_by_id(get_srt_proto_id(srt))));\r\nset_window_title(ss->gtk_data.win, str);\r\nss->gtk_data.vbox=ws_gtk_box_new(GTK_ORIENTATION_VERTICAL, 3, FALSE);\r\ngtk_container_add(GTK_CONTAINER(ss->gtk_data.win), ss->gtk_data.vbox);\r\ngtk_container_set_border_width(GTK_CONTAINER(ss->gtk_data.vbox), 12);\r\nlabel=gtk_label_new(str);\r\ngtk_box_pack_start(GTK_BOX(ss->gtk_data.vbox), label, FALSE, FALSE, 0);\r\ng_free(str);\r\nif ((filter != NULL) && (strlen(filter) > MAX_FILTER_STRING_LENGTH))\r\n{\r\ntmp_filter_string = g_strndup(filter, MAX_FILTER_STRING_LENGTH);\r\nfilter_string = g_strdup_printf("Filter: %s...", tmp_filter_string);\r\ng_free(tmp_filter_string);\r\n}\r\nelse\r\n{\r\nfilter_string = g_strdup_printf("Filter: %s", filter ? filter : "");\r\n}\r\nlabel=gtk_label_new(filter_string);\r\ngtk_label_set_line_wrap(GTK_LABEL(label), TRUE);\r\ngtk_widget_set_tooltip_text (label, filter ? filter : "");\r\ng_free(filter_string);\r\ngtk_box_pack_start(GTK_BOX(ss->gtk_data.vbox), label, FALSE, FALSE, 0);\r\nif (get_srt_max_tables(srt) > 3)\r\n{\r\nss->gtk_data.main_nb = gtk_notebook_new();\r\ngtk_box_pack_start(GTK_BOX(ss->gtk_data.vbox), ss->gtk_data.main_nb, TRUE, TRUE, 0);\r\n}\r\ngtk_widget_show_all(ss->gtk_data.win);\r\nss->type = proto_get_protocol_short_name(find_protocol_by_id(get_srt_proto_id(srt)));\r\nss->filter = g_strdup(filter);\r\nss->srt = srt;\r\nss->gtk_data.gtk_srt_array = g_array_new(FALSE, TRUE, sizeof(gtk_srt_table_t*));\r\nss->data.srt_array = g_array_new(FALSE, TRUE, sizeof(srt_stat_table*));\r\nss->data.user_data = ss;\r\nsrt_table_dissector_init(srt, ss->data.srt_array, init_gtk_srt_table, &ss->gtk_data);\r\nerror_string = register_tap_listener(get_srt_tap_listener_name(srt), &ss->data, filter, 0, srt_reset, get_srt_packet_func(srt), srt_draw);\r\nif(error_string){\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s", error_string->str);\r\ng_string_free(error_string, TRUE);\r\nfree_srt_table(ss->srt, ss->data.srt_array, NULL, NULL);\r\ng_free(ss);\r\nreturn;\r\n}\r\nbbox = dlg_button_row_new(GTK_STOCK_CLOSE, NULL);\r\ngtk_box_pack_end(GTK_BOX(ss->gtk_data.vbox), bbox, FALSE, FALSE, 0);\r\nclose_bt = (GtkWidget *)g_object_get_data(G_OBJECT(bbox), GTK_STOCK_CLOSE);\r\nwindow_set_cancel_button(ss->gtk_data.win, close_bt, window_cancel_button_cb);\r\ng_signal_connect(ss->gtk_data.win, "delete_event", G_CALLBACK(window_delete_event_cb), NULL);\r\ng_signal_connect(ss->gtk_data.win, "destroy", G_CALLBACK(win_destroy_cb), ss);\r\ngtk_widget_show_all(ss->gtk_data.win);\r\nwindow_present(ss->gtk_data.win);\r\ncf_retap_packets(&cfile);\r\ngdk_window_raise(gtk_widget_get_window(ss->gtk_data.win));\r\n}\r\nstatic void\r\ngtk_srtstat_init(const char *opt_arg, void *userdata _U_)\r\n{\r\ngchar** dissector_name;\r\nregister_srt_t *srt;\r\nconst char *filter=NULL;\r\nchar* err;\r\ndissector_name = g_strsplit(opt_arg, ",", -1);\r\ng_assert(dissector_name[0]);\r\nsrt = get_srt_table_by_name(dissector_name[0]);\r\ng_assert(srt);\r\nsrt_table_get_filter(srt, opt_arg, &filter, &err);\r\nif (err != NULL)\r\n{\r\ngchar* cmd_str = srt_table_get_tap_string(srt);\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "invalid \"-z %s,%s\" argument", cmd_str, err);\r\ng_free(cmd_str);\r\ng_free(err);\r\nreturn;\r\n}\r\ninit_srt_tables(srt, filter);\r\n}\r\nvoid register_service_response_tables(gpointer data, gpointer user_data _U_)\r\n{\r\nregister_srt_t *srt = (register_srt_t*)data;\r\nconst char* short_name = proto_get_protocol_short_name(find_protocol_by_id(get_srt_proto_id(srt)));\r\ntap_param_dlg* srt_dlg;\r\nif ((strcmp(short_name, "RPC") == 0) ||\r\n(strcmp(short_name, "DCERPC") == 0))\r\nreturn;\r\nsrt_dlg = g_new(tap_param_dlg, 1);\r\nsrt_dlg->win_title = g_strdup_printf("%s SRT Statistics", short_name);\r\nsrt_dlg->init_string = srt_table_get_tap_string(srt);\r\nsrt_dlg->tap_init_cb = gtk_srtstat_init;\r\nsrt_dlg->index = -1;\r\nsrt_dlg->user_data = srt;\r\nif (get_srt_proto_id(srt) == proto_get_id_by_filter_name("scsi"))\r\n{\r\nsrt_dlg->nparams = G_N_ELEMENTS(scsi_stat_params);\r\nsrt_dlg->params = scsi_stat_params;\r\n}\r\nelse\r\n{\r\nsrt_dlg->nparams = G_N_ELEMENTS(srt_stat_params);\r\nsrt_dlg->params = srt_stat_params;\r\n}\r\nregister_param_stat(srt_dlg, short_name, REGISTER_STAT_GROUP_RESPONSE_TIME);\r\n}
