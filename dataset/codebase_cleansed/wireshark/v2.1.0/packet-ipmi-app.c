static void\r\nrs01(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte2[] = { &hf_ipmi_app_01_dev_prov_sdr, &hf_ipmi_app_01_dev_rev, NULL };\r\nstatic const gint *byte3[] = { &hf_ipmi_app_01_dev_avail, &hf_ipmi_app_01_fw_rev_maj, NULL };\r\nstatic const gint *byte6[] = { &hf_ipmi_app_01_ipmi_ads_chassis, &hf_ipmi_app_01_ipmi_ads_bridge,\r\n&hf_ipmi_app_01_ipmi_ads_ipmb_ev_gen, &hf_ipmi_app_01_ipmi_ads_ipmb_ev_recv,\r\n&hf_ipmi_app_01_ipmi_ads_fru, &hf_ipmi_app_01_ipmi_ads_sel, &hf_ipmi_app_01_ipmi_ads_sdr,\r\n&hf_ipmi_app_01_ipmi_ads_sensor, NULL };\r\nsize_t len;\r\nlen = tvb_captured_length(tvb);\r\nproto_tree_add_item(tree, hf_ipmi_app_01_dev_id, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_app_01_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 2, 1, NULL, NULL, ett_ipmi_app_01_byte3, byte3, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_app_01_fw_rev_min, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_app_01_ipmi_version, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 5, 1, "Additional device support: ", "None",\r\nett_ipmi_app_01_byte6, byte6, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_app_01_manufacturer, tvb, 6, 3, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_app_01_product, tvb, 9, 2, ENC_LITTLE_ENDIAN);\r\nif (len > 11) {\r\nproto_tree_add_item(tree, hf_ipmi_app_01_fw_aux, tvb, 11, 4, ENC_NA);\r\n}\r\n}\r\nstatic void\r\nrs04(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte2[] = { &hf_ipmi_app_04_fail_sel, &hf_ipmi_app_04_fail_sdr,\r\n&hf_ipmi_app_04_fail_bmc_fru, &hf_ipmi_app_04_fail_ipmb_sig, &hf_ipmi_app_04_fail_sdr_empty,\r\n&hf_ipmi_app_04_fail_iua, &hf_ipmi_app_04_fail_bb_fw, &hf_ipmi_app_04_fail_oper_fw, NULL };\r\nint res, fail;\r\nres = tvb_get_guint8(tvb, 0);\r\nfail = tvb_get_guint8(tvb, 1);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_app_04_result, tvb, 0, 1,\r\nres, "%s (0x%02x)",\r\nval_to_str_const(res, vals_04_result, "Device-specific internal failure"),\r\nres);\r\nif (res == 0x55 || res == 0x56 || res == 0xff) {\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_app_04_fail, tvb, 1, 1,\r\nfail, "0x%02x (must be 0x00)",\r\nfail);\r\nreturn;\r\n}\r\nif (res != 0x57) {\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_app_04_fail, tvb, 1, 1,\r\nfail, "0x%02x (device-specific)",\r\nfail);\r\nreturn;\r\n}\r\nproto_tree_add_bitmask(tree, tvb, 1, hf_ipmi_app_04_fail, ett_ipmi_app_04_byte2, byte2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq05(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_app_05_devspec, tvb, 0, -1, ENC_NA);\r\n}\r\nstatic void\r\nrq06(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_06_syspwr_set, &hf_ipmi_app_06_syspwr_enum, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_app_06_devpwr_set, &hf_ipmi_app_06_devpwr_enum, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "ACPI System Power State: ", NULL,\r\nett_ipmi_app_06_syspwr, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, "ACPI Device Power State: ", NULL,\r\nett_ipmi_app_06_devpwr, byte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrs07(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_07_syspwr_enum, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_app_07_devpwr_enum, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "ACPI System Power State: ", NULL,\r\nett_ipmi_app_07_syspwr, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, "ACPI Device Power State: ", NULL,\r\nett_ipmi_app_07_devpwr, byte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrs08(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nipmi_add_guid(tree, hf_ipmi_app_08_guid, tvb, 0);\r\n}\r\nstatic void\r\nrq24(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_24_timer_use_dont_log,\r\n&hf_ipmi_app_24_timer_use_dont_stop, &hf_ipmi_app_24_timer_use_timer_use, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_app_24_timer_action_interrupt,\r\n&hf_ipmi_app_24_timer_action_timeout_action, NULL };\r\nstatic const gint *byte4[] = { &hf_ipmi_app_24_expiration_flags_oem,\r\n&hf_ipmi_app_24_expiration_flags_smsos, &hf_ipmi_app_24_expiration_flags_osload,\r\n&hf_ipmi_app_24_expiration_flags_biospost, &hf_ipmi_app_24_expiration_flags_biosfrb2, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Timer Use: ", NULL, ett_ipmi_app_24_timer_use,\r\nbyte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_app_24_timer_action,\r\nbyte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_app_24_pretimeout, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 3, 1, "Timer Use Expiration flags clear: ", "None",\r\nett_ipmi_app_24_expiration_flags, byte4, ENC_LITTLE_ENDIAN, BMT_NO_TFS);\r\nproto_tree_add_item(tree, hf_ipmi_app_24_initial_countdown, tvb, 4, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs25(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_25_timer_use_dont_log,\r\n&hf_ipmi_app_25_timer_use_started, &hf_ipmi_app_25_timer_use_timer_use, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_app_25_timer_action_interrupt,\r\n&hf_ipmi_app_25_timer_action_timeout_action, NULL };\r\nstatic const gint *byte4[] = { &hf_ipmi_app_25_expiration_flags_oem, &hf_ipmi_app_25_expiration_flags_smsos,\r\n&hf_ipmi_app_25_expiration_flags_osload, &hf_ipmi_app_25_expiration_flags_biospost,\r\n&hf_ipmi_app_25_expiration_flags_biosfrb2, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Timer Use: ", NULL, ett_ipmi_app_25_timer_use,\r\nbyte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_app_25_timer_action,\r\nbyte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_app_25_pretimeout, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 3, 1, "Timer Use Expiration flags: ", "None",\r\nett_ipmi_app_25_expiration_flags, byte4, ENC_LITTLE_ENDIAN, BMT_NO_TFS);\r\nproto_tree_add_item(tree, hf_ipmi_app_25_initial_countdown, tvb, 4, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_app_25_present_countdown, tvb, 6, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq2e(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_2e_byte1_oem2, &hf_ipmi_app_2e_byte1_oem1,\r\n&hf_ipmi_app_2e_byte1_oem0, &hf_ipmi_app_2e_byte1_sel, &hf_ipmi_app_2e_byte1_emb,\r\n&hf_ipmi_app_2e_byte1_emb_full_intr, &hf_ipmi_app_2e_byte1_rmq_intr, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Enables: ", "None", ett_ipmi_app_2e_byte1,\r\nbyte1, ENC_LITTLE_ENDIAN, BMT_NO_TFS);\r\n}\r\nstatic void\r\nrs2f(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_2f_byte1_oem2, &hf_ipmi_app_2f_byte1_oem1,\r\n&hf_ipmi_app_2f_byte1_oem0, &hf_ipmi_app_2f_byte1_sel, &hf_ipmi_app_2f_byte1_emb,\r\n&hf_ipmi_app_2f_byte1_emb_full_intr, &hf_ipmi_app_2f_byte1_rmq_intr, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Enables: ", "None", ett_ipmi_app_2f_byte1,\r\nbyte1, ENC_LITTLE_ENDIAN, BMT_NO_TFS);\r\n}\r\nstatic void\r\nrq30(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_30_byte1_oem2, &hf_ipmi_app_30_byte1_oem1,\r\n&hf_ipmi_app_30_byte1_oem0, &hf_ipmi_app_30_byte1_wd_pretimeout,\r\n&hf_ipmi_app_30_byte1_emb, &hf_ipmi_app_30_byte1_rmq, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Clear Message Flags: ", "None",\r\nett_ipmi_app_30_byte1, byte1, ENC_LITTLE_ENDIAN, BMT_NO_TFS);\r\n}\r\nstatic void\r\nrs31(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_31_byte1_oem2, &hf_ipmi_app_31_byte1_oem1,\r\n&hf_ipmi_app_31_byte1_oem0, &hf_ipmi_app_31_byte1_wd_pretimeout,\r\n&hf_ipmi_app_31_byte1_emb, &hf_ipmi_app_31_byte1_rmq, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Flags: ", "None",\r\nett_ipmi_app_31_byte1, byte1, ENC_LITTLE_ENDIAN, BMT_NO_TFS);\r\n}\r\nstatic void\r\nrq32(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_32_rq_chno, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_app_32_rq_state, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_app_32_rq_byte1,\r\nbyte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_app_32_rq_byte2,\r\nbyte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrs32(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_32_rs_chno, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_app_32_rs_state, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_app_32_rs_byte1,\r\nbyte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_app_32_rs_byte2,\r\nbyte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrs33(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_33_rs_chan,\r\n&hf_ipmi_app_33_rs_priv, NULL };\r\ntvbuff_t *next;\r\nipmi_dissect_arg_t arg;\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_app_33_rs_byte1,\r\nbyte1, ENC_LITTLE_ENDIAN, 0);\r\nnext = tvb_new_subset_remaining(tvb, 1);\r\narg.context = IPMI_E_GETMSG;\r\narg.channel = tvb_get_guint8(tvb, 0) & 0xF;\r\narg.flags = 0;\r\ndo_dissect_ipmb(next, pinfo, tree,\r\nhf_ipmi_app_33_msg, ett_ipmi_app_33_msg, &arg);\r\n}\r\nstatic void\r\nrq34(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_34_track, &hf_ipmi_app_34_encrypt,\r\n&hf_ipmi_app_34_auth, &hf_ipmi_app_34_chan, NULL };\r\ntvbuff_t *next;\r\nipmi_dissect_arg_t arg;\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_app_34_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nnext = tvb_new_subset_remaining(tvb, 1);\r\narg.context = IPMI_E_SENDMSG_RQ;\r\narg.channel = tvb_get_guint8(tvb, 0) & 0xF;\r\narg.flags = 0;\r\ndo_dissect_ipmb(next, pinfo, tree,\r\nhf_ipmi_app_34_msg, ett_ipmi_app_34_msg, &arg);\r\n}\r\nstatic void\r\nrs34(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nif (tvb_captured_length(tvb)) {\r\nipmi_dissect_arg_t arg;\r\narg.context = IPMI_E_SENDMSG_RS;\r\narg.channel = 0;\r\narg.flags = 0;\r\ndo_dissect_ipmb(tvb, pinfo, tree,\r\nhf_ipmi_app_34_msg, ett_ipmi_app_34_msg, &arg);\r\n}\r\n}\r\nstatic void\r\nrq38(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_38_rq_ipmi20, &hf_ipmi_app_38_rq_chan, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_app_38_rq_priv, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_app_38_rq_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_app_38_rq_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrs38(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_38_rs_chan, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_app_38_rs_ipmi20, &hf_ipmi_app_38_rs_auth_oem,\r\n&hf_ipmi_app_38_rs_auth_straight, &hf_ipmi_app_38_rs_auth_md5, &hf_ipmi_app_38_rs_auth_md2,\r\n&hf_ipmi_app_38_rs_auth_none, NULL };\r\nstatic const gint *byte3[] = { &hf_ipmi_app_38_rs_kg, &hf_ipmi_app_38_rs_permsg, &hf_ipmi_app_38_rs_userauth,\r\n&hf_ipmi_app_38_rs_user_nonnull, &hf_ipmi_app_38_rs_user_null, &hf_ipmi_app_38_rs_user_anon, NULL };\r\nstatic const gint *byte4[] = { &hf_ipmi_app_38_rs_ipmi20_conn, &hf_ipmi_app_38_rs_ipmi15_conn, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_app_38_rs_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL, ett_ipmi_app_38_rs_byte2, byte2, ENC_LITTLE_ENDIAN, BMT_NO_FALSE);\r\nproto_tree_add_bitmask_text(tree, tvb, 2, 1, NULL, NULL, ett_ipmi_app_38_rs_byte3, byte3, ENC_LITTLE_ENDIAN, BMT_NO_FALSE);\r\nproto_tree_add_bitmask_text(tree, tvb, 3, 1, "Supported connections: ", "None",\r\nett_ipmi_app_38_rs_byte4, byte4, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_app_38_rs_oem_iana, tvb, 4, 3, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_app_38_rs_oem_aux, tvb, 7, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq39(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_39_authtype, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_app_39_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_app_39_user, tvb, 1, 16, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nrs39(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_app_39_temp_session, tvb, 0, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_app_39_challenge, tvb, 4, 16, ENC_NA);\r\n}\r\nstatic void\r\nrq3a(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_3a_authtype, NULL };\r\nstatic const gint *byte2[] = { &hf_ipmi_app_3a_privlevel, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_app_3a_rq_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_app_3a_rq_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_app_3a_authcode, tvb, 2, 16, ENC_NA);\r\nproto_tree_add_item(tree, hf_ipmi_app_3a_outbound_seq, tvb, 18, 4, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs3a(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_3a_authtype_session, NULL };\r\nstatic const gint *byte10[] = { &hf_ipmi_app_3a_maxpriv_session, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_app_3a_rs_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_app_3a_session_id, tvb, 1, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_app_3a_inbound_seq, tvb, 5, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 9, 1, NULL, NULL,\r\nett_ipmi_app_3a_rs_byte10, byte10, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrq3b(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_3b_req_priv, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_app_3b_rq_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrs3b(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_app_3b_new_priv, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_app_3b_rs_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrq3c(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_app_3c_session_id, tvb, 0, 4, ENC_LITTLE_ENDIAN);\r\nif (tvb_captured_length(tvb) > 4) {\r\nproto_tree_add_item(tree, hf_ipmi_app_3c_session_handle, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nvoid\r\nproto_register_ipmi_app(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ipmi_app_01_dev_id,\r\n{ "Device ID",\r\n"ipmi.app00.dev.id", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_dev_prov_sdr,\r\n{ "Device provides Device SDRs",\r\n"ipmi.app00.dev.provides_dev_sdr", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_dev_rev,\r\n{ "Device Revision (binary encoded)",\r\n"ipmi.app00.dev.rev", FT_UINT8, BASE_HEX, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_dev_avail,\r\n{ "Device availability",\r\n"ipmi.app01.dev.avail", FT_BOOLEAN, 8, TFS(&tfs_01_dev_avail), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_fw_rev_maj,\r\n{ "Major Firmware Revision (binary encoded)",\r\n"ipmi.app01.fw.major", FT_UINT8, BASE_HEX, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_fw_rev_min,\r\n{ "Minor Firmware Revision (BCD encoded)",\r\n"ipmi.app01.fw.minor", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_ipmi_version,\r\n{ "IPMI version",\r\n"ipmi.app01.ipmi.version", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_version), 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_ipmi_ads_chassis,\r\n{ "Chassis",\r\n"ipmi.app01.ads.chassis", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_ipmi_ads_bridge,\r\n{ "Bridge",\r\n"ipmi.app01.ads.bridge", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_ipmi_ads_ipmb_ev_gen,\r\n{ "Event Generator",\r\n"ipmi.app01.ads.ipmb_ev_gen", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_ipmi_ads_ipmb_ev_recv,\r\n{ "Event Receiver",\r\n"ipmi.app01.ads.ipmb_ev_recv", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_ipmi_ads_fru,\r\n{ "FRU Inventory",\r\n"ipmi.app01.ads.fru", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_ipmi_ads_sel,\r\n{ "SEL",\r\n"ipmi.app01.ads.sel", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_ipmi_ads_sdr,\r\n{ "SDR Repository",\r\n"ipmi.app01.ads.sdr", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_ipmi_ads_sensor,\r\n{ "Sensor",\r\n"ipmi.app01.ads.sensor", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_manufacturer,\r\n{ "Manufacturer ID",\r\n"ipmi.app01.manufacturer", FT_UINT24, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_product,\r\n{ "Product ID",\r\n"ipmi.app01.product", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_01_fw_aux,\r\n{ "Auxiliary Firmware Revision Information",\r\n"ipmi.app01.fw.aux", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_04_result,\r\n{ "Self test result",\r\n"ipmi.app04.self_test_result", FT_UINT8, BASE_HEX, VALS(vals_04_result), 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_04_fail,\r\n{ "Self-test error bitfield",\r\n"ipmi.app04.fail", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_04_fail_sel,\r\n{ "Cannot access SEL device",\r\n"ipmi.app04.fail.sel", FT_BOOLEAN, 8, TFS(&tfs_04_fail_unknown), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_app_04_fail_sdr,\r\n{ "Cannot access SDR Repository",\r\n"ipmi.app04.fail.sdr", FT_BOOLEAN, 8, TFS(&tfs_04_fail_unknown), 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_app_04_fail_bmc_fru,\r\n{ "Cannot access BMC FRU device",\r\n"ipmi.app04.fail.bmc_fru", FT_BOOLEAN, 8, TFS(&tfs_04_fail_unknown), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_app_04_fail_ipmb_sig,\r\n{ "IPMB signal lines do not respond",\r\n"ipmi.app04.fail.ipmb_sig", FT_BOOLEAN, 8, TFS(&tfs_04_fail_unknown), 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_app_04_fail_sdr_empty,\r\n{ "SDR Repository is empty",\r\n"ipmi.app04.fail.sdr_empty", FT_BOOLEAN, 8, TFS(&tfs_04_fail_unknown), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_app_04_fail_iua,\r\n{ "Internal Use Area of BMC FRU corrupted",\r\n"ipmi.app04.fail.iua", FT_BOOLEAN, 8, TFS(&tfs_04_fail_unknown), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_app_04_fail_bb_fw,\r\n{ "Controller update boot block firmware corrupted",\r\n"ipmi.app04.fail.bb_fw", FT_BOOLEAN, 8, TFS(&tfs_04_fail_unknown), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_app_04_fail_oper_fw,\r\n{ "Controller operational firmware corrupted",\r\n"ipmi.app04.fail.oper_fw", FT_BOOLEAN, 8, TFS(&tfs_04_fail_unknown), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_app_05_devspec,\r\n{ "Device-specific parameters",\r\n"ipmi.app05.devspec", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_06_syspwr_set,\r\n{ "System Power State",\r\n"ipmi.app06.syspwr.set", FT_BOOLEAN, 8, TFS(&tfs_06_pwr), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_app_06_syspwr_enum,\r\n{ "System Power State enumeration",\r\n"ipmi.app06.syspwr.enum", FT_UINT8, BASE_HEX, VALS(vals_06_syspwr), 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_app_06_devpwr_set,\r\n{ "Device Power State",\r\n"ipmi.app06.devpwr.set", FT_BOOLEAN, 8, TFS(&tfs_06_pwr), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_app_06_devpwr_enum,\r\n{ "Device Power State enumeration",\r\n"ipmi.app06.devpwr.enum", FT_UINT8, BASE_HEX, VALS(vals_06_devpwr), 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_app_07_syspwr_enum,\r\n{ "ACPI System Power State",\r\n"ipmi.app07.syspwr", FT_UINT8, BASE_HEX, VALS(vals_07_syspwr), 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_app_07_devpwr_enum,\r\n{ "ACPI Device Power State",\r\n"ipmi.app07.devpwr", FT_UINT8, BASE_HEX, VALS(vals_07_devpwr), 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_app_08_guid,\r\n{ "GUID",\r\n"ipmi.app08.guid", FT_GUID, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_24_timer_use_dont_log,\r\n{ "Don't log",\r\n"ipmi.app24.timer_use.dont_log", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_app_24_timer_use_dont_stop,\r\n{ "Don't stop timer on Set Watchdog command",\r\n"ipmi.app24.timer_use.dont_stop", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_app_24_timer_use_timer_use,\r\n{ "Timer use",\r\n"ipmi.app24.timer_use.timer_use", FT_UINT8, BASE_HEX, VALS(vals_24_timer_use), 0x07, NULL, HFILL }},\r\n{ &hf_ipmi_app_24_timer_action_interrupt,\r\n{ "Pre-timeout interrupt",\r\n"ipmi.app24.timer_action.interrupt", FT_UINT8, BASE_HEX, VALS(vals_24_timer_action_interrupt), 0x70, NULL, HFILL }},\r\n{ &hf_ipmi_app_24_timer_action_timeout_action,\r\n{ "Timeout action",\r\n"ipmi.app24.timer_action.timeout", FT_UINT8, BASE_HEX, VALS(vals_24_timer_action_timeout), 0x07, NULL, HFILL }},\r\n{ &hf_ipmi_app_24_pretimeout,\r\n{ "Pre-timeout interval",\r\n"ipmi.app24.pretimeout", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_1s_1based), 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_24_expiration_flags_oem,\r\n{ "OEM",\r\n"ipmi.app24.exp_flags.oem", FT_BOOLEAN, 8, TFS(&tfs_24_exp_flags), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_app_24_expiration_flags_smsos,\r\n{ "SMS/OS",\r\n"ipmi.app24.exp_flags.sms_os", FT_BOOLEAN, 8, TFS(&tfs_24_exp_flags), 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_app_24_expiration_flags_osload,\r\n{ "OS Load",\r\n"ipmi.app24.exp_flags.osload", FT_BOOLEAN, 8, TFS(&tfs_24_exp_flags), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_app_24_expiration_flags_biospost,\r\n{ "BIOS/POST",\r\n"ipmi.app24.exp_flags.biospost", FT_BOOLEAN, 8, TFS(&tfs_24_exp_flags), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_app_24_expiration_flags_biosfrb2,\r\n{ "BIOS FRB2",\r\n"ipmi.app24.exp_flags.biosfrb2", FT_BOOLEAN, 8, TFS(&tfs_24_exp_flags), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_app_24_initial_countdown,\r\n{ "Initial countdown value (100ms/count)",\r\n"ipmi.app24.initial_countdown", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_25_timer_use_dont_log,\r\n{ "Don't log",\r\n"ipmi.app25.timer_use.dont_log", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_app_25_timer_use_started,\r\n{ "Started",\r\n"ipmi.app25.timer_use.started", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_app_25_timer_use_timer_use,\r\n{ "Timer user",\r\n"ipmi.app25.timer_use.timer_use", FT_UINT8, BASE_HEX, VALS(vals_24_timer_use), 0x07, NULL, HFILL }},\r\n{ &hf_ipmi_app_25_timer_action_interrupt,\r\n{ "Pre-timeout interrupt",\r\n"ipmi.app25.timer_action.interrupt", FT_UINT8, BASE_HEX, VALS(vals_24_timer_action_interrupt), 0x70, NULL, HFILL }},\r\n{ &hf_ipmi_app_25_timer_action_timeout_action,\r\n{ "Timeout action",\r\n"ipmi.app25.timer_action.timeout", FT_UINT8, BASE_HEX, VALS(vals_24_timer_action_timeout), 0x07, NULL, HFILL }},\r\n{ &hf_ipmi_app_25_pretimeout,\r\n{ "Pre-timeout interval",\r\n"ipmi.app25.pretimeout", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_1s_1based), 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_25_expiration_flags_oem,\r\n{ "OEM",\r\n"ipmi.app25.exp_flags.oem", FT_BOOLEAN, 8, TFS(&tfs_24_exp_flags), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_app_25_expiration_flags_smsos,\r\n{ "SMS/OS",\r\n"ipmi.app25.exp_flags.sms_os", FT_BOOLEAN, 8, TFS(&tfs_24_exp_flags), 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_app_25_expiration_flags_osload,\r\n{ "OS Load",\r\n"ipmi.app25.exp_flags.osload", FT_BOOLEAN, 8, TFS(&tfs_24_exp_flags), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_app_25_expiration_flags_biospost,\r\n{ "BIOS/POST",\r\n"ipmi.app25.exp_flags.biospost", FT_BOOLEAN, 8, TFS(&tfs_24_exp_flags), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_app_25_expiration_flags_biosfrb2,\r\n{ "BIOS FRB2",\r\n"ipmi.app25.exp_flags.biosfrb2", FT_BOOLEAN, 8, TFS(&tfs_24_exp_flags), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_app_25_initial_countdown,\r\n{ "Initial countdown value (100ms/count)",\r\n"ipmi.app25.initial_countdown", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_25_present_countdown,\r\n{ "Present countdown value (100ms/count)",\r\n"ipmi.app25.initial_countdown", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_2e_byte1_oem2,\r\n{ "OEM 2",\r\n"ipmi.app2e.bmc_global_enables.oem2", FT_BOOLEAN, 8, TFS(&tfs_2e_enable), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_app_2e_byte1_oem1,\r\n{ "OEM 1",\r\n"ipmi.app2e.bmc_global_enables.oem1", FT_BOOLEAN, 8, TFS(&tfs_2e_enable), 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_app_2e_byte1_oem0,\r\n{ "OEM 0",\r\n"ipmi.app2e.bmc_global_enables.oem0", FT_BOOLEAN, 8, TFS(&tfs_2e_enable), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_app_2e_byte1_sel,\r\n{ "System Event Logging",\r\n"ipmi.app2e.bmc_global_enables.sel", FT_BOOLEAN, 8, TFS(&tfs_2e_enable), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_app_2e_byte1_emb,\r\n{ "Event Message Buffer",\r\n"ipmi.app2e.bmc_global_enables.emb", FT_BOOLEAN, 8, TFS(&tfs_2e_enable), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_app_2e_byte1_emb_full_intr,\r\n{ "Event Message Buffer Full Interrupt",\r\n"ipmi.app2e.bmc_global_enables.emb_full_intr", FT_BOOLEAN, 8, TFS(&tfs_2e_enable), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_app_2e_byte1_rmq_intr,\r\n{ "Receive Message Queue Interrupt",\r\n"ipmi.app2e.bmc_global_enables.rmq_intr", FT_BOOLEAN, 8, TFS(&tfs_2e_enable), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_app_2f_byte1_oem2,\r\n{ "OEM 2",\r\n"ipmi.app2f.bmc_global_enables.oem2", FT_BOOLEAN, 8, TFS(&tfs_2f_enabled), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_app_2f_byte1_oem1,\r\n{ "OEM 1",\r\n"ipmi.app2f.bmc_global_enables.oem1", FT_BOOLEAN, 8, TFS(&tfs_2f_enabled), 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_app_2f_byte1_oem0,\r\n{ "OEM 0",\r\n"ipmi.app2f.bmc_global_enables.oem0", FT_BOOLEAN, 8, TFS(&tfs_2f_enabled), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_app_2f_byte1_sel,\r\n{ "System Event Logging",\r\n"ipmi.app2f.bmc_global_enables.sel", FT_BOOLEAN, 8, TFS(&tfs_2f_enabled), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_app_2f_byte1_emb,\r\n{ "Event Message Buffer",\r\n"ipmi.app2f.bmc_global_enables.emb", FT_BOOLEAN, 8, TFS(&tfs_2f_enabled), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_app_2f_byte1_emb_full_intr,\r\n{ "Event Message Buffer Full Interrupt",\r\n"ipmi.app2f.bmc_global_enables.emb_full_intr", FT_BOOLEAN, 8, TFS(&tfs_2f_enabled), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_app_2f_byte1_rmq_intr,\r\n{ "Receive Message Queue Interrupt",\r\n"ipmi.app2f.bmc_global_enables.rmq_intr", FT_BOOLEAN, 8, TFS(&tfs_2f_enabled), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_app_30_byte1_oem2,\r\n{ "OEM 2",\r\n"ipmi.app30.byte1.oem2", FT_BOOLEAN, 8, TFS(&tfs_30_clear), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_app_30_byte1_oem1,\r\n{ "OEM 1",\r\n"ipmi.app30.byte1.oem1", FT_BOOLEAN, 8, TFS(&tfs_30_clear), 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_app_30_byte1_oem0,\r\n{ "OEM 0",\r\n"ipmi.app30.byte1.oem0", FT_BOOLEAN, 8, TFS(&tfs_30_clear), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_app_30_byte1_wd_pretimeout,\r\n{ "Watchdog pre-timeout interrupt flag",\r\n"ipmi.app30.byte1.wd_pretimeout", FT_BOOLEAN, 8, TFS(&tfs_30_clear), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_app_30_byte1_emb,\r\n{ "Event Message Buffer",\r\n"ipmi.app30.byte1.emb", FT_BOOLEAN, 8, TFS(&tfs_30_clear), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_app_30_byte1_rmq,\r\n{ "Receive Message Queue",\r\n"ipmi.app30.byte1.rmq", FT_BOOLEAN, 8, TFS(&tfs_30_clear), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_app_31_byte1_oem2,\r\n{ "OEM 2 data available",\r\n"ipmi.app31.byte1.oem2", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_app_31_byte1_oem1,\r\n{ "OEM 1 data available",\r\n"ipmi.app31.byte1.oem1", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_app_31_byte1_oem0,\r\n{ "OEM 0 data available",\r\n"ipmi.app31.byte1.oem0", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_app_31_byte1_wd_pretimeout,\r\n{ "Watchdog pre-timeout interrupt occurred",\r\n"ipmi.app31.byte1.wd_pretimeout", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_app_31_byte1_emb,\r\n{ "Event Message Buffer Full",\r\n"ipmi.app31.byte1.emb", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_app_31_byte1_rmq,\r\n{ "Receive Message Available",\r\n"ipmi.app31.byte1.rmq", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_app_32_rq_chno,\r\n{ "Channel",\r\n"ipmi.app32.rq_chno", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_app_32_rq_state,\r\n{ "Channel State",\r\n"ipmi.app32.rq_state", FT_UINT8, BASE_HEX, VALS(vals_32_state), 0x03, NULL, HFILL }},\r\n{ &hf_ipmi_app_32_rs_chno,\r\n{ "Channel",\r\n"ipmi.app32.rs_chno", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_app_32_rs_state,\r\n{ "Channel State",\r\n"ipmi.app32.rs_state", FT_BOOLEAN, 8, TFS(&tfs_32_state), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_app_33_rs_chan,\r\n{ "Channel",\r\n"ipmi.app33.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_app_33_rs_priv,\r\n{ "Inferred privilege level",\r\n"ipmi.app33.priv", FT_UINT8, BASE_HEX, VALS(vals_XX_priv), 0xf0, NULL, HFILL }},\r\n{ &hf_ipmi_app_33_msg,\r\n{ "Message data",\r\n"ipmi.app33.msg", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_34_track,\r\n{ "Tracking",\r\n"ipmi.app34.track", FT_UINT8, BASE_HEX, VALS(vals_34_track), 0xc0, NULL, HFILL }},\r\n{ &hf_ipmi_app_34_encrypt,\r\n{ "Encryption required",\r\n"ipmi.app34.encrypt", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_app_34_auth,\r\n{ "Authentication required",\r\n"ipmi.app34.auth", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_app_34_chan,\r\n{ "Channel",\r\n"ipmi.app34.chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_app_34_msg,\r\n{ "Embedded message",\r\n"ipmi.app34.msg", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rq_ipmi20,\r\n{ "Version compatibility",\r\n"ipmi.app38.rq_ipmi20", FT_UINT8, BASE_DEC, VALS(vals_38_ipmi20), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rq_chan,\r\n{ "Channel",\r\n"ipmi.app38.rq_chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rq_priv,\r\n{ "Requested privilege level",\r\n"ipmi.app38.rq_priv", FT_UINT8, BASE_HEX, VALS(vals_XX_priv), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_chan,\r\n{ "Channel",\r\n"ipmi.app38.rs_chan", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_channel), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_ipmi20,\r\n{ "Version compatibility",\r\n"ipmi.app38.rs_ipmi20", FT_UINT8, BASE_DEC, VALS(vals_38_ipmi20), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_auth_oem,\r\n{ "OEM Proprietary authentication",\r\n"ipmi.app38.rs_auth_oem", FT_BOOLEAN, 8, TFS(&tfs_38_supp), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_auth_straight,\r\n{ "Straight password/key",\r\n"ipmi.app38.rs_auth_straight", FT_BOOLEAN, 8, TFS(&tfs_38_supp), 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_auth_md5,\r\n{ "MD5",\r\n"ipmi.app38.rs_auth_md5", FT_BOOLEAN, 8, TFS(&tfs_38_supp), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_auth_md2,\r\n{ "MD2",\r\n"ipmi.app38.rs_auth_md2", FT_BOOLEAN, 8, TFS(&tfs_38_supp), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_auth_none,\r\n{ "No auth",\r\n"ipmi.app38.rs_auth_none", FT_BOOLEAN, 8, TFS(&tfs_38_supp), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_kg,\r\n{ "KG",\r\n"ipmi.app38.rs_kg_status", FT_BOOLEAN, 8, TFS(&tfs_38_kg), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_permsg,\r\n{ "Per-message Authentication disabled",\r\n"ipmi.app38.rs_permsg", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_userauth,\r\n{ "User-level Authentication disabled",\r\n"ipmi.app38.rs_userauth", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_user_nonnull,\r\n{ "Non-null usernames enabled",\r\n"ipmi.app38.rs_user_nonnull", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_user_null,\r\n{ "Null usernames enabled",\r\n"ipmi.app38.rs_user_null", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_user_anon,\r\n{ "Anonymous login enabled",\r\n"ipmi.app38.rs_user_anon", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_ipmi20_conn,\r\n{ "IPMI v2.0",\r\n"ipmi.app38.rs_ipmi20_conn", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_ipmi15_conn,\r\n{ "IPMI v1.5",\r\n"ipmi.app38.rs_ipmi15_conn", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_oem_iana,\r\n{ "OEM ID",\r\n"ipmi.app38.rs_oem_iana", FT_UINT24, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_38_rs_oem_aux,\r\n{ "OEM Auxiliary data",\r\n"ipmi.app38.rs_oem_aux", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_39_authtype,\r\n{ "Authentication Type",\r\n"ipmi.app39.authtype", FT_UINT8, BASE_HEX, VALS(vals_XX_auth), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_app_39_user,\r\n{ "User Name",\r\n"ipmi.app39.user", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_39_temp_session,\r\n{ "Temporary Session ID",\r\n"ipmi.app39.temp_session", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_39_challenge,\r\n{ "Challenge",\r\n"ipmi.app39.challenge", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_3a_authtype,\r\n{ "Authentication Type",\r\n"ipmi.app3a.authtype", FT_UINT8, BASE_HEX, VALS(vals_XX_auth), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_app_3a_privlevel,\r\n{ "Requested Maximum Privilege Level",\r\n"ipmi.app3a.privlevel", FT_UINT8, BASE_HEX, VALS(vals_XX_priv), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_app_3a_authcode,\r\n{ "Challenge string/Auth Code",\r\n"ipmi.app3a.authcode", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_3a_outbound_seq,\r\n{ "Initial Outbound Sequence Number",\r\n"ipmi.app3a.outbound_seq", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_3a_authtype_session,\r\n{ "Authentication Type for session",\r\n"ipmi.app3a.authtype_session", FT_UINT8, BASE_HEX, VALS(vals_XX_auth), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_app_3a_session_id,\r\n{ "Session ID",\r\n"ipmi.app3a.session_id", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_3a_inbound_seq,\r\n{ "Initial Inbound Sequence Number",\r\n"ipmi.app3a.inbound_seq", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_3a_maxpriv_session,\r\n{ "Maximum Privilege Level for session",\r\n"ipmi.app3a.maxpriv_session", FT_UINT8, BASE_HEX, VALS(vals_XX_priv), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_app_3b_req_priv,\r\n{ "Requested Privilege Level",\r\n"ipmi.app3b.req_priv", FT_UINT8, BASE_HEX, VALS(vals_XX_priv), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_app_3b_new_priv,\r\n{ "New Privilege Level",\r\n"ipmi.app3b.new_priv", FT_UINT8, BASE_HEX, VALS(vals_XX_priv), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_app_3c_session_id,\r\n{ "Session ID",\r\n"ipmi.app3c.session_id", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_app_3c_session_handle,\r\n{ "Session handle",\r\n"ipmi.app3c.session_handle", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ipmi_app_01_byte2,\r\n&ett_ipmi_app_01_byte3,\r\n&ett_ipmi_app_01_byte6,\r\n&ett_ipmi_app_04_byte2,\r\n&ett_ipmi_app_06_syspwr,\r\n&ett_ipmi_app_06_devpwr,\r\n&ett_ipmi_app_07_syspwr,\r\n&ett_ipmi_app_07_devpwr,\r\n&ett_ipmi_app_24_timer_use,\r\n&ett_ipmi_app_24_timer_action,\r\n&ett_ipmi_app_24_expiration_flags,\r\n&ett_ipmi_app_25_timer_use,\r\n&ett_ipmi_app_25_timer_action,\r\n&ett_ipmi_app_25_expiration_flags,\r\n&ett_ipmi_app_2e_byte1,\r\n&ett_ipmi_app_2f_byte1,\r\n&ett_ipmi_app_30_byte1,\r\n&ett_ipmi_app_31_byte1,\r\n&ett_ipmi_app_32_rq_byte1,\r\n&ett_ipmi_app_32_rq_byte2,\r\n&ett_ipmi_app_32_rs_byte1,\r\n&ett_ipmi_app_32_rs_byte2,\r\n&ett_ipmi_app_33_rs_byte1,\r\n&ett_ipmi_app_33_msg,\r\n&ett_ipmi_app_34_byte1,\r\n&ett_ipmi_app_34_msg,\r\n&ett_ipmi_app_38_rq_byte1,\r\n&ett_ipmi_app_38_rq_byte2,\r\n&ett_ipmi_app_38_rs_byte1,\r\n&ett_ipmi_app_38_rs_byte2,\r\n&ett_ipmi_app_38_rs_byte3,\r\n&ett_ipmi_app_38_rs_byte4,\r\n&ett_ipmi_app_39_byte1,\r\n&ett_ipmi_app_3a_rq_byte1,\r\n&ett_ipmi_app_3a_rq_byte2,\r\n&ett_ipmi_app_3a_rs_byte1,\r\n&ett_ipmi_app_3a_rs_byte10,\r\n&ett_ipmi_app_3b_rq_byte1,\r\n&ett_ipmi_app_3b_rs_byte1,\r\n};\r\nproto_register_field_array(proto_ipmi, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nipmi_register_netfn_cmdtab(IPMI_APP_REQ, IPMI_OEM_NONE, NULL, 0, NULL,\r\ncmd_app, array_length(cmd_app));\r\n}
