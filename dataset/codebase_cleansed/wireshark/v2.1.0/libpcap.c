wtap_open_return_val libpcap_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nguint32 magic;\r\nstruct pcap_hdr hdr;\r\ngboolean byte_swapped;\r\ngboolean modified;\r\ngboolean aix;\r\nint file_encap;\r\ngint64 first_packet_offset;\r\nlibpcap_t *libpcap;\r\nstatic const int subtypes_modified[] = {\r\nWTAP_FILE_TYPE_SUBTYPE_PCAP_SS991029,\r\nWTAP_FILE_TYPE_SUBTYPE_PCAP_SS990915\r\n};\r\n#define N_SUBTYPES_MODIFIED G_N_ELEMENTS(subtypes_modified)\r\nstatic const int subtypes_standard[] = {\r\nWTAP_FILE_TYPE_SUBTYPE_PCAP,\r\nWTAP_FILE_TYPE_SUBTYPE_PCAP_SS990417,\r\nWTAP_FILE_TYPE_SUBTYPE_PCAP_NOKIA\r\n};\r\n#define N_SUBTYPES_STANDARD G_N_ELEMENTS(subtypes_standard)\r\nstatic const int subtypes_nsec[] = {\r\nWTAP_FILE_TYPE_SUBTYPE_PCAP_NSEC\r\n};\r\n#define N_SUBTYPES_NSEC G_N_ELEMENTS(subtypes_nsec)\r\n#define MAX_FIGURES_OF_MERIT \\r\nMAX(MAX(N_SUBTYPES_MODIFIED, N_SUBTYPES_STANDARD), N_SUBTYPES_NSEC)\r\nint figures_of_merit[MAX_FIGURES_OF_MERIT];\r\nconst int *subtypes;\r\nint n_subtypes;\r\nint best_subtype;\r\nint i;\r\nif (!wtap_read_bytes(wth->fh, &magic, sizeof magic, err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nswitch (magic) {\r\ncase PCAP_MAGIC:\r\nbyte_swapped = FALSE;\r\nmodified = FALSE;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nbreak;\r\ncase PCAP_MODIFIED_MAGIC:\r\nbyte_swapped = FALSE;\r\nmodified = TRUE;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nbreak;\r\ncase PCAP_SWAPPED_MAGIC:\r\nbyte_swapped = TRUE;\r\nmodified = FALSE;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nbreak;\r\ncase PCAP_SWAPPED_MODIFIED_MAGIC:\r\nbyte_swapped = TRUE;\r\nmodified = TRUE;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nbreak;\r\ncase PCAP_NSEC_MAGIC:\r\nbyte_swapped = FALSE;\r\nmodified = FALSE;\r\nwth->file_tsprec = WTAP_TSPREC_NSEC;\r\nbreak;\r\ncase PCAP_SWAPPED_NSEC_MAGIC:\r\nbyte_swapped = TRUE;\r\nmodified = FALSE;\r\nwth->file_tsprec = WTAP_TSPREC_NSEC;\r\nbreak;\r\ndefault:\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (!wtap_read_bytes(wth->fh, &hdr, sizeof hdr, err, err_info))\r\nreturn WTAP_OPEN_ERROR;\r\nif (byte_swapped) {\r\nhdr.version_major = GUINT16_SWAP_LE_BE(hdr.version_major);\r\nhdr.version_minor = GUINT16_SWAP_LE_BE(hdr.version_minor);\r\nhdr.snaplen = GUINT32_SWAP_LE_BE(hdr.snaplen);\r\nhdr.network = GUINT32_SWAP_LE_BE(hdr.network);\r\n}\r\nif (hdr.version_major < 2) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("pcap: major version %u unsupported",\r\nhdr.version_major);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\naix = FALSE;\r\nif (hdr.version_major == 2 && hdr.version_minor == 2) {\r\nswitch (hdr.network) {\r\ncase 6:\r\nhdr.network = 1;\r\naix = TRUE;\r\nbreak;\r\ncase 9:\r\nhdr.network = 6;\r\naix = TRUE;\r\nbreak;\r\ncase 15:\r\nhdr.network = 10;\r\naix = TRUE;\r\nbreak;\r\ncase 24:\r\nhdr.network = 0;\r\naix = TRUE;\r\nbreak;\r\n}\r\n}\r\nfile_encap = wtap_pcap_encap_to_wtap_encap(hdr.network);\r\nif (file_encap == WTAP_ENCAP_UNKNOWN) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("pcap: network type %u unknown or unsupported",\r\nhdr.network);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nlibpcap = (libpcap_t *)g_malloc(sizeof(libpcap_t));\r\nlibpcap->byte_swapped = byte_swapped;\r\nlibpcap->version_major = hdr.version_major;\r\nlibpcap->version_minor = hdr.version_minor;\r\nwth->priv = (void *)libpcap;\r\nwth->subtype_read = libpcap_read;\r\nwth->subtype_seek_read = libpcap_seek_read;\r\nwth->file_encap = file_encap;\r\nwth->snapshot_length = hdr.snaplen;\r\nswitch (hdr.version_major) {\r\ncase 2:\r\nif (hdr.version_minor < 3)\r\nlibpcap->lengths_swapped = SWAPPED;\r\nelse if (hdr.version_minor == 3)\r\nlibpcap->lengths_swapped = MAYBE_SWAPPED;\r\nelse\r\nlibpcap->lengths_swapped = NOT_SWAPPED;\r\nbreak;\r\ncase 543:\r\nlibpcap->lengths_swapped = SWAPPED;\r\nbreak;\r\ndefault:\r\nlibpcap->lengths_swapped = NOT_SWAPPED;\r\nbreak;\r\n}\r\nif (aix) {\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_PCAP_AIX;\r\nwth->file_tsprec = WTAP_TSPREC_NSEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nif (modified) {\r\nsubtypes = subtypes_modified;\r\nn_subtypes = N_SUBTYPES_MODIFIED;\r\n} else {\r\nif (wth->file_tsprec == WTAP_TSPREC_NSEC) {\r\nsubtypes = subtypes_nsec;\r\nn_subtypes = N_SUBTYPES_NSEC;\r\n} else {\r\nsubtypes = subtypes_standard;\r\nn_subtypes = N_SUBTYPES_STANDARD;\r\n}\r\n}\r\nfirst_packet_offset = file_tell(wth->fh);\r\nfor (i = 0; i < n_subtypes; i++) {\r\nwth->file_type_subtype = subtypes[i];\r\nfigures_of_merit[i] = libpcap_try(wth, err, err_info);\r\nif (figures_of_merit[i] == -1) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (figures_of_merit[i] == 0) {\r\nif (file_seek(wth->fh, first_packet_offset, SEEK_SET, err) == -1) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\ngoto done;\r\n}\r\nif (file_seek(wth->fh, first_packet_offset, SEEK_SET, err) == -1) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\n}\r\nbest_subtype = INT_MAX;\r\nfor (i = 0; i < n_subtypes; i++) {\r\nif (figures_of_merit[i] < best_subtype) {\r\nwth->file_type_subtype = subtypes[i];\r\nbest_subtype = figures_of_merit[i];\r\n}\r\n}\r\ndone:\r\nif (wth->file_type_subtype == WTAP_FILE_TYPE_SUBTYPE_PCAP_NOKIA &&\r\nhdr.network == 13)\r\nwth->file_encap = WTAP_ENCAP_ATM_PDUS;\r\nif (wth->file_encap == WTAP_ENCAP_ERF) {\r\nerf_populate_interfaces(wth);\r\n}\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic int libpcap_try(wtap *wth, int *err, gchar **err_info)\r\n{\r\nint ret;\r\nstruct pcaprec_ss990915_hdr first_rec_hdr, second_rec_hdr;\r\nret = libpcap_try_header(wth, wth->fh, err, err_info, &first_rec_hdr);\r\nif (ret == -1) {\r\nif (*err == 0 || *err == WTAP_ERR_SHORT_READ) {\r\nreturn 0;\r\n}\r\nreturn ret;\r\n}\r\nif (ret != 0) {\r\nreturn ret;\r\n}\r\nif (file_seek(wth->fh, first_rec_hdr.hdr.incl_len, SEEK_CUR, err) == -1)\r\nreturn -1;\r\nret = libpcap_try_header(wth, wth->fh, err, err_info, &second_rec_hdr);\r\nif (ret == -1) {\r\nif (*err == 0 || *err == WTAP_ERR_SHORT_READ) {\r\nreturn 0;\r\n}\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int libpcap_try_header(wtap *wth, FILE_T fh, int *err, gchar **err_info,\r\nstruct pcaprec_ss990915_hdr *hdr)\r\n{\r\nint ret;\r\nif (!libpcap_read_header(wth, fh, err, err_info, hdr))\r\nreturn -1;\r\nret = 0;\r\nswitch (wth->file_type_subtype) {\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_NSEC:\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_AIX:\r\nif (hdr->hdr.ts_usec >= 1000000000)\r\nret++;\r\nbreak;\r\ndefault:\r\nif (hdr->hdr.ts_usec >= 1000000)\r\nret++;\r\nbreak;\r\n}\r\nif (hdr->hdr.incl_len > WTAP_MAX_PACKET_SIZE) {\r\nret++;\r\n}\r\nif (hdr->hdr.orig_len > 64*1024*1024) {\r\nret++;\r\n}\r\nif (hdr->hdr.incl_len > wth->snapshot_length) {\r\nret++;\r\n}\r\nif (hdr->hdr.incl_len > hdr->hdr.orig_len) {\r\nret++;\r\n}\r\nreturn ret;\r\n}\r\nstatic gboolean libpcap_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\n*data_offset = file_tell(wth->fh);\r\nreturn libpcap_read_packet(wth, wth->fh, &wth->phdr,\r\nwth->frame_buffer, err, err_info);\r\n}\r\nstatic gboolean\r\nlibpcap_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (!libpcap_read_packet(wth, wth->random_fh, phdr, buf, err,\r\nerr_info)) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nlibpcap_read_packet(wtap *wth, FILE_T fh, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nstruct pcaprec_ss990915_hdr hdr;\r\nguint packet_size;\r\nguint orig_size;\r\nint phdr_len;\r\nlibpcap_t *libpcap;\r\nif (!libpcap_read_header(wth, fh, err, err_info, &hdr))\r\nreturn FALSE;\r\nif (hdr.hdr.incl_len > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\nif (err_info != NULL) {\r\n*err_info = g_strdup_printf("pcap: File has %u-byte packet, bigger than maximum of %u",\r\nhdr.hdr.incl_len, WTAP_MAX_PACKET_SIZE);\r\n}\r\nreturn FALSE;\r\n}\r\npacket_size = hdr.hdr.incl_len;\r\norig_size = hdr.hdr.orig_len;\r\nif (wth->file_type_subtype == WTAP_FILE_TYPE_SUBTYPE_PCAP_AIX &&\r\n(wth->file_encap == WTAP_ENCAP_FDDI ||\r\nwth->file_encap == WTAP_ENCAP_FDDI_BITSWAPPED)) {\r\npacket_size -= 3;\r\norig_size -= 3;\r\nif (!file_skip(fh, 3, err))\r\nreturn FALSE;\r\n}\r\nphdr_len = pcap_process_pseudo_header(fh, wth->file_type_subtype,\r\nwth->file_encap, packet_size, TRUE, phdr, err, err_info);\r\nif (phdr_len < 0)\r\nreturn FALSE;\r\norig_size -= phdr_len;\r\npacket_size -= phdr_len;\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\nif (wth->file_encap != WTAP_ENCAP_ERF) {\r\nphdr->ts.secs = hdr.hdr.ts_sec;\r\nif (wth->file_tsprec == WTAP_TSPREC_NSEC)\r\nphdr->ts.nsecs = hdr.hdr.ts_usec;\r\nelse\r\nphdr->ts.nsecs = hdr.hdr.ts_usec * 1000;\r\n} else {\r\nphdr->presence_flags |= WTAP_HAS_INTERFACE_ID;\r\nphdr->interface_id = phdr->pseudo_header.erf.phdr.flags & 0x03;\r\n}\r\nphdr->caplen = packet_size;\r\nphdr->len = orig_size;\r\nif (!wtap_read_packet_bytes(fh, buf, packet_size, err, err_info))\r\nreturn FALSE;\r\nlibpcap = (libpcap_t *)wth->priv;\r\npcap_read_post_process(wth->file_type_subtype, wth->file_encap,\r\nphdr, ws_buffer_start_ptr(buf), libpcap->byte_swapped, -1);\r\nreturn TRUE;\r\n}\r\nstatic int libpcap_read_header(wtap *wth, FILE_T fh, int *err, gchar **err_info,\r\nstruct pcaprec_ss990915_hdr *hdr)\r\n{\r\nint bytes_to_read;\r\nguint32 temp;\r\nlibpcap_t *libpcap;\r\nswitch (wth->file_type_subtype) {\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP:\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_AIX:\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_NSEC:\r\nbytes_to_read = sizeof (struct pcaprec_hdr);\r\nbreak;\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_SS990417:\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_SS991029:\r\nbytes_to_read = sizeof (struct pcaprec_modified_hdr);\r\nbreak;\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_SS990915:\r\nbytes_to_read = sizeof (struct pcaprec_ss990915_hdr);\r\nbreak;\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_NOKIA:\r\nbytes_to_read = sizeof (struct pcaprec_nokia_hdr);\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nbytes_to_read = 0;\r\n}\r\nif (!wtap_read_bytes_or_eof(fh, hdr, bytes_to_read, err, err_info))\r\nreturn FALSE;\r\nlibpcap = (libpcap_t *)wth->priv;\r\nif (libpcap->byte_swapped) {\r\nhdr->hdr.ts_sec = GUINT32_SWAP_LE_BE(hdr->hdr.ts_sec);\r\nhdr->hdr.ts_usec = GUINT32_SWAP_LE_BE(hdr->hdr.ts_usec);\r\nhdr->hdr.incl_len = GUINT32_SWAP_LE_BE(hdr->hdr.incl_len);\r\nhdr->hdr.orig_len = GUINT32_SWAP_LE_BE(hdr->hdr.orig_len);\r\n}\r\nswitch (libpcap->lengths_swapped) {\r\ncase NOT_SWAPPED:\r\nbreak;\r\ncase MAYBE_SWAPPED:\r\nif (hdr->hdr.incl_len <= hdr->hdr.orig_len) {\r\nbreak;\r\n}\r\ncase SWAPPED:\r\ntemp = hdr->hdr.orig_len;\r\nhdr->hdr.orig_len = hdr->hdr.incl_len;\r\nhdr->hdr.incl_len = temp;\r\nbreak;\r\n}\r\nreturn TRUE;\r\n}\r\nint libpcap_dump_can_write_encap(int encap)\r\n{\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nif (wtap_wtap_encap_to_pcap_encap(encap) == -1)\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\nreturn 0;\r\n}\r\ngboolean libpcap_dump_open(wtap_dumper *wdh, int *err)\r\n{\r\nguint32 magic;\r\nstruct pcap_hdr file_hdr;\r\nwdh->subtype_write = libpcap_dump;\r\nswitch (wdh->file_type_subtype) {\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP:\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_SS990417:\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_NOKIA:\r\nmagic = PCAP_MAGIC;\r\nwdh->tsprecision = WTAP_TSPREC_USEC;\r\nbreak;\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_SS990915:\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_SS991029:\r\nmagic = PCAP_MODIFIED_MAGIC;\r\nwdh->tsprecision = WTAP_TSPREC_USEC;\r\nbreak;\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_NSEC:\r\nmagic = PCAP_NSEC_MAGIC;\r\nwdh->tsprecision = WTAP_TSPREC_NSEC;\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_UNWRITABLE_FILE_TYPE;\r\nreturn FALSE;\r\n}\r\nif (!wtap_dump_file_write(wdh, &magic, sizeof magic, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += sizeof magic;\r\nfile_hdr.version_major = 2;\r\nfile_hdr.version_minor = 4;\r\nfile_hdr.thiszone = 0;\r\nfile_hdr.sigfigs = 0;\r\nfile_hdr.snaplen = (wdh->snaplen != 0) ? wdh->snaplen :\r\nWTAP_MAX_PACKET_SIZE;\r\nfile_hdr.network = wtap_wtap_encap_to_pcap_encap(wdh->encap);\r\nif (!wtap_dump_file_write(wdh, &file_hdr, sizeof file_hdr, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += sizeof file_hdr;\r\nreturn TRUE;\r\n}\r\nstatic gboolean libpcap_dump(wtap_dumper *wdh,\r\nconst struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info _U_)\r\n{\r\nconst union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nstruct pcaprec_ss990915_hdr rec_hdr;\r\nsize_t hdr_size;\r\nint phdrsize;\r\nphdrsize = pcap_get_phdr_size(wdh->encap, pseudo_header);\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\nif (phdr->caplen + phdrsize > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_PACKET_TOO_LARGE;\r\nreturn FALSE;\r\n}\r\nrec_hdr.hdr.ts_sec = (guint32) phdr->ts.secs;\r\nif(wdh->tsprecision == WTAP_TSPREC_NSEC) {\r\nrec_hdr.hdr.ts_usec = phdr->ts.nsecs;\r\n} else {\r\nrec_hdr.hdr.ts_usec = phdr->ts.nsecs / 1000;\r\n}\r\nrec_hdr.hdr.incl_len = phdr->caplen + phdrsize;\r\nrec_hdr.hdr.orig_len = phdr->len + phdrsize;\r\nif (rec_hdr.hdr.incl_len > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\nreturn FALSE;\r\n}\r\nswitch (wdh->file_type_subtype) {\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP:\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_NSEC:\r\nhdr_size = sizeof (struct pcaprec_hdr);\r\nbreak;\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_SS990417:\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_SS991029:\r\nrec_hdr.ifindex = 0;\r\nrec_hdr.protocol = 0;\r\nrec_hdr.pkt_type = 0;\r\nhdr_size = sizeof (struct pcaprec_modified_hdr);\r\nbreak;\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_SS990915:\r\nrec_hdr.ifindex = 0;\r\nrec_hdr.protocol = 0;\r\nrec_hdr.pkt_type = 0;\r\nrec_hdr.cpu1 = 0;\r\nrec_hdr.cpu2 = 0;\r\nhdr_size = sizeof (struct pcaprec_ss990915_hdr);\r\nbreak;\r\ncase WTAP_FILE_TYPE_SUBTYPE_PCAP_NOKIA:\r\nmemcpy(&rec_hdr.ifindex, pseudo_header->nokia.stuff, 4);\r\nrec_hdr.protocol = 0;\r\nrec_hdr.pkt_type = 0;\r\nrec_hdr.cpu1 = 0;\r\nrec_hdr.cpu2 = 0;\r\nhdr_size = sizeof (struct pcaprec_nokia_hdr);\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\n*err = WTAP_ERR_UNWRITABLE_FILE_TYPE;\r\nreturn FALSE;\r\n}\r\nif (!wtap_dump_file_write(wdh, &rec_hdr, hdr_size, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += hdr_size;\r\nif (!pcap_write_phdr(wdh, wdh->encap, pseudo_header, err))\r\nreturn FALSE;\r\nif (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += phdr->caplen;\r\nreturn TRUE;\r\n}
