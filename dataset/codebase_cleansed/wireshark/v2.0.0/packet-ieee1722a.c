static void dissect_1722a (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nproto_item *ti = NULL;\r\nproto_tree *ieee1722a_tree = NULL;\r\nproto_tree *audio_tree = NULL;\r\nproto_tree *sample_tree = NULL;\r\nproto_tree *timestamp_tree = NULL;\r\ngint offset = 0;\r\nguint16 datalen = 0;\r\nguint16 channels_per_frame = 0;\r\nguint8 subtype = 0;\r\ngint sample_width = 0;\r\nint i, j;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "IEEE1722a");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "AVB Transportation Protocol");\r\nif (tree)\r\n{\r\nti = proto_tree_add_item(tree, proto_1722a, tvb, 0, -1, ENC_NA);\r\nieee1722a_tree = proto_item_add_subtree(ti, ett_1722a);\r\n}\r\nsubtype = tvb_get_guint8(tvb, IEEE_1722A_CD_OFFSET);\r\nsubtype &= IEEE_1722A_SUBTYPE_MASK;\r\nswitch (subtype)\r\n{\r\ncase IEEE_1722A_SUBTYPE_AVTP_AUDIO:\r\nif (tree)\r\n{\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_mrfield, tvb, IEEE_1722A_VERSION_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_tvfield, tvb, IEEE_1722A_VERSION_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_seqnum, tvb, IEEE_1722A_SEQ_NUM_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_tufield, tvb, IEEE_1722A_TU_FIELD_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_stream_id, tvb, IEEE_1722A_STREAM_ID_OFFSET, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_avbtp_timestamp, tvb, IEEE_1722A_TIMESTAMP_OFFSET, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_format_info, tvb, IEEE_1722A_FORMAT_INFO_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_nominal_sample_rate, tvb, IEEE_1722A_NOM_SAMPLE_RATE_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_channels_per_frame, tvb, IEEE_1722A_CHANNELS_PER_FRAME_OFFSET, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_bit_depth, tvb, IEEE_1722A_BIT_DEPTH_OFFSET, 1, ENC_BIG_ENDIAN);\r\nti = proto_tree_add_item(ieee1722a_tree, hf_1722a_stream_data_length, tvb, IEEE_1722A_STREAM_DATA_LENGTH_OFFSET, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(ti, " bytes");\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_sparse_timestamp, tvb, IEEE_1722A_SPARSE_TIMESTAMP_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_evtfield, tvb, IEEE_1722A_EVT_OFFSET, 1, ENC_BIG_ENDIAN);\r\n}\r\ndatalen = tvb_get_ntohs(tvb, IEEE_1722A_STREAM_DATA_LENGTH_OFFSET);\r\nti = proto_tree_add_item(ieee1722a_tree, hf_1722a_data, tvb, IEEE_1722A_DATA_OFFSET, datalen, ENC_NA);\r\naudio_tree = proto_item_add_subtree(ti, ett_1722a_audio);\r\noffset = IEEE_1722A_DATA_OFFSET;\r\nchannels_per_frame = tvb_get_ntohs(tvb, IEEE_1722A_CHANNELS_PER_FRAME_OFFSET);\r\nchannels_per_frame &= IEEE_1722A_CHANNEL_PER_FRAME_MASK;\r\nswitch (tvb_get_guint8(tvb, IEEE_1722A_FORMAT_INFO_OFFSET))\r\n{\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nsample_width = 32;\r\nbreak;\r\ncase 2:\r\nsample_width = 32;\r\nbreak;\r\ncase 3:\r\nsample_width = 24;\r\nbreak;\r\ncase 4:\r\nsample_width = 16;\r\nbreak;\r\ndefault:\r\nexpert_add_info(pinfo, ti, &ei_format_info);\r\nbreak;\r\n}\r\nif (sample_width == 0)\r\n{\r\nexpert_add_info(pinfo, ti, &ei_sample_width);\r\n}\r\nelse\r\n{\r\nif (channels_per_frame == 0)\r\n{\r\nexpert_add_info(pinfo, ti, &ei_channels_per_frame);\r\n}\r\nelse\r\n{\r\nif (tree)\r\n{\r\nfor (j = 0; j < ((datalen * 8) / (channels_per_frame * sample_width)); j++)\r\n{\r\nsample_tree = proto_tree_add_subtree_format(audio_tree, tvb, offset, 1,\r\nett_1722a_sample, &ti, "Sample Chunk %d", j);\r\nfor (i = 0; i < channels_per_frame; i++)\r\n{\r\nti = proto_tree_add_item(sample_tree, hf_1722a_sample, tvb, offset, sample_width / 8, ENC_NA);\r\nproto_item_prepend_text(ti, "Channel: %d ", i);\r\noffset += (sample_width / 8);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nbreak;\r\ncase IEEE_1722A_SUBTYPE_CRF:\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_mrfield, tvb, IEEE_1722A_VERSION_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_tvfield, tvb, IEEE_1722A_VERSION_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_seqnum, tvb, IEEE_1722A_SEQ_NUM_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_tufield, tvb, IEEE_1722A_TU_FIELD_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_stream_id, tvb, IEEE_1722A_STREAM_ID_OFFSET, 8, ENC_BIG_ENDIAN);\r\nti = proto_tree_add_item(ieee1722a_tree, hf_1722a_stream_data_length, tvb, IEEE_1722A_STREAM_DATA_LENGTH_OFFSET, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(ti, " bytes");\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_crf_type, tvb, IEEE_1722A_CRF_TYPE_OFFSET, 2, ENC_BIG_ENDIAN);\r\nswitch (tvb_get_ntohs(tvb, IEEE_1722A_CRF_TYPE_OFFSET))\r\n{\r\ncase IEEE_1722A_CRF_AUDIO_SAMPLE_TIMESTAMP:\r\nif (tree)\r\n{\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_clock_frequency, tvb, IEEE_1722A_CRF_CLOCK_FREQUENCY_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_clock_multiplier, tvb, IEEE_1722A_CRF_CLOCK_MULTIPLIER_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722a_tree, hf_1722a_timestamp_interval, tvb, IEEE_1722A_CRF_TIMESTAMP_INTERVAL_OFFSET, 2, ENC_BIG_ENDIAN);\r\ndatalen = tvb_get_ntohs(tvb, IEEE_1722A_STREAM_DATA_LENGTH_OFFSET);\r\ndatalen = datalen - 6;\r\nti = proto_tree_add_item(ieee1722a_tree, hf_1722a_crf_timestamp, tvb, IEEE_1722A_CRF_AUDIO_TIMESTAMP_OFFSET, datalen, ENC_NA);\r\ntimestamp_tree = proto_item_add_subtree(ti, ett_1722a_crf_timestamp);\r\noffset = IEEE_1722A_CRF_AUDIO_TIMESTAMP_OFFSET;\r\nfor (j = 0; j < (datalen / IEEE_1722A_CRF_TIMESTAMP_SIZE); j++)\r\n{\r\nproto_tree_add_item(timestamp_tree, hf_1722a_crf_timestamp_data, tvb, offset, IEEE_1722A_CRF_TIMESTAMP_SIZE, ENC_BIG_ENDIAN);\r\noffset += IEEE_1722A_CRF_TIMESTAMP_SIZE;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nexpert_add_info(pinfo, ti, &ei_clock_reference_type);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nbreak;\r\n}\r\n}\r\nvoid proto_register_1722a (void)\r\n{\r\nexpert_module_t *expert_1722a;\r\nstatic hf_register_info hf[] =\r\n{\r\n{ &hf_1722a_mrfield,\r\n{ "AVBTP Media Clock Restart", "ieee1722a.mrfield",\r\nFT_BOOLEAN, 8, NULL, IEEE_1722A_MR_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722a_tvfield,\r\n{ "Source Timestamp Valid", "ieee1722a.tvfield",\r\nFT_BOOLEAN, 8, NULL, IEEE_1722A_TV_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722a_seqnum,\r\n{ "Sequence Number", "ieee1722a.seqnum",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722a_tufield,\r\n{ "AVBTP Timestamp Uncertain", "ieee1722a.tufield",\r\nFT_BOOLEAN, 8, NULL, IEEE_1722A_TU_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722a_stream_id,\r\n{ "Stream ID", "ieee1722a.stream_id",\r\nFT_UINT64, BASE_HEX, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722a_avbtp_timestamp,\r\n{ "AVBTP Timestamp", "ieee1722a.avbtp_timestamp",\r\nFT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722a_format_info,\r\n{ "Format Info", "ieee1722a.format_info",\r\nFT_UINT8, BASE_HEX, VALS(format_info_vals), 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722a_nominal_sample_rate,\r\n{ "Nominal Sample Rate", "ieee1722a.nominal_sample_rate",\r\nFT_UINT8, BASE_HEX, VALS(sample_rate_type_vals), IEEE_1722A_NOM_SAMPLE_RATE_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722a_bit_depth,\r\n{ "Bit Depth", "ieee1722a.bit_depth",\r\nFT_UINT8, BASE_HEX, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722a_stream_data_length,\r\n{ "Stream Data Length", "ieee1722a.stream_data_len",\r\nFT_UINT16, BASE_DEC, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722a_sparse_timestamp,\r\n{ "Sparse Timestamp Mode", "ieee1722a.sparse_timestamp",\r\nFT_BOOLEAN, 8, NULL, IEEE_1722A_SP_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722a_evtfield,\r\n{ "EVT", "ieee1722a.evtfield",\r\nFT_UINT8, BASE_HEX, NULL, IEEE_1722A_EVT_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722a_channels_per_frame,\r\n{ "Channels per Frame", "ieee1722a.channels_per_frame",\r\nFT_UINT16, BASE_DEC, NULL, IEEE_1722A_CHANNEL_PER_FRAME_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722a_data,\r\n{ "Audio Data", "ieee1722a.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722a_sample,\r\n{ "Sample Data", "ieee1722a.data.sample.sampledata",\r\nFT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722a_crf_type,\r\n{ "Type", "ieee1722a.type",\r\nFT_UINT16, BASE_HEX, VALS(clock_reference_format_type_vals), 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722a_clock_frequency,\r\n{ "Clock Frequency", "ieee1722a.clock_frequency",\r\nFT_UINT8, BASE_HEX, VALS(clock_frequency_type_vals), 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722a_clock_multiplier,\r\n{ "Clock Multiplier", "ieee1722a.clock_multiplier",\r\nFT_UINT8, BASE_HEX, VALS(clock_multiplier_type_vals), 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722a_timestamp_interval,\r\n{ "Timestamp Interval", "ieee1722a.timestamp_interval",\r\nFT_UINT16, BASE_DEC, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722a_crf_timestamp,\r\n{ "Timestamps", "ieee1722a.crf_timestamps",\r\nFT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722a_crf_timestamp_data,\r\n{ "Timestamp Data", "ieee1722a.crf_timestamp_data",\r\nFT_UINT64, BASE_HEX, NULL, 0x00, NULL, HFILL }\r\n}\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_sample_width, { "1722a.expert.sample_width_zero", PI_PROTOCOL, PI_WARN, "Wrong value for Sample Width", EXPFILL }},\r\n{ &ei_channels_per_frame, { "1722a.expert.channels_per_frame_zero", PI_PROTOCOL, PI_WARN, "Wrong value for parameter Channels per Frame", EXPFILL }},\r\n{ &ei_unknown_parameter, { "1722a.expert.unknown_parameter", PI_PROTOCOL, PI_WARN, "Unknown parameter", EXPFILL }},\r\n{ &ei_format_info, { "1722a.expert.format_info", PI_PROTOCOL, PI_WARN, "Format Info Value Reserved", EXPFILL }},\r\n{ &ei_clock_reference_type, { "1722a.expert.clock_reference_format_type", PI_PROTOCOL, PI_WARN, "The CRF type is not supported", EXPFILL }}\r\n};\r\nstatic gint *ett[] =\r\n{\r\n&ett_1722a,\r\n&ett_1722a_audio,\r\n&ett_1722a_sample,\r\n&ett_1722a_crf_timestamp\r\n};\r\nproto_1722a = proto_register_protocol(\r\n"IEEE 1722a Protocol",\r\n"1722A",\r\n"1722a"\r\n);\r\nproto_register_field_array(proto_1722a, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_1722a = expert_register_protocol(proto_1722a);\r\nexpert_register_field_array(expert_1722a, ei, array_length(ei));\r\n}\r\nvoid proto_reg_handoff_1722a(void)\r\n{\r\ndissector_handle_t avb1722a_handle;\r\navb1722a_handle = create_dissector_handle(dissect_1722a, proto_1722a);\r\ndissector_add_uint("ieee1722.subtype", IEEE_1722A_SUBTYPE_AVTP_AUDIO, avb1722a_handle);\r\ndissector_add_uint("ieee1722.subtype", IEEE_1722A_SUBTYPE_CRF, avb1722a_handle);\r\n}
