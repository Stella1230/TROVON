static void\r\ndissect_1722(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nproto_item *ti;\r\nproto_tree *ieee1722_tree = NULL;\r\nproto_tree *audio_tree;\r\nproto_tree *sample_tree;\r\ngint offset;\r\nguint16 datalen;\r\nguint8 dbs;\r\nguint8 subtype;\r\nint i, j;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "IEEE1722");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "AVB Transportation Protocol");\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_1722, tvb, 0, -1, ENC_NA);\r\nieee1722_tree = proto_item_add_subtree(ti, ett_1722);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_cdfield, tvb, IEEE_1722_CD_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_subtype, tvb, IEEE_1722_CD_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_svfield, tvb, IEEE_1722_VERSION_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_verfield, tvb, IEEE_1722_VERSION_OFFSET, 1, ENC_BIG_ENDIAN);\r\n}\r\nsubtype = tvb_get_guint8(tvb, IEEE_1722_CD_OFFSET);\r\nsubtype &= 0x7F;\r\nif (dissector_try_uint(avb_dissector_table, subtype, tvb, pinfo, tree)) return;\r\nif (tree) {\r\nproto_tree_add_item(ieee1722_tree, hf_1722_mrfield, tvb, IEEE_1722_VERSION_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_gvfield, tvb, IEEE_1722_VERSION_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_tvfield, tvb, IEEE_1722_VERSION_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_seqnum, tvb,\r\nIEEE_1722_SEQ_NUM_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_tufield, tvb,\r\nIEEE_1722_TU_FIELD_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_stream_id, tvb,\r\nIEEE_1722_STREAM_ID_OFFSET, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_avbtp_timestamp, tvb,\r\nIEEE_1722_TIMESTAMP_OFFSET, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_gateway_info, tvb,\r\nIEEE_1722_GW_INFO_OFFSET, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_packet_data_length, tvb,\r\nIEEE_1722_PKT_DATA_LENGTH_OFFSET, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_tag, tvb,\r\nIEEE_1722_TAG_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_channel, tvb,\r\nIEEE_1722_TAG_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_tcode, tvb,\r\nIEEE_1722_TCODE_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_sy, tvb,\r\nIEEE_1722_TCODE_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_sid, tvb,\r\nIEEE_1722_SID_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_dbs, tvb,\r\nIEEE_1722_DBS_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_fn, tvb,\r\nIEEE_1722_FN_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_qpc, tvb,\r\nIEEE_1722_FN_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_sph, tvb,\r\nIEEE_1722_FN_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_dbc, tvb,\r\nIEEE_1722_DBC_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_fmt, tvb,\r\nIEEE_1722_FMT_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_fdf, tvb,\r\nIEEE_1722_FDF_OFFSET, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ieee1722_tree, hf_1722_syt, tvb,\r\nIEEE_1722_SYT_OFFSET, 2, ENC_BIG_ENDIAN);\r\ndatalen = tvb_get_ntohs(tvb, IEEE_1722_PKT_DATA_LENGTH_OFFSET);\r\ndatalen -= IEEE_1722_CIP_HEADER_SIZE;\r\nti = proto_tree_add_item(ieee1722_tree, hf_1722_data, tvb,\r\nIEEE_1722_DATA_OFFSET, datalen, ENC_NA);\r\naudio_tree = proto_item_add_subtree(ti, ett_1722_audio);\r\noffset = IEEE_1722_DATA_OFFSET;\r\ndbs = tvb_get_guint8(tvb, IEEE_1722_DBS_OFFSET);\r\nif(dbs == 0)\r\nexpert_add_info(pinfo, ti, &ei_1722_incorrect_dbs);\r\nelse {\r\nfor (j = 0; j < (datalen / (dbs*4)); j++) {\r\nsample_tree = proto_tree_add_subtree_format(audio_tree, tvb, offset, 1, ett_1722_sample, NULL, "Sample %d", j+1);\r\nfor (i = 0; i < dbs; i++) {\r\nproto_tree_add_item(sample_tree, hf_1722_label, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(sample_tree, hf_1722_sample, tvb, offset, 3, ENC_NA);\r\noffset += 3;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nvoid proto_register_1722(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_1722_cdfield,\r\n{ "Control/Data Indicator", "ieee1722.cdfield",\r\nFT_BOOLEAN, 8, NULL, IEEE_1722_CD_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_subtype,\r\n{ "AVBTP Subtype", "ieee1722.subtype",\r\nFT_UINT8, BASE_HEX, NULL, IEEE_1722_SUBTYPE_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_svfield,\r\n{ "AVBTP Stream ID Valid", "ieee1722.svfield",\r\nFT_BOOLEAN, 8, NULL, IEEE_1722_SV_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_verfield,\r\n{ "AVBTP Version", "ieee1722.verfield",\r\nFT_UINT8, BASE_HEX, NULL, IEEE_1722_VER_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_mrfield,\r\n{ "AVBTP Media Reset", "ieee1722.mrfield",\r\nFT_UINT8, BASE_DEC, NULL, IEEE_1722_MR_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_gvfield,\r\n{ "AVBTP Gateway Info Valid", "ieee1722.gvfield",\r\nFT_BOOLEAN, 8, NULL, IEEE_1722_GV_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_tvfield,\r\n{ "Source Timestamp Valid", "ieee1722.tvfield",\r\nFT_BOOLEAN, 8, NULL, IEEE_1722_TV_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_seqnum,\r\n{ "Sequence Number", "ieee1722.seqnum",\r\nFT_UINT8, BASE_HEX, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722_tufield,\r\n{ "AVBTP Timestamp Uncertain", "ieee1722.tufield",\r\nFT_BOOLEAN, 8, NULL, IEEE_1722_TU_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_stream_id,\r\n{ "Stream ID", "ieee1722.stream_id",\r\nFT_UINT64, BASE_HEX, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722_avbtp_timestamp,\r\n{ "AVBTP Timestamp", "ieee1722.avbtp_timestamp",\r\nFT_UINT32, BASE_HEX, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722_gateway_info,\r\n{ "Gateway Info", "ieee1722.gateway_info",\r\nFT_UINT32, BASE_HEX, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722_packet_data_length,\r\n{ "1394 Packet Data Length", "ieee1722.packet_data_len",\r\nFT_UINT16, BASE_DEC, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722_tag,\r\n{ "1394 Packet Format Tag", "ieee1722.tag",\r\nFT_UINT8, BASE_HEX, NULL, IEEE_1722_TAG_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_channel,\r\n{ "1394 Packet Channel", "ieee1722.channel",\r\nFT_UINT8, BASE_HEX, NULL, IEEE_1722_CHANNEL_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_tcode,\r\n{ "1394 Packet Tcode", "ieee1722.tcode",\r\nFT_UINT8, BASE_HEX, NULL, IEEE_1722_TCODE_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_sy,\r\n{ "1394 App-specific Control", "ieee1722.sy",\r\nFT_UINT8, BASE_HEX, NULL, IEEE_1722_SY_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_sid,\r\n{ "Source ID", "ieee1722.sid",\r\nFT_UINT8, BASE_HEX, NULL, IEEE_1722_SID_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_dbs,\r\n{ "Data Block Size", "ieee1722.dbs",\r\nFT_UINT8, BASE_HEX, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722_fn,\r\n{ "Fraction Number", "ieee1722.fn",\r\nFT_UINT8, BASE_HEX, NULL, IEEE_1722_FN_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_qpc,\r\n{ "Quadlet Padding Count", "ieee1722.qpc",\r\nFT_UINT8, BASE_HEX, NULL, IEEE_1722_QPC_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_sph,\r\n{ "Source Packet Header", "ieee1722.sph",\r\nFT_BOOLEAN, 8, NULL, IEEE_1722_SPH_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_dbc,\r\n{ "Data Block Continuity", "ieee1722.dbc",\r\nFT_UINT8, BASE_HEX, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722_fmt,\r\n{ "Format ID", "ieee1722.fmt",\r\nFT_UINT8, BASE_HEX, NULL, IEEE_1722_FMT_MASK, NULL, HFILL }\r\n},\r\n{ &hf_1722_fdf,\r\n{ "Format Dependent Field", "ieee1722.fdf",\r\nFT_UINT8, BASE_HEX, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722_syt,\r\n{ "SYT", "ieee1722.syt",\r\nFT_UINT16, BASE_HEX, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722_data,\r\n{ "Audio Data", "ieee1722.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722_label,\r\n{ "Label", "ieee1722.data.sample.label",\r\nFT_UINT8, BASE_HEX, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_1722_sample,\r\n{ "Sample", "ieee1722.data.sample.sampledata",\r\nFT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_1722,\r\n&ett_1722_audio,\r\n&ett_1722_sample\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_1722_incorrect_dbs, { "ieee1722.incorrect_dbs", PI_PROTOCOL, PI_WARN, "Incorrect DBS", EXPFILL }},\r\n};\r\nexpert_module_t* expert_1722;\r\nproto_1722 = proto_register_protocol("IEEE 1722 Protocol", "IEEE1722", "ieee1722");\r\nproto_register_field_array(proto_1722, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_1722 = expert_register_protocol(proto_1722);\r\nexpert_register_field_array(expert_1722, ei, array_length(ei));\r\navb_dissector_table = register_dissector_table("ieee1722.subtype",\r\n"IEEE1722 AVBTP Subtype", FT_UINT8, BASE_HEX);\r\n}\r\nvoid proto_reg_handoff_1722(void)\r\n{\r\ndissector_handle_t avbtp_handle;\r\navbtp_handle = create_dissector_handle(dissect_1722, proto_1722);\r\ndissector_add_uint("ethertype", ETHERTYPE_AVBTP, avbtp_handle);\r\n}
