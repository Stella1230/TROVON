static inline unsigned long ROL(unsigned long word, int i)\r\n{\r\n__asm__("roll %%cl,%0"\r\n:"=r" (word)\r\n:"0" (word),"c" (i));\r\nreturn word;\r\n}\r\nstatic inline unsigned long ROR(unsigned long word, int i)\r\n{\r\n__asm__("rorl %%cl,%0"\r\n:"=r" (word)\r\n:"0" (word),"c" (i));\r\nreturn word;\r\n}\r\nstatic ulong32 BYTE2WORD(const unsigned char *b)\r\n{\r\nulong32 t;\r\nLOAD32L(t, b);\r\nreturn t;\r\n}\r\nstatic void XORWORD(ulong32 w, unsigned char *b)\r\n{\r\nulong32 t;\r\nLOAD32L(t, b);\r\nt ^= w;\r\nSTORE32L(t, b);\r\n}\r\nstatic void cycle(ulong32 *R)\r\n{\r\nulong32 t;\r\nint i;\r\nSTEP(R,0);\r\nt = R[0];\r\nfor (i = 1; i < N; ++i) {\r\nR[i-1] = R[i];\r\n}\r\nR[N-1] = t;\r\n}\r\nstatic ulong32 nltap(sober128_prng *c)\r\n{\r\nulong32 t;\r\nNLFUNC(c, 0);\r\nreturn t;\r\n}\r\nint sober128_start(sober128_prng *c)\r\n{\r\nint i;\r\nc->R[0] = 1;\r\nc->R[1] = 1;\r\nfor (i = 2; i < N; ++i) {\r\nc->R[i] = c->R[i-1] + c->R[i-2];\r\n}\r\nc->konst = INITKONST;\r\nc->flag = 1;\r\nc->set = 0;\r\nreturn 0;\r\n}\r\nstatic void s128_savestate(sober128_prng *c)\r\n{\r\nint i;\r\nfor (i = 0; i < N; ++i) {\r\nc->initR[i] = c->R[i];\r\n}\r\n}\r\nstatic void s128_reloadstate(sober128_prng *c)\r\n{\r\nint i;\r\nfor (i = 0; i < N; ++i) {\r\nc->R[i] = c->initR[i];\r\n}\r\n}\r\nstatic void s128_genkonst(sober128_prng *c)\r\n{\r\nulong32 newkonst;\r\ndo {\r\ncycle(c->R);\r\nnewkonst = nltap(c);\r\n} while ((newkonst & 0xFF000000) == 0);\r\nc->konst = newkonst;\r\n}\r\nstatic void s128_diffuse(sober128_prng *c)\r\n{\r\nulong32 t;\r\nDROUND(0);\r\nDROUND(1);\r\nDROUND(2);\r\nDROUND(3);\r\nDROUND(4);\r\nDROUND(5);\r\nDROUND(6);\r\nDROUND(7);\r\nDROUND(8);\r\nDROUND(9);\r\nDROUND(10);\r\nDROUND(11);\r\nDROUND(12);\r\nDROUND(13);\r\nDROUND(14);\r\nDROUND(15);\r\nDROUND(16);\r\n}\r\nint sober128_add_entropy(const unsigned char *buf, unsigned long len, sober128_prng *c)\r\n{\r\nulong32 i, k;\r\nif (c->flag == 1) {\r\nfor (i = 0; i < len; i += 4) {\r\nk = BYTE2WORD(&buf[i]);\r\nADDKEY(k);\r\ncycle(c->R);\r\nXORNL(nltap(c));\r\n}\r\nADDKEY(len);\r\ns128_diffuse(c);\r\ns128_genkonst(c);\r\ns128_savestate(c);\r\nc->nbuf = 0;\r\nc->flag = 0;\r\nc->set = 1;\r\n} else {\r\ns128_reloadstate(c);\r\nfor (i = 0; i < len; i += 4) {\r\nk = BYTE2WORD(&buf[i]);\r\nADDKEY(k);\r\ncycle(c->R);\r\nXORNL(nltap(c));\r\n}\r\nADDKEY(len);\r\ns128_diffuse(c);\r\nc->nbuf = 0;\r\n}\r\nreturn 0;\r\n}\r\nunsigned long sober128_read(unsigned char *buf, unsigned long nbytes, sober128_prng *c)\r\n{\r\nulong32 t, tlen;\r\ntlen = nbytes;\r\nwhile (c->nbuf != 0 && nbytes != 0) {\r\n*buf++ ^= c->sbuf & 0xFF;\r\nc->sbuf >>= 8;\r\nc->nbuf -= 8;\r\n--nbytes;\r\n}\r\n#ifndef SMALL_CODE\r\nwhile (nbytes >= N*4) {\r\nSROUND(0);\r\nSROUND(1);\r\nSROUND(2);\r\nSROUND(3);\r\nSROUND(4);\r\nSROUND(5);\r\nSROUND(6);\r\nSROUND(7);\r\nSROUND(8);\r\nSROUND(9);\r\nSROUND(10);\r\nSROUND(11);\r\nSROUND(12);\r\nSROUND(13);\r\nSROUND(14);\r\nSROUND(15);\r\nSROUND(16);\r\nbuf += 4*N;\r\nnbytes -= 4*N;\r\n}\r\n#endif\r\nwhile (4 <= nbytes) {\r\ncycle(c->R);\r\nt = nltap(c);\r\nXORWORD(t, buf);\r\nbuf += 4;\r\nnbytes -= 4;\r\n}\r\nif (nbytes != 0) {\r\ncycle(c->R);\r\nc->sbuf = nltap(c);\r\nc->nbuf = 32;\r\nwhile (c->nbuf != 0 && nbytes != 0) {\r\n*buf++ ^= c->sbuf & 0xFF;\r\nc->sbuf >>= 8;\r\nc->nbuf -= 8;\r\n--nbytes;\r\n}\r\n}\r\nreturn tlen;\r\n}
