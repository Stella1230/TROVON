void\r\nwmem_init_hashing(void)\r\n{\r\nx = g_random_int();\r\nif G_UNLIKELY(x == 0)\r\nx = 1;\r\npreseed = g_random_int();\r\npostseed = g_random_int();\r\n}\r\nwmem_map_t *\r\nwmem_map_new(wmem_allocator_t *allocator,\r\nGHashFunc hash_func, GEqualFunc eql_func)\r\n{\r\nwmem_map_t *map;\r\nmap = wmem_new(allocator, wmem_map_t);\r\nmap->count = 0;\r\nmap->capacity = WMEM_MAP_DEFAULT_CAPACITY;\r\nmap->table = wmem_alloc0_array(allocator, wmem_map_item_t*, CAPACITY(map));\r\nmap->hash_func = hash_func;\r\nmap->eql_func = eql_func;\r\nmap->allocator = allocator;\r\nreturn map;\r\n}\r\nstatic inline void\r\nwmem_map_grow(wmem_map_t *map)\r\n{\r\nwmem_map_item_t **old_table, *cur, *nxt;\r\nguint old_cap, i, slot;\r\nold_table = map->table;\r\nold_cap = CAPACITY(map);\r\nmap->capacity++;\r\nmap->table = wmem_alloc0_array(map->allocator, wmem_map_item_t*, CAPACITY(map));\r\nfor (i=0; i<old_cap; i++) {\r\ncur = old_table[i];\r\nwhile (cur) {\r\nnxt = cur->next;\r\nslot = HASH(map, cur->key);\r\ncur->next = map->table[slot];\r\nmap->table[slot] = cur;\r\ncur = nxt;\r\n}\r\n}\r\nwmem_free(map->allocator, old_table);\r\n}\r\nvoid *\r\nwmem_map_insert(wmem_map_t *map, const void *key, void *value)\r\n{\r\nwmem_map_item_t **item;\r\nvoid *old_val;\r\nitem = &(map->table[HASH(map, key)]);\r\nwhile (*item) {\r\nif (map->eql_func(key, (*item)->key)) {\r\nold_val = (*item)->value;\r\n(*item)->value = value;\r\nreturn old_val;\r\n}\r\nitem = &((*item)->next);\r\n}\r\n(*item) = wmem_new(map->allocator, wmem_map_item_t);\r\n(*item)->key = key;\r\n(*item)->value = value;\r\n(*item)->next = NULL;\r\nmap->count++;\r\nif (map->count >= CAPACITY(map)) {\r\nwmem_map_grow(map);\r\n}\r\nreturn NULL;\r\n}\r\nvoid *\r\nwmem_map_lookup(wmem_map_t *map, const void *key)\r\n{\r\nwmem_map_item_t *item;\r\nitem = map->table[HASH(map, key)];\r\nwhile (item) {\r\nif (map->eql_func(key, item->key)) {\r\nreturn item->value;\r\n}\r\nitem = item->next;\r\n}\r\nreturn NULL;\r\n}\r\nvoid *\r\nwmem_map_remove(wmem_map_t *map, const void *key)\r\n{\r\nwmem_map_item_t **item, *tmp;\r\nvoid *value;\r\nitem = &(map->table[HASH(map, key)]);\r\nwhile (*item) {\r\nif (map->eql_func(key, (*item)->key)) {\r\ntmp = (*item);\r\nvalue = tmp->value;\r\n(*item) = tmp->next;\r\nwmem_free(map->allocator, tmp);\r\nmap->count--;\r\nreturn value;\r\n}\r\nitem = &((*item)->next);\r\n}\r\nreturn NULL;\r\n}\r\nguint32\r\nwmem_strong_hash(const guint8 *buf, const size_t len)\r\n{\r\nconst guint8 * const end = (const guint8 *)buf + len;\r\nguint32 hash = preseed + (guint32)len;\r\nwhile (buf < end) {\r\nhash += (hash << 10);\r\nhash ^= (hash >> 6);\r\nhash += *buf++;\r\n}\r\nhash += (hash << 10);\r\nhash ^= (hash >> 6);\r\nhash += ((guint8*)&postseed)[0];\r\nhash += (hash << 10);\r\nhash ^= (hash >> 6);\r\nhash += ((guint8*)&postseed)[1];\r\nhash += (hash << 10);\r\nhash ^= (hash >> 6);\r\nhash += ((guint8*)&postseed)[2];\r\nhash += (hash << 10);\r\nhash ^= (hash >> 6);\r\nhash += ((guint8*)&postseed)[3];\r\nhash += (hash << 10);\r\nhash ^= (hash >> 6);\r\nhash += (hash << 3);\r\nhash ^= (hash >> 11);\r\nreturn (hash + (hash << 15));\r\n}\r\nguint\r\nwmem_str_hash(gconstpointer key)\r\n{\r\nreturn wmem_strong_hash((const guint8 *)key, strlen((const char *)key));\r\n}\r\nguint\r\nwmem_int64_hash(gconstpointer key)\r\n{\r\nreturn wmem_strong_hash((const guint8 *)key, sizeof(guint64));\r\n}\r\nguint\r\nwmem_double_hash(gconstpointer key)\r\n{\r\nreturn wmem_strong_hash((const guint8 *)key, sizeof(double));\r\n}
