static void\r\ndissect_ds_event(tvbuff_t * tvb, proto_tree *tree, int start, guint16 len)\r\n{\r\nguint8 type, length;\r\nproto_tree *event_tree;\r\nint pos = start;\r\nevent_tree =\r\nproto_tree_add_subtree_format(tree, tvb, start, len, ett_cmctrl_tlv_ds_event, NULL,\r\n"Override Downstream Status Event Event Mask (Length = %u)", len);\r\nwhile (pos < (start + len))\r\n{\r\ntype = tvb_get_guint8 (tvb, pos++);\r\nlength = tvb_get_guint8 (tvb, pos++);\r\nswitch (type)\r\n{\r\ncase DS_EVENT_CH_ID:\r\nif (length == 1)\r\n{\r\nproto_tree_add_item (event_tree, hf_ds_event_ch_id,\r\ntvb, pos, length, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nTHROW (ReportedBoundsError);\r\n}\r\nbreak;\r\ncase DS_EVENT_MASK:\r\nif (length == 2)\r\n{\r\nproto_tree_add_item (event_tree, hf_ds_event_mask,\r\ntvb, pos, length, ENC_NA);\r\n}\r\nelse\r\n{\r\nTHROW (ReportedBoundsError);\r\n}\r\nbreak;\r\n}\r\npos = pos + length;\r\n}\r\n}\r\nstatic void\r\ndissect_us_event(tvbuff_t * tvb, proto_tree *tree, int start, guint16 len)\r\n{\r\nguint8 type, length;\r\nproto_tree *event_tree;\r\nint pos = start;\r\nevent_tree =\r\nproto_tree_add_subtree_format(tree, tvb, start, len, ett_cmctrl_tlv_us_event, NULL,\r\n"Override Upstream Status Enable Event Mask (Length = %u)", len);\r\nwhile (pos < (start + len))\r\n{\r\ntype = tvb_get_guint8 (tvb, pos++);\r\nlength = tvb_get_guint8 (tvb, pos++);\r\nswitch (type)\r\n{\r\ncase US_EVENT_CH_ID:\r\nif (length == 1)\r\n{\r\nproto_tree_add_item (event_tree, hf_us_event_ch_id,\r\ntvb, pos, length, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nTHROW (ReportedBoundsError);\r\n}\r\nbreak;\r\ncase US_EVENT_MASK:\r\nif (length == 2)\r\n{\r\nproto_tree_add_item (event_tree, hf_us_event_mask,\r\ntvb, pos, length, ENC_NA);\r\n}\r\nelse\r\n{\r\nTHROW (ReportedBoundsError);\r\n}\r\nbreak;\r\n}\r\npos = pos + length;\r\n}\r\n}\r\nstatic void\r\ndissect_cmctrl_tlv (tvbuff_t * tvb, packet_info * pinfo _U_, proto_tree * tree)\r\n{\r\nproto_item *it;\r\nproto_tree *tlv_tree;\r\nint pos = 0;\r\ngint total_len;\r\nguint8 type, length;\r\ntotal_len = tvb_reported_length_remaining (tvb, 0);\r\nit =\r\nproto_tree_add_protocol_format (tree, proto_cmctrl_tlv, tvb, 0,\r\ntotal_len, "TLV Data");\r\ntlv_tree = proto_item_add_subtree (it, ett_cmctrl_tlv);\r\nwhile (pos < total_len)\r\n{\r\ntype = tvb_get_guint8 (tvb, pos++);\r\nlength = tvb_get_guint8 (tvb, pos++);\r\nswitch (type)\r\n{\r\ncase CM_CTRL_MUTE:\r\nif (length == 1)\r\n{\r\nproto_tree_add_item (tlv_tree, hf_cmctrl_tlv_mute,\r\ntvb, pos, length, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nTHROW (ReportedBoundsError);\r\n}\r\nbreak;\r\ncase CM_CTRL_MUTE_TIMEOUT:\r\nif (length == 4 || length == 1)\r\n{\r\nproto_tree_add_item (tlv_tree, hf_cmctrl_tlv_mute_timeout,\r\ntvb, pos, length, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nTHROW (ReportedBoundsError);\r\n}\r\nbreak;\r\ncase CM_CTRL_REINIT:\r\nif (length == 1)\r\n{\r\nproto_tree_add_item (tlv_tree, hf_cmctrl_tlv_reinit,\r\ntvb, pos, length, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nTHROW (ReportedBoundsError);\r\n}\r\nbreak;\r\ncase CM_CTRL_DISABLE_FWD:\r\nif (length == 1)\r\n{\r\nproto_tree_add_item (tlv_tree, hf_cmctrl_tlv_disable_fwd,\r\ntvb, pos, length, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nTHROW (ReportedBoundsError);\r\n}\r\nbreak;\r\ncase CM_CTRL_DS_EVENT:\r\nif (length == 1)\r\nproto_tree_add_item (tlv_tree, hf_cmctrl_tlv_ds_event,\r\ntvb, pos, length, ENC_NA);\r\nelse\r\ndissect_ds_event(tvb, tlv_tree, pos, length);\r\nbreak;\r\ncase CM_CTRL_US_EVENT:\r\nif (length == 1)\r\nproto_tree_add_item (tlv_tree, hf_cmctrl_tlv_ds_event,\r\ntvb, pos, length, ENC_NA);\r\nelse\r\ndissect_us_event(tvb, tlv_tree, pos, length);\r\nbreak;\r\ncase CM_CTRL_EVENT:\r\nif (length == 2 || length == 1)\r\n{\r\nproto_tree_add_item (tlv_tree, hf_cmctrl_tlv_event,\r\ntvb, pos, length, ENC_NA);\r\n}\r\nelse\r\n{\r\nTHROW (ReportedBoundsError);\r\n}\r\nbreak;\r\n}\r\npos = pos + length;\r\n}\r\n}\r\nvoid\r\nproto_register_cmctrl_tlv (void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{&hf_cmctrl_tlv_mute,\r\n{"1 Upstream Channel RF Mute", "cmctrl_tlv.mute",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Upstream Channel RF Mute", HFILL}\r\n},\r\n{&hf_cmctrl_tlv_mute_timeout,\r\n{"2 RF Mute Timeout Interval", "cmctrl_tlv.mute_timeout",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"RF Mute Timeout Interval", HFILL}\r\n},\r\n{&hf_cmctrl_tlv_reinit,\r\n{"3 CM Reinitialize", "cmctrl_tlv.reinit",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"CM Reinitialize", HFILL}\r\n},\r\n{&hf_cmctrl_tlv_disable_fwd,\r\n{"4 Disable Forwarding", "cmctrl_tlv.disable_fwd",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Disable Forwarding", HFILL}\r\n},\r\n{&hf_cmctrl_tlv_ds_event,\r\n{"5 Override Downstream Events", "cmctrl_tlv.ds_event",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Override Downstream Events", HFILL}\r\n},\r\n{&hf_ds_event_ch_id,\r\n{".1 Downstream Channel ID", "cmctrl_tlv.ds_event.chid",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Downstream Channel ID", HFILL}\r\n},\r\n{&hf_ds_event_mask,\r\n{".2 Downstream Status Event Enable Bitmask", "cmctrl_tlv.ds_event.mask",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Downstream Status Event Enable Bitmask", HFILL}\r\n},\r\n#if 0\r\n{&hf_cmctrl_tlv_us_event,\r\n{"6 Override Upstream Events", "cmctrl_tlv.us_event",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Override Downstream Events", HFILL}\r\n},\r\n#endif\r\n{&hf_us_event_ch_id,\r\n{".1 Upstream Channel ID", "cmctrl_tlv.us_event.chid",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Upstream Channel ID", HFILL}\r\n},\r\n{&hf_us_event_mask,\r\n{".2 Upstream Status Event Enable Bitmask", "cmctrl_tlv.us_event.mask",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Upstream Status Event Enable Bitmask", HFILL}\r\n},\r\n{&hf_cmctrl_tlv_event,\r\n{"7 Override Non-Channel-Specific Events", "cmctrl_tlv.event",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Override Non-Channel-Specific Events", HFILL}\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_cmctrl_tlv,\r\n&ett_cmctrl_tlv_ds_event,\r\n&ett_cmctrl_tlv_us_event,\r\n};\r\nproto_cmctrl_tlv = proto_register_protocol ("DOCSIS CM-CTRL TLV's",\r\n"DOCSIS CM-CTRL TLVs", "cmctrl_tlv");\r\nproto_register_field_array (proto_cmctrl_tlv, hf, array_length (hf));\r\nproto_register_subtree_array (ett, array_length (ett));\r\nregister_dissector ("cmctrl_tlv", dissect_cmctrl_tlv, proto_cmctrl_tlv);\r\n}\r\nvoid\r\nproto_reg_handoff_cmctrl_tlv (void)\r\n{\r\n#if 0\r\ndissector_handle_t cmctrl_tlv_handle;\r\ncmctrl_tlv_handle = find_dissector ("cmctrl_tlv");\r\ndissector_add_uint ("docsis", 0xFE, cmctrl_tlv_handle);\r\n#endif\r\n}
