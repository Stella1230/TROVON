static void\r\ndissect_vp8(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nproto_item *item;\r\ngint offset = 0, frametype = 0, partition1_size = -1;\r\nproto_tree *vp8_tree;\r\ngboolean hasHeader = FALSE;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "VP8");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nitem = proto_tree_add_item(tree, proto_vp8, tvb, 0, -1, ENC_NA);\r\nvp8_tree = proto_item_add_subtree(item, ett_vp8);\r\nframetype = 2;\r\ndissect_vp8_payload_descriptor(tvb, pinfo, vp8_tree, &offset, &hasHeader);\r\nif (hasHeader)\r\n{\r\ndissect_vp8_payload_header(tvb, pinfo, vp8_tree, &offset, &frametype, &partition1_size);\r\n}\r\ndissect_vp8_payload(tvb, pinfo, vp8_tree, &offset, &frametype, &partition1_size);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - %s",\r\nval_to_str(frametype, vp8_type_values, "Unknown Type (%u)"));\r\n}\r\nstatic void\r\ndissect_vp8_payload_descriptor(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *vp8_tree, gint *offset, gboolean *hasHeader)\r\n{\r\nproto_item *item_descriptor;\r\nguint8 extended_bit, s_bit, partId;\r\nproto_tree *vp8_payload_descriptor_tree;\r\nvp8_payload_descriptor_tree = proto_tree_add_subtree(vp8_tree, tvb, *offset, -1, ett_vp8_payload_descriptor,\r\n&item_descriptor, "Payload descriptor");\r\nproto_tree_add_item(vp8_payload_descriptor_tree, hf_vp8_pld_x_bit, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vp8_payload_descriptor_tree, hf_vp8_pld_r_bit, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vp8_payload_descriptor_tree, hf_vp8_pld_n_bit, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vp8_payload_descriptor_tree, hf_vp8_pld_s_bit, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vp8_payload_descriptor_tree, hf_vp8_pld_part_id, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nextended_bit = tvb_get_guint8(tvb, *offset) & BIT_1_MASK;\r\ns_bit = tvb_get_guint8(tvb, *offset) & BIT_4_MASK;\r\npartId = tvb_get_guint8(tvb, *offset) & BIT_5678_MASK;\r\nif ((s_bit > 0) && (partId == 0)) {\r\n*hasHeader=TRUE;\r\n}\r\nif (extended_bit)\r\n{\r\nguint8 i_bit, l_bit, t_bit, k_bit;\r\n(*offset)++;\r\nproto_tree_add_item(vp8_payload_descriptor_tree, hf_vp8_pld_i_bit, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vp8_payload_descriptor_tree, hf_vp8_pld_l_bit, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vp8_payload_descriptor_tree, hf_vp8_pld_t_bit, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vp8_payload_descriptor_tree, hf_vp8_pld_k_bit, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vp8_payload_descriptor_tree, hf_vp8_pld_rsv_a, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\ni_bit = tvb_get_guint8(tvb, *offset) & BIT_1_MASK;\r\nl_bit = tvb_get_guint8(tvb, *offset) & BIT_2_MASK;\r\nt_bit = tvb_get_guint8(tvb, *offset) & BIT_3_MASK;\r\nk_bit = tvb_get_guint8(tvb, *offset) & BIT_4_MASK;\r\nif (i_bit)\r\n{\r\n(*offset)++;\r\nif(tvb_get_guint8(tvb, *offset) & BIT_1_MASK)\r\n{\r\nproto_tree_add_item(vp8_payload_descriptor_tree, hf_vp8_pld_extended_picture_id, tvb, *offset, 2, ENC_BIG_ENDIAN);\r\n(*offset)++;\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(vp8_payload_descriptor_tree, hf_vp8_pld_picture_id, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nif (l_bit)\r\n{\r\n(*offset)++;\r\nproto_tree_add_item(vp8_payload_descriptor_tree, hf_vp8_pld_tl0picidx, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nif (t_bit || k_bit)\r\n{\r\n(*offset)++;\r\nproto_tree_add_item(vp8_payload_descriptor_tree, hf_vp8_pld_tid, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vp8_payload_descriptor_tree, hf_vp8_pld_y_bit, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vp8_payload_descriptor_tree, hf_vp8_pld_keyidx, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n}\r\n}\r\n(*offset)++;\r\nproto_item_set_len(item_descriptor, *offset);\r\n}\r\nstatic void\r\ndissect_vp8_payload_header(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *vp8_tree, gint *offset, gint *frametype, gint *partition1_size)\r\n{\r\nproto_item *item_header;\r\nproto_tree *vp8_payload_header_tree;\r\ngint size0, size1, size2;\r\nvp8_payload_header_tree = proto_tree_add_subtree(vp8_tree, tvb, *offset, 3, ett_vp8_payload_header, &item_header, "Payload header");\r\nproto_tree_add_item(vp8_payload_header_tree, hf_vp8_hdr_frametype, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vp8_payload_header_tree, hf_vp8_hdr_version, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vp8_payload_header_tree, hf_vp8_hdr_show_bit, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*frametype = tvb_get_guint8(tvb, *offset) & BIT_8_MASK;\r\nsize0 = (tvb_get_guint8(tvb, *offset) & BIT_123_MASK) >> 5;\r\nsize1 = tvb_get_guint8(tvb, *offset + 1);\r\nsize2 = tvb_get_guint8(tvb, *offset + 2);\r\n(*partition1_size) = size0 + (size1*8) + (size2*2048);\r\nproto_tree_add_uint(vp8_payload_header_tree, hf_vp8_hdr_first_partition_size, tvb, *offset, 3, *partition1_size);\r\n(*offset)++;\r\n(*offset)++;\r\n(*offset)++;\r\n}\r\nstatic void\r\ndissect_vp8_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *vp8_tree, gint *offset, gint *frametype, gint *partition1_size)\r\n{\r\nproto_tree *vp8_payload_tree;\r\nproto_item *payload_item;\r\ngint remainder;\r\nvp8_payload_tree = proto_tree_add_subtree(vp8_tree, tvb, *offset, -1, ett_vp8_payload, &payload_item, "Payload");\r\nif (*frametype == 0)\r\n{\r\nguint16 width, height;\r\ngint start1, start2, start3, horizontal_scale, vertical_scale;\r\nproto_tree *vp8_keyframe_tree;\r\nvp8_keyframe_tree = proto_tree_add_subtree(vp8_payload_tree, tvb, *offset, -1, ett_vp8_keyframe, NULL, "Keyframe header");\r\nproto_tree_add_item(vp8_keyframe_tree, hf_vp8_keyframe_start_code, tvb, *offset, 3, ENC_BIG_ENDIAN);\r\nstart1 = tvb_get_guint8(tvb, *offset);\r\nstart2 = tvb_get_guint8(tvb, *offset + 1);\r\nstart3 = tvb_get_guint8(tvb, *offset + 2);\r\nif ((start1 != 0x9d) || (start2 != 0x01) || (start3 != 0x2a))\r\n{\r\nexpert_add_info(pinfo, vp8_keyframe_tree, &ei_vp8_startcode);\r\n}\r\n(*offset)++;\r\n(*offset)++;\r\n(*offset)++;\r\nwidth = tvb_get_letohs(tvb, *offset) & 0x3FFF;\r\nhorizontal_scale = tvb_get_letohs(tvb, *offset)>>14;\r\nproto_tree_add_uint(vp8_keyframe_tree, hf_vp8_keyframe_horizontal_scale, tvb, *offset, 2, horizontal_scale);\r\nproto_tree_add_uint(vp8_keyframe_tree, hf_vp8_keyframe_width, tvb, *offset, 2, width);\r\n(*offset)++;\r\n(*offset)++;\r\nheight = tvb_get_letohs(tvb, *offset) & 0x3FFF;\r\nvertical_scale = tvb_get_letohs(tvb, *offset)>>14;\r\nproto_tree_add_uint(vp8_keyframe_tree, hf_vp8_keyframe_vertical_scale, tvb, *offset, 2, vertical_scale);\r\nproto_tree_add_uint(vp8_keyframe_tree, hf_vp8_keyframe_height, tvb, *offset, 2, height);\r\n(*offset)++;\r\n(*offset)++;\r\n}\r\nremainder = tvb_reported_length_remaining(tvb, (*offset));\r\nif ((*partition1_size) == -1)\r\n{\r\nproto_tree_add_expert_format(vp8_payload_tree, pinfo, &ei_vp8_continuation, tvb, *offset, -1, "Continuation of partition fragment (%d bytes)", remainder);\r\n}\r\nelse\r\n{\r\nif (remainder < *partition1_size)\r\n{\r\nproto_tree_add_expert_format(vp8_payload_tree, pinfo, &ei_vp8_first_partition_split, tvb, *offset, -1,\r\n"First partition is split with %d bytes in this packet and %d bytes in subsequent frames", remainder, ((*partition1_size)-remainder));\r\n}\r\nelse\r\n{\r\n(*offset)= (*offset) + (*partition1_size);\r\nproto_tree_add_expert_format(vp8_payload_tree, pinfo, &ei_vp8_first_partition_plus, tvb, *offset, -1,\r\n"This frame contains all of first partition (%d bytes) and also %d bytes from other partitions",\r\n*partition1_size, remainder);\r\n}\r\n}\r\nexpert_add_info(pinfo, payload_item, &ei_vp8_undecoded);\r\n}\r\nvoid\r\nproto_register_vp8(void)\r\n{\r\nmodule_t *vp8_module;\r\nexpert_module_t* expert_vp8;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_vp8_pld_x_bit,\r\n{ "X bit", "vp8.pld.x",\r\nFT_BOOLEAN, 8, TFS(&vp8_x_bit_vals), BIT_1_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_pld_r_bit,\r\n{ "R bit", "vp8.pld.r",\r\nFT_BOOLEAN, 8, TFS(&vp8_r_bit_vals), BIT_2_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_pld_n_bit,\r\n{ "N bit", "vp8.pld.n",\r\nFT_BOOLEAN, 8, TFS(&vp8_n_bit_vals), BIT_3_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_pld_s_bit,\r\n{ "S bit", "vp8.pld.s",\r\nFT_BOOLEAN, 8, TFS(&vp8_s_bit_vals), BIT_4_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_pld_part_id,\r\n{ "Part Id", "vp8.pld.partid",\r\nFT_UINT8, BASE_DEC, NULL, BIT_5678_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_pld_i_bit,\r\n{ "I bit", "vp8.pld.i",\r\nFT_BOOLEAN, 8, TFS(&vp8_i_bit_vals), BIT_1_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_pld_l_bit,\r\n{ "L bit", "vp8.pld.l",\r\nFT_BOOLEAN, 8, TFS(&vp8_l_bit_vals), BIT_2_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_pld_t_bit,\r\n{ "T bit", "vp8.pld.t",\r\nFT_BOOLEAN, 8, TFS(&vp8_t_bit_vals), BIT_3_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_pld_k_bit,\r\n{ "K bit", "vp8.pld.k",\r\nFT_BOOLEAN, 8, TFS(&vp8_k_bit_vals), BIT_4_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_pld_rsv_a,\r\n{ "Reserved A", "vp8.pld.rsva",\r\nFT_UINT8, BASE_DEC, NULL, BIT_5678_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_pld_picture_id,\r\n{ "Picture Id", "vp8.pld.pictureid",\r\nFT_UINT8, BASE_DEC, NULL, BIT_NO_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_pld_extended_picture_id,\r\n{ "Extended Picture Id", "vp8.pld.pictureid",\r\nFT_UINT8, BASE_DEC, NULL, BIT_EXT_PICTURE_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_pld_tl0picidx,\r\n{ "Temporal layer zero Picture Index (TL0PICIDX)", "vp8.pld.tl0picidx",\r\nFT_UINT8, BASE_DEC, NULL, BIT_NO_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_pld_tid,\r\n{ "Temporal layer Index (TID)", "vp8.pld.tid",\r\nFT_UINT8, BASE_DEC, NULL, BIT_12_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_pld_y_bit,\r\n{ "1 Lay Sync Bit (Y)", "vp8.pld.y",\r\nFT_BOOLEAN, 8, NULL, BIT_3_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_pld_keyidx,\r\n{ "Temporal Key Frame Index (KEYIDX)", "vp8.pld.keyidx",\r\nFT_UINT8, BASE_DEC, NULL, BIT_45678_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_hdr_frametype,\r\n{ "frametype", "vp8.hdr.frametype",\r\nFT_BOOLEAN, 8, TFS(&vp8_hdr_frametype_vals), BIT_8_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_hdr_version,\r\n{ "version", "vp8.hdr.version",\r\nFT_UINT8, BASE_DEC, NULL, BIT_567_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_hdr_show_bit,\r\n{ "Show bit", "vp8.hdr.show",\r\nFT_BOOLEAN, 8, NULL, BIT_5_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_hdr_first_partition_size,\r\n{ "First partition size", "vp8.hdr.partition_size",\r\nFT_UINT8, BASE_DEC, NULL, BIT_PARTITION_SIZE_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_keyframe_start_code,\r\n{ "VP8 Start code", "vp8.keyframe.start_code",\r\nFT_UINT24, BASE_HEX, NULL, BIT_3BYTE_NO_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_keyframe_width,\r\n{ "Width", "vp8.keyframe.width",\r\nFT_UINT16, BASE_DEC, NULL, BIT_2BYTE_NO_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_keyframe_height,\r\n{ "Height", "vp8.keyframe.height",\r\nFT_UINT16, BASE_DEC, NULL, BIT_2BYTE_NO_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_keyframe_horizontal_scale,\r\n{ "Horizontal Scale", "vp8.keyframe.horizontal_scale",\r\nFT_UINT8, BASE_DEC, NULL, BIT_12_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vp8_keyframe_vertical_scale,\r\n{ "Vertical Scale", "vp8.keyframe.vertical_scale",\r\nFT_UINT8, BASE_DEC, NULL, BIT_12_MASK,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_vp8_startcode, { "vp8.keyframe.startcode", PI_PROTOCOL, PI_ERROR, "Startcode is incorrect", EXPFILL }},\r\n{ &ei_vp8_undecoded, { "vp8.undecoded", PI_UNDECODED, PI_NOTE, "Payload not fully decoded", EXPFILL }},\r\n{ &ei_vp8_continuation, { "vp8.continuation", PI_REASSEMBLE, PI_CHAT, "Continuation of partition fragment", EXPFILL }},\r\n{ &ei_vp8_first_partition_split, { "vp8.first_partition_split", PI_REASSEMBLE, PI_CHAT, "First partition is split", EXPFILL }},\r\n{ &ei_vp8_first_partition_plus, { "vp8.first_partition_plus", PI_REASSEMBLE, PI_CHAT, "This frame contains all of first partition and also bytes from other partitions", EXPFILL }},\r\n};\r\nproto_vp8 = proto_register_protocol (\r\n"VP8",\r\n"VP8",\r\n"vp8"\r\n);\r\nproto_register_field_array(proto_vp8, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nvp8_module = prefs_register_protocol(proto_vp8, proto_reg_handoff_vp8);\r\nexpert_vp8 = expert_register_protocol(proto_vp8);\r\nexpert_register_field_array(expert_vp8, ei, array_length(ei));\r\nprefs_register_range_preference(vp8_module, "dynamic.payload.type",\r\n"vp8 dynamic payload types",\r\n"Dynamic payload types which will be interpreted as vp8"\r\n"; Values must be in the range 96 - 127",\r\n&temp_dynamic_payload_type_range, 127);\r\nregister_dissector("vp8", dissect_vp8, proto_vp8);\r\n}\r\nstatic void\r\nrange_delete_vp8_rtp_pt_callback(guint32 rtp_pt) {\r\nif ((rtp_pt >= 96) && (rtp_pt <= 127))\r\ndissector_delete_uint("rtp.pt", rtp_pt, vp8_handle);\r\n}\r\nstatic void\r\nrange_add_vp8_rtp_pt_callback(guint32 rtp_pt) {\r\nif ((rtp_pt >= 96) && (rtp_pt <= 127))\r\ndissector_add_uint("rtp.pt", rtp_pt, vp8_handle);\r\n}\r\nvoid\r\nproto_reg_handoff_vp8(void)\r\n{\r\nstatic range_t *dynamic_payload_type_range = NULL;\r\nstatic gboolean vp8_prefs_initialized = FALSE;\r\nif (!vp8_prefs_initialized) {\r\nvp8_handle = find_dissector("vp8");\r\ndissector_add_string("rtp_dyn_payload_type" , "VP8", vp8_handle);\r\nvp8_prefs_initialized = TRUE;\r\n} else {\r\nrange_foreach(dynamic_payload_type_range, range_delete_vp8_rtp_pt_callback);\r\ng_free(dynamic_payload_type_range);\r\n}\r\ndynamic_payload_type_range = range_copy(temp_dynamic_payload_type_range);\r\nrange_foreach(dynamic_payload_type_range, range_add_vp8_rtp_pt_callback);\r\n}
