static int dissect_vrt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\nguint8 type;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "VITA 49");\r\ncol_clear(pinfo->cinfo,COL_INFO);\r\nif (tvb_get_guint8(tvb, 0) == 0)\r\noffset += 4;\r\ntype = tvb_get_guint8(tvb, offset) >> 4;\r\ncol_add_str(pinfo->cinfo, COL_INFO, val_to_str(type, packet_types, "Reserved packet type (0x%02x)"));\r\nif (tree) {\r\nguint8 sidflag;\r\nguint8 cidflag;\r\nguint8 tflag;\r\nguint8 tsitype;\r\nguint8 tsftype;\r\nguint16 len;\r\nguint16 nsamps;\r\nproto_tree *vrt_tree;\r\nproto_item *ti;\r\nsidflag = (((type & 0x01) != 0) || (type == 4)) ? 1 : 0;\r\ncidflag = (tvb_get_guint8(tvb, offset) >> 3) & 0x01;\r\ntflag = (tvb_get_guint8(tvb, offset) >> 2) & 0x01;\r\nif (type == 4)\r\ntflag = 0;\r\ntsitype = (tvb_get_guint8(tvb, offset+1) >> 6) & 0x03;\r\ntsftype = (tvb_get_guint8(tvb, offset+1) >> 4) & 0x03;\r\nlen = tvb_get_ntohs(tvb, offset+2);\r\nnsamps = len - 1;\r\nti = proto_tree_add_item(tree, proto_vrt, tvb, offset, -1, ENC_NA);\r\nvrt_tree = proto_item_add_subtree(ti, ett_vrt);\r\ndissect_header(tvb, vrt_tree, type, offset);\r\noffset += 4;\r\nif (sidflag) {\r\nproto_tree_add_item(vrt_tree, hf_vrt_sid, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nnsamps -= 1;\r\noffset += 4;\r\n}\r\nif (cidflag) {\r\ndissect_cid(tvb, vrt_tree, offset);\r\nnsamps -= 2;\r\noffset += 8;\r\n}\r\nif (tsitype != 0) {\r\nproto_tree_add_item(vrt_tree, hf_vrt_ts_int, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nnsamps -= 1;\r\noffset += 4;\r\n}\r\nif (tsftype != 0) {\r\nif (tsftype == 1 || tsftype == 3) {\r\nproto_tree_add_item(vrt_tree, hf_vrt_ts_frac_sample, tvb, offset, 8, ENC_BIG_ENDIAN);\r\n} else if (tsftype == 2) {\r\nproto_tree_add_item(vrt_tree, hf_vrt_ts_frac_picosecond, tvb, offset, 8, ENC_BIG_ENDIAN);\r\n}\r\nnsamps -= 2;\r\noffset += 8;\r\n}\r\nif (tflag) {\r\nnsamps -= 1;\r\n}\r\nif (nsamps != 0) {\r\nproto_tree_add_item(vrt_tree, hf_vrt_data, tvb, offset, nsamps*4, ENC_NA);\r\n}\r\noffset += nsamps*4;\r\nif (tflag) {\r\ndissect_trailer(tvb, vrt_tree, offset);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid dissect_header(tvbuff_t *tvb, proto_tree *tree, int type, int offset)\r\n{\r\nproto_item *hdr_item;\r\nproto_tree *hdr_tree;\r\nhdr_item = proto_tree_add_item(tree, hf_vrt_header, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nhdr_tree = proto_item_add_subtree(hdr_item, ett_header);\r\nproto_tree_add_item(hdr_tree, hf_vrt_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(hdr_tree, hf_vrt_cidflag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif (type == 4) {\r\nproto_tree_add_item(hdr_tree, hf_vrt_tsmflag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n} else {\r\nproto_tree_add_item(hdr_tree, hf_vrt_tflag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\noffset += 1;\r\nproto_tree_add_item(hdr_tree, hf_vrt_tsi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(hdr_tree, hf_vrt_tsf, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(hdr_tree, hf_vrt_seq, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(hdr_tree, hf_vrt_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n}\r\nvoid dissect_trailer(tvbuff_t *tvb, proto_tree *tree, int offset)\r\n{\r\nproto_item *enable_item, *ind_item, *trailer_item;\r\nproto_tree *enable_tree;\r\nproto_tree *ind_tree;\r\nproto_tree *trailer_tree;\r\nguint16 en_bits;\r\ngint16 i;\r\ntrailer_item = proto_tree_add_item(tree, hf_vrt_trailer, tvb, offset, 4, ENC_BIG_ENDIAN);\r\ntrailer_tree = proto_item_add_subtree(trailer_item, ett_trailer);\r\nenable_item = proto_tree_add_item(trailer_tree, hf_vrt_trailer_enables, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nind_item = proto_tree_add_item(trailer_tree, hf_vrt_trailer_ind, tvb, offset + 1, 2, ENC_BIG_ENDIAN);\r\nen_bits = (tvb_get_ntohs(tvb, offset) & 0xFFF0) >> 4;\r\nif (en_bits) {\r\nenable_tree = proto_item_add_subtree(enable_item, ett_ind_enables);\r\nind_tree = proto_item_add_subtree(ind_item, ett_indicators);\r\nfor (i = 11; i >= 0; i--) {\r\nif (en_bits & (1<<i)) {\r\nproto_tree_add_item(enable_tree, *enable_hfs[i], tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ind_tree, *ind_hfs[i], tvb, offset+1, 2, ENC_BIG_ENDIAN);\r\n}\r\n}\r\n}\r\noffset += 3;\r\nproto_tree_add_item(trailer_tree, hf_vrt_trailer_e, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(trailer_tree, hf_vrt_trailer_acpc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nvoid dissect_cid(tvbuff_t *tvb, proto_tree *tree, int offset)\r\n{\r\nproto_item *cid_item;\r\nproto_tree *cid_tree;\r\ncid_item = proto_tree_add_item(tree, hf_vrt_cid, tvb, offset, 8, ENC_BIG_ENDIAN);\r\ncid_tree = proto_item_add_subtree(cid_item, ett_cid);\r\noffset += 1;\r\nproto_tree_add_item(cid_tree, hf_vrt_cid_oui, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\nproto_tree_add_item(cid_tree, hf_vrt_cid_icc, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(cid_tree, hf_vrt_cid_pcc, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n}\r\nvoid\r\nproto_register_vrt(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_vrt_header,\r\n{ "VRT header", "vrt.hdr",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_type,\r\n{ "Packet type", "vrt.type",\r\nFT_UINT8, BASE_DEC,\r\nVALS(packet_types), 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_cidflag,\r\n{ "Class ID included", "vrt.cidflag",\r\nFT_BOOLEAN, 8,\r\nNULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_tflag,\r\n{ "Trailer included", "vrt.tflag",\r\nFT_BOOLEAN, 8,\r\nNULL, 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_tsmflag,\r\n{ "Timestamp mode", "vrt.tsmflag",\r\nFT_UINT8, BASE_DEC,\r\nVALS(tsm_types), 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_tsi,\r\n{ "Integer timestamp type", "vrt.tsi",\r\nFT_UINT8, BASE_DEC,\r\nVALS(tsi_types), 0xC0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_tsf,\r\n{ "Fractional timestamp type", "vrt.tsf",\r\nFT_UINT8, BASE_DEC,\r\nVALS(tsf_types), 0x30,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_seq,\r\n{ "Sequence number", "vrt.seq",\r\nFT_UINT8, BASE_DEC,\r\nNULL, 0x0F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_len,\r\n{ "Length", "vrt.len",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_ts_int,\r\n{ "Integer timestamp", "vrt.ts_int",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_ts_frac_sample,\r\n{ "Fractional timestamp (samples)", "vrt.ts_frac_sample",\r\nFT_UINT64, BASE_DEC,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_ts_frac_picosecond,\r\n{ "Fractional timestamp (picoseconds)", "vrt.ts_frac_picosecond",\r\nFT_UINT64, BASE_DEC,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_sid,\r\n{ "Stream ID", "vrt.sid",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_cid,\r\n{ "Class ID", "vrt.cid",\r\nFT_UINT64, BASE_HEX,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_data,\r\n{ "Data", "vrt.data",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer,\r\n{ "Trailer", "vrt.trailer",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_enables,\r\n{ "Indicator enable bits", "vrt.enables",\r\nFT_UINT16, BASE_HEX,\r\nNULL, 0xFFF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_ind,\r\n{ "Indicator bits", "vrt.indicators",\r\nFT_UINT16, BASE_HEX,\r\nNULL, 0x0FFF,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_e,\r\n{ "Associated context packet count enabled", "vrt.e",\r\nFT_BOOLEAN, 8,\r\nNULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_acpc,\r\n{ "Associated context packet count", "vrt.acpc",\r\nFT_UINT8, BASE_DEC,\r\nNULL, 0x7F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_ind_caltime,\r\n{ "Calibrated time indicator", "vrt.caltime",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0800,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_ind_valid,\r\n{ "Valid signal indicator", "vrt.valid",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0400,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_ind_reflock,\r\n{ "Reference lock indicator", "vrt.reflock",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0200,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_ind_agc,\r\n{ "AGC/MGC indicator", "vrt.agc",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0100,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_ind_sig,\r\n{ "Signal detected indicator", "vrt.sig",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0080,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_ind_inv,\r\n{ "Spectral inversion indicator", "vrt.inv",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0040,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_ind_overrng,\r\n{ "Overrange indicator", "vrt.overrng",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0020,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_ind_sampleloss,\r\n{ "Lost sample indicator", "vrt.sampleloss",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0010,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_ind_user0,\r\n{ "User indicator 0", "vrt.user0",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x00008,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_ind_user1,\r\n{ "User indicator 1", "vrt.user1",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0004,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_ind_user2,\r\n{ "User indicator 2", "vrt.user2",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x00002,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_ind_user3,\r\n{ "User indicator 3", "vrt.user3",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0001,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_en_caltime,\r\n{ "Calibrated time indicator enable", "vrt.caltime_en",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x8000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_en_valid,\r\n{ "Valid signal indicator enable", "vrt.valid_en",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x4000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_en_reflock,\r\n{ "Reference lock indicator enable", "vrt.reflock_en",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x2000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_en_agc,\r\n{ "AGC/MGC indicator enable", "vrt.agc_en",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x1000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_en_sig,\r\n{ "Signal detected indicator enable", "vrt.sig_en",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0800,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_en_inv,\r\n{ "Spectral inversion indicator enable", "vrt.inv_en",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0400,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_en_overrng,\r\n{ "Overrange indicator enable", "vrt.overrng_en",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0200,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_en_sampleloss,\r\n{ "Lost sample indicator enable", "vrt.sampleloss_en",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0100,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_en_user0,\r\n{ "User indicator 0 enable", "vrt.user0_en",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0080,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_en_user1,\r\n{ "User indicator 1 enable", "vrt.user1_en",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0040,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_en_user2,\r\n{ "User indicator 2 enable", "vrt.user2_en",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0020,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_trailer_en_user3,\r\n{ "User indicator 3 enable", "vrt.user3_en",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x0010,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_cid_oui,\r\n{ "Class ID Organizationally Unique ID", "vrt.oui",\r\nFT_UINT24, BASE_HEX,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_cid_icc,\r\n{ "Class ID Information Class Code", "vrt.icc",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vrt_cid_pcc,\r\n{ "Class ID Packet Class Code", "vrt.pcc",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_vrt,\r\n&ett_header,\r\n&ett_trailer,\r\n&ett_indicators,\r\n&ett_ind_enables,\r\n&ett_cid\r\n};\r\nmodule_t *vrt_module;\r\nproto_vrt = proto_register_protocol (\r\n"VITA 49 radio transport protocol",\r\n"VITA 49",\r\n"vrt"\r\n);\r\nproto_register_field_array(proto_vrt, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nvrt_module = prefs_register_protocol(proto_vrt, proto_reg_handoff_vrt);\r\nprefs_register_uint_preference(vrt_module,\r\n"dissector_port",\r\n"Dissector UDP port",\r\n"The UDP port used by this dissector",\r\n10, &dissector_port_pref);\r\n}\r\nvoid\r\nproto_reg_handoff_vrt(void)\r\n{\r\nstatic gboolean vrt_prefs_initialized = FALSE;\r\nstatic dissector_handle_t vrt_handle;\r\nstatic gint dissector_port;\r\nif (!vrt_prefs_initialized) {\r\nvrt_handle = create_dissector_handle(dissect_vrt, proto_vrt);\r\nvrt_prefs_initialized = TRUE;\r\n} else {\r\ndissector_delete_uint("udp.port", dissector_port, vrt_handle);\r\n}\r\ndissector_port = dissector_port_pref;\r\ndissector_add_uint("udp.port", dissector_port, vrt_handle);\r\n}
