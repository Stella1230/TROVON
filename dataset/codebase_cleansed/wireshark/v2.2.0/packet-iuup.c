static proto_item*\r\niuup_proto_tree_add_bits(proto_tree* tree, int hf, tvbuff_t* tvb, int offset, int bit_offset, guint bits, guint8** buf) {\r\nstatic const guint8 masks[] = {0x00,0x80,0xc0,0xe0,0xf0,0xf8,0xfc,0xfe};\r\nint len = (bits + bit_offset)/8 + (((bits + bit_offset)%8) ? 0 : 1);\r\nguint8* shifted_buffer;\r\nproto_item* pi;\r\nint i;\r\nDISSECTOR_ASSERT(bit_offset < 8);\r\nshifted_buffer = (guint8 *)tvb_memdup(wmem_packet_scope(),tvb,offset,len+1);\r\nfor(i = 0; i < len; i++) {\r\nshifted_buffer[i] <<= bit_offset;\r\nshifted_buffer[i] |= (shifted_buffer[i+1] & masks[bit_offset]) >> (8 - bit_offset);\r\n}\r\nshifted_buffer[len] <<= bit_offset;\r\nshifted_buffer[len] &= masks[(bits + bit_offset)%8];\r\nif (buf)\r\n*buf = shifted_buffer;\r\npi = proto_tree_add_bytes(tree, hf, tvb, offset, len + (((bits + bit_offset)%8) ? 1 : 0) , shifted_buffer);\r\nproto_item_append_text(pi, " (%i Bits)", bits);\r\nreturn pi;\r\n}\r\nstatic void dissect_iuup_payload(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree, guint rfci_id _U_, int offset, guint32 circuit_id) {\r\niuup_circuit_t* iuup_circuit;\r\niuup_rfci_t *rfci;\r\nint last_offset = tvb_reported_length(tvb) - 1;\r\nguint bit_offset = 0;\r\nproto_item* pi;\r\npi = proto_tree_add_item(tree,hf_iuup_payload,tvb,offset,-1,ENC_NA);\r\nif ( ! dissect_fields ) {\r\nreturn;\r\n} else if ( ! circuit_id\r\n|| ! ( iuup_circuit = (iuup_circuit_t *)g_hash_table_lookup(circuits,GUINT_TO_POINTER(circuit_id)) ) ) {\r\nexpert_add_info(pinfo, pi, &ei_iuup_payload_undecoded);\r\nreturn;\r\n}\r\nfor(rfci = iuup_circuit->rfcis; rfci; rfci = rfci->next)\r\nif ( rfci->id == rfci_id )\r\nbreak;\r\nif (!rfci) {\r\nexpert_add_info(pinfo, pi, &ei_iuup_payload_undecoded);\r\nreturn;\r\n}\r\ntree = proto_item_add_subtree(pi,ett_payload);\r\ndo {\r\nguint i;\r\nguint subflows = rfci->num_of_subflows;\r\nproto_tree* flow_tree;\r\nflow_tree = proto_tree_add_subtree(tree,tvb,offset,-1,ett_payload_subflows,NULL,"Payload Frame");\r\nbit_offset = 0;\r\nfor(i = 0; i < subflows; i++) {\r\nif (! rfci->subflow[i].len)\r\ncontinue;\r\niuup_proto_tree_add_bits(flow_tree, hf_iuup_rfci_subflow[rfci->id][i], tvb,\r\noffset + (bit_offset/8),\r\nbit_offset % 8,\r\nrfci->subflow[i].len,\r\nNULL);\r\nbit_offset += rfci->subflow[i].len;\r\n}\r\noffset += (bit_offset / 8) + ((bit_offset % 8) ? 1 : 0);\r\n} while (offset <= last_offset);\r\n}\r\nstatic guint dissect_rfcis(tvbuff_t* tvb, packet_info* pinfo _U_, proto_tree* tree, int* offset, iuup_circuit_t* iuup_circuit) {\r\nproto_item* pi;\r\nproto_tree* pt;\r\nguint8 oct;\r\nguint c = 0;\r\nguint i;\r\ndo {\r\niuup_rfci_t *rfci = wmem_new0(wmem_file_scope(), iuup_rfci_t);\r\nguint len = 0;\r\nDISSECTOR_ASSERT(c < 64);\r\npi = proto_tree_add_item(tree,hf_iuup_init_rfci_ind,tvb,*offset,-1,ENC_NA);\r\npt = proto_item_add_subtree(pi,ett_rfci);\r\nproto_tree_add_item(pt,hf_iuup_init_rfci_lri[c],tvb,*offset,1,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pt,hf_iuup_init_rfci_li[c],tvb,*offset,1,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pt,hf_iuup_init_rfci[c],tvb,*offset,1,ENC_BIG_ENDIAN);\r\noct = tvb_get_guint8(tvb,*offset);\r\nrfci->id = oct & 0x3f;\r\nrfci->num_of_subflows = iuup_circuit->num_of_subflows;\r\nlen = (oct & 0x40) ? 2 : 1;\r\nproto_item_set_text(pi,"RFCI %i Initialization",rfci->id);\r\nproto_item_set_len(pi,(len*iuup_circuit->num_of_subflows)+1);\r\n(*offset)++;\r\nfor(i = 0; i < iuup_circuit->num_of_subflows; i++) {\r\nguint subflow_len;\r\nif (len == 2) {\r\nsubflow_len = tvb_get_ntohs(tvb,*offset);\r\n} else {\r\nsubflow_len = tvb_get_guint8(tvb,*offset);\r\n}\r\nrfci->subflow[i].len = subflow_len;\r\nrfci->sum_len += subflow_len;\r\nproto_tree_add_uint(pt,hf_iuup_init_rfci_flow_len[c][i],tvb,*offset,len,subflow_len);\r\n(*offset) += len;\r\n}\r\nif (iuup_circuit->last_rfci) {\r\niuup_circuit->last_rfci = iuup_circuit->last_rfci->next = rfci;\r\n} else {\r\niuup_circuit->last_rfci = iuup_circuit->rfcis = rfci;\r\n}\r\nc++;\r\n} while ( ! (oct & 0x80) );\r\nreturn c - 1;\r\n}\r\nstatic void dissect_iuup_init(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree, guint32 circuit_id) {\r\nint offset = 4;\r\nguint8 oct = tvb_get_guint8(tvb,offset);\r\nguint n = (oct & 0x0e) >> 1;\r\ngboolean ti = oct & 0x10;\r\nguint i;\r\nguint rfcis;\r\nproto_item* pi;\r\nproto_tree* support_tree = NULL;\r\nproto_tree* iptis_tree;\r\niuup_circuit_t* iuup_circuit = NULL;\r\nif (circuit_id) {\r\niuup_circuit = (iuup_circuit_t *)g_hash_table_lookup(circuits,GUINT_TO_POINTER(circuit_id));\r\nif (iuup_circuit) {\r\ng_hash_table_remove(circuits,GUINT_TO_POINTER(circuit_id));\r\n}\r\niuup_circuit = wmem_new0(wmem_file_scope(), iuup_circuit_t);\r\n} else {\r\niuup_circuit = wmem_new0(wmem_packet_scope(), iuup_circuit_t);\r\n}\r\niuup_circuit->id = circuit_id;\r\niuup_circuit->num_of_subflows = n;\r\niuup_circuit->rfcis = NULL;\r\niuup_circuit->last_rfci = NULL;\r\nif (circuit_id) {\r\ng_hash_table_insert(circuits,GUINT_TO_POINTER(iuup_circuit->id),iuup_circuit);\r\n}\r\nif (tree) {\r\nproto_tree_add_item(tree,hf_iuup_spare_e0,tvb,offset,1,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree,hf_iuup_init_ti,tvb,offset,1,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree,hf_iuup_init_subflows_per_rfci,tvb,offset,1,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree,hf_iuup_init_chain_ind,tvb,offset,1,ENC_BIG_ENDIAN);\r\n}\r\noffset++;\r\nrfcis = dissect_rfcis(tvb, pinfo, tree, &offset, iuup_circuit);\r\nif (!tree) return;\r\nif (ti) {\r\niptis_tree = proto_tree_add_subtree(tree,tvb,offset,(rfcis/2)+(rfcis%2),ett_ipti,NULL,"IPTIs");\r\nfor (i = 0; i <= rfcis; i++) {\r\nproto_tree_add_item(iptis_tree,hf_iuup_init_ipti[i],tvb,offset,1,ENC_BIG_ENDIAN);\r\nif ((i%2)) {\r\noffset++;\r\n}\r\n}\r\nif ((i%2)) {\r\noffset++;\r\n}\r\n}\r\nif (tree) {\r\npi = proto_tree_add_item(tree,hf_iuup_mode_versions,tvb,offset,2,ENC_BIG_ENDIAN);\r\nsupport_tree = proto_item_add_subtree(pi,ett_support);\r\nfor (i = 0; i < 16; i++) {\r\nproto_tree_add_item(support_tree,hf_iuup_mode_versions_a[i],tvb,offset,2,ENC_BIG_ENDIAN);\r\n}\r\n}\r\noffset += 2;\r\nproto_tree_add_item(tree,hf_iuup_data_pdu_type,tvb,offset,1,ENC_BIG_ENDIAN);\r\n}\r\nstatic void dissect_iuup_ratectl(tvbuff_t* tvb, packet_info* pinfo _U_, proto_tree* tree) {\r\nguint num = tvb_get_guint8(tvb,4) & 0x3f;\r\nguint i;\r\nproto_item* pi;\r\nproto_tree* inds_tree;\r\nint offset = 4;\r\npi = proto_tree_add_item(tree,hf_iuup_num_rfci_ind,tvb,4,1,ENC_BIG_ENDIAN);\r\ninds_tree = proto_item_add_subtree(pi,ett_rfciinds);\r\nfor (i = 0; i < num; i++) {\r\nif (! (i % 8) ) offset++;\r\nproto_tree_add_item(inds_tree,hf_iuup_rfci_ratectl[i],tvb,offset,1,ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void add_hdr_crc(tvbuff_t* tvb, packet_info* pinfo, proto_item* iuup_tree, guint16 crccheck)\r\n{\r\nproto_item *crc_item;\r\ncrc_item = proto_tree_add_item(iuup_tree,hf_iuup_hdr_crc,tvb,2,1,ENC_BIG_ENDIAN);\r\nif (crccheck) {\r\nproto_item_append_text(crc_item, "%s", " [incorrect]");\r\nexpert_add_info(pinfo, crc_item, &ei_iuup_hdr_crc_bad);\r\n}\r\n}\r\nstatic guint16\r\nupdate_crc10_by_bytes_iuup(tvbuff_t *tvb, int offset, int length)\r\n{\r\nguint16 crc10;\r\nguint16 extra_16bits;\r\nguint8 extra_8bits[2];\r\ncrc10 = update_crc10_by_bytes_tvb(0, tvb, offset + 2, length);\r\nextra_16bits = tvb_get_ntohs(tvb, offset) & 0x3FF;\r\nextra_8bits[0] = extra_16bits >> 2;\r\nextra_8bits[1] = (extra_16bits << 6) & 0xFF;\r\ncrc10 = update_crc10_by_bytes(crc10, extra_8bits, 2);\r\nreturn crc10;\r\n}\r\nstatic void add_payload_crc(tvbuff_t* tvb, packet_info* pinfo, proto_item* iuup_tree)\r\n{\r\nproto_item *crc_item;\r\nint length = tvb_reported_length(tvb);\r\nguint16 crccheck = update_crc10_by_bytes_iuup(tvb, 2, length - 4);\r\ncrc_item = proto_tree_add_item(iuup_tree,hf_iuup_payload_crc,tvb,2,2,ENC_BIG_ENDIAN);\r\nif (crccheck) {\r\nproto_item_append_text(crc_item, "%s", " [incorrect]");\r\nexpert_add_info(pinfo, crc_item, &ei_iuup_payload_crc_bad);\r\n}\r\n}\r\nstatic int dissect_iuup(tvbuff_t* tvb_in, packet_info* pinfo, proto_tree* tree, void* data _U_) {\r\nproto_item* pi;\r\nproto_item* iuup_item = NULL;\r\nproto_item* pdutype_item = NULL;\r\nproto_tree* iuup_tree = NULL;\r\nproto_item* proc_item = NULL;\r\nproto_item* ack_item = NULL;\r\nguint8 first_octet;\r\nguint8 second_octet;\r\nguint8 pdutype;\r\nguint phdr = 0;\r\nguint16 hdrcrc6;\r\nguint16 crccheck;\r\ntvbuff_t* tvb = tvb_in;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "IuUP");\r\nif (two_byte_pseudoheader) {\r\nint len = tvb_reported_length(tvb_in) - 2;\r\nphdr = tvb_get_ntohs(tvb,0);\r\nproto_tree_add_item(tree,hf_iuup_direction,tvb,0,2,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree,hf_iuup_circuit_id,tvb,0,2,ENC_BIG_ENDIAN);\r\nphdr &= 0x7fff;\r\npinfo->circuit_id = phdr;\r\ntvb = tvb_new_subset_length(tvb_in,2,len);\r\n}\r\nfirst_octet = tvb_get_guint8(tvb,0);\r\nsecond_octet = tvb_get_guint8(tvb,1);\r\nhdrcrc6 = tvb_get_guint8(tvb, 2) >> 2;\r\ncrccheck = update_crc6_by_bytes(hdrcrc6, first_octet, second_octet);\r\npdutype = ( first_octet & PDUTYPE_MASK ) >> 4;\r\nif (tree) {\r\niuup_item = proto_tree_add_item(tree,proto_iuup,tvb,0,-1,ENC_NA);\r\niuup_tree = proto_item_add_subtree(iuup_item,ett_iuup);\r\npdutype_item = proto_tree_add_item(iuup_tree,hf_iuup_pdu_type,tvb,0,1,ENC_BIG_ENDIAN);\r\n}\r\ncol_add_str(pinfo->cinfo, COL_INFO, val_to_str(pdutype, iuup_colinfo_pdu_types, "Unknown PDU Type(%u) "));\r\nswitch(pdutype) {\r\ncase PDUTYPE_DATA_WITH_CRC:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO,"FN: %x RFCI: %u", (guint)(first_octet & 0x0f) ,(guint)(second_octet & 0x3f));\r\nproto_tree_add_item(iuup_tree,hf_iuup_frame_number,tvb,0,1,ENC_BIG_ENDIAN);\r\npi = proto_tree_add_item(iuup_tree,hf_iuup_fqc,tvb,1,1,ENC_BIG_ENDIAN);\r\nif (first_octet & FQC_MASK) {\r\nexpert_add_info(pinfo, pi, &ei_iuup_error_response);\r\n}\r\nproto_tree_add_item(iuup_tree,hf_iuup_rfci,tvb,1,1,ENC_BIG_ENDIAN);\r\nadd_hdr_crc(tvb, pinfo, iuup_tree, crccheck);\r\nadd_payload_crc(tvb, pinfo, iuup_tree);\r\ndissect_iuup_payload(tvb,pinfo,iuup_tree,second_octet & 0x3f,4,pinfo->circuit_id);\r\nreturn tvb_captured_length(tvb);\r\ncase PDUTYPE_DATA_NO_CRC:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO," RFCI %u", (guint)(second_octet & 0x3f));\r\nproto_tree_add_item(iuup_tree,hf_iuup_frame_number,tvb,0,1,ENC_BIG_ENDIAN);\r\npi = proto_tree_add_item(iuup_tree,hf_iuup_fqc,tvb,1,1,ENC_BIG_ENDIAN);\r\nif (first_octet & FQC_MASK) {\r\nexpert_add_info(pinfo, pi, &ei_iuup_error_response);\r\n}\r\nproto_tree_add_item(iuup_tree,hf_iuup_rfci,tvb,1,1,ENC_BIG_ENDIAN);\r\nadd_hdr_crc(tvb, pinfo, iuup_tree, crccheck);\r\ndissect_iuup_payload(tvb,pinfo,iuup_tree,second_octet & 0x3f,3,pinfo->circuit_id);\r\nreturn tvb_captured_length(tvb);\r\ncase PDUTYPE_DATA_CONTROL_PROC:\r\nif (tree) {\r\nack_item = proto_tree_add_item(iuup_tree,hf_iuup_ack_nack,tvb,0,1,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(iuup_tree,hf_iuup_frame_number_t14,tvb,0,1,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(iuup_tree,hf_iuup_mode_version,tvb,1,1,ENC_BIG_ENDIAN);\r\nproc_item = proto_tree_add_item(iuup_tree,hf_iuup_procedure_indicator,tvb,1,1,ENC_BIG_ENDIAN);\r\nadd_hdr_crc(tvb, pinfo, iuup_tree, crccheck);\r\n}\r\ncol_append_str(pinfo->cinfo, COL_INFO,\r\nval_to_str(first_octet & ACKNACK_MASK,\r\niuup_colinfo_acknack_vals, "[action:%u] "));\r\ncol_append_str(pinfo->cinfo, COL_INFO,\r\nval_to_str(second_octet & PROCEDURE_MASK,\r\niuup_colinfo_procedures, "[proc:%u] "));\r\nswitch ( first_octet & ACKNACK_MASK ) {\r\ncase ACKNACK_ACK:\r\nswitch(second_octet & PROCEDURE_MASK) {\r\ncase PROC_INIT:\r\nproto_tree_add_item(iuup_tree,hf_iuup_spare_03,tvb,2,1,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(iuup_tree,hf_iuup_spare_ff,tvb,3,1,ENC_BIG_ENDIAN);\r\nreturn tvb_captured_length(tvb);\r\ncase PROC_RATE:\r\ndissect_iuup_ratectl(tvb,pinfo,iuup_tree);\r\nreturn tvb_captured_length(tvb);\r\ncase PROC_TIME:\r\ncase PROC_ERROR:\r\nbreak;\r\ndefault:\r\nexpert_add_info(pinfo, proc_item, &ei_iuup_procedure_indicator);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nbreak;\r\ncase ACKNACK_NACK:\r\npi = proto_tree_add_item(iuup_tree,hf_iuup_error_cause_val,tvb,4,1,ENC_BIG_ENDIAN);\r\nexpert_add_info(pinfo, pi, &ei_iuup_error_response);\r\nreturn tvb_captured_length(tvb);\r\ncase ACKNACK_RESERVED:\r\nexpert_add_info(pinfo, ack_item, &ei_iuup_ack_nack);\r\nreturn tvb_captured_length(tvb);\r\ncase ACKNACK_PROC:\r\nbreak;\r\n}\r\nswitch( second_octet & PROCEDURE_MASK ) {\r\ncase PROC_INIT:\r\nadd_payload_crc(tvb, pinfo, iuup_tree);\r\ndissect_iuup_init(tvb,pinfo,iuup_tree,pinfo->circuit_id);\r\nreturn tvb_captured_length(tvb);\r\ncase PROC_RATE:\r\nadd_payload_crc(tvb, pinfo, iuup_tree);\r\ndissect_iuup_ratectl(tvb,pinfo,iuup_tree);\r\nreturn tvb_captured_length(tvb);\r\ncase PROC_TIME:\r\n{\r\nproto_tree* time_tree;\r\nguint ta;\r\nta = tvb_get_guint8(tvb,4);\r\npi = proto_tree_add_item(iuup_tree,hf_iuup_time_align,tvb,4,1,ENC_BIG_ENDIAN);\r\ntime_tree = proto_item_add_subtree(pi,ett_time);\r\nif (ta >= 1 && ta <= 80) {\r\npi = proto_tree_add_uint(time_tree,hf_iuup_delay,tvb,4,1,ta * 500);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\npi = proto_tree_add_float(time_tree,hf_iuup_delta,tvb,4,1,((gfloat)((gint)(ta) * 500))/(gfloat)1000000.0);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\n} else if (ta >= 129 && ta <= 208) {\r\npi = proto_tree_add_uint(time_tree,hf_iuup_advance,tvb,4,1,(ta-128) * 500);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\npi = proto_tree_add_float(time_tree,hf_iuup_delta,tvb,4,1,((gfloat)((gint)(-(((gint)ta)-128))) * 500)/(gfloat)1000000.0);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\n} else {\r\nexpert_add_info(pinfo, pi, &ei_iuup_time_align);\r\n}\r\nproto_tree_add_item(iuup_tree,hf_iuup_spare_bytes,tvb,5,-1,ENC_NA);\r\nreturn tvb_captured_length(tvb);\r\n}\r\ncase PROC_ERROR:\r\ncol_append_str(pinfo->cinfo, COL_INFO, val_to_str(tvb_get_guint8(tvb,4) & 0x3f,iuup_error_causes,"Unknown (%u)"));\r\nproto_tree_add_item(iuup_tree,hf_iuup_error_distance,tvb,4,1,ENC_BIG_ENDIAN);\r\npi = proto_tree_add_item(iuup_tree,hf_iuup_errorevt_cause_val,tvb,4,1,ENC_BIG_ENDIAN);\r\nexpert_add_info(pinfo, pi, &ei_iuup_error_response);\r\nproto_tree_add_item(iuup_tree,hf_iuup_spare_bytes,tvb,5,-1,ENC_NA);\r\nreturn tvb_captured_length(tvb);\r\ndefault:\r\nexpert_add_info(pinfo, proc_item, &ei_iuup_procedure_indicator);\r\nreturn tvb_captured_length(tvb);\r\n}\r\ndefault:\r\nexpert_add_info(pinfo, pdutype_item, &ei_iuup_pdu_type);\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean dissect_iuup_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_) {\r\nint len = tvb_captured_length(tvb);\r\nguint8 first_octet = tvb_get_guint8(tvb,0);\r\nguint8 second_octet = tvb_get_guint8(tvb,1);\r\nguint16 hdrcrc6 = tvb_get_guint8(tvb, 2) >> 2;\r\nif (update_crc6_by_bytes(hdrcrc6, first_octet, second_octet)) return FALSE;\r\nswitch ( first_octet & 0xf0 ) {\r\ncase 0x00: {\r\nif (len<7) return FALSE;\r\nif (update_crc10_by_bytes_iuup(tvb, 4, len-4) ) return FALSE;\r\nbreak;\r\n}\r\ncase 0x10:\r\nif (len<5) return FALSE;\r\nbreak;\r\ncase 0xe0:\r\nif (len<5) return FALSE;\r\nif( (second_octet & 0x0f) > 3) return FALSE;\r\nbreak;\r\ndefault:\r\nreturn FALSE;\r\n}\r\ndissect_iuup(tvb, pinfo, tree, data);\r\nreturn TRUE;\r\n}\r\nstatic int find_iuup(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_) {\r\nint len = tvb_captured_length(tvb);\r\nint offset = 0;\r\nwhile (len > 3) {\r\nif ( dissect_iuup_heur(tvb_new_subset_remaining(tvb,offset), pinfo, tree, data) )\r\nreturn tvb_captured_length(tvb);\r\noffset++;\r\nlen--;\r\n}\r\ncall_data_dissector(tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void init_iuup(void) {\r\ncircuits = g_hash_table_new(g_direct_hash,g_direct_equal);\r\n}\r\nstatic void cleanup_iuup(void) {\r\ng_hash_table_destroy(circuits);\r\n}\r\nvoid proto_reg_handoff_iuup(void) {\r\nstatic gboolean iuup_prefs_initialized = FALSE;\r\nstatic dissector_handle_t iuup_handle;\r\nstatic guint saved_dynamic_payload_type = 0;\r\nif (!iuup_prefs_initialized) {\r\niuup_handle = find_dissector("iuup");\r\ndissector_add_string("rtp_dyn_payload_type","VND.3GPP.IUFP", iuup_handle);\r\niuup_prefs_initialized = TRUE;\r\n} else {\r\nif ( saved_dynamic_payload_type > 95 ) {\r\ndissector_delete_uint("rtp.pt", saved_dynamic_payload_type, iuup_handle);\r\n}\r\n}\r\nsaved_dynamic_payload_type = global_dynamic_payload_type;\r\nif ( global_dynamic_payload_type > 95 ) {\r\ndissector_add_uint("rtp.pt", global_dynamic_payload_type, iuup_handle);\r\n}\r\n}\r\nvoid proto_register_iuup(void) {\r\nstatic hf_register_info hf[] = {\r\n{ &hf_iuup_direction, { "Frame Direction", "iuup.direction", FT_UINT16, BASE_DEC, NULL,0x8000,NULL,HFILL}},\r\n{ &hf_iuup_circuit_id, { "Circuit ID", "iuup.circuit_id", FT_UINT16, BASE_DEC, NULL,0x7fff,NULL,HFILL}},\r\n{ &hf_iuup_pdu_type, { "PDU Type", "iuup.pdu_type", FT_UINT8, BASE_DEC, VALS(iuup_pdu_types),0xf0,NULL,HFILL}},\r\n{ &hf_iuup_frame_number, { "Frame Number", "iuup.framenum", FT_UINT8, BASE_DEC, NULL,0x0F,NULL,HFILL}},\r\n{ &hf_iuup_fqc, { "FQC", "iuup.fqc", FT_UINT8, BASE_DEC, VALS(iuup_fqcs),0xc0,"Frame Quality Classification",HFILL}},\r\n{ &hf_iuup_rfci, { "RFCI", "iuup.rfci", FT_UINT8, BASE_HEX, NULL, 0x3f, "RAB sub-Flow Combination Indicator",HFILL}},\r\n{ &hf_iuup_hdr_crc, { "Header CRC", "iuup.header_crc", FT_UINT8, BASE_HEX, NULL,0xfc,NULL,HFILL}},\r\n{ &hf_iuup_payload_crc, { "Payload CRC", "iuup.payload_crc", FT_UINT16, BASE_HEX, NULL,0x03FF,NULL,HFILL}},\r\n{ &hf_iuup_ack_nack, { "Ack/Nack", "iuup.ack", FT_UINT8, BASE_DEC, VALS(iuup_acknack_vals),0x0c,NULL,HFILL}},\r\n{ &hf_iuup_frame_number_t14, { "Frame Number", "iuup.framenum_t14", FT_UINT8, BASE_DEC, NULL,0x03,NULL,HFILL}},\r\n{ &hf_iuup_mode_version, { "Mode Version", "iuup.mode", FT_UINT8, BASE_HEX, NULL,0xf0,NULL,HFILL}},\r\n{ &hf_iuup_procedure_indicator, { "Procedure", "iuup.procedure", FT_UINT8, BASE_DEC, VALS(iuup_procedures),0x0f,NULL,HFILL}},\r\n{ &hf_iuup_error_cause_val, { "Error Cause", "iuup.error_cause", FT_UINT8, BASE_DEC, VALS(iuup_error_causes),0xfc,NULL,HFILL}},\r\n{ &hf_iuup_error_distance, { "Error DISTANCE", "iuup.error_distance", FT_UINT8, BASE_DEC, VALS(iuup_error_distances),0xc0,NULL,HFILL}},\r\n{ &hf_iuup_errorevt_cause_val, { "Error Cause", "iuup.errorevt_cause", FT_UINT8, BASE_DEC, NULL,0x3f,NULL,HFILL}},\r\n{ &hf_iuup_time_align, { "Time Align", "iuup.time_align", FT_UINT8, BASE_HEX, NULL,0x0,NULL,HFILL}},\r\n{ &hf_iuup_data_pdu_type, { "RFCI Data Pdu Type", "iuup.data_pdu_type", FT_UINT8, BASE_HEX, VALS(iuup_payload_pdu_type),0xF0,NULL,HFILL}},\r\n{ &hf_iuup_spare_03, { "Spare", "iuup.spare", FT_UINT8, BASE_HEX, NULL,0x03,NULL,HFILL}},\r\n#if 0\r\n{ &hf_iuup_spare_0f, { "Spare", "iuup.spare", FT_UINT8, BASE_HEX, NULL,0x0f,NULL,HFILL}},\r\n#endif\r\n#if 0\r\n{ &hf_iuup_spare_c0, { "Spare", "iuup.spare", FT_UINT8, BASE_HEX, NULL,0xc0,NULL,HFILL}},\r\n#endif\r\n{ &hf_iuup_spare_e0, { "Spare", "iuup.spare", FT_UINT8, BASE_HEX, NULL,0xe0,NULL,HFILL}},\r\n{ &hf_iuup_spare_ff, { "Spare", "iuup.spare", FT_UINT8, BASE_HEX, NULL,0xff,NULL,HFILL}},\r\n{ &hf_iuup_spare_bytes, { "Spare", "iuup.spare_bytes", FT_BYTES, BASE_NONE, NULL,0x0,NULL,HFILL}},\r\n{ &hf_iuup_delay, { "Delay", "iuup.delay", FT_UINT32, BASE_HEX, NULL,0x0,NULL,HFILL}},\r\n{ &hf_iuup_advance, { "Advance", "iuup.advance", FT_UINT32, BASE_HEX, NULL,0x0,NULL,HFILL}},\r\n{ &hf_iuup_delta, { "Delta Time", "iuup.delta", FT_FLOAT, BASE_NONE, NULL,0x0,NULL,HFILL}},\r\n{ &hf_iuup_init_ti, { "TI", "iuup.ti", FT_UINT8, BASE_DEC, VALS(iuup_ti_vals),0x10,"Timing Information",HFILL}},\r\n{ &hf_iuup_init_subflows_per_rfci, { "Subflows", "iuup.subflows", FT_UINT8, BASE_DEC, NULL,0x0e,"Number of Subflows",HFILL}},\r\n{ &hf_iuup_init_chain_ind, { "Chain Indicator", "iuup.chain_ind", FT_UINT8, BASE_DEC, VALS(iuup_init_chain_ind_vals),0x01,NULL,HFILL}},\r\n{ &hf_iuup_payload, { "Payload Data", "iuup.payload_data", FT_BYTES, BASE_NONE, NULL,0x00,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions, { "Iu UP Mode Versions Supported", "iuup.support_mode", FT_UINT16, BASE_HEX, NULL,0x0,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions_a[ 0], { "Version 16", "iuup.support_mode.version16", FT_UINT16, BASE_HEX, VALS(iuup_mode_version_support),0x8000,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions_a[ 1], { "Version 15", "iuup.support_mode.version15", FT_UINT16, BASE_HEX, VALS(iuup_mode_version_support),0x4000,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions_a[ 2], { "Version 14", "iuup.support_mode.version14", FT_UINT16, BASE_HEX, VALS(iuup_mode_version_support),0x2000,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions_a[ 3], { "Version 13", "iuup.support_mode.version13", FT_UINT16, BASE_HEX, VALS(iuup_mode_version_support),0x1000,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions_a[ 4], { "Version 12", "iuup.support_mode.version12", FT_UINT16, BASE_HEX, VALS(iuup_mode_version_support),0x0800,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions_a[ 5], { "Version 11", "iuup.support_mode.version11", FT_UINT16, BASE_HEX, VALS(iuup_mode_version_support),0x0400,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions_a[ 6], { "Version 10", "iuup.support_mode.version10", FT_UINT16, BASE_HEX, VALS(iuup_mode_version_support),0x0200,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions_a[ 7], { "Version 9", "iuup.support_mode.version9", FT_UINT16, BASE_HEX, VALS(iuup_mode_version_support),0x0100,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions_a[ 8], { "Version 8", "iuup.support_mode.version8", FT_UINT16, BASE_HEX, VALS(iuup_mode_version_support),0x0080,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions_a[ 9], { "Version 7", "iuup.support_mode.version7", FT_UINT16, BASE_HEX, VALS(iuup_mode_version_support),0x0040,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions_a[10], { "Version 6", "iuup.support_mode.version6", FT_UINT16, BASE_HEX, VALS(iuup_mode_version_support),0x0020,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions_a[11], { "Version 5", "iuup.support_mode.version5", FT_UINT16, BASE_HEX, VALS(iuup_mode_version_support),0x0010,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions_a[12], { "Version 4", "iuup.support_mode.version4", FT_UINT16, BASE_HEX, VALS(iuup_mode_version_support),0x0008,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions_a[13], { "Version 3", "iuup.support_mode.version3", FT_UINT16, BASE_HEX, VALS(iuup_mode_version_support),0x0004,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions_a[14], { "Version 2", "iuup.support_mode.version2", FT_UINT16, BASE_HEX, VALS(iuup_mode_version_support),0x0002,NULL,HFILL}},\r\n{ &hf_iuup_mode_versions_a[15], { "Version 1", "iuup.support_mode.version1", FT_UINT16, BASE_HEX, VALS(iuup_mode_version_support),0x0001,NULL,HFILL}},\r\n{ &hf_iuup_num_rfci_ind, { "Number of RFCI Indicators", "iuup.p", FT_UINT8, BASE_HEX, NULL,0x3f,NULL,HFILL}},\r\n{ &hf_iuup_init_rfci_ind, { "RFCI Initialization", "iuup.rfci.init", FT_BYTES, BASE_NONE, NULL,0x0,NULL,HFILL}},\r\nHFS_RFCI(0),HFS_RFCI(1),HFS_RFCI(2),HFS_RFCI(3),HFS_RFCI(4),HFS_RFCI(5),HFS_RFCI(6),HFS_RFCI(7),\r\nHFS_RFCI(8),HFS_RFCI(9),HFS_RFCI(10),HFS_RFCI(11),HFS_RFCI(12),HFS_RFCI(13),HFS_RFCI(14),HFS_RFCI(15),\r\nHFS_RFCI(16),HFS_RFCI(17),HFS_RFCI(18),HFS_RFCI(19),HFS_RFCI(20),HFS_RFCI(21),HFS_RFCI(22),HFS_RFCI(23),\r\nHFS_RFCI(24),HFS_RFCI(25),HFS_RFCI(26),HFS_RFCI(27),HFS_RFCI(28),HFS_RFCI(29),HFS_RFCI(30),HFS_RFCI(31),\r\nHFS_RFCI(32),HFS_RFCI(33),HFS_RFCI(34),HFS_RFCI(35),HFS_RFCI(36),HFS_RFCI(37),HFS_RFCI(38),HFS_RFCI(39),\r\nHFS_RFCI(40),HFS_RFCI(41),HFS_RFCI(42),HFS_RFCI(43),HFS_RFCI(44),HFS_RFCI(45),HFS_RFCI(46),HFS_RFCI(47),\r\nHFS_RFCI(48),HFS_RFCI(49),HFS_RFCI(50),HFS_RFCI(51),HFS_RFCI(52),HFS_RFCI(53),HFS_RFCI(54),HFS_RFCI(55),\r\nHFS_RFCI(56),HFS_RFCI(57),HFS_RFCI(58),HFS_RFCI(59),HFS_RFCI(60),HFS_RFCI(61),HFS_RFCI(62),HFS_RFCI(63)\r\n};\r\ngint* ett[] = {\r\n&ett_iuup,\r\n&ett_rfci,\r\n&ett_ipti,\r\n&ett_support,\r\n&ett_time,\r\n&ett_rfciinds,\r\n&ett_payload,\r\n&ett_payload_subflows\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_iuup_hdr_crc_bad, { "iuup.hdr.crc.bad", PI_CHECKSUM, PI_ERROR, "Bad checksum", EXPFILL }},\r\n{ &ei_iuup_payload_crc_bad, { "iuup.payload.crc.bad", PI_CHECKSUM, PI_ERROR, "Bad checksum", EXPFILL }},\r\n{ &ei_iuup_payload_undecoded, { "iuup.payload.undecoded", PI_UNDECODED, PI_WARN, "Undecoded payload", EXPFILL }},\r\n{ &ei_iuup_error_response, { "iuup.error_response", PI_RESPONSE_CODE, PI_ERROR, "Error response", EXPFILL }},\r\n{ &ei_iuup_ack_nack, { "iuup.ack.malformed", PI_MALFORMED, PI_ERROR, "Malformed Ack/Nack", EXPFILL }},\r\n{ &ei_iuup_time_align, { "iuup.time_align.malformed", PI_MALFORMED, PI_ERROR, "Malformed Time Align", EXPFILL }},\r\n{ &ei_iuup_procedure_indicator, { "iuup.procedure.malformed", PI_MALFORMED, PI_ERROR, "Malformed Procedure", EXPFILL }},\r\n{ &ei_iuup_pdu_type, { "iuup.pdu_type.malformed", PI_MALFORMED, PI_ERROR, "Malformed PDU Type", EXPFILL }},\r\n};\r\nmodule_t *iuup_module;\r\nexpert_module_t* expert_iuup;\r\nproto_iuup = proto_register_protocol("IuUP", "IuUP", "iuup");\r\nproto_register_field_array(proto_iuup, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_iuup = expert_register_protocol(proto_iuup);\r\nexpert_register_field_array(expert_iuup, ei, array_length(ei));\r\nregister_dissector("iuup", dissect_iuup, proto_iuup);\r\nregister_dissector("find_iuup", find_iuup, proto_iuup);\r\nregister_init_routine(&init_iuup);\r\nregister_cleanup_routine(&cleanup_iuup);\r\niuup_module = prefs_register_protocol(proto_iuup, proto_reg_handoff_iuup);\r\nprefs_register_bool_preference(iuup_module, "dissect_payload",\r\n"Dissect IuUP Payload bits",\r\n"Whether IuUP Payload bits should be dissected",\r\n&dissect_fields);\r\nprefs_register_bool_preference(iuup_module, "two_byte_pseudoheader",\r\n"Two byte pseudoheader",\r\n"The payload contains a two byte pseudoheader indicating direction and circuit_id",\r\n&two_byte_pseudoheader);\r\nprefs_register_uint_preference(iuup_module, "dynamic.payload.type",\r\n"IuUP dynamic payload type",\r\n"The dynamic payload type which will be interpreted as IuUP",\r\n10,\r\n&global_dynamic_payload_type);\r\n}
