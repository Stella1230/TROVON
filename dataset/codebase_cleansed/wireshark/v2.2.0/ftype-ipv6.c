static void\r\nipv6_fvalue_set(fvalue_t *fv, const guint8 *value)\r\n{\r\nmemcpy(fv->value.ipv6.addr.bytes, value, FT_IPv6_LEN);\r\nfv->value.ipv6.prefix = 128;\r\n}\r\nstatic gboolean\r\nipv6_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, gchar **err_msg)\r\n{\r\nconst char *slash;\r\nconst char *addr_str;\r\nchar *addr_str_to_free = NULL;\r\nunsigned int nmask_bits;\r\nfvalue_t *nmask_fvalue;\r\nslash = strchr(s, '/');\r\nif (slash) {\r\naddr_str_to_free = wmem_strndup(NULL, s, slash-s);\r\naddr_str = addr_str_to_free;\r\n}\r\nelse\r\naddr_str = s;\r\nif (!get_host_ipaddr6(addr_str, &(fv->value.ipv6.addr))) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid hostname or IPv6 address.", s);\r\nif (addr_str_to_free)\r\nwmem_free(NULL, addr_str_to_free);\r\nreturn FALSE;\r\n}\r\nif (addr_str_to_free)\r\nwmem_free(NULL, addr_str_to_free);\r\nif (slash) {\r\nnmask_fvalue = fvalue_from_unparsed(FT_UINT32, slash+1, FALSE, err_msg);\r\nif (!nmask_fvalue) {\r\nreturn FALSE;\r\n}\r\nnmask_bits = fvalue_get_uinteger(nmask_fvalue);\r\nFVALUE_FREE(nmask_fvalue);\r\nif (nmask_bits > 128) {\r\nif (err_msg != NULL) {\r\n*err_msg = g_strdup_printf("Prefix in a IPv6 address should be <= 128, not %u",\r\nnmask_bits);\r\n}\r\nreturn FALSE;\r\n}\r\nfv->value.ipv6.prefix = nmask_bits;\r\n} else {\r\nfv->value.ipv6.prefix = 128;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\nipv6_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_, int field_display _U_)\r\n{\r\nreturn MAX_IP6_STR_LEN;\r\n}\r\nstatic void\r\nipv6_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, int field_display _U_, char *buf, unsigned int size)\r\n{\r\nip6_to_str_buf(&(fv->value.ipv6.addr), buf, size);\r\n}\r\nstatic gpointer\r\nvalue_get(fvalue_t *fv)\r\n{\r\nreturn fv->value.ipv6.addr.bytes;\r\n}\r\nstatic gint\r\ncmp_compare(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nconst ipv6_addr_and_prefix *a = &(fv_a->value.ipv6);\r\nconst ipv6_addr_and_prefix *b = &(fv_b->value.ipv6);\r\nguint32 prefix;\r\nint pos = 0;\r\nprefix = MIN(a->prefix, b->prefix);\r\nprefix = MIN(prefix, 128);\r\nwhile (prefix >= 8) {\r\ngint byte_a = (gint) (a->addr.bytes[pos]);\r\ngint byte_b = (gint) (b->addr.bytes[pos]);\r\nif (byte_a != byte_b)\r\nreturn byte_a - byte_b;\r\nprefix -= 8;\r\npos++;\r\n}\r\nif (prefix != 0) {\r\ngint byte_a = (gint) (a->addr.bytes[pos] & (bitmasks[prefix]));\r\ngint byte_b = (gint) (b->addr.bytes[pos] & (bitmasks[prefix]));\r\nif (byte_a != byte_b)\r\nreturn byte_a - byte_b;\r\n}\r\nreturn 0;\r\n}\r\nstatic gboolean\r\ncmp_eq(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nreturn (cmp_compare(fv_a, fv_b) == 0);\r\n}\r\nstatic gboolean\r\ncmp_ne(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nreturn (cmp_compare(fv_a, fv_b) != 0);\r\n}\r\nstatic gboolean\r\ncmp_gt(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nreturn (cmp_compare(fv_a, fv_b) > 0);\r\n}\r\nstatic gboolean\r\ncmp_ge(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nreturn (cmp_compare(fv_a, fv_b) >= 0);\r\n}\r\nstatic gboolean\r\ncmp_lt(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nreturn (cmp_compare(fv_a, fv_b) < 0);\r\n}\r\nstatic gboolean\r\ncmp_le(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nreturn (cmp_compare(fv_a, fv_b) <= 0);\r\n}\r\nstatic gboolean\r\ncmp_bitwise_and(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nconst ipv6_addr_and_prefix *a = &(fv_a->value.ipv6);\r\nconst ipv6_addr_and_prefix *b = &(fv_b->value.ipv6);\r\nguint32 prefix;\r\nint pos = 0;\r\nprefix = MIN(a->prefix, b->prefix);\r\nprefix = MIN(prefix, 128);\r\nwhile (prefix >= 8) {\r\nif (a->addr.bytes[pos] & b->addr.bytes[pos])\r\nreturn TRUE;\r\nprefix -= 8;\r\npos++;\r\n}\r\nif (prefix != 0) {\r\nguint8 byte_a = (a->addr.bytes[pos] & (bitmasks[prefix]));\r\nguint8 byte_b = (b->addr.bytes[pos] & (bitmasks[prefix]));\r\nif (byte_a & byte_b)\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic void\r\nslice(fvalue_t *fv, GByteArray *bytes, guint offset, guint length)\r\n{\r\nguint8* data;\r\ndata = fv->value.ipv6.addr.bytes + offset;\r\ng_byte_array_append(bytes, data, length);\r\n}\r\nvoid\r\nftype_register_ipv6(void)\r\n{\r\nstatic ftype_t ipv6_type = {\r\nFT_IPv6,\r\n"FT_IPv6",\r\n"IPv6 address",\r\nFT_IPv6_LEN,\r\nNULL,\r\nNULL,\r\nipv6_from_unparsed,\r\nNULL,\r\nipv6_to_repr,\r\nipv6_repr_len,\r\nNULL,\r\nipv6_fvalue_set,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nvalue_get,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ncmp_gt,\r\ncmp_ge,\r\ncmp_lt,\r\ncmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nslice,\r\n};\r\nftype_register(FT_IPv6, &ipv6_type);\r\n}
