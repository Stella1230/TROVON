static int\r\ndissect_pn_io_ps_SB(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo _U_, proto_tree *tree, guint8 *drep _U_, int hfindex, const int **fields)\r\n{\r\nif (tree) {\r\nguint8 u8StatusByte;\r\nproto_item *sb_item;\r\nu8StatusByte = tvb_get_guint8(tvb, offset);\r\nsb_item = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hfindex, ett_pn_io_ioxs, fields,\r\nENC_LITTLE_ENDIAN, BMT_NO_APPEND);\r\nproto_item_append_text(sb_item, " (%s)", ((u8StatusByte == 0x20) || (u8StatusByte == 0x00)) ? "normal" : "unnormal");\r\n}\r\nreturn offset + 1;\r\n}\r\nstatic int\r\ndissect_pn_io_ps_CB(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo _U_, proto_tree *tree, guint8 *drep _U_, int hfindex, const int **fields)\r\n{\r\nif (tree) {\r\nguint8 u8ControlByte;\r\nproto_item *cb_item;\r\nu8ControlByte = tvb_get_guint8(tvb, offset);\r\ncb_item = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hfindex, ett_pn_io_ioxs, fields,\r\nENC_LITTLE_ENDIAN, BMT_NO_APPEND);\r\nproto_item_append_text(cb_item, " (%s)", ((u8ControlByte == 0x20) || (u8ControlByte == 0x00) ||\r\n(u8ControlByte == 0xa0) || (u8ControlByte == 0x80)) ? "normal" : "unnormal");\r\n}\r\nreturn offset + 1;\r\n}\r\nstatic int\r\ndissect_PNIO_IOCS(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree,\r\nguint8 *drep _U_, int hfindex, guint16 slotNr, guint16 subSlotNr, const int **fields)\r\n{\r\nif (tree) {\r\nguint8 u8IOxS;\r\nproto_item *ioxs_item;\r\nu8IOxS = tvb_get_guint8(tvb, offset);\r\nioxs_item = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hfindex,\r\nett_pn_io_ioxs, fields, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);\r\nproto_item_append_text(ioxs_item,\r\n" (%s%s), Slot: 0x%x, Subslot: 0x%x",\r\n(u8IOxS & 0x01) ? "another IOxS follows " : "",\r\n(u8IOxS & 0x80) ? "good" : "bad",\r\nslotNr,\r\nsubSlotNr);\r\n}\r\nreturn offset + 1;\r\n}\r\nstatic int\r\ndissect_PNIO_IOxS(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo _U_, proto_tree *tree, guint8 *drep _U_, int hfindex, const int **fields)\r\n{\r\nif (tree) {\r\nguint8 u8IOxS;\r\nproto_item *ioxs_item;\r\nu8IOxS = tvb_get_guint8(tvb, offset);\r\nioxs_item = proto_tree_add_bitmask_with_flags(tree, tvb, offset, hfindex,\r\nett_pn_io_ioxs, fields, ENC_LITTLE_ENDIAN, BMT_NO_APPEND);\r\nproto_item_append_text(ioxs_item,\r\n" (%s%s)",\r\n(u8IOxS & 0x01) ? "another IOxS follows " : "",\r\n(u8IOxS & 0x80) ? "good" : "bad");\r\n}\r\nreturn offset + 1;\r\n}\r\nstatic int\r\ndissect_pn_io_ps_uint(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\r\nproto_tree *tree, guint8 *drep,\r\nint hfindex, guint8 bytelength, guint64 *pdata)\r\n{\r\nguint64 data;\r\ngboolean generalDissection;\r\ngeneralDissection = FALSE;\r\nswitch (bytelength) {\r\ncase 1:\r\ndata = tvb_get_guint8(tvb, offset);\r\nif (pdata)\r\n*pdata = data;\r\nbreak;\r\ncase 2:\r\ndata = tvb_get_letohs(tvb, offset);\r\nif (pdata)\r\n*pdata = data;\r\nbreak;\r\ncase 3:\r\ndata = tvb_get_letoh24(tvb, offset);\r\nif (pdata)\r\n*pdata = data;\r\nbreak;\r\ncase 4:\r\ndata = tvb_get_letohl(tvb, offset);\r\nif (pdata)\r\n*pdata = data;\r\nbreak;\r\ncase 5:\r\ndata = tvb_get_letoh40(tvb, offset);\r\nif (pdata)\r\n*pdata = data;\r\nbreak;\r\ncase 6:\r\ndata = tvb_get_letoh48(tvb, offset);\r\nif (pdata)\r\n*pdata = data;\r\nbreak;\r\ncase 7:\r\ndata = tvb_get_letoh56(tvb, offset);\r\nif (pdata)\r\n*pdata = data;\r\nbreak;\r\ncase 8:\r\ndata = tvb_get_letoh64(tvb, offset);\r\nif (pdata)\r\n*pdata = data;\r\nbreak;\r\ndefault:\r\ndissect_pn_user_data(tvb, offset, pinfo, tree, bytelength, "Safety IO Data");\r\ngeneralDissection = TRUE;\r\nbreak;\r\n}\r\nif (tree && generalDissection == FALSE) {\r\nproto_tree_add_item(tree, hfindex, tvb, offset, bytelength, DREP_ENC_INTEGER(drep));\r\n}\r\nreturn offset + bytelength;\r\n}\r\nint\r\ndissect_PNIO_C_SDU_RTC1(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree, guint8 *drep _U_)\r\n{\r\nproto_tree *data_tree = NULL;\r\nguint16 frameOffset;\r\nguint32 objectCounter;\r\ngboolean inputFlag;\r\ngboolean outputFlag;\r\ngboolean psInfoText;\r\nproto_item *IODataObject_item;\r\nproto_item *IODataObject_item_info;\r\nproto_tree *IODataObject_tree;\r\nproto_item *ModuleID_item;\r\nproto_item *ModuleDiff_item;\r\nwmem_strbuf_t *moduleName;\r\nguint8 toggleBitSb;\r\nguint8 toggleBitCb;\r\nguint64 f_data;\r\nguint8 statusbyte;\r\nguint8 controlbyte;\r\nguint16 number_io_data_objects_input_cr;\r\nguint16 number_iocs_input_cr;\r\nguint16 number_io_data_objects_output_cr;\r\nguint16 number_iocs_output_cr;\r\nconversation_t *conversation;\r\nstationInfo *station_info = NULL;\r\niocsObject *iocs_object;\r\nioDataObject *io_data_object;\r\nmoduleDiffInfo *module_diff_info;\r\nwmem_list_frame_t *frame;\r\nwmem_list_frame_t *frame_diff;\r\nframeOffset = 0;\r\nf_data = 0;\r\ninputFlag = FALSE;\r\noutputFlag = FALSE;\r\npsInfoText = FALSE;\r\nnumber_io_data_objects_input_cr = 0;\r\nnumber_iocs_input_cr = 0;\r\nnumber_io_data_objects_output_cr = 0;\r\nnumber_iocs_output_cr = 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "PNIO");\r\nif (tree) {\r\nproto_item *data_item;\r\ndata_item = proto_tree_add_protocol_format(tree, proto_pn_io_rtc1, tvb, offset, tvb_captured_length(tvb),\r\n"PROFINET IO Cyclic Service Data Unit: %u bytes", tvb_captured_length(tvb));\r\ndata_tree = proto_item_add_subtree(data_item, ett_pn_io_rtc);\r\n}\r\nif (!(dissect_CSF_SDU_heur(tvb, pinfo, data_tree, NULL) == FALSE))\r\nreturn(tvb_captured_length(tvb));\r\nconversation = find_conversation(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0);\r\nif (conversation != NULL) {\r\nstation_info = (stationInfo*)conversation_get_proto_data(conversation, proto_pn_dcp);\r\nif (station_info != NULL) {\r\nif (pnio_ps_selection == TRUE) {\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "PNIO_PS");\r\n}\r\nif (addresses_equal(&(pinfo->src), &(conversation->key_ptr->addr1)) && addresses_equal(&(pinfo->dst), &(conversation->key_ptr->addr2))) {\r\ninputFlag = TRUE;\r\noutputFlag = FALSE;\r\nnumber_io_data_objects_input_cr = station_info->ioDataObjectNr;\r\nnumber_iocs_input_cr = station_info->iocsNr;\r\n}\r\nif (addresses_equal(&(pinfo->dst), &(conversation->key_ptr->addr1)) && addresses_equal(&(pinfo->src), &(conversation->key_ptr->addr2))) {\r\noutputFlag = TRUE;\r\ninputFlag = FALSE;\r\nnumber_io_data_objects_output_cr = station_info->ioDataObjectNr;\r\nnumber_iocs_output_cr = station_info->iocsNr;\r\n}\r\n}\r\n}\r\nif (inputFlag) {\r\nif (pnio_ps_selection == TRUE) {\r\nproto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_type, tvb,\r\noffset, 0, "Response", "Response Frame (IO_Device -> IO_Controller)");\r\n}\r\nelse {\r\nproto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_type, tvb,\r\noffset, 0, "Input", "Input Frame (IO_Device -> IO_Controller)");\r\n}\r\nif (station_info != NULL) {\r\nif (station_info->typeofstation != NULL) {\r\nproto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_vendor, tvb, 0,\r\n0, station_info->typeofstation, "\"%s\"", station_info->typeofstation);\r\n}\r\nif (station_info->nameofstation != NULL) {\r\nproto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_nameofstation, tvb, 0,\r\n0, station_info->nameofstation, "\"%s\"", station_info->nameofstation);\r\n}\r\nif (station_info->gsdPathLength == TRUE) {\r\nif (station_info->gsdFound == TRUE) {\r\nif (station_info->gsdLocation != NULL) {\r\nIODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_found, tvb, offset, 0, ENC_NA);\r\nproto_item_append_text(IODataObject_item_info, ": \"%s\"", station_info->gsdLocation);\r\n}\r\n}\r\nelse {\r\nif (station_info->gsdLocation != NULL) {\r\nIODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_error, tvb, offset, 0, ENC_NA);\r\nproto_item_append_text(IODataObject_item_info, " Please place relevant GSD-file under \"%s\"", station_info->gsdLocation);\r\n}\r\n}\r\n}\r\nelse {\r\nIODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_path, tvb, offset, 0, ENC_NA);\r\nproto_item_append_text(IODataObject_item_info, " Please check your GSD-file networkpath. (No Path configured)");\r\n}\r\n}\r\nobjectCounter = number_io_data_objects_input_cr + number_iocs_input_cr;\r\nwhile (objectCounter--) {\r\nif (station_info != NULL) {\r\nfor (frame = wmem_list_head(station_info->ioobject_data_in); frame != NULL; frame = wmem_list_frame_next(frame)) {\r\nio_data_object = (ioDataObject*)wmem_list_frame_data(frame);\r\nif (io_data_object->frameOffset == frameOffset) {\r\nIODataObject_item = proto_tree_add_item(data_tree, hf_pn_io_io_data_object, tvb, offset, 0, ENC_NA);\r\nIODataObject_tree = proto_item_add_subtree(IODataObject_item, ett_pn_io_io_data_object);\r\nfor (frame_diff = wmem_list_head(station_info->diff_module); frame_diff != NULL; frame_diff = wmem_list_frame_next(frame_diff)) {\r\nmodule_diff_info = (moduleDiffInfo*)wmem_list_frame_data(frame_diff);\r\nif (io_data_object->moduleIdentNr != module_diff_info->modulID) {\r\nModuleDiff_item = proto_tree_add_item(IODataObject_tree, hf_pn_io_io_data_object_info_module_diff, tvb, 0, 0, ENC_NA);\r\nproto_item_append_text(ModuleDiff_item, ": Device using ModuleIdentNumber 0x%08x instead of 0x%08x", module_diff_info->modulID, io_data_object->moduleIdentNr);\r\nbreak;\r\n}\r\n}\r\nproto_tree_add_uint(IODataObject_tree, hf_pn_io_io_data_object_info_moduleidentnumber, tvb, 0, 0, io_data_object->moduleIdentNr);\r\nproto_tree_add_uint(IODataObject_tree, hf_pn_io_io_data_object_info_submoduleidentnumber, tvb, 0, 0, io_data_object->subModuleIdentNr);\r\nif (io_data_object->profisafeSupported == TRUE && pnio_ps_selection == TRUE) {\r\nif (io_data_object->profisafeSupported == TRUE && psInfoText == FALSE) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, ", PROFIsafe Device");\r\npsInfoText = TRUE;\r\n}\r\nproto_tree_add_uint(IODataObject_tree, hf_pn_io_ps_f_dest_adr, tvb, 0, 0, io_data_object->f_dest_adr);\r\nif ((io_data_object->length - F_MESSAGE_TRAILER_4BYTE) > 0) {\r\noffset = dissect_pn_io_ps_uint(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_ps_f_data,\r\n(io_data_object->length - F_MESSAGE_TRAILER_4BYTE), &f_data);\r\n}\r\nstatusbyte = tvb_get_guint8(tvb, offset);\r\ntoggleBitSb = statusbyte & 0x20;\r\nif (io_data_object->lastToggleBit != toggleBitSb) {\r\nModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_sb_toggelBitChanged, tvb, offset, 0,\r\ntoggleBitSb, "%u", toggleBitSb);\r\nPROTO_ITEM_SET_HIDDEN(ModuleID_item);\r\nModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_sb_toggelBitChange_slot_nr, tvb, offset, 0,\r\nio_data_object->slotNr, "%u", io_data_object->slotNr);\r\nPROTO_ITEM_SET_HIDDEN(ModuleID_item);\r\nModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_sb_toggelBitChange_subslot_nr, tvb, offset, 0,\r\nio_data_object->subSlotNr, "%u", io_data_object->subSlotNr);\r\nPROTO_ITEM_SET_HIDDEN(ModuleID_item);\r\n}\r\noffset = dissect_pn_io_ps_SB(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_ps_sb, ps_sb_fields);\r\noffset = dissect_pn_user_data(tvb, offset, pinfo, IODataObject_tree, io_data_object->f_crc_len, "CRC");\r\nio_data_object->last_sb_cb = statusbyte;\r\nio_data_object->lastToggleBit = toggleBitSb;\r\n}\r\nelse {\r\noffset = dissect_pn_user_data(tvb, offset, pinfo, IODataObject_tree, io_data_object->length, "IO Data");\r\n}\r\nif (io_data_object->discardIOXS == FALSE) {\r\noffset = dissect_PNIO_IOxS(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_iops, ioxs_fields);\r\nproto_item_set_len(IODataObject_item, io_data_object->length + 1);\r\n}\r\nelse {\r\nproto_item_set_len(IODataObject_item, io_data_object->length);\r\n}\r\nproto_item_append_text(IODataObject_item, ": Slot: 0x%x Subslot: 0x%x",\r\nio_data_object->slotNr, io_data_object->subSlotNr);\r\nif (io_data_object->amountInGSDML > 1) {\r\nif (io_data_object->slotNr == 0) {\r\nmoduleName = wmem_strbuf_new(wmem_packet_scope(), "Headstation");\r\n}\r\nelse {\r\nmoduleName = wmem_strbuf_new(wmem_packet_scope(), "Module");\r\n}\r\nif (io_data_object->profisafeSupported == TRUE) {\r\nif (io_data_object->length >= 5) {\r\nwmem_strbuf_append(moduleName, ", DI");\r\n}\r\nelse {\r\nwmem_strbuf_append(moduleName, ", DO");\r\n}\r\n}\r\nelse {\r\nif (io_data_object->length > 0) {\r\nwmem_strbuf_append(moduleName, ", DI");\r\n}\r\nelse {\r\nwmem_strbuf_append(moduleName, ", DO");\r\n}\r\n}\r\nio_data_object->moduleNameStr = wmem_strdup(wmem_file_scope(), wmem_strbuf_get_str(moduleName));\r\n}\r\nproto_item_append_text(IODataObject_item, " ModuleName: \"%s\"", io_data_object->moduleNameStr);\r\nif (io_data_object->profisafeSupported == TRUE && pnio_ps_selection == TRUE) {\r\n(proto_item_append_text(IODataObject_item, " (PROFIsafe Module)"));\r\n}\r\nframeOffset = frameOffset + io_data_object->length;\r\nif (io_data_object->discardIOXS == FALSE) {\r\nframeOffset = frameOffset + 1;\r\n}\r\n}\r\n}\r\n}\r\nif (station_info != NULL) {\r\nfor (frame = wmem_list_head(station_info->iocs_data_in); frame != NULL; frame = wmem_list_frame_next(frame)) {\r\niocs_object = (iocsObject*)wmem_list_frame_data(frame);\r\nif (iocs_object->frameOffset == frameOffset) {\r\noffset = dissect_PNIO_IOCS(tvb, offset, pinfo, data_tree, drep, hf_pn_io_iocs, iocs_object->slotNr,\r\niocs_object->subSlotNr, ioxs_fields);\r\nframeOffset = frameOffset + 1;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\noffset = dissect_pn_user_data(tvb, offset, pinfo, tree, tvb_captured_length_remaining(tvb, offset), "GAP and RTCPadding");\r\n}\r\nelse if (outputFlag) {\r\nif (pnio_ps_selection == TRUE) {\r\nproto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_type, tvb,\r\noffset, 0, "Request", "Request Frame (IO_Controller -> IO_Device)");\r\n}\r\nelse {\r\nproto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_type, tvb,\r\noffset, 0, "Output", "Output Frame (IO_Controller -> IO_Device)");\r\n}\r\nif (station_info != NULL) {\r\nif (station_info->typeofstation != NULL) {\r\nproto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_vendor, tvb, 0,\r\n0, station_info->typeofstation, "\"%s\"", station_info->typeofstation);\r\n}\r\nif (station_info->nameofstation != NULL) {\r\nproto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_nameofstation, tvb, 0,\r\n0, station_info->nameofstation, "\"%s\"", station_info->nameofstation);\r\n}\r\nif (station_info->gsdPathLength == TRUE) {\r\nif (station_info->gsdFound == TRUE) {\r\nif (station_info->gsdLocation != NULL) {\r\nIODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_found, tvb, offset, 0, ENC_NA);\r\nproto_item_append_text(IODataObject_item_info, ": \"%s\"", station_info->gsdLocation);\r\n}\r\n}\r\nelse {\r\nif (station_info->gsdLocation != NULL) {\r\nIODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_error, tvb, offset, 0, ENC_NA);\r\nproto_item_append_text(IODataObject_item_info, " Please place relevant GSD-file under \"%s\"", station_info->gsdLocation);\r\n}\r\n}\r\n}\r\nelse {\r\nIODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_path, tvb, offset, 0, ENC_NA);\r\nproto_item_append_text(IODataObject_item_info, " Please check your GSD-file networkpath. (No Path configured)");\r\n}\r\n}\r\nobjectCounter = number_io_data_objects_output_cr + number_iocs_output_cr;\r\nwhile (objectCounter--) {\r\nif (station_info != NULL) {\r\nfor (frame = wmem_list_head(station_info->ioobject_data_out); frame != NULL; frame = wmem_list_frame_next(frame)) {\r\nio_data_object = (ioDataObject*)wmem_list_frame_data(frame);\r\nif (io_data_object != NULL && io_data_object->frameOffset == frameOffset) {\r\nIODataObject_item = proto_tree_add_item(data_tree, hf_pn_io_io_data_object, tvb, offset, 0, ENC_NA);\r\nIODataObject_tree = proto_item_add_subtree(IODataObject_item, ett_pn_io_io_data_object);\r\nfor (frame_diff = wmem_list_head(station_info->diff_module); frame_diff != NULL; frame_diff = wmem_list_frame_next(frame_diff)) {\r\nmodule_diff_info = (moduleDiffInfo*)wmem_list_frame_data(frame_diff);\r\nif (io_data_object->moduleIdentNr != module_diff_info->modulID) {\r\nModuleDiff_item = proto_tree_add_item(IODataObject_tree, hf_pn_io_io_data_object_info_module_diff, tvb, 0, 0, ENC_NA);\r\nproto_item_append_text(ModuleDiff_item, ": Device using ModuleIdentNumber 0x%08x instead of 0x%08x", module_diff_info->modulID, io_data_object->moduleIdentNr);\r\nbreak;\r\n}\r\n}\r\nproto_tree_add_uint(IODataObject_tree, hf_pn_io_io_data_object_info_moduleidentnumber, tvb, 0, 0, io_data_object->moduleIdentNr);\r\nproto_tree_add_uint(IODataObject_tree, hf_pn_io_io_data_object_info_submoduleidentnumber, tvb, 0, 0, io_data_object->subModuleIdentNr);\r\nif (io_data_object->profisafeSupported == TRUE && pnio_ps_selection == TRUE) {\r\nif (io_data_object->profisafeSupported == TRUE && psInfoText == FALSE) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, ", PROFIsafe Device");\r\npsInfoText = TRUE;\r\n}\r\nproto_tree_add_uint(IODataObject_tree, hf_pn_io_ps_f_dest_adr, tvb, 0, 0, io_data_object->f_dest_adr);\r\nif ((io_data_object->length - F_MESSAGE_TRAILER_4BYTE) > 0) {\r\noffset = dissect_pn_io_ps_uint(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_ps_f_data,\r\n(io_data_object->length - F_MESSAGE_TRAILER_4BYTE), &f_data);\r\n}\r\ncontrolbyte = tvb_get_guint8(tvb, offset);\r\ntoggleBitCb = controlbyte & 0x20;\r\nif (io_data_object->lastToggleBit != toggleBitCb) {\r\nModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_cb_toggelBitChanged, tvb, offset, 0,\r\ntoggleBitCb, "%u", toggleBitCb);\r\nPROTO_ITEM_SET_HIDDEN(ModuleID_item);\r\nModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_cb_toggelBitChange_slot_nr, tvb, offset, 0,\r\nio_data_object->slotNr, "%u", io_data_object->slotNr);\r\nPROTO_ITEM_SET_HIDDEN(ModuleID_item);\r\nModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_cb_toggelBitChange_subslot_nr, tvb, offset, 0,\r\nio_data_object->subSlotNr, "%u", io_data_object->subSlotNr);\r\nPROTO_ITEM_SET_HIDDEN(ModuleID_item);\r\n}\r\noffset = dissect_pn_io_ps_CB(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_ps_cb, ps_cb_fields);\r\noffset = dissect_pn_user_data(tvb, offset, pinfo, IODataObject_tree, io_data_object->f_crc_len, "CRC");\r\nio_data_object->last_sb_cb = controlbyte;\r\nio_data_object->lastToggleBit = toggleBitCb;\r\n}\r\nelse {\r\noffset = dissect_pn_user_data(tvb, offset, pinfo, IODataObject_tree, io_data_object->length, "IO Data");\r\n}\r\nif (io_data_object->discardIOXS == FALSE) {\r\noffset = dissect_PNIO_IOxS(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_iops, ioxs_fields);\r\nproto_item_set_len(IODataObject_item, io_data_object->length + 1);\r\n}\r\nelse {\r\nproto_item_set_len(IODataObject_item, io_data_object->length);\r\n}\r\nproto_item_append_text(IODataObject_item, ": Slot: 0x%x Subslot: 0x%x",\r\nio_data_object->slotNr, io_data_object->subSlotNr);\r\nif (io_data_object->amountInGSDML > 1) {\r\nif (io_data_object->slotNr == 0) {\r\nmoduleName = wmem_strbuf_new(wmem_packet_scope(), "Headstation");\r\n}\r\nelse {\r\nmoduleName = wmem_strbuf_new(wmem_packet_scope(), "Module");\r\n}\r\nif (io_data_object->profisafeSupported == TRUE) {\r\nif (io_data_object->length >= 5) {\r\nwmem_strbuf_append(moduleName, ", DO");\r\n}\r\nelse {\r\nwmem_strbuf_append(moduleName, ", DI");\r\n}\r\n}\r\nelse {\r\nif (io_data_object->length > 0) {\r\nwmem_strbuf_append(moduleName, ", DO");\r\n}\r\nelse {\r\nwmem_strbuf_append(moduleName, ", DI");\r\n}\r\n}\r\nio_data_object->moduleNameStr = wmem_strdup(wmem_file_scope(), wmem_strbuf_get_str(moduleName));\r\n}\r\nproto_item_append_text(IODataObject_item, " ModuleName: \"%s\"", io_data_object->moduleNameStr);\r\nif (io_data_object->profisafeSupported == TRUE && pnio_ps_selection == TRUE) {\r\nproto_item_append_text(IODataObject_item, " (PROFIsafe Module)");\r\n}\r\nframeOffset = frameOffset + io_data_object->length;\r\nif (io_data_object->discardIOXS == FALSE) {\r\nframeOffset = frameOffset + 1;\r\n}\r\n}\r\n}\r\n}\r\nif (station_info != NULL) {\r\nfor (frame = wmem_list_head(station_info->iocs_data_out); frame != NULL; frame = wmem_list_frame_next(frame)) {\r\niocs_object = (iocsObject*)wmem_list_frame_data(frame);\r\nif (iocs_object->frameOffset == frameOffset) {\r\noffset = dissect_PNIO_IOCS(tvb, offset, pinfo, data_tree, drep, hf_pn_io_iocs, iocs_object->slotNr,\r\niocs_object->subSlotNr, ioxs_fields);\r\nframeOffset = frameOffset + 1;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\noffset = dissect_pn_user_data(tvb, offset, pinfo, tree, tvb_captured_length_remaining(tvb, offset), "GAP and RTCPadding");\r\n}\r\nreturn offset;\r\n}\r\nvoid\r\ninit_pn_io_rtc1(int proto)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_pn_io_io_data_object,\r\n{ "IODataObject", "pn_io.io_data_object",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_io_data_object_info_module_diff,\r\n{ "Difference", "pn_io.io_data_object.diff_module",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_io_data_object_info_moduleidentnumber,\r\n{ "ModuleIdentNumber", "pn_io.io_data_object.module_nr",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_io_data_object_info_submoduleidentnumber,\r\n{ "SubmoduleIdentNumber", "pn_io.io_data_object.submodule_nr",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_frame_info_type,\r\n{ "PN Frame Type", "pn_io.frame_info.type",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_frame_info_vendor,\r\n{ "DeviceVendorValue", "pn_io.frame_info.vendor",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_frame_info_nameofstation,\r\n{ "NameOfStation", "pn_io.frame_info.nameofstation",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_frame_info_gsd_found,\r\n{ "GSD-file found", "pn_io.frame_info.gsd_found",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_frame_info_gsd_error,\r\n{ "GSD-file not found.", "pn_io.frame_info.gsd_error",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_frame_info_gsd_path,\r\n{ "GSD-file networkpath failure!", "pn_io.frame_info.gsd_path",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_iocs,\r\n{ "IOCS", "pn_io.ioxs",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_iops,\r\n{ "IOPS", "pn_io.ioxs",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ioxs_extension,\r\n{ "Extension", "pn_io.ioxs.extension",\r\nFT_UINT8, BASE_HEX, VALS(pn_io_ioxs_extension), 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ioxs_res14,\r\n{ "Reserved", "pn_io.ioxs.res14",\r\nFT_UINT8, BASE_HEX, NULL, 0x1E,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ioxs_instance,\r\n{ "Instance", "pn_io.ioxs.instance",\r\nFT_UINT8, BASE_HEX, VALS(pn_io_ioxs_instance), 0x60,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ioxs_datastate,\r\n{ "DataState", "pn_io.ioxs.datastate",\r\nFT_UINT8, BASE_HEX, VALS(pn_io_ioxs_datastate), 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_sb,\r\n{ "Status Byte", "pn_io.ps.sb",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_sb_toggelBitChanged,\r\n{ "Status Byte", "pn_io.ps.sb.toggle_d_changed",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_sb_toggelBitChange_slot_nr,\r\n{ "Slot_Number", "pn_io.ps.sb.toggle_d_changed.slot",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_sb_toggelBitChange_subslot_nr,\r\n{ "Sub_Slot_Number", "pn_io.ps.sb.toggle_d_changed.subslot",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_cb,\r\n{ "Control Byte", "pn_io.ps.cb",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_cb_toggelBitChanged,\r\n{ "Control Byte", "pn_io.ps.cb.toggle_h_changed",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_cb_toggelBitChange_slot_nr,\r\n{ "Slot_Number", "pn_io.ps.cb.toggle_h_changed.slot",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_cb_toggelBitChange_subslot_nr,\r\n{ "Sub_Slot_Number", "pn_io.ps.cb.toggle_h_changed.subslot",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_sb_iparOK,\r\n{ "iPar_OK - F-Device has new iParameter values assigned", "pn_io.ps.sb.iPar_OK",\r\nFT_UINT8, BASE_HEX, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_sb_DeviceFault,\r\n{ "Device_Fault - Failure exists in F-Device or F-Module", "pn_io.ps.sb.DeviceFault",\r\nFT_UINT8, BASE_HEX, NULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_sb_CECRC,\r\n{ "CE_CRC - CRC Communication fault", "pn_io.ps.sb.CE_CRC",\r\nFT_UINT8, BASE_HEX, NULL, 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_sb_WDtimeout,\r\n{ "WD_timeout - WatchDog timeout Communication fault", "pn_io.ps.sb.WD_timeout",\r\nFT_UINT8, BASE_HEX, NULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_sb_FVactivated,\r\n{ "FV_activated - Fail-safe values (FV) activated", "pn_io.ps.sb.FV_activated",\r\nFT_UINT8, BASE_HEX, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_sb_Toggle_d,\r\n{ "Toggle_d - Device-based Toggle Bit", "pn_io.ps.sb.Toggle_d",\r\nFT_UINT8, BASE_HEX, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_sb_ConsNr_reset,\r\n{ "cons_nr_R - F-Device has reset its consecutive number counter", "pn_io.ps.sb.cons_nr_R",\r\nFT_UINT8, BASE_HEX, NULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_sb_res,\r\n{ "Bit7 - reserved for future releases", "pn_io.ps.sb.bit7",\r\nFT_UINT8, BASE_HEX, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_cb_iparEN,\r\n{ "iPar_EN - iParameter assignment deblocked", "pn_io.ps.cb.iparEN",\r\nFT_UINT8, BASE_HEX, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_cb_OAReq,\r\n{ "OA_Req - Operator acknowledge requested", "pn_io.ps.cb.OA_Req",\r\nFT_UINT8, BASE_HEX, NULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_cb_resetConsNr,\r\n{ "R_cons_nr - Set the Virtual Consecutive Number within the F-Device to be \"0\"", "pn_io.ps.cb.R_cons_nr",\r\nFT_UINT8, BASE_HEX, NULL, 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_cb_useTO2,\r\n{ "Bit3 - Reserved or Use the secondary watchdog (Use_TO2)", "pn_io.ps.cb.bit3",\r\nFT_UINT8, BASE_HEX, NULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_cb_activateFV,\r\n{ "activate_FV - Fail-safe values (FV) to be activated", "pn_io.ps.cb.activate_FV",\r\nFT_UINT8, BASE_HEX, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_cb_Toggle_h,\r\n{ "Toggle_h - Host-based Toggle Bit", "pn_io.ps.cb.Toggle_h",\r\nFT_UINT8, BASE_HEX, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_cb_Chf_ACK,\r\n{ "Bit6 - Reserved or Operator acknowledge after cleared channel fault (ChF_Ack)", "pn_io.ps.cb.bit6",\r\nFT_UINT8, BASE_HEX, NULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_cb_loopcheck,\r\n{ "Bit7 - Reserved or Loop-back check (Loopcheck, shall be set to 1)", "pn_io.ps.cb.bit7",\r\nFT_UINT8, BASE_HEX, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_f_dest_adr,\r\n{ "F_Dest_Add", "pn_io.ps.f_dest_add",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pn_io_ps_f_data,\r\n{ "SafetyIO Data", "pn_io.ps.f_data",\r\nFT_UINT64, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_pn_io_rtc,\r\n&ett_pn_io_ioxs,\r\n&ett_pn_io_io_data_object\r\n};\r\nproto_pn_io_rtc1 = proto;\r\nproto_register_field_array(proto, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}
