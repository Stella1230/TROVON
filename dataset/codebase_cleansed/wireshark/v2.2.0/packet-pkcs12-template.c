static void append_oid(proto_tree *tree, const char *oid)\r\n{\r\nconst char *name = NULL;\r\nname = oid_resolved_from_string(wmem_packet_scope(), oid);\r\nproto_item_append_text(tree, " (%s)", name ? name : oid);\r\n}\r\nstatic int\r\ngenerate_key_or_iv(unsigned int id, tvbuff_t *salt_tvb, unsigned int iter,\r\nconst char *pw, unsigned int req_keylen, char * keybuf)\r\n{\r\nint rc;\r\nunsigned int i, j;\r\ngcry_md_hd_t md;\r\ngcry_mpi_t num_b1 = NULL;\r\nsize_t pwlen;\r\nchar hash[20], buf_b[64], buf_i[128], *p;\r\nchar *salt_p;\r\nint salt_size;\r\nsize_t cur_keylen;\r\nsize_t n;\r\ngcry_error_t err;\r\ncur_keylen = 0;\r\nsalt_size = tvb_captured_length(salt_tvb);\r\nsalt_p = (char *)tvb_memdup(wmem_packet_scope(), salt_tvb, 0, salt_size);\r\nif (pw == NULL)\r\npwlen = 0;\r\nelse\r\npwlen = strlen(pw);\r\nif (pwlen > 63 / 2)\r\n{\r\nreturn FALSE;\r\n}\r\np = buf_i;\r\nfor (i = 0; i < 64; i++)\r\n*p++ = salt_p[i % salt_size];\r\nif (pw)\r\n{\r\nfor (i = j = 0; i < 64; i += 2)\r\n{\r\n*p++ = 0;\r\n*p++ = pw[j];\r\nif (++j > pwlen)\r\nj = 0;\r\n}\r\n}\r\nelse\r\nmemset (p, 0, 64);\r\nfor (;;) {\r\nerr = gcry_md_open(&md, GCRY_MD_SHA1, 0);\r\nif (gcry_err_code(err))\r\n{\r\nreturn FALSE;\r\n}\r\nfor (i = 0; i < 64; i++)\r\n{\r\nunsigned char lid = id & 0xFF;\r\ngcry_md_write (md, &lid, 1);\r\n}\r\ngcry_md_write(md, buf_i, pw ? 128 : 64);\r\ngcry_md_final (md);\r\nmemcpy (hash, gcry_md_read (md, 0), 20);\r\ngcry_md_close (md);\r\nfor (i = 1; i < iter; i++)\r\ngcry_md_hash_buffer (GCRY_MD_SHA1, hash, hash, 20);\r\nfor (i = 0; i < 20 && cur_keylen < req_keylen; i++)\r\nkeybuf[cur_keylen++] = hash[i];\r\nif (cur_keylen == req_keylen)\r\n{\r\ngcry_mpi_release (num_b1);\r\nreturn TRUE;\r\n}\r\nfor (i = 0; i < 64; i++)\r\nbuf_b[i] = hash[i % 20];\r\nn = 64;\r\nrc = gcry_mpi_scan (&num_b1, GCRYMPI_FMT_USG, buf_b, n, &n);\r\nif (rc != 0)\r\n{\r\nreturn FALSE;\r\n}\r\ngcry_mpi_add_ui (num_b1, num_b1, 1);\r\nfor (i = 0; i < 128; i += 64)\r\n{\r\ngcry_mpi_t num_ij;\r\nn = 64;\r\nrc = gcry_mpi_scan (&num_ij, GCRYMPI_FMT_USG, buf_i + i, n, &n);\r\nif (rc != 0)\r\n{\r\nreturn FALSE;\r\n}\r\ngcry_mpi_add (num_ij, num_ij, num_b1);\r\ngcry_mpi_clear_highbit (num_ij, 64 * 8);\r\nn = 64;\r\nrc = gcry_mpi_print (GCRYMPI_FMT_USG, buf_i + i, n, &n, num_ij);\r\nif (rc != 0)\r\n{\r\nreturn FALSE;\r\n}\r\ngcry_mpi_release (num_ij);\r\n}\r\n}\r\n}\r\nvoid PBE_reset_parameters(void)\r\n{\r\niteration_count = 0;\r\nsalt = NULL;\r\n}\r\nint PBE_decrypt_data(const char *object_identifier_id_param _U_, tvbuff_t *encrypted_tvb _U_, asn1_ctx_t *actx _U_, proto_item *item _U_)\r\n{\r\n#ifdef HAVE_LIBGCRYPT\r\nconst char *encryption_algorithm;\r\ngcry_cipher_hd_t cipher;\r\ngcry_error_t err;\r\nint algo;\r\nint mode;\r\nint ivlen = 0;\r\nint keylen = 0;\r\nint datalen = 0;\r\nchar *key = NULL;\r\nchar *iv = NULL;\r\nchar *clear_data = NULL;\r\ntvbuff_t *clear_tvb = NULL;\r\nconst gchar *oidname;\r\nGString *name;\r\nproto_tree *tree;\r\nchar byte;\r\ngboolean decrypt_ok = TRUE;\r\nif(((password == NULL) || (*password == '\0')) && (try_null_password == FALSE)) {\r\nreturn FALSE;\r\n}\r\nencryption_algorithm = x509af_get_last_algorithm_id();\r\nif(!strcmp(encryption_algorithm, PKCS12_PBE_3DES_SHA1_OID)) {\r\nivlen = 8;\r\nkeylen = 24;\r\nalgo = GCRY_CIPHER_3DES;\r\nmode = GCRY_CIPHER_MODE_CBC;\r\n} else if(!strcmp(encryption_algorithm, PKCS12_PBE_ARCFOUR_SHA1_OID)) {\r\nivlen = 0;\r\nkeylen = 16;\r\nalgo = GCRY_CIPHER_ARCFOUR;\r\nmode = GCRY_CIPHER_MODE_NONE;\r\n} else if(!strcmp(encryption_algorithm, PKCS12_PBE_RC2_40_SHA1_OID)) {\r\nivlen = 8;\r\nkeylen = 5;\r\nalgo = GCRY_CIPHER_RFC2268_40;\r\nmode = GCRY_CIPHER_MODE_CBC;\r\n} else {\r\nproto_item_append_text(item, " [Unsupported encryption algorithm]");\r\nreturn FALSE;\r\n}\r\nif((iteration_count == 0) || (salt == NULL)) {\r\nproto_item_append_text(item, " [Insufficient parameters]");\r\nreturn FALSE;\r\n}\r\nkey = (char *)wmem_alloc(wmem_packet_scope(), keylen);\r\nif(!generate_key_or_iv(1 , salt, iteration_count, password, keylen, key))\r\nreturn FALSE;\r\nif(ivlen) {\r\niv = (char *)wmem_alloc(wmem_packet_scope(), ivlen);\r\nif(!generate_key_or_iv(2 , salt, iteration_count, password, ivlen, iv))\r\nreturn FALSE;\r\n}\r\nerr = gcry_cipher_open(&cipher, algo, mode, 0);\r\nif (gcry_err_code (err))\r\nreturn FALSE;\r\nerr = gcry_cipher_setkey (cipher, key, keylen);\r\nif (gcry_err_code (err)) {\r\ngcry_cipher_close (cipher);\r\nreturn FALSE;\r\n}\r\nif(ivlen) {\r\nerr = gcry_cipher_setiv (cipher, iv, ivlen);\r\nif (gcry_err_code (err)) {\r\ngcry_cipher_close (cipher);\r\nreturn FALSE;\r\n}\r\n}\r\ndatalen = tvb_captured_length(encrypted_tvb);\r\nclear_data = (char *)g_malloc(datalen);\r\nerr = gcry_cipher_decrypt (cipher, clear_data, datalen, (char *)tvb_memdup(wmem_packet_scope(), encrypted_tvb, 0, datalen), datalen);\r\nif (gcry_err_code (err)) {\r\nproto_item_append_text(item, " [Failed to decrypt with password preference]");\r\ngcry_cipher_close (cipher);\r\ng_free(clear_data);\r\nreturn FALSE;\r\n}\r\ngcry_cipher_close (cipher);\r\nbyte = clear_data[datalen-1];\r\nif(byte <= 0x08) {\r\nint i;\r\nfor(i = (int)byte; i > 0 ; i--) {\r\nif(clear_data[datalen - i] != byte) {\r\ndecrypt_ok = FALSE;\r\nbreak;\r\n}\r\n}\r\n} else {\r\n}\r\nbyte = clear_data[0];\r\nif((byte != 0x30) && (byte != 0x31)) {\r\ndecrypt_ok = FALSE;\r\n}\r\nif(!decrypt_ok) {\r\ng_free(clear_data);\r\nproto_item_append_text(item, " [Failed to decrypt with supplied password]");\r\nreturn FALSE;\r\n}\r\nproto_item_append_text(item, " [Decrypted successfully]");\r\ntree = proto_item_add_subtree(item, ett_decrypted_pbe);\r\nclear_tvb = tvb_new_child_real_data(encrypted_tvb,(const guint8 *)clear_data, datalen, datalen);\r\ntvb_set_free_cb(clear_tvb, g_free);\r\nname = g_string_new("");\r\noidname = oid_resolved_from_string(wmem_packet_scope(), object_identifier_id_param);\r\ng_string_printf(name, "Decrypted %s", oidname ? oidname : object_identifier_id_param);\r\nadd_new_data_source(actx->pinfo, clear_tvb, name->str);\r\ng_string_free(name, TRUE);\r\ncall_ber_oid_callback(object_identifier_id_param, clear_tvb, 0, actx->pinfo, tree, NULL);\r\nreturn TRUE;\r\n#else\r\nreturn FALSE;\r\n#endif\r\n}\r\nstatic int strip_octet_string(tvbuff_t *tvb)\r\n{\r\ngint8 ber_class;\r\ngboolean pc, ind;\r\ngint32 tag;\r\nguint32 len;\r\nint offset = 0;\r\noffset = get_ber_identifier(tvb, 0, &ber_class, &pc, &tag);\r\noffset = get_ber_length(tvb, offset, &len, &ind);\r\nif((ber_class == BER_CLASS_UNI) && (tag == BER_UNI_TAG_OCTETSTRING))\r\nreturn offset;\r\nreturn 0;\r\n}\r\nstatic int dissect_AuthenticatedSafe_OCTETSTRING_PDU(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_) {\r\nint offset = 0;\r\nasn1_ctx_t asn1_ctx;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\r\nif((offset = strip_octet_string(tvb)) > 0)\r\ndissect_pkcs12_AuthenticatedSafe(FALSE, tvb, offset, &asn1_ctx, tree, hf_pkcs12_AuthenticatedSafe_PDU);\r\nelse\r\nproto_tree_add_expert(tree, pinfo, &ei_pkcs12_octet_string_expected, tvb, 0, 1);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int dissect_SafeContents_OCTETSTRING_PDU(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\nasn1_ctx_t asn1_ctx;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\r\noffset = strip_octet_string(tvb);\r\ndissect_pkcs12_SafeContents(FALSE, tvb, offset, &asn1_ctx, tree, hf_pkcs12_SafeContents_PDU);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int dissect_X509Certificate_OCTETSTRING_PDU(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\nasn1_ctx_t asn1_ctx;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\r\nif((offset = strip_octet_string(tvb)) > 0)\r\ndissect_x509af_Certificate(FALSE, tvb, offset, &asn1_ctx, tree, hf_pkcs12_X509Certificate_PDU);\r\nelse\r\nproto_tree_add_expert(tree, pinfo, &ei_pkcs12_octet_string_expected, tvb, 0, 1);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_pkcs12(void) {\r\nstatic hf_register_info hf[] = {\r\n{ &hf_pkcs12_X509Certificate_PDU,\r\n{ "X509Certificate", "pkcs12.X509Certificate",\r\nFT_NONE, BASE_NONE, NULL, 0,\r\n"pkcs12.X509Certificate", HFILL }},\r\n{ &hf_pkcs12_AuthenticatedSafe_PDU,\r\n{ "AuthenticatedSafe", "pkcs12.AuthenticatedSafe",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n#include "packet-pkcs12-hfarr.c"\r\n};\r\nstatic gint *ett[] = {\r\n&ett_decrypted_pbe,\r\n#include "packet-pkcs12-ettarr.c"\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_pkcs12_octet_string_expected, { "pkcs12.octet_string_expected", PI_PROTOCOL, PI_WARN, "BER Error: OCTET STRING expected", EXPFILL }},\r\n};\r\nmodule_t *pkcs12_module;\r\nexpert_module_t* expert_pkcs12;\r\nproto_pkcs12 = proto_register_protocol(PNAME, PSNAME, PFNAME);\r\nproto_register_field_array(proto_pkcs12, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_pkcs12 = expert_register_protocol(proto_pkcs12);\r\nexpert_register_field_array(expert_pkcs12, ei, array_length(ei));\r\npkcs12_module = prefs_register_protocol(proto_pkcs12, NULL);\r\nprefs_register_string_preference(pkcs12_module, "password",\r\n"Password to decrypt the file with",\r\n"The password to used to decrypt the encrypted elements within"\r\n" the PKCS#12 file", &password);\r\nprefs_register_bool_preference(pkcs12_module, "try_null_password",\r\n"Try to decrypt with a empty password",\r\n"Whether to try and decrypt the encrypted data within the"\r\n" PKCS#12 with a NULL password", &try_null_password);\r\nregister_ber_syntax_dissector("PKCS#12", proto_pkcs12, dissect_PFX_PDU);\r\nregister_ber_oid_syntax(".p12", NULL, "PKCS#12");\r\nregister_ber_oid_syntax(".pfx", NULL, "PKCS#12");\r\n}\r\nvoid proto_reg_handoff_pkcs12(void) {\r\n#include "packet-pkcs12-dis-tab.c"\r\nregister_ber_oid_dissector("1.2.840.113549.1.9.22.1", dissect_X509Certificate_OCTETSTRING_PDU, proto_pkcs12, "x509Certificate");\r\n}
