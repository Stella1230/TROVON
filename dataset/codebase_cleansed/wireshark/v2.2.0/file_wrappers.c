static int\r\nraw_read(FILE_T state, unsigned char *buf, unsigned int count, guint *have)\r\n{\r\nssize_t ret;\r\n*have = 0;\r\ndo {\r\nret = ws_read(state->fd, buf + *have, count - *have);\r\nif (ret <= 0)\r\nbreak;\r\n*have += (unsigned)ret;\r\nstate->raw_pos += ret;\r\n} while (*have < count);\r\nif (ret < 0) {\r\nstate->err = errno;\r\nstate->err_info = NULL;\r\nreturn -1;\r\n}\r\nif (ret == 0)\r\nstate->eof = TRUE;\r\nreturn 0;\r\n}\r\nstatic int\r\nfill_in_buffer(FILE_T state)\r\n{\r\nif (state->err)\r\nreturn -1;\r\nif (state->eof == 0) {\r\nif (raw_read(state, state->in, state->size, &(state->avail_in)) == -1)\r\nreturn -1;\r\nstate->next_in = state->in;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct fast_seek_point *\r\nfast_seek_find(FILE_T file, gint64 pos)\r\n{\r\nstruct fast_seek_point *smallest = NULL;\r\nstruct fast_seek_point *item;\r\nguint low, i, max;\r\nif (!file->fast_seek)\r\nreturn NULL;\r\nfor (low = 0, max = file->fast_seek->len; low < max; ) {\r\ni = (low + max) / 2;\r\nitem = (struct fast_seek_point *)file->fast_seek->pdata[i];\r\nif (pos < item->out)\r\nmax = i;\r\nelse if (pos > item->out) {\r\nsmallest = item;\r\nlow = i + 1;\r\n} else {\r\nreturn item;\r\n}\r\n}\r\nreturn smallest;\r\n}\r\nstatic void\r\nfast_seek_header(FILE_T file, gint64 in_pos, gint64 out_pos,\r\ncompression_t compression)\r\n{\r\nstruct fast_seek_point *item = NULL;\r\nif (file->fast_seek->len != 0)\r\nitem = (struct fast_seek_point *)file->fast_seek->pdata[file->fast_seek->len - 1];\r\nif (!item || item->out < out_pos) {\r\nstruct fast_seek_point *val = g_new(struct fast_seek_point,1);\r\nval->in = in_pos;\r\nval->out = out_pos;\r\nval->compression = compression;\r\ng_ptr_array_add(file->fast_seek, val);\r\n}\r\n}\r\nstatic int\r\ngz_next1(FILE_T state, guint8 *ret)\r\n{\r\nint ch;\r\nch = GZ_GETC();\r\nif (ch == -1) {\r\nif (state->err == 0) {\r\nstate->err = WTAP_ERR_SHORT_READ;\r\nstate->err_info = NULL;\r\n}\r\nreturn -1;\r\n}\r\n*ret = ch;\r\nreturn 0;\r\n}\r\nstatic int\r\ngz_next2(FILE_T state, guint16 *ret)\r\n{\r\nguint16 val;\r\nint ch;\r\nval = GZ_GETC();\r\nch = GZ_GETC();\r\nif (ch == -1) {\r\nif (state->err == 0) {\r\nstate->err = WTAP_ERR_SHORT_READ;\r\nstate->err_info = NULL;\r\n}\r\nreturn -1;\r\n}\r\nval += (guint16)ch << 8;\r\n*ret = val;\r\nreturn 0;\r\n}\r\nstatic int\r\ngz_next4(FILE_T state, guint32 *ret)\r\n{\r\nguint32 val;\r\nint ch;\r\nval = GZ_GETC();\r\nval += (unsigned)GZ_GETC() << 8;\r\nval += (guint32)GZ_GETC() << 16;\r\nch = GZ_GETC();\r\nif (ch == -1) {\r\nif (state->err == 0) {\r\nstate->err = WTAP_ERR_SHORT_READ;\r\nstate->err_info = NULL;\r\n}\r\nreturn -1;\r\n}\r\nval += (guint32)ch << 24;\r\n*ret = val;\r\nreturn 0;\r\n}\r\nstatic int\r\ngz_skipn(FILE_T state, size_t n)\r\n{\r\nwhile (n != 0) {\r\nif (GZ_GETC() == -1) {\r\nif (state->err == 0) {\r\nstate->err = WTAP_ERR_SHORT_READ;\r\nstate->err_info = NULL;\r\n}\r\nreturn -1;\r\n}\r\nn--;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ngz_skipzstr(FILE_T state)\r\n{\r\nint ch;\r\nwhile ((ch = GZ_GETC()) > 0)\r\n;\r\nif (ch == -1) {\r\nif (state->err == 0) {\r\nstate->err = WTAP_ERR_SHORT_READ;\r\nstate->err_info = NULL;\r\n}\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nzlib_fast_seek_add(FILE_T file, struct zlib_cur_seek_point *point, int bits, gint64 in_pos, gint64 out_pos)\r\n{\r\nstruct fast_seek_point *item = (struct fast_seek_point *)file->fast_seek->pdata[file->fast_seek->len - 1];\r\n#ifndef HAVE_INFLATEPRIME\r\nif (bits)\r\nreturn;\r\n#endif\r\nif (item->out + SPAN < out_pos) {\r\nstruct fast_seek_point *val = g_new(struct fast_seek_point,1);\r\nval->in = in_pos;\r\nval->out = out_pos;\r\nval->compression = ZLIB;\r\n#ifdef HAVE_INFLATEPRIME\r\nval->data.zlib.bits = bits;\r\n#endif\r\nif (point->pos != 0) {\r\nunsigned int left = ZLIB_WINSIZE - point->pos;\r\nmemcpy(val->data.zlib.window, point->window + point->pos, left);\r\nmemcpy(val->data.zlib.window + left, point->window, point->pos);\r\n} else\r\nmemcpy(val->data.zlib.window, point->window, ZLIB_WINSIZE);\r\nval->data.zlib.adler = (guint32) file->strm.adler;\r\nval->data.zlib.total_out = (guint32) file->strm.total_out;\r\ng_ptr_array_add(file->fast_seek, val);\r\n}\r\n}\r\nstatic void\r\nzlib_read(FILE_T state, unsigned char *buf, unsigned int count)\r\n{\r\nint ret = 0;\r\nguint32 crc, len;\r\nz_streamp strm = &(state->strm);\r\nunsigned char *buf2 = buf;\r\nunsigned int count2 = count;\r\nstrm->avail_out = count;\r\nstrm->next_out = buf;\r\ndo {\r\nif (state->avail_in == 0 && fill_in_buffer(state) == -1)\r\nbreak;\r\nif (state->avail_in == 0) {\r\nstate->err = WTAP_ERR_SHORT_READ;\r\nstate->err_info = NULL;\r\nbreak;\r\n}\r\nstrm->avail_in = state->avail_in;\r\nstrm->next_in = state->next_in;\r\n#ifdef Z_BLOCK\r\nret = inflate(strm, Z_BLOCK);\r\n#else\r\nret = inflate(strm, Z_NO_FLUSH);\r\n#endif\r\nstate->avail_in = strm->avail_in;\r\n#ifdef z_const\r\nDIAG_OFF(cast-qual)\r\nstate->next_in = (unsigned char *)strm->next_in;\r\nDIAG_ON(cast-qual)\r\n#else\r\nstate->next_in = strm->next_in;\r\n#endif\r\nif (ret == Z_STREAM_ERROR) {\r\nstate->err = WTAP_ERR_DECOMPRESS;\r\nstate->err_info = strm->msg;\r\nbreak;\r\n}\r\nif (ret == Z_NEED_DICT) {\r\nstate->err = WTAP_ERR_DECOMPRESS;\r\nstate->err_info = "preset dictionary needed";\r\nbreak;\r\n}\r\nif (ret == Z_MEM_ERROR) {\r\nstate->err = ENOMEM;\r\nstate->err_info = NULL;\r\nbreak;\r\n}\r\nif (ret == Z_DATA_ERROR) {\r\nstate->err = WTAP_ERR_DECOMPRESS;\r\nstate->err_info = strm->msg;\r\nbreak;\r\n}\r\nstrm->adler = crc32(strm->adler, buf2, count2 - strm->avail_out);\r\n#ifdef Z_BLOCK\r\nif (state->fast_seek_cur) {\r\nstruct zlib_cur_seek_point *cur = (struct zlib_cur_seek_point *) state->fast_seek_cur;\r\nunsigned int ready = count2 - strm->avail_out;\r\nif (ready < ZLIB_WINSIZE) {\r\nguint left = ZLIB_WINSIZE - cur->pos;\r\nif (ready >= left) {\r\nmemcpy(cur->window + cur->pos, buf2, left);\r\nif (ready != left)\r\nmemcpy(cur->window, buf2 + left, ready - left);\r\ncur->pos = ready - left;\r\ncur->have += ready;\r\n} else {\r\nmemcpy(cur->window + cur->pos, buf2, ready);\r\ncur->pos += ready;\r\ncur->have += ready;\r\n}\r\nif (cur->have >= ZLIB_WINSIZE)\r\ncur->have = ZLIB_WINSIZE;\r\n} else {\r\nmemcpy(cur->window, buf2 + (ready - ZLIB_WINSIZE), ZLIB_WINSIZE);\r\ncur->pos = 0;\r\ncur->have = ZLIB_WINSIZE;\r\n}\r\nif (cur->have >= ZLIB_WINSIZE && ret != Z_STREAM_END && (strm->data_type & 128) && !(strm->data_type & 64))\r\nzlib_fast_seek_add(state, cur, (strm->data_type & 7), state->raw_pos - strm->avail_in, state->pos + (count - strm->avail_out));\r\n}\r\n#endif\r\nbuf2 = (buf2 + count2 - strm->avail_out);\r\ncount2 = strm->avail_out;\r\n} while (strm->avail_out && ret != Z_STREAM_END);\r\nstate->next = buf;\r\nstate->have = count - strm->avail_out;\r\nif (ret == Z_STREAM_END) {\r\nif (gz_next4(state, &crc) != -1 &&\r\ngz_next4(state, &len) != -1) {\r\nif (crc != strm->adler && !state->dont_check_crc) {\r\nstate->err = WTAP_ERR_DECOMPRESS;\r\nstate->err_info = "bad CRC";\r\n} else if (len != (strm->total_out & 0xffffffffUL)) {\r\nstate->err = WTAP_ERR_DECOMPRESS;\r\nstate->err_info = "length field wrong";\r\n}\r\n}\r\nstate->compression = UNKNOWN;\r\ng_free(state->fast_seek_cur);\r\nstate->fast_seek_cur = NULL;\r\n}\r\n}\r\nstatic int\r\ngz_head(FILE_T state)\r\n{\r\nif (state->avail_in == 0) {\r\nif (fill_in_buffer(state) == -1)\r\nreturn -1;\r\nif (state->avail_in == 0)\r\nreturn 0;\r\n}\r\n#ifdef HAVE_ZLIB\r\nif (state->next_in[0] == 31) {\r\nstate->avail_in--;\r\nstate->next_in++;\r\nif (state->avail_in == 0 && fill_in_buffer(state) == -1)\r\nreturn -1;\r\nif (state->avail_in && state->next_in[0] == 139) {\r\nguint8 cm;\r\nguint8 flags;\r\nguint16 len;\r\nguint16 hcrc;\r\nstate->avail_in--;\r\nstate->next_in++;\r\nif (gz_next1(state, &cm) == -1)\r\nreturn -1;\r\nif (cm != 8) {\r\nstate->err = WTAP_ERR_DECOMPRESS;\r\nstate->err_info = "unknown compression method";\r\nreturn -1;\r\n}\r\nif (gz_next1(state, &flags) == -1)\r\nreturn -1;\r\nif (flags & 0xe0) {\r\nstate->err = WTAP_ERR_DECOMPRESS;\r\nstate->err_info = "reserved flag bits set";\r\nreturn -1;\r\n}\r\nif (gz_skipn(state, 4) == -1)\r\nreturn -1;\r\nif (gz_skipn(state, 1) == -1)\r\nreturn -1;\r\nif (gz_skipn(state, 1) == -1)\r\nreturn -1;\r\nif (flags & 4) {\r\nif (gz_next2(state, &len) == -1)\r\nreturn -1;\r\nif (gz_skipn(state, len) == -1)\r\nreturn -1;\r\n}\r\nif (flags & 8) {\r\nif (gz_skipzstr(state) == -1)\r\nreturn -1;\r\n}\r\nif (flags & 16) {\r\nif (gz_skipzstr(state) == -1)\r\nreturn -1;\r\n}\r\nif (flags & 2) {\r\nif (gz_next2(state, &hcrc) == -1)\r\nreturn -1;\r\n}\r\ninflateReset(&(state->strm));\r\nstate->strm.adler = crc32(0L, Z_NULL, 0);\r\nstate->compression = ZLIB;\r\nstate->is_compressed = TRUE;\r\n#ifdef Z_BLOCK\r\nif (state->fast_seek) {\r\nstruct zlib_cur_seek_point *cur = g_new(struct zlib_cur_seek_point,1);\r\ncur->pos = cur->have = 0;\r\ng_free(state->fast_seek_cur);\r\nstate->fast_seek_cur = cur;\r\nfast_seek_header(state, state->raw_pos - state->avail_in, state->pos, GZIP_AFTER_HEADER);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nelse {\r\nstate->out[0] = 31;\r\nstate->have = 1;\r\n}\r\n}\r\n#endif\r\n#ifdef HAVE_LIBXZ\r\n#endif\r\nif (state->fast_seek)\r\nfast_seek_header(state, state->raw_pos - state->avail_in - state->have, state->pos, UNCOMPRESSED);\r\nstate->raw = state->pos;\r\nstate->next = state->out;\r\nif (state->avail_in) {\r\nmemcpy(state->next + state->have, state->next_in, state->avail_in);\r\nstate->have += state->avail_in;\r\nstate->avail_in = 0;\r\n}\r\nstate->compression = UNCOMPRESSED;\r\nreturn 0;\r\n}\r\nstatic int\r\nfill_out_buffer(FILE_T state)\r\n{\r\nif (state->compression == UNKNOWN) {\r\nif (gz_head(state) == -1)\r\nreturn -1;\r\nif (state->have)\r\nreturn 0;\r\n}\r\nif (state->compression == UNCOMPRESSED) {\r\nif (raw_read(state, state->out, state->size , &(state->have)) == -1)\r\nreturn -1;\r\nstate->next = state->out;\r\n}\r\n#ifdef HAVE_ZLIB\r\nelse if (state->compression == ZLIB) {\r\nzlib_read(state, state->out, state->size << 1);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int\r\ngz_skip(FILE_T state, gint64 len)\r\n{\r\nguint n;\r\nwhile (len)\r\nif (state->have) {\r\nn = (gint64)state->have > len ? (unsigned)len : state->have;\r\nstate->have -= n;\r\nstate->next += n;\r\nstate->pos += n;\r\nlen -= n;\r\n} else if (state->err) {\r\nreturn -1;\r\n} else if (state->eof && state->avail_in == 0) {\r\nbreak;\r\n} else {\r\nif (fill_out_buffer(state) == -1)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ngz_reset(FILE_T state)\r\n{\r\nstate->have = 0;\r\nstate->eof = FALSE;\r\nstate->compression = UNKNOWN;\r\nstate->seek_pending = FALSE;\r\nstate->err = 0;\r\nstate->err_info = NULL;\r\nstate->pos = 0;\r\nstate->avail_in = 0;\r\n}\r\nFILE_T\r\nfile_fdopen(int fd)\r\n{\r\n#ifdef _STATBUF_ST_BLKSIZE\r\nws_statb64 st;\r\n#endif\r\nint want = GZBUFSIZE;\r\nFILE_T state;\r\nif (fd == -1)\r\nreturn NULL;\r\nstate = (FILE_T)g_try_malloc(sizeof *state);\r\nif (state == NULL)\r\nreturn NULL;\r\nstate->fast_seek_cur = NULL;\r\nstate->fast_seek = NULL;\r\nstate->fd = fd;\r\nstate->is_compressed = FALSE;\r\nstate->start = ws_lseek64(state->fd, 0, SEEK_CUR);\r\nif (state->start == -1) state->start = 0;\r\nstate->raw_pos = state->start;\r\ngz_reset(state);\r\n#ifdef _STATBUF_ST_BLKSIZE\r\nif (ws_fstat64(fd, &st) >= 0) {\r\nif (st.st_blksize <= G_MAXINT)\r\nwant = (int)st.st_blksize;\r\n}\r\n#endif\r\nstate->in = (unsigned char *)g_try_malloc(want);\r\nstate->out = (unsigned char *)g_try_malloc(want << 1);\r\nstate->size = want;\r\nif (state->in == NULL || state->out == NULL) {\r\ng_free(state->out);\r\ng_free(state->in);\r\ng_free(state);\r\nerrno = ENOMEM;\r\nreturn NULL;\r\n}\r\n#ifdef HAVE_ZLIB\r\nstate->strm.zalloc = Z_NULL;\r\nstate->strm.zfree = Z_NULL;\r\nstate->strm.opaque = Z_NULL;\r\nstate->strm.avail_in = 0;\r\nstate->strm.next_in = Z_NULL;\r\nif (inflateInit2(&(state->strm), -15) != Z_OK) {\r\ng_free(state->out);\r\ng_free(state->in);\r\ng_free(state);\r\nerrno = ENOMEM;\r\nreturn NULL;\r\n}\r\nstate->dont_check_crc = FALSE;\r\n#endif\r\nreturn state;\r\n}\r\nFILE_T\r\nfile_open(const char *path)\r\n{\r\nint fd;\r\nFILE_T ft;\r\n#ifdef HAVE_ZLIB\r\nconst char *suffixp;\r\n#endif\r\nif ((fd = ws_open(path, O_RDONLY|O_BINARY, 0000)) == -1)\r\nreturn NULL;\r\nft = file_fdopen(fd);\r\nif (ft == NULL) {\r\nws_close(fd);\r\nreturn NULL;\r\n}\r\n#ifdef HAVE_ZLIB\r\nsuffixp = strrchr(path, '.');\r\nif (suffixp != NULL) {\r\nif (g_ascii_strcasecmp(suffixp, ".caz") == 0)\r\nft->dont_check_crc = TRUE;\r\n}\r\n#endif\r\nreturn ft;\r\n}\r\nvoid\r\nfile_set_random_access(FILE_T stream, gboolean random_flag _U_, GPtrArray *seek)\r\n{\r\nstream->fast_seek = seek;\r\n}\r\ngint64\r\nfile_seek(FILE_T file, gint64 offset, int whence, int *err)\r\n{\r\nstruct fast_seek_point *here;\r\nguint n;\r\nif (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END) {\r\ng_assert_not_reached();\r\n}\r\nif (whence == SEEK_END) {\r\nif (gz_skip(file, G_MAXINT64) == -1) {\r\n*err = file->err;\r\nreturn -1;\r\n}\r\nif (offset == 0) {\r\nreturn file->pos;\r\n}\r\n} else if (whence == SEEK_SET)\r\noffset -= file->pos;\r\nelse if (file->seek_pending)\r\noffset += file->skip;\r\nfile->seek_pending = FALSE;\r\nif (offset < 0 && file->next) {\r\nguint had = (unsigned)(file->next - file->out);\r\nif (-offset <= had) {\r\nguint adjustment = (unsigned)(-offset);\r\nfile->have += adjustment;\r\nfile->next -= adjustment;\r\nfile->pos -= adjustment;\r\nreturn file->pos;\r\n}\r\n}\r\nif ((here = fast_seek_find(file, file->pos + offset)) && (offset < 0 || offset > SPAN || here->compression == UNCOMPRESSED)) {\r\ngint64 off, off2;\r\n#ifdef HAVE_ZLIB\r\nif (here->compression == ZLIB) {\r\n#ifdef HAVE_INFLATEPRIME\r\noff = here->in - (here->data.zlib.bits ? 1 : 0);\r\n#else\r\noff = here->in;\r\n#endif\r\noff2 = here->out;\r\n} else if (here->compression == GZIP_AFTER_HEADER) {\r\noff = here->in;\r\noff2 = here->out;\r\n} else\r\n#endif\r\n{\r\noff2 = (file->pos + offset);\r\noff = here->in + (off2 - here->out);\r\n}\r\nif (ws_lseek64(file->fd, off, SEEK_SET) == -1) {\r\n*err = errno;\r\nreturn -1;\r\n}\r\nfast_seek_reset(file);\r\nfile->raw_pos = off;\r\nfile->have = 0;\r\nfile->eof = FALSE;\r\nfile->seek_pending = FALSE;\r\nfile->err = 0;\r\nfile->err_info = NULL;\r\nfile->avail_in = 0;\r\n#ifdef HAVE_ZLIB\r\nif (here->compression == ZLIB) {\r\nz_stream *strm = &file->strm;\r\ninflateReset(strm);\r\nstrm->adler = here->data.zlib.adler;\r\nstrm->total_out = here->data.zlib.total_out;\r\n#ifdef HAVE_INFLATEPRIME\r\nif (here->data.zlib.bits) {\r\nFILE_T state = file;\r\nint ret = GZ_GETC();\r\nif (ret == -1) {\r\nif (state->err == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n} else\r\n*err = state->err;\r\nreturn -1;\r\n}\r\n(void)inflatePrime(strm, here->data.zlib.bits, ret >> (8 - here->data.zlib.bits));\r\n}\r\n#endif\r\n(void)inflateSetDictionary(strm, here->data.zlib.window, ZLIB_WINSIZE);\r\nfile->compression = ZLIB;\r\n} else if (here->compression == GZIP_AFTER_HEADER) {\r\nz_stream *strm = &file->strm;\r\ninflateReset(strm);\r\nstrm->adler = crc32(0L, Z_NULL, 0);\r\nfile->compression = ZLIB;\r\n} else\r\n#endif\r\nfile->compression = here->compression;\r\noffset = (file->pos + offset) - off2;\r\nfile->pos = off2;\r\nif (offset) {\r\nfile->seek_pending = TRUE;\r\nfile->skip = offset;\r\n}\r\nreturn file->pos + offset;\r\n}\r\nif (file->compression == UNCOMPRESSED && file->pos + offset >= file->raw\r\n&& (offset < 0 || offset >= file->have)\r\n&& (file->fast_seek))\r\n{\r\nif (ws_lseek64(file->fd, offset - file->have, SEEK_CUR) == -1) {\r\n*err = errno;\r\nreturn -1;\r\n}\r\nfile->raw_pos += (offset - file->have);\r\nfile->have = 0;\r\nfile->eof = FALSE;\r\nfile->seek_pending = FALSE;\r\nfile->err = 0;\r\nfile->err_info = NULL;\r\nfile->avail_in = 0;\r\nfile->pos += offset;\r\nreturn file->pos;\r\n}\r\nif (offset < 0) {\r\noffset += file->pos;\r\nif (offset < 0) {\r\n*err = EINVAL;\r\nreturn -1;\r\n}\r\nif (ws_lseek64(file->fd, file->start, SEEK_SET) == -1) {\r\n*err = errno;\r\nreturn -1;\r\n}\r\nfast_seek_reset(file);\r\nfile->raw_pos = file->start;\r\ngz_reset(file);\r\n}\r\nn = (gint64)file->have > offset ? (unsigned)offset : file->have;\r\nfile->have -= n;\r\nfile->next += n;\r\nfile->pos += n;\r\noffset -= n;\r\nif (offset) {\r\nfile->seek_pending = TRUE;\r\nfile->skip = offset;\r\n}\r\nreturn file->pos + offset;\r\n}\r\ngboolean\r\nfile_skip(FILE_T file, gint64 delta, int *err)\r\n{\r\nif (file_seek(file, delta, SEEK_CUR, err) == -1)\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\ngint64\r\nfile_tell(FILE_T stream)\r\n{\r\nreturn stream->pos + (stream->seek_pending ? stream->skip : 0);\r\n}\r\ngint64\r\nfile_tell_raw(FILE_T stream)\r\n{\r\nreturn stream->raw_pos;\r\n}\r\nint\r\nfile_fstat(FILE_T stream, ws_statb64 *statb, int *err)\r\n{\r\nif (ws_fstat64(stream->fd, statb) == -1) {\r\nif (err != NULL)\r\n*err = errno;\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\ngboolean\r\nfile_iscompressed(FILE_T stream)\r\n{\r\nreturn stream->is_compressed;\r\n}\r\nint\r\nfile_read(void *buf, unsigned int len, FILE_T file)\r\n{\r\nguint got, n;\r\nif (len == 0)\r\nreturn 0;\r\nif (file->seek_pending) {\r\nfile->seek_pending = FALSE;\r\nif (gz_skip(file, file->skip) == -1)\r\nreturn -1;\r\n}\r\ngot = 0;\r\ndo {\r\nif (file->have) {\r\nn = file->have > len ? len : file->have;\r\nmemcpy(buf, file->next, n);\r\nfile->next += n;\r\nfile->have -= n;\r\n} else if (file->err) {\r\nreturn -1;\r\n} else if (file->eof && file->avail_in == 0) {\r\nbreak;\r\n} else {\r\nif (fill_out_buffer(file) == -1)\r\nreturn -1;\r\ncontinue;\r\n}\r\nlen -= n;\r\nbuf = (char *)buf + n;\r\ngot += n;\r\nfile->pos += n;\r\n} while (len);\r\nreturn (int)got;\r\n}\r\nint\r\nfile_peekc(FILE_T file)\r\n{\r\nint ret = 0;\r\nif (file->err)\r\nreturn -1;\r\nif (file->have) {\r\nreturn *(file->next);\r\n}\r\nif (file->seek_pending) {\r\nfile->seek_pending = FALSE;\r\nif (gz_skip(file, file->skip) == -1)\r\nreturn -1;\r\n}\r\nwhile (1) {\r\nif (file->have) {\r\nreturn *(file->next);\r\n}\r\nelse if (file->err) {\r\nreturn -1;\r\n}\r\nelse if (file->eof && file->avail_in == 0) {\r\nreturn -1;\r\n}\r\nelse if (fill_out_buffer(file) == -1) {\r\nreturn -1;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint\r\nfile_getc(FILE_T file)\r\n{\r\nunsigned char buf[1];\r\nint ret;\r\nif (file->err)\r\nreturn -1;\r\nif (file->have) {\r\nfile->have--;\r\nfile->pos++;\r\nreturn *(file->next)++;\r\n}\r\nret = file_read(buf, 1, file);\r\nreturn ret < 1 ? -1 : buf[0];\r\n}\r\nchar *\r\nfile_gets(char *buf, int len, FILE_T file)\r\n{\r\nguint left, n;\r\nchar *str;\r\nunsigned char *eol;\r\nif (buf == NULL || len < 1)\r\nreturn NULL;\r\nif (file->err)\r\nreturn NULL;\r\nif (file->seek_pending) {\r\nfile->seek_pending = FALSE;\r\nif (gz_skip(file, file->skip) == -1)\r\nreturn NULL;\r\n}\r\nstr = buf;\r\nleft = (unsigned)len - 1;\r\nif (left) do {\r\nif (file->have == 0) {\r\nif (file->err) {\r\nreturn NULL;\r\n}\r\nif (fill_out_buffer(file) == -1)\r\nreturn NULL;\r\nif (file->have == 0) {\r\nif (buf == str)\r\nreturn NULL;\r\nbreak;\r\n}\r\n}\r\nn = file->have > left ? left : file->have;\r\neol = (unsigned char *)memchr(file->next, '\n', n);\r\nif (eol != NULL)\r\nn = (unsigned)(eol - file->next) + 1;\r\nmemcpy(buf, file->next, n);\r\nfile->have -= n;\r\nfile->next += n;\r\nfile->pos += n;\r\nleft -= n;\r\nbuf += n;\r\n} while (left && eol == NULL);\r\nbuf[0] = 0;\r\nreturn str;\r\n}\r\nint\r\nfile_eof(FILE_T file)\r\n{\r\nreturn (file->eof && file->avail_in == 0 && file->have == 0);\r\n}\r\nint\r\nfile_error(FILE_T fh, gchar **err_info)\r\n{\r\nif (fh->err!=0 && err_info) {\r\n*err_info = g_strdup(fh->err_info);\r\n}\r\nreturn fh->err;\r\n}\r\nvoid\r\nfile_clearerr(FILE_T stream)\r\n{\r\nstream->err = 0;\r\nstream->err_info = NULL;\r\nstream->eof = FALSE;\r\n}\r\nvoid\r\nfile_fdclose(FILE_T file)\r\n{\r\nws_close(file->fd);\r\nfile->fd = -1;\r\n}\r\ngboolean\r\nfile_fdreopen(FILE_T file, const char *path)\r\n{\r\nint fd;\r\nif ((fd = ws_open(path, O_RDONLY|O_BINARY, 0000)) == -1)\r\nreturn FALSE;\r\nfile->fd = fd;\r\nreturn TRUE;\r\n}\r\nvoid\r\nfile_close(FILE_T file)\r\n{\r\nint fd = file->fd;\r\nif (file->size) {\r\n#ifdef HAVE_ZLIB\r\ninflateEnd(&(file->strm));\r\n#endif\r\ng_free(file->out);\r\ng_free(file->in);\r\n}\r\ng_free(file->fast_seek_cur);\r\nfile->err = 0;\r\nfile->err_info = NULL;\r\ng_free(file);\r\nif (fd != -1)\r\nws_close(fd);\r\n}\r\nGZWFILE_T\r\ngzwfile_open(const char *path)\r\n{\r\nint fd;\r\nGZWFILE_T state;\r\nint save_errno;\r\nfd = ws_open(path, O_BINARY|O_WRONLY|O_CREAT|O_TRUNC, 0666);\r\nif (fd == -1)\r\nreturn NULL;\r\nstate = gzwfile_fdopen(fd);\r\nif (state == NULL) {\r\nsave_errno = errno;\r\nws_close(fd);\r\nerrno = save_errno;\r\n}\r\nreturn state;\r\n}\r\nGZWFILE_T\r\ngzwfile_fdopen(int fd)\r\n{\r\nGZWFILE_T state;\r\nstate = (GZWFILE_T)g_try_malloc(sizeof *state);\r\nif (state == NULL)\r\nreturn NULL;\r\nstate->fd = fd;\r\nstate->size = 0;\r\nstate->want = GZBUFSIZE;\r\nstate->level = Z_DEFAULT_COMPRESSION;\r\nstate->strategy = Z_DEFAULT_STRATEGY;\r\nstate->err = Z_OK;\r\nstate->pos = 0;\r\nstate->strm.avail_in = 0;\r\nreturn state;\r\n}\r\nstatic int\r\ngz_init(GZWFILE_T state)\r\n{\r\nint ret;\r\nz_streamp strm = &(state->strm);\r\nstate->in = (unsigned char *)g_try_malloc(state->want);\r\nstate->out = (unsigned char *)g_try_malloc(state->want);\r\nif (state->in == NULL || state->out == NULL) {\r\ng_free(state->out);\r\ng_free(state->in);\r\nstate->err = ENOMEM;\r\nreturn -1;\r\n}\r\nstrm->zalloc = Z_NULL;\r\nstrm->zfree = Z_NULL;\r\nstrm->opaque = Z_NULL;\r\nret = deflateInit2(strm, state->level, Z_DEFLATED,\r\n15 + 16, 8, state->strategy);\r\nif (ret != Z_OK) {\r\ng_free(state->out);\r\ng_free(state->in);\r\nif (ret == Z_MEM_ERROR) {\r\nstate->err = ENOMEM;\r\n} else {\r\nstate->err = WTAP_ERR_INTERNAL;\r\n}\r\nreturn -1;\r\n}\r\nstate->size = state->want;\r\nstrm->avail_out = state->size;\r\nstrm->next_out = state->out;\r\nstate->next = strm->next_out;\r\nreturn 0;\r\n}\r\nstatic int\r\ngz_comp(GZWFILE_T state, int flush)\r\n{\r\nint ret;\r\nssize_t got;\r\nptrdiff_t have;\r\nz_streamp strm = &(state->strm);\r\nif (state->size == 0 && gz_init(state) == -1)\r\nreturn -1;\r\nret = Z_OK;\r\ndo {\r\nif (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&\r\n(flush != Z_FINISH || ret == Z_STREAM_END))) {\r\nhave = strm->next_out - state->next;\r\nif (have) {\r\ngot = ws_write(state->fd, state->next, (unsigned int)have);\r\nif (got < 0) {\r\nstate->err = errno;\r\nreturn -1;\r\n}\r\nif ((ptrdiff_t)got != have) {\r\nstate->err = WTAP_ERR_SHORT_WRITE;\r\nreturn -1;\r\n}\r\n}\r\nif (strm->avail_out == 0) {\r\nstrm->avail_out = state->size;\r\nstrm->next_out = state->out;\r\n}\r\nstate->next = strm->next_out;\r\n}\r\nhave = strm->avail_out;\r\nret = deflate(strm, flush);\r\nif (ret == Z_STREAM_ERROR) {\r\nstate->err = WTAP_ERR_INTERNAL;\r\nreturn -1;\r\n}\r\nhave -= strm->avail_out;\r\n} while (have);\r\nif (flush == Z_FINISH)\r\ndeflateReset(strm);\r\nreturn 0;\r\n}\r\nunsigned\r\ngzwfile_write(GZWFILE_T state, const void *buf, guint len)\r\n{\r\nguint put = len;\r\nguint n;\r\nz_streamp strm;\r\nstrm = &(state->strm);\r\nif (state->err != Z_OK)\r\nreturn 0;\r\nif (len == 0)\r\nreturn 0;\r\nif (state->size == 0 && gz_init(state) == -1)\r\nreturn 0;\r\nif (len < state->size) {\r\ndo {\r\nif (strm->avail_in == 0)\r\nstrm->next_in = state->in;\r\nn = state->size - strm->avail_in;\r\nif (n > len)\r\nn = len;\r\n#ifdef z_const\r\nDIAG_OFF(cast-qual)\r\nmemcpy((Bytef *)strm->next_in + strm->avail_in, buf, n);\r\nDIAG_ON(cast-qual)\r\n#else\r\nmemcpy(strm->next_in + strm->avail_in, buf, n);\r\n#endif\r\nstrm->avail_in += n;\r\nstate->pos += n;\r\nbuf = (const char *)buf + n;\r\nlen -= n;\r\nif (len && gz_comp(state, Z_NO_FLUSH) == -1)\r\nreturn 0;\r\n} while (len);\r\n}\r\nelse {\r\nif (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)\r\nreturn 0;\r\nstrm->avail_in = len;\r\n#ifdef z_const\r\nstrm->next_in = (z_const Bytef *)buf;\r\n#else\r\nDIAG_OFF(cast-qual)\r\nstrm->next_in = (Bytef *)buf;\r\nDIAG_ON(cast-qual)\r\n#endif\r\nstate->pos += len;\r\nif (gz_comp(state, Z_NO_FLUSH) == -1)\r\nreturn 0;\r\n}\r\nreturn (int)put;\r\n}\r\nint\r\ngzwfile_flush(GZWFILE_T state)\r\n{\r\nif (state->err != Z_OK)\r\nreturn -1;\r\ngz_comp(state, Z_SYNC_FLUSH);\r\nif (state->err != Z_OK)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint\r\ngzwfile_close(GZWFILE_T state, gboolean is_stdout)\r\n{\r\nint ret = 0;\r\nif (gz_comp(state, Z_FINISH) == -1 && ret == 0)\r\nret = state->err;\r\n(void)deflateEnd(&(state->strm));\r\ng_free(state->out);\r\ng_free(state->in);\r\nstate->err = Z_OK;\r\nif (!is_stdout) {\r\nif (ws_close(state->fd) == -1 && ret == 0)\r\nret = errno;\r\n}\r\ng_free(state);\r\nreturn ret;\r\n}\r\nint\r\ngzwfile_geterr(GZWFILE_T state)\r\n{\r\nreturn state->err;\r\n}
