wtap_open_return_val\r\ncatapult_dct2000_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\ngint64 offset = 0;\r\ntime_t timestamp;\r\nguint32 usecs;\r\ngint firstline_length = 0;\r\ndct2000_file_externals_t *file_externals;\r\nstatic gchar linebuff[MAX_LINE_LENGTH];\r\nstatic gboolean hex_byte_table_values_set = FALSE;\r\nerrno = 0;\r\nif (!read_new_line(wth->fh, &offset, &firstline_length, linebuff,\r\nsizeof linebuff, err, err_info)) {\r\nif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (((size_t)firstline_length < strlen(catapult_dct2000_magic)) ||\r\nfirstline_length >= MAX_FIRST_LINE_LENGTH) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (memcmp(catapult_dct2000_magic, linebuff, strlen(catapult_dct2000_magic)) != 0) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (!hex_byte_table_values_set) {\r\nprepare_hex_byte_from_chars_table();\r\nhex_byte_table_values_set = TRUE;\r\n}\r\nfile_externals = g_new(dct2000_file_externals_t,1);\r\nmemset((void*)file_externals, '\0', sizeof(dct2000_file_externals_t));\r\ng_strlcpy(file_externals->firstline, linebuff, firstline_length+1);\r\nfile_externals->firstline_length = firstline_length;\r\nif (!read_new_line(wth->fh, &offset, &(file_externals->secondline_length),\r\nlinebuff, sizeof linebuff, err, err_info)) {\r\ng_free(file_externals);\r\nif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif ((file_externals->secondline_length >= MAX_TIMESTAMP_LINE_LENGTH) ||\r\n(!get_file_time_stamp(linebuff, &timestamp, &usecs))) {\r\ng_free(file_externals);\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nfile_externals->start_secs = timestamp;\r\nfile_externals->start_usecs = usecs;\r\ng_strlcpy(file_externals->secondline, linebuff, file_externals->secondline_length+1);\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_CATAPULT_DCT2000;\r\nwth->file_encap = WTAP_ENCAP_CATAPULT_DCT2000;\r\nwth->subtype_read = catapult_dct2000_read;\r\nwth->subtype_seek_read = catapult_dct2000_seek_read;\r\nwth->subtype_close = catapult_dct2000_close;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nfile_externals->packet_prefix_table =\r\ng_hash_table_new(packet_offset_hash_func, packet_offset_equal);\r\nwth->priv = (void*)file_externals;\r\n*err = errno;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic void write_timestamp_string(char *timestamp_string, int secs, int tenthousandths)\r\n{\r\nint idx = 0;\r\nif (secs < 10) {\r\ntimestamp_string[idx++] = ((secs % 10)) + '0';\r\n}\r\nelse if (secs < 100) {\r\ntimestamp_string[idx++] = ( secs / 10) + '0';\r\ntimestamp_string[idx++] = ((secs % 10)) + '0';\r\n}\r\nelse if (secs < 1000) {\r\ntimestamp_string[idx++] = ((secs) / 100) + '0';\r\ntimestamp_string[idx++] = ((secs % 100)) / 10 + '0';\r\ntimestamp_string[idx++] = ((secs % 10)) + '0';\r\n}\r\nelse if (secs < 10000) {\r\ntimestamp_string[idx++] = ((secs) / 1000) + '0';\r\ntimestamp_string[idx++] = ((secs % 1000)) / 100 + '0';\r\ntimestamp_string[idx++] = ((secs % 100)) / 10 + '0';\r\ntimestamp_string[idx++] = ((secs % 10)) + '0';\r\n}\r\nelse if (secs < 100000) {\r\ntimestamp_string[idx++] = ((secs) / 10000) + '0';\r\ntimestamp_string[idx++] = ((secs % 10000)) / 1000 + '0';\r\ntimestamp_string[idx++] = ((secs % 1000)) / 100 + '0';\r\ntimestamp_string[idx++] = ((secs % 100)) / 10 + '0';\r\ntimestamp_string[idx++] = ((secs % 10)) + '0';\r\n}\r\nelse if (secs < 1000000) {\r\ntimestamp_string[idx++] = ((secs) / 100000) + '0';\r\ntimestamp_string[idx++] = ((secs % 100000)) / 10000 + '0';\r\ntimestamp_string[idx++] = ((secs % 10000)) / 1000 + '0';\r\ntimestamp_string[idx++] = ((secs % 1000)) / 100 + '0';\r\ntimestamp_string[idx++] = ((secs % 100)) / 10 + '0';\r\ntimestamp_string[idx++] = ((secs % 10)) + '0';\r\n}\r\nelse {\r\ng_snprintf(timestamp_string, MAX_TIMESTAMP_LEN, "%d.%04d", secs, tenthousandths);\r\nreturn;\r\n}\r\ntimestamp_string[idx++] = '.';\r\ntimestamp_string[idx++] = ( tenthousandths / 1000) + '0';\r\ntimestamp_string[idx++] = ((tenthousandths % 1000) / 100) + '0';\r\ntimestamp_string[idx++] = ((tenthousandths % 100) / 10) + '0';\r\ntimestamp_string[idx++] = ((tenthousandths % 10)) + '0';\r\ntimestamp_string[idx++] = '\0';\r\n}\r\nstatic gboolean\r\ncatapult_dct2000_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\ngint64 offset = file_tell(wth->fh);\r\nlong dollar_offset, before_time_offset, after_time_offset;\r\npacket_direction_t direction;\r\nint encap;\r\ndct2000_file_externals_t *file_externals =\r\n(dct2000_file_externals_t*)wth->priv;\r\nwhile (1) {\r\nint line_length, seconds, useconds, data_chars;\r\nint is_comment = FALSE;\r\nint is_sprint = FALSE;\r\ngint64 this_offset = offset;\r\nstatic gchar linebuff[MAX_LINE_LENGTH+1];\r\ngchar aal_header_chars[AAL_HEADER_CHARS];\r\ngchar context_name[MAX_CONTEXT_NAME];\r\nguint8 context_port = 0;\r\ngchar protocol_name[MAX_PROTOCOL_NAME+1];\r\ngchar variant_name[MAX_VARIANT_DIGITS+1];\r\ngchar outhdr_name[MAX_OUTHDR_NAME+1];\r\nif (file_tell(wth->fh) == 0) {\r\nthis_offset += (file_externals->firstline_length+1+\r\nfile_externals->secondline_length+1);\r\n}\r\nif (!read_new_line(wth->fh, &offset, &line_length, linebuff,\r\nsizeof linebuff, err, err_info)) {\r\nif (*err != 0)\r\nreturn FALSE;\r\nbreak;\r\n}\r\nif (parse_line(linebuff, line_length, &seconds, &useconds,\r\n&before_time_offset, &after_time_offset,\r\n&dollar_offset,\r\n&data_chars, &direction, &encap, &is_comment, &is_sprint,\r\naal_header_chars,\r\ncontext_name, &context_port,\r\nprotocol_name, variant_name, outhdr_name)) {\r\nline_prefix_info_t *line_prefix_info;\r\nchar timestamp_string[MAX_TIMESTAMP_LEN+1];\r\ngint64 *pkey = NULL;\r\nwrite_timestamp_string(timestamp_string, seconds, useconds/100);\r\n*data_offset = this_offset;\r\nif (!process_parsed_line(wth, file_externals,\r\n&wth->phdr,\r\nwth->frame_buffer, this_offset,\r\nlinebuff, dollar_offset,\r\nseconds, useconds,\r\ntimestamp_string,\r\ndirection, encap,\r\ncontext_name, context_port,\r\nprotocol_name, variant_name,\r\nouthdr_name, aal_header_chars,\r\nis_comment, data_chars,\r\nerr, err_info))\r\nreturn FALSE;\r\nline_prefix_info = g_new(line_prefix_info_t,1);\r\nline_prefix_info->before_time = (gchar *)g_malloc(before_time_offset+1);\r\nmemcpy(line_prefix_info->before_time, linebuff, before_time_offset);\r\nline_prefix_info->before_time[before_time_offset] = '\0';\r\nif (((size_t)(dollar_offset - after_time_offset -1) == strlen(" l ")) &&\r\n(strncmp(linebuff+after_time_offset, " l ", strlen(" l ")) == 0)) {\r\nline_prefix_info->after_time = NULL;\r\n}\r\nelse {\r\nline_prefix_info->after_time = (gchar *)g_malloc(dollar_offset - after_time_offset);\r\nmemcpy(line_prefix_info->after_time, linebuff+after_time_offset, dollar_offset - after_time_offset);\r\nline_prefix_info->after_time[dollar_offset - after_time_offset-1] = '\0';\r\n}\r\npkey = (gint64 *)g_malloc(sizeof(*pkey));\r\n*pkey = this_offset;\r\ng_hash_table_insert(file_externals->packet_prefix_table, pkey, line_prefix_info);\r\nreturn TRUE;\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\ncatapult_dct2000_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf,\r\nint *err, gchar **err_info)\r\n{\r\ngint64 offset = 0;\r\nint length;\r\nlong dollar_offset, before_time_offset, after_time_offset;\r\nstatic gchar linebuff[MAX_LINE_LENGTH+1];\r\ngchar aal_header_chars[AAL_HEADER_CHARS];\r\ngchar context_name[MAX_CONTEXT_NAME];\r\nguint8 context_port = 0;\r\ngchar protocol_name[MAX_PROTOCOL_NAME+1];\r\ngchar variant_name[MAX_VARIANT_DIGITS+1];\r\ngchar outhdr_name[MAX_OUTHDR_NAME+1];\r\nint is_comment = FALSE;\r\nint is_sprint = FALSE;\r\npacket_direction_t direction;\r\nint encap;\r\nint seconds, useconds, data_chars;\r\ndct2000_file_externals_t *file_externals =\r\n(dct2000_file_externals_t*)wth->priv;\r\n*err = errno = 0;\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\r\nreturn FALSE;\r\n}\r\nif (!read_new_line(wth->random_fh, &offset, &length, linebuff,\r\nsizeof linebuff, err, err_info)) {\r\nreturn FALSE;\r\n}\r\nif (parse_line(linebuff, length, &seconds, &useconds,\r\n&before_time_offset, &after_time_offset,\r\n&dollar_offset,\r\n&data_chars, &direction, &encap, &is_comment, &is_sprint,\r\naal_header_chars,\r\ncontext_name, &context_port,\r\nprotocol_name, variant_name, outhdr_name)) {\r\nchar timestamp_string[MAX_TIMESTAMP_LEN+1];\r\nwrite_timestamp_string(timestamp_string, seconds, useconds/100);\r\nif (!process_parsed_line(wth, file_externals,\r\nphdr, buf, seek_off,\r\nlinebuff, dollar_offset,\r\nseconds, useconds,\r\ntimestamp_string,\r\ndirection, encap,\r\ncontext_name, context_port,\r\nprotocol_name, variant_name,\r\nouthdr_name, aal_header_chars,\r\nis_comment, data_chars,\r\nerr, err_info))\r\nreturn FALSE;\r\n*err = errno = 0;\r\nreturn TRUE;\r\n}\r\n*err = errno;\r\n*err_info = g_strdup_printf("catapult dct2000: seek_read failed to read/parse "\r\n"line at position %" G_GINT64_MODIFIER "d",\r\nseek_off);\r\nreturn FALSE;\r\n}\r\nstatic void\r\ncatapult_dct2000_close(wtap *wth)\r\n{\r\ndct2000_file_externals_t *file_externals =\r\n(dct2000_file_externals_t*)wth->priv;\r\ng_hash_table_foreach_remove(file_externals->packet_prefix_table,\r\nfree_line_prefix_info, NULL);\r\ng_hash_table_destroy(file_externals->packet_prefix_table);\r\n}\r\ngboolean\r\ncatapult_dct2000_dump_open(wtap_dumper *wdh, int *err _U_)\r\n{\r\nwdh->subtype_write = catapult_dct2000_dump;\r\nreturn TRUE;\r\n}\r\nint\r\ncatapult_dct2000_dump_can_write_encap(int encap)\r\n{\r\nswitch (encap) {\r\ncase WTAP_ENCAP_CATAPULT_DCT2000:\r\nreturn 0;\r\ndefault:\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\n}\r\n}\r\nstatic gboolean\r\ncatapult_dct2000_dump(wtap_dumper *wdh, const struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info _U_)\r\n{\r\nconst union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nguint32 n;\r\nline_prefix_info_t *prefix = NULL;\r\ngchar time_string[16];\r\ngboolean is_comment;\r\ngboolean is_sprint = FALSE;\r\ndct2000_dump_t *dct2000;\r\nint consecutive_slashes=0;\r\nchar *p_c;\r\ndct2000_file_externals_t *file_externals =\r\n(dct2000_file_externals_t*)pseudo_header->dct2000.wth->priv;\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\ndct2000 = (dct2000_dump_t *)wdh->priv;\r\nif (dct2000 == NULL) {\r\nif (!wtap_dump_file_write(wdh, file_externals->firstline,\r\nfile_externals->firstline_length, err)) {\r\nreturn FALSE;\r\n}\r\nif (!wtap_dump_file_write(wdh, "\n", 1, err)) {\r\nreturn FALSE;\r\n}\r\nif (!wtap_dump_file_write(wdh, file_externals->secondline,\r\nfile_externals->secondline_length, err)) {\r\nreturn FALSE;\r\n}\r\nif (!wtap_dump_file_write(wdh, "\n", 1, err)) {\r\nreturn FALSE;\r\n}\r\ndct2000 = (dct2000_dump_t *)g_malloc(sizeof(dct2000_dump_t));\r\nwdh->priv = (void *)dct2000;\r\ndct2000->start_time.secs = file_externals->start_secs;\r\ndct2000->start_time.nsecs =\r\n(file_externals->start_usecs * 1000);\r\ndct2000->first_packet_written = TRUE;\r\n}\r\nprefix = (line_prefix_info_t*)g_hash_table_lookup(file_externals->packet_prefix_table,\r\n(const void*)&(pseudo_header->dct2000.seek_off));\r\nif (!wtap_dump_file_write(wdh, prefix->before_time,\r\nstrlen(prefix->before_time), err)) {\r\nreturn FALSE;\r\n}\r\np_c = prefix->before_time;\r\nwhile (p_c && (*p_c != '/')) {\r\np_c++;\r\n}\r\nwhile (p_c && (*p_c == '/')) {\r\nconsecutive_slashes++;\r\np_c++;\r\n}\r\nis_comment = (consecutive_slashes == 5);\r\nif (phdr->ts.nsecs >= dct2000->start_time.nsecs) {\r\nwrite_timestamp_string(time_string,\r\n(int)(phdr->ts.secs - dct2000->start_time.secs),\r\n(phdr->ts.nsecs - dct2000->start_time.nsecs) / 100000);\r\n}\r\nelse {\r\nwrite_timestamp_string(time_string,\r\n(int)(phdr->ts.secs - dct2000->start_time.secs-1),\r\n((1000000000 + (phdr->ts.nsecs / 100000)) - (dct2000->start_time.nsecs / 100000)) % 10000);\r\n}\r\nif (!wtap_dump_file_write(wdh, time_string, strlen(time_string), err)) {\r\nreturn FALSE;\r\n}\r\nif (prefix->after_time == NULL) {\r\nif (!wtap_dump_file_write(wdh, " l ", strlen(" l "), err)) {\r\nreturn FALSE;\r\n}\r\n}\r\nelse {\r\nif (!wtap_dump_file_write(wdh, prefix->after_time,\r\nstrlen(prefix->after_time), err)) {\r\nreturn FALSE;\r\n}\r\n}\r\nfor (n=0; pd[n] != '\0'; n++);\r\nn++;\r\nn++;\r\nfor (; pd[n] != '\0'; n++);\r\nn++;\r\nif (is_comment) {\r\nis_sprint = (strcmp((const char *)pd+n, "sprint") == 0);\r\n}\r\nfor (; pd[n] != '\0'; n++);\r\nn++;\r\nfor (; pd[n] != '\0'; n++);\r\nn++;\r\nfor (; pd[n] != '\0'; n++);\r\nn++;\r\nn += 2;\r\nif (!wtap_dump_file_write(wdh, is_sprint ? " " : "$", 1, err)) {\r\nreturn FALSE;\r\n}\r\nif (!is_comment) {\r\nfor (; n < phdr->len; n++) {\r\ngchar c[2];\r\nc[0] = char_from_hex((guint8)(pd[n] >> 4));\r\nc[1] = char_from_hex((guint8)(pd[n] & 0x0f));\r\nif (!wtap_dump_file_write(wdh, c, 2, err)) {\r\nreturn FALSE;\r\n}\r\n}\r\n}\r\nelse {\r\nfor (; n < phdr->len; n++) {\r\nchar c[1];\r\nc[0] = pd[n];\r\nif (!wtap_dump_file_write(wdh, c, 1, err)) {\r\nreturn FALSE;\r\n}\r\n}\r\n}\r\nif (!wtap_dump_file_write(wdh, "\n", 1, err)) {\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nread_new_line(FILE_T fh, gint64 *offset, gint *length,\r\ngchar *linebuff, size_t linebuffsize, int *err, gchar **err_info)\r\n{\r\ngint64 pos_before = file_tell(fh);\r\nif (file_gets(linebuff, (int)linebuffsize - 1, fh) == NULL) {\r\n*err = file_error(fh, err_info);\r\nreturn FALSE;\r\n}\r\n*length = (gint)(file_tell(fh) - pos_before);\r\n*offset = *offset + *length;\r\nif (*length > 0 && linebuff[*length-1] == '\n') {\r\nlinebuff[*length-1] = '\0';\r\n*length = *length - 1;\r\n}\r\nif (*length > 0 && linebuff[*length-1] == '\r') {\r\nlinebuff[*length-1] = '\0';\r\n*length = *length - 1;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nparse_line(gchar *linebuff, gint line_length,\r\ngint *seconds, gint *useconds,\r\nlong *before_time_offset, long *after_time_offset,\r\nlong *data_offset, gint *data_chars,\r\npacket_direction_t *direction,\r\nint *encap, int *is_comment, int *is_sprint,\r\ngchar *aal_header_chars,\r\ngchar *context_name, guint8 *context_portp,\r\ngchar *protocol_name, gchar *variant_name,\r\ngchar *outhdr_name)\r\n{\r\nint n = 0;\r\nint port_digits;\r\nchar port_number_string[MAX_PORT_DIGITS+1];\r\nint variant_digits = 0;\r\nint variant = 1;\r\nint protocol_chars = 0;\r\nint outhdr_chars = 0;\r\nchar seconds_buff[MAX_SECONDS_CHARS+1];\r\nint seconds_chars;\r\nchar subsecond_decimals_buff[MAX_SUBSECOND_DECIMALS+1];\r\nint subsecond_decimals_chars;\r\nint skip_first_byte = FALSE;\r\ngboolean atm_header_present = FALSE;\r\n*is_comment = FALSE;\r\n*is_sprint = FALSE;\r\nfor (n=0; (n < MAX_CONTEXT_NAME) && (n+1 < line_length) && (linebuff[n] != '.'); n++) {\r\nif (linebuff[n] == '/') {\r\ncontext_name[n] = '\0';\r\nif (strncmp(linebuff+n, "/////", 5) != 0) {\r\nreturn FALSE;\r\n}\r\ng_strlcpy(protocol_name, "comment", MAX_PROTOCOL_NAME);\r\n*is_comment = TRUE;\r\nbreak;\r\n}\r\nif (!g_ascii_isalnum(linebuff[n]) && (linebuff[n] != '_') && (linebuff[n] != '-')) {\r\nreturn FALSE;\r\n}\r\ncontext_name[n] = linebuff[n];\r\n}\r\nif (n == MAX_CONTEXT_NAME || (n+1 >= line_length)) {\r\nreturn FALSE;\r\n}\r\nvariant_name[0] = '\0';\r\nouthdr_name[0] = '\0';\r\nport_number_string[0] = '\0';\r\nif (!(*is_comment)) {\r\nif (linebuff[n] != '.') {\r\nreturn FALSE;\r\n}\r\ncontext_name[n] = '\0';\r\nn++;\r\nfor (port_digits = 0;\r\n(linebuff[n] != '/') && (port_digits <= MAX_PORT_DIGITS) && (n+1 < line_length);\r\nn++, port_digits++) {\r\nif (!g_ascii_isdigit(linebuff[n])) {\r\nreturn FALSE;\r\n}\r\nport_number_string[port_digits] = linebuff[n];\r\n}\r\nif (port_digits > MAX_PORT_DIGITS || (n+1 >= line_length)) {\r\nreturn FALSE;\r\n}\r\nif (linebuff[n] != '/')\r\n{\r\nreturn FALSE;\r\n}\r\nport_number_string[port_digits] = '\0';\r\nif (port_digits == 1) {\r\n*context_portp = port_number_string[0] - '0';\r\n}\r\nelse {\r\n*context_portp = atoi(port_number_string);\r\n}\r\nn++;\r\nfor (protocol_chars = 0;\r\n(linebuff[n] != '/') && (protocol_chars < MAX_PROTOCOL_NAME) && (n < line_length);\r\nn++, protocol_chars++) {\r\nif (!g_ascii_isalnum(linebuff[n]) && linebuff[n] != '_') {\r\nreturn FALSE;\r\n}\r\nprotocol_name[protocol_chars] = linebuff[n];\r\n}\r\nif (protocol_chars == MAX_PROTOCOL_NAME || n >= line_length) {\r\nreturn FALSE;\r\n}\r\nprotocol_name[protocol_chars] = '\0';\r\nif (linebuff[n] != '/') {\r\nreturn FALSE;\r\n}\r\nn++;\r\nfor (variant_digits = 0;\r\n(g_ascii_isdigit(linebuff[n])) && (variant_digits <= MAX_VARIANT_DIGITS) && (n+1 < line_length);\r\nn++, variant_digits++) {\r\nif (!g_ascii_isdigit(linebuff[n])) {\r\nreturn FALSE;\r\n}\r\nvariant_name[variant_digits] = linebuff[n];\r\n}\r\nif (variant_digits > MAX_VARIANT_DIGITS || (n+1 >= line_length)) {\r\nreturn FALSE;\r\n}\r\nif (variant_digits > 0) {\r\nvariant_name[variant_digits] = '\0';\r\nif (variant_digits == 1) {\r\nvariant = variant_name[0] - '0';\r\n}\r\nelse {\r\nvariant = atoi(variant_name);\r\n}\r\n}\r\nelse {\r\nvariant_name[0] = '1';\r\nvariant_name[1] = '\0';\r\n}\r\nouthdr_name[0] = '\0';\r\nif (linebuff[n] == ',') {\r\nn++;\r\nfor (outhdr_chars = 0;\r\n(g_ascii_isdigit(linebuff[n]) || linebuff[n] == ',') &&\r\n(outhdr_chars <= MAX_OUTHDR_NAME) && (n+1 < line_length);\r\nn++, outhdr_chars++) {\r\nif (!g_ascii_isdigit(linebuff[n]) && (linebuff[n] != ',')) {\r\nreturn FALSE;\r\n}\r\nouthdr_name[outhdr_chars] = linebuff[n];\r\n}\r\nif (outhdr_chars > MAX_OUTHDR_NAME || (n+1 >= line_length)) {\r\nreturn FALSE;\r\n}\r\nouthdr_name[outhdr_chars] = '\0';\r\n}\r\n}\r\nif ((strcmp(protocol_name, "ip") == 0) ||\r\n(strcmp(protocol_name, "sctp") == 0) ||\r\n(strcmp(protocol_name, "gre") == 0) ||\r\n(strcmp(protocol_name, "mipv6") == 0) ||\r\n(strcmp(protocol_name, "igmp") == 0)) {\r\n*encap = WTAP_ENCAP_RAW_IP;\r\n}\r\nelse\r\nif ((strcmp(protocol_name, "fp") == 0) ||\r\n(strncmp(protocol_name, "fp_r", 4) == 0)) {\r\nif ((variant > 256) && (variant % 256 == 3)) {\r\n*encap = 0;\r\n}\r\nelse {\r\n*encap = WTAP_ENCAP_ATM_PDUS_UNTRUNCATED;\r\natm_header_present = TRUE;\r\n}\r\n}\r\nelse if (strcmp(protocol_name, "fpiur_r5") == 0) {\r\n*encap = WTAP_ENCAP_ATM_PDUS_UNTRUNCATED;\r\natm_header_present = TRUE;\r\n}\r\nelse\r\nif (strcmp(protocol_name, "ppp") == 0) {\r\n*encap = WTAP_ENCAP_PPP;\r\n}\r\nelse\r\nif (strcmp(protocol_name, "isdn_l3") == 0) {\r\nskip_first_byte = TRUE;\r\n*encap = WTAP_ENCAP_ISDN;\r\n}\r\nelse\r\nif (strcmp(protocol_name, "isdn_l2") == 0) {\r\n*encap = WTAP_ENCAP_ISDN;\r\n}\r\nelse\r\nif (strcmp(protocol_name, "ethernet") == 0) {\r\n*encap = WTAP_ENCAP_ETHERNET;\r\n}\r\nelse\r\nif ((strcmp(protocol_name, "saalnni_sscop") == 0) ||\r\n(strcmp(protocol_name, "saaluni_sscop") == 0)) {\r\n*encap = DCT2000_ENCAP_SSCOP;\r\n}\r\nelse\r\nif (strcmp(protocol_name, "frelay_l2") == 0) {\r\n*encap = WTAP_ENCAP_FRELAY;\r\n}\r\nelse\r\nif (strcmp(protocol_name, "ss7_mtp2") == 0) {\r\n*encap = DCT2000_ENCAP_MTP2;\r\n}\r\nelse\r\nif ((strcmp(protocol_name, "nbap") == 0) ||\r\n(strcmp(protocol_name, "nbap_r4") == 0) ||\r\n(strncmp(protocol_name, "nbap_sscfuni", strlen("nbap_sscfuni")) == 0)) {\r\n*encap = DCT2000_ENCAP_NBAP;\r\n}\r\nelse {\r\n*encap = DCT2000_ENCAP_UNHANDLED;\r\n}\r\nif (atm_header_present) {\r\nint header_chars_seen = 0;\r\nfor (; (linebuff[n] != '$') && (n+1 < line_length); n++);\r\nn++;\r\nif (n+1 >= line_length) {\r\nreturn FALSE;\r\n}\r\nfor (;\r\n((n < line_length) &&\r\n(linebuff[n] >= '0') && (linebuff[n] <= '?') &&\r\n(header_chars_seen < AAL_HEADER_CHARS));\r\nn++, header_chars_seen++) {\r\naal_header_chars[header_chars_seen] = linebuff[n];\r\nif (!g_ascii_isdigit(linebuff[n])) {\r\naal_header_chars[header_chars_seen] = 'a' + (linebuff[n] - '9') -1;\r\n}\r\n}\r\nif (header_chars_seen != AAL_HEADER_CHARS || n >= line_length) {\r\nreturn FALSE;\r\n}\r\n}\r\nn++;\r\nif (g_ascii_isdigit(linebuff[n])) {\r\nwhile ((n+1 < line_length) && linebuff[n] != '/') {\r\nn++;\r\n}\r\n}\r\nwhile ((n+1 < line_length) && linebuff[n] == '/') {\r\nn++;\r\n}\r\nif ((n+1 < line_length) && linebuff[n] == ' ') {\r\nn++;\r\n}\r\nif (!(*is_comment)) {\r\nif (linebuff[n] == 's') {\r\n*direction = sent;\r\n}\r\nelse\r\nif (linebuff[n] == 'r') {\r\n*direction = received;\r\n}\r\nelse {\r\nreturn FALSE;\r\n}\r\nn++;\r\n}\r\nelse {\r\n*direction = sent;\r\n}\r\nfor (; ((linebuff[n] != 't') || (linebuff[n+1] != 'm')) && (n+1 < line_length); n++);\r\nif (n >= line_length) {\r\nreturn FALSE;\r\n}\r\nfor (; (n < line_length) && !g_ascii_isdigit(linebuff[n]); n++);\r\nif (n >= line_length) {\r\nreturn FALSE;\r\n}\r\n*before_time_offset = n;\r\nfor (seconds_chars = 0;\r\n(linebuff[n] != '.') &&\r\n(seconds_chars <= MAX_SECONDS_CHARS) &&\r\n(n < line_length);\r\nn++, seconds_chars++) {\r\nif (!g_ascii_isdigit(linebuff[n])) {\r\nreturn FALSE;\r\n}\r\nseconds_buff[seconds_chars] = linebuff[n];\r\n}\r\nif (seconds_chars > MAX_SECONDS_CHARS || n >= line_length) {\r\nreturn FALSE;\r\n}\r\nseconds_buff[seconds_chars] = '\0';\r\n*seconds = atoi(seconds_buff);\r\nif (linebuff[n] != '.') {\r\nreturn FALSE;\r\n}\r\nn++;\r\nfor (subsecond_decimals_chars = 0;\r\n(linebuff[n] != ' ') &&\r\n(subsecond_decimals_chars <= MAX_SUBSECOND_DECIMALS) &&\r\n(n < line_length);\r\nn++, subsecond_decimals_chars++) {\r\nif (!g_ascii_isdigit(linebuff[n])) {\r\nreturn FALSE;\r\n}\r\nsubsecond_decimals_buff[subsecond_decimals_chars] = linebuff[n];\r\n}\r\nif (subsecond_decimals_chars > MAX_SUBSECOND_DECIMALS || n >= line_length) {\r\nreturn FALSE;\r\n}\r\nsubsecond_decimals_buff[subsecond_decimals_chars] = '\0';\r\n*useconds = atoi(subsecond_decimals_buff) * 100;\r\nif (linebuff[n] != ' ') {\r\nreturn FALSE;\r\n}\r\n*after_time_offset = n++;\r\nif (*is_comment) {\r\nif (strncmp(linebuff+n, "l $", 3) != 0) {\r\n*is_sprint = TRUE;\r\ng_strlcpy(protocol_name, "sprint", MAX_PROTOCOL_NAME);\r\n}\r\n}\r\nif (!(*is_sprint)) {\r\nfor (; (linebuff[n] != '$') && (linebuff[n] != '\'') && (n+1 < line_length); n++);\r\nif ((linebuff[n] == '\'') || (n+1 >= line_length)) {\r\nreturn FALSE;\r\n}\r\nn++;\r\n}\r\n*data_offset = n;\r\n*data_chars = line_length - n;\r\nif (skip_first_byte) {\r\n*data_offset += 2;\r\n*data_chars -= 2;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nprocess_parsed_line(wtap *wth, dct2000_file_externals_t *file_externals,\r\nstruct wtap_pkthdr *phdr,\r\nBuffer *buf, gint64 file_offset,\r\nchar *linebuff, long dollar_offset,\r\nint seconds, int useconds, gchar *timestamp_string,\r\npacket_direction_t direction, int encap,\r\ngchar *context_name, guint8 context_port,\r\ngchar *protocol_name, gchar *variant_name,\r\ngchar *outhdr_name, gchar *aal_header_chars,\r\ngboolean is_comment, int data_chars,\r\nint *err, gchar **err_info)\r\n{\r\nint n;\r\nint stub_offset = 0;\r\ngsize length;\r\nguint8 *frame_buffer;\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS;\r\nphdr->pkt_encap = WTAP_ENCAP_CATAPULT_DCT2000;\r\nphdr->ts.secs = file_externals->start_secs + seconds;\r\nif ((file_externals->start_usecs + useconds) >= 1000000) {\r\nphdr->ts.secs++;\r\n}\r\nphdr->ts.nsecs =\r\n((file_externals->start_usecs + useconds) % 1000000) *1000;\r\nphdr->caplen = (guint)strlen(context_name)+1 +\r\n1 +\r\n(guint)strlen(timestamp_string)+1 +\r\n(guint)strlen(variant_name)+1 +\r\n(guint)strlen(outhdr_name)+1 +\r\n(guint)strlen(protocol_name)+1 +\r\n1 +\r\n1 +\r\n(is_comment ? data_chars : (data_chars/2));\r\nif (phdr->caplen > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("catapult dct2000: File has %u-byte packet, bigger than maximum of %u",\r\nphdr->caplen, WTAP_MAX_PACKET_SIZE);\r\nreturn FALSE;\r\n}\r\nphdr->len = phdr->caplen;\r\nws_buffer_assure_space(buf, phdr->caplen);\r\nframe_buffer = ws_buffer_start_ptr(buf);\r\nlength = g_strlcpy((char*)frame_buffer, context_name, MAX_CONTEXT_NAME+1);\r\nstub_offset += (int)(length + 1);\r\nframe_buffer[stub_offset] = context_port;\r\nstub_offset++;\r\nlength = g_strlcpy((char*)&frame_buffer[stub_offset], timestamp_string, MAX_TIMESTAMP_LEN+1);\r\nstub_offset += (int)(length + 1);\r\nlength = g_strlcpy((char*)&frame_buffer[stub_offset], protocol_name, MAX_PROTOCOL_NAME+1);\r\nstub_offset += (int)(length + 1);\r\nlength = g_strlcpy((gchar*)&frame_buffer[stub_offset], variant_name, MAX_VARIANT_DIGITS+1);\r\nstub_offset += (int)(length + 1);\r\nlength = g_strlcpy((char*)&frame_buffer[stub_offset], outhdr_name, MAX_OUTHDR_NAME+1);\r\nstub_offset += (int)(length + 1);\r\nframe_buffer[stub_offset] = direction;\r\nstub_offset++;\r\nframe_buffer[stub_offset] = (guint8)encap;\r\nstub_offset++;\r\nif (!is_comment) {\r\nfor (n=0; n < data_chars; n+=2) {\r\nframe_buffer[stub_offset + n/2] =\r\nhex_byte_from_chars(linebuff+dollar_offset+n);\r\n}\r\n}\r\nelse {\r\nfor (n=0; n < data_chars; n++) {\r\nframe_buffer[stub_offset + n] = linebuff[dollar_offset+n];\r\n}\r\n}\r\nphdr->pseudo_header.dct2000.seek_off = file_offset;\r\nphdr->pseudo_header.dct2000.wth = wth;\r\nswitch (encap) {\r\ncase WTAP_ENCAP_ATM_PDUS_UNTRUNCATED:\r\nset_aal_info(&phdr->pseudo_header, direction, aal_header_chars);\r\nbreak;\r\ncase WTAP_ENCAP_ISDN:\r\nset_isdn_info(&phdr->pseudo_header, direction);\r\nbreak;\r\ncase WTAP_ENCAP_PPP:\r\nset_ppp_info(&phdr->pseudo_header, direction);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic void\r\nset_aal_info(union wtap_pseudo_header *pseudo_header,\r\npacket_direction_t direction,\r\ngchar *aal_header_chars)\r\n{\r\npseudo_header->dct2000.inner_pseudo_header.atm.flags = 0x00;\r\npseudo_header->dct2000.inner_pseudo_header.atm.channel = (direction == received);\r\npseudo_header->dct2000.inner_pseudo_header.atm.aal = AAL_2;\r\npseudo_header->dct2000.inner_pseudo_header.atm.type = TRAF_UMTS_FP;\r\npseudo_header->dct2000.inner_pseudo_header.atm.subtype = TRAF_ST_UNKNOWN;\r\npseudo_header->dct2000.inner_pseudo_header.atm.vpi =\r\nhex_byte_from_chars(aal_header_chars+1);\r\npseudo_header->dct2000.inner_pseudo_header.atm.vci =\r\n((hex_from_char(aal_header_chars[3]) << 12) |\r\n(hex_from_char(aal_header_chars[4]) << 8) |\r\n(hex_from_char(aal_header_chars[5]) << 4) |\r\nhex_from_char(aal_header_chars[6]));\r\npseudo_header->dct2000.inner_pseudo_header.atm.cells = 0;\r\nif (g_ascii_isalnum(aal_header_chars[11])) {\r\npseudo_header->dct2000.inner_pseudo_header.atm.aal2_cid =\r\nhex_byte_from_chars(aal_header_chars+10);\r\n}\r\nelse {\r\npseudo_header->dct2000.inner_pseudo_header.atm.aal2_cid =\r\n(int)aal_header_chars[11] - '0';\r\n}\r\n}\r\nstatic void\r\nset_isdn_info(union wtap_pseudo_header *pseudo_header,\r\npacket_direction_t direction)\r\n{\r\npseudo_header->dct2000.inner_pseudo_header.isdn.uton = (direction == received);\r\npseudo_header->dct2000.inner_pseudo_header.isdn.channel = 0;\r\n}\r\nstatic void\r\nset_ppp_info(union wtap_pseudo_header *pseudo_header,\r\npacket_direction_t direction)\r\n{\r\npseudo_header->dct2000.inner_pseudo_header.p2p.sent = (direction == sent);\r\n}\r\nstatic guint8\r\nhex_from_char(gchar c)\r\n{\r\nif ((c >= '0') && (c <= '9')) {\r\nreturn c - '0';\r\n}\r\nif ((c >= 'a') && (c <= 'f')) {\r\nreturn 0x0a + (c - 'a');\r\n}\r\nreturn 0xff;\r\n}\r\nstatic void prepare_hex_byte_from_chars_table(void)\r\n{\r\nguchar hex_char_array[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n'a', 'b', 'c', 'd', 'e', 'f' };\r\ngint i, j;\r\nfor (i=0; i < 16; i++) {\r\nfor (j=0; j < 16; j++) {\r\ns_tableValues[hex_char_array[i]][hex_char_array[j]] = i*16 + j;\r\n}\r\n}\r\n}\r\nstatic guint8 hex_byte_from_chars(gchar *c)\r\n{\r\nreturn s_tableValues[(unsigned char)c[0]][(unsigned char)c[1]];\r\n}\r\nstatic gchar\r\nchar_from_hex(guint8 hex)\r\n{\r\nstatic const char hex_lookup[16] =\r\n{ '0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};\r\nif (hex > 15) {\r\nreturn '?';\r\n}\r\nreturn hex_lookup[hex];\r\n}\r\nstatic gint\r\npacket_offset_equal(gconstpointer v, gconstpointer v2)\r\n{\r\nreturn (*(const gint64*)v == *(const gint64*)v2);\r\n}\r\nstatic guint\r\npacket_offset_hash_func(gconstpointer v)\r\n{\r\nreturn (guint)(*(const gint64*)v);\r\n}\r\nstatic gboolean\r\nget_file_time_stamp(gchar *linebuff, time_t *secs, guint32 *usecs)\r\n{\r\nstruct tm tm;\r\n#define MAX_MONTH_LETTERS 9\r\nchar month[MAX_MONTH_LETTERS+1];\r\nint day, year, hour, minute, second;\r\nint scan_found;\r\nif (strlen(linebuff) > MAX_TIMESTAMP_LINE_LENGTH) {\r\nreturn FALSE;\r\n}\r\nscan_found = sscanf(linebuff, "%9s %2d, %4d %2d:%2d:%2d.%4u",\r\nmonth, &day, &year, &hour, &minute, &second, usecs);\r\nif (scan_found != 7) {\r\nreturn FALSE;\r\n}\r\nif (strcmp(month, "January" ) == 0) tm.tm_mon = 0;\r\nelse if (strcmp(month, "February" ) == 0) tm.tm_mon = 1;\r\nelse if (strcmp(month, "March" ) == 0) tm.tm_mon = 2;\r\nelse if (strcmp(month, "April" ) == 0) tm.tm_mon = 3;\r\nelse if (strcmp(month, "May" ) == 0) tm.tm_mon = 4;\r\nelse if (strcmp(month, "June" ) == 0) tm.tm_mon = 5;\r\nelse if (strcmp(month, "July" ) == 0) tm.tm_mon = 6;\r\nelse if (strcmp(month, "August" ) == 0) tm.tm_mon = 7;\r\nelse if (strcmp(month, "September") == 0) tm.tm_mon = 8;\r\nelse if (strcmp(month, "October" ) == 0) tm.tm_mon = 9;\r\nelse if (strcmp(month, "November" ) == 0) tm.tm_mon = 10;\r\nelse if (strcmp(month, "December" ) == 0) tm.tm_mon = 11;\r\nelse {\r\nreturn FALSE;\r\n}\r\ntm.tm_year = year - 1900;\r\ntm.tm_mday = day;\r\ntm.tm_hour = hour;\r\ntm.tm_min = minute;\r\ntm.tm_sec = second;\r\ntm.tm_isdst = -1;\r\n*secs = mktime(&tm);\r\n*usecs = *usecs * 100;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nfree_line_prefix_info(gpointer key, gpointer value,\r\ngpointer user_data _U_)\r\n{\r\nline_prefix_info_t *info = (line_prefix_info_t*)value;\r\ng_free(key);\r\ng_free(info->before_time);\r\nif (info->after_time) {\r\ng_free(info->after_time);\r\n}\r\ng_free(info);\r\nreturn TRUE;\r\n}
