static void\r\nfill_fp_info(fp_info* p_fp_info, guchar* extra_info, guint32 length)\r\n{\r\nguint adj = 0;\r\nguint info_type = pntoh16(extra_info);\r\nguchar radio_mode = extra_info[14];\r\nguchar channel_type = 0;\r\nguint i;\r\nif (!p_fp_info || length < 22)\r\nreturn;\r\np_fp_info->division = (enum division_type)radio_mode;\r\nif (pntoh16(extra_info+2) == 5)\r\nadj = 8;\r\np_fp_info->iface_type = IuB_Interface;\r\np_fp_info->release = 0;\r\np_fp_info->release_year = 0;\r\np_fp_info->release_month = 0;\r\nif (extra_info[15] == 1)\r\np_fp_info->is_uplink = 1;\r\nelse\r\np_fp_info->is_uplink = 0;\r\nif (info_type == 0x11)\r\nchannel_type = extra_info[21 + adj];\r\nelse if (info_type == 0x30)\r\nchannel_type = extra_info[22 + adj];\r\nswitch (channel_type) {\r\ncase 1:\r\np_fp_info->channel = CHANNEL_BCH;\r\nbreak;\r\ncase 2:\r\np_fp_info->channel = CHANNEL_PCH;\r\np_fp_info->paging_indications = 0;\r\nbreak;\r\ncase 3:\r\np_fp_info->channel = CHANNEL_CPCH;\r\nbreak;\r\ncase 4:\r\nif (radio_mode == 1)\r\np_fp_info->channel = CHANNEL_RACH_FDD;\r\nelse if (radio_mode == 2)\r\np_fp_info->channel = CHANNEL_RACH_TDD;\r\nelse\r\np_fp_info->channel = CHANNEL_RACH_TDD_128;\r\nbreak;\r\ncase 5:\r\nif (radio_mode == 1)\r\np_fp_info->channel = CHANNEL_FACH_FDD;\r\nelse\r\np_fp_info->channel = CHANNEL_FACH_TDD;\r\nbreak;\r\ncase 6:\r\nif (radio_mode == 2)\r\np_fp_info->channel = CHANNEL_USCH_TDD_384;\r\nelse\r\np_fp_info->channel = CHANNEL_USCH_TDD_128;\r\nbreak;\r\ncase 7:\r\nif (radio_mode == 1)\r\np_fp_info->channel = CHANNEL_DSCH_FDD;\r\nelse\r\np_fp_info->channel = CHANNEL_DSCH_TDD;\r\nbreak;\r\ncase 8:\r\np_fp_info->channel = CHANNEL_DCH;\r\nbreak;\r\n}\r\np_fp_info->dch_crc_present = 2;\r\nif (info_type == 0x30) {\r\np_fp_info->num_chans = extra_info[23 + adj];\r\nfor (i = 0; i < (guint)p_fp_info->num_chans && (36+i*104+adj) <= length; ++i) {\r\np_fp_info->chan_tf_size[i] = pntoh32(extra_info+28+i*104+adj);\r\nif (p_fp_info->chan_tf_size[i])\r\np_fp_info->chan_num_tbs[i] = pntoh32(extra_info+32+i*104+adj)\r\n/ p_fp_info->chan_tf_size[i];\r\n}\r\n}\r\n}\r\nstatic int\r\ndissect_k12(tvbuff_t* tvb,packet_info* pinfo,proto_tree* tree, void* data _U_)\r\n{\r\nstatic dissector_handle_t data_handles[] = {NULL, NULL};\r\nproto_item* k12_item;\r\nproto_tree* k12_tree;\r\nproto_item* stack_item;\r\ndissector_handle_t sub_handle = NULL;\r\ndissector_handle_t* handles;\r\nguint i;\r\nk12_item = proto_tree_add_protocol_format(tree, proto_k12, tvb, 0, 0,\r\n"Packet from: '%s' (0x%.8x)",\r\npinfo->pseudo_header->k12.input_name,\r\npinfo->pseudo_header->k12.input);\r\nk12_tree = proto_item_add_subtree(k12_item, ett_k12);\r\nproto_tree_add_uint(k12_tree, hf_k12_port_id, tvb, 0,0,pinfo->pseudo_header->k12.input);\r\nproto_tree_add_string(k12_tree, hf_k12_port_name, tvb, 0,0,pinfo->pseudo_header->k12.input_name);\r\nstack_item = proto_tree_add_string(k12_tree, hf_k12_stack_file, tvb, 0,0,pinfo->pseudo_header->k12.stack_file);\r\nk12_item = proto_tree_add_uint(k12_tree, hf_k12_port_type, tvb, 0, 0,\r\npinfo->pseudo_header->k12.input_type);\r\nk12_tree = proto_item_add_subtree(k12_item, ett_port);\r\nswitch ( pinfo->pseudo_header->k12.input_type ) {\r\ncase K12_PORT_DS0S:\r\nproto_tree_add_uint(k12_tree, hf_k12_ts, tvb, 0,0,pinfo->pseudo_header->k12.input_info.ds0mask);\r\nbreak;\r\ncase K12_PORT_ATMPVC:\r\n{\r\ngchar* circuit_str = wmem_strdup_printf(wmem_packet_scope(), "%u:%u:%u",\r\n(guint)pinfo->pseudo_header->k12.input_info.atm.vp,\r\n(guint)pinfo->pseudo_header->k12.input_info.atm.vc,\r\n(guint)pinfo->pseudo_header->k12.input_info.atm.cid);\r\npinfo->circuit_id = g_str_hash(circuit_str);\r\nproto_tree_add_uint(k12_tree, hf_k12_atm_vp, tvb, 0, 0,\r\npinfo->pseudo_header->k12.input_info.atm.vp);\r\nproto_tree_add_uint(k12_tree, hf_k12_atm_vc, tvb, 0, 0,\r\npinfo->pseudo_header->k12.input_info.atm.vc);\r\nif (pinfo->pseudo_header->k12.input_info.atm.cid)\r\nproto_tree_add_uint(k12_tree, hf_k12_atm_cid, tvb, 0, 0,\r\npinfo->pseudo_header->k12.input_info.atm.cid);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nhandles = (dissector_handle_t *)wmem_tree_lookup32(port_handles, pinfo->pseudo_header->k12.input);\r\nif (! handles ) {\r\nfor (i=0 ; i < nk12_handles; i++) {\r\nif ( epan_strcasestr(pinfo->pseudo_header->k12.stack_file, k12_handles[i].match)\r\n|| epan_strcasestr(pinfo->pseudo_header->k12.input_name, k12_handles[i].match) ) {\r\nhandles = k12_handles[i].handles;\r\nbreak;\r\n}\r\n}\r\nif (!handles) {\r\ndata_handles[0] = data_handle;\r\nhandles = data_handles;\r\n}\r\nwmem_tree_insert32(port_handles, pinfo->pseudo_header->k12.input, handles);\r\n}\r\nif (handles == data_handles) {\r\nexpert_add_info(pinfo, stack_item, &ei_k12_unmatched_stk_file);\r\nexpert_add_info(pinfo, stack_item, &ei_k12_unmatched_info);\r\ncall_dissector(data_handle, tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nfor (i = 0; handles[i] && handles[i+1]; ++i) {\r\nif (handles[i] == sscop_handle) {\r\nsscop_payload_info* p_sscop_info = (sscop_payload_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_sscop, 0);\r\nif (!p_sscop_info) {\r\np_sscop_info = wmem_new0(wmem_file_scope(), sscop_payload_info);\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_sscop, 0, p_sscop_info);\r\np_sscop_info->subdissector = handles[i+1];\r\n}\r\n}\r\n}\r\nsub_handle = handles[0];\r\nif (sub_handle == fp_handle) {\r\nfp_info* p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\nif (!p_fp_info) {\r\np_fp_info = wmem_new0(wmem_file_scope(), fp_info);\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_fp, 0, p_fp_info);\r\nfill_fp_info(p_fp_info,\r\npinfo->pseudo_header->k12.extra_info,\r\npinfo->pseudo_header->k12.extra_length);\r\n}\r\n}\r\ncall_dissector(sub_handle, tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\nk12_update_cb(void* r, char** err)\r\n{\r\nk12_handles_t* h = (k12_handles_t *)r;\r\ngchar** protos;\r\nguint num_protos, i;\r\nprotos = g_strsplit(h->protos,":",0);\r\nfor (num_protos = 0; protos[num_protos]; num_protos++)\r\ng_strstrip(protos[num_protos]);\r\ng_free(h->handles);\r\nh->handles = (dissector_handle_t *)g_malloc0(sizeof(dissector_handle_t)*(num_protos < 2 ? 2 : num_protos));\r\nfor (i = 0; i < num_protos; i++) {\r\nif ( ! (h->handles[i] = find_dissector(protos[i])) ) {\r\nh->handles[i] = data_handle;\r\ng_strfreev(protos);\r\n*err = g_strdup_printf("Could not find dissector for: '%s'",protos[i]);\r\nreturn FALSE;\r\n}\r\n}\r\ng_strfreev(protos);\r\n*err = NULL;\r\nreturn TRUE;\r\n}\r\nstatic void*\r\nk12_copy_cb(void* dest, const void* orig, size_t len _U_)\r\n{\r\nk12_handles_t* d = (k12_handles_t *)dest;\r\nconst k12_handles_t* o = (const k12_handles_t *)orig;\r\ngchar** protos = wmem_strsplit(NULL,d->protos,":",0);\r\nguint num_protos;\r\nfor (num_protos = 0; protos[num_protos]; num_protos++)\r\ng_strstrip(protos[num_protos]);\r\nd->match = g_strdup(o->match);\r\nd->protos = g_strdup(o->protos);\r\nd->handles = (dissector_handle_t *)g_memdup(o->handles,(guint)(sizeof(dissector_handle_t)*(num_protos+1)));\r\nwmem_free(NULL, protos);\r\nreturn dest;\r\n}\r\nstatic void\r\nk12_free_cb(void* r)\r\n{\r\nk12_handles_t* h = (k12_handles_t *)r;\r\ng_free(h->match);\r\ng_free(h->protos);\r\ng_free(h->handles);\r\n}\r\nstatic gboolean\r\nprotos_chk_cb(void* r _U_, const char* p, guint len, const void* u1 _U_, const void* u2 _U_, char** err)\r\n{\r\ngchar** protos;\r\ngchar* line = wmem_strndup(NULL,p,len);\r\nguint num_protos, i;\r\ng_strstrip(line);\r\nascii_strdown_inplace(line);\r\nprotos = wmem_strsplit(NULL,line,":",0);\r\nfor (num_protos = 0; protos[num_protos]; num_protos++)\r\ng_strstrip(protos[num_protos]);\r\nif (!num_protos) {\r\n*err = g_strdup("No protocols given");\r\nwmem_free(NULL, line);\r\nwmem_free(NULL, protos);\r\nreturn FALSE;\r\n}\r\nfor (i = 0; i < num_protos; i++) {\r\nif (!find_dissector(protos[i])) {\r\n*err = g_strdup_printf("Could not find dissector for: '%s'",protos[i]);\r\nwmem_free(NULL, line);\r\nwmem_free(NULL, protos);\r\nreturn FALSE;\r\n}\r\n}\r\nwmem_free(NULL, line);\r\nwmem_free(NULL, protos);\r\nreturn TRUE;\r\n}\r\nvoid\r\nproto_register_k12(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_k12_port_id,\r\n{ "Port Id", "k12.port_id",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_k12_port_name,\r\n{ "Port Name", "k12.port_name",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_k12_stack_file,\r\n{ "Stack file used", "k12.stack_file",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_k12_port_type,\r\n{ "Port type", "k12.input_type",\r\nFT_UINT32, BASE_HEX, VALS(k12_port_types), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_k12_ts,\r\n{ "Timeslot mask", "k12.ds0.ts",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_k12_atm_vp,\r\n{ "ATM VPI", "atm.vpi",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_k12_atm_vc,\r\n{ "ATM VCI", "atm.vci",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_k12_atm_cid,\r\n{ "AAL2 CID", "aal2.cid",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint* ett[] = {\r\n&ett_k12,\r\n&ett_port\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_k12_unmatched_stk_file,\r\n{ "k12.unmatched_stk_file", PI_UNDECODED, PI_WARN,\r\n"Warning: stk file not matched in the 'K12 Protocols' table", EXPFILL }},\r\n{ &ei_k12_unmatched_info,\r\n{ "k12.unmatched_info", PI_PROTOCOL, PI_NOTE,\r\n"You can edit the 'K12 Protocols' table from Preferences->Protocols->k12xx", EXPFILL }},\r\n};\r\nstatic uat_field_t uat_k12_flds[] = {\r\nUAT_FLD_CSTRING_ISPRINT(k12,match,"Match string",\r\n"A string that will be matched (a=A) against an .stk filename or the name of a port.\n"\r\n"The first match wins, the order of entries in the table is important!."),\r\nUAT_FLD_CSTRING_OTHER(k12,protos,"Protocol",protos_chk_cb,\r\n"The lowest layer protocol described by this .stk file (eg: mtp2).\n"\r\n"Use (sscop:sscf-nni) for sscf-nni (MTP3b) with sscop"),\r\nUAT_END_FIELDS\r\n};\r\nmodule_t* k12_module;\r\nexpert_module_t* expert_k12;\r\nproto_k12 = proto_register_protocol("K12xx", "K12xx", "k12");\r\nproto_register_field_array(proto_k12, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_k12 = expert_register_protocol(proto_k12);\r\nexpert_register_field_array(expert_k12, ei, array_length(ei));\r\nregister_dissector("k12", dissect_k12, proto_k12);\r\nk12_uat = uat_new("K12 Protocols",\r\nsizeof(k12_handles_t),\r\n"k12_protos",\r\nTRUE,\r\n&k12_handles,\r\n&nk12_handles,\r\nUAT_AFFECTS_DISSECTION,\r\n"ChK12ProtocolsSection",\r\nk12_copy_cb,\r\nk12_update_cb,\r\nk12_free_cb,\r\nNULL,\r\nuat_k12_flds);\r\nk12_module = prefs_register_protocol(proto_k12, NULL);\r\nprefs_register_obsolete_preference(k12_module, "config");\r\nprefs_register_uat_preference(k12_module, "cfg",\r\n"K12 Protocols",\r\n"A table of matches vs stack filenames and relative protocols",\r\nk12_uat);\r\nport_handles = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\n}\r\nvoid proto_reg_handoff_k12(void)\r\n{\r\nk12_handle = find_dissector("k12");\r\ndata_handle = find_dissector("data");\r\nsscop_handle = find_dissector("sscop");\r\nfp_handle = find_dissector("fp");\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_K12, k12_handle);\r\n}
