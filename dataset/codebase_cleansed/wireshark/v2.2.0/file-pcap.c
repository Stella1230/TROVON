static int\r\ndissect_pcap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nstatic const guint8 pcap_big_endian_magic[MAGIC_NUMBER_SIZE] = {\r\n0xa1, 0xb2, 0xc3, 0xd4\r\n};\r\nstatic const guint8 pcap_little_endian_magic[MAGIC_NUMBER_SIZE] = {\r\n0xd4, 0xc3, 0xb2, 0xa1\r\n};\r\nstatic const guint8 pcap_nsec_big_endian_magic[MAGIC_NUMBER_SIZE] = {\r\n0xa1, 0xb2, 0x3c, 0xd4\r\n};\r\nstatic const guint8 pcap_nsec_little_endian_magic[MAGIC_NUMBER_SIZE] = {\r\n0xd4, 0x3c, 0xb2, 0xa1\r\n};\r\nvolatile gint offset = 0;\r\nproto_tree *main_tree;\r\nproto_item *main_item;\r\nproto_tree *header_tree;\r\nproto_item *header_item;\r\nproto_item *magic_number_item;\r\nproto_tree *packet_tree;\r\nproto_item *packet_item;\r\nproto_tree *timestamp_tree;\r\nproto_item *timestamp_item;\r\nproto_tree *packet_data_tree;\r\nproto_item *packet_data_item;\r\nvolatile guint32 encoding;\r\nvolatile guint timestamp_scale_factor;\r\nconst char *magic;\r\nguint32 origin_length;\r\nguint32 length;\r\nguint32 link_type;\r\nvolatile guint32 frame_number = 1;\r\nnstime_t timestamp;\r\nif (tvb_memeql(tvb, 0, pcap_big_endian_magic, MAGIC_NUMBER_SIZE) == 0) {\r\nencoding = ENC_BIG_ENDIAN;\r\ntimestamp_scale_factor = 1000;\r\nmagic = "Big-endian";\r\n} else if (tvb_memeql(tvb, 0, pcap_little_endian_magic, MAGIC_NUMBER_SIZE) == 0) {\r\nencoding = ENC_LITTLE_ENDIAN;\r\ntimestamp_scale_factor = 1000;\r\nmagic = "Little-endian";\r\n} else if (tvb_memeql(tvb, 0, pcap_nsec_big_endian_magic, MAGIC_NUMBER_SIZE) == 0) {\r\nencoding = ENC_BIG_ENDIAN;\r\ntimestamp_scale_factor = 1;\r\nmagic = "Big-endian, nanosecond resolution";\r\n} else if (tvb_memeql(tvb, 0, pcap_nsec_little_endian_magic, MAGIC_NUMBER_SIZE) == 0) {\r\nencoding = ENC_LITTLE_ENDIAN;\r\ntimestamp_scale_factor = 1;\r\nmagic = "Little-endian, nanosecond resolution";\r\n} else {\r\nreturn 0;\r\n}\r\nmain_item = proto_tree_add_item(tree, proto_pcap, tvb, offset, -1, ENC_NA);\r\nmain_tree = proto_item_add_subtree(main_item, ett_pcap);\r\nheader_item = proto_tree_add_item(main_tree, hf_pcap_header , tvb, offset, 24, ENC_NA);\r\nheader_tree = proto_item_add_subtree(header_item, ett_pcap_header);\r\nmagic_number_item = proto_tree_add_item(header_tree, hf_pcap_header_magic_number, tvb, offset, 4, ENC_NA);\r\nproto_item_append_text(magic_number_item, " (%s)", magic);\r\noffset += 4;\r\nproto_tree_add_item(header_tree, hf_pcap_header_version_major, tvb, offset, 2, encoding);\r\noffset += 2;\r\nproto_tree_add_item(header_tree, hf_pcap_header_version_minor, tvb, offset, 2, encoding);\r\noffset += 2;\r\nproto_tree_add_item(header_tree, hf_pcap_header_this_zone, tvb, offset, 4, encoding);\r\noffset += 4;\r\nproto_tree_add_item(header_tree, hf_pcap_header_sigfigs, tvb, offset, 4, encoding);\r\noffset += 4;\r\nproto_tree_add_item(header_tree, hf_pcap_header_snapshot_length, tvb, offset, 4, encoding);\r\noffset += 4;\r\nproto_tree_add_item(header_tree, hf_pcap_header_link_type, tvb, offset, 4, encoding);\r\nlink_type = tvb_get_guint32(tvb, offset, encoding);\r\noffset += 4;\r\nwhile (offset < (gint) tvb_reported_length(tvb)) {\r\npacket_item = proto_tree_add_item(main_tree, hf_pcap_packet, tvb, offset, 4 * 4, ENC_NA);\r\npacket_tree = proto_item_add_subtree(packet_item, ett_pcap_packet);\r\nproto_item_append_text(packet_item, " %u", frame_number);\r\ntimestamp.secs = tvb_get_guint32(tvb, offset, encoding);\r\ntimestamp.nsecs = tvb_get_guint32(tvb, offset + 4, encoding) * timestamp_scale_factor;\r\ntimestamp_item = proto_tree_add_time(packet_tree, hf_pcap_packet_timestamp, tvb, offset, 8, &timestamp);\r\ntimestamp_tree = proto_item_add_subtree(timestamp_item, ett_pcap_timestamp);\r\nproto_tree_add_item(timestamp_tree, hf_pcap_packet_timestamp_sec, tvb, offset, 4, encoding);\r\noffset += 4;\r\nproto_tree_add_item(timestamp_tree, hf_pcap_packet_timestamp_usec, tvb, offset, 4, encoding);\r\noffset += 4;\r\nproto_tree_add_item_ret_uint(packet_tree, hf_pcap_packet_included_length, tvb, offset, 4, encoding, &length);\r\noffset += 4;\r\nproto_tree_add_item_ret_uint(packet_tree, hf_pcap_packet_origin_length, tvb, offset, 4, encoding, &origin_length);\r\noffset += 4;\r\npacket_data_item = proto_tree_add_item(packet_tree, hf_pcap_packet_data, tvb, offset, length, ENC_NA);\r\npacket_data_tree = proto_item_add_subtree(packet_data_item, ett_pcap_packet_data);\r\npinfo->num = frame_number;\r\npinfo->abs_ts = timestamp;\r\nif (pref_dissect_next_layer) {\r\nTRY {\r\ncall_dissector_with_data(pcap_pktdata_handle, tvb_new_subset(tvb, offset, length, origin_length), pinfo, packet_data_tree, &link_type);\r\n}\r\nCATCH_BOUNDS_ERRORS {\r\nshow_exception(tvb, pinfo, packet_data_tree, EXCEPT_CODE, GET_MESSAGE);\r\n}\r\nENDTRY;\r\n}\r\noffset += length;\r\nproto_item_set_len(packet_item, 4 * 4 + length);\r\nframe_number += 1;\r\n}\r\nreturn offset;\r\n}\r\nstatic gboolean\r\ndissect_pcap_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nreturn dissect_pcap(tvb, pinfo, tree, NULL) > 0;\r\n}\r\nvoid\r\nproto_register_file_pcap(void)\r\n{\r\nmodule_t *module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_pcap_header,\r\n{ "Header", "pcap.header",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pcap_header_magic_number,\r\n{ "Magic Number", "pcap.header.magic_number",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pcap_header_version_major,\r\n{ "Version Major", "pcap.header.version.major",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pcap_header_version_minor,\r\n{ "Version Minor", "pcap.header.version.minor",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pcap_header_this_zone,\r\n{ "This Zone", "pcap.header.this_zone",\r\nFT_INT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pcap_header_sigfigs,\r\n{ "Sigfigs", "pcap.header.sigfigs",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pcap_header_snapshot_length,\r\n{ "Snapshot Length", "pcap.header.snapshot_length",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pcap_header_link_type,\r\n{ "Link Type", "pcap.header.link_type",\r\nFT_UINT32, BASE_DEC_HEX, VALS(link_type_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pcap_packet,\r\n{ "Packet", "pcap.packet",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pcap_packet_timestamp,\r\n{ "Timestamp", "pcap.packet.timestamp",\r\nFT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pcap_packet_timestamp_sec,\r\n{ "Timestamp sec", "pcap.packet.timestamp.sec",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pcap_packet_timestamp_usec,\r\n{ "Timestamp usec", "pcap.packet.timestamp.usec",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pcap_packet_included_length,\r\n{ "Included Length", "pcap.packet.included_length",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pcap_packet_origin_length,\r\n{ "Origin Length", "pcap.packet.origin_length",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pcap_packet_data,\r\n{ "Data", "pcap.packet.data",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_pcap,\r\n&ett_pcap_header,\r\n&ett_pcap_packet,\r\n&ett_pcap_packet_data,\r\n&ett_pcap_timestamp\r\n};\r\nproto_pcap = proto_register_protocol("PCAP File Format", "File-PCAP", "file-pcap");\r\nproto_register_field_array(proto_pcap, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nregister_dissector("file-pcap", dissect_pcap, proto_pcap);\r\nmodule = prefs_register_protocol(proto_pcap, NULL);\r\nprefs_register_static_text_preference(module, "version",\r\n"PCAP version: >=2.4",\r\n"Version of file-format supported by this dissector.");\r\nprefs_register_bool_preference(module, "dissect_next_layer",\r\n"Dissect next layer",\r\n"Dissect next layer",\r\n&pref_dissect_next_layer);\r\n}\r\nvoid\r\nproto_reg_handoff_file_pcap(void)\r\n{\r\nheur_dissector_add("wtap_file", dissect_pcap_heur, "PCAP File", "pcap_wtap", proto_pcap, HEURISTIC_ENABLE);\r\npcap_pktdata_handle = find_dissector_add_dependency("pcap_pktdata", proto_pcap);\r\n}
