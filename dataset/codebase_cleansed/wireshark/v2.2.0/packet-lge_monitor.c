static int\r\ndissect_lge_monitor(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\nguint32 lge_monitor_proto_id;\r\ntvbuff_t* next_tvb = NULL;\r\nproto_tree* header_tree;\r\nproto_item *ti;\r\nproto_tree *lge_monitor_tree;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "LGE Monitor");\r\nti = proto_tree_add_item(tree, proto_lge_monitor, tvb, 0, LGEMON_PROTO_HEADER_LENGTH, ENC_NA);\r\nlge_monitor_tree = proto_item_add_subtree(ti, ett_lge_monitor);\r\nheader_tree = proto_tree_add_subtree(lge_monitor_tree, tvb, offset, LGEMON_PROTO_HEADER_LENGTH, ett_lge_header, NULL, "LGE Monitor PDU");\r\nproto_tree_add_item(header_tree, hf_lge_monitor_dir, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nlge_monitor_proto_id = tvb_get_ntohl(tvb,offset);\r\nproto_tree_add_item(header_tree, hf_lge_monitor_prot, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(header_tree, hf_lge_monitor_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nswitch (lge_monitor_proto_id){\r\ncase 0:\r\ncall_dissector(mtp3_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ncase 1:\r\ncall_dissector(sccp_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ncase 2:\r\ncall_dissector(sctp_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ncase 3:\r\ncall_dissector(m3ua_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(lge_monitor_tree, hf_lge_monitor_data, tvb, offset, -1, ENC_NA);\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_reg_handoff_lge_monitor(void)\r\n{\r\nstatic dissector_handle_t lge_monitor_handle;\r\nstatic guint saved_udp_port;\r\nstatic gboolean lge_monitor_prefs_initialized = FALSE;\r\nif (!lge_monitor_prefs_initialized) {\r\nlge_monitor_handle = create_dissector_handle(dissect_lge_monitor, proto_lge_monitor);\r\ndissector_add_for_decode_as("udp.port", lge_monitor_handle);\r\nmtp3_handle = find_dissector_add_dependency("mtp3", proto_lge_monitor);\r\nm3ua_handle = find_dissector_add_dependency("m3ua", proto_lge_monitor);\r\nsccp_handle = find_dissector_add_dependency("sccp", proto_lge_monitor);\r\nsctp_handle = find_dissector_add_dependency("sctp", proto_lge_monitor);\r\nlge_monitor_prefs_initialized = TRUE;\r\n}\r\nelse {\r\nif (saved_udp_port != 0) {\r\ndissector_delete_uint("udp.port", saved_udp_port, lge_monitor_handle);\r\n}\r\n}\r\nif (LGEMonitorUDPPort != 0) {\r\ndissector_add_uint("udp.port", LGEMonitorUDPPort, lge_monitor_handle);\r\n}\r\nsaved_udp_port = LGEMonitorUDPPort;\r\n}\r\nvoid\r\nproto_register_lge_monitor(void)\r\n{\r\nmodule_t *lge_monitor_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_lge_monitor_dir,\r\n{ "Direction", "lge_monitor.dir",\r\nFT_UINT32, BASE_DEC, VALS(lge_monitor_dir_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_lge_monitor_prot,\r\n{ "Protocol Identifier", "lge_monitor.prot",\r\nFT_UINT32, BASE_DEC, VALS(lge_monitor_prot_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_lge_monitor_length,\r\n{ "Payload Length", "lge_monitor.length",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_lge_monitor_data,\r\n{ "LGE Monitor data", "lge_monitor.monitor_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_lge_monitor,\r\n&ett_lge_header\r\n};\r\nproto_lge_monitor = proto_register_protocol("LGE Monitor","LGE_Monitor", "lge_monitor");\r\nproto_register_field_array(proto_lge_monitor, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nlge_monitor_module = prefs_register_protocol(proto_lge_monitor, proto_reg_handoff_lge_monitor);\r\nprefs_register_uint_preference(lge_monitor_module, "udp.port",\r\n"LGE Monitor UDP Port",\r\n"Set UDP port for LGE Monitor messages",\r\n10,\r\n&LGEMonitorUDPPort);\r\n}
