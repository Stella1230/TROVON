static int\r\nsvcctl_dissect_dwServiceType_flags(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *parent_tree,\r\nguint8 *drep, int opnum)\r\n{\r\nguint32 value, len = 4;\r\nproto_item *item = NULL;\r\nproto_tree *tree = NULL;\r\n(void) dissect_dcerpc_uint32 (tvb, offset, pinfo, NULL, drep, 0, &value);\r\nif(parent_tree) {\r\nitem = proto_tree_add_uint(parent_tree, hf_svcctl_service_type, tvb, offset, len, value);\r\ntree = proto_item_add_subtree(item, ett_dcerpc_svcctl_service_type_bits);\r\n}\r\nswitch(opnum) {\r\ncase SVC_CREATE_SERVICE_W:\r\nproto_tree_add_boolean(tree, hf_svcctl_service_type_interactive_process,\r\ntvb, offset, len, value & SVCCTL_SERVICE_TYPE_INTERACTIVE_PROCESS);\r\nproto_tree_add_boolean(tree, hf_svcctl_service_type_win32_share_process,\r\ntvb, offset, len, value & SVCCTL_SERVICE_TYPE_WIN32_SHARE_PROCESS);\r\nproto_tree_add_boolean(tree, hf_svcctl_service_type_win32_own_process,\r\ntvb, offset, len, value & SVCCTL_SERVICE_TYPE_WIN32_OWN_PROCESS);\r\nproto_tree_add_boolean(tree, hf_svcctl_service_type_fs_driver,\r\ntvb, offset, len, value & SVCCTL_SERVICE_TYPE_FILE_SYSTEM_DRIVER);\r\nproto_tree_add_boolean(tree, hf_svcctl_service_type_kernel_driver,\r\ntvb, offset, len, value & SVCCTL_SERVICE_TYPE_KERNEL_DRIVER);\r\nbreak;\r\ncase SVC_ENUM_SERVICES_STATUS_W:\r\nproto_tree_add_boolean(tree, hf_svcctl_service_type_win32_share_process,\r\ntvb, offset, len, value & SVCCTL_SERVICE_TYPE_WIN32_SHARE_PROCESS);\r\nproto_tree_add_boolean(tree, hf_svcctl_service_type_win32_own_process,\r\ntvb, offset, len, value & SVCCTL_SERVICE_TYPE_WIN32_OWN_PROCESS);\r\nproto_tree_add_boolean(tree, hf_svcctl_service_type_fs_driver,\r\ntvb, offset, len, value & SVCCTL_SERVICE_TYPE_FILE_SYSTEM_DRIVER);\r\nproto_tree_add_boolean(tree, hf_svcctl_service_type_kernel_driver,\r\ntvb, offset, len, value & SVCCTL_SERVICE_TYPE_KERNEL_DRIVER);\r\nbreak;\r\ncase SVC_QUERY_SERVICE_CONFIG_W:\r\nproto_tree_add_boolean(tree, hf_svcctl_service_type_win32_share_process,\r\ntvb, offset, len, value & SVCCTL_SERVICE_TYPE_WIN32_SHARE_PROCESS);\r\nproto_tree_add_boolean(tree, hf_svcctl_service_type_win32_own_process,\r\ntvb, offset, len, value & SVCCTL_SERVICE_TYPE_WIN32_OWN_PROCESS);\r\nproto_tree_add_boolean(tree, hf_svcctl_service_type_fs_driver,\r\ntvb, offset, len, value & SVCCTL_SERVICE_TYPE_FILE_SYSTEM_DRIVER);\r\nproto_tree_add_boolean(tree, hf_svcctl_service_type_kernel_driver,\r\ntvb, offset, len, value & SVCCTL_SERVICE_TYPE_KERNEL_DRIVER);\r\nbreak;\r\n}\r\noffset += len;\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_pointer_long(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_ndr_uint32 (tvb, offset, pinfo, tree, di, drep,\r\ndi->hf_index, NULL);\r\nreturn offset;\r\n}\r\nstatic void\r\nsvcctl_scm_specific_rights(tvbuff_t *tvb, gint offset, proto_tree *tree,\r\nguint32 access)\r\n{\r\nproto_tree_add_boolean(tree, hf_svcctl_scm_rights_modify_boot_config, tvb, offset, 4, access);\r\nproto_tree_add_boolean(tree, hf_svcctl_scm_rights_query_lock_status, tvb, offset, 4, access);\r\nproto_tree_add_boolean(tree, hf_svcctl_scm_rights_lock, tvb, offset, 4, access);\r\nproto_tree_add_boolean(tree, hf_svcctl_scm_rights_enumerate_service, tvb, offset, 4, access);\r\nproto_tree_add_boolean(tree, hf_svcctl_scm_rights_create_service, tvb, offset, 4, access);\r\nproto_tree_add_boolean(tree, hf_svcctl_scm_rights_connect, tvb, offset, 4, access);\r\n}\r\nstatic int\r\nsvcctl_dissect_OpenSCManager_rqst(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\ndcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\nconst char *mn, *dn;\r\ndcv->private_data=NULL;\r\noffset = dissect_ndr_pointer_cb(\r\ntvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_char_cvstring, NDR_POINTER_UNIQUE,\r\n"MachineName", hf_svcctl_machinename, cb_str_postprocess,\r\nGINT_TO_POINTER(CB_STR_COL_INFO | CB_STR_SAVE | 1));\r\nmn=(const char *)dcv->private_data;\r\nif(!mn)\r\nmn="";\r\ndcv->private_data=NULL;\r\noffset = dissect_ndr_pointer_cb(\r\ntvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_char_cvstring, NDR_POINTER_UNIQUE,\r\n"Database", hf_svcctl_database, cb_str_postprocess,\r\nGINT_TO_POINTER(CB_STR_COL_INFO | 1));\r\ndn=(const char *)dcv->private_data;\r\nif(!dn)\r\ndn="";\r\nif(!pinfo->fd->flags.visited){\r\nif(!dcv->se_data){\r\ndcv->se_data=wmem_strdup_printf(wmem_file_scope(), "%s\\%s",mn,dn);\r\n}\r\n}\r\noffset = dissect_nt_access_mask(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_access_mask,\r\n&svcctl_scm_access_mask_info, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_OpenSCManager_reply(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\ndcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\ne_ctx_hnd policy_hnd;\r\nproto_item *hnd_item;\r\nguint32 status;\r\noffset = dissect_nt_policy_hnd(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_hnd, &policy_hnd,\r\n&hnd_item, TRUE, FALSE);\r\noffset = dissect_doserror(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_rc, &status);\r\nif( status == 0 ){\r\nconst char *pol_name;\r\nif (dcv->se_data){\r\npol_name = wmem_strdup_printf(wmem_packet_scope(),\r\n"OpenSCManagerW(%s)", (char *)dcv->se_data);\r\n} else {\r\npol_name = "Unknown OpenSCManagerW() handle";\r\n}\r\nif(!pinfo->fd->flags.visited){\r\ndcerpc_store_polhnd_name(&policy_hnd, pinfo, pol_name);\r\n}\r\nif(hnd_item)\r\nproto_item_append_text(hnd_item, ": %s", pol_name);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_OpenSCManagerW_rqst(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\ndcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\nconst char *mn, *dn;\r\ndcv->private_data=NULL;\r\noffset = dissect_ndr_pointer_cb(\r\ntvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_wchar_cvstring, NDR_POINTER_UNIQUE,\r\n"MachineName", hf_svcctl_machinename, cb_wstr_postprocess,\r\nGINT_TO_POINTER(CB_STR_COL_INFO | CB_STR_SAVE | 1));\r\nmn=(const char *)dcv->private_data;\r\nif(!mn)\r\nmn="";\r\ndcv->private_data=NULL;\r\noffset = dissect_ndr_pointer_cb(\r\ntvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_wchar_cvstring, NDR_POINTER_UNIQUE,\r\n"Database", hf_svcctl_database, cb_wstr_postprocess,\r\nGINT_TO_POINTER(CB_STR_COL_INFO | 1));\r\ndn=(const char *)dcv->private_data;\r\nif(!dn)\r\ndn="";\r\nif(!pinfo->fd->flags.visited){\r\nif(!dcv->se_data){\r\ndcv->se_data=wmem_strdup_printf(wmem_file_scope(), "%s\\%s",mn,dn);\r\n}\r\n}\r\noffset = dissect_nt_access_mask(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_access_mask,\r\n&svcctl_scm_access_mask_info, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_OpenSCManagerW_reply(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\ndcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\ne_ctx_hnd policy_hnd;\r\nproto_item *hnd_item;\r\nguint32 status;\r\noffset = dissect_nt_policy_hnd(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_hnd, &policy_hnd,\r\n&hnd_item, TRUE, FALSE);\r\noffset = dissect_doserror(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_rc, &status);\r\nif( status == 0 ){\r\nconst char *pol_name;\r\nif (dcv->se_data){\r\npol_name = wmem_strdup_printf(wmem_packet_scope(),\r\n"OpenSCManagerW(%s)", (char *)dcv->se_data);\r\n} else {\r\npol_name = "Unknown OpenSCManagerW() handle";\r\n}\r\nif(!pinfo->fd->flags.visited){\r\ndcerpc_store_polhnd_name(&policy_hnd, pinfo, pol_name);\r\n}\r\nif(hnd_item)\r\nproto_item_append_text(hnd_item, ": %s", pol_name);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_CreateServiceW_rqst(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree, dcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_nt_policy_hnd(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_hnd, NULL, NULL, FALSE, FALSE);\r\noffset = dissect_ndr_cvstring(tvb, offset, pinfo, tree, di, drep,\r\nsizeof(guint16), hf_svcctl_service_name, TRUE, NULL);\r\noffset = dissect_ndr_pointer_cb(\r\ntvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_wchar_cvstring, NDR_POINTER_UNIQUE,\r\n"Display Name", hf_svcctl_display_name, cb_wstr_postprocess,\r\nGINT_TO_POINTER(1));\r\noffset = dissect_nt_access_mask(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_access_mask,\r\n&svcctl_scm_access_mask_info, NULL);\r\noffset = svcctl_dissect_dwServiceType_flags(tvb, offset, pinfo, tree, drep, SVC_CREATE_SERVICE_W);\r\noffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_service_start_type, NULL);\r\noffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_service_error_control, NULL);\r\noffset = dissect_ndr_cvstring(tvb, offset, pinfo, tree, di, drep,\r\nsizeof(guint16), hf_svcctl_binarypathname, TRUE, NULL);\r\noffset = dissect_ndr_pointer_cb(\r\ntvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_wchar_cvstring, NDR_POINTER_UNIQUE,\r\n"Load Order Group", hf_svcctl_loadordergroup, cb_wstr_postprocess,\r\nGINT_TO_POINTER(1));\r\noffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_tagid, NULL);\r\noffset = dissect_ndr_pointer_cb(\r\ntvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_wchar_cvstring, NDR_POINTER_UNIQUE,\r\n"Dependencies", hf_svcctl_dependencies, cb_wstr_postprocess,\r\nGINT_TO_POINTER(1));\r\noffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_depend_size, NULL);\r\noffset = dissect_ndr_pointer_cb(\r\ntvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_wchar_cvstring, NDR_POINTER_UNIQUE,\r\n"Service Start Name", hf_svcctl_service_start_name, cb_wstr_postprocess,\r\nGINT_TO_POINTER(1));\r\noffset = dissect_ndr_pointer_cb(\r\ntvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_wchar_cvstring, NDR_POINTER_UNIQUE,\r\n"Password", hf_svcctl_password, cb_wstr_postprocess,\r\nGINT_TO_POINTER(1));\r\noffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_password_size, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_CreateServiceW_reply(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree, dcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_tagid, NULL);\r\noffset = dissect_nt_policy_hnd(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_hnd, NULL, NULL, FALSE, FALSE);\r\noffset = dissect_doserror(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_rc, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_CloseServiceHandle_rqst(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\ne_ctx_hnd policy_hnd;\r\nchar *pol_name;\r\noffset = dissect_nt_policy_hnd(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_hnd, &policy_hnd,\r\nNULL, FALSE, TRUE);\r\ndcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\r\npinfo->num);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %s",\r\npol_name);\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_CloseServiceHandle_reply(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_nt_policy_hnd(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_hnd, NULL,\r\nNULL, FALSE, TRUE);\r\noffset = dissect_doserror(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_rc, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_LockServiceDatabase_rqst(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_nt_policy_hnd(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_hnd, NULL,\r\nNULL, FALSE, TRUE);\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_LockServiceDatabase_reply(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_nt_policy_hnd(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_lock, NULL,\r\nNULL, TRUE, FALSE);\r\noffset = dissect_doserror(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_rc, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_UnlockServiceDatabase_rqst(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_nt_policy_hnd(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_lock, NULL,\r\nNULL, FALSE, TRUE);\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_UnlockServiceDatabase_reply(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_nt_policy_hnd(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_lock, NULL,\r\nNULL, TRUE, FALSE);\r\noffset = dissect_doserror(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_rc, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_QUERY_SERVICE_LOCK_STATUS(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_is_locked, NULL);\r\noffset = dissect_ndr_pointer(\r\ntvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_char_cvstring, NDR_POINTER_UNIQUE,\r\n"Owner", hf_svcctl_lock_owner);\r\noffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_lock_duration, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_QueryServiceLockStatus_rqst(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_nt_policy_hnd(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_hnd, NULL,\r\nNULL, FALSE, TRUE);\r\noffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_size, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_QueryServiceLockStatus_reply(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_ndr_pointer(tvb, offset, pinfo, tree, di, drep,\r\nsvcctl_dissect_QUERY_SERVICE_LOCK_STATUS, NDR_POINTER_REF,\r\n"LOCK_STATUS", -1);\r\noffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_required_size, NULL);\r\noffset = dissect_doserror(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_rc, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_EnumServicesStatus_rqst(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree, dcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_nt_policy_hnd(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_hnd, NULL, NULL, FALSE, FALSE);\r\noffset = svcctl_dissect_dwServiceType_flags(tvb, offset, pinfo, tree, drep, SVC_ENUM_SERVICES_STATUS_W);\r\noffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_service_state, NULL);\r\noffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_size, NULL);\r\noffset = dissect_ndr_pointer(tvb, offset, pinfo, tree, di, drep,\r\nsvcctl_dissect_pointer_long, NDR_POINTER_UNIQUE,\r\n"Resume Handle", hf_svcctl_resume);\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_OpenServiceW_rqst(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree, dcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_nt_policy_hnd(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_hnd, NULL, NULL, FALSE, FALSE);\r\noffset = dissect_ndr_cvstring(tvb, offset, pinfo, tree, di, drep,\r\nsizeof(guint16), hf_svcctl_service_name, TRUE, NULL);\r\noffset = dissect_nt_access_mask(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_access_mask,\r\n&svcctl_scm_access_mask_info, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_OpenServiceW_reply(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree, dcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_nt_policy_hnd(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_hnd, NULL, NULL, FALSE, FALSE);\r\noffset = dissect_doserror(\r\ntvb, offset, pinfo, tree, di, drep, hf_svcctl_rc, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\nsvcctl_dissect_QueryServiceConfigW_rqst(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree, dcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_nt_policy_hnd(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_hnd, NULL, NULL, FALSE, FALSE);\r\noffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\nhf_svcctl_buffer, NULL);\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_dcerpc_svcctl(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_svcctl_opnum,\r\n{ "Operation", "svcctl.opnum", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_svcctl_machinename,\r\n{ "MachineName", "svcctl.machinename", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "Name of the host we want to open the database on", HFILL }},\r\n{ &hf_svcctl_database,\r\n{ "Database", "svcctl.database", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "Name of the database to open", HFILL }},\r\n{ &hf_svcctl_access_mask,\r\n{ "Access Mask", "svcctl.access_mask", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, "SVCCTL Access Mask", HFILL }},\r\n{ &hf_svcctl_scm_rights_connect,\r\n{ "Connect", "svcctl.scm_rights_connect", FT_BOOLEAN, 32,\r\nTFS(&tfs_set_notset), 0x00000001, "SVCCTL Rights to connect to SCM", HFILL }},\r\n{ &hf_svcctl_scm_rights_create_service,\r\n{ "Create Service", "svcctl.scm_rights_create_service", FT_BOOLEAN, 32,\r\nTFS(&tfs_set_notset), 0x00000002, "SVCCTL Rights to create services", HFILL }},\r\n{ &hf_svcctl_scm_rights_enumerate_service,\r\n{ "Enumerate Service", "svcctl.scm_rights_enumerate_service", FT_BOOLEAN, 32,\r\nTFS(&tfs_set_notset), 0x00000004, "SVCCTL Rights to enumerate services", HFILL }},\r\n{ &hf_svcctl_scm_rights_lock,\r\n{ "Lock", "svcctl.scm_rights_lock", FT_BOOLEAN, 32,\r\nTFS(&tfs_set_notset), 0x00000008, "SVCCTL Rights to lock database", HFILL }},\r\n{ &hf_svcctl_scm_rights_query_lock_status,\r\n{ "Query Lock Status", "svcctl.scm_rights_query_lock_status", FT_BOOLEAN, 32,\r\nTFS(&tfs_set_notset), 0x00000010, "SVCCTL Rights to query database lock status", HFILL }},\r\n{ &hf_svcctl_scm_rights_modify_boot_config,\r\n{ "Modify Boot Config", "svcctl.scm_rights_modify_boot_config", FT_BOOLEAN, 32,\r\nTFS(&tfs_set_notset), 0x00000020, "SVCCTL Rights to modify boot config", HFILL }},\r\n{ &hf_svcctl_hnd,\r\n{ "Context Handle", "svcctl.hnd", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "SVCCTL Context handle", HFILL }},\r\n{ &hf_svcctl_lock,\r\n{ "Lock", "svcctl.lock", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "SVCCTL Database Lock", HFILL }},\r\n{ &hf_svcctl_rc,\r\n{ "Return code", "svcctl.rc", FT_UINT32, BASE_HEX | BASE_EXT_STRING,\r\n&DOS_errors_ext, 0x0, "SVCCTL return code", HFILL }},\r\n{ &hf_svcctl_size,\r\n{ "Size", "svcctl.size", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "SVCCTL size of buffer", HFILL }},\r\n{ &hf_svcctl_required_size,\r\n{ "Required Size", "svcctl.required_size", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "SVCCTL required size of buffer for data to fit", HFILL }},\r\n{ &hf_svcctl_is_locked,\r\n{ "IsLocked", "svcctl.is_locked", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "SVCCTL whether the database is locked or not", HFILL }},\r\n{ &hf_svcctl_lock_duration,\r\n{ "Duration", "svcctl.lock_duration", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "SVCCTL number of seconds the database has been locked", HFILL }},\r\n{ &hf_svcctl_lock_owner,\r\n{ "Owner", "svcctl.lock_owner", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "SVCCTL the user that holds the database lock", HFILL }},\r\n{ &hf_svcctl_service_type,\r\n{ "Service Type", "svcctl.service_type", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, "SVCCTL type of service", HFILL }},\r\n{ &hf_svcctl_service_type_kernel_driver,\r\n{ "Kernel Driver Service", "svcctl.service_type.kernel", FT_BOOLEAN, 32,\r\nTFS(&tfs_svcctl_service_type_kernel_driver), SVCCTL_SERVICE_TYPE_KERNEL_DRIVER, "Request includes kernel driver services?", HFILL }},\r\n{ &hf_svcctl_service_type_fs_driver,\r\n{ "File System Driver Service", "svcctl.service_type.fs", FT_BOOLEAN, 32,\r\nTFS(&tfs_svcctl_service_type_fs_driver), SVCCTL_SERVICE_TYPE_FILE_SYSTEM_DRIVER, "Request includes file system driver services?", HFILL }},\r\n{ &hf_svcctl_service_type_win32_own_process,\r\n{ "Self Process Service", "svcctl.service_type.win32_own", FT_BOOLEAN, 32,\r\nTFS(&tfs_svcctl_service_type_win32_own_process), SVCCTL_SERVICE_TYPE_WIN32_OWN_PROCESS, "Request includes services that run their own process?", HFILL }},\r\n{ &hf_svcctl_service_type_win32_share_process,\r\n{ "Shared Process Service", "svcctl.service_type.win32_shared", FT_BOOLEAN, 32,\r\nTFS(&tfs_svcctl_service_type_win32_share_process), SVCCTL_SERVICE_TYPE_WIN32_SHARE_PROCESS, "Request includes services that share their process?", HFILL }},\r\n{ &hf_svcctl_service_type_interactive_process,\r\n{ "Interactive Process Service", "svcctl.service_type.interactive", FT_BOOLEAN, 32,\r\nTFS(&tfs_svcctl_service_type_interactive_process), SVCCTL_SERVICE_TYPE_INTERACTIVE_PROCESS, "Request includes services that can interact with the desktop?", HFILL }},\r\n{ &hf_svcctl_service_state,\r\n{ "Service State", "svcctl.service_state", FT_UINT32, BASE_DEC,\r\nVALS(svcctl_service_status_vals), 0x0, "SVCCTL service state", HFILL }},\r\n{ &hf_svcctl_buffer,\r\n{ "Buffer", "svcctl.buffer", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "SVCCTL buffer", HFILL }},\r\n#if 0\r\n{ &hf_svcctl_bytes_needed,\r\n{ "Bytes Needed", "svcctl.bytes_needed", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "SVCCTL bytes needed", HFILL }},\r\n{ &hf_svcctl_services_returned,\r\n{ "Services Returned", "svcctl.services_returned", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "SVCCTL services returned", HFILL }},\r\n#endif\r\n{ &hf_svcctl_service_name,\r\n{ "Service Name", "svcctl.servicename", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "SVCCTL name of service", HFILL }},\r\n{ &hf_svcctl_display_name,\r\n{ "Display Name", "svcctl.displayname", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "SVCCTL display name", HFILL }},\r\n{ &hf_svcctl_service_start_type,\r\n{ "Service Start Type", "svcctl.service_start_type", FT_UINT32, BASE_DEC,\r\nVALS(svcctl_service_start_type_vals), 0x0, "SVCCTL service start type", HFILL }},\r\n{ &hf_svcctl_service_error_control,\r\n{ "Service Error Control", "svcctl.service_error_control", FT_UINT32, BASE_DEC,\r\nVALS(svcctl_service_error_control_vals), 0x0, "SVCCTL service error control", HFILL }},\r\n{ &hf_svcctl_binarypathname,\r\n{ "Binary Path Name", "svcctl.binarypathname", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "SVCCTL binary path name", HFILL }},\r\n{ &hf_svcctl_loadordergroup,\r\n{ "Load Order Group", "svcctl.loadordergroup", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "SVCCTL load order group", HFILL }},\r\n{ &hf_svcctl_tagid,\r\n{ "Tag Id", "svcctl.tagid", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "SVCCTL tag id", HFILL }},\r\n{ &hf_svcctl_dependencies,\r\n{ "Dependencies", "svcctl.dependencies", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "SVCCTL dependencies", HFILL }},\r\n{ &hf_svcctl_depend_size,\r\n{ "Depend Size", "svcctl.depend_size", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "SVCCTL depend size", HFILL }},\r\n{ &hf_svcctl_service_start_name,\r\n{ "Service Start Name", "svcctl.service_start_name", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "SVCCTL service start name", HFILL }},\r\n{ &hf_svcctl_password,\r\n{ "Password", "svcctl.password", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "SVCCTL password", HFILL }},\r\n{ &hf_svcctl_password_size,\r\n{ "Password Size", "svcctl.password_size", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "SVCCTL password size", HFILL }},\r\n{ &hf_svcctl_resume,\r\n{ "Resume Handle", "svcctl.resume", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "SVCCTL resume handle", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_dcerpc_svcctl,\r\n&ett_dcerpc_svcctl_service_type_bits,\r\n};\r\nproto_dcerpc_svcctl = proto_register_protocol(\r\n"Microsoft Service Control", "SVCCTL", "svcctl");\r\nproto_register_field_array(proto_dcerpc_svcctl, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_dcerpc_svcctl(void)\r\n{\r\ndcerpc_init_uuid(proto_dcerpc_svcctl, ett_dcerpc_svcctl,\r\n&uuid_dcerpc_svcctl, ver_dcerpc_svcctl,\r\ndcerpc_svcctl_dissectors, hf_svcctl_opnum);\r\n}
