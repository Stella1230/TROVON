gint\r\nif_list_comparator_alph(const void *first_arg, const void *second_arg)\r\n{\r\nconst if_info_t *first = (const if_info_t *)first_arg, *second = (const if_info_t *)second_arg;\r\nif (first != NULL && first->friendly_name != NULL &&\r\nsecond != NULL && second->friendly_name != NULL) {\r\nreturn g_ascii_strcasecmp(first->friendly_name, second->friendly_name);\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic void\r\nfill_from_ifaces (interface_t *device)\r\n{\r\ninterface_options interface_opts;\r\nguint i;\r\nfor (i = 0; i < global_capture_opts.ifaces->len; i++) {\r\ninterface_opts = g_array_index(global_capture_opts.ifaces, interface_options, i);\r\nif (strcmp(interface_opts.name, device->name) != 0) {\r\ncontinue;\r\n}\r\n#if defined(HAVE_PCAP_CREATE)\r\ndevice->buffer = interface_opts.buffer_size;\r\ndevice->monitor_mode_enabled = interface_opts.monitor_mode;\r\n#endif\r\ndevice->pmode = interface_opts.promisc_mode;\r\ndevice->has_snaplen = interface_opts.has_snaplen;\r\ndevice->snaplen = interface_opts.snaplen;\r\ng_free(device->cfilter);\r\ndevice->cfilter = g_strdup(interface_opts.cfilter);\r\nif (interface_opts.linktype != -1) {\r\ndevice->active_dlt = interface_opts.linktype;\r\n}\r\nif (!device->selected) {\r\ndevice->selected = TRUE;\r\nglobal_capture_opts.num_selected++;\r\n}\r\nreturn;\r\n}\r\n}\r\nvoid\r\nscan_local_interfaces(void (*update_cb)(void))\r\n{\r\nGList *if_entry, *lt_entry, *if_list;\r\nif_info_t *if_info, temp;\r\ngchar *descr;\r\nif_capabilities_t *caps=NULL;\r\ngint linktype_count;\r\ngboolean monitor_mode;\r\nGSList *curr_addr;\r\nint ips = 0, i;\r\nguint count = 0, j;\r\nif_addr_t *addr, *temp_addr;\r\nlink_row *link = NULL;\r\ndata_link_info_t *data_link_info;\r\ninterface_t device;\r\nGString *ip_str;\r\ninterface_options interface_opts;\r\ngboolean found = FALSE;\r\nif (global_capture_opts.all_ifaces->len > 0) {\r\nfor (i = (int)global_capture_opts.all_ifaces->len-1; i >= 0; i--) {\r\ndevice = g_array_index(global_capture_opts.all_ifaces, interface_t, i);\r\nif (device.local && device.type != IF_PIPE && device.type != IF_STDIN) {\r\nglobal_capture_opts.all_ifaces = g_array_remove_index(global_capture_opts.all_ifaces, i);\r\nif (device.selected) {\r\nglobal_capture_opts.num_selected--;\r\n}\r\nfor (j = 0; j < global_capture_opts.ifaces->len; j++) {\r\ninterface_opts = g_array_index(global_capture_opts.ifaces, interface_options, j);\r\nif (strcmp(device.name, interface_opts.name) == 0) {\r\ncapture_opts_del_iface(&global_capture_opts, j);\r\n}\r\n}\r\ncapture_opts_free_interface_t(&device);\r\n}\r\n}\r\n}\r\ng_free(global_capture_opts.ifaces_err_info);\r\nif_list = capture_interface_list(&global_capture_opts.ifaces_err,\r\n&global_capture_opts.ifaces_err_info,\r\nupdate_cb);\r\ncount = 0;\r\nfor (if_entry = if_list; if_entry != NULL; if_entry = g_list_next(if_entry)) {\r\nmemset(&device, 0, sizeof(device));\r\nif_info = (if_info_t *)if_entry->data;\r\nip_str = g_string_new("");\r\nips = 0;\r\nif (strstr(if_info->name, "rpcap:")) {\r\ncontinue;\r\n}\r\ndevice.name = g_strdup(if_info->name);\r\nif (if_info->friendly_name != NULL) {\r\ndevice.friendly_name = g_strdup(if_info->friendly_name);\r\n} else {\r\ndevice.friendly_name = NULL;\r\n}\r\ndevice.hidden = FALSE;\r\ndevice.locked = FALSE;\r\nmemset(&temp, 0, sizeof(temp));\r\ntemp.name = g_strdup(if_info->name);\r\ntemp.friendly_name = g_strdup(if_info->friendly_name);\r\ntemp.vendor_description = g_strdup(if_info->vendor_description);\r\ntemp.loopback = if_info->loopback;\r\ntemp.type = if_info->type;\r\n#ifdef HAVE_EXTCAP\r\ntemp.extcap = g_strdup(if_info->extcap);\r\n#endif\r\ndescr = capture_dev_user_descr_find(if_info->name);\r\ndevice.display_name = get_iface_display_name(descr, if_info);\r\ng_free(descr);\r\ndevice.selected = FALSE;\r\nif (prefs_is_capture_device_hidden(if_info->name)) {\r\ndevice.hidden = TRUE;\r\n}\r\ndevice.type = if_info->type;\r\nmonitor_mode = prefs_capture_device_monitor_mode(if_info->name);\r\ncaps = capture_get_if_capabilities(if_info->name, monitor_mode, NULL, NULL, update_cb);\r\nfor (; (curr_addr = g_slist_nth(if_info->addrs, ips)) != NULL; ips++) {\r\ntemp_addr = (if_addr_t *)g_malloc0(sizeof(if_addr_t));\r\nif (ips != 0) {\r\ng_string_append(ip_str, "\n");\r\n}\r\naddr = (if_addr_t *)curr_addr->data;\r\nif (addr) {\r\naddress addr_str;\r\nchar* temp_addr_str = NULL;\r\ntemp_addr->ifat_type = addr->ifat_type;\r\nswitch (addr->ifat_type) {\r\ncase IF_AT_IPv4:\r\ntemp_addr->addr.ip4_addr = addr->addr.ip4_addr;\r\nset_address(&addr_str, AT_IPv4, 4, &addr->addr.ip4_addr);\r\ntemp_addr_str = address_to_str(NULL, &addr_str);\r\ng_string_append(ip_str, temp_addr_str);\r\nbreak;\r\ncase IF_AT_IPv6:\r\nmemcpy(temp_addr->addr.ip6_addr, addr->addr.ip6_addr, sizeof(addr->addr));\r\nset_address(&addr_str, AT_IPv6, 16, addr->addr.ip6_addr);\r\ntemp_addr_str = address_to_str(NULL, &addr_str);\r\ng_string_append(ip_str, temp_addr_str);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwmem_free(NULL, temp_addr_str);\r\n} else {\r\ng_free(temp_addr);\r\ntemp_addr = NULL;\r\n}\r\nif (temp_addr) {\r\ntemp.addrs = g_slist_append(temp.addrs, temp_addr);\r\n}\r\n}\r\n#ifdef HAVE_PCAP_REMOTE\r\ndevice.local = TRUE;\r\ndevice.remote_opts.src_type = CAPTURE_IFLOCAL;\r\ndevice.remote_opts.remote_host_opts.remote_host = g_strdup(global_capture_opts.default_options.remote_host);\r\ndevice.remote_opts.remote_host_opts.remote_port = g_strdup(global_capture_opts.default_options.remote_port);\r\ndevice.remote_opts.remote_host_opts.auth_type = global_capture_opts.default_options.auth_type;\r\ndevice.remote_opts.remote_host_opts.auth_username = g_strdup(global_capture_opts.default_options.auth_username);\r\ndevice.remote_opts.remote_host_opts.auth_password = g_strdup(global_capture_opts.default_options.auth_password);\r\ndevice.remote_opts.remote_host_opts.datatx_udp = global_capture_opts.default_options.datatx_udp;\r\ndevice.remote_opts.remote_host_opts.nocap_rpcap = global_capture_opts.default_options.nocap_rpcap;\r\ndevice.remote_opts.remote_host_opts.nocap_local = global_capture_opts.default_options.nocap_local;\r\n#endif\r\n#ifdef HAVE_PCAP_SETSAMPLING\r\ndevice.remote_opts.sampling_method = global_capture_opts.default_options.sampling_method;\r\ndevice.remote_opts.sampling_param = global_capture_opts.default_options.sampling_param;\r\n#endif\r\nlinktype_count = 0;\r\ndevice.links = NULL;\r\nif (caps != NULL) {\r\n#if defined(HAVE_PCAP_CREATE)\r\ndevice.monitor_mode_enabled = monitor_mode;\r\ndevice.monitor_mode_supported = caps->can_set_rfmon;\r\n#endif\r\nfor (lt_entry = caps->data_link_types; lt_entry != NULL; lt_entry = g_list_next(lt_entry)) {\r\ndata_link_info = (data_link_info_t *)lt_entry->data;\r\nlink = (link_row *)g_malloc(sizeof(link_row));\r\nif (data_link_info->description != NULL) {\r\nlink->dlt = data_link_info->dlt;\r\nlink->name = g_strdup(data_link_info->description);\r\n} else {\r\nlink->dlt = -1;\r\nlink->name = g_strdup_printf("%s (not supported)", data_link_info->name);\r\n}\r\ndevice.links = g_list_append(device.links, link);\r\nlinktype_count++;\r\n}\r\nset_active_dlt(&device, global_capture_opts.default_options.linktype);\r\n} else {\r\n#if defined(HAVE_PCAP_CREATE)\r\ndevice.monitor_mode_enabled = FALSE;\r\ndevice.monitor_mode_supported = FALSE;\r\n#endif\r\ndevice.active_dlt = -1;\r\n}\r\ndevice.addresses = g_strdup(ip_str->str);\r\ndevice.no_addresses = ips;\r\ndevice.local = TRUE;\r\ndevice.if_info = temp;\r\ndevice.last_packets = 0;\r\nif (!capture_dev_user_pmode_find(if_info->name, &device.pmode)) {\r\ndevice.pmode = global_capture_opts.default_options.promisc_mode;\r\n}\r\nif (!capture_dev_user_snaplen_find(if_info->name, &device.has_snaplen,\r\n&device.snaplen)) {\r\ndevice.has_snaplen = global_capture_opts.default_options.has_snaplen;\r\ndevice.snaplen = global_capture_opts.default_options.snaplen;\r\n}\r\ndevice.cfilter = g_strdup(global_capture_opts.default_options.cfilter);\r\n#ifdef CAN_SET_CAPTURE_BUFFER_SIZE\r\nif ((device.buffer = capture_dev_user_buffersize_find(if_info->name)) == -1) {\r\ndevice.buffer = global_capture_opts.default_options.buffer_size;\r\n}\r\n#endif\r\nfill_from_ifaces(&device);\r\n#ifdef HAVE_EXTCAP\r\ndevice.external_cap_args_settings = NULL;\r\n#endif\r\nif (global_capture_opts.all_ifaces->len <= count) {\r\ng_array_append_val(global_capture_opts.all_ifaces, device);\r\ncount = global_capture_opts.all_ifaces->len;\r\n} else {\r\ng_array_insert_val(global_capture_opts.all_ifaces, count, device);\r\n}\r\nif (caps != NULL) {\r\nfree_if_capabilities(caps);\r\n}\r\ng_string_free(ip_str, TRUE);\r\ncount++;\r\n}\r\nfree_interface_list(if_list);\r\nfor (j = 0; j < global_capture_opts.ifaces->len; j++) {\r\ninterface_opts = g_array_index(global_capture_opts.ifaces, interface_options, j);\r\nfound = FALSE;\r\nfor (i = 0; i < (int)global_capture_opts.all_ifaces->len; i++) {\r\ndevice = g_array_index(global_capture_opts.all_ifaces, interface_t, i);\r\nif (strcmp(device.name, interface_opts.name) == 0) {\r\nfound = TRUE;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nmemset(&device, 0, sizeof(device));\r\ndevice.name = g_strdup(interface_opts.name);\r\ndevice.display_name = interface_opts.descr ?\r\ng_strdup_printf("%s: %s", device.name, interface_opts.descr) :\r\ng_strdup(device.name);\r\ndevice.hidden = FALSE;\r\ndevice.selected = TRUE;\r\ndevice.type = IF_PIPE;\r\n#ifdef CAN_SET_CAPTURE_BUFFER_SIZE\r\ndevice.buffer = interface_opts.buffer_size;\r\n#endif\r\n#if defined(HAVE_PCAP_CREATE)\r\ndevice.monitor_mode_enabled = interface_opts.monitor_mode;\r\ndevice.monitor_mode_supported = FALSE;\r\n#endif\r\ndevice.pmode = interface_opts.promisc_mode;\r\ndevice.has_snaplen = interface_opts.has_snaplen;\r\ndevice.snaplen = interface_opts.snaplen;\r\ndevice.cfilter = g_strdup(interface_opts.cfilter);\r\ndevice.active_dlt = interface_opts.linktype;\r\ndevice.addresses = NULL;\r\ndevice.no_addresses = 0;\r\ndevice.last_packets = 0;\r\ndevice.links = NULL;\r\ndevice.local = TRUE;\r\ndevice.locked = FALSE;\r\ndevice.if_info.name = g_strdup(interface_opts.name);\r\ndevice.if_info.friendly_name = NULL;\r\ndevice.if_info.vendor_description = g_strdup(interface_opts.descr);\r\ndevice.if_info.addrs = NULL;\r\ndevice.if_info.loopback = FALSE;\r\n#ifdef HAVE_EXTCAP\r\ndevice.if_info.extcap = g_strdup(interface_opts.extcap);\r\n#endif\r\ng_array_append_val(global_capture_opts.all_ifaces, device);\r\nglobal_capture_opts.num_selected++;\r\n}\r\n}\r\n}\r\nvoid\r\nfill_in_local_interfaces(void(*update_cb)(void))\r\n{\r\nGTimeVal start_time;\r\nGTimeVal end_time;\r\nfloat elapsed;\r\nstatic gboolean initialized = FALSE;\r\ng_get_current_time(&start_time);\r\ng_log(LOG_DOMAIN_MAIN, G_LOG_LEVEL_INFO, "fill_in_local_interfaces() starts");\r\nif (!initialized) {\r\nscan_local_interfaces(update_cb);\r\ninitialized = TRUE;\r\n}\r\ng_get_current_time(&end_time);\r\nelapsed = (float) ((end_time.tv_sec - start_time.tv_sec) +\r\n((end_time.tv_usec - start_time.tv_usec) / 1e6));\r\ng_log(LOG_DOMAIN_MAIN, G_LOG_LEVEL_INFO, "fill_in_local_interfaces() ends, taking %.3fs", elapsed);\r\n}\r\nvoid\r\nhide_interface(gchar* new_hide)\r\n{\r\ngchar *tok;\r\nguint i;\r\ninterface_t device;\r\ngboolean found = FALSE;\r\nGList *hidden_devices = NULL, *entry;\r\nif (new_hide != NULL) {\r\nfor (tok = strtok (new_hide, ","); tok; tok = strtok(NULL, ",")) {\r\nhidden_devices = g_list_append(hidden_devices, tok);\r\n}\r\n}\r\nfor (i = 0; i < global_capture_opts.all_ifaces->len; i++) {\r\ndevice = g_array_index(global_capture_opts.all_ifaces, interface_t, i);\r\nfound = FALSE;\r\nfor (entry = hidden_devices; entry != NULL; entry = g_list_next(entry)) {\r\nif (strcmp((char *)entry->data, device.name)==0) {\r\ndevice.hidden = TRUE;\r\nif (device.selected) {\r\ndevice.selected = FALSE;\r\nglobal_capture_opts.num_selected--;\r\n}\r\nfound = TRUE;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\ndevice.hidden = FALSE;\r\n}\r\nglobal_capture_opts.all_ifaces = g_array_remove_index(global_capture_opts.all_ifaces, i);\r\ng_array_insert_val(global_capture_opts.all_ifaces, i, device);\r\n}\r\ng_list_free(hidden_devices);\r\ng_free(new_hide);\r\n}\r\nvoid\r\nupdate_local_interfaces(void)\r\n{\r\ninterface_t device;\r\ngchar *descr;\r\nguint i;\r\nfor (i = 0; i < global_capture_opts.all_ifaces->len; i++) {\r\ndevice = g_array_index(global_capture_opts.all_ifaces, interface_t, i);\r\ndevice.type = capture_dev_user_linktype_find(device.name);\r\ng_free (device.display_name);\r\ndescr = capture_dev_user_descr_find(device.name);\r\ndevice.display_name = get_iface_display_name(descr, &device.if_info);\r\ng_free (descr);\r\ndevice.hidden = prefs_is_capture_device_hidden(device.name);\r\nfill_from_ifaces(&device);\r\nglobal_capture_opts.all_ifaces = g_array_remove_index(global_capture_opts.all_ifaces, i);\r\ng_array_insert_val(global_capture_opts.all_ifaces, i, device);\r\n}\r\n}
