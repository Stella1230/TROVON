const gchar *\r\ntvb_arphrdaddr_to_str(tvbuff_t *tvb, gint offset, int ad_len, guint16 type)\r\n{\r\nif (ad_len == 0)\r\nreturn "<No address>";\r\nif (ARP_HW_IS_ETHER(type, ad_len)) {\r\nreturn tvb_ether_to_str(tvb, offset);\r\n}\r\nreturn tvb_bytes_to_str(wmem_packet_scope(), tvb, offset, ad_len);\r\n}\r\nstatic const gchar *\r\narpproaddr_to_str(const guint8 *ad, int ad_len, guint16 type)\r\n{\r\naddress addr;\r\nif (ad_len == 0)\r\nreturn "<No address>";\r\nif (ARP_PRO_IS_IPv4(type, ad_len)) {\r\nset_address(&addr, AT_IPv4, 4, ad);\r\nreturn address_to_str(wmem_packet_scope(), &addr);\r\n}\r\nif (ARP_HW_IS_AX25(type, ad_len)) {\r\n{\r\nset_address(&addr, AT_AX25, AX25_ADDR_LEN, ad);\r\nreturn address_to_str(wmem_packet_scope(), &addr);\r\n}\r\n}\r\nreturn bytes_to_str(wmem_packet_scope(), ad, ad_len);\r\n}\r\nstatic const gchar *\r\ntvb_arpproaddr_to_str(tvbuff_t *tvb, gint offset, int ad_len, guint16 type)\r\n{\r\nreturn arpproaddr_to_str(tvb_get_ptr(tvb, offset, ad_len), ad_len, type);\r\n}\r\nstatic const gchar *\r\natmarpnum_to_str(tvbuff_t *tvb, int offset, int ad_tl)\r\n{\r\nint ad_len = ad_tl & ATMARP_LEN_MASK;\r\ngchar *cur;\r\nif (ad_len == 0)\r\nreturn "<No address>";\r\nif (ad_tl & ATMARP_IS_E164) {\r\ncur = (gchar *)wmem_alloc(wmem_packet_scope(), MAX_E164_STR_LEN+3+1);\r\nif (ad_len > MAX_E164_STR_LEN) {\r\ntvb_memcpy(tvb, cur, offset, MAX_E164_STR_LEN);\r\ng_snprintf(&cur[MAX_E164_STR_LEN], 3+1, "...");\r\n} else {\r\ntvb_memcpy(tvb, cur, offset, ad_len);\r\ncur[ad_len + 1] = '\0';\r\n}\r\nreturn cur;\r\n} else {\r\nreturn tvb_bytes_to_str(wmem_packet_scope(), tvb, offset, ad_len);\r\n}\r\n}\r\nstatic const gchar *\r\natmarpsubaddr_to_str(tvbuff_t *tvb, int offset, int ad_tl)\r\n{\r\nint ad_len = ad_tl & ATMARP_LEN_MASK;\r\nif (ad_len == 0)\r\nreturn "<No address>";\r\nreturn tvb_bytes_to_str(wmem_packet_scope(), tvb, offset, ad_len);\r\n}\r\nstatic void\r\ndissect_atm_number(tvbuff_t *tvb, packet_info* pinfo, int offset, int tl, int hf_e164,\r\nint hf_nsap, proto_tree *tree)\r\n{\r\nint len = tl & ATMARP_LEN_MASK;\r\nproto_item *ti;\r\nproto_tree *nsap_tree;\r\nif (tl & ATMARP_IS_E164)\r\nproto_tree_add_item(tree, hf_e164, tvb, offset, len, ENC_BIG_ENDIAN);\r\nelse {\r\nti = proto_tree_add_item(tree, hf_nsap, tvb, offset, len, ENC_BIG_ENDIAN);\r\nif (len >= 20) {\r\nnsap_tree = proto_item_add_subtree(ti, ett_atmarp_nsap);\r\ndissect_atm_nsap(tvb, pinfo, offset, len, nsap_tree);\r\n}\r\n}\r\n}\r\nvoid\r\ndissect_atm_nsap(tvbuff_t *tvb, packet_info* pinfo, int offset, int len, proto_tree *tree)\r\n{\r\nguint8 afi;\r\nproto_item* ti;\r\nafi = tvb_get_guint8(tvb, offset);\r\nti = proto_tree_add_item(tree, hf_atmarp_src_atm_afi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nswitch (afi) {\r\ncase 0x39:\r\ncase 0xBD:\r\nproto_tree_add_item(tree, (afi == 0xBD) ? hf_atmarp_src_atm_data_country_code_group : hf_atmarp_src_atm_data_country_code,\r\ntvb, offset + 1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_atmarp_src_atm_high_order_dsp, tvb, offset + 3, 10, ENC_NA);\r\nproto_tree_add_item(tree, hf_atmarp_src_atm_end_system_identifier, tvb, offset + 13, 6, ENC_NA);\r\nproto_tree_add_item(tree, hf_atmarp_src_atm_selector, tvb, offset + 19, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x47:\r\ncase 0xC5:\r\nproto_tree_add_item(tree, (afi == 0xC5) ? hf_atmarp_src_atm_international_code_designator_group : hf_atmarp_src_atm_international_code_designator,\r\ntvb, offset + 1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_atmarp_src_atm_high_order_dsp, tvb, offset + 3, 10, ENC_NA);\r\nproto_tree_add_item(tree, hf_atmarp_src_atm_end_system_identifier, tvb, offset + 13, 6, ENC_NA);\r\nproto_tree_add_item(tree, hf_atmarp_src_atm_selector, tvb, offset + 19, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x45:\r\ncase 0xC3:\r\nproto_tree_add_item(tree, (afi == 0xC3) ? hf_atmarp_src_atm_e_164_isdn_group : hf_atmarp_src_atm_e_164_isdn,\r\ntvb, offset + 1, 8, ENC_NA);\r\nproto_tree_add_item(tree, hf_atmarp_src_atm_high_order_dsp, tvb, offset + 9, 4, ENC_NA);\r\nproto_tree_add_item(tree, hf_atmarp_src_atm_end_system_identifier, tvb, offset + 13, 6, ENC_NA);\r\nproto_tree_add_item(tree, hf_atmarp_src_atm_selector, tvb, offset + 19, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nexpert_add_info(pinfo, ti, &ei_atmarp_src_atm_unknown_afi);\r\nproto_tree_add_item(tree, hf_atmarp_src_atm_rest_of_address, tvb, offset + 1, len - 1, ENC_NA);\r\nbreak;\r\n}\r\n}\r\nstatic guint\r\naddress_hash_func(gconstpointer v)\r\n{\r\nreturn GPOINTER_TO_UINT(v);\r\n}\r\nstatic gint\r\naddress_equal_func(gconstpointer v, gconstpointer v2)\r\n{\r\nreturn v == v2;\r\n}\r\nstatic guint\r\nduplicate_result_hash_func(gconstpointer v)\r\n{\r\nconst duplicate_result_key *key = (const duplicate_result_key*)v;\r\nreturn (key->frame_number + key->ip_address);\r\n}\r\nstatic gint\r\nduplicate_result_equal_func(gconstpointer v, gconstpointer v2)\r\n{\r\nconst duplicate_result_key *key1 = (const duplicate_result_key*)v;\r\nconst duplicate_result_key *key2 = (const duplicate_result_key*)v2;\r\nreturn (memcmp(key1, key2, sizeof(duplicate_result_key)) == 0);\r\n}\r\nstatic gboolean\r\ncheck_for_duplicate_addresses(packet_info *pinfo, proto_tree *tree,\r\ntvbuff_t *tvb,\r\nconst guint8 *mac, guint32 ip,\r\nguint32 *duplicate_ip)\r\n{\r\naddress_hash_value *value;\r\naddress_hash_value *result = NULL;\r\nduplicate_result_key result_key = {pinfo->num, ip};\r\nif (pinfo->fd->flags.visited) {\r\nresult = (address_hash_value *)g_hash_table_lookup(duplicate_result_hash_table,\r\n&result_key);\r\n}\r\nelse {\r\nvalue = (address_hash_value *)g_hash_table_lookup(address_hash_table, GUINT_TO_POINTER(ip));\r\nif (value != NULL)\r\n{\r\nif (pinfo->num > value->frame_num)\r\n{\r\nif ((memcmp(value->mac, mac, 6) == 0))\r\n{\r\nvalue->frame_num = pinfo->num;\r\nvalue->time_of_entry = pinfo->abs_ts.secs;\r\n}\r\nelse\r\n{\r\nduplicate_result_key *persistent_key = wmem_new(wmem_file_scope(), duplicate_result_key);\r\nmemcpy(persistent_key, &result_key, sizeof(duplicate_result_key));\r\nresult = wmem_new(wmem_file_scope(), address_hash_value);\r\nmemcpy(result, value, sizeof(address_hash_value));\r\ng_hash_table_insert(duplicate_result_hash_table, persistent_key, result);\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nvalue = wmem_new(wmem_file_scope(), struct address_hash_value);\r\nmemcpy(value->mac, mac, 6);\r\nvalue->frame_num = pinfo->num;\r\nvalue->time_of_entry = pinfo->abs_ts.secs;\r\ng_hash_table_insert(address_hash_table, GUINT_TO_POINTER(ip), value);\r\n}\r\n}\r\nif (result != NULL) {\r\nproto_tree *duplicate_tree;\r\nproto_item *ti;\r\naddress mac_addr, result_mac_addr;\r\nset_address(&mac_addr, AT_ETHER, 6, mac);\r\nset_address(&result_mac_addr, AT_ETHER, 6, result->mac);\r\nduplicate_tree = proto_tree_add_subtree_format(tree, tvb, 0, 0, ett_arp_duplicate_address, &ti,\r\n"Duplicate IP address detected for %s (%s) - also in use by %s (frame %u)",\r\narpproaddr_to_str((guint8*)&ip, 4, ETHERTYPE_IP),\r\naddress_to_str(wmem_packet_scope(), &mac_addr),\r\naddress_to_str(wmem_packet_scope(), &result_mac_addr),\r\nresult->frame_num);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nti = proto_tree_add_uint(duplicate_tree, hf_arp_duplicate_ip_address_earlier_frame,\r\ntvb, 0, 0, result->frame_num);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nexpert_add_info_format(pinfo, ti,\r\n&ei_seq_arp_dup_ip,\r\n"Duplicate IP address configured (%s)",\r\narpproaddr_to_str((guint8*)&ip, 4, ETHERTYPE_IP));\r\nti = proto_tree_add_uint(duplicate_tree,\r\nhf_arp_duplicate_ip_address_seconds_since_earlier_frame,\r\ntvb, 0, 0,\r\n(guint32)(pinfo->abs_ts.secs - result->time_of_entry));\r\nPROTO_ITEM_SET_GENERATED(ti);\r\n*duplicate_ip = ip;\r\n}\r\nreturn (result != NULL);\r\n}\r\nstatic void\r\narp_init_protocol(void)\r\n{\r\naddress_hash_table = g_hash_table_new(address_hash_func, address_equal_func);\r\nduplicate_result_hash_table = g_hash_table_new(duplicate_result_hash_func,\r\nduplicate_result_equal_func);\r\n}\r\nstatic void\r\narp_cleanup_protocol(void)\r\n{\r\ng_hash_table_destroy(address_hash_table);\r\ng_hash_table_destroy(duplicate_result_hash_table);\r\n}\r\nstatic void\r\nrequest_seen(packet_info *pinfo)\r\n{\r\nif (p_get_proto_data(wmem_file_scope(), pinfo, proto_arp, 0) == 0)\r\n{\r\narp_request_count++;\r\n}\r\n}\r\nstatic void\r\ncheck_for_storm_count(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\ngboolean report_storm = FALSE;\r\nif (p_get_proto_data(wmem_file_scope(), pinfo, proto_arp, 0) != 0)\r\n{\r\nreport_storm = (p_get_proto_data(wmem_file_scope(), pinfo, proto_arp, 0) == (void*)STORM);\r\n}\r\nelse\r\n{\r\ngint seconds_delta = (gint) (pinfo->abs_ts.secs - time_at_start_of_count.secs);\r\ngint nseconds_delta = pinfo->abs_ts.nsecs - time_at_start_of_count.nsecs;\r\ngint gap = (seconds_delta*1000) + (nseconds_delta / 1000000);\r\nif ((gap > (gint)global_arp_detect_request_storm_period) ||\r\n(gap < 0))\r\n{\r\narp_request_count = 1;\r\ntime_at_start_of_count = pinfo->abs_ts;\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_arp, 0, (void*)NO_STORM);\r\nreturn;\r\n}\r\nelse\r\nif (arp_request_count > global_arp_detect_request_storm_packets)\r\n{\r\nreport_storm = TRUE;\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_arp, 0, (void*)STORM);\r\ntime_at_start_of_count = pinfo->abs_ts;\r\n}\r\nelse\r\n{\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_arp, 0, (void*)NO_STORM);\r\n}\r\n}\r\nif (report_storm)\r\n{\r\nproto_tree_add_expert_format(tree, pinfo, &ei_seq_arp_storm, tvb, 0, 0,\r\n"ARP packet storm detected (%u packets in < %u ms)",\r\nglobal_arp_detect_request_storm_packets,\r\nglobal_arp_detect_request_storm_period);\r\narp_request_count = 0;\r\n}\r\n}\r\nstatic int\r\ndissect_atmarp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nguint16 ar_hrd;\r\nguint16 ar_pro;\r\nguint8 ar_shtl;\r\nguint8 ar_shl;\r\nguint8 ar_sstl;\r\nguint8 ar_ssl;\r\nguint16 ar_op;\r\nguint8 ar_spln;\r\nguint8 ar_thtl;\r\nguint8 ar_thl;\r\nguint8 ar_tstl;\r\nguint8 ar_tsl;\r\nguint8 ar_tpln;\r\nint tot_len;\r\nproto_tree *arp_tree;\r\nproto_item *ti;\r\nconst gchar *op_str;\r\nint sha_offset, ssa_offset, spa_offset;\r\nint tha_offset, tsa_offset, tpa_offset;\r\nconst gchar *sha_str, *ssa_str, *spa_str;\r\nconst gchar *tha_str, *tsa_str, *tpa_str;\r\nproto_tree *tl_tree;\r\nar_hrd = tvb_get_ntohs(tvb, ATM_AR_HRD);\r\nar_pro = tvb_get_ntohs(tvb, ATM_AR_PRO);\r\nar_shtl = tvb_get_guint8(tvb, ATM_AR_SHTL);\r\nar_shl = ar_shtl & ATMARP_LEN_MASK;\r\nar_sstl = tvb_get_guint8(tvb, ATM_AR_SSTL);\r\nar_ssl = ar_sstl & ATMARP_LEN_MASK;\r\nar_op = tvb_get_ntohs(tvb, AR_OP);\r\nar_spln = tvb_get_guint8(tvb, ATM_AR_SPLN);\r\nar_thtl = tvb_get_guint8(tvb, ATM_AR_THTL);\r\nar_thl = ar_thtl & ATMARP_LEN_MASK;\r\nar_tstl = tvb_get_guint8(tvb, ATM_AR_TSTL);\r\nar_tsl = ar_tstl & ATMARP_LEN_MASK;\r\nar_tpln = tvb_get_guint8(tvb, ATM_AR_TPLN);\r\ntot_len = MIN_ATMARP_HEADER_SIZE + ar_shl + ar_ssl + ar_spln +\r\nar_thl + ar_tsl + ar_tpln;\r\ntvb_set_reported_length(tvb, tot_len);\r\nsha_offset = MIN_ATMARP_HEADER_SIZE;\r\nsha_str = atmarpnum_to_str(tvb, sha_offset, ar_shtl);\r\nssa_offset = sha_offset + ar_shl;\r\nif (ar_ssl != 0) {\r\nssa_str = atmarpsubaddr_to_str(tvb, ssa_offset, ar_sstl);\r\n} else {\r\nssa_str = NULL;\r\n}\r\nspa_offset = ssa_offset + ar_ssl;\r\nspa_str = tvb_arpproaddr_to_str(tvb, spa_offset, ar_spln, ar_pro);\r\ntha_offset = spa_offset + ar_spln;\r\ntha_str = atmarpnum_to_str(tvb, tha_offset, ar_thtl);\r\ntsa_offset = tha_offset + ar_thl;\r\nif (ar_tsl != 0) {\r\ntsa_str = atmarpsubaddr_to_str(tvb, tsa_offset, ar_tstl);\r\n} else {\r\ntsa_str = NULL;\r\n}\r\ntpa_offset = tsa_offset + ar_tsl;\r\ntpa_str = tvb_arpproaddr_to_str(tvb, tpa_offset, ar_tpln, ar_pro);\r\nswitch (ar_op) {\r\ncase ARPOP_REQUEST:\r\ncase ARPOP_REPLY:\r\ncase ATMARPOP_NAK:\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ATMARP");\r\nbreak;\r\ncase ARPOP_RREQUEST:\r\ncase ARPOP_RREPLY:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ATMRARP");\r\nbreak;\r\ncase ARPOP_IREQUEST:\r\ncase ARPOP_IREPLY:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Inverse ATMARP");\r\nbreak;\r\ncase ARPOP_MARS_REQUEST:\r\ncase ARPOP_MARS_MULTI:\r\ncase ARPOP_MARS_MSERV:\r\ncase ARPOP_MARS_JOIN:\r\ncase ARPOP_MARS_LEAVE:\r\ncase ARPOP_MARS_NAK:\r\ncase ARPOP_MARS_UNSERV:\r\ncase ARPOP_MARS_SJOIN:\r\ncase ARPOP_MARS_SLEAVE:\r\ncase ARPOP_MARS_GROUPLIST_REQUEST:\r\ncase ARPOP_MARS_GROUPLIST_REPLY:\r\ncase ARPOP_MARS_REDIRECT_MAP:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MARS");\r\nbreak;\r\ncase ARPOP_MAPOS_UNARP:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MAPOS");\r\nbreak;\r\n}\r\nswitch (ar_op) {\r\ncase ARPOP_REQUEST:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Who has %s? Tell %s",\r\ntpa_str, spa_str);\r\nbreak;\r\ncase ARPOP_REPLY:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s is at %s%s%s", spa_str, sha_str,\r\n((ssa_str != NULL) ? "," : ""),\r\n((ssa_str != NULL) ? ssa_str : ""));\r\nbreak;\r\ncase ARPOP_IREQUEST:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Who is %s%s%s? Tell %s%s%s",\r\ntha_str,\r\n((tsa_str != NULL) ? "," : ""),\r\n((tsa_str != NULL) ? tsa_str : ""),\r\nsha_str,\r\n((ssa_str != NULL) ? "," : ""),\r\n((ssa_str != NULL) ? ssa_str : ""));\r\nbreak;\r\ncase ARPOP_IREPLY:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s%s%s is at %s",\r\nsha_str,\r\n((ssa_str != NULL) ? "," : ""),\r\n((ssa_str != NULL) ? ssa_str : ""),\r\nspa_str);\r\nbreak;\r\ncase ATMARPOP_NAK:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "I don't know where %s is", spa_str);\r\nbreak;\r\ncase ARPOP_MARS_REQUEST:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS request from %s%s%s at %s",\r\nsha_str,\r\n((ssa_str != NULL) ? "," : ""),\r\n((ssa_str != NULL) ? ssa_str : ""),\r\nspa_str);\r\nbreak;\r\ncase ARPOP_MARS_MULTI:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS MULTI request from %s%s%s at %s",\r\nsha_str,\r\n((ssa_str != NULL) ? "," : ""),\r\n((ssa_str != NULL) ? ssa_str : ""),\r\nspa_str);\r\nbreak;\r\ncase ARPOP_MARS_MSERV:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS MSERV request from %s%s%s at %s",\r\nsha_str,\r\n((ssa_str != NULL) ? "," : ""),\r\n((ssa_str != NULL) ? ssa_str : ""),\r\nspa_str);\r\nbreak;\r\ncase ARPOP_MARS_JOIN:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS JOIN request from %s%s%s at %s",\r\nsha_str,\r\n((ssa_str != NULL) ? "," : ""),\r\n((ssa_str != NULL) ? ssa_str : ""),\r\nspa_str);\r\nbreak;\r\ncase ARPOP_MARS_LEAVE:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS LEAVE from %s%s%s at %s",\r\nsha_str,\r\n((ssa_str != NULL) ? "," : ""),\r\n((ssa_str != NULL) ? ssa_str : ""),\r\nspa_str);\r\nbreak;\r\ncase ARPOP_MARS_NAK:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS NAK from %s%s%s at %s",\r\nsha_str,\r\n((ssa_str != NULL) ? "," : ""),\r\n((ssa_str != NULL) ? ssa_str : ""),\r\nspa_str);\r\nbreak;\r\ncase ARPOP_MARS_UNSERV:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS UNSERV request from %s%s%s at %s",\r\nsha_str,\r\n((ssa_str != NULL) ? "," : ""),\r\n((ssa_str != NULL) ? ssa_str : ""),\r\nspa_str);\r\nbreak;\r\ncase ARPOP_MARS_SJOIN:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS SJOIN request from %s%s%s at %s",\r\nsha_str,\r\n((ssa_str != NULL) ? "," : ""),\r\n((ssa_str != NULL) ? ssa_str : ""),\r\nspa_str);\r\nbreak;\r\ncase ARPOP_MARS_SLEAVE:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS SLEAVE from %s%s%s at %s",\r\nsha_str,\r\n((ssa_str != NULL) ? "," : ""),\r\n((ssa_str != NULL) ? ssa_str : ""),\r\nspa_str);\r\nbreak;\r\ncase ARPOP_MARS_GROUPLIST_REQUEST:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS grouplist request from %s%s%s at %s",\r\nsha_str,\r\n((ssa_str != NULL) ? "," : ""),\r\n((ssa_str != NULL) ? ssa_str : ""),\r\nspa_str);\r\nbreak;\r\ncase ARPOP_MARS_GROUPLIST_REPLY:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS grouplist reply from %s%s%s at %s",\r\nsha_str,\r\n((ssa_str != NULL) ? "," : ""),\r\n((ssa_str != NULL) ? ssa_str : ""),\r\nspa_str);\r\nbreak;\r\ncase ARPOP_MARS_REDIRECT_MAP:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS redirect map from %s%s%s at %s",\r\nsha_str,\r\n((ssa_str != NULL) ? "," : ""),\r\n((ssa_str != NULL) ? ssa_str : ""),\r\nspa_str);\r\nbreak;\r\ncase ARPOP_MAPOS_UNARP:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MAPOS UNARP request from %s%s%s at %s",\r\nsha_str,\r\n((ssa_str != NULL) ? "," : ""),\r\n((ssa_str != NULL) ? ssa_str : ""),\r\nspa_str);\r\nbreak;\r\ncase ARPOP_EXP1:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Experimental 1 ( opcode %d )", ar_op);\r\nbreak;\r\ncase ARPOP_EXP2:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Experimental 2 ( opcode %d )", ar_op);\r\nbreak;\r\ncase 0:\r\ncase 65535:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Reserved opcode %d", ar_op);\r\nbreak;\r\ndefault:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Unknown ATMARP opcode 0x%04x", ar_op);\r\nbreak;\r\n}\r\nif (tree) {\r\nif ((op_str = try_val_to_str(ar_op, atmop_vals)))\r\nti = proto_tree_add_protocol_format(tree, proto_arp, tvb, 0, tot_len,\r\n"ATM Address Resolution Protocol (%s)",\r\nop_str);\r\nelse\r\nti = proto_tree_add_protocol_format(tree, proto_arp, tvb, 0, tot_len,\r\n"ATM Address Resolution Protocol (opcode 0x%04x)", ar_op);\r\narp_tree = proto_item_add_subtree(ti, ett_arp);\r\nproto_tree_add_uint(arp_tree, hf_arp_hard_type, tvb, ATM_AR_HRD, 2, ar_hrd);\r\nproto_tree_add_uint(arp_tree, hf_arp_proto_type, tvb, ATM_AR_PRO, 2,ar_pro);\r\ntl_tree = proto_tree_add_subtree_format(arp_tree, tvb, ATM_AR_SHTL, 1,\r\nett_atmarp_tl, NULL,\r\n"Sender ATM number type/length: %s/%u",\r\n(ar_shtl & ATMARP_IS_E164 ?\r\n"E.164" :\r\n"ATM Forum NSAPA"),\r\nar_shl);\r\nproto_tree_add_boolean(tl_tree, hf_atmarp_sht, tvb, ATM_AR_SHTL, 1, ar_shtl);\r\nproto_tree_add_uint(tl_tree, hf_atmarp_shl, tvb, ATM_AR_SHTL, 1, ar_shtl);\r\ntl_tree = proto_tree_add_subtree_format(arp_tree, tvb, ATM_AR_SSTL, 1,\r\nett_atmarp_tl, NULL,\r\n"Sender ATM subaddress type/length: %s/%u",\r\n(ar_sstl & ATMARP_IS_E164 ?\r\n"E.164" :\r\n"ATM Forum NSAPA"),\r\nar_ssl);\r\nproto_tree_add_boolean(tl_tree, hf_atmarp_sst, tvb, ATM_AR_SSTL, 1, ar_sstl);\r\nproto_tree_add_uint(tl_tree, hf_atmarp_ssl, tvb, ATM_AR_SSTL, 1, ar_sstl);\r\nproto_tree_add_uint(arp_tree, hf_arp_opcode, tvb, AR_OP, 2, ar_op);\r\nproto_tree_add_uint(arp_tree, hf_atmarp_spln, tvb, ATM_AR_SPLN, 1, ar_spln);\r\ntl_tree = proto_tree_add_subtree_format(arp_tree, tvb, ATM_AR_THTL, 1,\r\nett_atmarp_tl, NULL,\r\n"Target ATM number type/length: %s/%u",\r\n(ar_thtl & ATMARP_IS_E164 ?\r\n"E.164" :\r\n"ATM Forum NSAPA"),\r\nar_thl);\r\nproto_tree_add_boolean(tl_tree, hf_atmarp_tht, tvb, ATM_AR_THTL, 1, ar_thtl);\r\nproto_tree_add_uint(tl_tree, hf_atmarp_thl, tvb, ATM_AR_THTL, 1, ar_thtl);\r\ntl_tree = proto_tree_add_subtree_format(arp_tree, tvb, ATM_AR_TSTL, 1,\r\nett_atmarp_tl, NULL,\r\n"Target ATM subaddress type/length: %s/%u",\r\n(ar_tstl & ATMARP_IS_E164 ?\r\n"E.164" :\r\n"ATM Forum NSAPA"),\r\nar_tsl);\r\nproto_tree_add_boolean(tl_tree, hf_atmarp_tst, tvb, ATM_AR_TSTL, 1, ar_tstl);\r\nproto_tree_add_uint(tl_tree, hf_atmarp_tsl, tvb, ATM_AR_TSTL, 1, ar_tstl);\r\nproto_tree_add_uint(arp_tree, hf_atmarp_tpln, tvb, ATM_AR_TPLN, 1, ar_tpln);\r\nif (ar_shl != 0)\r\ndissect_atm_number(tvb, pinfo, sha_offset, ar_shtl, hf_atmarp_src_atm_num_e164,\r\nhf_atmarp_src_atm_num_nsap, arp_tree);\r\nif (ar_ssl != 0)\r\nproto_tree_add_bytes_format_value(arp_tree, hf_atmarp_src_atm_subaddr, tvb, ssa_offset,\r\nar_ssl, NULL, "%s", ssa_str);\r\nif (ar_spln != 0) {\r\nproto_tree_add_item(arp_tree,\r\nARP_PRO_IS_IPv4(ar_pro, ar_spln) ? hf_arp_src_proto_ipv4\r\n: hf_arp_src_proto,\r\ntvb, spa_offset, ar_spln, ENC_BIG_ENDIAN);\r\n}\r\nif (ar_thl != 0)\r\ndissect_atm_number(tvb, pinfo, tha_offset, ar_thtl, hf_atmarp_dst_atm_num_e164,\r\nhf_atmarp_dst_atm_num_nsap, arp_tree);\r\nif (ar_tsl != 0)\r\nproto_tree_add_bytes_format_value(arp_tree, hf_atmarp_dst_atm_subaddr, tvb, tsa_offset,\r\nar_tsl, NULL, "%s", tsa_str);\r\nif (ar_tpln != 0) {\r\nproto_tree_add_item(arp_tree,\r\nARP_PRO_IS_IPv4(ar_pro, ar_tpln) ? hf_arp_dst_proto_ipv4\r\n: hf_arp_dst_proto,\r\ntvb, tpa_offset, ar_tpln, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_ax25arp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\n#define ARP_AX25 204\r\nguint16 ar_hrd;\r\nguint16 ar_pro;\r\nguint8 ar_hln;\r\nguint8 ar_pln;\r\nguint16 ar_op;\r\nint tot_len;\r\nproto_tree *arp_tree = NULL;\r\nproto_item *ti;\r\nconst gchar *op_str;\r\nint sha_offset, spa_offset, tha_offset, tpa_offset;\r\nconst gchar *spa_str, *tpa_str;\r\ngboolean is_gratuitous;\r\nar_hrd = tvb_get_ntohs(tvb, AR_HRD);\r\nar_pro = tvb_get_ntohs(tvb, AR_PRO);\r\nar_hln = tvb_get_guint8(tvb, AR_HLN);\r\nar_pln = tvb_get_guint8(tvb, AR_PLN);\r\nar_op = tvb_get_ntohs(tvb, AR_OP);\r\ntot_len = MIN_ARP_HEADER_SIZE + ar_hln*2 + ar_pln*2;\r\ntvb_set_reported_length(tvb, tot_len);\r\nswitch (ar_op) {\r\ncase ARPOP_REQUEST:\r\nif (global_arp_detect_request_storm)\r\nrequest_seen(pinfo);\r\ncase ARPOP_REPLY:\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ARP");\r\nbreak;\r\ncase ARPOP_RREQUEST:\r\ncase ARPOP_RREPLY:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "RARP");\r\nbreak;\r\ncase ARPOP_IREQUEST:\r\ncase ARPOP_IREPLY:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Inverse ARP");\r\nbreak;\r\n}\r\nsha_offset = MIN_ARP_HEADER_SIZE;\r\nspa_offset = sha_offset + ar_hln;\r\ntha_offset = spa_offset + ar_pln;\r\ntpa_offset = tha_offset + ar_hln;\r\nspa_str = tvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro);\r\ntpa_str = tvb_arpproaddr_to_str(tvb, tpa_offset, ar_pln, ar_pro);\r\nif (((ar_op == ARPOP_REQUEST) || (ar_op == ARPOP_REPLY)) && (strcmp(spa_str, tpa_str) == 0))\r\nis_gratuitous = TRUE;\r\nelse\r\nis_gratuitous = FALSE;\r\nswitch (ar_op) {\r\ncase ARPOP_REQUEST:\r\nif (is_gratuitous)\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Gratuitous ARP for %s (Request)", tpa_str);\r\nelse\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Who has %s? Tell %s", tpa_str, spa_str);\r\nbreak;\r\ncase ARPOP_REPLY:\r\nif (is_gratuitous)\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Gratuitous ARP for %s (Reply)", spa_str);\r\nelse\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s is at %s",\r\nspa_str,\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd));\r\nbreak;\r\ncase ARPOP_RREQUEST:\r\ncase ARPOP_IREQUEST:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Who is %s? Tell %s",\r\ntvb_arphrdaddr_to_str(tvb, tha_offset, ar_hln, ar_hrd),\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd));\r\nbreak;\r\ncase ARPOP_RREPLY:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s is at %s",\r\ntvb_arphrdaddr_to_str(tvb, tha_offset, ar_hln, ar_hrd),\r\ntpa_str);\r\nbreak;\r\ncase ARPOP_IREPLY:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s is at %s",\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd),\r\nspa_str);\r\nbreak;\r\ndefault:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Unknown ARP opcode 0x%04x", ar_op);\r\nbreak;\r\n}\r\nif (tree) {\r\nif ((op_str = try_val_to_str(ar_op, op_vals))) {\r\nif (is_gratuitous && (ar_op == ARPOP_REQUEST))\r\nop_str = "request/gratuitous ARP";\r\nif (is_gratuitous && (ar_op == ARPOP_REPLY))\r\nop_str = "reply/gratuitous ARP";\r\nti = proto_tree_add_protocol_format(tree, proto_arp, tvb, 0, tot_len,\r\n"Address Resolution Protocol (%s)", op_str);\r\n} else\r\nti = proto_tree_add_protocol_format(tree, proto_arp, tvb, 0, tot_len,\r\n"Address Resolution Protocol (opcode 0x%04x)", ar_op);\r\narp_tree = proto_item_add_subtree(ti, ett_arp);\r\nproto_tree_add_uint(arp_tree, hf_arp_hard_type, tvb, AR_HRD, 2, ar_hrd);\r\nproto_tree_add_uint(arp_tree, hf_arp_proto_type, tvb, AR_PRO, 2, ar_pro);\r\nproto_tree_add_uint(arp_tree, hf_arp_hard_size, tvb, AR_HLN, 1, ar_hln);\r\nproto_tree_add_uint(arp_tree, hf_arp_proto_size, tvb, AR_PLN, 1, ar_pln);\r\nproto_tree_add_uint(arp_tree, hf_arp_opcode, tvb, AR_OP, 2, ar_op);\r\nif (ar_hln != 0) {\r\nproto_tree_add_item(arp_tree,\r\nARP_HW_IS_AX25(ar_hrd, ar_hln) ? hf_arp_src_hw_ax25 : hf_arp_src_hw,\r\ntvb, sha_offset, ar_hln, FALSE);\r\n}\r\nif (ar_pln != 0) {\r\nproto_tree_add_item(arp_tree,\r\nARP_PRO_IS_IPv4(ar_pro, ar_pln) ? hf_arp_src_proto_ipv4\r\n: hf_arp_src_proto,\r\ntvb, spa_offset, ar_pln, FALSE);\r\n}\r\nif (ar_hln != 0) {\r\nproto_tree_add_item(arp_tree,\r\nARP_HW_IS_AX25(ar_hrd, ar_hln) ? hf_arp_dst_hw_ax25 : hf_arp_dst_hw,\r\ntvb, tha_offset, ar_hln, FALSE);\r\n}\r\nif (ar_pln != 0) {\r\nproto_tree_add_item(arp_tree,\r\nARP_PRO_IS_IPv4(ar_pro, ar_pln) ? hf_arp_dst_proto_ipv4\r\n: hf_arp_dst_proto,\r\ntvb, tpa_offset, ar_pln, FALSE);\r\n}\r\n}\r\nif (global_arp_detect_request_storm)\r\n{\r\ncheck_for_storm_count(tvb, pinfo, arp_tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\ngboolean\r\ncapture_arp(const guchar *pd _U_, int offset _U_, int len _U_, capture_packet_info_t *cpinfo, const union wtap_pseudo_header *pseudo_header _U_)\r\n{\r\ncapture_dissector_increment_count(cpinfo, proto_arp);\r\nreturn TRUE;\r\n}\r\nstatic int\r\ndissect_arp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nguint16 ar_hrd;\r\nguint16 ar_pro;\r\nguint8 ar_hln;\r\nguint8 ar_pln;\r\nguint16 ar_op;\r\nint tot_len;\r\nproto_tree *arp_tree = NULL;\r\nproto_item *ti, *item;\r\nconst gchar *op_str;\r\nint sha_offset, spa_offset, tha_offset, tpa_offset;\r\ngboolean is_gratuitous;\r\ngboolean duplicate_detected = FALSE;\r\nguint32 duplicate_ip = 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ARP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nar_hrd = tvb_get_ntohs(tvb, AR_HRD);\r\nif (ar_hrd == ARPHRD_ATM2225) {\r\ncall_dissector(atmarp_handle, tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nif (ar_hrd == ARPHRD_AX25) {\r\ncall_dissector(ax25arp_handle, tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nar_pro = tvb_get_ntohs(tvb, AR_PRO);\r\nar_hln = tvb_get_guint8(tvb, AR_HLN);\r\nar_pln = tvb_get_guint8(tvb, AR_PLN);\r\nar_op = tvb_get_ntohs(tvb, AR_OP);\r\ntot_len = MIN_ARP_HEADER_SIZE + ar_hln*2 + ar_pln*2;\r\ntvb_set_reported_length(tvb, tot_len);\r\nswitch (ar_op) {\r\ncase ARPOP_REQUEST:\r\nif (global_arp_detect_request_storm)\r\n{\r\nrequest_seen(pinfo);\r\n}\r\ncase ARPOP_REPLY:\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ARP");\r\nbreak;\r\ncase ARPOP_RREQUEST:\r\ncase ARPOP_RREPLY:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "RARP");\r\nbreak;\r\ncase ARPOP_DRARPREQUEST:\r\ncase ARPOP_DRARPREPLY:\r\ncase ARPOP_DRARPERROR:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "DRARP");\r\nbreak;\r\ncase ARPOP_IREQUEST:\r\ncase ARPOP_IREPLY:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Inverse ARP");\r\nbreak;\r\ncase ARPOP_MARS_REQUEST:\r\ncase ARPOP_MARS_MULTI:\r\ncase ARPOP_MARS_MSERV:\r\ncase ARPOP_MARS_JOIN:\r\ncase ARPOP_MARS_LEAVE:\r\ncase ARPOP_MARS_NAK:\r\ncase ARPOP_MARS_UNSERV:\r\ncase ARPOP_MARS_SJOIN:\r\ncase ARPOP_MARS_SLEAVE:\r\ncase ARPOP_MARS_GROUPLIST_REQUEST:\r\ncase ARPOP_MARS_GROUPLIST_REPLY:\r\ncase ARPOP_MARS_REDIRECT_MAP:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MARS");\r\nbreak;\r\ncase ARPOP_MAPOS_UNARP:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MAPOS");\r\nbreak;\r\n}\r\nsha_offset = MIN_ARP_HEADER_SIZE;\r\nspa_offset = sha_offset + ar_hln;\r\ntha_offset = spa_offset + ar_pln;\r\ntpa_offset = tha_offset + ar_hln;\r\nif ((ar_op == ARPOP_REPLY || ar_op == ARPOP_REQUEST) &&\r\nARP_HW_IS_ETHER(ar_hrd, ar_hln) &&\r\nARP_PRO_IS_IPv4(ar_pro, ar_pln)) {\r\nguint32 ip;\r\nconst guint8 *mac;\r\nip = tvb_get_ipv4(tvb, spa_offset);\r\nmac = (const guint8*)tvb_memdup(wmem_packet_scope(), tvb, sha_offset, 6);\r\nif ((mac[0] & 0x01) == 0 && memcmp(mac, mac_allzero, 6) != 0 && ip != 0)\r\n{\r\nif (global_arp_register_network_address_binding)\r\n{\r\nadd_ether_byip(ip, mac);\r\n}\r\nif (global_arp_detect_duplicate_ip_addresses)\r\n{\r\nduplicate_detected =\r\ncheck_for_duplicate_addresses(pinfo, tree, tvb, mac, ip,\r\n&duplicate_ip);\r\n}\r\n}\r\nip = tvb_get_ipv4(tvb, tpa_offset);\r\nmac = (const guint8*)tvb_memdup(wmem_packet_scope(), tvb, tha_offset, 6);\r\nif ((mac[0] & 0x01) == 0 && memcmp(mac, mac_allzero, 6) != 0 && ip != 0\r\n&& ar_op != ARPOP_REQUEST)\r\n{\r\nif (global_arp_register_network_address_binding)\r\n{\r\nadd_ether_byip(ip, mac);\r\n}\r\nif (global_arp_detect_duplicate_ip_addresses && (duplicate_ip!=ip))\r\n{\r\nduplicate_detected =\r\ncheck_for_duplicate_addresses(pinfo, tree, tvb, mac, ip,\r\n&duplicate_ip);\r\n}\r\n}\r\n}\r\nif (((ar_op == ARPOP_REQUEST) || (ar_op == ARPOP_REPLY)) &&\r\n(tvb_memeql(tvb, spa_offset, tvb_get_ptr(tvb, tpa_offset, ar_pln), ar_pln) == 0))\r\nis_gratuitous = TRUE;\r\nelse\r\nis_gratuitous = FALSE;\r\nswitch (ar_op) {\r\ncase ARPOP_REQUEST:\r\nif (is_gratuitous)\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Gratuitous ARP for %s (Request)",\r\ntvb_arpproaddr_to_str(tvb, tpa_offset, ar_pln, ar_pro));\r\nelse\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Who has %s? Tell %s",\r\ntvb_arpproaddr_to_str(tvb, tpa_offset, ar_pln, ar_pro),\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro));\r\nbreak;\r\ncase ARPOP_REPLY:\r\nif (is_gratuitous)\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Gratuitous ARP for %s (Reply)",\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro));\r\nelse\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s is at %s",\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro),\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd));\r\nbreak;\r\ncase ARPOP_RREQUEST:\r\ncase ARPOP_IREQUEST:\r\ncase ARPOP_DRARPREQUEST:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Who is %s? Tell %s",\r\ntvb_arphrdaddr_to_str(tvb, tha_offset, ar_hln, ar_hrd),\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd));\r\nbreak;\r\ncase ARPOP_RREPLY:\r\ncase ARPOP_DRARPREPLY:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s is at %s",\r\ntvb_arphrdaddr_to_str(tvb, tha_offset, ar_hln, ar_hrd),\r\ntvb_arpproaddr_to_str(tvb, tpa_offset, ar_pln, ar_pro));\r\nbreak;\r\ncase ARPOP_DRARPERROR:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "DRARP Error");\r\nbreak;\r\ncase ARPOP_IREPLY:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s is at %s",\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd),\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro));\r\nbreak;\r\ncase ATMARPOP_NAK:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "ARP NAK");\r\nbreak;\r\ncase ARPOP_MARS_REQUEST:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS request from %s at %s",\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd),\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro));\r\nbreak;\r\ncase ARPOP_MARS_MULTI:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS MULTI request from %s at %s",\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd),\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro));\r\nbreak;\r\ncase ARPOP_MARS_MSERV:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS MSERV request from %s at %s",\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd),\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro));\r\nbreak;\r\ncase ARPOP_MARS_JOIN:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS JOIN request from %s at %s",\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd),\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro));\r\nbreak;\r\ncase ARPOP_MARS_LEAVE:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS LEAVE from %s at %s",\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd),\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro));\r\nbreak;\r\ncase ARPOP_MARS_NAK:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS NAK from %s at %s",\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd),\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro));\r\nbreak;\r\ncase ARPOP_MARS_UNSERV:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS UNSERV request from %s at %s",\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd),\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro));\r\nbreak;\r\ncase ARPOP_MARS_SJOIN:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS SJOIN request from %s at %s",\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd),\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro));\r\nbreak;\r\ncase ARPOP_MARS_SLEAVE:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS SLEAVE from %s at %s",\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd),\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro));\r\nbreak;\r\ncase ARPOP_MARS_GROUPLIST_REQUEST:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS grouplist request from %s at %s",\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd),\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro));\r\nbreak;\r\ncase ARPOP_MARS_GROUPLIST_REPLY:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS grouplist reply from %s at %s",\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd),\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro));\r\nbreak;\r\ncase ARPOP_MARS_REDIRECT_MAP:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MARS redirect map from %s at %s",\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd),\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro));\r\nbreak;\r\ncase ARPOP_MAPOS_UNARP:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MAPOS UNARP request from %s at %s",\r\ntvb_arphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd),\r\ntvb_arpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro));\r\nbreak;\r\ncase ARPOP_EXP1:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Experimental 1 ( opcode %d )", ar_op);\r\nbreak;\r\ncase ARPOP_EXP2:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Experimental 2 ( opcode %d )", ar_op);\r\nbreak;\r\ncase 0:\r\ncase 65535:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Reserved opcode %d", ar_op);\r\nbreak;\r\ndefault:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Unknown ARP opcode 0x%04x", ar_op);\r\nbreak;\r\n}\r\nif (tree) {\r\nif ((op_str = try_val_to_str(ar_op, op_vals))) {\r\nif (is_gratuitous && (ar_op == ARPOP_REQUEST))\r\nop_str = "request/gratuitous ARP";\r\nif (is_gratuitous && (ar_op == ARPOP_REPLY))\r\nop_str = "reply/gratuitous ARP";\r\nti = proto_tree_add_protocol_format(tree, proto_arp, tvb, 0, tot_len,\r\n"Address Resolution Protocol (%s)", op_str);\r\n} else\r\nti = proto_tree_add_protocol_format(tree, proto_arp, tvb, 0, tot_len,\r\n"Address Resolution Protocol (opcode 0x%04x)", ar_op);\r\narp_tree = proto_item_add_subtree(ti, ett_arp);\r\nproto_tree_add_uint(arp_tree, hf_arp_hard_type, tvb, AR_HRD, 2, ar_hrd);\r\nproto_tree_add_uint(arp_tree, hf_arp_proto_type, tvb, AR_PRO, 2, ar_pro);\r\nproto_tree_add_uint(arp_tree, hf_arp_hard_size, tvb, AR_HLN, 1, ar_hln);\r\nproto_tree_add_uint(arp_tree, hf_arp_proto_size, tvb, AR_PLN, 1, ar_pln);\r\nproto_tree_add_uint(arp_tree, hf_arp_opcode, tvb, AR_OP, 2, ar_op);\r\nif (is_gratuitous)\r\n{\r\nitem = proto_tree_add_boolean(arp_tree, hf_arp_isgratuitous, tvb, 0, 0, is_gratuitous);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nif (ar_hln != 0) {\r\nproto_tree_add_item(arp_tree,\r\nARP_HW_IS_ETHER(ar_hrd, ar_hln) ?\r\nhf_arp_src_hw_mac :\r\nhf_arp_src_hw,\r\ntvb, sha_offset, ar_hln, ENC_BIG_ENDIAN);\r\n}\r\nif (ar_pln != 0) {\r\nproto_tree_add_item(arp_tree,\r\nARP_PRO_IS_IPv4(ar_pro, ar_pln) ?\r\nhf_arp_src_proto_ipv4 :\r\nhf_arp_src_proto,\r\ntvb, spa_offset, ar_pln, ENC_BIG_ENDIAN);\r\n}\r\nif (ar_hln != 0) {\r\nproto_tree_add_item(arp_tree,\r\nARP_HW_IS_ETHER(ar_hrd, ar_hln) ?\r\nhf_arp_dst_hw_mac :\r\nhf_arp_dst_hw,\r\ntvb, tha_offset, ar_hln, ENC_BIG_ENDIAN);\r\n}\r\nif (ar_pln != 0 && ar_op != ARPOP_DRARPERROR) {\r\nproto_tree_add_item(arp_tree,\r\nARP_PRO_IS_IPv4(ar_pro, ar_pln) ?\r\nhf_arp_dst_proto_ipv4 :\r\nhf_arp_dst_proto,\r\ntvb, tpa_offset, ar_pln, ENC_BIG_ENDIAN);\r\n}\r\nelse if (ar_pln != 0 && ar_op == ARPOP_DRARPERROR) {\r\nproto_tree_add_item(arp_tree, hf_drarp_error_status, tvb, tpa_offset, 1, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nif (global_arp_detect_request_storm)\r\n{\r\ncheck_for_storm_count(tvb, pinfo, arp_tree);\r\n}\r\nif (duplicate_detected)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (duplicate use of %s detected!)",\r\narpproaddr_to_str((guint8*)&duplicate_ip, 4, ETHERTYPE_IP));\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_arp(void)\r\n{\r\nstatic struct true_false_string tfs_type_bit = { "E.164", "ATM Forum NSAPA" };\r\nstatic hf_register_info hf[] = {\r\n{ &hf_arp_hard_type,\r\n{ "Hardware type", "arp.hw.type",\r\nFT_UINT16, BASE_DEC, VALS(arp_hrd_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_arp_proto_type,\r\n{ "Protocol type", "arp.proto.type",\r\nFT_UINT16, BASE_HEX, VALS(etype_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_arp_hard_size,\r\n{ "Hardware size", "arp.hw.size",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_sht,\r\n{ "Sender ATM number type", "arp.src.htype",\r\nFT_BOOLEAN, 8, TFS(&tfs_type_bit), ATMARP_IS_E164,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_shl,\r\n{ "Sender ATM number length", "arp.src.hlen",\r\nFT_UINT8, BASE_DEC, NULL, ATMARP_LEN_MASK,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_sst,\r\n{ "Sender ATM subaddress type", "arp.src.stype",\r\nFT_BOOLEAN, 8, TFS(&tfs_type_bit), ATMARP_IS_E164,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_ssl,\r\n{ "Sender ATM subaddress length", "arp.src.slen",\r\nFT_UINT8, BASE_DEC, NULL, ATMARP_LEN_MASK,\r\nNULL, HFILL }},\r\n{ &hf_arp_proto_size,\r\n{ "Protocol size", "arp.proto.size",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_arp_opcode,\r\n{ "Opcode", "arp.opcode",\r\nFT_UINT16, BASE_DEC, VALS(op_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_arp_isgratuitous,\r\n{ "Is gratuitous", "arp.isgratuitous",\r\nFT_BOOLEAN, BASE_NONE, TFS(&tfs_true_false), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_spln,\r\n{ "Sender protocol size", "arp.src.pln",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_tht,\r\n{ "Target ATM number type", "arp.dst.htype",\r\nFT_BOOLEAN, 8, TFS(&tfs_type_bit), ATMARP_IS_E164,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_thl,\r\n{ "Target ATM number length", "arp.dst.hlen",\r\nFT_UINT8, BASE_DEC, NULL, ATMARP_LEN_MASK,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_tst,\r\n{ "Target ATM subaddress type", "arp.dst.stype",\r\nFT_BOOLEAN, 8, TFS(&tfs_type_bit), ATMARP_IS_E164,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_tsl,\r\n{ "Target ATM subaddress length", "arp.dst.slen",\r\nFT_UINT8, BASE_DEC, NULL, ATMARP_LEN_MASK,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_tpln,\r\n{ "Target protocol size", "arp.dst.pln",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_arp_src_hw,\r\n{ "Sender hardware address", "arp.src.hw",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_arp_src_hw_mac,\r\n{ "Sender MAC address", "arp.src.hw_mac",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_arp_src_hw_ax25,\r\n{ "Sender AX.25 address", "arp.src.hw_ax25",\r\nFT_AX25, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_src_atm_num_e164,\r\n{ "Sender ATM number (E.164)", "arp.src.atm_num_e164",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_src_atm_num_nsap,\r\n{ "Sender ATM number (NSAP)", "arp.src.atm_num_nsap",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_src_atm_subaddr,\r\n{ "Sender ATM subaddress", "arp.src.atm_subaddr",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_arp_src_proto,\r\n{ "Sender protocol address", "arp.src.proto",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_arp_src_proto_ipv4,\r\n{ "Sender IP address", "arp.src.proto_ipv4",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_arp_dst_hw,\r\n{ "Target hardware address", "arp.dst.hw",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_arp_dst_hw_mac,\r\n{ "Target MAC address", "arp.dst.hw_mac",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_arp_dst_hw_ax25,\r\n{ "Target AX.25 address", "arp.dst.hw_ax25",\r\nFT_AX25, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_dst_atm_num_e164,\r\n{ "Target ATM number (E.164)", "arp.dst.atm_num_e164",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_dst_atm_num_nsap,\r\n{ "Target ATM number (NSAP)", "arp.dst.atm_num_nsap",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_dst_atm_subaddr,\r\n{ "Target ATM subaddress", "arp.dst.atm_subaddr",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_arp_dst_proto,\r\n{ "Target protocol address", "arp.dst.proto",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_arp_dst_proto_ipv4,\r\n{ "Target IP address", "arp.dst.proto_ipv4",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_drarp_error_status,\r\n{ "DRARP error status", "arp.dst.drarp_error_status",\r\nFT_UINT16, BASE_DEC, VALS(drarp_status), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_arp_duplicate_ip_address_earlier_frame,\r\n{ "Frame showing earlier use of IP address", "arp.duplicate-address-frame",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_arp_duplicate_ip_address_seconds_since_earlier_frame,\r\n{ "Seconds since earlier frame seen", "arp.seconds-since-duplicate-address-frame",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_atmarp_src_atm_data_country_code, { "Data Country Code", "arp.src.atm_data_country_code", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_atmarp_src_atm_data_country_code_group, { "Data Country Code (group)", "arp.src.atm_data_country_code_group", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_atmarp_src_atm_high_order_dsp, { "High Order DSP", "arp.src.atm_high_order_dsp", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_atmarp_src_atm_end_system_identifier, { "End System Identifier", "arp.src.atm_end_system_identifier", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_atmarp_src_atm_selector, { "Selector", "arp.src.atm_selector", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_atmarp_src_atm_international_code_designator, { "International Code Designator", "arp.src.atm_international_code_designator", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_atmarp_src_atm_international_code_designator_group, { "International Code Designator (group)", "arp.src.atm_international_code_designator_group", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_atmarp_src_atm_e_164_isdn, { "E.164 ISDN", "arp.src.atm_e.164_isdn", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_atmarp_src_atm_e_164_isdn_group, { "E.164 ISDN", "arp.src.atm_e.164_isdn_group", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_atmarp_src_atm_rest_of_address, { "Rest of address", "arp.src.atm_rest_of_address", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_atmarp_src_atm_afi, { "AFI", "arp.src.atm_afi", FT_UINT8, BASE_HEX, VALS(atm_nsap_afi_vals), 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_arp,\r\n&ett_atmarp_nsap,\r\n&ett_atmarp_tl,\r\n&ett_arp_duplicate_address\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_seq_arp_dup_ip, { "arp.duplicate-address-detected", PI_SEQUENCE, PI_WARN, "Duplicate IP address configured", EXPFILL }},\r\n{ &ei_seq_arp_storm, { "arp.packet-storm-detected", PI_SEQUENCE, PI_NOTE, "ARP packet storm detected", EXPFILL }},\r\n{ &ei_atmarp_src_atm_unknown_afi, { "arp.src.atm_afi.unknown", PI_PROTOCOL, PI_WARN, "Unknown AFI", EXPFILL }},\r\n};\r\nmodule_t *arp_module;\r\nexpert_module_t* expert_arp;\r\nint proto_atmarp;\r\nproto_arp = proto_register_protocol("Address Resolution Protocol",\r\n"ARP/RARP", "arp");\r\nproto_atmarp = proto_register_protocol("ATM Address Resolution Protocol",\r\n"ATMARP", "atmarp");\r\nproto_register_field_array(proto_arp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_arp = expert_register_protocol(proto_arp);\r\nexpert_register_field_array(expert_arp, ei, array_length(ei));\r\natmarp_handle = create_dissector_handle(dissect_atmarp, proto_atmarp);\r\nax25arp_handle = create_dissector_handle(dissect_ax25arp, proto_arp);\r\narp_handle = register_dissector( "arp" , dissect_arp, proto_arp );\r\narp_module = prefs_register_protocol(proto_arp, NULL);\r\nprefs_register_bool_preference(arp_module, "detect_request_storms",\r\n"Detect ARP request storms",\r\n"Attempt to detect excessive rate of ARP requests",\r\n&global_arp_detect_request_storm);\r\nprefs_register_uint_preference(arp_module, "detect_storm_number_of_packets",\r\n"Number of requests to detect during period",\r\n"Number of requests needed within period to indicate a storm",\r\n10, &global_arp_detect_request_storm_packets);\r\nprefs_register_uint_preference(arp_module, "detect_storm_period",\r\n"Detection period (in ms)",\r\n"Period in milliseconds during which a packet storm may be detected",\r\n10, &global_arp_detect_request_storm_period);\r\nprefs_register_bool_preference(arp_module, "detect_duplicate_ips",\r\n"Detect duplicate IP address configuration",\r\n"Attempt to detect duplicate use of IP addresses",\r\n&global_arp_detect_duplicate_ip_addresses);\r\nprefs_register_bool_preference(arp_module, "register_network_address_binding",\r\n"Register network address mappings",\r\n"Try to resolve physical addresses to host names from ARP requests/responses",\r\n&global_arp_register_network_address_binding);\r\nregister_init_routine(&arp_init_protocol);\r\nregister_cleanup_routine(&arp_cleanup_protocol);\r\n}\r\nvoid\r\nproto_reg_handoff_arp(void)\r\n{\r\ndissector_add_uint("ethertype", ETHERTYPE_ARP, arp_handle);\r\ndissector_add_uint("ethertype", ETHERTYPE_REVARP, arp_handle);\r\ndissector_add_uint("arcnet.protocol_id", ARCNET_PROTO_ARP_1051, arp_handle);\r\ndissector_add_uint("arcnet.protocol_id", ARCNET_PROTO_ARP_1201, arp_handle);\r\ndissector_add_uint("arcnet.protocol_id", ARCNET_PROTO_RARP_1201, arp_handle);\r\ndissector_add_uint("ax25.pid", AX25_P_ARP, arp_handle);\r\ndissector_add_uint("gre.proto", ETHERTYPE_ARP, arp_handle);\r\nregister_capture_dissector("ethertype", ETHERTYPE_ARP, capture_arp, proto_arp);\r\nregister_capture_dissector("ax25.pid", AX25_P_ARP, capture_arp, proto_arp);\r\n}
