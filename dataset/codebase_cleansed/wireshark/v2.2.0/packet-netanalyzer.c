static int\r\ndissect_netanalyzer_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nproto_item *ti = NULL;\r\nproto_tree *netanalyzer_header_tree = NULL;\r\nproto_item *ti_status = NULL;\r\nproto_tree *netanalyzer_status_tree = NULL;\r\nguint32 packet_status;\r\nguint32 port_num;\r\nguint32 frame_length;\r\nguint is_gpio;\r\nguint32 offset;\r\nguint gpio_num;\r\nguint gpio_edge;\r\nguint version;\r\nguint idx;\r\nif (tree)\r\n{\r\nti = proto_tree_add_item(tree, proto_netanalyzer, tvb, 0, HEADER_SIZE, ENC_NA);\r\nnetanalyzer_header_tree = proto_item_add_subtree(ti, ett_netanalyzer);\r\nis_gpio = (tvb_get_guint8(tvb, 1) >> SRT_GPIO_FLAG) & 0x1;\r\nif (!is_gpio)\r\n{\r\nversion = (tvb_get_guint8(tvb, 1) >> SRT_VERSION) & 0xf;\r\nif (version != 1)\r\n{\r\nexpert_add_info(pinfo, ti, &ei_netanalyzer_header_version_wrong);\r\nreturn FALSE;\r\n}\r\nport_num = (tvb_get_guint8(tvb, 1) >> SRT_PORT_NUM) & 0x3;\r\nproto_tree_add_uint(netanalyzer_header_tree, hf_netanalyzer_port, tvb, 0, 4, port_num);\r\nproto_item_append_text(ti, " (Port: %u, ", port_num);\r\nframe_length = tvb_get_letohs(tvb, 2) & MSK_LENGTH;\r\nproto_tree_add_uint(netanalyzer_header_tree, hf_netanalyzer_length, tvb, 0, 4, frame_length);\r\nproto_item_append_text(ti, "Length: %u byte%s, ", frame_length, (frame_length == 1) ? "" : "s");\r\nproto_item_append_text(ti, "Status: ");\r\npacket_status = tvb_get_guint8(tvb, 0);\r\nif (packet_status == 0)\r\n{\r\nti_status = proto_tree_add_uint_format_value(netanalyzer_header_tree, hf_netanalyzer_status, tvb, 0, 1,\r\npacket_status, "No Error");\r\nproto_item_append_text(ti, "No Error)");\r\n}\r\nelse\r\n{\r\nwmem_strbuf_t *strbuf;\r\ngboolean first = TRUE;\r\nti_status = proto_tree_add_uint_format_value(netanalyzer_header_tree, hf_netanalyzer_status, tvb, 0, 1,\r\npacket_status, "Error present (expand tree for details)");\r\nstrbuf = wmem_strbuf_new_label(wmem_epan_scope());\r\nfor (idx = 0; idx < 8; idx++)\r\n{\r\nif (packet_status & (1 << idx))\r\n{\r\nif (first)\r\n{\r\nfirst = FALSE;\r\n}\r\nelse\r\n{\r\nwmem_strbuf_append(strbuf, ", ");\r\n}\r\nwmem_strbuf_append(strbuf, msk_strings[idx]);\r\n}\r\n}\r\nproto_item_append_text(ti, "%s)", wmem_strbuf_get_str(strbuf));\r\n}\r\nnetanalyzer_status_tree = proto_item_add_subtree(ti_status, ett_netanalyzer_status);\r\nproto_tree_add_item(netanalyzer_status_tree, hf_netanalyzer_status_rx_err, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(netanalyzer_status_tree, hf_netanalyzer_status_align_err, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(netanalyzer_status_tree, hf_netanalyzer_status_fcs, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(netanalyzer_status_tree, hf_netanalyzer_status_too_long, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(netanalyzer_status_tree, hf_netanalyzer_status_sfd_error, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(netanalyzer_status_tree, hf_netanalyzer_status_short_frame, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(netanalyzer_status_tree, hf_netanalyzer_status_short_preamble, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(netanalyzer_status_tree, hf_netanalyzer_status_long_preamble, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nif (tvb_get_guint8(tvb, 1) & MSK_TRANSPARENT_MODE)\r\n{\r\nproto_tree_add_expert(netanalyzer_header_tree, pinfo, &ei_netanalyzer_transparent_frame, tvb, 0, 4);\r\nproto_item_append_text(ti, ", Transparent Mode");\r\nif (packet_status & MSK_ALIGN_ERR)\r\n{\r\nproto_tree_add_expert(netanalyzer_header_tree, pinfo, &ei_netanalyzer_alignment_error, tvb, tvb_captured_length(tvb)-1, 1);\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nguchar *szTemp;\r\nif ( (tvb_get_guint8(tvb, 10) == 0x00) &&\r\n(tvb_get_guint8(tvb, 11) == 0x02) &&\r\n(tvb_get_guint8(tvb, 12) == 0xa2) &&\r\n(tvb_get_guint8(tvb, 13) == 0xff) &&\r\n(tvb_get_guint8(tvb, 14) == 0xff) &&\r\n(tvb_get_guint8(tvb, 15) == 0xff) &&\r\n(tvb_get_guint8(tvb, 16) == 0x88) &&\r\n(tvb_get_guint8(tvb, 17) == 0xff) &&\r\n(tvb_get_guint8(tvb, INFO_TYPE_OFFSET) == 0x00) )\r\n{\r\n#define MAX_BUFFER 255\r\nszTemp=(guchar *)wmem_alloc(wmem_epan_scope(), MAX_BUFFER);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "netANALYZER");\r\noffset = INFO_TYPE_OFFSET;\r\noffset++;\r\nproto_tree_add_item (netanalyzer_header_tree, hf_netanalyzer_gpio_number, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\ngpio_num = (tvb_get_guint8(tvb, offset) & 0x03);\r\noffset++;\r\nti = proto_tree_add_item (netanalyzer_header_tree, hf_netanalyzer_gpio_edge, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\ngpio_edge = (tvb_get_guint8(tvb, offset) & 0x01);\r\ng_snprintf(szTemp, MAX_BUFFER,\r\n"GPIO event on GPIO %d (%sing edge)", gpio_num, (gpio_edge == 0x00) ? "ris" : "fall");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s", szTemp);\r\nproto_item_append_text(ti, " %s", szTemp);\r\n}\r\nelse\r\n{\r\nexpert_add_info(pinfo, ti, &ei_netanalyzer_gpio_def_none);\r\n}\r\nreturn FALSE;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\ndissect_netanalyzer(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ntvbuff_t *next_tvb;\r\nif (tvb_reported_length(tvb) >= 4)\r\n{\r\nif (dissect_netanalyzer_common(tvb, pinfo, tree))\r\n{\r\nnext_tvb = tvb_new_subset_remaining(tvb, 4);\r\ncall_dissector(eth_dissector_handle, next_tvb, pinfo, tree);\r\n}\r\n}\r\nelse\r\n{\r\nproto_tree_add_expert_format(tree, pinfo, &ei_netanalyzer_header_version_none, tvb, 4, -1,\r\n"netANALYZER - No netANALYZER header found");\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_netanalyzer_transparent(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *transparent_payload_tree = NULL;\r\ntvbuff_t *next_tvb;\r\nif (tvb_reported_length(tvb) >= 4)\r\n{\r\nif (dissect_netanalyzer_common(tvb, pinfo, tree))\r\n{\r\ntransparent_payload_tree = proto_tree_add_subtree(tree, tvb, 4, tvb_captured_length(tvb)-4,\r\nett_netanalyzer_transparent, NULL, "Raw packet data");\r\nnext_tvb = tvb_new_subset_remaining(tvb, 4);\r\ncall_data_dissector(next_tvb, pinfo, transparent_payload_tree);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "netANALYZER");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Frame captured in transparent mode");\r\n}\r\n}\r\nelse\r\n{\r\nproto_tree_add_expert_format(tree, pinfo, &ei_netanalyzer_header_version_none, tvb, 4, -1,\r\n"netANALYZER transparent mode - No netANALYZER header found");\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_netanalyzer(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_netanalyzer_gpio_number,\r\n{ "Event on", "netanalyzer.gpio_event.gpio_number",\r\nFT_UINT8, BASE_HEX, VALS(gpio_number), 0x0,\r\n"Event on GPIO number", HFILL }\r\n},\r\n{ &hf_netanalyzer_gpio_edge,\r\n{ "Event type", "netanalyzer.gpio_event.gpio_edge",\r\nFT_UINT8, BASE_HEX, VALS(gpio_edge_vals), 0x0,\r\n"Edge of GPIO event", HFILL }\r\n},\r\n{ &hf_netanalyzer_port,\r\n{ "Reception Port", "netanalyzer.port",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"netANALYZER reception port", HFILL }\r\n},\r\n{ &hf_netanalyzer_length,\r\n{ "Ethernet frame length", "netanalyzer.framelen",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Actual Ethernet frame length", HFILL }\r\n},\r\n{ &hf_netanalyzer_status,\r\n{ "Status", "netanalyzer.packetstatus",\r\nFT_UINT8, BASE_HEX, NULL, MSK_PACKET_STATUS,\r\n"Status of Ethernet frame", HFILL }\r\n},\r\n{ &hf_netanalyzer_status_rx_err,\r\n{ "MII RX_ER error", "netanalyzer.packetstatus.rx_er",\r\nFT_BOOLEAN, 8, NULL, MSK_RX_ERR,\r\n"RX_ER detected in frame", HFILL }\r\n},\r\n{ &hf_netanalyzer_status_align_err,\r\n{ "Alignment error", "netanalyzer.packetstatus.alignment_error",\r\nFT_BOOLEAN, 8, NULL, MSK_ALIGN_ERR,\r\nNULL, HFILL }\r\n},\r\n{ &hf_netanalyzer_status_fcs,\r\n{ "FCS error", "netanalyzer.packetstatus.fcs_error",\r\nFT_BOOLEAN, 8, NULL, MSK_FCS_ERROR,\r\nNULL, HFILL }\r\n},\r\n{ &hf_netanalyzer_status_too_long,\r\n{ "Frame too long", "netanalyzer.packetstatus.too_long",\r\nFT_BOOLEAN, 8, NULL, MSK_TOO_LONG,\r\n"Frame too long (capture truncated)", HFILL }\r\n},\r\n{ &hf_netanalyzer_status_sfd_error,\r\n{ "No valid SFD found", "netanalyzer.packetstatus.sfd_error",\r\nFT_BOOLEAN, 8, NULL, MSK_SFD_ERROR,\r\n"SDF error detected in frame", HFILL }\r\n},\r\n{ &hf_netanalyzer_status_short_frame,\r\n{ "Frame smaller 64 bytes", "netanalyzer.packetstatus.short_frame",\r\nFT_BOOLEAN, 8, NULL, MSK_SHORT_FRAME,\r\nNULL, HFILL }\r\n},\r\n{ &hf_netanalyzer_status_short_preamble,\r\n{ "Preamble shorter than 7 bytes", "netanalyzer.packetstatus.short_preamble",\r\nFT_BOOLEAN, 8, NULL, MSK_SHORT_PREAMBLE,\r\nNULL, HFILL }\r\n},\r\n{ &hf_netanalyzer_status_long_preamble,\r\n{ "Preamble longer than 7 bytes", "netanalyzer.packetstatus.long_preamble",\r\nFT_BOOLEAN, 8, NULL, MSK_LONG_PREAMBLE,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_netanalyzer,\r\n&ett_netanalyzer_status,\r\n&ett_netanalyzer_transparent,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_netanalyzer_header_version_wrong, { "netanalyzer.header_version.wrong", PI_PROTOCOL, PI_ERROR, "Wrong netANALYZER header version", EXPFILL }},\r\n{ &ei_netanalyzer_gpio_def_none, { "netanalyzer.gpio_def_none", PI_MALFORMED, PI_ERROR, "No valid netANALYZER GPIO definition found", EXPFILL }},\r\n{ &ei_netanalyzer_header_version_none, { "netanalyzer.header_version.none", PI_MALFORMED, PI_ERROR, "No netANALYZER header found", EXPFILL }},\r\n{ &ei_netanalyzer_transparent_frame, { "netanalyzer.transparent_frame", PI_PROTOCOL, PI_NOTE, "This frame was captured in transparent mode", EXPFILL }},\r\n{ &ei_netanalyzer_alignment_error, { "netanalyzer.alignment_error", PI_PROTOCOL, PI_WARN, "Displayed frame data contains additional nibble due to alignment error (upper nibble is not valid)", EXPFILL }},\r\n};\r\nexpert_module_t* expert_netanalyzer;\r\nproto_netanalyzer = proto_register_protocol (\r\n"netANALYZER",\r\n"netANALYZER",\r\n"netanalyzer" );\r\nproto_register_field_array(proto_netanalyzer, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_netanalyzer = expert_register_protocol(proto_netanalyzer);\r\nexpert_register_field_array(expert_netanalyzer, ei, array_length(ei));\r\n}\r\nvoid proto_reg_handoff_netanalyzer(void)\r\n{\r\ndissector_handle_t netana_handle;\r\ndissector_handle_t netana_handle_transparent;\r\neth_dissector_handle = find_dissector_add_dependency("eth_withfcs", proto_netanalyzer);\r\nnetana_handle = create_dissector_handle(dissect_netanalyzer, proto_netanalyzer);\r\nnetana_handle_transparent = create_dissector_handle(dissect_netanalyzer_transparent, proto_netanalyzer);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_NETANALYZER, netana_handle);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_NETANALYZER_TRANSPARENT, netana_handle_transparent);\r\n}
