static int\r\ndissect_xyplex(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_tree *xyplex_tree;\r\nproto_item *ti;\r\nconversation_t *conversation;\r\ngint offset = 0;\r\nguint8 prototype;\r\nguint8 padding;\r\nguint16 server_port;\r\nguint16 return_port;\r\nguint16 reserved;\r\nguint16 reply;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "XYPLEX");\r\nti = proto_tree_add_item(tree, proto_xyplex, tvb, offset, -1, ENC_NA);\r\nxyplex_tree = proto_item_add_subtree(ti, ett_xyplex);\r\nif (pinfo->destport == UDP_PORT_XYPLEX) {\r\nprototype = tvb_get_guint8(tvb, offset);\r\npadding = tvb_get_guint8(tvb, offset+1);\r\nserver_port = tvb_get_ntohs(tvb, offset+2);\r\nreturn_port = tvb_get_ntohs(tvb, offset+4);\r\nreserved = tvb_get_ntohs(tvb, offset+6);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"Registration Request: %d Return: %d",\r\nserver_port, return_port);\r\nif (tree) {\r\nproto_tree_add_uint(xyplex_tree, hf_xyplex_type, tvb,\r\noffset, 1, prototype);\r\nproto_tree_add_uint(xyplex_tree, hf_xyplex_pad, tvb,\r\noffset+1, 1, padding);\r\nproto_tree_add_uint(xyplex_tree, hf_xyplex_server_port, tvb,\r\noffset+2, 2, server_port);\r\nproto_tree_add_uint(xyplex_tree, hf_xyplex_return_port, tvb,\r\noffset+4, 2, return_port);\r\nproto_tree_add_uint(xyplex_tree, hf_xyplex_reserved, tvb,\r\noffset+6, 2, reserved);\r\n}\r\noffset += 8;\r\nconversation = find_conversation(pinfo->num, &pinfo->src, &pinfo->dst,\r\nPT_TCP, return_port, 0, NO_PORT_B);\r\nif (conversation == NULL) {\r\nconversation = conversation_new(pinfo->num, &pinfo->src, &pinfo->dst,\r\nPT_TCP, return_port, 0, NO_PORT2);\r\nconversation_set_dissector(conversation, xyplex_handle);\r\n}\r\nreturn offset;\r\n}\r\nif (pinfo->srcport == UDP_PORT_XYPLEX) {\r\nprototype = tvb_get_guint8(tvb, offset);\r\npadding = tvb_get_guint8(tvb, offset+1);\r\nreply = tvb_get_ntohs(tvb, offset+2);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Registration Reply: %s",\r\nval_to_str(reply, xyplex_reg_vals, "Unknown (0x%02x)"));\r\nif (tree) {\r\nproto_tree_add_uint(xyplex_tree, hf_xyplex_type, tvb,\r\noffset, 1, prototype);\r\nproto_tree_add_uint(xyplex_tree, hf_xyplex_pad, tvb,\r\noffset+1, 1, padding);\r\nproto_tree_add_uint(xyplex_tree, hf_xyplex_reply, tvb,\r\noffset+2, 2, reply);\r\n}\r\noffset += 4;\r\nreturn offset;\r\n}\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%d > %d Data",\r\npinfo->srcport, pinfo->destport);\r\nproto_tree_add_item(xyplex_tree, hf_xyplex_data, tvb, offset, -1, ENC_NA);\r\nreturn tvb_reported_length_remaining(tvb, offset);\r\n}\r\nvoid\r\nproto_register_xyplex(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_xyplex_type,\r\n{ "Type", "xyplex.type",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Protocol type", HFILL }},\r\n{ &hf_xyplex_pad,\r\n{ "Pad", "xyplex.pad",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Padding", HFILL }},\r\n{ &hf_xyplex_server_port,\r\n{ "Server Port", "xyplex.server_port",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_xyplex_return_port,\r\n{ "Return Port", "xyplex.return_port",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_xyplex_reserved,\r\n{ "Reserved field", "xyplex.reserved",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_xyplex_reply,\r\n{ "Registration Reply", "xyplex.reply",\r\nFT_UINT16, BASE_DEC, VALS(xyplex_reg_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_xyplex_data,\r\n{ "Data", "xyplex.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_xyplex,\r\n};\r\nproto_xyplex = proto_register_protocol("Xyplex", "XYPLEX", "xyplex");\r\nproto_register_field_array(proto_xyplex, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_xyplex(void)\r\n{\r\nxyplex_handle = create_dissector_handle(dissect_xyplex, proto_xyplex);\r\ndissector_add_uint("udp.port", UDP_PORT_XYPLEX, xyplex_handle);\r\n}
