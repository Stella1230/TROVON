static inline gint\r\nis_edge_chosen(guint8 e)\r\n{\r\nreturn e & XIA_CHOSEN_EDGE;\r\n}\r\nstatic inline gint\r\nis_any_edge_chosen(const struct xia_row *row)\r\n{\r\nreturn row->s_edge.i & XIA_CHOSEN_EDGES;\r\n}\r\nstatic inline gint\r\nis_empty_edge(guint8 e)\r\n{\r\nreturn (e & XIA_EMPTY_EDGE) == XIA_EMPTY_EDGE;\r\n}\r\nstatic inline gint\r\nxia_is_nat(xid_type_t ty)\r\n{\r\nreturn ty == XIDTYPE_NAT;\r\n}\r\nstatic gint\r\nxia_are_edges_valid(const struct xia_row *row,\r\nguint8 node, guint8 num_node, guint32 *pvisited)\r\n{\r\nconst guint8 *edge;\r\nguint32 all_edges, bits;\r\ngint i;\r\nif (is_any_edge_chosen(row)) {\r\nreturn -XIAEADDR_CHOSEN_EDGE;\r\n}\r\nedge = row->s_edge.a;\r\nall_edges = g_ntohl(row->s_edge.i);\r\nbits = 0xffffffff;\r\nfor (i = 0; i < XIA_OUTDEGREE_MAX; i++, edge++) {\r\nguint8 e;\r\ne = *edge;\r\nif (e == XIA_EMPTY_EDGE) {\r\nif ((all_edges & bits) !=\r\n(XIA_EMPTY_EDGES & bits))\r\nreturn -XIAEADDR_EE_MISPLACED;\r\nelse\r\nbreak;\r\n} else if (e >= num_node) {\r\nreturn -XIAEADDR_EDGE_OUT_RANGE;\r\n} else if (node < (num_node - 1) && e <= node) {\r\nreturn -XIAEADDR_NOT_TOPOLOGICAL;\r\n}\r\nbits >>= 8;\r\n*pvisited |= 1 << e;\r\n}\r\nreturn 0;\r\n}\r\nstatic gint\r\nxia_test_addr(const struct xia_addr *addr)\r\n{\r\ngint i, n;\r\ngint saw_nat = 0;\r\nguint32 visited = 0;\r\nn = XIA_NODES_MAX;\r\nfor (i = 0; i < XIA_NODES_MAX; i++) {\r\nxid_type_t ty;\r\nty = addr->s_row[i].s_xid.xid_type;\r\nif (saw_nat) {\r\nif (!xia_is_nat(ty))\r\nreturn -XIAEADDR_NAT_MISPLACED;\r\n} else if (xia_is_nat(ty)) {\r\nn = i;\r\nsaw_nat = 1;\r\n}\r\n}\r\nfor (i = 0; i < n; i++) {\r\ngint rc;\r\nrc = xia_are_edges_valid(&addr->s_row[i], i, n, &visited);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (n >= 1) {\r\nguint32 all_edges;\r\nall_edges = addr->s_row[n - 1].s_edge.i;\r\nif (all_edges == XIA_EMPTY_EDGES)\r\nreturn -XIAEADDR_NO_ENTRY;\r\nif (visited != ((1U << n) - 1))\r\nreturn -XIAEADDR_MULTI_COMPONENTS;\r\n}\r\nreturn n;\r\n}\r\nstatic inline gchar\r\nedge_to_char(guint8 e)\r\n{\r\nconst gchar *ch_edge = "0123456789abcdefghijklmnopqrstuvwxyz";\r\ne &= ~XIA_CHOSEN_EDGE;\r\nif (e < INDEX_BASE)\r\nreturn ch_edge[e];\r\nelse if (is_empty_edge(e))\r\nreturn '*';\r\nelse\r\nreturn '+';\r\n}\r\nstatic void\r\nadd_edges_to_buf(gint valid, wmem_strbuf_t *buf, const guint8 *edges)\r\n{\r\ngint i;\r\nwmem_strbuf_append_c(buf, '-');\r\nfor (i = 0; i < XIA_OUTDEGREE_MAX; i++) {\r\nif (valid && edges[i] == XIA_EMPTY_EDGE)\r\nreturn;\r\nif (is_edge_chosen(edges[i]))\r\nwmem_strbuf_append_c(buf, '>');\r\nwmem_strbuf_append_c(buf, edge_to_char(edges[i]));\r\n}\r\n}\r\nstatic void\r\nadd_type_to_buf(xid_type_t ty, wmem_strbuf_t *buf)\r\n{\r\nconst gchar *xid_name;\r\ngsize buflen = wmem_strbuf_get_len(buf);\r\nif (XIA_MAX_STRADDR_SIZE - buflen - 1 < MAX_PPAL_NAME_SIZE)\r\nreturn;\r\nxid_name = try_val_to_str(ty, xidtype_vals);\r\nif (xid_name)\r\nwmem_strbuf_append_printf(buf, "%s-", xid_name);\r\nelse\r\nwmem_strbuf_append_printf(buf, "0x%x-", ty);\r\n}\r\nstatic inline void\r\nadd_id_to_buf(const struct xia_xid *src, wmem_strbuf_t *buf)\r\n{\r\nwmem_strbuf_append_printf(buf, "%08x%08x%08x%08x%08x",\r\nsrc->xid_id[0],\r\nsrc->xid_id[1],\r\nsrc->xid_id[2],\r\nsrc->xid_id[3],\r\nsrc->xid_id[4]);\r\n}\r\nstatic int\r\nxia_ntop(const struct xia_addr *src, wmem_strbuf_t *buf)\r\n{\r\ngint valid, i;\r\nvalid = xia_test_addr(src) >= 1;\r\nif (!valid)\r\nwmem_strbuf_append_c(buf, '!');\r\nfor (i = 0; i < XIA_NODES_MAX; i++) {\r\nconst struct xia_row *row = &src->s_row[i];\r\nif (xia_is_nat(row->s_xid.xid_type))\r\nbreak;\r\nif (i > 0)\r\nwmem_strbuf_append(buf, ":\n");\r\nadd_type_to_buf(row->s_xid.xid_type, buf);\r\nadd_id_to_buf(&row->s_xid, buf);\r\nadd_edges_to_buf(valid, buf, row->s_edge.a);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nconstruct_dag(tvbuff_t *tvb, proto_tree *xip_tree,\r\nconst gint ett, const gint hf, const gint hf_entry,\r\nconst guint8 num_nodes, guint8 offset)\r\n{\r\nproto_tree *dag_tree;\r\nproto_item *ti;\r\nstruct xia_addr dag;\r\nwmem_strbuf_t *buf;\r\nconst gchar *dag_str;\r\nguint i, j;\r\nguint8 dag_offset = offset;\r\nti = proto_tree_add_item(xip_tree, hf, tvb, offset,\r\nnum_nodes * XIA_NODE_SIZE, ENC_BIG_ENDIAN);\r\nbuf = wmem_strbuf_sized_new(wmem_packet_scope(),\r\nXIA_MAX_STRADDR_SIZE, XIA_MAX_STRADDR_SIZE);\r\ndag_tree = proto_item_add_subtree(ti, ett);\r\nmemset(&dag, 0, sizeof(dag));\r\nfor (i = 0; i < num_nodes; i++) {\r\nstruct xia_row *row = &dag.s_row[i];\r\nrow->s_xid.xid_type = tvb_get_ntohl(tvb, offset);\r\noffset += XIA_TYPE_SIZE;\r\nfor (j = 0; j < XIA_XID_SIZE / XIA_XID_CHUNK_SIZE; j++) {\r\nrow->s_xid.xid_id[j] = tvb_get_ntohl(tvb, offset);\r\noffset += XIA_XID_CHUNK_SIZE;\r\n}\r\ntvb_memcpy(tvb, row->s_edge.a, offset, XIA_EDGES_SIZE);\r\noffset += XIA_EDGES_SIZE;\r\n}\r\nxia_ntop(&dag, buf);\r\ndag_str = wmem_strbuf_get_str(buf);\r\nproto_tree_add_string_format(dag_tree, hf_entry, tvb, dag_offset,\r\nXIA_NODE_SIZE * num_nodes, dag_str, "%s", dag_str);\r\n}\r\nstatic gint\r\ndissect_xip_sink_node(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, guint8 sink_node)\r\n{\r\ntvbuff_t *next_tvb;\r\nswitch (sink_node) {\r\ncase XIDTYPE_FLOWID:\r\ncase XIDTYPE_SRVCID:\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nreturn call_dissector(xip_serval_handle, next_tvb, pinfo, tree);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic gint\r\ndissect_xip_next_header(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nproto_item *next_ti, gint offset)\r\n{\r\ntvbuff_t *next_tvb;\r\nguint8 next_header = tvb_get_guint8(tvb, XIPH_NXTH);\r\nswitch (next_header) {\r\ncase XIA_NEXT_HEADER_DATA:\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nreturn call_data_dissector(next_tvb, pinfo, tree);\r\ndefault:\r\nexpert_add_info_format(pinfo, next_ti, &ei_xip_next_header,\r\n"Unrecognized next header type: 0x%02x", next_header);\r\nreturn 0;\r\n}\r\n}\r\nstatic void\r\ndisplay_xip(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nproto_tree *xip_tree = NULL;\r\nproto_item *ti = NULL;\r\nproto_item *payload_ti = NULL;\r\nproto_item *next_ti = NULL;\r\nproto_item *num_ti = NULL;\r\ngint offset;\r\nguint16 xiph_len, payload_len;\r\nguint8 num_dst_nodes, num_src_nodes, last_node;\r\nnum_dst_nodes = tvb_get_guint8(tvb, XIPH_NDST);\r\nnum_src_nodes = tvb_get_guint8(tvb, XIPH_NSRC);\r\nxiph_len = 8 + (XIA_NODE_SIZE * num_dst_nodes) +\r\n(XIA_NODE_SIZE * num_src_nodes);\r\nti = proto_tree_add_item(tree, proto_xip, tvb, 0, xiph_len, ENC_NA);\r\nxip_tree = proto_item_add_subtree(ti, ett_xip_tree);\r\nproto_tree_add_item(xip_tree, hf_xip_version, tvb,\r\nXIPH_VERS, 1, ENC_BIG_ENDIAN);\r\nnext_ti = proto_tree_add_item(xip_tree, hf_xip_next_hdr, tvb,\r\nXIPH_NXTH, 1, ENC_BIG_ENDIAN);\r\npayload_len = tvb_get_ntohs(tvb, XIPH_PLEN);\r\npayload_ti = proto_tree_add_uint_format(xip_tree, hf_xip_payload_len,\r\ntvb, XIPH_PLEN, 2, payload_len, "Payload Length: %u bytes",\r\npayload_len);\r\nif (tvb_captured_length_remaining(tvb, xiph_len) != payload_len)\r\nexpert_add_info_format(pinfo, payload_ti, &ei_xip_invalid_len,\r\n"Payload length field (%d bytes) does not match actual payload length (%d bytes)",\r\npayload_len, tvb_captured_length_remaining(tvb, xiph_len));\r\nproto_tree_add_item(xip_tree, hf_xip_hop_limit, tvb,\r\nXIPH_HOPL, 1, ENC_BIG_ENDIAN);\r\nnum_ti = proto_tree_add_item(xip_tree, hf_xip_num_dst, tvb,\r\nXIPH_NDST, 1, ENC_BIG_ENDIAN);\r\nif (num_dst_nodes > XIA_NODES_MAX) {\r\nexpert_add_info_format(pinfo, num_ti, &ei_xip_bad_num_dst,\r\n"The number of destination DAG nodes (%d) must be less than XIA_NODES_MAX (%d)",\r\nnum_dst_nodes, XIA_NODES_MAX);\r\nnum_dst_nodes = XIA_NODES_MAX;\r\n}\r\nnum_ti = proto_tree_add_item(xip_tree, hf_xip_num_src, tvb,\r\nXIPH_NSRC, 1, ENC_BIG_ENDIAN);\r\nif (num_src_nodes > XIA_NODES_MAX) {\r\nexpert_add_info_format(pinfo, num_ti, &ei_xip_bad_num_src,\r\n"The number of source DAG nodes (%d) must be less than XIA_NODES_MAX (%d)",\r\nnum_src_nodes, XIA_NODES_MAX);\r\nnum_src_nodes = XIA_NODES_MAX;\r\n}\r\nlast_node = tvb_get_guint8(tvb, XIPH_LSTN);\r\nproto_tree_add_uint_format_value(xip_tree, hf_xip_last_node, tvb,\r\nXIPH_LSTN, 1, last_node, "%d%s", last_node,\r\nlast_node == XIA_ENTRY_NODE_INDEX ? " (entry node)" : "");\r\nif (num_dst_nodes > 0)\r\nconstruct_dag(tvb, xip_tree, ett_xip_ddag,\r\nhf_xip_dst_dag, hf_xip_dst_dag_entry,\r\nnum_dst_nodes, XIPH_DSTD);\r\nif (num_src_nodes > 0)\r\nconstruct_dag(tvb, xip_tree, ett_xip_sdag,\r\nhf_xip_src_dag, hf_xip_src_dag_entry,\r\nnum_src_nodes,\r\nXIPH_DSTD + num_dst_nodes * XIA_NODE_SIZE);\r\noffset = XIPH_DSTD + XIA_NODE_SIZE * (num_dst_nodes + num_src_nodes);\r\noffset += dissect_xip_sink_node(tvb, pinfo, tree, offset,\r\ntvb_get_ntohl(tvb, XIPH_DSTD +\r\n(num_dst_nodes - 1) * XIA_NODE_SIZE));\r\ndissect_xip_next_header(tvb, pinfo, tree, next_ti, offset);\r\n}\r\nstatic gint\r\ndissect_xip(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nvoid *data _U_)\r\n{\r\nif (tvb_reported_length(tvb) < XIPH_MIN_LEN)\r\nreturn 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "XIP");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "XIP Packet");\r\ndisplay_xip(tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_xip(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_xip_version,\r\n{ "Version", "xip.version", FT_UINT8,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_xip_next_hdr,\r\n{ "Next Header", "xip.next_hdr", FT_UINT8,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_xip_payload_len,\r\n{ "Payload Length", "xip.payload_len", FT_UINT16,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_xip_hop_limit,\r\n{ "Hop Limit", "xip.hop_limit", FT_UINT8,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_xip_num_dst,\r\n{ "Number of Destination Nodes", "xip.num_dst", FT_UINT8,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_xip_num_src,\r\n{ "Number of Source Nodes", "xip.num_src", FT_UINT8,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_xip_last_node,\r\n{ "Last Node", "xip.last_node", FT_UINT8,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_xip_dst_dag,\r\n{ "Destination DAG", "xip.dst_dag", FT_NONE,\r\nBASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_xip_dst_dag_entry,\r\n{ "Destination DAG Entry", "xip.dst_dag_entry", FT_STRING,\r\nBASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_xip_src_dag,\r\n{ "Source DAG", "xip.src_dag", FT_NONE,\r\nBASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_xip_src_dag_entry,\r\n{ "Source DAG Entry", "xip.src_dag_entry", FT_STRING,\r\nBASE_NONE, NULL, 0x0, NULL, HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_xip_tree,\r\n&ett_xip_ddag,\r\n&ett_xip_sdag\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_xip_invalid_len,\r\n{ "xip.invalid.len", PI_MALFORMED, PI_ERROR,\r\n"Invalid length", EXPFILL }},\r\n{ &ei_xip_next_header,\r\n{ "xip.next.header", PI_MALFORMED, PI_ERROR,\r\n"Invalid next header", EXPFILL }},\r\n{ &ei_xip_bad_num_dst,\r\n{ "xip.bad_num_dst", PI_MALFORMED, PI_ERROR,\r\n"Invalid number of destination DAG nodes", EXPFILL }},\r\n{ &ei_xip_bad_num_src,\r\n{ "xip.bad_num_src", PI_MALFORMED, PI_ERROR,\r\n"Invalid number of source DAG nodes", EXPFILL }}\r\n};\r\nexpert_module_t* expert_xip;\r\nproto_xip = proto_register_protocol(\r\n"eXpressive Internet Protocol",\r\n"XIP",\r\n"xip");\r\nxip_handle = register_dissector("xip", dissect_xip, proto_xip);\r\nproto_register_field_array(proto_xip, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_xip = expert_register_protocol(proto_xip);\r\nexpert_register_field_array(expert_xip, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_xip(void)\r\n{\r\ndissector_add_uint("ethertype", ETHERTYPE_XIP, xip_handle);\r\nxip_serval_handle = find_dissector_add_dependency("xipserval", proto_xip);\r\n}
