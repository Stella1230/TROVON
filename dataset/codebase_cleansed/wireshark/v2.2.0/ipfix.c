static gboolean\r\nipfix_read_message_header(ipfix_message_header_t *pfx_hdr, FILE_T fh, int *err, gchar **err_info)\r\n{\r\nif (!wtap_read_bytes_or_eof(fh, pfx_hdr, IPFIX_MSG_HDR_SIZE, err, err_info))\r\nreturn FALSE;\r\npfx_hdr->version = g_ntohs(pfx_hdr->version);\r\npfx_hdr->message_length = g_ntohs(pfx_hdr->message_length);\r\npfx_hdr->export_time_secs = g_ntohl(pfx_hdr->export_time_secs);\r\npfx_hdr->sequence_number = g_ntohl(pfx_hdr->sequence_number);\r\npfx_hdr->observation_id = g_ntohl(pfx_hdr->observation_id);\r\nif (pfx_hdr->version != IPFIX_VERSION) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("ipfix: wrong version %d", pfx_hdr->version);\r\nreturn FALSE;\r\n}\r\nif (pfx_hdr->message_length < 16) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("ipfix: message length %u is too short", pfx_hdr->message_length);\r\nreturn FALSE;\r\n}\r\nif (file_seek(fh, 0 - IPFIX_MSG_HDR_SIZE, SEEK_CUR, err) == -1) {\r\nipfix_debug("ipfix_read: couldn't go back in file before header");\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nipfix_read_message(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nipfix_message_header_t msg_hdr;\r\nif (!ipfix_read_message_header(&msg_hdr, fh, err, err_info))\r\nreturn FALSE;\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS;\r\nphdr->len = msg_hdr.message_length;\r\nphdr->caplen = msg_hdr.message_length;\r\nphdr->ts.secs = msg_hdr.export_time_secs;\r\nphdr->ts.nsecs = 0;\r\nreturn wtap_read_packet_bytes(fh, buf, msg_hdr.message_length, err, err_info);\r\n}\r\nwtap_open_return_val\r\nipfix_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\ngint i, n, records_for_ipfix_check = RECORDS_FOR_IPFIX_CHECK;\r\ngchar *s;\r\nguint16 checked_len = 0;\r\nipfix_message_header_t msg_hdr;\r\nipfix_set_header_t set_hdr;\r\nipfix_debug("ipfix_open: opening file");\r\nif ((s = getenv("IPFIX_RECORDS_TO_CHECK")) != NULL) {\r\nif ((n = atoi(s)) > 0 && n < 101) {\r\nrecords_for_ipfix_check = n;\r\n}\r\n}\r\nfor (i = 0; i < records_for_ipfix_check; i++) {\r\nif (!ipfix_read_message_header(&msg_hdr, wth->fh, err, err_info)) {\r\nipfix_debug("ipfix_open: couldn't read message header #%d with err code #%d (%s)",\r\ni, *err, *err_info);\r\nif (*err == WTAP_ERR_BAD_FILE) {\r\n*err = 0;\r\ng_free(*err_info);\r\n*err_info = NULL;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nif (i < 1) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nbreak;\r\n}\r\nif (file_seek(wth->fh, IPFIX_MSG_HDR_SIZE, SEEK_CUR, err) == -1) {\r\nipfix_debug("ipfix_open: failed seek to next message in file, %d bytes away",\r\nmsg_hdr.message_length);\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nchecked_len = IPFIX_MSG_HDR_SIZE;\r\nwhile (checked_len < msg_hdr.message_length) {\r\nif (!wtap_read_bytes(wth->fh, &set_hdr, IPFIX_SET_HDR_SIZE,\r\nerr, err_info)) {\r\nif (*err == WTAP_ERR_SHORT_READ) {\r\nipfix_debug("ipfix_open: error %d reading set", *err);\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nset_hdr.set_length = g_ntohs(set_hdr.set_length);\r\nif ((set_hdr.set_length < IPFIX_SET_HDR_SIZE) ||\r\n((set_hdr.set_length + checked_len) > msg_hdr.message_length)) {\r\nipfix_debug("ipfix_open: found invalid set_length of %d",\r\nset_hdr.set_length);\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (file_seek(wth->fh, set_hdr.set_length - IPFIX_SET_HDR_SIZE,\r\nSEEK_CUR, err) == -1)\r\n{\r\nipfix_debug("ipfix_open: failed seek to next set in file, %d bytes away",\r\nset_hdr.set_length - IPFIX_SET_HDR_SIZE);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nchecked_len += set_hdr.set_length;\r\n}\r\n}\r\nif (file_seek (wth->fh, 0, SEEK_SET, err) != 0)\r\n{\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nwth->file_encap = WTAP_ENCAP_RAW_IPFIX;\r\nwth->snapshot_length = 0;\r\nwth->file_tsprec = WTAP_TSPREC_SEC;\r\nwth->subtype_read = ipfix_read;\r\nwth->subtype_seek_read = ipfix_seek_read;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_IPFIX;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean\r\nipfix_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\r\n{\r\n*data_offset = file_tell(wth->fh);\r\nipfix_debug("ipfix_read: data_offset is initially %" G_GINT64_MODIFIER "d", *data_offset);\r\nif (!ipfix_read_message(wth->fh, &wth->phdr, wth->frame_buffer, err, err_info)) {\r\nipfix_debug("ipfix_read: couldn't read message header with code: %d\n, and error '%s'",\r\n*err, *err_info);\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nipfix_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\r\nipfix_debug("ipfix_seek_read: couldn't read message header with code: %d\n, and error '%s'",\r\n*err, *err_info);\r\nreturn FALSE;\r\n}\r\nipfix_debug("ipfix_seek_read: reading at offset %" G_GINT64_MODIFIER "u", seek_off);\r\nif (!ipfix_read_message(wth->random_fh, phdr, buf, err, err_info)) {\r\nipfix_debug("ipfix_seek_read: couldn't read message header");\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}
