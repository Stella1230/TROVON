static int\r\ndissect_pw_fr( tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_ )\r\n{\r\ngint packet_size;\r\ngint payload_size;\r\ngint payload_padding;\r\nconst int encaps_size = 4;\r\nenum {\r\nPQ_CW_BAD = 0x001\r\n,PQ_CW_BAD_BITS03 = 0x002\r\n,PQ_CW_BAD_LEN_GT_PACKET = 0x004\r\n,PQ_CW_BAD_LEN_MUST_BE_ZERO = 0x008\r\n,PQ_CW_BAD_LEN_MUST_BE_NONZERO = 0x010\r\n,PQ_PAYLOAD_SIZE_ZERO = 0x020\r\n};\r\nint packet_quality;\r\npacket_size = tvb_reported_length_remaining(tvb, 0);\r\nif (packet_size < encaps_size)\r\n{\r\n{\r\nproto_item *item;\r\nitem = proto_tree_add_item(tree, proto_encaps, tvb, 0, -1, ENC_NA);\r\nexpert_add_info_format(pinfo, item, &ei_cw_packet_size_too_small,\r\n"PW packet (%d) is smaller than PW encapsulation header (%d)",\r\n(int)packet_size,(int)encaps_size);\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "FR PW");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Malformed: PW packet < PW encapsulation header");\r\nreturn 1;\r\n}\r\nif (dissect_try_cw_first_nibble(tvb,pinfo,tree))\r\n{\r\nreturn tvb_captured_length(tvb);\r\n}\r\npacket_quality = 0;\r\nif (0 != (tvb_get_guint8(tvb, 0) & 0xf0 ))\r\n{\r\npacket_quality |= PQ_CW_BAD + PQ_CW_BAD_BITS03;\r\n}\r\n{\r\nint cw_len;\r\ngint payload_size_packet;\r\ncw_len = tvb_get_guint8(tvb, 1) & 0x3f;\r\npayload_size_packet = packet_size - encaps_size;\r\npayload_size = payload_size_packet;\r\npayload_padding = 0;\r\nif (payload_size_packet < 64)\r\n{\r\ngint payload_size_cw;\r\npayload_size_cw = cw_len;\r\nif (payload_size_cw == 0)\r\n{\r\npacket_quality |= PQ_CW_BAD + PQ_CW_BAD_LEN_MUST_BE_NONZERO;\r\n}\r\nelse if (payload_size_cw > payload_size_packet)\r\n{\r\npacket_quality |= PQ_CW_BAD + PQ_CW_BAD_LEN_GT_PACKET;\r\n}\r\nelse\r\n{\r\npayload_size = payload_size_cw;\r\npayload_padding = payload_size_packet - payload_size_cw;\r\n}\r\n}\r\nelse\r\n{\r\nif (cw_len != 0)\r\n{\r\npacket_quality |= PQ_CW_BAD + PQ_CW_BAD_LEN_MUST_BE_ZERO;\r\n}\r\n}\r\n}\r\nif (payload_size == 0)\r\n{\r\npacket_quality |= PQ_PAYLOAD_SIZE_ZERO;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "FR PW");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (packet_quality & PQ_CW_BAD)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_INFO, "CW:Malformed, ");\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%d payload octets", (int)payload_size);\r\nif (payload_padding != 0)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %d padding", (int)payload_padding);\r\n}\r\n{\r\nproto_tree* subtree;\r\nproto_item* item_headline;\r\nproto_item* item;\r\nitem_headline = proto_tree_add_item(tree, proto_encaps, tvb, 0, 4, ENC_NA);\r\nproto_item_append_text(item_headline, ": 0x%.8" G_GINT32_MODIFIER "x", tvb_get_ntohl(tvb, 0));\r\nsubtree = proto_item_add_subtree(item_headline, ett_encaps);\r\nif (packet_quality & PQ_CW_BAD_BITS03)\r\n{\r\nitem = proto_tree_add_item(subtree, hf_cw_bits03, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nexpert_add_info(pinfo, item, &ei_cw_bits03);\r\n}\r\nproto_tree_add_item( subtree, hf_cw_fecn, tvb, 0, 1, ENC_BIG_ENDIAN );\r\nproto_tree_add_item( subtree, hf_cw_becn, tvb, 0, 1, ENC_BIG_ENDIAN );\r\nproto_tree_add_item( subtree, hf_cw_de, tvb, 0, 1, ENC_BIG_ENDIAN );\r\nproto_tree_add_item( subtree, hf_cw_cr, tvb, 0, 1, ENC_BIG_ENDIAN );\r\nproto_tree_add_item( subtree, hf_cw_frg, tvb, 1, 1, ENC_BIG_ENDIAN );\r\nitem = proto_tree_add_item( subtree, hf_cw_len, tvb, 1, 1, ENC_BIG_ENDIAN );\r\nif (packet_quality & PQ_CW_BAD_LEN_GT_PACKET)\r\n{\r\nexpert_add_info_format(pinfo, item, &ei_payload_size_invalid,\r\n"Bad Length: greater than FR payload size (%d)",\r\n(int)payload_size);\r\n}\r\nif (packet_quality & PQ_CW_BAD_LEN_MUST_BE_NONZERO)\r\n{\r\nexpert_add_info_format(pinfo, item, &ei_payload_size_invalid,\r\n"Bad Length: must be non-zero if FR PW packet size (%d) is < 64",\r\n(int)(payload_size+encaps_size));\r\n}\r\nif (packet_quality & PQ_CW_BAD_LEN_MUST_BE_ZERO)\r\n{\r\nexpert_add_info_format(pinfo, item, &ei_payload_size_invalid,\r\n"Bad Length: must be 0 if FR PW packet size (%d) is >= 64",\r\n(int)(payload_size+encaps_size));\r\n}\r\nproto_tree_add_item( subtree, hf_cw_seq, tvb, 2, 2, ENC_BIG_ENDIAN );\r\nif (payload_padding > 0)\r\n{\r\nproto_tree_add_item(subtree, hf_cw_padding, tvb,\r\nencaps_size+payload_size, payload_padding, ENC_NA);\r\n}\r\nif (packet_quality & PQ_PAYLOAD_SIZE_ZERO)\r\n{\r\nexpert_add_info_format(pinfo, item_headline, &ei_payload_size_invalid,\r\n"FR payload size must be non-zero");\r\n}\r\n}\r\nif (payload_size > 0)\r\n{\r\ntvbuff_t *tvb_payload;\r\ntvb_payload = tvb_new_subset_length(tvb, encaps_size, payload_size);\r\ncall_dissector( fr_stripped_address_handle, tvb_payload, pinfo, tree );\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_pw_fr(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{&hf_cw_bits03 ,{"Bits 0 to 3" ,"pwfr.bits03" ,FT_UINT8 ,BASE_HEX\r\n,NULL ,0xf0 ,NULL\r\n,HFILL }},\r\n{&hf_cw_fecn ,{"FR FECN" ,"pwfr.fecn" ,FT_UINT8 ,BASE_DEC\r\n,NULL ,0x08 ,"FR Forward Explicit Congestion Notification bit"\r\n,HFILL}},\r\n{&hf_cw_becn ,{"FR BECN" ,"pwfr.becn" ,FT_UINT8 ,BASE_DEC\r\n,NULL ,0x04 ,"FR Backward Explicit Congestion Notification bit"\r\n,HFILL}},\r\n{&hf_cw_de ,{"FR DE bit" ,"pwfr.de" ,FT_UINT8 ,BASE_DEC\r\n,NULL ,0x02 ,"FR Discard Eligibility bit"\r\n,HFILL}},\r\n{&hf_cw_cr ,{"FR Frame C/R" ,"pwfr.cr" ,FT_UINT8 ,BASE_DEC\r\n,NULL ,0x01 ,"FR frame Command/Response bit"\r\n,HFILL}},\r\n{&hf_cw_frg ,{"Fragmentation" ,"pwfr.frag" ,FT_UINT8 ,BASE_DEC\r\n,VALS(vals_frg) ,0xc0 ,NULL\r\n,HFILL}},\r\n{&hf_cw_len ,{"Length" ,"pwfr.length" ,FT_UINT8 ,BASE_DEC\r\n,NULL ,0x3f ,NULL\r\n,HFILL}},\r\n{&hf_cw_seq ,{"Sequence number" ,"pwfr.length" ,FT_UINT16 ,BASE_DEC\r\n,NULL ,0 ,NULL\r\n,HFILL}},\r\n{&hf_cw_padding,{"Padding" ,"pwfr.padding" ,FT_BYTES, BASE_NONE\r\n,NULL ,0 ,NULL\r\n,HFILL}}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_encaps\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_cw_packet_size_too_small, { "pwfr.packet_size_too_small", PI_MALFORMED, PI_ERROR, "PW packet is smaller than PW encapsulation header", EXPFILL }},\r\n{ &ei_cw_bits03, { "pwfr.cw.bits03.not_zero", PI_MALFORMED, PI_ERROR, "Bits 0..3 of Control Word must be 0", EXPFILL }},\r\n{ &ei_payload_size_invalid, { "pwfr.payload.size_invalid", PI_MALFORMED, PI_ERROR, "Bad Length: greater than FR payload size", EXPFILL }},\r\n};\r\nexpert_module_t* expert_pwfr;\r\nproto_encaps = proto_register_protocol( "PW Frame Relay DLCI Control Word",\r\n"Frame Relay DLCI PW",\r\n"pwfr");\r\nproto_register_field_array(proto_encaps, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_pwfr = expert_register_protocol(proto_encaps);\r\nexpert_register_field_array(expert_pwfr, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_pw_fr(void)\r\n{\r\ndissector_handle_t pw_fr_mpls_handle;\r\npw_fr_mpls_handle = create_dissector_handle( dissect_pw_fr, proto_encaps );\r\ndissector_add_for_decode_as("mpls.label", pw_fr_mpls_handle);\r\nfr_stripped_address_handle = find_dissector_add_dependency("fr_stripped_address", proto_encaps);\r\n}
