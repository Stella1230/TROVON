static int\r\nadd_option_info(tvbuff_t *tvb, int pos, proto_tree *tree, proto_item *ti)\r\n{\r\nguint8 tag, length, fcs_err = 0, encr = 0, seen_fcs_err = 0;\r\nproto_tree *tag_tree;\r\nwhile (TRUE) {\r\ntag = tvb_get_guint8(tvb, pos);\r\nif ((tag != TZSP_HDR_PAD) && (tag != TZSP_HDR_END)) {\r\nlength = tvb_get_guint8(tvb, pos+1);\r\ntag_tree = proto_tree_add_subtree(tree, tvb, pos, 2+length, ett_tag, NULL, val_to_str_const(tag, option_tag_vals, "Unknown"));\r\n} else {\r\ntag_tree = proto_tree_add_subtree(tree, tvb, pos, 1, ett_tag, NULL, val_to_str_const(tag, option_tag_vals, "Unknown"));\r\nlength = 0;\r\n}\r\nproto_tree_add_item(tag_tree, hf_option_tag, tvb, pos, 1, ENC_BIG_ENDIAN);\r\npos++;\r\nif ((tag != TZSP_HDR_PAD) && (tag != TZSP_HDR_END)) {\r\nproto_tree_add_item(tag_tree, hf_option_length, tvb, pos, 1, ENC_BIG_ENDIAN);\r\npos++;\r\n}\r\nswitch (tag) {\r\ncase TZSP_HDR_PAD:\r\nbreak;\r\ncase TZSP_HDR_END:\r\nif (seen_fcs_err) {\r\nproto_item_append_text(ti,"%s", fcs_err?"FCS Error":(encr?"Encrypted":"Good"));\r\n}\r\nreturn pos;\r\ncase TZSP_HDR_ORIGINAL_LENGTH:\r\nproto_tree_add_item(tag_tree, hf_original_length, tvb, pos, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase WLAN_RADIO_HDR_SIGNAL:\r\nproto_tree_add_item(tag_tree, hf_signal, tvb, pos, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase WLAN_RADIO_HDR_NOISE:\r\nproto_tree_add_item(tag_tree, hf_silence, tvb, pos, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase WLAN_RADIO_HDR_RATE:\r\nproto_tree_add_item(tag_tree, hf_rate, tvb, pos, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase WLAN_RADIO_HDR_TIMESTAMP:\r\nproto_tree_add_item(tag_tree, hf_time, tvb, pos, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase WLAN_RADIO_HDR_MSG_TYPE:\r\nproto_tree_add_item(tag_tree, hf_status_msg_type, tvb, pos, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase WLAN_RADIO_HDR_CF:\r\nproto_tree_add_item(tag_tree, hf_status_pcf, tvb, pos, 1, ENC_NA);\r\nbreak;\r\ncase WLAN_RADIO_HDR_UN_DECR:\r\nproto_tree_add_item(tag_tree, hf_status_undecrypted, tvb, pos, 1, ENC_NA);\r\nencr = tvb_get_guint8(tvb, pos);\r\nbreak;\r\ncase WLAN_RADIO_HDR_FCS_ERR:\r\nseen_fcs_err = 1;\r\nproto_tree_add_item(tag_tree, hf_status_fcs_error, tvb, pos, 1, ENC_NA);\r\nfcs_err = tvb_get_guint8(tvb, pos);\r\nbreak;\r\ncase WLAN_RADIO_HDR_CHANNEL:\r\nproto_tree_add_item(tag_tree, hf_channel, tvb, pos, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase TZSP_HDR_SENSOR:\r\nproto_tree_add_item(tag_tree, hf_sensormac, tvb, pos, 6, ENC_NA);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tag_tree, hf_unknown, tvb, pos, length, ENC_NA);\r\nbreak;\r\n}\r\npos += length;\r\n}\r\n}\r\nstatic int\r\ndissect_tzsp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *tzsp_tree = NULL;\r\nproto_item *ti = NULL;\r\nint pos = 0;\r\ntvbuff_t *next_tvb;\r\nguint16 encapsulation = 0;\r\nconst char *info;\r\nguint8 type;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "TZSP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ntype = tvb_get_guint8(tvb, 1);\r\nencapsulation = tvb_get_ntohs(tvb, 2);\r\ninfo = val_to_str(encapsulation, tzsp_encapsulation, "Unknown (%u)");\r\ncol_add_str(pinfo->cinfo, COL_INFO, info);\r\nif (tree) {\r\nti = proto_tree_add_protocol_format(tree, proto_tzsp, tvb, 0,\r\n-1, "TZSP: %s ", info);\r\ntzsp_tree = proto_item_add_subtree(ti, ett_tzsp);\r\nproto_tree_add_item (tzsp_tree, hf_tzsp_version, tvb, 0, 1,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_uint (tzsp_tree, hf_tzsp_type, tvb, 1, 1,\r\ntype);\r\nproto_tree_add_uint (tzsp_tree, hf_tzsp_encap, tvb, 2, 2,\r\nencapsulation);\r\n}\r\nif ((type != TZSP_NULL) && (type != TZSP_PORT)) {\r\npos = add_option_info(tvb, 4, tzsp_tree, ti);\r\nif (tree)\r\nproto_item_set_end(ti, tvb, pos);\r\nnext_tvb = tvb_new_subset_remaining(tvb, pos);\r\nswitch (encapsulation) {\r\ncase TZSP_ENCAP_ETHERNET:\r\ncall_dissector(eth_maybefcs_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ncase TZSP_ENCAP_TOKEN_RING:\r\ncall_dissector(tr_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ncase TZSP_ENCAP_PPP:\r\ncall_dissector(ppp_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ncase TZSP_ENCAP_FDDI:\r\ncall_dissector(fddi_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ncase TZSP_ENCAP_RAW:\r\ncall_dissector(raw_ip_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ncase TZSP_ENCAP_IEEE_802_11:\r\ncall_dissector(ieee_802_11_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ncase TZSP_ENCAP_IEEE_802_11_PRISM:\r\ncall_dissector(ieee_802_11_prism_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ncase TZSP_ENCAP_IEEE_802_11_AVS:\r\ncall_dissector(ieee_802_11_avs_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "UNKNOWN");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "TZSP_ENCAP = %u",\r\nencapsulation);\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_tzsp(void)\r\n{\r\nstatic const value_string msg_type[] = {\r\n{0, "Normal"},\r\n{1, "RFC1042 encoded"},\r\n{2, "Bridge-tunnel encoded"},\r\n{4, "802.11 management frame"},\r\n{0, NULL}\r\n};\r\nstatic const true_false_string pcf_flag = {\r\n"CF: Frame received during CF period",\r\n"Not CF"\r\n};\r\nstatic const true_false_string undecr_flag = {\r\n"Encrypted frame could not be decrypted",\r\n"Unencrypted"\r\n};\r\nstatic const true_false_string fcs_err_flag = {\r\n"FCS error, frame is corrupted",\r\n"Frame is valid"\r\n};\r\nstatic const value_string channels[] = {\r\n{ 1, "1 (2.412 GHz)"},\r\n{ 2, "2 (2.417 GHz)"},\r\n{ 3, "3 (2.422 GHz)"},\r\n{ 4, "4 (2.427 GHz)"},\r\n{ 5, "5 (2.432 GHz)"},\r\n{ 6, "6 (2.437 GHz)"},\r\n{ 7, "7 (2.442 GHz)"},\r\n{ 8, "8 (2.447 GHz)"},\r\n{ 9, "9 (2.452 GHz)"},\r\n{ 10, "10 (2.457 GHz)"},\r\n{ 11, "11 (2.462 GHz)"},\r\n{ 12, "12 (2.467 GHz)"},\r\n{ 13, "13 (2.472 GHz)"},\r\n{ 14, "14 (2.484 GHz)"},\r\n{ 36, "36 (5.180 GHz)"},\r\n{ 40, "40 (5.200 GHz)"},\r\n{ 44, "44 (5.220 GHz)"},\r\n{ 48, "48 (5.240 GHz)"},\r\n{ 52, "52 (5.260 GHz)"},\r\n{ 56, "56 (5.280 GHz)"},\r\n{ 60, "60 (5.300 GHz)"},\r\n{ 64, "64 (5.320 GHz)"},\r\n{149, "149 (5.745 GHz)"},\r\n{153, "153 (5.765 GHz)"},\r\n{157, "157 (5.785 GHz)"},\r\n{161, "161 (5.805 GHz)"},\r\n{0, NULL}\r\n};\r\nstatic const value_string rates[] = {\r\n{0x0A, "1 Mbit/s"},\r\n{0x14, "2 Mbit/s"},\r\n{0x37, "5.5 Mbit/s"},\r\n{0x6E, "11 Mbit/s"},\r\n{ 2, "1 Mbit/s"},\r\n{ 4, "2 Mbit/s"},\r\n{ 11, "5.5 Mbit/s"},\r\n{ 12, "6 Mbit/s"},\r\n{ 18, "9 Mbit/s"},\r\n{ 22, "11 Mbit/s"},\r\n{ 24, "12 Mbit/s"},\r\n{ 36, "18 Mbit/s"},\r\n{ 48, "24 Mbit/s"},\r\n{ 72, "36 Mbit/s"},\r\n{ 96, "48 Mbit/s"},\r\n{108, "54 Mbit/s"},\r\n{0, NULL}\r\n};\r\nstatic hf_register_info hf[] = {\r\n{ &hf_tzsp_version, {\r\n"Version", "tzsp.version", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_tzsp_type, {\r\n"Type", "tzsp.type", FT_UINT8, BASE_DEC,\r\nVALS(tzsp_type), 0, NULL, HFILL }},\r\n{ &hf_tzsp_encap, {\r\n"Encapsulation", "tzsp.encap", FT_UINT16, BASE_DEC,\r\nVALS(tzsp_encapsulation), 0, NULL, HFILL }},\r\n{ &hf_option_tag, {\r\n"Option Tag", "tzsp.option_tag", FT_UINT8, BASE_DEC,\r\nVALS(option_tag_vals), 0, NULL, HFILL }},\r\n{ &hf_option_length, {\r\n"Option Length", "tzsp.option_length", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n#if 0\r\n{ &hf_status_field, {\r\n"Status", "tzsp.wlan.status", FT_UINT16, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n#endif\r\n{ &hf_status_msg_type, {\r\n"Type", "tzsp.wlan.status.msg_type", FT_UINT8, BASE_HEX,\r\nVALS(msg_type), 0, "Message type", HFILL }},\r\n#if 0\r\n{ &hf_status_mac_port, {\r\n"Port", "tzsp.wlan.status.mac_port", FT_UINT8, BASE_DEC,\r\nNULL, 0, "MAC port", HFILL }},\r\n#endif\r\n{ &hf_status_pcf, {\r\n"PCF", "tzsp.wlan.status.pcf", FT_BOOLEAN, BASE_NONE,\r\nTFS (&pcf_flag), 0x0, "Point Coordination Function", HFILL }},\r\n{ &hf_status_undecrypted, {\r\n"Undecrypted", "tzsp.wlan.status.undecrypted", FT_BOOLEAN, BASE_NONE,\r\nTFS (&undecr_flag), 0x0, NULL, HFILL }},\r\n{ &hf_status_fcs_error, {\r\n"FCS", "tzsp.wlan.status.fcs_err", FT_BOOLEAN, BASE_NONE,\r\nTFS (&fcs_err_flag), 0x0, "Frame check sequence", HFILL }},\r\n{ &hf_time, {\r\n"Time", "tzsp.wlan.time", FT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_silence, {\r\n"Silence", "tzsp.wlan.silence", FT_INT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_original_length, {\r\n"Original Length", "tzsp.original_length", FT_INT16, BASE_DEC,\r\nNULL, 0, "OrigLength", HFILL }},\r\n{ &hf_signal, {\r\n"Signal", "tzsp.wlan.signal", FT_INT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rate, {\r\n"Rate", "tzsp.wlan.rate", FT_UINT8, BASE_DEC,\r\nVALS(rates), 0, NULL, HFILL }},\r\n{ &hf_channel, {\r\n"Channel", "tzsp.wlan.channel", FT_UINT8, BASE_DEC,\r\nVALS(channels), 0, NULL, HFILL }},\r\n{ &hf_unknown, {\r\n"Unknown tag", "tzsp.unknown", FT_BYTES, BASE_NONE,\r\nNULL, 0, "Unknown", HFILL }},\r\n{ &hf_sensormac, {\r\n"Sensor Address", "tzsp.sensormac", FT_ETHER, BASE_NONE,\r\nNULL, 0, "Sensor MAC", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_tzsp,\r\n&ett_tag\r\n};\r\nproto_tzsp = proto_register_protocol("Tazmen Sniffer Protocol", "TZSP",\r\n"tzsp");\r\nproto_register_field_array(proto_tzsp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\ntzsp_handle = register_dissector("tzsp", dissect_tzsp, proto_tzsp);\r\n}\r\nvoid\r\nproto_reg_handoff_tzsp(void)\r\n{\r\ndissector_add_uint("udp.port", UDP_PORT_TZSP, tzsp_handle);\r\neth_maybefcs_handle = find_dissector_add_dependency("eth_maybefcs", proto_tzsp);\r\ntr_handle = find_dissector_add_dependency("tr", proto_tzsp);\r\nppp_handle = find_dissector_add_dependency("ppp_hdlc", proto_tzsp);\r\nfddi_handle = find_dissector_add_dependency("fddi", proto_tzsp);\r\nraw_ip_handle = find_dissector_add_dependency("raw_ip", proto_tzsp);\r\nieee_802_11_handle = find_dissector_add_dependency("wlan", proto_tzsp);\r\nieee_802_11_prism_handle = find_dissector_add_dependency("prism", proto_tzsp);\r\nieee_802_11_avs_handle = find_dissector_add_dependency("wlancap", proto_tzsp);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_TZSP, tzsp_handle);\r\n}
