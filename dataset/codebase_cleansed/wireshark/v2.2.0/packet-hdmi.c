static gint\r\ndissect_hdmi_edid(tvbuff_t *tvb, gint offset, packet_info *pinfo, proto_tree *tree)\r\n{\r\nproto_item *yi;\r\nproto_tree *edid_tree;\r\nguint64 edid_hdr;\r\nguint16 manf_id;\r\ngchar manf_id_str[4];\r\nguint8 week, year;\r\nint year_hf;\r\nedid_tree = proto_tree_add_subtree(tree, tvb,\r\noffset, -1, ett_hdmi_edid, NULL,\r\n"Extended Display Identification Data (EDID)");\r\nedid_hdr = tvb_get_ntoh64(tvb, offset);\r\nif (edid_hdr != EDID_HDR_VALUE)\r\nreturn offset;\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "EDID");\r\nproto_tree_add_item(edid_tree, hf_hdmi_edid_hdr,\r\ntvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\nmanf_id = tvb_get_ntohs(tvb, offset);\r\nmanf_id_str[0] = CAPITAL_LETTER(manf_id, 10);\r\nmanf_id_str[1] = CAPITAL_LETTER(manf_id, 5);\r\nmanf_id_str[2] = CAPITAL_LETTER(manf_id, 0);\r\nmanf_id_str[3] = 0;\r\nproto_tree_add_string(edid_tree, hf_hdmi_edid_manf_id,\r\ntvb, offset, 2, manf_id_str);\r\noffset += 2;\r\nproto_tree_add_item(edid_tree, hf_hdmi_edid_manf_prod_code,\r\ntvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(edid_tree, hf_hdmi_edid_manf_serial,\r\ntvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nweek = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(edid_tree, hf_hdmi_edid_manf_week,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nyear_hf = week == 255 ? hf_hdmi_edid_mod_year : hf_hdmi_edid_manf_year;\r\nyear = tvb_get_guint8(tvb, offset);\r\nyi = proto_tree_add_item(edid_tree, year_hf,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_item_append_text(yi, " (year %d)", 1990+year);\r\noffset += 1;\r\nproto_tree_add_item(edid_tree, hf_hdmi_edid_version, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic int\r\ndissect_hdmi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nguint8 addr;\r\ngint offset=0;\r\nproto_item *pi;\r\nproto_tree *hdmi_tree;\r\naddr = tvb_get_guint8(tvb, 0);\r\nif (!try_val_to_str(addr, hdmi_addr))\r\nreturn 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "HDMI");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\npi = proto_tree_add_item(tree, proto_hdmi, tvb, 0, -1, ENC_NA);\r\nhdmi_tree = proto_item_add_subtree(pi, ett_hdmi);\r\nif (addr&0x01) {\r\nset_address(&pinfo->src, AT_STRINGZ, (int)strlen(ADDR_RCV)+1, ADDR_RCV);\r\nset_address(&pinfo->dst, AT_STRINGZ, (int)strlen(ADDR_TRX)+1, ADDR_TRX);\r\npinfo->p2p_dir = P2P_DIR_RECV;\r\n}\r\nelse {\r\nset_address(&pinfo->src, AT_STRINGZ, (int)strlen(ADDR_TRX)+1, ADDR_TRX);\r\nset_address(&pinfo->dst, AT_STRINGZ, (int)strlen(ADDR_RCV)+1, ADDR_RCV);\r\npinfo->p2p_dir = P2P_DIR_SENT;\r\n}\r\nproto_tree_add_item(hdmi_tree, hf_hdmi_addr, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nif (HDCP_ADDR8(addr)) {\r\ntvbuff_t *hdcp_tvb;\r\nhdcp_tvb = tvb_new_subset_remaining(tvb, offset);\r\nreturn call_dissector(hdcp_handle, hdcp_tvb, pinfo, hdmi_tree);\r\n}\r\nif (addr == ADDR8_EDID_WRITE) {\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "EDID request");\r\nproto_tree_add_item(hdmi_tree, hf_hdmi_edid_offset,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nreturn dissect_hdmi_edid(tvb, offset, pinfo, hdmi_tree);\r\n}\r\nstatic void\r\nhdmi_fmt_edid_version( gchar *result, guint32 revision )\r\n{\r\ng_snprintf( result, ITEM_LABEL_LENGTH, "%d.%02d", (guint8)(( revision & 0xFF00 ) >> 8), (guint8)(revision & 0xFF) );\r\n}\r\nvoid\r\nproto_register_hdmi(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_hdmi_addr,\r\n{ "8bit I2C address", "hdmi.addr", FT_UINT8, BASE_HEX,\r\nVALS(hdmi_addr), 0, NULL, HFILL } },\r\n{ &hf_hdmi_edid_offset,\r\n{ "Offset", "hdmi.edid.offset",\r\nFT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL } },\r\n{ &hf_hdmi_edid_hdr,\r\n{ "EDID header", "hdmi.edid.hdr",\r\nFT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL } },\r\n{ &hf_hdmi_edid_manf_id,\r\n{ "Manufacturer ID", "hdmi.edid.manf_id",\r\nFT_STRING, STR_ASCII, NULL, 0, NULL, HFILL } },\r\n{ &hf_hdmi_edid_manf_prod_code,\r\n{ "Manufacturer product code", "hdmi.edid.manf_prod_code",\r\nFT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL } },\r\n{ &hf_hdmi_edid_manf_serial,\r\n{ "Serial number", "hdmi.edid.serial_num",\r\nFT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } },\r\n{ &hf_hdmi_edid_manf_week,\r\n{ "Week of manufacture", "hdmi.edid.manf_week",\r\nFT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } },\r\n{ &hf_hdmi_edid_mod_year,\r\n{ "Model year", "hdmi.edid.model_year",\r\nFT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } },\r\n{ &hf_hdmi_edid_manf_year,\r\n{ "Year of manufacture", "hdmi.edid.manf_year",\r\nFT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } },\r\n{ &hf_hdmi_edid_version,\r\n{ "EDID Version", "hdmi.edid.version",\r\nFT_UINT16, BASE_CUSTOM, CF_FUNC(hdmi_fmt_edid_version), 0, NULL, HFILL } }\r\n};\r\nstatic gint *ett[] = {\r\n&ett_hdmi,\r\n&ett_hdmi_edid\r\n};\r\nproto_hdmi = proto_register_protocol(\r\n"High-Definition Multimedia Interface", "HDMI", "hdmi");\r\nproto_register_field_array(proto_hdmi, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_hdmi(void)\r\n{\r\ndissector_handle_t hdmi_handle;\r\nhdcp_handle = find_dissector_add_dependency("hdcp", proto_hdmi);\r\nhdmi_handle = create_dissector_handle( dissect_hdmi, proto_hdmi );\r\ndissector_add_for_decode_as("i2c.message", hdmi_handle );\r\n}
