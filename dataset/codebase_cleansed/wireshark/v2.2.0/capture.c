static void\r\ncapture_callback_invoke(int event, capture_session *cap_session)\r\n{\r\ncapture_callback_data_t *cb;\r\nGList *cb_item = capture_callbacks;\r\ng_assert(cb_item != NULL);\r\nwhile(cb_item != NULL) {\r\ncb = (capture_callback_data_t *)cb_item->data;\r\ncb->cb_fct(event, cap_session, cb->user_data);\r\ncb_item = g_list_next(cb_item);\r\n}\r\n}\r\nvoid\r\ncapture_callback_add(capture_callback_t func, gpointer user_data)\r\n{\r\ncapture_callback_data_t *cb;\r\ncb = (capture_callback_data_t *)g_malloc(sizeof(capture_callback_data_t));\r\ncb->cb_fct = func;\r\ncb->user_data = user_data;\r\ncapture_callbacks = g_list_append(capture_callbacks, cb);\r\n}\r\nvoid\r\ncapture_callback_remove(capture_callback_t func, gpointer user_data)\r\n{\r\ncapture_callback_data_t *cb;\r\nGList *cb_item = capture_callbacks;\r\nwhile(cb_item != NULL) {\r\ncb = (capture_callback_data_t *)cb_item->data;\r\nif(cb->cb_fct == func && cb->user_data == user_data) {\r\ncapture_callbacks = g_list_remove(capture_callbacks, cb);\r\ng_free(cb);\r\nreturn;\r\n}\r\ncb_item = g_list_next(cb_item);\r\n}\r\ng_assert_not_reached();\r\n}\r\ngboolean\r\ncapture_start(capture_options *capture_opts, capture_session *cap_session, info_data_t* cap_data, void(*update_cb)(void))\r\n{\r\ngboolean ret;\r\nGString *source;\r\ncap_session->state = CAPTURE_PREPARING;\r\ncap_session->count = 0;\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, "Capture Start ...");\r\nsource = get_iface_list_string(capture_opts, IFLIST_SHOW_FILTER);\r\ncf_set_tempfile_source((capture_file *)cap_session->cf, source->str);\r\ng_string_free(source, TRUE);\r\nret = sync_pipe_start(capture_opts, cap_session, cap_data, update_cb);\r\nif(!ret) {\r\nif(capture_opts->save_file != NULL) {\r\ng_free(capture_opts->save_file);\r\ncapture_opts->save_file = NULL;\r\n}\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, "Capture Start failed.");\r\ncap_session->state = CAPTURE_STOPPED;\r\n} else {\r\ncapture_callback_invoke(capture_cb_capture_prepared, cap_session);\r\nif(capture_opts->show_info)\r\ncapture_info_open(cap_session, cap_data);\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\ncapture_stop(capture_session *cap_session)\r\n{\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, "Capture Stop ...");\r\ncapture_callback_invoke(capture_cb_capture_stopping, cap_session);\r\nsync_pipe_stop(cap_session);\r\n}\r\nvoid\r\ncapture_restart(capture_session *cap_session)\r\n{\r\ncapture_options *capture_opts = cap_session->capture_opts;\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, "Capture Restart");\r\ncapture_opts->restart = TRUE;\r\ncapture_stop(cap_session);\r\n}\r\nvoid\r\ncapture_kill_child(capture_session *cap_session)\r\n{\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_INFO, "Capture Kill");\r\nsync_pipe_kill(cap_session->fork_child);\r\n}\r\nstatic gboolean\r\ncapture_input_read_all(capture_session *cap_session, gboolean is_tempfile,\r\ngboolean drops_known, guint32 drops)\r\n{\r\ncapture_options *capture_opts = cap_session->capture_opts;\r\nint err;\r\nif (cf_open((capture_file *)cap_session->cf, capture_opts->save_file, WTAP_TYPE_AUTO, is_tempfile, &err) != CF_OK) {\r\nreturn FALSE;\r\n}\r\ncf_set_rfcode((capture_file *)cap_session->cf, NULL);\r\nif (drops_known) {\r\ncf_set_drops_known((capture_file *)cap_session->cf, TRUE);\r\ncf_set_drops((capture_file *)cap_session->cf, drops);\r\n}\r\nswitch (cf_read((capture_file *)cap_session->cf, FALSE)) {\r\ncase CF_READ_OK:\r\ncase CF_READ_ERROR:\r\nbreak;\r\ncase CF_READ_ABORTED:\r\nmain_window_nested_quit();\r\nreturn FALSE;\r\n}\r\nif(cap_session->count == 0 && !capture_opts->restart) {\r\nsimple_dialog(ESD_TYPE_INFO, ESD_BTN_OK,\r\n"%sNo packets captured.%s\n"\r\n"\n"\r\n"As no data was captured, closing the %scapture file.\n"\r\n"\n"\r\n"\n"\r\n"Help about capturing can be found at\n"\r\n"\n"\r\n" https://wiki.wireshark.org/CaptureSetup"\r\n#ifdef _WIN32\r\n"\n\n"\r\n"Wireless (Wi-Fi/WLAN):\n"\r\n"Try to switch off promiscuous mode in the Capture Options"\r\n#endif\r\n"",\r\nsimple_dialog_primary_start(), simple_dialog_primary_end(),\r\n(cf_is_tempfile((capture_file *)cap_session->cf)) ? "temporary " : "");\r\ncf_close((capture_file *)cap_session->cf);\r\n}\r\nreturn TRUE;\r\n}\r\ngboolean\r\ncapture_input_new_file(capture_session *cap_session, gchar *new_file)\r\n{\r\ncapture_options *capture_opts = cap_session->capture_opts;\r\ngboolean is_tempfile;\r\nint err;\r\nif(cap_session->state == CAPTURE_PREPARING) {\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, "Capture started");\r\n}\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, "File: \"%s\"", new_file);\r\ng_assert(cap_session->state == CAPTURE_PREPARING || cap_session->state == CAPTURE_RUNNING);\r\nif(capture_opts->save_file != NULL) {\r\nif( ((capture_file *) cap_session->cf)->state != FILE_CLOSED) {\r\nif(capture_opts->real_time_mode) {\r\ncapture_callback_invoke(capture_cb_capture_update_finished, cap_session);\r\ncf_finish_tail((capture_file *)cap_session->cf, &err);\r\ncf_close((capture_file *)cap_session->cf);\r\n} else {\r\ncapture_callback_invoke(capture_cb_capture_fixed_finished, cap_session);\r\n}\r\n}\r\ng_free(capture_opts->save_file);\r\nis_tempfile = FALSE;\r\ncf_set_tempfile((capture_file *)cap_session->cf, FALSE);\r\n} else {\r\nis_tempfile = TRUE;\r\ncf_set_tempfile((capture_file *)cap_session->cf, TRUE);\r\n}\r\ncapture_opts->save_file = g_strdup(new_file);\r\nif(capture_opts->real_time_mode) {\r\nswitch(cf_open((capture_file *)cap_session->cf, capture_opts->save_file, WTAP_TYPE_AUTO, is_tempfile, &err)) {\r\ncase CF_OK:\r\nbreak;\r\ncase CF_ERROR:\r\ng_free(capture_opts->save_file);\r\ncapture_opts->save_file = NULL;\r\nreturn FALSE;\r\n}\r\n} else {\r\ncapture_callback_invoke(capture_cb_capture_prepared, cap_session);\r\n}\r\nif(capture_opts->show_info) {\r\nif (!capture_info_new_file(new_file, cap_session->cap_data_info))\r\nreturn FALSE;\r\n}\r\nif(capture_opts->real_time_mode) {\r\ncapture_callback_invoke(capture_cb_capture_update_started, cap_session);\r\n} else {\r\ncapture_callback_invoke(capture_cb_capture_fixed_started, cap_session);\r\n}\r\ncap_session->state = CAPTURE_RUNNING;\r\nreturn TRUE;\r\n}\r\nvoid\r\ncapture_input_new_packets(capture_session *cap_session, int to_read)\r\n{\r\ncapture_options *capture_opts = cap_session->capture_opts;\r\nint err;\r\ng_assert(capture_opts->save_file);\r\nif(capture_opts->real_time_mode) {\r\nswitch (cf_continue_tail((capture_file *)cap_session->cf, to_read, &err)) {\r\ncase CF_READ_OK:\r\ncase CF_READ_ERROR:\r\ncapture_callback_invoke(capture_cb_capture_update_continue, cap_session);\r\nbreak;\r\ncase CF_READ_ABORTED:\r\ncapture_kill_child(cap_session);\r\nbreak;\r\n}\r\n} else {\r\ncf_fake_continue_tail((capture_file *)cap_session->cf);\r\ncapture_callback_invoke(capture_cb_capture_fixed_continue, cap_session);\r\n}\r\n#ifndef _WIN32\r\nmain_window_update();\r\n#endif\r\nif(capture_opts->show_info)\r\ncapture_info_new_packets(to_read, cap_session->cap_data_info);\r\n}\r\nvoid\r\ncapture_input_drops(capture_session *cap_session, guint32 dropped)\r\n{\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_INFO, "%u packet%s dropped", dropped, plurality(dropped, "", "s"));\r\ng_assert(cap_session->state == CAPTURE_RUNNING);\r\ncf_set_drops_known((capture_file *)cap_session->cf, TRUE);\r\ncf_set_drops((capture_file *)cap_session->cf, dropped);\r\n}\r\nvoid\r\ncapture_input_error_message(capture_session *cap_session, char *error_msg,\r\nchar *secondary_error_msg)\r\n{\r\ngchar *safe_error_msg;\r\ngchar *safe_secondary_error_msg;\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, "Error message from child: \"%s\", \"%s\"",\r\nerror_msg, secondary_error_msg);\r\ng_assert(cap_session->state == CAPTURE_PREPARING || cap_session->state == CAPTURE_RUNNING);\r\nsafe_error_msg = simple_dialog_format_message(error_msg);\r\nif (*secondary_error_msg != '\0') {\r\nsafe_secondary_error_msg = simple_dialog_format_message(secondary_error_msg);\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s%s%s\n\n%s",\r\nsimple_dialog_primary_start(), safe_error_msg,\r\nsimple_dialog_primary_end(), safe_secondary_error_msg);\r\ng_free(safe_secondary_error_msg);\r\n} else {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s%s%s",\r\nsimple_dialog_primary_start(), safe_error_msg,\r\nsimple_dialog_primary_end());\r\n}\r\ng_free(safe_error_msg);\r\n}\r\nvoid\r\ncapture_input_cfilter_error_message(capture_session *cap_session, guint i,\r\nchar *error_message)\r\n{\r\ncapture_options *capture_opts = cap_session->capture_opts;\r\ndfilter_t *rfcode = NULL;\r\ngchar *safe_cfilter;\r\ngchar *safe_descr;\r\ngchar *safe_cfilter_error_msg;\r\ninterface_options interface_opts;\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, "Capture filter error message from child: \"%s\"", error_message);\r\ng_assert(cap_session->state == CAPTURE_PREPARING || cap_session->state == CAPTURE_RUNNING);\r\ng_assert(i < capture_opts->ifaces->len);\r\ninterface_opts = g_array_index(capture_opts->ifaces, interface_options, i);\r\nsafe_cfilter = simple_dialog_format_message(interface_opts.cfilter);\r\nsafe_descr = simple_dialog_format_message(interface_opts.descr);\r\nsafe_cfilter_error_msg = simple_dialog_format_message(error_message);\r\nif (dfilter_compile(interface_opts.cfilter, &rfcode, NULL) && rfcode != NULL) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"%sInvalid capture filter \"%s\" for interface %s.%s\n"\r\n"\n"\r\n"That string looks like a valid display filter; however, it isn't a valid\n"\r\n"capture filter (%s).\n"\r\n"\n"\r\n"Note that display filters and capture filters don't have the same syntax,\n"\r\n"so you can't use most display filter expressions as capture filters.\n"\r\n"\n"\r\n"See the User's Guide for a description of the capture filter syntax.",\r\nsimple_dialog_primary_start(), safe_cfilter, safe_descr,\r\nsimple_dialog_primary_end(), safe_cfilter_error_msg);\r\ndfilter_free(rfcode);\r\n} else {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"%sInvalid capture filter \"%s\" for interface %s.%s\n"\r\n"\n"\r\n"That string isn't a valid capture filter (%s).\n"\r\n"See the User's Guide for a description of the capture filter syntax.",\r\nsimple_dialog_primary_start(), safe_cfilter, safe_descr,\r\nsimple_dialog_primary_end(), safe_cfilter_error_msg);\r\n}\r\ng_free(safe_cfilter_error_msg);\r\ng_free(safe_descr);\r\ng_free(safe_cfilter);\r\n}\r\nvoid\r\ncapture_input_closed(capture_session *cap_session, gchar *msg)\r\n{\r\ncapture_options *capture_opts = cap_session->capture_opts;\r\nint err;\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, "Capture stopped.");\r\ng_assert(cap_session->state == CAPTURE_PREPARING || cap_session->state == CAPTURE_RUNNING);\r\nif (msg != NULL)\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s", msg);\r\nif(cap_session->state == CAPTURE_PREPARING) {\r\ncapture_callback_invoke(capture_cb_capture_failed, cap_session);\r\n} else {\r\nif(capture_opts->real_time_mode) {\r\ncf_read_status_t status;\r\nstatus = cf_finish_tail((capture_file *)cap_session->cf, &err);\r\ncapture_callback_invoke(capture_cb_capture_update_finished, cap_session);\r\nswitch (status) {\r\ncase CF_READ_OK:\r\nif (cap_session->count == 0 && !capture_opts->restart) {\r\nsimple_dialog(ESD_TYPE_INFO, ESD_BTN_OK,\r\n"%sNo packets captured.%s\n"\r\n"\n"\r\n"As no data was captured, closing the %scapture file.\n"\r\n"\n"\r\n"\n"\r\n"Help about capturing can be found at\n"\r\n"\n"\r\n" https://wiki.wireshark.org/CaptureSetup"\r\n#ifdef _WIN32\r\n"\n\n"\r\n"Wireless (Wi-Fi/WLAN):\n"\r\n"Try to switch off promiscuous mode in the Capture Options."\r\n#endif\r\n"",\r\nsimple_dialog_primary_start(), simple_dialog_primary_end(),\r\ncf_is_tempfile((capture_file *)cap_session->cf) ? "temporary " : "");\r\ncf_close((capture_file *)cap_session->cf);\r\n}\r\nbreak;\r\ncase CF_READ_ERROR:\r\nbreak;\r\ncase CF_READ_ABORTED:\r\nmain_window_quit();\r\nbreak;\r\n}\r\n} else {\r\ncapture_callback_invoke(capture_cb_capture_fixed_finished, cap_session);\r\nif(capture_opts->save_file != NULL) {\r\ncapture_input_read_all(cap_session, cf_is_tempfile((capture_file *)cap_session->cf),\r\ncf_get_drops_known((capture_file *)cap_session->cf), cf_get_drops((capture_file *)cap_session->cf));\r\n}\r\n}\r\n}\r\nif(capture_opts->show_info)\r\ncapture_info_close(cap_session->cap_data_info);\r\ncap_session->state = CAPTURE_STOPPED;\r\nif(capture_opts->save_file == NULL) {\r\ncf_close((capture_file *)cap_session->cf);\r\nreturn;\r\n}\r\nif(capture_opts->restart) {\r\ncapture_opts->restart = FALSE;\r\nws_unlink(capture_opts->save_file);\r\nif ((capture_opts->multi_files_on) && (capture_opts->orig_save_file != NULL)) {\r\ng_free(capture_opts->save_file);\r\ncapture_opts->save_file = g_strdup(capture_opts->orig_save_file);\r\n}\r\nif(cf_is_tempfile((capture_file *)cap_session->cf)) {\r\ng_free(capture_opts->save_file);\r\ncapture_opts->save_file = NULL;\r\n}\r\nif (capture_opts->ifaces->len == 0) {\r\ncollect_ifaces(capture_opts);\r\n}\r\ncf_close((capture_file *)cap_session->cf);\r\ncapture_start(capture_opts, cap_session, cap_session->cap_data_info, NULL);\r\n} else {\r\ng_free(capture_opts->save_file);\r\ncapture_opts->save_file = NULL;\r\n}\r\n}\r\nif_stat_cache_t *\r\ncapture_stat_start(capture_options *capture_opts) {\r\nint stat_fd;\r\nws_process_id fork_child;\r\ngchar *msg;\r\nif_stat_cache_t *sc = NULL;\r\nif_stat_cache_item_t *sc_item;\r\nguint i;\r\ninterface_t device;\r\nif (sync_interface_stats_open(&stat_fd, &fork_child, &msg, NULL) == 0) {\r\nsc = (if_stat_cache_t *)g_malloc(sizeof(if_stat_cache_t));\r\nsc->stat_fd = stat_fd;\r\nsc->fork_child = fork_child;\r\nsc->cache_list = NULL;\r\nfor (i = 0; i < capture_opts->all_ifaces->len; i++) {\r\ndevice = g_array_index(capture_opts->all_ifaces, interface_t, i);\r\nif (device.type != IF_PIPE) {\r\nsc_item = (if_stat_cache_item_t *)g_malloc0(sizeof(if_stat_cache_item_t));\r\nsc_item->name = g_strdup(device.if_info.name);\r\nsc->cache_list = g_list_append(sc->cache_list, sc_item);\r\n}\r\n}\r\n} else {\r\ng_free(msg);\r\n}\r\nreturn sc;\r\n}\r\nstatic void\r\ncapture_stat_cache_update(if_stat_cache_t *sc) {\r\ngchar stat_line[MAX_STAT_LINE_LEN] = "";\r\ngchar **stat_parts;\r\nGList *sc_entry;\r\nif_stat_cache_item_t *sc_item;\r\nif (!sc)\r\nreturn;\r\nwhile (sync_pipe_gets_nonblock(sc->stat_fd, stat_line, MAX_STAT_LINE_LEN) > 0) {\r\ng_strstrip(stat_line);\r\nstat_parts = g_strsplit(stat_line, "\t", 3);\r\nif (stat_parts[0] == NULL || stat_parts[1] == NULL ||\r\nstat_parts[2] == NULL) {\r\ng_strfreev(stat_parts);\r\ncontinue;\r\n}\r\nfor (sc_entry = sc->cache_list; sc_entry != NULL; sc_entry = g_list_next(sc_entry)) {\r\nsc_item = (if_stat_cache_item_t *)sc_entry->data;\r\nif (strcmp(sc_item->name, stat_parts[0]) == 0) {\r\nsc_item->ps.ps_recv = (u_int) strtoul(stat_parts[1], NULL, 10);\r\nsc_item->ps.ps_drop = (u_int) strtoul(stat_parts[2], NULL, 10);\r\n}\r\n}\r\ng_strfreev(stat_parts);\r\n}\r\n}\r\ngboolean\r\ncapture_stats(if_stat_cache_t *sc, char *ifname, struct pcap_stat *ps) {\r\nGList *sc_entry;\r\nif_stat_cache_item_t *sc_item;\r\nif (!sc || !ifname || !ps) {\r\nreturn FALSE;\r\n}\r\ncapture_stat_cache_update(sc);\r\nfor (sc_entry = sc->cache_list; sc_entry != NULL; sc_entry = g_list_next(sc_entry)) {\r\nsc_item = (if_stat_cache_item_t *)sc_entry->data;\r\nif (strcmp(sc_item->name, ifname) == 0) {\r\nmemcpy(ps, &sc_item->ps, sizeof(struct pcap_stat));\r\nreturn TRUE;\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nvoid\r\ncapture_stat_stop(if_stat_cache_t *sc) {\r\nGList *sc_entry;\r\nif_stat_cache_item_t *sc_item;\r\nint ret;\r\ngchar *msg;\r\nif (!sc)\r\nreturn;\r\nret = sync_interface_stats_close(&sc->stat_fd, &sc->fork_child, &msg);\r\nif (ret == -1) {\r\ng_free(msg);\r\n}\r\nfor (sc_entry = sc->cache_list; sc_entry != NULL; sc_entry = g_list_next(sc_entry)) {\r\nsc_item = (if_stat_cache_item_t *)sc_entry->data;\r\ng_free(sc_item->name);\r\ng_free(sc_item);\r\n}\r\ng_list_free(sc->cache_list);\r\ng_free(sc);\r\n}
