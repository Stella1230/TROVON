static gboolean\r\nmp2t_read_packet(mp2t_filetype_t *mp2t, FILE_T fh, gint64 offset,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err,\r\ngchar **err_info)\r\n{\r\nguint64 tmp;\r\nws_buffer_assure_space(buf, MP2T_SIZE);\r\nif (!wtap_read_bytes_or_eof(fh, ws_buffer_start_ptr(buf), MP2T_SIZE, err, err_info))\r\nreturn FALSE;\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS;\r\ntmp = ((guint64)(offset - mp2t->start_offset) * 8);\r\nphdr->ts.secs = (time_t)(tmp / mp2t->bitrate);\r\nphdr->ts.nsecs = (int)((tmp % mp2t->bitrate) * 1000000000 / mp2t->bitrate);\r\nphdr->caplen = MP2T_SIZE;\r\nphdr->len = MP2T_SIZE;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nmp2t_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\r\n{\r\nmp2t_filetype_t *mp2t;\r\nmp2t = (mp2t_filetype_t*) wth->priv;\r\n*data_offset = file_tell(wth->fh);\r\nif (!mp2t_read_packet(mp2t, wth->fh, *data_offset, &wth->phdr,\r\nwth->frame_buffer, err, err_info)) {\r\nreturn FALSE;\r\n}\r\nif (mp2t->trailer_len!=0) {\r\nif (-1 == file_seek(wth->fh, mp2t->trailer_len, SEEK_CUR, err)) {\r\nreturn FALSE;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nmp2t_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nmp2t_filetype_t *mp2t;\r\nif (-1 == file_seek(wth->random_fh, seek_off, SEEK_SET, err)) {\r\nreturn FALSE;\r\n}\r\nmp2t = (mp2t_filetype_t*) wth->priv;\r\nif (!mp2t_read_packet(mp2t, wth->random_fh, seek_off, phdr, buf,\r\nerr, err_info)) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic guint64\r\nmp2t_read_pcr(guint8 *buffer)\r\n{\r\nguint64 base;\r\nguint64 ext;\r\nbase = pntoh40(buffer);\r\nbase >>= 7;\r\next = pntoh16(&buffer[4]);\r\next &= 0x01ff;\r\nreturn (base * 300 + ext);\r\n}\r\nstatic gboolean\r\nmp2t_find_next_pcr(wtap *wth, guint8 trailer_len,\r\nint *err, gchar **err_info, guint32 *idx, guint64 *pcr, guint16 *pid)\r\n{\r\nguint8 buffer[MP2T_SIZE+TRAILER_LEN_MAX];\r\ngboolean found;\r\nguint8 afc;\r\nguint timeout = 0;\r\nfound = FALSE;\r\nwhile (FALSE == found && timeout++ < SYNC_STEPS * SYNC_STEPS) {\r\n(*idx)++;\r\nif (!wtap_read_bytes_or_eof(\r\nwth->fh, buffer, MP2T_SIZE+trailer_len, err, err_info)) {\r\nreturn FALSE;\r\n}\r\nif (MP2T_SYNC_BYTE != buffer[0]) {\r\ncontinue;\r\n}\r\nafc = 3 & (buffer[3] >> 4);\r\nif (afc < 2) {\r\ncontinue;\r\n}\r\nif (buffer[4] < 7) {\r\ncontinue;\r\n}\r\nif (0x10 != (0x10 & buffer[5])) {\r\ncontinue;\r\n}\r\n*pcr = mp2t_read_pcr(&buffer[6]);\r\n*pid = 0x01ff & pntoh16(&buffer[1]);\r\nfound = TRUE;\r\n}\r\nreturn found;\r\n}\r\nstatic wtap_open_return_val\r\nmp2t_bits_per_second(wtap *wth, guint32 first, guint8 trailer_len,\r\nguint64 *bitrate, int *err, gchar **err_info)\r\n{\r\nguint32 pn1, pn2;\r\nguint64 pcr1, pcr2;\r\nguint16 pid1, pid2;\r\nguint32 idx;\r\nguint64 pcr_delta, bits_passed;\r\nidx = first;\r\nif (!mp2t_find_next_pcr(wth, trailer_len, err, err_info, &idx, &pcr1, &pid1)) {\r\nif (*err == WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_NOT_MINE;\r\nif (*err != 0)\r\nreturn WTAP_OPEN_ERROR;\r\n*bitrate = MP2T_QAM64_BITRATE;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\npn1 = idx;\r\npn2 = pn1;\r\nwhile (pn1 == pn2) {\r\nif (!mp2t_find_next_pcr(wth, trailer_len, err, err_info, &idx, &pcr2, &pid2)) {\r\nif (*err == WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_NOT_MINE;\r\nif (*err != 0)\r\nreturn WTAP_OPEN_ERROR;\r\n*bitrate = MP2T_QAM64_BITRATE;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nif (pid1 == pid2) {\r\npn2 = idx;\r\n}\r\n}\r\nif (pcr2 <= pcr1) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\npcr_delta = pcr2 - pcr1;\r\nbits_passed = (guint64)MP2T_SIZE * (pn2 - pn1) * 8;\r\n*bitrate = ((MP2T_PCR_CLOCK * bits_passed) / pcr_delta);\r\nif (*bitrate == 0) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nwtap_open_return_val\r\nmp2t_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nguint8 buffer[MP2T_SIZE+TRAILER_LEN_MAX];\r\nguint8 trailer_len = 0;\r\nguint sync_steps = 0;\r\nguint i;\r\nguint32 first = 0;\r\nmp2t_filetype_t *mp2t;\r\nwtap_open_return_val status;\r\nguint64 bitrate;\r\nif (!wtap_read_bytes(wth->fh, buffer, MP2T_SIZE, err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nfor (i = 0; i < MP2T_SIZE; i++) {\r\nif (MP2T_SYNC_BYTE == buffer[i]) {\r\nfirst = i;\r\ngoto found;\r\n}\r\n}\r\nreturn WTAP_OPEN_NOT_MINE;\r\nfound:\r\nif (-1 == file_seek(wth->fh, first, SEEK_SET, err)) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\ndo {\r\nif (!wtap_read_bytes(wth->fh, buffer, MP2T_SIZE+trailer_len, err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nif(sync_steps<2) return WTAP_OPEN_NOT_MINE;\r\nbreak;\r\n}\r\nif (buffer[0] == MP2T_SYNC_BYTE) {\r\nsync_steps++;\r\n}\r\nelse {\r\nif (trailer_len>0)\r\nreturn WTAP_OPEN_NOT_MINE;\r\nfor (i=0; i<TRAILER_LEN_MAX; i++) {\r\nif (buffer[i] == MP2T_SYNC_BYTE) {\r\ntrailer_len = i;\r\nif (-1 == file_seek(wth->fh, first, SEEK_SET, err)) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nsync_steps = 0;\r\nbreak;\r\n}\r\n}\r\nif (i==TRAILER_LEN_MAX)\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\n} while (sync_steps < SYNC_STEPS);\r\nif (-1 == file_seek(wth->fh, first, SEEK_SET, err)) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nstatus = mp2t_bits_per_second(wth, first, trailer_len,\r\n&bitrate, err, err_info);\r\nif (status != WTAP_OPEN_MINE) {\r\nreturn status;\r\n}\r\nif (-1 == file_seek(wth->fh, first, SEEK_SET, err)) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_MPEG_2_TS;\r\nwth->file_encap = WTAP_ENCAP_MPEG_2_TS;\r\nwth->file_tsprec = WTAP_TSPREC_NSEC;\r\nwth->subtype_read = mp2t_read;\r\nwth->subtype_seek_read = mp2t_seek_read;\r\nwth->snapshot_length = 0;\r\nmp2t = (mp2t_filetype_t*) g_malloc(sizeof(mp2t_filetype_t));\r\nwth->priv = mp2t;\r\nmp2t->start_offset = first;\r\nmp2t->trailer_len = trailer_len;\r\nmp2t->bitrate = bitrate;\r\nreturn WTAP_OPEN_MINE;\r\n}
