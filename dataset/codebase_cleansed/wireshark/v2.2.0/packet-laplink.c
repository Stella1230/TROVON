static gint\r\ndissect_laplink_udp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nint offset = 0;\r\nproto_item *ti;\r\nproto_tree *laplink_tree;\r\nguint32 udp_ident;\r\nconst gchar *udp_ident_string;\r\nif (!tvb_bytes_exist(tvb, offset, 4))\r\nreturn 0;\r\nudp_ident = tvb_get_ntohl(tvb, offset);\r\nudp_ident_string = try_val_to_str(udp_ident, laplink_udp_magic);\r\nif (udp_ident_string == NULL)\r\nreturn 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Laplink");\r\ncol_add_str(pinfo->cinfo, COL_INFO, udp_ident_string);\r\nif (tree){\r\nti = proto_tree_add_item(tree, proto_laplink, tvb, 0, -1, ENC_NA);\r\nlaplink_tree = proto_item_add_subtree(ti, ett_laplink);\r\nproto_tree_add_uint(laplink_tree, hf_laplink_udp_ident, tvb, offset, 4, udp_ident);\r\noffset += 4;\r\nproto_tree_add_item(laplink_tree, hf_laplink_udp_name, tvb, offset, -1, ENC_ASCII|ENC_NA);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_laplink_tcp_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\nint length = 0;\r\nproto_item *ti;\r\nproto_tree *laplink_tree;\r\nguint32 tcp_ident;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Laplink");\r\ntcp_ident = tvb_get_ntohl(tvb, offset);\r\ncol_add_str(pinfo->cinfo, COL_INFO,\r\nval_to_str(tcp_ident, laplink_tcp_magic, "TCP TBA (%u)"));\r\nif (tree){\r\nti = proto_tree_add_item(tree, proto_laplink, tvb, 0, -1, ENC_NA);\r\nlaplink_tree = proto_item_add_subtree(ti, ett_laplink);\r\nproto_tree_add_item(laplink_tree, hf_laplink_tcp_ident, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nlength = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(laplink_tree, hf_laplink_tcp_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(laplink_tree, hf_laplink_tcp_data, tvb, offset, length, ENC_NA);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic guint\r\nget_laplink_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nguint plen;\r\nplen = (tvb_get_ntohs(tvb, offset+4) + 2 + 4);\r\nreturn plen;\r\n}\r\nstatic int\r\ndissect_laplink_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, tree, laplink_desegment,\r\n6, get_laplink_pdu_len,\r\ndissect_laplink_tcp_pdu, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_laplink(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_laplink_udp_ident,\r\n{ "UDP Ident", "laplink.udp_ident",\r\nFT_UINT32, BASE_HEX, VALS(laplink_udp_magic), 0x0,\r\n"Unknown magic", HFILL }\r\n},\r\n{ &hf_laplink_udp_name,\r\n{ "UDP Name", "laplink.udp_name",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\n"Machine name", HFILL }\r\n},\r\n{ &hf_laplink_tcp_ident,\r\n{ "TCP Ident", "laplink.tcp_ident",\r\nFT_UINT32, BASE_HEX, VALS(laplink_tcp_magic), 0x0,\r\n"Unknown magic", HFILL }\r\n},\r\n{ &hf_laplink_tcp_length,\r\n{ "TCP Data payload length", "laplink.tcp_length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Length of remaining payload", HFILL }\r\n},\r\n{ &hf_laplink_tcp_data,\r\n{ "Unknown TCP data", "laplink.tcp_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"TCP data", HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_laplink,\r\n};\r\nmodule_t *laplink_module;\r\nproto_laplink = proto_register_protocol("Laplink",\r\n"Laplink", "laplink");\r\nproto_register_field_array(proto_laplink, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nlaplink_module = prefs_register_protocol(proto_laplink, NULL);\r\nprefs_register_bool_preference(laplink_module, "desegment_laplink_over_tcp",\r\n"Reassemble Laplink over TCP messages spanning multiple TCP segments",\r\n"Whether the Laplink dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&laplink_desegment);\r\n}\r\nvoid\r\nproto_reg_handoff_laplink(void)\r\n{\r\ndissector_handle_t laplink_udp_handle;\r\ndissector_handle_t laplink_tcp_handle;\r\nlaplink_tcp_handle = create_dissector_handle(dissect_laplink_tcp,\r\nproto_laplink);\r\ndissector_add_uint("tcp.port", TCP_PORT_LAPLINK, laplink_tcp_handle);\r\nlaplink_udp_handle = create_dissector_handle(dissect_laplink_udp,\r\nproto_laplink);\r\ndissector_add_uint("udp.port", UDP_PORT_LAPLINK, laplink_udp_handle);\r\n}
