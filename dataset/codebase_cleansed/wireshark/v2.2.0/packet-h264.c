static gboolean\r\nh264_byte_aligned(int bit_offset)\r\n{\r\nif (bit_offset&0x3)\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\nstatic guint32\r\ndissect_h264_exp_golomb_code(proto_tree *tree, int hf_index, tvbuff_t *tvb, gint *start_bit_offset, h264_golomb_descriptors descriptor)\r\n{\r\ngint leading_zero_bits, bit_offset, start_offset;\r\nguint32 codenum, mask, value, tmp;\r\ngint32 se_value = 0;\r\ngint b;\r\nchar *str;\r\nint bit;\r\nint i;\r\nheader_field_info *hf_field = NULL;\r\nstart_offset = *start_bit_offset>>3;\r\nif (hf_index > -1)\r\nhf_field = proto_registrar_get_nth(hf_index);\r\nbit_offset = *start_bit_offset;\r\nstr = (char *)wmem_alloc(wmem_packet_scope(), 256);\r\nstr[0] = '\0';\r\nfor (bit=0; bit<((int)(bit_offset&0x07)); bit++) {\r\nif (bit && (!(bit%4))) {\r\ng_strlcat(str, " ", 256);\r\n}\r\ng_strlcat(str,".", 256);\r\n}\r\nleading_zero_bits = -1;\r\nfor (b = 0; !b; leading_zero_bits++) {\r\nif (bit && (!(bit%4))) {\r\ng_strlcat(str, " ", 256);\r\n}\r\nif (bit && (!(bit%8))) {\r\ng_strlcat(str, " ", 256);\r\n}\r\nb = tvb_get_bits8(tvb, bit_offset, 1);\r\nif (b != 0) {\r\ng_strlcat(str, "1", 256);\r\n} else {\r\ng_strlcat(str, "0", 256);\r\n}\r\nbit++;\r\nbit_offset++;\r\n}\r\nif (leading_zero_bits == 0) {\r\ncodenum = 0;\r\n*start_bit_offset = bit_offset;\r\nfor (; bit%8; bit++) {\r\nif (bit && (!(bit%4))) {\r\ng_strlcat(str, " ", 256);\r\n}\r\ng_strlcat(str,".", 256);\r\n}\r\nif (hf_field) {\r\ng_strlcat(str," = ", 256);\r\ng_strlcat(str, hf_field->name, 256);\r\nswitch (descriptor) {\r\ncase H264_SE_V:\r\nif (hf_field->type == FT_INT32) {\r\nif (hf_field->strings) {\r\nproto_tree_add_int_format(tree, hf_index, tvb, start_offset, 1, codenum,\r\n"%s: %s (%d)",\r\nstr,\r\nval_to_str_const(codenum, cVALS(hf_field->strings), "Unknown "),\r\ncodenum);\r\n} else {\r\nswitch (hf_field->display) {\r\ncase BASE_DEC:\r\nproto_tree_add_int_format(tree, hf_index, tvb, start_offset, 1, codenum,\r\n"%s: %d",\r\nstr,\r\ncodenum);\r\nbreak;\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn codenum;\r\ndefault:\r\nbreak;\r\n}\r\nif (hf_field->type == FT_UINT32) {\r\nif (hf_field->strings) {\r\nproto_tree_add_uint_format(tree, hf_index, tvb, start_offset, 1, codenum,\r\n"%s: %s (%u)",\r\nstr,\r\nval_to_str_const(codenum, cVALS(hf_field->strings), "Unknown "),\r\ncodenum);\r\n} else {\r\nswitch (hf_field->display) {\r\ncase BASE_DEC:\r\nproto_tree_add_uint_format(tree, hf_index, tvb, start_offset, 1, codenum,\r\n"%s: %u",\r\nstr,\r\ncodenum);\r\nbreak;\r\ncase BASE_HEX:\r\nproto_tree_add_uint_format(tree, hf_index, tvb, start_offset, 1, codenum,\r\n"%s: 0x%x",\r\nstr,\r\ncodenum);\r\nbreak;\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nbreak;\r\n}\r\n}\r\n} else {\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\n}\r\n}\r\nreturn codenum;\r\n}\r\ncodenum = 1;\r\ncodenum = codenum << leading_zero_bits;\r\nmask = codenum>>1;\r\nif (leading_zero_bits > 32)\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nelse if (leading_zero_bits > 16)\r\nvalue = tvb_get_bits32(tvb, bit_offset, leading_zero_bits, ENC_BIG_ENDIAN);\r\nelse if (leading_zero_bits > 8)\r\nvalue = tvb_get_bits16(tvb, bit_offset, leading_zero_bits, ENC_BIG_ENDIAN);\r\nelse\r\nvalue = tvb_get_bits8(tvb, bit_offset, leading_zero_bits);\r\ncodenum = (codenum-1) + value;\r\nbit_offset = bit_offset + leading_zero_bits;\r\nfor (i=0; i<leading_zero_bits; i++) {\r\nif (bit && (!(bit%4))) {\r\ng_strlcat(str, " ", 256);\r\n}\r\nif (bit && (!(bit%8))) {\r\ng_strlcat(str, " ", 256);\r\n}\r\nbit++;\r\ntmp = value & mask;\r\nif (tmp != 0) {\r\ng_strlcat(str, "1", 256);\r\n} else {\r\ng_strlcat(str, "0", 256);\r\n}\r\nmask = mask>>1;\r\n}\r\nfor ( ; bit%8; bit++) {\r\nif (bit && (!(bit%4))) {\r\ng_strlcat(str, " ", 256);\r\n}\r\ng_strlcat(str,".", 256);\r\n}\r\nswitch (descriptor) {\r\ncase H264_SE_V:\r\nse_value = (codenum + 1) >> 1;\r\nif (!(se_value & 1)) {\r\nse_value = - se_value;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (hf_field) {\r\ng_strlcat(str," = ", 256);\r\ng_strlcat(str, hf_field->name, 256);\r\nswitch (descriptor) {\r\ncase H264_SE_V:\r\ng_strlcat(str,"(se(v))", 256);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif ((hf_field->type == FT_UINT32) && (descriptor == H264_UE_V)) {\r\nif (hf_field->strings) {\r\nproto_tree_add_uint_format(tree, hf_index, tvb, start_offset, 1, codenum,\r\n"%s: %s (%u)",\r\nstr,\r\nval_to_str_const(codenum, cVALS(hf_field->strings), "Unknown "),\r\ncodenum);\r\n} else {\r\nswitch (hf_field->display) {\r\ncase BASE_DEC:\r\nproto_tree_add_uint_format(tree, hf_index, tvb, start_offset, 1, codenum,\r\n"%s: %u",\r\nstr,\r\ncodenum);\r\nbreak;\r\ncase BASE_HEX:\r\nproto_tree_add_uint_format(tree, hf_index, tvb, start_offset, 1, codenum,\r\n"%s: 0x%x",\r\nstr,\r\ncodenum);\r\nbreak;\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nbreak;\r\n}\r\n}\r\n} else if ((hf_field->type == FT_INT32) && (descriptor == H264_SE_V)) {\r\nif (hf_field->strings) {\r\nproto_tree_add_int_format(tree, hf_index, tvb, start_offset, 1, codenum,\r\n"%s: %s (%d)",\r\nstr,\r\nval_to_str_const(codenum, cVALS(hf_field->strings), "Unknown "),\r\nse_value);\r\n} else {\r\nswitch (hf_field->display) {\r\ncase BASE_DEC:\r\nproto_tree_add_int_format(tree, hf_index, tvb, start_offset, 1, codenum,\r\n"%s: %d",\r\nstr,\r\nse_value);\r\nbreak;\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nbreak;\r\n}\r\n}\r\n*start_bit_offset = bit_offset;\r\nreturn se_value;\r\n} else {\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\n}\r\n}\r\n*start_bit_offset = bit_offset;\r\nreturn codenum;\r\n}\r\nstatic gboolean\r\nmore_rbsp_data(proto_tree *tree _U_, tvbuff_t *tvb, packet_info *pinfo _U_, gint bit_offset)\r\n{\r\nint offset;\r\nint remaining_length;\r\nint last_one_bit;\r\nguint8 b = 0;\r\noffset = bit_offset>>3;\r\nremaining_length = tvb_reported_length_remaining(tvb, offset);\r\nif (remaining_length>2) {\r\nreturn TRUE;\r\n}\r\nlast_one_bit = (tvb_reported_length(tvb) << 3);\r\nfor (b = 0; !b; ) {\r\nlast_one_bit--;\r\nb = tvb_get_bits8(tvb, last_one_bit, 1);\r\n}\r\nif (last_one_bit == bit_offset) {\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\ndissect_h264_rbsp_trailing_bits(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint bit_offset)\r\n{\r\ngint remaining_bits=0;\r\nproto_tree_add_bits_item(tree, hf_h264_rbsp_stop_bit, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nif ((bit_offset&0x7) != 0) {\r\nremaining_bits = 8 - (bit_offset&0x7);\r\nproto_tree_add_bits_item(tree, hf_h264_rbsp_trailing_bits, tvb, bit_offset, remaining_bits, ENC_BIG_ENDIAN);\r\n}\r\nreturn bit_offset+remaining_bits;\r\n}\r\nstatic int\r\ndissect_h264_slice_header(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint bit_offset)\r\n{\r\ndissect_h264_exp_golomb_code(tree, hf_h264_first_mb_in_slice, tvb, &bit_offset, H264_UE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_slice_type, tvb, &bit_offset, H264_UE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_pic_parameter_set_id, tvb, &bit_offset, H264_UE_V);\r\nreturn bit_offset;\r\n}\r\nstatic int\r\ndissect_h264_hrd_parameters(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint bit_offset)\r\n{\r\nguint8 cpb_cnt_minus1;\r\nint SchedSelIdx;\r\ncpb_cnt_minus1 = dissect_h264_exp_golomb_code(tree, hf_h264_cpb_cnt_minus1, tvb, &bit_offset, H264_UE_V);\r\nproto_tree_add_bits_item(tree, hf_h264_bit_rate_scale, tvb, bit_offset, 4, ENC_BIG_ENDIAN);\r\nbit_offset = bit_offset + 4;\r\nproto_tree_add_bits_item(tree, hf_h264_cpb_size_scale, tvb, bit_offset, 4, ENC_BIG_ENDIAN);\r\nbit_offset = bit_offset + 4;\r\nfor (SchedSelIdx = 0; SchedSelIdx <= cpb_cnt_minus1; SchedSelIdx++) {\r\ndissect_h264_exp_golomb_code(tree, hf_h264_bit_rate_value_minus1, tvb, &bit_offset, H264_UE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_cpb_size_value_minus1, tvb, &bit_offset, H264_UE_V);\r\nproto_tree_add_bits_item(tree, hf_h264_cbr_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\n}\r\nproto_tree_add_bits_item(tree, hf_h264_initial_cpb_removal_delay_length_minus1, tvb, bit_offset, 5, ENC_BIG_ENDIAN);\r\nbit_offset = bit_offset + 5;\r\nproto_tree_add_bits_item(tree, hf_h264_cpb_removal_delay_length_minus1, tvb, bit_offset, 5, ENC_BIG_ENDIAN);\r\nbit_offset = bit_offset + 5;\r\nproto_tree_add_bits_item(tree, hf_h264_dpb_output_delay_length_minus11, tvb, bit_offset, 5, ENC_BIG_ENDIAN);\r\nbit_offset = bit_offset + 5;\r\nproto_tree_add_bits_item(tree, hf_h264_time_offset_length, tvb, bit_offset, 5, ENC_BIG_ENDIAN);\r\nbit_offset = bit_offset + 5;\r\nreturn bit_offset;\r\n}\r\nstatic int\r\ndissect_h264_vui_parameters(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, gint bit_offset)\r\n{\r\nguint8 aspect_ratio_info_present_flag, aspect_ratio_idc, overscan_info_present_flag;\r\nguint8 video_signal_type_present_flag, colour_description_present_flag, chroma_loc_info_present_flag;\r\nguint8 timing_info_present_flag, nal_hrd_parameters_present_flag, vcl_hrd_parameters_present_flag;\r\nguint8 bitstream_restriction_flag;\r\naspect_ratio_info_present_flag = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, hf_h264_aspect_ratio_info_present_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nif (aspect_ratio_info_present_flag) {\r\naspect_ratio_idc = tvb_get_bits8(tvb, bit_offset, 8);\r\nproto_tree_add_bits_item(tree, hf_h264_aspect_ratio_idc, tvb, bit_offset, 8, ENC_BIG_ENDIAN);\r\nbit_offset = bit_offset + 8;\r\nif (aspect_ratio_idc == EXTENDED_SAR) {\r\nproto_tree_add_bits_item(tree, hf_h264_sar_width, tvb, bit_offset, 16, ENC_BIG_ENDIAN);\r\nbit_offset = bit_offset + 16;\r\nproto_tree_add_bits_item(tree, hf_h264_sar_height, tvb, bit_offset, 16, ENC_BIG_ENDIAN);\r\nbit_offset = bit_offset + 16;\r\n}\r\n}\r\noverscan_info_present_flag = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, hf_h264_overscan_info_present_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nif (overscan_info_present_flag) {\r\nproto_tree_add_bits_item(tree, hf_h264_overscan_appropriate_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\n}\r\nvideo_signal_type_present_flag = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, hf_h264_video_signal_type_present_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nif (video_signal_type_present_flag) {\r\nproto_tree_add_bits_item(tree, hf_h264_video_format, tvb, bit_offset, 3, ENC_BIG_ENDIAN);\r\nbit_offset = bit_offset + 3;\r\nproto_tree_add_bits_item(tree, hf_h264_video_full_range_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\ncolour_description_present_flag = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, hf_h264_colour_description_present_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nif (colour_description_present_flag) {\r\nproto_tree_add_bits_item(tree, hf_h264_colour_primaries, tvb, bit_offset, 8, ENC_BIG_ENDIAN);\r\nbit_offset = bit_offset + 8;\r\nproto_tree_add_bits_item(tree, hf_h264_transfer_characteristics, tvb, bit_offset, 8, ENC_BIG_ENDIAN);\r\nbit_offset = bit_offset + 8;\r\nproto_tree_add_bits_item(tree, hf_h264_matrix_coefficients, tvb, bit_offset, 8, ENC_BIG_ENDIAN);\r\nbit_offset = bit_offset + 8;\r\n}\r\n}\r\nchroma_loc_info_present_flag = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, hf_h264_chroma_loc_info_present_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nif (chroma_loc_info_present_flag) {\r\ndissect_h264_exp_golomb_code(tree, hf_h264_chroma_sample_loc_type_top_field, tvb, &bit_offset, H264_UE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_chroma_sample_loc_type_bottom_field, tvb, &bit_offset, H264_UE_V);\r\n}\r\ntiming_info_present_flag = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, hf_h264_timing_info_present_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nif (timing_info_present_flag) {\r\nproto_tree_add_bits_item(tree, hf_h264_num_units_in_tick, tvb, bit_offset, 32, ENC_BIG_ENDIAN);\r\nbit_offset = bit_offset + 32;\r\nproto_tree_add_bits_item(tree, hf_h264_time_scale, tvb, bit_offset, 32, ENC_BIG_ENDIAN);\r\nbit_offset = bit_offset + 32;\r\nproto_tree_add_bits_item(tree, hf_h264_fixed_frame_rate_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\n}\r\nnal_hrd_parameters_present_flag = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, hf_h264_nal_hrd_parameters_present_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nif (nal_hrd_parameters_present_flag) {\r\nbit_offset = dissect_h264_hrd_parameters(tree, tvb, pinfo, bit_offset);\r\n}\r\nvcl_hrd_parameters_present_flag = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, hf_h264_vcl_hrd_parameters_present_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nif (vcl_hrd_parameters_present_flag) {\r\nbit_offset = dissect_h264_hrd_parameters(tree, tvb, pinfo, bit_offset);\r\n}\r\nif (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {\r\nproto_tree_add_bits_item(tree, hf_h264_low_delay_hrd_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\n}\r\nproto_tree_add_bits_item(tree, hf_h264_pic_struct_present_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nbitstream_restriction_flag = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, hf_h264_bitstream_restriction_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nif (bitstream_restriction_flag) {\r\nproto_tree_add_bits_item(tree, hf_h264_motion_vectors_over_pic_boundaries_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\ndissect_h264_exp_golomb_code(tree, hf_h264_max_bytes_per_pic_denom, tvb, &bit_offset, H264_UE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_max_bits_per_mb_denom, tvb, &bit_offset, H264_UE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_log2_max_mv_length_horizontal, tvb, &bit_offset, H264_UE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_log2_max_mv_length_vertical, tvb, &bit_offset, H264_UE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_num_reorder_frames, tvb, &bit_offset, H264_UE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_max_dec_frame_buffering, tvb, &bit_offset, H264_UE_V);\r\n}\r\nreturn bit_offset;\r\n}\r\nvoid\r\ndissect_h264_profile(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_item *item, *level_item;\r\nproto_tree *h264_profile_tree;\r\ngint offset = 0;\r\nguint8 constraint_set3_flag;\r\nguint32 level_idc;\r\nitem = proto_tree_add_item(tree, hf_h264_profile, tvb, offset, -1, ENC_NA);\r\nh264_profile_tree = proto_item_add_subtree(item, ett_h264_profile);\r\nproto_tree_add_item(h264_profile_tree, hf_h264_profile_idc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nconstraint_set3_flag = (tvb_get_guint8(tvb, offset)&0x10)>>4;\r\nproto_tree_add_item(h264_profile_tree, hf_h264_constraint_set0_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h264_profile_tree, hf_h264_constraint_set1_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h264_profile_tree, hf_h264_constraint_set2_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h264_profile_tree, hf_h264_constraint_set3_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h264_profile_tree, hf_h264_constraint_set4_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h264_profile_tree, hf_h264_constraint_set5_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h264_profile_tree, hf_h264_reserved_zero_2bits, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nlevel_idc = tvb_get_guint8(tvb, offset);\r\nlevel_item = proto_tree_add_item(h264_profile_tree, hf_h264_level_idc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif ((level_idc == 11) && (constraint_set3_flag == 1)) {\r\nproto_item_append_text(level_item," [Level 1b (128kb/s)]");\r\n} else {\r\nproto_item_append_text(level_item," [Level %.1f %s]", ((double)level_idc/10), val_to_str_const(level_idc, h264_level_bitrate_values, "Unknown "));\r\n}\r\n}\r\nstatic tvbuff_t *\r\ndissect_h265_unescap_nal_unit(tvbuff_t *tvb, packet_info *pinfo, int offset)\r\n{\r\ntvbuff_t *tvb_rbsp;\r\nint length = tvb_reported_length_remaining(tvb, offset);\r\nint NumBytesInRBSP = 0;\r\nint i;\r\ngchar *buff;\r\nbuff = (gchar *)wmem_alloc(pinfo->pool, length);\r\nfor (i = 0; i < length; i++) {\r\nif ((i + 2 < length) && (tvb_get_ntoh24(tvb, offset) == 0x000003)) {\r\nbuff[NumBytesInRBSP++] = tvb_get_guint8(tvb, offset);\r\nbuff[NumBytesInRBSP++] = tvb_get_guint8(tvb, offset+1);\r\ni += 2;\r\noffset+=3;\r\n} else {\r\nbuff[ NumBytesInRBSP++] = tvb_get_guint8(tvb, offset);\r\noffset++;\r\n}\r\n}\r\ntvb_rbsp = tvb_new_child_real_data(tvb, buff, NumBytesInRBSP, NumBytesInRBSP);\r\nadd_new_data_source(pinfo, tvb_rbsp, "Unescaped RSP Data");\r\nreturn tvb_rbsp;\r\n}\r\nstatic void\r\ndissect_h264_slice_layer_without_partitioning_rbsp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, gint offset)\r\n{\r\ngint bit_offset;\r\nbit_offset = offset <<3;\r\nbit_offset = dissect_h264_slice_header(tree, tvb, pinfo, bit_offset);\r\nproto_tree_add_expert(tree, pinfo, &ei_h264_undecoded, tvb, bit_offset>>3, -1);\r\nreturn;\r\n}\r\nstatic void\r\ndissect_h264_slice_data_partition_a_layer_rbsp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint offset)\r\n{\r\ngint bit_offset;\r\nbit_offset = offset <<3;\r\nbit_offset = dissect_h264_slice_header(tree, tvb, pinfo, bit_offset);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_slice_id, tvb, &bit_offset, H264_UE_V);\r\nproto_tree_add_expert(tree, pinfo, &ei_h264_undecoded, tvb, bit_offset>>3, -1);\r\nreturn;\r\n}\r\nstatic void\r\ndissect_h264_slice_data_partition_b_layer_rbsp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint offset)\r\n{\r\ngint bit_offset;\r\nbit_offset = offset <<3;\r\ndissect_h264_exp_golomb_code(tree, hf_h264_slice_id, tvb, &bit_offset, H264_UE_V);\r\nproto_tree_add_expert(tree, pinfo, &ei_h264_undecoded, tvb, bit_offset>>3, -1);\r\n}\r\nstatic void\r\ndissect_h264_slice_data_partition_c_layer_rbsp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint offset)\r\n{\r\ngint bit_offset;\r\nbit_offset = offset <<3;\r\ndissect_h264_exp_golomb_code(tree, hf_h264_slice_id, tvb, &bit_offset, H264_UE_V);\r\nproto_tree_add_expert(tree, pinfo, &ei_h264_undecoded, tvb, bit_offset>>3, -1);\r\n}\r\nstatic int\r\nh264_user_data_unregistered(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint bit_offset, guint32 payloadSize)\r\n{\r\nguint8 i;\r\nguint8 ld_size;\r\nguint8 p_flag;\r\nguint8 desc =0;\r\nguint8 num_crops;\r\ngint offset = bit_offset >> 3;\r\nproto_item *item;\r\nproto_item *uuid_item;\r\nproto_tree *h264_ms_layer_desc_tree;\r\nproto_tree *h264_ms_crop_data_tree;\r\ne_guid_t guid;\r\nuuid_item = proto_tree_add_item (tree, hf_h264_sei_uuid, tvb, offset, 16, ENC_BIG_ENDIAN);\r\ntvb_get_ntohguid(tvb, offset, &guid);\r\noffset+=16;\r\nif ( memcmp(&guid, &(ms_guids[MS_LAYOUT]), sizeof(e_guid_t)) == 0)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ":MS_Layout");\r\nproto_item_append_text(uuid_item," - Microsoft Stream Layout SEI Message");\r\nfor (i = 0; i < 8 ; i++)\r\n{\r\nitem = proto_tree_add_item (tree, hf_h264_sei_ms_lpb, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text (item, " PRID %2d - %2d", (i+1)*8-1, i*8);\r\noffset++;\r\n}\r\np_flag = tvb_get_guint8 (tvb, offset);\r\nproto_tree_add_item (tree, hf_h264_sei_ms_layout_p, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nif (p_flag == 1)\r\n{\r\nld_size = tvb_get_guint8 (tvb, offset);\r\nproto_tree_add_item (tree, hf_h264_sei_ms_layout_ldsize, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nif (tvb_reported_length_remaining (tvb, offset) != ld_size)\r\n{\r\nitem = proto_tree_add_expert(tree, pinfo, &ei_h264_ms_layout_wrong_length, tvb, offset-1, 1);\r\nproto_item_append_text(item," Size of %d, remaining size %d",\r\nld_size,\r\ntvb_reported_length_remaining (tvb, offset));\r\n}\r\nwhile (tvb_reported_length_remaining (tvb, offset) >= 16)\r\n{\r\nh264_ms_layer_desc_tree = proto_tree_add_subtree_format(tree, tvb, offset, 16, ett_h264_ms_layer_description, NULL, "MS Layer Description #%d", ++desc);\r\nproto_tree_add_item (h264_ms_layer_desc_tree, hf_h264_sei_ms_layer_desc_coded_width, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (h264_ms_layer_desc_tree, hf_h264_sei_ms_layer_desc_coded_height, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (h264_ms_layer_desc_tree, hf_h264_sei_ms_layer_desc_display_width, tvb, offset + 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (h264_ms_layer_desc_tree, hf_h264_sei_ms_layer_desc_display_height, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (h264_ms_layer_desc_tree, hf_h264_sei_ms_layer_desc_bitrate, tvb, offset + 8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (h264_ms_layer_desc_tree, hf_h264_sei_ms_layer_desc_frame_rate, tvb, offset + 12, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (h264_ms_layer_desc_tree, hf_h264_sei_ms_layer_desc_layer_type, tvb, offset + 12, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (h264_ms_layer_desc_tree, hf_h264_sei_ms_layer_desc_prid, tvb, offset + 13, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (h264_ms_layer_desc_tree, hf_h264_sei_ms_layer_desc_cb, tvb, offset + 13, 1, ENC_BIG_ENDIAN);\r\noffset += 16;\r\n}\r\n}\r\n}\r\nelse if ( memcmp(&guid, &(ms_guids[MS_CROPPING]), sizeof(e_guid_t)) == 0)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ":MS_Cropping");\r\nproto_item_append_text(uuid_item," - Microsoft Cropping Info SEI Message");\r\nnum_crops = tvb_get_guint8 (tvb, offset);\r\nproto_tree_add_item (tree, hf_h264_sei_ms_crop_num_data, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item (tree, hf_h264_sei_ms_crop_info_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nwhile (num_crops != 0)\r\n{\r\nh264_ms_crop_data_tree = proto_tree_add_subtree_format(tree, tvb, offset, 9, ett_h264_ms_crop_data, NULL, "Crop Data #%d", ++desc);\r\nproto_tree_add_item (h264_ms_crop_data_tree, hf_h264_sei_ms_crop_confidence_level, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (h264_ms_crop_data_tree, hf_h264_sei_ms_crop_frame_left_offset, tvb, offset+1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (h264_ms_crop_data_tree, hf_h264_sei_ms_crop_frame_right_offset, tvb, offset+3, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (h264_ms_crop_data_tree, hf_h264_sei_ms_crop_frame_top_offset, tvb, offset+5, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (h264_ms_crop_data_tree, hf_h264_sei_ms_crop_frame_bottom_offset, tvb, offset+7, 2, ENC_BIG_ENDIAN);\r\nnum_crops--;\r\noffset += 9;\r\n}\r\n}\r\nelse if ( memcmp(&guid, &(ms_guids[MS_BITSTREAM]), sizeof(e_guid_t)) == 0)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ":MS_Bitstream");\r\nproto_item_append_text(uuid_item," - Microsoft Bitstream Info SEI Message");\r\nproto_tree_add_item (tree, hf_h264_sei_ms_bitstream_ref_frame_cnt, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item (tree, hf_h264_sei_ms_bitstream_num_nalus, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(tree, hf_h264_sei_iso_sec_info, tvb, offset, 16, ENC_NA);\r\nif (payloadSize > 16)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_h264_undecoded, tvb, offset, payloadSize-16);\r\noffset+=(payloadSize-16);\r\n}\r\n}\r\nreturn offset << 3;\r\n}\r\nstatic int\r\nh264_sei_payload(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint bit_offset, guint32 payloadType, guint32 payloadSize)\r\n{\r\nif (payloadType == 0) {\r\nbit_offset = bit_offset +(payloadSize<<3);\r\n#if 0\r\n} else if (payloadType == 1) {\r\n} else if (payloadType == 2) {\r\n} else if (payloadType == 3) {\r\n} else if (payloadType == 4) {\r\n#endif\r\n} else if (payloadType == 5) {\r\nbit_offset = h264_user_data_unregistered( tree, tvb, pinfo, bit_offset, payloadSize);\r\n} else if (payloadType == 6) {\r\nbit_offset = bit_offset +(payloadSize<<3);\r\n} else if (payloadType == 7) {\r\nbit_offset = bit_offset +(payloadSize<<3);\r\n}\r\n#if 0\r\nelse if (payloadType == 8)\r\nspare_pic( payloadSize ) 5\r\nelse if (payloadType == 9)\r\nscene_info( payloadSize ) 5\r\nelse if (payloadType == 10)\r\nsub_seq_info( payloadSize ) 5\r\nelse if (payloadType == 11)\r\nsub_seq_layer_characteristics( payloadSize ) 5\r\nelse if (payloadType == 12)\r\nsub_seq_characteristics( payloadSize ) 5\r\nelse if (payloadType == 13)\r\nfull_frame_freeze( payloadSize ) 5\r\nelse if (payloadType == 14)\r\nfull_frame_freeze_release( payloadSize ) 5\r\nelse if (payloadType == 15)\r\nfull_frame_snapshot( payloadSize ) 5\r\nelse if (payloadType == 16)\r\nprogressive_refinement_segment_start( payloadSize ) 5\r\nelse if (payloadType == 17)\r\nprogressive_refinement_segment_end( payloadSize ) 5\r\nelse if (payloadType == 18)\r\nmotion_constrained_slice_group_set( payloadSize ) 5\r\nelse if (payloadType == 19)\r\nfilm_grain_characteristics( payloadSize ) 5\r\nelse if (payloadType == 20)\r\ndeblocking_filter_display_preference( payloadSize ) 5\r\nelse if (payloadType == 21)\r\nstereo_video_info( payloadSize ) 5\r\nelse\r\nreserved_sei_message( payloadSize ) 5\r\nreturn bit_offset;\r\n#endif\r\nif (!h264_byte_aligned(bit_offset)) {\r\nbit_offset++;\r\nwhile (!h264_byte_aligned(bit_offset)) {\r\nbit_offset++;\r\n}\r\n}\r\nreturn bit_offset;\r\n}\r\nstatic gint\r\ndissect_h264_sei_message(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, gint bit_offset)\r\n{\r\nguint32 payloadType = 0, payloadSize;\r\ngint start_bit_offset, length;\r\nstart_bit_offset = bit_offset;\r\nwhile (tvb_get_bits8(tvb, bit_offset, 8) == 0xFF) {\r\npayloadType += 255;\r\nbit_offset+=8;\r\n}\r\npayloadType += tvb_get_bits8(tvb, bit_offset, 8);\r\nbit_offset+=8;\r\nlength = (bit_offset - start_bit_offset)>>3;\r\nproto_tree_add_uint(tree, hf_h264_payloadtype, tvb, start_bit_offset>>3, length, payloadType);\r\npayloadSize = 0;\r\nstart_bit_offset = bit_offset;\r\nwhile (tvb_get_bits8(tvb, bit_offset, 8) == 0xFF) {\r\npayloadSize += 255;\r\nbit_offset+=8;\r\n}\r\npayloadSize += tvb_get_bits8(tvb, bit_offset, 8);\r\nbit_offset+=8;\r\nlength = (bit_offset - start_bit_offset)>>3;\r\nproto_tree_add_uint(tree, hf_h264_payloadsize, tvb, start_bit_offset>>3, length, payloadSize);\r\nbit_offset = h264_sei_payload( tree, tvb, pinfo, bit_offset, payloadType, payloadSize);\r\nreturn bit_offset;\r\n}\r\nstatic int\r\ndissect_h264_sei_rbsp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint offset)\r\n{\r\ngint bit_offset;\r\nbit_offset = offset <<3;\r\nbit_offset = dissect_h264_sei_message( tree, tvb, pinfo, bit_offset);\r\nif (tvb_reported_length_remaining (tvb, bit_offset >> 3) != 0 || (bit_offset & 0x7) != 0)\r\n{\r\nbit_offset = dissect_h264_rbsp_trailing_bits(tree, tvb, pinfo, bit_offset);\r\n}\r\nreturn bit_offset;\r\n}\r\nstatic int\r\ndissect_h264_seq_parameter_set_rbsp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, gint offset)\r\n{\r\nproto_item *level_item;\r\ngint bit_offset;\r\nguint8 constraint_set3_flag;\r\nguint32 level_idc;\r\ngint i;\r\nguint8 profile_idc, chroma_format_idc, frame_mbs_only_flag, frame_cropping_flag;\r\nguint8 pic_order_cnt_type, vui_parameters_present_flag, num_ref_frames_in_pic_order_cnt_cycle;\r\nguint8 seq_scaling_matrix_present_flag;\r\nprofile_idc = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_h264_profile_idc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nconstraint_set3_flag = (tvb_get_guint8(tvb, offset)&0x10)>>4;\r\nproto_tree_add_item(tree, hf_h264_constraint_set0_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_constraint_set1_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_constraint_set2_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_constraint_set3_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_constraint_set4_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_constraint_set5_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_reserved_zero_2bits, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nlevel_idc = tvb_get_guint8(tvb, offset);\r\nlevel_item = proto_tree_add_item(tree, hf_h264_level_idc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif ((level_idc == 11) && (constraint_set3_flag == 1)) {\r\nproto_item_append_text(level_item,"[Level 1b]");\r\n} else {\r\nproto_item_append_text(level_item," [Level %.1f %s]", ((double)level_idc/10), val_to_str_const(level_idc, h264_level_bitrate_values, "Unknown "));\r\n}\r\noffset++;\r\nbit_offset = offset<<3;\r\ndissect_h264_exp_golomb_code(tree, hf_h264_seq_parameter_set_id, tvb, &bit_offset, H264_UE_V);\r\nif ((profile_idc == 100) || (profile_idc == 110) ||\r\n(profile_idc == 122) || (profile_idc == 144) ||\r\n(profile_idc == 44) || (profile_idc == 83) ||\r\n(profile_idc == 86) || (profile_idc == 118) ||\r\n(profile_idc == 128) || (profile_idc == 138))\r\n{\r\nchroma_format_idc = dissect_h264_exp_golomb_code(tree, hf_h264_chroma_format_idc, tvb, &bit_offset, H264_UE_V);\r\nif (chroma_format_idc == 3) {\r\nproto_tree_add_bits_item(tree, hf_h264_residual_colour_transform_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\n}\r\ndissect_h264_exp_golomb_code(tree, hf_h264_bit_depth_luma_minus8, tvb, &bit_offset, H264_UE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_bit_depth_chroma_minus8, tvb, &bit_offset, H264_UE_V);\r\nproto_tree_add_bits_item(tree, hf_h264_qpprime_y_zero_transform_bypass_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nseq_scaling_matrix_present_flag = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, hf_h264_seq_scaling_matrix_present_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nif (seq_scaling_matrix_present_flag) {\r\nproto_tree_add_expert(tree, pinfo, &ei_h264_undecoded, tvb, bit_offset>>3, -1);\r\nreturn -1;\r\n}\r\n}\r\ndissect_h264_exp_golomb_code(tree, hf_h264_log2_max_frame_num_minus4, tvb, &bit_offset, H264_UE_V);\r\npic_order_cnt_type = dissect_h264_exp_golomb_code(tree, hf_h264_pic_order_cnt_type, tvb, &bit_offset, H264_UE_V);\r\nif (pic_order_cnt_type == 0) {\r\ndissect_h264_exp_golomb_code(tree, hf_h264_log2_max_pic_order_cnt_lsb_minus4, tvb, &bit_offset, H264_UE_V);\r\n} else if (pic_order_cnt_type == 1) {\r\nproto_tree_add_bits_item(tree, hf_h264_delta_pic_order_always_zero_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\ndissect_h264_exp_golomb_code(tree, hf_h264_offset_for_non_ref_pic, tvb, &bit_offset, H264_SE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_offset_for_top_to_bottom_field, tvb, &bit_offset, H264_SE_V);\r\nnum_ref_frames_in_pic_order_cnt_cycle = dissect_h264_exp_golomb_code(tree, hf_h264_num_ref_frames_in_pic_order_cnt_cycle, tvb, &bit_offset, H264_UE_V);\r\nfor (i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {\r\ndissect_h264_exp_golomb_code(tree, hf_h264_offset_for_ref_frame, tvb, &bit_offset, H264_SE_V);\r\n}\r\n}\r\ndissect_h264_exp_golomb_code(tree, hf_h264_num_ref_frames, tvb, &bit_offset, H264_UE_V);\r\nproto_tree_add_bits_item(tree, hf_h264_gaps_in_frame_num_value_allowed_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\ndissect_h264_exp_golomb_code(tree, hf_h264_pic_width_in_mbs_minus1, tvb, &bit_offset, H264_UE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_pic_height_in_map_units_minus1, tvb, &bit_offset, H264_UE_V);\r\nframe_mbs_only_flag = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, hf_h264_frame_mbs_only_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nif (!frame_mbs_only_flag) {\r\nproto_tree_add_bits_item(tree, hf_h264_mb_adaptive_frame_field_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\n}\r\nproto_tree_add_bits_item(tree, hf_h264_direct_8x8_inference_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nframe_cropping_flag = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, hf_h264_frame_cropping_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nif (frame_cropping_flag) {\r\ndissect_h264_exp_golomb_code(tree, hf_h264_frame_crop_left_offset, tvb, &bit_offset, H264_UE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_frame_crop_right_offset, tvb, &bit_offset, H264_UE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_frame_crop_top_offset, tvb, &bit_offset, H264_UE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_frame_crop_bottom_offset, tvb, &bit_offset, H264_UE_V);\r\n}\r\nvui_parameters_present_flag = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, hf_h264_vui_parameters_present_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nif (vui_parameters_present_flag) {\r\nbit_offset = dissect_h264_vui_parameters(tree, tvb, pinfo, bit_offset);\r\n}\r\nbit_offset = dissect_h264_rbsp_trailing_bits(tree, tvb, pinfo, bit_offset);\r\noffset = bit_offset>>3;\r\nreturn offset;\r\n}\r\nstatic void\r\ndissect_h264_pic_parameter_set_rbsp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, gint offset)\r\n{\r\ngint bit_offset;\r\nguint32 num_slice_groups_minus1, pic_scaling_matrix_present_flag;\r\nbit_offset = offset<<3;\r\ndissect_h264_exp_golomb_code(tree, hf_h264_pic_parameter_set_id, tvb, &bit_offset, H264_UE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_seq_parameter_set_id, tvb, &bit_offset, H264_UE_V);\r\nproto_tree_add_bits_item(tree, hf_h264_entropy_coding_mode_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nproto_tree_add_bits_item(tree, hf_h264_pic_order_present_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nnum_slice_groups_minus1 = dissect_h264_exp_golomb_code(tree, hf_h264_num_slice_groups_minus1, tvb, &bit_offset, H264_UE_V);\r\nif (num_slice_groups_minus1 > 0) {\r\ndissect_h264_exp_golomb_code(tree, hf_h264_slice_group_map_type, tvb, &bit_offset, H264_UE_V);\r\nproto_tree_add_expert(tree, pinfo, &ei_h264_undecoded, tvb, bit_offset>>3, -1);\r\nreturn;\r\n}\r\ndissect_h264_exp_golomb_code(tree, hf_h264_num_ref_idx_l0_active_minus1, tvb, &bit_offset, H264_UE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_num_ref_idx_l1_active_minus1, tvb, &bit_offset, H264_UE_V);\r\nproto_tree_add_bits_item(tree, hf_h264_weighted_pred_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nproto_tree_add_bits_item(tree, hf_h264_weighted_bipred_idc, tvb, bit_offset, 2, ENC_BIG_ENDIAN);\r\nbit_offset= bit_offset+2;\r\ndissect_h264_exp_golomb_code(tree, hf_h264_pic_init_qp_minus26, tvb, &bit_offset, H264_SE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_pic_init_qs_minus26, tvb, &bit_offset, H264_SE_V);\r\ndissect_h264_exp_golomb_code(tree, hf_h264_chroma_qp_index_offset, tvb, &bit_offset, H264_SE_V);\r\nproto_tree_add_bits_item(tree, hf_h264_deblocking_filter_control_present_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nproto_tree_add_bits_item(tree, hf_h264_constrained_intra_pred_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nproto_tree_add_bits_item(tree, hf_h264_redundant_pic_cnt_present_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nif (more_rbsp_data(tree, tvb, pinfo, bit_offset)) {\r\nproto_tree_add_bits_item(tree, hf_h264_transform_8x8_mode_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\npic_scaling_matrix_present_flag = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, hf_h264_pic_scaling_matrix_present_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nif (pic_scaling_matrix_present_flag) {\r\nproto_tree_add_expert(tree, pinfo, &ei_h264_undecoded, tvb, bit_offset>>3, -1);\r\nreturn;\r\n}\r\ndissect_h264_exp_golomb_code(tree, hf_h264_second_chroma_qp_index_offset, tvb, &bit_offset, H264_SE_V);\r\n}\r\nbit_offset = dissect_h264_rbsp_trailing_bits(tree, tvb, pinfo, bit_offset);\r\n}\r\nstatic void\r\ndissect_h264_access_unit_delimiter_rbsp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint offset)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_h264_undecoded, tvb, offset, -1);\r\n}\r\nstatic void\r\ndissect_h264_end_of_seq_rbsp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint offset)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_h264_undecoded, tvb, offset, -1);\r\n}\r\nstatic void\r\ndissect_h264_end_of_stream_rbsp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint offset)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_h264_undecoded, tvb, offset, -1);\r\n}\r\nstatic void\r\ndissect_h264_filler_data_rbsp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint offset)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_h264_undecoded, tvb, offset, -1);\r\n}\r\nstatic void\r\ndissect_h264_seq_parameter_set_extension_rbsp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint offset)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_h264_undecoded, tvb, offset, -1);\r\n}\r\nstatic gint\r\ndissect_h264_svc_nal_header_extension(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint offset)\r\n{\r\nproto_tree_add_item(tree, hf_h264_nal_hdr_ext_svc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_nal_hdr_ext_i, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_nal_hdr_ext_prid, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_nal_hdr_ext_n, tvb, offset + 1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_nal_hdr_ext_did, tvb, offset + 1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_nal_hdr_ext_qid, tvb, offset + 1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_nal_hdr_ext_tid, tvb, offset + 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_nal_hdr_ext_u, tvb, offset + 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_nal_hdr_ext_d, tvb, offset + 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_nal_hdr_ext_o, tvb, offset + 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_nal_hdr_ext_rr, tvb, offset + 2, 1, ENC_BIG_ENDIAN);\r\nreturn offset + 3;\r\n}\r\nstatic int dissect_h264_prefix(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, gint offset)\r\n{\r\nguint8 svc_extension_flag;\r\nsvc_extension_flag = tvb_get_bits8(tvb, offset << 3, 1);\r\nif (svc_extension_flag)\r\n{\r\ndissect_h264_svc_nal_header_extension (tree, tvb, pinfo, offset);\r\n}\r\nelse\r\n{\r\noffset +=3;\r\n}\r\nreturn offset;\r\n}\r\nstatic void\r\ndissect_h264_pacsi(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, gint offset)\r\n{\r\ngint8 pacsi_flags;\r\nguint16 nal_unit_size;\r\ntvbuff_t *nalu_tvb;\r\ngboolean error = FALSE;\r\ngboolean contains_sei = FALSE;\r\noffset = dissect_h264_svc_nal_header_extension(tree, tvb, pinfo, offset);\r\npacsi_flags = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_h264_pacsi_x, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_pacsi_y, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_pacsi_t, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_pacsi_a, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_pacsi_p, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_pacsi_c, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_pacsi_s, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_pacsi_e, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nif (pacsi_flags & 0x40)\r\n{\r\nproto_tree_add_item(tree, hf_h264_pacsi_tl0picidx, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(tree, hf_h264_pacsi_idrpicid, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n}\r\nif (pacsi_flags & 0x20)\r\n{\r\nproto_tree_add_item(tree, hf_h264_pacsi_donc, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) > 0)\r\n{\r\ncontains_sei = TRUE;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "(");\r\n}\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0 && !error)\r\n{\r\nnal_unit_size = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(tree, hf_h264_nalu_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif (nal_unit_size == 0 || nal_unit_size > tvb_reported_length_remaining(tvb, offset))\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_h264_bad_nal_length, tvb, offset-2, 2);\r\nerror = TRUE;\r\n}\r\nelse\r\n{\r\nnalu_tvb = tvb_new_subset(tvb, offset, tvb_captured_length_remaining(tvb,offset), nal_unit_size);\r\ndissect_h264(nalu_tvb, pinfo, tree, NULL);\r\noffset += nal_unit_size;\r\n}\r\n}\r\nif (contains_sei == TRUE)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ")");\r\n}\r\n}\r\nstatic void\r\ndissect_h264_stap(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint offset, gint8 nal_type)\r\n{\r\nguint16 nal_unit_size;\r\ntvbuff_t *nalu_tvb;\r\nproto_item *item;\r\nif (nal_type == H264_STAP_B)\r\n{\r\nproto_tree_add_item(tree, hf_h264_don, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n}\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0)\r\n{\r\nproto_tree_add_item(tree, hf_h264_nalu_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nnal_unit_size = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\nif (nal_unit_size == 0 || tvb_reported_length_remaining(tvb, offset) < nal_unit_size)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " [Bad NAL Length]");\r\nitem = proto_tree_add_expert (tree, pinfo, &ei_h264_bad_nal_length, tvb, offset-2, 2);\r\nproto_item_append_text(item, " Size of %d, Remaining %d",\r\nnal_unit_size, tvb_reported_length_remaining(tvb, offset));\r\noffset += tvb_reported_length_remaining(tvb, offset);\r\n}\r\nelse\r\n{\r\nnalu_tvb = tvb_new_subset(tvb, offset, tvb_captured_length_remaining(tvb, offset), nal_unit_size);\r\ndissect_h264(nalu_tvb, pinfo, tree, NULL);\r\noffset += nal_unit_size;\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_h264_mtap(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint offset, gint8 nal_type)\r\n{\r\ngint size_offset;\r\nguint16 nal_unit_size;\r\ntvbuff_t *nalu_tvb;\r\nproto_item *item;\r\nproto_tree_add_item(tree, hf_h264_don, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0)\r\n{\r\nproto_tree_add_item(tree, hf_h264_nalu_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nnal_unit_size = tvb_get_ntohs(tvb, offset);\r\nsize_offset = offset;\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_h264_dond, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif (nal_type == H264_MTAP16)\r\n{\r\nproto_tree_add_item(tree, hf_h264_ts_offset16, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(tree, hf_h264_ts_offset24, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 3;\r\n}\r\nif (nal_unit_size == 0 || tvb_reported_length_remaining(tvb, offset) < nal_unit_size)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " [Bad NAL Length]");\r\nitem = proto_tree_add_expert (tree, pinfo, &ei_h264_bad_nal_length, tvb, size_offset, 2);\r\nproto_item_append_text(item, " Size of %d, Remaining %d",\r\nnal_unit_size, tvb_reported_length_remaining(tvb, offset));\r\noffset += tvb_reported_length_remaining(tvb, offset);\r\n}\r\nelse\r\n{\r\nnalu_tvb = tvb_new_subset(tvb, offset, tvb_captured_length_remaining(tvb, offset), nal_unit_size);\r\ndissect_h264(nalu_tvb, pinfo, tree, NULL);\r\noffset += nal_unit_size;\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_h264_nalu_extension (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint offset)\r\n{\r\ngint size_offset;\r\nguint16 nal_unit_size;\r\ntvbuff_t *nalu_tvb;\r\nguint8 subtype;\r\nguint8 j_flag;\r\nguint8 bit_offset = offset << 3;\r\nguint8 unit = 1;\r\nproto_item *item;\r\nproto_tree *nimtap_tree;\r\nsubtype = tvb_get_bits8(tvb, bit_offset, 5);\r\nj_flag = tvb_get_bits8(tvb, bit_offset+5, 1);\r\nproto_tree_add_item(tree, hf_h264_nal_extension_subtype, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_h264_nal_extension_j, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_h264_nal_extension_k, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_h264_nal_extension_l, tvb, offset, 1, ENC_NA);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " %s",\r\nval_to_str(subtype, h264_subtype_summary_values, "Unknown Subtype (%u)"));\r\noffset++;\r\nif (subtype == 2)\r\n{\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0)\r\n{\r\nnimtap_tree = proto_tree_add_subtree_format(tree, tvb, offset, 1, ett_h264_ni_mtap, NULL, "NI-MTAP Unit %d", unit++);\r\nproto_tree_add_item(nimtap_tree, hf_h264_nalu_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nnal_unit_size = tvb_get_ntohs(tvb, offset);\r\nsize_offset = offset;\r\noffset += 2;\r\nproto_tree_add_item(nimtap_tree, hf_h264_ts_offset16, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif (j_flag)\r\n{\r\nproto_tree_add_item(nimtap_tree, hf_h264_don, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n}\r\nif (nal_unit_size == 0 || tvb_reported_length_remaining(tvb, offset) < nal_unit_size)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " [Bad NAL Length]");\r\nitem = proto_tree_add_expert (nimtap_tree, pinfo, &ei_h264_bad_nal_length, tvb, size_offset, 2);\r\nproto_item_append_text(item, " Size of %d, Remaining %d",\r\nnal_unit_size, tvb_reported_length_remaining(tvb, offset));\r\noffset += tvb_reported_length_remaining(tvb, offset);\r\n}\r\nelse\r\n{\r\nnalu_tvb = tvb_new_subset(tvb, offset, tvb_captured_length_remaining(tvb, offset), nal_unit_size);\r\ndissect_h264(nalu_tvb, pinfo, nimtap_tree, NULL);\r\noffset += nal_unit_size;\r\n}\r\n}\r\n}\r\n}\r\nvoid\r\ndissect_h264_nal_unit(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_item *item, *nal_item;\r\nproto_tree *h264_nal_tree;\r\ngint offset = 0;\r\nguint8 nal_unit_type;\r\nguint32 dword;\r\nitem = proto_tree_add_item(tree, hf_h264_nal_unit, tvb, offset, -1, ENC_NA);\r\nh264_nal_tree = proto_item_add_subtree(item, ett_h264_nal_unit);\r\nstartover:\r\ndword = tvb_get_bits32(tvb, offset<<3, 32, ENC_BIG_ENDIAN);\r\nif (dword == 1) {\r\noffset+=4;\r\n} else if ((dword >> 8) == 1) {\r\noffset+= 3;\r\n}\r\nnal_unit_type = tvb_get_guint8(tvb, offset) & 0x1f;\r\nproto_tree_add_item(h264_nal_tree, hf_h264_forbidden_zero_bit, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h264_nal_tree, hf_h264_nal_ref_idc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nnal_item = proto_tree_add_item(h264_nal_tree, hf_h264_nal_unit_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nswitch (nal_unit_type) {\r\ncase 1:\r\ndissect_h264_slice_layer_without_partitioning_rbsp(h264_nal_tree, tvb, pinfo, offset);\r\nbreak;\r\ncase 2:\r\ndissect_h264_slice_data_partition_a_layer_rbsp(h264_nal_tree, tvb, pinfo, offset);\r\nbreak;\r\ncase 3:\r\ndissect_h264_slice_data_partition_b_layer_rbsp(h264_nal_tree, tvb, pinfo, offset);\r\nbreak;\r\ncase 4:\r\ndissect_h264_slice_data_partition_c_layer_rbsp(h264_nal_tree, tvb, pinfo, offset);\r\nbreak;\r\ncase 5:\r\ndissect_h264_slice_layer_without_partitioning_rbsp(h264_nal_tree, tvb, pinfo, offset);\r\nbreak;\r\ncase 6:\r\ndissect_h264_sei_rbsp(h264_nal_tree, tvb, pinfo, offset);\r\nbreak;\r\ncase H264_SEQ_PAR_SET:\r\noffset = dissect_h264_seq_parameter_set_rbsp(h264_nal_tree, tvb, pinfo, offset);\r\nif ((offset != -1) && (tvb_reported_length_remaining(tvb, offset) > 0)) {\r\nproto_item_set_len(item, offset);\r\nitem = proto_tree_add_item(tree, hf_h264_nal_unit, tvb, offset, -1, ENC_NA);\r\nh264_nal_tree = proto_item_add_subtree(item, ett_h264_nal_unit);\r\ngoto startover;\r\n}\r\nbreak;\r\ncase H264_PIC_PAR_SET:\r\ndissect_h264_pic_parameter_set_rbsp(h264_nal_tree, tvb, pinfo, offset);\r\nbreak;\r\ncase 9:\r\ndissect_h264_access_unit_delimiter_rbsp(h264_nal_tree, tvb, pinfo, offset);\r\nbreak;\r\ncase 10:\r\ndissect_h264_end_of_seq_rbsp(h264_nal_tree, tvb, pinfo, offset);\r\nbreak;\r\ncase 11:\r\ndissect_h264_end_of_stream_rbsp(h264_nal_tree, tvb, pinfo, offset);\r\nbreak;\r\ncase 12:\r\ndissect_h264_filler_data_rbsp(h264_nal_tree, tvb, pinfo, offset);\r\nbreak;\r\ncase 13:\r\ndissect_h264_seq_parameter_set_extension_rbsp(h264_nal_tree, tvb, pinfo, offset);\r\nbreak;\r\ncase 14:\r\ncase 15:\r\ncase 16:\r\ncase 17:\r\ncase 18:\r\nexpert_add_info(pinfo, nal_item, &ei_h264_nal_unit_type_reserved);\r\nbreak;\r\ncase 19:\r\ndissect_h264_slice_layer_without_partitioning_rbsp(tree, tvb, pinfo, offset);\r\nbreak;\r\ncase 28:\r\ndissect_h264_slice_layer_without_partitioning_rbsp(tree, tvb, pinfo, offset);\r\nbreak;\r\ncase 0:\r\ndefault:\r\nexpert_add_info(pinfo, nal_item, &ei_h264_nal_unit_type_unspecified);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\ndissect_h264(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\nproto_item *item;\r\nproto_tree *h264_tree, *h264_nal_tree, *stream_tree, *fua_tree;\r\nguint8 type;\r\ntvbuff_t *rbsp_tvb;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "H264");\r\ntype = tvb_get_guint8(tvb, offset)&0x1f;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " %s",\r\nval_to_str(type, h264_type_summary_values, "Unknown Type (%u)"));\r\n{\r\nitem = proto_tree_add_item(tree, proto_h264, tvb, 0, -1, ENC_NA);\r\nh264_tree = proto_item_add_subtree(item, ett_h264);\r\nif (type == 28)\r\nh264_nal_tree = proto_tree_add_subtree(h264_tree, tvb, offset, 1, ett_h264_nal, NULL, "FU identifier");\r\nelse\r\nh264_nal_tree = proto_tree_add_subtree(h264_tree, tvb, offset, 1, ett_h264_nal, NULL, "NAL unit header or first byte of the payload");\r\nproto_tree_add_item(h264_nal_tree, hf_h264_nal_f_bit, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h264_nal_tree, hf_h264_nal_nri, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(h264_nal_tree, hf_h264_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nif (type == 28) {\r\nfua_tree = proto_tree_add_subtree(h264_tree, tvb, offset, 1, ett_h264_fua, NULL, "FU Header");\r\nproto_tree_add_item(fua_tree, hf_h264_start_bit, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fua_tree, hf_h264_end_bit, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fua_tree, hf_h264_forbidden_bit, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fua_tree, hf_h264_nal_unit_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif ((tvb_get_guint8(tvb, offset)&0x80) == 0x80) {\r\ntype = tvb_get_guint8(tvb, offset)&0x1f;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " Start:%s",\r\nval_to_str(type, h264_type_summary_values, "Unknown Type (%u)"));\r\noffset++;\r\n}\r\nelse\r\n{\r\nif ((tvb_get_guint8(tvb, offset)&0x40) == 0x40) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " End");\r\n}\r\nreturn offset;\r\n}\r\n}\r\nrbsp_tvb = dissect_h265_unescap_nal_unit(tvb, pinfo, offset);\r\nstream_tree = proto_tree_add_subtree(h264_tree, tvb, offset, -1, ett_h264_stream, NULL, "H264 NAL Unit Payload");\r\nswitch (type) {\r\ncase 1:\r\ndissect_h264_slice_layer_without_partitioning_rbsp(stream_tree, rbsp_tvb, pinfo, 0);\r\nbreak;\r\ncase 3:\r\ndissect_h264_slice_data_partition_b_layer_rbsp(h264_nal_tree, rbsp_tvb, pinfo, 0);\r\nbreak;\r\ncase 4:\r\ndissect_h264_slice_data_partition_c_layer_rbsp(h264_nal_tree, rbsp_tvb, pinfo, 0);\r\nbreak;\r\ncase 5:\r\ndissect_h264_slice_layer_without_partitioning_rbsp(stream_tree, rbsp_tvb, pinfo, 0);\r\nbreak;\r\ncase 6:\r\ndissect_h264_sei_rbsp(stream_tree, tvb, pinfo, offset);\r\nbreak;\r\ncase H264_SEQ_PAR_SET:\r\ndissect_h264_seq_parameter_set_rbsp(stream_tree, rbsp_tvb, pinfo, 0);\r\nbreak;\r\ncase H264_PIC_PAR_SET:\r\ndissect_h264_pic_parameter_set_rbsp(stream_tree, rbsp_tvb, pinfo, 0);\r\nbreak;\r\ncase H264_PREFIX:\r\ndissect_h264_prefix(stream_tree, rbsp_tvb, pinfo, 0);\r\nbreak;\r\ncase 19:\r\ndissect_h264_slice_layer_without_partitioning_rbsp(stream_tree, rbsp_tvb, pinfo, 0);\r\nbreak;\r\ncase H264_STAP_A:\r\ncase H264_STAP_B:\r\ndissect_h264_stap(stream_tree, tvb, pinfo, offset, type);\r\nbreak;\r\ncase H264_MTAP16:\r\ncase H264_MTAP24:\r\ndissect_h264_mtap(stream_tree, tvb, pinfo, offset, type);\r\nbreak;\r\ncase H264_PACSI:\r\ndissect_h264_pacsi(stream_tree, tvb, pinfo, offset);\r\nbreak;\r\ncase H264_EXTENSION:\r\ndissect_h264_nalu_extension(stream_tree, rbsp_tvb, pinfo, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_h264_par_profile(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data _U_)\r\n{\r\nint offset = 0;\r\nproto_tree_add_bitmask(tree, tvb, offset,\r\nhf_h264_par_profile, ett_h264_par_profile,\r\nprofile_fields, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_h264_par_AdditionalModesSupported(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data _U_)\r\n{\r\nint offset = 0;\r\nproto_tree_add_bitmask(tree, tvb, offset,\r\nhf_h264_par_AdditionalModesSupported, ett_h264_par_AdditionalModesSupported,\r\nAdditionalModesSupported_fields, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_h264_ProfileIOP(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data _U_)\r\n{\r\nint offset = 0;\r\nproto_tree_add_bitmask(tree, tvb, offset,\r\nhf_h264_par_ProfileIOP, ett_h264_par_ProfileIOP,\r\nProfileIOP_fields, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_h264_par_level(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree _U_, void *data)\r\n{\r\nint offset = 0;\r\nguint16 lvl;\r\nconst gchar *p;\r\nasn1_ctx_t *actx;\r\nif (data == NULL)\r\nreturn 0;\r\nactx = get_asn1_ctx(data);\r\nDISSECTOR_ASSERT(actx);\r\nlvl = tvb_get_ntohs(tvb, offset);\r\np = try_val_to_str(lvl, VALS(h264_par_level_values));\r\nif (p) {\r\nproto_item_append_text(actx->created_item, " - Level %s", p);\r\n}\r\noffset += 2;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_h264_par_DecoderConfigurationInformation(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nasn1_ctx_t *actx;\r\nif (data == NULL)\r\nreturn 0;\r\nactx = get_asn1_ctx(data);\r\nDISSECTOR_ASSERT(actx);\r\ndissect_h264_nal_unit(tvb, pinfo, tree);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic h264_capability_t *find_cap(const gchar *id) {\r\nh264_capability_t *ftr = NULL;\r\nh264_capability_t *f;\r\nfor (f=h264_capability_tab; f->id; f++) {\r\nif (!strcmp(id, f->id)) { ftr = f; break; }\r\n}\r\nreturn ftr;\r\n}\r\nstatic int\r\ndissect_h264_name(tvbuff_t *tvb _U_, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\nasn1_ctx_t *actx;\r\nif (data == NULL)\r\nreturn 0;\r\nactx = get_asn1_ctx(data);\r\nDISSECTOR_ASSERT(actx);\r\nif (tree) {\r\nh264_capability_t *ftr;\r\nftr = find_cap(pinfo->match_string);\r\nif (ftr) {\r\nproto_item_append_text(actx->created_item, " - %s", ftr->name);\r\nproto_item_append_text(proto_item_get_parent(proto_tree_get_parent(tree)), ": %s", ftr->name);\r\n} else {\r\nproto_item_append_text(actx->created_item, " - unknown(%s)", pinfo->match_string);\r\n}\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic void range_delete_h264_rtp_pt_callback(guint32 rtp_pt) {\r\nif (rtp_pt >= 96 && rtp_pt <= 127)\r\ndissector_delete_uint("rtp.pt", rtp_pt, h264_handle);\r\n}\r\nstatic void range_add_h264_rtp_pt_callback(guint32 rtp_pt) {\r\nif (rtp_pt >= 96 && rtp_pt <= 127)\r\ndissector_add_uint("rtp.pt", rtp_pt, h264_handle);\r\n}\r\nvoid\r\nproto_register_h264(void)\r\n{\r\nmodule_t *h264_module;\r\nexpert_module_t* expert_h264;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_h264_nal_f_bit,\r\n{ "F bit", "h264.f",\r\nFT_BOOLEAN, 8, TFS(&h264_f_bit_vals), 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_nri,\r\n{ "Nal_ref_idc (NRI)", "h264.nal_nri",\r\nFT_UINT8, BASE_DEC, NULL, 0x60,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_type,\r\n{ "Type", "h264.nal_unit_hdr",\r\nFT_UINT8, BASE_DEC, VALS(h264_type_values), 0x1f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_start_bit,\r\n{ "Start bit", "h264.start.bit",\r\nFT_BOOLEAN, 8, TFS(&h264_start_bit_vals), 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_end_bit,\r\n{ "End bit", "h264.end.bit",\r\nFT_BOOLEAN, 8, TFS(&h264_end_bit_vals), 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_forbidden_bit,\r\n{ "Forbidden bit", "h264.forbidden.bit",\r\nFT_UINT8, BASE_DEC, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_profile,\r\n{ "Profile", "h264.profile",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_profile_idc,\r\n{ "Profile_idc", "h264.profile_idc",\r\nFT_UINT8, BASE_DEC, VALS(h264_profile_idc_values), 0xff,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_rbsp_stop_bit,\r\n{ "rbsp_stop_bit", "h264.rbsp_stop_bit",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_rbsp_trailing_bits,\r\n{ "rbsp_trailing_bits", "h264.rbsp_trailing_bits",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_constraint_set0_flag,\r\n{ "Constraint_set0_flag", "h264.constraint_set0_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_constraint_set1_flag,\r\n{ "Constraint_set1_flag", "h264.constraint_set1_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_constraint_set2_flag,\r\n{ "Constraint_set2_flag", "h264.constraint_set2_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_constraint_set3_flag,\r\n{ "Constraint_set3_flag", "h264.constraint_set3_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_constraint_set4_flag,\r\n{ "Constraint_set4_flag", "h264.constraint_set4_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_constraint_set5_flag,\r\n{ "Constraint_set5_flag", "h264.constraint_set5_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_reserved_zero_2bits,\r\n{ "Reserved_zero_2bits", "h264.reserved_zero_2bits",\r\nFT_UINT8, BASE_DEC, NULL, 0x03,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_level_idc,\r\n{ "Level_id", "h264.level_id",\r\nFT_UINT8, BASE_DEC, NULL, 0xff,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_unit,\r\n{ "NAL unit", "h264.nal_unit",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_forbidden_zero_bit,\r\n{ "Forbidden_zero_bit", "h264.forbidden_zero_bit",\r\nFT_UINT8, BASE_DEC, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_ref_idc,\r\n{ "Nal_ref_idc", "h264.nal_ref_idc",\r\nFT_UINT8, BASE_DEC, NULL, 0x60,\r\nNULL, HFILL }\r\n},\r\n{&hf_h264_nal_unit_type,\r\n{ "Nal_unit_type", "h264.nal_unit_type",\r\nFT_UINT8, BASE_DEC, VALS(h264_nal_unit_type_vals), 0x1f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_seq_parameter_set_id,\r\n{ "seq_parameter_set_id", "h264.seq_parameter_set_id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_chroma_format_idc,\r\n{ "chroma_format_id", "h264.chroma_format_id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_residual_colour_transform_flag,\r\n{ "residual_colour_transform_flag", "h264.residual_colour_transform_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_bit_depth_luma_minus8,\r\n{ "bit_depth_luma_minus8", "h264.bit_depth_luma_minus8",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_bit_depth_chroma_minus8,\r\n{ "bit_depth_chroma_minus8", "h264.bit_depth_chroma_minus8",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_qpprime_y_zero_transform_bypass_flag,\r\n{ "qpprime_y_zero_transform_bypass_flag", "h264.qpprime_y_zero_transform_bypass_flag",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_seq_scaling_matrix_present_flag,\r\n{ "seq_scaling_matrix_present_flag", "h264.seq_scaling_matrix_present_flag",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_log2_max_frame_num_minus4,\r\n{ "log2_max_frame_num_minus4", "h264.log2_max_frame_num_minus4",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pic_order_cnt_type,\r\n{ "pic_order_cnt_type", "h264.pic_order_cnt_type",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_log2_max_pic_order_cnt_lsb_minus4,\r\n{ "log2_max_pic_order_cnt_lsb_minus4", "h264.log2_max_pic_order_cnt_lsb_minus4",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_delta_pic_order_always_zero_flag,\r\n{ "delta_pic_order_always_zero_flag", "h264.delta_pic_order_always_zero_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_offset_for_non_ref_pic,\r\n{ "offset_for_non_ref_pic", "h264.offset_for_non_ref_pic",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_offset_for_top_to_bottom_field,\r\n{ "offset_for_top_to_bottom_field", "h264.offset_for_top_to_bottom_field",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_num_ref_frames_in_pic_order_cnt_cycle,\r\n{ "num_ref_frames_in_pic_order_cnt_cycle", "h264.num_ref_frames_in_pic_order_cnt_cycle",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_offset_for_ref_frame,\r\n{ "offset_for_ref_frame", "h264.offset_for_ref_frame",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_num_ref_frames,\r\n{ "num_ref_frames", "h264.num_ref_frames",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_gaps_in_frame_num_value_allowed_flag,\r\n{ "gaps_in_frame_num_value_allowed_flag", "h264.gaps_in_frame_num_value_allowed_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pic_width_in_mbs_minus1,\r\n{ "pic_width_in_mbs_minus1", "h264.pic_width_in_mbs_minus1",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pic_height_in_map_units_minus1,\r\n{ "pic_height_in_map_units_minus1", "h264.pic_height_in_map_units_minus1",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_frame_mbs_only_flag,\r\n{ "frame_mbs_only_flag", "h264.frame_mbs_only_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_mb_adaptive_frame_field_flag,\r\n{ "mb_adaptive_frame_field_flag", "h264.mb_adaptive_frame_field_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_direct_8x8_inference_flag,\r\n{ "direct_8x8_inference_flag", "h264.direct_8x8_inference_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_frame_cropping_flag,\r\n{ "frame_cropping_flag", "h264.frame_cropping_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_frame_crop_left_offset,\r\n{ "frame_crop_left_offset", "h264.frame_crop_left_offset",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_frame_crop_right_offset,\r\n{ "frame_crop_left_offset", "h264.frame_crop_right_offset",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_frame_crop_top_offset,\r\n{ "frame_crop_top_offset", "h264.frame_crop_top_offset",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_frame_crop_bottom_offset,\r\n{ "frame_crop_bottom_offset", "h264.frame_crop_bottom_offset",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_vui_parameters_present_flag,\r\n{ "vui_parameters_present_flag", "h264.vui_parameters_present_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pic_parameter_set_id,\r\n{ "pic_parameter_set_id", "h264.pic_parameter_set_id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_entropy_coding_mode_flag,\r\n{ "entropy_coding_mode_flag", "h264.entropy_coding_mode_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pic_order_present_flag,\r\n{ "pic_order_present_flag", "h264.pic_order_present_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_num_slice_groups_minus1,\r\n{ "num_slice_groups_minus1", "h264.num_slice_groups_minus1",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_slice_group_map_type,\r\n{ "slice_group_map_type", "h264.slice_group_map_type",\r\nFT_UINT32, BASE_DEC, VALS(h264_slice_group_map_type_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_num_ref_idx_l0_active_minus1,\r\n{ "num_ref_idx_l0_active_minus1", "h264.num_ref_idx_l0_active_minus1",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_num_ref_idx_l1_active_minus1,\r\n{ "num_ref_idx_l1_active_minus1", "h264.num_ref_idx_l1_active_minus1",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_weighted_pred_flag,\r\n{ "weighted_pred_flag", "h264.weighted_pred_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_weighted_bipred_idc,\r\n{ "weighted_bipred_idc", "h264.weighted_bipred_idc",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pic_init_qp_minus26,\r\n{ "pic_init_qp_minus26", "h264.pic_init_qp_minus26",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pic_init_qs_minus26,\r\n{ "pic_init_qs_minus26", "h264.pic_init_qs_minus26",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_chroma_qp_index_offset,\r\n{ "chroma_qp_index_offset", "h264.chroma_qp_index_offset",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_deblocking_filter_control_present_flag,\r\n{ "deblocking_filter_control_present_flag", "h264.deblocking_filter_control_present_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_constrained_intra_pred_flag,\r\n{ "constrained_intra_pred_flag", "h264.constrained_intra_pred_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_redundant_pic_cnt_present_flag,\r\n{ "redundant_pic_cnt_present_flag", "h264.redundant_pic_cnt_present_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_transform_8x8_mode_flag,\r\n{ "transform_8x8_mode_flag", "h264.transform_8x8_mode_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pic_scaling_matrix_present_flag,\r\n{ "pic_scaling_matrix_present_flag", "h264.pic_scaling_matrix_present_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_second_chroma_qp_index_offset,\r\n{ "second_chroma_qp_index_offset", "h264.second_chroma_qp_index_offset",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_aspect_ratio_info_present_flag,\r\n{ "aspect_ratio_info_present_flag", "h264.aspect_ratio_info_present_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_aspect_ratio_idc,\r\n{ "aspect_ratio_idc", "h264.aspect_ratio_idc",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sar_width,\r\n{ "sar_width", "h264.sar_width",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sar_height,\r\n{ "sar_height", "h264.sar_height",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_overscan_info_present_flag,\r\n{ "overscan_info_present_flag", "h264.overscan_info_present_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_overscan_appropriate_flag,\r\n{ "overscan_appropriate_flag", "h264.overscan_appropriate_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_video_signal_type_present_flag,\r\n{ "video_signal_type_present_flag", "h264.video_signal_type_present_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_video_format,\r\n{ "video_format", "h264.video_format",\r\nFT_UINT8, BASE_DEC, VALS(h264_video_format_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_video_full_range_flag,\r\n{ "video_full_range_flag", "h264.video_full_range_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_colour_description_present_flag,\r\n{ "colour_description_present_flag", "h264.colour_description_present_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_colour_primaries,\r\n{ "colour_primaries", "h264.colour_primaries",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_transfer_characteristics,\r\n{ "transfer_characteristics", "h264.transfer_characteristics",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_matrix_coefficients,\r\n{ "matrix_coefficients", "h264.matrix_coefficients",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_chroma_loc_info_present_flag,\r\n{ "chroma_loc_info_present_flag", "h264.chroma_loc_info_present_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_chroma_sample_loc_type_top_field,\r\n{ "chroma_sample_loc_type_top_field", "h264.chroma_sample_loc_type_top_field",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_chroma_sample_loc_type_bottom_field,\r\n{ "chroma_sample_loc_type_bottom_field", "h264.chroma_sample_loc_type_bottom_field",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_timing_info_present_flag,\r\n{ "timing_info_present_flag", "h264.timing_info_present_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_num_units_in_tick,\r\n{ "num_units_in_tick", "h264.num_units_in_tick",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_time_scale,\r\n{ "time_scale", "h264.time_scale",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_fixed_frame_rate_flag,\r\n{ "fixed_frame_rate_flag", "h264.fixed_frame_rate_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_hrd_parameters_present_flag,\r\n{ "nal_hrd_parameters_present_flag", "h264.nal_hrd_parameters_present_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_vcl_hrd_parameters_present_flag,\r\n{ "vcl_hrd_parameters_present_flag", "h264.vcl_hrd_parameters_present_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_low_delay_hrd_flag,\r\n{ "low_delay_hrd_flag", "h264.low_delay_hrd_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pic_struct_present_flag,\r\n{ "pic_struct_present_flag", "h264.pic_struct_present_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_bitstream_restriction_flag,\r\n{ "bitstream_restriction_flag", "h264.bitstream_restriction_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_motion_vectors_over_pic_boundaries_flag,\r\n{ "motion_vectors_over_pic_boundaries_flag", "h264.motion_vectors_over_pic_boundaries_flag",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_max_bytes_per_pic_denom,\r\n{ "max_bytes_per_pic_denom", "h264.max_bytes_per_pic_denom",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_max_bits_per_mb_denom,\r\n{ "max_bits_per_mb_denom", "h264.max_bits_per_mb_denom",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_log2_max_mv_length_horizontal,\r\n{ "max_mv_length_horizontal", "h264.max_mv_length_horizontal",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_log2_max_mv_length_vertical,\r\n{ "log2_max_mv_length_vertical", "h264.log2_max_mv_length_vertical",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_num_reorder_frames,\r\n{ "num_reorder_frames", "h264.num_reorder_frames",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_max_dec_frame_buffering,\r\n{ "max_dec_frame_buffering", "h264.max_dec_frame_buffering",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_cpb_cnt_minus1,\r\n{ "cpb_cnt_minus1", "h264.cpb_cnt_minus1",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_bit_rate_scale,\r\n{ "bit_rate_scale", "h264.bit_rate_scale",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_cpb_size_scale,\r\n{ "cpb_size_scale", "h264.cpb_size_scale",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_bit_rate_value_minus1,\r\n{ "bit_rate_value_minus1", "h264.bit_rate_value_minus1",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_cpb_size_value_minus1,\r\n{ "cpb_size_value_minus1", "h264.cpb_size_value_minus1",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_cbr_flag,\r\n{ "cbr_flag", "h264.cbr_flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_initial_cpb_removal_delay_length_minus1,\r\n{ "initial_cpb_removal_delay_length_minus1", "h264.initial_cpb_removal_delay_length_minus1",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_cpb_removal_delay_length_minus1,\r\n{ "cpb_removal_delay_length_minus1", "h264.cpb_removal_delay_length_minus1",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_dpb_output_delay_length_minus11,\r\n{ "dpb_output_delay_length_minus11", "h264.dpb_output_delay_length_minus11",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_time_offset_length,\r\n{ "time_offset_length", "h264.time_offset_length",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_first_mb_in_slice,\r\n{ "first_mb_in_slice", "h264.first_mb_in_slice",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_slice_type,\r\n{ "slice_type", "h264.slice_type",\r\nFT_UINT32, BASE_DEC, VALS(h264_slice_type_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_slice_id,\r\n{ "slice_id", "h264.slice_id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_payloadsize,\r\n{ "PayloadSize", "h264.payloadsize",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_payloadtype,\r\n{ "payloadType", "h264.payloadtype",\r\nFT_UINT32, BASE_DEC, VALS(h264_sei_payload_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n#if 0\r\n{ &hf_h264_frame_num,\r\n{ "frame_num", "h264.frame_num",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n#endif\r\n{ &hf_h264_par_profile,\r\n{ "Profile", "h264.par_profile",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL}},\r\n{ &hf_h264_par_profile_b,\r\n{ "Baseline Profile", "h264.par_profile.base",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL}},\r\n{ &hf_h264_par_profile_m,\r\n{ "Main Profile", "h264.par_profile.main",\r\nFT_BOOLEAN, 8, NULL, 0x20,\r\nNULL, HFILL}},\r\n{ &hf_h264_par_profile_e,\r\n{ "Extended Profile.", "h264.par_profile.ext",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\nNULL, HFILL}},\r\n{ &hf_h264_par_profile_h,\r\n{ "High Profile", "h264.par_profile.high",\r\nFT_BOOLEAN, 8, NULL, 0x08,\r\nNULL, HFILL}},\r\n{ &hf_h264_par_profile_h10,\r\n{ "High 10 Profile", "h264.par_profile.high10",\r\nFT_BOOLEAN, 8, NULL, 0x04,\r\nNULL, HFILL}},\r\n{ &hf_h264_par_profile_h4_2_2,\r\n{ "High 4:2:2 Profile", "h264.par_profile.high4_2_2",\r\nFT_BOOLEAN, 8, NULL, 0x02,\r\nNULL, HFILL}},\r\n{ &hf_h264_par_profile_h4_4_4,\r\n{ "High 4:4:4 Profile", "h264.par_profile.high4_4_4",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL}},\r\n{ &hf_h264_par_AdditionalModesSupported,\r\n{ "AdditionalModesSupported", "h264.AdditionalModesSupported",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL}},\r\n#if 0\r\n{ &hf_h264_par_add_mode_sup,\r\n{ "Additional Modes Supported", "h264.add_mode_sup",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL}},\r\n#endif\r\n{ &hf_h264_par_add_mode_sup_rcdo,\r\n{ "Reduced Complexity Decoding Operation (RCDO) support", "h264.add_mode_sup.rcdo",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL}},\r\n{ &hf_h264_par_ProfileIOP,\r\n{ "ProfileIOP", "h264.ProfileIOP",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL}},\r\n{ &hf_h264_par_constraint_set0_flag,\r\n{ "constraint_set0_flag", "h264.par.constraint_set0_flag",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL}},\r\n{ &hf_h264_par_constraint_set1_flag,\r\n{ "constraint_set1_flag", "h264.par.constraint_set1_flag",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL}},\r\n{ &hf_h264_par_constraint_set2_flag,\r\n{ "constraint_set2_flag", "h264.par.constraint_set2_flag",\r\nFT_BOOLEAN, 8, NULL, 0x20,\r\nNULL, HFILL}},\r\n{ &hf_h264_nalu_size,\r\n{ "NAL Unit Size", "h264.nalu_size",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_don,\r\n{ "Decoder Order Number", "h264.don",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_dond,\r\n{ "MTAP Decoder Order Number Delta", "h264.don_delta",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_ts_offset16,\r\n{ "MTAP TS Offset", "h264.ts_offset16",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_ts_offset24,\r\n{ "MTAP TS Offset", "h264.ts_offset24",\r\nFT_UINT24, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_extension_subtype,\r\n{ "Extension Header Subtype", "h264.nal_hdr_extension.subtype",\r\nFT_UINT8, BASE_DEC, VALS(h264_subtype_values), 0xF8,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_extension_j,\r\n{ "Extension Header J - DON Present Indicator", "h264.nal_hdr_extension.j",\r\nFT_BOOLEAN, 8, NULL, 0x4,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_extension_k,\r\n{ "Extension Header K", "h264.nal_hdr_extension.k",\r\nFT_BOOLEAN, 8, NULL, 0x2,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_extension_l,\r\n{ "Extension Header L", "h264.nal_hdr_extension.l",\r\nFT_BOOLEAN, 8, NULL, 0x1,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_uuid,\r\n{ "UUID", "h264.sei.uuid",\r\nFT_GUID, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_lpb,\r\n{ "Layer Presence", "h264.sei.ms.layout.lpb",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_layout_p,\r\n{ "Layer Description Present", "h264.sei.ms.layout.p",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_layout_ldsize,\r\n{ "Layer Description Size", "h264.sei.ms.layout.desc.ldsize",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_layer_desc_coded_width,\r\n{ "Coded Width", "h264.sei.ms.layout.desc.coded_width",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_layer_desc_coded_height,\r\n{ "Coded Height", "h264.sei.ms.layout.desc.coded_height",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_layer_desc_display_width,\r\n{ "Display Width", "h264.sei.ms.layout.desc.display_width",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_layer_desc_display_height,\r\n{ "Display Height", "h264.sei.ms.layout.desc.display_height",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_layer_desc_bitrate,\r\n{ "Bitrate", "h264.sei.ms.layout.desc.bitrate",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_layer_desc_frame_rate,\r\n{ "Frame Rate Index", "h264.sei.ms.layout.desc.frame_rate",\r\nFT_UINT8, BASE_DEC, VALS(h264_sei_ms_frame_values), 0xF8,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_layer_desc_layer_type,\r\n{ "Layer Type", "h264.sei.ms.layout.desc.layer_type",\r\nFT_UINT8, BASE_DEC, NULL, 0x07,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_layer_desc_prid,\r\n{ "Priority ID", "h264.sei.ms.layout.desc.prid",\r\nFT_UINT8, BASE_DEC, NULL, 0xFC,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_layer_desc_cb,\r\n{ "Constrained Baseline", "h264.sei.ms.layout.desc.constrained_baseline",\r\nFT_BOOLEAN, 8, NULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_bitstream_ref_frame_cnt,\r\n{ "Reference Frame Count", "h264.sei.ms.bitstream_info.ref_frm_cnt",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_bitstream_num_nalus,\r\n{ "Number of NAL units", "h264.sei.ms.bitstrea3416m_info.num_nalus",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_iso_sec_info,\r\n{ "Unparsed iso_iec information", "h264.sei.iso_sec_info",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_crop_num_data,\r\n{ "Number of Data Entries", "h264.sei.ms.crop.num_data",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_crop_info_type,\r\n{ "Info Type", "h264.sei.ms.crop.info_type",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_crop_confidence_level,\r\n{ "Confidence Level", "h264.sei.ms.crop.confidence_level",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_crop_frame_left_offset,\r\n{ "Left Offset", "h264.sei.ms.crop.left_offset",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_crop_frame_right_offset,\r\n{ "Right Offset", "h264.sei.ms.crop.right_offset",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_crop_frame_top_offset,\r\n{ "Top Offset", "h264.sei.ms.crop.top_offset",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_sei_ms_crop_frame_bottom_offset,\r\n{ "Bottom Offset", "h264.sei.ms.crop.bottom_offset",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_hdr_ext_svc,\r\n{ "SVC Extension / Reserved", "h264.nal_hdr_ext.r",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_hdr_ext_i,\r\n{ "IDR Picture", "h264.nal_hdr_ext.i",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_hdr_ext_prid,\r\n{ "Priority ID", "h264.nal_hdr_ext.prid",\r\nFT_UINT8, BASE_DEC, NULL, 0x3f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_hdr_ext_n,\r\n{ "No Inter Layer Prediction", "h264.nal_hdr_ext.n",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_hdr_ext_did,\r\n{ "Dependency ID", "h264.nal_hdr_ext.did",\r\nFT_UINT8, BASE_DEC, NULL, 0x70,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_hdr_ext_qid,\r\n{ "Quality ID", "h264.nal_hdr_ext.qid",\r\nFT_UINT8, BASE_DEC, NULL, 0x0f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_hdr_ext_tid,\r\n{ "Temporal ID", "h264.nal_hdr_ext.tid",\r\nFT_UINT8, BASE_DEC, NULL, 0xe0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_hdr_ext_u,\r\n{ "Use Ref Base Picture", "h264.nal_hdr_ext.u",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_hdr_ext_d,\r\n{ "Discardable", "h264.nal_hdr_ext.d",\r\nFT_BOOLEAN, 8, NULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_hdr_ext_o,\r\n{ "Output", "h264.nal_hdr_ext.o",\r\nFT_BOOLEAN, 8, NULL, 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_nal_hdr_ext_rr,\r\n{ "Reserved", "h264.nal_hdr_ext.rr",\r\nFT_UINT8, BASE_HEX, NULL, 0x03,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pacsi_x,\r\n{ "X - A,P,C Field Indicator", "h264.pacsi.x",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pacsi_y,\r\n{ "Y - Pic Fields Indicator", "h264.pacsi.y",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pacsi_t,\r\n{ "T - DONC Field Indicator", "h264.pacsi.t",\r\nFT_BOOLEAN, 8, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pacsi_a,\r\n{ "A - Anchor Layer", "h264.pacsi.a",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pacsi_p,\r\n{ "P - Redundant Slice", "h264.pacsi.p",\r\nFT_BOOLEAN, 8, NULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pacsi_c,\r\n{ "C - Intra Slice", "h264.pacsi.c",\r\nFT_BOOLEAN, 8, NULL, 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pacsi_s,\r\n{ "S - First Nal Unit of Layer", "h264.pacsi.s",\r\nFT_BOOLEAN, 8, NULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pacsi_e,\r\n{ "E - Last Nal Unit of Layer", "h264.pacsi.e",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pacsi_tl0picidx,\r\n{ "TL0PICIDX", "h264.pacsi.tl0picidx",\r\nFT_UINT8, BASE_DEC, NULL, 0xFF,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pacsi_idrpicid,\r\n{ "IDRPICID - IDR Picture ID", "h264.pacsi.idrpicid",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_h264_pacsi_donc,\r\n{ "DONC - Cross Session Decoder Order Number", "h264.pacsi.donc",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_h264,\r\n&ett_h264_profile,\r\n&ett_h264_nal,\r\n&ett_h264_fua,\r\n&ett_h264_stream,\r\n&ett_h264_nal_unit,\r\n&ett_h264_par_profile,\r\n&ett_h264_par_AdditionalModesSupported,\r\n&ett_h264_par_ProfileIOP,\r\n&ett_h264_ms_layer_description,\r\n&ett_h264_ms_crop_data,\r\n&ett_h264_ni_mtap\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_h264_undecoded, { "h264.undecoded", PI_UNDECODED, PI_WARN, "[Not decoded yet]", EXPFILL }},\r\n{ &ei_h264_ms_layout_wrong_length, { "h264.ms_layout.wrong_length", PI_PROTOCOL, PI_WARN, "[Wrong Layer Description Table Length]", EXPFILL }},\r\n{ &ei_h264_bad_nal_length, { "h264.bad_nalu_length", PI_MALFORMED, PI_ERROR, "[Bad NAL Unit Length]", EXPFILL }},\r\n{ &ei_h264_nal_unit_type_reserved, { "h264.nal_unit_type.reserved", PI_PROTOCOL, PI_WARN, "Reserved NAL unit type", EXPFILL }},\r\n{ &ei_h264_nal_unit_type_unspecified, { "h264.nal_unit_type.unspecified", PI_PROTOCOL, PI_WARN, "Unspecified NAL unit type", EXPFILL }},\r\n};\r\nproto_h264 = proto_register_protocol("H.264","H264", "h264");\r\nproto_register_field_array(proto_h264, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_h264 = expert_register_protocol(proto_h264);\r\nexpert_register_field_array(expert_h264, ei, array_length(ei));\r\nh264_module = prefs_register_protocol(proto_h264, proto_reg_handoff_h264);\r\nprefs_register_range_preference(h264_module, "dynamic.payload.type",\r\n"H264 dynamic payload types",\r\n"Dynamic payload types which will be interpreted as H264"\r\n"; Values must be in the range 96 - 127",\r\n&temp_dynamic_payload_type_range, 127);\r\nregister_dissector("h264", dissect_h264, proto_h264);\r\n}\r\nvoid\r\nproto_reg_handoff_h264(void)\r\n{\r\nstatic range_t *dynamic_payload_type_range = NULL;\r\nstatic gboolean h264_prefs_initialized = FALSE;\r\nif (!h264_prefs_initialized) {\r\ndissector_handle_t h264_name_handle;\r\nh264_capability_t *ftr;\r\nh264_handle = find_dissector("h264");\r\ndissector_add_string("rtp_dyn_payload_type","H264", h264_handle);\r\ndissector_add_string("rtp_dyn_payload_type","H264-SVC", h264_handle);\r\ndissector_add_string("rtp_dyn_payload_type","X-H264UC", h264_handle);\r\nh264_name_handle = create_dissector_handle(dissect_h264_name, proto_h264);\r\nfor (ftr=h264_capability_tab; ftr->id; ftr++) {\r\nif (ftr->name)\r\ndissector_add_string("h245.gef.name", ftr->id, h264_name_handle);\r\nif (ftr->content_pdu)\r\ndissector_add_string("h245.gef.content", ftr->id, create_dissector_handle(ftr->content_pdu, proto_h264));\r\n}\r\nh264_prefs_initialized = TRUE;\r\n} else {\r\nrange_foreach(dynamic_payload_type_range, range_delete_h264_rtp_pt_callback);\r\ng_free(dynamic_payload_type_range);\r\n}\r\ndynamic_payload_type_range = range_copy(temp_dynamic_payload_type_range);\r\nrange_foreach(dynamic_payload_type_range, range_add_h264_rtp_pt_callback);\r\n}
