static void cf_opa_snc_dw_to_b(gchar *buf, guint32 value)\r\n{\r\ng_snprintf(buf, ITEM_LABEL_LENGTH, "%u DWORDS, %u Bytes", value, value * 4);\r\n}\r\nstatic void cf_opa_snc_qw_to_b(gchar *buf, guint32 value)\r\n{\r\ng_snprintf(buf, ITEM_LABEL_LENGTH, "%u QWORDS, %u Bytes", value, value * 8);\r\n}\r\nstatic int dissect_opa_snc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\ngint offset = 0;\r\ngboolean isBypass = TRUE;\r\nguint8 Direction = tvb_get_guint8(tvb, offset + 1);\r\nguint64 RHF_PBC;\r\nproto_item *SnC_item;\r\nproto_tree * SnC_tree,*PBC_tree,*RHF_tree;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Omni-Path");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ntree = proto_tree_get_parent_tree(tree);\r\nSnC_item = proto_tree_add_item(tree, proto_opa_snc, tvb, offset, 16, ENC_NA);\r\nSnC_tree = proto_item_add_subtree(SnC_item, ett_snc);\r\nproto_tree_add_item(SnC_tree, hf_opa_snc_portnumber, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(SnC_tree, hf_opa_snc_direction, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(SnC_tree, hf_opa_snc_Reserved16, tvb, offset, 2, ENC_NA);\r\noffset += 2;\r\nproto_tree_add_item(SnC_tree, hf_opa_snc_Reserved32, tvb, offset, 4, ENC_NA);\r\noffset += 4;\r\nRHF_PBC = tvb_get_letoh64(tvb, offset);\r\nswitch (Direction) {\r\ncase 0:\r\nPBC_tree = proto_tree_add_subtree(SnC_tree, tvb, offset, 8, ett_sncpbc, NULL, "PBC - Per Buffer Control");\r\nproto_tree_add_bitmask_list(PBC_tree, tvb, offset + 4, 4, _snc_pbc_1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_list(PBC_tree, tvb, offset, 4, _snc_pbc_2, ENC_LITTLE_ENDIAN);\r\nisBypass = (((RHF_PBC >> 28) & 1) == 1);\r\nbreak;\r\ncase 1:\r\nRHF_tree = proto_tree_add_subtree(SnC_tree, tvb, offset, 8, ett_sncrhf, NULL, "RHF - Receive Header Flags");\r\nproto_tree_add_bitmask_list(RHF_tree, tvb, offset + 4, 4, _snc_rhf_1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_list(RHF_tree, tvb, offset, 4, _snc_rhf_2, ENC_LITTLE_ENDIAN);\r\nisBypass = (((RHF_PBC >> 12) & 7) == 4);\r\nbreak;\r\ncase 2:\r\nproto_tree_add_item(SnC_tree, hf_opa_snc_Reserved64, tvb, offset, 8, ENC_NA);\r\nisBypass = FALSE;\r\nbreak;\r\ndefault:\r\nisBypass = FALSE;\r\n}\r\noffset += 8;\r\nif (isBypass) {\r\nexpert_add_info(pinfo, NULL, &ei_opa_snc_nobypass);\r\n} else {\r\ncall_dissector(opa_9b_handle, tvb_new_subset_remaining(tvb, offset), pinfo, tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_opa_snc(void)\r\n{\r\nexpert_module_t *expert_opa_snc;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_opa_snc_direction, {\r\n"Direction", "opa.snc.direction",\r\nFT_UINT8, BASE_HEX, VALS(vals_opa_snc_direction), 0x0, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_portnumber, {\r\n"Port Number", "opa.snc.portnumber",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_Reserved32, {\r\n"Reserved (32 bits)", "opa.snc.reserved32",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_Reserved64, {\r\n"Reserved (64 bits)", "opa.snc.reserved64",\r\nFT_UINT64, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_Reserved16, {\r\n"Reserved (16 bits)", "opa.snc.reserved16",\r\nFT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_pbc_reserved_63_48, {\r\n"Reserved (16 bits)", "opa.snc.pbc.reserved_63_48",\r\nFT_UINT32, BASE_HEX, NULL, 0xFFFF0000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_pbc_pbcstaticratecontrolcnt, {\r\n"Static Rate Control Counter", "opa.snc.pbc.pbcstaticratecontrolcnt",\r\nFT_UINT32, BASE_HEX, NULL, 0x0000FFFF, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_pbc_pbcintr, {\r\n"Interrupt", "opa.snc.pbc.pbcintr",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), 0x80000000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_pbc_pbcdcinfo, {\r\n"DC Info", "opa.snc.pbc.pbcdcinfo",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), 0x40000000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_pbc_pbctestebp, {\r\n"Test End Bad Packet", "opa.snc.pbc.pbctestebp",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), 0x20000000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_pbc_pbcpacketbypass, {\r\n"Packet Type", "opa.snc.pbc.pbcpacketbypass",\r\nFT_BOOLEAN, 32, TFS(&tfs_opa_snc_pbc_isBypass), 0x10000000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_pbc_pbcinserthcrc, {\r\n"Insert Hcrc", "opa.snc.pbc.pbcinserthcrc",\r\nFT_UINT32, BASE_HEX, VALS(vals_opa_snc_pbc_insertHcrc), 0x0C000000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_pbc_pbccreditreturn, {\r\n"Request Credit Return", "opa.snc.pbc.pbccreditreturn",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), 0x02000000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_pbc_pbcinsertbypassicrc, {\r\n"Insert ICRC for bypass packets", "opa.snc.pbc.pbcinsertbypassicrc",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), 0x01000000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_pbc_pbctestbadicrc, {\r\n"Insert a bad ICRC", "opa.snc.pbc.pbctestbadicrc",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), 0x00800000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_pbc_pbcfecn, {\r\n"Set FECN bit", "opa.snc.pbc.pbcfecn",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), 0x00400000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_pbc_reserved_21_16, {\r\n"Reserved (6 bits)", "opa.snc.pbc.reserved_21_16",\r\nFT_UINT32, BASE_HEX, NULL, 0x003F0000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_pbc_pbcvl, {\r\n"VL", "opa.snc.pbc.pbcvl",\r\nFT_UINT32, BASE_DEC, NULL, 0x0000F000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_pbc_pbclengthdws, {\r\n"pbclengthdws", "opa.snc.pbc.pbclengthdws",\r\nFT_UINT32, BASE_CUSTOM, CF_FUNC(cf_opa_snc_dw_to_b), 0x00000FFF, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_icrcerr, {\r\n"ICRC error", "opa.snc.rhf.icrcerr",\r\nFT_BOOLEAN, 32, TFS(&tfs_error_ok), 0x80000000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_reserved_62, {\r\n"Reserved (1 bit)", "opa.snc.rhf.reserved_62",\r\nFT_UINT32, BASE_HEX, NULL, 0x40000000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_eccerr, {\r\n"Internal memory Uncorrectable error", "opa.snc.rhf.eccerr",\r\nFT_BOOLEAN, 32, TFS(&tfs_error_ok), 0x200000000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_lenerr, {\r\n"Length Error", "opa.snc.rhf.lenerr",\r\nFT_BOOLEAN, 32, TFS(&tfs_error_ok), 0x10000000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_tiderr, {\r\n"TID Error", "opa.snc.rhf.tiderr",\r\nFT_BOOLEAN, 32, TFS(&tfs_error_ok), 0x08000000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_rcvtypeerr, {\r\n"Receive Type Error", "opa.snc.rhf.rcvtypeerr",\r\nFT_UINT32, BASE_HEX, VALS(vals_opa_snc_rhf_rcvtypeerr), 0x07000000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_dcerr, {\r\n"End Bad Packet Error", "opa.snc.rhf.dcerr",\r\nFT_BOOLEAN, 32, TFS(&tfs_error_ok), 0x00800000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_dcuncerr, {\r\n"Uncorrectable or parity error", "opa.snc.rhf.dcuncerr",\r\nFT_BOOLEAN, 32, TFS(&tfs_error_ok), 0x00400000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_khdrlenerr, {\r\n"KDETH Length Error", "opa.snc.rhf.khdrlenerr",\r\nFT_BOOLEAN, 32, TFS(&tfs_error_ok), 0x00200000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_hdrqoffset, {\r\n"Receive Header Offset", "opa.snc.rhf.hdrqoffset",\r\nFT_UINT32, BASE_CUSTOM, CF_FUNC(cf_opa_snc_dw_to_b), 0x001FF000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_egroffset, {\r\n"Eager Buffer Offset", "opa.snc.rhf.egroffset",\r\nFT_UINT32, BASE_CUSTOM, CF_FUNC(cf_opa_snc_qw_to_b), 0x00000FFF, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_rcvseq, {\r\n"Receive Sequence", "opa.snc.rhf.rcvseq",\r\nFT_UINT32, BASE_DEC, NULL, 0xF0000000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_dcinfo, {\r\n"DC Info", "opa.snc.rhf.dcinfo",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), 0x08000000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_egrindex, {\r\n"Eager Buffer Index", "opa.snc.rhf.egrindex",\r\nFT_UINT32, BASE_HEX, NULL, 0x07FF0000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_useegrbfr, {\r\n"Use Eager Buffer", "opa.snc.rhf.useegrbfr",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), 0x00008000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_rcvtype, {\r\n"Packet Receive Type", "opa.snc.rhf.rcvtype",\r\nFT_UINT32, BASE_DEC_HEX, VALS(vals_opa_snc_rhf_rcvtype), 0x00007000, NULL, HFILL }\r\n},\r\n{ &hf_opa_snc_rhf_pktlen, {\r\n"Packet Length", "opa.snc.rhf.pktlen",\r\nFT_UINT32, BASE_CUSTOM, CF_FUNC(cf_opa_snc_dw_to_b), 0x00000FFF, NULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_snc,\r\n&ett_sncpbc,\r\n&ett_sncrhf,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_opa_snc_nobypass, {\r\n"opa.snc.nobypass", PI_PROTOCOL, PI_WARN,\r\n"Bypass packets not implemented in this version", EXPFILL }\r\n}\r\n};\r\nproto_opa_snc = proto_register_protocol(\r\n"Intel Omni-Path SnC - Omni-Path Snoop and Capture MetaData Header",\r\n"OPA SnC", "opa.snc");\r\nopa_snc_handle = register_dissector("opa.snc", dissect_opa_snc, proto_opa_snc);\r\nproto_register_field_array(proto_opa_snc, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_opa_snc = expert_register_protocol(proto_opa_snc);\r\nexpert_register_field_array(expert_opa_snc, ei, array_length(ei));\r\n}\r\nvoid proto_reg_handoff_opa_snc(void)\r\n{\r\nopa_9b_handle = find_dissector("opa");\r\ndissector_add_uint("erf.types.type", ERF_TYPE_OPA_SNC, opa_snc_handle);\r\n}
