static inline struct nl_handle *nl_socket_alloc(void)\r\n{\r\nreturn nl_handle_alloc();\r\n}\r\nstatic inline void nl_socket_free(struct nl_sock *h)\r\n{\r\nnl_handle_destroy(h);\r\n}\r\nstatic void\r\niface_mon_handler2(struct nl_object *obj, void *arg)\r\n{\r\nstruct rtnl_link *filter;\r\nstruct rtnl_link *link_obj;\r\nint flags, up;\r\nchar *ifname;\r\niface_mon_cb cb = (iface_mon_cb)arg;\r\nfilter = rtnl_link_alloc();\r\nif (!filter) {\r\nfprintf(stderr, "error allocating filter\n");\r\nreturn;\r\n}\r\nif (nl_object_match_filter (obj, OBJ_CAST (filter)) == 0) {\r\nrtnl_link_put(filter);\r\nreturn;\r\n}\r\nlink_obj = (struct rtnl_link *) obj;\r\nflags = rtnl_link_get_flags (link_obj);\r\nifname = rtnl_link_get_name(link_obj);\r\nup = (flags & IFF_UP) ? 1 : 0;\r\ncb(ifname, up);\r\nrtnl_link_put(filter);\r\nreturn;\r\n}\r\nstatic int\r\niface_mon_handler(struct nl_msg *msg, void *arg)\r\n{\r\nnl_msg_parse (msg, &iface_mon_handler2, arg);\r\nreturn 0;\r\n}\r\nvoid\r\niface_mon_event(void)\r\n{\r\nnl_recvmsgs_default(iface_mon_sock);\r\n}\r\nint\r\niface_mon_get_sock(void)\r\n{\r\nreturn nl_socket_get_fd(iface_mon_sock);\r\n}\r\nint\r\niface_mon_start(iface_mon_cb cb)\r\n{\r\nint err;\r\niface_mon_sock = nl_socket_alloc();\r\nif (!iface_mon_sock) {\r\nfprintf(stderr, "Failed to allocate netlink socket.\n");\r\nreturn -ENOMEM;\r\n}\r\nnl_socket_disable_seq_check(iface_mon_sock);\r\nnl_socket_modify_cb(iface_mon_sock, NL_CB_VALID, NL_CB_CUSTOM, iface_mon_handler, (void *)cb);\r\nif (nl_connect(iface_mon_sock, NETLINK_ROUTE)) {\r\nfprintf(stderr, "Failed to connect to generic netlink.\n");\r\nerr = -ENOLINK;\r\ngoto out_handle_destroy;\r\n}\r\nnl_socket_add_membership(iface_mon_sock, RTNLGRP_LINK);\r\nreturn 0;\r\nout_handle_destroy:\r\nnl_socket_free(iface_mon_sock);\r\nreturn err;\r\n}\r\nvoid\r\niface_mon_stop(void)\r\n{\r\nif(iface_mon_sock)\r\nnl_socket_free(iface_mon_sock);\r\niface_mon_sock = NULL;\r\n}\r\nint\r\niface_mon_start(iface_mon_cb cb)\r\n{\r\nint ret;\r\nstruct kev_request key;\r\ns = socket(PF_SYSTEM, SOCK_RAW, SYSPROTO_EVENT);\r\nif (s == -1)\r\nreturn -errno;\r\nkey.vendor_code = KEV_VENDOR_APPLE;\r\nkey.kev_class = KEV_NETWORK_CLASS;\r\nkey.kev_subclass = KEV_DL_SUBCLASS;\r\nif (ioctl(s, SIOCSKEVFILT, &key) == -1) {\r\nret = -errno;\r\nclose(s);\r\nreturn ret;\r\n}\r\ncallback = cb;\r\nreturn 0;\r\n}\r\nvoid\r\niface_mon_stop(void)\r\n{\r\nclose(s);\r\n}\r\nint\r\niface_mon_get_sock(void)\r\n{\r\nreturn s;\r\n}\r\nvoid\r\niface_mon_event(void)\r\n{\r\nchar msg[NET_EVENT_DATA_SIZE];\r\nssize_t received;\r\nstruct kern_event_msg *kem;\r\nstruct net_event_data *evd;\r\nsize_t evd_len;\r\nchar ifr_name[IFNAMSIZ];\r\nreceived = recv(s, msg, sizeof msg, 0);\r\nif (received < 0) {\r\nreturn;\r\n}\r\nif ((size_t)received < sizeof msg) {\r\nreturn;\r\n}\r\nkem = (struct kern_event_msg *)msg;\r\nevd_len = kem->total_size - KEV_MSG_HEADER_SIZE;\r\nif (evd_len != sizeof (struct net_event_data)) {\r\nreturn;\r\n}\r\nevd = (struct net_event_data *)&kem->event_data[0];\r\ng_snprintf(ifr_name, IFNAMSIZ, "%s%u", evd->if_name, evd->if_unit);\r\nswitch (kem->event_code) {\r\ncase KEV_DL_IF_ATTACHED:\r\ncallback(ifr_name, 1);\r\nbreak;\r\ncase KEV_DL_IF_DETACHED:\r\ncallback(ifr_name, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nint\r\niface_mon_start(iface_mon_cb cb _U_)\r\n{\r\nreturn -1;\r\n}\r\nvoid\r\niface_mon_stop(void)\r\n{\r\n}\r\nint\r\niface_mon_get_sock(void)\r\n{\r\nreturn -1;\r\n}\r\nvoid\r\niface_mon_event(void)\r\n{\r\n}
