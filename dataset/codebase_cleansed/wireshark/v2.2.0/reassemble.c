static guint\r\nfragment_addresses_hash(gconstpointer k)\r\n{\r\nconst fragment_addresses_key* key = (const fragment_addresses_key*) k;\r\nguint hash_val;\r\nhash_val = 0;\r\nhash_val += key->id;\r\nreturn hash_val;\r\n}\r\nstatic gint\r\nfragment_addresses_equal(gconstpointer k1, gconstpointer k2)\r\n{\r\nconst fragment_addresses_key* key1 = (const fragment_addresses_key*) k1;\r\nconst fragment_addresses_key* key2 = (const fragment_addresses_key*) k2;\r\nreturn (key1->id == key2->id) &&\r\n(addresses_equal(&key1->src, &key2->src)) &&\r\n(addresses_equal(&key1->dst, &key2->dst));\r\n}\r\nstatic gpointer\r\nfragment_addresses_temporary_key(const packet_info *pinfo, const guint32 id,\r\nconst void *data _U_)\r\n{\r\nfragment_addresses_key *key = g_slice_new(fragment_addresses_key);\r\ncopy_address_shallow(&key->src, &pinfo->src);\r\ncopy_address_shallow(&key->dst, &pinfo->dst);\r\nkey->id = id;\r\nreturn (gpointer)key;\r\n}\r\nstatic gpointer\r\nfragment_addresses_persistent_key(const packet_info *pinfo, const guint32 id,\r\nconst void *data _U_)\r\n{\r\nfragment_addresses_key *key = g_slice_new(fragment_addresses_key);\r\ncopy_address(&key->src, &pinfo->src);\r\ncopy_address(&key->dst, &pinfo->dst);\r\nkey->id = id;\r\nreturn (gpointer)key;\r\n}\r\nstatic void\r\nfragment_addresses_free_temporary_key(gpointer ptr)\r\n{\r\nfragment_addresses_key *key = (fragment_addresses_key *)ptr;\r\nif(key)\r\ng_slice_free(fragment_addresses_key, key);\r\n}\r\nstatic void\r\nfragment_addresses_free_persistent_key(gpointer ptr)\r\n{\r\nfragment_addresses_key *key = (fragment_addresses_key *)ptr;\r\nif(key){\r\nfree_address(&key->src);\r\nfree_address(&key->dst);\r\ng_slice_free(fragment_addresses_key, key);\r\n}\r\n}\r\nstatic guint\r\nfragment_addresses_ports_hash(gconstpointer k)\r\n{\r\nconst fragment_addresses_ports_key* key = (const fragment_addresses_ports_key*) k;\r\nguint hash_val;\r\nhash_val = 0;\r\nhash_val += key->id;\r\nreturn hash_val;\r\n}\r\nstatic gint\r\nfragment_addresses_ports_equal(gconstpointer k1, gconstpointer k2)\r\n{\r\nconst fragment_addresses_ports_key* key1 = (const fragment_addresses_ports_key*) k1;\r\nconst fragment_addresses_ports_key* key2 = (const fragment_addresses_ports_key*) k2;\r\nreturn (key1->id == key2->id) &&\r\n(addresses_equal(&key1->src_addr, &key2->src_addr)) &&\r\n(addresses_equal(&key1->dst_addr, &key2->dst_addr)) &&\r\n(key1->src_port == key2->src_port) &&\r\n(key1->dst_port == key2->dst_port);\r\n}\r\nstatic gpointer\r\nfragment_addresses_ports_temporary_key(const packet_info *pinfo, const guint32 id,\r\nconst void *data _U_)\r\n{\r\nfragment_addresses_ports_key *key = g_slice_new(fragment_addresses_ports_key);\r\ncopy_address_shallow(&key->src_addr, &pinfo->src);\r\ncopy_address_shallow(&key->dst_addr, &pinfo->dst);\r\nkey->src_port = pinfo->srcport;\r\nkey->dst_port = pinfo->destport;\r\nkey->id = id;\r\nreturn (gpointer)key;\r\n}\r\nstatic gpointer\r\nfragment_addresses_ports_persistent_key(const packet_info *pinfo,\r\nconst guint32 id, const void *data _U_)\r\n{\r\nfragment_addresses_ports_key *key = g_slice_new(fragment_addresses_ports_key);\r\ncopy_address(&key->src_addr, &pinfo->src);\r\ncopy_address(&key->dst_addr, &pinfo->dst);\r\nkey->src_port = pinfo->srcport;\r\nkey->dst_port = pinfo->destport;\r\nkey->id = id;\r\nreturn (gpointer)key;\r\n}\r\nstatic void\r\nfragment_addresses_ports_free_temporary_key(gpointer ptr)\r\n{\r\nfragment_addresses_ports_key *key = (fragment_addresses_ports_key *)ptr;\r\nif(key)\r\ng_slice_free(fragment_addresses_ports_key, key);\r\n}\r\nstatic void\r\nfragment_addresses_ports_free_persistent_key(gpointer ptr)\r\n{\r\nfragment_addresses_ports_key *key = (fragment_addresses_ports_key *)ptr;\r\nif(key){\r\nfree_address(&key->src_addr);\r\nfree_address(&key->dst_addr);\r\ng_slice_free(fragment_addresses_ports_key, key);\r\n}\r\n}\r\nstatic gint\r\nreassembled_equal(gconstpointer k1, gconstpointer k2)\r\n{\r\nconst reassembled_key* key1 = (const reassembled_key*) k1;\r\nconst reassembled_key* key2 = (const reassembled_key*) k2;\r\nreturn key1->frame == key2->frame && key1->id == key2->id;\r\n}\r\nstatic guint\r\nreassembled_hash(gconstpointer k)\r\n{\r\nconst reassembled_key* key = (const reassembled_key*) k;\r\nreturn key->frame;\r\n}\r\nstatic void\r\nreassembled_key_free(gpointer ptr)\r\n{\r\ng_slice_free(reassembled_key, (reassembled_key *)ptr);\r\n}\r\nstatic gboolean\r\nfree_all_fragments(gpointer key_arg _U_, gpointer value, gpointer user_data _U_)\r\n{\r\nfragment_head *fd_head;\r\nfragment_item *tmp_fd;\r\nfor (fd_head = (fragment_head *)value; fd_head != NULL; fd_head = tmp_fd) {\r\ntmp_fd=fd_head->next;\r\nif(fd_head->tvb_data && !(fd_head->flags&FD_SUBSET_TVB))\r\ntvb_free(fd_head->tvb_data);\r\ng_slice_free(fragment_item, fd_head);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic fragment_head *new_head(const guint32 flags)\r\n{\r\nfragment_head *fd_head;\r\nfd_head=g_slice_new0(fragment_head);\r\nfd_head->flags=flags;\r\nreturn fd_head;\r\n}\r\nstatic gboolean\r\nfree_all_reassembled_fragments(gpointer key_arg _U_, gpointer value,\r\ngpointer user_data)\r\n{\r\nGPtrArray *allocated_fragments = (GPtrArray *) user_data;\r\nfragment_head *fd_head;\r\nfor (fd_head = (fragment_head *)value; fd_head != NULL; fd_head = fd_head->next) {\r\nif (fd_head->flags != FD_VISITED_FREE) {\r\nif (fd_head->flags & FD_SUBSET_TVB)\r\nfd_head->tvb_data = NULL;\r\ng_ptr_array_add(allocated_fragments, fd_head);\r\nfd_head->flags = FD_VISITED_FREE;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic void\r\nfree_fragments(gpointer data, gpointer user_data _U_)\r\n{\r\nfragment_item *fd_head = (fragment_item *) data;\r\nif (fd_head->tvb_data)\r\ntvb_free(fd_head->tvb_data);\r\ng_slice_free(fragment_item, fd_head);\r\n}\r\nvoid\r\nreassembly_table_init(reassembly_table *table,\r\nconst reassembly_table_functions *funcs)\r\n{\r\nif (table->temporary_key_func == NULL)\r\ntable->temporary_key_func = funcs->temporary_key_func;\r\nif (table->persistent_key_func == NULL)\r\ntable->persistent_key_func = funcs->persistent_key_func;\r\nif (table->free_temporary_key_func == NULL)\r\ntable->free_temporary_key_func = funcs->free_temporary_key_func;\r\nif (table->fragment_table != NULL) {\r\ng_hash_table_foreach_remove(table->fragment_table,\r\nfree_all_fragments, NULL);\r\n} else {\r\ntable->fragment_table = g_hash_table_new_full(funcs->hash_func,\r\nfuncs->equal_func, funcs->free_persistent_key_func, NULL);\r\n}\r\nif (table->reassembled_table != NULL) {\r\nGPtrArray *allocated_fragments;\r\nallocated_fragments = g_ptr_array_new();\r\ng_hash_table_foreach_remove(table->reassembled_table,\r\nfree_all_reassembled_fragments, allocated_fragments);\r\ng_ptr_array_foreach(allocated_fragments, free_fragments, NULL);\r\ng_ptr_array_free(allocated_fragments, TRUE);\r\n} else {\r\ntable->reassembled_table = g_hash_table_new_full(reassembled_hash,\r\nreassembled_equal, reassembled_key_free, NULL);\r\n}\r\n}\r\nvoid\r\nreassembly_table_destroy(reassembly_table *table)\r\n{\r\ntable->temporary_key_func = NULL;\r\ntable->persistent_key_func = NULL;\r\ntable->free_temporary_key_func = NULL;\r\nif (table->fragment_table != NULL) {\r\ng_hash_table_foreach_remove(table->fragment_table,\r\nfree_all_fragments, NULL);\r\ng_hash_table_destroy(table->fragment_table);\r\ntable->fragment_table = NULL;\r\n}\r\nif (table->reassembled_table != NULL) {\r\nGPtrArray *allocated_fragments;\r\nallocated_fragments = g_ptr_array_new();\r\ng_hash_table_foreach_remove(table->reassembled_table,\r\nfree_all_reassembled_fragments, allocated_fragments);\r\ng_ptr_array_foreach(allocated_fragments, free_fragments, NULL);\r\ng_ptr_array_free(allocated_fragments, TRUE);\r\ng_hash_table_destroy(table->reassembled_table);\r\ntable->reassembled_table = NULL;\r\n}\r\n}\r\nstatic fragment_head *\r\nlookup_fd_head(reassembly_table *table, const packet_info *pinfo,\r\nconst guint32 id, const void *data, gpointer *orig_keyp)\r\n{\r\ngpointer key;\r\ngpointer value;\r\nkey = table->temporary_key_func(pinfo, id, data);\r\nif (!g_hash_table_lookup_extended(table->fragment_table, key, orig_keyp,\r\n&value))\r\nvalue = NULL;\r\ntable->free_temporary_key_func(key);\r\nreturn (fragment_head *)value;\r\n}\r\nstatic gpointer\r\ninsert_fd_head(reassembly_table *table, fragment_head *fd_head,\r\nconst packet_info *pinfo, const guint32 id, const void *data)\r\n{\r\ngpointer key;\r\nkey = table->persistent_key_func(pinfo, id, data);\r\ng_hash_table_insert(table->fragment_table, key, fd_head);\r\nreturn key;\r\n}\r\ntvbuff_t *\r\nfragment_delete(reassembly_table *table, const packet_info *pinfo,\r\nconst guint32 id, const void *data)\r\n{\r\nfragment_head *fd_head;\r\nfragment_item *fd;\r\ntvbuff_t *fd_tvb_data=NULL;\r\ngpointer key;\r\nfd_head = lookup_fd_head(table, pinfo, id, data, &key);\r\nif(fd_head==NULL){\r\nreturn NULL;\r\n}\r\nfd_tvb_data=fd_head->tvb_data;\r\nfor(fd=fd_head->next;fd;){\r\nfragment_item *tmp_fd;\r\ntmp_fd=fd->next;\r\nif (fd->tvb_data && !(fd->flags & FD_SUBSET_TVB))\r\ntvb_free(fd->tvb_data);\r\ng_slice_free(fragment_item, fd);\r\nfd=tmp_fd;\r\n}\r\ng_slice_free(fragment_head, fd_head);\r\ng_hash_table_remove(table->fragment_table, key);\r\nreturn fd_tvb_data;\r\n}\r\nfragment_head *\r\nfragment_get(reassembly_table *table, const packet_info *pinfo,\r\nconst guint32 id, const void *data)\r\n{\r\nreturn lookup_fd_head(table, pinfo, id, data, NULL);\r\n}\r\nfragment_head *\r\nfragment_get_reassembled(reassembly_table *table, const guint32 id)\r\n{\r\nfragment_head *fd_head;\r\nreassembled_key key;\r\nkey.frame = id;\r\nkey.id = id;\r\nfd_head = (fragment_head *)g_hash_table_lookup(table->reassembled_table, &key);\r\nreturn fd_head;\r\n}\r\nfragment_head *\r\nfragment_get_reassembled_id(reassembly_table *table, const packet_info *pinfo,\r\nconst guint32 id)\r\n{\r\nfragment_head *fd_head;\r\nreassembled_key key;\r\nkey.frame = pinfo->num;\r\nkey.id = id;\r\nfd_head = (fragment_head *)g_hash_table_lookup(table->reassembled_table, &key);\r\nreturn fd_head;\r\n}\r\nvoid\r\nfragment_add_seq_offset(reassembly_table *table, const packet_info *pinfo, const guint32 id,\r\nconst void *data, const guint32 fragment_offset)\r\n{\r\nfragment_head *fd_head;\r\nfd_head = lookup_fd_head(table, pinfo, id, data, NULL);\r\nif (!fd_head)\r\nreturn;\r\nif ( fd_head->fragment_nr_offset != 0 )\r\nreturn;\r\nfd_head->fragment_nr_offset = fragment_offset;\r\n}\r\nvoid\r\nfragment_set_tot_len(reassembly_table *table, const packet_info *pinfo,\r\nconst guint32 id, const void *data, const guint32 tot_len)\r\n{\r\nfragment_head *fd_head;\r\nfragment_item *fd;\r\nguint32 max_offset = 0;\r\nfd_head = lookup_fd_head(table, pinfo, id, data, NULL);\r\nif (!fd_head)\r\nreturn;\r\nfd = fd_head;\r\nif (fd_head->flags & FD_BLOCKSEQUENCE) {\r\nwhile (fd) {\r\nif (fd->offset > max_offset) {\r\nmax_offset = fd->offset;\r\nif (max_offset > tot_len) {\r\nfd_head->error = "Bad total reassembly block count";\r\nTHROW_MESSAGE(ReassemblyError, fd_head->error);\r\n}\r\n}\r\nfd = fd->next;\r\n}\r\n}\r\nif (fd_head->flags & FD_DEFRAGMENTED) {\r\nif (max_offset != tot_len) {\r\nfd_head->error = "Defragmented complete but total length not satisfied";\r\nTHROW_MESSAGE(ReassemblyError, fd_head->error);\r\n}\r\n}\r\nfd_head->datalen = tot_len;\r\nfd_head->flags |= FD_DATALEN_SET;\r\n}\r\nguint32\r\nfragment_get_tot_len(reassembly_table *table, const packet_info *pinfo,\r\nconst guint32 id, const void *data)\r\n{\r\nfragment_head *fd_head;\r\nfd_head = lookup_fd_head(table, pinfo, id, data, NULL);\r\nif(fd_head){\r\nreturn fd_head->datalen;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nfragment_set_partial_reassembly(reassembly_table *table,\r\nconst packet_info *pinfo, const guint32 id,\r\nconst void *data)\r\n{\r\nfragment_head *fd_head;\r\nfd_head = lookup_fd_head(table, pinfo, id, data, NULL);\r\nif(fd_head){\r\nfd_head->flags |= FD_PARTIAL_REASSEMBLY;\r\n}\r\n}\r\nstatic void\r\nfragment_unhash(reassembly_table *table, gpointer key)\r\n{\r\ng_hash_table_remove(table->fragment_table, key);\r\n}\r\nstatic void\r\nfragment_reassembled(reassembly_table *table, fragment_head *fd_head,\r\nconst packet_info *pinfo, const guint32 id)\r\n{\r\nreassembled_key *new_key;\r\nfragment_item *fd;\r\nif (fd_head->next == NULL) {\r\nnew_key = g_slice_new(reassembled_key);\r\nnew_key->frame = pinfo->num;\r\nnew_key->id = id;\r\ng_hash_table_insert(table->reassembled_table, new_key, fd_head);\r\n} else {\r\nfor (fd = fd_head->next; fd != NULL; fd = fd->next){\r\nnew_key = g_slice_new(reassembled_key);\r\nnew_key->frame = fd->frame;\r\nnew_key->id = id;\r\ng_hash_table_insert(table->reassembled_table, new_key,\r\nfd_head);\r\n}\r\n}\r\nfd_head->flags |= FD_DEFRAGMENTED;\r\nfd_head->reassembled_in = pinfo->num;\r\nfd_head->reas_in_layer_num = pinfo->curr_layer_num;\r\n}\r\nstatic void\r\nLINK_FRAG(fragment_head *fd_head,fragment_item *fd)\r\n{\r\nfragment_item *fd_i;\r\nfor(fd_i= fd_head; fd_i->next;fd_i=fd_i->next) {\r\nif (fd->offset < fd_i->next->offset )\r\nbreak;\r\n}\r\nfd->next=fd_i->next;\r\nfd_i->next=fd;\r\n}\r\nstatic gboolean\r\nfragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,\r\nconst packet_info *pinfo, const guint32 frag_offset,\r\nconst guint32 frag_data_len, const gboolean more_frags)\r\n{\r\nfragment_item *fd;\r\nfragment_item *fd_i;\r\nguint32 max, dfpos, fraglen;\r\ntvbuff_t *old_tvb_data;\r\nguint8 *data;\r\nfd = g_slice_new(fragment_item);\r\nfd->next = NULL;\r\nfd->flags = 0;\r\nfd->frame = pinfo->num;\r\nfd->offset = frag_offset;\r\nfd->fragment_nr_offset = 0;\r\nfd->len = frag_data_len;\r\nfd->tvb_data = NULL;\r\nfd->error = NULL;\r\nif (fd_head->flags & FD_DEFRAGMENTED) {\r\nif (frag_offset + frag_data_len >= fd_head->datalen) {\r\nif (fd_head->flags & FD_PARTIAL_REASSEMBLY) {\r\nfor(fd_i=fd_head->next; fd_i; fd_i=fd_i->next){\r\nif( !fd_i->tvb_data ) {\r\nfd_i->tvb_data = tvb_new_subset_remaining(fd_head->tvb_data, fd_i->offset);\r\nfd_i->flags |= FD_SUBSET_TVB;\r\n}\r\nfd_i->flags &= (~FD_TOOLONGFRAGMENT) & (~FD_MULTIPLETAILS);\r\n}\r\nfd_head->flags &= ~(FD_DEFRAGMENTED|FD_PARTIAL_REASSEMBLY|FD_DATALEN_SET);\r\nfd_head->flags &= (~FD_TOOLONGFRAGMENT) & (~FD_MULTIPLETAILS);\r\nfd_head->datalen=0;\r\nfd_head->reassembled_in=0;\r\nfd_head->reas_in_layer_num = 0;\r\n} else {\r\ng_slice_free(fragment_item, fd);\r\nif (frag_offset >= fd_head->datalen) {\r\nTHROW_MESSAGE(ReassemblyError, "New fragment past old data limits");\r\n} else {\r\nTHROW_MESSAGE(ReassemblyError, "New fragment overlaps old data (retransmission?)");\r\n}\r\n}\r\n} else {\r\ng_slice_free(fragment_item, fd);\r\nTHROW_MESSAGE(ReassemblyError, "New fragment overlaps old data (retransmission?)");\r\n}\r\n}\r\nif (fd->frame > fd_head->frame)\r\nfd_head->frame = fd->frame;\r\nif (!more_frags) {\r\nif (fd_head->flags & FD_DATALEN_SET) {\r\nif (fd_head->datalen != (fd->offset + fd->len) ){\r\nfd->flags |= FD_MULTIPLETAILS;\r\nfd_head->flags |= FD_MULTIPLETAILS;\r\n}\r\n} else {\r\nfd_head->datalen = fd->offset + fd->len;\r\nfd_head->flags |= FD_DATALEN_SET;\r\n}\r\n}\r\nif (fd_head->flags & FD_DEFRAGMENTED) {\r\nguint32 end_offset = fd->offset + fd->len;\r\nfd->flags |= FD_OVERLAP;\r\nfd_head->flags |= FD_OVERLAP;\r\nif (end_offset > fd_head->datalen || end_offset < fd->offset || end_offset < fd->len) {\r\nfd->flags |= FD_TOOLONGFRAGMENT;\r\nfd_head->flags |= FD_TOOLONGFRAGMENT;\r\n}\r\nelse if ( tvb_memeql(fd_head->tvb_data, fd->offset,\r\ntvb_get_ptr(tvb,offset,fd->len),fd->len) ){\r\nfd->flags |= FD_OVERLAPCONFLICT;\r\nfd_head->flags |= FD_OVERLAPCONFLICT;\r\n}\r\nLINK_FRAG(fd_head,fd);\r\nreturn TRUE;\r\n}\r\nif (!tvb_bytes_exist(tvb, offset, fd->len)) {\r\ng_slice_free(fragment_item, fd);\r\nTHROW(BoundsError);\r\n}\r\nfd->tvb_data = tvb_clone_offset_len(tvb, offset, fd->len);\r\nLINK_FRAG(fd_head,fd);\r\nif( !(fd_head->flags & FD_DATALEN_SET) ){\r\nreturn FALSE;\r\n}\r\nmax = 0;\r\nfor (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) {\r\nif ( ((fd_i->offset)<=max) &&\r\n((fd_i->offset+fd_i->len)>max) ){\r\nmax = fd_i->offset+fd_i->len;\r\n}\r\n}\r\nif (max < (fd_head->datalen)) {\r\nreturn FALSE;\r\n}\r\nold_tvb_data=fd_head->tvb_data;\r\ndata = (guint8 *) g_malloc(fd_head->datalen);\r\nfd_head->tvb_data = tvb_new_real_data(data, fd_head->datalen, fd_head->datalen);\r\ntvb_set_free_cb(fd_head->tvb_data, g_free);\r\nfor (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) {\r\nif (fd_i->len) {\r\nif (fd_i->offset + fd_i->len > dfpos) {\r\nif (fd_i->offset >= fd_head->datalen) {\r\nfd_i->flags |= FD_TOOLONGFRAGMENT;\r\nfd_head->flags |= FD_TOOLONGFRAGMENT;\r\n} else if (dfpos < fd_i->offset) {\r\nfd_head->error = "dfpos < offset";\r\n} else if (dfpos - fd_i->offset > fd_i->len)\r\nfd_head->error = "dfpos - offset > len";\r\nelse if (!fd_head->tvb_data)\r\nfd_head->error = "no data";\r\nelse {\r\nfraglen = fd_i->len;\r\nif (fd_i->offset + fraglen > fd_head->datalen) {\r\nfd_i->flags |= FD_TOOLONGFRAGMENT;\r\nfd_head->flags |= FD_TOOLONGFRAGMENT;\r\nfraglen = fd_head->datalen - fd_i->offset;\r\n}\r\nif (fd_i->offset < dfpos) {\r\nguint32 cmp_len = MIN(fd_i->len,(dfpos-fd_i->offset));\r\nfd_i->flags |= FD_OVERLAP;\r\nfd_head->flags |= FD_OVERLAP;\r\nif ( memcmp(data + fd_i->offset,\r\ntvb_get_ptr(fd_i->tvb_data, 0, cmp_len),\r\ncmp_len)\r\n) {\r\nfd_i->flags |= FD_OVERLAPCONFLICT;\r\nfd_head->flags |= FD_OVERLAPCONFLICT;\r\n}\r\n}\r\nif (fraglen < dfpos - fd_i->offset) {\r\nfd_head->error = "fraglen < dfpos - offset";\r\n} else {\r\nmemcpy(data+dfpos,\r\ntvb_get_ptr(fd_i->tvb_data, (dfpos-fd_i->offset), fraglen-(dfpos-fd_i->offset)),\r\nfraglen-(dfpos-fd_i->offset));\r\ndfpos=MAX(dfpos, (fd_i->offset + fraglen));\r\n}\r\n}\r\n} else {\r\nif (fd_i->offset + fd_i->len < fd_i->offset) {\r\nfd_head->error = "offset + len < offset";\r\n}\r\n}\r\nif (fd_i->flags & FD_SUBSET_TVB)\r\nfd_i->flags &= ~FD_SUBSET_TVB;\r\nelse if (fd_i->tvb_data)\r\ntvb_free(fd_i->tvb_data);\r\nfd_i->tvb_data=NULL;\r\n}\r\n}\r\nif (old_tvb_data)\r\ntvb_add_to_chain(tvb, old_tvb_data);\r\nfd_head->flags |= FD_DEFRAGMENTED;\r\nfd_head->reassembled_in=pinfo->num;\r\nfd_head->reas_in_layer_num = pinfo->curr_layer_num;\r\nif (fd_head->error) {\r\nTHROW_MESSAGE(ReassemblyError, fd_head->error);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic fragment_head *\r\nfragment_add_common(reassembly_table *table, tvbuff_t *tvb, const int offset,\r\nconst packet_info *pinfo, const guint32 id,\r\nconst void *data, const guint32 frag_offset,\r\nconst guint32 frag_data_len, const gboolean more_frags,\r\nconst gboolean check_already_added)\r\n{\r\nfragment_head *fd_head;\r\nfragment_item *fd_item;\r\ngboolean already_added;\r\nDISSECTOR_ASSERT(tvb_bytes_exist(tvb, offset, frag_data_len));\r\nfd_head = lookup_fd_head(table, pinfo, id, data, NULL);\r\n#if 0\r\nif(strcmp(pinfo->current_proto, "DCERPC") == 0) {\r\nprintf("proto:%s num:%u id:%u offset:%u len:%u more:%u visited:%u\n",\r\npinfo->current_proto, pinfo->num, id, frag_offset, frag_data_len, more_frags, pinfo->fd->flags.visited);\r\nif(fd_head != NULL) {\r\nfor(fd_item=fd_head->next;fd_item;fd_item=fd_item->next){\r\nprintf("fd_frame:%u fd_offset:%u len:%u datalen:%u\n",\r\nfd_item->frame, fd_item->offset, fd_item->len, fd_item->datalen);\r\n}\r\n}\r\n}\r\n#endif\r\nif (!pinfo->fd->flags.visited) {\r\nif (check_already_added && fd_head != NULL) {\r\nif (pinfo->num <= fd_head->frame) {\r\nalready_added = FALSE;\r\nfor (fd_item = fd_head->next; fd_item;\r\nfd_item = fd_item->next) {\r\nif (pinfo->num == fd_item->frame &&\r\nfrag_offset == fd_item->offset) {\r\nalready_added = TRUE;\r\nbreak;\r\n}\r\n}\r\nif (already_added) {\r\nif (fd_head->flags & FD_DEFRAGMENTED) {\r\nTHROW_MESSAGE(ReassemblyError,\r\n"Frame already added in first pass");\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\n}\r\n}\r\n} else {\r\nif (fd_head != NULL && fd_head->flags & FD_DEFRAGMENTED) {\r\nif (fd_head->error)\r\nTHROW_MESSAGE(ReassemblyError, fd_head->error);\r\nif (pinfo->num > fd_head->frame) {\r\nTHROW_MESSAGE(ReassemblyError, "New fragment overlaps old data (retransmission?)");\r\n}\r\nif (frag_offset + frag_data_len > fd_head->datalen) {\r\nif (frag_offset >= fd_head->datalen) {\r\nTHROW_MESSAGE(ReassemblyError, "New fragment past old data limits");\r\n} else {\r\nTHROW_MESSAGE(ReassemblyError, "New fragment overlaps old data (retransmission?)");\r\n}\r\n}\r\nreturn fd_head;\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nif (fd_head==NULL){\r\nfd_head = new_head(0);\r\ninsert_fd_head(table, fd_head, pinfo, id, data);\r\n}\r\nif (fragment_add_work(fd_head, tvb, offset, pinfo, frag_offset,\r\nfrag_data_len, more_frags)) {\r\nreturn fd_head;\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nfragment_head *\r\nfragment_add(reassembly_table *table, tvbuff_t *tvb, const int offset,\r\nconst packet_info *pinfo, const guint32 id, const void *data,\r\nconst guint32 frag_offset, const guint32 frag_data_len,\r\nconst gboolean more_frags)\r\n{\r\nreturn fragment_add_common(table, tvb, offset, pinfo, id, data,\r\nfrag_offset, frag_data_len, more_frags, TRUE);\r\n}\r\nfragment_head *\r\nfragment_add_multiple_ok(reassembly_table *table, tvbuff_t *tvb,\r\nconst int offset, const packet_info *pinfo,\r\nconst guint32 id, const void *data,\r\nconst guint32 frag_offset,\r\nconst guint32 frag_data_len, const gboolean more_frags)\r\n{\r\nreturn fragment_add_common(table, tvb, offset, pinfo, id, data,\r\nfrag_offset, frag_data_len, more_frags, FALSE);\r\n}\r\nfragment_head *\r\nfragment_add_check(reassembly_table *table, tvbuff_t *tvb, const int offset,\r\nconst packet_info *pinfo, const guint32 id,\r\nconst void *data, const guint32 frag_offset,\r\nconst guint32 frag_data_len, const gboolean more_frags)\r\n{\r\nreassembled_key reass_key;\r\nfragment_head *fd_head;\r\ngpointer orig_key;\r\nif (pinfo->fd->flags.visited) {\r\nreass_key.frame = pinfo->num;\r\nreass_key.id = id;\r\nreturn (fragment_head *)g_hash_table_lookup(table->reassembled_table, &reass_key);\r\n}\r\nfd_head = lookup_fd_head(table, pinfo, id, data, &orig_key);\r\nif (fd_head == NULL) {\r\nfd_head = new_head(0);\r\norig_key = insert_fd_head(table, fd_head, pinfo, id, data);\r\n}\r\nif (tvb_reported_length(tvb) > tvb_captured_length(tvb))\r\nreturn NULL;\r\nif (fragment_add_work(fd_head, tvb, offset, pinfo, frag_offset,\r\nfrag_data_len, more_frags)) {\r\nfragment_unhash(table, orig_key);\r\nfragment_reassembled(table, fd_head, pinfo, id);\r\nreturn fd_head;\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nstatic void\r\nfragment_defragment_and_free (fragment_head *fd_head, const packet_info *pinfo)\r\n{\r\nfragment_item *fd_i = NULL;\r\nfragment_item *last_fd = NULL;\r\nguint32 dfpos = 0, size = 0;\r\ntvbuff_t *old_tvb_data = NULL;\r\nguint8 *data;\r\nfor(fd_i=fd_head->next;fd_i;fd_i=fd_i->next) {\r\nif(!last_fd || last_fd->offset!=fd_i->offset){\r\nsize+=fd_i->len;\r\n}\r\nlast_fd=fd_i;\r\n}\r\nold_tvb_data=fd_head->tvb_data;\r\ndata = (guint8 *) g_malloc(size);\r\nfd_head->tvb_data = tvb_new_real_data(data, size, size);\r\ntvb_set_free_cb(fd_head->tvb_data, g_free);\r\nfd_head->len = size;\r\nlast_fd=NULL;\r\nfor (fd_i=fd_head->next; fd_i; fd_i=fd_i->next) {\r\nif (fd_i->len) {\r\nif(!last_fd || last_fd->offset != fd_i->offset) {\r\nmemcpy(data+dfpos, tvb_get_ptr(fd_i->tvb_data, 0, fd_i->len), fd_i->len);\r\ndfpos += fd_i->len;\r\n} else {\r\nfd_i->flags |= FD_OVERLAP;\r\nfd_head->flags |= FD_OVERLAP;\r\nif(last_fd->len != fd_i->len\r\n|| tvb_memeql(last_fd->tvb_data, 0, tvb_get_ptr(fd_i->tvb_data, 0, last_fd->len), last_fd->len) ) {\r\nfd_i->flags |= FD_OVERLAPCONFLICT;\r\nfd_head->flags |= FD_OVERLAPCONFLICT;\r\n}\r\n}\r\n}\r\nlast_fd=fd_i;\r\n}\r\nfor (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) {\r\nif (fd_i->flags & FD_SUBSET_TVB)\r\nfd_i->flags &= ~FD_SUBSET_TVB;\r\nelse if (fd_i->tvb_data)\r\ntvb_free(fd_i->tvb_data);\r\nfd_i->tvb_data=NULL;\r\n}\r\nif (old_tvb_data)\r\ntvb_free(old_tvb_data);\r\nfd_head->flags |= FD_DEFRAGMENTED;\r\nfd_head->reassembled_in=pinfo->num;\r\nfd_head->reas_in_layer_num = pinfo->curr_layer_num;\r\n}\r\nstatic gboolean\r\nfragment_add_seq_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,\r\nconst packet_info *pinfo, const guint32 frag_number,\r\nconst guint32 frag_data_len, const gboolean more_frags)\r\n{\r\nfragment_item *fd;\r\nfragment_item *fd_i;\r\nfragment_item *last_fd;\r\nguint32 max, dfpos;\r\nguint32 frag_number_work;\r\nfrag_number_work = frag_number;\r\nif ( fd_head->fragment_nr_offset != 0 )\r\nif ( frag_number_work >= fd_head->fragment_nr_offset )\r\nfrag_number_work = frag_number - fd_head->fragment_nr_offset;\r\nif(fd_head->flags & FD_DEFRAGMENTED && frag_number_work >= fd_head->datalen &&\r\nfd_head->flags & FD_PARTIAL_REASSEMBLY){\r\nguint32 lastdfpos = 0;\r\ndfpos = 0;\r\nfor(fd_i=fd_head->next; fd_i; fd_i=fd_i->next){\r\nif( !fd_i->tvb_data ) {\r\nif( fd_i->flags & FD_OVERLAP ) {\r\nfd_i->tvb_data = tvb_new_subset_remaining(fd_head->tvb_data, lastdfpos);\r\n} else {\r\nfd_i->tvb_data = tvb_new_subset_remaining(fd_head->tvb_data, dfpos);\r\nlastdfpos = dfpos;\r\ndfpos += fd_i->len;\r\n}\r\nfd_i->flags |= FD_SUBSET_TVB;\r\n}\r\nfd_i->flags &= (~FD_TOOLONGFRAGMENT) & (~FD_MULTIPLETAILS);\r\n}\r\nfd_head->flags &= ~(FD_DEFRAGMENTED|FD_PARTIAL_REASSEMBLY|FD_DATALEN_SET);\r\nfd_head->flags &= (~FD_TOOLONGFRAGMENT) & (~FD_MULTIPLETAILS);\r\nfd_head->datalen=0;\r\nfd_head->reassembled_in=0;\r\nfd_head->reas_in_layer_num = 0;\r\n}\r\nfd = g_slice_new(fragment_item);\r\nfd->next = NULL;\r\nfd->flags = 0;\r\nfd->frame = pinfo->num;\r\nfd->offset = frag_number_work;\r\nfd->len = frag_data_len;\r\nfd->tvb_data = NULL;\r\nfd->error = NULL;\r\nif (!more_frags) {\r\nif (fd_head->flags&FD_DATALEN_SET) {\r\nif (fd_head->datalen != fd->offset ){\r\nfd->flags |= FD_MULTIPLETAILS;\r\nfd_head->flags |= FD_MULTIPLETAILS;\r\n}\r\n} else {\r\nfd_head->datalen = fd->offset;\r\nfd_head->flags |= FD_DATALEN_SET;\r\n}\r\n}\r\nif (fd_head->flags & FD_DEFRAGMENTED) {\r\nfd->flags |= FD_OVERLAP;\r\nfd_head->flags |= FD_OVERLAP;\r\nif (fd->offset > fd_head->datalen) {\r\nfd->flags |= FD_TOOLONGFRAGMENT;\r\nfd_head->flags |= FD_TOOLONGFRAGMENT;\r\nLINK_FRAG(fd_head,fd);\r\nreturn TRUE;\r\n}\r\ndfpos=0;\r\nlast_fd=NULL;\r\nfor (fd_i=fd_head->next;fd_i && (fd_i->offset!=fd->offset);fd_i=fd_i->next) {\r\nif (!last_fd || last_fd->offset!=fd_i->offset){\r\ndfpos += fd_i->len;\r\n}\r\nlast_fd=fd_i;\r\n}\r\nif(fd_i){\r\nif(fd_i->len!=fd->len){\r\nfd->flags |= FD_OVERLAPCONFLICT;\r\nfd_head->flags |= FD_OVERLAPCONFLICT;\r\nLINK_FRAG(fd_head,fd);\r\nreturn TRUE;\r\n}\r\nDISSECTOR_ASSERT(fd_head->len >= dfpos + fd->len);\r\nif (tvb_memeql(fd_head->tvb_data, dfpos,\r\ntvb_get_ptr(tvb,offset,fd->len),fd->len) ){\r\nfd->flags |= FD_OVERLAPCONFLICT;\r\nfd_head->flags |= FD_OVERLAPCONFLICT;\r\nLINK_FRAG(fd_head,fd);\r\nreturn TRUE;\r\n}\r\nLINK_FRAG(fd_head,fd);\r\nreturn TRUE;\r\n} else {\r\nLINK_FRAG(fd_head,fd);\r\nreturn TRUE;\r\n}\r\n}\r\nif (fd->len) {\r\nif (!tvb_bytes_exist(tvb, offset, fd->len)) {\r\ng_slice_free(fragment_item, fd);\r\nreturn FALSE;\r\n}\r\nfd->tvb_data = tvb_clone_offset_len(tvb, offset, fd->len);\r\n}\r\nLINK_FRAG(fd_head,fd);\r\nif( !(fd_head->flags & FD_DATALEN_SET) ){\r\nreturn FALSE;\r\n}\r\nmax = 0;\r\nfor(fd_i=fd_head->next;fd_i;fd_i=fd_i->next) {\r\nif ( fd_i->offset==max ){\r\nmax++;\r\n}\r\n}\r\nif (max <= fd_head->datalen) {\r\nreturn FALSE;\r\n}\r\nif (max > (fd_head->datalen+1)) {\r\nfd->flags |= FD_TOOLONGFRAGMENT;\r\nfd_head->flags |= FD_TOOLONGFRAGMENT;\r\n}\r\nfragment_defragment_and_free(fd_head, pinfo);\r\nreturn TRUE;\r\n}\r\nstatic fragment_head *\r\nfragment_add_seq_common(reassembly_table *table, tvbuff_t *tvb,\r\nconst int offset, const packet_info *pinfo,\r\nconst guint32 id, const void *data,\r\nguint32 frag_number, const guint32 frag_data_len,\r\nconst gboolean more_frags, const guint32 flags,\r\ngpointer *orig_keyp)\r\n{\r\nfragment_head *fd_head;\r\ngpointer orig_key;\r\nfd_head = lookup_fd_head(table, pinfo, id, data, &orig_key);\r\nif (pinfo->fd->flags.visited) {\r\nif (fd_head != NULL && fd_head->flags & FD_DEFRAGMENTED) {\r\nif (orig_keyp != NULL)\r\n*orig_keyp = orig_key;\r\nreturn fd_head;\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nif (fd_head==NULL){\r\nfd_head= new_head(FD_BLOCKSEQUENCE);\r\nif((flags & (REASSEMBLE_FLAGS_NO_FRAG_NUMBER|REASSEMBLE_FLAGS_802_11_HACK))\r\n&& !more_frags) {\r\nif (orig_keyp != NULL)\r\n*orig_keyp = NULL;\r\nfd_head->reassembled_in=pinfo->num;\r\nfd_head->reas_in_layer_num = pinfo->curr_layer_num;\r\nreturn fd_head;\r\n}\r\norig_key = insert_fd_head(table, fd_head, pinfo, id, data);\r\nif (orig_keyp != NULL)\r\n*orig_keyp = orig_key;\r\nif (flags & REASSEMBLE_FLAGS_NO_FRAG_NUMBER)\r\nfrag_number = 0;\r\n} else {\r\nif (orig_keyp != NULL)\r\n*orig_keyp = orig_key;\r\nif (flags & REASSEMBLE_FLAGS_NO_FRAG_NUMBER) {\r\nfragment_item *fd;\r\nfor (fd = fd_head; fd != NULL; fd = fd->next) {\r\nif (fd->next == NULL)\r\nfrag_number = fd->offset + 1;\r\n}\r\n}\r\n}\r\nif (fragment_add_seq_work(fd_head, tvb, offset, pinfo,\r\nfrag_number, frag_data_len, more_frags)) {\r\nreturn fd_head;\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nfragment_head *\r\nfragment_add_seq(reassembly_table *table, tvbuff_t *tvb, const int offset,\r\nconst packet_info *pinfo, const guint32 id, const void *data,\r\nconst guint32 frag_number, const guint32 frag_data_len,\r\nconst gboolean more_frags, const guint32 flags)\r\n{\r\nreturn fragment_add_seq_common(table, tvb, offset, pinfo, id, data,\r\nfrag_number, frag_data_len,\r\nmore_frags, flags, NULL);\r\n}\r\nstatic fragment_head *\r\nfragment_add_seq_check_work(reassembly_table *table, tvbuff_t *tvb,\r\nconst int offset, const packet_info *pinfo,\r\nconst guint32 id, const void *data,\r\nconst guint32 frag_number,\r\nconst guint32 frag_data_len,\r\nconst gboolean more_frags, const guint32 flags)\r\n{\r\nreassembled_key reass_key;\r\nfragment_head *fd_head;\r\ngpointer orig_key;\r\nif (pinfo->fd->flags.visited) {\r\nreass_key.frame = pinfo->num;\r\nreass_key.id = id;\r\nreturn (fragment_head *)g_hash_table_lookup(table->reassembled_table, &reass_key);\r\n}\r\nfd_head = fragment_add_seq_common(table, tvb, offset, pinfo, id, data,\r\nfrag_number, frag_data_len,\r\nmore_frags,\r\nflags,\r\n&orig_key);\r\nif (fd_head) {\r\nif (orig_key != NULL)\r\nfragment_unhash(table, orig_key);\r\nfragment_reassembled(table, fd_head, pinfo, id);\r\nreturn fd_head;\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nfragment_head *\r\nfragment_add_seq_check(reassembly_table *table, tvbuff_t *tvb, const int offset,\r\nconst packet_info *pinfo, const guint32 id,\r\nconst void *data,\r\nconst guint32 frag_number, const guint32 frag_data_len,\r\nconst gboolean more_frags)\r\n{\r\nreturn fragment_add_seq_check_work(table, tvb, offset, pinfo, id, data,\r\nfrag_number, frag_data_len,\r\nmore_frags, 0);\r\n}\r\nfragment_head *\r\nfragment_add_seq_802_11(reassembly_table *table, tvbuff_t *tvb,\r\nconst int offset, const packet_info *pinfo,\r\nconst guint32 id, const void *data,\r\nconst guint32 frag_number, const guint32 frag_data_len,\r\nconst gboolean more_frags)\r\n{\r\nreturn fragment_add_seq_check_work(table, tvb, offset, pinfo, id, data,\r\nfrag_number, frag_data_len,\r\nmore_frags,\r\nREASSEMBLE_FLAGS_802_11_HACK);\r\n}\r\nfragment_head *\r\nfragment_add_seq_next(reassembly_table *table, tvbuff_t *tvb, const int offset,\r\nconst packet_info *pinfo, const guint32 id,\r\nconst void *data, const guint32 frag_data_len,\r\nconst gboolean more_frags)\r\n{\r\nreturn fragment_add_seq_check_work(table, tvb, offset, pinfo, id, data,\r\n0, frag_data_len, more_frags,\r\nREASSEMBLE_FLAGS_NO_FRAG_NUMBER);\r\n}\r\nvoid\r\nfragment_start_seq_check(reassembly_table *table, const packet_info *pinfo,\r\nconst guint32 id, const void *data,\r\nconst guint32 tot_len)\r\n{\r\nfragment_head *fd_head;\r\nif (pinfo->fd->flags.visited) {\r\nreturn;\r\n}\r\nfd_head = lookup_fd_head(table, pinfo, id, data, NULL);\r\nif (fd_head == NULL) {\r\nfd_head = g_slice_new(fragment_head);\r\nfd_head->next = NULL;\r\nfd_head->datalen = tot_len;\r\nfd_head->offset = 0;\r\nfd_head->fragment_nr_offset = 0;\r\nfd_head->len = 0;\r\nfd_head->flags = FD_BLOCKSEQUENCE|FD_DATALEN_SET;\r\nfd_head->tvb_data = NULL;\r\nfd_head->reassembled_in = 0;\r\nfd_head->reas_in_layer_num = 0;\r\nfd_head->error = NULL;\r\ninsert_fd_head(table, fd_head, pinfo, id, data);\r\n}\r\n}\r\nfragment_head *\r\nfragment_end_seq_next(reassembly_table *table, const packet_info *pinfo,\r\nconst guint32 id, const void *data)\r\n{\r\nreassembled_key reass_key;\r\nreassembled_key *new_key;\r\nfragment_head *fd_head;\r\ngpointer orig_key;\r\nif (pinfo->fd->flags.visited) {\r\nreass_key.frame = pinfo->num;\r\nreass_key.id = id;\r\nreturn (fragment_head *)g_hash_table_lookup(table->reassembled_table, &reass_key);\r\n}\r\nfd_head = lookup_fd_head(table, pinfo, id, data, &orig_key);\r\nif (fd_head) {\r\nfd_head->datalen = fd_head->offset;\r\nfd_head->flags |= FD_DATALEN_SET;\r\nfragment_defragment_and_free (fd_head, pinfo);\r\nfragment_unhash(table, orig_key);\r\nfragment_reassembled(table, fd_head, pinfo, id);\r\nif (fd_head->next != NULL) {\r\nnew_key = g_slice_new(reassembled_key);\r\nnew_key->frame = pinfo->num;\r\nnew_key->id = id;\r\ng_hash_table_insert(table->reassembled_table, new_key, fd_head);\r\n}\r\nreturn fd_head;\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\ntvbuff_t *\r\nprocess_reassembled_data(tvbuff_t *tvb, const int offset, packet_info *pinfo,\r\nconst char *name, fragment_head *fd_head, const fragment_items *fit,\r\ngboolean *update_col_infop, proto_tree *tree)\r\n{\r\ntvbuff_t *next_tvb;\r\ngboolean update_col_info;\r\nproto_item *frag_tree_item;\r\nif (fd_head != NULL && pinfo->num == fd_head->reassembled_in && pinfo->curr_layer_num == fd_head->reas_in_layer_num) {\r\nif (fd_head->next != NULL) {\r\nnext_tvb = tvb_new_chain(tvb, fd_head->tvb_data);\r\nadd_new_data_source(pinfo, next_tvb, name);\r\nif (fd_head->flags & FD_BLOCKSEQUENCE) {\r\nupdate_col_info = !show_fragment_seq_tree(\r\nfd_head, fit, tree, pinfo, next_tvb, &frag_tree_item);\r\n} else {\r\nupdate_col_info = !show_fragment_tree(fd_head,\r\nfit, tree, pinfo, next_tvb, &frag_tree_item);\r\n}\r\n} else {\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\npinfo->fragmented = FALSE;\r\nupdate_col_info = TRUE;\r\n}\r\nif (update_col_infop != NULL)\r\n*update_col_infop = update_col_info;\r\n} else {\r\nnext_tvb = NULL;\r\nif (fd_head != NULL && fit->hf_reassembled_in != NULL) {\r\nproto_tree_add_uint(tree,\r\n*(fit->hf_reassembled_in), tvb,\r\n0, 0, fd_head->reassembled_in);\r\n}\r\n}\r\nreturn next_tvb;\r\n}\r\nstatic void\r\nshow_fragment(fragment_item *fd, const int offset, const fragment_items *fit,\r\nproto_tree *ft, proto_item *fi, const gboolean first_frag,\r\nconst guint32 count, tvbuff_t *tvb, packet_info *pinfo)\r\n{\r\nproto_item *fei=NULL;\r\nint hf;\r\nif (first_frag) {\r\ngchar *name;\r\nif (count == 1) {\r\nname = g_strdup(proto_registrar_get_name(*(fit->hf_fragment)));\r\n} else {\r\nname = g_strdup(proto_registrar_get_name(*(fit->hf_fragments)));\r\n}\r\nproto_item_set_text(fi, "%u %s (%u byte%s): ", count, name, tvb_captured_length(tvb),\r\nplurality(tvb_captured_length(tvb), "", "s"));\r\ng_free(name);\r\n} else {\r\nproto_item_append_text(fi, ", ");\r\n}\r\nproto_item_append_text(fi, "#%u(%u)", fd->frame, fd->len);\r\nif (fd->flags & (FD_OVERLAPCONFLICT\r\n|FD_MULTIPLETAILS|FD_TOOLONGFRAGMENT) ) {\r\nhf = *(fit->hf_fragment_error);\r\n} else {\r\nhf = *(fit->hf_fragment);\r\n}\r\nif (fd->len == 0) {\r\nfei = proto_tree_add_uint_format(ft, hf,\r\ntvb, offset, fd->len,\r\nfd->frame,\r\n"Frame: %u (no data)",\r\nfd->frame);\r\n} else {\r\nfei = proto_tree_add_uint_format(ft, hf,\r\ntvb, offset, fd->len,\r\nfd->frame,\r\n"Frame: %u, payload: %u-%u (%u byte%s)",\r\nfd->frame,\r\noffset,\r\noffset+fd->len-1,\r\nfd->len,\r\nplurality(fd->len, "", "s"));\r\n}\r\nPROTO_ITEM_SET_GENERATED(fei);\r\nmark_frame_as_depended_upon(pinfo, fd->frame);\r\nif (fd->flags & (FD_OVERLAP|FD_OVERLAPCONFLICT\r\n|FD_MULTIPLETAILS|FD_TOOLONGFRAGMENT) ) {\r\nproto_tree *fet=NULL;\r\nfet = proto_item_add_subtree(fei, *(fit->ett_fragment));\r\nif (fd->flags&FD_OVERLAP) {\r\nfei=proto_tree_add_boolean(fet,\r\n*(fit->hf_fragment_overlap),\r\ntvb, 0, 0,\r\nTRUE);\r\nPROTO_ITEM_SET_GENERATED(fei);\r\n}\r\nif (fd->flags&FD_OVERLAPCONFLICT) {\r\nfei=proto_tree_add_boolean(fet,\r\n*(fit->hf_fragment_overlap_conflict),\r\ntvb, 0, 0,\r\nTRUE);\r\nPROTO_ITEM_SET_GENERATED(fei);\r\n}\r\nif (fd->flags&FD_MULTIPLETAILS) {\r\nfei=proto_tree_add_boolean(fet,\r\n*(fit->hf_fragment_multiple_tails),\r\ntvb, 0, 0,\r\nTRUE);\r\nPROTO_ITEM_SET_GENERATED(fei);\r\n}\r\nif (fd->flags&FD_TOOLONGFRAGMENT) {\r\nfei=proto_tree_add_boolean(fet,\r\n*(fit->hf_fragment_too_long_fragment),\r\ntvb, 0, 0,\r\nTRUE);\r\nPROTO_ITEM_SET_GENERATED(fei);\r\n}\r\n}\r\n}\r\nstatic gboolean\r\nshow_fragment_errs_in_col(fragment_head *fd_head, const fragment_items *fit,\r\npacket_info *pinfo)\r\n{\r\nif (fd_head->flags & (FD_OVERLAPCONFLICT\r\n|FD_MULTIPLETAILS|FD_TOOLONGFRAGMENT) ) {\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "[Illegal %s]", fit->tag);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\ngboolean\r\nshow_fragment_tree(fragment_head *fd_head, const fragment_items *fit,\r\nproto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, proto_item **fi)\r\n{\r\nfragment_item *fd;\r\nproto_tree *ft;\r\ngboolean first_frag;\r\nguint32 count = 0;\r\npinfo->fragmented = FALSE;\r\n*fi = proto_tree_add_item(tree, *(fit->hf_fragments), tvb, 0, -1, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(*fi);\r\nft = proto_item_add_subtree(*fi, *(fit->ett_fragments));\r\nfirst_frag = TRUE;\r\nfor (fd = fd_head->next; fd != NULL; fd = fd->next) {\r\ncount++;\r\n}\r\nfor (fd = fd_head->next; fd != NULL; fd = fd->next) {\r\nshow_fragment(fd, fd->offset, fit, ft, *fi, first_frag, count, tvb, pinfo);\r\nfirst_frag = FALSE;\r\n}\r\nif (fit->hf_fragment_count) {\r\nproto_item *fli = proto_tree_add_uint(ft, *(fit->hf_fragment_count),\r\ntvb, 0, 0, count);\r\nPROTO_ITEM_SET_GENERATED(fli);\r\n}\r\nif (fit->hf_reassembled_length) {\r\nproto_item *fli = proto_tree_add_uint(ft, *(fit->hf_reassembled_length),\r\ntvb, 0, 0, tvb_captured_length (tvb));\r\nPROTO_ITEM_SET_GENERATED(fli);\r\n}\r\nif (fit->hf_reassembled_data) {\r\nproto_item *fli = proto_tree_add_item(ft, *(fit->hf_reassembled_data),\r\ntvb, 0, tvb_captured_length(tvb), ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(fli);\r\n}\r\nreturn show_fragment_errs_in_col(fd_head, fit, pinfo);\r\n}\r\ngboolean\r\nshow_fragment_seq_tree(fragment_head *fd_head, const fragment_items *fit,\r\nproto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, proto_item **fi)\r\n{\r\nguint32 offset, next_offset, count = 0;\r\nfragment_item *fd, *last_fd;\r\nproto_tree *ft;\r\ngboolean first_frag;\r\npinfo->fragmented = FALSE;\r\n*fi = proto_tree_add_item(tree, *(fit->hf_fragments), tvb, 0, -1, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(*fi);\r\nft = proto_item_add_subtree(*fi, *(fit->ett_fragments));\r\noffset = 0;\r\nnext_offset = 0;\r\nlast_fd = NULL;\r\nfirst_frag = TRUE;\r\nfor (fd = fd_head->next; fd != NULL; fd = fd->next){\r\ncount++;\r\n}\r\nfor (fd = fd_head->next; fd != NULL; fd = fd->next){\r\nif (last_fd == NULL || last_fd->offset != fd->offset) {\r\noffset = next_offset;\r\nnext_offset += fd->len;\r\n}\r\nlast_fd = fd;\r\nshow_fragment(fd, offset, fit, ft, *fi, first_frag, count, tvb, pinfo);\r\nfirst_frag = FALSE;\r\n}\r\nif (fit->hf_fragment_count) {\r\nproto_item *fli = proto_tree_add_uint(ft, *(fit->hf_fragment_count),\r\ntvb, 0, 0, count);\r\nPROTO_ITEM_SET_GENERATED(fli);\r\n}\r\nif (fit->hf_reassembled_length) {\r\nproto_item *fli = proto_tree_add_uint(ft, *(fit->hf_reassembled_length),\r\ntvb, 0, 0, tvb_captured_length (tvb));\r\nPROTO_ITEM_SET_GENERATED(fli);\r\n}\r\nif (fit->hf_reassembled_data) {\r\nproto_item *fli = proto_tree_add_item(ft, *(fit->hf_reassembled_data),\r\ntvb, 0, tvb_captured_length(tvb), ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(fli);\r\n}\r\nreturn show_fragment_errs_in_col(fd_head, fit, pinfo);\r\n}
