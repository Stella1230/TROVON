static int\r\ndissect_udt(tvbuff_t *tvb, packet_info* pinfo, proto_tree *parent_tree,\r\nvoid *data _U_)\r\n{\r\nproto_tree *tree;\r\nproto_item *udt_item;\r\nint is_control, type;\r\nguint i;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "UDT");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nis_control = tvb_get_ntohl(tvb, 0) & 0x80000000;\r\ntype = (tvb_get_ntohl(tvb, 0) >> 16) & 0x7fff;\r\nif (is_control)\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "UDT type: %s id: %x",\r\nval_to_str(type, udt_packet_types,\r\n"Unknown Control Type (%x)"),\r\ntvb_get_ntohl(tvb, 12));\r\nelse\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"UDT type: data seqno: %u msgno: %u id: %x",\r\ntvb_get_ntohl(tvb, 0) & 0x7fffffff,\r\ntvb_get_ntohl(tvb, 4) & 0x1fffffff,\r\ntvb_get_ntohl(tvb, 12));\r\nudt_item = proto_tree_add_item(parent_tree, proto_udt, tvb,\r\n0, -1, ENC_NA);\r\ntree = proto_item_add_subtree(udt_item, ett_udt);\r\nproto_tree_add_item(tree, hf_udt_iscontrol, tvb, 0, 4, ENC_BIG_ENDIAN);\r\nif (is_control) {\r\nif (tree) {\r\nproto_tree_add_item(tree, hf_udt_type, tvb, 0, 2,\r\nENC_BIG_ENDIAN);\r\nswitch (type) {\r\ncase UDT_PACKET_TYPE_ACK:\r\nproto_tree_add_item(tree, hf_udt_ackno, tvb, 4, 4,\r\nENC_BIG_ENDIAN);\r\nbreak;\r\ncase UDT_PACKET_TYPE_ACK2:\r\nproto_tree_add_item(tree, hf_udt_ackno, tvb, 4, 4,\r\nENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tree, hf_udt_addinfo, tvb, 4, 4,\r\nENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(tree, hf_udt_timestamp, tvb, 8, 4,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_id, tvb, 12, 4,\r\nENC_BIG_ENDIAN);\r\n}\r\nswitch (type) {\r\ncase UDT_PACKET_TYPE_HANDSHAKE:\r\nif (tree) {\r\nproto_tree_add_item(tree, hf_udt_handshake_version, tvb,\r\n16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_handshake_type, tvb,\r\n20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_handshake_isn, tvb,\r\n24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_handshake_mtu, tvb,\r\n28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_handshake_flow_window, tvb,\r\n32, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_handshake_reqtype, tvb,\r\n36, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_handshake_id, tvb,\r\n40, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_handshake_cookie, tvb,\r\n44, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_handshake_peerip, tvb,\r\n48, 16, ENC_NA);\r\nproto_item_set_len(udt_item, 64);\r\n}\r\nbreak;\r\ncase UDT_PACKET_TYPE_ACK:\r\nif (tree) {\r\nproto_tree_add_item(tree, hf_udt_ack_seqno, tvb, 16, 4,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_rtt, tvb, 20, 4,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_rttvar, tvb, 24, 4,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_bufavail, tvb, 28, 4,\r\nENC_BIG_ENDIAN);\r\nif (tvb_reported_length(tvb) == 40) {\r\nproto_tree_add_item(tree, hf_udt_rate, tvb,\r\n32, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_linkcap, tvb,\r\n36, 4, ENC_BIG_ENDIAN);\r\nproto_item_set_len(udt_item, 40);\r\n}\r\nelse\r\n{\r\nproto_item_set_len(udt_item, 32);\r\n}\r\n}\r\nbreak;\r\ncase UDT_PACKET_TYPE_NAK:\r\nfor (i = 16; i < tvb_reported_length(tvb); i = i + 4) {\r\nguint32 start, finish;\r\nint is_range;\r\nis_range = tvb_get_ntohl(tvb, i) & 0x80000000;\r\nstart = tvb_get_ntohl(tvb, i) & 0x7fffffff;\r\nif (is_range) {\r\nfinish = tvb_get_ntohl(tvb, i + 4) & 0x7fffffff;\r\nproto_tree_add_expert_format(tree, pinfo, &ei_udt_nak_seqno,\r\ntvb, i, 8, "Missing Sequence Number(s): %u-%u",\r\nstart, finish);\r\ni = i + 4;\r\n} else {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_udt_nak_seqno,\r\ntvb, i, 4, "Missing Sequence Number: %u",\r\nstart);\r\n}\r\n}\r\nproto_item_set_len(udt_item, tvb_reported_length(tvb));\r\nbreak;\r\n}\r\n} else {\r\ntvbuff_t *next_tvb;\r\nif (tree) {\r\nproto_tree_add_item(tree, hf_udt_seqno, tvb, 0, 4,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_msgno_first, tvb, 4, 4,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_msgno_last, tvb, 4, 4,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_msgno_inorder, tvb, 4, 4,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_msgno, tvb, 4, 4,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_timestamp, tvb, 8, 4,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_udt_id, tvb, 12, 4,\r\nENC_BIG_ENDIAN);\r\n}\r\nnext_tvb = tvb_new_subset_remaining(tvb, 16);\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic gboolean\r\ndissect_udt_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nconversation_t *conv;\r\nif (tvb_captured_length(tvb) < 24)\r\nreturn FALSE;\r\nif (tvb_get_ntohl(tvb, 0) != (0x80000000 | UDT_PACKET_TYPE_HANDSHAKE))\r\nreturn FALSE;\r\nif ((tvb_get_ntohl(tvb, 16) != 4))\r\nreturn FALSE;\r\nif ((tvb_get_ntohl(tvb, 20) != UDT_HANDSHAKE_TYPE_DGRAM)\r\n&& (tvb_get_ntohl(tvb, 20) != UDT_HANDSHAKE_TYPE_STREAM))\r\nreturn FALSE;\r\nconv = find_or_create_conversation(pinfo);\r\nconversation_set_dissector(conv, udt_handle);\r\ndissect_udt(tvb, pinfo, tree, data);\r\nreturn TRUE;\r\n}\r\nvoid proto_register_udt(void)\r\n{\r\nexpert_module_t *expert_udt;\r\nstatic hf_register_info hf[] = {\r\n{&hf_udt_iscontrol, {\r\n"Type", "udt.iscontrol",\r\nFT_UINT32, BASE_DEC,\r\nVALS(udt_types), 0x80000000, NULL, HFILL}},\r\n{&hf_udt_type, {\r\n"Type", "udt.type",\r\nFT_UINT16, BASE_HEX,\r\nVALS(udt_packet_types), 0x7fff, NULL, HFILL}},\r\n{&hf_udt_seqno, {\r\n"Sequence Number", "udt.seqno",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0x7fffffff, NULL, HFILL}},\r\n{&hf_udt_addinfo, {\r\n"Additional Info", "udt.addinfo",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_msgno, {\r\n"Message Number", "udt.msgno",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0x1fffffff, NULL, HFILL}},\r\n{&hf_udt_msgno_first, {\r\n"First Indicator", "udt.msg.first",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0x80000000, NULL, HFILL}},\r\n{&hf_udt_msgno_last, {\r\n"Last Indicator", "udt.msg.last",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0x40000000, NULL, HFILL}},\r\n{&hf_udt_msgno_inorder, {\r\n"In-Order Indicator", "udt.msg.order",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0x20000000, NULL, HFILL}},\r\n{&hf_udt_timestamp, {\r\n"Timestamp", "udt.timestamp",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_id, {\r\n"ID", "udt.id",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_ack_seqno, {\r\n"Ack Sequence Number", "udt.ack_seqno",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_ackno, {\r\n"Ack Number", "udt.ackno",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_rtt, {\r\n"RTT (microseconds)", "udt.rtt",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_rttvar, {\r\n"RTT Variance (microseconds)", "udt.rttvar",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_bufavail, {\r\n"Buffer Available (packets)", "udt.rttvar",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_rate, {\r\n"Rate (packets/second)", "udt.rate",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_linkcap, {\r\n"Link Capacity (packets/second)", "udt.linkcap",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_handshake_version, {\r\n"Version", "udt.hs.version",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_handshake_type, {\r\n"Type", "udt.hs.type",\r\nFT_UINT32, BASE_DEC,\r\nVALS(udt_handshake_types), 0, NULL,\r\nHFILL}},\r\n{&hf_udt_handshake_isn, {\r\n"Initial Sequence Number", "udt.hs.isn",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_handshake_mtu, {\r\n"MTU", "udt.hs.mtu",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_handshake_flow_window, {\r\n"Flow Window", "udt.hs.flow_window",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_handshake_reqtype, {\r\n"Requested Type", "udt.hs.reqtype",\r\nFT_INT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_handshake_id, {\r\n"ID", "udt.hs.id",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_handshake_cookie, {\r\n"SYN Cookie", "udt.hs.cookie",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL}},\r\n{&hf_udt_handshake_peerip, {\r\n"Peer IP Address", "udt.hs.peerip",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL}},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_udt,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_udt_nak_seqno,\r\n{ "udt.nak_seqno", PI_SEQUENCE, PI_NOTE,\r\n"Missing Sequence Number(s)", EXPFILL }},\r\n};\r\nproto_udt = proto_register_protocol("UDT Protocol", "UDT", "udt");\r\nproto_register_field_array(proto_udt, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_udt = expert_register_protocol(proto_udt);\r\nexpert_register_field_array(expert_udt, ei, array_length(ei));\r\n}\r\nvoid proto_reg_handoff_udt(void)\r\n{\r\nudt_handle = create_dissector_handle(dissect_udt, proto_udt);\r\nheur_dissector_add("udp", dissect_udt_heur, "UDT over UDP", "udt_udp", proto_udt, HEURISTIC_ENABLE);\r\ndissector_add_for_decode_as("udp.port", udt_handle);\r\n}
