static lbtrm_transport_t * lbtrm_transport_unicast_find(const address * source_address, guint16 source_port, guint32 session_id, guint32 frame)\r\n{\r\nlbtrm_transport_t * transport = NULL;\r\nconversation_t * conv = NULL;\r\nwmem_tree_t * session_tree = NULL;\r\nconv = find_conversation(frame, source_address, &lbtrm_null_address, PT_UDP, source_port, 0, 0);\r\nif (conv != NULL)\r\n{\r\nif (frame > conv->last_frame)\r\n{\r\nconv->last_frame = frame;\r\n}\r\nsession_tree = (wmem_tree_t *) conversation_get_proto_data(conv, proto_lbtrm);\r\nif (session_tree != NULL)\r\n{\r\ntransport = (lbtrm_transport_t *) wmem_tree_lookup32(session_tree, session_id);\r\n}\r\n}\r\nreturn (transport);\r\n}\r\nstatic void lbtrm_transport_unicast_add(const address * source_address, guint16 source_port, guint32 session_id, guint32 frame, lbtrm_transport_t * transport)\r\n{\r\nconversation_t * conv = NULL;\r\nwmem_tree_t * session_tree = NULL;\r\nlbtrm_transport_t * transport_entry = NULL;\r\nconv = find_conversation(frame, source_address, &lbtrm_null_address, PT_UDP, source_port, 0, 0);\r\nif (conv == NULL)\r\n{\r\nconv = conversation_new(frame, source_address, &lbtrm_null_address, PT_UDP, source_port, 0, 0);\r\n}\r\nsession_tree = (wmem_tree_t *) conversation_get_proto_data(conv, proto_lbtrm);\r\nif (session_tree == NULL)\r\n{\r\nsession_tree = wmem_tree_new(wmem_file_scope());\r\nconversation_add_proto_data(conv, proto_lbtrm, (void *) session_tree);\r\n}\r\ntransport_entry = (lbtrm_transport_t *) wmem_tree_lookup32(session_tree, session_id);\r\nif (transport_entry == NULL)\r\n{\r\nwmem_tree_insert32(session_tree, session_id, (void *) transport);\r\n}\r\n}\r\nstatic lbtrm_transport_t * lbtrm_transport_find(const address * source_address, guint16 source_port, guint32 session_id, const address * multicast_group, guint16 dest_port, guint32 frame)\r\n{\r\nlbtrm_transport_t * entry = NULL;\r\nwmem_tree_t * session_tree = NULL;\r\nconversation_t * conv = NULL;\r\nconv = find_conversation(frame, source_address, multicast_group, PT_UDP, source_port, dest_port, 0);\r\nif (conv != NULL)\r\n{\r\nif (frame > conv->last_frame)\r\n{\r\nconv->last_frame = frame;\r\n}\r\nsession_tree = (wmem_tree_t *) conversation_get_proto_data(conv, proto_lbtrm);\r\nif (session_tree != NULL)\r\n{\r\nentry = (lbtrm_transport_t *) wmem_tree_lookup32(session_tree, session_id);\r\n}\r\n}\r\nreturn (entry);\r\n}\r\nlbtrm_transport_t * lbtrm_transport_add(const address * source_address, guint16 source_port, guint32 session_id, const address * multicast_group, guint16 dest_port, guint32 frame)\r\n{\r\nlbtrm_transport_t * entry;\r\nconversation_t * conv = NULL;\r\nwmem_tree_t * session_tree = NULL;\r\nconv = find_conversation(frame, source_address, multicast_group, PT_UDP, source_port, dest_port, 0);\r\nif (conv == NULL)\r\n{\r\nconv = conversation_new(frame, source_address, multicast_group, PT_UDP, source_port, dest_port, 0);\r\n}\r\nif (frame > conv->last_frame)\r\n{\r\nconv->last_frame = frame;\r\n}\r\nsession_tree = (wmem_tree_t *) conversation_get_proto_data(conv, proto_lbtrm);\r\nif (session_tree == NULL)\r\n{\r\nsession_tree = wmem_tree_new(wmem_file_scope());\r\nconversation_add_proto_data(conv, proto_lbtrm, (void *) session_tree);\r\n}\r\nentry = (lbtrm_transport_t *) wmem_tree_lookup32(session_tree, session_id);\r\nif (entry != NULL)\r\n{\r\nreturn (entry);\r\n}\r\nentry = wmem_new(wmem_file_scope(), lbtrm_transport_t);\r\ncopy_address_wmem(wmem_file_scope(), &(entry->source_address), source_address);\r\nentry->source_port = source_port;\r\nentry->session_id = session_id;\r\ncopy_address_wmem(wmem_file_scope(), &(entry->multicast_group), multicast_group);\r\nentry->dest_port = dest_port;\r\nentry->channel = lbm_channel_assign(LBM_CHANNEL_TRANSPORT_LBTRM);\r\nentry->frame = wmem_tree_new(wmem_file_scope());\r\nentry->last_frame = NULL;\r\nentry->last_data_frame = NULL;\r\nentry->last_sm_frame = NULL;\r\nentry->last_nak_frame = NULL;\r\nentry->last_ncf_frame = NULL;\r\nentry->data_sqn = wmem_tree_new(wmem_file_scope());\r\nentry->sm_sqn = wmem_tree_new(wmem_file_scope());\r\nentry->data_high_sqn = 0;\r\nentry->sm_high_sqn = 0;\r\nwmem_tree_insert32(session_tree, session_id, (void *) entry);\r\nlbtrm_transport_unicast_add(source_address, source_port, session_id, frame, entry);\r\nreturn (entry);\r\n}\r\nstatic lbm_transport_sqn_t * lbtrm_transport_sqn_find(lbtrm_transport_t * transport, guint8 type, guint32 sqn)\r\n{\r\nlbm_transport_sqn_t * sqn_entry = NULL;\r\nswitch (type)\r\n{\r\ncase LBTRM_PACKET_TYPE_DATA:\r\nsqn_entry = (lbm_transport_sqn_t *) wmem_tree_lookup32(transport->data_sqn, sqn);\r\nbreak;\r\ncase LBTRM_PACKET_TYPE_SM:\r\nsqn_entry = (lbm_transport_sqn_t *) wmem_tree_lookup32(transport->sm_sqn, sqn);\r\nbreak;\r\ncase LBTRM_PACKET_TYPE_NAK:\r\ncase LBTRM_PACKET_TYPE_NCF:\r\ndefault:\r\nsqn_entry = NULL;\r\nbreak;\r\n}\r\nreturn (sqn_entry);\r\n}\r\nstatic lbm_transport_sqn_t * lbtrm_transport_sqn_add(lbtrm_transport_t * transport, lbm_transport_frame_t * frame)\r\n{\r\nwmem_tree_t * sqn_list = NULL;\r\nlbm_transport_sqn_t * sqn_entry = NULL;\r\nswitch (frame->type)\r\n{\r\ncase LBTRM_PACKET_TYPE_DATA:\r\nsqn_list = transport->data_sqn;\r\nbreak;\r\ncase LBTRM_PACKET_TYPE_SM:\r\nsqn_list = transport->sm_sqn;\r\nbreak;\r\ncase LBTRM_PACKET_TYPE_NAK:\r\ncase LBTRM_PACKET_TYPE_NCF:\r\ndefault:\r\nreturn (NULL);\r\nbreak;\r\n}\r\nsqn_entry = lbm_transport_sqn_add(sqn_list, frame);\r\nreturn (sqn_entry);\r\n}\r\nstatic lbm_transport_frame_t * lbtrm_transport_frame_find(lbtrm_transport_t * transport, guint32 frame)\r\n{\r\nreturn ((lbm_transport_frame_t *) wmem_tree_lookup32(transport->frame, frame));\r\n}\r\nstatic lbm_transport_frame_t * lbtrm_transport_frame_add(lbtrm_transport_t * transport, guint8 type, guint32 frame, guint32 sqn, gboolean retransmission)\r\n{\r\nlbm_transport_sqn_t * dup_sqn_entry = NULL;\r\nlbm_transport_frame_t * frame_entry = NULL;\r\nframe_entry = lbtrm_transport_frame_find(transport, frame);\r\nif (frame_entry != NULL)\r\n{\r\nreturn (frame_entry);\r\n}\r\nframe_entry = lbm_transport_frame_add(transport->frame, type, frame, sqn, retransmission);\r\nif (transport->last_frame != NULL)\r\n{\r\nframe_entry->previous_frame = transport->last_frame->frame;\r\ntransport->last_frame->next_frame = frame;\r\n}\r\ntransport->last_frame = frame_entry;\r\nswitch (type)\r\n{\r\ncase LBTRM_PACKET_TYPE_DATA:\r\nif (transport->last_data_frame != NULL)\r\n{\r\nframe_entry->previous_type_frame = transport->last_data_frame->frame;\r\ntransport->last_data_frame->next_type_frame = frame;\r\nif (frame_entry->sqn <= transport->data_high_sqn)\r\n{\r\ndup_sqn_entry = lbtrm_transport_sqn_find(transport, type, frame_entry->sqn);\r\nif (!frame_entry->retransmission)\r\n{\r\nif (dup_sqn_entry != NULL)\r\n{\r\nframe_entry->duplicate = TRUE;\r\n}\r\nif (frame_entry->sqn != transport->data_high_sqn)\r\n{\r\nframe_entry->ooo_gap = transport->data_high_sqn - frame_entry->sqn;\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nif (!frame_entry->retransmission)\r\n{\r\nif (frame_entry->sqn != (transport->data_high_sqn + 1))\r\n{\r\nframe_entry->sqn_gap = frame_entry->sqn - (transport->last_data_frame->sqn + 1);\r\n}\r\n}\r\n}\r\n}\r\nif ((frame_entry->sqn > transport->data_high_sqn) && !frame_entry->retransmission)\r\n{\r\ntransport->data_high_sqn = frame_entry->sqn;\r\n}\r\ntransport->last_data_frame = frame_entry;\r\nbreak;\r\ncase LBTRM_PACKET_TYPE_SM:\r\nif (transport->last_sm_frame != NULL)\r\n{\r\nframe_entry->previous_type_frame = transport->last_sm_frame->frame;\r\ntransport->last_sm_frame->next_type_frame = frame;\r\nif (frame_entry->sqn <= transport->sm_high_sqn)\r\n{\r\ndup_sqn_entry = lbtrm_transport_sqn_find(transport, type, frame_entry->sqn);\r\nif (dup_sqn_entry != NULL)\r\n{\r\nframe_entry->duplicate = TRUE;\r\n}\r\nif (frame_entry->sqn != transport->sm_high_sqn)\r\n{\r\nframe_entry->ooo_gap = transport->sm_high_sqn - frame_entry->sqn;\r\n}\r\n}\r\nelse\r\n{\r\nif (frame_entry->sqn != (transport->sm_high_sqn + 1))\r\n{\r\nframe_entry->sqn_gap = frame_entry->sqn - (transport->sm_high_sqn + 1);\r\n}\r\n}\r\n}\r\nif (frame_entry->sqn > transport->sm_high_sqn)\r\n{\r\ntransport->sm_high_sqn = frame_entry->sqn;\r\n}\r\ntransport->last_sm_frame = frame_entry;\r\nbreak;\r\ncase LBTRM_PACKET_TYPE_NAK:\r\nif (transport->last_nak_frame != NULL)\r\n{\r\nframe_entry->previous_type_frame = transport->last_nak_frame->frame;\r\ntransport->last_nak_frame->next_type_frame = frame;\r\n}\r\ntransport->last_nak_frame = frame_entry;\r\nbreak;\r\ncase LBTRM_PACKET_TYPE_NCF:\r\nif (transport->last_ncf_frame != NULL)\r\n{\r\nframe_entry->previous_type_frame = transport->last_ncf_frame->frame;\r\ntransport->last_ncf_frame->next_type_frame = frame;\r\n}\r\ntransport->last_ncf_frame = frame_entry;\r\nbreak;\r\n}\r\n(void)lbtrm_transport_sqn_add(transport, frame_entry);\r\nreturn (frame_entry);\r\n}\r\nstatic char * lbtrm_transport_source_string_format(const address * source_address, guint16 source_port, guint32 session_id, const address * multicast_group, guint16 dest_port)\r\n{\r\nreturn (wmem_strdup_printf(wmem_packet_scope(), "LBTRM:%s:%" G_GUINT16_FORMAT ":%08x:%s:%" G_GUINT16_FORMAT, address_to_str(wmem_packet_scope(), source_address), source_port, session_id,\r\naddress_to_str(wmem_packet_scope(), multicast_group), dest_port));\r\n}\r\nchar * lbtrm_transport_source_string(const address * source_address, guint16 source_port, guint32 session_id, const address * multicast_group, guint16 dest_port)\r\n{\r\nreturn (wmem_strdup(wmem_file_scope(), lbtrm_transport_source_string_format(source_address, source_port, session_id, multicast_group, dest_port)));\r\n}\r\nstatic char * lbtrm_transport_source_string_transport(lbtrm_transport_t * transport)\r\n{\r\nreturn (lbtrm_transport_source_string_format(&(transport->source_address), transport->source_port, transport->session_id, &(transport->multicast_group), transport->dest_port));\r\n}\r\nstatic gboolean lbtrm_tag_update_cb(void * record, char * * error_string)\r\n{\r\nlbtrm_tag_entry_t * tag = (lbtrm_tag_entry_t *)record;\r\nif (tag->name == NULL)\r\n{\r\n*error_string = g_strdup("Tag name can't be empty");\r\nreturn FALSE;\r\n}\r\nelse\r\n{\r\ng_strstrip(tag->name);\r\nif (tag->name[0] == 0)\r\n{\r\n*error_string = g_strdup("Tag name can't be empty");\r\nreturn FALSE;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic void * lbtrm_tag_copy_cb(void * destination, const void * source, size_t length _U_)\r\n{\r\nconst lbtrm_tag_entry_t * src = (const lbtrm_tag_entry_t *)source;\r\nlbtrm_tag_entry_t * dest = (lbtrm_tag_entry_t *)destination;\r\ndest->name = g_strdup(src->name);\r\ndest->mc_address_low = g_strdup(src->mc_address_low);\r\ndest->mc_address_low_val_h = src->mc_address_low_val_h;\r\ndest->mc_address_high = g_strdup(src->mc_address_high);\r\ndest->mc_address_high_val_h = src->mc_address_high_val_h;\r\ndest->dport_low = src->dport_low;\r\ndest->dport_high = src->dport_high;\r\ndest->sport_low = src->sport_low;\r\ndest->sport_high = src->sport_high;\r\ndest->mim_incoming_dport = src->mim_incoming_dport;\r\ndest->mim_outgoing_dport = src->mim_outgoing_dport;\r\ndest->mim_mc_incoming_address = g_strdup(src->mim_mc_incoming_address);\r\ndest->mim_mc_incoming_address_val_h = src->mim_mc_incoming_address_val_h;\r\ndest->mim_mc_outgoing_address = g_strdup(src->mim_mc_outgoing_address);\r\ndest->mim_mc_outgoing_address_val_h = src->mim_mc_outgoing_address_val_h;\r\nreturn (dest);\r\n}\r\nstatic void lbtrm_tag_free_cb(void * record)\r\n{\r\nlbtrm_tag_entry_t * tag = (lbtrm_tag_entry_t *)record;\r\nif (tag->name != NULL)\r\n{\r\ng_free(tag->name);\r\ntag->name = NULL;\r\n}\r\nif (tag->mc_address_low != NULL)\r\n{\r\ng_free(tag->mc_address_low);\r\ntag->mc_address_low = NULL;\r\n}\r\nif (tag->mc_address_high != NULL)\r\n{\r\ng_free(tag->mc_address_high);\r\ntag->mc_address_high = NULL;\r\n}\r\nif (tag->mim_mc_incoming_address != NULL)\r\n{\r\ng_free(tag->mim_mc_incoming_address);\r\ntag->mim_mc_incoming_address = NULL;\r\n}\r\nif (tag->mim_mc_outgoing_address != NULL)\r\n{\r\ng_free(tag->mim_mc_outgoing_address);\r\ntag->mim_mc_outgoing_address = NULL;\r\n}\r\n}\r\nstatic char * lbtrm_tag_find(packet_info * pinfo)\r\n{\r\nguint idx;\r\nlbtrm_tag_entry_t * tag = NULL;\r\nguint32 dest_addr_h;\r\nif (!lbtrm_use_tag)\r\n{\r\nreturn (NULL);\r\n}\r\ndest_addr_h = pntoh32(pinfo->dst.data);\r\nfor (idx = 0; idx < lbtrm_tag_count; ++idx)\r\n{\r\ntag = &(lbtrm_tag_entry[idx]);\r\nif (IN_MULTICAST(dest_addr_h))\r\n{\r\nif ((dest_addr_h >= tag->mc_address_low_val_h) && (dest_addr_h <= tag->mc_address_high_val_h))\r\n{\r\nif ((pinfo->destport >= tag->dport_low) && (pinfo->destport <= tag->dport_high))\r\n{\r\nreturn (tag->name);\r\n}\r\n}\r\nelse if ((dest_addr_h == tag->mim_mc_incoming_address_val_h) || (dest_addr_h == tag->mim_mc_outgoing_address_val_h))\r\n{\r\nif (((dest_addr_h == tag->mim_mc_incoming_address_val_h) && (pinfo->destport == tag->mim_incoming_dport))\r\n|| ((dest_addr_h == tag->mim_mc_outgoing_address_val_h) && (pinfo->destport == tag->mim_outgoing_dport)))\r\n{\r\nreturn (tag->name);\r\n}\r\n}\r\ncontinue;\r\n}\r\nelse\r\n{\r\nif ((pinfo->destport < tag->sport_low) || (pinfo->destport > tag->sport_high))\r\n{\r\ncontinue;\r\n}\r\nreturn (tag->name);\r\n}\r\n}\r\nreturn (NULL);\r\n}\r\nstatic int dissect_lbtrm_data_contents(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, const char * tag_name, guint64 channel)\r\n{\r\ntvbuff_t * next_tvb;\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nreturn (lbmc_dissect_lbmc_packet(next_tvb, 0, pinfo, tree, tag_name, channel));\r\n}\r\nstatic int dissect_lbtrm_ncf_list(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, int ncf_count, int reason, lbm_lbtrm_tap_info_t * tap_info)\r\n{\r\nproto_tree * ncf_tree = NULL;\r\nproto_item * ncf_item = NULL;\r\nlbm_uint32_t ncf;\r\nint idx = 0;\r\nint len = 0;\r\nncf_item = proto_tree_add_item(tree, hf_lbtrm_ncf_list, tvb, offset + len, (int)(sizeof(lbm_uint32_t) * ncf_count), ENC_NA);\r\nncf_tree = proto_item_add_subtree(ncf_item, ett_lbtrm_ncf_list);\r\nfor (idx = 0; idx < ncf_count; idx++)\r\n{\r\nproto_item * sep_ncf_item = NULL;\r\nncf = tvb_get_ntohl(tvb, offset + len);\r\nsep_ncf_item = proto_tree_add_item(ncf_tree, hf_lbtrm_ncf_list_ncf, tvb, offset + len, sizeof(lbm_uint32_t), ENC_BIG_ENDIAN);\r\nif (lbtrm_expert_separate_ncfs)\r\n{\r\nexpert_add_info_format(pinfo, sep_ncf_item, &ei_lbtrm_analysis_ncf_ncf, "NCF 0x%08x %s", ncf, val_to_str(reason, lbtrm_ncf_reason, "Unknown (0x%02x)"));\r\n}\r\ntap_info->sqns[idx] = ncf;\r\nlen += 4;\r\n}\r\nreturn (len);\r\n}\r\nstatic int dissect_lbtrm_ncf(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, lbm_lbtrm_tap_info_t * tap_info)\r\n{\r\nint len = 0;\r\nguint16 num_ncfs;\r\nguint8 reason;\r\nproto_tree * ncf_tree = NULL;\r\nproto_item * ncf_item = NULL;\r\nproto_item * reason_item = NULL;\r\nncf_item = proto_tree_add_item(tree, hf_lbtrm_ncf, tvb, offset, -1, ENC_NA);\r\nncf_tree = proto_item_add_subtree(ncf_item, ett_lbtrm_ncf);\r\nnum_ncfs = tvb_get_ntohs(tvb, offset + O_LBTRM_NCF_HDR_T_NUM_NCFS);\r\nreason = tvb_get_guint8(tvb, offset + O_LBTRM_NCF_HDR_T_REASON_FORMAT);\r\nproto_tree_add_item(ncf_tree, hf_lbtrm_ncf_trail_sqn, tvb, offset + O_LBTRM_NCF_HDR_T_TRAIL_SQN, L_LBTRM_NCF_HDR_T_TRAIL_SQN, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ncf_tree, hf_lbtrm_ncf_num_ncfs, tvb, offset + O_LBTRM_NCF_HDR_T_NUM_NCFS, L_LBTRM_NCF_HDR_T_NUM_NCFS, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ncf_tree, hf_lbtrm_ncf_reserved, tvb, offset + O_LBTRM_NCF_HDR_T_RESERVED, L_LBTRM_NCF_HDR_T_RESERVED, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ncf_tree, hf_lbtrm_ncf_reason, tvb, offset + O_LBTRM_NCF_HDR_T_REASON_FORMAT, L_LBTRM_NCF_HDR_T_REASON_FORMAT, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ncf_tree, hf_lbtrm_ncf_format, tvb, offset + O_LBTRM_NCF_HDR_T_REASON_FORMAT, L_LBTRM_NCF_HDR_T_REASON_FORMAT, ENC_BIG_ENDIAN);\r\nlen = L_LBTRM_NCF_HDR_T;\r\nif (!lbtrm_expert_separate_ncfs)\r\n{\r\nexpert_add_info_format(pinfo, reason_item, &ei_lbtrm_analysis_ncf, "NCF %s", val_to_str(LBTRM_NCF_HDR_REASON(reason), lbtrm_ncf_reason, "Unknown (0x%02x)"));\r\n}\r\ntap_info->ncf_reason = LBTRM_NCF_HDR_REASON(reason);\r\ntap_info->num_sqns = num_ncfs;\r\ntap_info->sqns = wmem_alloc_array(wmem_packet_scope(), guint32, num_ncfs);\r\nlen += dissect_lbtrm_ncf_list(tvb, offset + len, pinfo, ncf_tree, num_ncfs, LBTRM_NCF_HDR_REASON(reason), tap_info);\r\nproto_item_set_len(ncf_item, len);\r\nreturn (len);\r\n}\r\nstatic int dissect_lbtrm_nak_list(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, int nak_count, lbm_lbtrm_tap_info_t * tap_info)\r\n{\r\nproto_tree * nak_tree = NULL;\r\nproto_item * nak_item = NULL;\r\nlbm_uint32_t nak;\r\nint idx = 0;\r\nint len = 0;\r\nnak_item = proto_tree_add_item(tree, hf_lbtrm_nak_list, tvb, offset + len, (int)(sizeof(lbm_uint32_t) * nak_count), ENC_NA);\r\nnak_tree = proto_item_add_subtree(nak_item, ett_lbtrm_nak_list);\r\nfor (idx = 0; idx < nak_count; idx++)\r\n{\r\nproto_item * sep_nak_item = NULL;\r\nnak = tvb_get_ntohl(tvb, offset + len);\r\nsep_nak_item = proto_tree_add_item(nak_tree, hf_lbtrm_nak_list_nak, tvb, offset + len, sizeof(lbm_uint32_t), ENC_BIG_ENDIAN);\r\nif (lbtrm_expert_separate_naks)\r\n{\r\nexpert_add_info_format(pinfo, sep_nak_item, &ei_lbtrm_analysis_nak_nak, "NAK 0x%08x", nak);\r\n}\r\ntap_info->sqns[idx] = nak;\r\nlen += 4;\r\n}\r\nreturn (len);\r\n}\r\nstatic int dissect_lbtrm_nak(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, lbm_lbtrm_tap_info_t * tap_info)\r\n{\r\nint len = 0;\r\nguint16 num_naks;\r\nproto_tree * nak_tree = NULL;\r\nproto_item * nak_item = NULL;\r\nnak_item = proto_tree_add_item(tree, hf_lbtrm_nak, tvb, offset, -1, ENC_NA);\r\nnak_tree = proto_item_add_subtree(nak_item, ett_lbtrm_nak);\r\nnum_naks = tvb_get_ntohs(tvb, offset + O_LBTRM_NAK_HDR_T_NUM_NAKS);\r\nproto_tree_add_item(nak_tree, hf_lbtrm_nak_num_naks, tvb, offset + O_LBTRM_NAK_HDR_T_NUM_NAKS, L_LBTRM_NAK_HDR_T_NUM_NAKS, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(nak_tree, hf_lbtrm_nak_format, tvb, offset + O_LBTRM_NAK_HDR_T_FORMAT, L_LBTRM_NAK_HDR_T_FORMAT, ENC_BIG_ENDIAN);\r\nlen = L_LBTRM_NAK_HDR_T;\r\nif (!lbtrm_expert_separate_naks)\r\n{\r\nexpert_add_info(pinfo, nak_item, &ei_lbtrm_analysis_nak);\r\n}\r\ntap_info->num_sqns = num_naks;\r\ntap_info->sqns = wmem_alloc_array(wmem_packet_scope(), guint32, num_naks);\r\nlen += dissect_lbtrm_nak_list(tvb, offset + len, pinfo, nak_tree, num_naks, tap_info);\r\nproto_item_set_len(nak_item, len);\r\nreturn (len);\r\n}\r\nstatic int dissect_lbtrm_sm(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, guint32 * sequence, lbm_lbtrm_tap_info_t * tap_info)\r\n{\r\nproto_tree * sm_tree = NULL;\r\nproto_item * sm_item = NULL;\r\nstatic const int * flags[] =\r\n{\r\n&hf_lbtrm_sm_flags_fec_type_ucast_naks,\r\nNULL\r\n};\r\nproto_item * sm_sqn_item = NULL;\r\nguint32 sqn;\r\nsm_item = proto_tree_add_item(tree, hf_lbtrm_sm, tvb, offset, L_LBTRM_SM_HDR_T, ENC_NA);\r\nsm_tree = proto_item_add_subtree(sm_item, ett_lbtrm_sm);\r\nsm_sqn_item = proto_tree_add_item(sm_tree, hf_lbtrm_sm_sm_sqn, tvb, offset + O_LBTRM_SM_HDR_T_SM_SQN, L_LBTRM_SM_HDR_T_SM_SQN, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sm_tree, hf_lbtrm_sm_lead_sqn, tvb, offset + O_LBTRM_SM_HDR_T_LEAD_SQN, L_LBTRM_SM_HDR_T_LEAD_SQN, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sm_tree, hf_lbtrm_sm_trail_sqn, tvb, offset + O_LBTRM_SM_HDR_T_TRAIL_SQN, L_LBTRM_SM_HDR_T_TRAIL_SQN, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(sm_tree, tvb, offset + O_LBTRM_SM_HDR_T_FLAGS_FEC_TYPE, hf_lbtrm_sm_flags_fec_type, ett_lbtrm_sm_flags_fec_type, flags, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sm_tree, hf_lbtrm_sm_flags_tgsz, tvb, offset + O_LBTRM_SM_HDR_T_FLAGS_TGSZ, L_LBTRM_SM_HDR_T_FLAGS_TGSZ, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sm_tree, hf_lbtrm_sm_reserved, tvb, offset + O_LBTRM_SM_HDR_T_RESERVED, L_LBTRM_SM_HDR_T_RESERVED, ENC_BIG_ENDIAN);\r\nsqn = tvb_get_ntohl(tvb, offset + O_LBTRM_SM_HDR_T_SM_SQN);\r\nexpert_add_info(pinfo, sm_sqn_item, &ei_lbtrm_analysis_sm);\r\nif (sequence != NULL)\r\n{\r\n*sequence = sqn;\r\n}\r\ntap_info->sqn = sqn;\r\nreturn (L_LBTRM_SM_HDR_T);\r\n}\r\nstatic int dissect_lbtrm_data(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, guint32 * sequence, gboolean * retransmission, lbm_lbtrm_tap_info_t * tap_info)\r\n{\r\nproto_tree * data_tree = NULL;\r\nproto_item * data_item = NULL;\r\nstatic const int * flags[] =\r\n{\r\n&hf_lbtrm_data_flags_fec_type_ucast_naks,\r\n&hf_lbtrm_data_flags_fec_type_rx,\r\nNULL\r\n};\r\nproto_item * sqn_item = NULL;\r\nguint8 flags_val;\r\nguint32 sqn;\r\ngboolean is_retransmission = FALSE;\r\ndata_item = proto_tree_add_item(tree, hf_lbtrm_data, tvb, offset, L_LBTRM_DATA_HDR_T, ENC_NA);\r\ndata_tree = proto_item_add_subtree(data_item, ett_lbtrm_data);\r\nsqn_item = proto_tree_add_item(data_tree, hf_lbtrm_data_sqn, tvb, offset + O_LBTRM_DATA_HDR_T_SQN, L_LBTRM_DATA_HDR_T_SQN, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(data_tree, hf_lbtrm_data_trail_sqn, tvb, offset + O_LBTRM_DATA_HDR_T_TRAIL_SQN, L_LBTRM_DATA_HDR_T_TRAIL_SQN, ENC_BIG_ENDIAN);\r\nflags_val = tvb_get_guint8(tvb, offset + O_LBTRM_DATA_HDR_T_FLAGS_FEC_TYPE);\r\nproto_tree_add_bitmask(data_tree, tvb, offset + O_LBTRM_DATA_HDR_T_FLAGS_FEC_TYPE, hf_lbtrm_data_flags_fec_type, ett_lbtrm_data_flags_fec_type, flags, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(data_tree, hf_lbtrm_data_flags_tgsz, tvb, offset + O_LBTRM_DATA_HDR_T_FLAGS_TGSZ, L_LBTRM_DATA_HDR_T_FLAGS_TGSZ, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(data_tree, hf_lbtrm_data_fec_symbol, tvb, offset + O_LBTRM_DATA_HDR_T_FEC_SYMBOL, L_LBTRM_DATA_HDR_T_FEC_SYMBOL, ENC_BIG_ENDIAN);\r\nsqn = tvb_get_ntohl(tvb, offset + O_LBTRM_DATA_HDR_T_SQN);\r\nif (sequence != NULL)\r\n{\r\n*sequence = sqn;\r\n}\r\nif ((flags_val & LBTRM_DATA_RETRANSMISSION_FLAG) != 0)\r\n{\r\nis_retransmission = TRUE;\r\nexpert_add_info_format(pinfo, sqn_item, &ei_lbtrm_analysis_rx, "RX 0x%08x", sqn);\r\n}\r\nif (retransmission != NULL)\r\n{\r\n*retransmission = is_retransmission;\r\n}\r\ntap_info->retransmission = is_retransmission;\r\ntap_info->sqn = sqn;\r\nreturn (L_LBTRM_DATA_HDR_T);\r\n}\r\nstatic gboolean dissect_lbtrm_sqn_frame_list_callback(const void *key _U_, void * frame, void * user_data)\r\n{\r\nlbtrm_sqn_frame_list_callback_data_t * cb_data = (lbtrm_sqn_frame_list_callback_data_t *) user_data;\r\nproto_item * transport_item = NULL;\r\nlbm_transport_sqn_frame_t * sqn_frame = (lbm_transport_sqn_frame_t *) frame;\r\nif (sqn_frame->frame != cb_data->current_frame)\r\n{\r\nif (sqn_frame->retransmission)\r\n{\r\ntransport_item = proto_tree_add_uint_format_value(cb_data->tree, hf_lbtrm_analysis_sqn_frame, cb_data->tvb, 0, 0, sqn_frame->frame, "%" G_GUINT32_FORMAT " (RX)", sqn_frame->frame);\r\n}\r\nelse\r\n{\r\ntransport_item = proto_tree_add_uint(cb_data->tree, hf_lbtrm_analysis_sqn_frame, cb_data->tvb, 0, 0, sqn_frame->frame);\r\n}\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nreturn (FALSE);\r\n}\r\nstatic int dissect_lbtrm(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * user_data _U_)\r\n{\r\nproto_tree * lbtrm_tree = NULL;\r\nproto_item * lbtrm_item;\r\nint offset = 0;\r\nguint8 next_hdr = 0;\r\nchar * tag_name = NULL;\r\nint dissected_len = 0;\r\nint total_dissected_len = 0;\r\nproto_tree * hdr_tree = NULL;\r\nproto_item * hdr_item = NULL;\r\nguint16 src_port = 0;\r\nguint32 session_id = 0;\r\nguint16 dest_port = 0;\r\nlbtrm_transport_t * transport = NULL;\r\nproto_tree * transport_tree = NULL;\r\nproto_item * transport_item = NULL;\r\nguint32 sequence = 0;\r\ngboolean retransmission = FALSE;\r\nguint8 packet_type = 0;\r\nguint64 channel = LBM_CHANNEL_NO_CHANNEL;\r\nguint8 ver_type = 0;\r\nguint8 flags_fec_type = 0;\r\nguint16 num_naks = 0;\r\nguint16 num_ncfs = 0;\r\nlbm_lbtrm_tap_info_t * tapinfo = NULL;\r\nproto_item * header_type_item = NULL;\r\ncol_add_str(pinfo->cinfo, COL_PROTOCOL, "LBT-RM");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (lbtrm_use_tag)\r\n{\r\ntag_name = lbtrm_tag_find(pinfo);\r\n}\r\nif (tag_name != NULL)\r\n{\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "[Tag: %s]", tag_name);\r\n}\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\nver_type = tvb_get_guint8(tvb, O_LBTRM_HDR_T_VER_TYPE);\r\npacket_type = LBTRM_HDR_TYPE(ver_type);\r\nnext_hdr = tvb_get_guint8(tvb, O_LBTRM_HDR_T_NEXT_HDR);\r\nsrc_port = tvb_get_ntohs(tvb, O_LBTRM_HDR_T_UCAST_PORT);\r\nsession_id = tvb_get_ntohl(tvb, O_LBTRM_HDR_T_SESSION_ID);\r\nif (tag_name != NULL)\r\n{\r\nlbtrm_item = proto_tree_add_protocol_format(tree, proto_lbtrm, tvb, offset, -1, "LBT-RM Protocol (Tag: %s): Version %u, Type %s: Source Unicast Port %" G_GUINT16_FORMAT ", Session ID 0x%08x",\r\ntag_name, LBTRM_HDR_VER(ver_type), val_to_str(packet_type, lbtrm_packet_type, "Unknown (0x%02x)"),\r\nsrc_port, session_id);\r\n}\r\nelse\r\n{\r\nlbtrm_item = proto_tree_add_protocol_format(tree, proto_lbtrm, tvb, offset, -1, "LBT-RM Protocol: Version %u, Type %s: Source Unicast Port %" G_GUINT16_FORMAT ", Session ID 0x%08x",\r\nLBTRM_HDR_VER(ver_type), val_to_str(packet_type, lbtrm_packet_type, "Unknown (0x%02x)"),\r\nsrc_port, session_id);\r\n}\r\nlbtrm_tree = proto_item_add_subtree(lbtrm_item, ett_lbtrm);\r\ndest_port = pinfo->destport;\r\nif (PINFO_FD_VISITED(pinfo) == 0)\r\n{\r\nif (packet_type == LBTRM_PACKET_TYPE_NAK)\r\n{\r\ntransport = lbtrm_transport_unicast_find(&(pinfo->dst), src_port, session_id, pinfo->num);\r\n}\r\nelse\r\n{\r\ntransport = lbtrm_transport_add(&(pinfo->src), src_port, session_id, &(pinfo->dst), dest_port, pinfo->num);\r\n}\r\n}\r\nelse\r\n{\r\nif (packet_type == LBTRM_PACKET_TYPE_NAK)\r\n{\r\ntransport = lbtrm_transport_unicast_find(&(pinfo->dst), src_port, session_id, pinfo->num);\r\n}\r\nelse\r\n{\r\ntransport = lbtrm_transport_find(&(pinfo->src), src_port, session_id, &(pinfo->dst), dest_port, pinfo->num);\r\n}\r\n}\r\nif (transport != NULL)\r\n{\r\nproto_item * item = NULL;\r\nchannel = transport->channel;\r\nitem = proto_tree_add_uint64(lbtrm_tree, hf_lbtrm_channel, tvb, 0, 0, channel);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nif (tag_name != NULL)\r\n{\r\nproto_item * item = NULL;\r\nitem = proto_tree_add_string(lbtrm_tree, hf_lbtrm_tag, tvb, 0, 0, tag_name);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\ntapinfo = wmem_new0(wmem_packet_scope(), lbm_lbtrm_tap_info_t);\r\nif (transport != NULL)\r\n{\r\ntapinfo->transport = lbtrm_transport_source_string_transport(transport);\r\n}\r\ntapinfo->type = packet_type;\r\nhdr_item = proto_tree_add_item(lbtrm_tree, hf_lbtrm_hdr, tvb, O_LBTRM_HDR_T_VER_TYPE, L_LBTRM_HDR_T, ENC_NA);\r\nhdr_tree = proto_item_add_subtree(hdr_item, ett_lbtrm_hdr);\r\nproto_tree_add_item(hdr_tree, hf_lbtrm_hdr_ver, tvb, O_LBTRM_HDR_T_VER_TYPE, L_LBTRM_HDR_T_VER_TYPE, ENC_BIG_ENDIAN);\r\nheader_type_item = proto_tree_add_item(hdr_tree, hf_lbtrm_hdr_type, tvb, O_LBTRM_HDR_T_VER_TYPE, L_LBTRM_HDR_T_VER_TYPE, ENC_BIG_ENDIAN);\r\nswitch (packet_type)\r\n{\r\ncase LBTRM_PACKET_TYPE_DATA:\r\nsequence = tvb_get_ntohl(tvb, L_LBTRM_HDR_T + O_LBTRM_DATA_HDR_T_SQN);\r\nflags_fec_type = tvb_get_guint8(tvb, L_LBTRM_HDR_T + O_LBTRM_DATA_HDR_T_FLAGS_FEC_TYPE);\r\nif ((flags_fec_type & LBTRM_DATA_RETRANSMISSION_FLAG) != 0)\r\n{\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "DATA(RX) sqn 0x%x Port %" G_GUINT16_FORMAT " ID 0x%08x", sequence, src_port, session_id);\r\n}\r\nelse\r\n{\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "DATA sqn 0x%x Port %" G_GUINT16_FORMAT " ID 0x%08x", sequence, src_port, session_id);\r\n}\r\nbreak;\r\ncase LBTRM_PACKET_TYPE_SM:\r\nsequence = tvb_get_ntohl(tvb, L_LBTRM_HDR_T + O_LBTRM_SM_HDR_T_SM_SQN);\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "SM sqn 0x%x Port %" G_GUINT16_FORMAT " ID 0x%08x", sequence, src_port, session_id);\r\nbreak;\r\ncase LBTRM_PACKET_TYPE_NAK:\r\nnum_naks = tvb_get_ntohs(tvb, L_LBTRM_HDR_T + O_LBTRM_NAK_HDR_T_NUM_NAKS);\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "NAK %u naks Port %" G_GUINT16_FORMAT " ID 0x%08x", num_naks, src_port, session_id);\r\nbreak;\r\ncase LBTRM_PACKET_TYPE_NCF:\r\nnum_ncfs = tvb_get_ntohs(tvb, L_LBTRM_HDR_T + O_LBTRM_NCF_HDR_T_NUM_NCFS);\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "NCF %u ncfs Port %" G_GUINT16_FORMAT " ID 0x%08x", num_ncfs, src_port, session_id);\r\nbreak;\r\ndefault:\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "Unknown (0x%02x)", packet_type);\r\nexpert_add_info_format(pinfo, header_type_item, &ei_lbtrm_analysis_invalid_value, "Unrecognized type 0x%02x", packet_type);\r\nbreak;\r\n}\r\nproto_tree_add_item(hdr_tree, hf_lbtrm_hdr_next_hdr, tvb, O_LBTRM_HDR_T_NEXT_HDR, L_LBTRM_HDR_T_NEXT_HDR, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(hdr_tree, hf_lbtrm_hdr_ucast_port, tvb, O_LBTRM_HDR_T_UCAST_PORT, L_LBTRM_HDR_T_UCAST_PORT, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(hdr_tree, hf_lbtrm_hdr_session_id, tvb, O_LBTRM_HDR_T_SESSION_ID, L_LBTRM_HDR_T_SESSION_ID, ENC_BIG_ENDIAN);\r\ntotal_dissected_len = L_LBTRM_HDR_T;\r\noffset = L_LBTRM_HDR_T;\r\nswitch (packet_type)\r\n{\r\ncase LBTRM_PACKET_TYPE_DATA:\r\ndissected_len = dissect_lbtrm_data(tvb, offset, pinfo, lbtrm_tree, &sequence, &retransmission, tapinfo);\r\nbreak;\r\ncase LBTRM_PACKET_TYPE_SM:\r\ndissected_len = dissect_lbtrm_sm(tvb, offset, pinfo, lbtrm_tree, &sequence, tapinfo);\r\nbreak;\r\ncase LBTRM_PACKET_TYPE_NAK:\r\ndissected_len = dissect_lbtrm_nak(tvb, offset, pinfo, lbtrm_tree, tapinfo);\r\nbreak;\r\ncase LBTRM_PACKET_TYPE_NCF:\r\ndissected_len = dissect_lbtrm_ncf(tvb, offset, pinfo, lbtrm_tree, tapinfo);\r\nbreak;\r\ndefault:\r\nreturn (total_dissected_len);\r\nbreak;\r\n}\r\ntotal_dissected_len += dissected_len;\r\noffset += dissected_len;\r\nwhile (next_hdr != LBTRM_NHDR_DATA)\r\n{\r\nguint8 hdrlen = 0;\r\nnext_hdr = tvb_get_guint8(tvb, offset + O_LBTRM_BASIC_OPT_T_NEXT_HDR);\r\nhdrlen = tvb_get_guint8(tvb, offset + O_LBTRM_BASIC_OPT_T_HDR_LEN);\r\nif (hdrlen == 0)\r\n{\r\nbreak;\r\n}\r\noffset += hdrlen;\r\ntotal_dissected_len += hdrlen;\r\n}\r\nif (lbtrm_sequence_analysis)\r\n{\r\nif (pinfo->fd->flags.visited == 0)\r\n{\r\nif (transport != NULL)\r\n{\r\nlbtrm_transport_frame_add(transport, packet_type, pinfo->num, sequence, retransmission);\r\n}\r\n}\r\nelse\r\n{\r\nif (transport != NULL)\r\n{\r\nlbm_transport_frame_t * frame = NULL;\r\ntransport_item = proto_tree_add_item(lbtrm_tree, hf_lbtrm_analysis, tvb, 0, 0, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\ntransport_tree = proto_item_add_subtree(transport_item, ett_lbtrm_transport);\r\nframe = lbtrm_transport_frame_find(transport, pinfo->num);\r\nif (frame != NULL)\r\n{\r\nlbm_transport_sqn_t * sqn = NULL;\r\nif (frame->previous_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtrm_analysis_prev_frame, tvb, 0, 0, frame->previous_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nif (frame->next_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtrm_analysis_next_frame, tvb, 0, 0, frame->next_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nswitch (packet_type)\r\n{\r\ncase LBTRM_PACKET_TYPE_DATA:\r\nif (frame->previous_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtrm_analysis_prev_data_frame, tvb, 0, 0, frame->previous_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nif (frame->next_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtrm_analysis_next_data_frame, tvb, 0, 0, frame->next_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nsqn = lbtrm_transport_sqn_find(transport, packet_type, sequence);\r\nif (sqn != NULL)\r\n{\r\nif (sqn->frame_count > 1)\r\n{\r\nproto_tree * frame_tree = NULL;\r\nproto_item * frame_tree_item = NULL;\r\nlbtrm_sqn_frame_list_callback_data_t cb_data;\r\nframe_tree_item = proto_tree_add_item(transport_tree, hf_lbtrm_analysis_sqn, tvb, 0, 0, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(frame_tree_item);\r\nframe_tree = proto_item_add_subtree(frame_tree_item, ett_lbtrm_transport_sqn);\r\ncb_data.tree = frame_tree;\r\ncb_data.tvb = tvb;\r\ncb_data.current_frame = pinfo->num;\r\nwmem_tree_foreach(sqn->frame, dissect_lbtrm_sqn_frame_list_callback, (void *) &cb_data);\r\n}\r\n}\r\nif (frame->retransmission)\r\n{\r\ntransport_item = proto_tree_add_boolean(transport_tree, hf_lbtrm_analysis_data_retransmission, tvb, 0, 0, TRUE);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\nexpert_add_info(pinfo, transport_item, &ei_lbtrm_analysis_data_rx);\r\n}\r\nif (frame->sqn_gap != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtrm_analysis_data_sqn_gap, tvb, 0, 0, frame->sqn_gap);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\nexpert_add_info_format(pinfo, transport_item, &ei_lbtrm_analysis_data_gap, "Data sequence gap (%" G_GUINT32_FORMAT ")", frame->sqn_gap);\r\n}\r\nif (frame->ooo_gap != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtrm_analysis_data_ooo_gap, tvb, 0, 0, frame->ooo_gap);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\nexpert_add_info_format(pinfo, transport_item, &ei_lbtrm_analysis_data_ooo, "Data sequence out of order gap (%" G_GUINT32_FORMAT ")", frame->ooo_gap);\r\n}\r\nif (frame->duplicate)\r\n{\r\ntransport_item = proto_tree_add_boolean(transport_tree, hf_lbtrm_analysis_data_duplicate, tvb, 0, 0, TRUE);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\nexpert_add_info(pinfo, transport_item, &ei_lbtrm_analysis_data_dup);\r\n}\r\nbreak;\r\ncase LBTRM_PACKET_TYPE_SM:\r\nif (frame->previous_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtrm_analysis_prev_sm_frame, tvb, 0, 0, frame->previous_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nif (frame->next_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtrm_analysis_next_sm_frame, tvb, 0, 0, frame->next_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nsqn = lbtrm_transport_sqn_find(transport, packet_type, sequence);\r\nif (sqn != NULL)\r\n{\r\nif (sqn->frame_count > 1)\r\n{\r\nproto_tree * frame_tree = NULL;\r\nproto_item * frame_tree_item = NULL;\r\nlbtrm_sqn_frame_list_callback_data_t cb_data;\r\nframe_tree_item = proto_tree_add_item(transport_tree, hf_lbtrm_analysis_sqn, tvb, 0, 0, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(frame_tree_item);\r\nframe_tree = proto_item_add_subtree(frame_tree_item, ett_lbtrm_transport_sqn);\r\ncb_data.tree = frame_tree;\r\ncb_data.tvb = tvb;\r\ncb_data.current_frame = pinfo->num;\r\nwmem_tree_foreach(sqn->frame, dissect_lbtrm_sqn_frame_list_callback, (void *) &cb_data);\r\n}\r\n}\r\nif (frame->sqn_gap != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtrm_analysis_sm_sqn_gap, tvb, 0, 0, frame->sqn_gap);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\nexpert_add_info_format(pinfo, transport_item, &ei_lbtrm_analysis_sm_gap, "SM sequence gap (%" G_GUINT32_FORMAT ")", frame->sqn_gap);\r\n}\r\nif (frame->ooo_gap != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtrm_analysis_sm_ooo_gap, tvb, 0, 0, frame->ooo_gap);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\nexpert_add_info_format(pinfo, transport_item, &ei_lbtrm_analysis_sm_ooo, "SM sequence out of order gap (%" G_GUINT32_FORMAT ")", frame->ooo_gap);\r\n}\r\nif (frame->duplicate)\r\n{\r\ntransport_item = proto_tree_add_boolean(transport_tree, hf_lbtrm_analysis_sm_duplicate, tvb, 0, 0, TRUE);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\nexpert_add_info(pinfo, transport_item, &ei_lbtrm_analysis_sm_dup);\r\n}\r\nbreak;\r\ncase LBTRM_PACKET_TYPE_NAK:\r\nif (frame->previous_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtrm_analysis_prev_nak_frame, tvb, 0, 0, frame->previous_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nif (frame->next_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtrm_analysis_next_nak_frame, tvb, 0, 0, frame->next_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nbreak;\r\ncase LBTRM_PACKET_TYPE_NCF:\r\nif (frame->previous_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtrm_analysis_prev_ncf_frame, tvb, 0, 0, frame->previous_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nif (frame->next_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtrm_analysis_next_ncf_frame, tvb, 0, 0, frame->next_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nproto_item_set_len(lbtrm_item, total_dissected_len);\r\nif ((packet_type == LBTRM_PACKET_TYPE_DATA) && (next_hdr == LBTRM_NHDR_DATA))\r\n{\r\ntotal_dissected_len += dissect_lbtrm_data_contents(tvb, offset, pinfo, tree, tag_name, channel);\r\n}\r\nif (tapinfo->transport != NULL)\r\n{\r\ntap_queue_packet(lbtrm_tap_handle, pinfo, (void *) tapinfo);\r\n}\r\nreturn (total_dissected_len);\r\n}\r\nstatic gboolean test_lbtrm_packet(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * user_data)\r\n{\r\nguint32 dest_addr_h;\r\ngboolean valid_packet = FALSE;\r\nguint8 ver_type = 0;\r\nguint8 packet_type = 0;\r\nguint8 packet_ver = 0;\r\nguint8 next_hdr = 0;\r\nif (pinfo->ptype != PT_UDP)\r\n{\r\nreturn (FALSE);\r\n}\r\nif ((pinfo->dst.type != AT_IPv4) || (pinfo->dst.len != 4))\r\n{\r\nreturn (FALSE);\r\n}\r\nif (tvb_reported_length_remaining(tvb, 0) < L_LBTRM_HDR_T)\r\n{\r\nreturn (FALSE);\r\n}\r\nver_type = tvb_get_guint8(tvb, O_LBTRM_HDR_T_VER_TYPE);\r\npacket_type = LBTRM_HDR_TYPE(ver_type);\r\nswitch (packet_type)\r\n{\r\ncase LBTRM_PACKET_TYPE_DATA:\r\ncase LBTRM_PACKET_TYPE_SM:\r\ncase LBTRM_PACKET_TYPE_NAK:\r\ncase LBTRM_PACKET_TYPE_NCF:\r\nbreak;\r\ndefault:\r\nreturn (FALSE);\r\n}\r\npacket_ver = LBTRM_HDR_VER(ver_type);\r\nif (packet_ver != LBTRM_VERSION)\r\n{\r\nreturn (FALSE);\r\n}\r\nnext_hdr = tvb_get_guint8(tvb, O_LBTRM_HDR_T_NEXT_HDR);\r\nif (next_hdr != LBTRM_NHDR_DATA)\r\n{\r\nreturn (FALSE);\r\n}\r\nif (lbtrm_use_tag)\r\n{\r\nif (lbtrm_tag_find(pinfo) != NULL)\r\n{\r\nvalid_packet = TRUE;\r\n}\r\n}\r\nelse\r\n{\r\ndest_addr_h = pntoh32(pinfo->dst.data);\r\nif (IN_MULTICAST(dest_addr_h))\r\n{\r\nif ((dest_addr_h >= lbtrm_mc_address_low_host) && (dest_addr_h <= lbtrm_mc_address_high_host))\r\n{\r\nif ((pinfo->destport >= lbtrm_dest_port_low) && (pinfo->destport <= lbtrm_dest_port_high))\r\n{\r\nvalid_packet = TRUE;\r\n}\r\n}\r\nelse if ((dest_addr_h == mim_incoming_mc_address_host) || (dest_addr_h == mim_outgoing_mc_address_host))\r\n{\r\nif (((dest_addr_h == mim_incoming_mc_address_host) && (pinfo->destport == mim_incoming_dest_port))\r\n|| ((dest_addr_h == mim_outgoing_mc_address_host) && (pinfo->destport == mim_outgoing_dest_port)))\r\n{\r\nvalid_packet = TRUE;\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nif ((pinfo->destport >= lbtrm_src_port_low) && (pinfo->destport <= lbtrm_src_port_high))\r\n{\r\nvalid_packet = TRUE;\r\n}\r\n}\r\n}\r\nif (valid_packet)\r\n{\r\ndissect_lbtrm(tvb, pinfo, tree, user_data);\r\nreturn (TRUE);\r\n}\r\nreturn (FALSE);\r\n}\r\nvoid proto_register_lbtrm(void)\r\n{\r\nstatic hf_register_info hf[] =\r\n{\r\n{ &hf_lbtrm_channel,\r\n{ "Channel ID", "lbtrm.channel", FT_UINT64, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_tag,\r\n{ "Tag", "lbtrm.tag", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_hdr,\r\n{ "Header", "lbtrm.hdr", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_hdr_ver,\r\n{ "Version", "lbtrm.hdr.ver", FT_UINT8, BASE_HEX, NULL, LBTRM_HDR_VER_MASK, NULL, HFILL } },\r\n{ &hf_lbtrm_hdr_type,\r\n{ "Type", "lbtrm.hdr.type", FT_UINT8, BASE_HEX, VALS(lbtrm_packet_type), LBTRM_HDR_TYPE_MASK, NULL, HFILL } },\r\n{ &hf_lbtrm_hdr_next_hdr,\r\n{ "Next Header", "lbtrm.hdr.next_hdr", FT_UINT8, BASE_HEX, VALS(lbtrm_next_header), 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_hdr_ucast_port,\r\n{ "Source Unicast Port", "lbtrm.hdr.ucast_port", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_hdr_session_id,\r\n{ "Session ID", "lbtrm.hdr.session_id", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_data,\r\n{ "Data Header", "lbtrm.data", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_data_sqn,\r\n{ "Sequence Number", "lbtrm.data.sqn", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_data_trail_sqn,\r\n{ "Trailing Edge Sequence Number", "lbtrm.data.trail_sqn", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_data_flags_fec_type,\r\n{ "FEC Flags", "lbtrm.data.flags_fec_type", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_data_flags_fec_type_ucast_naks,\r\n{ "Unicast NAKs", "lbtrm.data.flags_fec_type.ucast_naks", FT_BOOLEAN, L_LBTRM_DATA_HDR_T_FLAGS_FEC_TYPE * 8, TFS(&tfs_set_notset), LBTRM_DATA_UNICAST_NAKS_FLAG, "Set if NAKs are sent via unicast", HFILL } },\r\n{ &hf_lbtrm_data_flags_fec_type_rx,\r\n{ "Retransmission", "lbtrm.data.flags_fec_type.rx", FT_BOOLEAN, L_LBTRM_DATA_HDR_T_FLAGS_FEC_TYPE * 8, TFS(&tfs_set_notset), LBTRM_DATA_RETRANSMISSION_FLAG, "Set if this is a retransmission", HFILL } },\r\n{ &hf_lbtrm_data_flags_tgsz,\r\n{ "TGSZ Flags", "lbtrm.data.flags_tgsz", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_data_fec_symbol,\r\n{ "FEC Symbol", "lbtrm.data.fec_symbol", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_sm,\r\n{ "Session Message Header", "lbtrm.sm", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_sm_sm_sqn,\r\n{ "Sequence Number", "lbtrm.sm.sm_sqn", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_sm_lead_sqn,\r\n{ "Lead Sequence Number", "lbtrm.sm.lead_sqn", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_sm_trail_sqn,\r\n{ "Trail Sequence Number", "lbtrm.sm.trail_sqn", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_sm_flags_fec_type,\r\n{ "FEC Flags", "lbtrm.sm.flags_fec_type", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_sm_flags_fec_type_ucast_naks,\r\n{ "Unicast NAKs", "lbtrm.sm.flags_fec_type.ucast_naks", FT_BOOLEAN, 8, TFS(&tfs_present_not_present), LBTRM_SM_UNICAST_NAKS_FLAG, "Set if NAKs are sent via unicast", HFILL } },\r\n{ &hf_lbtrm_sm_flags_tgsz,\r\n{ "TGSZ Flags", "lbtrm.sm.flags_tgsz", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_sm_reserved,\r\n{ "Reserved", "lbtrm.sm.reserved", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_nak,\r\n{ "NAK Header", "lbtrm.nak", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_nak_num_naks,\r\n{ "Number of NAKs", "lbtrm.nak.num_naks", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_nak_format,\r\n{ "Format", "lbtrm.nak.format", FT_UINT8, BASE_HEX, VALS(lbtrm_nak_format), LBTRM_NAK_HDR_FORMAT_MASK, NULL, HFILL } },\r\n{ &hf_lbtrm_nak_list,\r\n{ "NAK List", "lbtrm.nak.list", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_nak_list_nak,\r\n{ "NAK", "lbtrm.nak.list.nak", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_ncf,\r\n{ "NAK Confirmation Header", "lbtrm.ncf", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_ncf_trail_sqn,\r\n{ "Trailing Sequence Number", "lbtrm.ncf.trail_sqn", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_ncf_num_ncfs,\r\n{ "Number of Individual NCFs", "lbtrm.ncf.num_ncfs", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_ncf_reserved,\r\n{ "Reserved", "lbtrm.ncf.reserved", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_ncf_reason,\r\n{ "Reason", "lbtrm.ncf.reason", FT_UINT8, BASE_HEX, VALS(lbtrm_ncf_reason), LBTRM_NCF_HDR_REASON_MASK, NULL, HFILL } },\r\n{ &hf_lbtrm_ncf_format,\r\n{ "Format", "lbtrm.ncf.format", FT_UINT8, BASE_HEX, VALS(lbtrm_ncf_format), LBTRM_NCF_HDR_FORMAT_MASK, NULL, HFILL } },\r\n{ &hf_lbtrm_ncf_list,\r\n{ "NCF List", "lbtrm.ncf.list", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_ncf_list_ncf,\r\n{ "NCF", "lbtrm.ncf.list.ncf", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis,\r\n{ "Transport Analysis", "lbtrm.transport", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_prev_frame,\r\n{ "Previous Transport frame", "lbtrm.transport.prev_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_prev_data_frame,\r\n{ "Previous Transport DATA frame", "lbtrm.transport.prev_data_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_prev_sm_frame,\r\n{ "Previous Transport SM frame", "lbtrm.transport.prev_sm_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_prev_nak_frame,\r\n{ "Previous Transport NAK frame", "lbtrm.transport.prev_nak_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_prev_ncf_frame,\r\n{ "Previous Transport NCF frame", "lbtrm.transport.prev_ncf_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_next_frame,\r\n{ "Next Transport frame", "lbtrm.transport.next_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_next_data_frame,\r\n{ "Next Transport DATA frame", "lbtrm.transport.next_data_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_next_sm_frame,\r\n{ "Next Transport SM frame", "lbtrm.transport.next_sm_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_next_nak_frame,\r\n{ "Next Transport NAK frame", "lbtrm.transport.next_nak_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_next_ncf_frame,\r\n{ "Next Transport NCF frame", "lbtrm.transport.next_ncf_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_sqn,\r\n{ "SQN Also in", "lbtrm.transport.sqn", FT_NONE, BASE_NONE, NULL, 0x0, "Sequence number also appears in these frames", HFILL } },\r\n{ &hf_lbtrm_analysis_sqn_frame,\r\n{ "Frame", "lbtrm.transport.sqn.frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_data_retransmission,\r\n{ "Frame is a Data Retransmission", "lbtrm.transport.data_retransmission", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_data_sqn_gap,\r\n{ "Gap in Data Sequence", "lbtrm.transport.data_sqn_gap", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_data_ooo_gap,\r\n{ "Data Sequence Out of Order Gap", "lbtrm.transport.data_ooo_gap", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_data_duplicate,\r\n{ "Duplicate Data frame", "lbtrm.transport.data_duplicate", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_sm_sqn_gap,\r\n{ "Gap in SM Sequence", "lbtrm.transport.sm_sqn_gap", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_sm_ooo_gap,\r\n{ "SM Sequence Out of Order Gap", "lbtrm.transport.sm_ooo_gap", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtrm_analysis_sm_duplicate,\r\n{ "Duplicate SM frame", "lbtrm.transport.sm_duplicate", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n};\r\nstatic gint * ett[] =\r\n{\r\n&ett_lbtrm,\r\n&ett_lbtrm_hdr,\r\n&ett_lbtrm_data,\r\n&ett_lbtrm_data_flags_fec_type,\r\n&ett_lbtrm_sm,\r\n&ett_lbtrm_sm_flags_fec_type,\r\n&ett_lbtrm_nak,\r\n&ett_lbtrm_nak_list,\r\n&ett_lbtrm_ncf,\r\n&ett_lbtrm_ncf_list,\r\n&ett_lbtrm_transport,\r\n&ett_lbtrm_transport_sqn\r\n};\r\nstatic ei_register_info ei[] =\r\n{\r\n{ &ei_lbtrm_analysis_ncf, { "lbtrm.analysis.ncf", PI_SEQUENCE, PI_NOTE, "NCF", EXPFILL } },\r\n{ &ei_lbtrm_analysis_ncf_ncf, { "lbtrm.analysis.ncf.ncf", PI_SEQUENCE, PI_NOTE, "NCF", EXPFILL } },\r\n{ &ei_lbtrm_analysis_nak, { "lbtrm.analysis.nak", PI_SEQUENCE, PI_WARN, "NAK", EXPFILL } },\r\n{ &ei_lbtrm_analysis_nak_nak, { "lbtrm.analysis.nak.nak", PI_SEQUENCE, PI_WARN, "NAK", EXPFILL } },\r\n{ &ei_lbtrm_analysis_sm, { "lbtrm.analysis.sm", PI_SEQUENCE, PI_CHAT, "SM", EXPFILL } },\r\n{ &ei_lbtrm_analysis_rx, { "lbtrm.analysis.rx", PI_SEQUENCE, PI_NOTE, "RX", EXPFILL } },\r\n{ &ei_lbtrm_analysis_invalid_value, { "lbtrm.analysis.invalid_value", PI_MALFORMED, PI_ERROR, "Invalid value", EXPFILL } },\r\n{ &ei_lbtrm_analysis_data_rx, { "lbtrm.analysis.data.rx", PI_SEQUENCE, PI_NOTE, "Data RX", EXPFILL } },\r\n{ &ei_lbtrm_analysis_data_gap, { "lbtrm.analysis.data.gap", PI_SEQUENCE, PI_NOTE, "Data sequence gap", EXPFILL } },\r\n{ &ei_lbtrm_analysis_data_ooo, { "lbtrm.analysis.data.ooo", PI_SEQUENCE, PI_NOTE, "Data out of order", EXPFILL } },\r\n{ &ei_lbtrm_analysis_data_dup, { "lbtrm.analysis.data.dup", PI_SEQUENCE, PI_NOTE, "Duplicate data", EXPFILL } },\r\n{ &ei_lbtrm_analysis_sm_gap, { "lbtrm.analysis.sm.gap", PI_SEQUENCE, PI_NOTE, "SM sequence gap", EXPFILL } },\r\n{ &ei_lbtrm_analysis_sm_ooo, { "lbtrm.analysis.sm.ooo", PI_SEQUENCE, PI_NOTE, "SM out of order", EXPFILL } },\r\n{ &ei_lbtrm_analysis_sm_dup, { "lbtrm.analysis.sm.dup", PI_SEQUENCE, PI_NOTE, "Duplicate SM", EXPFILL } },\r\n};\r\nmodule_t * lbtrm_module;\r\nstruct in_addr addr;\r\nuat_t * tag_uat;\r\nexpert_module_t * expert_lbtrm;\r\nproto_lbtrm = proto_register_protocol("LBT Reliable Multicast Protocol",\r\n"LBT-RM", "lbtrm");\r\nproto_register_field_array(proto_lbtrm, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_lbtrm = expert_register_protocol(proto_lbtrm);\r\nexpert_register_field_array(expert_lbtrm, ei, array_length(ei));\r\nlbtrm_module = prefs_register_protocol_subtree("29West", proto_lbtrm, proto_reg_handoff_lbtrm);\r\ninet_aton(LBTRM_DEFAULT_MC_ADDRESS_LOW, &addr);\r\nlbtrm_mc_address_low_host = g_ntohl(addr.s_addr);\r\nprefs_register_string_preference(lbtrm_module,\r\n"mc_address_low",\r\n"Multicast address range low (default " LBTRM_DEFAULT_MC_ADDRESS_LOW ")",\r\n"Set the low end of the LBT-RM multicast address range (context transport_lbtrm_multicast_address_low)",\r\n&global_lbtrm_mc_address_low);\r\ninet_aton(LBTRM_DEFAULT_MC_ADDRESS_HIGH, &addr);\r\nlbtrm_mc_address_high_host = g_ntohl(addr.s_addr);\r\nprefs_register_string_preference(lbtrm_module,\r\n"mc_address_high",\r\n"Multicast address range high (default " LBTRM_DEFAULT_MC_ADDRESS_HIGH ")",\r\n"Set the high end of the LBT-RM multicast address range (context transport_lbtrm_multicast_address_high)",\r\n&global_lbtrm_mc_address_high);\r\nprefs_register_uint_preference(lbtrm_module,\r\n"dport_low",\r\n"Destination port range low (default " MAKESTRING(LBTRM_DEFAULT_DPORT_LOW)")",\r\n"Set the low end of the LBT-RM UDP destination port range (source transport_lbtrm_destination_port)",\r\n10,\r\n&global_lbtrm_dest_port_low);\r\nprefs_register_uint_preference(lbtrm_module,\r\n"dport_high",\r\n"Destination port range high (default " MAKESTRING(LBTRM_DEFAULT_DPORT_HIGH)")",\r\n"Set the high end of the LBT-RM UDP destination port range (source transport_lbtrm_destination_port)",\r\n10,\r\n&global_lbtrm_dest_port_high);\r\nprefs_register_uint_preference(lbtrm_module,\r\n"sport_low",\r\n"Source port range low (default " MAKESTRING(LBTRM_DEFAULT_SPORT_LOW)")",\r\n"Set the low end of the LBT-RM UDP source port range (context transport_lbtrm_source_port_low)",\r\n10,\r\n&global_lbtrm_src_port_low);\r\nprefs_register_uint_preference(lbtrm_module,\r\n"sport_high",\r\n"Source port range high (default " MAKESTRING(LBTRM_DEFAULT_SPORT_HIGH)")",\r\n"Set the high end of the LBT-RM UDP source port range (context transport_lbtrm_source_port_high)",\r\n10,\r\n&global_lbtrm_src_port_high);\r\ninet_aton(MIM_DEFAULT_MC_INCOMING_ADDRESS, &addr);\r\nmim_incoming_mc_address_host = g_ntohl(addr.s_addr);\r\nprefs_register_string_preference(lbtrm_module,\r\n"mim_incoming_address",\r\n"MIM incoming multicast address (default " MIM_DEFAULT_MC_INCOMING_ADDRESS ")",\r\n"Set the incoming MIM multicast address (context mim_incoming_address)",\r\n&global_mim_incoming_mc_address);\r\ninet_aton(MIM_DEFAULT_MC_OUTGOING_ADDRESS, &addr);\r\nmim_outgoing_mc_address_host = g_ntohl(addr.s_addr);\r\nprefs_register_string_preference(lbtrm_module,\r\n"mim_outgoing_address",\r\n"MIM outgoing multicast address (default " MIM_DEFAULT_MC_OUTGOING_ADDRESS ")",\r\n"Set the outgoing MIM multicast address (context mim_outgoing_address)",\r\n&global_mim_outgoing_mc_address);\r\nprefs_register_uint_preference(lbtrm_module,\r\n"mim_incoming_dport",\r\n"MIM incoming port (default " MAKESTRING(MIM_DEFAULT_INCOMING_DPORT)")",\r\n"Set the incoming MIM UDP port (context mim_incoming_destination_port)",\r\n10,\r\n&global_mim_incoming_dest_port);\r\nprefs_register_uint_preference(lbtrm_module,\r\n"mim_outgoing_dport",\r\n"MIM outgoing port (default " MAKESTRING(MIM_DEFAULT_OUTGOING_DPORT)")",\r\n"Set the outgoing MIM UDP port (context mim_outgoing_destination_port)",\r\n10,\r\n&global_mim_outgoing_dest_port);\r\nlbtrm_expert_separate_naks = global_lbtrm_expert_separate_naks;\r\nprefs_register_bool_preference(lbtrm_module,\r\n"expert_separate_naks",\r\n"Separate NAKs in Expert Info",\r\n"Separate multiple NAKs from a single packet into distinct Expert Info entries",\r\n&global_lbtrm_expert_separate_naks);\r\nlbtrm_expert_separate_ncfs = global_lbtrm_expert_separate_ncfs;\r\nprefs_register_bool_preference(lbtrm_module,\r\n"expert_separate_ncfs",\r\n"Separate NCFs in Expert Info",\r\n"Separate multiple NCFs from a single packet into distinct Expert Info entries",\r\n&global_lbtrm_expert_separate_ncfs);\r\nlbtrm_sequence_analysis = global_lbtrm_sequence_analysis;\r\nprefs_register_bool_preference(lbtrm_module,\r\n"sequence_analysis",\r\n"Perform sequence Number Analysis",\r\n"Perform analysis on LBT-RM sequence numbers to determine out-of-order, gaps, loss, etc",\r\n&global_lbtrm_sequence_analysis);\r\nlbtrm_use_tag = global_lbtrm_use_tag;\r\nprefs_register_bool_preference(lbtrm_module,\r\n"use_lbtrm_domain",\r\n"Use LBT-RM tag table",\r\n"Use table of LBT-RM tags to decode the packet instead of above values",\r\n&global_lbtrm_use_tag);\r\ntag_uat = uat_new("LBT-RM tag definitions",\r\nsizeof(lbtrm_tag_entry_t),\r\n"lbtrm_domains",\r\nTRUE,\r\n(void * *)&lbtrm_tag_entry,\r\n&lbtrm_tag_count,\r\nUAT_AFFECTS_DISSECTION,\r\nNULL,\r\nlbtrm_tag_copy_cb,\r\nlbtrm_tag_update_cb,\r\nlbtrm_tag_free_cb,\r\nNULL,\r\nlbtrm_tag_array);\r\nprefs_register_uat_preference(lbtrm_module,\r\n"tnw_lbtrm_tags",\r\n"LBT-RM Tags",\r\n"A table to define LBT-RM tags",\r\ntag_uat);\r\n}\r\nvoid proto_reg_handoff_lbtrm(void)\r\n{\r\nstatic gboolean already_registered = FALSE;\r\nstruct in_addr addr;\r\nguint32 dest_addr_h_low;\r\nguint32 dest_addr_h_high;\r\nif (!already_registered)\r\n{\r\nlbtrm_dissector_handle = create_dissector_handle(dissect_lbtrm, proto_lbtrm);\r\ndissector_add_for_decode_as("udp.port", lbtrm_dissector_handle);\r\nheur_dissector_add("udp", test_lbtrm_packet, "LBT Reliable Multicast over UDP", "lbtrm_udp", proto_lbtrm, HEURISTIC_ENABLE);\r\nlbtrm_tap_handle = register_tap("lbm_lbtrm");\r\n}\r\ninet_aton(global_lbtrm_mc_address_low, &addr);\r\ndest_addr_h_low = g_ntohl(addr.s_addr);\r\ninet_aton(global_lbtrm_mc_address_high, &addr);\r\ndest_addr_h_high = g_ntohl(addr.s_addr);\r\nif (dest_addr_h_low <= dest_addr_h_high)\r\n{\r\nlbtrm_mc_address_low_host = dest_addr_h_low;\r\nlbtrm_mc_address_high_host = dest_addr_h_high;\r\n}\r\nif (global_lbtrm_dest_port_low <= global_lbtrm_dest_port_high)\r\n{\r\nlbtrm_dest_port_low = global_lbtrm_dest_port_low;\r\nlbtrm_dest_port_high = global_lbtrm_dest_port_high;\r\n}\r\nif (global_lbtrm_src_port_low <= global_lbtrm_src_port_high)\r\n{\r\nlbtrm_src_port_low = global_lbtrm_src_port_low;\r\nlbtrm_src_port_high = global_lbtrm_src_port_high;\r\n}\r\ninet_aton(global_mim_incoming_mc_address, &addr);\r\nmim_incoming_mc_address_host = g_htonl(addr.s_addr);\r\ninet_aton(global_mim_outgoing_mc_address, &addr);\r\nmim_outgoing_mc_address_host = g_htonl(addr.s_addr);\r\nmim_incoming_dest_port = global_mim_incoming_dest_port;\r\nmim_outgoing_dest_port = global_mim_outgoing_dest_port;\r\nlbtrm_expert_separate_naks = global_lbtrm_expert_separate_naks;\r\nlbtrm_expert_separate_ncfs = global_lbtrm_expert_separate_ncfs;\r\nlbtrm_sequence_analysis = global_lbtrm_sequence_analysis;\r\nlbtrm_use_tag = global_lbtrm_use_tag;\r\nalready_registered = TRUE;\r\n}
