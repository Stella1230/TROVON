static void dissect_caps(proto_tree *tree, tvbuff_t *tvb, int offset)\r\n{\r\nproto_tree *captree;\r\ncaptree = proto_tree_add_subtree(tree, tvb, offset, 1, ett_iapp_cap, NULL, "Capabilities");\r\nproto_tree_add_item(captree, hf_iapp_cap_forwarding, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(captree, hf_iapp_cap_wep, tvb, offset, 1, ENC_NA);\r\n}\r\nstatic void\r\nadd_authval_str(proto_tree *tree, int type, int len, tvbuff_t *tvb, int offset)\r\n{\r\nint val;\r\nswitch (type)\r\n{\r\ncase IAPP_AUTH_STATUS:\r\nval = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint_format_value(tree, hf_iapp_auth_status, tvb, offset, 1, val, "%s", val ? "Authenticated" : "Not authenticated");\r\nbreak;\r\ncase IAPP_AUTH_USERNAME:\r\ncase IAPP_AUTH_PROVNAME:\r\nproto_tree_add_item(tree, hf_iapp_auth_string, tvb, offset, 1, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase IAPP_AUTH_RXPKTS:\r\ncase IAPP_AUTH_TXPKTS:\r\ncase IAPP_AUTH_RXBYTES:\r\ncase IAPP_AUTH_TXBYTES:\r\ncase IAPP_AUTH_RXGWORDS:\r\ncase IAPP_AUTH_TXGWORDS:\r\ncase IAPP_AUTH_VOLLIMIT:\r\nproto_tree_add_item(tree, hf_iapp_auth_uint, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase IAPP_AUTH_LOGINTIME:\r\ncase IAPP_AUTH_TIMELIMIT:\r\ncase IAPP_AUTH_ACCCYCLE:\r\nval = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_uint_format_value(tree, hf_iapp_auth_uint, tvb, offset, 4, val, "%d seconds", val);\r\nbreak;\r\ncase IAPP_AUTH_IPADDR:\r\nproto_tree_add_item(tree, hf_iapp_auth_ipaddr, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase IAPP_AUTH_TRAILER:\r\nproto_tree_add_item(tree, hf_iapp_auth_trailer, tvb, offset, len, ENC_NA);\r\nbreak;\r\n}\r\n}\r\nstatic void dissect_authinfo(proto_item *pitem, tvbuff_t *tvb, int offset, int sumlen)\r\n{\r\nproto_tree *authtree, *value_tree;\r\nguint8 pdu_type;\r\nguint16 len;\r\nauthtree = proto_item_add_subtree(pitem, ett_iapp_auth);\r\nwhile (sumlen > 0)\r\n{\r\npdu_type = tvb_get_guint8(tvb, offset);\r\nlen = tvb_get_ntohs(tvb, offset+1);\r\nvalue_tree = proto_tree_add_subtree_format(authtree, tvb, offset, len + 3,\r\nett_iapp_authinfo, NULL, "%s (%d)",\r\nval_to_str_const(pdu_type, iapp_auth_type_vals, "Unknown PDU Type"),\r\npdu_type);\r\nadd_authval_str(value_tree, pdu_type, len, tvb, offset+3);\r\nsumlen -= (len + 3);\r\noffset += (len + 3);\r\n}\r\n}\r\nstatic gboolean\r\nappend_pduval_str(proto_tree *tree, int type, int len, tvbuff_t *tvb, int offset,\r\ngboolean is_fhss)\r\n{\r\nint val;\r\nswitch (type)\r\n{\r\ncase IAPP_PDU_SSID:\r\nproto_tree_add_item(tree, hf_iapp_pdu_ssid, tvb, offset, len, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase IAPP_PDU_BSSID:\r\ncase IAPP_PDU_OLDBSSID:\r\ncase IAPP_PDU_MSADDR:\r\nproto_tree_add_item(tree, hf_iapp_pdu_bytes, tvb, offset, len, ENC_NA);\r\nbreak;\r\ncase IAPP_PDU_CAPABILITY:\r\ndissect_caps(tree, tvb, offset);\r\nbreak;\r\ncase IAPP_PDU_ANNOUNCEINT:\r\nval = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint_format_value(tree, hf_iapp_pdu_uint, tvb, offset, 2, val, "%d seconds", val);\r\nbreak;\r\ncase IAPP_PDU_HOTIMEOUT:\r\ncase IAPP_PDU_BEACONINT:\r\nval = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint_format_value(tree, hf_iapp_pdu_uint, tvb, offset, 2, val, "%d Kus", val);\r\nbreak;\r\ncase IAPP_PDU_MESSAGEID:\r\nproto_tree_add_item(tree, hf_iapp_pdu_uint, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase IAPP_PDU_PHYTYPE:\r\nproto_tree_add_item(tree, hf_iapp_pdu_phytype, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nis_fhss = (tvb_get_guint8(tvb, offset) == IAPP_PHY_FHSS);\r\nbreak;\r\ncase IAPP_PDU_REGDOMAIN:\r\nproto_tree_add_item(tree, hf_iapp_pdu_regdomain, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase IAPP_PDU_CHANNEL:\r\nif (is_fhss)\r\n{\r\nval = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint_format(tree, hf_iapp_pdu_uint, tvb, offset, 1, val,\r\n"Pattern set %d, sequence %d", ((val >> 6) & 3) + 1, (val & 31) + 1);\r\n}\r\nelse\r\nproto_tree_add_item(tree, hf_iapp_pdu_uint, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase IAPP_PDU_OUIIDENT:\r\nproto_tree_add_item(tree, hf_iapp_pdu_oui_ident, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\nreturn is_fhss;\r\n}\r\nstatic void\r\ndissect_pdus(tvbuff_t *tvb, packet_info *pinfo, int offset, proto_tree *pdutree, proto_item *pduitem, int pdulen)\r\n{\r\nguint8 pdu_type;\r\nguint16 len;\r\nproto_item *ti;\r\ngboolean is_fhss;\r\nproto_tree *subtree;\r\nif (!pdulen)\r\n{\r\nexpert_add_info(pinfo, pduitem, &ei_iapp_no_pdus);\r\nreturn;\r\n}\r\nis_fhss = FALSE;\r\nwhile (pdulen > 0)\r\n{\r\npdu_type = tvb_get_guint8(tvb, offset);\r\nlen = tvb_get_ntohs(tvb, offset+1);\r\nsubtree = proto_tree_add_subtree_format(pdutree, tvb, offset, len + 3,\r\nett_iapp_subpdu, &ti, "%s (%d)",\r\nval_to_str_const(pdu_type, iapp_pdu_type_vals, "Unknown PDU Type"),\r\npdu_type);\r\nis_fhss = append_pduval_str(subtree, pdu_type, len, tvb,\r\noffset+3, is_fhss);\r\nif (pdu_type == IAPP_PDU_AUTHINFO)\r\ndissect_authinfo(ti, tvb, offset + 3, len);\r\npdulen -= (len + 3);\r\noffset += (len + 3);\r\n}\r\n}\r\nstatic int\r\ndissect_iapp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti, *pduitem;\r\nproto_tree *iapp_tree, *pdutree;\r\nguint8 ia_version;\r\nguint8 ia_type;\r\nconst gchar *codestrval;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "IAPP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nia_version = tvb_get_guint8(tvb, 0);\r\nia_type = tvb_get_guint8(tvb, 1);\r\ncodestrval = val_to_str_const(ia_type, iapp_vals, "Unknown Packet");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s(%d) (version=%d)", codestrval, ia_type, ia_version);\r\nti = proto_tree_add_item(tree, proto_iapp, tvb, 0, -1, ENC_NA);\r\niapp_tree = proto_item_add_subtree(ti, ett_iapp);\r\nproto_tree_add_item(iapp_tree, hf_iapp_version, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(iapp_tree, hf_iapp_type, tvb, 1, 1, ENC_BIG_ENDIAN);\r\npdutree = proto_tree_add_subtree(iapp_tree, tvb, 2, -1,\r\nett_iapp_pdu, &pduitem, "Protocol data units");\r\ndissect_pdus(tvb, pinfo, 2, pdutree, pduitem,\r\ntvb_captured_length_remaining(tvb, 2));\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_iapp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_iapp_version,\r\n{ "Version", "iapp.version", FT_UINT8, BASE_DEC, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_iapp_type,\r\n{ "Type", "iapp.type", FT_UINT8, BASE_DEC, VALS(iapp_vals), 0x00, NULL, HFILL }\r\n},\r\n{ &hf_iapp_cap_forwarding,\r\n{ "Forwarding", "iapp.cap.forwarding", FT_BOOLEAN, 8, TFS(&tfs_yes_no), IAPP_CAP_FORWARDING, NULL, HFILL }\r\n},\r\n{ &hf_iapp_cap_wep,\r\n{ "WEP", "iapp.cap.wep", FT_BOOLEAN, 8, TFS(&tfs_yes_no), IAPP_CAP_WEP, NULL, HFILL }\r\n},\r\n{ &hf_iapp_auth_status,\r\n{ "Status", "iapp.auth.status", FT_UINT8, BASE_DEC, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_iapp_auth_uint,\r\n{ "Value", "iapp.auth.uint", FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_iapp_auth_string,\r\n{ "Value", "iapp.auth.string", FT_STRING, BASE_NONE, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_iapp_auth_ipaddr,\r\n{ "IP Address", "iapp.auth.ipaddr", FT_IPv4, BASE_NONE, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_iapp_auth_trailer,\r\n{ "Trailer", "iapp.auth.trailer", FT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_iapp_pdu_ssid,\r\n{ "SSID", "iapp.pdu.ssid", FT_STRING, BASE_NONE, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_iapp_pdu_bytes,\r\n{ "Value", "iapp.pdu.bytes", FT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_iapp_pdu_uint,\r\n{ "Value", "iapp.pdu.uint", FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_iapp_pdu_phytype,\r\n{ "PHY Type", "iapp.pdu.phytype", FT_UINT8, BASE_DEC, VALS(iapp_phy_vals), 0x00, NULL, HFILL }\r\n},\r\n{ &hf_iapp_pdu_regdomain,\r\n{ "Reg domain", "iapp.pdu.regdomain", FT_UINT8, BASE_DEC, VALS(iapp_dom_vals), 0x00, NULL, HFILL }\r\n},\r\n{ &hf_iapp_pdu_oui_ident,\r\n{ "OUI", "iapp.pdu.oui_ident", FT_UINT24, BASE_DEC, VALS(oui_vals), 0x00, NULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_iapp,\r\n&ett_iapp_pdu,\r\n&ett_iapp_subpdu,\r\n&ett_iapp_cap,\r\n&ett_iapp_auth,\r\n&ett_iapp_authinfo\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_iapp_no_pdus, { "iapp.no_pdus", PI_PROTOCOL, PI_NOTE, "No PDUs found", EXPFILL }},\r\n};\r\nexpert_module_t* expert_iapp;\r\nproto_iapp = proto_register_protocol("Inter-Access-Point Protocol", "IAPP", "iapp");\r\nproto_register_field_array(proto_iapp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_iapp = expert_register_protocol(proto_iapp);\r\nexpert_register_field_array(expert_iapp, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_iapp(void)\r\n{\r\ndissector_handle_t iapp_handle;\r\niapp_handle = create_dissector_handle(dissect_iapp, proto_iapp);\r\ndissector_add_uint("udp.port", UDP_PORT_IAPP, iapp_handle);\r\n}
