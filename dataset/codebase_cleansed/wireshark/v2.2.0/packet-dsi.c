static gint\r\ndissect_dsi_open_session(tvbuff_t *tvb, proto_tree *dsi_tree, gint offset, gint dsi_length)\r\n{\r\nproto_tree *tree;\r\nguint8 type;\r\nguint8 len;\r\ntree = proto_tree_add_subtree(dsi_tree, tvb, offset, -1, ett_dsi_open, NULL, "Open Session");\r\nwhile( dsi_length >2 ) {\r\ntype = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_dsi_open_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nlen = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_dsi_open_len, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nswitch (type) {\r\ncase 0:\r\nproto_tree_add_item(tree, hf_dsi_open_quantum, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 1:\r\nproto_tree_add_item(tree, hf_dsi_open_quantum, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 2:\r\nproto_tree_add_item(tree, hf_dsi_replay_cache_size, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tree, hf_dsi_open_option, tvb, offset, len, ENC_NA);\r\n}\r\ndsi_length -= len + 2;\r\noffset += len;\r\n}\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_dsi_attention(tvbuff_t *tvb, proto_tree *dsi_tree, gint offset)\r\n{\r\nproto_tree *tree;\r\nproto_item *ti;\r\nguint16 flag;\r\nif (!tvb_reported_length_remaining(tvb,offset))\r\nreturn offset;\r\nflag = tvb_get_ntohs(tvb, offset);\r\ntree = proto_tree_add_subtree(dsi_tree, tvb, offset, -1, ett_dsi_attn, NULL, "Attention");\r\nti = proto_tree_add_item(tree, hf_dsi_attn_flag, tvb, offset, 2, ENC_BIG_ENDIAN);\r\ntree = proto_item_add_subtree(ti, ett_dsi_attn_flag);\r\nproto_tree_add_item(tree, hf_dsi_attn_flag_shutdown, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_dsi_attn_flag_crash, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_dsi_attn_flag_msg, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_dsi_attn_flag_reconnect, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nif ((flag & 0xf000) != 0x3000)\r\nproto_tree_add_item(tree, hf_dsi_attn_flag_time, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nelse\r\nproto_tree_add_item(tree, hf_dsi_attn_flag_bitmap, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_dsi_packet(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *dsi_tree;\r\nproto_item *dsi_ti;\r\nguint8 dsi_flags,dsi_command;\r\nguint16 dsi_requestid;\r\ngint32 dsi_code;\r\nguint32 dsi_length;\r\nguint32 dsi_reserved;\r\nstruct aspinfo aspinfo;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "DSI");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ndsi_flags = tvb_get_guint8(tvb, 0);\r\ndsi_command = tvb_get_guint8(tvb, 1);\r\ndsi_requestid = tvb_get_ntohs(tvb, 2);\r\ndsi_code = tvb_get_ntohl(tvb, 4);\r\ndsi_length = tvb_get_ntohl(tvb, 8);\r\ndsi_reserved = tvb_get_ntohl(tvb, 12);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s %s (%u)",\r\nval_to_str(dsi_flags, flag_vals,\r\n"Unknown flag (0x%02x)"),\r\nval_to_str_ext(dsi_command, &func_vals_ext,\r\n"Unknown function (0x%02x)"),\r\ndsi_requestid);\r\ndsi_ti = proto_tree_add_item(tree, proto_dsi, tvb, 0, -1, ENC_NA);\r\ndsi_tree = proto_item_add_subtree(dsi_ti, ett_dsi);\r\nif (tree) {\r\nproto_tree_add_uint(dsi_tree, hf_dsi_flags, tvb,\r\n0, 1, dsi_flags);\r\nproto_tree_add_uint(dsi_tree, hf_dsi_command, tvb,\r\n1, 1, dsi_command);\r\nproto_tree_add_uint(dsi_tree, hf_dsi_requestid, tvb,\r\n2, 2, dsi_requestid);\r\nswitch (dsi_flags) {\r\ncase DSIFL_REQUEST:\r\nproto_tree_add_int(dsi_tree, hf_dsi_offset, tvb,\r\n4, 4, dsi_code);\r\nbreak;\r\ncase DSIFL_REPLY:\r\nproto_tree_add_int(dsi_tree, hf_dsi_error, tvb,\r\n4, 4, dsi_code);\r\nbreak;\r\n}\r\nproto_tree_add_uint_format_value(dsi_tree, hf_dsi_length, tvb,\r\n8, 4, dsi_length,\r\n"%u bytes", dsi_length);\r\nproto_tree_add_uint(dsi_tree, hf_dsi_reserved, tvb,\r\n12, 4, dsi_reserved);\r\n}\r\nswitch (dsi_command) {\r\ncase DSIFUNC_OPEN:\r\nif (tree) {\r\ndissect_dsi_open_session(tvb, dsi_tree, DSI_BLOCKSIZ, dsi_length);\r\n}\r\nbreak;\r\ncase DSIFUNC_ATTN:\r\nif (tree) {\r\ndissect_dsi_attention(tvb, dsi_tree, DSI_BLOCKSIZ);\r\n}\r\nbreak;\r\ncase DSIFUNC_STAT:\r\nif (tree && (dsi_flags == DSIFL_REPLY)) {\r\ntvbuff_t *new_tvb;\r\nnew_tvb = tvb_new_subset_remaining(tvb, DSI_BLOCKSIZ);\r\ncall_dissector(afp_server_status_handle, new_tvb, pinfo, dsi_tree);\r\n}\r\nbreak;\r\ncase DSIFUNC_CMD:\r\ncase DSIFUNC_WRITE:\r\n{\r\ntvbuff_t *new_tvb;\r\naspinfo.reply = (dsi_flags == DSIFL_REPLY);\r\naspinfo.command = dsi_command;\r\naspinfo.seq = dsi_requestid;\r\naspinfo.code = dsi_code;\r\nproto_item_set_len(dsi_ti, DSI_BLOCKSIZ);\r\nnew_tvb = tvb_new_subset_remaining(tvb, DSI_BLOCKSIZ);\r\ncall_dissector_with_data(afp_handle, new_tvb, pinfo, tree, &aspinfo);\r\n}\r\nbreak;\r\ndefault:\r\ncall_data_dissector(tvb_new_subset_remaining(tvb, DSI_BLOCKSIZ),\r\npinfo, dsi_tree);\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic guint\r\nget_dsi_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nguint32 plen;\r\nguint8 dsi_flags,dsi_command;\r\ndsi_flags = tvb_get_guint8(tvb, offset);\r\ndsi_command = tvb_get_guint8(tvb, offset+ 1);\r\nif ( dsi_flags > DSIFL_MAX || !dsi_command || dsi_command > DSIFUNC_MAX)\r\n{\r\nreturn tvb_captured_length_remaining(tvb, offset);\r\n}\r\nplen = tvb_get_ntohl(tvb, offset+8);\r\nreturn plen + 16;\r\n}\r\nstatic int\r\ndissect_dsi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, tree, dsi_desegment, 12,\r\nget_dsi_pdu_len, dissect_dsi_packet, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_dsi(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_dsi_flags,\r\n{ "Flags", "dsi.flags",\r\nFT_UINT8, BASE_HEX, VALS(flag_vals), 0x0,\r\n"Indicates request or reply.", HFILL }},\r\n{ &hf_dsi_command,\r\n{ "Command", "dsi.command",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &func_vals_ext, 0x0,\r\n"Represents a DSI command.", HFILL }},\r\n{ &hf_dsi_requestid,\r\n{ "Request ID", "dsi.requestid",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Keeps track of which request this is. Replies must match a Request. IDs must be generated in sequential order.", HFILL }},\r\n{ &hf_dsi_offset,\r\n{ "Data offset", "dsi.data_offset",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_dsi_error,\r\n{ "Error code", "dsi.error_code",\r\nFT_INT32, BASE_DEC|BASE_EXT_STRING, &asp_error_vals_ext, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_dsi_length,\r\n{ "Length", "dsi.length",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Total length of the data that follows the DSI header.", HFILL }},\r\n{ &hf_dsi_reserved,\r\n{ "Reserved", "dsi.reserved",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"Reserved for future use. Should be set to zero.", HFILL }},\r\n{ &hf_dsi_open_type,\r\n{ "Option", "dsi.open_type",\r\nFT_UINT8, BASE_DEC, VALS(dsi_open_type_vals), 0x0,\r\n"Open session option type.", HFILL }},\r\n{ &hf_dsi_open_len,\r\n{ "Length", "dsi.open_len",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Open session option len", HFILL }},\r\n{ &hf_dsi_open_quantum,\r\n{ "Quantum", "dsi.open_quantum",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Server/Attention quantum", HFILL }},\r\n{ &hf_dsi_replay_cache_size,\r\n{ "Replay", "dsi.replay_cache",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Replay cache size", HFILL }},\r\n{ &hf_dsi_open_option,\r\n{ "Option", "dsi.open_option",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Open session options (undecoded)", HFILL }},\r\n{ &hf_dsi_attn_flag,\r\n{ "Flags", "dsi.attn_flag",\r\nFT_UINT16, BASE_HEX|BASE_EXT_STRING, &dsi_attn_flag_vals_ext, 0xf000,\r\n"Server attention flag", HFILL }},\r\n{ &hf_dsi_attn_flag_shutdown,\r\n{ "Shutdown", "dsi.attn_flag.shutdown",\r\nFT_BOOLEAN, 16, NULL, 1<<15,\r\n"Attention flag, server is shutting down", HFILL }},\r\n{ &hf_dsi_attn_flag_crash,\r\n{ "Crash", "dsi.attn_flag.crash",\r\nFT_BOOLEAN, 16, NULL, 1<<14,\r\n"Attention flag, server crash bit", HFILL }},\r\n{ &hf_dsi_attn_flag_msg,\r\n{ "Message", "dsi.attn_flag.msg",\r\nFT_BOOLEAN, 16, NULL, 1<<13,\r\n"Attention flag, server message bit", HFILL }},\r\n{ &hf_dsi_attn_flag_reconnect,\r\n{ "Don't reconnect", "dsi.attn_flag.reconnect",\r\nFT_BOOLEAN, 16, NULL, 1<<12,\r\n"Attention flag, don't reconnect bit", HFILL }},\r\n{ &hf_dsi_attn_flag_time,\r\n{ "Minutes", "dsi.attn_flag.time",\r\nFT_UINT16, BASE_DEC, NULL, 0xfff,\r\n"Number of minutes", HFILL }},\r\n{ &hf_dsi_attn_flag_bitmap,\r\n{ "Bitmap", "dsi.attn_flag.bitmap",\r\nFT_UINT16, BASE_HEX, NULL, 0xfff,\r\n"Attention extended bitmap", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_dsi,\r\n&ett_dsi_open,\r\n&ett_dsi_attn,\r\n&ett_dsi_attn_flag\r\n};\r\nmodule_t *dsi_module;\r\nproto_dsi = proto_register_protocol("Data Stream Interface", "DSI", "dsi");\r\nproto_register_field_array(proto_dsi, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\ndsi_module = prefs_register_protocol(proto_dsi, NULL);\r\nprefs_register_bool_preference(dsi_module, "desegment",\r\n"Reassemble DSI messages spanning multiple TCP segments",\r\n"Whether the DSI dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&dsi_desegment);\r\n}\r\nvoid\r\nproto_reg_handoff_dsi(void)\r\n{\r\ndissector_handle_t dsi_handle;\r\ndsi_handle = create_dissector_handle(dissect_dsi, proto_dsi);\r\ndissector_add_uint("tcp.port", TCP_PORT_DSI, dsi_handle);\r\nafp_handle = find_dissector_add_dependency("afp", proto_dsi);\r\nafp_server_status_handle = find_dissector_add_dependency("afp_server_status", proto_dsi);\r\n}
