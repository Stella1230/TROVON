static int\r\npacket_is_tcpencap(tvbuff_t *tvb, packet_info *pinfo, guint32 offset)\r\n{\r\nif (\r\ntvb_get_ntohl(tvb, offset + 0) != 0 ||\r\n(tvb_get_ntohs(tvb, offset + 6) & 0xfff) != 0 ||\r\n(tvb_get_guint8(tvb, offset + 13) != 17 &&\r\ntvb_get_guint8(tvb, offset + 13) != 50)\r\n) {\r\nreturn FALSE;\r\n}\r\nif(check_if_ndmp(tvb, pinfo)){\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\ndissect_tcpencap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_tree *tcpencap_tree = NULL;\r\nproto_tree *tcpencap_unknown_tree = NULL;\r\nproto_item *tree_item = NULL;\r\nproto_item *unknown_item = NULL;\r\ntvbuff_t *next_tvb;\r\nguint32 reported_length = tvb_reported_length(tvb);\r\nguint32 offset;\r\nguint8 protocol;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "TCPENCAP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (tvb_get_ntohl(tvb, 0) == 0x01f401f4) {\r\nprotocol = TCP_ENCAP_P_UDP;\r\n} else {\r\nprotocol = TCP_ENCAP_P_ESP;\r\n}\r\nif (tree) {\r\ntree_item = proto_tree_add_item(tree, proto_tcpencap, tvb, 0, -1, ENC_NA);\r\ntcpencap_tree = proto_item_add_subtree(tree_item, ett_tcpencap);\r\noffset = reported_length - TRAILERLENGTH;\r\nunknown_item = proto_tree_add_item(tcpencap_tree, hf_tcpencap_unknown, tvb,\r\noffset, TRAILERLENGTH, ENC_NA);\r\ntcpencap_unknown_tree = proto_item_add_subtree(unknown_item, ett_tcpencap_unknown);\r\nproto_tree_add_item(tcpencap_unknown_tree, hf_tcpencap_zero, tvb, offset + 0, 4, ENC_NA);\r\nproto_tree_add_item(tcpencap_unknown_tree, hf_tcpencap_seq, tvb, offset + 4, 2, ENC_BIG_ENDIAN);\r\nif (protocol == TCP_ENCAP_P_UDP) {\r\nproto_tree_add_item(tcpencap_unknown_tree, hf_tcpencap_ike_direction, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\r\n} else {\r\nproto_tree_add_item(tcpencap_unknown_tree, hf_tcpencap_esp_zero, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(tcpencap_unknown_tree, hf_tcpencap_magic, tvb, offset + 8, 5, ENC_NA);\r\nproto_tree_add_item(tcpencap_unknown_tree, hf_tcpencap_proto, tvb, offset + 13, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tcpencap_unknown_tree, hf_tcpencap_magic2, tvb, offset + 14, 2, ENC_NA);\r\n}\r\nnext_tvb = tvb_new_subset(tvb, 0, reported_length - TRAILERLENGTH , -1);\r\nif (protocol == TCP_ENCAP_P_UDP) {\r\ncall_dissector(udp_handle, next_tvb, pinfo, tree);\r\n} else {\r\ncall_dissector(esp_handle, next_tvb, pinfo, tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\ndissect_tcpencap_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nguint32 reported_length = tvb_reported_length(tvb);\r\nguint32 captured_length = tvb_captured_length(tvb);\r\nif (reported_length <= TRAILERLENGTH + 8 ||\r\n(reported_length - captured_length) > (TRAILERLENGTH - 13) ||\r\n!packet_is_tcpencap(tvb, pinfo, reported_length - TRAILERLENGTH) ) {\r\nreturn FALSE;\r\n}\r\ndissect_tcpencap(tvb, pinfo, tree, data);\r\nreturn TRUE;\r\n}\r\nvoid\r\nproto_register_tcpencap(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_tcpencap_unknown,\r\n{ "Unknown trailer", "tcpencap.unknown", FT_BYTES, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_tcpencap_zero,\r\n{ "All zero", "tcpencap.zero", FT_BYTES, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_tcpencap_seq,\r\n{ "Sequence number", "tcpencap.seq", FT_UINT16, BASE_HEX, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_tcpencap_esp_zero,\r\n{ "ESP zero", "tcpencap.espzero", FT_UINT16, BASE_HEX, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_tcpencap_ike_direction,\r\n{ "ISAKMP traffic direction", "tcpencap.ikedirection", FT_UINT16, BASE_HEX, VALS(tcpencap_ikedir_vals),\r\n0x0, NULL, HFILL }},\r\n{ &hf_tcpencap_magic,\r\n{ "Magic number", "tcpencap.magic", FT_BYTES, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_tcpencap_proto,\r\n{ "Protocol", "tcpencap.proto", FT_UINT8, BASE_HEX, VALS(tcpencap_proto_vals),\r\n0x0, NULL, HFILL }},\r\n{ &hf_tcpencap_magic2,\r\n{ "Magic 2", "tcpencap.magic2", FT_BYTES, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_tcpencap,\r\n&ett_tcpencap_unknown,\r\n};\r\nmodule_t *tcpencap_module;\r\nproto_tcpencap = proto_register_protocol(\r\n"TCP Encapsulation of IPsec Packets", "TCPENCAP", "tcpencap");\r\nproto_register_field_array(proto_tcpencap, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\ntcpencap_module = prefs_register_protocol(proto_tcpencap, proto_reg_handoff_tcpencap);\r\nprefs_register_uint_preference(tcpencap_module, "tcp.port", "IPSEC TCP Port",\r\n"Set the port for IPSEC/ISAKMP messages (typically 10000)",\r\n10, &global_tcpencap_tcp_port);\r\n}\r\nvoid\r\nproto_reg_handoff_tcpencap(void)\r\n{\r\nstatic dissector_handle_t tcpencap_handle;\r\nstatic gboolean initialized = FALSE;\r\nstatic guint tcpencap_tcp_port = 0;\r\nif (!initialized) {\r\ntcpencap_handle = create_dissector_handle(dissect_tcpencap, proto_tcpencap);\r\nesp_handle = find_dissector_add_dependency("esp", proto_tcpencap);\r\nudp_handle = find_dissector_add_dependency("udp", proto_tcpencap);\r\nheur_dissector_add("tcp", dissect_tcpencap_heur, "TCP Encapsulation of IPsec Packets", "ipsec_tcp", proto_tcpencap, HEURISTIC_ENABLE);\r\ninitialized = TRUE;\r\n}\r\nif(tcpencap_tcp_port != 0 && tcpencap_tcp_port != global_tcpencap_tcp_port){\r\ndissector_delete_uint("tcp.port", tcpencap_tcp_port, tcpencap_handle);\r\n}\r\nif(global_tcpencap_tcp_port != 0 && tcpencap_tcp_port != global_tcpencap_tcp_port) {\r\ndissector_add_uint("tcp.port", global_tcpencap_tcp_port, tcpencap_handle);\r\n}\r\n}
