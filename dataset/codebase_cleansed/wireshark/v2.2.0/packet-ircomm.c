static int dissect_cooked_ircomm(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *ircomm_tree, *ctrl_tree;\r\nguint offset = 0;\r\nguint clen;\r\ngint len = tvb_reported_length(tvb);\r\nif (len == 0)\r\nreturn len;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "IrCOMM");\r\nclen = tvb_get_guint8(tvb, offset);\r\nlen -= 1 + clen;\r\nif (len > 0)\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Clen=%d, UserData: %d byte%s", clen, len, (len > 1)? "s": "");\r\nelse\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Clen=%d", clen);\r\nti = proto_tree_add_item(tree, proto_ircomm, tvb, 0, -1, ENC_NA);\r\nircomm_tree = proto_item_add_subtree(ti, ett_ircomm);\r\nti = proto_tree_add_item(ircomm_tree, hf_control, tvb, 0, clen + 1, ENC_NA);\r\nctrl_tree = proto_item_add_subtree(ti, ett_ircomm_ctrl);\r\nproto_tree_add_item(ctrl_tree, hf_control_len, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\ncall_data_dissector(tvb_new_subset_length(tvb, offset, clen), pinfo, ctrl_tree);\r\noffset += clen;\r\ncall_data_dissector(tvb_new_subset_remaining(tvb, offset), pinfo, ircomm_tree);\r\nreturn len;\r\n}\r\nstatic int dissect_raw_ircomm(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree, void* data _U_)\r\n{\r\nguint len = tvb_reported_length(tvb);\r\nproto_item* ti;\r\nproto_tree* ircomm_tree;\r\nif (len == 0)\r\nreturn 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "IrCOMM");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "User Data: %d byte%s", len, (len > 1)? "s": "");\r\nti = proto_tree_add_item(tree, proto_ircomm, tvb, 0, -1, ENC_NA);\r\nircomm_tree = proto_item_add_subtree(ti, ett_ircomm);\r\ncall_data_dissector(tvb, pinfo, ircomm_tree);\r\nreturn len;\r\n}\r\nstatic gboolean dissect_ircomm_parameters(tvbuff_t* tvb, guint offset, packet_info* pinfo _U_,\r\nproto_tree* tree, guint list_index, guint8 attr_type, guint8 circuit_id _U_)\r\n{\r\nguint len;\r\nguint n = 0;\r\nproto_item* ti;\r\nproto_tree* p_tree;\r\nchar buf[256];\r\nguint8 pv;\r\nif (!check_iap_octet_result(tvb, tree, offset, "Parameters", attr_type))\r\nreturn TRUE;\r\nif (tree)\r\n{\r\nlen = tvb_get_ntohs(tvb, offset) + offset + 2;\r\noffset += 2;\r\nwhile (offset < len)\r\n{\r\nguint8 p_len = tvb_get_guint8(tvb, offset + 1);\r\nti = proto_tree_add_item(tree, hf_ircomm_param, tvb, offset, p_len + 2, ENC_NA);\r\np_tree = proto_item_add_subtree(ti, ett_param[list_index * MAX_PARAMETERS + n]);\r\nbuf[0] = 0;\r\nswitch (tvb_get_guint8(tvb, offset))\r\n{\r\ncase IRCOMM_SERVICE_TYPE:\r\nproto_item_append_text(ti, ": Service Type (");\r\npv = tvb_get_guint8(tvb, offset+2);\r\nif (pv & IRCOMM_3_WIRE_RAW)\r\ng_strlcat(buf, ", 3-Wire raw", 256);\r\nif (pv & IRCOMM_3_WIRE)\r\ng_strlcat(buf, ", 3-Wire", 256);\r\nif (pv & IRCOMM_9_WIRE)\r\ng_strlcat(buf, ", 9-Wire", 256);\r\nif (pv & IRCOMM_CENTRONICS)\r\ng_strlcat(buf, ", Centronics", 256);\r\ng_strlcat(buf, ")", 256);\r\nproto_item_append_text(ti, "%s", buf+2);\r\nbreak;\r\ncase IRCOMM_PORT_TYPE:\r\nproto_item_append_text(ti, ": Port Type (");\r\npv = tvb_get_guint8(tvb, offset+2);\r\nif (pv & IRCOMM_SERIAL)\r\ng_strlcat(buf, ", serial", 256);\r\nif (pv & IRCOMM_PARALLEL)\r\ng_strlcat(buf, ", parallel", 256);\r\ng_strlcat(buf, ")", 256);\r\nproto_item_append_text(ti, "%s", buf+2);\r\nbreak;\r\ncase IRCOMM_PORT_NAME:\r\nproto_item_append_text(ti, ": Port Name (\"%s\")",\r\ntvb_format_text(tvb, offset+2, p_len));\r\nbreak;\r\ndefault:\r\nproto_item_append_text(ti, ": unknown");\r\n}\r\noffset = dissect_param_tuple(tvb, p_tree, offset);\r\nn++;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean dissect_ircomm_ttp_lsap(tvbuff_t* tvb, guint offset, packet_info* pinfo,\r\nproto_tree* tree, guint list_index _U_, guint8 attr_type, guint8 circuit_id)\r\n{\r\nguint8 dlsap;\r\nif ((dlsap = check_iap_lsap_result(tvb, tree, offset, "IrDA:TinyTP:LsapSel", attr_type)) == 0)\r\nreturn FALSE;\r\nadd_lmp_conversation(pinfo, dlsap, TRUE, ircomm_cooked_handle, circuit_id);\r\nreturn FALSE;\r\n}\r\nstatic gboolean dissect_ircomm_lmp_lsap(tvbuff_t* tvb, guint offset, packet_info* pinfo,\r\nproto_tree* tree, guint list_index _U_, guint8 attr_type, guint8 circuit_id)\r\n{\r\nguint8 dlsap;\r\nif ((dlsap = check_iap_lsap_result(tvb, tree, offset, "IrDA:IrLMP:LsapSel", attr_type)) == 0)\r\nreturn FALSE;\r\nadd_lmp_conversation(pinfo, dlsap, FALSE, ircomm_raw_handle, circuit_id);\r\nreturn FALSE;\r\n}\r\nvoid proto_register_ircomm(void)\r\n{\r\nguint i;\r\nstatic hf_register_info hf_ircomm[] = {\r\n{ &hf_ircomm_param,\r\n{ "IrCOMM Parameter", "ircomm.parameter",\r\nFT_NONE, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n#if 0\r\n{ &hf_param_pi,\r\n{ "Parameter Identifier", "ircomm.pi",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_param_pl,\r\n{ "Parameter Length", "ircomm.pl",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_param_pv,\r\n{ "Parameter Value", "ircomm.pv",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n#endif\r\n{ &hf_control,\r\n{ "Control Channel", "ircomm.control",\r\nFT_NONE, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_control_len,\r\n{ "Clen", "ircomm.control.len",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }}\r\n};\r\nstatic gint* ett[] = {\r\n&ett_ircomm,\r\n&ett_ircomm_ctrl\r\n};\r\ngint* ett_p[MAX_IAP_ENTRIES * MAX_PARAMETERS];\r\nproto_ircomm = proto_register_protocol("IrCOMM Protocol", "IrCOMM", "ircomm");\r\nregister_dissector("ircomm_raw", dissect_raw_ircomm, proto_ircomm);\r\nregister_dissector("ircomm_cooked", dissect_cooked_ircomm, proto_ircomm);\r\nproto_register_field_array(proto_ircomm, hf_ircomm, array_length(hf_ircomm));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nfor (i = 0; i < MAX_IAP_ENTRIES * MAX_PARAMETERS; i++)\r\n{\r\nett_param[i] = -1;\r\nett_p[i] = &ett_param[i];\r\n}\r\nproto_register_subtree_array(ett_p, MAX_IAP_ENTRIES * MAX_PARAMETERS);\r\n}\r\nvoid\r\nproto_reg_handoff_ircomm(void) {\r\nircomm_raw_handle = find_dissector("ircomm_raw");\r\nircomm_cooked_handle = find_dissector("ircomm_cooked");\r\n}
