wtap_open_return_val peekclassic_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\npeekclassic_header_t ep_hdr;\r\ntime_t reference_time;\r\nint file_encap;\r\npeekclassic_t *peekclassic;\r\ng_assert(sizeof(ep_hdr.master) == PEEKCLASSIC_MASTER_HDR_SIZE);\r\nif (!wtap_read_bytes(wth->fh, &ep_hdr.master,\r\n(int)sizeof(ep_hdr.master), err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nep_hdr.master.version &= ~0x80;\r\nswitch (ep_hdr.master.version) {\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\ng_assert(sizeof(ep_hdr.secondary.v567) ==\r\nPEEKCLASSIC_V567_HDR_SIZE);\r\nif (!wtap_read_bytes(wth->fh, &ep_hdr.secondary.v567,\r\n(int)sizeof(ep_hdr.secondary.v567), err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif ((0 != ep_hdr.secondary.v567.reserved[0]) ||\r\n(0 != ep_hdr.secondary.v567.reserved[1]) ||\r\n(0 != ep_hdr.secondary.v567.reserved[2])) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nep_hdr.secondary.v567.mediaType =\r\ng_ntohl(ep_hdr.secondary.v567.mediaType);\r\nep_hdr.secondary.v567.physMedium =\r\ng_ntohl(ep_hdr.secondary.v567.physMedium);\r\nswitch (ep_hdr.secondary.v567.physMedium) {\r\ncase 0:\r\nswitch (ep_hdr.secondary.v567.mediaType) {\r\ncase 0:\r\nfile_encap = WTAP_ENCAP_ETHERNET;\r\nbreak;\r\ncase 1:\r\nfile_encap = WTAP_ENCAP_TOKEN_RING;\r\nbreak;\r\ndefault:\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nbreak;\r\ncase 1:\r\nswitch (ep_hdr.secondary.v567.mediaType) {\r\ncase 0:\r\nfile_encap = WTAP_ENCAP_IEEE_802_11_WITH_RADIO;\r\nbreak;\r\ndefault:\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nbreak;\r\ndefault:\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nep_hdr.secondary.v567.filelength =\r\ng_ntohl(ep_hdr.secondary.v567.filelength);\r\nep_hdr.secondary.v567.numPackets =\r\ng_ntohl(ep_hdr.secondary.v567.numPackets);\r\nep_hdr.secondary.v567.timeDate =\r\ng_ntohl(ep_hdr.secondary.v567.timeDate);\r\nep_hdr.secondary.v567.timeStart =\r\ng_ntohl(ep_hdr.secondary.v567.timeStart);\r\nep_hdr.secondary.v567.timeStop =\r\ng_ntohl(ep_hdr.secondary.v567.timeStop);\r\nep_hdr.secondary.v567.appVers =\r\ng_ntohl(ep_hdr.secondary.v567.appVers);\r\nep_hdr.secondary.v567.linkSpeed =\r\ng_ntohl(ep_hdr.secondary.v567.linkSpeed);\r\nreference_time = ep_hdr.secondary.v567.timeDate - mac2unix;\r\nbreak;\r\ndefault:\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\npeekclassic = (peekclassic_t *)g_malloc(sizeof(peekclassic_t));\r\nwth->priv = (void *)peekclassic;\r\npeekclassic->reference_time = reference_time;\r\nswitch (ep_hdr.master.version) {\r\ncase 5:\r\ncase 6:\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_PEEKCLASSIC_V56;\r\nwth->file_encap = WTAP_ENCAP_PER_PACKET;\r\nwth->subtype_read = peekclassic_read_v56;\r\nwth->subtype_seek_read = peekclassic_seek_read_v56;\r\nbreak;\r\ncase 7:\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_PEEKCLASSIC_V7;\r\nwth->file_encap = file_encap;\r\nwth->subtype_read = peekclassic_read_v7;\r\nwth->subtype_seek_read = peekclassic_seek_read_v7;\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\n}\r\nwth->snapshot_length = 0;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean peekclassic_read_v7(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\nint sliceLength;\r\n*data_offset = file_tell(wth->fh);\r\nsliceLength = peekclassic_read_packet_v7(wth, wth->fh, &wth->phdr,\r\nwth->frame_buffer, err, err_info);\r\nif (sliceLength < 0)\r\nreturn FALSE;\r\nif ((guint32)sliceLength > wth->phdr.caplen) {\r\nif (!file_skip(wth->fh, sliceLength - wth->phdr.caplen, err))\r\nreturn FALSE;\r\n}\r\nif (sliceLength & 0x01) {\r\nif (!file_skip(wth->fh, 1, err))\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean peekclassic_seek_read_v7(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (peekclassic_read_packet_v7(wth, wth->random_fh, phdr, buf,\r\nerr, err_info) == -1) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int peekclassic_read_packet_v7(wtap *wth, FILE_T fh,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nguint8 ep_pkt[PEEKCLASSIC_V7_PKT_SIZE];\r\n#if 0\r\nguint16 protoNum;\r\n#endif\r\nguint16 length;\r\nguint16 sliceLength;\r\n#if 0\r\nguint8 flags;\r\n#endif\r\nguint8 status;\r\nguint64 timestamp;\r\ntime_t tsecs;\r\nguint32 tusecs;\r\nguint8 radio_info[RADIO_INFO_SIZE];\r\nif (!wtap_read_bytes_or_eof(fh, ep_pkt, sizeof(ep_pkt), err, err_info))\r\nreturn -1;\r\n#if 0\r\nprotoNum = pntoh16(&ep_pkt[PEEKCLASSIC_V7_PROTONUM_OFFSET]);\r\n#endif\r\nlength = pntoh16(&ep_pkt[PEEKCLASSIC_V7_LENGTH_OFFSET]);\r\nsliceLength = pntoh16(&ep_pkt[PEEKCLASSIC_V7_SLICE_LENGTH_OFFSET]);\r\n#if 0\r\nflags = ep_pkt[PEEKCLASSIC_V7_FLAGS_OFFSET];\r\n#endif\r\nstatus = ep_pkt[PEEKCLASSIC_V7_STATUS_OFFSET];\r\ntimestamp = pntoh64(&ep_pkt[PEEKCLASSIC_V7_TIMESTAMP_OFFSET]);\r\nif (0 == sliceLength) {\r\nsliceLength = length;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\ntsecs = (time_t) (timestamp/1000000);\r\ntusecs = (guint32) (timestamp - tsecs*1000000);\r\nphdr->ts.secs = tsecs - mac2unix;\r\nphdr->ts.nsecs = tusecs * 1000;\r\nphdr->len = length;\r\nphdr->caplen = sliceLength;\r\nswitch (wth->file_encap) {\r\ncase WTAP_ENCAP_IEEE_802_11_WITH_RADIO:\r\nmemset(&phdr->pseudo_header.ieee_802_11, 0, sizeof(phdr->pseudo_header.ieee_802_11));\r\nphdr->pseudo_header.ieee_802_11.fcs_len = 0;\r\nphdr->pseudo_header.ieee_802_11.decrypted = FALSE;\r\nphdr->pseudo_header.ieee_802_11.datapad = FALSE;\r\nphdr->pseudo_header.ieee_802_11.phy = PHDR_802_11_PHY_UNKNOWN;\r\nif (phdr->len < RADIO_INFO_SIZE || phdr->caplen < RADIO_INFO_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("peekclassic: 802.11 packet has length < 4");\r\nreturn -1;\r\n}\r\nphdr->len -= RADIO_INFO_SIZE;\r\nphdr->caplen -= RADIO_INFO_SIZE;\r\nsliceLength -= RADIO_INFO_SIZE;\r\nif (!wtap_read_bytes(fh, radio_info, RADIO_INFO_SIZE, err, err_info))\r\nreturn -1;\r\nphdr->pseudo_header.ieee_802_11.has_data_rate = TRUE;\r\nphdr->pseudo_header.ieee_802_11.data_rate = radio_info[0];\r\nphdr->pseudo_header.ieee_802_11.has_channel = TRUE;\r\nphdr->pseudo_header.ieee_802_11.channel = radio_info[1];\r\nphdr->pseudo_header.ieee_802_11.has_signal_percent = TRUE;\r\nphdr->pseudo_header.ieee_802_11.signal_percent = radio_info[2];\r\nif (phdr->len < 4 || phdr->caplen < 4) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("peekclassic: 802.11 packet has length < 8");\r\nreturn -1;\r\n}\r\nphdr->len -= 4;\r\nphdr->caplen -= 4;\r\nbreak;\r\ncase WTAP_ENCAP_ETHERNET:\r\nphdr->pseudo_header.eth.fcs_len = (status & 0x01) ? 0 : 4;\r\nbreak;\r\n}\r\nif (!wtap_read_packet_bytes(fh, buf, phdr->caplen, err, err_info))\r\nreturn -1;\r\nreturn sliceLength;\r\n}\r\nstatic gboolean peekclassic_read_v56(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\n*data_offset = file_tell(wth->fh);\r\nif (!peekclassic_read_packet_v56(wth, wth->fh, &wth->phdr,\r\nwth->frame_buffer, err, err_info))\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\nstatic gboolean peekclassic_seek_read_v56(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (!peekclassic_read_packet_v56(wth, wth->random_fh, phdr, buf,\r\nerr, err_info)) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean peekclassic_read_packet_v56(wtap *wth, FILE_T fh,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\npeekclassic_t *peekclassic = (peekclassic_t *)wth->priv;\r\nguint8 ep_pkt[PEEKCLASSIC_V56_PKT_SIZE];\r\nguint16 length;\r\nguint16 sliceLength;\r\n#if 0\r\nguint8 flags;\r\nguint8 status;\r\n#endif\r\nguint32 timestamp;\r\n#if 0\r\nguint16 destNum;\r\nguint16 srcNum;\r\n#endif\r\nguint16 protoNum;\r\n#if 0\r\nchar protoStr[8];\r\n#endif\r\nunsigned int i;\r\nif (!wtap_read_bytes_or_eof(fh, ep_pkt, sizeof(ep_pkt), err, err_info))\r\nreturn FALSE;\r\nlength = pntoh16(&ep_pkt[PEEKCLASSIC_V56_LENGTH_OFFSET]);\r\nsliceLength = pntoh16(&ep_pkt[PEEKCLASSIC_V56_SLICE_LENGTH_OFFSET]);\r\n#if 0\r\nflags = ep_pkt[PEEKCLASSIC_V56_FLAGS_OFFSET];\r\nstatus = ep_pkt[PEEKCLASSIC_V56_STATUS_OFFSET];\r\n#endif\r\ntimestamp = pntoh32(&ep_pkt[PEEKCLASSIC_V56_TIMESTAMP_OFFSET]);\r\n#if 0\r\ndestNum = pntoh16(&ep_pkt[PEEKCLASSIC_V56_DESTNUM_OFFSET]);\r\nsrcNum = pntoh16(&ep_pkt[PEEKCLASSIC_V56_SRCNUM_OFFSET]);\r\n#endif\r\nprotoNum = pntoh16(&ep_pkt[PEEKCLASSIC_V56_PROTONUM_OFFSET]);\r\n#if 0\r\nmemcpy(protoStr, &ep_pkt[PEEKCLASSIC_V56_PROTOSTR_OFFSET],\r\nsizeof protoStr);\r\n#endif\r\nif (0 == sliceLength) {\r\nsliceLength = length;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\nphdr->ts.secs = peekclassic->reference_time + (timestamp / 1000);\r\nphdr->ts.nsecs = 1000 * (timestamp % 1000) * 1000;\r\nphdr->len = length;\r\nphdr->caplen = sliceLength;\r\nphdr->pkt_encap = WTAP_ENCAP_UNKNOWN;\r\nfor (i=0; i<NUM_PEEKCLASSIC_ENCAPS; i++) {\r\nif (peekclassic_encap[i].protoNum == protoNum) {\r\nphdr->pkt_encap = peekclassic_encap[i].encap;\r\n}\r\n}\r\nswitch (phdr->pkt_encap) {\r\ncase WTAP_ENCAP_ETHERNET:\r\nphdr->pseudo_header.eth.fcs_len = 0;\r\nbreak;\r\n}\r\nreturn wtap_read_packet_bytes(fh, buf, sliceLength, err, err_info);\r\n}
