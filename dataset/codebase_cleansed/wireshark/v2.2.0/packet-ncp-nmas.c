static int\r\nnmas_string(tvbuff_t* tvb, int hfinfo, proto_tree *nmas_tree, int offset, gboolean little)\r\n{\r\nint foffset = offset;\r\nguint32 str_length;\r\nchar *buffer;\r\nguint32 i;\r\nguint16 c_char;\r\nguint32 length_remaining = 0;\r\nbuffer = (char *)wmem_alloc(wmem_packet_scope(), ITEM_LABEL_LENGTH+1);\r\nif (little) {\r\nstr_length = tvb_get_letohl(tvb, foffset);\r\n} else {\r\nstr_length = tvb_get_ntohl(tvb, foffset);\r\n}\r\nfoffset += 4;\r\nif (str_length >= ITEM_LABEL_LENGTH) {\r\nproto_tree_add_string(nmas_tree, hfinfo, tvb, foffset,\r\nlength_remaining + 4, "<String too long to process>");\r\nfoffset += length_remaining;\r\nreturn foffset;\r\n}\r\nif (str_length == 0) {\r\nproto_tree_add_string(nmas_tree, hfinfo, tvb, offset, 4,\r\n"<Not Specified>");\r\nreturn foffset;\r\n}\r\nfor ( i = 0; i < str_length; i++ ) {\r\nc_char = tvb_get_guint8(tvb, foffset );\r\nif (c_char<0x20 || c_char>0x7e) {\r\nif (c_char != 0x00) {\r\nc_char = 0x2e;\r\nbuffer[i] = c_char & 0xff;\r\n} else {\r\ni--;\r\nstr_length--;\r\n}\r\n} else {\r\nbuffer[i] = c_char & 0xff;\r\n}\r\nfoffset++;\r\nlength_remaining--;\r\nif (length_remaining==1) {\r\ni++;\r\nbreak;\r\n}\r\n}\r\nbuffer[i] = '\0';\r\nif (little) {\r\nstr_length = tvb_get_letohl(tvb, offset);\r\n} else {\r\nstr_length = tvb_get_ntohl(tvb, offset);\r\n}\r\nproto_tree_add_string(nmas_tree, hfinfo, tvb, offset+4, str_length, buffer);\r\nreturn foffset;\r\n}\r\nvoid\r\ndissect_nmas_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *ncp_tree, ncp_req_hash_value *request_value)\r\n{\r\nguint8 subfunc;\r\nguint32 msg_length=0, cur_string_len=0;\r\nguint32 foffset;\r\nguint32 subverb=0;\r\nguint32 attribute=0;\r\nguint8 msgverb=0;\r\nproto_tree *atree;\r\nfoffset = 6;\r\nfoffset += 1;\r\nsubfunc = tvb_get_guint8(tvb, foffset);\r\nfoffset += 1;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "NMAS");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "C NMAS - %s",\r\nval_to_str(subfunc, nmas_func_enum, "Unknown (0x%02x)"));\r\natree = proto_tree_add_subtree_format(ncp_tree, tvb, foffset, -1, ett_nmas, NULL, "Packet Type: %s",\r\nval_to_str(subfunc, nmas_func_enum, "Unknown (0x%02x)"));\r\nswitch (subfunc) {\r\ncase 1:\r\nproto_tree_add_item(atree, hf_ping_version, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nfoffset += 4;\r\nproto_tree_add_item(atree, hf_ping_flags, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase 2:\r\nproto_tree_add_item(atree, hf_frag_handle, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nif (tvb_get_letohl(tvb, foffset)!=0xffffffff) {\r\nbreak;\r\n}\r\nfoffset += 4;\r\nfoffset += 4;\r\nproto_tree_add_item(atree, hf_length, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nmsg_length = tvb_get_letohl(tvb, foffset);\r\nfoffset += 4;\r\nfoffset += 12;\r\nmsg_length -= 16;\r\nproto_tree_add_item(atree, hf_subverb, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nsubverb = tvb_get_letohl(tvb, foffset);\r\nif (request_value) {\r\nrequest_value->req_nds_flags=subverb;\r\n}\r\nfoffset += 4;\r\nmsg_length -= 4;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %s",\r\nval_to_str(subverb, nmas_subverb_enum, "Unknown subverb (%u)"));\r\nswitch (subverb) {\r\ncase 0:\r\nproto_tree_add_item(atree, hf_ping_version, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nfoffset += 4;\r\nproto_tree_add_item(atree, hf_ping_flags, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase 2:\r\nproto_tree_add_item(atree, hf_opaque, tvb, foffset, msg_length, ENC_NA);\r\nbreak;\r\ncase 4:\r\ncase 6:\r\nbreak;\r\ncase 8:\r\nproto_tree_add_item(atree, hf_reply_buffer_size, tvb, foffset, 1, ENC_LITTLE_ENDIAN);\r\nfoffset += 4;\r\nmsgverb = tvb_get_guint8(tvb, foffset);\r\nif (request_value) {\r\nrequest_value->nds_request_verb=msgverb;\r\n}\r\nproto_tree_add_item(atree, hf_lsm_verb, tvb, foffset, 1, ENC_LITTLE_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %s",\r\nval_to_str(msgverb, nmas_lsmverb_enum, "Unknown (%u)"));\r\nswitch (msgverb) {\r\ncase 1:\r\nbreak;\r\ncase 2:\r\nbreak;\r\ncase 4:\r\nbreak;\r\ncase 5:\r\nbreak;\r\ncase 6:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase 10:\r\nfoffset += 4;\r\nfoffset += 8;\r\nfoffset = nmas_string(tvb, hf_tree, atree, foffset, TRUE);\r\nnmas_string(tvb, hf_user, atree, foffset, TRUE);\r\nbreak;\r\ncase 1242:\r\nfoffset += 4;\r\nproto_tree_add_item(atree, hf_msg_version, tvb, foffset, 4, ENC_BIG_ENDIAN);\r\nfoffset += 4;\r\nproto_tree_add_item(atree, hf_session_ident, tvb, foffset, 4, ENC_BIG_ENDIAN);\r\nfoffset += 4;\r\nfoffset += 3;\r\nmsgverb = tvb_get_guint8(tvb, foffset);\r\nif (request_value) {\r\nrequest_value->nds_request_verb=msgverb;\r\n}\r\nproto_tree_add_item(atree, hf_msg_verb, tvb, foffset, 1, ENC_BIG_ENDIAN);\r\nfoffset += 1;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %s",\r\nval_to_str(msgverb, nmas_msgverb_enum, "Unknown (%u)"));\r\nswitch(msgverb) {\r\ncase 1:\r\nmsg_length = tvb_get_ntohl(tvb, foffset);\r\nproto_tree_add_item(atree, hf_length, tvb, foffset, 4, ENC_BIG_ENDIAN);\r\nfoffset += 4;\r\nproto_tree_add_item(atree, hf_data, tvb, foffset, msg_length, ENC_NA);\r\nbreak;\r\ncase 3:\r\nmsg_length = tvb_get_ntohl(tvb, foffset);\r\nmsg_length -= 4;\r\nproto_tree_add_item(atree, hf_length, tvb, foffset, 4, ENC_BIG_ENDIAN);\r\nfoffset += 4;\r\nwhile (msg_length > 0) {\r\nattribute = tvb_get_ntohl(tvb, foffset);\r\nfoffset += 4;\r\ncur_string_len=tvb_get_ntohl(tvb, foffset);\r\nswitch (attribute) {\r\ncase 1:\r\nfoffset = nmas_string(tvb, hf_user, atree, foffset, FALSE);\r\nbreak;\r\ncase 2:\r\nfoffset = nmas_string(tvb, hf_tree, atree, foffset, FALSE);\r\nbreak;\r\ncase 4:\r\nfoffset = nmas_string(tvb, hf_clearance, atree, foffset, FALSE);\r\nbreak;\r\ncase 11:\r\nfoffset = nmas_string(tvb, hf_login_sequence, atree, foffset, FALSE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmsg_length -= cur_string_len;\r\nif (tvb_reported_length_remaining(tvb, foffset)<5) {\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase 5:\r\nproto_tree_add_item(atree, hf_opaque, tvb, foffset,\r\ntvb_reported_length_remaining(tvb, foffset), ENC_NA);\r\nbreak;\r\ncase 7:\r\ncase 9:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase 3:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid\r\ndissect_nmas_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *ncp_tree, guint8 func _U_, guint8 subfunc, ncp_req_hash_value *request_value)\r\n{\r\nguint32 foffset=0, roffset=0;\r\nguint32 subverb=0;\r\nguint8 msgverb=0;\r\nguint32 msg_length=0;\r\nguint32 return_code=0, encrypt_error=0;\r\nproto_tree *atree;\r\nproto_item *expert_item;\r\nconst gchar *str;\r\nfoffset = 8;\r\nif (request_value) {\r\nsubverb = request_value->req_nds_flags;\r\nmsgverb = request_value->nds_request_verb;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "NMAS");\r\nif (tvb_reported_length_remaining(tvb, foffset)<4) {\r\nreturn;\r\n}\r\natree = proto_tree_add_subtree_format(ncp_tree, tvb, foffset, -1, ett_nmas, NULL, "Packet Type: %s",\r\nval_to_str(subfunc, nmas_func_enum, "Unknown (0x%02x)"));\r\nswitch (subfunc) {\r\ncase 1:\r\nproto_tree_add_item(atree, hf_ping_flags, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nfoffset += 4;\r\nproto_tree_add_item(atree, hf_nmas_version, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase 2:\r\nproto_tree_add_uint(atree, hf_verb, tvb, foffset, -1, subverb);\r\nproto_tree_add_item(atree, hf_length, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nmsg_length = tvb_get_letohl(tvb, foffset);\r\nfoffset +=4;\r\nproto_tree_add_item(atree, hf_frag_handle, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nif (tvb_get_letohl(tvb, foffset)!=0xffffffff) {\r\nbreak;\r\n}\r\nfoffset += 4;\r\nreturn_code = tvb_get_letohl(tvb, foffset);\r\nroffset = foffset;\r\nfoffset += 4;\r\nmsg_length -= 8;\r\nif (return_code == 0 && msg_length > 0) {\r\nswitch (subverb) {\r\ncase 0:\r\nproto_tree_add_item(atree, hf_session_ident, tvb, foffset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 2:\r\nproto_tree_add_item(atree, hf_squeue_bytes, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nfoffset += 4;\r\nproto_tree_add_item(atree, hf_cqueue_bytes, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase 4:\r\nproto_tree_add_item(atree, hf_opaque, tvb, foffset, msg_length, ENC_NA);\r\nbreak;\r\ncase 6:\r\nproto_tree_add_item(atree, hf_num_creds, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nfoffset += 4;\r\nproto_tree_add_item(atree, hf_cred_type, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nfoffset += 4;\r\nproto_tree_add_item(atree, hf_login_state, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nfoffset += 4;\r\nmsg_length -= 12;\r\nproto_tree_add_item(atree, hf_enc_cred, tvb, foffset, msg_length, ENC_NA);\r\nbreak;\r\ncase 8:\r\nproto_tree_add_uint_format(atree, hf_lsm_verb, tvb, foffset, -1, msgverb,\r\n"Subverb: %s", val_to_str(msgverb, nmas_lsmverb_enum, "Unknown (%u)"));\r\nswitch(msgverb) {\r\ncase 1:\r\ncase 3:\r\ncase 5:\r\ncase 7:\r\ncase 9:\r\nproto_tree_add_item(atree, hf_enc_data, tvb, foffset, msg_length, ENC_NA);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase 10:\r\nproto_tree_add_item(atree, hf_nmas_version, tvb, foffset, 4, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase 1242:\r\nproto_tree_add_uint_format(atree, hf_msg_verb, tvb, foffset, 1, msgverb,\r\n"Subverb: %s", val_to_str(msgverb, nmas_msgverb_enum, "Unknown (%u)"));\r\nswitch(msgverb) {\r\ncase 1:\r\nmsg_length = tvb_get_ntohl(tvb, foffset);\r\nproto_tree_add_item(atree, hf_length, tvb, foffset, 4, ENC_BIG_ENDIAN);\r\nfoffset += 4;\r\nproto_tree_add_item(atree, hf_data, tvb, foffset, msg_length, ENC_NA);\r\nbreak;\r\ncase 3:\r\nproto_tree_add_item(atree, hf_session_ident, tvb, foffset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 5:\r\nbreak;\r\ncase 7:\r\nencrypt_error = tvb_get_ntohl(tvb, foffset);\r\nstr = try_val_to_str(encrypt_error, nmas_errors_enum);\r\nif (str) {\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "R Payload Error - %s", str);\r\nexpert_item = proto_tree_add_item(atree, hf_encrypt_error, tvb, foffset, 4, ENC_BIG_ENDIAN);\r\nexpert_add_info_format(pinfo, expert_item, &ei_encrypt_error, "NMAS Payload Error: %s", str);\r\n} else {\r\nproto_tree_add_item(atree, hf_opaque, tvb, foffset, msg_length, ENC_NA);\r\n}\r\nbreak;\r\ncase 9:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstr = try_val_to_str(return_code, nmas_errors_enum);\r\nif (str) {\r\nexpert_item = proto_tree_add_item(atree, hf_return_code, tvb, roffset, 4, ENC_LITTLE_ENDIAN);\r\nexpert_add_info_format(pinfo, expert_item, &ei_return_error, "NMAS Error: 0x%08x %s", return_code, str);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "R Error - %s", str);\r\n} else {\r\nif (return_code!=0) {\r\nexpert_item = proto_tree_add_item(atree, hf_return_code, tvb, roffset, 4, ENC_LITTLE_ENDIAN);\r\nexpert_add_info_format(pinfo, expert_item, &ei_return_error, "NMAS Error: 0x%08x is unknown", return_code);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "R Unknown NMAS Error - 0x%08x", return_code);\r\n}\r\n}\r\nif (return_code == 0) {\r\nproto_tree_add_uint_format_value(atree, hf_return_code, tvb, roffset, 4, return_code, "Success (0x00000000)");\r\n}\r\nbreak;\r\ncase 3:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid\r\nproto_register_nmas(void)\r\n{\r\nstatic hf_register_info hf_nmas[] = {\r\n#if 0\r\n{ &hf_func,\r\n{ "Function", "nmas.func",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n#endif\r\n#if 0\r\n{ &hf_subfunc,\r\n{ "Subfunction", "nmas.subfunc",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n#endif\r\n{ &hf_ping_version,\r\n{ "Ping Version", "nmas.ping_version",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ping_flags,\r\n{ "Flags", "nmas.ping_flags",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_frag_handle,\r\n{ "Fragment Handle", "nmas.frag_handle",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_length,\r\n{ "Length", "nmas.length",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_subverb,\r\n{ "Sub Verb", "nmas.subverb",\r\nFT_UINT32, BASE_HEX, VALS(nmas_subverb_enum), 0x0, NULL, HFILL }},\r\n{ &hf_tree,\r\n{ "Tree", "nmas.tree",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_user,\r\n{ "User", "nmas.user",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nmas_version,\r\n{ "NMAS Protocol Version", "nmas.version",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_msg_version,\r\n{ "Message Version", "nmas.msg_version",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_session_ident,\r\n{ "Session Identifier", "nmas.session_ident",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_verb,\r\n{ "Verb", "nmas.verb",\r\nFT_UINT8, BASE_HEX, VALS(nmas_subverb_enum), 0x0, NULL, HFILL }},\r\n{ &hf_msg_verb,\r\n{ "Message Verb", "nmas.msg_verb",\r\nFT_UINT8, BASE_HEX, VALS(nmas_msgverb_enum), 0x0, NULL, HFILL }},\r\n#if 0\r\n{ &hf_attribute,\r\n{ "Attribute Type", "nmas.attribute",\r\nFT_UINT32, BASE_DEC, VALS(nmas_attribute_enum), 0x0, NULL, HFILL }},\r\n#endif\r\n{ &hf_clearance,\r\n{ "Requested Clearance", "nmas.clearance",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_login_sequence,\r\n{ "Requested Login Sequence", "nmas.login_seq",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_opaque,\r\n{ "Opaque Data", "nmas.opaque",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_data,\r\n{ "Data", "nmas.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_return_code,\r\n{ "Return Code", "nmas.return_code",\r\nFT_UINT32, BASE_HEX, VALS(nmas_errors_enum), 0x0, NULL, HFILL }},\r\n{ &hf_lsm_verb,\r\n{ "Login Store Message Verb", "nmas.lsm_verb",\r\nFT_UINT8, BASE_HEX, VALS(nmas_lsmverb_enum), 0x0, NULL, HFILL }},\r\n{ &hf_squeue_bytes,\r\n{ "Server Queue Number of Bytes", "nmas.squeue_bytes",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_cqueue_bytes,\r\n{ "Client Queue Number of Bytes", "nmas.cqueue_bytes",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_num_creds,\r\n{ "Number of Credentials", "nmas.num_creds",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_cred_type,\r\n{ "Credential Type", "nmas.cred_type",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_login_state,\r\n{ "Login State", "nmas.login_state",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_enc_cred,\r\n{ "Encrypted Credential", "nmas.enc_cred",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_enc_data,\r\n{ "Encrypted Data", "nmas.enc_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_reply_buffer_size,\r\n{ "Reply Buffer Size", "nmas.buf_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_encrypt_error,\r\n{ "Payload Error", "nmas.encrypt_error",\r\nFT_UINT32, BASE_HEX, VALS(nmas_errors_enum), 0x0,\r\n"Payload/Encryption Return Code", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_nmas\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_encrypt_error, { "nmas.encrypt_error.expert", PI_RESPONSE_CODE, PI_NOTE, "NMAS Payload Erro", EXPFILL }},\r\n{ &ei_return_error, { "nmas.return_code.expert", PI_RESPONSE_CODE, PI_NOTE, "NMAS Error", EXPFILL }},\r\n};\r\nexpert_module_t* expert_nmas;\r\nproto_nmas = proto_register_protocol("Novell Modular Authentication Service", "NMAS", "nmas");\r\nproto_register_field_array(proto_nmas, hf_nmas, array_length(hf_nmas));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_nmas = expert_register_protocol(proto_nmas);\r\nexpert_register_field_array(expert_nmas, ei, array_length(ei));\r\n}
