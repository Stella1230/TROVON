static guint\r\nata_cmd_hash_matched(gconstpointer k)\r\n{\r\nreturn GPOINTER_TO_UINT(k);\r\n}\r\nstatic gint\r\nata_cmd_equal_matched(gconstpointer k1, gconstpointer k2)\r\n{\r\nreturn k1==k2;\r\n}\r\nstatic guint\r\nata_cmd_hash_unmatched(gconstpointer k)\r\n{\r\nconst ata_info_t *key = (const ata_info_t *)k;\r\nreturn key->tag;\r\n}\r\nstatic gint\r\nata_cmd_equal_unmatched(gconstpointer k1, gconstpointer k2)\r\n{\r\nconst ata_info_t *key1 = (const ata_info_t *)k1;\r\nconst ata_info_t *key2 = (const ata_info_t *)k2;\r\nreturn (key1->tag==key2->tag)&&(key1->conversation==key2->conversation);\r\n}\r\nstatic void\r\ndissect_ata_pdu(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset, gboolean response, guint32 tag)\r\n{\r\nproto_item *tmp_item;\r\nguint8 aflags;\r\nguint64 lba;\r\nata_info_t *ata_info=NULL;\r\nconversation_t *conversation;\r\nconversation = find_or_create_conversation(pinfo);\r\nif( !(pinfo->fd->flags.visited) ){\r\nif(!response){\r\nata_info_t *tmp_ata_info;\r\nata_info=wmem_new(wmem_file_scope(), ata_info_t);\r\nata_info->tag=tag;\r\nata_info->conversation=conversation;\r\nata_info->request_frame=pinfo->num;\r\nata_info->response_frame=0;\r\nata_info->cmd=tvb_get_guint8(tvb, offset+3);\r\nata_info->req_time=pinfo->abs_ts;\r\ntmp_ata_info=(ata_info_t *)g_hash_table_lookup(ata_cmd_unmatched, ata_info);\r\nif(tmp_ata_info){\r\ng_hash_table_remove(ata_cmd_unmatched, tmp_ata_info);\r\n}\r\ng_hash_table_insert(ata_cmd_unmatched, ata_info, ata_info);\r\n} else {\r\nata_info_t tmp_ata_info;\r\ntmp_ata_info.tag=tag;\r\ntmp_ata_info.conversation=conversation;\r\nata_info=(ata_info_t *)g_hash_table_lookup(ata_cmd_unmatched, &tmp_ata_info);\r\nif(ata_info){\r\nata_info->response_frame=pinfo->num;\r\ng_hash_table_remove(ata_cmd_unmatched, ata_info);\r\ng_hash_table_insert(ata_cmd_matched, GUINT_TO_POINTER(ata_info->request_frame), ata_info);\r\ng_hash_table_insert(ata_cmd_matched, GUINT_TO_POINTER(ata_info->response_frame), ata_info);\r\n}\r\n}\r\n} else {\r\nata_info=(ata_info_t *)g_hash_table_lookup(ata_cmd_matched, GUINT_TO_POINTER(pinfo->num));\r\n}\r\nif(ata_info){\r\nif(response){\r\nif(ata_info->request_frame){\r\nnstime_t delta_ts;\r\ntmp_item=proto_tree_add_uint(tree, hf_aoe_response_to, tvb, 0, 0, ata_info->request_frame);\r\nPROTO_ITEM_SET_GENERATED(tmp_item);\r\nnstime_delta(&delta_ts, &pinfo->abs_ts, &ata_info->req_time);\r\ntmp_item=proto_tree_add_time(tree, hf_aoe_time, tvb, offset, 0, &delta_ts);\r\nPROTO_ITEM_SET_GENERATED(tmp_item);\r\n}\r\n} else {\r\nif(ata_info->response_frame){\r\ntmp_item=proto_tree_add_uint(tree, hf_aoe_response_in, tvb, 0, 0, ata_info->response_frame);\r\nPROTO_ITEM_SET_GENERATED(tmp_item);\r\n}\r\n}\r\n}\r\naflags=tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_aoe_aflags_e, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif(aflags&AOE_AFLAGS_E){\r\nproto_tree_add_item(tree, hf_aoe_aflags_d, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nif(aflags&AOE_AFLAGS_W){\r\nproto_tree_add_item(tree, hf_aoe_aflags_a, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(tree, hf_aoe_aflags_w, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(tree, hf_aoe_err_feature, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(tree, hf_aoe_sector_count, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nif(!response){\r\nproto_tree_add_item(tree, hf_aoe_acmd, tvb, offset, 1, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " ATA:%s", val_to_str(tvb_get_guint8(tvb, offset), ata_cmd_vals, " Unknown ATA<0x%02x>"));\r\n} else {\r\nproto_tree_add_item(tree, hf_aoe_astatus, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif(ata_info != NULL && ata_info->request_frame){\r\ntmp_item=proto_tree_add_uint(tree, hf_aoe_acmd, tvb, 0, 0, ata_info->cmd);\r\nPROTO_ITEM_SET_GENERATED(tmp_item);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " ATA:%s", val_to_str(ata_info->cmd, ata_cmd_vals, " Unknown ATA<0x%02x>"));\r\n}\r\n}\r\noffset++;\r\nlba=tvb_get_letohs(tvb, offset+4);\r\nlba=(lba<<32)|tvb_get_letohl(tvb, offset);\r\noffset+=8;\r\nproto_tree_add_uint64(tree, hf_aoe_lba, tvb, offset-8, 6, lba);\r\n}\r\nstatic void\r\ndissect_aoe_v1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint8 flags, cmd;\r\nguint32 tag;\r\nproto_item *flags_item;\r\nproto_tree *flags_tree;\r\nflags=tvb_get_guint8(tvb, 0)&0x0f;\r\nflags_tree=proto_tree_add_subtree(tree, tvb, 0, 1, ett_aoe_flags, &flags_item, "Flags:");\r\nproto_tree_add_item(flags_tree, hf_aoe_flags_response, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_aoe_flags_error, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(flags_item,(flags&AOE_FLAGS_RESPONSE)?" Response":" Request");\r\nif(flags&AOE_FLAGS_ERROR){\r\nproto_item_append_text(flags_item, " Error");\r\n}\r\nif(flags&AOE_FLAGS_ERROR){\r\nproto_tree_add_item(tree, hf_aoe_error, tvb, 1, 1, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Error:%s ", val_to_str(tvb_get_guint8(tvb, 1), error_vals, "Unknown error<%d>"));\r\n}\r\nproto_tree_add_item(tree, hf_aoe_major, tvb, 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_aoe_minor, tvb, 4, 1, ENC_BIG_ENDIAN);\r\ncmd=tvb_get_guint8(tvb, 5);\r\nproto_tree_add_item(tree, hf_aoe_cmd, tvb, 5, 1, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s %s", val_to_str(cmd, cmd_vals, "Unknown command<%d>"), (flags&AOE_FLAGS_RESPONSE)?"Response":"Request");\r\ntag=tvb_get_letohl(tvb, 6);\r\nproto_tree_add_item(tree, hf_aoe_tag, tvb, 6, 4, ENC_BIG_ENDIAN);\r\nswitch(cmd){\r\ncase AOE_CMD_ISSUE_ATA_COMMAND:\r\ndissect_ata_pdu(pinfo, tree, tvb, 10, flags&AOE_FLAGS_RESPONSE, tag);\r\nbreak;\r\ncase AOE_CMD_QUERY_CONFIG_INFO:\r\nbreak;\r\n}\r\n}\r\nstatic int\r\ndissect_aoe(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data _U_)\r\n{\r\nproto_item *item;\r\nproto_tree *tree;\r\nguint8 version;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "AoE");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nitem = proto_tree_add_item(parent_tree, proto_aoe, tvb, 0, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_aoe);\r\nversion=tvb_get_guint8(tvb, 0)>>4;\r\nproto_tree_add_uint(tree, hf_aoe_version, tvb, 0, 1, version);\r\nswitch(version){\r\ncase 1:\r\ndissect_aoe_v1(tvb, pinfo, tree);\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\nata_init(void)\r\n{\r\nata_cmd_unmatched=g_hash_table_new(ata_cmd_hash_unmatched, ata_cmd_equal_unmatched);\r\nata_cmd_matched=g_hash_table_new(ata_cmd_hash_matched, ata_cmd_equal_matched);\r\n}\r\nstatic void\r\nata_cleanup(void)\r\n{\r\ng_hash_table_destroy(ata_cmd_unmatched);\r\ng_hash_table_destroy(ata_cmd_matched);\r\n}\r\nvoid\r\nproto_register_aoe(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_aoe_cmd,\r\n{ "Command", "aoe.cmd", FT_UINT8, BASE_DEC, VALS(cmd_vals), 0x0,\r\n"AOE Command", HFILL}},\r\n{ &hf_aoe_version,\r\n{ "Version", "aoe.version", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Version of the AOE protocol", HFILL}},\r\n{ &hf_aoe_error,\r\n{ "Error", "aoe.error", FT_UINT8, BASE_DEC, VALS(error_vals), 0x0,\r\n"Error code", HFILL}},\r\n{ &hf_aoe_err_feature,\r\n{ "Err/Feature", "aoe.err_feature", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}},\r\n{ &hf_aoe_sector_count,\r\n{ "Sector Count", "aoe.sector_count", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}},\r\n{ &hf_aoe_flags_response,\r\n{ "Response flag", "aoe.response", FT_BOOLEAN, 8, TFS(&tfs_response_request), AOE_FLAGS_RESPONSE, "Whether this is a response PDU or not", HFILL}},\r\n{ &hf_aoe_flags_error,\r\n{ "Error flag", "aoe.flags_error", FT_BOOLEAN, 8, TFS(&tfs_error), AOE_FLAGS_ERROR, "Whether this is an error PDU or not", HFILL}},\r\n{ &hf_aoe_major,\r\n{ "Major", "aoe.major", FT_UINT16, BASE_HEX, NULL, 0x0,\r\n"Major address", HFILL}},\r\n{ &hf_aoe_minor,\r\n{ "Minor", "aoe.minor", FT_UINT8, BASE_HEX, NULL, 0x0,\r\n"Minor address", HFILL}},\r\n{ &hf_aoe_acmd,\r\n{ "ATA Cmd", "aoe.ata.cmd", FT_UINT8, BASE_HEX, VALS(ata_cmd_vals), 0x0,\r\n"ATA command opcode", HFILL}},\r\n{ &hf_aoe_astatus,\r\n{ "ATA Status", "aoe.ata.status", FT_UINT8, BASE_HEX, NULL, 0x0,\r\n"ATA status bits", HFILL}},\r\n{ &hf_aoe_tag,\r\n{ "Tag", "aoe.tag", FT_UINT32, BASE_HEX, NULL, 0x0,\r\n"Command Tag", HFILL}},\r\n{ &hf_aoe_aflags_e,\r\n{ "E", "aoe.aflags.e", FT_BOOLEAN, 8, TFS(&tfs_aflags_e), AOE_AFLAGS_E, "Whether this is a normal or LBA48 command", HFILL}},\r\n{ &hf_aoe_aflags_d,\r\n{ "D", "aoe.aflags.d", FT_BOOLEAN, 8, TFS(&tfs_aflags_d), AOE_AFLAGS_D, NULL, HFILL}},\r\n{ &hf_aoe_aflags_a,\r\n{ "A", "aoe.aflags.a", FT_BOOLEAN, 8, TFS(&tfs_aflags_a), AOE_AFLAGS_A, "Whether this is an asynchronous write or not", HFILL}},\r\n{ &hf_aoe_aflags_w,\r\n{ "W", "aoe.aflags.w", FT_BOOLEAN, 8, TFS(&tfs_aflags_w), AOE_AFLAGS_W, "Is this a command writing data to the device or not", HFILL}},\r\n{ &hf_aoe_lba,\r\n{ "Lba", "aoe.lba", FT_UINT64, BASE_HEX, NULL, 0x00, "Lba address", HFILL}},\r\n{ &hf_aoe_response_in,\r\n{ "Response In", "aoe.response_in", FT_FRAMENUM, BASE_NONE, NULL, 0x0, "The response to this packet is in this frame", HFILL }},\r\n{ &hf_aoe_response_to,\r\n{ "Response To", "aoe.response_to", FT_FRAMENUM, BASE_NONE, NULL, 0x0, "This is a response to the ATA command in this frame", HFILL }},\r\n{ &hf_aoe_time,\r\n{ "Time from request", "aoe.time", FT_RELATIVE_TIME, BASE_NONE, NULL, 0, "Time between Request and Reply for ATA calls", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_aoe,\r\n&ett_aoe_flags,\r\n};\r\nproto_aoe = proto_register_protocol("ATAoverEthernet", "AOE", "aoe");\r\nproto_register_field_array(proto_aoe, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\naoe_handle = register_dissector("aoe", dissect_aoe, proto_aoe);\r\nregister_init_routine(ata_init);\r\nregister_cleanup_routine(ata_cleanup);\r\n}\r\nvoid\r\nproto_reg_handoff_aoe(void)\r\n{\r\ndissector_add_uint("ethertype", ETHERTYPE_AOE, aoe_handle);\r\n}
