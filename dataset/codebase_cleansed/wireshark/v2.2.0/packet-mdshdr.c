static int\r\ndissect_mdshdr(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti_main;\r\nproto_item *hidden_item;\r\nproto_tree *mdshdr_tree_main, *mdshdr_tree_hdr, *mdshdr_tree_trlr;\r\nint offset = 0;\r\nguint pktlen;\r\ntvbuff_t *next_tvb;\r\nguint8 sof, eof;\r\nint trailer_start = 0;\r\nfc_data_t fc_data;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MDS Header");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nsof = tvb_get_guint8(tvb, offset+MDSHDR_SOF_OFFSET) & 0x0F;\r\npktlen = tvb_get_ntohs(tvb, offset+MDSHDR_PKTLEN_OFFSET) & 0x1FFF;\r\nif ((tvb_captured_length(tvb) >= (MDSHDR_HEADER_SIZE + pktlen))\r\n&& (pktlen >= MDSHDR_TRAILER_SIZE)) {\r\ntrailer_start = MDSHDR_HEADER_SIZE + pktlen - MDSHDR_TRAILER_SIZE;\r\neof = tvb_get_guint8(tvb, trailer_start);\r\ntvb_set_reported_length(tvb, MDSHDR_HEADER_SIZE+pktlen);\r\n}\r\nelse {\r\neof = MDSHDR_EOF_UNKNOWN;\r\n}\r\nfc_data.sof_eof = 0;\r\nif ((sof == MDSHDR_SOFi3) || (sof == MDSHDR_SOFi2) || (sof == MDSHDR_SOFi1)\r\n|| (sof == MDSHDR_SOFi4)) {\r\nfc_data.sof_eof = FC_DATA_SOF_FIRST_FRAME;\r\n}\r\nelse if (sof == MDSHDR_SOFf) {\r\nfc_data.sof_eof = FC_DATA_SOF_SOFF;\r\n}\r\nif (eof != MDSHDR_EOFn) {\r\nfc_data.sof_eof |= FC_DATA_EOF_LAST_FRAME;\r\n}\r\nelse if (eof != MDSHDR_EOFt) {\r\nfc_data.sof_eof |= FC_DATA_EOF_INVALID;\r\n}\r\nif (tree) {\r\nti_main = proto_tree_add_protocol_format(tree, proto_mdshdr, tvb, 0,\r\nMDSHDR_HEADER_SIZE+pktlen,\r\n"MDS Header(%s/%s)",\r\nval_to_str(sof, sof_vals, "Unknown(%u)"),\r\nval_to_str(eof, eof_vals, "Unknown(%u)"));\r\nmdshdr_tree_main = proto_item_add_subtree(ti_main, ett_mdshdr);\r\nmdshdr_tree_hdr = proto_tree_add_subtree(mdshdr_tree_main, tvb, MDSHDR_VER_OFFSET,\r\nMDSHDR_HEADER_SIZE, ett_mdshdr_hdr, NULL, "MDS Header");\r\nhidden_item = proto_tree_add_item(mdshdr_tree_hdr, hf_mdshdr_sof, tvb, MDSHDR_SOF_OFFSET,\r\nMDSHDR_SIZE_BYTE, ENC_BIG_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nproto_tree_add_item(mdshdr_tree_hdr, hf_mdshdr_pkt_len, tvb, MDSHDR_PKTLEN_OFFSET,\r\nMDSHDR_SIZE_INT16, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(mdshdr_tree_hdr, hf_mdshdr_dstidx, tvb, MDSHDR_DIDX_OFFSET,\r\nMDSHDR_SIZE_INT16, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(mdshdr_tree_hdr, hf_mdshdr_srcidx, tvb, MDSHDR_SIDX_OFFSET,\r\nMDSHDR_SIZE_INT16, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(mdshdr_tree_hdr, hf_mdshdr_vsan, tvb, MDSHDR_VSAN_OFFSET,\r\nMDSHDR_SIZE_INT16, ENC_BIG_ENDIAN);\r\nhidden_item = proto_tree_add_item(mdshdr_tree_hdr, hf_mdshdr_span,\r\ntvb, MDSHDR_VSAN_OFFSET,\r\nMDSHDR_SIZE_INT16, ENC_BIG_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nif (tvb_reported_length(tvb) >= MDSHDR_HEADER_SIZE + pktlen\r\n&& 0 != trailer_start) {\r\nmdshdr_tree_trlr = proto_tree_add_subtree(mdshdr_tree_main, tvb, trailer_start,\r\nMDSHDR_TRAILER_SIZE,\r\nett_mdshdr_trlr, NULL, "MDS Trailer");\r\nproto_tree_add_item(mdshdr_tree_trlr, hf_mdshdr_eof, tvb,\r\ntrailer_start, MDSHDR_SIZE_BYTE, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(mdshdr_tree_trlr, hf_mdshdr_fccrc, tvb,\r\ntrailer_start+2, MDSHDR_SIZE_INT32, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_item(mdshdr_tree_main, hf_mdshdr_no_trailer, tvb, 0, 0, ENC_NA);\r\n}\r\n}\r\nif (tvb_reported_length(tvb) >= MDSHDR_HEADER_SIZE + pktlen\r\n&& 0 != pktlen ) {\r\nnext_tvb = tvb_new_subset_length(tvb, MDSHDR_HEADER_SIZE, pktlen);\r\n}\r\nelse {\r\nnext_tvb = tvb_new_subset_remaining(tvb, MDSHDR_HEADER_SIZE);\r\n}\r\nif (fc_dissector_handle) {\r\nfc_data.ethertype = ETHERTYPE_FCFT;\r\ncall_dissector_with_data(fc_dissector_handle, next_tvb, pinfo, tree, &fc_data);\r\n}\r\nelse {\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_mdshdr(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_mdshdr_sof,\r\n{"SOF", "mdshdr.sof", FT_UINT8, BASE_DEC, VALS(sof_vals), 0x0, NULL, HFILL}},\r\n{ &hf_mdshdr_pkt_len,\r\n{"Packet Len", "mdshdr.plen", FT_UINT16, BASE_DEC, NULL, 0x1FFF, NULL, HFILL}},\r\n{ &hf_mdshdr_dstidx,\r\n{"Dst Index", "mdshdr.dstidx", FT_UINT16, BASE_HEX, NULL, 0xFFC, NULL, HFILL}},\r\n{ &hf_mdshdr_srcidx,\r\n{"Src Index", "mdshdr.srcidx", FT_UINT16, BASE_HEX, NULL, 0x3FF, NULL, HFILL}},\r\n{ &hf_mdshdr_vsan,\r\n{"VSAN", "mdshdr.vsan", FT_UINT16, BASE_DEC, NULL, 0x0FFF, NULL, HFILL}},\r\n{ &hf_mdshdr_eof,\r\n{"EOF", "mdshdr.eof", FT_UINT8, BASE_DEC, VALS(eof_vals), 0x0, NULL, HFILL}},\r\n{ &hf_mdshdr_no_trailer,\r\n{"MDS Trailer: Not Found", "mdshdr.no_trailer", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_mdshdr_span,\r\n{"SPAN Frame", "mdshdr.span", FT_UINT16, BASE_DEC, NULL, 0xF000, NULL, HFILL}},\r\n{ &hf_mdshdr_fccrc,\r\n{"CRC", "mdshdr.crc", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL}},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_mdshdr,\r\n&ett_mdshdr_hdr,\r\n&ett_mdshdr_trlr\r\n};\r\nmodule_t *mdshdr_module;\r\nproto_mdshdr = proto_register_protocol("MDS Header", "MDS Header", "mdshdr");\r\nproto_register_field_array(proto_mdshdr, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nmdshdr_module = prefs_register_protocol(proto_mdshdr, proto_reg_handoff_mdshdr);\r\nprefs_register_bool_preference(mdshdr_module, "decode_if_etype_zero",\r\n"Decode as MDS Header if Ethertype == 0",\r\n"A frame is considered for decoding as MDSHDR if either "\r\n"ethertype is 0xFCFC or zero. Turn this flag off if you "\r\n"don't want ethertype zero to be decoded as MDSHDR. "\r\n"This might be useful to avoid problems with test frames.",\r\n&decode_if_zero_etype);\r\n}\r\nvoid\r\nproto_reg_handoff_mdshdr(void)\r\n{\r\nstatic dissector_handle_t mdshdr_handle;\r\nstatic gboolean registered_for_zero_etype = FALSE;\r\nstatic gboolean mdshdr_prefs_initialized = FALSE;\r\nif (!mdshdr_prefs_initialized) {\r\nmdshdr_handle = create_dissector_handle(dissect_mdshdr, proto_mdshdr);\r\ndissector_add_uint("ethertype", ETHERTYPE_FCFT, mdshdr_handle);\r\nfc_dissector_handle = find_dissector_add_dependency("fc", proto_mdshdr);\r\nmdshdr_prefs_initialized = TRUE;\r\n}\r\nif (decode_if_zero_etype) {\r\nif (!registered_for_zero_etype) {\r\ndissector_add_uint("ethertype", ETHERTYPE_UNK, mdshdr_handle);\r\nregistered_for_zero_etype = TRUE;\r\n}\r\n} else {\r\nif (registered_for_zero_etype) {\r\ndissector_delete_uint("ethertype", ETHERTYPE_UNK, mdshdr_handle);\r\nregistered_for_zero_etype = FALSE;\r\n}\r\n}\r\n}
