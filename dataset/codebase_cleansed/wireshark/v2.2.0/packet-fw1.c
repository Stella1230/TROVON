static void\r\nfw1_init(void)\r\n{\r\ninterface_anzahl = 0;\r\n}\r\nstatic int\r\ndissect_fw1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *fh_tree = NULL;\r\nchar direction;\r\nchar chain;\r\nchar *interface_name;\r\nguint32 iface_len = 10;\r\nwmem_strbuf_t *header;\r\nint i;\r\ngboolean found;\r\nstatic const char fw1_header[] = "FW1 Monitor";\r\nethertype_data_t ethertype_data;\r\nheader = wmem_strbuf_new_label(wmem_epan_scope());\r\nwmem_strbuf_append(header, fw1_header);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "FW1");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ndirection = tvb_get_guint8(tvb, 0);\r\nif (!fw1_iflist_with_chain)\r\nchain = ' ';\r\nelse\r\nchain = tvb_get_guint8(tvb, 1);\r\nif (fw1_with_uuid)\r\niface_len = 6;\r\ninterface_name=tvb_get_stringzpad(wmem_packet_scope(), tvb, 2, iface_len, ENC_ASCII|ENC_NA);\r\nfound=FALSE;\r\nfor (i=0; i<interface_anzahl; i++) {\r\nif ( strcmp(p_interfaces[i], interface_name) == 0 ) {\r\nfound=TRUE;\r\nbreak;\r\n}\r\n}\r\nif (!found && interface_anzahl < MAX_INTERFACES) {\r\np_interfaces[interface_anzahl] = wmem_strdup(wmem_file_scope(), interface_name);\r\ninterface_anzahl++;\r\n}\r\nfor (i=0; i<interface_anzahl; i++) {\r\nif ( strcmp(p_interfaces[i], interface_name) == 0 ) {\r\nwmem_strbuf_append_printf(header, " %c%c %s %c%c",\r\ndirection == 'i' ? 'i' : (direction == 'O' ? 'O' : ' '),\r\n(direction == 'i' || direction == 'O') ? chain : ' ',\r\np_interfaces[i],\r\ndirection == 'I' ? 'I' : (direction == 'o' ? 'o' : ' '),\r\n(direction == 'I' || direction == 'o') ? chain : ' '\r\n);\r\n} else {\r\nwmem_strbuf_append_printf(header, " %s ", p_interfaces[i]);\r\n}\r\n}\r\ncol_add_str(pinfo->cinfo, COL_IF_DIR, wmem_strbuf_get_str(header) + sizeof(fw1_header) + 1);\r\nif (tree) {\r\nif (!fw1_summary_in_tree)\r\nti = proto_tree_add_protocol_format(tree, proto_fw1, tvb, 0, ETH_HEADER_SIZE, "%s", fw1_header);\r\nelse\r\nti = proto_tree_add_protocol_format(tree, proto_fw1, tvb, 0, ETH_HEADER_SIZE, "%s", wmem_strbuf_get_str(header));\r\nfh_tree = proto_item_add_subtree(ti, ett_fw1);\r\nproto_tree_add_item(fh_tree, hf_fw1_direction, tvb, 0, 1, ENC_ASCII|ENC_NA);\r\nif (fw1_iflist_with_chain)\r\nproto_tree_add_item(fh_tree, hf_fw1_chain, tvb, 1, 1, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(fh_tree, hf_fw1_interface, tvb, 2, iface_len, ENC_ASCII|ENC_NA);\r\nif (fw1_with_uuid)\r\nproto_tree_add_item(fh_tree, hf_fw1_uuid, tvb, 8, 4, ENC_BIG_ENDIAN);\r\n}\r\nethertype_data.etype = tvb_get_ntohs(tvb, 12);\r\nethertype_data.offset_after_ethertype = ETH_HEADER_SIZE;\r\nethertype_data.fh_tree = fh_tree;\r\nethertype_data.etype_id = hf_fw1_type;\r\nethertype_data.trailer_id = hf_fw1_trailer;\r\nethertype_data.fcs_len = 0;\r\ncall_dissector_with_data(ethertype_handle, tvb, pinfo, tree, &ethertype_data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_fw1(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_fw1_direction,\r\n{ "Direction", "fw1.direction", FT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_fw1_chain,\r\n{ "Chain Position", "fw1.chain", FT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_fw1_interface,\r\n{ "Interface", "fw1.interface", FT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_fw1_uuid,\r\n{ "UUID", "fw1.uuid", FT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_fw1_type,\r\n{ "Type", "fw1.type", FT_UINT16, BASE_HEX, VALS(etype_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_fw1_trailer,\r\n{ "Trailer", "fw1.trailer", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_fw1,\r\n};\r\nmodule_t *fw1_module;\r\nint i;\r\nproto_fw1 = proto_register_protocol("Checkpoint FW-1", "FW-1", "fw1");\r\nproto_register_field_array(proto_fw1, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nfw1_module = prefs_register_protocol(proto_fw1, NULL);\r\nprefs_register_bool_preference(fw1_module, "summary_in_tree",\r\n"Show FireWall-1 summary in protocol tree",\r\n"Whether the FireWall-1 summary line should be shown in the protocol tree",\r\n&fw1_summary_in_tree);\r\nprefs_register_bool_preference(fw1_module, "with_uuid",\r\n"Monitor file includes UUID",\r\n"Whether the Firewall-1 monitor file includes UUID information",\r\n&fw1_with_uuid);\r\nprefs_register_bool_preference(fw1_module, "iflist_with_chain",\r\n"Interface list includes chain position",\r\n"Whether the interface list includes the chain position",\r\n&fw1_iflist_with_chain);\r\nregister_dissector("fw1", dissect_fw1, proto_fw1);\r\nfor (i=0; i<MAX_INTERFACES; i++) {\r\np_interfaces[i] = NULL;\r\n}\r\nregister_init_routine(fw1_init);\r\n}\r\nvoid\r\nproto_reg_handoff_fw1(void)\r\n{\r\nethertype_handle = find_dissector_add_dependency("ethertype", proto_fw1);\r\n}
