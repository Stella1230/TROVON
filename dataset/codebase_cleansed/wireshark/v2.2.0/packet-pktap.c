static gboolean\r\ncapture_pktap(const guchar *pd, int offset _U_, int len, capture_packet_info_t *cpinfo, const union wtap_pseudo_header *pseudo_header _U_)\r\n{\r\nguint32 hdrlen, rectype, dlt;\r\nhdrlen = pletoh32(pd);\r\nif (hdrlen < MIN_PKTAP_HDR_LEN || !BYTES_ARE_IN_FRAME(0, len, hdrlen))\r\nreturn FALSE;\r\nrectype = pletoh32(pd+4);\r\nif (rectype != PKT_REC_PACKET)\r\nreturn FALSE;\r\ndlt = pletoh32(pd+4);\r\nswitch (dlt) {\r\ncase 1:\r\nreturn capture_eth(pd, hdrlen, len, cpinfo, pseudo_header);\r\n}\r\nreturn FALSE;\r\n}\r\nstatic int\r\ndissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *pktap_tree = NULL;\r\nproto_item *ti = NULL;\r\ntvbuff_t *next_tvb;\r\nint offset = 0;\r\nguint32 pkt_len, rectype, dlt;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "PKTAP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\npkt_len = tvb_get_letohl(tvb, offset);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "PKTAP, %u byte header", pkt_len);\r\nti = proto_tree_add_item(tree, proto_pktap, tvb, offset, pkt_len, ENC_NA);\r\npktap_tree = proto_item_add_subtree(ti, ett_pktap);\r\nproto_tree_add_item(pktap_tree, hf_pktap_hdrlen, tvb, offset, 4,\r\nENC_LITTLE_ENDIAN);\r\nif (pkt_len < MIN_PKTAP_HDR_LEN) {\r\nproto_tree_add_expert(tree, pinfo, &ei_pktap_hdrlen_too_short,\r\ntvb, offset, 4);\r\nreturn tvb_captured_length(tvb);\r\n}\r\noffset += 4;\r\nproto_tree_add_item(pktap_tree, hf_pktap_rectype, tvb, offset, 4,\r\nENC_LITTLE_ENDIAN);\r\nrectype = tvb_get_letohl(tvb, offset);\r\noffset += 4;\r\nproto_tree_add_item(pktap_tree, hf_pktap_dlt, tvb, offset, 4,\r\nENC_LITTLE_ENDIAN);\r\ndlt = tvb_get_letohl(tvb, offset);\r\noffset += 4;\r\nproto_tree_add_item(pktap_tree, hf_pktap_ifname, tvb, offset, 24,\r\nENC_ASCII|ENC_NA);\r\noffset += 24;\r\nproto_tree_add_item(pktap_tree, hf_pktap_flags, tvb, offset, 4,\r\nENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(pktap_tree, hf_pktap_pfamily, tvb, offset, 4,\r\nENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(pktap_tree, hf_pktap_llhdrlen, tvb, offset, 4,\r\nENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(pktap_tree, hf_pktap_lltrlrlen, tvb, offset, 4,\r\nENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(pktap_tree, hf_pktap_pid, tvb, offset, 4,\r\nENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(pktap_tree, hf_pktap_cmdname, tvb, offset, 20,\r\nENC_UTF_8|ENC_NA);\r\noffset += 20;\r\nproto_tree_add_item(pktap_tree, hf_pktap_svc_class, tvb, offset, 4,\r\nENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(pktap_tree, hf_pktap_iftype, tvb, offset, 2,\r\nENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(pktap_tree, hf_pktap_ifunit, tvb, offset, 2,\r\nENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(pktap_tree, hf_pktap_epid, tvb, offset, 4,\r\nENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(pktap_tree, hf_pktap_ecmdname, tvb, offset, 20,\r\nENC_UTF_8|ENC_NA);\r\nif (rectype == PKT_REC_PACKET) {\r\nnext_tvb = tvb_new_subset_remaining(tvb, pkt_len);\r\ncall_dissector_with_data(pcap_pktdata_handle, next_tvb,\r\npinfo, tree, &dlt);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_pktap(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_pktap_hdrlen,\r\n{ "Header length", "pktap.hdrlen",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_pktap_rectype,\r\n{ "Record type", "pktap.rectype",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_pktap_dlt,\r\n{ "DLT", "pktap.dlt",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_pktap_ifname,\r\n{ "Interface name", "pktap.ifname",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_pktap_flags,\r\n{ "Flags", "pktap.flags",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_pktap_pfamily,\r\n{ "Protocol family", "pktap.pfamily",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_pktap_llhdrlen,\r\n{ "Link-layer header length", "pktap.llhdrlen",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_pktap_lltrlrlen,\r\n{ "Link-layer trailer length", "pktap.lltrlrlen",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_pktap_pid,\r\n{ "Process ID", "pktap.pid",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_pktap_cmdname,\r\n{ "Command name", "pktap.cmdname",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_pktap_svc_class,\r\n{ "Service class", "pktap.svc_class",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_pktap_iftype,\r\n{ "Interface type", "pktap.iftype",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_pktap_ifunit,\r\n{ "Interface unit", "pktap.ifunit",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_pktap_epid,\r\n{ "Effective process ID", "pktap.epid",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_pktap_ecmdname,\r\n{ "Effective command name", "pktap.ecmdname",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n};\r\nstatic gint *ett[] = {\r\n&ett_pktap,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_pktap_hdrlen_too_short,\r\n{ "pktap.hdrlen_too_short", PI_MALFORMED, PI_ERROR,\r\n"Header length is too short", EXPFILL }},\r\n};\r\nexpert_module_t* expert_pktap;\r\nproto_pktap = proto_register_protocol("PKTAP packet header", "PKTAP",\r\n"pktap");\r\nproto_register_field_array(proto_pktap, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_pktap = expert_register_protocol(proto_pktap);\r\nexpert_register_field_array(expert_pktap, ei, array_length(ei));\r\npktap_handle = register_dissector("pktap", dissect_pktap, proto_pktap);\r\n}\r\nvoid\r\nproto_reg_handoff_pktap(void)\r\n{\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_PKTAP, pktap_handle);\r\npcap_pktdata_handle = find_dissector_add_dependency("pcap_pktdata", proto_pktap);\r\nregister_capture_dissector("wtap_encap", WTAP_ENCAP_PKTAP, capture_pktap, proto_pktap);\r\nregister_capture_dissector("wtap_encap", WTAP_ENCAP_USER2, capture_pktap, proto_pktap);\r\n}
