static void\r\ncall_kerberos_callbacks(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int tag, kerberos_callbacks *cb)\r\n{\r\nif(!cb){\r\nreturn;\r\n}\r\nwhile(cb->tag){\r\nif(cb->tag==tag){\r\ncb->callback(pinfo, tvb, tree);\r\nreturn;\r\n}\r\ncb++;\r\n}\r\nreturn;\r\n}\r\nstatic kerberos_private_data_t*\r\nkerberos_get_private_data(asn1_ctx_t *actx)\r\n{\r\nif (!actx->private_data) {\r\nactx->private_data = wmem_new0(wmem_packet_scope(), kerberos_private_data_t);\r\n}\r\nreturn (kerberos_private_data_t *)(actx->private_data);\r\n}\r\nvoid\r\nread_keytab_file_from_preferences(void)\r\n{\r\nstatic char *last_keytab = NULL;\r\nif (!krb_decrypt) {\r\nreturn;\r\n}\r\nif (keytab_filename == NULL) {\r\nreturn;\r\n}\r\nif (last_keytab && !strcmp(last_keytab, keytab_filename)) {\r\nreturn;\r\n}\r\nif (last_keytab != NULL) {\r\ng_free(last_keytab);\r\nlast_keytab = NULL;\r\n}\r\nlast_keytab = g_strdup(keytab_filename);\r\nread_keytab_file(last_keytab);\r\n}\r\nstatic void\r\nadd_encryption_key(packet_info *pinfo, int keytype, int keylength, const char *keyvalue, const char *origin)\r\n{\r\nenc_key_t *new_key;\r\nif(pinfo->fd->flags.visited){\r\nreturn;\r\n}\r\nnew_key=(enc_key_t *)g_malloc(sizeof(enc_key_t));\r\ng_snprintf(new_key->key_origin, KRB_MAX_ORIG_LEN, "%s learnt from frame %u",origin,pinfo->num);\r\nnew_key->fd_num = pinfo->num;\r\nnew_key->next=enc_key_list;\r\nenc_key_list=new_key;\r\nnew_key->keytype=keytype;\r\nnew_key->keylength=keylength;\r\nnew_key->keyvalue=(char *)g_memdup(keyvalue, keylength);\r\n}\r\nUSES_APPLE_DEPRECATED_API\r\nvoid\r\nread_keytab_file(const char *filename)\r\n{\r\nkrb5_keytab keytab;\r\nkrb5_error_code ret;\r\nkrb5_keytab_entry key;\r\nkrb5_kt_cursor cursor;\r\nenc_key_t *new_key;\r\nstatic gboolean first_time=TRUE;\r\nif (filename == NULL || filename[0] == 0) {\r\nreturn;\r\n}\r\nif(first_time){\r\nfirst_time=FALSE;\r\nret = krb5_init_context(&krb5_ctx);\r\nif(ret && ret != KRB5_CONFIG_CANTOPEN){\r\nreturn;\r\n}\r\n}\r\nret = krb5_kt_resolve(krb5_ctx, filename, &keytab);\r\nif(ret){\r\nfprintf(stderr, "KERBEROS ERROR: Badly formatted keytab filename :%s\n",filename);\r\nreturn;\r\n}\r\nret = krb5_kt_start_seq_get(krb5_ctx, keytab, &cursor);\r\nif(ret){\r\nfprintf(stderr, "KERBEROS ERROR: Could not open or could not read from keytab file :%s\n",filename);\r\nreturn;\r\n}\r\ndo{\r\nnew_key=(enc_key_t *)g_malloc(sizeof(enc_key_t));\r\nnew_key->fd_num = -1;\r\nnew_key->next=enc_key_list;\r\nret = krb5_kt_next_entry(krb5_ctx, keytab, &key, &cursor);\r\nif(ret==0){\r\nint i;\r\nchar *pos;\r\npos=new_key->key_origin;\r\npos+=MIN(KRB_MAX_ORIG_LEN,\r\ng_snprintf(pos, KRB_MAX_ORIG_LEN, "keytab principal "));\r\nfor(i=0;i<key.principal->length;i++){\r\npos+=MIN(KRB_MAX_ORIG_LEN-(pos-new_key->key_origin),\r\ng_snprintf(pos, (gulong)(KRB_MAX_ORIG_LEN-(pos-new_key->key_origin)), "%s%s",(i?"/":""),(key.principal->data[i]).data));\r\n}\r\npos+=MIN(KRB_MAX_ORIG_LEN-(pos-new_key->key_origin),\r\ng_snprintf(pos, (gulong)(KRB_MAX_ORIG_LEN-(pos-new_key->key_origin)), "@%s",key.principal->realm.data));\r\n*pos=0;\r\nnew_key->keytype=key.key.enctype;\r\nnew_key->keylength=key.key.length;\r\nnew_key->keyvalue=(char *)g_memdup(key.key.contents, key.key.length);\r\nenc_key_list=new_key;\r\n}\r\n}while(ret==0);\r\nret = krb5_kt_end_seq_get(krb5_ctx, keytab, &cursor);\r\nif(ret){\r\nkrb5_kt_close(krb5_ctx, keytab);\r\n}\r\n}\r\nguint8 *\r\ndecrypt_krb5_data(proto_tree *tree _U_, packet_info *pinfo,\r\nint usage,\r\ntvbuff_t *cryptotvb,\r\nint keytype,\r\nint *datalen)\r\n{\r\nkrb5_error_code ret;\r\nenc_key_t *ek;\r\nkrb5_data data = {0,0,NULL};\r\nkrb5_keytab_entry key;\r\nint length = tvb_captured_length(cryptotvb);\r\nconst guint8 *cryptotext = tvb_get_ptr(cryptotvb, 0, length);\r\nif(!krb_decrypt || length < 1){\r\nreturn NULL;\r\n}\r\nif (tvb_captured_length(cryptotvb) < tvb_reported_length(cryptotvb)) {\r\nreturn NULL;\r\n}\r\nread_keytab_file_from_preferences();\r\ndata.data = (char *)g_malloc(length);\r\ndata.length = length;\r\nfor(ek=enc_key_list;ek;ek=ek->next){\r\nkrb5_enc_data input;\r\nif((keytype != -1) && (ek->keytype != keytype)) {\r\ncontinue;\r\n}\r\ninput.enctype = ek->keytype;\r\ninput.ciphertext.length = length;\r\ninput.ciphertext.data = (guint8 *)cryptotext;\r\nkey.key.enctype=ek->keytype;\r\nkey.key.length=ek->keylength;\r\nkey.key.contents=ek->keyvalue;\r\nret = krb5_c_decrypt(krb5_ctx, &(key.key), usage, 0, &input, &data);\r\nif(ret == 0){\r\nchar *user_data;\r\nexpert_add_info_format(pinfo, NULL, &ei_kerberos_decrypted_keytype,\r\n"Decrypted keytype %d in frame %u using %s",\r\nek->keytype, pinfo->num, ek->key_origin);\r\nuser_data=data.data;\r\nif (datalen) {\r\n*datalen = data.length;\r\n}\r\nreturn user_data;\r\n}\r\n}\r\ng_free(data.data);\r\nreturn NULL;\r\n}\r\nUSES_APPLE_DEPRECATED_API\r\nvoid\r\nread_keytab_file(const char *filename)\r\n{\r\nkrb5_keytab keytab;\r\nkrb5_error_code ret;\r\nkrb5_keytab_entry key;\r\nkrb5_kt_cursor cursor;\r\nenc_key_t *new_key;\r\nstatic gboolean first_time=TRUE;\r\nif (filename == NULL || filename[0] == 0) {\r\nreturn;\r\n}\r\nif(first_time){\r\nfirst_time=FALSE;\r\nret = krb5_init_context(&krb5_ctx);\r\nif(ret){\r\nreturn;\r\n}\r\n}\r\nret = krb5_kt_resolve(krb5_ctx, filename, &keytab);\r\nif(ret){\r\nfprintf(stderr, "KERBEROS ERROR: Could not open keytab file :%s\n",filename);\r\nreturn;\r\n}\r\nret = krb5_kt_start_seq_get(krb5_ctx, keytab, &cursor);\r\nif(ret){\r\nfprintf(stderr, "KERBEROS ERROR: Could not read from keytab file :%s\n",filename);\r\nreturn;\r\n}\r\ndo{\r\nnew_key = (enc_key_t *)g_malloc(sizeof(enc_key_t));\r\nnew_key->fd_num = -1;\r\nnew_key->next=enc_key_list;\r\nret = krb5_kt_next_entry(krb5_ctx, keytab, &key, &cursor);\r\nif(ret==0){\r\nunsigned int i;\r\nchar *pos;\r\npos=new_key->key_origin;\r\npos+=MIN(KRB_MAX_ORIG_LEN,\r\ng_snprintf(pos, KRB_MAX_ORIG_LEN, "keytab principal "));\r\nfor(i=0;i<key.principal->name.name_string.len;i++){\r\npos+=MIN(KRB_MAX_ORIG_LEN-(pos-new_key->key_origin),\r\ng_snprintf(pos, KRB_MAX_ORIG_LEN-(pos-new_key->key_origin), "%s%s",(i?"/":""),key.principal->name.name_string.val[i]));\r\n}\r\npos+=MIN(KRB_MAX_ORIG_LEN-(pos-new_key->key_origin),\r\ng_snprintf(pos, KRB_MAX_ORIG_LEN-(pos-new_key->key_origin), "@%s",key.principal->realm));\r\n*pos=0;\r\nnew_key->keytype=key.keyblock.keytype;\r\nnew_key->keylength=(int)key.keyblock.keyvalue.length;\r\nnew_key->keyvalue = (guint8 *)g_memdup(key.keyblock.keyvalue.data, (guint)key.keyblock.keyvalue.length);\r\nenc_key_list=new_key;\r\n}\r\n}while(ret==0);\r\nret = krb5_kt_end_seq_get(krb5_ctx, keytab, &cursor);\r\nif(ret){\r\nkrb5_kt_close(krb5_ctx, keytab);\r\n}\r\n}\r\nUSES_APPLE_RST\r\nguint8 *\r\ndecrypt_krb5_data(proto_tree *tree _U_, packet_info *pinfo,\r\nint usage,\r\ntvbuff_t *cryptotvb,\r\nint keytype,\r\nint *datalen)\r\n{\r\nkrb5_error_code ret;\r\nkrb5_data data;\r\nenc_key_t *ek;\r\nint length = tvb_captured_length(cryptotvb);\r\nconst guint8 *cryptotext = tvb_get_ptr(cryptotvb, 0, length);\r\nif(!krb_decrypt){\r\nreturn NULL;\r\n}\r\nif (tvb_captured_length(cryptotvb) < tvb_reported_length(cryptotvb)) {\r\nreturn NULL;\r\n}\r\nread_keytab_file_from_preferences();\r\nfor(ek=enc_key_list;ek;ek=ek->next){\r\nkrb5_keytab_entry key;\r\nkrb5_crypto crypto;\r\nguint8 *cryptocopy;\r\nif((keytype != -1) && (ek->keytype != keytype)) {\r\ncontinue;\r\n}\r\nkey.keyblock.keytype=ek->keytype;\r\nkey.keyblock.keyvalue.length=ek->keylength;\r\nkey.keyblock.keyvalue.data=ek->keyvalue;\r\nret = krb5_crypto_init(krb5_ctx, &(key.keyblock), (krb5_enctype)ENCTYPE_NULL, &crypto);\r\nif(ret){\r\nreturn NULL;\r\n}\r\ncryptocopy = (guint8 *)g_memdup(cryptotext, length);\r\nret = krb5_decrypt_ivec(krb5_ctx, crypto, usage,\r\ncryptocopy, length,\r\n&data,\r\nNULL);\r\ng_free(cryptocopy);\r\nif((ret == 0) && (length>0)){\r\nchar *user_data;\r\nexpert_add_info_format(pinfo, NULL, &ei_kerberos_decrypted_keytype,\r\n"Decrypted keytype %d in frame %u using %s",\r\nek->keytype, pinfo->num, ek->key_origin);\r\nkrb5_crypto_destroy(krb5_ctx, crypto);\r\nuser_data = (char *)g_memdup(data.data, (guint)data.length);\r\nif (datalen) {\r\n*datalen = (int)data.length;\r\n}\r\nreturn user_data;\r\n}\r\nkrb5_crypto_destroy(krb5_ctx, crypto);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nadd_encryption_key(packet_info *pinfo, int keytype, int keylength, const char *keyvalue, const char *origin)\r\n{\r\nservice_key_t *new_key;\r\nif(pinfo->fd->flags.visited){\r\nreturn;\r\n}\r\nnew_key = g_malloc(sizeof(service_key_t));\r\nnew_key->kvno = 0;\r\nnew_key->keytype = keytype;\r\nnew_key->length = keylength;\r\nnew_key->contents = g_memdup(keyvalue, keylength);\r\ng_snprintf(new_key->origin, KRB_MAX_ORIG_LEN, "%s learnt from frame %u", origin, pinfo->num);\r\nservice_key_list = g_slist_append(service_key_list, (gpointer) new_key);\r\n}\r\nstatic void\r\nclear_keytab(void) {\r\nGSList *ske;\r\nservice_key_t *sk;\r\nfor(ske = service_key_list; ske != NULL; ske = g_slist_next(ske)){\r\nsk = (service_key_t *) ske->data;\r\nif (sk) {\r\ng_free(sk->contents);\r\ng_free(sk);\r\n}\r\n}\r\ng_slist_free(service_key_list);\r\nservice_key_list = NULL;\r\n}\r\nstatic void\r\nread_keytab_file(const char *service_key_file)\r\n{\r\nFILE *skf;\r\nws_statb64 st;\r\nservice_key_t *sk;\r\nunsigned char buf[SERVICE_KEY_SIZE];\r\nint newline_skip = 0, count = 0;\r\nif (service_key_file != NULL && ws_stat64 (service_key_file, &st) == 0) {\r\nif (st.st_size > SERVICE_KEY_SIZE) {\r\nif ( (st.st_size % (SERVICE_KEY_SIZE + 1) == 0) ||\r\n(st.st_size % (SERVICE_KEY_SIZE + 1) == SERVICE_KEY_SIZE) ) {\r\nnewline_skip = 1;\r\n} else if ( (st.st_size % (SERVICE_KEY_SIZE + 2) == 0) ||\r\n(st.st_size % (SERVICE_KEY_SIZE + 2) == SERVICE_KEY_SIZE) ) {\r\nnewline_skip = 2;\r\n}\r\n}\r\nskf = ws_fopen(service_key_file, "rb");\r\nif (! skf) return;\r\nwhile (fread(buf, SERVICE_KEY_SIZE, 1, skf) == 1) {\r\nsk = g_malloc(sizeof(service_key_t));\r\nsk->kvno = buf[0] << 8 | buf[1];\r\nsk->keytype = KEYTYPE_DES3_CBC_MD5;\r\nsk->length = DES3_KEY_SIZE;\r\nsk->contents = g_memdup(buf + 2, DES3_KEY_SIZE);\r\ng_snprintf(sk->origin, KRB_MAX_ORIG_LEN, "3DES service key file, key #%d, offset %ld", count, ftell(skf));\r\nservice_key_list = g_slist_append(service_key_list, (gpointer) sk);\r\nif (fseek(skf, newline_skip, SEEK_CUR) < 0) {\r\nfprintf(stderr, "unable to seek...\n");\r\nreturn;\r\n}\r\ncount++;\r\n}\r\nfclose(skf);\r\n}\r\n}\r\nguint8 *\r\ndecrypt_krb5_data(proto_tree *tree, packet_info *pinfo,\r\nint _U_ usage,\r\ntvbuff_t *cryptotvb,\r\nint keytype,\r\nint *datalen)\r\n{\r\ntvbuff_t *encr_tvb;\r\nguint8 *decrypted_data = NULL, *plaintext = NULL;\r\nguint8 cls;\r\ngboolean pc;\r\nguint32 tag, item_len, data_len;\r\nint id_offset, offset;\r\nguint8 key[DES3_KEY_SIZE];\r\nguint8 initial_vector[DES_BLOCK_SIZE];\r\nmd5_state_t md5s;\r\nmd5_byte_t digest[16];\r\nmd5_byte_t zero_fill[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\r\nmd5_byte_t confounder[8];\r\ngboolean ind;\r\nGSList *ske;\r\nservice_key_t *sk;\r\nstruct des3_ctx ctx;\r\nint length = tvb_captured_length(cryptotvb);\r\nconst guint8 *cryptotext = tvb_get_ptr(cryptotvb, 0, length);\r\nif(!krb_decrypt){\r\nreturn NULL;\r\n}\r\nif (tvb_captured_length(cryptotvb) < tvb_reported_length(cryptotvb)) {\r\nreturn NULL;\r\n}\r\nif (keytype != KEYTYPE_DES3_CBC_MD5 || service_key_list == NULL) {\r\nreturn NULL;\r\n}\r\ndecrypted_data = g_malloc(length);\r\nfor(ske = service_key_list; ske != NULL; ske = g_slist_next(ske)){\r\ngboolean do_continue = FALSE;\r\nsk = (service_key_t *) ske->data;\r\ndes_fix_parity(DES3_KEY_SIZE, key, sk->contents);\r\nmd5_init(&md5s);\r\nmemset(initial_vector, 0, DES_BLOCK_SIZE);\r\ndes3_set_key(&ctx, key);\r\ncbc_decrypt(&ctx, des3_decrypt, DES_BLOCK_SIZE, initial_vector,\r\nlength, decrypted_data, cryptotext);\r\nencr_tvb = tvb_new_real_data(decrypted_data, length, length);\r\ntvb_memcpy(encr_tvb, confounder, 0, 8);\r\nTRY {\r\nid_offset = get_ber_identifier(encr_tvb, CONFOUNDER_PLUS_CHECKSUM, &cls, &pc, &tag);\r\noffset = get_ber_length(encr_tvb, id_offset, &item_len, &ind);\r\n}\r\nCATCH_BOUNDS_ERRORS {\r\ntvb_free(encr_tvb);\r\ndo_continue = TRUE;\r\n}\r\nENDTRY;\r\nif (do_continue) continue;\r\ndata_len = item_len + offset - CONFOUNDER_PLUS_CHECKSUM;\r\nif ((int) item_len + offset > length) {\r\ntvb_free(encr_tvb);\r\ncontinue;\r\n}\r\nmd5_append(&md5s, confounder, 8);\r\nmd5_append(&md5s, zero_fill, 16);\r\nmd5_append(&md5s, decrypted_data + CONFOUNDER_PLUS_CHECKSUM, data_len);\r\nmd5_finish(&md5s, digest);\r\nif (tvb_memeql (encr_tvb, 8, digest, 16) == 0) {\r\nplaintext = g_malloc(data_len);\r\ntvb_memcpy(encr_tvb, plaintext, CONFOUNDER_PLUS_CHECKSUM, data_len);\r\ntvb_free(encr_tvb);\r\nif (datalen) {\r\n*datalen = data_len;\r\n}\r\ng_free(decrypted_data);\r\nreturn(plaintext);\r\n}\r\ntvb_free(encr_tvb);\r\n}\r\ng_free(decrypted_data);\r\nreturn NULL;\r\n}\r\nstatic int\r\ndissect_krb5_decrypt_ticket_data (gboolean imp_tag _U_, tvbuff_t *tvb, int offset, asn1_ctx_t *actx,\r\nproto_tree *tree, int hf_index _U_)\r\n{\r\nguint8 *plaintext;\r\nint length;\r\nkerberos_private_data_t *private_data = kerberos_get_private_data(actx);\r\ntvbuff_t *next_tvb;\r\nnext_tvb=tvb_new_subset_remaining(tvb, offset);\r\nlength=tvb_captured_length_remaining(tvb, offset);\r\nplaintext=decrypt_krb5_data(tree, actx->pinfo, 2, next_tvb, private_data->etype, NULL);\r\nif(plaintext){\r\ntvbuff_t *child_tvb;\r\nchild_tvb = tvb_new_child_real_data(tvb, plaintext, length, length);\r\ntvb_set_free_cb(child_tvb, g_free);\r\nadd_new_data_source(actx->pinfo, child_tvb, "Decrypted Krb5");\r\noffset=dissect_kerberos_Applications(FALSE, child_tvb, 0, actx , tree, -1);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_decrypt_authenticator_data (gboolean imp_tag _U_, tvbuff_t *tvb, int offset, asn1_ctx_t *actx,\r\nproto_tree *tree, int hf_index _U_)\r\n{\r\nguint8 *plaintext;\r\nint length;\r\nkerberos_private_data_t *private_data = kerberos_get_private_data(actx);\r\ntvbuff_t *next_tvb;\r\nnext_tvb=tvb_new_subset_remaining(tvb, offset);\r\nlength=tvb_captured_length_remaining(tvb, offset);\r\nplaintext=decrypt_krb5_data(tree, actx->pinfo, 7, next_tvb, private_data->etype, NULL);\r\nif(!plaintext){\r\nplaintext=decrypt_krb5_data(tree, actx->pinfo, 11, next_tvb, private_data->etype, NULL);\r\n}\r\nif(plaintext){\r\ntvbuff_t *child_tvb;\r\nchild_tvb = tvb_new_child_real_data(tvb, plaintext, length, length);\r\ntvb_set_free_cb(child_tvb, g_free);\r\nadd_new_data_source(actx->pinfo, child_tvb, "Decrypted Krb5");\r\noffset=dissect_kerberos_Applications(FALSE, child_tvb, 0, actx , tree, -1);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_decrypt_KDC_REP_data (gboolean imp_tag _U_, tvbuff_t *tvb, int offset, asn1_ctx_t *actx,\r\nproto_tree *tree, int hf_index _U_)\r\n{\r\nguint8 *plaintext;\r\nint length;\r\nkerberos_private_data_t *private_data = kerberos_get_private_data(actx);\r\ntvbuff_t *next_tvb;\r\nnext_tvb=tvb_new_subset_remaining(tvb, offset);\r\nlength=tvb_captured_length_remaining(tvb, offset);\r\nplaintext=decrypt_krb5_data(tree, actx->pinfo, 3, next_tvb, private_data->etype, NULL);\r\nif(!plaintext){\r\nplaintext=decrypt_krb5_data(tree, actx->pinfo, 8, next_tvb, private_data->etype, NULL);\r\n}\r\nif(!plaintext){\r\nplaintext=decrypt_krb5_data(tree, actx->pinfo, 9, next_tvb, private_data->etype, NULL);\r\n}\r\nif(plaintext){\r\ntvbuff_t *child_tvb;\r\nchild_tvb = tvb_new_child_real_data(tvb, plaintext, length, length);\r\ntvb_set_free_cb(child_tvb, g_free);\r\nadd_new_data_source(actx->pinfo, child_tvb, "Decrypted Krb5");\r\noffset=dissect_kerberos_Applications(FALSE, child_tvb, 0, actx , tree, -1);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_decrypt_PA_ENC_TIMESTAMP (gboolean imp_tag _U_, tvbuff_t *tvb, int offset, asn1_ctx_t *actx,\r\nproto_tree *tree, int hf_index _U_)\r\n{\r\nguint8 *plaintext;\r\nint length;\r\nkerberos_private_data_t *private_data = kerberos_get_private_data(actx);\r\ntvbuff_t *next_tvb;\r\nnext_tvb=tvb_new_subset_remaining(tvb, offset);\r\nlength=tvb_captured_length_remaining(tvb, offset);\r\nplaintext=decrypt_krb5_data(tree, actx->pinfo, 1, next_tvb, private_data->etype, NULL);\r\nif(plaintext){\r\ntvbuff_t *child_tvb;\r\nchild_tvb = tvb_new_child_real_data(tvb, plaintext, length, length);\r\ntvb_set_free_cb(child_tvb, g_free);\r\nadd_new_data_source(actx->pinfo, child_tvb, "Decrypted Krb5");\r\noffset=dissect_kerberos_Applications(FALSE, child_tvb, 0, actx , tree, -1);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_decrypt_AP_REP_data (gboolean imp_tag _U_, tvbuff_t *tvb, int offset, asn1_ctx_t *actx,\r\nproto_tree *tree, int hf_index _U_)\r\n{\r\nguint8 *plaintext;\r\nint length;\r\nkerberos_private_data_t *private_data = kerberos_get_private_data(actx);\r\ntvbuff_t *next_tvb;\r\nnext_tvb=tvb_new_subset_remaining(tvb, offset);\r\nlength=tvb_captured_length_remaining(tvb, offset);\r\nplaintext=decrypt_krb5_data(tree, actx->pinfo, 12, next_tvb, private_data->etype, NULL);\r\nif(plaintext){\r\ntvbuff_t *child_tvb;\r\nchild_tvb = tvb_new_child_real_data(tvb, plaintext, length, length);\r\ntvb_set_free_cb(child_tvb, g_free);\r\nadd_new_data_source(actx->pinfo, child_tvb, "Decrypted Krb5");\r\noffset=dissect_kerberos_Applications(FALSE, child_tvb, 0, actx , tree, -1);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_decrypt_PRIV_data (gboolean imp_tag _U_, tvbuff_t *tvb, int offset, asn1_ctx_t *actx,\r\nproto_tree *tree, int hf_index _U_)\r\n{\r\nguint8 *plaintext;\r\nint length;\r\nkerberos_private_data_t *private_data = kerberos_get_private_data(actx);\r\ntvbuff_t *next_tvb;\r\nnext_tvb=tvb_new_subset_remaining(tvb, offset);\r\nlength=tvb_captured_length_remaining(tvb, offset);\r\nplaintext=decrypt_krb5_data(tree, actx->pinfo, 13, next_tvb, private_data->etype, NULL);\r\nif(plaintext){\r\ntvbuff_t *child_tvb;\r\nchild_tvb = tvb_new_child_real_data(tvb, plaintext, length, length);\r\ntvb_set_free_cb(child_tvb, g_free);\r\nadd_new_data_source(actx->pinfo, child_tvb, "Decrypted Krb5");\r\noffset=dissect_kerberos_Applications(FALSE, child_tvb, 0, actx , tree, -1);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_decrypt_CRED_data (gboolean imp_tag _U_, tvbuff_t *tvb, int offset, asn1_ctx_t *actx,\r\nproto_tree *tree, int hf_index _U_)\r\n{\r\nguint8 *plaintext;\r\nint length;\r\nkerberos_private_data_t *private_data = kerberos_get_private_data(actx);\r\ntvbuff_t *next_tvb;\r\nnext_tvb=tvb_new_subset_remaining(tvb, offset);\r\nlength=tvb_captured_length_remaining(tvb, offset);\r\nplaintext=decrypt_krb5_data(tree, actx->pinfo, 14, next_tvb, private_data->etype, NULL);\r\nif(plaintext){\r\ntvbuff_t *child_tvb;\r\nchild_tvb = tvb_new_child_real_data(tvb, plaintext, length, length);\r\ntvb_set_free_cb(child_tvb, g_free);\r\nadd_new_data_source(actx->pinfo, child_tvb, "Decrypted Krb5");\r\noffset=dissect_kerberos_Applications(FALSE, child_tvb, 0, actx , tree, -1);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_rfc1964_checksum(asn1_ctx_t *actx _U_, proto_tree *tree, tvbuff_t *tvb)\r\n{\r\nint offset=0;\r\nguint32 len;\r\nguint16 dlglen;\r\nlen=tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_krb_gssapi_len, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_krb_gssapi_bnd, tvb, offset, len, ENC_NA);\r\noffset += len;\r\nproto_tree_add_item(tree, hf_krb_gssapi_c_flag_dce_style, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_krb_gssapi_c_flag_integ, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_krb_gssapi_c_flag_conf, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_krb_gssapi_c_flag_sequence, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_krb_gssapi_c_flag_replay, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_krb_gssapi_c_flag_mutual, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_krb_gssapi_c_flag_deleg, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nif(tvb_reported_length_remaining(tvb, offset)<2){\r\nreturn offset;\r\n}\r\nproto_tree_add_item(tree, hf_krb_gssapi_dlgopt, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nif(tvb_reported_length_remaining(tvb, offset)<2){\r\nreturn offset;\r\n}\r\ndlglen=tvb_get_letohs(tvb, offset);\r\nproto_tree_add_item(tree, hf_krb_gssapi_dlglen, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nif(dlglen!=tvb_reported_length_remaining(tvb, offset)){\r\nproto_tree_add_expert_format(tree, actx->pinfo, &ei_krb_gssapi_dlglen, tvb, 0, 0,\r\n"Error: DlgLen:%d is not the same as number of bytes remaining:%d", dlglen, tvb_captured_length_remaining(tvb, offset));\r\nreturn offset;\r\n}\r\noffset=dissect_kerberos_Applications(FALSE, tvb, offset, actx, tree, -1);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_PA_PROV_SRV_LOCATION(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_)\r\n{\r\noffset=dissect_ber_GeneralString(actx, tree, tvb, offset, hf_krb_provsrv_location, NULL, 0);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_PW_SALT(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_)\r\n{\r\nguint32 nt_status;\r\nproto_tree_add_item(tree, hf_krb_smb_nt_status, tvb, offset, 4,\r\nENC_LITTLE_ENDIAN);\r\nnt_status=tvb_get_letohl(tvb, offset);\r\nif(nt_status) {\r\ncol_append_fstr(actx->pinfo->cinfo, COL_INFO,\r\n" NT Status: %s",\r\nval_to_str(nt_status, NT_errors,\r\n"Unknown error code %#x"));\r\n}\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_krb_smb_unknown, tvb, offset, 4,\r\nENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_krb_smb_unknown, tvb, offset, 4,\r\nENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_PAC_DREP(proto_tree *parent_tree, tvbuff_t *tvb, int offset, guint8 *drep)\r\n{\r\nproto_tree *tree;\r\nguint8 val;\r\ntree = proto_tree_add_subtree(parent_tree, tvb, offset, 16, ett_krb_pac_drep, NULL, "DREP");\r\nval = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(tree, hf_dcerpc_drep_byteorder, tvb, offset, 1, val>>4);\r\noffset++;\r\nif (drep) {\r\n*drep = val;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_PAC_NDRHEADERBLOB(proto_tree *parent_tree, tvbuff_t *tvb, int offset, guint8 *drep, asn1_ctx_t *actx _U_)\r\n{\r\nproto_tree *tree;\r\ntree = proto_tree_add_subtree(parent_tree, tvb, offset, 16, ett_krb_pac_midl_blob, NULL, "MES header");\r\nproto_tree_add_item(tree, hf_krb_midl_version, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\noffset = dissect_krb5_PAC_DREP(tree, tvb, offset, drep);\r\nproto_tree_add_item(tree, hf_krb_midl_hdr_len, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(tree, hf_krb_midl_fill_bytes, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_krb_midl_blob_len, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_PAC_LOGON_INFO(proto_tree *parent_tree, tvbuff_t *tvb, int offset, asn1_ctx_t *actx _U_)\r\n{\r\nproto_item *item;\r\nproto_tree *tree;\r\nguint8 drep[4] = { 0x10, 0x00, 0x00, 0x00};\r\nstatic dcerpc_info di;\r\nstatic dcerpc_call_value call_data;\r\nitem = proto_tree_add_item(parent_tree, hf_krb_pac_logon_info, tvb, offset, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_krb_pac_logon_info);\r\noffset = dissect_krb5_PAC_NDRHEADERBLOB(tree, tvb, offset, &drep[0], actx);\r\ndi.conformant_run=0;\r\ndi.call_data=&call_data;\r\ninit_ndr_pointer_list(&di);\r\noffset = dissect_ndr_pointer(tvb, offset, actx->pinfo, tree, &di, drep,\r\nnetlogon_dissect_PAC_LOGON_INFO, NDR_POINTER_UNIQUE,\r\n"PAC_LOGON_INFO:", -1);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_PAC_S4U_DELEGATION_INFO(proto_tree *parent_tree, tvbuff_t *tvb, int offset, asn1_ctx_t *actx)\r\n{\r\nproto_item *item;\r\nproto_tree *tree;\r\nguint8 drep[4] = { 0x10, 0x00, 0x00, 0x00};\r\nstatic dcerpc_info di;\r\nstatic dcerpc_call_value call_data;\r\nitem = proto_tree_add_item(parent_tree, hf_krb_pac_s4u_delegation_info, tvb, offset, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_krb_pac_s4u_delegation_info);\r\noffset = dissect_krb5_PAC_NDRHEADERBLOB(tree, tvb, offset, &drep[0], actx);\r\ndi.conformant_run=0;\r\ndi.call_data=&call_data;\r\ninit_ndr_pointer_list(&di);\r\noffset = dissect_ndr_pointer(tvb, offset, actx->pinfo, tree, &di, drep,\r\nnetlogon_dissect_PAC_S4U_DELEGATION_INFO, NDR_POINTER_UNIQUE,\r\n"PAC_S4U_DELEGATION_INFO:", -1);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_PAC_UPN_DNS_INFO(proto_tree *parent_tree, tvbuff_t *tvb, int offset, asn1_ctx_t *actx _U_)\r\n{\r\nproto_item *item;\r\nproto_tree *tree;\r\nguint16 dns_offset, dns_len;\r\nguint16 upn_offset, upn_len;\r\nconst char *dn;\r\nint dn_len;\r\nguint16 bc;\r\nitem = proto_tree_add_item(parent_tree, hf_krb_pac_upn_dns_info, tvb, offset, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_krb_pac_upn_dns_info);\r\nupn_len = tvb_get_letohs(tvb, offset);\r\nproto_tree_add_item(tree, hf_krb_pac_upn_upn_len, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset+=2;\r\nupn_offset = tvb_get_letohs(tvb, offset);\r\nproto_tree_add_item(tree, hf_krb_pac_upn_upn_offset, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset+=2;\r\ndns_len = tvb_get_letohs(tvb, offset);\r\nproto_tree_add_item(tree, hf_krb_pac_upn_dns_len, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset+=2;\r\ndns_offset = tvb_get_letohs(tvb, offset);\r\nproto_tree_add_item(tree, hf_krb_pac_upn_dns_offset, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(tree, hf_krb_pac_upn_flags, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset = upn_offset;\r\ndn_len = upn_len;\r\nbc = tvb_reported_length_remaining(tvb, offset);\r\ndn = get_unicode_or_ascii_string(tvb, &offset, TRUE, &dn_len, TRUE, TRUE, &bc);\r\nproto_tree_add_string(tree, hf_krb_pac_upn_upn_name, tvb, upn_offset, upn_len, dn);\r\noffset = dns_offset;\r\ndn_len = dns_len;\r\nbc = tvb_reported_length_remaining(tvb, offset);\r\ndn = get_unicode_or_ascii_string(tvb, &offset, TRUE, &dn_len, TRUE, TRUE, &bc);\r\nproto_tree_add_string(tree, hf_krb_pac_upn_dns_name, tvb, dns_offset, dns_len, dn);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_PAC_CREDENTIAL_TYPE(proto_tree *parent_tree, tvbuff_t *tvb, int offset, asn1_ctx_t *actx _U_)\r\n{\r\nproto_tree_add_item(parent_tree, hf_krb_pac_credential_type, tvb, offset, -1, ENC_NA);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_PAC_SERVER_CHECKSUM(proto_tree *parent_tree, tvbuff_t *tvb, int offset, asn1_ctx_t *actx _U_)\r\n{\r\nproto_item *item;\r\nproto_tree *tree;\r\nitem = proto_tree_add_item(parent_tree, hf_krb_pac_server_checksum, tvb, offset, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_krb_pac_server_checksum);\r\nproto_tree_add_item(tree, hf_krb_pac_signature_type, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_krb_pac_signature_signature, tvb, offset, -1, ENC_NA);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_PAC_PRIVSVR_CHECKSUM(proto_tree *parent_tree, tvbuff_t *tvb, int offset, asn1_ctx_t *actx _U_)\r\n{\r\nproto_item *item;\r\nproto_tree *tree;\r\nitem = proto_tree_add_item(parent_tree, hf_krb_pac_privsvr_checksum, tvb, offset, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_krb_pac_privsvr_checksum);\r\nproto_tree_add_item(tree, hf_krb_pac_signature_type, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_krb_pac_signature_signature, tvb, offset, -1, ENC_NA);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_PAC_CLIENT_INFO_TYPE(proto_tree *parent_tree, tvbuff_t *tvb, int offset, asn1_ctx_t *actx _U_)\r\n{\r\nproto_item *item;\r\nproto_tree *tree;\r\nguint16 namelen;\r\nitem = proto_tree_add_item(parent_tree, hf_krb_pac_client_info_type, tvb, offset, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_krb_pac_client_info_type);\r\noffset = dissect_nt_64bit_time(tvb, tree, offset, hf_krb_pac_clientid);\r\nnamelen=tvb_get_letohs(tvb, offset);\r\nproto_tree_add_uint(tree, hf_krb_pac_namelen, tvb, offset, 2, namelen);\r\noffset+=2;\r\nproto_tree_add_item(tree, hf_krb_pac_clientname, tvb, offset, namelen, ENC_UTF_16|ENC_LITTLE_ENDIAN);\r\noffset+=namelen;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_AD_WIN2K_PAC_struct(proto_tree *tree, tvbuff_t *tvb, int offset, asn1_ctx_t *actx)\r\n{\r\nguint32 pac_type;\r\nguint32 pac_size;\r\nguint32 pac_offset;\r\nproto_item *it=NULL;\r\nproto_tree *tr=NULL;\r\ntvbuff_t *next_tvb;\r\npac_type=tvb_get_letohl(tvb, offset);\r\nit=proto_tree_add_uint(tree, hf_krb_w2k_pac_type, tvb, offset, 4, pac_type);\r\ntr=proto_item_add_subtree(it, ett_krb_pac);\r\noffset += 4;\r\npac_size=tvb_get_letohl(tvb, offset);\r\nproto_tree_add_uint(tr, hf_krb_w2k_pac_size, tvb, offset, 4, pac_size);\r\noffset += 4;\r\npac_offset=tvb_get_letohl(tvb, offset);\r\nproto_tree_add_uint(tr, hf_krb_w2k_pac_offset, tvb, offset, 4, pac_offset);\r\noffset += 8;\r\nnext_tvb=tvb_new_subset(tvb, pac_offset, pac_size, pac_size);\r\nswitch(pac_type){\r\ncase PAC_LOGON_INFO:\r\ndissect_krb5_PAC_LOGON_INFO(tr, next_tvb, 0, actx);\r\nbreak;\r\ncase PAC_CREDENTIAL_TYPE:\r\ndissect_krb5_PAC_CREDENTIAL_TYPE(tr, next_tvb, 0, actx);\r\nbreak;\r\ncase PAC_SERVER_CHECKSUM:\r\ndissect_krb5_PAC_SERVER_CHECKSUM(tr, next_tvb, 0, actx);\r\nbreak;\r\ncase PAC_PRIVSVR_CHECKSUM:\r\ndissect_krb5_PAC_PRIVSVR_CHECKSUM(tr, next_tvb, 0, actx);\r\nbreak;\r\ncase PAC_CLIENT_INFO_TYPE:\r\ndissect_krb5_PAC_CLIENT_INFO_TYPE(tr, next_tvb, 0, actx);\r\nbreak;\r\ncase PAC_S4U_DELEGATION_INFO:\r\ndissect_krb5_PAC_S4U_DELEGATION_INFO(tr, next_tvb, 0, actx);\r\nbreak;\r\ncase PAC_UPN_DNS_INFO:\r\ndissect_krb5_PAC_UPN_DNS_INFO(tr, next_tvb, 0, actx);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_krb5_AD_WIN2K_PAC(gboolean implicit_tag _U_, tvbuff_t *tvb, int offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index _U_)\r\n{\r\nguint32 entries;\r\nguint32 version;\r\nguint32 i;\r\nentries=tvb_get_letohl(tvb, offset);\r\nproto_tree_add_uint(tree, hf_krb_w2k_pac_entries, tvb, offset, 4, entries);\r\noffset += 4;\r\nversion=tvb_get_letohl(tvb, offset);\r\nproto_tree_add_uint(tree, hf_krb_w2k_pac_version, tvb, offset, 4, version);\r\noffset += 4;\r\nfor(i=0;i<entries;i++){\r\noffset=dissect_krb5_AD_WIN2K_PAC_struct(tree, tvb, offset, actx);\r\n}\r\nreturn offset;\r\n}\r\nint\r\ndissect_krb5_Checksum(proto_tree *tree, tvbuff_t *tvb, int offset, asn1_ctx_t *actx _U_)\r\n{\r\nreturn dissect_kerberos_Checksum(FALSE, tvb, offset, actx, tree, hf_kerberos_cksum);\r\n}\r\nint\r\ndissect_krb5_ctime(proto_tree *tree, tvbuff_t *tvb, int offset, asn1_ctx_t *actx _U_)\r\n{\r\nreturn dissect_kerberos_KerberosTime(FALSE, tvb, offset, actx, tree, hf_kerberos_ctime);\r\n}\r\nint\r\ndissect_krb5_cname(proto_tree *tree, tvbuff_t *tvb, int offset, asn1_ctx_t *actx _U_)\r\n{\r\nreturn dissect_kerberos_PrincipalName(FALSE, tvb, offset, actx, tree, hf_kerberos_cname);\r\n}\r\nint\r\ndissect_krb5_realm(proto_tree *tree, tvbuff_t *tvb, int offset, asn1_ctx_t *actx _U_)\r\n{\r\nreturn dissect_kerberos_Realm(FALSE, tvb, offset, actx, tree, hf_kerberos_realm);\r\n}\r\nstatic gint\r\ndissect_kerberos_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngboolean dci, gboolean do_col_protocol, gboolean have_rm,\r\nkerberos_callbacks *cb)\r\n{\r\nvolatile int offset = 0;\r\nproto_tree *volatile kerberos_tree = NULL;\r\nproto_item *volatile item = NULL;\r\nasn1_ctx_t asn1_ctx;\r\nguint32 krb_rm = 0;\r\ngint krb_reclen = 0;\r\ngbl_do_col_info=dci;\r\nif (have_rm) {\r\nkrb_rm = tvb_get_ntohl(tvb, offset);\r\nkrb_reclen = kerberos_rm_to_reclen(krb_rm);\r\nif (krb_reclen > 10 * 1024 * 1024) {\r\nreturn (-1);\r\n}\r\nif (do_col_protocol) {\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "KRB5");\r\n}\r\nif (tree) {\r\nitem = proto_tree_add_item(tree, proto_kerberos, tvb, 0, -1, ENC_NA);\r\nkerberos_tree = proto_item_add_subtree(item, ett_kerberos);\r\n}\r\nshow_krb_recordmark(kerberos_tree, tvb, offset, krb_rm);\r\noffset += 4;\r\n} else {\r\ngint8 tmp_class;\r\ngboolean tmp_pc;\r\ngint32 tmp_tag;\r\nget_ber_identifier(tvb, offset, &tmp_class, &tmp_pc, &tmp_tag);\r\nif(tmp_class!=BER_CLASS_APP){\r\nreturn 0;\r\n}\r\nswitch(tmp_tag){\r\ncase KRB5_MSG_TICKET:\r\ncase KRB5_MSG_AUTHENTICATOR:\r\ncase KRB5_MSG_ENC_TICKET_PART:\r\ncase KRB5_MSG_AS_REQ:\r\ncase KRB5_MSG_AS_REP:\r\ncase KRB5_MSG_TGS_REQ:\r\ncase KRB5_MSG_TGS_REP:\r\ncase KRB5_MSG_AP_REQ:\r\ncase KRB5_MSG_AP_REP:\r\ncase KRB5_MSG_ENC_AS_REP_PART:\r\ncase KRB5_MSG_ENC_TGS_REP_PART:\r\ncase KRB5_MSG_ENC_AP_REP_PART:\r\ncase KRB5_MSG_ENC_KRB_PRIV_PART:\r\ncase KRB5_MSG_ENC_KRB_CRED_PART:\r\ncase KRB5_MSG_SAFE:\r\ncase KRB5_MSG_PRIV:\r\ncase KRB5_MSG_ERROR:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (do_col_protocol) {\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "KRB5");\r\n}\r\nif (gbl_do_col_info) {\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\n}\r\nif (tree) {\r\nitem = proto_tree_add_item(tree, proto_kerberos, tvb, 0, -1, ENC_NA);\r\nkerberos_tree = proto_item_add_subtree(item, ett_kerberos);\r\n}\r\n}\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\r\nasn1_ctx.private_data = cb;\r\nTRY {\r\noffset=dissect_kerberos_Applications(FALSE, tvb, offset, &asn1_ctx , kerberos_tree, -1);\r\n} CATCH_BOUNDS_ERRORS {\r\nRETHROW;\r\n} ENDTRY;\r\nproto_item_set_len(item, offset);\r\nreturn offset;\r\n}\r\nvoid\r\nshow_krb_recordmark(proto_tree *tree, tvbuff_t *tvb, gint start, guint32 krb_rm)\r\n{\r\ngint rec_len;\r\nproto_tree *rm_tree;\r\nif (tree == NULL)\r\nreturn;\r\nrec_len = kerberos_rm_to_reclen(krb_rm);\r\nrm_tree = proto_tree_add_subtree_format(tree, tvb, start, 4, ett_krb_recordmark, NULL,\r\n"Record Mark: %u %s", rec_len, plurality(rec_len, "byte", "bytes"));\r\nproto_tree_add_boolean(rm_tree, hf_krb_rm_reserved, tvb, start, 4, krb_rm);\r\nproto_tree_add_uint(rm_tree, hf_krb_rm_reclen, tvb, start, 4, krb_rm);\r\n}\r\ngint\r\ndissect_kerberos_main(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int do_col_info, kerberos_callbacks *cb)\r\n{\r\nreturn (dissect_kerberos_common(tvb, pinfo, tree, do_col_info, FALSE, FALSE, cb));\r\n}\r\nguint32\r\nkerberos_output_keytype(void)\r\n{\r\nreturn gbl_keytype;\r\n}\r\nstatic gint\r\ndissect_kerberos_udp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nif(tvb_captured_length(tvb) >= 1 && tvb_get_guint8(tvb, 0)<=0x10){\r\nif(krb4_handle){\r\ngboolean res;\r\nres=call_dissector_only(krb4_handle, tvb, pinfo, tree, NULL);\r\nreturn res;\r\n}else{\r\nreturn 0;\r\n}\r\n}\r\nreturn dissect_kerberos_common(tvb, pinfo, tree, TRUE, TRUE, FALSE, NULL);\r\n}\r\ngint\r\nkerberos_rm_to_reclen(guint krb_rm)\r\n{\r\nreturn (krb_rm & KRB_RM_RECLEN);\r\n}\r\nguint\r\nget_krb_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nguint krb_rm;\r\ngint pdulen;\r\nkrb_rm = tvb_get_ntohl(tvb, offset);\r\npdulen = kerberos_rm_to_reclen(krb_rm);\r\nreturn (pdulen + 4);\r\n}\r\nstatic void\r\nkerberos_prefs_apply_cb(void) {\r\n#ifdef HAVE_LIBNETTLE\r\nclear_keytab();\r\nread_keytab_file(keytab_filename);\r\n#endif\r\n}\r\nstatic int\r\ndissect_kerberos_tcp_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\npinfo->fragmented = TRUE;\r\nif (dissect_kerberos_common(tvb, pinfo, tree, TRUE, TRUE, TRUE, NULL) < 0) {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Continuation");\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_kerberos_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "KRB5");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ntcp_dissect_pdus(tvb, pinfo, tree, krb_desegment, 4, get_krb_pdu_len,\r\ndissect_kerberos_tcp_pdu, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_kerberos(void) {\r\nstatic hf_register_info hf[] = {\r\n{ &hf_krb_rm_reserved, {\r\n"Reserved", "kerberos.rm.reserved", FT_BOOLEAN, 32,\r\nTFS(&tfs_set_notset), KRB_RM_RESERVED, "Record mark reserved bit", HFILL }},\r\n{ &hf_krb_rm_reclen, {\r\n"Record Length", "kerberos.rm.length", FT_UINT32, BASE_DEC,\r\nNULL, KRB_RM_RECLEN, NULL, HFILL }},\r\n{ &hf_krb_provsrv_location, {\r\n"PROVSRV Location", "kerberos.provsrv_location", FT_STRING, BASE_NONE,\r\nNULL, 0, "PacketCable PROV SRV Location", HFILL }},\r\n{ &hf_krb_smb_nt_status,\r\n{ "NT Status", "kerberos.smb.nt_status", FT_UINT32, BASE_HEX,\r\nVALS(NT_errors), 0, "NT Status code", HFILL }},\r\n{ &hf_krb_smb_unknown,\r\n{ "Unknown", "kerberos.smb.unknown", FT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_krb_address_ip, {\r\n"IP Address", "kerberos.addr_ip", FT_IPv4, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_krb_address_ipv6, {\r\n"IPv6 Address", "kerberos.addr_ipv6", FT_IPv6, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_krb_address_netbios, {\r\n"NetBIOS Address", "kerberos.addr_nb", FT_STRING, BASE_NONE,\r\nNULL, 0, "NetBIOS Address and type", HFILL }},\r\n{ &hf_krb_gssapi_len, {\r\n"Length", "kerberos.gssapi.len", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Length of GSSAPI Bnd field", HFILL }},\r\n{ &hf_krb_gssapi_bnd, {\r\n"Bnd", "kerberos.gssapi.bdn", FT_BYTES, BASE_NONE,\r\nNULL, 0, "GSSAPI Bnd field", HFILL }},\r\n{ &hf_krb_gssapi_c_flag_deleg, {\r\n"Deleg", "kerberos.gssapi.checksum.flags.deleg", FT_BOOLEAN, 32,\r\nTFS(&tfs_gss_flags_deleg), KRB5_GSS_C_DELEG_FLAG, NULL, HFILL }},\r\n{ &hf_krb_gssapi_c_flag_mutual, {\r\n"Mutual", "kerberos.gssapi.checksum.flags.mutual", FT_BOOLEAN, 32,\r\nTFS(&tfs_gss_flags_mutual), KRB5_GSS_C_MUTUAL_FLAG, NULL, HFILL }},\r\n{ &hf_krb_gssapi_c_flag_replay, {\r\n"Replay", "kerberos.gssapi.checksum.flags.replay", FT_BOOLEAN, 32,\r\nTFS(&tfs_gss_flags_replay), KRB5_GSS_C_REPLAY_FLAG, NULL, HFILL }},\r\n{ &hf_krb_gssapi_c_flag_sequence, {\r\n"Sequence", "kerberos.gssapi.checksum.flags.sequence", FT_BOOLEAN, 32,\r\nTFS(&tfs_gss_flags_sequence), KRB5_GSS_C_SEQUENCE_FLAG, NULL, HFILL }},\r\n{ &hf_krb_gssapi_c_flag_conf, {\r\n"Conf", "kerberos.gssapi.checksum.flags.conf", FT_BOOLEAN, 32,\r\nTFS(&tfs_gss_flags_conf), KRB5_GSS_C_CONF_FLAG, NULL, HFILL }},\r\n{ &hf_krb_gssapi_c_flag_integ, {\r\n"Integ", "kerberos.gssapi.checksum.flags.integ", FT_BOOLEAN, 32,\r\nTFS(&tfs_gss_flags_integ), KRB5_GSS_C_INTEG_FLAG, NULL, HFILL }},\r\n{ &hf_krb_gssapi_c_flag_dce_style, {\r\n"DCE-style", "kerberos.gssapi.checksum.flags.dce-style", FT_BOOLEAN, 32,\r\nTFS(&tfs_gss_flags_dce_style), KRB5_GSS_C_DCE_STYLE, NULL, HFILL }},\r\n{ &hf_krb_gssapi_dlgopt, {\r\n"DlgOpt", "kerberos.gssapi.dlgopt", FT_UINT16, BASE_DEC,\r\nNULL, 0, "GSSAPI DlgOpt", HFILL }},\r\n{ &hf_krb_gssapi_dlglen, {\r\n"DlgLen", "kerberos.gssapi.dlglen", FT_UINT16, BASE_DEC,\r\nNULL, 0, "GSSAPI DlgLen", HFILL }},\r\n{ &hf_krb_midl_blob_len, {\r\n"Blob Length", "kerberos.midl_blob_len", FT_UINT64, BASE_DEC,\r\nNULL, 0, "Length of NDR encoded data that follows", HFILL }},\r\n{ &hf_krb_midl_fill_bytes, {\r\n"Fill bytes", "kerberos.midl.fill_bytes", FT_UINT32, BASE_HEX,\r\nNULL, 0, "Just some fill bytes", HFILL }},\r\n{ &hf_krb_midl_version, {\r\n"Version", "kerberos.midl.version", FT_UINT8, BASE_DEC,\r\nNULL, 0, "Version of pickling", HFILL }},\r\n{ &hf_krb_midl_hdr_len, {\r\n"HDR Length", "kerberos.midl.hdr_len", FT_UINT16, BASE_DEC,\r\nNULL, 0, "Length of header", HFILL }},\r\n{ &hf_krb_pac_signature_type, {\r\n"Type", "kerberos.pac.signature.type", FT_INT32, BASE_DEC,\r\nNULL, 0, "PAC Signature Type", HFILL }},\r\n{ &hf_krb_pac_signature_signature, {\r\n"Signature", "kerberos.pac.signature.signature", FT_BYTES, BASE_NONE,\r\nNULL, 0, "A PAC signature blob", HFILL }},\r\n{ &hf_krb_w2k_pac_entries, {\r\n"Num Entries", "kerberos.pac.entries", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Number of W2k PAC entries", HFILL }},\r\n{ &hf_krb_w2k_pac_version, {\r\n"Version", "kerberos.pac.version", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Version of PAC structures", HFILL }},\r\n{ &hf_krb_w2k_pac_type, {\r\n"Type", "kerberos.pac.type", FT_UINT32, BASE_DEC,\r\nVALS(w2k_pac_types), 0, "Type of W2k PAC entry", HFILL }},\r\n{ &hf_krb_w2k_pac_size, {\r\n"Size", "kerberos.pac.size", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Size of W2k PAC entry", HFILL }},\r\n{ &hf_krb_w2k_pac_offset, {\r\n"Offset", "kerberos.pac.offset", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Offset to W2k PAC entry", HFILL }},\r\n{ &hf_krb_pac_clientid, {\r\n"ClientID", "kerberos.pac.clientid", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\r\nNULL, 0, "ClientID Timestamp", HFILL }},\r\n{ &hf_krb_pac_namelen, {\r\n"Name Length", "kerberos.pac.namelen", FT_UINT16, BASE_DEC,\r\nNULL, 0, "Length of client name", HFILL }},\r\n{ &hf_krb_pac_clientname, {\r\n"Name", "kerberos.pac.name", FT_STRING, BASE_NONE,\r\nNULL, 0, "Name of the Client in the PAC structure", HFILL }},\r\n{ &hf_krb_pac_logon_info, {\r\n"PAC_LOGON_INFO", "kerberos.pac_logon_info", FT_BYTES, BASE_NONE,\r\nNULL, 0, "PAC_LOGON_INFO structure", HFILL }},\r\n{ &hf_krb_pac_credential_type, {\r\n"PAC_CREDENTIAL_TYPE", "kerberos.pac_credential_type", FT_BYTES, BASE_NONE,\r\nNULL, 0, "PAC_CREDENTIAL_TYPE structure", HFILL }},\r\n{ &hf_krb_pac_server_checksum, {\r\n"PAC_SERVER_CHECKSUM", "kerberos.pac_server_checksum", FT_BYTES, BASE_NONE,\r\nNULL, 0, "PAC_SERVER_CHECKSUM structure", HFILL }},\r\n{ &hf_krb_pac_privsvr_checksum, {\r\n"PAC_PRIVSVR_CHECKSUM", "kerberos.pac_privsvr_checksum", FT_BYTES, BASE_NONE,\r\nNULL, 0, "PAC_PRIVSVR_CHECKSUM structure", HFILL }},\r\n{ &hf_krb_pac_client_info_type, {\r\n"PAC_CLIENT_INFO_TYPE", "kerberos.pac_client_info_type", FT_BYTES, BASE_NONE,\r\nNULL, 0, "PAC_CLIENT_INFO_TYPE structure", HFILL }},\r\n{ &hf_krb_pac_s4u_delegation_info, {\r\n"PAC_S4U_DELEGATION_INFO", "kerberos.pac_s4u_delegation_info", FT_BYTES, BASE_NONE,\r\nNULL, 0, "PAC_S4U_DELEGATION_INFO structure", HFILL }},\r\n{ &hf_krb_pac_upn_dns_info, {\r\n"UPN_DNS_INFO", "kerberos.pac_upn_dns_info", FT_BYTES, BASE_NONE,\r\nNULL, 0, "UPN_DNS_INFO structure", HFILL }},\r\n{ &hf_krb_pac_upn_flags, {\r\n"Flags", "kerberos.pac.upn.flags", FT_UINT32, BASE_HEX,\r\nNULL, 0, "UPN flags", HFILL }},\r\n{ &hf_krb_pac_upn_dns_offset, {\r\n"DNS Offset", "kerberos.pac.upn.dns_offset", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_krb_pac_upn_dns_len, {\r\n"DNS Len", "kerberos.pac.upn.dns_len", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_krb_pac_upn_upn_offset, {\r\n"UPN Offset", "kerberos.pac.upn.upn_offset", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_krb_pac_upn_upn_len, {\r\n"UPN Len", "kerberos.pac.upn.upn_len", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_krb_pac_upn_upn_name, {\r\n"UPN Name", "kerberos.pac.upn.upn_name", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_krb_pac_upn_dns_name, {\r\n"DNS Name", "kerberos.pac.upn.dns_name", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n#include "packet-kerberos-hfarr.c"\r\n};\r\nstatic gint *ett[] = {\r\n&ett_kerberos,\r\n&ett_krb_recordmark,\r\n&ett_krb_pac,\r\n&ett_krb_pac_drep,\r\n&ett_krb_pac_midl_blob,\r\n&ett_krb_pac_logon_info,\r\n&ett_krb_pac_s4u_delegation_info,\r\n&ett_krb_pac_upn_dns_info,\r\n&ett_krb_pac_server_checksum,\r\n&ett_krb_pac_privsvr_checksum,\r\n&ett_krb_pac_client_info_type,\r\n#include "packet-kerberos-ettarr.c"\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_kerberos_decrypted_keytype, { "kerberos.decrypted_keytype", PI_SECURITY, PI_CHAT, "Decryted keytype", EXPFILL }},\r\n{ &ei_kerberos_address, { "kerberos.address.unknown", PI_UNDECODED, PI_WARN, "KRB Address: I don't know how to parse this type of address yet", EXPFILL }},\r\n{ &ei_krb_gssapi_dlglen, { "kerberos.gssapi.dlglen.error", PI_MALFORMED, PI_ERROR, "DlgLen is not the same as number of bytes remaining", EXPFILL }},\r\n};\r\nexpert_module_t* expert_krb;\r\nmodule_t *krb_module;\r\nproto_kerberos = proto_register_protocol("Kerberos", "KRB5", "kerberos");\r\nproto_register_field_array(proto_kerberos, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_krb = expert_register_protocol(proto_kerberos);\r\nexpert_register_field_array(expert_krb, ei, array_length(ei));\r\nkrb_module = prefs_register_protocol(proto_kerberos, kerberos_prefs_apply_cb);\r\nprefs_register_bool_preference(krb_module, "desegment",\r\n"Reassemble Kerberos over TCP messages spanning multiple TCP segments",\r\n"Whether the Kerberos dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&krb_desegment);\r\n#ifdef HAVE_KERBEROS\r\nprefs_register_bool_preference(krb_module, "decrypt",\r\n"Try to decrypt Kerberos blobs",\r\n"Whether the dissector should try to decrypt "\r\n"encrypted Kerberos blobs. This requires that the proper "\r\n"keytab file is installed as well.", &krb_decrypt);\r\nprefs_register_filename_preference(krb_module, "file",\r\n"Kerberos keytab file",\r\n"The keytab file containing all the secrets",\r\n&keytab_filename);\r\n#endif\r\n}\r\nstatic int wrap_dissect_gss_kerb(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\nproto_tree *tree, dcerpc_info *di _U_,guint8 *drep _U_)\r\n{\r\ntvbuff_t *auth_tvb;\r\nauth_tvb = tvb_new_subset_remaining(tvb, offset);\r\ndissect_kerberos_main(auth_tvb, pinfo, tree, FALSE, NULL);\r\nreturn tvb_captured_length_remaining(tvb, offset);\r\n}\r\nvoid\r\nproto_reg_handoff_kerberos(void)\r\n{\r\ndissector_handle_t kerberos_handle_tcp;\r\nkrb4_handle = find_dissector_add_dependency("krb4", proto_kerberos);\r\nkerberos_handle_udp = create_dissector_handle(dissect_kerberos_udp,\r\nproto_kerberos);\r\nkerberos_handle_tcp = create_dissector_handle(dissect_kerberos_tcp,\r\nproto_kerberos);\r\ndissector_add_uint("udp.port", UDP_PORT_KERBEROS, kerberos_handle_udp);\r\ndissector_add_uint("tcp.port", TCP_PORT_KERBEROS, kerberos_handle_tcp);\r\nregister_dcerpc_auth_subdissector(DCE_C_AUTHN_LEVEL_CONNECT,\r\nDCE_C_RPC_AUTHN_PROTOCOL_GSS_KERBEROS,\r\n&gss_kerb_auth_connect_fns);\r\nregister_dcerpc_auth_subdissector(DCE_C_AUTHN_LEVEL_PKT_INTEGRITY,\r\nDCE_C_RPC_AUTHN_PROTOCOL_GSS_KERBEROS,\r\n&gss_kerb_auth_sign_fns);\r\nregister_dcerpc_auth_subdissector(DCE_C_AUTHN_LEVEL_PKT_PRIVACY,\r\nDCE_C_RPC_AUTHN_PROTOCOL_GSS_KERBEROS,\r\n&gss_kerb_auth_seal_fns);\r\n}
