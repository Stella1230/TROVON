static void\r\nadwin_request_response_handling(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *adwin_tree, guint32 seq_num, adwin_direction_t direction)\r\n{\r\nconversation_t *conversation;\r\nadwin_conv_info_t *adwin_info;\r\nadwin_transaction_t *adwin_trans;\r\nconversation = find_or_create_conversation(pinfo);\r\nadwin_info = (adwin_conv_info_t *)conversation_get_proto_data(conversation, proto_adwin);\r\nif (!adwin_info) {\r\nadwin_info = wmem_new(wmem_file_scope(), adwin_conv_info_t);\r\nadwin_info->pdus = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\r\nconversation_add_proto_data(conversation, proto_adwin, adwin_info);\r\n}\r\nif (!pinfo->fd->flags.visited) {\r\nif (direction == ADWIN_REQUEST) {\r\nadwin_trans = wmem_new(wmem_file_scope(), adwin_transaction_t);\r\nadwin_trans->req_frame = pinfo->num;\r\nadwin_trans->rep_frame = 0;\r\nadwin_trans->req_time = pinfo->abs_ts;\r\nwmem_map_insert(adwin_info->pdus, GUINT_TO_POINTER(seq_num), (void *)adwin_trans);\r\n} else {\r\nadwin_trans = (adwin_transaction_t *)wmem_map_lookup(adwin_info->pdus, GUINT_TO_POINTER(seq_num));\r\nif (adwin_trans) {\r\nadwin_trans->rep_frame = pinfo->num;\r\n}\r\n}\r\n} else {\r\nadwin_trans = (adwin_transaction_t *)wmem_map_lookup(adwin_info->pdus, GUINT_TO_POINTER(seq_num));\r\n}\r\nif (!adwin_trans) {\r\nadwin_trans = wmem_new(wmem_packet_scope(), adwin_transaction_t);\r\nadwin_trans->req_frame = 0;\r\nadwin_trans->rep_frame = 0;\r\nadwin_trans->req_time = pinfo->abs_ts;\r\n}\r\nif (direction == ADWIN_REQUEST) {\r\nif (adwin_trans->rep_frame) {\r\nproto_item *it;\r\nit = proto_tree_add_uint(adwin_tree, hf_adwin_response_in,\r\ntvb, 0, 0, adwin_trans->rep_frame);\r\nPROTO_ITEM_SET_GENERATED(it);\r\n}\r\n} else {\r\nif (adwin_trans->req_frame) {\r\nproto_item *it;\r\nnstime_t ns;\r\nit = proto_tree_add_uint(adwin_tree, hf_adwin_response_to,\r\ntvb, 0, 0, adwin_trans->req_frame);\r\nPROTO_ITEM_SET_GENERATED(it);\r\nnstime_delta(&ns, &pinfo->abs_ts, &adwin_trans->req_time);\r\nit = proto_tree_add_time(adwin_tree, hf_adwin_response_time, tvb, 0, 0, &ns);\r\nPROTO_ITEM_SET_GENERATED(it);\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_UDPH1_generic(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *adwin_tree, proto_tree *adwin_debug_tree, gchar** info_string, const gchar* packet_name)\r\n{\r\nguint32 i3plus1code = 0, instructionID, seq_num;\r\ninstructionID = tvb_get_letohl(tvb, 0);\r\n*info_string = wmem_strdup_printf(wmem_packet_scope(), "%s: %s", packet_name,\r\nval_to_str_ext(instructionID, &instruction_mapping_ext, "unknown instruction: %d"));\r\nif (instructionID == I_3PLUS1) {\r\ngchar *tmp = *info_string;\r\ni3plus1code = tvb_get_letohl(tvb, 20);\r\n*info_string = wmem_strdup_printf(wmem_packet_scope(), "%s: %s", tmp, val_to_str_ext(i3plus1code, &instruction_3plus1_mapping_ext, "unknown 3+1 code: %d"));\r\n}\r\nseq_num = tvb_get_letohl(tvb, 4);\r\nadwin_request_response_handling(tvb, pinfo, adwin_tree, seq_num, ADWIN_REQUEST);\r\nif (! adwin_tree)\r\nreturn;\r\nSET_PACKET_TYPE(adwin_tree, APT_UDPH1_old);\r\nproto_tree_add_item(adwin_tree, hf_adwin_instruction, tvb, 0, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_packet_index, tvb, 4, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_password, tvb, 8, 10, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 18, 2, ENC_NA);\r\nswitch(instructionID) {\r\ncase I_3PLUS1:\r\nproto_tree_add_item(adwin_tree, hf_adwin_i3plus1, tvb, 20, 4, ENC_LITTLE_ENDIAN);\r\nswitch (i3plus1code) {\r\ncase I_3P1_SET_PAR:\r\nproto_tree_add_item(adwin_tree, hf_adwin_parameter, tvb, 24, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_val1, tvb, 28, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_val1f, tvb, 28, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 32, 4, ENC_NA);\r\nbreak;\r\ncase I_3P1_GET_PAR:\r\nproto_tree_add_item(adwin_tree, hf_adwin_parameter, tvb, 24, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 28, 8, ENC_NA);\r\nbreak;\r\ncase I_3P1_GET_MEMORY_INFO:\r\ncase I_3P1_GET_DETAILED_MEM_INFO:\r\nproto_tree_add_item(adwin_tree, hf_adwin_mem_type, tvb, 24, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 28, 8, ENC_NA);\r\nbreak;\r\ncase I_3P1_START:\r\ncase I_3P1_STOP:\r\ncase I_3P1_CLEAR_PROCESS:\r\nproto_tree_add_item(adwin_tree, hf_adwin_process_no, tvb, 24, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 28, 8, ENC_NA);\r\nbreak;\r\ncase I_3P1_GET_DATA_LENGTH:\r\nproto_tree_add_item(adwin_tree, hf_adwin_data_no32, tvb, 24, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 28, 8, ENC_NA);\r\nbreak;\r\ncase I_3P1_CLEAR_FIFO:\r\ncase I_3P1_GET_FIFO_EMPTY:\r\ncase I_3P1_GET_FIFO_COUNT:\r\nproto_tree_add_item(adwin_tree, hf_adwin_fifo_no32, tvb, 24, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 28, 8, ENC_NA);\r\nbreak;\r\ndefault: ;\r\n}\r\nbreak;\r\ncase I_BOOT:\r\nproto_tree_add_item(adwin_tree, hf_adwin_memsize, tvb, 20, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_blocksize, tvb, 24, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 26, 2, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_processor, tvb, 28, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_binfilesize, tvb, 32, 4, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase I_LOAD_BIN_FILE:\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 20, 6, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_blocksize, tvb, 26, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_processor, tvb, 28, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_binfilesize, tvb, 32, 4, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase I_GET_WORKLOAD:\r\nproto_tree_add_item(adwin_tree, hf_adwin_instruction, tvb, 20, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 24, 12, ENC_NA);\r\nbreak;\r\ncase I_GET_DATA_TYPE:\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 20, 4, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_data_no32, tvb, 24, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_start_index, tvb, 28, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 32, 4, ENC_NA);\r\nbreak;\r\ncase I_GET_DATA:\r\ncase I_SET_DATA:\r\nproto_tree_add_item(adwin_tree, hf_adwin_data_type, tvb, 20, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_data_no16, tvb, 24, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_blocksize, tvb, 26, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_start_index, tvb, 28, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_count, tvb, 32, 4, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase I_GET_DATA_SHIFTED_HANDSHAKE:\r\nproto_tree_add_item(adwin_tree, hf_adwin_data_no16, tvb, 20, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_blocksize, tvb, 22, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_start_index, tvb, 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_count, tvb, 28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 32, 4, ENC_NA);\r\nbreak;\r\ncase I_GET_DATA_SMALL:\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 20, 4, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_data_no16, tvb, 24, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 26, 2, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_start_index, tvb, 28, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_count, tvb, 32, 4, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase I_GET_PAR_ALL:\r\nproto_tree_add_item(adwin_tree, hf_adwin_start_index, tvb, 20, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_count, tvb, 24, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 28, 8, ENC_NA);\r\nbreak;\r\ncase I_SET_DATA_LAST_STATUS:\r\nproto_tree_add_item(adwin_tree, hf_adwin_data_packet_index, tvb, 20, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 24, 12, ENC_NA);\r\nbreak;\r\ncase I_GET_ARM_VERSION:\r\nproto_tree_add_item(adwin_tree, hf_adwin_armVersion, tvb, 20, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 24, 12, ENC_NA);\r\nbreak;\r\ncase I_GET_FIFO:\r\ncase I_SET_FIFO:\r\nproto_tree_add_item(adwin_tree, hf_adwin_data_type, tvb, 20, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_fifo_no16, tvb, 24, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 26, 6, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_count, tvb, 32, 4, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase I_GET_FIFO_RETRY:\r\ncase I_SET_FIFO_RETRY:\r\nproto_tree_add_item(adwin_tree, hf_adwin_data_type, tvb, 20, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_fifo_no16, tvb, 24, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 26, 2, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_retry_packet_index, tvb, 28, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_count, tvb, 32, 4, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase I_TEST_VERSION:\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 20, 16, ENC_NA);\r\nbreak;\r\ncase I_GET_MEMORY:\r\nproto_tree_add_item(adwin_tree, hf_adwin_address, tvb, 20, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_count, tvb, 24, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 28, 8, ENC_NA);\r\nbreak;\r\ndefault: ;\r\n}\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_link_addr, tvb, 36, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_timeout, tvb, 40, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_osys, tvb, 44, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 48, 4, ENC_NA);\r\n}\r\nstatic void\r\ndissect_UDPH1_old(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *adwin_tree, proto_tree *adwin_debug_tree, gchar** info_string)\r\n{\r\ndissect_UDPH1_generic(tvb, pinfo, adwin_tree, adwin_debug_tree, info_string, "UDPH1 (old)");\r\n}\r\nstatic void\r\ndissect_UDPH1_new(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *adwin_tree, proto_tree *adwin_debug_tree,\r\ngchar** info_string)\r\n{\r\ngchar* dll_version_s;\r\ngint32 dll_i;\r\ndissect_UDPH1_generic(tvb, pinfo, adwin_tree, adwin_debug_tree, info_string, "UDPH1 (new)");\r\nif (! adwin_tree)\r\nreturn;\r\nSET_PACKET_TYPE(adwin_tree, APT_UDPH1_new);\r\ndll_i = tvb_get_letohl(tvb, 52);\r\ndll_version_s = wmem_strdup_printf(wmem_packet_scope(), "%d.%d.%d",\r\ndll_i / 1000000,\r\n(dll_i - dll_i / 1000000 * 1000000) / 1000,\r\ndll_i % 1000);\r\nproto_tree_add_string(adwin_debug_tree, hf_adwin_dll_version,\r\ntvb, 52, 4, dll_version_s);\r\n}\r\nstatic void\r\ndissect_UDPR1(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *adwin_tree, proto_tree *adwin_debug_tree,\r\ngchar** info_string)\r\n{\r\nconst gchar *status_string;\r\nguint32 seq_num, status;\r\nstatus = tvb_get_letohl(tvb, 0);\r\nstatus_string = try_val_to_str_ext(status, &error_code_mapping_ext);\r\nif (status_string) {\r\n*info_string = wmem_strdup_printf(wmem_packet_scope(), "UDPR1 Status: %s", status_string);\r\n} else {\r\n*info_string = wmem_strdup_printf(wmem_packet_scope(), "UDPR1 Undefined error code %d", status);\r\n}\r\nseq_num = tvb_get_letohl(tvb, 4);\r\nadwin_request_response_handling(tvb, pinfo, adwin_tree, seq_num, ADWIN_RESPONSE);\r\nif (! adwin_tree)\r\nreturn;\r\nSET_PACKET_TYPE(adwin_tree, APT_UDPR1);\r\nproto_tree_add_item(adwin_tree, hf_adwin_status, tvb, 0, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_packet_index, tvb, 4, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_val1, tvb, 8, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_val1f, tvb, 8, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_val2, tvb, 12, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_val3, tvb, 16, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_val4, tvb, 20, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 24, 8, ENC_NA);\r\n}\r\nstatic void\r\ndissect_UDPR2(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *adwin_tree, proto_tree *adwin_debug_tree,\r\ngchar** info_string)\r\n{\r\nconst gchar *status_string;\r\nguint32 i, status, seq_num;\r\nstatus = tvb_get_letohl(tvb, 0);\r\nstatus_string = try_val_to_str_ext(status, &error_code_mapping_ext);\r\nif (status_string) {\r\n*info_string = wmem_strdup_printf(wmem_packet_scope(), "UDPR2 Status: %s", status_string);\r\n} else {\r\n*info_string = wmem_strdup_printf(wmem_packet_scope(), "UDPR2 Undefined error code %d", status);\r\n}\r\nseq_num = tvb_get_letohl(tvb, 4);\r\nadwin_request_response_handling(tvb, pinfo, adwin_tree, seq_num, ADWIN_RESPONSE);\r\nif (! adwin_tree)\r\nreturn;\r\nSET_PACKET_TYPE(adwin_tree, APT_UDPR2);\r\nproto_tree_add_item(adwin_tree, hf_adwin_status, tvb, 0, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_packet_index, tvb, 4, 4, ENC_LITTLE_ENDIAN);\r\nif (! global_adwin_dissect_data) {\r\ncall_data_dissector(tvb_new_subset_length(tvb, 8, 250*4), pinfo, adwin_debug_tree);\r\nreturn;\r\n}\r\nfor (i = 0; i < 250; i++) {\r\nproto_item *item;\r\nguint32 offset = 8 + i * (int)sizeof(guint32);\r\ngint32 value = tvb_get_letohl(tvb, offset);\r\nvoid * fvalue = &value;\r\nproto_tree_add_none_format(adwin_debug_tree, hf_adwin_data, tvb, offset, 4,\r\n"Data[%3d]: %10d - %10f - 0x%08x",\r\ni, value, *(float*)fvalue, value);\r\nitem = proto_tree_add_item(adwin_debug_tree, hf_adwin_data_int, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(item);\r\nitem = proto_tree_add_item(adwin_debug_tree, hf_adwin_data_float, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(item);\r\nitem = proto_tree_add_item(adwin_debug_tree, hf_adwin_data_hex, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(item);\r\n}\r\n}\r\nstatic void\r\ndissect_UDPR3(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *adwin_tree, proto_tree *adwin_debug_tree)\r\n{\r\nguint32 i, seq_num;\r\nseq_num = tvb_get_letohl(tvb, 0);\r\nadwin_request_response_handling(tvb, pinfo, adwin_tree, seq_num, ADWIN_RESPONSE);\r\nif (! adwin_tree)\r\nreturn;\r\nSET_PACKET_TYPE(adwin_tree, APT_UDPR3);\r\nproto_tree_add_item(adwin_tree, hf_adwin_packet_index, tvb, 0, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_packet_no, tvb, 4, 4, ENC_LITTLE_ENDIAN);\r\nif (! global_adwin_dissect_data) {\r\ncall_data_dissector(tvb_new_subset_length(tvb, 8, 350*4), pinfo, adwin_debug_tree);\r\nreturn;\r\n}\r\nfor (i = 0; i < 350; i++) {\r\nproto_item *item;\r\nguint32 offset = 8 + i * (int)sizeof(guint32);\r\ngint32 value = tvb_get_letohl(tvb, offset);\r\nvoid * fvalue = &value;\r\nproto_tree_add_none_format(adwin_debug_tree, hf_adwin_data, tvb, offset, 4,\r\n"Data[%3d]: %10d - %10f - 0x%08x",\r\ni, value, *(float*)fvalue, value);\r\nitem = proto_tree_add_item(adwin_debug_tree, hf_adwin_data_int, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(item);\r\nitem = proto_tree_add_item(adwin_debug_tree, hf_adwin_data_float, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(item);\r\nitem = proto_tree_add_item(adwin_debug_tree, hf_adwin_data_hex, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(item);\r\n}\r\n}\r\nstatic void\r\ndissect_UDPR4(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *adwin_tree, proto_tree *adwin_debug_tree, gchar** info_string)\r\n{\r\nconst gchar *status_string;\r\nguint32 data_type, i, status, seq_num;\r\nstatus = tvb_get_letohl(tvb, 0);\r\nstatus_string = try_val_to_str_ext(status, &error_code_mapping_ext);\r\nif (status_string) {\r\n*info_string = wmem_strdup_printf(wmem_packet_scope(), "UDPR4 Status: %s", status_string);\r\n} else {\r\n*info_string = wmem_strdup_printf(wmem_packet_scope(), "UDPR4 Undefined error code %d", status);\r\n}\r\nseq_num = tvb_get_letohl(tvb, 4);\r\nadwin_request_response_handling(tvb, pinfo, adwin_tree, seq_num, ADWIN_RESPONSE);\r\nif (! adwin_tree)\r\nreturn;\r\nSET_PACKET_TYPE(adwin_tree, APT_UDPR4);\r\nproto_tree_add_item(adwin_tree, hf_adwin_status, tvb, 0, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_packet_index, tvb, 4, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_packet_no, tvb, 1408, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_data_type, tvb, 1412, 4, ENC_LITTLE_ENDIAN);\r\ndata_type = tvb_get_letohl(tvb, 1412);\r\nif (! global_adwin_dissect_data) {\r\ncall_data_dissector(tvb_new_subset_length(tvb, 8, 350*4), pinfo, adwin_debug_tree);\r\nreturn;\r\n}\r\nfor (i = 0; i < 350; i++) {\r\nproto_item *item;\r\nguint32 offset = 8 + i * (int)sizeof(guint32);\r\ngint32 value = tvb_get_letohl(tvb, offset);\r\nvoid * fvalue = &value;\r\nswitch (data_type) {\r\ncase 2:\r\ncase 3:\r\ncase 4:\r\nproto_tree_add_none_format(adwin_debug_tree, hf_adwin_data, tvb, offset, 4,\r\n"Data[%3d]: %10d - 0x%08x",\r\ni, value, value);\r\nitem = proto_tree_add_item(adwin_debug_tree, hf_adwin_data_int, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(item);\r\nitem = proto_tree_add_item(adwin_debug_tree, hf_adwin_data_hex, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(item);\r\nbreak;\r\ncase 5:\r\nproto_tree_add_none_format(adwin_debug_tree, hf_adwin_data, tvb, offset, 4,\r\n"Data[%3d]: %10f - 0x%08x",\r\ni, *(float*)fvalue, value);\r\nitem = proto_tree_add_item(adwin_debug_tree, hf_adwin_data_float, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(item);\r\nitem = proto_tree_add_item(adwin_debug_tree, hf_adwin_data_hex, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(item);\r\nbreak;\r\ndefault:\r\nproto_tree_add_none_format(adwin_debug_tree, hf_adwin_data, tvb, offset, 4,\r\n"Data[%3d]: 0x%08x",\r\ni, value);\r\nitem = proto_tree_add_item(adwin_debug_tree, hf_adwin_data_hex, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(item);\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_GDSHP(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *adwin_tree, proto_tree *adwin_debug_tree)\r\n{\r\nguint32 i, seq_num;\r\nseq_num = tvb_get_ntohl(tvb, 0);\r\nadwin_request_response_handling(tvb, pinfo, adwin_tree, seq_num, ADWIN_RESPONSE);\r\nif (! adwin_tree)\r\nreturn;\r\nSET_PACKET_TYPE(adwin_tree, APT_GDSHP);\r\nproto_tree_add_item(adwin_tree, hf_adwin_packet_index, tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_packet_no, tvb, 4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_unused, tvb, 8, 4, ENC_NA);\r\nif (! global_adwin_dissect_data) {\r\ncall_data_dissector(tvb_new_subset_length(tvb, 12, 336*4), pinfo, adwin_debug_tree);\r\nreturn;\r\n}\r\nfor (i = 0; i < 336; i++) {\r\nproto_item *item;\r\nguint32 offset = 12 + i * (int)sizeof(guint32);\r\ngint32 value = tvb_get_letohl(tvb, offset);\r\nvoid * fvalue = &value;\r\nproto_tree_add_none_format(adwin_debug_tree, hf_adwin_data, tvb, offset, 4,\r\n"Data[%3d]: %10d - %10f - 0x%08x",\r\ni, value, *(float*)fvalue, value);\r\nitem = proto_tree_add_item(adwin_debug_tree, hf_adwin_data_int, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(item);\r\nitem = proto_tree_add_item(adwin_debug_tree, hf_adwin_data_float, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(item);\r\nitem = proto_tree_add_item(adwin_debug_tree, hf_adwin_data_hex, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(item);\r\n}\r\n}\r\nstatic void\r\ndissect_GDSHR(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *adwin_tree, proto_tree *adwin_debug_tree)\r\n{\r\nguint32 is_range, packet_start, packet_end, seq_num;\r\nproto_item *ti;\r\nseq_num = tvb_get_ntohl(tvb, 0);\r\nadwin_request_response_handling(tvb, pinfo, adwin_tree, seq_num, ADWIN_RESPONSE);\r\nif (! adwin_tree)\r\nreturn;\r\nSET_PACKET_TYPE(adwin_tree, APT_GDSHR);\r\nproto_tree_add_item(adwin_tree, hf_adwin_packet_index, tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_request_no, tvb, 4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_complete_packets, tvb, 8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_is_range, tvb, 12, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_packet_start, tvb, 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_packet_end, tvb, 20, 4, ENC_BIG_ENDIAN);\r\nis_range = tvb_get_ntohl(tvb, 12);\r\npacket_start = tvb_get_ntohl(tvb, 16);\r\nswitch(is_range) {\r\ncase 0:\r\nti = proto_tree_add_uint_format_value(adwin_tree, hf_adwin_gdsh_status, tvb, 12, 4,\r\nis_range, "get single packet no %d", packet_start);\r\nbreak;\r\ncase 1:\r\npacket_end = tvb_get_ntohl(tvb, 20);\r\nti = proto_tree_add_uint_format_value(adwin_tree, hf_adwin_gdsh_status, tvb, 12, 4,\r\nis_range, "get packets %d - %d",\r\npacket_start, packet_end);\r\nbreak;\r\ncase 2:\r\nti = proto_tree_add_uint_format_value(adwin_tree, hf_adwin_gdsh_status, tvb, 12, 4,\r\nis_range, "finished");\r\nbreak;\r\ndefault:\r\nti = proto_tree_add_uint_format_value(adwin_tree, hf_adwin_gdsh_status, tvb, 12, 4,\r\nis_range, "unknown code %d", is_range);\r\n}\r\nproto_item_set_len(ti, 12);\r\nproto_tree_add_item(adwin_debug_tree, hf_adwin_unused, tvb, 24, 40, ENC_NA);\r\n}\r\nstatic int\r\ndissect_adwin(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *ti, *ti2;\r\nproto_tree *adwin_tree, *adwin_debug_tree;\r\ngchar *info_string;\r\nguint32 length;\r\nlength = tvb_reported_length(tvb);\r\nif(! (length == UDPH1_OLD_LENGTH\r\n|| length == UDPH1_NEW_LENGTH\r\n|| length == UDPR1_LENGTH\r\n|| length == UDPH2_LENGTH\r\n|| length == UDPR2_LENGTH\r\n|| length == UDPR3_LENGTH\r\n|| length == UDPR4_LENGTH\r\n|| length == GetDataSHPacket_LENGTH\r\n|| length == GetDataSHRequest_LENGTH))\r\nreturn(0);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ADwin");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_adwin, tvb, 0, -1, ENC_NA);\r\nadwin_tree = proto_item_add_subtree(ti, ett_adwin);\r\nti2 = proto_tree_add_item(adwin_tree, proto_adwin, tvb, 0, -1, ENC_NA);\r\nadwin_debug_tree = proto_item_add_subtree(ti2, ett_adwin_debug);\r\nproto_item_set_text(ti2, "ADwin Debug information");\r\n} else {\r\nadwin_tree = NULL;\r\nadwin_debug_tree = NULL;\r\n}\r\nswitch (length) {\r\ncase UDPH1_OLD_LENGTH:\r\ndissect_UDPH1_old(tvb, pinfo, adwin_tree, adwin_debug_tree, &info_string);\r\nbreak;\r\ncase UDPH1_NEW_LENGTH:\r\ndissect_UDPH1_new(tvb, pinfo, adwin_tree, adwin_debug_tree, &info_string);\r\nbreak;\r\ncase UDPR1_LENGTH:\r\ndissect_UDPR1(tvb, pinfo, adwin_tree, adwin_debug_tree, &info_string);\r\nbreak;\r\ncase UDPH2_LENGTH:\r\ninfo_string = wmem_strdup(wmem_packet_scope(), "UDPH2 - UNUSED");\r\nbreak;\r\ncase UDPR2_LENGTH:\r\ndissect_UDPR2(tvb, pinfo, adwin_tree, adwin_debug_tree, &info_string);\r\nbreak;\r\ncase UDPR3_LENGTH:\r\ndissect_UDPR3(tvb, pinfo, adwin_tree, adwin_debug_tree);\r\ninfo_string = wmem_strdup(wmem_packet_scope(), "UDPR3");\r\nbreak;\r\ncase UDPR4_LENGTH:\r\ndissect_UDPR4(tvb, pinfo, adwin_tree, adwin_debug_tree, &info_string);\r\nbreak;\r\ncase GetDataSHPacket_LENGTH:\r\ndissect_GDSHP(tvb, pinfo, adwin_tree, adwin_debug_tree);\r\ninfo_string = wmem_strdup(wmem_packet_scope(), "GDSHP");\r\nbreak;\r\ncase GetDataSHRequest_LENGTH:\r\ndissect_GDSHR(tvb, pinfo, adwin_tree, adwin_debug_tree);\r\ninfo_string = wmem_strdup(wmem_packet_scope(), "GDSHR");\r\nbreak;\r\ndefault:\r\ninfo_string = wmem_strdup_printf(wmem_packet_scope(), "Unknown ADwin packet, length: %d", length);\r\nbreak;\r\n}\r\ncol_add_str(pinfo->cinfo, COL_INFO, info_string);\r\nreturn (tvb_reported_length(tvb));\r\n}\r\nvoid\r\nproto_reg_handoff_adwin(void)\r\n{\r\nstatic int adwin_prefs_initialized = FALSE;\r\nstatic dissector_handle_t adwin_handle;\r\nstatic unsigned int udp_port;\r\nif (! adwin_prefs_initialized) {\r\nadwin_handle = create_dissector_handle(dissect_adwin, proto_adwin);\r\nadwin_prefs_initialized = TRUE;\r\n} else {\r\ndissector_delete_uint("udp.port", udp_port, adwin_handle);\r\n}\r\nudp_port = global_adwin_udp_port;\r\ndissector_add_uint("udp.port", global_adwin_udp_port, adwin_handle);\r\n}\r\nvoid\r\nproto_register_adwin(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_adwin_address,\r\n{ "memory address", "adwin.address",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"Memory address to read on DSP", HFILL }\r\n},\r\n{ &hf_adwin_armVersion,\r\n{ "Get ARM Version", "adwin.armVersion",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_binfilesize,\r\n{ "File size", "adwin.binfilesize",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Size of binary file", HFILL }\r\n},\r\n{ &hf_adwin_blocksize,\r\n{ "Blocksize", "adwin.blocksize",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Maximum number of unacknowledged packets", HFILL }\r\n},\r\n{ &hf_adwin_complete_packets,\r\n{ "Complete packets", "adwin.complete_packets",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Highest sequential package number", HFILL }\r\n},\r\n{ &hf_adwin_count,\r\n{ "Count", "adwin.count",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Number of longs", HFILL }\r\n},\r\n{ &hf_adwin_data,\r\n{ "Data", "adwin.data",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_data_int,\r\n{ "Data element int", "adwin.data_int",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_data_float,\r\n{ "Data element float", "adwin.data_float",\r\nFT_FLOAT, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_data_hex,\r\n{ "Data element hex", "adwin.data_hex",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_data_no16,\r\n{ "Data No. (16bit)", "adwin.data_no16",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_data_no32,\r\n{ "Data No. (32bit)", "adwin.data_no32",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_data_type,\r\n{ "Data type", "adwin.data_type",\r\nFT_UINT32, BASE_DEC|BASE_EXT_STRING, &data_type_mapping_ext, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_data_packet_index,\r\n{ "Data packet index", "adwin.data_packet_index",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_dll_version,\r\n{ "DLL Version", "adwin.dll_version",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_fifo_no16,\r\n{ "FiFo No. (16bit)", "adwin.fifo_no",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_fifo_no32,\r\n{ "FiFo No. (32bit)", "adwin.fifo_no",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_instruction,\r\n{ "Instruction", "adwin.instruction",\r\nFT_UINT32, BASE_DEC|BASE_EXT_STRING, &instruction_mapping_ext, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_is_range,\r\n{ "packets are a range", "adwin.is_range",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_i3plus1,\r\n{ "3+1 Instruction", "adwin.i3plus1",\r\nFT_UINT32, BASE_DEC|BASE_EXT_STRING, &instruction_3plus1_mapping_ext, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_link_addr,\r\n{ "Link address", "adwin.link_addr",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"Link address (TCP/IP Server only)", HFILL }\r\n},\r\n{ &hf_adwin_mem_type,\r\n{ "Memory type", "adwin.mem_type",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_memsize,\r\n{ "Memory size", "adwin.memsize",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_osys,\r\n{ "Operating system", "adwin.osys",\r\nFT_UINT32, BASE_DEC|BASE_EXT_STRING, &osys_mapping_ext, 0x0,\r\n"Operating system / environment", HFILL }\r\n},\r\n{ &hf_adwin_packet_end,\r\n{ "End packet", "adwin.packet_end",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"GDSH: End Packet", HFILL }\r\n},\r\n{ &hf_adwin_gdsh_status,\r\n{ "GDSH status", "adwin.gdsh_status",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_packet_index,\r\n{ "Packet index", "adwin.packet_index",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_packet_no,\r\n{ "Packet No.", "adwin.packet_no",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_packet_start,\r\n{ "Starting packet", "adwin.packet_start",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"GDSH: Starting Packet", HFILL }\r\n},\r\n{ &hf_adwin_packet_type,\r\n{ "Packet type", "adwin.packet_type",\r\nFT_INT32, BASE_DEC|BASE_EXT_STRING, &packet_type_mapping_ext, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_parameter,\r\n{ "Parameter", "adwin.parameter",\r\nFT_UINT32, BASE_DEC|BASE_EXT_STRING, &parameter_mapping_ext, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_password,\r\n{ "Password", "adwin.password",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Password for ADwin system", HFILL }\r\n},\r\n{ &hf_adwin_process_no,\r\n{ "Process No.", "adwin.process_no",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_processor,\r\n{ "Processor", "adwin.processor",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_response_in,\r\n{ "Response In", "adwin.response_in",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n"The response to this ADwin request is in this frame", HFILL }\r\n},\r\n{ &hf_adwin_response_to,\r\n{ "Request In", "adwin.response_to",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n"This is a response to the ADwin request in this frame", HFILL }\r\n},\r\n{ &hf_adwin_response_time,\r\n{ "Response time", "adwin.response_time",\r\nFT_RELATIVE_TIME, BASE_NONE, NULL, 0x0,\r\n"The time between the Request and the Reply", HFILL }\r\n},\r\n{ &hf_adwin_retry_packet_index,\r\n{ "Retry packet index", "adwin.retry_packet_index",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_request_no,\r\n{ "Request Number", "adwin.request_no",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Request number index", HFILL }\r\n},\r\n{ &hf_adwin_start_index,\r\n{ "Start index", "adwin.start_index",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_status,\r\n{ "Status", "adwin.status",\r\nFT_INT32, BASE_DEC|BASE_EXT_STRING, &error_code_mapping_ext, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_timeout,\r\n{ "Timeout", "adwin.timeout",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Timeout in ms", HFILL }\r\n},\r\n{ &hf_adwin_unused,\r\n{ "Unused", "adwin.unused",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_val1,\r\n{ "Value 1 (as int)", "adwin.val1",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\n"Generic return value 1 interpreted as integer (correct interpretation depends on request).", HFILL }\r\n},\r\n{ &hf_adwin_val1f,\r\n{ "Value 1 (as float)", "adwin.val1f",\r\nFT_FLOAT, BASE_NONE, NULL, 0x0,\r\n"Generic return value 1 interpreted as float (correct interpretation depends on request).", HFILL }\r\n},\r\n{ &hf_adwin_val2,\r\n{ "Value 2", "adwin.val2",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\n"Generic return value 2 (interpretation depends on request).", HFILL }\r\n},\r\n{ &hf_adwin_val3,\r\n{ "Value 3", "adwin.val3",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\n"Generic return value 3 (interpretation depends on request).", HFILL }\r\n},\r\n{ &hf_adwin_val4,\r\n{ "Value 4", "adwin.val4",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\n"Generic return value 4 (interpretation depends on request).", HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_adwin,\r\n&ett_adwin_debug,\r\n};\r\nmodule_t *adwin_module;\r\nproto_adwin = proto_register_protocol("ADwin communication protocol",\r\n"ADwin", "adwin");\r\nproto_register_field_array(proto_adwin, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nadwin_module = prefs_register_protocol(proto_adwin, proto_reg_handoff_adwin);\r\nprefs_register_uint_preference(adwin_module, "udp.port", "ADwin UDP Port",\r\n"Set the UDP port for ADwin packets (if other"\r\n" than the default of 6543)",\r\n10, &global_adwin_udp_port);\r\nprefs_register_bool_preference(adwin_module, "dissect_data",\r\n"Dissect Data sections",\r\n"Specify if the Data sections of packets "\r\n"should be dissected or not",\r\n&global_adwin_dissect_data);\r\n}
