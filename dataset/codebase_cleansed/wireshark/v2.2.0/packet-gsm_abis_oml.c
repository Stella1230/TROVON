static void format_custom_msgtype(gchar *out, guint32 in)\r\n{\r\nconst gchar *tmp = NULL;\r\ngchar *tmp_str;\r\nswitch (global_oml_dialect) {\r\ncase OML_DIALECT_SIEMENS:\r\ntmp = try_val_to_str(in, oml_fom_msgtype_vals_bs11);\r\nbreak;\r\ncase OML_DIALECT_IPA:\r\ntmp = try_val_to_str(in, oml_fom_msgtype_vals_ipa);\r\nbreak;\r\ncase OML_DIALECT_ETSI:\r\ndefault:\r\nbreak;\r\n}\r\nif (tmp)\r\ng_snprintf(out, ITEM_LABEL_LENGTH, "%s", tmp);\r\nelse {\r\ntmp_str = val_to_str_wmem(NULL, in, oml_fom_msgtype_vals, "Unknown 0x%02x");\r\ng_snprintf(out, ITEM_LABEL_LENGTH, "%s", tmp_str);\r\nwmem_free(NULL, tmp_str);\r\n}\r\n}\r\nstatic void format_custom_attr(gchar *out, guint32 in)\r\n{\r\nconst gchar *tmp = NULL;\r\ngchar *tmp_str;\r\nswitch (global_oml_dialect) {\r\ncase OML_DIALECT_SIEMENS:\r\ntmp = try_val_to_str(in, oml_fom_attr_vals_bs11);\r\nbreak;\r\ncase OML_DIALECT_IPA:\r\ntmp = try_val_to_str(in, oml_fom_attr_vals_ipa);\r\nbreak;\r\ncase OML_DIALECT_ETSI:\r\ndefault:\r\nbreak;\r\n}\r\nif (tmp)\r\ng_snprintf(out, ITEM_LABEL_LENGTH, "%s", tmp);\r\nelse {\r\ntmp_str = val_to_str_wmem(NULL, in, oml_fom_attr_vals, "Unknown 0x%02x");\r\ng_snprintf(out, ITEM_LABEL_LENGTH, "%s", tmp_str);\r\nwmem_free(NULL, tmp_str);\r\n}\r\n}\r\nstatic const struct tlv_def *\r\nfind_tlv_tag(guint8 tag)\r\n{\r\nconst struct tlv_def *specific;\r\nswitch (global_oml_dialect) {\r\ncase OML_DIALECT_IPA:\r\nspecific = &nm_att_tlvdef_ipa.def[tag];\r\nbreak;\r\ncase OML_DIALECT_SIEMENS:\r\nspecific = &nm_att_tlvdev_bs11.def[tag];\r\nbreak;\r\ncase OML_DIALECT_ETSI:\r\ndefault:\r\nspecific = NULL;\r\nbreak;\r\n}\r\nif (specific && specific->type != TLV_TYPE_UNKNOWN)\r\nreturn specific;\r\nreturn &nm_att_tlvdef_base.def[tag];\r\n}\r\nstatic gint\r\nipacc_tr_ie_bcch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *att_tree,\r\nint offset)\r\n{\r\nguint16 binfo_type;\r\nbinfo_type = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\nproto_tree_add_item(att_tree, hf_attr_ipa_tr_arfcn,\r\ntvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(att_tree, hf_attr_ipa_tr_f_qual,\r\ntvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(att_tree, hf_attr_ipa_tr_b_rxlev,\r\ntvb, offset++, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(att_tree, hf_attr_ipa_tr_rxqual,\r\ntvb, offset++, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(att_tree, hf_attr_ipa_tr_f_err,\r\ntvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(att_tree, hf_attr_ipa_tr_frame_offs,\r\ntvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(att_tree, hf_attr_ipa_tr_framenr_offs,\r\ntvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(att_tree, hf_attr_ipa_tr_bsic,\r\ntvb, offset++, 1, ENC_LITTLE_ENDIAN);\r\nde_lai(tvb, att_tree, pinfo, offset, 5, NULL, 0);\r\noffset += 5;\r\nproto_tree_add_item(att_tree, hf_attr_ipa_tr_cell_id,\r\ntvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nif (binfo_type & 0x8000) {\r\nproto_tree_add_item(att_tree, hf_attr_ipa_tr_si2,\r\ntvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n}\r\nif (binfo_type & 0x0001) {\r\nproto_tree_add_item(att_tree, hf_attr_ipa_tr_si2bis,\r\ntvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n}\r\nif (binfo_type & 0x0002) {\r\nproto_tree_add_item(att_tree, hf_attr_ipa_tr_si2ter,\r\ntvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n}\r\nif (binfo_type & 0x0004) {\r\nproto_tree_add_item(att_tree, hf_attr_ipa_tr_chan_desc,\r\ntvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n}\r\nreturn offset;\r\n}\r\nstatic gint\r\nipacc_tr_ie_chan_usage(tvbuff_t *tvb, proto_tree *att_tree, int offset)\r\n{\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nguint16 result;\r\nresult = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint(att_tree, hf_attr_ipa_tr_arfcn,\r\ntvb, offset, 2, result);\r\nproto_tree_add_uint(att_tree, hf_attr_ipa_tr_rxlev,\r\ntvb, offset, 2, result);\r\noffset += 2;\r\n}\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_ipacc_test_rep(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb)\r\n{\r\ngint offset = 0;\r\nproto_tree_add_item(tree, hf_attr_ipa_test_res, tvb, offset++,\r\n1, ENC_BIG_ENDIAN);\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nguint8 ie;\r\nguint16 len;\r\nproto_item *ti;\r\nproto_tree *att_tree;\r\nie = tvb_get_guint8(tvb, offset);\r\nlen = tvb_get_ntohs(tvb, offset+1);\r\nti = proto_tree_add_item(tree, hf_oml_ipa_tres_attr_tag, tvb,\r\noffset++, 1, ENC_BIG_ENDIAN);\r\natt_tree = proto_item_add_subtree(ti, ett_oml_fom_att);\r\nproto_tree_add_uint(att_tree, hf_oml_ipa_tres_attr_len, tvb,\r\noffset, 2, len);\r\noffset += 2;\r\nswitch (ie) {\r\ncase NM_IPACC_TR_IE_CHAN_USAGE:\r\noffset = ipacc_tr_ie_chan_usage(tvb,\r\natt_tree, offset);\r\nbreak;\r\ncase NM_IPACC_TR_IE_BCCH_INFO:\r\noffset = ipacc_tr_ie_bcch(tvb, pinfo,\r\natt_tree, offset);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_oml_attrs(tvbuff_t *tvb, int base_offs, packet_info *pinfo,\r\nproto_tree *tree)\r\n{\r\nint offset = base_offs;\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nguint i;\r\nguint8 tag, val8;\r\nguint16 val16;\r\nguint32 val32;\r\nunsigned int len, len_len, hlen;\r\nconst struct tlv_def *tdef;\r\nproto_item *ti;\r\nproto_tree *att_tree;\r\ntvbuff_t *sub_tvb;\r\ntag = tvb_get_guint8(tvb, offset);\r\nti = proto_tree_add_item(tree, hf_oml_fom_attr_tag, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\natt_tree = proto_item_add_subtree(ti, ett_oml_fom_att);\r\ntdef = find_tlv_tag(tag);\r\nswitch (tdef->type) {\r\ncase TLV_TYPE_FIXED:\r\nhlen = 1;\r\nlen_len = 0;\r\nlen = tdef->fixed_len;\r\nbreak;\r\ncase TLV_TYPE_T:\r\nhlen = 1;\r\nlen_len = 0;\r\nlen = 0;\r\nbreak;\r\ncase TLV_TYPE_TV:\r\nhlen = 1;\r\nlen_len = 0;\r\nlen = 1;\r\nbreak;\r\ncase TLV_TYPE_TLV:\r\nhlen = 2;\r\nlen_len = 1;\r\nlen = tvb_get_guint8(tvb, offset+1);\r\nbreak;\r\ncase TLV_TYPE_TL16V:\r\nhlen = 3;\r\nlen_len = 2;\r\nlen = tvb_get_guint8(tvb, offset+1) << 8 |\r\ntvb_get_guint8(tvb, offset+2);\r\nbreak;\r\ncase TLV_TYPE_TLV16:\r\nhlen = 2;\r\nlen_len = 1;\r\nlen = tvb_get_guint8(tvb, offset+1) * 2;\r\nbreak;\r\ncase TLV_TYPE_UNKNOWN:\r\ndefault:\r\nexpert_add_info(pinfo, ti, &ei_unknown_type);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nproto_tree_add_uint(att_tree, hf_oml_fom_attr_len, tvb,\r\noffset+1, len_len, len);\r\noffset += hlen;\r\nsub_tvb = tvb_new_subset_length(tvb, offset, len);\r\nswitch (tag) {\r\ncase NM_ATT_ABIS_CHANNEL:\r\nproto_tree_add_item(att_tree, hf_attr_ach_btsp, tvb,\r\noffset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(att_tree, hf_attr_ach_tslot, tvb,\r\noffset+1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(att_tree, hf_attr_ach_sslot, tvb,\r\noffset+2, 1, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase NM_ATT_ADM_STATE:\r\nproto_tree_add_item(att_tree, hf_attr_adm_state, tvb,\r\noffset, len, ENC_BIG_ENDIAN);\r\nval8 = tvb_get_guint8(tvb, offset);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s ",\r\nval_to_str(val8, oml_adm_state_vals,\r\n"%02x"));\r\nbreak;\r\ncase NM_ATT_ARFCN_LIST:\r\nfor (i = 0; i < len; i += 2) {\r\nval16 = tvb_get_ntohs(tvb, offset + i);\r\nproto_tree_add_uint(att_tree, hf_attr_arfcn,\r\ntvb, offset + i, 2, val16);\r\n}\r\nbreak;\r\ncase NM_ATT_AVAIL_STATUS:\r\nif (len) {\r\nval8 = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(att_tree,\r\nhf_attr_avail_state, tvb,\r\noffset, len, ENC_BIG_ENDIAN);\r\n} else\r\nval8 = 0xff;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s ",\r\nval_to_str(val8, oml_avail_state_vals,\r\n"%02x"));\r\nbreak;\r\ncase NM_ATT_BCCH_ARFCN:\r\nproto_tree_add_item(att_tree, hf_attr_bcch_arfcn, tvb,\r\noffset, len, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase NM_ATT_BSIC:\r\nproto_tree_add_item(att_tree, hf_attr_bsic, tvb,\r\noffset, len, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase NM_ATT_CHAN_COMB:\r\nproto_tree_add_item(att_tree, hf_attr_chan_comb, tvb,\r\noffset, len, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase NM_ATT_EVENT_TYPE:\r\nproto_tree_add_item(att_tree, hf_attr_event_type, tvb,\r\noffset, len, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase NM_ATT_GSM_TIME:\r\nproto_tree_add_item(att_tree, hf_attr_gsm_time, tvb,\r\noffset, len, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase NM_ATT_OPER_STATE:\r\nproto_tree_add_item(att_tree, hf_attr_oper_state, tvb,\r\noffset, len, ENC_BIG_ENDIAN);\r\nval8 = tvb_get_guint8(tvb, offset);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s ",\r\nval_to_str(val8, oml_oper_state_vals,\r\n"%02x"));\r\nbreak;\r\ncase NM_ATT_TEI:\r\nproto_tree_add_item(att_tree, hf_attr_tei, tvb,\r\noffset, len, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase NM_ATT_TSC:\r\nproto_tree_add_item(att_tree, hf_attr_tsc, tvb,\r\noffset, len, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase NM_ATT_SEVERITY:\r\nproto_tree_add_item(att_tree, hf_attr_severity, tvb,\r\noffset, len, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase NM_ATT_TEST_REPORT:\r\ndissect_ipacc_test_rep(att_tree, pinfo, sub_tvb);\r\nbreak;\r\ncase NM_ATT_TEST_NO:\r\nproto_tree_add_item(att_tree, hf_attr_test_no, tvb,\r\noffset, len, ENC_LITTLE_ENDIAN);\r\nval8 = tvb_get_guint8(tvb, offset);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s ",\r\nval_to_str(val8, oml_test_no_vals,\r\n"%02x"));\r\nbreak;\r\ncase NM_ATT_HSN:\r\nproto_tree_add_item(att_tree, hf_attr_hsn, tvb,\r\noffset, len, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase NM_ATT_MAIO:\r\nproto_tree_add_item(att_tree, hf_attr_maio, tvb,\r\noffset, len, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(att_tree, hf_oml_fom_attr_val, tvb,\r\noffset, len, ENC_NA);\r\n}\r\nif (global_oml_dialect == OML_DIALECT_IPA) switch (tag) {\r\ncase NM_ATT_IPACC_DST_IP:\r\nval32 = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_ipv4(att_tree, hf_attr_ipa_rsl_ip, tvb,\r\noffset, len, val32);\r\nbreak;\r\ncase NM_ATT_IPACC_DST_IP_PORT:\r\nval16 = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint(att_tree, hf_attr_ipa_rsl_port, tvb,\r\noffset, len, val16);\r\nbreak;\r\ncase NM_ATT_IPACC_LOCATION:\r\nproto_tree_add_item(att_tree, hf_attr_ipa_location_name,\r\ntvb, offset, len, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase NM_ATT_IPACC_UNIT_ID:\r\nproto_tree_add_item(att_tree, hf_attr_ipa_unit_id,\r\ntvb, offset, len, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase NM_ATT_IPACC_UNIT_NAME:\r\nproto_tree_add_item(att_tree, hf_attr_ipa_unit_name,\r\ntvb, offset, len, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase NM_ATT_IPACC_PRIM_OML_CFG_LIST:\r\nproto_tree_add_item(att_tree, hf_attr_ipa_prim_oml_ip,\r\ntvb, offset+1, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(att_tree, hf_attr_ipa_prim_oml_port,\r\ntvb, offset+1+4, 2, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase NM_ATT_IPACC_NV_FLAGS:\r\n{\r\nguint flags, mask;\r\nflags = tvb_get_guint8(tvb, offset);\r\nmask = tvb_get_guint8(tvb, offset+1);\r\nflags |= tvb_get_guint8(tvb, offset+2) << 8;\r\nmask |= tvb_get_guint8(tvb, offset+3) << 8;\r\nproto_tree_add_uint(att_tree, hf_attr_ipa_nv_flags,\r\ntvb, offset, 3, flags);\r\nproto_tree_add_uint(att_tree, hf_attr_ipa_nv_mask,\r\ntvb, offset+1, 3, mask);\r\n}\r\nbreak;\r\ncase NM_ATT_IPACC_RAC:\r\nproto_tree_add_item(att_tree, hf_attr_ipa_rac,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase NM_ATT_IPACC_NSEI:\r\nval16 = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint(att_tree, hf_attr_ipa_nsei,\r\ntvb, offset, 2, val16);\r\nbreak;\r\ncase NM_ATT_IPACC_NSVCI:\r\nval16 = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint(att_tree, hf_attr_ipa_nsvci,\r\ntvb, offset, 2, val16);\r\nbreak;\r\ncase NM_ATT_IPACC_BVCI:\r\nval16 = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint(att_tree, hf_attr_ipa_bvci,\r\ntvb, offset, 2, val16);\r\nbreak;\r\ncase NM_ATT_IPACC_NS_LINK_CFG:\r\nval16 = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint(att_tree, hf_attr_ipa_nsl_sport,\r\ntvb, offset, 2, val16);\r\nval32 = tvb_get_ipv4(tvb, offset+2);\r\nproto_tree_add_ipv4(att_tree, hf_attr_ipa_nsl_daddr,\r\ntvb, offset+2, 4, val32);\r\nval16 = tvb_get_ntohs(tvb, offset+6);\r\nproto_tree_add_uint(att_tree, hf_attr_ipa_nsl_dport,\r\ntvb, offset+6, 2, val16);\r\nbreak;\r\n}\r\noffset += len;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_oml_fom(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nint offset, proto_item *top_ti)\r\n{\r\nguint8 msg_type, obj_class, bts_nr, trx_nr, ts_nr;\r\nproto_item *ti;\r\nproto_tree *fom_tree;\r\ngchar formatted[ITEM_LABEL_LENGTH];\r\nmsg_type = tvb_get_guint8(tvb, offset);\r\nobj_class = tvb_get_guint8(tvb, offset+1);\r\nbts_nr = tvb_get_guint8(tvb, offset+2);\r\ntrx_nr = tvb_get_guint8(tvb, offset+3);\r\nts_nr = tvb_get_guint8(tvb, offset+4);\r\nformat_custom_msgtype(formatted, msg_type);\r\nproto_item_append_text(top_ti, ", %s(%02x,%02x,%02x) %s ",\r\nval_to_str(obj_class, oml_fom_objclass_vals, "%02x"),\r\nbts_nr, trx_nr, ts_nr, formatted);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s(%02x,%02x,%02x) %s ",\r\nval_to_str(obj_class, oml_fom_objclass_vals, "%02x"),\r\nbts_nr, trx_nr, ts_nr, formatted);\r\nti = proto_tree_add_item(tree, hf_oml_fom_msgtype, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nfom_tree = proto_item_add_subtree(ti, ett_oml_fom);\r\nproto_tree_add_item(fom_tree, hf_oml_fom_objclass, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fom_tree, hf_oml_fom_inst_bts, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fom_tree, hf_oml_fom_inst_trx, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fom_tree, hf_oml_fom_inst_ts, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\noffset = dissect_oml_attrs(tvb, offset, pinfo, fom_tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_oml_manuf(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nint offset, proto_item *top_ti)\r\n{\r\nif (tvb_get_guint8(tvb, offset) != 0x0d ||\r\ntvb_memeql(tvb, offset+1, ipaccess_magic, sizeof(ipaccess_magic)))\r\nreturn offset;\r\noffset += (int)sizeof(ipaccess_magic) + 1;\r\nreturn dissect_oml_fom(tvb, pinfo, tree, offset, top_ti);\r\n}\r\nstatic int\r\ndissect_abis_oml(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *oml_tree;\r\nint offset = 0;\r\nguint8 msg_disc = tvb_get_guint8(tvb, offset);\r\nguint8 len = tvb_get_guint8(tvb, offset+3);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "OML");\r\ntop_tree = tree;\r\nti = proto_tree_add_item(tree, proto_abis_oml, tvb, 0, -1, ENC_NA);\r\noml_tree = proto_item_add_subtree(ti, ett_oml);\r\nproto_tree_add_item(oml_tree, hf_oml_msg_disc, tvb, offset++,\r\n1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(oml_tree, hf_oml_placement, tvb, offset++,\r\n1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(oml_tree, hf_oml_sequence, tvb, offset++,\r\n1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(oml_tree, hf_oml_length, tvb, offset++,\r\n1, ENC_LITTLE_ENDIAN);\r\nif (global_oml_dialect == OML_DIALECT_ERICSSON) {\r\ntvbuff_t *subtvb;\r\nsubtvb = tvb_new_subset_length(tvb, offset, len);\r\nif (sub_om2000)\r\ncall_dissector(sub_om2000, subtvb, pinfo, tree);\r\n} else {\r\nswitch (msg_disc) {\r\ncase ABIS_OM_MDISC_FOM:\r\noffset = dissect_oml_fom(tvb, pinfo, oml_tree,\r\noffset, ti);\r\nbreak;\r\ncase ABIS_OM_MDISC_MANUF:\r\noffset = dissect_oml_manuf(tvb, pinfo, oml_tree,\r\noffset, ti);\r\nbreak;\r\ncase ABIS_OM_MDISC_MMI:\r\ncase ABIS_OM_MDISC_TRAU:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_abis_oml(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_oml_msg_disc,\r\n{ "Message Discriminator", "gsm_abis_oml.msg_dsc",\r\nFT_UINT8, BASE_HEX, VALS(oml_msg_disc_vals), 0,\r\n"GSM 12.21 Message Discriminator", HFILL }\r\n},\r\n{ &hf_oml_placement,\r\n{ "Placement Indicator", "gsm_abis_oml.placement",\r\nFT_UINT8, BASE_HEX, VALS(oml_placement_vals), 0,\r\n"GSM 12.21 Placement Indicator", HFILL }\r\n},\r\n{ &hf_oml_sequence,\r\n{ "Sequence Number", "gsm_abis_oml.sequence",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Sequence Number (if multi-part msg)", HFILL }\r\n},\r\n{ &hf_oml_length,\r\n{ "Length Indicator", "gsm_abis_oml.length",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Total length of payload", HFILL }\r\n},\r\n{ &hf_oml_fom_msgtype,\r\n{ "FOM Message Type", "gsm_abis_oml.fom.msg_type",\r\nFT_UINT8, BASE_CUSTOM, CF_FUNC(format_custom_msgtype), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_oml_fom_objclass,\r\n{ "FOM Object Class", "gsm_abis_oml.fom.obj_class",\r\nFT_UINT8, BASE_HEX, VALS(oml_fom_objclass_vals), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_oml_fom_inst_bts,\r\n{ "FOM Object Instance BTS", "gsm_abis_oml.fom.obj_inst.bts",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_oml_fom_inst_trx,\r\n{ "FOM Object Instance TRX", "gsm_abis_oml.fom.obj_inst.trx",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_oml_fom_inst_ts,\r\n{ "FOM Object Instance TS", "gsm_abis_oml.fom.obj_inst.ts",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_oml_fom_attr_tag,\r\n{ "FOM Attribute ID", "gsm_abis_oml.fom.attr_id",\r\nFT_UINT8, BASE_CUSTOM, CF_FUNC(format_custom_attr), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_oml_fom_attr_len,\r\n{ "FOM Attribute Length", "gsm_abis_oml.fom.attr_len",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_oml_fom_attr_val,\r\n{ "FOM Attribute Value", "gsm_abis_oml.fom.attr_val",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_attr_adm_state,\r\n{ "Administrative State", "gsm_abis_oml.fom.attr.adm_state",\r\nFT_UINT8, BASE_HEX, VALS(oml_adm_state_vals), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_attr_arfcn,\r\n{ "ARFCN", "gsm_abis_oml.fom.attr.arfcn",\r\nFT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_oper_state,\r\n{ "Operational State", "gsm_abis_oml.fom.attr.oper_state",\r\nFT_UINT8, BASE_HEX, VALS(oml_oper_state_vals), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_attr_avail_state,\r\n{ "Availability Status", "gsm_abis_oml.fom.attr.avail_state",\r\nFT_UINT8, BASE_HEX, VALS(oml_avail_state_vals), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_attr_event_type,\r\n{ "Event Type", "gsm_abis_oml.fom.attr.event_type",\r\nFT_UINT8, BASE_HEX, VALS(oml_event_type_vals), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_attr_severity,\r\n{ "Severity", "gsm_abis_oml.fom.attr.severity",\r\nFT_UINT8, BASE_HEX, VALS(oml_severity_vals), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_attr_bcch_arfcn,\r\n{ "BCCH ARFCN", "gsm_abis_oml.fom.attr.bcch_arfcn",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"ARFCN of the BCCH", HFILL }\r\n},\r\n{ &hf_attr_bsic,\r\n{ "BSIC", "gsm_abis_oml.fom.attr.bsic",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\n"Base Station Identity Cdoe", HFILL }\r\n},\r\n{ &hf_attr_test_no,\r\n{ "Test Number", "gsm_abis_oml.fom.attr.test_no",\r\nFT_UINT8, BASE_HEX, VALS(oml_test_no_vals), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_attr_tsc,\r\n{ "TSC", "gsm_abis_oml.fom.attr.tsc",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Training Sequence Code", HFILL }\r\n},\r\n{ &hf_attr_tei,\r\n{ "TEI", "gsm_abis_oml.fom.attr.tei",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_attr_ach_btsp,\r\n{ "BTS E1 Port", "gsm_abis_oml.fom.attr.abis_ch.bts_port",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_attr_ach_tslot,\r\n{ "E1 Timeslot", "gsm_abis_oml.fom.attr.abis_ch.timeslot",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_attr_ach_sslot,\r\n{ "E1 Subslot", "gsm_abis_oml.fom.attr.abis_ch.subslot",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_attr_gsm_time,\r\n{ "GSM Time", "gsm_abis_oml.fom.attr.gsm_time",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_attr_chan_comb,\r\n{ "Channel Combination", "gsm_abis_oml.fom.attr.chan_comb",\r\nFT_UINT8, BASE_HEX, VALS(oml_chan_comb_vals), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_attr_hsn,\r\n{ "HSN", "gsm_abis_oml.fom.attr.hsn",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Hopping Sequence Number", HFILL }\r\n},\r\n{ &hf_attr_maio,\r\n{ "MAIO", "gsm_abis_oml.fom.attr.maio",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Mobile Allocation Index Offset", HFILL }\r\n},\r\n{ &hf_oml_ipa_tres_attr_tag,\r\n{ "IPA Test Result Embedded IE",\r\n"gsm_abis_oml.fom.testrep.ipa_tag",\r\nFT_UINT8, BASE_HEX, VALS(ipacc_testres_ie_vals), 0,\r\n"Information Element embedded into the Test Result "\r\n"of ip.access BTS", HFILL },\r\n},\r\n{ &hf_oml_ipa_tres_attr_len,\r\n{ "IPA Test Result Embedded IE Length",\r\n"gsm_abis_oml.fom.testrep.ipa_len",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Length of ip.access Test Result Embedded IE", HFILL }\r\n},\r\n{ &hf_attr_ipa_test_res,\r\n{ "IPA Test Result", "gsm_abis_oml.fom.testrep.result",\r\nFT_UINT8, BASE_DEC, VALS(ipacc_test_res_vals), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_tr_rxlev,\r\n{ "Rx Level", "gsm_abis_oml.fom.testrep.ipa_rxlev",\r\nFT_UINT16, BASE_DEC, NULL, 0xfc00, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_tr_b_rxlev,\r\n{ "Rx Level", "gsm_abis_oml.fom.testrep.ipa_rxlev_b",\r\nFT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_tr_arfcn,\r\n{ "ARFCN", "gsm_abis_oml.fom.testrep.ipa_arfcn",\r\nFT_UINT16, BASE_DEC, NULL, 0x03ff, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_tr_f_qual,\r\n{ "Frequency Quality", "gsm_abis_oml.fom.testrep.ipa.freq_qual",\r\nFT_UINT8, BASE_DEC, NULL, 0xfc, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_tr_f_err,\r\n{ "Frequency Error", "gsm_abis_oml.fom.testrep.ipa.freq_err",\r\nFT_INT16, BASE_DEC, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_tr_rxqual,\r\n{ "Rx Quality", "gsm_abis_oml.fom.testrep.ipa.rx_qual",\r\nFT_UINT8, BASE_DEC, NULL, 0x7, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_tr_frame_offs,\r\n{ "Frame Offset", "gsm_abis_oml.fom.testrep.ipa.frame_offset",\r\nFT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_tr_framenr_offs,\r\n{ "Frame Number Offset",\r\n"gsm_abis_oml.fom.testrep.ipa.framenr_offset",\r\nFT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_tr_bsic,\r\n{ "BSIC", "gsm_abis_oml.fom.testrep.ipa.bsic",\r\nFT_UINT8, BASE_DEC, NULL, 0x3f,\r\n"Base Station Identity Code", HFILL }\r\n},\r\n{ &hf_attr_ipa_tr_cell_id,\r\n{ "Cell ID", "gsm_abis_oml.fom.testrep.ipa.cell_id",\r\nFT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_rsl_ip,\r\n{ "BSC RSL IP Address", "gsm_abis_oml.fom.attr.ipa.rsl_ip",\r\nFT_IPv4, BASE_NONE, NULL, 0,\r\n"IP Address to which the BTS establishes "\r\n"the RSL link", HFILL }\r\n},\r\n{ &hf_attr_ipa_rsl_port,\r\n{ "BSC RSL TCP Port", "gsm_abis_oml.fom.attr.ipa.rsl_port",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Port number to which the BST establishes "\r\n"the RSL link", HFILL }\r\n},\r\n{ &hf_attr_ipa_prim_oml_ip,\r\n{ "Primary OML IP Address",\r\n"gsm_abis_oml.fom.attr.ipa.prim_oml_ip",\r\nFT_IPv4, BASE_NONE, NULL, 0,\r\n"IP Address of the BSC for the primary OML link",\r\nHFILL }\r\n},\r\n{ &hf_attr_ipa_prim_oml_port,\r\n{ "Primary OML TCP Port",\r\n"gsm_abis_oml.fom.attr.ipa.prim_oml_port",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"TCP Port of the BSC for the primarly OML link",\r\nHFILL }\r\n},\r\n{ &hf_attr_ipa_location_name,\r\n{ "Location Name", "gsm_abis_oml.fom.attr.ipa.loc_name",\r\nFT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_unit_name,\r\n{ "Unit Name", "gsm_abis_oml.fom.attr.ipa.unit_name",\r\nFT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_unit_id,\r\n{ "Unit ID", "gsm_abis_oml.fom.attr.ipa.unit_id",\r\nFT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_nv_flags,\r\n{ "NVRAM Config Flags", "gsm_abis_oml.fom.attr.ipa.nv_flags",\r\nFT_UINT16, BASE_HEX, NULL, 0xffff, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_nv_mask,\r\n{ "NVRAM Config Mask", "gsm_abis_oml.fom.attr.ipa.nv_mask",\r\nFT_UINT16, BASE_HEX, NULL, 0xffff, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_tr_si2,\r\n{ "System Information 2", "gsm_abis_oml.fom.attr.ipa.si2",\r\nFT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_tr_si2bis,\r\n{ "System Information 2bis", "gsm_abis_oml.fom.attr.ipa.si2bis",\r\nFT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_tr_si2ter,\r\n{ "System Information 2ter", "gsm_abis_oml.fom.attr.ipa.si2ter",\r\nFT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_tr_chan_desc,\r\n{ "Cell Channel Description",\r\n"gsm_abis_oml.fom.attr.ipa.chan_desc",\r\nFT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_nsl_sport,\r\n{ "NS Link IP Source Port",\r\n"gsm_abis_oml.fom.attr.ipa.nsl_sport",\r\nFT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_nsl_daddr,\r\n{ "NS Link IP Destination Addr",\r\n"gsm_abis_oml.fom.attr.ipa.nsl_daddr",\r\nFT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_nsl_dport,\r\n{ "NS Link IP Destination Port",\r\n"gsm_abis_oml.fom.attr.ipa.nsl_dport",\r\nFT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_nsei,\r\n{ "NSEI", "gsm_abis_oml.fom.attr.ipa.nsei",\r\nFT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_nsvci,\r\n{ "NSVCI", "gsm_abis_oml.fom.attr.ipa.nsvci",\r\nFT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_bvci,\r\n{ "BVCI", "gsm_abis_oml.fom.attr.ipa.bvci",\r\nFT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_attr_ipa_rac,\r\n{ "RAC", "gsm_abis_oml.fom.attr.ipa.rac",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Routing Area Code", HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_oml,\r\n&ett_oml_fom,\r\n&ett_oml_fom_att,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_unknown_type, { "gsm_abis_oml.expert.unknown_type", PI_PROTOCOL, PI_NOTE, "Unknown TLV type", EXPFILL }},\r\n};\r\nmodule_t *oml_module;\r\nexpert_module_t *expert_module;\r\n#define NM_ATT_TLVDEF_BASE(_attr, _type, _fixed_len) \\r\nnm_att_tlvdef_base.def[_attr].type = _type; \\r\nnm_att_tlvdef_base.def[_attr].fixed_len = _fixed_len; \\r\nNM_ATT_TLVDEF_BASE(NM_ATT_ABIS_CHANNEL, TLV_TYPE_FIXED, 3);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_ADD_INFO, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_ADD_TEXT, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_ADM_STATE, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_ARFCN_LIST, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_AUTON_REPORT, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_AVAIL_STATUS, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_BCCH_ARFCN, TLV_TYPE_FIXED, 2);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_BSIC, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_BTS_AIR_TIMER, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_CCCH_L_I_P, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_CCCH_L_T, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_CHAN_COMB, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_CONN_FAIL_CRIT, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_DEST, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_EVENT_TYPE, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_FILE_ID, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_FILE_VERSION, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_GSM_TIME, TLV_TYPE_FIXED, 2);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_HSN, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_HW_CONFIG, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_HW_DESC, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_INTAVE_PARAM, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_INTERF_BOUND, TLV_TYPE_FIXED, 6);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_LIST_REQ_ATTR, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_MAIO, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_MANUF_STATE, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_MANUF_THRESH, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_MANUF_ID, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_MAX_TA, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_MDROP_LINK, TLV_TYPE_FIXED, 2);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_MDROP_NEXT, TLV_TYPE_FIXED, 2);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_NACK_CAUSES, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_NY1, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_OPER_STATE, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_OVERL_PERIOD, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_PHYS_CONF, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_POWER_CLASS, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_POWER_THRESH, TLV_TYPE_FIXED, 3);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_PROB_CAUSE, TLV_TYPE_FIXED, 3);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_RACH_B_THRESH, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_LDAVG_SLOTS, TLV_TYPE_FIXED, 2);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_RAD_SUBC, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_RF_MAXPOWR_R, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_SITE_INPUTS, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_SITE_OUTPUTS, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_SOURCE, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_SPEC_PROB, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_START_TIME, TLV_TYPE_FIXED, 2);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_T200, TLV_TYPE_FIXED, 7);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_TEI, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_TEST_DUR, TLV_TYPE_FIXED, 2);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_TEST_NO, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_TEST_REPORT, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_VSWR_THRESH, TLV_TYPE_FIXED, 2);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_WINDOW_SIZE, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_TSC, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_SW_CONFIG, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_SW_DESCR, TLV_TYPE_T, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_SEVERITY, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_GET_ARI, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_HW_CONF_CHG, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_OUTST_ALARM, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_FILE_DATA, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_BASE(NM_ATT_MEAS_RES, TLV_TYPE_TL16V, 0);\r\n#define NM_ATT_TLVDEV_BS11(_attr, _type, _fixed_len) \\r\nnm_att_tlvdev_bs11.def[_attr].type = _type; \\r\nnm_att_tlvdev_bs11.def[_attr].fixed_len = _fixed_len; \\r\nNM_ATT_TLVDEV_BS11(NM_ATT_OUTST_ALARM, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_HW_DESC, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_ARFCN_LIST, TLV_TYPE_TLV16, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_ABIS_EXT_TIME, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_OM_LAPD_REL_TIMER, TLV_TYPE_FIXED, 2);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_SH_LAPD_INT_TIMER, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_EMERG_TIMER1, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_EMERG_TIMER2, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_BTSLS_HOPPING, TLV_TYPE_FIXED, 1);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_CELL_ALLOC_NR, TLV_TYPE_FIXED, 1);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_ENA_INTERF_CLASS, TLV_TYPE_FIXED, 1);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_FACCH_QUAL, TLV_TYPE_FIXED, 1);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_TSYNC, TLV_TYPE_FIXED, 2);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_TTRAU, TLV_TYPE_FIXED, 2);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_EXCESSIVE_DISTANCE,TLV_TYPE_TLV, 1);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_HOPPING_MODE, TLV_TYPE_TLV, 1);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_RF_RES_IND_PER, TLV_TYPE_FIXED, 1);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_RADIO_MEAS_GRAN, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_RADIO_MEAS_REP, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_EMRG_CFG_MEMBER, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_TRX_AREA, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_ESN_FW_CODE_NO, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_ESN_HW_CODE_NO, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_ESN_PCB_SERIAL, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_BOOT_SW_VERS, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(0x59, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(0xd5, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(0xa8, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_PASSWORD, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_TXPWR, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_RSSI_OFFS, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_LINE_CFG, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_L1_PROT_TYPE, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_BIT_ERR_THESH, TLV_TYPE_FIXED, 2);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_DIVERSITY, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_LMT_LOGON_SESSION, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_LMT_LOGIN_TIME, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_LMT_USER_ACC_LEV, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_LMT_USER_NAME, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_BTS_STATE, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_E1_STATE, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_PLL_MODE, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_PLL, TLV_TYPE_TLV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_CCLK_ACCURACY, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEV_BS11(NM_ATT_BS11_CCLK_TYPE, TLV_TYPE_TV, 0);\r\n#define NM_ATT_TLVDEF_IPA(_attr, _type, _fixed_len) \\r\nnm_att_tlvdef_ipa.def[_attr].type = _type; \\r\nnm_att_tlvdef_ipa.def[_attr].fixed_len = _fixed_len; \\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_DST_IP, TLV_TYPE_FIXED, 4);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_DST_IP_PORT, TLV_TYPE_FIXED, 2);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_PRIM_OML_CFG, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_NV_FLAGS, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_FREQ_CTRL, TLV_TYPE_FIXED, 2);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_SEC_OML_CFG, TLV_TYPE_FIXED, 6);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_IP_IF_CFG, TLV_TYPE_FIXED, 8);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_IP_GW_CFG, TLV_TYPE_FIXED, 12);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_LOCATION, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_UNIT_ID, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_UNIT_NAME, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_SNMP_CFG, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_ALM_THRESH_LIST, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_CUR_SW_CFG, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_STREAM_ID, TLV_TYPE_TV, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_RAC, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_OBJ_VERSION, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_GPRS_PAGING_CFG, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_NSEI, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_BVCI, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_NSVCI, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_NS_CFG, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_BSSGP_CFG, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_NS_LINK_CFG, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_RLC_CFG, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_SUPP_FEATURES, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_CODING_SCHEMES, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_RLC_CFG_2, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_RLC_CFG_3, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_PAGING_CFG, TLV_TYPE_FIXED, 2);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_FILE_DATA, TLV_TYPE_TL16V, 0);\r\nNM_ATT_TLVDEF_IPA(NM_ATT_IPACC_CGI, TLV_TYPE_TL16V, 0);\r\nproto_abis_oml = proto_register_protocol("GSM A-bis OML", "A-bis OML",\r\n"gsm_abis_oml");\r\nproto_register_field_array(proto_abis_oml, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_module = expert_register_protocol(proto_abis_oml);\r\nexpert_register_field_array(expert_module, ei, array_length(ei));\r\nregister_dissector("gsm_abis_oml", dissect_abis_oml, proto_abis_oml);\r\noml_module = prefs_register_protocol(proto_abis_oml, NULL);\r\nprefs_register_enum_preference(oml_module, "oml_dialect",\r\n"A-bis OML dialect to be used",\r\n"Use ipaccess nanoBTS specific definitions for OML",\r\n&global_oml_dialect, oml_dialect_enumvals, TRUE);\r\n}\r\nvoid\r\nproto_reg_handoff_abis_oml(void)\r\n{\r\ndissector_handle_t abis_oml_handle;\r\nabis_oml_handle = create_dissector_handle(dissect_abis_oml,\r\nproto_abis_oml);\r\ndissector_add_uint("lapd.gsm.sapi", LAPD_GSM_SAPI_OM_PROC,\r\nabis_oml_handle);\r\nsub_om2000 = find_dissector_add_dependency("gsm_abis_om2000", proto_abis_oml);\r\n}
