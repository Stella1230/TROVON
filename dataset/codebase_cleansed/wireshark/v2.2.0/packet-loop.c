static int\r\ndissect_loop(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *loop_tree = NULL;\r\nproto_item *ti;\r\nguint16 function;\r\nint offset = 0;\r\nint skip_offset;\r\ngboolean set_info = TRUE;\r\ngboolean more_function;\r\ntvbuff_t *next_tvb;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "LOOP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_loop, tvb, offset, -1, ENC_NA);\r\nloop_tree = proto_item_add_subtree(ti, ett_loop);\r\nproto_tree_add_item(loop_tree, hf_loop_skipcount, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nskip_offset = 2 + tvb_get_letohs(tvb, offset);\r\noffset += 2;\r\ndo {\r\nfunction = tvb_get_letohs(tvb, offset);\r\nif (offset == skip_offset) {\r\ncol_add_str(pinfo->cinfo, COL_INFO,\r\nval_to_str(function, function_vals, "Unknown function (%u)"));\r\nproto_tree_add_uint(loop_tree, hf_loop_relevant_function, tvb, offset, 2, function);\r\nset_info = FALSE;\r\n}\r\nproto_tree_add_uint(loop_tree, hf_loop_function, tvb, offset, 2, function);\r\noffset += 2;\r\nswitch (function) {\r\ncase FUNC_REPLY:\r\nproto_tree_add_item(loop_tree, hf_loop_receipt_number, tvb, offset, 2,\r\nENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nmore_function = FALSE;\r\nbreak;\r\ncase FUNC_FORWARD_DATA:\r\nproto_tree_add_item(loop_tree, hf_loop_forwarding_address, tvb, offset,\r\n6, ENC_NA);\r\noffset += 6;\r\nmore_function = TRUE;\r\nbreak;\r\ndefault:\r\nmore_function = FALSE;\r\nbreak;\r\n}\r\n} while (more_function);\r\nif (set_info) {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "No valid function found");\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) > 0)\r\n{\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_loop(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_loop_skipcount,\r\n{ "skipCount", "loop.skipcount",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_loop_function,\r\n{ "Function", "loop.function",\r\nFT_UINT16, BASE_DEC, VALS(function_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_loop_relevant_function,\r\n{ "Relevant function", "loop.relevant_function",\r\nFT_UINT16, BASE_DEC, VALS(function_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_loop_receipt_number,\r\n{ "Receipt number", "loop.receipt_number",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_loop_forwarding_address,\r\n{ "Forwarding address", "loop.forwarding_address",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_loop,\r\n};\r\nproto_loop = proto_register_protocol("Configuration Test Protocol (loopback)",\r\n"LOOP", "loop");\r\nproto_register_field_array(proto_loop, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_loop(void)\r\n{\r\ndissector_handle_t loop_handle;\r\nloop_handle = create_dissector_handle(dissect_loop, proto_loop);\r\ndissector_add_uint("ethertype", ETHERTYPE_LOOP, loop_handle);\r\n}
