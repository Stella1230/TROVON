static int\r\ndissect_hsr_frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *hsr_tree;\r\ntvbuff_t *next_tvb;\r\nguint16 etype;\r\nguint16 lsdu_size, lsdu_size_correct;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "HSR");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "HSR-Data Frame");\r\nti = proto_tree_add_item(tree, proto_hsr, tvb, 0, HSR_TOTAL_LENGTH, ENC_NA);\r\nhsr_tree = proto_item_add_subtree(ti, ett_hsr_frame);\r\nproto_tree_add_item(hsr_tree, hf_hsr_path,\r\ntvb, HSR_PATH_OFFSET, HSR_LSDU_PATH_LENGTH , ENC_BIG_ENDIAN);\r\nproto_tree_add_item(hsr_tree, hf_hsr_netid,\r\ntvb, HSR_PATH_OFFSET, HSR_LSDU_PATH_LENGTH , ENC_BIG_ENDIAN);\r\nproto_tree_add_item(hsr_tree, hf_hsr_laneid,\r\ntvb, HSR_PATH_OFFSET, HSR_LSDU_PATH_LENGTH , ENC_BIG_ENDIAN);\r\nlsdu_size = tvb_get_ntohs(tvb, HSR_PATH_OFFSET) & 0x0fff;\r\nlsdu_size_correct = tvb_reported_length_remaining(tvb, 0);\r\nif (lsdu_size == lsdu_size_correct) {\r\nproto_tree_add_uint_format_value(hsr_tree, hf_hsr_lsdu_size,\r\ntvb, HSR_PATH_OFFSET, HSR_LSDU_PATH_LENGTH, lsdu_size,\r\n"%d [correct]", lsdu_size);\r\n} else {\r\nproto_tree_add_uint_format_value(hsr_tree, hf_hsr_lsdu_size,\r\ntvb, HSR_PATH_OFFSET, HSR_LSDU_PATH_LENGTH, lsdu_size,\r\n"%d [WRONG, should be %d]", lsdu_size, lsdu_size_correct);\r\n}\r\nproto_tree_add_item(hsr_tree, hf_hsr_sequence_nr,\r\ntvb, HSR_SEQUENZNR_OFFSET,HSR_SEQUENZNR_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(hsr_tree, hf_type,\r\ntvb, HSR_TOTAL_LENGTH,2, ENC_BIG_ENDIAN);\r\nnext_tvb = tvb_new_subset_remaining(tvb, HSR_TOTAL_LENGTH + 2);\r\netype = tvb_get_ntohs(tvb, HSR_TOTAL_LENGTH);\r\nif (!dissector_try_uint(ethertype_subdissector_table, etype, next_tvb, pinfo, tree))\r\ncall_data_dissector(next_tvb, pinfo, hsr_tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_hsr(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_hsr_path,\r\n{ "Path", "hsr.path",\r\nFT_UINT16, BASE_DEC, NULL, 0xf000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hsr_netid,\r\n{ "Network id", "hsr.netid",\r\nFT_UINT16, BASE_DEC, NULL, 0xe000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hsr_laneid,\r\n{ "Lane id", "hsr.laneid",\r\nFT_UINT16, BASE_DEC, VALS(hsr_laneid_vals), 0x1000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hsr_lsdu_size,\r\n{ "LSDU size", "hsr.lsdu_size",\r\nFT_UINT16, BASE_DEC, NULL, 0x0fff,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hsr_sequence_nr,\r\n{ "Sequence number", "hsr.sequence_nr",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_type,\r\n{ "Type", "hsr.type",\r\nFT_UINT16, BASE_HEX, VALS(etype_vals), 0x00,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_hsr_frame,\r\n};\r\nproto_hsr = proto_register_protocol("High-availability Seamless Redundancy (IEC62439 Part 3 Chapter 5)",\r\n"HSR", "hsr");\r\nproto_register_field_array(proto_hsr, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid proto_reg_handoff_hsr(void)\r\n{\r\ndissector_handle_t hsr_frame_handle;\r\nhsr_frame_handle = create_dissector_handle(dissect_hsr_frame, proto_hsr);\r\ndissector_add_uint("ethertype", ETHERTYPE_HSR, hsr_frame_handle);\r\nethertype_subdissector_table = find_dissector_table("ethertype");\r\n}
