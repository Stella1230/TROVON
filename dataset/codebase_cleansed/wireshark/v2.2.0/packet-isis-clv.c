void\r\nisis_dissect_area_address_clv(proto_tree *tree, packet_info* pinfo, tvbuff_t *tvb,\r\nexpert_field* expert, int hf_area, int offset, int length)\r\n{\r\nint arealen,area_idx;\r\nwhile ( length > 0 ) {\r\narealen = tvb_get_guint8(tvb, offset);\r\nlength--;\r\nif (length<=0) {\r\nproto_tree_add_expert_format(tree, pinfo, expert, tvb, offset, -1,\r\n"short address (no length for payload)");\r\nreturn;\r\n}\r\nif ( arealen > length) {\r\nproto_tree_add_expert_format(tree, pinfo, expert, tvb, offset, -1,\r\n"short address, packet says %d, we have %d left",\r\narealen, length );\r\nreturn;\r\n}\r\nif ( tree ) {\r\nproto_item *ti;\r\nti = proto_tree_add_bytes_format( tree, hf_area, tvb, offset, arealen + 1,\r\nNULL, "Area address (%d): ", arealen );\r\nfor (area_idx = 0; area_idx < arealen; area_idx++) {\r\nproto_item_append_text(ti, "%02x",\r\ntvb_get_guint8(tvb, offset+area_idx+1));\r\nif (((area_idx & 1) == 0) &&\r\n(area_idx + 1 < arealen)) {\r\nproto_item_append_text(ti, ".");\r\n}\r\n}\r\n}\r\noffset += arealen + 1;\r\nlength -= arealen;\r\n}\r\n}\r\nvoid\r\nisis_dissect_instance_identifier_clv(proto_tree *tree, packet_info* pinfo, tvbuff_t *tvb,\r\nexpert_field* expert, int hf_iid, int hf_supported_itid, int offset, int length)\r\n{\r\nlength--;\r\nif (length<=0) {\r\nproto_tree_add_expert_format(tree, pinfo, expert, tvb, offset, -1,\r\n"short address (no length for payload)");\r\nreturn;\r\n}\r\nproto_tree_add_item(tree, hf_iid, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nlength -= 2;\r\nwhile ( length > 0 ) {\r\nproto_tree_add_item(tree, hf_supported_itid, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nlength -= 2;\r\n}\r\n}\r\nvoid\r\nisis_dissect_authentication_clv(proto_tree *tree, packet_info* pinfo, tvbuff_t *tvb,\r\nint hf_auth_bytes, expert_field* auth_expert, int offset, int length)\r\n{\r\nguchar pw_type;\r\nint auth_unsupported;\r\nif ( length <= 0 ) {\r\nreturn;\r\n}\r\npw_type = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\nlength--;\r\nauth_unsupported = FALSE;\r\nswitch (pw_type) {\r\ncase 1:\r\nif ( length > 0 ) {\r\nproto_tree_add_bytes_format( tree, hf_auth_bytes, tvb, offset, length,\r\nNULL, "clear text (1), password (length %d) = %s", length, tvb_format_text(tvb, offset, length));\r\n} else {\r\nproto_tree_add_bytes_format( tree, hf_auth_bytes, tvb, offset, length,\r\nNULL, "clear text (1), no clear-text password found!!!");\r\n}\r\nbreak;\r\ncase 54:\r\nif ( length == 16 ) {\r\nproto_tree_add_bytes_format( tree, hf_auth_bytes, tvb, offset, length,\r\nNULL, "hmac-md5 (54), password (length %d) = %s", length, tvb_bytes_to_str(wmem_packet_scope(), tvb, offset, length));\r\n} else {\r\nproto_tree_add_bytes_format( tree, hf_auth_bytes, tvb, offset, length,\r\nNULL, "hmac-md5 (54), illegal hmac-md5 digest format (must be 16 bytes)");\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_bytes_format( tree, hf_auth_bytes, tvb, offset, length,\r\nNULL, "type 0x%02x (0x%02x)", pw_type, length);\r\nauth_unsupported=TRUE;\r\nbreak;\r\n}\r\nif ( auth_unsupported ) {\r\nproto_tree_add_expert(tree, pinfo, auth_expert, tvb, offset, -1);\r\n}\r\n}\r\nvoid\r\nisis_dissect_hostname_clv(tvbuff_t *tvb, proto_tree *tree, int offset,\r\nint length, int tree_id)\r\n{\r\nproto_item* ti = proto_tree_add_item( tree, tree_id, tvb, offset, length, ENC_ASCII|ENC_NA);\r\nif ( length == 0 ) {\r\nproto_item_append_text(ti, "--none--" );\r\n}\r\n}\r\nvoid\r\nisis_dissect_mt_clv(tvbuff_t *tvb, packet_info* pinfo, proto_tree *tree, int offset, int length,\r\nint tree_id, expert_field* mtid_expert)\r\n{\r\nguint16 mt_block;\r\nconst char *mt_desc;\r\nwhile (length>0) {\r\nif (length!=1) {\r\nmt_block=tvb_get_ntohs(tvb, offset);\r\nswitch(mt_block&0x0fff) {\r\ncase 0:\r\nmt_desc="IPv4 unicast";\r\nbreak;\r\ncase 1:\r\nmt_desc="In-Band Management";\r\nbreak;\r\ncase 2:\r\nmt_desc="IPv6 unicast";\r\nbreak;\r\ncase 3:\r\nmt_desc="Multicast";\r\nbreak;\r\ncase 4095:\r\nmt_desc="Development, Experimental or Proprietary";\r\nbreak;\r\ndefault:\r\nmt_desc="Reserved for IETF Consensus";\r\nbreak;\r\n}\r\nproto_tree_add_uint_format ( tree, tree_id, tvb, offset, 2,\r\nmt_block,\r\n"%s Topology (0x%03x), %ssubTLVs present%s",\r\nmt_desc,\r\nmt_block&0xfff,\r\n(mt_block&0x8000) ? "" : "no ",\r\n(mt_block&0x4000) ? ", ATT bit set" : "" );\r\n} else {\r\nproto_tree_add_expert( tree, pinfo, mtid_expert, tvb, offset, 1);\r\nbreak;\r\n}\r\nlength -= 2;\r\noffset += 2;\r\n}\r\n}\r\nvoid\r\nisis_dissect_ip_int_clv(proto_tree *tree, packet_info* pinfo, tvbuff_t *tvb, expert_field* expert,\r\nint offset, int length, int tree_id)\r\n{\r\nif ( length <= 0 ) {\r\nreturn;\r\n}\r\nwhile ( length > 0 ) {\r\nif ( length < 4 ) {\r\nproto_tree_add_expert_format(tree, pinfo, expert, tvb, offset, -1,\r\n"Short IP interface address (%d vs 4)",length );\r\nreturn;\r\n}\r\nif ( tree ) {\r\nproto_tree_add_item(tree, tree_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\noffset += 4;\r\nlength -= 4;\r\n}\r\n}\r\nvoid\r\nisis_dissect_ipv6_int_clv(proto_tree *tree, packet_info* pinfo, tvbuff_t *tvb, expert_field* expert,\r\nint offset, int length, int tree_id)\r\n{\r\nstruct e_in6_addr addr;\r\nif ( length <= 0 ) {\r\nreturn;\r\n}\r\nwhile ( length > 0 ) {\r\nif ( length < 16 ) {\r\nproto_tree_add_expert_format(tree, pinfo, expert, tvb, offset, -1,\r\n"Short IPv6 interface address (%d vs 16)",length );\r\nreturn;\r\n}\r\ntvb_get_ipv6(tvb, offset, &addr);\r\nif ( tree ) {\r\nproto_tree_add_ipv6(tree, tree_id, tvb, offset, 16, &addr);\r\n}\r\noffset += 16;\r\nlength -= 16;\r\n}\r\n}\r\nvoid\r\nisis_dissect_te_router_id_clv(proto_tree *tree, packet_info* pinfo, tvbuff_t *tvb, expert_field* expert,\r\nint offset, int length, int tree_id)\r\n{\r\nif ( length <= 0 ) {\r\nreturn;\r\n}\r\nif ( length != 4 ) {\r\nproto_tree_add_expert_format(tree, pinfo, expert, tvb, offset, -1,\r\n"malformed Traffic Engineering Router ID (%d vs 4)",length );\r\nreturn;\r\n}\r\nproto_tree_add_item(tree, tree_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\nvoid\r\nisis_dissect_nlpid_clv(tvbuff_t *tvb, proto_tree *tree, int hf_nlpid, int offset, int length)\r\n{\r\ngboolean first;\r\nproto_item *ti;\r\nif ( !tree ) return;\r\nif (length <= 0) {\r\nproto_tree_add_item(tree, hf_nlpid, tvb, offset, length, ENC_NA);\r\n} else {\r\nfirst = TRUE;\r\nti = proto_tree_add_bytes_format(tree, hf_nlpid, tvb, offset, length, NULL, "NLPID(s): ");\r\nwhile (length-- > 0 ) {\r\nif (!first) {\r\nproto_item_append_text(ti, ", ");\r\n}\r\nproto_item_append_text(ti, "%s (0x%02x)",\r\n(tvb_get_guint8(tvb, offset) == NLPID_IEEE_8021AQ\r\n? "IEEE 802.1aq (SPB)"\r\n: val_to_str_const(tvb_get_guint8(tvb, offset), nlpid_vals, "Unknown")),\r\ntvb_get_guint8(tvb, offset));\r\noffset++;\r\nfirst = FALSE;\r\n}\r\n}\r\n}\r\nvoid\r\nisis_dissect_clvs(tvbuff_t *tvb, packet_info* pinfo, proto_tree *tree, int offset,\r\nconst isis_clv_handle_t *opts, expert_field* expert_short_len, int len, int id_length,\r\nint unknown_tree_id _U_, int tree_type, int tree_length, expert_field ei_unknown)\r\n{\r\nguint8 code;\r\nguint8 length;\r\nint q;\r\nproto_tree *clv_tree;\r\nwhile ( len > 0 ) {\r\ncode = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\nlen -= 1;\r\nif (len == 0)\r\nbreak;\r\nlength = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\nlen -= 1;\r\nif (len == 0)\r\nbreak;\r\nif ( len < length ) {\r\nproto_tree_add_expert_format(tree, pinfo, expert_short_len, tvb, offset, -1,\r\n"Short CLV header (%d vs %d)",\r\nlength, len );\r\nreturn;\r\n}\r\nq = 0;\r\nwhile ((opts[q].dissect != NULL )&&( opts[q].optcode != code )){\r\nq++;\r\n}\r\nif ( opts[q].dissect ) {\r\nclv_tree = proto_tree_add_subtree_format(tree, tvb, offset - 2,\r\nlength + 2, *opts[q].tree_id, NULL, "%s (t=%u, l=%u)",\r\nopts[q].tree_text, opts[q].optcode, length);\r\nproto_tree_add_item(clv_tree, tree_type, tvb, offset - 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(clv_tree, tree_length, tvb, offset - 1, 1, ENC_BIG_ENDIAN);\r\nopts[q].dissect(tvb, pinfo, clv_tree, offset,\r\nid_length, length);\r\n} else {\r\nclv_tree = proto_tree_add_subtree_format(tree, tvb, offset - 2,\r\nlength + 2, unknown_tree_id, NULL, "Unknown code (t=%u, l=%u)",\r\ncode, length);\r\nproto_tree_add_item(clv_tree, tree_type, tvb, offset - 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(clv_tree, tree_length, tvb, offset - 1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_expert_format(clv_tree, pinfo, &ei_unknown, tvb, offset, length -2, "Dissector for IS-IS CLV (%d)"\r\n" code not implemented, Contact Wireshark developers if you want this supported", code);\r\n}\r\noffset += length;\r\nlen -= length;\r\n}\r\n}
