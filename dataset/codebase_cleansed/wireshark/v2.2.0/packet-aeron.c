static int aeron_pos_roundup(int offset)\r\n{\r\nreturn ((offset+7) & 0xfffffff8);\r\n}\r\nstatic int aeron_pos_compare(const aeron_pos_t * pos1, const aeron_pos_t * pos2)\r\n{\r\nif (pos1->term_id == pos2->term_id)\r\n{\r\nif (pos1->term_offset == pos2->term_offset)\r\n{\r\nreturn (0);\r\n}\r\nelse\r\n{\r\nreturn ((pos1->term_offset < pos2->term_offset) ? -1 : 1);\r\n}\r\n}\r\nelse\r\n{\r\nreturn ((pos1->term_id < pos2->term_id) ? -1 : 1);\r\n}\r\n}\r\nstatic guint32 aeron_pos_delta(const aeron_pos_t * pos1, const aeron_pos_t * pos2, guint32 term_size)\r\n{\r\nconst aeron_pos_t * p1;\r\nconst aeron_pos_t * p2;\r\nguint64 p1_val;\r\nguint64 p2_val;\r\nguint64 delta;\r\nint rc;\r\nrc = aeron_pos_compare(pos1, pos2);\r\nif (rc >= 0)\r\n{\r\np1 = pos1;\r\np2 = pos2;\r\n}\r\nelse\r\n{\r\np1 = pos2;\r\np2 = pos1;\r\n}\r\np1_val = ((guint64) p1->term_id * term_size) + ((guint64) p1->term_offset);\r\np2_val = ((guint64) p2->term_id * term_size) + ((guint64) p2->term_offset);\r\ndelta = p1_val - p2_val;\r\nreturn ((guint32) (delta & G_GUINT64_CONSTANT(0x00000000ffffffff)));\r\n}\r\nstatic gboolean aeron_pos_add_length(aeron_pos_t * pos, guint32 length, guint32 term_length)\r\n{\r\nguint32 next_term_offset;\r\nguint32 rounded_next_term_offset;\r\nnext_term_offset = pos->term_offset + length;\r\nif (next_term_offset < pos->term_offset)\r\nreturn FALSE;\r\nrounded_next_term_offset = aeron_pos_roundup(next_term_offset);\r\nif (rounded_next_term_offset < next_term_offset)\r\nreturn FALSE;\r\nnext_term_offset = rounded_next_term_offset;\r\nif (next_term_offset >= term_length)\r\n{\r\npos->term_offset = 0;\r\npos->term_id++;\r\n}\r\nelse\r\n{\r\npos->term_offset = next_term_offset;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic wmem_tree_key_t * aeron_frame_info_key_build(guint32 frame, guint32 ofs)\r\n{\r\nwmem_tree_key_t * fkey;\r\nguint32 * key;\r\nfkey = wmem_alloc_array(wmem_packet_scope(), wmem_tree_key_t, 2);\r\nkey = wmem_alloc_array(wmem_packet_scope(), guint32, 2);\r\nkey[0] = frame;\r\nkey[1] = ofs;\r\nfkey[0].length = 2;\r\nfkey[0].key = key;\r\nfkey[1].length = 0;\r\nfkey[1].key = NULL;\r\nreturn (fkey);\r\n}\r\nstatic aeron_frame_info_t * aeron_frame_info_lookup(wmem_tree_key_t * key)\r\n{\r\naeron_frame_info_t * fi;\r\nfi = (aeron_frame_info_t *) wmem_tree_lookup32_array(aeron_frame_info_tree, key);\r\nreturn (fi);\r\n}\r\nstatic aeron_frame_info_t * aeron_frame_info_find(guint32 frame, guint32 ofs)\r\n{\r\nwmem_tree_key_t * key = aeron_frame_info_key_build(frame, ofs);\r\nreturn (aeron_frame_info_lookup(key));\r\n}\r\nstatic aeron_frame_info_t * aeron_frame_info_add(guint32 frame, guint32 ofs)\r\n{\r\naeron_frame_info_t * fi;\r\nwmem_tree_key_t * key = aeron_frame_info_key_build(frame, ofs);\r\nfi = aeron_frame_info_lookup(key);\r\nif (fi == NULL)\r\n{\r\nfi = wmem_new0(wmem_file_scope(), aeron_frame_info_t);\r\nfi->frame = frame;\r\nfi->ofs = ofs;\r\nif (aeron_sequence_analysis && aeron_stream_analysis)\r\n{\r\nfi->rx = wmem_list_new(wmem_file_scope());\r\n}\r\nwmem_tree_insert32_array(aeron_frame_info_tree, key, (void *) fi);\r\n}\r\nreturn (fi);\r\n}\r\nstatic guint64 aeron_channel_id_assign(void)\r\n{\r\nreturn (aeron_channel_id++);\r\n}\r\nstatic void aeron_channel_id_init(void)\r\n{\r\naeron_channel_id = 1;\r\n}\r\nstatic guint aeron_guint32_hash_func(gconstpointer key)\r\n{\r\nguint32 value = *((const guint32 *) key);\r\nreturn ((guint) value);\r\n}\r\nstatic gboolean aeron_guint32_compare_func(gconstpointer lhs, gconstpointer rhs)\r\n{\r\nguint32 key1 = *((const guint32 *) lhs);\r\nguint32 key2 = *((const guint32 *) rhs);\r\nreturn ((key1 == key2) ? TRUE : FALSE);\r\n}\r\nstatic aeron_transport_t * aeron_transport_add(const aeron_conversation_info_t * cinfo, guint32 session_id, guint32 frame)\r\n{\r\naeron_transport_t * transport;\r\nconversation_t * conv;\r\nwmem_map_t * session_map;\r\nconv = find_conversation(frame, cinfo->addr1, cinfo->addr2, cinfo->ptype, cinfo->port1, cinfo->port2, 0);\r\nif (conv == NULL)\r\n{\r\nconv = conversation_new(frame, cinfo->addr1, cinfo->addr2, cinfo->ptype, cinfo->port1, cinfo->port2, 0);\r\n}\r\nif (frame > conv->last_frame)\r\n{\r\nconv->last_frame = frame;\r\n}\r\nsession_map = (wmem_map_t *) conversation_get_proto_data(conv, proto_aeron);\r\nif (session_map == NULL)\r\n{\r\nsession_map = wmem_map_new(wmem_file_scope(), aeron_guint32_hash_func, aeron_guint32_compare_func);\r\nconversation_add_proto_data(conv, proto_aeron, (void *) session_map);\r\n}\r\ntransport = (aeron_transport_t *) wmem_map_lookup(session_map, (const void *) &session_id);\r\nif (transport != NULL)\r\n{\r\nreturn (transport);\r\n}\r\ntransport = wmem_new0(wmem_file_scope(), aeron_transport_t);\r\ntransport->channel_id = aeron_channel_id_assign();\r\ntransport->stream = wmem_map_new(wmem_file_scope(), aeron_guint32_hash_func, aeron_guint32_compare_func);\r\ntransport->last_frame = NULL;\r\ncopy_address_wmem(wmem_file_scope(), &(transport->addr1), cinfo->addr1);\r\ncopy_address_wmem(wmem_file_scope(), &(transport->addr2), cinfo->addr2);\r\ntransport->session_id = session_id;\r\ntransport->port1 = cinfo->port1;\r\ntransport->port2 = cinfo->port2;\r\nwmem_map_insert(session_map, (const void *) &(transport->session_id), (void *) transport);\r\nreturn (transport);\r\n}\r\nstatic aeron_stream_t * aeron_transport_stream_find(aeron_transport_t * transport, guint32 stream_id)\r\n{\r\naeron_stream_t * stream;\r\nstream = (aeron_stream_t *) wmem_map_lookup(transport->stream, (const void *) &stream_id);\r\nreturn (stream);\r\n}\r\nstatic aeron_stream_t * aeron_transport_stream_add(aeron_transport_t * transport, guint32 stream_id)\r\n{\r\naeron_stream_t * stream;\r\nstream = aeron_transport_stream_find(transport, stream_id);\r\nif (stream == NULL)\r\n{\r\nstream = wmem_new0(wmem_file_scope(), aeron_stream_t);\r\nstream->transport = transport;\r\nstream->term = wmem_map_new(wmem_file_scope(), aeron_guint32_hash_func, aeron_guint32_compare_func);\r\nstream->rcv = wmem_list_new(wmem_file_scope());\r\nstream->rcv_count = 0;\r\nstream->last_frame = NULL;\r\nstream->stream_id = stream_id;\r\nstream->term_length = 0;\r\nstream->mtu = 0;\r\nstream->flags = 0;\r\nstream->high.term_id = 0;\r\nstream->high.term_offset = 0;\r\nwmem_map_insert(transport->stream, (const void *) &(stream->stream_id), (void *) stream);\r\n}\r\nreturn (stream);\r\n}\r\nstatic void aeron_transport_frame_add(aeron_transport_t * transport, aeron_frame_info_t * finfo, guint32 flags)\r\n{\r\nif (flags != 0)\r\n{\r\nfinfo->flags = flags;\r\n}\r\nif (transport->last_frame != NULL)\r\n{\r\nfinfo->transport.previous = transport->last_frame->frame;\r\ntransport->last_frame->transport.next = finfo->frame;\r\n}\r\nfinfo->transport.next = 0;\r\ntransport->last_frame = finfo;\r\n}\r\nstatic aeron_term_t * aeron_stream_term_find(aeron_stream_t * stream, guint32 term_id)\r\n{\r\naeron_term_t * term;\r\nterm = (aeron_term_t *) wmem_map_lookup(stream->term, (const void *) &term_id);\r\nreturn (term);\r\n}\r\nstatic aeron_term_t * aeron_stream_term_add(aeron_stream_t * stream, guint32 term_id)\r\n{\r\naeron_term_t * term;\r\nterm = aeron_stream_term_find(stream, term_id);\r\nif (term == NULL)\r\n{\r\nterm = wmem_new0(wmem_file_scope(), aeron_term_t);\r\nterm->stream = stream;\r\nterm->fragment = wmem_map_new(wmem_file_scope(), aeron_guint32_hash_func, aeron_guint32_compare_func);\r\nterm->message = wmem_tree_new(wmem_file_scope());\r\nterm->orphan_fragment = wmem_list_new(wmem_file_scope());\r\nterm->nak = wmem_list_new(wmem_file_scope());\r\nterm->term_id = term_id;\r\nwmem_map_insert(stream->term, (const void *) &(term->term_id), (void *) term);\r\n}\r\nreturn (term);\r\n}\r\nstatic aeron_stream_rcv_t * aeron_stream_rcv_find(aeron_stream_t * stream, const address * addr, guint16 port)\r\n{\r\nwmem_list_frame_t * lf = wmem_list_head(stream->rcv);\r\naeron_stream_rcv_t * rcv = NULL;\r\nwhile (lf != NULL)\r\n{\r\naeron_stream_rcv_t * cur = (aeron_stream_rcv_t *) wmem_list_frame_data(lf);\r\nif (cur != NULL)\r\n{\r\nif ((cmp_address(&(cur->addr), addr) == 0) && (cur->port == port))\r\n{\r\nrcv = cur;\r\nbreak;\r\n}\r\n}\r\nlf = wmem_list_frame_next(lf);\r\n}\r\nreturn (rcv);\r\n}\r\nstatic aeron_stream_rcv_t * aeron_stream_rcv_add(aeron_stream_t * stream, const address * addr, guint16 port)\r\n{\r\naeron_stream_rcv_t * rcv;\r\nrcv = aeron_stream_rcv_find(stream, addr, port);\r\nif (rcv != NULL)\r\n{\r\nreturn (rcv);\r\n}\r\nrcv = wmem_new0(wmem_file_scope(), aeron_stream_rcv_t);\r\ncopy_address_wmem(wmem_file_scope(), &(rcv->addr), addr);\r\nrcv->port = port;\r\nrcv->completed.term_id = 0;\r\nrcv->completed.term_offset = 0;\r\nrcv->receiver_window = 0;\r\nwmem_list_append(stream->rcv, (void *) rcv);\r\nstream->rcv_count++;\r\nreturn (rcv);\r\n}\r\nstatic void aeron_stream_frame_add(aeron_stream_t * stream, aeron_frame_info_t * finfo, guint32 flags)\r\n{\r\nif (flags != 0)\r\n{\r\nfinfo->flags = flags;\r\n}\r\nif (stream->last_frame != NULL)\r\n{\r\nfinfo->stream.previous = stream->last_frame->frame;\r\nstream->last_frame->stream.next = finfo->frame;\r\n}\r\nfinfo->stream.next = 0;\r\nstream->last_frame = finfo;\r\naeron_transport_frame_add(stream->transport, finfo, 0);\r\n}\r\nstatic aeron_fragment_t * aeron_term_fragment_find(aeron_term_t * term, guint32 term_offset)\r\n{\r\naeron_fragment_t * fragment;\r\nfragment = (aeron_fragment_t *) wmem_map_lookup(term->fragment, (const void *) &term_offset);\r\nreturn (fragment);\r\n}\r\nstatic aeron_fragment_t * aeron_term_fragment_add(aeron_term_t * term, guint32 term_offset, guint32 length, guint32 data_length)\r\n{\r\naeron_fragment_t * fragment;\r\nfragment = aeron_term_fragment_find(term, term_offset);\r\nif (fragment == NULL)\r\n{\r\nfragment = wmem_new0(wmem_file_scope(), aeron_fragment_t);\r\nfragment->term = term;\r\nfragment->frame = wmem_list_new(wmem_file_scope());\r\nfragment->first_frame = NULL;\r\nfragment->last_frame = NULL;\r\nfragment->first_data_frame = NULL;\r\nfragment->term_offset = term_offset;\r\nfragment->length = length;\r\nfragment->data_length = data_length;\r\nfragment->frame_count = 0;\r\nwmem_map_insert(term->fragment, (const void *) &(fragment->term_offset), (void *) fragment);\r\n}\r\nreturn (fragment);\r\n}\r\nstatic void aeron_term_frame_add(aeron_term_t * term, aeron_frame_info_t * finfo, guint32 flags)\r\n{\r\nif (flags != 0)\r\n{\r\nfinfo->flags = flags;\r\n}\r\nif (term->last_frame != NULL)\r\n{\r\nfinfo->term.previous = term->last_frame->frame;\r\nterm->last_frame->term.next = finfo->frame;\r\n}\r\nfinfo->term.next = 0;\r\nterm->last_frame = finfo;\r\naeron_stream_frame_add(term->stream, finfo, 0);\r\n}\r\nstatic void aeron_fragment_frame_add(aeron_fragment_t * fragment, aeron_frame_info_t * finfo, guint32 flags, guint32 length)\r\n{\r\nif (flags != 0)\r\n{\r\nfinfo->flags = flags;\r\n}\r\nwmem_list_append(fragment->frame, (void *) finfo);\r\nfragment->frame_count++;\r\nif (fragment->last_frame != NULL)\r\n{\r\nfinfo->fragment.previous = fragment->last_frame->frame;\r\nfragment->last_frame->fragment.next = finfo->frame;\r\n}\r\nif (fragment->first_frame == NULL)\r\n{\r\nfragment->first_frame = finfo;\r\n}\r\nif (length != 0)\r\n{\r\nif (fragment->first_data_frame == NULL)\r\n{\r\nfragment->first_data_frame = finfo;\r\n}\r\n}\r\nfinfo->fragment.next = 0;\r\nfragment->last_frame = finfo;\r\naeron_term_frame_add(fragment->term, finfo, 0);\r\n}\r\nstatic gboolean aeron_is_address_multicast(const address * addr)\r\n{\r\nconst guint8 * addr_data = (const guint8 *) addr->data;\r\nswitch (addr->type)\r\n{\r\ncase AT_IPv4:\r\nif ((addr_data[0] & 0xf0) == 0xe0)\r\n{\r\nreturn (TRUE);\r\n}\r\nbreak;\r\ncase AT_IPv6:\r\nif (addr_data[0] == 0xff)\r\n{\r\nreturn (TRUE);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn (FALSE);\r\n}\r\nstatic char * aeron_format_transport_uri(const aeron_conversation_info_t * cinfo)\r\n{\r\nwmem_strbuf_t * uri;\r\nuri = wmem_strbuf_new(wmem_packet_scope(), "aeron:");\r\nswitch (cinfo->ptype)\r\n{\r\ncase PT_UDP:\r\nwmem_strbuf_append(uri, "udp");\r\nbreak;\r\ndefault:\r\nwmem_strbuf_append(uri, "unknown");\r\nbreak;\r\n}\r\nwmem_strbuf_append_c(uri, '?');\r\nif (aeron_is_address_multicast(cinfo->addr2))\r\n{\r\nswitch (cinfo->addr2->type)\r\n{\r\ncase AT_IPv6:\r\nwmem_strbuf_append_printf(uri, "group=[%s]:%" G_GUINT16_FORMAT, address_to_str(wmem_packet_scope(), cinfo->addr2), cinfo->port2);\r\nbreak;\r\ncase AT_IPv4:\r\ndefault:\r\nwmem_strbuf_append_printf(uri, "group=%s:%" G_GUINT16_FORMAT, address_to_str(wmem_packet_scope(), cinfo->addr2), cinfo->port2);\r\nbreak;\r\n}\r\n}\r\nelse\r\n{\r\nswitch (cinfo->addr2->type)\r\n{\r\ncase AT_IPv6:\r\nwmem_strbuf_append_printf(uri, "remote=[%s]:%" G_GUINT16_FORMAT, address_to_str(wmem_packet_scope(), cinfo->addr2), cinfo->port2);\r\nbreak;\r\ncase AT_IPv4:\r\ndefault:\r\nwmem_strbuf_append_printf(uri, "remote=%s:%" G_GUINT16_FORMAT, address_to_str(wmem_packet_scope(), cinfo->addr2), cinfo->port2);\r\nbreak;\r\n}\r\n}\r\nreturn (wmem_strbuf_finalize(uri));\r\n}\r\nstatic aeron_conversation_info_t * aeron_setup_conversation_info(const packet_info * pinfo, guint16 type)\r\n{\r\naeron_conversation_info_t * cinfo;\r\nint addr_len = pinfo->dst.len;\r\ncinfo = wmem_new0(wmem_packet_scope(), aeron_conversation_info_t);\r\ncinfo->ptype = pinfo->ptype;\r\nswitch (pinfo->dst.type)\r\n{\r\ncase AT_IPv4:\r\n{\r\nconst guint8 * dst_addr = (const guint8 *) pinfo->dst.data;\r\ncinfo->addr1 = wmem_new0(wmem_packet_scope(), address);\r\ncinfo->addr2 = wmem_new0(wmem_packet_scope(), address);\r\nif (aeron_is_address_multicast(&(pinfo->dst)))\r\n{\r\nguint8 * addr1;\r\nguint8 * addr2;\r\naddr1 = (guint8 *) wmem_memdup(wmem_packet_scope(), (const void *) dst_addr, (size_t) addr_len);\r\naddr2 = (guint8 *) wmem_memdup(wmem_packet_scope(), (const void *) dst_addr, (size_t) addr_len);\r\nif ((dst_addr[addr_len - 1] & 0x1) != 0)\r\n{\r\naddr1[addr_len - 1]++;\r\n}\r\nelse\r\n{\r\naddr2[addr_len - 1]--;\r\n}\r\nset_address(cinfo->addr1, AT_IPv4, addr_len, (void *) addr1);\r\nset_address(cinfo->addr2, AT_IPv4, addr_len, (void *) addr2);\r\ncinfo->port1 = pinfo->destport;\r\ncinfo->port2 = cinfo->port1;\r\n}\r\nelse\r\n{\r\nswitch (type)\r\n{\r\ncase HDR_TYPE_PAD:\r\ncase HDR_TYPE_DATA:\r\ncase HDR_TYPE_SETUP:\r\ncopy_address_wmem(wmem_packet_scope(), cinfo->addr1, &(pinfo->src));\r\ncinfo->port1 = pinfo->srcport;\r\ncopy_address_wmem(wmem_packet_scope(), cinfo->addr2, &(pinfo->dst));\r\ncinfo->port2 = pinfo->destport;\r\nbreak;\r\ncase HDR_TYPE_NAK:\r\ncase HDR_TYPE_SM:\r\ncopy_address_wmem(wmem_packet_scope(), cinfo->addr1, &(pinfo->dst));\r\ncinfo->port1 = pinfo->destport;\r\ncopy_address_wmem(wmem_packet_scope(), cinfo->addr2, &(pinfo->src));\r\ncinfo->port2 = pinfo->srcport;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase AT_IPv6:\r\n{\r\nconst guint8 * dst_addr = (const guint8 *) pinfo->dst.data;\r\ncinfo->addr1 = wmem_new0(wmem_packet_scope(), address);\r\ncinfo->addr2 = wmem_new0(wmem_packet_scope(), address);\r\nif (aeron_is_address_multicast(&(pinfo->dst)))\r\n{\r\nguint8 * addr1;\r\nguint8 * addr2;\r\naddr1 = (guint8 *) wmem_memdup(wmem_packet_scope(), (const void *) dst_addr, (size_t) addr_len);\r\naddr2 = (guint8 *) wmem_memdup(wmem_packet_scope(), (const void *) dst_addr, (size_t) addr_len);\r\nif ((dst_addr[addr_len - 1] & 0x1) != 0)\r\n{\r\naddr1[addr_len - 1]++;\r\n}\r\nelse\r\n{\r\naddr2[addr_len - 1]--;\r\n}\r\nset_address(cinfo->addr1, AT_IPv6, addr_len, (void *) addr1);\r\nset_address(cinfo->addr2, AT_IPv6, addr_len, (void *) addr2);\r\ncinfo->port1 = pinfo->destport;\r\ncinfo->port2 = cinfo->port1;\r\n}\r\nelse\r\n{\r\nswitch (type)\r\n{\r\ncase HDR_TYPE_PAD:\r\ncase HDR_TYPE_DATA:\r\ncase HDR_TYPE_SETUP:\r\ncopy_address_wmem(wmem_packet_scope(), cinfo->addr1, &(pinfo->src));\r\ncinfo->port1 = pinfo->srcport;\r\ncopy_address_wmem(wmem_packet_scope(), cinfo->addr2, &(pinfo->dst));\r\ncinfo->port2 = pinfo->destport;\r\nbreak;\r\ncase HDR_TYPE_NAK:\r\ncase HDR_TYPE_SM:\r\ncopy_address_wmem(wmem_packet_scope(), cinfo->addr1, &(pinfo->dst));\r\ncinfo->port1 = pinfo->destport;\r\ncopy_address_wmem(wmem_packet_scope(), cinfo->addr2, &(pinfo->src));\r\ncinfo->port2 = pinfo->srcport;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nreturn (NULL);\r\n}\r\nreturn (cinfo);\r\n}\r\nstatic void aeron_frame_nak_rx_add(aeron_frame_info_t * nak_info, aeron_frame_info_t * rx_info, guint32 term_offset, guint32 length)\r\n{\r\nif (nak_info->nak_analysis->unrecovered_length >= length)\r\n{\r\nwmem_list_frame_t * lf = wmem_list_head(nak_info->nak_analysis->rx);\r\naeron_rx_info_t * rx = NULL;\r\nwhile (lf != NULL)\r\n{\r\nrx = (aeron_rx_info_t *) wmem_list_frame_data(lf);\r\nif (rx != NULL)\r\n{\r\nif ((rx->term_offset == term_offset) && (rx->length == length))\r\n{\r\nreturn;\r\n}\r\n}\r\nlf = wmem_list_frame_next(lf);\r\n}\r\nrx = wmem_new0(wmem_file_scope(), aeron_rx_info_t);\r\nrx->frame_info = rx_info;\r\nrx->term_offset = term_offset;\r\nrx->length = length;\r\nwmem_list_append(nak_info->nak_analysis->rx, (void *) rx);\r\nnak_info->nak_analysis->unrecovered_length -= length;\r\nwmem_list_append(rx_info->rx, (void *) nak_info);\r\n}\r\n}\r\nstatic void aeron_frame_process_rx(aeron_packet_info_t * info, aeron_frame_info_t * finfo, aeron_term_t * term)\r\n{\r\nwmem_list_frame_t * lf;\r\nlf = wmem_list_head(term->nak);\r\nwhile (lf != NULL)\r\n{\r\naeron_nak_t * nak = (aeron_nak_t *) wmem_list_frame_data(lf);\r\nif (nak != NULL)\r\n{\r\nif (nak->frame_info->frame <= finfo->frame)\r\n{\r\nif ((nak->term_offset <= info->term_offset) && (nak->length >= info->length))\r\n{\r\naeron_frame_nak_rx_add(nak->frame_info, finfo, info->term_offset, info->length);\r\n}\r\n}\r\n}\r\nlf = wmem_list_frame_next(lf);\r\n}\r\n}\r\nstatic void aeron_frame_nak_analysis_setup(aeron_packet_info_t * info, aeron_frame_info_t * finfo, aeron_term_t * term)\r\n{\r\naeron_nak_t * nak = wmem_new0(wmem_file_scope(), aeron_nak_t);\r\nnak->term = term;\r\nnak->frame_info = finfo;\r\nnak->term_offset = info->nak_term_offset;\r\nnak->length = info->nak_length;\r\nwmem_list_append(term->nak, (void *) nak);\r\nfinfo->nak_analysis = wmem_new0(wmem_file_scope(), aeron_nak_analysis_t);\r\nfinfo->nak_analysis->frame_info = finfo;\r\nfinfo->nak_analysis->rx = wmem_list_new(wmem_file_scope());\r\nfinfo->nak_analysis->nak_term_offset = info->nak_term_offset;\r\nfinfo->nak_analysis->nak_length = info->nak_length;\r\nfinfo->nak_analysis->unrecovered_length = info->nak_length;\r\n}\r\nstatic int aeron_frame_stream_analysis_setup(packet_info * pinfo, aeron_packet_info_t * info, aeron_frame_info_t * finfo, aeron_stream_t * stream, aeron_term_t * term, gboolean new_term)\r\n{\r\naeron_stream_rcv_t * rcv = NULL;\r\naeron_pos_t dp = { 0, 0 };\r\naeron_pos_t pdp = stream->high;\r\ngboolean pdpv = ((stream->flags & AERON_STREAM_FLAGS_HIGH_VALID) != 0);\r\naeron_pos_t rp = { 0, 0 };\r\naeron_pos_t prp = { 0, 0 };\r\ngboolean prpv = FALSE;\r\nguint32 cur_receiver_window = 0;\r\nguint32 frame_flags = 0;\r\nif (info->type == HDR_TYPE_SM)\r\n{\r\nrcv = aeron_stream_rcv_find(stream, &(pinfo->src), pinfo->srcport);\r\nif (rcv == NULL)\r\n{\r\nrcv = aeron_stream_rcv_add(stream, &(pinfo->src), pinfo->srcport);\r\n}\r\nelse\r\n{\r\nprpv = TRUE;\r\nprp = rcv->completed;\r\ncur_receiver_window = rcv->receiver_window;\r\n}\r\n}\r\nswitch (info->type)\r\n{\r\ncase HDR_TYPE_DATA:\r\ncase HDR_TYPE_PAD:\r\ndp.term_id = info->term_id;\r\ndp.term_offset = info->term_offset;\r\nif (!aeron_pos_add_length(&dp, info->length, stream->term_length))\r\nreturn -1;\r\nif (pdpv)\r\n{\r\nif (dp.term_id > stream->high.term_id)\r\n{\r\nstream->high.term_id = dp.term_id;\r\nstream->high.term_offset = dp.term_offset;\r\n}\r\nelse if (dp.term_offset > stream->high.term_offset)\r\n{\r\nstream->high.term_offset = dp.term_offset;\r\n}\r\n}\r\nelse\r\n{\r\nstream->flags |= AERON_STREAM_FLAGS_HIGH_VALID;\r\nstream->high.term_id = dp.term_id;\r\nstream->high.term_offset = dp.term_offset;\r\n}\r\nbreak;\r\ncase HDR_TYPE_SM:\r\nrp.term_id = info->term_id;\r\nrp.term_offset = info->term_offset;\r\nif (prpv)\r\n{\r\nif (rp.term_id > rcv->completed.term_id)\r\n{\r\nrcv->completed.term_id = rp.term_id;\r\nrcv->completed.term_offset = rp.term_offset;\r\n}\r\nelse if (rp.term_offset > rcv->completed.term_offset)\r\n{\r\nrcv->completed.term_offset = rp.term_offset;\r\n}\r\n}\r\nelse\r\n{\r\nrcv->completed.term_id = rp.term_id;\r\nrcv->completed.term_offset = rp.term_offset;\r\n}\r\nrcv->receiver_window = info->receiver_window;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (aeron_stream_analysis)\r\n{\r\nif ((stream->flags & AERON_STREAM_FLAGS_HIGH_VALID) != 0)\r\n{\r\nfinfo->stream_analysis = wmem_new0(wmem_file_scope(), aeron_stream_analysis_t);\r\n}\r\n}\r\nif (finfo->stream_analysis != NULL)\r\n{\r\nswitch (info->type)\r\n{\r\ncase HDR_TYPE_DATA:\r\ncase HDR_TYPE_SM:\r\ncase HDR_TYPE_PAD:\r\nfinfo->stream_analysis->high.term_id = stream->high.term_id;\r\nfinfo->stream_analysis->high.term_offset = stream->high.term_offset;\r\nif (rcv != NULL)\r\n{\r\nfinfo->stream_analysis->flags2 |= AERON_STREAM_ANALYSIS_FLAGS2_RCV_VALID;\r\nfinfo->stream_analysis->completed.term_id = rcv->completed.term_id;\r\nfinfo->stream_analysis->completed.term_offset = rcv->completed.term_offset;\r\nfinfo->stream_analysis->receiver_window = rcv->receiver_window;\r\nfinfo->stream_analysis->outstanding_bytes = aeron_pos_delta(&(finfo->stream_analysis->high), &(finfo->stream_analysis->completed), stream->term_length);\r\nif (finfo->stream_analysis->outstanding_bytes >= finfo->stream_analysis->receiver_window)\r\n{\r\nfinfo->stream_analysis->flags |= AERON_STREAM_ANALYSIS_FLAGS_WINDOW_FULL;\r\n}\r\n}\r\nelse\r\n{\r\nfinfo->stream_analysis->completed.term_id = 0;\r\nfinfo->stream_analysis->completed.term_offset = 0;\r\nfinfo->stream_analysis->receiver_window = 0;\r\nfinfo->stream_analysis->outstanding_bytes = 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (info->type)\r\n{\r\ncase HDR_TYPE_DATA:\r\ncase HDR_TYPE_PAD:\r\nif (pdpv)\r\n{\r\nint rc = aeron_pos_compare(&dp, &pdp);\r\nif (rc == 0)\r\n{\r\nif (info->length == 0)\r\n{\r\nfinfo->stream_analysis->flags |= AERON_STREAM_ANALYSIS_FLAGS_KEEPALIVE;\r\nframe_flags |= AERON_FRAME_INFO_FLAGS_KEEPALIVE;\r\n}\r\nelse\r\n{\r\nif (prpv)\r\n{\r\nif (aeron_pos_compare(&dp, &prp) == 0)\r\n{\r\nfinfo->stream_analysis->flags |= AERON_STREAM_ANALYSIS_FLAGS_IDLE_RX;\r\n}\r\nelse\r\n{\r\nfinfo->stream_analysis->flags |= AERON_STREAM_ANALYSIS_FLAGS_PACING_RX;\r\n}\r\n}\r\nelse\r\n{\r\nfinfo->stream_analysis->flags |= AERON_STREAM_ANALYSIS_FLAGS_IDLE_RX;\r\n}\r\nframe_flags |= AERON_FRAME_INFO_FLAGS_RETRANSMISSION;\r\n}\r\n}\r\nelse\r\n{\r\naeron_pos_t expected_dp;\r\nint erc;\r\nexpected_dp.term_id = pdp.term_id;\r\nexpected_dp.term_offset = pdp.term_offset;\r\nif (!aeron_pos_add_length(&expected_dp, info->length, stream->term_length))\r\nreturn -1;\r\nerc = aeron_pos_compare(&expected_dp, &dp);\r\nif (erc > 0)\r\n{\r\nfinfo->stream_analysis->flags |= AERON_STREAM_ANALYSIS_FLAGS_RX;\r\nframe_flags |= AERON_FRAME_INFO_FLAGS_RETRANSMISSION;\r\naeron_frame_process_rx(info, finfo, term);\r\n}\r\nelse if (erc < 0)\r\n{\r\nfinfo->stream_analysis->flags |= AERON_STREAM_ANALYSIS_FLAGS_OOO_GAP;\r\n}\r\n}\r\n}\r\nif (new_term && (info->term_offset == 0))\r\n{\r\nfinfo->stream_analysis->flags |= AERON_STREAM_ANALYSIS_FLAGS_TERM_ID_CHANGE;\r\n}\r\nbreak;\r\ncase HDR_TYPE_SM:\r\nif (prpv)\r\n{\r\nint rc = aeron_pos_compare(&rp, &prp);\r\nif (rc == 0)\r\n{\r\nfinfo->stream_analysis->flags |= AERON_STREAM_ANALYSIS_FLAGS_KEEPALIVE_SM;\r\n}\r\nelse if (rc < 0)\r\n{\r\nfinfo->stream_analysis->flags |= AERON_STREAM_ANALYSIS_FLAGS_OOO_SM;\r\n}\r\nif (cur_receiver_window != finfo->stream_analysis->receiver_window)\r\n{\r\nfinfo->stream_analysis->flags |= AERON_STREAM_ANALYSIS_FLAGS_WINDOW_RESIZE;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif ((info->type == HDR_TYPE_DATA) || (info->type == HDR_TYPE_PAD))\r\n{\r\naeron_fragment_t * fragment;\r\nfragment = aeron_term_fragment_find(term, info->term_offset);\r\nif (fragment == NULL)\r\n{\r\nfragment = aeron_term_fragment_add(term, info->term_offset, info->length, info->data_length);\r\n}\r\naeron_fragment_frame_add(fragment, finfo, frame_flags, info->length);\r\n}\r\nelse\r\n{\r\naeron_term_frame_add(term, finfo, frame_flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int aeron_frame_info_setup(packet_info * pinfo, aeron_transport_t * transport, aeron_packet_info_t * info, aeron_frame_info_t * finfo)\r\n{\r\nif (!transport || !aeron_sequence_analysis || !finfo || PINFO_FD_VISITED(pinfo))\r\nreturn 0;\r\nif ((info->info_flags & AERON_PACKET_INFO_FLAGS_STREAM_ID_VALID) != 0)\r\n{\r\naeron_stream_t * stream;\r\nstream = aeron_transport_stream_find(transport, info->stream_id);\r\nif (stream == NULL)\r\n{\r\nstream = aeron_transport_stream_add(transport, info->stream_id);\r\n}\r\nif ((info->info_flags & AERON_PACKET_INFO_FLAGS_TERM_ID_VALID) != 0)\r\n{\r\naeron_term_t * term;\r\ngboolean new_term = FALSE;\r\nterm = aeron_stream_term_find(stream, info->term_id);\r\nif (term == NULL)\r\n{\r\nterm = aeron_stream_term_add(stream, info->term_id);\r\nnew_term = TRUE;\r\n}\r\nif ((info->info_flags & AERON_PACKET_INFO_FLAGS_TERM_OFFSET_VALID) != 0)\r\n{\r\nif (aeron_frame_stream_analysis_setup(pinfo, info, finfo, stream, term, new_term) < 0)\r\nreturn -1;\r\n}\r\nelse\r\n{\r\naeron_term_frame_add(term, finfo, 0);\r\nif (info->type == HDR_TYPE_NAK)\r\n{\r\naeron_frame_nak_analysis_setup(info, finfo, term);\r\n}\r\n}\r\n}\r\nelse\r\n{\r\naeron_stream_frame_add(stream, finfo, 0);\r\n}\r\n}\r\nelse\r\n{\r\naeron_transport_frame_add(transport, finfo, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void aeron_sequence_report_frame(tvbuff_t * tvb, proto_tree * tree, aeron_frame_info_t * finfo)\r\n{\r\nproto_item * item = NULL;\r\nif ((finfo->flags & AERON_FRAME_INFO_FLAGS_RETRANSMISSION) != 0)\r\n{\r\nitem = proto_tree_add_uint_format_value(tree, hf_aeron_sequence_analysis_term_offset_frame, tvb, 0, 0, finfo->frame, "%" G_GUINT32_FORMAT " (RX)", finfo->frame);\r\n}\r\nelse if ((finfo->flags & AERON_FRAME_INFO_FLAGS_KEEPALIVE) != 0)\r\n{\r\nitem = proto_tree_add_uint_format_value(tree, hf_aeron_sequence_analysis_term_offset_frame, tvb, 0, 0, finfo->frame, "%" G_GUINT32_FORMAT " (KA)", finfo->frame);\r\n}\r\nelse\r\n{\r\nitem = proto_tree_add_uint(tree, hf_aeron_sequence_analysis_term_offset_frame, tvb, 0, 0, finfo->frame);\r\n}\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nstatic void aeron_sequence_report(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, aeron_transport_t * transport, aeron_packet_info_t * info, aeron_frame_info_t * finfo)\r\n{\r\nif (transport != NULL)\r\n{\r\nif (aeron_sequence_analysis && (finfo != NULL))\r\n{\r\nproto_tree * subtree;\r\nproto_item * item;\r\nitem = proto_tree_add_item(tree, hf_aeron_sequence_analysis, tvb, 0, 0, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(item);\r\nsubtree = proto_item_add_subtree(item, ett_aeron_sequence_analysis);\r\nif (finfo->transport.previous != 0)\r\n{\r\nitem = proto_tree_add_uint(subtree, hf_aeron_sequence_analysis_channel_prev_frame, tvb, 0, 0, finfo->transport.previous);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nif (finfo->transport.next != 0)\r\n{\r\nitem = proto_tree_add_uint(subtree, hf_aeron_sequence_analysis_channel_next_frame, tvb, 0, 0, finfo->transport.next);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nif ((info->info_flags & AERON_PACKET_INFO_FLAGS_STREAM_ID_VALID) != 0)\r\n{\r\naeron_stream_t * stream;\r\nstream = aeron_transport_stream_find(transport, info->stream_id);\r\nif (stream != NULL)\r\n{\r\nif (finfo->stream.previous != 0)\r\n{\r\nitem = proto_tree_add_uint(subtree, hf_aeron_sequence_analysis_stream_prev_frame, tvb, 0, 0, finfo->stream.previous);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nif (finfo->stream.next != 0)\r\n{\r\nitem = proto_tree_add_uint(subtree, hf_aeron_sequence_analysis_stream_next_frame, tvb, 0, 0, finfo->stream.next);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nif ((info->info_flags & AERON_PACKET_INFO_FLAGS_TERM_ID_VALID) != 0)\r\n{\r\naeron_term_t * term;\r\nterm = aeron_stream_term_find(stream, info->term_id);\r\nif (term != NULL)\r\n{\r\nif (finfo->term.previous != 0)\r\n{\r\nitem = proto_tree_add_uint(subtree, hf_aeron_sequence_analysis_term_prev_frame, tvb, 0, 0, finfo->term.previous);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nif (finfo->term.next != 0)\r\n{\r\nitem = proto_tree_add_uint(subtree, hf_aeron_sequence_analysis_term_next_frame, tvb, 0, 0, finfo->term.next);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nif ((info->info_flags & AERON_PACKET_INFO_FLAGS_TERM_OFFSET_VALID) != 0)\r\n{\r\nif ((info->type == HDR_TYPE_DATA) || (info->type == HDR_TYPE_PAD))\r\n{\r\naeron_fragment_t * fragment;\r\nfragment = aeron_term_fragment_find(term, info->term_offset);\r\nif (fragment != NULL)\r\n{\r\nproto_item * fei_item;\r\ngboolean rx = ((finfo->flags & AERON_FRAME_INFO_FLAGS_RETRANSMISSION) != 0);\r\ngboolean ka = ((finfo->flags & AERON_FRAME_INFO_FLAGS_KEEPALIVE) != 0);\r\nif (fragment->frame_count > 1)\r\n{\r\nproto_tree * frame_tree;\r\nproto_item * frame_item;\r\nwmem_list_frame_t * lf;\r\nframe_item = proto_tree_add_item(subtree, hf_aeron_sequence_analysis_term_offset, tvb, 0, 0, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(frame_item);\r\nframe_tree = proto_item_add_subtree(frame_item, ett_aeron_sequence_analysis_term_offset);\r\nlf = wmem_list_head(fragment->frame);\r\nwhile (lf != NULL)\r\n{\r\naeron_frame_info_t * frag_frame = (aeron_frame_info_t *) wmem_list_frame_data(lf);\r\nif (frag_frame != NULL)\r\n{\r\nif (frag_frame->frame != pinfo->num)\r\n{\r\naeron_sequence_report_frame(tvb, frame_tree, frag_frame);\r\n}\r\n}\r\nlf = wmem_list_frame_next(lf);\r\n}\r\n}\r\nfei_item = proto_tree_add_boolean(subtree, hf_aeron_sequence_analysis_retransmission, tvb, 0, 0, rx);\r\nPROTO_ITEM_SET_GENERATED(fei_item);\r\nif (rx)\r\n{\r\nif (wmem_list_count(finfo->rx) > 0)\r\n{\r\nproto_tree * rx_tree;\r\nproto_item * rx_item;\r\nwmem_list_frame_t * lf;\r\nrx_item = proto_tree_add_item(subtree, hf_aeron_sequence_analysis_retransmission_rx, tvb, 0, 0, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(rx_item);\r\nrx_tree = proto_item_add_subtree(rx_item, ett_aeron_sequence_analysis_retransmission_rx);\r\nlf = wmem_list_head(finfo->rx);\r\nwhile (lf != NULL)\r\n{\r\naeron_frame_info_t * nak = (aeron_frame_info_t *) wmem_list_frame_data(lf);\r\nif (nak != NULL)\r\n{\r\nrx_item = proto_tree_add_uint(rx_tree, hf_aeron_sequence_analysis_retransmission_rx_frame, tvb, 0, 0, nak->frame);\r\nPROTO_ITEM_SET_GENERATED(rx_item);\r\n}\r\nlf = wmem_list_frame_next(lf);\r\n}\r\n}\r\n}\r\nfei_item = proto_tree_add_boolean(subtree, hf_aeron_sequence_analysis_keepalive, tvb, 0, 0, ka);\r\nPROTO_ITEM_SET_GENERATED(fei_item);\r\n}\r\n}\r\n}\r\nelse if ((info->type == HDR_TYPE_NAK) && (finfo->nak_analysis != NULL))\r\n{\r\nproto_item * nak_item;\r\nnak_item = proto_tree_add_uint(subtree, hf_aeron_sequence_analysis_nak_unrecovered, tvb, 0, 0, finfo->nak_analysis->unrecovered_length);\r\nPROTO_ITEM_SET_GENERATED(nak_item);\r\nif (wmem_list_count(finfo->nak_analysis->rx) > 0)\r\n{\r\nproto_tree * rx_tree;\r\nproto_item * rx_item;\r\nwmem_list_frame_t * lf;\r\nrx_item = proto_tree_add_item(subtree, hf_aeron_sequence_analysis_nak_rx, tvb, 0, 0, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(rx_item);\r\nrx_tree = proto_item_add_subtree(rx_item, ett_aeron_sequence_analysis_nak_rx);\r\nlf = wmem_list_head(finfo->nak_analysis->rx);\r\nwhile (lf != NULL)\r\n{\r\naeron_rx_info_t * rx = (aeron_rx_info_t *) wmem_list_frame_data(lf);\r\nif (rx != NULL)\r\n{\r\nrx_item = proto_tree_add_uint_format_value(rx_tree, hf_aeron_sequence_analysis_nak_rx_frame, tvb, 0, 0, rx->frame_info->frame,\r\n"%" G_GUINT32_FORMAT ", Term offset=%" G_GUINT32_FORMAT " (0x%08x), Length=%" G_GUINT32_FORMAT, rx->frame_info->frame, rx->term_offset, rx->term_offset, rx->length);\r\nPROTO_ITEM_SET_GENERATED(rx_item);\r\n}\r\nlf = wmem_list_frame_next(lf);\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void aeron_stream_report(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, aeron_transport_t * transport, aeron_frame_info_t * finfo)\r\n{\r\nif (transport != NULL)\r\n{\r\nif (aeron_sequence_analysis && aeron_stream_analysis && (finfo != NULL) && (finfo->stream_analysis != NULL))\r\n{\r\nproto_tree * subtree;\r\nproto_item * item;\r\nitem = proto_tree_add_item(tree, hf_aeron_stream_analysis, tvb, 0, 0, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(item);\r\nsubtree = proto_item_add_subtree(item, ett_aeron_stream_analysis);\r\nitem = proto_tree_add_uint(subtree, hf_aeron_stream_analysis_high_term_id, tvb, 0, 0, finfo->stream_analysis->high.term_id);\r\nif ((finfo->stream_analysis->flags & AERON_STREAM_ANALYSIS_FLAGS_TERM_ID_CHANGE) != 0)\r\n{\r\nexpert_add_info(pinfo, item, &ei_aeron_analysis_term_id_change);\r\n}\r\nPROTO_ITEM_SET_GENERATED(item);\r\nitem = proto_tree_add_uint(subtree, hf_aeron_stream_analysis_high_term_offset, tvb, 0, 0, finfo->stream_analysis->high.term_offset);\r\nPROTO_ITEM_SET_GENERATED(item);\r\nif ((finfo->stream_analysis->flags & AERON_STREAM_ANALYSIS_FLAGS_IDLE_RX) != 0)\r\n{\r\nexpert_add_info(pinfo, item, &ei_aeron_analysis_idle_rx);\r\n}\r\nif ((finfo->stream_analysis->flags & AERON_STREAM_ANALYSIS_FLAGS_PACING_RX) != 0)\r\n{\r\nexpert_add_info(pinfo, item, &ei_aeron_analysis_pacing_rx);\r\n}\r\nif ((finfo->stream_analysis->flags & AERON_STREAM_ANALYSIS_FLAGS_OOO) != 0)\r\n{\r\nexpert_add_info(pinfo, item, &ei_aeron_analysis_ooo);\r\n}\r\nif ((finfo->stream_analysis->flags & AERON_STREAM_ANALYSIS_FLAGS_OOO_GAP) != 0)\r\n{\r\nexpert_add_info(pinfo, item, &ei_aeron_analysis_ooo_gap);\r\n}\r\nif ((finfo->stream_analysis->flags & AERON_STREAM_ANALYSIS_FLAGS_KEEPALIVE) != 0)\r\n{\r\nexpert_add_info(pinfo, item, &ei_aeron_analysis_keepalive);\r\n}\r\nif ((finfo->stream_analysis->flags & AERON_STREAM_ANALYSIS_FLAGS_RX) != 0)\r\n{\r\nexpert_add_info(pinfo, item, &ei_aeron_analysis_rx);\r\n}\r\nif ((finfo->stream_analysis->flags2 & AERON_STREAM_ANALYSIS_FLAGS2_RCV_VALID) != 0)\r\n{\r\nitem = proto_tree_add_uint(subtree, hf_aeron_stream_analysis_completed_term_id, tvb, 0, 0, finfo->stream_analysis->completed.term_id);\r\nPROTO_ITEM_SET_GENERATED(item);\r\nitem = proto_tree_add_uint(subtree, hf_aeron_stream_analysis_completed_term_offset, tvb, 0, 0, finfo->stream_analysis->completed.term_offset);\r\nPROTO_ITEM_SET_GENERATED(item);\r\nif ((finfo->stream_analysis->flags & AERON_STREAM_ANALYSIS_FLAGS_OOO_SM) != 0)\r\n{\r\nexpert_add_info(pinfo, item, &ei_aeron_analysis_ooo_sm);\r\n}\r\nif ((finfo->stream_analysis->flags & AERON_STREAM_ANALYSIS_FLAGS_KEEPALIVE_SM) != 0)\r\n{\r\nexpert_add_info(pinfo, item, &ei_aeron_analysis_keepalive_sm);\r\n}\r\nitem = proto_tree_add_uint(subtree, hf_aeron_stream_analysis_outstanding_bytes, tvb, 0, 0, finfo->stream_analysis->outstanding_bytes);\r\nPROTO_ITEM_SET_GENERATED(item);\r\nif ((finfo->stream_analysis->flags & AERON_STREAM_ANALYSIS_FLAGS_WINDOW_FULL) != 0)\r\n{\r\nexpert_add_info(pinfo, item, &ei_aeron_analysis_window_full);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void aeron_next_offset_report(tvbuff_t * tvb, proto_tree * tree, aeron_transport_t * transport, guint32 stream_id, guint32 term_id, guint32 term_offset, guint32 length)\r\n{\r\naeron_stream_t * stream;\r\nstream = aeron_transport_stream_find(transport, stream_id);\r\nif (stream != NULL)\r\n{\r\naeron_term_t * term;\r\nif (stream->term_length == 0)\r\n{\r\nstream->term_length = length;\r\n}\r\nterm = aeron_stream_term_find(stream, term_id);\r\nif (term != NULL)\r\n{\r\naeron_fragment_t * fragment = aeron_term_fragment_find(term, term_offset);\r\nif (fragment != NULL)\r\n{\r\nguint32 next_offset = term_offset + length;\r\nguint32 next_offset_term_id = term_id;\r\nguint32 next_offset_first_frame = 0;\r\naeron_term_t * next_offset_term = NULL;\r\nproto_item * item;\r\nif (next_offset >= stream->term_length)\r\n{\r\nnext_offset = 0;\r\nnext_offset_term_id++;\r\n}\r\nitem = proto_tree_add_uint(tree, hf_aeron_data_next_offset, tvb, 0, 0, next_offset);\r\nPROTO_ITEM_SET_GENERATED(item);\r\nif (next_offset_term_id != term_id)\r\n{\r\nnext_offset_term = aeron_stream_term_find(stream, next_offset_term_id);\r\nitem = proto_tree_add_uint(tree, hf_aeron_data_next_offset_term, tvb, 0, 0, next_offset_term_id);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nelse\r\n{\r\nnext_offset_term = term;\r\n}\r\nif (next_offset_term != NULL)\r\n{\r\naeron_fragment_t * next_offset_fragment;\r\nnext_offset_fragment = aeron_term_fragment_find(next_offset_term, next_offset);\r\nif (next_offset_fragment != NULL)\r\n{\r\nif (next_offset_fragment->first_frame != NULL)\r\n{\r\nnext_offset_first_frame = next_offset_fragment->first_frame->frame;\r\nitem = proto_tree_add_uint(tree, hf_aeron_data_next_offset_first_frame, tvb, 0, 0, next_offset_first_frame);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void aeron_info_stream_progress_report(packet_info * pinfo, guint16 msgtype, guint8 flags, guint32 term_id, guint32 term_offset, aeron_frame_info_t * finfo)\r\n{\r\nconst gchar * type_string = val_to_str_const((guint32) msgtype, aeron_frame_type, "Unknown");\r\nif (aeron_sequence_analysis && aeron_stream_analysis && (finfo != NULL) && (finfo->stream_analysis != NULL))\r\n{\r\nswitch (msgtype)\r\n{\r\ncase HDR_TYPE_PAD:\r\ncase HDR_TYPE_DATA:\r\nif ((finfo->stream_analysis->flags & AERON_STREAM_ANALYSIS_FLAGS_KEEPALIVE) != 0)\r\n{\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, ", ", "%s-KA", type_string);\r\n}\r\nelse\r\n{\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, ", ", "%s (0x%08x:%" G_GUINT32_FORMAT ")",\r\ntype_string, term_id, term_offset);\r\n}\r\nbreak;\r\ncase HDR_TYPE_SM:\r\nif ((finfo->stream_analysis->flags & AERON_STREAM_ANALYSIS_FLAGS_KEEPALIVE_SM) != 0)\r\n{\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, ", ", "%s-KA", type_string);\r\n}\r\nelse\r\n{\r\nif (finfo->stream_analysis->high.term_id == finfo->stream_analysis->completed.term_id)\r\n{\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, ", ", "%s (%" G_GUINT32_FORMAT "/%" G_GUINT32_FORMAT " [%" G_GUINT32_FORMAT "])",\r\ntype_string, finfo->stream_analysis->high.term_offset, finfo->stream_analysis->completed.term_offset, finfo->stream_analysis->outstanding_bytes);\r\n}\r\nelse\r\n{\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, ", ", "%s (0x%08x:%" G_GUINT32_FORMAT "/0x%08x:%" G_GUINT32_FORMAT " [%" G_GUINT32_FORMAT "])",\r\ntype_string, finfo->stream_analysis->high.term_id, finfo->stream_analysis->high.term_offset, finfo->stream_analysis->completed.term_id, finfo->stream_analysis->completed.term_offset, finfo->stream_analysis->outstanding_bytes);\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nelse\r\n{\r\nif ((msgtype == HDR_TYPE_SM) && ((flags & STATUS_FLAGS_SETUP) != 0))\r\n{\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, ", ", "%s-SETUP", type_string);\r\n}\r\nelse\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, ", ", type_string);\r\n}\r\n}\r\n}\r\nstatic void aeron_msg_fragment_add(aeron_msg_t * msg, aeron_msg_fragment_t * fragment)\r\n{\r\nwmem_list_append(msg->fragment, (void *) fragment);\r\nmsg->length += fragment->data_length;\r\nmsg->contiguous_length += fragment->data_length;\r\nmsg->fragment_count++;\r\nif (msg->first_frame > fragment->frame)\r\n{\r\nmsg->first_frame = fragment->frame;\r\n}\r\nif (msg->last_frame < fragment->frame)\r\n{\r\nmsg->last_frame = fragment->frame;\r\n}\r\nmsg->next_expected_term_offset += fragment->frame_length;\r\nif ((fragment->flags & DATA_FLAGS_END) == DATA_FLAGS_END)\r\n{\r\ngchar * buf;\r\nwmem_list_frame_t * lf;\r\nsize_t ofs = 0;\r\nsize_t accum_len = 0;\r\nguint32 last_frame_offset = 0;\r\ngboolean last_frame_found = FALSE;\r\naeron_frame_info_t * finfo = NULL;\r\nmsg->complete = TRUE;\r\nmsg->end_frame = fragment->frame;\r\nbuf = (gchar *) wmem_alloc(wmem_file_scope(), (size_t) msg->length);\r\nlf = wmem_list_head(msg->fragment);\r\nwhile (lf != NULL)\r\n{\r\naeron_msg_fragment_t * cur_frag = (aeron_msg_fragment_t *) wmem_list_frame_data(lf);\r\nif (cur_frag != NULL)\r\n{\r\nif (cur_frag->frame == msg->last_frame)\r\n{\r\nlast_frame_offset = cur_frag->frame_offset;\r\nlast_frame_found = TRUE;\r\n}\r\nmemcpy((void *) (buf + ofs), (void *) cur_frag->data, (size_t) cur_frag->data_length);\r\nofs += (size_t) cur_frag->data_length;\r\naccum_len += (size_t) cur_frag->data_length;\r\n}\r\nlf = wmem_list_frame_next(lf);\r\n}\r\nDISSECTOR_ASSERT(accum_len == (size_t) msg->length);\r\nDISSECTOR_ASSERT(last_frame_found == TRUE);\r\nif (last_frame_found)\r\n{\r\nfinfo = aeron_frame_info_find(msg->last_frame, last_frame_offset);\r\n}\r\nmsg->reassembled_data = tvb_new_real_data(buf, msg->length, msg->length);\r\nDISSECTOR_ASSERT(finfo != NULL);\r\nif (finfo != NULL)\r\n{\r\nfinfo->flags |= AERON_FRAME_INFO_FLAGS_REASSEMBLED_MSG;\r\nfinfo->message = msg;\r\n}\r\n}\r\n}\r\nstatic gboolean aeron_msg_process_orphan_fragments_msg_cb(const void *key _U_, void * value, void * userdata)\r\n{\r\naeron_msg_t * msg = (aeron_msg_t *) value;\r\naeron_term_t * term = (aeron_term_t *) userdata;\r\ngboolean frag_found = FALSE;\r\nwmem_list_frame_t * lf = NULL;\r\naeron_msg_fragment_t * frag = NULL;\r\nif (msg->complete)\r\n{\r\nreturn (FALSE);\r\n}\r\nwhile (TRUE)\r\n{\r\nlf = wmem_list_head(term->orphan_fragment);\r\nwhile (lf != NULL)\r\n{\r\nfrag = (aeron_msg_fragment_t *) wmem_list_frame_data(lf);\r\nif (frag != NULL)\r\n{\r\nif (msg->next_expected_term_offset == frag->term_offset)\r\n{\r\nwmem_list_remove_frame(term->orphan_fragment, lf);\r\naeron_msg_fragment_add(msg, frag);\r\nfrag_found = TRUE;\r\nbreak;\r\n}\r\n}\r\nlf = wmem_list_frame_next(lf);\r\n}\r\nif (!frag_found)\r\n{\r\nbreak;\r\n}\r\nfrag_found = FALSE;\r\n}\r\nreturn (FALSE);\r\n}\r\nstatic void aeron_msg_process_orphan_fragments(aeron_term_t * term)\r\n{\r\nif (wmem_list_count(term->orphan_fragment) == 0)\r\n{\r\nreturn;\r\n}\r\nwmem_tree_foreach(term->message, aeron_msg_process_orphan_fragments_msg_cb, (void *) term);\r\n}\r\nstatic aeron_msg_fragment_t * aeron_msg_fragment_create(tvbuff_t * tvb, int offset, packet_info * pinfo, aeron_packet_info_t * info)\r\n{\r\naeron_msg_fragment_t * frag;\r\nfrag = wmem_new0(wmem_file_scope(), aeron_msg_fragment_t);\r\nfrag->term_offset = info->term_offset;\r\nfrag->frame_length = info->length;\r\nfrag->data_length = info->data_length;\r\nfrag->frame = pinfo->num;\r\nfrag->frame_offset = offset;\r\nfrag->data = (gchar *) tvb_memdup(wmem_file_scope(), tvb, frag->frame_offset + O_AERON_DATA_DATA, (size_t) frag->data_length);\r\nfrag->flags = info->flags;\r\nreturn (frag);\r\n}\r\nstatic aeron_msg_fragment_t * aeron_msg_fragment_find(aeron_msg_t * message, aeron_packet_info_t * info)\r\n{\r\naeron_msg_fragment_t * frag = NULL;\r\nwmem_list_frame_t * lf;\r\nif (message->next_expected_term_offset < info->term_offset)\r\n{\r\nreturn (NULL);\r\n}\r\nlf = wmem_list_head(message->fragment);\r\nwhile (lf != NULL)\r\n{\r\nfrag = (aeron_msg_fragment_t *) wmem_list_frame_data(lf);\r\nif (frag != NULL)\r\n{\r\nif (frag->term_offset == info->term_offset)\r\n{\r\nbreak;\r\n}\r\n}\r\nlf = wmem_list_frame_next(lf);\r\n}\r\nreturn (frag);\r\n}\r\nstatic aeron_msg_t * aeron_term_msg_find_le(aeron_term_t * term, guint32 term_offset)\r\n{\r\naeron_msg_t * msg = (aeron_msg_t *) wmem_tree_lookup32_le(term->message, term_offset);\r\nreturn (msg);\r\n}\r\nstatic aeron_msg_t * aeron_term_msg_add(aeron_term_t * term, packet_info * pinfo, aeron_packet_info_t * info)\r\n{\r\naeron_msg_t * pos;\r\naeron_msg_t * msg;\r\npos = aeron_term_msg_find_le(term, info->term_offset);\r\nif ((pos != NULL) && (pos->first_fragment_term_offset == info->term_offset))\r\n{\r\nreturn (pos);\r\n}\r\nmsg = wmem_new0(wmem_file_scope(), aeron_msg_t);\r\nmsg->fragment = wmem_list_new(wmem_file_scope());\r\nmsg->term = term;\r\nmsg->reassembled_data = NULL;\r\nmsg->first_fragment_term_offset = info->term_offset;\r\nmsg->next_expected_term_offset = info->term_offset;\r\nmsg->length = 0;\r\nmsg->frame_length = 0;\r\nmsg->fragment_count = 0;\r\nmsg->contiguous_length = 0;\r\nmsg->begin_frame = pinfo->num;\r\nmsg->first_frame = pinfo->num;\r\nmsg->end_frame = 0;\r\nmsg->last_frame = 0;\r\nmsg->complete = FALSE;\r\nwmem_tree_insert32(term->message, msg->first_fragment_term_offset, (void *) msg);\r\nreturn (msg);\r\n}\r\nstatic void aeron_msg_process(tvbuff_t * tvb, int offset, packet_info * pinfo, aeron_transport_t * transport, aeron_packet_info_t * info, aeron_frame_info_t * finfo _U_)\r\n{\r\nif (aeron_reassemble_fragments && (PINFO_FD_VISITED(pinfo) == 0))\r\n{\r\nif ((info->flags & DATA_FLAGS_COMPLETE) != DATA_FLAGS_COMPLETE)\r\n{\r\naeron_stream_t * stream = aeron_transport_stream_find(transport, info->stream_id);\r\nif (stream != NULL)\r\n{\r\naeron_term_t * term = aeron_stream_term_find(stream, info->term_id);\r\nif (term != NULL)\r\n{\r\naeron_msg_t * msg = NULL;\r\naeron_msg_fragment_t * frag = NULL;\r\nif ((info->flags & DATA_FLAGS_BEGIN) == DATA_FLAGS_BEGIN)\r\n{\r\nmsg = aeron_term_msg_find_le(term, info->term_offset);\r\nif (msg != NULL)\r\n{\r\nif (msg->first_fragment_term_offset != info->term_offset)\r\n{\r\nmsg = NULL;\r\n}\r\n}\r\nif (msg == NULL)\r\n{\r\nmsg = aeron_term_msg_add(term, pinfo, info);\r\n}\r\n}\r\nelse\r\n{\r\nmsg = aeron_term_msg_find_le(term, info->term_offset);\r\nif (msg != NULL)\r\n{\r\nif (msg->next_expected_term_offset == info->term_offset)\r\n{\r\n}\r\nelse\r\n{\r\nfrag = aeron_msg_fragment_find(msg, info);\r\nif (frag != NULL)\r\n{\r\nreturn;\r\n}\r\nelse\r\n{\r\nmsg = NULL;\r\n}\r\n}\r\n}\r\n}\r\nfrag = aeron_msg_fragment_create(tvb, offset, pinfo, info);\r\nif (msg == NULL)\r\n{\r\nwmem_list_append(term->orphan_fragment, (void *) frag);\r\n}\r\nelse\r\n{\r\naeron_msg_fragment_add(msg, frag);\r\n}\r\naeron_msg_process_orphan_fragments(term);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic int dissect_aeron_pad(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, aeron_conversation_info_t * cinfo, aeron_frame_info_t * finfo)\r\n{\r\nproto_tree * subtree;\r\nproto_item * pad_item;\r\nproto_item * channel_item;\r\nproto_item * frame_length_item;\r\nguint32 frame_length;\r\nguint32 pad_length;\r\naeron_transport_t * transport;\r\nguint32 session_id;\r\nguint32 stream_id;\r\nguint32 term_id;\r\nguint32 term_offset;\r\nint rounded_length;\r\naeron_packet_info_t pktinfo;\r\nframe_length = tvb_get_letohl(tvb, offset + O_AERON_PAD_FRAME_LENGTH);\r\nrounded_length = (int) aeron_pos_roundup(frame_length);\r\nif (rounded_length < 0)\r\nreturn 0;\r\nterm_offset = tvb_get_letohl(tvb, offset + O_AERON_PAD_TERM_OFFSET);\r\nsession_id = tvb_get_letohl(tvb, offset + O_AERON_PAD_SESSION_ID);\r\ntransport = aeron_transport_add(cinfo, session_id, pinfo->num);\r\nstream_id = tvb_get_letohl(tvb, offset + O_AERON_PAD_STREAM_ID);\r\nterm_id = tvb_get_letohl(tvb, offset + O_AERON_PAD_TERM_ID);\r\npad_length = frame_length - L_AERON_PAD_MIN;\r\nmemset((void *) &pktinfo, 0, sizeof(aeron_packet_info_t));\r\npktinfo.stream_id = stream_id;\r\npktinfo.term_id = term_id;\r\npktinfo.term_offset = term_offset;\r\npktinfo.info_flags = AERON_PACKET_INFO_FLAGS_STREAM_ID_VALID | AERON_PACKET_INFO_FLAGS_TERM_ID_VALID | AERON_PACKET_INFO_FLAGS_TERM_OFFSET_VALID;\r\npktinfo.length = frame_length;\r\npktinfo.data_length = pad_length;\r\npktinfo.type = HDR_TYPE_PAD;\r\npktinfo.flags = tvb_get_guint8(tvb, offset + O_AERON_PAD_FLAGS);\r\nif (aeron_frame_info_setup(pinfo, transport, &pktinfo, finfo) < 0)\r\nreturn 0;\r\naeron_info_stream_progress_report(pinfo, HDR_TYPE_PAD, pktinfo.flags, term_id, term_offset, finfo);\r\npad_item = proto_tree_add_none_format(tree, hf_aeron_pad, tvb, offset, -1, "Pad Frame: Term 0x%x, Ofs %" G_GUINT32_FORMAT ", Len %" G_GUINT32_FORMAT "(%d)",\r\nterm_id, term_offset, frame_length, rounded_length);\r\nsubtree = proto_item_add_subtree(pad_item, ett_aeron_pad);\r\nchannel_item = proto_tree_add_uint64(subtree, hf_aeron_channel_id, tvb, 0, 0, transport->channel_id);\r\nPROTO_ITEM_SET_GENERATED(channel_item);\r\nframe_length_item = proto_tree_add_item(subtree, hf_aeron_pad_frame_length, tvb, offset + O_AERON_PAD_FRAME_LENGTH, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_pad_version, tvb, offset + O_AERON_PAD_VERSION, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_pad_flags, tvb, offset + O_AERON_PAD_FLAGS, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_pad_type, tvb, offset + O_AERON_PAD_TYPE, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_pad_term_offset, tvb, offset + O_AERON_PAD_TERM_OFFSET, 4, ENC_LITTLE_ENDIAN);\r\naeron_next_offset_report(tvb, subtree, transport, stream_id, term_id, term_offset, (guint32) rounded_length);\r\nproto_tree_add_item(subtree, hf_aeron_pad_session_id, tvb, offset + O_AERON_PAD_SESSION_ID, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_pad_stream_id, tvb, offset + O_AERON_PAD_STREAM_ID, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_pad_term_id, tvb, offset + O_AERON_PAD_TERM_ID, 4, ENC_LITTLE_ENDIAN);\r\naeron_sequence_report(tvb, pinfo, subtree, transport, &pktinfo, finfo);\r\naeron_stream_report(tvb, pinfo, subtree, transport, finfo);\r\nproto_item_set_len(pad_item, rounded_length);\r\nif (frame_length < L_AERON_PAD_MIN)\r\n{\r\nexpert_add_info(pinfo, frame_length_item, &ei_aeron_analysis_invalid_pad_length);\r\nreturn (-rounded_length);\r\n}\r\nreturn (rounded_length);\r\n}\r\nstatic void dissect_aeron_reassembled_data(packet_info * pinfo, proto_tree * tree, aeron_frame_info_t * finfo)\r\n{\r\nproto_item * frag_item;\r\nproto_tree * frag_tree;\r\naeron_msg_t * msg;\r\nwmem_list_frame_t * lf;\r\ngboolean first_item = TRUE;\r\nguint32 msg_ofs = 0;\r\nif (finfo->message == NULL)\r\n{\r\nreturn;\r\n}\r\nmsg = finfo->message;\r\nadd_new_data_source(pinfo, msg->reassembled_data, "Reassembled Data");\r\nfrag_item = proto_tree_add_none_format(tree,\r\nhf_aeron_data_reassembly,\r\nmsg->reassembled_data,\r\n0,\r\ntvb_reported_length_remaining(msg->reassembled_data, 0),\r\n"%" G_GUINT32_FORMAT " Reassembled Fragments (%" G_GUINT32_FORMAT " bytes):",\r\nmsg->fragment_count,\r\nmsg->length);\r\nfrag_tree = proto_item_add_subtree(frag_item, ett_aeron_data_reassembly);\r\nlf = wmem_list_head(msg->fragment);\r\nwhile (lf != NULL)\r\n{\r\naeron_msg_fragment_t * frag = (aeron_msg_fragment_t *) wmem_list_frame_data(lf);\r\nif (frag != NULL)\r\n{\r\nproto_item * pi;\r\npi = proto_tree_add_uint_format_value(frag_tree,\r\nhf_aeron_data_reassembly_fragment,\r\nmsg->reassembled_data,\r\nmsg_ofs,\r\nfrag->data_length,\r\nfrag->frame,\r\n"Frame: %" G_GUINT32_FORMAT ", payload: %" G_GUINT32_FORMAT "-%" G_GUINT32_FORMAT " (%" G_GUINT32_FORMAT " bytes)",\r\nfrag->frame,\r\nmsg_ofs,\r\n(msg_ofs + frag->data_length) - 1,\r\nfrag->data_length);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\nif (first_item)\r\n{\r\nproto_item_append_text(frag_item, " #%" G_GUINT32_FORMAT "(%" G_GUINT32_FORMAT ")", frag->frame, frag->data_length);\r\n}\r\nelse\r\n{\r\nproto_item_append_text(frag_item, ", #%" G_GUINT32_FORMAT "(%" G_GUINT32_FORMAT ")", frag->frame, frag->data_length);\r\n}\r\nmsg_ofs += frag->data_length;\r\nfirst_item = FALSE;\r\n}\r\nlf = wmem_list_frame_next(lf);\r\n}\r\nPROTO_ITEM_SET_GENERATED(frag_item);\r\n}\r\nstatic int dissect_aeron_data(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, aeron_conversation_info_t * cinfo, aeron_frame_info_t * finfo)\r\n{\r\nproto_tree * subtree;\r\nproto_item * data_item;\r\nproto_item * channel_item;\r\nproto_item * frame_length_item;\r\nguint32 frame_length;\r\nstatic const int * flags[] =\r\n{\r\n&hf_aeron_data_flags_b,\r\n&hf_aeron_data_flags_e,\r\nNULL\r\n};\r\naeron_transport_t * transport;\r\nguint32 session_id;\r\nguint32 stream_id;\r\nguint32 term_id;\r\nguint32 term_offset;\r\nguint32 data_length;\r\nint rounded_length = 0;\r\naeron_packet_info_t pktinfo;\r\nguint32 offset_increment = 0;\r\nframe_length = tvb_get_letohl(tvb, offset + O_AERON_DATA_FRAME_LENGTH);\r\nif (frame_length == 0)\r\n{\r\nrounded_length = O_AERON_DATA_DATA;\r\ndata_length = 0;\r\noffset_increment = 0;\r\n}\r\nelse\r\n{\r\noffset_increment = aeron_pos_roundup(frame_length);\r\nrounded_length = (int) offset_increment;\r\nif (rounded_length < 0)\r\nreturn 0;\r\ndata_length = frame_length - O_AERON_DATA_DATA;\r\n}\r\nterm_offset = tvb_get_letohl(tvb, offset + O_AERON_DATA_TERM_OFFSET);\r\nsession_id = tvb_get_letohl(tvb, offset + O_AERON_DATA_SESSION_ID);\r\ntransport = aeron_transport_add(cinfo, session_id, pinfo->num);\r\nstream_id = tvb_get_letohl(tvb, offset + O_AERON_DATA_STREAM_ID);\r\nterm_id = tvb_get_letohl(tvb, offset + O_AERON_DATA_TERM_ID);\r\nmemset((void *) &pktinfo, 0, sizeof(aeron_packet_info_t));\r\npktinfo.stream_id = stream_id;\r\npktinfo.term_id = term_id;\r\npktinfo.term_offset = term_offset;\r\npktinfo.info_flags = AERON_PACKET_INFO_FLAGS_STREAM_ID_VALID | AERON_PACKET_INFO_FLAGS_TERM_ID_VALID | AERON_PACKET_INFO_FLAGS_TERM_OFFSET_VALID;\r\npktinfo.length = frame_length;\r\npktinfo.data_length = data_length;\r\npktinfo.type = HDR_TYPE_DATA;\r\npktinfo.flags = tvb_get_guint8(tvb, offset + O_AERON_DATA_FLAGS);\r\nif (aeron_frame_info_setup(pinfo, transport, &pktinfo, finfo) < 0)\r\nreturn 0;\r\naeron_info_stream_progress_report(pinfo, HDR_TYPE_DATA, pktinfo.flags, term_id, term_offset, finfo);\r\ndata_item = proto_tree_add_none_format(tree, hf_aeron_data, tvb, offset, -1, "Data Frame: Term 0x%x, Ofs %" G_GUINT32_FORMAT ", Len %" G_GUINT32_FORMAT "(%d)",\r\n(guint32) term_id, term_offset, frame_length, rounded_length);\r\nsubtree = proto_item_add_subtree(data_item, ett_aeron_data);\r\nchannel_item = proto_tree_add_uint64(subtree, hf_aeron_channel_id, tvb, 0, 0, transport->channel_id);\r\nPROTO_ITEM_SET_GENERATED(channel_item);\r\nframe_length_item = proto_tree_add_item(subtree, hf_aeron_data_frame_length, tvb, offset + O_AERON_DATA_FRAME_LENGTH, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_data_version, tvb, offset + O_AERON_DATA_VERSION, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask(subtree, tvb, offset + O_AERON_DATA_FLAGS, hf_aeron_data_flags, ett_aeron_data_flags, flags, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_data_type, tvb, offset + O_AERON_DATA_TYPE, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_data_term_offset, tvb, offset + O_AERON_DATA_TERM_OFFSET, 4, ENC_LITTLE_ENDIAN);\r\naeron_next_offset_report(tvb, subtree, transport, stream_id, term_id, term_offset, offset_increment);\r\nproto_tree_add_item(subtree, hf_aeron_data_session_id, tvb, offset + O_AERON_DATA_SESSION_ID, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_data_stream_id, tvb, offset + O_AERON_DATA_STREAM_ID, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_data_term_id, tvb, offset + O_AERON_DATA_TERM_ID, 4, ENC_LITTLE_ENDIAN);\r\nif (data_length > 0)\r\n{\r\ntvbuff_t * data_tvb = NULL;\r\ngboolean can_call_subdissector = FALSE;\r\ngboolean dissector_found = FALSE;\r\nheur_dtbl_entry_t * hdtbl_entry;\r\naeron_msg_process(tvb, offset, pinfo, transport, &pktinfo, finfo);\r\nif ((pktinfo.flags & DATA_FLAGS_COMPLETE) == DATA_FLAGS_COMPLETE)\r\n{\r\ncan_call_subdissector = TRUE;\r\n}\r\nif (finfo != NULL)\r\n{\r\nif ((finfo->flags & AERON_FRAME_INFO_FLAGS_REASSEMBLED_MSG) != 0)\r\n{\r\ndissect_aeron_reassembled_data(pinfo, subtree, finfo);\r\ndata_tvb = finfo->message->reassembled_data;\r\ncan_call_subdissector = TRUE;\r\n}\r\nelse\r\n{\r\ndata_tvb = tvb_new_subset_length(tvb, offset + O_AERON_DATA_DATA, data_length);\r\n}\r\n}\r\nelse\r\n{\r\ndata_tvb = tvb_new_subset_length(tvb, offset + O_AERON_DATA_DATA, data_length);\r\n}\r\nif (can_call_subdissector && aeron_use_heuristic_subdissectors)\r\n{\r\ndissector_found = dissector_try_heuristic(aeron_heuristic_subdissector_list, data_tvb, pinfo, subtree, &hdtbl_entry, NULL);\r\n}\r\nif (!dissector_found)\r\n{\r\ncall_data_dissector(data_tvb, pinfo, subtree);\r\n}\r\n}\r\naeron_sequence_report(tvb, pinfo, subtree, transport, &pktinfo, finfo);\r\naeron_stream_report(tvb, pinfo, subtree, transport, finfo);\r\nproto_item_set_len(data_item, rounded_length);\r\nif ((frame_length != 0) && (frame_length < L_AERON_DATA_MIN))\r\n{\r\nexpert_add_info(pinfo, frame_length_item, &ei_aeron_analysis_invalid_data_length);\r\nreturn (-rounded_length);\r\n}\r\nreturn (rounded_length);\r\n}\r\nstatic int dissect_aeron_nak(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, aeron_conversation_info_t * cinfo, aeron_frame_info_t * finfo)\r\n{\r\nproto_tree * subtree;\r\nproto_item * nak_item;\r\nproto_item * frame_length_item;\r\nproto_item * channel_item;\r\nproto_item * nak_offset_item;\r\nguint32 frame_length;\r\naeron_transport_t * transport;\r\nguint32 session_id;\r\nguint32 stream_id;\r\nguint32 term_id;\r\nguint32 nak_term_offset;\r\nguint32 nak_length;\r\nint rounded_length;\r\naeron_packet_info_t pktinfo;\r\nframe_length = tvb_get_letohl(tvb, offset + O_AERON_NAK_FRAME_LENGTH);\r\nrounded_length = (int) aeron_pos_roundup(frame_length);\r\nif (rounded_length < 0)\r\nreturn 0;\r\nsession_id = tvb_get_letohl(tvb, offset + O_AERON_NAK_SESSION_ID);\r\ntransport = aeron_transport_add(cinfo, session_id, pinfo->num);\r\nstream_id = tvb_get_letohl(tvb, offset + O_AERON_NAK_STREAM_ID);\r\nterm_id = tvb_get_letohl(tvb, offset + O_AERON_NAK_TERM_ID);\r\nnak_term_offset = tvb_get_letohl(tvb, offset + O_AERON_NAK_TERM_OFFSET);\r\nnak_length = tvb_get_letohl(tvb, offset + O_AERON_NAK_LENGTH);\r\nmemset((void *) &pktinfo, 0, sizeof(aeron_packet_info_t));\r\npktinfo.stream_id = stream_id;\r\npktinfo.term_id = term_id;\r\npktinfo.info_flags = AERON_PACKET_INFO_FLAGS_STREAM_ID_VALID | AERON_PACKET_INFO_FLAGS_TERM_ID_VALID;\r\npktinfo.nak_term_offset = nak_term_offset;\r\npktinfo.nak_length = nak_length;\r\npktinfo.type = HDR_TYPE_NAK;\r\npktinfo.flags = tvb_get_guint8(tvb, offset + O_AERON_NAK_FLAGS);\r\nif (aeron_frame_info_setup(pinfo, transport, &pktinfo, finfo) < 0)\r\nreturn 0;\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, ", ", "NAK");\r\nnak_item = proto_tree_add_none_format(tree, hf_aeron_nak, tvb, offset, -1, "NAK Frame: Term 0x%x, Ofs %" G_GUINT32_FORMAT ", Len %" G_GUINT32_FORMAT,\r\nterm_id, nak_term_offset, nak_length);\r\nsubtree = proto_item_add_subtree(nak_item, ett_aeron_nak);\r\nchannel_item = proto_tree_add_uint64(subtree, hf_aeron_channel_id, tvb, 0, 0, transport->channel_id);\r\nPROTO_ITEM_SET_GENERATED(channel_item);\r\nframe_length_item = proto_tree_add_item(subtree, hf_aeron_nak_frame_length, tvb, offset + O_AERON_NAK_FRAME_LENGTH, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_nak_version, tvb, offset + O_AERON_NAK_VERSION, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_nak_flags, tvb, offset + O_AERON_NAK_FLAGS, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_nak_type, tvb, offset + O_AERON_NAK_TYPE, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_nak_session_id, tvb, offset + O_AERON_NAK_SESSION_ID, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_nak_stream_id, tvb, offset + O_AERON_NAK_STREAM_ID, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_nak_term_id, tvb, offset + O_AERON_NAK_TERM_ID, 4, ENC_LITTLE_ENDIAN);\r\nnak_offset_item = proto_tree_add_item(subtree, hf_aeron_nak_term_offset, tvb, offset + O_AERON_NAK_TERM_OFFSET, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_nak_length, tvb, offset + O_AERON_NAK_LENGTH, 4, ENC_LITTLE_ENDIAN);\r\nexpert_add_info_format(pinfo, nak_offset_item, &ei_aeron_analysis_nak, "NAK offset %" G_GUINT32_FORMAT " length %" G_GUINT32_FORMAT, nak_term_offset, nak_length);\r\naeron_sequence_report(tvb, pinfo, subtree, transport, &pktinfo, finfo);\r\nproto_item_set_len(nak_item, rounded_length);\r\nif (frame_length != L_AERON_NAK)\r\n{\r\nexpert_add_info(pinfo, frame_length_item, &ei_aeron_analysis_invalid_nak_length);\r\nreturn (-rounded_length);\r\n}\r\nreturn (rounded_length);\r\n}\r\nstatic void aeron_window_resize_report(packet_info * pinfo, proto_item * item, aeron_frame_info_t * finfo)\r\n{\r\nif (aeron_sequence_analysis && aeron_stream_analysis && (finfo != NULL) && (finfo->stream_analysis != NULL))\r\n{\r\nif ((finfo->stream_analysis->flags & AERON_STREAM_ANALYSIS_FLAGS_WINDOW_RESIZE) != 0)\r\n{\r\nexpert_add_info(pinfo, item, &ei_aeron_analysis_window_resize);\r\n}\r\n}\r\n}\r\nstatic int dissect_aeron_sm(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, aeron_conversation_info_t * cinfo, aeron_frame_info_t * finfo)\r\n{\r\nproto_tree * subtree;\r\nproto_item * sm_item;\r\nproto_item * frame_length_item;\r\nproto_item * item;\r\nproto_item * rcv_window_item;\r\nguint32 frame_length;\r\nstatic const int * flags[] =\r\n{\r\n&hf_aeron_sm_flags_s,\r\nNULL\r\n};\r\nguint32 feedback_length;\r\naeron_transport_t * transport;\r\nguint32 session_id;\r\nguint32 stream_id;\r\nguint32 term_id;\r\nguint32 consumption_offset;\r\nguint32 rcv_window;\r\nint rounded_length;\r\naeron_packet_info_t pktinfo;\r\nframe_length = tvb_get_letohl(tvb, offset + O_AERON_SM_FRAME_LENGTH);\r\nfeedback_length = frame_length - O_AERON_SM_FEEDBACK;\r\nrounded_length = (int) aeron_pos_roundup(frame_length);\r\nif (rounded_length < 0)\r\nreturn 0;\r\nsession_id = tvb_get_letohl(tvb, offset + O_AERON_SM_SESSION_ID);\r\ntransport = aeron_transport_add(cinfo, session_id, pinfo->num);\r\nstream_id = tvb_get_letohl(tvb, offset + O_AERON_SM_STREAM_ID);\r\nterm_id = tvb_get_letohl(tvb, offset + O_AERON_SM_TERM_ID);\r\nconsumption_offset = tvb_get_letohl(tvb, offset + O_AERON_SM_COMPLETED_TERM_OFFSET);\r\nrcv_window = tvb_get_letohl(tvb, offset + O_AERON_SM_RECEIVER_WINDOW);\r\nmemset((void *) &pktinfo, 0, sizeof(aeron_packet_info_t));\r\npktinfo.stream_id = stream_id;\r\npktinfo.info_flags = AERON_PACKET_INFO_FLAGS_STREAM_ID_VALID;\r\npktinfo.flags = tvb_get_guint8(tvb, offset + O_AERON_SM_FLAGS);\r\nif ((pktinfo.flags & STATUS_FLAGS_SETUP) == 0)\r\n{\r\npktinfo.term_id = term_id;\r\npktinfo.term_offset = consumption_offset;\r\npktinfo.info_flags |= (AERON_PACKET_INFO_FLAGS_TERM_ID_VALID | AERON_PACKET_INFO_FLAGS_TERM_OFFSET_VALID);\r\npktinfo.receiver_window = rcv_window;\r\n}\r\nelse\r\n{\r\npktinfo.term_id = 0;\r\npktinfo.term_offset = 0;\r\npktinfo.receiver_window = 0;\r\n}\r\npktinfo.length = 0;\r\npktinfo.data_length = 0;\r\npktinfo.type = HDR_TYPE_SM;\r\nif (aeron_frame_info_setup(pinfo, transport, &pktinfo, finfo) < 0)\r\nreturn 0;\r\naeron_info_stream_progress_report(pinfo, HDR_TYPE_SM, pktinfo.flags, term_id, consumption_offset, finfo);\r\nsm_item = proto_tree_add_none_format(tree, hf_aeron_sm, tvb, offset, -1, "Status Message: Term 0x%x, ConsumptionOfs %" G_GUINT32_FORMAT ", RcvWindow %" G_GUINT32_FORMAT,\r\nterm_id, consumption_offset, rcv_window);\r\nsubtree = proto_item_add_subtree(sm_item, ett_aeron_sm);\r\nitem = proto_tree_add_uint64(subtree, hf_aeron_channel_id, tvb, 0, 0, transport->channel_id);\r\nPROTO_ITEM_SET_GENERATED(item);\r\nframe_length_item = proto_tree_add_item(subtree, hf_aeron_sm_frame_length, tvb, offset + O_AERON_SM_FRAME_LENGTH, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_sm_version, tvb, offset + O_AERON_SM_VERSION, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask(subtree, tvb, offset + O_AERON_SM_FLAGS, hf_aeron_sm_flags, ett_aeron_sm_flags, flags, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_sm_type, tvb, offset + O_AERON_SM_TYPE, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_sm_session_id, tvb, offset + O_AERON_SM_SESSION_ID, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_sm_stream_id, tvb, offset + O_AERON_SM_STREAM_ID, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_sm_consumption_term_id, tvb, offset + O_AERON_SM_TERM_ID, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_sm_consumption_term_offset, tvb, offset + O_AERON_SM_COMPLETED_TERM_OFFSET, 4, ENC_LITTLE_ENDIAN);\r\nrcv_window_item = proto_tree_add_item(subtree, hf_aeron_sm_receiver_window, tvb, offset + O_AERON_SM_RECEIVER_WINDOW, 4, ENC_LITTLE_ENDIAN);\r\naeron_window_resize_report(pinfo, rcv_window_item, finfo);\r\nif (feedback_length > 0)\r\n{\r\nproto_tree_add_item(subtree, hf_aeron_sm_feedback, tvb, offset + O_AERON_SM_FEEDBACK, feedback_length, ENC_NA);\r\n}\r\naeron_sequence_report(tvb, pinfo, subtree, transport, &pktinfo, finfo);\r\naeron_stream_report(tvb, pinfo, subtree, transport, finfo);\r\nproto_item_set_len(sm_item, rounded_length);\r\nif (frame_length < L_AERON_SM_MIN)\r\n{\r\nexpert_add_info(pinfo, frame_length_item, &ei_aeron_analysis_invalid_sm_length);\r\nreturn (-rounded_length);\r\n}\r\nreturn (rounded_length);\r\n}\r\nstatic int dissect_aeron_err(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree)\r\n{\r\nproto_tree * subtree;\r\nproto_item * err_item;\r\nproto_item * frame_length_item;\r\nint rounded_length;\r\nguint32 bad_frame_length;\r\ngint string_length;\r\nguint32 frame_length;\r\nint ofs;\r\nframe_length = tvb_get_letohl(tvb, offset + O_AERON_ERR_FRAME_LENGTH);\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, ", ", "Error");\r\nerr_item = proto_tree_add_item(tree, hf_aeron_err, tvb, offset, -1, ENC_NA);\r\nsubtree = proto_item_add_subtree(err_item, ett_aeron_err);\r\nframe_length_item = proto_tree_add_item(subtree, hf_aeron_err_frame_length, tvb, offset + O_AERON_ERR_FRAME_LENGTH, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_err_version, tvb, offset + O_AERON_ERR_VERSION, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_err_code, tvb, offset + O_AERON_ERR_CODE, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_err_type, tvb, offset + O_AERON_ERR_TYPE, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_err_off_frame_length, tvb, offset + O_AERON_ERR_OFFENDING_FRAME_LENGTH, 4, ENC_LITTLE_ENDIAN);\r\nbad_frame_length = tvb_get_letohl(tvb, offset + O_AERON_ERR_OFFENDING_FRAME_LENGTH);\r\nofs = offset + O_AERON_ERR_OFFENDING_HEADER;\r\nproto_tree_add_item(subtree, hf_aeron_err_off_hdr, tvb, offset + ofs, bad_frame_length, ENC_NA);\r\nofs += bad_frame_length;\r\nstring_length = frame_length - ofs;\r\nif (string_length > 0)\r\n{\r\nproto_tree_add_item(subtree, hf_aeron_err_string, tvb, offset + ofs, string_length, ENC_ASCII|ENC_NA);\r\n}\r\nrounded_length = (int) aeron_pos_roundup(frame_length);\r\nif (rounded_length < 0)\r\nreturn 0;\r\nproto_item_set_len(err_item, rounded_length);\r\nif (frame_length < L_AERON_ERR_MIN)\r\n{\r\nexpert_add_info(pinfo, frame_length_item, &ei_aeron_analysis_invalid_err_length);\r\nreturn (-rounded_length);\r\n}\r\nreturn (rounded_length);\r\n}\r\nstatic void aeron_set_stream_mtu_term_length(packet_info * pinfo, aeron_transport_t * transport, guint32 stream_id, guint32 mtu, guint32 term_length)\r\n{\r\nif (PINFO_FD_VISITED(pinfo) == 0)\r\n{\r\naeron_stream_t * stream = aeron_transport_stream_find(transport, stream_id);\r\nif (stream != NULL)\r\n{\r\nstream->term_length = term_length;\r\nstream->mtu = mtu;\r\n}\r\n}\r\n}\r\nstatic int dissect_aeron_setup(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, aeron_conversation_info_t * cinfo, aeron_frame_info_t * finfo)\r\n{\r\nproto_tree * subtree;\r\nproto_item * setup_item;\r\nproto_item * frame_length_item;\r\nguint32 frame_length;\r\nproto_item * channel_item;\r\naeron_transport_t * transport;\r\nguint32 session_id;\r\nguint32 stream_id;\r\nguint32 active_term_id;\r\nguint32 initial_term_id;\r\nguint32 term_offset;\r\nguint32 term_length;\r\nguint32 mtu;\r\nint rounded_length;\r\naeron_packet_info_t pktinfo;\r\nframe_length = tvb_get_letohl(tvb, offset + O_AERON_SETUP_FRAME_LENGTH);\r\nrounded_length = (int) aeron_pos_roundup(frame_length);\r\nif (rounded_length < 0)\r\nreturn 0;\r\nterm_offset = tvb_get_letohl(tvb, offset + O_AERON_SETUP_TERM_OFFSET);\r\nsession_id = tvb_get_letohl(tvb, offset + O_AERON_SETUP_SESSION_ID);\r\ntransport = aeron_transport_add(cinfo, session_id, pinfo->num);\r\nstream_id = tvb_get_letohl(tvb, offset + O_AERON_SETUP_STREAM_ID);\r\ninitial_term_id = tvb_get_letohl(tvb, offset + O_AERON_SETUP_INITIAL_TERM_ID);\r\nactive_term_id = tvb_get_letohl(tvb, offset + O_AERON_SETUP_ACTIVE_TERM_ID);\r\nmemset((void *) &pktinfo, 0, sizeof(aeron_packet_info_t));\r\npktinfo.stream_id = stream_id;\r\npktinfo.term_id = active_term_id;\r\npktinfo.term_offset = 0;\r\npktinfo.info_flags = AERON_PACKET_INFO_FLAGS_STREAM_ID_VALID | AERON_PACKET_INFO_FLAGS_TERM_ID_VALID;\r\npktinfo.length = 0;\r\npktinfo.data_length = 0;\r\npktinfo.receiver_window = 0;\r\npktinfo.type = HDR_TYPE_SETUP;\r\npktinfo.flags = 0;\r\nif (aeron_frame_info_setup(pinfo, transport, &pktinfo, finfo) < 0)\r\nreturn 0;\r\nterm_length = tvb_get_letohl(tvb, offset + O_AERON_SETUP_TERM_LENGTH);\r\nmtu = tvb_get_letohl(tvb, offset + O_AERON_SETUP_MTU);\r\naeron_set_stream_mtu_term_length(pinfo, transport, stream_id, mtu, term_length);\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, ", ", "Setup");\r\nsetup_item = proto_tree_add_none_format(tree, hf_aeron_setup, tvb, offset, -1, "Setup Frame: InitTerm 0x%x, ActiveTerm 0x%x, TermLen %" G_GUINT32_FORMAT ", Ofs %" G_GUINT32_FORMAT ", MTU %" G_GUINT32_FORMAT,\r\ninitial_term_id, (guint32) active_term_id, term_length, term_offset, mtu);\r\nsubtree = proto_item_add_subtree(setup_item, ett_aeron_setup);\r\nchannel_item = proto_tree_add_uint64(subtree, hf_aeron_channel_id, tvb, 0, 0, transport->channel_id);\r\nPROTO_ITEM_SET_GENERATED(channel_item);\r\nframe_length_item = proto_tree_add_item(subtree, hf_aeron_setup_frame_length, tvb, offset + O_AERON_SETUP_FRAME_LENGTH, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_setup_version, tvb, offset + O_AERON_SETUP_VERSION, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_setup_flags, tvb, offset + O_AERON_SETUP_FLAGS, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_setup_type, tvb, offset + O_AERON_SETUP_TYPE, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_setup_term_offset, tvb, offset + O_AERON_SETUP_TERM_OFFSET, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_setup_session_id, tvb, offset + O_AERON_SETUP_SESSION_ID, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_setup_stream_id, tvb, offset + O_AERON_SETUP_STREAM_ID, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_setup_initial_term_id, tvb, offset + O_AERON_SETUP_INITIAL_TERM_ID, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_setup_active_term_id, tvb, offset + O_AERON_SETUP_ACTIVE_TERM_ID, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_setup_term_length, tvb, offset + O_AERON_SETUP_TERM_LENGTH, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_aeron_setup_mtu, tvb, offset + O_AERON_SETUP_MTU, 4, ENC_LITTLE_ENDIAN);\r\naeron_sequence_report(tvb, pinfo, subtree, transport, &pktinfo, finfo);\r\nproto_item_set_len(setup_item, rounded_length);\r\nif (frame_length != L_AERON_SETUP)\r\n{\r\nexpert_add_info(pinfo, frame_length_item, &ei_aeron_analysis_invalid_setup_length);\r\nreturn (-rounded_length);\r\n}\r\nreturn (rounded_length);\r\n}\r\nstatic int dissect_aeron(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * user_data _U_)\r\n{\r\nint total_dissected_length = 0;\r\nguint16 frame_type;\r\nproto_tree * aeron_tree;\r\nproto_item * aeron_item;\r\nint dissected_length = 0;\r\nint offset = 0;\r\nint length_remaining;\r\naeron_conversation_info_t * cinfo;\r\nif (tvb_captured_length_remaining(tvb, offset) < 2)\r\nreturn 0;\r\nframe_type = tvb_get_letohs(tvb, offset + O_AERON_BASIC_TYPE);\r\ncinfo = aeron_setup_conversation_info(pinfo, frame_type);\r\nif (!cinfo)\r\nreturn 0;\r\ncol_add_str(pinfo->cinfo, COL_PROTOCOL, "Aeron");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ncol_add_str(pinfo->cinfo, COL_INFO, aeron_format_transport_uri(cinfo));\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\nlength_remaining = tvb_reported_length(tvb);\r\naeron_item = proto_tree_add_protocol_format(tree, proto_aeron, tvb, offset, -1, "Aeron Protocol");\r\naeron_tree = proto_item_add_subtree(aeron_item, ett_aeron);\r\nwhile (length_remaining > 0)\r\n{\r\naeron_frame_info_t * finfo = NULL;\r\nif (aeron_sequence_analysis)\r\n{\r\nfinfo = aeron_frame_info_add(pinfo->num, (guint32) offset);\r\n}\r\nframe_type = tvb_get_letohs(tvb, offset + O_AERON_BASIC_TYPE);\r\ncinfo = aeron_setup_conversation_info(pinfo, frame_type);\r\nswitch (frame_type)\r\n{\r\ncase HDR_TYPE_PAD:\r\ndissected_length = dissect_aeron_pad(tvb, offset, pinfo, aeron_tree, cinfo, finfo);\r\nbreak;\r\ncase HDR_TYPE_DATA:\r\ndissected_length = dissect_aeron_data(tvb, offset, pinfo, aeron_tree, cinfo, finfo);\r\nbreak;\r\ncase HDR_TYPE_NAK:\r\ndissected_length = dissect_aeron_nak(tvb, offset, pinfo, aeron_tree, cinfo, finfo);\r\nbreak;\r\ncase HDR_TYPE_SM:\r\ndissected_length = dissect_aeron_sm(tvb, offset, pinfo, aeron_tree, cinfo, finfo);\r\nbreak;\r\ncase HDR_TYPE_ERR:\r\ndissected_length = dissect_aeron_err(tvb, offset, pinfo, aeron_tree);\r\nbreak;\r\ncase HDR_TYPE_SETUP:\r\ndissected_length = dissect_aeron_setup(tvb, offset, pinfo, aeron_tree, cinfo, finfo);\r\nbreak;\r\ncase HDR_TYPE_EXT:\r\ndefault:\r\nreturn (total_dissected_length);\r\n}\r\nif (dissected_length <= 0)\r\n{\r\ntotal_dissected_length += -dissected_length;\r\nproto_item_set_len(aeron_item, total_dissected_length);\r\nreturn (total_dissected_length);\r\n}\r\ntotal_dissected_length += dissected_length;\r\noffset += dissected_length;\r\nlength_remaining -= dissected_length;\r\nproto_item_set_len(aeron_item, total_dissected_length);\r\n}\r\nreturn (total_dissected_length);\r\n}\r\nstatic gboolean test_aeron_packet(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * user_data)\r\n{\r\nguint8 ver;\r\nguint16 packet_type;\r\ngint length;\r\ngint length_remaining;\r\nint rc;\r\nlength_remaining = tvb_captured_length_remaining(tvb, 0);\r\nif (length_remaining < HDR_LENGTH_MIN)\r\n{\r\nreturn (FALSE);\r\n}\r\nver = tvb_get_guint8(tvb, O_AERON_BASIC_VERSION);\r\nif (ver != 0)\r\n{\r\nreturn (FALSE);\r\n}\r\npacket_type = tvb_get_letohs(tvb, O_AERON_BASIC_TYPE);\r\nswitch (packet_type)\r\n{\r\ncase HDR_TYPE_PAD:\r\ncase HDR_TYPE_DATA:\r\ncase HDR_TYPE_NAK:\r\ncase HDR_TYPE_SM:\r\ncase HDR_TYPE_ERR:\r\ncase HDR_TYPE_SETUP:\r\ncase HDR_TYPE_EXT:\r\nbreak;\r\ndefault:\r\nreturn (FALSE);\r\n}\r\nlength = (gint) (tvb_get_letohl(tvb, O_AERON_BASIC_FRAME_LENGTH) & 0x7fffffff);\r\nif (!((packet_type == HDR_TYPE_DATA) && (length == 0)))\r\n{\r\nif (length < HDR_LENGTH_MIN)\r\n{\r\nreturn (FALSE);\r\n}\r\n}\r\nif (packet_type == HDR_TYPE_PAD)\r\n{\r\nguint32 term_offset = tvb_get_letohl(tvb, O_AERON_PAD_TERM_OFFSET);\r\nif (term_offset == 0)\r\n{\r\nreturn (FALSE);\r\n}\r\n}\r\nelse\r\n{\r\nif (length > length_remaining)\r\n{\r\nreturn (FALSE);\r\n}\r\n}\r\nrc = dissect_aeron(tvb, pinfo, tree, user_data);\r\nif (rc == 0)\r\n{\r\nreturn (FALSE);\r\n}\r\nreturn (TRUE);\r\n}\r\nstatic void aeron_init(void)\r\n{\r\naeron_channel_id_init();\r\n}\r\nvoid proto_register_aeron(void)\r\n{\r\nstatic hf_register_info hf[] =\r\n{\r\n{ &hf_aeron_channel_id,\r\n{ "Channel ID", "aeron.channel_id", FT_UINT64, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_pad,\r\n{ "Pad Frame", "aeron.pad", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_pad_frame_length,\r\n{ "Frame Length", "aeron.pad.frame_length", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_pad_version,\r\n{ "Version", "aeron.pad.version", FT_UINT8, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_pad_flags,\r\n{ "Flags", "aeron.pad.flags", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_pad_type,\r\n{ "Type", "aeron.pad.type", FT_UINT16, BASE_DEC_HEX, VALS(aeron_frame_type), 0x0, NULL, HFILL } },\r\n{ &hf_aeron_pad_term_offset,\r\n{ "Term Offset", "aeron.pad.term_offset", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_pad_session_id,\r\n{ "Session ID", "aeron.pad.session_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_pad_stream_id,\r\n{ "Stream ID", "aeron.pad.stream_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_pad_term_id,\r\n{ "Term ID", "aeron.pad.term_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_data,\r\n{ "Data Frame", "aeron.data", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_data_frame_length,\r\n{ "Frame Length", "aeron.data.frame_length", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_data_version,\r\n{ "Version", "aeron.data.version", FT_UINT8, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_data_flags,\r\n{ "Flags", "aeron.data.flags", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_data_flags_b,\r\n{ "Begin Message", "aeron.data.flags.b", FT_BOOLEAN, 8, TFS(&tfs_set_notset), DATA_FLAGS_BEGIN, NULL, HFILL } },\r\n{ &hf_aeron_data_flags_e,\r\n{ "End Message", "aeron.data.flags.e", FT_BOOLEAN, 8, TFS(&tfs_set_notset), DATA_FLAGS_END, NULL, HFILL } },\r\n{ &hf_aeron_data_type,\r\n{ "Type", "aeron.data.type", FT_UINT16, BASE_DEC_HEX, VALS(aeron_frame_type), 0x0, NULL, HFILL } },\r\n{ &hf_aeron_data_term_offset,\r\n{ "Term Offset", "aeron.data.term_offset", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_data_next_offset,\r\n{ "Next Offset", "aeron.data.next_offset", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_data_next_offset_term,\r\n{ "Next Offset Term", "aeron.data.next_offset_term", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_data_next_offset_first_frame,\r\n{ "Next Offset First Frame", "aeron.data.next_offset_first_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_data_session_id,\r\n{ "Session ID", "aeron.data.session_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_data_stream_id,\r\n{ "Stream ID", "aeron.data.stream_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_data_term_id,\r\n{ "Term ID", "aeron.data.term_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_data_reassembly,\r\n{ "Reassembled Fragments", "aeron.data.reassembly", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_data_reassembly_fragment,\r\n{ "Fragment", "aeron.data.reassembly.fragment", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_nak,\r\n{ "NAK Frame", "aeron.nak", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_nak_frame_length,\r\n{ "Frame Length", "aeron.nak.frame_length", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_nak_version,\r\n{ "Version", "aeron.nak.version", FT_UINT8, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_nak_flags,\r\n{ "Flags", "aeron.nak.flags", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_nak_type,\r\n{ "Type", "aeron.nak.type", FT_UINT16, BASE_DEC_HEX, VALS(aeron_frame_type), 0x0, NULL, HFILL } },\r\n{ &hf_aeron_nak_session_id,\r\n{ "Session ID", "aeron.nak.session_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_nak_stream_id,\r\n{ "Stream ID", "aeron.nak.stream_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_nak_term_id,\r\n{ "Term ID", "aeron.nak.term_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_nak_term_offset,\r\n{ "Term Offset", "aeron.nak.term_offset", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_nak_length,\r\n{ "Length", "aeron.nak.length", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sm,\r\n{ "Status Message", "aeron.sm", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sm_frame_length,\r\n{ "Frame Length", "aeron.sm.frame_length", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sm_version,\r\n{ "Version", "aeron.sm.version", FT_UINT8, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sm_flags,\r\n{ "Flags", "aeron.sm.flags", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sm_flags_s,\r\n{ "Setup", "aeron.sm.flags.s", FT_BOOLEAN, 8, TFS(&tfs_set_notset), STATUS_FLAGS_SETUP, NULL, HFILL } },\r\n{ &hf_aeron_sm_type,\r\n{ "Type", "aeron.sm.type", FT_UINT16, BASE_DEC_HEX, VALS(aeron_frame_type), 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sm_session_id,\r\n{ "Session ID", "aeron.sm.session_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sm_stream_id,\r\n{ "Stream ID", "aeron.sm.stream_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sm_consumption_term_id,\r\n{ "Consumption Term ID", "aeron.sm.consumption_term_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sm_consumption_term_offset,\r\n{ "Consumption Term Offset", "aeron.sm.consumption_term_offset", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sm_receiver_window,\r\n{ "Receiver Window", "aeron.sm.receiver_window", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sm_feedback,\r\n{ "Application-specific Feedback", "aeron.sm.feedback", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_err,\r\n{ "Error Header", "aeron.err", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_err_frame_length,\r\n{ "Frame Length", "aeron.err.frame_length", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_err_version,\r\n{ "Version", "aeron.err.version", FT_UINT8, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_err_code,\r\n{ "Error Code", "aeron.err.code", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_err_type,\r\n{ "Type", "aeron.err.type", FT_UINT16, BASE_DEC_HEX, VALS(aeron_frame_type), 0x0, NULL, HFILL } },\r\n{ &hf_aeron_err_off_frame_length,\r\n{ "Offending Frame Length", "aeron.err.off_frame_length", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_err_off_hdr,\r\n{ "Offending Header", "aeron.err.off_hdr", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_err_string,\r\n{ "Error String", "aeron.err.string", FT_STRINGZ, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_setup,\r\n{ "Setup Frame", "aeron.setup", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_setup_frame_length,\r\n{ "Frame Length", "aeron.setup.frame_length", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_setup_version,\r\n{ "Version", "aeron.setup.version", FT_UINT8, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_setup_flags,\r\n{ "Flags", "aeron.setup.flags", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_setup_type,\r\n{ "Type", "aeron.setup.type", FT_UINT16, BASE_DEC_HEX, VALS(aeron_frame_type), 0x0, NULL, HFILL } },\r\n{ &hf_aeron_setup_term_offset,\r\n{ "Term Offset", "aeron.setup.term_offset", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_setup_session_id,\r\n{ "Session ID", "aeron.setup.session_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_setup_stream_id,\r\n{ "Stream ID", "aeron.setup.stream_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_setup_initial_term_id,\r\n{ "Initial Term ID", "aeron.setup.initial_term_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_setup_active_term_id,\r\n{ "Active Term ID", "aeron.setup.active_term_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_setup_term_length,\r\n{ "Term Length", "aeron.setup.term_length", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_setup_mtu,\r\n{ "MTU", "aeron.setup.mtu", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sequence_analysis,\r\n{ "Sequence Analysis", "aeron.sequence_analysis", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sequence_analysis_channel_prev_frame,\r\n{ "Previous Channel Frame", "aeron.sequence_analysis.prev_channel_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sequence_analysis_channel_next_frame,\r\n{ "Next Channel Frame", "aeron.sequence_analysis.next_channel_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sequence_analysis_stream_prev_frame,\r\n{ "Previous Stream Frame", "aeron.sequence_analysis.prev_stream_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sequence_analysis_stream_next_frame,\r\n{ "Next Stream Frame", "aeron.sequence_analysis.next_stream_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sequence_analysis_term_prev_frame,\r\n{ "Previous Term Frame", "aeron.sequence_analysis.prev_term_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sequence_analysis_term_next_frame,\r\n{ "Next Term Frame", "aeron.sequence_analysis.next_term_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sequence_analysis_term_offset,\r\n{ "Offset also in", "aeron.sequence_analysis.term_offset", FT_NONE, BASE_NONE, NULL, 0x0, "Offset also appears in these frames", HFILL } },\r\n{ &hf_aeron_sequence_analysis_term_offset_frame,\r\n{ "Frame", "aeron.sequence_analysis.term_offset.frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sequence_analysis_retransmission,\r\n{ "Frame is a retransmission", "aeron.sequence_analysis.retransmission", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sequence_analysis_retransmission_rx,\r\n{ "List of NAK frames to which this retransmission applies", "aeron.sequence_analysis.retransmission.rx", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sequence_analysis_retransmission_rx_frame,\r\n{ "Retransmission applies to frame", "aeron.sequence_analysis.retransmission.rx.frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sequence_analysis_nak_unrecovered,\r\n{ "Unrecovered Bytes", "aeron.sequence_analysis.nak_unrecovered", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sequence_analysis_nak_rx,\r\n{ "List of RX Frames for this NAK", "aeron.sequence_analysis.nak_rx", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sequence_analysis_nak_rx_frame,\r\n{ "RX Frame for this NAK", "aeron.sequence_analysis.nak_rx.frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_sequence_analysis_keepalive,\r\n{ "Frame is a keepalive", "aeron.sequence_analysis.keepalive", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_stream_analysis,\r\n{ "Stream Analysis", "aeron.stream_analysis", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_stream_analysis_high_term_id,\r\n{ "Highest sent term ID", "aeron.stream_analysis.high_term_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_stream_analysis_high_term_offset,\r\n{ "Highest sent term offset", "aeron.stream_analysis.high_term_offset", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_stream_analysis_completed_term_id,\r\n{ "Completed term ID", "aeron.stream_analysis.completed_term_id", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_stream_analysis_completed_term_offset,\r\n{ "Completed term offset", "aeron.stream_analysis.completed_term_offset", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_aeron_stream_analysis_outstanding_bytes,\r\n{ "Outstanding bytes", "aeron.stream_analysis.outstanding_bytes", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } }\r\n};\r\nstatic gint * ett[] =\r\n{\r\n&ett_aeron,\r\n&ett_aeron_pad,\r\n&ett_aeron_data,\r\n&ett_aeron_data_flags,\r\n&ett_aeron_data_reassembly,\r\n&ett_aeron_nak,\r\n&ett_aeron_sm,\r\n&ett_aeron_sm_flags,\r\n&ett_aeron_err,\r\n&ett_aeron_setup,\r\n&ett_aeron_ext,\r\n&ett_aeron_sequence_analysis,\r\n&ett_aeron_sequence_analysis_retransmission_rx,\r\n&ett_aeron_sequence_analysis_nak_rx,\r\n&ett_aeron_sequence_analysis_term_offset,\r\n&ett_aeron_stream_analysis\r\n};\r\nstatic ei_register_info ei[] =\r\n{\r\n{ &ei_aeron_analysis_nak, { "aeron.analysis.nak", PI_SEQUENCE, PI_NOTE, "NAK", EXPFILL } },\r\n{ &ei_aeron_analysis_window_full, { "aeron.analysis.window_full", PI_SEQUENCE, PI_NOTE, "Receiver window is full", EXPFILL } },\r\n{ &ei_aeron_analysis_idle_rx, { "aeron.analysis.idle_rx", PI_SEQUENCE, PI_NOTE, "This frame contains an Idle RX", EXPFILL } },\r\n{ &ei_aeron_analysis_pacing_rx, { "aeron.analysis.pacing_rx", PI_SEQUENCE, PI_NOTE, "This frame contains a Pacing RX", EXPFILL } },\r\n{ &ei_aeron_analysis_ooo, { "aeron.analysis.ooo", PI_SEQUENCE, PI_NOTE, "This frame contains Out-of-order data", EXPFILL } },\r\n{ &ei_aeron_analysis_ooo_gap, { "aeron.analysis.ooo_gap", PI_SEQUENCE, PI_NOTE, "This frame is an Out-of-order gap", EXPFILL } },\r\n{ &ei_aeron_analysis_keepalive, { "aeron.analysis.keepalive", PI_SEQUENCE, PI_NOTE, "This frame contains a Keepalive", EXPFILL } },\r\n{ &ei_aeron_analysis_window_resize, { "aeron.analysis.window_resize", PI_SEQUENCE, PI_NOTE, "Receiver window resized", EXPFILL } },\r\n{ &ei_aeron_analysis_ooo_sm, { "aeron.analysis.ooo_sm", PI_SEQUENCE, PI_NOTE, "This frame contains an Out-of-order SM", EXPFILL } },\r\n{ &ei_aeron_analysis_keepalive_sm, { "aeron.analysis.keepalive_sm", PI_SEQUENCE, PI_NOTE, "This frame contains a Keepalive SM", EXPFILL } },\r\n{ &ei_aeron_analysis_rx, { "aeron.analysis.rx", PI_SEQUENCE, PI_NOTE, "This frame contains a (likely) retransmission", EXPFILL } },\r\n{ &ei_aeron_analysis_term_id_change, { "aeron.analysis.term_id_change", PI_SEQUENCE, PI_CHAT, "This frame contains a new term ID", EXPFILL } },\r\n{ &ei_aeron_analysis_invalid_pad_length, { "aeron.analysis.invalid_pad_length", PI_MALFORMED, PI_ERROR, "Invalid pad frame length", EXPFILL } },\r\n{ &ei_aeron_analysis_invalid_data_length, { "aeron.analysis.invalid_data_length", PI_MALFORMED, PI_ERROR, "Invalid data frame length", EXPFILL } },\r\n{ &ei_aeron_analysis_invalid_nak_length, { "aeron.analysis.invalid_nak_length", PI_MALFORMED, PI_ERROR, "Invalid NAK frame length", EXPFILL } },\r\n{ &ei_aeron_analysis_invalid_sm_length, { "aeron.analysis.invalid_sm_length", PI_MALFORMED, PI_ERROR, "Invalid SM frame length", EXPFILL } },\r\n{ &ei_aeron_analysis_invalid_err_length, { "aeron.analysis.invalid_err_length", PI_MALFORMED, PI_ERROR, "Invalid error frame length", EXPFILL } },\r\n{ &ei_aeron_analysis_invalid_setup_length, { "aeron.analysis.invalid_setup_length", PI_MALFORMED, PI_ERROR, "Invalid setup frame length", EXPFILL } }\r\n};\r\nmodule_t * aeron_module;\r\nexpert_module_t * expert_aeron;\r\nproto_aeron = proto_register_protocol("Aeron Protocol", "Aeron", "aeron");\r\nproto_register_field_array(proto_aeron, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_aeron = expert_register_protocol(proto_aeron);\r\nexpert_register_field_array(expert_aeron, ei, array_length(ei));\r\naeron_module = prefs_register_protocol(proto_aeron, proto_reg_handoff_aeron);\r\naeron_heuristic_subdissector_list = register_heur_dissector_list("aeron_msg_payload", proto_aeron);\r\nprefs_register_bool_preference(aeron_module,\r\n"sequence_analysis",\r\n"Analyze transport sequencing",\r\n"Include next/previous frame for channel, stream, and term, and other transport sequence analysis.",\r\n&aeron_sequence_analysis);\r\nprefs_register_bool_preference(aeron_module,\r\n"stream_analysis",\r\n"Analyze stream sequencing",\r\n"Include stream analysis, tracking publisher and subscriber positions. Requires \"Analyze transport sequencing\".",\r\n&aeron_stream_analysis);\r\nprefs_register_bool_preference(aeron_module,\r\n"reassemble_fragments",\r\n"Reassemble fragmented data",\r\n"Reassemble fragmented data messages. Requires \"Analyze transport sequencing\" and \"Analyze stream sequencing\".",\r\n&aeron_reassemble_fragments);\r\nprefs_register_bool_preference(aeron_module,\r\n"use_heuristic_subdissectors",\r\n"Use heuristic sub-dissectors",\r\n"Use a registered heuristic sub-dissector to decode the payload data. Requires \"Analyze transport sequencing\", \"Analyze stream sequencing\", and \"Reassemble fragmented data\".",\r\n&aeron_use_heuristic_subdissectors);\r\nregister_init_routine(aeron_init);\r\naeron_frame_info_tree = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\n}\r\nvoid proto_reg_handoff_aeron(void)\r\n{\r\naeron_dissector_handle = create_dissector_handle(dissect_aeron, proto_aeron);\r\ndissector_add_for_decode_as("udp.port", aeron_dissector_handle);\r\nheur_dissector_add("udp", test_aeron_packet, "Aeron over UDP", "aeron_udp", proto_aeron, HEURISTIC_DISABLE);\r\n}
