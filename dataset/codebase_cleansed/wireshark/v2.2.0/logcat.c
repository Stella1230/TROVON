static gchar get_priority(const guint8 priority) {\r\nstatic gchar priorities[] = "??VDIWEFS";\r\nif (priority >= (guint8) sizeof(priorities))\r\nreturn '?';\r\nreturn priorities[priority];\r\n}\r\nstatic gint detect_version(FILE_T fh, int *err, gchar **err_info)\r\n{\r\nguint16 payload_length;\r\nguint16 hdr_size;\r\nguint16 read_sofar;\r\nguint16 entry_len;\r\ngint version;\r\nstruct logger_entry *log_entry;\r\nstruct logger_entry_v2 *log_entry_v2;\r\nguint8 *buffer;\r\nguint16 tmp;\r\nguint8 *msg_payload;\r\nguint8 *msg_part;\r\nguint8 *msg_end;\r\nguint16 msg_len;\r\nif (!wtap_read_bytes_or_eof(fh, &tmp, 2, err, err_info)) {\r\nif (*err == 0) {\r\nreturn -2;\r\n}\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn -1;\r\nreturn 0;\r\n}\r\npayload_length = pletoh16(&tmp);\r\nif (payload_length < 3)\r\nreturn 0;\r\nif (payload_length > LOGGER_ENTRY_MAX_PAYLOAD)\r\nreturn 0;\r\nif (!wtap_read_bytes(fh, &tmp, 2, err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nhdr_size = pletoh16(&tmp);\r\nread_sofar = 4;\r\nbuffer = (guint8 *) g_malloc(sizeof(*log_entry_v2) + payload_length);\r\nlog_entry_v2 = (struct logger_entry_v2 *)(void *) buffer;\r\nlog_entry = (struct logger_entry *)(void *) buffer;\r\nfor (version = 1; version <= 2; ++version) {\r\nif (version == 1) {\r\nmsg_payload = (guint8 *) (log_entry + 1);\r\nentry_len = sizeof(*log_entry) + payload_length;\r\n} else if (version == 2) {\r\nmsg_payload = (guint8 *) (log_entry_v2 + 1);\r\nentry_len = sizeof(*log_entry_v2) + payload_length;\r\nif (hdr_size != sizeof(*log_entry_v2))\r\ncontinue;\r\n} else {\r\ncontinue;\r\n}\r\nif (!wtap_read_bytes(fh, buffer + read_sofar, entry_len - read_sofar, err, err_info)) {\r\ng_free(buffer);\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nread_sofar += entry_len - read_sofar;\r\nif (get_priority(msg_payload[0]) == '?')\r\ncontinue;\r\nmsg_part = (guint8 *) memchr(msg_payload, '\0', payload_length - 1);\r\nif (msg_part == NULL)\r\ncontinue;\r\n++msg_part;\r\nmsg_len = (guint16)(payload_length - (msg_part - msg_payload));\r\nmsg_end = (guint8 *) memchr(msg_part, '\0', msg_len);\r\nif (msg_end && (msg_payload + payload_length - 1 != msg_end))\r\ncontinue;\r\ng_free(buffer);\r\nreturn version;\r\n}\r\ng_free(buffer);\r\nreturn 0;\r\n}\r\ngint logcat_exported_pdu_length(const guint8 *pd) {\r\nconst guint16 *tag;\r\nconst guint16 *tag_length;\r\ngint length = 0;\r\ntag = (const guint16 *)(const void *) pd;\r\nwhile(GINT16_FROM_BE(*tag)) {\r\ntag_length = (const guint16 *)(const void *) (pd + 2);\r\nlength += 2 + 2 + GINT16_FROM_BE(*tag_length);\r\npd += 2 + 2 + GINT16_FROM_BE(*tag_length);\r\ntag = (const guint16 *)(const void *) pd;\r\n}\r\nlength += 2 + 2;\r\nreturn length;\r\n}\r\nstatic gboolean logcat_read_packet(struct logcat_phdr *logcat, FILE_T fh,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\ngint packet_size;\r\nguint16 payload_length;\r\nguint tmp[2];\r\nguint8 *pd;\r\nstruct logger_entry *log_entry;\r\nif (!wtap_read_bytes_or_eof(fh, &tmp, 2, err, err_info)) {\r\nreturn FALSE;\r\n}\r\npayload_length = pletoh16(tmp);\r\nif (logcat->version == 1) {\r\npacket_size = (gint)sizeof(struct logger_entry) + payload_length;\r\n} else if (logcat->version == 2) {\r\npacket_size = (gint)sizeof(struct logger_entry_v2) + payload_length;\r\n} else {\r\nreturn FALSE;\r\n}\r\nws_buffer_assure_space(buf, packet_size);\r\npd = ws_buffer_start_ptr(buf);\r\nlog_entry = (struct logger_entry *)(void *) pd;\r\nmemcpy(pd, tmp, 2);\r\nif (!wtap_read_bytes(fh, pd + 2, packet_size - 2, err, err_info)) {\r\nreturn FALSE;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS;\r\nphdr->ts.secs = (time_t) GINT32_FROM_LE(log_entry->sec);\r\nphdr->ts.nsecs = GINT32_FROM_LE(log_entry->nsec);\r\nphdr->caplen = packet_size;\r\nphdr->len = packet_size;\r\nphdr->pseudo_header.logcat.version = logcat->version;\r\nreturn TRUE;\r\n}\r\nstatic gboolean logcat_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\n*data_offset = file_tell(wth->fh);\r\nreturn logcat_read_packet((struct logcat_phdr *) wth->priv, wth->fh,\r\n&wth->phdr, wth->frame_buffer, err, err_info);\r\n}\r\nstatic gboolean logcat_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf,\r\nint *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (!logcat_read_packet((struct logcat_phdr *) wth->priv, wth->random_fh,\r\nphdr, buf, err, err_info)) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nwtap_open_return_val logcat_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\ngint version;\r\ngint tmp_version;\r\nstruct logcat_phdr *logcat;\r\nversion = detect_version(wth->fh, err, err_info);\r\nif (version == -1)\r\nreturn WTAP_OPEN_ERROR;\r\nif (version == 0)\r\nreturn WTAP_OPEN_NOT_MINE;\r\nif (version == -2)\r\nreturn WTAP_OPEN_NOT_MINE;\r\ntmp_version = detect_version(wth->fh, err, err_info);\r\nif (tmp_version == -1)\r\nreturn WTAP_OPEN_ERROR;\r\nif (tmp_version == 0)\r\nreturn WTAP_OPEN_NOT_MINE;\r\nif (tmp_version != -2) {\r\nif (tmp_version != version) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\ntmp_version = detect_version(wth->fh, err, err_info);\r\nif (tmp_version < 0)\r\nreturn WTAP_OPEN_ERROR;\r\nif (tmp_version == 0)\r\nreturn WTAP_OPEN_NOT_MINE;\r\nif (tmp_version != -2) {\r\nif (tmp_version != version) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\n}\r\n}\r\nif (file_seek(wth->fh, 0, SEEK_SET, err) == -1)\r\nreturn WTAP_OPEN_ERROR;\r\nlogcat = (struct logcat_phdr *) g_malloc(sizeof(struct logcat_phdr));\r\nlogcat->version = version;\r\nwth->priv = logcat;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_LOGCAT;\r\nwth->file_encap = WTAP_ENCAP_LOGCAT;\r\nwth->snapshot_length = 0;\r\nwth->subtype_read = logcat_read;\r\nwth->subtype_seek_read = logcat_seek_read;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nint logcat_dump_can_write_encap(int encap)\r\n{\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nif (encap != WTAP_ENCAP_LOGCAT && encap != WTAP_ENCAP_WIRESHARK_UPPER_PDU)\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\nreturn 0;\r\n}\r\nstatic gboolean logcat_binary_dump(wtap_dumper *wdh,\r\nconst struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info _U_)\r\n{\r\nint caplen;\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\ncaplen = phdr->caplen;\r\nif (wdh->encap == WTAP_ENCAP_WIRESHARK_UPPER_PDU) {\r\ngint skipped_length;\r\nskipped_length = logcat_exported_pdu_length(pd);\r\npd += skipped_length;\r\ncaplen -= skipped_length;\r\n}\r\nif (!wtap_dump_file_write(wdh, pd, caplen, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += caplen;\r\nreturn TRUE;\r\n}\r\ngboolean logcat_binary_dump_open(wtap_dumper *wdh, int *err)\r\n{\r\nwdh->subtype_write = logcat_binary_dump;\r\nswitch (wdh->encap) {\r\ncase WTAP_ENCAP_LOGCAT:\r\ncase WTAP_ENCAP_WIRESHARK_UPPER_PDU:\r\nwdh->tsprecision = WTAP_TSPREC_USEC;\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_UNWRITABLE_FILE_TYPE;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}
