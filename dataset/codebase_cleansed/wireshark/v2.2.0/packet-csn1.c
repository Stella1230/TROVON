static guint8\r\ntvb_get_masked_bits8(tvbuff_t *tvb, gint bit_offset, const gint no_of_bits)\r\n{\r\nstatic const guint8 maskBits[] = {0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF};\r\ngint byte_offset = bit_offset >> 3;\r\ngint relative_bit_offset = bit_offset & 0x07;\r\nguint8 result;\r\ngint bit_shift = 8 - relative_bit_offset - (gint) no_of_bits;\r\nif (bit_shift >= 0)\r\n{\r\nresult = (0x2B ^ tvb_get_guint8(tvb, byte_offset)) >> bit_shift;\r\nresult &= maskBits[no_of_bits];\r\n}\r\nelse\r\n{\r\nguint8 hight_part = (0x2B ^ tvb_get_guint8(tvb, byte_offset)) & maskBits[8 - relative_bit_offset];\r\nhight_part = (guint8) (hight_part << (-bit_shift));\r\nresult = (0x2B ^ tvb_get_guint8(tvb, byte_offset+1)) >> (8 + bit_shift);\r\nresult |= hight_part;\r\n}\r\nreturn result;\r\n}\r\nvoid\r\ncsnStreamInit(csnStream_t* ar, gint bit_offset, gint remaining_bits_len, packet_info* pinfo)\r\n{\r\nar->remaining_bits_len = remaining_bits_len;\r\nar->bit_offset = bit_offset;\r\nar->pinfo = pinfo;\r\n}\r\nstatic gint16\r\nProcessError(proto_tree *tree, packet_info* pinfo, tvbuff_t *tvb, gint bit_offset, gint16 err, expert_field* err_field, const CSN_DESCR* pDescr)\r\n{\r\nif (err_field != NULL)\r\nproto_tree_add_expert_format(tree, pinfo, err_field, tvb, bit_offset>>3, 1, "%s (%s)", expert_get_summary(err_field), pDescr?pDescr->sz:"-");\r\nreturn err;\r\n}\r\nstatic gboolean\r\nexistNextElement(tvbuff_t *tvb, gint bit_offset, guint8 Tag)\r\n{\r\nguint8 res = tvb_get_bits8(tvb, bit_offset, 1);\r\nif (Tag == STANDARD_TAG)\r\n{\r\nreturn (res > 0);\r\n}\r\nreturn (res == 0);\r\n}\r\ngint16\r\ncsnStreamDissector(proto_tree *tree, csnStream_t* ar, const CSN_DESCR* pDescr, tvbuff_t *tvb, void* data, int ett_csn1)\r\n{\r\ngint remaining_bits_len = ar->remaining_bits_len;\r\ngint bit_offset = ar->bit_offset;\r\nguint8* pui8 = NULL;\r\nguint16* pui16;\r\nguint32* pui32;\r\nguint8 Tag = STANDARD_TAG;\r\nif (remaining_bits_len <= 0)\r\n{\r\nreturn 0;\r\n}\r\ndo\r\n{\r\nswitch (pDescr->type)\r\n{\r\ncase CSN_BIT:\r\n{\r\nif (remaining_bits_len > 0)\r\n{\r\npui8 = pui8DATA(data, pDescr->offset);\r\n*pui8 = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nelse if(pDescr->may_be_null)\r\n{\r\n*pui8 = 0;\r\nproto_tree_add_none_format(tree, hf_null_data, tvb, 0, 0, "[NULL data]: %s Not Present", proto_registrar_get_name(*(pDescr->hf_ptr)));\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\npDescr++;\r\nremaining_bits_len--;\r\nbit_offset++;\r\nbreak;\r\n}\r\ncase CSN_NULL:\r\n{\r\nbit_offset += pDescr->i;\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_UINT:\r\n{\r\nguint8 no_of_bits = (guint8) pDescr->i;\r\nif (remaining_bits_len >= no_of_bits)\r\n{\r\nif (no_of_bits <= 8)\r\n{\r\nguint8 ui8 = tvb_get_bits8(tvb, bit_offset, no_of_bits);\r\npui8 = pui8DATA(data, pDescr->offset);\r\n*pui8 = ui8;\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse if (no_of_bits <= 16)\r\n{\r\nguint16 ui16 = tvb_get_bits16(tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\npui16 = pui16DATA(data, pDescr->offset);\r\n*pui16 = ui16;\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse if (no_of_bits <= 32)\r\n{\r\nguint32 ui32 = tvb_get_bits32(tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\npui32 = pui32DATA(data, pDescr->offset);\r\n*pui32 = ui32;\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_GENERAL, &ei_csn1_general, pDescr);\r\n}\r\nremaining_bits_len -= no_of_bits;\r\nbit_offset += no_of_bits;\r\n}\r\nelse if(pDescr->may_be_null)\r\n{\r\nif (no_of_bits <= 8)\r\n{\r\npui8 = pui8DATA(data, pDescr->offset);\r\n*pui8 = 0;\r\n}\r\nelse if (no_of_bits <= 16)\r\n{\r\npui16 = pui16DATA(data, pDescr->offset);\r\n*pui16 = 0;\r\n}\r\nelse if (no_of_bits <= 32)\r\n{\r\npui32 = pui32DATA(data, pDescr->offset);\r\n*pui32 = 0;\r\n}\r\nproto_tree_add_none_format(tree, hf_null_data, tvb, 0, 0, "[NULL data]: %s Not Present", proto_registrar_get_name(*(pDescr->hf_ptr)));\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_UINT_OFFSET:\r\n{\r\nguint8 no_of_bits = (guint8) pDescr->i;\r\nif (remaining_bits_len >= no_of_bits)\r\n{\r\nif (no_of_bits <= 8)\r\n{\r\nguint8 ui8 = tvb_get_bits8(tvb, bit_offset, no_of_bits);\r\npui8 = pui8DATA(data, pDescr->offset);\r\n*pui8 = ui8 + (guint8)pDescr->descr.value;\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse if (no_of_bits <= 16)\r\n{\r\nguint16 ui16 = tvb_get_bits16(tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\npui16 = pui16DATA(data, pDescr->offset);\r\n*pui16 = ui16 + (guint16)pDescr->descr.value;\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse if (no_of_bits <= 32)\r\n{\r\nguint32 ui32 = tvb_get_bits32(tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\npui32 = pui32DATA(data, pDescr->offset);\r\n*pui32 = ui32 + (guint16)pDescr->descr.value;\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_GENERAL, &ei_csn1_general, pDescr);\r\n}\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\nremaining_bits_len -= no_of_bits;\r\nbit_offset += no_of_bits;\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_UINT_LH:\r\n{\r\nguint8 no_of_bits = (guint8) pDescr->i;\r\nif (remaining_bits_len >= no_of_bits)\r\n{\r\nif (no_of_bits <= 8)\r\n{\r\nguint8 ui8 = tvb_get_masked_bits8(tvb, bit_offset, no_of_bits);\r\npui8 = pui8DATA(data, pDescr->offset);\r\n*pui8 = ui8;\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_GENERAL, &ei_csn1_general, pDescr);\r\n}\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\nremaining_bits_len -= no_of_bits;\r\nbit_offset += no_of_bits;\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_SPLIT_BITS:\r\n{\r\nguint8 no_of_value_bits = (guint8) pDescr->i;\r\nguint64 value;\r\nproto_tree_add_split_bits_item_ret_val(tree, *pDescr->hf_ptr, tvb, bit_offset, pDescr->descr.crumb_spec, &value);\r\nif (no_of_value_bits <= 8)\r\n{\r\npui8 = pui8DATA(data, pDescr->offset);\r\n*pui8 = (guint8)value;\r\n}\r\nelse if (no_of_value_bits <= 16)\r\n{\r\npui16 = pui16DATA(data, pDescr->offset);\r\n*pui16 = (guint16)value;\r\n}\r\nelse if (no_of_value_bits <= 32)\r\n{\r\npui32 = pui32DATA(data, pDescr->offset);\r\n*pui32 = (guint32)value;\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_GENERAL, &ei_csn1_general, pDescr);\r\n}\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_SPLIT_BITS_CRUMB:\r\n{\r\nif (remaining_bits_len >= pDescr->descr.crumb_spec[pDescr->i].crumb_bit_length)\r\n{\r\nproto_tree_add_split_bits_crumb(tree, *pDescr->hf_ptr, tvb, bit_offset,\r\npDescr->descr.crumb_spec, pDescr->i);\r\nremaining_bits_len -= pDescr->descr.crumb_spec[pDescr->i].crumb_bit_length;\r\nbit_offset += pDescr->descr.crumb_spec[pDescr->i].crumb_bit_length;\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_UINT_ARRAY:\r\n{\r\nguint8 no_of_bits = (guint8) pDescr->i;\r\nguint16 nCount = (guint16)pDescr->descr.value;\r\nint i =0;\r\nif (pDescr->value != 0)\r\n{\r\nnCount = *pui16DATA(data, nCount);\r\n}\r\nif (remaining_bits_len >= no_of_bits)\r\n{\r\nif (no_of_bits <= 8)\r\n{\r\npui8 = pui8DATA(data, pDescr->offset);\r\ndo\r\n{\r\n*pui8++ = tvb_get_bits8(tvb, bit_offset, no_of_bits);\r\nproto_tree_add_uint_bits_format_value(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, *pui8, " (Count %d)", i++);\r\nremaining_bits_len -= no_of_bits;\r\nbit_offset += no_of_bits;\r\n} while (--nCount > 0);\r\n}\r\nelse if (no_of_bits <= 16)\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, 999, &ei_csn1_not_implemented, pDescr);\r\n}\r\nelse if (no_of_bits <= 32)\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, 999, &ei_csn1_not_implemented, pDescr);\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_GENERAL, &ei_csn1_general, pDescr);\r\n}\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_VARIABLE_TARRAY_OFFSET:\r\ncase CSN_VARIABLE_TARRAY:\r\ncase CSN_TYPE_ARRAY:\r\n{\r\ngint16 Status;\r\ncsnStream_t arT = *ar;\r\ngint16 nCount = pDescr->i;\r\nguint16 nSize = (guint16)(gint32)pDescr->value;\r\nint i =0;\r\npui8 = pui8DATA(data, pDescr->offset);\r\nif (pDescr->type == CSN_VARIABLE_TARRAY)\r\n{\r\nnCount = *pui8DATA(data, pDescr->i);\r\n}\r\nelse if (pDescr->type == CSN_VARIABLE_TARRAY_OFFSET)\r\n{\r\nnCount = *pui8DATA(data, pDescr->i);\r\n}\r\nwhile (nCount > 0)\r\n{\r\nproto_item *ti;\r\nproto_tree *test_tree;\r\ntest_tree = proto_tree_add_subtree_format(tree, tvb, bit_offset>>3, 1, ett_csn1, &ti, "%s[%d]",pDescr->sz, i++);\r\ncsnStreamInit(&arT, bit_offset, remaining_bits_len, ar->pinfo);\r\nStatus = csnStreamDissector(test_tree, &arT, (const CSN_DESCR*)pDescr->descr.ptr, tvb, pui8, ett_csn1);\r\nif (Status >= 0)\r\n{\r\npui8 += nSize;\r\nproto_item_set_len(ti,((arT.bit_offset-1)>>3) - (bit_offset>>3)+1);\r\nremaining_bits_len = arT.remaining_bits_len;\r\nbit_offset = arT.bit_offset;\r\n}\r\nelse\r\n{\r\nreturn Status;\r\n}\r\nnCount--;\r\n}\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_BITMAP:\r\n{\r\nguint8 no_of_bits = (guint8) pDescr->i;\r\nif (no_of_bits > 0)\r\n{\r\nif (no_of_bits <= 32)\r\n{\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse if (no_of_bits <= 64)\r\n{\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, 999, &ei_csn1_not_implemented, pDescr);\r\n}\r\nremaining_bits_len -= no_of_bits;\r\nDISSECTOR_ASSERT(remaining_bits_len >= 0);\r\nbit_offset += no_of_bits;\r\n}\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_TYPE:\r\n{\r\ngint16 Status;\r\ncsnStream_t arT = *ar;\r\nproto_item *ti;\r\nproto_tree *test_tree;\r\ntest_tree = proto_tree_add_subtree_format(tree, tvb, bit_offset>>3, 1, ett_csn1, &ti, "%s", pDescr->sz);\r\ncsnStreamInit(&arT, bit_offset, remaining_bits_len, ar->pinfo);\r\nStatus = csnStreamDissector(test_tree, &arT, (const CSN_DESCR*)pDescr->descr.ptr, tvb, pvDATA(data, pDescr->offset), ett_csn1);\r\nif (Status >= 0)\r\n{\r\nproto_item_set_len(ti,((arT.bit_offset-1)>>3) - (bit_offset>>3)+1);\r\nremaining_bits_len = arT.remaining_bits_len;\r\nbit_offset = arT.bit_offset;\r\npDescr++;\r\n}\r\nelse\r\n{\r\nreturn Status;\r\n}\r\nbreak;\r\n}\r\ncase CSN_CHOICE:\r\n{\r\ngint16 count = pDescr->i;\r\nguint8 i = 0;\r\nconst CSN_ChoiceElement_t* pChoice = (const CSN_ChoiceElement_t*) pDescr->descr.ptr;\r\nwhile (count > 0)\r\n{\r\nguint8 no_of_bits = pChoice->bits;\r\nguint8 value = tvb_get_bits8(tvb, bit_offset, no_of_bits);\r\nif (value == pChoice->value)\r\n{\r\nCSN_DESCR descr[2];\r\ngint16 Status;\r\ncsnStream_t arT = *ar;\r\nproto_item *ti = NULL;\r\nproto_tree *test_tree;\r\ndescr[0] = pChoice->descr;\r\nmemset(&descr[1], 0x00, sizeof(CSN_DESCR));\r\ndescr[1].type = CSN_END;\r\npui8 = pui8DATA(data, pDescr->offset);\r\n*pui8 = i;\r\nif (pDescr->sz) {\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nif (!pChoice->keep_bits) {\r\nbit_offset += no_of_bits;\r\nremaining_bits_len -= no_of_bits;\r\n}\r\nif (pDescr->sz) {\r\ntest_tree = proto_tree_add_subtree(tree, tvb, bit_offset>>3, 1, ett_csn1, &ti, pDescr->sz);\r\n} else {\r\ntest_tree = tree;\r\n}\r\ncsnStreamInit(&arT, bit_offset, remaining_bits_len, ar->pinfo);\r\nStatus = csnStreamDissector(test_tree, &arT, (const CSN_DESCR*)descr, tvb, data, ett_csn1);\r\nif (Status >= 0)\r\n{\r\nif (ti)\r\nproto_item_set_len(ti,((arT.bit_offset-1)>>3) - (bit_offset>>3)+1);\r\nremaining_bits_len = arT.remaining_bits_len;\r\nbit_offset = arT.bit_offset;\r\n}\r\nelse\r\n{\r\nreturn Status;\r\n}\r\nbreak;\r\n}\r\ncount--;\r\npChoice++;\r\ni++;\r\n}\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_SERIALIZE:\r\n{\r\nStreamSerializeFcn_t serialize = (StreamSerializeFcn_t)pDescr->aux_fn;\r\ncsnStream_t arT = *ar;\r\nguint length_len = pDescr->i;\r\ngint16 Status = -1;\r\nproto_item *ti;\r\nproto_tree *test_tree;\r\nguint8 length = 0;\r\nif (length_len) {\r\nlength = tvb_get_bits8(tvb, bit_offset, length_len);\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, length_len, ENC_BIG_ENDIAN);\r\nbit_offset += length_len;\r\nremaining_bits_len -= length_len;\r\ntest_tree = proto_tree_add_subtree(tree, tvb, bit_offset>>3, ((bit_offset+length-1)>>3)-(bit_offset>>3) + 1, ett_csn1, &ti, pDescr->sz);\r\n} else {\r\ntest_tree = proto_tree_add_subtree(tree, tvb, bit_offset>>3, 1, ett_csn1, &ti, pDescr->sz);\r\n}\r\ncsnStreamInit(&arT, bit_offset, length > 0 ? length : remaining_bits_len, ar->pinfo);\r\nStatus = serialize(test_tree, &arT, tvb, pvDATA(data, pDescr->offset), ett_csn1);\r\nif (Status >= 0)\r\n{\r\nif (length > 0) {\r\nremaining_bits_len -= length;\r\nbit_offset += length;\r\n} else {\r\nproto_item_set_len(ti,((arT.bit_offset - bit_offset)>>3)+1);\r\nremaining_bits_len = arT.remaining_bits_len;\r\nbit_offset = arT.bit_offset;\r\n}\r\npDescr++;\r\n}\r\nelse\r\n{\r\nreturn Status;\r\n}\r\nbreak;\r\n}\r\ncase CSN_UNION_LH:\r\ncase CSN_UNION:\r\n{\r\ngint16 Bits;\r\nguint8 t_index;\r\ngint16 count = pDescr->i;\r\nconst CSN_DESCR* pDescrNext = pDescr;\r\npDescrNext += count + 1;\r\nif ((count <= 0) || (count > 16))\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_INVALID_UNION_INDEX, &ei_csn1_union_index, pDescr);\r\n}\r\nBits = ixBitsTab[count];\r\nproto_tree_add_uint_bits_format_value(tree, *(pDescr->hf_ptr), tvb, bit_offset, Bits, tvb_get_bits8(tvb, bit_offset, Bits), " (Union)");\r\nt_index = 0;\r\nwhile (Bits > 0)\r\n{\r\nt_index <<= 1;\r\nif (CSN_UNION_LH == pDescr->type)\r\n{\r\nt_index |= tvb_get_masked_bits8(tvb, bit_offset, 1);\r\n}\r\nelse\r\n{\r\nt_index |= tvb_get_bits8(tvb, bit_offset, 1);\r\n}\r\nremaining_bits_len--;\r\nbit_offset++;\r\nBits--;\r\n}\r\npui8 = pui8DATA(data, pDescr->offset);\r\n*pui8 = t_index;\r\npDescr += (MIN(t_index + 1, count));\r\nswitch (pDescr->type)\r\n{\r\ncase CSN_BIT:\r\n{\r\npui8 = pui8DATA(data, pDescr->offset);\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\n*pui8 = 0x00;\r\nif (tvb_get_bits8(tvb, bit_offset, 1) > 0)\r\n{\r\n*pui8 = 0x01;\r\n}\r\nremaining_bits_len --;\r\nbit_offset++;\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_NULL:\r\n{\r\nbit_offset += pDescr->i;\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_UINT:\r\n{\r\nguint8 no_of_bits = (guint8) pDescr->i;\r\nif (remaining_bits_len >= no_of_bits)\r\n{\r\nif (no_of_bits <= 8)\r\n{\r\nguint8 ui8 = tvb_get_bits8(tvb, bit_offset, no_of_bits);\r\npui8 = pui8DATA(data, pDescr->offset);\r\n*pui8 = ui8;\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse if (no_of_bits <= 16)\r\n{\r\nguint16 ui16 = tvb_get_bits16(tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\npui16 = pui16DATA(data, pDescr->offset);\r\n*pui16 = ui16;\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse if (no_of_bits <= 32)\r\n{\r\nguint32 ui32 = tvb_get_bits32(tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\npui32 = pui32DATA(data, pDescr->offset);\r\n*pui32 = ui32;\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_GENERAL, &ei_csn1_general, pDescr);\r\n}\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_GENERAL, &ei_csn1_general, pDescr);\r\n}\r\nremaining_bits_len -= no_of_bits;\r\nbit_offset += no_of_bits;\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_UINT_OFFSET:\r\n{\r\nguint8 no_of_bits = (guint8) pDescr->i;\r\nif (remaining_bits_len >= no_of_bits)\r\n{\r\nif (no_of_bits <= 8)\r\n{\r\nguint8 ui8 = tvb_get_bits8(tvb, bit_offset, no_of_bits);\r\npui8 = pui8DATA(data, pDescr->offset);\r\n*pui8 = ui8 + (guint8)pDescr->descr.value;\r\nproto_tree_add_uint_bits_format_value(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ui8, "%d", ui8);\r\n}\r\nelse if (no_of_bits <= 16)\r\n{\r\nguint16 ui16 = tvb_get_bits16(tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\npui16 = pui16DATA(data, pDescr->offset);\r\n*pui16 = ui16 + (guint16)pDescr->descr.value;\r\nproto_tree_add_uint_bits_format_value(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ui16, "%d", ui16);\r\n}\r\nelse if (no_of_bits <= 32)\r\n{\r\nguint32 ui32 = tvb_get_bits32(tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\npui32 = pui32DATA(data, pDescr->offset);\r\n*pui32 = ui32 + (guint16)pDescr->descr.value;\r\nproto_tree_add_uint_bits_format_value(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ui32, "%d", ui32);\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_GENERAL, &ei_csn1_general, pDescr);\r\n}\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\nremaining_bits_len -= no_of_bits;\r\nbit_offset += no_of_bits;\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_UINT_LH:\r\n{\r\nguint8 no_of_bits = (guint8) pDescr->i;\r\nif (remaining_bits_len >= no_of_bits)\r\n{\r\nif (no_of_bits <= 8)\r\n{\r\nguint8 ui8 = tvb_get_masked_bits8(tvb, bit_offset, no_of_bits);\r\npui8 = pui8DATA(data, pDescr->offset);\r\n*pui8 = ui8;\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_GENERAL, &ei_csn1_general, pDescr);\r\n}\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\nremaining_bits_len -= no_of_bits;\r\nbit_offset += no_of_bits;\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_UINT_ARRAY:\r\n{\r\nguint8 no_of_bits = (guint8) pDescr->i;\r\nguint16 nCount = (guint16)pDescr->descr.value;\r\ngint i = 0;\r\nif (pDescr->value != 0)\r\n{\r\nnCount = *pui16DATA(data, nCount);\r\n}\r\nif (remaining_bits_len >= no_of_bits)\r\n{\r\nif (no_of_bits <= 8)\r\n{\r\npui8 = pui8DATA(data, pDescr->offset);\r\nwhile (nCount > 0)\r\n{\r\n*pui8 = tvb_get_bits8(tvb, bit_offset, no_of_bits);\r\nproto_tree_add_uint_bits_format_value(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, *pui8, " (Count %d)", i++);\r\npui8++;\r\nremaining_bits_len -= no_of_bits;\r\nbit_offset += no_of_bits;\r\nnCount--;\r\n}\r\n}\r\nelse if (no_of_bits <= 16)\r\n{\r\npui16 = pui16DATA(data, pDescr->offset);\r\nwhile (nCount > 0)\r\n{\r\n*pui16 = tvb_get_bits16(tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint_bits_format_value(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, *pui16, " (Count %d)", i++);\r\nremaining_bits_len -= no_of_bits;\r\nbit_offset += no_of_bits;\r\nnCount--;\r\n}\r\n}\r\nelse if (no_of_bits <= 32)\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, 999, &ei_csn1_not_implemented, pDescr);\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_GENERAL, &ei_csn1_general, pDescr);\r\n}\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_VARIABLE_TARRAY_OFFSET:\r\ncase CSN_VARIABLE_TARRAY:\r\ncase CSN_TYPE_ARRAY:\r\n{\r\ngint16 Status;\r\ncsnStream_t arT = *ar;\r\nguint16 nCount = (guint16) pDescr->i;\r\nguint16 nSize = (guint16)(guint32)pDescr->value;\r\ngint i = 0;\r\npui8 = pui8DATA(data, pDescr->offset);\r\nif (CSN_VARIABLE_TARRAY == pDescr->type)\r\n{\r\nnCount = *pui8DATA(data, pDescr->i);\r\n}\r\nelse if (CSN_VARIABLE_TARRAY_OFFSET == pDescr->type)\r\n{\r\nnCount = *pui8DATA(data, pDescr->i);\r\nnCount--;\r\n}\r\nwhile (nCount--)\r\n{\r\nproto_item *ti;\r\nproto_tree *test_tree;\r\ntest_tree = proto_tree_add_subtree_format(tree, tvb, bit_offset>>3, 1, ett_csn1, &ti, "%s[%d]",pDescr->sz, i++);\r\ncsnStreamInit(&arT, bit_offset, remaining_bits_len, ar->pinfo);\r\nStatus = csnStreamDissector(test_tree, &arT, (const CSN_DESCR *)pDescr->descr.ptr, tvb, pui8, ett_csn1);\r\nif (Status >= 0)\r\n{\r\npui8 += nSize;\r\nproto_item_set_len(ti,((arT.bit_offset-1)>>3) - (bit_offset>>3)+1);\r\nremaining_bits_len = arT.remaining_bits_len;\r\nbit_offset = arT.bit_offset;\r\n}\r\nelse\r\n{\r\nreturn Status;\r\n}\r\n}\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_BITMAP:\r\n{\r\nguint8 no_of_bits = (guint8) pDescr->i;\r\nif (no_of_bits > 0)\r\n{\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\nremaining_bits_len -= no_of_bits;\r\nbit_offset += no_of_bits;\r\nif (remaining_bits_len < 0)\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\n}\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_TYPE:\r\n{\r\ngint16 Status;\r\ncsnStream_t arT = *ar;\r\nproto_item *ti;\r\nproto_tree *test_tree;\r\ntest_tree = proto_tree_add_subtree(tree, tvb, bit_offset>>3, 1, ett_csn1, &ti, pDescr->sz);\r\ncsnStreamInit(&arT, bit_offset, remaining_bits_len, ar->pinfo);\r\nStatus = csnStreamDissector(test_tree, &arT, (const CSN_DESCR *)pDescr->descr.ptr, tvb, pvDATA(data, pDescr->offset), ett_csn1);\r\nif (Status >= 0)\r\n{\r\nproto_item_set_len(ti,((arT.bit_offset-1)>>3) - (bit_offset>>3)+1);\r\nremaining_bits_len = arT.remaining_bits_len;\r\nbit_offset = arT.bit_offset;\r\npDescr++;\r\n}\r\nelse\r\n{\r\nreturn Status;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_IN_SCRIPT, &ei_csn1_script_error, pDescr);\r\n}\r\n}\r\npDescr = pDescrNext;\r\nbreak;\r\n}\r\ncase CSN_EXIST:\r\ncase CSN_EXIST_LH:\r\n{\r\nguint8 fExist;\r\npui8 = pui8DATA(data, pDescr->offset);\r\nif (CSN_EXIST_LH == pDescr->type)\r\n{\r\nfExist = tvb_get_masked_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_uint(tree, *(pDescr->hf_ptr), tvb, bit_offset>>3, 1, fExist);\r\n}\r\nelse\r\n{\r\nfExist = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\n}\r\n*pui8 = fExist;\r\nremaining_bits_len --;\r\nbit_offset++;\r\npDescr++;\r\nif (!fExist)\r\n{\r\nar->remaining_bits_len = remaining_bits_len;\r\nar->bit_offset = bit_offset;\r\nreturn remaining_bits_len;\r\n}\r\nbreak;\r\n}\r\ncase CSN_NEXT_EXIST:\r\n{\r\nguint8 fExist;\r\npui8 = pui8DATA(data, pDescr->offset);\r\nif ((pDescr->may_be_null) && (remaining_bits_len == 0))\r\n{\r\npDescr += pDescr->i + 1;\r\n*pui8 = 0;\r\nbreak;\r\n}\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nfExist = 0x00;\r\nif (tvb_get_bits8(tvb, bit_offset, 1))\r\n{\r\nfExist = 0x01;\r\n}\r\n*pui8 = fExist;\r\nremaining_bits_len --;\r\nbit_offset++;\r\nif (fExist == 0)\r\n{\r\npDescr += pDescr->i;\r\n}\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_NEXT_EXIST_LH:\r\n{\r\nguint8 fExist;\r\npui8 = pui8DATA(data, pDescr->offset);\r\nif ((pDescr->descr.ptr != NULL) && (remaining_bits_len == 0))\r\n{\r\npDescr += pDescr->i + 1;\r\n*pui8 = 0;\r\nbreak;\r\n}\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nfExist = tvb_get_masked_bits8(tvb, bit_offset, 1);\r\n*pui8++ = fExist;\r\nremaining_bits_len --;\r\nbit_offset++;\r\nif (fExist == 0)\r\n{\r\npDescr += pDescr->i;\r\n}\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_VARIABLE_BITMAP_1:\r\n{\r\n*pui8DATA(data, (gint16)pDescr->descr.value) = (guint8) remaining_bits_len;\r\n}\r\ncase CSN_VARIABLE_BITMAP:\r\n{\r\ngint16 no_of_bits = *pui8DATA(data, (gint16)pDescr->descr.value);\r\nno_of_bits += pDescr->i;\r\nwhile (no_of_bits > 0)\r\n{\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nno_of_bits--;\r\nremaining_bits_len--;\r\nif (remaining_bits_len < 0)\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\n}\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_LEFT_ALIGNED_VAR_BMP_1:\r\n{\r\n*pui8DATA(data, (gint16)pDescr->descr.value) = (guint8) remaining_bits_len;\r\n}\r\ncase CSN_LEFT_ALIGNED_VAR_BMP:\r\n{\r\ngint16 no_of_bits = *pui8DATA(data, (gint16)pDescr->descr.value);\r\nno_of_bits += pDescr->i;\r\nif (no_of_bits > 0)\r\n{\r\nif (no_of_bits <= 32)\r\n{\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse if (no_of_bits <= 64)\r\n{\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nproto_tree_add_uint64_format_value(tree, *(pDescr->hf_ptr), tvb, bit_offset>>3, ((bit_offset+no_of_bits-1)>>3)-(bit_offset>>3)+1, no_of_bits, "%u bits",\r\nno_of_bits);\r\n}\r\nbit_offset += no_of_bits;\r\nremaining_bits_len -= no_of_bits;\r\nif (remaining_bits_len < 0)\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\n}\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_PADDING_BITS:\r\n{\r\nif (remaining_bits_len > 0)\r\n{\r\nproto_tree *padding_tree = proto_tree_add_subtree(tree, tvb, bit_offset>>3, -1, ett_csn1, NULL, "Padding Bits");\r\nwhile (remaining_bits_len > 0)\r\n{\r\ngint bits_to_handle = remaining_bits_len + (bit_offset%8);\r\nif (bits_to_handle > 32)\r\n{\r\nbits_to_handle = 32 - (bit_offset%8);\r\n}\r\nelse\r\n{\r\nbits_to_handle -= (bit_offset%8);\r\n}\r\nproto_tree_add_bits_item(padding_tree, *(pDescr->hf_ptr), tvb, bit_offset, bits_to_handle, ENC_BIG_ENDIAN);\r\nbit_offset += bits_to_handle;\r\nremaining_bits_len -= bits_to_handle;\r\n}\r\n}\r\nif (remaining_bits_len < 0)\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_VARIABLE_ARRAY:\r\n{\r\ngint16 count = *pui8DATA(data, (gint16)pDescr->descr.value);\r\ncount += pDescr->i;\r\nif (count > 0)\r\n{\r\npui8 = pui8DATA(data, pDescr->offset);\r\nwhile (count > 0)\r\n{\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, 8, ENC_BIG_ENDIAN);\r\n*pui8++ = tvb_get_bits8(tvb, bit_offset, 8);\r\nbit_offset += 8;\r\ncount--;\r\nremaining_bits_len -= 8;\r\nif (remaining_bits_len < 0)\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\n}\r\n}\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_RECURSIVE_ARRAY:\r\n{\r\ngint16 no_of_bits = pDescr->i;\r\nguint8 ElementCount = 0;\r\npui8 = pui8DATA(data, pDescr->offset);\r\nwhile (existNextElement(tvb, bit_offset, Tag))\r\n{\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_exist_ptr), tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nremaining_bits_len--;\r\n*pui8++ = tvb_get_bits8(tvb, bit_offset, no_of_bits);\r\nElementCount++;\r\nif (remaining_bits_len < 0)\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\nbit_offset += no_of_bits;\r\nremaining_bits_len -= no_of_bits;\r\n}\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_exist_ptr), tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nremaining_bits_len--;\r\n*pui8DATA(data, (gint16)pDescr->descr.value) = ElementCount;\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_RECURSIVE_TARRAY:\r\n{\r\ngint16 nSizeElement = (gint16)(gint32)pDescr->value;\r\nguint8 ElementCount = 0;\r\nwhile (existNextElement(tvb, bit_offset, Tag))\r\n{\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nremaining_bits_len--;\r\nElementCount++;\r\n{\r\ncsnStream_t arT = *ar;\r\ngint16 Status;\r\nproto_item *ti;\r\nproto_tree *test_tree;\r\ntest_tree = proto_tree_add_subtree(tree, tvb, bit_offset>>3, 1, ett_csn1, &ti, pDescr->sz);\r\ncsnStreamInit(&arT, bit_offset, remaining_bits_len, ar->pinfo);\r\nStatus = csnStreamDissector(test_tree, &arT, (const CSN_DESCR *)pDescr->descr.ptr, tvb, pvDATA(data, pDescr->offset), ett_csn1);\r\nif (Status >= 0)\r\n{\r\npui8 += nSizeElement;\r\nproto_item_set_len(ti,((arT.bit_offset-1)>>3) - (bit_offset>>3)+1);\r\nremaining_bits_len = arT.remaining_bits_len;\r\nbit_offset = arT.bit_offset;\r\n}\r\nelse\r\n{\r\nreturn Status;\r\n}\r\n}\r\nif (remaining_bits_len < 0)\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\n}\r\nbit_offset++;\r\nremaining_bits_len --;\r\n*pui8DATA(data, (gint16)(gint32)pDescr->i) = ElementCount;\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_RECURSIVE_TARRAY_2:\r\n{\r\nTag = REVERSED_TAG;\r\n}\r\ncase CSN_RECURSIVE_TARRAY_1:\r\n{\r\ngint16 nSizeElement = (gint16)(gint32)pDescr->value;\r\nguint8 ElementCount = 0;\r\ncsnStream_t arT = *ar;\r\ngboolean EndOfList = FALSE;\r\ngint16 Status;\r\nproto_item *ti;\r\nproto_tree *test_tree;\r\ndo\r\n{\r\nElementCount++;\r\ntest_tree = proto_tree_add_subtree_format(tree, tvb, bit_offset>>3, 1, ett_csn1, &ti, "%s[%d]", pDescr->sz, ElementCount-1);\r\ncsnStreamInit(&arT, bit_offset, remaining_bits_len, ar->pinfo);\r\nStatus = csnStreamDissector(test_tree, &arT, (const CSN_DESCR *)pDescr->descr.ptr, tvb, pvDATA(data, pDescr->offset), ett_csn1);\r\nif (Status >= 0)\r\n{\r\npui8 += nSizeElement;\r\nproto_item_set_len(ti,((arT.bit_offset-1)>>3) - (bit_offset>>3)+1);\r\nremaining_bits_len = arT.remaining_bits_len;\r\nbit_offset = arT.bit_offset;\r\n}\r\nelse\r\n{\r\nreturn Status;\r\n}\r\nif (remaining_bits_len < 0)\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\nproto_tree_add_uint_bits_format_value(tree, *(pDescr->hf_ptr), tvb, bit_offset, 1, tvb_get_bits8(tvb, bit_offset, 1), "%s[%d]",\r\nproto_registrar_get_name(*(pDescr->hf_ptr)), ElementCount);\r\nEndOfList = !(existNextElement(tvb, bit_offset, Tag));\r\nbit_offset++;\r\nremaining_bits_len--;\r\n} while (!EndOfList);\r\n*pui8DATA(data, pDescr->i) = ElementCount;\r\nTag = STANDARD_TAG;\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_FIXED:\r\n{\r\nguint8 no_of_bits = (guint8) pDescr->i;\r\nguint32 ui32;\r\nif (no_of_bits <= 8)\r\n{\r\nui32 = tvb_get_bits8(tvb, bit_offset, no_of_bits);\r\n}\r\nelse if (no_of_bits <= 16)\r\n{\r\nui32 = tvb_get_bits16(tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse if (no_of_bits <= 32)\r\n{\r\nui32 = tvb_get_bits32(tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, -1, &ei_csn1_more32bits, pDescr);\r\n}\r\nif (ui32 != (unsigned)(gint32)pDescr->offset)\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, -1, &ei_csn1_fixed_not_matched, pDescr);\r\n}\r\nproto_tree_add_bits_item(tree, *(pDescr->hf_ptr), tvb, bit_offset, no_of_bits, ENC_BIG_ENDIAN);\r\nremaining_bits_len -= no_of_bits;\r\nbit_offset += no_of_bits;\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_CALLBACK:\r\n{\r\nguint16 no_of_bits;\r\nDissectorCallbackFcn_t callback = (DissectorCallbackFcn_t)pDescr->aux_fn;\r\nno_of_bits = callback(tree, tvb, pvDATA(data, pDescr->i), pvDATA(data, pDescr->offset), bit_offset, ett_csn1, ar->pinfo);\r\nbit_offset += no_of_bits;\r\nremaining_bits_len -= no_of_bits;\r\npDescr++;\r\nbreak;\r\n}\r\ncase CSN_TRAP_ERROR:\r\n{\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, -1, pDescr->error, pDescr);\r\n}\r\ncase CSN_END:\r\n{\r\nar->remaining_bits_len = remaining_bits_len;\r\nar->bit_offset = bit_offset;\r\nreturn remaining_bits_len;\r\n}\r\ndefault:\r\n{\r\nDISSECTOR_ASSERT(0);\r\n}\r\n}\r\n} while (remaining_bits_len >= 0);\r\nreturn ProcessError(tree, ar->pinfo, tvb, bit_offset, CSN_ERROR_NEED_MORE_BITS_TO_UNPACK, &ei_csn1_more_bits_to_unpack, pDescr);\r\n}\r\nvoid\r\nproto_register_csn1(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_null_data,\r\n{ "NULL data", "csn1.null_data",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_csn1_more_bits_to_unpack, { "csn1.more_bits_to_unpack", PI_MALFORMED, PI_ERROR, "NEED_MORE BITS TO UNPACK", EXPFILL }},\r\n{ &ei_csn1_general, { "csn1.general_error", PI_PROTOCOL, PI_WARN, "General -1", EXPFILL }},\r\n{ &ei_csn1_not_implemented, { "csn1.not_implemented", PI_UNDECODED, PI_WARN, "NOT IMPLEMENTED", EXPFILL }},\r\n{ &ei_csn1_union_index, { "csn1.union_index_invalid", PI_PROTOCOL, PI_WARN, "INVALID UNION INDEX", EXPFILL }},\r\n{ &ei_csn1_script_error, { "csn1.script_error", PI_MALFORMED, PI_ERROR, "ERROR IN SCRIPT", EXPFILL }},\r\n{ &ei_csn1_more32bits, { "csn1.more32bits", PI_PROTOCOL, PI_WARN, "no_of_bits > 32", EXPFILL }},\r\n{ &ei_csn1_fixed_not_matched, { "csn1.fixed_not_matched", PI_PROTOCOL, PI_WARN, "FIXED value does not match", EXPFILL }},\r\n};\r\nexpert_module_t* expert_csn1;\r\nproto_csn1 = proto_register_protocol("CSN.1", "CSN1", "csn1");\r\nproto_register_field_array(proto_csn1, hf, array_length(hf));\r\nexpert_csn1 = expert_register_protocol(proto_csn1);\r\nexpert_register_field_array(expert_csn1, ei, array_length(ei));\r\nproto_set_cant_toggle(proto_csn1);\r\n}
