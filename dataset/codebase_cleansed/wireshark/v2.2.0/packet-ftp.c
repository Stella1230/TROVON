static gboolean\r\nparse_port_pasv(const guchar *line, int linelen, guint32 *ftp_ip, guint16 *ftp_port,\r\nguint32 *pasv_offset, guint *ftp_ip_len, guint *ftp_port_len)\r\n{\r\nchar *args;\r\nchar *p;\r\nguchar c;\r\nint i;\r\nint ip_address[4], port[2];\r\ngboolean ret = FALSE;\r\nargs = wmem_strndup(wmem_packet_scope(), line, linelen);\r\np = args;\r\nfor (;;) {\r\nwhile ((c = *p) != '\0' && !g_ascii_isdigit(c))\r\np++;\r\nif (*p == '\0') {\r\nbreak;\r\n}\r\ni = sscanf(p, "%d,%d,%d,%d,%d,%d",\r\n&ip_address[0], &ip_address[1], &ip_address[2], &ip_address[3],\r\n&port[0], &port[1]);\r\nif (i == 6) {\r\n*ftp_port = ((port[0] & 0xFF)<<8) | (port[1] & 0xFF);\r\n*ftp_ip = g_htonl((ip_address[0] << 24) | (ip_address[1] <<16) | (ip_address[2] <<8) | ip_address[3]);\r\n*pasv_offset = (guint32)(p - args);\r\n*ftp_port_len = (port[0] < 10 ? 1 : (port[0] < 100 ? 2 : 3 )) + 1 +\r\n(port[1] < 10 ? 1 : (port[1] < 100 ? 2 : 3 ));\r\n*ftp_ip_len = (ip_address[0] < 10 ? 1 : (ip_address[0] < 100 ? 2 : 3)) + 1 +\r\n(ip_address[1] < 10 ? 1 : (ip_address[1] < 100 ? 2 : 3)) + 1 +\r\n(ip_address[2] < 10 ? 1 : (ip_address[2] < 100 ? 2 : 3)) + 1 +\r\n(ip_address[3] < 10 ? 1 : (ip_address[3] < 100 ? 2 : 3));\r\nret = TRUE;\r\nbreak;\r\n}\r\nwhile ((c = *p) != '\0' && g_ascii_isdigit(c))\r\np++;\r\n}\r\nreturn ret;\r\n}\r\nstatic gboolean\r\nisvalid_rfc2428_delimiter(const guchar c)\r\n{\r\nconst gchar *forbidden = "0123456789abcdef.:";\r\nif (!g_ascii_isgraph(c))\r\nreturn FALSE;\r\nif (strchr(forbidden, g_ascii_tolower(c)))\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nparse_eprt_request(const guchar* line, gint linelen, guint32 *eprt_af,\r\nguint32 *eprt_ip, guint16 *eprt_ipv6, guint16 *ftp_port,\r\nguint32 *eprt_ip_len, guint32 *ftp_port_len)\r\n{\r\ngint delimiters_seen = 0;\r\ngchar delimiter;\r\ngint fieldlen;\r\ngchar *field;\r\ngint n;\r\ngint lastn;\r\nchar *args, *p;\r\ngboolean ret = TRUE;\r\nif (!line || linelen<4)\r\nreturn FALSE;\r\nargs = wmem_strndup(wmem_packet_scope(), line, linelen);\r\np = args;\r\nif ((gint)strlen(args) < linelen)\r\nlinelen = (gint)strlen(args);\r\nif (!isvalid_rfc2428_delimiter(*p))\r\nreturn FALSE;\r\ndelimiter = *p;\r\nfor (n = 0; n < linelen; n++) {\r\nif (*(p+n) == delimiter)\r\ndelimiters_seen++;\r\n}\r\nif (delimiters_seen != 4)\r\nreturn FALSE;\r\ndelimiters_seen = 1;\r\nlastn = 0;\r\nfor (n=1; n < linelen; n++) {\r\nif (*(p+n) != delimiter)\r\ncontinue;\r\ndelimiters_seen++;\r\nfieldlen = n - lastn - 1;\r\nif (fieldlen<=0)\r\nreturn FALSE;\r\nfield = p + lastn + 1;\r\nif (delimiters_seen == 2) {\r\ngchar *af_str;\r\naf_str = wmem_strndup(wmem_packet_scope(), field, fieldlen);\r\n*eprt_af = atoi(af_str);\r\n}\r\nelse if (delimiters_seen == 3) {\r\ngchar *ip_str;\r\nip_str = wmem_strndup(wmem_packet_scope(), field, fieldlen);\r\nif (*eprt_af == EPRT_AF_IPv4) {\r\nif (str_to_ip(ip_str, eprt_ip))\r\nret = TRUE;\r\nelse\r\nret = FALSE;\r\n}\r\nelse if (*eprt_af == EPRT_AF_IPv6) {\r\nif (str_to_ip6(ip_str, eprt_ipv6))\r\nret = TRUE;\r\nelse\r\nret = FALSE;\r\n}\r\nelse\r\nreturn FALSE;\r\n*eprt_ip_len = fieldlen;\r\n}\r\nelse if (delimiters_seen == 4) {\r\ngchar *pt_str;\r\npt_str = wmem_strndup(wmem_packet_scope(), field, fieldlen);\r\n*ftp_port = atoi(pt_str);\r\n*ftp_port_len = fieldlen;\r\n}\r\nlastn = n;\r\n}\r\nreturn ret;\r\n}\r\nstatic gboolean\r\nparse_extended_pasv_response(const guchar *line, gint linelen, guint16 *ftp_port,\r\nguint *pasv_offset, guint *ftp_port_len)\r\n{\r\ngint n;\r\ngchar *args;\r\ngchar *p;\r\ngchar *e;\r\nguchar c;\r\ngboolean ret = FALSE;\r\ngboolean delimiters_seen = FALSE;\r\nargs = wmem_strndup(wmem_packet_scope(), line, linelen);\r\np = args;\r\nfor (; !delimiters_seen;) {\r\nguchar delimiter = '\0';\r\nwhile ((c = *p) != '\0' && (c != '('))\r\np++;\r\nif (*p == '\0') {\r\nreturn FALSE;\r\n}\r\np++;\r\nfor (n=0; n<3; n++) {\r\nif ((c = *p) != '\0') {\r\nif (delimiter == '\0' && isvalid_rfc2428_delimiter(c)) {\r\ndelimiter = c;\r\n}\r\nif (c != delimiter) {\r\nbreak;\r\n}\r\np++;\r\n}\r\nelse {\r\nbreak;\r\n}\r\n}\r\ndelimiters_seen = TRUE;\r\n}\r\nif (*p != '\0') {\r\n*ftp_port = atoi(p);\r\n*pasv_offset = (guint32)(p - args);\r\nret = TRUE;\r\nif ((e=strchr(p,')')) == NULL) {\r\nret = FALSE;\r\n}\r\nelse {\r\n*ftp_port_len = (guint)(--e - p);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\ndissect_ftp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ngboolean is_request;\r\nproto_tree *ftp_tree;\r\nproto_tree *reqresp_tree;\r\nproto_item *ti, *hidden_item;\r\ngint offset;\r\nconst guchar *line;\r\nguint32 code;\r\ngchar code_str[4];\r\ngboolean is_port_request = FALSE;\r\ngboolean is_eprt_request = FALSE;\r\ngboolean is_pasv_response = FALSE;\r\ngboolean is_epasv_response = FALSE;\r\ngint next_offset;\r\nint linelen;\r\nint tokenlen = 0;\r\nconst guchar *next_token;\r\nguint32 pasv_ip;\r\nguint32 pasv_offset;\r\nguint32 ftp_ip;\r\nguint32 ftp_ip_len;\r\nguint32 eprt_offset;\r\nguint32 eprt_af = 0;\r\nguint32 eprt_ip;\r\nguint16 eprt_ipv6[8];\r\nguint32 eprt_ip_len = 0;\r\nguint16 ftp_port;\r\nguint32 ftp_port_len;\r\naddress ftp_ip_address;\r\ngboolean ftp_nat;\r\nconversation_t *conversation;\r\ncopy_address_shallow(&ftp_ip_address, &pinfo->src);\r\nif (pinfo->match_uint == pinfo->destport)\r\nis_request = TRUE;\r\nelse\r\nis_request = FALSE;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "FTP");\r\nlinelen = tvb_find_line_end(tvb, 0, -1, &next_offset, FALSE);\r\nline = tvb_get_ptr(tvb, 0, linelen);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s: %s",\r\nis_request ? "Request" : "Response",\r\nformat_text(line, linelen));\r\nti = proto_tree_add_item(tree, proto_ftp, tvb, 0, -1, ENC_NA);\r\nftp_tree = proto_item_add_subtree(ti, ett_ftp);\r\nhidden_item = proto_tree_add_boolean(ftp_tree,\r\nhf_ftp_request, tvb, 0, 0, is_request);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_boolean(ftp_tree,\r\nhf_ftp_response, tvb, 0, 0, is_request == FALSE);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nti = proto_tree_add_format_text(ftp_tree, tvb, 0, next_offset);\r\nreqresp_tree = proto_item_add_subtree(ti, ett_ftp_reqresp);\r\nif (is_request) {\r\ntokenlen = get_token_len(line, line + linelen, &next_token);\r\nif (tokenlen != 0) {\r\nproto_tree_add_item(reqresp_tree, hf_ftp_request_command,\r\ntvb, 0, tokenlen, ENC_ASCII|ENC_NA);\r\nif (strncmp(line, "PORT", tokenlen) == 0)\r\nis_port_request = TRUE;\r\nelse if (strncmp(line, "EPRT", tokenlen) == 0)\r\nis_eprt_request = TRUE;\r\n}\r\n} else {\r\nif (linelen >= 3 && g_ascii_isdigit(line[0]) && g_ascii_isdigit(line[1])\r\n&& g_ascii_isdigit(line[2])) {\r\ntvb_get_nstringz0(tvb, 0, sizeof(code_str), code_str);\r\ncode = (guint32)strtoul(code_str, NULL, 10);\r\nproto_tree_add_uint(reqresp_tree,\r\nhf_ftp_response_code, tvb, 0, 3, code);\r\nif (code == 227)\r\nis_pasv_response = TRUE;\r\nif (code == 229)\r\nis_epasv_response = TRUE;\r\nif (linelen >= 4)\r\nnext_token = line + 4;\r\nelse\r\nnext_token = line + linelen;\r\n} else {\r\nnext_token = line;\r\n}\r\n}\r\noffset = (gint) (next_token - line);\r\nlinelen -= (int) (next_token - line);\r\nline = next_token;\r\nif (linelen != 0) {\r\nif (is_request) {\r\nproto_tree_add_item(reqresp_tree,\r\nhf_ftp_request_arg, tvb, offset,\r\nlinelen, ENC_ASCII|ENC_NA);\r\n} else {\r\nproto_tree_add_item(reqresp_tree,\r\nhf_ftp_response_arg, tvb, offset,\r\nlinelen, ENC_ASCII|ENC_NA);\r\n}\r\n}\r\noffset = next_offset;\r\nif (is_port_request) {\r\nif (parse_port_pasv(line, linelen, &ftp_ip, &ftp_port, &pasv_offset, &ftp_ip_len, &ftp_port_len)) {\r\nproto_tree_add_ipv4(reqresp_tree, hf_ftp_active_ip,\r\ntvb, pasv_offset + (tokenlen+1) , ftp_ip_len, ftp_ip);\r\nproto_tree_add_uint(reqresp_tree, hf_ftp_active_port,\r\ntvb, pasv_offset + 1 + (tokenlen+1) + ftp_ip_len, ftp_port_len, ftp_port);\r\nset_address(&ftp_ip_address, AT_IPv4, 4, (const guint8 *)&ftp_ip);\r\nftp_nat = !addresses_equal(&pinfo->src, &ftp_ip_address);\r\nif (ftp_nat) {\r\nproto_tree_add_boolean(reqresp_tree, hf_ftp_active_nat,\r\ntvb, 0, 0, ftp_nat);\r\n}\r\n}\r\n}\r\nif (is_pasv_response) {\r\nif (linelen != 0) {\r\nif (parse_port_pasv(line, linelen, &pasv_ip, &ftp_port, &pasv_offset, &ftp_ip_len, &ftp_port_len)) {\r\nproto_tree_add_ipv4(reqresp_tree, hf_ftp_pasv_ip,\r\ntvb, pasv_offset + 4, ftp_ip_len, pasv_ip);\r\nproto_tree_add_uint(reqresp_tree, hf_ftp_pasv_port,\r\ntvb, pasv_offset + 4 + 1 + ftp_ip_len, ftp_port_len, ftp_port);\r\nset_address(&ftp_ip_address, AT_IPv4, 4,\r\n(const guint8 *)&pasv_ip);\r\nftp_nat = !addresses_equal(&pinfo->src, &ftp_ip_address);\r\nif (ftp_nat) {\r\nproto_tree_add_boolean(reqresp_tree, hf_ftp_pasv_nat,\r\ntvb, 0, 0, ftp_nat);\r\n}\r\nconversation = find_conversation(pinfo->num, &ftp_ip_address,\r\n&pinfo->dst, PT_TCP, ftp_port, 0,\r\nNO_PORT_B);\r\nif (conversation == NULL) {\r\nconversation = conversation_new(\r\npinfo->num, &ftp_ip_address, &pinfo->dst,\r\nPT_TCP, ftp_port, 0, NO_PORT2);\r\nconversation_set_dissector(conversation, ftpdata_handle);\r\n}\r\n}\r\n}\r\n}\r\nif (is_eprt_request) {\r\nif (parse_eprt_request(line, linelen,\r\n&eprt_af, &eprt_ip, eprt_ipv6, &ftp_port,\r\n&eprt_ip_len, &ftp_port_len)) {\r\neprt_offset = tokenlen + 1 + 1;\r\nproto_tree_add_uint(reqresp_tree, hf_ftp_eprt_af, tvb,\r\neprt_offset, 1, eprt_af);\r\neprt_offset += 1 + 1;\r\nif (eprt_af == EPRT_AF_IPv4) {\r\nproto_tree_add_ipv4(reqresp_tree, hf_ftp_eprt_ip,\r\ntvb, eprt_offset, eprt_ip_len, eprt_ip);\r\nset_address(&ftp_ip_address, AT_IPv4, 4,\r\n(const guint8 *)&eprt_ip);\r\n}\r\nelse if (eprt_af == EPRT_AF_IPv6) {\r\nproto_tree_add_ipv6(reqresp_tree, hf_ftp_eprt_ipv6,\r\ntvb, eprt_offset, eprt_ip_len, (const struct e_in6_addr *)eprt_ipv6);\r\nset_address(&ftp_ip_address, AT_IPv6, 16, eprt_ipv6);\r\n}\r\neprt_offset += eprt_ip_len + 1;\r\nproto_tree_add_uint(reqresp_tree, hf_ftp_eprt_port,\r\ntvb, eprt_offset, ftp_port_len, ftp_port);\r\nconversation = find_conversation(pinfo->num,\r\n&pinfo->src, &ftp_ip_address,\r\nPT_TCP, ftp_port, 0, NO_PORT_B);\r\nif (conversation == NULL) {\r\nconversation = conversation_new(\r\npinfo->num, &pinfo->src, &ftp_ip_address,\r\nPT_TCP, ftp_port, 0, NO_PORT2);\r\nconversation_set_dissector(conversation,\r\nftpdata_handle);\r\n}\r\n}\r\nelse {\r\nproto_tree_add_expert(reqresp_tree, pinfo, &ei_ftp_eprt_args_invalid,\r\ntvb, offset - linelen - 1, linelen);\r\n}\r\n}\r\nif (is_epasv_response) {\r\nif (linelen != 0) {\r\nproto_item *addr_it;\r\nif (parse_extended_pasv_response(line, linelen,\r\n&ftp_port, &pasv_offset, &ftp_port_len)) {\r\nif (ftp_ip_address.type == AT_IPv4) {\r\nguint32 addr;\r\nmemcpy(&addr, ftp_ip_address.data, 4);\r\naddr_it = proto_tree_add_ipv4(reqresp_tree,\r\nhf_ftp_epsv_ip, tvb, 0, 0, addr);\r\nPROTO_ITEM_SET_GENERATED(addr_it);\r\n}\r\nelse if (ftp_ip_address.type == AT_IPv6) {\r\naddr_it = proto_tree_add_ipv6(reqresp_tree,\r\nhf_ftp_epsv_ipv6, tvb, 0, 0,\r\n(const struct e_in6_addr *)ftp_ip_address.data);\r\nPROTO_ITEM_SET_GENERATED(addr_it);\r\n}\r\nproto_tree_add_uint(reqresp_tree,\r\nhf_ftp_epsv_port, tvb, pasv_offset + 4,\r\nftp_port_len, ftp_port);\r\nconversation = find_conversation(pinfo->num, &ftp_ip_address,\r\n&pinfo->dst, PT_TCP, ftp_port, 0,\r\nNO_PORT_B);\r\nif (conversation == NULL) {\r\nconversation = conversation_new(\r\npinfo->num, &ftp_ip_address, &pinfo->dst,\r\nPT_TCP, ftp_port, 0, NO_PORT2);\r\nconversation_set_dissector(conversation,\r\nftpdata_handle);\r\n}\r\n}\r\nelse {\r\nproto_tree_add_expert(reqresp_tree, pinfo, &ei_ftp_epsv_args_invalid,\r\ntvb, offset - linelen - 1, linelen);\r\n}\r\n}\r\n}\r\nwhile (tvb_offset_exists(tvb, offset)) {\r\ntvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\r\nproto_tree_add_format_text(ftp_tree, tvb, offset,\r\nnext_offset - offset);\r\noffset = next_offset;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_ftpdata(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nint data_length;\r\ngboolean is_text = TRUE;\r\ngint check_chars, i;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "FTP-DATA");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "FTP Data: %u bytes",\r\ntvb_reported_length(tvb));\r\ndata_length = tvb_captured_length(tvb);\r\nti = proto_tree_add_item(tree, proto_ftp_data, tvb, 0, -1, ENC_NA);\r\ncheck_chars = MIN(10, data_length);\r\nfor (i=0; i < check_chars; i++) {\r\nif (!g_ascii_isprint(tvb_get_guint8(tvb, i))) {\r\nis_text = FALSE;\r\nbreak;\r\n}\r\n}\r\nif (is_text) {\r\nproto_item_append_text(ti, " (%s)", tvb_format_text(tvb, 0, MIN(data_length, ITEM_LABEL_LENGTH)));\r\n}\r\nelse {\r\nproto_item_append_text(ti, " (%u bytes data)", data_length);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ftp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ftp_response,\r\n{ "Response", "ftp.response",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"TRUE if FTP response", HFILL }},\r\n{ &hf_ftp_request,\r\n{ "Request", "ftp.request",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"TRUE if FTP request", HFILL }},\r\n{ &hf_ftp_request_command,\r\n{ "Request command", "ftp.request.command",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ftp_request_arg,\r\n{ "Request arg", "ftp.request.arg",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ftp_response_code,\r\n{ "Response code", "ftp.response.code",\r\nFT_UINT32, BASE_DEC|BASE_EXT_STRING, &response_table_ext, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ftp_response_arg,\r\n{ "Response arg", "ftp.response.arg",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ftp_pasv_ip,\r\n{ "Passive IP address", "ftp.passive.ip",\r\nFT_IPv4, BASE_NONE, NULL,0x0,\r\n"Passive IP address (check NAT)", HFILL}},\r\n{ &hf_ftp_pasv_port,\r\n{ "Passive port", "ftp.passive.port",\r\nFT_UINT16, BASE_DEC, NULL,0x0,\r\n"Passive FTP server port", HFILL }},\r\n{ &hf_ftp_pasv_nat,\r\n{"Passive IP NAT", "ftp.passive.nat",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"NAT is active SIP and passive IP different", HFILL }},\r\n{ &hf_ftp_active_ip,\r\n{ "Active IP address", "ftp.active.cip",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\n"Active FTP client IP address", HFILL }},\r\n{ &hf_ftp_active_port,\r\n{"Active port", "ftp.active.port",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Active FTP client port", HFILL }},\r\n{ &hf_ftp_active_nat,\r\n{ "Active IP NAT", "ftp.active.nat",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"NAT is active", HFILL}},\r\n{ &hf_ftp_eprt_af,\r\n{ "Extended active address family", "ftp.eprt.af",\r\nFT_UINT8, BASE_DEC, VALS(eprt_af_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_ftp_eprt_ip,\r\n{ "Extended active IP address", "ftp.eprt.ip",\r\nFT_IPv4, BASE_NONE, NULL, 0,\r\n"Extended active FTP client IPv4 address", HFILL }},\r\n{ &hf_ftp_eprt_ipv6,\r\n{ "Extended active IPv6 address", "ftp.eprt.ipv6",\r\nFT_IPv6, BASE_NONE, NULL, 0,\r\n"Extended active FTP client IPv6 address", HFILL }},\r\n{ &hf_ftp_eprt_port,\r\n{ "Extended active port", "ftp.eprt.port",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Extended active FTP client listener port", HFILL }},\r\n{ &hf_ftp_epsv_ip,\r\n{ "Extended passive IPv4 address", "ftp.epsv.ip",\r\nFT_IPv4, BASE_NONE, NULL, 0,\r\n"Extended passive FTP server IPv4 address", HFILL }},\r\n{ &hf_ftp_epsv_ipv6,\r\n{ "Extended passive IPv6 address", "ftp.epsv.ipv6",\r\nFT_IPv6, BASE_NONE, NULL, 0,\r\n"Extended passive FTP server IPv6 address", HFILL }},\r\n{ &hf_ftp_epsv_port,\r\n{ "Extended passive port", "ftp.epsv.port",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Extended passive FTP server port", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ftp,\r\n&ett_ftp_reqresp\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_ftp_eprt_args_invalid, { "ftp.eprt.args_invalid", PI_MALFORMED, PI_WARN, "EPRT arguments must have the form: |<family>|<addr>|<port>|", EXPFILL }},\r\n{ &ei_ftp_epsv_args_invalid, { "ftp.epsv.args_invalid", PI_MALFORMED, PI_WARN, "EPSV arguments must have the form (|||<port>|)", EXPFILL }},\r\n};\r\nexpert_module_t* expert_ftp;\r\nproto_ftp = proto_register_protocol("File Transfer Protocol (FTP)", "FTP", "ftp");\r\nregister_dissector("ftp", dissect_ftp, proto_ftp);\r\nproto_ftp_data = proto_register_protocol("FTP Data", "FTP-DATA", "ftp-data");\r\nregister_dissector("ftp-data", dissect_ftpdata, proto_ftp_data);\r\nproto_register_field_array(proto_ftp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_ftp = expert_register_protocol(proto_ftp);\r\nexpert_register_field_array(expert_ftp, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_ftp(void)\r\n{\r\ndissector_handle_t ftp_handle;\r\nftpdata_handle = find_dissector("ftp-data");\r\ndissector_add_uint("tcp.port", TCP_PORT_FTPDATA, ftpdata_handle);\r\nftp_handle = find_dissector("ftp");\r\ndissector_add_uint("tcp.port", TCP_PORT_FTP, ftp_handle);\r\n}
