static int\r\nzebra_route_nexthop(proto_tree *tree, tvbuff_t *tvb, int offset, guint16 len)\r\n{\r\nguint8 nexthoptype, nexthopcount, interfacenamelength;\r\nnexthopcount = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(tree, hf_zebra_nexthopnum,\r\ntvb, offset, 1, nexthopcount);\r\noffset += 1;\r\nif (nexthopcount > len)\r\nreturn offset;\r\nwhile (nexthopcount--) {\r\nnexthoptype = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\nif (nexthoptype == ZEBRA_NEXTHOP_TYPE_IFINDEX ||\r\nnexthoptype == ZEBRA_NEXTHOP_TYPE_IPV4_IFINDEX ||\r\nnexthoptype == ZEBRA_NEXTHOP_TYPE_IPV6_IFINDEX){\r\nproto_tree_add_item(tree,hf_zebra_index, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nif (nexthoptype == ZEBRA_NEXTHOP_TYPE_IFNAME ||\r\nnexthoptype == ZEBRA_NEXTHOP_TYPE_IPV4_IFNAME ||\r\nnexthoptype == ZEBRA_NEXTHOP_TYPE_IPV6_IFNAME) {\r\ninterfacenamelength = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_zebra_interface,\r\ntvb, offset, interfacenamelength,\r\nENC_ASCII|ENC_NA);\r\noffset += interfacenamelength;\r\n}\r\nif (nexthoptype == ZEBRA_NEXTHOP_TYPE_IPV6 ||\r\nnexthoptype == ZEBRA_NEXTHOP_TYPE_IPV6_IFINDEX ||\r\nnexthoptype == ZEBRA_NEXTHOP_TYPE_IPV6_IFNAME) {\r\nproto_tree_add_item(tree, hf_zebra_nexthop6,\r\ntvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n}\r\nif (nexthoptype == ZEBRA_NEXTHOP_TYPE_IPV4 ||\r\nnexthoptype == ZEBRA_NEXTHOP_TYPE_IPV4_IFINDEX ||\r\nnexthoptype == ZEBRA_NEXTHOP_TYPE_IPV4_IFNAME) {\r\nproto_tree_add_item(tree, hf_zebra_nexthop4,\r\ntvb, offset, 4, ENC_NA);\r\noffset += 4;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\nzebra_route_ifindex(proto_tree *tree, tvbuff_t *tvb, int offset, guint16 len)\r\n{\r\nguint16 indexcount = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(tree, hf_zebra_indexnum,\r\ntvb, offset, 1, indexcount);\r\noffset += 1;\r\nif (indexcount > len)\r\nreturn offset;\r\nwhile (indexcount--) {\r\nproto_tree_add_item(tree, hf_zebra_index, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint8\r\nzebra_route_message(proto_tree *tree, tvbuff_t *tvb, int offset)\r\n{\r\nstatic const int * flags[] = {\r\n&hf_zebra_msg_nexthop,\r\n&hf_zebra_msg_index,\r\n&hf_zebra_msg_distance,\r\n&hf_zebra_msg_metric,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(tree, tvb, offset, hf_zebra_message, ett_message, flags, ENC_NA);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic int\r\nzebra_route(proto_tree *tree, tvbuff_t *tvb, int offset, guint16 len,\r\nguint8 family, guint8 version)\r\n{\r\nguint32 prefix4;\r\nguint8 message, prefixlen, buffer6[16];\r\nif (version == 0) {\r\nproto_tree_add_item(tree, hf_zebra_type_v0, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\n} else {\r\nproto_tree_add_item(tree, hf_zebra_type_v1, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\n}\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_zebra_rtflags, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nmessage = tvb_get_guint8(tvb, offset);\r\noffset = zebra_route_message(tree, tvb, offset);\r\nif (version > 1) {\r\nproto_tree_add_item(tree, hf_zebra_route_safi, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n}\r\nprefixlen = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(tree, hf_zebra_prefixlen, tvb,\r\noffset, 1, prefixlen);\r\noffset += 1;\r\nif (family == ZEBRA_FAMILY_IPV6) {\r\nmemset(buffer6, '\0', sizeof buffer6);\r\ntvb_memcpy(tvb, buffer6, offset,\r\nMIN((unsigned) PSIZE(prefixlen), sizeof buffer6));\r\nproto_tree_add_ipv6(tree, hf_zebra_prefix6,\r\ntvb, offset, PSIZE(prefixlen), (struct e_in6_addr *)buffer6);\r\n}else {\r\nprefix4 = 0;\r\ntvb_memcpy(tvb, (guint8 *)&prefix4, offset,\r\nMIN((unsigned) PSIZE(prefixlen), sizeof prefix4));\r\nproto_tree_add_ipv4(tree, hf_zebra_prefix4,\r\ntvb, offset, PSIZE(prefixlen), prefix4);\r\n}\r\noffset += PSIZE(prefixlen);\r\nif (message & ZEBRA_ZAPI_MESSAGE_NEXTHOP) {\r\noffset = zebra_route_nexthop(tree, tvb, offset, len);\r\n}\r\nif (message & ZEBRA_ZAPI_MESSAGE_IFINDEX) {\r\noffset = zebra_route_ifindex(tree, tvb, offset, len);\r\n}\r\nif (message & ZEBRA_ZAPI_MESSAGE_DISTANCE) {\r\nproto_tree_add_item(tree, hf_zebra_distance,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\n}\r\nif (message & ZEBRA_ZAPI_MESSAGE_METRIC) {\r\nproto_tree_add_item(tree, hf_zebra_metric,\r\ntvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\nzebra_interface_address(proto_tree *tree, tvbuff_t *tvb, int offset)\r\n{\r\nguint8 family;\r\nproto_tree_add_item(tree, hf_zebra_index, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_zebra_flags, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_zebra_family, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\nfamily = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\nif (family == ZEBRA_FAMILY_IPV4) {\r\nproto_tree_add_item(tree, hf_zebra_prefix4,\r\ntvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nelse if (family == ZEBRA_FAMILY_IPV6) {\r\nproto_tree_add_item(tree, hf_zebra_prefix6,\r\ntvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n}\r\nelse\r\nreturn offset;\r\nproto_tree_add_item(tree, hf_zebra_prefixlen, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif (family == ZEBRA_FAMILY_IPV4) {\r\nproto_tree_add_item(tree, hf_zebra_dest4,\r\ntvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nelse if (family == ZEBRA_FAMILY_IPV6) {\r\nproto_tree_add_item(tree, hf_zebra_dest6,\r\ntvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\nzebra_interface_del(proto_tree *tree, tvbuff_t *tvb, int offset)\r\n{\r\nproto_tree_add_item(tree, hf_zebra_interface,\r\ntvb, offset, INTERFACE_NAMSIZ, ENC_ASCII|ENC_NA);\r\noffset += INTERFACE_NAMSIZ;\r\nproto_tree_add_item(tree, hf_zebra_index, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nreturn offset;\r\n}\r\nstatic int\r\nzebra_interface(proto_tree *tree, tvbuff_t *tvb, int offset, guint8 version)\r\n{\r\ngint maclen;\r\nproto_tree_add_item(tree, hf_zebra_interface,\r\ntvb, offset, INTERFACE_NAMSIZ, ENC_ASCII|ENC_NA);\r\noffset += INTERFACE_NAMSIZ;\r\nproto_tree_add_item(tree, hf_zebra_index, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_zebra_intstatus, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif (version != 0) {\r\nproto_tree_add_item(tree, hf_zebra_intflags, tvb,\r\noffset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\n} else {\r\nproto_tree_add_item(tree, hf_zebra_intflags, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nproto_tree_add_item(tree, hf_zebra_metric, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_zebra_mtu, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nif (version != 0) {\r\nproto_tree_add_item(tree, hf_zebra_mtu6, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nproto_tree_add_item(tree, hf_zebra_bandwidth, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nif (version != 0) {\r\nmaclen = (gint)tvb_get_ntohl(tvb, offset);\r\noffset += 4;\r\nif (maclen > 0)\r\nproto_tree_add_item(tree, hf_zebra_mac, tvb,\r\noffset, maclen, ENC_NA);\r\noffset += maclen;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\nzebra_nexthop_lookup(proto_tree *tree, tvbuff_t *tvb, int offset, guint16 len,\r\nguint8 family)\r\n{\r\nif (family == ZEBRA_FAMILY_IPV6) {\r\nproto_tree_add_item(tree, hf_zebra_dest6, tvb, offset, 16,\r\nENC_NA);\r\noffset += 16;\r\n}else {\r\nproto_tree_add_item(tree, hf_zebra_dest4, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nproto_tree_add_item(tree, hf_zebra_metric,tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\noffset = zebra_route_nexthop(tree, tvb, offset, len);\r\nreturn offset;\r\n}\r\nstatic int\r\nzerba_router_update(proto_tree *tree, tvbuff_t *tvb, int offset)\r\n{\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_zebra_routeridaddress, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_zebra_routeridmask, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_zebra_request(proto_tree *tree, gboolean request, tvbuff_t *tvb,\r\nint offset, guint16 len, guint16 command, guint8 version)\r\n{\r\nproto_tree_add_uint(tree, hf_zebra_len, tvb, offset, 2, len);\r\noffset += 2;\r\nif (version != 0) {\r\nproto_tree_add_item(tree, hf_zebra_marker, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_uint(tree, hf_zebra_version, tvb, offset, 1,\r\nversion);\r\noffset += 1;\r\nproto_tree_add_uint(tree, hf_zebra_command, tvb, offset, 2,\r\ncommand);\r\noffset += 2;\r\n} else {\r\nproto_tree_add_uint(tree, hf_zebra_command, tvb, offset, 1,\r\ncommand);\r\noffset += 1;\r\n}\r\nswitch(command) {\r\ncase ZEBRA_INTERFACE_ADD:\r\ncase ZEBRA_INTERFACE_UP:\r\ncase ZEBRA_INTERFACE_DOWN:\r\nif (request)\r\nbreak;\r\noffset = zebra_interface(tree, tvb, offset, version);\r\nbreak;\r\ncase ZEBRA_INTERFACE_DELETE:\r\noffset = zebra_interface_del(tree, tvb, offset);\r\nbreak;\r\ncase ZEBRA_INTERFACE_ADDRESS_ADD:\r\ncase ZEBRA_INTERFACE_ADDRESS_DELETE:\r\noffset = zebra_interface_address(tree, tvb, offset);\r\nbreak;\r\ncase ZEBRA_IPV4_ROUTE_ADD:\r\ncase ZEBRA_IPV4_ROUTE_DELETE:\r\noffset = zebra_route(tree, tvb, offset, len,\r\nZEBRA_FAMILY_IPV4, version);\r\nbreak;\r\ncase ZEBRA_IPV6_ROUTE_ADD:\r\ncase ZEBRA_IPV6_ROUTE_DELETE:\r\noffset = zebra_route(tree, tvb, offset, len,\r\nZEBRA_FAMILY_IPV6, version);\r\nbreak;\r\ncase ZEBRA_REDISTRIBUTE_ADD:\r\ncase ZEBRA_REDISTRIBUTE_DEFAULT_ADD:\r\nif (version == 0) {\r\nproto_tree_add_item(tree, hf_zebra_type_v0, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\n} else {\r\nproto_tree_add_item(tree, hf_zebra_type_v1, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\n}\r\noffset = 1;\r\nbreak;\r\ncase ZEBRA_IPV4_IMPORT_LOOKUP:\r\ncase ZEBRA_IPV4_NEXTHOP_LOOKUP:\r\noffset = zebra_nexthop_lookup(tree, tvb, offset, len,\r\nZEBRA_FAMILY_IPV4);\r\nbreak;\r\ncase ZEBRA_IPV6_IMPORT_LOOKUP:\r\ncase ZEBRA_IPV6_NEXTHOP_LOOKUP:\r\noffset = zebra_nexthop_lookup(tree, tvb, offset, len,\r\nZEBRA_FAMILY_IPV6);\r\nbreak;\r\ncase ZEBRA_ROUTER_ID_UPDATE:\r\noffset = zerba_router_update(tree, tvb, offset);\r\nbreak;\r\ncase ZEBRA_ROUTER_ID_ADD:\r\ncase ZEBRA_ROUTER_ID_DELETE:\r\ncase ZEBRA_REDISTRIBUTE_DEFAULT_DELETE:\r\nbreak;\r\ncase ZEBRA_REDISTRIBUTE_DELETE:\r\nif (version > 0) {\r\nproto_tree_add_item(tree, hf_zebra_type_v1, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase ZEBRA_HELLO:\r\nproto_tree_add_item(tree, hf_zebra_redist_default, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_zebra(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *zebra_tree;\r\ngboolean request;\r\nint left, offset;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ZEBRA");\r\nrequest = (pinfo->destport == pinfo->match_uint);\r\nleft = tvb_reported_length(tvb);\r\noffset = 0;\r\ncol_set_str(pinfo->cinfo, COL_INFO,\r\nrequest? "Zebra Request" : "Zebra Reply");\r\n{\r\nti = proto_tree_add_item(tree, proto_zebra, tvb, offset, -1,\r\nENC_NA);\r\nzebra_tree = proto_item_add_subtree(ti, ett_zebra);\r\nti = proto_tree_add_boolean(zebra_tree, hf_zebra_request,\r\ntvb, offset, 0, request);\r\nPROTO_ITEM_SET_HIDDEN(ti);\r\nfor (;;) {\r\nguint8 headermarker, version;\r\nguint16 command, len;\r\nproto_tree *zebra_request_tree;\r\nif (left < 3)\r\nbreak;\r\nlen = tvb_get_ntohs(tvb, offset);\r\nif (len < 3)\r\nbreak;\r\nheadermarker = tvb_get_guint8(tvb,offset+2);\r\nif (headermarker != 0xFF) {\r\ncommand = headermarker;\r\nversion = 0;\r\n} else {\r\nversion = tvb_get_guint8(tvb, offset+3);\r\ncommand = tvb_get_ntohs(tvb, offset+4);\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ": %s",\r\nval_to_str(command, messages, "Command Type 0x%02d"));\r\nti = proto_tree_add_uint(zebra_tree,\r\nhf_zebra_command, tvb,\r\noffset, len, command);\r\nzebra_request_tree = proto_item_add_subtree(ti,\r\nett_zebra_request);\r\ndissect_zebra_request(zebra_request_tree, request, tvb,\r\noffset, len, command, version);\r\noffset += len;\r\nleft -= len;\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_zebra(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_zebra_len,\r\n{ "Length", "zebra.len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Length of Zebra request", HFILL }},\r\n{ &hf_zebra_version,\r\n{ "Version", "zebra.version",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Zerbra srv version", HFILL }},\r\n{ &hf_zebra_marker,\r\n{ "Marker", "zebra.marker",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\n"Zerbra srv marker", HFILL }},\r\n{ &hf_zebra_request,\r\n{ "Request", "zebra.request",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"TRUE if Zebra request", HFILL }},\r\n{ &hf_zebra_command,\r\n{ "Command", "zebra.command",\r\nFT_UINT8, BASE_DEC, VALS(messages), 0x0,\r\n"Zebra command", HFILL }},\r\n{ &hf_zebra_interface,\r\n{ "Interface", "zebra.interface",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Interface name of Zebra request", HFILL }},\r\n{ &hf_zebra_index,\r\n{ "Index", "zebra.index",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Index of interface", HFILL }},\r\n{ &hf_zebra_intstatus,\r\n{ "Status", "zebra.intstatus",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Status of interface", HFILL}},\r\n{ &hf_zebra_indexnum,\r\n{ "Index Number", "zebra.indexnum",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Number of indices for route", HFILL }},\r\n{ &hf_zebra_intflags,\r\n{ "Flags", "zebra.intflags",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\n"Flags of interface", HFILL }},\r\n{ &hf_zebra_rtflags,\r\n{ "Flags", "zebra.rtflags",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Flags of route", HFILL }},\r\n{ &hf_zebra_message,\r\n{ "Message", "zebra.message",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Message type of route", HFILL }},\r\n{ &hf_zebra_route_safi,\r\n{ "SAFI", "zebra.safi",\r\nFT_UINT16, BASE_DEC, VALS(safi), 0x0,\r\n"Subsequent Address Family Identifier", HFILL }},\r\n{ &hf_zebra_msg_nexthop,\r\n{ "Message Nexthop", "zebra.message.nexthop",\r\nFT_BOOLEAN, 8, NULL, ZEBRA_ZAPI_MESSAGE_NEXTHOP,\r\n"Message contains nexthop", HFILL }},\r\n{ &hf_zebra_msg_index,\r\n{ "Message Index", "zebra.message.index",\r\nFT_BOOLEAN, 8, NULL, ZEBRA_ZAPI_MESSAGE_IFINDEX,\r\n"Message contains index", HFILL }},\r\n{ &hf_zebra_msg_distance,\r\n{ "Message Distance", "zebra.message.distance",\r\nFT_BOOLEAN, 8, NULL, ZEBRA_ZAPI_MESSAGE_DISTANCE,\r\n"Message contains distance", HFILL }},\r\n{ &hf_zebra_msg_metric,\r\n{ "Message Metric", "zebra.message.metric",\r\nFT_BOOLEAN, 8, NULL, ZEBRA_ZAPI_MESSAGE_METRIC,\r\n"Message contains metric", HFILL }},\r\n{ &hf_zebra_type_v0,\r\n{ "Type", "zebra.type",\r\nFT_UINT8, BASE_DEC, VALS(routes_v0), 0x0,\r\n"Type of route", HFILL }},\r\n{ &hf_zebra_type_v1,\r\n{ "Type", "zebra.type",\r\nFT_UINT8, BASE_DEC, VALS(routes_v1), 0x0,\r\n"Type of route", HFILL }},\r\n{ &hf_zebra_distance,\r\n{ "Distance", "zebra.distance",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Distance of route", HFILL }},\r\n{ &hf_zebra_metric,\r\n{ "Metric", "zebra.metric",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Metric of interface or route", HFILL }},\r\n{ &hf_zebra_mtu,\r\n{ "MTU", "zebra.mtu",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"MTU of interface", HFILL }},\r\n{ &hf_zebra_mtu6,\r\n{ "MTUv6", "zebra.mtu6",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"MTUv6 of interface", HFILL }},\r\n{ &hf_zebra_bandwidth,\r\n{ "Bandwidth", "zebra.bandwidth",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Bandwidth of interface", HFILL }},\r\n{ &hf_zebra_family,\r\n{ "Family", "zebra.family",\r\nFT_UINT8, BASE_DEC, VALS(families), 0x0,\r\n"Family of IP address", HFILL }},\r\n{ &hf_zebra_flags,\r\n{ "Flags", "zebra.flags",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Flags of Address Info", HFILL }},\r\n{ &hf_zebra_dest4,\r\n{ "Destination", "zebra.dest4",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\n"Destination IPv4 field", HFILL }},\r\n{ &hf_zebra_dest6,\r\n{ "Destination", "zebra.dest6",\r\nFT_IPv6, BASE_NONE, NULL, 0x0,\r\n"Destination IPv6 field", HFILL }},\r\n{ &hf_zebra_nexthopnum,\r\n{ "Nexthop Number", "zebra.nexthopnum",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Number of nexthops in route", HFILL }},\r\n{ &hf_zebra_nexthop4,\r\n{ "Nexthop", "zebra.nexthop4",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\n"Nethop IPv4 field of route", HFILL }},\r\n{ &hf_zebra_nexthop6,\r\n{ "Nexthop", "zebra.nexthop6",\r\nFT_IPv6, BASE_NONE, NULL, 0x0,\r\n"Nethop IPv6 field of route", HFILL }},\r\n{ &hf_zebra_prefixlen,\r\n{ "Prefix length", "zebra.prefixlen",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_zebra_prefix4,\r\n{ "Prefix", "zebra.prefix4",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\n"Prefix IPv4", HFILL }},\r\n{ &hf_zebra_prefix6,\r\n{ "Prefix", "zebra.prefix6",\r\nFT_IPv6, BASE_NONE, NULL, 0x0,\r\n"Prefix IPv6", HFILL }},\r\n{ &hf_zebra_routeridaddress,\r\n{ "Router ID address", "zebra.routerIDAddress",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\n"Router ID", HFILL }},\r\n{ &hf_zebra_routeridmask,\r\n{ "Router ID mask", "zebra.routerIDMask",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"netmask of Router ID", HFILL }},\r\n{ &hf_zebra_mac,\r\n{ "MAC address", "zebra.macaddress",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\n"MAC address of interface", HFILL }},\r\n{ &hf_zebra_redist_default,\r\n{ "Redistribute default", "zebra.redist_default",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"TRUE if redistribute default", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_zebra,\r\n&ett_zebra_request,\r\n&ett_message,\r\n};\r\nproto_zebra = proto_register_protocol("Zebra Protocol", "ZEBRA", "zebra");\r\nproto_register_field_array(proto_zebra, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_zebra(void)\r\n{\r\ndissector_handle_t zebra_handle;\r\nzebra_handle = create_dissector_handle(dissect_zebra, proto_zebra);\r\ndissector_add_uint("tcp.port", TCP_PORT_ZEBRA, zebra_handle);\r\n}
