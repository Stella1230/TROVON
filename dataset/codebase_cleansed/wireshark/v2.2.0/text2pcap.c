static guint32\r\nparse_num (const char *str, int offset)\r\n{\r\nguint32 num;\r\nchar *c;\r\nif (str == NULL) {\r\nfprintf(stderr, "FATAL ERROR: str is NULL\n");\r\nexit(1);\r\n}\r\nnum = (guint32)strtoul(str, &c, offset ? offset_base : 16);\r\nif (c == str) {\r\nfprintf(stderr, "FATAL ERROR: Bad hex number? [%s]\n", str);\r\nexit(1);\r\n}\r\nreturn num;\r\n}\r\nstatic void\r\nwrite_byte (const char *str)\r\n{\r\nguint32 num;\r\nnum = parse_num(str, FALSE);\r\npacket_buf[curr_offset] = (guint8) num;\r\ncurr_offset++;\r\nif (curr_offset - header_length >= max_offset)\r\nstart_new_packet(TRUE);\r\n}\r\nstatic void\r\nwrite_bytes (const char bytes[], guint32 nbytes)\r\n{\r\nguint32 i;\r\nif (curr_offset + nbytes < MAX_PACKET) {\r\nfor (i = 0; i < nbytes; i++) {\r\npacket_buf[curr_offset] = bytes[i];\r\ncurr_offset++;\r\n}\r\n}\r\n}\r\nstatic void\r\nunwrite_bytes (guint32 nbytes)\r\n{\r\ncurr_offset -= nbytes;\r\n}\r\nstatic guint16\r\nin_checksum (void *buf, guint32 count)\r\n{\r\nguint32 sum = 0;\r\nguint16 *addr = (guint16 *)buf;\r\nwhile (count > 1) {\r\nsum += g_ntohs(* (guint16 *) addr);\r\naddr++;\r\ncount -= 2;\r\n}\r\nif (count > 0)\r\nsum += g_ntohs(* (guint8 *) addr);\r\nwhile (sum>>16)\r\nsum = (sum & 0xffff) + (sum >> 16);\r\nsum = ~sum;\r\nreturn g_htons(sum);\r\n}\r\nstatic guint32\r\ncrc32c (const guint8* buf, unsigned int len, guint32 crc32_init)\r\n{\r\nunsigned int i;\r\nguint32 crc;\r\ncrc = crc32_init;\r\nfor (i = 0; i < len; i++)\r\nCRC32C(crc, buf[i]);\r\nreturn crc;\r\n}\r\nstatic guint32\r\nfinalize_crc32c (guint32 crc)\r\n{\r\nguint32 result;\r\nguint8 byte0,byte1,byte2,byte3;\r\nresult = ~crc;\r\nbyte0 = result & 0xff;\r\nbyte1 = (result>>8) & 0xff;\r\nbyte2 = (result>>16) & 0xff;\r\nbyte3 = (result>>24) & 0xff;\r\nresult = ((byte0 << 24) | (byte1 << 16) | (byte2 << 8) | byte3);\r\nreturn result;\r\n}\r\nstatic guint16\r\nnumber_of_padding_bytes (guint32 length)\r\n{\r\nguint16 remainder;\r\nremainder = length % 4;\r\nif (remainder == 0)\r\nreturn 0;\r\nelse\r\nreturn 4 - remainder;\r\n}\r\nstatic void\r\nwrite_current_packet (gboolean cont)\r\n{\r\nguint32 length = 0;\r\nguint16 padding_length = 0;\r\nint err;\r\nguint16 ihatemacros;\r\ngboolean success;\r\nif (curr_offset > header_length) {\r\ngboolean isInbound = has_direction && (direction == 2);\r\nif (hdr_ipv6) {\r\nhdr_ethernet_proto = 0x86DD;\r\nhdr_ip = FALSE;\r\n}\r\nlength = curr_offset;\r\nif (hdr_sctp) {\r\npadding_length = number_of_padding_bytes(length - header_length );\r\n} else {\r\npadding_length = 0;\r\n}\r\ncurr_offset = 0;\r\nif (hdr_ethernet) {\r\nHDR_ETHERNET.l3pid = g_htons(hdr_ethernet_proto);\r\nwrite_bytes((const char *)&HDR_ETHERNET, sizeof(HDR_ETHERNET));\r\n}\r\nif (hdr_ip) {\r\nif (isInbound) {\r\nHDR_IP.src_addr = hdr_ip_dest_addr ? hdr_ip_dest_addr : IP_DST;\r\nHDR_IP.dest_addr = hdr_ip_src_addr? hdr_ip_src_addr : IP_SRC;\r\n}\r\nelse {\r\nHDR_IP.src_addr = hdr_ip_src_addr? hdr_ip_src_addr : IP_SRC;\r\nHDR_IP.dest_addr = hdr_ip_dest_addr ? hdr_ip_dest_addr : IP_DST;\r\n}\r\nHDR_IP.packet_length = g_htons(length - ip_offset + padding_length);\r\nHDR_IP.protocol = (guint8) hdr_ip_proto;\r\nHDR_IP.hdr_checksum = 0;\r\nHDR_IP.hdr_checksum = in_checksum(&HDR_IP, sizeof(HDR_IP));\r\nwrite_bytes((const char *)&HDR_IP, sizeof(HDR_IP));\r\n} else if (hdr_ipv6) {\r\nif (memcmp(isInbound ? &hdr_ipv6_dest_addr : &hdr_ipv6_src_addr, &NO_IPv6_ADDRESS, sizeof(struct e_in6_addr)))\r\nmemcpy(&HDR_IPv6.ip6_src, isInbound ? &hdr_ipv6_dest_addr : &hdr_ipv6_src_addr, sizeof(struct e_in6_addr));\r\nif (memcmp(isInbound ? &hdr_ipv6_src_addr : &hdr_ipv6_dest_addr, &NO_IPv6_ADDRESS, sizeof(struct e_in6_addr)))\r\nmemcpy(&HDR_IPv6.ip6_dst, isInbound ? &hdr_ipv6_src_addr : &hdr_ipv6_dest_addr, sizeof(struct e_in6_addr));\r\nHDR_IPv6.ip6_ctlun.ip6_un2_vfc &= 0x0F;\r\nHDR_IPv6.ip6_ctlun.ip6_un2_vfc |= (6<< 4);\r\nHDR_IPv6.ip6_ctlun.ip6_un1.ip6_un1_plen = g_htons(length - ip_offset + padding_length);\r\nHDR_IPv6.ip6_ctlun.ip6_un1.ip6_un1_nxt = (guint8) hdr_ip_proto;\r\nHDR_IPv6.ip6_ctlun.ip6_un1.ip6_un1_hlim = 32;\r\nwrite_bytes((const char *)&HDR_IPv6, sizeof(HDR_IPv6));\r\npseudoh6.src_addr6 = HDR_IPv6.ip6_src;\r\npseudoh6.dst_addr6 = HDR_IPv6.ip6_dst;\r\npseudoh6.zero = 0;\r\npseudoh6.protocol = (guint8) hdr_ip_proto;\r\nihatemacros = g_ntohs(HDR_IPv6.ip6_ctlun.ip6_un1.ip6_un1_plen);\r\npseudoh.length = g_htons(length - ihatemacros + sizeof(HDR_UDP));\r\n}\r\nif (!hdr_ipv6) {\r\npseudoh.src_addr = HDR_IP.src_addr;\r\npseudoh.dest_addr = HDR_IP.dest_addr;\r\npseudoh.zero = 0;\r\npseudoh.protocol = (guint8) hdr_ip_proto;\r\npseudoh.length = g_htons(length - header_length + sizeof(HDR_UDP));\r\n}\r\nif (hdr_udp) {\r\nguint16 x16;\r\nguint32 u;\r\nHDR_UDP.source_port = isInbound ? g_htons(hdr_dest_port): g_htons(hdr_src_port);\r\nHDR_UDP.dest_port = isInbound ? g_htons(hdr_src_port) : g_htons(hdr_dest_port);\r\nHDR_UDP.length = pseudoh.length;\r\nHDR_UDP.checksum = 0;\r\nx16 = hdr_ipv6 ? in_checksum(&pseudoh6, sizeof(pseudoh6)) : in_checksum(&pseudoh, sizeof(pseudoh));\r\nu = g_ntohs(x16);\r\nx16 = in_checksum(&HDR_UDP, sizeof(HDR_UDP));\r\nu += g_ntohs(x16);\r\nx16 = in_checksum(packet_buf + header_length, length - header_length);\r\nu += g_ntohs(x16);\r\nx16 = (u & 0xffff) + (u>>16);\r\nHDR_UDP.checksum = g_htons(x16);\r\nif (HDR_UDP.checksum == 0)\r\nHDR_UDP.checksum = g_htons(1);\r\nwrite_bytes((const char *)&HDR_UDP, sizeof(HDR_UDP));\r\n}\r\nif (hdr_tcp) {\r\nguint16 x16;\r\nguint32 u;\r\npseudoh.src_addr = HDR_IP.src_addr;\r\npseudoh.dest_addr = HDR_IP.dest_addr;\r\npseudoh.zero = 0;\r\npseudoh.protocol = (guint8) hdr_ip_proto;\r\npseudoh.length = g_htons(length - header_length + sizeof(HDR_TCP));\r\nHDR_TCP.source_port = isInbound ? g_htons(hdr_dest_port): g_htons(hdr_src_port);\r\nHDR_TCP.dest_port = isInbound ? g_htons(hdr_src_port) : g_htons(hdr_dest_port);\r\nif (has_direction) {\r\nHDR_TCP.flags = 0x10;\r\nHDR_TCP.ack_num = g_ntohl(isInbound ? tcp_out_seq_num : tcp_in_seq_num);\r\nHDR_TCP.ack_num = g_htonl(HDR_TCP.ack_num);\r\n}\r\nelse {\r\nHDR_TCP.flags = 0;\r\nHDR_TCP.ack_num = 0;\r\n}\r\nHDR_TCP.seq_num = isInbound ? tcp_in_seq_num : tcp_out_seq_num;\r\nHDR_TCP.window = g_htons(0x2000);\r\nHDR_TCP.checksum = 0;\r\nx16 = in_checksum(&pseudoh, sizeof(pseudoh));\r\nu = g_ntohs(x16);\r\nx16 = in_checksum(&HDR_TCP, sizeof(HDR_TCP));\r\nu += g_ntohs(x16);\r\nx16 = in_checksum(packet_buf + header_length, length - header_length);\r\nu += g_ntohs(x16);\r\nx16 = (u & 0xffff) + (u>>16);\r\nHDR_TCP.checksum = g_htons(x16);\r\nif (HDR_TCP.checksum == 0)\r\nHDR_TCP.checksum = g_htons(1);\r\nwrite_bytes((const char *)&HDR_TCP, sizeof(HDR_TCP));\r\nif (isInbound) {\r\ntcp_in_seq_num = g_ntohl(tcp_in_seq_num) + length - header_length;\r\ntcp_in_seq_num = g_htonl(tcp_in_seq_num);\r\n}\r\nelse {\r\ntcp_out_seq_num = g_ntohl(tcp_out_seq_num) + length - header_length;\r\ntcp_out_seq_num = g_htonl(tcp_out_seq_num);\r\n}\r\n}\r\nif (hdr_data_chunk) {\r\nhdr_data_chunk_bits = 0;\r\nif (packet_start == 0) {\r\nhdr_data_chunk_bits |= 0x02;\r\n}\r\nif (!cont) {\r\nhdr_data_chunk_bits |= 0x01;\r\n}\r\nHDR_DATA_CHUNK.type = hdr_data_chunk_type;\r\nHDR_DATA_CHUNK.bits = hdr_data_chunk_bits;\r\nHDR_DATA_CHUNK.length = g_htons(length - header_length + sizeof(HDR_DATA_CHUNK));\r\nHDR_DATA_CHUNK.tsn = g_htonl(hdr_data_chunk_tsn);\r\nHDR_DATA_CHUNK.sid = g_htons(hdr_data_chunk_sid);\r\nHDR_DATA_CHUNK.ssn = g_htons(hdr_data_chunk_ssn);\r\nHDR_DATA_CHUNK.ppid = g_htonl(hdr_data_chunk_ppid);\r\nhdr_data_chunk_tsn++;\r\nif (!cont) {\r\nhdr_data_chunk_ssn++;\r\n}\r\n}\r\nif (hdr_sctp) {\r\nguint32 zero = 0;\r\nHDR_SCTP.src_port = isInbound ? g_htons(hdr_sctp_dest): g_htons(hdr_sctp_src);\r\nHDR_SCTP.dest_port = isInbound ? g_htons(hdr_sctp_src) : g_htons(hdr_sctp_dest);\r\nHDR_SCTP.tag = g_htonl(hdr_sctp_tag);\r\nHDR_SCTP.checksum = g_htonl(0);\r\nHDR_SCTP.checksum = crc32c((guint8 *)&HDR_SCTP, sizeof(HDR_SCTP), ~0);\r\nif (hdr_data_chunk) {\r\nHDR_SCTP.checksum = crc32c((guint8 *)&HDR_DATA_CHUNK, sizeof(HDR_DATA_CHUNK), HDR_SCTP.checksum);\r\nHDR_SCTP.checksum = crc32c((guint8 *)packet_buf + header_length, length - header_length, HDR_SCTP.checksum);\r\nHDR_SCTP.checksum = crc32c((guint8 *)&zero, padding_length, HDR_SCTP.checksum);\r\n} else {\r\nHDR_SCTP.checksum = crc32c((guint8 *)packet_buf + header_length, length - header_length, HDR_SCTP.checksum);\r\n}\r\nHDR_SCTP.checksum = finalize_crc32c(HDR_SCTP.checksum);\r\nHDR_SCTP.checksum = g_htonl(HDR_SCTP.checksum);\r\nwrite_bytes((const char *)&HDR_SCTP, sizeof(HDR_SCTP));\r\n}\r\nif (hdr_data_chunk) {\r\nwrite_bytes((const char *)&HDR_DATA_CHUNK, sizeof(HDR_DATA_CHUNK));\r\n}\r\ncurr_offset = length;\r\nif (hdr_data_chunk && (padding_length > 0)) {\r\nmemset(tempbuf, 0, padding_length);\r\nwrite_bytes((const char *)&tempbuf, padding_length);\r\nlength += padding_length;\r\n}\r\nif (hdr_ethernet && (length < 60)) {\r\nmemset(tempbuf, 0, 60 - length);\r\nwrite_bytes((const char *)&tempbuf, 60 - length);\r\nlength = 60;\r\n}\r\nif (use_pcapng) {\r\nsuccess = pcapng_write_enhanced_packet_block(output_file,\r\nNULL,\r\nts_sec, ts_nsec,\r\nlength, length,\r\n0,\r\n1000000000,\r\npacket_buf, direction,\r\n&bytes_written, &err);\r\n} else {\r\nsuccess = libpcap_write_packet(output_file,\r\nts_sec, ts_nsec/1000,\r\nlength, length,\r\npacket_buf,\r\n&bytes_written, &err);\r\n}\r\nif (!success) {\r\nfprintf(stderr, "File write error [%s] : %s\n",\r\noutput_filename, g_strerror(err));\r\nexit(1);\r\n}\r\nif (ts_fmt == NULL) {\r\nif (use_pcapng)\r\nts_nsec++;\r\nelse\r\nts_nsec += 1000;\r\n}\r\nif (!quiet) {\r\nfprintf(stderr, "Wrote packet of %u bytes.\n", length);\r\n}\r\nnum_packets_written++;\r\n}\r\npacket_start += curr_offset - header_length;\r\ncurr_offset = header_length;\r\nreturn;\r\n}\r\nstatic void\r\nwrite_file_header (void)\r\n{\r\nint err;\r\ngboolean success;\r\nif (use_pcapng) {\r\nchar *appname;\r\nchar *comment;\r\nappname = g_strdup_printf("text2pcap (Wireshark) %s", get_ws_vcs_version_info());\r\ncomment = g_strdup_printf("Generated from input file %s.", input_filename);\r\nsuccess = pcapng_write_session_header_block(output_file,\r\ncomment,\r\nNULL,\r\nNULL,\r\nappname,\r\n-1,\r\n&bytes_written,\r\n&err);\r\ng_free(appname);\r\ng_free(comment);\r\nif (success) {\r\nsuccess = pcapng_write_interface_description_block(output_file,\r\nNULL,\r\nNULL,\r\nNULL,\r\n"",\r\nNULL,\r\npcap_link_type,\r\nPCAP_SNAPLEN,\r\n&bytes_written,\r\n0,\r\n9,\r\n&err);\r\n}\r\n} else {\r\nsuccess = libpcap_write_file_header(output_file, pcap_link_type,\r\nPCAP_SNAPLEN, FALSE,\r\n&bytes_written, &err);\r\n}\r\nif (!success) {\r\nfprintf(stderr, "File write error [%s] : %s\n",\r\noutput_filename, g_strerror(err));\r\nexit(1);\r\n}\r\n}\r\nstatic void\r\nappend_to_preamble (char *str)\r\n{\r\nsize_t toklen;\r\nif (packet_preamble_len != 0) {\r\nif (packet_preamble_len == PACKET_PREAMBLE_MAX_LEN)\r\nreturn;\r\npacket_preamble[packet_preamble_len++] = ' ';\r\n}\r\ntoklen = strlen(str);\r\nif (toklen != 0) {\r\nif (packet_preamble_len + toklen > PACKET_PREAMBLE_MAX_LEN)\r\nreturn;\r\ng_strlcpy(&packet_preamble[packet_preamble_len], str, PACKET_PREAMBLE_MAX_LEN);\r\npacket_preamble_len += (int) toklen;\r\nif (debug >= 2) {\r\nchar *c;\r\nchar xs[PACKET_PREAMBLE_MAX_LEN];\r\ng_strlcpy(xs, packet_preamble, PACKET_PREAMBLE_MAX_LEN);\r\nwhile ((c = strchr(xs, '\r')) != NULL) *c=' ';\r\nfprintf (stderr, "[[append_to_preamble: \"%s\"]]", xs);\r\n}\r\n}\r\n}\r\nstatic void\r\nparse_preamble (void)\r\n{\r\nstruct tm timecode;\r\nchar *subsecs;\r\nchar *p;\r\nint subseclen;\r\nint i;\r\npacket_preamble[packet_preamble_len] = '\0';\r\nif (debug > 0)\r\nfprintf(stderr, "[[parse_preamble: \"%s\"]]\n", packet_preamble);\r\nif (has_direction) {\r\nswitch (packet_preamble[0]) {\r\ncase 'i':\r\ncase 'I':\r\ndirection = 0x00000001;\r\npacket_preamble[0] = ' ';\r\nbreak;\r\ncase 'o':\r\ncase 'O':\r\ndirection = 0x00000002;\r\npacket_preamble[0] = ' ';\r\nbreak;\r\ndefault:\r\ndirection = 0x00000000;\r\nbreak;\r\n}\r\ni = 0;\r\nwhile (packet_preamble[i] == ' ' ||\r\npacket_preamble[i] == '\r' ||\r\npacket_preamble[i] == '\t') {\r\ni++;\r\n}\r\npacket_preamble_len -= i;\r\nmemmove(packet_preamble, packet_preamble + i, packet_preamble_len + 1);\r\n}\r\nif (ts_fmt == NULL) {\r\npacket_preamble_len = 0;\r\nreturn;\r\n}\r\ntimecode = timecode_default;\r\nts_nsec = 0;\r\nif (strlen(packet_preamble) > 2) {\r\nsubsecs = strptime( packet_preamble, ts_fmt, &timecode );\r\nif (subsecs != NULL) {\r\nts_sec = mktime( &timecode );\r\n} else\r\nts_sec = -1;\r\nif (-1 == ts_sec) {\r\nchar *c;\r\nwhile ((c = strchr(packet_preamble, '\r')) != NULL) *c=' ';\r\nfprintf (stderr, "Failure processing time \"%s\" using time format \"%s\"\n (defaulting to Jan 1,1970 00:00:00 GMT)\n",\r\npacket_preamble, ts_fmt);\r\nif (debug >= 2) {\r\nfprintf(stderr, "timecode: %02d/%02d/%d %02d:%02d:%02d %d\n",\r\ntimecode.tm_mday, timecode.tm_mon, timecode.tm_year,\r\ntimecode.tm_hour, timecode.tm_min, timecode.tm_sec, timecode.tm_isdst);\r\n}\r\nts_sec = 0;\r\nts_nsec = 0;\r\n} else {\r\nts_nsec = (guint32)strtol(subsecs, &p, 10);\r\nif (subsecs == p) {\r\nts_nsec = 0;\r\n} else {\r\nsubseclen = (int) (p - subsecs);\r\nif (subseclen > 9) {\r\nfor (i = subseclen - 9; i != 0; i--)\r\nts_nsec /= 10;\r\n} else if (subseclen < 9) {\r\nfor (i = 9 - subseclen; i != 0; i--)\r\nts_nsec *= 10;\r\n}\r\n}\r\n}\r\n}\r\nif (debug >= 2) {\r\nchar *c;\r\nwhile ((c = strchr(packet_preamble, '\r')) != NULL) *c=' ';\r\nfprintf(stderr, "[[parse_preamble: \"%s\"]]\n", packet_preamble);\r\nfprintf(stderr, "Format(%s), time(%u), subsecs(%u)\n", ts_fmt, (guint32)ts_sec, ts_nsec);\r\n}\r\npacket_preamble_len = 0;\r\n}\r\nstatic void\r\nstart_new_packet (gboolean cont)\r\n{\r\nif (debug >= 1)\r\nfprintf(stderr, "Start new packet (cont = %s).\n", cont ? "TRUE" : "FALSE");\r\nwrite_current_packet(cont);\r\nnum_packets_read++;\r\nparse_preamble();\r\n}\r\nstatic void\r\nprocess_directive (char *str)\r\n{\r\nfprintf(stderr, "\n--- Directive [%s] currently unsupported ---\n", str + 10);\r\n}\r\nvoid\r\nparse_token (token_t token, char *str)\r\n{\r\nguint32 num;\r\nint by_eol;\r\nint rollback = 0;\r\nint line_size;\r\nint i;\r\nchar *s2;\r\nchar tmp_str[3];\r\nif (debug >= 2) {\r\nchar *c;\r\nif (str!=NULL) { while ((c = strchr(str, '\r')) != NULL) *c=' '; }\r\nfprintf(stderr, "(%s, %s \"%s\") -> (",\r\nstate_str[state], token_str[token], str ? str : "");\r\n}\r\nswitch (state) {\r\ncase INIT:\r\nif (!str && token != T_EOL) goto fail_null_str;\r\nswitch (token) {\r\ncase T_TEXT:\r\nappend_to_preamble(str);\r\nbreak;\r\ncase T_DIRECTIVE:\r\nprocess_directive(str);\r\nbreak;\r\ncase T_OFFSET:\r\nnum = parse_num(str, TRUE);\r\nif (num == 0) {\r\nstart_new_packet(FALSE);\r\nstate = READ_OFFSET;\r\npkt_lnstart = packet_buf + num;\r\n}\r\nbreak;\r\ncase T_EOL:\r\nstate = START_OF_LINE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase START_OF_LINE:\r\nif (!str && token != T_EOL) goto fail_null_str;\r\nswitch (token) {\r\ncase T_TEXT:\r\nappend_to_preamble(str);\r\nbreak;\r\ncase T_DIRECTIVE:\r\nprocess_directive(str);\r\nbreak;\r\ncase T_OFFSET:\r\nnum = parse_num(str, TRUE);\r\nif (num == 0) {\r\nstart_new_packet(FALSE);\r\npacket_start = 0;\r\nstate = READ_OFFSET;\r\n} else if ((num - packet_start) != curr_offset - header_length) {\r\nif (num < curr_offset) {\r\nunwrite_bytes(curr_offset - num);\r\nstate = READ_OFFSET;\r\n} else {\r\nif (debug >= 1)\r\nfprintf(stderr, "Inconsistent offset. Expecting %0X, got %0X. Ignoring rest of packet\n",\r\ncurr_offset, num);\r\nwrite_current_packet(FALSE);\r\nstate = INIT;\r\n}\r\n} else {\r\nstate = READ_OFFSET;\r\n}\r\npkt_lnstart = packet_buf + num;\r\nbreak;\r\ncase T_EOL:\r\nstate = START_OF_LINE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase READ_OFFSET:\r\nswitch (token) {\r\ncase T_BYTE:\r\nstate = READ_BYTE;\r\nif (!str) goto fail_null_str;\r\nwrite_byte(str);\r\nbreak;\r\ncase T_TEXT:\r\ncase T_DIRECTIVE:\r\ncase T_OFFSET:\r\nstate = READ_TEXT;\r\nbreak;\r\ncase T_EOL:\r\nstate = START_OF_LINE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase READ_BYTE:\r\nswitch (token) {\r\ncase T_BYTE:\r\nwrite_byte(str);\r\nbreak;\r\ncase T_TEXT:\r\ncase T_DIRECTIVE:\r\ncase T_OFFSET:\r\ncase T_EOL:\r\nby_eol = 0;\r\nstate = READ_TEXT;\r\nif (token == T_EOL) {\r\nby_eol = 1;\r\nstate = START_OF_LINE;\r\n}\r\nif (identify_ascii) {\r\nrollback = 0;\r\nline_size = curr_offset-(int)(pkt_lnstart-packet_buf);\r\ns2 = (char*)g_malloc((line_size+1)/4+1);\r\nfor (i = 0; i < (line_size+1)/4; i++) {\r\ntmp_str[0] = pkt_lnstart[i*3];\r\ntmp_str[1] = pkt_lnstart[i*3+1];\r\ntmp_str[2] = '\0';\r\nif (!g_ascii_isxdigit(tmp_str[0]) || !g_ascii_isxdigit(tmp_str[1])) {\r\nbreak;\r\n}\r\ns2[i] = (char)strtoul(tmp_str, (char **)NULL, 16);\r\nrollback++;\r\nif (!(pkt_lnstart[i*3+2] == ' ')) {\r\nif (by_eol != 1)\r\nrollback--;\r\nbreak;\r\n}\r\n}\r\nif (rollback > 0) {\r\nif (strncmp(pkt_lnstart+line_size-rollback, s2, rollback) == 0) {\r\nunwrite_bytes(rollback);\r\n}\r\nelse {\r\nunwrite_bytes(line_size);\r\n}\r\n}\r\ng_free(s2);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase READ_TEXT:\r\nswitch (token) {\r\ncase T_EOL:\r\nstate = START_OF_LINE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nfprintf(stderr, "FATAL ERROR: Bad state (%d)", state);\r\nexit(1);\r\n}\r\nif (debug >= 2)\r\nfprintf(stderr, ", %s)\n", state_str[state]);\r\nreturn;\r\nfail_null_str:\r\nfprintf(stderr, "FATAL ERROR: got NULL str pointer in state (%d)", state);\r\nexit(1);\r\n}\r\nstatic void\r\nprint_usage (FILE *output)\r\n{\r\nfprintf(output,\r\n"\n"\r\n"Usage: text2pcap [options] <infile> <outfile>\n"\r\n"\n"\r\n"where <infile> specifies input filename (use - for standard input)\n"\r\n" <outfile> specifies output filename (use - for standard output)\n"\r\n"\n"\r\n"Input:\n"\r\n" -o hex|oct|dec parse offsets as (h)ex, (o)ctal or (d)ecimal;\n"\r\n" default is hex.\n"\r\n" -t <timefmt> treat the text before the packet as a date/time code;\n"\r\n" the specified argument is a format string of the sort\n"\r\n" supported by strptime.\n"\r\n" Example: The time \"10:15:14.5476\" has the format code\n"\r\n" \"%%H:%%M:%%S.\"\n"\r\n" NOTE: The subsecond component delimiter, '.', must be\n"\r\n" given, but no pattern is required; the remaining\n"\r\n" number is assumed to be fractions of a second.\n"\r\n" NOTE: Date/time fields from the current date/time are\n"\r\n" used as the default for unspecified fields.\n"\r\n" -D the text before the packet starts with an I or an O,\n"\r\n" indicating that the packet is inbound or outbound.\n"\r\n" This is only stored if the output format is PCAP-NG.\n"\r\n" -a enable ASCII text dump identification.\n"\r\n" The start of the ASCII text dump can be identified\n"\r\n" and excluded from the packet data, even if it looks\n"\r\n" like a HEX dump.\n"\r\n" NOTE: Do not enable it if the input file does not\n"\r\n" contain the ASCII text dump.\n"\r\n"\n"\r\n"Output:\n"\r\n" -l <typenum> link-layer type number; default is 1 (Ethernet). See\n"\r\n" http://www.tcpdump.org/linktypes.html for a list of\n"\r\n" numbers. Use this option if your dump is a complete\n"\r\n" hex dump of an encapsulated packet and you wish to\n"\r\n" specify the exact type of encapsulation.\n"\r\n" Example: -l 7 for ARCNet packets.\n"\r\n" -m <max-packet> max packet length in output; default is %d\n"\r\n"\n"\r\n"Prepend dummy header:\n"\r\n" -e <l3pid> prepend dummy Ethernet II header with specified L3PID\n"\r\n" (in HEX).\n"\r\n" Example: -e 0x806 to specify an ARP packet.\n"\r\n" -i <proto> prepend dummy IP header with specified IP protocol\n"\r\n" (in DECIMAL).\n"\r\n" Automatically prepends Ethernet header as well.\n"\r\n" Example: -i 46\n"\r\n" -4 <srcip>,<destip> prepend dummy IPv4 header with specified\n"\r\n" dest and source address.\n"\r\n" Example: -4 10.0.0.1,10.0.0.2\n"\r\n" -6 <srcip>,<destip> replace IPv6 header with specified\n"\r\n" dest and source address.\n"\r\n" Example: -6 fe80:0:0:0:202:b3ff:fe1e:8329,2001:0db8:85a3:0000:0000:8a2e:0370:7334\n"\r\n" -u <srcp>,<destp> prepend dummy UDP header with specified\n"\r\n" source and destination ports (in DECIMAL).\n"\r\n" Automatically prepends Ethernet & IP headers as well.\n"\r\n" Example: -u 1000,69 to make the packets look like\n"\r\n" TFTP/UDP packets.\n"\r\n" -T <srcp>,<destp> prepend dummy TCP header with specified\n"\r\n" source and destination ports (in DECIMAL).\n"\r\n" Automatically prepends Ethernet & IP headers as well.\n"\r\n" Example: -T 50,60\n"\r\n" -s <srcp>,<dstp>,<tag> prepend dummy SCTP header with specified\n"\r\n" source/dest ports and verification tag (in DECIMAL).\n"\r\n" Automatically prepends Ethernet & IP headers as well.\n"\r\n" Example: -s 30,40,34\n"\r\n" -S <srcp>,<dstp>,<ppi> prepend dummy SCTP header with specified\n"\r\n" source/dest ports and verification tag 0.\n"\r\n" Automatically prepends a dummy SCTP DATA\n"\r\n" chunk header with payload protocol identifier ppi.\n"\r\n" Example: -S 30,40,34\n"\r\n"\n"\r\n"Miscellaneous:\n"\r\n" -h display this help and exit.\n"\r\n" -d show detailed debug of parser states.\n"\r\n" -q generate no output at all (automatically disables -d).\n"\r\n" -n use PCAP-NG instead of PCAP as output format.\n"\r\n"",\r\nMAX_PACKET);\r\n}\r\nstatic void\r\nparse_options (int argc, char *argv[])\r\n{\r\nGString *comp_info_str;\r\nGString *runtime_info_str;\r\nint c;\r\nchar *p;\r\nstatic const struct option long_options[] = {\r\n{"help", no_argument, NULL, 'h'},\r\n{"version", no_argument, NULL, 'v'},\r\n{0, 0, 0, 0 }\r\n};\r\n#ifdef _WIN32\r\narg_list_utf_16to8(argc, argv);\r\ncreate_app_running_mutex();\r\n#endif\r\ncomp_info_str = get_compiled_version_info(NULL, NULL);\r\nruntime_info_str = get_runtime_version_info(NULL);\r\nws_add_crash_info("Text2pcap (Wireshark) %s\n"\r\n"\n"\r\n"%s"\r\n"\n"\r\n"%s",\r\nget_ws_vcs_version_info(), comp_info_str->str, runtime_info_str->str);\r\nwhile ((c = getopt_long(argc, argv, "aDdhqe:i:l:m:no:u:s:S:t:T:v4:6:", long_options, NULL)) != -1) {\r\nswitch (c) {\r\ncase 'h':\r\nprintf("Text2pcap (Wireshark) %s\n"\r\n"Generate a capture file from an ASCII hexdump of packets.\n"\r\n"See https://www.wireshark.org for more information.\n",\r\nget_ws_vcs_version_info());\r\nprint_usage(stdout);\r\nexit(0);\r\nbreak;\r\ncase 'd': if (!quiet) debug++; break;\r\ncase 'D': has_direction = TRUE; break;\r\ncase 'q': quiet = TRUE; debug = FALSE; break;\r\ncase 'l': pcap_link_type = (guint32)strtol(optarg, NULL, 0); break;\r\ncase 'm': max_offset = (guint32)strtol(optarg, NULL, 0); break;\r\ncase 'n': use_pcapng = TRUE; break;\r\ncase 'o':\r\nif (optarg[0] != 'h' && optarg[0] != 'o' && optarg[0] != 'd') {\r\nfprintf(stderr, "Bad argument for '-o': %s\n", optarg);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\nswitch (optarg[0]) {\r\ncase 'o': offset_base = 8; break;\r\ncase 'h': offset_base = 16; break;\r\ncase 'd': offset_base = 10; break;\r\n}\r\nbreak;\r\ncase 'e':\r\nhdr_ethernet = TRUE;\r\nif (sscanf(optarg, "%x", &hdr_ethernet_proto) < 1) {\r\nfprintf(stderr, "Bad argument for '-e': %s\n", optarg);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\nbreak;\r\ncase 'i':\r\nhdr_ip = TRUE;\r\nhdr_ip_proto = strtol(optarg, &p, 10);\r\nif (p == optarg || *p != '\0' || hdr_ip_proto < 0 ||\r\nhdr_ip_proto > 255) {\r\nfprintf(stderr, "Bad argument for '-i': %s\n", optarg);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\nhdr_ethernet = TRUE;\r\nhdr_ethernet_proto = 0x800;\r\nbreak;\r\ncase 's':\r\nhdr_sctp = TRUE;\r\nhdr_data_chunk = FALSE;\r\nhdr_tcp = FALSE;\r\nhdr_udp = FALSE;\r\nhdr_sctp_src = (guint32)strtol(optarg, &p, 10);\r\nif (p == optarg || (*p != ',' && *p != '\0')) {\r\nfprintf(stderr, "Bad src port for '-%c'\n", c);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\nif (*p == '\0') {\r\nfprintf(stderr, "No dest port specified for '-%c'\n", c);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\np++;\r\noptarg = p;\r\nhdr_sctp_dest = (guint32)strtol(optarg, &p, 10);\r\nif (p == optarg || (*p != ',' && *p != '\0')) {\r\nfprintf(stderr, "Bad dest port for '-s'\n");\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\nif (*p == '\0') {\r\nfprintf(stderr, "No tag specified for '-%c'\n", c);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\np++;\r\noptarg = p;\r\nhdr_sctp_tag = (guint32)strtol(optarg, &p, 10);\r\nif (p == optarg || *p != '\0') {\r\nfprintf(stderr, "Bad tag for '-%c'\n", c);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\nhdr_ip = TRUE;\r\nhdr_ip_proto = 132;\r\nhdr_ethernet = TRUE;\r\nhdr_ethernet_proto = 0x800;\r\nbreak;\r\ncase 'S':\r\nhdr_sctp = TRUE;\r\nhdr_data_chunk = TRUE;\r\nhdr_tcp = FALSE;\r\nhdr_udp = FALSE;\r\nhdr_sctp_src = (guint32)strtol(optarg, &p, 10);\r\nif (p == optarg || (*p != ',' && *p != '\0')) {\r\nfprintf(stderr, "Bad src port for '-%c'\n", c);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\nif (*p == '\0') {\r\nfprintf(stderr, "No dest port specified for '-%c'\n", c);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\np++;\r\noptarg = p;\r\nhdr_sctp_dest = (guint32)strtol(optarg, &p, 10);\r\nif (p == optarg || (*p != ',' && *p != '\0')) {\r\nfprintf(stderr, "Bad dest port for '-s'\n");\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\nif (*p == '\0') {\r\nfprintf(stderr, "No ppi specified for '-%c'\n", c);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\np++;\r\noptarg = p;\r\nhdr_data_chunk_ppid = (guint32)strtoul(optarg, &p, 10);\r\nif (p == optarg || *p != '\0') {\r\nfprintf(stderr, "Bad ppi for '-%c'\n", c);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\nhdr_ip = TRUE;\r\nhdr_ip_proto = 132;\r\nhdr_ethernet = TRUE;\r\nhdr_ethernet_proto = 0x800;\r\nbreak;\r\ncase 't':\r\nts_fmt = optarg;\r\nbreak;\r\ncase 'u':\r\nhdr_udp = TRUE;\r\nhdr_tcp = FALSE;\r\nhdr_sctp = FALSE;\r\nhdr_data_chunk = FALSE;\r\nhdr_src_port = (guint32)strtol(optarg, &p, 10);\r\nif (p == optarg || (*p != ',' && *p != '\0')) {\r\nfprintf(stderr, "Bad src port for '-u'\n");\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\nif (*p == '\0') {\r\nfprintf(stderr, "No dest port specified for '-u'\n");\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\np++;\r\noptarg = p;\r\nhdr_dest_port = (guint32)strtol(optarg, &p, 10);\r\nif (p == optarg || *p != '\0') {\r\nfprintf(stderr, "Bad dest port for '-u'\n");\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\nhdr_ip = TRUE;\r\nhdr_ip_proto = 17;\r\nhdr_ethernet = TRUE;\r\nhdr_ethernet_proto = 0x800;\r\nbreak;\r\ncase 'T':\r\nhdr_tcp = TRUE;\r\nhdr_udp = FALSE;\r\nhdr_sctp = FALSE;\r\nhdr_data_chunk = FALSE;\r\nhdr_src_port = (guint32)strtol(optarg, &p, 10);\r\nif (p == optarg || (*p != ',' && *p != '\0')) {\r\nfprintf(stderr, "Bad src port for '-T'\n");\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\nif (*p == '\0') {\r\nfprintf(stderr, "No dest port specified for '-u'\n");\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\np++;\r\noptarg = p;\r\nhdr_dest_port = (guint32)strtol(optarg, &p, 10);\r\nif (p == optarg || *p != '\0') {\r\nfprintf(stderr, "Bad dest port for '-T'\n");\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\nhdr_ip = TRUE;\r\nhdr_ip_proto = 6;\r\nhdr_ethernet = TRUE;\r\nhdr_ethernet_proto = 0x800;\r\nbreak;\r\ncase 'a':\r\nidentify_ascii = TRUE;\r\nbreak;\r\ncase 'v':\r\nshow_version("Text2pcap (Wireshark)", comp_info_str, runtime_info_str);\r\ng_string_free(comp_info_str, TRUE);\r\ng_string_free(runtime_info_str, TRUE);\r\nexit(0);\r\nbreak;\r\ncase '4':\r\ncase '6':\r\np = strchr(optarg, ',');\r\nif (!p) {\r\nfprintf(stderr, "Bad source param addr for '-%c'\n", c);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\n*p = '\0';\r\nif (c == '6')\r\n{\r\nhdr_ipv6 = TRUE;\r\nhdr_ethernet_proto = 0x86DD;\r\n}\r\nelse\r\n{\r\nhdr_ip = TRUE;\r\nhdr_ethernet_proto = 0x800;\r\n}\r\nhdr_ethernet = TRUE;\r\nif (hdr_ipv6 == TRUE) {\r\nif (!ws_inet_pton6(optarg, &hdr_ipv6_src_addr)) {\r\nfprintf(stderr, "Bad src addr -%c '%s'\n", c, p);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\n} else {\r\nif (!ws_inet_pton4(optarg, &hdr_ip_src_addr)) {\r\nfprintf(stderr, "Bad src addr -%c '%s'\n", c, p);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\n}\r\np++;\r\nif (*p == '\0') {\r\nfprintf(stderr, "No dest addr specified for '-%c'\n", c);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\nif (hdr_ipv6 == TRUE) {\r\nif (!ws_inet_pton6(p, &hdr_ipv6_dest_addr)) {\r\nfprintf(stderr, "Bad dest addr for -%c '%s'\n", c, p);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\n} else {\r\nif (!ws_inet_pton4(p, &hdr_ip_dest_addr)) {\r\nfprintf(stderr, "Bad dest addr for -%c '%s'\n", c, p);\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\n}\r\nbreak;\r\ncase '?':\r\ndefault:\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\n}\r\nif (optind >= argc || argc-optind < 2) {\r\nfprintf(stderr, "Must specify input and output filename\n");\r\nprint_usage(stderr);\r\nexit(1);\r\n}\r\nif (strcmp(argv[optind], "-")) {\r\ninput_filename = g_strdup(argv[optind]);\r\ninput_file = ws_fopen(input_filename, "rb");\r\nif (!input_file) {\r\nfprintf(stderr, "Cannot open file [%s] for reading: %s\n",\r\ninput_filename, g_strerror(errno));\r\nexit(1);\r\n}\r\n} else {\r\ninput_filename = "Standard input";\r\ninput_file = stdin;\r\n}\r\nif (strcmp(argv[optind+1], "-")) {\r\noutput_filename = g_strdup(argv[optind+1]);\r\noutput_file = ws_fopen(output_filename, "wb");\r\nif (!output_file) {\r\nfprintf(stderr, "Cannot open file [%s] for writing: %s\n",\r\noutput_filename, g_strerror(errno));\r\nexit(1);\r\n}\r\n} else {\r\noutput_filename = "Standard output";\r\noutput_file = stdout;\r\n}\r\nif (pcap_link_type != 1 && hdr_ethernet) {\r\nfprintf(stderr, "Dummy headers (-e, -i, -u, -s, -S -T) cannot be specified with link type override (-l)\n");\r\nexit(1);\r\n}\r\nif (!input_file) {\r\ninput_file = stdin;\r\ninput_filename = "Standard input";\r\n}\r\nif (!output_file) {\r\noutput_file = stdout;\r\noutput_filename = "Standard output";\r\n}\r\nts_sec = time(0);\r\ntimecode_default = *localtime(&ts_sec);\r\ntimecode_default.tm_isdst = -1;\r\nif (!quiet) {\r\nfprintf(stderr, "Input from: %s\n", input_filename);\r\nfprintf(stderr, "Output to: %s\n", output_filename);\r\nfprintf(stderr, "Output format: %s\n", use_pcapng ? "PCAP-NG" : "PCAP");\r\nif (hdr_ethernet) fprintf(stderr, "Generate dummy Ethernet header: Protocol: 0x%0X\n",\r\nhdr_ethernet_proto);\r\nif (hdr_ip) fprintf(stderr, "Generate dummy IP header: Protocol: %ld\n",\r\nhdr_ip_proto);\r\nif (hdr_udp) fprintf(stderr, "Generate dummy UDP header: Source port: %u. Dest port: %u\n",\r\nhdr_src_port, hdr_dest_port);\r\nif (hdr_tcp) fprintf(stderr, "Generate dummy TCP header: Source port: %u. Dest port: %u\n",\r\nhdr_src_port, hdr_dest_port);\r\nif (hdr_sctp) fprintf(stderr, "Generate dummy SCTP header: Source port: %u. Dest port: %u. Tag: %u\n",\r\nhdr_sctp_src, hdr_sctp_dest, hdr_sctp_tag);\r\nif (hdr_data_chunk) fprintf(stderr, "Generate dummy DATA chunk header: TSN: %u. SID: %u. SSN: %u. PPID: %u\n",\r\nhdr_data_chunk_tsn, hdr_data_chunk_sid, hdr_data_chunk_ssn, hdr_data_chunk_ppid);\r\n}\r\n}\r\nint\r\nmain(int argc, char *argv[])\r\n{\r\nparse_options(argc, argv);\r\nassert(input_file != NULL);\r\nassert(output_file != NULL);\r\nwrite_file_header();\r\nheader_length = 0;\r\nif (hdr_ethernet) {\r\nheader_length += (int)sizeof(HDR_ETHERNET);\r\n}\r\nif (hdr_ip) {\r\nip_offset = header_length;\r\nheader_length += (int)sizeof(HDR_IP);\r\n} else if (hdr_ipv6) {\r\nip_offset = header_length;\r\nheader_length += (int)sizeof(HDR_IPv6);\r\n}\r\nif (hdr_sctp) {\r\nheader_length += (int)sizeof(HDR_SCTP);\r\n}\r\nif (hdr_data_chunk) {\r\nheader_length += (int)sizeof(HDR_DATA_CHUNK);\r\n}\r\nif (hdr_tcp) {\r\nheader_length += (int)sizeof(HDR_TCP);\r\n}\r\nif (hdr_udp) {\r\nheader_length += (int)sizeof(HDR_UDP);\r\n}\r\ncurr_offset = header_length;\r\nyyin = input_file;\r\nyylex();\r\nwrite_current_packet(FALSE);\r\nfclose(input_file);\r\nfclose(output_file);\r\nif (debug)\r\nfprintf(stderr, "\n-------------------------\n");\r\nif (!quiet) {\r\nfprintf(stderr, "Read %u potential packet%s, wrote %u packet%s (%" G_GINT64_MODIFIER "u byte%s).\n",\r\nnum_packets_read, (num_packets_read == 1) ? "" : "s",\r\nnum_packets_written, (num_packets_written == 1) ? "" : "s",\r\nbytes_written, (bytes_written == 1) ? "" : "s");\r\n}\r\nreturn 0;\r\n}
