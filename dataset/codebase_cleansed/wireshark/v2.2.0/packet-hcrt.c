static void dissect_hcrt_body(tvbuff_t* tvb, proto_tree* tree , int* offset,\r\nint type, int addr_mode, int adl, int body_len)\r\n{\r\nproto_item* ti_body;\r\nproto_tree* hcrt_body_tree;\r\ngint i;\r\nti_body = proto_tree_add_item(tree, hf_hcrt_body, tvb, *offset, body_len, ENC_NA);\r\nhcrt_body_tree = proto_item_add_subtree(ti_body, ett_hcrt_body);\r\nswitch (type) {\r\ncase HCRT_NOP:\r\nproto_tree_add_item(hcrt_body_tree, hf_hcrt_command_nop, tvb, *offset,\r\nbody_len, ENC_NA);\r\nbreak;\r\ncase HCRT_WRITE:\r\nif (addr_mode == ADDR_MODE_32) {\r\nproto_tree_add_item(hcrt_body_tree, hf_hcrt_addr_32, tvb, *offset,\r\n4, ENC_LITTLE_ENDIAN);\r\nfor (i = 1; i <= adl; i++) {\r\nproto_tree_add_item(hcrt_body_tree, hf_hcrt_data_32, tvb,\r\n*offset + i * 4, 4, ENC_LITTLE_ENDIAN);\r\n}\r\n} else {\r\nproto_tree_add_item(hcrt_body_tree, hf_hcrt_addr_64, tvb, *offset,\r\n8, ENC_LITTLE_ENDIAN);\r\nfor (i = 1; i <= adl; i++)\r\nproto_tree_add_item(hcrt_body_tree, hf_hcrt_data_64, tvb,\r\n*offset + i * 8, 8, ENC_LITTLE_ENDIAN);\r\n}\r\nbreak;\r\ncase HCRT_READ:\r\nif (addr_mode == ADDR_MODE_32) {\r\nproto_tree_add_item(hcrt_body_tree, hf_hcrt_addr_32, tvb, *offset, 4,\r\nENC_LITTLE_ENDIAN);\r\n} else {\r\nproto_tree_add_item(hcrt_body_tree, hf_hcrt_addr_64, tvb, *offset, 8,\r\nENC_LITTLE_ENDIAN);\r\n}\r\nbreak;\r\ncase HCRT_RESPONSE:\r\nif (body_len > 0) {\r\nproto_tree_add_item(hcrt_body_tree, hf_hcrt_command_nop, tvb, *offset,\r\nbody_len, ENC_NA);\r\n}\r\nbreak;\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nbreak;\r\n}\r\n(*offset) += body_len;\r\n}\r\nstatic gboolean dissect_hcrt_header(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree,\r\nint* offset, guint8 b0_first, guint8 b0_current)\r\n{\r\nproto_item* ti_hdr;\r\nproto_tree* hcrt_hdr_tree;\r\ngboolean last;\r\nguint8 type;\r\nti_hdr = proto_tree_add_item(tree, hf_hcrt_header, tvb, *offset, 4, ENC_NA);\r\nhcrt_hdr_tree = proto_item_add_subtree(ti_hdr, ett_hcrt_hdr);\r\nif (b0_first != b0_current) {\r\nexpert_add_info_format(pinfo, hcrt_hdr_tree, &ei_hcrt_error,\r\n"Invalid Byte 0 in Header. Must be equal in all HCrt messages. "\r\n"Expected: %.2X, got: %.2X", b0_first, b0_current);\r\n}\r\ntype = (b0_current & 0x30) >> 4;\r\nproto_tree_add_item(hcrt_hdr_tree, hf_hcrt_message_tag, tvb,\r\n*offset, 1, ENC_NA);\r\nproto_tree_add_item(hcrt_hdr_tree, hf_hcrt_message_type, tvb,\r\n*offset, 1, ENC_NA);\r\nproto_tree_add_item(hcrt_hdr_tree, hf_hcrt_am, tvb,\r\n*offset, 1, ENC_NA);\r\nproto_tree_add_item(hcrt_hdr_tree, hf_hcrt_do, tvb,\r\n*offset, 1, ENC_NA);\r\n(*offset)++;\r\nif (type != HCRT_RESPONSE) {\r\nproto_tree_add_item(hcrt_hdr_tree, hf_hcrt_1st_dword_enable, tvb,\r\n*offset, 1, ENC_NA);\r\n} else {\r\nproto_tree_add_item(hcrt_hdr_tree, hf_hcrt_resp_code, tvb,\r\n*offset, 1, ENC_NA);\r\n}\r\nif (type != HCRT_RESPONSE) {\r\nproto_tree_add_item(hcrt_hdr_tree, hf_hcrt_last_dword_enable, tvb,\r\n*offset, 1, ENC_NA);\r\n}\r\n(*offset)++;\r\nproto_tree_add_item(hcrt_hdr_tree, hf_hcrt_adl, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(hcrt_hdr_tree, hf_hcrt_last, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\r\nlast = (tvb_get_letohs(tvb, *offset) & 0x8000) != 0;\r\n(*offset) += 2;\r\nreturn last;\r\n}\r\nstatic gboolean dissect_hcrt_message(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree,\r\nint* offset, guint8 b0_first, int i)\r\n{\r\ngboolean last;\r\nguint adl;\r\nguint addr_mode;\r\nguint body_len;\r\nproto_tree* hcrt_msg_tree;\r\nguint8 b0_current;\r\nint type;\r\nb0_current = tvb_get_guint8(tvb, *offset);\r\nadl = tvb_get_letohs(tvb, *offset + 2) & 0x0FFF;\r\naddr_mode = (1 + ((b0_current & 0x40) >> 6));\r\ntype = (b0_current & 0x30) >> 4;\r\nswitch (type) {\r\ncase HCRT_NOP:\r\nbody_len = 4 * addr_mode * adl;\r\nbreak;\r\ncase HCRT_WRITE:\r\nbody_len = 4 * addr_mode * (adl + 1);\r\nbreak;\r\ncase HCRT_READ:\r\nbody_len = 4 * addr_mode;\r\nbreak;\r\ncase HCRT_RESPONSE:\r\nbody_len = 4 * addr_mode * adl;\r\nbreak;\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nbreak;\r\n}\r\nhcrt_msg_tree = proto_tree_add_subtree_format(tree, tvb, *offset,\r\nHCRT_HDR_LEN + body_len, ett_hcrt_msg, NULL, "Message %d", i);\r\nlast = dissect_hcrt_header(tvb, pinfo, hcrt_msg_tree, offset, b0_first, b0_current);\r\ndissect_hcrt_body(tvb, hcrt_msg_tree, offset, type, addr_mode, adl, body_len);\r\nreturn last;\r\n}\r\nstatic int dissect_hcrt(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree, void* data _U_)\r\n{\r\nguint8 type;\r\nproto_item* ti;\r\nproto_tree* hcrt_tree;\r\nguint offset;\r\nint i = 1;\r\nguint8 b0_first;\r\nguint8 tag;\r\nguint adl;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "HCrt");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nb0_first = tvb_get_guint8(tvb, 0);\r\ntag = b0_first & 0x0F;\r\ntype = (b0_first & 0x30) >> 4;\r\nadl = tvb_get_letohs(tvb, 2) & 0x0FFF;\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Type: %s, Tag: 0x%X, ADL: %u",\r\nval_to_str(type, hcrt_message_types, "Unknown (0x%02x)"), tag, adl);\r\nif (adl == 1) {\r\nif (type == HCRT_READ || type == HCRT_WRITE) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Address: 0x%.8X", tvb_get_letohl(tvb, 4));\r\n}\r\nif (type == HCRT_WRITE) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Data: 0x%.8X", tvb_get_letohl(tvb, 8));\r\n}\r\n}\r\noffset = 0;\r\nti = proto_tree_add_item(tree, proto_hcrt, tvb, 0, -1, ENC_NA);\r\nhcrt_tree = proto_item_add_subtree(ti, ett_hcrt);\r\nwhile (!dissect_hcrt_message(tvb, pinfo, hcrt_tree, &offset, b0_first, i)) {\r\ni++;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_hcrt(void)\r\n{\r\nexpert_module_t* expert_hcrt;\r\nmodule_t* hcrt_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_hcrt_header,\r\n{ "Header", "hcrt.hdr",\r\nFT_NONE, BASE_NONE,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hcrt_message_tag,\r\n{ "Tag", "hcrt.tag",\r\nFT_UINT8, BASE_HEX,\r\nNULL, 0x0F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hcrt_message_type,\r\n{ "Type", "hcrt.type",\r\nFT_UINT8, BASE_DEC,\r\nVALS(hcrt_message_types), 0x30,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hcrt_am,\r\n{ "Addressing Mode", "hcrt.am",\r\nFT_UINT8, BASE_DEC,\r\nVALS(hcrt_ams), 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hcrt_do,\r\n{ "Discovery Operation", "hcrt.do",\r\nFT_BOOLEAN, 8,\r\nTFS(&hcrt_dos), 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hcrt_1st_dword_enable,\r\n{ "1st DWORD enable", "hcrt.first_dword_enable",\r\nFT_UINT8, BASE_HEX,\r\nVALS(dword_enable_vals), 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hcrt_last_dword_enable,\r\n{ "Last DWORD enable", "hcrt.last_dword_enable",\r\nFT_UINT8, BASE_HEX,\r\nVALS(dword_enable_vals), 0x0F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hcrt_resp_code,\r\n{ "Response code", "hcrt.response_code",\r\nFT_UINT8, BASE_HEX,\r\nVALS(response_codes), 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hcrt_adl,\r\n{ "ADL", "hcrt.adl",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0x0FFF,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hcrt_last,\r\n{ "Last message", "hcrt.last",\r\nFT_BOOLEAN, 16,\r\nNULL, 0x8000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hcrt_body,\r\n{ "Body", "hcrt.body",\r\nFT_NONE, BASE_NONE,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hcrt_addr_32,\r\n{ "Address", "hcrt.address32",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hcrt_addr_64,\r\n{ "Address", "hcrt.address64",\r\nFT_UINT64, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hcrt_data_32,\r\n{ "Data", "hcrt.data32",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hcrt_data_64,\r\n{ "Data", "hcrt.data64",\r\nFT_UINT64, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hcrt_command_nop,\r\n{ "Command", "hcrt.command_nop",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_hcrt_error, { "hcrt.error", PI_MALFORMED, PI_ERROR, "Unusual error code", EXPFILL }}\r\n};\r\nstatic gint* ett[] = {\r\n&ett_hcrt,\r\n&ett_hcrt_msg,\r\n&ett_hcrt_hdr,\r\n&ett_hcrt_body,\r\n};\r\nproto_hcrt = proto_register_protocol (\r\n"Hotline Command-Response Transaction protocol",\r\n"HCrt",\r\n"hcrt"\r\n);\r\nproto_register_field_array(proto_hcrt, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_hcrt = expert_register_protocol(proto_hcrt);\r\nexpert_register_field_array(expert_hcrt, ei, array_length(ei));\r\nrange_convert_str(&hcrt_port_range_default, HCRT_UDP_PORTS_DEFAULT, MAX_UDP_PORT);\r\nhcrt_module = prefs_register_protocol(proto_hcrt, proto_reg_handoff_hcrt);\r\nprefs_register_range_preference(hcrt_module,\r\n"dissector_udp_port",\r\n"UDP port",\r\n"The UDP port used in L3 communications (default " HCRT_UDP_PORTS_DEFAULT ")",\r\n&hcrt_port_range_default, MAX_UDP_PORT);\r\nprefs_register_uint_preference(hcrt_module,\r\n"dissector_ethertype",\r\n"Ethernet type",\r\n"The ethernet type used for L2 communications",\r\n10, &ethertype_pref);\r\n}\r\nvoid proto_reg_handoff_hcrt(void)\r\n{\r\nstatic dissector_handle_t hcrt_handle;\r\nstatic gboolean hcrt_prefs_initialized = FALSE;\r\nstatic range_t* hcrt_port_range;\r\nstatic gint hcrt_ethertype;\r\nif (!hcrt_prefs_initialized) {\r\nhcrt_handle = create_dissector_handle(dissect_hcrt, proto_hcrt);\r\ndissector_add_for_decode_as("tcp.port", hcrt_handle);\r\nhcrt_prefs_initialized = TRUE;\r\n} else {\r\ndissector_delete_uint("ethertype", hcrt_ethertype, hcrt_handle);\r\ndissector_delete_uint_range("udp.port", hcrt_port_range, hcrt_handle);\r\ng_free(hcrt_port_range);\r\n}\r\nhcrt_port_range = range_copy(hcrt_port_range_default);\r\nhcrt_ethertype = ethertype_pref;\r\ndissector_add_uint("ethertype", hcrt_ethertype, hcrt_handle);\r\ndissector_add_uint_range("udp.port", hcrt_port_range, hcrt_handle);\r\n}
