int\r\ndissect_ndr_datablob(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\nproto_tree *tree, dcerpc_info *di, guint8 *drep, int hf_index,\r\nint use_remaining_space)\r\n{\r\nproto_item *item;\r\nguint3264 len;\r\nproto_tree *subtree;\r\nsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_nt_data_blob, &item,\r\nproto_registrar_get_name(hf_index));\r\nif (use_remaining_space) {\r\nlen = tvb_captured_length_remaining (tvb, offset);\r\n} else {\r\noffset = dissect_ndr_uint3264(tvb, offset, pinfo, subtree, di, drep,\r\nhf_nt_data_blob_len, &len);\r\n}\r\nproto_tree_add_item(subtree, hf_nt_data_blob_data, tvb, offset, (int)len, ENC_NA);\r\noffset += (int)len;\r\nreturn offset;\r\n}\r\nint\r\ndissect_null_term_string(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo _U_, proto_tree *tree,\r\nguint8 *drep _U_, int hf_index, int levels _U_)\r\n{\r\nguint len;\r\nlen = tvb_strsize(tvb, offset);\r\nproto_tree_add_item(tree, hf_index, tvb, offset, len, ENC_ASCII|ENC_NA);\r\nreturn offset + len;\r\n}\r\nint\r\ndissect_null_term_wstring(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo _U_, proto_tree *tree,\r\nguint8 *drep _U_, int hf_index, int levels _U_)\r\n{\r\nguint len;\r\nlen = tvb_unicode_strsize(tvb, offset);\r\nproto_tree_add_item(tree, hf_index, tvb, offset, len, ENC_UTF_16|ENC_LITTLE_ENDIAN);\r\nreturn offset + len;\r\n}\r\nint\r\ndissect_ndr_counted_string_cb(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep, int hf_index,\r\ndcerpc_callback_fnct_t *callback,\r\nvoid *callback_args)\r\n{\r\nguint16 len, size;\r\nALIGN_TO_5_BYTES;\r\nif (di->conformant_run)\r\nreturn offset;\r\noffset = dissect_ndr_uint16(tvb, offset, pinfo, tree, di, drep,\r\nhf_nt_cs_len, &len);\r\noffset = dissect_ndr_uint16(tvb, offset, pinfo, tree, di, drep,\r\nhf_nt_cs_size, &size);\r\noffset = dissect_ndr_pointer_cb(tvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_wchar_cvstring, NDR_POINTER_UNIQUE,\r\n"Character Array", hf_index, callback, callback_args);\r\nif (di->call_data->flags & DCERPC_IS_NDR64) {\r\nALIGN_TO_5_BYTES;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_ndr_counted_string_helper(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep, int hf_index, int levels,\r\ngboolean add_subtree)\r\n{\r\nproto_item *item;\r\nproto_tree *subtree = tree;\r\nif (add_subtree) {\r\nsubtree = proto_tree_add_subtree(\r\ntree, tvb, offset, 0, ett_nt_counted_string, &item,\r\nproto_registrar_get_name(hf_index));\r\n}\r\nreturn dissect_ndr_counted_string_cb(\r\ntvb, offset, pinfo, subtree, di, drep, hf_index,\r\ncb_wstr_postprocess, GINT_TO_POINTER(2 + levels));\r\n}\r\nint\r\ndissect_ndr_counted_string(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep, int hf_index, int levels)\r\n{\r\nreturn dissect_ndr_counted_string_helper(\r\ntvb, offset, pinfo, tree, di, drep, hf_index, levels, TRUE);\r\n}\r\nint\r\ndissect_ndr_counted_string_ptr(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\nreturn dissect_ndr_counted_string_helper(\r\ntvb, offset, pinfo, tree, di, drep, di->hf_index, 0, FALSE);\r\n}\r\nint\r\ndissect_ndr_counted_byte_array_cb(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep, int hf_index,\r\ndcerpc_callback_fnct_t *callback,\r\nvoid *callback_args)\r\n{\r\nproto_item *item;\r\nproto_tree *subtree;\r\nguint16 len, size;\r\nALIGN_TO_5_BYTES;\r\nif (di->conformant_run)\r\nreturn offset;\r\nsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_nt_counted_byte_array, &item,\r\nproto_registrar_get_name(hf_index));\r\noffset = dissect_ndr_uint16(tvb, offset, pinfo, subtree, di, drep,\r\nhf_nt_cs_len, &len);\r\noffset = dissect_ndr_uint16(tvb, offset, pinfo, subtree, di, drep,\r\nhf_nt_cs_size, &size);\r\noffset = dissect_ndr_pointer_cb(tvb, offset, pinfo, subtree, di, drep,\r\ndissect_ndr_char_cvstring, NDR_POINTER_UNIQUE,\r\n"Byte Array", hf_index, callback, callback_args);\r\nif (di->call_data->flags & DCERPC_IS_NDR64) {\r\nALIGN_TO_5_BYTES;\r\n}\r\nreturn offset;\r\n}\r\nstatic void cb_byte_array_postprocess(packet_info *pinfo, proto_tree *tree _U_,\r\nproto_item *item, dcerpc_info *di _U_, tvbuff_t *tvb,\r\nint start_offset, int end_offset,\r\nvoid *callback_args)\r\n{\r\ngint options = GPOINTER_TO_INT(callback_args);\r\ngint levels = CB_STR_ITEM_LEVELS(options);\r\nchar *s;\r\nif (start_offset % 4)\r\nstart_offset += 4 - (start_offset % 4);\r\nif ((end_offset - start_offset) <= 12)\r\nreturn;\r\ns = tvb_bytes_to_str(wmem_packet_scope(), tvb, start_offset + 12, (end_offset - start_offset - 12) );\r\nif (options & CB_STR_COL_INFO) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %s", s);\r\n}\r\nif (levels > 0 && item && s && s[0]) {\r\nproto_item_append_text(item, ": %s", s);\r\nitem = GET_ITEM_PARENT(item);\r\nlevels--;\r\nif (levels > 0) {\r\nproto_item_append_text(item, ": %s", s);\r\nitem = GET_ITEM_PARENT(item);\r\nlevels--;\r\nwhile (levels > 0) {\r\nproto_item_append_text(item, " %s", s);\r\nitem = GET_ITEM_PARENT(item);\r\nlevels--;\r\n}\r\n}\r\n}\r\n}\r\nint\r\ndissect_ndr_counted_byte_array(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep, int hf_index, int levels)\r\n{\r\nreturn dissect_ndr_counted_byte_array_cb(\r\ntvb, offset, pinfo, tree, di, drep, hf_index, cb_byte_array_postprocess, GINT_TO_POINTER(2 + levels));\r\n}\r\nint\r\ndissect_ndr_counted_ascii_string_cb(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep, int hf_index,\r\ndcerpc_callback_fnct_t *callback,\r\nvoid *callback_args)\r\n{\r\nproto_item *item;\r\nproto_tree *subtree;\r\nguint16 len, size;\r\nALIGN_TO_5_BYTES;\r\nif (di->conformant_run)\r\nreturn offset;\r\nsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_nt_counted_ascii_string, &item,\r\nproto_registrar_get_name(hf_index));\r\noffset = dissect_ndr_uint16(tvb, offset, pinfo, subtree, di, drep,\r\nhf_nt_cs_len, &len);\r\noffset = dissect_ndr_uint16(tvb, offset, pinfo, subtree, di, drep,\r\nhf_nt_cs_size, &size);\r\noffset = dissect_ndr_pointer_cb(tvb, offset, pinfo, subtree, di, drep,\r\ndissect_ndr_char_cvstring, NDR_POINTER_UNIQUE,\r\n"Ascii String", hf_index, callback, callback_args);\r\nif (di->call_data->flags & DCERPC_IS_NDR64) {\r\nALIGN_TO_5_BYTES;\r\n}\r\nreturn offset;\r\n}\r\nint\r\ndissect_ndr_counted_ascii_string(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep, int hf_index, int levels)\r\n{\r\nreturn dissect_ndr_counted_ascii_string_cb(\r\ntvb, offset, pinfo, tree, di, drep, hf_index, cb_str_postprocess, GINT_TO_POINTER(2 + levels));\r\n}\r\nint\r\ndissect_nt_GUID(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\noffset=dissect_ndr_uuid_t(tvb, offset, pinfo, tree, di, drep, hf_nt_guid, NULL);\r\nreturn offset;\r\n}\r\nint\r\ndissect_ndr_lsa_String(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *parent_tree, dcerpc_info *di, guint8 *drep, guint32 param, int hfindex)\r\n{\r\nproto_item *item = NULL;\r\nproto_tree *tree = NULL;\r\nint old_offset;\r\nheader_field_info *hf_info;\r\nALIGN_TO_5_BYTES;\r\nold_offset = offset;\r\nhf_info=proto_registrar_get_nth(hfindex);\r\nif (parent_tree) {\r\ntree = proto_tree_add_subtree_format(parent_tree, tvb, offset, 0, ett_lsa_String, &item, "%s: ", hf_info->name);\r\n}\r\noffset = PIDL_dissect_uint16(tvb, offset, pinfo, tree, di, drep, hf_lsa_String_name_len, 0);\r\noffset = PIDL_dissect_uint16(tvb, offset, pinfo, tree, di, drep, hf_lsa_String_name_size, 0);\r\noffset = dissect_ndr_pointer_cb(\r\ntvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_wchar_cvstring, NDR_POINTER_UNIQUE,\r\nhf_info->name, hfindex, cb_wstr_postprocess,\r\nGINT_TO_POINTER(param));\r\nproto_item_set_len(item, offset-old_offset);\r\nif (di->call_data->flags & DCERPC_IS_NDR64) {\r\nALIGN_TO_5_BYTES;\r\n}\r\nreturn offset;\r\n}\r\nint\r\ndissect_ndr_nt_NTTIME (tvbuff_t *tvb, int offset,\r\npacket_info *pinfo _U_, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep _U_, int hf_index)\r\n{\r\nif(di->conformant_run){\r\nreturn offset;\r\n}\r\nALIGN_TO_4_BYTES;\r\noffset = dissect_nt_64bit_time(tvb, tree, offset, hf_index);\r\nreturn offset;\r\n}\r\nint\r\ndissect_ndr_nt_NTTIME_hyper (tvbuff_t *tvb, int offset,\r\npacket_info *pinfo _U_, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep _U_, int hf_index, gboolean onesec_resolution)\r\n{\r\nif(di->conformant_run){\r\nreturn offset;\r\n}\r\nALIGN_TO_8_BYTES;\r\noffset = dissect_nt_64bit_time_opt(tvb, tree, offset, hf_index, onesec_resolution);\r\nreturn offset;\r\n}\r\nstatic guint pol_hash_fn(gconstpointer k)\r\n{\r\nconst pol_hash_key *key = (const pol_hash_key *)k;\r\nreturn key->policy_hnd[4] + (key->policy_hnd[5] << 8) +\r\n(key->policy_hnd[6] << 16) + (key->policy_hnd[7] << 24);\r\n}\r\nstatic gboolean is_null_pol(e_ctx_hnd *policy_hnd)\r\n{\r\nstatic guint8 null_policy_hnd[20];\r\nreturn memcmp(policy_hnd, null_policy_hnd, 20) == 0;\r\n}\r\nstatic gint pol_hash_compare(gconstpointer k1, gconstpointer k2)\r\n{\r\nconst pol_hash_key *key1 = (const pol_hash_key *)k1;\r\nconst pol_hash_key *key2 = (const pol_hash_key *)k2;\r\nreturn memcmp(key1->policy_hnd, key2->policy_hnd,\r\nsizeof(key1->policy_hnd)) == 0;\r\n}\r\nstatic pol_value *find_pol_handle(e_ctx_hnd *policy_hnd, guint32 frame,\r\npol_hash_value **valuep)\r\n{\r\npol_hash_key key;\r\npol_value *pol;\r\nmemcpy(&key.policy_hnd, policy_hnd, sizeof(key.policy_hnd));\r\nif ((*valuep = (pol_hash_value *)g_hash_table_lookup(pol_hash, &key))) {\r\nfor (pol = (*valuep)->list; pol != NULL; pol = pol->next) {\r\nif (pol->first_frame <= frame &&\r\n(pol->last_frame == 0 ||\r\npol->last_frame >= frame))\r\nbreak;\r\n}\r\nreturn pol;\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nstatic void add_pol_handle(e_ctx_hnd *policy_hnd, guint32 frame,\r\npol_value *pol, pol_hash_value *value)\r\n{\r\npol_hash_key *key;\r\npol_value *polprev, *polnext;\r\nif (value == NULL) {\r\nvalue = (pol_hash_value *)wmem_alloc(wmem_file_scope(), sizeof(pol_hash_value));\r\nvalue->list = pol;\r\npol->next = NULL;\r\nkey = (pol_hash_key *)wmem_alloc(wmem_file_scope(), sizeof(pol_hash_key));\r\nmemcpy(&key->policy_hnd, policy_hnd, sizeof(key->policy_hnd));\r\ng_hash_table_insert(pol_hash, key, value);\r\n} else {\r\nfor (polnext = value->list, polprev = NULL;\r\npolnext != NULL && polnext->first_frame <= frame;\r\npolprev = polnext, polnext = polnext->next)\r\n;\r\nif (polprev == NULL)\r\nvalue->list = pol;\r\nelse\r\npolprev->next = pol;\r\npol->next = polnext;\r\n}\r\n}\r\nvoid dcerpc_smb_store_pol_pkts(e_ctx_hnd *policy_hnd, packet_info *pinfo,\r\ngboolean is_open, gboolean is_close)\r\n{\r\npol_hash_value *value;\r\npol_value *pol;\r\nif (pinfo->fd->flags.visited)\r\nreturn;\r\nif (is_null_pol(policy_hnd))\r\nreturn;\r\npol = find_pol_handle(policy_hnd, pinfo->num, &value);\r\nif (pol != NULL) {\r\nif (is_open) {\r\nif (pol->first_frame == pinfo->num &&\r\npol->last_frame == 0)\r\nreturn;\r\npol->last_frame = pinfo->num;\r\npol = NULL;\r\n} else {\r\nif (is_close) {\r\npol->close_frame = pinfo->num;\r\npol->last_frame = pinfo->num;\r\n}\r\nreturn;\r\n}\r\n}\r\npol = (pol_value *)wmem_alloc(wmem_file_scope(), sizeof(pol_value));\r\npol->open_frame = is_open ? pinfo->num : 0;\r\npol->close_frame = is_close ? pinfo->num : 0;\r\npol->first_frame = pinfo->num;\r\npol->last_frame = pol->close_frame;\r\npol->type=0;\r\npol->name = NULL;\r\nadd_pol_handle(policy_hnd, pinfo->num, pol, value);\r\n}\r\nstatic void dcerpc_store_polhnd_type(e_ctx_hnd *policy_hnd, packet_info *pinfo,\r\nguint32 type)\r\n{\r\npol_hash_value *value;\r\npol_value *pol;\r\nif (pinfo->fd->flags.visited)\r\nreturn;\r\nif (is_null_pol(policy_hnd))\r\nreturn;\r\npol = find_pol_handle(policy_hnd, pinfo->num, &value);\r\nif (pol != NULL) {\r\npol->type=type;\r\n}\r\n}\r\nvoid dcerpc_store_polhnd_name(e_ctx_hnd *policy_hnd, packet_info *pinfo,\r\nconst char *name)\r\n{\r\npol_hash_value *value;\r\npol_value *pol;\r\nif (pinfo->fd->flags.visited)\r\nreturn;\r\nif (is_null_pol(policy_hnd))\r\nreturn;\r\npol = find_pol_handle(policy_hnd, pinfo->num, &value);\r\nif (pol != NULL) {\r\nif (pol->name && name) {\r\n#ifdef DEBUG_HASH_COLL\r\nif (strcmp(pol->name, name) != 0)\r\ng_warning("dcerpc_smb: pol_hash name collision %s/%s\n", value->name, name);\r\n#endif\r\n}\r\npol->name = wmem_strdup(wmem_file_scope(), name);\r\nreturn;\r\n}\r\npol = (pol_value *)wmem_alloc(wmem_file_scope(), sizeof(pol_value));\r\npol->open_frame = 0;\r\npol->close_frame = 0;\r\npol->first_frame = pinfo->num;\r\npol->last_frame = 0;\r\npol->type = 0;\r\nif (name)\r\npol->name = wmem_strdup(wmem_file_scope(), name);\r\nelse\r\npol->name = wmem_strdup(wmem_file_scope(), "<UNKNOWN>");\r\nadd_pol_handle(policy_hnd, pinfo->num, pol, value);\r\n}\r\ngboolean dcerpc_fetch_polhnd_data(e_ctx_hnd *policy_hnd,\r\nchar **name, guint32 *type,\r\nguint32 *open_frame, guint32 *close_frame,\r\nguint32 cur_frame)\r\n{\r\npol_hash_value *value;\r\npol_value *pol;\r\nif (name)\r\n*name = NULL;\r\nif (type)\r\n*type = 0;\r\nif (open_frame)\r\n*open_frame = 0;\r\nif (close_frame)\r\n*close_frame = 0;\r\npol = find_pol_handle(policy_hnd, cur_frame, &value);\r\nif (pol) {\r\nif (name)\r\n*name = pol->name;\r\nif (type)\r\n*type = pol->type;\r\nif (open_frame)\r\n*open_frame = pol->open_frame;\r\nif (close_frame)\r\n*close_frame = pol->close_frame;\r\n}\r\nreturn pol != NULL;\r\n}\r\nstatic void init_pol_hash(void)\r\n{\r\npol_hash = g_hash_table_new(pol_hash_fn, pol_hash_compare);\r\n}\r\nstatic void cleanup_pol_hash(void)\r\n{\r\ng_hash_table_destroy(pol_hash);\r\n}\r\nint\r\ndissect_ntstatus(tvbuff_t *tvb, gint offset, packet_info *pinfo,\r\nproto_tree *tree, dcerpc_info *di, guint8 *drep,\r\nint hfindex, guint32 *pdata)\r\n{\r\nguint32 status;\r\noffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\nhfindex, &status);\r\nif (status != 0)\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %s",\r\nval_to_str_ext(status, &NT_errors_ext,\r\n"Unknown error 0x%08x"));\r\nif (pdata)\r\n*pdata = status;\r\nreturn offset;\r\n}\r\nint\r\ndissect_doserror(tvbuff_t *tvb, gint offset, packet_info *pinfo,\r\nproto_tree *tree, dcerpc_info *di, guint8 *drep,\r\nint hfindex, guint32 *pdata)\r\n{\r\nguint32 status;\r\noffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\nhfindex, &status);\r\nif (status != 0)\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %s",\r\nval_to_str_ext(status, &DOS_errors_ext,\r\n"Unknown error 0x%08x"));\r\nif (pdata)\r\n*pdata = status;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nt_hnd(tvbuff_t *tvb, gint offset, packet_info *pinfo,\r\nproto_tree *tree, dcerpc_info *di, guint8 *drep, int hfindex,\r\ne_ctx_hnd *pdata, proto_item **pitem,\r\ngboolean is_open, gboolean is_close, e_hnd_type type)\r\n{\r\nproto_item *item=NULL;\r\nproto_tree *subtree;\r\ne_ctx_hnd hnd;\r\nguint32 open_frame = 0, close_frame = 0;\r\nchar *name;\r\nint old_offset = offset;\r\nif(di->conformant_run){\r\nreturn offset;\r\n}\r\nswitch(type){\r\ncase HND_TYPE_CTX_HANDLE:\r\nif (!di->no_align && (offset % 4)) {\r\noffset += 4 - (offset % 4);\r\n}\r\nsubtree = proto_tree_add_subtree(tree, tvb, offset, sizeof(e_ctx_hnd),\r\nett_nt_policy_hnd, &item, "Policy Handle");\r\noffset = dissect_ndr_ctx_hnd(tvb, offset, pinfo, subtree, di, drep,\r\nhfindex, &hnd);\r\nbreak;\r\ncase HND_TYPE_GUID:\r\nsubtree = proto_tree_add_subtree(tree, tvb, offset, 16,\r\nett_nt_policy_hnd, &item, "GUID handle");\r\nhnd.attributes=0;\r\noffset=dissect_ndr_uuid_t(tvb, offset, pinfo, subtree, di, drep, hfindex, &hnd.uuid);\r\nbreak;\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nreturn offset;\r\n}\r\ndcerpc_smb_store_pol_pkts(&hnd, pinfo, is_open, is_close);\r\nif (dcerpc_fetch_polhnd_data(&hnd, &name, NULL, &open_frame,\r\n&close_frame, pinfo->num)) {\r\nif (open_frame) {\r\nproto_item *item_local;\r\nitem_local=proto_tree_add_uint(\r\nsubtree, hf_nt_policy_open_frame, tvb,\r\nold_offset, sizeof(e_ctx_hnd), open_frame);\r\nPROTO_ITEM_SET_GENERATED(item_local);\r\n}\r\nif (close_frame) {\r\nproto_item *item_local;\r\nitem_local=proto_tree_add_uint(\r\nsubtree, hf_nt_policy_close_frame, tvb,\r\nold_offset, sizeof(e_ctx_hnd), close_frame);\r\nPROTO_ITEM_SET_GENERATED(item_local);\r\n}\r\nif (name != NULL && pitem == NULL)\r\nproto_item_append_text(item, ": %s", name);\r\n}\r\nif (pdata)\r\n*pdata = hnd;\r\nif (pitem)\r\n*pitem = item;\r\nreturn offset;\r\n}\r\nint\r\ndissect_nt_policy_hnd(tvbuff_t *tvb, gint offset, packet_info *pinfo,\r\nproto_tree *tree, dcerpc_info *di, guint8 *drep, int hfindex,\r\ne_ctx_hnd *pdata, proto_item **pitem,\r\ngboolean is_open, gboolean is_close)\r\n{\r\noffset=dissect_nt_hnd(tvb, offset, pinfo,\r\ntree, di, drep, hfindex,\r\npdata, pitem,\r\nis_open, is_close, HND_TYPE_CTX_HANDLE);\r\nreturn offset;\r\n}\r\nint\r\nPIDL_dissect_policy_hnd(tvbuff_t *tvb, gint offset, packet_info *pinfo,\r\nproto_tree *tree, dcerpc_info* di, guint8 *drep, int hfindex,\r\nguint32 param)\r\n{\r\ne_ctx_hnd policy_hnd;\r\noffset=dissect_nt_hnd(tvb, offset, pinfo,\r\ntree, di, drep, hfindex,\r\n&policy_hnd, NULL,\r\nparam&PIDL_POLHND_OPEN, param&PIDL_POLHND_CLOSE,\r\nHND_TYPE_CTX_HANDLE);\r\nif((param&PIDL_POLHND_OPEN)\r\n&& !pinfo->fd->flags.visited\r\n&& !di->conformant_run){\r\nchar *pol_string=NULL;\r\nconst char *pol_name=NULL;\r\ndcerpc_call_value *dcv;\r\ndcv = (dcerpc_call_value *)di->call_data;\r\npol_name = (const char *)dcv->private_data;\r\nif(!pol_name){\r\npol_name="<...>";\r\n}\r\npol_string=wmem_strdup_printf(wmem_packet_scope(), "%s(%s)", di->dcerpc_procedure_name, pol_name);\r\ndcerpc_store_polhnd_name(&policy_hnd, pinfo, pol_string);\r\ndcerpc_store_polhnd_type(&policy_hnd, pinfo, param&PIDL_POLHND_TYPE_MASK);\r\n}\r\nif(!pinfo->fd->flags.visited\r\n&& !di->conformant_run){\r\ndcerpc_call_value *dcv;\r\ndcv = (dcerpc_call_value *)di->call_data;\r\nif(!dcv->pol){\r\ndcv->pol=(e_ctx_hnd *)wmem_memdup(wmem_file_scope(), &policy_hnd, sizeof(e_ctx_hnd));\r\n}\r\n}\r\nreturn offset;\r\n}\r\nint\r\ndissect_nt_guid_hnd(tvbuff_t *tvb, gint offset, packet_info *pinfo,\r\nproto_tree *tree, dcerpc_info *di, guint8 *drep, int hfindex,\r\ne_ctx_hnd *pdata, proto_item **pitem,\r\ngboolean is_open, gboolean is_close)\r\n{\r\noffset=dissect_nt_hnd(tvb, offset, pinfo,\r\ntree, di, drep, hfindex,\r\npdata, pitem,\r\nis_open, is_close, HND_TYPE_GUID);\r\nreturn offset;\r\n}\r\nint\r\ndissect_dcerpc_uint8s(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\r\nproto_tree *tree, dcerpc_info *di _U_, guint8 *drep _U_, int hfindex,\r\nint length, const guint8 **pdata)\r\n{\r\nconst guint8 *data;\r\ndata = (const guint8 *)tvb_get_ptr(tvb, offset, length);\r\nif (tree) {\r\nproto_tree_add_item (tree, hfindex, tvb, offset, length, ENC_NA);\r\n}\r\nif (pdata)\r\n*pdata = data;\r\nreturn offset + length;\r\n}\r\nint\r\ndissect_ndr_uint8s(tvbuff_t *tvb, gint offset, packet_info *pinfo,\r\nproto_tree *tree, dcerpc_info *di, guint8 *drep,\r\nint hfindex, int length, const guint8 **pdata)\r\n{\r\nif(di->conformant_run){\r\nreturn offset;\r\n}\r\nreturn dissect_dcerpc_uint8s(tvb, offset, pinfo,\r\ntree, di, drep, hfindex, length, pdata);\r\n}\r\nint\r\ndissect_dcerpc_uint16s(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\r\nproto_tree *tree, guint8 *drep, int hfindex,\r\nint length)\r\n{\r\nif (tree) {\r\nproto_tree_add_item (tree, hfindex, tvb, offset, length * 2, DREP_ENC_INTEGER(drep));\r\n}\r\nreturn offset + length * 2;\r\n}\r\nint\r\ndissect_ndr_uint16s(tvbuff_t *tvb, gint offset, packet_info *pinfo,\r\nproto_tree *tree, dcerpc_info *di, guint8 *drep,\r\nint hfindex, int length)\r\n{\r\nif(di->conformant_run){\r\nreturn offset;\r\n}\r\nif (offset % 2)\r\noffset++;\r\nreturn dissect_dcerpc_uint16s(tvb, offset, pinfo,\r\ntree, drep, hfindex, length);\r\n}\r\nvoid cb_wstr_postprocess(packet_info *pinfo, proto_tree *tree _U_,\r\nproto_item *item, dcerpc_info *di, tvbuff_t *tvb,\r\nint start_offset, int end_offset,\r\nvoid *callback_args)\r\n{\r\ngint options = GPOINTER_TO_INT(callback_args);\r\ngint levels = CB_STR_ITEM_LEVELS(options);\r\nchar *s;\r\nif (start_offset % 4)\r\nstart_offset += 4 - (start_offset % 4);\r\nif ((end_offset - start_offset) <= 12)\r\nreturn;\r\ns = tvb_get_string_enc(wmem_packet_scope(),\r\ntvb, start_offset + 12, end_offset - start_offset - 12,\r\nENC_UTF_16|ENC_LITTLE_ENDIAN);\r\nif (options & CB_STR_COL_INFO) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %s", s);\r\n}\r\nif (levels > 0 && item && s && s[0]) {\r\nproto_item_append_text(item, ": %s", s);\r\nitem = GET_ITEM_PARENT(item);\r\nlevels--;\r\nif (item && levels > 0) {\r\nproto_item_append_text(item, ": %s", s);\r\nitem = GET_ITEM_PARENT(item);\r\nlevels--;\r\nwhile (item && levels > 0) {\r\nproto_item_append_text(item, " %s", s);\r\nitem = GET_ITEM_PARENT(item);\r\nlevels--;\r\n}\r\n}\r\n}\r\nif (options & CB_STR_SAVE) {\r\ndcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\ndcv->private_data = s;\r\n}\r\n}\r\nvoid cb_str_postprocess(packet_info *pinfo, proto_tree *tree _U_,\r\nproto_item *item, dcerpc_info *di, tvbuff_t *tvb,\r\nint start_offset, int end_offset,\r\nvoid *callback_args)\r\n{\r\ngint options = GPOINTER_TO_INT(callback_args);\r\ngint levels = CB_STR_ITEM_LEVELS(options);\r\nguint8 *s;\r\nif (start_offset % 4)\r\nstart_offset += 4 - (start_offset % 4);\r\nif ((end_offset - start_offset) <= 12)\r\nreturn;\r\ns = tvb_get_string_enc(wmem_packet_scope(),\r\ntvb, start_offset + 12, (end_offset - start_offset - 12), ENC_ASCII);\r\nif (options & CB_STR_COL_INFO) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %s", s);\r\n}\r\nif (levels > 0 && item && s && s[0]) {\r\nproto_item_append_text(item, ": %s", s);\r\nitem = GET_ITEM_PARENT(item);\r\nlevels--;\r\nif (levels > 0) {\r\nproto_item_append_text(item, ": %s", s);\r\nitem = GET_ITEM_PARENT(item);\r\nlevels--;\r\nwhile (levels > 0) {\r\nproto_item_append_text(item, " %s", s);\r\nitem = GET_ITEM_PARENT(item);\r\nlevels--;\r\n}\r\n}\r\n}\r\nif (options & CB_STR_SAVE) {\r\ndcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\ndcv->private_data = s;\r\n}\r\n}\r\nint dissect_ndr_str_pointer_item(tvbuff_t *tvb, gint offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep, int type, const char *text,\r\nint hf_index, int levels)\r\n{\r\nreturn dissect_ndr_pointer_cb(\r\ntvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_wchar_cvstring, type, text, hf_index,\r\ncb_wstr_postprocess, GINT_TO_POINTER(levels + 1));\r\n}\r\nint\r\ndissect_ndr_nt_SID28(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\nproto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\r\n{\r\nproto_item *item;\r\ndcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\nchar *sid_str=NULL;\r\nconst char *name;\r\nint newoffset;\r\nif(di->hf_index!=-1){\r\nname=proto_registrar_get_name(di->hf_index);\r\n} else {\r\nname="Domain";\r\n}\r\nif(di->conformant_run){\r\nreturn offset;\r\n}\r\nnewoffset = dissect_nt_sid(tvb, offset, tree, name, &sid_str,\r\nhf_nt_domain_sid);\r\nif ((newoffset - offset) > 28) {\r\nitem = proto_tree_get_parent(tree? tree->last_child : NULL);\r\nexpert_add_info(pinfo, item, &ei_dcerpc_nt_badsid);\r\nreturn newoffset;\r\n}\r\nif (tree) {\r\nitem = proto_tree_get_parent(tree->last_child);\r\nproto_item_set_len(item, 28);\r\n}\r\noffset += 28;\r\nif(dcv){\r\ndcv->private_data = wmem_strdup(wmem_file_scope(), sid_str);\r\n}\r\nreturn offset;\r\n}\r\nint\r\ndissect_ndr_nt_SID(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\nproto_tree *tree, dcerpc_info *di, guint8 *drep)\r\n{\r\ndcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\nchar *sid_str=NULL;\r\nconst char *name;\r\nif(di->hf_index!=-1){\r\nname=proto_registrar_get_name(di->hf_index);\r\n} else {\r\nname="Domain";\r\n}\r\nif(di->conformant_run){\r\nreturn offset;\r\n}\r\noffset = dissect_ndr_uint3264 (tvb, offset, pinfo, tree, di, drep,\r\nhf_nt_count, NULL);\r\noffset = dissect_nt_sid(tvb, offset, tree, name, &sid_str,\r\nhf_nt_domain_sid);\r\nif(dcv){\r\ndcv->private_data = wmem_strdup(wmem_file_scope(), sid_str);\r\n}\r\nreturn offset;\r\n}\r\nint\r\ndissect_ndr_nt_SID_with_options(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, dcerpc_info *di, guint8 *drep, guint32 options)\r\n{\r\ndcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\ngint levels = CB_STR_ITEM_LEVELS(options);\r\noffset=dissect_ndr_nt_SID(tvb, offset, pinfo, tree, di, drep);\r\nif(dcv && dcv->private_data){\r\nchar *s=(char *)dcv->private_data;\r\nproto_item *item=(proto_item *)tree;\r\nif ((options & CB_STR_COL_INFO)&&(!di->conformant_run)) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %s", s);\r\n}\r\nif (levels > 0 && item && s && s[0]) {\r\nproto_item_append_text(item, ": %s", s);\r\nitem = GET_ITEM_PARENT(item);\r\nlevels--;\r\nif (levels > 0) {\r\nproto_item_append_text(item, ": %s", s);\r\nitem = GET_ITEM_PARENT(item);\r\nlevels--;\r\nwhile (levels > 0) {\r\nproto_item_append_text(item, " %s", s);\r\nitem = GET_ITEM_PARENT(item);\r\nlevels--;\r\n}\r\n}\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_ndr_nt_SID_hf_through_ptr(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\nproto_tree *tree, dcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_ndr_nt_SID(tvb, offset, pinfo, tree, di, drep);\r\nreturn offset;\r\n}\r\nint\r\ndissect_ndr_nt_PSID(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *parent_tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\nproto_item *item=NULL;\r\nproto_tree *tree=NULL;\r\nint old_offset=offset;\r\nif(parent_tree){\r\ntree = proto_tree_add_subtree(parent_tree, tvb, offset, -1,\r\nett_nt_sid_pointer, &item, "SID pointer:");\r\n}\r\noffset = dissect_ndr_pointer(tvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_nt_SID_hf_through_ptr, NDR_POINTER_UNIQUE,\r\n"SID pointer", hf_nt_domain_sid);\r\nproto_item_set_len(item, offset-old_offset);\r\nreturn offset;\r\n}\r\nint\r\ndissect_ndr_nt_acct_ctrl(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\nproto_tree *parent_tree, dcerpc_info *di, guint8 *drep)\r\n{\r\nguint32 mask;\r\nstatic const int * flags[] = {\r\n&hf_nt_acb_autolock,\r\n&hf_nt_acb_pwnoexp,\r\n&hf_nt_acb_svrtrust,\r\n&hf_nt_acb_wstrust,\r\n&hf_nt_acb_domtrust,\r\n&hf_nt_acb_mns,\r\n&hf_nt_acb_normal,\r\n&hf_nt_acb_tempdup,\r\n&hf_nt_acb_pwnotreq,\r\n&hf_nt_acb_homedirreq,\r\n&hf_nt_acb_disabled,\r\nNULL\r\n};\r\noffset=dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &mask);\r\nproto_tree_add_bitmask_value_with_flags(parent_tree, tvb, offset-4, hf_nt_acct_ctrl,\r\nett_nt_acct_ctrl, flags, mask, BMT_NO_APPEND);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_LOGON_HOURS_entry(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_ndr_uint8(tvb, offset, pinfo, tree, di, drep,\r\nhf_logonhours_unknown_char, NULL);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_LOGON_HOURS_hours(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *parent_tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\nproto_item *item=NULL;\r\nproto_tree *tree=NULL;\r\nint old_offset=offset;\r\nif(parent_tree){\r\ntree = proto_tree_add_subtree(parent_tree, tvb, offset, -1,\r\nett_nt_logon_hours_hours, &item, "LOGON_HOURS:");\r\n}\r\noffset = dissect_ndr_ucvarray(tvb, offset, pinfo, tree, di, drep,\r\ndissect_LOGON_HOURS_entry);\r\nproto_item_set_len(item, offset-old_offset);\r\nreturn offset;\r\n}\r\nint\r\ndissect_ndr_nt_LOGON_HOURS(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *parent_tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\nproto_item *item=NULL;\r\nproto_tree *tree=NULL;\r\nint old_offset=offset;\r\nALIGN_TO_4_BYTES;\r\nif(parent_tree){\r\ntree = proto_tree_add_subtree(parent_tree, tvb, offset, -1,\r\nett_nt_logon_hours, &item, "LOGON_HOURS:");\r\n}\r\noffset = dissect_ndr_uint16(tvb, offset, pinfo, tree, di, drep,\r\nhf_logonhours_divisions, NULL);\r\noffset = dissect_ndr_pointer(tvb, offset, pinfo, tree, di, drep,\r\ndissect_LOGON_HOURS_hours, NDR_POINTER_UNIQUE,\r\n"LOGON_HOURS", -1);\r\nproto_item_set_len(item, offset-old_offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_ndr_nt_PSID_no_hf(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *parent_tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\noffset=dissect_ndr_nt_PSID(tvb, offset, pinfo, parent_tree, di, drep);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_ndr_nt_PSID_ARRAY_sids (tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\noffset = dissect_ndr_ucarray(tvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_nt_PSID_no_hf);\r\nreturn offset;\r\n}\r\nint\r\ndissect_ndr_nt_PSID_ARRAY(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *parent_tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\nguint32 count;\r\nproto_item *item=NULL;\r\nproto_tree *tree=NULL;\r\nint old_offset=offset;\r\nif(parent_tree){\r\ntree = proto_tree_add_subtree(parent_tree, tvb, offset, -1,\r\nett_nt_sid_array, &item, "SID array:");\r\n}\r\nALIGN_TO_5_BYTES;\r\noffset = dissect_ndr_uint32 (tvb, offset, pinfo, tree, di, drep,\r\nhf_nt_count, &count);\r\noffset = dissect_ndr_pointer(tvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_nt_PSID_ARRAY_sids, NDR_POINTER_UNIQUE,\r\n"PSID_ARRAY", -1);\r\nproto_item_set_len(item, offset-old_offset);\r\nif (di->call_data->flags & DCERPC_IS_NDR64) {\r\nALIGN_TO_5_BYTES;\r\n}\r\nreturn offset;\r\n}\r\nint\r\ndissect_ndr_nt_SID_AND_ATTRIBUTES(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *parent_tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\nproto_item *item=NULL;\r\nproto_tree *tree=NULL;\r\nif(parent_tree){\r\ntree = proto_tree_add_subtree(parent_tree, tvb, offset, 0,\r\nett_nt_sid_and_attributes, &item, "SID_AND_ATTRIBUTES:");\r\n}\r\noffset = dissect_ndr_nt_PSID(tvb, offset, pinfo, tree, di, drep);\r\noffset = dissect_ndr_uint32 (tvb, offset, pinfo, tree, di, drep,\r\nhf_nt_attrib, NULL);\r\nreturn offset;\r\n}\r\nint\r\ndissect_ndr_nt_SID_AND_ATTRIBUTES_ARRAY(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *parent_tree,\r\ndcerpc_info *di, guint8 *drep)\r\n{\r\nproto_item *item=NULL;\r\nproto_tree *tree=NULL;\r\nint old_offset=offset;\r\nif(parent_tree){\r\ntree = proto_tree_add_subtree(parent_tree, tvb, offset, 0,\r\nett_nt_sid_and_attributes_array, &item, "SID_AND_ATTRIBUTES array:");\r\n}\r\noffset = dissect_ndr_ucarray(tvb, offset, pinfo, tree, di, drep,\r\ndissect_ndr_nt_SID_AND_ATTRIBUTES);\r\nproto_item_set_len(item, offset-old_offset);\r\nreturn offset;\r\n}\r\nint\r\nnt_dissect_MIDL_NDRHEADERBLOB(proto_tree *parent_tree, tvbuff_t *tvb, int offset, guint8 *drep)\r\n{\r\nproto_tree *tree;\r\nguint8 val;\r\ntree=proto_tree_add_subtree(parent_tree, tvb, offset, 16, ett_nt_MIDL_BLOB, NULL, "MES header");\r\nproto_tree_add_item(tree, hf_nt_midl_version, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\nval = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(tree, hf_dcerpc_drep_byteorder, tvb, offset, 1, val>>4);\r\noffset++;\r\nif (drep) {\r\n*drep = val;\r\n}\r\nproto_tree_add_item(tree, hf_nt_midl_hdr_len, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(tree, hf_nt_midl_fill_bytes, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_nt_midl_blob_len, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\nreturn offset;\r\n}\r\nvoid dcerpc_smb_init(int proto_dcerpc)\r\n{\r\nexpert_module_t* expert_dcerpc_nt;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_nt_cs_size,\r\n{ "Size", "dcerpc.nt.str.size", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "Size of string in short integers",\r\nHFILL }},\r\n{ &hf_nt_cs_len,\r\n{ "Length", "dcerpc.nt.str.len", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "Length of string in short integers",\r\nHFILL }},\r\n{ &hf_nt_guid,\r\n{ "GUID", "dcerpc.nt.guid", FT_GUID, BASE_NONE,\r\nNULL, 0x0, "GUID (uuid for groups?)", HFILL }},\r\n{ &hf_nt_policy_open_frame,\r\n{ "Frame handle opened", "dcerpc.nt.open_frame",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nt_policy_close_frame,\r\n{ "Frame handle closed", "dcerpc.nt.close_frame",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nt_acct_ctrl,\r\n{ "Acct Ctrl", "dcerpc.nt.acct_ctrl", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_nt_acb_disabled,\r\n{ "Account disabled", "dcerpc.nt.acb.disabled", FT_BOOLEAN, 32,\r\nTFS(&tfs_nt_acb_disabled), 0x0001,\r\n"If this account is enabled or disabled", HFILL }},\r\n{ &hf_nt_acb_homedirreq,\r\n{ "Home dir required", "dcerpc.nt.acb.homedirreq", FT_BOOLEAN, 32,\r\nTFS(&tfs_nt_acb_homedirreq), 0x0002,\r\n"Is homedirs required for this account?", HFILL }},\r\n{ &hf_nt_acb_pwnotreq,\r\n{ "Password required", "dcerpc.nt.acb.pwnotreq", FT_BOOLEAN, 32,\r\nTFS(&tfs_nt_acb_pwnotreq), 0x0004,\r\n"If a password is required for this account?", HFILL }},\r\n{ &hf_nt_acb_tempdup,\r\n{ "Temporary duplicate account", "dcerpc.nt.acb.tempdup", FT_BOOLEAN, 32,\r\nTFS(&tfs_nt_acb_tempdup), 0x0008,\r\n"If this is a temporary duplicate account", HFILL }},\r\n{ &hf_nt_acb_normal,\r\n{ "Normal user account", "dcerpc.nt.acb.normal", FT_BOOLEAN, 32,\r\nTFS(&tfs_nt_acb_normal), 0x0010,\r\n"If this is a normal user account", HFILL }},\r\n{ &hf_nt_acb_mns,\r\n{ "MNS logon user account", "dcerpc.nt.acb.mns", FT_BOOLEAN, 32,\r\nTFS(&tfs_nt_acb_mns), 0x0020,\r\nNULL, HFILL }},\r\n{ &hf_nt_acb_domtrust,\r\n{ "Interdomain trust account", "dcerpc.nt.acb.domtrust", FT_BOOLEAN, 32,\r\nTFS(&tfs_nt_acb_domtrust), 0x0040,\r\nNULL, HFILL }},\r\n{ &hf_nt_acb_wstrust,\r\n{ "Workstation trust account", "dcerpc.nt.acb.wstrust", FT_BOOLEAN, 32,\r\nTFS(&tfs_nt_acb_wstrust), 0x0080,\r\nNULL, HFILL }},\r\n{ &hf_nt_acb_svrtrust,\r\n{ "Server trust account", "dcerpc.nt.acb.svrtrust", FT_BOOLEAN, 32,\r\nTFS(&tfs_nt_acb_svrtrust), 0x0100,\r\nNULL, HFILL }},\r\n{ &hf_nt_acb_pwnoexp,\r\n{ "Password expires", "dcerpc.nt.acb.pwnoexp", FT_BOOLEAN, 32,\r\nTFS(&tfs_nt_acb_pwnoexp), 0x0200,\r\n"If this account expires or not", HFILL }},\r\n{ &hf_nt_acb_autolock,\r\n{ "Account is autolocked", "dcerpc.nt.acb.autolock", FT_BOOLEAN, 32,\r\nTFS(&tfs_nt_acb_autolock), 0x0400,\r\n"If this account has been autolocked", HFILL }},\r\n{ &hf_nt_error,\r\n{ "Wrong string type", "dcerpc.nt.sting_error",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Non terminated string", HFILL }},\r\n{ &hf_nt_domain_sid,\r\n{ "Domain SID", "dcerpc.nt.domain_sid",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"The Domain SID", HFILL }},\r\n{ &hf_nt_count,\r\n{ "Count", "dcerpc.nt.count",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Number of elements in following array", HFILL }},\r\n{ &hf_logonhours_divisions,\r\n{ "Divisions", "dcerpc.nt.logonhours.divisions",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Number of divisions for LOGON_HOURS", HFILL }},\r\n{ &hf_logonhours_unknown_char,\r\n{ "Unknown char", "dcerpc.nt.unknown.char",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\n"Unknown char. If you know what this is, contact wireshark developers.", HFILL }},\r\n{ &hf_nt_attrib,\r\n{ "Attributes", "dcerpc.nt.attr",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_lsa_String_name_len,\r\n{ "Name Len", "dcerpc.lsa_String.name_len",\r\nFT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_lsa_String_name_size,\r\n{ "Name Size", "dcerpc.lsa_String.name_size",\r\nFT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_nt_data_blob_len,\r\n{ "Blob size", "dcerpc.nt.blob.size",\r\nFT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_nt_data_blob_data,\r\n{ "Blob data", "dcerpc.nt.blob.data",\r\nFT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_nt_midl_blob_len, {\r\n"Blob Length", "nt.midl_blob_len", FT_UINT64, BASE_DEC,\r\nNULL, 0, "Length of NDR encoded data that follows", HFILL }},\r\n{ &hf_nt_midl_fill_bytes, {\r\n"Fill bytes", "nt.midl.fill_bytes", FT_UINT32, BASE_HEX,\r\nNULL, 0, "Just some fill bytes", HFILL }},\r\n{ &hf_nt_midl_version, {\r\n"Version", "nt.midl.version", FT_UINT8, BASE_DEC,\r\nNULL, 0, "Version of pickling", HFILL }},\r\n{ &hf_nt_midl_hdr_len, {\r\n"HDR Length", "nt.midl.hdr_len", FT_UINT16, BASE_DEC,\r\nNULL, 0, "Length of header", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_nt_data_blob,\r\n&ett_nt_counted_string,\r\n&ett_nt_counted_byte_array,\r\n&ett_nt_policy_hnd,\r\n&ett_nt_sid_pointer,\r\n&ett_nt_acct_ctrl,\r\n&ett_nt_logon_hours,\r\n&ett_nt_logon_hours_hours,\r\n&ett_nt_sid_array,\r\n&ett_nt_sid_and_attributes_array,\r\n&ett_nt_sid_and_attributes,\r\n&ett_nt_counted_ascii_string,\r\n&ett_lsa_String,\r\n&ett_nt_MIDL_BLOB,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_dcerpc_nt_badsid, { "dcerpc.nt.badsid", PI_MALFORMED, PI_ERROR, "Association rejected", EXPFILL }},\r\n};\r\nproto_register_subtree_array(ett, array_length(ett));\r\nproto_register_field_array(proto_dcerpc, hf, array_length(hf));\r\nexpert_dcerpc_nt = expert_register_protocol(proto_dcerpc);\r\nexpert_register_field_array(expert_dcerpc_nt, ei, array_length(ei));\r\nregister_init_routine(&init_pol_hash);\r\nregister_cleanup_routine(&cleanup_pol_hash);\r\n}
