static int\r\ndissect_scop(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ntvbuff_t *next_tvb;\r\nproto_item *proto_root;\r\nproto_tree *scop_tree;\r\nguint offset = 0;\r\nscop_packet packet;\r\nmemset(&packet, 0, sizeof(packet));\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "SCoP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nproto_root = proto_tree_add_protocol_format(tree, proto_scop, tvb, 0, tvb_captured_length(tvb),\r\n"ZigBee SCoP");\r\nscop_tree = proto_item_add_subtree(proto_root, ett_scop);\r\npacket.transport = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(scop_tree, hf_scop_transport, tvb, offset, 1, packet.transport);\r\noffset += 1;\r\npacket.version = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(scop_tree, hf_scop_version, tvb, offset, 1, packet.version);\r\noffset += 1;\r\npacket.length = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint(scop_tree, hf_scop_length, tvb, offset, 2, packet.length);\r\noffset += 2;\r\nif ( (packet.transport == SCOP_TRANSPORT_UDP_CCM)\r\n|| (packet.transport == SCOP_TRANSPORT_TCP_CCM)) {\r\nreturn offset;\r\n}\r\nnext_tvb = tvb;\r\npacket.service = tvb_get_guint8(next_tvb, offset);\r\nproto_tree_add_uint(scop_tree, hf_scop_service, next_tvb, offset, 1, packet.service);\r\noffset += 1;\r\nswitch (packet.service) {\r\ncase SCOP_SERVICE_SCOP:\r\ndissect_scop_zip(tvb_new_subset_remaining(next_tvb, offset), pinfo, scop_tree);\r\nbreak;\r\ncase SCOP_SERVICE_BRIDGE:\r\ndissect_scop_bridge(tvb_new_subset_remaining(next_tvb, offset), pinfo, scop_tree);\r\nbreak;\r\ncase SCOP_SERVICE_GATEWAY:\r\ndefault:\r\ncall_data_dissector(tvb_new_subset_remaining(next_tvb, offset), pinfo, tree);\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic guint\r\nget_scop_length(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nreturn tvb_get_ntohs(tvb, offset + SCOP_LENGTH_OFFSET);\r\n}\r\nstatic int\r\ndissect_scop_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, tree, TRUE, SCOP_HEADER_LENGTH, get_scop_length, dissect_scop, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_scop_zip(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint offset = 0;\r\nguint8 type = tvb_get_guint8(tvb, offset);\r\nguint16 status;\r\nproto_tree_add_uint(tree, hf_scop_type, tvb, offset, 1, type);\r\nproto_item_append_text(tree, ", %s", val_to_str_const(type, scop_types, "Reserved Type"));\r\ncol_set_str(pinfo->cinfo, COL_INFO, val_to_str_const(type, scop_types, "Reserved Type"));\r\noffset += 2;\r\nif (type == SCOP_CMD_HELLO_RESP) {\r\nstatus = tvb_get_ntohs(tvb, 1);\r\nproto_tree_add_uint_format_value(tree, hf_scop_status, tvb, offset, 2, status, "%s", (status==0x0000)?"Success":"Failure");\r\noffset += 2;\r\n}\r\nif (offset < tvb_reported_length(tvb)) {\r\ntvbuff_t *payload_tvb = tvb_new_subset_remaining(tvb, offset);\r\nproto_tree *root = proto_tree_get_root(tree);\r\ncall_data_dissector(payload_tvb, pinfo, root);\r\n}\r\n}\r\nstatic void\r\ndissect_scop_bridge(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\ncall_dissector(ieee802154_handle, tvb, pinfo, proto_tree_get_root(tree));\r\n}\r\nvoid proto_register_scop(void)\r\n{\r\nmodule_t *scop_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_scop_transport,\r\n{ "Transport Type", "scop.transport", FT_UINT8, BASE_DEC, VALS(scop_transports), 0x0,\r\n"The type of transport used.", HFILL }},\r\n{ &hf_scop_version,\r\n{ "Version", "scop.version", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"The version of the sniffer.", HFILL }},\r\n{ &hf_scop_length,\r\n{ "Length", "scop.length", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_scop_service,\r\n{ "Service Identifier", "scop.service", FT_UINT8, BASE_DEC, VALS(scop_services), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_scop_type,\r\n{ "Packet Type", "scop.type", FT_UINT8, BASE_DEC, VALS(scop_types), 0x0,\r\n"Service-specific packet type.", HFILL }},\r\n{ &hf_scop_status,\r\n{ "Status", "scop.status", FT_UINT16, BASE_HEX, NULL, 0x0,\r\n"Status of the SCoP Command.", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_scop\r\n};\r\nproto_scop = proto_register_protocol("ZigBee SCoP", "SCoP", "scop");\r\nproto_register_field_array(proto_scop, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nscop_module = prefs_register_protocol(proto_scop, proto_reg_handoff_scop);\r\nprefs_register_uint_preference(scop_module, "port", "SCoP Port",\r\n"Set the port for SCoP\n",\r\n10, &gPREF_scop_port);\r\nprefs_register_uint_preference(scop_module, "port_secure", "SCoP Secured Port",\r\n"Set the port for secured SCoP\n",\r\n10, &gPREF_scop_port_secured);\r\nregister_dissector("scop.udp", dissect_scop, proto_scop);\r\nregister_dissector("scop.tcp", dissect_scop_tcp, proto_scop);\r\n}\r\nvoid proto_reg_handoff_scop(void)\r\n{\r\nstatic gboolean inited = FALSE;\r\nstatic guint32 lastPort;\r\nstatic guint32 lastPort_secured;\r\nstatic dissector_handle_t scop_udp_handle;\r\nstatic dissector_handle_t scop_tcp_handle;\r\nif (!inited){\r\nscop_udp_handle = find_dissector("scop.udp");\r\nscop_tcp_handle = find_dissector("scop.tcp");\r\nieee802154_handle = find_dissector_add_dependency("wpan_nofcs", proto_scop);\r\ninited = TRUE;\r\n} else {\r\ndissector_delete_uint("udp.port", lastPort, scop_udp_handle);\r\ndissector_delete_uint("tcp.port", lastPort, scop_tcp_handle);\r\ndissector_delete_uint("udp.port", lastPort_secured, scop_udp_handle);\r\ndissector_delete_uint("tcp.port", lastPort_secured, scop_tcp_handle);\r\n}\r\ndissector_add_uint("udp.port", gPREF_scop_port, scop_udp_handle);\r\ndissector_add_uint("tcp.port", gPREF_scop_port, scop_tcp_handle);\r\ndissector_add_uint("udp.port", gPREF_scop_port_secured, scop_udp_handle);\r\ndissector_add_uint("tcp.port", gPREF_scop_port_secured, scop_tcp_handle);\r\nlastPort = gPREF_scop_port;\r\nlastPort_secured = gPREF_scop_port_secured;\r\n}
