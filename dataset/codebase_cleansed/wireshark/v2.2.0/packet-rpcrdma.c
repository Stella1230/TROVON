static guint parse_list(tvbuff_t *tvb, guint offset, proto_tree *tree,\r\nint hf_item, const char* msg, gboolean have_position)\r\n{\r\nproto_item *fitem;\r\nproto_tree *ftree;\r\nguint32 arr_len, i, val, j;\r\narr_len = tvb_get_ntohl(tvb, offset);\r\nfitem = proto_tree_add_uint_format(tree, hf_item, tvb, offset, 4, arr_len,\r\n"%s (count: %u)", msg, arr_len);\r\noffset += 4;\r\nftree = proto_item_add_subtree(fitem, ett_rpcordma_chunk);\r\nfor (i = 0; i < arr_len; ++i) {\r\nval = tvb_get_ntohl(tvb, offset);\r\noffset += 4;\r\nfor (j = 0; j < val; ++j) {\r\nif (have_position) {\r\nproto_tree_add_item(ftree, hf_rpcordma_position, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nproto_tree_add_item(ftree, hf_rpcordma_rdma_handle, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(ftree, hf_rpcordma_rdma_length, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(ftree, hf_rpcordma_rdma_offset, tvb,\r\noffset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic guint parse_rdma_header(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\noffset = parse_list(tvb, offset, tree, hf_rpcordma_reads_count, "Reads", TRUE);\r\noffset = parse_list(tvb, offset, tree, hf_rpcordma_writes_count, "Writes", FALSE);\r\noffset = parse_list(tvb, offset, tree, hf_rpcordma_reply_count, "Reply", FALSE);\r\nreturn offset;\r\n}\r\nstatic gboolean\r\nget_chunk_len(tvbuff_t *tvb, guint offset, guint len, guint num_position_bytes, guint *res)\r\n{\r\nguint32 arr_len, i, val, temp;\r\nif (offset + 4 > len)\r\nreturn FALSE;\r\narr_len = tvb_get_ntohl(tvb, offset);\r\noffset += 4;\r\nfor (i = 0; i < arr_len; i++) {\r\nif (offset + 4 > len)\r\nreturn FALSE;\r\nval = tvb_get_ntohl(tvb, offset);\r\noffset += 4;\r\ntemp = offset + val * (16 + num_position_bytes);\r\nif ((temp > len) || (temp < offset))\r\nreturn FALSE;\r\noffset = temp;\r\n}\r\nDISSECTOR_ASSERT(offset <= len);\r\n*res = offset;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nget_chunks_len(tvbuff_t *tvb, guint offset, guint len, guint *res)\r\n{\r\nif (!get_chunk_len(tvb, offset, len, 4, res))\r\nreturn FALSE;\r\nif (!get_chunk_len(tvb, *res, len, 0, res))\r\nreturn FALSE;\r\nreturn get_chunk_len(tvb, *res, len, 0, res);\r\n}\r\nstatic gboolean\r\npacket_is_rpcordma(tvbuff_t *tvb)\r\n{\r\nguint len = tvb_reported_length(tvb);\r\nguint32 xid_rpc;\r\nguint32 xid = tvb_get_ntohl(tvb, 0);\r\nguint32 msg_type = tvb_get_ntohl(tvb, 12);\r\nguint offset;\r\nswitch (msg_type) {\r\ncase RDMA_MSG:\r\nif (len < MIN_RPCRDMA_MSG_SZ)\r\nreturn FALSE;\r\nif (!get_chunks_len(tvb, MIN_RPCRDMA_HDR_SZ, len, &offset))\r\nreturn FALSE;\r\nif (offset + 4 > len)\r\nreturn FALSE;\r\nxid_rpc = tvb_get_ntohl(tvb, offset);\r\nif (xid != xid_rpc)\r\nreturn FALSE;\r\nbreak;\r\ncase RDMA_MSGP:\r\nif (len < MIN_RPCRDMA_MSGP_SZ)\r\nreturn FALSE;\r\nif (!get_chunks_len(tvb, MIN_RPCRDMA_HDR_SZ + 8, len, &offset))\r\nreturn FALSE;\r\nif (offset + 4 > len)\r\nreturn FALSE;\r\nxid_rpc = tvb_get_ntohl(tvb, offset);\r\nif (xid != xid_rpc)\r\nreturn FALSE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\ndissect_packet(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\ntvbuff_t *next_tvb;\r\nproto_item *ti;\r\nproto_tree *rpcordma_tree;\r\nguint offset = 0;\r\nguint32 xid;\r\nguint32 msg_type;\r\nguint32 val;\r\nif (tvb_reported_length(tvb) < MIN_RPCRDMA_HDR_SZ)\r\nreturn 0;\r\nif (tvb_get_ntohl(tvb, 4) != 1)\r\nreturn 0;\r\nmsg_type = tvb_get_ntohl(tvb, 12);\r\nif (msg_type > RDMA_ERROR)\r\nreturn 0;\r\nif (!packet_is_rpcordma(tvb))\r\nreturn call_dissector(rpc_handler, tvb, pinfo, tree);\r\nxid = tvb_get_ntohl(tvb, 0);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "RPCoRDMA");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s XID 0x%x",\r\nval_to_str(msg_type, rpcordma_message_type, "Unknown (%d)"), xid);\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_rpcordma, tvb, 0, MIN_RPCRDMA_HDR_SZ, ENC_NA);\r\nrpcordma_tree = proto_item_add_subtree(ti, ett_rpcordma);\r\nproto_tree_add_item(rpcordma_tree, hf_rpcordma_xid, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(rpcordma_tree, hf_rpcordma_vers, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(rpcordma_tree, hf_rpcordma_flow_control, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(rpcordma_tree, hf_rpcordma_message_type, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nswitch (msg_type) {\r\ncase RDMA_MSG:\r\noffset = parse_rdma_header(tvb, offset, rpcordma_tree);\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nreturn call_dissector(rpc_handler, next_tvb, pinfo, tree);\r\ncase RDMA_NOMSG:\r\noffset = parse_rdma_header(tvb, offset, rpcordma_tree);\r\nbreak;\r\ncase RDMA_MSGP:\r\nproto_tree_add_item(rpcordma_tree, hf_rpcordma_rdma_align, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(rpcordma_tree, hf_rpcordma_rdma_thresh, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\noffset = parse_rdma_header(tvb, offset, rpcordma_tree);\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nreturn call_dissector(rpc_handler, next_tvb, pinfo, tree);\r\ncase RDMA_DONE:\r\nbreak;\r\ncase RDMA_ERROR:\r\nval = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(rpcordma_tree, hf_rpcordma_errcode, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nswitch (val) {\r\ncase ERR_VERS:\r\nproto_tree_add_item(rpcordma_tree, hf_rpcordma_vers_low, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(rpcordma_tree, hf_rpcordma_vers_high, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase ERR_CHUNK:\r\nbreak;\r\ndefault:\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nreturn call_data_dissector(next_tvb, pinfo, tree);\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_rpcordma(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nvoid *data _U_)\r\n{\r\nreturn dissect_packet(tvb, pinfo, tree);\r\n}\r\nstatic gboolean\r\ndissect_rpcordma_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nvoid *data _U_)\r\n{\r\nconversation_t *conv;\r\nconversation_infiniband_data *convo_data = NULL;\r\nif (gPREF_MAN_EN) {\r\nif ( (addresses_equal(&pinfo->src, &manual_addr[0]) &&\r\naddresses_equal(&pinfo->dst, &manual_addr[1]) &&\r\n(pinfo->srcport == 0xffffffff || pinfo->srcport == gPREF_QP[0]) &&\r\n(pinfo->destport == 0xffffffff || pinfo->destport == gPREF_QP[1])) ||\r\n(addresses_equal(&pinfo->src, &manual_addr[1]) &&\r\naddresses_equal(&pinfo->dst, &manual_addr[0]) &&\r\n(pinfo->srcport == 0xffffffff || pinfo->srcport == gPREF_QP[1]) &&\r\n(pinfo->destport == 0xffffffff || pinfo->destport == gPREF_QP[0])) )\r\nreturn (dissect_packet(tvb, pinfo, tree) != 0);\r\n}\r\nconv = find_conversation(pinfo->num, &pinfo->src, &pinfo->dst,\r\nPT_IBQP, pinfo->srcport, pinfo->destport, 0);\r\nif (!conv) {\r\nconv = find_conversation(pinfo->num, &pinfo->dst, &pinfo->dst,\r\nPT_IBQP, pinfo->destport, pinfo->destport, NO_ADDR_B|NO_PORT_B);\r\nif (!conv)\r\nreturn FALSE;\r\n}\r\nconvo_data = (conversation_infiniband_data *)conversation_get_proto_data(conv, proto_ib);\r\nif (!convo_data)\r\nreturn FALSE;\r\nif ((convo_data->service_id & SID_MASK) != SID_ULP_TCP)\r\nreturn FALSE;\r\nif (!(value_is_in_range(gPORT_RANGE, (guint32)(convo_data->service_id & SID_PORT_MASK))))\r\nreturn FALSE;\r\nconv = find_or_create_conversation(pinfo);\r\nconversation_set_dissector(conv, rpcordma_handler);\r\nreturn (dissect_packet(tvb, pinfo, tree) != 0);\r\n}\r\nvoid\r\nproto_register_rpcordma(void)\r\n{\r\nmodule_t *rpcordma_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_rpcordma_xid,\r\n{ "XID", "rpcordma.xid",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL}\r\n},\r\n{ &hf_rpcordma_vers,\r\n{ "Version", "rpcordma.version",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL}\r\n},\r\n{ &hf_rpcordma_flow_control,\r\n{ "Flow Control", "rpcordma.flow_control",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL}\r\n},\r\n{ &hf_rpcordma_message_type,\r\n{ "Message Type", "rpcordma.msg_type",\r\nFT_UINT32, BASE_HEX,\r\nVALS(rpcordma_message_type), 0x0, NULL, HFILL}\r\n},\r\n{ &hf_rpcordma_reads_count,\r\n{ "Read list", "rpcordma.reads_count",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_rpcordma_writes_count,\r\n{ "Write list", "rpcordma.writes_count",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_rpcordma_reply_count,\r\n{ "Reply list", "rpcordma.reply_count",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_rpcordma_rdma_handle,\r\n{ "RDMA handle", "rpcordma.rdma_handle",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_rpcordma_rdma_length,\r\n{ "RDMA length", "rpcordma.rdma_length",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_rpcordma_rdma_offset,\r\n{ "RDMA offset", "rpcordma.rdma_offset",\r\nFT_UINT64, BASE_HEX,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_rpcordma_position,\r\n{ "Postion in XDR", "rpcordma.position",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_rpcordma_rdma_align,\r\n{ "RDMA align", "rpcordma.rdma_align",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_rpcordma_rdma_thresh,\r\n{ "RDMA threshold", "rpcordma.rdma_thresh",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_rpcordma_errcode,\r\n{ "Error code", "rpcordma.errcode",\r\nFT_UINT32, BASE_HEX,\r\nVALS(rpcordma_err), 0, NULL, HFILL }\r\n},\r\n{ &hf_rpcordma_vers_low,\r\n{ "Version low", "rpcordma.vers_low",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_rpcordma_vers_high,\r\n{ "Version high", "rpcordma.vers_high",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_rpcordma,\r\n&ett_rpcordma_chunk,\r\n};\r\nproto_rpcordma = proto_register_protocol (\r\n"RPC over RDMA",\r\n"RPCoRDMA",\r\n"rpcordma"\r\n);\r\nproto_register_field_array(proto_rpcordma, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nrpcordma_module = prefs_register_protocol(proto_rpcordma, proto_reg_handoff_rpcordma);\r\nprefs_register_bool_preference(rpcordma_module, "manual_en", "Enable manual settings",\r\n"Check to treat all traffic between the configured source/destination as RPCoRDMA",\r\n&gPREF_MAN_EN);\r\nprefs_register_static_text_preference(rpcordma_module, "addr_a", "Address A",\r\n"Side A of the manually-configured connection");\r\nprefs_register_enum_preference(rpcordma_module, "addr_a_type", "Address Type",\r\n"Type of address specified", &gPREF_TYPE[0], pref_address_types, FALSE);\r\nprefs_register_string_preference(rpcordma_module, "addr_a_id", "ID",\r\n"LID/GID of address A", &gPREF_ID[0]);\r\nprefs_register_uint_preference(rpcordma_module, "addr_a_qp", "QP Number",\r\n"QP Number for address A", 10, &gPREF_QP[0]);\r\nprefs_register_static_text_preference(rpcordma_module, "addr_b", "Address B",\r\n"Side B of the manually-configured connection");\r\nprefs_register_enum_preference(rpcordma_module, "addr_b_type", "Address Type",\r\n"Type of address specified", &gPREF_TYPE[1], pref_address_types, FALSE);\r\nprefs_register_string_preference(rpcordma_module, "addr_b_id", "ID",\r\n"LID/GID of address B", &gPREF_ID[1]);\r\nprefs_register_uint_preference(rpcordma_module, "addr_b_qp", "QP Number",\r\n"QP Number for address B", 10, &gPREF_QP[1]);\r\nrange_convert_str(&gPORT_RANGE, TCP_PORT_RPCRDMA_RANGE, MAX_TCP_PORT);\r\nprefs_register_range_preference(rpcordma_module,\r\n"target_ports",\r\n"Target Ports Range",\r\n"Range of RPCoRDMA server ports"\r\n"(default " TCP_PORT_RPCRDMA_RANGE ")",\r\n&gPORT_RANGE, MAX_TCP_PORT);\r\n}\r\nvoid\r\nproto_reg_handoff_rpcordma(void)\r\n{\r\nstatic gboolean initialized = FALSE;\r\nif (!initialized) {\r\nrpcordma_handler = create_dissector_handle(dissect_rpcordma, proto_rpcordma);\r\nheur_dissector_add("infiniband.payload", dissect_rpcordma_heur, "Infiniband RPC over RDMA", "rpcordma_infiniband", proto_rpcordma, HEURISTIC_ENABLE);\r\nheur_dissector_add("infiniband.mad.cm.private", dissect_rpcordma_heur, "RPC over RDMA in PrivateData of CM packets", "rpcordma_ib_private", proto_rpcordma, HEURISTIC_ENABLE);\r\nmanual_addr_data[0] = wmem_alloc(wmem_epan_scope(), GID_SIZE);\r\nmanual_addr_data[1] = wmem_alloc(wmem_epan_scope(), GID_SIZE);\r\nrpc_handler = find_dissector_add_dependency("rpc", proto_rpcordma);\r\nib_handler = find_dissector_add_dependency("infiniband", proto_rpcordma);\r\nproto_ib = dissector_handle_get_protocol_index(ib_handler);\r\ninitialized = TRUE;\r\n}\r\nif (gPREF_MAN_EN) {\r\ngboolean error_occured = FALSE;\r\nchar *not_parsed;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nif (gPREF_TYPE[i] == 0) {\r\nerrno = 0;\r\n*((guint16*)manual_addr_data[i]) = (guint16)strtoul(gPREF_ID[i], &not_parsed, 0);\r\nif (errno || *not_parsed != '\0') {\r\nerror_occured = TRUE;\r\n} else {\r\nset_address(&manual_addr[i], AT_IB, sizeof(guint16), manual_addr_data[i]);\r\n}\r\n} else {\r\nif (!str_to_ip6(gPREF_ID[i], manual_addr_data[i]) ) {\r\nerror_occured = TRUE;\r\n} else {\r\nset_address(&manual_addr[i], AT_IB, GID_SIZE, manual_addr_data[i]);\r\n}\r\n}\r\nif (error_occured) {\r\ngPREF_MAN_EN = FALSE;\r\nbreak;\r\n}\r\n}\r\n}\r\n}
