static void\r\ndissect_mmc4_getconfiguration (tvbuff_t *tvb_a, packet_info *pinfo,\r\nproto_tree *tree, guint offset_a,\r\ngboolean isreq, gboolean iscdb,\r\nguint payload_len _U_,\r\nscsi_task_data_t *cdata)\r\n{\r\ngint32 len;\r\nguint old_offset;\r\nif (tree && isreq && iscdb) {\r\nproto_tree_add_item (tree, hf_scsi_mmc_getconf_rt, tvb_a, offset_a+0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_getconf_starting_feature, tvb_a, offset_a+1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_alloclen16, tvb_a, offset_a+6, 2, ENC_BIG_ENDIAN);\r\nif(cdata){\r\ncdata->itlq->alloc_len=tvb_get_ntohs(tvb_a, offset_a+6);\r\n}\r\nproto_tree_add_bitmask(tree, tvb_a, offset_a+8, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\nif(!isreq) {\r\nif(!cdata){\r\nreturn;\r\n}\r\nTRY_SCSI_CDB_ALLOC_LEN(cdata->itlq->alloc_len);\r\nlen=tvb_get_ntohl(try_tvb, try_offset+0);\r\nproto_tree_add_item (tree, hf_scsi_mmc_data_length, try_tvb, try_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_getconf_current_profile, try_tvb, try_offset+6, 2, ENC_BIG_ENDIAN);\r\ntry_offset+=8;\r\nlen-=4;\r\nwhile(len>0){\r\nguint16 feature;\r\nguint8 additional_length;\r\nguint8 num_linksize;\r\nfeature=tvb_get_ntohs(try_tvb, try_offset);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature, try_tvb, try_offset, 2, ENC_BIG_ENDIAN);\r\ntry_offset+=2;\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_version, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_persistent, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_current, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\ntry_offset+=1;\r\nadditional_length=tvb_get_guint8(try_tvb, try_offset);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_additional_length, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\ntry_offset+=1;\r\nold_offset=try_offset;\r\nswitch(feature){\r\ncase 0x0000:\r\nwhile(try_offset<(old_offset+additional_length)){\r\nproto_item *it;\r\nproto_tree *tr;\r\nguint16 profile;\r\nguint8 cur_profile;\r\ntr=proto_tree_add_subtree(tree, try_tvb, try_offset, 4, ett_scsi_mmc_profile, &it, "Profile:");\r\nprofile=tvb_get_ntohs(try_tvb, try_offset);\r\nproto_tree_add_item (tr, hf_scsi_mmc_feature_profile, try_tvb, try_offset, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(it, "%s", val_to_str_ext(profile, &scsi_getconf_current_profile_val_ext, "Unknown 0x%04x"));\r\ncur_profile=tvb_get_guint8(try_tvb, try_offset+2);\r\nproto_tree_add_item (tr, hf_scsi_mmc_feature_profile_current, try_tvb, try_offset+2, 1, ENC_BIG_ENDIAN);\r\nif(cur_profile&0x01){\r\nproto_item_append_text(it, " [CURRENT PROFILE]");\r\n}\r\ntry_offset+=4;\r\n}\r\nbreak;\r\ncase 0x001d:\r\ncase 0x001f:\r\nbreak;\r\ncase 0x001e:\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_cdread_dap, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_cdread_c2flag, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_cdread_cdtext, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x0021:\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_dts, try_tvb, try_offset, 2, ENC_BIG_ENDIAN);\r\ntry_offset+=2;\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_isw_buf, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\ntry_offset+=1;\r\nnum_linksize=tvb_get_guint8(try_tvb, try_offset);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_isw_num_linksize, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\ntry_offset+=1;\r\nwhile(num_linksize--){\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_isw_linksize, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\ntry_offset+=1;\r\n}\r\nbreak;\r\ncase 0x002a:\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_dvdrw_write, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_dvdrw_quickstart, try_tvb, try_offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_dvdrw_closeonly, try_tvb, try_offset, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x002b:\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_dvdr_write, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x002d:\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_tao_buf, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_tao_rwraw, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_tao_rwpack, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_tao_testwrite, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_tao_cdrw, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_tao_rwsubcode, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_dts, try_tvb, try_offset+2, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x002e:\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_sao_buf, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_sao_sao, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_sao_rawms, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_sao_raw, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_sao_testwrite, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_sao_cdrw, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_sao_rw, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_sao_mcsl, try_tvb, try_offset+1, 3, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x002f:\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_dvdr_buf, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_dvdr_testwrite, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_dvdr_dvdrw, try_tvb, try_offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x0108:\r\nproto_tree_add_item (tree, hf_scsi_mmc_feature_lun_sn, try_tvb, try_offset, additional_length, ENC_ASCII|ENC_NA);\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert(tree, pinfo, &ei_scsi_mmc_unknown_feature_data, try_tvb, try_offset, additional_length);\r\nbreak;\r\n}\r\ntry_offset=old_offset+additional_length;\r\nlen-=4+additional_length;\r\n}\r\nEND_TRY_SCSI_CDB_ALLOC_LEN;\r\n}\r\n}\r\nstatic void\r\ndissect_mmc4_readtocpmaatip (tvbuff_t *tvb_a, packet_info *pinfo, proto_tree *tree,\r\nguint offset_a, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata)\r\n{\r\nguint8 format;\r\ngint16 len;\r\nif (isreq && iscdb) {\r\nformat=tvb_get_guint8(tvb_a, offset_a+1)&0x0f;\r\ncdata->itlq->flags=format;\r\nswitch(format){\r\ncase 0x00:\r\ncase 0x01:\r\nproto_tree_add_item (tree, hf_scsi_mmc_readtoc_time, tvb_a, offset_a, 1, ENC_BIG_ENDIAN);\r\nif(tvb_get_guint8(tvb_a, offset_a)&0x02){\r\ncdata->itlq->flags|=0x0100;\r\n}\r\nbreak;\r\n}\r\nproto_tree_add_item (tree, hf_scsi_mmc_readtoc_format, tvb_a, offset_a+1, 1, ENC_BIG_ENDIAN);\r\nswitch(format){\r\ncase 0x00:\r\nproto_tree_add_item (tree, hf_scsi_mmc_track, tvb_a, offset_a+5, 1, ENC_BIG_ENDIAN);\r\ncdata->itlq->flags|=0x0200;\r\nbreak;\r\ncase 0x02:\r\nproto_tree_add_item (tree, hf_scsi_mmc_session, tvb_a, offset_a+5, 1, ENC_BIG_ENDIAN);\r\ncdata->itlq->flags|=0x0400;\r\nbreak;\r\n}\r\nproto_tree_add_item (tree, hf_scsi_alloclen16, tvb_a, offset_a + 6, 2, ENC_BIG_ENDIAN);\r\ncdata->itlq->alloc_len = tvb_get_ntohs(tvb_a, offset_a + 6);\r\nproto_tree_add_bitmask(tree, tvb_a, offset_a+8, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\nif(!isreq) {\r\nTRY_SCSI_CDB_ALLOC_LEN(cdata->itlq->alloc_len);\r\nlen=tvb_get_ntohs(try_tvb, try_offset);\r\nproto_tree_add_item (tree, hf_scsi_mmc_data_length, try_tvb, try_offset, 2, ENC_BIG_ENDIAN);\r\nif(cdata->itlq->flags&0x0200){\r\nproto_tree_add_item (tree, hf_scsi_mmc_first_track, try_tvb, try_offset+2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_readtoc_last_track, try_tvb, try_offset+3, 1, ENC_BIG_ENDIAN);\r\n}\r\nif(cdata->itlq->flags&0x0400){\r\nproto_tree_add_item (tree, hf_scsi_mmc_readtoc_first_session, try_tvb, try_offset+2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_readtoc_last_session, try_tvb, try_offset+3, 1, ENC_BIG_ENDIAN);\r\n}\r\ntry_offset+=4;\r\nlen-=2;\r\nswitch(cdata->itlq->flags&0x000f){\r\ncase 0x0:\r\nwhile(len>0){\r\nproto_tree_add_item (tree, hf_scsi_mmc_q_subchannel_adr, try_tvb, try_offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_q_subchannel_control, try_tvb, try_offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_track, try_tvb, try_offset+2, 1, ENC_BIG_ENDIAN);\r\nif(cdata->itlq->flags&0x0100){\r\nproto_tree_add_item (tree, hf_scsi_mmc_track_start_time, try_tvb, try_offset+4, 4, ENC_BIG_ENDIAN);\r\n} else {\r\nproto_tree_add_item (tree, hf_scsi_mmc_track_start_address, try_tvb, try_offset+4, 4, ENC_BIG_ENDIAN);\r\n}\r\ntry_offset+=8;\r\nlen-=8;\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert_format(tree, pinfo, &ei_scsi_mmc_unknown_read_toc_format, try_tvb, try_offset, len, "SCSI/MMC Unknown READ TOC Format:0x%04x", cdata->itlq->flags&0x000f);\r\nbreak;\r\n}\r\nEND_TRY_SCSI_CDB_ALLOC_LEN;\r\n}\r\n}\r\nstatic void\r\ndissect_mmc4_readdiscinformation (tvbuff_t *tvb_a, packet_info *pinfo, proto_tree *tree,\r\nguint offset_a, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata)\r\n{\r\nif (iscdb) {\r\nproto_tree_add_item (tree, hf_scsi_alloclen16, tvb_a, offset_a + 6, 2, ENC_BIG_ENDIAN);\r\nif (cdata && cdata->itlq) {\r\ncdata->itlq->alloc_len = tvb_get_ntohs(tvb_a, offset_a + 6);\r\n}\r\nproto_tree_add_bitmask(tree, tvb_a, offset_a+8, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\nif (!isreq) {\r\nstatic const int *disk_fields[] = {\r\n&hf_scsi_mmc_disc_info_erasable,\r\n&hf_scsi_mmc_disc_info_state_of_last_session,\r\n&hf_scsi_mmc_disc_info_disk_status,\r\nNULL\r\n};\r\nstatic const int *format_fields[] = {\r\n&hf_scsi_mmc_disc_info_did_v,\r\n&hf_scsi_mmc_disc_info_dbc_v,\r\n&hf_scsi_mmc_disc_info_uru,\r\n&hf_scsi_mmc_disc_info_dac_v,\r\n&hf_scsi_mmc_disc_info_dbit,\r\n&hf_scsi_mmc_disc_info_bgfs,\r\nNULL\r\n};\r\nTRY_SCSI_CDB_ALLOC_LEN( (cdata && cdata->itlq) ? cdata->itlq->alloc_len : 0);\r\nproto_tree_add_item (tree, hf_scsi_mmc_data_length, try_tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, try_tvb, try_offset + 2, hf_scsi_mmc_disk_flags,\r\nett_scsi_disk_flags, disk_fields, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_first_track, try_tvb, try_offset+3, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint (tree, hf_scsi_mmc_disc_info_number_of_sessions, try_tvb, 4, 1, (tvb_get_guint8(try_tvb, try_offset+9)<<8)|tvb_get_guint8(try_tvb, try_offset+4));\r\nproto_tree_add_uint (tree, hf_scsi_mmc_disc_info_first_track_in_last_session, try_tvb, 5, 1, (tvb_get_guint8(try_tvb, try_offset+10)<<8)|tvb_get_guint8(try_tvb, try_offset+5));\r\nproto_tree_add_uint (tree, hf_scsi_mmc_disc_info_last_track_in_last_session, try_tvb, 6, 1, (tvb_get_guint8(try_tvb, try_offset+11)<<8)|tvb_get_guint8(try_tvb, try_offset+6));\r\nproto_tree_add_bitmask(tree, try_tvb, try_offset + 7, hf_scsi_mmc_format_flags,\r\nett_scsi_format_flags, format_fields, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_info_disc_type, try_tvb, try_offset+8, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_info_disc_identification, try_tvb, try_offset+12, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_info_last_session_lead_in_start_address, try_tvb, try_offset+16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_info_last_possible_lead_out_start_address, try_tvb, try_offset+20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_info_disc_bar_code, try_tvb, try_offset+24, 8, ENC_BIG_ENDIAN);\r\nEND_TRY_SCSI_CDB_ALLOC_LEN;\r\n}\r\n}\r\nstatic void\r\ndissect_mmc4_readdiscstructure (tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata)\r\n{ if (tree && isreq && iscdb) {\r\nproto_tree_add_item(tree, hf_scsi_mmc_read_dvd_address, tvb, offset+1, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_scsi_mmc_read_dvd_layer_number, tvb, offset+5, 1, ENC_BIG_ENDIAN);\r\ncdata->itlq->flags=tvb_get_guint8 (tvb, offset+6);\r\nproto_tree_add_uint (tree, hf_scsi_mmc_read_dvd_format, tvb, offset+6, 1, cdata->itlq->flags);\r\nproto_tree_add_item (tree, hf_scsi_alloclen16, tvb, offset+7, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_scsi_mmc_read_dvd_agid, tvb, offset+9, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+10, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\nif(tree && (!isreq)) {\r\nproto_item *ti;\r\nti = proto_tree_add_uint (tree, hf_scsi_mmc_read_dvd_format, tvb, 0, 0, cdata->itlq->flags);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nproto_tree_add_item (tree, hf_scsi_mmc_data_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nswitch(cdata->itlq->flags) {\r\ncase 0x00:\r\ncase 0x11:\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_book_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_book_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_size_size, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_size_rate, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_num_layers, tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_track_path, tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_structure_layer, tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_density_length, tvb, offset+3, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_density_pitch, tvb, offset+3, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_first_physical, tvb, offset+5, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_last_physical, tvb, offset+9, 3, ENC_BIG_ENDIAN);\r\nif (cdata->itlq->flags == 0x00) {\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_last_physical_layer0, tvb, offset+13, 3, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_extended_format_info, tvb, offset+16, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_disc_application_code, tvb, offset+17, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_adip_eib5, tvb, offset+18, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_adip_eib4, tvb, offset+18, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_adip_eib3, tvb, offset+18, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_adip_eib2, tvb, offset+18, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_adip_eib1, tvb, offset+18, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_adip_eib0, tvb, offset+18, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_adip_device_manuf_id, tvb, offset+19, 8, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item (tree, hf_scsi_mmc_adip_media_type_id, tvb, offset+27, 3, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item (tree, hf_scsi_mmc_adip_product_revision_number, tvb, offset+30, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_adip_number_of_physical_info, tvb, offset+31, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert_format(tree, pinfo, &ei_scsi_mmc_unknown_read_dvd_format, tvb, 0, 0, "SCSI/MMC Unknown Read DVD Format:0x%02x", cdata->itlq->flags);\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_mmc4_getperformance (tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata _U_)\r\n{\r\nif (tree && isreq && iscdb) {\r\nproto_tree_add_item(tree, hf_scsi_mmc_getperformance_data_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_scsi_mmc_getperformance_starting_lba, tvb, offset+1, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_scsi_mmc_getperformance_max_num_descriptors, tvb, offset+7, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_scsi_mmc_getperformance_type, tvb, offset+9, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+10, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_mmc4_synchronizecache (tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata _U_)\r\n{\r\nif (tree && isreq && iscdb) {\r\nproto_tree_add_item (tree, hf_scsi_mmc_synccache_immed, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_synccache_reladr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_lba, tvb, offset+1, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_num_blocks, tvb, offset+6, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+8, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_mmc4_reportkey (tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata)\r\n{\r\nguint8 agid, key_format, key_class;\r\nif (tree && isreq && iscdb) {\r\nproto_tree_add_item (tree, hf_scsi_mmc_lba, tvb, offset+1,\r\n4, ENC_BIG_ENDIAN);\r\nkey_class=tvb_get_guint8(tvb, offset+6);\r\nproto_tree_add_item (tree, hf_scsi_mmc_key_class, tvb, offset+6,\r\n1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_alloclen16, tvb, offset+7, 2, ENC_BIG_ENDIAN);\r\nagid=tvb_get_guint8(tvb, offset+9)&0xc0;\r\nkey_format=tvb_get_guint8(tvb, offset+9)&0x3f;\r\nswitch(key_format){\r\ncase 0x01:\r\ncase 0x02:\r\ncase 0x04:\r\ncase 0x3f:\r\nproto_tree_add_uint (tree, hf_scsi_mmc_agid, tvb, offset+9, 1, agid);\r\nbreak;\r\n}\r\nproto_tree_add_uint (tree, hf_scsi_mmc_key_format, tvb, offset+9, 1, key_format);\r\ncdata->itlq->flags=(key_format<<8)|key_class;\r\nproto_tree_add_bitmask(tree, tvb, offset+14, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\nif(tree && (!isreq)) {\r\nswitch(cdata->itlq->flags){\r\ncase 0x0800:\r\nproto_tree_add_item (tree, hf_scsi_mmc_data_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_report_key_type_code, tvb, offset+4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_report_key_vendor_resets, tvb, offset+4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_report_key_user_changes, tvb, offset+4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_report_key_region_mask, tvb, offset+5, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_report_key_rpc_scheme, tvb, offset+6, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert_format(tree, pinfo, &ei_scsi_mmc_unknown_format_class, tvb, 0, 0,\r\n"SCSI/MMC Unknown Format:0x%02x/Class:0x%02x combination",\r\ncdata->itlq->flags>>8,cdata->itlq->flags&0xff);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_mmc4_readtrackinformation (tvbuff_t *tvb_a, packet_info *pinfo, proto_tree *tree,\r\nguint offset_a, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata)\r\n{\r\nguint8 addresstype;\r\nif (isreq && iscdb) {\r\naddresstype=tvb_get_guint8(tvb_a, offset_a)&0x03;\r\nproto_tree_add_item (tree, hf_scsi_mmc_rti_address_type, tvb_a, offset_a+0, 1, ENC_BIG_ENDIAN);\r\nswitch(addresstype){\r\ncase 0x00:\r\nproto_tree_add_item (tree, hf_scsi_mmc_lba, tvb_a, offset_a+1,\r\n4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x01:\r\nproto_tree_add_item (tree, hf_scsi_mmc_track, tvb_a, offset_a+1,\r\n4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x02:\r\nproto_tree_add_item (tree, hf_scsi_mmc_session, tvb_a, offset_a+1,\r\n4, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\nproto_tree_add_item (tree, hf_scsi_alloclen16, tvb_a, offset_a + 6, 2, ENC_BIG_ENDIAN);\r\nif (cdata) {\r\ncdata->itlq->alloc_len = tvb_get_ntohs(tvb_a, offset_a + 6);\r\n}\r\nproto_tree_add_bitmask(tree, tvb_a, offset_a+8, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\nif (!isreq) {\r\nstatic const int *track_fields[] = {\r\n&hf_scsi_mmc_rti_damage,\r\n&hf_scsi_mmc_rti_copy,\r\n&hf_scsi_mmc_rti_track_mode,\r\nNULL\r\n};\r\nstatic const int *data_fields[] = {\r\n&hf_scsi_mmc_rti_rt,\r\n&hf_scsi_mmc_rti_blank,\r\n&hf_scsi_mmc_rti_packet,\r\n&hf_scsi_mmc_rti_fp,\r\n&hf_scsi_mmc_rti_data_mode,\r\nNULL\r\n};\r\nTRY_SCSI_CDB_ALLOC_LEN(cdata->itlq->alloc_len);\r\nproto_tree_add_item (tree, hf_scsi_mmc_data_length, try_tvb, 0, 2, ENC_BIG_ENDIAN);\r\nif (tvb_reported_length(try_tvb) < 33) {\r\nproto_tree_add_uint (tree, hf_scsi_mmc_track, try_tvb, 2, 1, tvb_get_guint8(try_tvb, try_offset + 2));\r\n} else {\r\nproto_tree_add_uint (tree, hf_scsi_mmc_track, try_tvb, 2, 1, (tvb_get_guint8(try_tvb, try_offset + 32) << 8) | tvb_get_guint8(try_tvb, try_offset + 2));\r\n}\r\nif (tvb_reported_length(try_tvb) < 34) {\r\nproto_tree_add_uint (tree, hf_scsi_mmc_session, try_tvb, 3, 1, tvb_get_guint8(try_tvb, try_offset + 3));\r\n} else {\r\nproto_tree_add_uint (tree, hf_scsi_mmc_session, try_tvb, 3, 1, (tvb_get_guint8(try_tvb, try_offset + 33) << 8) | tvb_get_guint8(try_tvb, try_offset + 3));\r\n}\r\nproto_tree_add_bitmask(tree, try_tvb, try_offset + 5, hf_scsi_mmc_track_flags,\r\nett_scsi_track_flags, track_fields, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, try_tvb, try_offset + 6, hf_scsi_mmc_data_flags,\r\nett_scsi_data_flags, data_fields, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_rti_lra_v, try_tvb, 7, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_rti_nwa_v, try_tvb, 7, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_track_start_address, try_tvb, try_offset+8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_next_writable_address, try_tvb, try_offset+12, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_free_blocks, try_tvb, try_offset+16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_fixed_packet_size, try_tvb, try_offset+20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_track_size, try_tvb, try_offset+24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_last_recorded_address, try_tvb, try_offset+28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_read_compatibility_lba, try_tvb, try_offset+36, 4, ENC_BIG_ENDIAN);\r\nEND_TRY_SCSI_CDB_ALLOC_LEN;\r\n}\r\n}\r\nstatic void\r\ndissect_mmc4_geteventstatusnotification (tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata _U_)\r\n{\r\nif (tree && isreq && iscdb) {\r\nstatic const int *notification_fields[] = {\r\n&hf_scsi_mmc_gesn_device_busy,\r\n&hf_scsi_mmc_gesn_multi_initiator,\r\n&hf_scsi_mmc_gesn_media,\r\n&hf_scsi_mmc_gesn_external_request,\r\n&hf_scsi_mmc_gesn_power_mgmt,\r\n&hf_scsi_mmc_gesn_operational_change,\r\nNULL\r\n};\r\nproto_tree_add_item (tree, hf_scsi_mmc_gesn_polled, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset + 3, hf_scsi_mmc_notification_flags,\r\nett_scsi_notifications, notification_fields, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_alloclen16, tvb, offset+6, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+8, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_mmc4_reservetrack (tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata _U_)\r\n{\r\nif (tree && isreq && iscdb) {\r\nproto_tree_add_item (tree, hf_scsi_mmc_reservation_size, tvb, offset+4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+8, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_mmc4_close_track (tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata _U_)\r\n{\r\nif (tree && isreq && iscdb) {\r\nproto_tree_add_item (tree, hf_scsi_mmc_closetrack_immed, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item (tree, hf_scsi_mmc_closetrack_func, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\noffset++;\r\nproto_tree_add_item (tree, hf_scsi_mmc_track, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\noffset+=3;\r\nproto_tree_add_bitmask(tree, tvb, offset, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_mmc4_readbuffercapacity (tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata)\r\n{\r\nif (tree && isreq && iscdb) {\r\ncdata->itlq->flags=0;\r\nproto_tree_add_item (tree, hf_scsi_mmc_rbc_block, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif(tvb_get_guint8(tvb, offset)&0x01){\r\ncdata->itlq->flags=1;\r\n}\r\nproto_tree_add_item (tree, hf_scsi_alloclen16, tvb, offset+6, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+8, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\nif(tree && (!isreq)) {\r\nproto_tree_add_item (tree, hf_scsi_mmc_data_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nif(cdata->itlq->flags){\r\nproto_tree_add_item (tree, hf_scsi_mmc_rbc_lob_blocks, tvb, offset+4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_rbc_alob_blocks, tvb, offset+8, 4, ENC_BIG_ENDIAN);\r\n} else {\r\nproto_tree_add_item (tree, hf_scsi_mmc_rbc_lob_bytes, tvb, offset+4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_rbc_alob_bytes, tvb, offset+8, 4, ENC_BIG_ENDIAN);\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_mmc4_setcdspeed (tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata _U_)\r\n{\r\nif (tree && isreq && iscdb) {\r\nproto_tree_add_item (tree, hf_scsi_mmc_setcdspeed_rc, tvb, offset+0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_scsi_mmc_setcdspeed_logical_unit_read_speed, tvb, offset+1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_scsi_mmc_setcdspeed_logical_unit_write_speed, tvb, offset+3, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+10, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_mmc4_setstreaming (tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata)\r\n{\r\nguint8 type;\r\nif (tree && isreq && iscdb) {\r\ntype=tvb_get_guint8(tvb, offset+7);\r\ncdata->itlq->flags=type;\r\nproto_tree_add_item (tree, hf_scsi_mmc_setstreaming_type, tvb, offset+7, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_setstreaming_param_len, tvb, offset+8, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offset+10, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\nif(tree && isreq && (!iscdb)) {\r\nswitch(cdata->itlq->flags){\r\ncase 0x00:\r\nproto_tree_add_item (tree, hf_scsi_mmc_setstreaming_wrc, tvb, offset+0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_setstreaming_rdd, tvb, offset+0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_setstreaming_exact, tvb, offset+0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_setstreaming_ra, tvb, offset+0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_setstreaming_start_lba, tvb, offset+4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_setstreaming_end_lba, tvb, offset+8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_setstreaming_read_size, tvb, offset+12, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_setstreaming_read_time, tvb, offset+16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_setstreaming_write_size, tvb, offset+20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_scsi_mmc_setstreaming_write_time, tvb, offset+24, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert_format(tree, pinfo, &ei_scsi_mmc_unknown_setstreaming_type, tvb, 0, 0,\r\n"SCSI/MMC Unknown SetStreaming Type:0x%02x",cdata->itlq->flags);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_mmc_preventallowmediaremoval(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nguint offset, gboolean isreq, gboolean iscdb,\r\nguint payload_len _U_, scsi_task_data_t *cdata _U_)\r\n{\r\nif (isreq && iscdb) {\r\nguint8 flags;\r\nstatic const int *prevent_allow_fields[] = {\r\n&hf_scsi_mmc_prevent_allow_persistent,\r\n&hf_scsi_mmc_prevent_allow_prevent,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(tree, tvb, offset + 3, hf_scsi_mmc_prevent_allow_flags,\r\nett_scsi_prevent_allow, prevent_allow_fields, ENC_BIG_ENDIAN);\r\nflags = tvb_get_guint8(tvb, offset + 3);\r\nif (flags & 0x01) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, " PREVENT");\r\n} else {\r\ncol_append_str(pinfo->cinfo, COL_INFO, " ALLOW");\r\n}\r\nif (flags & 0x02) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, " (PERSISTENT)");\r\n}\r\nproto_tree_add_bitmask(tree, tvb, offset+4, hf_scsi_control,\r\nett_scsi_control, cdb_control_fields, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nvoid\r\nproto_register_scsi_mmc(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_scsi_mmc_opcode,\r\n{"MMC Opcode", "scsi_mmc.opcode", FT_UINT8, BASE_HEX | BASE_EXT_STRING,\r\n&scsi_mmc_vals_ext, 0x0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_setstreaming_type,\r\n{"Type", "scsi_mmc.setstreaming.type", FT_UINT8, BASE_DEC,\r\nVALS(scsi_setstreaming_type_val), 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_setstreaming_param_len,\r\n{"Parameter Length", "scsi_mmc.setstreaming.param_len", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_setstreaming_wrc,\r\n{"WRC", "scsi_mmc.setstreaming.wrc", FT_UINT8, BASE_HEX,\r\nNULL, 0x18, NULL, HFILL}},\r\n{ &hf_scsi_mmc_setstreaming_rdd,\r\n{"RDD", "scsi_mmc.setstreaming.rdd", FT_BOOLEAN, 8,\r\nNULL, 0x04, NULL, HFILL}},\r\n{ &hf_scsi_mmc_setstreaming_exact,\r\n{"Exact", "scsi_mmc.setstreaming.exact", FT_BOOLEAN, 8,\r\nNULL, 0x02, NULL, HFILL}},\r\n{ &hf_scsi_mmc_setstreaming_ra,\r\n{"RA", "scsi_mmc.setstreaming.ra", FT_BOOLEAN, 8,\r\nNULL, 0x01, NULL, HFILL}},\r\n{ &hf_scsi_mmc_setstreaming_start_lba,\r\n{"Start LBA", "scsi_mmc.setstreaming.start_lbs", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_setstreaming_end_lba,\r\n{"End LBA", "scsi_mmc.setstreaming.end_lba", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_setstreaming_read_size,\r\n{"Read Size", "scsi_mmc.setstreaming.read_size", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_setstreaming_read_time,\r\n{"Read Time", "scsi_mmc.setstreaming.read_time", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_setstreaming_write_size,\r\n{"Write Size", "scsi_mmc.setstreaming.write_size", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_setstreaming_write_time,\r\n{"Write Time", "scsi_mmc.setstreaming.write_time", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_setcdspeed_rc,\r\n{"Rotational Control", "scsi_mmc.setcdspeed.rc", FT_UINT8, BASE_HEX,\r\nVALS(scsi_setcdspeed_rc_val), 0x03, NULL, HFILL}},\r\n{ &hf_scsi_mmc_rbc_block,\r\n{"BLOCK", "scsi_mmc.rbc.block", FT_BOOLEAN, 8,\r\nNULL, 0x01, NULL, HFILL}},\r\n{ &hf_scsi_mmc_rbc_lob_blocks,\r\n{"Buffer Len (blocks)", "scsi_mmc.rbc.lob_blocks", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_rbc_alob_blocks,\r\n{"Available Buffer Len (blocks)", "scsi_mmc.rbc.alob_blocks", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_rbc_lob_bytes,\r\n{"Buffer Len (bytes)", "scsi_mmc.rbc.lob_bytes", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_rbc_alob_bytes,\r\n{"Available Buffer Len (bytes)", "scsi_mmc.rbc.alob_bytes", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_rti_address_type,\r\n{"Address Type", "scsi_mmc.rti.address_type", FT_UINT8, BASE_HEX,\r\nVALS(scsi_rti_address_type_val), 0x03, NULL, HFILL}},\r\n{ &hf_scsi_mmc_rti_damage,\r\n{"Damage", "scsi_mmc.rti.damage", FT_BOOLEAN, 8,\r\nNULL, 0x20, NULL, HFILL}},\r\n{ &hf_scsi_mmc_rti_copy,\r\n{"Copy", "scsi_mmc.rti.copy", FT_BOOLEAN, 8,\r\nNULL, 0x10, NULL, HFILL}},\r\n{ &hf_scsi_mmc_rti_track_mode,\r\n{"Track Mode", "scsi_mmc.rti.track_mode", FT_UINT8, BASE_HEX | BASE_EXT_STRING,\r\n&scsi_track_mode_vals_ext, 0x0f, NULL, HFILL}},\r\n{ &hf_scsi_mmc_rti_rt,\r\n{"RT", "scsi_mmc.rti.rt", FT_BOOLEAN, 8,\r\nNULL, 0x80, NULL, HFILL}},\r\n{ &hf_scsi_mmc_rti_blank,\r\n{"Blank", "scsi_mmc.rti.blank", FT_BOOLEAN, 8,\r\nNULL, 0x40, NULL, HFILL}},\r\n{ &hf_scsi_mmc_rti_packet,\r\n{"Packet/Inc", "scsi_mmc.rti.packet", FT_BOOLEAN, 8,\r\nNULL, 0x20, NULL, HFILL}},\r\n{ &hf_scsi_mmc_rti_fp,\r\n{"FP", "scsi_mmc.rti.fp", FT_BOOLEAN, 8,\r\nNULL, 0x10, NULL, HFILL}},\r\n{ &hf_scsi_mmc_rti_data_mode,\r\n{"Data Mode", "scsi_mmc.rti.data_mode", FT_UINT8, BASE_HEX,\r\nVALS(scsi_data_mode_vals), 0x0f, NULL, HFILL}},\r\n{ &hf_scsi_mmc_rti_lra_v,\r\n{"LRA_V", "scsi_mmc.rti.lra_v", FT_BOOLEAN, 8,\r\nNULL, 0x02, NULL, HFILL}},\r\n{ &hf_scsi_mmc_rti_nwa_v,\r\n{"NWA_V", "scsi_mmc.rti.nwa_v", FT_BOOLEAN, 8,\r\nNULL, 0x01, NULL, HFILL}},\r\n{ &hf_scsi_mmc_report_key_type_code,\r\n{"Type Code", "scsi_mmc.report_key.type_code", FT_UINT8, BASE_HEX,\r\nVALS(scsi_report_key_type_code_val), 0xc0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_report_key_vendor_resets,\r\n{"Vendor Resets", "scsi_mmc.report_key.vendor_resets", FT_UINT8, BASE_HEX,\r\nNULL, 0x38, NULL, HFILL}},\r\n{ &hf_scsi_mmc_report_key_user_changes,\r\n{"User Changes", "scsi_mmc.report_key.user_changes", FT_UINT8, BASE_HEX,\r\nNULL, 0x07, NULL, HFILL}},\r\n{ &hf_scsi_mmc_report_key_region_mask,\r\n{"Region Mask", "scsi_mmc.report_key.region_mask", FT_UINT8, BASE_HEX,\r\nNULL, 0xff, NULL, HFILL}},\r\n{ &hf_scsi_mmc_report_key_rpc_scheme,\r\n{"RPC Scheme", "scsi_mmc.report_key.rpc_scheme", FT_UINT8, BASE_HEX,\r\nVALS(scsi_report_key_rpc_scheme_val), 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_key_class,\r\n{"Key Class", "scsi_mmc.key_class", FT_UINT8, BASE_HEX,\r\nVALS (scsi_key_class_val), 0x00, NULL, HFILL}},\r\n{ &hf_scsi_mmc_key_format,\r\n{"Key Format", "scsi_mmc.key_format", FT_UINT8, BASE_HEX,\r\nVALS (scsi_key_format_val), 0x3f, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_erasable,\r\n{"Erasable", "scsi_mmc.disc_info.erasable", FT_BOOLEAN, 8,\r\nNULL, 0x10, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_state_of_last_session,\r\n{"State Of Last Session", "scsi_mmc.disc_info.state_of_last_session", FT_UINT8, BASE_HEX,\r\nVALS(scsi_disc_info_sols_val), 0x0c, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_disk_status,\r\n{"Disk Status", "scsi_mmc.disc_info.disk_status", FT_UINT8, BASE_HEX,\r\nVALS(scsi_disc_info_disc_status_val), 0x03, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_number_of_sessions,\r\n{"Number Of Sessions", "scsi_mmc.disc_info.number_of_sessions", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_first_track_in_last_session,\r\n{"First Track In Last Session", "scsi_mmc.disc_info.first_track_in_last_session", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_last_track_in_last_session,\r\n{"Last Track In Last Session", "scsi_mmc.disc_info.last_track_in_last_session", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_did_v,\r\n{"DID_V", "scsi_mmc.disc_info.did_v", FT_BOOLEAN, 8,\r\nNULL, 0x80, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_dbc_v,\r\n{"DBC_V", "scsi_mmc.disc_info.dbc_v", FT_BOOLEAN, 8,\r\nNULL, 0x40, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_uru,\r\n{"URU", "scsi_mmc.disc_info.uru", FT_BOOLEAN, 8,\r\nNULL, 0x20, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_dac_v,\r\n{"DAC_V", "scsi_mmc.disc_info.dac_v", FT_BOOLEAN, 8,\r\nNULL, 0x10, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_dbit,\r\n{"Dbit", "scsi_mmc.disc_info.dbit", FT_BOOLEAN, 8,\r\nNULL, 0x04, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_bgfs,\r\n{"BG Format Status", "scsi_mmc.disc_info.bgfs", FT_UINT8, BASE_HEX,\r\nVALS(scsi_disc_info_bgfs_val), 0x03, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_disc_type,\r\n{"Disc Type", "scsi_mmc.disc_info.disc_type", FT_UINT8, BASE_HEX,\r\nVALS(scsi_disc_info_disc_type_val), 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_disc_identification,\r\n{"Disc Identification", "scsi_mmc.disc_info.disc_identification", FT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_last_session_lead_in_start_address,\r\n{"Last Session Lead-In Start Address", "scsi_mmc.disc_info.last_session_lead_in_start_address", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_last_possible_lead_out_start_address,\r\n{"Last Possible Lead-Out Start Address", "scsi_mmc.disc_info.last_possible_lead_out_start_address", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_info_disc_bar_code,\r\n{"Disc Bar Code", "scsi_mmc.disc_info.disc_bar_code", FT_UINT64, BASE_HEX,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_readtoc_time,\r\n{"Time", "scsi_mmc.readtoc.time", FT_BOOLEAN, 8,\r\nNULL, 0x02, NULL, HFILL}},\r\n{ &hf_scsi_mmc_readtoc_format,\r\n{"Format", "scsi_mmc.readtoc.format", FT_UINT8, BASE_HEX,\r\nNULL, 0x0f, NULL, HFILL}},\r\n{ &hf_scsi_mmc_readtoc_first_session,\r\n{"First Session", "scsi_mmc.readtoc.first_session", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_readtoc_last_track,\r\n{"Last Track", "scsi_mmc.readtoc.last_track", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_readtoc_last_session,\r\n{"Last Session", "scsi_mmc.readtoc.last_session", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_q_subchannel_adr,\r\n{"Q Subchannel ADR", "scsi_mmc.q.subchannel.adr", FT_UINT8, BASE_HEX,\r\nVALS(scsi_q_subchannel_adr_val), 0xf0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_q_subchannel_control,\r\n{"Q Subchannel Control", "scsi_mmc.q.subchannel.control", FT_UINT8, BASE_HEX | BASE_EXT_STRING,\r\n&scsi_q_subchannel_control_val_ext, 0x0f, NULL, HFILL}},\r\n{ &hf_scsi_mmc_agid,\r\n{"AGID", "scsi_mmc.agid", FT_UINT8, BASE_HEX,\r\nNULL, 0xc0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_track,\r\n{"Track", "scsi_mmc.track", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_track_size,\r\n{"Track Size", "scsi_mmc.track_size", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_track_start_address,\r\n{"Track Start Address", "scsi_mmc.track_start_address", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_track_start_time,\r\n{"Track Start Time", "scsi_mmc.track_start_time", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_lba,\r\n{"Logical Block Address", "scsi_mmc.lba", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_session,\r\n{"Session", "scsi_mmc.session", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_data_length,\r\n{"Data Length", "scsi_mmc.data_length", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_getconf_rt,\r\n{"RT", "scsi_mmc.getconf.rt", FT_UINT8, BASE_HEX,\r\nVALS(scsi_getconf_rt_val), 0x03, NULL, HFILL}},\r\n{ &hf_scsi_mmc_getconf_current_profile,\r\n{"Current Profile", "scsi_mmc.getconf.current_profile", FT_UINT16, BASE_HEX | BASE_EXT_STRING,\r\n&scsi_getconf_current_profile_val_ext, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_getconf_starting_feature,\r\n{"Starting Feature", "scsi_mmc.getconf.starting_feature", FT_UINT16, BASE_HEX | BASE_EXT_STRING,\r\n&scsi_feature_val_ext, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature,\r\n{"Feature", "scsi_mmc.feature", FT_UINT16, BASE_HEX | BASE_EXT_STRING,\r\n&scsi_feature_val_ext, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_version,\r\n{"Version", "scsi_mmc.feature.version", FT_UINT8, BASE_DEC,\r\nNULL, 0x3c, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_persistent,\r\n{"Persistent", "scsi_mmc.feature.persistent", FT_UINT8, BASE_HEX,\r\nNULL, 0x02, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_current,\r\n{"Current", "scsi_mmc.feature.current", FT_UINT8, BASE_HEX,\r\nNULL, 001, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_additional_length,\r\n{"Additional Length", "scsi_mmc.feature.additional_length", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_lun_sn,\r\n{"LUN Serial Number", "scsi_mmc.feature.lun_sn", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_cdread_dap,\r\n{"DAP", "scsi_mmc.feature.cdread.dap", FT_BOOLEAN, 8,\r\nNULL, 0x80, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_cdread_c2flag,\r\n{"C2 Flag", "scsi_mmc.feature.cdread.c2flag", FT_BOOLEAN, 8,\r\nNULL, 0x02, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_cdread_cdtext,\r\n{"CD-Text", "scsi_mmc.feature.cdread.cdtext", FT_BOOLEAN, 8,\r\nNULL, 0x01, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_dvdrw_write,\r\n{"Write", "scsi_mmc.feature.dvdrw.write", FT_BOOLEAN, 8,\r\nNULL, 0x01, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_dvdrw_quickstart,\r\n{"Quick Start", "scsi_mmc.feature.dvdrw.quickstart", FT_BOOLEAN, 8,\r\nNULL, 0x02, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_dvdrw_closeonly,\r\n{"Close Only", "scsi_mmc.feature.dvdrw.closeonly", FT_BOOLEAN, 8,\r\nNULL, 0x01, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_dvdr_write,\r\n{"Write", "scsi_mmc.feature.dvdr.write", FT_BOOLEAN, 8,\r\nNULL, 0x01, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_tao_buf,\r\n{"BUF", "scsi_mmc.feature.tao.buf", FT_BOOLEAN, 8,\r\nNULL, 0x40, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_tao_rwraw,\r\n{"R-W Raw", "scsi_mmc.feature.tao.rwraw", FT_BOOLEAN, 8,\r\nNULL, 0x10, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_tao_rwpack,\r\n{"R-W Pack", "scsi_mmc.feature.tao.rwpack", FT_BOOLEAN, 8,\r\nNULL, 0x08, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_tao_testwrite,\r\n{"Test Write", "scsi_mmc.feature.tao.testwrite", FT_BOOLEAN, 8,\r\nNULL, 0x04, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_tao_cdrw,\r\n{"CD-RW", "scsi_mmc.feature.tao.cdrw", FT_BOOLEAN, 8,\r\nNULL, 0x02, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_tao_rwsubcode,\r\n{"R-W Subcode", "scsi_mmc.feature.tao.rwsubcode", FT_BOOLEAN, 8,\r\nNULL, 0x01, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_dts,\r\n{"Data Type Supported", "scsi_mmc.feature.dts", FT_UINT16, BASE_HEX,\r\nNULL, 0xffff, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_sao_buf,\r\n{"BUF", "scsi_mmc.feature.sao.buf", FT_BOOLEAN, 8,\r\nNULL, 0x40, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_sao_sao,\r\n{"SAO", "scsi_mmc.feature.sao.sao", FT_BOOLEAN, 8,\r\nNULL, 0x20, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_sao_rawms,\r\n{"Raw MS", "scsi_mmc.feature.sao.rawms", FT_BOOLEAN, 8,\r\nNULL, 0x10, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_sao_raw,\r\n{"Raw", "scsi_mmc.feature.sao.raw", FT_BOOLEAN, 8,\r\nNULL, 0x08, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_sao_testwrite,\r\n{"Test Write", "scsi_mmc.feature.sao.testwrite", FT_BOOLEAN, 8,\r\nNULL, 0x04, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_sao_cdrw,\r\n{"CD-RW", "scsi_mmc.feature.sao.cdrw", FT_BOOLEAN, 8,\r\nNULL, 0x02, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_sao_rw,\r\n{"R-W", "scsi_mmc.feature.sao.rw", FT_BOOLEAN, 8,\r\nNULL, 0x01, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_sao_mcsl,\r\n{"Maximum Cue Sheet Length", "scsi_mmc.feature.sao.mcsl", FT_UINT24, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_dvdr_buf,\r\n{"BUF", "scsi_mmc.feature.dvdr.buf", FT_BOOLEAN, 8,\r\nNULL, 0x40, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_dvdr_testwrite,\r\n{"Test Write", "scsi_mmc.feature.dvdr.testwrite", FT_BOOLEAN, 8,\r\nNULL, 0x04, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_dvdr_dvdrw,\r\n{"DVD-RW", "scsi_mmc.feature.dvdr.dvdrw", FT_BOOLEAN, 8,\r\nNULL, 0x02, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_profile,\r\n{"Profile", "scsi_mmc.feature.profile", FT_UINT16, BASE_HEX | BASE_EXT_STRING,\r\n&scsi_getconf_current_profile_val_ext, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_profile_current,\r\n{"Current", "scsi_mmc.feature.profile.current", FT_BOOLEAN, 8,\r\nNULL, 0x01, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_isw_buf,\r\n{"BUF", "scsi_mmc.feature.isw.buf", FT_BOOLEAN, 8,\r\nNULL, 0x01, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_isw_num_linksize,\r\n{"Number of Link Sizes", "scsi_mmc.feature.isw.num_linksize", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_feature_isw_linksize,\r\n{"Link Size", "scsi_mmc.feature.isw.linksize", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_read_compatibility_lba,\r\n{"Read Compatibility LBA", "scsi_mmc.read_compatibility_lba", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_reservation_size,\r\n{"Reservation Size", "scsi_mmc.reservation_size", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_last_recorded_address,\r\n{"Last Recorded Address", "scsi_mmc.last_recorded_address", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_first_track,\r\n{"First Track", "scsi_mmc.first_track", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_fixed_packet_size,\r\n{"Fixed Packet Size", "scsi_mmc.fixed_packet_size", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_closetrack_immed,\r\n{"IMMED", "scsi_mmc.closetrack.immed", FT_BOOLEAN, 8,\r\nNULL, 0x01, NULL, HFILL}},\r\n{ &hf_scsi_mmc_closetrack_func,\r\n{"Close Function", "scsi_mmc.closetrack.func", FT_UINT8, BASE_HEX,\r\nVALS(scsi_closetrack_func_val), 0x07, NULL, HFILL}},\r\n{ &hf_scsi_mmc_synccache_immed,\r\n{"IMMED", "scsi_mmc.synccache.immed", FT_BOOLEAN, 8,\r\nNULL, 0x02, NULL, HFILL}},\r\n{ &hf_scsi_mmc_synccache_reladr,\r\n{"RelAdr", "scsi_mmc.synccache.reladr", FT_BOOLEAN, 8,\r\nNULL, 0x01, NULL, HFILL}},\r\n{ &hf_scsi_mmc_num_blocks,\r\n{"Number of Blocks", "scsi_mmc.num_blocks", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_next_writable_address,\r\n{"Next Writable Address", "scsi_mmc.next_writable_address", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_free_blocks,\r\n{"Free Blocks", "scsi_mmc.free_blocks", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_read_dvd_format,\r\n{ "Format Code", "scsi_mmc.read_dvd.format", FT_UINT8, BASE_HEX | BASE_EXT_STRING,\r\n&scsi_read_dvd_formats_ext, 0x0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_book_type,\r\n{ "Type", "scsi_mmc.book.type", FT_UINT8, BASE_HEX,\r\nVALS(scsi_disc_category_type), 0xf0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_book_version,\r\n{ "Version", "scsi_mmc.book.version", FT_UINT8, BASE_HEX,\r\nNULL, 0x0f, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_size_size,\r\n{ "Size", "scsi_mmc.disc.size", FT_UINT8, BASE_HEX,\r\nVALS(scsi_disc_size), 0xf0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_size_rate,\r\n{ "Rate", "scsi_mmc.disc.rate", FT_UINT8, BASE_HEX,\r\nVALS(scsi_disc_rate), 0x0f, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_structure_layer,\r\n{ "Structure", "scsi_mmc.disc.structure", FT_UINT8, BASE_HEX,\r\nVALS(scsi_disc_structure), 0x0f, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_density_length,\r\n{ "Channel bith length", "scsi_mmc.density.channel_bit_length", FT_UINT8, BASE_HEX,\r\nVALS(scsi_density_length), 0xf0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_density_pitch,\r\n{ "Average Track Pitch", "scsi_mmc.density.average_track_pitch", FT_UINT8, BASE_HEX,\r\nVALS(scsi_density_pitch), 0x0f, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_first_physical,\r\n{ "First physical sector of data zone", "scsi_mmc.first_physical", FT_UINT24, BASE_HEX,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_last_physical,\r\n{ "Last physical sector of data zone", "scsi_mmc.last_physical", FT_UINT24, BASE_HEX,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_last_physical_layer0,\r\n{ "Last physical sector of layer 0", "scsi_mmc.last_physical_layer0", FT_UINT24, BASE_HEX,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_extended_format_info,\r\n{ "Extended Format Info", "scsi_mmc.adip.extended_format_info", FT_BOOLEAN, 8,\r\nTFS(&scsi_adip_extended_format_info), 0x40, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_application_code,\r\n{ "Disk Application Code", "scsi_mmc.disk_application_code", FT_UINT8, BASE_HEX,\r\nVALS(scsi_disk_application_code), 0x0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_adip_eib0,\r\n{ "Extended Format Block 0", "scsi_mmc.adip.extended_format_block.0", FT_BOOLEAN, 8,\r\nNULL, 0x01, NULL, HFILL}},\r\n{ &hf_scsi_mmc_adip_eib1,\r\n{ "Extended Format Block 1", "scsi_mmc.adip.extended_format_block.1", FT_BOOLEAN, 8,\r\nNULL, 0x02, NULL, HFILL}},\r\n{ &hf_scsi_mmc_adip_eib2,\r\n{ "Extended Format Block 2", "scsi_mmc.adip.extended_format_block.2", FT_BOOLEAN, 8,\r\nNULL, 0x04, NULL, HFILL}},\r\n{ &hf_scsi_mmc_adip_eib3,\r\n{ "Extended Format Block 3", "scsi_mmc.adip.extended_format_block.3", FT_BOOLEAN, 8,\r\nNULL, 0x08, NULL, HFILL}},\r\n{ &hf_scsi_mmc_adip_eib4,\r\n{ "Extended Format Block 4", "scsi_mmc.adip.extended_format_block.4", FT_BOOLEAN, 8,\r\nNULL, 0x10, NULL, HFILL}},\r\n{ &hf_scsi_mmc_adip_eib5,\r\n{ "Extended Format Block 5", "scsi_mmc.adip.extended_format_block.5", FT_BOOLEAN, 8,\r\nNULL, 0x20, NULL, HFILL}},\r\n{ &hf_scsi_mmc_adip_device_manuf_id,\r\n{ "Device Manufacturer Id", "scsi_mmc.adip.device_manufacturer_id", FT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_adip_media_type_id,\r\n{ "Media Type Id", "scsi_mmc.adip.media_type_id", FT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_adip_product_revision_number,\r\n{ "Product Revision Number", "scsi_mmc.adip.product_revision_number", FT_UINT8, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_adip_number_of_physical_info,\r\n{ "Number of bytes of physical info", "scsi_mmc.adip.number_of_physical_info", FT_UINT8, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_num_layers,\r\n{ "Number of Layers", "scsi_mmc.disk.num_layers", FT_UINT8, BASE_DEC,\r\nVALS(scsi_num_layers), 0x60, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disc_track_path,\r\n{ "Track Path", "scsi_mmc.disk.track_path", FT_BOOLEAN, 8,\r\nTFS(&scsi_track_path), 0x10, NULL, HFILL}},\r\n{ &hf_scsi_mmc_gesn_polled,\r\n{ "Polled", "scsi_mmc.gesn.polled", FT_BOOLEAN, 8,\r\nTFS(&scsi_gesn_path), 0x01, NULL, HFILL}},\r\n{ &hf_scsi_mmc_notification_flags,\r\n{"Notification Class Request", "scsi_mmc.notification.flags", FT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL}},\r\n{ &hf_scsi_mmc_gesn_device_busy,\r\n{ "DEVICE BUSY", "scsi_mmc.gesn.device_busy", FT_BOOLEAN, 8,\r\nNULL, 0x40, NULL, HFILL}},\r\n{ &hf_scsi_mmc_gesn_multi_initiator,\r\n{ "MULTI_INITIATOR", "scsi_mmc.gesn.multi_initiator", FT_BOOLEAN, 8,\r\nNULL, 0x20, NULL, HFILL}},\r\n{ &hf_scsi_mmc_gesn_media,\r\n{ "MEDIA", "scsi_mmc.gesn.media", FT_BOOLEAN, 8,\r\nNULL, 0x10, NULL, HFILL}},\r\n{ &hf_scsi_mmc_gesn_external_request,\r\n{ "EXTERNAL_REQUEST", "scsi_mmc.gesn.external_request", FT_BOOLEAN, 8,\r\nNULL, 0x08, NULL, HFILL}},\r\n{ &hf_scsi_mmc_gesn_power_mgmt,\r\n{ "POWER_MANAGEMENT", "scsi_mmc.gesn.power_management", FT_BOOLEAN, 8,\r\nNULL, 0x04, NULL, HFILL}},\r\n{ &hf_scsi_mmc_gesn_operational_change,\r\n{ "OPERATIONAL_CHANGE", "scsi_mmc.gesn.operational_change", FT_BOOLEAN, 8,\r\nNULL, 0x02, NULL, HFILL}},\r\n{ &hf_scsi_mmc_prevent_allow_flags,\r\n{"Prevent Allow Flags", "scsi_mmc.prevent_allow.flags", FT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL}},\r\n{ &hf_scsi_mmc_prevent_allow_persistent,\r\n{ "PERSISTENT", "scsi_mmc.prevent_allow.persistent", FT_BOOLEAN, 8,\r\nNULL, 0x02, NULL, HFILL}},\r\n{ &hf_scsi_mmc_prevent_allow_prevent,\r\n{ "PREVENT", "scsi_mmc.prevent_allow.prevent", FT_BOOLEAN, 8,\r\nNULL, 0x01, NULL, HFILL}},\r\n{ &hf_scsi_mmc_disk_flags,\r\n{"Disk Flags", "scsi_mmc.disk.flags", FT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL}},\r\n{ &hf_scsi_mmc_format_flags,\r\n{"Format Flags", "scsi_mmc.format.flags", FT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL}},\r\n{ &hf_scsi_mmc_track_flags,\r\n{"Track Flags", "scsi_mmc.track.flags", FT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL}},\r\n{ &hf_scsi_mmc_data_flags,\r\n{"Data Flags", "scsi_mmc.data.flags", FT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL}},\r\n{ &hf_scsi_mmc_read_dvd_address, { "Address", "scsi_mmc.read_dvd.address", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_scsi_mmc_read_dvd_layer_number, { "Layer Number", "scsi_mmc.read_dvd.layer_number", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_scsi_mmc_read_dvd_agid, { "AGID", "scsi_mmc.read_dvd.agid", FT_UINT8, BASE_DEC, NULL, 0xc0, NULL, HFILL }},\r\n{ &hf_scsi_mmc_getperformance_data_type, { "Data Type", "scsi_mmc.getperformance.data_type", FT_UINT8, BASE_DEC, NULL, 0x1f, NULL, HFILL }},\r\n{ &hf_scsi_mmc_getperformance_starting_lba, { "Starting LBA", "scsi_mmc.getperformance.starting_lba", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_scsi_mmc_getperformance_max_num_descriptors, { "Maximum Number of Descriptors", "scsi_mmc.getperformance.max_num_descriptors", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_scsi_mmc_getperformance_type, { "Type", "scsi_mmc.getperformance.type", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_scsi_mmc_setcdspeed_logical_unit_read_speed, { "Logical Unit Read Speed(bytes/sec)", "scsi_mmc.setcdspeed.logical_unit_read_speed", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_scsi_mmc_setcdspeed_logical_unit_write_speed, { "Logical Unit Write Speed(bytes/sec)", "scsi_mmc.setcdspeed.logical_unit_write_speed", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_scsi_mmc_profile,\r\n&ett_scsi_notifications,\r\n&ett_scsi_prevent_allow,\r\n&ett_scsi_disk_flags,\r\n&ett_scsi_format_flags,\r\n&ett_scsi_track_flags,\r\n&ett_scsi_data_flags,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_scsi_mmc_unknown_feature_data, { "scsi_mmc.unknown_feature_data", PI_PROTOCOL, PI_WARN, "SCSI/MMC Unknown Feature data", EXPFILL }},\r\n{ &ei_scsi_mmc_unknown_read_toc_format, { "scsi_mmc.unknown_read_toc_format", PI_PROTOCOL, PI_WARN, "SCSI/MMC Unknown READ TOC Format", EXPFILL }},\r\n{ &ei_scsi_mmc_unknown_read_dvd_format, { "scsi_mmc.unknown_read_dvd_format", PI_PROTOCOL, PI_WARN, "SCSI/MMC Unknown Read DVD Format", EXPFILL }},\r\n{ &ei_scsi_mmc_unknown_format_class, { "scsi_mmc.unknown_format_class", PI_PROTOCOL, PI_WARN, "SCSI/MMC Unknown Format/Class combination", EXPFILL }},\r\n{ &ei_scsi_mmc_unknown_setstreaming_type, { "scsi_mmc.unknown_setstreaming_type", PI_PROTOCOL, PI_WARN, "SCSI/MMC Unknown SetStreaming Type", EXPFILL }},\r\n};\r\nexpert_module_t* expert_scsi_mmc;\r\nproto_scsi_mmc = proto_register_protocol("SCSI_MMC", "SCSI_MMC", "scsi_mmc");\r\nproto_register_field_array(proto_scsi_mmc, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_scsi_mmc = expert_register_protocol(proto_scsi_mmc);\r\nexpert_register_field_array(expert_scsi_mmc, ei, array_length(ei));\r\n}
