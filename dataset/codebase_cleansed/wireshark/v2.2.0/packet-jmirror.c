static dissector_handle_t\r\nget_heuristic_handle(tvbuff_t *tvb)\r\n{\r\nint offset = MIRROR_HDR_SZ;\r\nint byte0, byte1, byte2, byte3;\r\nif (!tvb_bytes_exist(tvb, offset, 4))\r\nreturn NULL;\r\nbyte0 = tvb_get_guint8(tvb, offset + 0);\r\nbyte1 = tvb_get_guint8(tvb, offset + 1);\r\nbyte2 = tvb_get_guint8(tvb, offset + 2);\r\nbyte3 = tvb_get_guint8(tvb, offset + 3);\r\nif ( byte0 == 0x45 && ipv4_handle )\r\nreturn ipv4_handle;\r\nelse if ( hi_nibble(byte0) == 6 && ipv6_handle )\r\nreturn ipv6_handle;\r\nelse if ( byte0 == 0xff && byte1 == 0x03 && lo_nibble(byte2) == 0 && byte3 == 0x21 && hdlc_handle )\r\nreturn hdlc_handle;\r\nelse if ( byte0 == 0xff && byte1 == 0x03 && byte2 == 0 && byte3 == 0x57 && hdlc_handle )\r\nreturn hdlc_handle;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic int\r\ndissect_jmirror(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nint offset = 0;\r\ndissector_handle_t dissector_handle;\r\nunsigned int midval, sidval;\r\nproto_item *ti = NULL;\r\nproto_tree *jmirror_tree = NULL;\r\ntvbuff_t *next_tvb = NULL;\r\nif ( !( dissector_handle = get_heuristic_handle(tvb) ) )\r\nreturn 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Jmirror");\r\nmidval = tvb_get_ntohl(tvb, offset);\r\nsidval = tvb_get_ntohl(tvb, offset+MIRROR_ID_SZ);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MID: 0X%08x (%d), SID: 0x%08x (%d)", midval, midval, sidval, sidval);\r\nti = proto_tree_add_protocol_format(tree, proto_jmirror, tvb, offset, MIRROR_HDR_SZ,\r\n"Juniper Packet Mirror, MID: 0x%08x (%d), SID: 0x%08x (%d)", midval, midval, sidval, sidval);\r\njmirror_tree = proto_item_add_subtree(ti, ett_jmirror);\r\nproto_tree_add_item(jmirror_tree, hf_jmirror_mid, tvb, offset, MIRROR_ID_SZ, ENC_BIG_ENDIAN);\r\noffset += MIRROR_ID_SZ;\r\nproto_tree_add_item(jmirror_tree, hf_jmirror_sid, tvb, offset, SESSION_ID_SZ, ENC_BIG_ENDIAN);\r\noffset += SESSION_ID_SZ;\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nreturn MIRROR_HDR_SZ + call_dissector(dissector_handle, next_tvb, pinfo, tree);\r\n}\r\nvoid\r\nproto_register_jmirror(void)\r\n{\r\nmodule_t *jmirror_module = NULL;\r\nstatic hf_register_info jmirror_hf[] = {\r\n{ &hf_jmirror_mid,\r\n{ "Jmirror Identifier", "jmirror.mid", FT_UINT32, BASE_HEX_DEC, NULL, 0x0,\r\n"Unique identifier of the mirrored session", HFILL }\r\n},\r\n{ &hf_jmirror_sid,\r\n{ "Session Identifier", "jmirror.sid", FT_UINT32, BASE_HEX_DEC, NULL, 0x0,\r\n"Unique identifier of the user session", HFILL }\r\n}\r\n};\r\nstatic gint *jmirror_ett[] = {\r\n&ett_jmirror\r\n};\r\nproto_jmirror = proto_register_protocol("Juniper Packet Mirror", "Jmirror", "jmirror");\r\njmirror_module = prefs_register_protocol(proto_jmirror, proto_reg_handoff_jmirror);\r\nprefs_register_uint_preference(jmirror_module, "udp.port", "JMirror UDP Port",\r\n"Set the port for JMirror Port (if other than the default of 30030)",\r\n10, &global_jmirror_udp_port);\r\nproto_register_field_array(proto_jmirror, jmirror_hf, array_length(jmirror_hf));\r\nproto_register_subtree_array(jmirror_ett, array_length(jmirror_ett));\r\n}\r\nvoid\r\nproto_reg_handoff_jmirror(void)\r\n{\r\nstatic int jmirror_inited = FALSE;\r\nstatic guint jmirror_udp_port;\r\nstatic dissector_handle_t jmirror_handle;\r\nif ( !jmirror_inited )\r\n{\r\njmirror_handle = create_dissector_handle(dissect_jmirror, proto_jmirror);\r\nipv4_handle = find_dissector("ip");\r\nipv6_handle = find_dissector("ipv6");\r\nhdlc_handle = find_dissector("pw_hdlc_nocw_hdlc_ppp");\r\njmirror_inited = TRUE;\r\n} else {\r\ndissector_delete_uint("udp.port", jmirror_udp_port, jmirror_handle);\r\n}\r\njmirror_udp_port = global_jmirror_udp_port;\r\ndissector_add_uint("udp.port", jmirror_udp_port, jmirror_handle);\r\n}
