static int\r\ndissect_ipmi_session(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_tree *sess_tree = NULL, *s_tree;\r\nproto_item *ti;\r\ntvbuff_t *next_tvb;\r\nguint32 session_id;\r\nguint8 authtype, payloadtype = 0;\r\nguint32 msg_start, msg_len, offset = 0;\r\ngboolean payloadtype_auth = 0, payloadtype_enc = 0;\r\nauthtype = tvb_get_guint8(tvb, 0);\r\nif (authtype == IPMI_AUTH_RMCPP) {\r\npayloadtype = tvb_get_guint8(tvb, 1);\r\npayloadtype_auth = (payloadtype >> 6) & 1;\r\npayloadtype_enc = (payloadtype >> 7);\r\npayloadtype &= 0x3f;\r\nif (payloadtype == IPMI_OEM_EXPLICIT) {\r\nsession_id = tvb_get_letohl(tvb, 8);\r\nmsg_start = 18;\r\nmsg_len = tvb_get_letohs(tvb, 16);\r\n} else {\r\nsession_id = tvb_get_letohl(tvb, 2);\r\nmsg_start = 12;\r\nmsg_len = tvb_get_letohs(tvb, 10);\r\n}\r\n} else {\r\nsession_id = tvb_get_letohl(tvb, 5);\r\nif (authtype == IPMI_AUTH_NONE) {\r\nmsg_start = 10;\r\nmsg_len = tvb_get_guint8(tvb, 9);\r\n} else {\r\nmsg_start = 26;\r\nmsg_len = tvb_get_guint8(tvb, 25);\r\n}\r\n}\r\nif (authtype == IPMI_AUTH_RMCPP) {\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "RMCP+");\r\n} else {\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "IPMI");\r\n}\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Session ID 0x%x", session_id);\r\nif (authtype == IPMI_AUTH_RMCPP) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", payload type: %s",\r\nval_to_str_const(payloadtype, ipmi_payload_vals, "Unknown"));\r\n}\r\nif (tree) {\r\noffset = 0;\r\nti = proto_tree_add_protocol_format(tree, proto_ipmi_session,\r\ntvb, 0, -1,\r\n"IPMI v%s Session Wrapper, session ID 0x%x",\r\nauthtype == IPMI_AUTH_RMCPP ? "2.0+" : "1.5",\r\nsession_id);\r\nsess_tree = proto_item_add_subtree(ti, ett_ipmi_session);\r\nproto_tree_add_item(sess_tree, hf_ipmi_session_authtype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\nif (authtype == IPMI_AUTH_RMCPP) {\r\ns_tree = proto_tree_add_subtree_format(sess_tree, tvb, offset, 1,\r\nett_ipmi_session_payloadtype, NULL,\r\n"Payload type: %s (0x%02x), %sencrypted, %sauthenticated",\r\nval_to_str_const(payloadtype, ipmi_payload_vals, "Unknown"),\r\npayloadtype,\r\npayloadtype_enc ? "" : "not ",\r\npayloadtype_auth ? "" : "not ");\r\nproto_tree_add_item(s_tree, hf_ipmi_session_payloadtype_enc, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(s_tree, hf_ipmi_session_payloadtype_auth, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(s_tree, hf_ipmi_session_payloadtype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\nif (payloadtype == IPMI_OEM_EXPLICIT) {\r\nproto_tree_add_item(sess_tree, hf_ipmi_session_oem_iana, tvb, offset, 4, ENC_NA);\r\noffset += 4;\r\nproto_tree_add_item(sess_tree, hf_ipmi_session_oem_payload_id, tvb, offset, 2, ENC_NA);\r\noffset += 2;\r\n}\r\nproto_tree_add_item(sess_tree, hf_ipmi_session_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(sess_tree, hf_ipmi_session_sequence, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(sess_tree, hf_ipmi_session_msg_len_2b, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\n} else {\r\nproto_tree_add_item(sess_tree, hf_ipmi_session_sequence, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(sess_tree, hf_ipmi_session_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nif (authtype != IPMI_AUTH_NONE) {\r\nproto_tree_add_item(sess_tree, hf_ipmi_session_authcode,\r\ntvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n}\r\nproto_tree_add_item(sess_tree, hf_ipmi_session_msg_len_1b, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\n}\r\n}\r\nnext_tvb = tvb_new_subset(tvb, msg_start, msg_len, -1);\r\nif (payloadtype_enc) {\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n} else if (authtype != IPMI_AUTH_RMCPP || payloadtype == IPMI_IPMI_MESSAGE) {\r\ncall_dissector(ipmi_handle, next_tvb, pinfo, tree);\r\n} else {\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\nif (tree) {\r\noffset += msg_len;\r\nif (offset < tvb_captured_length(tvb)) {\r\nproto_tree_add_item(sess_tree, hf_ipmi_session_trailer,\r\ntvb, offset, -1, ENC_NA);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ipmi_session(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ipmi_session_authtype, {\r\n"Authentication Type", "ipmi_session.authtype",\r\nFT_UINT8, BASE_HEX, VALS(ipmi_authtype_vals), 0, NULL, HFILL }},\r\n{ &hf_ipmi_session_payloadtype,{\r\n"Payload Type", "ipmi_session.payloadtype",\r\nFT_UINT8, BASE_HEX, VALS(ipmi_payload_vals), 0x3f, NULL, HFILL }},\r\n{ &hf_ipmi_session_payloadtype_auth,{\r\n"Authenticated","ipmi_session.payloadtype.auth",\r\nFT_BOOLEAN,8, TFS(&ipmi_payload_aut_val), 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_session_payloadtype_enc,{\r\n"Encryption","ipmi_session.payloadtype.enc",\r\nFT_BOOLEAN,8, TFS(&ipmi_payload_enc_val), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_session_oem_iana, {\r\n"OEM IANA", "ipmi_session.oem.iana",\r\nFT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_session_oem_payload_id, {\r\n"OEM Payload ID", "ipmi_session.oem.payloadid",\r\nFT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_session_sequence, {\r\n"Session Sequence Number", "ipmi_session.sequence",\r\nFT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_session_id, {\r\n"Session ID", "ipmi_session.id",\r\nFT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_session_authcode, {\r\n"Authentication Code", "ipmi_session.authcode",\r\nFT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_session_msg_len_1b, {\r\n"Message Length", "ipmi_session.msg.len",\r\nFT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_session_msg_len_2b, {\r\n"Message Length", "ipmi_session.msg.len",\r\nFT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_session_trailer, {\r\n"IPMI Session Wrapper (trailer)", "ipmi_session.trailer",\r\nFT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = { &ett_ipmi_session, &ett_ipmi_session_payloadtype };\r\nproto_ipmi_session = proto_register_protocol(\r\n"Intelligent Platform Management Interface (Session Wrapper)", "IPMI Session",\r\n"ipmi_session");\r\nproto_register_field_array(proto_ipmi_session, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_ipmi_session(void)\r\n{\r\ndissector_handle_t ipmi_session_handle;\r\nipmi_session_handle = create_dissector_handle(dissect_ipmi_session, proto_ipmi_session);\r\ndissector_add_uint("rmcp.class", RMCP_CLASS_IPMI, ipmi_session_handle);\r\nipmi_handle = find_dissector_add_dependency("ipmi", proto_ipmi_session);\r\n}
