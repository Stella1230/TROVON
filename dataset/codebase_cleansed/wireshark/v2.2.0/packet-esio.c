static gboolean\r\nis_esio_pdu(tvbuff_t *tvb)\r\n{\r\nif (tvb_captured_length(tvb) < 20) {\r\nreturn FALSE;\r\n}\r\nif (tvb_strneql(tvb, 0, "ESIO", 4) != 0) {\r\nreturn FALSE;\r\n}\r\nif (tvb_get_guint8(tvb, 4) > 0x00) {\r\nreturn FALSE;\r\n}\r\nif (tvb_get_guint8(tvb, 5) > 0x02) {\r\nreturn FALSE;\r\n}\r\nif (tvb_get_guint8(tvb, 6) > 0x00) {\r\nreturn FALSE;\r\n}\r\nif (tvb_get_guint8(tvb, 7) > 0x00) {\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\ndissect_esio(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *esio_tree, *esio_header_tree, *esio_transfer_header_tree,\r\n*esio_data_tansfer_tree, *esio_data_tree;\r\ngint i;\r\ngint offset;\r\nguint8 esio_nbr_data_transfers;\r\nguint16 esio_telegram_type;\r\nguint16 esio_tlg_type;\r\nguint16 esio_transfer_length;\r\nguint32 esio_transfer_dest_id;\r\nguint32 esio_src_id;\r\nguint32 esio_dst_id;\r\nif (!is_esio_pdu(tvb)) {\r\nreturn 0;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ESIO");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nesio_telegram_type = tvb_get_guint8(tvb,5);\r\nswitch (esio_telegram_type) {\r\ncase ESIO_TRANSFER:\r\nesio_src_id = tvb_get_ntohl(tvb,16);\r\nesio_nbr_data_transfers = tvb_get_guint8(tvb, 20);\r\nesio_dst_id = tvb_get_ntohl(tvb,26);\r\ncol_add_fstr( pinfo->cinfo, COL_INFO,\r\n"Data transfer: Src ID: %d, Dst ID(s): %d",\r\nesio_src_id, esio_dst_id);\r\nif (esio_nbr_data_transfers > 1) {\r\ncol_append_str( pinfo->cinfo, COL_INFO,\r\n" ...");\r\n}\r\nbreak;\r\ncase ESIO_STATUS:\r\nesio_src_id = tvb_get_ntohl(tvb,16);\r\ncol_add_fstr( pinfo->cinfo, COL_INFO,\r\n"Status/diag telegram: Src ID: %d",\r\nesio_src_id);\r\nbreak;\r\ndefault:\r\ncol_set_str( pinfo->cinfo, COL_INFO,\r\n"Unknown telegram");\r\nbreak;\r\n}\r\noffset = 0;\r\nti = proto_tree_add_item(tree, proto_esio, tvb, offset, -1, ENC_NA);\r\nesio_tree = proto_item_add_subtree(ti, ett_esio);\r\nesio_header_tree = proto_tree_add_subtree(esio_tree, tvb, offset, 12, ett_esio_header, NULL, "Ether-S-I/O header");\r\noffset += 4;\r\nesio_tlg_type = tvb_get_ntohs(tvb,offset);\r\nproto_tree_add_item(esio_header_tree,\r\nhf_esio_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(esio_header_tree,\r\nhf_esio_version, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(esio_header_tree,\r\nhf_esio_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(esio_header_tree,\r\nhf_esio_transaction_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nswitch (esio_tlg_type) {\r\ncase ESIO_TRANSFER:\r\nif (tree) {\r\nesio_transfer_header_tree = proto_tree_add_subtree(esio_tree, tvb, offset, 12,\r\nett_esio_transfer_header, NULL, "Transfer header");\r\nproto_tree_add_item(esio_transfer_header_tree,\r\nhf_esio_tlg_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(esio_transfer_header_tree,\r\nhf_esio_src_stn_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nesio_nbr_data_transfers = tvb_get_guint8(tvb,offset);\r\nproto_tree_add_item(esio_transfer_header_tree,\r\nhf_esio_data_nbr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(esio_transfer_header_tree,\r\nhf_esio_data_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nfor (i=((esio_nbr_data_transfers)); i>0; i--) {\r\nesio_transfer_dest_id = tvb_get_ntohl(tvb,(offset+4));\r\nesio_transfer_length = tvb_get_ntohs(tvb,(offset+8));\r\nesio_data_tansfer_tree = proto_tree_add_subtree_format(esio_tree, tvb, offset,\r\n(esio_transfer_length + 10), ett_esio_transfer_data, NULL,\r\n"Data transfer to ID: %d ", esio_transfer_dest_id);\r\nproto_tree_add_item(esio_data_tansfer_tree,\r\nhf_esio_data_transfer_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(esio_data_tansfer_tree,\r\nhf_esio_data_dest_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(esio_data_tansfer_tree,\r\nhf_esio_data_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nesio_data_tree = proto_tree_add_subtree(esio_data_tansfer_tree, tvb, offset,\r\nesio_transfer_length, ett_esio_data, NULL, "Data bytes ");\r\nfor (i=((esio_transfer_length)); i>0; i--) {\r\nproto_tree_add_item(esio_data_tree,\r\nhf_esio_data, tvb, offset,\r\n1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase ESIO_STATUS: {\r\nproto_item *hi = NULL;\r\nif (tree) {\r\nproto_tree_add_item(esio_tree,\r\nhf_esio_sts_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(esio_tree,\r\nhf_esio_sts_size, tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(esio_tree,\r\nhf_esio_src_stn_id, tvb, offset+4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(esio_tree,\r\nhf_esio_rio_sts, tvb, offset+8,\r\n1, ENC_BIG_ENDIAN);\r\nhi = proto_tree_add_item(esio_tree,\r\nhf_esio_rio_tlgs_lost, tvb, offset+9,\r\n1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(esio_tree,\r\nhf_esio_rio_diag, tvb, offset+10,\r\n1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(esio_tree,\r\nhf_esio_rio_flags, tvb, offset+11, 1, ENC_BIG_ENDIAN);\r\n}\r\nif (tvb_get_guint8(tvb, offset + 9) > 0) {\r\nexpert_add_info(pinfo, hi, &ei_esio_telegram_lost);\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_esio(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_esio_type,\r\n{ "Telegram type", "esio.type",\r\nFT_UINT16, BASE_HEX, VALS(esio_tlg_types), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_version,\r\n{ "Version", "esio.vers",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_length,\r\n{ "Length (bytes)", "esio.len",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_transaction_id,\r\n{ "Transaction ID", "esio.transaction_id",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_src_stn_id,\r\n{ "Source station ID", "esio.src_stn_id",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_tlg_id,\r\n{ "Telegram ID", "esio.transfer.tlg_id",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_data_nbr,\r\n{ "Nbr. of data transfers", "esio.data.nbr",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_data_flags,\r\n{ "Transfer header flags", "esio.data.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_data_transfer_id,\r\n{ "Data transfer ID", "esio.data.transfer_id",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_data_dest_id,\r\n{ "Data destination ID", "esio.data.destination_id",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_data_length,\r\n{ "Data transfer length", "esio.data.length",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_data,\r\n{ "Data", "esio.data",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_sts_type,\r\n{ "Status type", "esio.sts.type",\r\nFT_UINT16, BASE_HEX, VALS(esio_sts_types), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_sts_size,\r\n{ "Status length (bytes)", "esio.sts.length",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_rio_sts,\r\n{ "RIO status", "esio.sts.rio_sts",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_rio_tlgs_lost,\r\n{ "Lost telegrams to RIO", "esio.sts.rio_lost_tlg",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_rio_diag,\r\n{ "RIO diagnostics", "esio.sts.rio_diag",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_esio_rio_flags,\r\n{ "RIO flags", "esio.sts.rio_flags",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_esio,\r\n&ett_esio_header,\r\n&ett_esio_transfer_header,\r\n&ett_esio_transfer_data,\r\n&ett_esio_data\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_esio_telegram_lost, { "esio.telegram_lost", PI_SEQUENCE, PI_NOTE, "Telegram(s) lost", EXPFILL }},\r\n};\r\nexpert_module_t* expert_esio;\r\nproto_esio = proto_register_protocol("SAIA Ether-S-I/O protocol", "ESIO", "esio");\r\nproto_register_field_array(proto_esio, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_esio = expert_register_protocol(proto_esio);\r\nexpert_register_field_array(expert_esio, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_esio(void)\r\n{\r\ndissector_handle_t esio_handle;\r\nesio_handle = create_dissector_handle(dissect_esio, proto_esio);\r\ndissector_add_uint("udp.port", 6060, esio_handle);\r\n}
