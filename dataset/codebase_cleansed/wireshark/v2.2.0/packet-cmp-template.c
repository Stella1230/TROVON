static int\r\ndissect_cmp_pdu(tvbuff_t *tvb, proto_tree *tree, asn1_ctx_t *actx)\r\n{\r\nreturn dissect_cmp_PKIMessage(FALSE, tvb, 0, actx,tree, -1);\r\n}\r\nstatic int dissect_cmp_tcp_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data _U_)\r\n{\r\ntvbuff_t *next_tvb;\r\nguint32 pdu_len;\r\nguint8 pdu_type;\r\nnstime_t ts;\r\nproto_item *item=NULL;\r\nproto_item *ti=NULL;\r\nproto_tree *tree=NULL;\r\nproto_tree *tcptrans_tree=NULL;\r\nasn1_ctx_t asn1_ctx;\r\nint offset=0;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "CMP");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "PKIXCMP");\r\nif(parent_tree){\r\nitem=proto_tree_add_item(parent_tree, proto_cmp, tvb, 0, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_cmp);\r\n}\r\npdu_len=tvb_get_ntohl(tvb, 0);\r\npdu_type=tvb_get_guint8(tvb, 4);\r\nif (pdu_type < 10) {\r\nti = proto_tree_add_item(tree, proto_cmp, tvb, offset, 5, ENC_NA);\r\ntcptrans_tree = proto_item_add_subtree(ti, ett_cmp);\r\nproto_tree_add_item(tree, hf_cmp_tcptrans_len, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_cmp_tcptrans_type, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\n} else {\r\ntcptrans_tree = proto_tree_add_subtree(tree, tvb, offset, 7, ett_cmp, NULL, "TCP transport");\r\npdu_type=tvb_get_guint8(tvb, 6);\r\nproto_tree_add_item(tcptrans_tree, hf_cmp_tcptrans_len, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tcptrans_tree, hf_cmp_tcptrans10_version, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tcptrans_tree, hf_cmp_tcptrans10_flags, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tcptrans_tree, hf_cmp_tcptrans_type, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\n}\r\ncol_add_str (pinfo->cinfo, COL_INFO, val_to_str (pdu_type, cmp_pdu_types, "0x%x"));\r\nswitch(pdu_type){\r\ncase CMP_TYPE_PKIMSG:\r\nnext_tvb = tvb_new_subset(tvb, offset, tvb_reported_length_remaining(tvb, offset), pdu_len);\r\ndissect_cmp_pdu(next_tvb, tree, &asn1_ctx);\r\noffset += tvb_reported_length_remaining(tvb, offset);\r\nbreak;\r\ncase CMP_TYPE_POLLREP:\r\nproto_tree_add_item(tcptrans_tree, hf_cmp_tcptrans_poll_ref, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nts.secs = tvb_get_ntohl(tvb, 4);\r\nts.nsecs = 0;\r\nproto_tree_add_time(tcptrans_tree, hf_cmp_tcptrans_ttcb, tvb, offset, 4, &ts);\r\noffset += 4;\r\nbreak;\r\ncase CMP_TYPE_POLLREQ:\r\nproto_tree_add_item(tcptrans_tree, hf_cmp_tcptrans_poll_ref, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase CMP_TYPE_NEGPOLLREP:\r\nbreak;\r\ncase CMP_TYPE_PARTIALMSGREP:\r\nproto_tree_add_item(tcptrans_tree, hf_cmp_tcptrans_next_poll_ref, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nts.secs = tvb_get_ntohl(tvb, 4);\r\nts.nsecs = 0;\r\nproto_tree_add_time(tcptrans_tree, hf_cmp_tcptrans_ttcb, tvb, offset, 4, &ts);\r\noffset += 4;\r\nnext_tvb = tvb_new_subset(tvb, offset, tvb_reported_length_remaining(tvb, offset), pdu_len);\r\ndissect_cmp_pdu(next_tvb, tree, &asn1_ctx);\r\noffset += tvb_reported_length_remaining(tvb, offset);\r\nbreak;\r\ncase CMP_TYPE_FINALMSGREP:\r\nnext_tvb = tvb_new_subset(tvb, offset, tvb_reported_length_remaining(tvb, offset), pdu_len);\r\ndissect_cmp_pdu(next_tvb, tree, &asn1_ctx);\r\noffset += tvb_reported_length_remaining(tvb, offset);\r\nbreak;\r\ncase CMP_TYPE_ERRORMSGREP:\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint get_cmp_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset, void *data _U_)\r\n{\r\nguint32 plen;\r\nplen = tvb_get_ntohl(tvb, offset);\r\nreturn plen+4;\r\n}\r\nstatic int\r\ndissect_cmp_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data)\r\n{\r\nguint32 pdu_len;\r\nguint8 pdu_type;\r\nint offset=4;\r\nif (!tvb_bytes_exist(tvb, 0, 5)) {\r\nreturn 0;\r\n}\r\npdu_len=tvb_get_ntohl(tvb, 0);\r\npdu_type=tvb_get_guint8(tvb, 4);\r\nif(pdu_type == 10) {\r\npdu_type = tvb_get_guint8(tvb, 7);\r\noffset = 7;\r\nif((pdu_len<=2)||(pdu_len>10000)){\r\nreturn 0;\r\n}\r\n} else {\r\nif(pdu_type>6){\r\nreturn 0;\r\n}\r\nif((pdu_len<=0)||(pdu_len>10000)){\r\nreturn 0;\r\n}\r\n}\r\nif((pdu_type==0)&&(pdu_len<3)){\r\nreturn 0;\r\n}\r\ntcp_dissect_pdus(tvb, pinfo, parent_tree, cmp_desegment, offset, get_cmp_pdu_len,\r\ndissect_cmp_tcp_pdu, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_cmp_http(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data _U_)\r\n{\r\nproto_item *item=NULL;\r\nproto_tree *tree=NULL;\r\nasn1_ctx_t asn1_ctx;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "CMP");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "PKIXCMP");\r\nif(parent_tree){\r\nitem=proto_tree_add_item(parent_tree, proto_cmp, tvb, 0, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_cmp);\r\n}\r\nreturn dissect_cmp_pdu(tvb, tree, &asn1_ctx);\r\n}\r\nvoid proto_register_cmp(void) {\r\nstatic hf_register_info hf[] = {\r\n{ &hf_cmp_type_oid,\r\n{ "InfoType", "cmp.type.oid",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\n"Type of InfoTypeAndValue", HFILL }},\r\n{ &hf_cmp_tcptrans_len,\r\n{ "Length", "cmp.tcptrans.length",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"TCP transport Length of PDU in bytes", HFILL }},\r\n{ &hf_cmp_tcptrans_type,\r\n{ "Type", "cmp.tcptrans.type",\r\nFT_UINT8, BASE_DEC, VALS(cmp_pdu_types), 0,\r\n"TCP transport PDU Type", HFILL }},\r\n{ &hf_cmp_tcptrans_poll_ref,\r\n{ "Polling Reference", "cmp.tcptrans.poll_ref",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"TCP transport Polling Reference", HFILL }},\r\n{ &hf_cmp_tcptrans_next_poll_ref,\r\n{ "Next Polling Reference", "cmp.tcptrans.next_poll_ref",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"TCP transport Next Polling Reference", HFILL }},\r\n{ &hf_cmp_tcptrans_ttcb,\r\n{ "Time to check Back", "cmp.tcptrans.ttcb",\r\nFT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0,\r\n"TCP transport Time to check Back", HFILL }},\r\n{ &hf_cmp_tcptrans10_version,\r\n{ "Version", "cmp.tcptrans10.version",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"TCP transport version", HFILL }},\r\n{ &hf_cmp_tcptrans10_flags,\r\n{ "Flags", "cmp.tcptrans10.flags",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"TCP transport flags", HFILL }},\r\n#include "packet-cmp-hfarr.c"\r\n};\r\nstatic gint *ett[] = {\r\n&ett_cmp,\r\n#include "packet-cmp-ettarr.c"\r\n};\r\nmodule_t *cmp_module;\r\nproto_cmp = proto_register_protocol(PNAME, PSNAME, PFNAME);\r\nproto_register_field_array(proto_cmp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\ncmp_module = prefs_register_protocol(proto_cmp, proto_reg_handoff_cmp);\r\nprefs_register_bool_preference(cmp_module, "desegment",\r\n"Reassemble CMP-over-TCP messages spanning multiple TCP segments",\r\n"Whether the CMP-over-TCP dissector should reassemble messages spanning multiple TCP segments. "\r\n"To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&cmp_desegment);\r\nprefs_register_uint_preference(cmp_module, "tcp_alternate_port",\r\n"Alternate TCP port",\r\n"Decode this TCP port\'s traffic as CMP. Set to \"0\" to disable.",\r\n10,\r\n&cmp_alternate_tcp_port);\r\nprefs_register_uint_preference(cmp_module, "http_alternate_port",\r\n"Alternate HTTP port",\r\n"Decode this TCP port\'s traffic as CMP-over-HTTP. Set to \"0\" to disable. "\r\n"Use this if the Content-Type is not set correctly.",\r\n10,\r\n&cmp_alternate_http_port);\r\nprefs_register_uint_preference(cmp_module, "tcp_style_http_alternate_port",\r\n"Alternate TCP-style-HTTP port",\r\n"Decode this TCP port\'s traffic as TCP-transport-style CMP-over-HTTP. Set to \"0\" to disable. "\r\n"Use this if the Content-Type is not set correctly.",\r\n10,\r\n&cmp_alternate_tcp_style_http_port);\r\n}\r\nvoid proto_reg_handoff_cmp(void) {\r\nstatic gboolean inited = FALSE;\r\nstatic dissector_handle_t cmp_http_handle;\r\nstatic dissector_handle_t cmp_tcp_style_http_handle;\r\nstatic dissector_handle_t cmp_tcp_handle;\r\nstatic guint cmp_alternate_tcp_port_prev = 0;\r\nstatic guint cmp_alternate_http_port_prev = 0;\r\nstatic guint cmp_alternate_tcp_style_http_port_prev = 0;\r\nif (!inited) {\r\ncmp_http_handle = create_dissector_handle(dissect_cmp_http, proto_cmp);\r\ndissector_add_string("media_type", "application/pkixcmp", cmp_http_handle);\r\ndissector_add_string("media_type", "application/x-pkixcmp", cmp_http_handle);\r\ncmp_tcp_style_http_handle = create_dissector_handle(dissect_cmp_tcp_pdu, proto_cmp);\r\ndissector_add_string("media_type", "application/pkixcmp-poll", cmp_tcp_style_http_handle);\r\ndissector_add_string("media_type", "application/x-pkixcmp-poll", cmp_tcp_style_http_handle);\r\ncmp_tcp_handle = create_dissector_handle(dissect_cmp_tcp, proto_cmp);\r\ndissector_add_uint("tcp.port", TCP_PORT_CMP, cmp_tcp_handle);\r\noid_add_from_string("Cryptlib-presence-check","1.3.6.1.4.1.3029.3.1.1");\r\noid_add_from_string("Cryptlib-PKIBoot","1.3.6.1.4.1.3029.3.1.2");\r\noid_add_from_string("HMAC MD5","1.3.6.1.5.5.8.1.1");\r\noid_add_from_string("HMAC SHA-1","1.3.6.1.5.5.8.1.2");\r\noid_add_from_string("HMAC TIGER","1.3.6.1.5.5.8.1.3");\r\noid_add_from_string("HMAC RIPEMD-160","1.3.6.1.5.5.8.1.4");\r\n#include "packet-cmp-dis-tab.c"\r\ninited = TRUE;\r\n}\r\nif (cmp_alternate_tcp_port != cmp_alternate_tcp_port_prev) {\r\nif (cmp_alternate_tcp_port_prev != 0)\r\ndissector_delete_uint("tcp.port", cmp_alternate_tcp_port_prev, cmp_tcp_handle);\r\nif (cmp_alternate_tcp_port != 0)\r\ndissector_add_uint("tcp.port", cmp_alternate_tcp_port, cmp_tcp_handle);\r\ncmp_alternate_tcp_port_prev = cmp_alternate_tcp_port;\r\n}\r\nif (cmp_alternate_http_port != cmp_alternate_http_port_prev) {\r\nif (cmp_alternate_http_port_prev != 0) {\r\ndissector_delete_uint("tcp.port", cmp_alternate_http_port_prev, NULL);\r\ndissector_delete_uint("http.port", cmp_alternate_http_port_prev, NULL);\r\n}\r\nif (cmp_alternate_http_port != 0)\r\nhttp_tcp_dissector_add( cmp_alternate_http_port, cmp_http_handle);\r\ncmp_alternate_http_port_prev = cmp_alternate_http_port;\r\n}\r\nif (cmp_alternate_tcp_style_http_port != cmp_alternate_tcp_style_http_port_prev) {\r\nif (cmp_alternate_tcp_style_http_port_prev != 0) {\r\ndissector_delete_uint("tcp.port", cmp_alternate_tcp_style_http_port_prev, NULL);\r\ndissector_delete_uint("http.port", cmp_alternate_tcp_style_http_port_prev, NULL);\r\n}\r\nif (cmp_alternate_tcp_style_http_port != 0)\r\nhttp_tcp_dissector_add( cmp_alternate_tcp_style_http_port, cmp_tcp_style_http_handle);\r\ncmp_alternate_tcp_style_http_port_prev = cmp_alternate_tcp_style_http_port;\r\n}\r\n}
