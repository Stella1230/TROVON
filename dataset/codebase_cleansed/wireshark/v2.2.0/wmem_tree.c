static wmem_tree_node_t *\r\nnode_uncle(wmem_tree_node_t *node)\r\n{\r\nwmem_tree_node_t *parent, *grandparent;\r\nparent = node->parent;\r\nif (parent == NULL) {\r\nreturn NULL;\r\n}\r\ngrandparent = parent->parent;\r\nif (grandparent == NULL) {\r\nreturn NULL;\r\n}\r\nif (parent == grandparent->left) {\r\nreturn grandparent->right;\r\n}\r\nelse {\r\nreturn grandparent->left;\r\n}\r\n}\r\nstatic void\r\nrotate_left(wmem_tree_t *tree, wmem_tree_node_t *node)\r\n{\r\nif (node->parent) {\r\nif (node->parent->left == node) {\r\nnode->parent->left = node->right;\r\n}\r\nelse {\r\nnode->parent->right = node->right;\r\n}\r\n}\r\nelse {\r\ntree->root = node->right;\r\n}\r\nnode->right->parent = node->parent;\r\nnode->parent = node->right;\r\nnode->right = node->right->left;\r\nif (node->right) {\r\nnode->right->parent = node;\r\n}\r\nnode->parent->left = node;\r\nif (tree->post_rotation_cb) {\r\ntree->post_rotation_cb (node);\r\n}\r\n}\r\nstatic void\r\nrotate_right(wmem_tree_t *tree, wmem_tree_node_t *node)\r\n{\r\nif (node->parent) {\r\nif (node->parent->left == node) {\r\nnode->parent->left = node->left;\r\n}\r\nelse {\r\nnode->parent->right = node->left;\r\n}\r\n}\r\nelse {\r\ntree->root = node->left;\r\n}\r\nnode->left->parent = node->parent;\r\nnode->parent = node->left;\r\nnode->left = node->left->right;\r\nif (node->left) {\r\nnode->left->parent = node;\r\n}\r\nnode->parent->right = node;\r\nif (tree->post_rotation_cb) {\r\ntree->post_rotation_cb (node);\r\n}\r\n}\r\nstatic void\r\nrb_insert_case5(wmem_tree_t *tree, wmem_tree_node_t *node)\r\n{\r\nwmem_tree_node_t *parent, *grandparent;\r\nparent = node->parent;\r\ngrandparent = parent->parent;\r\nparent->color = WMEM_NODE_COLOR_BLACK;\r\ngrandparent->color = WMEM_NODE_COLOR_RED;\r\nif (node == parent->left && parent == grandparent->left) {\r\nrotate_right(tree, grandparent);\r\n}\r\nelse {\r\nrotate_left(tree, grandparent);\r\n}\r\n}\r\nstatic void\r\nrb_insert_case4(wmem_tree_t *tree, wmem_tree_node_t *node)\r\n{\r\nwmem_tree_node_t *parent, *grandparent;\r\nparent = node->parent;\r\ngrandparent = parent->parent;\r\nif (!grandparent) {\r\nreturn;\r\n}\r\nif (node == parent->right && parent == grandparent->left) {\r\nrotate_left(tree, parent);\r\nnode = node->left;\r\n}\r\nelse if (node == parent->left && parent == grandparent->right) {\r\nrotate_right(tree, parent);\r\nnode = node->right;\r\n}\r\nrb_insert_case5(tree, node);\r\n}\r\nstatic void\r\nrb_insert_case3(wmem_tree_t *tree, wmem_tree_node_t *node)\r\n{\r\nwmem_tree_node_t *parent, *grandparent, *uncle;\r\nuncle = node_uncle(node);\r\nif (uncle && uncle->color == WMEM_NODE_COLOR_RED) {\r\nparent = node->parent;\r\ngrandparent = parent->parent;\r\nparent->color = WMEM_NODE_COLOR_BLACK;\r\nuncle->color = WMEM_NODE_COLOR_BLACK;\r\ngrandparent->color = WMEM_NODE_COLOR_RED;\r\nrb_insert_case1(tree, grandparent);\r\n}\r\nelse {\r\nrb_insert_case4(tree, node);\r\n}\r\n}\r\nstatic void\r\nrb_insert_case2(wmem_tree_t *tree, wmem_tree_node_t *node)\r\n{\r\nif (node->parent->color == WMEM_NODE_COLOR_RED) {\r\nrb_insert_case3(tree, node);\r\n}\r\n}\r\nstatic void\r\nrb_insert_case1(wmem_tree_t *tree, wmem_tree_node_t *node)\r\n{\r\nwmem_tree_node_t *parent = node->parent;\r\nif (parent == NULL) {\r\nnode->color = WMEM_NODE_COLOR_BLACK;\r\n}\r\nelse {\r\nrb_insert_case2(tree, node);\r\n}\r\n}\r\nwmem_tree_t *\r\nwmem_tree_new(wmem_allocator_t *allocator)\r\n{\r\nwmem_tree_t *tree;\r\ntree = wmem_new(allocator, wmem_tree_t);\r\ntree->master = allocator;\r\ntree->allocator = allocator;\r\ntree->root = NULL;\r\ntree->post_rotation_cb = NULL;\r\nreturn tree;\r\n}\r\nstatic gboolean\r\nwmem_tree_reset_cb(wmem_allocator_t *allocator _U_, wmem_cb_event_t event,\r\nvoid *user_data)\r\n{\r\nwmem_tree_t *tree = (wmem_tree_t *)user_data;\r\ntree->root = NULL;\r\nif (event == WMEM_CB_DESTROY_EVENT) {\r\nwmem_unregister_callback(tree->master, tree->master_cb_id);\r\nwmem_free(tree->master, tree);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nwmem_tree_destroy_cb(wmem_allocator_t *allocator _U_, wmem_cb_event_t event _U_,\r\nvoid *user_data)\r\n{\r\nwmem_tree_t *tree = (wmem_tree_t *)user_data;\r\nwmem_unregister_callback(tree->allocator, tree->slave_cb_id);\r\nreturn FALSE;\r\n}\r\nwmem_tree_t *\r\nwmem_tree_new_autoreset(wmem_allocator_t *master, wmem_allocator_t *slave)\r\n{\r\nwmem_tree_t *tree;\r\ntree = wmem_new(master, wmem_tree_t);\r\ntree->master = master;\r\ntree->allocator = slave;\r\ntree->root = NULL;\r\ntree->post_rotation_cb = NULL;\r\ntree->master_cb_id = wmem_register_callback(master, wmem_tree_destroy_cb,\r\ntree);\r\ntree->slave_cb_id = wmem_register_callback(slave, wmem_tree_reset_cb,\r\ntree);\r\nreturn tree;\r\n}\r\ngboolean\r\nwmem_tree_is_empty(wmem_tree_t *tree)\r\n{\r\nreturn tree->root == NULL;\r\n}\r\nstatic wmem_tree_node_t *\r\ncreate_node(wmem_allocator_t *allocator, wmem_tree_node_t *parent, const void *key,\r\nvoid *data, wmem_node_color_t color, gboolean is_subtree)\r\n{\r\nwmem_tree_node_t *node;\r\nnode = wmem_new(allocator, wmem_tree_node_t);\r\nnode->left = NULL;\r\nnode->right = NULL;\r\nnode->parent = parent;\r\nnode->key = key;\r\nnode->data = data;\r\nnode->color = color;\r\nnode->is_subtree = is_subtree;\r\nnode->is_removed = FALSE;\r\nreturn node;\r\n}\r\nstatic wmem_tree_node_t *\r\nlookup_or_insert32_node(wmem_tree_t *tree, guint32 key,\r\nvoid*(*func)(void*), void* data, gboolean is_subtree, gboolean replace)\r\n{\r\nwmem_tree_node_t *node = tree->root;\r\nwmem_tree_node_t *new_node = NULL;\r\nif (!node) {\r\nnew_node = create_node(tree->allocator, NULL, GUINT_TO_POINTER(key),\r\nCREATE_DATA(func, data), WMEM_NODE_COLOR_BLACK, is_subtree);\r\ntree->root = new_node;\r\nreturn new_node;\r\n}\r\nwhile (!new_node) {\r\nif (key == GPOINTER_TO_UINT(node->key)) {\r\nif (replace) {\r\nnode->data = CREATE_DATA(func, data);\r\n}\r\nreturn node;\r\n}\r\nelse if (key < GPOINTER_TO_UINT(node->key)) {\r\nif (node->left) {\r\nnode = node->left;\r\n}\r\nelse {\r\nnew_node = create_node(tree->allocator, node, GUINT_TO_POINTER(key),\r\nCREATE_DATA(func, data), WMEM_NODE_COLOR_RED,\r\nis_subtree);\r\nnode->left = new_node;\r\n}\r\n}\r\nelse if (key > GPOINTER_TO_UINT(node->key)) {\r\nif (node->right) {\r\nnode = node->right;\r\n}\r\nelse {\r\nnew_node = create_node(tree->allocator, node, GUINT_TO_POINTER(key),\r\nCREATE_DATA(func, data), WMEM_NODE_COLOR_RED,\r\nis_subtree);\r\nnode->right = new_node;\r\n}\r\n}\r\n}\r\nrb_insert_case1(tree, new_node);\r\nreturn new_node;\r\n}\r\nstatic void *\r\nlookup_or_insert32(wmem_tree_t *tree, guint32 key,\r\nvoid*(*func)(void*), void* data, gboolean is_subtree, gboolean replace)\r\n{\r\nwmem_tree_node_t *node = lookup_or_insert32_node(tree, key, func, data, is_subtree, replace);\r\nreturn node->data;\r\n}\r\nstatic void *\r\nwmem_tree_lookup(wmem_tree_t *tree, const void *key, compare_func cmp)\r\n{\r\nwmem_tree_node_t *node;\r\nif (tree == NULL || key == NULL) {\r\nreturn NULL;\r\n}\r\nnode = tree->root;\r\nwhile (node) {\r\nint result = cmp(key, node->key);\r\nif (result == 0) {\r\nreturn node->data;\r\n}\r\nelse if (result < 0) {\r\nnode = node->left;\r\n}\r\nelse if (result > 0) {\r\nnode = node->right;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nwmem_tree_node_t *\r\nwmem_tree_insert(wmem_tree_t *tree, const void *key, void *data, compare_func cmp)\r\n{\r\nwmem_tree_node_t *node = tree->root;\r\nwmem_tree_node_t *new_node = NULL;\r\nif (!node) {\r\ntree->root = create_node(tree->allocator, node, key,\r\ndata, WMEM_NODE_COLOR_BLACK, FALSE);\r\nreturn tree->root;\r\n}\r\nwhile (!new_node) {\r\nint result = cmp(key, node->key);\r\nif (result == 0) {\r\nnode->data = data;\r\nnode->is_removed = data ? FALSE : TRUE;\r\nreturn node;\r\n}\r\nelse if (result < 0) {\r\nif (node->left) {\r\nnode = node->left;\r\n}\r\nelse {\r\nnew_node = create_node(tree->allocator, node, key,\r\ndata, WMEM_NODE_COLOR_RED, FALSE);\r\nnode->left = new_node;\r\n}\r\n}\r\nelse if (result > 0) {\r\nif (node->right) {\r\nnode = node->right;\r\n}\r\nelse {\r\nnew_node = create_node(tree->allocator, node, key,\r\ndata, WMEM_NODE_COLOR_RED, FALSE);\r\nnode->right = new_node;\r\n}\r\n}\r\n}\r\nrb_insert_case1(tree, new_node);\r\nreturn new_node;\r\n}\r\nvoid\r\nwmem_tree_insert32(wmem_tree_t *tree, guint32 key, void *data)\r\n{\r\nlookup_or_insert32(tree, key, NULL, data, FALSE, TRUE);\r\n}\r\nvoid *\r\nwmem_tree_lookup32(wmem_tree_t *tree, guint32 key)\r\n{\r\nwmem_tree_node_t *node = tree->root;\r\nwhile (node) {\r\nif (key == GPOINTER_TO_UINT(node->key)) {\r\nreturn node->data;\r\n}\r\nelse if (key < GPOINTER_TO_UINT(node->key)) {\r\nnode = node->left;\r\n}\r\nelse if (key > GPOINTER_TO_UINT(node->key)) {\r\nnode = node->right;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nvoid *\r\nwmem_tree_lookup32_le(wmem_tree_t *tree, guint32 key)\r\n{\r\nwmem_tree_node_t *node = tree->root;\r\nwhile (node) {\r\nif (key == GPOINTER_TO_UINT(node->key)) {\r\nreturn node->data;\r\n}\r\nelse if (key < GPOINTER_TO_UINT(node->key)) {\r\nif (node->left == NULL) {\r\nbreak;\r\n}\r\nnode = node->left;\r\n}\r\nelse if (key > GPOINTER_TO_UINT(node->key)) {\r\nif (node->right == NULL) {\r\nbreak;\r\n}\r\nnode = node->right;\r\n}\r\n}\r\nif (!node) {\r\nreturn NULL;\r\n}\r\nif (node->parent == NULL) {\r\nif (key > GPOINTER_TO_UINT(node->key)) {\r\nreturn node->data;\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nif (GPOINTER_TO_UINT(node->key) <= key) {\r\nreturn node->data;\r\n}\r\nelse if (node == node->parent->left) {\r\nwhile (node) {\r\nif (key > GPOINTER_TO_UINT(node->key)) {\r\nreturn node->data;\r\n}\r\nnode=node->parent;\r\n}\r\nreturn NULL;\r\n}\r\nelse {\r\nreturn node->parent->data;\r\n}\r\n}\r\nvoid\r\nwmem_tree_insert_string(wmem_tree_t* tree, const gchar* k, void* v, guint32 flags)\r\n{\r\nchar *key;\r\ncompare_func cmp;\r\nkey = wmem_strdup(tree->allocator, k);\r\nif (flags & WMEM_TREE_STRING_NOCASE) {\r\ncmp = (compare_func)g_ascii_strcasecmp;\r\n} else {\r\ncmp = (compare_func)strcmp;\r\n}\r\nwmem_tree_insert(tree, key, v, cmp);\r\n}\r\nvoid *\r\nwmem_tree_lookup_string(wmem_tree_t* tree, const gchar* k, guint32 flags)\r\n{\r\ncompare_func cmp;\r\nif (flags & WMEM_TREE_STRING_NOCASE) {\r\ncmp = (compare_func)g_ascii_strcasecmp;\r\n} else {\r\ncmp = (compare_func)strcmp;\r\n}\r\nreturn wmem_tree_lookup(tree, k, cmp);\r\n}\r\nvoid *\r\nwmem_tree_remove_string(wmem_tree_t* tree, const gchar* k, guint32 flags)\r\n{\r\nvoid *ret = wmem_tree_lookup_string(tree, k, flags);\r\nif (ret) {\r\nwmem_tree_insert_string(tree, k, NULL, flags);\r\n}\r\nreturn ret;\r\n}\r\nstatic void *\r\ncreate_sub_tree(void* d)\r\n{\r\nreturn wmem_tree_new(((wmem_tree_t *)d)->allocator);\r\n}\r\nvoid\r\nwmem_tree_insert32_array(wmem_tree_t *tree, wmem_tree_key_t *key, void *data)\r\n{\r\nwmem_tree_t *insert_tree = NULL;\r\nwmem_tree_key_t *cur_key;\r\nguint32 i, insert_key32 = 0;\r\nfor (cur_key = key; cur_key->length > 0; cur_key++) {\r\nfor (i = 0; i < cur_key->length; i++) {\r\nif (!insert_tree) {\r\ninsert_tree = tree;\r\n} else {\r\ninsert_tree = (wmem_tree_t *)lookup_or_insert32(insert_tree,\r\ninsert_key32, create_sub_tree, tree, TRUE, FALSE);\r\n}\r\ninsert_key32 = cur_key->key[i];\r\n}\r\n}\r\ng_assert(insert_tree);\r\nwmem_tree_insert32(insert_tree, insert_key32, data);\r\n}\r\nstatic void *\r\nwmem_tree_lookup32_array_helper(wmem_tree_t *tree, wmem_tree_key_t *key,\r\nvoid*(*helper)(wmem_tree_t*, guint32))\r\n{\r\nwmem_tree_t *lookup_tree = NULL;\r\nwmem_tree_key_t *cur_key;\r\nguint32 i, lookup_key32 = 0;\r\nif (!tree || !key) {\r\nreturn NULL;\r\n}\r\nfor (cur_key = key; cur_key->length > 0; cur_key++) {\r\nfor (i = 0; i < cur_key->length; i++) {\r\nif (!lookup_tree) {\r\nlookup_tree = tree;\r\n}\r\nelse {\r\nlookup_tree =\r\n(wmem_tree_t *)(*helper)(lookup_tree, lookup_key32);\r\nif (!lookup_tree) {\r\nreturn NULL;\r\n}\r\n}\r\nlookup_key32 = cur_key->key[i];\r\n}\r\n}\r\ng_assert(lookup_tree);\r\nreturn (*helper)(lookup_tree, lookup_key32);\r\n}\r\nvoid *\r\nwmem_tree_lookup32_array(wmem_tree_t *tree, wmem_tree_key_t *key)\r\n{\r\nreturn wmem_tree_lookup32_array_helper(tree, key, wmem_tree_lookup32);\r\n}\r\nvoid *\r\nwmem_tree_lookup32_array_le(wmem_tree_t *tree, wmem_tree_key_t *key)\r\n{\r\nreturn wmem_tree_lookup32_array_helper(tree, key, wmem_tree_lookup32_le);\r\n}\r\nstatic gboolean\r\nwmem_tree_foreach_nodes(wmem_tree_node_t* node, wmem_foreach_func callback,\r\nvoid *user_data)\r\n{\r\ngboolean stop_traverse = FALSE;\r\nif (!node) {\r\nreturn FALSE;\r\n}\r\nif (node->left) {\r\nif (wmem_tree_foreach_nodes(node->left, callback, user_data)) {\r\nreturn TRUE;\r\n}\r\n}\r\nif (node->is_subtree) {\r\nstop_traverse = wmem_tree_foreach((wmem_tree_t *)node->data,\r\ncallback, user_data);\r\n} else if (!node->is_removed) {\r\nstop_traverse = callback(node->key, node->data, user_data);\r\n}\r\nif (stop_traverse) {\r\nreturn TRUE;\r\n}\r\nif(node->right) {\r\nif (wmem_tree_foreach_nodes(node->right, callback, user_data)) {\r\nreturn TRUE;\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\ngboolean\r\nwmem_tree_foreach(wmem_tree_t* tree, wmem_foreach_func callback,\r\nvoid *user_data)\r\n{\r\nif(!tree->root)\r\nreturn FALSE;\r\nreturn wmem_tree_foreach_nodes(tree->root, callback, user_data);\r\n}\r\nstatic void\r\nwmem_print_indent(guint32 level) {\r\nguint32 i;\r\nfor (i=0; i<level; i++) {\r\nprintf(" ");\r\n}\r\n}\r\nstatic void\r\nwmem_tree_print_nodes(const char *prefix, wmem_tree_node_t *node, guint32 level,\r\nwmem_printer_func key_printer, wmem_printer_func data_printer)\r\n{\r\nif (!node)\r\nreturn;\r\nwmem_print_indent(level);\r\nprintf("%sNODE:%p parent:%p left:%p right:%p colour:%s key:%p %s:%p\n",\r\nprefix,\r\n(void *)node, (void *)node->parent,\r\n(void *)node->left, (void *)node->right,\r\nnode->color?"Black":"Red", node->key,\r\nnode->is_subtree?"tree":"data", node->data);\r\nif(key_printer) {\r\nwmem_print_indent(level);\r\nkey_printer(node->key);\r\nprintf("\n");\r\n}\r\nif(data_printer) {\r\nwmem_print_indent(level);\r\ndata_printer(node->data);\r\nprintf("\n");\r\n}\r\nif (node->left)\r\nwmem_tree_print_nodes("L-", node->left, level+1, key_printer, data_printer);\r\nif (node->right)\r\nwmem_tree_print_nodes("R-", node->right, level+1, key_printer, data_printer);\r\nif (node->is_subtree)\r\nwmem_print_subtree((wmem_tree_t *)node->data, level+1, key_printer, data_printer);\r\n}\r\nstatic void\r\nwmem_print_subtree(wmem_tree_t *tree, guint32 level, wmem_printer_func key_printer, wmem_printer_func data_printer)\r\n{\r\nif (!tree)\r\nreturn;\r\nwmem_print_indent(level);\r\nprintf("WMEM tree:%p root:%p\n", (void *)tree, (void *)tree->root);\r\nif (tree->root) {\r\nwmem_tree_print_nodes("Root-", tree->root, level, key_printer, data_printer);\r\n}\r\n}\r\nvoid\r\nwmem_print_tree(wmem_tree_t *tree, wmem_printer_func key_printer, wmem_printer_func data_printer)\r\n{\r\nwmem_print_subtree(tree, 0, key_printer, data_printer);\r\n}
