seq_analysis_info_t *\r\nsequence_analysis_info_new(void)\r\n{\r\nseq_analysis_info_t *sainfo = g_new0(seq_analysis_info_t, 1);\r\nsainfo->items = g_queue_new();\r\nsainfo->ht= g_hash_table_new(g_int_hash, g_int_equal);\r\nreturn sainfo;\r\n}\r\nvoid sequence_analysis_info_free(seq_analysis_info_t *sainfo)\r\n{\r\nif (!sainfo) return;\r\nsequence_analysis_list_free(sainfo);\r\ng_queue_free(sainfo->items);\r\ng_hash_table_destroy(sainfo->ht);\r\ng_free(sainfo);\r\n}\r\nstatic gboolean\r\nseq_analysis_frame_packet( void *ptr, packet_info *pinfo, epan_dissect_t *edt _U_, const void *dummy _U_)\r\n{\r\nseq_analysis_info_t *sainfo = (seq_analysis_info_t *) ptr;\r\ncol_item_t* col_item;\r\nif ((sainfo->all_packets)||(pinfo->fd->flags.passed_dfilter==1)){\r\nint i;\r\ngchar *protocol = NULL;\r\ngchar *colinfo = NULL;\r\nseq_analysis_item_t *sai = NULL;\r\nicmp_info_t *p_icmp_info;\r\nif (sainfo->any_addr) {\r\nif (pinfo->net_src.type!=AT_NONE && pinfo->net_dst.type!=AT_NONE) {\r\nsai = (seq_analysis_item_t *)g_malloc0(sizeof(seq_analysis_item_t));\r\ncopy_address(&(sai->src_addr),&(pinfo->net_src));\r\ncopy_address(&(sai->dst_addr),&(pinfo->net_dst));\r\n}\r\n} else {\r\nif (pinfo->src.type!=AT_NONE && pinfo->dst.type!=AT_NONE) {\r\nsai = (seq_analysis_item_t *)g_malloc0(sizeof(seq_analysis_item_t));\r\ncopy_address(&(sai->src_addr),&(pinfo->src));\r\ncopy_address(&(sai->dst_addr),&(pinfo->dst));\r\n}\r\n}\r\nif (!sai) return FALSE;\r\nsai->frame_number = pinfo->num;\r\nif (pinfo->fd->color_filter) {\r\nsai->bg_color = color_t_to_rgb(&pinfo->fd->color_filter->bg_color);\r\nsai->fg_color = color_t_to_rgb(&pinfo->fd->color_filter->fg_color);\r\n}\r\nsai->port_src=pinfo->srcport;\r\nsai->port_dst=pinfo->destport;\r\nsai->protocol = g_strdup(port_type_to_str(pinfo->ptype));\r\nif(pinfo->cinfo) {\r\nif (pinfo->cinfo->col_first[COL_INFO]>=0){\r\nfor (i = pinfo->cinfo->col_first[COL_INFO]; i <= pinfo->cinfo->col_last[COL_INFO]; i++) {\r\ncol_item = &pinfo->cinfo->columns[i];\r\nif (col_item->fmt_matx[COL_INFO]) {\r\ncolinfo = g_strdup(col_item->col_data);\r\n}\r\n}\r\n}\r\nif (pinfo->cinfo->col_first[COL_PROTOCOL]>=0){\r\nfor (i = pinfo->cinfo->col_first[COL_PROTOCOL]; i <= pinfo->cinfo->col_last[COL_PROTOCOL]; i++) {\r\ncol_item = &pinfo->cinfo->columns[i];\r\nif (col_item->fmt_matx[COL_PROTOCOL]) {\r\nprotocol = g_strdup(col_item->col_data);\r\n}\r\n}\r\n}\r\n}\r\nif (colinfo != NULL) {\r\nsai->frame_label = g_strdup(colinfo);\r\nif (protocol != NULL) {\r\nsai->comment = g_strdup_printf("%s: %s", protocol, colinfo);\r\n} else {\r\nsai->comment = g_strdup(colinfo);\r\n}\r\n} else {\r\nif (protocol != NULL) {\r\nsai->frame_label = g_strdup(protocol);\r\nsai->comment = g_strdup(protocol);\r\n}\r\n}\r\nif (pinfo->ptype == PT_NONE) {\r\nif ((p_icmp_info = (icmp_info_t *)p_get_proto_data(wmem_file_scope(),\r\npinfo, proto_get_id_by_short_name("ICMP"), 0)) != NULL) {\r\ng_free(sai->protocol);\r\nsai->protocol = g_strdup("ICMP");\r\nsai->port_src = 0;\r\nsai->port_dst = p_icmp_info->type * 256 + p_icmp_info->code;\r\n} else if ((p_icmp_info = (icmp_info_t *)p_get_proto_data(wmem_file_scope(),\r\npinfo, proto_get_id_by_short_name("ICMPv6"), 0)) != NULL) {\r\ng_free(sai->protocol);\r\nsai->protocol = g_strdup("ICMPv6");\r\nsai->port_src = 0;\r\nsai->port_dst = p_icmp_info->type * 256 + p_icmp_info->code;\r\n}\r\n}\r\ng_free(protocol);\r\ng_free(colinfo);\r\nsai->line_style=1;\r\nsai->conv_num=0;\r\nsai->display=TRUE;\r\ng_queue_push_tail(sainfo->items, sai);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nseq_analysis_tcp_packet( void *ptr, packet_info *pinfo, epan_dissect_t *edt _U_, const void *tcp_info)\r\n{\r\nseq_analysis_info_t *sainfo = (seq_analysis_info_t *) ptr;\r\nconst struct tcpheader *tcph = (const struct tcpheader *)tcp_info;\r\nif ((sainfo->all_packets)||(pinfo->fd->flags.passed_dfilter==1)){\r\nstatic const gchar *fstr[] = {"FIN", "SYN", "RST", "PSH", "ACK", "URG", "ECN", "CWR" };\r\nguint i, bpos;\r\ngboolean flags_found = FALSE;\r\ngchar flags[64];\r\nseq_analysis_item_t *sai;\r\nsai = (seq_analysis_item_t *)g_malloc0(sizeof(seq_analysis_item_t));\r\nsai->frame_number = pinfo->num;\r\nif (sainfo->any_addr) {\r\ncopy_address(&(sai->src_addr),&(pinfo->net_src));\r\ncopy_address(&(sai->dst_addr),&(pinfo->net_dst));\r\n} else {\r\ncopy_address(&(sai->src_addr),&(pinfo->src));\r\ncopy_address(&(sai->dst_addr),&(pinfo->dst));\r\n}\r\nsai->port_src=pinfo->srcport;\r\nsai->port_dst=pinfo->destport;\r\nsai->protocol=g_strdup(port_type_to_str(pinfo->ptype));\r\nflags[0] = '\0';\r\nfor (i = 0; i < 8; i++) {\r\nbpos = 1 << i;\r\nif (tcph->th_flags & bpos) {\r\nif (flags_found) {\r\ng_strlcat(flags, ", ", sizeof(flags));\r\n}\r\ng_strlcat(flags, fstr[i], sizeof(flags));\r\nflags_found = TRUE;\r\n}\r\n}\r\nif (flags[0] == '\0') {\r\ng_snprintf (flags, sizeof(flags), "<None>");\r\n}\r\nif ((tcph->th_have_seglen)&&(tcph->th_seglen!=0)){\r\nsai->frame_label = g_strdup_printf("%s - Len: %u",flags, tcph->th_seglen);\r\n}\r\nelse{\r\nsai->frame_label = g_strdup(flags);\r\n}\r\nif (tcph->th_flags & TH_ACK)\r\nsai->comment = g_strdup_printf("Seq = %u Ack = %u",tcph->th_seq, tcph->th_ack);\r\nelse\r\nsai->comment = g_strdup_printf("Seq = %u",tcph->th_seq);\r\nsai->line_style = 1;\r\nsai->conv_num = (guint16) tcph->th_stream;\r\nsai->display = TRUE;\r\ng_queue_push_tail(sainfo->items, sai);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic void sequence_analysis_item_set_timestamp(gpointer data, gpointer user_data)\r\n{\r\ngchar time_str[COL_MAX_LEN];\r\nseq_analysis_item_t *seq_item = (seq_analysis_item_t *)data;\r\nconst capture_file *cf = (const capture_file *)user_data;\r\nframe_data *fd = frame_data_sequence_find(cf->frames, seq_item->frame_number);\r\nset_fd_time(cf->epan, fd, time_str);\r\nseq_item->time_str = g_strdup(time_str);\r\n}\r\nvoid\r\nsequence_analysis_list_get(capture_file *cf, seq_analysis_info_t *sainfo)\r\n{\r\nif (!cf || !sainfo) return;\r\nswitch (sainfo->type) {\r\ncase SEQ_ANALYSIS_ANY:\r\nregister_tap_listener("frame", sainfo, NULL,\r\nTL_REQUIRES_COLUMNS,\r\nNULL,\r\nseq_analysis_frame_packet,\r\nNULL\r\n);\r\nbreak;\r\ncase SEQ_ANALYSIS_TCP:\r\nregister_tap_listener("tcp", sainfo, NULL,\r\n0,\r\nNULL,\r\nseq_analysis_tcp_packet,\r\nNULL\r\n);\r\nbreak;\r\ncase SEQ_ANALYSIS_VOIP:\r\ndefault:\r\nreturn;\r\n}\r\ncf_retap_packets(cf);\r\nremove_tap_listener(sainfo);\r\ng_queue_foreach(sainfo->items, sequence_analysis_item_set_timestamp, cf);\r\n}\r\nstatic void sequence_analysis_item_free(gpointer data)\r\n{\r\nseq_analysis_item_t *seq_item = (seq_analysis_item_t *)data;\r\ng_free(seq_item->frame_label);\r\ng_free(seq_item->time_str);\r\ng_free(seq_item->comment);\r\ng_free(seq_item->protocol);\r\nfree_address(&seq_item->src_addr);\r\nfree_address(&seq_item->dst_addr);\r\ng_free(data);\r\n}\r\nstatic gint\r\nsequence_analysis_sort_compare(gconstpointer a, gconstpointer b, gpointer user_data _U_)\r\n{\r\nconst seq_analysis_item_t *entry_a = (const seq_analysis_item_t *)a;\r\nconst seq_analysis_item_t *entry_b = (const seq_analysis_item_t *)b;\r\nif(entry_a->frame_number < entry_b->frame_number)\r\nreturn -1;\r\nif(entry_a->frame_number > entry_b->frame_number)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid\r\nsequence_analysis_list_sort(seq_analysis_info_t *sainfo)\r\n{\r\nif (!sainfo) return;\r\ng_queue_sort(sainfo->items, sequence_analysis_sort_compare, NULL);\r\n}\r\nvoid\r\nsequence_analysis_list_free(seq_analysis_info_t *sainfo)\r\n{\r\nint i;\r\nif (!sainfo) return;\r\n#if GLIB_CHECK_VERSION (2, 32, 0)\r\ng_queue_free_full(sainfo->items, sequence_analysis_item_free);\r\nsainfo->items = g_queue_new();\r\n#else\r\n{\r\nGList *list = g_queue_peek_nth_link(sainfo->items, 0);\r\nwhile (list)\r\n{\r\nsequence_analysis_item_free(list->data);\r\nlist = g_list_next(list);\r\n}\r\ng_queue_clear(sainfo->items);\r\n}\r\n#endif\r\nif (NULL != sainfo->ht) {\r\ng_hash_table_remove_all(sainfo->ht);\r\n}\r\nsainfo->nconv = 0;\r\nfor (i=0; i<MAX_NUM_NODES; i++) {\r\nfree_address(&sainfo->nodes[i]);\r\n}\r\nsainfo->num_nodes = 0;\r\n}\r\nstatic void enlarge_string(GString *gstr, guint32 length, char pad) {\r\ngsize i;\r\nfor (i = gstr->len; i < length; i++) {\r\ng_string_append_c(gstr, pad);\r\n}\r\n}\r\nstatic void overwrite (GString *gstr, char *text_to_insert, guint32 p1, guint32 p2) {\r\nglong len, ins_len;\r\ngsize pos;\r\ngchar *ins_str = NULL;\r\nif (p1 == p2)\r\nreturn;\r\nif (p1 > p2) {\r\npos = p2;\r\nlen = p1 - p2;\r\n}\r\nelse{\r\npos = p1;\r\nlen = p2 - p1;\r\n}\r\nins_len = g_utf8_strlen(text_to_insert, -1);\r\nif (len > ins_len) {\r\nlen = ins_len;\r\n} else if (len < ins_len) {\r\n#if GLIB_CHECK_VERSION(2,30,0)\r\nins_str = g_utf8_substring(text_to_insert, 0, len);\r\n#else\r\ngchar *end = g_utf8_offset_to_pointer(text_to_insert, len);\r\nins_str = g_strndup(text_to_insert, end - text_to_insert);\r\n#endif\r\n}\r\nif (!ins_str) ins_str = g_strdup(text_to_insert);\r\nif (pos > gstr->len)\r\npos = gstr->len;\r\ng_string_erase(gstr, pos, len);\r\ng_string_insert(gstr, pos, ins_str);\r\ng_free(ins_str);\r\n}\r\nstatic guint add_or_get_node(seq_analysis_info_t *sainfo, address *node) {\r\nguint i;\r\nif (node->type == AT_NONE) return NODE_OVERFLOW;\r\nfor (i=0; i<MAX_NUM_NODES && i < sainfo->num_nodes ; i++) {\r\nif ( cmp_address(&(sainfo->nodes[i]), node) == 0 ) return i;\r\n}\r\nif (i >= MAX_NUM_NODES) {\r\nreturn NODE_OVERFLOW;\r\n} else {\r\nsainfo->num_nodes++;\r\ncopy_address(&(sainfo->nodes[i]), node);\r\nreturn i;\r\n}\r\n}\r\nstatic void sequence_analysis_get_nodes_item_proc(gpointer data, gpointer user_data)\r\n{\r\nseq_analysis_item_t *gai = (seq_analysis_item_t *)data;\r\nstruct sainfo_counter *sc = (struct sainfo_counter *)user_data;\r\nif (gai->display) {\r\n(sc->num_items)++;\r\ngai->src_node = add_or_get_node(sc->sainfo, &(gai->src_addr));\r\ngai->dst_node = add_or_get_node(sc->sainfo, &(gai->dst_addr));\r\n}\r\n}\r\nint\r\nsequence_analysis_get_nodes(seq_analysis_info_t *sainfo)\r\n{\r\nstruct sainfo_counter sc = {sainfo, 0};\r\ng_queue_foreach(sainfo->items, sequence_analysis_get_nodes_item_proc, &sc);\r\nreturn sc.num_items;\r\n}\r\ngboolean\r\nsequence_analysis_dump_to_file(const char *pathname, seq_analysis_info_t *sainfo, capture_file *cf, unsigned int first_node)\r\n{\r\nguint32 i, display_items, display_nodes;\r\nguint32 start_position, end_position, item_width, header_length;\r\nseq_analysis_item_t *sai;\r\nframe_data *fd;\r\nguint16 first_conv_num = 0;\r\ngboolean several_convs = FALSE;\r\ngboolean first_packet = TRUE;\r\nGString *label_string, *empty_line, *separator_line, *tmp_str, *tmp_str2;\r\nconst char *empty_header;\r\nchar src_port[8], dst_port[8];\r\ngchar *time_str;\r\nGList *list;\r\nchar *addr_str;\r\nFILE *of;\r\nof = ws_fopen(pathname, "w");\r\nif (of==NULL) {\r\nopen_failure_alert_box(pathname, errno, TRUE);\r\nreturn FALSE;\r\n}\r\ntime_str = (gchar *)g_malloc(COL_MAX_LEN);\r\nlabel_string = g_string_new("");\r\nempty_line = g_string_new("");\r\nseparator_line = g_string_new("");\r\ntmp_str = g_string_new("");\r\ntmp_str2 = g_string_new("");\r\ndisplay_items = 0;\r\nlist = g_queue_peek_nth_link(sainfo->items, 0);\r\nwhile (list)\r\n{\r\nsai = (seq_analysis_item_t *)list->data;\r\nlist = g_list_next(list);\r\nif (!sai->display)\r\ncontinue;\r\ndisplay_items += 1;\r\nif (first_packet) {\r\nfirst_conv_num = sai->conv_num;\r\nfirst_packet = FALSE;\r\n}\r\nelse if (sai->conv_num != first_conv_num) {\r\nseveral_convs = TRUE;\r\n}\r\n}\r\nif (display_items == 0)\r\ngoto exit;\r\ndisplay_nodes = sainfo->num_nodes;\r\nif (several_convs) {\r\nfprintf(of, CONV_TIME_HEADER);\r\nempty_header = CONV_TIME_EMPTY_HEADER;\r\nheader_length = CONV_TIME_HEADER_LENGTH;\r\n}\r\nelse{\r\nfprintf(of, TIME_HEADER);\r\nempty_header = TIME_EMPTY_HEADER;\r\nheader_length = TIME_HEADER_LENGTH;\r\n}\r\nfor (i=0; i<display_nodes; i+=2) {\r\naddr_str = address_to_display(NULL, &(sainfo->nodes[i+first_node]));\r\ng_string_printf(label_string, "| %s", addr_str);\r\nwmem_free(NULL, addr_str);\r\nenlarge_string(label_string, NODE_CHARS_WIDTH*2, ' ');\r\nfprintf(of, "%s", label_string->str);\r\ng_string_printf(label_string, "| ");\r\nenlarge_string(label_string, NODE_CHARS_WIDTH, ' ');\r\ng_string_append(empty_line, label_string->str);\r\n}\r\nfprintf(of, "|\n%s", empty_header);\r\ng_string_printf(label_string, "| ");\r\nenlarge_string(label_string, NODE_CHARS_WIDTH, ' ');\r\nfprintf(of, "%s", label_string->str);\r\nfor (i=1; i<display_nodes; i+=2) {\r\naddr_str = address_to_display(NULL, &(sainfo->nodes[i+first_node]));\r\ng_string_printf(label_string, "| %s", addr_str);\r\nwmem_free(NULL, addr_str);\r\nif (label_string->len < NODE_CHARS_WIDTH)\r\n{\r\nenlarge_string(label_string, NODE_CHARS_WIDTH, ' ');\r\ng_string_append(label_string, "| ");\r\n}\r\nenlarge_string(label_string, NODE_CHARS_WIDTH*2, ' ');\r\nfprintf(of, "%s", label_string->str);\r\ng_string_printf(label_string, "| ");\r\nenlarge_string(label_string, NODE_CHARS_WIDTH, ' ');\r\ng_string_append(empty_line, label_string->str);\r\n}\r\nfprintf(of, "\n");\r\ng_string_append_c(empty_line, '|');\r\nenlarge_string(separator_line, (guint32) empty_line->len + header_length, '-');\r\nlist = g_queue_peek_nth_link(sainfo->items, 0);\r\nwhile (list)\r\n{\r\nsai = (seq_analysis_item_t *)list->data;\r\nlist = g_list_next(list);\r\nif (!sai->display)\r\ncontinue;\r\nstart_position = (sai->src_node-first_node)*NODE_CHARS_WIDTH+NODE_CHARS_WIDTH/2;\r\nend_position = (sai->dst_node-first_node)*NODE_CHARS_WIDTH+NODE_CHARS_WIDTH/2;\r\nif (start_position > end_position) {\r\nitem_width = start_position-end_position;\r\n}\r\nelse if (start_position < end_position) {\r\nitem_width = end_position-start_position;\r\n}\r\nelse{\r\nend_position = start_position+NODE_CHARS_WIDTH;\r\nitem_width = NODE_CHARS_WIDTH;\r\n}\r\nif (sai->conv_num != first_conv_num) {\r\nfprintf(of, "%s\n", separator_line->str);\r\nfirst_conv_num = sai->conv_num;\r\n}\r\nif (several_convs) {\r\ng_string_printf(label_string, "%i", sai->conv_num);\r\nenlarge_string(label_string, 5, ' ');\r\nfprintf(of, "%s", label_string->str);\r\n}\r\nfd = frame_data_sequence_find(cf->frames, sai->frame_number);\r\n#if 0\r\ng_string_printf(label_string, "|%.3f", nstime_to_sec(&fd->rel_ts));\r\n#endif\r\nset_fd_time(cf->epan, fd, time_str);\r\ng_string_printf(label_string, "|%s", time_str);\r\nenlarge_string(label_string, 10, ' ');\r\nfprintf(of, "%s", label_string->str);\r\ng_string_printf(tmp_str, "%s", empty_line->str);\r\noverwrite(tmp_str, sai->frame_label,\r\nstart_position,\r\nend_position\r\n);\r\nfprintf(of, "%s", tmp_str->str);\r\nfprintf(of, "%s\n", sai->comment);\r\nfprintf(of, "%s", empty_header);\r\ng_string_printf(tmp_str, "%s", empty_line->str);\r\ng_string_truncate(tmp_str2, 0);\r\nif (start_position<end_position) {\r\nenlarge_string(tmp_str2, item_width-2, '-');\r\ng_string_append_c(tmp_str2, '>');\r\n}\r\nelse{\r\ng_string_printf(tmp_str2, "<");\r\nenlarge_string(tmp_str2, item_width-1, '-');\r\n}\r\noverwrite(tmp_str, tmp_str2->str,\r\nstart_position,\r\nend_position\r\n);\r\ng_snprintf(src_port, sizeof(src_port), "(%i)", sai->port_src);\r\ng_snprintf(dst_port, sizeof(dst_port), "(%i)", sai->port_dst);\r\nif (start_position<end_position) {\r\noverwrite(tmp_str, src_port, start_position-9, start_position-1);\r\noverwrite(tmp_str, dst_port, end_position+1, end_position+9);\r\n}\r\nelse{\r\noverwrite(tmp_str, src_port, start_position+1, start_position+9);\r\noverwrite(tmp_str, dst_port, end_position-9, end_position+1);\r\n}\r\nfprintf(of, "%s\n", tmp_str->str);\r\n}\r\nexit:\r\ng_string_free(label_string, TRUE);\r\ng_string_free(empty_line, TRUE);\r\ng_string_free(separator_line, TRUE);\r\ng_string_free(tmp_str, TRUE);\r\ng_string_free(tmp_str2, TRUE);\r\ng_free(time_str);\r\nfclose (of);\r\nreturn TRUE;\r\n}
