static int\r\ndissect_rsh(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *rsh_tree=NULL;\r\nguchar *field_stringz;\r\ngint length;\r\nguint offset = 0;\r\nconversation_t *conversation;\r\nrsh_hash_entry_t *hash_info;\r\nconversation = find_or_create_conversation(pinfo);\r\nhash_info = (rsh_hash_entry_t *)conversation_get_proto_data(conversation, proto_rsh);\r\nif(!hash_info){\r\nhash_info = wmem_new(wmem_file_scope(), rsh_hash_entry_t);\r\nhash_info->first_packet_number = pinfo->num;\r\nhash_info->second_packet_number = 0;\r\nhash_info->third_packet_number = 0;\r\nhash_info->fourth_packet_number = 0;\r\nhash_info->state = WAIT_FOR_STDERR_PORT;\r\nhash_info->client_username=NULL;\r\nhash_info->server_username=NULL;\r\nhash_info->command=NULL;\r\nhash_info->first_packet_state = NONE;\r\nhash_info->second_packet_state = NONE;\r\nhash_info->third_packet_state = NONE;\r\nhash_info->fourth_packet_state = NONE;\r\nconversation_add_proto_data(conversation, proto_rsh, hash_info);\r\n}\r\nif(!hash_info->second_packet_number\r\n&& pinfo->num > hash_info->first_packet_number){\r\nhash_info->second_packet_number = pinfo->num;\r\n} else if(hash_info->second_packet_number\r\n&& !hash_info->third_packet_number\r\n&& pinfo->num > hash_info->second_packet_number) {\r\nhash_info->third_packet_number = pinfo->num;\r\n} else if(hash_info->third_packet_number\r\n&& !hash_info->fourth_packet_number\r\n&& pinfo->num > hash_info->third_packet_number) {\r\nhash_info->fourth_packet_number = pinfo->num;\r\n}\r\nif(pinfo->num == hash_info->first_packet_number){\r\nif(hash_info->first_packet_state == NONE){\r\nhash_info->first_packet_state = hash_info->state;\r\n} else {\r\nhash_info->state = hash_info->first_packet_state;\r\n}\r\n}\r\nif(pinfo->num == hash_info->second_packet_number){\r\nif(hash_info->second_packet_state == NONE){\r\nhash_info->second_packet_state = hash_info->state;\r\n} else {\r\nhash_info->state = hash_info->second_packet_state;\r\n}\r\n}\r\nif(pinfo->num == hash_info->third_packet_number){\r\nif(hash_info->third_packet_state == NONE){\r\nhash_info->third_packet_state = hash_info->state;\r\n} else {\r\nhash_info->state = hash_info->third_packet_state;\r\n}\r\n}\r\nif(pinfo->num == hash_info->fourth_packet_number){\r\nif(hash_info->fourth_packet_state == NONE){\r\nhash_info->fourth_packet_state = hash_info->state;\r\n} else {\r\nhash_info->state = hash_info->fourth_packet_state;\r\n}\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "RSH");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif(hash_info->client_username && preference_info_show_client_username == TRUE){\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Client username:%s ", hash_info->client_username);\r\n}\r\nif(hash_info->server_username && preference_info_show_server_username == TRUE){\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Server username:%s ", hash_info->server_username);\r\n}\r\nif(hash_info->command && preference_info_show_command == TRUE){\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Command:%s ", hash_info->command);\r\n}\r\nti = proto_tree_add_item(tree, proto_rsh, tvb, 0, -1, ENC_NA);\r\nrsh_tree = proto_item_add_subtree(ti, ett_rsh);\r\nif(tvb_find_guint8(tvb, tvb_captured_length(tvb)-1, 1, '\0') == -1){\r\nhash_info->state = WAIT_FOR_DATA;\r\n}\r\nif(hash_info->state == WAIT_FOR_STDERR_PORT\r\n&& tvb_reported_length_remaining(tvb, offset)){\r\nfield_stringz = tvb_get_stringz_enc(wmem_packet_scope(), tvb, offset, &length, ENC_ASCII);\r\nif(length == 1 || (isdigit_string(field_stringz)\r\n&& length <= RSH_STDERR_PORT_LEN)){\r\nproto_tree_add_string(rsh_tree, hf_rsh_stderr_port, tvb, offset, length, (gchar*)field_stringz);\r\nhash_info->state = WAIT_FOR_CLIENT_USERNAME;\r\n} else {\r\nhash_info->state = WAIT_FOR_DATA;\r\n}\r\noffset += length;\r\n}\r\nif(hash_info->state == WAIT_FOR_CLIENT_USERNAME\r\n&& tvb_reported_length_remaining(tvb, offset)){\r\nfield_stringz = tvb_get_stringz_enc(wmem_packet_scope(), tvb, offset, &length, ENC_ASCII);\r\nif(length != 1 && length <= RSH_CLIENT_USERNAME_LEN\r\n&& isprint_string(field_stringz)){\r\nproto_tree_add_string(rsh_tree, hf_rsh_client_username, tvb, offset, length, (gchar*)field_stringz);\r\nif(!hash_info->client_username){\r\nhash_info->client_username=wmem_strdup(wmem_file_scope(), (gchar*)field_stringz);\r\n}\r\nhash_info->state = WAIT_FOR_SERVER_USERNAME;\r\n} else {\r\nhash_info->state = WAIT_FOR_DATA;\r\n}\r\noffset += length;\r\n}\r\nif(hash_info->state == WAIT_FOR_SERVER_USERNAME\r\n&& tvb_reported_length_remaining(tvb, offset)){\r\nfield_stringz = tvb_get_stringz_enc(wmem_packet_scope(), tvb, offset, &length, ENC_ASCII);\r\nif(length != 1 && length <= RSH_SERVER_USERNAME_LEN\r\n&& isprint_string(field_stringz)){\r\nproto_tree_add_string(rsh_tree, hf_rsh_server_username, tvb, offset, length, (gchar*)field_stringz);\r\nif(!hash_info->server_username){\r\nhash_info->server_username=wmem_strdup(wmem_file_scope(), (gchar*)field_stringz);\r\n}\r\nhash_info->state = WAIT_FOR_COMMAND;\r\n} else {\r\nhash_info->state = WAIT_FOR_DATA;\r\n}\r\noffset += length;\r\nhash_info->state = WAIT_FOR_COMMAND;\r\n}\r\nif(hash_info->state == WAIT_FOR_COMMAND\r\n&& tvb_reported_length_remaining(tvb, offset)){\r\nfield_stringz = tvb_get_stringz_enc(wmem_packet_scope(), tvb, offset, &length, ENC_ASCII);\r\nif(length != 1 && length <= RSH_COMMAND_LEN\r\n&& isprint_string(field_stringz)){\r\nproto_tree_add_string(rsh_tree, hf_rsh_command, tvb, offset, length, (gchar*)field_stringz);\r\nif(!hash_info->command){\r\nhash_info->command=wmem_strdup(wmem_file_scope(), (gchar*)field_stringz);\r\n}\r\n} else {\r\nhash_info->state = WAIT_FOR_DATA;\r\n}\r\n}\r\nif(hash_info->state == WAIT_FOR_DATA\r\n&& tvb_reported_length_remaining(tvb, offset)){\r\nif(pinfo->destport == RSH_PORT){\r\nproto_tree_add_item(rsh_tree, hf_rsh_client_server_data, tvb, 0, -1, ENC_NA);\r\ncol_append_str(pinfo->cinfo, COL_INFO, "Client -> Server data");\r\n} else {\r\nproto_tree_add_item(rsh_tree, hf_rsh_server_client_data, tvb, 0, -1, ENC_NA);\r\ncol_append_str(pinfo->cinfo, COL_INFO, "Server -> Client Data");\r\n}\r\n}\r\nif(hash_info->state < WAIT_FOR_DATA){\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Session Establishment");\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_rsh(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_rsh_stderr_port, { "Stderr port (optional)", "rsh.stderr_port",\r\nFT_STRINGZ, BASE_NONE, NULL, 0,\r\n"Client port that is listening for stderr stream from server", HFILL } },\r\n{ &hf_rsh_client_username, { "Client username", "rsh.client_username",\r\nFT_STRINGZ, BASE_NONE, NULL, 0,\r\n"User's identity on the client machine", HFILL } },\r\n{ &hf_rsh_server_username, { "Server username", "rsh.server_username",\r\nFT_STRINGZ, BASE_NONE, NULL, 0,\r\n"User's identity on the server machine", HFILL } },\r\n{ &hf_rsh_command, { "Command to execute", "rsh.command",\r\nFT_STRINGZ, BASE_NONE, NULL, 0,\r\n"Command client is requesting the server to run", HFILL } },\r\n{ &hf_rsh_client_server_data, { "Client -> Server Data", "rsh.client_server_data",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL } },\r\n{ &hf_rsh_server_client_data, { "Server -> Client Data", "rsh.server_client_data",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL } },\r\n};\r\nstatic gint *ett[] =\r\n{\r\n&ett_rsh\r\n};\r\nmodule_t *rsh_module;\r\nproto_rsh = proto_register_protocol("Remote Shell", "RSH", "rsh");\r\nproto_register_field_array(proto_rsh, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nrsh_module = prefs_register_protocol(proto_rsh, NULL);\r\nprefs_register_bool_preference(rsh_module, "info_show_client_username",\r\n"Show client username in info column",\r\n"Controls the display of the session's client username in the info column. This is only displayed if the packet containing it was seen during this capture session.",\r\n&preference_info_show_client_username);\r\nprefs_register_bool_preference(rsh_module, "info_show_server_username",\r\n"Show server username in info column",\r\n"Controls the display of the session's server username in the info column. This is only displayed if the packet containing it was seen during this capture session.",\r\n&preference_info_show_server_username);\r\nprefs_register_bool_preference(rsh_module, "info_show_command",\r\n"Show command in info column",\r\n"Controls the display of the command being run on the server by this session in the info column. This is only displayed if the packet containing it was seen during this capture session.",\r\n&preference_info_show_command);\r\n}\r\nvoid\r\nproto_reg_handoff_rsh(void)\r\n{\r\ndissector_handle_t rsh_handle;\r\nrsh_handle = create_dissector_handle(dissect_rsh, proto_rsh);\r\ndissector_add_uint("tcp.port", RSH_PORT, rsh_handle);\r\n}
