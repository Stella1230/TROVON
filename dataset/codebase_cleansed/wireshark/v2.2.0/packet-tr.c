static const char* tr_conv_get_filter_type(conv_item_t* conv, conv_filter_type_e filter)\r\n{\r\nif ((filter == CONV_FT_SRC_ADDRESS) && (conv->src_address.type == AT_ETHER))\r\nreturn "tr.src";\r\nif ((filter == CONV_FT_DST_ADDRESS) && (conv->dst_address.type == AT_ETHER))\r\nreturn "tr.dst";\r\nif ((filter == CONV_FT_ANY_ADDRESS) && (conv->src_address.type == AT_ETHER))\r\nreturn "tr.addr";\r\nreturn CONV_FILTER_INVALID;\r\n}\r\nstatic int\r\ntr_conversation_packet(void *pct, packet_info *pinfo, epan_dissect_t *edt _U_, const void *vip)\r\n{\r\nconv_hash_t *hash = (conv_hash_t*) pct;\r\nconst tr_hdr *trhdr=(const tr_hdr *)vip;\r\nadd_conversation_table_data(hash, &trhdr->src, &trhdr->dst, 0, 0, 1, pinfo->fd->pkt_len, &pinfo->rel_ts, &pinfo->abs_ts, &tr_ct_dissector_info, PT_NONE);\r\nreturn 1;\r\n}\r\nstatic const char* tr_host_get_filter_type(hostlist_talker_t* host, conv_filter_type_e filter)\r\n{\r\nif ((filter == CONV_FT_ANY_ADDRESS) && (host->myaddress.type == AT_ETHER))\r\nreturn "tr.addr";\r\nreturn CONV_FILTER_INVALID;\r\n}\r\nstatic int\r\ntr_hostlist_packet(void *pit, packet_info *pinfo, epan_dissect_t *edt _U_, const void *vip)\r\n{\r\nconv_hash_t *hash = (conv_hash_t*) pit;\r\nconst tr_hdr *trhdr=(const tr_hdr *)vip;\r\nadd_hostlist_table_data(hash, &trhdr->src, 0, TRUE, 1, pinfo->fd->pkt_len, &tr_host_dissector_info, PT_NONE);\r\nadd_hostlist_table_data(hash, &trhdr->dst, 0, FALSE, 1, pinfo->fd->pkt_len, &tr_host_dissector_info, PT_NONE);\r\nreturn 1;\r\n}\r\nstatic\r\nint check_for_old_linux_tvb(tvbuff_t *tvb)\r\n{\r\nconst guint8 *data;\r\nint x, bytes;\r\nbytes = tvb_captured_length(tvb);\r\nif (bytes > 19) {\r\nbytes = 19;\r\n}\r\ndata = tvb_get_ptr(tvb, 0, bytes);\r\nfor(x = 1; x <= bytes-1 ;x++)\r\n{\r\nif (memcmp(&data[0], &data[x], x) == 0)\r\n{\r\nreturn x;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic\r\nint check_for_old_linux(const guchar * pd)\r\n{\r\nint x;\r\nfor(x=1;x<=18;x++)\r\n{\r\nif (memcmp(&pd[0],&pd[x],x) == 0)\r\n{\r\nreturn x;\r\n}\r\n}\r\nreturn 0;\r\n}\r\ngboolean\r\ncapture_tr(const guchar *pd, int offset, int len, capture_packet_info_t *cpinfo, const union wtap_pseudo_header *pseudo_header _U_) {\r\nint source_routed = 0;\r\nint frame_type;\r\nint x;\r\nguint8 trn_rif_bytes;\r\nguint8 actual_rif_bytes;\r\nguint16 first2_sr;\r\nguint8 trn_fc;\r\nconst guint8 *trn_shost;\r\nif (!BYTES_ARE_IN_FRAME(offset, len, TR_MIN_HEADER_LEN))\r\nreturn FALSE;\r\nif ((x = check_for_old_linux(pd)))\r\n{\r\noffset+=x;\r\n}\r\ntrn_fc = pd[offset + 1];\r\ntrn_shost = &pd[offset + 8];\r\nframe_type = (trn_fc & 192) >> 6;\r\nsource_routed = trn_shost[0] & 128;\r\ntrn_rif_bytes = pd[offset + 14] & 31;\r\nif (fix_linux_botches) {\r\nif (!source_routed && trn_rif_bytes > 0) {\r\nif (pd[offset + 0x0e] != pd[offset + 0x0f]) {\r\nfirst2_sr = pntoh16(&pd[offset + 0xe0 + trn_rif_bytes]);\r\nif (\r\n(first2_sr == 0xaaaa &&\r\npd[offset + 0x10 + trn_rif_bytes] == 0x03) ||\r\nfirst2_sr == 0xe0e0 ||\r\nfirst2_sr == 0xe0aa ) {\r\nsource_routed = 1;\r\n}\r\n}\r\n}\r\n}\r\nif (source_routed) {\r\nactual_rif_bytes = trn_rif_bytes;\r\n}\r\nelse {\r\ntrn_rif_bytes = 0;\r\nactual_rif_bytes = 0;\r\n}\r\nif (fix_linux_botches) {\r\nif ((source_routed && trn_rif_bytes == 2 && frame_type == 1) ||\r\n(!source_routed && frame_type == 1)) {\r\nif ( (pd[offset + 0x20] == 0xaa && pd[offset + 0x21] == 0xaa && pd[offset + 0x22] == 03) ||\r\n(pd[offset + 0x20] == 0xe0 && pd[offset + 0x21] == 0xe0) ) {\r\nactual_rif_bytes = 18;\r\n} else if (\r\npd[offset + 0x23] == 0 &&\r\npd[offset + 0x24] == 0 &&\r\npd[offset + 0x25] == 0 &&\r\npd[offset + 0x26] == 0x00 &&\r\npd[offset + 0x27] == 0x11) {\r\nactual_rif_bytes = 18;\r\noffset += 8;\r\n}\r\n}\r\n}\r\noffset += actual_rif_bytes + TR_MIN_HEADER_LEN;\r\nswitch (frame_type) {\r\ncase 1:\r\nreturn capture_llc(pd, offset, len, cpinfo, pseudo_header);\r\n}\r\nreturn FALSE;\r\n}\r\nstatic int\r\ndissect_tr(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *tr_tree;\r\nproto_item *ti, *hidden_item;\r\nguint8 rcf1, rcf2;\r\ntvbuff_t *next_tvb;\r\nvolatile int frame_type;\r\nvolatile int fixoffset = 0;\r\nvolatile int source_routed = 0;\r\nvolatile guint8 trn_rif_bytes;\r\nvolatile guint8 actual_rif_bytes;\r\nvolatile guint8 c1_nonsr;\r\nvolatile guint8 c2_nonsr;\r\nvolatile guint16 first2_sr;\r\ntvbuff_t *volatile tr_tvb;\r\nstatic tr_hdr trh_arr[4];\r\nstatic int trh_current=0;\r\ntr_hdr *volatile trh;\r\nguint8 *trn_shost_nonsr = (guint8*)wmem_alloc(pinfo->pool, 6);\r\nint x;\r\nstatic const char *fc[] = { "MAC", "LLC", "Reserved", "Unknown" };\r\ntrh_current++;\r\nif(trh_current==4){\r\ntrh_current=0;\r\n}\r\ntrh=&trh_arr[trh_current];\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "TR");\r\nif (fix_linux_botches)\r\nx = check_for_old_linux_tvb((tvbuff_t*) tvb);\r\nelse\r\nx = 0;\r\nif (x != 0) {\r\ntr_tvb = tvb_new_subset_remaining((tvbuff_t*) tvb, x);\r\n}\r\nelse {\r\ntr_tvb = tvb;\r\n}\r\ntrh->fc = tvb_get_guint8(tr_tvb, 1);\r\nset_address_tvb(&trh->src, AT_ETHER, 6, tr_tvb, 8);\r\nset_address_tvb(&trh->dst, AT_ETHER, 6, tr_tvb, 2);\r\nmemcpy(trn_shost_nonsr, trh->src.data, 6);\r\nsource_routed = trn_shost_nonsr[0] & 128;\r\ntrn_shost_nonsr[0] &= 127;\r\nframe_type = (trh->fc & 192) >> 6;\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Token-Ring %s", fc[frame_type]);\r\ntrn_rif_bytes = tvb_get_guint8(tr_tvb, 14) & 31;\r\nif (fix_linux_botches) {\r\nif (frame_type == 1 && !source_routed && trn_rif_bytes > 0) {\r\nTRY {\r\nc1_nonsr = tvb_get_guint8(tr_tvb, 14);\r\nc2_nonsr = tvb_get_guint8(tr_tvb, 15);\r\nif (c1_nonsr != c2_nonsr) {\r\nfirst2_sr = tvb_get_ntohs(tr_tvb, trn_rif_bytes + 0x0e);\r\nif ( ( first2_sr == 0xaaaa &&\r\ntvb_get_guint8(tr_tvb, trn_rif_bytes + 0x10) == 0x03) ||\r\nfirst2_sr == 0xe0e0 ||\r\nfirst2_sr == 0xe0aa ) {\r\nsource_routed = 1;\r\n}\r\n}\r\n}\r\nCATCH(BoundsError) {\r\n;\r\n}\r\nENDTRY;\r\n}\r\n}\r\nif (source_routed) {\r\nactual_rif_bytes = trn_rif_bytes;\r\n}\r\nelse {\r\ntrn_rif_bytes = 0;\r\nactual_rif_bytes = 0;\r\n}\r\nif (fix_linux_botches) {\r\nTRY {\r\nif (frame_type == 1 && ( (source_routed && trn_rif_bytes == 2) ||\r\n!source_routed) ) {\r\nif (\r\n(tvb_get_ntohs(tr_tvb, 0x20) == 0xaaaa &&\r\ntvb_get_guint8(tr_tvb, 0x22) == 0x03)\r\n||\r\ntvb_get_ntohs(tr_tvb, 0x20) == 0xe0e0 ) {\r\nactual_rif_bytes = 18;\r\n}\r\nelse if (\r\ntvb_get_ntohl(tr_tvb, 0x23) == 0 &&\r\ntvb_get_guint8(tr_tvb, 0x27) == 0x11) {\r\nactual_rif_bytes = 18;\r\nfixoffset += 8;\r\n}\r\n}\r\n}\r\nCATCH(BoundsError) {\r\n;\r\n}\r\nENDTRY;\r\n}\r\nset_address(&pinfo->dl_src, AT_ETHER, 6, trn_shost_nonsr);\r\ncopy_address_shallow(&pinfo->src, &pinfo->dl_src);\r\nset_address(&pinfo->dl_dst, AT_ETHER, 6, trh->dst.data);\r\ncopy_address_shallow(&pinfo->dst, &pinfo->dl_dst);\r\nif (tree) {\r\nstatic const int * ac[] = {\r\n&hf_tr_priority,\r\n&hf_tr_frame,\r\n&hf_tr_monitor_cnt,\r\n&hf_tr_priority_reservation,\r\nNULL\r\n};\r\nstatic const int * fc_flags[] = {\r\n&hf_tr_fc_type,\r\n&hf_tr_fc_pcf,\r\nNULL\r\n};\r\nti = proto_tree_add_item(tree, proto_tr, tr_tvb, 0, TR_MIN_HEADER_LEN + actual_rif_bytes, ENC_NA);\r\ntr_tree = proto_item_add_subtree(ti, ett_token_ring);\r\ntrh->ac = tvb_get_guint8(tr_tvb, 0);\r\nproto_tree_add_bitmask(tr_tree, tr_tvb, 0, hf_tr_ac, ett_token_ring_ac, ac, ENC_NA);\r\nproto_tree_add_bitmask(tr_tree, tr_tvb, 1, hf_tr_fc, ett_token_ring_fc, fc_flags, ENC_NA);\r\nproto_tree_add_ether(tr_tree, hf_tr_dst, tr_tvb, 2, 6, (const guint8 *)trh->dst.data);\r\nproto_tree_add_ether(tr_tree, hf_tr_src, tr_tvb, 8, 6, (const guint8 *)trh->src.data);\r\nhidden_item = proto_tree_add_ether(tr_tree, hf_tr_addr, tr_tvb, 2, 6, (const guint8 *)trh->dst.data);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_ether(tr_tree, hf_tr_addr, tr_tvb, 8, 6, (const guint8 *)trh->src.data);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nproto_tree_add_boolean(tr_tree, hf_tr_sr, tr_tvb, 8, 1, source_routed);\r\nhidden_item = proto_tree_add_ether(tr_tree, hf_tr_src, tr_tvb, 8, 6, trn_shost_nonsr);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nif (source_routed) {\r\nrcf1 = tvb_get_guint8(tr_tvb, 14);\r\nproto_tree_add_uint(tr_tree, hf_tr_rif_bytes, tr_tvb, 14, 1, trn_rif_bytes);\r\nproto_tree_add_uint(tr_tree, hf_tr_broadcast, tr_tvb, 14, 1, rcf1 & 224);\r\nrcf2 = tvb_get_guint8(tr_tvb, 15);\r\nproto_tree_add_uint(tr_tree, hf_tr_max_frame_size, tr_tvb, 15, 1, rcf2 & 112);\r\nproto_tree_add_uint(tr_tree, hf_tr_direction, tr_tvb, 15, 1, rcf2 & 128);\r\nif (trn_rif_bytes > 2) {\r\nadd_ring_bridge_pairs(trn_rif_bytes, tr_tvb, tr_tree);\r\n}\r\n}\r\nif (actual_rif_bytes > trn_rif_bytes) {\r\nproto_tree_add_expert(tr_tree, pinfo, &ei_token_empty_rif, tr_tvb, TR_MIN_HEADER_LEN + trn_rif_bytes, actual_rif_bytes - trn_rif_bytes);\r\n}\r\nif (fixoffset) {\r\nproto_tree_add_expert(tr_tree, pinfo, &ei_token_fake_llc_snap_header, tr_tvb, TR_MIN_HEADER_LEN + 18, 8);\r\n}\r\n}\r\nnext_tvb = tvb_new_subset_remaining(tr_tvb, TR_MIN_HEADER_LEN + actual_rif_bytes + fixoffset);\r\nswitch (frame_type) {\r\ncase 0:\r\ncall_dissector(trmac_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ncase 1:\r\ncall_dissector(llc_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\nbreak;\r\n}\r\ntap_queue_packet(tr_tap, pinfo, trh);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\nadd_ring_bridge_pairs(int rcf_len, tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_item *hidden_item;\r\nint j;\r\nint segment, brdgnmb, unprocessed_rif;\r\n#define RIF_OFFSET 16\r\n#define RIF_BYTES_TO_PROCESS 30\r\nwmem_strbuf_t *buf;\r\n#define MAX_BUF_LEN 3 + (RIF_BYTES_TO_PROCESS / 2) * 6 + 1\r\nbuf = wmem_strbuf_sized_new(wmem_packet_scope(),\r\nMAX_BUF_LEN, MAX_BUF_LEN);\r\nunprocessed_rif = rcf_len - RIF_BYTES_TO_PROCESS;\r\nrcf_len = MIN(rcf_len, RIF_BYTES_TO_PROCESS);\r\nrcf_len -= 2;\r\nfor(j = 1; j < rcf_len - 1; j += 2) {\r\nif (j==1) {\r\nsegment = tvb_get_ntohs(tvb, RIF_OFFSET) >> 4;\r\nwmem_strbuf_append_printf(buf, "%03X", segment);\r\nhidden_item = proto_tree_add_uint(tree, hf_tr_rif_ring, tvb, TR_MIN_HEADER_LEN + 2, 2, segment);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\n}\r\nsegment = tvb_get_ntohs(tvb, RIF_OFFSET + 1 + j) >> 4;\r\nbrdgnmb = tvb_get_guint8(tvb, RIF_OFFSET + j) & 0x0f;\r\nwmem_strbuf_append_printf(buf, "-%01X-%03X", brdgnmb, segment);\r\nhidden_item = proto_tree_add_uint(tree, hf_tr_rif_ring, tvb, TR_MIN_HEADER_LEN + 3 + j, 2, segment);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_uint(tree, hf_tr_rif_bridge, tvb, TR_MIN_HEADER_LEN + 2 + j, 1, brdgnmb);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\n}\r\nproto_tree_add_string(tree, hf_tr_rif, tvb, TR_MIN_HEADER_LEN + 2, rcf_len, wmem_strbuf_get_str(buf));\r\nif (unprocessed_rif > 0) {\r\nproto_tree_add_item(tree, hf_tr_extra_rif, tvb, TR_MIN_HEADER_LEN + RIF_BYTES_TO_PROCESS, unprocessed_rif, ENC_NA);\r\n}\r\n}\r\nvoid\r\nproto_register_tr(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_tr_ac,\r\n{ "Access Control", "tr.ac", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tr_priority,\r\n{ "Priority", "tr.priority", FT_UINT8, BASE_DEC, NULL, 0xe0,\r\nNULL, HFILL }},\r\n{ &hf_tr_frame,\r\n{ "Frame", "tr.frame", FT_BOOLEAN, 8, TFS(&ac_truth), 0x10,\r\nNULL, HFILL }},\r\n{ &hf_tr_monitor_cnt,\r\n{ "Monitor Count", "tr.monitor_cnt", FT_UINT8, BASE_DEC, NULL, 0x08,\r\nNULL, HFILL }},\r\n{ &hf_tr_priority_reservation,\r\n{ "Priority Reservation","tr.priority_reservation", FT_UINT8, BASE_DEC, NULL, 0x07,\r\nNULL, HFILL }},\r\n{ &hf_tr_fc,\r\n{ "Frame Control", "tr.fc", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tr_fc_type,\r\n{ "Frame Type", "tr.frame_type", FT_UINT8, BASE_DEC, VALS(frame_vals), 0xc0,\r\nNULL, HFILL }},\r\n{ &hf_tr_fc_pcf,\r\n{ "Frame PCF", "tr.frame_pcf", FT_UINT8, BASE_DEC, VALS(pcf_vals), 0x0f,\r\nNULL, HFILL }},\r\n{ &hf_tr_dst,\r\n{ "Destination", "tr.dst", FT_ETHER, BASE_NONE, NULL, 0x0,\r\n"Destination Hardware Address", HFILL }},\r\n{ &hf_tr_src,\r\n{ "Source", "tr.src", FT_ETHER, BASE_NONE, NULL, 0x0,\r\n"Source Hardware Address", HFILL }},\r\n{ &hf_tr_addr,\r\n{ "Source or Destination Address", "tr.addr", FT_ETHER, BASE_NONE, NULL, 0x0,\r\n"Source or Destination Hardware Address", HFILL }},\r\n{ &hf_tr_sr,\r\n{ "Source Routed", "tr.sr", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tr_rif_bytes,\r\n{ "RIF Bytes", "tr.rif_bytes", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Number of bytes in Routing Information Fields, including the two bytes of Routing Control Field", HFILL }},\r\n{ &hf_tr_broadcast,\r\n{ "Broadcast Type", "tr.broadcast", FT_UINT8, BASE_DEC, VALS(broadcast_vals), 0x0,\r\n"Type of Token-Ring Broadcast", HFILL }},\r\n{ &hf_tr_max_frame_size,\r\n{ "Maximum Frame Size", "tr.max_frame_size", FT_UINT8, BASE_DEC, VALS(max_frame_size_vals),\r\n0x0,\r\nNULL, HFILL }},\r\n{ &hf_tr_direction,\r\n{ "Direction", "tr.direction", FT_UINT8, BASE_DEC, VALS(direction_vals), 0x0,\r\n"Direction of RIF", HFILL }},\r\n{ &hf_tr_rif,\r\n{ "Ring-Bridge Pairs", "tr.rif", FT_STRING, BASE_NONE, NULL, 0x0,\r\n"String representing Ring-Bridge Pairs", HFILL }},\r\n{ &hf_tr_rif_ring,\r\n{ "RIF Ring", "tr.rif.ring", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tr_rif_bridge,\r\n{ "RIF Bridge", "tr.rif.bridge", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tr_extra_rif,\r\n{ "Extra RIF bytes beyond spec", "tr.rif.extra", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_token_ring,\r\n&ett_token_ring_ac,\r\n&ett_token_ring_fc,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_token_empty_rif, { "tr.empty_rif", PI_PROTOCOL, PI_NOTE, "Empty RIF from Linux 2.0.x driver. The sniffing NIC is also running a protocol stack.", EXPFILL }},\r\n{ &ei_token_fake_llc_snap_header, { "tr.fake_llc_snap_header", PI_PROTOCOL, PI_NOTE, "Linux 2.0.x fake LLC and SNAP header", EXPFILL }},\r\n};\r\nmodule_t *tr_module;\r\nexpert_module_t* expert_tr;\r\nproto_tr = proto_register_protocol("Token-Ring", "Token-Ring", "tr");\r\nproto_register_field_array(proto_tr, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_tr = expert_register_protocol(proto_tr);\r\nexpert_register_field_array(expert_tr, ei, array_length(ei));\r\ntr_module = prefs_register_protocol(proto_tr, NULL);\r\nprefs_register_bool_preference(tr_module, "fix_linux_botches",\r\n"Attempt to compensate for Linux mangling of the link-layer header",\r\n"Whether Linux mangling of the link-layer header should be checked for and worked around",\r\n&fix_linux_botches);\r\nregister_dissector("tr", dissect_tr, proto_tr);\r\ntr_tap=register_tap("tr");\r\nregister_conversation_table(proto_tr, TRUE, tr_conversation_packet, tr_hostlist_packet);\r\n}\r\nvoid\r\nproto_reg_handoff_tr(void)\r\n{\r\ndissector_handle_t tr_handle;\r\ntrmac_handle = find_dissector_add_dependency("trmac", proto_tr);\r\nllc_handle = find_dissector_add_dependency("llc", proto_tr);\r\ntr_handle = find_dissector("tr");\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_TOKEN_RING, tr_handle);\r\ndissector_add_uint("sflow_245.header_protocol", SFLOW_245_HEADER_TOKENRING, tr_handle);\r\nregister_capture_dissector("wtap_encap", WTAP_ENCAP_TOKEN_RING, capture_tr, proto_tr);\r\nregister_capture_dissector("atm_lane", TRAF_ST_LANE_802_5, capture_tr, proto_tr);\r\nregister_capture_dissector("atm_lane", TRAF_ST_LANE_802_5_MC, capture_tr, proto_tr);\r\n}
