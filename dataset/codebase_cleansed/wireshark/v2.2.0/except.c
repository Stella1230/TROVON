int except_init(void)\r\n{\r\nint retval = 1;\r\npthread_mutex_lock(&init_mtx);\r\nassert (init_counter < INT_MAX);\r\nif (init_counter++ == 0) {\r\nint top_ok = (pthread_key_create(&top_key, 0) == 0);\r\nint uh_ok = (pthread_key_create(&uh_key, 0) == 0);\r\nint alloc_ok = (pthread_key_create(&alloc_key, 0) == 0);\r\nint dealloc_ok = (pthread_key_create(&dealloc_key, 0) == 0);\r\nif (!top_ok || !uh_ok || !alloc_ok || !dealloc_ok) {\r\nretval = 0;\r\ninit_counter = 0;\r\nif (top_ok)\r\npthread_key_delete(top_key);\r\nif (uh_ok)\r\npthread_key_delete(uh_key);\r\nif (alloc_ok)\r\npthread_key_delete(alloc_key);\r\nif (dealloc_ok)\r\npthread_key_delete(dealloc_key);\r\n}\r\n}\r\npthread_mutex_unlock(&init_mtx);\r\nreturn retval;\r\n}\r\nvoid except_deinit(void)\r\n{\r\npthread_mutex_lock(&init_mtx);\r\nassert (init_counter > 0);\r\nif (--init_counter == 0) {\r\npthread_key_delete(top_key);\r\npthread_key_delete(uh_key);\r\npthread_key_delete(alloc_key);\r\npthread_key_delete(dealloc_key);\r\n}\r\npthread_mutex_unlock(&init_mtx);\r\n}\r\nint except_init(void)\r\n{\r\nassert (init_counter < INT_MAX);\r\ninit_counter++;\r\nreturn 1;\r\n}\r\nvoid except_deinit(void)\r\n{\r\nassert (init_counter > 0);\r\ninit_counter--;\r\n}\r\nstatic int match(const volatile except_id_t *thrown, const except_id_t *caught)\r\n{\r\nint group_match = (caught->except_group == XCEPT_GROUP_ANY ||\r\ncaught->except_group == thrown->except_group);\r\nint code_match = (caught->except_code == XCEPT_CODE_ANY ||\r\ncaught->except_code == thrown->except_code);\r\nreturn group_match && code_match;\r\n}\r\nWS_NORETURN static void do_throw(except_t *except)\r\n{\r\nstruct except_stacknode *top;\r\nassert (except->except_id.except_group != 0 &&\r\nexcept->except_id.except_code != 0);\r\nfor (top = get_top(); top != 0; top = top->except_down) {\r\nif (top->except_type == XCEPT_CLEANUP) {\r\ntop->except_info.except_cleanup->except_func(top->except_info.except_cleanup->except_context);\r\n} else {\r\nstruct except_catch *catcher = top->except_info.except_catcher;\r\nconst except_id_t *pi = catcher->except_id;\r\nsize_t i;\r\nassert (top->except_type == XCEPT_CATCHER);\r\nexcept_free(catcher->except_obj.except_dyndata);\r\nfor (i = 0; i < catcher->except_size; pi++, i++) {\r\nif (match(&except->except_id, pi)) {\r\ncatcher->except_obj = *except;\r\nset_top(top);\r\nlongjmp(catcher->except_jmp, 1);\r\n}\r\n}\r\n}\r\n}\r\nset_top(top);\r\nget_catcher()(except);\r\nabort();\r\n}\r\nstatic void unhandled_catcher(except_t *except)\r\n{\r\nif (except->except_message == NULL) {\r\nfprintf(stderr, "Unhandled exception (group=%lu, code=%lu)\n",\r\nexcept->except_id.except_group,\r\nexcept->except_id.except_code);\r\n} else {\r\nfprintf(stderr, "Unhandled exception (\"%s\", group=%lu, code=%lu)\n",\r\nexcept->except_message, except->except_id.except_group,\r\nexcept->except_id.except_code);\r\n}\r\nabort();\r\n}\r\nstatic void stack_push(struct except_stacknode *node)\r\n{\r\nnode->except_down = get_top();\r\nset_top(node);\r\n}\r\nvoid except_setup_clean(struct except_stacknode *esn,\r\nstruct except_cleanup *ecl, void (*cleanf)(void *), void *context)\r\n{\r\nesn->except_type = XCEPT_CLEANUP;\r\necl->except_func = cleanf;\r\necl->except_context = context;\r\nesn->except_info.except_cleanup = ecl;\r\nstack_push(esn);\r\n}\r\nvoid except_setup_try(struct except_stacknode *esn,\r\nstruct except_catch *ech, const except_id_t id[], size_t size)\r\n{\r\nech->except_id = id;\r\nech->except_size = size;\r\nech->except_obj.except_dyndata = 0;\r\nesn->except_type = XCEPT_CATCHER;\r\nesn->except_info.except_catcher = ech;\r\nstack_push(esn);\r\n}\r\nstruct except_stacknode *except_pop(void)\r\n{\r\nstruct except_stacknode *top = get_top();\r\nset_top(top->except_down);\r\nreturn top;\r\n}\r\nWS_NORETURN void except_rethrow(except_t *except)\r\n{\r\nstruct except_stacknode *top = get_top();\r\nassert (top != 0);\r\nassert (top->except_type == XCEPT_CATCHER);\r\nassert (&top->except_info.except_catcher->except_obj == except);\r\nset_top(top->except_down);\r\ndo_throw(except);\r\n}\r\nWS_NORETURN void except_throw(long group, long code, const char *msg)\r\n{\r\nexcept_t except;\r\nexcept.except_id.except_group = group;\r\nexcept.except_id.except_code = code;\r\nexcept.except_message = msg;\r\nexcept.except_dyndata = 0;\r\n#ifdef _WIN32\r\nif (code == DissectorError && IsDebuggerPresent()) {\r\nDebugBreak();\r\n}\r\n#endif\r\ndo_throw(&except);\r\n}\r\nWS_NORETURN void except_throwd(long group, long code, const char *msg, void *data)\r\n{\r\nexcept_t except;\r\nexcept.except_id.except_group = group;\r\nexcept.except_id.except_code = code;\r\nexcept.except_message = msg;\r\nexcept.except_dyndata = data;\r\ndo_throw(&except);\r\n}\r\nWS_NORETURN void except_throwf(long group, long code, const char *fmt, ...)\r\n{\r\nchar *buf = (char *)except_alloc(XCEPT_BUFFER_SIZE);\r\nva_list vl;\r\nva_start (vl, fmt);\r\ng_vsnprintf(buf, XCEPT_BUFFER_SIZE, fmt, vl);\r\nva_end (vl);\r\nexcept_throwd(group, code, buf, buf);\r\n}\r\nunsigned long except_code(except_t *ex)\r\n{\r\nreturn ex->except_id.except_code;\r\n}\r\nunsigned long except_group(except_t *ex)\r\n{\r\nreturn ex->except_id.except_group;\r\n}\r\nconst char *except_message(except_t *ex)\r\n{\r\nreturn ex->except_message;\r\n}\r\nvoid *except_data(except_t *ex)\r\n{\r\nreturn ex->except_dyndata;\r\n}\r\nvoid *except_take_data(except_t *ex)\r\n{\r\nvoid *data = ex->except_dyndata;\r\nex->except_dyndata = 0;\r\nreturn data;\r\n}\r\nvoid except_set_allocator(void *(*alloc)(size_t), void (*dealloc)(void *))\r\n{\r\nset_alloc(alloc);\r\nset_dealloc(dealloc);\r\n}\r\nvoid *except_alloc(size_t size)\r\n{\r\nvoid *ptr = get_alloc()(size);\r\nif (ptr == 0)\r\nexcept_throw(XCEPT_BAD_ALLOC, 0, "out of memory");\r\nreturn ptr;\r\n}\r\nvoid except_free(void *ptr)\r\n{\r\nget_dealloc()(ptr);\r\n}\r\nstatic void cleanup(void *arg)\r\n{\r\nprintf("cleanup(\"%s\") called\n", (char *) arg);\r\n}\r\nstatic void bottom_level(void)\r\n{\r\nchar buf[256];\r\nprintf("throw exception? "); fflush(stdout);\r\nfgets(buf, sizeof buf, stdin);\r\nif (buf[0] >= 0 && (buf[0] == 'Y' || buf[0] == 'y'))\r\nexcept_throw(1, 1, "nasty exception");\r\n}\r\nstatic void top_level(void)\r\n{\r\nexcept_cleanup_push(cleanup, "argument");\r\nbottom_level();\r\nexcept_cleanup_pop(0);\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nstatic const except_id_t catch[] = { { 1, 1 }, { 1, 2 } };\r\nexcept_t *ex;\r\nchar *msg;\r\nexcept_try_push(catch, 2, &ex);\r\nif (!ex) {\r\nexcept_try_push(catch, 2, &ex);\r\nif (!ex) {\r\ntop_level();\r\n} else {\r\nmsg = except_message(ex);\r\nif (msg == NULL) {\r\nprintf("caught exception (inner): s=%lu, c=%lu\n",\r\nexcept_group(ex), except_code(ex));\r\n} else {\r\nprintf("caught exception (inner): \"%s\", s=%lu, c=%lu\n",\r\nmsg, except_group(ex), except_code(ex));\r\n}\r\nexcept_rethrow(ex);\r\n}\r\nexcept_try_pop();\r\n} else {\r\nmsg = except_message(ex);\r\nif (msg == NULL) {\r\nprintf("caught exception (outer): s=%lu, c=%lu\n",\r\nexcept_group(ex), except_code(ex));\r\n} else {\r\nprintf("caught exception (outer): \"%s\", s=%lu, c=%lu\n",\r\nexcept_message(ex), except_group(ex), except_code(ex));\r\n}\r\n}\r\nexcept_try_pop();\r\nexcept_throw(99, 99, "exception in main");\r\nreturn 0;\r\n}
