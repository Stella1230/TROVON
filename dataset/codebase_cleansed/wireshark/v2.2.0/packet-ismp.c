static gchar*\r\nipx_addr_to_str(const guint32 net, const guint8 *ad)\r\n{\r\ngchar *buf;\r\nconst gchar *name;\r\nname = get_ether_name_if_known(ad);\r\nif (name) {\r\nbuf = wmem_strdup_printf(wmem_packet_scope(), "%s.%s",\r\nget_ipxnet_name(wmem_packet_scope(), net),\r\nname);\r\n}\r\nelse {\r\nbuf = wmem_strdup_printf(wmem_packet_scope(), "%s.%s",\r\nget_ipxnet_name(wmem_packet_scope(), net),\r\nbytestring_to_str(wmem_packet_scope(), ad, 6, '\0'));\r\n}\r\nreturn buf;\r\n}\r\nstatic void\r\ndissect_ismp_edp(tvbuff_t *tvb, packet_info *pinfo, int offset, proto_tree *ismp_tree)\r\n{\r\nint neighbors_count = 0;\r\nint tuples_count = 0;\r\nguint16 device_type = 0;\r\nguint16 num_neighbors = 0;\r\nguint16 num_tuples = 0;\r\nguint16 tuple_type = 0;\r\nguint16 tuple_length = 0;\r\nproto_item *edp_ti, *ti;\r\nproto_tree *edp_tree;\r\nproto_item *edp_neighbors_ti;\r\nproto_tree *edp_neighbors_tree;\r\nproto_tree *edp_neighbors_leaf_tree;\r\nproto_item *edp_tuples_ti;\r\nproto_tree *edp_tuples_tree;\r\nproto_tree *edp_tuples_leaf_tree;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ISMP.EDP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nedp_ti = proto_tree_add_item(ismp_tree, hf_ismp_edp, tvb, offset, -1, ENC_NA);\r\nedp_tree = proto_item_add_subtree(edp_ti, ett_ismp_edp);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MIP %s, MMAC %s, ifIdx %d",\r\ntvb_ip_to_str(tvb, offset+2),\r\ntvb_ether_to_str(tvb, offset+6),\r\ntvb_get_ntohl(tvb, offset+12));\r\nproto_tree_add_item(edp_tree, hf_ismp_edp_version, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(edp_tree, hf_ismp_edp_module_ip, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(edp_tree, hf_ismp_edp_module_mac, tvb, offset, 6, ENC_NA);\r\noffset += 6;\r\nproto_tree_add_item(edp_tree, hf_ismp_edp_module_port, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(edp_tree, hf_ismp_edp_chassis_mac, tvb, offset, 6, ENC_NA);\r\noffset += 6;\r\nproto_tree_add_item(edp_tree, hf_ismp_edp_chassis_ip, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\ndevice_type = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(edp_tree, hf_ismp_edp_device_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_uint_format_value(edp_tree, hf_ismp_edp_module_rev, tvb, offset, 4, tvb_get_ntohl(tvb, offset),\r\n"%02x.%02x.%02x.%02x", tvb_get_guint8(tvb, offset),\r\ntvb_get_guint8(tvb, offset+1), tvb_get_guint8(tvb, offset+2), tvb_get_guint8(tvb, offset+3));\r\noffset += 4;\r\nswitch (device_type) {\r\ncase EDP_DEVICE_TYPE_SFS17:\r\ncase EDP_DEVICE_TYPE_SFS18:\r\n{\r\nstatic const gint *options[] = {\r\n&hf_ismp_edp_sfs_option_uplink_flood,\r\n&hf_ismp_edp_sfs_option_uplink_port,\r\n&hf_ismp_edp_sfs_option_uplink_core,\r\n&hf_ismp_edp_sfs_option_uplink_switch,\r\n&hf_ismp_edp_sfs_option_isolated,\r\n&hf_ismp_edp_sfs_option_redun,\r\n&hf_ismp_edp_sfs_option_conmsg,\r\n&hf_ismp_edp_sfs_option_calltap,\r\n&hf_ismp_edp_sfs_option_tagflood,\r\n&hf_ismp_edp_sfs_option_unused2,\r\n&hf_ismp_edp_sfs_option_resolve,\r\n&hf_ismp_edp_sfs_option_flood,\r\n&hf_ismp_edp_sfs_option_lsp,\r\n&hf_ismp_edp_sfs_option_sfssup,\r\n&hf_ismp_edp_sfs_option_unused1,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase EDP_DEVICE_TYPE_ROUTER:\r\n{\r\nstatic const gint *options[] = {\r\n&hf_ismp_edp_rtr_option_level1,\r\n&hf_ismp_edp_rtr_option_trans,\r\n&hf_ismp_edp_rtr_option_route,\r\n&hf_ismp_edp_rtr_option_igmp_snoop,\r\n&hf_ismp_edp_rtr_option_gmrp,\r\n&hf_ismp_edp_rtr_option_gvrp,\r\n&hf_ismp_edp_rtr_option_8021q,\r\n&hf_ismp_edp_rtr_option_dvmrp,\r\n&hf_ismp_edp_rtr_option_ospf,\r\n&hf_ismp_edp_rtr_option_bgp,\r\n&hf_ismp_edp_rtr_option_rip,\r\n&hf_ismp_edp_rtr_option_igmp,\r\n&hf_ismp_edp_rtr_option_ssr,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase EDP_DEVICE_TYPE_BRIDGE:\r\n{\r\nstatic const gint *options[] = {\r\n&hf_ismp_edp_switch_option_level1,\r\n&hf_ismp_edp_switch_option_trans,\r\n&hf_ismp_edp_switch_option_route,\r\n&hf_ismp_edp_switch_option_igmp,\r\n&hf_ismp_edp_switch_option_gmrp,\r\n&hf_ismp_edp_switch_option_gvrp,\r\n&hf_ismp_edp_switch_option_8021q,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase EDP_DEVICE_TYPE_NTSERVER:\r\ncase EDP_DEVICE_TYPE_NTCLIENT:\r\ncase EDP_DEVICE_TYPE_WIN95:\r\ncase EDP_DEVICE_TYPE_WIN98:\r\ncase EDP_DEVICE_TYPE_UNIXSERVER:\r\ncase EDP_DEVICE_TYPE_UNIXCLIENT:\r\n{\r\nstatic const gint *options[] = {\r\n&hf_ismp_edp_end_station_option_ad,\r\n&hf_ismp_edp_end_station_option_dns,\r\n&hf_ismp_edp_end_station_option_dhcp,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase EDP_DEVICE_TYPE_VLANMAN:\r\ncase EDP_DEVICE_TYPE_ACCESSPOINT:\r\ndefault:\r\nproto_tree_add_item(edp_tree, hf_ismp_edp_options, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\noffset += 4;\r\nnum_neighbors = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(edp_tree, hf_ismp_edp_num_neighbors, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif (num_neighbors > 0)\r\n{\r\nedp_neighbors_ti = proto_tree_add_item(edp_tree, hf_ismp_edp_neighbors, tvb,\r\noffset, num_neighbors*10, ENC_NA);\r\nedp_neighbors_tree = proto_item_add_subtree(edp_neighbors_ti, ett_ismp_edp_neighbors);\r\nwhile ( neighbors_count < num_neighbors && tvb_reported_length_remaining(tvb, offset) >= 10)\r\n{\r\nedp_neighbors_leaf_tree = proto_tree_add_subtree_format(edp_neighbors_tree, tvb, offset, 10,\r\nett_ismp_edp_neighbors_leaf, NULL, "Neighbor%d", (neighbors_count+1));\r\nproto_tree_add_item(edp_neighbors_leaf_tree, hf_ismp_neighborhood_mac_address, tvb, offset, 6, ENC_NA);\r\nproto_tree_add_item(edp_neighbors_leaf_tree, hf_ismp_assigned_neighbor_state, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 10;\r\nneighbors_count++;\r\n}\r\nif (neighbors_count != num_neighbors)\r\n{\r\nproto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, -1);\r\nreturn;\r\n}\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) != 0 &&\r\ntvb_reported_length_remaining(tvb, offset) >= 2)\r\n{\r\nnum_tuples = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(edp_tree, hf_ismp_edp_num_tuples, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n}\r\nelse if (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nproto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, -1);\r\nreturn;\r\n}\r\nelse\r\n{\r\nreturn;\r\n}\r\nif (num_tuples && tvb_reported_length_remaining(tvb, offset) >= 4)\r\n{\r\nedp_tuples_ti = proto_tree_add_bytes_format(edp_tree, hf_ismp_edp_tuples, tvb,\r\noffset, -1, NULL, "Tuples");\r\nedp_tuples_tree = proto_item_add_subtree(edp_tuples_ti, ett_ismp_edp_tuples);\r\nwhile ( (tuples_count < num_tuples) && (tvb_reported_length_remaining(tvb, offset) >= 4) )\r\n{\r\ntuple_length = tvb_get_ntohs(tvb, offset+2);\r\nedp_tuples_leaf_tree = proto_tree_add_subtree_format(edp_tuples_tree, tvb, offset, tuple_length,\r\nett_ismp_edp_tuples_leaf, NULL, "Tuple%d", tuples_count+1);\r\ntuple_type = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_tuple_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_tuple_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif (tvb_reported_length_remaining(tvb, offset) >= tuple_length)\r\n{\r\nswitch (tuple_type)\r\n{\r\ncase EDP_TUPLE_HOLD:\r\nti = proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_hold_time, tvb, offset, hf_ismp_hold_time, ENC_BIG_ENDIAN);\r\nproto_item_set_len(ti, tuple_length);\r\nbreak;\r\ncase EDP_TUPLE_INT_NAME:\r\nproto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_interface_name, tvb, offset, tuple_length, ENC_NA|ENC_ASCII);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", ifName %s",\r\ntvb_format_text(tvb, offset, tuple_length));\r\nbreak;\r\ncase EDP_TUPLE_SYS_DESCRIPT:\r\nproto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_system_description, tvb, offset, tuple_length, ENC_NA|ENC_ASCII);\r\nbreak;\r\ncase EDP_TUPLE_IPX_ADDR:\r\nproto_tree_add_string(edp_tuples_leaf_tree, hf_ismp_interface_ipx_address ,tvb, offset, tuple_length,\r\nipx_addr_to_str(tvb_get_ntohl(tvb, offset),\r\ntvb_get_string_enc(wmem_packet_scope(), tvb, offset+4, tuple_length-4, ENC_ASCII)));\r\nbreak;\r\ncase EDP_TUPLE_UNKNOWN:\r\ndefault:\r\nproto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_unknown_tuple_data, tvb, offset, tuple_length, ENC_NA|ENC_ASCII);\r\nbreak;\r\n}\r\n}\r\noffset += tuple_length;\r\ntuples_count++;\r\n}\r\nif (tuples_count != num_tuples)\r\nproto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, -1);\r\nreturn;\r\n}\r\n}\r\nstatic int\r\ndissect_ismp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\nguint16 message_type = 0;\r\nguint8 code_length = 0;\r\nguint8 weird_stuff[3] = { 0x42, 0x42, 0x03 };\r\nproto_item *ti;\r\nproto_tree *ismp_tree;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ISMP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (tvb_memeql(tvb, offset, weird_stuff, sizeof weird_stuff) == 0)\r\noffset += 3;\r\nti = proto_tree_add_item(tree, proto_ismp, tvb, offset, -1, ENC_NA);\r\nismp_tree = proto_item_add_subtree(ti, ett_ismp);\r\nproto_tree_add_item(ismp_tree, hf_ismp_version, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nmessage_type = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(ismp_tree, hf_ismp_message_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(ismp_tree, hf_ismp_seq_num, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\ncode_length = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(ismp_tree, hf_ismp_code_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(ismp_tree, hf_ismp_auth_data, tvb, offset, code_length, ENC_NA);\r\noffset += code_length;\r\nif(message_type == ISMPTYPE_EDP)\r\ndissect_ismp_edp(tvb, pinfo, offset, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ismp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ismp_version,\r\n{ "Version", "ismp.version",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_message_type,\r\n{ "Message Type", "ismp.msgtype",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_seq_num,\r\n{ "Sequence Number", "ismp.seqnum",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_code_length,\r\n{ "Auth Code Length", "ismp.codelen",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_auth_data,\r\n{ "Auth Data", "ismp.authdata",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp,\r\n{ "EDP", "ismp.edp",\r\nFT_PROTOCOL, BASE_NONE, NULL, 0x0,\r\n"Enterasys Discovery Protocol", HFILL }\r\n},\r\n{ &hf_ismp_edp_version,\r\n{ "Version", "ismp.edp.version",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_module_ip,\r\n{ "Module IP Address", "ismp.edp.modip",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_module_mac,\r\n{ "Module MAC Address", "ismp.edp.modmac",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_module_port,\r\n{ "Module Port (ifIndex num)", "ismp.edp.modport",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_chassis_mac,\r\n{ "Chassis MAC Address", "ismp.edp.chassismac",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_chassis_ip,\r\n{ "Chassis IP Address", "ismp.edp.chassisip",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_device_type,\r\n{ "Device Type", "ismp.edp.devtype",\r\nFT_UINT16, BASE_DEC, VALS(edp_device_types), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_module_rev,\r\n{ "Module Firmware Revision", "ismp.edp.rev",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_options,\r\n{ "Device Options", "ismp.edp.options",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_sfs_option_unused1,\r\n{ "Unused", "ismp.edp.sfs_option_unused1",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SFS_OPTION_UNUSED1,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_sfs_option_sfssup,\r\n{ "SFS Support", "ismp.edp.sfs_option_sfssup",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SFS_OPTION_SFSSUP,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_sfs_option_lsp,\r\n{ "LSP Support", "ismp.edp.sfs_option_lsp",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SFS_OPTION_LSP,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_sfs_option_flood,\r\n{ "Flood Path Support", "ismp.edp.sfs_option_flood",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SFS_OPTION_FLOOD,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_sfs_option_resolve,\r\n{ "Resolve Support", "ismp.edp.sfs_option_resolve",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SFS_OPTION_RESOLVE,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_sfs_option_unused2,\r\n{ "Unused", "ismp.edp.sfs_option_unused2",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SFS_OPTION_UNUSED2,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_sfs_option_tagflood,\r\n{ "Tagged Flood Support", "ismp.edp.sfs_option_tagflood",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SFS_OPTION_TAGFLOOD,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_sfs_option_calltap,\r\n{ "Call Tap Support", "ismp.edp.sfs_option_calltap",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SFS_OPTION_CALLTAP,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_sfs_option_conmsg,\r\n{ "Connection Message Support", "ismp.edp.sfs_option_conmsg",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SFS_OPTION_CONMSG,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_sfs_option_redun,\r\n{ "Redundant Access Support", "ismp.edp.sfs_option_redun",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SFS_OPTION_REDUN,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_sfs_option_isolated,\r\n{ "Isolated Switch", "ismp.edp.sfs_option_isolated",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SFS_OPTION_ISOLATED,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_sfs_option_uplink_switch,\r\n{ "Uplink Switch", "ismp.edp.sfs_option_uplink_switch",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SFS_OPTION_UPLINK_SWITCH,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_sfs_option_uplink_core,\r\n{ "Uplink Core", "ismp.edp.sfs_option_uplink_core",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SFS_OPTION_UPLINK_CORE,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_sfs_option_uplink_port,\r\n{ "Uplink Port", "ismp.edp.sfs_option_uplink_port",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SFS_OPTION_UPLINK_PORT,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_sfs_option_uplink_flood,\r\n{ "Uplink Flood Support", "ismp.edp.sfs_option_uplink_flood",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SFS_OPTION_UPLINK_FLOOD,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_rtr_option_ssr,\r\n{ "SSR Type Device", "ismp.edp.rtr_option_ssr",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_RTR_OPTION_SSR,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_rtr_option_igmp,\r\n{ "IGMP Active", "ismp.edp.rtr_option_igmp",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_RTR_OPTION_IGMP,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_rtr_option_rip,\r\n{ "RIP Active", "ismp.edp.rtr_option_rip",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_RTR_OPTION_RIP,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_rtr_option_bgp,\r\n{ "BGP Active", "ismp.edp.rtr_option_bgp",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_RTR_OPTION_BGP,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_rtr_option_ospf,\r\n{ "OSPF Active", "ismp.edp.rtr_option_ospf",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_RTR_OPTION_OSPF,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_rtr_option_dvmrp,\r\n{ "DVMRP Active", "ismp.edp.rtr_option_dvmrp",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_RTR_OPTION_DVMRP,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_rtr_option_8021q,\r\n{ "802.1Q Support", "ismp.edp.rtr_option_8021q",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_RTR_OPTION_8021Q,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_rtr_option_gvrp,\r\n{ "GVRP Support", "ismp.edp.rtr_option_gvrp",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_RTR_OPTION_GVRP,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_rtr_option_gmrp,\r\n{ "GMRP Support", "ismp.edp.rtr_option_gmrp",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_RTR_OPTION_GMRP,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_rtr_option_igmp_snoop,\r\n{ "IGMP Snooping Support", "ismp.edp.rtr_option_igmp_snoop",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_RTR_OPTION_IGMP_SNOOP,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_rtr_option_route,\r\n{ "Route Bridging", "ismp.edp.rtr_option_route",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_RTR_OPTION_ROUTE,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_rtr_option_trans,\r\n{ "Transparent Bridging", "ismp.edp.rtr_option_trans",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_RTR_OPTION_TRANS,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_rtr_option_level1,\r\n{ "Level 1 Functionality", "ismp.edp.rtr_option_level1",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_RTR_OPTION_LEVEL1,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_switch_option_8021q,\r\n{ "802.1Q Support", "ismp.edp.switch_option_8021q",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SWITCH_OPTION_8021Q,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_switch_option_gvrp,\r\n{ "GVRP Support", "ismp.edp.switch_option_gvrp",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SWITCH_OPTION_GVRP,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_switch_option_gmrp,\r\n{ "GMRP Support", "ismp.edp.switch_option_gmrp",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SWITCH_OPTION_GMRP,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_switch_option_igmp,\r\n{ "IGMP Snooping Support", "ismp.edp.switch_option_igmp",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SWITCH_OPTION_IGMP,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_switch_option_route,\r\n{ "Route Bridging", "ismp.edp.switch_option_route",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SWITCH_OPTION_ROUTE,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_switch_option_trans,\r\n{ "Transparent Bridging", "ismp.edp.switch_option_trans",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SWITCH_OPTION_TRANS,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_switch_option_level1,\r\n{ "Level 1 Functionality", "ismp.edp.switch_option_level1",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_SWITCH_OPTION_LEVEL1,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_end_station_option_dhcp,\r\n{ "DHCP Enabled", "ismp.edp.end_station_option_dhcp",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_END_STATION_OPTION_DHCP,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_end_station_option_dns,\r\n{ "DNS Enabled", "ismp.edp.end_station_option_dns",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_END_STATION_OPTION_DNS,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_end_station_option_ad,\r\n{ "Active Directory Enabled", "ismp.edp.end_station_option_ad",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), EDP_END_STATION_OPTION_AD,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_num_neighbors,\r\n{ "Number of Known Neighbors", "ismp.edp.maccount",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_neighbors,\r\n{ "Neighbors", "ismp.edp.nbrs",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_num_tuples,\r\n{ "Number of Tuples", "ismp.edp.numtups",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_edp_tuples,\r\n{ "Number of Tuples", "ismp.edp.tups",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ismp_neighborhood_mac_address, { "MAC Address", "ismp.neighborhood_mac_address", FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ismp_assigned_neighbor_state, { "Assigned Neighbor State", "ismp.assigned_neighbor_state", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ismp_tuple_type, { "Tuple Type", "ismp.tuple_type", FT_UINT16, BASE_DEC, VALS(edp_tuple_types), 0x0, NULL, HFILL }},\r\n{ &hf_ismp_tuple_length, { "Tuple Length", "ismp.tuple_length", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ismp_hold_time, { "Hold Time", "ismp.hold_time", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ismp_interface_name, { "Interface Name", "ismp.interface_name", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ismp_system_description, { "System Description", "ismp.system_description", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ismp_interface_ipx_address, { "Interface IPX_address", "ismp.interface_ipx_address", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ismp_unknown_tuple_data, { "Unknown Tuple Data", "ismp.unknown_tuple_data", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ismp,\r\n&ett_ismp_edp,\r\n&ett_ismp_edp_options,\r\n&ett_ismp_edp_neighbors,\r\n&ett_ismp_edp_neighbors_leaf,\r\n&ett_ismp_edp_tuples,\r\n&ett_ismp_edp_tuples_leaf,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_ismp_malformed, { "ismp.malformed", PI_MALFORMED, PI_ERROR, "Malformed packet", EXPFILL }},\r\n};\r\nexpert_module_t* expert_ismp;\r\nproto_ismp = proto_register_protocol("InterSwitch Message Protocol",\r\n"ISMP", "ismp");\r\nproto_register_field_array(proto_ismp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_ismp = expert_register_protocol(proto_ismp);\r\nexpert_register_field_array(expert_ismp, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_ismp(void)\r\n{\r\ndissector_handle_t ismp_handle;\r\nismp_handle = create_dissector_handle(dissect_ismp,\r\nproto_ismp);\r\ndissector_add_uint("ethertype", ETHERTYPE_ISMP, ismp_handle);\r\n}
