static gint64 dbs_etherwatch_seek_next_packet(wtap *wth, int *err,\r\ngchar **err_info)\r\n{\r\nint byte;\r\nunsigned int level = 0;\r\ngint64 cur_off;\r\nwhile ((byte = file_getc(wth->fh)) != EOF) {\r\nif (byte == dbs_etherwatch_rec_magic[level]) {\r\nlevel++;\r\nif (level >= DBS_ETHERWATCH_REC_MAGIC_SIZE) {\r\ncur_off = file_tell(wth->fh);\r\nif (cur_off == -1) {\r\n*err = file_error(wth->fh, err_info);\r\nreturn -1;\r\n}\r\nreturn cur_off + 1;\r\n}\r\n} else {\r\nlevel = 0;\r\n}\r\n}\r\n*err = file_error(wth->fh, err_info);\r\nreturn -1;\r\n}\r\nstatic gboolean dbs_etherwatch_check_file_type(wtap *wth, int *err,\r\ngchar **err_info)\r\n{\r\nchar buf[DBS_ETHERWATCH_LINE_LENGTH];\r\nint line, byte;\r\ngsize reclen;\r\nunsigned int i, level;\r\nbuf[DBS_ETHERWATCH_LINE_LENGTH-1] = 0;\r\nfor (line = 0; line < DBS_ETHERWATCH_HEADER_LINES_TO_CHECK; line++) {\r\nif (file_gets(buf, DBS_ETHERWATCH_LINE_LENGTH, wth->fh) == NULL) {\r\n*err = file_error(wth->fh, err_info);\r\nreturn FALSE;\r\n}\r\nreclen = strlen(buf);\r\nif (reclen < DBS_ETHERWATCH_HDR_MAGIC_SIZE)\r\ncontinue;\r\nlevel = 0;\r\nfor (i = 0; i < reclen; i++) {\r\nbyte = buf[i];\r\nif (byte == dbs_etherwatch_hdr_magic[level]) {\r\nlevel++;\r\nif (level >=\r\nDBS_ETHERWATCH_HDR_MAGIC_SIZE) {\r\nreturn TRUE;\r\n}\r\n}\r\nelse\r\nlevel = 0;\r\n}\r\n}\r\n*err = 0;\r\nreturn FALSE;\r\n}\r\nwtap_open_return_val dbs_etherwatch_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nif (!dbs_etherwatch_check_file_type(wth, err, err_info)) {\r\nif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nwth->file_encap = WTAP_ENCAP_ETHERNET;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_DBS_ETHERWATCH;\r\nwth->snapshot_length = 0;\r\nwth->subtype_read = dbs_etherwatch_read;\r\nwth->subtype_seek_read = dbs_etherwatch_seek_read;\r\nwth->file_tsprec = WTAP_TSPREC_CSEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean dbs_etherwatch_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\ngint64 offset;\r\noffset = dbs_etherwatch_seek_next_packet(wth, err, err_info);\r\nif (offset < 1)\r\nreturn FALSE;\r\n*data_offset = offset;\r\nreturn parse_dbs_etherwatch_packet(&wth->phdr, wth->fh,\r\nwth->frame_buffer, err, err_info);\r\n}\r\nstatic gboolean\r\ndbs_etherwatch_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off - 1, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nreturn parse_dbs_etherwatch_packet(phdr, wth->random_fh, buf, err,\r\nerr_info);\r\n}\r\nstatic gboolean\r\nparse_dbs_etherwatch_packet(struct wtap_pkthdr *phdr, FILE_T fh, Buffer* buf,\r\nint *err, gchar **err_info)\r\n{\r\nguint8 *pd;\r\nchar line[DBS_ETHERWATCH_LINE_LENGTH];\r\nint num_items_scanned;\r\nint eth_hdr_len, pkt_len, csec;\r\nint length_pos, length_from, length;\r\nstruct tm tm;\r\nchar mon[4] = "xxx";\r\ngchar *p;\r\nstatic const gchar months[] = "JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC";\r\nint count, line_count;\r\nws_buffer_assure_space(buf, DBS_ETHERWATCH_MAX_ETHERNET_PACKET_LEN);\r\npd = ws_buffer_start_ptr(buf);\r\neth_hdr_len = 0;\r\nmemset(&tm, 0, sizeof(tm));\r\nif (file_gets(line, DBS_ETHERWATCH_LINE_LENGTH, fh) == NULL) {\r\n*err = file_error(fh, err_info);\r\nif (*err == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn FALSE;\r\n}\r\np = strstr(line, DEST_MAC_PREFIX);\r\nif(!p) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("dbs_etherwatch: destination address not found");\r\nreturn FALSE;\r\n}\r\np += strlen(DEST_MAC_PREFIX);\r\nif(parse_hex_dump(p, &pd[eth_hdr_len], HEX_HDR_SPR, HEX_HDR_END)\r\n!= MAC_ADDR_LENGTH) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("dbs_etherwatch: destination address not valid");\r\nreturn FALSE;\r\n}\r\neth_hdr_len += MAC_ADDR_LENGTH;\r\np = line;\r\nwhile(!g_ascii_isxdigit(*p)) {\r\np++;\r\n}\r\nif(parse_hex_dump(p, &pd[eth_hdr_len], HEX_HDR_SPR,\r\nHEX_HDR_END) != MAC_ADDR_LENGTH) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("dbs_etherwatch: source address not valid");\r\nreturn FALSE;\r\n}\r\neth_hdr_len += MAC_ADDR_LENGTH;\r\nif (file_gets(line, DBS_ETHERWATCH_LINE_LENGTH, fh) == NULL) {\r\n*err = file_error(fh, err_info);\r\nif (*err == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn FALSE;\r\n}\r\nif(strlen(line) < LENGTH_POS) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("dbs_etherwatch: line too short");\r\nreturn FALSE;\r\n}\r\nnum_items_scanned = sscanf(line + LENGTH_POS,\r\n"%9d byte buffer at %2d-%3s-%4d %2d:%2d:%2d.%9d",\r\n&pkt_len,\r\n&tm.tm_mday, mon,\r\n&tm.tm_year, &tm.tm_hour, &tm.tm_min,\r\n&tm.tm_sec, &csec);\r\nif (num_items_scanned != 8) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("dbs_etherwatch: header line not valid");\r\nreturn FALSE;\r\n}\r\nif (pkt_len < 0) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("dbs_etherwatch: packet header has a negative packet length");\r\nreturn FALSE;\r\n}\r\nif(strncmp(&line[ETH_II_CHECK_POS], ETH_II_CHECK_STR,\r\nstrlen(ETH_II_CHECK_STR)) == 0) {\r\nif(parse_hex_dump(&line[PROTOCOL_POS], &pd[eth_hdr_len], HEX_HDR_SPR,\r\nHEX_HDR_END) != PROTOCOL_LENGTH) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("dbs_etherwatch: Ethernet II protocol value not valid");\r\nreturn FALSE;\r\n}\r\neth_hdr_len += PROTOCOL_LENGTH;\r\n} else {\r\nlength_pos = eth_hdr_len;\r\neth_hdr_len += IEEE802_LEN_LEN;\r\nlength_from = eth_hdr_len;\r\nif(parse_hex_dump(&line[SAP_POS], &pd[eth_hdr_len], HEX_HDR_SPR,\r\nHEX_HDR_END) != SAP_LENGTH) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("dbs_etherwatch: 802.2 DSAP+SSAP value not valid");\r\nreturn FALSE;\r\n}\r\neth_hdr_len += SAP_LENGTH;\r\nif(parse_hex_dump(&line[CTL_POS], &pd[eth_hdr_len], HEX_HDR_SPR,\r\nHEX_HDR_END) != CTL_UNNUMB_LENGTH) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("dbs_etherwatch: 802.2 control field first part not valid");\r\nreturn FALSE;\r\n}\r\nif((pd[eth_hdr_len] & CTL_UNNUMB_MASK) != CTL_UNNUMB_VALUE) {\r\nif(parse_hex_dump(&line[PID_POS],\r\n&pd[eth_hdr_len + CTL_UNNUMB_LENGTH], HEX_HDR_END,\r\nHEX_HDR_SPR) != CTL_NUMB_LENGTH - CTL_UNNUMB_LENGTH) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("dbs_etherwatch: 802.2 control field second part value not valid");\r\nreturn FALSE;\r\n}\r\neth_hdr_len += CTL_NUMB_LENGTH;\r\n} else {\r\neth_hdr_len += CTL_UNNUMB_LENGTH;\r\n}\r\nif(strncmp(&line[SNAP_CHECK_POS], SNAP_CHECK_STR,\r\nstrlen(SNAP_CHECK_STR)) == 0) {\r\nif(parse_hex_dump(&line[PID_POS], &pd[eth_hdr_len], HEX_HDR_SPR,\r\nHEX_PID_END) != PID_LENGTH) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("dbs_etherwatch: 802.2 PID value not valid");\r\nreturn FALSE;\r\n}\r\neth_hdr_len += PID_LENGTH;\r\n}\r\nlength = eth_hdr_len - length_from + pkt_len;\r\npd[length_pos] = (length) >> 8;\r\npd[length_pos+1] = (length) & 0xFF;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\np = strstr(months, mon);\r\nif (p)\r\ntm.tm_mon = (int)(p - months) / 3;\r\ntm.tm_year -= 1900;\r\ntm.tm_isdst = -1;\r\nphdr->ts.secs = mktime(&tm);\r\nphdr->ts.nsecs = csec * 10000000;\r\nphdr->caplen = eth_hdr_len + pkt_len;\r\nphdr->len = eth_hdr_len + pkt_len;\r\nif (phdr->caplen > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("dbs_etherwatch: File has %u-byte packet, bigger than maximum of %u",\r\nphdr->caplen, WTAP_MAX_PACKET_SIZE);\r\nreturn FALSE;\r\n}\r\nws_buffer_assure_space(buf, phdr->caplen);\r\npd = ws_buffer_start_ptr(buf);\r\nphdr->pseudo_header.eth.fcs_len = 0;\r\ncount = 0;\r\nwhile (count < pkt_len) {\r\nif (file_gets(line, DBS_ETHERWATCH_LINE_LENGTH, fh) == NULL) {\r\n*err = file_error(fh, err_info);\r\nif (*err == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn FALSE;\r\n}\r\nif (!(line_count = parse_single_hex_dump_line(line,\r\n&pd[eth_hdr_len + count], count))) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("dbs_etherwatch: packet data value not valid");\r\nreturn FALSE;\r\n}\r\ncount += line_count;\r\nif (count > pkt_len) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("dbs_etherwatch: packet data value has too many bytes");\r\nreturn FALSE;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic guint\r\nparse_single_hex_dump_line(char* rec, guint8 *buf, int byte_offset) {\r\nint pos, i;\r\nint value;\r\nfor(i = 0; i < TYPE_CHECK_POS; i++)\r\n{\r\nif(rec[i] == '\0') {\r\nreturn 0;\r\n}\r\n}\r\nif(rec[TYPE_CHECK_POS] == TYPE_CHECK_BOTH)\r\n{\r\npos = COUNT_POS_BOTH;\r\n}\r\nelse\r\n{\r\npos = COUNT_POS_HEX;\r\n}\r\nwhile(i < pos)\r\n{\r\nif(rec[i] == '\0') {\r\nreturn 0;\r\n}\r\ni++;\r\n}\r\nvalue = 0;\r\nfor(i = 0; i < COUNT_SIZE; i++) {\r\nif(!g_ascii_isspace(rec[pos])) {\r\nif(g_ascii_isdigit(rec[pos])) {\r\nvalue *= 10;\r\nvalue += rec[pos] - '0';\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\npos++;\r\n}\r\nif (value != byte_offset) {\r\nreturn 0;\r\n}\r\nwhile(rec[pos] != HEX_DUMP_START) {\r\nif(rec[pos] == '\0') {\r\nreturn 0;\r\n}\r\npos++;\r\n}\r\npos++;\r\nreturn parse_hex_dump(&rec[pos], buf, HEX_DUMP_SPR, HEX_DUMP_END);\r\n}\r\nstatic guint\r\nparse_hex_dump(char* dump, guint8 *buf, char seperator, char end) {\r\nint pos, count;\r\npos = 0;\r\ncount = 0;\r\nwhile(dump[pos] != end) {\r\nif(!(g_ascii_isxdigit(dump[pos]) &&\r\ng_ascii_isxdigit(dump[pos + 1]))) {\r\nreturn 0;\r\n}\r\nif(g_ascii_isdigit(dump[pos])) {\r\nbuf[count] = (dump[pos] - '0') << 4;\r\n} else {\r\nbuf[count] = (g_ascii_toupper(dump[pos]) - 'A' + 10) << 4;\r\n}\r\npos++;\r\nif(g_ascii_isdigit(dump[pos])) {\r\nbuf[count] += dump[pos] - '0';\r\n} else {\r\nbuf[count] += g_ascii_toupper(dump[pos]) - 'A' + 10;\r\n}\r\npos++;\r\ncount++;\r\nwhile(dump[pos] == seperator) {\r\npos++;\r\n}\r\n}\r\nreturn count;\r\n}
