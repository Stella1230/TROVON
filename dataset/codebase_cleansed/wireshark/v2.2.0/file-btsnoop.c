static int\r\ndissect_btsnoop(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nstatic const guint8 magic[] = { 'b', 't', 's', 'n', 'o', 'o', 'p', 0};\r\ngint offset = 0;\r\nguint32 datalink;\r\nguint32 flags;\r\nguint32 length;\r\nproto_tree *main_tree;\r\nproto_item *main_item;\r\nproto_tree *header_tree;\r\nproto_item *header_item;\r\nproto_tree *frame_tree;\r\nproto_item *frame_item;\r\nproto_tree *flags_tree;\r\nproto_item *flags_item;\r\nproto_tree *payload_tree;\r\nproto_item *payload_item;\r\nstatic guint32 frame_number = 1;\r\ntvbuff_t *next_tvb;\r\nnstime_t timestamp;\r\nguint64 ts;\r\nif (tvb_memeql(tvb, 0, magic, sizeof(magic)) != 0)\r\nreturn 0;\r\nif (offset == 0) frame_number = 1;\r\nmain_item = proto_tree_add_item(tree, proto_btsnoop, tvb, offset, -1, ENC_NA);\r\nmain_tree = proto_item_add_subtree(main_item, ett_btsnoop);\r\nheader_item = proto_tree_add_item(main_tree, hf_btsnoop_header, tvb, offset, sizeof(magic) + 4 + 4, ENC_NA);\r\nheader_tree = proto_item_add_subtree(header_item, ett_btsnoop_header);\r\nproto_tree_add_item(header_tree, hf_btsnoop_magic_bytes, tvb, offset, sizeof(magic), ENC_ASCII | ENC_NA);\r\noffset += (gint)sizeof(magic);\r\nproto_tree_add_item(header_tree, hf_btsnoop_version, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(header_tree, hf_btsnoop_datalink, tvb, offset, 4, ENC_BIG_ENDIAN);\r\ndatalink = tvb_get_ntohl(tvb, offset);\r\noffset += 4;\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nframe_item = proto_tree_add_item(main_tree, hf_btsnoop_frame, tvb, offset, 0, ENC_NA);\r\nframe_tree = proto_item_add_subtree(frame_item, ett_btsnoop_frame);\r\nif (tvb_reported_length_remaining(tvb, offset) < 4 * 4 + 8) {\r\nexpert_add_info(pinfo, frame_item, &ei_malformed_frame);\r\n}\r\nproto_item_append_text(frame_item, " %u", frame_number);\r\nproto_tree_add_item(frame_tree, hf_btsnoop_origin_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(frame_tree, hf_btsnoop_included_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nlength = tvb_get_ntohl(tvb, offset);\r\noffset += 4;\r\nflags_item = proto_tree_add_item(frame_tree, hf_btsnoop_flags, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nflags_tree = proto_item_add_subtree(flags_item, ett_btsnoop_flags);\r\nflags = tvb_get_ntohl(tvb, offset);\r\nswitch (datalink) {\r\ncase 1001:\r\nproto_tree_add_item(flags_tree, hf_btsnoop_flags_h1_reserved, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_btsnoop_flags_h1_channel_type, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_btsnoop_flags_h1_direction, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 1002:\r\nproto_tree_add_item(flags_tree, hf_btsnoop_flags_h4_reserved, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_btsnoop_flags_h4_direction, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 2001:\r\nproto_tree_add_item(flags_tree, hf_btsnoop_flags_linux_monitor_adapter_id, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_btsnoop_flags_linux_monitor_opcode, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\noffset += 4;\r\nproto_tree_add_item(frame_tree, hf_btsnoop_cumulative_dropped_packets, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nts = tvb_get_ntoh64(tvb, offset) - G_GINT64_CONSTANT(0x00dcddb30f2f8000);\r\ntimestamp.secs = (guint)(ts / 1000000);\r\ntimestamp.nsecs =(guint)((ts % 1000000) * 1000);\r\nproto_tree_add_time(frame_tree, hf_btsnoop_timestamp_microseconds, tvb, offset, 8, &timestamp);\r\noffset += 8;\r\npayload_item = proto_tree_add_item(frame_tree, hf_btsnoop_payload, tvb, offset, length, ENC_NA);\r\npayload_tree = proto_item_add_subtree(payload_item, ett_btsnoop_payload);\r\nif (pref_dissect_next_layer) switch (datalink) {\\r\ncase 1001:\r\npinfo->num = frame_number;\r\npinfo->abs_ts = timestamp;\r\npinfo->pseudo_header->bthci.sent = (flags & 0x01) ? FALSE : TRUE;\r\nif (flags & 0x02) {\r\nif(pinfo->pseudo_header->bthci.sent)\r\npinfo->pseudo_header->bthci.channel = BTHCI_CHANNEL_COMMAND;\r\nelse\r\npinfo->pseudo_header->bthci.channel = BTHCI_CHANNEL_EVENT;\r\n} else {\r\npinfo->pseudo_header->bthci.channel = BTHCI_CHANNEL_ACL;\r\n}\r\nnext_tvb = tvb_new_subset(tvb, offset, length, length);\r\ncall_dissector(hci_h1_handle, next_tvb, pinfo, payload_tree);\r\nbreak;\r\ncase 1002:\r\npinfo->num = frame_number;\r\npinfo->abs_ts = timestamp;\r\npinfo->p2p_dir = (flags & 0x01) ? P2P_DIR_RECV : P2P_DIR_SENT;\r\nnext_tvb = tvb_new_subset(tvb, offset, length, length);\r\ncall_dissector(hci_h4_handle, next_tvb, pinfo, payload_tree);\r\nbreak;\r\ncase 2001:\r\npinfo->num = frame_number;\r\npinfo->abs_ts = timestamp;\r\npinfo->pseudo_header->btmon.opcode = flags & 0xFFFF;\r\npinfo->pseudo_header->btmon.adapter_id = flags >> 16;\r\nnext_tvb = tvb_new_subset(tvb, offset, length, length);\r\ncall_dissector(hci_mon_handle, next_tvb, pinfo, payload_tree);\r\nbreak;\r\ncase 1003:\r\ncase 1004:\r\ncase 2002:\r\nproto_tree_add_expert(payload_tree, pinfo, &ei_not_implemented_yet, tvb, offset, length);\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert(payload_tree, pinfo, &ei_unknown_data, tvb, offset, length);\r\n}\r\noffset += length;\r\nproto_item_set_len(frame_item, 4 * 4 + 8 + length);\r\nframe_number += 1;\r\n}\r\nreturn offset;\r\n}\r\nstatic gboolean\r\ndissect_btsnoop_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nreturn dissect_btsnoop(tvb, pinfo, tree, NULL) > 0;\r\n}\r\nvoid\r\nproto_register_btsnoop(void)\r\n{\r\nmodule_t *module;\r\nexpert_module_t *expert_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_btsnoop_header,\r\n{ "Header", "btsnoop.header",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_magic_bytes,\r\n{ "Magic Bytes", "btsnoop.header.magic_bytes",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_version,\r\n{ "Version", "btsnoop.header.version",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_datalink,\r\n{ "Datalink", "btsnoop.header.datalink",\r\nFT_UINT32, BASE_DEC_HEX, VALS(datalink_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_frame,\r\n{ "Frame", "btsnoop.frame",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_origin_length,\r\n{ "Origin Length", "btsnoop.frame.origin_length",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_included_length,\r\n{ "Included Length", "btsnoop.frame.included_length",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_flags,\r\n{ "Flags", "btsnoop.frame.flags",\r\nFT_UINT32, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_cumulative_dropped_packets,\r\n{ "Cumulative Dropped Packets", "btsnoop.frame.cumulative_dropped_packets",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_timestamp_microseconds,\r\n{ "Timestamp Microseconds", "btsnoop.frame.timestamp_microseconds",\r\nFT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_payload,\r\n{ "Payload", "btsnoop.frame.payload",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_flags_h1_reserved,\r\n{ "Reserved", "btsnoop.frame.flags.h1.reserved",\r\nFT_UINT32, BASE_HEX, NULL, 0xFFFFFFFC,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_flags_h1_channel_type,\r\n{ "Channel Type", "btsnoop.frame.flags.h1.channel_type",\r\nFT_UINT32, BASE_DEC, VALS(flags_h1_channel_type_vals), 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_flags_h1_direction,\r\n{ "Direction", "btsnoop.frame.flags.h1.direction",\r\nFT_UINT32, BASE_DEC, VALS(flags_direction_vals), 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_flags_h4_reserved,\r\n{ "Reserved", "btsnoop.frame.flags.h4.reserved",\r\nFT_UINT32, BASE_HEX, NULL, 0xFFFFFFFE,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_flags_h4_direction,\r\n{ "Direction", "btsnoop.frame.flags.h4.direction",\r\nFT_UINT32, BASE_DEC, VALS(flags_direction_vals), 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_flags_linux_monitor_opcode,\r\n{ "Opcode", "btsnoop.frame.flags.linux_monitor.opcode",\r\nFT_UINT16, BASE_HEX | BASE_EXT_STRING, &hci_mon_opcode_vals_ext, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btsnoop_flags_linux_monitor_adapter_id,\r\n{ "Adapter ID", "btsnoop.frame.flags.linux_monitor.adapter_id",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_malformed_frame, { "btsnoop.malformed_frame", PI_PROTOCOL, PI_WARN, "Malformed Frame", EXPFILL }},\r\n{ &ei_not_implemented_yet, { "btsnoop.not_implemented_yet", PI_PROTOCOL, PI_UNDECODED, "Not implemented yet", EXPFILL }},\r\n{ &ei_unknown_data, { "btsnoop.unknown_data", PI_PROTOCOL, PI_WARN, "Unknown data", EXPFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_btsnoop,\r\n&ett_btsnoop_header,\r\n&ett_btsnoop_frame,\r\n&ett_btsnoop_payload,\r\n&ett_btsnoop_flags,\r\n};\r\nproto_btsnoop = proto_register_protocol("Symbian OS BTSNOOP File Format", "BTSNOOP", "btsnoop");\r\nproto_register_field_array(proto_btsnoop, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nbtsnoop_handle = register_dissector("btsnoop", dissect_btsnoop, proto_btsnoop);\r\nmodule = prefs_register_protocol(proto_btsnoop, NULL);\r\nprefs_register_static_text_preference(module, "version",\r\n"BTSNOOP version: 1",\r\n"Version of file-format supported by this dissector.");\r\nprefs_register_bool_preference(module, "dissect_next_layer",\r\n"Dissect next layer",\r\n"Dissect next layer",\r\n&pref_dissect_next_layer);\r\nexpert_module = expert_register_protocol(proto_btsnoop);\r\nexpert_register_field_array(expert_module, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_btsnoop(void)\r\n{\r\nhci_h1_handle = find_dissector_add_dependency("hci_h1", proto_btsnoop);\r\nhci_h4_handle = find_dissector_add_dependency("hci_h4", proto_btsnoop);\r\nhci_mon_handle = find_dissector_add_dependency("hci_mon", proto_btsnoop);\r\nheur_dissector_add("wtap_file", dissect_btsnoop_heur, "BTSNOOP file", "btsnoop_wtap", proto_btsnoop, HEURISTIC_ENABLE);\r\n}
