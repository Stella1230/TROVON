static void dissect_pgsql_fe_msg(guchar type, guint length, tvbuff_t *tvb,\r\ngint n, proto_tree *tree,\r\npgsql_conn_data_t *conv_data)\r\n{\r\nguchar c;\r\ngint i, siz;\r\nchar *s;\r\nproto_tree *shrub;\r\nswitch (type) {\r\ncase 'p':\r\nsiz = tvb_strsize(tvb, n);\r\nproto_tree_add_item(tree, hf_passwd, tvb, n, siz, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase 'Q':\r\nsiz = tvb_strsize(tvb, n);\r\nproto_tree_add_item(tree, hf_query, tvb, n, siz, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase 'P':\r\nsiz = tvb_strsize(tvb, n);\r\nproto_tree_add_item(tree, hf_statement, tvb, n, siz, ENC_ASCII|ENC_NA);\r\nn += siz;\r\nsiz = tvb_strsize(tvb, n);\r\nproto_tree_add_item(tree, hf_query, tvb, n, siz, ENC_ASCII|ENC_NA);\r\nn += siz;\r\ni = tvb_get_ntohs(tvb, n);\r\nshrub = proto_tree_add_subtree_format(tree, tvb, n, 2, ett_values, NULL, "Parameters: %d", i);\r\nn += 2;\r\nwhile (i-- > 0) {\r\nproto_tree_add_item(shrub, hf_typeoid, tvb, n, 4, ENC_BIG_ENDIAN);\r\nn += 4;\r\n}\r\nbreak;\r\ncase 'B':\r\nsiz = tvb_strsize(tvb, n);\r\nproto_tree_add_item(tree, hf_portal, tvb, n, siz, ENC_ASCII|ENC_NA);\r\nn += siz;\r\nsiz = tvb_strsize(tvb, n);\r\nproto_tree_add_item(tree, hf_statement, tvb, n, siz, ENC_ASCII|ENC_NA);\r\nn += siz;\r\ni = tvb_get_ntohs(tvb, n);\r\nshrub = proto_tree_add_subtree_format(tree, tvb, n, 2, ett_values, NULL, "Parameter formats: %d", i);\r\nn += 2;\r\nwhile (i-- > 0) {\r\nproto_tree_add_item(shrub, hf_format, tvb, n, 2, ENC_BIG_ENDIAN);\r\nn += 2;\r\n}\r\ni = tvb_get_ntohs(tvb, n);\r\nshrub = proto_tree_add_subtree_format(tree, tvb, n, 2, ett_values, NULL, "Parameter values: %d", i);\r\nn += 2;\r\nwhile (i-- > 0) {\r\nsiz = tvb_get_ntohl(tvb, n);\r\nproto_tree_add_int(shrub, hf_val_length, tvb, n, 4, siz);\r\nn += 4;\r\nif (siz > 0) {\r\nproto_tree_add_item(shrub, hf_val_data, tvb, n, siz, ENC_NA);\r\nn += siz;\r\n}\r\n}\r\ni = tvb_get_ntohs(tvb, n);\r\nshrub = proto_tree_add_subtree_format(tree, tvb, n, 2, ett_values, NULL, "Result formats: %d", i);\r\nn += 2;\r\nwhile (i-- > 0) {\r\nproto_tree_add_item(shrub, hf_format, tvb, n, 2, ENC_BIG_ENDIAN);\r\nn += 2;\r\n}\r\nbreak;\r\ncase 'E':\r\nsiz = tvb_strsize(tvb, n);\r\nproto_tree_add_item(tree, hf_portal, tvb, n, siz, ENC_ASCII|ENC_NA);\r\nn += siz;\r\ni = tvb_get_ntohl(tvb, n);\r\nif (i == 0)\r\nproto_tree_add_uint_format_value(tree, hf_return, tvb, n, 4, i, "all rows");\r\nelse\r\nproto_tree_add_uint_format_value(tree, hf_return, tvb, n, 4, i, "%d rows", i);\r\nbreak;\r\ncase 'D':\r\ncase 'C':\r\nc = tvb_get_guint8(tvb, n);\r\nif (c == 'P')\r\ni = hf_portal;\r\nelse\r\ni = hf_statement;\r\nn += 1;\r\ns = tvb_get_stringz_enc(wmem_packet_scope(), tvb, n, &siz, ENC_ASCII);\r\nproto_tree_add_string(tree, i, tvb, n, siz, s);\r\nbreak;\r\ncase '\0':\r\ni = tvb_get_ntohl(tvb, n);\r\nn += 4;\r\nlength -= n;\r\nswitch (i) {\r\ncase 196608:\r\nwhile ((signed)length > 0) {\r\nsiz = tvb_strsize(tvb, n);\r\nlength -= siz;\r\nif ((signed)length <= 0) {\r\nbreak;\r\n}\r\nproto_tree_add_item(tree, hf_parameter_name, tvb, n, siz, ENC_ASCII|ENC_NA);\r\ni = tvb_strsize(tvb, n+siz);\r\nproto_tree_add_item(tree, hf_parameter_value, tvb, n + siz, i, ENC_ASCII|ENC_NA);\r\nlength -= i;\r\nn += siz+i;\r\nif (length == 1 && tvb_get_guint8(tvb, n) == 0)\r\nbreak;\r\n}\r\nbreak;\r\ncase 80877103:\r\nconv_data->ssl_requested = TRUE;\r\nbreak;\r\ncase 80877102:\r\nproto_tree_add_item(tree, hf_pid, tvb, n, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_key, tvb, n+4, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\nbreak;\r\ncase 'd':\r\nproto_tree_add_item(tree, hf_copydata, tvb, n, length-n+1, ENC_NA);\r\nbreak;\r\ncase 'f':\r\nsiz = tvb_strsize(tvb, n);\r\nproto_tree_add_item(tree, hf_error, tvb, n, siz, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase 'F':\r\nproto_tree_add_item(tree, hf_oid, tvb, n, 4, ENC_BIG_ENDIAN);\r\nn += 4;\r\ni = tvb_get_ntohs(tvb, n);\r\nshrub = proto_tree_add_subtree_format(tree, tvb, n, 2, ett_values, NULL, "Parameter formats: %d", i);\r\nn += 2;\r\nwhile (i-- > 0) {\r\nproto_tree_add_item(shrub, hf_format, tvb, n, 2, ENC_BIG_ENDIAN);\r\nn += 2;\r\n}\r\ni = tvb_get_ntohs(tvb, n);\r\nshrub = proto_tree_add_subtree_format(tree, tvb, n, 2, ett_values, NULL, "Parameter values: %d", i);\r\nn += 2;\r\nwhile (i-- > 0) {\r\nsiz = tvb_get_ntohl(tvb, n);\r\nproto_tree_add_item(shrub, hf_val_length, tvb, n, 4, ENC_BIG_ENDIAN);\r\nn += 4;\r\nif (siz > 0) {\r\nproto_tree_add_item(shrub, hf_val_data, tvb, n, siz, ENC_NA);\r\nn += siz;\r\n}\r\n}\r\nproto_tree_add_item(tree, hf_format, tvb, n, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\n}\r\nstatic void dissect_pgsql_be_msg(guchar type, guint length, tvbuff_t *tvb,\r\ngint n, proto_tree *tree)\r\n{\r\nguchar c;\r\ngint i, siz;\r\nchar *s, *t;\r\nproto_item *ti;\r\nproto_tree *shrub;\r\nswitch (type) {\r\ncase 'R':\r\nproto_tree_add_item(tree, hf_authtype, tvb, n, 4, ENC_BIG_ENDIAN);\r\ni = tvb_get_ntohl(tvb, n);\r\nif (i == 4 || i == 5) {\r\nn += 4;\r\nsiz = (i == 4 ? 2 : 4);\r\nproto_tree_add_item(tree, hf_salt, tvb, n, siz, ENC_NA);\r\n}\r\nbreak;\r\ncase 'K':\r\nproto_tree_add_item(tree, hf_pid, tvb, n, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_key, tvb, n+4, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 'S':\r\ns = tvb_get_stringz_enc(wmem_packet_scope(), tvb, n, &siz, ENC_ASCII);\r\nproto_tree_add_string(tree, hf_parameter_name, tvb, n, siz, s);\r\nn += siz;\r\nt = tvb_get_stringz_enc(wmem_packet_scope(), tvb, n, &i, ENC_ASCII);\r\nproto_tree_add_string(tree, hf_parameter_value, tvb, n, i, t);\r\nbreak;\r\ncase 't':\r\ni = tvb_get_ntohs(tvb, n);\r\nshrub = proto_tree_add_subtree_format(tree, tvb, n, 2, ett_values, NULL, "Parameters: %d", i);\r\nn += 2;\r\nwhile (i-- > 0) {\r\nproto_tree_add_item(shrub, hf_typeoid, tvb, n, 4, ENC_BIG_ENDIAN);\r\nn += 4;\r\n}\r\nbreak;\r\ncase 'T':\r\ni = tvb_get_ntohs(tvb, n);\r\nti = proto_tree_add_item(tree, hf_field_count, tvb, n, 2, ENC_BIG_ENDIAN);\r\nshrub = proto_item_add_subtree(ti, ett_values);\r\nn += 2;\r\nwhile (i-- > 0) {\r\nproto_tree *twig;\r\nsiz = tvb_strsize(tvb, n);\r\nti = proto_tree_add_item(shrub, hf_val_name, tvb, n, siz, ENC_ASCII|ENC_NA);\r\ntwig = proto_item_add_subtree(ti, ett_values);\r\nn += siz;\r\nproto_tree_add_item(twig, hf_tableoid, tvb, n, 4, ENC_BIG_ENDIAN);\r\nn += 4;\r\nproto_tree_add_item(twig, hf_val_idx, tvb, n, 2, ENC_BIG_ENDIAN);\r\nn += 2;\r\nproto_tree_add_item(twig, hf_typeoid, tvb, n, 4, ENC_BIG_ENDIAN);\r\nn += 4;\r\nproto_tree_add_item(twig, hf_val_length, tvb, n, 2, ENC_BIG_ENDIAN);\r\nn += 2;\r\nproto_tree_add_item(twig, hf_val_mod, tvb, n, 4, ENC_BIG_ENDIAN);\r\nn += 4;\r\nproto_tree_add_item(twig, hf_format, tvb, n, 2, ENC_BIG_ENDIAN);\r\nn += 2;\r\n}\r\nbreak;\r\ncase 'D':\r\ni = tvb_get_ntohs(tvb, n);\r\nti = proto_tree_add_item(tree, hf_field_count, tvb, n, 2, ENC_BIG_ENDIAN);\r\nshrub = proto_item_add_subtree(ti, ett_values);\r\nn += 2;\r\nwhile (i-- > 0) {\r\nsiz = tvb_get_ntohl(tvb, n);\r\nproto_tree_add_int(shrub, hf_val_length, tvb, n, 4, siz);\r\nn += 4;\r\nif (siz > 0) {\r\nproto_tree_add_item(shrub, hf_val_data, tvb, n, siz, ENC_NA);\r\nn += siz;\r\n}\r\n}\r\nbreak;\r\ncase 'C':\r\nsiz = tvb_strsize(tvb, n);\r\nproto_tree_add_item(tree, hf_tag, tvb, n, siz, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase 'Z':\r\nproto_tree_add_item(tree, hf_status, tvb, n, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 'E':\r\ncase 'N':\r\nlength -= 4;\r\nwhile ((signed)length > 0) {\r\nc = tvb_get_guint8(tvb, n);\r\nif (c == '\0')\r\nbreak;\r\ns = tvb_get_stringz_enc(wmem_packet_scope(), tvb, n+1, &siz, ENC_ASCII);\r\ni = hf_text;\r\nswitch (c) {\r\ncase 'S': i = hf_severity; break;\r\ncase 'C': i = hf_code; break;\r\ncase 'M': i = hf_message; break;\r\ncase 'D': i = hf_detail; break;\r\ncase 'H': i = hf_hint; break;\r\ncase 'P': i = hf_position; break;\r\ncase 'p': i = hf_internal_position; break;\r\ncase 'q': i = hf_internal_query; break;\r\ncase 'W': i = hf_where; break;\r\ncase 's': i = hf_schema_name; break;\r\ncase 't': i = hf_table_name; break;\r\ncase 'c': i = hf_column_name; break;\r\ncase 'd': i = hf_type_name; break;\r\ncase 'n': i = hf_constraint_name; break;\r\ncase 'F': i = hf_file; break;\r\ncase 'L': i = hf_line; break;\r\ncase 'R': i = hf_routine; break;\r\n}\r\nproto_tree_add_string(tree, i, tvb, n, siz+1, s);\r\nlength -= siz+1;\r\nn += siz+1;\r\n}\r\nbreak;\r\ncase 'A':\r\nproto_tree_add_item(tree, hf_pid, tvb, n, 4, ENC_BIG_ENDIAN);\r\nn += 4;\r\nsiz = tvb_strsize(tvb, n);\r\nproto_tree_add_item(tree, hf_condition, tvb, n, siz, ENC_ASCII|ENC_NA);\r\nn += siz;\r\nsiz = tvb_strsize(tvb, n);\r\nif (siz > 1)\r\nproto_tree_add_item(tree, hf_text, tvb, n, siz, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase 'G':\r\ncase 'H':\r\nproto_tree_add_item(tree, hf_format, tvb, n, 1, ENC_BIG_ENDIAN);\r\nn += 1;\r\ni = tvb_get_ntohs(tvb, n);\r\nshrub = proto_tree_add_subtree_format(tree, tvb, n, 2, ett_values, NULL, "Columns: %d", i);\r\nn += 2;\r\nwhile (i-- > 2) {\r\nproto_tree_add_item(shrub, hf_format, tvb, n, 2, ENC_BIG_ENDIAN);\r\nn += 2;\r\n}\r\nbreak;\r\ncase 'd':\r\nproto_tree_add_item(tree, hf_copydata, tvb, n, length-n+1, ENC_NA);\r\nbreak;\r\ncase 'V':\r\nsiz = tvb_get_ntohl(tvb, n);\r\nproto_tree_add_int(tree, hf_val_length, tvb, n, 4, siz);\r\nif (siz > 0)\r\nproto_tree_add_item(tree, hf_val_data, tvb, n+4, siz, ENC_NA);\r\nbreak;\r\n}\r\n}\r\nstatic guint\r\npgsql_length(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\ngint n = 0;\r\nguchar type;\r\nguint length;\r\ntype = tvb_get_guint8(tvb, offset);\r\nif (type != '\0')\r\nn = 1;\r\nlength = tvb_get_ntohl(tvb, offset+n);\r\nreturn length+n;\r\n}\r\nstatic int\r\ndissect_pgsql_msg(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti, *hidden_item;\r\nproto_tree *ptree;\r\nconversation_t *conversation;\r\npgsql_conn_data_t *conn_data;\r\ngint n;\r\nguchar type;\r\nconst char *typestr;\r\nguint length;\r\ngboolean fe = (pinfo->match_uint == pinfo->destport);\r\nconversation = find_or_create_conversation(pinfo);\r\nconn_data = (pgsql_conn_data_t *)conversation_get_proto_data(conversation, proto_pgsql);\r\nif (!conn_data) {\r\nconn_data = wmem_new(wmem_file_scope(), pgsql_conn_data_t);\r\nconn_data->ssl_requested = FALSE;\r\nconversation_add_proto_data(conversation, proto_pgsql, conn_data);\r\n}\r\nn = 0;\r\ntype = tvb_get_guint8(tvb, 0);\r\nif (type != '\0')\r\nn += 1;\r\nlength = tvb_get_ntohl(tvb, n);\r\nif (fe) {\r\nif (type == '\0') {\r\nguint tag = tvb_get_ntohl(tvb, 4);\r\nif (length == 16 && tag == 80877102)\r\ntypestr = "Cancel request";\r\nelse if (length == 8 && tag == 80877103)\r\ntypestr = "SSL request";\r\nelse if (tag == 196608)\r\ntypestr = "Startup message";\r\nelse\r\ntypestr = "Unknown";\r\n} else\r\ntypestr = val_to_str_const(type, fe_messages, "Unknown");\r\n}\r\nelse {\r\ntypestr = val_to_str_const(type, be_messages, "Unknown");\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s%c",\r\n( first_message ? "" : "/" ), type);\r\nfirst_message = FALSE;\r\n{\r\nti = proto_tree_add_item(tree, proto_pgsql, tvb, 0, -1, ENC_NA);\r\nptree = proto_item_add_subtree(ti, ett_pgsql);\r\nn = 1;\r\nif (type == '\0')\r\nn = 0;\r\nproto_tree_add_string(ptree, hf_type, tvb, 0, n, typestr);\r\nproto_tree_add_item(ptree, hf_length, tvb, n, 4, ENC_BIG_ENDIAN);\r\nhidden_item = proto_tree_add_boolean(ptree, hf_frontend, tvb, 0, 0, fe);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nn += 4;\r\nif (fe)\r\ndissect_pgsql_fe_msg(type, length, tvb, n, ptree, conn_data);\r\nelse\r\ndissect_pgsql_be_msg(type, length, tvb, n, ptree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_pgsql(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\nconversation_t *conversation;\r\npgsql_conn_data_t *conn_data;\r\nfirst_message = TRUE;\r\nconversation = find_or_create_conversation(pinfo);\r\nconn_data = (pgsql_conn_data_t *)conversation_get_proto_data(conversation, proto_pgsql);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "PGSQL");\r\ncol_set_str(pinfo->cinfo, COL_INFO,\r\n(pinfo->match_uint == pinfo->destport) ?\r\n">" : "<");\r\nif (conn_data && conn_data->ssl_requested) {\r\nswitch (tvb_get_guint8(tvb, 0)) {\r\ncase 'S':\r\nssl_starttls_ack(ssl_handle, pinfo, pgsql_handle);\r\nbreak;\r\ncase 'N':\r\ndefault:\r\nbreak;\r\n}\r\nconn_data->ssl_requested = FALSE;\r\nreturn tvb_captured_length(tvb);\r\n}\r\ntcp_dissect_pdus(tvb, pinfo, tree, pgsql_desegment, 5,\r\npgsql_length, dissect_pgsql_msg, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_pgsql(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_frontend,\r\n{ "Frontend", "pgsql.frontend", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"True for messages from the frontend, false otherwise.",\r\nHFILL }\r\n},\r\n{ &hf_type,\r\n{ "Type", "pgsql.type", FT_STRING, BASE_NONE, NULL, 0,\r\n"A one-byte message type identifier.", HFILL }\r\n},\r\n{ &hf_length,\r\n{ "Length", "pgsql.length", FT_UINT32, BASE_DEC, NULL, 0,\r\n"The length of the message (not including the type).",\r\nHFILL }\r\n},\r\n{ &hf_parameter_name,\r\n{ "Parameter name", "pgsql.parameter_name", FT_STRINGZ,\r\nBASE_NONE, NULL, 0, "The name of a database parameter.",\r\nHFILL }\r\n},\r\n{ &hf_parameter_value,\r\n{ "Parameter value", "pgsql.parameter_value", FT_STRINGZ,\r\nBASE_NONE, NULL, 0, "The value of a database parameter.",\r\nHFILL }\r\n},\r\n{ &hf_query,\r\n{ "Query", "pgsql.query", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"A query string.", HFILL }\r\n},\r\n{ &hf_passwd,\r\n{ "Password", "pgsql.password", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"A password.", HFILL }\r\n},\r\n{ &hf_authtype,\r\n{ "Authentication type", "pgsql.authtype", FT_INT32, BASE_DEC,\r\nVALS(auth_types), 0,\r\n"The type of authentication requested by the backend.", HFILL }\r\n},\r\n{ &hf_salt,\r\n{ "Salt value", "pgsql.salt", FT_BYTES, BASE_NONE, NULL, 0,\r\n"The salt to use while encrypting a password.", HFILL }\r\n},\r\n{ &hf_statement,\r\n{ "Statement", "pgsql.statement", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"The name of a prepared statement.", HFILL }\r\n},\r\n{ &hf_portal,\r\n{ "Portal", "pgsql.portal", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"The name of a portal.", HFILL }\r\n},\r\n{ &hf_return,\r\n{ "Returns", "pgsql.returns", FT_UINT32, BASE_DEC,\r\nNULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_tag,\r\n{ "Tag", "pgsql.tag", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"A completion tag.", HFILL }\r\n},\r\n{ &hf_status,\r\n{ "Status", "pgsql.status", FT_UINT8, BASE_DEC, VALS(status_vals),\r\n0, "The transaction status of the backend.", HFILL }\r\n},\r\n{ &hf_copydata,\r\n{ "Copy data", "pgsql.copydata", FT_BYTES, BASE_NONE, NULL, 0,\r\n"Data sent following a Copy-in or Copy-out response.", HFILL }\r\n},\r\n{ &hf_error,\r\n{ "Error", "pgsql.error", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"An error message.", HFILL }\r\n},\r\n{ &hf_pid,\r\n{ "PID", "pgsql.pid", FT_UINT32, BASE_DEC, NULL, 0,\r\n"The process ID of a backend.", HFILL }\r\n},\r\n{ &hf_key,\r\n{ "Key", "pgsql.key", FT_UINT32, BASE_DEC, NULL, 0,\r\n"The secret key used by a particular backend.", HFILL }\r\n},\r\n{ &hf_condition,\r\n{ "Condition", "pgsql.condition", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"The name of a NOTIFY condition.", HFILL }\r\n},\r\n{ &hf_text,\r\n{ "Text", "pgsql.text", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"Text from the backend.", HFILL }\r\n},\r\n{ &hf_tableoid,\r\n{ "Table OID", "pgsql.oid.table", FT_UINT32, BASE_DEC, NULL, 0,\r\n"The object identifier of a table.", HFILL }\r\n},\r\n{ &hf_typeoid,\r\n{ "Type OID", "pgsql.oid.type", FT_UINT32, BASE_DEC, NULL, 0,\r\n"The object identifier of a type.", HFILL }\r\n},\r\n{ &hf_oid,\r\n{ "OID", "pgsql.oid", FT_UINT32, BASE_DEC, NULL, 0,\r\n"An object identifier.", HFILL }\r\n},\r\n{ &hf_format,\r\n{ "Format", "pgsql.format", FT_UINT16, BASE_DEC, VALS(format_vals),\r\n0, "A format specifier.", HFILL }\r\n},\r\n{ &hf_field_count,\r\n{ "Field count", "pgsql.field.count", FT_UINT16, BASE_DEC, NULL, 0,\r\n"The number of fields within a row.", HFILL }\r\n},\r\n{ &hf_val_name,\r\n{ "Column name", "pgsql.col.name", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"The name of a column.", HFILL }\r\n},\r\n{ &hf_val_idx,\r\n{ "Column index", "pgsql.col.index", FT_UINT32, BASE_DEC, NULL, 0,\r\n"The position of a column within a row.", HFILL }\r\n},\r\n{ &hf_val_length,\r\n{ "Column length", "pgsql.val.length", FT_INT32, BASE_DEC, NULL, 0,\r\n"The length of a parameter value, in bytes. -1 means NULL.",\r\nHFILL }\r\n},\r\n{ &hf_val_data,\r\n{ "Data", "pgsql.val.data", FT_BYTES, BASE_NONE, NULL, 0,\r\n"Parameter data.", HFILL }\r\n},\r\n{ &hf_val_mod,\r\n{ "Type modifier", "pgsql.col.typemod", FT_INT32, BASE_DEC, NULL, 0,\r\n"The type modifier for a column.", HFILL }\r\n},\r\n{ &hf_severity,\r\n{ "Severity", "pgsql.severity", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"Message severity.", HFILL }\r\n},\r\n{ &hf_code,\r\n{ "Code", "pgsql.code", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"SQLState code.", HFILL }\r\n},\r\n{ &hf_message,\r\n{ "Message", "pgsql.message", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"Error message.", HFILL }\r\n},\r\n{ &hf_detail,\r\n{ "Detail", "pgsql.detail", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"Detailed error message.", HFILL }\r\n},\r\n{ &hf_hint,\r\n{ "Hint", "pgsql.hint", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"A suggestion to resolve an error.", HFILL }\r\n},\r\n{ &hf_position,\r\n{ "Position", "pgsql.position", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"The index of the error within the query string.", HFILL }\r\n},\r\n{ &hf_internal_position,\r\n{ "Position (Internal)", "pgsql.internal_position", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"The index of the error within the internally-generated query string.", HFILL }\r\n},\r\n{ &hf_internal_query,\r\n{ "Query (Internal)", "pgsql.internal_query", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"The internally-generated query string", HFILL }\r\n},\r\n{ &hf_where,\r\n{ "Context", "pgsql.where", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"The context in which an error occurred.", HFILL }\r\n},\r\n{ &hf_schema_name,\r\n{ "Schema", "pgsql.schema_name", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"The schema with which an error is associated.", HFILL }\r\n},\r\n{ &hf_table_name,\r\n{ "Table", "pgsql.table_name", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"The table with which an error is associated.", HFILL }\r\n},\r\n{ &hf_column_name,\r\n{ "Column", "pgsql.column_name", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"The column with which an error is associated.", HFILL }\r\n},\r\n{ &hf_type_name,\r\n{ "Type", "pgsql.type_name", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"The date type with which an error is associated.", HFILL }\r\n},\r\n{ &hf_constraint_name,\r\n{ "Constraint", "pgsql.constraint_name", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"The constraint with which an error is associated.", HFILL }\r\n},\r\n{ &hf_file,\r\n{ "File", "pgsql.file", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"The source-code file where an error was reported.", HFILL }\r\n},\r\n{ &hf_line,\r\n{ "Line", "pgsql.line", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"The line number on which an error was reported.", HFILL }\r\n},\r\n{ &hf_routine,\r\n{ "Routine", "pgsql.routine", FT_STRINGZ, BASE_NONE, NULL, 0,\r\n"The routine that reported an error.", HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_pgsql,\r\n&ett_values\r\n};\r\nmodule_t *mod_pgsql;\r\nproto_pgsql = proto_register_protocol("PostgreSQL", "PGSQL", "pgsql");\r\nproto_register_field_array(proto_pgsql, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nmod_pgsql = prefs_register_protocol(proto_pgsql, proto_reg_handoff_pgsql);\r\nprefs_register_uint_preference(\r\nmod_pgsql, "tcp.port", "PGSQL TCP port", "Set the port for PGSQL "\r\n"messages (if different from the default of 5432)", 10, &pgsql_port\r\n);\r\n}\r\nvoid\r\nproto_reg_handoff_pgsql(void)\r\n{\r\nstatic gboolean initialized = FALSE;\r\nstatic guint saved_pgsql_port;\r\nif (!initialized) {\r\npgsql_handle = create_dissector_handle(dissect_pgsql, proto_pgsql);\r\ninitialized = TRUE;\r\n} else {\r\ndissector_delete_uint("tcp.port", saved_pgsql_port, pgsql_handle);\r\n}\r\ndissector_add_uint("tcp.port", pgsql_port, pgsql_handle);\r\nsaved_pgsql_port = pgsql_port;\r\nssl_handle = find_dissector("ssl");\r\n}
