static void\r\ndissect_int_interface_identifier_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 number_of_ids, id_number;\r\ngint offset;\r\nnumber_of_ids= (tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET) - PARAMETER_HEADER_LENGTH) / INT_INTERFACE_ID_LENGTH;\r\noffset = PARAMETER_VALUE_OFFSET;\r\nproto_item_append_text(parameter_item, " (");\r\nfor (id_number = 0; id_number < number_of_ids; id_number++) {\r\nproto_tree_add_item(parameter_tree, hf_int_interface_id, parameter_tvb, offset, INT_INTERFACE_ID_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_append_text(parameter_item, (id_number > 0) ? ", %d" : "%d", tvb_get_ntohl(parameter_tvb, offset));\r\noffset += INT_INTERFACE_ID_LENGTH;\r\n}\r\nproto_item_append_text(parameter_item, ")");\r\n}\r\nstatic void\r\ndissect_text_interface_identifier_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 interface_id_length;\r\ninterface_id_length = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET) - PARAMETER_HEADER_LENGTH;\r\nproto_tree_add_item(parameter_tree, hf_text_interface_id, parameter_tvb, TEXT_INTERFACE_ID_OFFSET, interface_id_length, ENC_ASCII|ENC_NA);\r\nproto_item_append_text(parameter_item, " (%.*s)", interface_id_length,\r\ntvb_format_text(parameter_tvb, TEXT_INTERFACE_ID_OFFSET, interface_id_length));\r\n}\r\nstatic void\r\ndissect_info_string_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 info_string_length;\r\ninfo_string_length = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET) - PARAMETER_HEADER_LENGTH;\r\nproto_tree_add_item(parameter_tree, hf_info_string, parameter_tvb, INFO_STRING_OFFSET, info_string_length, ENC_ASCII|ENC_NA);\r\nproto_item_append_text(parameter_item, " (%.*s)", info_string_length,\r\ntvb_format_text(parameter_tvb, INFO_STRING_OFFSET, info_string_length));\r\n}\r\nstatic void\r\ndissect_dlci_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree)\r\n{\r\nproto_tree_add_item(parameter_tree, hf_dlci_zero_bit, parameter_tvb, DLCI_SAPI_OFFSET, DLCI_SAPI_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parameter_tree, hf_dlci_spare_bit, parameter_tvb, DLCI_SAPI_OFFSET, DLCI_SAPI_LENGTH, ENC_BIG_ENDIAN);\r\nif(global_iua_gsm_sapis) {\r\nproto_tree_add_item(parameter_tree, hf_dlci_gsm_sapi, parameter_tvb, DLCI_SAPI_OFFSET, DLCI_SAPI_LENGTH, ENC_BIG_ENDIAN);\r\n} else {\r\nproto_tree_add_item(parameter_tree, hf_dlci_sapi, parameter_tvb, DLCI_SAPI_OFFSET, DLCI_SAPI_LENGTH, ENC_BIG_ENDIAN);\r\n}\r\nsapi_val = (tvb_get_guint8(parameter_tvb, DLCI_SAPI_OFFSET) & SAPI_MASK) >> SAPI_SHIFT;\r\nsapi_val_assigned = TRUE;\r\nproto_tree_add_item(parameter_tree, hf_dlci_one_bit, parameter_tvb, DLCI_TEI_OFFSET, DLCI_TEI_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parameter_tree, hf_dlci_tei, parameter_tvb, DLCI_TEI_OFFSET, DLCI_TEI_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parameter_tree, hf_dlci_spare, parameter_tvb, DLCI_SPARE_OFFSET, DLCI_SPARE_LENGTH, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_diagnostic_information_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 diag_info_length;\r\ndiag_info_length = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET) - PARAMETER_HEADER_LENGTH;\r\nproto_tree_add_item(parameter_tree, hf_diag_info, parameter_tvb, PARAMETER_VALUE_OFFSET, diag_info_length, ENC_NA);\r\nproto_item_append_text(parameter_item, " (%u byte%s)", diag_info_length, plurality(diag_info_length, "", "s"));\r\n}\r\nstatic void\r\ndissect_integer_range_interface_identifier_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 number_of_ranges, range_number;\r\ngint offset;\r\nnumber_of_ranges = (tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET) - PARAMETER_HEADER_LENGTH) / INTERVAL_LENGTH;\r\noffset = PARAMETER_VALUE_OFFSET;\r\nproto_item_append_text(parameter_item, " (");\r\nfor (range_number = 0; range_number < number_of_ranges; range_number++) {\r\nproto_tree_add_item(parameter_tree, hf_interface_range_start, parameter_tvb, offset + START_OFFSET, START_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parameter_tree, hf_interface_range_end, parameter_tvb, offset + END_OFFSET, END_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_append_text(parameter_item, (range_number > 0) ? ", %d-%d" : "%d-%d",\r\ntvb_get_ntohl(parameter_tvb, offset + START_OFFSET), tvb_get_ntohl(parameter_tvb, offset + END_OFFSET));\r\noffset += INTERVAL_LENGTH;\r\n}\r\nproto_item_append_text(parameter_item, ")");\r\n}\r\nstatic void\r\ndissect_heartbeat_data_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 heartbeat_data_length;\r\nheartbeat_data_length = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET) - PARAMETER_HEADER_LENGTH;\r\nproto_tree_add_item(parameter_tree, hf_heartbeat_data, parameter_tvb, HEARTBEAT_DATA_OFFSET, heartbeat_data_length, ENC_NA);\r\nproto_item_append_text(parameter_item, " (%u byte%s)", heartbeat_data_length, plurality(heartbeat_data_length, "", "s"));\r\n}\r\nstatic void\r\ndissect_asp_reason_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nproto_tree_add_item(parameter_tree, hf_asp_reason, parameter_tvb, ASP_REASON_OFFSET, ASP_REASON_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_append_text(parameter_item, " (%s)", val_to_str_const(tvb_get_ntohl(parameter_tvb, ASP_REASON_OFFSET), asp_reason_values, "unknown"));\r\n}\r\nstatic void\r\ndissect_traffic_mode_type_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nproto_tree_add_item(parameter_tree, hf_traffic_mode_type, parameter_tvb, TRAFFIC_MODE_TYPE_OFFSET, TRAFFIC_MODE_TYPE_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_append_text(parameter_item, " (%s)",\r\nval_to_str_const(tvb_get_ntohl(parameter_tvb, TRAFFIC_MODE_TYPE_OFFSET), traffic_mode_type_values, "unknown"));\r\n}\r\nstatic void\r\ndissect_error_code_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nproto_tree_add_item(parameter_tree, support_IG?hf_error_code_ig:hf_error_code, parameter_tvb, ERROR_CODE_OFFSET, ERROR_CODE_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_append_text(parameter_item, " (%s)",\r\nval_to_str_const(tvb_get_ntohl(parameter_tvb, ERROR_CODE_OFFSET), support_IG?error_code_ig_values:error_code_values, "unknown"));\r\n}\r\nstatic void\r\ndissect_status_type_identification_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 status_type, status_id;\r\nstatus_type = tvb_get_ntohs(parameter_tvb, STATUS_TYPE_OFFSET);\r\nstatus_id = tvb_get_ntohs(parameter_tvb, STATUS_IDENT_OFFSET);\r\nproto_tree_add_item(parameter_tree, hf_status_type, parameter_tvb, STATUS_TYPE_OFFSET, STATUS_TYPE_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint_format_value(parameter_tree, hf_status_id, parameter_tvb, STATUS_IDENT_OFFSET, STATUS_IDENT_LENGTH,\r\nstatus_id, "%u (%s)", status_id,\r\nval_to_str_const(status_type * 256 * 256 + status_id, support_IG?status_type_id_ig_values:status_type_id_values, "unknown"));\r\nproto_item_append_text(parameter_item, " (%s)",\r\nval_to_str_const(status_type * 256 * 256 + status_id, support_IG?status_type_id_ig_values:status_type_id_values, "unknown status information"));\r\n}\r\nstatic void\r\ndissect_protocol_data_parameter(tvbuff_t *parameter_tvb, proto_item *parameter_item, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint16 protocol_data_length;\r\ntvbuff_t *protocol_data_tvb;\r\nprotocol_data_length = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET) - PARAMETER_HEADER_LENGTH;\r\nprotocol_data_tvb = tvb_new_subset_length(parameter_tvb, PROTOCOL_DATA_OFFSET, protocol_data_length);\r\nproto_item_append_text(parameter_item, " (%u byte%s)", protocol_data_length, plurality(protocol_data_length, "", "s"));\r\nif(sapi_val_assigned == FALSE)\r\n{\r\nreturn;\r\n}\r\nif(global_iua_gsm_sapis) {\r\nif (!dissector_try_uint(lapd_gsm_sapi_dissector_table, sapi_val, protocol_data_tvb, pinfo, tree))\r\ncall_data_dissector(protocol_data_tvb, pinfo, tree);\r\nreturn;\r\n}\r\nswitch(sapi_val)\r\n{\r\ncase SAPI_VAL_CALL_CONTROL:\r\ncase SAPI_VAL_Q931_PACKET:\r\ncall_dissector(q931_handle, protocol_data_tvb, pinfo, tree);\r\nbreak;\r\ncase SAPI_VAL_X25:\r\ncall_dissector(x25_handle, protocol_data_tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndissect_release_reason_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nproto_tree_add_item(parameter_tree, hf_release_reason, parameter_tvb, RELEASE_REASON_OFFSET, RELEASE_REASON_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_append_text(parameter_item, " (%s)",\r\nval_to_str_const(tvb_get_ntohl(parameter_tvb, RELEASE_REASON_OFFSET), release_reason_values, "unknown"));\r\n}\r\nstatic void\r\ndissect_tei_status_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nproto_tree_add_item(parameter_tree, hf_tei_status, parameter_tvb, TEI_STATUS_OFFSET, TEI_STATUS_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_append_text(parameter_item, " (%s)",\r\nval_to_str_const(tvb_get_ntohl(parameter_tvb, TEI_STATUS_OFFSET), tei_status_values, "unknown"));\r\n}\r\nstatic void\r\ndissect_asp_identifier_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nproto_tree_add_item(parameter_tree, hf_asp_id, parameter_tvb, ASP_ID_OFFSET, ASP_ID_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_append_text(parameter_item, " (%u)", tvb_get_ntohl(parameter_tvb, ASP_ID_OFFSET));\r\n}\r\nstatic void\r\ndissect_unknown_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 parameter_value_length;\r\nparameter_value_length = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET) - PARAMETER_HEADER_LENGTH;\r\nif (parameter_value_length > 0)\r\nproto_tree_add_item(parameter_tree, hf_parameter_value, parameter_tvb, PARAMETER_VALUE_OFFSET, parameter_value_length, ENC_NA);\r\nproto_item_append_text(parameter_item, " with tag %u and %u byte%s value",\r\ntvb_get_ntohs(parameter_tvb, PARAMETER_TAG_OFFSET), parameter_value_length, plurality(parameter_value_length, "", "s"));\r\n}\r\nstatic void\r\ndissect_parameter(tvbuff_t *parameter_tvb, packet_info *pinfo, proto_tree *tree, proto_tree *iua_tree)\r\n{\r\nguint16 tag, length, padding_length;\r\nproto_item *parameter_item;\r\nproto_tree *parameter_tree;\r\ntag = tvb_get_ntohs(parameter_tvb, PARAMETER_TAG_OFFSET);\r\nlength = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET);\r\npadding_length = tvb_reported_length(parameter_tvb) - length;\r\nparameter_tree = proto_tree_add_subtree_format(iua_tree, parameter_tvb, PARAMETER_HEADER_OFFSET, -1, ett_iua_parameter, &parameter_item,\r\n"%s parameter", val_to_str_const(tag, support_IG?parameter_tag_ig_values:parameter_tag_values, "Unknown"));\r\nproto_tree_add_item(parameter_tree, support_IG?hf_parameter_tag_ig:hf_parameter_tag, parameter_tvb, PARAMETER_TAG_OFFSET, PARAMETER_TAG_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parameter_tree, hf_parameter_length, parameter_tvb, PARAMETER_LENGTH_OFFSET, PARAMETER_LENGTH_LENGTH, ENC_BIG_ENDIAN);\r\nswitch(tag) {\r\ncase INT_INTERFACE_IDENTIFIER_PARAMETER_TAG:\r\ndissect_int_interface_identifier_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase TEXT_INTERFACE_IDENTIFIER_PARAMETER_TAG:\r\ndissect_text_interface_identifier_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase INFO_PARAMETER_TAG:\r\ndissect_info_string_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase DLCI_PARAMETER_TAG:\r\ndissect_dlci_parameter(parameter_tvb, parameter_tree);\r\nbreak;\r\ncase DIAGNOSTIC_INFORMATION_PARAMETER_TAG:\r\ndissect_diagnostic_information_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase INTEGER_RANGE_INTERFACE_IDENTIFIER_PARAMETER_TAG:\r\ndissect_integer_range_interface_identifier_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase HEARTBEAT_DATA_PARAMETER_TAG:\r\ndissect_heartbeat_data_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase ASP_REASON_PARAMETER_TAG:\r\nif (support_IG)\r\ndissect_unknown_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nelse\r\ndissect_asp_reason_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase TRAFFIC_MODE_TYPE_PARAMETER_TAG:\r\ndissect_traffic_mode_type_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase ERROR_CODE_PARAMETER_TAG:\r\ndissect_error_code_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase STATUS_TYPE_INDENTIFICATION_PARAMETER_TAG:\r\ndissect_status_type_identification_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase PROTOCOL_DATA_PARAMETER_TAG:\r\ndissect_protocol_data_parameter(parameter_tvb, parameter_item, pinfo, tree);\r\nbreak;\r\ncase RELEASE_REASON_PARAMETER_TAG:\r\ndissect_release_reason_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase TEI_STATUS_PARAMETER_TAG:\r\ndissect_tei_status_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase ASP_IDENTIFIER_PARAMETER_TAG:\r\nif (support_IG)\r\ndissect_asp_identifier_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nelse\r\ndissect_unknown_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ndefault:\r\ndissect_unknown_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\n};\r\nif (padding_length > 0)\r\nproto_tree_add_item(parameter_tree, hf_parameter_padding, parameter_tvb, PARAMETER_HEADER_OFFSET + length, padding_length, ENC_NA);\r\n}\r\nstatic void\r\ndissect_parameters(tvbuff_t *parameters_tvb, packet_info *pinfo, proto_tree *tree, proto_tree *iua_tree)\r\n{\r\ngint offset, length, total_length, remaining_length;\r\ntvbuff_t *parameter_tvb;\r\noffset = 0;\r\nwhile((remaining_length = tvb_reported_length_remaining(parameters_tvb, offset))) {\r\nlength = tvb_get_ntohs(parameters_tvb, offset + PARAMETER_LENGTH_OFFSET);\r\ntotal_length = ADD_PADDING(length);\r\nif (remaining_length >= length)\r\ntotal_length = MIN(total_length, remaining_length);\r\nparameter_tvb = tvb_new_subset_length(parameters_tvb, offset, total_length);\r\ndissect_parameter(parameter_tvb, pinfo, tree, iua_tree);\r\noffset += total_length;\r\n}\r\n}\r\nstatic void\r\ndissect_common_header(tvbuff_t *common_header_tvb, packet_info *pinfo, proto_tree *iua_tree)\r\n{\r\nguint8 message_class, message_type;\r\nmessage_class = tvb_get_guint8(common_header_tvb, MESSAGE_CLASS_OFFSET);\r\nmessage_type = tvb_get_guint8(common_header_tvb, MESSAGE_TYPE_OFFSET);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s ", val_to_str_const(message_class * 256 + message_type, support_IG?message_class_type_acro_ig_values:message_class_type_acro_values, "UNKNOWN"));\r\nif (iua_tree) {\r\nproto_tree_add_item(iua_tree, hf_version, common_header_tvb, VERSION_OFFSET, VERSION_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(iua_tree, hf_reserved, common_header_tvb, RESERVED_OFFSET, RESERVED_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(iua_tree, hf_message_class, common_header_tvb, MESSAGE_CLASS_OFFSET, MESSAGE_CLASS_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint_format_value(iua_tree, hf_message_type,\r\ncommon_header_tvb, MESSAGE_TYPE_OFFSET, MESSAGE_TYPE_LENGTH,\r\nmessage_type, "%u (%s)",\r\nmessage_type, val_to_str_const(message_class * 256 + message_type, support_IG?message_class_type_ig_values:message_class_type_values, "reserved"));\r\nproto_tree_add_item(iua_tree, hf_message_length, common_header_tvb, MESSAGE_LENGTH_OFFSET, MESSAGE_LENGTH_LENGTH, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_iua_message(tvbuff_t *message_tvb, packet_info *pinfo, proto_tree *tree, proto_tree *iua_tree)\r\n{\r\ntvbuff_t *common_header_tvb, *parameters_tvb;\r\nsapi_val_assigned = FALSE;\r\ncommon_header_tvb = tvb_new_subset_length(message_tvb, COMMON_HEADER_OFFSET, COMMON_HEADER_LENGTH);\r\nparameters_tvb = tvb_new_subset_remaining(message_tvb, PARAMETERS_OFFSET);\r\ndissect_common_header(common_header_tvb, pinfo, iua_tree);\r\ndissect_parameters(parameters_tvb, pinfo, tree, iua_tree);\r\n}\r\nstatic int\r\ndissect_iua(tvbuff_t *message_tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *iua_item;\r\nproto_tree *iua_tree;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, support_IG?"IUA (RFC 3057 + IG)":"IUA (RFC 3057)");\r\niua_item = proto_tree_add_item(tree, proto_iua, message_tvb, 0, -1, ENC_NA);\r\niua_tree = proto_item_add_subtree(iua_item, ett_iua);\r\ndissect_iua_message(message_tvb, pinfo, tree, iua_tree);\r\nreturn tvb_captured_length(message_tvb);\r\n}\r\nvoid\r\nproto_register_iua(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_int_interface_id, { "Integer interface identifier", "iua.int_interface_identifier", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_text_interface_id, { "Text interface identifier", "iua.text_interface_identifier", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_info_string, { "Info string", "iua.info_string", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_dlci_zero_bit, { "Zero bit", "iua.dlci_zero_bit", FT_BOOLEAN, 8, NULL, ZERO_BIT_MASK, NULL, HFILL } },\r\n{ &hf_dlci_spare_bit, { "Spare bit", "iua.dlci_spare_bit", FT_BOOLEAN, 8, NULL, SPARE_BIT_MASK, NULL, HFILL } },\r\n{ &hf_dlci_sapi, { "SAPI", "iua.dlci_sapi", FT_UINT8, BASE_HEX, VALS(sapi_values), SAPI_MASK, NULL, HFILL } },\r\n{ &hf_dlci_gsm_sapi, { "SAPI", "iua.dlci_gsm_sapi", FT_UINT8, BASE_HEX, VALS(gsm_sapi_vals), SAPI_MASK, NULL, HFILL } },\r\n{ &hf_dlci_one_bit, { "One bit", "iua.dlci_one_bit", FT_BOOLEAN, 8, NULL, ONE_BIT_MASK, NULL, HFILL } },\r\n{ &hf_dlci_tei, { "TEI", "iua.dlci_tei", FT_UINT8, BASE_HEX, NULL, TEI_MASK, NULL, HFILL } },\r\n{ &hf_dlci_spare, { "Spare", "iua.dlci_spare", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_diag_info, { "Diagnostic information", "iua.diagnostic_information", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_interface_range_start, { "Start", "iua.interface_range_start", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_interface_range_end, { "End", "iua.interface_range_end", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_heartbeat_data, { "Heartbeat data", "iua.heartbeat_data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_asp_reason, { "Reason", "iua.asp_reason", FT_UINT32, BASE_HEX, VALS(asp_reason_values), 0x0, NULL, HFILL } },\r\n{ &hf_traffic_mode_type, { "Traffic mode type", "iua.traffic_mode_type", FT_UINT32, BASE_HEX, VALS(traffic_mode_type_values), 0x0, NULL, HFILL } },\r\n{ &hf_error_code, { "Error code", "iua.error_code", FT_UINT32, BASE_DEC, VALS(error_code_values), 0x0, NULL, HFILL } },\r\n{ &hf_error_code_ig, { "Error code", "iua.error_code", FT_UINT32, BASE_DEC, VALS(error_code_ig_values), 0x0, NULL, HFILL } },\r\n{ &hf_status_type, { "Status type", "iua.status_type", FT_UINT16, BASE_DEC, VALS(status_type_values), 0x0, NULL, HFILL } },\r\n{ &hf_status_id, { "Status identification", "iua.status_identification", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_release_reason, { "Reason", "iua.release_reason", FT_UINT32, BASE_HEX, VALS(release_reason_values), 0x0, NULL, HFILL } },\r\n{ &hf_tei_status, { "TEI status", "iua.tei_status", FT_UINT32, BASE_HEX, VALS(tei_status_values), 0x0, NULL, HFILL } },\r\n{ &hf_asp_id, { "ASP identifier", "iua.asp_identifier", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_parameter_tag, { "Parameter Tag", "iua.parameter_tag", FT_UINT16, BASE_DEC, VALS(parameter_tag_values), 0x0, NULL, HFILL } },\r\n{ &hf_parameter_tag_ig, { "Parameter Tag", "iua.parameter_tag", FT_UINT16, BASE_DEC, VALS(parameter_tag_ig_values), 0x0, NULL, HFILL } },\r\n{ &hf_parameter_length, { "Parameter length", "iua.parameter_length", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_parameter_value, { "Parameter value", "iua.parameter_value", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_parameter_padding, { "Parameter padding", "iua.parameter_padding", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_version, { "Version", "iua.version", FT_UINT8, BASE_DEC, VALS(protocol_version_values), 0x0, NULL, HFILL } },\r\n{ &hf_reserved, { "Reserved", "iua.reserved", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_message_class, { "Message class", "iua.message_class", FT_UINT8, BASE_DEC, VALS(message_class_values), 0x0, NULL, HFILL } },\r\n{ &hf_message_type, { "Message Type", "iua.message_type", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_message_length, { "Message length", "iua.message_length", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n};\r\nstatic gint *ett[] = {\r\n&ett_iua,\r\n&ett_iua_parameter,\r\n};\r\nproto_iua = proto_register_protocol("ISDN Q.921-User Adaptation Layer", "IUA", "iua");\r\niua_module = prefs_register_protocol(proto_iua, NULL);\r\nproto_register_field_array(proto_iua, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nprefs_register_bool_preference(iua_module, "support_ig", "Support Implementers Guide", "Support Implementers Guide (version 01)", &support_IG);\r\nprefs_register_bool_preference(iua_module, "use_gsm_sapi_values",\r\n"Use GSM SAPI values",\r\n"Use SAPI values as specified in TS 48 056",\r\n&global_iua_gsm_sapis);\r\nregister_dissector("iua", dissect_iua, proto_iua);\r\n}\r\nvoid\r\nproto_reg_handoff_iua(void)\r\n{\r\ndissector_handle_t iua_handle;\r\niua_handle = find_dissector("iua");\r\nq931_handle = find_dissector_add_dependency("q931", proto_iua);\r\nx25_handle = find_dissector_add_dependency("x.25", proto_iua);\r\ndissector_add_uint("sctp.port", SCTP_PORT_IUA, iua_handle);\r\ndissector_add_uint("sctp.ppi", IUA_PAYLOAD_PROTOCOL_ID, iua_handle);\r\nlapd_gsm_sapi_dissector_table = find_dissector_table("lapd.gsm.sapi");\r\n}
