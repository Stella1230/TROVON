wtap_open_return_val\r\nngsniffer_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nchar magic[sizeof ngsniffer_magic];\r\nchar record_type[2];\r\nchar record_length[4];\r\nguint16 type;\r\nstruct vers_rec version;\r\nguint16 maj_vers;\r\nguint16 start_date;\r\n#if 0\r\nguint16 start_time;\r\n#endif\r\nstatic const int sniffer_encap[] = {\r\nWTAP_ENCAP_TOKEN_RING,\r\nWTAP_ENCAP_ETHERNET,\r\nWTAP_ENCAP_ARCNET,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_PER_PACKET,\r\nWTAP_ENCAP_PER_PACKET,\r\nWTAP_ENCAP_FDDI_BITSWAPPED,\r\nWTAP_ENCAP_ATM_PDUS\r\n};\r\n#define NUM_NGSNIFF_ENCAPS (sizeof sniffer_encap / sizeof sniffer_encap[0])\r\nstruct tm tm;\r\ngint64 current_offset;\r\nngsniffer_t *ngsniffer;\r\nif (!wtap_read_bytes(wth->fh, magic, sizeof magic, err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (memcmp(magic, ngsniffer_magic, sizeof ngsniffer_magic)) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (!wtap_read_bytes(wth->fh, record_type, 2, err, err_info))\r\nreturn WTAP_OPEN_ERROR;\r\nif (!wtap_read_bytes(wth->fh, record_length, 4, err, err_info))\r\nreturn WTAP_OPEN_ERROR;\r\ntype = pletoh16(record_type);\r\nif (type != REC_VERS) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("ngsniffer: Sniffer file doesn't start with a version record");\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (!wtap_read_bytes(wth->fh, &version, sizeof version, err, err_info))\r\nreturn WTAP_OPEN_ERROR;\r\nif (version.network >= NUM_NGSNIFF_ENCAPS\r\n|| sniffer_encap[version.network] == WTAP_ENCAP_UNKNOWN) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("ngsniffer: network type %u unknown or unsupported",\r\nversion.network);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (version.timeunit >= NUM_NGSNIFF_TIMEUNITS) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("ngsniffer: Unknown timeunit %u", version.timeunit);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (version.format != 1) {\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_NGSNIFFER_COMPRESSED;\r\n} else {\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_NGSNIFFER_UNCOMPRESSED;\r\n}\r\nwth->file_encap = sniffer_encap[version.network];\r\nmaj_vers = pletoh16(&version.maj_vers);\r\nif (process_header_records(wth, err, err_info, maj_vers,\r\nversion.network) < 0)\r\nreturn WTAP_OPEN_ERROR;\r\nif ((version.network == NETWORK_SYNCHRO ||\r\nversion.network == NETWORK_ASYNC) &&\r\nwth->file_encap == WTAP_ENCAP_PER_PACKET) {\r\nswitch (maj_vers) {\r\ncase 1:\r\nswitch (pletoh16(&version.rsvd[0])) {\r\ncase 1:\r\ncase 2:\r\nwth->file_encap = WTAP_ENCAP_ISDN;\r\nbreak;\r\n}\r\nbreak;\r\ncase 3:\r\nwth->file_encap = WTAP_ENCAP_FRELAY_WITH_PHDR;\r\nbreak;\r\n}\r\n}\r\ncurrent_offset = file_tell(wth->fh);\r\nif (wth->random_fh != NULL) {\r\nif (file_seek(wth->random_fh, current_offset, SEEK_SET, err) == -1)\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nngsniffer = (ngsniffer_t *)g_malloc(sizeof(ngsniffer_t));\r\nwth->priv = (void *)ngsniffer;\r\nngsniffer->maj_vers = maj_vers;\r\nngsniffer->min_vers = pletoh16(&version.min_vers);\r\nngsniffer->seq.buf = NULL;\r\nngsniffer->seq.nbytes = 0;\r\nngsniffer->seq.nextout = 0;\r\nngsniffer->rand.buf = NULL;\r\nngsniffer->rand.nbytes = 0;\r\nngsniffer->rand.nextout = 0;\r\nngsniffer->seq.uncomp_offset = current_offset;\r\nngsniffer->seq.comp_offset = current_offset;\r\nngsniffer->rand.uncomp_offset = current_offset;\r\nngsniffer->rand.comp_offset = current_offset;\r\nngsniffer->first_blob = NULL;\r\nngsniffer->last_blob = NULL;\r\nngsniffer->current_blob = NULL;\r\nwth->subtype_read = ngsniffer_read;\r\nwth->subtype_seek_read = ngsniffer_seek_read;\r\nwth->subtype_sequential_close = ngsniffer_sequential_close;\r\nwth->subtype_close = ngsniffer_close;\r\nwth->snapshot_length = 0;\r\nngsniffer->timeunit = Psec[version.timeunit];\r\nngsniffer->network = version.network;\r\nstart_date = pletoh16(&version.date);\r\ntm.tm_year = ((start_date&DOS_YEAR_MASK)>>DOS_YEAR_SHIFT) + DOS_YEAR_OFFSET;\r\ntm.tm_mon = ((start_date&DOS_MONTH_MASK)>>DOS_MONTH_SHIFT) + DOS_MONTH_OFFSET;\r\ntm.tm_mday = ((start_date&DOS_DAY_MASK)>>DOS_DAY_SHIFT);\r\n#if 0\r\nstart_time = pletoh16(&version.time);\r\ntm.tm_hour = (start_time&0xf800)>>11;\r\ntm.tm_min = (start_time&0x7e0)>>5;\r\ntm.tm_sec = (start_time&0x1f)<<1;\r\n#else\r\ntm.tm_hour = 0;\r\ntm.tm_min = 0;\r\ntm.tm_sec = 0;\r\n#endif\r\ntm.tm_isdst = -1;\r\nngsniffer->start = mktime(&tm);\r\nwth->file_tsprec = WTAP_TSPREC_NSEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic int\r\nprocess_header_records(wtap *wth, int *err, gchar **err_info, gint16 maj_vers,\r\nguint8 network)\r\n{\r\nchar record_type[2];\r\nchar record_length[4];\r\nguint16 rec_type, rec_length_remaining;\r\nint bytes_to_read;\r\nunsigned char buffer[256];\r\nfor (;;) {\r\nif (!wtap_read_bytes_or_eof(wth->fh, record_type, 2, err, err_info)) {\r\nif (*err != 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nrec_type = pletoh16(record_type);\r\nif ((rec_type != REC_HEADER1) && (rec_type != REC_HEADER2)\r\n&& (rec_type != REC_HEADER3) && (rec_type != REC_HEADER4)\r\n&& (rec_type != REC_HEADER5) && (rec_type != REC_HEADER6)\r\n&& (rec_type != REC_HEADER7)\r\n&& ((rec_type != REC_V2DESC) || (maj_vers > 2)) ) {\r\nif (file_seek(wth->fh, -2, SEEK_CUR, err) == -1)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nif (!wtap_read_bytes(wth->fh, record_length, 4,\r\nerr, err_info))\r\nreturn -1;\r\nrec_length_remaining = pletoh16(record_length);\r\nif ((network == NETWORK_SYNCHRO || network == NETWORK_ASYNC) &&\r\nrec_type == REC_HEADER2) {\r\nbytes_to_read = MIN(rec_length_remaining, (int)sizeof buffer);\r\nif (!wtap_read_bytes(wth->fh, buffer,\r\nbytes_to_read, err, err_info))\r\nreturn -1;\r\nswitch (maj_vers) {\r\ncase 2:\r\nif (process_rec_header2_v2(wth, buffer,\r\nrec_length_remaining, err, err_info) < 0)\r\nreturn -1;\r\nbreak;\r\ncase 1:\r\ncase 4:\r\ncase 5:\r\nif (process_rec_header2_v145(wth, buffer,\r\nrec_length_remaining, maj_vers, err, err_info) < 0)\r\nreturn -1;\r\nbreak;\r\n}\r\nif (rec_length_remaining > sizeof buffer) {\r\nif (file_seek(wth->fh, rec_length_remaining - sizeof buffer,\r\nSEEK_CUR, err) == -1)\r\nreturn -1;\r\n}\r\n} else {\r\nif (file_seek(wth->fh, rec_length_remaining, SEEK_CUR, err) == -1)\r\nreturn -1;\r\n}\r\n}\r\n}\r\nstatic int\r\nprocess_rec_header2_v2(wtap *wth, unsigned char *buffer, guint16 length,\r\nint *err, gchar **err_info)\r\n{\r\nstatic const char x_25_str[] = "HDLC\nX.25\n";\r\nif (length < sizeof x_25_str - 1) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup("ngsniffer: WAN capture has too-short protocol list");\r\nreturn -1;\r\n}\r\nif (strncmp((char *)buffer, x_25_str, sizeof x_25_str - 1) == 0) {\r\nwth->file_encap = WTAP_ENCAP_LAPB;\r\n} else {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("ngsniffer: WAN capture protocol string %.*s unknown",\r\nlength, buffer);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nprocess_rec_header2_v145(wtap *wth, unsigned char *buffer, guint16 length,\r\ngint16 maj_vers, int *err, gchar **err_info)\r\n{\r\nif (length < 5) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup("ngsniffer: WAN capture has no network subtype");\r\nreturn -1;\r\n}\r\nswitch (buffer[4]) {\r\ncase NET_SDLC:\r\nwth->file_encap = WTAP_ENCAP_SDLC;\r\nbreak;\r\ncase NET_HDLC:\r\nwth->file_encap = WTAP_ENCAP_PER_PACKET;\r\nbreak;\r\ncase NET_FRAME_RELAY:\r\nwth->file_encap = WTAP_ENCAP_FRELAY_WITH_PHDR;\r\nbreak;\r\ncase NET_ROUTER:\r\nwth->file_encap = WTAP_ENCAP_PER_PACKET;\r\nswitch (maj_vers) {\r\ncase 4:\r\nif (buffer[1] == 0xfa)\r\nwth->file_encap = WTAP_ENCAP_ISDN;\r\nbreak;\r\ncase 5:\r\nif (length < 7) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup("ngsniffer: WAN bridge/router capture has no ISDN flag");\r\nreturn -1;\r\n}\r\nif (buffer[6] == 0x01)\r\nwth->file_encap = WTAP_ENCAP_ISDN;\r\nbreak;\r\n}\r\nbreak;\r\ncase NET_PPP:\r\nwth->file_encap = WTAP_ENCAP_PPP_WITH_PHDR;\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("ngsniffer: WAN network subtype %u unknown or unsupported",\r\nbuffer[4]);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic gboolean\r\nngsniffer_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\r\n{\r\nngsniffer_t *ngsniffer;\r\nint ret;\r\nguint padding;\r\nngsniffer = (ngsniffer_t *)wth->priv;\r\nfor (;;) {\r\n*data_offset = ngsniffer->seq.uncomp_offset;\r\nret = ngsniffer_process_record(wth, FALSE, &padding,\r\n&wth->phdr, wth->frame_buffer, err, err_info);\r\nif (ret < 0) {\r\nreturn FALSE;\r\n}\r\nswitch (ret) {\r\ncase REC_FRAME2:\r\ncase REC_FRAME4:\r\ncase REC_FRAME6:\r\nif (padding != 0) {\r\nif (!ng_file_skip_seq(wth, padding, err,\r\nerr_info))\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\ncase REC_EOF:\r\n*err = 0;\r\nreturn FALSE;\r\ndefault:\r\nif (padding != 0) {\r\nif (!ng_file_skip_seq(wth, padding, err,\r\nerr_info))\r\nreturn FALSE;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic gboolean\r\nngsniffer_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nint ret;\r\nif (!ng_file_seek_rand(wth, seek_off, err, err_info))\r\nreturn FALSE;\r\nret = ngsniffer_process_record(wth, TRUE, NULL, phdr, buf, err, err_info);\r\nif (ret < 0) {\r\nreturn FALSE;\r\n}\r\nswitch (ret) {\r\ncase REC_FRAME2:\r\ncase REC_FRAME4:\r\ncase REC_FRAME6:\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\nngsniffer_process_record(wtap *wth, gboolean is_random, guint *padding,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nngsniffer_t *ngsniffer;\r\nchar record_type[2];\r\nchar record_length[4];\r\nguint rec_type, rec_length_remaining;\r\nstruct frame2_rec frame2;\r\nstruct frame4_rec frame4;\r\nstruct frame6_rec frame6;\r\nguint16 time_low, time_med, true_size, size;\r\nguint8 time_high, time_day;\r\nguint64 t, tsecs, tpsecs;\r\nif (!ng_read_bytes_or_eof(wth, record_type, 2, is_random, err, err_info)) {\r\nif (*err != 0)\r\nreturn -1;\r\nreturn REC_EOF;\r\n}\r\nif (!ng_read_bytes(wth, record_length, 4, is_random, err, err_info))\r\nreturn -1;\r\nrec_type = pletoh16(record_type);\r\nrec_length_remaining = pletoh16(record_length);\r\nngsniffer = (ngsniffer_t *)wth->priv;\r\nswitch (rec_type) {\r\ncase REC_FRAME2:\r\nif (ngsniffer->network == NETWORK_ATM) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("ngsniffer: REC_FRAME2 record in an ATM Sniffer file");\r\nreturn -1;\r\n}\r\nif (rec_length_remaining < sizeof frame2) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("ngsniffer: REC_FRAME2 record length is less than record header length");\r\nreturn -1;\r\n}\r\nif (!ng_read_bytes(wth, &frame2, (unsigned int)sizeof frame2,\r\nis_random, err, err_info))\r\nreturn -1;\r\ntime_low = pletoh16(&frame2.time_low);\r\ntime_med = pletoh16(&frame2.time_med);\r\ntime_high = frame2.time_high;\r\ntime_day = frame2.time_day;\r\nsize = pletoh16(&frame2.size);\r\ntrue_size = pletoh16(&frame2.true_size);\r\nrec_length_remaining -= (guint)sizeof frame2;\r\nset_pseudo_header_frame2(wth, &phdr->pseudo_header, &frame2);\r\nbreak;\r\ncase REC_FRAME4:\r\nif (ngsniffer->network != NETWORK_ATM) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("ngsniffer: REC_FRAME4 record in a non-ATM Sniffer file");\r\nreturn -1;\r\n}\r\nif (ngsniffer->maj_vers < 5 && ngsniffer->min_vers >= 95)\r\nrec_length_remaining += (guint)(sizeof frame4 - sizeof frame2);\r\nif (rec_length_remaining < sizeof frame4) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("ngsniffer: REC_FRAME4 record length is less than record header length");\r\nreturn -1;\r\n}\r\nif (!ng_read_bytes(wth, &frame4, (unsigned int)sizeof frame4,\r\nis_random, err, err_info))\r\nreturn -1;\r\ntime_low = pletoh16(&frame4.time_low);\r\ntime_med = pletoh16(&frame4.time_med);\r\ntime_high = frame4.time_high;\r\ntime_day = frame4.time_day;\r\nsize = pletoh16(&frame4.size);\r\ntrue_size = pletoh16(&frame4.true_size);\r\nrec_length_remaining -= (guint)sizeof frame4;\r\nset_pseudo_header_frame4(&phdr->pseudo_header, &frame4);\r\nbreak;\r\ncase REC_FRAME6:\r\nif (rec_length_remaining < sizeof frame6) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("ngsniffer: REC_FRAME6 record length is less than record header length");\r\nreturn -1;\r\n}\r\nif (!ng_read_bytes(wth, &frame6, (unsigned int)sizeof frame6,\r\nis_random, err, err_info))\r\nreturn -1;\r\ntime_low = pletoh16(&frame6.time_low);\r\ntime_med = pletoh16(&frame6.time_med);\r\ntime_high = frame6.time_high;\r\ntime_day = frame6.time_day;\r\nsize = pletoh16(&frame6.size);\r\ntrue_size = pletoh16(&frame6.true_size);\r\nrec_length_remaining -= (guint)sizeof frame6;\r\nset_pseudo_header_frame6(wth, &phdr->pseudo_header, &frame6);\r\nbreak;\r\ncase REC_EOF:\r\n*err = 0;\r\nreturn REC_EOF;\r\ndefault:\r\nif (padding != NULL) {\r\n*padding = rec_length_remaining;\r\n}\r\nreturn rec_type;\r\n}\r\nif (size > rec_length_remaining) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("ngsniffer: Record length is less than packet size");\r\nreturn -1;\r\n}\r\nif (padding != NULL) {\r\n*padding = rec_length_remaining - size;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = true_size ? WTAP_HAS_TS|WTAP_HAS_CAP_LEN : WTAP_HAS_TS;\r\nphdr->len = true_size ? true_size : size;\r\nphdr->caplen = size;\r\nws_buffer_assure_space(buf, size);\r\nif (!ng_read_bytes(wth, ws_buffer_start_ptr(buf), size, is_random,\r\nerr, err_info))\r\nreturn -1;\r\nphdr->pkt_encap = fix_pseudo_header(wth->file_encap,\r\nbuf, size, &phdr->pseudo_header);\r\nt = (((guint64)time_high)<<32) | (((guint64)time_med) << 16) | time_low;\r\nt *= ngsniffer->timeunit;\r\ntsecs = t/G_GUINT64_CONSTANT(1000000000000);\r\ntpsecs = t - tsecs*G_GUINT64_CONSTANT(1000000000000);\r\ntsecs += time_day*86400;\r\ntsecs += ngsniffer->start;\r\nphdr->ts.secs = (time_t)tsecs;\r\nphdr->ts.nsecs = (int)(tpsecs/1000);\r\nreturn rec_type;\r\n}\r\nstatic void\r\nset_pseudo_header_frame2(wtap *wth, union wtap_pseudo_header *pseudo_header,\r\nstruct frame2_rec *frame2)\r\n{\r\nswitch (wth->file_encap) {\r\ncase WTAP_ENCAP_ETHERNET:\r\npseudo_header->eth.fcs_len = 0;\r\nbreak;\r\ncase WTAP_ENCAP_PPP_WITH_PHDR:\r\ncase WTAP_ENCAP_SDLC:\r\npseudo_header->p2p.sent = (frame2->fs & FS_WAN_DTE) ? TRUE : FALSE;\r\nbreak;\r\ncase WTAP_ENCAP_LAPB:\r\ncase WTAP_ENCAP_FRELAY_WITH_PHDR:\r\ncase WTAP_ENCAP_PER_PACKET:\r\npseudo_header->x25.flags = (frame2->fs & FS_WAN_DTE) ? 0x00 : FROM_DCE;\r\nbreak;\r\ncase WTAP_ENCAP_ISDN:\r\npseudo_header->isdn.uton = (frame2->fs & FS_WAN_DTE) ? FALSE : TRUE;\r\nswitch (frame2->fs & FS_ISDN_CHAN_MASK) {\r\ncase FS_ISDN_CHAN_D:\r\npseudo_header->isdn.channel = 0;\r\nbreak;\r\ncase FS_ISDN_CHAN_B1:\r\npseudo_header->isdn.channel = 1;\r\nbreak;\r\ncase FS_ISDN_CHAN_B2:\r\npseudo_header->isdn.channel = 2;\r\nbreak;\r\ndefault:\r\npseudo_header->isdn.channel = 30;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\nset_pseudo_header_frame4(union wtap_pseudo_header *pseudo_header,\r\nstruct frame4_rec *frame4)\r\n{\r\nguint32 StatusWord;\r\nguint8 aal_type, hl_type;\r\nguint16 vpi, vci;\r\npseudo_header->atm.flags = 0;\r\nStatusWord = pletoh32(&frame4->atm_info.StatusWord);\r\nif (StatusWord & SW_RAW_CELL)\r\npseudo_header->atm.flags |= ATM_RAW_CELL;\r\naal_type = frame4->atm_info.AppTrafType & ATT_AALTYPE;\r\nhl_type = frame4->atm_info.AppTrafType & ATT_HLTYPE;\r\nvpi = pletoh16(&frame4->atm_info.Vpi);\r\nvci = pletoh16(&frame4->atm_info.Vci);\r\nswitch (aal_type) {\r\ncase ATT_AAL_UNKNOWN:\r\nif (vpi == 0 && vci == 5)\r\npseudo_header->atm.aal = AAL_SIGNALLING;\r\nelse\r\npseudo_header->atm.aal = AAL_UNKNOWN;\r\npseudo_header->atm.type = TRAF_UNKNOWN;\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase ATT_AAL1:\r\npseudo_header->atm.aal = AAL_1;\r\npseudo_header->atm.type = TRAF_UNKNOWN;\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase ATT_AAL3_4:\r\npseudo_header->atm.aal = AAL_3_4;\r\npseudo_header->atm.type = TRAF_UNKNOWN;\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase ATT_AAL5:\r\npseudo_header->atm.aal = AAL_5;\r\nswitch (hl_type) {\r\ncase ATT_HL_UNKNOWN:\r\npseudo_header->atm.type = TRAF_UNKNOWN;\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase ATT_HL_LLCMX:\r\npseudo_header->atm.type = TRAF_LLCMX;\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase ATT_HL_VCMX:\r\npseudo_header->atm.type = TRAF_VCMX;\r\nswitch (frame4->atm_info.AppHLType) {\r\ncase AHLT_UNKNOWN:\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase AHLT_VCMX_802_3_FCS:\r\npseudo_header->atm.subtype =\r\nTRAF_ST_VCMX_802_3_FCS;\r\nbreak;\r\ncase AHLT_VCMX_802_4_FCS:\r\npseudo_header->atm.subtype =\r\nTRAF_ST_VCMX_802_4_FCS;\r\nbreak;\r\ncase AHLT_VCMX_802_5_FCS:\r\npseudo_header->atm.subtype =\r\nTRAF_ST_VCMX_802_5_FCS;\r\nbreak;\r\ncase AHLT_VCMX_FDDI_FCS:\r\npseudo_header->atm.subtype =\r\nTRAF_ST_VCMX_FDDI_FCS;\r\nbreak;\r\ncase AHLT_VCMX_802_6_FCS:\r\npseudo_header->atm.subtype =\r\nTRAF_ST_VCMX_802_6_FCS;\r\nbreak;\r\ncase AHLT_VCMX_802_3:\r\npseudo_header->atm.subtype = TRAF_ST_VCMX_802_3;\r\nbreak;\r\ncase AHLT_VCMX_802_4:\r\npseudo_header->atm.subtype = TRAF_ST_VCMX_802_4;\r\nbreak;\r\ncase AHLT_VCMX_802_5:\r\npseudo_header->atm.subtype = TRAF_ST_VCMX_802_5;\r\nbreak;\r\ncase AHLT_VCMX_FDDI:\r\npseudo_header->atm.subtype = TRAF_ST_VCMX_FDDI;\r\nbreak;\r\ncase AHLT_VCMX_802_6:\r\npseudo_header->atm.subtype = TRAF_ST_VCMX_802_6;\r\nbreak;\r\ncase AHLT_VCMX_FRAGMENTS:\r\npseudo_header->atm.subtype =\r\nTRAF_ST_VCMX_FRAGMENTS;\r\nbreak;\r\ncase AHLT_VCMX_BPDU:\r\npseudo_header->atm.subtype = TRAF_ST_VCMX_BPDU;\r\nbreak;\r\ndefault:\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\n}\r\nbreak;\r\ncase ATT_HL_LANE:\r\npseudo_header->atm.type = TRAF_LANE;\r\nswitch (frame4->atm_info.AppHLType) {\r\ncase AHLT_UNKNOWN:\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase AHLT_LANE_LE_CTRL:\r\npseudo_header->atm.subtype =\r\nTRAF_ST_LANE_LE_CTRL;\r\nbreak;\r\ncase AHLT_LANE_802_3:\r\npseudo_header->atm.subtype = TRAF_ST_LANE_802_3;\r\nbreak;\r\ncase AHLT_LANE_802_5:\r\npseudo_header->atm.subtype = TRAF_ST_LANE_802_5;\r\nbreak;\r\ncase AHLT_LANE_802_3_MC:\r\npseudo_header->atm.subtype =\r\nTRAF_ST_LANE_802_3_MC;\r\nbreak;\r\ncase AHLT_LANE_802_5_MC:\r\npseudo_header->atm.subtype =\r\nTRAF_ST_LANE_802_5_MC;\r\nbreak;\r\ndefault:\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\n}\r\nbreak;\r\ncase ATT_HL_ILMI:\r\npseudo_header->atm.type = TRAF_ILMI;\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase ATT_HL_FRMR:\r\npseudo_header->atm.type = TRAF_FR;\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase ATT_HL_SPANS:\r\npseudo_header->atm.type = TRAF_SPANS;\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase ATT_HL_IPSILON:\r\npseudo_header->atm.type = TRAF_IPSILON;\r\nswitch (frame4->atm_info.AppHLType) {\r\ncase AHLT_UNKNOWN:\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase AHLT_IPSILON_FT0:\r\npseudo_header->atm.subtype =\r\nTRAF_ST_IPSILON_FT0;\r\nbreak;\r\ncase AHLT_IPSILON_FT1:\r\npseudo_header->atm.subtype =\r\nTRAF_ST_IPSILON_FT1;\r\nbreak;\r\ncase AHLT_IPSILON_FT2:\r\npseudo_header->atm.subtype =\r\nTRAF_ST_IPSILON_FT2;\r\nbreak;\r\ndefault:\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\npseudo_header->atm.type = TRAF_UNKNOWN;\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\n}\r\nbreak;\r\ncase ATT_AAL_USER:\r\npseudo_header->atm.aal = AAL_USER;\r\npseudo_header->atm.type = TRAF_UNKNOWN;\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase ATT_AAL_SIGNALLING:\r\npseudo_header->atm.aal = AAL_SIGNALLING;\r\npseudo_header->atm.type = TRAF_UNKNOWN;\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase ATT_OAMCELL:\r\npseudo_header->atm.aal = AAL_OAMCELL;\r\npseudo_header->atm.type = TRAF_UNKNOWN;\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ndefault:\r\npseudo_header->atm.aal = AAL_UNKNOWN;\r\npseudo_header->atm.type = TRAF_UNKNOWN;\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\n}\r\npseudo_header->atm.vpi = vpi;\r\npseudo_header->atm.vci = vci;\r\npseudo_header->atm.channel = pletoh16(&frame4->atm_info.channel);\r\npseudo_header->atm.cells = pletoh16(&frame4->atm_info.cells);\r\npseudo_header->atm.aal5t_u2u = pletoh16(&frame4->atm_info.Trailer.aal5t_u2u);\r\npseudo_header->atm.aal5t_len = pletoh16(&frame4->atm_info.Trailer.aal5t_len);\r\npseudo_header->atm.aal5t_chksum = pntoh32(&frame4->atm_info.Trailer.aal5t_chksum);\r\n}\r\nstatic void\r\nset_pseudo_header_frame6(wtap *wth, union wtap_pseudo_header *pseudo_header,\r\nstruct frame6_rec *frame6 _U_)\r\n{\r\nswitch (wth->file_encap) {\r\ncase WTAP_ENCAP_ETHERNET:\r\npseudo_header->eth.fcs_len = -1;\r\nbreak;\r\n}\r\n}\r\nstatic int\r\ninfer_pkt_encap(const guint8 *pd, int len)\r\n{\r\nint i;\r\nif (len <= 0) {\r\nreturn WTAP_ENCAP_PPP_WITH_PHDR;\r\n}\r\nif (pd[0] == 0xFF) {\r\nreturn WTAP_ENCAP_PPP_WITH_PHDR;\r\n}\r\nif (len >= 2) {\r\nif (pd[0] == 0x07 && pd[1] == 0x03) {\r\nreturn WTAP_ENCAP_WFLEET_HDLC;\r\n} else if ((pd[0] == 0x0F && pd[1] == 0x00) ||\r\n(pd[0] == 0x8F && pd[1] == 0x00)) {\r\nreturn WTAP_ENCAP_CHDLC_WITH_PHDR;\r\n}\r\nfor (i = 0; i < len && (pd[i] & 0x01) == 0; i++)\r\n;\r\ni++;\r\nif (i == len) {\r\nreturn WTAP_ENCAP_LAPB;\r\n}\r\nif (pd[i] == 0x03)\r\nreturn WTAP_ENCAP_FRELAY_WITH_PHDR;\r\n}\r\nreturn WTAP_ENCAP_LAPB;\r\n}\r\nstatic int\r\nfix_pseudo_header(int encap, Buffer *buf, int len,\r\nunion wtap_pseudo_header *pseudo_header)\r\n{\r\nconst guint8 *pd;\r\npd = ws_buffer_start_ptr(buf);\r\nswitch (encap) {\r\ncase WTAP_ENCAP_PER_PACKET:\r\nencap = infer_pkt_encap(pd, len);\r\nswitch (encap) {\r\ncase WTAP_ENCAP_WFLEET_HDLC:\r\ncase WTAP_ENCAP_CHDLC_WITH_PHDR:\r\ncase WTAP_ENCAP_PPP_WITH_PHDR:\r\nif (pseudo_header->x25.flags == 0)\r\npseudo_header->p2p.sent = TRUE;\r\nelse\r\npseudo_header->p2p.sent = FALSE;\r\nbreak;\r\ncase WTAP_ENCAP_ISDN:\r\nif (pseudo_header->x25.flags == 0x00)\r\npseudo_header->isdn.uton = FALSE;\r\nelse\r\npseudo_header->isdn.uton = TRUE;\r\npseudo_header->isdn.channel = 0;\r\nbreak;\r\n}\r\nbreak;\r\ncase WTAP_ENCAP_ATM_PDUS:\r\nif (pseudo_header->atm.type == TRAF_LANE && len >= 2) {\r\nif (pd[0] == 0xff && pd[1] == 0x00) {\r\npseudo_header->atm.subtype =\r\nTRAF_ST_LANE_LE_CTRL;\r\n} else {\r\nif (pseudo_header->atm.subtype ==\r\nTRAF_ST_LANE_LE_CTRL) {\r\npseudo_header->atm.subtype =\r\nTRAF_ST_LANE_802_3;\r\n}\r\n}\r\n}\r\nbreak;\r\n}\r\nreturn encap;\r\n}\r\nstatic void\r\nngsniffer_sequential_close(wtap *wth)\r\n{\r\nngsniffer_t *ngsniffer;\r\nngsniffer = (ngsniffer_t *)wth->priv;\r\nif (ngsniffer->seq.buf != NULL) {\r\ng_free(ngsniffer->seq.buf);\r\nngsniffer->seq.buf = NULL;\r\n}\r\n}\r\nstatic void\r\nfree_blob(gpointer data, gpointer user_data _U_)\r\n{\r\ng_free(data);\r\n}\r\nstatic void\r\nngsniffer_close(wtap *wth)\r\n{\r\nngsniffer_t *ngsniffer;\r\nngsniffer = (ngsniffer_t *)wth->priv;\r\nif (ngsniffer->rand.buf != NULL)\r\ng_free(ngsniffer->rand.buf);\r\nif (ngsniffer->first_blob != NULL) {\r\ng_list_foreach(ngsniffer->first_blob, free_blob, NULL);\r\ng_list_free(ngsniffer->first_blob);\r\n}\r\n}\r\nint\r\nngsniffer_dump_can_write_encap(int encap)\r\n{\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nif (encap < 0 || (unsigned)encap >= NUM_WTAP_ENCAPS || wtap_encap[encap] == -1)\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\nreturn 0;\r\n}\r\ngboolean\r\nngsniffer_dump_open(wtap_dumper *wdh, int *err)\r\n{\r\nngsniffer_dump_t *ngsniffer;\r\nchar buf[6] = {REC_VERS, 0x00, 0x12, 0x00, 0x00, 0x00};\r\nwdh->subtype_write = ngsniffer_dump;\r\nwdh->subtype_finish = ngsniffer_dump_finish;\r\nngsniffer = (ngsniffer_dump_t *)g_malloc(sizeof(ngsniffer_dump_t));\r\nwdh->priv = (void *)ngsniffer;\r\nngsniffer->first_frame = TRUE;\r\nngsniffer->start = 0;\r\nif (!wtap_dump_file_write(wdh, ngsniffer_magic, sizeof ngsniffer_magic,\r\nerr))\r\nreturn FALSE;\r\nif (!wtap_dump_file_write(wdh, buf, 6, err))\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nngsniffer_dump(wtap_dumper *wdh, const struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info _U_)\r\n{\r\nconst union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nngsniffer_dump_t *ngsniffer = (ngsniffer_dump_t *)wdh->priv;\r\nstruct frame2_rec rec_hdr;\r\nchar buf[6];\r\ntime_t tsecs;\r\nguint64 t;\r\nguint16 t_low, t_med;\r\nguint8 t_high;\r\nstruct vers_rec version;\r\ngint16 maj_vers, min_vers;\r\nguint16 start_date;\r\nstruct tm *tm;\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\nif (phdr->caplen > 65535) {\r\n*err = WTAP_ERR_PACKET_TOO_LARGE;\r\nreturn FALSE;\r\n}\r\nif (ngsniffer->first_frame) {\r\nngsniffer->first_frame=FALSE;\r\ntm = localtime(&phdr->ts.secs);\r\nif (tm != NULL && tm->tm_year >= DOS_YEAR_OFFSET) {\r\nstart_date = (tm->tm_year - DOS_YEAR_OFFSET) << DOS_YEAR_SHIFT;\r\nstart_date |= (tm->tm_mon - DOS_MONTH_OFFSET) << DOS_MONTH_SHIFT;\r\nstart_date |= tm->tm_mday << DOS_DAY_SHIFT;\r\nngsniffer->start = phdr->ts.secs - (3600*tm->tm_hour + 60*tm->tm_min + tm->tm_sec);\r\n} else {\r\nstart_date = 0;\r\nngsniffer->start = 0;\r\n}\r\nmaj_vers = 4;\r\nmin_vers = 0;\r\nversion.maj_vers = GUINT16_TO_LE(maj_vers);\r\nversion.min_vers = GUINT16_TO_LE(min_vers);\r\nversion.time = 0;\r\nversion.date = GUINT16_TO_LE(start_date);\r\nversion.type = 4;\r\nversion.network = wtap_encap[wdh->encap];\r\nversion.format = 1;\r\nversion.timeunit = 1;\r\nversion.cmprs_vers = 0;\r\nversion.cmprs_level = 0;\r\nversion.rsvd[0] = 0;\r\nversion.rsvd[1] = 0;\r\nif (!wtap_dump_file_write(wdh, &version, sizeof version, err))\r\nreturn FALSE;\r\n}\r\nbuf[0] = REC_FRAME2;\r\nbuf[1] = 0x00;\r\nbuf[2] = (char)((phdr->caplen + sizeof(struct frame2_rec))%256);\r\nbuf[3] = (char)((phdr->caplen + sizeof(struct frame2_rec))/256);\r\nbuf[4] = 0x00;\r\nbuf[5] = 0x00;\r\nif (!wtap_dump_file_write(wdh, buf, 6, err))\r\nreturn FALSE;\r\ntsecs = phdr->ts.secs - ngsniffer->start;\r\nrec_hdr.time_day = (guint8)(tsecs / 86400);\r\ntsecs -= rec_hdr.time_day * 86400;\r\nt = tsecs*G_GUINT64_CONSTANT(1000000000000) +\r\nphdr->ts.nsecs*G_GUINT64_CONSTANT(1000);\r\nt /= Psec[1];\r\nt_low = (guint16)((t >> 0) & 0xFFFF);\r\nt_med = (guint16)((t >> 16) & 0xFFFF);\r\nt_high = (guint8)((t >> 32) & 0xFF);\r\nrec_hdr.time_low = GUINT16_TO_LE(t_low);\r\nrec_hdr.time_med = GUINT16_TO_LE(t_med);\r\nrec_hdr.time_high = t_high;\r\nrec_hdr.size = GUINT16_TO_LE(phdr->caplen);\r\nswitch (wdh->encap) {\r\ncase WTAP_ENCAP_LAPB:\r\ncase WTAP_ENCAP_FRELAY_WITH_PHDR:\r\nrec_hdr.fs = (pseudo_header->x25.flags & FROM_DCE) ? 0x00 : FS_WAN_DTE;\r\nbreak;\r\ncase WTAP_ENCAP_PPP_WITH_PHDR:\r\ncase WTAP_ENCAP_SDLC:\r\nrec_hdr.fs = pseudo_header->p2p.sent ? 0x00 : FS_WAN_DTE;\r\nbreak;\r\ncase WTAP_ENCAP_ISDN:\r\nrec_hdr.fs = pseudo_header->isdn.uton ? FS_WAN_DTE : 0x00;\r\nswitch (pseudo_header->isdn.channel) {\r\ncase 0:\r\nrec_hdr.fs |= FS_ISDN_CHAN_D;\r\nbreak;\r\ncase 1:\r\nrec_hdr.fs |= FS_ISDN_CHAN_B1;\r\nbreak;\r\ncase 2:\r\nrec_hdr.fs |= FS_ISDN_CHAN_B2;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nrec_hdr.fs = 0;\r\nbreak;\r\n}\r\nrec_hdr.flags = 0;\r\nrec_hdr.true_size = phdr->len != phdr->caplen ? GUINT16_TO_LE(phdr->len) : 0;\r\nrec_hdr.rsvd = 0;\r\nif (!wtap_dump_file_write(wdh, &rec_hdr, sizeof rec_hdr, err))\r\nreturn FALSE;\r\nif (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nngsniffer_dump_finish(wtap_dumper *wdh, int *err)\r\n{\r\nchar buf[6] = {REC_EOF, 0x00, 0x00, 0x00, 0x00, 0x00};\r\nif (!wtap_dump_file_write(wdh, buf, 6, err))\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\nstatic int\r\nSnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,\r\nsize_t outlen, int *err, gchar **err_info)\r\n{\r\nunsigned char * pin = inbuf;\r\nunsigned char * pout = outbuf;\r\nunsigned char * pin_end = pin + inlen;\r\nunsigned char * pout_end = pout + outlen;\r\nunsigned int bit_mask;\r\nunsigned int bit_value = 0;\r\nunsigned int code_type;\r\nunsigned int code_low;\r\nint length;\r\nint offset;\r\nif (inlen > G_MAXUINT16) {\r\nreturn ( -1 );\r\n}\r\nbit_mask = 0;\r\nwhile (pin < pin_end)\r\n{\r\nbit_mask = bit_mask >> 1;\r\nif ( 0 == bit_mask )\r\n{\r\nCHECK_INPUT_POINTER( 3 );\r\nbit_mask = 0x8000;\r\nbit_value = pletoh16(pin);\r\npin += 2;\r\n}\r\nif ( !(bit_mask & bit_value) )\r\n{\r\nCHECK_OUTPUT_LENGTH( 1 );\r\n*(pout++) = *(pin++);\r\n}\r\nelse\r\n{\r\ncode_type = (unsigned int) ((*pin) >> 4 ) & 0xF;\r\ncode_low = (unsigned int) ((*pin) & 0xF );\r\npin++;\r\nswitch ( code_type )\r\n{\r\ncase 0 :\r\nlength = code_low + 3;\r\nAPPEND_RLE_BYTE( length );\r\nbreak;\r\ncase 1 :\r\nCHECK_INPUT_POINTER( 1 );\r\nlength = code_low + ((unsigned int)(*pin++) << 4) + 19;\r\nAPPEND_RLE_BYTE( length );\r\nbreak;\r\ncase 2 :\r\nFETCH_OFFSET_HIGH;\r\nCHECK_INPUT_POINTER( 1 );\r\nlength = (unsigned int)(*pin++) + 16;\r\nAPPEND_LZW_STRING( offset, length );\r\nbreak;\r\ndefault :\r\nFETCH_OFFSET_HIGH;\r\nlength = code_type;\r\nAPPEND_LZW_STRING( offset, length );\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn (int) ( pout - outbuf );\r\n}\r\nstatic gboolean\r\nng_read_bytes_or_eof(wtap *wth, void *buffer, unsigned int nbytes, gboolean is_random,\r\nint *err, gchar **err_info)\r\n{\r\nngsniffer_t *ngsniffer;\r\nFILE_T infile;\r\nngsniffer_comp_stream_t *comp_stream;\r\nunsigned char *outbuffer = (unsigned char *)buffer;\r\nblob_info_t *blob;\r\nunsigned int bytes_to_copy;\r\nunsigned int bytes_left;\r\nngsniffer = (ngsniffer_t *)wth->priv;\r\nif (is_random) {\r\ninfile = wth->random_fh;\r\ncomp_stream = &ngsniffer->rand;\r\n} else {\r\ninfile = wth->fh;\r\ncomp_stream = &ngsniffer->seq;\r\n}\r\nif (wth->file_type_subtype == WTAP_FILE_TYPE_SUBTYPE_NGSNIFFER_UNCOMPRESSED) {\r\nif (!wtap_read_bytes_or_eof(infile, buffer, nbytes, err, err_info))\r\nreturn FALSE;\r\ncomp_stream->uncomp_offset += nbytes;\r\ncomp_stream->comp_offset += nbytes;\r\nreturn TRUE;\r\n}\r\nif (comp_stream->buf == NULL) {\r\ncomp_stream->buf = (unsigned char *)g_malloc(OUTBUF_SIZE);\r\nif (is_random) {\r\nngsniffer->current_blob = ngsniffer->first_blob;\r\n} else {\r\nif (wth->random_fh != NULL) {\r\ng_assert(ngsniffer->first_blob == NULL);\r\nblob = g_new(blob_info_t,1);\r\nblob->blob_comp_offset = comp_stream->comp_offset;\r\nblob->blob_uncomp_offset = comp_stream->uncomp_offset;\r\nngsniffer->first_blob = g_list_append(ngsniffer->first_blob,\r\nblob);\r\nngsniffer->last_blob = ngsniffer->first_blob;\r\n}\r\n}\r\nif (!read_blob(infile, comp_stream, err, err_info))\r\nreturn FALSE;\r\n}\r\nwhile (nbytes > 0) {\r\nbytes_left = comp_stream->nbytes - comp_stream->nextout;\r\nif (bytes_left == 0) {\r\nif (is_random) {\r\nngsniffer->current_blob = g_list_next(ngsniffer->current_blob);\r\nif (!ngsniffer->current_blob) {\r\n*err = WTAP_ERR_CANT_SEEK;\r\nreturn FALSE;\r\n}\r\n} else {\r\nif (wth->random_fh != NULL) {\r\nblob = g_new(blob_info_t,1);\r\nblob->blob_comp_offset = comp_stream->comp_offset;\r\nblob->blob_uncomp_offset = comp_stream->uncomp_offset;\r\nngsniffer->last_blob = g_list_append(ngsniffer->last_blob,\r\nblob);\r\n}\r\n}\r\nif (!read_blob(infile, comp_stream, err, err_info))\r\nreturn FALSE;\r\nbytes_left = comp_stream->nbytes - comp_stream->nextout;\r\n}\r\nbytes_to_copy = nbytes;\r\nif (bytes_to_copy > bytes_left)\r\nbytes_to_copy = bytes_left;\r\nmemcpy(outbuffer, &comp_stream->buf[comp_stream->nextout],\r\nbytes_to_copy);\r\nnbytes -= bytes_to_copy;\r\noutbuffer += bytes_to_copy;\r\ncomp_stream->nextout += bytes_to_copy;\r\ncomp_stream->uncomp_offset += bytes_to_copy;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nng_read_bytes(wtap *wth, void *buffer, unsigned int nbytes, gboolean is_random,\r\nint *err, gchar **err_info)\r\n{\r\nif (!ng_read_bytes_or_eof(wth, buffer, nbytes, is_random, err, err_info)) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nread_blob(FILE_T infile, ngsniffer_comp_stream_t *comp_stream, int *err,\r\ngchar **err_info)\r\n{\r\nint in_len;\r\nunsigned short blob_len;\r\ngint16 blob_len_host;\r\ngboolean uncompressed;\r\nunsigned char *file_inbuf;\r\nint out_len;\r\nif (!wtap_read_bytes_or_eof(infile, &blob_len, 2, err, err_info))\r\nreturn FALSE;\r\ncomp_stream->comp_offset += 2;\r\nblob_len_host = pletoh16(&blob_len);\r\nif (blob_len_host < 0) {\r\nin_len = -blob_len_host;\r\nuncompressed = TRUE;\r\n} else {\r\nin_len = blob_len_host;\r\nuncompressed = FALSE;\r\n}\r\nfile_inbuf = (unsigned char *)g_malloc(INBUF_SIZE);\r\nif (!wtap_read_bytes(infile, file_inbuf, in_len, err, err_info)) {\r\ng_free(file_inbuf);\r\nreturn FALSE;\r\n}\r\ncomp_stream->comp_offset += in_len;\r\nif (uncompressed) {\r\nmemcpy(comp_stream->buf, file_inbuf, in_len);\r\nout_len = in_len;\r\n} else {\r\nout_len = SnifferDecompress(file_inbuf, in_len,\r\ncomp_stream->buf, OUTBUF_SIZE, err,\r\nerr_info);\r\nif (out_len < 0) {\r\ng_free(file_inbuf);\r\nreturn FALSE;\r\n}\r\n}\r\ng_free(file_inbuf);\r\ncomp_stream->nextout = 0;\r\ncomp_stream->nbytes = out_len;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nng_file_skip_seq(wtap *wth, gint64 delta, int *err, gchar **err_info)\r\n{\r\nngsniffer_t *ngsniffer;\r\nchar *buf;\r\nunsigned int amount_to_read;\r\nngsniffer = (ngsniffer_t *)wth->priv;\r\nif (wth->file_type_subtype == WTAP_FILE_TYPE_SUBTYPE_NGSNIFFER_UNCOMPRESSED) {\r\nngsniffer->seq.uncomp_offset += delta;\r\nreturn file_skip(wth->fh, delta, err);\r\n}\r\ng_assert(delta >= 0);\r\nbuf = (char *)g_malloc(INBUF_SIZE);\r\nwhile (delta != 0) {\r\nif (delta > INBUF_SIZE)\r\namount_to_read = INBUF_SIZE;\r\nelse\r\namount_to_read = (unsigned int) delta;\r\nif (!ng_read_bytes(wth, buf, amount_to_read, FALSE, err, err_info)) {\r\ng_free(buf);\r\nreturn FALSE;\r\n}\r\ndelta -= amount_to_read;\r\n}\r\ng_free(buf);\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nng_file_seek_rand(wtap *wth, gint64 offset, int *err, gchar **err_info)\r\n{\r\nngsniffer_t *ngsniffer;\r\ngint64 delta;\r\nGList *new_list, *next_list;\r\nblob_info_t *next_blob, *new_blob;\r\nngsniffer = (ngsniffer_t *)wth->priv;\r\nif (wth->file_type_subtype == WTAP_FILE_TYPE_SUBTYPE_NGSNIFFER_UNCOMPRESSED) {\r\nif (file_seek(wth->random_fh, offset, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\ndelta = offset - ngsniffer->rand.uncomp_offset;\r\nnew_list = NULL;\r\nif (delta > 0) {\r\nif ((size_t)(ngsniffer->rand.nextout + delta) >= ngsniffer->rand.nbytes) {\r\nif (ngsniffer->current_blob == NULL) {\r\nnew_list = ngsniffer->first_blob;\r\n} else {\r\nnew_list = g_list_next(ngsniffer->current_blob);\r\n}\r\nwhile (new_list) {\r\nnext_list = g_list_next(new_list);\r\nif (next_list == NULL) {\r\nbreak;\r\n}\r\nnext_blob = (blob_info_t *)next_list->data;\r\nif (next_blob->blob_uncomp_offset > offset)\r\nbreak;\r\nnew_list = next_list;\r\n}\r\nif (new_list == NULL) {\r\n*err = WTAP_ERR_CANT_SEEK;\r\nreturn FALSE;\r\n}\r\n}\r\n} else if (delta < 0) {\r\nif (ngsniffer->rand.nextout + delta < 0) {\r\nif (ngsniffer->current_blob == NULL) {\r\nnew_list = ngsniffer->last_blob;\r\n} else {\r\nnew_list = g_list_previous(ngsniffer->current_blob);\r\n}\r\nwhile (new_list) {\r\nnew_blob = (blob_info_t *)new_list->data;\r\nif (new_blob->blob_uncomp_offset <= offset)\r\nbreak;\r\nnew_list = g_list_previous(new_list);\r\n}\r\nif (new_list == NULL) {\r\n*err = WTAP_ERR_CANT_SEEK;\r\nreturn FALSE;\r\n}\r\n}\r\n}\r\nif (new_list != NULL) {\r\nnew_blob = (blob_info_t *)new_list->data;\r\nif (file_seek(wth->random_fh, new_blob->blob_comp_offset, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (ngsniffer->rand.buf == NULL) {\r\nngsniffer->rand.buf = (unsigned char *)g_malloc(OUTBUF_SIZE);\r\n}\r\nngsniffer->current_blob = new_list;\r\nngsniffer->rand.uncomp_offset = new_blob->blob_uncomp_offset;\r\nngsniffer->rand.comp_offset = new_blob->blob_comp_offset;\r\nif (!read_blob(wth->random_fh, &ngsniffer->rand, err, err_info))\r\nreturn FALSE;\r\ndelta = offset - ngsniffer->rand.uncomp_offset;\r\ng_assert(delta >= 0 && (unsigned long)delta < ngsniffer->rand.nbytes);\r\n}\r\nngsniffer->rand.nextout += (int) delta;\r\nngsniffer->rand.uncomp_offset += delta;\r\nreturn TRUE;\r\n}
