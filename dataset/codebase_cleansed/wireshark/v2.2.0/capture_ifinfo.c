static GList * append_remote_list(GList *iflist)\r\n{\r\nGSList *list;\r\nGList *rlist;\r\nif_addr_t *if_addr, *temp_addr;\r\nif_info_t *if_info, *temp;\r\nfor (rlist = g_list_nth(remote_interface_list, 0); rlist != NULL; rlist = g_list_next(rlist)) {\r\nif_info = (if_info_t *)rlist->data;\r\ntemp = g_malloc0(sizeof(if_info_t));\r\ntemp->name = g_strdup(if_info->name);\r\ntemp->friendly_name = g_strdup(if_info->friendly_name);\r\ntemp->vendor_description = g_strdup(if_info->vendor_description);\r\nfor (list = g_slist_nth(if_info->addrs, 0); list != NULL; list = g_slist_next(list)) {\r\ntemp_addr = g_malloc0(sizeof(if_addr_t));\r\nif_addr = (if_addr_t *)list->data;\r\nif (if_addr) {\r\ntemp_addr->ifat_type = if_addr->ifat_type;\r\nif (temp_addr->ifat_type == IF_AT_IPv4) {\r\ntemp_addr->addr.ip4_addr = if_addr->addr.ip4_addr;\r\n} else {\r\nmemcpy(temp_addr->addr.ip6_addr, if_addr->addr.ip6_addr, sizeof(if_addr->addr));\r\n}\r\n} else {\r\ng_free(temp_addr);\r\ntemp_addr = NULL;\r\n}\r\nif (temp_addr) {\r\ntemp->addrs = g_slist_append(temp->addrs, temp_addr);\r\n}\r\n}\r\ntemp->loopback = if_info->loopback;\r\niflist = g_list_append(iflist, temp);\r\n}\r\nreturn iflist;\r\n}\r\nGList *\r\ncapture_interface_list(int *err, char **err_str, void (*update_cb)(void))\r\n{\r\nint ret;\r\nGList *if_list = NULL;\r\nint i, j;\r\ngchar *data, *primary_msg, *secondary_msg;\r\ngchar **raw_list, **if_parts, **addr_parts;\r\ngchar *name;\r\nif_info_t *if_info;\r\nif_addr_t *if_addr;\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, "Capture Interface List ...");\r\n*err = 0;\r\nret = sync_interface_list_open(&data, &primary_msg, &secondary_msg, update_cb);\r\nif (ret != 0) {\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, "Capture Interface List failed, error %d, %s (%s)!",\r\n*err, primary_msg ? primary_msg : "no message",\r\nsecondary_msg ? secondary_msg : "no secondary message");\r\nif (err_str) {\r\n*err_str = primary_msg;\r\n} else {\r\ng_free(primary_msg);\r\n}\r\ng_free(secondary_msg);\r\n*err = CANT_GET_INTERFACE_LIST;\r\nreturn if_list;\r\n}\r\n#ifdef _WIN32\r\nraw_list = g_strsplit(data, "\r\n", 0);\r\n#else\r\nraw_list = g_strsplit(data, "\n", 0);\r\n#endif\r\ng_free(data);\r\nfor (i = 0; raw_list[i] != NULL; i++) {\r\n#ifdef HAVE_EXTCAP\r\nif_parts = g_strsplit(raw_list[i], "\t", 7);\r\nif (if_parts[0] == NULL || if_parts[1] == NULL || if_parts[2] == NULL ||\r\nif_parts[3] == NULL || if_parts[4] == NULL || if_parts[5] == NULL ||\r\nif_parts[6] == NULL) {\r\ng_strfreev(if_parts);\r\ncontinue;\r\n}\r\n#else\r\nif_parts = g_strsplit(raw_list[i], "\t", 6);\r\nif (if_parts[0] == NULL || if_parts[1] == NULL || if_parts[2] == NULL ||\r\nif_parts[3] == NULL || if_parts[4] == NULL || if_parts[5] == NULL) {\r\ng_strfreev(if_parts);\r\ncontinue;\r\n}\r\n#endif\r\nname = strchr(if_parts[0], ' ');\r\nif (name) {\r\nname++;\r\n} else {\r\ng_strfreev(if_parts);\r\ncontinue;\r\n}\r\nif_info = g_new0(if_info_t,1);\r\nif_info->name = g_strdup(name);\r\nif (strlen(if_parts[1]) > 0)\r\nif_info->vendor_description = g_strdup(if_parts[1]);\r\nif (strlen(if_parts[2]) > 0)\r\nif_info->friendly_name = g_strdup(if_parts[2]);\r\nif_info->type = (interface_type)(int)strtol(if_parts[3], NULL, 10);\r\naddr_parts = g_strsplit(if_parts[4], ",", 0);\r\nfor (j = 0; addr_parts[j] != NULL; j++) {\r\nif_addr = g_new0(if_addr_t,1);\r\nif (ws_inet_pton4(addr_parts[j], &if_addr->addr.ip4_addr)) {\r\nif_addr->ifat_type = IF_AT_IPv4;\r\n} else if (ws_inet_pton6(addr_parts[j], (struct e_in6_addr *)&if_addr->addr.ip6_addr)) {\r\nif_addr->ifat_type = IF_AT_IPv6;\r\n} else {\r\ng_free(if_addr);\r\nif_addr = NULL;\r\n}\r\nif (if_addr) {\r\nif_info->addrs = g_slist_append(if_info->addrs, if_addr);\r\n}\r\n}\r\nif (strcmp(if_parts[5], "loopback") == 0)\r\nif_info->loopback = TRUE;\r\n#ifdef HAVE_EXTCAP\r\nif_info->extcap = g_strdup(if_parts[6]);\r\n#endif\r\ng_strfreev(if_parts);\r\ng_strfreev(addr_parts);\r\nif_list = g_list_append(if_list, if_info);\r\n}\r\ng_strfreev(raw_list);\r\n#ifdef HAVE_PCAP_REMOTE\r\nif (remote_interface_list && g_list_length(remote_interface_list) > 0) {\r\nif_list = append_remote_list(if_list);\r\n}\r\n#endif\r\n#ifdef HAVE_EXTCAP\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, "Loading External Capture Interface List ...");\r\nif_list = append_extcap_interface_list(if_list, err_str);\r\n#endif\r\nreturn if_list;\r\n}\r\nif_capabilities_t *\r\ncapture_get_if_capabilities(const gchar *ifname, gboolean monitor_mode,\r\nconst gchar *auth_string,\r\nchar **err_str, void (*update_cb)(void))\r\n{\r\nif_capabilities_t *caps;\r\nGList *linktype_list = NULL;\r\nint err, i;\r\ngchar *data, *primary_msg, *secondary_msg;\r\ngchar **raw_list, **lt_parts;\r\ndata_link_info_t *data_link_info;\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, "Capture Interface Capabilities ...");\r\n#ifdef HAVE_EXTCAP\r\ncaps = extcap_get_if_dlts(ifname, err_str);\r\nif (caps != NULL)\r\nreturn caps;\r\nif (err_str != NULL && *err_str != NULL)\r\nreturn NULL;\r\n#endif\r\nerr = sync_if_capabilities_open(ifname, monitor_mode, auth_string, &data,\r\n&primary_msg, &secondary_msg, update_cb);\r\nif (err != 0) {\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, "Capture Interface Capabilities failed, error %d, %s (%s)!",\r\nerr, primary_msg ? primary_msg : "no message",\r\nsecondary_msg ? secondary_msg : "no secondary message");\r\nif (err_str) {\r\n*err_str = primary_msg;\r\n} else {\r\ng_free(primary_msg);\r\n}\r\ng_free(secondary_msg);\r\nreturn NULL;\r\n}\r\n#ifdef _WIN32\r\nraw_list = g_strsplit(data, "\r\n", 0);\r\n#else\r\nraw_list = g_strsplit(data, "\n", 0);\r\n#endif\r\ng_free(data);\r\nif (raw_list[0] == NULL || *raw_list[0] == '\0') {\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, "Capture Interface Capabilities returned no information!");\r\nif (err_str) {\r\n*err_str = g_strdup("Dumpcap returned no interface capability information");\r\n}\r\ng_strfreev(raw_list);\r\nreturn NULL;\r\n}\r\ncaps = (if_capabilities_t *)g_malloc(sizeof *caps);\r\nswitch (*raw_list[0]) {\r\ncase '0':\r\ncaps->can_set_rfmon = FALSE;\r\nbreak;\r\ncase '1':\r\ncaps->can_set_rfmon = TRUE;\r\nbreak;\r\ndefault:\r\ng_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, "Capture Interface Capabilities returned bad information!");\r\nif (err_str) {\r\n*err_str = g_strdup_printf("Dumpcap returned \"%s\" for monitor-mode capability",\r\nraw_list[0]);\r\n}\r\ng_free(caps);\r\ng_strfreev(raw_list);\r\nreturn NULL;\r\n}\r\nfor (i = 1; raw_list[i] != NULL; i++) {\r\nlt_parts = g_strsplit(raw_list[i], "\t", 3);\r\nif (lt_parts[0] == NULL || lt_parts[1] == NULL || lt_parts[2] == NULL) {\r\ng_strfreev(lt_parts);\r\ncontinue;\r\n}\r\ndata_link_info = g_new(data_link_info_t,1);\r\ndata_link_info->dlt = (int) strtol(lt_parts[0], NULL, 10);\r\ndata_link_info->name = g_strdup(lt_parts[1]);\r\nif (strcmp(lt_parts[2], "(not supported)") != 0)\r\ndata_link_info->description = g_strdup(lt_parts[2]);\r\nelse\r\ndata_link_info->description = NULL;\r\ng_strfreev(lt_parts);\r\nlinktype_list = g_list_append(linktype_list, data_link_info);\r\n}\r\ng_strfreev(raw_list);\r\nif (linktype_list == NULL) {\r\nif (err_str)\r\n*err_str = g_strdup("Dumpcap returned no link-layer types");\r\ng_free(caps);\r\nreturn NULL;\r\n}\r\ncaps->data_link_types = linktype_list;\r\nreturn caps;\r\n}\r\nvoid add_interface_to_remote_list(if_info_t *if_info)\r\n{\r\nGSList *list;\r\nif_addr_t *if_addr, *temp_addr;\r\nif_info_t *temp = g_malloc0(sizeof(if_info_t));\r\ntemp->name = g_strdup(if_info->name);\r\ntemp->friendly_name = g_strdup(if_info->friendly_name);\r\ntemp->vendor_description = g_strdup(if_info->vendor_description);\r\nfor (list = g_slist_nth(if_info->addrs, 0); list != NULL; list = g_slist_next(list)) {\r\ntemp_addr = g_malloc0(sizeof(if_addr_t));\r\nif_addr = (if_addr_t *)list->data;\r\nif (if_addr) {\r\ntemp_addr->ifat_type = if_addr->ifat_type;\r\nif (temp_addr->ifat_type == IF_AT_IPv4) {\r\ntemp_addr->addr.ip4_addr = if_addr->addr.ip4_addr;\r\n} else {\r\nmemcpy(temp_addr->addr.ip6_addr, if_addr->addr.ip6_addr, sizeof(if_addr->addr));\r\n}\r\n} else {\r\ng_free(temp_addr);\r\ntemp_addr = NULL;\r\n}\r\nif (temp_addr) {\r\ntemp->addrs = g_slist_append(temp->addrs, temp_addr);\r\n}\r\n}\r\ntemp->loopback = if_info->loopback;\r\nremote_interface_list = g_list_append(remote_interface_list, temp);\r\n}
