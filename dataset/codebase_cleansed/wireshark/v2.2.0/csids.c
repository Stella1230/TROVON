wtap_open_return_val csids_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nint tmp,iplen;\r\ngboolean byteswap = FALSE;\r\nstruct csids_header hdr;\r\ncsids_t *csids;\r\nif( !wtap_read_bytes( wth->fh, &hdr, sizeof( struct csids_header), err, err_info ) ) {\r\nif( *err != WTAP_ERR_SHORT_READ ) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif( hdr.zeropad != 0 || hdr.caplen == 0 ) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nhdr.seconds = pntoh32( &hdr.seconds );\r\nhdr.caplen = pntoh16( &hdr.caplen );\r\nif( !wtap_read_bytes( wth->fh, &tmp, 2, err, err_info ) ) {\r\nif( *err != WTAP_ERR_SHORT_READ ) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif( !wtap_read_bytes(wth->fh, &iplen, 2, err, err_info ) ) {\r\nif( *err != WTAP_ERR_SHORT_READ ) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\niplen = pntoh16(&iplen);\r\nif ( iplen == 0 )\r\nreturn WTAP_OPEN_NOT_MINE;\r\nif( iplen > hdr.caplen ) {\r\niplen = GUINT16_SWAP_LE_BE(iplen);\r\nif( iplen <= hdr.caplen ) {\r\nbyteswap = TRUE;\r\n} else {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\n} else {\r\nbyteswap = FALSE;\r\n}\r\nif (file_seek(wth->fh, 0, SEEK_SET, err) == -1)\r\nreturn WTAP_OPEN_ERROR;\r\ncsids = (csids_t *)g_malloc(sizeof(csids_t));\r\nwth->priv = (void *)csids;\r\ncsids->byteswapped = byteswap;\r\nwth->file_encap = WTAP_ENCAP_RAW_IP;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_CSIDS;\r\nwth->snapshot_length = 0;\r\nwth->subtype_read = csids_read;\r\nwth->subtype_seek_read = csids_seek_read;\r\nwth->file_tsprec = WTAP_TSPREC_SEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean csids_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\ncsids_t *csids = (csids_t *)wth->priv;\r\n*data_offset = file_tell(wth->fh);\r\nreturn csids_read_packet( wth->fh, csids, &wth->phdr, wth->frame_buffer,\r\nerr, err_info );\r\n}\r\nstatic gboolean\r\ncsids_seek_read(wtap *wth,\r\ngint64 seek_off,\r\nstruct wtap_pkthdr *phdr,\r\nBuffer *buf,\r\nint *err,\r\ngchar **err_info)\r\n{\r\ncsids_t *csids = (csids_t *)wth->priv;\r\nif( file_seek( wth->random_fh, seek_off, SEEK_SET, err ) == -1 )\r\nreturn FALSE;\r\nif( !csids_read_packet( wth->random_fh, csids, phdr, buf, err, err_info ) ) {\r\nif( *err == 0 )\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\ncsids_read_packet(FILE_T fh, csids_t *csids, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nstruct csids_header hdr;\r\nguint8 *pd;\r\nif( !wtap_read_bytes_or_eof( fh, &hdr, sizeof( struct csids_header), err, err_info ) )\r\nreturn FALSE;\r\nhdr.seconds = pntoh32(&hdr.seconds);\r\nhdr.caplen = pntoh16(&hdr.caplen);\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS;\r\nphdr->len = hdr.caplen;\r\nphdr->caplen = hdr.caplen;\r\nphdr->ts.secs = hdr.seconds;\r\nphdr->ts.nsecs = 0;\r\nif( !wtap_read_packet_bytes( fh, buf, phdr->caplen, err, err_info ) )\r\nreturn FALSE;\r\npd = ws_buffer_start_ptr( buf );\r\nif( csids->byteswapped ) {\r\nif( phdr->caplen >= 2 ) {\r\nPBSWAP16(pd);\r\nif( phdr->caplen >= 4 ) {\r\nPBSWAP16(pd+2);\r\nif( phdr->caplen >= 6 )\r\nPBSWAP16(pd+4);\r\n}\r\n}\r\n}\r\nreturn TRUE;\r\n}
