static gboolean\r\nifcp_header_test(tvbuff_t *tvb, int offset)\r\n{\r\nguint16 flen, flen1;\r\nif(tvb_captured_length_remaining(tvb, offset)<iFCP_MIN_HEADER_LEN){\r\nreturn FALSE;\r\n}\r\nif(tvb_memeql(tvb, offset, ifcp_header_4_bytes, 4) != 0){\r\nreturn FALSE;\r\n}\r\nflen=tvb_get_ntohs(tvb, offset+12)&0x03FF;\r\nif((flen < 15) || (flen > 545)){\r\nreturn FALSE;\r\n}\r\nflen1=tvb_get_ntohs(tvb, offset+14)&0x03FF;\r\nif(flen!=((~flen1)&0x03FF)){\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\ndissect_ifcpflags(tvbuff_t *tvb, int offset, proto_tree *parent_tree)\r\n{\r\nstatic const int * flags[] = {\r\n&hf_ifcp_flags_ses,\r\n&hf_ifcp_flags_trp,\r\n&hf_ifcp_flags_spc,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(parent_tree, tvb, offset, hf_ifcp_flags,\r\nett_ifcp_flags, flags, ENC_BIG_ENDIAN);\r\noffset++;\r\nreturn offset;\r\n}\r\nstatic void\r\ndissect_commonflags(tvbuff_t *tvb, int offset, proto_tree *parent_tree)\r\n{\r\nstatic const int * flags[] = {\r\n&hf_ifcp_common_flags_crcv,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(parent_tree, tvb, offset, hf_ifcp_common_flags,\r\nett_ifcp_common_flags, flags, ENC_BIG_ENDIAN);\r\n}\r\nstatic int\r\ndissect_ifcp_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data _U_)\r\n{\r\ngint offset = 0, frame_len = 0;\r\nguint8 sof = 0, eof = 0;\r\nproto_item *ti;\r\nproto_tree *tree = NULL;\r\ntvbuff_t *next_tvb;\r\nguint8 protocol;\r\nproto_tree *protocol_tree = NULL;\r\nproto_tree *version_tree = NULL;\r\nproto_tree *frame_len_tree = NULL;\r\nproto_tree *sof_tree = NULL;\r\nproto_tree *eof_tree = NULL;\r\nfc_data_t fc_data;\r\nif(tvb_captured_length(tvb)<iFCP_ENCAP_HEADER_LEN){\r\nreturn 0;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "iFCP");\r\nframe_len = (tvb_get_ntohs (tvb, offset+12) & 0x03FF)*4;\r\nif (parent_tree) {\r\nif (tvb_bytes_exist (tvb, offset, frame_len-4)) {\r\nsof = tvb_get_guint8 (tvb, offset+iFCP_ENCAP_HEADER_LEN);\r\neof = tvb_get_guint8 (tvb, offset+frame_len - 4);\r\nti = proto_tree_add_protocol_format (parent_tree, proto_ifcp, tvb, offset,\r\niFCP_ENCAP_HEADER_LEN,\r\n"iFCP (%s/%s)",\r\nval_to_str (sof, ifcp_sof_vals,\r\n"0x%x"),\r\nval_to_str (eof, ifcp_eof_vals,\r\n"0x%x"));\r\n} else {\r\nsof = tvb_get_guint8 (tvb, offset+iFCP_ENCAP_HEADER_LEN);\r\nti = proto_tree_add_protocol_format (parent_tree, proto_ifcp, tvb, offset,\r\niFCP_ENCAP_HEADER_LEN,\r\n"iFCP (%s/%s)",\r\nval_to_str (sof, ifcp_sof_vals,\r\n"0x%x"),\r\n"NA");\r\n}\r\ntree = proto_item_add_subtree (ti, ett_ifcp);\r\n}\r\nprotocol = tvb_get_guint8 (tvb, offset);\r\nti=proto_tree_add_item(tree, hf_ifcp_protocol, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nprotocol_tree=proto_item_add_subtree(ti, ett_ifcp_protocol);\r\noffset++;\r\nti=proto_tree_add_item(tree, hf_ifcp_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nversion_tree=proto_item_add_subtree(ti, ett_ifcp_version);\r\noffset++;\r\nproto_tree_add_item(protocol_tree, hf_ifcp_protocol_c, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(version_tree, hf_ifcp_version_c, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\noffset+=4;\r\nif(protocol==FCENCAP_PROTO_iFCP){\r\nproto_tree_add_item(tree, hf_ifcp_ls_command_acc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\noffset=dissect_ifcpflags(tvb, offset, tree);\r\nti=proto_tree_add_item(tree, hf_ifcp_sof, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nsof_tree=proto_item_add_subtree(ti, ett_ifcp_sof);\r\noffset++;\r\nti=proto_tree_add_item(tree, hf_ifcp_eof, tvb, offset, 1, ENC_BIG_ENDIAN);\r\neof_tree=proto_item_add_subtree(ti, ett_ifcp_eof);\r\noffset++;\r\n} else {\r\noffset+=4;\r\nsof_tree=tree;\r\neof_tree=tree;\r\n}\r\ndissect_commonflags(tvb, offset, tree);\r\nti=proto_tree_add_item(tree, hf_ifcp_framelen, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nframe_len_tree=proto_item_add_subtree(ti, ett_ifcp_frame_len);\r\noffset+=2;\r\nproto_tree_add_item(frame_len_tree, hf_ifcp_encap_flags_c, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(frame_len_tree, hf_ifcp_framelen_c, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(tree, hf_ifcp_tsec, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ifcp_tusec, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ifcp_encap_crc, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nproto_tree_add_item(sof_tree, hf_ifcp_sof, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(sof_tree, hf_ifcp_sof, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(sof_tree, hf_ifcp_sof_c, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(sof_tree, hf_ifcp_sof_c, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nif(tvb_bytes_exist(tvb, frame_len-4, 4)) {\r\nproto_tree_add_item(eof_tree, hf_ifcp_eof, tvb, frame_len-4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(eof_tree, hf_ifcp_eof, tvb, frame_len-3, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(eof_tree, hf_ifcp_eof_c, tvb, frame_len-2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(eof_tree, hf_ifcp_eof_c, tvb, frame_len-1, 1, ENC_BIG_ENDIAN);\r\n}\r\nfc_data.sof_eof = 0;\r\nswitch(sof){\r\ncase iFCP_SOFi3:\r\ncase iFCP_SOFi2:\r\ncase iFCP_SOFi4:\r\nfc_data.sof_eof = FC_DATA_SOF_FIRST_FRAME;\r\nbreak;\r\ncase iFCP_SOFf:\r\nfc_data.sof_eof = FC_DATA_SOF_SOFF;\r\nbreak;\r\ndefault:\r\nif(sof){\r\nif (eof != iFCP_EOFn) {\r\nfc_data.sof_eof |= FC_DATA_EOF_LAST_FRAME;\r\n} else if (eof != iFCP_EOFt) {\r\nfc_data.sof_eof |= FC_DATA_EOF_INVALID;\r\n}\r\n}\r\n}\r\nnext_tvb=tvb_new_subset_length(tvb, offset, frame_len-offset-4);\r\nfc_data.ethertype = 0;\r\nif(fc_handle){\r\ncall_dissector_with_data(fc_handle, next_tvb, pinfo, parent_tree, &fc_data);\r\n} else {\r\ncall_data_dissector(next_tvb, pinfo, parent_tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic guint\r\nget_ifcp_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nguint pdu_len;\r\nif(!ifcp_header_test(tvb, offset)){\r\nreturn 0;\r\n}\r\npdu_len=(tvb_get_ntohs(tvb, offset+12)&0x03FF)*4;\r\nreturn pdu_len;\r\n}\r\nstatic int\r\ndissect_ifcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, parent_tree, ifcp_desegment, iFCP_MIN_HEADER_LEN, get_ifcp_pdu_len, dissect_ifcp_pdu, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_ifcp_handle(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\nreturn dissect_ifcp(tvb, pinfo, tree, data);\r\n}\r\nstatic gboolean\r\ndissect_ifcp_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nif(!ifcp_header_test(tvb, 0)){\r\nreturn FALSE;\r\n}\r\ndissect_ifcp(tvb, pinfo, tree, data);\r\nif(ifcp_handle){\r\nconversation_t* ifcp_conv;\r\nifcp_conv=find_or_create_conversation(pinfo);\r\nconversation_set_dissector(ifcp_conv, ifcp_handle);\r\n}\r\nreturn TRUE;\r\n}\r\nvoid\r\nproto_register_ifcp (void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ifcp_protocol,\r\n{"Protocol", "ifcp.encap.proto", FT_UINT8, BASE_DEC, VALS(fcencap_proto_vals), 0,\r\nNULL, HFILL }},\r\n{ &hf_ifcp_protocol_c,\r\n{"Protocol (1's Complement)", "ifcp.encap.protoc", FT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}},\r\n{ &hf_ifcp_version,\r\n{"Version", "ifcp.encap.version", FT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}},\r\n{ &hf_ifcp_version_c,\r\n{"Version (1's Complement)", "ifcp.encap.versionc", FT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}},\r\n{ &hf_ifcp_encap_flags_c,\r\n{"iFCP Encapsulation Flags (1's Complement)", "ifcp.encap_flagsc", FT_UINT8, BASE_HEX, NULL, 0xFC,\r\nNULL, HFILL}},\r\n{ &hf_ifcp_framelen,\r\n{"Frame Length (in Words)", "ifcp.encap.framelen", FT_UINT16, BASE_DEC, NULL, 0x03FF,\r\nNULL, HFILL}},\r\n{ &hf_ifcp_framelen_c,\r\n{"Frame Length (1's Complement)", "ifcp.encap.framelenc", FT_UINT16, BASE_DEC, NULL, 0x03FF,\r\nNULL, HFILL}},\r\n{ &hf_ifcp_tsec,\r\n{"Time (secs)", "ifcp.encap.tsec", FT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL}},\r\n{ &hf_ifcp_tusec,\r\n{"Time (fraction)", "ifcp.encap.tusec", FT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL}},\r\n{ &hf_ifcp_encap_crc,\r\n{"CRC", "ifcp.encap.crc", FT_UINT32, BASE_HEX, NULL, 0,\r\nNULL, HFILL}},\r\n{ &hf_ifcp_sof,\r\n{"SOF", "ifcp.sof", FT_UINT8, BASE_HEX, VALS (ifcp_sof_vals), 0,\r\nNULL, HFILL}},\r\n{ &hf_ifcp_eof,\r\n{"EOF", "ifcp.eof", FT_UINT8, BASE_HEX, VALS (ifcp_eof_vals), 0,\r\nNULL, HFILL}},\r\n{ &hf_ifcp_sof_c,\r\n{"SOF Compliment", "ifcp.sof_c", FT_UINT8, BASE_HEX, NULL , 0,\r\nNULL, HFILL}},\r\n{ &hf_ifcp_eof_c,\r\n{"EOF Compliment", "ifcp.eof_c", FT_UINT8, BASE_HEX, NULL , 0,\r\nNULL, HFILL}},\r\n{ &hf_ifcp_ls_command_acc,\r\n{"Ls Command Acc", "ifcp.ls_command_acc", FT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL}},\r\n{ &hf_ifcp_common_flags,\r\n{"Flags", "ifcp.common_flags", FT_UINT8, BASE_HEX , NULL, 0xfc,\r\nNULL, HFILL }},\r\n{ &hf_ifcp_common_flags_crcv,\r\n{"CRC", "ifcp.common_flags.crcv", FT_BOOLEAN, 8, TFS(&tfs_valid_not_valid), IFCP_COMMON_FLAGS_CRCV,\r\n"Is the CRC field valid?", HFILL }},\r\n{ &hf_ifcp_flags,\r\n{"iFCP Flags", "ifcp.flags", FT_UINT8, BASE_HEX , NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_ifcp_flags_ses,\r\n{"SES", "ifcp.flags.ses", FT_BOOLEAN, 8, TFS(&ifcp_flags_ses_tfs), IFCP_FLAGS_SES,\r\n"Is this a Session control frame", HFILL }},\r\n{ &hf_ifcp_flags_trp,\r\n{"TRP", "ifcp.flags.trp", FT_BOOLEAN, 8, TFS(&ifcp_flags_trp_tfs), IFCP_FLAGS_TRP,\r\n"Is address transparent mode enabled", HFILL }},\r\n{ &hf_ifcp_flags_spc,\r\n{"SPC", "ifcp.flags.spc", FT_BOOLEAN, 8, TFS(&ifcp_flags_spc_tfs), IFCP_FLAGS_SPC,\r\n"Is frame part of link service", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ifcp,\r\n&ett_ifcp_sof,\r\n&ett_ifcp_eof,\r\n&ett_ifcp_protocol,\r\n&ett_ifcp_version,\r\n&ett_ifcp_frame_len,\r\n&ett_ifcp_flags,\r\n&ett_ifcp_common_flags,\r\n};\r\nmodule_t *ifcp_module;\r\nproto_ifcp = proto_register_protocol("iFCP", "iFCP", "ifcp");\r\nproto_register_field_array(proto_ifcp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nifcp_module = prefs_register_protocol(proto_ifcp, NULL);\r\nprefs_register_bool_preference(ifcp_module,\r\n"desegment",\r\n"Reassemble iFCP messages spanning multiple TCP segments",\r\n"Whether the iFCP dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&ifcp_desegment);\r\nprefs_register_obsolete_preference(ifcp_module, "target_port");\r\n}\r\nvoid\r\nproto_reg_handoff_ifcp (void)\r\n{\r\nheur_dissector_add("tcp", dissect_ifcp_heur, "iFCP over TCP", "ifcp_tcp", proto_ifcp, HEURISTIC_ENABLE);\r\nifcp_handle = create_dissector_handle(dissect_ifcp_handle, proto_ifcp);\r\ndissector_add_for_decode_as("tcp.port", ifcp_handle);\r\nfc_handle = find_dissector_add_dependency("fc_ifcp", proto_ifcp);\r\n}
