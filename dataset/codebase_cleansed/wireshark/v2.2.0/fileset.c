gboolean\r\nfileset_filename_match_pattern(const char *fname)\r\n{\r\nchar *pfx;\r\nsize_t baselen;\r\nsize_t minlen = strlen("_00001_20050418010750");\r\nchar *filename;\r\nfilename = g_strdup(get_basename(fname));\r\npfx = strrchr(filename, '.');\r\nif(pfx == NULL) {\r\npfx = filename + strlen(filename);\r\n}\r\n*pfx = '\0';\r\nbaselen = strlen(filename);\r\nif(baselen < minlen) {\r\ng_free(filename);\r\nreturn FALSE;\r\n}\r\nif(filename[baselen-minlen] != '_' || filename[baselen-minlen+6] != '_') {\r\ng_free(filename);\r\nreturn FALSE;\r\n}\r\nfilename[baselen-minlen] = '0';\r\nfilename[baselen-minlen+6] = '0';\r\nwhile(minlen--) {\r\nbaselen--;\r\nif(!g_ascii_isdigit( filename[baselen])) {\r\ng_free(filename);\r\nreturn FALSE;\r\n}\r\n}\r\ng_free(filename);\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nfileset_is_file_in_set(const char *fname1, const char *fname2)\r\n{\r\nchar *pfx1;\r\nchar *pfx2;\r\nchar *dup_f1;\r\nchar *dup_f2;\r\nsize_t minlen = strlen("_00001_20050418010750");\r\ng_assert(fileset_filename_match_pattern(fname1));\r\ng_assert(fileset_filename_match_pattern(fname2));\r\ndup_f1 = g_strdup(fname1);\r\ndup_f2 = g_strdup(fname2);\r\npfx1 = strrchr(dup_f1, '.');\r\npfx2 = strrchr(dup_f2, '.');\r\nif (!pfx1) pfx1 = dup_f1 + strlen(dup_f1);\r\nif (!pfx2) pfx2 = dup_f2 + strlen(dup_f2);\r\nif(strcmp(pfx1, pfx2) != 0) {\r\ng_free(dup_f1);\r\ng_free(dup_f2);\r\nreturn FALSE;\r\n}\r\n*(pfx1-minlen) = '\0';\r\n*(pfx2-minlen) = '\0';\r\nif(strcmp(dup_f1, dup_f2) != 0) {\r\ng_free(dup_f1);\r\ng_free(dup_f2);\r\nreturn FALSE;\r\n}\r\ng_free(dup_f1);\r\ng_free(dup_f2);\r\nreturn TRUE;\r\n}\r\nstatic gint\r\nfileset_find_by_path(gconstpointer a, gconstpointer b)\r\n{\r\nconst fileset_entry *entry;\r\nconst char *path;\r\nentry = (const fileset_entry *) a;\r\npath = (const char *) b;\r\nreturn g_strcmp0(entry->fullname, path);\r\n}\r\nvoid\r\nfileset_update_file(const char *path)\r\n{\r\nint fh, result;\r\nws_statb64 buf;\r\nfileset_entry *entry = NULL;\r\nGList *entry_list;\r\nfh = ws_open( path, O_RDONLY, 0000 );\r\nif(fh != -1) {\r\nresult = ws_fstat64( fh, &buf );\r\nif( result == 0 ) {\r\nentry_list = g_list_find_custom(set.entries, path,\r\nfileset_find_by_path);\r\nif (entry_list) {\r\nentry = (fileset_entry *) entry_list->data;\r\nentry->ctime = buf.st_ctime;\r\nentry->mtime = buf.st_mtime;\r\nentry->size = buf.st_size;\r\n}\r\n}\r\nws_close(fh);\r\n}\r\n}\r\nstatic fileset_entry *\r\nfileset_add_file(const char *dirname, const char *fname, gboolean current)\r\n{\r\nint fh, result;\r\nws_statb64 buf;\r\nchar *path;\r\nfileset_entry *entry = NULL;\r\npath = g_strdup_printf("%s%s", dirname, fname);\r\nfh = ws_open( path, O_RDONLY, 0000 );\r\nif(fh != -1) {\r\nresult = ws_fstat64( fh, &buf );\r\nif( result == 0 ) {\r\nentry = (fileset_entry *)g_malloc(sizeof(fileset_entry));\r\nentry->fullname = g_strdup(path);\r\nentry->name = g_strdup(fname);\r\nentry->ctime = buf.st_ctime;\r\nentry->mtime = buf.st_mtime;\r\nentry->size = buf.st_size;\r\nentry->current = current;\r\nset.entries = g_list_append(set.entries, entry);\r\n}\r\nws_close(fh);\r\n}\r\ng_free(path);\r\nreturn entry;\r\n}\r\nstatic gint\r\nfileset_sort_compare(gconstpointer a, gconstpointer b)\r\n{\r\nconst fileset_entry *entry_a = (const fileset_entry *)a;\r\nconst fileset_entry *entry_b = (const fileset_entry *)b;\r\nreturn strcmp(entry_a->name, entry_b->name);\r\n}\r\nvoid fileset_update_dlg(void *window)\r\n{\r\nGList *le;\r\nle = g_list_first(set.entries);\r\nwhile(le) {\r\nfileset_dlg_add_file((fileset_entry *)le->data, window);\r\nle = g_list_next(le);\r\n}\r\n}\r\nvoid\r\nfileset_add_dir(const char *fname, void *window)\r\n{\r\nWS_DIR *dir;\r\nWS_DIRENT *file;\r\nconst char *name;\r\nGString *dirname;\r\ngchar *fname_dup;\r\nfname_dup = g_strdup(fname);\r\ndirname = g_string_new(get_dirname(fname_dup));\r\ng_free(fname_dup);\r\nset.dirname = g_strdup(dirname->str);\r\ndirname = g_string_append_c(dirname, G_DIR_SEPARATOR);\r\nif(fileset_filename_match_pattern(fname)) {\r\nif ((dir = ws_dir_open(dirname->str, 0, NULL)) != NULL) {\r\nwhile ((file = ws_dir_read_name(dir)) != NULL) {\r\nname = ws_dir_get_name(file);\r\nif(fileset_filename_match_pattern(name) && fileset_is_file_in_set(name, get_basename(fname))) {\r\nfileset_add_file(dirname->str, name, strcmp(name, get_basename(fname))== 0 );\r\n}\r\n}\r\nws_dir_close(dir);\r\n}\r\n} else {\r\nfileset_add_file(dirname->str, get_basename(fname), TRUE );\r\n}\r\ng_string_free(dirname, TRUE );\r\nset.entries = g_list_sort(set.entries, fileset_sort_compare);\r\nfileset_update_dlg(window);\r\n}\r\nconst char *\r\nfileset_get_dirname(void)\r\n{\r\nreturn set.dirname;\r\n}\r\nstatic GList *\r\nfileset_get_current(void)\r\n{\r\nGList *le;\r\nfileset_entry *entry;\r\nle = g_list_first(set.entries);\r\nwhile(le) {\r\nentry = (fileset_entry *)le->data;\r\nif(entry->current) {\r\nreturn le;\r\n}\r\nle = g_list_next(le);\r\n}\r\nreturn NULL;\r\n}\r\nfileset_entry *\r\nfileset_get_next(void)\r\n{\r\nGList *le;\r\nle = fileset_get_current();\r\nif(le == NULL) {\r\nreturn NULL;\r\n}\r\nle = g_list_next(le);\r\nif(le == NULL) {\r\nreturn NULL;\r\n}\r\nreturn (fileset_entry *)le->data;\r\n}\r\nfileset_entry *\r\nfileset_get_previous(void)\r\n{\r\nGList *le;\r\nle = fileset_get_current();\r\nif(le == NULL) {\r\nreturn NULL;\r\n}\r\nle = g_list_previous(le);\r\nif(le == NULL) {\r\nreturn NULL;\r\n}\r\nreturn (fileset_entry *)le->data;\r\n}\r\nstatic void fileset_entry_delete(gpointer data, gpointer user_data _U_)\r\n{\r\nfileset_entry *entry = (fileset_entry *)data;\r\ng_free( (gpointer) entry->fullname);\r\nentry->fullname = NULL;\r\ng_free( (gpointer) entry->name);\r\nentry->name = NULL;\r\ng_free(entry);\r\n}\r\nvoid fileset_delete(void)\r\n{\r\nif(set.entries) {\r\ng_list_foreach(set.entries, fileset_entry_delete, NULL);\r\ng_list_free(set.entries);\r\nset.entries = NULL;\r\n}\r\nif(set.dirname) {\r\ng_free( (gpointer) set.dirname);\r\nset.dirname = NULL;\r\n}\r\n}
