static int get_content_item_length(tvbuff_t *tvb, int offset)\r\n{\r\nint origoffset = offset;\r\nwhile (tvb_captured_length_remaining(tvb, offset) >= 2) {\r\nif (tvb_get_ntohs(tvb, offset) == 0xc080) {\r\nbreak;\r\n}\r\noffset += 1;\r\n}\r\nreturn offset - origoffset;\r\n}\r\nstatic guint\r\nget_ymsg_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nguint plen;\r\nplen = tvb_get_ntohs(tvb, offset + 8);\r\nreturn plen + YAHOO_HEADER_SIZE;\r\n}\r\nstatic int\r\ndissect_ymsg_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *ymsg_tree, *ti;\r\nproto_item *content_item;\r\nproto_tree *content_tree;\r\nchar *keybuf;\r\nchar *valbuf;\r\nint keylen;\r\nint vallen;\r\nint content_len;\r\nint offset = 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "YMSG");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"%s (status=%s) ",\r\nval_to_str(tvb_get_ntohs(tvb, offset + 10),\r\nymsg_service_vals, "Unknown Service: %u"),\r\nval_to_str(tvb_get_ntohl(tvb, offset + 12),\r\nymsg_status_vals, "Unknown Status: %u")\r\n);\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_ymsg, tvb, offset, -1, ENC_NA);\r\nymsg_tree = proto_item_add_subtree(ti, ett_ymsg);\r\noffset += 4;\r\nproto_tree_add_item(ymsg_tree, hf_ymsg_version, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(ymsg_tree, hf_ymsg_vendor, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\ncontent_len = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(ymsg_tree, hf_ymsg_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_item_append_text(ti, " (%s)",\r\nval_to_str_const(tvb_get_ntohs(tvb, offset),\r\nymsg_service_vals,\r\n"Unknown"));\r\nproto_tree_add_item(ymsg_tree, hf_ymsg_service, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(ymsg_tree, hf_ymsg_status, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(ymsg_tree, hf_ymsg_session_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nif (content_len) {\r\ncontent_item = proto_tree_add_item(ymsg_tree, hf_ymsg_content, tvb,\r\noffset, -1, ENC_NA);\r\ncontent_tree = proto_item_add_subtree(content_item, ett_ymsg_content);\r\nfor (;;)\r\n{\r\nproto_item *ti_2;\r\nproto_tree *content_line_tree;\r\nif (offset >= (YAHOO_HEADER_SIZE+content_len-4))\r\n{\r\nbreak;\r\n}\r\nkeylen = get_content_item_length(tvb, offset);\r\nkeybuf = tvb_format_text(tvb, offset, keylen);\r\nvallen = get_content_item_length(tvb, offset+keylen+2);\r\nvalbuf = tvb_format_text(tvb, offset+keylen+2, vallen);\r\nti_2 = proto_tree_add_string_format(content_tree, hf_ymsg_content_line, tvb,\r\noffset, keylen+2+vallen+2,\r\n"", "%s:%s", keybuf, valbuf);\r\ncontent_line_tree = proto_item_add_subtree(ti_2, ett_ymsg_content_line);\r\nproto_tree_add_item(content_line_tree, hf_ymsg_content_line_key, tvb,\r\noffset, keylen, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(content_line_tree, hf_ymsg_content_line_value, tvb,\r\noffset+keylen+2, vallen, ENC_ASCII|ENC_NA);\r\noffset += keylen+2+vallen+2;\r\n}\r\n}\r\n}\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\ndissect_ymsg(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nif (tvb_captured_length(tvb) < 4) {\r\nreturn FALSE;\r\n}\r\nif (tvb_memeql(tvb, 0, "YMSG", 4) == -1) {\r\nreturn FALSE;\r\n}\r\ntcp_dissect_pdus(tvb, pinfo, tree, ymsg_desegment, 10, get_ymsg_pdu_len,\r\ndissect_ymsg_pdu, data);\r\nreturn TRUE;\r\n}\r\nvoid\r\nproto_register_ymsg(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ymsg_version, {\r\n"Version", "ymsg.version", FT_UINT16, BASE_DEC,\r\nNULL, 0, "Packet version identifier", HFILL }},\r\n{ &hf_ymsg_vendor, {\r\n"Vendor ID", "ymsg.vendor", FT_UINT16, BASE_DEC,\r\nNULL, 0, "Vendor identifier", HFILL }},\r\n{ &hf_ymsg_len, {\r\n"Packet Length", "ymsg.len", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ymsg_service, {\r\n"Service", "ymsg.service", FT_UINT16, BASE_DEC,\r\nVALS(ymsg_service_vals), 0, "Service Type", HFILL }},\r\n{ &hf_ymsg_status, {\r\n"Status", "ymsg.status", FT_UINT32, BASE_DEC,\r\nVALS(ymsg_status_vals), 0, "Message Type Flags", HFILL }},\r\n{ &hf_ymsg_session_id, {\r\n"Session ID", "ymsg.session_id", FT_UINT32, BASE_HEX,\r\nNULL, 0, "Connection ID", HFILL }},\r\n{ &hf_ymsg_content, {\r\n"Content", "ymsg.content", FT_BYTES, BASE_NONE,\r\nNULL, 0, "Data portion of the packet", HFILL }},\r\n{ &hf_ymsg_content_line, {\r\n"Content-line", "ymsg.content-line", FT_STRING, BASE_NONE,\r\nNULL, 0, "Content line", HFILL }},\r\n{ &hf_ymsg_content_line_key, {\r\n"Key", "ymsg.content-line.key", FT_STRING, BASE_NONE,\r\nNULL, 0, "Content line key", HFILL }},\r\n{ &hf_ymsg_content_line_value, {\r\n"Value", "ymsg.content-line.value", FT_STRING, BASE_NONE,\r\nNULL, 0, "Content line value", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ymsg,\r\n&ett_ymsg_content,\r\n&ett_ymsg_content_line\r\n};\r\nmodule_t *ymsg_module;\r\nproto_ymsg = proto_register_protocol("Yahoo YMSG Messenger Protocol",\r\n"YMSG", "ymsg");\r\nproto_register_field_array(proto_ymsg, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nymsg_module = prefs_register_protocol(proto_ymsg, NULL);\r\nprefs_register_bool_preference(ymsg_module, "desegment",\r\n"Reassemble YMSG messages spanning multiple TCP segments",\r\n"Whether the YMSG dissector should reassemble messages spanning multiple TCP segments. "\r\n"To use this option, you must also enable"\r\n" \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&ymsg_desegment);\r\n}\r\nvoid\r\nproto_reg_handoff_ymsg(void)\r\n{\r\nheur_dissector_add("tcp", dissect_ymsg, "Yahoo YMSG Messenger over TCP", "ymsg_tcp", proto_ymsg, HEURISTIC_ENABLE);\r\n}
