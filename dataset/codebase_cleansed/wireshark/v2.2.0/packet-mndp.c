static const gchar*\r\nmatch_strextval_idx(guint32 val, const ext_value_string *vs, gint *idx) {\r\ngint i = 0;\r\nif(vs) {\r\nwhile (vs[i].strptr) {\r\nif (vs[i].value == val) {\r\nif (idx)\r\n*idx = i;\r\nreturn(vs[i].strptr);\r\n}\r\ni++;\r\n}\r\n}\r\nif (idx)\r\n*idx = -1;\r\nreturn NULL;\r\n}\r\nstatic const gchar*\r\nextval_to_str_idx(guint32 val, const ext_value_string *vs, gint *idx, const char *fmt) {\r\nconst gchar *ret;\r\nif (!fmt)\r\nfmt="Unknown";\r\nret = match_strextval_idx(val, vs, idx);\r\nif (ret != NULL)\r\nreturn ret;\r\nreturn wmem_strdup_printf(wmem_packet_scope(), fmt, val);\r\n}\r\nstatic int\r\ndissect_tlv(tvbuff_t *tvb, packet_info *pinfo, proto_tree *mndp_tree,\r\nguint32 offset, guint32 length _U_, const ext_value_string *value_array)\r\n{\r\nguint32 tlv_type;\r\nguint32 tlv_length;\r\nproto_item *tlv_tree;\r\nproto_item *type_item;\r\nint type_index;\r\nguint32 tlv_end;\r\nguint encoding_info;\r\ntlv_type = tvb_get_ntohs(tvb, offset);\r\ntlv_length = tvb_get_ntohs(tvb, offset + 2);\r\ntlv_tree = proto_tree_add_subtree_format(mndp_tree, tvb,\r\noffset, tlv_length+4, ett_mndp_tlv_header, NULL,\r\n"T %d, L %d: %s",\r\ntlv_type,\r\ntlv_length,\r\nextval_to_str_idx(tlv_type, value_array, NULL, "Unknown"));\r\ntype_item = proto_tree_add_item(tlv_tree, hf_mndp_tlv_type,\r\ntvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(type_item, " = %s",\r\nextval_to_str_idx(tlv_type, value_array,\r\n&type_index, "Unknown"));\r\noffset += 2;\r\nproto_tree_add_item(tlv_tree, hf_mndp_tlv_length,\r\ntvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif (tlv_length == 0)\r\nreturn offset;\r\ntlv_end = offset + tlv_length;\r\nif ( type_index != -1\r\n&& !value_array[type_index].specialfunction\r\n&& value_array[type_index].evs != NULL\r\n) {\r\nencoding_info = value_array[type_index].evs ? TRUE : FALSE;\r\n} else {\r\nencoding_info = FALSE;\r\n}\r\nif ( type_index != -1 && value_array[type_index].hf_element) {\r\nproto_tree_add_item(tlv_tree,\r\n*(value_array[type_index].hf_element),\r\ntvb, offset, tlv_length, encoding_info);\r\n} else {\r\nproto_tree_add_item(tlv_tree, hf_mndp_tlv_data,\r\ntvb, offset, tlv_length, ENC_NA);\r\n}\r\nif ( type_index != -1 && value_array[type_index].specialfunction ) {\r\nguint32 newoffset;\r\nwhile (offset < tlv_end) {\r\nnewoffset = value_array[type_index].specialfunction (\r\ntvb, pinfo, tlv_tree, offset, tlv_length,\r\nvalue_array[type_index].evs);\r\nDISSECTOR_ASSERT(newoffset > offset);\r\noffset = newoffset;\r\n}\r\n}\r\nreturn tlv_end;\r\n}\r\nstatic int\r\ndissect_mndp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nproto_item *ti;\r\nproto_tree *mndp_tree;\r\nguint32 offset = 0;\r\nguint32 packet_length;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, PROTO_SHORT_NAME);\r\npacket_length = tvb_reported_length(tvb);\r\nti = proto_tree_add_item(tree, proto_mndp, tvb, offset, -1,\r\nENC_NA);\r\nmndp_tree = proto_item_add_subtree(ti, ett_mndp);\r\nproto_tree_add_item(mndp_tree, hf_mndp_header_unknown, tvb, offset, 2,\r\nENC_NA);\r\noffset += 2;\r\nproto_tree_add_item(mndp_tree, hf_mndp_header_seqno, tvb, offset, 2,\r\nENC_BIG_ENDIAN);\r\noffset += 2;\r\nwhile (offset < packet_length) {\r\noffset = dissect_tlv(tvb, pinfo, mndp_tree,\r\noffset, 0, mndp_body_tlv_vals);\r\n}\r\nreturn offset;\r\n}\r\nstatic gboolean\r\ntest_mndp(tvbuff_t *tvb)\r\n{\r\nif ( tvb_captured_length(tvb) < 8\r\n|| tvb_get_guint8(tvb, 4) != 0\r\n|| tvb_get_guint8(tvb, 6) != 0\r\n) {\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\ndissect_mndp_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nif ( !test_mndp(tvb) ) {\r\nreturn FALSE;\r\n}\r\ndissect_mndp(tvb, pinfo, tree);\r\nreturn TRUE;\r\n}\r\nstatic int\r\ndissect_mndp_static(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nif ( !test_mndp(tvb) ) {\r\nreturn 0;\r\n}\r\nreturn dissect_mndp(tvb, pinfo, tree);\r\n}\r\nvoid\r\nproto_register_mndp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_mndp_tlv_type,\r\n{ "TlvType", "mndp.tlv.type", FT_UINT16, BASE_DEC, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_mndp_tlv_length,\r\n{ "TlvLength", "mndp.tlv.length", FT_UINT16, BASE_DEC, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_mndp_tlv_data,\r\n{ "TlvData", "mndp.tlv.data", FT_BYTES, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_mndp_header_unknown,\r\n{ "Header Unknown", "mndp.header.unknown", FT_BYTES, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_mndp_header_seqno,\r\n{ "SeqNo", "mndp.header.seqno", FT_UINT16, BASE_DEC, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_mndp_mac,\r\n{ "MAC-Address", "mndp.mac", FT_ETHER, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_mndp_softwareid,\r\n{ "Software-ID", "mndp.softwareid", FT_STRING, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_mndp_version,\r\n{ "Version", "mndp.version", FT_STRING, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_mndp_identity,\r\n{ "Identity", "mndp.identity", FT_STRING, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_mndp_uptime,\r\n{ "Uptime", "mndp.uptime", FT_RELATIVE_TIME, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_mndp_platform,\r\n{ "Platform", "mndp.platform", FT_STRING, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_mndp_board,\r\n{ "Board", "mndp.board", FT_STRING, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_mndp_unpack,\r\n{ "Unpack", "mndp.unpack", FT_UINT8, BASE_DEC, VALS(mndp_unpack_vals),\r\n0x0, NULL, HFILL }},\r\n{ &hf_mndp_ipv6address,\r\n{ "IPv6-Address", "mndp.ipv6address", FT_IPv6, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_mndp_interfacename,\r\n{ "Interface name", "mndp.interfacename", FT_STRING, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_mndp,\r\n&ett_mndp_tlv_header,\r\n};\r\nproto_mndp = proto_register_protocol(PROTO_LONG_NAME, PROTO_SHORT_NAME, "mndp");\r\nproto_register_field_array(proto_mndp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_mndp(void)\r\n{\r\ndissector_handle_t mndp_handle;\r\nmndp_handle = create_dissector_handle(dissect_mndp_static, proto_mndp);\r\ndissector_add_uint("udp.port", PORT_MNDP, mndp_handle);\r\nheur_dissector_add("udp", dissect_mndp_heur, "MNDP over UDP", "mndp_udp", proto_mndp, HEURISTIC_DISABLE);\r\n}
