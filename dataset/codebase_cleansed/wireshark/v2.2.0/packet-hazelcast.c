static guint get_hazelcast_message_len(packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset, void *data _U_)\r\n{\r\nguint messageLength;\r\nguint headerKeyLength;\r\nguint headerValueLength;\r\nmessageLength = tvb_get_ntohl(tvb, offset);\r\nheaderKeyLength = tvb_get_ntohl(tvb, offset+4);\r\nheaderValueLength = tvb_get_ntohl(tvb, offset+8);\r\nreturn messageLength + headerKeyLength + headerValueLength + 13;\r\n}\r\nstatic int dissect_hazelcast_message(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_) {\r\nguint8 version;\r\nguint8 flags;\r\nguint8 operation;\r\nguint8 lockCountFlag;\r\nguint8 timeoutFlag;\r\nguint8 ttlFlag;\r\nguint8 txnFlag;\r\nguint8 longValueFlag;\r\nguint8 versionFlag;\r\nguint8 lockAddrNullFlag;\r\nguint32 nameLength;\r\nguint32 keyLength;\r\nguint32 valueLength;\r\ngint offset = 0;\r\nproto_tree *hcast_tree = NULL;\r\nproto_tree *flag_tree = NULL;\r\nproto_item *tf = NULL;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "HAZELCAST");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Hazelcast distributed object goodness");\r\nif (tree) {\r\nproto_item *ti;\r\nti = proto_tree_add_item(tree, proto_hazelcast, tvb, 0, -1, ENC_NA);\r\nhcast_tree = proto_item_add_subtree(ti, ett_hazelcast);\r\n}\r\nif (tvb_captured_length_remaining(tvb, 0) < 13) {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Hazelcast too short");\r\nreturn 0;\r\n}\r\nversion = tvb_get_guint8(tvb, 12);\r\nif ( version != 6 ) {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Hazelcast unsupported version");\r\nreturn 12;\r\n}\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_headerLength, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_headerKeyLength, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nkeyLength = tvb_get_ntohl(tvb, offset);\r\noffset += 4;\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_headerValueLength, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nvalueLength = tvb_get_ntohl(tvb, offset);\r\noffset += 4;\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_headerVersion, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_operation, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noperation = tvb_get_guint8(tvb, offset);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s", val_to_str(operation, operationTypes, "Unknown (0x%02x)"));\r\noffset += 1;\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_blockID, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_threadID, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nflags = tvb_get_guint8(tvb, offset);\r\ntf = proto_tree_add_item(hcast_tree, hf_hazelcast_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nflag_tree = proto_item_add_subtree(tf, ett_hazelcast_flags);\r\nproto_tree_add_item(flag_tree, hf_hazelcast_flags_lockCount, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_hazelcast_flags_timeout, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_hazelcast_flags_ttl, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_hazelcast_flags_txn, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_hazelcast_flags_longValue, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_hazelcast_flags_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_hazelcast_flags_client, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_hazelcast_flags_lockAddrNull, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nlockCountFlag = flags & HAZELCAST_LOCKCOUNT_FLAG;\r\ntimeoutFlag = flags & HAZELCAST_TIMEOUT_FLAG;\r\nttlFlag = flags & HAZELCAST_TTL_FLAG;\r\ntxnFlag = flags & HAZELCAST_TXN_FLAG;\r\nlongValueFlag = flags & HAZELCAST_LONGVALUE_FLAG;\r\nversionFlag = flags & HAZELCAST_VERSION_FLAG;\r\nlockAddrNullFlag = flags & HAZELCAST_LOCKADDRNULL_FLAG;\r\noffset += 1;\r\nif ( lockCountFlag ) {\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_lockCount, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nif ( timeoutFlag ) {\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_timeout, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\n}\r\nif ( ttlFlag ) {\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_ttl, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\n}\r\nif ( txnFlag ) {\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_txnID, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\n}\r\nif ( longValueFlag ) {\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_longValue, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\n}\r\nif ( versionFlag ) {\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_version, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\n}\r\nif ( lockAddrNullFlag == 0 ) {\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_lockAddrIP, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_lockAddrPort, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_callID, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_responseType, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_nameLength, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nnameLength = tvb_get_ntohl(tvb, offset);\r\noffset += 4;\r\nif ( nameLength > 0 ) {\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_name, tvb, offset, nameLength, ENC_ASCII|ENC_NA);\r\noffset += nameLength;\r\n}\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_indexCount, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_keyPartitionHash, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_valuePartitionHash, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nif ( keyLength > 0 ) {\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_keys, tvb, offset, keyLength, ENC_NA);\r\noffset += keyLength;\r\n}\r\nif ( valueLength > 0 ) {\r\nproto_tree_add_item(hcast_tree, hf_hazelcast_values, tvb, offset, valueLength, ENC_NA);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int dissect_hazelcast(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data) {\r\ntcp_dissect_pdus(tvb, pinfo, tree, hazelcast_desegment, 13, get_hazelcast_message_len, dissect_hazelcast_message, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_hazelcast(void) {\r\nstatic hf_register_info hf[] = {\r\n{ &hf_hazelcast_headerLength,\r\n{ "Hazelcast hdr length", "hazelcast.hdr.length", FT_UINT32, BASE_DEC, NULL, 0x0, "header length", HFILL }\r\n},\r\n{ &hf_hazelcast_headerKeyLength,\r\n{ "Hazelcast hdr key length", "hazelcast.hdr.keylength", FT_UINT32, BASE_DEC, NULL, 0x0, "header key length", HFILL }\r\n},\r\n{ &hf_hazelcast_headerValueLength,\r\n{ "Hazelcast hdr value length", "hazelcast.hdr.valuelength", FT_UINT32, BASE_DEC, NULL, 0x0, "header value length", HFILL }\r\n},\r\n{ &hf_hazelcast_headerVersion,\r\n{ "Hazelcast hdr version", "hazelcast.hdr.version", FT_UINT8, BASE_DEC, NULL, 0x0, "header version", HFILL }\r\n},\r\n{ &hf_hazelcast_operation,\r\n{ "Hazelcast operation", "hazelcast.operation", FT_UINT8, BASE_DEC|BASE_EXT_STRING, &operationTypes_ext, 0x0, "operation", HFILL }\r\n},\r\n{ &hf_hazelcast_blockID,\r\n{ "Hazelcast blockID", "hazelcast.blockID", FT_UINT32, BASE_HEX, NULL, 0x0, "blockID", HFILL }\r\n},\r\n{ &hf_hazelcast_threadID,\r\n{ "Hazelcast threadID", "hazelcast.threadID", FT_UINT32, BASE_DEC, NULL, 0x0, "threadID", HFILL }\r\n},\r\n{ &hf_hazelcast_flags,\r\n{ "hazelcast flags", "hazelcast.flags", FT_UINT32, BASE_HEX, NULL, 0x0, "flags", HFILL }\r\n},\r\n{ &hf_hazelcast_flags_lockCount,\r\n{ "hazelcast lockCount flag", "hazelcast.flags.lockCount", FT_BOOLEAN, 8, NULL, HAZELCAST_LOCKCOUNT_FLAG, NULL, HFILL }\r\n},\r\n{ &hf_hazelcast_flags_timeout,\r\n{ "hazelcast timeout flag", "hazelcast.flags.timeout", FT_BOOLEAN, 8, NULL, HAZELCAST_TIMEOUT_FLAG, NULL, HFILL }\r\n},\r\n{ &hf_hazelcast_flags_ttl,\r\n{ "hazelcast ttl flag", "hazelcast.flags.ttl", FT_BOOLEAN, 8, NULL, HAZELCAST_TTL_FLAG, NULL, HFILL }\r\n},\r\n{ &hf_hazelcast_flags_txn,\r\n{ "hazelcast txn flag", "hazelcast.flags.txn", FT_BOOLEAN, 8, NULL, HAZELCAST_TXN_FLAG, NULL, HFILL }\r\n},\r\n{ &hf_hazelcast_flags_longValue,\r\n{ "hazelcast longValue flag", "hazelcast.flags.longValue", FT_BOOLEAN, 8, NULL, HAZELCAST_LONGVALUE_FLAG, NULL, HFILL }\r\n},\r\n{ &hf_hazelcast_flags_version,\r\n{ "hazelcast version flag", "hazelcast.flags.version", FT_BOOLEAN, 8, NULL, HAZELCAST_VERSION_FLAG, NULL, HFILL }\r\n},\r\n{ &hf_hazelcast_flags_client,\r\n{ "hazelcast client flag", "hazelcast.flags.client", FT_BOOLEAN, 8, NULL, HAZELCAST_CLIENT_FLAG, NULL, HFILL }\r\n},\r\n{ &hf_hazelcast_flags_lockAddrNull,\r\n{ "hazelcast lockAddrNull flag", "hazelcast.flags.lockAddrNull", FT_BOOLEAN, 8, NULL, HAZELCAST_LOCKADDRNULL_FLAG, NULL, HFILL }\r\n},\r\n{ &hf_hazelcast_timeout,\r\n{ "hazelcast timeout", "hazelcast.timeout", FT_UINT64, BASE_DEC, NULL, 0x0, "timeout", HFILL }\r\n},\r\n{ &hf_hazelcast_ttl,\r\n{ "hazelcast ttl", "hazelcast.ttl", FT_UINT64, BASE_DEC, NULL, 0x0, "ttl", HFILL }\r\n},\r\n{ &hf_hazelcast_longValue,\r\n{ "hazelcast longValue", "hazelcast.longValue", FT_UINT64, BASE_DEC, NULL, 0x0, "longValue", HFILL }\r\n},\r\n{ &hf_hazelcast_txnID,\r\n{ "hazelcast txnID", "hazelcast.txnID", FT_UINT64, BASE_DEC, NULL, 0x0, "txnID", HFILL }\r\n},\r\n{ &hf_hazelcast_version,\r\n{ "hazelcast version", "hazelcast.version", FT_UINT64, BASE_DEC, NULL, 0x0, "version", HFILL }\r\n},\r\n{ &hf_hazelcast_lockCount,\r\n{ "hazelcast lockCount", "hazelcast.lockCount", FT_UINT32, BASE_DEC, NULL, 0x0, "lockCount", HFILL }\r\n},\r\n{ &hf_hazelcast_lockAddrIP,\r\n{ "hazelcast lock address IP", "hazelcast.lockaddr.ip", FT_IPv4, BASE_NONE, NULL, 0x0, "lockAddrIP", HFILL }\r\n},\r\n{ &hf_hazelcast_lockAddrPort,\r\n{ "hazelcast lock address Port", "hazelcast.lockaddr.port", FT_UINT32, BASE_DEC, NULL, 0x0, "lockAddrPort", HFILL }\r\n},\r\n{ &hf_hazelcast_callID,\r\n{ "hazelcast callID", "hazelcast.callID", FT_INT64, BASE_DEC, NULL, 0x0, "callID", HFILL }\r\n},\r\n{ &hf_hazelcast_responseType,\r\n{ "hazelcast response type", "hazelcast.responseType", FT_UINT8, BASE_DEC|BASE_EXT_STRING, &responseTypes_ext, 0x0, "responseType", HFILL }\r\n},\r\n{ &hf_hazelcast_nameLength,\r\n{ "hazelcast name length", "hazelcast.nameLength", FT_UINT32, BASE_DEC, NULL, 0x0, "nameLength", HFILL }\r\n},\r\n{ &hf_hazelcast_name,\r\n{ "hazelcast name", "hazelcast.name", FT_STRING, BASE_NONE, NULL, 0x0, "name", HFILL }\r\n},\r\n{ &hf_hazelcast_indexCount,\r\n{ "hazelcast indexCount", "hazelcast.indexCount", FT_UINT8, BASE_DEC, NULL, 0x0, "indexCount", HFILL }\r\n},\r\n{ &hf_hazelcast_keyPartitionHash,\r\n{ "hazelcast keyPartitionHash", "hazelcast.keyPartitionHash", FT_UINT32, BASE_HEX, NULL, 0x0, "keyPartitionHash", HFILL }\r\n},\r\n{ &hf_hazelcast_valuePartitionHash,\r\n{ "hazelcast valuePartitionHash", "hazelcast.valuePartitionHash", FT_UINT32, BASE_HEX, NULL, 0x0, "valuePartitionHash", HFILL }\r\n},\r\n{ &hf_hazelcast_keys,\r\n{ "hazelcast keys", "hazelcast.keys", FT_BYTES, BASE_NONE, NULL, 0x0, "keys", HFILL }\r\n},\r\n{ &hf_hazelcast_values,\r\n{ "hazelcast values", "hazelcast.values", FT_BYTES, BASE_NONE, NULL, 0x0, "values", HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_hazelcast,\r\n&ett_hazelcast_flags\r\n};\r\nmodule_t *hazelcast_module;\r\nproto_hazelcast = proto_register_protocol (\r\n"Hazelcast Wire Protocol",\r\n"HAZELCAST",\r\n"hzlcst"\r\n);\r\nproto_register_field_array(proto_hazelcast, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nhazelcast_module = prefs_register_protocol(proto_hazelcast, NULL);\r\nprefs_register_bool_preference(hazelcast_module, "desegment",\r\n"Reassemble hazelcast messages spanning multiple TCP segments",\r\n"Whether the hazel dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&hazelcast_desegment);\r\nprefs_register_uint_preference(hazelcast_module, "tcp.port",\r\n"Hazelcast TCP Port",\r\n" Hazelcast TCP port if other than the default",\r\n10,\r\n&gPORT_PREF);\r\nhazelcast_tap = register_tap("hzlcst");\r\n}\r\nvoid\r\nproto_reg_handoff_hazelcast(void) {\r\nstatic gboolean initialized = FALSE;\r\nstatic dissector_handle_t hazelcast_handle;\r\nstatic int currentPort;\r\nif (!initialized) {\r\nhazelcast_handle = create_dissector_handle(dissect_hazelcast, proto_hazelcast);\r\ninitialized = TRUE;\r\n} else {\r\ndissector_delete_uint("tcp.port", currentPort, hazelcast_handle);\r\n}\r\ncurrentPort = gPORT_PREF;\r\ndissector_add_uint("tcp.port", currentPort, hazelcast_handle);\r\n}
