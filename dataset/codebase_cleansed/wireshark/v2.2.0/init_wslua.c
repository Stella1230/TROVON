static gboolean\r\nlua_pinfo_end(wmem_allocator_t *allocator _U_, wmem_cb_event_t event _U_,\r\nvoid *user_data _U_)\r\n{\r\nclear_outstanding_Tvb();\r\nclear_outstanding_TvbRange();\r\nclear_outstanding_Pinfo();\r\nclear_outstanding_Column();\r\nclear_outstanding_Columns();\r\nclear_outstanding_PrivateTable();\r\nclear_outstanding_TreeItem();\r\nclear_outstanding_FieldInfo();\r\nclear_outstanding_FuncSavers();\r\nreturn FALSE;\r\n}\r\nstatic int wslua_not_register_menu(lua_State* LS) {\r\nluaL_error(LS,"too late to register a menu");\r\nreturn 0;\r\n}\r\nint get_hf_wslua_text(void) {\r\nreturn hf_wslua_text;\r\n}\r\nint dissect_lua(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree, void* data _U_) {\r\nint consumed_bytes = tvb_captured_length(tvb);\r\nlua_pinfo = pinfo;\r\nlua_tvb = tvb;\r\nlua_settop(L,0);\r\nlua_rawgeti(L, LUA_REGISTRYINDEX, lua_dissectors_table_ref);\r\nlua_pushstring(L, pinfo->current_proto);\r\nlua_gettable(L, -2);\r\nlua_remove(L,1);\r\nif (lua_isfunction(L,1)) {\r\npush_Tvb(L,tvb);\r\npush_Pinfo(L,pinfo);\r\nlua_tree = push_TreeItem(L, tree, proto_tree_add_item(tree, hf_wslua_fake, tvb, 0, 0, ENC_NA));\r\nPROTO_ITEM_SET_HIDDEN(lua_tree->item);\r\nif ( lua_pcall(L,3,1,0) ) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_lua_error, tvb, 0, 0, "Lua Error: %s", lua_tostring(L,-1));\r\n} else {\r\nif (lua_isnumber(L, -1)) {\r\nconsumed_bytes = wslua_togint(L, -1);\r\nlua_pop(L, 1);\r\n}\r\n}\r\n} else {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_lua_error, tvb, 0, 0,\r\n"Lua Error: did not find the %s dissector in the dissectors table", pinfo->current_proto);\r\n}\r\nwmem_register_callback(pinfo->pool, lua_pinfo_end, NULL);\r\nlua_pinfo = NULL;\r\nlua_tree = NULL;\r\nlua_tvb = NULL;\r\nreturn consumed_bytes;\r\n}\r\ngboolean heur_dissect_lua(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree, void* data _U_) {\r\ngboolean result = FALSE;\r\nlua_tvb = tvb;\r\nlua_pinfo = pinfo;\r\ng_assert(tvb && pinfo);\r\nif (!pinfo->heur_list_name || !pinfo->current_proto) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_lua_error, tvb, 0, 0,\r\n"internal error in heur_dissect_lua: NULL list name or current proto");\r\nreturn FALSE;\r\n}\r\nlua_settop(L,0);\r\nlua_rawgeti(L, LUA_REGISTRYINDEX, lua_heur_dissectors_table_ref);\r\nif (!wslua_get_table(L, -1, pinfo->heur_list_name)) {\r\nlua_settop(L,0);\r\nproto_tree_add_expert_format(tree, pinfo, &ei_lua_error, tvb, 0, 0,\r\n"internal error in heur_dissect_lua: no %s heur list table", pinfo->heur_list_name);\r\nreturn FALSE;\r\n}\r\nif (!wslua_get_field(L,-1,pinfo->current_proto)) {\r\nlua_settop(L,0);\r\nproto_tree_add_expert_format(tree, pinfo, &ei_lua_error, tvb, 0, 0,\r\n"internal error in heur_dissect_lua: no %s heuristic dissector for list %s",\r\npinfo->current_proto, pinfo->heur_list_name);\r\nreturn FALSE;\r\n}\r\nlua_remove(L,1);\r\nlua_remove(L,1);\r\nif (!lua_isfunction(L,-1)) {\r\nlua_settop(L,0);\r\nproto_tree_add_expert_format(tree, pinfo, &ei_lua_error, tvb, 0, 0,\r\n"internal error in heur_dissect_lua: %s heuristic dissector is not a function", pinfo->current_proto);\r\nreturn FALSE;\r\n}\r\npush_Tvb(L,tvb);\r\npush_Pinfo(L,pinfo);\r\nlua_tree = push_TreeItem(L, tree, proto_tree_add_item(tree, hf_wslua_fake, tvb, 0, 0, ENC_NA));\r\nPROTO_ITEM_SET_HIDDEN(lua_tree->item);\r\nif ( lua_pcall(L,3,1,0) ) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_lua_error, tvb, 0, 0,\r\n"Lua Error: error calling %s heuristic dissector: %s", pinfo->current_proto, lua_tostring(L,-1));\r\nlua_settop(L,0);\r\n} else {\r\nif (lua_isboolean(L, -1) || lua_isnil(L, -1)) {\r\nresult = lua_toboolean(L, -1);\r\n} else if (lua_type(L, -1) == LUA_TNUMBER) {\r\nresult = lua_tointeger(L,-1) != 0 ? TRUE : FALSE;\r\n} else {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_lua_error, tvb, 0, 0,\r\n"Lua Error: invalid return value from Lua %s heuristic dissector", pinfo->current_proto);\r\n}\r\nlua_pop(L, 1);\r\n}\r\nwmem_register_callback(pinfo->pool, lua_pinfo_end, NULL);\r\nlua_pinfo = NULL;\r\nlua_tree = NULL;\r\nlua_tvb = NULL;\r\nreturn result;\r\n}\r\nstatic void iter_table_and_call(lua_State* LS, const gchar* table_name, lua_CFunction error_handler) {\r\nlua_settop(LS,0);\r\nlua_pushcfunction(LS,error_handler);\r\nlua_getglobal(LS, table_name);\r\nif (!lua_istable(LS, 2)) {\r\nreport_failure("Lua: either `%s' does not exist or it is not a table!\n",table_name);\r\nlua_close(LS);\r\nL = NULL;\r\nreturn;\r\n}\r\nlua_pushnil(LS);\r\nwhile (lua_next(LS, 2)) {\r\nconst gchar* name = lua_tostring(L,-2);\r\nif (lua_isfunction(LS,-1)) {\r\nif ( lua_pcall(LS,0,0,1) ) {\r\nlua_pop(LS,1);\r\n}\r\n} else {\r\nreport_failure("Lua: Something not a function got its way into the %s.%s",table_name,name);\r\nlua_close(LS);\r\nL = NULL;\r\nreturn;\r\n}\r\n}\r\nlua_settop(LS,0);\r\n}\r\nstatic int init_error_handler(lua_State* LS) {\r\nconst gchar* error = lua_tostring(LS,1);\r\nreport_failure("Lua: Error During execution of Initialization:\n %s",error);\r\nreturn 0;\r\n}\r\nstatic void wslua_init_routine(void) {\r\nif ( ! init_routine_initialized ) {\r\nlua_prime_all_fields(NULL);\r\ninit_routine_initialized = TRUE;\r\n}\r\nif (L) {\r\niter_table_and_call(L, WSLUA_INIT_ROUTINES,init_error_handler);\r\n}\r\n}\r\nstatic void wslua_cleanup_routine(void) {\r\nif (L) {\r\niter_table_and_call(L, WSLUA_INIT_ROUTINES,init_error_handler);\r\n}\r\n}\r\nstatic int prefs_changed_error_handler(lua_State* LS) {\r\nconst gchar* error = lua_tostring(LS,1);\r\nreport_failure("Lua: Error During execution of prefs apply callback:\n %s",error);\r\nreturn 0;\r\n}\r\nvoid wslua_prefs_changed(void) {\r\nif (L) {\r\niter_table_and_call(L, WSLUA_PREFS_CHANGED,prefs_changed_error_handler);\r\n}\r\n}\r\nstatic const char *getF(lua_State *LS _U_, void *ud, size_t *size)\r\n{\r\nFILE *f=(FILE *)ud;\r\nstatic char buff[512];\r\nif (feof(f)) return NULL;\r\n*size=fread(buff,1,sizeof(buff),f);\r\nreturn (*size>0) ? buff : NULL;\r\n}\r\nstatic int lua_main_error_handler(lua_State* LS) {\r\nconst gchar* error = lua_tostring(LS,1);\r\nreport_failure("Lua: Error during loading:\n %s",error);\r\nreturn 0;\r\n}\r\nstatic void wslua_add_plugin(const gchar *name, const gchar *version, const gchar *filename)\r\n{\r\nwslua_plugin *new_plug, *lua_plug;\r\nlua_plug = wslua_plugin_list;\r\nnew_plug = (wslua_plugin *)g_malloc(sizeof(wslua_plugin));\r\nif (!lua_plug) {\r\nwslua_plugin_list = new_plug;\r\n} else {\r\nwhile (lua_plug->next != NULL) {\r\nlua_plug = lua_plug->next;\r\n}\r\nlua_plug->next = new_plug;\r\n}\r\nnew_plug->name = g_strdup(name);\r\nnew_plug->version = g_strdup(version);\r\nnew_plug->filename = g_strdup(filename);\r\nnew_plug->next = NULL;\r\n}\r\nstatic void wslua_clear_plugin_list(void)\r\n{\r\nwslua_plugin *lua_plug;\r\nwhile (wslua_plugin_list) {\r\nlua_plug = wslua_plugin_list;\r\nwslua_plugin_list = wslua_plugin_list->next;\r\ng_free (lua_plug->name);\r\ng_free (lua_plug->version);\r\ng_free (lua_plug->filename);\r\ng_free (lua_plug);\r\n}\r\n}\r\nstatic int lua_script_push_args(const int script_num) {\r\ngchar* argname = g_strdup_printf("lua_script%d", script_num);\r\nconst gchar* argvalue = NULL;\r\nint i, count = ex_opt_count(argname);\r\nfor (i = 0; i < count; i++) {\r\nargvalue = ex_opt_get_nth(argname, i);\r\nlua_pushstring(L,argvalue);\r\n}\r\ng_free(argname);\r\nreturn count;\r\n}\r\nstatic void set_file_environment(const gchar* filename, const gchar* dirname) {\r\nconst char* path;\r\nchar* personal = get_plugins_pers_dir();\r\nlua_newtable(L);\r\nlua_pushstring(L, filename);\r\nlua_setfield(L, -2, FILE_NAME_KEY);\r\nlua_pushstring(L, dirname);\r\nlua_setfield(L, -2, DIR_NAME_KEY);\r\nlua_pushstring(L, G_DIR_SEPARATOR_S);\r\nlua_setfield(L, -2, DIR_SEP_NAME_KEY);\r\nlua_newtable(L);\r\n#if LUA_VERSION_NUM >= 502\r\nlua_pushglobaltable(L);\r\n#else\r\nlua_pushvalue(L, LUA_GLOBALSINDEX);\r\n#endif\r\nlua_getfield(L, -1, "package");\r\nlua_getfield(L, -1, "path");\r\npath = luaL_checkstring(L, -1);\r\nlua_pop(L, 1);\r\nlua_pushfstring(L, "%s" G_DIR_SEPARATOR_S "?.lua;%s" G_DIR_SEPARATOR_S "?.lua;%s" G_DIR_SEPARATOR_S "?.lua;%s",\r\ndirname, personal, get_plugin_dir(), path);\r\nlua_setfield(L, -2, "path");\r\nlua_setfield(L, -2, "package");\r\nlua_setfield(L, -2, "__index");\r\nlua_setmetatable(L, -2);\r\n#if LUA_VERSION_NUM >= 502\r\nlua_setupvalue(L, -2, 1);\r\n#else\r\nlua_setfenv(L, -2);\r\n#endif\r\ng_free(personal);\r\n}\r\nstatic gboolean lua_load_script(const gchar* filename, const gchar* dirname, const int file_count) {\r\nFILE* file;\r\nint error;\r\nint numargs = 0;\r\nif (! ( file = ws_fopen(filename,"r")) ) {\r\nreport_open_failure(filename,errno,FALSE);\r\nreturn FALSE;\r\n}\r\nlua_settop(L,0);\r\nlua_pushcfunction(L,lua_main_error_handler);\r\n#if LUA_VERSION_NUM >= 502\r\nerror = lua_load(L,getF,file,filename,NULL);\r\n#else\r\nerror = lua_load(L,getF,file,filename);\r\n#endif\r\nswitch (error) {\r\ncase 0:\r\nif (dirname) {\r\nset_file_environment(filename, dirname);\r\n}\r\nif (file_count > 0) {\r\nnumargs = lua_script_push_args(file_count);\r\n}\r\nlua_pcall(L,numargs,0,1);\r\nfclose(file);\r\nlua_pop(L,1);\r\nreturn TRUE;\r\ncase LUA_ERRSYNTAX: {\r\nreport_failure("Lua: syntax error during precompilation of `%s':\n%s",filename,lua_tostring(L,-1));\r\nfclose(file);\r\nreturn FALSE;\r\n}\r\ncase LUA_ERRMEM:\r\nreport_failure("Lua: memory allocation error during execution of %s",filename);\r\nfclose(file);\r\nreturn FALSE;\r\ndefault:\r\nreport_failure("Lua: unknown error during execution of %s: %d",filename,error);\r\nfclose(file);\r\nreturn FALSE;\r\n}\r\n}\r\nstatic gboolean lua_load_internal_script(const gchar* filename) {\r\nreturn lua_load_script(filename, NULL, 0);\r\n}\r\nstatic gboolean lua_load_plugin_script(const gchar* name,\r\nconst gchar* filename,\r\nconst gchar* dirname,\r\nconst int file_count)\r\n{\r\nif (lua_load_script(filename, dirname, file_count)) {\r\nwslua_add_plugin(name, get_current_plugin_version(), filename);\r\nclear_current_plugin_version();\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic void basic_logger(const gchar *log_domain _U_,\r\nGLogLevelFlags log_level _U_,\r\nconst gchar *message,\r\ngpointer user_data _U_) {\r\nfputs(message,stderr);\r\n}\r\nstatic int wslua_panic(lua_State* LS) {\r\ng_error("LUA PANIC: %s",lua_tostring(LS,-1));\r\nreturn 0;\r\n}\r\nstatic int lua_load_plugins(const char *dirname, register_cb cb, gpointer client_data,\r\ngboolean count_only, const gboolean is_user)\r\n{\r\nWS_DIR *dir;\r\nWS_DIRENT *file;\r\ngchar *filename, *dot;\r\nconst gchar *name;\r\nint plugins_counter = 0;\r\nif ((dir = ws_dir_open(dirname, 0, NULL)) != NULL) {\r\nwhile ((file = ws_dir_read_name(dir)) != NULL) {\r\nname = ws_dir_get_name(file);\r\nif (strcmp(name, ".") == 0 || strcmp(name, "..") == 0)\r\ncontinue;\r\nfilename = g_strdup_printf("%s" G_DIR_SEPARATOR_S "%s", dirname, name);\r\nif (test_for_directory(filename) == EISDIR) {\r\nplugins_counter += lua_load_plugins(filename, cb, client_data, count_only, is_user);\r\ng_free(filename);\r\ncontinue;\r\n}\r\nif (name[0] == '.') {\r\ng_free(filename);\r\ncontinue;\r\n}\r\ndot = strrchr(name, '.');\r\nif (dot == NULL || g_ascii_strcasecmp(dot+1, "lua") != 0) {\r\ng_free(filename);\r\ncontinue;\r\n}\r\nif (file_exists(filename)) {\r\nif (!count_only) {\r\nif (cb)\r\n(*cb)(RA_LUA_PLUGINS, name, client_data);\r\nlua_load_plugin_script(name, filename, is_user ? dirname : NULL, 0);\r\n}\r\nplugins_counter++;\r\n}\r\ng_free(filename);\r\n}\r\nws_dir_close(dir);\r\n}\r\nreturn plugins_counter;\r\n}\r\nint wslua_count_plugins(void) {\r\ngchar* filename;\r\nint plugins_counter;\r\nplugins_counter = lua_load_plugins(get_plugin_dir(), NULL, NULL, TRUE, FALSE);\r\nfilename = get_persconffile_path("init.lua", FALSE);\r\nif ((file_exists(filename))) {\r\nplugins_counter++;\r\n}\r\ng_free(filename);\r\nfilename = get_plugins_pers_dir();\r\nplugins_counter += lua_load_plugins(filename, NULL, NULL, TRUE, TRUE);\r\ng_free(filename);\r\nplugins_counter += ex_opt_count("lua_script");\r\nreturn plugins_counter;\r\n}\r\nvoid wslua_plugins_get_descriptions(wslua_plugin_description_callback callback, void *user_data) {\r\nwslua_plugin *lua_plug;\r\nfor (lua_plug = wslua_plugin_list; lua_plug != NULL; lua_plug = lua_plug->next)\r\n{\r\ncallback(lua_plug->name, lua_plug->version, "lua script",\r\nlua_plug->filename, user_data);\r\n}\r\n}\r\nstatic void\r\nprint_wslua_plugin_description(const char *name, const char *version,\r\nconst char *description, const char *filename,\r\nvoid *user_data _U_)\r\n{\r\nprintf("%s\t%s\t%s\t%s\n", name, version, description, filename);\r\n}\r\nvoid\r\nwslua_plugins_dump_all(void)\r\n{\r\nwslua_plugins_get_descriptions(print_wslua_plugin_description, NULL);\r\n}\r\nexpert_field*\r\nwslua_get_expert_field(const int group, const int severity)\r\n{\r\nint i;\r\nconst ei_register_info *ei = ws_lua_ei;\r\ng_assert(ei);\r\nfor (i=0; i < ws_lua_ei_len; i++, ei++) {\r\nif (ei->eiinfo.group == group && ei->eiinfo.severity == severity)\r\nreturn ei->ids;\r\n}\r\nreturn &ei_lua_error;\r\n}\r\nstatic void *\r\nwslua_allocf(void *ud _U_, void *ptr, size_t osize _U_, size_t nsize)\r\n{\r\nreturn g_realloc(ptr, nsize);\r\n}\r\nvoid wslua_init(register_cb cb, gpointer client_data) {\r\ngchar* filename;\r\nconst funnel_ops_t* ops = funnel_get_funnel_ops();\r\ngboolean run_anyway = FALSE;\r\nexpert_module_t* expert_lua;\r\nint file_count = 1;\r\nstatic gboolean first_time = TRUE;\r\nint i;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_wslua_fake,\r\n{ "Wireshark Lua fake item", "_ws.lua.fake",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\n"Fake internal item for Wireshark Lua", HFILL }},\r\n{ &hf_wslua_text,\r\n{ "Wireshark Lua text", "_ws.lua.text",\r\nFT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_lua_proto_checksum_comment, { "_ws.lua.proto.comment", PI_CHECKSUM, PI_COMMENT ,"Protocol Comment", EXPFILL }},\r\n{ &ei_lua_proto_checksum_chat, { "_ws.lua.proto.chat", PI_CHECKSUM, PI_CHAT ,"Protocol Chat", EXPFILL }},\r\n{ &ei_lua_proto_checksum_note, { "_ws.lua.proto.note", PI_CHECKSUM, PI_NOTE ,"Protocol Note", EXPFILL }},\r\n{ &ei_lua_proto_checksum_warn, { "_ws.lua.proto.warning", PI_CHECKSUM, PI_WARN ,"Protocol Warning", EXPFILL }},\r\n{ &ei_lua_proto_checksum_error, { "_ws.lua.proto.error", PI_CHECKSUM, PI_ERROR ,"Protocol Error", EXPFILL }},\r\n{ &ei_lua_proto_sequence_comment, { "_ws.lua.proto.comment", PI_SEQUENCE, PI_COMMENT ,"Protocol Comment", EXPFILL }},\r\n{ &ei_lua_proto_sequence_chat, { "_ws.lua.proto.chat", PI_SEQUENCE, PI_CHAT ,"Protocol Chat", EXPFILL }},\r\n{ &ei_lua_proto_sequence_note, { "_ws.lua.proto.note", PI_SEQUENCE, PI_NOTE ,"Protocol Note", EXPFILL }},\r\n{ &ei_lua_proto_sequence_warn, { "_ws.lua.proto.warning", PI_SEQUENCE, PI_WARN ,"Protocol Warning", EXPFILL }},\r\n{ &ei_lua_proto_sequence_error, { "_ws.lua.proto.error", PI_SEQUENCE, PI_ERROR ,"Protocol Error", EXPFILL }},\r\n{ &ei_lua_proto_response_comment, { "_ws.lua.proto.comment", PI_RESPONSE_CODE, PI_COMMENT ,"Protocol Comment", EXPFILL }},\r\n{ &ei_lua_proto_response_chat, { "_ws.lua.proto.chat", PI_RESPONSE_CODE, PI_CHAT ,"Protocol Chat", EXPFILL }},\r\n{ &ei_lua_proto_response_note, { "_ws.lua.proto.note", PI_RESPONSE_CODE, PI_NOTE ,"Protocol Note", EXPFILL }},\r\n{ &ei_lua_proto_response_warn, { "_ws.lua.proto.warning", PI_RESPONSE_CODE, PI_WARN ,"Protocol Warning", EXPFILL }},\r\n{ &ei_lua_proto_response_error, { "_ws.lua.proto.error", PI_RESPONSE_CODE, PI_ERROR ,"Protocol Error", EXPFILL }},\r\n{ &ei_lua_proto_request_comment, { "_ws.lua.proto.comment", PI_REQUEST_CODE, PI_COMMENT ,"Protocol Comment", EXPFILL }},\r\n{ &ei_lua_proto_request_chat, { "_ws.lua.proto.chat", PI_REQUEST_CODE, PI_CHAT ,"Protocol Chat", EXPFILL }},\r\n{ &ei_lua_proto_request_note, { "_ws.lua.proto.note", PI_REQUEST_CODE, PI_NOTE ,"Protocol Note", EXPFILL }},\r\n{ &ei_lua_proto_request_warn, { "_ws.lua.proto.warning", PI_REQUEST_CODE, PI_WARN ,"Protocol Warning", EXPFILL }},\r\n{ &ei_lua_proto_request_error, { "_ws.lua.proto.error", PI_REQUEST_CODE, PI_ERROR ,"Protocol Error", EXPFILL }},\r\n{ &ei_lua_proto_undecoded_comment, { "_ws.lua.proto.comment", PI_UNDECODED, PI_COMMENT ,"Protocol Comment", EXPFILL }},\r\n{ &ei_lua_proto_undecoded_chat, { "_ws.lua.proto.chat", PI_UNDECODED, PI_CHAT ,"Protocol Chat", EXPFILL }},\r\n{ &ei_lua_proto_undecoded_note, { "_ws.lua.proto.note", PI_UNDECODED, PI_NOTE ,"Protocol Note", EXPFILL }},\r\n{ &ei_lua_proto_undecoded_warn, { "_ws.lua.proto.warning", PI_UNDECODED, PI_WARN ,"Protocol Warning", EXPFILL }},\r\n{ &ei_lua_proto_undecoded_error, { "_ws.lua.proto.error", PI_UNDECODED, PI_ERROR ,"Protocol Error", EXPFILL }},\r\n{ &ei_lua_proto_reassemble_comment, { "_ws.lua.proto.comment", PI_REASSEMBLE, PI_COMMENT ,"Protocol Comment", EXPFILL }},\r\n{ &ei_lua_proto_reassemble_chat, { "_ws.lua.proto.chat", PI_REASSEMBLE, PI_CHAT ,"Protocol Chat", EXPFILL }},\r\n{ &ei_lua_proto_reassemble_note, { "_ws.lua.proto.note", PI_REASSEMBLE, PI_NOTE ,"Protocol Note", EXPFILL }},\r\n{ &ei_lua_proto_reassemble_warn, { "_ws.lua.proto.warning", PI_REASSEMBLE, PI_WARN ,"Protocol Warning", EXPFILL }},\r\n{ &ei_lua_proto_reassemble_error, { "_ws.lua.proto.error", PI_REASSEMBLE, PI_ERROR ,"Protocol Error", EXPFILL }},\r\n{ &ei_lua_proto_malformed_comment, { "_ws.lua.proto.comment", PI_MALFORMED, PI_COMMENT ,"Protocol Comment", EXPFILL }},\r\n{ &ei_lua_proto_malformed_chat, { "_ws.lua.proto.chat", PI_MALFORMED, PI_CHAT ,"Protocol Chat", EXPFILL }},\r\n{ &ei_lua_proto_malformed_note, { "_ws.lua.proto.note", PI_MALFORMED, PI_NOTE ,"Protocol Note", EXPFILL }},\r\n{ &ei_lua_proto_malformed_warn, { "_ws.lua.proto.warning", PI_MALFORMED, PI_WARN ,"Protocol Warning", EXPFILL }},\r\n{ &ei_lua_proto_malformed_error, { "_ws.lua.proto.error", PI_MALFORMED, PI_ERROR ,"Protocol Error", EXPFILL }},\r\n{ &ei_lua_proto_debug_comment, { "_ws.lua.proto.comment", PI_DEBUG, PI_COMMENT ,"Protocol Comment", EXPFILL }},\r\n{ &ei_lua_proto_debug_chat, { "_ws.lua.proto.chat", PI_DEBUG, PI_CHAT ,"Protocol Chat", EXPFILL }},\r\n{ &ei_lua_proto_debug_note, { "_ws.lua.proto.note", PI_DEBUG, PI_NOTE ,"Protocol Note", EXPFILL }},\r\n{ &ei_lua_proto_debug_warn, { "_ws.lua.proto.warning", PI_DEBUG, PI_WARN ,"Protocol Warning", EXPFILL }},\r\n{ &ei_lua_proto_debug_error, { "_ws.lua.proto.error", PI_DEBUG, PI_ERROR ,"Protocol Error", EXPFILL }},\r\n{ &ei_lua_proto_protocol_comment, { "_ws.lua.proto.comment", PI_PROTOCOL, PI_COMMENT ,"Protocol Comment", EXPFILL }},\r\n{ &ei_lua_proto_protocol_chat, { "_ws.lua.proto.chat", PI_PROTOCOL, PI_CHAT ,"Protocol Chat", EXPFILL }},\r\n{ &ei_lua_proto_protocol_note, { "_ws.lua.proto.note", PI_PROTOCOL, PI_NOTE ,"Protocol Note", EXPFILL }},\r\n{ &ei_lua_proto_protocol_warn, { "_ws.lua.proto.warning", PI_PROTOCOL, PI_WARN ,"Protocol Warning", EXPFILL }},\r\n{ &ei_lua_proto_protocol_error, { "_ws.lua.proto.error", PI_PROTOCOL, PI_ERROR ,"Protocol Error", EXPFILL }},\r\n{ &ei_lua_proto_security_comment, { "_ws.lua.proto.comment", PI_SECURITY, PI_COMMENT ,"Protocol Comment", EXPFILL }},\r\n{ &ei_lua_proto_security_chat, { "_ws.lua.proto.chat", PI_SECURITY, PI_CHAT ,"Protocol Chat", EXPFILL }},\r\n{ &ei_lua_proto_security_note, { "_ws.lua.proto.note", PI_SECURITY, PI_NOTE ,"Protocol Note", EXPFILL }},\r\n{ &ei_lua_proto_security_warn, { "_ws.lua.proto.warning", PI_SECURITY, PI_WARN ,"Protocol Warning", EXPFILL }},\r\n{ &ei_lua_proto_security_error, { "_ws.lua.proto.error", PI_SECURITY, PI_ERROR ,"Protocol Error", EXPFILL }},\r\n{ &ei_lua_proto_comments_comment, { "_ws.lua.proto.comment", PI_COMMENTS_GROUP, PI_COMMENT ,"Protocol Comment", EXPFILL }},\r\n{ &ei_lua_proto_comments_chat, { "_ws.lua.proto.chat", PI_COMMENTS_GROUP, PI_CHAT ,"Protocol Chat", EXPFILL }},\r\n{ &ei_lua_proto_comments_note, { "_ws.lua.proto.note", PI_COMMENTS_GROUP, PI_NOTE ,"Protocol Note", EXPFILL }},\r\n{ &ei_lua_proto_comments_warn, { "_ws.lua.proto.warning", PI_COMMENTS_GROUP, PI_WARN ,"Protocol Warning", EXPFILL }},\r\n{ &ei_lua_proto_comments_error, { "_ws.lua.proto.error", PI_COMMENTS_GROUP, PI_ERROR ,"Protocol Error", EXPFILL }},\r\n{ &ei_lua_error, { "_ws.lua.error", PI_UNDECODED, PI_ERROR ,"Lua Error", EXPFILL }},\r\n};\r\nif (first_time) {\r\nws_lua_ei = ei;\r\nws_lua_ei_len = array_length(ei);\r\ng_log_set_handler(LOG_DOMAIN_LUA, (GLogLevelFlags)(G_LOG_LEVEL_CRITICAL|\r\nG_LOG_LEVEL_WARNING|\r\nG_LOG_LEVEL_MESSAGE|\r\nG_LOG_LEVEL_INFO|\r\nG_LOG_LEVEL_DEBUG),\r\nops ? ops->logger : basic_logger,\r\nNULL);\r\n}\r\nif (!L) {\r\nL = lua_newstate(wslua_allocf, NULL);\r\n}\r\nWSLUA_INIT(L);\r\nif (first_time) {\r\nproto_lua = proto_register_protocol("Lua Dissection", "Lua Dissection", "_ws.lua");\r\nproto_register_field_array(proto_lua, hf, array_length(hf));\r\nexpert_lua = expert_register_protocol(proto_lua);\r\nexpert_register_field_array(expert_lua, ei, array_length(ei));\r\n}\r\nlua_atpanic(L,wslua_panic);\r\nlua_newtable (L);\r\nlua_setglobal(L, WSLUA_INIT_ROUTINES);\r\nlua_newtable (L);\r\nlua_dissectors_table_ref = luaL_ref(L, LUA_REGISTRYINDEX);\r\nlua_newtable (L);\r\nlua_heur_dissectors_table_ref = luaL_ref(L, LUA_REGISTRYINDEX);\r\nlua_newtable (L);\r\nlua_setglobal(L, WSLUA_PREFS_CHANGED);\r\nWSLUA_REG_GLOBAL_BOOL(L,"running_superuser",started_with_special_privs());\r\nWSLUA_REG_GLOBAL_NUMBER(L,"DESEGMENT_ONE_MORE_SEGMENT",DESEGMENT_ONE_MORE_SEGMENT);\r\nif (running_in_build_directory()) {\r\nfilename = g_strdup_printf("%s" G_DIR_SEPARATOR_S "epan" G_DIR_SEPARATOR_S "wslua"\r\nG_DIR_SEPARATOR_S "init.lua", get_progfile_dir());\r\nif (( ! file_exists(filename))) {\r\ng_free(filename);\r\nfilename = g_strdup_printf("%s" G_DIR_SEPARATOR_S "init.lua",\r\nget_progfile_dir());\r\n}\r\n} else {\r\nfilename = get_datafile_path("init.lua");\r\n}\r\nif (( file_exists(filename))) {\r\nlua_load_internal_script(filename);\r\n}\r\ng_free(filename);\r\nfilename = NULL;\r\nlua_getglobal(L,"disable_lua");\r\nif (lua_isboolean(L,-1) && lua_toboolean(L,-1)) {\r\nlua_close(L);\r\nL = NULL;\r\nfirst_time = FALSE;\r\nreturn;\r\n}\r\nlua_pop(L,1);\r\nlua_load_plugins(get_plugin_dir(), cb, client_data, FALSE, FALSE);\r\nlua_getglobal(L,"run_user_scripts_when_superuser");\r\nif (lua_isboolean(L,-1) && lua_toboolean(L,-1)) {\r\nrun_anyway = TRUE;\r\n}\r\nlua_pop(L,1);\r\nif ( (!started_with_special_privs()) || run_anyway ) {\r\nfilename = get_persconffile_path("init.lua", FALSE);\r\nif ((file_exists(filename))) {\r\nif (cb)\r\n(*cb)(RA_LUA_PLUGINS, get_basename(filename), client_data);\r\nlua_load_internal_script(filename);\r\n}\r\ng_free(filename);\r\nfilename = get_plugins_pers_dir();\r\nlua_load_plugins(filename, cb, client_data, FALSE, TRUE);\r\ng_free(filename);\r\nfor (i = 0; i < ex_opt_count("lua_script"); i++) {\r\nconst gchar *script_filename = ex_opt_get_nth("lua_script", i);\r\nchar* dirname = g_strdup(script_filename);\r\nchar* dname = get_dirname(dirname);\r\nif (cb)\r\n(*cb)(RA_LUA_PLUGINS, get_basename(script_filename), client_data);\r\nlua_load_plugin_script(ws_dir_get_name(script_filename),\r\nscript_filename,\r\ndname ? dname : "",\r\nfile_count);\r\nfile_count++;\r\ng_free(dirname);\r\n}\r\n}\r\nif (first_time) {\r\nregister_init_routine(wslua_init_routine);\r\nregister_cleanup_routine(wslua_cleanup_routine);\r\n}\r\nlua_pushcfunction(L, wslua_not_register_menu);\r\nlua_setglobal(L, "register_menu");\r\nlua_pinfo = NULL;\r\nlua_tree = NULL;\r\nlua_tvb = NULL;\r\nlua_data_handle = find_dissector("data");\r\nProto_commit(L);\r\nfirst_time = FALSE;\r\n}\r\nvoid wslua_reload_plugins (register_cb cb, gpointer client_data) {\r\nconst funnel_ops_t* ops = funnel_get_funnel_ops();\r\nif (cb)\r\n(*cb)(RA_LUA_DEREGISTER, NULL, client_data);\r\nif (ops->close_dialogs)\r\nops->close_dialogs();\r\nwslua_deregister_heur_dissectors(L);\r\nwslua_deregister_protocols(L);\r\nwslua_deregister_dissector_tables(L);\r\nwslua_deregister_listeners(L);\r\nwslua_deregister_fields(L);\r\nwslua_deregister_filehandlers(L);\r\nwslua_deregister_menus();\r\nwslua_clear_plugin_list();\r\nwslua_cleanup();\r\nwslua_init(cb, client_data);\r\n}\r\nvoid wslua_cleanup(void) {\r\nif (L) {\r\nlua_close(L);\r\nL = NULL;\r\n}\r\ninit_routine_initialized = FALSE;\r\n}\r\nlua_State* wslua_state(void) { return L; }
