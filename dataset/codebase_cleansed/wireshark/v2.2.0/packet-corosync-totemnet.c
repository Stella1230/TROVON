static int\r\ndissect_corosync_totemnet_security_header(tvbuff_t *tvb,\r\npacket_info *pinfo, proto_tree *parent_tree,\r\ngboolean check_crypt_type,\r\nconst gchar* key)\r\n{\r\nproto_item *item;\r\nproto_tree *tree;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "COROSYNC/TOTEMNET");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (parent_tree)\r\n{\r\nitem = proto_tree_add_item(parent_tree, proto_corosync_totemnet, tvb, 0,\r\n-1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_corosync_totemnet_security_header);\r\nproto_tree_add_item(tree,\r\nhf_corosync_totemnet_security_header_hash_digest,\r\ntvb, 0, SHA1_DIGEST_LEN, ENC_NA);\r\nproto_tree_add_item(tree,\r\nhf_corosync_totemnet_security_header_salt,\r\ntvb, SHA1_DIGEST_LEN, SALT_SIZE, ENC_NA);\r\nif (check_crypt_type)\r\n{\r\nint io_len = tvb_reported_length(tvb);\r\nproto_item * key_item;\r\nproto_tree_add_item(tree,\r\nhf_corosync_totemnet_security_crypto_type,\r\ntvb, io_len - 1, 1, ENC_BIG_ENDIAN);\r\nkey_item = proto_tree_add_string(tree,\r\nhf_corosync_totemnet_security_crypto_key,\r\ntvb, 0, 0, key);\r\nPROTO_ITEM_SET_GENERATED(key_item);\r\n}\r\n}\r\nreturn SHA1_DIGEST_LEN + SALT_SIZE;\r\n}\r\nstatic int\r\ndissect_corosynec_totemnet_with_decryption(tvbuff_t *tvb,\r\npacket_info *pinfo, proto_tree *parent_tree,\r\ngboolean check_crypt_type,\r\nconst gchar* key_for_trial)\r\n{\r\nunsigned char keys[48];\r\nsober128_prng keygen_prng_state;\r\nsober128_prng stream_prng_state;\r\nunsigned char *hmac_key = &keys[32];\r\nunsigned char *cipher_key = &keys[16];\r\nunsigned char *initial_vector = &keys[0];\r\nunsigned char digest_comparison[SHA1_DIGEST_LEN];\r\nint io_len;\r\nguint8 *io_base;\r\n#define PRIVATE_KEY_LEN_MAX 256\r\ngchar private_key[PRIVATE_KEY_LEN_MAX];\r\ngsize private_key_len;\r\nunsigned char* hash_digest;\r\nunsigned char* salt;\r\nio_len = tvb_reported_length(tvb) - (check_crypt_type? 1: 0);\r\nif (io_len < SHA1_DIGEST_LEN + SALT_SIZE) {\r\nreturn 0;\r\n}\r\nio_base = (guint8 *)tvb_memdup(pinfo->pool, tvb, 0, io_len + (check_crypt_type? 1: 0));\r\nif (check_crypt_type &&\r\n( io_base[io_len] != TOTEM_CRYPTO_SOBER )) {\r\nreturn 0;\r\n}\r\nhash_digest = io_base;\r\nsalt = io_base + SHA1_DIGEST_LEN;\r\nmemset(private_key, 0, sizeof(private_key));\r\nprivate_key_len = (strlen(key_for_trial)+4) & 0xFC;\r\nif (private_key_len > PRIVATE_KEY_LEN_MAX)\r\nprivate_key_len = PRIVATE_KEY_LEN_MAX;\r\ng_strlcpy(private_key, key_for_trial, private_key_len);\r\nmemset (keys, 0, sizeof(keys));\r\nsober128_start (&keygen_prng_state);\r\nsober128_add_entropy(private_key,\r\n(unsigned long)private_key_len, &keygen_prng_state);\r\nsober128_add_entropy (salt, SALT_SIZE, &keygen_prng_state);\r\nsober128_read (keys, sizeof (keys), &keygen_prng_state);\r\nsober128_start (&stream_prng_state);\r\nsober128_add_entropy (cipher_key, 16, &stream_prng_state);\r\nsober128_add_entropy (initial_vector, 16, &stream_prng_state);\r\nsha1_hmac(hmac_key, 16,\r\nio_base + SHA1_DIGEST_LEN, io_len - SHA1_DIGEST_LEN,\r\ndigest_comparison);\r\nif (memcmp (digest_comparison, hash_digest, SHA1_DIGEST_LEN) != 0)\r\nreturn 0;\r\nsober128_read (io_base + SHA1_DIGEST_LEN + SALT_SIZE,\r\nio_len - (SHA1_DIGEST_LEN + SALT_SIZE),\r\n&stream_prng_state);\r\n{\r\ntvbuff_t *decrypted_tvb;\r\ntvbuff_t *next_tvb;\r\ndecrypted_tvb = tvb_new_real_data(io_base, io_len, io_len);\r\ntvb_set_child_real_data_tvbuff(tvb, decrypted_tvb);\r\nadd_new_data_source(pinfo, decrypted_tvb, "Decrypted Data");\r\ndissect_corosync_totemnet_security_header(decrypted_tvb, pinfo, parent_tree,\r\ncheck_crypt_type, key_for_trial);\r\nnext_tvb = tvb_new_subset(decrypted_tvb,\r\nSHA1_DIGEST_LEN + SALT_SIZE,\r\nio_len - (SHA1_DIGEST_LEN + SALT_SIZE),\r\nio_len - (SHA1_DIGEST_LEN + SALT_SIZE));\r\nreturn call_dissector(corosync_totemsrp_handle, next_tvb, pinfo, parent_tree) + SHA1_DIGEST_LEN + SALT_SIZE;\r\n}\r\n}\r\nstatic int\r\ndissect_corosynec_totemnet(tvbuff_t *tvb,\r\npacket_info *pinfo, proto_tree *parent_tree,\r\nvoid *data _U_)\r\n{\r\nif (corosync_totemnet_private_keys_list)\r\n{\r\nstatic int last_key_index = -1;\r\nint key_index;\r\nstatic int last_check_crypt_type_index;\r\nint check_crypt_type_index = -1;\r\ngboolean check_crypt_type_list[] = {FALSE, TRUE};\r\nif (last_key_index != -1)\r\n{\r\nint r;\r\nr = dissect_corosynec_totemnet_with_decryption(tvb,\r\npinfo,\r\nparent_tree,\r\ncheck_crypt_type_list[last_check_crypt_type_index],\r\ncorosync_totemnet_private_keys_list[last_key_index]);\r\nif (r > 0)\r\nreturn r;\r\nelse\r\nlast_key_index = -1;\r\n}\r\nfor (key_index = 0;\r\ncorosync_totemnet_private_keys_list[key_index];\r\nkey_index++)\r\n{\r\nfor (check_crypt_type_index = 0;\r\ncheck_crypt_type_index < 2;\r\ncheck_crypt_type_index++)\r\n{\r\nint r;\r\nr = dissect_corosynec_totemnet_with_decryption(tvb,\r\npinfo,\r\nparent_tree,\r\ncheck_crypt_type_list[check_crypt_type_index],\r\ncorosync_totemnet_private_keys_list[key_index]);\r\nif (r > 0)\r\n{\r\nlast_key_index = key_index;\r\nlast_check_crypt_type_index = check_crypt_type_index;\r\nreturn r;\r\n}\r\nelse if (r < 0)\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn call_dissector(corosync_totemsrp_handle, tvb, pinfo, parent_tree);\r\n}\r\nvoid\r\nproto_register_corosync_totemnet(void)\r\n{\r\nmodule_t *corosync_totemnet_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_corosync_totemnet_security_header_hash_digest,\r\n{ "Hash digest", "corosync_totemnet.security_header_hash_digest",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_corosync_totemnet_security_header_salt,\r\n{ "Salt", "corosync_totemnet.security_header_salt",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_corosync_totemnet_security_crypto_type,\r\n{ "Cryptographic Type", "corosync_totemnet.security_crypto_type",\r\nFT_UINT8, BASE_DEC, VALS(corosync_totemnet_crypto_type), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_corosync_totemnet_security_crypto_key,\r\n{ "Private Key for decryption", "corosync_totemnet.security_crypto_key",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett_corosync_totemnet[] = {\r\n&ett_corosync_totemnet_security_header,\r\n};\r\nproto_corosync_totemnet = proto_register_protocol("Totemnet Layer of Corosync Cluster Engine",\r\n"COROSYNC/TOTEMNET", "corosync_totemnet");\r\nproto_register_field_array(proto_corosync_totemnet, hf, array_length(hf));\r\nproto_register_subtree_array(ett_corosync_totemnet, array_length(ett_corosync_totemnet));\r\ncorosync_totemnet_module = prefs_register_protocol(proto_corosync_totemnet,\r\nproto_reg_handoff_corosync_totemnet);\r\nprefs_register_uint_preference(corosync_totemnet_module, "udp.port",\r\n"UDP Port",\r\n"Set the UDP port for totem ring protocol implemented in corosync cluster engine",\r\n10,\r\n&corosync_totemnet_port);\r\nprefs_register_string_preference(corosync_totemnet_module, "private_keys", "Private keys",\r\n"Semicolon-separated list of keys for decryption(e.g. key1;key2;..." ,\r\n(const gchar **)&corosync_totemnet_private_keys);\r\n}\r\nvoid\r\nproto_reg_handoff_corosync_totemnet(void)\r\n{\r\nstatic gboolean initialized = FALSE;\r\nstatic dissector_handle_t corosync_totemnet_handle;\r\nstatic int port = 0;\r\nif (initialized)\r\n{\r\ndissector_delete_uint("udp.port", port, corosync_totemnet_handle);\r\ndissector_delete_uint("udp.port", port - 1, corosync_totemnet_handle);\r\n}\r\nelse\r\n{\r\ncorosync_totemnet_handle = create_dissector_handle(dissect_corosynec_totemnet,\r\nproto_corosync_totemnet);\r\ncorosync_totemsrp_handle = find_dissector_add_dependency("corosync_totemsrp", proto_corosync_totemnet);\r\ninitialized = TRUE;\r\n}\r\nif (corosync_totemnet_private_keys_list) {\r\ng_strfreev(corosync_totemnet_private_keys_list);\r\ncorosync_totemnet_private_keys_list = NULL;\r\n}\r\ncorosync_totemnet_private_keys_list = g_strsplit(corosync_totemnet_private_keys,\r\n";",\r\n0);\r\nport = corosync_totemnet_port;\r\ndissector_add_uint("udp.port", port, corosync_totemnet_handle);\r\ndissector_add_uint("udp.port", port - 1, corosync_totemnet_handle);\r\n}
