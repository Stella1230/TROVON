static void dissect_wlan_if_stats(guint32 starting_offset, proto_item *parent_tree, tvbuff_t *tvb)\r\n{\r\nproto_item *phy_types;\r\nproto_tree *phy_types_tree;\r\nguint32 phy_types_bitfield, noise_floor;\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifwlanbssid, tvb, starting_offset, 6, ENC_NA);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifwlanssid, tvb, starting_offset + 8, 32, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifwlanrssi, tvb, starting_offset + 44, 4, ENC_BIG_ENDIAN);\r\nnoise_floor = tvb_get_ntohl(tvb, starting_offset + 48);\r\nif (noise_floor != 0x7fffffff) {\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifwlannoise, tvb, starting_offset + 48, 4, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_int_format_value(parent_tree,\r\nhf_waveagent_ifwlannoise, tvb, starting_offset + 48, 4, noise_floor,\r\n"Not Reported");\r\n}\r\nphy_types_bitfield = tvb_get_ntohl(tvb, starting_offset + 52);\r\nphy_types = proto_tree_add_uint(parent_tree, hf_waveagent_ifphytypes,\r\ntvb, starting_offset + 52, 4, phy_types_bitfield);\r\nphy_types_tree = proto_item_add_subtree(phy_types, ett_phytypes);\r\nproto_tree_add_item(phy_types_tree,\r\nhf_waveagent_ifphytypebit0, tvb, starting_offset + 55, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(phy_types_tree,\r\nhf_waveagent_ifphytypebit1, tvb, starting_offset + 55, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(phy_types_tree,\r\nhf_waveagent_ifphytypebit2, tvb, starting_offset + 55, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(phy_types_tree,\r\nhf_waveagent_ifphytypebit3, tvb, starting_offset + 55, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifwlanauthentication, tvb, starting_offset + 56, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifwlancipher, tvb, starting_offset + 60, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void dissect_wa_payload(guint32 starting_offset, proto_item *parent_tree, tvbuff_t *tvb, guint32 control_word, guint8 version)\r\n{\r\nswitch (control_word)\r\n{\r\ncase 0x11:\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_payfill, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_paysize, tvb, starting_offset+4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_avgrate, tvb, starting_offset+8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_totalframes, tvb, starting_offset+12, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x23:\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_bssidstartindex, tvb, starting_offset+4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_bssidstopindex, tvb, starting_offset+8, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x24:\r\ncase 0x25:\r\ncase 0x8a:\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x26:\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_oidcode, tvb, starting_offset+4, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x30: {\r\nguint32 if_type;\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\nif_type = tvb_get_ntohl(tvb, starting_offset + 4);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_iftype, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifdhcp, tvb, starting_offset + 8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifmacaddr, tvb, starting_offset + 12, 6, ENC_NA);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_iflinkspeed, tvb, starting_offset + 20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifdescription, tvb, starting_offset + 24, 128, ENC_ASCII|ENC_NA);\r\nif (if_type == WLAN_INTERFACE)\r\ndissect_wlan_if_stats(starting_offset + 156, parent_tree, tvb);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifiptype, tvb, starting_offset + 252, 2, ENC_BIG_ENDIAN);\r\nif (tvb_get_ntohs(tvb, starting_offset + 252) == IPV4_TYPE) {\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifipv4, tvb, starting_offset + 260, 4, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifipv6, tvb, starting_offset + 260, 16, ENC_NA);\r\n}\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifdhcpserver, tvb, starting_offset + 284, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifgateway, tvb, starting_offset + 308, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifdnsserver, tvb, starting_offset + 332, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\ncase 0x31: {\r\nguint32 offset;\r\nguint32 if_type;\r\nguint32 delta;\r\nguint32 iLoop;\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\nif_type = tvb_get_ntohl(tvb, starting_offset + 4);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_iftype, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\r\noffset = starting_offset + 8;\r\ndelta = 156;\r\nfor (iLoop = 0; iLoop < NUM_STATE_CHANGES; iLoop++) {\r\nproto_item *stIndex;\r\nproto_tree *st_change_index_tree;\r\nguint32 if_status;\r\nint current_offset;\r\ncurrent_offset = offset + iLoop * delta;\r\nif_status = tvb_get_ntohl(tvb, current_offset);\r\nif (if_status == 0) continue;\r\nstIndex = proto_tree_add_uint_format_value(parent_tree,\r\nhf_waveagent_ifwlanl2status, tvb, current_offset, 4, if_status, "Interface state change %d", iLoop);\r\nst_change_index_tree = proto_item_add_subtree(stIndex, ett_scindex[iLoop]);\r\nif (if_type == WLAN_INTERFACE) {\r\nproto_tree_add_item(st_change_index_tree,\r\nhf_waveagent_ifwlanl2status, tvb, current_offset, 4, ENC_BIG_ENDIAN);\r\n} else {\r\nproto_tree_add_item(st_change_index_tree,\r\nhf_waveagent_ifethl2status, tvb, current_offset, 4, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(st_change_index_tree,\r\nhf_waveagent_ifl3status, tvb, current_offset + 4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(st_change_index_tree,\r\nhf_waveagent_iflinkspeed, tvb, current_offset + 8, 4, ENC_BIG_ENDIAN);\r\nif (if_type == WLAN_INTERFACE) {\r\ndissect_wlan_if_stats(current_offset + 12, st_change_index_tree, tvb);\r\n}\r\nproto_tree_add_item(st_change_index_tree,\r\nhf_waveagent_snap, tvb, current_offset + 108, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(st_change_index_tree,\r\nhf_waveagent_ifiptype, tvb, current_offset + 116, 2, ENC_BIG_ENDIAN);\r\nif (tvb_get_ntohs(tvb, current_offset + 116) == IPV4_TYPE) {\r\nproto_tree_add_item(st_change_index_tree,\r\nhf_waveagent_ifipv4, tvb, current_offset + 124, 4, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_item(st_change_index_tree,\r\nhf_waveagent_ifipv6, tvb, current_offset + 124, 16, ENC_NA);\r\n}\r\n}\r\nbreak;\r\n}\r\ncase 0x32:\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_oidcode, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_oidvalue, tvb, starting_offset + 12, 1024, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase 0x2e: {\r\nguint32 offset;\r\nproto_item *pi;\r\nguint32 num_bss_entries;\r\nguint32 tag_len;\r\nguint32 delta;\r\nguint32 iLoop;\r\nwmem_strbuf_t *sb;\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_totalbssid, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\r\npi = proto_tree_add_item(parent_tree,\r\nhf_waveagent_returnedbssid, tvb, starting_offset + 8, 4, ENC_BIG_ENDIAN);\r\nnum_bss_entries = tvb_get_ntohl(tvb, starting_offset + 8);\r\nif (num_bss_entries > NUM_BSS) {\r\nproto_item_append_text(pi, " [**Too large: Limiting to " G_STRINGIFY(NUM_BSS) "]");\r\nnum_bss_entries = NUM_BSS;\r\n}\r\noffset = starting_offset + 16;\r\ndelta = 148;\r\nsb = wmem_strbuf_sized_new(wmem_packet_scope(), 8, SHORT_STR);\r\nfor (iLoop = 0; iLoop < num_bss_entries; iLoop++)\r\n{\r\nproto_item *bssIndex;\r\nproto_tree *bss_tree;\r\nint current_offset;\r\nwmem_strbuf_truncate(sb, 0);\r\ncurrent_offset = offset + iLoop * delta;\r\nbssIndex = proto_tree_add_item(parent_tree,\r\nhf_waveagent_scanssid, tvb, current_offset, 32, ENC_ASCII|ENC_NA);\r\nbss_tree = proto_item_add_subtree(bssIndex, ett_bss[iLoop]);\r\ntag_len = tvb_get_ntohl(tvb, current_offset + 52);\r\nif (tag_len != 0) {\r\nguint32 isr;\r\nguint8 isr_value;\r\nfor (isr = 0; isr < tag_len; isr++) {\r\nisr_value = tvb_get_guint8(tvb, offset + 36 + isr);\r\nif (isr_value == 0xFF){\r\nproto_tree_add_string (bss_tree, hf_waveagent_ifwlansupprates, tvb, offset + 36 + isr,\r\n1,\r\n"BSS requires support for mandatory features of HT PHY (IEEE 802.11"\r\n" - Clause 20)");\r\n} else {\r\nwmem_strbuf_append_printf(sb, "%2.1f%s ",\r\n(isr_value & 0x7F) * 0.5,\r\n(isr_value & 0x80) ? "(B)" : "");\r\n}\r\n}\r\nwmem_strbuf_append(sb, " [Mbit/sec]");\r\n}\r\nelse {\r\nwmem_strbuf_append(sb, "Not defined");\r\n}\r\nproto_tree_add_string (bss_tree, hf_waveagent_ifwlansupprates, tvb, offset + 36,\r\ntag_len, wmem_strbuf_get_str(sb));\r\nproto_tree_add_item(bss_tree,\r\nhf_waveagent_scanbssid, tvb, current_offset + 56, 6, ENC_NA);\r\nproto_tree_add_item(bss_tree,\r\nhf_waveagent_ifwlancapabilities, tvb, current_offset + 62, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(bss_tree,\r\nhf_waveagent_ifwlanrssi, tvb, current_offset + 64, 4, ENC_BIG_ENDIAN);\r\n#if 0\r\nproto_tree_add_item(bss_tree,\r\nhf_waveagent_ifwlansigquality, tvb, current_offset + 68, 4, ENC_BIG_ENDIAN);\r\n#endif\r\nproto_tree_add_item(bss_tree,\r\nhf_waveagent_ifwlanchannel, tvb, current_offset + 72, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(bss_tree,\r\nhf_waveagent_ifwlanprivacy, tvb, current_offset + 76, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(bss_tree,\r\nhf_waveagent_ifwlanbssmode, tvb, current_offset + 80, 4, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\n}\r\ncase 0x2f:\r\nif (version < 3) {\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_capstatus, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_protocolversion, tvb, starting_offset, 1, ENC_BIG_ENDIAN);\r\nstarting_offset += 4;\r\n}\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_capimpl, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_state, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_appstate, tvb, starting_offset + 8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_rxdatapckts, tvb, starting_offset + 12, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_rxdatabytes, tvb, starting_offset + 20, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_rxpcktrate, tvb, starting_offset + 28, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_rxbyterate, tvb, starting_offset + 36, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_txdatapckts, tvb, starting_offset + 44, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_txdatabytes, tvb, starting_offset + 52, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_txpcktrate, tvb, starting_offset + 60, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_txbyterate, tvb, starting_offset + 68, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_looppckts, tvb, starting_offset + 76, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_loopbytes, tvb, starting_offset + 84, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_rxctlpckts, tvb, starting_offset + 92, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_rxctlbytes, tvb, starting_offset + 100, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_txctlpckts, tvb, starting_offset + 108, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_txctlbytes, tvb, starting_offset + 116, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_unknowncmds, tvb, starting_offset + 124, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_snap, tvb, starting_offset + 132, 8, ENC_BIG_ENDIAN);\r\n#if 0\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_tstamp1, tvb, 140, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_tstamp2, tvb, 144, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_tstamp3, tvb, 148, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_tstamp4, tvb, 152, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_tstamp5, tvb, 156, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_tstamp6, tvb, 160, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_tstamp7, tvb, 164, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_tstamp8, tvb, 168, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_minlcldelta, tvb, 172, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_maxlcldelta, tvb, 176, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_avglcldelta, tvb, 180, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_minremdelta, tvb, 184, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_maxremdelta, tvb, 188, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_avgremdelta, tvb, 192, 4, ENC_BIG_ENDIAN);\r\n#endif\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_rx1pl, tvb, starting_offset + 284, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_rx2pl, tvb, starting_offset + 292, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_rx3pl, tvb, starting_offset + 300, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_rx4pl, tvb, starting_offset + 308, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_rx5pl, tvb, starting_offset + 316, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_rxoospkts, tvb, starting_offset + 324, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_jitter, tvb, starting_offset + 356, 8, ENC_BIG_ENDIAN);\r\nif (version >= 3) {\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_delayfactor, tvb, starting_offset + 364, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_medialossrate, tvb, starting_offset + 372, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_txstartts, tvb, starting_offset + 380, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_txendts, tvb, starting_offset + 388, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_rxstartts, tvb, starting_offset + 396, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_rxendts, tvb, starting_offset + 404, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_latencysum, tvb, starting_offset + 412, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_latencycount, tvb, starting_offset + 420, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_txflowstop, tvb, starting_offset + 428, 8, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase 0x40: {\r\nguint32 offset;\r\nguint32 delta;\r\nguint32 iLoop;\r\nguint32 num_bss_entries;\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_connectflags, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_connecttype, tvb, starting_offset + 8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_scanssid, tvb, starting_offset + 12, 32, ENC_ASCII|ENC_NA);\r\nnum_bss_entries = tvb_get_ntohl(tvb, starting_offset + 142);\r\noffset = starting_offset + 46;\r\ndelta = 6;\r\nfor (iLoop = 0; iLoop < num_bss_entries; iLoop++)\r\n{\r\nint current_offset;\r\ncurrent_offset = offset + iLoop * delta;\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_scanbssid, tvb, current_offset, 6, ENC_NA);\r\n}\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_minrssi, tvb, starting_offset + 146, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_connecttimeout, tvb, starting_offset + 150, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_connectattempts, tvb, starting_offset + 154, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\ncase 0x41:\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_reason, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x81:\r\nif (version < 3) {\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_capstatus, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_protocolversion, tvb, starting_offset, 1, ENC_BIG_ENDIAN);\r\nstarting_offset += 4;\r\n}\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_capimpl, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_id, tvb, starting_offset + 4, 128, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_bindtag, tvb, starting_offset + 136, 128, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_version, tvb, starting_offset + 268, 128, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_brokerip, tvb, starting_offset + 400, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_brokerport, tvb, starting_offset + 404, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_bindlevel, tvb, starting_offset + 408, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_bindport, tvb, starting_offset + 412, 4, ENC_BIG_ENDIAN);\r\nif (version >= 3) {\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_capabilities2, tvb, starting_offset + 416, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_numinterfaces, tvb, starting_offset + 420, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifmask, tvb, starting_offset + 424, 4, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase 0x82:\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_bindtag, tvb, starting_offset, 128, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_brokerip, tvb, starting_offset + 132, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_brokerport, tvb, starting_offset + 136, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x85: {\r\nproto_tree *fs_flags;\r\nproto_tree *fs_flags_tree;\r\nguint32 flags_bitfield;\r\nif (version < 3) {\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_rxflownum, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_mode, tvb, starting_offset + 7, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_endpointtype, tvb, starting_offset + 7, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_bindport, tvb, starting_offset + 8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_bindlevel, tvb, starting_offset + 12, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_remoteport, tvb, starting_offset + 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_remoteaddr, tvb, starting_offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_dscp, tvb, starting_offset + 40, 4, ENC_BIG_ENDIAN);\r\nflags_bitfield = tvb_get_ntohl(tvb, starting_offset + 44);\r\nfs_flags = proto_tree_add_uint(parent_tree, hf_waveagent_fsflags,\r\ntvb, starting_offset + 44, 4, flags_bitfield);\r\nfs_flags_tree = proto_item_add_subtree(fs_flags, ett_fsflags);\r\nproto_tree_add_item(fs_flags_tree,\r\nhf_waveagent_fscbrflag, tvb, starting_offset + 47, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(fs_flags_tree,\r\nhf_waveagent_fscombinedsetupflag, tvb, starting_offset + 47, 1, ENC_LITTLE_ENDIAN);\r\nif (version >= 3) {\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_ifindex, tvb, starting_offset + 48, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_payfill, tvb, starting_offset + 52, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_paysize, tvb, starting_offset + 56, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_avgrate, tvb, starting_offset + 60, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_totalframes, tvb, starting_offset + 64, 4, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\n}\r\ncase 0x8b:\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_destip, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_destport, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_connectflags, tvb, starting_offset + 8, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 0x3f:\r\ncase 0x8f:\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_commandstatus, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_syserrno, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_statusstring, tvb, starting_offset + 8, 128, ENC_ASCII|ENC_NA);\r\nbreak;\r\n}\r\n}\r\nstatic guint32 dissect_wa_header(guint32 starting_offset, proto_item *parent_tree, tvbuff_t *tvb, guint8 version)\r\n{\r\nguint32 wa_payload_offset;\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_controlword, tvb, 30+starting_offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_payloadlen, tvb, 20+starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_transnum, tvb, 24+starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_rtoken, tvb, 32+starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_flowid, tvb, 36+starting_offset, 4, ENC_BIG_ENDIAN);\r\nif (version >= 3) {\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_capstatus, tvb, 40+starting_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_protocolversion, tvb, 40+starting_offset, 1, ENC_BIG_ENDIAN);\r\nwa_payload_offset = WA_V3_PAYLOAD_OFFSET + starting_offset;\r\n}\r\nelse {\r\nwa_payload_offset = WA_V2_PAYLOAD_OFFSET + starting_offset;\r\n}\r\nproto_tree_add_item(parent_tree,\r\nhf_waveagent_sigsequencenum, tvb, 4+starting_offset, 1, ENC_BIG_ENDIAN);\r\nreturn wa_payload_offset;\r\n}\r\nstatic int dissect_waveagent(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nproto_item *ti, *rmi;\r\nproto_tree *waveagent_tree, *relay_message_tree, *payload_tree;\r\nguint8 signature_start, signature_end;\r\nguint8 version;\r\nguint32 magic_number;\r\nguint32 control_word, paylen;\r\nguint32 wa_payload_offset;\r\nif (tvb_captured_length(tvb) < 52 )\r\nreturn 0;\r\nmagic_number = tvb_get_ntohl(tvb, 16) & 0x0FFFFFFF;\r\nif(magic_number != 0x0F87C3A5){\r\nreturn 0;\r\n}\r\nsignature_start = tvb_get_guint8(tvb, 0);\r\nsignature_end = tvb_get_guint8(tvb, 15);\r\nif ( ((signature_start != 0xcc) && (signature_start !=0xdd)) ||\r\n(signature_end != 0xE2))\r\nreturn 0;\r\nversion = ((tvb_get_ntohl(tvb, 16) & 0xF0000000) >> 28 == 1) ? 3 : 2;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "WA");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ncontrol_word = tvb_get_ntohl(tvb, 28);\r\npaylen = tvb_get_ntohl(tvb, 20);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s (0x%x)",\r\nval_to_str_ext_const(control_word, &control_words_ext, "Unknown"), control_word);\r\nif (tree) {\r\nti = proto_tree_add_protocol_format(tree, proto_waveagent, tvb, 0, -1,\r\n"WaveAgent, %s (0x%x), Payload Length %u Bytes",\r\nval_to_str_ext_const(control_word, &control_words_ext, "Unknown"), control_word, paylen);\r\nwaveagent_tree = proto_item_add_subtree(ti, ett_waveagent);\r\nwa_payload_offset = dissect_wa_header(0, waveagent_tree, tvb, version);\r\npayload_tree = waveagent_tree;\r\nif (control_word == 0x3e)\r\n{\r\nproto_tree_add_item(waveagent_tree,\r\nhf_waveagent_relaydestid, tvb, wa_payload_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(waveagent_tree,\r\nhf_waveagent_relaysrcid, tvb, wa_payload_offset+4, 4, ENC_BIG_ENDIAN);\r\ncontrol_word = tvb_get_ntohl(tvb, wa_payload_offset+12+28);\r\nrmi = proto_tree_add_none_format(waveagent_tree, hf_waveagent_relaymessagest,\r\ntvb, wa_payload_offset+12+28, 0,\r\n"Relayed WaveAgent Message, %s (0x%x)",\r\nval_to_str_ext_const(control_word, &control_words_ext, "Unknown"),\r\ncontrol_word);\r\nrelay_message_tree = proto_item_add_subtree(rmi, ett_relaymessage);\r\nwa_payload_offset = dissect_wa_header(wa_payload_offset+12, relay_message_tree, tvb, version);\r\npayload_tree = relay_message_tree;\r\n}\r\ndissect_wa_payload(wa_payload_offset, payload_tree, tvb, control_word, version);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean dissect_waveagent_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nreturn (dissect_waveagent(tvb, pinfo, tree) > 0) ? TRUE : FALSE;\r\n}\r\nvoid proto_register_waveagent(void)\r\n{\r\nstatic const value_string tcp_states[] = {\r\n{ 0, "Closed" },\r\n{ 1, "Listen" },\r\n{ 2, "SYN Sent" },\r\n{ 3, "SYN received" },\r\n{ 4, "Established" },\r\n{ 5, "FIN Wait 1" },\r\n{ 6, "FIN Wait 2" },\r\n{ 7, "Close Wait" },\r\n{ 8, "Closing" },\r\n{ 9, "Last ACK" },\r\n{ 10, "Time Wait" },\r\n{ 0, NULL },\r\n};\r\nstatic const value_string app_states[] = {\r\n{ 0, "IDLE" },\r\n{ 1, "READY" },\r\n{ 0, NULL },\r\n};\r\nstatic const value_string wa_modes[] = {\r\n{ 0, "In-band" },\r\n{ 1, "Source" },\r\n{ 2, "Sink" },\r\n{ 3, "Loopback" },\r\n{ 0, NULL },\r\n};\r\nstatic const value_string wa_endpointtypes[] = {\r\n{ 0, "Undefined" },\r\n{ 1, "Server" },\r\n{ 2, "Client" },\r\n{ 0, NULL },\r\n};\r\nstatic const value_string binding_levels[] = {\r\n{ 0, "WLAN" },\r\n{ 1, "Ethernet" },\r\n{ 2, "IP" },\r\n{ 3, "UDP" },\r\n{ 4, "TCP" },\r\n{ 5, "FIN Wait 1" },\r\n{ 6, "FIN Wait 2" },\r\n{ 7, "Close Wait" },\r\n{ 8, "Closing" },\r\n{ 9, "Last ACK" },\r\n{ 10, "Time Wait" },\r\n{ 0, NULL },\r\n};\r\nstatic const value_string if_types[] = {\r\n{ ETHERNET_INTERFACE, "Ethernet" },\r\n{ WLAN_INTERFACE, "WLAN" },\r\n{ 0, NULL },\r\n};\r\nstatic const value_string no_yes[] = {\r\n{ 0, "No" },\r\n{ 1, "Yes" },\r\n{ 0, NULL },\r\n};\r\nstatic const value_string ip_types[] = {\r\n{ 0, "Unspecified" },\r\n{ IPV4_TYPE, "IPv4" },\r\n{ IPV6_TYPE, "IPv6" },\r\n{ 0, NULL },\r\n};\r\nstatic const value_string if_l3_states[] = {\r\n{ 0, "Uninitialized" },\r\n{ 1, "Disconnected" },\r\n{ 2, "Connected" },\r\n{ 3, "Error" },\r\n{ 0, NULL },\r\n};\r\nstatic const value_string if_wlan_states[] = {\r\n{ 0, "Uninitialized" },\r\n{ 1, "Not ready" },\r\n{ 2, "Connected" },\r\n{ 3, "Ad Hoc network formed" },\r\n{ 4, "Disconnecting" },\r\n{ 5, "Disconnected" },\r\n{ 6, "Associating" },\r\n{ 7, "Discovering" },\r\n{ 8, "Authenticating" },\r\n{ 0, NULL },\r\n};\r\nstatic const value_string if_eth_states[] = {\r\n{ 0, "Uninitialized" },\r\n{ 1, "Not Operational" },\r\n{ 2, "Unreachable" },\r\n{ 3, "Disconnected" },\r\n{ 4, "Connecting" },\r\n{ 5, "Connected" },\r\n{ 6, "Operational" },\r\n{ 7, "Error" },\r\n{ 0, NULL },\r\n};\r\nstatic const value_string bss_modes[] = {\r\n{ 0, "Infrastructure" },\r\n{ 1, "IBSS" },\r\n{ 2, "Unknown" },\r\n{ 0, NULL },\r\n};\r\nstatic const value_string auth_algs[] = {\r\n{ 0, "Open" },\r\n{ 1, "Shared Key" },\r\n{ 2, "WPA" },\r\n{ 4, "WPA PSK" },\r\n{ 8, "WPA2" },\r\n{ 16, "WPA2 PSK" },\r\n{ 0, NULL },\r\n};\r\nstatic const value_string cipher_algs[] = {\r\n{ 0, "None" },\r\n{ 1, "WEP 40" },\r\n{ 2, "WEP 104" },\r\n{ 4, "WEP" },\r\n{ 8, "TKIP" },\r\n{ 16, "CCMP" },\r\n{ 0, NULL },\r\n};\r\nstatic hf_register_info hf[] = {\r\n{ &hf_waveagent_controlword,\r\n{ "Control Word", "waveagent.cword",\r\nFT_UINT16, BASE_HEX | BASE_EXT_STRING, &control_words_ext, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_payloadlen,\r\n{ "Payload Length", "waveagent.paylen",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_transnum,\r\n{ "Transaction Number", "waveagent.transnum",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_rtoken,\r\n{ "Reservation Token", "waveagent.rtoken",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_flowid,\r\n{ "Flow ID", "waveagent.flowid",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_capstatus,\r\n{ "Capabilities Status", "waveagent.capstatus",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_protocolversion,\r\n{ "Protocol Version", "waveagent.protocolversion",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_capimpl,\r\n{ "Capabilities Implementation", "waveagent.capimpl",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_sigsequencenum,\r\n{ "Signature Sequence Number", "waveagent.sigsequencenum",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_id,\r\n{ "ID", "waveagent.id",\r\nFT_STRING, 0, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_bindtag,\r\n{ "Binding Tag", "waveagent.bindtag",\r\nFT_STRING, 0, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_version,\r\n{ "Version", "waveagent.version",\r\nFT_STRING, 0, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_brokerip,\r\n{ "Broker IP address", "waveagent.brokerip",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_brokerport,\r\n{ "Broker Port", "waveagent.brokerport",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_bindlevel,\r\n{ "Binding Level", "waveagent.bindlevel",\r\nFT_UINT32, BASE_DEC, VALS(binding_levels), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_bindport,\r\n{ "Binding Port", "waveagent.bindport",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifindex,\r\n{ "Interface Index", "waveagent.ifindex",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_capabilities2,\r\n{ "Additional Capabilities", "waveagent.capabilities2",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_numinterfaces,\r\n{ "Number of WA Interfaces", "waveagent.numinterfaces",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifmask,\r\n{ "Mask of Active Interfaces", "waveagent.ifmask",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_commandstatus,\r\n{ "Status of Previous Command", "waveagent.cmdstat",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_syserrno,\r\n{ "System Error Number", "waveagent.syserrno",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_statusstring,\r\n{ "Status Message", "waveagent.statmsg",\r\nFT_STRING, 0, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_rxdatapckts,\r\n{ "Received Data Packets", "waveagent.rxdpkts",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_rxdatabytes,\r\n{ "Received Data Bytes", "waveagent.rxdbytes",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_rxpcktrate,\r\n{ "Received Data Packet Rate (pps)", "waveagent.rxpktrate",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_rxbyterate,\r\n{ "Received Byte Rate", "waveagent.rxbyterate",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_txdatapckts,\r\n{ "Transmitted Data Packets", "waveagent.txdpkts",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_txdatabytes,\r\n{ "Transmitted Data Bytes", "waveagent.txdbytes",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_txpcktrate,\r\n{ "Transmitted Data Packet Rate (pps)", "waveagent.txpktrate",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_txbyterate,\r\n{ "Transmitted Byte Rate", "waveagent.txbyterate",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_looppckts,\r\n{ "Loopback Packets", "waveagent.looppckts",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_loopbytes,\r\n{ "Loopback Bytes", "waveagent.loopbytes",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_rxctlpckts,\r\n{ "Received Control Packets", "waveagent.rxctlpkts",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_rxctlbytes,\r\n{ "Received Control Bytes", "waveagent.rxctlbytes",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_txctlpckts,\r\n{ "Transmitted Control Packets", "waveagent.txctlpkts",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_txctlbytes,\r\n{ "Transmitted Control Bytes", "waveagent.txctlbytes",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_unknowncmds,\r\n{ "Unknown Commands", "waveagent.unkcmds",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_snap,\r\n{ "Time Snap for Counters", "waveagent.snap",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_appstate,\r\n{ "TCP State", "waveagent.state",\r\nFT_UINT32, BASE_DEC, VALS(tcp_states), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_state,\r\n{ "Application State", "waveagent.appstate",\r\nFT_UINT32, BASE_DEC, VALS(app_states), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_rx1pl,\r\n{ "Instances of single packet loss", "waveagent.rx1pl",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_rx2pl,\r\n{ "Instances of 2 sequential packets lost", "waveagent.rx2pl",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_rx3pl,\r\n{ "Instances of 3 sequential packets lost", "waveagent.rx3pl",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_rx4pl,\r\n{ "Instances of 4 sequential packets lost", "waveagent.rx4pl",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_rx5pl,\r\n{ "Instances of 5 sequential packets lost", "waveagent.rx5pl",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_rxoospkts,\r\n{ "Instances of out-of-sequence packets", "waveagent.rxoospkts",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n#if 0\r\n{ &hf_waveagent_rxmeanlatency,\r\n{ "Rx Mean latency", "waveagent.rxmeanlatency",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n#endif\r\n#if 0\r\n{ &hf_waveagent_rxminlatency,\r\n{ "Rx Minimum latency", "waveagent.rxminlatency",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n#endif\r\n#if 0\r\n{ &hf_waveagent_rxmaxlatency,\r\n{ "Rx Maximum latency", "waveagent.rxmaxlatency",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n#endif\r\n{ &hf_waveagent_jitter,\r\n{ "Jitter (microseconds)", "waveagent.jitter",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_delayfactor,\r\n{ "Delay Factor", "waveagent.delayfactor",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_medialossrate,\r\n{ "Media Loss Rate", "waveagent.medialossrate",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_txstartts,\r\n{ "Timestamp for first Tx flow packet", "waveagent.txstartts",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_txendts,\r\n{ "Timestamp for last Tx flow packet", "waveagent.txendts",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_rxstartts,\r\n{ "Timestamp for first Rx flow packet", "waveagent.rxstartts",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_rxendts,\r\n{ "Timestamp for last Rx flow packet", "waveagent.rxendts",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_latencysum,\r\n{ "Sum of latencies across all received packets", "waveagent.latencysum",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_latencycount,\r\n{ "Count of packets included in the latency sum", "waveagent.latencycount",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_txflowstop,\r\n{ "Timestamp for Tx flow stop message", "waveagent.txflowstop",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_rxflownum,\r\n{ "Received Flow Number", "waveagent.rxflownum",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_mode,\r\n{ "WaveAgent Mode", "waveagent.trafficmode",\r\nFT_UINT8, BASE_DEC, VALS(wa_modes), 0x03,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_endpointtype,\r\n{ "WaveAgent Endpoint Type", "waveagent.endpointtype",\r\nFT_UINT8, BASE_DEC, VALS(wa_endpointtypes), 0x0c,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_remoteport,\r\n{ "Remote port", "waveagent.remoteport",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_remoteaddr,\r\n{ "Remote address", "waveagent.remoteaddr",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_dscp,\r\n{ "DSCP Setting", "waveagent.dscp",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_fsflags,\r\n{ "Flow Setup Flags", "waveagent.fsflags",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_fscbrflag,\r\n{ "CBR Transmit Mode", "waveagent.fscbrflag",\r\nFT_BOOLEAN, 4, NULL, 0x01, NULL, HFILL } },\r\n{ &hf_waveagent_fscombinedsetupflag,\r\n{ "Setup, Connect/Listen, Start Combined", "waveagent.fscombinedsetupflag",\r\nFT_BOOLEAN, 4, NULL, 0x02, NULL, HFILL } },\r\n{ &hf_waveagent_payfill,\r\n{ "Payload Fill", "waveagent.payfill",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_paysize,\r\n{ "WaveAgent Payload Size (bytes)", "waveagent.paysize",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_avgrate,\r\n{ "Average Rate (header + payload + trailer bytes/s)", "waveagent.avgrate",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_totalframes,\r\n{ "Total Frames", "waveagent.totalframes",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_bssidstartindex,\r\n{ "Starting Index of BSSID list for reporting", "waveagent.bssidstartindex",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_bssidstopindex,\r\n{ "Ending Index of BSSID list for reporting", "waveagent.bssidstopindex",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifwlanbssid,\r\n{ "WLAN Interface Connected to BSSID", "waveagent.ifwlanbssid",\r\nFT_ETHER, 0, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifwlanssid,\r\n{ "WLAN Interface Connected to SSID", "waveagent.ifwlanssid",\r\nFT_STRING, 0, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifwlanrssi,\r\n{ "WLAN Interface RSSI", "waveagent.ifwlanrssi",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifwlannoise,\r\n{ "WLAN Interface Noise Floor (dBm)", "waveagent.ifwlannoise",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifphytypes,\r\n{ "WLAN Interface Supported PHY Types", "waveagent.ifphytypes",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifphytypebit0,\r\n{ "11b", "waveagent.ifphytypebit0",\r\nFT_BOOLEAN, 4, NULL, 0x01, NULL, HFILL } },\r\n{ &hf_waveagent_ifphytypebit1,\r\n{ "11g", "waveagent.ifphytypebit1",\r\nFT_BOOLEAN, 4, NULL, 0x02, NULL, HFILL } },\r\n{ &hf_waveagent_ifphytypebit2,\r\n{ "11a", "waveagent.ifphytypebit2",\r\nFT_BOOLEAN, 4, NULL, 0x04, NULL, HFILL } },\r\n{ &hf_waveagent_ifphytypebit3,\r\n{ "11n", "waveagent.ifphytypebit3",\r\nFT_BOOLEAN, 4, NULL, 0x08, NULL, HFILL } },\r\n{ &hf_waveagent_ifwlanauthentication,\r\n{ "WLAN Interface Authentication Algorithm", "waveagent.ifwlanauthentication",\r\nFT_UINT32, BASE_DEC, VALS(auth_algs), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifwlancipher,\r\n{ "WLAN Interface Encryption/Cipher Algorithm", "waveagent.ifwlancipher",\r\nFT_UINT32, BASE_DEC, VALS(cipher_algs), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_iftype,\r\n{ "Interface type", "waveagent.iftype",\r\nFT_UINT32, BASE_DEC, VALS(if_types), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifdescription,\r\n{ "Name/Description of the adapter", "waveagent.ifdescription",\r\nFT_STRING, 0, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifmacaddr,\r\n{ "Interface MAC Address", "waveagent.ifmacaddr",\r\nFT_ETHER, 0, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_iflinkspeed,\r\n{ "Interface Link Speed (kbps)", "waveagent.iflinkspeed",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifdhcp,\r\n{ "Interface DHCP Enabled", "waveagent.ifdhcp",\r\nFT_UINT32, BASE_DEC, VALS(no_yes), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifiptype,\r\n{ "Interface IP Type", "waveagent.ifiptype",\r\nFT_UINT32, BASE_DEC, VALS(ip_types), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifipv4,\r\n{ "Interface Bound to IP Address", "waveagent.ifipv4",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifipv6,\r\n{ "Interface Bound to IP Address", "waveagent.ifipv6",\r\nFT_IPv6, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifdhcpserver,\r\n{ "Interface DHCP Server Address", "waveagent.ifdhcpserver",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifgateway,\r\n{ "Interface Gateway", "waveagent.ifgateway",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifdnsserver,\r\n{ "Interface DNS Server Address", "waveagent.ifdnsserver",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifethl2status,\r\n{ "Ethernet L2 Interface Status", "waveagent.ifethl2status",\r\nFT_UINT32, BASE_DEC, VALS(if_eth_states), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifwlanl2status,\r\n{ "WLAN L2 Interface Status", "waveagent.ifwlanl2status",\r\nFT_UINT32, BASE_DEC, VALS(if_wlan_states), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifl3status,\r\n{ "L3 Interface Status", "waveagent.ifl3status",\r\nFT_UINT32, BASE_DEC, VALS(if_l3_states), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_totalbssid,\r\n{ "Number of Found BSSID", "waveagent.totalbssid",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_returnedbssid,\r\n{ "Number of BSSID Reported in This Response", "waveagent.returnedbssid",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_scanbssid,\r\n{ "BSSID", "waveagent.scanbssid",\r\nFT_ETHER, 0, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_scanssid,\r\n{ "SSID", "waveagent.scanssid",\r\nFT_STRING, 0, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifwlansupprates,\r\n{ "Supported Rates", "waveagent.ifwlansupportedrates",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifwlancapabilities,\r\n{ "Capabilities field", "waveagent.ifwlancapabilities",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifwlanchannel,\r\n{ "Channel", "waveagent.ifwlanchannel",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifwlanprivacy,\r\n{ "Privacy Enabled", "waveagent.ifwlanprivacy",\r\nFT_UINT32, BASE_DEC, VALS(no_yes), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_ifwlanbssmode,\r\n{ "BSS Mode", "waveagent.ifwlanbssmode",\r\nFT_UINT32, BASE_DEC, VALS(bss_modes), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_oidcode,\r\n{ "OID Code", "waveagent.oidcode",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_oidvalue,\r\n{ "OID Value", "waveagent.oidvalue",\r\nFT_STRING, 0, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_destip,\r\n{ "Destination IP", "waveagent.destip",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_destport,\r\n{ "Destination Port", "waveagent.destport",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_connectflags,\r\n{ "Connect Flags", "waveagent.connectflags",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_connecttype,\r\n{ "Connect Type", "waveagent.connecttype",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_minrssi,\r\n{ "Minimum RSSI", "waveagent.minrssi",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_connecttimeout,\r\n{ "Connect timeout (s)", "waveagent.connecttimeout",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_connectattempts,\r\n{ "Connect attempts", "waveagent.connectattempt",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_reason,\r\n{ "Reason", "waveagent.reason",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_relaydestid,\r\n{ "ID of destination client (assigned by relay server)", "waveagent.relaydestid",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_relaysrcid,\r\n{ "ID of source client (assigned by relay server)", "waveagent.relaysrcid",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_waveagent_relaymessagest,\r\n{ "Relayed WaveAgent Message", "waveagent.relaymessagest",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\n"This is a relayed WaveAgent message", HFILL } },\r\n};\r\nstatic gint *ett[] = {\r\n&ett_waveagent,\r\n&ett_statechange,\r\n&ett_phytypes,\r\n&ett_fsflags,\r\n&ett_scindex[0],\r\n&ett_scindex[1],\r\n&ett_scindex[2],\r\n&ett_scindex[3],\r\n&ett_scindex[4],\r\n&ett_scindex[5],\r\n&ett_scindex[6],\r\n&ett_scindex[7],\r\n&ett_bss[0],\r\n&ett_bss[1],\r\n&ett_bss[2],\r\n&ett_bss[3],\r\n&ett_bss[4],\r\n&ett_bss[5],\r\n&ett_bss[6],\r\n&ett_bss[7],\r\n&ett_relaymessage,\r\n};\r\nproto_waveagent = proto_register_protocol(\r\n"WaveAgent", "waveagent", "waveagent");\r\nproto_register_field_array(proto_waveagent, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid proto_reg_handoff_waveagent(void)\r\n{\r\nheur_dissector_add("udp", dissect_waveagent_heur, "WaveAgent over UDP", "waveagent_udp", proto_waveagent, HEURISTIC_ENABLE);\r\n}
