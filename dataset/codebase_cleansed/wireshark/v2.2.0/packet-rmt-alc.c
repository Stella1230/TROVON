static int\r\ndissect_alc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nguint8 version;\r\nlct_data_exchange_t lct;\r\nfec_data_exchange_t fec;\r\nint len;\r\nguint offset = 0;\r\nproto_item *ti;\r\nproto_tree *alc_tree;\r\ntvbuff_t *new_tvb;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ALC");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nversion = hi_nibble(tvb_get_guint8(tvb, offset));\r\nti = proto_tree_add_item(tree, proto_rmt_alc, tvb, offset, -1, ENC_NA);\r\nalc_tree = proto_item_add_subtree(ti, ett_main);\r\nti = proto_tree_add_uint(alc_tree, hf_version, tvb, offset, 1, version);\r\nif (version != 1) {\r\nexpert_add_info(pinfo, ti, &ei_version1_only);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Version: %u (not supported)", version);\r\nreturn 0;\r\n}\r\nnew_tvb = tvb_new_subset_remaining(tvb,offset);\r\nlct.ext_192 = g_ext_192;\r\nlct.ext_193 = g_ext_193;\r\nlct.codepoint = 0;\r\nlct.is_flute = FALSE;\r\nlen = call_dissector_with_data(rmt_lct_handle, new_tvb, pinfo, alc_tree, &lct);\r\nif (len < 0)\r\nreturn offset;\r\noffset += len;\r\nif (g_codepoint_as_fec_encoding && tvb_reported_length(tvb) > offset)\r\n{\r\nfec.encoding_id = lct.codepoint;\r\nnew_tvb = tvb_new_subset_remaining(tvb,offset);\r\nlen = call_dissector_with_data(rmt_fec_handle, new_tvb, pinfo, alc_tree, &fec);\r\nif (len < 0)\r\nreturn offset;\r\noffset += len;\r\n}\r\nif (tvb_reported_length(tvb) > offset){\r\nif(lct.is_flute){\r\nnew_tvb = tvb_new_subset_remaining(tvb,offset);\r\ncall_dissector(xml_handle, new_tvb, pinfo, alc_tree);\r\n}else{\r\nproto_tree_add_item(alc_tree, hf_payload, tvb, offset, -1, ENC_NA);\r\n}\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nvoid proto_register_alc(void)\r\n{\r\nstatic hf_register_info hf_ptr[] = {\r\n{ &hf_version,\r\n{ "Version", "alc.version", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_payload,\r\n{ "Payload", "alc.payload", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }}\r\n};\r\nstatic gint *ett_ptr[] = {\r\n&ett_main,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_version1_only, { "alc.version1_only", PI_PROTOCOL, PI_WARN, "Sorry, this dissector supports ALC version 1 only", EXPFILL }},\r\n};\r\nmodule_t *module;\r\nexpert_module_t* expert_rmt_alc;\r\nproto_rmt_alc = proto_register_protocol("Asynchronous Layered Coding", "ALC", "alc");\r\nregister_dissector("alc", dissect_alc, proto_rmt_alc);\r\nproto_register_field_array(proto_rmt_alc, hf_ptr, array_length(hf_ptr));\r\nproto_register_subtree_array(ett_ptr, array_length(ett_ptr));\r\nexpert_rmt_alc = expert_register_protocol(proto_rmt_alc);\r\nexpert_register_field_array(expert_rmt_alc, ei, array_length(ei));\r\nmodule = prefs_register_protocol(proto_rmt_alc, proto_reg_handoff_alc);\r\nprefs_register_obsolete_preference(module, "default.udp_port.enabled");\r\nprefs_register_uint_preference(module,\r\n"default.udp_port",\r\n"UDP destination port",\r\n"Specifies the UDP destination port for automatic dissection of ALC packets",\r\n10, &g_default_udp_port);\r\nprefs_register_bool_preference(module,\r\n"lct.codepoint_as_fec_id",\r\n"LCT Codepoint as FEC Encoding ID",\r\n"Whether the LCT header Codepoint field should be considered the FEC Encoding ID of carried object",\r\n&g_codepoint_as_fec_encoding);\r\nprefs_register_enum_preference(module,\r\n"lct.ext.192",\r\n"LCT header extension 192",\r\n"How to decode LCT header extension 192",\r\n&g_ext_192,\r\nenum_lct_ext_192,\r\nFALSE);\r\nprefs_register_enum_preference(module,\r\n"lct.ext.193",\r\n"LCT header extension 193",\r\n"How to decode LCT header extension 193",\r\n&g_ext_193,\r\nenum_lct_ext_193,\r\nFALSE);\r\n}\r\nvoid proto_reg_handoff_alc(void)\r\n{\r\nstatic dissector_handle_t handle;\r\nstatic gboolean preferences_initialized = FALSE;\r\nstatic guint old_udp_port = 0;\r\nif (!preferences_initialized)\r\n{\r\npreferences_initialized = TRUE;\r\nhandle = create_dissector_handle(dissect_alc, proto_rmt_alc);\r\ndissector_add_for_decode_as("udp.port", handle);\r\nxml_handle = find_dissector_add_dependency("xml", proto_rmt_alc);\r\nrmt_lct_handle = find_dissector_add_dependency("rmt-lct", proto_rmt_alc);\r\nrmt_fec_handle = find_dissector_add_dependency("rmt-fec", proto_rmt_alc);\r\n}\r\nif(old_udp_port != 0 && old_udp_port != g_default_udp_port){\r\ndissector_delete_uint("udp.port", old_udp_port, handle);\r\n}\r\nif(g_default_udp_port != 0 && old_udp_port != g_default_udp_port) {\r\ndissector_add_uint("udp.port", g_default_udp_port, handle);\r\n}\r\nold_udp_port = g_default_udp_port;\r\n}
