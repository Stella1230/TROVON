static int\r\ndissect_isdn(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *isdn_tree;\r\nproto_item *ti;\r\nstatic const guint8 v120_sabme[3] = { 0x08, 0x01, 0x7F };\r\nstatic const guint8 ppp[2] = { 0xFF, 0x03 };\r\ncircuit_t *circuit;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ISDN");\r\nif (pinfo->pseudo_header->isdn.uton) {\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_DST, "Network");\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_SRC, "User");\r\n} else {\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_DST, "User");\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_SRC, "Network");\r\n}\r\npinfo->ctype = CT_ISDN;\r\npinfo->circuit_id = pinfo->pseudo_header->isdn.channel;\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_isdn, tvb, 0, 0, ENC_NA);\r\nisdn_tree = proto_item_add_subtree(ti, ett_isdn);\r\nproto_tree_add_uint(isdn_tree, hf_isdn_channel, tvb, 0, 0,\r\npinfo->pseudo_header->isdn.channel);\r\n}\r\ncircuit = find_circuit(CT_ISDN, pinfo->pseudo_header->isdn.channel, pinfo->num);\r\nif (circuit == NULL)\r\ncircuit = circuit_new(CT_ISDN, pinfo->pseudo_header->isdn.channel, pinfo->num);\r\nif (circuit_get_dissector(circuit) == NULL) {\r\nswitch (pinfo->pseudo_header->isdn.channel) {\r\ncase 0:\r\nswitch (dchannel_protocol) {\r\ncase DCHANNEL_LAPD:\r\ncircuit_set_dissector(circuit, lapd_handle);\r\nbreak;\r\ncase DCHANNEL_DPNSS:\r\ncircuit_set_dissector(circuit,\r\ndpnss_link_handle);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nif (tvb_memeql(tvb, 0, v120_sabme, 3) == 0) {\r\ncircuit_set_dissector(circuit, v120_handle);\r\n} else if (tvb_memeql(tvb, 0, ppp, 2) == 0) {\r\ncircuit_set_dissector(circuit, ppp_hdlc_handle);\r\n}\r\nbreak;\r\n}\r\n}\r\nif (!try_circuit_dissector(CT_ISDN, pinfo->pseudo_header->isdn.channel,\r\npinfo->num, tvb, pinfo, tree, NULL))\r\ncall_data_dissector(tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_isdn(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_isdn_channel,\r\n{ "Channel", "isdn.channel", FT_UINT8, BASE_DEC,\r\nVALS(channel_vals), 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_isdn,\r\n};\r\nmodule_t *isdn_module;\r\nproto_isdn = proto_register_protocol("ISDN", "ISDN", "isdn");\r\nproto_register_field_array(proto_isdn, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nisdn_module = prefs_register_protocol(proto_isdn, NULL);\r\nprefs_register_enum_preference(isdn_module, "dchannel_protocol",\r\n"D-channel protocol",\r\n"The protocol running on the D channel",\r\n&dchannel_protocol, dchannel_protocol_options, FALSE);\r\n}\r\nvoid\r\nproto_reg_handoff_isdn(void)\r\n{\r\ndissector_handle_t isdn_handle;\r\nlapd_handle = find_dissector("lapd");\r\ndpnss_link_handle = find_dissector("dpnss_link");\r\nppp_hdlc_handle = find_dissector("ppp_hdlc");\r\nv120_handle = find_dissector("v120");\r\nisdn_handle = create_dissector_handle(dissect_isdn, proto_isdn);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_ISDN, isdn_handle);\r\n}
