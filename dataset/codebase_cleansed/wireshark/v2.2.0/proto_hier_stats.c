static GNode*\r\nfind_stat_node(GNode *parent_stat_node, header_field_info *needle_hfinfo)\r\n{\r\nGNode *needle_stat_node, *up_parent_stat_node;\r\nheader_field_info *hfinfo;\r\nph_stats_node_t *stats;\r\nneedle_stat_node = g_node_first_child(parent_stat_node);\r\nwhile (needle_stat_node) {\r\nhfinfo = STAT_NODE_HFINFO(needle_stat_node);\r\nif (hfinfo && hfinfo->id == needle_hfinfo->id) {\r\nreturn needle_stat_node;\r\n}\r\nneedle_stat_node = g_node_next_sibling(needle_stat_node);\r\n}\r\nup_parent_stat_node = parent_stat_node;\r\nwhile (up_parent_stat_node && up_parent_stat_node->parent)\r\n{\r\nneedle_stat_node = g_node_first_child(up_parent_stat_node->parent);\r\nwhile (needle_stat_node) {\r\nhfinfo = STAT_NODE_HFINFO(needle_stat_node);\r\nif (hfinfo && hfinfo->id == needle_hfinfo->id) {\r\nreturn needle_stat_node;\r\n}\r\nneedle_stat_node = g_node_next_sibling(needle_stat_node);\r\n}\r\nup_parent_stat_node = up_parent_stat_node->parent;\r\n}\r\nstats = g_new(ph_stats_node_t, 1);\r\nstats->hfinfo = needle_hfinfo;\r\nstats->num_pkts_total = 0;\r\nstats->num_pkts_last = 0;\r\nstats->num_bytes_total = 0;\r\nstats->num_bytes_last = 0;\r\nneedle_stat_node = g_node_new(stats);\r\ng_node_append(parent_stat_node, needle_stat_node);\r\nreturn needle_stat_node;\r\n}\r\nstatic void\r\nprocess_node(proto_node *ptree_node, GNode *parent_stat_node, ph_stats_t *ps)\r\n{\r\nfield_info *finfo;\r\nph_stats_node_t *stats;\r\nproto_node *proto_sibling_node;\r\nGNode *stat_node;\r\nfinfo = PNODE_FINFO(ptree_node);\r\ng_assert(finfo);\r\nif (finfo->hfinfo->parent != -1) {\r\nstat_node = parent_stat_node;\r\nstats = STAT_NODE_STATS(stat_node);\r\n} else {\r\nstat_node = find_stat_node(parent_stat_node, finfo->hfinfo);\r\nstats = STAT_NODE_STATS(stat_node);\r\nstats->num_pkts_total++;\r\nstats->num_bytes_total += finfo->length;\r\n}\r\nproto_sibling_node = ptree_node->next;\r\nif (proto_sibling_node) {\r\nif(strlen(PNODE_FINFO(proto_sibling_node)->hfinfo->name) == 0 && ptree_node->next)\r\nproto_sibling_node = proto_sibling_node->next;\r\nprocess_node(proto_sibling_node, stat_node, ps);\r\n} else {\r\nstats->num_pkts_last++;\r\nstats->num_bytes_last += finfo->length;\r\n}\r\n}\r\nstatic void\r\nprocess_tree(proto_tree *protocol_tree, ph_stats_t* ps)\r\n{\r\nproto_node *ptree_node;\r\nptree_node = ((proto_node *)protocol_tree)->first_child;\r\nif (ptree_node && ptree_node->finfo->hfinfo->id == pc_proto_id) {\r\nptree_node = ptree_node->next;\r\n}\r\nif (!ptree_node) {\r\nreturn;\r\n}\r\nprocess_node(ptree_node, ps->stats_tree, ps);\r\n}\r\nstatic gboolean\r\nprocess_record(capture_file *cf, frame_data *frame, column_info *cinfo, ph_stats_t* ps)\r\n{\r\nepan_dissect_t edt;\r\nstruct wtap_pkthdr phdr;\r\nBuffer buf;\r\ndouble cur_time;\r\nwtap_phdr_init(&phdr);\r\nws_buffer_init(&buf, 1500);\r\nif (!cf_read_record_r(cf, frame, &phdr, &buf))\r\nreturn FALSE;\r\nepan_dissect_init(&edt, cf->epan, TRUE, FALSE);\r\nepan_dissect_fake_protocols(&edt, FALSE);\r\nepan_dissect_run(&edt, cf->cd_t, &phdr, frame_tvbuff_new_buffer(frame, &buf), frame, cinfo);\r\nprocess_tree(edt.tree, ps);\r\nif (frame->flags.has_ts) {\r\ncur_time = nstime_to_sec(&frame->abs_ts);\r\nif (cur_time < ps->first_time)\r\nps->first_time = cur_time;\r\nif (cur_time > ps->last_time)\r\nps->last_time = cur_time;\r\n}\r\nepan_dissect_cleanup(&edt);\r\nwtap_phdr_cleanup(&phdr);\r\nws_buffer_free(&buf);\r\nreturn TRUE;\r\n}\r\nph_stats_t*\r\nph_stats_new(capture_file *cf)\r\n{\r\nph_stats_t *ps;\r\nguint32 framenum;\r\nframe_data *frame;\r\nguint tot_packets, tot_bytes;\r\nprogdlg_t *progbar = NULL;\r\ngboolean stop_flag;\r\nint count;\r\nfloat progbar_val;\r\nGTimeVal start_time;\r\ngchar status_str[100];\r\nint progbar_nextstep;\r\nint progbar_quantum;\r\nif (!cf) return NULL;\r\npc_proto_id = proto_get_id_by_filter_name("pkt_comment");\r\nps = g_new(ph_stats_t, 1);\r\nps->tot_packets = 0;\r\nps->tot_bytes = 0;\r\nps->stats_tree = g_node_new(NULL);\r\nps->first_time = 0.0;\r\nps->last_time = 0.0;\r\nprogbar_nextstep = 0;\r\nprogbar_quantum = cf->count/N_PROGBAR_UPDATES;\r\ncount = 0;\r\nprogbar_val = 0.0f;\r\nstop_flag = FALSE;\r\ng_get_current_time(&start_time);\r\ntot_packets = 0;\r\ntot_bytes = 0;\r\nfor (framenum = 1; framenum <= cf->count; framenum++) {\r\nframe = frame_data_sequence_find(cf->frames, framenum);\r\nif (progbar == NULL)\r\nprogbar = delayed_create_progress_dlg(\r\ncf->window, "Computing",\r\n"protocol hierarchy statistics",\r\nTRUE, &stop_flag, &start_time, progbar_val);\r\nif (count >= progbar_nextstep) {\r\ng_assert(cf->count > 0);\r\nprogbar_val = (gfloat) count / cf->count;\r\nif (progbar != NULL) {\r\ng_snprintf(status_str, sizeof(status_str),\r\n"%4u of %u frames", count, cf->count);\r\nupdate_progress_dlg(progbar, progbar_val, status_str);\r\n}\r\nprogbar_nextstep += progbar_quantum;\r\n}\r\nif (stop_flag) {\r\nbreak;\r\n}\r\nif (frame->flags.passed_dfilter) {\r\nif (frame->flags.has_ts) {\r\nif (tot_packets == 0) {\r\ndouble cur_time = nstime_to_sec(&frame->abs_ts);\r\nps->first_time = cur_time;\r\nps->last_time = cur_time;\r\n}\r\n}\r\nif (!process_record(cf, frame, NULL, ps)) {\r\nstop_flag = TRUE;\r\nbreak;\r\n}\r\ntot_packets++;\r\ntot_bytes += frame->pkt_len;\r\n}\r\ncount++;\r\n}\r\nif (progbar != NULL)\r\ndestroy_progress_dlg(progbar);\r\nif (stop_flag) {\r\nph_stats_free(ps);\r\nreturn NULL;\r\n}\r\nps->tot_packets = tot_packets;\r\nps->tot_bytes = tot_bytes;\r\nreturn ps;\r\n}\r\nstatic gboolean\r\nstat_node_free(GNode *node, gpointer data _U_)\r\n{\r\nph_stats_node_t *stats = (ph_stats_node_t *)node->data;\r\nif (stats) {\r\ng_free(stats);\r\n}\r\nreturn FALSE;\r\n}\r\nvoid\r\nph_stats_free(ph_stats_t *ps)\r\n{\r\nif (ps->stats_tree) {\r\ng_node_traverse(ps->stats_tree, G_IN_ORDER,\r\nG_TRAVERSE_ALL, -1,\r\nstat_node_free, NULL);\r\ng_node_destroy(ps->stats_tree);\r\n}\r\ng_free(ps);\r\n}
