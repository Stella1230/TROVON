void *\r\nwmem_alloc(wmem_allocator_t *allocator, const size_t size)\r\n{\r\nif (allocator == NULL) {\r\nreturn g_malloc(size);\r\n}\r\ng_assert(allocator->in_scope);\r\nif (size == 0) {\r\nreturn NULL;\r\n}\r\nreturn allocator->walloc(allocator->private_data, size);\r\n}\r\nvoid *\r\nwmem_alloc0(wmem_allocator_t *allocator, const size_t size)\r\n{\r\nvoid *buf;\r\nbuf = wmem_alloc(allocator, size);\r\nif (buf) {\r\nmemset(buf, 0, size);\r\n}\r\nreturn buf;\r\n}\r\nvoid\r\nwmem_free(wmem_allocator_t *allocator, void *ptr)\r\n{\r\nif (allocator == NULL) {\r\ng_free(ptr);\r\nreturn;\r\n}\r\ng_assert(allocator->in_scope);\r\nif (ptr == NULL) {\r\nreturn;\r\n}\r\nallocator->wfree(allocator->private_data, ptr);\r\n}\r\nvoid *\r\nwmem_realloc(wmem_allocator_t *allocator, void *ptr, const size_t size)\r\n{\r\nif (allocator == NULL) {\r\nreturn g_realloc(ptr, size);\r\n}\r\nif (ptr == NULL) {\r\nreturn wmem_alloc(allocator, size);\r\n}\r\nif (size == 0) {\r\nwmem_free(allocator, ptr);\r\nreturn NULL;\r\n}\r\ng_assert(allocator->in_scope);\r\nreturn allocator->wrealloc(allocator->private_data, ptr, size);\r\n}\r\nstatic void\r\nwmem_free_all_real(wmem_allocator_t *allocator, gboolean final)\r\n{\r\nwmem_call_callbacks(allocator,\r\nfinal ? WMEM_CB_DESTROY_EVENT : WMEM_CB_FREE_EVENT);\r\nallocator->free_all(allocator->private_data);\r\n}\r\nvoid\r\nwmem_free_all(wmem_allocator_t *allocator)\r\n{\r\nwmem_free_all_real(allocator, FALSE);\r\n}\r\nvoid\r\nwmem_gc(wmem_allocator_t *allocator)\r\n{\r\nallocator->gc(allocator->private_data);\r\n}\r\nvoid\r\nwmem_destroy_allocator(wmem_allocator_t *allocator)\r\n{\r\nwmem_free_all_real(allocator, TRUE);\r\nallocator->cleanup(allocator->private_data);\r\nwmem_free(NULL, allocator);\r\n}\r\nwmem_allocator_t *\r\nwmem_allocator_new(const wmem_allocator_type_t type)\r\n{\r\nwmem_allocator_t *allocator;\r\nwmem_allocator_type_t real_type;\r\nif (do_override) {\r\nreal_type = override_type;\r\n}\r\nelse {\r\nreal_type = type;\r\n}\r\nallocator = wmem_new(NULL, wmem_allocator_t);\r\nallocator->type = real_type;\r\nallocator->callbacks = NULL;\r\nallocator->in_scope = TRUE;\r\nswitch (real_type) {\r\ncase WMEM_ALLOCATOR_SIMPLE:\r\nwmem_simple_allocator_init(allocator);\r\nbreak;\r\ncase WMEM_ALLOCATOR_BLOCK:\r\nwmem_block_allocator_init(allocator);\r\nbreak;\r\ncase WMEM_ALLOCATOR_BLOCK_FAST:\r\nwmem_block_fast_allocator_init(allocator);\r\nbreak;\r\ncase WMEM_ALLOCATOR_STRICT:\r\nwmem_strict_allocator_init(allocator);\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nreturn NULL;\r\n};\r\nreturn allocator;\r\n}\r\nvoid\r\nwmem_init(void)\r\n{\r\nconst char *override_env;\r\noverride_env = getenv("WIRESHARK_DEBUG_WMEM_OVERRIDE");\r\nif (override_env == NULL) {\r\ndo_override = FALSE;\r\n}\r\nelse {\r\ndo_override = TRUE;\r\nif (strncmp(override_env, "simple", strlen("simple")) == 0) {\r\noverride_type = WMEM_ALLOCATOR_SIMPLE;\r\n}\r\nelse if (strncmp(override_env, "block", strlen("block")) == 0) {\r\noverride_type = WMEM_ALLOCATOR_BLOCK;\r\n}\r\nelse if (strncmp(override_env, "strict", strlen("strict")) == 0) {\r\noverride_type = WMEM_ALLOCATOR_STRICT;\r\n}\r\nelse if (strncmp(override_env, "block_fast", strlen("block_fast")) == 0) {\r\noverride_type = WMEM_ALLOCATOR_BLOCK_FAST;\r\n}\r\nelse {\r\ng_warning("Unrecognized wmem override");\r\ndo_override = FALSE;\r\n}\r\n}\r\nwmem_init_scopes();\r\nwmem_init_hashing();\r\n}\r\nvoid\r\nwmem_cleanup(void)\r\n{\r\nwmem_cleanup_scopes();\r\n}
