lbttcp_transport_t * lbttcp_transport_find(const address * source_address, guint16 source_port, guint32 session_id, guint32 frame)\r\n{\r\nlbttcp_transport_t * entry = NULL;\r\nconversation_t * conv = NULL;\r\nlbttcp_transport_conv_data_t * conv_data = NULL;\r\nconv = find_conversation(frame, source_address, &lbttcp_null_address, PT_TCP, source_port, 0, 0);\r\nif (conv != NULL)\r\n{\r\nconv_data = (lbttcp_transport_conv_data_t *) conversation_get_proto_data(conv, proto_lbttcp);\r\nif (conv_data != NULL)\r\n{\r\nentry = (lbttcp_transport_t *) wmem_tree_lookup32(conv_data->session_tree, session_id);\r\n}\r\n}\r\nreturn (entry);\r\n}\r\nstatic lbttcp_transport_t * lbttcp_transport_create(const address * source_address, guint16 source_port, guint32 session_id)\r\n{\r\nlbttcp_transport_t * transport = NULL;\r\ntransport = wmem_new(wmem_file_scope(), lbttcp_transport_t);\r\ncopy_address_wmem(wmem_file_scope(), &(transport->source_address), source_address);\r\ntransport->source_port = source_port;\r\ntransport->session_id = session_id;\r\ntransport->channel = lbm_channel_assign(LBM_CHANNEL_TRANSPORT_LBTTCP);\r\ntransport->next_client_id = 1;\r\ntransport->client_list = wmem_list_new(wmem_file_scope());\r\nreturn (transport);\r\n}\r\nlbttcp_transport_t * lbttcp_transport_add(const address * source_address, guint16 source_port, guint32 session_id, guint32 frame)\r\n{\r\nlbttcp_transport_t * entry = NULL;\r\nconversation_t * conv = NULL;\r\nlbttcp_transport_conv_data_t * conv_data = NULL;\r\nconv = find_conversation(frame, source_address, &lbttcp_null_address, PT_TCP, source_port, 0, 0);\r\nif (conv == NULL)\r\n{\r\nconv = conversation_new(frame, source_address, &lbttcp_null_address, PT_TCP, source_port, 0, 0);\r\n}\r\nconv_data = (lbttcp_transport_conv_data_t *) conversation_get_proto_data(conv, proto_lbttcp);\r\nif (conv_data == NULL)\r\n{\r\nconv_data = wmem_new(wmem_file_scope(), lbttcp_transport_conv_data_t);\r\nconv_data->frame_tree = wmem_tree_new(wmem_file_scope());\r\nconv_data->session_tree = wmem_tree_new(wmem_file_scope());\r\nconversation_add_proto_data(conv, proto_lbttcp, (void *) conv_data);\r\n}\r\nentry = (lbttcp_transport_t *) wmem_tree_lookup32(conv_data->session_tree, session_id);\r\nif (entry != NULL)\r\n{\r\nreturn (entry);\r\n}\r\nentry = lbttcp_transport_create(source_address, source_port, session_id);\r\nwmem_tree_insert32(conv_data->session_tree, session_id, (void *) entry);\r\nwmem_tree_insert32(conv_data->frame_tree, frame, (void *) entry);\r\nreturn (entry);\r\n}\r\nstatic lbttcp_client_transport_t * lbttcp_client_transport_find(lbttcp_transport_t * transport, const address * receiver_address, guint16 receiver_port, guint32 frame)\r\n{\r\nlbttcp_client_transport_t * entry = NULL;\r\nconversation_t * client_conv = NULL;\r\nif (transport == NULL)\r\n{\r\nreturn (NULL);\r\n}\r\nclient_conv = find_conversation(frame, &(transport->source_address), receiver_address, PT_TCP, transport->source_port, receiver_port, 0);\r\nif (client_conv != NULL)\r\n{\r\nwmem_tree_t * session_tree = NULL;\r\nsession_tree = (wmem_tree_t *) conversation_get_proto_data(client_conv, proto_lbttcp);\r\nif (session_tree != NULL)\r\n{\r\nentry = (lbttcp_client_transport_t *) wmem_tree_lookup32(session_tree, transport->session_id);\r\n}\r\n}\r\nreturn (entry);\r\n}\r\nstatic lbttcp_client_transport_t * lbttcp_client_transport_add(lbttcp_transport_t * transport, const address * receiver_address, guint16 receiver_port, guint32 frame)\r\n{\r\nlbttcp_client_transport_t * entry;\r\nconversation_t * client_conv = NULL;\r\nwmem_tree_t * session_tree = NULL;\r\nif (transport == NULL)\r\n{\r\nreturn (NULL);\r\n}\r\nentry = lbttcp_client_transport_find(transport, receiver_address, receiver_port, frame);\r\nif (entry != NULL)\r\n{\r\nreturn (entry);\r\n}\r\nentry = wmem_new(wmem_file_scope(), lbttcp_client_transport_t);\r\ncopy_address_wmem(wmem_file_scope(), &(entry->receiver_address), receiver_address);\r\nentry->receiver_port = receiver_port;\r\nentry->id = transport->next_client_id++;\r\nclient_conv = find_conversation(frame, &(transport->source_address), receiver_address, PT_TCP, transport->source_port, receiver_port, 0);\r\nif (client_conv == NULL)\r\n{\r\nclient_conv = conversation_new(frame, &(transport->source_address), receiver_address, PT_TCP, transport->source_port, receiver_port, 0);\r\nsession_tree = wmem_tree_new(wmem_file_scope());\r\nconversation_add_proto_data(client_conv, proto_lbttcp, (void *) session_tree);\r\n}\r\nsession_tree = (wmem_tree_t *) conversation_get_proto_data(client_conv, proto_lbttcp);\r\nif (session_tree == NULL)\r\n{\r\nsession_tree = wmem_tree_new(wmem_file_scope());\r\nconversation_add_proto_data(client_conv, proto_lbttcp, (void *) session_tree);\r\n}\r\nwmem_tree_insert32(session_tree, transport->session_id, (void *) entry);\r\nwmem_list_append(transport->client_list, (void *) entry);\r\nreturn (entry);\r\n}\r\nchar * lbttcp_transport_source_string(const address * source_address, guint16 source_port, guint32 session_id)\r\n{\r\nchar * bufptr = NULL;\r\nif (session_id == 0)\r\n{\r\nbufptr = wmem_strdup_printf(wmem_file_scope(), "TCP:%s:%" G_GUINT16_FORMAT, address_to_str(wmem_packet_scope(), source_address), source_port);\r\n}\r\nelse\r\n{\r\nbufptr = wmem_strdup_printf(wmem_file_scope(), "TCP:%s:%" G_GUINT16_FORMAT ":%08x", address_to_str(wmem_packet_scope(), source_address), source_port, session_id);\r\n}\r\nreturn (bufptr);\r\n}\r\ngboolean lbttcp_transport_sid_find(const address * source_address, guint16 source_port, guint32 frame, guint32 * session_id)\r\n{\r\nconversation_t * conv = NULL;\r\nlbttcp_transport_conv_data_t * conv_data = NULL;\r\nlbttcp_transport_t * transport = NULL;\r\nconv = find_conversation(frame, source_address, &lbttcp_null_address, PT_TCP, source_port, 0, 0);\r\nif (conv == NULL)\r\n{\r\nreturn (FALSE);\r\n}\r\nconv_data = (lbttcp_transport_conv_data_t *) conversation_get_proto_data(conv, proto_lbttcp);\r\nif (conv_data == NULL)\r\n{\r\nreturn (FALSE);\r\n}\r\nif (conv_data->frame_tree == NULL)\r\n{\r\nreturn (FALSE);\r\n}\r\ntransport = (lbttcp_transport_t *)wmem_tree_lookup32_le(conv_data->frame_tree, frame);\r\nif (transport == NULL)\r\n{\r\nreturn (FALSE);\r\n}\r\n*session_id = transport->session_id;\r\nreturn (TRUE);\r\n}\r\nvoid lbttcp_transport_sid_add(const address * source_address, guint16 source_port, guint32 frame, guint32 session_id)\r\n{\r\nconversation_t * conv = NULL;\r\nlbttcp_transport_conv_data_t * conv_data = NULL;\r\nlbttcp_transport_t * transport = NULL;\r\nconv = find_conversation(frame, source_address, &lbttcp_null_address, PT_TCP, source_port, 0, 0);\r\nif (conv == NULL)\r\n{\r\nconv = conversation_new(frame, source_address, &lbttcp_null_address, PT_TCP, source_port, 0, 0);\r\n}\r\nconv_data = (lbttcp_transport_conv_data_t *) conversation_get_proto_data(conv, proto_lbttcp);\r\nif (conv_data == NULL)\r\n{\r\nconv_data = wmem_new(wmem_file_scope(), lbttcp_transport_conv_data_t);\r\nconv_data->frame_tree = wmem_tree_new(wmem_file_scope());\r\nconv_data->session_tree = wmem_tree_new(wmem_file_scope());\r\nconversation_add_proto_data(conv, proto_lbttcp, (void *) conv_data);\r\n}\r\ntransport = (lbttcp_transport_t *) wmem_tree_lookup32_le(conv_data->frame_tree, frame);\r\nif (transport != NULL)\r\n{\r\nif (transport->session_id != session_id)\r\n{\r\ntransport = NULL;\r\n}\r\n}\r\nif (transport == NULL)\r\n{\r\ntransport = lbttcp_transport_create(source_address, source_port, session_id);\r\nwmem_tree_insert32(conv_data->session_tree, session_id, (void *) transport);\r\nwmem_tree_insert32(conv_data->frame_tree, frame, (void *) transport);\r\n}\r\n}\r\nstatic gboolean lbttcp_tag_update_cb(void * record, char * * error_string)\r\n{\r\nlbttcp_tag_entry_t * tag = (lbttcp_tag_entry_t *)record;\r\nif (tag->name == NULL)\r\n{\r\n*error_string = g_strdup("Tag name can't be empty");\r\nreturn FALSE;\r\n}\r\nelse\r\n{\r\ng_strstrip(tag->name);\r\nif (tag->name[0] == 0)\r\n{\r\n*error_string = g_strdup("Tag name can't be empty");\r\nreturn FALSE;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic void * lbttcp_tag_copy_cb(void * destination, const void * source, size_t length _U_)\r\n{\r\nconst lbttcp_tag_entry_t * src = (const lbttcp_tag_entry_t *)source;\r\nlbttcp_tag_entry_t * dest = (lbttcp_tag_entry_t *)destination;\r\ndest->name = g_strdup(src->name);\r\ndest->source_port_low = src->source_port_low;\r\ndest->source_port_high = src->source_port_high;\r\ndest->request_port_low = src->request_port_low;\r\ndest->request_port_high = src->request_port_high;\r\ndest->store_port_low = src->store_port_low;\r\ndest->store_port_high = src->store_port_high;\r\nreturn (dest);\r\n}\r\nstatic void lbttcp_tag_free_cb(void * record)\r\n{\r\nlbttcp_tag_entry_t * tag = (lbttcp_tag_entry_t *)record;\r\nif (tag->name != NULL)\r\n{\r\ng_free(tag->name);\r\ntag->name = NULL;\r\n}\r\n}\r\nstatic const lbttcp_tag_entry_t * lbttcp_tag_locate(packet_info * pinfo)\r\n{\r\nguint idx;\r\nconst lbttcp_tag_entry_t * tag = NULL;\r\nif (!lbttcp_use_tag)\r\n{\r\nreturn (NULL);\r\n}\r\nfor (idx = 0; idx < lbttcp_tag_count; ++idx)\r\n{\r\ntag = &(lbttcp_tag_entry[idx]);\r\nif (((pinfo->srcport >= tag->source_port_low) && (pinfo->srcport <= tag->source_port_high))\r\n|| ((pinfo->destport >= tag->source_port_low) && (pinfo->destport <= tag->source_port_high))\r\n|| ((pinfo->srcport >= tag->request_port_low) && (pinfo->srcport <= tag->request_port_high))\r\n|| ((pinfo->destport >= tag->request_port_low) && (pinfo->destport <= tag->request_port_high))\r\n|| ((pinfo->srcport >= tag->store_port_low) && (pinfo->srcport <= tag->store_port_high))\r\n|| ((pinfo->destport >= tag->store_port_low) && (pinfo->destport <= tag->store_port_high)))\r\n{\r\nreturn (tag);\r\n}\r\n}\r\nreturn (NULL);\r\n}\r\nstatic char * lbttcp_tag_find(packet_info * pinfo)\r\n{\r\nconst lbttcp_tag_entry_t * tag = NULL;\r\nif (!lbttcp_use_tag)\r\n{\r\nreturn (NULL);\r\n}\r\ntag = lbttcp_tag_locate(pinfo);\r\nif (tag != NULL)\r\n{\r\nreturn tag->name;\r\n}\r\nreturn (NULL);\r\n}\r\nstatic gboolean lbttcp_packet_is_transport_source(packet_info * pinfo, const lbttcp_tag_entry_t * tag)\r\n{\r\ngboolean is_transport_source_packet = FALSE;\r\nif (tag == NULL)\r\n{\r\nif ((pinfo->srcport >= lbttcp_source_port_low) && (pinfo->srcport <= lbttcp_source_port_high))\r\n{\r\nis_transport_source_packet = TRUE;\r\n}\r\n}\r\nelse\r\n{\r\nif ((pinfo->srcport >= tag->source_port_low) && (pinfo->srcport <= tag->source_port_high))\r\n{\r\nis_transport_source_packet = TRUE;\r\n}\r\n}\r\nreturn (is_transport_source_packet);\r\n}\r\nstatic gboolean lbttcp_packet_is_transport_client(packet_info * pinfo, const lbttcp_tag_entry_t * tag)\r\n{\r\ngboolean is_transport_client_packet = FALSE;\r\nif (tag == NULL)\r\n{\r\nif ((pinfo->destport >= lbttcp_source_port_low) && (pinfo->destport <= lbttcp_source_port_high))\r\n{\r\nis_transport_client_packet = TRUE;\r\n}\r\n}\r\nelse\r\n{\r\nif ((pinfo->destport >= tag->source_port_low) && (pinfo->destport <= tag->source_port_high))\r\n{\r\nis_transport_client_packet = TRUE;\r\n}\r\n}\r\nreturn (is_transport_client_packet);\r\n}\r\nstatic guint get_lbttcp_pdu_length(packet_info * pinfo _U_, tvbuff_t * tvb,\r\nint offset, void *data _U_)\r\n{\r\nreturn lbmc_get_message_length(tvb, offset);\r\n}\r\nstatic int dissect_lbttcp_pdu(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * dissector_data _U_)\r\n{\r\nproto_tree * lbttcp_tree = NULL;\r\nproto_item * ti = NULL;\r\nchar * tag_name = NULL;\r\nint len_dissected;\r\nconst lbttcp_tag_entry_t * tag = NULL;\r\nguint64 channel = LBM_CHANNEL_NO_CHANNEL;\r\nguint32 client_id = 0;\r\ngboolean from_source = FALSE;\r\ngboolean transport_packet = FALSE;\r\nif (lbttcp_use_tag)\r\n{\r\ntag = lbttcp_tag_locate(pinfo);\r\ntag_name = lbttcp_tag_find(pinfo);\r\n}\r\nif (tag_name != NULL)\r\n{\r\nti = proto_tree_add_protocol_format(tree, proto_lbttcp, tvb, 0, -1, "LBT-TCP Protocol (Tag: %s)", tag_name);\r\n}\r\nelse\r\n{\r\nti = proto_tree_add_protocol_format(tree, proto_lbttcp, tvb, 0, -1, "LBT-TCP Protocol");\r\n}\r\nlbttcp_tree = proto_item_add_subtree(ti, ett_lbttcp);\r\nif (tag_name != NULL)\r\n{\r\nproto_item * item = NULL;\r\nitem = proto_tree_add_string(lbttcp_tree, hf_lbttcp_tag, tvb, 0, 0, tag_name);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nif (lbttcp_packet_is_transport_source(pinfo, tag))\r\n{\r\nfrom_source = TRUE;\r\ntransport_packet = TRUE;\r\n}\r\nelse if (lbttcp_packet_is_transport_client(pinfo, tag))\r\n{\r\nfrom_source = FALSE;\r\ntransport_packet = TRUE;\r\n}\r\nif (transport_packet)\r\n{\r\naddress source_address;\r\naddress client_address;\r\nguint16 srcport;\r\nguint16 clntport;\r\nguint32 sid = 0;\r\nlbttcp_transport_t * transport = NULL;\r\nlbttcp_client_transport_t * client = NULL;\r\nif (from_source)\r\n{\r\ncopy_address_shallow(&source_address, &(pinfo->src));\r\nsrcport = pinfo->srcport;\r\ncopy_address_shallow(&client_address, &(pinfo->dst));\r\nclntport = pinfo->destport;\r\n}\r\nelse\r\n{\r\ncopy_address_shallow(&source_address, &(pinfo->dst));\r\nsrcport = pinfo->destport;\r\ncopy_address_shallow(&client_address, &(pinfo->src));\r\nclntport = pinfo->srcport;\r\n}\r\ntransport = lbttcp_transport_find(&source_address, srcport, sid, pinfo->num);\r\nif (transport == NULL)\r\n{\r\nif (lbttcp_transport_sid_find(&source_address, srcport, pinfo->num, &sid))\r\n{\r\ntransport = lbttcp_transport_find(&source_address, srcport, sid, pinfo->num);\r\n}\r\n}\r\nif (transport != NULL)\r\n{\r\nchannel = transport->channel;\r\nclient = lbttcp_client_transport_find(transport, &client_address, clntport, pinfo->num);\r\nif (client == NULL)\r\n{\r\nclient = lbttcp_client_transport_add(transport, &client_address, clntport, pinfo->num);\r\n}\r\nif (client != NULL)\r\n{\r\nclient_id = client->id;\r\n}\r\n}\r\nelse\r\n{\r\nif (PINFO_FD_VISITED(pinfo))\r\n{\r\ntransport = lbttcp_transport_add(&source_address, srcport, 0, pinfo->num);\r\nif (transport != NULL)\r\n{\r\nchannel = transport->channel;\r\nclient = lbttcp_client_transport_add(transport, &client_address, clntport, pinfo->num);\r\nif (client != NULL)\r\n{\r\nclient_id = client->id;\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nif (from_source)\r\n{\r\nchannel = lbm_channel_assign_unknown_transport_source_lbttcp();\r\n}\r\nelse\r\n{\r\nchannel = lbm_channel_assign_unknown_transport_client_lbttcp();\r\n}\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nchannel = lbm_channel_assign_unknown_stream_tcp();\r\n}\r\nif (lbm_channel_is_known(channel))\r\n{\r\nproto_item * channel_item = NULL;\r\nproto_tree * channel_tree = NULL;\r\nchannel_item = proto_tree_add_item(lbttcp_tree, hf_lbttcp_channel, tvb, 0, 0, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(channel_item);\r\nchannel_tree = proto_item_add_subtree(channel_item, ett_lbttcp_channel);\r\nchannel_item = proto_tree_add_uint64(channel_tree, hf_lbttcp_channel_id, tvb, 0, 0, channel);\r\nPROTO_ITEM_SET_GENERATED(channel_item);\r\nchannel_item = proto_tree_add_uint(channel_tree, hf_lbttcp_channel_client, tvb, 0, 0, client_id);\r\nPROTO_ITEM_SET_GENERATED(channel_item);\r\n}\r\nlen_dissected = lbmc_dissect_lbmc_packet(tvb, 0, pinfo, tree, tag_name, channel);\r\nreturn (len_dissected);\r\n}\r\nstatic int dissect_lbttcp_real(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * data _U_)\r\n{\r\nchar * tag_name = NULL;\r\ncol_add_str(pinfo->cinfo, COL_PROTOCOL, "LBT-TCP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (lbttcp_use_tag)\r\n{\r\ntag_name = lbttcp_tag_find(pinfo);\r\n}\r\nif (tag_name != NULL)\r\n{\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "[Tag: %s]", tag_name);\r\n}\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\ntcp_dissect_pdus(tvb, pinfo, tree, TRUE, lbmc_get_minimum_length(),\r\nget_lbttcp_pdu_length, dissect_lbttcp_pdu, NULL);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int dissect_lbttcp(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * data)\r\n{\r\nif (!lbmc_test_lbmc_header(tvb, 0))\r\nreturn 0;\r\nreturn dissect_lbttcp_real(tvb, pinfo, tree, data);\r\n}\r\nstatic gboolean test_lbttcp_packet(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * data)\r\n{\r\nif ((pinfo->dst.type != AT_IPv4) || (pinfo->dst.len != 4))\r\n{\r\nreturn (FALSE);\r\n}\r\nif (lbttcp_use_tag)\r\n{\r\nif (lbttcp_tag_find(pinfo) != NULL)\r\n{\r\ndissect_lbttcp_real(tvb, pinfo, tree, data);\r\nreturn (TRUE);\r\n}\r\nelse\r\n{\r\nreturn (FALSE);\r\n}\r\n}\r\nif (!(((pinfo->srcport >= lbttcp_source_port_low) && (pinfo->srcport <= lbttcp_source_port_high))\r\n|| ((pinfo->destport >= lbttcp_source_port_low) && (pinfo->destport <= lbttcp_source_port_high))\r\n|| ((pinfo->srcport >= lbttcp_request_port_low) && (pinfo->srcport <= lbttcp_request_port_high))\r\n|| ((pinfo->destport >= lbttcp_request_port_low) && (pinfo->destport <= lbttcp_request_port_high))\r\n|| ((pinfo->srcport >= lbttcp_store_port_low) && (pinfo->srcport <= lbttcp_store_port_high))\r\n|| ((pinfo->destport >= lbttcp_store_port_low) && (pinfo->destport <= lbttcp_store_port_high))))\r\n{\r\nreturn (FALSE);\r\n}\r\nif (!lbmc_test_lbmc_header(tvb, 0))\r\nreturn FALSE;\r\ndissect_lbttcp_real(tvb, pinfo, tree, data);\r\nreturn (TRUE);\r\n}\r\nvoid proto_register_lbttcp(void)\r\n{\r\nstatic hf_register_info hf[] =\r\n{\r\n{ &hf_lbttcp_tag,\r\n{ "Tag", "lbttcp.tag", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbttcp_channel,\r\n{ "Channel", "lbttcp.channel", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbttcp_channel_id,\r\n{ "Channel ID", "lbttcp.channel.channel", FT_UINT64, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbttcp_channel_client,\r\n{ "Channel Client", "lbttcp.channel.client", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n};\r\nstatic gint * ett[] =\r\n{\r\n&ett_lbttcp,\r\n&ett_lbttcp_channel\r\n};\r\nmodule_t * lbttcp_module;\r\nuat_t * tag_uat;\r\nproto_lbttcp = proto_register_protocol("LBT TCP Protocol", "LBT-TCP", "lbttcp");\r\nproto_register_field_array(proto_lbttcp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nlbttcp_module = prefs_register_protocol_subtree("29West", proto_lbttcp, proto_reg_handoff_lbttcp);\r\nprefs_register_uint_preference(lbttcp_module,\r\n"source_port_low",\r\n"Source port range low (default " MAKESTRING(LBTTCP_DEFAULT_SOURCE_PORT_LOW)")",\r\n"Set the low end of the LBT-TCP source TCP port range (context transport_tcp_port_low)",\r\n10,\r\n&global_lbttcp_source_port_low);\r\nprefs_register_uint_preference(lbttcp_module,\r\n"source_port_high",\r\n"Source port range high (default " MAKESTRING(LBTTCP_DEFAULT_SOURCE_PORT_HIGH)")",\r\n"Set the high end of the LBT-TCP source TCP port range (context transport_tcp_port_high)",\r\n10,\r\n&global_lbttcp_source_port_high);\r\nprefs_register_uint_preference(lbttcp_module,\r\n"request_port_low",\r\n"Request port range low (default " MAKESTRING(LBTTCP_DEFAULT_REQUEST_PORT_LOW)")",\r\n"Set the low end of the LBT-TCP request TCP port range (context request_tcp_port_low)",\r\n10,\r\n&global_lbttcp_request_port_low);\r\nprefs_register_uint_preference(lbttcp_module,\r\n"request_port_high",\r\n"Request port range high (default " MAKESTRING(LBTTCP_DEFAULT_REQUEST_PORT_HIGH)")",\r\n"Set the high end of the LBT-TCP request TCP port range (context request_tcp_port_high)",\r\n10,\r\n&global_lbttcp_request_port_high);\r\nprefs_register_uint_preference(lbttcp_module,\r\n"store_port_low",\r\n"UME Store port range low (default " MAKESTRING(LBTTCP_DEFAULT_STORE_PORT_LOW)")",\r\n"Set the low end of the LBT-TCP UME Store TCP port range",\r\n10,\r\n&global_lbttcp_store_port_low);\r\nprefs_register_uint_preference(lbttcp_module,\r\n"store_port_high",\r\n"UME Store port range high (default " MAKESTRING(LBTTCP_DEFAULT_STORE_PORT_HIGH)")",\r\n"Set the high end of the LBT-TCP UME Store TCP port range",\r\n10,\r\n&global_lbttcp_store_port_high);\r\nprefs_register_bool_preference(lbttcp_module,\r\n"use_lbttcp_domain",\r\n"Use LBT-TCP tag table",\r\n"Use table of LBT-TCP tags to decode the packet instead of above values",\r\n&global_lbttcp_use_tag);\r\ntag_uat = uat_new("LBT-TCP tag definitions",\r\nsizeof(lbttcp_tag_entry_t),\r\n"lbttcp_domains",\r\nTRUE,\r\n(void * *)&lbttcp_tag_entry,\r\n&lbttcp_tag_count,\r\nUAT_AFFECTS_DISSECTION,\r\nNULL,\r\nlbttcp_tag_copy_cb,\r\nlbttcp_tag_update_cb,\r\nlbttcp_tag_free_cb,\r\nNULL,\r\nlbttcp_tag_array);\r\nprefs_register_uat_preference(lbttcp_module,\r\n"tnw_lbttcp_tags",\r\n"LBT-TCP Tags",\r\n"A table to define LBT-TCP tags",\r\ntag_uat);\r\n}\r\nvoid proto_reg_handoff_lbttcp(void)\r\n{\r\nstatic gboolean already_registered = FALSE;\r\nif (!already_registered)\r\n{\r\nlbttcp_dissector_handle = create_dissector_handle(dissect_lbttcp, proto_lbttcp);\r\ndissector_add_for_decode_as("tcp.port", lbttcp_dissector_handle);\r\nheur_dissector_add("tcp", test_lbttcp_packet, "LBT over TCP", "lbttcp_tcp", proto_lbttcp, HEURISTIC_ENABLE);\r\n}\r\nif (global_lbttcp_source_port_low <= global_lbttcp_source_port_high)\r\n{\r\nlbttcp_source_port_low = global_lbttcp_source_port_low;\r\nlbttcp_source_port_high = global_lbttcp_source_port_high;\r\n}\r\nif (global_lbttcp_request_port_low <= global_lbttcp_request_port_high)\r\n{\r\nlbttcp_request_port_low = global_lbttcp_request_port_low;\r\nlbttcp_request_port_high = global_lbttcp_request_port_high;\r\n}\r\nif (global_lbttcp_store_port_low <= global_lbttcp_store_port_high)\r\n{\r\nlbttcp_store_port_low = global_lbttcp_store_port_low;\r\nlbttcp_store_port_high = global_lbttcp_store_port_high;\r\n}\r\nlbttcp_use_tag = global_lbttcp_use_tag;\r\nalready_registered = TRUE;\r\n}
