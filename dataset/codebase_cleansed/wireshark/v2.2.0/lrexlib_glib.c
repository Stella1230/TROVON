static void minfo_free(TGrgx* ud) {\r\nif (ud->match_info)\r\ng_match_info_free (ud->match_info);\r\nud->match_info = NULL;\r\n}\r\nstatic void gerror_free(TGrgx* ud) {\r\nif (ud->error)\r\ng_error_free (ud->error);\r\nud->error = NULL;\r\n}\r\nstatic int getSubStartPos(TGrgx* ud, int n) {\r\nint start_pos = -1;\r\ng_match_info_fetch_pos (ud->match_info, n, &start_pos, NULL);\r\nreturn start_pos;\r\n}\r\nstatic int getSubEndPos(TGrgx* ud, int n) {\r\nint end_pos = -1;\r\ng_match_info_fetch_pos (ud->match_info, n, NULL, &end_pos);\r\nreturn end_pos;\r\n}\r\nstatic int getcflags (lua_State *L, int pos) {\r\nswitch (lua_type (L, pos)) {\r\ncase LUA_TNONE:\r\ncase LUA_TNIL:\r\nreturn ALG_CFLAGS_DFLT;\r\ncase LUA_TNUMBER: {\r\nint res = (int) lua_tointeger (L, pos);\r\nif ((res & ~G_REGEX_COMPILE_MASK) != 0) {\r\nreturn luaL_error (L, "GLib Regex compile flag is invalid");\r\n}\r\nreturn res;\r\n}\r\ncase LUA_TSTRING: {\r\nconst char *s = lua_tostring (L, pos);\r\nint res = 0, ch;\r\nwhile ((ch = *s++) != '\0') {\r\nif (ch == 'i') res |= G_REGEX_CASELESS;\r\nelse if (ch == 'm') res |= G_REGEX_MULTILINE;\r\nelse if (ch == 's') res |= G_REGEX_DOTALL;\r\nelse if (ch == 'x') res |= G_REGEX_EXTENDED;\r\nelse if (ch == 'U') res |= G_REGEX_UNGREEDY;\r\n}\r\nreturn (int)res;\r\n}\r\ndefault:\r\nreturn luaL_typerror (L, pos, "number or string");\r\n}\r\n}\r\nstatic int check_eflags(lua_State *L, const int idx, const int def) {\r\nint eflags = (int) luaL_optinteger (L, idx, def);\r\nif ((eflags & ~G_REGEX_MATCH_MASK) != 0) {\r\nreturn luaL_error (L, "GLib Regex match flag is invalid");\r\n}\r\nreturn eflags;\r\n}\r\nstatic int generate_error (lua_State *L, const TGrgx *ud, int errcode) {\r\nconst char *key = get_flag_key (gregex_error_flags, ud->error->code);\r\n(void) errcode;\r\nif (key)\r\nreturn luaL_error (L, "error G_REGEX_%s (%s)", key, ud->error->message);\r\nelse\r\nreturn luaL_error (L, "GLib Regex error: %s (code %d)", ud->error->message, ud->error->code);\r\n}\r\nstatic int compile_regex (lua_State *L, const TArgComp *argC, TGrgx **pud) {\r\nTGrgx *ud;\r\nud = (TGrgx*)lua_newuserdata (L, sizeof (TGrgx));\r\nmemset (ud, 0, sizeof (TGrgx));\r\nlua_pushvalue (L, ALG_ENVIRONINDEX);\r\nlua_setmetatable (L, -2);\r\nud->pr = g_regex_new (argC->pattern,\r\n(GRegexCompileFlags)(argC->cflags | G_REGEX_RAW), (GRegexMatchFlags)0, &ud->error);\r\nif (pud) *pud = ud;\r\nif (!ud->pr)\r\nreturn luaL_error (L, "%s (code: %d)", ud->error->message, ud->error->code);\r\nreturn 1;\r\n}\r\nstatic void checkarg_dfa_exec (lua_State *L, TArgExec *argE, TGrgx **ud) {\r\n*ud = check_ud (L);\r\nargE->text = luaL_checklstring (L, 2, &argE->textlen);\r\nargE->startoffset = get_startoffset (L, 3, argE->textlen);\r\nargE->eflags = ALG_GETEFLAGS (L, 4);\r\n}\r\nstatic int Gregex_dfa_exec (lua_State *L)\r\n{\r\nTArgExec argE;\r\nTGrgx *ud;\r\ngboolean res;\r\ncheckarg_dfa_exec (L, &argE, &ud);\r\ngerror_free (ud);\r\nres = g_regex_match_all_full (ud->pr, argE.text, (int)argE.textlen,\r\nargE.startoffset, (GRegexMatchFlags)argE.eflags, &ud->match_info, &ud->error);\r\nif (ALG_ISMATCH (res)) {\r\nint i, start_pos, end_pos;\r\nint max = g_match_info_get_match_count (ud->match_info);\r\ng_match_info_fetch_pos (ud->match_info, 0, &start_pos, NULL);\r\nlua_pushinteger (L, start_pos + 1);\r\nlua_newtable (L);\r\nfor (i=0; i<max; i++) {\r\ng_match_info_fetch_pos (ud->match_info, i, NULL, &end_pos);\r\nlua_pushinteger (L, end_pos);\r\nlua_rawseti (L, -2, i+1);\r\n}\r\nlua_pushinteger (L, max);\r\nminfo_free (ud);\r\nreturn 3;\r\n}\r\nelse if (g_match_info_is_partial_match(ud->match_info)) {\r\nlua_pushboolean(L,1);\r\nminfo_free (ud);\r\nreturn 1;\r\n}\r\nelse {\r\nminfo_free (ud);\r\nif (ALG_NOMATCH (res))\r\nreturn lua_pushnil (L), 1;\r\nelse\r\nreturn generate_error (L, ud, 0);\r\n}\r\n}\r\nstatic int gmatch_exec (TUserdata *ud, TArgExec *argE, int retry) {\r\nint eflags = retry ? (argE->eflags|G_REGEX_MATCH_NOTEMPTY|G_REGEX_MATCH_ANCHORED) : argE->eflags;\r\nminfo_free (ud);\r\ngerror_free (ud);\r\nreturn g_regex_match_full (ud->pr, argE->text, argE->textlen,\r\nargE->startoffset, (GRegexMatchFlags)eflags, &ud->match_info, &ud->error);\r\n}\r\nstatic int gmatch_exec (TUserdata *ud, TArgExec *argE) {\r\nminfo_free (ud);\r\ngerror_free (ud);\r\nreturn g_regex_match_full (ud->pr, argE->text, argE->textlen,\r\nargE->startoffset, (GRegexMatchFlags)argE->eflags, &ud->match_info, &ud->error);\r\n}\r\nstatic void gmatch_pushsubject (lua_State *L, TArgExec *argE) {\r\nlua_pushlstring (L, argE->text, argE->textlen);\r\n}\r\nstatic int findmatch_exec (TGrgx *ud, TArgExec *argE) {\r\nminfo_free (ud);\r\ngerror_free (ud);\r\nreturn g_regex_match_full (ud->pr, argE->text, argE->textlen,\r\nargE->startoffset, (GRegexMatchFlags)argE->eflags, &ud->match_info, &ud->error);\r\n}\r\nstatic int gsub_exec (TGrgx *ud, TArgExec *argE, int st, int retry) {\r\nint eflags = retry ? (argE->eflags|G_REGEX_MATCH_NOTEMPTY|G_REGEX_MATCH_ANCHORED) : argE->eflags;\r\nminfo_free (ud);\r\ngerror_free (ud);\r\nreturn g_regex_match_full (ud->pr, argE->text, argE->textlen,\r\nst, (GRegexMatchFlags)eflags, &ud->match_info, &ud->error);\r\n}\r\nstatic int gsub_exec (TGrgx *ud, TArgExec *argE, int st) {\r\nminfo_free (ud);\r\ngerror_free (ud);\r\nreturn g_regex_match_full (ud->pr, argE->text, argE->textlen,\r\nst, (GRegexMatchFlags)argE->eflags, &ud->match_info, &ud->error);\r\n}\r\nstatic int split_exec (TGrgx *ud, TArgExec *argE, int offset) {\r\nminfo_free (ud);\r\ngerror_free (ud);\r\nreturn g_regex_match_full (ud->pr, argE->text, argE->textlen, offset,\r\n(GRegexMatchFlags)argE->eflags, &ud->match_info, &ud->error);\r\n}\r\nstatic int Gregex_gc (lua_State *L) {\r\nTGrgx *ud = check_ud (L);\r\nif (ud->freed == 0) {\r\nud->freed = 1;\r\nif (ud->pr) g_regex_unref (ud->pr);\r\nminfo_free (ud);\r\ngerror_free (ud);\r\n}\r\nreturn 0;\r\n}\r\nstatic int Gregex_tostring (lua_State *L) {\r\nTGrgx *ud = check_ud (L);\r\nif (ud->freed == 0)\r\nlua_pushfstring (L, "%s (%p)", REX_TYPENAME, (void*)ud);\r\nelse\r\nlua_pushfstring (L, "%s (deleted)", REX_TYPENAME);\r\nreturn 1;\r\n}\r\nstatic int Gregex_version (lua_State *L) {\r\nlua_pushfstring (L, "%d.%d.%d", GLIB_MAJOR_VERSION, GLIB_MINOR_VERSION, GLIB_MICRO_VERSION);\r\nreturn 1;\r\n}\r\nREX_API int REX_OPENLIB (lua_State *L) {\r\nalg_register(L, r_methods, r_functions, "GLib Regex");\r\nreturn 1;\r\n}
