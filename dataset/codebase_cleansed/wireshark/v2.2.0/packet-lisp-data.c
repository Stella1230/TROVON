static int\r\ndissect_lisp_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\ngint offset = 0;\r\nguint8 flags;\r\nguint8 ip_ver;\r\ntvbuff_t *next_tvb;\r\nproto_item *ti;\r\nproto_item *tif;\r\nproto_tree *lisp_data_tree;\r\nproto_tree *lisp_data_flags_tree;\r\nif (pinfo->destport == LISP_CONTROL_PORT)\r\nreturn call_dissector(lisp_handle, tvb, pinfo, tree);\r\nif (tvb_reported_length(tvb) < LISP_DATA_HEADER_LEN)\r\nreturn 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "LISP");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "LISP Encapsulation Header");\r\nti = proto_tree_add_item(tree, proto_lisp_data, tvb, 0,\r\nLISP_DATA_HEADER_LEN, ENC_NA);\r\nlisp_data_tree = proto_item_add_subtree(ti, ett_lisp_data);\r\ntif = proto_tree_add_item(lisp_data_tree,\r\nhf_lisp_data_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nlisp_data_flags_tree = proto_item_add_subtree(tif, ett_lisp_data_flags);\r\nproto_tree_add_item(lisp_data_flags_tree,\r\nhf_lisp_data_flags_nonce, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(lisp_data_flags_tree,\r\nhf_lisp_data_flags_lsb, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(lisp_data_flags_tree,\r\nhf_lisp_data_flags_enr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(lisp_data_flags_tree,\r\nhf_lisp_data_flags_mv, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(lisp_data_flags_tree,\r\nhf_lisp_data_flags_iid, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(lisp_data_flags_tree,\r\nhf_lisp_data_flags_res, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nflags = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\nif (flags&LISP_DATA_FLAG_E && !(flags&LISP_DATA_FLAG_N)) {\r\nexpert_add_info(pinfo, tif, &ei_lisp_data_flags_en_invalid);\r\n}\r\nif (flags&LISP_DATA_FLAG_N) {\r\nif (flags&LISP_DATA_FLAG_V) {\r\nexpert_add_info(pinfo, tif, &ei_lisp_data_flags_nv_invalid);\r\n}\r\nproto_tree_add_item(lisp_data_tree,\r\nhf_lisp_data_nonce, tvb, offset, 3, ENC_BIG_ENDIAN);\r\n} else {\r\nif (flags&LISP_DATA_FLAG_V) {\r\nproto_item *tiv;\r\nproto_tree *lisp_data_mapver_tree;\r\ntiv = proto_tree_add_item(lisp_data_tree,\r\nhf_lisp_data_mapver, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nlisp_data_mapver_tree = proto_item_add_subtree(tiv, ett_lisp_data_mapver);\r\nproto_tree_add_item(lisp_data_mapver_tree,\r\nhf_lisp_data_srcmapver, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(lisp_data_mapver_tree,\r\nhf_lisp_data_dstmapver, tvb, offset, 3, ENC_BIG_ENDIAN);\r\n}\r\n}\r\noffset += 3;\r\nif (flags&LISP_DATA_FLAG_I) {\r\nproto_tree_add_item(lisp_data_tree,\r\nhf_lisp_data_iid, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\nif (flags&LISP_DATA_FLAG_L) {\r\nproto_tree_add_item(lisp_data_tree,\r\nhf_lisp_data_lsb8, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\n} else {\r\nif (flags&LISP_DATA_FLAG_L) {\r\nproto_tree_add_item(lisp_data_tree,\r\nhf_lisp_data_lsb, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nnext_tvb = tvb_new_subset_remaining(tvb, LISP_DATA_HEADER_LEN);\r\nip_ver = tvb_get_bits8(next_tvb, 0, 4);\r\nswitch (ip_ver) {\r\ncase 4:\r\ncall_dissector(ipv4_handle, next_tvb, pinfo, tree);\r\nreturn tvb_reported_length(tvb);\r\ncase 6:\r\ncall_dissector(ipv6_handle, next_tvb, pinfo, tree);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nreturn LISP_DATA_HEADER_LEN;\r\n}\r\nvoid\r\nproto_register_lisp_data(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_lisp_data_flags,\r\n{ "Flags", "lisp-data.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, "LISP Data Header Flags", HFILL }},\r\n{ &hf_lisp_data_flags_nonce,\r\n{ "N bit (Nonce present)", "lisp-data.flags.nonce",\r\nFT_BOOLEAN, LISP_DATA_FLAGS_WIDTH, TFS(&tfs_set_notset),\r\nLISP_DATA_FLAG_N, NULL, HFILL }},\r\n{ &hf_lisp_data_flags_lsb,\r\n{ "L bit (Locator-Status-Bits field enabled)", "lisp-data.flags.lsb",\r\nFT_BOOLEAN, LISP_DATA_FLAGS_WIDTH, TFS(&tfs_set_notset),\r\nLISP_DATA_FLAG_L, NULL, HFILL }},\r\n{ &hf_lisp_data_flags_enr,\r\n{ "E bit (Echo-Nonce-Request)", "lisp-data.flags.enr",\r\nFT_BOOLEAN, LISP_DATA_FLAGS_WIDTH, TFS(&tfs_set_notset),\r\nLISP_DATA_FLAG_E, NULL, HFILL }},\r\n{ &hf_lisp_data_flags_mv,\r\n{ "V bit (Map-Version present)", "lisp-data.flags.mv",\r\nFT_BOOLEAN, LISP_DATA_FLAGS_WIDTH, TFS(&tfs_set_notset),\r\nLISP_DATA_FLAG_V, NULL, HFILL }},\r\n{ &hf_lisp_data_flags_iid,\r\n{ "I bit (Instance ID present)", "lisp-data.flags.iid",\r\nFT_BOOLEAN, LISP_DATA_FLAGS_WIDTH, TFS(&tfs_set_notset),\r\nLISP_DATA_FLAG_I, NULL, HFILL }},\r\n{ &hf_lisp_data_flags_res,\r\n{ "Reserved", "lisp-data.flags.res",\r\nFT_UINT8, BASE_HEX, NULL,\r\nLISP_DATA_FLAG_RES, "Must be zero", HFILL }},\r\n{ &hf_lisp_data_nonce,\r\n{ "Nonce", "lisp-data.nonce",\r\nFT_UINT24, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_lisp_data_mapver,\r\n{ "Map-Version", "lisp-data.mapver",\r\nFT_UINT24, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_lisp_data_srcmapver,\r\n{ "Source Map-Version", "lisp-data.srcmapver",\r\nFT_UINT24, BASE_DEC, NULL, 0xFFF000, NULL, HFILL }},\r\n{ &hf_lisp_data_dstmapver,\r\n{ "Destination Map-Version", "lisp-data.dstmapver",\r\nFT_UINT24, BASE_DEC, NULL, 0x000FFF, NULL, HFILL }},\r\n{ &hf_lisp_data_iid,\r\n{ "Instance ID", "lisp-data.iid",\r\nFT_UINT24, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_lisp_data_lsb,\r\n{ "Locator-Status-Bits", "lisp-data.lsb",\r\nFT_UINT32, BASE_HEX, NULL, 0xFFFFFFFF, NULL, HFILL }},\r\n{ &hf_lisp_data_lsb8,\r\n{ "Locator-Status-Bits", "lisp-data.lsb8",\r\nFT_UINT8, BASE_HEX, NULL, 0xFF, NULL, HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_lisp_data,\r\n&ett_lisp_data_flags,\r\n&ett_lisp_data_mapver\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_lisp_data_flags_en_invalid, { "lisp-data.flags.en_invalid", PI_PROTOCOL, PI_WARN, "Invalid flag combination: if E is set, N MUST be set", EXPFILL }},\r\n{ &ei_lisp_data_flags_nv_invalid, { "lisp-data.flags.nv_invalid", PI_PROTOCOL, PI_WARN, "Invalid flag combination: N and V can't be set both", EXPFILL }},\r\n};\r\nexpert_module_t* expert_lisp_data;\r\nproto_lisp_data = proto_register_protocol("Locator/ID Separation Protocol (Data)",\r\n"LISP Data", "lisp-data");\r\nproto_register_field_array(proto_lisp_data, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_lisp_data = expert_register_protocol(proto_lisp_data);\r\nexpert_register_field_array(expert_lisp_data, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_lisp_data(void)\r\n{\r\ndissector_handle_t lisp_data_handle;\r\nlisp_data_handle = create_dissector_handle(dissect_lisp_data,\r\nproto_lisp_data);\r\ndissector_add_uint("udp.port", LISP_DATA_PORT, lisp_data_handle);\r\nipv4_handle = find_dissector_add_dependency("ip", proto_lisp_data);\r\nipv6_handle = find_dissector_add_dependency("ipv6", proto_lisp_data);\r\nlisp_handle = find_dissector_add_dependency("lisp", proto_lisp_data);\r\n}
