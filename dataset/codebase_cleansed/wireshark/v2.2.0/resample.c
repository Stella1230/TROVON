static void *speex_alloc (size_t size) {return g_malloc0(size);}\r\nstatic void *speex_realloc (void *ptr, size_t size) {return g_realloc(ptr, size);}\r\nstatic void speex_free (void *ptr) {g_free(ptr);}\r\nstatic double compute_func(float x, const struct FuncDef *func)\r\n{\r\nfloat y, frac;\r\ndouble interp[4];\r\nint ind;\r\ny = x*func->oversample;\r\nind = (int)floor(y);\r\nfrac = (y-ind);\r\ninterp[3] = -0.1666666667*frac + 0.1666666667*(frac*frac*frac);\r\ninterp[2] = frac + 0.5*(frac*frac) - 0.5*(frac*frac*frac);\r\ninterp[0] = -0.3333333333*frac + 0.5*(frac*frac) - 0.1666666667*(frac*frac*frac);\r\ninterp[1] = 1.f-interp[3]-interp[2]-interp[0];\r\nreturn interp[0]*func->table[ind] + interp[1]*func->table[ind+1] + interp[2]*func->table[ind+2] + interp[3]*func->table[ind+3];\r\n}\r\nstatic spx_word16_t sinc(float cutoff, float x, int N, const struct FuncDef *window_func)\r\n{\r\nfloat xx = x * cutoff;\r\nif (fabs(x)<1e-6f)\r\nreturn WORD2INT(32768.*cutoff);\r\nelse if (fabs(x) > .5f*N)\r\nreturn 0;\r\nreturn WORD2INT(32768.*cutoff*sin(M_PI*xx)/(M_PI*xx) * compute_func(fabs(2.*x/N), window_func));\r\n}\r\nstatic spx_word16_t sinc(float cutoff, float x, int N, const struct FuncDef *window_func)\r\n{\r\nfloat xx = x * cutoff;\r\nif (fabs(x)<1e-6)\r\nreturn cutoff;\r\nelse if (fabs(x) > .5*N)\r\nreturn 0;\r\nreturn (spx_word16_t)(cutoff*sin(M_PI*xx)/(M_PI*xx) * compute_func((float)fabs(2.*x/N), window_func));\r\n}\r\nstatic void cubic_coef(spx_word16_t x, spx_word16_t interp[4])\r\n{\r\nspx_word16_t x2, x3;\r\nx2 = MULT16_16_P15(x, x);\r\nx3 = MULT16_16_P15(x, x2);\r\ninterp[0] = PSHR32(MULT16_16(QCONST16(-0.16667f, 15),x) + MULT16_16(QCONST16(0.16667f, 15),x3),15);\r\ninterp[1] = EXTRACT16(EXTEND32(x) + SHR32(SUB32(EXTEND32(x2),EXTEND32(x3)),1));\r\ninterp[3] = PSHR32(MULT16_16(QCONST16(-0.33333f, 15),x) + MULT16_16(QCONST16(.5f,15),x2) - MULT16_16(QCONST16(0.16667f, 15),x3),15);\r\ninterp[2] = Q15_ONE-interp[0]-interp[1]-interp[3];\r\nif (interp[2]<32767)\r\ninterp[2]+=1;\r\n}\r\nstatic void cubic_coef(spx_word16_t frac, spx_word16_t interp[4])\r\n{\r\ninterp[0] = -0.16667f*frac + 0.16667f*frac*frac*frac;\r\ninterp[1] = frac + 0.5f*frac*frac - 0.5f*frac*frac*frac;\r\ninterp[3] = -0.33333f*frac + 0.5f*frac*frac - 0.16667f*frac*frac*frac;\r\ninterp[2] = (spx_word16_t)(1.-interp[0]-interp[1]-interp[3]);\r\n}\r\nstatic int resampler_basic_direct_single(SpeexResamplerState *st, spx_uint32_t channel_index, const spx_word16_t *in, spx_uint32_t *in_len, spx_word16_t *out, spx_uint32_t *out_len)\r\n{\r\nconst int N = st->filt_len;\r\nint out_sample = 0;\r\nint last_sample = st->last_sample[channel_index];\r\nspx_uint32_t samp_frac_num = st->samp_frac_num[channel_index];\r\nconst spx_word16_t *sinc_table = st->sinc_table;\r\nconst int out_stride = st->out_stride;\r\nconst int int_advance = st->int_advance;\r\nconst int frac_advance = st->frac_advance;\r\nconst spx_uint32_t den_rate = st->den_rate;\r\nspx_word32_t sum;\r\nwhile (!(last_sample >= (spx_int32_t)*in_len || out_sample >= (spx_int32_t)*out_len))\r\n{\r\nconst spx_word16_t *sinct = & sinc_table[samp_frac_num*N];\r\nconst spx_word16_t *iptr = & in[last_sample];\r\n#ifndef OVERRIDE_INNER_PRODUCT_SINGLE\r\nint j;\r\nsum = 0;\r\nfor(j=0;j<N;j++) sum += MULT16_16(sinct[j], iptr[j]);\r\nsum = SATURATE32PSHR(sum, 15, 32767);\r\n#else\r\nsum = inner_product_single(sinct, iptr, N);\r\n#endif\r\nout[out_stride * out_sample++] = sum;\r\nlast_sample += int_advance;\r\nsamp_frac_num += frac_advance;\r\nif (samp_frac_num >= den_rate)\r\n{\r\nsamp_frac_num -= den_rate;\r\nlast_sample++;\r\n}\r\n}\r\nst->last_sample[channel_index] = last_sample;\r\nst->samp_frac_num[channel_index] = samp_frac_num;\r\nreturn out_sample;\r\n}\r\nstatic int resampler_basic_direct_double(SpeexResamplerState *st, spx_uint32_t channel_index, const spx_word16_t *in, spx_uint32_t *in_len, spx_word16_t *out, spx_uint32_t *out_len)\r\n{\r\nconst int N = st->filt_len;\r\nint out_sample = 0;\r\nint last_sample = st->last_sample[channel_index];\r\nspx_uint32_t samp_frac_num = st->samp_frac_num[channel_index];\r\nconst spx_word16_t *sinc_table = st->sinc_table;\r\nconst int out_stride = st->out_stride;\r\nconst int int_advance = st->int_advance;\r\nconst int frac_advance = st->frac_advance;\r\nconst spx_uint32_t den_rate = st->den_rate;\r\ndouble sum;\r\nwhile (!(last_sample >= (spx_int32_t)*in_len || out_sample >= (spx_int32_t)*out_len))\r\n{\r\nconst spx_word16_t *sinct = & sinc_table[samp_frac_num*N];\r\nconst spx_word16_t *iptr = & in[last_sample];\r\n#ifndef OVERRIDE_INNER_PRODUCT_DOUBLE\r\nint j;\r\ndouble accum[4] = {0,0,0,0};\r\nfor(j=0;j<N;j+=4) {\r\naccum[0] += sinct[j]*iptr[j];\r\naccum[1] += sinct[j+1]*iptr[j+1];\r\naccum[2] += sinct[j+2]*iptr[j+2];\r\naccum[3] += sinct[j+3]*iptr[j+3];\r\n}\r\nsum = accum[0] + accum[1] + accum[2] + accum[3];\r\n#else\r\nsum = inner_product_double(sinct, iptr, N);\r\n#endif\r\nout[out_stride * out_sample++] = PSHR32(sum, 15);\r\nlast_sample += int_advance;\r\nsamp_frac_num += frac_advance;\r\nif (samp_frac_num >= den_rate)\r\n{\r\nsamp_frac_num -= den_rate;\r\nlast_sample++;\r\n}\r\n}\r\nst->last_sample[channel_index] = last_sample;\r\nst->samp_frac_num[channel_index] = samp_frac_num;\r\nreturn out_sample;\r\n}\r\nstatic int resampler_basic_interpolate_single(SpeexResamplerState *st, spx_uint32_t channel_index, const spx_word16_t *in, spx_uint32_t *in_len, spx_word16_t *out, spx_uint32_t *out_len)\r\n{\r\nconst int N = st->filt_len;\r\nint out_sample = 0;\r\nint last_sample = st->last_sample[channel_index];\r\nspx_uint32_t samp_frac_num = st->samp_frac_num[channel_index];\r\nconst int out_stride = st->out_stride;\r\nconst int int_advance = st->int_advance;\r\nconst int frac_advance = st->frac_advance;\r\nconst spx_uint32_t den_rate = st->den_rate;\r\nspx_word32_t sum;\r\nwhile (!(last_sample >= (spx_int32_t)*in_len || out_sample >= (spx_int32_t)*out_len))\r\n{\r\nconst spx_word16_t *iptr = & in[last_sample];\r\nconst int offset = samp_frac_num*st->oversample/st->den_rate;\r\n#ifdef FIXED_POINT\r\nconst spx_word16_t frac = PDIV32(SHL32((samp_frac_num*st->oversample) % st->den_rate,15),st->den_rate);\r\n#else\r\nconst spx_word16_t frac = ((float)((samp_frac_num*st->oversample) % st->den_rate))/st->den_rate;\r\n#endif\r\nspx_word16_t interp[4];\r\n#ifndef OVERRIDE_INTERPOLATE_PRODUCT_SINGLE\r\nint j;\r\nspx_word32_t accum[4] = {0,0,0,0};\r\nfor(j=0;j<N;j++) {\r\nconst spx_word16_t curr_in=iptr[j];\r\naccum[0] += MULT16_16(curr_in,st->sinc_table[4+(j+1)*st->oversample-offset-2]);\r\naccum[1] += MULT16_16(curr_in,st->sinc_table[4+(j+1)*st->oversample-offset-1]);\r\naccum[2] += MULT16_16(curr_in,st->sinc_table[4+(j+1)*st->oversample-offset]);\r\naccum[3] += MULT16_16(curr_in,st->sinc_table[4+(j+1)*st->oversample-offset+1]);\r\n}\r\ncubic_coef(frac, interp);\r\nsum = MULT16_32_Q15(interp[0],SHR32(accum[0], 1)) + MULT16_32_Q15(interp[1],SHR32(accum[1], 1)) + MULT16_32_Q15(interp[2],SHR32(accum[2], 1)) + MULT16_32_Q15(interp[3],SHR32(accum[3], 1));\r\nsum = SATURATE32PSHR(sum, 15, 32767);\r\n#else\r\ncubic_coef(frac, interp);\r\nsum = interpolate_product_single(iptr, st->sinc_table + st->oversample + 4 - offset - 2, N, st->oversample, interp);\r\n#endif\r\nout[out_stride * out_sample++] = sum;\r\nlast_sample += int_advance;\r\nsamp_frac_num += frac_advance;\r\nif (samp_frac_num >= den_rate)\r\n{\r\nsamp_frac_num -= den_rate;\r\nlast_sample++;\r\n}\r\n}\r\nst->last_sample[channel_index] = last_sample;\r\nst->samp_frac_num[channel_index] = samp_frac_num;\r\nreturn out_sample;\r\n}\r\nstatic int resampler_basic_interpolate_double(SpeexResamplerState *st, spx_uint32_t channel_index, const spx_word16_t *in, spx_uint32_t *in_len, spx_word16_t *out, spx_uint32_t *out_len)\r\n{\r\nconst int N = st->filt_len;\r\nint out_sample = 0;\r\nint last_sample = st->last_sample[channel_index];\r\nspx_uint32_t samp_frac_num = st->samp_frac_num[channel_index];\r\nconst int out_stride = st->out_stride;\r\nconst int int_advance = st->int_advance;\r\nconst int frac_advance = st->frac_advance;\r\nconst spx_uint32_t den_rate = st->den_rate;\r\nspx_word32_t sum;\r\nwhile (!(last_sample >= (spx_int32_t)*in_len || out_sample >= (spx_int32_t)*out_len))\r\n{\r\nconst spx_word16_t *iptr = & in[last_sample];\r\nconst int offset = samp_frac_num*st->oversample/st->den_rate;\r\n#ifdef FIXED_POINT\r\nconst spx_word16_t frac = PDIV32(SHL32((samp_frac_num*st->oversample) % st->den_rate,15),st->den_rate);\r\n#else\r\nconst spx_word16_t frac = ((float)((samp_frac_num*st->oversample) % st->den_rate))/st->den_rate;\r\n#endif\r\nspx_word16_t interp[4];\r\n#ifndef OVERRIDE_INTERPOLATE_PRODUCT_DOUBLE\r\nint j;\r\ndouble accum[4] = {0,0,0,0};\r\nfor(j=0;j<N;j++) {\r\nconst double curr_in=iptr[j];\r\naccum[0] += MULT16_16(curr_in,st->sinc_table[4+(j+1)*st->oversample-offset-2]);\r\naccum[1] += MULT16_16(curr_in,st->sinc_table[4+(j+1)*st->oversample-offset-1]);\r\naccum[2] += MULT16_16(curr_in,st->sinc_table[4+(j+1)*st->oversample-offset]);\r\naccum[3] += MULT16_16(curr_in,st->sinc_table[4+(j+1)*st->oversample-offset+1]);\r\n}\r\ncubic_coef(frac, interp);\r\nsum = MULT16_32_Q15(interp[0],accum[0]) + MULT16_32_Q15(interp[1],accum[1]) + MULT16_32_Q15(interp[2],accum[2]) + MULT16_32_Q15(interp[3],accum[3]);\r\n#else\r\ncubic_coef(frac, interp);\r\nsum = interpolate_product_double(iptr, st->sinc_table + st->oversample + 4 - offset - 2, N, st->oversample, interp);\r\n#endif\r\nout[out_stride * out_sample++] = PSHR32(sum,15);\r\nlast_sample += int_advance;\r\nsamp_frac_num += frac_advance;\r\nif (samp_frac_num >= den_rate)\r\n{\r\nsamp_frac_num -= den_rate;\r\nlast_sample++;\r\n}\r\n}\r\nst->last_sample[channel_index] = last_sample;\r\nst->samp_frac_num[channel_index] = samp_frac_num;\r\nreturn out_sample;\r\n}\r\nstatic int resampler_basic_zero(SpeexResamplerState *st, spx_uint32_t channel_index, const spx_word16_t *in _U_, spx_uint32_t *in_len, spx_word16_t *out, spx_uint32_t *out_len)\r\n{\r\nint out_sample = 0;\r\nint last_sample = st->last_sample[channel_index];\r\nspx_uint32_t samp_frac_num = st->samp_frac_num[channel_index];\r\nconst int out_stride = st->out_stride;\r\nconst int int_advance = st->int_advance;\r\nconst int frac_advance = st->frac_advance;\r\nconst spx_uint32_t den_rate = st->den_rate;\r\nwhile (!(last_sample >= (spx_int32_t)*in_len || out_sample >= (spx_int32_t)*out_len))\r\n{\r\nout[out_stride * out_sample++] = 0;\r\nlast_sample += int_advance;\r\nsamp_frac_num += frac_advance;\r\nif (samp_frac_num >= den_rate)\r\n{\r\nsamp_frac_num -= den_rate;\r\nlast_sample++;\r\n}\r\n}\r\nst->last_sample[channel_index] = last_sample;\r\nst->samp_frac_num[channel_index] = samp_frac_num;\r\nreturn out_sample;\r\n}\r\nstatic int update_filter(SpeexResamplerState *st)\r\n{\r\nspx_uint32_t old_length = st->filt_len;\r\nspx_uint32_t old_alloc_size = st->mem_alloc_size;\r\nint use_direct;\r\nspx_uint32_t min_sinc_table_length;\r\nspx_uint32_t min_alloc_size;\r\nst->int_advance = st->num_rate/st->den_rate;\r\nst->frac_advance = st->num_rate%st->den_rate;\r\nst->oversample = quality_map[st->quality].oversample;\r\nst->filt_len = quality_map[st->quality].base_length;\r\nif (st->num_rate > st->den_rate)\r\n{\r\nst->cutoff = quality_map[st->quality].downsample_bandwidth * st->den_rate / st->num_rate;\r\nst->filt_len = st->filt_len*st->num_rate / st->den_rate;\r\nst->filt_len = ((st->filt_len-1)&(~0x7))+8;\r\nif (2*st->den_rate < st->num_rate)\r\nst->oversample >>= 1;\r\nif (4*st->den_rate < st->num_rate)\r\nst->oversample >>= 1;\r\nif (8*st->den_rate < st->num_rate)\r\nst->oversample >>= 1;\r\nif (16*st->den_rate < st->num_rate)\r\nst->oversample >>= 1;\r\nif (st->oversample < 1)\r\nst->oversample = 1;\r\n} else {\r\nst->cutoff = quality_map[st->quality].upsample_bandwidth;\r\n}\r\n#ifdef RESAMPLE_FULL_SINC_TABLE\r\nuse_direct = 1;\r\nif (INT_MAX/sizeof(spx_word16_t)/st->den_rate < st->filt_len)\r\ngoto fail;\r\n#else\r\nuse_direct = st->filt_len*st->den_rate <= st->filt_len*st->oversample+8\r\n&& INT_MAX/(spx_uint32_t)sizeof(spx_word16_t)/st->den_rate >= st->filt_len;\r\n#endif\r\nif (use_direct)\r\n{\r\nmin_sinc_table_length = st->filt_len*st->den_rate;\r\n} else {\r\nif ((INT_MAX/(spx_uint32_t)sizeof(spx_word16_t)-8)/st->oversample < st->filt_len)\r\ngoto fail;\r\nmin_sinc_table_length = st->filt_len*st->oversample+8;\r\n}\r\nif (st->sinc_table_length < min_sinc_table_length)\r\n{\r\nspx_word16_t *sinc_table = (spx_word16_t *)speex_realloc(st->sinc_table,min_sinc_table_length*sizeof(spx_word16_t));\r\nif (!sinc_table)\r\ngoto fail;\r\nst->sinc_table = sinc_table;\r\nst->sinc_table_length = min_sinc_table_length;\r\n}\r\nif (use_direct)\r\n{\r\nspx_uint32_t i;\r\nfor (i=0;i<st->den_rate;i++)\r\n{\r\nspx_uint32_t j;\r\nfor (j=0;j<st->filt_len;j++)\r\n{\r\nst->sinc_table[i*st->filt_len+j] = sinc(st->cutoff,((j-(spx_int32_t)st->filt_len/2+1)-((float)i)/st->den_rate), st->filt_len, quality_map[st->quality].window_func);\r\n}\r\n}\r\n#ifdef FIXED_POINT\r\nst->resampler_ptr = resampler_basic_direct_single;\r\n#else\r\nif (st->quality>8)\r\nst->resampler_ptr = resampler_basic_direct_double;\r\nelse\r\nst->resampler_ptr = resampler_basic_direct_single;\r\n#endif\r\n} else {\r\nspx_int32_t i;\r\nfor (i=-4;i<(spx_int32_t)(st->oversample*st->filt_len+4);i++)\r\nst->sinc_table[i+4] = sinc(st->cutoff,(i/(float)st->oversample - st->filt_len/2), st->filt_len, quality_map[st->quality].window_func);\r\n#ifdef FIXED_POINT\r\nst->resampler_ptr = resampler_basic_interpolate_single;\r\n#else\r\nif (st->quality>8)\r\nst->resampler_ptr = resampler_basic_interpolate_double;\r\nelse\r\nst->resampler_ptr = resampler_basic_interpolate_single;\r\n#endif\r\n}\r\nmin_alloc_size = st->filt_len-1 + st->buffer_size;\r\nif (min_alloc_size > st->mem_alloc_size)\r\n{\r\nspx_word16_t *mem;\r\nif (INT_MAX/(spx_uint32_t)sizeof(spx_word16_t)/st->nb_channels < min_alloc_size)\r\ngoto fail;\r\nelse if (!(mem = (spx_word16_t*)speex_realloc(st->mem, st->nb_channels*min_alloc_size * sizeof(*mem))))\r\ngoto fail;\r\nst->mem = mem;\r\nst->mem_alloc_size = min_alloc_size;\r\n}\r\nif (!st->started)\r\n{\r\nspx_uint32_t i;\r\nfor (i=0;i<st->nb_channels*st->mem_alloc_size;i++)\r\nst->mem[i] = 0;\r\n} else if (st->filt_len > old_length)\r\n{\r\nspx_uint32_t i;\r\nfor (i=st->nb_channels;i--;)\r\n{\r\nspx_uint32_t j;\r\nspx_uint32_t olen = old_length;\r\n{\r\nolen = old_length + 2*st->magic_samples[i];\r\nfor (j=old_length-1+st->magic_samples[i];j--;)\r\nst->mem[i*st->mem_alloc_size+j+st->magic_samples[i]] = st->mem[i*old_alloc_size+j];\r\nfor (j=0;j<st->magic_samples[i];j++)\r\nst->mem[i*st->mem_alloc_size+j] = 0;\r\nst->magic_samples[i] = 0;\r\n}\r\nif (st->filt_len > olen)\r\n{\r\nfor (j=0;j<olen-1;j++)\r\nst->mem[i*st->mem_alloc_size+(st->filt_len-2-j)] = st->mem[i*st->mem_alloc_size+(olen-2-j)];\r\nfor (;j<st->filt_len-1;j++)\r\nst->mem[i*st->mem_alloc_size+(st->filt_len-2-j)] = 0;\r\nst->last_sample[i] += (st->filt_len - olen)/2;\r\n} else {\r\nst->magic_samples[i] = (olen - st->filt_len)/2;\r\nfor (j=0;j<st->filt_len-1+st->magic_samples[i];j++)\r\nst->mem[i*st->mem_alloc_size+j] = st->mem[i*st->mem_alloc_size+j+st->magic_samples[i]];\r\n}\r\n}\r\n} else if (st->filt_len < old_length)\r\n{\r\nspx_uint32_t i;\r\nfor (i=0;i<st->nb_channels;i++)\r\n{\r\nspx_uint32_t j;\r\nspx_uint32_t old_magic = st->magic_samples[i];\r\nst->magic_samples[i] = (old_length - st->filt_len)/2;\r\nfor (j=0;j<st->filt_len-1+st->magic_samples[i]+old_magic;j++)\r\nst->mem[i*st->mem_alloc_size+j] = st->mem[i*st->mem_alloc_size+j+st->magic_samples[i]];\r\nst->magic_samples[i] += old_magic;\r\n}\r\n}\r\nreturn RESAMPLER_ERR_SUCCESS;\r\nfail:\r\nst->resampler_ptr = resampler_basic_zero;\r\nst->filt_len = old_length;\r\nreturn RESAMPLER_ERR_ALLOC_FAILED;\r\n}\r\nEXPORT SpeexResamplerState *speex_resampler_init(spx_uint32_t nb_channels, spx_uint32_t in_rate, spx_uint32_t out_rate, int quality, int *err)\r\n{\r\nreturn speex_resampler_init_frac(nb_channels, in_rate, out_rate, in_rate, out_rate, quality, err);\r\n}\r\nEXPORT SpeexResamplerState *speex_resampler_init_frac(spx_uint32_t nb_channels, spx_uint32_t ratio_num, spx_uint32_t ratio_den, spx_uint32_t in_rate, spx_uint32_t out_rate, int quality, int *err)\r\n{\r\nspx_uint32_t i;\r\nSpeexResamplerState *st;\r\nint filter_err;\r\nif (quality > 10 || quality < 0)\r\n{\r\nif (err)\r\n*err = RESAMPLER_ERR_INVALID_ARG;\r\nreturn NULL;\r\n}\r\nst = (SpeexResamplerState *)speex_alloc(sizeof(SpeexResamplerState));\r\nst->initialised = 0;\r\nst->started = 0;\r\nst->in_rate = 0;\r\nst->out_rate = 0;\r\nst->num_rate = 0;\r\nst->den_rate = 0;\r\nst->quality = -1;\r\nst->sinc_table_length = 0;\r\nst->mem_alloc_size = 0;\r\nst->filt_len = 0;\r\nst->mem = 0;\r\nst->resampler_ptr = 0;\r\nst->cutoff = 1.f;\r\nst->nb_channels = nb_channels;\r\nst->in_stride = 1;\r\nst->out_stride = 1;\r\nst->buffer_size = 160;\r\nst->last_sample = (spx_int32_t*)speex_alloc(nb_channels*sizeof(spx_int32_t));\r\nst->magic_samples = (spx_uint32_t*)speex_alloc(nb_channels*sizeof(spx_uint32_t));\r\nst->samp_frac_num = (spx_uint32_t*)speex_alloc(nb_channels*sizeof(spx_uint32_t));\r\nfor (i=0;i<nb_channels;i++)\r\n{\r\nst->last_sample[i] = 0;\r\nst->magic_samples[i] = 0;\r\nst->samp_frac_num[i] = 0;\r\n}\r\nspeex_resampler_set_quality(st, quality);\r\nspeex_resampler_set_rate_frac(st, ratio_num, ratio_den, in_rate, out_rate);\r\nfilter_err = update_filter(st);\r\nif (filter_err == RESAMPLER_ERR_SUCCESS)\r\n{\r\nst->initialised = 1;\r\n} else {\r\nspeex_resampler_destroy(st);\r\nst = NULL;\r\n}\r\nif (err)\r\n*err = filter_err;\r\nreturn st;\r\n}\r\nEXPORT void speex_resampler_destroy(SpeexResamplerState *st)\r\n{\r\nspeex_free(st->mem);\r\nspeex_free(st->sinc_table);\r\nspeex_free(st->last_sample);\r\nspeex_free(st->magic_samples);\r\nspeex_free(st->samp_frac_num);\r\nspeex_free(st);\r\n}\r\nstatic int speex_resampler_process_native(SpeexResamplerState *st, spx_uint32_t channel_index, spx_uint32_t *in_len, spx_word16_t *out, spx_uint32_t *out_len)\r\n{\r\nint j=0;\r\nconst int N = st->filt_len;\r\nint out_sample = 0;\r\nspx_word16_t *mem = st->mem + channel_index * st->mem_alloc_size;\r\nspx_uint32_t ilen;\r\nst->started = 1;\r\nout_sample = st->resampler_ptr(st, channel_index, mem, in_len, out, out_len);\r\nif (st->last_sample[channel_index] < (spx_int32_t)*in_len)\r\n*in_len = st->last_sample[channel_index];\r\n*out_len = out_sample;\r\nst->last_sample[channel_index] -= *in_len;\r\nilen = *in_len;\r\nfor(j=0;j<N-1;++j)\r\nmem[j] = mem[j+ilen];\r\nreturn RESAMPLER_ERR_SUCCESS;\r\n}\r\nstatic int speex_resampler_magic(SpeexResamplerState *st, spx_uint32_t channel_index, spx_word16_t **out, spx_uint32_t out_len) {\r\nspx_uint32_t tmp_in_len = st->magic_samples[channel_index];\r\nspx_word16_t *mem = st->mem + channel_index * st->mem_alloc_size;\r\nconst int N = st->filt_len;\r\nspeex_resampler_process_native(st, channel_index, &tmp_in_len, *out, &out_len);\r\nst->magic_samples[channel_index] -= tmp_in_len;\r\nif (st->magic_samples[channel_index])\r\n{\r\nspx_uint32_t i;\r\nfor (i=0;i<st->magic_samples[channel_index];i++)\r\nmem[N-1+i]=mem[N-1+i+tmp_in_len];\r\n}\r\n*out += out_len*st->out_stride;\r\nreturn out_len;\r\n}\r\nEXPORT int speex_resampler_process_interleaved_float(SpeexResamplerState *st, const float *in, spx_uint32_t *in_len, float *out, spx_uint32_t *out_len)\r\n{\r\nspx_uint32_t i;\r\nint istride_save, ostride_save;\r\nspx_uint32_t bak_out_len = *out_len;\r\nspx_uint32_t bak_in_len = *in_len;\r\nistride_save = st->in_stride;\r\nostride_save = st->out_stride;\r\nst->in_stride = st->out_stride = st->nb_channels;\r\nfor (i=0;i<st->nb_channels;i++)\r\n{\r\n*out_len = bak_out_len;\r\n*in_len = bak_in_len;\r\nif (in != NULL)\r\nspeex_resampler_process_float(st, i, in+i, in_len, out+i, out_len);\r\nelse\r\nspeex_resampler_process_float(st, i, NULL, in_len, out+i, out_len);\r\n}\r\nst->in_stride = istride_save;\r\nst->out_stride = ostride_save;\r\nreturn st->resampler_ptr == resampler_basic_zero ? RESAMPLER_ERR_ALLOC_FAILED : RESAMPLER_ERR_SUCCESS;\r\n}\r\nEXPORT int speex_resampler_process_interleaved_int(SpeexResamplerState *st, const spx_int16_t *in, spx_uint32_t *in_len, spx_int16_t *out, spx_uint32_t *out_len)\r\n{\r\nspx_uint32_t i;\r\nint istride_save, ostride_save;\r\nspx_uint32_t bak_out_len = *out_len;\r\nspx_uint32_t bak_in_len = *in_len;\r\nistride_save = st->in_stride;\r\nostride_save = st->out_stride;\r\nst->in_stride = st->out_stride = st->nb_channels;\r\nfor (i=0;i<st->nb_channels;i++)\r\n{\r\n*out_len = bak_out_len;\r\n*in_len = bak_in_len;\r\nif (in != NULL)\r\nspeex_resampler_process_int(st, i, in+i, in_len, out+i, out_len);\r\nelse\r\nspeex_resampler_process_int(st, i, NULL, in_len, out+i, out_len);\r\n}\r\nst->in_stride = istride_save;\r\nst->out_stride = ostride_save;\r\nreturn st->resampler_ptr == resampler_basic_zero ? RESAMPLER_ERR_ALLOC_FAILED : RESAMPLER_ERR_SUCCESS;\r\n}\r\nEXPORT int speex_resampler_set_rate(SpeexResamplerState *st, spx_uint32_t in_rate, spx_uint32_t out_rate)\r\n{\r\nreturn speex_resampler_set_rate_frac(st, in_rate, out_rate, in_rate, out_rate);\r\n}\r\nEXPORT void speex_resampler_get_rate(SpeexResamplerState *st, spx_uint32_t *in_rate, spx_uint32_t *out_rate)\r\n{\r\n*in_rate = st->in_rate;\r\n*out_rate = st->out_rate;\r\n}\r\nEXPORT int speex_resampler_set_rate_frac(SpeexResamplerState *st, spx_uint32_t ratio_num, spx_uint32_t ratio_den, spx_uint32_t in_rate, spx_uint32_t out_rate)\r\n{\r\nspx_uint32_t fact;\r\nspx_uint32_t old_den;\r\nspx_uint32_t i;\r\nif (st->in_rate == in_rate && st->out_rate == out_rate && st->num_rate == ratio_num && st->den_rate == ratio_den)\r\nreturn RESAMPLER_ERR_SUCCESS;\r\nold_den = st->den_rate;\r\nst->in_rate = in_rate;\r\nst->out_rate = out_rate;\r\nst->num_rate = ratio_num;\r\nst->den_rate = ratio_den;\r\nfor (fact=2;fact<=IMIN(st->num_rate, st->den_rate);fact++)\r\n{\r\nwhile ((st->num_rate % fact == 0) && (st->den_rate % fact == 0))\r\n{\r\nst->num_rate /= fact;\r\nst->den_rate /= fact;\r\n}\r\n}\r\nif (old_den > 0)\r\n{\r\nfor (i=0;i<st->nb_channels;i++)\r\n{\r\nst->samp_frac_num[i]=st->samp_frac_num[i]*st->den_rate/old_den;\r\nif (st->samp_frac_num[i] >= st->den_rate)\r\nst->samp_frac_num[i] = st->den_rate-1;\r\n}\r\n}\r\nif (st->initialised)\r\nreturn update_filter(st);\r\nreturn RESAMPLER_ERR_SUCCESS;\r\n}\r\nEXPORT void speex_resampler_get_ratio(SpeexResamplerState *st, spx_uint32_t *ratio_num, spx_uint32_t *ratio_den)\r\n{\r\n*ratio_num = st->num_rate;\r\n*ratio_den = st->den_rate;\r\n}\r\nEXPORT int speex_resampler_set_quality(SpeexResamplerState *st, int quality)\r\n{\r\nif (quality > 10 || quality < 0)\r\nreturn RESAMPLER_ERR_INVALID_ARG;\r\nif (st->quality == quality)\r\nreturn RESAMPLER_ERR_SUCCESS;\r\nst->quality = quality;\r\nif (st->initialised)\r\nreturn update_filter(st);\r\nreturn RESAMPLER_ERR_SUCCESS;\r\n}\r\nEXPORT void speex_resampler_get_quality(SpeexResamplerState *st, int *quality)\r\n{\r\n*quality = st->quality;\r\n}\r\nEXPORT void speex_resampler_set_input_stride(SpeexResamplerState *st, spx_uint32_t stride)\r\n{\r\nst->in_stride = stride;\r\n}\r\nEXPORT void speex_resampler_get_input_stride(SpeexResamplerState *st, spx_uint32_t *stride)\r\n{\r\n*stride = st->in_stride;\r\n}\r\nEXPORT void speex_resampler_set_output_stride(SpeexResamplerState *st, spx_uint32_t stride)\r\n{\r\nst->out_stride = stride;\r\n}\r\nEXPORT void speex_resampler_get_output_stride(SpeexResamplerState *st, spx_uint32_t *stride)\r\n{\r\n*stride = st->out_stride;\r\n}\r\nEXPORT int speex_resampler_get_input_latency(SpeexResamplerState *st)\r\n{\r\nreturn st->filt_len / 2;\r\n}\r\nEXPORT int speex_resampler_get_output_latency(SpeexResamplerState *st)\r\n{\r\nreturn ((st->filt_len / 2) * st->den_rate + (st->num_rate >> 1)) / st->num_rate;\r\n}\r\nEXPORT int speex_resampler_skip_zeros(SpeexResamplerState *st)\r\n{\r\nspx_uint32_t i;\r\nfor (i=0;i<st->nb_channels;i++)\r\nst->last_sample[i] = st->filt_len/2;\r\nreturn RESAMPLER_ERR_SUCCESS;\r\n}\r\nEXPORT int speex_resampler_reset_mem(SpeexResamplerState *st)\r\n{\r\nspx_uint32_t i;\r\nfor (i=0;i<st->nb_channels;i++)\r\n{\r\nst->last_sample[i] = 0;\r\nst->magic_samples[i] = 0;\r\nst->samp_frac_num[i] = 0;\r\n}\r\nfor (i=0;i<st->nb_channels*(st->filt_len-1);i++)\r\nst->mem[i] = 0;\r\nreturn RESAMPLER_ERR_SUCCESS;\r\n}\r\nEXPORT const char *speex_resampler_strerror(int err)\r\n{\r\nswitch (err)\r\n{\r\ncase RESAMPLER_ERR_SUCCESS:\r\nreturn "Success.";\r\ncase RESAMPLER_ERR_ALLOC_FAILED:\r\nreturn "Memory allocation failed.";\r\ncase RESAMPLER_ERR_BAD_STATE:\r\nreturn "Bad resampler state.";\r\ncase RESAMPLER_ERR_INVALID_ARG:\r\nreturn "Invalid argument.";\r\ncase RESAMPLER_ERR_PTR_OVERLAP:\r\nreturn "Input and output buffers overlap.";\r\ndefault:\r\nreturn "Unknown error. Bad error code or strange version mismatch.";\r\n}\r\n}
