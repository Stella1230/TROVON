static int\r\ndissect_qllc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\nproto_tree *qllc_tree;\r\nproto_item *qllc_ti;\r\ngboolean *q_bit_set;\r\nguint8 addr, ctrl;\r\ngboolean command = FALSE;\r\nif (data == NULL)\r\nreturn 0;\r\nq_bit_set = (gboolean *)data;\r\nif (!(*q_bit_set)) {\r\ncall_dissector(sna_handle, tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "QLLC");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nqllc_ti = proto_tree_add_item(tree, proto_qllc, tvb, 0, -1, ENC_NA);\r\nqllc_tree = proto_item_add_subtree(qllc_ti, ett_qllc);\r\naddr = tvb_get_guint8(tvb, 0);\r\nproto_tree_add_item(qllc_tree, hf_qllc_address, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nctrl = tvb_get_guint8(tvb, 1);\r\nif (ctrl != QRR && addr == 0xff) {\r\ncommand = TRUE;\r\n}\r\nif (ctrl == QRD_QDISC_VALUE) {\r\nif (command) {\r\ncol_set_str(pinfo->cinfo, COL_INFO, QDISC_TEXT);\r\nproto_tree_add_uint_format_value(qllc_tree, hf_qllc_control, tvb,\r\n1, 1, ctrl, "%s (0x%02x)", QDISC_TEXT, ctrl);\r\n}\r\nelse {\r\ncol_set_str(pinfo->cinfo, COL_INFO, QRD_TEXT);\r\nproto_tree_add_uint_format_value(qllc_tree, hf_qllc_control, tvb,\r\n1, 1, ctrl, "%s (0x%02x)", QRD_TEXT, ctrl);\r\n}\r\n}\r\nelse {\r\ncol_add_str(pinfo->cinfo, COL_INFO,\r\nval_to_str(ctrl, qllc_control_vals,\r\n"Control Field: 0x%02x (unknown)"));\r\nproto_tree_add_uint(qllc_tree, hf_qllc_control, tvb,\r\n1, 1, ctrl);\r\n}\r\nif (ctrl == QXID || ctrl == QTEST || ctrl == QFRMR) {\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_qllc(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_qllc_address,\r\n{ "Address Field", "qllc.address", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_qllc_control,\r\n{ "Control Field", "qllc.control", FT_UINT8, BASE_HEX,\r\nVALS(qllc_control_vals), 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_qllc,\r\n};\r\nproto_qllc = proto_register_protocol("Qualified Logical Link Control", "QLLC", "qllc");\r\nproto_register_field_array(proto_qllc, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nregister_dissector("qllc", dissect_qllc, proto_qllc);\r\n}\r\nvoid\r\nproto_reg_handoff_qllc(void)\r\n{\r\nsna_handle = find_dissector_add_dependency("sna", proto_qllc);\r\n}
