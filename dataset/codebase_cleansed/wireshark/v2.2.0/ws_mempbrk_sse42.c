static inline __m128i\r\n__m128i_shift_right (__m128i value, unsigned long int offset)\r\n{\r\nreturn _mm_shuffle_epi8 (value,\r\n_mm_loadu_si128 (cast_128aligned__m128i(___m128i_shift_right + offset)));\r\n}\r\nvoid\r\nws_mempbrk_sse42_compile(ws_mempbrk_pattern* pattern, const gchar *needles)\r\n{\r\nsize_t length = strlen(needles);\r\npattern->use_sse42 = ws_cpuid_sse42() && (length <= 16);\r\nif (pattern->use_sse42) {\r\npattern->mask = _mm_setzero_si128();\r\nmemcpy(&(pattern->mask), needles, length);\r\n}\r\n}\r\nconst char *\r\nws_mempbrk_sse42_exec(const char *s, size_t slen, const ws_mempbrk_pattern* pattern, guchar *found_needle)\r\n{\r\nconst char *aligned;\r\nint offset;\r\noffset = (int) ((size_t) s & 15);\r\naligned = (const char *) ((size_t) s & -16L);\r\nif (offset != 0)\r\n{\r\n__m128i value = __m128i_shift_right (_mm_load_si128 (cast_128aligned__m128i(aligned)), offset);\r\nint length = _mm_cmpistri (pattern->mask, value, 0x2);\r\nint cflag = _mm_cmpistrc (pattern->mask, value, 0x2);\r\nint idx = _mm_cmpistri (value, value, 0x3a);\r\nif (cflag) {\r\nif (found_needle)\r\n*found_needle = *(s + length);\r\nreturn s + length;\r\n}\r\nif (idx < 16 - offset)\r\n{\r\nreturn ws_mempbrk_portable_exec(s + idx + 1, slen - idx - 1, pattern, found_needle);\r\n}\r\naligned += 16;\r\nslen -= (16 - offset);\r\n}\r\nelse\r\naligned = s;\r\nwhile (slen >= 16)\r\n{\r\n__m128i value = _mm_load_si128 (cast_128aligned__m128i(aligned));\r\nint idx = _mm_cmpistri (pattern->mask, value, 0x2);\r\nint cflag = _mm_cmpistrc (pattern->mask, value, 0x2);\r\nint zflag = _mm_cmpistrz (pattern->mask, value, 0x2);\r\nif (cflag) {\r\nif (found_needle)\r\n*found_needle = *(aligned + idx);\r\nreturn aligned + idx;\r\n}\r\nif (zflag)\r\n{\r\nreturn ws_mempbrk_portable_exec(aligned, slen, pattern, found_needle);\r\n}\r\naligned += 16;\r\nslen -= 16;\r\n}\r\nreturn ws_mempbrk_portable_exec(aligned, slen, pattern, found_needle);\r\n}
