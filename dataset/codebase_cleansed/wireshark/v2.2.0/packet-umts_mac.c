gint get_mac_tsn_size(void) { return global_mac_tsn_size; }\r\nstatic gboolean mac_is_channel_equal(gconstpointer a, gconstpointer b)\r\n{\r\nconst mac_is_channel *x = (const mac_is_channel *)a, *y = (const mac_is_channel *)b;\r\nreturn x->lchid == y->lchid && x->ueid == y->ueid;\r\n}\r\nstatic guint mac_is_channel_hash(gconstpointer key)\r\n{\r\nconst mac_is_channel * ch = (const mac_is_channel *)key;\r\nreturn (ch->ueid << 4) | ch->lchid;\r\n}\r\nstatic gboolean mac_is_fragment_equal(gconstpointer a, gconstpointer b)\r\n{\r\nconst mac_is_fragment *x = (const mac_is_fragment *)a, *y = (const mac_is_fragment *)b;\r\nreturn x->frame_num == y->frame_num && x->tsn == y->tsn && x->type == y->type;\r\n}\r\nstatic guint mac_is_fragment_hash(gconstpointer key)\r\n{\r\nconst mac_is_fragment *frag = (const mac_is_fragment *)key;\r\nreturn (frag->frame_num << 2) | frag->type;\r\n}\r\nstatic guint8 fach_fdd_tctf(guint8 hdr, guint16 *bit_offs)\r\n{\r\nguint8 tctf;\r\ntctf = hdr >> 6;\r\nswitch (tctf) {\r\ncase TCTF_BCCH_FACH_FDD:\r\ncase TCTF_DCCH_DTCH_FACH_FDD:\r\n*bit_offs = 2;\r\nreturn tctf;\r\n}\r\ntctf = hdr >> 4;\r\nswitch (tctf) {\r\ncase TCTF_MTCH_FACH_FDD:\r\n*bit_offs = 4;\r\nreturn tctf;\r\n}\r\n*bit_offs = 8;\r\ntctf = hdr;\r\nswitch (tctf) {\r\ncase TCTF_CCCH_FACH_FDD:\r\ncase TCTF_MCCH_FACH_FDD:\r\ncase TCTF_MSCH_FACH_FDD:\r\ncase TCTF_CTCH_FACH_FDD:\r\nreturn tctf;\r\ndefault:\r\nreturn tctf;\r\n}\r\n}\r\nstatic guint16 tree_add_common_dcch_dtch_fields(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, guint16 bitoffs, fp_info *fpinf, umts_mac_info *macinf, rlc_info *rlcinf)\r\n{\r\nguint8 ueid_type;\r\nueid_type = tvb_get_bits8(tvb, bitoffs, 2);\r\nproto_tree_add_bits_item(tree, hf_mac_ueid_type, tvb, bitoffs, 2, ENC_BIG_ENDIAN);\r\nbitoffs += 2;\r\nif (ueid_type == MAC_UEID_TYPE_URNTI) {\r\nproto_tree_add_bits_item(tree, hf_mac_urnti, tvb, bitoffs, 32, ENC_BIG_ENDIAN);\r\nrlcinf->urnti[fpinf->cur_tb] = tvb_get_bits32(tvb, bitoffs, 32,ENC_BIG_ENDIAN);\r\nbitoffs += 32;\r\n} else if (ueid_type == MAC_UEID_TYPE_CRNTI) {\r\nproto_tree_add_bits_item(tree, hf_mac_crnti, tvb, 4, 16, ENC_BIG_ENDIAN);\r\nrlcinf->urnti[fpinf->cur_tb] = tvb_get_bits16(tvb, bitoffs, 16,ENC_BIG_ENDIAN);\r\nbitoffs += 16;\r\n}\r\nif (macinf->ctmux[fpinf->cur_tb]) {\r\nproto_item * temp;\r\nif(rlcinf){\r\nrlcinf->rbid[fpinf->cur_tb] = tvb_get_bits8(tvb, bitoffs, 4)+1;\r\n}\r\nproto_tree_add_bits_item(tree, hf_mac_ct, tvb, bitoffs, 4, ENC_BIG_ENDIAN);\r\nbitoffs += 4;\r\nif(rlcinf){\r\ntemp = proto_tree_add_uint(tree, hf_mac_lch_id, tvb, 0, 0, rlcinf->rbid[fpinf->cur_tb]);\r\nPROTO_ITEM_SET_GENERATED(temp);\r\n}\r\n}\r\nreturn bitoffs;\r\n}\r\nstatic int dissect_mac_fdd_pch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nproto_tree *pch_tree = NULL;\r\nproto_item *channel_type;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MAC");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "PCCH");\r\nif (tree) {\r\nproto_item *ti;\r\nti = proto_tree_add_item(tree, proto_umts_mac, tvb, 0, -1, ENC_NA);\r\npch_tree = proto_item_add_subtree(ti, ett_mac_pch);\r\nproto_item_append_text(ti, " (PCCH)");\r\nchannel_type = proto_tree_add_uint(pch_tree, hf_mac_channel, tvb, 0, 0, MAC_PCCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\n}\r\ncall_dissector_with_data(rlc_pcch_handle, tvb, pinfo, tree, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int dissect_mac_fdd_rach(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nguint8 tctf;\r\nguint8 chan;\r\nguint16 bitoffs = 0;\r\ntvbuff_t *next_tvb;\r\nproto_tree *rach_tree = NULL;\r\nproto_item *channel_type;\r\numts_mac_info *macinf;\r\nfp_info *fpinf;\r\nrlc_info *rlcinf;\r\nproto_item *ti = NULL;\r\nguint8 c_t;\r\ntctf = tvb_get_bits8(tvb, 0, 2);\r\nbitoffs += 2;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MAC");\r\ncol_set_str(pinfo->cinfo, COL_INFO,\r\nval_to_str_const(tctf, rach_fdd_tctf_vals, "Unknown TCTF"));\r\nti = proto_tree_add_item(tree, proto_umts_mac, tvb, 0, -1, ENC_NA);\r\nrach_tree = proto_item_add_subtree(ti, ett_mac_rach);\r\nmacinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\r\nfpinf = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\nrlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0);\r\nif (!macinf || !fpinf) {\r\nproto_tree_add_expert(rach_tree, pinfo, &ei_mac_per_frame_info_missing, tvb, 0, -1);\r\nreturn 1;\r\n}\r\nproto_tree_add_bits_item(rach_tree, hf_mac_rach_fdd_tctf, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nif (tctf == TCTF_DCCH_DTCH_RACH_FDD) {\r\nmacinf->ctmux[fpinf->cur_tb] = 1;\r\nbitoffs = tree_add_common_dcch_dtch_fields(tvb, pinfo, rach_tree, bitoffs, fpinf, macinf, rlcinf);\r\n}\r\nchan = fpinf->cur_chan;\r\nswitch (tctf) {\r\ncase TCTF_CCCH_RACH_FDD:\r\nproto_item_append_text(ti, " (CCCH)");\r\nchannel_type = proto_tree_add_uint(rach_tree, hf_mac_channel, tvb, 0, 0, MAC_CCCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nnext_tvb = tvb_new_octet_aligned(tvb, bitoffs, fpinf->chan_tf_size[chan] - bitoffs);\r\nadd_new_data_source(pinfo, next_tvb, "Octet-Aligned CCCH Data");\r\ncall_dissector_with_data(rlc_ccch_handle, next_tvb, pinfo, tree, data);\r\nbreak;\r\ncase TCTF_DCCH_DTCH_RACH_FDD:\r\nc_t = tvb_get_bits8(tvb,bitoffs-4,4);\r\nrlcinf->mode[chan] = lchId_rlc_map[c_t+1];\r\nmacinf->content[chan] = lchId_type_table[c_t+1];\r\nrlcinf->rbid[chan] = c_t+1;\r\nswitch (macinf->content[chan]) {\r\ncase MAC_CONTENT_DCCH:\r\nproto_item_append_text(ti, " (DCCH)");\r\nchannel_type = proto_tree_add_uint(rach_tree, hf_mac_channel, tvb, 0, 0, MAC_DCCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nnext_tvb = tvb_new_octet_aligned(tvb, bitoffs, fpinf->chan_tf_size[chan] - bitoffs);\r\nadd_new_data_source(pinfo, next_tvb, "Octet-Aligned DCCH Data");\r\ncall_dissector_with_data(rlc_dcch_handle, next_tvb, pinfo, tree, data);\r\nbreak;\r\ncase MAC_CONTENT_PS_DTCH:\r\nproto_item_append_text(ti, " (PS DTCH)");\r\nchannel_type = proto_tree_add_uint(rach_tree, hf_mac_channel, tvb, 0, 0, MAC_DTCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nnext_tvb = tvb_new_octet_aligned(tvb, bitoffs, fpinf->chan_tf_size[chan] - bitoffs);\r\nadd_new_data_source(pinfo, next_tvb, "Octet-Aligned DTCH Data");\r\ncall_dissector_with_data(rlc_ps_dtch_handle, next_tvb, pinfo, tree, data);\r\nbreak;\r\ncase MAC_CONTENT_CS_DTCH:\r\nproto_item_append_text(ti, " (CS DTCH)");\r\nbreak;\r\ndefault:\r\nproto_item_append_text(ti, " (Unknown RACH DCCH/DTCH Content)");\r\nexpert_add_info_format(pinfo, NULL, &ei_mac_unknown_content, "Unknown RACH DCCH/DTCH Content");\r\n}\r\nbreak;\r\ndefault:\r\nproto_item_append_text(ti, " (Unknown RACH TCTF)");\r\nexpert_add_info_format(pinfo, NULL, &ei_mac_rach_tctf_unknown, "Unknown RACH TCTF");\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int dissect_mac_fdd_fach(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nguint8 hdr, tctf;\r\nguint16 bitoffs = 0;\r\nguint16 tctf_len, chan;\r\nproto_tree *fach_tree = NULL;\r\nproto_item *channel_type;\r\ntvbuff_t *next_tvb;\r\numts_mac_info *macinf;\r\nfp_info *fpinf;\r\nrlc_info *rlcinf;\r\nstruct rrc_info *rrcinf;\r\nproto_item *ti = NULL;\r\ngint c_t;\r\nhdr = tvb_get_guint8(tvb, 0);\r\ntctf = fach_fdd_tctf(hdr, &bitoffs);\r\ntctf_len = bitoffs;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MAC");\r\ncol_set_str(pinfo->cinfo, COL_INFO,\r\nval_to_str_const(tctf, fach_fdd_tctf_vals, "Unknown TCTF"));\r\nti = proto_tree_add_item(tree, proto_umts_mac, tvb, 0, -1, ENC_NA);\r\nfach_tree = proto_item_add_subtree(ti, ett_mac_fach);\r\nmacinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\r\nfpinf = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\nrlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0);\r\nif (!macinf || !fpinf) {\r\nproto_tree_add_expert(fach_tree, pinfo, &ei_mac_per_frame_info_missing, tvb, 0, -1);\r\nreturn 1;\r\n}\r\nproto_tree_add_bits_item(fach_tree, hf_mac_fach_fdd_tctf, tvb, 0, tctf_len, ENC_BIG_ENDIAN);\r\nif (tctf == TCTF_DCCH_DTCH_FACH_FDD) {\r\nmacinf->ctmux[fpinf->cur_tb] = 1;\r\nbitoffs = tree_add_common_dcch_dtch_fields(tvb, pinfo, fach_tree, bitoffs, fpinf, macinf, rlcinf);\r\n}\r\nchan = fpinf->cur_chan;\r\nswitch (tctf) {\r\ncase TCTF_CCCH_FACH_FDD:\r\nproto_item_append_text(ti, " (CCCH)");\r\nchannel_type = proto_tree_add_uint(fach_tree, hf_mac_channel, tvb, 0, 0, MAC_CCCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nnext_tvb = tvb_new_subset_remaining(tvb, 1);\r\ncall_dissector_with_data(rlc_ccch_handle, next_tvb, pinfo, tree, data);\r\nbreak;\r\ncase TCTF_DCCH_DTCH_FACH_FDD:\r\nc_t = tvb_get_bits8(tvb,bitoffs-4,4);\r\nrlcinf->mode[fpinf->cur_tb] = lchId_rlc_map[c_t+1];\r\nmacinf->content[fpinf->cur_tb] = lchId_type_table[c_t+1];\r\nswitch (macinf->content[fpinf->cur_tb]) {\r\ncase MAC_CONTENT_DCCH:\r\nproto_item_append_text(ti, " (DCCH)");\r\nchannel_type = proto_tree_add_uint(fach_tree, hf_mac_channel, tvb, 0, 0, MAC_DCCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nnext_tvb = tvb_new_octet_aligned(tvb, bitoffs, fpinf->chan_tf_size[chan] - bitoffs);\r\nadd_new_data_source(pinfo, next_tvb, "Octet-Aligned DCCH Data");\r\ncall_dissector_with_data(rlc_dcch_handle, next_tvb, pinfo, tree, data);\r\nbreak;\r\ncase MAC_CONTENT_PS_DTCH:\r\nproto_item_append_text(ti, " (PS DTCH)");\r\nchannel_type = proto_tree_add_uint(fach_tree, hf_mac_channel, tvb, 0, 0, MAC_DTCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nnext_tvb = tvb_new_octet_aligned(tvb, bitoffs, fpinf->chan_tf_size[chan] - bitoffs);\r\nadd_new_data_source(pinfo, next_tvb, "Octet-Aligned DCCH Data");\r\ncall_dissector_with_data(rlc_ps_dtch_handle, next_tvb, pinfo, tree, data);\r\nbreak;\r\ncase MAC_CONTENT_CS_DTCH:\r\nproto_item_append_text(ti, " (CS DTCH)");\r\nexpert_add_info(pinfo, NULL, &ei_mac_cs_dtch_not_implemented);\r\nbreak;\r\ndefault:\r\nproto_item_append_text(ti, " (Unknown FACH Content");\r\nexpert_add_info_format(pinfo, NULL, &ei_mac_unknown_content, "Unknown FACH Content for this transportblock");\r\n}\r\nbreak;\r\ncase TCTF_CTCH_FACH_FDD:\r\nproto_item_append_text(ti, " (CTCH)");\r\nchannel_type = proto_tree_add_uint(fach_tree, hf_mac_channel, tvb, 0, 0, MAC_CTCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nnext_tvb = tvb_new_subset_remaining(tvb, 1);\r\ncall_dissector_with_data(rlc_ctch_handle, next_tvb, pinfo, tree, data);\r\nbreak;\r\ncase TCTF_BCCH_FACH_FDD:\r\nproto_item_append_text(ti, " (BCCH)");\r\nchannel_type = proto_tree_add_uint(fach_tree, hf_mac_channel, tvb, 0, 0, MAC_BCCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nnext_tvb= tvb_new_octet_aligned(tvb, 2, (tvb_reported_length(tvb)*8)-2);\r\nadd_new_data_source(pinfo, next_tvb, "Octet-Aligned BCCH Data");\r\nrrcinf = (rrc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rrc, 0);\r\nif (!rrcinf) {\r\nrrcinf = wmem_new0(wmem_file_scope(), struct rrc_info);\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_rrc, 0, rrcinf);\r\n}\r\nrrcinf->msgtype[fpinf->cur_tb] = RRC_MESSAGE_TYPE_BCCH_FACH;\r\ncall_dissector_with_data(rrc_handle, next_tvb, pinfo, tree, data);\r\nbreak;\r\ncase TCTF_MSCH_FACH_FDD:\r\ncase TCTF_MCCH_FACH_FDD:\r\ncase TCTF_MTCH_FACH_FDD:\r\nexpert_add_info(pinfo, NULL, &ei_mac_fach_content_type_unknown);\r\nbreak;\r\ndefault:\r\nproto_item_append_text(ti, " (Unknown FACH Content)");\r\nexpert_add_info_format(pinfo, NULL, &ei_mac_unknown_content, " Unknown FACH Content");\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int dissect_mac_fdd_dch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nguint16 pos;\r\nguint8 bitoffs = 0;\r\numts_mac_info *macinf;\r\nfp_info *fpinf;\r\nrlc_info *rlcinf;\r\nproto_tree *dch_tree = NULL;\r\nproto_item *channel_type;\r\ntvbuff_t *next_tvb;\r\nproto_item *ti = NULL;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MAC");\r\nti = proto_tree_add_item(tree, proto_umts_mac, tvb, 0, -1, ENC_NA);\r\ndch_tree = proto_item_add_subtree(ti, ett_mac_dch);\r\nmacinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\r\nfpinf = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\nrlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0);\r\nif (!macinf || !fpinf) {\r\nproto_tree_add_expert(dch_tree, pinfo, &ei_mac_per_frame_info_missing, tvb, 0, -1);\r\nreturn 1;\r\n}\r\npos = fpinf->cur_tb;\r\nif (macinf->ctmux[pos]) {\r\nif(rlcinf){\r\nrlcinf->rbid[fpinf->cur_tb] = tvb_get_bits8(tvb, bitoffs, 4)+1;\r\n}\r\nproto_tree_add_bits_item(dch_tree, hf_mac_ct, tvb, 0, 4, ENC_BIG_ENDIAN);\r\nbitoffs = 4;\r\n}\r\nif (bitoffs) {\r\nnext_tvb = tvb_new_octet_aligned(tvb, bitoffs, fpinf->chan_tf_size[pos] - bitoffs);\r\nadd_new_data_source(pinfo, next_tvb, "Octet-Aligned DCCH Data");\r\n} else\r\nnext_tvb = tvb;\r\nswitch (macinf->content[pos]) {\r\ncase MAC_CONTENT_DCCH:\r\nproto_item_append_text(ti, " (DCCH)");\r\nchannel_type = proto_tree_add_uint(dch_tree, hf_mac_lch_id, tvb, 0, 0, macinf->lchid[pos]);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nif(macinf->lchid[pos]!= 255){\r\nif(macinf->fake_chid[pos]){\r\nexpert_add_info(pinfo, channel_type, &ei_mac_faked_logical_channel_id);\r\n}\r\n}else{\r\nexpert_add_info(pinfo, channel_type, &ei_mac_no_logical_channel);\r\n}\r\nchannel_type = proto_tree_add_uint(dch_tree, hf_mac_channel, tvb, 0, 0, MAC_DCCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nchannel_type = proto_tree_add_uint(dch_tree, hf_mac_trch_id, tvb, 0, 0, macinf->trchid[pos]);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\ncall_dissector_with_data(rlc_dcch_handle, next_tvb, pinfo, tree, data);\r\nbreak;\r\ncase MAC_CONTENT_PS_DTCH:\r\nproto_item_append_text(ti, " (PS DTCH)");\r\nchannel_type = proto_tree_add_uint(dch_tree, hf_mac_lch_id, tvb, 0, 0, macinf->lchid[pos]);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nif(macinf->lchid[pos]== 255){\r\nexpert_add_info(pinfo, channel_type, &ei_mac_no_logical_channel);\r\n}\r\nchannel_type = proto_tree_add_uint(dch_tree, hf_mac_channel, tvb, 0, 0, MAC_DTCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\ncall_dissector_with_data(rlc_ps_dtch_handle, next_tvb, pinfo, tree, data);\r\nbreak;\r\ncase MAC_CONTENT_CS_DTCH:\r\nproto_item_append_text(ti, " (CS DTCH)");\r\nchannel_type = proto_tree_add_uint(dch_tree, hf_mac_lch_id, tvb, 0, 0, macinf->lchid[pos]);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nif(macinf->lchid[pos]!= 255){\r\nif(macinf->fake_chid[pos]){\r\nexpert_add_info(pinfo, channel_type, &ei_mac_faked_logical_channel_id);\r\n}\r\n}else{\r\nexpert_add_info(pinfo, channel_type, &ei_mac_no_logical_channel);\r\n}\r\nchannel_type = proto_tree_add_uint(dch_tree, hf_mac_channel, tvb, 0, 0, MAC_DTCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nchannel_type = proto_tree_add_uint(dch_tree, hf_mac_trch_id, tvb, 0, 0, macinf->trchid[pos]);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nbreak;\r\ndefault:\r\nproto_item_append_text(ti, " (Unknown DCH Content)");\r\nexpert_add_info_format(pinfo, NULL, &ei_mac_unknown_content, "Unknown DCH Content");\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void init_frag(tvbuff_t * tvb, body_parts * bp, guint length, guint offset, guint32 frame_num, guint16 tsn, guint8 type)\r\n{\r\nmac_is_fragment * frag = wmem_new(wmem_file_scope(), mac_is_fragment);\r\nfrag->type = type;\r\nfrag->length = length;\r\nfrag->data = (guint8 *)g_malloc(length);\r\nfrag->frame_num = frame_num;\r\nfrag->tsn = tsn;\r\nfrag->next = NULL;\r\nswitch (type) {\r\ncase MAC_IS_HEAD:\r\nDISSECTOR_ASSERT(bp->head == NULL);\r\nbp->head = frag;\r\nbreak;\r\ncase MAC_IS_MIDDLE:\r\nDISSECTOR_ASSERT(bp->middle == NULL);\r\nbp->middle = frag;\r\nbreak;\r\ncase MAC_IS_TAIL:\r\nDISSECTOR_ASSERT(bp->tail == NULL);\r\nbp->tail = frag;\r\nbreak;\r\n}\r\ntvb_memcpy(tvb, frag->data, offset, length);\r\n}\r\nstatic void mac_is_copy(mac_is_sdu * sdu, mac_is_fragment * frag, guint total_length, gboolean reverse)\r\n{\r\nDISSECTOR_ASSERT(sdu->length+frag->length <= total_length);\r\nif (reverse) {\r\nmemcpy(sdu->data+total_length-frag->length-sdu->length, frag->data, frag->length);\r\n} else {\r\nmemcpy(sdu->data+sdu->length, frag->data, frag->length);\r\n}\r\nsdu->length += frag->length;\r\ng_free(frag->data);\r\n}\r\nstatic tvbuff_t * reassemble(tvbuff_t * tvb, body_parts ** body_parts_array, guint16 head_tsn, guint length, mac_is_channel * ch, guint frame_num)\r\n{\r\nmac_is_sdu * sdu;\r\nmac_is_fragment * f;\r\nguint16 i;\r\nGHashTable * sdus;\r\nsdus = (GHashTable *)g_hash_table_lookup(mac_is_sdus, ch);\r\nif (sdus == NULL) {\r\nmac_is_channel * channel;\r\nsdus = g_hash_table_new(mac_is_fragment_hash, mac_is_fragment_equal);\r\nchannel = wmem_new(wmem_file_scope(), mac_is_channel);\r\n*channel = *ch;\r\ng_hash_table_insert(mac_is_sdus, channel, sdus);\r\n}\r\nsdu = wmem_new(wmem_file_scope(), mac_is_sdu);\r\nsdu->length = 0;\r\nsdu->data = (guint8 *)wmem_alloc(wmem_file_scope(), length);\r\nf = body_parts_array[head_tsn]->head;\r\ng_hash_table_insert(sdus, f, sdu);\r\nbody_parts_array[head_tsn]->head = NULL;\r\nmac_is_copy(sdu, f, length, FALSE);\r\nsdu->fragments = f;\r\nsdu->frame_num = frame_num;\r\nfor (i = (head_tsn+1)%MAX_TSN; body_parts_array[i]->middle != NULL; i = (i+1)%MAX_TSN)\r\n{\r\nf = f->next = body_parts_array[i]->middle;\r\ng_hash_table_insert(sdus, f, sdu);\r\nbody_parts_array[i]->middle = NULL;\r\nmac_is_copy(sdu, f, length, FALSE);\r\n}\r\nDISSECTOR_ASSERT(body_parts_array[i]->tail != NULL);\r\nf->next = body_parts_array[i]->tail;\r\ng_hash_table_insert(sdus, f->next, sdu);\r\nbody_parts_array[i]->tail = NULL;\r\nsdu->tsn = i;\r\nmac_is_copy(sdu, f->next, length, FALSE);\r\nreturn tvb_new_child_real_data(tvb, sdu->data, sdu->length, sdu->length);\r\n}\r\nstatic mac_is_sdu * get_sdu(guint frame_num, guint16 tsn, guint8 type, mac_is_channel * ch)\r\n{\r\nmac_is_sdu * sdu = NULL;\r\nGHashTable * sdus = NULL;\r\nmac_is_fragment frag_lookup_key;\r\nsdus = (GHashTable *)g_hash_table_lookup(mac_is_sdus, ch);\r\nif (sdus) {\r\nfrag_lookup_key.frame_num = frame_num;\r\nfrag_lookup_key.tsn = tsn;\r\nfrag_lookup_key.type = type;\r\nsdu = (mac_is_sdu *)g_hash_table_lookup(sdus, &frag_lookup_key);\r\nreturn sdu;\r\n}\r\nreturn NULL;\r\n}\r\nstatic tvbuff_t * add_to_tree(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, mac_is_sdu * sdu, guint offset, guint16 maclength, guint8 type)\r\n{\r\ntvbuff_t * new_tvb = NULL;\r\nif (sdu->frame_num == pinfo->num) {\r\nmac_is_fragment * f = sdu->fragments;\r\nguint counter = 0;\r\nnew_tvb = tvb_new_child_real_data(tvb, sdu->data, sdu->length, sdu->length);\r\nadd_new_data_source(pinfo, new_tvb, "Reassembled MAC-is SDU");\r\nproto_tree_add_expert(tree, pinfo, &ei_mac_macis_sdu_reassembled, new_tvb, 0, -1);\r\nwhile (f) {\r\nproto_tree_add_uint_format_value(tree, hf_mac_is_fraglink, new_tvb,\r\ncounter, f->length, f->frame_num,\r\n"%u, payload: %u-%u (%u bytes) (TSN: %u)",\r\nf->frame_num, counter, counter+f->length-1, f->length,\r\nf->tsn);\r\ncounter += f->length;\r\nf = f->next;\r\n}\r\nreturn new_tvb;\r\n} else {\r\nnew_tvb = tvb_new_subset(tvb, offset, maclength, -1);\r\nswitch (type) {\r\ncase MAC_IS_HEAD:\r\nproto_tree_add_expert(tree, pinfo, &ei_mac_macis_sdu_first, new_tvb, 0, -1);\r\nbreak;\r\ncase MAC_IS_MIDDLE:\r\nproto_tree_add_expert(tree, pinfo, &ei_mac_macis_sdu_middle, new_tvb, 0, -1);\r\nbreak;\r\ncase MAC_IS_TAIL:\r\nproto_tree_add_expert(tree, pinfo, &ei_mac_macis_sdu_last, new_tvb, 0, -1);\r\nbreak;\r\n}\r\nproto_tree_add_uint(tree, hf_mac_is_reasmin, new_tvb, 0, 0, sdu->frame_num);\r\nreturn NULL;\r\n}\r\n}\r\nstatic guint find_head(body_parts ** body_parts_array, guint16 * tsn)\r\n{\r\nguint length = 0;\r\n*tsn = (*tsn==0)? (guint16)(MAX_TSN-1) : (*tsn)-1;\r\nfor (; body_parts_array[*tsn]->middle != NULL; *tsn = (*tsn==0)?(guint16)(MAX_TSN-1):(*tsn)-1)\r\nlength += body_parts_array[*tsn]->middle->length;\r\nif (body_parts_array[*tsn]->head != NULL)\r\nreturn length+body_parts_array[*tsn]->head->length;\r\nreturn 0;\r\n}\r\nstatic guint find_tail(body_parts ** body_parts_array, guint16 tsn)\r\n{\r\nguint length = 0;\r\nfor (tsn = (tsn+1)%MAX_TSN; body_parts_array[tsn]->middle != NULL; tsn = (tsn+1)%MAX_TSN)\r\nlength += body_parts_array[tsn]->middle->length;\r\nif (body_parts_array[tsn]->tail != NULL)\r\nreturn length+body_parts_array[tsn]->tail->length;\r\nreturn 0;\r\n}\r\nstatic body_parts ** get_body_parts(mac_is_channel * ch)\r\n{\r\nbody_parts ** bpa = (body_parts **)g_hash_table_lookup(mac_is_fragments, ch);\r\nif (bpa == NULL) {\r\nmac_is_channel * channel;\r\nguint16 i;\r\nbpa = wmem_alloc_array(wmem_file_scope(), body_parts*, MAX_TSN);\r\nfor (i = 0; i < MAX_TSN; i++) {\r\nbpa[i] = wmem_new0(wmem_file_scope(), body_parts);\r\n}\r\nchannel = wmem_new(wmem_file_scope(), mac_is_channel);\r\n*channel = *ch;\r\ng_hash_table_insert(mac_is_fragments, channel, bpa);\r\n}\r\nreturn bpa;\r\n}\r\nstatic tvbuff_t * mac_is_add_fragment(tvbuff_t * tvb _U_, packet_info *pinfo, proto_tree * tree _U_, guint8 lchid, guint ueid, int offset, guint8 ss, guint16 tsn, int sdu_no, guint8 no_sdus, guint16 maclength)\r\n{\r\nmac_is_channel ch;\r\nch.lchid = lchid;\r\nch.ueid = ueid;\r\nif (pinfo->fd->flags.visited == FALSE) {\r\nbody_parts ** body_parts_array = get_body_parts(&ch);\r\nif (no_sdus == 1 && ss == 3) {\r\nguint head_length, tail_length;\r\ninit_frag(tvb, body_parts_array[tsn], maclength, offset, pinfo->num, tsn, MAC_IS_MIDDLE);\r\ntail_length = find_tail(body_parts_array, tsn);\r\nif (tail_length > 0) {\r\nhead_length = find_head(body_parts_array, &tsn);\r\nif (head_length > 0) {\r\nreturn reassemble(tvb, body_parts_array, tsn, tail_length+head_length+maclength, &ch, pinfo->num);\r\n}\r\n}\r\n}\r\nelse if (sdu_no == 0 && (ss & 1) == 1) {\r\nguint length = maclength;\r\ninit_frag(tvb, body_parts_array[tsn], maclength, offset, pinfo->num, tsn, MAC_IS_TAIL);\r\nlength += find_head(body_parts_array, &tsn);\r\nif (length > maclength) {\r\nreturn reassemble(tvb, body_parts_array, tsn, length, &ch, pinfo->num);\r\n}\r\n}\r\nelse if (sdu_no == no_sdus-1 && (ss & 2) == 2) {\r\nguint length = maclength;\r\ninit_frag(tvb, body_parts_array[tsn], maclength, offset, pinfo->num, tsn, MAC_IS_HEAD);\r\nlength += find_tail(body_parts_array, tsn);\r\nif (length > maclength) {\r\nreturn reassemble(tvb, body_parts_array, tsn, length, &ch, pinfo->num);\r\n}\r\n} else {\r\nDISSECTOR_ASSERT((sdu_no == 0) ? (ss&1) == 0 : ((sdu_no == no_sdus-1) ? (ss&2) == 0 : TRUE));\r\nreturn tvb_new_subset(tvb, offset, maclength, -1);\r\n}\r\n} else {\r\ntvbuff_t * new_tvb = NULL;\r\nif (no_sdus == 1 && ss == 3) {\r\nmac_is_sdu * sdu = get_sdu(pinfo->num, tsn, MAC_IS_MIDDLE, &ch);\r\nif (sdu) {\r\nreturn add_to_tree(tvb, pinfo, tree, sdu, offset, maclength, MAC_IS_MIDDLE);\r\n}\r\n}\r\nelse if (sdu_no == 0 && (ss & 1) == 1) {\r\nmac_is_sdu * sdu = get_sdu(pinfo->num, tsn, MAC_IS_TAIL, &ch);\r\nif (sdu) {\r\nreturn add_to_tree(tvb, pinfo, tree, sdu, offset, maclength, MAC_IS_TAIL);\r\n}\r\n}\r\nelse if (sdu_no == no_sdus-1 && (ss & 2) == 2) {\r\nmac_is_sdu * sdu = get_sdu(pinfo->num, tsn, MAC_IS_HEAD, &ch);\r\nif (sdu) {\r\nreturn add_to_tree(tvb, pinfo, tree, sdu, offset, maclength, MAC_IS_HEAD);\r\n}\r\n} else {\r\nnew_tvb = tvb_new_subset(tvb, offset, maclength, -1);\r\nproto_tree_add_expert(tree, pinfo, &ei_mac_macis_sdu_complete, new_tvb, 0, -1);\r\nproto_tree_add_item(tree, hf_mac_edch_type2_sdu_data, new_tvb, 0, -1, ENC_NA);\r\nreturn new_tvb;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ss_interpretation(tvbuff_t * tvb, proto_tree * tree, guint8 ss, guint number_of_mac_is_sdus, guint offset)\r\n{\r\nswitch (ss) {\r\ncase 0:\r\nif (number_of_mac_is_sdus > 1) {\r\nproto_tree_add_uint_format_value(tree, hf_mac_edch_type2_ss_interpretation, tvb, offset, 1, ss,\r\n"The first MAC-is SDU of the MAC-is PDU is a complete MAC-d PDU or MAC-c PDU. The last MAC-is SDU of the MAC-is PDU is a complete MAC-d PDU or MAC-c PDU.");\r\n} else {\r\nproto_tree_add_uint_format_value(tree, hf_mac_edch_type2_ss_interpretation, tvb, offset, 1, ss,\r\n"The MAC-is SDU of the MAC-is PDU is a complete MAC-d PDU or MAC-c PDU.");\r\n}\r\nbreak;\r\ncase 1:\r\nif (number_of_mac_is_sdus > 1) {\r\nproto_tree_add_uint_format_value(tree, hf_mac_edch_type2_ss_interpretation, tvb, offset, 1, ss,\r\n"The last MAC-is SDU of the MAC-is PDU is a complete MAC-d PDU or MAC-c PDU. The first MAC-is SDU of the MAC-is PDU is the last segment of a MAC-d PDU or MAC-c PDU.");\r\n} else {\r\nproto_tree_add_uint_format_value(tree, hf_mac_edch_type2_ss_interpretation, tvb, offset, 1, ss,\r\n"The MAC-is SDU of the MAC-is PDU is the last segment of a MAC-d PDU or MAC-c PDU.");\r\n}\r\nbreak;\r\ncase 2:\r\nif (number_of_mac_is_sdus > 1) {\r\nproto_tree_add_uint_format_value(tree, hf_mac_edch_type2_ss_interpretation, tvb, offset, 1, ss,\r\n"The first MAC-is SDU of the MAC-is PDU is a complete MAC-d PDU or MAC-c PDU. The last MAC-is SDU of the MAC-is PDU is the first segment of a MAC-d PDU or MAC-c PDU.");\r\n} else {\r\nproto_tree_add_uint_format_value(tree, hf_mac_edch_type2_ss_interpretation, tvb, offset, 1, ss,\r\n"The MAC-is SDU of the MAC-is PDU is the first segment of a MAC-d PDU or MAC-c PDU.");\r\n}\r\nbreak;\r\ncase 3:\r\nif (number_of_mac_is_sdus > 1) {\r\nproto_tree_add_uint_format_value(tree, hf_mac_edch_type2_ss_interpretation, tvb, offset, 1, ss,\r\n"The first MAC-is SDU of the MAC-is PDU is the last segment of a MAC-d PDU or MAC-c PDU and the last MAC-is SDU of MAC-is PDU is the first segment of a MAC-d PDU or MAC-c PDU.");\r\n} else {\r\nproto_tree_add_uint_format_value(tree, hf_mac_edch_type2_ss_interpretation, tvb, offset, 1, ss,\r\n"The MAC-is SDU is a middle segment of a MAC-d PDU or MAC-c PDU.");\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void call_rlc(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, proto_item * ti, guint8 lchid, void *data)\r\n{\r\nswitch (lchId_type_table[lchid]) {\r\ncase MAC_CONTENT_DCCH:\r\nproto_item_append_text(ti, " (DCCH)");\r\ncall_dissector_with_data(rlc_dcch_handle, tvb, pinfo, tree, data);\r\nbreak;\r\ncase MAC_CONTENT_PS_DTCH:\r\nproto_item_append_text(ti, " (PS DTCH)");\r\ncall_dissector_with_data(rlc_ps_dtch_handle, tvb, pinfo, tree, data);\r\nbreak;\r\ncase MAC_CONTENT_CS_DTCH:\r\nproto_item_append_text(ti, " (CS DTCH)");\r\nbreak;\r\ndefault:\r\nproto_item_append_text(ti, " (Unknown EDCH Content)");\r\nexpert_add_info_format(pinfo, ti, &ei_mac_unknown_content, "Unknown EDCH Content");\r\nbreak;\r\n}\r\n}\r\nstatic int dissect_mac_fdd_edch_type2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nguint sdu_no, subframe_bytes = 0, offset = 0;\r\nguint8 ss;\r\nguint16 tsn;\r\nproto_item *pi, *temp;\r\nproto_tree *macis_pdu_tree, *macis_sdu_tree;\r\numts_mac_is_info * mac_is_info = (umts_mac_is_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\r\nrlc_info * rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0);\r\nstruct fp_info *p_fp_info = (struct fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\nDISSECTOR_ASSERT(mac_is_info != NULL && rlcinf != NULL && p_fp_info != NULL);\r\npi = proto_tree_add_item(tree, proto_umts_mac, tvb, 0, -1, ENC_NA);\r\nmacis_pdu_tree = proto_item_add_subtree(pi, ett_mac_edch_type2);\r\nss = (tvb_get_guint8(tvb, offset) & 0xc0) >> 6;\r\nproto_tree_add_item(macis_pdu_tree, hf_mac_edch_type2_ss, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nss_interpretation(tvb, macis_pdu_tree, ss, mac_is_info->number_of_mac_is_sdus, offset);\r\ntsn = tvb_get_bits8(tvb, offset*8+2, mac_tsn_size);\r\nproto_tree_add_bits_item(macis_pdu_tree, hf_mac_edch_type2_tsn, tvb, offset*8+2, mac_tsn_size, ENC_BIG_ENDIAN);\r\noffset += (2+mac_tsn_size)/8;\r\nfor (sdu_no=0; sdu_no < mac_is_info->number_of_mac_is_sdus; sdu_no++) {\r\nproto_item *ti;\r\ntvbuff_t * asm_tvb;\r\nguint8 lchid = mac_is_info->lchid[sdu_no]+1;\r\nguint sdulength = mac_is_info->sdulength[sdu_no];\r\nti = proto_tree_add_item(tree, hf_mac_edch_type2_sdu, tvb, offset, sdulength, ENC_NA);\r\nmacis_sdu_tree = proto_item_add_subtree(ti, ett_mac_edch_type2_sdu);\r\nproto_item_append_text(ti, " (Logical channel=%u, Len=%u)", lchid, sdulength);\r\ntemp = proto_tree_add_uint(ti, hf_mac_lch_id, tvb, 0, 0, lchid);\r\nPROTO_ITEM_SET_GENERATED(temp);\r\nrlcinf->mode[sdu_no] = lchId_rlc_map[lchid];\r\nrlcinf->urnti[sdu_no] = p_fp_info->com_context_id;\r\nrlcinf->rbid[sdu_no] = lchid;\r\nrlcinf->li_size[sdu_no] = RLC_LI_7BITS;\r\nrlcinf->ciphered[sdu_no] = FALSE;\r\nrlcinf->deciphered[sdu_no] = FALSE;\r\nasm_tvb = mac_is_add_fragment(tvb, pinfo, macis_sdu_tree, lchid, p_fp_info->com_context_id, offset, ss, tsn, sdu_no, mac_is_info->number_of_mac_is_sdus, sdulength);\r\nif (asm_tvb != NULL) {\r\ncall_rlc(asm_tvb, pinfo, tree, ti, lchid, data);\r\n}\r\noffset += sdulength;\r\nsubframe_bytes += sdulength;\r\n}\r\nproto_item_append_text(pi, "-is PDU (SS=%u, TSN=%u, %u bytes in %u SDU fragments)",\r\nss, tsn, subframe_bytes, mac_is_info->number_of_mac_is_sdus);\r\nproto_item_set_len(pi, 1+subframe_bytes);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int dissect_mac_fdd_edch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nproto_tree *edch_tree = NULL;\r\nproto_item *channel_type;\r\numts_mac_info *macinf;\r\nfp_info *fpinf;\r\nguint16 pos;\r\nproto_item *ti = NULL;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MAC");\r\nti = proto_tree_add_item(tree, proto_umts_mac, tvb, 0, -1, ENC_NA);\r\nedch_tree = proto_item_add_subtree(ti, ett_mac_edch);\r\nfpinf = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\nmacinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\r\nif (!macinf|| !fpinf) {\r\nproto_tree_add_expert(edch_tree, pinfo, &ei_mac_per_frame_info_missing, tvb, 0, -1);\r\nreturn 1;\r\n}\r\npos = fpinf->cur_tb;\r\nswitch (macinf->content[pos]) {\r\ncase MAC_CONTENT_DCCH:\r\nproto_item_append_text(ti, " (DCCH)");\r\nchannel_type = proto_tree_add_uint(edch_tree, hf_mac_lch_id, tvb, 0, 0, macinf->lchid[pos]);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nchannel_type = proto_tree_add_uint(edch_tree, hf_mac_channel, tvb, 0, 0, MAC_DCCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\ncall_dissector_with_data(rlc_dcch_handle, tvb, pinfo, tree, data);\r\nbreak;\r\ncase MAC_CONTENT_PS_DTCH:\r\nproto_item_append_text(ti, " (PS DTCH)");\r\nchannel_type = proto_tree_add_uint(edch_tree, hf_mac_lch_id, tvb, 0, 0, macinf->lchid[pos]);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nchannel_type = proto_tree_add_uint(edch_tree, hf_mac_channel, tvb, 0, 0, MAC_DTCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\ncall_dissector_with_data(rlc_ps_dtch_handle, tvb, pinfo, tree, data);\r\nbreak;\r\ncase MAC_CONTENT_CS_DTCH:\r\nproto_item_append_text(ti, " (CS DTCH)");\r\nbreak;\r\ndefault:\r\nproto_item_append_text(ti, " (Unknown EDCH Content)");\r\nexpert_add_info_format(pinfo, ti, &ei_mac_unknown_content, "Unknown EDCH Content");\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int dissect_mac_fdd_hsdsch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nproto_tree *hsdsch_tree = NULL;\r\nproto_item *channel_type;\r\nfp_info *fpinf;\r\numts_mac_info *macinf;\r\nguint16 pos;\r\nguint8 bitoffs=0;\r\ntvbuff_t *next_tvb;\r\nproto_item *ti = NULL;\r\nrlc_info * rlcinf;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MAC");\r\nti = proto_tree_add_item(tree, proto_umts_mac, tvb, 0, -1, ENC_NA);\r\nhsdsch_tree = proto_item_add_subtree(ti, ett_mac_hsdsch);\r\nfpinf = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\nmacinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\r\npos = fpinf->cur_tb;\r\nbitoffs = fpinf->hsdsch_entity == ehs ? 0 : 4;\r\nif (!macinf) {\r\nproto_tree_add_expert(hsdsch_tree, pinfo, &ei_mac_per_frame_info_missing, tvb, 0, -1);\r\nreturn 1;\r\n}\r\nif (macinf->ctmux[pos]) {\r\nproto_tree_add_bits_item(hsdsch_tree, hf_mac_ct, tvb, bitoffs, 4, ENC_BIG_ENDIAN);\r\nmacinf->lchid[pos] = tvb_get_bits8(tvb,bitoffs,4)+1;\r\nmacinf->fake_chid[pos] = FALSE;\r\nmacinf->content[pos] = lchId_type_table[macinf->lchid[pos]];\r\nrlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0);\r\nrlcinf->rbid[pos] = macinf->lchid[pos];\r\nrlcinf->mode[pos] = lchId_rlc_map[macinf->lchid[pos]];\r\nbitoffs += 4;\r\n}\r\nif ((bitoffs % 8) == 0) {\r\nnext_tvb = tvb_new_subset_remaining(tvb, bitoffs/8);\r\n} else {\r\nnext_tvb = tvb_new_octet_aligned(tvb, bitoffs, macinf->pdu_len);\r\nadd_new_data_source(pinfo, next_tvb, "Octet-Aligned HSDSCH Data");\r\n}\r\nswitch (macinf->content[pos]) {\r\ncase MAC_CONTENT_CCCH:\r\nproto_item_append_text(ti, " (CCCH)");\r\nchannel_type = proto_tree_add_uint(hsdsch_tree, hf_mac_lch_id, tvb, 0, 0, macinf->lchid[pos]);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nif(macinf->lchid[pos] != 255){\r\nif(macinf->fake_chid[pos]){\r\nexpert_add_info(pinfo, channel_type, &ei_mac_faked_logical_channel_id);\r\n}\r\n}else{\r\nexpert_add_info(pinfo, channel_type, &ei_mac_no_logical_channel);\r\n}\r\nchannel_type = proto_tree_add_uint(hsdsch_tree, hf_mac_channel, tvb, 0, 0, MAC_DCCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nchannel_type = proto_tree_add_uint(hsdsch_tree, hf_mac_macdflowd_id, tvb, 0, 0, macinf->macdflow_id[pos]);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\ncall_dissector_with_data(rlc_ccch_handle, next_tvb, pinfo, tree, data);\r\nbreak;\r\ncase MAC_CONTENT_DCCH:\r\nproto_item_append_text(ti, " (DCCH)");\r\nchannel_type = proto_tree_add_uint(hsdsch_tree, hf_mac_lch_id, tvb, 0, 0, macinf->lchid[pos]);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nif(macinf->lchid[pos] != 255){\r\nif(macinf->fake_chid[pos]){\r\nexpert_add_info(pinfo, channel_type, &ei_mac_faked_logical_channel_id);\r\n}\r\n}else{\r\nexpert_add_info(pinfo, channel_type, &ei_mac_no_logical_channel);\r\n}\r\nchannel_type = proto_tree_add_uint(hsdsch_tree, hf_mac_channel, tvb, 0, 0, MAC_DCCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nchannel_type = proto_tree_add_uint(hsdsch_tree, hf_mac_macdflowd_id, tvb, 0, 0, macinf->macdflow_id[pos]);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\ncall_dissector_with_data(rlc_dcch_handle, next_tvb, pinfo, tree, data);\r\nbreak;\r\ncase MAC_CONTENT_PS_DTCH:\r\nproto_item_append_text(ti, " (PS DTCH)");\r\nchannel_type = proto_tree_add_uint(hsdsch_tree, hf_mac_lch_id, tvb, 0, 0, macinf->lchid[pos]);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nif(macinf->lchid[pos] != 255){\r\nif(macinf->fake_chid[pos]){\r\nexpert_add_info(pinfo, channel_type, &ei_mac_faked_logical_channel_id);\r\n}\r\n}else{\r\nexpert_add_info(pinfo, channel_type, &ei_mac_no_logical_channel);\r\n}\r\nchannel_type = proto_tree_add_uint(hsdsch_tree, hf_mac_channel, tvb, 0, 0, MAC_DTCH);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\nchannel_type = proto_tree_add_uint(hsdsch_tree, hf_mac_macdflowd_id, tvb, 0, 0, macinf->macdflow_id[pos]);\r\nPROTO_ITEM_SET_GENERATED(channel_type);\r\ncall_dissector_with_data(rlc_ps_dtch_handle, next_tvb, pinfo, tree, data);\r\nbreak;\r\ncase MAC_CONTENT_CS_DTCH:\r\nproto_item_append_text(ti, " (CS DTCH)");\r\nbreak;\r\ndefault:\r\nproto_item_append_text(ti, " (Unknown HSDSCH Content)");\r\nexpert_add_info_format(pinfo, NULL, &ei_mac_unknown_content, "Unknown HSDSCH Content");\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void mac_is_sdus_hash_destroy(gpointer data)\r\n{\r\ng_hash_table_destroy((GHashTable *)data);\r\n}\r\nstatic void mac_init(void)\r\n{\r\nmac_is_sdus = g_hash_table_new_full(mac_is_channel_hash, mac_is_channel_equal, NULL, mac_is_sdus_hash_destroy);\r\nmac_is_fragments = g_hash_table_new_full(mac_is_channel_hash, mac_is_channel_equal, NULL, NULL);\r\nif (global_mac_tsn_size == MAC_TSN_6BITS) {\r\nMAX_TSN = 64;\r\nmac_tsn_size = 6;\r\n} else {\r\nMAX_TSN = 16384;\r\nmac_tsn_size = 14;\r\n}\r\n}\r\nstatic void mac_cleanup(void)\r\n{\r\ng_hash_table_destroy(mac_is_sdus);\r\ng_hash_table_destroy(mac_is_fragments);\r\n}\r\nvoid\r\nproto_register_umts_mac(void)\r\n{\r\nmodule_t *mac_module;\r\nstatic gint *ett[] = {\r\n&ett_mac,\r\n&ett_mac_fach,\r\n&ett_mac_rach,\r\n&ett_mac_dch,\r\n&ett_mac_pch,\r\n&ett_mac_edch,\r\n&ett_mac_hsdsch,\r\n&ett_mac_edch_type2,\r\n&ett_mac_edch_type2_sdu\r\n};\r\nstatic hf_register_info hf[] = {\r\n{ &hf_mac_rach_fdd_tctf,\r\n{ "Target Channel Type Field", "mac.tctf",\r\nFT_UINT8, BASE_HEX, VALS(rach_fdd_tctf_vals), 0, NULL, HFILL }\r\n},\r\n{ &hf_mac_fach_fdd_tctf,\r\n{ "Target Channel Type Field", "mac.tctf",\r\nFT_UINT8, BASE_HEX, VALS(fach_fdd_tctf_vals), 0, NULL, HFILL }\r\n},\r\n{ &hf_mac_ct,\r\n{ "C/T", "mac.ct",\r\nFT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_mac_ueid_type,\r\n{ "UEID Type", "mac.ueid_type",\r\nFT_UINT8, BASE_DEC, VALS(ueid_type_vals), 0, NULL, HFILL }\r\n},\r\n{ &hf_mac_crnti,\r\n{ "C-RNTI (UEID)", "mac.ueid",\r\nFT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_mac_urnti,\r\n{ "U-RNTI (UEID)", "mac.ueid",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_mac_channel,\r\n{ "Logical Channel Type", "mac.logical_channel",\r\nFT_UINT16, BASE_DEC, VALS(mac_logical_channel_vals), 0, NULL, HFILL }\r\n},\r\n#if 0\r\n{ &hf_mac_channel_str,\r\n{ "Logical Channel", "mac.logical_channel",\r\nFT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }\r\n},\r\n#endif\r\n#if 0\r\n{ &hf_mac_channel_hsdsch,\r\n{ "MACd-FlowID", "mac.macd_flowid", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n#endif\r\n{ &hf_mac_macdflowd_id,\r\n{ "MACd-FlowID", "mac.macd_flowid", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_mac_lch_id,\r\n{ "Logical Channel ID", "mac.logical_channel_id", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_mac_trch_id,\r\n{ "Transport Channel ID", "mac.transport_channel_id", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n#if 0\r\n{ &hf_mac_edch_type2_descriptors,\r\n{ "MAC-is Descriptors",\r\n"mac.edch.type2.descriptors", FT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n#endif\r\n#if 0\r\n{ &hf_mac_edch_type2_lchid,\r\n{ "LCH-ID",\r\n"mac.logical_channel_id", FT_UINT8, BASE_HEX, NULL, 0xf0,\r\nNULL, HFILL\r\n}\r\n},\r\n#endif\r\n#if 0\r\n{ &hf_mac_edch_type2_length,\r\n{ "Length",\r\n"mac.edch.type2.length", FT_UINT16, BASE_DEC, NULL, 0x0ffe,\r\nNULL, HFILL\r\n}\r\n},\r\n#endif\r\n#if 0\r\n{ &hf_mac_edch_type2_flag,\r\n{ "Flag",\r\n"mac.edch.type2.lchid", FT_UINT8, BASE_HEX, NULL, 0x01,\r\n"Indicates if another entry follows", HFILL\r\n}\r\n},\r\n#endif\r\n{ &hf_mac_edch_type2_ss,\r\n{ "SS",\r\n"mac.edch.type2.ss", FT_UINT8, BASE_HEX, NULL, 0xc0,\r\n"Segmentation Status", HFILL\r\n}\r\n},\r\n{ &hf_mac_edch_type2_ss_interpretation,\r\n{ "SS interpretation",\r\n"mac.edch.type2.ss_interpretation", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mac_edch_type2_tsn,\r\n{ "TSN",\r\n"mac.edch.type2.tsn", FT_UINT16, BASE_DEC, NULL, 0,\r\n"Transmission Sequence Number", HFILL\r\n}\r\n},\r\n{ &hf_mac_edch_type2_sdu,\r\n{ "MAC-is SDU",\r\n"mac.edch.type2.sdu", FT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mac_edch_type2_sdu_data,\r\n{ "Data",\r\n"mac.edch.type2.sdu.data", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n#if 0\r\n{ &hf_mac_edch_type2_subframe_header,\r\n{ "Subframe header",\r\n"mac.edch.type2.subframeheader", FT_STRING, BASE_NONE, NULL, 0x0,\r\n"EDCH Subframe header", HFILL\r\n}\r\n},\r\n#endif\r\n{ &hf_mac_is_reasmin,\r\n{ "Reassembled in frame", "mac.is.reasmin",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_mac_is_fraglink,\r\n{ "Frame", "mac.is.fraglink",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0, NULL, HFILL }\r\n}\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_mac_per_frame_info_missing, { "mac.per_frame_info_missing", PI_MALFORMED, PI_ERROR, "Cannot dissect MAC frame because per-frame info is missing", EXPFILL }},\r\n{ &ei_mac_unknown_content, { "mac.unknown_content", PI_MALFORMED, PI_ERROR, "Unknown RACH DCCH/DTCH Content", EXPFILL }},\r\n{ &ei_mac_rach_tctf_unknown, { "mac.rach_tctf.unknown", PI_MALFORMED, PI_ERROR, "Unknown RACH TCTF", EXPFILL }},\r\n{ &ei_mac_cs_dtch_not_implemented, { "mac.cs_dtch.not_implemented", PI_DEBUG, PI_ERROR, "CS DTCH Is not implemented", EXPFILL }},\r\n{ &ei_mac_fach_content_type_unknown, { "mac.fach_content_type.unknown", PI_UNDECODED, PI_WARN, " Unimplemented FACH Content type!", EXPFILL }},\r\n{ &ei_mac_no_logical_channel, { "mac.no_logical_channel", PI_PROTOCOL, PI_WARN, "Frame is missing logical channel", EXPFILL }},\r\n{ &ei_mac_faked_logical_channel_id, { "mac.faked_logical_channel_id", PI_PROTOCOL, PI_WARN, "This is a faked logical channel id!", EXPFILL }},\r\n{ &ei_mac_macis_sdu_reassembled, { "mac.macis_sdu.reassembled", PI_REASSEMBLE, PI_CHAT, "Reassembled MAC-is SDU", EXPFILL }},\r\n{ &ei_mac_macis_sdu_first, { "mac.macis_sdu.first", PI_REASSEMBLE, PI_CHAT, "This MAC-is SDU is the first segment of a MAC-d PDU or MAC-c PDU", EXPFILL }},\r\n{ &ei_mac_macis_sdu_middle, { "mac.macis_sdu.middle", PI_REASSEMBLE, PI_CHAT, "This MAC-is SDU is a middle segment of a MAC-d PDU or MAC-c PDU", EXPFILL }},\r\n{ &ei_mac_macis_sdu_last, { "mac.macis_sdu.last", PI_REASSEMBLE, PI_CHAT, "This MAC-is SDU is the last segment of a MAC-d PDU or MAC-c PDU", EXPFILL }},\r\n{ &ei_mac_macis_sdu_complete, { "mac.macis_sdu.complete", PI_REASSEMBLE, PI_CHAT, "This MAC-is SDU is a complete MAC-d PDU or MAC-c PDU", EXPFILL }},\r\n};\r\nexpert_module_t* expert_umts_mac;\r\nproto_umts_mac = proto_register_protocol("MAC", "MAC", "mac");\r\nproto_register_field_array(proto_umts_mac, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_umts_mac = expert_register_protocol(proto_umts_mac);\r\nexpert_register_field_array(expert_umts_mac, ei, array_length(ei));\r\nregister_dissector("mac.fdd.rach", dissect_mac_fdd_rach, proto_umts_mac);\r\nregister_dissector("mac.fdd.fach", dissect_mac_fdd_fach, proto_umts_mac);\r\nregister_dissector("mac.fdd.pch", dissect_mac_fdd_pch, proto_umts_mac);\r\nregister_dissector("mac.fdd.dch", dissect_mac_fdd_dch, proto_umts_mac);\r\nregister_dissector("mac.fdd.edch", dissect_mac_fdd_edch, proto_umts_mac);\r\nregister_dissector("mac.fdd.edch.type2", dissect_mac_fdd_edch_type2, proto_umts_mac);\r\nregister_dissector("mac.fdd.hsdsch", dissect_mac_fdd_hsdsch, proto_umts_mac);\r\nregister_init_routine(mac_init);\r\nregister_cleanup_routine(mac_cleanup);\r\nmac_module = prefs_register_protocol(proto_umts_mac, NULL);\r\nprefs_register_enum_preference(mac_module, "tsn_size", "TSN size",\r\n"TSN size in bits, either 6 or 14 bit",\r\n&global_mac_tsn_size, tsn_size_enumvals, FALSE);\r\n}\r\nvoid\r\nproto_reg_handoff_umts_mac(void)\r\n{\r\nrlc_pcch_handle = find_dissector_add_dependency("rlc.pcch", proto_umts_mac);\r\nrlc_ccch_handle = find_dissector_add_dependency("rlc.ccch", proto_umts_mac);\r\nrlc_ctch_handle = find_dissector_add_dependency("rlc.ctch", proto_umts_mac);\r\nrlc_dcch_handle = find_dissector_add_dependency("rlc.dcch", proto_umts_mac);\r\nrlc_ps_dtch_handle = find_dissector_add_dependency("rlc.ps_dtch", proto_umts_mac);\r\nrrc_handle = find_dissector_add_dependency("rrc", proto_umts_mac);\r\n}
