static int dissect_ismacryp_v11(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, PROTO_TAG_ISMACRYP_11);\r\ncol_set_str(pinfo->cinfo, COL_INFO, "(PT=enc-mpeg4-generic)");\r\ndissect_ismacryp_common( tvb, pinfo, tree, V11);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int dissect_ismacryp_v20(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, PROTO_TAG_ISMACRYP_20);\r\ncol_set_str(pinfo->cinfo, COL_INFO, "(PT=enc-isoff-generic)");\r\ndissect_ismacryp_common( tvb, pinfo, tree, V20);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int dissect_ismacryp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Manual version");\r\ndissect_ismacryp_common( tvb, pinfo, tree, version_type);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void dissect_ismacryp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint ismacryp_version)\r\n{\r\nguint set_version;\r\nproto_item *ismacryp_item;\r\nproto_tree *ismacryp_tree;\r\nproto_tree *ismacryp_message_tree;\r\nif ((ismacryp_version != version_type) && override_flag) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, " Manual version");\r\nset_version = version_type;\r\n}\r\nelse {\r\nset_version = ismacryp_version;\r\n}\r\nif (set_version == V11) {\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, PROTO_TAG_ISMACRYP_11);\r\nif (pref_user_mode == FALSE) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %s", val_to_str_const(mode, modetypenames, "user mode"));\r\n} else {\r\ncol_append_str(pinfo->cinfo, COL_INFO, ", user mode");\r\n}\r\nuser_mode = pref_user_mode;\r\n}\r\nif (set_version == V20) {\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, PROTO_TAG_ISMACRYP_20);\r\nuser_mode = TRUE;\r\ncol_append_str(pinfo->cinfo, COL_INFO, ", user mode");\r\n}\r\nif (user_mode == TRUE) {\r\nau_size_length = pref_au_size_length;\r\nau_index_length = pref_au_index_length;\r\nau_index_delta_length = pref_au_index_delta_length;\r\ncts_delta_length = pref_cts_delta_length;\r\ndts_delta_length = pref_dts_delta_length;\r\nrandom_access_indication = pref_random_access_indication;\r\nstream_state_indication = pref_stream_state_indication;\r\n}\r\nif (user_mode == FALSE) {\r\nswitch (mode) {\r\ncase AAC_HBR_MODE:\r\nau_size_length = 13;\r\nau_index_length = 3;\r\nau_index_delta_length = 3;\r\ncts_delta_length = 0;\r\ndts_delta_length = 0;\r\nrandom_access_indication = FALSE;\r\nstream_state_indication = 0;\r\nbreak;\r\ncase MPEG4_VIDEO_MODE:\r\nau_size_length = 0;\r\nau_index_length = 0;\r\nau_index_delta_length = 0;\r\ncts_delta_length = 0;\r\ndts_delta_length = 22;\r\nrandom_access_indication = TRUE;\r\nstream_state_indication = 0;\r\nbreak;\r\ncase AVC_VIDEO_MODE:\r\nau_size_length = 0;\r\nau_index_length = 0;\r\nau_index_delta_length = 0;\r\ncts_delta_length = 0;\r\ndts_delta_length = 22;\r\nrandom_access_indication = TRUE;\r\nstream_state_indication = 0;\r\nbreak;\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nbreak;\r\n}\r\n}\r\n{\r\nguint16 au_headers_length;\r\nguint16 totalbits;\r\nint deltabits;\r\noffset_struct s_offset;\r\noffset_struct* poffset;\r\nguint16 nbmessage_bytes;\r\ns_offset.offset_bytes = 0;\r\ns_offset.offset_bits = 0;\r\npoffset = &s_offset;\r\nismacryp_item = proto_tree_add_item(tree, proto_ismacryp, tvb, 0, -1, ENC_NA);\r\nismacryp_tree = proto_item_add_subtree(ismacryp_item, ett_ismacryp);\r\nproto_item_append_text(tree, ", %s", "ismacryp packet");\r\nismacryp_item = proto_tree_add_item(ismacryp_tree, hf_ismacryp_au_headers_length,\r\ntvb, poffset->offset_bytes, AU_HEADERS_LENGTH_SIZE, ENC_BIG_ENDIAN );\r\nproto_item_append_text(ismacryp_item, " (bits)");\r\nau_headers_length = tvb_get_ntohs(tvb, poffset->offset_bytes);\r\npoffset->offset_bytes += AU_HEADERS_LENGTH_SIZE;\r\ntotalbits = (poffset->offset_bytes*8) + poffset->offset_bits;\r\ndeltabits = 1;\r\nwhile( ((totalbits - 8*AU_HEADERS_LENGTH_SIZE)<au_headers_length) && deltabits != 0 )\r\n{\r\npoffset = dissect_auheader( tvb, poffset, pinfo, ismacryp_tree, set_version);\r\ndeltabits = (poffset->offset_bytes*8) + poffset->offset_bits - totalbits;\r\ntotalbits += deltabits;\r\n}\r\nif ( (totalbits - 8*AU_HEADERS_LENGTH_SIZE) != au_headers_length)\r\n{\r\nproto_item_append_text(ismacryp_item,\r\n" Error - expected total AU headers size (%d bits) "\r\n"does not match calculated size (%d bits) - check parameters!",\r\nau_headers_length, (totalbits - 8*AU_HEADERS_LENGTH_SIZE));\r\n}\r\nif (poffset->offset_bits != 0)\r\n{\r\nguint16 totalbit_offset;\r\nint nbpadding_bits;\r\ntotalbit_offset = (poffset->offset_bytes)*8 + poffset->offset_bits;\r\nnbpadding_bits = (8 - poffset->offset_bits);\r\nismacryp_item = proto_tree_add_bits_item(ismacryp_tree, hf_ismacryp_padding,\r\ntvb, totalbit_offset, nbpadding_bits , ENC_BIG_ENDIAN);\r\nproto_item_append_text(ismacryp_item, ": Length=%d bits", nbpadding_bits);\r\nadd_bits(poffset, nbpadding_bits);\r\n}\r\nismacryp_item = proto_tree_add_item( ismacryp_tree, hf_ismacryp_message,\r\ntvb, poffset->offset_bytes, -1, ENC_NA );\r\nismacryp_message_tree = proto_item_add_subtree(ismacryp_item, ett_ismacryp_message);\r\nproto_item_append_text(ismacryp_item, ", %s", "Encrypted data");\r\nnbmessage_bytes = tvb_reported_length_remaining(tvb, poffset->offset_bytes);\r\nproto_item_append_text(ismacryp_item, ", Length= %d bytes", nbmessage_bytes );\r\nif (ismacryp_message_tree)\r\n{\r\npoffset->offset_bytes += nbmessage_bytes;\r\n}\r\n}\r\n}\r\nstatic offset_struct* dissect_auheader( tvbuff_t *tvb, offset_struct *poffset, packet_info *pinfo, proto_tree *ismacryp_tree, guint set_version )\r\n{\r\nproto_item *ismacryp_item;\r\nproto_tree *ismacryp_header_tree;\r\nproto_tree *ismacryp_header_byte_tree;\r\nguint16 header_len_bytes = 0;\r\ngint header_len = 0;\r\ngint cts_flag =0;\r\ngint dts_flag =0;\r\ngboolean first_au_flag = FALSE;\r\ngint bit_offset = 0;\r\nswitch (set_version) {\r\ncase V11:\r\nif (selective_encryption)\r\nheader_len += 8;\r\nbreak;\r\ncase V20:\r\nif (selective_encryption || slice_indication || padding_indication)\r\nheader_len += 8;\r\nbreak;\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nbreak;\r\n}\r\nheader_len += au_size_length;\r\nif (poffset->offset_bytes == AU_HEADERS_LENGTH_SIZE) {\r\nheader_len += 8*(iv_length);\r\nheader_len += 8*key_indicator_length;\r\nheader_len += au_index_length;\r\nfirst_au_flag = TRUE;\r\n}\r\nelse {\r\nif (key_indicator_per_au_flag == TRUE)\r\nheader_len += 8*key_indicator_length;\r\nheader_len += 8*(delta_iv_length);\r\nheader_len += au_index_delta_length;\r\n}\r\nif (cts_delta_length != 0) {\r\ncts_flag = tvb_get_bits8(tvb, AU_HEADERS_LENGTH_SIZE*8 + header_len, 1);\r\nheader_len += 1;\r\nif (cts_flag == 1)\r\nheader_len += cts_delta_length;\r\n}\r\nif (dts_delta_length != 0) {\r\ndts_flag = tvb_get_bits8(tvb, AU_HEADERS_LENGTH_SIZE*8 + header_len, 1);\r\nheader_len += 1;\r\nif (dts_flag == 1)\r\nheader_len += dts_delta_length;\r\n}\r\nif (random_access_indication != FALSE)\r\nheader_len += 1;\r\nif (stream_state_indication !=0)\r\nheader_len += stream_state_indication;\r\nif (header_len% 8 != 0)\r\n{\r\nheader_len_bytes = ((header_len)/8) + 1;\r\n}\r\nelse\r\nheader_len_bytes = ((header_len)/8);\r\nismacryp_item = proto_tree_add_item(ismacryp_tree, hf_ismacryp_header, tvb, poffset->offset_bytes, header_len_bytes, ENC_NA );\r\nproto_item_append_text(ismacryp_item, ": Length=%d bits", header_len);\r\nif ( header_len == 0)\r\n{\r\nproto_item_append_text(ismacryp_item, " Error - zero bit AU header size - check parameters!");\r\n}\r\nismacryp_header_tree = proto_item_add_subtree(ismacryp_item, ett_ismacryp_header);\r\nif ((set_version == V20 && (selective_encryption || slice_indication || padding_indication))\r\n|| (set_version == V11 && selective_encryption)) {\r\nismacryp_item = proto_tree_add_item(ismacryp_header_tree, hf_ismacryp_header_byte,\r\ntvb, poffset->offset_bytes, 1, ENC_NA );\r\nproto_item_append_text(ismacryp_item, ": Length=8 bits");\r\nismacryp_header_byte_tree = proto_item_add_subtree(ismacryp_item, ett_ismacryp_header_byte);\r\nadd_bits(poffset, 7);\r\nbit_offset = (poffset->offset_bytes)*8 + poffset->offset_bits;\r\nif (selective_encryption) {\r\nproto_tree_add_bits_item(ismacryp_header_byte_tree, hf_ismacryp_au_is_encrypted,\r\ntvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_bits_item(ismacryp_header_byte_tree, hf_ismacryp_unused_bits,\r\ntvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nswitch (set_version) {\r\ncase V11:\r\nadd_bits(poffset, -7);\r\nbit_offset = (poffset->offset_bytes)*8 + poffset->offset_bits;\r\nproto_tree_add_bits_item(ismacryp_header_byte_tree, hf_ismacryp_reserved_bits,\r\ntvb, bit_offset, 7, ENC_BIG_ENDIAN);\r\nadd_bits(poffset, 8);\r\nbreak;\r\ncase V20:\r\nadd_bits(poffset, -1);\r\nbit_offset = (poffset->offset_bytes)*8 + poffset->offset_bits;\r\nif (slice_indication) {\r\nproto_tree_add_bits_item(ismacryp_header_byte_tree, hf_ismacryp_slice_start,\r\ntvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_bits_item(ismacryp_header_byte_tree, hf_ismacryp_unused_bits,\r\ntvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nadd_bits(poffset, -1);\r\nbit_offset = (poffset->offset_bytes)*8 + poffset->offset_bits;\r\nif (slice_indication) {\r\nproto_tree_add_bits_item(ismacryp_header_byte_tree, hf_ismacryp_slice_end,\r\ntvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_bits_item(ismacryp_header_byte_tree, hf_ismacryp_unused_bits,\r\ntvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nadd_bits(poffset, -3);\r\nbit_offset = (poffset->offset_bytes)*8 + poffset->offset_bits;\r\nif (padding_indication) {\r\nproto_tree_add_bits_item(ismacryp_header_byte_tree, hf_ismacryp_padding_bitcount,\r\ntvb, bit_offset, 3, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_bits_item(ismacryp_header_byte_tree, hf_ismacryp_unused_bits,\r\ntvb, bit_offset, 3, ENC_BIG_ENDIAN);\r\n}\r\nadd_bits(poffset, -2);\r\nbit_offset = (poffset->offset_bytes)*8 + poffset->offset_bits;\r\nproto_tree_add_bits_item(ismacryp_header_byte_tree, hf_ismacryp_reserved_bits,\r\ntvb, bit_offset, 2, ENC_BIG_ENDIAN);\r\nadd_bits(poffset, 8);\r\nbreak;\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nbreak;\r\n}\r\n}\r\nif (first_au_flag == TRUE && iv_length != 0)\r\n{\r\nismacryp_item = proto_tree_add_item(ismacryp_header_tree, hf_ismacryp_iv, tvb, poffset->offset_bytes, iv_length, ENC_NA);\r\nproto_item_append_text(ismacryp_item, ": Length=%d bytes", iv_length);\r\ncol_append_fstr( pinfo->cinfo, COL_INFO,\r\n", IV=0x%s", tvb_bytes_to_str_punct(wmem_packet_scope(), tvb, poffset->offset_bytes, iv_length, ' '));\r\npoffset->offset_bytes += iv_length;\r\n}\r\nif (first_au_flag == FALSE && delta_iv_length != 0)\r\n{\r\nismacryp_item = proto_tree_add_item(ismacryp_header_tree, hf_ismacryp_delta_iv,\r\ntvb, poffset->offset_bytes, delta_iv_length, ENC_NA);\r\nproto_item_append_text(ismacryp_item, ": Length=%d bytes", delta_iv_length);\r\ncol_append_fstr( pinfo->cinfo, COL_INFO,\r\n", Delta IV=0x%s", tvb_bytes_to_str_punct(wmem_packet_scope(), tvb, poffset->offset_bytes, delta_iv_length, ' '));\r\npoffset->offset_bytes += delta_iv_length;\r\n}\r\nif ( key_indicator_length != 0 && ( first_au_flag == TRUE || key_indicator_per_au_flag == TRUE) )\r\n{\r\nismacryp_item = proto_tree_add_item(ismacryp_header_tree, hf_ismacryp_key_indicator,\r\ntvb, poffset->offset_bytes, key_indicator_length, ENC_NA);\r\nproto_item_append_text(ismacryp_item, ": Length=%d bytes", key_indicator_length);\r\ncol_append_fstr( pinfo->cinfo, COL_INFO,\r\n", KI=0x%s", tvb_bytes_to_str_punct(wmem_packet_scope(), tvb, poffset->offset_bytes, key_indicator_length, ' '));\r\npoffset->offset_bytes += key_indicator_length;\r\n}\r\nif (au_size_length != 0)\r\n{\r\nbit_offset = (poffset->offset_bytes)*8 + poffset->offset_bits;\r\nismacryp_item = proto_tree_add_bits_item(ismacryp_header_tree, hf_ismacryp_au_size,\r\ntvb, bit_offset, au_size_length, ENC_BIG_ENDIAN);\r\nproto_item_append_text(ismacryp_item, " bytes: Length=%d bits", au_size_length);\r\nadd_bits(poffset, au_size_length);\r\n}\r\nif (first_au_flag == TRUE && au_index_length != 0)\r\n{\r\nbit_offset = (poffset->offset_bytes)*8 + poffset->offset_bits;\r\nismacryp_item = proto_tree_add_bits_item(ismacryp_header_tree, hf_ismacryp_au_index,\r\ntvb, bit_offset, au_index_length, ENC_BIG_ENDIAN);\r\nproto_item_append_text(ismacryp_item, " bits: Length=%d bits", au_index_length);\r\nadd_bits(poffset, au_index_length);\r\n}\r\nif (first_au_flag == FALSE && au_index_delta_length != 0)\r\n{\r\nbit_offset = (poffset->offset_bytes)*8 + poffset->offset_bits;\r\nismacryp_item = proto_tree_add_bits_item(ismacryp_header_tree, hf_ismacryp_au_index_delta,\r\ntvb, bit_offset, au_index_delta_length, ENC_BIG_ENDIAN);\r\nproto_item_append_text(ismacryp_item, ": Length=%d bits", au_index_delta_length);\r\nadd_bits(poffset, au_index_delta_length);\r\n}\r\nif (cts_delta_length != 0)\r\n{\r\nbit_offset = (poffset->offset_bytes)*8 + poffset->offset_bits;\r\nproto_tree_add_bits_item(ismacryp_header_tree, hf_ismacryp_cts_flag,\r\ntvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nadd_bits(poffset, 1);\r\nif (cts_flag == 1)\r\n{\r\nbit_offset = (poffset->offset_bytes)*8 + poffset->offset_bits;\r\nismacryp_item = proto_tree_add_bits_item(ismacryp_header_tree, hf_ismacryp_cts_delta,\r\ntvb, bit_offset, cts_delta_length, ENC_BIG_ENDIAN);\r\nproto_item_append_text(ismacryp_item, ": Length=%d bits", cts_delta_length);\r\nadd_bits(poffset, cts_delta_length);\r\n}\r\n}\r\nif (dts_delta_length != 0)\r\n{\r\nbit_offset = (poffset->offset_bytes)*8 + poffset->offset_bits;\r\nproto_tree_add_bits_item(ismacryp_header_tree, hf_ismacryp_dts_flag,\r\ntvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nadd_bits(poffset, 1);\r\nif (dts_flag ==1)\r\n{\r\nbit_offset = (poffset->offset_bytes)*8 + poffset->offset_bits;\r\nismacryp_item = proto_tree_add_bits_item(ismacryp_header_tree, hf_ismacryp_dts_delta,\r\ntvb, bit_offset, dts_delta_length, ENC_BIG_ENDIAN);\r\nproto_item_append_text(ismacryp_item, ": Length=%d bits", dts_delta_length);\r\nadd_bits(poffset, dts_delta_length);\r\n}\r\n}\r\nif (random_access_indication != FALSE)\r\n{\r\nbit_offset = (poffset->offset_bytes)*8 + poffset->offset_bits;\r\nproto_tree_add_bits_item(ismacryp_header_tree, hf_ismacryp_rap_flag,\r\ntvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nadd_bits(poffset, 1);\r\n}\r\nif (stream_state_indication != 0)\r\n{\r\nbit_offset = (poffset->offset_bytes)*8 + poffset->offset_bits;\r\nproto_tree_add_bits_item(ismacryp_header_tree, hf_ismacryp_stream_state,\r\ntvb, bit_offset, stream_state_indication, ENC_BIG_ENDIAN);\r\nadd_bits(poffset, stream_state_indication);\r\n}\r\nreturn poffset;\r\n}\r\nstatic void add_bits(offset_struct* poffset, gint len_bits)\r\n{\r\ngint nbbitstotal;\r\nnbbitstotal = poffset->offset_bytes*8 + (poffset->offset_bits) + len_bits;\r\npoffset->offset_bytes = (nbbitstotal / 8);\r\npoffset->offset_bits = (nbbitstotal % 8);\r\n}\r\nvoid proto_register_ismacryp (void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n#if 0\r\n{ &hf_ismacryp,\r\n{ "Data", "ismacryp.data", FT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n#endif\r\n#if 0\r\n{ &hf_ismacryp_length,\r\n{ "Total Length", "ismacryp.len", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n#endif\r\n{ &hf_ismacryp_header,\r\n{ "AU Header", "ismacryp.header", FT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n#if 0\r\n{ &hf_ismacryp_header_length,\r\n{ "Header Length", "ismacryp.header.length", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n#endif\r\n{ &hf_ismacryp_au_headers_length,\r\n{ "AU Headers Length", "ismacryp.au_headers.length", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_header_byte,\r\n{ "Header Byte", "ismacryp.header.byte", FT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n#if 0\r\n{ &hf_ismacryp_version,\r\n{ "Version", "ismacryp.version", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n#endif\r\n{ &hf_ismacryp_message,\r\n{ "Message", "ismacryp.message", FT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n#if 0\r\n{ &hf_ismacryp_message_length,\r\n{ "Message Length", "ismacryp.message.len", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n#endif\r\n#if 0\r\n{ &hf_ismacryp_parameter,\r\n{ "Parameter", "ismacryp.parameter", FT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n#endif\r\n#if 0\r\n{ &hf_ismacryp_parameter_length,\r\n{ "Parameter Length", "ismacryp.parameter.len", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n#endif\r\n{ &hf_ismacryp_iv,\r\n{ "IV", "ismacryp.iv", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_delta_iv,\r\n{ "Delta IV", "ismacryp.delta_iv", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_key_indicator,\r\n{ "Key Indicator", "ismacryp.key_indicator", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n#if 0\r\n{ &hf_ismacryp_parameter_value,\r\n{ "Parameter Value", "ismacryp.parameter.value", FT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n#endif\r\n{ &hf_ismacryp_au_size,\r\n{ "AU size", "ismacryp.au.size", FT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_au_index,\r\n{ "AU index", "ismacryp.au.index", FT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_au_index_delta,\r\n{ "AU index delta", "ismacryp.au.index_delta", FT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_cts_delta,\r\n{ "CTS delta", "ismacryp.cts_delta", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_cts_flag,\r\n{ "CTS flag", "ismacryp.cts_flag", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_dts_delta,\r\n{ "DTS delta", "ismacryp.dts_delta", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_dts_flag,\r\n{ "DTS flag", "ismacryp.dts_flag", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_rap_flag,\r\n{ "RAP flag", "ismacryp.rap_flag", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_stream_state,\r\n{ "Stream state", "ismacryp.stream_state", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_au_is_encrypted,\r\n{ "AU_is_encrypted flag", "ismacryp.au_is_encrypted", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_slice_start,\r\n{ "Slice_start flag", "ismacryp.slice_start", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_slice_end,\r\n{ "Slice_end flag", "ismacryp.slice_end", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_padding_bitcount,\r\n{ "Padding_bitcount bits", "ismacryp.padding_bitcount", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_padding,\r\n{ "Padding bits", "ismacryp.padding", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_reserved_bits,\r\n{ "Reserved bits", "ismacryp.reserved", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ismacryp_unused_bits,\r\n{ "Unused bits", "ismacryp.unused", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }}\r\n};\r\nstatic gint *ett[] =\r\n{\r\n&ett_ismacryp,\r\n&ett_ismacryp_header,\r\n&ett_ismacryp_header_byte,\r\n&ett_ismacryp_message\r\n};\r\nstatic const enum_val_t version_types[] = {\r\n{PROTO_TAG_ISMACRYP_11, "ISMACryp v1.1", V11},\r\n{PROTO_TAG_ISMACRYP_20, "ISMACryp v2.0", V20},\r\n{NULL, NULL, -1}\r\n};\r\nstatic const enum_val_t mode_types[] = {\r\n{"aac-hbr", "aac-hbr", AAC_HBR_MODE},\r\n{"mpeg4-video", "mpeg4-video", MPEG4_VIDEO_MODE},\r\n{"avc-video", "avc-video", AVC_VIDEO_MODE},\r\n{NULL, NULL, -1}\r\n};\r\nmodule_t *ismacryp_module;\r\nproto_ismacryp = proto_register_protocol ("ISMACryp Protocol", "ISMACRYP", "ismacryp");\r\nproto_register_field_array (proto_ismacryp, hf, array_length (hf));\r\nproto_register_subtree_array (ett, array_length (ett));\r\nismacryp_module = prefs_register_protocol(proto_ismacryp, proto_reg_handoff_ismacryp);\r\nprefs_register_uint_preference(ismacryp_module, "dynamic.payload.type",\r\n"ISMACryp dynamic payload type",\r\n"The dynamic payload type which will be interpreted as ISMACryp",\r\n10,\r\n&pref_dynamic_payload_type);\r\nprefs_register_enum_preference(ismacryp_module, "version",\r\n"ISMACryp version",\r\n"ISMACryp version",\r\n&version_type, version_types, TRUE);\r\nprefs_register_static_text_preference(ismacryp_module, "text_override",\r\n"The following option allows the version to be set manually"\r\n" and to override the version if detected from RTP payload type:",\r\n"The following option allows the version to be set manually"\r\n" and to override the version if detected from RTP payload type:");\r\nprefs_register_bool_preference(ismacryp_module,\r\n"override_rtp_pt", "Override RTP payload type for version",\r\n"Indicates whether or not the ISMACryp version deduced"\r\n" from RTP payload type, if present, is used or whether the"\r\n" version above is used",\r\n&override_flag);\r\nprefs_register_static_text_preference(ismacryp_module,\r\n"v11_parameters",\r\n"ISMACryp v1.1 parameters:",\r\n"ISMACryp v1.1 parameters declared in SDP");\r\nprefs_register_uint_preference(ismacryp_module,\r\n"iv_length", "ISMACrypIVLength (bytes)",\r\n"Set the length of the IV in the ISMACryp AU Header in bytes",\r\n10, &iv_length);\r\nprefs_register_uint_preference(ismacryp_module,\r\n"delta_iv_length", "ISMACrypDeltaIVLength (bytes)",\r\n"Set the length of the Delta IV in the ISMACryp AU Header in bytes",\r\n10, &delta_iv_length);\r\nprefs_register_uint_preference(ismacryp_module,\r\n"key_indicator_length", "ISMACrypKeyIndicatorLength (bytes)",\r\n"Set the length of the Key Indicator in the ISMACryp AU Header in bytes",\r\n10, &key_indicator_length);\r\nprefs_register_bool_preference(ismacryp_module,\r\n"key_indicator_per_au_flag", "ISMACrypKeyIndicatorPerAU (T/F)",\r\n"Indicates whether or not the Key Indicator is present in all AU Headers (T/F)",\r\n&key_indicator_per_au_flag);\r\nprefs_register_bool_preference(ismacryp_module,\r\n"selective_encryption", "ISMACrypSelectiveEncryption (T/F)",\r\n"Indicates whether or not selective encryption is enabled (T/F)",\r\n&selective_encryption);\r\nprefs_register_static_text_preference(ismacryp_module,\r\n"v20_parameters",\r\n"ISMACryp v2.0 parameters:",\r\n"ISMACryp v2.0 parameters declared in SDP");\r\nprefs_register_bool_preference(ismacryp_module,\r\n"slice_indication", "ISMACrypSliceIndication (T/F)",\r\n"Indicates whether or not slice start / end is present (T/F)",\r\n&slice_indication);\r\nprefs_register_bool_preference(ismacryp_module,\r\n"padding_indication", "ISMACrypPaddingIndication (T/F)",\r\n"Indicates whether or not padding information is present (T/F)",\r\n&padding_indication);\r\nprefs_register_static_text_preference(ismacryp_module,\r\n"codec_modes",\r\n"Codec mode selection (RFC3640 for ISMACryp v1.1 only):",\r\n"AU parameters set according to RFC3640 mode or user defined");\r\nprefs_register_enum_preference(ismacryp_module,\r\n"rfc3640_mode",\r\n"RFC3640 mode",\r\n"RFC3640 mode",\r\n&mode, mode_types, TRUE);\r\nprefs_register_bool_preference(ismacryp_module,\r\n"user_mode", "User mode (T/F)",\r\n"Indicates use of user mode instead of RFC3640 modes (T/F)",\r\n&pref_user_mode);\r\nprefs_register_static_text_preference(ismacryp_module,\r\n"user_defined_modes",\r\n"Following parameters only valid and used for user mode:",\r\n"AU parameters defined by the user");\r\nprefs_register_uint_preference(ismacryp_module,\r\n"au_size_length", "User mode: SizeLength (bits)",\r\n"Set the length of the AU size in the AU Header in bits",\r\n10, &pref_au_size_length);\r\nprefs_register_uint_preference(ismacryp_module,\r\n"au_index_length", "User mode: IndexLength (bits)",\r\n"Set the length of the AU index in the AU Header in bits",\r\n10, &pref_au_index_length);\r\nprefs_register_uint_preference(ismacryp_module,\r\n"au_index_delta_length", "User mode: IndexDeltaLength (bits)",\r\n"Set the length of the AU delta index in the AU Header in bits",\r\n10, &pref_au_index_delta_length);\r\nprefs_register_uint_preference(ismacryp_module,\r\n"cts_delta_length", "User mode: CTSDeltaLength (bits)",\r\n"Set the length of the CTS delta field in the AU Header in bits",\r\n10, &pref_cts_delta_length);\r\nprefs_register_uint_preference(ismacryp_module,\r\n"dts_delta_length", "User mode: DTSDeltaLength (bits)",\r\n"Set the length of the DTS delta field in the AU Header in bits",\r\n10, &pref_dts_delta_length);\r\nprefs_register_bool_preference(ismacryp_module,\r\n"random_access_indication", "User mode: RandomAccessIndication (T/F)",\r\n"Indicates whether or not the RAP field is present in the AU Header (T/F)",\r\n&pref_random_access_indication);\r\nprefs_register_uint_preference(ismacryp_module,\r\n"stream_state_indication", "User mode: StreamStateIndication (number of bits)",\r\n"Indicates the number of bits on which the stream state field is encoded"\r\n" in the AU Header (bits)",\r\n10, &pref_stream_state_indication);\r\n}\r\nvoid proto_reg_handoff_ismacryp(void)\r\n{\r\nstatic gboolean ismacryp_prefs_initialized = FALSE;\r\nstatic dissector_handle_t ismacryp_handle;\r\nstatic guint dynamic_payload_type;\r\nif (!ismacryp_prefs_initialized) {\r\ndissector_handle_t ismacryp_v11_handle;\r\ndissector_handle_t ismacryp_v20_handle;\r\nismacryp_handle = create_dissector_handle(dissect_ismacryp, proto_ismacryp);\r\nismacryp_v11_handle = create_dissector_handle(dissect_ismacryp_v11, proto_ismacryp);\r\nismacryp_v20_handle = create_dissector_handle(dissect_ismacryp_v20, proto_ismacryp);\r\nismacryp_prefs_initialized = TRUE;\r\ndissector_add_string("rtp_dyn_payload_type", "ISMACRYP", ismacryp_handle);\r\ndissector_add_string("rtp_dyn_payload_type", "enc-mpeg4-generic", ismacryp_v11_handle);\r\ndissector_add_string("rtp_dyn_payload_type", "enc-isoff-generic", ismacryp_v20_handle);\r\n}\r\nelse {\r\nif ( dynamic_payload_type > 95 ) {\r\ndissector_delete_uint("rtp.pt", dynamic_payload_type, ismacryp_handle);\r\n}\r\n}\r\ndynamic_payload_type = pref_dynamic_payload_type;\r\nif ( dynamic_payload_type > 95 ) {\r\ndissector_add_uint("rtp.pt", dynamic_payload_type, ismacryp_handle);\r\n}\r\n}
