static int\r\ndissect_mpls_y1711(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nstruct mplsinfo *mplsinfo;\r\nint offset = 0;\r\nproto_tree *mpls_y1711_tree;\r\nint functype;\r\ntvbuff_t *data_tvb;\r\nstatic const guint8 allone[] = { 0xff, 0xff };\r\nstatic const guint8 allzero[] = { 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00 };\r\nif (data == NULL)\r\nreturn 0;\r\nmplsinfo = (struct mplsinfo *)data;\r\nfunctype = tvb_get_guint8(tvb, offset);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (Y.1711: %s)",\r\n(functype == 0x01) ? "CV" :\r\n(functype == 0x02) ? "FDI" :\r\n(functype == 0x03) ? "BDI" :\r\n(functype == 0x07) ? "FDD" :\r\n"reserved/unknown");\r\nif (tvb_reported_length(tvb) < 44) {\r\nproto_tree_add_expert(tree, pinfo, &ei_mpls_y1711_minimum_payload, tvb, offset, -1);\r\ndata_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_data_dissector(data_tvb, pinfo, tree);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nmpls_y1711_tree = proto_tree_add_subtree(tree, tvb, offset, 44, ett_mpls_y1711, NULL, "Y.1711 OAM");\r\nif (mplsinfo->label != MPLS_LABEL_OAM_ALERT)\r\nproto_tree_add_expert_format(mpls_y1711_tree, pinfo, &ei_mpls_y1711_no_OAM_alert_label, tvb, offset - 4, 3,\r\n"Warning: Y.1711 but no OAM alert label (%d) ?!", MPLS_LABEL_OAM_ALERT);\r\nif (mplsinfo->exp != 0)\r\nproto_tree_add_expert(mpls_y1711_tree, pinfo, &ei_mpls_y1711_exp_bits_not_zero, tvb, offset - 2, 1);\r\nif (mplsinfo->bos != 1)\r\nproto_tree_add_expert(mpls_y1711_tree, pinfo, &ei_mpls_y1711_s_bit_not_one, tvb, offset - 2, 1);\r\nif (mplsinfo->ttl != 1)\r\nproto_tree_add_expert(mpls_y1711_tree, pinfo, &ei_mpls_y1711_ttl_not_one, tvb, offset - 1, 1);\r\nfunctype = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(mpls_y1711_tree, hf_mpls_y1711_function_type, tvb,\r\noffset, 1,\r\nENC_LITTLE_ENDIAN);\r\noffset++;\r\nswitch (functype) {\r\ncase 0x01:\r\n{\r\nif (tvb_memeql(tvb, offset, allzero, 3) == -1) {\r\nproto_tree_add_expert(mpls_y1711_tree, pinfo, &ei_mpls_y1711_reserved_not_zero, tvb, offset, 3);\r\n}\r\noffset += 3;\r\nif (tvb_memeql(tvb, offset, allzero, 10) == -1) {\r\nproto_tree_add_expert(mpls_y1711_tree, pinfo, &ei_mpls_y1711_padding_not_zero, tvb, offset, 10);\r\n}\r\noffset += 10;\r\nif (tvb_memeql(tvb, offset, allone, 2) == -1) {\r\nproto_tree_add_expert(mpls_y1711_tree, pinfo, &ei_mpls_y1711_padding_not_ff, tvb, offset, 2);\r\n}\r\noffset += 2;\r\nproto_tree_add_item(mpls_y1711_tree, hf_mpls_y1711_lsr_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(mpls_y1711_tree, hf_mpls_y1711_lsp_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nif (tvb_memeql(tvb, offset, allzero, 18) == -1) {\r\nproto_tree_add_expert(mpls_y1711_tree, pinfo, &ei_mpls_y1711_padding_not_zero, tvb, offset, 18);\r\n}\r\noffset += 18;\r\n}\r\nbreak;\r\ncase 0x02:\r\ncase 0x03:\r\n{\r\nif (tvb_memeql(tvb, offset, allzero, 1) == -1) {\r\nproto_tree_add_expert_format(mpls_y1711_tree, pinfo, &ei_mpls_y1711_reserved_not_zero, tvb, offset, 3,\r\n"Error: this byte is reserved and must be 0x00");\r\n}\r\noffset++;\r\nproto_tree_add_item(mpls_y1711_tree, hf_mpls_y1711_defect_type, tvb,\r\noffset, 2,\r\nENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nif (tvb_memeql(tvb, offset, allzero, 20) == 0) {\r\nproto_tree_add_expert(mpls_y1711_tree, pinfo, &ei_mpls_y1711_ttsi_not_preset, tvb, offset, 20);\r\noffset += 20;\r\n} else {\r\nif (tvb_memeql(tvb, offset, allzero, 10) == -1) {\r\nproto_tree_add_expert(mpls_y1711_tree, pinfo, &ei_mpls_y1711_padding_not_zero, tvb, offset, 10);\r\n}\r\noffset += 10;\r\nif (tvb_memeql(tvb, offset, allone, 2) == -1) {\r\nproto_tree_add_expert(mpls_y1711_tree, pinfo, &ei_mpls_y1711_padding_not_ff, tvb, offset, 2);\r\n}\r\noffset += 2;\r\nproto_tree_add_item(mpls_y1711_tree, hf_mpls_y1711_lsr_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(mpls_y1711_tree, hf_mpls_y1711_lsp_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nproto_tree_add_item(mpls_y1711_tree, hf_mpls_y1711_defect_location, tvb,\r\noffset, 4,\r\nENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nif (tvb_memeql(tvb, offset, allzero, 14) == -1) {\r\nproto_tree_add_expert(mpls_y1711_tree, pinfo, &ei_mpls_y1711_padding_not_zero, tvb, offset, 14);\r\n}\r\noffset += 14;\r\n}\r\nbreak;\r\ncase 0x07:\r\n{\r\nif (tvb_memeql(tvb, offset, allzero, 3) == -1) {\r\nproto_tree_add_expert(mpls_y1711_tree, pinfo, &ei_mpls_y1711_reserved_not_zero, tvb, offset, 3);\r\n}\r\noffset += 3;\r\nif (tvb_memeql(tvb, offset, allzero, 10) == -1) {\r\nproto_tree_add_expert(mpls_y1711_tree, pinfo, &ei_mpls_y1711_padding_not_zero, tvb, offset, 10);\r\n}\r\noffset += 10;\r\nif (tvb_memeql(tvb, offset, allone, 2) == -1) {\r\nproto_tree_add_expert(mpls_y1711_tree, pinfo, &ei_mpls_y1711_padding_not_ff, tvb, offset, 2);\r\n}\r\noffset += 2;\r\nproto_tree_add_item(mpls_y1711_tree, hf_mpls_y1711_lsr_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(mpls_y1711_tree, hf_mpls_y1711_lsp_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(mpls_y1711_tree, hf_mpls_y1711_frequency, tvb,\r\noffset, 1,\r\nENC_LITTLE_ENDIAN);\r\noffset++;\r\nif (tvb_memeql(tvb, offset, allzero, 17) == -1) {\r\nproto_tree_add_expert(mpls_y1711_tree, pinfo, &ei_mpls_y1711_padding_not_zero, tvb, offset, 17);\r\n}\r\noffset += 17;\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert(mpls_y1711_tree, pinfo, &ei_mpls_y1711_unknown_pdu, tvb, offset - 1, -1);\r\nreturn offset;\r\n}\r\nproto_tree_add_item(mpls_y1711_tree, hf_mpls_y1711_bip16, tvb, offset, 2,\r\nENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_mpls_y1711(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{\r\n&hf_mpls_y1711_function_type,\r\n{\r\n"Function Type", "mpls_y1711.function_type", FT_UINT8,\r\nBASE_HEX, VALS(y1711_function_type_vals),\r\n0x0, "Function Type codepoint", HFILL\r\n}\r\n},\r\n#if 0\r\n{\r\n&hf_mpls_y1711_ttsi,\r\n{\r\n"Trail Termination Source Identifier",\r\n"mpls_y1711.ttsi",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n#endif\r\n{\r\n&hf_mpls_y1711_frequency,\r\n{\r\n"Frequency", "mpls_y1711.frequency", FT_UINT8,\r\nBASE_HEX, VALS(y1711_frequency_vals), 0x0,\r\n"Frequency of probe injection", HFILL\r\n}\r\n},\r\n{\r\n&hf_mpls_y1711_defect_type,\r\n{\r\n"Defect Type", "mpls_y1711.defect_type", FT_UINT16,\r\nBASE_HEX, VALS(y1711_defect_type_vals), 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_mpls_y1711_defect_location,\r\n{\r\n"Defect Location (AS)", "mpls_y1711.defect_location",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, "Defect Location", HFILL\r\n}\r\n},\r\n{\r\n&hf_mpls_y1711_bip16,\r\n{\r\n"BIP16", "mpls_y1711.bip16", FT_UINT16,\r\nBASE_HEX, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mpls_y1711_lsr_id, { "LSR ID", "mpls_y1711.lsr_id", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_mpls_y1711_lsp_id, { "LSP ID", "mpls_y1711.lsp_id", FT_INT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_mpls_y1711\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_mpls_y1711_minimum_payload, { "mpls_y1711.minimum_payload", PI_MALFORMED, PI_ERROR, "Error: must have a minimum payload length of 44 bytes", EXPFILL }},\r\n{ &ei_mpls_y1711_no_OAM_alert_label, { "mpls_y1711.no_OAM_alert_label", PI_PROTOCOL, PI_WARN, "Warning: Y.1711 but no OAM alert label (%d) ?!", EXPFILL }},\r\n{ &ei_mpls_y1711_exp_bits_not_zero, { "mpls_y1711.exp_bits_not_0", PI_PROTOCOL, PI_WARN, "Warning: Exp bits should be 0 for Y.1711", EXPFILL }},\r\n{ &ei_mpls_y1711_s_bit_not_one, { "mpls_y1711.s_bit_not_1", PI_PROTOCOL, PI_WARN, "Warning: S bit should be 1 for Y.1711", EXPFILL }},\r\n{ &ei_mpls_y1711_ttl_not_one, { "mpls_y1711.ttl_not_1", PI_PROTOCOL, PI_WARN, "Warning: TTL should be 1 for Y.1711", EXPFILL }},\r\n{ &ei_mpls_y1711_reserved_not_zero, { "mpls_y1711.reserved_not_zero", PI_PROTOCOL, PI_WARN, "Error: these bytes are reserved and must be 0x00", EXPFILL }},\r\n{ &ei_mpls_y1711_padding_not_zero, { "mpls_y1711.padding_not_zero", PI_PROTOCOL, PI_WARN, "Error: these bytes are padding and must be 0x00", EXPFILL }},\r\n{ &ei_mpls_y1711_padding_not_ff, { "mpls_y1711.padding_not_ff", PI_PROTOCOL, PI_WARN, "Error: these bytes are padding and must be 0xFF", EXPFILL }},\r\n{ &ei_mpls_y1711_ttsi_not_preset, { "mpls_y1711.ttsi_not_preset", PI_PROTOCOL, PI_NOTE, "TTSI not preset (optional for FDI/BDI)", EXPFILL }},\r\n{ &ei_mpls_y1711_unknown_pdu, { "mpls_y1711.unknown_pdu", PI_PROTOCOL, PI_WARN, "Unknown MPLS Y.1711 PDU", EXPFILL }},\r\n};\r\nexpert_module_t* expert_mpls_y1711;\r\nproto_mpls_y1711 =\r\nproto_register_protocol("MPLS ITU-T Y.1711 OAM",\r\n"MPLS ITU-T Y.1711 OAM",\r\n"mpls_y1711");\r\nproto_register_field_array(proto_mpls_y1711, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_mpls_y1711 = expert_register_protocol(proto_mpls_y1711);\r\nexpert_register_field_array(expert_mpls_y1711, ei, array_length(ei));\r\nregister_dissector("mpls_y1711", dissect_mpls_y1711, proto_mpls_y1711);\r\n}\r\nvoid\r\nproto_reg_handoff_mpls_y1711(void)\r\n{\r\nmpls_y1711_handle = find_dissector("mpls_y1711");\r\ndissector_add_uint("mpls.label",\r\nMPLS_LABEL_OAM_ALERT ,\r\nmpls_y1711_handle);\r\n}
