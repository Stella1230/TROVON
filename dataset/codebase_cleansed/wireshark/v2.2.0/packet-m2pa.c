static void\r\ndissect_v2_header(tvbuff_t *header_tvb, packet_info *pinfo, proto_tree *m2pa_tree)\r\n{\r\nguint16 message_type;\r\nmessage_type = tvb_get_ntohs(header_tvb, V2_TYPE_OFFSET);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s ", val_to_str_const(message_type, v2_message_type_values, "reserved"));\r\nproto_tree_add_item(m2pa_tree, hf_version, header_tvb, VERSION_OFFSET, VERSION_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_spare, header_tvb, SPARE_OFFSET, SPARE_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_v2_type, header_tvb, V2_TYPE_OFFSET, V2_TYPE_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_length, header_tvb, V2_LENGTH_OFFSET, LENGTH_LENGTH, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_v8_header(tvbuff_t *header_tvb, packet_info *pinfo, proto_tree *m2pa_tree)\r\n{\r\nguint8 message_type;\r\nmessage_type = tvb_get_guint8(header_tvb, V8_TYPE_OFFSET);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s ", val_to_str_const(message_type, v8_message_type_values, "Unknown"));\r\nproto_tree_add_item(m2pa_tree, hf_version, header_tvb, VERSION_OFFSET, VERSION_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_spare, header_tvb, SPARE_OFFSET, SPARE_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_class, header_tvb, CLASS_OFFSET, CLASS_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_v8_type, header_tvb, V8_TYPE_OFFSET, V8_TYPE_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_length, header_tvb, V8_LENGTH_OFFSET, LENGTH_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_unused, header_tvb, FIRST_UNUSED_OFFSET, UNUSED_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_bsn, header_tvb, BSN_OFFSET, BSN_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_unused, header_tvb, SECOND_UNUSED_OFFSET, UNUSED_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_fsn, header_tvb, FSN_OFFSET, FSN_LENGTH, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_header(tvbuff_t *header_tvb, packet_info *pinfo, proto_tree *m2pa_tree)\r\n{\r\nguint8 message_type;\r\nmessage_type = tvb_get_guint8(header_tvb, V8_TYPE_OFFSET);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s ", val_to_str_const(message_type, v8_message_type_values, "Unknown"));\r\nproto_tree_add_item(m2pa_tree, hf_version, header_tvb, VERSION_OFFSET, VERSION_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_spare, header_tvb, SPARE_OFFSET, SPARE_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_class, header_tvb, CLASS_OFFSET, CLASS_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_type, header_tvb, TYPE_OFFSET, TYPE_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_length, header_tvb, LENGTH_OFFSET, LENGTH_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_unused, header_tvb, FIRST_UNUSED_OFFSET, UNUSED_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_bsn, header_tvb, BSN_OFFSET, BSN_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_unused, header_tvb, SECOND_UNUSED_OFFSET, UNUSED_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_tree, hf_fsn, header_tvb, FSN_OFFSET, FSN_LENGTH, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_v2_user_data_message(tvbuff_t *message_data_tvb, packet_info *pinfo, proto_item *m2pa_item, proto_tree *m2pa_tree, proto_tree *tree)\r\n{\r\nproto_tree *m2pa_li_tree;\r\ntvbuff_t *payload_tvb;\r\nif (tvb_reported_length(message_data_tvb) > 0) {\r\nm2pa_li_tree = proto_tree_add_subtree(m2pa_tree, message_data_tvb, LI_OFFSET, LI_LENGTH, ett_m2pa_li, NULL, "Length Indicator");\r\nproto_tree_add_item(m2pa_li_tree, hf_v2_li_spare, message_data_tvb, LI_OFFSET, LI_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_li_tree, hf_v2_li_prio, message_data_tvb, LI_OFFSET, LI_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_set_len(m2pa_item, V2_HEADER_LENGTH + LI_LENGTH);\r\n}\r\npayload_tvb = tvb_new_subset_remaining(message_data_tvb, MTP3_OFFSET);\r\ncall_dissector(mtp3_handle, payload_tvb, pinfo, tree);\r\n}\r\nstatic void\r\ndissect_v8_user_data_message(tvbuff_t *message_data_tvb, packet_info *pinfo, proto_item *m2pa_item, proto_tree *m2pa_tree, proto_tree *tree)\r\n{\r\nproto_tree *m2pa_li_tree;\r\ntvbuff_t *payload_tvb;\r\nif (tvb_reported_length(message_data_tvb) > 0) {\r\nm2pa_li_tree = proto_tree_add_subtree(m2pa_tree, message_data_tvb, LI_OFFSET, LI_LENGTH, ett_m2pa_li, NULL, "Length Indicator");\r\nproto_tree_add_item(m2pa_li_tree, hf_v8_li_prio, message_data_tvb, LI_OFFSET, LI_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_li_tree, hf_v8_li_spare, message_data_tvb, LI_OFFSET, LI_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_set_len(m2pa_item, V8_HEADER_LENGTH + LI_LENGTH);\r\npayload_tvb = tvb_new_subset_remaining(message_data_tvb, MTP3_OFFSET);\r\ncall_dissector(mtp3_handle, payload_tvb, pinfo, tree);\r\n}\r\n}\r\nstatic void\r\ndissect_user_data_message(tvbuff_t *message_data_tvb, packet_info *pinfo, proto_item *m2pa_item, proto_tree *m2pa_tree, proto_tree *tree)\r\n{\r\nproto_tree *m2pa_li_tree;\r\ntvbuff_t *payload_tvb;\r\nif (tvb_reported_length(message_data_tvb) > 0) {\r\nm2pa_li_tree = proto_tree_add_subtree(m2pa_tree, message_data_tvb, PRI_OFFSET, PRI_LENGTH, ett_m2pa_li, NULL, "Priority");\r\nproto_tree_add_item(m2pa_li_tree, hf_pri_prio, message_data_tvb, PRI_OFFSET, PRI_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(m2pa_li_tree, hf_pri_spare, message_data_tvb, PRI_OFFSET, PRI_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_set_len(m2pa_item, HEADER_LENGTH + PRI_LENGTH);\r\npayload_tvb = tvb_new_subset_remaining(message_data_tvb, MTP3_OFFSET);\r\ncall_dissector(mtp3_handle, payload_tvb, pinfo, tree);\r\n}\r\n}\r\nstatic void\r\ndissect_v2_link_status_message(tvbuff_t *message_data_tvb, packet_info *pinfo, proto_tree *m2pa_tree)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "(%s) ", val_to_str_const(tvb_get_ntohl(message_data_tvb, STATUS_OFFSET), v2_link_status_values, "Unknown"));\r\nproto_tree_add_item(m2pa_tree, hf_v2_status, message_data_tvb, STATUS_OFFSET, STATUS_LENGTH, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_v8_link_status_message(tvbuff_t *message_data_tvb, packet_info *pinfo, proto_tree *m2pa_tree)\r\n{\r\nguint16 filler_length;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "(%s) ", val_to_str_const(tvb_get_ntohl(message_data_tvb, STATUS_OFFSET), v8_link_status_values, "Unknown"));\r\nfiller_length = tvb_reported_length(message_data_tvb) - STATUS_LENGTH;\r\nproto_tree_add_item(m2pa_tree, hf_v8_status, message_data_tvb, STATUS_OFFSET, STATUS_LENGTH, ENC_BIG_ENDIAN);\r\nif (filler_length > 0)\r\nproto_tree_add_item(m2pa_tree, hf_filler, message_data_tvb, FILLER_OFFSET, filler_length, ENC_NA);\r\n}\r\nstatic void\r\ndissect_link_status_message(tvbuff_t *message_data_tvb, packet_info *pinfo, proto_tree *m2pa_tree)\r\n{\r\nguint16 filler_length;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "(%s) ", val_to_str_const(tvb_get_ntohl(message_data_tvb, STATUS_OFFSET), link_status_values, "Unknown"));\r\nfiller_length = tvb_reported_length(message_data_tvb) - STATUS_LENGTH;\r\nproto_tree_add_item(m2pa_tree, hf_status, message_data_tvb, STATUS_OFFSET, STATUS_LENGTH, ENC_BIG_ENDIAN);\r\nif (filler_length > 0)\r\nproto_tree_add_item(m2pa_tree, hf_filler, message_data_tvb, FILLER_OFFSET, filler_length, ENC_NA);\r\n}\r\nstatic void\r\ndissect_unknown_message(tvbuff_t *message_data_tvb, proto_tree *m2pa_tree)\r\n{\r\nguint length;\r\nlength = tvb_reported_length(message_data_tvb);\r\nif (length > 0)\r\nproto_tree_add_item(m2pa_tree, hf_unknown_data, message_data_tvb, 0, length, ENC_NA);\r\n}\r\nstatic void\r\ndissect_v2_message_data(tvbuff_t *message_tvb, packet_info *pinfo, proto_item *m2pa_item, proto_tree *m2pa_tree, proto_tree *tree)\r\n{\r\nguint32 message_data_length;\r\nguint16 type;\r\ntvbuff_t *message_data_tvb;\r\nmessage_data_length = (gint) tvb_get_ntohl(message_tvb, V2_LENGTH_OFFSET);\r\nif ((gint) message_data_length < 1) {\r\nproto_tree_add_expert_format(m2pa_tree, pinfo, &ei_length, message_tvb, V2_LENGTH_OFFSET, 4,\r\n"Invalid message data length: %u", message_data_length);\r\nreturn;\r\n}\r\nmessage_data_tvb = tvb_new_subset_length(message_tvb, V2_MESSAGE_DATA_OFFSET, message_data_length);\r\ntype = tvb_get_ntohs(message_tvb, V2_TYPE_OFFSET);\r\nswitch(type) {\r\ncase V2_USER_DATA_TYPE:\r\ndissect_v2_user_data_message(message_data_tvb, pinfo, m2pa_item, m2pa_tree, tree);\r\nbreak;\r\ncase V2_LINK_STATUS_TYPE:\r\ndissect_v2_link_status_message(message_data_tvb, pinfo, m2pa_tree);\r\nbreak;\r\ndefault:\r\ndissect_unknown_message(message_data_tvb, m2pa_tree);\r\n}\r\n}\r\nstatic void\r\ndissect_v8_message_data(tvbuff_t *message_tvb, packet_info *pinfo, proto_item *m2pa_item, proto_tree *m2pa_tree, proto_tree *tree)\r\n{\r\nguint32 message_data_length;\r\nguint8 type;\r\ntvbuff_t *message_data_tvb;\r\nmessage_data_length = tvb_get_ntohl(message_tvb, V8_LENGTH_OFFSET) - V8_HEADER_LENGTH;\r\nif ((gint) message_data_length < 1) {\r\nproto_tree_add_expert_format(m2pa_tree, pinfo, &ei_length, message_tvb, V8_LENGTH_OFFSET, 4,\r\n"Invalid message data length: %u", message_data_length);\r\nreturn;\r\n}\r\nmessage_data_tvb = tvb_new_subset_length(message_tvb, V8_MESSAGE_DATA_OFFSET, message_data_length);\r\ntype = tvb_get_guint8(message_tvb, V8_TYPE_OFFSET);\r\nswitch(type) {\r\ncase V8_USER_DATA_TYPE:\r\ndissect_v8_user_data_message(message_data_tvb, pinfo, m2pa_item, m2pa_tree, tree);\r\nbreak;\r\ncase V8_LINK_STATUS_TYPE:\r\ndissect_v8_link_status_message(message_data_tvb, pinfo, m2pa_tree);\r\nbreak;\r\ndefault:\r\ndissect_unknown_message(message_data_tvb, m2pa_tree);\r\n}\r\n}\r\nstatic void\r\ndissect_message_data(tvbuff_t *message_tvb, packet_info *pinfo, proto_item *m2pa_item, proto_tree *m2pa_tree, proto_tree *tree)\r\n{\r\nguint32 length, message_data_length, actual_length;\r\nguint8 type;\r\ntvbuff_t *message_data_tvb;\r\nlength = tvb_get_ntohl(message_tvb, LENGTH_OFFSET);\r\nmessage_data_length = length - HEADER_LENGTH;\r\nmessage_data_tvb = tvb_new_subset_length(message_tvb, MESSAGE_DATA_OFFSET, message_data_length);\r\ntype = tvb_get_guint8(message_tvb, TYPE_OFFSET);\r\nswitch(type) {\r\ncase USER_DATA_TYPE:\r\ndissect_user_data_message(message_data_tvb, pinfo, m2pa_item, m2pa_tree, tree);\r\nbreak;\r\ncase LINK_STATUS_TYPE:\r\ndissect_link_status_message(message_data_tvb, pinfo, m2pa_tree);\r\nbreak;\r\ndefault:\r\ndissect_unknown_message(message_data_tvb, m2pa_tree);\r\n}\r\nactual_length = tvb_reported_length(message_tvb);\r\nif (actual_length > length)\r\n{\r\nproto_item *pi;\r\npi = proto_tree_add_item(m2pa_tree, hf_undecode_data, message_tvb, length, (actual_length - length), ENC_NA);\r\nexpert_add_info_format(pinfo, pi, &ei_undecode_data,\r\n"There are %d bytes of data which is greater than M2PA's length parameter (%d)",\r\nactual_length, length);\r\n}\r\n}\r\nstatic void\r\ndissect_v2_message(tvbuff_t *message_tvb, packet_info *pinfo, proto_item *m2pa_item, proto_tree *m2pa_tree, proto_tree *tree)\r\n{\r\ndissect_v2_header(message_tvb, pinfo, m2pa_tree);\r\ndissect_v2_message_data(message_tvb, pinfo, m2pa_item, m2pa_tree, tree);\r\n}\r\nstatic void\r\ndissect_v8_message(tvbuff_t *message_tvb, packet_info *pinfo, proto_item *m2pa_item, proto_tree *m2pa_tree, proto_tree *tree)\r\n{\r\ndissect_v8_header(message_tvb, pinfo, m2pa_tree);\r\ndissect_v8_message_data(message_tvb, pinfo, m2pa_item, m2pa_tree, tree);\r\n}\r\nstatic void\r\ndissect_message(tvbuff_t *message_tvb, packet_info *pinfo, proto_item *m2pa_item, proto_tree *m2pa_tree, proto_tree *tree)\r\n{\r\ndissect_header(message_tvb, pinfo, m2pa_tree);\r\ndissect_message_data(message_tvb, pinfo, m2pa_item, m2pa_tree, tree);\r\n}\r\nstatic int\r\ndissect_m2pa(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *m2pa_item;\r\nproto_tree *m2pa_tree;\r\nswitch(m2pa_version) {\r\ncase M2PA_V02:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "M2PA (ID 02)");\r\nbreak;\r\ncase M2PA_V08:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "M2PA (ID 08)");\r\nbreak;\r\ncase M2PA_RFC4165:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "M2PA");\r\nbreak;\r\n};\r\nm2pa_item = proto_tree_add_item(tree, proto_m2pa, tvb, 0, -1, ENC_NA);\r\nm2pa_tree = proto_item_add_subtree(m2pa_item, ett_m2pa);\r\nswitch(m2pa_version) {\r\ncase M2PA_V02:\r\ndissect_v2_message(tvb, pinfo, m2pa_item, m2pa_tree, tree);\r\nbreak;\r\ncase M2PA_V08:\r\ndissect_v8_message(tvb, pinfo, m2pa_item, m2pa_tree, tree);\r\nbreak;\r\ncase M2PA_RFC4165:\r\ndissect_message(tvb, pinfo, m2pa_item, m2pa_tree, tree);\r\nbreak;\r\n};\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_m2pa(void)\r\n{\r\nstatic hf_register_info hf[] =\r\n{ { &hf_version, { "Version", "m2pa.version", FT_UINT8, BASE_DEC, VALS(protocol_version_values), 0x0, NULL, HFILL} },\r\n{ &hf_spare, { "Spare", "m2pa.spare", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL} },\r\n{ &hf_v2_type, { "Message Type", "m2pa.type_v2", FT_UINT16, BASE_HEX, VALS(v2_message_type_values), 0x0, NULL, HFILL} },\r\n{ &hf_v8_type, { "Message Type", "m2pa.type_v8", FT_UINT8, BASE_DEC, VALS(v8_message_type_values), 0x0, NULL, HFILL} },\r\n{ &hf_type, { "Message Type", "m2pa.type", FT_UINT8, BASE_DEC, VALS(message_type_values), 0x0, NULL, HFILL} },\r\n{ &hf_class, { "Message Class", "m2pa.class", FT_UINT8, BASE_DEC, VALS(message_class_values), 0x0, NULL, HFILL} },\r\n{ &hf_length, { "Message length", "m2pa.length", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL} },\r\n{ &hf_unused, { "Unused", "m2pa.unused", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL} },\r\n{ &hf_bsn, { "BSN", "m2pa.bsn", FT_UINT24, BASE_DEC, NULL, 0x0, NULL, HFILL} },\r\n{ &hf_fsn, { "FSN", "m2pa.fsn", FT_UINT24, BASE_DEC, NULL, 0x0, NULL, HFILL} },\r\n{ &hf_v2_li_spare, { "Spare", "m2pa.li_spare_v2", FT_UINT8, BASE_DEC, NULL, V2_LI_SPARE_MASK, NULL, HFILL} },\r\n{ &hf_v8_li_spare, { "Spare", "m2pa.li_spare_v8", FT_UINT8, BASE_HEX, NULL, V8_LI_SPARE_MASK, NULL, HFILL} },\r\n{ &hf_pri_spare, { "Spare", "m2pa.priority_spare", FT_UINT8, BASE_HEX, NULL, SPARE_MASK, NULL, HFILL} },\r\n{ &hf_v2_li_prio, { "Priority", "m2pa.li_priority_v2", FT_UINT8, BASE_DEC, NULL, V2_LI_PRIORITY_MASK, NULL, HFILL} },\r\n{ &hf_v8_li_prio, { "Priority", "m2pa.li_priority_v8", FT_UINT8, BASE_HEX, NULL, V8_LI_PRIORITY_MASK, NULL, HFILL} },\r\n{ &hf_pri_prio, { "Priority", "m2pa.priority", FT_UINT8, BASE_HEX, NULL, PRIORITY_MASK, NULL, HFILL} },\r\n{ &hf_v2_status, { "Link Status", "m2pa.status_v2", FT_UINT32, BASE_DEC, VALS(v2_link_status_values), 0x0, NULL, HFILL} },\r\n{ &hf_v8_status, { "Link Status", "m2pa.status_v8", FT_UINT32, BASE_DEC, VALS(v8_link_status_values), 0x0, NULL, HFILL} },\r\n{ &hf_status, { "Link Status", "m2pa.status", FT_UINT32, BASE_DEC, VALS(link_status_values), 0x0, NULL, HFILL} },\r\n{ &hf_filler, { "Filler", "m2pa.filler", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL} },\r\n{ &hf_unknown_data, { "Unknown Data", "m2pa.unknown_data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL} },\r\n{ &hf_undecode_data,{ "Undecoded data", "m2pa.undecoded_data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL} }\r\n};\r\nstatic gint *ett[] = {\r\n&ett_m2pa,\r\n&ett_m2pa_li\r\n};\r\nstatic const enum_val_t m2pa_version_options[] = {\r\n{ "draft-2", "Internet Draft version 2", M2PA_V02 },\r\n{ "draft-8", "Internet Draft version 8", M2PA_V08 },\r\n{ "RFC4165", "RFC 4165", M2PA_RFC4165 },\r\n{ NULL, NULL, 0 }\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_undecode_data, { "m2pa.undecoded_data.expert", PI_MALFORMED, PI_WARN, "There are bytes of data which is greater than M2PA's length parameter", EXPFILL }},\r\n{ &ei_length, { "m2pa.length.invalid", PI_MALFORMED, PI_ERROR, "Invalid message data length", EXPFILL }},\r\n};\r\nexpert_module_t* expert_m2pa;\r\nproto_m2pa = proto_register_protocol("MTP2 Peer Adaptation Layer", "M2PA", "m2pa");\r\nproto_register_field_array(proto_m2pa, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_m2pa = expert_register_protocol(proto_m2pa);\r\nexpert_register_field_array(expert_m2pa, ei, array_length(ei));\r\nregister_dissector("m2pa", dissect_m2pa, proto_m2pa);\r\nm2pa_module = prefs_register_protocol(proto_m2pa, proto_reg_handoff_m2pa);\r\nprefs_register_enum_preference(m2pa_module, "version", "M2PA version", "Version used by Wireshark", &m2pa_version, m2pa_version_options, FALSE);\r\nprefs_register_uint_preference(m2pa_module, "port", "M2PA SCTP Port", "Set the port for M2PA messages (Default of 3565)", 10, &global_sctp_port);\r\n}\r\nvoid\r\nproto_reg_handoff_m2pa(void)\r\n{\r\nstatic gboolean prefs_initialized = FALSE;\r\nstatic dissector_handle_t m2pa_handle;\r\nstatic guint sctp_port;\r\nif (!prefs_initialized) {\r\nm2pa_handle = find_dissector("m2pa");\r\nmtp3_handle = find_dissector_add_dependency("mtp3", proto_m2pa);\r\ndissector_add_uint("sctp.ppi", M2PA_PAYLOAD_PROTOCOL_ID, m2pa_handle);\r\nprefs_initialized = TRUE;\r\n} else {\r\ndissector_delete_uint("sctp.port", sctp_port, m2pa_handle);\r\n}\r\nsctp_port = global_sctp_port;\r\ndissector_add_uint("sctp.port", sctp_port, m2pa_handle);\r\n}
