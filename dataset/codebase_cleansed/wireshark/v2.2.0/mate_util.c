void dbg_print(const gint* which, gint how, FILE* where, const gchar* fmt, ... ) {\r\nstatic gchar debug_buffer[DEBUG_BUFFER_SIZE];\r\nva_list list;\r\nif ( ! which || *which < how ) return;\r\nva_start( list, fmt );\r\ng_vsnprintf(debug_buffer,DEBUG_BUFFER_SIZE,fmt,list);\r\nva_end( list );\r\nif (! where) {\r\ng_message("%s", debug_buffer);\r\n} else {\r\nfputs(debug_buffer,where);\r\nfputs("\n",where);\r\n}\r\n}\r\nstatic void destroy_scs_collection(SCS_collection* c) {\r\nif (c->hash) g_hash_table_destroy(c->hash);\r\n}\r\nstatic SCS_collection* scs_init(void) {\r\nSCS_collection* c = (SCS_collection *)g_malloc(sizeof(SCS_collection));\r\nc->hash = g_hash_table_new(g_str_hash,g_str_equal);\r\nreturn c;\r\n}\r\ngchar* scs_subscribe(SCS_collection* c, const gchar* s) {\r\ngchar* orig = NULL;\r\nguint* ip = NULL;\r\nsize_t len = 0;\r\ng_hash_table_lookup_extended(c->hash,(gconstpointer)s,(gpointer *)&orig,(gpointer *)&ip);\r\nif (ip) {\r\n(*ip)++;\r\n} else {\r\nip = g_slice_new(guint);\r\n*ip = 0;\r\nlen = strlen(s) + 1;\r\nif (len <= SCS_SMALL_SIZE) {\r\nlen = SCS_SMALL_SIZE;\r\n} else if (len <= SCS_MEDIUM_SIZE) {\r\nlen = SCS_MEDIUM_SIZE;\r\n} else if (len <= SCS_LARGE_SIZE) {\r\nlen = SCS_LARGE_SIZE;\r\n} else if (len < SCS_HUGE_SIZE) {\r\nlen = SCS_HUGE_SIZE;\r\n} else {\r\nlen = SCS_HUGE_SIZE;\r\ng_warning("mate SCS: string truncated due to huge size");\r\n}\r\norig = (gchar *)g_slice_alloc(len);\r\ng_strlcpy(orig,s,len);\r\ng_hash_table_insert(c->hash,orig,ip);\r\n}\r\nreturn orig;\r\n}\r\nvoid scs_unsubscribe(SCS_collection* c, gchar* s) {\r\ngchar* orig = NULL;\r\nguint* ip = NULL;\r\nsize_t len = 0xffff;\r\ng_hash_table_lookup_extended(c->hash,(gconstpointer)s,(gpointer *)&orig,(gpointer *)&ip);\r\nif (ip) {\r\nif (*ip == 0) {\r\ng_hash_table_remove(c->hash,orig);\r\nlen = strlen(orig);\r\nif (len < SCS_SMALL_SIZE) {\r\nlen = SCS_SMALL_SIZE;\r\n} else if (len < SCS_MEDIUM_SIZE) {\r\nlen = SCS_MEDIUM_SIZE;\r\n} else if (len < SCS_LARGE_SIZE) {\r\nlen = SCS_LARGE_SIZE;\r\n} else {\r\nlen = SCS_HUGE_SIZE;\r\n}\r\ng_slice_free1(len, orig);\r\ng_slice_free(guint,ip);\r\n}\r\nelse {\r\n(*ip)--;\r\n}\r\n} else {\r\ng_warning("unsubscribe: not subscribed");\r\n}\r\n}\r\ngchar* scs_subscribe_printf(SCS_collection* c, gchar* fmt, ...) {\r\nva_list list;\r\nstatic gchar buf[SCS_HUGE_SIZE];\r\nva_start( list, fmt );\r\ng_vsnprintf(buf, SCS_HUGE_SIZE, fmt, list);\r\nva_end( list );\r\nreturn scs_subscribe(c,buf);\r\n}\r\nextern void setup_avp_debug(FILE* fp, int* general, int* avp, int* avp_op, int* avpl, int* avpl_op) {\r\ndbg_fp = fp;\r\ndbg = general;\r\ndbg_avp = avp;\r\ndbg_avp_op = avp_op;\r\ndbg_avpl = avpl;\r\ndbg_avpl_op = avpl_op;\r\n}\r\nextern void avp_init(void) {\r\nif (avp_strings) destroy_scs_collection(avp_strings);\r\navp_strings = scs_init();\r\n}\r\nextern AVP* new_avp_from_finfo(const gchar* name, field_info* finfo) {\r\nAVP* new_avp_val = (AVP*)g_slice_new(any_avp_type);\r\ngchar* value;\r\ngchar* repr;\r\nnew_avp_val->n = scs_subscribe(avp_strings, name);\r\nrepr = fvalue_to_string_repr(NULL, &finfo->value,FTREPR_DISPLAY,finfo->hfinfo->display);\r\nif (repr) {\r\nvalue = scs_subscribe(avp_strings, repr);\r\nwmem_free(NULL, repr);\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print (dbg_avp,2,dbg_fp,"new_avp_from_finfo: from string: %s",value);\r\n#endif\r\n} else {\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print (dbg_avp,2,dbg_fp,"new_avp_from_finfo: a proto: %s",finfo->hfinfo->abbrev);\r\n#endif\r\nvalue = scs_subscribe(avp_strings, "");\r\n}\r\nnew_avp_val->v = value;\r\nnew_avp_val->o = '=';\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print (dbg_avp,1,dbg_fp,"new_avp_from_finfo: %X %s%c%s;",(guint32) new_avp_val,new_avp_val->n,new_avp_val->o,new_avp_val->v);\r\n#endif\r\nreturn new_avp_val;\r\n}\r\nextern AVP* new_avp(const gchar* name, const gchar* value, gchar o) {\r\nAVP* new_avp_val = (AVP*)g_slice_new(any_avp_type);\r\nnew_avp_val->n = scs_subscribe(avp_strings, name);\r\nnew_avp_val->v = scs_subscribe(avp_strings, value);\r\nnew_avp_val->o = o;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avp,1,dbg_fp,"new_avp_val: %X %s%c%s;",(guint32) new_avp_val,new_avp_val->n,new_avp_val->o,new_avp_val->v);\r\n#endif\r\nreturn new_avp_val;\r\n}\r\nextern void delete_avp(AVP* avp) {\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avp,1,dbg_fp,"delete_avp: %X %s%c%s;",(guint32) avp,avp->n,avp->o,avp->v);\r\n#endif\r\nscs_unsubscribe(avp_strings, avp->n);\r\nscs_unsubscribe(avp_strings, avp->v);\r\ng_slice_free(any_avp_type,(any_avp_type*)avp);\r\n}\r\nextern AVP* avp_copy(AVP* from) {\r\nAVP* new_avp_val = (AVP*)g_slice_new(any_avp_type);\r\nnew_avp_val->n = scs_subscribe(avp_strings, from->n);\r\nnew_avp_val->v = scs_subscribe(avp_strings, from->v);\r\nnew_avp_val->o = from->o;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avp,1,dbg_fp,"copy_avp: %X %s%c%s;",(guint32) new_avp_val,new_avp_val->n,new_avp_val->o,new_avp_val->v);\r\n#endif\r\nreturn new_avp_val;\r\n}\r\nextern AVPL* new_avpl(const gchar* name) {\r\nAVPL* new_avpl_p = (AVPL*)g_slice_new(any_avp_type);\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,7,dbg_fp,"new_avpl_p: %X name=%s",new_avpl_p,name);\r\n#endif\r\nnew_avpl_p->name = name ? scs_subscribe(avp_strings, name) : scs_subscribe(avp_strings, "");\r\nnew_avpl_p->len = 0;\r\nnew_avpl_p->null.avp = NULL;\r\nnew_avpl_p->null.next = &new_avpl_p->null;\r\nnew_avpl_p->null.prev = &new_avpl_p->null;\r\nreturn new_avpl_p;\r\n}\r\nextern void rename_avpl(AVPL* avpl, gchar* name) {\r\nscs_unsubscribe(avp_strings,avpl->name);\r\navpl->name = scs_subscribe(avp_strings,name);\r\n}\r\nextern gboolean insert_avp(AVPL* avpl, AVP* avp) {\r\nAVPN* new_avp_val = (AVPN*)g_slice_new(any_avp_type);\r\nAVPN* c;\r\nnew_avp_val->avp = avp;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,7,dbg_fp,"new_avpn: %X",new_avp_val);\r\ndbg_print(dbg_avpl_op,4,dbg_fp,"insert_avp: %X %X %s%c%s;",avpl,avp,avp->n,avp->o,avp->v);\r\n#endif\r\nfor(c=avpl->null.next; c->avp; c = c->next) {\r\nif ( avp->n == c->avp->n ) {\r\nif (avp->v > c->avp->v) {\r\nbreak;\r\n}\r\nif (avp->v == c->avp->v) {\r\nif (avp->o == AVP_OP_EQUAL) {\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,7,dbg_fp,"delete_avpn: %X",new_avp_val);\r\n#endif\r\ng_slice_free(any_avp_type,(any_avp_type*)new_avp_val);\r\nreturn FALSE;\r\n}\r\n}\r\n}\r\nif (avp->n > c->avp->n) {\r\nbreak;\r\n}\r\n}\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl,5,dbg_fp,"insert_avp: inserting %X in %X before %X;",avp,avpl,c);\r\n#endif\r\nnew_avp_val->next = c;\r\nnew_avp_val->prev = c->prev;\r\nc->prev->next = new_avp_val;\r\nc->prev = new_avp_val;\r\navpl->len++;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl,4,dbg_fp,"avpl: %X new len: %i",avpl,avpl->len);\r\n#endif\r\nreturn TRUE;\r\n}\r\nextern AVP* get_avp_by_name(AVPL* avpl, gchar* name, void** cookie) {\r\nAVPN* curr;\r\nAVPN* start = (AVPN*) *cookie;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,7,dbg_fp,"get_avp_by_name: entering: %X %s %X",avpl,name,*cookie);\r\n#endif\r\nname = scs_subscribe(avp_strings, name);\r\nif (!start) start = avpl->null.next;\r\nfor ( curr = start; curr->avp; curr = curr->next ) {\r\nif ( curr->avp->n == name ) {\r\nbreak;\r\n}\r\n}\r\n*cookie = curr;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,5,dbg_fp,"get_avp_by_name: got avp: %X",curr);\r\n#endif\r\nscs_unsubscribe(avp_strings, name);\r\nreturn curr->avp;\r\n}\r\nextern AVP* extract_avp_by_name(AVPL* avpl, gchar* name) {\r\nAVPN* curr;\r\nAVP* avp = NULL;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,7,dbg_fp,"extract_avp_by_name: entering: %X %s",avpl,name);\r\n#endif\r\nname = scs_subscribe(avp_strings, name);\r\nfor ( curr = avpl->null.next; curr->avp; curr = curr->next ) {\r\nif ( curr->avp->n == name ) {\r\nbreak;\r\n}\r\n}\r\nscs_unsubscribe(avp_strings, name);\r\nif( ! curr->avp ) return NULL;\r\ncurr->next->prev = curr->prev;\r\ncurr->prev->next = curr->next;\r\navp = curr->avp;\r\ng_slice_free(any_avp_type,(any_avp_type*)curr);\r\n(avpl->len)--;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl,4,dbg_fp,"avpl: %X new len: %i",avpl,avpl->len);\r\n#endif\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,5,dbg_fp,"extract_avp_by_name: got avp: %X",avp);\r\n#endif\r\nreturn avp;\r\n}\r\nextern AVP* extract_first_avp(AVPL* avpl) {\r\nAVP* avp;\r\nAVPN* node;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,7,dbg_fp,"extract_first_avp: %X",avpl);\r\n#endif\r\nnode = avpl->null.next;\r\navpl->null.next->prev = &avpl->null;\r\navpl->null.next = node->next;\r\navp = node->avp;\r\nif (avp) {\r\ng_slice_free(any_avp_type,(any_avp_type*)node);\r\n(avpl->len)--;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl,4,dbg_fp,"avpl: %X new len: %i",avpl,avpl->len);\r\n#endif\r\n}\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,5,dbg_fp,"extract_first_avp: got avp: %X",avp);\r\n#endif\r\nreturn avp;\r\n}\r\nextern AVP* extract_last_avp(AVPL* avpl) {\r\nAVP* avp;\r\nAVPN* node;\r\nnode = avpl->null.prev;\r\navpl->null.prev->next = &avpl->null;\r\navpl->null.prev = node->prev;\r\navp = node->avp;\r\nif (avp) {\r\ng_slice_free(any_avp_type,(any_avp_type*)node);\r\n(avpl->len)--;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl,4,dbg_fp,"avpl: %X new len: %i",avpl,avpl->len);\r\n#endif\r\n}\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,5,dbg_fp,"extract_last_avp: got avp: %X",avp);\r\n#endif\r\nreturn avp;\r\n}\r\nextern void delete_avpl(AVPL* avpl, gboolean avps_too) {\r\nAVP* avp;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl,3,dbg_fp,"delete_avpl: %X",avpl);\r\n#endif\r\nwhile(( avp = extract_last_avp(avpl))) {\r\nif (avps_too) {\r\ndelete_avp(avp);\r\n}\r\n}\r\nscs_unsubscribe(avp_strings,avpl->name);\r\ng_slice_free(any_avp_type,(any_avp_type*)avpl);\r\n}\r\nextern AVP* get_next_avp(AVPL* avpl, void** cookie) {\r\nAVPN* node;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,5,dbg_fp,"get_next_avp: avpl: %X avpn: %X",avpl,*cookie);\r\n#endif\r\nif (*cookie) {\r\nnode = (AVPN*) *cookie;\r\n} else {\r\nnode = avpl->null.next;\r\n}\r\n*cookie = node->next;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,5,dbg_fp,"extract_last_avp: got avp: %X",node->avp);\r\n#endif\r\nreturn node->avp;\r\n}\r\ngchar* avpl_to_str(AVPL* avpl) {\r\nAVPN* c;\r\nGString* s = g_string_new("");\r\ngchar* avp_s;\r\ngchar* r;\r\nfor(c=avpl->null.next; c->avp; c = c->next) {\r\navp_s = avp_to_str(c->avp);\r\ng_string_append_printf(s," %s;",avp_s);\r\ng_free(avp_s);\r\n}\r\nr = g_string_free(s,FALSE);\r\nreturn r;\r\n}\r\nextern gchar* avpl_to_dotstr(AVPL* avpl) {\r\nAVPN* c;\r\nGString* s = g_string_new("");\r\ngchar* avp_s;\r\ngchar* r;\r\nfor(c=avpl->null.next; c->avp; c = c->next) {\r\navp_s = avp_to_str(c->avp);\r\ng_string_append_printf(s," .%s;",avp_s);\r\ng_free(avp_s);\r\n}\r\nr = g_string_free(s,FALSE);\r\nreturn r;\r\n}\r\nextern void merge_avpl(AVPL* dst, AVPL* src, gboolean copy_avps) {\r\nAVPN* cd = NULL;\r\nAVPN* cs = NULL;\r\nptrdiff_t c;\r\nAVP* copy;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,3,dbg_fp,"merge_avpl: %X %X",dst,src);\r\n#endif\r\ncs = src->null.next;\r\ncd = dst->null.next;\r\nwhile(cs->avp) {\r\nif(cd->avp) {\r\nc = ADDRDIFF(cd->avp->n,cs->avp->n);\r\n} else {\r\nc = -1;\r\n}\r\nif (c > 0) {\r\nif (cd->avp) cd = cd->next;\r\n} else if (c < 0) {\r\nif (copy_avps) {\r\ncopy = avp_copy(cs->avp);\r\nif ( ! insert_avp(dst,copy) ) {\r\ndelete_avp(copy);\r\n}\r\n} else {\r\ninsert_avp(dst,cs->avp);\r\n}\r\ncs = cs->next;\r\n} else {\r\nif ( ! cd->avp || ! (cd->avp->v == cs->avp->v) ) {\r\nif (copy_avps) {\r\ncopy = avp_copy(cs->avp);\r\nif ( ! insert_avp(dst,copy) ) {\r\ndelete_avp(copy);\r\n}\r\n} else {\r\ninsert_avp(dst,cs->avp);\r\n}\r\n}\r\ncs = cs->next;\r\nif (cd->avp) cd = cd->next;\r\n}\r\n}\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,8,dbg_fp,"merge_avpl: done");\r\n#endif\r\nreturn;\r\n}\r\nextern AVPL* new_avpl_from_avpl(const gchar* name, AVPL* avpl, gboolean copy_avps) {\r\nAVPL* newavpl = new_avpl(name);\r\nvoid* cookie = NULL;\r\nAVP* avp;\r\nAVP* copy;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,3,dbg_fp,"new_avpl_from_avpl: %X from=%X name='%s'",newavpl,avpl,name);\r\n#endif\r\nwhile(( avp = get_next_avp(avpl,&cookie) )) {\r\nif (copy_avps) {\r\ncopy = avp_copy(avp);\r\nif ( ! insert_avp(newavpl,copy) ) {\r\ndelete_avp(copy);\r\n}\r\n} else {\r\ninsert_avp(newavpl,avp);\r\n}\r\n}\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,8,dbg_fp,"new_avpl_from_avpl: done");\r\n#endif\r\nreturn newavpl;\r\n}\r\nextern AVP* match_avp(AVP* src, AVP* op) {\r\ngchar** splited;\r\nint i;\r\ngchar* p;\r\nguint ls;\r\nguint lo;\r\nfloat fs = 0.0f;\r\nfloat fo = 0.0f;\r\ngboolean lower = FALSE;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,3,dbg_fp,"match_avp: %s%c%s; vs. %s%c%s;",src->n,src->o,src->v,op->n,op->o,op->v);\r\n#endif\r\nif ( src->n != op->n ) {\r\nreturn NULL;\r\n}\r\nswitch (op->o) {\r\ncase AVP_OP_EXISTS:\r\nreturn src;\r\ncase AVP_OP_EQUAL:\r\nreturn src->v == op->v ? src : NULL;\r\ncase AVP_OP_NOTEQUAL:\r\nreturn !( src->v == op->v) ? src : NULL;\r\ncase AVP_OP_STARTS:\r\nreturn strncmp(src->v,op->v,strlen(op->v)) == 0 ? src : NULL;\r\ncase AVP_OP_ONEOFF:\r\nsplited = g_strsplit(op->v,"|",0);\r\nif (splited) {\r\nfor (i=0;splited[i];i++) {\r\nif(g_str_equal(splited[i],src->v)) {\r\ng_strfreev(splited);\r\nreturn src;\r\n}\r\n}\r\ng_strfreev(splited);\r\n}\r\nreturn NULL;\r\ncase AVP_OP_LOWER:\r\nlower = TRUE;\r\ncase AVP_OP_HIGHER:\r\nfs = (float) g_ascii_strtod(src->v, NULL);\r\nfo = (float) g_ascii_strtod(op->v, NULL);\r\nif (lower) {\r\nif (fs<fo) return src;\r\nelse return NULL;\r\n} else {\r\nif (fs>fo) return src;\r\nelse return NULL;\r\n}\r\ncase AVP_OP_ENDS:\r\nls = (guint) strlen(src->v);\r\nlo = (guint) strlen(op->v);\r\nif ( ls < lo ) {\r\nreturn NULL;\r\n} else {\r\np = src->v + ( ls - lo );\r\nreturn g_str_equal(p,op->v) ? src : NULL;\r\n}\r\ncase AVP_OP_CONTAINS:\r\nreturn g_strrstr(src->v, op->v) ? src : NULL;;\r\n}\r\nreturn NULL;\r\n}\r\nextern AVPL* new_avpl_loose_match(const gchar* name,\r\nAVPL* src,\r\nAVPL* op,\r\ngboolean copy_avps) {\r\nAVPL* newavpl = new_avpl(scs_subscribe(avp_strings, name));\r\nAVPN* co = NULL;\r\nAVPN* cs = NULL;\r\nptrdiff_t c;\r\nAVP* m;\r\nAVP* copy;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,3,dbg_fp,"new_avpl_loose_match: %X src=%X op=%X name='%s'",newavpl,src,op,name);\r\n#endif\r\ncs = src->null.next;\r\nco = op->null.next;\r\nwhile(1) {\r\nif (!co->avp) {\r\nreturn newavpl;\r\n}\r\nif (!cs->avp) {\r\nreturn newavpl;\r\n}\r\nc = ADDRDIFF(co->avp->n, cs->avp->n);\r\nif ( c > 0 ) {\r\nif (co->avp) co = co->next;\r\n} else if (c < 0) {\r\nif (cs->avp) cs = cs->next;\r\n} else {\r\nm = match_avp(cs->avp,co->avp);\r\nif(m) {\r\nif (copy_avps) {\r\ncopy = avp_copy(m);\r\nif ( ! insert_avp(newavpl,copy) ) {\r\ndelete_avp(copy);\r\n}\r\n} else {\r\ninsert_avp(newavpl,m);\r\n}\r\n}\r\nif (cs->avp) cs = cs->next;\r\n}\r\n}\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,6,dbg_fp,"new_avpl_loose_match: done!");\r\n#endif\r\nreturn NULL;\r\n}\r\nextern AVPL* new_avpl_every_match(const gchar* name, AVPL* src, AVPL* op, gboolean copy_avps) {\r\nAVPL* newavpl;\r\nAVPN* co = NULL;\r\nAVPN* cs = NULL;\r\nptrdiff_t c;\r\nAVP* m;\r\nAVP* copy;\r\ngboolean matches;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,3,dbg_fp,"new_avpl_every_match: %X src=%X op=%X name='%s'",newavpl,src,op,name);\r\n#endif\r\nif (src->len == 0) return NULL;\r\nnewavpl = new_avpl(scs_subscribe(avp_strings, name));\r\nif (op->len == 0)\r\nreturn newavpl;\r\nmatches = TRUE;\r\ncs = src->null.next;\r\nco = op->null.next;\r\nwhile(1) {\r\nif (!co->avp) {\r\nbreak;\r\n}\r\nif (!cs->avp) {\r\nbreak;\r\n}\r\nc = ADDRDIFF(co->avp->n,cs->avp->n);\r\nif ( c > 0 ) {\r\ndelete_avpl(newavpl,TRUE);\r\nreturn NULL;\r\n} else if (c < 0) {\r\ncs = cs->next;\r\nif (! cs->avp ) {\r\nbreak;\r\n}\r\n} else {\r\nm = match_avp(cs->avp,co->avp);\r\nif(m) {\r\nmatches++;\r\ncs = cs->next;\r\nco = co->next;\r\nif (copy_avps) {\r\ncopy = avp_copy(m);\r\nif ( ! insert_avp(newavpl,copy) ) {\r\ndelete_avp(copy);\r\n}\r\n} else {\r\ninsert_avp(newavpl,m);\r\n}\r\n} else {\r\ncs = cs->next;\r\n}\r\n}\r\n}\r\nif (matches) {\r\nreturn newavpl;\r\n} else {\r\ndelete_avpl(newavpl,TRUE);\r\nreturn NULL;\r\n}\r\n}\r\nextern AVPL* new_avpl_exact_match(const gchar* name,AVPL* src, AVPL* op, gboolean copy_avps) {\r\nAVPL* newavpl = new_avpl(name);\r\nAVPN* co = NULL;\r\nAVPN* cs = NULL;\r\nptrdiff_t c;\r\nAVP* m;\r\nAVP* copy;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,3,dbg_fp,"new_avpl_every_match: %X src=%X op=%X name='%s'",newavpl,src,op,name);\r\n#endif\r\nif (op->len == 0)\r\nreturn newavpl;\r\nif (src->len == 0) {\r\ndelete_avpl(newavpl,FALSE);\r\nreturn NULL;\r\n}\r\ncs = src->null.next;\r\nco = op->null.next;\r\nwhile(1) {\r\nc = ADDRDIFF(co->avp->n,cs->avp->n);\r\nif ( c > 0 ) {\r\ndelete_avpl(newavpl,TRUE);\r\nreturn NULL;\r\n} else if (c < 0) {\r\ncs = cs->next;\r\nif (! cs->avp ) {\r\ndelete_avpl(newavpl,TRUE);\r\nreturn NULL;\r\n}\r\n} else {\r\nm = match_avp(cs->avp,co->avp);\r\nif(m) {\r\ncs = cs->next;\r\nco = co->next;\r\nif (copy_avps) {\r\ncopy = avp_copy(m);\r\nif ( ! insert_avp(newavpl,copy) ) {\r\ndelete_avp(copy);\r\n}\r\n} else {\r\ninsert_avp(newavpl,m);\r\n}\r\nif (!co->avp) {\r\nreturn newavpl;\r\n}\r\nif (!cs->avp) {\r\ndelete_avpl(newavpl,TRUE);\r\nreturn NULL;\r\n}\r\n} else {\r\ndelete_avpl(newavpl,TRUE);\r\nreturn NULL;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nextern AVPL* new_avpl_from_match(avpl_match_mode mode, const gchar* name,AVPL* src, AVPL* op, gboolean copy_avps) {\r\nAVPL* avpl = NULL;\r\nswitch (mode) {\r\ncase AVPL_STRICT:\r\navpl = new_avpl_exact_match(name,src,op,copy_avps);\r\nbreak;\r\ncase AVPL_LOOSE:\r\navpl = new_avpl_loose_match(name,src,op,copy_avps);\r\nbreak;\r\ncase AVPL_EVERY:\r\navpl = new_avpl_every_match(name,src,op,copy_avps);\r\nbreak;\r\ncase AVPL_NO_MATCH:\r\navpl = new_avpl_from_avpl(name,src,copy_avps);\r\nmerge_avpl(avpl, op, copy_avps);\r\nbreak;\r\n}\r\nreturn avpl;\r\n}\r\nextern void delete_avpl_transform(AVPL_Transf* op) {\r\nAVPL_Transf* next;\r\nfor (; op ; op = next) {\r\nnext = op->next;\r\ng_free(op->name);\r\nif (op->match) {\r\ndelete_avpl(op->match,TRUE);\r\n}\r\nif (op->replace) {\r\ndelete_avpl(op->replace,TRUE);\r\n}\r\ng_free(op);\r\n}\r\n}\r\nextern void avpl_transform(AVPL* src, AVPL_Transf* op) {\r\nAVPL* avpl = NULL;\r\nAVPN* cs;\r\nAVPN* cm;\r\nAVPN* n;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,3,dbg_fp,"avpl_transform: src=%X op=%X",src,op);\r\n#endif\r\nfor ( ; op ; op = op->next) {\r\navpl = new_avpl_from_match(op->match_mode, src->name,src, op->match, TRUE);\r\nif (avpl) {\r\nswitch (op->replace_mode) {\r\ncase AVPL_NO_REPLACE:\r\ndelete_avpl(avpl,TRUE);\r\nreturn;\r\ncase AVPL_INSERT:\r\nmerge_avpl(src,op->replace,TRUE);\r\ndelete_avpl(avpl,TRUE);\r\nreturn;\r\ncase AVPL_REPLACE:\r\ncs = src->null.next;\r\ncm = avpl->null.next;\r\nwhile(cs->avp) {\r\nif (cm->avp && cs->avp->n == cm->avp->n && cs->avp->v == cm->avp->v) {\r\nn = cs->next;\r\ncs->prev->next = cs->next;\r\ncs->next->prev = cs->prev;\r\ng_slice_free(any_avp_type,(any_avp_type*)cs);\r\ncs = n;\r\ncm = cm->next;\r\n} else {\r\ncs = cs->next;\r\n}\r\n}\r\nmerge_avpl(src,op->replace,TRUE);\r\ndelete_avpl(avpl,TRUE);\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nextern LoAL* new_loal(const gchar* name) {\r\nLoAL* new_loal_p = (LoAL*)g_slice_new(any_avp_type);\r\nif (! name) {\r\nname = "anonymous";\r\n}\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,3,dbg_fp,"new_loal_p: %X name=%s",new_loal_p,name);\r\n#endif\r\nnew_loal_p->name = scs_subscribe(avp_strings,name);\r\nnew_loal_p->null.avpl = NULL;\r\nnew_loal_p->null.next = &new_loal_p->null;\r\nnew_loal_p->null.prev = &new_loal_p->null;\r\nnew_loal_p->len = 0;\r\nreturn new_loal_p;\r\n}\r\nextern void loal_append(LoAL* loal, AVPL* avpl) {\r\nLoALnode* node = (LoALnode*)g_slice_new(any_avp_type);\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,3,dbg_fp,"new_loal_node: %X",node);\r\n#endif\r\nnode->avpl = avpl;\r\nnode->next = &loal->null;\r\nnode->prev = loal->null.prev;\r\nloal->null.prev->next = node;\r\nloal->null.prev = node;\r\nloal->len++;\r\n}\r\nextern AVPL* extract_first_avpl(LoAL* loal) {\r\nLoALnode* node;\r\nAVPL* avpl;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,3,dbg_fp,"extract_first_avpl: from: %s",loal->name);\r\n#endif\r\nnode = loal->null.next;\r\nloal->null.next->next->prev = &loal->null;\r\nloal->null.next = node->next;\r\nloal->len--;\r\navpl = node->avpl;\r\nif ( avpl ) {\r\ng_slice_free(any_avp_type,(any_avp_type*)node);\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,3,dbg_fp,"extract_first_avpl: got %s",avpl->name);\r\ndbg_print(dbg_avpl_op,3,dbg_fp,"delete_loal_node: %X",node);\r\n#endif\r\n}\r\nreturn avpl;\r\n}\r\nextern AVPL* extract_last_avpl(LoAL* loal){\r\nLoALnode* node;\r\nAVPL* avpl;\r\nnode = loal->null.prev;\r\nloal->null.prev->prev->next = &loal->null;\r\nloal->null.prev = node->prev;\r\nloal->len--;\r\navpl = node->avpl;\r\nif ( avpl ) {\r\ng_slice_free(any_avp_type,(any_avp_type*)node);\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,3,dbg_fp,"delete_loal_node: %X",node);\r\n#endif\r\n}\r\nreturn avpl;\r\n}\r\nextern AVPL* get_next_avpl(LoAL* loal,void** cookie) {\r\nLoALnode* node;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,3,dbg_fp,"get_next_avpl: loal=%X node=%X",loal,*cookie);\r\n#endif\r\nif (*cookie) {\r\nnode = (LoALnode*) *cookie;\r\n} else {\r\nnode = loal->null.next;\r\n}\r\n*cookie = node->next;\r\nreturn node->avpl;\r\n}\r\nextern void delete_loal(LoAL* loal, gboolean avpls_too, gboolean avps_too) {\r\nAVPL* avpl;\r\n#ifdef _AVP_DEBUGGING\r\ndbg_print(dbg_avpl_op,3,dbg_fp,"delete_loal: %X",loal);\r\n#endif\r\nwhile(( avpl = extract_last_avpl(loal) )) {\r\nif (avpls_too) {\r\ndelete_avpl(avpl,avps_too);\r\n}\r\n}\r\nscs_unsubscribe(avp_strings,loal->name);\r\ng_slice_free(any_avp_type,(any_avp_type*)loal);\r\n}\r\nstatic LoAL* load_loal_error(FILE* fp, LoAL* loal, AVPL* curr, int linenum, const gchar* fmt, ...) {\r\nva_list list;\r\ngchar* desc;\r\nLoAL* ret = NULL;\r\ngchar* err;\r\nva_start( list, fmt );\r\ndesc = g_strdup_vprintf(fmt, list);\r\nva_end( list );\r\nerr = g_strdup_printf("Error Loading LoAL from file: in %s at line: %i, %s",loal->name,linenum,desc);\r\nret = new_loal(err);\r\ng_free(desc);\r\ng_free(err);\r\nif (fp) fclose(fp);\r\nif (loal) delete_loal(loal,TRUE,TRUE);\r\nif (curr) delete_avpl(curr,TRUE);\r\nreturn ret;\r\n}\r\nextern LoAL* loal_from_file(gchar* filename) {\r\nFILE *fp = NULL;\r\ngchar c;\r\nint i = 0;\r\nguint32 linenum = 1;\r\ngchar linenum_buf[MAX_ITEM_LEN];\r\ngchar name[MAX_ITEM_LEN];\r\ngchar value[MAX_ITEM_LEN];\r\ngchar op = '?';\r\nLoAL *loal = new_loal(filename);\r\nAVPL* curr = NULL;\r\nAVP* avp;\r\nenum _load_loal_states {\r\nSTART,\r\nBEFORE_NAME,\r\nIN_NAME,\r\nIN_VALUE,\r\nMY_IGNORE\r\n} state;\r\n#ifndef _WIN32\r\nif (! getuid()) {\r\nreturn load_loal_error(fp,loal,curr,linenum,"MATE Will not run as root");\r\n}\r\n#endif\r\nstate = START;\r\nif (( fp = ws_fopen(filename,"r") )) {\r\nwhile(( c = (gchar) fgetc(fp) )){\r\nif ( feof(fp) ) {\r\nif ( ferror(fp) ) {\r\nreport_read_failure(filename,errno);\r\nreturn load_loal_error(fp,loal,curr,linenum,"Error while reading '%f'",filename);\r\n}\r\nbreak;\r\n}\r\nif ( c == '\n' ) {\r\nlinenum++;\r\n}\r\nif ( i >= MAX_ITEM_LEN - 1 ) {\r\nreturn load_loal_error(fp,loal,curr,linenum,"Maximum item length exceeded");\r\n}\r\nswitch(state) {\r\ncase MY_IGNORE:\r\nswitch (c) {\r\ncase '\n':\r\nstate = START;\r\ni = 0;\r\ncontinue;\r\ndefault:\r\ncontinue;\r\n}\r\ncase START:\r\nswitch (c) {\r\ncase ' ': case '\t':\r\ncontinue;\r\ncase '\n':\r\ni = 0;\r\ncontinue;\r\ncase AVP_NAME_CHAR:\r\nstate = IN_NAME;\r\ni = 0;\r\nname[i++] = c;\r\nname[i] = '\0';\r\ng_snprintf(linenum_buf,sizeof(linenum_buf),"%s:%u",filename,linenum);\r\ncurr = new_avpl(linenum_buf);\r\ncontinue;\r\ncase '#':\r\nstate = MY_IGNORE;\r\ncontinue;\r\ndefault:\r\nreturn load_loal_error(fp,loal,curr,linenum,"expecting name got: '%c'",c);\r\n}\r\ncase BEFORE_NAME:\r\ni = 0;\r\nname[0] = '\0';\r\nswitch (c) {\r\ncase '\\':\r\nc = (gchar) fgetc(fp);\r\nif (c != '\n') ungetc(c,fp);\r\ncontinue;\r\ncase ' ':\r\ncase '\t':\r\ncontinue;\r\ncase AVP_NAME_CHAR:\r\nstate = IN_NAME;\r\nname[i++] = c;\r\nname[i] = '\0';\r\ncontinue;\r\ncase '\n':\r\nloal_append(loal,curr);\r\nstate = START;\r\ncontinue;\r\ndefault:\r\nreturn load_loal_error(fp,loal,curr,linenum,"expecting name got: '%c'",c);\r\n}\r\ncase IN_NAME:\r\nswitch (c) {\r\ncase ';':\r\nstate = BEFORE_NAME;\r\nop = '?';\r\nname[i] = '\0';\r\nvalue[0] = '\0';\r\ni = 0;\r\navp = new_avp(name,value,op);\r\nif (! insert_avp(curr,avp) ) {\r\ndelete_avp(avp);\r\n}\r\ncontinue;\r\ncase AVP_OP_CHAR:\r\nname[i] = '\0';\r\ni = 0;\r\nop = c;\r\nstate = IN_VALUE;\r\ncontinue;\r\ncase AVP_NAME_CHAR:\r\nname[i++] = c;\r\ncontinue;\r\ncase '\n':\r\nreturn load_loal_error(fp,loal,curr,linenum,"operator expected found new line");\r\ndefault:\r\nreturn load_loal_error(fp,loal,curr,linenum,"name or match operator expected found '%c'",c);\r\n}\r\ncase IN_VALUE:\r\nswitch (c) {\r\ncase '\\':\r\nvalue[i++] = (gchar) fgetc(fp);\r\ncontinue;\r\ncase ';':\r\nstate = BEFORE_NAME;\r\nvalue[i] = '\0';\r\ni = 0;\r\navp = new_avp(name,value,op);\r\nif (! insert_avp(curr,avp) ) {\r\ndelete_avp(avp);\r\n}\r\ncontinue;\r\ncase '\n':\r\nreturn load_loal_error(fp,loal,curr,linenum,"';' expected found new line");\r\ndefault:\r\nvalue[i++] = c;\r\ncontinue;\r\n}\r\n}\r\n}\r\nfclose (fp);\r\nreturn loal;\r\n} else {\r\nreport_open_failure(filename,errno,FALSE);\r\nreturn load_loal_error(NULL,loal,NULL,0,"Cannot Open file '%s'",filename);\r\n}\r\n}
