static guint\r\nget_rpkirtr_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nguint32 plen;\r\nplen = tvb_get_ntohl(tvb, offset+4);\r\nreturn plen;\r\n}\r\nstatic int dissect_rpkirtr_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti = NULL, *ti_flags, *ti_type;\r\nproto_tree *rpkirtr_tree = NULL, *flags_tree = NULL;\r\nint offset = 0;\r\nguint8 pdu_type, version;\r\nguint length;\r\nwhile (tvb_reported_length_remaining(tvb, offset) != 0) {\r\nti = proto_tree_add_item(tree, proto_rpkirtr, tvb, 0, -1, ENC_NA);\r\nrpkirtr_tree = proto_item_add_subtree(ti, ett_rpkirtr);\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nversion = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\nti_type = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_pdu_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\npdu_type = tvb_get_guint8(tvb, offset);\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, val_to_str(pdu_type, rtr_pdu_type_vals, "Unknown (%d)"));\r\nproto_item_append_text(ti, " (%s)", val_to_str(pdu_type, rtr_pdu_type_vals, "Unknown %d"));\r\noffset += 1;\r\nlength = tvb_get_ntohl(tvb, offset);\r\nswitch (pdu_type) {\r\ncase RPKI_RTR_SERIAL_NOTIFY_PDU:\r\ncase RPKI_RTR_SERIAL_QUERY_PDU:\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_serial_number, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase RPKI_RTR_RESET_QUERY_PDU:\r\ncase RPKI_RTR_CACHE_RESET_PDU:\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved, tvb, offset, 2, ENC_NA);\r\noffset += 2;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase RPKI_RTR_CACHE_RESPONSE_PDU:\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase RPKI_RTR_IPV4_PREFIX_PDU:\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved, tvb, offset, 2, ENC_NA);\r\noffset += 2;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nflags_tree = proto_item_add_subtree(ti_flags, ett_flags);\r\nproto_tree_add_item(flags_tree, hf_rpkirtr_flags_aw, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_prefix_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_max_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_ipv4_prefix, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase RPKI_RTR_IPV6_PREFIX_PDU:\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved, tvb, offset, 2, ENC_NA);\r\noffset += 2;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nflags_tree = proto_item_add_subtree(ti_flags, ett_flags);\r\nproto_tree_add_item(flags_tree, hf_rpkirtr_flags_aw, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_prefix_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_max_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_ipv6_prefix, tvb, offset, 16, ENC_NA);\r\noffset += 16;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase RPKI_RTR_END_OF_DATA_PDU:\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_serial_number, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nif (version >= 1){\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_refresh_interval, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_retry_interval, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_expire_interval, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nbreak;\r\ncase RPKI_RTR_ROUTER_KEY:\r\nif(version < 1){\r\nexpert_add_info(pinfo, ti_type, &ei_rpkirtr_wrong_version_router_key);\r\n} else {\r\nasn1_ctx_t asn1_ctx;\r\nti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nflags_tree = proto_item_add_subtree(ti_flags, ett_flags_nd);\r\nproto_tree_add_item(flags_tree, hf_rpkirtr_flags_rk, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved, tvb, offset, 2, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_subject_key_identifier, tvb, offset, 20, ENC_NA);\r\noffset += 20;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\r\noffset = dissect_x509af_SubjectPublicKeyInfo(FALSE, tvb, offset, &asn1_ctx, rpkirtr_tree, hf_rpkirtr_subject_public_key_info);\r\n}\r\nbreak;\r\ncase RPKI_RTR_ERROR_REPORT_PDU:\r\n{\r\nguint32 len_pdu, len_text;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_code, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length_pdu, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nlen_pdu = tvb_get_ntohl(tvb, offset);\r\noffset += 4;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_pdu, tvb, offset, len_pdu, ENC_NA);\r\noffset += len_pdu;\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length_text, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nlen_text = tvb_get_ntohl(tvb, offset);\r\noffset += 4,\r\nproto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_text, tvb, offset, len_text, ENC_ASCII|ENC_NA);\r\noffset += len_text;\r\n}\r\nbreak;\r\ndefault:\r\noffset += length;\r\nbreak;\r\n}\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic int\r\ndissect_rpkirtr(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "RPKI-RTR");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ntcp_dissect_pdus(tvb, pinfo, tree, 1, 8, get_rpkirtr_pdu_len, dissect_rpkirtr_pdu, data);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nvoid\r\nproto_register_rpkirtr(void)\r\n{\r\nmodule_t *rpkirtr_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_rpkirtr_version,\r\n{ "Version", "rpki-rtr.version",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Denoting the version of this protocol (currently 0)", HFILL }\r\n},\r\n{ &hf_rpkirtr_pdu_type,\r\n{ "PDU Type", "rpki-rtr.pdu_type",\r\nFT_UINT8, BASE_DEC, VALS(rtr_pdu_type_vals), 0x0,\r\n"Denoting the type of the PDU", HFILL }\r\n},\r\n{ &hf_rpkirtr_reserved,\r\n{ "Reserved", "rpki-rtr.reserved",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Must be zero", HFILL }\r\n},\r\n{ &hf_rpkirtr_session_id,\r\n{ "Session ID", "rpki-rtr.session_id",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rpkirtr_length,\r\n{ "Length", "rpki-rtr.length",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Value the count of the bytes in the entire PDU, including the eight bytes of header that end with the length field", HFILL }\r\n},\r\n{ &hf_rpkirtr_serial_number,\r\n{ "Serial Number", "rpki-rtr.serial_number",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rpkirtr_flags,\r\n{ "Flags", "rpki-rtr.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rpkirtr_flags_aw,\r\n{ "Flag AW", "rpki-rtr.flags.aw",\r\nFT_BOOLEAN, 8, TFS(&tfs_flag_type_aw), 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rpkirtr_flags_rk,\r\n{ "Flag Router Key", "rpki-rtr.flags.rk",\r\nFT_BOOLEAN, 8, TFS(&tfs_flag_type_rk), 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rpkirtr_prefix_length,\r\n{ "Prefix Length", "rpki-rtr.prefix_length",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Denoting the shortest prefix allowed for the prefix", HFILL }\r\n},\r\n{ &hf_rpkirtr_max_length,\r\n{ "Max length", "rpki-rtr.max_length",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Denoting the longest prefix allowed by the prefix. This MUST NOT be less than the Prefix Length element", HFILL }\r\n},\r\n{ &hf_rpkirtr_ipv4_prefix,\r\n{ "IPv4 Prefix", "rpki-rtr.ipv4_prefix",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\n"The IPv4 prefix of the ROA", HFILL }\r\n},\r\n{ &hf_rpkirtr_ipv6_prefix,\r\n{ "IPv6 Prefix", "rpki-rtr.ipv6_prefix",\r\nFT_IPv6, BASE_NONE, NULL, 0x0,\r\n"The IPv6 prefix of the ROA", HFILL }\r\n},\r\n{ &hf_rpkirtr_as_number,\r\n{ "AS Number", "rpki-rtr.as_number",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Autonomous System Number allowed to announce this prefix", HFILL }\r\n},\r\n{ &hf_rpkirtr_error_code,\r\n{ "Error Code", "rpki-rtr.error_code",\r\nFT_UINT16, BASE_DEC, VALS(rtr_error_code_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rpkirtr_length_pdu,\r\n{ "Length of Encapsulated PDU", "rpki-rtr.length_pdu",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rpkirtr_error_pdu,\r\n{ "Erroneous PDU", "rpki-rtr.error_pdu",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rpkirtr_length_text,\r\n{ "Length of text", "rpki-rtr.length_text",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rpkirtr_error_text,\r\n{ "Erroneous Text", "rpki-rtr.error_text",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rpkirtr_refresh_interval,\r\n{ "Refresh Interval", "rpki-rtr.refresh_interval",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rpkirtr_retry_interval,\r\n{ "Retry Interval", "rpki-rtr.retry_interval",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rpkirtr_expire_interval,\r\n{ "Expire Interval", "rpki-rtr.expire_interval",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rpkirtr_subject_key_identifier,\r\n{ "Subject Key Identifier", "rpki-rtr.subject_key_identifier",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rpkirtr_subject_public_key_info,\r\n{ "Subject Public Key Info", "rpki-rtr.subject_public_key_info",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_rpkirtr,\r\n&ett_flags,\r\n&ett_flags_nd\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_rpkirtr_wrong_version_router_key, { "rpkirtr.router_key.wrong_version", PI_MALFORMED, PI_WARN, "Wrong version for Router Key type", EXPFILL }},\r\n};\r\nexpert_module_t *expert_rpkirtr;\r\nproto_rpkirtr = proto_register_protocol("RPKI-Router Protocol",\r\n"RPKI-Router Protocol", "rpkirtr");\r\nproto_register_field_array(proto_rpkirtr, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nrpkirtr_module = prefs_register_protocol(proto_rpkirtr,\r\nproto_reg_handoff_rpkirtr);\r\nprefs_register_uint_preference(rpkirtr_module, "tcp.rpkirtr.port", "RPKI-RTR TCP Port",\r\n"RPKI-Router Protocol TCP port if other than the default",\r\n10, &g_port_rpkirtr);\r\nprefs_register_uint_preference(rpkirtr_module, "tcp.rpkirtr_tls.port", "RPKI-RTR TCP TLS Port",\r\n"RPKI-Router Protocol TCP TLS port if other than the default",\r\n10, &g_port_rpkirtr_tls);\r\nexpert_rpkirtr = expert_register_protocol(proto_rpkirtr);\r\nexpert_register_field_array(expert_rpkirtr, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_rpkirtr(void)\r\n{\r\nstatic gboolean initialized = FALSE;\r\nstatic dissector_handle_t rpkirtr_handle;\r\nstatic dissector_handle_t ssl_handle;\r\nstatic int rpki_rtr_port, rpki_rtr_tls_port;\r\nif (!initialized) {\r\nrpkirtr_handle = create_dissector_handle(dissect_rpkirtr,\r\nproto_rpkirtr);\r\nssl_handle = find_dissector("ssl");\r\ninitialized = TRUE;\r\n} else {\r\ndissector_delete_uint("tcp.port", rpki_rtr_port, rpkirtr_handle);\r\ndissector_delete_uint("tcp.port", rpki_rtr_tls_port, ssl_handle);\r\n}\r\nrpki_rtr_port = g_port_rpkirtr;\r\nrpki_rtr_tls_port = g_port_rpkirtr_tls;\r\ndissector_add_uint("tcp.port", rpki_rtr_port, rpkirtr_handle);\r\ndissector_add_uint("tcp.port", rpki_rtr_tls_port, ssl_handle);\r\n}
