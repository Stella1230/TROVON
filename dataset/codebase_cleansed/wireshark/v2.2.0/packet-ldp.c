static void\r\ndissect_tlv_fec(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nstatic int *interface_params_header_fields[] = {\r\n&hf_ldp_tlv_fec_vc_intparam_length ,\r\n&hf_ldp_tlv_fec_vc_intparam_mtu ,\r\n&hf_ldp_tlv_fec_vc_intparam_tdmbps ,\r\n&hf_ldp_tlv_fec_vc_intparam_id ,\r\n&hf_ldp_tlv_fec_vc_intparam_maxcatmcells ,\r\n&hf_ldp_tlv_fec_vc_intparam_desc ,\r\n&hf_ldp_tlv_fec_vc_intparam_cepbytes ,\r\n&hf_ldp_tlv_fec_vc_intparam_cepopt_ais ,\r\n&hf_ldp_tlv_fec_vc_intparam_cepopt_une ,\r\n&hf_ldp_tlv_fec_vc_intparam_cepopt_rtp ,\r\n&hf_ldp_tlv_fec_vc_intparam_cepopt_ebm ,\r\n&hf_ldp_tlv_fec_vc_intparam_cepopt_mah ,\r\n&hf_ldp_tlv_fec_vc_intparam_cepopt_res ,\r\n&hf_ldp_tlv_fec_vc_intparam_cepopt_ceptype ,\r\n&hf_ldp_tlv_fec_vc_intparam_cepopt_t3 ,\r\n&hf_ldp_tlv_fec_vc_intparam_cepopt_e3 ,\r\n&hf_ldp_tlv_fec_vc_intparam_vlanid ,\r\n&hf_ldp_tlv_fec_vc_intparam_dlcilen ,\r\n&hf_ldp_tlv_fec_vc_intparam_fcslen ,\r\n&hf_ldp_tlv_fec_vc_intparam_tdmopt_r ,\r\n&hf_ldp_tlv_fec_vc_intparam_tdmopt_d ,\r\n&hf_ldp_tlv_fec_vc_intparam_tdmopt_f ,\r\n&hf_ldp_tlv_fec_vc_intparam_tdmopt_res1 ,\r\n&hf_ldp_tlv_fec_vc_intparam_tdmopt_pt ,\r\n&hf_ldp_tlv_fec_vc_intparam_tdmopt_res2 ,\r\n&hf_ldp_tlv_fec_vc_intparam_tdmopt_freq ,\r\n&hf_ldp_tlv_fec_vc_intparam_tdmopt_ssrc ,\r\n&hf_ldp_tlv_fec_vc_intparam_vccv_cctype_cw ,\r\n&hf_ldp_tlv_fec_vc_intparam_vccv_cctype_mplsra ,\r\n&hf_ldp_tlv_fec_vc_intparam_vccv_cctype_ttl1 ,\r\n&hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_icmpping ,\r\n&hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_lspping ,\r\n&hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_bfd1,\r\n&hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_bfd2,\r\n&hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_bfd3,\r\n&hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_bfd4,\r\n&hf_ldp_tlv_fec_vc_intparam_flowlabel_t,\r\n&hf_ldp_tlv_fec_vc_intparam_flowlabel_r,\r\n&hf_ldp_tlv_fec_vc_intparam_flowlabel_res,\r\n};\r\nproto_tree *ti, *ti2, *val_tree, *fec_tree=NULL;\r\nproto_tree *agi_tree=NULL, *saii_tree=NULL, *taii_tree=NULL;\r\nguint16 family, ix=1, ax;\r\nguint16 op_length = tvb_get_bits16(tvb, ((offset+8)*8), 16, ENC_BIG_ENDIAN);\r\nguint8 addr_size=0, *addr, implemented, prefix_len_octets, prefix_len, host_len, vc_len;\r\nguint8 intparam_len, aai_type = 0;\r\nconst char *str;\r\nguint8 gen_fec_id_len = 0;\r\naddress_type addr_type;\r\naddress addr_str;\r\nval_tree=proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "FEC Elements");\r\nwhile (rem > 0){\r\nswitch (tvb_get_guint8(tvb, offset)) {\r\ncase WILDCARD_FEC:\r\ncase CRLSP_FEC:\r\nfec_tree = proto_tree_add_subtree_format(val_tree, tvb, offset, 1,\r\nett_ldp_fec, NULL, "FEC Element %u", ix);\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_wc,tvb, offset, 1, ENC_BIG_ENDIAN);\r\nrem -= 1;\r\noffset += 1;\r\nbreak;\r\ncase PREFIX_FEC:\r\nif ( rem < 4 ){\r\nproto_tree_add_expert_format(val_tree, pinfo, &ei_ldp_tlv_fec, tvb, offset, rem, "Error in FEC Element %u", ix);\r\nreturn;\r\n}\r\nfamily=tvb_get_ntohs(tvb, offset+1);\r\nprefix_len=tvb_get_guint8(tvb, offset+3);\r\nprefix_len_octets=(prefix_len+7)/8;\r\nimplemented=1;\r\nswitch(family) {\r\ncase AFNUM_INET:\r\naddr_size=4;\r\naddr_type = AT_IPv4;\r\nbreak;\r\ncase AFNUM_INET6:\r\naddr_size=16;\r\naddr_type = AT_IPv6;\r\nbreak;\r\ndefault:\r\nimplemented=0;\r\nbreak;\r\n}\r\nif ( !implemented ) {\r\nguint16 noctets;\r\nnoctets= rem>4+prefix_len_octets?4+prefix_len_octets:rem;\r\nproto_tree_add_expert(val_tree, pinfo, &ei_ldp_address_family_not_implemented, tvb, offset, noctets);\r\noffset+=noctets;\r\nrem-=noctets;\r\nbreak;\r\n}\r\nif ( rem < 4+MIN(addr_size, prefix_len_octets) ){\r\nproto_tree_add_expert_format(val_tree, pinfo, &ei_ldp_tlv_fec, tvb, offset, rem, "Error in FEC Element %u", ix);\r\nreturn;\r\n}\r\nfec_tree = proto_tree_add_subtree_format(val_tree, tvb, offset, 4+MIN(addr_size, prefix_len_octets),\r\nett_ldp_fec, NULL, "FEC Element %u", ix);\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_wc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_af, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nti = proto_tree_add_item(fec_tree, hf_ldp_tlv_fec_len, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif ( addr_size < prefix_len_octets) {\r\noffset+=addr_size;\r\nrem-=addr_size;\r\nexpert_add_info_format(pinfo, ti, &ei_ldp_tlv_fec_len,\r\n"Invalid prefix %u length for family %s",\r\nprefix_len, val_to_str_const(family, afn_vals, "Unknown Family"));\r\nbreak;\r\n}\r\naddr=(guint8 *)wmem_alloc0(wmem_packet_scope(), addr_size);\r\nfor(ax=0; ax+1 <= prefix_len_octets; ax++)\r\naddr[ax]=tvb_get_guint8(tvb, offset+ax);\r\nif ( prefix_len % 8 )\r\naddr[ax-1] = addr[ax-1]&(0xFF<<(8-prefix_len%8));\r\nset_address(&addr_str, addr_type, addr_size, addr);\r\nstr = address_to_str(wmem_packet_scope(), &addr_str);\r\nproto_tree_add_string_format(fec_tree, hf_ldp_tlv_fec_pfval, tvb, offset, prefix_len_octets,\r\nstr, "Prefix: %s", str);\r\noffset += prefix_len_octets;\r\nrem -= 4+prefix_len_octets;\r\nbreak;\r\ncase HOST_FEC:\r\nif ( rem < 4 ){\r\nproto_tree_add_expert_format(val_tree, pinfo, &ei_ldp_tlv_fec, tvb, offset, rem, "Error in FEC Element %u", ix);\r\nreturn;\r\n}\r\nfamily=tvb_get_ntohs(tvb, offset+1);\r\nhost_len=tvb_get_guint8(tvb, offset+3);\r\nimplemented=1;\r\nswitch(family) {\r\ncase AFNUM_INET:\r\naddr_size=4;\r\naddr_type = AT_IPv4;\r\nbreak;\r\ncase AFNUM_INET6:\r\naddr_size=16;\r\naddr_type = AT_IPv6;\r\nbreak;\r\ndefault:\r\nimplemented=0;\r\nbreak;\r\n}\r\nif ( !implemented ) {\r\nguint16 noctets;\r\nnoctets= rem>4+host_len?4+host_len:rem;\r\nproto_tree_add_expert(val_tree, pinfo, &ei_ldp_address_family_not_implemented, tvb, offset, noctets);\r\noffset+=noctets;\r\nrem-=noctets;\r\nbreak;\r\n}\r\nif ( rem < 4+addr_size ){\r\nproto_tree_add_expert_format(val_tree, pinfo, &ei_ldp_tlv_fec, tvb, offset, rem, "Error in FEC Element %u", ix);\r\nreturn;\r\n}\r\nfec_tree = proto_tree_add_subtree_format(val_tree, tvb, offset, 4+addr_size, ett_ldp_fec, NULL, "FEC Element %u", ix);\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_wc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_af, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nti = proto_tree_add_item(fec_tree, hf_ldp_tlv_fec_len, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif ( addr_size != host_len) {\r\noffset+=addr_size;\r\nrem-=addr_size;\r\nexpert_add_info_format(pinfo, ti, &ei_ldp_tlv_fec_len,\r\n"Invalid address length %u length for family %s",\r\nhost_len, val_to_str_const(family, afn_vals, "Unknown Family"));\r\nbreak;\r\n}\r\naddr=(guint8 *)wmem_alloc0(wmem_packet_scope(), addr_size);\r\nfor(ax=0; ax+1 <= host_len; ax++)\r\naddr[ax]=tvb_get_guint8(tvb, offset+ax);\r\nset_address(&addr_str, addr_type, addr_size, addr);\r\nstr = address_to_str(wmem_packet_scope(), &addr_str);\r\nproto_tree_add_string_format(fec_tree, hf_ldp_tlv_fec_hoval, tvb, offset, host_len,\r\nstr, "Address: %s", str);\r\noffset += host_len;\r\nrem -= 4+host_len;\r\nbreak;\r\ncase VC_FEC:\r\nif ( rem < 8 ){\r\nproto_tree_add_expert_format(val_tree, pinfo, &ei_ldp_tlv_fec, tvb, offset, rem, "Error in FEC Element %u", ix);\r\nreturn;\r\n}\r\nvc_len = tvb_get_guint8 (tvb, offset+3);\r\nfec_tree = proto_tree_add_subtree_format(val_tree, tvb, offset, 8+vc_len, ett_ldp_fec, &ti, "FEC Element %u", ix);\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_wc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_vc_controlword, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_vc_vctype, tvb, offset+1, 2, ENC_BIG_ENDIAN);\r\nti2 = proto_tree_add_item(fec_tree, hf_ldp_tlv_fec_vc_infolength, tvb, offset+3,1,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_vc_groupid,tvb, offset +4, 4, ENC_BIG_ENDIAN);\r\nrem -=8;\r\noffset +=8;\r\nif ( (vc_len > 3) && ( rem > 3 ) ) {\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_vc_vcid,tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_item_append_text (ti," VCID: %u",tvb_get_ntohl(tvb,offset));\r\n} else {\r\nexpert_add_info(pinfo, ti2, &ei_ldp_tlv_fec_vc_infolength);\r\nreturn;\r\n}\r\nrem -= 4;\r\nvc_len -= 4;\r\noffset += 4;\r\nwhile ( (vc_len > 1) && (rem > 1) ) {\r\nintparam_len = tvb_get_guint8(tvb, offset+1);\r\nif (intparam_len < 2){\r\nproto_tree_add_expert(fec_tree, pinfo, &ei_ldp_malformed_interface_parameter, tvb, offset +1, 1);\r\nreturn;\r\n}\r\nif ( (vc_len -intparam_len) <0 && (rem -intparam_len) <0 ) {\r\nproto_tree_add_expert(fec_tree, pinfo, &ei_ldp_malformed_data, tvb, offset +2, MIN(vc_len,rem));\r\nreturn;\r\n}\r\ndissect_subtlv_interface_parameters(tvb, offset, fec_tree, intparam_len, interface_params_header_fields);\r\nrem -= intparam_len;\r\nvc_len -= intparam_len;\r\noffset += intparam_len;\r\n}\r\nbreak;\r\ncase GEN_FEC:\r\n{\r\nif ( rem < 4 ){\r\nproto_tree_add_expert_format(val_tree, pinfo, &ei_ldp_tlv_fec, tvb, offset, rem, "Error in FEC Element %u", ix);\r\nreturn;\r\n}\r\nvc_len = tvb_get_guint8 (tvb, offset+3);\r\nfec_tree = proto_tree_add_subtree_format(val_tree, tvb, offset, 8+vc_len, ett_ldp_fec, NULL, "FEC Element %u", ix);\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_wc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_vc_controlword, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_vc_vctype, tvb, offset+1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_vc_infolength, tvb, offset+3,1,ENC_BIG_ENDIAN);\r\nrem -= 4;\r\noffset += 4;\r\nif ( (vc_len > 1) && ( rem > 1 ) ) {\r\ngen_fec_id_len = tvb_get_guint8 (tvb, offset+1);\r\nagi_tree = proto_tree_add_subtree_format(fec_tree, tvb, offset, 2 + gen_fec_id_len, ett_ldp_gen_agi, NULL, "AGI");\r\nproto_tree_add_item(agi_tree, hf_ldp_tlv_fec_gen_agi_type,tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(agi_tree, hf_ldp_tlv_fec_gen_agi_length,tvb, offset + 1, 1, ENC_BIG_ENDIAN);\r\nif ( gen_fec_id_len > 0)\r\n{\r\nproto_tree_add_item(agi_tree, hf_ldp_tlv_fec_gen_agi_value, tvb, offset+2, gen_fec_id_len , ENC_NA );\r\n}\r\nrem -= 2 + gen_fec_id_len;\r\nvc_len -= 2 + gen_fec_id_len;\r\noffset += 2 + gen_fec_id_len;\r\n} else {\r\nproto_tree_add_expert_format(fec_tree, pinfo, &ei_ldp_tlv_fec_vc_infolength, tvb, offset, 2 +vc_len, "Generalized FEC: AGI size format error");\r\nreturn;\r\n}\r\nif ( (vc_len > 1) && ( rem > 1 ) ) {\r\ngen_fec_id_len = tvb_get_guint8 (tvb, offset+1);\r\naai_type = tvb_get_guint8(tvb, offset);\r\nif ( aai_type == 2 && gen_fec_id_len != 12)\r\n{\r\nproto_tree_add_expert_format(fec_tree, pinfo, &ei_ldp_tlv_fec_vc_infolength, tvb, offset, 2 + gen_fec_id_len, "Generalized FEC: SAII size format error");\r\n}\r\nelse\r\n{\r\nsaii_tree = proto_tree_add_subtree(fec_tree, tvb, offset, 2 + gen_fec_id_len, ett_ldp_gen_saii, NULL, "SAII");\r\nproto_tree_add_item(saii_tree, hf_ldp_tlv_fec_gen_saii_type,tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(saii_tree, hf_ldp_tlv_fec_gen_saii_length,tvb, offset + 1, 1, ENC_BIG_ENDIAN);\r\nif ( gen_fec_id_len > 0)\r\n{\r\nif ( aai_type == 2)\r\n{\r\ndissect_genpwid_fec_aai_type2_parameter(tvb, pinfo, offset +2, saii_tree, gen_fec_id_len);\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(saii_tree,\r\nhf_ldp_tlv_fec_gen_saii_value,\r\ntvb,\r\noffset+2,\r\ngen_fec_id_len ,\r\nENC_NA );\r\n}\r\n}\r\n}\r\nrem -= 2 + gen_fec_id_len;\r\nvc_len -= 2 + gen_fec_id_len;\r\noffset += 2 + gen_fec_id_len;\r\n} else {\r\nproto_tree_add_expert_format(fec_tree, pinfo, &ei_ldp_tlv_fec_vc_infolength, tvb, offset, 2 + vc_len, "Generalized FEC: SAII size format error");\r\nreturn;\r\n}\r\nif ( (vc_len > 1) && ( rem > 1 ) ) {\r\ngen_fec_id_len = tvb_get_guint8 (tvb, offset+1);\r\naai_type = tvb_get_guint8(tvb, offset);\r\nif ( aai_type == 2 && gen_fec_id_len != 12)\r\n{\r\nproto_tree_add_expert_format(fec_tree, pinfo, &ei_ldp_tlv_fec_vc_infolength, tvb, offset, 2 + gen_fec_id_len, "Generalized FEC: TAII size format error");\r\n}\r\nelse\r\n{\r\ntaii_tree = proto_tree_add_subtree(fec_tree, tvb, offset, 2 + gen_fec_id_len, ett_ldp_gen_taii, NULL, "TAII");\r\nproto_tree_add_item(taii_tree, hf_ldp_tlv_fec_gen_taii_type,tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(taii_tree, hf_ldp_tlv_fec_gen_taii_length,tvb, offset + 1, 1, ENC_BIG_ENDIAN);\r\nif ( gen_fec_id_len > 0)\r\n{\r\nif ( aai_type == 2)\r\n{\r\ndissect_genpwid_fec_aai_type2_parameter(tvb, pinfo, offset +2, taii_tree, gen_fec_id_len);\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(taii_tree, hf_ldp_tlv_fec_gen_taii_value, tvb, offset+2, gen_fec_id_len , ENC_NA);\r\n}\r\n}\r\n}\r\nrem -= 2 + gen_fec_id_len;\r\noffset += 2 + gen_fec_id_len;\r\n} else {\r\nproto_tree_add_expert_format(fec_tree, pinfo, &ei_ldp_tlv_fec_vc_infolength, tvb, offset, 2 +vc_len, "Generalized FEC: TAII size format error");\r\nreturn;\r\n}\r\nbreak;\r\n}\r\ncase P2MP_FEC:\r\n{\r\nif (rem < 4 ){\r\nproto_item* inv_length;\r\ninv_length = proto_tree_add_item(val_tree, hf_ldp_tlv_inv_length, tvb, offset, rem, ENC_BIG_ENDIAN);\r\nexpert_add_info(pinfo, inv_length, &ei_ldp_inv_length);\r\nreturn;\r\n}\r\nfec_tree = proto_tree_add_subtree_format(val_tree, tvb, offset, 4+tvb_get_guint8 (tvb, offset+1),\r\nett_ldp_fec, NULL, "FEC Element %u", ix);\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_wc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_af, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_fec_len, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_ldp_p2mp_rtnodeaddr, tvb,offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_ldp_p2mp_oplength, tvb,offset + 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(fec_tree, hf_ldp_tlv_ldp_p2mp_opvalue, tvb,offset + 6, op_length, ENC_NA);\r\noffset = offset + 6 + op_length;\r\nrem = rem - 10 - op_length;\r\nbreak;\r\n}\r\ndefault:\r\nfec_tree = proto_tree_add_subtree_format(val_tree, tvb, offset, 4, ett_ldp_fec, NULL, "FEC Element %u", ix);\r\nproto_tree_add_expert(fec_tree, pinfo, &ei_ldp_tlv_fec_type, tvb, offset, rem);\r\nreturn;\r\n}\r\nix++;\r\n}\r\n}\r\nstatic void\r\ndissect_tlv_address_list(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nguint16 family, ix;\r\nguint8 addr_size, *addr;\r\nconst char *str;\r\naddress_type addr_type;\r\naddress addr_str;\r\nif ( rem < 2 ) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing Address List TLV: length is %d, should be >= 2",\r\nrem);\r\nreturn;\r\n}\r\nfamily=tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(tree, hf_ldp_tlv_addrl_addr_family, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\nswitch(family) {\r\ncase AFNUM_INET:\r\naddr_size=4;\r\naddr_type = AT_IPv4;\r\nbreak;\r\ncase AFNUM_INET6:\r\naddr_size=16;\r\naddr_type = AT_IPv6;\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert(tree, pinfo, &ei_ldp_address_family_not_implemented, tvb, offset+2, rem-2);\r\nreturn;\r\n}\r\noffset+=2; rem-=2;\r\nval_tree=proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "Addresses");\r\naddr=(guint8 *)wmem_alloc(wmem_packet_scope(), addr_size);\r\nfor(ix=1; rem >= addr_size; ix++, offset += addr_size,\r\nrem -= addr_size) {\r\nif ( (tvb_memcpy(tvb, addr, offset, addr_size))\r\n== NULL)\r\nbreak;\r\nset_address(&addr_str, addr_type, addr_size, addr);\r\nstr = address_to_str(wmem_packet_scope(), &addr_str);\r\nproto_tree_add_string_format(val_tree,\r\nhf_ldp_tlv_addrl_addr, tvb, offset, addr_size, str,\r\n"Address %u: %s", ix, str);\r\n}\r\nif (rem)\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem, "Error processing TLV: Extra data at end of address list");\r\n}\r\nstatic void\r\ndissect_tlv_path_vector(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nguint8 ix;\r\nguint32 addr;\r\nval_tree=proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "LSR IDs");\r\nfor(ix=1; rem >= 4; ix++, offset += 4, rem -= 4) {\r\naddr = tvb_get_ipv4(tvb, offset);\r\nproto_tree_add_ipv4_format(val_tree,\r\nhf_ldp_tlv_pv_lsrid, tvb, offset, 4,\r\naddr, "LSR Id %u: %s", ix,\r\ntvb_ip_to_str(tvb, offset));\r\n}\r\nif (rem)\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem, "Error processing TLV: Extra data at end of path vector");\r\n}\r\nstatic void\r\ndissect_tlv_atm_label(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nif (rem != 4){\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem, "Error processing ATM Label TLV: length is %d, should be 4", rem);\r\nreturn;\r\n}\r\nval_tree=proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "ATM Label");\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_atm_label_vbits, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_atm_label_vpi, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_atm_label_vci, tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_tlv_frame_label(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nguint8 len;\r\nif (rem != 4){\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing Frame Relay Label TLV: length is %d, should be 4",\r\nrem);\r\nreturn;\r\n}\r\nval_tree=proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "Frame Relay Label");\r\nlen=(guint8)(tvb_get_ntohs(tvb, offset)>>7) & 0x03;\r\nproto_tree_add_uint_format_value(val_tree, hf_ldp_tlv_fr_label_len, tvb, offset, 2, len,\r\n"%s (%u)", val_to_str_const(len, tlv_fr_len_vals, "Unknown Length"), len);\r\nproto_tree_add_item(val_tree,\r\nhf_ldp_tlv_fr_label_dlci, tvb, offset+1, 3, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_tlv_status(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nguint32 data;\r\nif (rem != 10){\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing Status TLV: length is %d, should be 10",\r\nrem);\r\nreturn;\r\n}\r\nval_tree=proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "Status");\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_status_ebit, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_status_fbit, tvb, offset, 1, ENC_BIG_ENDIAN);\r\ndata=tvb_get_ntohl(tvb, offset)&0x3FFFFFFF;\r\nproto_tree_add_uint_format_value(val_tree, hf_ldp_tlv_status_data, tvb, offset, 4,\r\ndata, "%s (0x%X)", val_to_str_const(data, tlv_status_data, "Unknown Status Data"), data);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_status_msg_id, tvb, offset+4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_status_msg_type, tvb, offset+8, 2, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_tlv_returned_pdu(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nif (rem < 10){\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing Returned PDU TLV: length is %d, should be >= 10",\r\nrem);\r\nreturn;\r\n}\r\nval_tree=proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "Returned PDU");\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_returned_version, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_returned_pdu_len, tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_returned_lsr, tvb, offset+4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_returned_ls_id, tvb, offset+8, 2, ENC_BIG_ENDIAN);\r\noffset += 10;\r\nrem -= 10;\r\nif ( rem > 0 ) {\r\nproto_tree_add_item(val_tree, hf_ldp_returned_pdu_data, tvb, offset, rem, ENC_NA);\r\n}\r\n}\r\nstatic void\r\ndissect_tlv_returned_message(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nguint16 type;\r\nif (rem < 4) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing Returned Message TLV: length is %d, should be >= 4",\r\nrem);\r\nreturn;\r\n}\r\nval_tree=proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "Returned Message");\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_returned_msg_ubit, tvb, offset, 1, ENC_BIG_ENDIAN);\r\ntype=tvb_get_ntohs(tvb, offset)&0x7FFF;\r\nif (type>=LDP_VENDOR_PRIVATE_START && type<=LDP_VENDOR_PRIVATE_END){\r\nproto_tree_add_uint_format(val_tree, hf_ldp_tlv_returned_msg_type, tvb, offset, 2,\r\ntype, "Message Type: Vendor Private (0x%X)", type);\r\n} else if (type>=LDP_EXPERIMENTAL_MESSAGE_START && type<=LDP_EXPERIMENTAL_MESSAGE_END){\r\nproto_tree_add_uint_format(val_tree, hf_ldp_tlv_returned_msg_type, tvb, offset, 2,\r\ntype, "Message Type: Experimental (0x%X)", type);\r\n} else {\r\nproto_tree_add_uint_format(val_tree, hf_ldp_tlv_returned_msg_type, tvb, offset, 2,\r\ntype, "Message Type: %s (0x%X)", val_to_str_const(type, ldp_message_types,"Unknown Message Type"), type);\r\n}\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_returned_msg_len, tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nrem -= 4;\r\nif ( rem >= 4 ) {\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_returned_msg_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nrem -= 4;\r\n}\r\nif ( rem > 0 ) {\r\nproto_tree_add_item(val_tree, hf_ldp_returned_message_parameters, tvb, offset, rem, ENC_NA);\r\n}\r\n}\r\nstatic void\r\n#if 0\r\ndissect_tlv_common_hello_parms(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n#else\r\ndissect_tlv_common_hello_parms(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree)\r\n#endif\r\n{\r\n#if 0\r\nproto_tree *ti;\r\n#endif\r\nproto_tree *val_tree;\r\nproto_item *gtsm_flag_item;\r\nguint16 gtsm_flag_buffer;\r\n#if 0\r\nti = proto_tree_add_item(tree, hf_ldp_tlv_value, tvb, offset, rem, ENC_NA);\r\nval_tree = proto_item_add_subtree(ti, ett_ldp_tlv_val);\r\n#else\r\nval_tree=tree;\r\n#endif\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_val_hold, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_val_target, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_val_request, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\ngtsm_flag_item = proto_tree_add_item(val_tree, hf_ldp_tlv_val_gtsm_flag, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\ngtsm_flag_buffer = tvb_get_bits16(tvb, ((offset+2)*8), 16, ENC_BIG_ENDIAN);\r\nif ( gtsm_flag_buffer & 0x2000 ) {\r\nif ( gtsm_flag_buffer & 0x8000 ) {\r\nexpert_add_info(pinfo, gtsm_flag_item, &ei_ldp_dtsm_and_target);\r\n} else {\r\nexpert_add_info(pinfo, gtsm_flag_item, &ei_ldp_gtsm_supported);\r\n}\r\n} else {\r\nif ( gtsm_flag_buffer & 0x8000 ) {\r\nexpert_add_info(pinfo, gtsm_flag_item, &ei_ldp_gtsm_not_supported_basic_discovery);\r\n} else {\r\nexpert_add_info(pinfo, gtsm_flag_item, &ei_ldp_gtsm_not_supported);\r\n}\r\n}\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_val_res, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_tlv_mac(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nguint8 ix;\r\nval_tree=proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "MAC addresses");\r\nfor(ix=1; rem >= 6; ix++, offset += 6, rem -= 6) {\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_mac, tvb, offset, 6, ENC_NA);\r\n}\r\nif (rem)\r\nproto_tree_add_expert_format(val_tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem, "Error processing TLV: Extra data at end of path vector");\r\n}\r\nstatic void\r\ndissect_tlv_common_session_parms(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nif ( rem != 14) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem, "Error processing Common Session Parameters TLV: length is %d, should be 14", rem);\r\nreturn;\r\n}\r\nval_tree=proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "Parameters");\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_sess_ver, tvb,offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_sess_ka, tvb,offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_sess_advbit,tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_sess_ldetbit,tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_sess_pvlim,tvb, offset + 5, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_sess_mxpdu,tvb, offset + 6, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_sess_rxlsr,tvb, offset + 8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_sess_rxls,tvb, offset + 12, 2, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_tlv_atm_session_parms(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree, *lbl_tree;\r\nguint8 numlr, ix;\r\nif (rem < 4) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing ATM Parameters TLV: length is %d, should be >= 4",\r\nrem);\r\nreturn;\r\n}\r\nval_tree=proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "ATM Parameters");\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_sess_atm_merge,tvb, offset, 1, ENC_BIG_ENDIAN);\r\nnumlr=(tvb_get_guint8(tvb, offset)>>2) & 0x0F;\r\nproto_tree_add_uint_format(val_tree, hf_ldp_tlv_sess_atm_lr,\r\ntvb, offset, 1, numlr, "Number of Label Range components: %u",\r\nnumlr);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_sess_atm_dir,tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nrem -= 4;\r\nval_tree=proto_tree_add_subtree(val_tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "ATM Label Range Components");\r\nfor(ix=1; numlr > 0 && rem >= 8; ix++, rem-=8, numlr--) {\r\nlbl_tree=proto_tree_add_subtree_format(val_tree, tvb, offset, 8,\r\nett_ldp_tlv_val, NULL, "ATM Label Range Component %u", ix);\r\nproto_tree_add_item(lbl_tree,\r\nhf_ldp_tlv_sess_atm_minvpi,\r\ntvb, offset, 2,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(lbl_tree,\r\nhf_ldp_tlv_sess_atm_maxvpi,\r\ntvb, (offset+4), 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(lbl_tree,\r\nhf_ldp_tlv_sess_atm_minvci,\r\ntvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(lbl_tree,\r\nhf_ldp_tlv_sess_atm_maxvci,\r\ntvb, offset+6, 2, ENC_BIG_ENDIAN);\r\noffset += 8;\r\n}\r\nif( rem || numlr)\r\nproto_tree_add_expert_format(val_tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing TLV: Extra data at end of TLV");\r\n}\r\nstatic void\r\ndissect_tlv_frame_relay_session_parms(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree, *lbl_tree;\r\nguint8 numlr, ix, len;\r\nif(rem < 4) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing Frame Relay Parameters TLV: length is %d, should be >= 4",\r\nrem);\r\nreturn;\r\n}\r\nval_tree=proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "Frame Relay Parameters");\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_sess_fr_merge,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\nnumlr=(tvb_get_guint8(tvb, offset)>>2) & 0x0F;\r\nproto_tree_add_uint_format(val_tree, hf_ldp_tlv_sess_fr_lr,\r\ntvb, offset, 1, numlr, "Number of Label Range components: %u",\r\nnumlr);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_sess_fr_dir,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nrem -= 4;\r\nval_tree=proto_tree_add_subtree(val_tree, tvb, offset, rem, ett_ldp_tlv_val, NULL,\r\n"Frame Relay Label Range Components");\r\nfor(ix=1; numlr > 0 && rem >= 8; ix++, rem-=8, numlr--) {\r\nlbl_tree=proto_tree_add_subtree_format(val_tree, tvb, offset, 8,\r\nett_ldp_tlv_val, NULL, "Frame Relay Label Range Component %u", ix);\r\nlen=(guint8)(tvb_get_ntohs(tvb, offset)>>7) & 0x03;\r\nproto_tree_add_uint_format_value(lbl_tree, hf_ldp_tlv_sess_fr_len, tvb, offset, 2, len,\r\n"%s (%u)", val_to_str_const(len, tlv_fr_len_vals, "Unknown Length"), len);\r\nproto_tree_add_item(lbl_tree, hf_ldp_tlv_sess_fr_mindlci, tvb, offset+1, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(lbl_tree, hf_ldp_tlv_sess_fr_maxdlci, tvb, offset+5, 3, ENC_BIG_ENDIAN);\r\noffset += 8;\r\n}\r\nif( rem || numlr)\r\nproto_tree_add_expert_format(val_tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing TLV: Extra data at end of TLV");\r\n}\r\nstatic void\r\ndissect_tlv_ft_session(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *ti, *val_tree, *flags_tree;\r\nguint16 flags;\r\nif(rem != 12){\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing FT Session TLV: length is %d, should be 12",\r\nrem);\r\nreturn;\r\n}\r\nval_tree=proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "FT Session Parameters");\r\nti = proto_tree_add_item(val_tree, hf_ldp_tlv_ft_sess_flags, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nflags_tree = proto_item_add_subtree(ti, ett_ldp_tlv_ft_flags);\r\nflags = tvb_get_ntohs(tvb, offset);\r\nproto_item_append_text(ti, " (%s%s)", (flags & 0x8000) ? "R, " : "",\r\nval_to_str_const(flags & 0xF, tlv_ft_flags, "Invalid"));\r\nproto_tree_add_item(flags_tree, hf_ldp_tlv_ft_sess_flag_r, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_ldp_tlv_ft_sess_flag_res, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_ldp_tlv_ft_sess_flag_s, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_ldp_tlv_ft_sess_flag_a, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_ldp_tlv_ft_sess_flag_c, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_ldp_tlv_ft_sess_flag_l, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_ft_sess_res, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_ft_sess_reconn_to, tvb, offset + 4,\r\n4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_ft_sess_recovery_time, tvb, offset + 8,\r\n4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_tlv_lspid(tvbuff_t *tvb, packet_info *pinfo, guint offset,proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nif(rem != 8) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing LSP ID TLV: length is %d, should be 8",\r\nrem);\r\nreturn;\r\n}\r\nval_tree=proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "LSP ID");\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_lspid_act_flg,\r\ntvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_lspid_cr_lsp,\r\ntvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_lspid_ldpid,\r\ntvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_tlv_er_hop_ipv4(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nif(rem != 8) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing ER HOP IPv4 TLV: length is %d, should be 8",\r\nrem);\r\nreturn;\r\n}\r\nval_tree=proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "ER HOP IPv4");\r\nif(val_tree != NULL) {\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_er_hop_loose,\r\ntvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_er_hop_prelen,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_er_hop_prefix4,\r\ntvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_tlv_er_hop_ipv6(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nif(rem != 20) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing ER HOP IPv6 TLV: length is %d, should be 20",\r\nrem);\r\nreturn;\r\n}\r\nval_tree = proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "ER HOP IPv6");\r\nif(val_tree != NULL) {\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_er_hop_loose,\r\ntvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_er_hop_prelen,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_er_hop_prefix6,\r\ntvb, offset, 16, ENC_NA);\r\n}\r\n}\r\nstatic void\r\ndissect_tlv_er_hop_as(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nif(rem != 4) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing ER HOP AS TLV: length is %d, should be 4",\r\nrem);\r\nreturn;\r\n}\r\nval_tree = proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "ER HOP AS");\r\nif(val_tree != NULL) {\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_er_hop_loose,\r\ntvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_er_hop_as,\r\ntvb, offset, 2, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_tlv_er_hop_lspid(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nif(rem != 8) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing ER HOP LSPID TLV: length is %d, should be 8",\r\nrem);\r\nreturn;\r\n}\r\nval_tree = proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "ER HOP LSPID");\r\nif(val_tree != NULL) {\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_er_hop_loose,\r\ntvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_er_hop_cr_lsp,\r\ntvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_er_hop_ldpid,\r\ntvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_tlv_traffic(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nguint8 val_8;\r\nfloat val_f;\r\nproto_item *pi;\r\nif(rem != 24) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing Traffic Parameters TLV: length is %d, should be 24",\r\nrem);\r\nreturn;\r\n}\r\nval_tree = proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "Traffic parameters");\r\nif(val_tree != NULL) {\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_flags_reserv, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_flags_weight, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_flags_ebs, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_flags_cbs, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_flags_cdr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_flags_pbs, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_flags_pdr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_frequency, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\noffset ++;\r\npi = proto_tree_add_item(val_tree, hf_ldp_tlv_weight, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nval_8 = tvb_get_guint8(tvb, offset);\r\nif (val_8 == 0)\r\nproto_item_set_text(pi, "Weight: Not applicable");\r\noffset ++;\r\nval_f = tvb_get_ntohieee_float (tvb, offset);\r\nproto_tree_add_double_format_value(val_tree, hf_ldp_tlv_pdr, tvb, offset,\r\n4, val_f, "%.10g Bps", val_f);\r\noffset += 4;\r\nval_f = tvb_get_ntohieee_float (tvb, offset);\r\nproto_tree_add_double_format_value(val_tree, hf_ldp_tlv_pbs, tvb, offset,\r\n4, val_f, "%.10g Bytes", val_f);\r\noffset += 4;\r\nval_f = tvb_get_ntohieee_float (tvb, offset);\r\nproto_tree_add_double_format_value(val_tree, hf_ldp_tlv_cdr, tvb, offset,\r\n4, val_f, "%.10g Bps", val_f);\r\noffset += 4;\r\nval_f = tvb_get_ntohieee_float (tvb, offset);\r\nproto_tree_add_double_format_value(val_tree, hf_ldp_tlv_cbs, tvb, offset,\r\n4, val_f, "%.10g Bytes", val_f);\r\noffset += 4;\r\nval_f = tvb_get_ntohieee_float (tvb, offset);\r\nproto_tree_add_double_format_value(val_tree, hf_ldp_tlv_ebs, tvb, offset,\r\n4, val_f, "%.10g Bytes", val_f);\r\n}\r\n}\r\nstatic void\r\ndissect_tlv_route_pinning(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nif(rem != 4) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing Route Pinning TLV: length is %d, should be 4",\r\nrem);\r\nreturn;\r\n}\r\nval_tree = proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "Route Pinning");\r\nif(val_tree != NULL) {\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_route_pinning,\r\ntvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_tlv_resource_class(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nif(rem != 4) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing Resource Class TLV: length is %d, should be 4",\r\nrem);\r\nreturn;\r\n}\r\nval_tree = proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "Resource Class");\r\nif(val_tree != NULL) {\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_resource_class,\r\ntvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_tlv_preemption(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nif(rem != 4) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing Preemption TLV: length is %d, should be 4",\r\nrem);\r\nreturn;\r\n}\r\nval_tree = proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "Preemption");\r\nif(val_tree != NULL) {\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_set_prio,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_hold_prio,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_tlv_diffserv(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nstatic int *hfindexes[] = {\r\n&hf_ldp_tlv_diffserv_map,\r\n&hf_ldp_tlv_diffserv_map_exp,\r\n&hf_ldp_tlv_diffserv_phbid,\r\n&hf_ldp_tlv_diffserv_phbid_dscp,\r\n&hf_ldp_tlv_diffserv_phbid_code,\r\n&hf_ldp_tlv_diffserv_phbid_bit14,\r\n&hf_ldp_tlv_diffserv_phbid_bit15\r\n};\r\nstatic gint *etts[] = {\r\n&ett_ldp_diffserv_map,\r\n&ett_ldp_diffserv_map_phbid\r\n};\r\nint type, mapnb, count;\r\nif (rem < 4) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing Diff-Serv TLV: length is %d, should be >= 4", rem);\r\nreturn;\r\n}\r\nproto_tree_add_uint(tree, hf_ldp_tlv_diffserv_type, tvb, offset, 1,\r\ntype = tvb_get_guint8(tvb, offset));\r\ntype = (type >> 7) + 1;\r\nif (type == 1) {\r\noffset += 3;\r\nproto_tree_add_uint(tree, hf_ldp_tlv_diffserv_mapnb, tvb, offset,\r\n1, mapnb = tvb_get_guint8(tvb, offset) & 15);\r\noffset += 1;\r\nfor (count = 0; count < mapnb; count++) {\r\ndissect_diffserv_mpls_common(tvb, tree, type, offset, hfindexes, etts);\r\noffset += 4;\r\n}\r\n}\r\nelse if (type == 2) {\r\ndissect_diffserv_mpls_common(tvb, tree, type, offset + 2, hfindexes, etts);\r\n}\r\n}\r\nstatic void\r\ndissect_tlv_er(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nint len;\r\nval_tree = proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "Explicit route");\r\nif(val_tree != NULL) {\r\nwhile (rem > 0) {\r\nlen = dissect_tlv (tvb, pinfo, offset, val_tree, rem);\r\noffset += len;\r\nrem -= len;\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_tlv_upstrm_lbl_ass_cap(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nif ( rem != 1)\r\n{\r\nproto_item* inv_length;\r\ninv_length = proto_tree_add_item(tree, hf_ldp_tlv_inv_length, tvb, offset, rem, ENC_BIG_ENDIAN);\r\nexpert_add_info(pinfo, inv_length, &ei_ldp_inv_length);\r\nreturn;\r\n}\r\nval_tree = proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "State Bit");\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_upstr_sbit, tvb,offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_tlv_upstrm_ass_lbl_req(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nif ( rem != 4)\r\n{\r\nproto_item* inv_length;\r\ninv_length = proto_tree_add_item(tree, hf_ldp_tlv_inv_length, tvb, offset, rem, ENC_BIG_ENDIAN);\r\nexpert_add_info(pinfo, inv_length, &ei_ldp_inv_length);\r\nreturn;\r\n}\r\nproto_tree_add_item(tree, hf_ldp_tlv_upstr_lbl_req_resvbit, tvb,offset, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_tlv_upstrm_ass_lbl(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nif ( rem != 8)\r\n{\r\nproto_item* inv_length;\r\ninv_length = proto_tree_add_item(tree, hf_ldp_tlv_inv_length, tvb, offset, rem, ENC_BIG_ENDIAN);\r\nexpert_add_info(pinfo, inv_length, &ei_ldp_inv_length);\r\nreturn;\r\n}\r\nval_tree = proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "Upstream-Assigned Label");\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_upstr_lbl_resvbit, tvb,offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_upstr_ass_lbl, tvb,offset + 4, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_tlv_ipv4_interface_id(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree, *sub_tree;\r\nval_tree = proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "IPv4 Interface ID");\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_ipv4_intID_hop_addr, tvb,offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_logical_intID, tvb,offset + 4, 4, ENC_BIG_ENDIAN);\r\nsub_tree = proto_tree_add_subtree(val_tree, tvb, offset + 8, rem, ett_ldp_sub_tlv, NULL, "Sub TLV");\r\nif(rem != 20 && rem != 24 && rem != 28 && rem != 29)\r\n{\r\nproto_item* inv_length;\r\ninv_length = proto_tree_add_item(val_tree, hf_ldp_tlv_inv_length, tvb, offset, rem, ENC_BIG_ENDIAN);\r\nexpert_add_info(pinfo, inv_length, &ei_ldp_inv_length);\r\n}\r\nelse\r\n{\r\nrem = rem - 8;\r\ndissect_tlv(tvb, pinfo, offset + 8, sub_tree, rem);\r\n}\r\n}\r\nstatic void\r\ndissect_tlv_ip_multicast_tunnel(tvbuff_t *tvb, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nval_tree = proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "IP Multicast Label");\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_ip_multicast_srcaddr, tvb,offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_ip_multicast_mltcstaddr, tvb,offset + 4, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_tlv_mpls_context_lbl(tvbuff_t *tvb,packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *val_tree;\r\nproto_tree_add_item(tree, hf_ldp_tlv_ip_mpls_context_srcaddr, tvb,offset, 4, ENC_BIG_ENDIAN);\r\nval_tree = proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_tlv_val, NULL, "MPLS Context Label");\r\ndissect_tlv(tvb, pinfo, offset + 4, val_tree, rem);\r\n}\r\nstatic void\r\ndissect_tlv_ldp_p2mp_lsp(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nguint16 addr_length = tvb_get_bits16(tvb, ((offset+3)*8), 8, ENC_BIG_ENDIAN);\r\nguint16 opcode_length = tvb_get_bits16(tvb, ((offset + 4 + addr_length)*8), 16, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ldp_tlv_ldp_p2mp_lsptype, tvb,offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ldp_tlv_ldp_p2mp_addrfam, tvb,offset + 1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ldp_tlv_ldp_p2mp_addrlen, tvb,offset + 3, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ldp_tlv_ldp_p2mp_rtnodeaddr, tvb,offset + 4, addr_length, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ldp_tlv_ldp_p2mp_oplength, tvb,offset + 4 + addr_length, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ldp_tlv_ldp_p2mp_opvalue, tvb,offset + 4 + addr_length + 2, opcode_length, ENC_NA);\r\n}\r\nstatic void\r\ndissect_tlv_rsvp_te_p2mp_lsp(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ldp_tlv_rsvp_te_p2mp_id, tvb,offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ldp_tlv_must_be_zero, tvb,offset + 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ldp_tlv_tunnel_id, tvb,offset + 6, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ldp_tlv_ext_tunnel_id, tvb,offset + 8, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic int\r\ndissect_tlv(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nguint16 type, typebak;\r\nint length;\r\nlength=tvb_reported_length_remaining(tvb, offset);\r\nrem=MIN(rem, length);\r\nif( rem < 4 ) {\r\nif (tree) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing TLV: length is %d, should be >= 4",\r\nrem);\r\n}\r\nreturn rem;\r\n}\r\ntype = tvb_get_ntohs(tvb, offset) & 0x3FFF;\r\nlength = tvb_get_ntohs(tvb, offset + 2);\r\nrem -= 4;\r\nlength = MIN(length, rem);\r\nif (tree) {\r\nproto_tree *tlv_tree;\r\nif(type>=TLV_VENDOR_PRIVATE_START && type<=TLV_VENDOR_PRIVATE_END){\r\ntypebak=type;\r\ntype=TLV_VENDOR_PRIVATE_START;\r\ntlv_tree = proto_tree_add_subtree(tree, tvb, offset, length + 4, ett_ldp_tlv, NULL, "Vendor Private TLV");\r\n} else if(type>=TLV_EXPERIMENTAL_START && type<=TLV_EXPERIMENTAL_END){\r\ntypebak=type;\r\ntype=TLV_EXPERIMENTAL_START;\r\ntlv_tree = proto_tree_add_subtree(tree, tvb, offset, length + 4, ett_ldp_tlv, NULL, "Experimental TLV");\r\n} else {\r\ntypebak=0;\r\ntlv_tree = proto_tree_add_subtree(tree, tvb, offset, length + 4, ett_ldp_tlv, NULL,\r\nval_to_str(type, tlv_type_names, "Unknown TLV type (0x%04X)"));\r\n}\r\nproto_tree_add_item(tlv_tree, hf_ldp_tlv_unknown, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nswitch (type) {\r\ncase TLV_VENDOR_PRIVATE_START:\r\nproto_tree_add_uint_format_value(tlv_tree, hf_ldp_tlv_type, tvb, offset, 2,\r\ntypebak, "Vendor Private (0x%X)", typebak);\r\nbreak;\r\ncase TLV_EXPERIMENTAL_START:\r\nproto_tree_add_uint_format_value(tlv_tree, hf_ldp_tlv_type, tvb, offset, 2,\r\ntypebak, "Experimental (0x%X)", typebak);\r\nbreak;\r\ndefault:\r\nproto_tree_add_uint_format(tlv_tree, hf_ldp_tlv_type, tvb, offset, 2,\r\ntype, "TLV Type: %s (0x%X)", val_to_str_const(type, tlv_type_names, "Unknown TLV type"), type );\r\n}\r\nproto_tree_add_item(tlv_tree, hf_ldp_tlv_len, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nswitch (type) {\r\ncase TLV_FEC:\r\ndissect_tlv_fec(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_ADDRESS_LIST:\r\ndissect_tlv_address_list(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_HOP_COUNT:\r\nif( length != 1 )\r\nproto_tree_add_expert_format(tlv_tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset + 4,length,\r\n"Error processing Hop Count TLV: length is %d, should be 1",\r\nlength);\r\nelse\r\nproto_tree_add_item(tlv_tree, hf_ldp_tlv_hc_value, tvb,offset + 4, length, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase TLV_PATH_VECTOR:\r\ndissect_tlv_path_vector(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_GENERIC_LABEL:\r\nif( length != 4 )\r\nproto_tree_add_expert_format(tlv_tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset + 4, length,\r\n"Error processing Generic Label TLV: length is %d, should be 4",\r\nlength);\r\nelse {\r\nguint32 label=tvb_get_ntohl(tvb, offset+4) & 0x000FFFFF;\r\nproto_tree_add_uint(tlv_tree, hf_ldp_tlv_generic_label,\r\ntvb, offset+4, length, label);\r\n}\r\nbreak;\r\ncase TLV_ATM_LABEL:\r\ndissect_tlv_atm_label(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_FRAME_LABEL:\r\ndissect_tlv_frame_label(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_FT_PROTECTION:\r\nif( length != 4 )\r\nproto_tree_add_expert_format(tlv_tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset + 4, length,\r\n"Error processing FT Protection TLV: length is %d, should be 4",\r\nlength);\r\nelse\r\nproto_tree_add_item(tlv_tree, hf_ldp_tlv_ft_protect_sequence_num, tvb,\r\noffset + 4,length, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase TLV_STATUS:\r\ndissect_tlv_status(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_EXTENDED_STATUS:\r\nif( length != 4 )\r\nproto_tree_add_expert_format(tlv_tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset + 4, length,\r\n"Error processing Extended Status TLV: length is %d, should be 4",\r\nlength);\r\nelse {\r\nproto_tree_add_item(tlv_tree, hf_ldp_tlv_extstatus_data, tvb, offset + 4, length, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase TLV_RETURNED_PDU:\r\ndissect_tlv_returned_pdu(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_RETURNED_MESSAGE:\r\ndissect_tlv_returned_message(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_COMMON_HELLO_PARMS:\r\n#if 0\r\ndissect_tlv_common_hello_parms(tvb, pinfo, offset + 4, tlv_tree, length);\r\n#else\r\ndissect_tlv_common_hello_parms(tvb, pinfo, offset + 4, tlv_tree);\r\n#endif\r\nbreak;\r\ncase TLV_IPV4_TRANSPORT_ADDRESS:\r\nif( length != 4 )\r\nproto_tree_add_expert_format(tlv_tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset + 4, length,\r\n"Error processing IPv4 Transport Address TLV: length is %d, should be 4",\r\nlength);\r\nelse {\r\nproto_tree_add_item(tlv_tree, hf_ldp_tlv_ipv4_taddr, tvb, offset + 4, 4, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase TLV_CONFIGURATION_SEQNO:\r\nif( length != 4 )\r\nproto_tree_add_expert_format(tlv_tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset + 4, length,\r\n"Error processing Configuration Sequence Number TLV: length is %d, should be 4",\r\nlength);\r\nelse {\r\nproto_tree_add_item(tlv_tree, hf_ldp_tlv_config_seqno, tvb, offset + 4, 4, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase TLV_IPV6_TRANSPORT_ADDRESS:\r\nif( length != 16 )\r\nproto_tree_add_expert_format(tlv_tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset + 4, length,\r\n"Error processing IPv6 Transport Address TLV: length is %d, should be 16",\r\nlength);\r\nelse {\r\nproto_tree_add_item(tlv_tree, hf_ldp_tlv_ipv6_taddr, tvb, offset + 4, 16, ENC_NA);\r\n}\r\nbreak;\r\ncase TLV_MAC:\r\ndissect_tlv_mac(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_COMMON_SESSION_PARMS:\r\ndissect_tlv_common_session_parms(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_ATM_SESSION_PARMS:\r\ndissect_tlv_atm_session_parms(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_FRAME_RELAY_SESSION_PARMS:\r\ndissect_tlv_frame_relay_session_parms(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_FT_SESSION:\r\ndissect_tlv_ft_session(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_FT_ACK:\r\nif( length != 4 )\r\nproto_tree_add_expert_format(tlv_tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset + 4, length,\r\n"Error processing FT ACK TLV: length is %d, should be 4",\r\nlength);\r\nelse\r\nproto_tree_add_item(tlv_tree, hf_ldp_tlv_ft_ack_sequence_num, tvb,\r\noffset + 4,length, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase TLV_FT_CORK:\r\nif( length != 0 )\r\nproto_tree_add_expert_format(tlv_tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset + 4, length,\r\n"Error processing FT Cork TLV: length is %d, should be 0",\r\nlength);\r\nbreak;\r\ncase TLV_LABEL_REQUEST_MESSAGE_ID:\r\nif( length != 4 )\r\nproto_tree_add_expert_format(tlv_tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset + 4, length,\r\n"Error processing Label Request Message ID TLV: length is %d, should be 4",\r\nlength);\r\nelse\r\nproto_tree_add_item(tlv_tree, hf_ldp_tlv_lbl_req_msg_id, tvb,offset + 4,length, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase TLV_LSPID:\r\ndissect_tlv_lspid(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_ER:\r\ndissect_tlv_er(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_ER_HOP_IPV4:\r\ndissect_tlv_er_hop_ipv4(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_ER_HOP_IPV6:\r\ndissect_tlv_er_hop_ipv6(tvb, pinfo, offset +4, tlv_tree, length);\r\nbreak;\r\ncase TLV_ER_HOP_AS:\r\ndissect_tlv_er_hop_as(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_ER_HOP_LSPID:\r\ndissect_tlv_er_hop_lspid(tvb, pinfo, offset +4, tlv_tree, length);\r\nbreak;\r\ncase TLV_TRAFFIC_PARAM:\r\ndissect_tlv_traffic(tvb, pinfo, offset +4, tlv_tree, length);\r\nbreak;\r\ncase TLV_PREEMPTION:\r\ndissect_tlv_preemption(tvb, pinfo, offset +4, tlv_tree, length);\r\nbreak;\r\ncase TLV_RESOURCE_CLASS:\r\ndissect_tlv_resource_class(tvb, pinfo, offset +4, tlv_tree, length);\r\nbreak;\r\ncase TLV_ROUTE_PINNING:\r\ndissect_tlv_route_pinning(tvb, pinfo, offset +4, tlv_tree, length);\r\nbreak;\r\ncase TLV_DIFFSERV:\r\ndissect_tlv_diffserv(tvb, pinfo, offset +4, tlv_tree, length);\r\nbreak;\r\ncase TLV_VENDOR_PRIVATE_START:\r\nif( length < 4 )\r\nproto_tree_add_expert_format(tlv_tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset + 4, length,\r\n"Error processing Vendor Private Start TLV: length is %d, should be >= 4",\r\nlength);\r\nelse {\r\nproto_tree_add_item(tlv_tree, hf_ldp_tlv_vendor_id, tvb,offset + 4, 4, ENC_BIG_ENDIAN);\r\nif( length > 4 )\r\nproto_tree_add_item(tlv_tree, hf_ldp_data, tvb, offset + 8, length-4, ENC_NA);\r\n}\r\nbreak;\r\ncase TLV_EXPERIMENTAL_START:\r\nif( length < 4 )\r\nproto_tree_add_expert_format(tlv_tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset + 4, length,\r\n"Error processing Experimental Start TLV: length is %d, should be >= 4",\r\nlength);\r\nelse {\r\nproto_tree_add_item(tlv_tree, hf_ldp_tlv_experiment_id, tvb,offset + 4, 4, ENC_BIG_ENDIAN);\r\nif( length > 4 )\r\nproto_tree_add_item(tlv_tree, hf_ldp_data, tvb, offset + 8, length-4, ENC_NA);\r\n}\r\nbreak;\r\ncase TLV_PW_STATUS:\r\n{\r\ndissect_tlv_pw_status(tvb, pinfo, offset +4, tlv_tree, length);\r\nbreak;\r\n}\r\ncase TLV_PW_INTERFACE_PARAMETERS:\r\n{\r\nstatic int *interface_params_header_fields[] = {\r\n&hf_ldp_tlv_intparam_length ,\r\n&hf_ldp_tlv_intparam_mtu ,\r\n&hf_ldp_tlv_intparam_tdmbps ,\r\n&hf_ldp_tlv_intparam_id ,\r\n&hf_ldp_tlv_intparam_maxcatmcells ,\r\n&hf_ldp_tlv_intparam_desc ,\r\n&hf_ldp_tlv_intparam_cepbytes ,\r\n&hf_ldp_tlv_intparam_cepopt_ais ,\r\n&hf_ldp_tlv_intparam_cepopt_une ,\r\n&hf_ldp_tlv_intparam_cepopt_rtp ,\r\n&hf_ldp_tlv_intparam_cepopt_ebm ,\r\n&hf_ldp_tlv_intparam_cepopt_mah ,\r\n&hf_ldp_tlv_intparam_cepopt_res ,\r\n&hf_ldp_tlv_intparam_cepopt_ceptype ,\r\n&hf_ldp_tlv_intparam_cepopt_t3 ,\r\n&hf_ldp_tlv_intparam_cepopt_e3 ,\r\n&hf_ldp_tlv_intparam_vlanid ,\r\n&hf_ldp_tlv_intparam_dlcilen ,\r\n&hf_ldp_tlv_intparam_fcslen ,\r\n&hf_ldp_tlv_intparam_tdmopt_r ,\r\n&hf_ldp_tlv_intparam_tdmopt_d ,\r\n&hf_ldp_tlv_intparam_tdmopt_f ,\r\n&hf_ldp_tlv_intparam_tdmopt_res1 ,\r\n&hf_ldp_tlv_intparam_tdmopt_pt ,\r\n&hf_ldp_tlv_intparam_tdmopt_res2 ,\r\n&hf_ldp_tlv_intparam_tdmopt_freq ,\r\n&hf_ldp_tlv_intparam_tdmopt_ssrc ,\r\n&hf_ldp_tlv_intparam_vccv_cctype_cw ,\r\n&hf_ldp_tlv_intparam_vccv_cctype_mplsra ,\r\n&hf_ldp_tlv_intparam_vccv_cctype_ttl1 ,\r\n&hf_ldp_tlv_intparam_vccv_cvtype_icmpping ,\r\n&hf_ldp_tlv_intparam_vccv_cvtype_lspping ,\r\n&hf_ldp_tlv_intparam_vccv_cvtype_bfd,\r\n&hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_bfd2,\r\n&hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_bfd3,\r\n&hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_bfd4,\r\n&hf_ldp_tlv_fec_vc_intparam_flowlabel_t,\r\n&hf_ldp_tlv_fec_vc_intparam_flowlabel_r,\r\n&hf_ldp_tlv_fec_vc_intparam_flowlabel_res\r\n};\r\nint vc_len = length;\r\noffset += 4;\r\nwhile ( (vc_len > 1) && (rem > 1) ) {\r\nint intparam_len = tvb_get_guint8(tvb, offset+1);\r\nif (intparam_len < 2){\r\nproto_tree_add_expert(tlv_tree, pinfo, &ei_ldp_malformed_interface_parameter, tvb, offset +1, 1);\r\nbreak;\r\n}\r\nif ( (vc_len -intparam_len) <0 && (rem -intparam_len) <0 ) {\r\nproto_tree_add_expert(tlv_tree, pinfo, &ei_ldp_malformed_data, tvb, offset +2, MIN(vc_len,rem));\r\nbreak;\r\n}\r\ndissect_subtlv_interface_parameters(tvb, offset, tlv_tree, intparam_len, interface_params_header_fields);\r\nrem -= intparam_len;\r\nvc_len -= intparam_len;\r\noffset += intparam_len;\r\n}\r\nbreak;\r\n}\r\ncase TLV_PW_GROUPING:\r\n{\r\ndissect_tlv_pw_grouping(tvb, offset +4, tlv_tree, length);\r\nbreak;\r\n}\r\ncase TLV_UPSTRM_LBL_ASS_CAP:\r\ndissect_tlv_upstrm_lbl_ass_cap(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_UPSTRM_ASS_LBL_REQ:\r\ndissect_tlv_upstrm_ass_lbl_req(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_UPSTRM_ASS_LBL:\r\ndissect_tlv_upstrm_ass_lbl(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_IPV4_INTERFACE_ID:\r\ndissect_tlv_ipv4_interface_id(tvb, pinfo, offset + 4, tlv_tree, length);\r\nbreak;\r\ncase TLV_IP_MULTICAST_TUNNEL:\r\ndissect_tlv_ip_multicast_tunnel(tvb, offset + 4, tlv_tree, rem);\r\nbreak;\r\ncase TLV_MPLS_CONTEXT_LBL:\r\ndissect_tlv_mpls_context_lbl(tvb, pinfo, offset + 4, tlv_tree, rem);\r\nbreak;\r\ncase TLV_LDP_P2MP_LSP:\r\ndissect_tlv_ldp_p2mp_lsp(tvb, offset + 4, tlv_tree);\r\nbreak;\r\ncase TLV_RSVP_TE_P2MP_LSP:\r\ndissect_tlv_rsvp_te_p2mp_lsp(tvb, offset + 4, tlv_tree);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tlv_tree, hf_ldp_tlv_value, tvb, offset + 4, length, ENC_NA);\r\nbreak;\r\n}\r\n}\r\nreturn length + 4;\r\n}\r\nstatic int\r\ndissect_msg(tvbuff_t *tvb, guint offset, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint16 type, typebak;\r\nguint8 extra=0;\r\nint length, rem, ao=0, co;\r\nproto_tree *msg_tree = NULL;\r\nrem=tvb_reported_length_remaining(tvb, offset);\r\nif( rem < 8 ) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, "Bad Message");\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_inv_length, tvb, offset, rem,\r\n"Error processing Message: length is %d, should be >= 8",\r\nrem);\r\nreturn rem;\r\n}\r\ntype = tvb_get_ntohs(tvb, offset) & 0x7FFF;\r\nif(type>=LDP_VENDOR_PRIVATE_START && type<=LDP_VENDOR_PRIVATE_END){\r\ntypebak=type;\r\ntype=LDP_VENDOR_PRIVATE_START;\r\nextra=4;\r\n} else if(type>=LDP_EXPERIMENTAL_MESSAGE_START && type<=LDP_EXPERIMENTAL_MESSAGE_END){\r\ntypebak=type;\r\ntype=LDP_EXPERIMENTAL_MESSAGE_START;\r\nextra=4;\r\n} else {\r\ntypebak=0;\r\nextra=0;\r\n}\r\nif( (length = tvb_get_ntohs(tvb, offset + 2)) < (4+extra) ) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, "Bad Message Length ");\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_inv_length, tvb, offset, rem,\r\n"Error processing Message Length: length is %d, should be >= %u",\r\nlength, 4+extra);\r\nreturn rem;\r\n}\r\nrem -= 4;\r\nlength = MIN(length, rem);\r\nswitch (type) {\r\ncase LDP_VENDOR_PRIVATE_START:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Vendor-Private Message (0x%04X) ", typebak);\r\nbreak;\r\ncase LDP_EXPERIMENTAL_MESSAGE_START:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Experimental Message (0x%04X) ", typebak);\r\nbreak;\r\ndefault:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s ", val_to_str(type, ldp_message_types, "Unknown Message (0x%04X)"));\r\n}\r\nif (tree) {\r\nswitch (type) {\r\ncase LDP_VENDOR_PRIVATE_START:\r\nmsg_tree = proto_tree_add_subtree(tree, tvb, offset, length + 4, ett_ldp_message, NULL, "Vendor-Private Message");\r\nbreak;\r\ncase LDP_EXPERIMENTAL_MESSAGE_START:\r\nmsg_tree = proto_tree_add_subtree(tree, tvb, offset, length + 4, ett_ldp_message, NULL, "Experimental Message");\r\nbreak;\r\ndefault:\r\nmsg_tree = proto_tree_add_subtree(tree, tvb, offset, length + 4, ett_ldp_message, NULL,\r\nval_to_str(type, ldp_message_types, "Unknown Message type (0x%04X)"));\r\n}\r\nproto_tree_add_item(msg_tree, hf_ldp_msg_ubit, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nswitch (type) {\r\ncase LDP_VENDOR_PRIVATE_START:\r\nproto_tree_add_uint_format_value(msg_tree, hf_ldp_msg_type, tvb, offset, 2,\r\ntypebak, "Vendor Private (0x%X)", typebak);\r\nbreak;\r\ncase LDP_EXPERIMENTAL_MESSAGE_START:\r\nproto_tree_add_uint_format_value(msg_tree, hf_ldp_msg_type, tvb, offset, 2,\r\ntypebak, "Experimental (0x%X)", typebak);\r\nbreak;\r\ndefault:\r\nproto_tree_add_uint_format(msg_tree, hf_ldp_msg_type, tvb, offset, 2,\r\ntype, "Message Type: %s (0x%X)", val_to_str_const(type, ldp_message_types,"Unknown Message Type"), type);\r\n}\r\nproto_tree_add_item(msg_tree, hf_ldp_msg_len, tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(msg_tree, hf_ldp_msg_id, tvb, offset+4, 4, ENC_BIG_ENDIAN);\r\nif(extra){\r\nproto_tree_add_item(msg_tree, (type == LDP_VENDOR_PRIVATE_START) ?\r\nhf_ldp_msg_vendor_id : hf_ldp_msg_experiment_id, tvb, offset+8,\r\nextra, ENC_BIG_ENDIAN);\r\n}\r\n}\r\noffset += (8+extra);\r\nlength -= (4+extra);\r\nif (tree) {\r\nwhile ( (length-ao) > 0 ) {\r\nco = dissect_tlv(tvb, pinfo, offset, msg_tree, length-ao);\r\noffset += co;\r\nao += co;\r\n}\r\n}\r\nreturn length+8+extra;\r\n}\r\nstatic void\r\ndissect_ldp_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nint offset = 0, co;\r\nint rem, length;\r\nproto_tree *ti=NULL, *pdu_tree = NULL;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "LDP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (tree) {\r\nti=proto_tree_add_item(tree, proto_ldp, tvb, 0, -1, ENC_NA);\r\npdu_tree = proto_item_add_subtree(ti, ett_ldp);\r\nproto_tree_add_item(pdu_tree, hf_ldp_version, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n}\r\nlength = tvb_get_ntohs(tvb, offset+2);\r\nif (tree) {\r\nproto_tree_add_uint(pdu_tree, hf_ldp_pdu_len, tvb, offset+2, 2, length);\r\n}\r\nlength += 4;\r\nrem = tvb_reported_length_remaining(tvb, offset);\r\nif (length < rem)\r\ntvb_set_reported_length(tvb, length);\r\nif (tree) {\r\nproto_tree_add_item(pdu_tree, hf_ldp_lsr, tvb, offset+4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pdu_tree, hf_ldp_ls_id, tvb, offset+8, 2, ENC_BIG_ENDIAN);\r\n}\r\noffset += 10;\r\nwhile ( tvb_reported_length_remaining(tvb, offset) > 0 ) {\r\nco = dissect_msg(tvb, offset, pinfo, pdu_tree);\r\noffset += co;\r\n}\r\n}\r\nstatic int\r\ndissect_ldp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nif (tvb_captured_length(tvb) < 2) {\r\nreturn 0;\r\n}\r\nif (tvb_get_ntohs(tvb, 0) != 1) {\r\nreturn 0;\r\n}\r\ndissect_ldp_pdu(tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_tlv_pw_status(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *ti, *val_tree;\r\nif(rem != 4){\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_tlv_fec_len, tvb, offset, rem,\r\n"Error processing PW Status TLV: length is %d, should be 4",\r\nrem);\r\nreturn;\r\n}\r\nti = proto_tree_add_item(tree, hf_ldp_tlv_pw_status_data, tvb, offset, rem, ENC_BIG_ENDIAN);\r\nval_tree=proto_item_add_subtree(ti, ett_ldp_tlv_val);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_pw_not_forwarding, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_pw_lac_ingress_recv_fault, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_pw_lac_egress_recv_fault, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_pw_psn_pw_ingress_recv_fault, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(val_tree, hf_ldp_tlv_pw_psn_pw_egress_recv_fault, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_tlv_pw_grouping(tvbuff_t *tvb, guint offset, proto_tree *tree, int rem _U_)\r\n{\r\nproto_tree_add_item(tree,hf_ldp_tlv_pw_grouping_value,tvb,offset,4,ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_subtlv_interface_parameters(tvbuff_t *tvb, guint offset, proto_tree *tree, int rem, int *interface_parameters_hf[])\r\n{\r\n#if 0\r\nstatic int interface_parameters_hf[] = {\r\n0 - hf_ldp_tlv_fec_vc_intparam_length ,\r\n1 - hf_ldp_tlv_fec_vc_intparam_mtu ,\r\n2 - hf_ldp_tlv_fec_vc_intparam_tdmbps ,\r\n3 - hf_ldp_tlv_fec_vc_intparam_id ,\r\n4 - hf_ldp_tlv_fec_vc_intparam_maxcatmcells ,\r\n5 - hf_ldp_tlv_fec_vc_intparam_desc ,\r\n6 - hf_ldp_tlv_fec_vc_intparam_cepbytes ,\r\n7 - hf_ldp_tlv_fec_vc_intparam_cepopt_ais ,\r\n8 - hf_ldp_tlv_fec_vc_intparam_cepopt_une ,\r\n9 - hf_ldp_tlv_fec_vc_intparam_cepopt_rtp ,\r\n10 - hf_ldp_tlv_fec_vc_intparam_cepopt_ebm ,\r\n11 - hf_ldp_tlv_fec_vc_intparam_cepopt_mah ,\r\n12 - hf_ldp_tlv_fec_vc_intparam_cepopt_res ,\r\n13 - hf_ldp_tlv_fec_vc_intparam_cepopt_ceptype ,\r\n14 - hf_ldp_tlv_fec_vc_intparam_cepopt_t3 ,\r\n15 - hf_ldp_tlv_fec_vc_intparam_cepopt_e3 ,\r\n16 - hf_ldp_tlv_fec_vc_intparam_vlanid ,\r\n17 - hf_ldp_tlv_fec_vc_intparam_dlcilen ,\r\n18 - hf_ldp_tlv_fec_vc_intparam_fcslen ,\r\n19 - hf_ldp_tlv_fec_vc_intparam_tdmopt_r ,\r\n20 - hf_ldp_tlv_fec_vc_intparam_tdmopt_d ,\r\n21 - hf_ldp_tlv_fec_vc_intparam_tdmopt_f ,\r\n22 - hf_ldp_tlv_fec_vc_intparam_tdmopt_res1 ,\r\n23 - hf_ldp_tlv_fec_vc_intparam_tdmopt_pt ,\r\n24 - hf_ldp_tlv_fec_vc_intparam_tdmopt_res2 ,\r\n25 - hf_ldp_tlv_fec_vc_intparam_tdmopt_freq ,\r\n26 - hf_ldp_tlv_fec_vc_intparam_tdmopt_ssrc ,\r\n27 - hf_ldp_tlv_fec_vc_intparam_vccv_cctype_cw ,\r\n28 - hf_ldp_tlv_fec_vc_intparam_vccv_cctype_mplsra ,\r\n29 - hf_ldp_tlv_fec_vc_intparam_vccv_cctype_ttl1 ,\r\n30 - hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_icmpping ,\r\n31 - hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_lspping ,\r\n32 - hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_bfd1,\r\n33 - hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_bfd2,\r\n34 - hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_bfd3,\r\n35 - hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_bfd4,\r\n36 - hf_ldp_tlv_fec_vc_intparam_flowlabel_t,\r\n37 - hf_ldp_tlv_fec_vc_intparam_flowlabel_r,\r\n38 - hf_ldp_tlv_fec_vc_intparam_flowlabel_res\r\n};\r\n#endif\r\nproto_tree *ti;\r\nproto_tree *cepopt_tree=NULL, *vccvtype_tree=NULL;\r\nproto_tree *vcintparam_tree = proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_fec_vc_interfaceparam, &ti, "Interface Parameter");\r\nguint8 intparam_len = rem;\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[3],tvb,offset,1,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[0],tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nswitch (tvb_get_guint8(tvb, offset)) {\r\ncase FEC_VC_INTERFACEPARAM_MTU:\r\nproto_item_append_text(ti,": MTU %u", tvb_get_ntohs(tvb,offset+2));\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[1],tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase FEC_VC_INTERFACEPARAM_TDMBPS:\r\nproto_item_append_text(ti,": BPS %u", tvb_get_ntohl(tvb,offset+2));\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[2],tvb, offset+2, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase FEC_VC_INTERFACEPARAM_MAXCATMCELLS:\r\nproto_item_append_text(ti,": Max ATM Concat Cells %u", tvb_get_ntohs(tvb,offset+2));\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[4],tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase FEC_VC_INTERFACEPARAM_DESCRIPTION:\r\nproto_item_append_text(ti,": Description");\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[5],tvb, offset+2, (intparam_len -2), ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase FEC_VC_INTERFACEPARAM_CEPBYTES:\r\nproto_item_append_text(ti,": CEP/TDM Payload Bytes %u", tvb_get_ntohs(tvb,offset+2));\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[6],tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase FEC_VC_INTERFACEPARAM_CEPOPTIONS:\r\nproto_item_append_text(ti,": CEP Options");\r\ncepopt_tree = proto_tree_add_subtree(vcintparam_tree, tvb, offset + 2, 2, ett_ldp_fec_vc_interfaceparam_cepopt, NULL, "CEP Options");\r\nproto_tree_add_item(cepopt_tree, *interface_parameters_hf[7], tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(cepopt_tree, *interface_parameters_hf[8], tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(cepopt_tree, *interface_parameters_hf[9], tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(cepopt_tree, *interface_parameters_hf[10], tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(cepopt_tree, *interface_parameters_hf[11], tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(cepopt_tree, *interface_parameters_hf[12], tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(cepopt_tree, *interface_parameters_hf[13], tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(cepopt_tree, *interface_parameters_hf[14], tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(cepopt_tree, *interface_parameters_hf[15], tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase FEC_VC_INTERFACEPARAM_VLANID:\r\nproto_item_append_text(ti,": VLAN Id %u", tvb_get_ntohs(tvb,offset+2));\r\nproto_tree_add_item(vcintparam_tree, *interface_parameters_hf[16], tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase FEC_VC_INTERFACEPARAM_FRDLCILEN:\r\nproto_item_append_text(ti,": DLCI Length %u", tvb_get_ntohs(tvb,offset+2));\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[17], tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase FEC_VC_INTERFACEPARAM_FRAGIND:\r\nproto_item_append_text(ti,": Fragmentation");\r\nbreak;\r\ncase FEC_VC_INTERFACEPARAM_FCSRETENT:\r\nproto_item_append_text(ti,": FCS retention, FCS Length %u Bytes", tvb_get_ntohs(tvb,offset+2));\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[18], tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase FEC_VC_INTERFACEPARAM_TDMOPTION:\r\nproto_item_append_text(ti,": TDM Options");\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[19], tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[20], tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[21], tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[22], tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nif (intparam_len >= 8){\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[23], tvb, offset+4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[24], tvb, offset+5, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[25], tvb, offset+6, 2, ENC_BIG_ENDIAN);\r\n}\r\nif (intparam_len >= 12){\r\nproto_tree_add_item(vcintparam_tree,*interface_parameters_hf[26], tvb, offset+8, 4, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase FEC_VC_INTERFACEPARAM_VCCV:\r\nproto_item_append_text(ti,": VCCV");\r\nvccvtype_tree = proto_tree_add_subtree(vcintparam_tree, tvb, offset + 2, 1, ett_ldp_fec_vc_interfaceparam_vccvtype, NULL, "CC Type");\r\nproto_tree_add_item(vccvtype_tree, *interface_parameters_hf[27], tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vccvtype_tree, *interface_parameters_hf[28], tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vccvtype_tree, *interface_parameters_hf[29], tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\nvccvtype_tree = proto_tree_add_subtree(vcintparam_tree, tvb, offset + 3, 1, ett_ldp_fec_vc_interfaceparam_vccvtype, NULL, "CV Type");\r\nproto_tree_add_item(vccvtype_tree, *interface_parameters_hf[30], tvb, offset+3, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vccvtype_tree, *interface_parameters_hf[31], tvb, offset+3, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vccvtype_tree, *interface_parameters_hf[32], tvb, offset+3, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase FEC_VC_INTERFACEPARAM_FLOWLABEL:\r\nproto_item_append_text(ti,": Flow Label for Pseudowire");\r\nproto_tree_add_item(vcintparam_tree, *interface_parameters_hf[36], tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vcintparam_tree, *interface_parameters_hf[37], tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vcintparam_tree, *interface_parameters_hf[38], tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nproto_item_append_text(ti," unknown");\r\nproto_tree_add_item(vcintparam_tree, hf_ldp_unknown_data, tvb, offset+2, (intparam_len -2), ENC_NA);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndissect_genpwid_fec_aai_type2_parameter(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)\r\n{\r\nproto_tree *aai_param_tree = proto_tree_add_subtree(tree, tvb, offset, rem, ett_ldp_gen_aai_type2, NULL, "AAI");\r\nif ( rem != 12)\r\n{\r\nproto_tree_add_expert_format(tree, pinfo, &ei_ldp_inv_length, tvb, offset, rem,\r\n"Error processing AAI Parameter: length is %d, should be 12 bytes for Type 2.",\r\nrem);\r\nreturn;\r\n}\r\nproto_tree_add_item(aai_param_tree,hf_ldp_tlv_fec_gen_aai_globalid,tvb,offset,4,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(aai_param_tree,hf_ldp_tlv_fec_gen_aai_prefix,tvb, offset+4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(aai_param_tree,hf_ldp_tlv_fec_gen_aai_ac_id,tvb, offset+4, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic int\r\ndissect_ldp_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nvolatile gboolean first = TRUE;\r\nvolatile int offset = 0;\r\nint length_remaining;\r\nguint16 plen;\r\nint length;\r\ntvbuff_t *volatile next_tvb;\r\nwhile (tvb_reported_length_remaining(tvb, offset) != 0) {\r\nlength_remaining = tvb_captured_length_remaining(tvb, offset);\r\nif (first) {\r\nif (length_remaining < 2) {\r\nreturn 0;\r\n}\r\nif (tvb_get_ntohs(tvb, offset) != 1) {\r\nreturn 0;\r\n}\r\nfirst = FALSE;\r\n}\r\nif (ldp_desegment && pinfo->can_desegment) {\r\nif (length_remaining < 4) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn -((gint32) pinfo->desegment_len);\r\n}\r\n}\r\nplen = tvb_get_ntohs(tvb, offset + 2);\r\nif (ldp_desegment && pinfo->can_desegment) {\r\nif (length_remaining < plen + 4) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = (plen + 4) - length_remaining;\r\nreturn -((gint32) pinfo->desegment_len);\r\n}\r\n}\r\nlength = length_remaining;\r\nif (length > plen + 4)\r\nlength = plen + 4;\r\nnext_tvb = tvb_new_subset(tvb, offset, length, plen + 4);\r\nTRY {\r\ndissect_ldp_pdu(next_tvb, pinfo, tree);\r\n}\r\nCATCH_NONFATAL_ERRORS {\r\nshow_exception(tvb, pinfo, tree, EXCEPT_CODE, GET_MESSAGE);\r\n}\r\nENDTRY;\r\noffset += plen + 4;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ldp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n#if 0\r\n{ &hf_ldp_req,\r\n{ "Request", "ldp.req", FT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n#endif\r\n#if 0\r\n{ &hf_ldp_rsp,\r\n{ "Response", "ldp.rsp", FT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n#endif\r\n{ &hf_ldp_version,\r\n{ "Version", "ldp.hdr.version", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "LDP Version Number", HFILL }},\r\n{ &hf_ldp_pdu_len,\r\n{ "PDU Length", "ldp.hdr.pdu_len", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "LDP PDU Length", HFILL }},\r\n{ &hf_ldp_lsr,\r\n{ "LSR ID", "ldp.hdr.ldpid.lsr", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, "LDP Label Space Router ID", HFILL }},\r\n{ &hf_ldp_ls_id,\r\n{ "Label Space ID", "ldp.hdr.ldpid.lsid", FT_UINT16, BASE_DEC,\r\nNULL, 0, "LDP Label Space ID", HFILL }},\r\n{ &hf_ldp_msg_ubit,\r\n{ "U bit", "ldp.msg.ubit", FT_BOOLEAN, 8,\r\nTFS(&ldp_message_ubit), 0x80, "Unknown Message Bit", HFILL }},\r\n{ &hf_ldp_msg_type,\r\n{ "Message Type", "ldp.msg.type", FT_UINT16, BASE_HEX,\r\nVALS(ldp_message_types), 0x7FFF, "LDP message type", HFILL }},\r\n{ &hf_ldp_msg_len,\r\n{ "Message Length", "ldp.msg.len", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "LDP Message Length (excluding message type and len)", HFILL }},\r\n{ &hf_ldp_msg_id,\r\n{ "Message ID", "ldp.msg.id", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, "LDP Message ID", HFILL }},\r\n{ &hf_ldp_msg_vendor_id,\r\n{ "Vendor ID", "ldp.msg.vendor.id", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, "LDP Vendor-private Message ID", HFILL }},\r\n{ &hf_ldp_msg_experiment_id,\r\n{ "Experiment ID", "ldp.msg.experiment.id", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, "LDP Experimental Message ID", HFILL }},\r\n{ &hf_ldp_tlv_unknown,\r\n{ "TLV Unknown bits", "ldp.msg.tlv.unknown", FT_UINT8, BASE_HEX,\r\nVALS(tlv_unknown_vals), 0xC0, "TLV Unknown bits Field", HFILL }},\r\n{ &hf_ldp_tlv_type,\r\n{ "TLV Type", "ldp.msg.tlv.type", FT_UINT16, BASE_HEX,\r\nVALS(tlv_type_names), 0x3FFF, "TLV Type Field", HFILL }},\r\n{ &hf_ldp_tlv_len,\r\n{ "TLV Length", "ldp.msg.tlv.len", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "TLV Length Field", HFILL }},\r\n{ &hf_ldp_tlv_value,\r\n{ "TLV Value", "ldp.msg.tlv.value", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "TLV Value Bytes", HFILL }},\r\n{ &hf_ldp_tlv_val_hold,\r\n{ "Hold Time", "ldp.msg.tlv.hello.hold", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "Hello Common Parameters Hold Time", HFILL }},\r\n{ &hf_ldp_tlv_val_target,\r\n{ "Targeted Hello", "ldp.msg.tlv.hello.targeted", FT_BOOLEAN, 16,\r\nTFS(&hello_targeted_vals), 0x8000, "Hello Common Parameters Targeted Bit", HFILL }},\r\n{ &hf_ldp_tlv_val_request,\r\n{ "Hello Requested", "ldp.msg.tlv.hello.requested", FT_BOOLEAN, 16,\r\nTFS(&hello_requested_vals), 0x4000, "Hello Common Parameters Hello Requested Bit", HFILL }},\r\n{ &hf_ldp_tlv_val_gtsm_flag,\r\n{ "GTSM Flag", "ldp.msg.tlv.hello.gtsm", FT_BOOLEAN, 16,\r\nTFS(&tfs_set_notset), 0x2000, "Hello Common Parameters GTSM bit", HFILL }},\r\n{ &hf_ldp_tlv_val_res,\r\n{ "Reserved", "ldp.msg.tlv.hello.res", FT_UINT16, BASE_HEX,\r\nNULL, 0x1FFF, "Hello Common Parameters Reserved Field", HFILL }},\r\n{ &hf_ldp_tlv_ipv4_taddr,\r\n{ "IPv4 Transport Address", "ldp.msg.tlv.ipv4.taddr", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_config_seqno,\r\n{ "Configuration Sequence Number", "ldp.msg.tlv.hello.cnf_seqno", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "Hello Configuration Sequence Number", HFILL }},\r\n{ &hf_ldp_tlv_ipv6_taddr,\r\n{ "IPv6 Transport Address", "ldp.msg.tlv.ipv6.taddr", FT_IPv6, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_fec_wc,\r\n{ "FEC Element Type", "ldp.msg.tlv.fec.type", FT_UINT8, BASE_DEC,\r\nVALS(fec_types_vals), 0x0, "Forwarding Equivalence Class Element Types", HFILL }},\r\n{ &hf_ldp_tlv_fec_af,\r\n{ "FEC Element Address Type", "ldp.msg.tlv.fec.af", FT_UINT16, BASE_DEC,\r\nVALS(afn_vals), 0x0, "Forwarding Equivalence Class Element Address Family", HFILL }},\r\n{ &hf_ldp_tlv_fec_len,\r\n{ "FEC Element Length", "ldp.msg.tlv.fec.len", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, "Forwarding Equivalence Class Element Length", HFILL }},\r\n{ &hf_ldp_tlv_fec_pfval,\r\n{ "FEC Element Prefix Value", "ldp.msg.tlv.fec.pfval", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "Forwarding Equivalence Class Element Prefix", HFILL }},\r\n{ &hf_ldp_tlv_fec_hoval,\r\n{ "FEC Element Host Address Value", "ldp.msg.tlv.fec.hoval", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "Forwarding Equivalence Class Element Address", HFILL }},\r\n{ &hf_ldp_tlv_addrl_addr_family,\r\n{ "Address Family", "ldp.msg.tlv.addrl.addr_family", FT_UINT16, BASE_DEC,\r\nVALS(afn_vals), 0x0, "Address Family List", HFILL }},\r\n{ &hf_ldp_tlv_addrl_addr,\r\n{ "Address", "ldp.msg.tlv.addrl.addr", FT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_hc_value,\r\n{ "Hop Count Value", "ldp.msg.tlv.hc.value", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, "Hop Count", HFILL }},\r\n{ &hf_ldp_tlv_pv_lsrid,\r\n{ "LSR Id", "ldp.msg.tlv.pv.lsrid", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, "Path Vector LSR Id", HFILL }},\r\n{ &hf_ldp_tlv_sess_ver,\r\n{ "Session Protocol Version", "ldp.msg.tlv.sess.ver", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "Common Session Parameters Protocol Version", HFILL }},\r\n{ &hf_ldp_tlv_sess_ka,\r\n{ "Session KeepAlive Time", "ldp.msg.tlv.sess.ka", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "Common Session Parameters KeepAlive Time", HFILL }},\r\n{ &hf_ldp_tlv_sess_advbit,\r\n{ "Session Label Advertisement Discipline", "ldp.msg.tlv.sess.advbit", FT_BOOLEAN, 8,\r\nTFS(&tlv_sess_advbit_vals), 0x80, "Common Session Parameters Label Advertisement Discipline", HFILL }},\r\n{ &hf_ldp_tlv_sess_ldetbit,\r\n{ "Session Loop Detection", "ldp.msg.tlv.sess.ldetbit", FT_BOOLEAN, 8,\r\nTFS(&tlv_sess_ldetbit_vals), 0x40, "Common Session Parameters Loop Detection", HFILL }},\r\n{ &hf_ldp_tlv_sess_pvlim,\r\n{ "Session Path Vector Limit", "ldp.msg.tlv.sess.pvlim", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, "Common Session Parameters Path Vector Limit", HFILL }},\r\n{ &hf_ldp_tlv_sess_mxpdu,\r\n{ "Session Max PDU Length", "ldp.msg.tlv.sess.mxpdu", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "Common Session Parameters Max PDU Length", HFILL }},\r\n{ &hf_ldp_tlv_sess_rxlsr,\r\n{ "Session Receiver LSR Identifier", "ldp.msg.tlv.sess.rxlsr", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, "Common Session Parameters LSR Identifier", HFILL }},\r\n{ &hf_ldp_tlv_sess_rxls,\r\n{ "Session Receiver Label Space Identifier", "ldp.msg.tlv.sess.rxls", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "Common Session Parameters Receiver Label Space Identifier", HFILL }},\r\n{ &hf_ldp_tlv_sess_atm_merge,\r\n{ "Session ATM Merge Parameter", "ldp.msg.tlv.sess.atm.merge", FT_UINT8, BASE_DEC,\r\nVALS(tlv_atm_merge_vals), 0xC0, "Merge ATM Session Parameters", HFILL }},\r\n{ &hf_ldp_tlv_sess_atm_lr,\r\n{ "Number of ATM Label Ranges", "ldp.msg.tlv.sess.atm.lr", FT_UINT8, BASE_DEC,\r\nNULL, 0x3C, "Number of Label Ranges", HFILL }},\r\n{ &hf_ldp_tlv_sess_atm_dir,\r\n{ "Directionality", "ldp.msg.tlv.sess.atm.dir", FT_BOOLEAN, 8,\r\nTFS(&tlv_atm_dirbit), 0x02, "Label Directionality", HFILL }},\r\n{ &hf_ldp_tlv_sess_atm_minvpi,\r\n{ "Minimum VPI", "ldp.msg.tlv.sess.atm.minvpi", FT_UINT16, BASE_DEC,\r\nNULL, 0x0FFF, NULL, HFILL }},\r\n{ &hf_ldp_tlv_sess_atm_minvci,\r\n{ "Minimum VCI", "ldp.msg.tlv.sess.atm.minvci", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_sess_atm_maxvpi,\r\n{ "Maximum VPI", "ldp.msg.tlv.sess.atm.maxvpi", FT_UINT16, BASE_DEC,\r\nNULL, 0x0FFF, NULL, HFILL }},\r\n{ &hf_ldp_tlv_sess_atm_maxvci,\r\n{ "Maximum VCI", "ldp.msg.tlv.sess.atm.maxvci", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_sess_fr_merge,\r\n{ "Session Frame Relay Merge Parameter", "ldp.msg.tlv.sess.fr.merge", FT_UINT8, BASE_DEC,\r\nVALS(tlv_fr_merge_vals), 0xC0, "Merge Frame Relay Session Parameters", HFILL }},\r\n{ &hf_ldp_tlv_sess_fr_lr,\r\n{ "Number of Frame Relay Label Ranges", "ldp.msg.tlv.sess.fr.lr", FT_UINT8, BASE_DEC,\r\nNULL, 0x3C, "Number of Label Ranges", HFILL }},\r\n{ &hf_ldp_tlv_sess_fr_dir,\r\n{ "Directionality", "ldp.msg.tlv.sess.fr.dir", FT_BOOLEAN, 8,\r\nTFS(&tlv_atm_dirbit), 0x02, "Label Directionality", HFILL }},\r\n{ &hf_ldp_tlv_sess_fr_len,\r\n{ "Number of DLCI bits", "ldp.msg.tlv.sess.fr.len", FT_UINT16, BASE_DEC,\r\nVALS(tlv_fr_len_vals), 0x0180, "DLCI Number of bits", HFILL }},\r\n{ &hf_ldp_tlv_sess_fr_mindlci,\r\n{ "Minimum DLCI", "ldp.msg.tlv.sess.fr.mindlci", FT_UINT24, BASE_DEC,\r\nNULL, 0x7FFFFF, NULL, HFILL }},\r\n{ &hf_ldp_tlv_sess_fr_maxdlci,\r\n{ "Maximum DLCI", "ldp.msg.tlv.sess.fr.maxdlci", FT_UINT24, BASE_DEC,\r\nNULL, 0x7FFFFF, NULL, HFILL }},\r\n{ &hf_ldp_tlv_ft_sess_flags,\r\n{ "Flags", "ldp.msg.tlv.ft_sess.flags", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, "FT Session Flags", HFILL }},\r\n{ &hf_ldp_tlv_ft_sess_flag_r,\r\n{ "R bit", "ldp.msg.tlv.ft_sess.flag_r", FT_BOOLEAN, 16,\r\nTFS(&tlv_ft_r), 0x8000, "FT Reconnect Flag", HFILL }},\r\n{ &hf_ldp_tlv_ft_sess_flag_res,\r\n{ "Reserved", "ldp.msg.tlv.ft_sess.flag_res", FT_UINT16, BASE_HEX,\r\nNULL, 0x7FF0, "Reserved bits", HFILL }},\r\n{ &hf_ldp_tlv_ft_sess_flag_s,\r\n{ "S bit", "ldp.msg.tlv.ft_sess.flag_s", FT_BOOLEAN, 16,\r\nTFS(&tlv_ft_s), 0x8, "Save State Flag", HFILL }},\r\n{ &hf_ldp_tlv_ft_sess_flag_a,\r\n{ "A bit", "ldp.msg.tlv.ft_sess.flag_a", FT_BOOLEAN, 16,\r\nTFS(&tlv_ft_a), 0x4, "All-Label protection Required", HFILL }},\r\n{ &hf_ldp_tlv_ft_sess_flag_c,\r\n{ "C bit", "ldp.msg.tlv.ft_sess.flag_c", FT_BOOLEAN, 16,\r\nTFS(&tlv_ft_c), 0x2, "Check-Pointint Flag", HFILL }},\r\n{ &hf_ldp_tlv_ft_sess_flag_l,\r\n{ "L bit", "ldp.msg.tlv.ft_sess.flag_l", FT_BOOLEAN, 16,\r\nTFS(&tlv_ft_l), 0x1, "Learn From network Flag", HFILL }},\r\n{ &hf_ldp_tlv_ft_sess_res,\r\n{ "Reserved", "ldp.msg.tlv.ft_sess.res", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_ft_sess_reconn_to,\r\n{ "Reconnect Timeout", "ldp.msg.tlv.ft_sess.reconn_to", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "FT Reconnect Timeout", HFILL }},\r\n{ &hf_ldp_tlv_ft_sess_recovery_time,\r\n{ "Recovery Time", "ldp.msg.tlv.ft_sess.recovery_time", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_ft_ack_sequence_num,\r\n{ "FT ACK Sequence Number", "ldp.msg.tlv.ft_ack.sequence_num", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_lbl_req_msg_id,\r\n{ "Label Request Message ID", "ldp.msg.tlv.lbl_req_msg_id", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, "Label Request Message to be aborted", HFILL }},\r\n{ &hf_ldp_tlv_vendor_id,\r\n{ "Vendor ID", "ldp.msg.tlv.vendor_id", FT_UINT32, BASE_HEX,\r\nNULL, 0, "IEEE 802 Assigned Vendor ID", HFILL }},\r\n{ &hf_ldp_tlv_experiment_id,\r\n{ "Experiment ID", "ldp.msg.tlv.experiment_id", FT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_generic_label,\r\n{ "Generic Label", "ldp.msg.tlv.generic.label", FT_UINT32, BASE_HEX,\r\nNULL, 0x000FFFFF, NULL, HFILL }},\r\n{ &hf_ldp_tlv_atm_label_vbits,\r\n{ "V-bits", "ldp.msg.tlv.atm.label.vbits", FT_UINT8, BASE_HEX,\r\nVALS(tlv_atm_vbits_vals), 0x30, "ATM Label V Bits", HFILL }},\r\n{ &hf_ldp_tlv_atm_label_vpi,\r\n{ "VPI", "ldp.msg.tlv.atm.label.vpi", FT_UINT16, BASE_DEC,\r\nNULL, 0x0FFF, "ATM Label VPI", HFILL }},\r\n{ &hf_ldp_tlv_atm_label_vci,\r\n{ "VCI", "ldp.msg.tlv.atm.label.vci", FT_UINT16, BASE_DEC,\r\nNULL, 0, "ATM Label VCI", HFILL }},\r\n{ &hf_ldp_tlv_fr_label_len,\r\n{ "Number of DLCI bits", "ldp.msg.tlv.fr.label.len", FT_UINT16, BASE_DEC,\r\nVALS(tlv_fr_len_vals), 0x0180, "DLCI Number of bits", HFILL }},\r\n{ &hf_ldp_tlv_fr_label_dlci,\r\n{ "DLCI", "ldp.msg.tlv.fr.label.dlci", FT_UINT24, BASE_DEC,\r\nNULL, 0x7FFFFF, "FRAME RELAY Label DLCI", HFILL }},\r\n{ &hf_ldp_tlv_ft_protect_sequence_num,\r\n{ "FT Sequence Number", "ldp.msg.tlv.ft_protect.sequence_num", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_status_ebit,\r\n{ "E Bit", "ldp.msg.tlv.status.ebit", FT_BOOLEAN, 8,\r\nTFS(&tlv_status_ebit), 0x80, "Fatal Error Bit", HFILL }},\r\n{ &hf_ldp_tlv_status_fbit,\r\n{ "F Bit", "ldp.msg.tlv.status.fbit", FT_BOOLEAN, 8,\r\nTFS(&tlv_status_fbit), 0x40, "Forward Bit", HFILL }},\r\n{ &hf_ldp_tlv_status_data,\r\n{ "Status Data", "ldp.msg.tlv.status.data", FT_UINT32, BASE_HEX,\r\nVALS(tlv_status_data), 0x3FFFFFFF, NULL, HFILL }},\r\n{ &hf_ldp_tlv_status_msg_id,\r\n{ "Message ID", "ldp.msg.tlv.status.msg.id", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, "Identifies peer message to which Status TLV refers", HFILL }},\r\n{ &hf_ldp_tlv_status_msg_type,\r\n{ "Message Type", "ldp.msg.tlv.status.msg.type", FT_UINT16, BASE_HEX,\r\nVALS(ldp_message_types), 0x0, "Type of peer message to which Status TLV refers", HFILL }},\r\n{ &hf_ldp_tlv_extstatus_data,\r\n{ "Extended Status Data", "ldp.msg.tlv.extstatus.data", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_returned_version,\r\n{ "Returned PDU Version", "ldp.msg.tlv.returned.version", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "LDP Version Number", HFILL }},\r\n{ &hf_ldp_tlv_returned_pdu_len,\r\n{ "Returned PDU Length", "ldp.msg.tlv.returned.pdu_len", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "LDP PDU Length", HFILL }},\r\n{ &hf_ldp_tlv_returned_lsr,\r\n{ "Returned PDU LSR ID", "ldp.msg.tlv.returned.ldpid.lsr", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, "LDP Label Space Router ID", HFILL }},\r\n{ &hf_ldp_tlv_returned_ls_id,\r\n{ "Returned PDU Label Space ID", "ldp.msg.tlv.returned.ldpid.lsid", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, "LDP Label Space ID", HFILL }},\r\n{ &hf_ldp_tlv_returned_msg_ubit,\r\n{ "Returned Message Unknown bit", "ldp.msg.tlv.returned.msg.ubit", FT_BOOLEAN, 8,\r\nTFS(&ldp_message_ubit), 0x80, "Message Unknown bit", HFILL }},\r\n{ &hf_ldp_tlv_returned_msg_type,\r\n{ "Returned Message Type", "ldp.msg.tlv.returned.msg.type", FT_UINT16, BASE_HEX,\r\nVALS(ldp_message_types), 0x7FFF, "LDP message type", HFILL }},\r\n{ &hf_ldp_tlv_returned_msg_len,\r\n{ "Returned Message Length", "ldp.msg.tlv.returned.msg.len", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "LDP Message Length (excluding message type and len)", HFILL }},\r\n{ &hf_ldp_tlv_returned_msg_id,\r\n{ "Returned Message ID", "ldp.msg.tlv.returned.msg.id", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, "LDP Message ID", HFILL }},\r\n{ &hf_ldp_tlv_mac,\r\n{ "MAC address", "ldp.msg.tlv.mac", FT_ETHER, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_ldp_tlv_fec_vc_controlword,\r\n{ "C-bit", "ldp.msg.tlv.fec.vc.controlword", FT_BOOLEAN, 8,\r\nTFS(&fec_vc_cbit), 0x80, "Control Word Present", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_vctype,\r\n{ "VC Type", "ldp.msg.tlv.fec.vc.vctype", FT_UINT16, BASE_HEX,\r\nVALS(fec_vc_types_vals), 0x7FFF, "Virtual Circuit Type", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_infolength,\r\n{ "VC Info Length", "ldp.msg.tlv.fec.vc.infolength", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, "VC FEC Info Length", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_groupid,\r\n{ "Group ID", "ldp.msg.tlv.fec.vc.groupid", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "VC FEC Group ID", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_vcid,\r\n{ "VC ID", "ldp.msg.tlv.fec.vc.vcid", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "VC FEC VCID", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_length,\r\n{ "Length", "ldp.msg.tlv.fec.vc.intparam.length", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, "VC FEC Interface Parameter Length", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_mtu,\r\n{ "MTU", "ldp.msg.tlv.fec.vc.intparam.mtu", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "VC FEC Interface Parameter MTU", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_tdmbps,\r\n{ "BPS", "ldp.msg.tlv.fec.vc.intparam.tdmbps", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "VC FEC Interface Parameter CEP/TDM bit-rate", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_id,\r\n{ "ID", "ldp.msg.tlv.fec.vc.intparam.id", FT_UINT8, BASE_HEX,\r\nVALS(fec_vc_interfaceparm), 0x0, "VC FEC Interface Parameter ID", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_maxcatmcells,\r\n{ "Number of Cells", "ldp.msg.tlv.fec.vc.intparam.maxatm", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "VC FEC Interface Param Max ATM Concat Cells", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_desc,\r\n{ "Description", "ldp.msg.tlv.fec.vc.intparam.desc", FT_STRING, BASE_NONE,\r\nNULL, 0, "VC FEC Interface Description", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_cepbytes,\r\n{ "Payload Bytes", "ldp.msg.tlv.fec.vc.intparam.cepbytes", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "VC FEC Interface Param CEP/TDM Payload Bytes", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_cepopt_ais,\r\n{ "AIS", "ldp.msg.tlv.fec.vc.intparam.cepopt_ais", FT_BOOLEAN, 16,\r\nNULL, 0x8000, "VC FEC Interface Param CEP Option AIS", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_cepopt_une,\r\n{ "UNE", "ldp.msg.tlv.fec.vc.intparam.cepopt_une", FT_BOOLEAN, 16,\r\nNULL, 0x4000, "VC FEC Interface Param CEP Option Unequipped", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_cepopt_rtp,\r\n{ "RTP", "ldp.msg.tlv.fec.vc.intparam.cepopt_rtp", FT_BOOLEAN, 16,\r\nNULL, 0x2000, "VC FEC Interface Param CEP Option RTP Header", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_cepopt_ebm,\r\n{ "EBM", "ldp.msg.tlv.fec.vc.intparam.cepopt_ebm", FT_BOOLEAN, 16,\r\nNULL, 0x1000, "VC FEC Interface Param CEP Option EBM Header", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_cepopt_mah,\r\n{ "MAH", "ldp.msg.tlv.fec.vc.intparam.cepopt_mah", FT_BOOLEAN, 16,\r\nNULL, 0x0800, "VC FEC Interface Param CEP Option MPLS Adaptation header", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_cepopt_res,\r\n{ "Reserved", "ldp.msg.tlv.fec.vc.intparam.cepopt_res", FT_UINT16, BASE_HEX,\r\nNULL , 0x07E0, "VC FEC Interface Param CEP Option Reserved", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_cepopt_ceptype,\r\n{ "CEP Type", "ldp.msg.tlv.fec.vc.intparam.cepopt_ceptype", FT_UINT16, BASE_HEX,\r\nVALS(fec_vc_ceptype_vals), 0x001C, "VC FEC Interface Param CEP Option CEP Type", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_cepopt_t3,\r\n{ "Async T3", "ldp.msg.tlv.fec.vc.intparam.cepopt_t3", FT_BOOLEAN, 16,\r\nNULL, 0x0002, "VC FEC Interface Param CEP Option Async T3", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_cepopt_e3,\r\n{ "Async E3", "ldp.msg.tlv.fec.vc.intparam.cepopt_e3", FT_BOOLEAN, 16,\r\nNULL, 0x0001, "VC FEC Interface Param CEP Option Async E3", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_vlanid,\r\n{ "VLAN Id", "ldp.msg.tlv.fec.vc.intparam.vlanid", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "VC FEC Interface Param VLAN Id", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_dlcilen,\r\n{ "DLCI Length", "ldp.msg.tlv.fec.vc.intparam.dlcilen", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "VC FEC Interface Parameter Frame-Relay DLCI Length", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_fcslen,\r\n{ "FCS Length", "ldp.msg.tlv.fec.vc.intparam.fcslen", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "VC FEC Interface Parameter FCS Length", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_tdmopt_r,\r\n{ "R Bit", "ldp.msg.tlv.fec.vc.intparam.tdmopt_r", FT_BOOLEAN, 16,\r\nTFS(&fec_vc_tdmopt_r), 0x8000, "VC FEC Interface Param TDM Options RTP Header", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_tdmopt_d,\r\n{ "D Bit", "ldp.msg.tlv.fec.vc.intparam.tdmopt_d", FT_BOOLEAN, 16,\r\nTFS(&fec_vc_tdmopt_d), 0x4000, "VC FEC Interface Param TDM Options Dynamic Timestamp", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_tdmopt_f,\r\n{ "F Bit", "ldp.msg.tlv.fec.vc.intparam.tdmopt_f", FT_BOOLEAN, 16,\r\nTFS(&fec_vc_tdmopt_f), 0x2000, "VC FEC Interface Param TDM Options Flavor bit", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_tdmopt_res1,\r\n{ "RSVD-1", "ldp.msg.tlv.fec.vc.intparam.tdmopt_res1", FT_UINT16, BASE_HEX,\r\nNULL, 0x1FFF, "VC FEC Interface Param TDM Options Reserved", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_tdmopt_pt,\r\n{ "PT", "ldp.msg.tlv.fec.vc.intparam.tdmopt_pt", FT_UINT8, BASE_DEC,\r\nNULL, 0x7F, "VC FEC Interface Param TDM Options Payload Type", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_tdmopt_res2,\r\n{ "RSVD-2", "ldp.msg.tlv.fec.vc.intparam.tdmopt_res2", FT_UINT8, BASE_HEX,\r\nNULL, 0x00, "VC FEC Interface Param TDM Options Reserved", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_tdmopt_freq,\r\n{ "FREQ", "ldp.msg.tlv.fec.vc.intparam.tdmopt_freq", FT_UINT16, BASE_DEC,\r\nNULL, 0x00, "VC FEC Interface Param TDM Options Frequency", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_tdmopt_ssrc,\r\n{ "SSRC", "ldp.msg.tlv.fec.vc.intparam.tdmopt_ssrc", FT_UINT32, BASE_HEX,\r\nNULL, 0x00, "VC FEC Interface Param TDM Options SSRC", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_vccv_cctype_cw,\r\n{ "PWE3 Control Word", "ldp.msg.tlv.fec.vc.intparam.vccv.cctype_cw", FT_BOOLEAN, 8,\r\nNULL, 0x01, "VC FEC Interface Param VCCV CC Type PWE3 CW", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_vccv_cctype_mplsra,\r\n{ "MPLS Router Alert", "ldp.msg.tlv.fec.vc.intparam.vccv.cctype_mplsra", FT_BOOLEAN, 8,\r\nNULL, 0x02, "VC FEC Interface Param VCCV CC Type MPLS Router Alert", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_vccv_cctype_ttl1,\r\n{ "MPLS Inner Label TTL = 1", "ldp.msg.tlv.fec.vc.intparam.vccv.cctype_ttl1", FT_BOOLEAN, 8,\r\nNULL, 0x04, "VC FEC Interface Param VCCV CC Type Inner Label TTL 1", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_icmpping,\r\n{ "ICMP Ping", "ldp.msg.tlv.fec.vc.intparam.vccv.cvtype_icmpping", FT_BOOLEAN, 8,\r\nNULL, 0x01, "VC FEC Interface Param VCCV CV Type ICMP Ping", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_lspping,\r\n{ "LSP Ping", "ldp.msg.tlv.fec.vc.intparam.vccv.cvtype_lspping", FT_BOOLEAN, 8,\r\nNULL, 0x02, "VC FEC Interface Param VCCV CV Type LSP Ping", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_bfd1,\r\n{ "BFD IP/UDP-encapsulated, for PW Fault Detection only", "ldp.msg.tlv.fec.vc.intparam.vccv.cvtype_bfd1", FT_BOOLEAN, 8,\r\nNULL, 0x04, "VC FEC Interface Param VCCV CV Type BFD IP/UDP-encapsulated, for PW Fault Detection only", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_bfd2,\r\n{ "BFD IP/UDP-encapsulated, for PW Fault Detection and AC/PW Fault Status Signaling", "ldp.msg.tlv.fec.vc.intparam.vccv.cvtype_bfd2", FT_BOOLEAN, 8,\r\nNULL, 0x08, "VC FEC Interface Param VCCV CV Type BFD IP/UDP-encapsulated, for PW Fault Detection and AC/PW Fault Status Signaling", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_bfd3,\r\n{ "BFD BFD PW-ACH-encapsulated, for PW Fault Detection only", "ldp.msg.tlv.fec.vc.intparam.vccv.cvtype_bfd3", FT_BOOLEAN, 8,\r\nNULL, 0x10, "VC FEC Interface Param VCCV CV Type BFD PW-ACH-encapsulated, for PW Fault Detection only", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_vccv_cvtype_bfd4,\r\n{ "BFD BFD PW-ACH-encapsulated, for PW Fault Detection and AC/PW Fault Status Signaling", "ldp.msg.tlv.fec.vc.intparam.vccv.cvtype_bfd4", FT_BOOLEAN, 8,\r\nNULL, 0x20, "VC FEC Interface Param VCCV CV Type BFD PW-ACH-encapsulated, for PW Fault Detection and AC/PW Fault Status Signaling", HFILL }},\r\n{ &hf_ldp_tlv_fec_vc_intparam_flowlabel_t,\r\n{ "Flow Label Transmit bit", "ldp.msg.tlv.fec.vc.intparam.flowlabel.t", FT_UINT8, BASE_DEC, NULL, 0x80, NULL, HFILL}},\r\n{ &hf_ldp_tlv_fec_vc_intparam_flowlabel_r,\r\n{ "Flow Label Receive bit", "ldp.msg.tlv.fec.vc.intparam.flowlabel.r", FT_UINT8, BASE_DEC, NULL, 0x40, NULL, HFILL}},\r\n{ &hf_ldp_tlv_fec_vc_intparam_flowlabel_res,\r\n{ "Flow Label Reserved", "ldp.msg.tlv.fec.vc.intparam.flowlabel.res", FT_UINT16, BASE_HEX, NULL, 0x3FFF, NULL, HFILL}},\r\n{ &hf_ldp_tlv_lspid_act_flg,\r\n{ "Action Indicator Flag", "ldp.msg.tlv.lspid.actflg", FT_UINT16, BASE_HEX,\r\nVALS(ldp_act_flg_vals), 0x000F, NULL, HFILL}},\r\n{ &hf_ldp_tlv_lspid_cr_lsp,\r\n{ "Local CR-LSP ID", "ldp.msg.tlv.lspid.locallspid", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_ldp_tlv_lspid_ldpid,\r\n{ "Ingress LSR Router ID", "ldp.msg.tlv.lspid.lsrid", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_ldp_tlv_er_hop_loose,\r\n{ "Loose route bit", "ldp.msg.tlv.er_hop.loose", FT_UINT24, BASE_HEX,\r\nVALS(ldp_loose_vals), 0x800000, NULL, HFILL}},\r\n{ &hf_ldp_tlv_er_hop_prelen,\r\n{ "Prefix length", "ldp.msg.tlv.er_hop.prefixlen", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, "Prefix len", HFILL}},\r\n{ &hf_ldp_tlv_er_hop_prefix4,\r\n{ "IPv4 Address", "ldp.msg.tlv.er_hop.prefix4", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_ldp_tlv_er_hop_prefix6,\r\n{ "IPv6 Address", "ldp.msg.tlv.er_hop.prefix6", FT_IPv6, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_ldp_tlv_er_hop_as,\r\n{ "AS Number", "ldp.msg.tlv.er_hop.as", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_ldp_tlv_er_hop_cr_lsp,\r\n{ "Local CR-LSP ID", "ldp.msg.tlv.er_hop.locallspid", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_ldp_tlv_er_hop_ldpid,\r\n{ "Local CR-LSP ID", "ldp.msg.tlv.er_hop.lsrid", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_ldp_tlv_flags_reserv,\r\n{ "Reserved", "ldp.msg.tlv.flags_reserv", FT_UINT8, BASE_HEX,\r\nNULL, 0xC0, NULL, HFILL}},\r\n{ &hf_ldp_tlv_flags_pdr,\r\n{ "PDR", "ldp.msg.tlv.flags_pdr", FT_BOOLEAN, 8,\r\nTFS(&tlv_negotiable), 0x1, "PDR negotiability flag", HFILL}},\r\n{ &hf_ldp_tlv_flags_pbs,\r\n{ "PBS", "ldp.msg.tlv.flags_pbs", FT_BOOLEAN, 8,\r\nTFS(&tlv_negotiable), 0x2, "PBS negotiability flag", HFILL}},\r\n{ &hf_ldp_tlv_flags_cdr,\r\n{ "CDR", "ldp.msg.tlv.flags_cdr", FT_BOOLEAN, 8,\r\nTFS(&tlv_negotiable), 0x4, "CDR negotiability flag", HFILL}},\r\n{ &hf_ldp_tlv_flags_cbs,\r\n{ "CBS", "ldp.msg.tlv.flags_cbs", FT_BOOLEAN, 8,\r\nTFS(&tlv_negotiable), 0x8, "CBS negotiability flag", HFILL}},\r\n{ &hf_ldp_tlv_flags_ebs,\r\n{ "EBS", "ldp.msg.tlv.flags_ebs", FT_BOOLEAN, 8,\r\nTFS(&tlv_negotiable), 0x10, "EBS negotiability flag", HFILL}},\r\n{ &hf_ldp_tlv_flags_weight,\r\n{ "Weight", "ldp.msg.tlv.flags_weight", FT_BOOLEAN, 8,\r\nTFS(&tlv_negotiable), 0x20, "Weight negotiability flag", HFILL}},\r\n{ &hf_ldp_tlv_frequency,\r\n{ "Frequency", "ldp.msg.tlv.frequency", FT_UINT8, BASE_DEC,\r\nVALS(freq_values), 0, NULL, HFILL}},\r\n{ &hf_ldp_tlv_weight,\r\n{ "Weight", "ldp.msg.tlv.weight", FT_UINT8, BASE_DEC,\r\nNULL, 0, "Weight of the CR-LSP", HFILL}},\r\n{ &hf_ldp_tlv_pdr,\r\n{ "PDR", "ldp.msg.tlv.pdr", FT_DOUBLE, BASE_NONE,\r\nNULL, 0, "Peak Data Rate", HFILL}},\r\n{ &hf_ldp_tlv_pbs,\r\n{ "PBS", "ldp.msg.tlv.pbs", FT_DOUBLE, BASE_NONE,\r\nNULL, 0, "Peak Burst Size", HFILL}},\r\n{ &hf_ldp_tlv_cdr,\r\n{ "CDR", "ldp.msg.tlv.cdr", FT_DOUBLE, BASE_NONE,\r\nNULL, 0, "Committed Data Rate", HFILL}},\r\n{ &hf_ldp_tlv_cbs,\r\n{ "CBS", "ldp.msg.tlv.cbs", FT_DOUBLE, BASE_NONE,\r\nNULL, 0, "Committed Burst Size", HFILL}},\r\n{ &hf_ldp_tlv_ebs,\r\n{ "EBS", "ldp.msg.tlv.ebs", FT_DOUBLE, BASE_NONE,\r\nNULL, 0, "Excess Burst Size", HFILL}},\r\n{ &hf_ldp_tlv_set_prio,\r\n{ "Set Prio", "ldp.msg.tlv.set_prio", FT_UINT8, BASE_DEC,\r\nNULL, 0, "LSP setup priority", HFILL}},\r\n{ &hf_ldp_tlv_hold_prio,\r\n{ "Hold Prio", "ldp.msg.tlv.hold_prio", FT_UINT8, BASE_DEC,\r\nNULL, 0, "LSP hold priority", HFILL}},\r\n{ &hf_ldp_tlv_route_pinning,\r\n{ "Route Pinning", "ldp.msg.tlv.route_pinning", FT_UINT32, BASE_DEC,\r\nVALS(route_pinning_vals), 0x80000000, NULL, HFILL}},\r\n{ &hf_ldp_tlv_resource_class,\r\n{ "Resource Class", "ldp.msg.tlv.resource_class", FT_UINT32, BASE_HEX,\r\nNULL, 0, "Resource Class (Color)", HFILL}},\r\n#if 0\r\n{ &hf_ldp_tlv_diffserv,\r\n{ "Diff-Serv TLV", "ldp.msg.tlv.diffserv", FT_NONE, BASE_NONE,\r\nNULL, 0, "Diffserv TLV", HFILL}},\r\n#endif\r\n{ &hf_ldp_tlv_diffserv_type,\r\n{ "LSP Type", "ldp.msg.tlv.diffserv.type", FT_UINT8, BASE_DEC,\r\nVALS(diffserv_type_vals), 0x80, NULL, HFILL}},\r\n{ &hf_ldp_tlv_diffserv_mapnb,\r\n{ "MAPnb", "ldp.msg.tlv.diffserv.mapnb", FT_UINT8, BASE_DEC,\r\nNULL, 0, MAPNB_DESCRIPTION, HFILL}},\r\n{ &hf_ldp_tlv_diffserv_map,\r\n{ "MAP", "ldp.msg.tlv.diffserv.map", FT_NONE, BASE_NONE,\r\nNULL, 0, MAP_DESCRIPTION, HFILL}},\r\n{ &hf_ldp_tlv_diffserv_map_exp,\r\n{ "EXP", "ldp.msg.tlv.diffserv.map.exp", FT_UINT8, BASE_DEC,\r\nNULL, 0, EXP_DESCRIPTION, HFILL}},\r\n{ &hf_ldp_tlv_diffserv_phbid,\r\n{ PHBID_DESCRIPTION, "ldp.msg.tlv.diffserv.phbid", FT_NONE, BASE_NONE,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_ldp_tlv_diffserv_phbid_dscp,\r\n{ PHBID_DSCP_DESCRIPTION, "ldp.msg.tlv.diffserv.phbid.dscp", FT_UINT16, BASE_DEC,\r\nNULL, PHBID_DSCP_MASK, NULL, HFILL}},\r\n{ &hf_ldp_tlv_diffserv_phbid_code,\r\n{ PHBID_CODE_DESCRIPTION, "ldp.msg.tlv.diffserv.phbid.code", FT_UINT16, BASE_DEC,\r\nNULL, PHBID_CODE_MASK, NULL, HFILL}},\r\n{ &hf_ldp_tlv_diffserv_phbid_bit14,\r\n{ PHBID_BIT14_DESCRIPTION, "ldp.msg.tlv.diffserv.phbid.bit14", FT_UINT16, BASE_DEC,\r\nVALS(phbid_bit14_vals), PHBID_BIT14_MASK, NULL, HFILL}},\r\n{ &hf_ldp_tlv_diffserv_phbid_bit15,\r\n{ PHBID_BIT15_DESCRIPTION, "ldp.msg.tlv.diffserv.phbid.bit15", FT_UINT16, BASE_DEC,\r\nVALS(phbid_bit15_vals), PHBID_BIT15_MASK, NULL, HFILL}},\r\n{ &hf_ldp_tlv_fec_gen_agi_type,\r\n{ "AGI Type", "ldp.msg.tlv.fec.gen.agi.type", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, "Attachment Group Identifier Type", HFILL}},\r\n{ &hf_ldp_tlv_fec_gen_agi_length,\r\n{ "AGI Length", "ldp.msg.tlv.fec.gen.agi.length", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, "Attachment Group Identifier Length", HFILL}},\r\n{ &hf_ldp_tlv_fec_gen_agi_value,\r\n{ "AGI Value", "ldp.msg.tlv.fec.gen.agi.value", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "Attachment Group Identifier Value", HFILL}},\r\n{ &hf_ldp_tlv_fec_gen_saii_type,\r\n{ "SAII Type", "ldp.msg.tlv.fec.gen.saii.type", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, "Source Attachment Individual Identifier Type", HFILL}},\r\n{ &hf_ldp_tlv_fec_gen_saii_length,\r\n{ "SAII Length", "ldp.msg.tlv.fec.gen.saii.length", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, "Source Attachment Individual Identifier Length", HFILL}},\r\n{ &hf_ldp_tlv_fec_gen_saii_value,\r\n{ "SAII Value", "ldp.msg.tlv.fec.gen.saii.value", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "Source Attachment Individual Identifier Value", HFILL}},\r\n{ &hf_ldp_tlv_fec_gen_taii_type,\r\n{ "TAII Type", "ldp.msg.tlv.fec.gen.taii.type", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, "Target Attachment Individual Identifier Type", HFILL}},\r\n{ &hf_ldp_tlv_fec_gen_taii_length,\r\n{ "TAII length", "ldp.msg.tlv.fec.gen.taii.length", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, "Target Attachment Individual Identifier Length", HFILL}},\r\n{ &hf_ldp_tlv_fec_gen_taii_value,\r\n{ "TAII Value", "ldp.msg.tlv.fec.gen.taii.value", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "Target Attachment Individual Identifier Value", HFILL}},\r\n{ &hf_ldp_tlv_fec_gen_aai_globalid,\r\n{ "Global Id", "ldp.msg.tlv.fec.gen.aii.globalid", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "Attachment Individual Identifier Global Id", HFILL}},\r\n{ &hf_ldp_tlv_fec_gen_aai_prefix,\r\n{ "Prefix", "ldp.msg.tlv.fec.gen.aii.prefix", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "Attachment Individual Identifier Prefix", HFILL}},\r\n{ &hf_ldp_tlv_fec_gen_aai_ac_id,\r\n{ "Prefix", "ldp.msg.tlv.fec.gen.aii.acid", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "Attachment Individual Identifier AC Id", HFILL}},\r\n{ &hf_ldp_tlv_pw_status_data,\r\n{ "PW Status", "ldp.msg.tlv.pwstatus.code", FT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_pw_not_forwarding,\r\n{ "Pseudowire Not Forwarding", "ldp.msg.tlv.pwstatus.code.pwnotforward", FT_BOOLEAN, 32,\r\nTFS(&tfs_set_notset), PW_NOT_FORWARDING, NULL, HFILL }},\r\n{ &hf_ldp_tlv_pw_lac_ingress_recv_fault,\r\n{ "Local Attachment Circuit (ingress) Receive Fault", "ldp.msg.tlv.pwstatus.code.pwlacingressrecvfault",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), PW_LAC_INGRESS_RECV_FAULT, NULL, HFILL }},\r\n{ &hf_ldp_tlv_pw_lac_egress_recv_fault,\r\n{ "Local Attachment Circuit (egress) Transmit Fault", "ldp.msg.tlv.pwstatus.code.pwlacegresstransfault",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), PW_LAC_EGRESS_TRANS_FAULT, NULL, HFILL }},\r\n{ &hf_ldp_tlv_pw_psn_pw_ingress_recv_fault,\r\n{ "Local PSN-facing PW (ingress) Receive Fault", "ldp.msg.tlv.pwstatus.code.pwpsnpwingressrecvfault",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), PW_PSN_PW_INGRESS_RECV_FAULT, NULL, HFILL }},\r\n{ &hf_ldp_tlv_pw_psn_pw_egress_recv_fault,\r\n{ "Local PSN-facing PW (egress) Transmit Fault", "ldp.msg.tlv.pwstatus.code.pwpsnpwegresstransfault",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), PW_PSN_PW_EGRESS_TRANS_FAULT, NULL, HFILL }},\r\n{ &hf_ldp_tlv_pw_grouping_value,\r\n{ "Value", "ldp.msg.tlv.pwgrouping.value",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"PW Grouping Value", HFILL }},\r\n{ &hf_ldp_tlv_intparam_length,\r\n{ "Length", "ldp.msg.tlv.intparam.length", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, "VC FEC Interface Parameter Length", HFILL }},\r\n{ &hf_ldp_tlv_intparam_mtu,\r\n{ "MTU", "ldp.msg.tlv.intparam.mtu", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "VC FEC Interface Parameter MTU", HFILL }},\r\n{ &hf_ldp_tlv_intparam_tdmbps,\r\n{ "BPS", "ldp.msg.tlv.intparam.tdmbps", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "VC FEC Interface Parameter CEP/TDM bit-rate", HFILL }},\r\n{ &hf_ldp_tlv_intparam_id,\r\n{ "ID", "ldp.msg.tlv.intparam.id", FT_UINT8, BASE_HEX,\r\nVALS(fec_vc_interfaceparm), 0x0, "VC FEC Interface Parameter ID", HFILL }},\r\n{ &hf_ldp_tlv_intparam_maxcatmcells,\r\n{ "Number of Cells", "ldp.msg.tlv.intparam.maxatm", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "VC FEC Interface Param Max ATM Concat Cells", HFILL }},\r\n{ &hf_ldp_tlv_intparam_desc,\r\n{ "Description", "ldp.msg.tlv.intparam.desc", FT_STRING, BASE_NONE,\r\nNULL, 0, "VC FEC Interface Description", HFILL }},\r\n{ &hf_ldp_tlv_intparam_cepbytes,\r\n{ "Payload Bytes", "ldp.msg.tlv.intparam.cepbytes", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "VC FEC Interface Param CEP/TDM Payload Bytes", HFILL }},\r\n{ &hf_ldp_tlv_intparam_cepopt_ais,\r\n{ "AIS", "ldp.msg.tlv.intparam.cepopt_ais", FT_BOOLEAN, 16,\r\nNULL, 0x8000, "VC FEC Interface Param CEP Option AIS", HFILL }},\r\n{ &hf_ldp_tlv_intparam_cepopt_une,\r\n{ "UNE", "ldp.msg.tlv.intparam.cepopt_une", FT_BOOLEAN, 16,\r\nNULL, 0x4000, "VC FEC Interface Param CEP Option Unequipped", HFILL }},\r\n{ &hf_ldp_tlv_intparam_cepopt_rtp,\r\n{ "RTP", "ldp.msg.tlv.intparam.cepopt_rtp", FT_BOOLEAN, 16,\r\nNULL, 0x2000, "VC FEC Interface Param CEP Option RTP Header", HFILL }},\r\n{ &hf_ldp_tlv_intparam_cepopt_ebm,\r\n{ "EBM", "ldp.msg.tlv.intparam.cepopt_ebm", FT_BOOLEAN, 16,\r\nNULL, 0x1000, "VC FEC Interface Param CEP Option EBM Header", HFILL }},\r\n{ &hf_ldp_tlv_intparam_cepopt_mah,\r\n{ "MAH", "ldp.msg.tlv.intparam.cepopt_mah", FT_BOOLEAN, 16,\r\nNULL, 0x0800, "VC FEC Interface Param CEP Option MPLS Adaptation header", HFILL }},\r\n{ &hf_ldp_tlv_intparam_cepopt_res,\r\n{ "Reserved", "ldp.msg.tlv.intparam.cepopt_res", FT_UINT16, BASE_HEX,\r\nNULL , 0x07E0, "VC FEC Interface Param CEP Option Reserved", HFILL }},\r\n{ &hf_ldp_tlv_intparam_cepopt_ceptype,\r\n{ "CEP Type", "ldp.msg.tlv.intparam.cepopt_ceptype", FT_UINT16, BASE_HEX,\r\nVALS(fec_vc_ceptype_vals), 0x001C, "VC FEC Interface Param CEP Option CEP Type", HFILL }},\r\n{ &hf_ldp_tlv_intparam_cepopt_t3,\r\n{ "Async T3", "ldp.msg.tlv.intparam.cepopt_t3", FT_BOOLEAN, 16,\r\nNULL, 0x0002, "VC FEC Interface Param CEP Option Async T3", HFILL }},\r\n{ &hf_ldp_tlv_intparam_cepopt_e3,\r\n{ "Async E3", "ldp.msg.tlv.intparam.cepopt_e3", FT_BOOLEAN, 16,\r\nNULL, 0x0001, "VC FEC Interface Param CEP Option Async E3", HFILL }},\r\n{ &hf_ldp_tlv_intparam_vlanid,\r\n{ "VLAN Id", "ldp.msg.tlv.intparam.vlanid", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "VC FEC Interface Param VLAN Id", HFILL }},\r\n{ &hf_ldp_tlv_intparam_dlcilen,\r\n{ "DLCI Length", "ldp.msg.tlv.intparam.dlcilen", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "VC FEC Interface Parameter Frame-Relay DLCI Length", HFILL }},\r\n{ &hf_ldp_tlv_intparam_fcslen,\r\n{ "FCS Length", "ldp.msg.tlv.intparam.fcslen", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "VC FEC Interface Parameter FCS Length", HFILL }},\r\n{ &hf_ldp_tlv_intparam_tdmopt_r,\r\n{ "R Bit", "ldp.msg.tlv.intparam.tdmopt_r", FT_BOOLEAN, 16,\r\nTFS(&fec_vc_tdmopt_r), 0x8000, "VC FEC Interface Param TDM Options RTP Header", HFILL }},\r\n{ &hf_ldp_tlv_intparam_tdmopt_d,\r\n{ "D Bit", "ldp.msg.tlv.intparam.tdmopt_d", FT_BOOLEAN, 16,\r\nTFS(&fec_vc_tdmopt_d), 0x4000, "VC FEC Interface Param TDM Options Dynamic Timestamp", HFILL }},\r\n{ &hf_ldp_tlv_intparam_tdmopt_f,\r\n{ "F Bit", "ldp.msg.tlv.intparam.tdmopt_f", FT_BOOLEAN, 16,\r\nTFS(&fec_vc_tdmopt_f), 0x2000, "VC FEC Interface Param TDM Options Flavor bit", HFILL }},\r\n{ &hf_ldp_tlv_intparam_tdmopt_res1,\r\n{ "RSVD-1", "ldp.msg.tlv.intparam.tdmopt_res1", FT_UINT16, BASE_HEX,\r\nNULL, 0x1FFF, "VC FEC Interface Param TDM Options Reserved", HFILL }},\r\n{ &hf_ldp_tlv_intparam_tdmopt_pt,\r\n{ "PT", "ldp.msg.tlv.intparam.tdmopt_pt", FT_UINT8, BASE_DEC,\r\nNULL, 0x7F, "VC FEC Interface Param TDM Options Payload Type", HFILL }},\r\n{ &hf_ldp_tlv_intparam_tdmopt_res2,\r\n{ "RSVD-2", "ldp.msg.tlv.intparam.tdmopt_res2", FT_UINT8, BASE_HEX,\r\nNULL, 0x00, "VC FEC Interface Param TDM Options Reserved", HFILL }},\r\n{ &hf_ldp_tlv_intparam_tdmopt_freq,\r\n{ "FREQ", "ldp.msg.tlv.intparam.tdmopt_freq", FT_UINT16, BASE_DEC,\r\nNULL, 0x00, "VC FEC Interface Param TDM Options Frequency", HFILL }},\r\n{ &hf_ldp_tlv_intparam_tdmopt_ssrc,\r\n{ "SSRC", "ldp.msg.tlv.intparam.tdmopt_ssrc", FT_UINT32, BASE_HEX,\r\nNULL, 0x00, "VC FEC Interface Param TDM Options SSRC", HFILL }},\r\n{ &hf_ldp_tlv_intparam_vccv_cctype_cw,\r\n{ "PWE3 Control Word", "ldp.msg.tlv.intparam.vccv.cctype_cw", FT_BOOLEAN, 8,\r\nNULL, 0x01, "VC FEC Interface Param VCCV CC Type PWE3 CW", HFILL }},\r\n{ &hf_ldp_tlv_intparam_vccv_cctype_mplsra,\r\n{ "MPLS Router Alert", "ldp.msg.tlv.intparam.vccv.cctype_mplsra", FT_BOOLEAN, 8,\r\nNULL, 0x02, "VC FEC Interface Param VCCV CC Type MPLS Router Alert", HFILL }},\r\n{ &hf_ldp_tlv_intparam_vccv_cctype_ttl1,\r\n{ "MPLS Inner Label TTL = 1", "ldp.msg.tlv.intparam.vccv.cctype_ttl1", FT_BOOLEAN, 8,\r\nNULL, 0x04, "VC FEC Interface Param VCCV CC Type Inner Label TTL 1", HFILL }},\r\n{ &hf_ldp_tlv_intparam_vccv_cvtype_icmpping,\r\n{ "ICMP Ping", "ldp.msg.tlv.intparam.vccv.cvtype_icmpping", FT_BOOLEAN, 8,\r\nNULL, 0x01, "VC FEC Interface Param VCCV CV Type ICMP Ping", HFILL }},\r\n{ &hf_ldp_tlv_intparam_vccv_cvtype_lspping,\r\n{ "LSP Ping", "ldp.msg.tlv.intparam.vccv.cvtype_lspping", FT_BOOLEAN, 8,\r\nNULL, 0x02, "VC FEC Interface Param VCCV CV Type LSP Ping", HFILL }},\r\n{ &hf_ldp_tlv_intparam_vccv_cvtype_bfd,\r\n{ "BFD", "ldp.msg.tlv.intparam.vccv.cvtype_bfd", FT_BOOLEAN, 8,\r\nNULL, 0x04, "VC FEC Interface Param VCCV CV Type BFD", HFILL }},\r\n{ &hf_ldp_tlv_upstr_sbit,\r\n{ "S-Bit", "ldp.msg.tlv.upstream.sbit", FT_BOOLEAN, 8,\r\nTFS(&tlv_upstr_sbit_vals), 0x80, "Upstream Label Assignment Capability State Bit", HFILL }},\r\n{ &hf_ldp_tlv_upstr_lbl_req_resvbit,\r\n{ "Reserved Bits", "ldp.msg.tlv.upstream_label_req.resvbit", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_upstr_ass_lbl,\r\n{ "Upstream-Assigned Label", "ldp.msg.tlv.upstream.label", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_upstr_lbl_resvbit,\r\n{ "Reserved Bits", "ldp.msg.tlv.upstream.resvbit", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_ipv4_intID_hop_addr,\r\n{ "IPv4 Next/Previous Hop Address", "ldp.msg.tlv.ipv4_interface_ID.hop_addr", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_logical_intID,\r\n{ "Logical Interface ID", "ldp.msg.tlv.interface_ID.logical_intID", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_ip_multicast_srcaddr,\r\n{ "Source Address", "ldp.msg.tlv.ip_multicast.ipv4_srcaddr", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_ip_multicast_mltcstaddr,\r\n{ "Multicast Group Address", "ldp.msg.tlv.ip_multicast.ipv4_maddr", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_ip_mpls_context_srcaddr,\r\n{ "Source Address", "ldp.msg.tlv.ip_mpls_context.ipv4_srcaddr", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_ldp_p2mp_lsptype,\r\n{ "P2MP Type", "ldp.msg.tlv.ldp_p2mp.type", FT_UINT8, BASE_HEX,\r\nNULL, 0x0, "TLV Type", HFILL }},\r\n{ &hf_ldp_tlv_ldp_p2mp_addrfam,\r\n{ "Address Family", "ldp.msg.tlv.ldp_p2mp.addr_family", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_ldp_p2mp_addrlen,\r\n{ "Address Length", "ldp.msg.tlv.ldp_p2mp.addr_len", FT_UINT8, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_ldp_p2mp_rtnodeaddr,\r\n{ "Root Node Address", "ldp.msg.tlv.ldp_p2mp.ipv4_rtnodeaddr", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_ldp_p2mp_oplength,\r\n{ "Opaque Length", "ldp.msg.tlv.ldp_p2mp.oplength", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_ldp_p2mp_opvalue,\r\n{ "Opaque Value", "ldp.msg.tlv.ldp_p2mp.opvalue", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_rsvp_te_p2mp_id,\r\n{ "P2MP ID", "ldp.msg.tlv.rsvp_te_p2mp.id", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_must_be_zero,\r\n{ "MUST be zero", "ldp.msg.tlv.rsvp_te_p2mp.zero", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_tunnel_id,\r\n{ "Tunnel ID", "ldp.msg.tlv.rsvp_te_p2mp.tunnel_id", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_ext_tunnel_id,\r\n{ "Extended Tunnel ID", "ldp.msg.tlv.rsvp_te_p2mp.ipv4_ext_tunnel_id", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_tlv_inv_length,\r\n{ "Invalid length", "ldp.msg.tlv.invalid.length", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_returned_pdu_data,\r\n{ "Returned PDU Data", "ldp.returned_pdu_data", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_returned_message_parameters,\r\n{ "Returned Message Parameters", "ldp.returned_message_parameters", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_data,\r\n{ "Data", "ldp.data", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ldp_unknown_data,\r\n{ "Unknown Data", "ldp.unknown_data", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ldp,\r\n&ett_ldp_header,\r\n&ett_ldp_ldpid,\r\n&ett_ldp_message,\r\n&ett_ldp_tlv,\r\n&ett_ldp_tlv_val,\r\n&ett_ldp_tlv_ft_flags,\r\n&ett_ldp_fec,\r\n&ett_ldp_fec_vc_interfaceparam,\r\n&ett_ldp_fec_vc_interfaceparam_cepopt,\r\n&ett_ldp_fec_vc_interfaceparam_vccvtype,\r\n&ett_ldp_diffserv_map,\r\n&ett_ldp_diffserv_map_phbid,\r\n&ett_ldp_gen_agi,\r\n&ett_ldp_gen_saii,\r\n&ett_ldp_gen_taii,\r\n&ett_ldp_gen_aai_type2,\r\n&ett_ldp_sub_tlv\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_ldp_dtsm_and_target, { "ldp.dtsm_and_target", PI_PROTOCOL, PI_WARN, "ERROR - Both GTSM and Target Flag are enabled.", EXPFILL }},\r\n{ &ei_ldp_gtsm_supported, { "ldp.gtsm_supported", PI_PROTOCOL, PI_CHAT, "GTSM is supported by the source", EXPFILL }},\r\n{ &ei_ldp_gtsm_not_supported_basic_discovery, { "ldp.gtsm_not_supported_basic_discovery", PI_PROTOCOL, PI_WARN, "GTSM is not supported by the source, since basic discovery is not enabled", EXPFILL }},\r\n{ &ei_ldp_gtsm_not_supported, { "ldp.gtsm_not_supported", PI_PROTOCOL, PI_CHAT, "GTSM is not supported by the source", EXPFILL }},\r\n{ &ei_ldp_inv_length, { "ldp.invalid_length", PI_MALFORMED, PI_ERROR, "Length of the packet is malformed", EXPFILL }},\r\n{ &ei_ldp_address_family_not_implemented, { "ldp.address_family_not_implemented", PI_UNDECODED, PI_WARN, "Support for Address Family not implemented", EXPFILL }},\r\n{ &ei_ldp_tlv_fec, { "ldp.msg.tlv.fec.error", PI_PROTOCOL, PI_ERROR, "Error in FEC Element %u", EXPFILL }},\r\n{ &ei_ldp_tlv_fec_len, { "ldp.msg.tlv.fec.len.invalid", PI_PROTOCOL, PI_ERROR, "Invalid prefix %u length for family %s", EXPFILL }},\r\n{ &ei_ldp_tlv_fec_vc_infolength, { "ldp.msg.tlv.fec.vc.infolength.invalid", PI_PROTOCOL, PI_ERROR, "VC FEC size format error", EXPFILL }},\r\n{ &ei_ldp_malformed_interface_parameter, { "ldp.malformed_interface_parameter", PI_MALFORMED, PI_ERROR, "Malformed interface parameter", EXPFILL }},\r\n{ &ei_ldp_malformed_data, { "ldp.malformed_data", PI_MALFORMED, PI_ERROR, "Malformed data", EXPFILL }},\r\n{ &ei_ldp_tlv_fec_type, { "ldp.msg.tlv.fec.unknown", PI_PROTOCOL, PI_WARN, "Unknown FEC TLV type", EXPFILL }},\r\n};\r\nmodule_t *ldp_module;\r\nexpert_module_t* expert_ldp;\r\nproto_ldp = proto_register_protocol("Label Distribution Protocol",\r\n"LDP", "ldp");\r\nproto_register_field_array(proto_ldp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_ldp = expert_register_protocol(proto_ldp);\r\nexpert_register_field_array(expert_ldp, ei, array_length(ei));\r\nldp_module = prefs_register_protocol(proto_ldp, proto_reg_handoff_ldp);\r\nprefs_register_uint_preference(ldp_module, "tcp.port", "LDP TCP Port",\r\n"Set the TCP port for messages (if other"\r\n" than the default of 646)",\r\n10, &global_ldp_tcp_port);\r\nprefs_register_uint_preference(ldp_module, "udp.port", "LDP UDP Port",\r\n"Set the UDP port for messages (if other"\r\n" than the default of 646)",\r\n10, &global_ldp_udp_port);\r\nprefs_register_bool_preference(ldp_module, "desegment_ldp_messages",\r\n"Reassemble LDP messages spanning multiple TCP segments",\r\n"Whether the LDP dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\""\r\n" in the TCP protocol settings.",\r\n&ldp_desegment);\r\n}\r\nvoid\r\nproto_reg_handoff_ldp(void)\r\n{\r\nstatic gboolean ldp_prefs_initialized = FALSE;\r\nstatic dissector_handle_t ldp_tcp_handle, ldp_handle;\r\nstatic int tcp_port;\r\nstatic int udp_port;\r\nif (!ldp_prefs_initialized) {\r\nldp_tcp_handle = create_dissector_handle(dissect_ldp_tcp, proto_ldp);\r\nldp_handle = create_dissector_handle(dissect_ldp, proto_ldp);\r\nldp_prefs_initialized = TRUE;\r\n}\r\nelse {\r\ndissector_delete_uint("tcp.port", tcp_port, ldp_tcp_handle);\r\ndissector_delete_uint("udp.port", udp_port, ldp_handle);\r\n}\r\ntcp_port = global_ldp_tcp_port;\r\nudp_port = global_ldp_udp_port;\r\ndissector_add_uint("tcp.port", global_ldp_tcp_port, ldp_tcp_handle);\r\ndissector_add_uint("udp.port", global_ldp_udp_port, ldp_handle);\r\n}
