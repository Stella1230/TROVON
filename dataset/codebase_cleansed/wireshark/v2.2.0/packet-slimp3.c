static int\r\ndissect_slimp3(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nconst char *opcode_str;\r\nproto_tree *slimp3_tree;\r\nproto_item *ti;\r\ngint i1;\r\ngint offset = 0;\r\nguint16 opcode;\r\nguchar lcd_char;\r\nchar lcd_str[MAX_LCD_STR_LEN + 1];\r\nint to_server = FALSE;\r\nint old_protocol = FALSE;\r\naddress tmp_addr;\r\ngboolean in_str;\r\nint lcd_strlen;\r\nif (!tvb_bytes_exist(tvb, offset, 1))\r\nreturn 0;\r\nopcode = tvb_get_guint8(tvb, offset);\r\nopcode_str = try_val_to_str(opcode, slimp3_opcode_vals);\r\nif (opcode_str == NULL)\r\nreturn 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "SliMP3");\r\ncol_add_str(pinfo->cinfo, COL_INFO, opcode_str);\r\nti = proto_tree_add_item(tree, proto_slimp3, tvb, offset, -1, ENC_NA);\r\nslimp3_tree = proto_item_add_subtree(ti, ett_slimp3);\r\nproto_tree_add_uint(slimp3_tree, hf_slimp3_opcode, tvb,\r\noffset, 1, opcode);\r\nif ((pinfo->destport == UDP_PORT_SLIMP3_V2) && (pinfo->srcport == UDP_PORT_SLIMP3_V2)) {\r\nset_address_tvb(&tmp_addr, AT_ETHER, 6, tvb, offset+12);\r\nto_server = addresses_equal(&tmp_addr, &pinfo->dl_src);\r\n}\r\nelse if (pinfo->destport == UDP_PORT_SLIMP3_V2) {\r\nto_server = TRUE;\r\n}\r\nelse if (pinfo->srcport == UDP_PORT_SLIMP3_V2) {\r\nto_server = FALSE;\r\n}\r\nif (pinfo->destport == UDP_PORT_SLIMP3_V1) {\r\nto_server = TRUE;\r\nold_protocol = TRUE;\r\n}\r\nelse if (pinfo->srcport == UDP_PORT_SLIMP3_V1) {\r\nto_server = FALSE;\r\nold_protocol = TRUE;\r\n}\r\nswitch (opcode) {\r\ncase SLIMP3_IR:\r\nif (tree) {\r\ni1 = tvb_get_ntohl(tvb, offset+2);\r\nproto_tree_add_uint_format_value(slimp3_tree, hf_slimp3_uptime, tvb, offset+2, 4, i1,\r\n"%u sec (%u ticks)", i1/625000, i1);\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_code_id, tvb, offset+6, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_code_bits, tvb, offset+7, 1, ENC_BIG_ENDIAN);\r\ni1 = tvb_get_ntohl(tvb, offset+8);\r\nif (tvb_get_guint8(tvb, offset+6) == 0x02 &&\r\ntvb_get_guint8(tvb, offset+7) == 32) {\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_infrared_slimp3, tvb, offset+8, 4, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", SLIMP3: %s",\r\nval_to_str_ext(i1, &slimp3_ir_codes_slimp3_ext, "Unknown (0x%0x)"));\r\n}\r\nelse if (tvb_get_guint8(tvb, offset+6) == 0xff &&\r\ntvb_get_guint8(tvb, offset+7) == 16) {\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_infrared_jvc, tvb, offset+8, 4, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", JVC: %s",\r\nval_to_str(i1, slimp3_ir_codes_jvc, "Unknown (0x%0x)"));\r\n} else {\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_infrared, tvb, offset+8, 4, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", 0x%0x", i1);\r\n}\r\n}\r\nbreak;\r\ncase SLIMP3_DISPLAY:\r\nif (tree) {\r\nguint8 value;\r\ni1 = 18;\r\nin_str = FALSE;\r\nlcd_strlen = 0;\r\nwhile (i1 < tvb_reported_length_remaining(tvb, offset)) {\r\nswitch(tvb_get_guint8(tvb, offset + i1)) {\r\ncase 0:\r\nin_str = FALSE;\r\nlcd_strlen = 0;\r\nvalue = tvb_get_guint8(tvb, offset + i1 + 1);\r\nproto_tree_add_uint_format_value(slimp3_tree, hf_slimp3_display_delay, tvb, offset + i1, 2,\r\nvalue, "%u ms", value);\r\ni1 += 2;\r\nbreak;\r\ncase 3:\r\nlcd_char = tvb_get_guint8(tvb, offset + i1 + 1);\r\nif (!g_ascii_isprint(lcd_char))\r\nlcd_char = '.';\r\nif (ti && in_str) {\r\nlcd_strlen += 2;\r\nproto_item_append_text(ti, "%c", lcd_char);\r\nproto_item_set_len(ti, lcd_strlen);\r\n} else {\r\nti = proto_tree_add_uint_format_value(slimp3_tree, hf_slimp3_display_string, tvb, offset + i1, 2,\r\nlcd_char, "%c", lcd_char);\r\nin_str = TRUE;\r\nlcd_strlen = 2;\r\n}\r\ni1 += 2;\r\nbreak;\r\ncase 2:\r\nin_str = FALSE;\r\nlcd_strlen = 0;\r\nvalue = tvb_get_guint8(tvb, offset + i1 + 1);\r\nti = proto_tree_add_uint(slimp3_tree, hf_slimp3_display_command, tvb, offset + i1, 2, value);\r\nif ((tvb_get_guint8(tvb, offset + i1 + 1) & 0xf0) == 0x30) {\r\nproto_item_append_text(ti, ": %s",\r\nval_to_str(tvb_get_guint8(tvb, offset + i1 + 2),\r\nslimp3_display_fset8,\r\n"Unknown (0x%0x)"));\r\ni1 += 2;\r\n}\r\ni1 += 2;\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_display_unknown, tvb, offset + i1, 2, ENC_NA);\r\ni1 += 2;\r\nbreak;\r\n}\r\n}\r\n}\r\ni1 = 18;\r\nlcd_strlen = 0;\r\nwhile (tvb_offset_exists(tvb, offset + i1) &&\r\nlcd_strlen < MAX_LCD_STR_LEN) {\r\nswitch (tvb_get_guint8(tvb, offset + i1)) {\r\ncase 0:\r\nlcd_str[lcd_strlen++] = '.';\r\nbreak;\r\ncase 2:\r\nlcd_str[lcd_strlen++] = '|';\r\nif (tvb_offset_exists(tvb, offset + i1 + 1) &&\r\n(tvb_get_guint8(tvb, offset + i1 + 1) & 0xf0) == 0x30)\r\ni1 += 2;\r\nbreak;\r\ncase 3:\r\nif (tvb_offset_exists(tvb, offset + i1 + 1)) {\r\nif ((lcd_strlen < 1) ||\r\n(lcd_str[lcd_strlen-1] != ' ') ||\r\n(tvb_get_guint8(tvb, offset + i1 + 1) != ' ')) {\r\nlcd_char = tvb_get_guint8(tvb, offset + i1 + 1);\r\nlcd_str[lcd_strlen++] = g_ascii_isprint(lcd_char) ? lcd_char : '.';\r\n}\r\n}\r\n}\r\ni1 += 2;\r\n}\r\nlcd_str[lcd_strlen] = '\0';\r\nif (lcd_strlen > 0)\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %s", lcd_str);\r\nbreak;\r\ncase SLIMP3_CONTROL:\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_control, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %s",\r\nval_to_str(tvb_get_guint8(tvb, offset+1),\r\nslimp3_stream_control, "Unknown (0x%0x)"));\r\nbreak;\r\ncase SLIMP3_HELLO:\r\nif (tree) {\r\nif (to_server) {\r\nguint8 fw_ver;\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_hello_response_client_server, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_device_id, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nfw_ver = tvb_get_guint8(tvb, offset+2);\r\nproto_tree_add_uint_format_value(slimp3_tree, hf_slimp3_fw_rev, tvb, offset+2, 1, fw_ver,\r\n"%u.%u (0x%0x)", fw_ver>>4, fw_ver & 0xf, fw_ver);\r\n} else {\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_hello_request_server_client, tvb, offset, 1, ENC_NA);\r\n}\r\n}\r\nbreak;\r\ncase SLIMP3_I2C:\r\nif (to_server) {\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_i2c_response_client_server, tvb, offset, -1, ENC_NA);\r\ncol_append_str(pinfo->cinfo, COL_INFO, ", Response");\r\n} else {\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_i2c_request_server_client, tvb, offset, -1, ENC_NA);\r\ncol_append_str(pinfo->cinfo, COL_INFO, ", Request");\r\n}\r\nbreak;\r\ncase SLIMP3_DATA_REQ:\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_data_req_offset, tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Offset: %u bytes",\r\ntvb_get_ntohs(tvb, offset+2)*2);\r\nbreak;\r\ncase SLIMP3_DATA:\r\nif (old_protocol) {\r\nguint offset_buffer;\r\nproto_tree_add_bytes_format(slimp3_tree, hf_slimp3_data_length, tvb, offset, -1,\r\nNULL, "Length: %d bytes",\r\ntvb_reported_length_remaining(tvb, offset+18));\r\noffset_buffer = tvb_get_ntohs(tvb, offset+2) * 2;\r\nproto_tree_add_uint(slimp3_tree, hf_slimp3_data_offset, tvb, offset+2, 2, offset_buffer);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO,\r\n", Length: %d bytes, Offset: %u bytes.",\r\ntvb_reported_length_remaining(tvb, offset+18),\r\noffset_buffer);\r\n}\r\nelse {\r\nguint write_pointer;\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_data_command, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_bytes_format(slimp3_tree, hf_slimp3_data_length, tvb, offset, -1,\r\nNULL, "Length: %d bytes",\r\ntvb_reported_length_remaining(tvb, offset+18));\r\nwrite_pointer = tvb_get_ntohs(tvb, offset+6) * 2;\r\nproto_tree_add_uint(slimp3_tree, hf_slimp3_data_write_pointer, tvb, offset+6, 2, write_pointer);\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_data_sequence, tvb, offset+10, 2, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO,\r\n", %s, %d bytes at %u, Sequence: %u",\r\nval_to_str(tvb_get_guint8(tvb, offset+1),\r\nslimp3_mpg_control, "Unknown (0x%0x)"),\r\ntvb_reported_length_remaining(tvb, offset+18),\r\nwrite_pointer,\r\ntvb_get_ntohs(tvb, offset+10));\r\n}\r\nbreak;\r\ncase SLIMP3_DISC_REQ:\r\n{\r\nguint8 fw_ver;\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_device_id, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nfw_ver = tvb_get_guint8(tvb, offset+2);\r\nproto_tree_add_uint_format_value(slimp3_tree, hf_slimp3_fw_rev, tvb, offset+2, 1, fw_ver,\r\n"%u.%u (0x%0x)", fw_ver>>4, fw_ver & 0xf, fw_ver);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Device ID: %u. Firmware: %u.%u",\r\ntvb_get_guint8(tvb, offset+1), fw_ver>>4, fw_ver & 0xf);\r\n}\r\nbreak;\r\ncase SLIMP3_DISC_RSP:\r\nif (tree) {\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_disc_rsp_server_ip, tvb, offset+2, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_disc_rsp_server_port, tvb, offset+6, 2, ENC_BIG_ENDIAN);\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Server Address: %s. Server Port: %u",\r\ntvb_ip_to_str(tvb, offset+2),\r\ntvb_get_ntohs(tvb, offset + 6));\r\nbreak;\r\ncase SLIMP3_DATA_ACK:\r\nif (tree) {\r\nguint pointer;\r\npointer = tvb_get_ntohs(tvb, offset+6) * 2;\r\nproto_tree_add_uint(slimp3_tree, hf_slimp3_data_ack_write_pointer, tvb, offset+6, 2, pointer);\r\npointer = tvb_get_ntohs(tvb, offset+8) * 2;\r\nproto_tree_add_uint(slimp3_tree, hf_slimp3_data_ack_read_pointer, tvb, offset+8, 2, pointer);\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_data_ack_sequence, tvb, offset+10, 2, ENC_BIG_ENDIAN);\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Sequence: %u",\r\ntvb_get_ntohs(tvb, offset+10));\r\nbreak;\r\ndefault:\r\nif (tree) {\r\nproto_tree_add_item(slimp3_tree, hf_slimp3_data_data, tvb, offset, -1, ENC_NA);\r\n}\r\nbreak;\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nvoid\r\nproto_register_slimp3(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_slimp3_opcode,\r\n{ "Opcode", "slimp3.opcode",\r\nFT_UINT8, BASE_DEC, VALS(slimp3_opcode_vals), 0x0,\r\n"SLIMP3 message type", HFILL }},\r\n{ &hf_slimp3_control,\r\n{ "Control Packet", "slimp3.control",\r\nFT_UINT8, BASE_DEC, VALS(slimp3_stream_control), 0x0,\r\n"SLIMP3 control", HFILL }},\r\n{ &hf_slimp3_uptime,\r\n{ "Uptime", "slimp3.uptime",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_code_id,\r\n{ "Code identifier", "slimp3.code_id",\r\nFT_UINT8, BASE_DEC, VALS(slimp3_ir_types), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_code_bits,\r\n{ "Code bits", "slimp3.code_bits",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_infrared_slimp3,\r\n{ "Infrared Code", "slimp3.infrared",\r\nFT_UINT32, BASE_HEX | BASE_EXT_STRING, &slimp3_ir_codes_slimp3_ext, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_infrared_jvc,\r\n{ "Infrared Code", "slimp3.infrared",\r\nFT_UINT32, BASE_HEX, VALS(slimp3_ir_codes_jvc), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_infrared,\r\n{ "Infrared Code", "slimp3.infrared",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_device_id,\r\n{ "Device ID", "slimp3.device_id",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_fw_rev,\r\n{ "Firmware Revision", "slimp3.fw_rev",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_data_offset,\r\n{ "Buffer offset", "slimp3.data.offset",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_data_command,\r\n{ "Command", "slimp3.data.command",\r\nFT_UINT8, BASE_HEX, VALS(slimp3_mpg_control), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_data_write_pointer,\r\n{ "Write Pointer", "slimp3.data.write_pointer",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_data_sequence,\r\n{ "Sequence", "slimp3.data.sequence",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_disc_rsp_server_ip,\r\n{ "Server Address", "slimp3.disc_rsp.server_ip",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_disc_rsp_server_port,\r\n{ "Server Port", "slimp3.disc_rsp.server_port",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_data_ack_write_pointer,\r\n{ "Write Pointer", "slimp3.data_ack.write_pointer",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_data_ack_read_pointer,\r\n{ "Read Pointer", "slimp3.data_ack.read_pointer",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_data_ack_sequence,\r\n{ "Sequence", "slimp3.data_ack.sequence",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_data_req_offset,\r\n{ "Requested offset", "slimp3.data_req.offset",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_slimp3_display_delay, { "Delay", "slimp3.display_delay", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_slimp3_display_string, { "String", "slimp3.display_string", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_slimp3_display_command, { "Command", "slimp3.display_command", FT_UINT8, BASE_DEC, VALS(slimp3_display_commands), 0x0, NULL, HFILL }},\r\n{ &hf_slimp3_display_unknown, { "Unknown", "slimp3.display_unknown", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_slimp3_hello_response_client_server, { "Hello Response (Client --> Server)", "slimp3.hello_response_client_server", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_slimp3_hello_request_server_client, { "Hello Request (Server --> Client)", "slimp3.hello_request_server_client", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_slimp3_i2c_response_client_server, { "I2C Response (Client --> Server)", "slimp3.i2c_response_client_server", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_slimp3_i2c_request_server_client, { "I2C Request (Server --> Client)", "slimp3.i2c_request_server_client", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_slimp3_data_length, { "Length", "slimp3.data.length", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_slimp3_data_data, { "Data", "slimp3.data.data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_slimp3,\r\n};\r\nproto_slimp3 = proto_register_protocol("SliMP3 Communication Protocol",\r\n"SliMP3", "slimp3");\r\nproto_register_field_array(proto_slimp3, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_slimp3(void)\r\n{\r\ndissector_handle_t slimp3_handle;\r\nslimp3_handle = create_dissector_handle(dissect_slimp3, proto_slimp3);\r\ndissector_add_uint("udp.port", UDP_PORT_SLIMP3_V1, slimp3_handle);\r\ndissector_add_uint("udp.port", UDP_PORT_SLIMP3_V2, slimp3_handle);\r\n}
