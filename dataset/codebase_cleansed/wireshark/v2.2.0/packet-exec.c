static int\r\ndissect_exec(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *exec_tree=NULL;\r\nguchar *field_stringz;\r\ngint length;\r\nguint offset = 0;\r\nconversation_t *conversation;\r\nexec_hash_entry_t *hash_info;\r\nconversation = find_or_create_conversation(pinfo);\r\nhash_info = (exec_hash_entry_t *)conversation_get_proto_data(conversation, proto_exec);\r\nif(!hash_info){\r\nhash_info = wmem_new(wmem_file_scope(), exec_hash_entry_t);\r\nhash_info->first_packet_number = pinfo->num;\r\nhash_info->second_packet_number = 0;\r\nhash_info->third_packet_number = 0;\r\nhash_info->fourth_packet_number = 0;\r\nhash_info->state = WAIT_FOR_STDERR_PORT;\r\nhash_info->username=NULL;\r\nhash_info->command=NULL;\r\nhash_info->first_packet_state = NONE;\r\nhash_info->second_packet_state = NONE;\r\nhash_info->third_packet_state = NONE;\r\nhash_info->fourth_packet_state = NONE;\r\nconversation_add_proto_data(conversation, proto_exec, hash_info);\r\n}\r\nif(!hash_info->second_packet_number\r\n&& pinfo->num > hash_info->first_packet_number){\r\nhash_info->second_packet_number = pinfo->num;\r\n} else if(hash_info->second_packet_number\r\n&& !hash_info->third_packet_number\r\n&& pinfo->num > hash_info->second_packet_number) {\r\nhash_info->third_packet_number = pinfo->num;\r\n} else if(hash_info->third_packet_number\r\n&& !hash_info->fourth_packet_number\r\n&& pinfo->num > hash_info->third_packet_number) {\r\nhash_info->fourth_packet_number = pinfo->num;\r\n}\r\nif(pinfo->num == hash_info->first_packet_number){\r\nif(hash_info->first_packet_state == NONE){\r\nhash_info->first_packet_state = hash_info->state;\r\n} else {\r\nhash_info->state = hash_info->first_packet_state;\r\n}\r\n}\r\nif(pinfo->num == hash_info->second_packet_number){\r\nif(hash_info->second_packet_state == NONE){\r\nhash_info->second_packet_state = hash_info->state;\r\n} else {\r\nhash_info->state = hash_info->second_packet_state;\r\n}\r\n}\r\nif(pinfo->num == hash_info->third_packet_number){\r\nif(hash_info->third_packet_state == NONE){\r\nhash_info->third_packet_state = hash_info->state;\r\n} else {\r\nhash_info->state = hash_info->third_packet_state;\r\n}\r\n}\r\nif(pinfo->num == hash_info->fourth_packet_number){\r\nif(hash_info->fourth_packet_state == NONE){\r\nhash_info->fourth_packet_state = hash_info->state;\r\n} else {\r\nhash_info->state = hash_info->fourth_packet_state;\r\n}\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "EXEC");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif(hash_info->username && preference_info_show_username == TRUE){\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Username:%s ", hash_info->username);\r\n}\r\nif(hash_info->command && preference_info_show_command == TRUE){\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Command:%s ", hash_info->command);\r\n}\r\nti = proto_tree_add_item(tree, proto_exec, tvb, 0, -1, ENC_NA);\r\nexec_tree = proto_item_add_subtree(ti, ett_exec);\r\nif(tvb_find_guint8(tvb, tvb_captured_length(tvb)-1, 1, '\0') == -1){\r\nhash_info->state = WAIT_FOR_DATA;\r\n}\r\nif(hash_info->state == WAIT_FOR_STDERR_PORT\r\n&& tvb_reported_length_remaining(tvb, offset)){\r\nfield_stringz = tvb_get_stringz_enc(wmem_packet_scope(), tvb, offset, &length, ENC_ASCII);\r\nif(length == 1 || (isdigit_string(field_stringz)\r\n&& length <= EXEC_STDERR_PORT_LEN)){\r\nproto_tree_add_string(exec_tree, hf_exec_stderr_port, tvb, offset, length, (gchar*)field_stringz);\r\nhash_info->state = WAIT_FOR_USERNAME;\r\n} else {\r\nhash_info->state = WAIT_FOR_DATA;\r\n}\r\noffset += length;\r\n}\r\nif(hash_info->state == WAIT_FOR_USERNAME\r\n&& tvb_reported_length_remaining(tvb, offset)){\r\nfield_stringz = tvb_get_stringz_enc(wmem_packet_scope(), tvb, offset, &length, ENC_ASCII);\r\nif(length != 1 && length <= EXEC_USERNAME_LEN\r\n&& isprint_string(field_stringz)){\r\nproto_tree_add_string(exec_tree, hf_exec_username, tvb, offset, length, (gchar*)field_stringz);\r\nif(!hash_info->username){\r\nhash_info->username=wmem_strdup(wmem_file_scope(), (gchar*)field_stringz);\r\n}\r\nhash_info->state = WAIT_FOR_PASSWORD;\r\n} else {\r\nhash_info->state = WAIT_FOR_DATA;\r\n}\r\noffset += length;\r\n}\r\nif(hash_info->state == WAIT_FOR_PASSWORD\r\n&& tvb_reported_length_remaining(tvb, offset)){\r\nfield_stringz = tvb_get_stringz_enc(wmem_packet_scope(), tvb, offset, &length, ENC_ASCII);\r\nif(length != 1 && length <= EXEC_PASSWORD_LEN\r\n&& isprint_string(field_stringz)){\r\nproto_tree_add_string(exec_tree, hf_exec_password, tvb, offset, length, (gchar*)field_stringz);\r\nhash_info->state = WAIT_FOR_COMMAND;\r\n} else {\r\nhash_info->state = WAIT_FOR_DATA;\r\n}\r\noffset += length;\r\nhash_info->state = WAIT_FOR_COMMAND;\r\n}\r\nif(hash_info->state == WAIT_FOR_COMMAND\r\n&& tvb_reported_length_remaining(tvb, offset)){\r\nfield_stringz = tvb_get_stringz_enc(wmem_packet_scope(), tvb, offset, &length, ENC_ASCII);\r\nif(length != 1 && length <= EXEC_COMMAND_LEN\r\n&& isprint_string(field_stringz)){\r\nproto_tree_add_string(exec_tree, hf_exec_command, tvb, offset, length, (gchar*)field_stringz);\r\nif(!hash_info->command){\r\nhash_info->command=wmem_strdup(wmem_file_scope(), (gchar*)field_stringz);\r\n}\r\n} else {\r\nhash_info->state = WAIT_FOR_DATA;\r\n}\r\n}\r\nif(hash_info->state == WAIT_FOR_DATA\r\n&& tvb_reported_length_remaining(tvb, offset)){\r\nif(pinfo->destport == EXEC_PORT){\r\nproto_tree_add_item(exec_tree, hf_exec_client_server_data, tvb, 0, -1, ENC_NA);\r\ncol_append_str(pinfo->cinfo, COL_INFO, "Client -> Server data");\r\n} else {\r\nproto_tree_add_item(exec_tree, hf_exec_server_client_data, tvb, 0, -1, ENC_NA);\r\ncol_append_str(pinfo->cinfo, COL_INFO, "Server -> Client Data");\r\n}\r\n}\r\nif(hash_info->state < WAIT_FOR_DATA){\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Session Establishment");\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_exec(void)\r\n{\r\nstatic hf_register_info hf[] =\r\n{\r\n{ &hf_exec_stderr_port, { "Stderr port (optional)", "exec.stderr_port",\r\nFT_STRINGZ, BASE_NONE, NULL, 0,\r\n"Client port that is listening for stderr stream from server", HFILL } },\r\n{ &hf_exec_username, { "Client username", "exec.username",\r\nFT_STRINGZ, BASE_NONE, NULL, 0,\r\n"Username client uses to log in to the server.", HFILL } },\r\n{ &hf_exec_password, { "Client password", "exec.password",\r\nFT_STRINGZ, BASE_NONE, NULL, 0,\r\n"Password client uses to log in to the server.", HFILL } },\r\n{ &hf_exec_command, { "Command to execute", "exec.command",\r\nFT_STRINGZ, BASE_NONE, NULL, 0,\r\n"Command client is requesting the server to run.", HFILL } },\r\n{ &hf_exec_client_server_data, { "Client -> Server Data", "exec.client_server_data",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL } },\r\n{ &hf_exec_server_client_data, { "Server -> Client Data", "exec.server_client_data",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL } },\r\n};\r\nstatic gint *ett[] =\r\n{\r\n&ett_exec\r\n};\r\nmodule_t *exec_module;\r\nproto_exec = proto_register_protocol("Remote Process Execution", "EXEC", "exec");\r\nproto_register_field_array(proto_exec, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexec_module = prefs_register_protocol(proto_exec, NULL);\r\nprefs_register_bool_preference(exec_module, "info_show_username",\r\n"Show username in info column",\r\n"Controls the display of the session's username in the info column. This is only displayed if the packet containing it was seen during this capture session.", &preference_info_show_username);\r\nprefs_register_bool_preference(exec_module, "info_show_command",\r\n"Show command in info column",\r\n"Controls the display of the command being run on the server by this session in the info column. This is only displayed if the packet containing it was seen during this capture session.", &preference_info_show_command);\r\n}\r\nvoid\r\nproto_reg_handoff_exec(void)\r\n{\r\ndissector_handle_t exec_handle;\r\nexec_handle = create_dissector_handle(dissect_exec, proto_exec);\r\ndissector_add_uint("tcp.port", EXEC_PORT, exec_handle);\r\n}
