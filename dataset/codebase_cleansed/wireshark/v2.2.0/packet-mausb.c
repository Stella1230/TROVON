gboolean mausb_is_from_host(struct mausb_header *header)\r\n{\r\nreturn (MAUSB_FLAG_HOST << MAUSB_FLAG_OFFSET) & header->ver_flags;\r\n}\r\nstatic gboolean mausb_is_mgmt_pkt(struct mausb_header *header)\r\n{\r\nreturn MAUSB_PKT_TYPE_MGMT == (header->type & MAUSB_PKT_TYPE_MASK);\r\n}\r\nstatic gboolean mausb_is_data_pkt(struct mausb_header *header)\r\n{\r\nreturn MAUSB_PKT_TYPE_DATA == (header->type & MAUSB_PKT_TYPE_MASK);\r\n}\r\nstatic gboolean mausb_is_transfer_req(struct mausb_header *header)\r\n{\r\nreturn TransferReq == header->type;\r\n}\r\nstatic gboolean mausb_is_transfer_ack(struct mausb_header *header)\r\n{\r\nreturn TransferAck == header->type;\r\n}\r\nstatic gint8 mausb_tx_type(struct mausb_header *header)\r\n{\r\nreturn (header->u.s.eps_tflags >> MAUSB_TFLAG_OFFSET) & MAUSB_TFLAG_TRANSFER_TYPE;\r\n}\r\nstatic gboolean mausb_is_iso_pkt(struct mausb_header *header)\r\n{\r\nreturn MAUSB_TX_TYPE_ISOC == mausb_tx_type(header);\r\n}\r\nstatic gboolean mausb_has_timestamp(struct mausb_header *header)\r\n{\r\nreturn (MAUSB_FLAG_TIMESTAMP << MAUSB_FLAG_OFFSET) & header->ver_flags;\r\n}\r\nstatic gboolean mausb_has_mtd(struct mausb_header *header)\r\n{\r\nreturn (MAUSB_IFLAG_MTD << MAUSB_IFLAG_OFFSET) & header->u.s.u1.num_headers_iflags;\r\n}\r\nstatic gboolean mausb_has_setup_data(struct mausb_header *header)\r\n{\r\nif ((TransferReq == header->type ) &&\r\n(mausb_is_from_host(header)) &&\r\n(0 == header->u.s.seq_num) &&\r\n(MAUSB_TX_TYPE_CTRL == mausb_tx_type(header))) {\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean mausb_is_setup_response(struct mausb_header *header)\r\n{\r\nif ((TransferResp == header->type) &&\r\n(!mausb_is_from_host(header)) &&\r\n(MAUSB_TX_TYPE_CTRL == mausb_tx_type(header))) {\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nguint8 mausb_ep_handle_ep_num(guint16 handle) {\r\nreturn (handle & MAUSB_EP_HANDLE_EP_NUM) >> MAUSB_EP_HANDLE_EP_NUM_OFFSET;\r\n}\r\nguint8 mausb_ep_handle_dev_addr(guint16 handle) {\r\nreturn (handle & MAUSB_EP_HANDLE_DEV_ADDR) >> MAUSB_EP_HANDLE_DEV_ADDR_OFFSET;\r\n}\r\nguint8 mausb_ep_handle_bus_num(guint16 handle) {\r\nreturn (handle & MAUSB_EP_HANDLE_BUS_NUM) >> MAUSB_EP_HANDLE_BUS_NUM_OFFSET;\r\n}\r\nstatic guint mausb_get_pkt_len(packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset, void *data _U_)\r\n{\r\nreturn tvb_get_letohs(tvb, offset + 2);\r\n}\r\nstatic guint16 dissect_mausb_dev_cap_desc(proto_tree *tree, tvbuff_t *tvb,\r\npacket_info *pinfo, gint16 offset)\r\n{\r\nguint8 desc_len;\r\nguint8 cap_type;\r\ngint16 desc_offset;\r\nproto_item *len_field;\r\nproto_tree *dev_cap_tree;\r\ndesc_offset = offset;\r\ndesc_len = tvb_get_guint8(tvb, desc_offset);\r\ncap_type = tvb_get_guint8(tvb, desc_offset + 1);\r\ndev_cap_tree = proto_tree_add_subtree(tree, tvb, desc_offset, desc_len,\r\nett_dev_cap, NULL,\r\nval_to_str_const(cap_type, mausb_dev_cap_string, "Unknown Capability"));\r\nlen_field = proto_tree_add_item(dev_cap_tree, hf_mausb_dev_cap_len,\r\ntvb, desc_offset, 1, ENC_LITTLE_ENDIAN);\r\ndesc_offset += 1;\r\nproto_tree_add_item(dev_cap_tree, hf_mausb_dev_cap_type,\r\ntvb, desc_offset, 1, ENC_LITTLE_ENDIAN);\r\ndesc_offset += 1;\r\nif (desc_len > 2) {\r\nswitch (cap_type) {\r\ncase SpeedCap:\r\ncase PmanCap:\r\ncase IsoCap:\r\ncase SyncCap:\r\ncase ContainerIDCap:\r\ncase LinkSleepCap:\r\ndefault:\r\nproto_tree_add_item(dev_cap_tree, hf_mausb_dev_cap_generic,\r\ntvb, desc_offset, (desc_len - 2), ENC_NA);\r\ndesc_offset += (desc_len - 2);\r\nbreak;\r\n}\r\n}\r\nif (desc_offset != offset + desc_len) {\r\nexpert_add_info(pinfo, len_field, &ei_dev_cap_len);\r\n}\r\nreturn offset + desc_len;\r\n}\r\nstatic guint16 dissect_mausb_mgmt_pkt_cap_resp(struct mausb_header *header,\r\nproto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, gint16 offset)\r\n{\r\nguint desc_len;\r\nguint8 desc_count;\r\nproto_item *len_field;\r\nguint16 loop_offset;\r\nint i;\r\nproto_tree_add_item(tree, hf_mausb_cap_resp_num_ep,\r\ntvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_mausb_cap_resp_num_dev,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_mausb_cap_resp_num_stream,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_mausb_cap_resp_dev_type,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_mausb_cap_resp_desc_count,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\ndesc_count = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\nlen_field = proto_tree_add_item(tree, hf_mausb_cap_resp_desc_len,\r\ntvb, offset, 3, ENC_LITTLE_ENDIAN);\r\ndesc_len = tvb_get_letoh24(tvb, offset);\r\noffset += 3;\r\nproto_tree_add_item(tree, hf_mausb_cap_resp_transfer_req,\r\ntvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_mausb_cap_resp_mgmt_req,\r\ntvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_mausb_cap_resp_rsvd,\r\ntvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nif (offset + desc_len > header->length) {\r\nexpert_add_info(pinfo, len_field, &ei_cap_resp_desc_len);\r\ndesc_len = header->length - offset;\r\n}\r\nloop_offset = offset;\r\nfor (i = 0; i < desc_count; i++) {\r\nloop_offset = dissect_mausb_dev_cap_desc(tree, tvb, pinfo, loop_offset);\r\n}\r\nif (loop_offset != offset + desc_len) {\r\nexpert_add_info(pinfo, len_field, &ei_dev_cap_resp_desc_len);\r\ndesc_len = header->length - offset;\r\n}\r\nreturn offset + desc_len;\r\n}\r\nstatic gint dissect_ep_handle(proto_tree *tree, tvbuff_t *tvb, gint offset)\r\n{\r\nproto_item *ti;\r\nproto_tree *ep_handle_tree;\r\nti = proto_tree_add_item(tree, hf_mausb_ep_handle, tvb,\r\noffset, MAUSB_SIZE_EP_HANDLE, ENC_LITTLE_ENDIAN);\r\nep_handle_tree = proto_item_add_subtree(ti, ett_mausb_ep_handle);\r\nproto_tree_add_item(ep_handle_tree, hf_mausb_ep_handle_d, tvb,\r\noffset, MAUSB_SIZE_EP_HANDLE, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(ep_handle_tree, hf_mausb_ep_handle_ep_num, tvb,\r\noffset, MAUSB_SIZE_EP_HANDLE, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(ep_handle_tree, hf_mausb_ep_handle_dev_addr, tvb,\r\noffset, MAUSB_SIZE_EP_HANDLE, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(ep_handle_tree, hf_mausb_ep_handle_bus_num, tvb,\r\noffset, MAUSB_SIZE_EP_HANDLE, ENC_LITTLE_ENDIAN);\r\nreturn MAUSB_SIZE_EP_HANDLE;\r\n}\r\nstatic void dissect_mausb_present_time(proto_tree *tree, tvbuff_t *tvb,\r\ngint offset)\r\n{\r\nproto_item *ti;\r\nproto_tree *present_time_tree;\r\nti = proto_tree_add_item(tree, hf_mausb_present_time, tvb,\r\noffset, 4, ENC_LITTLE_ENDIAN);\r\npresent_time_tree = proto_item_add_subtree(ti, ett_mausb_present_time);\r\nproto_tree_add_item(present_time_tree, hf_mausb_uframe, tvb,\r\noffset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(present_time_tree, hf_mausb_frame, tvb,\r\noffset, 4, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void dissect_mausb_timestamp(proto_tree *tree, tvbuff_t *tvb,\r\ngint offset)\r\n{\r\nproto_item *ti;\r\nproto_tree *timestamp_tree;\r\nti = proto_tree_add_item(tree, hf_mausb_timestamp, tvb,\r\noffset, 4, ENC_LITTLE_ENDIAN);\r\ntimestamp_tree = proto_item_add_subtree(ti, ett_mausb_timestamp);\r\nproto_tree_add_item(timestamp_tree, hf_mausb_delta, tvb,\r\noffset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(timestamp_tree, hf_mausb_nom_interval, tvb,\r\noffset, 4, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic guint8 mausb_get_size_ep_des(tvbuff_t *tvb, gint offset)\r\n{\r\nguint8 size_ep_des = 0;\r\nguint16 temp_buffer = 0;\r\ntemp_buffer = tvb_get_letohs(tvb, offset);\r\ntemp_buffer = temp_buffer & MAUSB_MGMT_SIZE_EP_DES_MASK;\r\nsize_ep_des = (temp_buffer >> MAUSB_MGMT_SIZE_EP_DES_OFFSET);\r\nreturn size_ep_des;\r\n}\r\nstatic guint16 dissect_clear_transfers_block(proto_tree *tree,\r\ntvbuff_t *tvb, gint16 offset, gboolean req)\r\n{\r\nproto_item *ti;\r\nproto_tree *block_tree;\r\nif (req) {\r\nti = proto_tree_add_item(tree, hf_mausb_clear_transfers_info_block,\r\ntvb, offset, 8, ENC_NA);\r\n} else {\r\nti = proto_tree_add_item(tree, hf_mausb_clear_transfers_status_block,\r\ntvb, offset, 16, ENC_NA);\r\n}\r\nblock_tree = proto_item_add_subtree(ti, ett_clear_transfers_block);\r\noffset += dissect_ep_handle(block_tree, tvb, offset);\r\nproto_tree_add_item(block_tree, hf_mausb_stream_id, tvb, offset, 2,\r\nENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nif (req) {\r\nproto_tree_add_item(block_tree, hf_mausb_clear_transfers_start_req_id,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(block_tree, hf_mausb_clear_transfers_req_block_rsvd,\r\ntvb, offset, 3, ENC_NA);\r\noffset += 3;\r\n} else {\r\nproto_tree_add_item(block_tree, hf_mausb_clear_transfers_status,\r\ntvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(block_tree, hf_mausb_clear_transfers_partial,\r\ntvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(block_tree, hf_mausb_clear_transfers_resp_block_rsvd,\r\ntvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(block_tree, hf_mausb_clear_transfers_last_req_id,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(block_tree, hf_mausb_cancel_transfer_seq_num, tvb,\r\noffset, 3, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\nproto_tree_add_item(block_tree, hf_mausb_cancel_transfer_byte_offset,\r\ntvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint16 dissect_mausb_mgmt_pkt_clear_transfers(proto_tree *tree,\r\ntvbuff_t *tvb, gint16 offset, gboolean req)\r\n{\r\nguint8 num_block;\r\nint i;\r\nnum_block = tvb_get_guint8(tvb, offset);\r\nif (req) {\r\nproto_tree_add_item(tree, hf_mausb_clear_transfers_req_num, tvb,\r\noffset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_mausb_clear_transfers_req_rsvd, tvb,\r\noffset, 3, ENC_NA);\r\noffset += 3;\r\n} else {\r\nnum_block &= MAUSB_MGMT_CLEAR_TRANSFER_RESP_NUM_MASK;\r\nproto_tree_add_item(tree, hf_mausb_clear_transfers_resp_num, tvb,\r\noffset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_mausb_clear_transfers_resp_rsvd, tvb,\r\noffset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\n}\r\nfor (i = 0; i < num_block; i++) {\r\noffset = dissect_clear_transfers_block(tree, tvb, offset, req);\r\n}\r\nreturn offset;\r\n}\r\nstatic guint16 dissect_mausb_mgmt_pkt_ep_handle( proto_tree *tree, tvbuff_t *tvb,\r\npacket_info *pinfo, gint16 start, gboolean req, gboolean del)\r\n{\r\nusb_conv_info_t usb_conv_info;\r\nproto_item *size_field = NULL;\r\nguint16 offset = start;\r\nguint16 loop_offset;\r\nguint8 num_ep;\r\nguint8 size_ep_des;\r\nint i;\r\nmemset(&usb_conv_info, 0, sizeof(usb_conv_info_t));\r\nnum_ep = tvb_get_guint8(tvb, offset) & MAUSB_MGMT_NUM_EP_DES_MASK;\r\nif (!del) {\r\nproto_tree_add_item(tree, hf_mausb_mgmt_ep_des_num, tvb,\r\noffset, 1, ENC_LITTLE_ENDIAN);\r\n} else {\r\nproto_tree_add_item(tree, hf_mausb_mgmt_ep_handle_num, tvb,\r\noffset, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nif (req && !del) {\r\nsize_ep_des = mausb_get_size_ep_des(tvb, offset);\r\nsize_field = proto_tree_add_item(tree, hf_mausb_mgmt_ep_des_size, tvb,\r\noffset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_mausb_mgmt_ep_des_pad, tvb,\r\noffset, 3, ENC_NA);\r\noffset += 3;\r\n} else if (!req && !del) {\r\nsize_ep_des = MAUSB_SIZE_MAUSB_EP_DES;\r\nproto_tree_add_item(tree, hf_mausb_mgmt_ep_handle_pad, tvb,\r\noffset, 4, ENC_NA);\r\noffset += 4;\r\n} else {\r\nsize_ep_des = MAUSB_SIZE_EP_HANDLE;\r\nproto_tree_add_item(tree, hf_mausb_mgmt_ep_handle_pad, tvb,\r\noffset, 4, ENC_NA);\r\noffset += 4;\r\n}\r\nfor (i = 0; i < num_ep; ++i) {\r\nloop_offset = offset;\r\nif (del) {\r\nloop_offset += dissect_ep_handle(tree, tvb, loop_offset);\r\n} else if (req) {\r\ndissect_usb_endpoint_descriptor(pinfo, tree, tvb, loop_offset,\r\n&usb_conv_info);\r\nloop_offset += USB_DT_EP_SIZE;\r\nif (MAUSB_EP_DES_SIZE < size_ep_des) {\r\ndissect_usb_unknown_descriptor(pinfo, tree,\r\ntvb, loop_offset, &usb_conv_info);\r\nloop_offset += USB_DT_SS_EP_COMP_SIZE;\r\nif (MAUSB_SS_EP_DES_SIZE < size_ep_des) {\r\nloop_offset += dissect_usb_unknown_descriptor(pinfo, tree,\r\ntvb, loop_offset, &usb_conv_info);\r\nproto_tree_add_item(tree, hf_mausb_ep_handle_req_pad, tvb,\r\nloop_offset, MAUSB_ISO_SSP_EP_DES_PAD, ENC_NA);\r\nloop_offset += MAUSB_ISO_SSP_EP_DES_PAD;\r\n} else {\r\nproto_tree_add_item(tree, hf_mausb_ep_handle_req_pad, tvb,\r\nloop_offset, MAUSB_SS_EP_DES_PAD, ENC_NA);\r\nloop_offset += MAUSB_SS_EP_DES_PAD;\r\n}\r\n} else {\r\nproto_tree_add_item(tree, hf_mausb_ep_handle_req_pad, tvb,\r\nloop_offset, MAUSB_EP_DES_PAD, ENC_NA);\r\nloop_offset += MAUSB_EP_DES_PAD;\r\n}\r\n} else {\r\nloop_offset += dissect_ep_handle(tree, tvb, loop_offset);\r\nproto_tree_add_item(tree, hf_mausb_ep_handle_resp_dir, tvb,\r\nloop_offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_mausb_ep_handle_resp_iso, tvb,\r\nloop_offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_mausb_ep_handle_resp_lman, tvb,\r\nloop_offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_mausb_ep_handle_resp_valid, tvb,\r\nloop_offset, 1, ENC_LITTLE_ENDIAN);\r\nloop_offset += 2;\r\nproto_tree_add_item(tree, hf_mausb_ep_handle_resp_ccu, tvb,\r\nloop_offset, 2, ENC_LITTLE_ENDIAN);\r\nloop_offset += 2;\r\nloop_offset += 2;\r\nproto_tree_add_item(tree, hf_mausb_ep_handle_resp_buf_size, tvb,\r\nloop_offset, 4, ENC_LITTLE_ENDIAN);\r\nloop_offset += 4;\r\nproto_tree_add_item(tree, hf_mausb_ep_handle_resp_iso_prog_dly, tvb,\r\nloop_offset, 2, ENC_LITTLE_ENDIAN);\r\nloop_offset += 2;\r\nproto_tree_add_item(tree, hf_mausb_ep_handle_resp_iso_resp_dly, tvb,\r\nloop_offset, 2, ENC_LITTLE_ENDIAN);\r\nloop_offset += 2;\r\n}\r\noffset += size_ep_des;\r\nif (req && !del && loop_offset != offset){\r\nexpert_add_info(pinfo, size_field, &ei_ep_handle_len);\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic guint16 dissect_mausb_mgmt_pkt_cancel_transfer( proto_tree *tree,\r\ntvbuff_t *tvb, gint offset, gboolean req)\r\n{\r\nguint8 status;\r\noffset += dissect_ep_handle(tree, tvb, offset);\r\nproto_tree_add_item(tree, hf_mausb_stream_id, tvb, offset, 2,\r\nENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_mausb_req_id, tvb, offset, 1,\r\nENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nif (req) {\r\nproto_tree_add_item(tree, hf_mausb_cancel_transfer_rsvd, tvb, offset, 3,\r\nENC_NA);\r\noffset += 3;\r\nreturn offset;\r\n}\r\nstatus = tvb_get_guint8(tvb, offset) |\r\nMAUSB_CANCEL_TRANSFER_STATUS_MASK;\r\nproto_tree_add_item(tree, hf_mausb_cancel_transfer_status, tvb, offset, 3,\r\nENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_mausb_cancel_transfer_rsvd_2, tvb, offset, 3,\r\nENC_LITTLE_ENDIAN);\r\noffset += 3;\r\nif (2 == status) {\r\nproto_tree_add_item(tree, hf_mausb_cancel_transfer_seq_num, tvb, offset,\r\n3, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\nproto_tree_add_item(tree, hf_mausb_cancel_transfer_rsvd, tvb, offset, 1,\r\nENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_mausb_cancel_transfer_byte_offset, tvb,\r\noffset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\n} else {\r\nproto_tree_add_item(tree, hf_mausb_cancel_transfer_rsvd, tvb, offset, 8,\r\nENC_NA);\r\noffset += 8;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint16 dissect_mausb_mgmt_pkt_flds(struct mausb_header *header,\r\nproto_tree *tree, tvbuff_t *tvb,\r\npacket_info *pinfo, gint16 start)\r\n{\r\nproto_item *ti;\r\nproto_tree *mgmt_tree;\r\nguint16 offset = start;\r\ngint type_spec_len = tvb_reported_length(tvb) - start;\r\nif (0 > type_spec_len) {\r\nexpert_add_info(pinfo, tree, &ei_mgmt_type_spec_len_short);\r\nreturn offset;\r\n}\r\nti = proto_tree_add_item(tree, hf_mausb_mgmt_type_spec, tvb,\r\noffset, type_spec_len, ENC_NA);\r\nmgmt_tree = proto_item_add_subtree(ti, ett_mgmt);\r\nswitch (header->type) {\r\ncase CapResp:\r\noffset = dissect_mausb_mgmt_pkt_cap_resp(header, mgmt_tree, tvb, pinfo, offset);\r\nbreak;\r\ncase EPHandleReq:\r\noffset = dissect_mausb_mgmt_pkt_ep_handle(mgmt_tree, tvb, pinfo,\r\noffset, TRUE, FALSE);\r\nbreak;\r\ncase EPHandleResp:\r\noffset = dissect_mausb_mgmt_pkt_ep_handle(mgmt_tree, tvb, pinfo,\r\noffset, FALSE, FALSE);\r\nbreak;\r\ncase EPActivateReq:\r\ncase EPActivateResp:\r\ncase EPInactivateReq:\r\ncase EPInactivateResp:\r\ncase EPResetReq:\r\ncase EPResetResp:\r\nproto_tree_add_item(mgmt_tree, hf_mausb_mgmt_type_spec_generic,\r\ntvb, offset, type_spec_len, ENC_NA);\r\noffset += type_spec_len;\r\nbreak;\r\ncase ClearTransfersReq:\r\noffset = dissect_mausb_mgmt_pkt_clear_transfers(mgmt_tree, tvb, offset, TRUE);\r\nbreak;\r\ncase ClearTransfersResp:\r\noffset = dissect_mausb_mgmt_pkt_clear_transfers(mgmt_tree, tvb, offset, FALSE);\r\nbreak;\r\ncase EPHandleDeleteReq:\r\noffset = dissect_mausb_mgmt_pkt_ep_handle(mgmt_tree, tvb, pinfo,\r\noffset, TRUE, TRUE);\r\nbreak;\r\ncase EPHandleDeleteResp:\r\noffset = dissect_mausb_mgmt_pkt_ep_handle(mgmt_tree, tvb, pinfo,\r\noffset, FALSE, TRUE);\r\nbreak;\r\ncase ModifyEP0Resp:\r\ncase EPCloseStreamResp:\r\ncase USBDevResetReq:\r\ncase USBDevResetResp:\r\ncase EPOpenStreamResp:\r\ncase VendorSpecificReq:\r\ncase VendorSpecificResp:\r\ncase CapReq:\r\ncase USBDevHandleReq:\r\ncase USBDevHandleResp:\r\ncase ModifyEP0Req:\r\ncase SetUSBDevAddrReq:\r\ncase SetUSBDevAddrResp:\r\ncase UpdateDevReq:\r\ncase SynchReq:\r\ncase EPCloseStreamReq:\r\nproto_tree_add_item(mgmt_tree, hf_mausb_mgmt_type_spec_generic,\r\ntvb, offset, type_spec_len, ENC_NA);\r\noffset += type_spec_len;\r\nbreak;\r\ncase CancelTransferReq:\r\noffset = dissect_mausb_mgmt_pkt_cancel_transfer(mgmt_tree, tvb, offset,\r\nTRUE);\r\nbreak;\r\ncase CancelTransferResp:\r\noffset = dissect_mausb_mgmt_pkt_cancel_transfer(mgmt_tree, tvb, offset,\r\nFALSE);\r\nbreak;\r\ncase EPOpenStreamReq:\r\nproto_tree_add_item(mgmt_tree, hf_mausb_mgmt_type_spec_generic,\r\ntvb, offset, type_spec_len, ENC_NA);\r\noffset += type_spec_len;\r\nbreak;\r\ncase DevResetReq:\r\ncase DevResetResp:\r\ncase UpdateDevResp:\r\ncase USBDevDisconnectReq:\r\ncase USBDevDisconnectResp:\r\ncase SleepReq:\r\ncase SleepResp:\r\ncase WakeReq:\r\ncase WakeResp:\r\ncase PingReq:\r\ncase PingResp:\r\ncase DevDisconnectReq:\r\ncase DevDisconnectResp:\r\ncase DevInitDisconnectReq:\r\ncase DevInitDisconnectResp:\r\ncase SynchResp:\r\nbreak;\r\ndefault:\r\nexpert_add_info(pinfo, mgmt_tree, &ei_mgmt_type_undef);\r\nbreak;\r\n}\r\nif (offset < tvb_reported_length(tvb)) {\r\nexpert_add_info(pinfo, mgmt_tree, &ei_mgmt_type_spec_len_long);\r\n}\r\nreturn offset;\r\n}\r\nvoid mausb_set_usb_conv_info(usb_conv_info_t *usb_conv_info,\r\nstruct mausb_header *header)\r\n{\r\nusb_conv_info->is_request = mausb_is_transfer_req(header);\r\nusb_conv_info->bus_id = mausb_ep_handle_bus_num(header->handle);\r\nusb_conv_info->device_address = mausb_ep_handle_dev_addr(header->handle);\r\nusb_conv_info->direction = mausb_is_from_host(header);\r\nusb_conv_info->endpoint = mausb_ep_handle_ep_num(header->handle);\r\nusb_conv_info->is_setup = mausb_has_setup_data(header) ||\r\nmausb_is_setup_response(header);\r\nswitch (mausb_tx_type(header)) {\r\ncase MAUSB_TX_TYPE_CTRL:\r\nusb_conv_info->transfer_type = URB_CONTROL;\r\nbreak;\r\ncase MAUSB_TX_TYPE_ISOC:\r\nusb_conv_info->transfer_type = URB_ISOCHRONOUS;\r\nbreak;\r\ncase MAUSB_TX_TYPE_BULK:\r\nusb_conv_info->transfer_type = URB_BULK;\r\nbreak;\r\ncase MAUSB_TX_TYPE_INTR:\r\nusb_conv_info->transfer_type = URB_INTERRUPT;\r\nbreak;\r\ndefault:\r\nusb_conv_info->transfer_type = URB_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nstatic int\r\ndissect_mausb_pkt_common(tvbuff_t *tvb, gint offset, packet_info *pinfo,\r\nproto_tree *mausb_tree, struct mausb_header *header)\r\n{\r\nproto_item *len_field;\r\nheader->ver_flags = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(mausb_tree, hf_mausb_version, tvb,\r\noffset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask(mausb_tree, tvb, offset, hf_mausb_flags,\r\nett_mausb_flags, mausb_flag_fields, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nheader->type = tvb_get_guint8(tvb, offset);\r\ncol_append_str(pinfo->cinfo, COL_INFO, val_to_str(header->type, mausb_type_string, "%d"));\r\nproto_tree_add_item(mausb_tree, hf_mausb_type, tvb,\r\noffset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nheader->length = tvb_get_letohs(tvb, offset);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " Length=%u", header->length);\r\nlen_field = proto_tree_add_item(mausb_tree, hf_mausb_length, tvb,\r\noffset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nif (tvb_reported_length(tvb) != header->length) {\r\nexpert_add_info(pinfo, len_field, &ei_len);\r\n}\r\nheader->handle = tvb_get_letohs(tvb, offset);\r\nif (mausb_is_mgmt_pkt(header)) {\r\nproto_tree_add_item(mausb_tree, hf_mausb_dev_handle, tvb,\r\noffset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\n} else {\r\noffset += dissect_ep_handle(mausb_tree, tvb, offset);\r\n}\r\nheader->ma_dev_addr = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(mausb_tree, hf_mausb_ma_dev_addr, tvb,\r\noffset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nheader->mass_id = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(mausb_tree, hf_mausb_ssid, tvb,\r\noffset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nheader->status = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(mausb_tree, hf_mausb_status, tvb,\r\noffset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_mausb_pkt_data(tvbuff_t *tvb, gint offset, packet_info *pinfo,\r\nproto_tree *mausb_tree, struct mausb_header *header)\r\n{\r\nheader->u.s.eps_tflags = tvb_get_guint8(tvb, offset);\r\nif (mausb_is_from_host(header)) {\r\nproto_tree_add_item(mausb_tree, hf_mausb_eps_rsvd, tvb,\r\noffset, 1, ENC_LITTLE_ENDIAN);\r\n} else {\r\nproto_tree_add_item(mausb_tree, hf_mausb_eps, tvb,\r\noffset, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nproto_tree_add_bitmask(mausb_tree, tvb, offset, hf_mausb_tflags,\r\nett_mausb_tflags, mausb_tflag_fields, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nif (mausb_is_iso_pkt(header)) {\r\nheader->u.s.u1.num_headers_iflags = tvb_get_letohs(tvb, offset);\r\nproto_tree_add_item(mausb_tree, hf_mausb_num_iso_hdr, tvb,\r\noffset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask(mausb_tree, tvb, offset, hf_mausb_iflags,\r\nett_mausb_iflags, mausb_iflag_fields, ENC_LITTLE_ENDIAN);\r\n} else {\r\nheader->u.s.u1.stream_id = tvb_get_letohs(tvb, offset);\r\nproto_tree_add_item(mausb_tree, hf_mausb_stream_id, tvb,\r\noffset, 2, ENC_LITTLE_ENDIAN);\r\n}\r\noffset += 2;\r\nheader->u.s.seq_num = tvb_get_letoh24(tvb, offset);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " SeqNum=%u", header->u.s.seq_num);\r\nproto_tree_add_item(mausb_tree, hf_mausb_seq_num, tvb,\r\noffset, 3, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\nheader->u.s.req_id = tvb_get_guint8(tvb, offset);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " ReqID=%u", header->u.s.req_id);\r\nproto_tree_add_item(mausb_tree, hf_mausb_req_id, tvb,\r\noffset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nif (mausb_is_iso_pkt(header)) {\r\nheader->u.s.u2.present_time_num_seg = tvb_get_letohl(tvb, offset);\r\ndissect_mausb_present_time(mausb_tree, tvb, offset);\r\nproto_tree_add_item(mausb_tree, hf_mausb_num_segs, tvb,\r\noffset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nif (mausb_has_timestamp(header)) {\r\nheader->u.s.timestamp = tvb_get_letohl(tvb, offset);\r\ndissect_mausb_timestamp(mausb_tree, tvb, offset);\r\noffset += 4;\r\n}\r\nif (mausb_has_mtd(header)) {\r\nheader->u.s.tx_dly = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(mausb_tree, hf_mausb_mtd, tvb,\r\noffset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\n}\r\n} else {\r\nheader->u.s.u2.credit = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(mausb_tree, hf_mausb_rem_size_credit, tvb,\r\noffset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_mausb_pkt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nvoid *data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *mausb_tree;\r\nstruct mausb_header header;\r\ngint offset = 0;\r\nmemset(&header, 0, sizeof(struct mausb_header));\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MAUSB");\r\nmausb_num_pdus++;\r\ncol_add_str(pinfo->cinfo, COL_INFO, "[");\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\nti = proto_tree_add_item(tree, proto_mausb, tvb, 0,\r\nmausb_get_pkt_len(pinfo, tvb, offset, NULL), ENC_NA);\r\nmausb_tree = proto_item_add_subtree(ti, ett_mausb);\r\noffset = dissect_mausb_pkt_common(tvb, offset, pinfo, mausb_tree, &header);\r\nif (mausb_is_mgmt_pkt(&header)) {\r\nheader.u.token = tvb_get_letohs(tvb, 9) & MAUSB_TOKEN_MASK;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " Token=%u", header.u.token);\r\nproto_tree_add_item(mausb_tree, hf_mausb_token, tvb,\r\noffset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(mausb_tree, hf_mausb_mgmt_pad, tvb,\r\noffset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nif (offset < header.length) {\r\ndissect_mausb_mgmt_pkt_flds(&header, mausb_tree, tvb, pinfo, offset);\r\n}\r\n}\r\nelse if (mausb_is_data_pkt(&header)) {\r\ndissect_mausb_pkt_data(tvb, offset, pinfo, mausb_tree, &header);\r\nif (!mausb_is_transfer_ack(&header)) {\r\ndissect_usb_common(tvb, pinfo, tree, USB_HEADER_MAUSB, &header);\r\n}\r\n}\r\ncol_append_str(pinfo->cinfo, COL_INFO, "]");\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\nreturn header.length;\r\n}\r\nstatic int\r\ndissect_mausb(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nmausb_num_pdus = 0;\r\ntcp_dissect_pdus(tvb, pinfo, tree, TRUE, MAUSB_MIN_LENGTH,\r\nmausb_get_pkt_len, dissect_mausb_pkt, data);\r\nif (1 < mausb_num_pdus) {\r\ncol_clear_fence(pinfo->cinfo, COL_INFO);\r\ncol_prepend_fstr(pinfo->cinfo, COL_INFO, "[%i packets] ", mausb_num_pdus);\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nvoid\r\nproto_register_mausb(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_mausb_version,\r\n{ "Version", "mausb.version", FT_UINT8, BASE_DEC,\r\nVALS(mausb_version_string), MAUSB_VERSION_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_flags,\r\n{ "Flags", "mausb.flags", FT_UINT8, BASE_HEX,\r\nNULL, MAUSB_FLAG_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_flag_host,\r\n{ "Host", "mausb.flags.host", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), (MAUSB_FLAG_HOST << MAUSB_FLAG_OFFSET),\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_flag_retry,\r\n{ "Retry", "mausb.flags.retry", FT_BOOLEAN, 8,\r\nTFS(&tfs_yes_no), (MAUSB_FLAG_RETRY << MAUSB_FLAG_OFFSET),\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_flag_timestamp,\r\n{ "Timestamp", "mausb.flags.timestamp", FT_BOOLEAN, 8,\r\nTFS(&tfs_present_not_present),\r\n(MAUSB_FLAG_TIMESTAMP << MAUSB_FLAG_OFFSET),\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_flag_reserved,\r\n{ "Reserved", "mausb.flags.reserved", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), (MAUSB_FLAG_RESERVED << MAUSB_FLAG_OFFSET),\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_type,\r\n{ "Type", "mausb.type", FT_UINT8, BASE_HEX,\r\nVALS(mausb_type_string), 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_length,\r\n{ "Length", "mausb.length", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_dev_handle,\r\n{ "Device Handle", "mausb.dev_handle", FT_UINT16, BASE_HEX,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_ep_handle,\r\n{ "Endpoint Handle", "mausb.ep_handle", FT_UINT16, BASE_HEX,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_ep_handle_d,\r\n{ "Direction", "mausb.ep_handle.d", FT_BOOLEAN, 16,\r\nTFS(&tfs_endpoint_direction), MAUSB_EP_HANDLE_D, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_ep_handle_ep_num,\r\n{ "Endpoint Number", "mausb.ep_handle.ep_num", FT_UINT16, BASE_DEC,\r\nNULL, MAUSB_EP_HANDLE_EP_NUM, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_ep_handle_dev_addr,\r\n{ "USB Device Address", "mausb.ep_handle.dev_addr", FT_UINT16, BASE_DEC,\r\nNULL, MAUSB_EP_HANDLE_DEV_ADDR, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_ep_handle_bus_num,\r\n{ "USB Bus Number", "mausb.ep_handle.bus_num", FT_UINT16, BASE_DEC,\r\nNULL, MAUSB_EP_HANDLE_BUS_NUM, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_ma_dev_addr,\r\n{ "MA Device Address", "mausb.ma_dev_addr", FT_UINT8, BASE_HEX,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_ssid,\r\n{ "Service Set ID", "mausb.ssid", FT_UINT8, BASE_HEX,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_status,\r\n{ "Status", "mausb.status", FT_UINT8, BASE_DEC,\r\nVALS(mausb_status_string), 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_token,\r\n{ "Token", "mausb.token", FT_UINT16, BASE_DEC,\r\nNULL, MAUSB_TOKEN_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_mgmt_pad,\r\n{ "Padding to a DWORD", "mausb.mgmt_pad",\r\nFT_UINT16, BASE_HEX, NULL, MAUSB_MGMT_PAD_MASK,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_mgmt_type_spec,\r\n{ "Type-specific management packet fields", "mausb.mgmt_flds",\r\nFT_NONE, 0, NULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_mgmt_type_spec_generic,\r\n{ "Type-specific management packet fields", "mausb.mgmt_flds.generic",\r\nFT_NONE, 0, NULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_eps,\r\n{ "EP Status", "mausb.eps", FT_UINT8, BASE_HEX,\r\nVALS(mausb_eps_string), MAUSB_EPS_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_eps_rsvd,\r\n{ "EP Status", "mausb.eps.reserved", FT_UINT8, BASE_HEX,\r\nNULL, MAUSB_EPS_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_tflags,\r\n{ "Transfer Flags", "mausb.tflag", FT_UINT8, BASE_HEX,\r\nNULL, MAUSB_TFLAG_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_tflag_arq,\r\n{ "ARQ", "mausb.tflag.arq", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), MAUSB_TFLAG_ARQ << MAUSB_TFLAG_OFFSET,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_tflag_neg,\r\n{ "NEG", "mausb.tflag.neg", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), MAUSB_TFLAG_NEG << MAUSB_TFLAG_OFFSET,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_tflag_eot,\r\n{ "EoT", "mausb.tflag.eot", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), MAUSB_TFLAG_EOT << MAUSB_TFLAG_OFFSET,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_tflag_type,\r\n{ "Transfer Type", "mausb.tflag.type", FT_UINT8, BASE_HEX,\r\nVALS(mausb_transfer_type_string),\r\nMAUSB_TFLAG_TRANSFER_TYPE << MAUSB_TFLAG_OFFSET,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_tflag_rsvd,\r\n{ "Reserved", "mausb.tflag.rsvd", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), MAUSB_TFLAG_RSVD << MAUSB_TFLAG_OFFSET,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_num_iso_hdr,\r\n{ "Number of Iso Headers", "mausb.numisohdr", FT_UINT16, BASE_DEC,\r\nNULL, MAUSB_NUM_ISO_HDR_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_iflags,\r\n{ "Isochronous Flags", "mausb.iflag", FT_UINT16, BASE_HEX,\r\nNULL, MAUSB_IFLAG_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_iflag_mtd,\r\n{ "MTD Valid", "mausb.iflag.mtd", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), MAUSB_IFLAG_MTD << MAUSB_IFLAG_OFFSET,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_iflag_hdr_format,\r\n{ "Isochronous Header Format", "mausb.iflag.ihf", FT_UINT8, BASE_HEX,\r\nNULL, MAUSB_IFLAG_HDR_FORMAT << MAUSB_IFLAG_OFFSET, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_iflag_asap,\r\n{ "ASAP", "mausb.iflag.asap", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), MAUSB_IFLAG_ASAP << MAUSB_IFLAG_OFFSET,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_stream_id,\r\n{ "Stream ID", "mausb.streamid", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_seq_num,\r\n{ "Sequence Number", "mausb.seqnum", FT_UINT24, BASE_DEC,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_req_id,\r\n{ "Request ID", "mausb.reqid", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_present_time,\r\n{ "Presentation Time", "mausb.presenttime", FT_UINT32, BASE_DEC,\r\nNULL, MAUSB_PRESENT_TIME_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_uframe,\r\n{ "Microframe Number", "mausb.uframe", FT_UINT32, BASE_DEC,\r\nNULL, MAUSB_UFRAME_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_frame,\r\n{ "Frame Number", "mausb.frame", FT_UINT32, BASE_DEC,\r\nNULL, MAUSB_FRAME_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_num_segs,\r\n{ "Number of Segments", "mausb.numseg", FT_UINT32, BASE_DEC,\r\nNULL, MAUSB_NUM_SEGS_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_timestamp,\r\n{ "Timestamp", "mausb.timestamp", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_delta,\r\n{ "Delta", "mausb.delta", FT_UINT32, BASE_DEC,\r\nNULL, MAUSB_DELTA_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_nom_interval,\r\n{ "Nominal Bus Interval", "mausb.nomitvl", FT_UINT32, BASE_DEC,\r\nNULL, MAUSB_INTERVAL_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_mtd,\r\n{ "Media Time/Transmission Delay", "mausb.mtd", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_rem_size_credit,\r\n{ "Remaining Size/Credit", "mausb.remsize_credit", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n};\r\nstatic hf_register_info hf_cap[] = {\r\n{ &hf_mausb_cap_resp_num_ep,\r\n{ "Number of Endpoints", "mausb.cap_resp.num_ep",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"the maximum number of endpoints for this device",\r\nHFILL\r\n}\r\n},\r\n{ &hf_mausb_cap_resp_num_dev,\r\n{ "Number of Devices", "mausb.cap_resp.num_dev",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"the maximum number of USB devices the MA USB device can manage",\r\nHFILL\r\n}\r\n},\r\n{ &hf_mausb_cap_resp_num_stream,\r\n{ "Number of Streams", "mausb.cap_resp.num_stream",\r\nFT_UINT8, BASE_DEC, NULL, MAUSB_CAP_RESP_NUM_STREAM_MASK,\r\n"2 to the power of this value is the max number of streams supported",\r\nHFILL\r\n}\r\n},\r\n{ &hf_mausb_cap_resp_dev_type,\r\n{ "Device Type", "mausb.cap_resp.dev_type", FT_UINT8, BASE_HEX,\r\nVALS(mausb_cap_resp_dev_type), MAUSB_CAP_RESP_DEV_TYPE_MASK,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_cap_resp_desc_count,\r\n{ "Descriptors Count", "mausb.cap_resp.desc_count",\r\nFT_UINT8, BASE_DEC,\r\nNULL, 0, "The total number of MA Device Capabilities descriptors",\r\nHFILL\r\n}\r\n},\r\n{ &hf_mausb_cap_resp_desc_len,\r\n{ "Descriptors Length", "mausb.cap_resp.desc_len",\r\nFT_UINT24, BASE_DEC,\r\nNULL, 0, "The total size of MA Device Capabilities descriptors",\r\nHFILL\r\n}\r\n},\r\n{ &hf_mausb_cap_resp_transfer_req,\r\n{ "Number of Outstanding Transfer Requests",\r\n"mausb.cap_resp.transfer_req",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"The maximum number of total outstanding transfer requests", HFILL\r\n}\r\n},\r\n{ &hf_mausb_cap_resp_mgmt_req,\r\n{ "Number of Outstanding Management Requests", "mausb.cap_resp.mgmt_req",\r\nFT_UINT16, BASE_DEC, NULL,\r\nMAUSB_CAP_RESP_MGMT_REQ_MASK,\r\n"The maximum number of host initiated outstanding management requests",\r\nHFILL\r\n}\r\n},\r\n{ &hf_mausb_cap_resp_rsvd,\r\n{ "Reserved", "mausb.cap_resp.rsvd", FT_UINT16, BASE_HEX,\r\nNULL, MAUSB_CAP_RESP_RSVD_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_dev_cap_len,\r\n{ "Length", "mausb.cap_resp.dev_cap.length",\r\nFT_UINT8, BASE_DEC, NULL,\r\n0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_dev_cap_type,\r\n{ "Type", "mausb.cap_resp.dev_cap.type",\r\nFT_UINT8, BASE_DEC, VALS(mausb_dev_cap_string),\r\n0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_dev_cap_generic,\r\n{ "Type-specific device capability descriptor fields",\r\n"mausb.cap_resp.dev_cap.generic",\r\nFT_NONE, 0, NULL, 0, NULL, HFILL\r\n}\r\n}\r\n};\r\nstatic hf_register_info hf_ep_handle[] = {\r\n{ &hf_mausb_mgmt_ep_handle_num,\r\n{ "Number of Endpoint Handles", "mausb.ep_handle_num",\r\nFT_UINT8, BASE_DEC,\r\nNULL, MAUSB_MGMT_NUM_EP_DES_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_mgmt_ep_handle_pad,\r\n{ "Padding to a DWORD", "mausb.ep_handle_pad",\r\nFT_NONE, 0,\r\nNULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_mgmt_ep_des_num,\r\n{ "Number of Endpoint Descriptors", "mausb.ep_des_num",\r\nFT_UINT8, BASE_DEC,\r\nNULL, MAUSB_MGMT_NUM_EP_DES_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_mgmt_ep_des_size,\r\n{ "Size of Endpoint Descriptors", "mausb.ep_des_size",\r\nFT_UINT16, BASE_DEC,\r\nNULL, MAUSB_MGMT_SIZE_EP_DES_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_mgmt_ep_des_pad,\r\n{ "Padding to a DWORD", "mausb.ep_des_pad",\r\nFT_NONE, 0, NULL,\r\n0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_ep_handle_req_pad,\r\n{ "Padding to a DWORD", "mausb.ep_handle_req.pad",\r\nFT_NONE, 0, NULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_ep_handle_resp_dir,\r\n{ "Direction", "mausb.ep_dir", FT_BOOLEAN, 6,\r\nTFS(&tfs_ep_handle_resp_dir), MAUSB_EP_HANDLE_RESP_DIR_MASK,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_ep_handle_resp_iso,\r\n{ "Isochronous", "mausb.ep_iso", FT_BOOLEAN, 6,\r\nTFS(&tfs_yes_no), MAUSB_EP_HANDLE_RESP_ISO_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_ep_handle_resp_lman,\r\n{ "L-Managed", "mausb.ep_lman", FT_BOOLEAN, 6,\r\nTFS(&tfs_supported_not_supported), MAUSB_EP_HANDLE_RESP_LMAN_MASK,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_ep_handle_resp_valid,\r\n{ "Valid", "mausb.ep_valid", FT_BOOLEAN, 6,\r\nTFS(&tfs_invalid_valid), MAUSB_EP_HANDLE_RESP_VALID_MASK,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_ep_handle_resp_ccu,\r\n{ "CCU", "mausb.ep_ccu", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_ep_handle_resp_buf_size,\r\n{ "Buffer Size", "mausb.ep_buf_size", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_ep_handle_resp_iso_prog_dly,\r\n{ "Iso Programming Delay", "mausb.ep_iso_prog_dly", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_ep_handle_resp_iso_resp_dly,\r\n{ "Iso Response Delay", "mausb.ep_iso_resp_dly", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL\r\n}\r\n}\r\n};\r\nstatic hf_register_info hf_cancel_transfer[] = {\r\n{ &hf_mausb_clear_transfers_info_block,\r\n{ "Clear Transfers Information Block", "mausb.clear_transfers.info", FT_NONE, 0,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_clear_transfers_status_block,\r\n{ "Cancel Transfers Status Block", "mausb.clear_transfers.status_block", FT_NONE, 0,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_cancel_transfer_rsvd,\r\n{ "Reserved", "mausb.cancel_transfer.rsvd", FT_NONE, 0,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_clear_transfers_req_num,\r\n{ "Number of Blocks", "mausb.clear_transfers_req.num", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_clear_transfers_req_rsvd,\r\n{ "Reserved", "mausb.clear_transfers_req.rsvd", FT_NONE, 0,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_clear_transfers_resp_num,\r\n{ "Number of Blocks", "mausb.clear_transfers_resp.num", FT_UINT32, BASE_DEC,\r\nNULL, MAUSB_CLEAR_TRANSFERS_RESP_NUM_MASK , NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_clear_transfers_resp_rsvd,\r\n{ "Reserved", "mausb.clear_transfers_resp.rsvd", FT_UINT32, BASE_HEX,\r\nNULL, ~MAUSB_CLEAR_TRANSFERS_RESP_NUM_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_cancel_transfer_status,\r\n{ "Status", "mausb.cancel_transfer.status", FT_UINT24, BASE_HEX,\r\nVALS(mausb_cancel_transfer_status_string),\r\nMAUSB_CANCEL_TRANSFER_STATUS_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_cancel_transfer_rsvd_2,\r\n{ "Reserved", "mausb.cancel_transfer.rsvd_2", FT_UINT24, BASE_HEX,\r\nNULL, ~MAUSB_CANCEL_TRANSFER_STATUS_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_clear_transfers_status,\r\n{ "Cancellation Status", "mausb.clear_transfers.status", FT_BOOLEAN, 6,\r\nTFS(&tfs_success_fail), MAUSB_CLEAR_TRANSFERS_STATUS_MASK,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_clear_transfers_partial,\r\n{ "Partial Delivery", "mausb.clear_transfers.partial", FT_BOOLEAN, 6,\r\nTFS(&tfs_true_false), MAUSB_CLEAR_TRANSFERS_PARTIAL_MASK,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_clear_transfers_start_req_id,\r\n{ "Start Request ID", "mausb.clear_transfers.start_reqid", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_clear_transfers_last_req_id,\r\n{ "Last Request ID", "mausb.clear_transfers.last_reqid", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_clear_transfers_req_block_rsvd,\r\n{ "Reserved", "mausb.clear_transfers_req.block_rsvd", FT_NONE, 0,\r\nNULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_clear_transfers_resp_block_rsvd,\r\n{ "Reserved", "mausb.clear_transfers_resp.block_rsvd", FT_UINT32, BASE_HEX,\r\nNULL, MAUSB_CLEAR_TRANSFERS_RESP_BLOCK_RSVD_MASK, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_cancel_transfer_seq_num,\r\n{ "Delivered Sequence Number", "mausb.cancel_transfer.seqnum",\r\nFT_UINT24, BASE_DEC, NULL, 0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_mausb_cancel_transfer_byte_offset,\r\n{ "Delivered Byte Offset", "mausb.cancel_transfer.byte_offset",\r\nFT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL\r\n}\r\n},\r\n};\r\nstatic hf_register_info oui_hf[] = {\r\n{ &hf_llc_mausb_pid,\r\n{ "PID", "mausb.pid", FT_UINT16, BASE_HEX,\r\nVALS(mausb_pid_string), 0x0, NULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_mausb,\r\n&ett_mausb_flags,\r\n&ett_mausb_ep_handle,\r\n&ett_mausb_tflags,\r\n&ett_mausb_iflags,\r\n&ett_mausb_present_time,\r\n&ett_mausb_timestamp,\r\n&ett_mgmt,\r\n&ett_dev_cap,\r\n&ett_clear_transfers_block\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_ep_handle_len,\r\n{ "mausb.ei.ep_handle.length", PI_PROTOCOL, PI_WARN,\r\n"Invalid Endpoint handle length field", EXPFILL }\r\n},\r\n{ &ei_len,\r\n{ "mausb.ei.length", PI_MALFORMED, PI_ERROR,\r\n"Packet length field does not match size of packet", EXPFILL }\r\n},\r\n{ &ei_mgmt_type_undef,\r\n{ "mausb.ei.type", PI_PROTOCOL, PI_WARN,\r\n"Undefined management packet type", EXPFILL }\r\n},\r\n{ &ei_mgmt_type_spec_len_long,\r\n{ "mausb.ei.type_spec.len", PI_PROTOCOL, PI_WARN,\r\n"Data exists after type-specific management packet field", EXPFILL }\r\n},\r\n{ &ei_mgmt_type_spec_len_short,\r\n{ "mausb.ei.type_spec.len", PI_PROTOCOL, PI_WARN,\r\n"Expected type-specific management packet data", EXPFILL }\r\n},\r\n{ &ei_dev_cap_len,\r\n{ "mausb.ei.cap_resp.dev_cap.length", PI_PROTOCOL, PI_WARN,\r\n"Incorrect length value for this device capability descriptor",\r\nEXPFILL }\r\n},\r\n{ &ei_dev_cap_resp_desc_len,\r\n{ "mausb.ei.dev_cap_resp.desc_len", PI_PROTOCOL, PI_WARN,\r\n"Incorrect value in Device Descriptors Length field", EXPFILL }\r\n},\r\n{ &ei_cap_resp_desc_len,\r\n{ "mausb.ei.cap_resp.desc_len", PI_PROTOCOL, PI_WARN,\r\n"Value in Descriptors Length field exceeds actual space in packet", EXPFILL }\r\n},\r\n};\r\nmodule_t *mausb_module;\r\nexpert_module_t* expert_mausb;\r\nproto_mausb = proto_register_protocol("Media Agnostic USB",\r\n"MAUSB", "mausb");\r\nproto_register_field_array(proto_mausb, hf, array_length(hf));\r\nproto_register_field_array(proto_mausb, hf_cap, array_length(hf_cap));\r\nproto_register_field_array(proto_mausb, hf_ep_handle, array_length(hf_ep_handle));\r\nproto_register_field_array(proto_mausb, hf_cancel_transfer, array_length(hf_cancel_transfer));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_mausb = expert_register_protocol(proto_mausb);\r\nexpert_register_field_array(expert_mausb, ei, array_length(ei));\r\nmausb_module = prefs_register_protocol(proto_mausb, proto_reg_handoff_mausb);\r\nprefs_register_uint_preference(mausb_module, "tcp.port", "MAUSB TCP Port",\r\n"Set the port for Media Agnostic Packets",\r\n10, &mausb_tcp_port_pref);\r\nprefs_register_uint_preference(mausb_module, "udp.port", "MAUSB UDP Port",\r\n"Set the port for Media Agnostic Packets",\r\n10, &mausb_udp_port_pref);\r\nllc_add_oui(OUI_WFA, "llc.wfa_pid", "LLC WFA OUI PID", oui_hf, proto_mausb);\r\n}\r\nvoid\r\nproto_reg_handoff_mausb(void)\r\n{\r\nstatic gboolean initialized = FALSE;\r\nstatic dissector_handle_t mausb_tcp_handle;\r\nstatic dissector_handle_t mausb_pkt_handle;\r\nstatic guint saved_mausb_tcp_port_pref;\r\nstatic guint saved_mausb_udp_port_pref;\r\nif (!initialized) {\r\nmausb_tcp_handle = create_dissector_handle(dissect_mausb,\r\nproto_mausb);\r\nmausb_pkt_handle = create_dissector_handle(dissect_mausb_pkt,\r\nproto_mausb);\r\ndissector_add_uint("llc.wfa_pid", PID_MAUSB, mausb_pkt_handle);\r\ninitialized = TRUE;\r\n} else {\r\ndissector_delete_uint("tcp.port", saved_mausb_tcp_port_pref, mausb_tcp_handle);\r\ndissector_delete_uint("udp.port", saved_mausb_udp_port_pref, mausb_pkt_handle);\r\n}\r\nsaved_mausb_tcp_port_pref = mausb_tcp_port_pref;\r\nsaved_mausb_udp_port_pref = mausb_udp_port_pref;\r\ndissector_add_uint("tcp.port", mausb_tcp_port_pref, mausb_tcp_handle);\r\ndissector_add_uint("udp.port", mausb_udp_port_pref, mausb_pkt_handle);\r\n}
