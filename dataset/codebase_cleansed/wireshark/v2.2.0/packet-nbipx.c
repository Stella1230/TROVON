static void\r\nadd_routers(proto_tree *tree, tvbuff_t *tvb, int offset)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nif (tvb_get_ntohl(tvb, offset) != 0) {\r\nproto_tree_add_item(tree, hf_nbipx_ipx_network, tvb, offset, 4, ENC_NA);\r\n}\r\noffset += 4;\r\n}\r\n}\r\nstatic void\r\ndissect_netbios_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nheur_dtbl_entry_t *hdtbl_entry;\r\nif (!dissector_try_heuristic(netbios_heur_subdissector_list,\r\ntvb, pinfo, tree, &hdtbl_entry, NULL))\r\ncall_data_dissector(tvb, pinfo, tree);\r\n}\r\nstatic int\r\ndissect_nbipx(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ngboolean has_routes;\r\nproto_tree *nbipx_tree = NULL;\r\nproto_item *ti = NULL;\r\nint offset = 0;\r\nguint8 packet_type;\r\nproto_tree *name_type_flag_tree;\r\nproto_item *tf;\r\nchar name[(NETBIOS_NAME_LEN - 1)*4 + 1];\r\nint name_type;\r\ngboolean has_payload;\r\ntvbuff_t *next_tvb;\r\nipxhdr_t *ipxh;\r\nif (data == NULL)\r\nreturn 0;\r\nipxh = (ipxhdr_t*)data;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "NBIPX");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (ipxh->ipx_type == IPX_PACKET_TYPE_WANBCAST) {\r\nhas_routes = TRUE;\r\n} else {\r\nhas_routes = FALSE;\r\nif (tvb_reported_length(tvb) == 50) {\r\npacket_type = tvb_get_guint8(tvb, offset + 32 + 1);\r\nswitch (packet_type) {\r\ncase NBIPX_FIND_NAME:\r\ncase NBIPX_NAME_RECOGNIZED:\r\ncase NBIPX_CHECK_NAME:\r\ncase NBIPX_NAME_IN_USE:\r\ncase NBIPX_DEREGISTER_NAME:\r\nhas_routes = TRUE;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_nbipx, tvb, 0,\r\n-1, ENC_NA);\r\nnbipx_tree = proto_item_add_subtree(ti, ett_nbipx);\r\n}\r\nif (has_routes) {\r\nif (tree)\r\nadd_routers(nbipx_tree, tvb, 0);\r\noffset += 32;\r\n}\r\npacket_type = tvb_get_guint8(tvb, offset + 1);\r\nswitch (packet_type) {\r\ncase NBIPX_FIND_NAME:\r\ncase NBIPX_NAME_RECOGNIZED:\r\ncase NBIPX_CHECK_NAME:\r\ncase NBIPX_NAME_IN_USE:\r\ncase NBIPX_DEREGISTER_NAME:\r\nname_type = get_netbios_name(tvb, offset+2, name, (NETBIOS_NAME_LEN - 1)*4 + 1);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s %s<%02x>",\r\nval_to_str_const(packet_type, nbipx_data_stream_type_vals, "Unknown"),\r\nname, name_type);\r\nif (nbipx_tree) {\r\ntf = proto_tree_add_item(nbipx_tree, hf_nbipx_name_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nname_type_flag_tree = proto_item_add_subtree(tf, ett_nbipx_name_type_flags);\r\nproto_tree_add_item(name_type_flag_tree, hf_nbipx_name_flags_group, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(name_type_flag_tree, hf_nbipx_name_flags_in_use, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(name_type_flag_tree, hf_nbipx_name_flags_registered, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(name_type_flag_tree, hf_nbipx_name_flags_duplicated, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(name_type_flag_tree, hf_nbipx_name_flags_deregistered, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n}\r\noffset += 1;\r\nproto_tree_add_uint(nbipx_tree, hf_nbipx_packettype, tvb, offset, 1, packet_type);\r\noffset += 1;\r\nif (nbipx_tree)\r\nnetbios_add_name("Name", tvb, offset, nbipx_tree);\r\noffset += NETBIOS_NAME_LEN;\r\nhas_payload = FALSE;\r\nbreak;\r\ncase NBIPX_SESSION_DATA:\r\ncase NBIPX_SESSION_END:\r\ncase NBIPX_SESSION_END_ACK:\r\ncol_set_str(pinfo->cinfo, COL_INFO,\r\nval_to_str_const(packet_type, nbipx_data_stream_type_vals, "Unknown"));\r\ndissect_conn_control(tvb, offset, nbipx_tree);\r\noffset += 1;\r\nproto_tree_add_uint(nbipx_tree, hf_nbipx_packettype, tvb, offset, 1, packet_type);\r\noffset += 1;\r\nproto_tree_add_item(nbipx_tree, hf_nbipx_session_src_conn_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(nbipx_tree, hf_nbipx_session_dest_conn_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(nbipx_tree, hf_nbipx_session_send_seq_number, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(nbipx_tree, hf_nbipx_session_total_data_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(nbipx_tree, hf_nbipx_session_offset, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(nbipx_tree, hf_nbipx_session_data_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(nbipx_tree, hf_nbipx_session_recv_seq_number, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(nbipx_tree, hf_nbipx_session_bytes_received, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nhas_payload = TRUE;\r\nbreak;\r\ncase NBIPX_DIRECTED_DATAGRAM:\r\ncol_set_str(pinfo->cinfo, COL_INFO,\r\nval_to_str_const(packet_type, nbipx_data_stream_type_vals, "Unknown"));\r\ndissect_conn_control(tvb, offset, nbipx_tree);\r\noffset += 1;\r\nproto_tree_add_uint(nbipx_tree, hf_nbipx_packettype, tvb, offset, 1, packet_type);\r\noffset += 1;\r\nif (nbipx_tree)\r\nnetbios_add_name("Receiver's Name", tvb, offset,\r\nnbipx_tree);\r\noffset += NETBIOS_NAME_LEN;\r\nif (nbipx_tree)\r\nnetbios_add_name("Sender's Name", tvb, offset,\r\nnbipx_tree);\r\noffset += NETBIOS_NAME_LEN;\r\nhas_payload = TRUE;\r\nbreak;\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_INFO,\r\nval_to_str_const(packet_type, nbipx_data_stream_type_vals, "Unknown"));\r\noffset += 1;\r\nproto_tree_add_uint(nbipx_tree, hf_nbipx_packettype, tvb, offset, 1, packet_type);\r\noffset += 1;\r\nhas_payload = FALSE;\r\n}\r\nif (ti != NULL)\r\nproto_item_set_len(ti, offset);\r\nif (has_payload && tvb_offset_exists(tvb, offset)) {\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ndissect_netbios_payload(next_tvb, pinfo, tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_conn_control(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nproto_item *ti;\r\nproto_tree *cc_tree;\r\nif (tree) {\r\nti = proto_tree_add_item(tree, hf_nbipx_conn_control, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\ncc_tree = proto_item_add_subtree(ti, ett_nbipx_conn_ctrl);\r\nproto_tree_add_item(cc_tree, hf_nbipx_conn_control_sys_packet, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(cc_tree, hf_nbipx_conn_control_ack, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(cc_tree, hf_nbipx_conn_control_attention, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(cc_tree, hf_nbipx_conn_control_end_msg, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(cc_tree, hf_nbipx_conn_control_resend, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nvoid\r\nproto_register_nbipx(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_nbipx_packettype,\r\n{ "Packet Type", "nmpi.packettype",\r\nFT_UINT8, BASE_HEX, VALS(nbipx_data_stream_type_vals), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_name_flags,\r\n{ "Name type flag", "nmpi.name_flags",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_name_flags_group,\r\n{ "Name", "nmpi.name_flags.group",\r\nFT_BOOLEAN, 8, TFS(&tfs_group_unique_name), 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_name_flags_in_use,\r\n{ "In use", "nmpi.name_flags.in_use",\r\nFT_BOOLEAN, 8, TFS(&tfs_used_notused), 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_name_flags_registered,\r\n{ "Registered", "nmpi.name_flags.registered",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_name_flags_duplicated,\r\n{ "Duplicated", "nmpi.name_flags.duplicated",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_name_flags_deregistered,\r\n{ "Deregistered", "nmpi.name_flags.deregistered",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_conn_control,\r\n{ "Connection control", "nmpi.conn_control",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_conn_control_sys_packet,\r\n{ "Packet", "nmpi.conn_control.sys_packet",\r\nFT_BOOLEAN, 8, TFS(&tfs_system_non_system), 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_conn_control_ack,\r\n{ "Acknowledgement", "nmpi.conn_control.ack",\r\nFT_BOOLEAN, 8, TFS(&tfs_required_not_required), 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_conn_control_attention,\r\n{ "Attention", "nmpi.conn_control.attention",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_conn_control_end_msg,\r\n{ "End of message", "nmpi.conn_control.end_msg",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_conn_control_resend,\r\n{ "Resend", "nmpi.conn_control.resend",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_session_src_conn_id,\r\n{ "Source connection ID", "nmpi.session.src_conn_id",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_session_dest_conn_id,\r\n{ "Destination connection ID", "nmpi.session.dest_conn_id",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_session_send_seq_number,\r\n{ "Send sequence number", "nmpi.session.send_seq_number",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_session_total_data_length,\r\n{ "Total data length", "nmpi.session.total_data_length",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_session_offset,\r\n{ "Offset", "nmpi.session.offset",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_session_data_length,\r\n{ "Data length", "nmpi.session.data_length",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_session_recv_seq_number,\r\n{ "Receive sequence number", "nmpi.session.recv_seq_number",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_session_bytes_received,\r\n{ "Bytes received", "nmpi.session.bytes_received",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_ipx_network,\r\n{ "IPX Network", "nmpi.ipx_network",\r\nFT_IPXNET, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_opcode,\r\n{ "Opcode", "nmpi.opcode",\r\nFT_UINT8, BASE_HEX, VALS(nmpi_opcode_vals), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_name_type,\r\n{ "Name Type", "nmpi.name_type",\r\nFT_UINT8, BASE_HEX, VALS(nmpi_name_type_vals), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_nbipx_messageid,\r\n{ "Message ID", "nmpi.messageid",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_nbipx,\r\n&ett_nbipx_conn_ctrl,\r\n&ett_nbipx_name_type_flags,\r\n};\r\nproto_nbipx = proto_register_protocol("NetBIOS over IPX", "NBIPX", "nbipx");\r\nproto_register_field_array(proto_nbipx, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_nbipx(void)\r\n{\r\ndissector_handle_t nbipx_handle;\r\nnbipx_handle = create_dissector_handle(dissect_nbipx, proto_nbipx);\r\ndissector_add_uint("ipx.socket", IPX_SOCKET_NETBIOS, nbipx_handle);\r\nnetbios_heur_subdissector_list = find_heur_dissector_list("netbios");\r\n}\r\nstatic int\r\ndissect_nmpi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *nmpi_tree = NULL;\r\nproto_item *ti;\r\nint offset = 0;\r\nguint8 opcode;\r\nchar name[(NETBIOS_NAME_LEN - 1)*4 + 1];\r\nint name_type;\r\nchar node_name[(NETBIOS_NAME_LEN - 1)*4 + 1];\r\ntvbuff_t *next_tvb;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "NMPI");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_nmpi, tvb, offset, 68,\r\nENC_NA);\r\nnmpi_tree = proto_item_add_subtree(ti, ett_nmpi);\r\nadd_routers(nmpi_tree, tvb, offset);\r\n}\r\noffset += 32;\r\nopcode = tvb_get_guint8(tvb, offset);\r\nname_type = get_netbios_name(tvb, offset+4, name, (NETBIOS_NAME_LEN - 1)*4 + 1);\r\nget_netbios_name(tvb, offset+20, node_name, (NETBIOS_NAME_LEN - 1)*4 + 1);\r\nswitch (opcode) {\r\ncase INAME_CLAIM:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Claim name %s<%02x>",\r\nname, name_type);\r\nbreak;\r\ncase INAME_DELETE:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Delete name %s<%02x>",\r\nname, name_type);\r\nbreak;\r\ncase INAME_QUERY:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Query name %s<%02x>",\r\nname, name_type);\r\nbreak;\r\ncase INAME_FOUND:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Name %s<%02x> found",\r\nname, name_type);\r\nbreak;\r\ncase IMSG_HANGUP:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"Messenger hangup on %s<%02x>", name, name_type);\r\nbreak;\r\ncase IMSLOT_SEND:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"Mailslot write to %s<%02x>", name, name_type);\r\nbreak;\r\ncase IMSLOT_FIND:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"Find mailslot name %s<%02x>", name, name_type);\r\nbreak;\r\ncase IMSLOT_NAME:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"Mailslot name %s<%02x> found", name, name_type);\r\nbreak;\r\ndefault:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"Unknown NMPI op 0x%02x: name %s<%02x>",\r\nopcode, name, name_type);\r\nbreak;\r\n}\r\nif (tree) {\r\nproto_tree_add_item(nmpi_tree, hf_nbipx_opcode, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(nmpi_tree, hf_nbipx_name_type, tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(nmpi_tree, hf_nbipx_messageid, tvb, offset+2, 2, ENC_LITTLE_ENDIAN);\r\nnetbios_add_name("Requested name", tvb, offset+4, nmpi_tree);\r\nnetbios_add_name("Source name", tvb, offset+20, nmpi_tree);\r\n}\r\noffset += 1 + 1 + 2 + NETBIOS_NAME_LEN + NETBIOS_NAME_LEN;\r\nif (opcode == IMSLOT_SEND && tvb_offset_exists(tvb, offset)) {\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ndissect_netbios_payload(next_tvb, pinfo, tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_nmpi(void)\r\n{\r\nstatic gint *ett[] = {\r\n&ett_nmpi,\r\n&ett_nmpi_name_type_flags,\r\n};\r\nproto_nmpi = proto_register_protocol("Name Management Protocol over IPX",\r\n"NMPI", "nmpi");\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_nmpi(void)\r\n{\r\ndissector_handle_t nmpi_handle;\r\nnmpi_handle = create_dissector_handle(dissect_nmpi, proto_nmpi);\r\ndissector_add_uint("ipx.socket", IPX_SOCKET_NWLINK_SMB_NAMEQUERY,\r\nnmpi_handle);\r\ndissector_add_uint("ipx.socket", IPX_SOCKET_NWLINK_SMB_MAILSLOT,\r\nnmpi_handle);\r\n}
