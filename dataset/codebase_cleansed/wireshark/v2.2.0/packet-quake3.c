static void\r\ndissect_quake3_ConnectionlessPacket(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, int* direction)\r\n{\r\nproto_tree *cl_tree;\r\nproto_item *text_item = NULL;\r\nproto_tree *text_tree = NULL;\r\nguint8 *text;\r\nint len;\r\nint offset;\r\nguint32 marker;\r\nint command;\r\nint command_len;\r\ngboolean command_finished = FALSE;\r\ncl_tree = proto_tree_add_subtree(tree, tvb,\r\n0, -1, ett_quake3_connectionless, NULL, "Connectionless");\r\nmarker = tvb_get_ntohl(tvb, 0);\r\nproto_tree_add_uint(cl_tree, hf_quake3_connectionless_marker,\r\ntvb, 0, 4, marker);\r\noffset = 4;\r\ntext = tvb_get_stringz_enc(wmem_packet_scope(), tvb, offset, &len, ENC_ASCII|ENC_NA);\r\nif (cl_tree) {\r\ntext_item = proto_tree_add_string(cl_tree,\r\nhf_quake3_connectionless_text,\r\ntvb, offset, len, text);\r\ntext_tree = proto_item_add_subtree(text_item, ett_quake3_connectionless_text);\r\n}\r\ncommand = COMMAND_UNKNOWN;\r\ncommand_len = 0;\r\nif (strncmp(text, "statusResponse", 14) == 0) {\r\ncommand = COMMAND_statusResponse;\r\n*direction = DIR_S2C;\r\ncommand_len = 14;\r\n}\r\nelse if (strncmp(text, "getstatus", 9) == 0) {\r\ncommand = COMMAND_getstatus;\r\n*direction = DIR_C2S;\r\ncommand_len = 9;\r\n}\r\nelse if (strncmp(text, "infoResponse", 12) == 0) {\r\ncommand = COMMAND_infoResponse;\r\n*direction = DIR_S2C;\r\ncommand_len = 12;\r\n}\r\nelse if (strncmp(text, "getinfo", 7) == 0) {\r\ncommand = COMMAND_getinfo;\r\n*direction = DIR_C2S;\r\ncommand_len = 7;\r\n}\r\nelse if (strncmp(text, "challengeResponse", 17) == 0) {\r\ncommand = COMMAND_challengeResponse;\r\n*direction = DIR_S2C;\r\ncommand_len = 17;\r\n}\r\nelse if (strncmp(text, "getchallenge", 12) == 0) {\r\ncommand = COMMAND_getchallenge;\r\n*direction = DIR_C2S;\r\ncommand_len = 12;\r\n}\r\nelse if (strncmp(text, "connectResponse", 15) == 0) {\r\ncommand = COMMAND_connectResponse;\r\n*direction = DIR_S2C;\r\ncommand_len = 15;\r\n}\r\nelse if (strncmp(text, "connect", 7) == 0) {\r\ncommand = COMMAND_connect;\r\n*direction = DIR_C2S;\r\ncommand_len = 7;\r\n}\r\nelse if (strncmp(text, "rconResponse", 12) == 0) {\r\ncommand = COMMAND_rconResponse;\r\n*direction = DIR_S2C;\r\ncommand_len = 12;\r\n}\r\nelse if (strncmp(text, "rcon", 4) == 0) {\r\ncommand = COMMAND_rcon;\r\n*direction = DIR_C2S;\r\ncommand_len = 4;\r\n}\r\nelse if (strncmp(text, "getmotdResponse", 15) == 0) {\r\ncommand = COMMAND_getmotdResponse;\r\n*direction = DIR_M2C;\r\ncommand_len = 15;\r\n}\r\nelse if (strncmp(text, "getmotd", 7) == 0) {\r\ncommand = COMMAND_getmotd;\r\n*direction = DIR_C2M;\r\ncommand_len = 7;\r\n}\r\nelse if (strncmp(text, "getserversResponse", 18) == 0) {\r\nint base;\r\ncommand = COMMAND_getserversResponse;\r\n*direction = DIR_M2C;\r\ncommand_len = 18;\r\nif (text_item) {\r\nproto_item_set_len(text_item, tvb_captured_length_remaining(tvb, offset));\r\nproto_item_set_text(text_item, "Text: getserversResponse<DATA>");\r\n}\r\nif (text_tree)\r\nproto_tree_add_string(text_tree, hf_quake3_connectionless_command,\r\ntvb, offset, command_len,\r\nval_to_str_const(command, names_command, "Unknown"));\r\ncommand_finished = TRUE;\r\nbase = offset + 18;\r\nwhile (tvb_reported_length_remaining(tvb, base) >= 7) {\r\nguint32 ip_addr;\r\nguint16 udp_port;\r\nip_addr = tvb_get_ipv4(tvb, base + 1);\r\nudp_port = tvb_get_ntohs(tvb, base + 5);\r\nif (text_tree) {\r\nproto_tree *server_tree;\r\nserver_tree = proto_tree_add_subtree_format(text_tree,\r\ntvb, base, 7,\r\nett_quake3_server, NULL, "Server: %s:%u",\r\nget_hostname(ip_addr),\r\nudp_port);\r\nproto_tree_add_ipv4(server_tree, hf_quake3_server_addr,\r\ntvb, base + 1, 4, ip_addr);\r\nproto_tree_add_uint(server_tree, hf_quake3_server_port,\r\ntvb, base + 5, 2, udp_port);\r\n}\r\nbase += 7;\r\n}\r\n}\r\nelse if (strncmp(text, "getservers", 10) == 0) {\r\ncommand = COMMAND_getservers;\r\n*direction = DIR_C2M;\r\ncommand_len = 10;\r\n}\r\nelse if (strncmp(text, "getKeyAuthorize", 15) == 0) {\r\ncommand = COMMAND_getKeyAuthorize;\r\n*direction = DIR_C2M;\r\ncommand_len = 15;\r\n}\r\nelse if (strncmp(text, "getIpAuthorize", 14) == 0) {\r\ncommand = COMMAND_getIpAuthorize;\r\n*direction = DIR_C2M;\r\ncommand_len = 14;\r\n}\r\nelse if (strncmp(text, "ipAuthorize", 11) == 0) {\r\ncommand = COMMAND_ipAuthorize;\r\n*direction = DIR_M2C;\r\ncommand_len = 11;\r\n}\r\nelse {\r\n*direction = DIR_UNKNOWN;\r\n}\r\nif (text_tree && command_finished == FALSE) {\r\nproto_tree_add_string(text_tree, hf_quake3_connectionless_command,\r\ntvb, offset, command_len,\r\nval_to_str_const(command, names_command, "Unknown"));\r\n}\r\n}\r\nstatic void\r\ndissect_quake3_client_commands(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree)\r\n{\r\ncall_data_dissector(tvb, pinfo, tree);\r\n}\r\nstatic void\r\ndissect_quake3_server_commands(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree)\r\n{\r\ncall_data_dissector(tvb, pinfo, tree);\r\n}\r\nstatic void\r\ndissect_quake3_GamePacket(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, int *direction)\r\n{\r\nproto_tree *game_tree;\r\nguint32 seq1;\r\nguint32 seq2;\r\nint rel1;\r\nint rel2;\r\nint offset;\r\nguint rest_length;\r\n*direction = (pinfo->destport == gbl_quake3_server_port) ?\r\nDIR_C2S : DIR_S2C;\r\ngame_tree = proto_tree_add_subtree(tree, tvb, 0, -1, ett_quake3_game, NULL, "Game");\r\noffset = 0;\r\nseq1 = tvb_get_letohs(tvb, offset);\r\nrel1 = seq1 & 0x8000 ? 1 : 0;\r\nseq1 &= ~0x8000;\r\nif (game_tree) {\r\nproto_tree *seq1_tree = proto_tree_add_subtree_format(game_tree,\r\ntvb, offset, 2, ett_quake3_game_seq1, NULL, "Current Sequence: %u (%s)",\r\nseq1, val_to_str(rel1,names_reliable,"%u"));\r\nproto_tree_add_uint(seq1_tree, hf_quake3_game_seq1,\r\ntvb, offset, 2, seq1);\r\nproto_tree_add_boolean(seq1_tree, hf_quake3_game_rel1,\r\ntvb, offset+1, 1, rel1);\r\n}\r\noffset += 2;\r\nseq2 = tvb_get_letohs(tvb, offset);\r\nrel2 = seq2 & 0x8000 ? 1 : 0;\r\nseq2 &= ~0x8000;\r\nif (game_tree) {\r\nproto_tree *seq2_tree = proto_tree_add_subtree_format(game_tree,\r\ntvb, offset, 2, ett_quake3_game_seq2, NULL, "Acknowledge Sequence: %u (%s)",\r\nseq2, val_to_str(rel2,names_reliable,"%u"));\r\nproto_tree_add_uint(seq2_tree, hf_quake3_game_seq2,\r\ntvb, offset, 2, seq2);\r\nproto_tree_add_boolean(seq2_tree, hf_quake3_game_rel2,\r\ntvb, offset+1, 1, rel2);\r\n}\r\noffset += 2;\r\nif (*direction == DIR_C2S) {\r\nguint16 qport = tvb_get_letohs(tvb, offset);\r\nif (game_tree) {\r\nproto_tree_add_uint(game_tree, hf_quake3_game_qport,\r\ntvb, offset, 2, qport);\r\n}\r\noffset +=2;\r\n}\r\nrest_length = tvb_reported_length(tvb) - offset;\r\nif (rest_length) {\r\ntvbuff_t *next_tvb = tvb_new_subset_remaining(tvb, offset);\r\nproto_tree *c_tree;\r\nif (*direction == DIR_C2S) {\r\nc_tree = proto_tree_add_subtree(game_tree, next_tvb,\r\n0, -1, ett_quake3_game_clc, NULL, "Client Commands");\r\ndissect_quake3_client_commands(next_tvb, pinfo, c_tree);\r\n}\r\nelse {\r\nc_tree = proto_tree_add_subtree(game_tree, next_tvb,\r\n0, -1, ett_quake3_game_svc, NULL, "Server Commands");\r\ndissect_quake3_server_commands(next_tvb, pinfo, c_tree);\r\n}\r\n}\r\n}\r\nstatic int\r\ndissect_quake3(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *quake3_tree = NULL;\r\nproto_item *dir_item = NULL;\r\nint direction;\r\ndirection = DIR_UNKNOWN;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "QUAKE3");\r\nif (tree) {\r\nproto_item *quake3_item;\r\nquake3_item = proto_tree_add_item(tree, proto_quake3,\r\ntvb, 0, -1, ENC_NA);\r\nquake3_tree = proto_item_add_subtree(quake3_item, ett_quake3);\r\ndir_item = proto_tree_add_none_format(\r\nquake3_tree,\r\nhf_quake3_direction, tvb, 0, 0,\r\n"Direction: %s",\r\nval_to_str(direction,\r\nnames_direction, "%u"));\r\n}\r\nif (tvb_get_ntohl(tvb, 0) == 0xffffffff) {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Connectionless ");\r\nproto_tree_add_uint_format(quake3_tree,\r\nhf_quake3_connectionless,\r\ntvb, 0, 0, 1,\r\n"Type: Connectionless");\r\ndissect_quake3_ConnectionlessPacket(\r\ntvb, pinfo, quake3_tree, &direction);\r\n}\r\nelse {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Game ");\r\nproto_tree_add_uint_format(quake3_tree,\r\nhf_quake3_game,\r\ntvb, 0, 0, 1,\r\n"Type: Game");\r\ndissect_quake3_GamePacket(\r\ntvb, pinfo, quake3_tree, &direction);\r\n}\r\nif (direction != DIR_UNKNOWN && dir_item)\r\nproto_item_set_text(dir_item,\r\n"Direction: %s",\r\nval_to_str(direction,\r\nnames_direction, "%u"));\r\ncol_append_str(pinfo->cinfo, COL_INFO, val_to_str(direction,\r\nnames_direction, "%u"));\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_quake3(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_quake3_direction,\r\n{ "Direction", "quake3.direction",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\n"Packet Direction", HFILL }},\r\n{ &hf_quake3_connectionless,\r\n{ "Connectionless", "quake3.connectionless",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_quake3_game,\r\n{ "Game", "quake3.game",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_quake3_connectionless_marker,\r\n{ "Marker", "quake3.connectionless.marker",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_quake3_connectionless_text,\r\n{ "Text", "quake3.connectionless.text",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_quake3_connectionless_command,\r\n{ "Command", "quake3.connectionless.command",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_quake3_server_addr,\r\n{ "Server Address", "quake3.server.addr",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\n"Server IP Address", HFILL }},\r\n{ &hf_quake3_server_port,\r\n{ "Server Port", "quake3.server.port",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Server UDP Port", HFILL }},\r\n{ &hf_quake3_game_seq1,\r\n{ "Sequence Number", "quake3.game.seq1",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Sequence number of the current packet", HFILL }},\r\n{ &hf_quake3_game_rel1,\r\n{ "Reliable", "quake3.game.rel1",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Packet is reliable and may be retransmitted", HFILL }},\r\n{ &hf_quake3_game_seq2,\r\n{ "Sequence Number", "quake3.game.seq2",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Sequence number of the last received packet", HFILL }},\r\n{ &hf_quake3_game_rel2,\r\n{ "Reliable", "quake3.game.rel2",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Packet was reliable and may be retransmitted", HFILL }},\r\n{ &hf_quake3_game_qport,\r\n{ "QPort", "quake3.game.qport",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Quake III Arena Client Port", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_quake3,\r\n&ett_quake3_connectionless,\r\n&ett_quake3_connectionless_text,\r\n&ett_quake3_server,\r\n&ett_quake3_game,\r\n&ett_quake3_game_seq1,\r\n&ett_quake3_game_seq2,\r\n&ett_quake3_game_clc,\r\n&ett_quake3_game_svc\r\n};\r\nmodule_t *quake3_module;\r\nproto_quake3 = proto_register_protocol("Quake III Arena Network Protocol",\r\n"QUAKE3", "quake3");\r\nproto_register_field_array(proto_quake3, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nquake3_module = prefs_register_protocol(proto_quake3,\r\nproto_reg_handoff_quake3);\r\nprefs_register_uint_preference(quake3_module, "udp.arena_port",\r\n"Quake III Arena Server UDP Base Port",\r\n"Set the UDP base port for the Quake III Arena Server",\r\n10, &gbl_quake3_server_port);\r\nprefs_register_uint_preference(quake3_module, "udp.master_port",\r\n"Quake III Arena Master Server UDP Base Port",\r\n"Set the UDP base port for the Quake III Arena Master Server",\r\n10, &gbl_quake3_master_port);\r\n}\r\nvoid\r\nproto_reg_handoff_quake3(void)\r\n{\r\nstatic gboolean initialized=FALSE;\r\nstatic dissector_handle_t quake3_handle;\r\nstatic guint server_port;\r\nstatic guint master_port;\r\nint i;\r\nif (!initialized) {\r\nquake3_handle = create_dissector_handle(dissect_quake3,\r\nproto_quake3);\r\ninitialized=TRUE;\r\n} else {\r\nfor (i=0;i<4;i++)\r\ndissector_delete_uint("udp.port", server_port+i, quake3_handle);\r\nfor (i=0;i<4;i++)\r\ndissector_delete_uint("udp.port", master_port+i, quake3_handle);\r\n}\r\nserver_port = gbl_quake3_server_port;\r\nmaster_port = gbl_quake3_master_port;\r\nfor (i=0;i<4;i++)\r\ndissector_add_uint("udp.port", gbl_quake3_server_port + i,\r\nquake3_handle);\r\nfor (i=0;i<4;i++)\r\ndissector_add_uint("udp.port", gbl_quake3_master_port + i,\r\nquake3_handle);\r\n}
