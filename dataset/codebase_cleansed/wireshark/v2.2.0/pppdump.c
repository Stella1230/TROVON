static void\r\ninit_state(pppdump_t *state)\r\n{\r\nstate->num_bytes = 0;\r\nstate->pkt = NULL;\r\nstate->spkt.dir = DIRECTION_SENT;\r\nstate->spkt.cnt = 0;\r\nstate->spkt.esc = FALSE;\r\nstate->spkt.id_offset = 0;\r\nstate->spkt.sd_offset = 0;\r\nstate->spkt.cd_offset = 0;\r\nstate->rpkt.dir = DIRECTION_RECV;\r\nstate->rpkt.cnt = 0;\r\nstate->rpkt.esc = FALSE;\r\nstate->rpkt.id_offset = 0;\r\nstate->rpkt.sd_offset = 0;\r\nstate->rpkt.cd_offset = 0;\r\nstate->seek_state = NULL;\r\nstate->offset = 0x100000;\r\n}\r\nwtap_open_return_val\r\npppdump_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nguint8 buffer[6];\r\npppdump_t *state;\r\nif (!wtap_read_bytes(wth->fh, buffer, sizeof(buffer),\r\nerr, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (buffer[0] == PPPD_RESET_TIME &&\r\n(buffer[5] == PPPD_SENT_DATA ||\r\nbuffer[5] == PPPD_RECV_DATA ||\r\nbuffer[5] == PPPD_TIME_STEP_LONG ||\r\nbuffer[5] == PPPD_TIME_STEP_SHORT ||\r\nbuffer[5] == PPPD_RESET_TIME)) {\r\ngoto my_file_type;\r\n}\r\nelse {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nmy_file_type:\r\nif (file_seek(wth->fh, 5, SEEK_SET, err) == -1)\r\nreturn WTAP_OPEN_ERROR;\r\nstate = (pppdump_t *)g_malloc(sizeof(pppdump_t));\r\nwth->priv = (void *)state;\r\nstate->timestamp = pntoh32(&buffer[1]);\r\nstate->tenths = 0;\r\ninit_state(state);\r\nstate->offset = 5;\r\nwth->file_encap = WTAP_ENCAP_PPP_WITH_PHDR;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_PPPDUMP;\r\nwth->snapshot_length = PPPD_BUF_SIZE;\r\nwth->subtype_read = pppdump_read;\r\nwth->subtype_seek_read = pppdump_seek_read;\r\nwth->subtype_close = pppdump_close;\r\nwth->file_tsprec = WTAP_TSPREC_DSEC;\r\nstate->seek_state = g_new(pppdump_t,1);\r\nif (wth->random_fh != NULL)\r\nstate->pids = g_ptr_array_new();\r\nelse\r\nstate->pids = NULL;\r\nstate->pkt_cnt = 0;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic void\r\npppdump_set_phdr(struct wtap_pkthdr *phdr, int num_bytes,\r\ndirection_enum direction)\r\n{\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->len = num_bytes;\r\nphdr->caplen = num_bytes;\r\nphdr->pkt_encap = WTAP_ENCAP_PPP_WITH_PHDR;\r\nphdr->pseudo_header.p2p.sent = (direction == DIRECTION_SENT ? TRUE : FALSE);\r\n}\r\nstatic gboolean\r\npppdump_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\r\n{\r\nint num_bytes;\r\ndirection_enum direction;\r\nguint8 *buf;\r\npppdump_t *state;\r\npkt_id *pid;\r\nstate = (pppdump_t *)wth->priv;\r\nif (wth->random_fh != NULL) {\r\npid = g_new(pkt_id, 1);\r\nif (!pid) {\r\n*err = errno;\r\nreturn FALSE;\r\n}\r\npid->offset = 0;\r\n} else\r\npid = NULL;\r\nws_buffer_assure_space(wth->frame_buffer, PPPD_BUF_SIZE);\r\nbuf = ws_buffer_start_ptr(wth->frame_buffer);\r\nif (!collate(state, wth->fh, err, err_info, buf, &num_bytes, &direction,\r\npid, 0)) {\r\nif (pid != NULL)\r\ng_free(pid);\r\nreturn FALSE;\r\n}\r\nif (pid != NULL)\r\npid->dir = direction;\r\nif (pid != NULL)\r\ng_ptr_array_add(state->pids, pid);\r\n*data_offset = state->pkt_cnt;\r\nstate->pkt_cnt++;\r\npppdump_set_phdr(&wth->phdr, num_bytes, direction);\r\nwth->phdr.presence_flags = WTAP_HAS_TS;\r\nwth->phdr.ts.secs = state->timestamp;\r\nwth->phdr.ts.nsecs = state->tenths * 100000000;\r\nreturn TRUE;\r\n}\r\nstatic int\r\nprocess_data(pppdump_t *state, FILE_T fh, pkt_t *pkt, int n, guint8 *pd,\r\nint *err, gchar **err_info, pkt_id *pid)\r\n{\r\nint c;\r\nint num_bytes = n;\r\nint num_written;\r\nfor (; num_bytes > 0; --num_bytes) {\r\nc = file_getc(fh);\r\nif (c == EOF) {\r\n*err = file_error(fh, err_info);\r\nif (*err == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn -1;\r\n}\r\nstate->offset++;\r\nswitch (c) {\r\ncase 0x7e:\r\nif (pkt->cnt > 0) {\r\npkt->esc = FALSE;\r\nnum_written = pkt->cnt;\r\npkt->cnt = 0;\r\nif (num_written <= 0) {\r\nreturn 0;\r\n}\r\nif (num_written > PPPD_BUF_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("pppdump: File has %u-byte packet, bigger than maximum of %u",\r\nnum_written, PPPD_BUF_SIZE);\r\nreturn -1;\r\n}\r\nmemcpy(pd, pkt->buf, num_written);\r\nif (pid) {\r\npid->offset = pkt->id_offset;\r\npid->num_bytes_to_skip =\r\npkt->sd_offset - pkt->id_offset - 3;\r\ng_assert(pid->num_bytes_to_skip >= 0);\r\n}\r\nnum_bytes--;\r\nif (num_bytes > 0) {\r\npkt->id_offset = pkt->cd_offset;\r\npkt->sd_offset = state->offset;\r\n} else {\r\npkt->id_offset = 0;\r\npkt->sd_offset = 0;\r\n}\r\nstate->num_bytes = num_bytes;\r\nstate->pkt = pkt;\r\nreturn num_written;\r\n}\r\nbreak;\r\ncase 0x7d:\r\nif (!pkt->esc) {\r\npkt->esc = TRUE;\r\nbreak;\r\n}\r\ndefault:\r\nif (pkt->esc) {\r\nc ^= 0x20;\r\npkt->esc = FALSE;\r\n}\r\nif (pkt->cnt >= PPPD_BUF_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("pppdump: File has %u-byte packet, bigger than maximum of %u",\r\npkt->cnt - 1, PPPD_BUF_SIZE);\r\nreturn -1;\r\n}\r\npkt->buf[pkt->cnt++] = c;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic gboolean\r\ncollate(pppdump_t* state, FILE_T fh, int *err, gchar **err_info, guint8 *pd,\r\nint *num_bytes, direction_enum *direction, pkt_id *pid,\r\ngint64 num_bytes_to_skip)\r\n{\r\nint id;\r\npkt_t *pkt = NULL;\r\nint byte0, byte1;\r\nint n, num_written = 0;\r\ngint64 start_offset;\r\nguint32 time_long;\r\nguint8 time_short;\r\nif (state->num_bytes > 0) {\r\ng_assert(num_bytes_to_skip == 0);\r\npkt = state->pkt;\r\nnum_written = process_data(state, fh, pkt, state->num_bytes,\r\npd, err, err_info, pid);\r\nif (num_written < 0) {\r\nreturn FALSE;\r\n}\r\nelse if (num_written > 0) {\r\n*num_bytes = num_written;\r\n*direction = pkt->dir;\r\nreturn TRUE;\r\n}\r\n} else {\r\nif (pid)\r\npid->num_bytes_to_skip = 0;\r\n}\r\nstart_offset = state->offset;\r\nwhile ((id = file_getc(fh)) != EOF) {\r\nstate->offset++;\r\nswitch (id) {\r\ncase PPPD_SENT_DATA:\r\ncase PPPD_RECV_DATA:\r\npkt = id == PPPD_SENT_DATA ? &state->spkt : &state->rpkt;\r\npkt->cd_offset = state->offset - 1;\r\nbyte0 = file_getc(fh);\r\nif (byte0 == EOF)\r\ngoto done;\r\nstate->offset++;\r\nbyte1 = file_getc(fh);\r\nif (byte1 == EOF)\r\ngoto done;\r\nstate->offset++;\r\nn = (byte0 << 8) | byte1;\r\nif (pkt->id_offset == 0) {\r\npkt->id_offset = pkt->cd_offset;\r\npkt->sd_offset = state->offset;\r\n}\r\nif (n == 0)\r\ncontinue;\r\ng_assert(num_bytes_to_skip < n);\r\nwhile (num_bytes_to_skip) {\r\nif (file_getc(fh) == EOF)\r\ngoto done;\r\nstate->offset++;\r\nnum_bytes_to_skip--;\r\nn--;\r\n}\r\nnum_written = process_data(state, fh, pkt, n,\r\npd, err, err_info, pid);\r\nif (num_written < 0) {\r\nreturn FALSE;\r\n}\r\nelse if (num_written > 0) {\r\n*num_bytes = num_written;\r\n*direction = pkt->dir;\r\nreturn TRUE;\r\n}\r\nbreak;\r\ncase PPPD_SEND_DELIM:\r\ncase PPPD_RECV_DELIM:\r\nbreak;\r\ncase PPPD_RESET_TIME:\r\nif (!wtap_read_bytes(fh, &time_long, sizeof(guint32), err, err_info))\r\nreturn FALSE;\r\nstate->offset += sizeof(guint32);\r\nstate->timestamp = pntoh32(&time_long);\r\nstate->tenths = 0;\r\nbreak;\r\ncase PPPD_TIME_STEP_LONG:\r\nif (!wtap_read_bytes(fh, &time_long, sizeof(guint32), err, err_info))\r\nreturn FALSE;\r\nstate->offset += sizeof(guint32);\r\nstate->tenths += pntoh32(&time_long);\r\nif (state->tenths >= 10) {\r\nstate->timestamp += state->tenths / 10;\r\nstate->tenths = state->tenths % 10;\r\n}\r\nbreak;\r\ncase PPPD_TIME_STEP_SHORT:\r\nif (!wtap_read_bytes(fh, &time_short, sizeof(guint8), err, err_info))\r\nreturn FALSE;\r\nstate->offset += sizeof(guint8);\r\nstate->tenths += time_short;\r\nif (state->tenths >= 10) {\r\nstate->timestamp += state->tenths / 10;\r\nstate->tenths = state->tenths % 10;\r\n}\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("pppdump: bad ID byte 0x%02x", id);\r\nreturn FALSE;\r\n}\r\n}\r\ndone:\r\n*err = file_error(fh, err_info);\r\nif (*err == 0) {\r\nif (state->offset != start_offset) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\npppdump_seek_read(wtap *wth,\r\ngint64 seek_off,\r\nstruct wtap_pkthdr *phdr,\r\nBuffer *buf,\r\nint *err,\r\ngchar **err_info)\r\n{\r\nint num_bytes;\r\nguint8 *pd;\r\ndirection_enum direction;\r\npppdump_t *state;\r\npkt_id *pid;\r\ngint64 num_bytes_to_skip;\r\nstate = (pppdump_t *)wth->priv;\r\npid = (pkt_id *)g_ptr_array_index(state->pids, seek_off);\r\nif (!pid) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("pppdump: PID not found for record");\r\nreturn FALSE;\r\n}\r\nif (file_seek(wth->random_fh, pid->offset, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\ninit_state(state->seek_state);\r\nstate->seek_state->offset = pid->offset;\r\nws_buffer_assure_space(buf, PPPD_BUF_SIZE);\r\npd = ws_buffer_start_ptr(buf);\r\nnum_bytes_to_skip = pid->num_bytes_to_skip;\r\ndo {\r\nif (!collate(state->seek_state, wth->random_fh, err, err_info,\r\npd, &num_bytes, &direction, NULL, num_bytes_to_skip))\r\nreturn FALSE;\r\nnum_bytes_to_skip = 0;\r\n} while (direction != pid->dir);\r\npppdump_set_phdr(phdr, num_bytes, pid->dir);\r\nreturn TRUE;\r\n}\r\nstatic void\r\npppdump_close(wtap *wth)\r\n{\r\npppdump_t *state;\r\nstate = (pppdump_t *)wth->priv;\r\nif (state->seek_state) {\r\ng_free(state->seek_state);\r\n}\r\nif (state->pids) {\r\nunsigned int i;\r\nfor (i = 0; i < g_ptr_array_len(state->pids); i++) {\r\ng_free(g_ptr_array_index(state->pids, i));\r\n}\r\ng_ptr_array_free(state->pids, TRUE);\r\n}\r\n}
