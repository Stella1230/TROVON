static lbtru_transport_t * lbtru_transport_find(const address * source_address, guint16 source_port, guint32 session_id, guint32 frame)\r\n{\r\nlbtru_transport_t * entry = NULL;\r\nwmem_tree_t * session_tree = NULL;\r\nconversation_t * conv = NULL;\r\nconv = find_conversation(frame, source_address, &lbtru_null_address, PT_UDP, source_port, 0, 0);\r\nif (conv != NULL)\r\n{\r\nif (frame != 0)\r\n{\r\nif (conv->setup_frame == 0)\r\n{\r\nconv->setup_frame = frame;\r\n}\r\nif (frame > conv->last_frame)\r\n{\r\nconv->last_frame = frame;\r\n}\r\n}\r\nsession_tree = (wmem_tree_t *) conversation_get_proto_data(conv, proto_lbtru);\r\nif (session_tree != NULL)\r\n{\r\nentry = (lbtru_transport_t *) wmem_tree_lookup32(session_tree, session_id);\r\n}\r\n}\r\nreturn (entry);\r\n}\r\nlbtru_transport_t * lbtru_transport_add(const address * source_address, guint16 source_port, guint32 session_id, guint32 frame)\r\n{\r\nlbtru_transport_t * entry = NULL;\r\nwmem_tree_t * session_tree = NULL;\r\nconversation_t * conv = NULL;\r\nconv = find_conversation(frame, source_address, &lbtru_null_address, PT_UDP, source_port, 0, 0);\r\nif (conv == NULL)\r\n{\r\nconv = conversation_new(frame, source_address, &lbtru_null_address, PT_UDP, source_port, 0, 0);\r\n}\r\nif (frame != 0)\r\n{\r\nif (conv->setup_frame == 0)\r\n{\r\nconv->setup_frame = frame;\r\n}\r\nif (frame > conv->last_frame)\r\n{\r\nconv->last_frame = frame;\r\n}\r\n}\r\nsession_tree = (wmem_tree_t *) conversation_get_proto_data(conv, proto_lbtru);\r\nif (session_tree == NULL)\r\n{\r\nsession_tree = wmem_tree_new(wmem_file_scope());\r\nconversation_add_proto_data(conv, proto_lbtru, (void *)session_tree);\r\n}\r\nentry = (lbtru_transport_t *) wmem_tree_lookup32(session_tree, session_id);\r\nif (entry != NULL)\r\n{\r\nreturn (entry);\r\n}\r\nentry = wmem_new(wmem_file_scope(), lbtru_transport_t);\r\ncopy_address_wmem(wmem_file_scope(), &(entry->source_address), source_address);\r\nentry->source_port = source_port;\r\nentry->session_id = session_id;\r\nentry->channel = lbm_channel_assign(LBM_CHANNEL_TRANSPORT_LBTRU);\r\nentry->next_client_id = 1;\r\nentry->client_list = wmem_list_new(wmem_file_scope());\r\nwmem_tree_insert32(session_tree, session_id, (void *) entry);\r\nreturn (entry);\r\n}\r\nstatic lbtru_client_transport_t * lbtru_client_transport_find(lbtru_transport_t * transport, const address * receiver_address, guint16 receiver_port, guint32 frame)\r\n{\r\nlbtru_client_transport_t * entry = NULL;\r\nconversation_t * client_conv = NULL;\r\nif (transport == NULL)\r\n{\r\nreturn (NULL);\r\n}\r\nclient_conv = find_conversation(frame, &(transport->source_address), receiver_address, PT_UDP, transport->source_port, receiver_port, 0);\r\nif (client_conv != NULL)\r\n{\r\nwmem_tree_t * session_tree = NULL;\r\nsession_tree = (wmem_tree_t *) conversation_get_proto_data(client_conv, proto_lbtru);\r\nif (session_tree != NULL)\r\n{\r\nentry = (lbtru_client_transport_t *) wmem_tree_lookup32(session_tree, transport->session_id);\r\n}\r\n}\r\nreturn (entry);\r\n}\r\nstatic lbtru_client_transport_t * lbtru_client_transport_add(lbtru_transport_t * transport, const address * receiver_address, guint16 receiver_port, guint32 frame)\r\n{\r\nlbtru_client_transport_t * entry = NULL;\r\nconversation_t * client_conv = NULL;\r\nwmem_tree_t * session_tree = NULL;\r\nif (transport == NULL)\r\n{\r\nreturn (NULL);\r\n}\r\nentry = lbtru_client_transport_find(transport, receiver_address, receiver_port, frame);\r\nif (entry != NULL)\r\n{\r\nreturn (entry);\r\n}\r\nentry = wmem_new0(wmem_file_scope(), lbtru_client_transport_t);\r\ncopy_address_wmem(wmem_file_scope(), &(entry->receiver_address), receiver_address);\r\nentry->receiver_port = receiver_port;\r\nentry->transport = transport;\r\nentry->id = transport->next_client_id++;\r\nentry->frame = wmem_tree_new(wmem_file_scope());\r\nentry->last_frame = NULL;\r\nentry->last_data_frame = NULL;\r\nentry->last_sm_frame = NULL;\r\nentry->last_nak_frame = NULL;\r\nentry->last_ncf_frame = NULL;\r\nentry->last_ack_frame = NULL;\r\nentry->last_creq_frame = NULL;\r\nentry->last_rst_frame = NULL;\r\nentry->data_sqn = wmem_tree_new(wmem_file_scope());\r\nentry->sm_sqn = wmem_tree_new(wmem_file_scope());\r\nentry->data_high_sqn = 0;\r\nentry->sm_high_sqn = 0;\r\nclient_conv = find_conversation(frame, &(transport->source_address), receiver_address, PT_UDP, transport->source_port, receiver_port, 0);\r\nif (client_conv == NULL)\r\n{\r\nclient_conv = conversation_new(frame, &(transport->source_address), receiver_address, PT_UDP, transport->source_port, receiver_port, 0);\r\nsession_tree = wmem_tree_new(wmem_file_scope());\r\nconversation_add_proto_data(client_conv, proto_lbtru, (void *) session_tree);\r\n}\r\nelse\r\n{\r\nsession_tree = (wmem_tree_t *) conversation_get_proto_data(client_conv, proto_lbtru);\r\nif (session_tree == NULL)\r\n{\r\nsession_tree = wmem_tree_new(wmem_file_scope());\r\nconversation_add_proto_data(client_conv, proto_lbtru, (void *) session_tree);\r\n}\r\n}\r\nwmem_tree_insert32(session_tree, transport->session_id, (void *) entry);\r\nwmem_list_append(transport->client_list, (void *) entry);\r\nreturn (entry);\r\n}\r\nstatic lbm_transport_sqn_t * lbtru_client_transport_sqn_find(lbtru_client_transport_t * client, guint8 type, guint32 sqn)\r\n{\r\nlbm_transport_sqn_t * sqn_entry = NULL;\r\nswitch (type)\r\n{\r\ncase LBTRU_PACKET_TYPE_DATA:\r\nsqn_entry = (lbm_transport_sqn_t *) wmem_tree_lookup32(client->data_sqn, sqn);\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_SM:\r\nsqn_entry = (lbm_transport_sqn_t *) wmem_tree_lookup32(client->sm_sqn, sqn);\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_NAK:\r\ncase LBTRU_PACKET_TYPE_NCF:\r\ncase LBTRU_PACKET_TYPE_ACK:\r\ncase LBTRU_PACKET_TYPE_CREQ:\r\ncase LBTRU_PACKET_TYPE_RST:\r\ndefault:\r\nsqn_entry = NULL;\r\nbreak;\r\n}\r\nreturn (sqn_entry);\r\n}\r\nstatic lbm_transport_sqn_t * lbtru_client_transport_sqn_add(lbtru_client_transport_t * client, lbm_transport_frame_t * frame)\r\n{\r\nwmem_tree_t * sqn_list = NULL;\r\nlbm_transport_sqn_t * sqn_entry = NULL;\r\nswitch (frame->type)\r\n{\r\ncase LBTRU_PACKET_TYPE_DATA:\r\nsqn_list = client->data_sqn;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_SM:\r\nsqn_list = client->sm_sqn;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_NAK:\r\ncase LBTRU_PACKET_TYPE_NCF:\r\ncase LBTRU_PACKET_TYPE_ACK:\r\ncase LBTRU_PACKET_TYPE_CREQ:\r\ncase LBTRU_PACKET_TYPE_RST:\r\ndefault:\r\nreturn (NULL);\r\nbreak;\r\n}\r\nsqn_entry = lbm_transport_sqn_add(sqn_list, frame);\r\nreturn (sqn_entry);\r\n}\r\nstatic lbm_transport_frame_t * lbtru_client_transport_frame_find(lbtru_client_transport_t * client, guint32 frame)\r\n{\r\nreturn ((lbm_transport_frame_t *) wmem_tree_lookup32(client->frame, frame));\r\n}\r\nstatic lbm_transport_frame_t * lbtru_client_transport_frame_add(lbtru_client_transport_t * client, guint8 type, guint32 frame, guint32 sqn, gboolean retransmission)\r\n{\r\nlbm_transport_sqn_t * dup_sqn_entry = NULL;\r\nlbm_transport_frame_t * frame_entry = NULL;\r\nframe_entry = lbtru_client_transport_frame_find(client, frame);\r\nif (frame_entry != NULL)\r\n{\r\nreturn (frame_entry);\r\n}\r\nframe_entry = lbm_transport_frame_add(client->frame, type, frame, sqn, retransmission);\r\nif (client->last_frame != NULL)\r\n{\r\nframe_entry->previous_frame = client->last_frame->frame;\r\nclient->last_frame->next_frame = frame;\r\n}\r\nclient->last_frame = frame_entry;\r\nswitch (type)\r\n{\r\ncase LBTRU_PACKET_TYPE_DATA:\r\nif (client->last_data_frame != NULL)\r\n{\r\nframe_entry->previous_type_frame = client->last_data_frame->frame;\r\nclient->last_data_frame->next_type_frame = frame;\r\nif (frame_entry->sqn <= client->data_high_sqn)\r\n{\r\ndup_sqn_entry = lbtru_client_transport_sqn_find(client, type, frame_entry->sqn);\r\nif (!frame_entry->retransmission)\r\n{\r\nif (dup_sqn_entry != NULL)\r\n{\r\nframe_entry->duplicate = TRUE;\r\n}\r\nif (frame_entry->sqn != client->data_high_sqn)\r\n{\r\nframe_entry->ooo_gap = client->data_high_sqn - frame_entry->sqn;\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nif (!frame_entry->retransmission)\r\n{\r\nif (frame_entry->sqn != (client->data_high_sqn + 1))\r\n{\r\nframe_entry->sqn_gap = frame_entry->sqn - (client->last_data_frame->sqn + 1);\r\n}\r\n}\r\n}\r\n}\r\nif ((frame_entry->sqn > client->data_high_sqn) && !frame_entry->retransmission)\r\n{\r\nclient->data_high_sqn = frame_entry->sqn;\r\n}\r\nclient->last_data_frame = frame_entry;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_SM:\r\nif (client->last_sm_frame != NULL)\r\n{\r\nframe_entry->previous_type_frame = client->last_sm_frame->frame;\r\nclient->last_sm_frame->next_type_frame = frame;\r\nif (frame_entry->sqn <= client->sm_high_sqn)\r\n{\r\ndup_sqn_entry = lbtru_client_transport_sqn_find(client, type, frame_entry->sqn);\r\nif (dup_sqn_entry != NULL)\r\n{\r\nframe_entry->duplicate = TRUE;\r\n}\r\nif (frame_entry->sqn != client->sm_high_sqn)\r\n{\r\nframe_entry->ooo_gap = client->sm_high_sqn - frame_entry->sqn;\r\n}\r\n}\r\nelse\r\n{\r\nif (frame_entry->sqn != (client->sm_high_sqn + 1))\r\n{\r\nframe_entry->sqn_gap = frame_entry->sqn - (client->sm_high_sqn + 1);\r\n}\r\n}\r\n}\r\nif (frame_entry->sqn > client->sm_high_sqn)\r\n{\r\nclient->sm_high_sqn = frame_entry->sqn;\r\n}\r\nclient->last_sm_frame = frame_entry;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_NAK:\r\nif (client->last_nak_frame != NULL)\r\n{\r\nframe_entry->previous_type_frame = client->last_nak_frame->frame;\r\nclient->last_nak_frame->next_type_frame = frame;\r\n}\r\nclient->last_nak_frame = frame_entry;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_NCF:\r\nif (client->last_ncf_frame != NULL)\r\n{\r\nframe_entry->previous_type_frame = client->last_ncf_frame->frame;\r\nclient->last_ncf_frame->next_type_frame = frame;\r\n}\r\nclient->last_ncf_frame = frame_entry;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_ACK:\r\nif (client->last_ack_frame != NULL)\r\n{\r\nframe_entry->previous_type_frame = client->last_ack_frame->frame;\r\nclient->last_ack_frame->next_type_frame = frame;\r\n}\r\nclient->last_ack_frame = frame_entry;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_CREQ:\r\nif (client->last_creq_frame != NULL)\r\n{\r\nframe_entry->previous_type_frame = client->last_creq_frame->frame;\r\nclient->last_creq_frame->next_type_frame = frame;\r\n}\r\nclient->last_creq_frame = frame_entry;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_RST:\r\nif (client->last_rst_frame != NULL)\r\n{\r\nframe_entry->previous_type_frame = client->last_rst_frame->frame;\r\nclient->last_rst_frame->next_type_frame = frame;\r\n}\r\nclient->last_rst_frame = frame_entry;\r\nbreak;\r\n}\r\n(void)lbtru_client_transport_sqn_add(client, frame_entry);\r\nreturn (frame_entry);\r\n}\r\nstatic char * lbtru_transport_source_string_format(const address * source_address, guint16 source_port, guint32 session_id)\r\n{\r\nchar * bufptr = NULL;\r\nif (session_id == 0)\r\n{\r\nbufptr = wmem_strdup_printf(wmem_packet_scope(), "LBT-RU:%s:%" G_GUINT16_FORMAT, address_to_str(wmem_packet_scope(), source_address), source_port);\r\n}\r\nelse\r\n{\r\nbufptr = wmem_strdup_printf(wmem_packet_scope(), "LBT-RU:%s:%" G_GUINT16_FORMAT ":%08x", address_to_str(wmem_packet_scope(), source_address), source_port, session_id);\r\n}\r\nreturn (bufptr);\r\n}\r\nchar * lbtru_transport_source_string(const address * source_address, guint16 source_port, guint32 session_id)\r\n{\r\nreturn (wmem_strdup(wmem_file_scope(), lbtru_transport_source_string_format(source_address, source_port, session_id)));\r\n}\r\nstatic char * lbtru_transport_source_string_transport(lbtru_transport_t * transport)\r\n{\r\nreturn (lbtru_transport_source_string(&(transport->source_address), transport->source_port, transport->session_id));\r\n}\r\nstatic gboolean lbtru_tag_update_cb(void * record, char * * error_string)\r\n{\r\nlbtru_tag_entry_t * tag = (lbtru_tag_entry_t *)record;\r\nif (tag->name == NULL)\r\n{\r\n*error_string = g_strdup("Tag name can't be empty");\r\nreturn FALSE;\r\n}\r\nelse\r\n{\r\ng_strstrip(tag->name);\r\nif (tag->name[0] == 0)\r\n{\r\n*error_string = g_strdup("Tag name can't be empty");\r\nreturn FALSE;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic void * lbtru_tag_copy_cb(void * destination, const void * source, size_t length _U_)\r\n{\r\nconst lbtru_tag_entry_t * src = (const lbtru_tag_entry_t *)source;\r\nlbtru_tag_entry_t * dest = (lbtru_tag_entry_t *)destination;\r\ndest->name = g_strdup(src->name);\r\ndest->source_port_low = src->source_port_low;\r\ndest->source_port_high = src->source_port_high;\r\ndest->receiver_port_low = src->receiver_port_low;\r\ndest->receiver_port_high = src->receiver_port_high;\r\nreturn (dest);\r\n}\r\nstatic void lbtru_tag_free_cb(void * record)\r\n{\r\nlbtru_tag_entry_t * tag = (lbtru_tag_entry_t *)record;\r\nif (tag->name != NULL)\r\n{\r\ng_free(tag->name);\r\ntag->name = NULL;\r\n}\r\n}\r\nstatic char * lbtru_tag_find(packet_info * pinfo)\r\n{\r\nguint idx;\r\nlbtru_tag_entry_t * tag = NULL;\r\nif (!lbtru_use_tag)\r\n{\r\nreturn (NULL);\r\n}\r\nfor (idx = 0; idx < lbtru_tag_count; ++idx)\r\n{\r\ntag = &(lbtru_tag_entry[idx]);\r\nif (((pinfo->destport >= tag->source_port_low)\r\n&& (pinfo->destport <= tag->source_port_high)\r\n&& (pinfo->srcport >= tag->receiver_port_low)\r\n&& (pinfo->srcport <= tag->receiver_port_high))\r\n|| ((pinfo->destport >= tag->receiver_port_low)\r\n&& (pinfo->destport <= tag->receiver_port_high)\r\n&& (pinfo->srcport >= tag->source_port_low)\r\n&& (pinfo->srcport <= tag->source_port_high)))\r\n{\r\nreturn tag->name;\r\n}\r\n}\r\nreturn (NULL);\r\n}\r\nstatic int dissect_lbtru_data_contents(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, const char * tag_name, guint64 channel)\r\n{\r\ntvbuff_t * next_tvb;\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nreturn (lbmc_dissect_lbmc_packet(next_tvb, 0, pinfo, tree, tag_name, channel));\r\n}\r\nstatic int dissect_lbtru_ack(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, lbm_lbtru_tap_info_t * tap_info)\r\n{\r\nproto_tree * ack_tree = NULL;\r\nproto_item * ack_item = NULL;\r\nproto_item * ack = NULL;\r\nack_item = proto_tree_add_item(tree, hf_lbtru_ack, tvb, offset, L_LBTRU_ACK_HDR_T, ENC_NA);\r\nack_tree = proto_item_add_subtree(ack_item, ett_lbtru_ack);\r\nack = proto_tree_add_item(ack_tree, hf_lbtru_ack_sqn, tvb, offset + O_LBTRU_ACK_HDR_T_ACK_SQN, L_LBTRU_ACK_HDR_T_ACK_SQN, ENC_BIG_ENDIAN);\r\nexpert_add_info(pinfo, ack, &ei_lbtru_analysis_ack);\r\ntap_info->sqn = tvb_get_ntohl(tvb, offset + O_LBTRU_ACK_HDR_T_ACK_SQN);\r\nreturn (L_LBTRU_ACK_HDR_T);\r\n}\r\nstatic int dissect_lbtru_ncf_list(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, int ncf_count, int reason, lbm_lbtru_tap_info_t * tap_info)\r\n{\r\nproto_tree * ncf_tree = NULL;\r\nproto_item * ncf_item = NULL;\r\nlbm_uint32_t ncf;\r\nint idx = 0;\r\nint len = 0;\r\nncf_item = proto_tree_add_item(tree, hf_lbtru_ncf_list, tvb, offset, -1, ENC_NA);\r\nncf_tree = proto_item_add_subtree(ncf_item, ett_lbtru_ncf_list);\r\nfor (idx = 0; idx < ncf_count; idx++)\r\n{\r\nproto_item * sep_ncf_item = NULL;\r\nncf = tvb_get_ntohl(tvb, offset + len);\r\nsep_ncf_item = proto_tree_add_item(ncf_tree, hf_lbtru_ncf_list_ncf, tvb, offset + len, sizeof(lbm_uint32_t), ENC_BIG_ENDIAN);\r\nif (lbtru_expert_separate_ncfs)\r\n{\r\nexpert_add_info_format(pinfo, sep_ncf_item, &ei_lbtru_analysis_ncf_ncf, "NCF 0x%08x %s", ncf, val_to_str(reason, lbtru_ncf_reason, "Unknown (0x%02x)"));\r\n}\r\ntap_info->sqns[idx] = ncf;\r\nlen += (int)sizeof(lbm_uint32_t);\r\n}\r\nproto_item_set_len(ncf_item, len);\r\nreturn (len);\r\n}\r\nstatic int dissect_lbtru_ncf(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, lbm_lbtru_tap_info_t * tap_info)\r\n{\r\nint len_dissected;\r\nguint8 reason_format;\r\nproto_tree * ncf_tree = NULL;\r\nproto_item * ncf_item = NULL;\r\nguint16 num_ncfs = 0;\r\nncf_item = proto_tree_add_item(tree, hf_lbtru_ncf, tvb, offset, -1, ENC_NA);\r\nncf_tree = proto_item_add_subtree(ncf_item, ett_lbtru_ncf);\r\nreason_format = tvb_get_guint8(tvb, offset + O_LBTRU_NCF_HDR_T_REASON_FORMAT);\r\nnum_ncfs = tvb_get_ntohs(tvb, offset + O_LBTRU_NCF_HDR_T_NUM_NCFS);\r\nproto_tree_add_item(ncf_tree, hf_lbtru_ncf_trail_sqn, tvb, offset + O_LBTRU_NCF_HDR_T_TRAIL_SQN, L_LBTRU_NCF_HDR_T_TRAIL_SQN, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ncf_tree, hf_lbtru_ncf_num, tvb, offset + O_LBTRU_NCF_HDR_T_NUM_NCFS, L_LBTRU_NCF_HDR_T_NUM_NCFS, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ncf_tree, hf_lbtru_ncf_reserved, tvb, offset + O_LBTRU_NCF_HDR_T_RESERVED, L_LBTRU_NCF_HDR_T_RESERVED, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ncf_tree, hf_lbtru_ncf_reason, tvb, offset + O_LBTRU_NCF_HDR_T_REASON_FORMAT, L_LBTRU_NCF_HDR_T_REASON_FORMAT, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ncf_tree, hf_lbtru_ncf_format, tvb, offset + O_LBTRU_NCF_HDR_T_REASON_FORMAT, L_LBTRU_NCF_HDR_T_REASON_FORMAT, ENC_BIG_ENDIAN);\r\nlen_dissected = L_LBTRU_NCF_HDR_T;\r\nif (!lbtru_expert_separate_ncfs)\r\n{\r\nexpert_add_info_format(pinfo, ncf_item, &ei_lbtru_analysis_ncf, "NCF %s", val_to_str(LBTRU_NCF_HDR_REASON(reason_format), lbtru_ncf_reason, "Unknown (0x%02x)"));\r\n}\r\ntap_info->ncf_reason = LBTRU_NCF_HDR_REASON(reason_format);;\r\ntap_info->num_sqns = num_ncfs;\r\ntap_info->sqns = wmem_alloc_array(wmem_packet_scope(), guint32, num_ncfs);\r\nlen_dissected += dissect_lbtru_ncf_list(tvb, offset + L_LBTRU_NCF_HDR_T, pinfo, ncf_tree, num_ncfs, LBTRU_NCF_HDR_REASON(reason_format), tap_info);\r\nproto_item_set_len(ncf_item, len_dissected);\r\nreturn (len_dissected);\r\n}\r\nstatic int dissect_lbtru_nak_list(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, int nak_count, lbm_lbtru_tap_info_t * tap_info)\r\n{\r\nproto_tree * nak_tree = NULL;\r\nproto_item * nak_item = NULL;\r\nint idx = 0;\r\nint len = 0;\r\nnak_item = proto_tree_add_item(tree, hf_lbtru_nak_list, tvb, offset, -1, ENC_NA);\r\nnak_tree = proto_item_add_subtree(nak_item, ett_lbtru_nak_list);\r\nfor (idx = 0; idx < nak_count; idx++)\r\n{\r\nproto_item * sep_nak_item = NULL;\r\nlbm_uint32_t nak;\r\nnak = tvb_get_ntohl(tvb, offset + len);\r\nsep_nak_item = proto_tree_add_item(nak_tree, hf_lbtru_nak_list_nak, tvb, offset + len, sizeof(lbm_uint32_t), ENC_BIG_ENDIAN);\r\nif (lbtru_expert_separate_naks)\r\n{\r\nexpert_add_info_format(pinfo, sep_nak_item, &ei_lbtru_analysis_nak_nak, "NAK 0x%08x", nak);\r\n}\r\ntap_info->sqns[idx] = nak;\r\nlen += (int)sizeof(lbm_uint32_t);\r\n}\r\nproto_item_set_len(nak_item, len);\r\nreturn (len);\r\n}\r\nstatic int dissect_lbtru_nak(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, lbm_lbtru_tap_info_t * tap_info)\r\n{\r\nint len_dissected;\r\nproto_tree * nak_tree = NULL;\r\nproto_item * nak_item = NULL;\r\nguint16 num_naks = 0;\r\nnak_item = proto_tree_add_item(tree, hf_lbtru_nak, tvb, offset, -1, ENC_NA);\r\nnak_tree = proto_item_add_subtree(nak_item, ett_lbtru_nak);\r\nnum_naks = tvb_get_ntohs(tvb, offset + O_LBTRU_NAK_HDR_T_NUM_NAKS);\r\nproto_tree_add_item(nak_tree, hf_lbtru_nak_num, tvb, offset + O_LBTRU_NAK_HDR_T_NUM_NAKS, L_LBTRU_NAK_HDR_T_NUM_NAKS, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(nak_tree, hf_lbtru_nak_format, tvb, offset + O_LBTRU_NAK_HDR_T_FORMAT, L_LBTRU_NAK_HDR_T_FORMAT, ENC_BIG_ENDIAN);\r\nlen_dissected = L_LBTRU_NAK_HDR_T;\r\nif (!lbtru_expert_separate_naks)\r\n{\r\nexpert_add_info(pinfo, nak_item, &ei_lbtru_analysis_nak);\r\n}\r\ntap_info->num_sqns = num_naks;\r\ntap_info->sqns = wmem_alloc_array(wmem_packet_scope(), guint32, num_naks);\r\nlen_dissected += dissect_lbtru_nak_list(tvb, offset + L_LBTRU_NAK_HDR_T, pinfo, nak_tree, num_naks, tap_info);\r\nproto_item_set_len(nak_item, len_dissected);\r\nreturn (len_dissected);\r\n}\r\nstatic int dissect_lbtru_sm(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree, int syn, lbm_lbtru_tap_info_t * tap_info)\r\n{\r\nproto_tree * sm_tree = NULL;\r\nproto_item * sm_item = NULL;\r\nproto_item * sm_sqn = NULL;\r\nsm_item = proto_tree_add_item(tree, hf_lbtru_sm, tvb, offset, L_LBTRU_SM_HDR_T, ENC_NA);\r\nsm_tree = proto_item_add_subtree(sm_item, ett_lbtru_sm);\r\nsm_sqn = proto_tree_add_item(sm_tree, hf_lbtru_sm_sqn, tvb, offset + O_LBTRU_SM_HDR_T_SM_SQN, L_LBTRU_SM_HDR_T_SM_SQN, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sm_tree, hf_lbtru_sm_lead_sqn, tvb, offset + O_LBTRU_SM_HDR_T_LEAD_SQN, L_LBTRU_SM_HDR_T_LEAD_SQN, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sm_tree, hf_lbtru_sm_trail_sqn, tvb, offset + O_LBTRU_SM_HDR_T_TRAIL_SQN, L_LBTRU_SM_HDR_T_TRAIL_SQN, ENC_BIG_ENDIAN);\r\nif (syn)\r\n{\r\nexpert_add_info(pinfo, sm_sqn, &ei_lbtru_analysis_sm_syn);\r\n}\r\nelse\r\n{\r\nexpert_add_info(pinfo, sm_sqn, &ei_lbtru_analysis_sm);\r\n}\r\ntap_info->sqn = tvb_get_ntohl(tvb, offset + O_LBTRU_SM_HDR_T_SM_SQN);\r\nreturn (L_LBTRU_SM_HDR_T);\r\n}\r\nstatic int dissect_lbtru_data(tvbuff_t * tvb, int offset, packet_info * pinfo _U_, proto_tree * tree, lbm_lbtru_tap_info_t * tap_info)\r\n{\r\nproto_tree * data_tree = NULL;\r\nproto_item * data_item = NULL;\r\ndata_item = proto_tree_add_item(tree, hf_lbtru_data, tvb, offset, L_LBTRU_DATA_HDR_T, ENC_NA);\r\ndata_tree = proto_item_add_subtree(data_item, ett_lbtru_data);\r\nproto_tree_add_item(data_tree, hf_lbtru_data_sqn, tvb, offset + O_LBTRU_DATA_HDR_T_SQN, L_LBTRU_DATA_HDR_T_SQN, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(data_tree, hf_lbtru_data_trail_sqn, tvb, offset + O_LBTRU_DATA_HDR_T_TRAIL_SQN, L_LBTRU_DATA_HDR_T_TRAIL_SQN, ENC_BIG_ENDIAN);\r\ntap_info->sqn = tvb_get_ntohl(tvb, offset + O_LBTRU_DATA_HDR_T_SQN);\r\nreturn (L_LBTRU_DATA_HDR_T);\r\n}\r\nstatic gboolean dissect_lbtru_sqn_frame_list_callback(const void *key _U_, void * frame, void * user_data)\r\n{\r\nlbtru_sqn_frame_list_callback_data_t * cb_data = (lbtru_sqn_frame_list_callback_data_t *) user_data;\r\nproto_item * transport_item = NULL;\r\nlbm_transport_sqn_frame_t * sqn_frame = (lbm_transport_sqn_frame_t *) frame;\r\nif (sqn_frame->frame != cb_data->current_frame)\r\n{\r\nif (sqn_frame->retransmission)\r\n{\r\ntransport_item = proto_tree_add_uint_format_value(cb_data->tree, hf_lbtru_analysis_sqn_frame, cb_data->tvb, 0, 0, sqn_frame->frame, "%" G_GUINT32_FORMAT " (RX)", sqn_frame->frame);\r\n}\r\nelse\r\n{\r\ntransport_item = proto_tree_add_uint(cb_data->tree, hf_lbtru_analysis_sqn_frame, cb_data->tvb, 0, 0, sqn_frame->frame);\r\n}\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nreturn (FALSE);\r\n}\r\nstatic int dissect_lbtru(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * user_data _U_)\r\n{\r\nproto_tree * lbtru_tree = NULL;\r\nproto_item * lbtru_item = NULL;\r\nstatic const int * flags_data[] =\r\n{\r\n&hf_lbtru_hdr_flags_rx,\r\nNULL\r\n};\r\nstatic const int * flags_sm[] =\r\n{\r\n&hf_lbtru_hdr_flags_syn,\r\nNULL\r\n};\r\nint ofs = 0;\r\nguint32 session_id = 0;\r\nchar * tag_name = NULL;\r\nint dissected_len;\r\nint total_dissected_len = 0;\r\nproto_tree * header_tree = NULL;\r\nproto_item * header_item = NULL;\r\nproto_tree * transport_tree = NULL;\r\nproto_item * transport_item = NULL;\r\ngboolean from_source = TRUE;\r\nguint8 packet_type = 0;\r\naddress source_address;\r\naddress receiver_address;\r\nguint16 source_port = 0;\r\nguint16 receiver_port = 0;\r\nlbtru_transport_t * transport = NULL;\r\nlbtru_client_transport_t * client = NULL;\r\nguint64 channel = LBM_CHANNEL_NO_CHANNEL;\r\nproto_tree * channel_tree = NULL;\r\nproto_item * channel_item = NULL;\r\nguint8 ver_type = 0;\r\nguint8 next_hdr = 0;\r\nguint32 packet_sqn = 0;\r\nguint16 flags_or_res = 0;\r\nguint16 num_naks = 0;\r\nguint16 num_ncfs = 0;\r\ngboolean retransmission = FALSE;\r\nproto_item * fld_item = NULL;\r\nproto_item * ei_item = NULL;\r\nproto_item * type_item = NULL;\r\nproto_item * next_hdr_item = NULL;\r\nlbm_lbtru_tap_info_t * tapinfo = NULL;\r\ncol_add_str(pinfo->cinfo, COL_PROTOCOL, "LBT-RU");\r\nif (lbtru_use_tag)\r\n{\r\ntag_name = lbtru_tag_find(pinfo);\r\n}\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (tag_name != NULL)\r\n{\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "[Tag: %s]", tag_name);\r\n}\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\nver_type = tvb_get_guint8(tvb, O_LBTRU_HDR_T_VER_TYPE);\r\nnext_hdr = tvb_get_guint8(tvb, O_LBTRU_HDR_T_NEXT_HDR);\r\nflags_or_res = tvb_get_ntohs(tvb, O_LBTRU_HDR_T_FLAGS_OR_RES);\r\npacket_type = LBTRU_HDR_TYPE(ver_type);\r\nif (tag_name != NULL)\r\n{\r\nlbtru_item = proto_tree_add_protocol_format(tree, proto_lbtru, tvb, ofs, -1, "LBT-RU Protocol (Tag: %s): Version %u, Type %s", tag_name,\r\nLBTRU_HDR_VER(ver_type), val_to_str(LBTRU_HDR_TYPE(ver_type), lbtru_packet_type, "Unknown (0x%02x)"));\r\n}\r\nelse\r\n{\r\nlbtru_item = proto_tree_add_protocol_format(tree, proto_lbtru, tvb, ofs, -1, "LBT-RU Protocol: Version %u, Type %s", LBTRU_HDR_VER(ver_type),\r\nval_to_str(LBTRU_HDR_TYPE(ver_type), lbtru_packet_type, "Unknown (0x%02x)"));\r\n}\r\nlbtru_tree = proto_item_add_subtree(lbtru_item, ett_lbtru);\r\nif (tag_name != NULL)\r\n{\r\nproto_item * item = NULL;\r\nitem = proto_tree_add_string(lbtru_tree, hf_lbtru_tag, tvb, 0, 0, tag_name);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nchannel_item = proto_tree_add_item(lbtru_tree, hf_lbtru_channel, tvb, 0, 0, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(channel_item);\r\nchannel_tree = proto_item_add_subtree(channel_item, ett_lbtru_channel);\r\ntapinfo = wmem_new0(wmem_packet_scope(), lbm_lbtru_tap_info_t);\r\ntapinfo->type = packet_type;\r\nheader_item = proto_tree_add_item(lbtru_tree, hf_lbtru_hdr, tvb, 0, -1, ENC_NA);\r\nheader_tree = proto_item_add_subtree(header_item, ett_lbtru_hdr);\r\nproto_tree_add_item(header_tree, hf_lbtru_hdr_ver, tvb, O_LBTRU_HDR_T_VER_TYPE, L_LBTRU_HDR_T_VER_TYPE, ENC_BIG_ENDIAN);\r\ntype_item = proto_tree_add_item(header_tree, hf_lbtru_hdr_type, tvb, O_LBTRU_HDR_T_VER_TYPE, L_LBTRU_HDR_T_VER_TYPE, ENC_BIG_ENDIAN);\r\nnext_hdr_item = proto_tree_add_item(header_tree, hf_lbtru_hdr_next_hdr, tvb, O_LBTRU_HDR_T_NEXT_HDR, L_LBTRU_HDR_T_NEXT_HDR, ENC_BIG_ENDIAN);\r\ntotal_dissected_len = L_LBTRU_HDR_T_VER_TYPE + L_LBTRU_HDR_T_NEXT_HDR;\r\nofs = L_LBTRU_HDR_T_VER_TYPE + L_LBTRU_HDR_T_NEXT_HDR;\r\nswitch (packet_type)\r\n{\r\ncase LBTRU_PACKET_TYPE_DATA:\r\npacket_sqn = tvb_get_ntohl(tvb, L_LBTRU_HDR_T + O_LBTRU_DATA_HDR_T_SQN);\r\nif ((flags_or_res & LBTRU_RETRANSMISSION_FLAG) != 0)\r\n{\r\nretransmission = TRUE;\r\ntapinfo->retransmission = TRUE;\r\n}\r\nif (retransmission)\r\n{\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "DATA(RX) sqn 0x%x", packet_sqn);\r\n}\r\nelse\r\n{\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "DATA sqn 0x%x", packet_sqn);\r\n}\r\nfrom_source = TRUE;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_SM:\r\npacket_sqn = tvb_get_ntohl(tvb, L_LBTRU_HDR_T + O_LBTRU_SM_HDR_T_SM_SQN);\r\nif ((flags_or_res & LBTRU_SM_SYN_FLAG) != 0)\r\n{\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "SM sqn 0x%x SYN", packet_sqn);\r\n}\r\nelse\r\n{\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "SM sqn 0x%x", packet_sqn);\r\n}\r\nfrom_source = TRUE;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_NAK:\r\nnum_naks = tvb_get_ntohs(tvb, L_LBTRU_HDR_T + O_LBTRU_NAK_HDR_T_NUM_NAKS);\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "NAK %" G_GUINT16_FORMAT " naks", num_naks);\r\nfrom_source = FALSE;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_NCF:\r\nnum_ncfs = tvb_get_ntohs(tvb, L_LBTRU_HDR_T + O_LBTRU_NCF_HDR_T_NUM_NCFS);\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "NCF %" G_GUINT16_FORMAT " ncfs", num_ncfs);\r\nfrom_source = TRUE;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_ACK:\r\npacket_sqn = tvb_get_ntohl(tvb, L_LBTRU_HDR_T + O_LBTRU_ACK_HDR_T_ACK_SQN);\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "ACK sqn 0x%x", packet_sqn);\r\nfrom_source = FALSE;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_CREQ:\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "CREQ %s", val_to_str(flags_or_res, lbtru_creq_request, "Unknown (0x%02x)"));\r\nfrom_source = FALSE;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_RST:\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "RST %s", val_to_str(flags_or_res, lbtru_rst_reason, "Unknown (0x%02x)"));\r\nfrom_source = TRUE;\r\nbreak;\r\ndefault:\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "Unknown (0x%02x)", LBTRU_HDR_TYPE(ver_type));\r\nexpert_add_info_format(pinfo, type_item, &ei_lbtru_analysis_unknown_type, "Unrecognized type 0x%02x", LBTRU_HDR_TYPE(ver_type));\r\nreturn (total_dissected_len);\r\nbreak;\r\n}\r\nswitch (packet_type)\r\n{\r\ncase LBTRU_PACKET_TYPE_DATA:\r\nproto_tree_add_bitmask(header_tree, tvb, O_LBTRU_HDR_T_FLAGS_OR_RES, hf_lbtru_hdr_flags, ett_lbtru_hdr_flags, flags_data, ENC_BIG_ENDIAN);\r\ntotal_dissected_len += L_LBTRU_HDR_T_FLAGS_OR_RES;\r\nofs += L_LBTRU_HDR_T_FLAGS_OR_RES;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_NAK:\r\ncase LBTRU_PACKET_TYPE_NCF:\r\ncase LBTRU_PACKET_TYPE_ACK:\r\nproto_tree_add_item(header_tree, hf_lbtru_hdr_res, tvb, O_LBTRU_HDR_T_FLAGS_OR_RES, L_LBTRU_HDR_T_FLAGS_OR_RES, ENC_BIG_ENDIAN);\r\ntotal_dissected_len += L_LBTRU_HDR_T_FLAGS_OR_RES;\r\nofs += L_LBTRU_HDR_T_FLAGS_OR_RES;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_SM:\r\nproto_tree_add_bitmask(header_tree, tvb, O_LBTRU_HDR_T_FLAGS_OR_RES, hf_lbtru_hdr_flags, ett_lbtru_hdr_flags, flags_sm, ENC_BIG_ENDIAN);\r\ntotal_dissected_len += L_LBTRU_HDR_T_FLAGS_OR_RES;\r\nofs += L_LBTRU_HDR_T_FLAGS_OR_RES;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_CREQ:\r\nei_item = proto_tree_add_item(header_tree, hf_lbtru_hdr_request, tvb, O_LBTRU_HDR_T_FLAGS_OR_RES, L_LBTRU_HDR_T_FLAGS_OR_RES, ENC_BIG_ENDIAN);\r\nexpert_add_info_format(pinfo, ei_item, &ei_lbtru_analysis_creq, "CREQ %s", val_to_str(flags_or_res, lbtru_creq_request, "Unknown (0x%04x)"));\r\ntotal_dissected_len += L_LBTRU_HDR_T_FLAGS_OR_RES;\r\nofs += L_LBTRU_HDR_T_FLAGS_OR_RES;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_RST:\r\nei_item = proto_tree_add_item(header_tree, hf_lbtru_hdr_reason, tvb, O_LBTRU_HDR_T_FLAGS_OR_RES, L_LBTRU_HDR_T_FLAGS_OR_RES, ENC_BIG_ENDIAN);\r\nexpert_add_info_format(pinfo, ei_item, &ei_lbtru_analysis_rst, "RST %s", val_to_str(flags_or_res, lbtru_rst_reason, "Unknown (0x%04x)"));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (packet_type)\r\n{\r\ncase LBTRU_PACKET_TYPE_DATA:\r\ndissected_len = dissect_lbtru_data(tvb, L_LBTRU_HDR_T, pinfo, lbtru_tree, tapinfo);\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_SM:\r\ndissected_len = dissect_lbtru_sm(tvb, L_LBTRU_HDR_T, pinfo, lbtru_tree, (flags_or_res & LBTRU_SM_SYN_FLAG), tapinfo);\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_NAK:\r\ndissected_len = dissect_lbtru_nak(tvb, ofs, pinfo, lbtru_tree, tapinfo);\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_NCF:\r\ndissected_len = dissect_lbtru_ncf(tvb, ofs, pinfo, lbtru_tree, tapinfo);\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_ACK:\r\ndissected_len = dissect_lbtru_ack(tvb, ofs, pinfo, lbtru_tree, tapinfo);\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_CREQ:\r\ndissected_len = 0;\r\ntapinfo->creq_type = flags_or_res;\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_RST:\r\ndissected_len = 0;\r\ntapinfo->rst_type = flags_or_res;\r\nbreak;\r\ndefault:\r\ndissected_len = 0;\r\nbreak;\r\n}\r\ntotal_dissected_len += dissected_len;\r\nofs += dissected_len;\r\nif (lbtru_sequence_analysis)\r\n{\r\ntransport_item = proto_tree_add_item(lbtru_tree, hf_lbtru_analysis, tvb, 0, 0, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\ntransport_tree = proto_item_add_subtree(transport_item, ett_lbtru_transport);\r\n}\r\nwhile (next_hdr != LBTRU_NHDR_DATA)\r\n{\r\nproto_item * hdr_length_item;\r\nproto_tree * opt_tree = NULL;\r\nstatic const int * sid_flags[] =\r\n{\r\n&hf_lbtru_opt_sid_flags_ignore,\r\nNULL\r\n};\r\nstatic const int * cid_flags[] =\r\n{\r\n&hf_lbtru_opt_cid_flags_ignore,\r\nNULL\r\n};\r\nint hdrlen;\r\nguint8 cur_next_hdr;\r\ncur_next_hdr = tvb_get_guint8(tvb, ofs + O_LBTRU_BASIC_OPT_T_NEXT_HDR);\r\nhdrlen = (int)tvb_get_guint8(tvb, ofs + O_LBTRU_BASIC_OPT_T_HDR_LEN);\r\nswitch (next_hdr)\r\n{\r\ncase LBTRU_NHDR_SID:\r\nfld_item = proto_tree_add_item(lbtru_tree, hf_lbtru_opt_sid, tvb, ofs, L_LBTRU_BASIC_OPT_T + L_LBTRU_SID_OPT_T, ENC_NA);\r\nopt_tree = proto_item_add_subtree(fld_item, ett_lbtru_opt);\r\nnext_hdr_item = proto_tree_add_item(opt_tree, hf_lbtru_opt_sid_next_hdr, tvb, ofs + O_LBTRU_BASIC_OPT_T_NEXT_HDR, L_LBTRU_BASIC_OPT_T_NEXT_HDR, ENC_BIG_ENDIAN);\r\nhdr_length_item = proto_tree_add_item(opt_tree, hf_lbtru_opt_sid_hdr_len, tvb, ofs + O_LBTRU_BASIC_OPT_T_HDR_LEN, L_LBTRU_BASIC_OPT_T_HDR_LEN, ENC_BIG_ENDIAN);\r\nif (hdrlen == 0)\r\n{\r\nexpert_add_info(pinfo, hdr_length_item, &ei_lbtru_analysis_zero_length_header);\r\nreturn (total_dissected_len);\r\n}\r\nproto_tree_add_bitmask(opt_tree, tvb, ofs + O_LBTRU_BASIC_OPT_T_RES, hf_lbtru_opt_sid_flags, ett_lbtru_opt_sid_flags, sid_flags, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(opt_tree, hf_lbtru_opt_sid_session_id, tvb, ofs + L_LBTRU_BASIC_OPT_T + O_LBTRU_SID_OPT_T_SESSION_ID, L_LBTRU_SID_OPT_T_SESSION_ID, ENC_BIG_ENDIAN);\r\nsession_id = tvb_get_ntohl(tvb, ofs + L_LBTRU_BASIC_OPT_T + O_LBTRU_SID_OPT_T_SESSION_ID);\r\nbreak;\r\ncase LBTRU_NHDR_CID:\r\nfld_item = proto_tree_add_item(lbtru_tree, hf_lbtru_opt_cid, tvb, ofs, L_LBTRU_BASIC_OPT_T + L_LBTRU_CID_OPT_T, ENC_NA);\r\nopt_tree = proto_item_add_subtree(fld_item, ett_lbtru_opt);\r\nnext_hdr_item = proto_tree_add_item(opt_tree, hf_lbtru_opt_cid_next_hdr, tvb, ofs + O_LBTRU_BASIC_OPT_T_NEXT_HDR, L_LBTRU_BASIC_OPT_T_NEXT_HDR, ENC_BIG_ENDIAN);\r\nhdr_length_item = proto_tree_add_item(opt_tree, hf_lbtru_opt_cid_hdr_len, tvb, ofs + O_LBTRU_BASIC_OPT_T_HDR_LEN, L_LBTRU_BASIC_OPT_T_HDR_LEN, ENC_BIG_ENDIAN);\r\nif (hdrlen == 0)\r\n{\r\nexpert_add_info(pinfo, hdr_length_item, &ei_lbtru_analysis_zero_length_header);\r\nreturn (total_dissected_len);\r\n}\r\nproto_tree_add_bitmask(opt_tree, tvb, ofs + O_LBTRU_BASIC_OPT_T_RES, hf_lbtru_opt_cid_flags, ett_lbtru_opt_cid_flags, cid_flags, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(opt_tree, hf_lbtru_opt_cid_client_id, tvb, ofs + L_LBTRU_BASIC_OPT_T + O_LBTRU_CID_OPT_T_CLIENT_SID, L_LBTRU_CID_OPT_T_CLIENT_SID, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, next_hdr_item, &ei_lbtru_analysis_unknown_header, "Unrecognized header 0x%02x", next_hdr);\r\nfld_item = proto_tree_add_item(lbtru_tree, hf_lbtru_opt_unknown, tvb, ofs, L_LBTRU_BASIC_OPT_T + L_LBTRU_CID_OPT_T, ENC_NA);\r\nopt_tree = proto_item_add_subtree(fld_item, ett_lbtru_opt);\r\nnext_hdr_item = proto_tree_add_item(opt_tree, hf_lbtru_opt_unknown_next_hdr, tvb, ofs + O_LBTRU_BASIC_OPT_T_NEXT_HDR, L_LBTRU_BASIC_OPT_T_NEXT_HDR, ENC_BIG_ENDIAN);\r\nhdr_length_item = proto_tree_add_item(opt_tree, hf_lbtru_opt_unknown_hdr_len, tvb, ofs + O_LBTRU_BASIC_OPT_T_HDR_LEN, L_LBTRU_BASIC_OPT_T_HDR_LEN, ENC_BIG_ENDIAN);\r\nif (hdrlen == 0)\r\n{\r\nexpert_add_info(pinfo, hdr_length_item, &ei_lbtru_analysis_zero_length_header);\r\nreturn (total_dissected_len);\r\n}\r\nbreak;\r\n}\r\nnext_hdr = cur_next_hdr;\r\nofs += hdrlen;\r\ntotal_dissected_len += hdrlen;\r\n}\r\nif (from_source)\r\n{\r\ncopy_address_shallow(&source_address, &(pinfo->src));\r\nsource_port = pinfo->srcport;\r\ncopy_address_shallow(&receiver_address, &(pinfo->dst));\r\nreceiver_port = pinfo->destport;\r\n}\r\nelse\r\n{\r\ncopy_address_shallow(&source_address, &(pinfo->dst));\r\nsource_port = pinfo->destport;\r\ncopy_address_shallow(&receiver_address, &(pinfo->src));\r\nreceiver_port = pinfo->srcport;\r\n}\r\nif (pinfo->fd->flags.visited == 0)\r\n{\r\ntransport = lbtru_transport_add(&source_address, source_port, session_id, pinfo->num);\r\n}\r\nelse\r\n{\r\ntransport = lbtru_transport_find(&source_address, source_port, session_id, pinfo->num);\r\n}\r\nif (transport != NULL)\r\n{\r\nif (pinfo->fd->flags.visited == 0)\r\n{\r\nclient = lbtru_client_transport_add(transport, &receiver_address, receiver_port, pinfo->num);\r\nif (client != NULL)\r\n{\r\nif (lbtru_sequence_analysis)\r\n{\r\nlbtru_client_transport_frame_add(client, packet_type, pinfo->num, packet_sqn, retransmission);\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nclient = lbtru_client_transport_find(transport, &receiver_address, receiver_port, pinfo->num);\r\n}\r\ntapinfo->transport = lbtru_transport_source_string_transport(transport);\r\nchannel = transport->channel;\r\nfld_item = proto_tree_add_uint64(channel_tree, hf_lbtru_channel_id, tvb, 0, 0, channel);\r\nPROTO_ITEM_SET_GENERATED(fld_item);\r\nif (client != NULL)\r\n{\r\nfld_item = proto_tree_add_uint(channel_tree, hf_lbtru_channel_client, tvb, 0, 0, client->id);\r\nPROTO_ITEM_SET_GENERATED(fld_item);\r\n}\r\n}\r\nproto_item_set_len(lbtru_item, total_dissected_len);\r\nif ((packet_type == LBTRU_PACKET_TYPE_DATA) && (next_hdr == LBTRU_NHDR_DATA))\r\n{\r\ntotal_dissected_len += dissect_lbtru_data_contents(tvb, ofs, pinfo, tree, tag_name, channel);\r\n}\r\nif (lbtru_sequence_analysis)\r\n{\r\nif ((transport != NULL) && (client != NULL))\r\n{\r\nlbm_transport_frame_t * frame = NULL;\r\nframe = lbtru_client_transport_frame_find(client, pinfo->num);\r\nif (frame != NULL)\r\n{\r\nlbm_transport_sqn_t * sqn = NULL;\r\nif (frame->previous_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_prev_frame, tvb, 0, 0, frame->previous_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nif (frame->next_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_next_frame, tvb, 0, 0, frame->next_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nswitch (packet_type)\r\n{\r\ncase LBTRU_PACKET_TYPE_DATA:\r\nif (frame->previous_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_prev_data_frame, tvb, 0, 0, frame->previous_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nif (frame->next_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_next_data_frame, tvb, 0, 0, frame->next_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nsqn = lbtru_client_transport_sqn_find(client, packet_type, packet_sqn);\r\nif (sqn != NULL)\r\n{\r\nif (sqn->frame_count > 1)\r\n{\r\nproto_tree * frame_tree = NULL;\r\nproto_item * frame_tree_item = NULL;\r\nlbtru_sqn_frame_list_callback_data_t cb_data;\r\nframe_tree_item = proto_tree_add_item(transport_tree, hf_lbtru_analysis_sqn, tvb, 0, 0, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(frame_tree_item);\r\nframe_tree = proto_item_add_subtree(frame_tree_item, ett_lbtru_transport_sqn);\r\ncb_data.tree = frame_tree;\r\ncb_data.tvb = tvb;\r\ncb_data.current_frame = pinfo->num;\r\nwmem_tree_foreach(sqn->frame, dissect_lbtru_sqn_frame_list_callback, (void *) &cb_data);\r\n}\r\n}\r\nif (frame->retransmission)\r\n{\r\ntransport_item = proto_tree_add_boolean(transport_tree, hf_lbtru_analysis_data_retransmission, tvb, 0, 0, TRUE);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\nexpert_add_info(pinfo, transport_item, &ei_lbtru_analysis_data_rx);\r\n}\r\nif (frame->sqn_gap != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_data_sqn_gap, tvb, 0, 0, frame->sqn_gap);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\nexpert_add_info_format(pinfo, transport_item, &ei_lbtru_analysis_data_gap, "Data sequence gap (%" G_GUINT32_FORMAT ")", frame->sqn_gap);\r\n}\r\nif (frame->ooo_gap != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_data_ooo_gap, tvb, 0, 0, frame->ooo_gap);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\nexpert_add_info_format(pinfo, transport_item, &ei_lbtru_analysis_data_ooo, "Data sequence out of order gap (%" G_GUINT32_FORMAT ")", frame->ooo_gap);\r\n}\r\nif (frame->duplicate)\r\n{\r\ntransport_item = proto_tree_add_boolean(transport_tree, hf_lbtru_analysis_data_duplicate, tvb, 0, 0, TRUE);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\nexpert_add_info(pinfo, transport_item, &ei_lbtru_analysis_data_dup);\r\n}\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_SM:\r\nif (frame->previous_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_prev_sm_frame, tvb, 0, 0, frame->previous_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nif (frame->next_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_next_sm_frame, tvb, 0, 0, frame->next_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nsqn = lbtru_client_transport_sqn_find(client, packet_type, packet_sqn);\r\nif (sqn != NULL)\r\n{\r\nif (sqn->frame_count > 1)\r\n{\r\nproto_tree * frame_tree = NULL;\r\nproto_item * frame_tree_item = NULL;\r\nlbtru_sqn_frame_list_callback_data_t cb_data;\r\nframe_tree_item = proto_tree_add_item(transport_tree, hf_lbtru_analysis_sqn, tvb, 0, 0, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(frame_tree_item);\r\nframe_tree = proto_item_add_subtree(frame_tree_item, ett_lbtru_transport_sqn);\r\ncb_data.tree = frame_tree;\r\ncb_data.tvb = tvb;\r\ncb_data.current_frame = pinfo->num;\r\nwmem_tree_foreach(sqn->frame, dissect_lbtru_sqn_frame_list_callback, (void *) &cb_data);\r\n}\r\n}\r\nif (frame->sqn_gap != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_sm_sqn_gap, tvb, 0, 0, frame->sqn_gap);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\nexpert_add_info_format(pinfo, transport_item, &ei_lbtru_analysis_sm_gap, "SM sequence gap (%" G_GUINT32_FORMAT ")", frame->sqn_gap);\r\n}\r\nif (frame->ooo_gap != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_sm_ooo_gap, tvb, 0, 0, frame->ooo_gap);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\nexpert_add_info_format(pinfo, transport_item, &ei_lbtru_analysis_sm_ooo, "SM sequence out of order gap (%" G_GUINT32_FORMAT ")", frame->ooo_gap);\r\n}\r\nif (frame->duplicate)\r\n{\r\ntransport_item = proto_tree_add_boolean(transport_tree, hf_lbtru_analysis_sm_duplicate, tvb, 0, 0, TRUE);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\nexpert_add_info(pinfo, transport_item, &ei_lbtru_analysis_sm_dup);\r\n}\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_NAK:\r\nif (frame->previous_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_prev_nak_frame, tvb, 0, 0, frame->previous_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nif (frame->next_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_next_nak_frame, tvb, 0, 0, frame->next_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_NCF:\r\nif (frame->previous_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_prev_ncf_frame, tvb, 0, 0, frame->previous_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nif (frame->next_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_next_ncf_frame, tvb, 0, 0, frame->next_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_ACK:\r\nif (frame->previous_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_prev_ack_frame, tvb, 0, 0, frame->previous_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nif (frame->next_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_next_ack_frame, tvb, 0, 0, frame->next_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_CREQ:\r\nif (frame->previous_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_prev_creq_frame, tvb, 0, 0, frame->previous_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nif (frame->next_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_next_creq_frame, tvb, 0, 0, frame->next_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nbreak;\r\ncase LBTRU_PACKET_TYPE_RST:\r\nif (frame->previous_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_prev_rst_frame, tvb, 0, 0, frame->previous_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nif (frame->next_type_frame != 0)\r\n{\r\ntransport_item = proto_tree_add_uint(transport_tree, hf_lbtru_analysis_next_rst_frame, tvb, 0, 0, frame->next_type_frame);\r\nPROTO_ITEM_SET_GENERATED(transport_item);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nif (tapinfo->transport != NULL)\r\n{\r\ntap_queue_packet(lbtru_tap_handle, pinfo, (void *) tapinfo);\r\n}\r\nreturn (total_dissected_len);\r\n}\r\nstatic gboolean test_lbtru_packet(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * user_data)\r\n{\r\ngboolean valid_packet = FALSE;\r\nif (pinfo->ptype != PT_UDP)\r\n{\r\nreturn (FALSE);\r\n}\r\nif ((pinfo->dst.type != AT_IPv4) || (pinfo->dst.len != 4))\r\n{\r\nreturn (FALSE);\r\n}\r\nif (lbtru_use_tag)\r\n{\r\nif (lbtru_tag_find(pinfo) != NULL)\r\n{\r\nvalid_packet = TRUE;\r\n}\r\n}\r\nelse\r\n{\r\nif (((pinfo->destport >= lbtru_source_port_low)\r\n&& (pinfo->destport <= lbtru_source_port_high)\r\n&& (pinfo->srcport >= lbtru_receiver_port_low)\r\n&& (pinfo->srcport <= lbtru_receiver_port_high))\r\n|| ((pinfo->destport >= lbtru_receiver_port_low)\r\n&& (pinfo->destport <= lbtru_receiver_port_high)\r\n&& (pinfo->srcport >= lbtru_source_port_low)\r\n&& (pinfo->srcport <= lbtru_source_port_high)))\r\n{\r\nvalid_packet = TRUE;\r\n}\r\n}\r\nif (valid_packet)\r\n{\r\ndissect_lbtru(tvb, pinfo, tree, user_data);\r\nreturn (TRUE);\r\n}\r\nreturn (FALSE);\r\n}\r\nvoid proto_register_lbtru(void)\r\n{\r\nstatic hf_register_info hf[] =\r\n{\r\n{ &hf_lbtru_channel,\r\n{ "Channel", "lbtru.channel", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_channel_id,\r\n{ "Channel ID", "lbtru.channel.channel", FT_UINT64, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_channel_client,\r\n{ "Channel Client", "lbtru.channel.client", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_tag,\r\n{ "Tag", "lbtru.tag", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_hdr,\r\n{ "Header", "lbtru.hdr", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_hdr_ver,\r\n{ "Version", "lbtru.hdr.ver", FT_UINT8, BASE_DEC, NULL, LBTRU_HDR_VER_VER_MASK, NULL, HFILL } },\r\n{ &hf_lbtru_hdr_type,\r\n{ "Type", "lbtru.hdr.type", FT_UINT8, BASE_HEX, VALS(lbtru_packet_type), LBTRU_HDR_VER_TYPE_MASK, NULL, HFILL } },\r\n{ &hf_lbtru_hdr_next_hdr,\r\n{ "Next Header", "lbtru.hdr.next_hdr", FT_UINT8, BASE_HEX, VALS(lbtru_next_header), 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_hdr_res,\r\n{ "Reserved", "lbtru.hdr.res", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_hdr_flags,\r\n{ "Flags", "lbtru.hdr.flags", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_hdr_flags_rx,\r\n{ "Retransmission", "lbtru.hdr.flags.rx", FT_BOOLEAN, L_LBTRU_HDR_T_FLAGS_OR_RES * 8, TFS(&tfs_set_notset), LBTRU_RETRANSMISSION_FLAG, NULL, HFILL } },\r\n{ &hf_lbtru_hdr_flags_syn,\r\n{ "SYN", "lbtru.hdr.flags.syn", FT_BOOLEAN, L_LBTRU_HDR_T_FLAGS_OR_RES * 8, TFS(&tfs_set_notset), LBTRU_SM_SYN_FLAG, NULL, HFILL } },\r\n{ &hf_lbtru_hdr_request,\r\n{ "Request", "lbtru.hdr.request", FT_UINT16, BASE_HEX, VALS(lbtru_creq_request), 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_hdr_reason,\r\n{ "Reason", "lbtru.hdr.reason", FT_UINT16, BASE_HEX, VALS(lbtru_rst_reason), 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_data,\r\n{ "Data Header", "lbtru.data", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_data_sqn,\r\n{ "Sequence Number", "lbtru.data.sqn", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_data_trail_sqn,\r\n{ "Trailing Edge Sequence Number", "lbtru.data.trail", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_sm,\r\n{ "Session Message Header", "lbtru.sm", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_sm_sqn,\r\n{ "Sequence Number", "lbtru.sm.sqn", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_sm_lead_sqn,\r\n{ "Leading Edge Sequence Number", "lbtru.sm.lead", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_sm_trail_sqn,\r\n{ "Trailing Edge Sequence Number", "lbtru.sm.trail", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_nak,\r\n{ "NAK Header", "lbtru.nak", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_nak_num,\r\n{ "Number of NAKs", "lbtru.nak.num", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_nak_format,\r\n{ "Format", "lbtru.nak.format", FT_UINT16, BASE_DEC, VALS(lbtru_nak_format), LBTRU_NAK_HDR_FORMAT_MASK, NULL, HFILL } },\r\n{ &hf_lbtru_nak_list,\r\n{ "NAK List", "lbtru.nak.list", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_nak_list_nak,\r\n{ "NAK", "lbtru.nak.list.nak", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_ncf,\r\n{ "NAK Confirmation Header", "lbtru.ncf", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_ncf_trail_sqn,\r\n{ "Trailing Edge Sequence Number", "lbtru.ncf.trail", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_ncf_num,\r\n{ "Number of Individual NCFs", "lbtru.ncf.num", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_ncf_reserved,\r\n{ "Reserved", "lbtru.ncf.reserved", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_ncf_reason,\r\n{ "Reason", "lbtru.ncf.reason", FT_UINT8, BASE_HEX, VALS(lbtru_ncf_reason), LBTRU_NCF_HDR_REASON_MASK, NULL, HFILL } },\r\n{ &hf_lbtru_ncf_format,\r\n{ "Format", "lbtru.ncf.format", FT_UINT8, BASE_HEX, VALS(lbtru_ncf_format), LBTRU_NCF_HDR_FORMAT_MASK, NULL, HFILL } },\r\n{ &hf_lbtru_ncf_list,\r\n{ "NCF List", "lbtru.ncf.list", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_ncf_list_ncf,\r\n{ "NCF", "lbtru.ncf.list.ncf", FT_UINT32, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_ack,\r\n{ "ACK Header", "lbtru.ack", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_ack_sqn,\r\n{ "ACK Sequence Number", "lbtru.ack.sqn", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_opt_sid,\r\n{ "SID Option", "lbtru.opt_sid", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_opt_sid_next_hdr,\r\n{ "Next Header", "lbtru.opt_sid.next_hdr", FT_UINT8, BASE_DEC_HEX, VALS(lbtru_next_header), 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_opt_sid_hdr_len,\r\n{ "Header Length", "lbtru.opt_sid.hdr_len", FT_UINT8, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_opt_sid_flags,\r\n{ "Flags", "lbtru.opt_sid.flags", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_opt_sid_flags_ignore,\r\n{ "Ignore", "lbtru.opt_sid.flags.ignore", FT_BOOLEAN, L_LBTRU_BASIC_OPT_T_RES * 8, &(tfs_set_notset), LBTRU_OPT_IGNORE, NULL, HFILL } },\r\n{ &hf_lbtru_opt_sid_session_id,\r\n{ "Session ID", "lbtru.opt_sid.session_id", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_opt_cid,\r\n{ "CID Option", "lbtru.opt_cid", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_opt_cid_next_hdr,\r\n{ "Next Header", "lbtru.opt_cid.next_hdr", FT_UINT8, BASE_DEC_HEX, VALS(lbtru_next_header), 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_opt_cid_hdr_len,\r\n{ "Header Length", "lbtru.opt_cid.hdr_len", FT_UINT8, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_opt_cid_flags,\r\n{ "Flags", "lbtru.opt_cid.flags", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_opt_cid_flags_ignore,\r\n{ "Ignore", "lbtru.opt_cid.flags.ignore", FT_BOOLEAN, L_LBTRU_BASIC_OPT_T_RES * 8, &(tfs_set_notset), LBTRU_OPT_IGNORE, NULL, HFILL } },\r\n{ &hf_lbtru_opt_cid_client_id,\r\n{ "Client ID", "lbtru.opt_cid.client_id", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_opt_unknown,\r\n{ "Unknown Option", "lbtru.opt_unknown", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_opt_unknown_next_hdr,\r\n{ "Next Header", "lbtru.opt_unknown.next_hdr", FT_UINT8, BASE_DEC_HEX, VALS(lbtru_next_header), 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_opt_unknown_hdr_len,\r\n{ "Header Length", "lbtru.opt_unknown.hdr_len", FT_UINT8, BASE_DEC_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis,\r\n{ "Transport Analysis", "lbtru.analysis", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_prev_frame,\r\n{ "Previous Transport Frame", "lbtru.analysis.prev_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_prev_data_frame,\r\n{ "Previous Transport DATA Frame", "lbtru.analysis.prev_data_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_prev_sm_frame,\r\n{ "Previous Transport SM Frame", "lbtru.analysis.prev_sm_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_prev_nak_frame,\r\n{ "Previous Transport NAK Frame", "lbtru.analysis.prev_nak_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_prev_ncf_frame,\r\n{ "Previous Transport NCF Frame", "lbtru.analysis.prev_ncf_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_prev_ack_frame,\r\n{ "Previous Transport ACK Frame", "lbtru.analysis.prev_ack_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_prev_creq_frame,\r\n{ "Previous Transport CREQ Frame", "lbtru.analysis.prev_creq_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_prev_rst_frame,\r\n{ "Previous Transport RST Frame", "lbtru.analysis.prev_rst_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_next_frame,\r\n{ "Next Transport Frame", "lbtru.analysis.next_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_next_data_frame,\r\n{ "Next Transport DATA Frame", "lbtru.analysis.next_data_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_next_sm_frame,\r\n{ "Next Transport SM Frame", "lbtru.analysis.next_sm_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_next_nak_frame,\r\n{ "Next Transport NAK Frame", "lbtru.analysis.next_nak_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_next_ncf_frame,\r\n{ "Next Transport NCF Frame", "lbtru.analysis.next_ncf_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_next_ack_frame,\r\n{ "Next Transport ACK Frame", "lbtru.analysis.next_ack_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_next_creq_frame,\r\n{ "Next Transport CREQ Frame", "lbtru.analysis.next_creq_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_next_rst_frame,\r\n{ "Next Transport RST Frame", "lbtru.analysis.next_rst_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_sqn,\r\n{ "SQN Also in", "lbtru.analysis.sqn", FT_NONE, BASE_NONE, NULL, 0x0, "Sequence number also appears in these frames", HFILL } },\r\n{ &hf_lbtru_analysis_sqn_frame,\r\n{ "Frame", "lbtru.analysis.sqn.frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_data_retransmission,\r\n{ "Frame is a Data Retransmission", "lbtru.analysis.data_retransmission", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_data_sqn_gap,\r\n{ "Gap in Data Sequence", "lbtru.analysis.data_sqn_gap", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_data_ooo_gap,\r\n{ "Data Sequence Out of Order Gap", "lbtru.analysis.data_ooo_gap", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_data_duplicate,\r\n{ "Duplicate Data Frame", "lbtru.analysis.data_duplicate", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_sm_sqn_gap,\r\n{ "Gap in SM Sequence", "lbtru.analysis.sm_sqn_gap", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_sm_ooo_gap,\r\n{ "SM Sequence Out of Order Gap", "lbtru.analysis.sm_ooo_gap", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbtru_analysis_sm_duplicate,\r\n{ "Duplicate SM Frame", "lbtru.analysis.sm_duplicate", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n};\r\nstatic gint * ett[] =\r\n{\r\n&ett_lbtru,\r\n&ett_lbtru_channel,\r\n&ett_lbtru_hdr,\r\n&ett_lbtru_hdr_flags,\r\n&ett_lbtru_data,\r\n&ett_lbtru_sm,\r\n&ett_lbtru_nak,\r\n&ett_lbtru_nak_list,\r\n&ett_lbtru_ncf,\r\n&ett_lbtru_ncf_list,\r\n&ett_lbtru_ack,\r\n&ett_lbtru_opt,\r\n&ett_lbtru_opt_sid_flags,\r\n&ett_lbtru_opt_cid_flags,\r\n&ett_lbtru_transport,\r\n&ett_lbtru_transport_sqn,\r\n};\r\nstatic ei_register_info ei[] =\r\n{\r\n{ &ei_lbtru_analysis_unknown_type, { "lbtru.analysis.unknown_type", PI_MALFORMED, PI_ERROR, "Unrecognized type", EXPFILL } },\r\n{ &ei_lbtru_analysis_unknown_header, { "lbtru.analysis.unknown_header", PI_MALFORMED, PI_ERROR, "Unrecognized header", EXPFILL } },\r\n{ &ei_lbtru_analysis_zero_length_header, { "lbtru.analysis.zero_length_header", PI_MALFORMED, PI_ERROR, "Zero-length header", EXPFILL } },\r\n{ &ei_lbtru_analysis_ack, { "lbtru.analysis.ack", PI_SEQUENCE, PI_CHAT, "ACK", EXPFILL } },\r\n{ &ei_lbtru_analysis_ncf, { "lbtru.analysis.ncf", PI_SEQUENCE, PI_NOTE, "NCF", EXPFILL } },\r\n{ &ei_lbtru_analysis_ncf_ncf, { "lbtru.analysis.ncf.ncf", PI_SEQUENCE, PI_NOTE, "NCF", EXPFILL } },\r\n{ &ei_lbtru_analysis_nak, { "lbtru.analysis.nak", PI_SEQUENCE, PI_WARN, "NAK", EXPFILL } },\r\n{ &ei_lbtru_analysis_nak_nak, { "lbtru.analysis.nak.nak", PI_SEQUENCE, PI_WARN, "NAK", EXPFILL } },\r\n{ &ei_lbtru_analysis_sm, { "lbtru.analysis.sm", PI_SEQUENCE, PI_CHAT, "SM", EXPFILL } },\r\n{ &ei_lbtru_analysis_sm_syn, { "lbtru.analysis.sm.syn", PI_SEQUENCE, PI_CHAT, "SM SYN", EXPFILL } },\r\n{ &ei_lbtru_analysis_creq, { "lbtru.analysis.creq", PI_SEQUENCE, PI_CHAT, "Connection REQuest", EXPFILL } },\r\n{ &ei_lbtru_analysis_rst, { "lbtru.analysis.rst", PI_SEQUENCE, PI_CHAT, "ReSeT", EXPFILL } },\r\n{ &ei_lbtru_analysis_data_rx, { "lbtru.analysis.data.rx", PI_SEQUENCE, PI_NOTE, "Data retransmission", EXPFILL } },\r\n{ &ei_lbtru_analysis_data_gap, { "lbtru.analysis.data.gap", PI_SEQUENCE, PI_NOTE, "Data sequence gap", EXPFILL } },\r\n{ &ei_lbtru_analysis_data_ooo, { "lbtru.analysis.data.ooo", PI_SEQUENCE, PI_NOTE, "Data sequence out of order", EXPFILL } },\r\n{ &ei_lbtru_analysis_data_dup, { "lbtru.analysis.data.dup", PI_SEQUENCE, PI_NOTE, "Duplicate data", EXPFILL } },\r\n{ &ei_lbtru_analysis_sm_gap, { "lbtru.analysis.sm.gap", PI_SEQUENCE, PI_NOTE, "SM sequence gap", EXPFILL } },\r\n{ &ei_lbtru_analysis_sm_ooo, { "lbtru.analysis.sm.ooo", PI_SEQUENCE, PI_NOTE, "SM sequence out of order", EXPFILL } },\r\n{ &ei_lbtru_analysis_sm_dup, { "lbtru.analysis.sm.dup", PI_SEQUENCE, PI_NOTE, "Duplicate SM", EXPFILL } },\r\n};\r\nmodule_t * lbtru_module;\r\nuat_t * tag_uat;\r\nexpert_module_t * expert_lbtru;\r\nproto_lbtru = proto_register_protocol("LBT Reliable Unicast Protocol",\r\n"LBT-RU", "lbtru");\r\nproto_register_field_array(proto_lbtru, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_lbtru = expert_register_protocol(proto_lbtru);\r\nexpert_register_field_array(expert_lbtru, ei, array_length(ei));\r\nlbtru_module = prefs_register_protocol_subtree("29West", proto_lbtru, proto_reg_handoff_lbtru);\r\nprefs_register_uint_preference(lbtru_module,\r\n"source_port_low",\r\n"Source port range low (default " MAKESTRING(LBTRU_DEFAULT_SOURCE_PORT_LOW)")",\r\n"Set the low end of the LBT-RU source UDP port range (context transport_lbtru_port_low)",\r\n10,\r\n&global_lbtru_source_port_low);\r\nprefs_register_uint_preference(lbtru_module,\r\n"source_port_high",\r\n"Source port range high (default " MAKESTRING(LBTRU_DEFAULT_SOURCE_PORT_HIGH)")",\r\n"Set the high end of the LBT-RU source UDP port range (context transport_lbtru_port_high)",\r\n10,\r\n&global_lbtru_source_port_high);\r\nprefs_register_uint_preference(lbtru_module,\r\n"receiver_port_low",\r\n"Receiver port range low (default " MAKESTRING(LBTRU_DEFAULT_RECEIVER_PORT_LOW)")",\r\n"Set the low end of the LBT-RU receiver UDP port range (receiver transport_lbtru_port_low)",\r\n10,\r\n&global_lbtru_receiver_port_low);\r\nprefs_register_uint_preference(lbtru_module,\r\n"receiver_port_high",\r\n"Receiver port range high (default " MAKESTRING(LBTRU_DEFAULT_RECEIVER_PORT_HIGH)")",\r\n"Set the high end of the LBT-RU receiver UDP port range (receiver transport_lbtru_port_high)",\r\n10,\r\n&global_lbtru_receiver_port_high);\r\nlbtru_expert_separate_naks = global_lbtru_expert_separate_naks;\r\nprefs_register_bool_preference(lbtru_module,\r\n"expert_separate_naks",\r\n"Separate NAKs in Expert Info",\r\n"Separate multiple NAKs from a single packet into distinct Expert Info entries",\r\n&global_lbtru_expert_separate_naks);\r\nlbtru_expert_separate_ncfs = global_lbtru_expert_separate_ncfs;\r\nprefs_register_bool_preference(lbtru_module,\r\n"expert_separate_ncfs",\r\n"Separate NCFs in Expert Info",\r\n"Separate multiple NCFs from a single packet into distinct Expert Info entries",\r\n&global_lbtru_expert_separate_ncfs);\r\nlbtru_sequence_analysis = global_lbtru_sequence_analysis;\r\nprefs_register_bool_preference(lbtru_module,\r\n"sequence_analysis",\r\n"Perform Sequence Number Analysis",\r\n"Perform analysis on LBT-RU sequence numbers to determine out-of-order, gaps, loss, etc",\r\n&global_lbtru_sequence_analysis);\r\nprefs_register_bool_preference(lbtru_module,\r\n"use_lbtru_domain",\r\n"Use LBT-RU tag table",\r\n"Use table of LBT-RU tags to decode the packet instead of above values",\r\n&global_lbtru_use_tag);\r\ntag_uat = uat_new("LBT-RU tag definitions",\r\nsizeof(lbtru_tag_entry_t),\r\n"lbtru_domains",\r\nTRUE,\r\n(void * *)&lbtru_tag_entry,\r\n&lbtru_tag_count,\r\nUAT_AFFECTS_DISSECTION,\r\nNULL,\r\nlbtru_tag_copy_cb,\r\nlbtru_tag_update_cb,\r\nlbtru_tag_free_cb,\r\nNULL,\r\nlbtru_tag_array);\r\nprefs_register_uat_preference(lbtru_module,\r\n"tnw_lbtru_tags",\r\n"LBT-RU Tags",\r\n"A table to define LBT-RU tags",\r\ntag_uat);\r\n}\r\nvoid proto_reg_handoff_lbtru(void)\r\n{\r\nstatic gboolean already_registered = FALSE;\r\nif (!already_registered)\r\n{\r\nlbtru_dissector_handle = create_dissector_handle(dissect_lbtru, proto_lbtru);\r\ndissector_add_for_decode_as("udp.port", lbtru_dissector_handle);\r\nheur_dissector_add("udp", test_lbtru_packet, "LBT Reliable Unicast over UDP", "lbtru_udp", proto_lbtru, HEURISTIC_ENABLE);\r\nlbtru_tap_handle = register_tap("lbm_lbtru");\r\n}\r\nif (global_lbtru_source_port_low <= global_lbtru_source_port_high)\r\n{\r\nlbtru_source_port_low = global_lbtru_source_port_low;\r\nlbtru_source_port_high = global_lbtru_source_port_high;\r\n}\r\nif (global_lbtru_receiver_port_low <= global_lbtru_receiver_port_high)\r\n{\r\nlbtru_receiver_port_low = global_lbtru_receiver_port_low;\r\nlbtru_receiver_port_high = global_lbtru_receiver_port_high;\r\n}\r\nlbtru_expert_separate_naks = global_lbtru_expert_separate_naks;\r\nlbtru_expert_separate_ncfs = global_lbtru_expert_separate_ncfs;\r\nlbtru_sequence_analysis = global_lbtru_sequence_analysis;\r\nlbtru_use_tag = global_lbtru_use_tag;\r\nalready_registered = TRUE;\r\n}
