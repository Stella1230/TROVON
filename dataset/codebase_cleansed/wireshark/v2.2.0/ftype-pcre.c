static void\r\ngregex_fvalue_new(fvalue_t *fv)\r\n{\r\nfv->value.re = NULL;\r\n}\r\nstatic void\r\ngregex_fvalue_free(fvalue_t *fv)\r\n{\r\nif (fv->value.re) {\r\ng_regex_unref(fv->value.re);\r\nfv->value.re = NULL;\r\n}\r\n}\r\nstatic gboolean\r\nraw_flag_needed(const gchar *pattern)\r\n{\r\ngboolean found = FALSE;\r\nconst gchar *s = pattern;\r\nsize_t i, len;\r\nlen = strlen(s);\r\nfor (i = 0; i < len; i++) {\r\nif ((guchar)(s[i] & 0xF0) >= 0xA0 &&\r\n(guchar)(s[i] & 0x0F) >= 0x0A)\r\n{\r\nfound = TRUE;\r\nbreak;\r\n}\r\n}\r\nreturn found;\r\n}\r\nstatic gboolean\r\nval_from_string(fvalue_t *fv, const char *pattern, gchar **err_msg)\r\n{\r\nGError *regex_error = NULL;\r\nGRegexCompileFlags cflags = G_REGEX_OPTIMIZE;\r\nif (raw_flag_needed(pattern)) {\r\ncflags = (GRegexCompileFlags)(G_REGEX_OPTIMIZE | G_REGEX_RAW);\r\n}\r\ngregex_fvalue_free(fv);\r\nfv->value.re = g_regex_new(\r\npattern,\r\ncflags,\r\n(GRegexMatchFlags)0,\r\n&regex_error\r\n);\r\nif (regex_error) {\r\nif (err_msg) {\r\n*err_msg = g_strdup(regex_error->message);\r\n}\r\ng_error_free(regex_error);\r\nif (fv->value.re) {\r\ng_regex_unref(fv->value.re);\r\n}\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nval_from_unparsed(fvalue_t *fv, const char *pattern, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\ng_assert(! allow_partial_value);\r\nreturn val_from_string(fv, pattern, err_msg);\r\n}\r\nstatic int\r\ngregex_repr_len(fvalue_t *fv, ftrepr_t rtype, int field_display _U_)\r\n{\r\ng_assert(rtype == FTREPR_DFILTER);\r\nreturn (int)strlen(g_regex_get_pattern(fv->value.re));\r\n}\r\nstatic void\r\ngregex_to_repr(fvalue_t *fv, ftrepr_t rtype, int field_display _U_, char *buf, unsigned int size)\r\n{\r\ng_assert(rtype == FTREPR_DFILTER);\r\ng_strlcpy(buf, g_regex_get_pattern(fv->value.re), size);\r\n}\r\nstatic void\r\ngregex_fvalue_set(fvalue_t *fv, const char *value)\r\n{\r\ng_assert(value != NULL);\r\ngregex_fvalue_free(fv);\r\nval_from_unparsed(fv, value, FALSE, NULL);\r\n}\r\nstatic gpointer\r\ngregex_fvalue_get(fvalue_t *fv)\r\n{\r\nreturn fv->value.re;\r\n}\r\nvoid\r\nftype_register_pcre(void)\r\n{\r\nstatic ftype_t pcre_type = {\r\nFT_PCRE,\r\n"FT_PCRE",\r\n"Compiled Perl-Compatible Regular Expression (GRegex) object",\r\n0,\r\ngregex_fvalue_new,\r\ngregex_fvalue_free,\r\nval_from_unparsed,\r\nval_from_string,\r\ngregex_to_repr,\r\ngregex_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ngregex_fvalue_set,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ngregex_fvalue_get,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nftype_register(FT_PCRE, &pcre_type);\r\n}
