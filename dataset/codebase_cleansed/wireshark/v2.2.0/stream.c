static guint stream_hash_func(gconstpointer k)\r\n{\r\nconst stream_key_t *key = (const stream_key_t *)k;\r\nreturn (GPOINTER_TO_UINT(key->circ.circuit)) ^ key->p2p_dir;\r\n}\r\nstatic gboolean stream_compare_func(gconstpointer a,\r\ngconstpointer b)\r\n{\r\nconst stream_key_t *key1 = (const stream_key_t *)a;\r\nconst stream_key_t *key2 = (const stream_key_t *)b;\r\nif( key1 -> p2p_dir != key2 -> p2p_dir ||\r\nkey1-> is_circuit != key2 -> is_circuit )\r\nreturn FALSE;\r\nif( key1 -> is_circuit )\r\nreturn (key1 -> circ.circuit == key2 -> circ.circuit );\r\nelse\r\nreturn (key1 -> circ.conv == key2 -> circ.conv );\r\n}\r\nstatic void cleanup_stream_hash( void ) {\r\nif( stream_hash != NULL ) {\r\ng_hash_table_destroy( stream_hash );\r\nstream_hash = NULL;\r\n}\r\n}\r\nstatic void init_stream_hash( void ) {\r\ng_assert(stream_hash==NULL);\r\nstream_hash = g_hash_table_new(stream_hash_func,\r\nstream_compare_func);\r\n}\r\nstatic stream_t *stream_hash_lookup_circ( const struct circuit *circuit, int p2p_dir )\r\n{\r\nstream_key_t key;\r\nkey.is_circuit=TRUE;\r\nkey.circ.circuit=circuit;\r\nkey.p2p_dir=p2p_dir;\r\nreturn (stream_t *)g_hash_table_lookup(stream_hash, &key);\r\n}\r\nstatic stream_t *stream_hash_lookup_conv( const struct conversation *conv, int p2p_dir )\r\n{\r\nstream_key_t key;\r\nkey.is_circuit=FALSE;\r\nkey.circ.conv = conv;\r\nkey.p2p_dir=p2p_dir;\r\nreturn (stream_t *)g_hash_table_lookup(stream_hash, &key);\r\n}\r\nstatic stream_t *new_stream( stream_key_t *key )\r\n{\r\nstream_t *val;\r\nval = wmem_new(wmem_file_scope(), stream_t);\r\nval -> key = key;\r\nval -> pdu_counter = 0;\r\nval -> current_pdu = NULL;\r\nval -> lastfrag_framenum = 0;\r\nval -> lastfrag_offset = 0;\r\ng_hash_table_insert(stream_hash, key, val);\r\nreturn val;\r\n}\r\nstatic stream_t *stream_hash_insert_circ( const struct circuit *circuit, int p2p_dir )\r\n{\r\nstream_key_t *key;\r\nkey = wmem_new(wmem_file_scope(), stream_key_t);\r\nkey->is_circuit = TRUE;\r\nkey->circ.circuit = circuit;\r\nkey->p2p_dir = p2p_dir;\r\nreturn new_stream(key);\r\n}\r\nstatic stream_t *stream_hash_insert_conv( const struct conversation *conv, int p2p_dir )\r\n{\r\nstream_key_t *key;\r\nkey = wmem_new(wmem_file_scope(), stream_key_t);\r\nkey->is_circuit = FALSE;\r\nkey->circ.conv = conv;\r\nkey->p2p_dir = p2p_dir;\r\nreturn new_stream(key);\r\n}\r\nstatic void stream_cleanup_pdu_data(void)\r\n{\r\n}\r\nstatic void stream_init_pdu_data(void)\r\n{\r\npdu_counter = 0;\r\n}\r\nstatic stream_pdu_t *stream_new_pdu(stream_t *stream)\r\n{\r\nstream_pdu_t *pdu;\r\npdu = wmem_new(wmem_file_scope(), stream_pdu_t);\r\npdu -> fd_head = NULL;\r\npdu -> pdu_number = stream -> pdu_counter++;\r\npdu -> id = pdu_counter++;\r\nreturn pdu;\r\n}\r\nstatic guint fragment_hash_func(gconstpointer k)\r\n{\r\nconst fragment_key_t *key = (const fragment_key_t *)k;\r\nreturn (GPOINTER_TO_UINT(key->stream)) + ((guint)key -> framenum) + ((guint)key->offset);\r\n}\r\nstatic gboolean fragment_compare_func(gconstpointer a,\r\ngconstpointer b)\r\n{\r\nconst fragment_key_t *key1 = (const fragment_key_t *)a;\r\nconst fragment_key_t *key2 = (const fragment_key_t *)b;\r\nreturn (key1 -> stream == key2 -> stream &&\r\nkey1 -> framenum == key2 -> framenum &&\r\nkey1 -> offset == key2 -> offset );\r\n}\r\nstatic void cleanup_fragment_hash( void ) {\r\nif( fragment_hash != NULL ) {\r\ng_hash_table_destroy( fragment_hash );\r\nfragment_hash = NULL;\r\n}\r\n}\r\nstatic void init_fragment_hash( void ) {\r\ng_assert(fragment_hash==NULL);\r\nfragment_hash = g_hash_table_new(fragment_hash_func,\r\nfragment_compare_func);\r\n}\r\nstatic stream_pdu_fragment_t *fragment_hash_lookup( const stream_t *stream, guint32 framenum, guint32 offset )\r\n{\r\nfragment_key_t key;\r\nstream_pdu_fragment_t *val;\r\nkey.stream = stream;\r\nkey.framenum = framenum;\r\nkey.offset = offset;\r\nval = (stream_pdu_fragment_t *)g_hash_table_lookup(fragment_hash, &key);\r\nreturn val;\r\n}\r\nstatic stream_pdu_fragment_t *fragment_hash_insert( const stream_t *stream, guint32 framenum, guint32 offset,\r\nguint32 length)\r\n{\r\nfragment_key_t *key;\r\nstream_pdu_fragment_t *val;\r\nkey = wmem_new(wmem_file_scope(), fragment_key_t);\r\nkey->stream = stream;\r\nkey->framenum = framenum;\r\nkey->offset = offset;\r\nval = wmem_new(wmem_file_scope(), stream_pdu_fragment_t);\r\nval->len = length;\r\nval->pdu = NULL;\r\nval->final_fragment = FALSE;\r\ng_hash_table_insert(fragment_hash, key, val);\r\nreturn val;\r\n}\r\nstream_t *stream_new_circ ( const struct circuit *circuit, int p2p_dir )\r\n{\r\nstream_t * stream;\r\nstream = stream_hash_lookup_circ(circuit, p2p_dir);\r\nDISSECTOR_ASSERT( stream == NULL );\r\nstream = stream_hash_insert_circ(circuit, p2p_dir);\r\nreturn stream;\r\n}\r\nstream_t *stream_new_conv ( const struct conversation *conv, int p2p_dir )\r\n{\r\nstream_t * stream;\r\nstream = stream_hash_lookup_conv(conv, p2p_dir);\r\nDISSECTOR_ASSERT( stream == NULL );\r\nstream = stream_hash_insert_conv(conv, p2p_dir);\r\nreturn stream;\r\n}\r\nstream_t *find_stream_circ ( const struct circuit *circuit, int p2p_dir )\r\n{\r\nreturn stream_hash_lookup_circ(circuit,p2p_dir);\r\n}\r\nstream_t *find_stream_conv ( const struct conversation *conv, int p2p_dir )\r\n{\r\nreturn stream_hash_lookup_conv(conv,p2p_dir);\r\n}\r\nvoid stream_cleanup( void )\r\n{\r\ncleanup_stream_hash();\r\ncleanup_fragment_hash();\r\nstream_cleanup_pdu_data();\r\n}\r\nvoid stream_init( void )\r\n{\r\ninit_stream_hash();\r\ninit_fragment_hash();\r\nstream_init_pdu_data();\r\nreassembly_table_init(&stream_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\n}\r\nstream_pdu_fragment_t *stream_find_frag( stream_t *stream, guint32 framenum, guint32 offset )\r\n{\r\nreturn fragment_hash_lookup( stream, framenum, offset );\r\n}\r\nstream_pdu_fragment_t *stream_add_frag( stream_t *stream, guint32 framenum, guint32 offset,\r\ntvbuff_t *tvb, packet_info *pinfo, gboolean more_frags )\r\n{\r\nfragment_head *fd_head;\r\nstream_pdu_t *pdu;\r\nstream_pdu_fragment_t *frag_data;\r\nDISSECTOR_ASSERT(stream);\r\nDISSECTOR_ASSERT( framenum > stream->lastfrag_framenum ||\r\n(framenum == stream->lastfrag_framenum && offset > stream->lastfrag_offset));\r\npdu = stream->current_pdu;\r\nif( pdu == NULL ) {\r\npdu = stream->current_pdu = stream_new_pdu(stream);\r\n}\r\nfd_head = fragment_add_seq_next(&stream_reassembly_table,\r\ntvb, 0, pinfo, pdu->id, NULL,\r\ntvb_reported_length(tvb), more_frags);\r\nfrag_data = fragment_hash_insert( stream, framenum, offset, tvb_reported_length(tvb));\r\nfrag_data -> pdu = pdu;\r\nif( fd_head != NULL ) {\r\npdu -> fd_head = fd_head;\r\nstream->current_pdu = NULL;\r\nfrag_data -> final_fragment = TRUE;\r\n}\r\nstream -> lastfrag_framenum = framenum;\r\nstream -> lastfrag_offset = offset;\r\nreturn frag_data;\r\n}\r\ntvbuff_t *stream_process_reassembled(\r\ntvbuff_t *tvb, int offset, packet_info *pinfo,\r\nconst char *name, const stream_pdu_fragment_t *frag,\r\nconst struct _fragment_items *fit,\r\ngboolean *update_col_infop, proto_tree *tree)\r\n{\r\nstream_pdu_t *pdu;\r\nDISSECTOR_ASSERT(frag);\r\npdu = frag->pdu;\r\nif(!frag->final_fragment) {\r\nif (pdu->fd_head != NULL && fit->hf_reassembled_in != NULL) {\r\nproto_tree_add_uint(tree,\r\n*(fit->hf_reassembled_in), tvb,\r\n0, 0, pdu->fd_head->reassembled_in);\r\n}\r\nreturn NULL;\r\n}\r\nreturn process_reassembled_data(tvb, offset, pinfo, name, pdu->fd_head,\r\nfit, update_col_infop, tree);\r\n}\r\nguint32 stream_get_frag_length( const stream_pdu_fragment_t *frag)\r\n{\r\nDISSECTOR_ASSERT( frag );\r\nreturn frag->len;\r\n}\r\nfragment_head *stream_get_frag_data( const stream_pdu_fragment_t *frag)\r\n{\r\nDISSECTOR_ASSERT( frag );\r\nreturn frag->pdu->fd_head;\r\n}\r\nguint32 stream_get_pdu_no( const stream_pdu_fragment_t *frag)\r\n{\r\nDISSECTOR_ASSERT( frag );\r\nreturn frag->pdu->pdu_number;\r\n}
