wtap_open_return_val snoop_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nchar magic[sizeof snoop_magic];\r\nstruct snoop_hdr hdr;\r\nstruct snooprec_hdr rec_hdr;\r\nguint padbytes;\r\ngboolean is_shomiti;\r\nstatic const int snoop_encap[] = {\r\nWTAP_ENCAP_ETHERNET,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_TOKEN_RING,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_ETHERNET,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_FDDI_BITSWAPPED,\r\nWTAP_ENCAP_NULL,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_NULL,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_IP_OVER_FC,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_ATM_PDUS,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_IP_OVER_IB_SNOOP,\r\n};\r\n#define NUM_SNOOP_ENCAPS (sizeof snoop_encap / sizeof snoop_encap[0])\r\n#define SNOOP_PRIVATE_BIT 0x80000000\r\nstatic const int snoop_private_encap[] = {\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_IPNET,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\n};\r\n#define NUM_SNOOP_PRIVATE_ENCAPS (sizeof snoop_private_encap / sizeof snoop_private_encap[0])\r\nstatic const int shomiti_encap[] = {\r\nWTAP_ENCAP_ETHERNET,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_TOKEN_RING,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_ETHERNET,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_FDDI_BITSWAPPED,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_ETHERNET,\r\nWTAP_ENCAP_TOKEN_RING,\r\nWTAP_ENCAP_ETHERNET,\r\nWTAP_ENCAP_TOKEN_RING,\r\nWTAP_ENCAP_TOKEN_RING,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_IEEE_802_11_WITH_RADIO,\r\nWTAP_ENCAP_ETHERNET,\r\n};\r\n#define NUM_SHOMITI_ENCAPS (sizeof shomiti_encap / sizeof shomiti_encap[0])\r\nint file_encap;\r\ngint64 saved_offset;\r\nif (!wtap_read_bytes(wth->fh, magic, sizeof magic, err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (memcmp(magic, snoop_magic, sizeof snoop_magic) != 0) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (!wtap_read_bytes(wth->fh, &hdr, sizeof hdr, err, err_info))\r\nreturn WTAP_OPEN_ERROR;\r\nhdr.version = g_ntohl(hdr.version);\r\nswitch (hdr.version) {\r\ncase 2:\r\ncase 3:\r\ncase 4:\r\ncase 5:\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("snoop: version %u unsupported", hdr.version);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nis_shomiti = FALSE;\r\nsaved_offset = file_tell(wth->fh);\r\nif (!wtap_read_bytes_or_eof(wth->fh, &rec_hdr, sizeof rec_hdr, err, err_info)) {\r\nif (*err != 0)\r\nreturn WTAP_OPEN_ERROR;\r\n} else {\r\nif (g_ntohl(rec_hdr.rec_len) >\r\n(sizeof rec_hdr + g_ntohl(rec_hdr.incl_len))) {\r\npadbytes = g_ntohl(rec_hdr.rec_len) -\r\n((guint)sizeof rec_hdr + g_ntohl(rec_hdr.incl_len));\r\nis_shomiti =\r\n(padbytes >= sizeof (struct shomiti_trailer));\r\n}\r\n}\r\nif (file_seek(wth->fh, saved_offset, SEEK_SET, err) == -1)\r\nreturn WTAP_OPEN_ERROR;\r\nhdr.network = g_ntohl(hdr.network);\r\nif (is_shomiti) {\r\nif (hdr.network >= NUM_SHOMITI_ENCAPS\r\n|| shomiti_encap[hdr.network] == WTAP_ENCAP_UNKNOWN) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("snoop: Shomiti network type %u unknown or unsupported",\r\nhdr.network);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nfile_encap = shomiti_encap[hdr.network];\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_SHOMITI;\r\n} else if (hdr.network & SNOOP_PRIVATE_BIT) {\r\nif ((hdr.network^SNOOP_PRIVATE_BIT) >= NUM_SNOOP_PRIVATE_ENCAPS\r\n|| snoop_private_encap[hdr.network^SNOOP_PRIVATE_BIT] == WTAP_ENCAP_UNKNOWN) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("snoop: private network type %u unknown or unsupported",\r\nhdr.network);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nfile_encap = snoop_private_encap[hdr.network^SNOOP_PRIVATE_BIT];\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_SNOOP;\r\n} else {\r\nif (hdr.network >= NUM_SNOOP_ENCAPS\r\n|| snoop_encap[hdr.network] == WTAP_ENCAP_UNKNOWN) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("snoop: network type %u unknown or unsupported",\r\nhdr.network);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nfile_encap = snoop_encap[hdr.network];\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_SNOOP;\r\n}\r\nwth->subtype_read = snoop_read;\r\nwth->subtype_seek_read = snoop_seek_read;\r\nwth->file_encap = file_encap;\r\nwth->snapshot_length = 0;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean snoop_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\nint padbytes;\r\n*data_offset = file_tell(wth->fh);\r\npadbytes = snoop_read_packet(wth, wth->fh, &wth->phdr,\r\nwth->frame_buffer, err, err_info);\r\nif (padbytes == -1)\r\nreturn FALSE;\r\nif (padbytes != 0) {\r\nif (!file_skip(wth->fh, padbytes, err))\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nsnoop_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (snoop_read_packet(wth, wth->random_fh, phdr, buf, err, err_info) == -1) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\nsnoop_read_packet(wtap *wth, FILE_T fh, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nstruct snooprec_hdr hdr;\r\nguint32 rec_size;\r\nguint32 packet_size;\r\nguint32 orig_size;\r\nint header_size;\r\nif (!wtap_read_bytes_or_eof(fh, &hdr, sizeof hdr, err, err_info))\r\nreturn -1;\r\nrec_size = g_ntohl(hdr.rec_len);\r\norig_size = g_ntohl(hdr.orig_len);\r\npacket_size = g_ntohl(hdr.incl_len);\r\nif (orig_size > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("snoop: File has %u-byte original length, bigger than maximum of %u",\r\norig_size, WTAP_MAX_PACKET_SIZE);\r\nreturn -1;\r\n}\r\nif (packet_size > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("snoop: File has %u-byte packet, bigger than maximum of %u",\r\npacket_size, WTAP_MAX_PACKET_SIZE);\r\nreturn -1;\r\n}\r\nif (packet_size > rec_size) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("snoop: File has %u-byte packet, bigger than record size %u",\r\npacket_size, rec_size);\r\nreturn -1;\r\n}\r\nswitch (wth->file_encap) {\r\ncase WTAP_ENCAP_ATM_PDUS:\r\nif (packet_size < sizeof (struct snoop_atm_hdr)) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("snoop: atmsnoop file has a %u-byte packet, too small to have even an ATM pseudo-header",\r\npacket_size);\r\nreturn -1;\r\n}\r\nif (!snoop_read_atm_pseudoheader(fh, &phdr->pseudo_header,\r\nerr, err_info))\r\nreturn -1;\r\nrec_size -= (guint32)sizeof (struct snoop_atm_hdr);\r\norig_size -= (guint32)sizeof (struct snoop_atm_hdr);\r\npacket_size -= (guint32)sizeof (struct snoop_atm_hdr);\r\nbreak;\r\ncase WTAP_ENCAP_ETHERNET:\r\nif (wth->file_type_subtype == WTAP_FILE_TYPE_SUBTYPE_SHOMITI)\r\nphdr->pseudo_header.eth.fcs_len = 4;\r\nelse\r\nphdr->pseudo_header.eth.fcs_len = 0;\r\nbreak;\r\ncase WTAP_ENCAP_IEEE_802_11_WITH_RADIO:\r\nif (packet_size < sizeof (shomiti_wireless_header)) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("snoop: Shomiti wireless file has a %u-byte packet, too small to have even a wireless pseudo-header",\r\npacket_size);\r\nreturn -1;\r\n}\r\nif (!snoop_read_shomiti_wireless_pseudoheader(fh,\r\n&phdr->pseudo_header, err, err_info, &header_size))\r\nreturn -1;\r\nrec_size -= header_size;\r\norig_size -= header_size;\r\npacket_size -= header_size;\r\nbreak;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\nphdr->ts.secs = g_ntohl(hdr.ts_sec);\r\nphdr->ts.nsecs = g_ntohl(hdr.ts_usec) * 1000;\r\nphdr->caplen = packet_size;\r\nphdr->len = orig_size;\r\nif (rec_size < (sizeof hdr + packet_size)) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("snoop: File has %u-byte record with packet size of %u",\r\nrec_size, packet_size);\r\nreturn -1;\r\n}\r\nif (!wtap_read_packet_bytes(fh, buf, packet_size, err, err_info))\r\nreturn -1;\r\nif (wth->file_encap == WTAP_ENCAP_ATM_PDUS &&\r\nphdr->pseudo_header.atm.type == TRAF_LANE) {\r\natm_guess_lane_type(phdr, ws_buffer_start_ptr(buf));\r\n}\r\nreturn rec_size - ((guint)sizeof hdr + packet_size);\r\n}\r\nstatic gboolean\r\nsnoop_read_atm_pseudoheader(FILE_T fh, union wtap_pseudo_header *pseudo_header,\r\nint *err, gchar **err_info)\r\n{\r\nstruct snoop_atm_hdr atm_phdr;\r\nguint8 vpi;\r\nguint16 vci;\r\nif (!wtap_read_bytes(fh, &atm_phdr, sizeof atm_phdr, err, err_info))\r\nreturn FALSE;\r\nvpi = atm_phdr.vpi;\r\nvci = pntoh16(&atm_phdr.vci);\r\nswitch (atm_phdr.flags & 0x0F) {\r\ncase 0x01:\r\npseudo_header->atm.aal = AAL_5;\r\npseudo_header->atm.type = TRAF_LANE;\r\nbreak;\r\ncase 0x02:\r\npseudo_header->atm.aal = AAL_5;\r\npseudo_header->atm.type = TRAF_LLCMX;\r\nbreak;\r\ncase 0x05:\r\npseudo_header->atm.aal = AAL_5;\r\npseudo_header->atm.type = TRAF_ILMI;\r\nbreak;\r\ncase 0x06:\r\npseudo_header->atm.aal = AAL_SIGNALLING;\r\npseudo_header->atm.type = TRAF_UNKNOWN;\r\nbreak;\r\ncase 0x03:\r\npseudo_header->atm.aal = AAL_5;\r\npseudo_header->atm.type = TRAF_UNKNOWN;\r\nbreak;\r\ncase 0x04:\r\npseudo_header->atm.aal = AAL_5;\r\npseudo_header->atm.type = TRAF_UNKNOWN;\r\nbreak;\r\ndefault:\r\nif (vpi == 0 && vci == 5)\r\npseudo_header->atm.aal = AAL_SIGNALLING;\r\nelse\r\npseudo_header->atm.aal = AAL_5;\r\npseudo_header->atm.type = TRAF_UNKNOWN;\r\nbreak;\r\n}\r\npseudo_header->atm.subtype = TRAF_ST_UNKNOWN;\r\npseudo_header->atm.vpi = vpi;\r\npseudo_header->atm.vci = vci;\r\npseudo_header->atm.channel = (atm_phdr.flags & 0x80) ? 0 : 1;\r\npseudo_header->atm.flags = 0;\r\npseudo_header->atm.cells = 0;\r\npseudo_header->atm.aal5t_u2u = 0;\r\npseudo_header->atm.aal5t_len = 0;\r\npseudo_header->atm.aal5t_chksum = 0;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nsnoop_read_shomiti_wireless_pseudoheader(FILE_T fh,\r\nunion wtap_pseudo_header *pseudo_header, int *err, gchar **err_info,\r\nint *header_size)\r\n{\r\nshomiti_wireless_header whdr;\r\nint rsize;\r\nif (!wtap_read_bytes(fh, &whdr, sizeof whdr, err, err_info))\r\nreturn FALSE;\r\nif (whdr.pad[3] < 8) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("snoop: Header length in Surveyor record is %u, less than minimum of 8",\r\nwhdr.pad[3]);\r\nreturn FALSE;\r\n}\r\nrsize = ((int) whdr.pad[3]) - 8;\r\nif (file_seek(fh, rsize, SEEK_CUR, err) == -1)\r\nreturn FALSE;\r\nmemset(&pseudo_header->ieee_802_11, 0, sizeof(pseudo_header->ieee_802_11));\r\npseudo_header->ieee_802_11.fcs_len = 4;\r\npseudo_header->ieee_802_11.decrypted = FALSE;\r\npseudo_header->ieee_802_11.datapad = FALSE;\r\npseudo_header->ieee_802_11.phy = PHDR_802_11_PHY_UNKNOWN;\r\npseudo_header->ieee_802_11.has_channel = TRUE;\r\npseudo_header->ieee_802_11.channel = whdr.channel;\r\npseudo_header->ieee_802_11.has_data_rate = TRUE;\r\npseudo_header->ieee_802_11.data_rate = whdr.rate;\r\npseudo_header->ieee_802_11.has_signal_percent = TRUE;\r\npseudo_header->ieee_802_11.signal_percent = whdr.signal;\r\n*header_size = rsize + 8 + 4;\r\nreturn TRUE;\r\n}\r\nint snoop_dump_can_write_encap(int encap)\r\n{\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nif (encap < 0 || (unsigned)encap >= NUM_WTAP_ENCAPS || wtap_encap[encap] == -1)\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\nreturn 0;\r\n}\r\ngboolean snoop_dump_open(wtap_dumper *wdh, int *err)\r\n{\r\nstruct snoop_hdr file_hdr;\r\nwdh->subtype_write = snoop_dump;\r\nif (!wtap_dump_file_write(wdh, &snoop_magic, sizeof snoop_magic, err))\r\nreturn FALSE;\r\nfile_hdr.version = g_htonl(2);\r\nfile_hdr.network = g_htonl(wtap_encap[wdh->encap]);\r\nif (!wtap_dump_file_write(wdh, &file_hdr, sizeof file_hdr, err))\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\nstatic gboolean snoop_dump(wtap_dumper *wdh,\r\nconst struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info _U_)\r\n{\r\nconst union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nstruct snooprec_hdr rec_hdr;\r\nint reclen;\r\nguint padlen;\r\nstatic const char zeroes[4] = {0};\r\nstruct snoop_atm_hdr atm_hdr;\r\nint atm_hdrsize;\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\nif (wdh->encap == WTAP_ENCAP_ATM_PDUS)\r\natm_hdrsize = sizeof (struct snoop_atm_hdr);\r\nelse\r\natm_hdrsize = 0;\r\nreclen = (int)sizeof rec_hdr + phdr->caplen + atm_hdrsize;\r\npadlen = ((reclen + 3) & ~3) - reclen;\r\nreclen += padlen;\r\nif (phdr->caplen + atm_hdrsize > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_PACKET_TOO_LARGE;\r\nreturn FALSE;\r\n}\r\nrec_hdr.orig_len = g_htonl(phdr->len + atm_hdrsize);\r\nrec_hdr.incl_len = g_htonl(phdr->caplen + atm_hdrsize);\r\nrec_hdr.rec_len = g_htonl(reclen);\r\nrec_hdr.cum_drops = 0;\r\nrec_hdr.ts_sec = g_htonl(phdr->ts.secs);\r\nrec_hdr.ts_usec = g_htonl(phdr->ts.nsecs / 1000);\r\nif (!wtap_dump_file_write(wdh, &rec_hdr, sizeof rec_hdr, err))\r\nreturn FALSE;\r\nif (wdh->encap == WTAP_ENCAP_ATM_PDUS) {\r\natm_hdr.flags =\r\n(pseudo_header->atm.channel == 0) ? 0x80 : 0x00;\r\nswitch (pseudo_header->atm.aal) {\r\ncase AAL_SIGNALLING:\r\natm_hdr.flags |= 0x06;\r\nbreak;\r\ncase AAL_5:\r\nswitch (pseudo_header->atm.type) {\r\ncase TRAF_LANE:\r\natm_hdr.flags |= 0x01;\r\nbreak;\r\ncase TRAF_LLCMX:\r\natm_hdr.flags |= 0x02;\r\nbreak;\r\ncase TRAF_ILMI:\r\natm_hdr.flags |= 0x05;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\natm_hdr.vpi = (guint8) pseudo_header->atm.vpi;\r\natm_hdr.vci = g_htons(pseudo_header->atm.vci);\r\nif (!wtap_dump_file_write(wdh, &atm_hdr, sizeof atm_hdr, err))\r\nreturn FALSE;\r\n}\r\nif (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))\r\nreturn FALSE;\r\nif (!wtap_dump_file_write(wdh, zeroes, padlen, err))\r\nreturn FALSE;\r\nreturn TRUE;\r\n}
