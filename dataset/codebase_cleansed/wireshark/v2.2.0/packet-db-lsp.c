static int\r\ndissect_db_lsp_pdu (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *db_lsp_tree;\r\nproto_item *db_lsp_item;\r\ngint offset = 0;\r\nguint8 type, opvalue;\r\nguint16 magic, length;\r\ncol_set_str (pinfo->cinfo, COL_PROTOCOL, PSNAME);\r\ncol_set_str (pinfo->cinfo, COL_INFO, PNAME);\r\ndb_lsp_item = proto_tree_add_item (tree, proto_db_lsp, tvb, offset, -1, ENC_NA);\r\ndb_lsp_tree = proto_item_add_subtree (db_lsp_item, ett_db_lsp);\r\ntype = tvb_get_guint8 (tvb, offset);\r\nproto_tree_add_item (db_lsp_tree, hf_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif (type == 0x80) {\r\noffset += 2;\r\n}\r\nmagic = tvb_get_ntohs (tvb, offset);\r\nproto_tree_add_item (db_lsp_tree, hf_magic, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nlength = tvb_get_ntohs (tvb, offset);\r\nproto_tree_add_item (db_lsp_tree, hf_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif (magic != 0x0301 || length > tvb_reported_length_remaining (tvb, offset)) {\r\nreturn 0;\r\n}\r\nif (type == TYPE_CONFIG) {\r\nopvalue = tvb_get_guint8 (tvb, offset);\r\nproto_tree_add_item (db_lsp_tree, hf_opvalue, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif (opvalue == OP_CERT) {\r\ntvbuff_t *cert_tvb = tvb_new_subset_length (tvb, offset+10, length-10);\r\ndissect_x509af_Certificate_PDU (cert_tvb, pinfo, db_lsp_tree, NULL);\r\n} else {\r\nproto_tree_add_item (db_lsp_tree, hf_value, tvb, offset, length, ENC_NA);\r\n}\r\n} else if (type == TYPE_DATA) {\r\nproto_tree_add_item (db_lsp_tree, hf_data, tvb, offset, length, ENC_NA);\r\n} else {\r\nproto_tree_add_item (db_lsp_tree, hf_value, tvb, offset, length, ENC_NA);\r\n}\r\nproto_item_append_text (db_lsp_item, ", Type: %d, Length: %d", type, length);\r\nproto_item_set_len (db_lsp_item, length + 5);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic guint\r\nget_db_lsp_pdu_len (packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset, void *data _U_)\r\n{\r\nif (tvb_get_ntohs (tvb, offset + 1) != 0x0301) {\r\nreturn tvb_reported_length_remaining (tvb, offset);\r\n}\r\nreturn tvb_get_ntohs (tvb, offset + 3) + 5;\r\n}\r\nstatic int\r\ndissect_db_lsp_tcp (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ntcp_dissect_pdus (tvb, pinfo, tree, db_lsp_desegment, 5,\r\nget_db_lsp_pdu_len, dissect_db_lsp_pdu, data);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic int\r\ndissect_db_lsp_disc (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *db_lsp_tree;\r\nproto_item *db_lsp_item;\r\ngint offset = 0;\r\nheur_dtbl_entry_t *hdtbl_entry;\r\nproto_tree *data_subtree;\r\ncol_set_str (pinfo->cinfo, COL_PROTOCOL, PSNAME_DISC);\r\ncol_set_str (pinfo->cinfo, COL_INFO, PNAME_DISC);\r\ndb_lsp_item = proto_tree_add_item (tree, proto_db_lsp_disc, tvb, offset, -1, ENC_NA);\r\ndb_lsp_tree = proto_item_add_subtree (db_lsp_item, ett_db_lsp);\r\nif (try_heuristic) {\r\ndata_subtree = proto_item_add_subtree(db_lsp_item, ett_db_lsp);\r\nif (dissector_try_heuristic(heur_subdissector_list, tvb, pinfo, data_subtree, &hdtbl_entry, NULL)) {\r\nreturn tvb_captured_length(tvb);\r\n}\r\n}\r\nproto_tree_add_item (db_lsp_tree, hf_text, tvb, offset, -1, ENC_ASCII|ENC_NA);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_db_lsp (void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_type,\r\n{ "Type", "db-lsp.type",\r\nFT_UINT8, BASE_DEC_HEX, VALS(type_vals), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_magic,\r\n{ "Magic", "db-lsp.magic",\r\nFT_UINT16, BASE_DEC_HEX, NULL, 0x0,\r\n"Magic number", HFILL } },\r\n{ &hf_length,\r\n{ "Length", "db-lsp.length",\r\nFT_UINT16, BASE_DEC_HEX, NULL, 0x0,\r\n"Length in bytes", HFILL } },\r\n{ &hf_opvalue,\r\n{ "OP Value", "db-lsp.op",\r\nFT_UINT8, BASE_DEC_HEX, VALS(op_vals), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_value,\r\n{ "Value", "db-lsp.value",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_data,\r\n{ "Data", "db-lsp.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_text,\r\n{ "Text", "db-lsp.text",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n};\r\nstatic gint *ett[] = {\r\n&ett_db_lsp,\r\n};\r\nmodule_t *db_lsp_module;\r\nproto_db_lsp = proto_register_protocol (PNAME, PSNAME, PFNAME);\r\nproto_db_lsp_disc = proto_register_protocol (PNAME_DISC, PSNAME_DISC, PFNAME_DISC);\r\nregister_dissector ("db-lsp.tcp", dissect_db_lsp_tcp, proto_db_lsp);\r\nregister_dissector ("db-lsp.udp", dissect_db_lsp_disc, proto_db_lsp_disc);\r\nheur_subdissector_list = register_heur_dissector_list("db-lsp", proto_db_lsp);\r\nproto_register_field_array (proto_db_lsp, hf, array_length (hf));\r\nproto_register_subtree_array (ett, array_length (ett));\r\ndb_lsp_module = prefs_register_protocol (proto_db_lsp, NULL);\r\nprefs_register_bool_preference (db_lsp_module, "desegment_pdus",\r\n"Reassemble PDUs spanning multiple TCP segments",\r\n"Whether the LAN sync dissector should reassemble PDUs"\r\n" spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors"\r\n" to reassemble TCP streams\" in the TCP protocol settings.",\r\n&db_lsp_desegment);\r\nprefs_register_bool_preference(db_lsp_module, "try_heuristic",\r\n"Try heuristic sub-dissectors",\r\n"Try to decode the payload using an heuristic sub-dissector",\r\n&try_heuristic);\r\n}\r\nvoid\r\nproto_reg_handoff_db_lsp (void)\r\n{\r\ndissector_handle_t db_lsp_tcp_handle;\r\ndissector_handle_t db_lsp_udp_handle;\r\ndb_lsp_tcp_handle = find_dissector ("db-lsp.tcp");\r\ndb_lsp_udp_handle = find_dissector ("db-lsp.udp");\r\ndissector_add_uint ("tcp.port", DB_LSP_PORT, db_lsp_tcp_handle);\r\ndissector_add_uint ("udp.port", DB_LSP_PORT, db_lsp_udp_handle);\r\n}
