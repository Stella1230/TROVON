static void\r\ninitialize_hopount_info(hopcount_info *hpi) {\r\nmemset(hpi, 0, sizeof(hopcount_info));\r\n}\r\nstatic int\r\ndissect_packetcable_ccc_option(proto_tree *v_tree, proto_item *v_item, packet_info *pinfo, tvbuff_t *tvb, int optoff,\r\nint optend)\r\n{\r\nint suboptoff = optoff;\r\nguint16 subopt, subopt_len;\r\nproto_item *vti;\r\nproto_tree *pkt_s_tree;\r\nsubopt = tvb_get_ntohs(tvb, optoff);\r\nsuboptoff += 2;\r\nsubopt_len = tvb_get_ntohs(tvb, suboptoff);\r\nsuboptoff += 2;\r\nif (optend <= 0) {\r\nexpert_add_info_format(pinfo, v_item, &ei_dhcpv6_no_suboption_len, "Sub element %d: no room left in option for suboption length", subopt);\r\nreturn (optend);\r\n}\r\nvti = proto_tree_add_item(v_tree, hf_packetcable_ccc_suboption, tvb, optoff, 2, ENC_BIG_ENDIAN);\r\npkt_s_tree = proto_item_add_subtree(vti, ett_dhcpv6_pkt_option);\r\nswitch (subopt) {\r\ncase PKT_CCC_PRI_DHCP:\r\nif (subopt_len == 4) {\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_ccc_pri_dhcp, tvb, suboptoff, 4, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nexpert_add_info_format(pinfo, vti, &ei_dhcpv6_bogus_length, "Bogus length: %d", subopt_len);\r\n}\r\nsuboptoff += subopt_len;\r\nbreak;\r\ncase PKT_CCC_SEC_DHCP:\r\nif (subopt_len == 4) {\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_ccc_sec_dhcp, tvb, suboptoff, 4, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nexpert_add_info_format(pinfo, vti, &ei_dhcpv6_bogus_length, "Bogus length: %d", subopt_len);\r\n}\r\nsuboptoff += subopt_len;\r\nbreak;\r\ndefault:\r\nsuboptoff += subopt_len;\r\nbreak;\r\n}\r\nreturn (suboptoff - optoff);\r\n}\r\nstatic void\r\ndhcpv6_domain(proto_tree *subtree, proto_item *v_item, packet_info *pinfo, int hfindex, tvbuff_t *tvb, int offset, guint16 optlen)\r\n{\r\nint start_offset = offset;\r\nchar domain[256];\r\nint pos;\r\nguint8 len;\r\npos = 0;\r\nwhile (optlen) {\r\nif (!pos) {\r\nstart_offset = offset;\r\n}\r\ndomain[pos] = '\0';\r\nlen = tvb_get_guint8(tvb, offset);\r\nif (optlen < len) {\r\nexpert_add_info(pinfo, v_item, &ei_dhcpv6_malformed_dns);\r\nreturn;\r\n}\r\noffset += 1;\r\noptlen -= 1;\r\nif (!len) {\r\nif (!pos) {\r\nexpert_add_info(pinfo, v_item, &ei_dhcpv6_malformed_option);\r\nreturn;\r\n} else {\r\nproto_tree_add_string(subtree, hfindex, tvb, start_offset, offset-start_offset, domain);\r\npos = 0;\r\ncontinue;\r\n}\r\n}\r\nif (pos) {\r\ndomain[pos] = '.';\r\npos++;\r\n}\r\nif ((pos + len) > 254) {\r\nexpert_add_info(pinfo, v_item, &ei_dhcpv6_malformed_option);\r\nreturn;\r\n}\r\ntvb_memcpy(tvb, domain+pos, offset, len);\r\npos += len;\r\noffset += len;\r\noptlen -= len;\r\n}\r\nif (pos) {\r\ndomain[pos] = '\0';\r\nproto_tree_add_string(subtree, hfindex, tvb, start_offset, offset-start_offset, domain);\r\n}\r\n}\r\nstatic int\r\ndissect_packetcable_cccV6_option(proto_tree *v_tree, proto_item *v_item, packet_info *pinfo, tvbuff_t *tvb, int optoff,\r\nint optend)\r\n{\r\nint suboptoff = optoff;\r\nguint16 subopt, subopt_len;\r\nguint8 type;\r\nproto_item *vti, *ti;\r\nproto_tree *pkt_s_tree;\r\nint i;\r\nsubopt = tvb_get_ntohs(tvb, optoff);\r\nsuboptoff += 2;\r\nsubopt_len = tvb_get_ntohs(tvb, suboptoff);\r\nsuboptoff += 2;\r\nif (optend <= 0) {\r\nexpert_add_info_format(pinfo, v_item, &ei_dhcpv6_no_suboption_len, "Sub element %d: no room left in option for suboption length", subopt);\r\nreturn (optend);\r\n}\r\nvti = proto_tree_add_item(v_tree, hf_packetcable_cccV6_suboption, tvb, optoff, 2, ENC_BIG_ENDIAN);\r\npkt_s_tree = proto_item_add_subtree(vti, ett_dhcpv6_pkt_option);\r\nswitch (subopt) {\r\ncase PKT_CCCV6_PRI_DSS:\r\nif (subopt_len < 35) {\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_cccV6_pri_dss, tvb, suboptoff, subopt_len, ENC_ASCII|ENC_NA);\r\n} else {\r\nexpert_add_info_format(pinfo, vti, &ei_dhcpv6_bogus_length, "Bogus length: %d", subopt_len);\r\n}\r\nsuboptoff += subopt_len;\r\nbreak;\r\ncase PKT_CCCV6_SEC_DSS:\r\nif (subopt_len < 35) {\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_cccV6_sec_dss, tvb, suboptoff, subopt_len, ENC_ASCII|ENC_NA);\r\n} else {\r\nexpert_add_info_format(pinfo, vti, &ei_dhcpv6_bogus_length, "Bogus length: %d", subopt_len);\r\n}\r\nsuboptoff += subopt_len;\r\nbreak;\r\ncase PKT_CCCV6_IETF_PROV_SRV:\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_cccV6_prov_srv_type, tvb, suboptoff, 1, ENC_BIG_ENDIAN);\r\ntype = tvb_get_guint8(tvb, suboptoff);\r\nif (type == 0) {\r\ndhcpv6_domain(pkt_s_tree, vti, pinfo, hf_packetcable_cccV6_prov_srv_fqdn, tvb, suboptoff+1, subopt_len-1);\r\n} else if (type == 1) {\r\nif ((subopt_len % 16) == 0) {\r\nfor (i = 0; i < subopt_len/16; i++) {\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_cccV6_prov_srv_ipv6, tvb, suboptoff+1, 4, ENC_NA);\r\nsuboptoff += 16;\r\n}\r\n}\r\n} else {\r\nexpert_add_info_format(pinfo, vti, &ei_dhcpv6_invalid_type, "Invalid type: %u (%u byte%s)",\r\ntype, subopt_len, plurality(subopt_len, "", "s"));\r\n}\r\nsuboptoff += subopt_len;\r\nbreak;\r\ncase PKT_CCCV6_IETF_AS_KRB:\r\nif (subopt_len == 12) {\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_cccV6_as_krb_nominal_timeout, tvb, suboptoff, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_cccV6_as_krb_max_timeout, tvb, suboptoff+4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_cccV6_as_krb_max_retry_count, tvb, suboptoff+8, 4, ENC_BIG_ENDIAN);\r\n} else {\r\nproto_item_append_text(vti, "Bogus length: %d", subopt_len);\r\n}\r\nsuboptoff += subopt_len;\r\nbreak;\r\ncase PKT_CCCV6_IETF_AP_KRB:\r\nif (subopt_len == 12) {\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_cccV6_ap_krb_nominal_timeout, tvb, suboptoff, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_cccV6_ap_krb_max_timeout, tvb, suboptoff+4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_cccV6_ap_krb_max_retry_count, tvb, suboptoff+8, 4, ENC_BIG_ENDIAN);\r\n} else {\r\nproto_item_append_text(vti, "Bogus length: %d", subopt_len);\r\n}\r\nsuboptoff += subopt_len;\r\nbreak;\r\ncase PKT_CCCV6_KRB_REALM:\r\nif (subopt_len > 0) {\r\ndhcpv6_domain(pkt_s_tree, vti, pinfo, hf_packetcable_cccV6_krb_realm, tvb, suboptoff, subopt_len);\r\n}\r\nsuboptoff += subopt_len;\r\nbreak;\r\ncase PKT_CCCV6_TGT_FLAG:\r\nif (subopt_len == 1) {\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_cccV6_tgt_flag, tvb, suboptoff, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_cccV6_tgt_flag_fetch, tvb, suboptoff, 1, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nexpert_add_info_format(pinfo, vti, &ei_dhcpv6_bogus_length, "Bogus length: %d", subopt_len);\r\n}\r\nsuboptoff += subopt_len;\r\nbreak;\r\ncase PKT_CCCV6_PROV_TIMER:\r\nif (subopt_len == 1) {\r\nti = proto_tree_add_item(pkt_s_tree, hf_packetcable_cccV6_prov_timer, tvb, suboptoff, 1, ENC_BIG_ENDIAN);\r\nif (tvb_get_guint8(tvb, suboptoff) > 30)\r\nexpert_add_info(pinfo, ti, &ei_dhcpv6_invalid_time_value);\r\n}\r\nelse {\r\nexpert_add_info_format(pinfo, vti, &ei_dhcpv6_bogus_length, "Bogus length: %d", subopt_len);\r\n}\r\nsuboptoff += subopt_len;\r\nbreak;\r\ncase PKT_CCCV6_IETF_SEC_TKT:\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_cccV6_sec_tcm, tvb, suboptoff, 2, ENC_BIG_ENDIAN);\r\nif (subopt_len == 2) {\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_cccV6_sec_tcm_provisioning_server, tvb, suboptoff, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pkt_s_tree, hf_packetcable_cccV6_sec_tcm_call_manager_server, tvb, suboptoff, 2, ENC_BIG_ENDIAN);\r\n} else {\r\nexpert_add_info_format(pinfo, vti, &ei_dhcpv6_bogus_length, "Bogus length: %d", subopt_len);\r\n}\r\nsuboptoff += subopt_len;\r\nbreak;\r\ndefault:\r\nsuboptoff += subopt_len;\r\nbreak;\r\n}\r\nreturn (suboptoff - optoff);\r\n}\r\nstatic void\r\ndissect_cablelabs_specific_opts(proto_tree *v_tree, proto_item *v_item, packet_info *pinfo, tvbuff_t *tvb, int voff, int len)\r\n{\r\nguint16 type,\r\ntlv_len,\r\nopt_len,\r\nsub_value;\r\nproto_item *ti;\r\nproto_item *ti2;\r\nproto_tree *subtree;\r\nproto_tree *subtree2;\r\ngint tlv5_cap_index,\r\ntlv5_counter,\r\ntlv5_cap_len;\r\nint off = voff,\r\nsub_off,\r\ni,\r\nfield_len,\r\nfield_value;\r\ngchar *device_type = NULL;\r\nif (len > 4) {\r\nwhile (off - voff < len) {\r\ntype = tvb_get_ntohs(tvb, off);\r\nti = proto_tree_add_item(v_tree, hf_cablelabs_opts, tvb, off, 2, ENC_BIG_ENDIAN);\r\ntlv_len = tvb_get_ntohs(tvb, off+2);\r\nsub_off = off + 4;\r\nswitch (type) {\r\ncase CL_OPTION_DEVICE_TYPE:\r\nopt_len = tlv_len;\r\nfield_len = tlv_len;\r\ndevice_type = tvb_get_string_enc(wmem_packet_scope(), tvb, sub_off, field_len, ENC_ASCII);\r\nif ((device_type == NULL) || (strlen(device_type) == 0)) {\r\nproto_item_append_text(ti, "Packet does not contain Device Type.");\r\n} else {\r\nproto_item_append_text(ti, "\"%s\"", device_type);\r\n}\r\nbreak;\r\ncase CL_OPTION_DEVICE_SERIAL_NUMBER:\r\ncase CL_OPTION_HARDWARE_VERSION_NUMBER:\r\ncase CL_OPTION_SOFTWARE_VERSION_NUMBER:\r\ncase CL_OPTION_BOOT_ROM_VERSION:\r\ncase CL_OPTION_MODEL_NUMBER:\r\ncase CL_OPTION_VENDOR_NAME:\r\ncase CL_OPTION_CONFIG_FILE_NAME:\r\ncase CL_OPTION_EMBEDDED_COMPONENT_LIST:\r\nopt_len = tlv_len;\r\nfield_len = tlv_len;\r\nproto_item_append_text(ti, "\"%s\"",\r\ntvb_format_stringzpad(tvb, sub_off, field_len));\r\nbreak;\r\ncase CL_OPTION_VENDOR_OUI:\r\nopt_len = tlv_len;\r\nif (tlv_len == 3) {\r\nproto_item_append_text(ti, "%s",\r\ntvb_bytes_to_str_punct(wmem_packet_scope(), tvb, sub_off, 3, ':'));\r\n} else if (tlv_len == 6) {\r\nproto_item_append_text(ti, "\"%s\"", tvb_format_stringzpad(tvb, sub_off, tlv_len));\r\n} else {\r\nexpert_add_info_format(pinfo, ti, &ei_dhcpv6_bogus_length, "Suboption %d: suboption length isn't 3 or 6", type);\r\n}\r\nbreak;\r\ncase CL_OPTION_ORO:\r\nfield_len = 2;\r\nopt_len = tlv_len;\r\nif (opt_len > 0) {\r\nfor (i = 0; i < tlv_len; i += field_len) {\r\nsub_value = tvb_get_ntohs(tvb, sub_off);\r\nproto_item_append_text(ti, " %d", sub_value);\r\nsub_off += field_len;\r\n}\r\n}\r\nbreak;\r\ncase CL_OPTION_TFTP_SERVERS:\r\ncase CL_OPTION_SYSLOG_SERVERS:\r\ncase CL_OPTION_RFC868_SERVERS:\r\nfield_len = 16;\r\nopt_len = tlv_len;\r\nsubtree = proto_item_add_subtree(ti, ett_dhcpv6_vendor_option);\r\nif ((tlv_len % field_len) == 0) {\r\nfor (i = 0; i < tlv_len/field_len; i++) {\r\nti = proto_tree_add_item(subtree, hf_cablelabs_ipv6_server, tvb, sub_off, 16, ENC_NA);\r\nproto_item_prepend_text(ti, " %d ", i + 1);\r\nsub_off += field_len;\r\n}\r\n}\r\nbreak;\r\ncase CL_OPTION_DEVICE_ID:\r\nopt_len = tlv_len;\r\nfield_len = tlv_len;\r\nif (tlv_len != 6) {\r\nexpert_add_info_format(pinfo, ti, &ei_dhcpv6_bogus_length, "Bogus length: %d", tlv_len);\r\n}\r\nelse {\r\nproto_item_append_text(ti, "%s",\r\ntvb_bytes_to_str(wmem_packet_scope(), tvb, sub_off, field_len));\r\n}\r\nbreak;\r\ncase CL_OPTION_TLV5:\r\nopt_len = tlv_len;\r\nif (device_type == NULL)\r\nbreak;\r\ntlv5_counter = 0;\r\ntlv5_cap_index = sub_off;\r\nsubtree = proto_item_add_subtree(ti, ett_dhcpv6_tlv5_type);\r\nwhile (tlv5_counter < tlv_len) {\r\nif (!g_ascii_strncasecmp(device_type, "ecm", 3)) {\r\nti2 = proto_tree_add_item(subtree, hf_modem_capabilities_encoding_type, tvb, tlv5_cap_index, 1, ENC_BIG_ENDIAN);\r\n} else if (!g_ascii_strncasecmp(device_type, "edva", 3)) {\r\nti2 = proto_tree_add_item(subtree, hf_eue_capabilities_encoding_type, tvb, tlv5_cap_index, 1, ENC_BIG_ENDIAN);\r\n} else {\r\nbreak;\r\n}\r\ntlv5_cap_index++;\r\ntlv5_counter++;\r\nsubtree2 = proto_item_add_subtree(ti2, ett_dhcpv6_tlv5_type);\r\nproto_tree_add_item(subtree2, hf_capabilities_encoding_length, tvb, tlv5_cap_index, 1, ENC_BIG_ENDIAN);\r\ntlv5_cap_len = (guint8) tvb_get_guint8(tvb, tlv5_cap_index);\r\ntlv5_cap_index++;\r\ntlv5_counter += tlv5_cap_len;\r\nif (tlv5_cap_len > 2) {\r\nproto_tree_add_item(subtree2, hf_capabilities_encoding_bytes, tvb, tlv5_cap_index, tlv5_cap_len, ENC_NA);\r\n} else {\r\nproto_tree_add_item(subtree2, hf_capabilities_encoding_number, tvb, tlv5_cap_index, tlv5_cap_len, ENC_BIG_ENDIAN);\r\n}\r\ntlv5_cap_index += tlv5_cap_len;\r\ntlv5_counter++;\r\n}\r\nbreak;\r\ncase CL_OPTION_TIME_OFFSET:\r\nopt_len = tlv_len;\r\nproto_item_append_text(ti, "%d", tvb_get_ntohl(tvb, sub_off));\r\nbreak;\r\ncase CL_OPTION_IP_PREF:\r\nopt_len = tlv_len;\r\nfield_value = tvb_get_guint8(tvb, sub_off);\r\nif (field_value == 1) {\r\nproto_item_append_text(ti, "%s", "IPv4");\r\n} else if (field_value == 2) {\r\nproto_item_append_text(ti, "%s", "IPv6");\r\n} else if (field_value == 6) {\r\nproto_item_append_text(ti, "%s", "Dual Stack");\r\n} else {\r\nproto_item_append_text(ti, "%s%d", "Invalid IP Preference value ", field_value);\r\n}\r\nbreak;\r\ncase CL_OPTION_DOCS_CMTS_CAP:\r\nopt_len = tlv_len;\r\nfield_len = 0;\r\nsubtree = proto_item_add_subtree(ti, ett_dhcpv6_vendor_option);\r\nif (tlv_len > 0) {\r\nfor (i = 0; field_len < opt_len; i++) {\r\nint tagLen = 0;\r\nint tag = 0;\r\ntag = tvb_get_guint8(tvb, sub_off);\r\nsub_off++;\r\ntagLen = tvb_get_guint8(tvb, sub_off);\r\nsub_off++;\r\nif ((tag == CL_OPTION_DOCS_CMTS_TLV_VERS_NUM) && (tagLen == 2)) {\r\nproto_tree_add_item(subtree, hf_cablelabs_docsis_version_number, tvb, sub_off,\r\n2, ENC_BIG_ENDIAN);\r\nsub_off += 2;\r\n}\r\nelse\r\nsub_off += tagLen;\r\nfield_len += tagLen + 2;\r\n}\r\n}\r\nelse\r\nproto_item_append_text(ti, " (empty)");\r\nbreak;\r\ncase CL_CM_MAC_ADDR:\r\nopt_len = tlv_len;\r\nif (tlv_len != 6) {\r\nexpert_add_info_format(pinfo, ti, &ei_dhcpv6_bogus_length, "Bogus length: %d", tlv_len);\r\n}\r\nelse {\r\nproto_item_append_text(ti, "%s", tvb_bytes_to_str_punct(wmem_packet_scope(), tvb, sub_off, opt_len, ':'));\r\n}\r\nbreak;\r\ncase CL_EROUTER_CONTAINER_OPTION:\r\nopt_len = tlv_len;\r\nproto_item_append_text(ti, " %s (len=%d)",\r\ntvb_bytes_to_str(wmem_packet_scope(), tvb, sub_off, opt_len), tlv_len);\r\nbreak;\r\ncase CL_OPTION_CCC:\r\nopt_len = tlv_len;\r\nfield_len = 0;\r\nsubtree = proto_item_add_subtree(ti, ett_dhcpv6_vendor_option);\r\nproto_item_append_text(ti, " (%d bytes)", opt_len);\r\nwhile (field_len < opt_len) {\r\nsub_value = dissect_packetcable_ccc_option(subtree, ti, pinfo, tvb,\r\nsub_off, (opt_len - field_len));\r\nsub_off += sub_value;\r\nfield_len += sub_value;\r\n}\r\nbreak;\r\ncase CL_OPTION_CCCV6:\r\nopt_len = tlv_len;\r\nfield_len = 0;\r\nsubtree = proto_item_add_subtree(ti, ett_dhcpv6_vendor_option);\r\nproto_item_append_text(ti, " (%d bytes)", opt_len);\r\nwhile (field_len < opt_len) {\r\nsub_value = dissect_packetcable_cccV6_option(subtree, ti, pinfo, tvb,\r\nsub_off, (opt_len - field_len));\r\nsub_off += sub_value;\r\nfield_len += sub_value;\r\n}\r\nbreak;\r\ncase CL_OPTION_CORRELATION_ID:\r\nopt_len = tlv_len;\r\nif (tlv_len != 4) {\r\nproto_item_append_text(ti, "Bogus value length=%d",\r\ntlv_len);\r\n}\r\nelse {\r\nproto_item_append_text(ti, "%u", tvb_get_ntohl(tvb, sub_off));\r\n}\r\nbreak;\r\ndefault:\r\nopt_len = tlv_len;\r\nbreak;\r\n}\r\noff += (opt_len + 4);\r\n}\r\n}\r\nelse {\r\nexpert_add_info_format(pinfo, v_item, &ei_dhcpv6_bogus_length, "Bogus length: %d", len);\r\n}\r\n}\r\nstatic void\r\ncablelabs_fmt_docsis_version( gchar *result, guint32 revision )\r\n{\r\ng_snprintf( result, ITEM_LABEL_LENGTH, "%d.%02d", (guint8)(( revision & 0xFF00 ) >> 8), (guint8)(revision & 0xFF) );\r\n}\r\nstatic int\r\ndhcpv6_option(tvbuff_t *tvb, packet_info *pinfo, proto_tree *bp_tree,\r\nint off, int eoff, gboolean *at_end, int protocol, hopcount_info hpi)\r\n{\r\nguint16 opttype, hwtype, subopt_type;\r\nint temp_optlen, optlen, subopt_len;\r\nproto_item *ti = NULL, *option_item;\r\nproto_tree *subtree;\r\nproto_tree *subtree_2;\r\nint i;\r\nguint16 duidtype;\r\nguint32 enterprise_no;\r\nif ((eoff - off) < 4) {\r\n*at_end = TRUE;\r\nreturn 0;\r\n}\r\nopttype = tvb_get_ntohs(tvb, off);\r\noptlen = tvb_get_ntohs(tvb, off + 2);\r\nif ((eoff - off) < (4 + optlen)) {\r\n*at_end = TRUE;\r\nreturn 0;\r\n}\r\nsubtree = proto_tree_add_subtree(bp_tree, tvb, off, 4 + optlen, ett_dhcpv6_option, &option_item,\r\nval_to_str_ext(opttype, &opttype_vals_ext, "DHCP option %u"));\r\nproto_tree_add_item(subtree, hf_option_type, tvb, off, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_option_length, tvb, off + 2, 2, ENC_BIG_ENDIAN);\r\noff += 4;\r\nif (optlen)\r\nproto_tree_add_item(subtree, hf_option_value, tvb, off, optlen, ENC_NA);\r\nswitch (opttype) {\r\ncase OPTION_CLIENTID:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "CID: %s ", tvb_bytes_to_str(wmem_packet_scope(), tvb, off, optlen));\r\ncase OPTION_SERVERID:\r\ncase OPTION_RELAYID:\r\nif (optlen < 2) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "DUID: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_duid_bytes, tvb, off, optlen, ENC_NA);\r\nduidtype = tvb_get_ntohs(tvb, off);\r\nproto_tree_add_item(subtree, hf_duid_type, tvb, off, 2, ENC_BIG_ENDIAN);\r\nswitch (duidtype) {\r\ncase DUID_LLT:\r\n{\r\nnstime_t llt_time;\r\nif (optlen < 8) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "DUID: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_duidllt_hwtype, tvb, off + 2, 2, ENC_BIG_ENDIAN);\r\nllt_time.secs = tvb_get_ntohl(tvb, off + 4) + 946684800U;\r\nllt_time.nsecs = 0;\r\nproto_tree_add_time(subtree, hf_duidllt_time, tvb, off + 4, 4, &llt_time);\r\nif (optlen > 8) {\r\nhwtype = tvb_get_ntohs(tvb, off + 2);\r\nproto_tree_add_string(subtree, hf_duidllt_link_layer_addr, tvb, off + 8,\r\noptlen - 8, tvb_arphrdaddr_to_str(tvb, off+8, optlen-8, hwtype));\r\n}\r\n}\r\nbreak;\r\ncase DUID_EN:\r\nif (optlen < 6) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "DUID: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_duiden_enterprise, tvb, off + 2, 4, ENC_BIG_ENDIAN);\r\nif (optlen > 6) {\r\nproto_tree_add_item(subtree, hf_duiden_identifier, tvb, off + 6, optlen - 6, ENC_NA);\r\n}\r\nbreak;\r\ncase DUID_LL:\r\nif (optlen < 4) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "DUID: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_duidll_hwtype, tvb, off + 2, 2, ENC_BIG_ENDIAN);\r\nif (optlen > 4) {\r\nhwtype = tvb_get_ntohs(tvb, off + 2);\r\nproto_tree_add_string(subtree, hf_duidll_link_layer_addr, tvb, off + 4,\r\noptlen - 4, tvb_arphrdaddr_to_str(tvb, off+4, optlen-4, hwtype));\r\n}\r\nbreak;\r\ncase DUID_UUID:\r\nif (optlen != 18) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "DUID: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_duiduuid_bytes, tvb, off + 2, 16, ENC_NA);\r\nbreak;\r\n}\r\nbreak;\r\ncase OPTION_NTP_SERVER:\r\nif (optlen < 4) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "NTP Server: malformed option");\r\nbreak;\r\n}\r\ntemp_optlen = 0;\r\nwhile (optlen > temp_optlen) {\r\nsubopt_type = tvb_get_ntohs(tvb, off + temp_optlen);\r\nsubopt_len = tvb_get_ntohs(tvb, off + 2 + temp_optlen);\r\nsubtree_2 = proto_tree_add_subtree(subtree, tvb, off+temp_optlen, 4 + subopt_len, ett_dhcpv6_netserver_option, &ti,\r\nval_to_str(subopt_type, ntp_server_opttype_vals, "NTP Server suboption %u"));\r\nproto_tree_add_item(subtree_2, hf_option_ntpserver_type, tvb, off + temp_optlen, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree_2, hf_option_ntpserver_length, tvb, off + temp_optlen + 2, 2, ENC_BIG_ENDIAN);\r\ntemp_optlen += 4;\r\nswitch (subopt_type) {\r\ncase NTP_SUBOPTION_SRV_ADDR:\r\nproto_tree_add_item(subtree_2, hf_option_ntpserver_addr, tvb, off + temp_optlen, 16, ENC_NA);\r\nbreak;\r\ncase NTP_SUBOPTION_MC_ADDR:\r\nproto_tree_add_item(subtree_2, hf_option_ntpserver_mc_addr, tvb, off + temp_optlen, 16, ENC_NA);\r\nbreak;\r\ncase NTP_SUBOPTION_SRV_FQDN:\r\ndhcpv6_domain(subtree_2, ti, pinfo, hf_option_ntpserver_fqdn, tvb, off + temp_optlen, subopt_len);\r\nbreak;\r\n}\r\ntemp_optlen += subopt_len;\r\n}\r\nbreak;\r\ncase OPTION_IA_NA:\r\ncase OPTION_IA_PD:\r\nif (optlen < 12) {\r\nif (opttype == OPTION_IA_NA)\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "IA_NA: malformed option");\r\nelse\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "IA_PD: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_string(subtree, hf_iaid, tvb, off,\r\n4, tvb_arphrdaddr_to_str(tvb, off, 4, opttype));\r\nif (tvb_get_ntohl(tvb, off+4) == DHCPV6_LEASEDURATION_INFINITY) {\r\nproto_tree_add_uint_format_value(subtree, hf_iaid_t1, tvb, off+4,\r\n4, DHCPV6_LEASEDURATION_INFINITY, "infinity");\r\n} else {\r\nproto_tree_add_item(subtree, hf_iaid_t1, tvb, off+4,\r\n4, ENC_BIG_ENDIAN);\r\n}\r\nif (tvb_get_ntohl(tvb, off+8) == DHCPV6_LEASEDURATION_INFINITY) {\r\nproto_tree_add_uint_format_value(subtree, hf_iaid_t2, tvb, off+8,\r\n4, DHCPV6_LEASEDURATION_INFINITY, "infinity");\r\n} else {\r\nproto_tree_add_item(subtree, hf_iaid_t2, tvb, off+8,\r\n4, ENC_BIG_ENDIAN);\r\n}\r\ntemp_optlen = 12;\r\nwhile ((optlen - temp_optlen) > 0) {\r\ntemp_optlen += dhcpv6_option(tvb, pinfo, subtree,\r\noff+temp_optlen, off + optlen, at_end, protocol, hpi);\r\nif (*at_end) {\r\ntemp_optlen = optlen;\r\n}\r\n}\r\nbreak;\r\ncase OPTION_IA_TA:\r\nif (optlen < 4) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "IA_TA: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_string(subtree, hf_iata, tvb, off,\r\n4, tvb_arphrdaddr_to_str(tvb, off, 4, opttype));\r\ntemp_optlen = 4;\r\nwhile ((optlen - temp_optlen) > 0) {\r\ntemp_optlen += dhcpv6_option(tvb, pinfo, subtree,\r\noff+temp_optlen, off + optlen, at_end, protocol, hpi);\r\nif (*at_end) {\r\ntemp_optlen = optlen;\r\n}\r\n}\r\nbreak;\r\ncase OPTION_IAADDR:\r\n{\r\nguint32 preferred_lifetime, valid_lifetime;\r\nif (optlen < 24) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "IA_TA: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_iaaddr_ip, tvb, off, 16, ENC_NA);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "IAA: %s ", tvb_ip6_to_str(tvb, off));\r\npreferred_lifetime = tvb_get_ntohl(tvb, off + 16);\r\nvalid_lifetime = tvb_get_ntohl(tvb, off + 20);\r\nif (preferred_lifetime == DHCPV6_LEASEDURATION_INFINITY) {\r\nproto_tree_add_uint_format_value(subtree, hf_iaaddr_pref_lifetime, tvb, off+16,\r\n4, DHCPV6_LEASEDURATION_INFINITY, "infinity");\r\n} else {\r\nproto_tree_add_item(subtree, hf_iaaddr_pref_lifetime, tvb, off+16,\r\n4, ENC_BIG_ENDIAN);\r\n}\r\nif (valid_lifetime == DHCPV6_LEASEDURATION_INFINITY) {\r\nproto_tree_add_uint_format(subtree, hf_iaaddr_valid_lifetime, tvb, off+20,\r\n4, DHCPV6_LEASEDURATION_INFINITY, "Preferred lifetime: infinity");\r\n} else {\r\nproto_tree_add_item(subtree, hf_iaaddr_valid_lifetime, tvb, off+20,\r\n4, ENC_BIG_ENDIAN);\r\n}\r\ntemp_optlen = 24;\r\nwhile ((optlen - temp_optlen) > 0) {\r\ntemp_optlen += dhcpv6_option(tvb, pinfo, subtree,\r\noff+temp_optlen, off + optlen, at_end, protocol, hpi);\r\nif (*at_end) {\r\ntemp_optlen = optlen;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase OPTION_ORO:\r\ncase OPTION_ERO:\r\nfor (i = 0; i < optlen; i += 2) {\r\nproto_tree_add_item(subtree, hf_requested_option_code, tvb, off+i,\r\n2, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase OPTION_PREFERENCE:\r\nif (optlen != 1) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "PREFERENCE: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_option_preference, tvb, off, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase OPTION_ELAPSED_TIME:\r\nif (optlen != 2) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "ELAPSED-TIME: malformed option");\r\nbreak;\r\n}\r\ntemp_optlen = tvb_get_ntohs(tvb, off);\r\nproto_tree_add_uint_format_value(subtree, hf_elapsed_time, tvb, off,\r\n2, temp_optlen*10, "%u ms", temp_optlen*10);\r\nbreak;\r\ncase OPTION_RELAY_MSG:\r\nif (optlen == 0) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "RELAY-MSG: malformed option");\r\n} else {\r\ndissect_dhcpv6(tvb, pinfo, subtree, off, off + optlen, hpi);\r\n}\r\nbreak;\r\ncase OPTION_AUTH:\r\nif (optlen < 11) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "AUTH: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_auth_protocol, tvb, off, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_auth_algorithm, tvb, off+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_auth_rdm, tvb, off+2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_auth_replay_detection, tvb, off+3, 8, ENC_NA);\r\nif (optlen != 11)\r\nproto_tree_add_item(subtree, hf_auth_info, tvb, off+11, optlen-11, ENC_NA);\r\nbreak;\r\ncase OPTION_UNICAST:\r\nif (optlen != 16) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "UNICAST: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_opt_unicast, tvb, off, 16, ENC_NA);\r\nbreak;\r\ncase OPTION_STATUS_CODE:\r\nproto_tree_add_item(subtree, hf_opt_status_code, tvb, off, 2, ENC_BIG_ENDIAN);\r\nif (optlen > 2)\r\nproto_tree_add_item(subtree, hf_opt_status_msg, tvb, off+2, optlen - 2, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase OPTION_VENDOR_CLASS:\r\nif (optlen < 4) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "VENDOR_CLASS: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_vendorclass_enterprise, tvb, off, 4, ENC_BIG_ENDIAN);\r\nif (optlen > 4)\r\nproto_tree_add_item(subtree, hf_vendorclass_data, tvb, off+6, optlen-6, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase OPTION_VENDOR_OPTS:\r\nif (optlen < 4) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "VENDOR_OPTS: malformed option");\r\nbreak;\r\n}\r\nenterprise_no = tvb_get_ntohl(tvb, off);\r\nti = proto_tree_add_item(subtree, hf_vendoropts_enterprise, tvb, off, 4, ENC_BIG_ENDIAN);\r\nif (optlen >= 4) {\r\nif (enterprise_no == 4491) {\r\ndissect_cablelabs_specific_opts(subtree, ti, pinfo, tvb, off+4, optlen-4);\r\n} else {\r\nint optoffset = 0;\r\nwhile ((optlen - 4 - optoffset) > 0) {\r\nint olen = tvb_get_ntohs(tvb, off + optoffset + 6);\r\nsubtree_2 = proto_tree_add_subtree(subtree, tvb, off + optoffset + 4,\r\n4 + olen, ett_dhcpv6_option_vsoption, NULL, "option");\r\nproto_tree_add_item(subtree_2, hf_vendoropts_enterprise_option_code, tvb, off + optoffset + 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree_2, hf_vendoropts_enterprise_option_length, tvb, off + optoffset + 6, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree_2, hf_vendoropts_enterprise_option_data, tvb, off + optoffset + 8, olen, ENC_NA);\r\noptoffset += (4 + olen);\r\n}\r\n}\r\n}\r\nbreak;\r\ncase OPTION_INTERFACE_ID:\r\n{\r\nif (optlen == 0) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "INTERFACE_ID: malformed option");\r\nbreak;\r\n}\r\nif (cablelabs_interface_id) {\r\ngint namelen = tvb_strnlen(tvb, off, optlen)+1;\r\nif (namelen == 0) {\r\nproto_tree_add_item(subtree, hf_cablelabs_interface_id, tvb, off, optlen, ENC_ASCII|ENC_NA);\r\n} else {\r\nproto_tree_add_item(subtree, hf_cablelabs_interface_id, tvb, off, namelen-1, ENC_ASCII|ENC_NA);\r\ntemp_optlen = optlen - namelen;\r\noff += namelen;\r\nif (temp_optlen >= 6)\r\nproto_tree_add_string(subtree, hf_cablelabs_interface_id_link_address, tvb, off, temp_optlen, tvb_arphrdaddr_to_str(tvb, off, 6, ARPHRD_ETHER));\r\n}\r\n} else {\r\nproto_tree_add_item(subtree, hf_interface_id, tvb, off, optlen, ENC_NA);\r\n}\r\n}\r\nbreak;\r\ncase OPTION_RECONF_MSG:\r\nif (optlen != 1) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "RECONF_MSG: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_reconf_msg, tvb, off, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase OPTION_RECONF_ACCEPT:\r\nif (optlen)\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "RECONF_ACCEPT: malformed option");\r\nbreak;\r\ncase OPTION_SIP_SERVER_D:\r\nif (optlen > 0) {\r\nsubtree_2 = proto_tree_add_subtree(subtree, tvb, off, optlen, ett_dhcpv6_sip_server_domain_search_list_option, &ti, "SIP Servers Domain Search List");\r\ndhcpv6_domain(subtree_2, ti, pinfo, hf_sip_server_domain_search_fqdn, tvb, off, optlen);\r\n}\r\nbreak;\r\ncase OPTION_SIP_SERVER_A:\r\nif (optlen % 16) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "SIP servers address: malformed option");\r\nbreak;\r\n}\r\nfor (i = 0; i < optlen; i += 16)\r\nproto_tree_add_item(subtree, hf_sip_server_a, tvb, off + i, 16, ENC_NA);\r\nbreak;\r\ncase OPTION_DNS_SERVERS:\r\nif (optlen % 16) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "DNS servers address: malformed option");\r\nbreak;\r\n}\r\nfor (i = 0; i < optlen; i += 16) {\r\nti = proto_tree_add_item(subtree, hf_dns_servers, tvb, off + i, 16, ENC_NA);\r\nproto_item_prepend_text(ti, " %d ", i/16 + 1);\r\n}\r\nbreak;\r\ncase OPTION_DOMAIN_LIST:\r\nif (optlen > 0) {\r\nsubtree_2 = proto_tree_add_subtree(subtree, tvb, off, optlen, ett_dhcpv6_dns_domain_search_list_option, &ti, "DNS Domain Search List");\r\ndhcpv6_domain(subtree_2, ti, pinfo, hf_domain_search_list_fqdn, tvb, off, optlen);\r\n}\r\nbreak;\r\ncase OPTION_NIS_SERVERS:\r\nif (optlen % 16) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "NIS servers address: malformed option");\r\nbreak;\r\n}\r\nfor (i = 0; i < optlen; i += 16)\r\nproto_tree_add_item(subtree, hf_nis_servers, tvb, off + i, 16, ENC_NA);\r\nbreak;\r\ncase OPTION_NISP_SERVERS:\r\nif (optlen % 16) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "NISP servers address: malformed option");\r\nbreak;\r\n}\r\nfor (i = 0; i < optlen; i += 16)\r\nproto_tree_add_item(subtree, hf_nisp_servers, tvb, off + i, 16, ENC_NA);\r\nbreak;\r\ncase OPTION_NIS_DOMAIN_NAME:\r\nif (optlen > 0) {\r\nsubtree_2 = proto_tree_add_subtree(subtree, tvb, off, optlen, ett_dhcpv6_nis_domain_name_option, &ti, "nis-domain-name");\r\ndhcpv6_domain(subtree_2, ti, pinfo, hf_nis_fqdn, tvb, off, optlen);\r\n}\r\nbreak;\r\ncase OPTION_NISP_DOMAIN_NAME:\r\nif (optlen > 0) {\r\nsubtree_2 = proto_tree_add_subtree(subtree, tvb, off, optlen, ett_dhcpv6_nisp_domain_name_option, &ti, "nisp-domain-name");\r\ndhcpv6_domain(subtree_2, ti, pinfo, hf_nisp_fqdn, tvb, off, optlen);\r\n}\r\nbreak;\r\ncase OPTION_SNTP_SERVERS:\r\nif (optlen % 16) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "SNTP servers address: malformed option");\r\nbreak;\r\n}\r\nfor (i = 0; i < optlen; i += 16){\r\nti = proto_tree_add_item(subtree, hf_sntp_servers, tvb, off + i, 16, ENC_NA);\r\nproto_item_prepend_text(ti, " %d ", i/16 + 1);\r\n}\r\nbreak;\r\ncase OPTION_LIFETIME:\r\nif (optlen != 4) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "LIFETIME: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_opt_lifetime, tvb, off, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase OPTION_BCMCS_SERVER_D:\r\nif (optlen > 0) {\r\nsubtree_2 = proto_tree_add_subtree(subtree, tvb, off, optlen, ett_dhcpv6_bcmcs_servers_domain_search_list_option, &ti, "BCMCS Servers Domain Search List");\r\ndhcpv6_domain(subtree_2, ti, pinfo, hf_bcmcs_servers_fqdn, tvb, off, optlen);\r\n}\r\nbreak;\r\ncase OPTION_BCMCS_SERVER_A:\r\nif (optlen % 16) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "BCMCS servers address: malformed option");\r\nbreak;\r\n}\r\nfor (i = 0; i < optlen; i += 16)\r\nproto_tree_add_item(subtree, hf_bcmcs_servers_a, tvb, off + i, 16, ENC_NA);\r\nbreak;\r\ncase OPTION_REMOTE_ID:\r\nif (optlen < 4) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "REMOTE_ID: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_remoteid_enterprise, tvb, off, 4, ENC_BIG_ENDIAN);\r\noff += 4;\r\nproto_tree_add_item(subtree, hf_remoteid_enterprise_id, tvb, off, optlen - 4, ENC_NA);\r\nbreak;\r\ncase OPTION_SUBSCRIBER_ID:\r\nif (optlen == 0) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "SUBSCRIBER_ID: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_subscriber_id, tvb, off, optlen, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase OPTION_CLIENT_FQDN:\r\nif (optlen < 1) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "FQDN: malformed option");\r\n} else {\r\nproto_tree_add_item(subtree, hf_clientfqdn_reserved, tvb, off, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_clientfqdn_n, tvb, off, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_clientfqdn_o, tvb, off, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_clientfqdn_s, tvb, off, 1, ENC_BIG_ENDIAN);\r\ndhcpv6_domain(subtree, option_item, pinfo, hf_client_fqdn, tvb, off+1, optlen-1);\r\n}\r\nbreak;\r\ncase OPTION_PANA_AGENT:\r\nif (optlen % 16) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "PANA agent address: malformed option");\r\nbreak;\r\n}\r\nfor (i = 0; i < optlen; i += 16)\r\nproto_tree_add_item(subtree, hf_pana_agent, tvb, off + i, 16, ENC_NA);\r\nbreak;\r\ncase OPTION_TIME_ZONE:\r\nif (optlen > 0)\r\nproto_tree_add_item(subtree, hf_opt_timezone, tvb, off, optlen, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase OPTION_TZDB:\r\nif (optlen > 0)\r\nproto_tree_add_item(subtree, hf_opt_tzdb, tvb, off, optlen, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase OPTION_LQ_QUERY:\r\n{\r\nguint8 query_type;\r\nif (optlen < 17) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "LQ-QUERY: malformed option");\r\nbreak;\r\n}\r\nquery_type = tvb_get_guint8(tvb, off);\r\nti = proto_tree_add_item(subtree, hf_lq_query, tvb, off, 1, ENC_BIG_ENDIAN);\r\nif ((protocol == proto_dhcpv6) &&\r\n((query_type == LQ_QUERY_RELAYID) ||\r\n(query_type == LQ_QUERY_LINK_ADDRESS) ||\r\n(query_type == LQ_QUERY_REMOTEID))) {\r\nexpert_add_info(pinfo, ti, &ei_dhcpv6_bulk_leasequery_bad_query_type);\r\n}\r\nproto_tree_add_item(subtree, hf_lq_query_link_address, tvb, off+1, 16, ENC_NA);\r\ntemp_optlen = 17;\r\nwhile ((optlen - temp_optlen) > 0) {\r\ntemp_optlen += dhcpv6_option(tvb, pinfo, subtree,\r\noff + temp_optlen,\r\noff + optlen, at_end, protocol, hpi);\r\nif (*at_end) {\r\ntemp_optlen = optlen;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase OPTION_CLIENT_DATA:\r\ntemp_optlen = 0;\r\nwhile ((optlen - temp_optlen) > 0) {\r\ntemp_optlen += dhcpv6_option(tvb, pinfo, subtree,\r\noff + temp_optlen,\r\noff + optlen, at_end, protocol, hpi);\r\nif (*at_end) {\r\ntemp_optlen = optlen;\r\n}\r\n}\r\nbreak;\r\ncase OPTION_CLT_TIME:\r\nif (optlen != 4) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "CLT_TIME: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_clt_time, tvb, off, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase OPTION_LQ_RELAY_DATA:\r\nif (optlen < 16) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "LQ_RELAY_DATA: malformed option");\r\nbreak;\r\n}\r\nif (protocol == proto_dhcpv6_bulk_leasequery) {\r\nexpert_add_info(pinfo, option_item, &ei_dhcpv6_bulk_leasequery_no_lq_relay_data);\r\n}\r\nproto_tree_add_item(subtree, hf_lq_relay_data_peer_addr, tvb, off, 16, ENC_NA);\r\nproto_tree_add_item(subtree, hf_lq_relay_data_msg, tvb, off+16, optlen - 16, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase OPTION_LQ_CLIENT_LINK:\r\nif (optlen % 16) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "LQ client links address: malformed option");\r\nbreak;\r\n}\r\nfor (i = 0; i < optlen; i += 16)\r\nproto_tree_add_item(subtree, hf_lq_client_link, tvb, off + i, 16, ENC_NA);\r\nbreak;\r\ncase OPTION_CAPWAP_AC_V6:\r\nif (optlen % 16) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "CAPWAP Access Controllers address: malformed option");\r\nbreak;\r\n}\r\nfor (i = 0; i < optlen; i += 16)\r\nproto_tree_add_item(subtree, hf_capwap_ac_v6, tvb, off + i, 16, ENC_NA);\r\nbreak;\r\ncase OPTION_AFTR_NAME:\r\n{\r\ndhcpv6_domain(subtree, option_item, pinfo, hf_aftr_name, tvb, off, optlen);\r\nbreak;\r\n}\r\ncase OPTION_IAPREFIX:\r\nif (optlen < 25) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "IAPREFIX: malformed option");\r\nbreak;\r\n}\r\nif (tvb_get_ntohl(tvb, off) == DHCPV6_LEASEDURATION_INFINITY) {\r\nproto_tree_add_uint_format_value(subtree, hf_iaprefix_pref_lifetime, tvb, off,\r\n4, DHCPV6_LEASEDURATION_INFINITY, "infinity");\r\n} else {\r\nproto_tree_add_item(subtree, hf_iaprefix_pref_lifetime, tvb, off,\r\n4, ENC_BIG_ENDIAN);\r\n}\r\nif (tvb_get_ntohl(tvb, off + 4) == DHCPV6_LEASEDURATION_INFINITY) {\r\nproto_tree_add_uint_format_value(subtree, hf_iaprefix_valid_lifetime, tvb, off+4,\r\n4, DHCPV6_LEASEDURATION_INFINITY, "infinity");\r\n} else {\r\nproto_tree_add_item(subtree, hf_iaprefix_valid_lifetime, tvb, off+4,\r\n4, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(subtree, hf_iaprefix_pref_len, tvb, off+8, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_iaprefix_pref_addr, tvb, off+9, 16, ENC_NA);\r\ntemp_optlen = 25;\r\nwhile ((optlen - temp_optlen) > 0) {\r\ntemp_optlen += dhcpv6_option(tvb, pinfo, subtree,\r\noff+temp_optlen, off + optlen, at_end, protocol, hpi);\r\nif (*at_end) {\r\ntemp_optlen = optlen;\r\n}\r\n}\r\nbreak;\r\ncase OPTION_MIP6_HA:\r\nif (optlen != 16) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "MIP6_HA: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_mip6_ha, tvb, off, 16, ENC_NA);\r\nbreak;\r\ncase OPTION_MIP6_HOA:\r\nif (optlen != 16) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "MIP6_HOA: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_mip6_hoa, tvb, off, 16, ENC_NA);\r\nbreak;\r\ncase OPTION_NAI:\r\nif (optlen < 4) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "NAI: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_nai, tvb, off, optlen - 2, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase OPTION_PD_EXCLUDE:\r\nif ((optlen < 2) || (optlen > 17)) {\r\nexpert_add_info_format(pinfo, option_item, &ei_dhcpv6_malformed_option, "PD_EXCLUDE: malformed option");\r\nbreak;\r\n}\r\nproto_tree_add_item(subtree, hf_pd_exclude_pref_len, tvb, off, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_pd_exclude_subnet_id , tvb, off+1, optlen-1, ENC_NA);\r\nbreak;\r\n}\r\nreturn 4 + optlen;\r\n}\r\nstatic void\r\ndissect_dhcpv6(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nint off, int eoff, hopcount_info hpi)\r\n{\r\nproto_tree *bp_tree = NULL;\r\nproto_item *ti;\r\nguint8 msgtype;\r\ngboolean at_end;\r\nmsgtype = tvb_get_guint8(tvb, off);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s ", val_to_str_ext(msgtype, &msgtype_vals_ext, "Message Type %u"));\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_dhcpv6, tvb, off, eoff - off, ENC_NA);\r\nbp_tree = proto_item_add_subtree(ti, ett_dhcpv6);\r\n}\r\nif ((msgtype == RELAY_FORW) || (msgtype == RELAY_REPLY)) {\r\nconst guint8 previous_hopcount = hpi.hopcount;\r\nproto_item *previous_pi = hpi.pi;\r\nif (tree) {\r\nproto_tree_add_item(bp_tree, hf_dhcpv6_msgtype, tvb, off, 1, ENC_BIG_ENDIAN);\r\nhpi.pi = proto_tree_add_item(bp_tree, hf_dhcpv6_hopcount, tvb, off + 1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(bp_tree, hf_dhcpv6_linkaddr, tvb, off + 2, 16, ENC_NA);\r\nproto_tree_add_item(bp_tree, hf_dhcpv6_peeraddr, tvb, off + 18, 16, ENC_NA);\r\n}\r\nhpi.hopcount = tvb_get_guint8(tvb, off + 1);\r\nif (hpi.hopcount > HOP_COUNT_LIMIT) {\r\nexpert_add_info_format(pinfo, hpi.pi, &ei_dhcpv6_error_hopcount, "Hopcount (%d) exceeds the maximum limit HOP_COUNT_LIMIT (%d)", hpi.hopcount, HOP_COUNT_LIMIT);\r\n}\r\nif (hpi.relay_message_previously_detected && hpi.hopcount != previous_hopcount - 1) {\r\nexpert_add_info_format(pinfo, previous_pi, &ei_dhcpv6_error_hopcount, "hopcount is not correctly incremented by 1 (expected : %d, actual : %d)", hpi.hopcount + 1, previous_hopcount);\r\n}\r\nhpi.relay_message_previously_detected = TRUE;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "L: %s ", tvb_ip6_to_str(tvb, off + 2));\r\noff += 34;\r\n} else {\r\nif (hpi.hopcount) {\r\nexpert_add_info_format(pinfo, hpi.pi, &ei_dhcpv6_error_hopcount, "Hopcount of most inner message has to equal 0 instead of %d", hpi.hopcount);\r\n}\r\nif (tree) {\r\nproto_tree_add_item(bp_tree, hf_dhcpv6_msgtype, tvb, off, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(bp_tree, hf_dhcpv6_xid, tvb, off + 1, 3, ENC_BIG_ENDIAN);\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "XID: 0x%x ", tvb_get_ntoh24(tvb, off + 1));\r\noff += 4;\r\n}\r\nat_end = FALSE;\r\nwhile ((off < eoff) && !at_end)\r\noff += dhcpv6_option(tvb, pinfo, bp_tree, off, eoff, &at_end, proto_dhcpv6, hpi);\r\n}\r\nstatic int\r\ndissect_dhcpv6_stream(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nhopcount_info hpi;\r\ninitialize_hopount_info(&hpi);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "DHCPv6");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ndissect_dhcpv6(tvb, pinfo, tree, 0, tvb_reported_length(tvb), hpi);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic guint\r\nget_dhcpv6_bulk_leasequery_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset, void *data _U_)\r\n{\r\nreturn (tvb_get_ntohs(tvb, offset)+2);\r\n}\r\nstatic int\r\ndissect_dhcpv6_bulk_leasequery_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *bulk_tree, *option_tree;\r\ngint offset = 0, end;\r\nguint16 size, trans_id;\r\nguint8 msg_type;\r\ngboolean at_end = FALSE;\r\nhopcount_info hpi;\r\ninitialize_hopount_info(&hpi);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "DHCPv6 BulkLease");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nti = proto_tree_add_item(tree, proto_dhcpv6_bulk_leasequery, tvb, 0, -1, ENC_NA );\r\nbulk_tree = proto_item_add_subtree(ti, ett_dhcpv6_bulk_leasequery);\r\nsize = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(bulk_tree, hf_dhcpv6_bulk_leasequery_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nmsg_type = tvb_get_guint8( tvb, offset );\r\nti = proto_tree_add_item(bulk_tree, hf_dhcpv6_bulk_leasequery_msgtype, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif ((msg_type != LEASEQUERY) &&\r\n(msg_type != LEASEQUERY_REPLY) &&\r\n(msg_type != LEASEQUERY_DONE) &&\r\n(msg_type != LEASEQUERY_DATA))\r\nexpert_add_info_format(pinfo, ti, &ei_dhcpv6_bulk_leasequery_bad_msg_type,\r\n"Message Type %d not allowed by DHCPv6 Bulk Leasequery", msg_type);\r\noffset += 1;\r\nproto_tree_add_item(bulk_tree, hf_dhcpv6_bulk_leasequery_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\ntrans_id = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(bulk_tree, hf_dhcpv6_bulk_leasequery_trans_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s, Transaction ID: %5u",\r\nval_to_str_ext_const(msg_type, &msgtype_vals_ext, "Unknown"), trans_id);\r\noption_tree = proto_tree_add_subtree(bulk_tree, tvb, offset, -1, ett_dhcpv6_bulk_leasequery_options, NULL, "DHCPv6 Options");\r\nend = size + 2;\r\nwhile ((offset < end) && !at_end)\r\noffset += dhcpv6_option(tvb, pinfo, option_tree, offset,\r\nend, &at_end, proto_dhcpv6_bulk_leasequery, hpi);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic int\r\ndissect_dhcpv6_bulk_leasequery(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, tree, dhcpv6_bulk_leasequery_desegment, 2,\r\nget_dhcpv6_bulk_leasequery_pdu_len, dissect_dhcpv6_bulk_leasequery_pdu, data);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nvoid\r\nproto_register_dhcpv6(void)\r\n{\r\nmodule_t *bulkquery_module;\r\nmodule_t *dhcpv6_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_dhcpv6_msgtype,\r\n{ "Message type", "dhcpv6.msgtype", FT_UINT8, BASE_DEC | BASE_EXT_STRING, &msgtype_vals_ext, 0x0, NULL, HFILL }},\r\n{ &hf_dhcpv6_hopcount,\r\n{ "Hopcount", "dhcpv6.hopcount", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL}},\r\n{ &hf_dhcpv6_xid,\r\n{ "Transaction ID", "dhcpv6.xid", FT_UINT24, BASE_HEX, NULL, 0, NULL, HFILL}},\r\n{ &hf_dhcpv6_linkaddr,\r\n{ "Link address", "dhcpv6.linkaddr", FT_IPv6, BASE_NONE, NULL, 0, NULL, HFILL}},\r\n{ &hf_dhcpv6_peeraddr,\r\n{ "Peer address", "dhcpv6.peeraddr", FT_IPv6, BASE_NONE, NULL, 0, NULL, HFILL}},\r\n{ &hf_option_type,\r\n{ "Option", "dhcpv6.option.type", FT_UINT16, BASE_DEC | BASE_EXT_STRING, &opttype_vals_ext, 0x0, NULL, HFILL}},\r\n{ &hf_option_length,\r\n{ "Length", "dhcpv6.option.length", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_option_value,\r\n{ "Value", "dhcpv6.option.value", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_clientfqdn_reserved,\r\n{ "Reserved", "dhcpv6.clientfqdn.reserved", FT_UINT8, BASE_HEX, NULL, 0xF8, NULL, HFILL}},\r\n{ &hf_clientfqdn_n,\r\n{ "N bit", "dhcpv6.clientfqdn.n", FT_BOOLEAN, 8, TFS(&fqdn_n), 0x4, "Whether the server SHOULD NOT perform any DNS updates", HFILL}},\r\n{ &hf_clientfqdn_o,\r\n{ "O bit", "dhcpv6.clientfqdn.o", FT_BOOLEAN, 8, TFS(&fqdn_o), 0x2, "Whether the server has overridden the client's preference for the S bit. Must be 0 when sent from client", HFILL}},\r\n{ &hf_clientfqdn_s,\r\n{ "S bit", "dhcpv6.clientfqdn.s", FT_BOOLEAN, 8, TFS(&fqdn_s), 0x1, "Whether the server SHOULD or SHOULD NOT perform the AAAA RR (FQDN-to-address) DNS updates", HFILL}},\r\n{ &hf_remoteid_enterprise,\r\n{ "Enterprise ID", "dhcpv6.remoteid.enterprise", FT_UINT32, BASE_DEC|BASE_EXT_STRING, &sminmpec_values_ext, 0, "RemoteID Enterprise Number", HFILL }},\r\n{ &hf_duid_bytes,\r\n{ "DUID", "dhcpv6.duid.bytes", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_duid_type,\r\n{ "DUID Type", "dhcpv6.duid.type", FT_UINT16, BASE_DEC, VALS(duidtype_vals), 0x0, NULL, HFILL}},\r\n{ &hf_duidllt_time,\r\n{ "DUID Time", "dhcpv6.duidllt.time", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_duidllt_link_layer_addr,\r\n{ "Link-layer address", "dhcpv6.duidllt.link_layer_addr", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_duidllt_hwtype,\r\n{ "Hardware type", "dhcpv6.duidllt.hwtype", FT_UINT16, BASE_DEC, VALS(arp_hrd_vals), 0, "DUID LLT Hardware Type", HFILL }},\r\n{ &hf_duidll_hwtype,\r\n{ "Hardware type", "dhcpv6.duidll.hwtype", FT_UINT16, BASE_DEC, VALS(arp_hrd_vals), 0, "DUID LL Hardware Type", HFILL }},\r\n{ &hf_duiden_enterprise,\r\n{ "Enterprise ID", "dhcpv6.duiden.enterprise", FT_UINT32, BASE_DEC|BASE_EXT_STRING, &sminmpec_values_ext, 0, "DUID EN Enterprise Number", HFILL }},\r\n{ &hf_duiden_identifier,\r\n{ "Identifier", "dhcpv6.duiden.identifier", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_duidll_link_layer_addr,\r\n{ "Link-layer address", "dhcpv6.duidll.link_layer_addr", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_duiduuid_bytes,\r\n{ "UUID", "dhcpv6.duiduuid.bytes", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_iaid,\r\n{ "IAID", "dhcpv6.iaid", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_iaid_t1,\r\n{ "T1", "dhcpv6.iaid.t1", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL}},\r\n{ &hf_iaid_t2,\r\n{ "T2", "dhcpv6.iaid.t2", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL}},\r\n{ &hf_iata,\r\n{ "IATA", "dhcpv6.iata", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_iaaddr_ip,\r\n{ "IPv6 address", "dhcpv6.iaaddr.ip", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_iaaddr_pref_lifetime,\r\n{ "Preferred lifetime", "dhcpv6.iaaddr.pref_lifetime", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL}},\r\n{ &hf_iaaddr_valid_lifetime,\r\n{ "Valid lifetime", "dhcpv6.iaaddr.valid_lifetime", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL}},\r\n{ &hf_requested_option_code,\r\n{ "Requested Option code", "dhcpv6.requested_option_code", FT_UINT16, BASE_DEC | BASE_EXT_STRING, &opttype_vals_ext, 0, NULL, HFILL }},\r\n{ &hf_option_preference,\r\n{ "Pref-value", "dhcpv6.option_preference", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL}},\r\n{ &hf_elapsed_time,\r\n{ "Elapsed time", "dhcpv6.elapsed_time", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL}},\r\n{ &hf_auth_protocol,\r\n{ "Protocol", "dhcpv6.auth.protocol", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL}},\r\n{ &hf_auth_algorithm,\r\n{ "Algorithm", "dhcpv6.auth.algorithm", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL}},\r\n{ &hf_auth_rdm,\r\n{ "RDM", "dhcpv6.auth.rdm", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL}},\r\n{ &hf_auth_replay_detection,\r\n{ "Replay Detection", "dhcpv6.auth.replay_detection", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_auth_info,\r\n{ "Authentication Information", "dhcpv6.auth.info", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_opt_unicast,\r\n{ "IPv6 address", "dhcpv6.unicast", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_opt_status_code,\r\n{ "Status Code", "dhcpv6.status_code", FT_UINT16, BASE_DEC | BASE_EXT_STRING, &statuscode_vals_ext, 0, NULL, HFILL }},\r\n{ &hf_opt_status_msg,\r\n{ "Status Message", "dhcpv6.status_msg", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_vendorclass_enterprise,\r\n{ "Enterprise ID", "dhcpv6.vendorclass.enterprise", FT_UINT32, BASE_DEC|BASE_EXT_STRING, &sminmpec_values_ext, 0, "Vendor Class Enterprise Number", HFILL }},\r\n{ &hf_vendorclass_data,\r\n{ "vendor-class-data", "dhcpv6.vendorclass.data", FT_STRINGZ, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_vendoropts_enterprise,\r\n{ "Enterprise ID", "dhcpv6.vendoropts.enterprise", FT_UINT32, BASE_DEC|BASE_EXT_STRING, &sminmpec_values_ext, 0, "Vendor opts Enterprise Number", HFILL }},\r\n{ &hf_vendoropts_enterprise_option_code,\r\n{ "Option code", "dhcpv6.vendoropts.enterprise.option_code", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_vendoropts_enterprise_option_length,\r\n{ "Option length", "dhcpv6.vendoropts.enterprise.option_length", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_vendoropts_enterprise_option_data,\r\n{ "Option data", "dhcpv6.vendoropts.enterprise.option_data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_interface_id,\r\n{ "Interface-ID", "dhcpv6.interface_id", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_reconf_msg,\r\n{ "Reconfigure message type", "dhcpv6.reconf_msg", FT_UINT8, BASE_DEC | BASE_EXT_STRING, &msgtype_vals_ext, 0, NULL, HFILL }},\r\n{ &hf_sip_server_domain_search_fqdn,\r\n{ "SIP Server Domain Search FQDN", "dhcpv6.sip_server_domain_search_fqdn", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sip_server_a,\r\n{ "SIP server address", "dhcpv6.sip_server_a", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_dns_servers,\r\n{ "DNS server address", "dhcpv6.dns_server", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_domain_search_list_fqdn,\r\n{ "Domain Search List FQDN", "dhcpv6.domain_search_list_fqdn", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nis_servers,\r\n{ "NIS server address", "dhcpv6.nis_server", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_nisp_servers,\r\n{ "NISP server address", "dhcpv6.nisp_server", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_nis_fqdn,\r\n{ "NIS FQDN", "dhcpv6.nis_fqdn", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nisp_fqdn,\r\n{ "NISP FQDN", "dhcpv6.nisp_fqdn", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sntp_servers,\r\n{ "SNTP server address", "dhcpv6.sntp_server", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_opt_lifetime,\r\n{ "Lifetime", "dhcpv6.lifetime", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL}},\r\n{ &hf_bcmcs_servers_fqdn,\r\n{ "BCMCS server FQDN", "dhcpv6.bcmcs_server_fqdn", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_bcmcs_servers_a,\r\n{ "BCMCS server address", "dhcpv6.bcmcs_server_a", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_remoteid_enterprise_id,\r\n{ "Remote-ID", "dhcpv6.remoteid_enterprise_id", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_subscriber_id,\r\n{ "Subscriber-ID", "dhcpv6.subscriber_id", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_client_fqdn,\r\n{ "Client FQDN", "dhcpv6.client_fqdn", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pana_agent,\r\n{ "PANA agents address", "dhcpv6.pana_agent", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_opt_timezone,\r\n{ "Time-zone", "dhcpv6.timezone", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_opt_tzdb,\r\n{ "TZ-database", "dhcpv6.tzdb", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_lq_query,\r\n{ "Query-type", "dhcpv6.lq_query", FT_UINT8, BASE_DEC, VALS(lq_query_vals), 0, NULL, HFILL }},\r\n{ &hf_lq_query_link_address,\r\n{ "Link address", "dhcpv6.lq_query_link_address", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_clt_time,\r\n{ "Clt_time", "dhcpv6.clt_time", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL}},\r\n{ &hf_lq_relay_data_peer_addr,\r\n{ "Peer address", "dhcpv6.lq_relay_data_peer_addr", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_lq_relay_data_msg,\r\n{ "DHCPv6 relay message", "dhcpv6.lq_relay_data_msg", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_lq_client_link,\r\n{ "LQ client links address", "dhcpv6.lq_client_link", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_capwap_ac_v6,\r\n{ "CAPWAP Access Controllers address", "dhcpv6.capwap_ac_v6", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_aftr_name,\r\n{ "DS-Lite AFTR Name", "dhcpv6.aftr_name", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_iaprefix_pref_lifetime,\r\n{ "Preferred lifetime", "dhcpv6.iaprefix.pref_lifetime", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL}},\r\n{ &hf_iaprefix_valid_lifetime,\r\n{ "Valid lifetime", "dhcpv6.iaprefix.valid_lifetime", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL}},\r\n{ &hf_iaprefix_pref_len,\r\n{ "Prefix length", "dhcpv6.iaprefix.pref_len", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_iaprefix_pref_addr,\r\n{ "Prefix address", "dhcpv6.iaprefix.pref_addr", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_mip6_ha,\r\n{ "Home Agent", "dhcpv6.mip6_home_agent", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_mip6_hoa,\r\n{ "Home Address", "dhcpv6.mip6_home_address", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_nai,\r\n{ "NAI", "dhcpv6.nai", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_pd_exclude_pref_len,\r\n{ "Prefix length", "dhcpv6.pd_exclude.pref_len", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_pd_exclude_subnet_id,\r\n{ "IPv6 subnet ID", "dhcpv6.pd_exclude.subnet_id", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_option_ntpserver_type,\r\n{ "Suboption", "dhcpv6.ntpserver.option.type", FT_UINT16, BASE_DEC, VALS(ntp_server_opttype_vals), 0x0, NULL, HFILL}},\r\n{ &hf_option_ntpserver_length,\r\n{ "Length", "dhcpv6.ntpserver.option.length", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_option_ntpserver_addr,\r\n{ "NTP Server Address", "dhcpv6.ntpserver.addr", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_option_ntpserver_mc_addr,\r\n{ "NTP Multicast Address", "dhcpv6.ntpserver.mc_addr", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_option_ntpserver_fqdn,\r\n{ "NTP Server FQDN", "dhcpv6.ntpserver.fqdn", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_packetcable_ccc_suboption,\r\n{ "Sub element", "dhcpv6.packetcable.ccc.suboption", FT_UINT16, BASE_DEC, VALS(pkt_ccc_opt_vals), 0, NULL, HFILL }},\r\n{ &hf_packetcable_ccc_pri_dhcp,\r\n{ "Primary DHCP", "dhcpv6.packetcable.ccc.pri_dhcp", FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_ccc_sec_dhcp,\r\n{ "Secondary DHCP", "dhcpv6.packetcable.ccc.sec_dhcp", FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_suboption,\r\n{ "Sub element", "dhcpv6.packetcable.cccV6.suboption", FT_UINT16, BASE_DEC | BASE_EXT_STRING, &pkt_cccV6_opt_vals_ext, 0, NULL, HFILL }},\r\n{ &hf_modem_capabilities_encoding_type,\r\n{ "Type", "dhcpv6.docsis.cccV6.tlv5.suboption", FT_UINT16, BASE_DEC | BASE_EXT_STRING, &modem_capabilities_encoding_ext, 0, NULL, HFILL }},\r\n{ &hf_eue_capabilities_encoding_type,\r\n{ "Type", "dhcpv6.packetcable.cccV6.tlv5.suboption", FT_UINT16, BASE_DEC | BASE_EXT_STRING, &eue_capabilities_encoding_ext, 0, NULL, HFILL }},\r\n{ &hf_capabilities_encoding_length,\r\n{ "Length", "dhcpv6.cccV6.tlv5.suboption.length", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_capabilities_encoding_bytes,\r\n{ "Value", "dhcpv6.cccV6.tlv5.suboption.value", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_capabilities_encoding_number,\r\n{ "Value", "dhcpv6.cccV6.tlv5.suboption.value_number", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_pri_dss,\r\n{ "Primary SSID", "dhcpv6.packetcable.cccV6.pri_dss", FT_STRINGZ, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_sec_dss,\r\n{ "Secondary SSID", "dhcpv6.packetcable.cccV6.sec_dss", FT_STRINGZ, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_prov_srv_type,\r\n{ "Type", "dhcpv6.packetcable.cccV6.prov_srv.type", FT_UINT8, BASE_DEC, VALS(pkt_cccV6_prov_srv_type_vals), 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_prov_srv_fqdn,\r\n{ "FQDN", "dhcpv6.packetcable.cccV6.prov_srv.fqdn", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_prov_srv_ipv6,\r\n{ "IPv6 address", "dhcpv6.packetcable.cccV6.prov_srv.ipv6", FT_IPv6, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_as_krb_nominal_timeout,\r\n{ "Nominal Timeout", "dhcpv6.packetcable.cccV6.as_krb.nominal_timeout", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_as_krb_max_timeout,\r\n{ "Maximum Timeout", "dhcpv6.packetcable.cccV6.as_krb.max_timeout", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_as_krb_max_retry_count,\r\n{ "Maximum Retry Count", "dhcpv6.packetcable.cccV6.as_krb.max_retry_count", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_ap_krb_nominal_timeout,\r\n{ "Nominal Timeout", "dhcpv6.packetcable.cccV6.ap_krb.nominal_timeout", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_ap_krb_max_timeout,\r\n{ "Maximum Timeout", "dhcpv6.packetcable.cccV6.ap_krb.max_timeout", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_ap_krb_max_retry_count,\r\n{ "Maximum Retry Count", "dhcpv6.packetcable.cccV6.ap_krb.max_retry_count", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_krb_realm,\r\n{ "KRB Realm", "dhcpv6.packetcable.cccV6.krb_realm", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_tgt_flag,\r\n{ "TGT Flags", "dhcpv6.packetcable.cccV6.tgt_flag", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_tgt_flag_fetch,\r\n{ "Fetch TGT", "dhcpv6.packetcable.cccV6.tgt_flag.fetch", FT_BOOLEAN, 8, TFS(&tfs_true_false), 0x01, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_prov_timer,\r\n{ "Provisioning timer", "dhcpv6.packetcable.cccV6.prov_timer", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_sec_tcm,\r\n{ "SEC TCM Flags", "dhcpv6.packetcable.cccV6.sec_tcm", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_sec_tcm_provisioning_server,\r\n{ "Provisioning Server", "dhcpv6.packetcable.cccV6.sec_tcm.provisioning_server", FT_BOOLEAN, 16, TFS(&tfs_on_off), 0x01, NULL, HFILL }},\r\n{ &hf_packetcable_cccV6_sec_tcm_call_manager_server,\r\n{ "Call Manager Servers", "dhcpv6.packetcable.cccV6.tgt_flag.call_manager_server", FT_BOOLEAN, 16, TFS(&tfs_on_off), 0x02, NULL, HFILL }},\r\n{ &hf_cablelabs_opts,\r\n{ "Suboption", "dhcpv6.cablelabs.opt", FT_UINT16, BASE_DEC | BASE_EXT_STRING, &cl_vendor_subopt_values_ext, 0, NULL, HFILL }},\r\n{ &hf_cablelabs_ipv6_server,\r\n{ "IPv6 address", "dhcpv6.cablelabs.ipv6_server", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_cablelabs_docsis_version_number,\r\n{ "DOCSIS Version Number", "dhcpv6.cablelabs.docsis_version_number", FT_UINT16, BASE_CUSTOM, CF_FUNC(cablelabs_fmt_docsis_version), 0x0, NULL, HFILL}},\r\n{ &hf_cablelabs_interface_id,\r\n{ "Interface-ID", "dhcpv6.cablelabs.interface_id", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_cablelabs_interface_id_link_address,\r\n{ "Link Address", "dhcpv6.cablelabs.interface_id_link_address", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_dhcpv6,\r\n&ett_dhcpv6_option,\r\n&ett_dhcpv6_option_vsoption,\r\n&ett_dhcpv6_vendor_option,\r\n&ett_dhcpv6_pkt_option,\r\n&ett_dhcpv6_netserver_option,\r\n&ett_dhcpv6_tlv5_type,\r\n&ett_dhcpv6_sip_server_domain_search_list_option,\r\n&ett_dhcpv6_dns_domain_search_list_option,\r\n&ett_dhcpv6_nis_domain_name_option,\r\n&ett_dhcpv6_nisp_domain_name_option,\r\n&ett_dhcpv6_bcmcs_servers_domain_search_list_option,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_dhcpv6_bogus_length, { "dhcpv6.bogus_length", PI_MALFORMED, PI_ERROR, "Bogus length", EXPFILL }},\r\n{ &ei_dhcpv6_malformed_option, { "dhcpv6.malformed_option", PI_MALFORMED, PI_ERROR, "Malformed option", EXPFILL }},\r\n{ &ei_dhcpv6_no_suboption_len, { "dhcpv6.no_suboption_len", PI_PROTOCOL, PI_WARN, "no room left in option for suboption length", EXPFILL }},\r\n{ &ei_dhcpv6_invalid_time_value, { "dhcpv6.invalid_time_value", PI_PROTOCOL, PI_WARN, "Invalid time value", EXPFILL }},\r\n{ &ei_dhcpv6_invalid_type, { "dhcpv6.invalid_type", PI_PROTOCOL, PI_WARN, "Invalid type", EXPFILL }},\r\n{ &ei_dhcpv6_malformed_dns, { "dhcpv6.malformed_dns", PI_PROTOCOL, PI_WARN, "Malformed DNS name record (MS Vista client?)", EXPFILL }},\r\n{ &ei_dhcpv6_error_hopcount, { "dhcpv6.error_hopcount", PI_PROTOCOL, PI_WARN, "Detected error on hop-count", EXPFILL }},\r\n};\r\nstatic hf_register_info bulk_leasequery_hf[] = {\r\n{ &hf_dhcpv6_bulk_leasequery_size,\r\n{ "Message size", "dhcpv6.bulk_leasequery.size", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_dhcpv6_bulk_leasequery_msgtype,\r\n{ "Message type", "dhcpv6.bulk_leasequery.msgtype", FT_UINT8, BASE_DEC | BASE_EXT_STRING, &msgtype_vals_ext, 0x0, NULL, HFILL }},\r\n{ &hf_dhcpv6_bulk_leasequery_reserved,\r\n{ "Reserved", "dhcpv6.bulk_leasequery.reserved", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_dhcpv6_bulk_leasequery_trans_id,\r\n{ "Transaction ID", "dhcpv6.bulk_leasequery.trans_id", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett_bulk_leasequery[] = {\r\n&ett_dhcpv6_bulk_leasequery,\r\n&ett_dhcpv6_bulk_leasequery_options\r\n};\r\nstatic ei_register_info ei_bulk_leasequery[] = {\r\n{ &ei_dhcpv6_bulk_leasequery_bad_query_type, { "dhcpv6.bulk_leasequery.bad_query_type", PI_MALFORMED, PI_WARN, "LQ-QUERY: Query types only supported by Bulk Leasequery", EXPFILL }},\r\n{ &ei_dhcpv6_bulk_leasequery_no_lq_relay_data, { "dhcpv6.bulk_leasequery.no_lq_relay_data", PI_MALFORMED, PI_WARN, "LQ_RELAY_DATA: Not allowed in Bulk Leasequery", EXPFILL }},\r\n{ &ei_dhcpv6_bulk_leasequery_bad_msg_type, { "dhcpv6.bulk_leasequery.bad_msg_type", PI_MALFORMED, PI_WARN, "Message Type %d not allowed by DHCPv6 Bulk Leasequery", EXPFILL }},\r\n};\r\nexpert_module_t *expert_dhcpv6;\r\nexpert_module_t *expert_dhcpv6_bulk_leasequery;\r\nproto_dhcpv6 = proto_register_protocol("DHCPv6", "DHCPv6", "dhcpv6");\r\nproto_register_field_array(proto_dhcpv6, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_dhcpv6 = expert_register_protocol(proto_dhcpv6);\r\nexpert_register_field_array(expert_dhcpv6, ei, array_length(ei));\r\nproto_dhcpv6_bulk_leasequery = proto_register_protocol("DHCPv6 Bulk Leasequery", "DHCPv6 Bulk Leasequery", "dhcpv6.bulk_leasequery");\r\nproto_register_field_array(proto_dhcpv6_bulk_leasequery, bulk_leasequery_hf, array_length(bulk_leasequery_hf));\r\nproto_register_subtree_array(ett_bulk_leasequery, array_length(ett_bulk_leasequery));\r\nexpert_dhcpv6_bulk_leasequery = expert_register_protocol(proto_dhcpv6_bulk_leasequery);\r\nexpert_register_field_array(expert_dhcpv6_bulk_leasequery, ei_bulk_leasequery, array_length(ei_bulk_leasequery));\r\ndhcpv6_handle = register_dissector("dhcpv6", dissect_dhcpv6_stream, proto_dhcpv6);\r\ndhcpv6_module = prefs_register_protocol(proto_dhcpv6, NULL);\r\nprefs_register_bool_preference(dhcpv6_module, "cablelabs_interface_id",\r\n"Dissect Option 18 (Interface-Id) as CableLab option",\r\n"Whether Option 18 is dissected as CableLab or RFC 3315",\r\n&cablelabs_interface_id);\r\nbulkquery_module = prefs_register_protocol(proto_dhcpv6_bulk_leasequery, NULL);\r\nprefs_register_bool_preference(bulkquery_module, "desegment",\r\n"Desegment all Bulk Leasequery messages spanning multiple TCP segments",\r\n"Whether the Bulk Leasequery dissector should desegment all messages spanning multiple TCP segments",\r\n&dhcpv6_bulk_leasequery_desegment);\r\n}\r\nvoid\r\nproto_reg_handoff_dhcpv6(void)\r\n{\r\ndissector_handle_t dhcpv6_bulkquery_handle;\r\ndissector_add_uint("udp.port", UDP_PORT_DHCPV6_DOWNSTREAM, dhcpv6_handle);\r\ndissector_add_uint("udp.port", UDP_PORT_DHCPV6_UPSTREAM, dhcpv6_handle);\r\ndhcpv6_bulkquery_handle = create_dissector_handle(dissect_dhcpv6_bulk_leasequery,\r\nproto_dhcpv6_bulk_leasequery);\r\ndissector_add_uint("tcp.port", UDP_PORT_DHCPV6_UPSTREAM, dhcpv6_bulkquery_handle);\r\n}
