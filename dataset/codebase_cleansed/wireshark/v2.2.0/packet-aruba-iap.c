static int\r\ndissect_aruba_iap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *ti;\r\nproto_tree *aruba_iap_tree;\r\nguint16 magic;\r\nguint8 type;\r\nint offset = 0;\r\nmagic = tvb_get_ntohs(tvb, offset);\r\nif(magic != MAGIC_IAP)\r\n{\r\nreturn 0;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "IAP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nti = proto_tree_add_item(tree, proto_aruba_iap, tvb, 0, -1, ENC_NA);\r\naruba_iap_tree = proto_item_add_subtree(ti, ett_aruba_iap);\r\nproto_tree_add_item(aruba_iap_tree, hf_iap_magic, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(aruba_iap_tree, hf_iap_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Aruba Instant AP");\r\nproto_tree_add_item(aruba_iap_tree, hf_iap_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\ntype = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\nproto_tree_add_item(aruba_iap_tree, hf_iap_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(aruba_iap_tree, hf_iap_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif(type == 3 || type == 4 || type == 5 || type == 7){\r\nproto_tree_add_item(aruba_iap_tree, hf_iap_status, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(aruba_iap_tree, hf_iap_uptime, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(aruba_iap_tree, hf_iap_vc_ip, tvb, offset, 4, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " VC IP: %s", tvb_ip_to_str(tvb, offset));\r\noffset += 4;\r\nproto_tree_add_item(aruba_iap_tree, hf_iap_unknown_uint, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(aruba_iap_tree, hf_iap_pvid, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(aruba_iap_tree, hf_iap_unknown_uint, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(aruba_iap_tree, hf_iap_unknown_bytes, tvb, offset, -1, ENC_NA);\r\n} else {\r\nproto_tree_add_item(aruba_iap_tree, hf_iap_unknown_bytes, tvb, offset, -1, ENC_NA);\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nvoid\r\nproto_register_aruba_iap(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_iap_magic,\r\n{ "Magic", "aruba_iap.magic", FT_UINT16, BASE_HEX, NULL,0x0,\r\n"Magic Number of IAP trafic (Always 0x8ffd)", HFILL}},\r\n{ &hf_iap_version,\r\n{ "Version", "aruba_iap.version", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}},\r\n{ &hf_iap_type,\r\n{ "Type", "aruba_iap.type", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Type of message", HFILL}},\r\n{ &hf_iap_length,\r\n{ "Length", "aruba_iap.length", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}},\r\n{ &hf_iap_id,\r\n{ "Id", "aruba_iap.id", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}},\r\n{ &hf_iap_status,\r\n{ "Status", "aruba_iap.status", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}},\r\n{ &hf_iap_uptime,\r\n{ "Uptime", "aruba_iap.uptime", FT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}},\r\n{ &hf_iap_vc_ip,\r\n{ "VC IP", "aruba_iap.vc_ip", FT_IPv4, BASE_NONE, NULL, 0x0,\r\n"Address IP of Virtual Controller", HFILL}},\r\n{ &hf_iap_pvid,\r\n{ "PVID (Port Vlan ID)", "aruba_iap.pvid", FT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Vlan ID (of Uplink)", HFILL}},\r\n{ &hf_iap_unknown_bytes,\r\n{ "Unknown", "aruba_iap.unknown.bytes", FT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Unknown Data...", HFILL}},\r\n{ &hf_iap_unknown_uint,\r\n{ "Unknown", "aruba_iap.unknown.uint", FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\r\n"Unknown (UINT) Data...", HFILL}},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_aruba_iap,\r\n};\r\nproto_aruba_iap = proto_register_protocol("Aruba Instant AP Protocol",\r\n"aruba_iap", "aruba_iap");\r\nproto_register_field_array(proto_aruba_iap, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_aruba_iap(void)\r\n{\r\ndissector_handle_t iap_handle;\r\niap_handle = create_dissector_handle(dissect_aruba_iap, proto_aruba_iap);\r\ndissector_add_uint("ethertype", ETHERTYPE_IAP, iap_handle);\r\n}
