static void\r\nrs00(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_00_version, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_00_max_fruid, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_00_ipmc_fruid, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq01(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (tvb_captured_length(tvb) > 0) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_01_rq_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nif (tvb_captured_length(tvb) > 1) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_01_rq_addr_key_type, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nif (tvb_captured_length(tvb) > 2) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_01_rq_addr_key, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nif (tvb_captured_length(tvb) > 3) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_01_rq_site_type, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrs01(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_01_rs_hwaddr, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_01_rs_ipmbaddr, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_01_rs_rsrv, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_01_rs_fruid, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_01_rs_site_num, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_01_rs_site_type, tvb, 5, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs02(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nipmi_add_typelen(tree, hf_ipmi_picmg_02_shelf_address, hf_ipmi_picmg_02_shelf_type, hf_ipmi_picmg_02_shelf_length, tvb, 0, TRUE);\r\n}\r\nstatic void\r\nrq03(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nipmi_add_typelen(tree, hf_ipmi_picmg_03_shelf_address, hf_ipmi_picmg_03_shelf_type, hf_ipmi_picmg_03_shelf_length, tvb, 0, TRUE);\r\n}\r\nstatic void\r\nrq04(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_04_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_04_cmd, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq05(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_05_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs05(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_picmg_05_led3, &hf_ipmi_picmg_05_led2,\r\n&hf_ipmi_picmg_05_led1, &hf_ipmi_picmg_05_blue_led, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "General Status LEDs: ", "None",\r\nett_ipmi_picmg_05_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_05_app_leds, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq06(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_06_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_06_ledid, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs06(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_picmg_06_cap_white, &hf_ipmi_picmg_06_cap_orange,\r\n&hf_ipmi_picmg_06_cap_amber, &hf_ipmi_picmg_06_cap_green, &hf_ipmi_picmg_06_cap_red,\r\n&hf_ipmi_picmg_06_cap_blue, NULL };\r\nstatic const int *byte2[] = { &hf_ipmi_picmg_06_default_local_color, NULL };\r\nstatic const int *byte3[] = { &hf_ipmi_picmg_06_default_override_color, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Color capabilities: ", "None",\r\nett_ipmi_picmg_06_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_picmg_06_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_bitmask_text(tree, tvb, 2, 1, NULL, NULL,\r\nett_ipmi_picmg_06_byte3, byte3, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nparse_led_state(proto_tree *tree, tvbuff_t *tvb, guint offs, const char *desc)\r\n{\r\nstatic const int *color[] = { &hf_ipmi_picmg_led_color, NULL };\r\nstatic const value_string funcs[] = {\r\n{ 0x00, "LED Off override" },\r\n{ 0xfb, "Lamp Test state" },\r\n{ 0xfc, "Restore Local Control" },\r\n{ 0xfd, "Reserved" },\r\n{ 0xfe, "Reserved" },\r\n{ 0xff, "LED On override" },\r\n{ 0, NULL }\r\n};\r\nproto_item *ti;\r\nguint8 v;\r\nv = tvb_get_guint8(tvb, offs);\r\nproto_tree_add_uint_format(tree, hf_ipmi_picmg_led_function, tvb, offs, 1,\r\nv, "%sFunction: %s (0x%02x)", desc,\r\nval_to_str(v, funcs, "LED Blinking override, off-duration %d0ms"),\r\nv);\r\nv = tvb_get_guint8(tvb, offs + 1);\r\nproto_tree_add_uint_format(tree, hf_ipmi_picmg_led_on_duration, tvb, offs + 1, 1,\r\nv, "%sOn-duration: %d0ms", desc, v);\r\nv = tvb_get_guint8(tvb, offs + 2) & 0x0f;\r\nti = proto_tree_add_bitmask_text(tree, tvb, offs + 2, 1,\r\nNULL, NULL, ett_ipmi_picmg_led_color, color, ENC_LITTLE_ENDIAN, 0);\r\nproto_item_set_text(ti, "%sColor: %s", desc, val_to_str_const(v, led_color_vals, "Reserved"));\r\n}\r\nstatic void\r\nrq07(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_07_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_07_ledid, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nparse_led_state(tree, tvb, 2, "");\r\n}\r\nstatic void\r\nrq08(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_08_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_08_ledid, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs08(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_picmg_08_state_lamptest, &hf_ipmi_picmg_08_state_override,\r\n&hf_ipmi_picmg_08_state_local, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "LED States: ", "None",\r\nett_ipmi_picmg_08_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nparse_led_state(tree, tvb, 1, "Local Control ");\r\nif (tvb_captured_length(tvb) > 4) {\r\nparse_led_state(tree, tvb, 4, "Override ");\r\n}\r\nif (tvb_captured_length(tvb) > 7) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_08_lamptest_duration, tvb, 7, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nparse_ipmb_state(proto_tree *tree, tvbuff_t *tvb, guint offs, int hf, int hf_link, int hf_state, int ett)\r\n{\r\nchar buf[32];\r\nconst char *desc;\r\nproto_tree *s_tree;\r\nproto_item *ti;\r\nguint8 v, num;\r\nv = tvb_get_guint8(tvb, offs);\r\nif (v == 0xff) {\r\nproto_tree_add_uint_format_value(tree, hf, tvb, 0, 1,\r\nv, "Don't change (0xff)");\r\n} else {\r\nnum = v >> 1;\r\nif (!num) {\r\ndesc = "All Links";\r\n} else if (num < 0x60) {\r\ng_snprintf(buf, sizeof(buf), "Link #%d", num);\r\ndesc = buf;\r\n} else {\r\ndesc = "Reserved";\r\n}\r\nti = proto_tree_add_uint_format_value(tree, hf, tvb, 0, 1,\r\nv, "%s, %s", desc, (v & 1) ? "Local Control" : "Override");\r\ns_tree = proto_item_add_subtree(ti, ett);\r\nproto_tree_add_uint_format_value(s_tree, hf_link, tvb, 0, 1, v, "%s (0x%02x)",\r\ndesc, num);\r\nproto_tree_add_item(s_tree, hf_state, tvb, 0, 1, ENC_NA);\r\n}\r\n}\r\nstatic void\r\nrq09(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nparse_ipmb_state(tree, tvb, 0, hf_ipmi_picmg_09_ipmba, hf_ipmi_picmg_09_ipmba_link, hf_ipmi_picmg_09_ipmba_state, ett_ipmi_picmg_09_ipmba);\r\nparse_ipmb_state(tree, tvb, 1, hf_ipmi_picmg_09_ipmbb, hf_ipmi_picmg_09_ipmbb_link, hf_ipmi_picmg_09_ipmbb_state, ett_ipmi_picmg_09_ipmbb);\r\n}\r\nstatic void\r\nrq0a(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte2[] = { &hf_ipmi_picmg_0a_msk_d_locked, &hf_ipmi_picmg_0a_msk_locked, NULL };\r\nstatic const int *byte3[] = { &hf_ipmi_picmg_0a_d_locked, &hf_ipmi_picmg_0a_locked, NULL };\r\nproto_tree_add_item(tree, hf_ipmi_picmg_0a_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, "Will affect bits: ", "None",\r\nett_ipmi_picmg_0a_byte2, byte2, ENC_LITTLE_ENDIAN, BMT_NO_TFS);\r\nproto_tree_add_bitmask_text(tree, tvb, 2, 1, "Activation Policy Set Bits: ", NULL,\r\nett_ipmi_picmg_0a_byte3, byte3, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrq0b(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_0b_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs0b(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_picmg_0b_d_locked, &hf_ipmi_picmg_0b_locked, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "Activation Policy Bits: ", NULL,\r\nett_ipmi_picmg_0b_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrq0c(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_0c_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_0c_cmd, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq0d(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_0d_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nif (tvb_captured_length(tvb) > 1) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_0d_start, tvb, 1, 2, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrs0d(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_0d_recordid, tvb, 0, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nparse_link_info_state(proto_tree *tree, tvbuff_t *tvb, guint offs, const char *num, const value_string *vs)\r\n{\r\nstatic const int *link_info[] = { &hf_ipmi_picmg_linkinfo_grpid, &hf_ipmi_picmg_linkinfo_type_ext,\r\n&hf_ipmi_picmg_linkinfo_type, &hf_ipmi_picmg_linkinfo_ports, &hf_ipmi_picmg_linkinfo_iface,\r\n&hf_ipmi_picmg_linkinfo_chan, NULL };\r\nguint8 v = tvb_get_guint8(tvb, offs + 4);\r\nchar buf[32];\r\ng_snprintf(buf, sizeof(buf), "Link info%s: ", num);\r\nproto_tree_add_bitmask_text(tree, tvb, offs, 4, buf, NULL,\r\nett_ipmi_picmg_link_info, link_info, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_uint_format(tree, hf_ipmi_picmg_linkinfo_state, tvb, offs + 4, 1,\r\nv, "State%s: %s (0x%02x)", num, val_to_str_const(v, vs, "Reserved"), v);\r\n}\r\nstatic void\r\nrq0e(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const value_string state_vals[] = {\r\n{ 0x00, "Disable" },\r\n{ 0x01, "Enable" },\r\n{ 0, NULL }\r\n};\r\nparse_link_info_state(tree, tvb, 0, "", state_vals);\r\n}\r\nstatic void\r\nrq0f(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *chan[] = { &hf_ipmi_picmg_0f_iface, &hf_ipmi_picmg_0f_chan, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_picmg_0f_chan, chan, ENC_LITTLE_ENDIAN, 0);\r\nif (tvb_captured_length(tvb) > 1) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1a_flags, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrs0f(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const value_string state_vals[] = {\r\n{ 0x00, "Disabled" },\r\n{ 0x01, "Enabled" },\r\n{ 0x02, "Disabled, Extended Inactive State Link" },\r\n{ 0x03, "Enabled, Extended Inactive State Link" },\r\n{ 0, NULL }\r\n};\r\nif (tvb_captured_length(tvb) > 0) {\r\nparse_link_info_state(tree, tvb, 0, " 1", state_vals);\r\n}\r\nif (tvb_captured_length(tvb) > 5) {\r\nparse_link_info_state(tree, tvb, 5, " 2", state_vals);\r\n}\r\nif (tvb_captured_length(tvb) > 10) {\r\nparse_link_info_state(tree, tvb, 10, " 3", state_vals);\r\n}\r\nif (tvb_captured_length(tvb) > 15) {\r\nparse_link_info_state(tree, tvb, 15, " 4", state_vals);\r\n}\r\n}\r\nstatic void\r\nrq10(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_10_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs10(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_10_nslots, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_10_ipmc_loc, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq11(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const value_string plvl_vals[] = {\r\n{ 0x00, "Power Off" },\r\n{ 0xff, "Do not change" },\r\n{ 0, NULL }\r\n};\r\nguint8 v = tvb_get_guint8(tvb, 1);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_11_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_picmg_11_power_level, tvb, 1, 1,\r\nv, "%s", val_to_str(v, plvl_vals, "Power Level %d"));\r\nproto_tree_add_item(tree, hf_ipmi_picmg_11_set_to_desired, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq12(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_12_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_12_pwr_type, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs12(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_picmg_12_dynamic, &hf_ipmi_picmg_12_pwr_lvl, NULL };\r\nguint8 v, v2, i;\r\nguint32 tmp, max;\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL, ett_ipmi_picmg_12_byte1, byte1, ENC_LITTLE_ENDIAN, BMT_NO_FALSE);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_12_delay, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nv = tvb_get_guint8(tvb, 2);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_picmg_12_pwr_mult, tvb, 2, 1,\r\nv, "%d.%dW", v / 10, v % 10);\r\nmax = tvb_captured_length(tvb) - 3;\r\nif (max == 0) {\r\nmax = 1;\r\n} else if (max > 20) {\r\nmax = 20;\r\n}\r\nfor (i = 1; i <= max; i++) {\r\nv2 = tvb_get_guint8(tvb, 2 + i);\r\ntmp = (guint)v2 * v;\r\nproto_tree_add_uint_format(tree, hf_ipmi_picmg_12_pwr_draw, tvb, 2 + i, 1,\r\nv2, "Power Draw [%d]: %d.%dW (0x%02x)", i,\r\ntmp / 10, tmp % 10, v2);\r\n}\r\n}\r\nstatic void\r\nrq13(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (tvb_captured_length(tvb) > 0) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_13_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrq14(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_14_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs14(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *prop[] = { &hf_ipmi_picmg_14_local_control, NULL };\r\nproto_tree_add_item(tree, hf_ipmi_picmg_14_speed_min, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_14_speed_max, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_14_speed_norm, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 3, 1, "Fan Tray Properties: ", "None",\r\nett_ipmi_picmg_14_prop, prop, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrq15(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nguint8 v = tvb_get_guint8(tvb, 1);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_15_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_picmg_15_fan_level, tvb, 1, 1,\r\nv, "%s", val_to_str(v, fan_level_vals, "%d"));\r\nif (tvb_captured_length(tvb) > 2) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_15_local_enable, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrq16(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_16_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs16(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nguint8 v;\r\nv = tvb_get_guint8(tvb, 0);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_picmg_16_override_level, tvb, 0, 1,\r\nv, "%s", val_to_str(v, fan_level_vals, "%d"));\r\nif (tvb_captured_length(tvb) > 1) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_16_local_level, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nif (tvb_captured_length(tvb) > 2) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_16_local_enable, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrq17(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const value_string vals_17_cmd_fromshmm[] = {\r\n{ 0x00, "Query" },\r\n{ 0x01, "Release" },\r\n{ 0x02, "Force" },\r\n{ 0x03, "Bus Free" },\r\n{ 0, NULL }\r\n};\r\nstatic const value_string vals_17_cmd_toshmm[] = {\r\n{ 0x00, "Request" },\r\n{ 0x01, "Relinquish" },\r\n{ 0x02, "Notify" },\r\n{ 0, NULL }\r\n};\r\nguint to_shmm = ipmi_get_hdr(pinfo)->rs_sa == 0x20;\r\nguint cmd = tvb_get_guint8(tvb, 0);\r\nipmi_set_data(pinfo, 0, (to_shmm << 8) | cmd);\r\nif (!tree) {\r\nreturn;\r\n}\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_picmg_17_cmd, tvb, 0, 1,\r\ncmd, "%s (0x%02x)",\r\nval_to_str_const(cmd,\r\nto_shmm ? vals_17_cmd_toshmm : vals_17_cmd_fromshmm,\r\n"Reserved"),\r\ncmd);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_17_resid, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs17(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const value_string response_vals[] = {\r\n{ 0x000000, "In Control" },\r\n{ 0x000001, "No Control" },\r\n{ 0x000100, "Ack" },\r\n{ 0x000101, "Refused" },\r\n{ 0x000102, "No Control" },\r\n{ 0x000200, "Ack" },\r\n{ 0x000201, "No Control" },\r\n{ 0x000300, "Accept" },\r\n{ 0x000301, "Not Needed" },\r\n{ 0x010000, "Grant" },\r\n{ 0x010001, "Busy" },\r\n{ 0x010002, "Defer" },\r\n{ 0x010003, "Deny" },\r\n{ 0x010100, "Ack" },\r\n{ 0x010101, "Error" },\r\n{ 0x010200, "Ack" },\r\n{ 0x010201, "Error" },\r\n{ 0x010202, "Deny" },\r\n{ 0, NULL }\r\n};\r\nguint32 val;\r\nguint8 status;\r\nif (!ipmi_get_data(pinfo, 0, &val)) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_17_status, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nreturn;\r\n}\r\nstatus = tvb_get_guint8(tvb, 0);\r\nval = (val << 8) | status;\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_picmg_17_status, tvb, 0, 1,\r\nstatus, "%s (0x%02x)", val_to_str_const(val, response_vals, "Reserved"), status);\r\n}\r\nstatic void\r\nrq18(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_18_li_key_type, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_18_li_key, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs18(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_18_link_num, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_18_sensor_num, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nparse_amc_link_info_state(proto_tree *tree, tvbuff_t *tvb, guint offs)\r\n{\r\nstatic const int *amc_link_info[] = {\r\n&hf_ipmi_picmg_linkinfo_amc_ports,\r\n&hf_ipmi_picmg_linkinfo_amc_type,\r\n&hf_ipmi_picmg_linkinfo_amc_type_ext,\r\n&hf_ipmi_picmg_linkinfo_amc_grpid,\r\nNULL };\r\nstatic const int *amc_link_state[] = {\r\n&hf_ipmi_picmg_linkinfo_state_0,\r\n&hf_ipmi_picmg_linkinfo_state_1,\r\nNULL };\r\nproto_tree_add_bitmask(tree, tvb, offs, hf_ipmi_picmg_linkinfo,\r\nett_ipmi_picmg_link_info, amc_link_info, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, offs + 3, hf_ipmi_picmg_linkinfo_state,\r\nett_ipmi_picmg_link_state, amc_link_state, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq19(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_linkinfo_amc_chan, tvb, 0, 1,\r\nENC_LITTLE_ENDIAN);\r\nparse_amc_link_info_state(tree, tvb, 1);\r\nif (tvb_captured_length(tvb) > 5) {\r\nproto_tree_add_bitmask(tree, tvb, 5, hf_ipmi_picmg_linkinfo_dev,\r\nett_ipmi_picmg_link_dev, amc_link_dev, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrq1a(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_linkinfo_amc_chan, tvb, 0, 1,\r\nENC_LITTLE_ENDIAN);\r\nif (tvb_captured_length(tvb) > 1) {\r\nproto_tree_add_bitmask(tree, tvb, 1, hf_ipmi_picmg_linkinfo_dev,\r\nett_ipmi_picmg_link_state, amc_link_dev, ENC_LITTLE_ENDIAN);\r\n}\r\nif (tvb_captured_length(tvb) > 2) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1a_flags, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrs1a(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nguint len = tvb_captured_length(tvb);\r\nif (len > 0) {\r\nparse_amc_link_info_state(tree, tvb, 0);\r\n}\r\nif (len > 4) {\r\nparse_amc_link_info_state(tree, tvb, 4);\r\n}\r\nif (len > 8) {\r\nparse_amc_link_info_state(tree, tvb, 8);\r\n}\r\nif (len > 12) {\r\nparse_amc_link_info_state(tree, tvb, 12);\r\n}\r\n}\r\nstatic void\r\nrs1b(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1b_addr_active, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1b_addr_backup, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq1c(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1c_fan_site_number, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1c_fan_enable_state, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1c_fan_policy_timeout, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nif (tvb_captured_length(tvb) > 3) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1c_site_number, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1c_site_type, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrq1d(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1d_fan_site_number, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nif (tvb_captured_length(tvb) > 1) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1d_site_number, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1d_site_type, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrs1d(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1d_policy, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nif (tvb_captured_length(tvb) > 1) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1d_coverage, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrq1e(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1e_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs1e(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte1[] = { &hf_ipmi_picmg_1e_cap_diagintr,\r\n&hf_ipmi_picmg_1e_cap_graceful_reboot, &hf_ipmi_picmg_1e_cap_warm_reset, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "FRU Control Capabilities: ", "None",\r\nett_ipmi_picmg_1e_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrq1f(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1f_rq_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1f_rq_op, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1f_rq_lockid, tvb, 2, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs1f(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_1f_rs_lockid, tvb, 0, 2, ENC_LITTLE_ENDIAN);\r\nipmi_add_timestamp(tree, hf_ipmi_picmg_1f_rs_tstamp, tvb, 2);\r\n}\r\nstatic void\r\nrq20(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_20_fruid, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_20_lockid, tvb, 1, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_20_offset, tvb, 3, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_20_data, tvb, 5, -1, ENC_NA);\r\n}\r\nstatic void\r\nrs20(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_20_count, tvb, 0, 1, ENC_NA);\r\n}\r\nstatic void\r\nrq21(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_21_addr_num, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs21(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int *byte9[] = { &hf_ipmi_picmg_21_is_shm, &hf_ipmi_picmg_21_addr_type, NULL };\r\nguint8 addrtype;\r\nipmi_add_timestamp(tree, hf_ipmi_picmg_21_tstamp, tvb, 0);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_21_addr_count, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_21_site_type, tvb, 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_21_site_num, tvb, 6, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_21_max_unavail, tvb, 7, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 8, 1, NULL, NULL, ett_ipmi_picmg_21_byte9, byte9, ENC_LITTLE_ENDIAN, 0);\r\naddrtype = tvb_get_guint8(tvb, 8) & 0x7f;\r\nif (addrtype == 0x01) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_21_ipaddr, tvb, 9, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_21_rmcpport, tvb, 13, 2, ENC_BIG_ENDIAN);\r\n};\r\n}\r\nstatic void\r\nrq22(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nipmi_set_data(pinfo, 0, tvb_get_guint8(tvb, 0));\r\nif (!tree) {\r\nreturn;\r\n}\r\nproto_tree_add_item(tree, hf_ipmi_picmg_22_feed_idx, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs22(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nguint32 offs = 0;\r\nguint16 v;\r\nguint i, max;\r\nproto_tree_add_item(tree, hf_ipmi_picmg_22_update_cnt, tvb, 0, 2, ENC_LITTLE_ENDIAN);\r\nmax = tvb_captured_length(tvb) / 2 - 1;\r\nif (!max) {\r\nmax = 1;\r\n}\r\nipmi_get_data(pinfo, 0, &offs);\r\nfor (i = 0; i < max; i++) {\r\nv = tvb_get_letohs(tvb, 2 + 2 * i);\r\nproto_tree_add_uint_format(tree, hf_ipmi_picmg_22_pwr_alloc, tvb, 2 + 2 * i, 2,\r\nv, "Power Feed [%d] Allocation: %d Watts", offs + i, v);\r\n}\r\n}\r\nstatic void\r\nrq23(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int * picmg_23_rq_byte2[] = {\r\n&hf_ipmi_picmg_23_slot_sel,\r\n&hf_ipmi_picmg_23_carrier_num,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(tree, tvb, 0, hf_ipmi_picmg_23_rq_byte2,\r\nett_ipmi_picmg_23_rq_byte2, picmg_23_rq_byte2,\r\nENC_LITTLE_ENDIAN);\r\nif ((tvb_get_guint8(tvb, 0) & 0xC0) == 0x80) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_01_rs_site_num,\r\ntvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_01_rs_site_type,\r\ntvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrs23(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const int * picmg_23_rs_byte5[] = {\r\n&hf_ipmi_picmg_23_slot_base,\r\n&hf_ipmi_picmg_23_tier_base,\r\n&hf_ipmi_picmg_23_orientation,\r\nNULL\r\n};\r\nproto_tree_add_item(tree, hf_ipmi_picmg_23_slot_num,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_23_tier_num,\r\ntvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, 2, hf_ipmi_picmg_23_rs_byte5,\r\nett_ipmi_picmg_23_rs_byte5, picmg_23_rs_byte5,\r\nENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_23_origin_x,\r\ntvb, 3, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_23_origin_y,\r\ntvb, 5, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nfmt_power_amps(gchar *s, guint32 v)\r\n{\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d.%dA", v / 10, v % 10);\r\n}\r\nstatic void\r\nrq24(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_24_channel,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_24_control,\r\ntvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_24_current,\r\ntvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_24_primary_pm,\r\ntvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_24_backup_pm,\r\ntvb, 4, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq25(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_25_start,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_25_count,\r\ntvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs25(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint * picmg_25_gstatus[] = {\r\n&hf_ipmi_picmg_25_fault,\r\n&hf_ipmi_picmg_25_pwr_good,\r\n&hf_ipmi_picmg_25_mp_good,\r\n&hf_ipmi_picmg_25_role,\r\nNULL\r\n};\r\nstatic const gint * picmg_25_cstatus[] = {\r\n&hf_ipmi_picmg_25_pwr_on,\r\n&hf_ipmi_picmg_25_pwr_ovr,\r\n&hf_ipmi_picmg_25_pwr,\r\n&hf_ipmi_picmg_25_enable,\r\n&hf_ipmi_picmg_25_mp_ovr,\r\n&hf_ipmi_picmg_25_mp,\r\n&hf_ipmi_picmg_25_ps1,\r\nNULL\r\n};\r\nguint i, len = tvb_captured_length(tvb);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_25_max,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, 1, hf_ipmi_picmg_25_gstatus,\r\nett_ipmi_picmg_25_rs_byte4, picmg_25_gstatus,\r\nENC_LITTLE_ENDIAN);\r\nfor (i = 2; i < len; i++) {\r\nproto_tree_add_bitmask(tree, tvb, i, hf_ipmi_picmg_25_cstatus,\r\nett_ipmi_picmg_25_rs_byte5, picmg_25_cstatus,\r\nENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrq26(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_26_pm_site,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs27(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint * picmg_27_status[] = {\r\n&hf_ipmi_picmg_27_pm_healthy,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(tree, tvb, 0, hf_ipmi_picmg_27_rs_byte3,\r\nett_ipmi_picmg_27_rs_byte3, picmg_27_status,\r\nENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nfmt_100ms(gchar *s, guint32 v)\r\n{\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d.%dS", v / 10, v % 10);\r\n}\r\nstatic void\r\nrq28(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint * picmg_28_flags[] = {\r\n&hf_ipmi_picmg_28_mch2,\r\n&hf_ipmi_picmg_28_mch1,\r\nNULL\r\n};\r\nproto_tree_add_item(tree, hf_ipmi_picmg_28_timeout,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, 1, hf_ipmi_picmg_28_rq_byte3,\r\nett_ipmi_picmg_28_rq_byte3, picmg_28_flags,\r\nENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs29(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint * picmg_29_caps[] = {\r\n&hf_ipmi_picmg_29_maj_rst,\r\n&hf_ipmi_picmg_29_min_rst,\r\n&hf_ipmi_picmg_29_alarm_cut,\r\n&hf_ipmi_picmg_29_test_mode,\r\n&hf_ipmi_picmg_29_pwr_alarm,\r\n&hf_ipmi_picmg_29_minor_alarm,\r\n&hf_ipmi_picmg_29_major_alarm,\r\n&hf_ipmi_picmg_29_crit_alarm,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(tree, tvb, 0, hf_ipmi_picmg_29_rs_byte3,\r\nett_ipmi_picmg_29_rs_byte3, picmg_29_caps,\r\nENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq2a(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_05_fruid,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_2a_alarm_id,\r\ntvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_2a_alarm_ctrl,\r\ntvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq2b(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_05_fruid,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_2a_alarm_id,\r\ntvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs2b(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_2b_alarm_state,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq2c(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_clock_id, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_clock_cfg, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask(tree, tvb, 2, hf_ipmi_picmg_clock_setting,\r\nett_ipmi_picmg_clock_setting, amc_clock_setting, ENC_LITTLE_ENDIAN);\r\nif (tvb_captured_length(tvb) > 3) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_clock_family, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_clock_accuracy, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_clock_frequency, tvb, 5, 4, ENC_LITTLE_ENDIAN);\r\n}\r\nif (tvb_captured_length(tvb) > 9) {\r\nproto_tree_add_bitmask(tree, tvb, 9, hf_ipmi_picmg_clock_resource,\r\nett_ipmi_picmg_clock_res, amc_clock_resource, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrq2d(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_clock_id, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nif (tvb_captured_length(tvb) > 1) {\r\nproto_tree_add_bitmask(tree, tvb, 1, hf_ipmi_picmg_clock_resource,\r\nett_ipmi_picmg_clock_res, amc_clock_resource, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrs2d(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_bitmask(tree, tvb, 0, hf_ipmi_picmg_clock_setting,\r\nett_ipmi_picmg_clock_setting, amc_clock_setting, ENC_LITTLE_ENDIAN);\r\nif (tvb_captured_length(tvb) > 1) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_clock_cfg, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_clock_family, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_clock_accuracy, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_clock_frequency, tvb, 4, 4, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nadd_component_bits(proto_tree *tree, tvbuff_t *tvb, guint offs, const char *desc)\r\n{\r\nstatic const gint *compbits[] = { &hf_ipmi_picmg_XX_comp7, &hf_ipmi_picmg_XX_comp6, &hf_ipmi_picmg_XX_comp5,\r\n&hf_ipmi_picmg_XX_comp4, &hf_ipmi_picmg_XX_comp3, &hf_ipmi_picmg_XX_comp2, &hf_ipmi_picmg_XX_comp1, &hf_ipmi_picmg_XX_comp0, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, offs, 1, desc, "None",\r\nett_ipmi_picmg_XX_compbits, compbits, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nrs2e(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte2[] = { &hf_ipmi_picmg_2e_upgrade_undesirable, &hf_ipmi_picmg_2e_auto_rollback_override,\r\n&hf_ipmi_picmg_2e_ipmc_degraded, &hf_ipmi_picmg_2e_deferred_activate, &hf_ipmi_picmg_2e_services_affected,\r\n&hf_ipmi_picmg_2e_manual_rollback, &hf_ipmi_picmg_2e_auto_rollback, &hf_ipmi_picmg_2e_self_test, NULL };\r\nproto_tree_add_item(tree, hf_ipmi_picmg_2e_version, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, "Capabilities: ", "None",\r\nett_ipmi_picmg_2e_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_2e_upgrade_tout, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_2e_selftest_tout, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_2e_rollback_tout, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_2e_inaccessibility_tout, tvb, 5, 1, ENC_LITTLE_ENDIAN);\r\nadd_component_bits(tree, tvb, 6, "Components present: ");\r\n}\r\nstatic void\r\nprop_00(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_picmg_prop00_cold_reset, &hf_ipmi_picmg_prop00_deferred_activation,\r\n&hf_ipmi_picmg_prop00_comparison, &hf_ipmi_picmg_prop00_preparation, &hf_ipmi_picmg_prop00_rollback, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, "General Component Properties: ", "None",\r\nett_ipmi_picmg_prop00_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\n}\r\nstatic void\r\nparse_version(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = { &hf_ipmi_picmg_prop01_fw_major, NULL };\r\nproto_tree_add_bitmask_text(tree, tvb, 0, 1, NULL, NULL,\r\nett_ipmi_picmg_prop01_byte1, byte1, ENC_LITTLE_ENDIAN, 0);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_prop01_fw_minor, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_prop01_fw_aux, tvb, 2, 4, ENC_NA);\r\n}\r\nstatic void\r\nprop_02(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nguint len = tvb_captured_length(tvb);\r\nif (len > 12) {\r\nlen = 12;\r\n}\r\nproto_tree_add_item(tree, hf_ipmi_picmg_prop02_desc, tvb, 0, len, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\nrq2f(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nguint8 pno = tvb_get_guint8(tvb, 1);\r\nconst char *desc;\r\nipmi_set_data(pinfo, 0, pno);\r\nif (!tree) {\r\nreturn;\r\n}\r\nif (pno < array_length(compprops)) {\r\ndesc = compprops[pno].name;\r\n} else if (pno >= 0xC0) {\r\ndesc = "OEM";\r\n} else {\r\ndesc = "Reserved";\r\n}\r\nproto_tree_add_item(tree, hf_ipmi_picmg_2f_comp_id, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_picmg_2f_comp_prop, tvb, 1, 1, pno,\r\n"%s (0x%02x)", desc, pno);\r\n}\r\nstatic void\r\nrs2f(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nguint32 pno;\r\nconst char *desc;\r\nproto_item *ti;\r\nif (!ipmi_get_data(pinfo, 0, &pno)) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_2f_prop_data, tvb, 0, -1, ENC_NA);\r\nreturn;\r\n}\r\nif (pno < array_length(compprops)) {\r\ndesc = compprops[pno].name;\r\n} else if (pno >= 0xC0) {\r\ndesc = "OEM";\r\n} else {\r\ndesc = "Reserved";\r\n}\r\nti = proto_tree_add_uint_format_value(tree, hf_ipmi_picmg_2f_comp_prop, tvb, 0, 0, pno, "%s (0x%02x)", desc, pno);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nif (pno < array_length(compprops)) {\r\ncompprops[pno].intrp(tvb, tree);\r\n} else {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_2f_prop_data, tvb, 0, -1, ENC_NA);\r\n}\r\n}\r\nstatic void\r\nrq31(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nadd_component_bits(tree, tvb, 0, "Components: ");\r\nproto_tree_add_item(tree, hf_ipmi_picmg_31_action, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq32(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_32_block, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_32_data, tvb, 1, -1, ENC_NA);\r\n}\r\nstatic void\r\nrs32(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (tvb_captured_length(tvb) > 0) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_32_sec_offs, tvb, 0, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_32_sec_len, tvb, 4, 4, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrq33(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_33_comp_id, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_33_img_len, tvb, 1, 4, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs34(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const guint8 sig = 0;\r\nstatic const gint *byte3[] = { &hf_ipmi_picmg_34_percentage, NULL };\r\nguint8 v;\r\nipmi_cmd_t *c;\r\nv = tvb_get_guint8(tvb, 0);\r\nc = ipmi_getcmd(ipmi_getnetfn(IPMI_GROUP_REQ, &sig), v);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_picmg_34_cmd, tvb, 0, 1, v,\r\n"%s (0x%02x)", c->desc, v);\r\nv = tvb_get_guint8(tvb, 1);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_picmg_34_ccode, tvb, 1, 1, v,\r\n"%s (0x%02x)", ipmi_get_completion_code(v, c), v);\r\nif (tvb_captured_length(tvb) > 2) {\r\nproto_tree_add_bitmask_text(tree, tvb, 2, 1, NULL, NULL,\r\nett_ipmi_picmg_34_byte3, byte3, ENC_LITTLE_ENDIAN, 0);\r\n}\r\n}\r\nstatic void\r\nrq35(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (tvb_captured_length(tvb) > 0) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_35_rollback_override, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrs36(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte2[] = { &hf_ipmi_picmg_36_fail_sel, &hf_ipmi_picmg_36_fail_sdr,\r\n&hf_ipmi_picmg_36_fail_bmc_fru, &hf_ipmi_picmg_36_fail_ipmb_sig, &hf_ipmi_picmg_36_fail_sdr_empty,\r\n&hf_ipmi_picmg_36_fail_iua, &hf_ipmi_picmg_36_fail_bb_fw, &hf_ipmi_picmg_36_fail_oper_fw, NULL };\r\nint res, fail;\r\nres = tvb_get_guint8(tvb, 0);\r\nfail = tvb_get_guint8(tvb, 1);\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_picmg_36_result, tvb, 0, 1,\r\nres, "%s (0x%02x)",\r\nval_to_str_const(res, vals_36_result, "Device-specific internal failure"),\r\nres);\r\nif (res == 0x55 || res == 0xff) {\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_picmg_36_fail, tvb, 1, 1,\r\nfail, "0x%02x (must be 0x00)",\r\nfail);\r\n} else if (res == 0x57) {\r\nproto_tree_add_bitmask(tree, tvb, 1, hf_ipmi_picmg_36_fail, ett_ipmi_picmg_36_byte2, byte2, ENC_LITTLE_ENDIAN);\r\n} else if (res == 0x60) {\r\nadd_component_bits(tree, tvb, 1, "Failed components: ");\r\n} else {\r\nproto_tree_add_uint_format_value(tree, hf_ipmi_picmg_36_fail, tvb, 1, 1,\r\nfail, "0x%02x (device-specific)", fail);\r\n}\r\n}\r\nstatic void\r\nrs37(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte2[] = { &hf_ipmi_picmg_37_percent, NULL };\r\nconst char *desc;\r\nswitch (ipmi_get_ccode(pinfo)) {\r\ncase 0x00: desc = "Components completed rollback: "; break;\r\ncase 0x80: desc = "Components (should be None): "; break;\r\ncase 0x81: desc = "Components failed to rollback: "; break;\r\ndefault: desc = "Components (ignored): "; break;\r\n}\r\nadd_component_bits(tree, tvb, 0, desc);\r\nif (tvb_captured_length(tvb) > 1) {\r\nproto_tree_add_bitmask_text(tree, tvb, 1, 1, NULL, NULL,\r\nett_ipmi_picmg_37_byte2, byte2, ENC_LITTLE_ENDIAN, 0);\r\n}\r\n}\r\nstatic void\r\nrq3e(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_id, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs3e(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *hpm2_caps[] = {\r\n&hf_ipmi_picmg_hpm2_dyn_ssn,\r\n&hf_ipmi_picmg_hpm2_ver_chg,\r\n&hf_ipmi_picmg_hpm2_ext_mgt,\r\n&hf_ipmi_picmg_hpm2_pkt_trc,\r\n&hf_ipmi_picmg_hpm2_sol_ext,\r\nNULL };\r\nguint8 hpm_x;\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_id, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_rev, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nhpm_x = tvb_get_guint8(tvb, 0);\r\nif (hpm_x == 2) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm2_mask, tvb, 2, 2, ENC_LITTLE_ENDIAN);\r\nif (tvb_captured_length(tvb) > 4) {\r\nproto_tree_add_bitmask(tree, tvb, 4, hf_ipmi_picmg_hpm2_caps,\r\nett_ipmi_picmg_hpm_caps, hpm2_caps, ENC_LITTLE_ENDIAN);\r\n}\r\nif (tvb_captured_length(tvb) > 5) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_oem_start,\r\ntvb, 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_oem_rev,\r\ntvb, 6, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nif (tvb_captured_length(tvb) > 7) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm2_sol_oem_start,\r\ntvb, 7, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm2_sol_oem_rev,\r\ntvb, 8, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n} else if (hpm_x == 3) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_oem_start,\r\ntvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_oem_rev,\r\ntvb, 3, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrq3f(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_cred_hnd,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_func_sel,\r\ntvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nif (!tvb_get_guint8(tvb, 1)) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_ipmi_rev,\r\ntvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nif (tvb_get_guint8(tvb, 2)) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_cipher_id,\r\ntvb, 3, 1, ENC_LITTLE_ENDIAN);\r\n} else {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_auth_type,\r\ntvb, 3, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_priv_level,\r\ntvb, 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_chn_num,\r\ntvb, 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_avail_time,\r\ntvb, 6, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_21_ipaddr,\r\ntvb, 10, 4, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrs3f(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nguint8 func;\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_cred_hnd,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_func_sel,\r\ntvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nfunc = tvb_get_guint8(tvb, 1);\r\nswitch (func) {\r\ncase 0:\r\ncase 1:\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_avail_time,\r\ntvb, 2, 4, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase 2:\r\ncase 3:\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_user_name,\r\ntvb, 2, 8, ENC_NA);\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_user_pwd,\r\ntvb, 2, 10, ENC_NA);\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_bmc_key,\r\ntvb, 2, 10, ENC_NA);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nrq40(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_01_rs_ipmbaddr,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_01_rs_fruid,\r\ntvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nif (tvb_captured_length(tvb) > 2) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_operation,\r\ntvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrs40(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_chn_num,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_ssn_hnd,\r\ntvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_ssn_hnd,\r\ntvb, 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_ssn_hnd,\r\ntvb, 3, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs41(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_power_draw,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_base_channels,\r\ntvb, 1, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_fabric_channels,\r\ntvb, 3, 2, ENC_LITTLE_ENDIAN);\r\nif (tvb_captured_length(tvb) > 5) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_update_channels,\r\ntvb, 5, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nif (tvb_captured_length(tvb) > 6) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_cross_channels,\r\ntvb, 6, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrs42(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *amc_resource_type[] = {\r\n&hf_ipmi_picmg_linkinfo_dev_type,\r\n&hf_ipmi_picmg_linkinfo_dev_id,\r\nNULL };\r\nguint8 num, i;\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_power_draw,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_num_chn_desc,\r\ntvb, 1, 1, ENC_LITTLE_ENDIAN);\r\nnum = tvb_get_guint8(tvb, 1);\r\nfor (i = 0; i < num; i++) {\r\nproto_tree_add_bitmask(tree, tvb, 2 + i * 5,\r\nhf_ipmi_picmg_linkinfo_dev, ett_ipmi_picmg_link_dev,\r\namc_resource_type, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_chn_mask,\r\ntvb, 3 + i * 5, 4, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrq43(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_ext_mgmt_state,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_polling_period,\r\ntvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs44(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_ext_mgmt_state,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq45(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_auth_pwr_state,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs46(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_auth_pwr_state,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg_hpm_amc_pwr_state,\r\ntvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq47(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg47_port,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_ipmi_picmg47_flags,\r\ntvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrs47(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nstatic const gint *byte1[] = {\r\n&hf_ipmi_picmg47_state,\r\n&hf_ipmi_picmg47_instance,\r\nNULL };\r\nproto_tree_add_bitmask(tree, tvb, 0, hf_ipmi_picmg47_assignment,\r\nett_ipmi_picmg_47_byte1, byte1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nrq48(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg_01_rs_ipmbaddr,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nif (tvb_captured_length(tvb) > 1) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg48_sub_fru_type,\r\ntvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nif (tvb_captured_length(tvb) > 2) {\r\nproto_tree_add_item(tree, hf_ipmi_picmg48_sub_fru_id,\r\ntvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nrs48(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_ipmi_picmg48_ip_source,\r\ntvb, 0, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nvoid\r\nproto_register_ipmi_picmg(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ipmi_picmg_led_function,\r\n{ "LED Function",\r\n"ipmi.led.function", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_led_on_duration,\r\n{ "On-duration",\r\n"ipmi.led.on_duration", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_led_color,\r\n{ "Color",\r\n"ipmi.led.color", FT_UINT8, BASE_HEX, VALS(led_color_vals), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_grpid,\r\n{ "Grouping ID",\r\n"ipmi.linkinfo.grpid", FT_UINT32, BASE_DEC, NULL, 0xff000000, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_type_ext,\r\n{ "Type extension",\r\n"ipmi.linkinfo.type_ext", FT_UINT32, BASE_HEX, NULL, 0x00f00000, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_type,\r\n{ "Type",\r\n"ipmi.linkinfo.type", FT_UINT32, BASE_HEX, VALS(linkinfo_type_vals), 0x000ff000, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_ports,\r\n{ "Ports",\r\n"ipmi.linkinfo.ports", FT_UINT32, BASE_HEX, VALS(linkinfo_ports_vals), 0x00000f00, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_iface,\r\n{ "Interface",\r\n"ipmi.linkinfo.iface", FT_UINT32, BASE_HEX, VALS(linkinfo_iface_vals), 0x000000c0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_chan,\r\n{ "Channel",\r\n"ipmi.linkinfo.chan", FT_UINT32, BASE_DEC, NULL, 0x0000003f, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_state,\r\n{ "State",\r\n"ipmi.linkinfo.state", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo,\r\n{ "Link Info",\r\n"ipmi.linkinfo", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_amc_chan,\r\n{ "Channel",\r\n"ipmi.linkinfo.chan", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_amc_ports,\r\n{ "Ports",\r\n"ipmi.linkinfo.ports", FT_UINT24, BASE_HEX, VALS(linkinfo_ports_vals), 0x00000f, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_amc_type,\r\n{ "Type",\r\n"ipmi.linkinfo.type", FT_UINT24, BASE_HEX, VALS(linkinfo_amc_type_vals), 0x000ff0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_amc_type_ext,\r\n{ "Type extension",\r\n"ipmi.linkinfo.type_ext", FT_UINT24, BASE_HEX, NULL, 0x00f000, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_amc_grpid,\r\n{ "Grouping ID",\r\n"ipmi.linkinfo.grpid", FT_UINT24, BASE_DEC, NULL, 0xff0000, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_state_0,\r\n{ "Enabled",\r\n"ipmi.linkinfo.state0", FT_BOOLEAN, 8, NULL, 0x1, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_state_1,\r\n{ "Extended Management Link",\r\n"ipmi.linkinfo.state1", FT_BOOLEAN, 8, NULL, 0x2, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_dev,\r\n{ "On-Carrier Device",\r\n"ipmi.linkinfo.dev", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_dev_type,\r\n{ "Device Type",\r\n"ipmi.linkinfo.dev.type", FT_UINT8, BASE_DEC, VALS(amc_resource_types), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_linkinfo_dev_id,\r\n{ "Device ID",\r\n"ipmi.linkinfo.dev.id", FT_UINT8, BASE_DEC_HEX, NULL, 0xF, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_clock_id,\r\n{ "Clock ID",\r\n"ipmi.clock.id", FT_UINT8, BASE_HEX, VALS(amc_clock_ids), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_clock_cfg,\r\n{ "Clock Configuration Descriptor Index",\r\n"ipmi.clock.cfg", FT_UINT8, BASE_DEC_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_clock_setting,\r\n{ "Clock Setting",\r\n"ipmi.clock.setting", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_clock_state,\r\n{ "Clock State",\r\n"ipmi.clock.state", FT_UINT8, BASE_DEC, VALS(enable_vals), 0x8, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_clock_dir,\r\n{ "Clock Direction",\r\n"ipmi.clock.dir", FT_UINT8, BASE_DEC, VALS(amc_clock_dirs), 0x4, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_clock_pll,\r\n{ "PLL Control",\r\n"ipmi.clock.pll", FT_UINT8, BASE_DEC, VALS(amc_clock_plls), 0x3, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_clock_family,\r\n{ "Clock Family",\r\n"ipmi.clock.family", FT_UINT8, BASE_HEX|BASE_RANGE_STRING, RVALS(amc_clock_families), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_clock_accuracy,\r\n{ "Clock Accuracy",\r\n"ipmi.clock.accu", FT_UINT8, BASE_HEX_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_clock_frequency,\r\n{ "Clock Frequency",\r\n"ipmi.clock.freq", FT_UINT32, BASE_DEC_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_clock_resource,\r\n{ "Clock Resource ID",\r\n"ipmi.clock.res", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_clock_resource_type,\r\n{ "Resource Type",\r\n"ipmi.clock.res.type", FT_UINT8, BASE_HEX, VALS(amc_clock_resource_types), 0xC0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_clock_resource_dev,\r\n{ "Device ID",\r\n"ipmi.clock.res.id", FT_UINT8, BASE_DEC, NULL, 0x0F, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_00_version,\r\n{ "PICMG Extension Version",\r\n"ipmi.picmg00.version", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_version), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_00_max_fruid,\r\n{ "Max FRU Device ID",\r\n"ipmi.picmg00.max_fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_00_ipmc_fruid,\r\n{ "FRU Device ID for IPMC",\r\n"ipmi.picmg00.ipmc_fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_01_rq_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg01.rq_fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_01_rq_addr_key_type,\r\n{ "Address Key Type",\r\n"ipmi.picmg01.rq_addr_key_type", FT_UINT8, BASE_HEX, VALS(addr_key_type_vals), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_01_rq_addr_key,\r\n{ "Address Key",\r\n"ipmi.picmg01.rq_addr_key", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_01_rq_site_type,\r\n{ "Site Type",\r\n"ipmi.picmg01.rq_site_type", FT_UINT8, BASE_HEX, VALS(site_type_vals), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_01_rs_hwaddr,\r\n{ "Hardware Address",\r\n"ipmi.picmg01.rs_hwaddr", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_01_rs_ipmbaddr,\r\n{ "IPMB Address",\r\n"ipmi.picmg01.rs_ipmbaddr", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_01_rs_rsrv,\r\n{ "Reserved (shall be 0xFF)",\r\n"ipmi.picmg01.rs_rsrv", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_01_rs_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg01.rs_fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_01_rs_site_num,\r\n{ "Site Number",\r\n"ipmi.picmg01.rs_site_num", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_01_rs_site_type,\r\n{ "Site Type",\r\n"ipmi.picmg01.rs_site_type", FT_UINT8, BASE_HEX, VALS(site_type_vals), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_02_shelf_address,\r\n{ "Shelf Address",\r\n"ipmi.picmg02.shelf_address", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_02_shelf_type,\r\n{ "Type",\r\n"ipmi.picmg02.shelf_type", FT_UINT8, BASE_DEC, NULL, 0xc0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_02_shelf_length,\r\n{ "Length",\r\n"ipmi.picmg02.shelf_length", FT_UINT8, BASE_DEC, NULL, 0x3f, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_03_shelf_address,\r\n{ "Shelf Address",\r\n"ipmi.picmg03.shelf_address", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_03_shelf_type,\r\n{ "Type",\r\n"ipmi.picmg03.shelf_type", FT_UINT8, BASE_DEC, NULL, 0xc0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_03_shelf_length,\r\n{ "Length",\r\n"ipmi.picmg03.shelf_length", FT_UINT8, BASE_DEC, NULL, 0x3f, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_04_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg04.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_04_cmd,\r\n{ "Command",\r\n"ipmi.picmg04.cmd", FT_UINT8, BASE_HEX, VALS(vals_04_cmd), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_05_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg05.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_05_led3,\r\n{ "LED 3",\r\n"ipmi.picmg05.led3", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_05_led2,\r\n{ "LED 2",\r\n"ipmi.picmg05.led2", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_05_led1,\r\n{ "LED 1",\r\n"ipmi.picmg05.led1", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_05_blue_led,\r\n{ "BLUE LED",\r\n"ipmi.picmg05.blue_led", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_05_app_leds,\r\n{ "Application-specific LED Count",\r\n"ipmi.picmg05.app_leds", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_06_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg06.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_06_ledid,\r\n{ "LED ID",\r\n"ipmi.picmg06.ledid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_06_cap_white,\r\n{ "White",\r\n"ipmi.picmg06.cap_white", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_06_cap_orange,\r\n{ "Orange",\r\n"ipmi.picmg06.cap_orange", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_06_cap_amber,\r\n{ "Amber",\r\n"ipmi.picmg06.cap_amber", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_06_cap_green,\r\n{ "Green",\r\n"ipmi.picmg06.cap_green", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_06_cap_red,\r\n{ "Red",\r\n"ipmi.picmg06.cap_red", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_06_cap_blue,\r\n{ "Blue",\r\n"ipmi.picmg06.cap_blue", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_06_default_local_color,\r\n{ "Default LED Color in Local Control state",\r\n"ipmi.picmg06.def_local", FT_UINT8, BASE_HEX, VALS(led_color_vals), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_06_default_override_color,\r\n{ "Default LED Color in Override state",\r\n"ipmi.picmg06.def_override", FT_UINT8, BASE_HEX, VALS(led_color_vals), 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_07_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg07.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_07_ledid,\r\n{ "LED ID",\r\n"ipmi.picmg07.ledid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_08_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg08.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_08_ledid,\r\n{ "LED ID",\r\n"ipmi.picmg08.ledid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_08_state_lamptest,\r\n{ "Lamp Test",\r\n"ipmi.picmg08.state_lamptest", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_08_state_override,\r\n{ "Override",\r\n"ipmi.picmg08.state_override", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_08_state_local,\r\n{ "Local Control",\r\n"ipmi.picmg08.state_local", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_08_lamptest_duration,\r\n{ "Lamp test duration",\r\n"ipmi.picmg08.lamptest_duration", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_09_ipmba,\r\n{ "IPMB-A State",\r\n"ipmi.picmg09.ipmba", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_09_ipmba_link,\r\n{ "Link",\r\n"ipmi.picmg09.ipmba_link", FT_UINT8, BASE_HEX, NULL, 0xFE, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_09_ipmba_state,\r\n{ "State",\r\n"ipmi.picmg09.ipmba_state", FT_BOOLEAN, 8, TFS(&tfs_local_control_override), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_09_ipmbb,\r\n{ "IPMB-B State",\r\n"ipmi.picmg09.ipmbb", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_09_ipmbb_link,\r\n{ "Link",\r\n"ipmi.picmg09.ipmbb_link", FT_UINT8, BASE_HEX, NULL, 0xFE, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_09_ipmbb_state,\r\n{ "State",\r\n"ipmi.picmg09.ipmbb_state", FT_BOOLEAN, 8, TFS(&tfs_local_control_override), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_0a_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg0a.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_0a_msk_d_locked,\r\n{ "Deactivation-Locked bit",\r\n"ipmi.picmg0a.msk_deactivation", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_0a_msk_locked,\r\n{ "Locked bit",\r\n"ipmi.picmg0a.msk_locked", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_0a_d_locked,\r\n{ "Deactivation-Locked bit",\r\n"ipmi.picmg0a.deactivation", FT_BOOLEAN, 8, TFS(&set_clear_tfs), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_0a_locked,\r\n{ "Locked bit",\r\n"ipmi.picmg0a.locked", FT_BOOLEAN, 8, TFS(&set_clear_tfs), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_0b_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg0b.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_0b_d_locked,\r\n{ "Deactivation-Locked bit",\r\n"ipmi.picmg0b.deactivation", FT_BOOLEAN, 8, TFS(&set_clear_tfs), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_0b_locked,\r\n{ "Locked bit",\r\n"ipmi.picmg0b.locked", FT_BOOLEAN, 8, TFS(&set_clear_tfs), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_0c_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg0c.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_0c_cmd,\r\n{ "Command",\r\n"ipmi.picmg0c.cmd", FT_UINT8, BASE_HEX, VALS(vals_0c_cmd), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_0d_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg0d.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_0d_start,\r\n{ "Search after record ID",\r\n"ipmi.picmg0d.start", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_0d_recordid,\r\n{ "Record ID",\r\n"ipmi.picmg0d.recordid", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_0f_iface,\r\n{ "Interface",\r\n"ipmi.linkinfo.iface", FT_UINT8, BASE_HEX, VALS(linkinfo_iface_vals), 0x000000c0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_0f_chan,\r\n{ "Channel",\r\n"ipmi.linkinfo.chan", FT_UINT8, BASE_DEC, NULL, 0x0000003f, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_10_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg10.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_10_nslots,\r\n{ "Number of spanned slots",\r\n"ipmi.picmg10.nslots", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_10_ipmc_loc,\r\n{ "IPMC Location",\r\n"ipmi.picmg10.ipmc_loc", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_11_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg11.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_11_power_level,\r\n{ "Power Level",\r\n"ipmi.picmg11.power_level", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_11_set_to_desired,\r\n{ "Set Present Levels to Desired",\r\n"ipmi.picmg11.set_to_desired", FT_UINT8, BASE_HEX, VALS(vals_11_set), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_12_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg12.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_12_pwr_type,\r\n{ "Power Type",\r\n"ipmi.picmg12.pwr_type", FT_UINT8, BASE_HEX, VALS(vals_12_pwr_type), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_12_dynamic,\r\n{ "Dynamic Power Configuration",\r\n"ipmi.picmg12.dynamic", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_12_pwr_lvl,\r\n{ "Power Level",\r\n"ipmi.picmg12.pwd_lvl", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_12_delay,\r\n{ "Delay to stable power",\r\n"ipmi.picmg12.delay", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_12_pwr_mult,\r\n{ "Power multiplier",\r\n"ipmi.picmg12.pwr_mult", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_12_pwr_draw,\r\n{ "Power draw",\r\n"ipmi.picmg12.pwr_draw", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_13_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg13.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_14_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg14.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_14_speed_min,\r\n{ "Minimum Speed Level",\r\n"ipmi.picmg14.speed_min", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_14_speed_max,\r\n{ "Maximum Speed Level",\r\n"ipmi.picmg14.speed_max", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_14_speed_norm,\r\n{ "Normal Operating Level",\r\n"ipmi.picmg14.speed_norm", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_14_local_control,\r\n{ "Local Control Mode Supported",\r\n"ipmi.picmg14.local_control", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_15_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg15.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_15_fan_level,\r\n{ "Fan Level",\r\n"ipmi.picmg15.fan_level", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_15_local_enable,\r\n{ "Local Control Enable State",\r\n"ipmi.picmg15.local_enable", FT_UINT8, BASE_HEX, VALS(enable_vals), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_16_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg16.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_16_override_level,\r\n{ "Override Fan Level",\r\n"ipmi.picmg16.override_level", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_16_local_level,\r\n{ "Local Control Fan Level",\r\n"ipmi.picmg16.local_level", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_16_local_enable,\r\n{ "Local Control Enable State",\r\n"ipmi.picmg16.local_enable", FT_UINT8, BASE_HEX, VALS(enabled_vals), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_17_cmd,\r\n{ "Command",\r\n"ipmi.picmg17.cmd", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_17_resid,\r\n{ "Bused Resource ID",\r\n"ipmi.picmg17.resid", FT_UINT8, BASE_HEX, VALS(busresid_vals), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_17_status,\r\n{ "Status",\r\n"ipmi.picmg17.status", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_18_li_key_type,\r\n{ "Link Info Key Type",\r\n"ipmi.picmg18.li_key_type", FT_UINT8, BASE_HEX, VALS(vals_18_keytype), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_18_li_key,\r\n{ "Link Info Key",\r\n"ipmi.picmg18.li_key", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_18_link_num,\r\n{ "Link Number",\r\n"ipmi.picmg18.link_num", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_18_sensor_num,\r\n{ "Sensor Number",\r\n"ipmi.picmg18.sensor_num", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1a_flags,\r\n{ "Extended Request Flags",\r\n"ipmi.picmg1a.flags", FT_UINT8, BASE_DEC_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1b_addr_active,\r\n{ "Active Shelf Manager IPMB Address",\r\n"ipmi.picmg1b.addr_active", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1b_addr_backup,\r\n{ "Backup Shelf Manager IPMB Address",\r\n"ipmi.picmg1b.addr_backup", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1c_fan_site_number,\r\n{ "Fan Tray Site Number",\r\n"ipmi.picmg1c.fan_site_number", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1c_fan_enable_state,\r\n{ "Fan Enable state",\r\n"ipmi.picmg1c.fan_enable_state", FT_UINT8, BASE_HEX, VALS(enable_vals), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1c_fan_policy_timeout,\r\n{ "Fan Policy Timeout",\r\n"ipmi.picmg1c.fan_policy_timeout", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_5s_1based), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1c_site_number,\r\n{ "Site Number",\r\n"ipmi.picmg1c.site_number", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1c_site_type,\r\n{ "Site Type",\r\n"ipmi.picmg1c.site_type", FT_UINT8, BASE_HEX, VALS(site_type_vals), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1d_fan_site_number,\r\n{ "Fan Tray Site Number",\r\n"ipmi.picmg1d.fan_site_number", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1d_site_number,\r\n{ "Site Number",\r\n"ipmi.picmg1d.site_number", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1d_site_type,\r\n{ "Site Type",\r\n"ipmi.picmg1d.site_type", FT_UINT8, BASE_HEX, VALS(site_type_vals), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1d_policy,\r\n{ "Policy",\r\n"ipmi.picmg1d.fan_enable_state", FT_UINT8, BASE_HEX, VALS(vals_1d_policy), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1d_coverage,\r\n{ "Coverage",\r\n"ipmi.picmg1d.coverage", FT_UINT8, BASE_HEX, VALS(vals_1d_coverage), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1e_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg1e.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1e_cap_diagintr,\r\n{ "Diagnostic interrupt",\r\n"ipmi.picmg1e.cap_diagintr", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1e_cap_graceful_reboot,\r\n{ "Graceful reboot",\r\n"ipmi.picmg1e.cap_reboot", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1e_cap_warm_reset,\r\n{ "Warm Reset",\r\n"ipmi.picmg1e.cap_warmreset", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1f_rq_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg1f.rq_fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1f_rq_op,\r\n{ "Operation",\r\n"ipmi.picmg1f.rq_op", FT_UINT8, BASE_HEX, VALS(vals_1f_op), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1f_rq_lockid,\r\n{ "Lock ID",\r\n"ipmi.picmg1f.rq_lockid", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1f_rs_lockid,\r\n{ "Lock ID",\r\n"ipmi.picmg1f.rs_lockid", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_1f_rs_tstamp,\r\n{ "Last Commit Timestamp",\r\n"ipmi.picmg1f.rs_tstamp", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_20_fruid,\r\n{ "FRU ID",\r\n"ipmi.picmg20.fruid", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_20_lockid,\r\n{ "Lock ID",\r\n"ipmi.picmg20.lockid", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_20_offset,\r\n{ "Offset to write",\r\n"ipmi.picmg20.offset", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_20_data,\r\n{ "Data to write",\r\n"ipmi.picmg20.data", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_20_count,\r\n{ "Count written",\r\n"ipmi.picmg20.count", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_21_addr_num,\r\n{ "Address Number",\r\n"ipmi.picmg21.addr_num", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_21_tstamp,\r\n{ "Shelf IP Address Last Change Timestamp",\r\n"ipmi.picmg21.tstamp", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_21_addr_count,\r\n{ "Address Count",\r\n"ipmi.picmg21.addr_count", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_21_site_type,\r\n{ "Site Type",\r\n"ipmi.picmg21.site_type", FT_UINT8, BASE_HEX, VALS(site_type_vals), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_21_site_num,\r\n{ "Site Number",\r\n"ipmi.picmg21.site_num", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_21_max_unavail,\r\n{ "Maximum Unavailable Time",\r\n"ipmi.picmg21.max_unavail", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_1s_1based), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_21_is_shm,\r\n{ "Shelf Manager IP Address",\r\n"ipmi.picmg21.is_shm", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_21_addr_type,\r\n{ "Address Type",\r\n"ipmi.picmg21.addr_type", FT_UINT8, BASE_HEX, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_21_ipaddr,\r\n{ "IP Address",\r\n"ipmi.picmg21.ip_addr", FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_21_rmcpport,\r\n{ "RMCP Port",\r\n"ipmi.picmg21.rmcp_port", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_22_feed_idx,\r\n{ "Power Feed Index",\r\n"ipmi.picmg22.feed_idx", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_22_update_cnt,\r\n{ "Update Counter",\r\n"ipmi.picmg22.update_cnt", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_22_pwr_alloc,\r\n{ "Power Feed Allocation",\r\n"ipmi.picmg22.pwr_alloc", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_XX_comp7,\r\n{ "Component 7",\r\n"ipmi.hpm1.comp7", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_XX_comp6,\r\n{ "Component 6",\r\n"ipmi.hpm1.comp6", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_XX_comp5,\r\n{ "Component 5",\r\n"ipmi.hpm1.comp5", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_XX_comp4,\r\n{ "Component 4",\r\n"ipmi.hpm1.comp4", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_XX_comp3,\r\n{ "Component 3",\r\n"ipmi.hpm1.comp3", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_XX_comp2,\r\n{ "Component 2",\r\n"ipmi.hpm1.comp2", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_XX_comp1,\r\n{ "Component 1",\r\n"ipmi.hpm1.comp1", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_XX_comp0,\r\n{ "Component 0",\r\n"ipmi.hpm1.comp0", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2e_version,\r\n{ "HPM.1 version",\r\n"ipmi.picmg2e.hpm1_version", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2e_upgrade_undesirable,\r\n{ "Firmware Upgrade Undesirable",\r\n"ipmi.picmg2e.upgrade_undesirable", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2e_auto_rollback_override,\r\n{ "Automatic Rollback Overridden",\r\n"ipmi.picmg2e.auto_rollback_override", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2e_ipmc_degraded,\r\n{ "IPMC degraded during upgrade",\r\n"ipmi.picmg2e.ipmc_degraded", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2e_deferred_activate,\r\n{ "Deferred Activation supported",\r\n"ipmi.picmg2e.deferred_activate", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2e_services_affected,\r\n{ "Services affected by upgrade",\r\n"ipmi.picmg2e.services_affected", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2e_manual_rollback,\r\n{ "Manual Rollback supported",\r\n"ipmi.picmg2e.manual_rollback", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2e_auto_rollback,\r\n{ "Automatic Rollback supported",\r\n"ipmi.picmg2e.auto_rollback", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2e_self_test,\r\n{ "Self-Test supported",\r\n"ipmi.picmg2e.self_test", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2e_upgrade_tout,\r\n{ "Upgrade timeout",\r\n"ipmi.picmg2e.upgrade_tout", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_5s_1based), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2e_selftest_tout,\r\n{ "Self-test timeout",\r\n"ipmi.picmg2e.selftest_tout", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_5s_1based), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2e_rollback_tout,\r\n{ "Rollback timeout",\r\n"ipmi.picmg2e.rollback_tout", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_5s_1based), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2e_inaccessibility_tout,\r\n{ "Inaccessibility timeout",\r\n"ipmi.picmg2e.inaccessibility_tout", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_5s_1based), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_prop00_cold_reset,\r\n{ "Payload cold reset required",\r\n"ipmi.prop00.cold_reset", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_prop00_deferred_activation,\r\n{ "Deferred firmware activation supported",\r\n"ipmi.prop00.deferred_activation", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_prop00_comparison,\r\n{ "Firmware comparison supported",\r\n"ipmi.prop00.firmware_comparison", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_prop00_preparation,\r\n{ "Prepare Components action required",\r\n"ipmi.prop00.preparation", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_prop00_rollback,\r\n{ "Rollback/Backup support",\r\n"ipmi.prop00.rollback", FT_UINT8, BASE_HEX, VALS(vals_prop00_rollback), 0x03, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_prop01_fw_major,\r\n{ "Major Firmware Revision (binary encoded)",\r\n"ipmi.prop01.fw_major", FT_UINT8, BASE_HEX, NULL, 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_prop01_fw_minor,\r\n{ "Minor Firmware Revision (BCD encoded)",\r\n"ipmi.prop01.fw_minor", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_prop01_fw_aux,\r\n{ "Auxiliary Firmware Revision Information",\r\n"ipmi.prop01.fw_aux", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_prop02_desc,\r\n{ "Description string",\r\n"ipmi.prop02.desc", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2f_comp_id,\r\n{ "Component ID",\r\n"ipmi.picmg2f.comp_id", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2f_comp_prop,\r\n{ "Component property selector",\r\n"ipmi.picmg2f.comp_prop", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2f_prop_data,\r\n{ "Unknown property data",\r\n"ipmi.picmg2f.prop_data", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_31_action,\r\n{ "Upgrade action",\r\n"ipmi.picmg31.action", FT_UINT8, BASE_HEX, VALS(vals_31_action), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_32_block,\r\n{ "Block Number",\r\n"ipmi.picmg32.block", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_32_data,\r\n{ "Data",\r\n"ipmi.picmg32.data", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_32_sec_offs,\r\n{ "Section Offset",\r\n"ipmi.picmg32.sec_offs", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_32_sec_len,\r\n{ "Section Length",\r\n"ipmi.picmg32.sec_len", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_33_comp_id,\r\n{ "Component ID",\r\n"ipmi.picmg33.comp_id", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_33_img_len,\r\n{ "Image Length",\r\n"ipmi.picmg33.img_len", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_34_cmd,\r\n{ "Command in progress",\r\n"ipmi.picmg34.cmd", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_34_ccode,\r\n{ "Last command completion code",\r\n"ipmi.picmg34.ccode", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_34_percentage,\r\n{ "Completion estimate",\r\n"ipmi.picmg34.percent", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_percent), 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_35_rollback_override,\r\n{ "Rollback Override Policy",\r\n"ipmi.picmg35.rollback_override", FT_UINT8, BASE_HEX, VALS(vals_35_override), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_36_result,\r\n{ "Self test result",\r\n"ipmi.picmg36.self_test_result", FT_UINT8, BASE_HEX, VALS(vals_36_result), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_36_fail,\r\n{ "Self-test error bitfield",\r\n"ipmi.picmg36.fail", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_36_fail_sel,\r\n{ "Cannot access SEL device",\r\n"ipmi.picmg36.fail.sel", FT_BOOLEAN, 8, TFS(&tfs_36_fail_unknown), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_36_fail_sdr,\r\n{ "Cannot access SDR Repository",\r\n"ipmi.picmg36.fail.sdr", FT_BOOLEAN, 8, TFS(&tfs_36_fail_unknown), 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_36_fail_bmc_fru,\r\n{ "Cannot access BMC FRU device",\r\n"ipmi.picmg36.fail.bmc_fru", FT_BOOLEAN, 8, TFS(&tfs_36_fail_unknown), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_36_fail_ipmb_sig,\r\n{ "IPMB signal lines do not respond",\r\n"ipmi.picmg36.fail.ipmb_sig", FT_BOOLEAN, 8, TFS(&tfs_36_fail_unknown), 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_36_fail_sdr_empty,\r\n{ "SDR Repository is empty",\r\n"ipmi.picmg36.fail.sdr_empty", FT_BOOLEAN, 8, TFS(&tfs_36_fail_unknown), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_36_fail_iua,\r\n{ "Internal Use Area of BMC FRU corrupted",\r\n"ipmi.picmg36.fail.iua", FT_BOOLEAN, 8, TFS(&tfs_36_fail_unknown), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_36_fail_bb_fw,\r\n{ "Controller update boot block firmware corrupted",\r\n"ipmi.picmg36.fail.bb_fw", FT_BOOLEAN, 8, TFS(&tfs_36_fail_unknown), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_36_fail_oper_fw,\r\n{ "Controller operational firmware corrupted",\r\n"ipmi.picmg36.fail.oper_fw", FT_BOOLEAN, 8, TFS(&tfs_36_fail_unknown), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_37_percent,\r\n{ "Estimated percentage complete",\r\n"ipmi.picmg37.percent", FT_UINT8, BASE_CUSTOM, CF_FUNC(ipmi_fmt_percent), 0x7f, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_id,\r\n{ "HPM.x Identifier",\r\n"ipmi.picmg.hpm.id", FT_UINT8, BASE_HEX, VALS(hpm_x_ids), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_rev,\r\n{ "HPM.x Revision Identifier",\r\n"ipmi.picmg.hpm.rev", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm2_mask,\r\n{ "IPMI LAN Channel Mask",\r\n"ipmi.picmg.hpm2.mask", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm2_caps,\r\n{ "HPM.2 Capabilities",\r\n"ipmi.picmg.hpm2.caps", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm2_dyn_ssn,\r\n{ "Dynamic Sessions",\r\n"ipmi.picmg.hpm2.dynssn", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm2_ver_chg,\r\n{ "Version Change Sensor for LAN Configuration",\r\n"ipmi.picmg.hpm2.verchg", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm2_ext_mgt,\r\n{ "Extended Inactive State Management",\r\n"ipmi.picmg.hpm2.extmgt", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm2_pkt_trc,\r\n{ "IPMI Channel Packet Trace",\r\n"ipmi.picmg.hpm2.pkttrc", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm2_sol_ext,\r\n{ "SOL Extensions",\r\n"ipmi.picmg.hpm2.solext", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_oem_start,\r\n{ "OEM LAN Parameters Start Location",\r\n"ipmi.picmg.hpm.oem.start", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_oem_rev,\r\n{ "OEM LAN Parameters Blocks Revision Number",\r\n"ipmi.picmg.hpm.oem.rev", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm2_sol_oem_start,\r\n{ "OEM SOL Parameters Start Location",\r\n"ipmi.picmg.hpm2.sol.oem.start", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm2_sol_oem_rev,\r\n{ "OEM SOL Parameters Blocks Revision Number",\r\n"ipmi.picmg.hpm2.sol.oem.rev", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_cred_hnd,\r\n{ "Credentials Handle",\r\n"ipmi.picmg.hpm.cred.hnd", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_func_sel,\r\n{ "Function Selector",\r\n"ipmi.picmg.hpm.func.sel", FT_UINT8, BASE_DEC, VALS(hpm2_func_selectors), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_ipmi_rev,\r\n{ "IPMI Revision",\r\n"ipmi.picmg.hpm.ipmi.rev", FT_UINT8, BASE_HEX, VALS(hpm2_ipmi_revs), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_auth_type,\r\n{ "Authentication Type",\r\n"ipmi.picmg.hpm.auth.type", FT_UINT8, BASE_HEX, VALS(hpm2_auth_types), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_cipher_id,\r\n{ "Cipher Suite ID",\r\n"ipmi.picmg.hpm.cipher", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_priv_level,\r\n{ "Maximum Privilege Level",\r\n"ipmi.picmg.hpm.priv", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_chn_num,\r\n{ "IPMI Lan Channel Number",\r\n"ipmi.picmg.hpm.chn.num", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_avail_time,\r\n{ "Availability Time",\r\n"ipmi.picmg.hpm.avail", FT_UINT32, BASE_DEC_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_user_name,\r\n{ "User Name",\r\n"ipmi.picmg.hpm.user.name", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_user_pwd,\r\n{ "User Password",\r\n"ipmi.picmg.hpm.user.pwd", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_bmc_key,\r\n{ "BMC Key",\r\n"ipmi.picmg.hpm.bmc.key", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_operation,\r\n{ "Command Operation Mode",\r\n"ipmi.picmg.hpm.operation", FT_UINT8, BASE_DEC, VALS(picmg40_operations), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_ssn_hnd,\r\n{ "Session Handle",\r\n"ipmi.picmg.hpm.ssn.hnd", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_power_draw,\r\n{ "Extended Management Power Draw",\r\n"ipmi.picmg.hpm.pwr.draw", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_base_channels,\r\n{ "Base Interface Channels",\r\n"ipmi.picmg.hpm.base.chn", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_fabric_channels,\r\n{ "Fabric Interface Channels",\r\n"ipmi.picmg.hpm.base.chn", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_update_channels,\r\n{ "Update Channels",\r\n"ipmi.picmg.hpm.upd.chn", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_cross_channels,\r\n{ "ShMC Cross-Connect Channels",\r\n"ipmi.picmg.hpm.cross.chn", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_num_chn_desc,\r\n{ "Number of Channel Descriptors",\r\n"ipmi.picmg.hpm.num.chn.desc", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_chn_mask,\r\n{ "Channel Bitmask",\r\n"ipmi.picmg.hpm.chn.mask", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_ext_mgmt_state,\r\n{ "Extended Management State",\r\n"ipmi.picmg.hpm.ext.mgmt.state", FT_UINT8, BASE_DEC, VALS(enable_vals), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_polling_period,\r\n{ "Polling Period",\r\n"ipmi.picmg.hpm.poll.period", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_auth_pwr_state,\r\n{ "Authorized Power State",\r\n"ipmi.picmg.hpm.auth.pwr", FT_UINT8, BASE_DEC, VALS(auth_pwr_states), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_hpm_amc_pwr_state,\r\n{ "Actual Power State",\r\n"ipmi.picmg.hpm.amc.pwr", FT_UINT8, BASE_DEC, VALS(amc_pwr_states), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg47_port,\r\n{ "System Serial Port Number",\r\n"ipmi.picmg47.port", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg47_flags,\r\n{ "Flags",\r\n"ipmi.picmg47.flags", FT_UINT8, BASE_DEC, VALS(picmg47_flags), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg47_assignment,\r\n{ "Assigned Instance",\r\n"ipmi.picmg47.assign", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg47_state,\r\n{ "Serial port assigned to instance state",\r\n"ipmi.picmg47.state", FT_UINT8, BASE_DEC, VALS(picmg47_states), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_picmg47_instance,\r\n{ "Payload instance number",\r\n"ipmi.picmg47.instance", FT_UINT8, BASE_DEC, NULL, 0x0F, NULL, HFILL }},\r\n{ &hf_ipmi_picmg48_sub_fru_type,\r\n{ "Subsidiary FRU Identifier Type",\r\n"ipmi.picmg48.fru.type", FT_UINT8, BASE_DEC, VALS(picmg48_fru_types), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg48_sub_fru_id,\r\n{ "Subsidiary FRU Identifier",\r\n"ipmi.picmg48.fru.id", FT_UINT8, BASE_DEC_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg48_ip_source,\r\n{ "IP Address Source",\r\n"ipmi.picmg48.ip.source", FT_UINT8, BASE_DEC, VALS(picmg48_ip_sources), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_23_rq_byte2,\r\n{ "Request Flags",\r\n"ipmi.picmg23.rq.flags", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_23_slot_sel,\r\n{ "MCS",\r\n"ipmi.picmg23.rq.mcs", FT_UINT8, BASE_HEX, VALS(picmg_23_slot_selectors), 0xC0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_23_carrier_num,\r\n{ "Carrier Number",\r\n"ipmi.picmg23.carrier.num", FT_UINT8, BASE_DEC, NULL, 0x1F, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_23_slot_num,\r\n{ "Slot Number",\r\n"ipmi.picmg23.slot.num", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_23_tier_num,\r\n{ "Tier Number",\r\n"ipmi.picmg23.tier.num", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_23_rs_byte5,\r\n{ "Orientation Flags",\r\n"ipmi.picmg23.rs.flags", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_23_slot_base,\r\n{ "Slot Numbers",\r\n"ipmi.picmg23.slot.base", FT_UINT8, BASE_DEC, VALS(picmg_23_num_bases), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_23_tier_base,\r\n{ "Tier Numbers",\r\n"ipmi.picmg23.tier.base", FT_UINT8, BASE_DEC, VALS(picmg_23_num_bases), 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_23_orientation,\r\n{ "Carrier Orientation",\r\n"ipmi.picmg23.orient", FT_UINT8, BASE_DEC, VALS(picmg_23_orientations), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_23_origin_x,\r\n{ "Origin X",\r\n"ipmi.picmg23.origin.x", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_23_origin_y,\r\n{ "Origin Y",\r\n"ipmi.picmg23.origin.y", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_24_channel,\r\n{ "Power Channel Number",\r\n"ipmi.picmg.pwr.channel", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_24_control,\r\n{ "Power Channel Control",\r\n"ipmi.picmg.pwr.control", FT_UINT8, BASE_DEC, VALS(picmg_24_controls), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_24_current,\r\n{ "Power Channel Current Limit",\r\n"ipmi.picmg.pwr.limit", FT_UINT8, BASE_CUSTOM, CF_FUNC(fmt_power_amps), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_24_primary_pm,\r\n{ "Primary PM",\r\n"ipmi.picmg.primary.pm", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_24_backup_pm,\r\n{ "Redundant PM",\r\n"ipmi.picmg.backup.pm", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_25_start,\r\n{ "Starting Power Channel Number",\r\n"ipmi.picmg25.start", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_25_count,\r\n{ "Power Channel Count",\r\n"ipmi.picmg25.count", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_25_max,\r\n{ "Max Power Channel Number",\r\n"ipmi.picmg25.max", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_25_gstatus,\r\n{ "Global Status",\r\n"ipmi.picmg25.gstatus", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_25_fault,\r\n{ "Unidentified Fault",\r\n"ipmi.picmg25.fault", FT_UINT8, BASE_DEC, VALS(picmg_25_fault_vals), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_25_pwr_good,\r\n{ "Payload Power is Good",\r\n"ipmi.picmg25.pwr.good", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_25_mp_good,\r\n{ "Management Power is Good",\r\n"ipmi.picmg25.mp.good", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_25_role,\r\n{ "Role",\r\n"ipmi.picmg25.role", FT_BOOLEAN, 8, TFS(&picmg_25_roles), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_25_cstatus,\r\n{ "Power Channel Status",\r\n"ipmi.picmg25.cstatus", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_25_pwr_on,\r\n{ "PWR_ON is asserted",\r\n"ipmi.picmg25.pwr.on", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_25_pwr_ovr,\r\n{ "Payload Power Overcurrent is detected",\r\n"ipmi.picmg25.pwr.ovr", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_25_pwr,\r\n{ "Payload Power is enabled",\r\n"ipmi.picmg25.pwr", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_25_enable,\r\n{ "ENABLE# is asserted",\r\n"ipmi.picmg25.enable", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_25_mp_ovr,\r\n{ "Management Power Overcurrent is detected",\r\n"ipmi.picmg25.mp.ovr", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_25_mp,\r\n{ "Management Power is enabled",\r\n"ipmi.picmg25.mp", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_25_ps1,\r\n{ "PS1# is asserted",\r\n"ipmi.picmg25.ps1", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_26_pm_site,\r\n{ "PM Site Number",\r\n"ipmi.picmg26.pm.site", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_27_rs_byte3,\r\n{ "PM Status",\r\n"ipmi.picmg26.pm.status", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_27_pm_healthy,\r\n{ "PM is present and healthy",\r\n"ipmi.picmg26.pm.hly", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_28_timeout,\r\n{ "Time-out",\r\n"ipmi.picmg28.timeout", FT_UINT8, BASE_CUSTOM, CF_FUNC(fmt_100ms), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_28_rq_byte3,\r\n{ "Flags",\r\n"ipmi.picmg28.flags", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_28_mch2,\r\n{ "Use MCH2 PS1# de-assertion to indicate Carrier Manager is extracted",\r\n"ipmi.picmg28.mch2", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_28_mch1,\r\n{ "Use MCH1 PS1# de-assertion to indicate Carrier Manager is extracted",\r\n"ipmi.picmg28.mch1", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_29_rs_byte3,\r\n{ "Alarm Capabilities",\r\n"ipmi.picmg29.caps", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_29_maj_rst,\r\n{ "Autonomous Major Reset",\r\n"ipmi.picmg29.maj.rst", FT_BOOLEAN, 8, TFS(&picmg_29_alarm_actions), 0x80, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_29_min_rst,\r\n{ "Autonomous Minor Reset",\r\n"ipmi.picmg29.min.rst", FT_BOOLEAN, 8, TFS(&picmg_29_alarm_actions), 0x40, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_29_alarm_cut,\r\n{ "Autonomous alarm cutoff",\r\n"ipmi.picmg29.alrm.cut", FT_BOOLEAN, 8, TFS(&picmg_29_alarm_actions), 0x20, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_29_test_mode,\r\n{ "Test Mode",\r\n"ipmi.picmg29.test.mode", FT_BOOLEAN, 8, TFS(&picmg_29_alarm_modes), 0x10, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_29_pwr_alarm,\r\n{ "Power Alarm",\r\n"ipmi.picmg29.pwr.alrm", FT_BOOLEAN, 8, TFS(&picmg_29_alarm_modes), 0x08, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_29_minor_alarm,\r\n{ "Minor Alarm",\r\n"ipmi.picmg29.min.alrm", FT_BOOLEAN, 8, TFS(&picmg_29_alarm_modes), 0x04, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_29_major_alarm,\r\n{ "Minor Alarm",\r\n"ipmi.picmg29.maj.alrm", FT_BOOLEAN, 8, TFS(&picmg_29_alarm_modes), 0x02, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_29_crit_alarm,\r\n{ "Critical Alarm",\r\n"ipmi.picmg29.crit.alrm", FT_BOOLEAN, 8, TFS(&picmg_29_alarm_modes), 0x01, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2a_alarm_id,\r\n{ "Alarm ID",\r\n"ipmi.picmg29.alrm.id", FT_UINT8, BASE_HEX, VALS(picmg_2a_alarm_ids), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2a_alarm_ctrl,\r\n{ "Alarm Control",\r\n"ipmi.picmg29.alrm.ctrl", FT_UINT8, BASE_HEX, VALS(picmg_2a_alarm_ctrls), 0, NULL, HFILL }},\r\n{ &hf_ipmi_picmg_2b_alarm_state,\r\n{ "Alarm State",\r\n"ipmi.picmg29.alrm.ctrl", FT_UINT8, BASE_HEX, VALS(picmg_2a_alarm_ctrls), 0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ipmi_picmg_led_color,\r\n&ett_ipmi_picmg_link_info,\r\n&ett_ipmi_picmg_link_state,\r\n&ett_ipmi_picmg_link_dev,\r\n&ett_ipmi_picmg_clock_setting,\r\n&ett_ipmi_picmg_clock_res,\r\n&ett_ipmi_picmg_05_byte1,\r\n&ett_ipmi_picmg_06_byte1,\r\n&ett_ipmi_picmg_06_byte2,\r\n&ett_ipmi_picmg_06_byte3,\r\n&ett_ipmi_picmg_08_byte1,\r\n&ett_ipmi_picmg_09_ipmba,\r\n&ett_ipmi_picmg_09_ipmbb,\r\n&ett_ipmi_picmg_0a_byte2,\r\n&ett_ipmi_picmg_0a_byte3,\r\n&ett_ipmi_picmg_0b_byte1,\r\n&ett_ipmi_picmg_0f_chan,\r\n&ett_ipmi_picmg_12_byte1,\r\n&ett_ipmi_picmg_14_prop,\r\n&ett_ipmi_picmg_1e_byte1,\r\n&ett_ipmi_picmg_21_byte9,\r\n&ett_ipmi_picmg_XX_compbits,\r\n&ett_ipmi_picmg_2e_byte2,\r\n&ett_ipmi_picmg_prop00_byte1,\r\n&ett_ipmi_picmg_prop01_byte1,\r\n&ett_ipmi_picmg_34_byte3,\r\n&ett_ipmi_picmg_36_byte2,\r\n&ett_ipmi_picmg_37_byte2,\r\n&ett_ipmi_picmg_hpm_caps,\r\n&ett_ipmi_picmg_47_byte1,\r\n&ett_ipmi_picmg_23_rq_byte2,\r\n&ett_ipmi_picmg_23_rs_byte5,\r\n&ett_ipmi_picmg_25_rs_byte4,\r\n&ett_ipmi_picmg_25_rs_byte5,\r\n&ett_ipmi_picmg_27_rs_byte3,\r\n&ett_ipmi_picmg_28_rq_byte3,\r\n&ett_ipmi_picmg_29_rs_byte3\r\n};\r\nstatic guint8 sig_picmg[1] = { 0 };\r\nproto_register_field_array(proto_ipmi, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nipmi_register_netfn_cmdtab(IPMI_GROUP_REQ, IPMI_OEM_NONE, sig_picmg, 1,\r\n"PICMG", cmd_picmg, array_length(cmd_picmg));\r\n}
