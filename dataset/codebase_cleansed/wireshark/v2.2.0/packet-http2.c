static gboolean\r\nhd_inflate_del_cb(wmem_allocator_t *allocator _U_, wmem_cb_event_t event _U_, void *user_data)\r\n{\r\nnghttp2_hd_inflate_del((nghttp2_hd_inflater*)user_data);\r\nhttp2_hdrcache_map = NULL;\r\nhttp2_header_pstr = NULL;\r\nreturn FALSE;\r\n}\r\nstatic http2_session_t*\r\nget_http2_session(packet_info *pinfo)\r\n{\r\nconversation_t *conversation;\r\nhttp2_session_t *h2session;\r\nconversation = find_or_create_conversation(pinfo);\r\nh2session = (http2_session_t*)conversation_get_proto_data(conversation,\r\nproto_http2);\r\nif(!h2session) {\r\nstruct tcp_analysis *tcpd;\r\ntcpd = get_tcp_conversation_data(NULL, pinfo);\r\nh2session = wmem_new0(wmem_file_scope(), http2_session_t);\r\nnghttp2_hd_inflate_new(&h2session->hd_inflater[0]);\r\nnghttp2_hd_inflate_new(&h2session->hd_inflater[1]);\r\nwmem_register_callback(wmem_file_scope(), hd_inflate_del_cb,\r\nh2session->hd_inflater[0]);\r\nwmem_register_callback(wmem_file_scope(), hd_inflate_del_cb,\r\nh2session->hd_inflater[1]);\r\nh2session->fwd_flow = tcpd->fwd;\r\nh2session->settings_queue[0] = wmem_queue_new(wmem_file_scope());\r\nh2session->settings_queue[1] = wmem_queue_new(wmem_file_scope());\r\nconversation_add_proto_data(conversation, proto_http2, h2session);\r\n}\r\nreturn h2session;\r\n}\r\nstatic int\r\nselect_http2_flow_index(packet_info *pinfo, http2_session_t *h2session)\r\n{\r\nstruct tcp_analysis *tcpd;\r\ntcpd = get_tcp_conversation_data(NULL, pinfo);\r\nif(tcpd->fwd == h2session->fwd_flow) {\r\nreturn 0;\r\n} else {\r\nreturn 1;\r\n}\r\n}\r\nstatic void\r\npush_settings(packet_info *pinfo, http2_session_t *h2session,\r\nhttp2_settings_t *settings)\r\n{\r\nwmem_queue_t *queue;\r\nint flow_index;\r\nflow_index = select_http2_flow_index(pinfo, h2session);\r\nqueue = h2session->settings_queue[flow_index];\r\nwmem_queue_push(queue, settings);\r\n}\r\nstatic void\r\napply_and_pop_settings(packet_info *pinfo, http2_session_t *h2session)\r\n{\r\nwmem_queue_t *queue;\r\nhttp2_settings_t *settings;\r\nnghttp2_hd_inflater *inflater;\r\nint flow_index;\r\nflow_index = select_http2_flow_index(pinfo, h2session);\r\ninflater = h2session->hd_inflater[flow_index];\r\nqueue = h2session->settings_queue[flow_index ^ 1];\r\nif(wmem_queue_count(queue) == 0) {\r\nreturn;\r\n}\r\nsettings = (http2_settings_t*)wmem_queue_pop(queue);\r\nif(settings->has_header_table_size) {\r\nif(settings->min_header_table_size < settings->header_table_size) {\r\nnghttp2_hd_inflate_change_table_size\r\n(inflater, settings->min_header_table_size);\r\n}\r\nnghttp2_hd_inflate_change_table_size(inflater,\r\nsettings->header_table_size);\r\n}\r\n}\r\nstatic guint read_integer(http2_header_repr_info_t *header_repr_info,\r\nconst guint8 *buf, guint len, guint p, guint prefix)\r\n{\r\nguint k = (1 << prefix) - 1;\r\nguint n = header_repr_info->integer;\r\nguint shift = header_repr_info->next_shift;\r\nif(n == 0) {\r\nDISSECTOR_ASSERT(p < len);\r\nif((buf[p] & k) != k) {\r\nheader_repr_info->integer = buf[p] & k;\r\nheader_repr_info->complete = TRUE;\r\nreturn p + 1;\r\n}\r\nn = k;\r\n++p;\r\n}\r\nfor(; p < len; ++p, shift += 7) {\r\nDISSECTOR_ASSERT(p < len);\r\nn += (buf[p] & 0x7F) << shift;\r\nif((buf[p] & 0x80) == 0) {\r\nheader_repr_info->complete = TRUE;\r\n++p;\r\nbreak;\r\n}\r\n}\r\nheader_repr_info->integer = n;\r\nheader_repr_info->next_shift = shift;\r\nreturn p;\r\n}\r\nstatic void\r\nreset_http2_header_repr_info(http2_header_repr_info_t *header_repr_info)\r\n{\r\nheader_repr_info->type = HTTP2_HD_NONE;\r\nheader_repr_info->integer = 0;\r\nheader_repr_info->next_shift = 0;\r\nheader_repr_info->complete = FALSE;\r\n}\r\nstatic guint\r\nprocess_http2_header_repr_info(wmem_array_t *headers,\r\nhttp2_header_repr_info_t *header_repr_info,\r\nconst guint8 *buf, guint len)\r\n{\r\nguint i;\r\nguint start;\r\nif(header_repr_info->type != HTTP2_HD_NONE &&\r\nheader_repr_info->type != HTTP2_HD_HEADER_TABLE_SIZE_UPDATE &&\r\nheader_repr_info->complete) {\r\nreturn 0;\r\n}\r\nstart = 0;\r\nfor(i = 0; i < len;) {\r\nif(header_repr_info->type == HTTP2_HD_NONE) {\r\nguchar c = buf[i];\r\nif((c & 0xE0) == 0x20) {\r\nheader_repr_info->type = HTTP2_HD_HEADER_TABLE_SIZE_UPDATE;\r\ni = read_integer(header_repr_info, buf, len, i, 5);\r\n} else if(c & 0x80) {\r\nheader_repr_info->type = HTTP2_HD_INDEXED;\r\ni = read_integer(header_repr_info, buf, len, i, 7);\r\n} else if(c == 0x40 || c == 0 || c == 0x10) {\r\nheader_repr_info->complete = TRUE;\r\nif(c & 0x40) {\r\nheader_repr_info->type = HTTP2_HD_LITERAL_INDEXING_NEW_NAME;\r\n} else if((c & 0xF0) == 0x10) {\r\nheader_repr_info->type = HTTP2_HD_LITERAL_NEVER_INDEXING_NEW_NAME;\r\n} else {\r\nheader_repr_info->type = HTTP2_HD_LITERAL_NEW_NAME;\r\n}\r\n} else {\r\nif(c & 0x40) {\r\nheader_repr_info->type = HTTP2_HD_LITERAL_INDEXING_INDEXED_NAME;\r\ni = read_integer(header_repr_info, buf, len, i, 6);\r\n} else if((c & 0xF0) == 0x10) {\r\nheader_repr_info->type = HTTP2_HD_LITERAL_NEVER_INDEXING_INDEXED_NAME;\r\ni = read_integer(header_repr_info, buf, len, i, 4);\r\n} else {\r\nheader_repr_info->type = HTTP2_HD_LITERAL_INDEXED_NAME;\r\ni = read_integer(header_repr_info, buf, len, i, 4);\r\n}\r\n}\r\n} else {\r\ni = read_integer(header_repr_info, buf, len, i, 8);\r\n}\r\nif(header_repr_info->complete) {\r\nif(header_repr_info->type == HTTP2_HD_HEADER_TABLE_SIZE_UPDATE) {\r\nhttp2_header_t *out;\r\nout = wmem_new(wmem_file_scope(), http2_header_t);\r\nout->type = header_repr_info->type;\r\nout->length = i - start;\r\nout->table.header_table_size = header_repr_info->integer;\r\nwmem_array_append(headers, out, 1);\r\nreset_http2_header_repr_info(header_repr_info);\r\nstart = i;\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn start;\r\n}\r\nstatic size_t http2_hdrcache_length(gconstpointer vv)\r\n{\r\nconst guint8 *v = (const guint8 *)vv;\r\nguint32 namelen, valuelen;\r\nnamelen = pntoh32(v);\r\nvaluelen = pntoh32(v + sizeof(namelen) + namelen);\r\nreturn namelen + valuelen + sizeof(namelen) + sizeof(valuelen);\r\n}\r\nstatic guint http2_hdrcache_hash(gconstpointer key)\r\n{\r\nreturn wmem_strong_hash((const guint8 *)key, http2_hdrcache_length(key));\r\n}\r\nstatic gboolean http2_hdrcache_equal(gconstpointer lhs, gconstpointer rhs)\r\n{\r\nconst guint8 *a = (const guint8 *)lhs;\r\nconst guint8 *b = (const guint8 *)rhs;\r\nsize_t alen = http2_hdrcache_length(a);\r\nsize_t blen = http2_hdrcache_length(b);\r\nreturn alen == blen && memcmp(a, b, alen) == 0;\r\n}\r\nstatic void\r\ninflate_http2_header_block(tvbuff_t *tvb, packet_info *pinfo, guint offset,\r\nproto_tree *tree, size_t headlen,\r\nhttp2_session_t *h2session, guint8 flags)\r\n{\r\nguint8 *headbuf;\r\nproto_tree *header_tree;\r\nproto_item *header, *ti;\r\nint header_name_length;\r\nint header_value_length;\r\nconst gchar *header_name;\r\nconst gchar *header_value;\r\nint hoffset = 0;\r\nnghttp2_hd_inflater *hd_inflater;\r\ntvbuff_t *header_tvb = tvb_new_composite();\r\nint rv;\r\nint header_len = 0;\r\nint final;\r\nint flow_index;\r\nhttp2_header_data_t *header_data;\r\nhttp2_header_repr_info_t *header_repr_info;\r\nwmem_list_t *header_list;\r\nwmem_array_t *headers;\r\nguint i;\r\nif (!http2_hdrcache_map) {\r\nhttp2_hdrcache_map = wmem_map_new(wmem_file_scope(), http2_hdrcache_hash, http2_hdrcache_equal);\r\n}\r\nheader_data = (http2_header_data_t*)p_get_proto_data(wmem_file_scope(), pinfo, proto_http2, 0);\r\nheader_list = header_data->header_list;\r\nif(!PINFO_FD_VISITED(pinfo)) {\r\nint decompressed_bytes = 0;\r\nheadbuf = (guint8*)wmem_alloc(wmem_packet_scope(), headlen);\r\ntvb_memcpy(tvb, headbuf, offset, headlen);\r\nflow_index = select_http2_flow_index(pinfo, h2session);\r\nhd_inflater = h2session->hd_inflater[flow_index];\r\nheader_repr_info = &h2session->header_repr_info[flow_index];\r\nfinal = flags & HTTP2_FLAGS_END_HEADERS;\r\nheaders = wmem_array_sized_new(wmem_file_scope(), sizeof(http2_header_t), 16);\r\nfor(;;) {\r\nnghttp2_nv nv;\r\nint inflate_flags = 0;\r\nif (wmem_array_get_count(headers) >= MAX_HTTP2_HEADER_LINES) {\r\nheader_data->header_lines_exceeded = TRUE;\r\nbreak;\r\n}\r\nrv = (int)nghttp2_hd_inflate_hd(hd_inflater, &nv,\r\n&inflate_flags, headbuf, headlen, final);\r\nif(rv < 0) {\r\nbreak;\r\n}\r\nheadbuf += rv;\r\nheadlen -= rv;\r\nrv -= process_http2_header_repr_info(headers, header_repr_info, headbuf - rv, rv);\r\nif(inflate_flags & NGHTTP2_HD_INFLATE_EMIT) {\r\nchar *cached_pstr;\r\nguint32 len;\r\nguint datalen = (guint)(4 + nv.namelen + 4 + nv.valuelen);\r\nhttp2_header_t *out;\r\nif (decompressed_bytes + datalen >= MAX_HTTP2_HEADER_SIZE) {\r\nheader_data->header_size_reached = decompressed_bytes;\r\nheader_data->header_size_attempted = decompressed_bytes + datalen;\r\nbreak;\r\n}\r\nout = wmem_new(wmem_file_scope(), http2_header_t);\r\nout->type = header_repr_info->type;\r\nout->length = rv;\r\nout->table.data.idx = header_repr_info->integer;\r\nout->table.data.datalen = datalen;\r\ndecompressed_bytes += datalen;\r\nhttp2_header_pstr = (char *)wmem_realloc(wmem_file_scope(), http2_header_pstr, out->table.data.datalen);\r\nlen = (guint32)nv.namelen;\r\nphton32(&http2_header_pstr[0], len);\r\nmemcpy(&http2_header_pstr[4], nv.name, nv.namelen);\r\nlen = (guint32)nv.valuelen;\r\nphton32(&http2_header_pstr[4 + nv.namelen], len);\r\nmemcpy(&http2_header_pstr[4 + nv.namelen + 4], nv.value, nv.valuelen);\r\ncached_pstr = (char *)wmem_map_lookup(http2_hdrcache_map, http2_header_pstr);\r\nif (cached_pstr) {\r\nout->table.data.data = cached_pstr;\r\n} else {\r\nwmem_map_insert(http2_hdrcache_map, http2_header_pstr, http2_header_pstr);\r\nout->table.data.data = http2_header_pstr;\r\nhttp2_header_pstr = NULL;\r\n}\r\nwmem_array_append(headers, out, 1);\r\nreset_http2_header_repr_info(header_repr_info);\r\n}\r\nif(inflate_flags & NGHTTP2_HD_INFLATE_FINAL) {\r\nnghttp2_hd_inflate_end_headers(hd_inflater);\r\nbreak;\r\n}\r\nif((inflate_flags & NGHTTP2_HD_INFLATE_EMIT) == 0 &&\r\nheadlen == 0) {\r\nbreak;\r\n}\r\n}\r\nwmem_list_append(header_list, headers);\r\nif(!header_data->current) {\r\nheader_data->current = wmem_list_head(header_list);\r\n}\r\n} else {\r\nheaders = (wmem_array_t*)wmem_list_frame_data(header_data->current);\r\nheader_data->current = wmem_list_frame_next(header_data->current);\r\nif(!header_data->current) {\r\nheader_data->current = wmem_list_head(header_list);\r\n}\r\n}\r\nif(wmem_array_get_count(headers) == 0) {\r\nreturn;\r\n}\r\nfor(i = 0; i < wmem_array_get_count(headers); ++i) {\r\nhttp2_header_t *in;\r\ntvbuff_t *next_tvb;\r\nin = (http2_header_t*)wmem_array_index(headers, i);\r\nif(in->type == HTTP2_HD_HEADER_TABLE_SIZE_UPDATE) {\r\ncontinue;\r\n}\r\nheader_len += in->table.data.datalen;\r\nnext_tvb = tvb_new_child_real_data(tvb, in->table.data.data, in->table.data.datalen, in->table.data.datalen);\r\ntvb_composite_append(header_tvb, next_tvb);\r\n}\r\ntvb_composite_finalize(header_tvb);\r\nadd_new_data_source(pinfo, header_tvb, "Decompressed Header");\r\nti = proto_tree_add_uint(tree, hf_http2_header_length, header_tvb, hoffset, 1, header_len);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nif (header_data->header_size_attempted > 0) {\r\nexpert_add_info_format(pinfo, ti, &ei_http2_header_size,\r\n"Decompression stopped after %u bytes (%u attempted).",\r\nheader_data->header_size_reached,\r\nheader_data->header_size_attempted);\r\n}\r\nti = proto_tree_add_uint(tree, hf_http2_header_count, header_tvb, hoffset, 1, wmem_array_get_count(headers));\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nif (header_data->header_lines_exceeded) {\r\nexpert_add_info(pinfo, ti, &ei_http2_header_lines);\r\n}\r\nfor(i = 0; i < wmem_array_get_count(headers); ++i) {\r\nhttp2_header_t *in = (http2_header_t*)wmem_array_index(headers, i);\r\nif(in->type == HTTP2_HD_HEADER_TABLE_SIZE_UPDATE) {\r\nheader = proto_tree_add_item(tree, hf_http2_header_table_size_update, tvb, offset, in->length, ENC_NA);\r\nheader_tree = proto_item_add_subtree(header, ett_http2_headers);\r\nproto_tree_add_uint(header_tree, hf_http2_header_table_size, tvb, offset, in->length, in->table.header_table_size);\r\noffset += in->length;\r\ncontinue;\r\n}\r\nheader = proto_tree_add_item(tree, hf_http2_header, tvb, offset, in->length, ENC_NA);\r\nheader_tree = proto_item_add_subtree(header, ett_http2_headers);\r\nheader_name_length = tvb_get_ntohl(header_tvb, hoffset);\r\nproto_tree_add_uint(header_tree, hf_http2_header_name_length, tvb, offset, in->length, header_name_length);\r\nhoffset += 4;\r\nheader_name = (gchar *)tvb_get_string_enc(wmem_packet_scope(), header_tvb, hoffset, header_name_length, ENC_ASCII|ENC_NA);\r\nproto_tree_add_string(header_tree, hf_http2_header_name, tvb, offset, in->length, header_name);\r\nhoffset += header_name_length;\r\nheader_value_length = tvb_get_ntohl(header_tvb, hoffset);\r\nproto_tree_add_uint(header_tree, hf_http2_header_value_length, tvb, offset, in->length, header_value_length);\r\nhoffset += 4;\r\nheader_value = (gchar *)tvb_get_string_enc(wmem_packet_scope(),header_tvb, hoffset, header_value_length, ENC_ASCII|ENC_NA);\r\nproto_tree_add_string(header_tree, hf_http2_header_value, tvb, offset, in->length, header_value);\r\nhoffset += header_value_length;\r\nproto_tree_add_string(header_tree, hf_http2_header_repr, tvb, offset, in->length, http2_header_repr_type[in->type].strptr);\r\nif(in->type == HTTP2_HD_INDEXED ||\r\nin->type == HTTP2_HD_LITERAL_INDEXING_INDEXED_NAME ||\r\nin->type == HTTP2_HD_LITERAL_INDEXED_NAME ||\r\nin->type == HTTP2_HD_LITERAL_NEVER_INDEXING_INDEXED_NAME) {\r\nproto_tree_add_uint(header_tree, hf_http2_header_index, tvb, offset, in->length, in->table.data.idx);\r\n}\r\nproto_item_append_text(header, ": %s: %s", header_name, header_value);\r\noffset += in->length;\r\n}\r\n}\r\nstatic guint8\r\ndissect_http2_header_flags(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *http2_tree, guint offset, guint8 type)\r\n{\r\nproto_item *ti_flags;\r\nproto_tree *flags_tree;\r\nguint8 flags;\r\nti_flags = proto_tree_add_item(http2_tree, hf_http2_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nflags_tree = proto_item_add_subtree(ti_flags, ett_http2_flags);\r\nflags = tvb_get_guint8(tvb, offset);\r\nswitch(type){\r\ncase HTTP2_DATA:\r\nproto_tree_add_item(flags_tree, hf_http2_flags_end_stream, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(flags_tree, hf_http2_flags_padded, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(flags_tree, hf_http2_flags_unused_data, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase HTTP2_HEADERS:\r\nproto_tree_add_item(flags_tree, hf_http2_flags_end_stream, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(flags_tree, hf_http2_flags_end_headers, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(flags_tree, hf_http2_flags_padded, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(flags_tree, hf_http2_flags_priority, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(flags_tree, hf_http2_flags_unused_headers, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase HTTP2_SETTINGS:\r\nproto_tree_add_item(flags_tree, hf_http2_flags_settings_ack, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(flags_tree, hf_http2_flags_unused_settings, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase HTTP2_PUSH_PROMISE:\r\nproto_tree_add_item(flags_tree, hf_http2_flags_end_headers, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(flags_tree, hf_http2_flags_padded, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(flags_tree, hf_http2_flags_unused_push_promise, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase HTTP2_CONTINUATION:\r\nproto_tree_add_item(flags_tree, hf_http2_flags_end_headers, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(flags_tree, hf_http2_flags_unused_continuation, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase HTTP2_PING:\r\nproto_tree_add_item(flags_tree, hf_http2_flags_ping_ack, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(flags_tree, hf_http2_flags_unused_ping, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase HTTP2_PRIORITY:\r\ncase HTTP2_RST_STREAM:\r\ncase HTTP2_GOAWAY:\r\ncase HTTP2_WINDOW_UPDATE:\r\ncase HTTP2_ALTSVC:\r\ncase HTTP2_BLOCKED:\r\ndefault:\r\nproto_tree_add_item(flags_tree, hf_http2_flags_unused, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\nreturn flags;\r\n}\r\nstatic guint\r\ndissect_frame_padding(tvbuff_t *tvb, guint16 *padding, proto_tree *http2_tree,\r\nguint offset, guint8 flags)\r\n{\r\nproto_item *ti;\r\nguint pad_len = 0;\r\n*padding = 0;\r\nif(flags & HTTP2_FLAGS_PADDED)\r\n{\r\n*padding = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(http2_tree, hf_http2_padding, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\npad_len ++;\r\n}\r\nti = proto_tree_add_uint(http2_tree, hf_http2_pad_length, tvb, offset-pad_len, pad_len, *padding);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nreturn offset;\r\n}\r\nstatic guint\r\ndissect_frame_prio(tvbuff_t *tvb, proto_tree *http2_tree, guint offset, guint8 flags)\r\n{\r\nproto_tree *ti;\r\nguint8 weight;\r\nif(flags & HTTP2_FLAGS_PRIORITY)\r\n{\r\nproto_tree_add_item(http2_tree, hf_http2_excl_dependency, tvb, offset, 4, ENC_NA);\r\nproto_tree_add_item(http2_tree, hf_http2_stream_dependency, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(http2_tree, hf_http2_weight, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nweight = tvb_get_guint8(tvb, offset);\r\nti = proto_tree_add_uint(http2_tree, hf_http2_weight_real, tvb, offset, 1, weight+1);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\noffset++;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_http2_data(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *http2_tree,\r\nguint offset, guint8 flags)\r\n{\r\nguint16 padding;\r\ngint datalen;\r\noffset = dissect_frame_padding(tvb, &padding, http2_tree, offset, flags);\r\ndatalen = tvb_reported_length_remaining(tvb, offset) - padding;\r\nproto_tree_add_item(http2_tree, hf_http2_data_data, tvb, offset, datalen, ENC_NA);\r\noffset += datalen;\r\nproto_tree_add_item(http2_tree, hf_http2_data_padding, tvb, offset, padding, ENC_NA);\r\noffset += padding;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_http2_headers(tvbuff_t *tvb, packet_info *pinfo, proto_tree *http2_tree,\r\nguint offset, guint8 flags)\r\n{\r\nguint16 padding;\r\ngint headlen;\r\nhttp2_session_t *h2session;\r\nh2session = get_http2_session(pinfo);\r\noffset = dissect_frame_padding(tvb, &padding, http2_tree, offset, flags);\r\noffset = dissect_frame_prio(tvb, http2_tree, offset, flags);\r\nheadlen = tvb_reported_length_remaining(tvb, offset) - padding;\r\nproto_tree_add_item(http2_tree, hf_http2_headers, tvb, offset, headlen, ENC_NA);\r\ninflate_http2_header_block(tvb, pinfo, offset, http2_tree, headlen, h2session, flags);\r\noffset += headlen;\r\nproto_tree_add_item(http2_tree, hf_http2_headers_padding, tvb, offset, padding, ENC_NA);\r\noffset += padding;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_http2_priority(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *http2_tree,\r\nguint offset, guint8 flags)\r\n{\r\noffset = dissect_frame_prio(tvb, http2_tree, offset,\r\nflags | HTTP2_FLAGS_PRIORITY);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_http2_rst_stream(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *http2_tree, guint offset, guint8 flags _U_)\r\n{\r\nproto_tree_add_item(http2_tree, hf_http2_rst_stream_error, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_http2_settings(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *http2_tree, guint offset, guint8 flags)\r\n{\r\nguint32 settingsid;\r\nproto_item *ti_settings;\r\nproto_tree *settings_tree;\r\nguint32 header_table_size;\r\nguint32 min_header_table_size;\r\nint header_table_size_found;\r\nhttp2_session_t *h2session;\r\nheader_table_size_found = 0;\r\nheader_table_size = 0;\r\nmin_header_table_size = 0xFFFFFFFFu;\r\nwhile(tvb_reported_length_remaining(tvb, offset) > 0){\r\nti_settings = proto_tree_add_item(http2_tree, hf_http2_settings, tvb, offset, 5, ENC_NA);\r\nsettings_tree = proto_item_add_subtree(ti_settings, ett_http2_settings);\r\nproto_tree_add_item(settings_tree, hf_http2_settings_identifier, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nsettingsid = tvb_get_ntohs(tvb, offset);\r\nproto_item_append_text(ti_settings, " - %s",\r\nval_to_str( settingsid, http2_settings_vals, "Unknown (%u)") );\r\noffset += 2;\r\nswitch(settingsid){\r\ncase HTTP2_SETTINGS_HEADER_TABLE_SIZE:\r\nproto_tree_add_item(settings_tree, hf_http2_settings_header_table_size, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nheader_table_size_found = 1;\r\nheader_table_size = tvb_get_ntohl(tvb, offset);\r\nif(min_header_table_size > header_table_size) {\r\nmin_header_table_size = header_table_size;\r\n}\r\nbreak;\r\ncase HTTP2_SETTINGS_ENABLE_PUSH:\r\nproto_tree_add_item(settings_tree, hf_http2_settings_enable_push, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase HTTP2_SETTINGS_MAX_CONCURRENT_STREAMS:\r\nproto_tree_add_item(settings_tree, hf_http2_settings_max_concurrent_streams, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase HTTP2_SETTINGS_INITIAL_WINDOW_SIZE:\r\nproto_tree_add_item(settings_tree, hf_http2_settings_initial_window_size, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase HTTP2_SETTINGS_MAX_FRAME_SIZE:\r\nproto_tree_add_item(settings_tree, hf_http2_settings_max_frame_size, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE:\r\nproto_tree_add_item(settings_tree, hf_http2_settings_max_header_list_size, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(settings_tree, hf_http2_settings_unknown, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\nproto_item_append_text(ti_settings, " : %u", tvb_get_ntohl(tvb, offset));\r\noffset += 4;\r\n}\r\nif(!PINFO_FD_VISITED(pinfo)) {\r\nh2session = get_http2_session(pinfo);\r\nif(flags & HTTP2_FLAGS_ACK) {\r\napply_and_pop_settings(pinfo, h2session);\r\n} else {\r\nhttp2_settings_t *settings;\r\nsettings = wmem_new(wmem_file_scope(), http2_settings_t);\r\nsettings->min_header_table_size = min_header_table_size;\r\nsettings->header_table_size = header_table_size;\r\nsettings->has_header_table_size = header_table_size_found;\r\npush_settings(pinfo, h2session, settings);\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_http2_push_promise(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *http2_tree,\r\nguint offset, guint8 flags _U_)\r\n{\r\nguint16 padding;\r\ngint headlen;\r\nhttp2_session_t *h2session;\r\nh2session = get_http2_session(pinfo);\r\noffset = dissect_frame_padding(tvb, &padding, http2_tree, offset, flags);\r\nproto_tree_add_item(http2_tree, hf_http2_push_promise_r, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(http2_tree, hf_http2_push_promise_promised_stream_id, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nheadlen = tvb_reported_length_remaining(tvb, offset) - padding;\r\nproto_tree_add_item(http2_tree, hf_http2_push_promise_header, tvb, offset, headlen,\r\nENC_ASCII|ENC_NA);\r\ninflate_http2_header_block(tvb, pinfo, offset, http2_tree, headlen, h2session, flags);\r\noffset += headlen;\r\nproto_tree_add_item(http2_tree, hf_http2_push_promise_padding, tvb,\r\noffset, padding, ENC_NA);\r\noffset += tvb_reported_length_remaining(tvb, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_http2_ping(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *http2_tree,\r\nguint offset, guint8 flags)\r\n{\r\nif(flags & HTTP2_FLAGS_ACK)\r\n{\r\nproto_tree_add_item(http2_tree, hf_http2_pong, tvb, offset, 8, ENC_NA);\r\n}else{\r\nproto_tree_add_item(http2_tree, hf_http2_ping, tvb, offset, 8, ENC_NA);\r\n}\r\noffset += 8;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_http2_goaway(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *http2_tree, guint offset, guint8 flags _U_)\r\n{\r\nproto_tree_add_item(http2_tree, hf_http2_goaway_r, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(http2_tree, hf_http2_goaway_last_stream_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(http2_tree, hf_http2_goaway_error, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nif(tvb_reported_length_remaining(tvb, offset) > 0)\r\n{\r\nproto_tree_add_item(http2_tree, hf_http2_goaway_addata , tvb, offset, -1, ENC_NA);\r\noffset += tvb_reported_length_remaining(tvb, offset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_http2_window_update(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *http2_tree, guint offset, guint8 flags _U_)\r\n{\r\nproto_tree_add_item(http2_tree, hf_http2_window_update_r, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(http2_tree, hf_http2_window_update_window_size_increment, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_http2_continuation(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *http2_tree, guint offset, guint8 flags)\r\n{\r\nguint16 padding;\r\ngint headlen;\r\nhttp2_session_t *h2session;\r\nh2session = get_http2_session(pinfo);\r\noffset = dissect_frame_padding(tvb, &padding, http2_tree, offset, flags);\r\nheadlen = tvb_reported_length_remaining(tvb, offset) - padding;\r\nproto_tree_add_item(http2_tree, hf_http2_continuation_header, tvb, offset, headlen, ENC_ASCII|ENC_NA);\r\ninflate_http2_header_block(tvb, pinfo, offset, http2_tree, headlen, h2session, flags);\r\noffset += headlen;\r\nproto_tree_add_item(http2_tree, hf_http2_continuation_padding, tvb, offset, padding, ENC_NA);\r\noffset += padding;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_http2_altsvc(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *http2_tree,\r\nguint offset, guint8 flags _U_, guint16 length)\r\n{\r\nguint32 origin_len;\r\nint remain = length;\r\nproto_tree_add_item_ret_uint(http2_tree, hf_http2_altsvc_origin_len, tvb, offset, 2, ENC_BIG_ENDIAN, &origin_len);\r\noffset += 2;\r\nremain -= 2;\r\nproto_tree_add_item(http2_tree, hf_http2_altsvc_origin, tvb, offset, origin_len, ENC_ASCII|ENC_NA);\r\noffset += origin_len;\r\nremain -= origin_len;\r\nif(remain) {\r\nproto_tree_add_item(http2_tree, hf_http2_altsvc_field_value, tvb, offset, remain, ENC_ASCII|ENC_NA);\r\noffset += remain;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_http2_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_ )\r\n{\r\nproto_item *ti;\r\nproto_tree *http2_tree;\r\nguint offset = 0;\r\nguint8 type, flags;\r\nguint16 length;\r\nguint32 streamid;\r\nstruct HTTP2Tap *http2_stats;\r\nif(!p_get_proto_data(wmem_file_scope(), pinfo, proto_http2, 0)) {\r\nhttp2_header_data_t *header_data;\r\nheader_data = wmem_new0(wmem_file_scope(), http2_header_data_t);\r\nheader_data->header_list = wmem_list_new(wmem_file_scope());\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_http2, 0, header_data);\r\n}\r\nti = proto_tree_add_item(tree, hf_http2_stream, tvb, 0, -1, ENC_NA);\r\nhttp2_tree = proto_item_add_subtree(ti, ett_http2_header);\r\nif (tvb_memeql(tvb, offset, kMagicHello, MAGIC_FRAME_LENGTH) == 0 )\r\n{\r\ncol_append_sep_str( pinfo->cinfo, COL_INFO, ", ", "Magic" );\r\nproto_item_set_len(ti, MAGIC_FRAME_LENGTH);\r\nproto_item_append_text(ti, ": Magic");\r\nproto_tree_add_item(http2_tree, hf_http2_magic, tvb, offset, MAGIC_FRAME_LENGTH, ENC_ASCII|ENC_NA);\r\nreturn MAGIC_FRAME_LENGTH;\r\n}\r\nproto_tree_add_item(http2_tree, hf_http2_length, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nlength = tvb_get_ntoh24(tvb, offset);\r\noffset += 3;\r\nproto_tree_add_item(http2_tree, hf_http2_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\ntype = tvb_get_guint8(tvb, offset);\r\ncol_append_sep_fstr( pinfo->cinfo, COL_INFO, ", ", "%s", val_to_str(type, http2_type_vals, "Unknown type (%d)"));\r\noffset += 1;\r\nflags = dissect_http2_header_flags(tvb, pinfo, http2_tree, offset, type);\r\noffset += 1;\r\nproto_tree_add_item(http2_tree, hf_http2_r, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(http2_tree, hf_http2_streamid, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nstreamid = tvb_get_ntohl(tvb, offset) & MASK_HTTP2_STREAMID;\r\nproto_item_append_text(ti, ": %s, Stream ID: %u, Length %u", val_to_str(type, http2_type_vals, "Unknown type (%d)"), streamid, length);\r\noffset += 4;\r\nhttp2_stats = wmem_new0(wmem_packet_scope(), struct HTTP2Tap);\r\nhttp2_stats->type = type;\r\nswitch(type){\r\ncase HTTP2_DATA:\r\ndissect_http2_data(tvb, pinfo, http2_tree, offset, flags);\r\nbreak;\r\ncase HTTP2_HEADERS:\r\ndissect_http2_headers(tvb, pinfo, http2_tree, offset, flags);\r\nbreak;\r\ncase HTTP2_PRIORITY:\r\ndissect_http2_priority(tvb, pinfo, http2_tree, offset, flags);\r\nbreak;\r\ncase HTTP2_RST_STREAM:\r\ndissect_http2_rst_stream(tvb, pinfo, http2_tree, offset, flags);\r\nbreak;\r\ncase HTTP2_SETTINGS:\r\ndissect_http2_settings(tvb, pinfo, http2_tree, offset, flags);\r\nbreak;\r\ncase HTTP2_PUSH_PROMISE:\r\ndissect_http2_push_promise(tvb, pinfo, http2_tree, offset, flags);\r\nbreak;\r\ncase HTTP2_PING:\r\ndissect_http2_ping(tvb, pinfo, http2_tree, offset, flags);\r\nbreak;\r\ncase HTTP2_GOAWAY:\r\ndissect_http2_goaway(tvb, pinfo, http2_tree, offset, flags);\r\nbreak;\r\ncase HTTP2_WINDOW_UPDATE:\r\ndissect_http2_window_update(tvb, pinfo, http2_tree, offset, flags);\r\nbreak;\r\ncase HTTP2_CONTINUATION:\r\ndissect_http2_continuation(tvb, pinfo, http2_tree, offset, flags);\r\nbreak;\r\ncase HTTP2_ALTSVC:\r\ndissect_http2_altsvc(tvb, pinfo, http2_tree, offset, flags, length);\r\nbreak;\r\ncase HTTP2_BLOCKED:\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(http2_tree, hf_http2_unknown, tvb, offset, -1, ENC_NA);\r\nbreak;\r\n}\r\ntap_queue_packet(http2_tap, pinfo, http2_stats);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic guint get_http2_message_len(packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset, void *data _U_)\r\n{\r\nif ( tvb_memeql( tvb, offset, kMagicHello, MAGIC_FRAME_LENGTH ) == 0 ) {\r\nreturn MAGIC_FRAME_LENGTH;\r\n}\r\nreturn (guint)tvb_get_ntoh24(tvb, offset) + FRAME_HEADER_LENGTH;\r\n}\r\nstatic int\r\ndissect_http2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nvoid *data)\r\n{\r\nproto_item *ti;\r\nproto_tree *http2_tree;\r\nif (tvb_captured_length(tvb) < FRAME_HEADER_LENGTH)\r\nreturn 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "HTTP2");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nti = proto_tree_add_item(tree, proto_http2, tvb, 0, -1, ENC_NA);\r\nhttp2_tree = proto_item_add_subtree(ti, ett_http2);\r\ntcp_dissect_pdus(tvb, pinfo, http2_tree, TRUE, FRAME_HEADER_LENGTH,\r\nget_http2_message_len, dissect_http2_pdu, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\ndissect_http2_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nconversation_t *conversation;\r\nhttp2_session_t *session;\r\nconversation = find_or_create_conversation(pinfo);\r\nsession = (http2_session_t *)conversation_get_proto_data(conversation,\r\nproto_http2);\r\nif (session) {\r\ndissect_http2(tvb, pinfo, tree, data);\r\nreturn TRUE;\r\n}\r\nif (tvb_memeql(tvb, 0, kMagicHello, MAGIC_FRAME_LENGTH) != 0) {\r\nreturn FALSE;\r\n}\r\nget_http2_session(pinfo);\r\ndissect_http2(tvb, pinfo, tree, data);\r\nreturn (TRUE);\r\n}\r\nstatic gboolean\r\ndissect_http2_heur_ssl(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\ndissector_handle_t *app_handle = (dissector_handle_t *) data;\r\nif (dissect_http2_heur(tvb, pinfo, tree, NULL)) {\r\n*app_handle = http2_handle;\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nvoid\r\nproto_register_http2(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_http2_stream,\r\n{ "Stream", "http2.stream",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_length,\r\n{ "Length", "http2.length",\r\nFT_UINT24, BASE_DEC, NULL, 0x0,\r\n"The length (24 bits) of the frame payload (The 9 octets of the frame header are not included)", HFILL }\r\n},\r\n{ &hf_http2_type,\r\n{ "Type", "http2.type",\r\nFT_UINT8, BASE_DEC, VALS(http2_type_vals), 0x0,\r\n"The frame type determines how the remainder of the frame header and payload are interpreted", HFILL }\r\n},\r\n{ &hf_http2_r,\r\n{ "Reserved", "http2.r",\r\nFT_UINT32, BASE_HEX, NULL, MASK_HTTP2_RESERVED,\r\n"The semantics of this bit are undefined and the bit MUST remain unset (0) when sending and MUST be ignored when receiving", HFILL }\r\n},\r\n{ &hf_http2_weight,\r\n{ "Weight", "http2.headers.weight",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"An 8-bit weight for the identified priority", HFILL }\r\n},\r\n{ &hf_http2_weight_real,\r\n{ "Weight real", "http2.headers.weight_real",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Real Weight value (Add one to value)", HFILL }\r\n},\r\n{ &hf_http2_streamid,\r\n{ "Stream Identifier", "http2.streamid",\r\nFT_UINT32, BASE_DEC, NULL, MASK_HTTP2_STREAMID,\r\n"A 31-bit stream identifier", HFILL }\r\n},\r\n{ &hf_http2_magic,\r\n{ "Magic", "http2.magic",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_unknown,\r\n{ "Unknown", "http2.unknown",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_flags,\r\n{ "Flags", "http2.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\n"Flags are assigned semantics specific to the indicated frame type", HFILL }\r\n},\r\n{ &hf_http2_flags_end_stream,\r\n{ "End Stream", "http2.flags.end_stream",\r\nFT_BOOLEAN, 8, NULL, HTTP2_FLAGS_END_STREAM,\r\n"Indicates that this frame is the last that the endpoint will send for the identified stream", HFILL }\r\n},\r\n{ &hf_http2_flags_end_headers,\r\n{ "End Headers", "http2.flags.eh",\r\nFT_BOOLEAN, 8, NULL, HTTP2_FLAGS_END_HEADERS,\r\n"Indicates that this frame contains an entire header block and is not followed by any CONTINUATION frames.", HFILL }\r\n},\r\n{ &hf_http2_flags_padded,\r\n{ "Padded", "http2.flags.padded",\r\nFT_BOOLEAN, 8, NULL, HTTP2_FLAGS_PADDED,\r\n"Indicates that the Pad Length field is present", HFILL }\r\n},\r\n{ &hf_http2_flags_priority,\r\n{ "Priority", "http2.flags.priority",\r\nFT_BOOLEAN, 8, NULL, HTTP2_FLAGS_PRIORITY,\r\n"Indicates that the Exclusive Flag (E), Stream Dependency, and Weight fields are present", HFILL }\r\n},\r\n{ &hf_http2_flags_ping_ack,\r\n{ "ACK", "http2.flags.ack.ping",\r\nFT_BOOLEAN, 8, NULL, HTTP2_FLAGS_ACK,\r\n"Set indicates that this PING frame is a PING response", HFILL }\r\n},\r\n{ &hf_http2_flags_unused,\r\n{ "Unused", "http2.flags.unused",\r\nFT_UINT8, BASE_HEX, NULL, HTTP2_FLAGS_UNUSED,\r\n"Must be zero", HFILL }\r\n},\r\n{ &hf_http2_flags_unused_settings,\r\n{ "Unused", "http2.flags.unused_settings",\r\nFT_UINT8, BASE_HEX, NULL, HTTP2_FLAGS_UNUSED_SETTINGS,\r\n"Must be zero", HFILL }\r\n},\r\n{ &hf_http2_flags_unused_ping,\r\n{ "Unused", "http2.flags.unused_ping",\r\nFT_UINT8, BASE_HEX, NULL, HTTP2_FLAGS_UNUSED_PING,\r\n"Must be zero", HFILL }\r\n},\r\n{ &hf_http2_flags_unused_continuation,\r\n{ "Unused", "http2.flags.unused_continuation",\r\nFT_UINT8, BASE_HEX, NULL, HTTP2_FLAGS_UNUSED_CONTINUATION,\r\n"Must be zero", HFILL }\r\n},\r\n{ &hf_http2_flags_unused_push_promise,\r\n{ "Unused", "http2.flags.unused_push_promise",\r\nFT_UINT8, BASE_HEX, NULL, HTTP2_FLAGS_UNUSED_PUSH_PROMISE,\r\n"Must be zero", HFILL }\r\n},\r\n{ &hf_http2_flags_unused_data,\r\n{ "Unused", "http2.flags.unused_data",\r\nFT_UINT8, BASE_HEX, NULL, HTTP2_FLAGS_UNUSED_DATA,\r\n"Must be zero", HFILL }\r\n},\r\n{ &hf_http2_flags_unused_headers,\r\n{ "Unused", "http2.flags.unused_headers",\r\nFT_UINT8, BASE_HEX, NULL, HTTP2_FLAGS_UNUSED_HEADERS,\r\n"Must be zero", HFILL }\r\n},\r\n{ &hf_http2_flags_settings_ack,\r\n{ "ACK", "http2.flags.ack.settings",\r\nFT_BOOLEAN, 8, NULL, HTTP2_FLAGS_ACK,\r\n"Indicates that this frame acknowledges receipt and application of the peer's SETTINGS frame", HFILL }\r\n},\r\n{ &hf_http2_padding,\r\n{ "Pad Length", "http2.padding",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\n"Padding size", HFILL }\r\n},\r\n{ &hf_http2_pad_length,\r\n{ "Pad Length", "http2.pad_length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_excl_dependency,\r\n{ "Exclusive", "http2.exclusive",\r\nFT_BOOLEAN, 32, NULL, 0x80000000,\r\n"A single bit flag indicates that the stream dependency is exclusive", HFILL }\r\n},\r\n{ &hf_http2_stream_dependency,\r\n{ "Stream Dependency", "http2.stream_dependency",\r\nFT_UINT32, BASE_DEC, NULL, 0x7FFFFFFF,\r\n"An identifier for the stream that this stream depends on", HFILL }\r\n},\r\n{ &hf_http2_data_data,\r\n{ "Data", "http2.data.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Application data", HFILL }\r\n},\r\n{ &hf_http2_data_padding,\r\n{ "Padding", "http2.data.padding",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Padding octets", HFILL }\r\n},\r\n{ &hf_http2_headers,\r\n{ "Header Block Fragment", "http2.headers",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"A header block fragment", HFILL }\r\n},\r\n{ &hf_http2_headers_padding,\r\n{ "Padding", "http2.headers.padding",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Padding octets", HFILL }\r\n},\r\n{ &hf_http2_header,\r\n{ "Header", "http2.header",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_header_length,\r\n{ "Header Length", "http2.header.length",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_header_count,\r\n{ "Header Count", "http2.header.count",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_header_name_length,\r\n{ "Name Length", "http2.header.name.length",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_header_name,\r\n{ "Name", "http2.header.name",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_header_value_length,\r\n{ "Value Length", "http2.header.value.length",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_header_value,\r\n{ "Value", "http2.header.value",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_header_repr,\r\n{ "Representation", "http2.header.repr",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_header_index,\r\n{ "Index", "http2.header.index",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_header_table_size_update,\r\n{ "Header table size update", "http2.header_table_size_update",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_header_table_size,\r\n{ "Header table size", "http2.header_table_size_update.header_table_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_rst_stream_error,\r\n{ "Error", "http2.rst_stream.error",\r\nFT_UINT32, BASE_DEC, VALS(http2_error_codes_vals), 0x0,\r\n"The error code indicates why the stream is being terminated", HFILL }\r\n},\r\n{ &hf_http2_settings,\r\n{ "Settings", "http2.settings",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_settings_identifier,\r\n{ "Settings Identifier", "http2.settings.id",\r\nFT_UINT16, BASE_DEC, VALS(http2_settings_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_settings_header_table_size,\r\n{ "Header table size", "http2.settings.header_table_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Allows the sender to inform the remote endpoint of the size of the header compression table used to decode header blocks. The initial value is 4096 bytes", HFILL }\r\n},\r\n{ &hf_http2_settings_enable_push,\r\n{ "Enable PUSH", "http2.settings.enable_push",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"The initial value is 1, which indicates that push is permitted", HFILL }\r\n},\r\n{ &hf_http2_settings_max_concurrent_streams,\r\n{ "Max concurrent streams", "http2.settings.max_concurrent_streams",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Indicates the maximum number of concurrent streams that the sender will allow", HFILL }\r\n},\r\n{ &hf_http2_settings_initial_window_size,\r\n{ "Initial Windows Size", "http2.settings.initial_window_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Indicates the sender's initial window size (in bytes) for stream level flow control", HFILL }\r\n},\r\n{ &hf_http2_settings_max_frame_size,\r\n{ "Max frame size", "http2.settings.max_frame_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Indicates the size of the largest frame payload that the sender will allow", HFILL }\r\n},\r\n{ &hf_http2_settings_max_header_list_size,\r\n{ "Max header list size", "http2.settings.max_header_list_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"This advisory setting informs a peer of the maximum size of header list that the sender is prepared to accept.", HFILL }\r\n},\r\n{ &hf_http2_settings_unknown,\r\n{ "Unknown Settings", "http2.settings.unknown",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_push_promise_r,\r\n{ "Reserved", "http2.push_promise.r",\r\nFT_UINT32, BASE_HEX, NULL, MASK_HTTP2_RESERVED,\r\n"Must be zero", HFILL }\r\n},\r\n{ &hf_http2_push_promise_promised_stream_id,\r\n{ "Promised-Stream-ID", "http2.push_promise.promised_stream_id",\r\nFT_UINT32, BASE_DEC, NULL, MASK_HTTP2_PRIORITY,\r\n"Identifies the stream the endpoint intends to start sending frames for", HFILL }\r\n},\r\n{ &hf_http2_push_promise_header,\r\n{ "Header", "http2.push_promise.header",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_push_promise_padding,\r\n{ "Padding", "http2.push_promise.padding",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Padding octets", HFILL }\r\n},\r\n{ &hf_http2_ping,\r\n{ "Ping", "http2.ping",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_pong,\r\n{ "Pong", "http2.pong",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_goaway_r,\r\n{ "Reserved", "http2.goway.r",\r\nFT_UINT32, BASE_HEX, NULL, MASK_HTTP2_RESERVED,\r\n"Must be zero", HFILL }\r\n},\r\n{ &hf_http2_goaway_last_stream_id,\r\n{ "Promised-Stream-ID", "http2.goaway.last_stream_id",\r\nFT_UINT32, BASE_DEC, NULL, MASK_HTTP2_PRIORITY,\r\n"Contains the highest numbered stream identifier for which the sender of the GOAWAY frame has received frames on and might have taken some action on", HFILL }\r\n},\r\n{ &hf_http2_goaway_error,\r\n{ "Error", "http2.goaway.error",\r\nFT_UINT32, BASE_DEC, VALS(http2_error_codes_vals), 0x0,\r\n"The error code indicates the reason for closing the connection", HFILL }\r\n},\r\n{ &hf_http2_goaway_addata,\r\n{ "Additional Debug Data", "http2.goaway.addata",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_http2_window_update_r,\r\n{ "Reserved", "http2.window_update.r",\r\nFT_UINT32, BASE_HEX, NULL, MASK_HTTP2_RESERVED,\r\n"Must be zero", HFILL }\r\n},\r\n{ &hf_http2_window_update_window_size_increment,\r\n{ "Window Size Increment", "http2.window_update.window_size_increment",\r\nFT_UINT32, BASE_DEC, NULL, MASK_HTTP2_PRIORITY,\r\n"Indicating the number of bytes that the sender can transmit in addition to the existing flow control window", HFILL }\r\n},\r\n{ &hf_http2_continuation_header,\r\n{ "Continuation Header", "http2.continuation.header",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Contains a header block fragment", HFILL }\r\n},\r\n{ &hf_http2_continuation_padding,\r\n{ "Padding", "http2.continuation.padding",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Padding octets", HFILL }\r\n},\r\n{ &hf_http2_altsvc_origin_len,\r\n{ "Origin Length", "http2.altsvc.origin.len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"indicating the length, in octets, of the Origin field.", HFILL }\r\n},\r\n{ &hf_http2_altsvc_origin,\r\n{ "Origin", "http2.altsvc.origin",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"A sequence of characters containing ASCII serialisation of an "\r\n"origin that the alternate service is applicable to.", HFILL }\r\n},\r\n{ &hf_http2_altsvc_field_value,\r\n{ "Field/Value", "http2.altsvc.field_value",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"A sequence of octets containing a value identical to the Alt-Svc field value", HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_http2,\r\n&ett_http2_header,\r\n&ett_http2_headers,\r\n&ett_http2_flags,\r\n&ett_http2_settings\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_http2_header_size,\r\n{ "http2.header_size_exceeded", PI_UNDECODED, PI_ERROR,\r\n"Decompression stopped.", EXPFILL }\r\n},\r\n{ &ei_http2_header_lines,\r\n{ "http2.header_lines_exceeded", PI_UNDECODED, PI_ERROR,\r\n"Decompression stopped after " G_STRINGIFY(MAX_HTTP2_HEADER_LINES) " header lines.", EXPFILL }\r\n}\r\n};\r\nmodule_t *http2_module;\r\nexpert_module_t *expert_http2;\r\nproto_http2 = proto_register_protocol("HyperText Transfer Protocol 2", "HTTP2", "http2");\r\nproto_register_field_array(proto_http2, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nhttp2_module = prefs_register_protocol(proto_http2, NULL);\r\nexpert_http2 = expert_register_protocol(proto_http2);\r\nexpert_register_field_array(expert_http2, ei, array_length(ei));\r\nprefs_register_obsolete_preference(http2_module, "heuristic_http2");\r\nhttp2_handle = register_dissector("http2", dissect_http2, proto_http2);\r\nhttp2_tap = register_tap("http2");\r\n}\r\nstatic void http2_stats_tree_init(stats_tree* st)\r\n{\r\nst_node_http2 = stats_tree_create_node(st, st_str_http2, 0, TRUE);\r\nst_node_http2_type = stats_tree_create_pivot(st, st_str_http2_type, st_node_http2);\r\n}\r\nstatic int http2_stats_tree_packet(stats_tree* st, packet_info* pinfo _U_, epan_dissect_t* edt _U_, const void* p)\r\n{\r\nconst struct HTTP2Tap *pi = (const struct HTTP2Tap *)p;\r\ntick_stat_node(st, st_str_http2, 0, FALSE);\r\nstats_tree_tick_pivot(st, st_node_http2_type,\r\nval_to_str(pi->type, http2_type_vals, "Unknown type (%d)"));\r\nreturn 1;\r\n}\r\nvoid\r\nproto_reg_handoff_http2(void)\r\n{\r\ndissector_add_for_decode_as("tcp.port", http2_handle);\r\nheur_dissector_add("ssl", dissect_http2_heur_ssl, "HTTP2 over SSL", "http2_ssl", proto_http2, HEURISTIC_ENABLE);\r\nheur_dissector_add("http", dissect_http2_heur, "HTTP2 over TCP", "http2_tcp", proto_http2, HEURISTIC_ENABLE);\r\nstats_tree_register("http2", "http2", "HTTP2", 0, http2_stats_tree_packet, http2_stats_tree_init, NULL);\r\n}
