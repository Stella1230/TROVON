static int\r\ndissect_ipvs_syncd(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data _U_)\r\n{\r\nproto_tree *tree;\r\nproto_item *item;\r\nint offset = 0;\r\nguint8 cnt = 0;\r\nint conn = 0;\r\nitem = proto_tree_add_item(parent_tree, proto_ipvs_syncd, tvb, offset, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_ipvs_syncd);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "IPVS");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ncnt = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_conn_count, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_syncid, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nfor (conn = 0; conn < cnt; conn++)\r\n{\r\nproto_tree *ctree;\r\nproto_tree *ftree, *fi;\r\nguint16 flags;\r\nctree = proto_tree_add_subtree_format(tree, tvb, offset, 24, ett_conn, NULL,\r\n"Connection #%d", conn+1);\r\nproto_tree_add_item(ctree, hf_resv8, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(ctree, hf_proto, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(ctree, hf_cport, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(ctree, hf_vport, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(ctree, hf_dport, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(ctree, hf_caddr, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(ctree, hf_vaddr, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(ctree, hf_daddr, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nflags = tvb_get_ntohs(tvb, offset);\r\nfi = proto_tree_add_item(ctree, hf_flags, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nftree = proto_item_add_subtree(fi, ett_flags);\r\nproto_tree_add_item(ftree, hf_flags_conn_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ftree, hf_flags_hashed_entry, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ftree, hf_flags_no_output_packets, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ftree, hf_flags_conn_not_established, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ftree, hf_flags_adjust_output_seq, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ftree, hf_flags_adjust_input_seq, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ftree, hf_flags_no_client_port_set, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(ctree, hf_state, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif ( flags & IP_VS_CONN_F_SEQ_MASK )\r\n{\r\nproto_tree_add_item(ctree, hf_in_seq_init, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(ctree, hf_in_seq_delta, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(ctree, hf_in_seq_pdelta, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(ctree, hf_out_seq_init, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(ctree, hf_out_seq_delta, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(ctree, hf_out_seq_pdelta, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ipvs_syncd(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_conn_count,\r\n{ "Connection Count", "ipvs.conncount", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_syncid,\r\n{ "Synchronization ID", "ipvs.syncid", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_size,\r\n{ "Size", "ipvs.size", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_resv8,\r\n{ "Reserved", "ipvs.resv8", FT_UINT8, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_proto,\r\n{ "Protocol", "ipvs.proto", FT_UINT8, BASE_HEX,\r\nVALS(proto_strings), 0, NULL, HFILL }},\r\n{ &hf_cport,\r\n{ "Client Port", "ipvs.cport", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_vport,\r\n{ "Virtual Port", "ipvs.vport", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_dport,\r\n{ "Destination Port", "ipvs.dport", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_caddr,\r\n{ "Client Address", "ipvs.caddr", FT_IPv4, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_vaddr,\r\n{ "Virtual Address", "ipvs.vaddr", FT_IPv4, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_daddr,\r\n{ "Destination Address", "ipvs.daddr", FT_IPv4, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_flags,\r\n{ "Flags", "ipvs.flags", FT_UINT16, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_flags_conn_type,\r\n{ "Connection Type", "ipvs.flags.conn_type", FT_UINT16, BASE_HEX,\r\nVALS(connection_type_strings), 0x0F, NULL, HFILL }},\r\n{ &hf_flags_hashed_entry,\r\n{ "Hashed Entry", "ipvs.flags.hashed_entry", FT_BOOLEAN, 16,\r\nTFS(&tfs_true_false), IP_VS_CONN_F_HASHED, NULL, HFILL }},\r\n{ &hf_flags_no_output_packets,\r\n{ "No Output Packets", "ipvs.flags.no_output_packets", FT_BOOLEAN, 16,\r\nTFS(&tfs_true_false), IP_VS_CONN_F_NOOUTPUT, NULL, HFILL }},\r\n{ &hf_flags_conn_not_established,\r\n{ "Connection Not Established", "ipvs.flags.conn_not_established", FT_BOOLEAN, 16,\r\nTFS(&tfs_true_false), IP_VS_CONN_F_INACTIVE, NULL, HFILL }},\r\n{ &hf_flags_adjust_output_seq,\r\n{ "Adjust Output Sequence", "ipvs.flags.adjust_output_seq", FT_BOOLEAN, 16,\r\nTFS(&tfs_true_false), IP_VS_CONN_F_OUT_SEQ, NULL, HFILL }},\r\n{ &hf_flags_adjust_input_seq,\r\n{ "Adjust Input Sequence", "ipvs.flags.adjust_input_seq", FT_BOOLEAN, 16,\r\nTFS(&tfs_true_false), IP_VS_CONN_F_IN_SEQ, NULL, HFILL }},\r\n{ &hf_flags_no_client_port_set,\r\n{ "No Client Port Set", "ipvs.flags.no_client_port_set", FT_BOOLEAN, 16,\r\nTFS(&tfs_true_false), IP_VS_CONN_F_NO_CPORT, NULL, HFILL }},\r\n{ &hf_state,\r\n{ "State", "ipvs.state", FT_UINT16, BASE_HEX,\r\nVALS(state_strings), 0, NULL, HFILL }},\r\n{ &hf_in_seq_init,\r\n{ "Input Sequence (Initial)", "ipvs.in_seq.initial", FT_UINT32,\r\nBASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_in_seq_delta,\r\n{ "Input Sequence (Delta)", "ipvs.in_seq.delta", FT_UINT32,\r\nBASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_in_seq_pdelta,\r\n{ "Input Sequence (Previous Delta)", "ipvs.in_seq.pdelta", FT_UINT32,\r\nBASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_out_seq_init,\r\n{ "Output Sequence (Initial)", "ipvs.out_seq.initial", FT_UINT32,\r\nBASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_out_seq_delta,\r\n{ "Output Sequence (Delta)", "ipvs.out_seq.delta", FT_UINT32,\r\nBASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_out_seq_pdelta,\r\n{ "Output Sequence (Previous Delta)", "ipvs.out_seq.pdelta", FT_UINT32,\r\nBASE_HEX, NULL, 0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ipvs_syncd,\r\n&ett_conn,\r\n&ett_flags,\r\n};\r\nproto_ipvs_syncd = proto_register_protocol("IP Virtual Services Sync Daemon",\r\n"IPVS", "ipvs");\r\nproto_register_field_array(proto_ipvs_syncd, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_ipvs_syncd(void)\r\n{\r\ndissector_handle_t ipvs_syncd_handle;\r\nipvs_syncd_handle = create_dissector_handle(dissect_ipvs_syncd, proto_ipvs_syncd);\r\ndissector_add_uint("udp.port", IPVS_SYNCD_PORT, ipvs_syncd_handle);\r\n}
