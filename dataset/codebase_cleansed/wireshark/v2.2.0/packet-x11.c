static void atom(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nguint byte_order)\r\n{\r\nconst char *interpretation = NULL;\r\nguint32 v = VALUE32(tvb, *offsetp);\r\nif (v >= 1 && v < array_length(atom_predefined_interpretation))\r\ninterpretation = atom_predefined_interpretation[v];\r\nelse if (v)\r\ninterpretation = "Not a predefined atom";\r\nelse {\r\nheader_field_info *hfi = proto_registrar_get_nth(hf);\r\nif (hfi -> strings)\r\ninterpretation = try_val_to_str(v, cVALS(hfi -> strings));\r\n}\r\nif (!interpretation) interpretation = "error in Xlib client program ?";\r\nproto_tree_add_uint_format(t, hf, tvb, *offsetp, 4, v, "%s: %u (%s)",\r\nproto_registrar_get_nth(hf) -> name, v, interpretation);\r\n*offsetp += 4;\r\n}\r\nstatic guint32 add_boolean(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf)\r\n{\r\nguint32 v = VALUE8(tvb, *offsetp);\r\nproto_tree_add_boolean(t, hf, tvb, *offsetp, 1, v);\r\n*offsetp += 1;\r\nreturn v;\r\n}\r\nstatic void colorFlags(tvbuff_t *tvb, int *offsetp, proto_tree *t)\r\n{\r\nguint do_red_green_blue = VALUE8(tvb, *offsetp);\r\nproto_item *ti;\r\nproto_tree *tt;\r\nif (do_red_green_blue) {\r\nint sep = FALSE;\r\nwmem_strbuf_t *buffer = wmem_strbuf_new_label(wmem_packet_scope());\r\nwmem_strbuf_append(buffer, "flags: ");\r\nif (do_red_green_blue & 0x1) {\r\nwmem_strbuf_append(buffer, "DoRed");\r\nsep = TRUE;\r\n}\r\nif (do_red_green_blue & 0x2) {\r\nif (sep) wmem_strbuf_append(buffer, " | ");\r\nwmem_strbuf_append(buffer, "DoGreen");\r\nsep = TRUE;\r\n}\r\nif (do_red_green_blue & 0x4) {\r\nif (sep) wmem_strbuf_append(buffer, " | ");\r\nwmem_strbuf_append(buffer, "DoBlue");\r\nsep = TRUE;\r\n}\r\nif (do_red_green_blue & 0xf8) {\r\nif (sep) wmem_strbuf_append(buffer, " + trash");\r\n}\r\nti = proto_tree_add_uint_format(t, hf_x11_coloritem_flags, tvb, *offsetp, 1, do_red_green_blue,\r\n"%s", wmem_strbuf_get_str(buffer));\r\ntt = proto_item_add_subtree(ti, ett_x11_color_flags);\r\nif (do_red_green_blue & 0x1)\r\nproto_tree_add_boolean(tt, hf_x11_coloritem_flags_do_red, tvb, *offsetp, 1,\r\ndo_red_green_blue & 0x1);\r\nif (do_red_green_blue & 0x2)\r\nproto_tree_add_boolean(tt, hf_x11_coloritem_flags_do_green, tvb, *offsetp, 1,\r\ndo_red_green_blue & 0x2);\r\nif (do_red_green_blue & 0x4)\r\nproto_tree_add_boolean(tt, hf_x11_coloritem_flags_do_blue, tvb, *offsetp, 1,\r\ndo_red_green_blue & 0x4);\r\nif (do_red_green_blue & 0xf8)\r\nproto_tree_add_boolean(tt, hf_x11_coloritem_flags_unused, tvb, *offsetp, 1,\r\ndo_red_green_blue & 0xf8);\r\n} else\r\nproto_tree_add_uint_format(t, hf_x11_coloritem_flags, tvb, *offsetp, 1, do_red_green_blue,\r\n"flags: none");\r\n*offsetp += 1;\r\n}\r\nstatic void gravity(tvbuff_t *tvb, int *offsetp, proto_tree *t,\r\nint hf, const char *nullInterpretation)\r\n{\r\nguint8 v = VALUE8(tvb, *offsetp);\r\nif (!v)\r\nproto_tree_add_uint_format(t, hf, tvb, *offsetp, 1, v, "%s: 0 (%s)",\r\nproto_registrar_get_nth(hf) -> name,\r\nnullInterpretation);\r\nelse\r\nproto_tree_add_uint(t, hf, tvb, *offsetp, 1, v);\r\n*offsetp += 1;\r\n}\r\nstatic void listOfArc(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint length, guint byte_order)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp, length * 8, byte_order);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_arc);\r\nwhile(length--) {\r\ngint16 x = VALUE16(tvb, *offsetp);\r\ngint16 y = VALUE16(tvb, *offsetp + 2);\r\nguint16 width = VALUE16(tvb, *offsetp + 4);\r\nguint16 height = VALUE16(tvb, *offsetp + 6);\r\ngint16 angle1 = VALUE16(tvb, *offsetp + 8);\r\ngint16 angle2 = VALUE16(tvb, *offsetp + 10);\r\nproto_item *tti = proto_tree_add_none_format(tt, hf_x11_arc, tvb, *offsetp, 12,\r\n"arc: %dx%d+%d+%d, angle %d -> %d (%f degrees -> %f degrees)",\r\nwidth, height, x, y, angle1, angle2,\r\nangle1 / 64.0, angle2 / 64.0);\r\nproto_tree *ttt = proto_item_add_subtree(tti, ett_x11_arc);\r\nproto_tree_add_int(ttt, hf_x11_arc_x, tvb, *offsetp, 2, x);\r\n*offsetp += 2;\r\nproto_tree_add_int(ttt, hf_x11_arc_y, tvb, *offsetp, 2, y);\r\n*offsetp += 2;\r\nproto_tree_add_uint(ttt, hf_x11_arc_width, tvb, *offsetp, 2, y);\r\n*offsetp += 2;\r\nproto_tree_add_uint(ttt, hf_x11_arc_height, tvb, *offsetp, 2, y);\r\n*offsetp += 2;\r\nproto_tree_add_int(ttt, hf_x11_arc_angle1, tvb, *offsetp, 2, y);\r\n*offsetp += 2;\r\nproto_tree_add_int(ttt, hf_x11_arc_angle2, tvb, *offsetp, 2, y);\r\n*offsetp += 2;\r\n}\r\n}\r\nstatic void listOfAtom(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint length, guint byte_order)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp, length * 4, byte_order);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_atom);\r\nwhile(length--)\r\natom(tvb, offsetp, tt, hf_x11_properties_item, byte_order);\r\n}\r\nstatic void listOfByte(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint length, guint byte_order)\r\n{\r\nif (length <= 0) length = 1;\r\nproto_tree_add_item(t, hf, tvb, *offsetp, length, byte_order);\r\n*offsetp += length;\r\n}\r\nstatic void listOfCard16(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint hf_item, int length, guint byte_order)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp, length * 2, byte_order);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_card32);\r\nwhile(length--) {\r\nproto_tree_add_uint(tt, hf_item, tvb, *offsetp, 2, VALUE16(tvb, *offsetp));\r\n*offsetp += 2;\r\n}\r\n}\r\nstatic void listOfInt16(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint hf_item, int length, guint byte_order)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp, length * 2, byte_order);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_card32);\r\nwhile(length--) {\r\nproto_tree_add_int(tt, hf_item, tvb, *offsetp, 2, VALUE16(tvb, *offsetp));\r\n*offsetp += 2;\r\n}\r\n}\r\nstatic void listOfCard32(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint hf_item, int length, guint byte_order)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp, length * 4, byte_order);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_card32);\r\nwhile(length--) {\r\nproto_tree_add_uint(tt, hf_item, tvb, *offsetp, 4, VALUE32(tvb, *offsetp));\r\n*offsetp += 4;\r\n}\r\n}\r\nstatic void listOfInt32(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint hf_item, int length, guint byte_order)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp, length * 4, byte_order);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_card32);\r\nwhile(length--) {\r\nproto_tree_add_int(tt, hf_item, tvb, *offsetp, 4, VALUE32(tvb, *offsetp));\r\n*offsetp += 4;\r\n}\r\n}\r\nstatic void listOfFloat(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint hf_item, int length, guint byte_order)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp, length * 4, byte_order);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_float);\r\nwhile(length--) {\r\nproto_tree_add_float(tt, hf_item, tvb, *offsetp, 4, FLOAT(tvb, *offsetp));\r\n*offsetp += 4;\r\n}\r\n}\r\nstatic void listOfDouble(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint hf_item, int length, guint byte_order)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp, length * 8, byte_order);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_double);\r\nwhile(length--) {\r\nproto_tree_add_double(tt, hf_item, tvb, *offsetp, 8, DOUBLE(tvb, *offsetp));\r\n*offsetp += 8;\r\n}\r\n}\r\nstatic void listOfColorItem(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint length, guint byte_order)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp, length * 8, byte_order);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_color_item);\r\nwhile(length--) {\r\nproto_item *tti;\r\nproto_tree *ttt;\r\nguint do_red_green_blue;\r\nguint16 red, green, blue;\r\nwmem_strbuf_t *buffer;\r\nconst char *sep;\r\nbuffer=wmem_strbuf_new_label(wmem_packet_scope());\r\nwmem_strbuf_append(buffer, "colorItem ");\r\nred = VALUE16(tvb, *offsetp + 4);\r\ngreen = VALUE16(tvb, *offsetp + 6);\r\nblue = VALUE16(tvb, *offsetp + 8);\r\ndo_red_green_blue = VALUE8(tvb, *offsetp + 10);\r\nsep = "";\r\nif (do_red_green_blue & 0x1) {\r\nwmem_strbuf_append_printf(buffer, "red = %d", red);\r\nsep = ", ";\r\n}\r\nif (do_red_green_blue & 0x2) {\r\nwmem_strbuf_append_printf(buffer, "%sgreen = %d", sep, green);\r\nsep = ", ";\r\n}\r\nif (do_red_green_blue & 0x4)\r\nwmem_strbuf_append_printf(buffer, "%sblue = %d", sep, blue);\r\ntti = proto_tree_add_none_format(tt, hf_x11_coloritem, tvb, *offsetp, 12, "%s", wmem_strbuf_get_str(buffer));\r\nttt = proto_item_add_subtree(tti, ett_x11_color_item);\r\nproto_tree_add_item(ttt, hf_x11_coloritem_pixel, tvb, *offsetp, 4, byte_order);\r\n*offsetp += 4;\r\nproto_tree_add_item(ttt, hf_x11_coloritem_red, tvb, *offsetp, 2, byte_order);\r\n*offsetp += 2;\r\nproto_tree_add_item(ttt, hf_x11_coloritem_green, tvb, *offsetp, 2, byte_order);\r\n*offsetp += 2;\r\nproto_tree_add_item(ttt, hf_x11_coloritem_blue, tvb, *offsetp, 2, byte_order);\r\n*offsetp += 2;\r\ncolorFlags(tvb, offsetp, ttt);\r\nproto_tree_add_item(ttt, hf_x11_coloritem_unused, tvb, *offsetp, 1, byte_order);\r\n*offsetp += 1;\r\n}\r\n}\r\nstatic void\r\nXConvertCase(register int sym, int *lower, int *upper)\r\n{\r\n*lower = sym;\r\n*upper = sym;\r\nswitch(sym >> 8) {\r\ncase 0:\r\nif ((sym >= XK_A) && (sym <= XK_Z))\r\n*lower += (XK_a - XK_A);\r\nelse if ((sym >= XK_a) && (sym <= XK_z))\r\n*upper -= (XK_a - XK_A);\r\nelse if ((sym >= XK_Agrave) && (sym <= XK_Odiaeresis))\r\n*lower += (XK_agrave - XK_Agrave);\r\nelse if ((sym >= XK_agrave) && (sym <= XK_odiaeresis))\r\n*upper -= (XK_agrave - XK_Agrave);\r\nelse if ((sym >= XK_Ooblique) && (sym <= XK_Thorn))\r\n*lower += (XK_oslash - XK_Ooblique);\r\nelse if ((sym >= XK_oslash) && (sym <= XK_thorn))\r\n*upper -= (XK_oslash - XK_Ooblique);\r\nbreak;\r\ncase 1:\r\nif (sym == XK_Aogonek)\r\n*lower = XK_aogonek;\r\nelse if (sym >= XK_Lstroke && sym <= XK_Sacute)\r\n*lower += (XK_lstroke - XK_Lstroke);\r\nelse if (sym >= XK_Scaron && sym <= XK_Zacute)\r\n*lower += (XK_scaron - XK_Scaron);\r\nelse if (sym >= XK_Zcaron && sym <= XK_Zabovedot)\r\n*lower += (XK_zcaron - XK_Zcaron);\r\nelse if (sym == XK_aogonek)\r\n*upper = XK_Aogonek;\r\nelse if (sym >= XK_lstroke && sym <= XK_sacute)\r\n*upper -= (XK_lstroke - XK_Lstroke);\r\nelse if (sym >= XK_scaron && sym <= XK_zacute)\r\n*upper -= (XK_scaron - XK_Scaron);\r\nelse if (sym >= XK_zcaron && sym <= XK_zabovedot)\r\n*upper -= (XK_zcaron - XK_Zcaron);\r\nelse if (sym >= XK_Racute && sym <= XK_Tcedilla)\r\n*lower += (XK_racute - XK_Racute);\r\nelse if (sym >= XK_racute && sym <= XK_tcedilla)\r\n*upper -= (XK_racute - XK_Racute);\r\nbreak;\r\ncase 2:\r\nif (sym >= XK_Hstroke && sym <= XK_Hcircumflex)\r\n*lower += (XK_hstroke - XK_Hstroke);\r\nelse if (sym >= XK_Gbreve && sym <= XK_Jcircumflex)\r\n*lower += (XK_gbreve - XK_Gbreve);\r\nelse if (sym >= XK_hstroke && sym <= XK_hcircumflex)\r\n*upper -= (XK_hstroke - XK_Hstroke);\r\nelse if (sym >= XK_gbreve && sym <= XK_jcircumflex)\r\n*upper -= (XK_gbreve - XK_Gbreve);\r\nelse if (sym >= XK_Cabovedot && sym <= XK_Scircumflex)\r\n*lower += (XK_cabovedot - XK_Cabovedot);\r\nelse if (sym >= XK_cabovedot && sym <= XK_scircumflex)\r\n*upper -= (XK_cabovedot - XK_Cabovedot);\r\nbreak;\r\ncase 3:\r\nif (sym >= XK_Rcedilla && sym <= XK_Tslash)\r\n*lower += (XK_rcedilla - XK_Rcedilla);\r\nelse if (sym >= XK_rcedilla && sym <= XK_tslash)\r\n*upper -= (XK_rcedilla - XK_Rcedilla);\r\nelse if (sym == XK_ENG)\r\n*lower = XK_eng;\r\nelse if (sym == XK_eng)\r\n*upper = XK_ENG;\r\nelse if (sym >= XK_Amacron && sym <= XK_Umacron)\r\n*lower += (XK_amacron - XK_Amacron);\r\nelse if (sym >= XK_amacron && sym <= XK_umacron)\r\n*upper -= (XK_amacron - XK_Amacron);\r\nbreak;\r\ncase 6:\r\nif (sym >= XK_Serbian_DJE && sym <= XK_Serbian_DZE)\r\n*lower -= (XK_Serbian_DJE - XK_Serbian_dje);\r\nelse if (sym >= XK_Serbian_dje && sym <= XK_Serbian_dze)\r\n*upper += (XK_Serbian_DJE - XK_Serbian_dje);\r\nelse if (sym >= XK_Cyrillic_YU && sym <= XK_Cyrillic_HARDSIGN)\r\n*lower -= (XK_Cyrillic_YU - XK_Cyrillic_yu);\r\nelse if (sym >= XK_Cyrillic_yu && sym <= XK_Cyrillic_hardsign)\r\n*upper += (XK_Cyrillic_YU - XK_Cyrillic_yu);\r\nbreak;\r\ncase 7:\r\nif (sym >= XK_Greek_ALPHAaccent && sym <= XK_Greek_OMEGAaccent)\r\n*lower += (XK_Greek_alphaaccent - XK_Greek_ALPHAaccent);\r\nelse if (sym >= XK_Greek_alphaaccent && sym <= XK_Greek_omegaaccent &&\r\nsym != XK_Greek_iotaaccentdieresis &&\r\nsym != XK_Greek_upsilonaccentdieresis)\r\n*upper -= (XK_Greek_alphaaccent - XK_Greek_ALPHAaccent);\r\nelse if (sym >= XK_Greek_ALPHA && sym <= XK_Greek_OMEGA)\r\n*lower += (XK_Greek_alpha - XK_Greek_ALPHA);\r\nelse if (sym >= XK_Greek_alpha && sym <= XK_Greek_omega &&\r\nsym != XK_Greek_finalsmallsigma)\r\n*upper -= (XK_Greek_alpha - XK_Greek_ALPHA);\r\nbreak;\r\n}\r\n}\r\nstatic const char *\r\nkeycode2keysymString(int *keycodemap[256], int first_keycode,\r\nint keysyms_per_keycode,\r\nint *modifiermap[array_length(modifiers)],\r\nint keycodes_per_modifier,\r\nguint32 keycode, guint32 bitmask)\r\n{\r\nint *syms;\r\nint groupmodkc, numlockkc, numlockmod, groupmod;\r\nint lockmod_is_capslock = 0, lockmod_is_shiftlock = 0;\r\nint lockmod_is_nosymbol = 1;\r\nint modifier, kc, keysym;\r\nif ((syms = keycodemap[keycode]) == NULL)\r\nreturn "<Unknown>";\r\nfor (kc = first_keycode, groupmodkc = numlockkc = -1; kc < 256; ++kc)\r\nfor (keysym = 0; keysym < keysyms_per_keycode; ++keysym) {\r\nif (keycodemap[kc] == NULL)\r\nreturn "<Unknown>";\r\nswitch (keycodemap[kc][keysym]) {\r\ncase 0xff7e:\r\ngroupmodkc = kc;\r\nbreak;\r\ncase 0xff7f:\r\nnumlockkc = kc;\r\nbreak;\r\ncase 0xffe5:\r\nlockmod_is_capslock = kc;\r\nbreak;\r\ncase 0xffe6:\r\nlockmod_is_shiftlock = kc;\r\nbreak;\r\n}\r\n}\r\nif (modifiermap[array_length(modifiers) - 1] == NULL)\r\nreturn "<Unknown>";\r\nfor (modifier = 0, numlockmod = groupmod = -1;\r\nmodifier < (int)array_length(modifiers) && numlockmod == -1;\r\n++modifier)\r\nfor (kc = 0; kc < keycodes_per_modifier; ++kc)\r\nif (modifiermap[modifier][kc] == numlockkc)\r\nnumlockmod = modifier;\r\nelse if (modifiermap[modifier][kc] == groupmodkc)\r\ngroupmod = modifier;\r\nfor (kc = 0; kc < keycodes_per_modifier; ++kc)\r\nif (modifiermap[1][kc] == lockmod_is_capslock) {\r\nlockmod_is_shiftlock = lockmod_is_nosymbol = 0;\r\nbreak;\r\n}\r\nelse if (modifiermap[0][kc] == lockmod_is_shiftlock) {\r\nlockmod_is_capslock = lockmod_is_nosymbol = 0;\r\nbreak;\r\n}\r\n#if 0\r\nif (numlockmod >= 0 && (bitmask & modifiermask[numlockmod])\r\n&& ((syms[1] >= 0xff80\r\n&& syms[1] <= 0xffbd)\r\n|| (syms[1] >= 0x11000000\r\n&& syms[1] <= 0x1100ffff))) {\r\nif ((bitmask & ShiftMask) || lockmod_is_shiftlock)\r\nreturn keysymString(syms[groupmod + 0]);\r\nelse\r\nif (syms[groupmod + 1] == NoSymbol)\r\nreturn keysymString(syms[groupmod + 0]);\r\nelse\r\nreturn keysymString(syms[groupmod + 1]);\r\n}\r\nelse if (!(bitmask & ShiftMask) && !(bitmask & LockMask))\r\nreturn keysymString(syms[groupmod + 0]);\r\nelse if (!(bitmask & ShiftMask)\r\n&& ((bitmask & LockMask) && lockmod_is_capslock))\r\nif (islower(syms[groupmod + 0]))\r\nreturn "Uppercase";\r\nelse\r\nreturn keysymString(syms[groupmod + 0]);\r\nelse if ((bitmask & ShiftMask)\r\n&& ((bitmask & LockMask) && lockmod_is_capslock))\r\nif (islower(syms[groupmod + 1]))\r\nreturn "Uppercase";\r\nelse\r\nreturn keysymString(syms[groupmod + 1]);\r\nelse if ((bitmask & ShiftMask)\r\n|| ((bitmask & LockMask) && lockmod_is_shiftlock))\r\nreturn keysymString(syms[groupmod + 1]);\r\n#else\r\nwhile (keysyms_per_keycode > 2\r\n&& keycodemap[keysyms_per_keycode - 1] == NoSymbol)\r\n--keysyms_per_keycode;\r\nif (keysyms_per_keycode > 2\r\n&& (groupmod >= 0 && (modifiermask[groupmod] & bitmask))) {\r\nsyms += 2;\r\nkeysyms_per_keycode -= 2;\r\n}\r\nif (numlockmod >= 0 && (bitmask & modifiermask[numlockmod])\r\n&& keysyms_per_keycode > 1\r\n&& ((syms[1] >= 0xff80 && syms[1] <= 0xffbd)\r\n|| (syms[1] >= 0x11000000 && syms[1] <= 0x1100ffff))) {\r\nif ((bitmask & ShiftMask)\r\n|| (bitmask & LockMask && lockmod_is_shiftlock))\r\nkeysym = syms[0];\r\nelse\r\nkeysym = syms[1];\r\n}\r\nelse if (!(bitmask & ShiftMask)\r\n&& (!(bitmask & LockMask) || lockmod_is_nosymbol)) {\r\nif (keysyms_per_keycode == 1\r\n|| (keysyms_per_keycode > 1 && syms[1] == NoSymbol)) {\r\nint usym;\r\nXConvertCase(syms[0], &keysym, &usym);\r\n}\r\nelse\r\nkeysym = syms[0];\r\n}\r\nelse if (!(bitmask & LockMask) || !lockmod_is_capslock) {\r\nint lsym, usym = 0;\r\nif (keysyms_per_keycode == 1\r\n|| (keysyms_per_keycode > 1 && (usym = syms[1]) == NoSymbol))\r\nXConvertCase(syms[0], &lsym, &usym);\r\nkeysym = usym;\r\n}\r\nelse {\r\nint lsym, usym = 0;\r\nif (keysyms_per_keycode == 1\r\n|| (keysyms_per_keycode > 1 && syms[1] == NoSymbol))\r\nkeysym = syms[0];\r\nXConvertCase(keysym, &lsym, &usym);\r\nif (!(bitmask & ShiftMask) && keysym != syms[0]\r\n&& ((keysym != usym) || (lsym == usym)))\r\nXConvertCase(syms[0], &lsym, &usym);\r\nkeysym = usym;\r\n}\r\nif (keysym == XK_VoidSymbol)\r\nkeysym = NoSymbol;\r\nreturn wmem_strdup_printf(wmem_packet_scope(), "%d, \"%s\"", keysym, keysymString(keysym));\r\n#endif\r\n}\r\nstatic const char *keysymString(guint32 v)\r\n{\r\n#if 0\r\nstatic GTree *keysymTable = NULL;\r\ngpointer res;\r\nif (!keysymTable) {\r\nconst value_string *p = x11_keysym_vals_source;\r\nkeysymTable = g_tree_new(compareGuint32);\r\nfor(; p -> strptr; p++)\r\ng_tree_insert(keysymTable, GINT_TO_POINTER(p -> value), (gpointer) (p -> strptr) );\r\n}\r\nres = g_tree_lookup(keysymTable, GINT_TO_POINTER(v));\r\nreturn res ? res : "<Unknown>";\r\n#endif\r\nreturn val_to_str_ext_const(v, &x11_keysym_vals_source_ext, "<Unknown>");\r\n}\r\nstatic void listOfKeycode(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint *modifiermap[], int keycodes_per_modifier,\r\nguint byte_order _U_)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp,\r\n(int)array_length(modifiers) * keycodes_per_modifier, ENC_NA);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_keycode);\r\nsize_t m;\r\nfor (m = 0; m < array_length(modifiers);\r\n++m, *offsetp += keycodes_per_modifier) {\r\nconst guint8 *p;\r\nproto_item *tikc;\r\nint i;\r\np = tvb_get_ptr(tvb, *offsetp, keycodes_per_modifier);\r\nmodifiermap[m] = (int *)\r\ng_malloc(sizeof(*modifiermap[m]) * keycodes_per_modifier);\r\ntikc = proto_tree_add_bytes_format(tt, hf_x11_keycodes_item, tvb,\r\n*offsetp, keycodes_per_modifier, p, "item: ");\r\nfor(i = 0; i < keycodes_per_modifier; ++i) {\r\nguchar c = p[i];\r\nif (c)\r\nproto_item_append_text(tikc, " %s=%d", modifiers[m], c);\r\nmodifiermap[m][i] = c;\r\n}\r\n}\r\n}\r\nstatic void listOfKeysyms(tvbuff_t *tvb, packet_info *pinfo, int *offsetp, proto_tree *t, int hf,\r\nint hf_item, int *keycodemap[256],\r\nint keycode_first, int keycode_count,\r\nint keysyms_per_keycode, guint byte_order)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp, keycode_count * keysyms_per_keycode * 4, byte_order);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_keysyms);\r\nproto_item *tti;\r\nproto_tree *ttt;\r\nint i, keycode;\r\nDISSECTOR_ASSERT(keycode_first >= 0);\r\nDISSECTOR_ASSERT(keycode_count >= 0);\r\nfor (keycode = keycode_first; keycode_count > 0;\r\n++keycode, --keycode_count) {\r\ntti = proto_tree_add_none_format(tt, hf_item, tvb, *offsetp,\r\n4 * keysyms_per_keycode, "keysyms (keycode %d):", keycode);\r\nif (keycode >= 256) {\r\nexpert_add_info_format(pinfo, tti, &ei_x11_keycode_value_out_of_range,\r\n"keycode value %d is out of range", keycode);\r\n*offsetp += 4 * keysyms_per_keycode;\r\ncontinue;\r\n}\r\nttt = proto_item_add_subtree(tti, ett_x11_keysym);\r\ntvb_ensure_bytes_exist(tvb, *offsetp, 4 * keysyms_per_keycode);\r\nkeycodemap[keycode]\r\n= (int *)g_malloc(sizeof(*keycodemap[keycode]) * keysyms_per_keycode);\r\nfor(i = 0; i < keysyms_per_keycode; ++i) {\r\nguint32 v = VALUE32(tvb, *offsetp);\r\nproto_item_append_text(tti, " %s", keysymString(v));\r\nproto_tree_add_uint_format(ttt, hf_x11_keysyms_item_keysym,\r\ntvb, *offsetp, 4, v,\r\n"keysym (keycode %d): 0x%08x (%s)",\r\nkeycode, v, keysymString(v));\r\nkeycodemap[keycode][i] = v;\r\n*offsetp += 4;\r\n}\r\nfor (i = 1; i < keysyms_per_keycode; ++i)\r\nif (keycodemap[keycode][i] != NoSymbol)\r\nbreak;\r\nif (i == keysyms_per_keycode) {\r\nif (keysyms_per_keycode == 4) {\r\nkeycodemap[keycode][1] = NoSymbol;\r\nkeycodemap[keycode][2] = keycodemap[keycode][0];\r\nkeycodemap[keycode][3] = NoSymbol;\r\n}\r\ncontinue;\r\n}\r\nfor (i = 2; i < keysyms_per_keycode; ++i)\r\nif (keycodemap[keycode][i] != NoSymbol)\r\nbreak;\r\nif (i == keysyms_per_keycode) {\r\nif (keysyms_per_keycode == 4) {\r\nkeycodemap[keycode][2] = keycodemap[keycode][0];\r\nkeycodemap[keycode][3] = keycodemap[keycode][1];\r\n}\r\ncontinue;\r\n}\r\n}\r\n}\r\nstatic void listOfPoint(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint length, guint byte_order)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp, length * 4, byte_order);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_point);\r\nwhile(length--) {\r\ngint16 x, y;\r\nproto_item *tti;\r\nproto_tree *ttt;\r\nx = VALUE16(tvb, *offsetp);\r\ny = VALUE16(tvb, *offsetp + 2);\r\ntti = proto_tree_add_none_format(tt, hf_x11_point, tvb, *offsetp, 4, "point: (%d,%d)", x, y);\r\nttt = proto_item_add_subtree(tti, ett_x11_point);\r\nproto_tree_add_int(ttt, hf_x11_point_x, tvb, *offsetp, 2, x);\r\n*offsetp += 2;\r\nproto_tree_add_int(ttt, hf_x11_point_y, tvb, *offsetp, 2, y);\r\n*offsetp += 2;\r\n}\r\n}\r\nstatic void listOfRectangle(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint length, guint byte_order)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp, length * 8, byte_order);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_rectangle);\r\nwhile(length--) {\r\ngint16 x, y;\r\nguint width, height;\r\nproto_item *tti;\r\nproto_tree *ttt;\r\nx = VALUE16(tvb, *offsetp);\r\ny = VALUE16(tvb, *offsetp + 2);\r\nwidth = VALUE16(tvb, *offsetp + 4);\r\nheight = VALUE16(tvb, *offsetp + 6);\r\ntti = proto_tree_add_none_format(tt, hf_x11_rectangle, tvb, *offsetp, 8,\r\n"rectangle: %dx%d+%d+%d", width, height, x, y);\r\nttt = proto_item_add_subtree(tti, ett_x11_rectangle);\r\nproto_tree_add_int(ttt, hf_x11_rectangle_x, tvb, *offsetp, 2, x);\r\n*offsetp += 2;\r\nproto_tree_add_int(ttt, hf_x11_rectangle_y, tvb, *offsetp, 2, y);\r\n*offsetp += 2;\r\nproto_tree_add_uint(ttt, hf_x11_rectangle_width, tvb, *offsetp, 2, width);\r\n*offsetp += 2;\r\nproto_tree_add_uint(ttt, hf_x11_rectangle_height, tvb, *offsetp, 2, height);\r\n*offsetp += 2;\r\n}\r\n}\r\nstatic void listOfSegment(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint length, guint byte_order)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp, length * 8, byte_order);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_segment);\r\nwhile(length--) {\r\ngint16 x1, y1, x2, y2;\r\nproto_item *tti;\r\nproto_tree *ttt;\r\nx1 = VALUE16(tvb, *offsetp);\r\ny1 = VALUE16(tvb, *offsetp + 2);\r\nx2 = VALUE16(tvb, *offsetp + 4);\r\ny2 = VALUE16(tvb, *offsetp + 6);\r\ntti = proto_tree_add_none_format(tt, hf_x11_segment, tvb, *offsetp, 8,\r\n"segment: (%d,%d)-(%d,%d)", x1, y1, x2, y2);\r\nttt = proto_item_add_subtree(tti, ett_x11_segment);\r\nproto_tree_add_item(ttt, hf_x11_segment_x1, tvb, *offsetp, 2, byte_order);\r\n*offsetp += 2;\r\nproto_tree_add_item(ttt, hf_x11_segment_y1, tvb, *offsetp, 2, byte_order);\r\n*offsetp += 2;\r\nproto_tree_add_item(ttt, hf_x11_segment_x2, tvb, *offsetp, 2, byte_order);\r\n*offsetp += 2;\r\nproto_tree_add_item(ttt, hf_x11_segment_y2, tvb, *offsetp, 2, byte_order);\r\n*offsetp += 2;\r\n}\r\n}\r\nstatic void listOfVisualTypes(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint length, guint byte_order)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp, length * 24, byte_order);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_visualtype);\r\nwhile(length--) {\r\nproto_item *tti;\r\nproto_tree *ttt;\r\ntti = proto_tree_add_none_format(tt, hf_x11_visualtype, tvb, *offsetp, 24,\r\n"visualtype");\r\nttt = proto_item_add_subtree(tti, ett_x11_visualtype);\r\nproto_tree_add_item(ttt, hf_x11_visualtype_visualid, tvb, *offsetp, 4, byte_order);\r\n*offsetp += 4;\r\nproto_tree_add_item(ttt, hf_x11_visualtype_class, tvb, *offsetp, 1, byte_order);\r\n*offsetp += 1;\r\nproto_tree_add_item(ttt, hf_x11_visualtype_bits_per_rgb_value, tvb, *offsetp, 1, byte_order);\r\n*offsetp += 1;\r\nproto_tree_add_item(ttt, hf_x11_visualtype_colormap_entries, tvb, *offsetp, 2, byte_order);\r\n*offsetp += 2;\r\nproto_tree_add_item(ttt, hf_x11_visualtype_red_mask, tvb, *offsetp, 4, byte_order);\r\n*offsetp += 4;\r\nproto_tree_add_item(ttt, hf_x11_visualtype_green_mask, tvb, *offsetp, 4, byte_order);\r\n*offsetp += 4;\r\nproto_tree_add_item(ttt, hf_x11_visualtype_blue_mask, tvb, *offsetp, 4, byte_order);\r\n*offsetp += 4;\r\nproto_tree_add_item(ttt, hf_x11_unused, tvb, *offsetp, 4, byte_order);\r\n*offsetp += 4;\r\n}\r\n}\r\nstatic void listOfDepth(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint length, guint byte_order)\r\n{\r\nguint8 number_of_visualtypes;\r\nproto_item *ti;\r\nproto_tree *tt;\r\nti = proto_tree_add_item(t, hf, tvb, *offsetp, -1, byte_order);\r\ntt = proto_item_add_subtree(ti, ett_x11_list_of_depth_detail);\r\nwhile(length--) {\r\nproto_item *tti;\r\nproto_tree *ttt;\r\nnumber_of_visualtypes = VALUE16(tvb, *offsetp + 2);\r\ntti = proto_tree_add_none_format(tt, hf_x11_depth_detail, tvb, *offsetp, 8 + 24 * number_of_visualtypes,\r\n"depth-detail");\r\nttt = proto_item_add_subtree(tti, ett_x11_screen);\r\nproto_tree_add_item(ttt, hf_x11_depth_detail_depth, tvb, *offsetp, 1, byte_order);\r\n*offsetp += 1;\r\nproto_tree_add_item(ttt, hf_x11_unused, tvb, *offsetp, 1, byte_order);\r\n*offsetp += 1;\r\nproto_tree_add_item(ttt, hf_x11_depth_detail_visualtypes_numbers, tvb, *offsetp, 2, byte_order);\r\n*offsetp += 2;\r\nproto_tree_add_item(ttt, hf_x11_unused, tvb, *offsetp, 4, byte_order);\r\n*offsetp += 4;\r\nif (number_of_visualtypes > 0)\r\nlistOfVisualTypes(tvb, offsetp, ttt, hf_x11_visualtype, number_of_visualtypes, byte_order);\r\n}\r\n}\r\nstatic void listOfScreen(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint length, guint byte_order)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp, -1, byte_order);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_screen);\r\nwhile(length--) {\r\nguint8 number_of_depths, root_depth;\r\nguint16 width_in_pixels, height_in_pixels;\r\nguint32 screen_root;\r\nproto_item *tti;\r\nproto_tree *ttt;\r\nscreen_root = VALUE32(tvb, *offsetp);\r\nwidth_in_pixels = VALUE16(tvb, *offsetp + 20);\r\nheight_in_pixels = VALUE16(tvb, *offsetp + 22);\r\nroot_depth = VALUE8(tvb, *offsetp + 38);\r\ntti = proto_tree_add_none_format(tt, hf_x11_screen, tvb, *offsetp, 0,\r\n"screen (%08x: %d x %d x %d)", screen_root,\r\nwidth_in_pixels, height_in_pixels, root_depth);\r\nttt = proto_item_add_subtree(tti, ett_x11_screen);\r\nproto_tree_add_item(ttt, hf_x11_screen_root, tvb, *offsetp, 4, byte_order);\r\n*offsetp += 4;\r\nproto_tree_add_item(ttt, hf_x11_screen_default_colormap, tvb, *offsetp, 4, byte_order);\r\n*offsetp += 4;\r\nproto_tree_add_item(ttt, hf_x11_screen_white_pixel, tvb, *offsetp, 4, byte_order);\r\n*offsetp += 4;\r\nproto_tree_add_item(ttt, hf_x11_screen_black_pixel, tvb, *offsetp, 4, byte_order);\r\n*offsetp += 4;\r\nproto_tree_add_item(ttt, hf_x11_screen_current_input_masks, tvb, *offsetp, 4, byte_order);\r\n*offsetp += 4;\r\nproto_tree_add_item(ttt, hf_x11_screen_width_in_pixels, tvb, *offsetp, 2, byte_order);\r\n*offsetp += 2;\r\nproto_tree_add_item(ttt, hf_x11_screen_height_in_pixels, tvb, *offsetp, 2, byte_order);\r\n*offsetp += 2;\r\nproto_tree_add_item(ttt, hf_x11_screen_width_in_millimeters, tvb, *offsetp, 2, byte_order);\r\n*offsetp += 2;\r\nproto_tree_add_item(ttt, hf_x11_screen_height_in_millimeters, tvb, *offsetp, 2, byte_order);\r\n*offsetp += 2;\r\nproto_tree_add_item(ttt, hf_x11_screen_min_installed_maps, tvb, *offsetp, 2, byte_order);\r\n*offsetp += 2;\r\nproto_tree_add_item(ttt, hf_x11_screen_max_installed_maps, tvb, *offsetp, 2, byte_order);\r\n*offsetp += 2;\r\nproto_tree_add_item(ttt, hf_x11_screen_root_visual, tvb, *offsetp, 4, byte_order);\r\n*offsetp += 4;\r\nproto_tree_add_item(ttt, hf_x11_screen_backing_stores, tvb, *offsetp, 1, byte_order);\r\n*offsetp += 1;\r\nproto_tree_add_item(ttt, hf_x11_screen_save_unders, tvb, *offsetp, 1, byte_order);\r\n*offsetp += 1;\r\nproto_tree_add_item(ttt, hf_x11_screen_root_depth, tvb, *offsetp, 1, byte_order);\r\n*offsetp += 1;\r\nnumber_of_depths = VALUE8(tvb, *offsetp);\r\nproto_tree_add_item(ttt, hf_x11_screen_allowed_depths_len, tvb, *offsetp, 1, byte_order);\r\n*offsetp += 1;\r\nlistOfDepth(tvb, offsetp, ttt, hf_x11_depth_detail, number_of_depths, byte_order);\r\n}\r\n}\r\nstatic void listOfPixmapFormat(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint length, guint byte_order)\r\n{\r\nproto_item *ti = proto_tree_add_item(t, hf, tvb, *offsetp, length * 8, byte_order);\r\nproto_tree *tt = proto_item_add_subtree(ti, ett_x11_list_of_pixmap_format);\r\nwhile(length--) {\r\nproto_item *tti;\r\nproto_tree *ttt;\r\ntti = proto_tree_add_none_format(tt, hf_x11_pixmap_format, tvb, *offsetp, 8,\r\n"pixmap-format");\r\nttt = proto_item_add_subtree(tti, ett_x11_pixmap_format);\r\nproto_tree_add_item(ttt, hf_x11_pixmap_format_depth, tvb, *offsetp, 1, byte_order);\r\n*offsetp += 1;\r\nproto_tree_add_item(ttt, hf_x11_pixmap_format_bits_per_pixel, tvb, *offsetp, 1, byte_order);\r\n*offsetp += 1;\r\nproto_tree_add_item(ttt, hf_x11_pixmap_format_scanline_pad, tvb, *offsetp, 1, byte_order);\r\n*offsetp += 1;\r\nproto_tree_add_item(ttt, hf_x11_unused, tvb, *offsetp, 5, byte_order);\r\n*offsetp += 5;\r\n}\r\n}\r\nstatic void listOfString8(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint hf_item, int length, guint byte_order)\r\n{\r\nchar *s = NULL;\r\nproto_item *ti;\r\nproto_tree *tt;\r\nint i;\r\nint scanning_offset = *offsetp;\r\nfor(i = length; i; i--) {\r\nint l;\r\nl = tvb_get_guint8(tvb, scanning_offset);\r\nscanning_offset += 1 + l;\r\n}\r\nti = proto_tree_add_item(t, hf, tvb, *offsetp, scanning_offset - *offsetp, byte_order);\r\ntt = proto_item_add_subtree(ti, ett_x11_list_of_string8);\r\nwhile(length--) {\r\nguint l = VALUE8(tvb, *offsetp);\r\ns = tvb_get_string_enc(wmem_packet_scope(), tvb, *offsetp + 1, l, ENC_ASCII);\r\nproto_tree_add_string_format(tt, hf_item, tvb, *offsetp, l + 1, s, "\"%s\"", s);\r\n*offsetp += l + 1;\r\n}\r\n}\r\nstatic int stringIsActuallyAn8BitString(tvbuff_t *tvb, int offset, guint length)\r\n{\r\nfor(; length > 0; offset += 2, length--) {\r\nif (tvb_get_guint8(tvb, offset))\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic char *tvb_get_ascii_string16(tvbuff_t *tvb, int offset, guint length)\r\n{\r\nwmem_strbuf_t *str;\r\nguint8 ch;\r\nstr = wmem_strbuf_sized_new(wmem_packet_scope(), length + 1, 0);\r\nwhile(length--) {\r\noffset++;\r\nch = tvb_get_guint8(tvb, offset);\r\nif (ch < 0x80)\r\nwmem_strbuf_append_c(str, ch);\r\nelse\r\nwmem_strbuf_append_unichar(str, UNREPL);\r\noffset++;\r\n}\r\nreturn wmem_strbuf_finalize(str);\r\n}\r\nstatic void listOfTextItem(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint sizeIs16, int next_offset, guint byte_order)\r\n{\r\nchar *s = NULL;\r\nproto_item *ti;\r\nproto_tree *tt;\r\nguint32 fid;\r\nint scanning_offset = *offsetp;\r\nint n = 0;\r\nwhile(scanning_offset < next_offset) {\r\nint l;\r\nl = tvb_get_guint8(tvb, scanning_offset);\r\nscanning_offset++;\r\nif (!l) break;\r\nn++;\r\nscanning_offset += l == 255 ? 4 : l + (sizeIs16 ? l : 0) + 1;\r\n}\r\nti = proto_tree_add_item(t, hf, tvb, *offsetp, scanning_offset - *offsetp, byte_order);\r\ntt = proto_item_add_subtree(ti, ett_x11_list_of_text_item);\r\nwhile(n--) {\r\nguint l = VALUE8(tvb, *offsetp);\r\nif (l == 255) {\r\nfid = tvb_get_ntohl(tvb, *offsetp + 1);\r\nproto_tree_add_uint(tt, hf_x11_textitem_font, tvb, *offsetp, 5, fid);\r\n*offsetp += 5;\r\n} else {\r\nproto_item *tti;\r\nproto_tree *ttt;\r\ngint8 delta = VALUE8(tvb, *offsetp + 1);\r\nif (sizeIs16) {\r\nif (stringIsActuallyAn8BitString(tvb, *offsetp + 2, l)) {\r\ns = tvb_get_ascii_string16(tvb, *offsetp + 2, l);\r\ntti = proto_tree_add_none_format(tt, hf_x11_textitem_string, tvb, *offsetp, l*2 + 2,\r\n"textitem (string): delta = %d, \"%s\"",\r\ndelta, s);\r\nttt = proto_item_add_subtree(tti, ett_x11_text_item);\r\nproto_tree_add_item(ttt, hf_x11_textitem_string_delta, tvb, *offsetp + 1, 1, byte_order);\r\nproto_tree_add_string_format_value(ttt, hf_x11_textitem_string_string16, tvb,\r\n*offsetp + 2, l, s, "\"%s\"", s);\r\n} else {\r\ntti = proto_tree_add_none_format(tt, hf_x11_textitem_string, tvb, *offsetp, l*2 + 2,\r\n"textitem (string): delta = %d, %s",\r\ndelta,\r\ntvb_bytes_to_str(wmem_packet_scope(), tvb, *offsetp + 2, l*2));\r\nttt = proto_item_add_subtree(tti, ett_x11_text_item);\r\nproto_tree_add_item(ttt, hf_x11_textitem_string_delta, tvb, *offsetp + 1, 1, byte_order);\r\nproto_tree_add_item(ttt, hf_x11_textitem_string_string16_bytes, tvb, *offsetp + 2, l*2, byte_order);\r\n}\r\n*offsetp += l*2 + 2;\r\n} else {\r\ns = tvb_get_string_enc(wmem_packet_scope(), tvb, *offsetp + 2, l, ENC_ASCII);\r\ntti = proto_tree_add_none_format(tt, hf_x11_textitem_string, tvb, *offsetp, l + 2,\r\n"textitem (string): delta = %d, \"%s\"",\r\ndelta, s);\r\nttt = proto_item_add_subtree(tti, ett_x11_text_item);\r\nproto_tree_add_item(ttt, hf_x11_textitem_string_delta, tvb, *offsetp + 1, 1, byte_order);\r\nproto_tree_add_string_format(ttt, hf_x11_textitem_string_string8, tvb,\r\n*offsetp + 2, l, s, "\"%s\"", s);\r\n*offsetp += l + 2;\r\n}\r\n}\r\n}\r\n}\r\nstatic guint32 field8(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nguint byte_order)\r\n{\r\nguint32 v = VALUE8(tvb, *offsetp);\r\nheader_field_info *hfi = proto_registrar_get_nth(hf);\r\nconst gchar *enumValue = NULL;\r\nif (hfi -> strings)\r\nenumValue = try_val_to_str(v, cVALS(hfi -> strings));\r\nif (enumValue)\r\nproto_tree_add_uint_format(t, hf, tvb, *offsetp, 1, v,\r\nhfi -> display == BASE_DEC ? "%s: %u (%s)" : "%s: 0x%02x (%s)",\r\nhfi -> name, v, enumValue);\r\nelse\r\nproto_tree_add_item(t, hf, tvb, *offsetp, 1, byte_order);\r\n*offsetp += 1;\r\nreturn v;\r\n}\r\nstatic guint32 field16(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nguint byte_order)\r\n{\r\nguint32 v = VALUE16(tvb, *offsetp);\r\nheader_field_info *hfi = proto_registrar_get_nth(hf);\r\nconst gchar *enumValue = NULL;\r\nif (hfi -> strings)\r\nenumValue = try_val_to_str(v, cVALS(hfi -> strings));\r\nif (enumValue)\r\nproto_tree_add_uint_format(t, hf, tvb, *offsetp, 2, v,\r\nhfi -> display == BASE_DEC ? "%s: %u (%s)" : "%s: 0x%02x (%s)",\r\nhfi -> name, v, enumValue);\r\nelse\r\nproto_tree_add_item(t, hf, tvb, *offsetp, 2, byte_order);\r\n*offsetp += 2;\r\nreturn v;\r\n}\r\nstatic guint32 field32(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nguint byte_order)\r\n{\r\nguint32 v = VALUE32(tvb, *offsetp);\r\nheader_field_info *hfi = proto_registrar_get_nth(hf);\r\nconst gchar *enumValue = NULL;\r\nconst gchar *nameAsChar = hfi -> name;\r\nif (hfi -> strings)\r\nenumValue = try_val_to_str(v, cVALS(hfi -> strings));\r\nif (enumValue)\r\nproto_tree_add_uint_format(t, hf, tvb, *offsetp, 4, v,\r\nhfi -> display == BASE_DEC ? "%s: %u (%s)" : "%s: 0x%08x (%s)",\r\nnameAsChar, v, enumValue);\r\nelse\r\nproto_tree_add_uint_format(t, hf, tvb, *offsetp, 4, v,\r\nhfi -> display == BASE_DEC ? "%s: %u" : "%s: 0x%08x",\r\nnameAsChar, v);\r\n*offsetp += 4;\r\nreturn v;\r\n}\r\nstatic void gcAttributes(tvbuff_t *tvb, int *offsetp, proto_tree *t,\r\nguint byte_order)\r\n{\r\nBITMASK32(gc_value);\r\nBITFIELD(ENUM8, gc_value_mask, function);\r\nBITFIELD(CARD32, gc_value_mask, plane_mask);\r\nBITFIELD(CARD32, gc_value_mask, foreground);\r\nBITFIELD(CARD32, gc_value_mask, background);\r\nBITFIELD(CARD16, gc_value_mask, line_width);\r\nBITFIELD(ENUM8, gc_value_mask, line_style);\r\nBITFIELD(ENUM8, gc_value_mask, cap_style);\r\nBITFIELD(ENUM8, gc_value_mask, join_style);\r\nBITFIELD(ENUM8, gc_value_mask, fill_style);\r\nBITFIELD(ENUM8, gc_value_mask, fill_rule);\r\nBITFIELD(PIXMAP, gc_value_mask, tile);\r\nBITFIELD(PIXMAP, gc_value_mask, stipple);\r\nBITFIELD(INT16, gc_value_mask, tile_stipple_x_origin);\r\nBITFIELD(INT16, gc_value_mask, tile_stipple_y_origin);\r\nBITFIELD(FONT, gc_value_mask, font);\r\nBITFIELD(ENUM8, gc_value_mask, subwindow_mode);\r\nBITFIELD(BOOL, gc_value_mask, graphics_exposures);\r\nBITFIELD(INT16, gc_value_mask, clip_x_origin);\r\nBITFIELD(INT16, gc_value_mask, clip_y_origin);\r\nBITFIELD(PIXMAP, gc_value_mask, clip_mask);\r\nBITFIELD(CARD16, gc_value_mask, dash_offset);\r\nBITFIELD(CARD8, gc_value_mask, gc_dashes);\r\nBITFIELD(ENUM8, gc_value_mask, arc_mode);\r\nENDBITMASK;\r\n}\r\nstatic void gcMask(tvbuff_t *tvb, int *offsetp, proto_tree *t,\r\nguint byte_order)\r\n{\r\nBITMASK32(gc_value);\r\nFLAG(gc_value, function);\r\nFLAG(gc_value, plane_mask);\r\nFLAG(gc_value, foreground);\r\nFLAG(gc_value, background);\r\nFLAG(gc_value, line_width);\r\nFLAG(gc_value, line_style);\r\nFLAG(gc_value, cap_style);\r\nFLAG(gc_value, join_style);\r\nFLAG(gc_value, fill_style);\r\nFLAG(gc_value, fill_rule);\r\nFLAG(gc_value, tile);\r\nFLAG(gc_value, stipple);\r\nFLAG(gc_value, tile_stipple_x_origin);\r\nFLAG(gc_value, tile_stipple_y_origin);\r\nFLAG(gc_value, font);\r\nFLAG(gc_value, subwindow_mode);\r\nFLAG(gc_value, graphics_exposures);\r\nFLAG(gc_value, clip_x_origin);\r\nFLAG(gc_value, clip_y_origin);\r\nFLAG(gc_value, clip_mask);\r\nFLAG(gc_value, dash_offset);\r\nFLAG(gc_value, gc_dashes);\r\nFLAG(gc_value, arc_mode);\r\nENDBITMASK;\r\n}\r\nstatic guint32 requestLength(tvbuff_t *tvb, int *offsetp, proto_tree *t,\r\nguint byte_order)\r\n{\r\nguint32 res = VALUE16(tvb, *offsetp);\r\nproto_tree_add_uint(t, hf_x11_request_length, tvb, *offsetp, 2, res);\r\n*offsetp += 2;\r\nreturn res * 4;\r\n}\r\nstatic void setOfEvent(tvbuff_t *tvb, int *offsetp, proto_tree *t,\r\nguint byte_order)\r\n{\r\nBITMASK32(event);\r\nFLAG(event, KeyPress);\r\nFLAG(event, KeyRelease);\r\nFLAG(event, ButtonPress);\r\nFLAG(event, ButtonRelease);\r\nFLAG(event, EnterWindow);\r\nFLAG(event, LeaveWindow);\r\nFLAG(event, PointerMotion);\r\nFLAG(event, PointerMotionHint);\r\nFLAG(event, Button1Motion);\r\nFLAG(event, Button2Motion);\r\nFLAG(event, Button3Motion);\r\nFLAG(event, Button4Motion);\r\nFLAG(event, Button5Motion);\r\nFLAG(event, ButtonMotion);\r\nFLAG(event, KeymapState);\r\nFLAG(event, Exposure);\r\nFLAG(event, VisibilityChange);\r\nFLAG(event, StructureNotify);\r\nFLAG(event, ResizeRedirect);\r\nFLAG(event, SubstructureNotify);\r\nFLAG(event, SubstructureRedirect);\r\nFLAG(event, FocusChange);\r\nFLAG(event, PropertyChange);\r\nFLAG(event, ColormapChange);\r\nFLAG(event, OwnerGrabButton);\r\nFLAG_IF_NONZERO(event, erroneous_bits);\r\nENDBITMASK;\r\n}\r\nstatic void setOfDeviceEvent(tvbuff_t *tvb, int *offsetp, proto_tree *t,\r\nguint byte_order)\r\n{\r\nBITMASK32(do_not_propagate);\r\nFLAG(do_not_propagate, KeyPress);\r\nFLAG(do_not_propagate, KeyRelease);\r\nFLAG(do_not_propagate, ButtonPress);\r\nFLAG(do_not_propagate, ButtonRelease);\r\nFLAG(do_not_propagate, PointerMotion);\r\nFLAG(do_not_propagate, Button1Motion);\r\nFLAG(do_not_propagate, Button2Motion);\r\nFLAG(do_not_propagate, Button3Motion);\r\nFLAG(do_not_propagate, Button4Motion);\r\nFLAG(do_not_propagate, Button5Motion);\r\nFLAG(do_not_propagate, ButtonMotion);\r\nFLAG_IF_NONZERO(do_not_propagate, erroneous_bits);\r\nENDBITMASK;\r\n}\r\nstatic void setOfKeyButMask(tvbuff_t *tvb, int *offsetp, proto_tree *t,\r\nguint byte_order, gboolean butmask)\r\n{\r\nproto_item *ti;\r\nguint32 bitmask_value;\r\nint bitmask_offset;\r\nint bitmask_size;\r\nproto_tree *bitmask_tree;\r\nbitmask_value = VALUE16(tvb, *offsetp);\r\nbitmask_offset = *offsetp;\r\nbitmask_size = 2;\r\nif (!butmask && bitmask_value == 0x8000)\r\nproto_tree_add_uint_format(t, hf_x11_modifiers_mask_AnyModifier, tvb, *offsetp, 2, 0x8000,\r\n"modifiers-masks: 0x8000 (AnyModifier)");\r\nelse {\r\nti = proto_tree_add_uint(t, hf_x11_modifiers_mask, tvb, *offsetp, 2,\r\nbitmask_value);\r\nbitmask_tree = proto_item_add_subtree(ti, ett_x11_set_of_key_mask);\r\nFLAG(modifiers, Shift);\r\nFLAG(modifiers, Lock);\r\nFLAG(modifiers, Control);\r\nFLAG(modifiers, Mod1);\r\nFLAG(modifiers, Mod2);\r\nFLAG(modifiers, Mod3);\r\nFLAG(modifiers, Mod4);\r\nFLAG(modifiers, Mod5);\r\nif (butmask) {\r\nFLAG(modifiers, Button1);\r\nFLAG(modifiers, Button2);\r\nFLAG(modifiers, Button3);\r\nFLAG(modifiers, Button4);\r\nFLAG(modifiers, Button5);\r\n}\r\nif (butmask)\r\nFLAG_IF_NONZERO(keybut, erroneous_bits);\r\nelse\r\nFLAG_IF_NONZERO(modifiers, erroneous_bits);\r\n}\r\n*offsetp += 2;\r\n}\r\nstatic void setOfPointerEvent(tvbuff_t *tvb, int *offsetp, proto_tree *t,\r\nguint byte_order)\r\n{\r\nBITMASK16(pointer_event);\r\nFLAG(pointer_event, ButtonPress);\r\nFLAG(pointer_event, ButtonRelease);\r\nFLAG(pointer_event, EnterWindow);\r\nFLAG(pointer_event, LeaveWindow);\r\nFLAG(pointer_event, PointerMotion);\r\nFLAG(pointer_event, PointerMotionHint);\r\nFLAG(pointer_event, Button1Motion);\r\nFLAG(pointer_event, Button2Motion);\r\nFLAG(pointer_event, Button3Motion);\r\nFLAG(pointer_event, Button4Motion);\r\nFLAG(pointer_event, Button5Motion);\r\nFLAG(pointer_event, ButtonMotion);\r\nFLAG(pointer_event, KeymapState);\r\nFLAG_IF_NONZERO(pointer_event, erroneous_bits);\r\nENDBITMASK;\r\n}\r\nstatic void string8(tvbuff_t *tvb, int *offsetp, proto_tree *t,\r\nint hf, guint length)\r\n{\r\nproto_tree_add_item(t, hf, tvb, *offsetp, length, ENC_NA|ENC_ASCII);\r\n*offsetp += length;\r\n}\r\nstatic void string16(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nint hf_bytes, guint length, guint byte_order)\r\n{\r\nguint l = length*2;\r\nchar *s;\r\nif (stringIsActuallyAn8BitString(tvb, *offsetp, length)) {\r\ns = tvb_get_ascii_string16(tvb, *offsetp, length);\r\nproto_tree_add_string_format_value(t, hf, tvb, *offsetp, l, s, "\"%s\"", s);\r\n} else\r\nproto_tree_add_item(t, hf_bytes, tvb, *offsetp, l, byte_order);\r\n*offsetp += l;\r\n}\r\nstatic void timestamp(tvbuff_t *tvb, int *offsetp, proto_tree *t, int hf,\r\nguint byte_order)\r\n{\r\nguint32 v = VALUE32(tvb, *offsetp);\r\nif (!v)\r\nproto_tree_add_uint_format(t, hf, tvb, *offsetp, 4, 0, "%s: 0 (CurrentTime)",\r\nproto_registrar_get_nth(hf) -> name);\r\nelse\r\nproto_tree_add_uint(t, hf, tvb, *offsetp, 4, v);\r\n*offsetp += 4;\r\n}\r\nstatic void windowAttributes(tvbuff_t *tvb, int *offsetp, proto_tree *t,\r\nguint byte_order)\r\n{\r\nBITMASK32(window_value);\r\nBITFIELD(PIXMAP, window_value_mask, background_pixmap);\r\nBITFIELD(CARD32, window_value_mask, background_pixel);\r\nBITFIELD(PIXMAP, window_value_mask, border_pixmap);\r\nBITFIELD(CARD32, window_value_mask, border_pixel);\r\nBITFIELD(BITGRAVITY, window_value_mask, bit_gravity);\r\nBITFIELD(WINGRAVITY, window_value_mask, win_gravity);\r\nBITFIELD(ENUM8, window_value_mask, backing_store);\r\nBITFIELD(CARD32, window_value_mask, backing_planes);\r\nBITFIELD(CARD32, window_value_mask, backing_pixel);\r\nBITFIELD(BOOL, window_value_mask, override_redirect);\r\nBITFIELD(BOOL, window_value_mask, save_under);\r\nBITFIELD(SETofEVENT, window_value_mask, event_mask);\r\nBITFIELD(SETofDEVICEEVENT, window_value_mask, do_not_propagate_mask);\r\nBITFIELD(COLORMAP, window_value_mask, colormap);\r\nBITFIELD(CURSOR, window_value_mask, cursor);\r\nENDBITMASK;\r\n}\r\nstatic void x11_cleanup(void)\r\n{\r\nx11_conv_data_t *state;\r\nfor (state = x11_conv_data_list; state != NULL; ) {\r\nx11_conv_data_t *last;\r\ng_hash_table_destroy(state->eventcode_funcs);\r\ng_hash_table_destroy(state->reply_funcs);\r\ng_hash_table_destroy(state->seqtable);\r\ng_hash_table_destroy(state->valtable);\r\nlast = state;\r\nstate = state->next;\r\ng_free(last);\r\n}\r\nx11_conv_data_list = NULL;\r\n}\r\nstatic int numberOfBitSet(tvbuff_t *tvb, int offset, int maskLength)\r\n{\r\nint res = 0;\r\nwhile(maskLength--) {\r\nint c = tvb_get_guint8(tvb, offset);\r\noffset++;\r\nres += numberOfBitSetTable[c & 0xf] + numberOfBitSetTable[c >> 4];\r\n}\r\nreturn res;\r\n}\r\nstatic int listOfStringLengthConsistent(tvbuff_t *tvb, int offset, int length, int listLength)\r\n{\r\nif (listLength > length) return FALSE;\r\nwhile(listLength--) {\r\nint l;\r\nif (!tvb_bytes_exist(tvb, offset, 1)) return TRUE;\r\nl = tvb_get_guint8(tvb, offset);\r\nif (!l) break;\r\nl++;\r\nif (l > length) return FALSE;\r\nif (!tvb_bytes_exist(tvb, offset, l)) return TRUE;\r\noffset += l;\r\nlength -= l;\r\n}\r\nif (length > 3) return FALSE;\r\nreturn TRUE;\r\n}\r\nstatic int rounded4(int n)\r\n{\r\nint remainder = n % 4;\r\nint res = n / 4;\r\nif (remainder) res++;\r\nreturn res;\r\n}\r\nstatic gboolean consistentWithOrder(int length, tvbuff_t *tvb, int offset, guint16 (*v16)(tvbuff_t *, const gint))\r\n{\r\nswitch(tvb_get_guint8(tvb, offset)) {\r\ncase X_CreateWindow:\r\nreturn !tvb_bytes_exist(tvb, offset, 32) || length == 8 + numberOfBitSet(tvb, offset + 7 * 4, 4);\r\ncase X_ChangeWindowAttributes:\r\ncase X_ChangeGC:\r\nreturn !tvb_bytes_exist(tvb, offset, 12) || length == 3 + numberOfBitSet(tvb, offset + 8, 4);\r\ncase X_GetWindowAttributes:\r\ncase X_DestroyWindow:\r\ncase X_DestroySubwindows:\r\ncase X_ChangeSaveSet:\r\ncase X_MapWindow:\r\ncase X_MapSubwindows:\r\ncase X_UnmapWindow:\r\ncase X_UnmapSubwindows:\r\ncase X_CirculateWindow:\r\ncase X_GetGeometry:\r\ncase X_QueryTree:\r\ncase X_GetAtomName:\r\ncase X_ListProperties:\r\ncase X_GetSelectionOwner:\r\ncase X_UngrabPointer:\r\ncase X_UngrabKeyboard:\r\ncase X_AllowEvents:\r\ncase X_QueryPointer:\r\ncase X_CloseFont:\r\ncase X_QueryFont:\r\ncase X_FreePixmap:\r\ncase X_FreeGC:\r\ncase X_FreeColormap:\r\ncase X_InstallColormap:\r\ncase X_UninstallColormap:\r\ncase X_ListInstalledColormaps:\r\ncase X_FreeCursor:\r\ncase X_GetKeyboardMapping:\r\ncase X_KillClient:\r\nreturn length == 2;\r\ncase X_ReparentWindow:\r\ncase X_SetSelectionOwner:\r\ncase X_ChangeActivePointerGrab:\r\ncase X_GrabKeyboard:\r\ncase X_GrabKey:\r\ncase X_GetMotionEvents:\r\ncase X_TranslateCoords:\r\ncase X_CreatePixmap:\r\ncase X_CopyGC:\r\ncase X_ClearArea:\r\ncase X_CreateColormap:\r\ncase X_AllocColor:\r\ncase X_AllocColorPlanes:\r\nreturn length == 4;\r\ncase X_ConfigureWindow:\r\nreturn !tvb_bytes_exist(tvb, offset, 10) || length == 3 + numberOfBitSet(tvb, offset + 8, 2);\r\ncase X_InternAtom:\r\ncase X_QueryExtension:\r\nreturn !tvb_bytes_exist(tvb, offset, 6) || length == 2 + rounded4(v16(tvb, offset + 4));\r\ncase X_ChangeProperty:\r\n{\r\nint multiplier, type;\r\nif (!tvb_bytes_exist(tvb, offset, 17)) return TRUE;\r\ntype = tvb_get_guint8(tvb, 16);\r\nif (type != 8 && type != 16 && type != 32) return FALSE;\r\nmultiplier = type == 8 ? 1 : type == 16 ? 2 : 4;\r\nif (!tvb_bytes_exist(tvb, offset, 24)) return TRUE;\r\nreturn length == 6 + rounded4((v16 == tvb_get_letohs ? tvb_get_letohl : tvb_get_ntohl)(tvb, offset + 20) * multiplier);\r\n}\r\ncase X_DeleteProperty:\r\ncase X_UngrabButton:\r\ncase X_UngrabKey:\r\ncase X_SetInputFocus:\r\ncase X_CopyColormapAndFree:\r\ncase X_AllocColorCells:\r\ncase X_QueryBestSize:\r\ncase X_ChangePointerControl:\r\ncase X_SetScreenSaver:\r\nreturn length == 3;\r\ncase X_GetProperty:\r\ncase X_ConvertSelection:\r\ncase X_GrabPointer:\r\ncase X_GrabButton:\r\ncase X_WarpPointer:\r\nreturn length == 6;\r\ncase X_SendEvent:\r\nreturn length == 11;\r\ncase X_GrabServer:\r\ncase X_UngrabServer:\r\ncase X_GetInputFocus:\r\ncase X_QueryKeymap:\r\ncase X_GetFontPath:\r\ncase X_ListExtensions:\r\ncase X_GetKeyboardControl:\r\ncase X_Bell:\r\ncase X_GetPointerControl:\r\ncase X_GetScreenSaver:\r\ncase X_ListHosts:\r\ncase X_SetAccessControl:\r\ncase X_SetCloseDownMode:\r\ncase X_ForceScreenSaver:\r\ncase X_GetPointerMapping:\r\ncase X_GetModifierMapping:\r\nreturn length == 1;\r\ncase X_OpenFont:\r\ncase X_AllocNamedColor:\r\ncase X_LookupColor:\r\nreturn !tvb_bytes_exist(tvb, offset, 10) || length == 3 + rounded4(v16(tvb, offset + 8));\r\ncase X_QueryTextExtents:\r\nreturn length >= 2;\r\ncase X_ListFonts:\r\ncase X_ListFontsWithInfo:\r\ncase X_ChangeHosts:\r\nreturn !tvb_bytes_exist(tvb, offset, 8) || length == 2 + rounded4(v16(tvb, offset + 6));\r\ncase X_SetFontPath:\r\nif (length < 2) return FALSE;\r\nif (!tvb_bytes_exist(tvb, offset, 8)) return TRUE;\r\nreturn listOfStringLengthConsistent(tvb, offset + 8, (length - 2) * 4, v16(tvb, offset + 4));\r\ncase X_CreateGC:\r\nreturn !tvb_bytes_exist(tvb, offset, 16) || length == 4 + numberOfBitSet(tvb, offset + 12, 4);\r\ncase X_SetDashes:\r\nreturn !tvb_bytes_exist(tvb, offset, 12) || length == 3 + rounded4(v16(tvb, offset + 10));\r\ncase X_SetClipRectangles:\r\ncase X_PolySegment:\r\ncase X_PolyRectangle:\r\ncase X_PolyFillRectangle:\r\nreturn length >= 3 && (length - 3) % 2 == 0;\r\ncase X_CopyArea:\r\nreturn length == 7;\r\ncase X_CopyPlane:\r\ncase X_CreateCursor:\r\ncase X_CreateGlyphCursor:\r\nreturn length == 8;\r\ncase X_PolyPoint:\r\ncase X_PolyLine:\r\ncase X_FreeColors:\r\nreturn length >= 3;\r\ncase X_PolyArc:\r\ncase X_PolyFillArc:\r\nreturn length >= 3 && (length - 3) % 3 == 0;\r\ncase X_FillPoly:\r\ncase X_ImageText8:\r\nreturn length >= 4;\r\ncase X_PutImage:\r\nreturn length >= 6;\r\ncase X_GetImage:\r\ncase X_RecolorCursor:\r\nreturn length == 5;\r\ncase X_PolyText8:\r\nif (length < 4) return FALSE;\r\nreturn TRUE;\r\ncase X_PolyText16:\r\nif (length < 4) return FALSE;\r\nreturn TRUE;\r\ncase X_ImageText16:\r\nreturn length >= 4;\r\ncase X_StoreColors:\r\nreturn length > 2 && (length - 2) % 3 == 0;\r\ncase X_StoreNamedColor:\r\nreturn !tvb_bytes_exist(tvb, offset, 14) || length == 4 + rounded4(v16(tvb, offset + 12));\r\ncase X_QueryColors:\r\nreturn length >= 2;\r\ncase X_ChangeKeyboardMapping:\r\nreturn !tvb_bytes_exist(tvb, offset, 6) || length == 2 + tvb_get_guint8(tvb, 1) * tvb_get_guint8(tvb, 5);\r\ncase X_ChangeKeyboardControl:\r\nreturn !tvb_bytes_exist(tvb, offset, 6) || length == 2 + numberOfBitSet(tvb, offset + 4, 2);\r\ncase X_RotateProperties:\r\nreturn !tvb_bytes_exist(tvb, offset, 10) || length == 3 + v16(tvb, offset + 8);\r\ncase X_SetPointerMapping:\r\nreturn length == 1 + rounded4(tvb_get_guint8(tvb, 1));\r\ncase X_SetModifierMapping:\r\nreturn length == 1 + tvb_get_guint8(tvb, 1) * 2;\r\ncase X_NoOperation:\r\nreturn length >= 1;\r\ndefault:\r\nreturn TRUE;\r\n}\r\n}\r\nstatic int x_endian_match(tvbuff_t *tvb, guint16 (*v16)(tvbuff_t *, const gint))\r\n{\r\nint offset, nextoffset;\r\nint atLeastOne = 0;\r\nfor(offset = 0; tvb_bytes_exist(tvb, offset, 4); offset = nextoffset) {\r\nint length;\r\nlength = v16(tvb, offset + 2);\r\nif (!length) return -1;\r\nnextoffset = offset + length * 4;\r\nif (!consistentWithOrder(length, tvb, offset, v16)) return -1;\r\natLeastOne = 1;\r\n}\r\nreturn atLeastOne;\r\n}\r\nstatic guint\r\nguess_byte_ordering(tvbuff_t *tvb, packet_info *pinfo,\r\nx11_conv_data_t *state)\r\n{\r\nint le, be;\r\nguint decision;\r\nif (state->byte_order == BYTE_ORDER_BE)\r\nreturn ENC_BIG_ENDIAN;\r\nelse if (state->byte_order == BYTE_ORDER_LE)\r\nreturn ENC_LITTLE_ENDIAN;\r\nif (pinfo->srcport == pinfo->match_uint) {\r\nreturn ENC_LITTLE_ENDIAN;\r\n}\r\nle = x_endian_match(tvb, tvb_get_letohs);\r\nbe = x_endian_match(tvb, tvb_get_ntohs);\r\nif (le == be) {\r\nif (!tvb_bytes_exist(tvb, 0, 4))\r\ndecision = ENC_LITTLE_ENDIAN;\r\nelse {\r\nif (tvb_get_letohs(tvb, 2) <= tvb_get_ntohs(tvb, 2))\r\ndecision = ENC_LITTLE_ENDIAN;\r\nelse\r\ndecision = ENC_BIG_ENDIAN;\r\n}\r\n} else {\r\nif (le >= be)\r\ndecision = ENC_LITTLE_ENDIAN;\r\nelse\r\ndecision = ENC_BIG_ENDIAN;\r\n}\r\nif ((le < 0 && be > 0) || (le > 0 && be < 0)) {\r\nstate->byte_order = (decision == ENC_BIG_ENDIAN) ? BYTE_ORDER_BE : BYTE_ORDER_LE;\r\n}\r\nreturn decision;\r\n}\r\nstatic void dissect_x11_initial_conn(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, x11_conv_data_t *state, guint byte_order)\r\n{\r\nint offset = 0;\r\nint *offsetp = &offset;\r\nproto_item *ti;\r\nproto_tree *t;\r\nguint16 auth_proto_name_length, auth_proto_data_length;\r\ngint left;\r\nti = proto_tree_add_item(tree, proto_x11, tvb, 0, -1, ENC_NA);\r\nproto_item_append_text(ti, ", Request, Initial connection request");\r\nt = proto_item_add_subtree(ti, ett_x11);\r\nCARD8(byte_order);\r\nUNUSED(1);\r\nCARD16(protocol_major_version);\r\nCARD16(protocol_minor_version);\r\nauth_proto_name_length = CARD16(authorization_protocol_name_length);\r\nauth_proto_data_length = CARD16(authorization_protocol_data_length);\r\nUNUSED(2);\r\nif (auth_proto_name_length != 0) {\r\nSTRING8(authorization_protocol_name, auth_proto_name_length);\r\noffset = ROUND_LENGTH(offset);\r\n}\r\nif (auth_proto_data_length != 0) {\r\nSTRING8(authorization_protocol_data, auth_proto_data_length);\r\noffset = ROUND_LENGTH(offset);\r\n}\r\nif ((left = tvb_reported_length_remaining(tvb, offset)) > 0)\r\nproto_tree_add_item(t, hf_x11_undecoded, tvb, offset, left,\r\nENC_NA);\r\nstate->iconn_frame = pinfo->num;\r\nstate->sequencenumber = 0;\r\ng_hash_table_insert(state->seqtable, GINT_TO_POINTER(state->sequencenumber),\r\n(int *)INITIAL_CONN);\r\n}\r\nstatic void dissect_x11_initial_reply(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, const char _U_ *sep, x11_conv_data_t *state,\r\nguint byte_order)\r\n{\r\nint offset = 0, *offsetp = &offset, left;\r\nunsigned char success;\r\nint length_of_vendor;\r\nint length_of_reason;\r\nint number_of_formats_in_pixmap_formats;\r\nint number_of_screens_in_roots;\r\nint unused;\r\nproto_item *ti;\r\nproto_tree *t;\r\nti = proto_tree_add_item(tree, proto_x11, tvb, 0, -1, ENC_NA);\r\nproto_item_append_text(ti, ", Reply, Initial connection reply");\r\nt = proto_item_add_subtree(ti, ett_x11);\r\nstate->iconn_reply = pinfo->num;\r\nsuccess = INT8(success);\r\nif (success) {\r\nUNUSED(1);\r\nlength_of_reason = 0;\r\n}\r\nelse {\r\nlength_of_reason = INT8(length_of_reason);\r\n}\r\nINT16(protocol_major_version);\r\nINT16(protocol_minor_version);\r\nINT16(replylength);\r\nif (success) {\r\nINT32(release_number);\r\nINT32(resource_id_base);\r\nINT32(resource_id_mask);\r\nINT32(motion_buffer_size);\r\nlength_of_vendor = INT16(length_of_vendor);\r\nINT16(maximum_request_length);\r\nnumber_of_screens_in_roots = INT8(number_of_screens_in_roots);\r\nnumber_of_formats_in_pixmap_formats = INT8(number_of_formats_in_pixmap_formats);\r\nINT8(image_byte_order);\r\nINT8(bitmap_format_bit_order);\r\nINT8(bitmap_format_scanline_unit);\r\nINT8(bitmap_format_scanline_pad);\r\nINT8(min_keycode);\r\nINT8(max_keycode);\r\nUNUSED(4);\r\nSTRING8(vendor, length_of_vendor);\r\nunused = (4 - (length_of_vendor % 4)) % 4;\r\nif (unused > 0)\r\nUNUSED(unused);\r\nLISTofPIXMAPFORMAT(pixmap_format, number_of_formats_in_pixmap_formats);\r\nLISTofSCREEN(screen, number_of_screens_in_roots);\r\n} else {\r\nSTRING8(reason, length_of_reason);\r\n}\r\nif ((left = tvb_reported_length_remaining(tvb, offset)) > 0)\r\nUNDECODED(left);\r\n}\r\nstatic void set_handler(const char *name, void (*func)(tvbuff_t *tvb, packet_info *pinfo, int *offsetp, proto_tree *t, guint byte_order),\r\nconst char **errors,\r\nconst x11_event_info *event_info,\r\nconst x11_generic_event_info *genevent_info,\r\nconst x11_reply_info *reply_info)\r\n{\r\ng_hash_table_insert(extension_table, (gpointer)name, (gpointer)func);\r\ng_hash_table_insert(error_table, (gpointer)name, (gpointer)errors);\r\ng_hash_table_insert(event_table, (gpointer)name, (gpointer)event_info);\r\nif (genevent_info)\r\ng_hash_table_insert(genevent_table, (gpointer)name, (gpointer)genevent_info);\r\ng_hash_table_insert(reply_table, (gpointer)name, (gpointer)reply_info);\r\n}\r\nstatic void tryExtension(int opcode, tvbuff_t *tvb, packet_info *pinfo, int *offsetp, proto_tree *t,\r\nx11_conv_data_t *state, guint byte_order)\r\n{\r\nconst gchar *extension;\r\nvoid (*func)(tvbuff_t *tvb, packet_info *pinfo, int *offsetp, proto_tree *t, guint byte_order);\r\nextension = try_val_to_str(opcode, state->opcode_vals);\r\nif (!extension)\r\nreturn;\r\nfunc = (void (*)(tvbuff_t *, packet_info *, int *, proto_tree *, guint))g_hash_table_lookup(extension_table, extension);\r\nif (func)\r\nfunc(tvb, pinfo, offsetp, t, byte_order);\r\n}\r\nstatic void tryExtensionReply(int opcode, tvbuff_t *tvb, packet_info *pinfo, int *offsetp, proto_tree *t,\r\nx11_conv_data_t *state, guint byte_order)\r\n{\r\nvoid (*func)(tvbuff_t *tvb, packet_info *pinfo, int *offsetp, proto_tree *t, guint byte_order);\r\nfunc = (void (*)(tvbuff_t *, packet_info *, int *, proto_tree *, guint))g_hash_table_lookup(state->reply_funcs, GINT_TO_POINTER(opcode));\r\nif (func)\r\nfunc(tvb, pinfo, offsetp, t, byte_order);\r\nelse\r\nREPLYCONTENTS_COMMON();\r\n}\r\nstatic void tryExtensionEvent(int event, tvbuff_t *tvb, int *offsetp, proto_tree *t,\r\nx11_conv_data_t *state, guint byte_order)\r\n{\r\nvoid (*func)(tvbuff_t *tvb, int *offsetp, proto_tree *t, guint byte_order);\r\nfunc = (void (*)(tvbuff_t *, int *, proto_tree *, guint))g_hash_table_lookup(state->eventcode_funcs, GINT_TO_POINTER(event));\r\nif (func)\r\nfunc(tvb, offsetp, t, byte_order);\r\n}\r\nstatic void tryGenericExtensionEvent(tvbuff_t *tvb, int *offsetp, proto_tree *t,\r\nx11_conv_data_t *state, guint byte_order)\r\n{\r\nconst gchar *extname;\r\nint extension, length;\r\nextension = VALUE8(tvb, *offsetp);\r\n(*offsetp)++;\r\nextname = try_val_to_str(extension, state->opcode_vals);\r\nif (extname) {\r\nproto_tree_add_uint_format(t, hf_x11_extension, tvb, *offsetp, 1, extension, "extension: %d (%s)", extension, extname);\r\n} else {\r\nproto_tree_add_uint(t, hf_x11_extension, tvb, *offsetp, 1, extension);\r\n}\r\nCARD16(event_sequencenumber);\r\nlength = REPLYLENGTH(eventlength);\r\nlength = length * 4 + 32;\r\n*offsetp += 4;\r\nif (extname) {\r\nx11_generic_event_info *info;\r\ninfo = (x11_generic_event_info *)g_hash_table_lookup(genevent_table, extname);\r\nif (info) {\r\nint i;\r\nint opcode = VALUE16(tvb, *offsetp);\r\nfor (i = 0; info[i].dissect != NULL; i++) {\r\nif (info[i].minor == opcode) {\r\n*offsetp += 2;\r\ninfo[i].dissect(tvb, length, offsetp, t, byte_order);\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nCARD16(minor_opcode);\r\n}\r\nstatic void register_extension(x11_conv_data_t *state, value_string *vals_p,\r\nint major_opcode, unsigned int first_event, unsigned int first_error)\r\n{\r\nconst char **error_string;\r\nx11_event_info *event_info;\r\nx11_reply_info *reply_info;\r\nint i;\r\nvals_p->value = major_opcode;\r\nerror_string = (const char **)g_hash_table_lookup(error_table, vals_p->strptr);\r\nwhile (error_string && *error_string && first_error <= LastExtensionError) {\r\nfor (i = 0; i <= LastExtensionError; i++) {\r\nif (state->errorcode_vals[i].strptr == NULL) {\r\nstate->errorcode_vals[i].value = first_error;\r\nstate->errorcode_vals[i].strptr = *error_string;\r\nbreak;\r\n} else if (state->errorcode_vals[i].value == first_error) {\r\nstate->errorcode_vals[i].strptr = *error_string;\r\nbreak;\r\n}\r\n}\r\nfirst_error++;\r\nerror_string++;\r\n}\r\nevent_info = (x11_event_info *)g_hash_table_lookup(event_table, vals_p->strptr);\r\nwhile (event_info && event_info->name && first_event <= LastExtensionEvent) {\r\nfor (i = 0; i <= LastExtensionEvent; i++) {\r\nif (state->eventcode_vals[i].strptr == NULL) {\r\nstate->eventcode_vals[i].value = first_event;\r\nstate->eventcode_vals[i].strptr = event_info->name;\r\nbreak;\r\n} else if (state->eventcode_vals[i].value == first_event) {\r\nstate->eventcode_vals[i].strptr = event_info->name;\r\nbreak;\r\n}\r\n}\r\ng_hash_table_insert(state->eventcode_funcs, GINT_TO_POINTER(first_event), (gpointer)event_info->dissect);\r\nfirst_event++;\r\nevent_info++;\r\n}\r\nreply_info = (x11_reply_info *)g_hash_table_lookup(reply_table, vals_p->strptr);\r\nif (reply_info)\r\nfor (i = 0; reply_info[i].dissect; i++)\r\ng_hash_table_insert(state->reply_funcs,\r\nGINT_TO_POINTER(major_opcode | (reply_info[i].minor << 8)),\r\n(gpointer)reply_info[i].dissect);\r\n}\r\nstatic void dissect_x11_request(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, const char *sep, x11_conv_data_t *state,\r\nguint byte_order)\r\n{\r\nint offset = 0;\r\nint *offsetp = &offset;\r\nint next_offset;\r\nproto_item *ti;\r\nproto_tree *t;\r\nint length, opcode, i;\r\nguint8 v8, v8_2, v8_3;\r\nguint16 v16;\r\nguint32 v32;\r\ngint left;\r\ngchar *name;\r\nlength = VALUE16(tvb, 2) * 4;\r\nif (length < 4) {\r\nreturn;\r\n}\r\nnext_offset = offset + length;\r\nti = proto_tree_add_item(tree, proto_x11, tvb, 0, -1, ENC_NA);\r\nt = proto_item_add_subtree(ti, ett_x11);\r\nif (PACKET_IS_NEW(pinfo))\r\n++state->sequencenumber;\r\nOPCODE();\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s %s", sep,\r\nval_to_str(opcode, state->opcode_vals,\r\n"<Unknown opcode %d>"));\r\nproto_item_append_text(ti, ", Request, opcode: %d (%s)",\r\nopcode, val_to_str(opcode, state->opcode_vals,\r\n"<Unknown opcode %d>"));\r\nswitch(opcode) {\r\ncase X_QueryExtension:\r\nv16 = VALUE16(tvb, 4);\r\nname = tvb_get_string_enc(wmem_file_scope(), tvb, 8, v16, ENC_ASCII);\r\ni = 0;\r\nwhile(i < MAX_OPCODES) {\r\nif (state->opcode_vals[i].strptr == NULL) {\r\nstate->opcode_vals[i].strptr = name;\r\nstate->opcode_vals[i].value = -1;\r\ng_hash_table_insert(state->valtable,\r\nGINT_TO_POINTER(state->sequencenumber),\r\n(int *)&state->opcode_vals[i]);\r\nbreak;\r\n} else if (strcmp(state->opcode_vals[i].strptr,\r\nname) == 0) {\r\ng_hash_table_insert(state->valtable,\r\nGINT_TO_POINTER(state->sequencenumber),\r\n(int *)&state->opcode_vals[i]);\r\nbreak;\r\n}\r\ni++;\r\n}\r\ncase X_AllocColor:\r\ncase X_AllocColorCells:\r\ncase X_AllocColorPlanes:\r\ncase X_AllocNamedColor:\r\ncase X_GetAtomName:\r\ncase X_GetFontPath:\r\ncase X_GetGeometry:\r\ncase X_GetImage:\r\ncase X_GetInputFocus:\r\ncase X_GetKeyboardControl:\r\ncase X_GetKeyboardMapping:\r\ncase X_GetModifierMapping:\r\ncase X_GetMotionEvents:\r\ncase X_GetPointerControl:\r\ncase X_GetPointerMapping:\r\ncase X_GetProperty:\r\ncase X_GetScreenSaver:\r\ncase X_GetSelectionOwner:\r\ncase X_GetWindowAttributes:\r\ncase X_GrabKeyboard:\r\ncase X_GrabPointer:\r\ncase X_InternAtom:\r\ncase X_ListExtensions:\r\ncase X_ListFonts:\r\ncase X_ListFontsWithInfo:\r\ncase X_ListHosts:\r\ncase X_ListInstalledColormaps:\r\ncase X_ListProperties:\r\ncase X_LookupColor:\r\ncase X_QueryBestSize:\r\ncase X_QueryColors:\r\ncase X_QueryFont:\r\ncase X_QueryKeymap:\r\ncase X_QueryPointer:\r\ncase X_QueryTextExtents:\r\ncase X_QueryTree:\r\ncase X_SetModifierMapping:\r\ncase X_SetPointerMapping:\r\ncase X_TranslateCoords:\r\ng_hash_table_insert(state->seqtable,\r\nGINT_TO_POINTER(state->sequencenumber),\r\nGINT_TO_POINTER(opcode));\r\nbreak;\r\ndefault:\r\nif (opcode >= X_FirstExtension && opcode <= X_LastExtension) {\r\nguint32 minor;\r\nminor = tvb_get_guint8(tvb, 1);\r\ng_hash_table_insert(state->seqtable,\r\nGINT_TO_POINTER(state->sequencenumber),\r\nGINT_TO_POINTER(opcode | (minor << 8)));\r\n}\r\nbreak;\r\n}\r\nif (tree == NULL)\r\nreturn;\r\nswitch(opcode) {\r\ncase X_CreateWindow:\r\nCARD8(depth);\r\nREQUEST_LENGTH();\r\nWINDOW(wid);\r\nWINDOW(parent);\r\nINT16(x);\r\nINT16(y);\r\nCARD16(width);\r\nCARD16(height);\r\nCARD16(border_width);\r\nENUM16(window_class);\r\nVISUALID(visual);\r\nwindowAttributes(tvb, offsetp, t, byte_order);\r\nbreak;\r\ncase X_ChangeWindowAttributes:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nWINDOW(window);\r\nwindowAttributes(tvb, offsetp, t, byte_order);\r\nbreak;\r\ncase X_GetWindowAttributes:\r\ncase X_DestroyWindow:\r\ncase X_DestroySubwindows:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nWINDOW(window);\r\nbreak;\r\ncase X_ChangeSaveSet:\r\nENUM8(save_set_mode);\r\nREQUEST_LENGTH();\r\nWINDOW(window);\r\nbreak;\r\ncase X_ReparentWindow:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nWINDOW(window);\r\nWINDOW(parent);\r\nINT16(x);\r\nINT16(y);\r\nbreak;\r\ncase X_MapWindow:\r\ncase X_MapSubwindows:\r\ncase X_UnmapWindow:\r\ncase X_UnmapSubwindows:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nWINDOW(window);\r\nbreak;\r\ncase X_ConfigureWindow:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nWINDOW(window);\r\nBITMASK16(configure_window);\r\nUNUSED(2);\r\nBITFIELD(INT16, configure_window_mask, x);\r\nBITFIELD(INT16, configure_window_mask, y);\r\nBITFIELD(CARD16, configure_window_mask, width);\r\nBITFIELD(CARD16, configure_window_mask, height);\r\nBITFIELD(CARD16, configure_window_mask, border_width);\r\nBITFIELD(WINDOW, configure_window_mask, sibling);\r\nBITFIELD(ENUM8, configure_window_mask, stack_mode);\r\nENDBITMASK;\r\nPAD();\r\nbreak;\r\ncase X_CirculateWindow:\r\nENUM8(direction);\r\nREQUEST_LENGTH();\r\nWINDOW(window);\r\nbreak;\r\ncase X_GetGeometry:\r\ncase X_QueryTree:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nDRAWABLE(drawable);\r\nbreak;\r\ncase X_InternAtom:\r\nBOOL(only_if_exists);\r\nREQUEST_LENGTH();\r\nv16 = FIELD16(name_length);\r\nUNUSED(2);\r\nSTRING8(name, v16);\r\nPAD();\r\nbreak;\r\ncase X_GetAtomName:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nATOM(atom);\r\nbreak;\r\ncase X_ChangeProperty:\r\nENUM8(mode);\r\nREQUEST_LENGTH();\r\nWINDOW(window);\r\nATOM(property);\r\nATOM(type);\r\nv8 = CARD8(format);\r\nUNUSED(3);\r\nv32 = CARD32(data_length);\r\nswitch (v8) {\r\ncase 8:\r\nif (v32)\r\nLISTofBYTE(data, v32);\r\nbreak;\r\ncase 16:\r\nif (v32)\r\nLISTofCARD16(data16, v32 * 2);\r\nbreak;\r\ncase 32:\r\nif (v32)\r\nLISTofCARD32(data32, v32 * 4);\r\nbreak;\r\ndefault:\r\nexpert_add_info(pinfo, ti, &ei_x11_invalid_format);\r\nbreak;\r\n}\r\nPAD();\r\nbreak;\r\ncase X_DeleteProperty:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nWINDOW(window);\r\nATOM(property);\r\nbreak;\r\ncase X_GetProperty:\r\nBOOL(delete);\r\nREQUEST_LENGTH();\r\nWINDOW(window);\r\nATOM(property);\r\nATOM(get_property_type);\r\nCARD32(long_offset);\r\nCARD32(long_length);\r\nbreak;\r\ncase X_ListProperties:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nWINDOW(window);\r\nbreak;\r\ncase X_SetSelectionOwner:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nWINDOW(owner);\r\nATOM(selection);\r\nTIMESTAMP(time);\r\nbreak;\r\ncase X_GetSelectionOwner:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nATOM(selection);\r\nbreak;\r\ncase X_ConvertSelection:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nWINDOW(requestor);\r\nATOM(selection);\r\nATOM(target);\r\nATOM(property);\r\nTIMESTAMP(time);\r\nbreak;\r\ncase X_SendEvent:\r\nBOOL(propagate);\r\nREQUEST_LENGTH();\r\nWINDOW(destination);\r\nSETofEVENT(event_mask);\r\nEVENT();\r\nbreak;\r\ncase X_GrabPointer:\r\nBOOL(owner_events);\r\nREQUEST_LENGTH();\r\nWINDOW(grab_window);\r\nSETofPOINTEREVENT(pointer_event_mask);\r\nENUM8(pointer_mode);\r\nENUM8(keyboard_mode);\r\nWINDOW(confine_to);\r\nCURSOR(cursor);\r\nTIMESTAMP(time);\r\nbreak;\r\ncase X_UngrabPointer:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nTIMESTAMP(time);\r\nbreak;\r\ncase X_GrabButton:\r\nBOOL(owner_events);\r\nREQUEST_LENGTH();\r\nWINDOW(grab_window);\r\nSETofPOINTEREVENT(event_mask);\r\nENUM8(pointer_mode);\r\nENUM8(keyboard_mode);\r\nWINDOW(confine_to);\r\nCURSOR(cursor);\r\nBUTTON(button);\r\nUNUSED(1);\r\nSETofKEYMASK(modifiers);\r\nbreak;\r\ncase X_UngrabButton:\r\nBUTTON(button);\r\nREQUEST_LENGTH();\r\nWINDOW(grab_window);\r\nSETofKEYMASK(modifiers);\r\nUNUSED(2);\r\nbreak;\r\ncase X_ChangeActivePointerGrab:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nCURSOR(cursor);\r\nTIMESTAMP(time);\r\nSETofPOINTEREVENT(event_mask);\r\nUNUSED(2);\r\nbreak;\r\ncase X_GrabKeyboard:\r\nBOOL(owner_events);\r\nREQUEST_LENGTH();\r\nWINDOW(grab_window);\r\nTIMESTAMP(time);\r\nENUM8(pointer_mode);\r\nENUM8(keyboard_mode);\r\nUNUSED(2);\r\nbreak;\r\ncase X_UngrabKeyboard:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nTIMESTAMP(time);\r\nbreak;\r\ncase X_GrabKey:\r\nBOOL(owner_events);\r\nREQUEST_LENGTH();\r\nWINDOW(grab_window);\r\nSETofKEYMASK(modifiers);\r\nKEYCODE(key);\r\nENUM8(pointer_mode);\r\nENUM8(keyboard_mode);\r\nUNUSED(3);\r\nbreak;\r\ncase X_UngrabKey:\r\nKEYCODE(key);\r\nREQUEST_LENGTH();\r\nWINDOW(grab_window);\r\nSETofKEYMASK(modifiers);\r\nUNUSED(2);\r\nbreak;\r\ncase X_AllowEvents:\r\nENUM8(allow_events_mode);\r\nREQUEST_LENGTH();\r\nTIMESTAMP(time);\r\nbreak;\r\ncase X_GrabServer:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nbreak;\r\ncase X_UngrabServer:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nbreak;\r\ncase X_QueryPointer:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nWINDOW(window);\r\nbreak;\r\ncase X_GetMotionEvents:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nWINDOW(window);\r\nTIMESTAMP(start);\r\nTIMESTAMP(stop);\r\nbreak;\r\ncase X_TranslateCoords:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nWINDOW(src_window);\r\nWINDOW(dst_window);\r\nINT16(src_x);\r\nINT16(src_y);\r\nbreak;\r\ncase X_WarpPointer:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nWINDOW(warp_pointer_src_window);\r\nWINDOW(warp_pointer_dst_window);\r\nINT16(src_x);\r\nINT16(src_y);\r\nCARD16(src_width);\r\nCARD16(src_height);\r\nINT16(dst_x);\r\nINT16(dst_y);\r\nbreak;\r\ncase X_SetInputFocus:\r\nENUM8(revert_to);\r\nREQUEST_LENGTH();\r\nWINDOW(focus);\r\nTIMESTAMP(time);\r\nbreak;\r\ncase X_GetInputFocus:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nbreak;\r\ncase X_QueryKeymap:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nbreak;\r\ncase X_OpenFont:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nFONT(fid);\r\nv16 = FIELD16(name_length);\r\nUNUSED(2);\r\nSTRING8(name, v16);\r\nPAD();\r\nbreak;\r\ncase X_CloseFont:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nFONT(font);\r\nbreak;\r\ncase X_QueryFont:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nFONTABLE(font);\r\nbreak;\r\ncase X_QueryTextExtents:\r\nv8 = BOOL(odd_length);\r\nREQUEST_LENGTH();\r\nFONTABLE(font);\r\nSTRING16(string16, (next_offset - offset - (v8 ? 2 : 0)) / 2);\r\nPAD();\r\nbreak;\r\ncase X_ListFonts:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nCARD16(max_names);\r\nv16 = FIELD16(pattern_length);\r\nSTRING8(pattern, v16);\r\nPAD();\r\nbreak;\r\ncase X_ListFontsWithInfo:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nCARD16(max_names);\r\nv16 = FIELD16(pattern_length);\r\nSTRING8(pattern, v16);\r\nPAD();\r\nbreak;\r\ncase X_SetFontPath:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nv16 = CARD16(str_number_in_path);\r\nUNUSED(2);\r\nLISTofSTRING8(path, v16);\r\nPAD();\r\nbreak;\r\ncase X_GetFontPath:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nbreak;\r\ncase X_CreatePixmap:\r\nCARD8(depth);\r\nREQUEST_LENGTH();\r\nPIXMAP(pid);\r\nDRAWABLE(drawable);\r\nCARD16(width);\r\nCARD16(height);\r\nbreak;\r\ncase X_FreePixmap:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nPIXMAP(pixmap);\r\nbreak;\r\ncase X_CreateGC:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nGCONTEXT(cid);\r\nDRAWABLE(drawable);\r\ngcAttributes(tvb, offsetp, t, byte_order);\r\nbreak;\r\ncase X_ChangeGC:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nGCONTEXT(gc);\r\ngcAttributes(tvb, offsetp, t, byte_order);\r\nbreak;\r\ncase X_CopyGC:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nGCONTEXT(src_gc);\r\nGCONTEXT(dst_gc);\r\ngcMask(tvb, offsetp, t, byte_order);\r\nbreak;\r\ncase X_SetDashes:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nGCONTEXT(gc);\r\nCARD16(dash_offset);\r\nv16 = FIELD16(dashes_length);\r\nLISTofCARD8(dashes, v16);\r\nPAD();\r\nbreak;\r\ncase X_SetClipRectangles:\r\nENUM8(ordering);\r\nREQUEST_LENGTH();\r\nGCONTEXT(gc);\r\nINT16(clip_x_origin);\r\nINT16(clip_y_origin);\r\nLISTofRECTANGLE(rectangles);\r\nbreak;\r\ncase X_FreeGC:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nGCONTEXT(gc);\r\nbreak;\r\ncase X_ClearArea:\r\nBOOL(exposures);\r\nREQUEST_LENGTH();\r\nWINDOW(window);\r\nINT16(x);\r\nINT16(y);\r\nCARD16(width);\r\nCARD16(height);\r\nbreak;\r\ncase X_CopyArea:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nDRAWABLE(src_drawable);\r\nDRAWABLE(dst_drawable);\r\nGCONTEXT(gc);\r\nINT16(src_x);\r\nINT16(src_y);\r\nINT16(dst_x);\r\nINT16(dst_y);\r\nCARD16(width);\r\nCARD16(height);\r\nbreak;\r\ncase X_CopyPlane:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nDRAWABLE(src_drawable);\r\nDRAWABLE(dst_drawable);\r\nGCONTEXT(gc);\r\nINT16(src_x);\r\nINT16(src_y);\r\nINT16(dst_x);\r\nINT16(dst_y);\r\nCARD16(width);\r\nCARD16(height);\r\nCARD32(bit_plane);\r\nbreak;\r\ncase X_PolyPoint:\r\nENUM8(coordinate_mode);\r\nv16 = REQUEST_LENGTH();\r\nDRAWABLE(drawable);\r\nGCONTEXT(gc);\r\nLISTofPOINT(points, v16 - 12);\r\nbreak;\r\ncase X_PolyLine:\r\nENUM8(coordinate_mode);\r\nv16 = REQUEST_LENGTH();\r\nDRAWABLE(drawable);\r\nGCONTEXT(gc);\r\nLISTofPOINT(points, v16 - 12);\r\nbreak;\r\ncase X_PolySegment:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nDRAWABLE(drawable);\r\nGCONTEXT(gc);\r\nLISTofSEGMENT(segments);\r\nbreak;\r\ncase X_PolyRectangle:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nDRAWABLE(drawable);\r\nGCONTEXT(gc);\r\nLISTofRECTANGLE(rectangles);\r\nbreak;\r\ncase X_PolyArc:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nDRAWABLE(drawable);\r\nGCONTEXT(gc);\r\nLISTofARC(arcs);\r\nbreak;\r\ncase X_FillPoly:\r\nUNUSED(1);\r\nv16 = REQUEST_LENGTH();\r\nDRAWABLE(drawable);\r\nGCONTEXT(gc);\r\nENUM8(shape);\r\nENUM8(coordinate_mode);\r\nUNUSED(2);\r\nLISTofPOINT(points, v16 - 16);\r\nbreak;\r\ncase X_PolyFillRectangle:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nDRAWABLE(drawable);\r\nGCONTEXT(gc);\r\nLISTofRECTANGLE(rectangles);\r\nbreak;\r\ncase X_PolyFillArc:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nDRAWABLE(drawable);\r\nGCONTEXT(gc);\r\nLISTofARC(arcs);\r\nbreak;\r\ncase X_PutImage:\r\nENUM8(image_format);\r\nv16 = REQUEST_LENGTH();\r\nDRAWABLE(drawable);\r\nGCONTEXT(gc);\r\nCARD16(width);\r\nCARD16(height);\r\nINT16(dst_x);\r\nINT16(dst_y);\r\nCARD8(left_pad);\r\nCARD8(depth);\r\nUNUSED(2);\r\nLISTofBYTE(data, v16 - 24);\r\nPAD();\r\nbreak;\r\ncase X_GetImage:\r\nENUM8(image_pixmap_format);\r\nREQUEST_LENGTH();\r\nDRAWABLE(drawable);\r\nINT16(x);\r\nINT16(y);\r\nCARD16(width);\r\nCARD16(height);\r\nCARD32(plane_mask);\r\nbreak;\r\ncase X_PolyText8:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nDRAWABLE(drawable);\r\nGCONTEXT(gc);\r\nINT16(x);\r\nINT16(y);\r\nLISTofTEXTITEM8(items);\r\nPAD();\r\nbreak;\r\ncase X_PolyText16:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nDRAWABLE(drawable);\r\nGCONTEXT(gc);\r\nINT16(x);\r\nINT16(y);\r\nLISTofTEXTITEM16(items);\r\nPAD();\r\nbreak;\r\ncase X_ImageText8:\r\nv8 = FIELD8(string_length);\r\nREQUEST_LENGTH();\r\nDRAWABLE(drawable);\r\nGCONTEXT(gc);\r\nINT16(x);\r\nINT16(y);\r\nSTRING8(string, v8);\r\nPAD();\r\nbreak;\r\ncase X_ImageText16:\r\nv8 = FIELD8(string_length);\r\nREQUEST_LENGTH();\r\nDRAWABLE(drawable);\r\nGCONTEXT(gc);\r\nINT16(x);\r\nINT16(y);\r\nSTRING16(string16, v8);\r\nPAD();\r\nbreak;\r\ncase X_CreateColormap:\r\nENUM8(alloc);\r\nREQUEST_LENGTH();\r\nCOLORMAP(mid);\r\nWINDOW(window);\r\nVISUALID(visual);\r\nbreak;\r\ncase X_FreeColormap:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nCOLORMAP(cmap);\r\nbreak;\r\ncase X_CopyColormapAndFree:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nCOLORMAP(mid);\r\nCOLORMAP(src_cmap);\r\nbreak;\r\ncase X_InstallColormap:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nCOLORMAP(cmap);\r\nbreak;\r\ncase X_UninstallColormap:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nCOLORMAP(cmap);\r\nbreak;\r\ncase X_ListInstalledColormaps:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nWINDOW(window);\r\nbreak;\r\ncase X_AllocColor:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nCOLORMAP(cmap);\r\nCARD16(red);\r\nCARD16(green);\r\nCARD16(blue);\r\nUNUSED(2);\r\nbreak;\r\ncase X_AllocNamedColor:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nCOLORMAP(cmap);\r\nv16 = FIELD16(name_length);\r\nUNUSED(2);\r\nSTRING8(name, v16);\r\nPAD();\r\nbreak;\r\ncase X_AllocColorCells:\r\nBOOL(contiguous);\r\nREQUEST_LENGTH();\r\nCOLORMAP(cmap);\r\nCARD16(colors);\r\nCARD16(planes);\r\nbreak;\r\ncase X_AllocColorPlanes:\r\nBOOL(contiguous);\r\nREQUEST_LENGTH();\r\nCOLORMAP(cmap);\r\nCARD16(colors);\r\nCARD16(reds);\r\nCARD16(greens);\r\nCARD16(blues);\r\nbreak;\r\ncase X_FreeColors:\r\nUNUSED(1);\r\nv16 = REQUEST_LENGTH();\r\nCOLORMAP(cmap);\r\nCARD32(plane_mask);\r\nLISTofCARD32(pixels, v16 - 12);\r\nbreak;\r\ncase X_StoreColors:\r\nUNUSED(1);\r\nv16 = REQUEST_LENGTH();\r\nCOLORMAP(cmap);\r\nLISTofCOLORITEM(color_items, v16 - 8);\r\nbreak;\r\ncase X_StoreNamedColor:\r\nCOLOR_FLAGS(color);\r\nREQUEST_LENGTH();\r\nCOLORMAP(cmap);\r\nCARD32(pixel);\r\nv16 = FIELD16(name_length);\r\nUNUSED(2);\r\nSTRING8(name, v16);\r\nPAD();\r\nbreak;\r\ncase X_QueryColors:\r\nUNUSED(1);\r\nv16 = REQUEST_LENGTH();\r\nCOLORMAP(cmap);\r\nLISTofCARD32(pixels, v16 - 8);\r\nbreak;\r\ncase X_LookupColor:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nCOLORMAP(cmap);\r\nv16 = FIELD16(name_length);\r\nUNUSED(2);\r\nSTRING8(name, v16);\r\nPAD();\r\nbreak;\r\ncase X_CreateCursor:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nCURSOR(cid);\r\nPIXMAP(source_pixmap);\r\nPIXMAP(mask);\r\nCARD16(fore_red);\r\nCARD16(fore_green);\r\nCARD16(fore_blue);\r\nCARD16(back_red);\r\nCARD16(back_green);\r\nCARD16(back_blue);\r\nCARD16(x);\r\nCARD16(y);\r\nbreak;\r\ncase X_CreateGlyphCursor:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nCURSOR(cid);\r\nFONT(source_font);\r\nFONT(mask_font);\r\nCARD16(source_char);\r\nCARD16(mask_char);\r\nCARD16(fore_red);\r\nCARD16(fore_green);\r\nCARD16(fore_blue);\r\nCARD16(back_red);\r\nCARD16(back_green);\r\nCARD16(back_blue);\r\nbreak;\r\ncase X_FreeCursor:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nCURSOR(cursor);\r\nbreak;\r\ncase X_RecolorCursor:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nCURSOR(cursor);\r\nCARD16(fore_red);\r\nCARD16(fore_green);\r\nCARD16(fore_blue);\r\nCARD16(back_red);\r\nCARD16(back_green);\r\nCARD16(back_blue);\r\nbreak;\r\ncase X_QueryBestSize:\r\nENUM8(class);\r\nREQUEST_LENGTH();\r\nDRAWABLE(drawable);\r\nCARD16(width);\r\nCARD16(height);\r\nbreak;\r\ncase X_QueryExtension:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nv16 = FIELD16(name_length);\r\nUNUSED(2);\r\nSTRING8(name, v16);\r\nPAD();\r\nbreak;\r\ncase X_ListExtensions:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nbreak;\r\ncase X_ChangeKeyboardMapping:\r\nv8 = FIELD8(keycode_count);\r\nREQUEST_LENGTH();\r\nv8_2 = KEYCODE(first_keycode);\r\nv8_3 = FIELD8(keysyms_per_keycode);\r\nUNUSED(2);\r\nLISTofKEYSYM(keysyms, state->keycodemap, v8_2, v8, v8_3);\r\nbreak;\r\ncase X_GetKeyboardMapping:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nstate->request.GetKeyboardMapping.first_keycode\r\n= KEYCODE(first_keycode);\r\nFIELD8(count);\r\nUNUSED(2);\r\nbreak;\r\ncase X_ChangeKeyboardControl:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nBITMASK32(keyboard_value);\r\nBITFIELD(INT8, keyboard_value_mask, key_click_percent);\r\nBITFIELD(INT8, keyboard_value_mask, bell_percent);\r\nBITFIELD(INT16, keyboard_value_mask, bell_pitch);\r\nBITFIELD(INT16, keyboard_value_mask, bell_duration);\r\nBITFIELD(INT16, keyboard_value_mask, led);\r\nBITFIELD(ENUM8, keyboard_value_mask, led_mode);\r\nBITFIELD(KEYCODE, keyboard_value_mask, keyboard_key);\r\nBITFIELD(ENUM8, keyboard_value_mask, auto_repeat_mode);\r\nENDBITMASK;\r\nbreak;\r\ncase X_GetKeyboardControl:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nbreak;\r\ncase X_Bell:\r\nINT8(percent);\r\nREQUEST_LENGTH();\r\nbreak;\r\ncase X_ChangePointerControl:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nINT16(acceleration_numerator);\r\nINT16(acceleration_denominator);\r\nINT16(threshold);\r\nBOOL(do_acceleration);\r\nBOOL(do_threshold);\r\nbreak;\r\ncase X_GetPointerControl:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nbreak;\r\ncase X_SetScreenSaver:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nINT16(timeout);\r\nINT16(interval);\r\nENUM8(prefer_blanking);\r\nENUM8(allow_exposures);\r\nUNUSED(2);\r\nbreak;\r\ncase X_GetScreenSaver:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nbreak;\r\ncase X_ChangeHosts:\r\nENUM8(change_host_mode);\r\nREQUEST_LENGTH();\r\nv8 = ENUM8(family);\r\nUNUSED(1);\r\nv16 = CARD16(address_length);\r\nif (v8 == FAMILY_INTERNET && v16 == 4) {\r\nLISTofIPADDRESS(ip_address, v16);\r\n} else\r\nLISTofCARD8(address, v16);\r\nbreak;\r\ncase X_ListHosts:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nbreak;\r\ncase X_SetAccessControl:\r\nENUM8(access_mode);\r\nREQUEST_LENGTH();\r\nbreak;\r\ncase X_SetCloseDownMode:\r\nENUM8(close_down_mode);\r\nREQUEST_LENGTH();\r\nbreak;\r\ncase X_KillClient:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nCARD32(resource);\r\nbreak;\r\ncase X_RotateProperties:\r\nUNUSED(1);\r\nv16 = REQUEST_LENGTH();\r\nWINDOW(window);\r\nCARD16(property_number);\r\nINT16(delta);\r\nLISTofATOM(properties, (v16 - 12));\r\nbreak;\r\ncase X_ForceScreenSaver:\r\nENUM8(screen_saver_mode);\r\nREQUEST_LENGTH();\r\nbreak;\r\ncase X_SetPointerMapping:\r\nv8 = FIELD8(map_length);\r\nREQUEST_LENGTH();\r\nLISTofCARD8(map, v8);\r\nPAD();\r\nbreak;\r\ncase X_GetPointerMapping:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nbreak;\r\ncase X_SetModifierMapping:\r\nv8 = FIELD8(keycodes_per_modifier);\r\nREQUEST_LENGTH();\r\nLISTofKEYCODE(state->modifiermap, keycodes, v8);\r\nbreak;\r\ncase X_GetModifierMapping:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nbreak;\r\ncase X_NoOperation:\r\nUNUSED(1);\r\nREQUEST_LENGTH();\r\nbreak;\r\ndefault:\r\ntryExtension(opcode, tvb, pinfo, offsetp, t, state, byte_order);\r\nbreak;\r\n}\r\nif ((left = tvb_reported_length_remaining(tvb, offset)) > 0)\r\nUNDECODED(left);\r\n}\r\nstatic void dissect_x11_requests(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree)\r\n{\r\nvolatile int offset = 0;\r\nint length_remaining;\r\nvolatile guint byte_order;\r\nguint8 opcode;\r\nvolatile int plen;\r\nproto_item *ti;\r\nvolatile gboolean is_initial_creq;\r\nguint16 auth_proto_len, auth_data_len;\r\nconst char *volatile sep = NULL;\r\nconversation_t *conversation;\r\nx11_conv_data_t *volatile state;\r\nint length;\r\ntvbuff_t *volatile next_tvb;\r\nwhile ((length_remaining = tvb_reported_length_remaining(tvb, offset)) > 0) {\r\nif (x11_desegment && pinfo->can_desegment) {\r\nif (length_remaining < 4) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn;\r\n}\r\n}\r\nconversation = find_or_create_conversation(pinfo);\r\nif ((state = (x11_conv_data_t *)conversation_get_proto_data(conversation, proto_x11))\r\n== NULL)\r\nstate = x11_stateinit(conversation);\r\nbyte_order = guess_byte_ordering(tvb, pinfo, state);\r\nopcode = VALUE8(tvb, 0);\r\nplen = VALUE16(tvb, offset + 2);\r\nif (plen == 0) {\r\nti = proto_tree_add_item(tree, proto_x11, tvb, offset, -1, ENC_NA);\r\nexpert_add_info_format(pinfo, ti, &ei_x11_request_length, "Bogus request length (0)");\r\nreturn;\r\n}\r\nif (state->iconn_frame == pinfo->num ||\r\n(g_hash_table_lookup(state->seqtable,\r\nGINT_TO_POINTER(state->sequencenumber)) == (int *)NOTHING_SEEN &&\r\n(opcode == 'B' || opcode == 'l') &&\r\n(plen == 11 || plen == 2816))) {\r\nis_initial_creq = TRUE;\r\nif (state->byte_order == BYTE_ORDER_UNKNOWN) {\r\nif (opcode == 'B') {\r\nstate->byte_order = BYTE_ORDER_BE;\r\nbyte_order = ENC_BIG_ENDIAN;\r\n} else {\r\nstate->byte_order = BYTE_ORDER_LE;\r\nbyte_order = ENC_LITTLE_ENDIAN;\r\n}\r\n}\r\nif (x11_desegment && pinfo->can_desegment) {\r\nif (length_remaining < 10) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn;\r\n}\r\n}\r\nauth_proto_len = VALUE16(tvb, offset + 6);\r\nauth_data_len = VALUE16(tvb, offset + 8);\r\nplen = 12 + ROUND_LENGTH(auth_proto_len) +\r\nROUND_LENGTH(auth_data_len);\r\n} else {\r\nis_initial_creq = FALSE;\r\nplen *= 4;\r\n}\r\nif (x11_desegment && pinfo->can_desegment) {\r\nif (length_remaining < plen) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = plen - length_remaining;\r\nreturn;\r\n}\r\n}\r\nlength = length_remaining;\r\nif (length > plen)\r\nlength = plen;\r\nnext_tvb = tvb_new_subset(tvb, offset, length, plen);\r\nif (is_initial_creq) {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Initial connection request");\r\n} else {\r\nif (sep == NULL) {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Requests");\r\nsep = ":";\r\n}\r\n}\r\nTRY {\r\nif (is_initial_creq) {\r\ndissect_x11_initial_conn(next_tvb, pinfo, tree,\r\nstate, byte_order);\r\n} else {\r\ndissect_x11_request(next_tvb, pinfo, tree, sep,\r\nstate, byte_order);\r\n}\r\n}\r\nCATCH_NONFATAL_ERRORS {\r\nshow_exception(tvb, pinfo, tree, EXCEPT_CODE, GET_MESSAGE);\r\n}\r\nENDTRY;\r\noffset += plen;\r\nsep = ",";\r\n}\r\n}\r\nstatic x11_conv_data_t *\r\nx11_stateinit(conversation_t *conversation)\r\n{\r\nx11_conv_data_t *state;\r\nstatic x11_conv_data_t stateinit;\r\nint i;\r\nstate = (x11_conv_data_t *)g_malloc(sizeof (x11_conv_data_t));\r\n*state = stateinit;\r\nstate->next = x11_conv_data_list;\r\nx11_conv_data_list = state;\r\nfor (i = 0; opcode_vals[i].strptr != NULL; i++) {\r\nstate->opcode_vals[i].value = opcode_vals[i].value;\r\nstate->opcode_vals[i].strptr = opcode_vals[i].strptr;\r\n}\r\nfor (; i <= MAX_OPCODES; i++) {\r\nstate->opcode_vals[i].value = 0;\r\nstate->opcode_vals[i].strptr = NULL;\r\n}\r\nfor (i = 0; errorcode_vals[i].strptr != NULL; i++) {\r\nstate->errorcode_vals[i].value = errorcode_vals[i].value;\r\nstate->errorcode_vals[i].strptr = errorcode_vals[i].strptr;\r\n}\r\nfor (; i <= LastExtensionError + 1; i++) {\r\nstate->errorcode_vals[i].value = 0;\r\nstate->errorcode_vals[i].strptr = NULL;\r\n}\r\nfor (i = 0; eventcode_vals[i].strptr != NULL; i++) {\r\nstate->eventcode_vals[i].value = eventcode_vals[i].value;\r\nstate->eventcode_vals[i].strptr = eventcode_vals[i].strptr;\r\n}\r\nfor (; i <= LastExtensionEvent + 1; i++) {\r\nstate->eventcode_vals[i].value = 0;\r\nstate->eventcode_vals[i].strptr = NULL;\r\n}\r\nstate->eventcode_funcs = g_hash_table_new(g_direct_hash, g_direct_equal);\r\nstate->reply_funcs = g_hash_table_new(g_direct_hash, g_direct_equal);\r\nstate->seqtable = g_hash_table_new(g_direct_hash, g_direct_equal);\r\nstate->valtable = g_hash_table_new(g_direct_hash, g_direct_equal);\r\ng_hash_table_insert(state->seqtable, (int *)0, (int *)NOTHING_SEEN);\r\nstate->byte_order = BYTE_ORDER_UNKNOWN;\r\nconversation_add_proto_data(conversation, proto_x11, state);\r\nreturn state;\r\n}\r\nstatic void\r\ndissect_x11_replies(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nvolatile int offset, plen;\r\ntvbuff_t *volatile next_tvb;\r\nconversation_t *conversation;\r\nx11_conv_data_t *volatile state;\r\nvolatile guint byte_order;\r\nint length_remaining;\r\nconst char *volatile sep = NULL;\r\nconversation = find_or_create_conversation(pinfo);\r\nif ((state = (x11_conv_data_t *)conversation_get_proto_data(conversation, proto_x11))\r\n== NULL) {\r\nstate = x11_stateinit(conversation);\r\n}\r\nbyte_order = guess_byte_ordering(tvb, pinfo, state);\r\noffset = 0;\r\nwhile ((length_remaining = tvb_reported_length_remaining(tvb, offset)) > 0) {\r\nif (x11_desegment && pinfo->can_desegment) {\r\nif (length_remaining < 8) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn;\r\n}\r\n}\r\nif (g_hash_table_lookup(state->seqtable,\r\nGINT_TO_POINTER(state->sequencenumber)) == (int *)INITIAL_CONN\r\n|| (state->iconn_reply == pinfo->num)) {\r\nplen = 8 + VALUE16(tvb, offset + 6) * 4;\r\nHANDLE_REPLY(plen, length_remaining,\r\n"Initial connection reply",\r\ndissect_x11_initial_reply);\r\n} else {\r\nswitch (tvb_get_guint8(tvb, offset)) {\r\ncase 0:\r\nplen = 32;\r\nHANDLE_REPLY(plen, length_remaining,\r\n"Error", dissect_x11_error);\r\nbreak;\r\ncase 1:\r\n{\r\nint tmp_plen;\r\ntmp_plen = plen = 32 + VALUE32(tvb, offset + 4) * 4;\r\nTHROW_ON(tmp_plen < 32, ReportedBoundsError);\r\nHANDLE_REPLY(plen, length_remaining,\r\n"Reply", dissect_x11_reply);\r\nbreak;\r\n}\r\ndefault:\r\nplen = 32;\r\nHANDLE_REPLY(plen, length_remaining,\r\n"Event", dissect_x11_event);\r\nbreak;\r\n}\r\n}\r\noffset += plen;\r\n}\r\nreturn;\r\n}\r\nstatic void\r\ndissect_x11_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nconst char *sep, x11_conv_data_t *state,\r\nguint byte_order)\r\n{\r\nint offset = 0, *offsetp = &offset, length, left, opcode;\r\nint major_opcode, sequence_number, first_error, first_event;\r\nvalue_string *vals_p;\r\nproto_item *ti;\r\nproto_tree *t;\r\nti = proto_tree_add_item(tree, proto_x11, tvb, 0, -1, ENC_NA);\r\nt = proto_item_add_subtree(ti, ett_x11);\r\nsequence_number = VALUE16(tvb, offset + 2);\r\nopcode = GPOINTER_TO_INT(g_hash_table_lookup(state->seqtable,\r\nGINT_TO_POINTER(sequence_number)));\r\nif (state->iconn_frame == 0 && state->resync == FALSE) {\r\nstate->sequencenumber = sequence_number;\r\nstate->resync = TRUE;\r\n}\r\nif (opcode == UNKNOWN_OPCODE) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO,\r\n"%s to unknown request", sep);\r\nproto_item_append_text(ti, ", Reply to unknown request");\r\n} else {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s %s",\r\nsep,\r\nval_to_str(opcode & 0xFF, state->opcode_vals,\r\n"<Unknown opcode %d>"));\r\nif (opcode > 0xFF)\r\nproto_item_append_text(ti, ", Reply, opcode: %d.%d (%s)",\r\nopcode & 0xFF, opcode >> 8, val_to_str(opcode & 0xFF,\r\nstate->opcode_vals,\r\n"<Unknown opcode %d>"));\r\nelse\r\nproto_item_append_text(ti, ", Reply, opcode: %d (%s)",\r\nopcode, val_to_str(opcode,\r\nstate->opcode_vals,\r\n"<Unknown opcode %d>"));\r\n}\r\nswitch (opcode) {\r\ncase X_QueryExtension:\r\nif (!VALUE8(tvb, offset + 8)) {\r\nbreak;\r\n}\r\nvals_p = (value_string *)g_hash_table_lookup(state->valtable,\r\nGINT_TO_POINTER(sequence_number));\r\nif (vals_p != NULL) {\r\nmajor_opcode = VALUE8(tvb, offset + 9);\r\nfirst_event = VALUE8(tvb, offset + 10);\r\nfirst_error = VALUE8(tvb, offset + 11);\r\nregister_extension(state, vals_p, major_opcode, first_event, first_error);\r\ng_hash_table_remove(state->valtable,\r\nGINT_TO_POINTER(sequence_number));\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (tree == NULL)\r\nreturn;\r\nswitch (opcode) {\r\ncase X_GetWindowAttributes:\r\nREPLYCONTENTS_COMMON();\r\nbreak;\r\ncase X_GetGeometry:\r\nREPLY(reply);\r\nCARD8(depth);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nWINDOW(rootwindow);\r\nINT16(x);\r\nINT16(y);\r\nCARD16(width);\r\nCARD16(height);\r\nCARD16(border_width);\r\nUNUSED(10);\r\nbreak;\r\ncase X_QueryTree:\r\nREPLYCONTENTS_COMMON();\r\nbreak;\r\ncase X_InternAtom:\r\nREPLY(reply);\r\nUNUSED(1);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nATOM(atom);\r\nUNUSED(20);\r\nbreak;\r\ncase X_GetAtomName:\r\nREPLYCONTENTS_COMMON();\r\nbreak;\r\ncase X_GetProperty:\r\nREPLY(reply);\r\nCARD8(format);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nATOM(get_property_type);\r\nCARD32(bytes_after);\r\nCARD32(valuelength);\r\nUNUSED(12);\r\nbreak;\r\ncase X_ListProperties:\r\nREPLY(reply);\r\nUNUSED(1);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nlength = CARD16(property_number);\r\nUNUSED(22);\r\nLISTofATOM(properties, length*4);\r\nbreak;\r\ncase X_GetSelectionOwner:\r\nREPLY(reply);\r\nUNUSED(1);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nWINDOW(owner);\r\nUNUSED(20);\r\nbreak;\r\ncase X_GrabPointer:\r\ncase X_GrabKeyboard:\r\nREPLY(reply);\r\nENUM8(grab_status);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nUNUSED(24);\r\nbreak;\r\ncase X_QueryPointer:\r\nREPLY(reply);\r\nBOOL(same_screen);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nWINDOW(rootwindow);\r\nWINDOW(childwindow);\r\nINT16(root_x);\r\nINT16(root_y);\r\nINT16(win_x);\r\nINT16(win_y);\r\nSETofKEYBUTMASK(mask);\r\nUNUSED(6);\r\nbreak;\r\ncase X_GetMotionEvents:\r\nREPLYCONTENTS_COMMON();\r\nbreak;\r\ncase X_TranslateCoords:\r\nREPLY(reply);\r\nBOOL(same_screen);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nWINDOW(childwindow);\r\nINT16(dst_x);\r\nINT16(dst_y);\r\nUNUSED(16);\r\nbreak;\r\ncase X_GetInputFocus:\r\nREPLY(reply);\r\nENUM8(revert_to);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nWINDOW(focus);\r\nUNUSED(20);\r\nbreak;\r\ncase X_QueryKeymap:\r\nREPLY(reply);\r\nUNUSED(1);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nLISTofCARD8(keys, 32);\r\nbreak;\r\ncase X_QueryFont:\r\ncase X_QueryTextExtents:\r\ncase X_ListFonts:\r\ncase X_GetImage:\r\ncase X_ListInstalledColormaps:\r\nREPLYCONTENTS_COMMON();\r\nbreak;\r\ncase X_AllocColor:\r\nREPLY(reply);\r\nUNUSED(1);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nCARD16(red);\r\nCARD16(green);\r\nCARD16(blue);\r\nUNUSED(2);\r\nCARD32(pixel);\r\nUNUSED(12);\r\nbreak;\r\ncase X_QueryColors:\r\nREPLYCONTENTS_COMMON();\r\nbreak;\r\ncase X_LookupColor:\r\nREPLY(reply);\r\nUNUSED(1);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nCARD16(exact_red);\r\nCARD16(exact_green);\r\nCARD16(exact_blue);\r\nCARD16(visual_red);\r\nCARD16(visual_green);\r\nCARD16(visual_blue);\r\nUNUSED(12);\r\nbreak;\r\ncase X_QueryBestSize:\r\nREPLY(reply);\r\nUNUSED(1);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nCARD16(width);\r\nCARD16(height);\r\nUNUSED(20);\r\nbreak;\r\ncase X_QueryExtension:\r\nREPLY(reply);\r\nUNUSED(1);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nBOOL(present);\r\nCARD8(major_opcode);\r\nCARD8(first_event);\r\nCARD8(first_error);\r\nUNUSED(20);\r\nbreak;\r\ncase X_ListExtensions:\r\nREPLYCONTENTS_COMMON();\r\nbreak;\r\ncase X_GetKeyboardMapping:\r\nstate->first_keycode =\r\nstate->request.GetKeyboardMapping.first_keycode;\r\nREPLY(reply);\r\nstate->keysyms_per_keycode =\r\nFIELD8(keysyms_per_keycode);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nlength = REPLYLENGTH(replylength);\r\nUNUSED(24);\r\nLISTofKEYSYM(keysyms, state->keycodemap,\r\nstate->request.GetKeyboardMapping.first_keycode,\r\nstate->keysyms_per_keycode ? length / state->keysyms_per_keycode : 0,\r\nstate->keysyms_per_keycode);\r\nbreak;\r\ncase X_GetKeyboardControl:\r\nREPLYCONTENTS_COMMON();\r\nbreak;\r\ncase X_GetPointerControl:\r\nREPLY(reply);\r\nUNUSED(1);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nCARD16(acceleration_numerator);\r\nCARD16(acceleration_denominator);\r\nCARD16(threshold);\r\nUNUSED(18);\r\nbreak;\r\ncase X_GetScreenSaver:\r\nREPLY(reply);\r\nUNUSED(1);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nCARD16(timeout);\r\nCARD16(interval);\r\nENUM8(prefer_blanking);\r\nENUM8(allow_exposures);\r\nUNUSED(18);\r\nbreak;\r\ncase X_ListHosts:\r\ncase X_SetPointerMapping:\r\ncase X_GetPointerMapping:\r\ncase X_SetModifierMapping:\r\nREPLYCONTENTS_COMMON();\r\nbreak;\r\ncase X_GetModifierMapping:\r\nREPLY(reply);\r\nstate->keycodes_per_modifier =\r\nFIELD8(keycodes_per_modifier);\r\nSEQUENCENUMBER_REPLY(sequencenumber);\r\nREPLYLENGTH(replylength);\r\nUNUSED(24);\r\nLISTofKEYCODE(state->modifiermap, keycodes,\r\nstate->keycodes_per_modifier);\r\nbreak;\r\ncase UNKNOWN_OPCODE:\r\nREPLYCONTENTS_COMMON();\r\nbreak;\r\ndefault:\r\ntryExtensionReply(opcode, tvb, pinfo, offsetp, t, state, byte_order);\r\n}\r\nif ((left = tvb_reported_length_remaining(tvb, offset)) > 0)\r\nUNDECODED(left);\r\n}\r\nstatic void\r\nsame_screen_focus(tvbuff_t *tvb, int *offsetp, proto_tree *t)\r\n{\r\nproto_item *ti;\r\nguint32 bitmask_value;\r\nint bitmask_offset;\r\nint bitmask_size;\r\nproto_tree *bitmask_tree;\r\nbitmask_value = VALUE8(tvb, *offsetp);\r\nbitmask_offset = *offsetp;\r\nbitmask_size = 1;\r\nti = proto_tree_add_uint(t, hf_x11_same_screen_focus_mask, tvb, *offsetp, 1,\r\nbitmask_value);\r\nbitmask_tree = proto_item_add_subtree(ti, ett_x11_same_screen_focus);\r\nFLAG(same_screen_focus, focus);\r\nFLAG(same_screen_focus, same_screen);\r\n*offsetp += 1;\r\n}\r\nstatic void\r\ndissect_x11_event(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nconst char *sep, x11_conv_data_t *state,\r\nguint byte_order)\r\n{\r\nunsigned char eventcode;\r\nconst char *sent;\r\nproto_item *ti;\r\nproto_tree *t;\r\nti = proto_tree_add_item(tree, proto_x11, tvb, 0, -1, ENC_NA);\r\nt = proto_item_add_subtree(ti, ett_x11);\r\neventcode = tvb_get_guint8(tvb, 0);\r\nsent = (eventcode & 0x80) ? "Sent-" : "";\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s %s%s",\r\nsep, sent,\r\nval_to_str(eventcode & 0x7F, state->eventcode_vals,\r\n"<Unknown eventcode %u>"));\r\nproto_item_append_text(ti, ", Event, eventcode: %d (%s%s)",\r\neventcode, sent,\r\nval_to_str(eventcode & 0x7F, state->eventcode_vals,\r\n"<Unknown eventcode %u>"));\r\nif (tree == NULL)\r\nreturn;\r\ndecode_x11_event(tvb, eventcode, sent, t, state, byte_order);\r\nreturn;\r\n}\r\nstatic void\r\ndecode_x11_event(tvbuff_t *tvb, unsigned char eventcode, const char *sent,\r\nproto_tree *t, x11_conv_data_t *state,\r\nguint byte_order)\r\n{\r\nint offset = 0, *offsetp = &offset, left;\r\nproto_tree_add_uint_format(t, hf_x11_eventcode, tvb, offset, 1,\r\neventcode,\r\n"eventcode: %d (%s%s)",\r\neventcode, sent,\r\nval_to_str(eventcode & 0x7F, state->eventcode_vals,\r\n"<Unknown eventcode %u>"));\r\n++offset;\r\nswitch (eventcode & 0x7F) {\r\ncase KeyPress:\r\ncase KeyRelease: {\r\nint code, mask;\r\ncode = VALUE8(tvb, offset);\r\nmask = VALUE16(tvb, 28);\r\nKEYCODE_DECODED(keycode, code, mask);\r\nCARD16(event_sequencenumber);\r\nEVENTCONTENTS_COMMON();\r\nBOOL(same_screen);\r\nUNUSED(1);\r\nbreak;\r\n}\r\ncase ButtonPress:\r\ncase ButtonRelease:\r\nBUTTON(eventbutton);\r\nCARD16(event_sequencenumber);\r\nEVENTCONTENTS_COMMON();\r\nBOOL(same_screen);\r\nUNUSED(1);\r\nbreak;\r\ncase MotionNotify:\r\nCARD8(detail);\r\nCARD16(event_sequencenumber);\r\nEVENTCONTENTS_COMMON();\r\nBOOL(same_screen);\r\nUNUSED(1);\r\nbreak;\r\ncase EnterNotify:\r\ncase LeaveNotify:\r\nENUM8(event_detail);\r\nCARD16(event_sequencenumber);\r\nEVENTCONTENTS_COMMON();\r\nENUM8(grab_mode);\r\nsame_screen_focus(tvb, offsetp, t);\r\nbreak;\r\ncase FocusIn:\r\ncase FocusOut:\r\nENUM8(focus_detail);\r\nCARD16(event_sequencenumber);\r\nWINDOW(eventwindow);\r\nENUM8(focus_mode);\r\nUNUSED(23);\r\nbreak;\r\ncase KeymapNotify:\r\nbreak;\r\ncase Expose:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nWINDOW(eventwindow);\r\nINT16(x);\r\nINT16(y);\r\nCARD16(width);\r\nCARD16(height);\r\nCARD16(count);\r\nUNUSED(14);\r\nbreak;\r\ncase GraphicsExpose:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nDRAWABLE(drawable);\r\nCARD16(x);\r\nCARD16(y);\r\nCARD16(width);\r\nCARD16(height);\r\nCARD16(minor_opcode);\r\nCARD16(count);\r\nCARD8(major_opcode);\r\nUNUSED(11);\r\nbreak;\r\ncase NoExpose:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nDRAWABLE(drawable);\r\nCARD16(minor_opcode);\r\nCARD8(major_opcode);\r\nUNUSED(21);\r\nbreak;\r\ncase VisibilityNotify:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nWINDOW(eventwindow);\r\nENUM8(visibility_state);\r\nUNUSED(23);\r\nbreak;\r\ncase CreateNotify:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nWINDOW(parent);\r\nWINDOW(eventwindow);\r\nINT16(x);\r\nINT16(y);\r\nCARD16(width);\r\nCARD16(height);\r\nCARD16(border_width);\r\nBOOL(override_redirect);\r\nUNUSED(9);\r\nbreak;\r\ncase DestroyNotify:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nWINDOW(eventwindow);\r\nWINDOW(window);\r\nUNUSED(20);\r\nbreak;\r\ncase UnmapNotify:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nWINDOW(eventwindow);\r\nWINDOW(window);\r\nBOOL(from_configure);\r\nUNUSED(19);\r\nbreak;\r\ncase MapNotify:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nWINDOW(eventwindow);\r\nWINDOW(window);\r\nBOOL(override_redirect);\r\nUNUSED(19);\r\nbreak;\r\ncase MapRequest:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nWINDOW(parent);\r\nWINDOW(eventwindow);\r\nUNUSED(20);\r\nbreak;\r\ncase ReparentNotify:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nWINDOW(eventwindow);\r\nWINDOW(window);\r\nWINDOW(parent);\r\nINT16(x);\r\nINT16(y);\r\nBOOL(override_redirect);\r\nUNUSED(11);\r\nbreak;\r\ncase ConfigureNotify:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nWINDOW(eventwindow);\r\nWINDOW(window);\r\nWINDOW(above_sibling);\r\nINT16(x);\r\nINT16(y);\r\nCARD16(width);\r\nCARD16(height);\r\nCARD16(border_width);\r\nBOOL(override_redirect);\r\nUNUSED(5);\r\nbreak;\r\ncase ConfigureRequest:\r\nbreak;\r\ncase GravityNotify:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nWINDOW(eventwindow);\r\nWINDOW(window);\r\nINT16(x);\r\nINT16(y);\r\nUNUSED(16);\r\nbreak;\r\ncase ResizeRequest:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nWINDOW(eventwindow);\r\nCARD16(width);\r\nCARD16(height);\r\nUNUSED(20);\r\nbreak;\r\ncase CirculateNotify:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nWINDOW(eventwindow);\r\nWINDOW(window);\r\nUNUSED(4);\r\nENUM8(place);\r\nUNUSED(15);\r\nbreak;\r\ncase CirculateRequest:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nWINDOW(parent);\r\nWINDOW(eventwindow);\r\nUNUSED(4);\r\nENUM8(place);\r\nUNUSED(15);\r\nbreak;\r\ncase PropertyNotify:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nWINDOW(eventwindow);\r\nATOM(atom);\r\nTIMESTAMP(time);\r\nENUM8(property_state);\r\nUNUSED(15);\r\nbreak;\r\ncase SelectionClear:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nTIMESTAMP(time);\r\nWINDOW(owner);\r\nATOM(selection);\r\nUNUSED(16);\r\nbreak;\r\ncase SelectionRequest:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nTIMESTAMP(time);\r\nWINDOW(owner);\r\nWINDOW(requestor);\r\nATOM(selection);\r\nATOM(target);\r\nATOM(property);\r\nUNUSED(4);\r\nbreak;\r\ncase SelectionNotify:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nTIMESTAMP(time);\r\nWINDOW(requestor);\r\nATOM(selection);\r\nATOM(target);\r\nATOM(property);\r\nUNUSED(8);\r\nbreak;\r\ncase ColormapNotify:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nWINDOW(eventwindow);\r\nCOLORMAP(cmap);\r\nBOOL(new);\r\nENUM8(colormap_state);\r\nUNUSED(18);\r\nbreak;\r\ncase ClientMessage:\r\nCARD8(format);\r\nCARD16(event_sequencenumber);\r\nWINDOW(eventwindow);\r\nATOM(type);\r\nLISTofBYTE(data, 20);\r\nbreak;\r\ncase MappingNotify:\r\nUNUSED(1);\r\nCARD16(event_sequencenumber);\r\nENUM8(mapping_request);\r\nCARD8(first_keycode);\r\nCARD8(count);\r\nUNUSED(25);\r\nbreak;\r\ncase GenericEvent:\r\ntryGenericExtensionEvent(tvb, offsetp, t, state, byte_order);\r\nbreak;\r\ndefault:\r\ntryExtensionEvent(eventcode & 0x7F, tvb, offsetp, t, state, byte_order);\r\nbreak;\r\n}\r\nif ((left = tvb_reported_length_remaining(tvb, offset)) > 0)\r\nUNDECODED(left);\r\nreturn;\r\n}\r\nstatic void\r\ndissect_x11_error(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nconst char *sep, x11_conv_data_t *state _U_,\r\nguint byte_order)\r\n{\r\nint offset = 0, *offsetp = &offset, left;\r\nunsigned char errorcode;\r\nproto_item *ti;\r\nproto_tree *t;\r\nti = proto_tree_add_item(tree, proto_x11, tvb, 0, -1, ENC_NA);\r\nt = proto_item_add_subtree(ti, ett_x11);\r\nCARD8(error);\r\nerrorcode = tvb_get_guint8(tvb, offset);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s %s",\r\nsep, val_to_str(errorcode, state->errorcode_vals, "<Unknown errorcode %u>"));\r\nproto_tree_add_uint_format(t, hf_x11_errorcode, tvb, offset, 1,\r\nerrorcode,\r\n"errorcode: %d (%s)",\r\nerrorcode,\r\nval_to_str(errorcode, state->errorcode_vals,\r\n"<Unknown errorcode %u>"));\r\n++offset;\r\nproto_item_append_text(ti, ", Error, errorcode: %d (%s)",\r\nerrorcode, val_to_str(errorcode, state->errorcode_vals,\r\n"<Unknown errorcode %u>"));\r\nif (tree == NULL)\r\nreturn;\r\nCARD16(error_sequencenumber);\r\nswitch (errorcode) {\r\ncase BadValue:\r\nCARD32(error_badvalue);\r\nbreak;\r\ncase BadWindow:\r\ncase BadPixmap:\r\ncase BadCursor:\r\ncase BadFont:\r\ncase BadDrawable:\r\ncase BadColormap:\r\ncase BadGC:\r\ncase BadIDChoice:\r\nCARD32(error_badresourceid);\r\nbreak;\r\ndefault:\r\nUNDECODED(4);\r\n}\r\nCARD16(minor_opcode);\r\nCARD8(major_opcode);\r\nif ((left = tvb_reported_length_remaining(tvb, offset)) > 0)\r\nUNDECODED(left);\r\n}\r\nstatic int\r\ndissect_x11(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "X11");\r\nif (pinfo->match_uint == pinfo->srcport)\r\ndissect_x11_replies(tvb, pinfo, tree);\r\nelse\r\ndissect_x11_requests(tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_x11(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n#include "x11-register-info.h"\r\n};\r\nstatic gint *ett[] = {\r\n&ett_x11,\r\n&ett_x11_color_flags,\r\n&ett_x11_list_of_arc,\r\n&ett_x11_arc,\r\n&ett_x11_list_of_atom,\r\n&ett_x11_list_of_card32,\r\n&ett_x11_list_of_float,\r\n&ett_x11_list_of_double,\r\n&ett_x11_list_of_color_item,\r\n&ett_x11_color_item,\r\n&ett_x11_list_of_keycode,\r\n&ett_x11_list_of_keysyms,\r\n&ett_x11_keysym,\r\n&ett_x11_list_of_point,\r\n&ett_x11_point,\r\n&ett_x11_list_of_rectangle,\r\n&ett_x11_rectangle,\r\n&ett_x11_list_of_segment,\r\n&ett_x11_segment,\r\n&ett_x11_list_of_string8,\r\n&ett_x11_list_of_text_item,\r\n&ett_x11_text_item,\r\n&ett_x11_gc_value_mask,\r\n&ett_x11_event_mask,\r\n&ett_x11_do_not_propagate_mask,\r\n&ett_x11_set_of_key_mask,\r\n&ett_x11_pointer_event_mask,\r\n&ett_x11_window_value_mask,\r\n&ett_x11_configure_window_mask,\r\n&ett_x11_keyboard_value_mask,\r\n&ett_x11_same_screen_focus,\r\n&ett_x11_event,\r\n&ett_x11_list_of_pixmap_format,\r\n&ett_x11_pixmap_format,\r\n&ett_x11_list_of_screen,\r\n&ett_x11_screen,\r\n&ett_x11_list_of_depth_detail,\r\n&ett_x11_depth_detail,\r\n&ett_x11_list_of_visualtype,\r\n&ett_x11_visualtype,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_x11_invalid_format, { "x11.invalid_format", PI_PROTOCOL, PI_WARN, "Invalid Format", EXPFILL }},\r\n{ &ei_x11_request_length, { "x11.request-length.invalid", PI_PROTOCOL, PI_WARN, "Invalid Length", EXPFILL }},\r\n{ &ei_x11_keycode_value_out_of_range, { "x11.keycode_value_out_of_range", PI_PROTOCOL, PI_WARN, "keycode value is out of range", EXPFILL }},\r\n};\r\nmodule_t *x11_module;\r\nexpert_module_t* expert_x11;\r\nproto_x11 = proto_register_protocol("X11", "X11", "x11");\r\nproto_register_field_array(proto_x11, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_x11 = expert_register_protocol(proto_x11);\r\nexpert_register_field_array(expert_x11, ei, array_length(ei));\r\nregister_cleanup_routine(x11_cleanup);\r\nextension_table = g_hash_table_new(g_str_hash, g_str_equal);\r\nerror_table = g_hash_table_new(g_str_hash, g_str_equal);\r\nevent_table = g_hash_table_new(g_str_hash, g_str_equal);\r\ngenevent_table = g_hash_table_new(g_str_hash, g_str_equal);\r\nreply_table = g_hash_table_new(g_str_hash, g_str_equal);\r\nregister_x11_extensions();\r\nrange_convert_str(&global_x11_tcp_port_range, DEFAULT_X11_PORT_RANGE, MAX_TCP_PORT);\r\nx11_module = prefs_register_protocol(proto_x11, NULL);\r\nprefs_register_bool_preference(x11_module, "desegment",\r\n"Reassemble X11 messages spanning multiple TCP segments",\r\n"Whether the X11 dissector should reassemble messages spanning multiple TCP segments. "\r\n"To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&x11_desegment);\r\nprefs_register_range_preference(x11_module, "tcp.ports", "X11 TCP ports",\r\n"TCP ports to be decoded as X11 (default: "\r\nDEFAULT_X11_PORT_RANGE ")",\r\n&global_x11_tcp_port_range, MAX_TCP_PORT);\r\n}\r\nvoid\r\nproto_reg_handoff_x11(void)\r\n{\r\nstatic gboolean initialized = FALSE;\r\nstatic range_t *x11_tcp_port_range;\r\nstatic dissector_handle_t x11_handle = NULL;\r\nif (!initialized)\r\n{\r\nx11_handle = create_dissector_handle(dissect_x11, proto_x11);\r\ninitialized = TRUE;\r\n}\r\nelse\r\n{\r\ndissector_delete_uint_range("tcp.port", x11_tcp_port_range, x11_handle);\r\ng_free(x11_tcp_port_range);\r\n}\r\nx11_tcp_port_range = range_copy(global_x11_tcp_port_range);\r\ndissector_add_uint_range("tcp.port", x11_tcp_port_range, x11_handle);\r\n}
