extern gchar*\r\nstats_tree_node_to_str(const stat_node *node, gchar *buffer, guint len)\r\n{\r\nif (buffer) {\r\ng_snprintf(buffer,len,"%s: %i",node->name, node->counter);\r\nreturn buffer;\r\n} else {\r\nreturn g_strdup_printf("%s: %i",node->name, node->counter);\r\n}\r\n}\r\nextern guint\r\nstats_tree_branch_max_namelen(const stat_node *node, guint indent)\r\n{\r\nstat_node *child;\r\nguint maxlen = 0;\r\nguint len;\r\nindent = indent > INDENT_MAX ? INDENT_MAX : indent;\r\nif (node->children) {\r\nfor (child = node->children; child; child = child->next ) {\r\nlen = stats_tree_branch_max_namelen(child,indent+1);\r\nmaxlen = len > maxlen ? len : maxlen;\r\n}\r\n}\r\nif (node->st_flags&ST_FLG_ROOTCHILD) {\r\ngchar *display_name= stats_tree_get_displayname(node->name);\r\nlen = (guint) strlen(display_name) + indent;\r\ng_free(display_name);\r\n}\r\nelse {\r\nlen = (guint) strlen(node->name) + indent;\r\n}\r\nmaxlen = len > maxlen ? len : maxlen;\r\nreturn maxlen;\r\n}\r\nstatic void\r\nfree_stat_node(stat_node *node)\r\n{\r\nstat_node *child;\r\nstat_node *next;\r\nburst_bucket *bucket;\r\nif (node->children) {\r\nfor (child = node->children; child; child = next ) {\r\nnext = child->next;\r\nfree_stat_node(child);\r\n}\r\n}\r\nif (node->hash) g_hash_table_destroy(node->hash);\r\nwhile (node->bh) {\r\nbucket = node->bh;\r\nnode->bh = bucket->next;\r\ng_free(bucket);\r\n}\r\ng_free(node->rng);\r\ng_free(node->name);\r\ng_free(node);\r\n}\r\nextern void\r\nstats_tree_free(stats_tree *st)\r\n{\r\nstat_node *child;\r\nstat_node *next;\r\nif (!st) return;\r\ng_free(st->filter);\r\ng_hash_table_destroy(st->names);\r\ng_ptr_array_free(st->parents,TRUE);\r\ng_free(st->display_name);\r\nfor (child = st->root.children; child; child = next ) {\r\nnext = child->next;\r\nfree_stat_node(child);\r\n}\r\nif (st->cfg->free_tree_pr)\r\nst->cfg->free_tree_pr(st);\r\nif (st->cfg->cleanup)\r\nst->cfg->cleanup(st);\r\ng_free(st);\r\n}\r\nstatic void\r\nreset_stat_node(stat_node *node)\r\n{\r\nstat_node *child;\r\nburst_bucket *bucket;\r\nnode->counter = 0;\r\nnode->total = 0;\r\nnode->minvalue = G_MAXINT;\r\nnode->maxvalue = G_MININT;\r\nnode->st_flags = 0;\r\nwhile (node->bh) {\r\nbucket = node->bh;\r\nnode->bh = bucket->next;\r\ng_free(bucket);\r\n}\r\nnode->bh = (burst_bucket*)g_malloc0(sizeof(burst_bucket));\r\nnode->bt = node->bh;\r\nnode->bcount = 0;\r\nnode->max_burst = 0;\r\nnode->burst_time = -1.0;\r\nif (node->children) {\r\nfor (child = node->children; child; child = child->next )\r\nreset_stat_node(child);\r\n}\r\n}\r\nextern void\r\nstats_tree_reset(void *p)\r\n{\r\nstats_tree *st = (stats_tree *)p;\r\nst->start = -1.0;\r\nst->elapsed = 0.0;\r\nst->now = - 1.0;\r\nreset_stat_node(&st->root);\r\n}\r\nextern void\r\nstats_tree_reinit(void *p)\r\n{\r\nstats_tree *st = (stats_tree *)p;\r\nstat_node *child;\r\nstat_node *next;\r\nfor (child = st->root.children; child; child = next) {\r\nnext = child->next;\r\nfree_stat_node(child);\r\n}\r\nst->root.children = NULL;\r\nst->root.counter = 0;\r\nst->root.total = 0;\r\nst->root.minvalue = G_MAXINT;\r\nst->root.maxvalue = G_MININT;\r\nst->root.st_flags = 0;\r\nst->root.bh = (burst_bucket*)g_malloc0(sizeof(burst_bucket));\r\nst->root.bt = st->root.bh;\r\nst->root.bcount = 0;\r\nst->root.max_burst = 0;\r\nst->root.burst_time = -1.0;\r\ng_hash_table_remove_all(st->names);\r\nif (st->parents->len>1) {\r\ng_ptr_array_remove_range(st->parents, 1, st->parents->len-1);\r\n}\r\nst->num_columns = N_COLUMNS;\r\ng_free(st->display_name);\r\nst->display_name= stats_tree_get_displayname(st->cfg->name);\r\nif (st->cfg->init) {\r\nst->cfg->init(st);\r\n}\r\n}\r\nextern void\r\nstats_tree_register_with_group(const char *tapname, const char *abbr, const char *name,\r\nguint flags,\r\nstat_tree_packet_cb packet, stat_tree_init_cb init,\r\nstat_tree_cleanup_cb cleanup, register_stat_group_t stat_group)\r\n{\r\nstats_tree_cfg *cfg = (stats_tree_cfg *)g_malloc0( sizeof(stats_tree_cfg) );\r\ng_assert( tapname && abbr && packet );\r\ncfg->tapname = g_strdup(tapname);\r\ncfg->abbr = g_strdup(abbr);\r\ncfg->name = name ? g_strdup(name) : g_strdup(abbr);\r\ncfg->stat_group = stat_group;\r\ncfg->packet = packet;\r\ncfg->init = init;\r\ncfg->cleanup = cleanup;\r\ncfg->flags = flags&~ST_FLG_MASK;\r\ncfg->st_flags = flags&ST_FLG_MASK;\r\nif (!registry) registry = g_hash_table_new(g_str_hash,g_str_equal);\r\ng_hash_table_insert(registry,cfg->abbr,cfg);\r\n}\r\nextern void\r\nstats_tree_register(const char *tapname, const char *abbr, const char *name,\r\nguint flags,\r\nstat_tree_packet_cb packet, stat_tree_init_cb init,\r\nstat_tree_cleanup_cb cleanup)\r\n{\r\nstats_tree_register_with_group(tapname, abbr, name,\r\nflags,\r\npacket, init,\r\ncleanup, REGISTER_STAT_GROUP_UNSORTED);\r\n}\r\nextern void\r\nstats_tree_register_plugin(const char *tapname, const char *abbr, const char *name,\r\nguint flags,\r\nstat_tree_packet_cb packet, stat_tree_init_cb init,\r\nstat_tree_cleanup_cb cleanup)\r\n{\r\nstats_tree_cfg *cfg;\r\nstats_tree_register(tapname, abbr, name,\r\nflags,\r\npacket, init,\r\ncleanup);\r\ncfg = stats_tree_get_cfg_by_abbr(abbr);\r\ncfg->plugin = TRUE;\r\n}\r\nextern stats_tree*\r\nstats_tree_new(stats_tree_cfg *cfg, tree_pres *pr, const char *filter)\r\n{\r\nstats_tree *st = (stats_tree *)g_malloc0(sizeof(stats_tree));\r\nst->cfg = cfg;\r\nst->pr = pr;\r\nst->names = g_hash_table_new(g_str_hash,g_str_equal);\r\nst->parents = g_ptr_array_new();\r\nst->filter = g_strdup(filter);\r\nst->start = -1.0;\r\nst->elapsed = 0.0;\r\nst->root.minvalue = G_MAXINT;\r\nst->root.maxvalue = G_MININT;\r\nst->root.bh = (burst_bucket*)g_malloc0(sizeof(burst_bucket));\r\nst->root.bt = st->root.bh;\r\nst->root.burst_time = -1.0;\r\nst->root.name = stats_tree_get_displayname(cfg->name);\r\nst->root.st = st;\r\nst->st_flags = st->cfg->st_flags;\r\nif (!(st->st_flags&ST_FLG_SRTCOL_MASK)) {\r\nst->st_flags |= prefs.st_sort_defcolflag<<ST_FLG_SRTCOL_SHIFT;\r\nif (prefs.st_sort_defdescending) {\r\nst->st_flags |= ST_FLG_SORT_DESC;\r\n}\r\n}\r\nst->num_columns = N_COLUMNS;\r\nst->display_name= stats_tree_get_displayname(st->cfg->name);\r\ng_ptr_array_add(st->parents,&st->root);\r\nreturn st;\r\n}\r\nextern int\r\nstats_tree_packet(void *p, packet_info *pinfo, epan_dissect_t *edt, const void *pri)\r\n{\r\nstats_tree *st = (stats_tree *)p;\r\nst->now = nstime_to_msec(&pinfo->rel_ts);\r\nif (st->start < 0.0) st->start = st->now;\r\nst->elapsed = st->now - st->start;\r\nif (st->cfg->packet)\r\nreturn st->cfg->packet(st,pinfo,edt,pri);\r\nelse\r\nreturn 0;\r\n}\r\nextern stats_tree_cfg*\r\nstats_tree_get_cfg_by_abbr(const char *abbr)\r\n{\r\nif (!abbr) return NULL;\r\nreturn (stats_tree_cfg *)g_hash_table_lookup(registry,abbr);\r\n}\r\nstatic gint\r\ncompare_stat_menu_item(gconstpointer stat_a, gconstpointer stat_b)\r\n{\r\nconst stats_tree_cfg* stat_cfg_a = (const stats_tree_cfg*)stat_a;\r\nconst stats_tree_cfg* stat_cfg_b = (const stats_tree_cfg*)stat_b;\r\nreturn strcmp(stat_cfg_a->name, stat_cfg_b->name);\r\n}\r\nextern GList*\r\nstats_tree_get_cfg_list(void)\r\n{\r\nGList* registry_list = g_hash_table_get_values(registry);\r\nreturn g_list_sort(registry_list, compare_stat_menu_item);\r\n}\r\nstatic void\r\nsetup_tree_presentation(gpointer k _U_, gpointer v, gpointer p)\r\n{\r\nstats_tree_cfg *cfg = (stats_tree_cfg *)v;\r\nstruct _stats_tree_pres_cbs *d = (struct _stats_tree_pres_cbs *)p;\r\ncfg->in_use = FALSE;\r\ncfg->setup_node_pr = d->setup_node_pr;\r\ncfg->free_tree_pr = d->free_tree_pr;\r\n}\r\nextern void\r\nstats_tree_presentation(void (*registry_iterator)(gpointer,gpointer,gpointer),\r\nvoid (*setup_node_pr)(stat_node*),\r\nvoid (*free_tree_pr)(stats_tree*),\r\nvoid *data)\r\n{\r\nstatic struct _stats_tree_pres_cbs d;\r\nd.setup_node_pr = setup_node_pr;\r\nd.free_tree_pr = free_tree_pr;\r\nif (registry) g_hash_table_foreach(registry,setup_tree_presentation,&d);\r\nif (registry_iterator && registry)\r\ng_hash_table_foreach(registry,registry_iterator,data);\r\n}\r\nstatic stat_node*\r\nnew_stat_node(stats_tree *st, const gchar *name, int parent_id,\r\ngboolean with_hash, gboolean as_parent_node)\r\n{\r\nstat_node *node = (stat_node *)g_malloc0(sizeof(stat_node));\r\nstat_node *last_chld = NULL;\r\nnode->minvalue = G_MAXINT;\r\nnode->maxvalue = G_MININT;\r\nnode->st_flags = parent_id?0:ST_FLG_ROOTCHILD;\r\nnode->bh = (burst_bucket*)g_malloc0(sizeof(burst_bucket));\r\nnode->bt = node->bh;\r\nnode->burst_time = -1.0;\r\nnode->name = g_strdup(name);\r\nnode->st = (stats_tree*) st;\r\nnode->hash = with_hash ? g_hash_table_new(g_str_hash,g_str_equal) : NULL;\r\nif (as_parent_node) {\r\ng_hash_table_insert(st->names,\r\nnode->name,\r\nnode);\r\ng_ptr_array_add(st->parents,node);\r\nnode->id = st->parents->len - 1;\r\n} else {\r\nnode->id = -1;\r\n}\r\nif (parent_id >= 0 && parent_id < (int) st->parents->len ) {\r\nnode->parent = (stat_node *)g_ptr_array_index(st->parents,parent_id);\r\n} else {\r\ng_assert_not_reached();\r\n}\r\nif (node->parent->children) {\r\nfor (last_chld = node->parent->children;\r\nlast_chld->next;\r\nlast_chld = last_chld->next ) ;\r\nlast_chld->next = node;\r\n} else {\r\nnode->parent->children = node;\r\n}\r\nif(node->parent->hash) {\r\ng_hash_table_insert(node->parent->hash,node->name,node);\r\n}\r\nif (st->cfg->setup_node_pr) {\r\nst->cfg->setup_node_pr(node);\r\n} else {\r\nnode->pr = NULL;\r\n}\r\nreturn node;\r\n}\r\nextern int\r\nstats_tree_create_node(stats_tree *st, const gchar *name, int parent_id, gboolean with_hash)\r\n{\r\nstat_node *node = new_stat_node(st,name,parent_id,with_hash,TRUE);\r\nif (node)\r\nreturn node->id;\r\nelse\r\nreturn 0;\r\n}\r\nextern int\r\nstats_tree_create_node_by_pname(stats_tree *st, const gchar *name,\r\nconst gchar *parent_name, gboolean with_children)\r\n{\r\nreturn stats_tree_create_node(st,name,stats_tree_parent_id_by_name(st,parent_name),with_children);\r\n}\r\nstatic void\r\nupdate_burst_calc(stat_node *node, gint value)\r\n{\r\ndouble current_bucket;\r\ndouble burstwin;\r\nburst_bucket *bn;\r\nif (!prefs.st_enable_burstinfo) {\r\nreturn;\r\n}\r\ncurrent_bucket= floor(node->st->now/prefs.st_burst_resolution);\r\nburstwin= prefs.st_burst_windowlen/prefs.st_burst_resolution;\r\nif (current_bucket>node->bt->bucket_no) {\r\nbn = (burst_bucket*)g_malloc0(sizeof(burst_bucket));\r\nbn->count = value;\r\nbn->bucket_no = current_bucket;\r\nbn->start_time = node->st->now;\r\nbn->prev = node->bt;\r\nnode->bt->next = bn;\r\nnode->bt = bn;\r\nnode->bcount += value;\r\nwhile (current_bucket>=(node->bh->bucket_no+burstwin)) {\r\nbn = node->bh;\r\nnode->bh = bn->next;\r\nnode->bh->prev = NULL;\r\nnode->bcount -= bn->count;\r\ng_free(bn);\r\n}\r\n}\r\nelse if (current_bucket<node->bh->bucket_no) {\r\nif ((current_bucket+burstwin)>node->bt->bucket_no) {\r\nbn = (burst_bucket*)g_malloc0(sizeof(burst_bucket));\r\nbn->count = value;\r\nbn->bucket_no = current_bucket;\r\nbn->start_time = node->st->now;\r\nbn->next = node->bh;\r\nnode->bh->prev = bn;\r\nnode->bh = bn;\r\nnode->bcount += value;\r\n}\r\n}\r\nelse\r\n{\r\nburst_bucket *search = node->bt;\r\nwhile (current_bucket<search->bucket_no) {\r\nsearch = search->prev;\r\n}\r\nif (current_bucket==search->bucket_no) {\r\nsearch->count += value;\r\nif (search->start_time>node->st->now) {\r\nsearch->start_time = node->st->now;\r\n}\r\n}\r\nelse {\r\nbn = (burst_bucket*)g_malloc0(sizeof(burst_bucket));\r\nbn->count = value;\r\nbn->bucket_no = current_bucket;\r\nbn->start_time = node->st->now;\r\nbn->prev = search;\r\nbn->next = search->next;\r\nsearch->next = bn;\r\nbn->next->prev = bn;\r\n}\r\nnode->bcount += value;\r\n}\r\nif (node->bcount>node->max_burst) {\r\nnode->max_burst = node->bcount;\r\nnode->burst_time = node->bh->start_time;\r\n}\r\n}\r\nextern int\r\nstats_tree_manip_node(manip_node_mode mode, stats_tree *st, const char *name,\r\nint parent_id, gboolean with_hash, gint value)\r\n{\r\nstat_node *node = NULL;\r\nstat_node *parent = NULL;\r\ng_assert( parent_id >= 0 && parent_id < (int) st->parents->len );\r\nparent = (stat_node *)g_ptr_array_index(st->parents,parent_id);\r\nif( parent->hash ) {\r\nnode = (stat_node *)g_hash_table_lookup(parent->hash,name);\r\n} else {\r\nnode = (stat_node *)g_hash_table_lookup(st->names,name);\r\n}\r\nif ( node == NULL )\r\nnode = new_stat_node(st,name,parent_id,with_hash,with_hash);\r\nswitch (mode) {\r\ncase MN_INCREASE:\r\nnode->counter += value;\r\nupdate_burst_calc(node, value);\r\nbreak;\r\ncase MN_SET: node->counter = value; break;\r\ncase MN_AVERAGE:\r\nnode->counter++;\r\nupdate_burst_calc(node, 1);\r\ncase MN_AVERAGE_NOTICK:\r\nnode->total += value;\r\nif (node->minvalue > value) {\r\nnode->minvalue = value;\r\n}\r\nif (node->maxvalue < value) {\r\nnode->maxvalue = value;\r\n}\r\nnode->st_flags |= ST_FLG_AVERAGE;\r\nbreak;\r\ncase MN_SET_FLAGS:\r\nnode->st_flags |= value;\r\nbreak;\r\ncase MN_CLEAR_FLAGS:\r\nnode->st_flags &= ~value;\r\nbreak;\r\n}\r\nif (node)\r\nreturn node->id;\r\nelse\r\nreturn -1;\r\n}\r\nextern char*\r\nstats_tree_get_abbr(const char *opt_arg)\r\n{\r\nguint i;\r\ng_assert(opt_arg != NULL);\r\nfor (i=0; opt_arg[i] && opt_arg[i] != ','; i++);\r\nif (opt_arg[i] == ',') {\r\nreturn g_strndup(opt_arg,i);\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nstatic range_pair_t*\r\nget_range(char *rngstr)\r\n{\r\ngchar **split;\r\nrange_pair_t *rng;\r\nsplit = g_strsplit((gchar*)rngstr,"-",2);\r\nif (split[0] == NULL) {\r\ng_strfreev(split);\r\nreturn NULL;\r\n}\r\nrng = (range_pair_t *)g_malloc(sizeof(range_pair_t));\r\nif (split[1] == NULL) {\r\nrng->floor = (gint)strtol(split[0],NULL,10);\r\nrng->ceil = rng->floor;\r\n} else {\r\nif (*(split[0]) != '\0') {\r\nrng->floor = (gint)strtol(split[0],NULL,10);\r\n} else {\r\nrng->floor = G_MININT;\r\n}\r\nif (*(split[1]) != '\0') {\r\nrng->ceil = (gint)strtol(split[1],NULL,10);\r\n} else {\r\nrng->ceil = G_MAXINT;\r\n}\r\n}\r\ng_strfreev(split);\r\nreturn rng;\r\n}\r\nextern int\r\nstats_tree_create_range_node(stats_tree *st, const gchar *name, int parent_id, ...)\r\n{\r\nva_list list;\r\ngchar *curr_range;\r\nstat_node *rng_root = new_stat_node(st, name, parent_id, FALSE, TRUE);\r\nstat_node *range_node = NULL;\r\nva_start( list, parent_id );\r\nwhile (( curr_range = va_arg(list, gchar*) )) {\r\nrange_node = new_stat_node(st, curr_range, rng_root->id, FALSE, FALSE);\r\nrange_node->rng = get_range(curr_range);\r\n}\r\nva_end( list );\r\nreturn rng_root->id;\r\n}\r\nextern int\r\nstats_tree_create_range_node_string(stats_tree *st, const gchar *name,\r\nint parent_id, int num_str_ranges,\r\ngchar** str_ranges)\r\n{\r\nint i;\r\nstat_node *rng_root = new_stat_node(st, name, parent_id, FALSE, TRUE);\r\nstat_node *range_node = NULL;\r\nfor (i = 0; i < num_str_ranges; i++) {\r\nrange_node = new_stat_node(st, str_ranges[i], rng_root->id, FALSE, FALSE);\r\nrange_node->rng = get_range(str_ranges[i]);\r\n}\r\nreturn rng_root->id;\r\n}\r\nextern int\r\nstats_tree_parent_id_by_name(stats_tree *st, const gchar *parent_name)\r\n{\r\nstat_node *node = (stat_node *)g_hash_table_lookup(st->names,parent_name);\r\nif (node)\r\nreturn node->id;\r\nelse\r\nreturn 0;\r\n}\r\nextern int\r\nstats_tree_range_node_with_pname(stats_tree *st, const gchar *name,\r\nconst gchar *parent_name, ...)\r\n{\r\nva_list list;\r\ngchar *curr_range;\r\nstat_node *range_node = NULL;\r\nint parent_id = stats_tree_parent_id_by_name(st,parent_name);\r\nstat_node *rng_root = new_stat_node(st, name, parent_id, FALSE, TRUE);\r\nva_start( list, parent_name );\r\nwhile (( curr_range = va_arg(list, gchar*) )) {\r\nrange_node = new_stat_node(st, curr_range, rng_root->id, FALSE, FALSE);\r\nrange_node->rng = get_range(curr_range);\r\n}\r\nva_end( list );\r\nreturn rng_root->id;\r\n}\r\nextern int\r\nstats_tree_tick_range(stats_tree *st, const gchar *name, int parent_id,\r\nint value_in_range)\r\n{\r\nstat_node *node = NULL;\r\nstat_node *parent = NULL;\r\nstat_node *child = NULL;\r\ngint stat_floor, stat_ceil;\r\nif (parent_id >= 0 && parent_id < (int) st->parents->len) {\r\nparent = (stat_node *)g_ptr_array_index(st->parents,parent_id);\r\n} else {\r\ng_assert_not_reached();\r\n}\r\nif( parent->hash ) {\r\nnode = (stat_node *)g_hash_table_lookup(parent->hash,name);\r\n} else {\r\nnode = (stat_node *)g_hash_table_lookup(st->names,name);\r\n}\r\nif ( node == NULL )\r\ng_assert_not_reached();\r\nnode->total += value_in_range;\r\nif (node->minvalue > value_in_range) {\r\nnode->minvalue = value_in_range;\r\n}\r\nif (node->maxvalue < value_in_range) {\r\nnode->maxvalue = value_in_range;\r\n}\r\nnode->st_flags |= ST_FLG_AVERAGE;\r\nfor ( child = node->children; child; child = child->next) {\r\nstat_floor = child->rng->floor;\r\nstat_ceil = child->rng->ceil;\r\nif ( value_in_range >= stat_floor && value_in_range <= stat_ceil ) {\r\nchild->counter++;\r\nchild->total += value_in_range;\r\nif (child->minvalue > value_in_range) {\r\nchild->minvalue = value_in_range;\r\n}\r\nif (child->maxvalue < value_in_range) {\r\nchild->maxvalue = value_in_range;\r\n}\r\nchild->st_flags |= ST_FLG_AVERAGE;\r\nupdate_burst_calc(child, 1);\r\nreturn node->id;\r\n}\r\n}\r\nreturn node->id;\r\n}\r\nextern int\r\nstats_tree_create_pivot(stats_tree *st, const gchar *name, int parent_id)\r\n{\r\nstat_node *node = new_stat_node(st,name,parent_id,TRUE,TRUE);\r\nif (node)\r\nreturn node->id;\r\nelse\r\nreturn 0;\r\n}\r\nextern int\r\nstats_tree_create_pivot_by_pname(stats_tree *st, const gchar *name,\r\nconst gchar *parent_name)\r\n{\r\nint parent_id = stats_tree_parent_id_by_name(st,parent_name);\r\nstat_node *node;\r\nnode = new_stat_node(st,name,parent_id,TRUE,TRUE);\r\nif (node)\r\nreturn node->id;\r\nelse\r\nreturn 0;\r\n}\r\nextern int\r\nstats_tree_tick_pivot(stats_tree *st, int pivot_id, const gchar *pivot_value)\r\n{\r\nstat_node *parent = (stat_node *)g_ptr_array_index(st->parents,pivot_id);\r\nparent->counter++;\r\nupdate_burst_calc(parent, 1);\r\nstats_tree_manip_node( MN_INCREASE, st, pivot_value, pivot_id, FALSE, 1);\r\nreturn pivot_id;\r\n}\r\nextern gchar*\r\nstats_tree_get_displayname (gchar* fullname)\r\n{\r\ngchar *buf = g_strdup(fullname);\r\ngchar *sep;\r\nif (prefs.st_sort_showfullname) {\r\nreturn buf;\r\n}\r\nsep = buf;\r\nwhile ((sep = strchr(sep,'/')) != NULL) {\r\nif (*(++sep)=='/') {\r\nmemmove(sep,sep+1,strlen(sep));\r\n}\r\nelse {\r\nmemmove(buf,sep,strlen(sep)+1);\r\nsep = buf;\r\n}\r\n}\r\nreturn buf;\r\n}\r\nextern gint\r\nstats_tree_get_default_sort_col (stats_tree *st)\r\n{\r\nswitch ((st->st_flags&ST_FLG_SRTCOL_MASK)>>ST_FLG_SRTCOL_SHIFT) {\r\ncase ST_SORT_COL_NAME:\r\nreturn COL_NAME;\r\ncase ST_SORT_COL_COUNT:\r\nreturn COL_COUNT;\r\ncase ST_SORT_COL_AVG:\r\nreturn COL_AVERAGE;\r\ncase ST_SORT_COL_MIN:\r\nreturn COL_MIN;\r\ncase ST_SORT_COL_MAX:\r\nreturn COL_MAX;\r\ncase ST_SORT_COL_BURSTRATE:\r\nreturn COL_BURSTRATE;\r\n}\r\nreturn COL_COUNT;\r\n}\r\nextern gboolean\r\nstats_tree_is_default_sort_DESC (stats_tree *st)\r\n{\r\nreturn st->st_flags&ST_FLG_SORT_DESC;\r\n}\r\nextern const gchar*\r\nstats_tree_get_column_name (gint col_index)\r\n{\r\nswitch (col_index) {\r\ncase COL_NAME:\r\nreturn "Topic / Item";\r\ncase COL_COUNT:\r\nreturn "Count";\r\ncase COL_AVERAGE:\r\nreturn "Average";\r\ncase COL_MIN:\r\nreturn "Min val";\r\ncase COL_MAX:\r\nreturn "Max val";\r\ncase COL_RATE:\r\nreturn "Rate (ms)";\r\ncase COL_PERCENT:\r\nreturn "Percent";\r\ncase COL_BURSTRATE:\r\nreturn prefs.st_burst_showcount?"Burst count":"Burst rate";\r\ncase COL_BURSTTIME:\r\nreturn "Burst start";\r\ndefault:\r\nreturn "(Unknown)";\r\n}\r\n}\r\nextern gint\r\nstats_tree_get_column_size (gint col_index)\r\n{\r\nif (col_index==COL_NAME) {\r\nreturn 36;\r\n}\r\nif (col_index<N_COLUMNS) {\r\nreturn 12;\r\n}\r\nreturn 0;\r\n}\r\nextern gchar**\r\nstats_tree_get_values_from_node (const stat_node* node)\r\n{\r\ngchar **values = (gchar**) g_malloc0(sizeof(gchar*)*(node->st->num_columns));\r\nvalues[COL_NAME]= (node->st_flags&ST_FLG_ROOTCHILD)?stats_tree_get_displayname(node->name):g_strdup(node->name);\r\nvalues[COL_COUNT]= g_strdup_printf("%u",node->counter);\r\nvalues[COL_AVERAGE]= ((node->st_flags&ST_FLG_AVERAGE)||node->rng)?\r\n(node->counter?g_strdup_printf("%.2f",((float)node->total)/node->counter):g_strdup("-")):\r\ng_strdup("");\r\nvalues[COL_MIN]= ((node->st_flags&ST_FLG_AVERAGE)||node->rng)?\r\n(node->counter?g_strdup_printf("%u",node->minvalue):g_strdup("-")):\r\ng_strdup("");\r\nvalues[COL_MAX]= ((node->st_flags&ST_FLG_AVERAGE)||node->rng)?\r\n(node->counter?g_strdup_printf("%u",node->maxvalue):g_strdup("-")):\r\ng_strdup("");\r\nvalues[COL_RATE]= (node->st->elapsed)?g_strdup_printf("%.4f",((float)node->counter)/node->st->elapsed):g_strdup("");\r\nvalues[COL_PERCENT]= ((node->parent)&&(node->parent->counter))?\r\ng_strdup_printf("%.2f%%",(node->counter*100.0)/node->parent->counter):\r\n(node->parent==&(node->st->root)?g_strdup("100%"):g_strdup(""));\r\nif (node->st->num_columns>COL_BURSTTIME) {\r\nvalues[COL_BURSTRATE]= (!prefs.st_enable_burstinfo)?g_strdup(""):\r\n(node->max_burst?(prefs.st_burst_showcount?\r\ng_strdup_printf("%d",node->max_burst):\r\ng_strdup_printf("%.4f",((double)node->max_burst)/prefs.st_burst_windowlen)):\r\ng_strdup("-"));\r\nvalues[COL_BURSTTIME]= (!prefs.st_enable_burstinfo)?g_strdup(""):\r\n(node->max_burst?g_strdup_printf("%.3f",((double)node->burst_time/1000.0)):g_strdup("-"));\r\n}\r\nreturn values;\r\n}\r\nextern gint\r\nstats_tree_sort_compare (const stat_node *a, const stat_node *b, gint sort_column,\r\ngboolean sort_descending)\r\n{\r\nint result = 0;\r\nfloat avg_a, avg_b;\r\nif (prefs.st_sort_rng_nameonly&&(a->rng&&b->rng)) {\r\nresult = a->rng->floor - b->rng->floor;\r\nif (sort_descending&&(!prefs.st_sort_rng_fixorder)) {\r\nresult= -result;\r\n}\r\nreturn result;\r\n}\r\nswitch (sort_column) {\r\ncase COL_NAME:\r\nif (a->rng&&b->rng) {\r\nresult = a->rng->floor - b->rng->floor;\r\n}\r\nelse if (prefs.st_sort_casesensitve) {\r\nresult = strcmp(a->name,b->name);\r\n}\r\nelse {\r\nresult = g_ascii_strcasecmp(a->name,b->name);\r\n}\r\nbreak;\r\ncase COL_RATE:\r\ncase COL_PERCENT:\r\ncase COL_COUNT:\r\nresult = a->counter - b->counter;\r\nbreak;\r\ncase COL_AVERAGE:\r\nif (a->counter) {\r\nresult= 1;\r\nif (b->counter) {\r\navg_a= ((float)a->total)/a->counter;\r\navg_b= ((float)b->total)/b->counter;\r\nresult= (avg_a>avg_b)?1:((avg_a<avg_b)?-1:0);\r\n}\r\n}\r\nelse {\r\nresult= -1;\r\n}\r\nbreak;\r\ncase COL_MIN:\r\nresult = a->minvalue - b->minvalue;\r\nbreak;\r\ncase COL_MAX:\r\nresult = a->maxvalue - b->maxvalue;\r\nbreak;\r\ncase COL_BURSTRATE:\r\nresult = a->max_burst - b->max_burst;\r\nbreak;\r\ncase COL_BURSTTIME:\r\nresult = (a->burst_time>b->burst_time)?1:((a->burst_time<b->burst_time)?-1:0);\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\n}\r\nif (!result) {\r\nif (sort_column==COL_NAME) {\r\nresult = a->counter - b->counter;\r\n}\r\nelse {\r\nif (a->rng&&b->rng) {\r\nresult = a->rng->floor - b->rng->floor;\r\n}\r\nelse if (prefs.st_sort_casesensitve) {\r\nresult = strcmp(a->name,b->name);\r\n}\r\nelse {\r\nresult = g_ascii_strcasecmp(a->name,b->name);\r\n}\r\n}\r\n}\r\nif (sort_descending) {\r\nresult= -result;\r\n}\r\nif ((a->st_flags&ST_FLG_SORT_TOP)!=(b->st_flags&ST_FLG_SORT_TOP)) {\r\nresult= (a->st_flags&ST_FLG_SORT_TOP)?-1:1;\r\n}\r\nreturn result;\r\n}\r\nextern GString*\r\nstats_tree_format_as_str(const stats_tree* st, st_format_type format_type,\r\ngint sort_column, gboolean sort_descending)\r\n{\r\nint maxnamelen= stats_tree_branch_max_namelen(&st->root,0);\r\nstat_node *child;\r\nGString *s;\r\nint count;\r\ngchar *separator = NULL;\r\nswitch(format_type) {\r\ncase ST_FORMAT_YAML:\r\ns = g_string_new("---\n");\r\nbreak;\r\ncase ST_FORMAT_XML:\r\ns = g_string_new("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");\r\nbreak;\r\ncase ST_FORMAT_CSV:\r\ns = g_string_new("\"level\",\"parent\",");\r\nfor (count = 0; count<st->num_columns; count++) {\r\ng_string_append_printf(s,"\"%s\",",stats_tree_get_column_name(count));\r\n}\r\ng_string_append (s,"\n");\r\nbreak;\r\ncase ST_FORMAT_PLAIN:\r\n{\r\nchar fmt[16];\r\nint sep_length;\r\nsep_length= maxnamelen;\r\nfor (count = 1; count<st->num_columns; count++) {\r\nsep_length += stats_tree_get_column_size(count)+2;\r\n}\r\nseparator = (gchar *)g_malloc(sep_length+1);\r\nmemset (separator, '=', sep_length);\r\nseparator[sep_length] = 0;\r\ns = g_string_new("\n");\r\ng_string_append(s,separator);\r\ng_string_append_printf(s,"\n%s:\n",st->cfg->name);\r\ng_snprintf (fmt,(gulong)sizeof(fmt),"%%-%us",maxnamelen);\r\ng_string_append_printf(s,fmt,stats_tree_get_column_name(0));\r\nfor (count = 1; count<st->num_columns; count++) {\r\ng_snprintf (fmt,(gulong)sizeof(fmt)," %%-%us",stats_tree_get_column_size(count)+1);\r\ng_string_append_printf(s,fmt,stats_tree_get_column_name(count));\r\n}\r\nmemset (separator, '-', sep_length);\r\ng_string_append_printf(s,"\n%s\n",separator);\r\nbreak;\r\n}\r\ndefault:\r\nreturn g_string_new("unknown format for stats_tree\n");\r\n}\r\nfor (child = st->root.children; child; child = child->next ) {\r\nstats_tree_format_node_as_str(child,s,format_type,0,"",maxnamelen,sort_column,sort_descending);\r\n}\r\nif (format_type==ST_FORMAT_PLAIN) {\r\ng_string_append_printf(s,"\n%s\n",separator);\r\ng_free(separator);\r\n}\r\nreturn s;\r\n}\r\nextern gint\r\nstat_node_array_sortcmp (gconstpointer a, gconstpointer b, gpointer user_data)\r\n{\r\nreturn stats_tree_sort_compare (*(const stat_node*const*)a,*(const stat_node*const*)b,\r\n((sortinfo*)user_data)->sort_column,((sortinfo*)user_data)->sort_descending);\r\n}\r\nstatic gchar*\r\nclean_for_xml_tag (gchar *str)\r\n{\r\ngchar *s = str;\r\nwhile ((s=strpbrk(s,"!\"#$%%&'()*+,/;<=>?@[\\]^`{|}~ ")) != NULL) {\r\n*(s++) = '-';\r\n}\r\nreturn str;\r\n}\r\nWS_DLL_PUBLIC void stats_tree_format_node_as_str(const stat_node *node,\r\nGString *s,\r\nst_format_type format_type,\r\nguint indent,\r\nconst gchar *path,\r\ngint maxnamelen,\r\ngint sort_column,\r\ngboolean sort_descending)\r\n{\r\nint count;\r\nint num_columns= node->st->num_columns;\r\ngchar **values= stats_tree_get_values_from_node(node);\r\nstat_node *child;\r\nsortinfo si;\r\ngchar *full_path;\r\nchar fmt[16] = "%s%s%s";\r\nswitch(format_type) {\r\ncase ST_FORMAT_YAML:\r\nif (indent) {\r\ng_snprintf(fmt, (gulong)sizeof(fmt), "%%%ds%%s%%s", indent*4-2);\r\n}\r\ng_string_append_printf(s, fmt, "", indent?"- ":"", "Description");\r\ng_string_append_printf(s, ": \"%s\"\n", values[0]);\r\nfor (count = 1; count<num_columns; count++) {\r\nif (*values[count]) {\r\ng_string_append_printf(s, fmt, "", indent?" ":"",\r\nstats_tree_get_column_name(count));\r\ng_string_append_printf(s, ": %s\n", values[count]);\r\n}\r\n}\r\nif (node->children) {\r\ng_string_append_printf(s, fmt, "", indent?" ":"", "Items:\n");\r\n}\r\nbreak;\r\ncase ST_FORMAT_XML:\r\n{\r\nchar *itemname = xml_escape(values[0]);\r\ng_string_append_printf(s,"<stat-node name=\"%s\"%s>\n",itemname,\r\nnode->rng?" isrange=\"true\"":"");\r\ng_free(itemname);\r\nfor (count = 1; count<num_columns; count++) {\r\ngchar *colname= g_strdup(stats_tree_get_column_name(count));\r\ng_string_append_printf(s,"<%s>",clean_for_xml_tag(colname));\r\ng_string_append_printf(s,"%s</%s>\n",values[count],colname);\r\ng_free(colname);\r\n}\r\nbreak;\r\n}\r\ncase ST_FORMAT_CSV:\r\ng_string_append_printf(s,"%d,\"%s\",\"%s\"",indent,path,values[0]);\r\nfor (count = 1; count<num_columns; count++) {\r\ng_string_append_printf(s,",%s",values[count]);\r\n}\r\ng_string_append (s,"\n");\r\nbreak;\r\ncase ST_FORMAT_PLAIN:\r\ng_snprintf (fmt,(gulong)sizeof(fmt),"%%%ds%%-%us",indent,maxnamelen-indent);\r\ng_string_append_printf(s,fmt,"",values[0]);\r\nfor (count = 1; count<num_columns; count++) {\r\ng_snprintf (fmt,(gulong)sizeof(fmt)," %%-%us",stats_tree_get_column_size(count)+1);\r\ng_string_append_printf(s,fmt,values[count]);\r\n}\r\ng_string_append (s,"\n");\r\nbreak;\r\n}\r\nindent++;\r\nindent = indent > INDENT_MAX ? INDENT_MAX : indent;\r\nfull_path= g_strdup_printf ("%s/%s",path,values[0]);\r\nfor (count = 0; count<num_columns; count++) {\r\ng_free(values[count]);\r\n}\r\ng_free(values);\r\nif (node->children) {\r\nGArray *Children= g_array_new(FALSE,FALSE,sizeof(child));\r\nfor (child = node->children; child; child = child->next ) {\r\ng_array_append_val(Children,child);\r\n}\r\nsi.sort_column = sort_column;\r\nsi.sort_descending = sort_descending;\r\ng_array_sort_with_data(Children,stat_node_array_sortcmp,&si);\r\nfor (count = 0; count<((int)Children->len); count++) {\r\nstats_tree_format_node_as_str(g_array_index(Children,stat_node*,count), s, format_type,\r\nindent, full_path, maxnamelen, sort_column, sort_descending);\r\n}\r\ng_array_free(Children,FALSE);\r\n}\r\ng_free(full_path);\r\nif (format_type==ST_FORMAT_XML) {\r\ng_string_append(s,"</stat-node>\n");\r\n}\r\n}
