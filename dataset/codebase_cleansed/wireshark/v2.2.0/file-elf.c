static gint\r\nvalue_guard(guint64 value)\r\n{\r\nDISSECTOR_ASSERT_HINT(value <= G_MAXINT, "Too big file - not supported");\r\nreturn (gint) value;\r\n}\r\nstatic guint8\r\ndissect_dwarf_encoding(tvbuff_t *tvb, gint offset, proto_item *item)\r\n{\r\nguint8 value;\r\nproto_tree *tree;\r\ntree = proto_item_add_subtree(item, ett_dwarf_encoding);\r\nvalue = tvb_get_guint8(tvb, offset);\r\nif (value == 0xFF) {\r\nproto_tree_add_item(tree, hf_dwarf_omit, tvb, offset, 1, ENC_NA);\r\n} else {\r\nproto_tree_add_item(tree, hf_dwarf_upper, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_dwarf_format, tvb, offset, 1, ENC_NA);\r\n}\r\nreturn value;\r\n}\r\nstatic gint8\r\nget_dwarf_extension_length(guint8 format, guint register_size)\r\n{\r\nswitch (format & 0x0F) {\r\ncase 0x0:\r\nreturn register_size;\r\ncase 0x1:\r\nreturn LENGTH_ULEB128;\r\ncase 0x2:\r\nreturn 2;\r\ncase 0x3:\r\nreturn 4;\r\ncase 0x4:\r\nreturn 8;\r\ncase 0x9:\r\nreturn LENGTH_LEB128;\r\ncase 0xA:\r\nreturn 2;\r\ncase 0xB:\r\nreturn 4;\r\ncase 0xC:\r\nreturn 8;\r\n}\r\nreturn 0;\r\n}\r\nstatic const guint8 *\r\nget_section_name_offset(tvbuff_t *tvb, guint64 shoff, guint16 shnum, guint16 shentsize, guint16 shndx, guint64 shstrtab_offset, guint machine_encoding)\r\n{\r\ngint offset;\r\nguint32 sh_name;\r\nif (shndx > shnum)\r\nreturn NULL;\r\noffset = value_guard(shoff + shndx * shentsize);\r\nsh_name = (machine_encoding == ENC_BIG_ENDIAN) ? tvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\nreturn tvb_get_const_stringz(tvb, value_guard(shstrtab_offset + sh_name), NULL);\r\n}\r\nstatic gint\r\ndissect_dynamic(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *entry_tree, proto_item *entry_item,\r\ngint offset, gint register_size, guint machine_encoding)\r\n{\r\nenum enum_tag_type {\r\nDYNAMIC_TYPE_VALUE,\r\nDYNAMIC_TYPE_POINTER,\r\nDYNAMIC_TYPE_IGNORED,\r\nDYNAMIC_TYPE_UNSPECIFIED\r\n};\r\nguint64 tag;\r\nstatic const enum enum_tag_type tag_to_type[MAX_TAG_TO_TYPE] = {\r\nDYNAMIC_TYPE_IGNORED,\r\nDYNAMIC_TYPE_VALUE,\r\nDYNAMIC_TYPE_VALUE,\r\nDYNAMIC_TYPE_POINTER,\r\nDYNAMIC_TYPE_POINTER,\r\nDYNAMIC_TYPE_POINTER,\r\nDYNAMIC_TYPE_POINTER,\r\nDYNAMIC_TYPE_POINTER,\r\nDYNAMIC_TYPE_VALUE,\r\nDYNAMIC_TYPE_VALUE,\r\nDYNAMIC_TYPE_VALUE,\r\nDYNAMIC_TYPE_VALUE,\r\nDYNAMIC_TYPE_POINTER,\r\nDYNAMIC_TYPE_POINTER,\r\nDYNAMIC_TYPE_VALUE,\r\nDYNAMIC_TYPE_VALUE,\r\nDYNAMIC_TYPE_IGNORED,\r\nDYNAMIC_TYPE_POINTER,\r\nDYNAMIC_TYPE_VALUE,\r\nDYNAMIC_TYPE_VALUE,\r\nDYNAMIC_TYPE_VALUE,\r\nDYNAMIC_TYPE_POINTER,\r\nDYNAMIC_TYPE_IGNORED,\r\nDYNAMIC_TYPE_POINTER,\r\nDYNAMIC_TYPE_IGNORED,\r\nDYNAMIC_TYPE_POINTER,\r\nDYNAMIC_TYPE_POINTER,\r\nDYNAMIC_TYPE_VALUE,\r\nDYNAMIC_TYPE_VALUE,\r\nDYNAMIC_TYPE_VALUE,\r\nDYNAMIC_TYPE_VALUE,\r\nDYNAMIC_TYPE_UNSPECIFIED,\r\nDYNAMIC_TYPE_POINTER,\r\nDYNAMIC_TYPE_VALUE\r\n};\r\nif (register_size == REGISTER_32_SIZE) {\r\nproto_tree_add_item(entry_tree, hf_elf_dynamic_tag, tvb, offset, 4, machine_encoding);\r\ntag = (machine_encoding == ENC_BIG_ENDIAN) ? tvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\noffset += 4;\r\nif (tag < MAX_TAG_TO_TYPE && tag_to_type[tag] == DYNAMIC_TYPE_VALUE)\r\nproto_tree_add_item(entry_tree, hf_elf_dynamic_value, tvb, offset, 4, machine_encoding);\r\nelse if (tag < MAX_TAG_TO_TYPE && tag_to_type[tag] == DYNAMIC_TYPE_POINTER)\r\nproto_tree_add_item(entry_tree, hf_elf_dynamic_pointer, tvb, offset, 4, machine_encoding);\r\nelse if (tag < MAX_TAG_TO_TYPE && tag_to_type[tag] == DYNAMIC_TYPE_IGNORED)\r\nproto_tree_add_item(entry_tree, hf_elf_dynamic_ignored, tvb, offset, 4, machine_encoding);\r\nelse\r\nproto_tree_add_item(entry_tree, hf_elf_dynamic_unspecified, tvb, offset, 4, machine_encoding);\r\noffset += 4;\r\n} else {\r\nproto_item *pitem;\r\npitem = proto_tree_add_item(entry_tree, hf_elf64_dynamic_tag, tvb, offset, 8, machine_encoding);\r\ntag = (machine_encoding == ENC_BIG_ENDIAN) ? tvb_get_ntoh64(tvb, offset) : tvb_get_letoh64(tvb, offset);\r\nproto_item_append_text(pitem, " (%s)", rval_to_str(value_guard(tag), dynamic_tag_rvals, "Unknown"));\r\noffset += 8;\r\nif (tag < MAX_TAG_TO_TYPE && tag_to_type[tag] == DYNAMIC_TYPE_VALUE)\r\nproto_tree_add_item(entry_tree, hf_elf64_dynamic_value, tvb, offset, 8, machine_encoding);\r\nelse if (tag < MAX_TAG_TO_TYPE && tag_to_type[tag] == DYNAMIC_TYPE_POINTER)\r\nproto_tree_add_item(entry_tree, hf_elf64_dynamic_pointer, tvb, offset, 8, machine_encoding);\r\nelse if (tag < MAX_TAG_TO_TYPE && tag_to_type[tag] == DYNAMIC_TYPE_IGNORED)\r\nproto_tree_add_item(entry_tree, hf_elf64_dynamic_ignored, tvb, offset, 8, machine_encoding);\r\nelse\r\nproto_tree_add_item(entry_tree, hf_elf64_dynamic_unspecified, tvb, offset, 8, machine_encoding);\r\noffset += 8;\r\n}\r\nproto_item_append_text(entry_item, ": %s", rval_to_str(value_guard(tag), dynamic_tag_rvals, "Unknown"));\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_symbol_table(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *entry_tree, proto_item *entry_item,\r\ngint offset, gint register_size, guint machine_encoding, guint64 strtab_offset,\r\nguint64 shoff, guint16 shnum, guint16 shentsize, guint64 shstrtab_offset)\r\n{\r\nproto_item *pitem;\r\nproto_item *info_item;\r\nproto_tree *info_tree;\r\nguint16 shndx;\r\nguint32 name_index;\r\nconst guint8 *section_name;\r\nconst guint8 *name;\r\nguint8 info_bind;\r\nguint8 info_type;\r\npitem = proto_tree_add_item(entry_tree, hf_elf_symbol_table_name_index, tvb, offset, 4, machine_encoding);\r\nif (strtab_offset) {\r\nname_index = (machine_encoding == ENC_BIG_ENDIAN) ? tvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\nname = tvb_get_const_stringz(tvb, value_guard(strtab_offset + name_index), NULL);\r\nif (name) {\r\nproto_item_append_text(pitem, ": %s", name);\r\nproto_item_append_text(entry_item, ": %s", name);\r\n}\r\n}\r\noffset += 4;\r\nif (register_size == REGISTER_32_SIZE) {\r\nproto_tree_add_item(entry_tree, hf_elf_symbol_table_value, tvb, offset, 4, machine_encoding);\r\noffset += 4;\r\nproto_tree_add_item(entry_tree, hf_elf_symbol_table_size, tvb, offset, 4, machine_encoding);\r\noffset += 4;\r\ninfo_item = proto_tree_add_item(entry_tree, hf_elf_symbol_table_info, tvb, offset, 1, machine_encoding);\r\ninfo_tree = proto_item_add_subtree(info_item, ett_symbol_table_info);\r\nproto_tree_add_item(info_tree, hf_elf_symbol_table_info_bind, tvb, offset, 1, machine_encoding);\r\nproto_tree_add_item(info_tree, hf_elf_symbol_table_info_type, tvb, offset, 1, machine_encoding);\r\ninfo_bind = tvb_get_guint8(tvb, offset) >> 4;\r\ninfo_type = tvb_get_guint8(tvb, offset) & 0x0F;\r\noffset += 1;\r\nproto_tree_add_item(entry_tree, hf_elf_symbol_table_other, tvb, offset, 1, machine_encoding);\r\noffset += 1;\r\npitem = proto_tree_add_item(entry_tree, hf_elf_symbol_table_shndx, tvb, offset, 2, machine_encoding);\r\nshndx = (machine_encoding == ENC_BIG_ENDIAN) ? tvb_get_ntohs(tvb, offset) : tvb_get_letohs(tvb, offset);\r\nif (shndx <= shnum) {\r\nsection_name = get_section_name_offset(tvb, shoff, shnum, shentsize, shndx, shstrtab_offset, machine_encoding);\r\nif (section_name && section_name[0] != '\0')\r\nproto_item_append_text(pitem, " (%u: %s)", shndx, section_name);\r\n} else {\r\nproto_item_append_text(pitem, " (%u)", shndx);\r\n}\r\noffset += 2;\r\n} else {\r\ninfo_item = proto_tree_add_item(entry_tree, hf_elf_symbol_table_info, tvb, offset, 1, machine_encoding);\r\ninfo_tree = proto_item_add_subtree(info_item, ett_symbol_table_info);\r\nproto_tree_add_item(info_tree, hf_elf_symbol_table_info_bind, tvb, offset, 1, machine_encoding);\r\nproto_tree_add_item(info_tree, hf_elf_symbol_table_info_type, tvb, offset, 1, machine_encoding);\r\ninfo_bind = tvb_get_guint8(tvb, offset) >> 4;\r\ninfo_type = tvb_get_guint8(tvb, offset) & 0x0F;\r\noffset += 1;\r\nproto_tree_add_item(entry_tree, hf_elf_symbol_table_other, tvb, offset, 1, machine_encoding);\r\noffset += 1;\r\npitem = proto_tree_add_item(entry_tree, hf_elf_symbol_table_shndx, tvb, offset, 2, machine_encoding);\r\nshndx = (machine_encoding == ENC_BIG_ENDIAN) ? tvb_get_ntohs(tvb, offset) : tvb_get_letohs(tvb, offset);\r\nif (shndx <= shnum) {\r\nsection_name = get_section_name_offset(tvb, shoff, shnum, shentsize, shndx, shstrtab_offset, machine_encoding);\r\nif (section_name && section_name[0] != '\0')\r\nproto_item_append_text(pitem, " (%u: %s)", shndx, section_name);\r\n} else {\r\nproto_item_append_text(pitem, " (%u)", shndx);\r\n}\r\noffset += 2;\r\nproto_tree_add_item(entry_tree, hf_elf64_symbol_table_value, tvb, offset, 8, machine_encoding);\r\noffset += 8;\r\nproto_tree_add_item(entry_tree, hf_elf64_symbol_table_size, tvb, offset, 8, machine_encoding);\r\noffset += 8;\r\n}\r\nproto_item_append_text(info_item, " (Bind: %s, Type: %s)",\r\nval_to_str_const(info_bind, symbol_table_info_bind_vals, "Unknown"),\r\nval_to_str_ext_const(info_type, &symbol_table_info_type_vals_ext, "Unknown"));\r\nproto_item_append_text(entry_item, " (Bind: %s, Type: %s)",\r\nval_to_str_const(info_bind, symbol_table_info_bind_vals, "Unknown"),\r\nval_to_str_ext_const(info_type, &symbol_table_info_type_vals_ext, "Unknown"));\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_eh_frame_hdr(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *segment_tree,\r\ngint offset, gint segment_size _U_, gint register_size, guint machine_encoding)\r\n{\r\nproto_item *item;\r\nproto_tree *table_tree;\r\nguint8 format;\r\ngint efp_length;\r\ngint fde_count_length;\r\ngint table_entry_length;\r\nguint64 fde_count;\r\nguint i_entry;\r\nproto_tree_add_item(segment_tree, hf_elf_eh_frame_hdr_version, tvb, offset, 1, machine_encoding);\r\noffset += 1;\r\nitem = proto_tree_add_item(segment_tree, hf_elf_eh_frame_hdr_exception_frame_pointer_encoding, tvb, offset, 1, machine_encoding);\r\nformat = dissect_dwarf_encoding(tvb, offset, item);\r\nefp_length = get_dwarf_extension_length(format, register_size);\r\noffset += 1;\r\nitem = proto_tree_add_item(segment_tree, hf_elf_eh_frame_hdr_fde_count_encoding, tvb, offset, 1, machine_encoding);\r\nformat = dissect_dwarf_encoding(tvb, offset, item);\r\nfde_count_length = get_dwarf_extension_length(format, register_size);\r\noffset += 1;\r\nitem = proto_tree_add_item(segment_tree, hf_elf_eh_frame_hdr_binary_search_table_encoding, tvb, offset, 1, machine_encoding);\r\nformat = dissect_dwarf_encoding(tvb, offset, item);\r\ntable_entry_length = get_dwarf_extension_length(format, register_size);\r\noffset += 1;\r\nif (efp_length == LENGTH_ULEB128) {\r\nguint64 value;\r\nefp_length = dissect_uleb128(tvb, offset, &value);\r\n} else if (efp_length == LENGTH_LEB128) {\r\ngint64 value;\r\nefp_length = dissect_leb128(tvb, offset, &value);\r\n}\r\nproto_tree_add_item(segment_tree, hf_elf_eh_frame_hdr_eh_frame_ptr, tvb, offset, efp_length, machine_encoding);\r\noffset += efp_length;\r\nif (fde_count_length == LENGTH_ULEB128) {\r\nfde_count_length = dissect_uleb128(tvb, offset, &fde_count);\r\n} else if (fde_count_length == LENGTH_LEB128) {\r\ngint64 value;\r\nfde_count_length = dissect_leb128(tvb, offset, &value);\r\nfde_count = (guint64) value;\r\n} else {\r\nif (fde_count_length == 0) fde_count_length = register_size;\r\nswitch(fde_count_length) {\r\ncase 2:\r\nfde_count = (machine_encoding == ENC_BIG_ENDIAN) ? tvb_get_ntohs(tvb, offset) : tvb_get_letohs(tvb, offset);\r\nbreak;\r\ncase 4:\r\nfde_count = (machine_encoding == ENC_BIG_ENDIAN) ? tvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\nbreak;\r\ncase 8:\r\nfde_count = (machine_encoding == ENC_BIG_ENDIAN) ? tvb_get_ntoh64(tvb, offset) : tvb_get_letoh64(tvb, offset);\r\nbreak;\r\ncase 0:\r\ndefault:\r\nfde_count = 0;\r\nbreak;\r\n}\r\n}\r\nproto_tree_add_item(segment_tree, hf_elf_eh_frame_hdr_fde_count, tvb, offset,\r\nfde_count_length, machine_encoding);\r\noffset += fde_count_length;\r\nif (table_entry_length == LENGTH_ULEB128) {\r\nguint64 value;\r\ntable_entry_length = dissect_uleb128(tvb, offset, &value);\r\n} else if (table_entry_length == LENGTH_LEB128) {\r\ngint64 value;\r\ntable_entry_length = dissect_leb128(tvb, offset, &value);\r\n}\r\ni_entry = 0;\r\ntable_tree = proto_tree_add_subtree(segment_tree, tvb, offset, value_guard(fde_count * table_entry_length * 2),\r\nett_binary_table, NULL, "Binary Search Table");\r\nwhile (++i_entry <= fde_count) {\r\nproto_tree *entry_tree;\r\nentry_tree = proto_tree_add_subtree_format(table_tree, tvb, offset, table_entry_length * 2, ett_binary_table_entry,\r\nNULL, "Binary Table Entry #%u", i_entry);\r\nproto_tree_add_item(entry_tree, hf_elf_eh_frame_hdr_binary_search_table_entry_initial_location, tvb, offset, table_entry_length, machine_encoding);\r\noffset += table_entry_length;\r\nproto_tree_add_item(entry_tree, hf_elf_eh_frame_hdr_binary_search_table_entry_address, tvb, offset, table_entry_length, machine_encoding);\r\noffset += table_entry_length;\r\n}\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_eh_frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *segment_tree,\r\ngint offset, gint segment_size, gint register_size _U_, guint machine_encoding)\r\n{\r\nproto_tree *cfi_tree = NULL;\r\nproto_item *cfi_tree_item = NULL;\r\nproto_tree *entry_tree;\r\nproto_item *pi = NULL;\r\nguint64 length;\r\nguint lengths_size;\r\ngboolean is_cie;\r\nguint entry_size, entry_end = 0;\r\nguint cfi_size = 0;\r\nguint64 unsigned_value;\r\ngint64 signed_value;\r\ngint size;\r\nconst gchar *augmentation_string = "";\r\ngboolean is_extended_length;\r\ngint start_offset = offset;\r\nguint cfi_number = 0;\r\ngint entry_number = 0;\r\nwhile (offset - start_offset < segment_size) {\r\nlength = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\nis_extended_length = length == 0xFFFFFFFF;\r\nif (is_extended_length) {\r\nlength = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntoh64(tvb, offset + 4) :\r\ntvb_get_letoh64(tvb, offset + 4);\r\n}\r\nlengths_size = is_extended_length ? 12 : 4;\r\nis_cie = length == 0 || tvb_get_ntohl(tvb, offset + lengths_size) == 0;\r\nentry_size = value_guard(length + lengths_size);\r\nentry_end = offset + entry_size;\r\nif (length == 0) {\r\nentry_tree = proto_tree_add_subtree(segment_tree,\r\ntvb, offset, entry_size,\r\nett_elf_cie_terminator, NULL, "CIE Terminator");\r\n} else if (cfi_number == 0 || is_cie) {\r\n++cfi_number;\r\ncfi_tree = proto_tree_add_subtree_format(segment_tree,\r\ntvb, offset, entry_size, ett_elf_cfi_record, &cfi_tree_item,\r\n"Call Frame Information Entry %i", cfi_number);\r\nentry_tree = proto_tree_add_subtree(cfi_tree, tvb, offset,\r\nentry_size, ett_elf_cie_entry, NULL, "Common Information Entry");\r\ncfi_size = entry_size;\r\nentry_number = 0;\r\n} else {\r\n++entry_number;\r\ncfi_size += entry_size;\r\nproto_item_set_len(cfi_tree_item, cfi_size);\r\nentry_tree = proto_tree_add_subtree_format(cfi_tree,\r\ntvb, offset, entry_size, ett_elf_fde_entry, NULL,\r\n"Frame Description Entry %i", entry_number);\r\n}\r\npi = proto_tree_add_item(entry_tree, is_cie ?\r\nhf_elf_eh_frame_length :\r\nhf_elf_eh_frame_fde_length,\r\ntvb, offset, 4, machine_encoding);\r\noffset += 4;\r\nif (is_extended_length) {\r\npi = proto_tree_add_item(entry_tree, is_cie ?\r\nhf_elf_eh_frame_extended_length :\r\nhf_elf_eh_frame_fde_extended_length,\r\ntvb, offset, 8, machine_encoding);\r\noffset += 8;\r\n}\r\nif (length == 0)\r\nbreak;\r\nif (length < 12 || entry_end - start_offset > (guint64)segment_size) {\r\nexpert_add_info(pinfo, pi, &ei_invalid_cie_length);\r\nreturn offset;\r\n}\r\nproto_tree_add_item(entry_tree, is_cie ?\r\nhf_elf_eh_frame_cie_id :\r\nhf_elf_eh_frame_fde_cie_pointer,\r\ntvb, offset, 4, machine_encoding);\r\noffset += 4;\r\nif (is_cie) {\r\nproto_tree_add_item(entry_tree, hf_elf_eh_frame_version,\r\ntvb, offset, 1, machine_encoding);\r\noffset += 1;\r\naugmentation_string = tvb_get_const_stringz(tvb, offset, &size);\r\nproto_tree_add_item(entry_tree, hf_elf_eh_frame_augmentation_string,\r\ntvb, offset, size, machine_encoding);\r\noffset += size;\r\nsize = dissect_uleb128(tvb, offset, &unsigned_value);\r\nproto_tree_add_uint64(entry_tree, hf_elf_eh_frame_code_alignment_factor,\r\ntvb, offset, size, unsigned_value);\r\noffset += size;\r\nsize = dissect_leb128(tvb, offset, &signed_value);\r\nproto_tree_add_int64(entry_tree, hf_elf_eh_frame_data_alignment_factor,\r\ntvb, offset, size, signed_value);\r\noffset += size;\r\nsize = dissect_uleb128(tvb, offset, &unsigned_value);\r\nproto_tree_add_uint64(entry_tree, hf_elf_eh_frame_return_address_register,\r\ntvb, offset, size, unsigned_value);\r\noffset += size;\r\n} else {\r\nproto_tree_add_item(entry_tree, hf_elf_eh_frame_fde_pc_begin, tvb,\r\noffset, 4, machine_encoding);\r\noffset += 4;\r\nproto_tree_add_item(entry_tree, hf_elf_eh_frame_fde_pc_range, tvb,\r\noffset, 4, machine_encoding);\r\noffset += 4;\r\n}\r\nif (augmentation_string[0] == 'z') {\r\nsize = dissect_uleb128(tvb, offset, &unsigned_value);\r\nproto_tree_add_uint64(entry_tree, is_cie ?\r\nhf_elf_eh_frame_augmentation_length :\r\nhf_elf_eh_frame_fde_augmentation_length,\r\ntvb, offset, size, unsigned_value);\r\noffset += size;\r\nproto_tree_add_item(entry_tree, is_cie ?\r\nhf_elf_eh_frame_augmentation_data :\r\nhf_elf_eh_frame_fde_augmentation_data,\r\ntvb, offset, value_guard(unsigned_value),\r\nmachine_encoding);\r\noffset += value_guard(unsigned_value);\r\n}\r\nproto_tree_add_item(entry_tree, is_cie ?\r\nhf_elf_eh_frame_initial_instructions :\r\nhf_elf_eh_frame_fde_call_frame_instructions,\r\ntvb, offset, value_guard(entry_end - offset),\r\nmachine_encoding);\r\noffset = value_guard(entry_end);\r\n}\r\nif (entry_end - start_offset != (guint64)segment_size)\r\nexpert_add_info(pinfo, pi, &ei_cfi_extraneous_data);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_elf(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nstatic const guint8 magic[] = { 0x7F, 'E', 'L', 'F'};\r\ngint offset = 0;\r\nproto_tree *main_tree;\r\nproto_item *main_item, *ti;\r\nproto_tree *header_tree;\r\nproto_item *header_item;\r\nproto_tree *program_header_tree;\r\nproto_tree *section_header_tree;\r\nproto_tree *ph_entry_tree;\r\nproto_item *sh_entry_item;\r\nproto_tree *sh_entry_tree;\r\nproto_item *segment_item;\r\nproto_tree *segment_tree;\r\nproto_item *generated_item;\r\nproto_tree *generated_tree;\r\nproto_tree *overlapping_tree;\r\nproto_tree *blackhole_tree;\r\nproto_item *entry_item;\r\nproto_tree *entry_tree;\r\nguint machine_encoding = ENC_NA;\r\ngint register_size = 4;\r\nguint16 phentsize;\r\nguint16 phnum;\r\nguint16 shentsize;\r\nguint16 shnum;\r\nguint64 phoff;\r\nguint64 shoff;\r\nguint16 i_16;\r\nguint32 p_type;\r\nguint32 sh_type;\r\nguint16 shstrndx;\r\nguint64 shstrtab_offset;\r\nguint32 sh_name;\r\nconst guint8 *section_name;\r\nguint64 length;\r\nguint64 segment_offset;\r\nguint64 segment_size;\r\nguint64 file_size;\r\nguint64 p_offset;\r\ngint ehsize;\r\nguint area_counter = 0;\r\nsegment_info_t *segment_info;\r\nguint i;\r\nguint i_next;\r\ngint next_offset;\r\ngint len;\r\nguint64 sh_entsize;\r\nguint64 strtab_offset = 0;\r\nguint64 dynstr_offset = 0;\r\nif (tvb_captured_length(tvb) < 52)\r\nreturn 0;\r\nif (tvb_memeql(tvb, 0, magic, sizeof(magic)) != 0)\r\nreturn 0;\r\nmain_item = proto_tree_add_item(tree, proto_elf, tvb, offset, -1, ENC_NA);\r\nmain_tree = proto_item_add_subtree(main_item, ett_elf);\r\nheader_tree = proto_tree_add_subtree(main_tree, tvb, offset, 1, ett_elf_header, &header_item, "Header");\r\nproto_tree_add_item(header_tree, hf_elf_magic_bytes, tvb, offset, sizeof(magic), ENC_NA);\r\noffset += (int)sizeof(magic);\r\nproto_tree_add_item(header_tree, hf_elf_file_class, tvb, offset, 1, ENC_NA);\r\nregister_size *= tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\nproto_tree_add_item(header_tree, hf_elf_data_encoding, tvb, offset, 1, ENC_NA);\r\nif (tvb_get_guint8(tvb, offset) == 1)\r\nmachine_encoding = ENC_LITTLE_ENDIAN;\r\nelse\r\nmachine_encoding = ENC_BIG_ENDIAN;\r\noffset += 1;\r\nproto_tree_add_item(header_tree, hf_elf_file_version, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(header_tree, hf_elf_os_abi, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(header_tree, hf_elf_abi_version, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(header_tree, hf_elf_file_padding, tvb, offset, 7, ENC_NA);\r\noffset += 7;\r\nproto_tree_add_item(header_tree, hf_elf_type, tvb, offset, 2, machine_encoding);\r\noffset += 2;\r\nproto_tree_add_item(header_tree, hf_elf_machine, tvb, offset, 2, machine_encoding);\r\noffset += 2;\r\nproto_tree_add_item(header_tree, hf_elf_version, tvb, offset, 4, machine_encoding);\r\noffset += 4;\r\nproto_tree_add_item(header_tree,\r\n(register_size == REGISTER_32_SIZE) ? hf_elf_entry : hf_elf64_entry,\r\ntvb, offset, register_size, machine_encoding);\r\noffset += register_size;\r\nif (register_size == REGISTER_32_SIZE) {\r\nproto_tree_add_item(header_tree, hf_elf_phoff, tvb, offset,\r\nregister_size, machine_encoding);\r\nphoff = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\n} else {\r\nproto_tree_add_item(header_tree, hf_elf64_phoff, tvb, offset,\r\nregister_size, machine_encoding);\r\nphoff = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntoh64(tvb, offset) : tvb_get_letoh64(tvb, offset);\r\n}\r\noffset += register_size;\r\nif (register_size == REGISTER_32_SIZE) {\r\nproto_tree_add_item(header_tree, hf_elf_shoff, tvb, offset,\r\nregister_size, machine_encoding);\r\nshoff = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\n} else {\r\nproto_tree_add_item(header_tree, hf_elf64_shoff, tvb, offset,\r\nregister_size, machine_encoding);\r\nshoff = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntoh64(tvb, offset) : tvb_get_letoh64(tvb, offset);\r\n}\r\noffset += register_size;\r\nproto_tree_add_item(header_tree, hf_elf_flags, tvb, offset, 4, machine_encoding);\r\noffset += 4;\r\nproto_tree_add_item(header_tree, hf_elf_ehsize, tvb, offset, 2, machine_encoding);\r\nehsize = (machine_encoding == ENC_BIG_ENDIAN) ? tvb_get_ntohs(tvb, offset) : tvb_get_letohs(tvb, offset);\r\nproto_item_set_len(header_item, ehsize);\r\noffset += 2;\r\nproto_tree_add_item(header_tree, hf_elf_phentsize, tvb, offset, 2, machine_encoding);\r\nphentsize = (machine_encoding == ENC_BIG_ENDIAN) ? tvb_get_ntohs(tvb, offset) : tvb_get_letohs(tvb, offset);\r\noffset += 2;\r\nproto_tree_add_item(header_tree, hf_elf_phnum, tvb, offset, 2, machine_encoding);\r\nphnum = (machine_encoding == ENC_BIG_ENDIAN) ? tvb_get_ntohs(tvb, offset) : tvb_get_letohs(tvb, offset);\r\noffset += 2;\r\nproto_tree_add_item(header_tree, hf_elf_shentsize, tvb, offset, 2, machine_encoding);\r\nshentsize = (machine_encoding == ENC_BIG_ENDIAN) ? tvb_get_ntohs(tvb, offset) : tvb_get_letohs(tvb, offset);\r\noffset += 2;\r\nproto_tree_add_item(header_tree, hf_elf_shnum, tvb, offset, 2, machine_encoding);\r\nshnum = (machine_encoding == ENC_BIG_ENDIAN) ? tvb_get_ntohs(tvb, offset) : tvb_get_letohs(tvb, offset);\r\noffset += 2;\r\nproto_tree_add_item(header_tree, hf_elf_shstrndx, tvb, offset, 2, machine_encoding);\r\nshstrndx = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntohs(tvb, offset) : tvb_get_letohs(tvb, offset);\r\nprogram_header_tree = proto_tree_add_subtree_format(main_tree, tvb, value_guard(phoff),\r\nphnum * phentsize, ett_elf_program_header, NULL, "Program Header Table [%d entries]", phnum);\r\nsection_header_tree = proto_tree_add_subtree_format(main_tree, tvb, value_guard(shoff),\r\nshnum * shentsize, ett_elf_section_header, NULL, "Section Header Table [%d entries]", shnum);\r\nfile_size = ehsize + phnum * phentsize + shnum * shentsize;\r\nsegment_info = (segment_info_t *) wmem_alloc(wmem_packet_scope(), sizeof(segment_info_t) * (shnum + phnum + 3));\r\nsegment_info[area_counter].offset = 0;\r\nsegment_info[area_counter].size = ehsize;\r\nsegment_info[area_counter].name = "Header";\r\narea_counter += 1;\r\nif (phoff) {\r\nsegment_info[area_counter].offset = phoff;\r\nsegment_info[area_counter].size = phnum * phentsize;\r\nsegment_info[area_counter].name = "ProgramHeader";\r\narea_counter += 1;\r\n}\r\nif (shoff) {\r\nsegment_info[area_counter].offset = shoff;\r\nsegment_info[area_counter].size = shnum * shentsize;\r\nsegment_info[area_counter].name = "SectionHeader";\r\narea_counter += 1;\r\n}\r\noffset = value_guard(phoff);\r\ni_16 = phnum;\r\nwhile (i_16-- > 0) {\r\np_type = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\nif (p_type >= 0x60000000 && p_type <= 0x6FFFFFFF) {\r\nph_entry_tree = proto_tree_add_subtree_format(program_header_tree,\r\ntvb, offset, phentsize, ett_elf_program_header_entry, NULL,\r\n"Entry #%d: Operating System Specific (0x%08x)", phnum - i_16 - 1, p_type);\r\nproto_tree_add_item(ph_entry_tree, hf_elf_p_type_operating_system_specific, tvb, offset, 4, machine_encoding);\r\n} else if (p_type >= 0x70000000 && p_type <= 0x7FFFFFFF) {\r\nph_entry_tree = proto_tree_add_subtree_format(program_header_tree,\r\ntvb, offset, phentsize, ett_elf_program_header_entry, NULL,\r\n"Entry #%d: Processor Specific (0x%08x)", phnum - i_16 - 1, p_type);\r\nproto_tree_add_item(ph_entry_tree, hf_elf_p_type_processor_specific, tvb, offset, 4, machine_encoding);\r\n} else {\r\nph_entry_tree = proto_tree_add_subtree_format(program_header_tree,\r\ntvb, offset, phentsize, ett_elf_program_header_entry, NULL,\r\n"Entry #%d: %s", phnum - i_16 - 1,\r\nval_to_str_const(p_type, p_type_vals, "Unknown"));\r\nproto_tree_add_item(ph_entry_tree, hf_elf_p_type, tvb, offset, 4, machine_encoding);\r\n}\r\noffset += 4;\r\nif (register_size == REGISTER_64_SIZE) {\r\nproto_tree_add_item(ph_entry_tree, hf_elf_p_flags_processor_specific, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(ph_entry_tree, hf_elf_p_flags_operating_system_specific, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(ph_entry_tree, hf_elf_p_flags_reserved, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(ph_entry_tree, hf_elf_p_flags_read, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(ph_entry_tree, hf_elf_p_flags_write, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(ph_entry_tree, hf_elf_p_flags_execute, tvb, offset, 4, machine_encoding);\r\noffset += 4;\r\n}\r\nproto_tree_add_item(ph_entry_tree,\r\n(register_size == REGISTER_32_SIZE) ? hf_elf_p_offset : hf_elf64_p_offset,\r\ntvb, offset, register_size, machine_encoding);\r\nif (register_size == REGISTER_32_SIZE) {\r\np_offset = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\n} else {\r\np_offset = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntoh64(tvb, offset) : tvb_get_letoh64(tvb, offset);\r\n}\r\noffset += register_size;\r\nproto_tree_add_item(ph_entry_tree,\r\n(register_size == REGISTER_32_SIZE) ? hf_elf_p_vaddr : hf_elf64_p_vaddr,\r\ntvb, offset, register_size, machine_encoding);\r\noffset += register_size;\r\nproto_tree_add_item(ph_entry_tree,\r\n(register_size == REGISTER_32_SIZE) ? hf_elf_p_paddr : hf_elf64_p_paddr,\r\ntvb, offset, register_size, machine_encoding);\r\noffset += register_size;\r\nproto_tree_add_item(ph_entry_tree,\r\n(register_size == REGISTER_32_SIZE) ? hf_elf_p_filesz : hf_elf64_p_filesz,\r\ntvb, offset, register_size, machine_encoding);\r\nif (register_size == REGISTER_32_SIZE) {\r\nsegment_size = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\n} else {\r\nsegment_size = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntoh64(tvb, offset) : tvb_get_letoh64(tvb, offset);\r\n}\r\noffset += register_size;\r\nproto_tree_add_item(ph_entry_tree,\r\n(register_size == REGISTER_32_SIZE) ? hf_elf_p_memsz : hf_elf64_p_memsz,\r\ntvb, offset, register_size, machine_encoding);\r\noffset += register_size;\r\nif (register_size == REGISTER_32_SIZE) {\r\nproto_tree_add_item(ph_entry_tree, hf_elf_p_flags_processor_specific, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(ph_entry_tree, hf_elf_p_flags_operating_system_specific, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(ph_entry_tree, hf_elf_p_flags_reserved, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(ph_entry_tree, hf_elf_p_flags_read, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(ph_entry_tree, hf_elf_p_flags_write, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(ph_entry_tree, hf_elf_p_flags_execute, tvb, offset, 4, machine_encoding);\r\noffset += 4;\r\n}\r\nproto_tree_add_item(ph_entry_tree,\r\n(register_size == REGISTER_32_SIZE) ? hf_elf_p_align : hf_elf64_p_align,\r\ntvb, offset, register_size, machine_encoding);\r\noffset += register_size;\r\nif (segment_size) {\r\ngchar *name;\r\nname = wmem_strdup_printf(wmem_packet_scope(), "ProgramHeaderEntry #%u", phnum - i_16 - 1);\r\nproto_tree_add_bytes_format(ph_entry_tree, hf_elf_segment, tvb, value_guard(p_offset), value_guard(segment_size), NULL, "Segment");\r\nfile_size += segment_size;\r\nsegment_info[area_counter].offset = p_offset;\r\nsegment_info[area_counter].size = segment_size;\r\nsegment_info[area_counter].name = name;\r\narea_counter += 1;\r\n}\r\n}\r\noffset = value_guard(shoff);\r\ni_16 = shnum;\r\nwhile (i_16-- > 0) {\r\nsh_name = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\noffset += 4;\r\noffset += 4;\r\nlength = shoff + shstrndx * shentsize + 2 * 4 + 2 * register_size;\r\nif (register_size == REGISTER_32_SIZE) {\r\nshstrtab_offset = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntohl(tvb, value_guard(length)) : tvb_get_letohl(tvb, value_guard(length));\r\n} else {\r\nshstrtab_offset = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntoh64(tvb, value_guard(length)) : tvb_get_letoh64(tvb, value_guard(length));\r\n}\r\nsection_name = tvb_get_const_stringz(tvb, value_guard(shstrtab_offset + sh_name), NULL);\r\nif (register_size == REGISTER_64_SIZE && machine_encoding == ENC_BIG_ENDIAN) {\r\noffset += 4;\r\n}\r\noffset += 4;\r\nif (register_size == REGISTER_64_SIZE && machine_encoding == ENC_LITTLE_ENDIAN) {\r\noffset += 4;\r\n}\r\noffset += register_size;\r\nif (register_size == REGISTER_32_SIZE) {\r\nsegment_offset = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\n} else {\r\nsegment_offset = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntoh64(tvb, offset) : tvb_get_letoh64(tvb, offset);\r\n}\r\nif (g_strcmp0(section_name, ".strtab") == 0) {\r\nstrtab_offset = segment_offset;\r\n} else if (g_strcmp0(section_name, ".dynstr") == 0) {\r\ndynstr_offset = segment_offset;\r\n}\r\noffset += register_size;\r\noffset += register_size;\r\noffset += 4;\r\noffset += 4;\r\noffset += register_size;\r\noffset += register_size;\r\n}\r\noffset = value_guard(shoff);\r\ni_16 = shnum;\r\nwhile (i_16-- > 0) {\r\nsh_entry_tree = proto_tree_add_subtree_format(section_header_tree, tvb, offset, shentsize,\r\nett_elf_section_header_entry, &sh_entry_item,\r\n"Entry #%d: ", shnum - i_16 - 1);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_name, tvb, offset, 4, machine_encoding);\r\nsh_name = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\noffset += 4;\r\nsh_type = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\nif (sh_type >= 0x60000000 && sh_type <= 0x6FFFFFFF) {\r\nproto_item_append_text(sh_entry_item, "Operating System Specific (0x%08x)", sh_type);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_type_operating_system_specific, tvb, offset, 4, machine_encoding);\r\n} else if (sh_type >= 0x70000000 && sh_type <= 0x7FFFFFFF) {\r\nproto_item_append_text(sh_entry_item, "Processor Specific (0x%08x)", sh_type);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_type_processor_specific, tvb, offset, 4, machine_encoding);\r\n} else if (sh_type >= 0x80000000 && sh_type <= 0xFFFFFFFF) {\r\nproto_item_append_text(sh_entry_item, "User Specific (0x%08x)", sh_type);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_type_user_specific, tvb, offset, 4, machine_encoding);\r\n}else {\r\nproto_item_append_text(sh_entry_item, "%s", val_to_str_ext_const(sh_type, &sh_type_vals_ext, "Unknown"));\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_type, tvb, offset, 4, machine_encoding);\r\n}\r\noffset += 4;\r\nlength = shoff + shstrndx * shentsize + 2 * 4 + 2 * register_size;\r\nif (register_size == REGISTER_32_SIZE) {\r\nshstrtab_offset = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntohl(tvb, value_guard(length)) : tvb_get_letohl(tvb, value_guard(length));\r\n} else {\r\nshstrtab_offset = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntoh64(tvb, value_guard(length)) : tvb_get_letoh64(tvb, value_guard(length));\r\n}\r\nsection_name = tvb_get_const_stringz(tvb, value_guard(shstrtab_offset + sh_name), NULL);\r\nif (section_name)\r\nproto_item_append_text(sh_entry_item, ": %s", section_name);\r\nif (register_size == REGISTER_64_SIZE && machine_encoding == ENC_BIG_ENDIAN) {\r\noffset += 4;\r\n}\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_flags_processor_specific, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_flags_operating_system_specific, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_flags_reserved, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_flags_tls, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_flags_group, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_flags_os_nonconforming, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_flags_link_order, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_flags_info_link, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_flags_strings, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_flags_merge, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_flags_reserved_8, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_flags_exec_instr, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_flags_alloc, tvb, offset, 4, machine_encoding);\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_flags_write, tvb, offset, 4, machine_encoding);\r\noffset += 4;\r\nif (register_size == REGISTER_64_SIZE && machine_encoding == ENC_LITTLE_ENDIAN) {\r\noffset += 4;\r\n}\r\nproto_tree_add_item(sh_entry_tree,\r\n(register_size == REGISTER_32_SIZE) ? hf_elf_sh_addr : hf_elf64_sh_addr,\r\ntvb, offset, register_size, machine_encoding);\r\noffset += register_size;\r\nproto_tree_add_item(sh_entry_tree,\r\n(register_size == REGISTER_32_SIZE) ? hf_elf_sh_offset : hf_elf64_sh_offset,\r\ntvb, offset, register_size, machine_encoding);\r\nif (register_size == REGISTER_32_SIZE) {\r\nsegment_offset = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\n} else {\r\nsegment_offset = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntoh64(tvb, offset) : tvb_get_letoh64(tvb, offset);\r\n}\r\noffset += register_size;\r\nproto_tree_add_item(sh_entry_tree,\r\n(register_size == REGISTER_32_SIZE) ? hf_elf_sh_size : hf_elf64_sh_size,\r\ntvb, offset, register_size, machine_encoding);\r\nif (register_size == REGISTER_32_SIZE) {\r\nsegment_size = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\n} else {\r\nsegment_size = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntoh64(tvb, offset) : tvb_get_letoh64(tvb, offset);\r\n}\r\noffset += register_size;\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_link, tvb, offset, 4, machine_encoding);\r\noffset += 4;\r\nproto_tree_add_item(sh_entry_tree, hf_elf_sh_info, tvb, offset, 4, machine_encoding);\r\noffset += 4;\r\nproto_tree_add_item(sh_entry_tree,\r\n(register_size == REGISTER_32_SIZE) ? hf_elf_sh_addralign : hf_elf64_sh_addralign,\r\ntvb, offset, register_size, machine_encoding);\r\noffset += register_size;\r\nproto_tree_add_item(sh_entry_tree,\r\n(register_size == REGISTER_32_SIZE) ? hf_elf_sh_entsize : hf_elf64_sh_entsize,\r\ntvb, offset, register_size, machine_encoding);\r\nif (register_size == REGISTER_32_SIZE) {\r\nsh_entsize = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntohl(tvb, offset) : tvb_get_letohl(tvb, offset);\r\n} else {\r\nsh_entsize = (machine_encoding == ENC_BIG_ENDIAN) ?\r\ntvb_get_ntoh64(tvb, offset) : tvb_get_letoh64(tvb, offset);\r\n}\r\noffset += register_size;\r\nif (segment_size > 0 && sh_type != 8) {\r\nfile_size += segment_size;\r\nsegment_info[area_counter].offset = segment_offset;\r\nsegment_info[area_counter].size = segment_size;\r\nsegment_info[area_counter].name = section_name;\r\narea_counter += 1;\r\nsegment_tree = proto_tree_add_subtree(sh_entry_tree, tvb, value_guard(segment_offset),\r\nvalue_guard(segment_size), ett_elf_segment, &segment_item, "Segment");\r\nif (g_strcmp0(section_name, ".eh_frame") == 0) {\r\nnext_offset = dissect_eh_frame(tvb, pinfo, segment_tree,\r\nvalue_guard(segment_offset), value_guard(segment_size), register_size,\r\nmachine_encoding);\r\nif (next_offset != (gint) (segment_offset + segment_size))\r\nexpert_add_info(pinfo, segment_item, &ei_invalid_segment_size);\r\n} else if (g_strcmp0(section_name, ".eh_frame_hdr") == 0) {\r\nnext_offset = dissect_eh_frame_hdr(tvb, pinfo, segment_tree,\r\nvalue_guard(segment_offset), value_guard(segment_size), register_size,\r\nmachine_encoding);\r\nif (next_offset != (gint) (segment_offset + segment_size))\r\nexpert_add_info(pinfo, segment_item, &ei_invalid_segment_size);\r\n} else if (sh_type == 0x06) {\r\nif (sh_entsize > 0) {\r\nnext_offset = value_guard(segment_offset);\r\nfor (i = 1; i < (segment_size / sh_entsize) + 1; i += 1) {\r\nentry_tree = proto_tree_add_subtree_format(segment_tree, tvb, next_offset,\r\nvalue_guard(sh_entsize), ett_symbol_table_entry, &entry_item, "Entry #%d", i);\r\nnext_offset = dissect_dynamic(tvb, pinfo, entry_tree, entry_item,\r\nnext_offset, register_size, machine_encoding);\r\nif (next_offset != (gint) (segment_offset + i * sh_entsize))\r\nexpert_add_info(pinfo, segment_item, &ei_invalid_entry_size);\r\n}\r\n}\r\n} else if (sh_type == 0x02 || sh_type == 0x0b) {\r\nif (sh_entsize > 0) {\r\nnext_offset = value_guard(segment_offset);\r\nfor (i = 1; i < (segment_size / sh_entsize) + 1; i += 1) {\r\nentry_tree = proto_tree_add_subtree_format(segment_tree, tvb, next_offset,\r\nvalue_guard(sh_entsize), ett_symbol_table_entry, &entry_item, "Entry #%d", i);\r\nnext_offset = dissect_symbol_table(tvb, pinfo, entry_tree, entry_item,\r\nnext_offset, register_size, machine_encoding, (sh_type == 0x02) ? strtab_offset : dynstr_offset,\r\nshoff, shnum, shentsize, shstrtab_offset);\r\nif (next_offset != (gint) (segment_offset + i * sh_entsize))\r\nexpert_add_info(pinfo, segment_item, &ei_invalid_entry_size);\r\n}\r\n}\r\n} else if (sh_type == 0x03) {\r\nnext_offset = value_guard(segment_offset);\r\ni = 1;\r\nwhile (next_offset < (gint) (segment_offset + segment_size)) {\r\ntvb_get_const_stringz(tvb, next_offset, &len);\r\nentry_item = proto_tree_add_item(segment_tree, hf_elf_string, tvb, next_offset, len, ENC_ASCII | ENC_NA);\r\nproto_item_append_text(entry_item, " (Number: %u, Index: %u, Length: %u)", (guint) i, (guint) (next_offset - segment_offset), len - 1);\r\nnext_offset += len;\r\ni += 1;\r\n}\r\n} else {\r\nif (sh_entsize > 0) {\r\nnext_offset = value_guard(segment_offset);\r\nfor (i = 1; i < (segment_size / sh_entsize) + 1; i += 1) {\r\nproto_tree_add_bytes_format(segment_tree, hf_elf_entry_bytes, tvb, next_offset,\r\nvalue_guard(sh_entsize), NULL, "Entry #%d ", i);\r\nnext_offset += value_guard(sh_entsize);\r\n}\r\n}\r\n}\r\n}\r\n}\r\ngenerated_tree = proto_tree_add_subtree(main_tree, tvb, 0, 0, ett_elf_info, &generated_item, "Infos");\r\nPROTO_ITEM_SET_GENERATED(generated_item);\r\nblackhole_tree = proto_tree_add_subtree(generated_tree, tvb, 0, 0, ett_elf_black_holes, NULL, "Backholes");\r\noverlapping_tree = proto_tree_add_subtree(generated_tree, tvb, 0, 0, ett_elf_overlapping, NULL, "Overlapping");\r\nfor (i = 0; i < area_counter; i += 1) {\r\nsegment_info_t tmp_segment;\r\nsegment_info_t *min_offset_segment;\r\nmin_offset_segment = &segment_info[i];\r\nfor (i_next = i + 1; i_next < area_counter; i_next += 1) {\r\nif (min_offset_segment->offset <= segment_info[i_next].offset) continue;\r\ntmp_segment = *min_offset_segment;\r\n*min_offset_segment = segment_info[i_next];\r\nsegment_info[i_next] = tmp_segment;\r\n}\r\n}\r\nfor (i = 1; i < area_counter; i += 1) {\r\nif (segment_info[i - 1].offset + segment_info[i - 1].size < segment_info[i].offset) {\r\nlen = (guint) (segment_info[i].offset - segment_info[i - 1].offset - segment_info[i - 1].size);\r\nti = proto_tree_add_uint_format(blackhole_tree, hf_elf_blackhole_size, tvb, value_guard(segment_info[i].offset - len), 1, len,\r\n"Blackhole between: %s and %s, size: %u", segment_info[i - 1].name, segment_info[i].name, len);\r\nproto_item_set_len(ti, len);\r\n} else if (segment_info[i - 1].offset + segment_info[i - 1].size > segment_info[i].offset) {\r\nlen = (guint) (segment_info[i - 1].offset + segment_info[i - 1].size - segment_info[i].offset);\r\nti = proto_tree_add_uint_format(overlapping_tree, hf_elf_overlapping_size, tvb, value_guard(segment_info[i - 1].offset + segment_info[i - 1].size - len), 1, len,\r\n"Overlapping between: %s and %s, size: %u", segment_info[i - 1].name, segment_info[i].name, len);\r\nproto_item_set_len(ti, len);\r\nfile_size -= len;\r\n}\r\n}\r\nif (segment_info[area_counter - 1].offset + segment_info[area_counter - 1].size < tvb_captured_length(tvb)) {\r\nlen = tvb_captured_length(tvb) - (guint) (segment_info[area_counter - 1].offset - segment_info[area_counter - 1].size);\r\nti = proto_tree_add_uint_format(blackhole_tree, hf_elf_blackhole_size, tvb,\r\nvalue_guard(segment_info[area_counter - 1].offset +\r\nsegment_info[area_counter - 1].size), 1,\r\nlen, "Blackhole between: %s and <EOF>, size: %u",\r\nsegment_info[area_counter - 1].name, len);\r\nproto_item_set_len(ti, len);\r\n}\r\nproto_tree_add_uint(generated_tree, hf_elf_file_size, tvb, 0, 0, tvb_captured_length(tvb));\r\nproto_tree_add_uint(generated_tree, hf_elf_header_segment_size, tvb, 0, 0, (guint)file_size);\r\nproto_tree_add_uint(generated_tree, hf_elf_blackholes_size, tvb, 0, 0, tvb_captured_length(tvb) - (guint)file_size);\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ncol_add_str(pinfo->cinfo, COL_INFO, "(ELF)");\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\ndissect_elf_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nreturn dissect_elf(tvb, pinfo, tree, NULL) > 0;\r\n}\r\nvoid\r\nproto_register_elf(void)\r\n{\r\nmodule_t *module;\r\nexpert_module_t *expert_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_elf_magic_bytes,\r\n{ "Magic Bytes", "elf.magic_bytes",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_file_size,\r\n{ "File size", "elf.file_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_header_segment_size,\r\n{ "Header size + all segment size", "elf.header_segment_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_blackholes_size,\r\n{ "Total blackholes size", "elf.blackholes_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_blackhole_size,\r\n{ "Blackhole size", "elf.blackhole_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\n"Blackhole size between sections or program headers", HFILL }\r\n},\r\n{ &hf_elf_overlapping_size,\r\n{ "Overlapping size", "elf.overlapping_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\n"Overlapping size between sections or program headers", HFILL }\r\n},\r\n{ &hf_elf_segment,\r\n{ "Segment", "elf.segment",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_entry_bytes,\r\n{ "Entry", "elf.entry_bytes",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_file_class,\r\n{ "File Class", "elf.file_class",\r\nFT_UINT8, BASE_HEX, VALS(class_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_data_encoding,\r\n{ "Data Encoding", "elf.data_encoding",\r\nFT_UINT8, BASE_HEX, VALS(data_encoding_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_file_version,\r\n{ "File Version", "elf.file_version",\r\nFT_UINT8, BASE_HEX, VALS(version_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_os_abi,\r\n{ "OS ABI", "elf.os_abi",\r\nFT_UINT8, BASE_HEX | BASE_EXT_STRING, &os_abi_vals_ext, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_abi_version,\r\n{ "ABI Version", "elf.abi_version",\r\nFT_UINT8, BASE_HEX_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_file_padding,\r\n{ "File Padding", "elf.file_padding",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_type,\r\n{ "Type", "elf.type",\r\nFT_UINT16, BASE_HEX, VALS(type_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_machine,\r\n{ "Machine", "elf.machine",\r\nFT_UINT16, BASE_HEX | BASE_EXT_STRING, &machine_vals_ext, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_version,\r\n{ "Version", "elf.version",\r\nFT_UINT32, BASE_HEX, VALS(version_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_entry,\r\n{ "Entry", "elf.entry",\r\nFT_UINT32, BASE_HEX, NULL, 0x00,\r\n"This member gives the virtual address to which the system first transfers control, thus starting the process. If the file has no associated entry point, this member holds zero. ", HFILL }\r\n},\r\n{ &hf_elf64_entry,\r\n{ "Entry", "elf.entry64",\r\nFT_UINT64, BASE_HEX, NULL, 0x00,\r\n"This member gives the virtual address to which the system first transfers control, thus starting the process. If the file has no associated entry point, this member holds zero. ", HFILL }\r\n},\r\n{ &hf_elf_phoff,\r\n{ "Program Header Table File Offset", "elf.phoff",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"This member holds the program header table's file offset in bytes. If the file has no program header table, this member holds zero.", HFILL }\r\n},\r\n{ &hf_elf64_phoff,\r\n{ "Program Header Table File Offset", "elf.phoff64",\r\nFT_UINT64, BASE_DEC_HEX, NULL, 0x00,\r\n"This member holds the program header table's file offset in bytes. If the file has no program header table, this member holds zero.", HFILL }\r\n},\r\n{ &hf_elf_shoff,\r\n{ "Section Header Table File Offset", "elf.shoff",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"This member holds the section header table's file offset in bytes. If the file has no section header table, this member holds zero.", HFILL }\r\n},\r\n{ &hf_elf64_shoff,\r\n{ "Section Header Table File Offset", "elf.shoff64",\r\nFT_UINT64, BASE_DEC_HEX, NULL, 0x00,\r\n"This member holds the section header table's file offset in bytes. If the file has no section header table, this member holds zero.", HFILL }\r\n},\r\n{ &hf_elf_flags,\r\n{ "Flags", "elf.flags",\r\nFT_UINT32, BASE_HEX, NULL, 0x00,\r\n"This member holds processor-specific flags associated with the file. Flag names take the form EF_machine_flag.", HFILL }\r\n},\r\n{ &hf_elf_ehsize,\r\n{ "ELF Header Size", "elf.ehsize",\r\nFT_UINT16, BASE_DEC_HEX, NULL, 0x00,\r\n"This member holds the ELF header's size in bytes.", HFILL }\r\n},\r\n{ &hf_elf_phentsize,\r\n{ "Entry Size in Program Header Table", "elf.phentsize",\r\nFT_UINT16, BASE_DEC_HEX, NULL, 0x00,\r\n"This member holds the size in bytes of one entry in the file's program header table; all entries are the same size.", HFILL }\r\n},\r\n{ &hf_elf_phnum,\r\n{ "Number of Entries in the Program Header Table", "elf.phnum",\r\nFT_UINT16, BASE_DEC_HEX, NULL, 0x00,\r\n"This member holds the number of entries in the program header table. Thus the product of e_phentsize and e_phnum gives the table's size in bytes. If a file has no program header table, e_phnum holds the value zero.", HFILL }\r\n},\r\n{ &hf_elf_shentsize,\r\n{ "Entry Size in Section Header Table", "elf.shentsize",\r\nFT_UINT16, BASE_DEC_HEX, NULL, 0x00,\r\n"This member holds a section header's size in bytes. A section header is one entry in the section header table; all entries are the same size.", HFILL }\r\n},\r\n{ &hf_elf_shnum,\r\n{ "Number of Entries in the Section Header Table", "elf.shnum",\r\nFT_UINT16, BASE_DEC_HEX, NULL, 0x00,\r\n"This member holds the number of entries in the section header table. Thus the product of e_shentsize and e_shnum gives the section header table's size in bytes. If a file has no section header table, e_shnum holds the value zero.", HFILL }\r\n},\r\n{ &hf_elf_shstrndx,\r\n{ "Section Header Table String Index", "elf.shstrndx",\r\nFT_UINT16, BASE_DEC_HEX, NULL, 0x00,\r\n"This member holds the section header table index of the entry associated with the section name string table. If the file has no section name string table, this member holds the value SHN_UNDEF.", HFILL }\r\n},\r\n{ &hf_elf_p_type,\r\n{ "Element Type", "elf.p_type",\r\nFT_UINT32, BASE_HEX_DEC, VALS(p_type_vals), 0x00,\r\n"This member tells what kind of segment this array element describes or how to interpret the array element's information.", HFILL }\r\n},\r\n{ &hf_elf_p_type_operating_system_specific,\r\n{ "Element Type: Operating System Specific", "elf.p_type",\r\nFT_UINT32, BASE_HEX_DEC, NULL, 0x00,\r\n"This member tells what kind of segment this array element describes or how to interpret the array element's information.", HFILL }\r\n},\r\n{ &hf_elf_p_type_processor_specific,\r\n{ "Element Type: Processor Specific", "elf.p_type",\r\nFT_UINT32, BASE_HEX_DEC, NULL, 0x00,\r\n"This member tells what kind of segment this array element describes or how to interpret the array element's information.", HFILL }\r\n},\r\n{ &hf_elf_p_offset,\r\n{ "File Offset", "elf.p_offset",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"This member gives the offset from the beginning of the file at which the first byte of the segment resides.", HFILL }\r\n},\r\n{ &hf_elf64_p_offset,\r\n{ "File Offset", "elf.p_offset64",\r\nFT_UINT64, BASE_DEC_HEX, NULL, 0x00,\r\n"This member gives the offset from the beginning of the file at which the first byte of the segment resides.", HFILL }\r\n},\r\n{ &hf_elf_p_vaddr,\r\n{ "Virtual Address", "elf.p_vaddr",\r\nFT_UINT32, BASE_HEX, NULL, 0x00,\r\n"This member gives the virtual address at which the first byte of the segment resides in memory.", HFILL }\r\n},\r\n{ &hf_elf64_p_vaddr,\r\n{ "Virtual Address", "elf.p_vaddr64",\r\nFT_UINT64, BASE_HEX, NULL, 0x00,\r\n"This member gives the virtual address at which the first byte of the segment resides in memory.", HFILL }\r\n},\r\n{ &hf_elf_p_paddr,\r\n{ "Physical Address", "elf.p_paddr",\r\nFT_UINT32, BASE_HEX, NULL, 0x00,\r\n"On systems for which physical addressing is relevant, this member is reserved for the segment's physical address. Because System V ignores physical addressing for application programs, this member has unspecified contents for executable files and shared objects.", HFILL }\r\n},\r\n{ &hf_elf64_p_paddr,\r\n{ "Physical Address", "elf.p_paddr64",\r\nFT_UINT64, BASE_HEX, NULL, 0x00,\r\n"On systems for which physical addressing is relevant, this member is reserved for the segment's physical address. Because System V ignores physical addressing for application programs, this member has unspecified contents for executable files and shared objects.", HFILL }\r\n},\r\n{ &hf_elf_p_filesz,\r\n{ "File Image Size", "elf.p_filesz",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"This member gives the number of bytes in the file image of the segment; it may be zero.", HFILL }\r\n},\r\n{ &hf_elf64_p_filesz,\r\n{ "File Image Size", "elf.p_filesz64",\r\nFT_UINT64, BASE_DEC_HEX, NULL, 0x00,\r\n"This member gives the number of bytes in the file image of the segment; it may be zero.", HFILL }\r\n},\r\n{ &hf_elf_p_memsz,\r\n{ "Memory Image Size", "elf.p_memsz",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"This member gives the number of bytes in the memory image of the segment; it may be zero.", HFILL }\r\n},\r\n{ &hf_elf64_p_memsz,\r\n{ "Memory Image Size", "elf.p_memsz64",\r\nFT_UINT64, BASE_DEC_HEX, NULL, 0x00,\r\n"This member gives the number of bytes in the memory image of the segment; it may be zero.", HFILL }\r\n},\r\n{ &hf_elf_p_flags_processor_specific,\r\n{ "Processor Specific Flags", "elf.p_flags.maskproc",\r\nFT_BOOLEAN, 32, NULL, 0xF0000000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_p_flags_operating_system_specific,\r\n{ "Operating System Specific Flags", "elf.p_flags.maskos",\r\nFT_BOOLEAN, 32, NULL, 0x0FF00000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_p_flags_reserved,\r\n{ "Reserrved Flags", "elf.p_flags.reserved",\r\nFT_BOOLEAN, 32, NULL, 0x000FFFF8,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_p_flags_read,\r\n{ "Read Flag", "elf.p_flags.read",\r\nFT_BOOLEAN, 32, NULL, 0x00000004,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_p_flags_write,\r\n{ "Write Flag", "elf.p_flags.write",\r\nFT_BOOLEAN, 32, NULL, 0x00000002,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_p_flags_execute,\r\n{ "Execute Flag", "elf.p_flags.execute",\r\nFT_BOOLEAN, 32, NULL, 0x00000001,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_p_align,\r\n{ "Align", "elf.p_align",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"This member gives the value to which the segments are aligned in memory and in the file. Values 0 and 1 mean no alignment is required. Otherwise, p_align should be a positive, integral power of 2, and p_vaddr should equal p_offset, modulo p_align.", HFILL }\r\n},\r\n{ &hf_elf64_p_align,\r\n{ "Align", "elf.p_align64",\r\nFT_UINT64, BASE_DEC_HEX, NULL, 0x00,\r\n"This member gives the value to which the segments are aligned in memory and in the file. Values 0 and 1 mean no alignment is required. Otherwise, p_align should be a positive, integral power of 2, and p_vaddr should equal p_offset, modulo p_align.", HFILL }\r\n},\r\n{ &hf_elf_sh_name,\r\n{ "Name Index", "elf.sh_name",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"Section Name. Its value is an index into the section header string table section, giving the location of a null-terminated string.", HFILL }\r\n},\r\n{ &hf_elf_sh_type,\r\n{ "Type", "elf.sh_type",\r\nFT_UINT32, BASE_HEX_DEC | BASE_EXT_STRING, &sh_type_vals_ext, 0x00,\r\n"This member categorizes the section's contents and semantics.", HFILL }\r\n},\r\n{ &hf_elf_sh_type_operating_system_specific,\r\n{ "Type: Operating System Specific", "elf.sh_type",\r\nFT_UINT32, BASE_HEX_DEC, NULL, 0x00,\r\n"This member categorizes the section's contents and semantics.", HFILL }\r\n},\r\n{ &hf_elf_sh_type_processor_specific,\r\n{ "Type: Procesor Specific", "elf.sh_type",\r\nFT_UINT32, BASE_HEX_DEC, NULL, 0x00,\r\n"This member categorizes the section's contents and semantics.", HFILL }\r\n},\r\n{ &hf_elf_sh_type_user_specific,\r\n{ "Type: User Specific", "elf.sh_type",\r\nFT_UINT32, BASE_HEX_DEC, NULL, 0x00,\r\n"This member categorizes the section's contents and semantics.", HFILL }\r\n},\r\n{ &hf_elf_sh_flags_processor_specific,\r\n{ "Processor Specific Flags", "elf.sh_flags.maskproc",\r\nFT_BOOLEAN, 32, NULL, 0xF0000000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_sh_flags_operating_system_specific,\r\n{ "Operating System Specific Flags", "elf.sh_flags.maskos",\r\nFT_BOOLEAN, 32, NULL, 0x0FF00000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_sh_flags_reserved,\r\n{ "Reserved", "elf.sh_flags.reserved",\r\nFT_BOOLEAN, 32, NULL, 0x000FF800,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_sh_flags_tls,\r\n{ "TLS Flag", "elf.sh_flags.tls",\r\nFT_BOOLEAN, 32, NULL, 0x00000400,\r\n"This section holds Thread-Local Storage, meaning that each separate execution flow has its own distinct instance of this data. Implementations need not support this flag.", HFILL }\r\n},\r\n{ &hf_elf_sh_flags_group,\r\n{ "Group Flag", "elf.sh_flags.group",\r\nFT_BOOLEAN, 32, NULL, 0x00000200,\r\n"This section is a member (perhaps the only one) of a section group.", HFILL }\r\n},\r\n{ &hf_elf_sh_flags_os_nonconforming,\r\n{ "OS NonConforming Flag", "elf.sh_flags.os_nonconforming",\r\nFT_BOOLEAN, 32, NULL, 0x00000100,\r\n"This section requires special OS-specific processing to avoid incorrect behavior.", HFILL }\r\n},\r\n{ &hf_elf_sh_flags_link_order,\r\n{ "Link Order Flag", "elf.sh_flags.link_order",\r\nFT_BOOLEAN, 32, NULL, 0x00000080,\r\n"This flag adds special ordering requirements for link editors.", HFILL }\r\n},\r\n{ &hf_elf_sh_flags_info_link,\r\n{ "Info Link Flag", "elf.sh_flags.info_link",\r\nFT_BOOLEAN, 32, NULL, 0x00000040,\r\n"The sh_info field of this section header holds a section header table index.", HFILL }\r\n},\r\n{ &hf_elf_sh_flags_strings,\r\n{ "Strings Flag", "elf.sh_flags.strings",\r\nFT_BOOLEAN, 32, NULL, 0x00000020,\r\n"The data elements in the section consist of null-terminated character strings. The size of each character is specified in the section header's sh_entsize field.", HFILL }\r\n},\r\n{ &hf_elf_sh_flags_merge,\r\n{ "Merge Flag", "elf.sh_flags.merge",\r\nFT_BOOLEAN, 32, NULL, 0x00000010,\r\n"The data in the section may be merged to eliminate duplication.", HFILL }\r\n},\r\n{ &hf_elf_sh_flags_reserved_8,\r\n{ "Reserved", "elf.sh_flags.reserved.8",\r\nFT_BOOLEAN, 32, NULL, 0x00000008,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_sh_flags_exec_instr,\r\n{ "Exec Instr Flag", "elf.sh_flags.exec_instr",\r\nFT_BOOLEAN, 32, NULL, 0x00000004,\r\n"The section contains executable machine instructions.", HFILL }\r\n},\r\n{ &hf_elf_sh_flags_alloc,\r\n{ "Alloc Flag", "elf.sh_flags.alloc",\r\nFT_BOOLEAN, 32, NULL, 0x00000002,\r\n"The section occupies memory during process execution. Some control sections do not reside in the memory image of an object file; this attribute is off for those sections.", HFILL }\r\n},\r\n{ &hf_elf_sh_flags_write,\r\n{ "Write Flag", "elf.sh_flags.write",\r\nFT_BOOLEAN, 32, NULL, 0x00000001,\r\n"The section contains data that should be writable during process execution.", HFILL }\r\n},\r\n{ &hf_elf_sh_addr,\r\n{ "Address", "elf.sh_addr",\r\nFT_UINT32, BASE_HEX, NULL, 0x00,\r\n"If the section will appear in the memory image of a process, this member gives the address at which the section's first byte should reside. Otherwise, the member contains 0.", HFILL }\r\n},\r\n{ &hf_elf64_sh_addr,\r\n{ "Address", "elf.sh_addr64",\r\nFT_UINT64, BASE_HEX, NULL, 0x00,\r\n"If the section will appear in the memory image of a process, this member gives the address at which the section's first byte should reside. Otherwise, the member contains 0.", HFILL }\r\n},\r\n{ &hf_elf_sh_offset,\r\n{ "File Offset", "elf.sh_offset",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"This member's value gives the byte offset from the beginning of the file to the first byte in the section. One section type, SHT_NOBITS, occupies no space in the file, and its sh_offset member locates the conceptual placement in the file.", HFILL }\r\n},\r\n{ &hf_elf64_sh_offset,\r\n{ "File Offset", "elf.sh_offset64",\r\nFT_UINT64, BASE_DEC_HEX, NULL, 0x00,\r\n"This member's value gives the byte offset from the beginning of the file to the first byte in the section. One section type, SHT_NOBITS, occupies no space in the file, and its sh_offset member locates the conceptual placement in the file.", HFILL }\r\n},\r\n{ &hf_elf_sh_size,\r\n{ "Size", "elf.sh_size",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"This member gives the section's size in bytes.", HFILL }\r\n},\r\n{ &hf_elf64_sh_size,\r\n{ "Size", "elf.sh_size64",\r\nFT_UINT64, BASE_DEC_HEX, NULL, 0x00,\r\n"This member gives the section's size in bytes.", HFILL }\r\n},\r\n{ &hf_elf_sh_link,\r\n{ "Link Index", "elf.sh_link",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"This member holds a section header table index link, whose interpretation depends on the section type.", HFILL }\r\n},\r\n{ &hf_elf_sh_info,\r\n{ "Info", "elf.sh_info",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"This member holds extra information, whose interpretation depends on the section type.", HFILL }\r\n},\r\n{ &hf_elf_sh_addralign,\r\n{ "Address Alignment", "elf.sh_addralign",\r\nFT_UINT32, BASE_HEX, NULL, 0x00,\r\n"Some sections have address alignment constraints. Currently, only 0 and positive integral powers of two are allowed. Values 0 and 1 mean the section has no alignment constraints.", HFILL }\r\n},\r\n{ &hf_elf64_sh_addralign,\r\n{ "Address Alignment", "elf.sh_addralign64",\r\nFT_UINT64, BASE_HEX, NULL, 0x00,\r\n"Some sections have address alignment constraints. Currently, only 0 and positive integral powers of two are allowed. Values 0 and 1 mean the section has no alignment constraints.", HFILL }\r\n},\r\n{ &hf_elf_sh_entsize,\r\n{ "Entry Size", "elf.sh_entsize",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"Some sections hold a table of fixed-size entries, such as a symbol table. For such a section, this member gives the size in bytes of each entry. The member contains 0 if the section does not hold a table of fixed-size entries.", HFILL }\r\n},\r\n{ &hf_elf64_sh_entsize,\r\n{ "Entry Size", "elf.sh_entsize64",\r\nFT_UINT64, BASE_DEC_HEX, NULL, 0x00,\r\n"Some sections hold a table of fixed-size entries, such as a symbol table. For such a section, this member gives the size in bytes of each entry. The member contains 0 if the section does not hold a table of fixed-size entries.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_length,\r\n{ "Length", "elf.eh_frame.length",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"Length of CIE. Zero indicates a terminator, 0xffffffff means that "\r\n"the Extended Length field contains the actual length.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_extended_length,\r\n{ "Extended Length", "elf.eh_frame.extended_length",\r\nFT_UINT64, BASE_DEC_HEX, NULL, 0x00,\r\n"Extended Length of CIE.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_cie_id,\r\n{ "CIE ID", "elf.eh_frame.cie_id",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"A 4 byte unsigned value that is used to distinguish CIE records from FDE records. This value shall always be 0, which indicates this record is a CIE.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_version,\r\n{ "Version", "elf.eh_frame.version",\r\nFT_UINT8, BASE_DEC_HEX, NULL, 0x00,\r\n"A 1 byte value that identifies the version number of the frame information structure. This value shall be 1.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_augmentation_string,\r\n{ "Augmentation String", "elf.eh_frame.augmentation_string",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x00,\r\n"This value is a NUL terminated string that identifies the augmentation to the CIE or to the FDEs associated with this CIE. A zero length string indicates that no augmentation data is present. The augmentation string is case sensitive.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_code_alignment_factor,\r\n{ "Code Alignment Factor", "elf.eh_frame.code_alignment_factor",\r\nFT_UINT64, BASE_DEC, NULL, 0x00,\r\n"An unsigned LEB128 encoded value that is factored out of all advance location instructions that are associated with this CIE or its FDEs. This value shall be multiplied by the delta argument of an adavance location instruction to obtain the new location value.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_data_alignment_factor,\r\n{ "Data Alignment Factor", "elf.eh_frame.data_alignment_factor",\r\nFT_INT64, BASE_DEC, NULL, 0x00,\r\n"A signed LEB128 encoded value that is factored out of all offset instructions that are associated with this CIE or its FDEs. This value shall be multiplied by the register offset argument of an offset instruction to obtain the new offset value.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_return_address_register,\r\n{ "Return Address Register", "elf.eh_frame.return_address_register",\r\nFT_UINT64, BASE_DEC, NULL, 0x00,\r\n"An unsigned LEB128 constant that indicates which column in the rule table represents the return address of the function. Note that this column might not correspond to an actual machine register.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_augmentation_length,\r\n{ "Augmentation Length", "elf.eh_frame.augmentation_length",\r\nFT_UINT64, BASE_DEC, NULL, 0x00,\r\n"An unsigned LEB128 encoded value indicating the length in bytes of the Augmentation Data. This field is only present if the Augmentation String contains the character 'z'.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_augmentation_data,\r\n{ "Augmentation Data", "elf.eh_frame.augmentation_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\n"A block of data whose contents are defined by the contents of the Augmentation String as described below. This field is only present if the Augmentation String contains the character 'z'.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_initial_instructions,\r\n{ "Initial Instructions", "elf.eh_frame.initial_instructions",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\n"Initial set of Call Frame Instructions.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_fde_length,\r\n{ "Length", "elf.eh_frame.fde.length",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"Length of FDE. Zero indicates a terminator, 0xffffffff means that "\r\n"the Extended Length field contains the actual length.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_fde_extended_length,\r\n{ "Extended Length", "elf.eh_frame.fde.extended_length",\r\nFT_UINT64, BASE_DEC_HEX, NULL, 0x00,\r\n"Extended Length of FDE.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_fde_cie_pointer,\r\n{ "CIE Pointer", "elf.eh_frame.fde.cie_pointer",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"A 4 byte unsigned value that when subtracted from the offset of the the CIE Pointer in the current FDE yields the offset of the start of the associated CIE. This value shall never be 0.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_fde_pc_begin,\r\n{ "PC Begin", "elf.eh_frame.fde.pc_begin",\r\nFT_UINT32, BASE_HEX, NULL, 0x00,\r\n"An encoded value that indicates the address of the initial location associated with this FDE. The encoding format is specified in the Augmentation Data.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_fde_pc_range,\r\n{ "PC Range", "elf.eh_frame.fde.pc_range",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\n"An absolute value that indicates the number of bytes of instructions associated with this FDE.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_fde_augmentation_length,\r\n{ "Augmentation Length", "elf.eh_frame.fde.augmentation_length",\r\nFT_UINT64, BASE_DEC, NULL, 0x00,\r\n"An unsigned LEB128 encoded value indicating the length in bytes of the Augmentation Data.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_fde_augmentation_data,\r\n{ "Augmentation Data", "elf.eh_frame.fde.augmentation_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\n"Data as described by the Augmentation String in the CIE.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_fde_call_frame_instructions,\r\n{ "Call Frame Instructions", "elf.eh_frame.fde.call_frame_instructions",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\n"A set of Call Frame Instructions.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_hdr_version,\r\n{ "Version", "elf.eh_frame_hdr.version",\r\nFT_UINT8, BASE_DEC_HEX, NULL, 0x00,\r\n"Version of the .eh_frame_hdr format. This value shall be 1.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_hdr_exception_frame_pointer_encoding,\r\n{ "Exception Frame Pointer Encoding", "elf.eh_frame_hdr.eh_frame_ptr_enc",\r\nFT_UINT8, BASE_DEC_HEX, NULL, 0x00,\r\n"The encoding format of the eh_frame_ptr field.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_hdr_fde_count_encoding,\r\n{ "FDE Count Encoding", "elf.eh_frame_hdr.fde_count_enc",\r\nFT_UINT8, BASE_DEC_HEX, NULL, 0x00,\r\n"The encoding format of the fde_count field. A value of DW_EH_PE_omit indicates the binary search table is not present.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_hdr_binary_search_table_encoding,\r\n{ "Binary Search Table Encoding", "elf.eh_frame_hdr.binary_search_table_encoding",\r\nFT_UINT8, BASE_DEC_HEX, NULL, 0x00,\r\n"The encoding format of the entries in the binary search table. A value of DW_EH_PE_omit indicates the binary search table is not present.", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_hdr_eh_frame_ptr,\r\n{ "Exception Frame Pointer", "elf.eh_frame_hdr.eh_frame_ptr",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\n"Start of .eh_frame pointer", HFILL }\r\n},\r\n{ &hf_elf_eh_frame_hdr_fde_count,\r\n{ "Number of FDE entries", "elf.eh_frame_hdr.fde_count",\r\nFT_UINT64, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_eh_frame_hdr_binary_search_table_entry_initial_location,\r\n{ "Initial location", "elf.eh_frame_hdr.binary_search_table_entry.initial_location",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_eh_frame_hdr_binary_search_table_entry_address,\r\n{ "Address", "elf.eh_frame_hdr.binary_search_table_entry.address",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_symbol_table_name_index,\r\n{ "Name Index", "elf.symbol_table.name_index",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_symbol_table_info,\r\n{ "Info", "elf.symbol_table.info",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_symbol_table_info_bind,\r\n{ "Bind", "elf.symbol_table.info.bind",\r\nFT_UINT8, BASE_HEX, VALS(symbol_table_info_bind_vals), 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_symbol_table_info_type,\r\n{ "Type", "elf.symbol_table.info.type",\r\nFT_UINT8, BASE_HEX | BASE_EXT_STRING, &symbol_table_info_type_vals_ext, 0x0F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_symbol_table_other,\r\n{ "Other", "elf.symbol_table.other",\r\nFT_UINT8, BASE_HEX, VALS(symbol_table_other_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_symbol_table_shndx,\r\n{ "Releated Section Header Index", "elf.symbol_table.shndx",\r\nFT_UINT16, BASE_HEX | BASE_RANGE_STRING, RVALS(symbol_table_shndx_rvals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_symbol_table_value,\r\n{ "Value", "elf.symbol_table.value",\r\nFT_UINT32, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf64_symbol_table_value,\r\n{ "Value", "elf.symbol_table.value64",\r\nFT_UINT64, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_symbol_table_size,\r\n{ "Size", "elf.symbol_table.size",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf64_symbol_table_size,\r\n{ "Size", "elf.symbol_table.size64",\r\nFT_UINT64, BASE_DEC_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_dynamic_tag,\r\n{ "Tag", "elf.dynamic.tag",\r\nFT_UINT32, BASE_HEX | BASE_RANGE_STRING, RVALS(dynamic_tag_rvals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_dynamic_value,\r\n{ "Value", "elf.dynamic.value",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_dynamic_pointer,\r\n{ "Pointer", "elf.dynamic.pointer",\r\nFT_UINT32, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_dynamic_ignored,\r\n{ "Ignored", "elf.dynamic.ignored",\r\nFT_UINT32, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf_dynamic_unspecified,\r\n{ "Unspecified", "elf.dynamic.unspecified",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf64_dynamic_tag,\r\n{ "Tag", "elf.dynamic.tag64",\r\nFT_UINT64, BASE_HEX , NULL , 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf64_dynamic_value,\r\n{ "Value", "elf.dynamic.value64",\r\nFT_UINT64, BASE_DEC_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf64_dynamic_pointer,\r\n{ "Pointer", "elf.dynamic.pointer64",\r\nFT_UINT64, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf64_dynamic_ignored,\r\n{ "Ignored", "elf.dynamic.ignored64",\r\nFT_UINT64, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_elf64_dynamic_unspecified,\r\n{ "Unspecified", "elf.dynamic.unspecified64",\r\nFT_UINT64, BASE_DEC_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_dwarf_omit,\r\n{ "DW_EH_PE_omit", "elf.dwarf.omit",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\n"Used to indicate that no value is present.", HFILL }\r\n},\r\n{ &hf_dwarf_upper,\r\n{ "DWARF Exception Header application", "elf.dwarf.upper",\r\nFT_UINT8, BASE_HEX, VALS(eh_dwarf_upper), 0xF0,\r\n"The upper 4 bits indicate how the value is to be applied.", HFILL }\r\n},\r\n{ &hf_dwarf_format,\r\n{ "DWARF Exception Header value format", "elf.dwarf.format",\r\nFT_UINT8, BASE_HEX, VALS(eh_dwarf_format), 0x0F,\r\n"The lower 4 bits indicate the format of the data.", HFILL }\r\n},\r\n{ &hf_elf_string,\r\n{ "String", "elf.string",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_invalid_segment_size, { "elf.invalid_segment_size", PI_PROTOCOL, PI_WARN, "Segment size is different then currently parsed bytes", EXPFILL }},\r\n{ &ei_invalid_entry_size, { "elf.invalid_entry_size", PI_PROTOCOL, PI_WARN, "Entry size is different then currently parsed bytes", EXPFILL }},\r\n{ &ei_cfi_extraneous_data, { "elf.cfi_extraneous_data", PI_PROTOCOL, PI_WARN, "Segment size is larger than CFI records combined", EXPFILL }},\r\n{ &ei_invalid_cie_length, { "elf.invalid_cie_length", PI_PROTOCOL, PI_ERROR, "CIE length is too small or larger than segment size", EXPFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_elf,\r\n&ett_elf_header,\r\n&ett_elf_program_header,\r\n&ett_elf_program_header_entry,\r\n&ett_elf_section_header,\r\n&ett_elf_section_header_entry,\r\n&ett_elf_segment,\r\n&ett_elf_cfi_record,\r\n&ett_elf_cie_entry,\r\n&ett_elf_fde_entry,\r\n&ett_elf_cie_terminator,\r\n&ett_elf_info,\r\n&ett_elf_black_holes,\r\n&ett_elf_overlapping,\r\n&ett_dwarf_encoding,\r\n&ett_binary_table,\r\n&ett_binary_table_entry,\r\n&ett_symbol_table_entry,\r\n&ett_symbol_table_info\r\n};\r\nproto_elf = proto_register_protocol("Executable and Linkable Format", "ELF", "elf");\r\nproto_register_field_array(proto_elf, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nelf_handle = register_dissector("elf", dissect_elf, proto_elf);\r\nmodule = prefs_register_protocol(proto_elf, NULL);\r\nprefs_register_static_text_preference(module, "version",\r\n"ELF version: 4.1 DRAFT",\r\n"Version of file-format supported by this dissector.");\r\nexpert_module = expert_register_protocol(proto_elf);\r\nexpert_register_field_array(expert_module, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_elf(void)\r\n{\r\ndissector_add_string("media_type", "application/x-executable", elf_handle);\r\ndissector_add_string("media_type", "application/x-coredump", elf_handle);\r\ndissector_add_string("media_type", "application/x-object", elf_handle);\r\ndissector_add_string("media_type", "application/x-sharedlib", elf_handle);\r\ndissector_add_uint("ftap_encap", 1234, elf_handle);\r\nheur_dissector_add("wtap_file", dissect_elf_heur, "ELF file", "elf_wtap", proto_elf, HEURISTIC_ENABLE);\r\n}
