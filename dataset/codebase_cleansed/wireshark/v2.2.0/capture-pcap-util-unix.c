GList *\r\nget_remote_interface_list(const char *hostname, const char *port,\r\nint auth_type, const char *username,\r\nconst char *passwd, int *err, char **err_str)\r\n{\r\nstruct pcap_rmtauth auth;\r\nchar source[PCAP_BUF_SIZE];\r\nchar errbuf[PCAP_ERRBUF_SIZE];\r\nGList *result;\r\nif (pcap_createsrcstr(source, PCAP_SRC_IFREMOTE, hostname, port,\r\nNULL, errbuf) == -1) {\r\n*err = CANT_GET_INTERFACE_LIST;\r\nif (err_str != NULL)\r\n*err_str = cant_get_if_list_error_message(errbuf);\r\nreturn NULL;\r\n}\r\nauth.type = auth_type;\r\nauth.username = g_strdup(username);\r\nauth.password = g_strdup(passwd);\r\nresult = get_interface_list_findalldevs_ex(source, &auth, err, err_str);\r\ng_free(auth.username);\r\ng_free(auth.password);\r\nreturn result;\r\n}\r\nGList *\r\nget_interface_list(int *err, char **err_str)\r\n{\r\nreturn get_interface_list_findalldevs(err, err_str);\r\n}\r\nstatic void\r\nsearch_for_if_cb(gpointer data, gpointer user_data)\r\n{\r\nstruct search_user_data *search_user_data = (struct search_user_data*)user_data;\r\nif_info_t *if_info = (if_info_t *)data;\r\nif (strcmp(if_info->name, search_user_data->name) == 0)\r\nsearch_user_data->if_info = if_info;\r\n}\r\nGList *\r\nget_interface_list(int *err, char **err_str)\r\n{\r\nGList *il = NULL;\r\ngint nonloopback_pos = 0;\r\nstruct ifreq *ifr, *last;\r\nstruct ifconf ifc;\r\nstruct ifreq ifrflags;\r\nint sock = socket(AF_INET, SOCK_DGRAM, 0);\r\nstruct search_user_data user_data;\r\npcap_t *pch;\r\nint len, lastlen;\r\nchar *buf;\r\nif_info_t *if_info;\r\nchar errbuf[PCAP_ERRBUF_SIZE];\r\ngboolean loopback;\r\nif (sock < 0) {\r\n*err = CANT_GET_INTERFACE_LIST;\r\nif (err_str != NULL) {\r\n*err_str = g_strdup_printf(\r\n"Can't get list of interfaces: error opening socket: %s",\r\ng_strerror(errno));\r\n}\r\nreturn NULL;\r\n}\r\nlastlen = 0;\r\nlen = 100 * sizeof(struct ifreq);\r\nfor ( ; ; ) {\r\nbuf = (char *)g_malloc(len);\r\nifc.ifc_len = len;\r\nifc.ifc_buf = buf;\r\nmemset (buf, 0, len);\r\nif (ioctl(sock, SIOCGIFCONF, &ifc) < 0) {\r\nif (errno != EINVAL || lastlen != 0) {\r\nif (err_str != NULL) {\r\n*err_str = g_strdup_printf(\r\n"Can't get list of interfaces: SIOCGIFCONF ioctl error: %s",\r\ng_strerror(errno));\r\n}\r\ngoto fail;\r\n}\r\n} else {\r\nif ((unsigned int) ifc.ifc_len < sizeof(struct ifreq)) {\r\nif (err_str != NULL) {\r\n*err_str = g_strdup(\r\n"Can't get list of interfaces: SIOCGIFCONF ioctl gave too small return buffer");\r\n}\r\ngoto fail;\r\n}\r\nif (ifc.ifc_len == lastlen)\r\nbreak;\r\nlastlen = ifc.ifc_len;\r\n}\r\nlen += 10 * sizeof(struct ifreq);\r\ng_free(buf);\r\n}\r\nifr = (struct ifreq *) ifc.ifc_req;\r\nlast = (struct ifreq *) ((char *) ifr + ifc.ifc_len);\r\nwhile (ifr < last) {\r\nif (strncmp(ifr->ifr_name, "dummy", 5) == 0 ||\r\nstrchr(ifr->ifr_name, ':') != NULL)\r\ngoto next;\r\nuser_data.name = ifr->ifr_name;\r\nuser_data.if_info = NULL;\r\ng_list_foreach(il, search_for_if_cb, &user_data);\r\nif (user_data.if_info != NULL) {\r\nif_info_add_address(user_data.if_info, &ifr->ifr_addr);\r\ngoto next;\r\n}\r\nmemset(&ifrflags, 0, sizeof ifrflags);\r\ng_strlcpy(ifrflags.ifr_name, ifr->ifr_name,\r\nsizeof ifrflags.ifr_name);\r\nif (ioctl(sock, SIOCGIFFLAGS, (char *)&ifrflags) < 0) {\r\nif (errno == ENXIO)\r\ngoto next;\r\nif (err_str != NULL) {\r\n*err_str = g_strdup_printf(\r\n"Can't get list of interfaces: SIOCGIFFLAGS error getting flags for interface %s: %s",\r\nifr->ifr_name, g_strerror(errno));\r\n}\r\ngoto fail;\r\n}\r\nif (!(ifrflags.ifr_flags & IFF_UP))\r\ngoto next;\r\npch = pcap_open_live(ifr->ifr_name, MIN_PACKET_SIZE, 0, 0,\r\nerrbuf);\r\nif (pch == NULL)\r\ngoto next;\r\npcap_close(pch);\r\nloopback = ((ifrflags.ifr_flags & IFF_LOOPBACK) ||\r\nstrncmp(ifr->ifr_name, "lo", 2) == 0);\r\nif_info = if_info_new(ifr->ifr_name, NULL, loopback);\r\nif_info_add_address(if_info, &ifr->ifr_addr);\r\nif (loopback)\r\nil = g_list_append(il, if_info);\r\nelse {\r\nil = g_list_insert(il, if_info, nonloopback_pos);\r\nnonloopback_pos++;\r\n}\r\nnext:\r\n#ifdef HAVE_SOCKADDR_SA_LEN\r\nifr = (struct ifreq *) ((char *) ifr +\r\n(ifr->ifr_addr.sa_len > sizeof(ifr->ifr_addr) ?\r\nifr->ifr_addr.sa_len : sizeof(ifr->ifr_addr)) +\r\nIFNAMSIZ);\r\n#else\r\nifr = (struct ifreq *) ((char *) ifr + sizeof(struct ifreq));\r\n#endif\r\n}\r\n#ifdef linux\r\npch = pcap_open_live("any", MIN_PACKET_SIZE, 0, 0, errbuf);\r\nif (pch != NULL) {\r\nif_info = if_info_new("any",\r\n"Pseudo-device that captures on all interfaces", FALSE);\r\nil = g_list_insert(il, if_info, -1);\r\npcap_close(pch);\r\n}\r\n#endif\r\ng_free(ifc.ifc_buf);\r\nclose(sock);\r\nif (il == NULL) {\r\n*err = 0;\r\nif (err_str != NULL)\r\n*err_str = NULL;\r\n}\r\nreturn il;\r\nfail:\r\nif (il != NULL)\r\nfree_interface_list(il);\r\ng_free(ifc.ifc_buf);\r\nclose(sock);\r\n*err = CANT_GET_INTERFACE_LIST;\r\nreturn NULL;\r\n}\r\ngchar *\r\ncant_get_if_list_error_message(const char *err_str)\r\n{\r\nreturn g_strdup_printf("Can't get list of interfaces: %s", err_str);\r\n}\r\nvoid\r\nrequest_high_resolution_timestamp(pcap_t *pcap_h)\r\n{\r\n#ifdef __APPLE__\r\nstatic gboolean initialized = FALSE;\r\nstatic int (*p_pcap_set_tstamp_precision)(pcap_t *, int);\r\nif (!initialized) {\r\np_pcap_set_tstamp_precision =\r\n(int (*)(pcap_t *, int))\r\ndlsym(RTLD_NEXT, "pcap_set_tstamp_precision");\r\ninitialized = TRUE;\r\n}\r\nif (p_pcap_set_tstamp_precision != NULL)\r\n(*p_pcap_set_tstamp_precision)(pcap_h, PCAP_TSTAMP_PRECISION_NANO);\r\n#else\r\npcap_set_tstamp_precision(pcap_h, PCAP_TSTAMP_PRECISION_NANO);\r\n#endif\r\n}\r\ngboolean\r\nhave_high_resolution_timestamp(pcap_t *pcap_h)\r\n{\r\n#ifdef __APPLE__\r\nstatic gboolean initialized = FALSE;\r\nstatic int (*p_pcap_get_tstamp_precision)(pcap_t *);\r\nif (!initialized) {\r\np_pcap_get_tstamp_precision =\r\n(int (*)(pcap_t *))\r\ndlsym(RTLD_NEXT, "pcap_get_tstamp_precision");\r\ninitialized = TRUE;\r\n}\r\nif (p_pcap_get_tstamp_precision != NULL)\r\nreturn (*p_pcap_get_tstamp_precision)(pcap_h) == PCAP_TSTAMP_PRECISION_NANO;\r\nelse\r\nreturn FALSE;\r\n#else\r\nreturn pcap_get_tstamp_precision(pcap_h) == PCAP_TSTAMP_PRECISION_NANO;\r\n#endif\r\n}\r\nif_capabilities_t *\r\nget_if_capabilities_local(interface_options *interface_opts, char **err_str)\r\n{\r\n#ifdef HAVE_PCAP_CREATE\r\nreturn get_if_capabilities_pcap_create(interface_opts, err_str);\r\n#else\r\nreturn get_if_capabilities_pcap_open_live(interface_opts, err_str);\r\n#endif\r\n}\r\nvoid\r\nget_compiled_caplibs_version(GString *str)\r\n{\r\ng_string_append(str, "with libpcap");\r\ng_string_append(str, ", ");\r\n#ifdef HAVE_LIBCAP\r\ng_string_append(str, "with POSIX capabilities");\r\n#ifdef _LINUX_CAPABILITY_VERSION\r\ng_string_append(str, " (Linux)");\r\n#endif\r\n#else\r\ng_string_append(str, "without POSIX capabilities");\r\n#endif\r\n#ifdef __linux__\r\ng_string_append(str, ", ");\r\n#if defined(HAVE_LIBNL1)\r\ng_string_append(str, "with libnl 1");\r\n#elif defined(HAVE_LIBNL2)\r\ng_string_append(str, "with libnl 2");\r\n#elif defined(HAVE_LIBNL3)\r\ng_string_append(str, "with libnl 3");\r\n#else\r\ng_string_append(str, "without libnl");\r\n#endif\r\n#endif\r\n}\r\nvoid\r\nget_runtime_caplibs_version(GString *str)\r\n{\r\ng_string_append_printf(str, "with ");\r\n#ifdef HAVE_PCAP_LIB_VERSION\r\ng_string_append(str, pcap_lib_version());\r\n#else\r\ng_string_append(str, "libpcap (version unknown)");\r\n#endif\r\n}\r\nvoid\r\nget_compiled_caplibs_version(GString *str)\r\n{\r\ng_string_append(str, "without libpcap");\r\n}\r\nvoid\r\nget_runtime_caplibs_version(GString *str _U_)\r\n{\r\n}
