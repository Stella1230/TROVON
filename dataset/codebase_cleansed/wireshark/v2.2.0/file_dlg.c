GtkWidget *\r\nfile_selection_new(const gchar *title, GtkWindow *parent,\r\nfile_selection_action_t action)\r\n{\r\nGtkWidget *win;\r\nGtkFileChooserAction gtk_action;\r\nconst gchar *ok_button_text;\r\nswitch (action) {\r\ncase FILE_SELECTION_OPEN:\r\ngtk_action = GTK_FILE_CHOOSER_ACTION_OPEN;\r\nok_button_text = GTK_STOCK_OPEN;\r\nbreak;\r\ncase FILE_SELECTION_READ_BROWSE:\r\ngtk_action = GTK_FILE_CHOOSER_ACTION_OPEN;\r\nok_button_text = GTK_STOCK_OK;\r\nbreak;\r\ncase FILE_SELECTION_SAVE:\r\ngtk_action = GTK_FILE_CHOOSER_ACTION_SAVE;\r\nok_button_text = WIRESHARK_STOCK_SAVE;\r\nbreak;\r\ncase FILE_SELECTION_WRITE_BROWSE:\r\ngtk_action = GTK_FILE_CHOOSER_ACTION_SAVE;\r\nok_button_text = GTK_STOCK_OK;\r\nbreak;\r\ncase FILE_SELECTION_CREATE_FOLDER:\r\ngtk_action = GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER;\r\nok_button_text = GTK_STOCK_OK;\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\ngtk_action = (GtkFileChooserAction)-1;\r\nok_button_text = NULL;\r\nbreak;\r\n}\r\nwin = gtk_file_chooser_dialog_new(title, parent, gtk_action,\r\nGTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,\r\nok_button_text, GTK_RESPONSE_ACCEPT,\r\nNULL);\r\ngtk_dialog_set_alternative_button_order(GTK_DIALOG(win),\r\nGTK_RESPONSE_ACCEPT,\r\nGTK_RESPONSE_CANCEL,\r\n-1);\r\nif (action == FILE_SELECTION_SAVE)\r\ngtk_file_chooser_set_do_overwrite_confirmation(GTK_FILE_CHOOSER(win), TRUE);\r\nif (last_open_dir) {\r\nfile_selection_set_current_folder(win, last_open_dir);\r\n}\r\nreturn win;\r\n}\r\ngboolean\r\nfile_selection_set_current_folder(GtkWidget *fs, const gchar *filename)\r\n{\r\ngboolean ret;\r\nsize_t filename_len = strlen(filename);\r\ngchar *new_filename;\r\nif (filename[filename_len -1] == G_DIR_SEPARATOR\r\n#ifdef _WIN32\r\n&& filename_len > 3)\r\n#else\r\n&& filename_len > 1)\r\n#endif\r\n{\r\nnew_filename = g_strdup(filename);\r\nnew_filename[filename_len-1] = '\0';\r\n} else {\r\nnew_filename = g_strdup(filename);\r\n}\r\nret = gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(fs\r\nstatic gchar *filesel_get_link(const gchar *link_file)\r\n{\r\nWIN32_FIND_DATAW wfd;\r\nIShellLinkW *psl;\r\nIPersistFile *ppf;\r\nwchar_t *wlink_file;\r\nwchar_t wtarget[MAX_PATH];\r\ngchar *target = NULL;\r\nwtarget[0] = 0L;\r\nCoInitialize(NULL);\r\nif (S_OK == CoCreateInstance(&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,\r\n&IID_IShellLinkW, (void **)&psl)) {\r\nif (S_OK == IShellLinkW_QueryInterface(psl, &IID_IPersistFile,\r\n(void **)&ppf)) {\r\nwlink_file = g_utf8_to_utf16(link_file, -1, NULL, NULL, NULL);\r\nif (S_OK == IPersistFile_Load(ppf, wlink_file, STGM_READ)) {\r\nif (S_OK == IShellLinkW_GetPath(psl, wtarget, MAX_PATH, &wfd,\r\nSLGP_UNCPRIORITY)) {\r\ntarget = g_utf16_to_utf8(wtarget, -1, NULL, NULL, NULL);\r\n}\r\n}\r\nIPersistFile_Release(ppf);\r\ng_free(wlink_file);\r\n}\r\nIShellLinkW_Release(psl);\r\n}\r\nCoUninitialize();\r\nreturn target;\r\n}\r\ngchar *\r\nfile_selection_run(GtkWidget *fs)\r\n{\r\ngchar *cf_name;\r\n#ifdef _WIN32\r\ngchar *target;\r\nconst gchar *ext;\r\n#endif\r\nfor (;;) {\r\nif (gtk_dialog_run(GTK_DIALOG(fs)) != GTK_RESPONSE_ACCEPT) {\r\nwindow_destroy(fs);\r\nreturn NULL;\r\n}\r\ncf_name = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(fs));\r\nif (test_for_directory(cf_name) == EISDIR) {\r\nset_last_open_dir(cf_name);\r\ng_free(cf_name);\r\nfile_selection_set_current_folder(fs, get_last_open_dir());\r\ncontinue;\r\n}\r\n#ifdef _WIN32\r\nif ((ext = strrchr(cf_name, '.')) && g_ascii_strcasecmp(ext, ".lnk") == 0) {\r\ntarget = filesel_get_link(cf_name);\r\nif (target != NULL) {\r\ng_free(cf_name);\r\nif (test_for_directory(target)) {\r\nset_last_open_dir(target);\r\ng_free(target);\r\nfile_selection_set_current_folder(fs, get_last_open_dir());\r\ncontinue;\r\n}\r\ncf_name = target;\r\n}\r\n}\r\n#endif\r\nbreak;\r\n}\r\nreturn cf_name;\r\n}\r\ngboolean\r\nfile_target_unwritable_ui(GtkWidget *chooser_w, char *cf_name)\r\n{\r\nGtkWidget *msg_dialog;\r\ngchar *display_basename;\r\ngint response;\r\nws_statb64 statbuf;\r\nif (ws_stat64(cf_name, &statbuf) == -1) {\r\nreturn TRUE;\r\n}\r\n#ifdef HAVE_STAT_ST_FLAGS\r\nif (statbuf.st_flags & UF_IMMUTABLE) {\r\ndisplay_basename = g_filename_display_basename(cf_name);\r\nmsg_dialog = gtk_message_dialog_new(GTK_WINDOW(chooser_w),\r\n(GtkDialogFlags)(GTK_DIALOG_MODAL|GTK_DIALOG_DESTROY_WITH_PARENT),\r\nGTK_MESSAGE_QUESTION,\r\nGTK_BUTTONS_NONE,\r\n#ifdef __APPLE__\r\n"The file \"%s\" is locked.",\r\n#else\r\n"The file \"%s\" is immutable.",\r\n#endif\r\ndisplay_basename);\r\ng_free(display_basename);\r\n} else\r\n#endif\r\nif ((statbuf.st_mode & (S_IWUSR|S_IWGRP|S_IWOTH)) == 0) {\r\ndisplay_basename = g_filename_display_basename(cf_name);\r\nmsg_dialog = gtk_message_dialog_new(GTK_WINDOW(chooser_w),\r\n(GtkDialogFlags)(GTK_DIALOG_MODAL|GTK_DIALOG_DESTROY_WITH_PARENT),\r\nGTK_MESSAGE_QUESTION,\r\nGTK_BUTTONS_NONE,\r\n"The file \"%s\" is read-only.",\r\ndisplay_basename);\r\ng_free(display_basename);\r\n} else {\r\nmsg_dialog = NULL;\r\n}\r\nif (msg_dialog != NULL) {\r\ngtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(msg_dialog),\r\n"Do you want to overwrite it anyway?");\r\ngtk_dialog_add_buttons(GTK_DIALOG(msg_dialog),\r\n"Overwrite", GTK_RESPONSE_ACCEPT,\r\n"Don't overwrite", GTK_RESPONSE_REJECT,\r\nNULL);\r\ngtk_dialog_set_default_response(GTK_DIALOG(msg_dialog), GTK_RESPONSE_REJECT);\r\nresponse = gtk_dialog_run(GTK_DIALOG(msg_dialog));\r\ngtk_widget_destroy(msg_dialog);\r\nif (response != GTK_RESPONSE_ACCEPT) {\r\nreturn FALSE;\r\n}\r\n#ifdef HAVE_STAT_ST_FLAGS\r\nif (statbuf.st_flags & UF_IMMUTABLE) {\r\nchflags(cf_name, statbuf.st_flags & ~UF_IMMUTABLE);\r\n}\r\n#endif\r\n}\r\nreturn TRUE;\r\n}\r\nvoid\r\nfile_selection_browse(GtkWidget *file_bt, GtkWidget *file_te, const char *label, file_selection_action_t action)\r\n{\r\nGtkWidget *caller = gtk_widget_get_toplevel(file_bt);\r\nGtkWidget *fs;\r\ngchar *f_name;\r\nfs = file_selection_new(label, GTK_WINDOW(caller), action);\r\ng_object_set_data(G_OBJECT(fs), PRINT_FILE_TE_KEY, file_te);\r\ng_object_set_data(G_OBJECT(fs), E_FS_CALLER_PTR_KEY, caller);\r\ng_object_set_data(G_OBJECT(caller), E_FILE_SEL_DIALOG_PTR_KEY, fs);\r\ng_signal_connect(fs, "destroy", G_CALLBACK(file_selection_browse_destroy_cb),\r\nfile_te);\r\nif (gtk_dialog_run(GTK_DIALOG(fs)) == GTK_RESPONSE_ACCEPT)\r\n{\r\nf_name = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(fs));\r\ngtk_entry_set_text(GTK_ENTRY(file_te), f_name);\r\ng_free(f_name);\r\n}\r\nwindow_destroy(fs);\r\n}\r\nstatic void\r\nfile_selection_browse_destroy_cb(GtkWidget *win, GtkWidget* parent_te)\r\n{\r\nGtkWidget *caller;\r\ncaller = (GtkWidget *)g_object_get_data(G_OBJECT(win), E_FS_CALLER_PTR_KEY);\r\ng_object_set_data(G_OBJECT(caller), E_FILE_SEL_DIALOG_PTR_KEY, NULL);\r\ngtk_widget_grab_focus(parent_te);\r\n}\r\nvoid\r\nset_last_open_dir(const char *dirname)\r\n{\r\nsize_t len;\r\ngchar *new_last_open_dir;\r\nif (dirname && dirname[0]) {\r\nlen = strlen(dirname);\r\nif (dirname[len-1] == G_DIR_SEPARATOR) {\r\nnew_last_open_dir = g_strconcat(dirname, NULL);\r\n}\r\nelse {\r\nnew_last_open_dir = g_strconcat(dirname,\r\nG_DIR_SEPARATOR_S, NULL);\r\n}\r\n} else {\r\nnew_last_open_dir = NULL;\r\n}\r\ng_free(last_open_dir);\r\nlast_open_dir = new_last_open_dir;\r\n}\r\nchar *\r\nget_last_open_dir(void)\r\n{\r\nreturn last_open_dir;\r\n}
