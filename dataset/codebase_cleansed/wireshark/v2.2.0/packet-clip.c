static int\r\ndissect_clip(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *fh_item;\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_SRC, "N/A");\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_DST, "N/A");\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "CLIP");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Classical IP frame");\r\nfh_item = proto_tree_add_item(tree, proto_clip, tvb, 0, 0, ENC_NA);\r\nexpert_add_info(pinfo, fh_item, &ei_no_link_info);\r\ncall_dissector(ip_handle, tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_clip(void)\r\n{\r\nstatic gint *ett[] = {\r\n&ett_clip,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_no_link_info, { "clip.no_link_info", PI_PROTOCOL, PI_NOTE, "No link information available", EXPFILL }},\r\n};\r\nexpert_module_t* expert_clip;\r\nproto_clip = proto_register_protocol("Classical IP frame", "CLIP", "clip");\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_clip = expert_register_protocol(proto_clip);\r\nexpert_register_field_array(expert_clip, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_clip(void)\r\n{\r\ndissector_handle_t clip_handle;\r\nip_handle = find_dissector_add_dependency("ip", proto_clip);\r\nclip_handle = create_dissector_handle(dissect_clip, proto_clip);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_LINUX_ATM_CLIP, clip_handle);\r\nregister_capture_dissector("wtap_encap", WTAP_ENCAP_LINUX_ATM_CLIP, capture_ip, proto_clip);\r\n}
