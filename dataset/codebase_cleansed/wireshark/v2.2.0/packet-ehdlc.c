static int\r\ndissect_ehdlc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 4;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "EHDLC");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nproto_item *ti = NULL;\r\nproto_tree *ehdlc_tree = NULL;\r\nguint16 len, msg_type;\r\ntvbuff_t *next_tvb;\r\nguint16 control;\r\ngboolean is_response = FALSE, is_extended = TRUE;\r\ngint header_length = 2;\r\nmsg_type = tvb_get_guint8(tvb, offset);\r\nlen = tvb_get_guint8(tvb, offset+1);\r\n#if 0\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s ",\r\nval_to_str(msg_type, ehdlc_protocol_vals,\r\n"unknown 0x%02x"));\r\n#endif\r\nif (tree) {\r\nti = proto_tree_add_protocol_format(tree, proto_ehdlc,\r\ntvb, offset, MIN(len, tvb_captured_length_remaining(tvb,offset)),\r\n"Ericsson HDLC protocol, type: %s",\r\nval_to_str(msg_type, ehdlc_protocol_vals,\r\n"unknown 0x%02x"));\r\nehdlc_tree = proto_item_add_subtree(ti, ett_ehdlc);\r\nproto_tree_add_item(ehdlc_tree, hf_ehdlc_protocol,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\n#if 0\r\nproto_tree_add_item(ehdlc_tree, hf_ehdlc_sapi,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ehdlc_tree, hf_ehdlc_c_r,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\n#endif\r\nproto_tree_add_item(ehdlc_tree, hf_ehdlc_data_len,\r\ntvb, offset+1, 1, ENC_BIG_ENDIAN);\r\n}\r\ncontrol = dissect_xdlc_control(tvb, offset+2, pinfo, ehdlc_tree, hf_ehdlc_control,\r\nett_ehdlc_control, &ehdlc_cf_items, &ehdlc_cf_items_ext,\r\nNULL, NULL, is_response, is_extended, FALSE);\r\nheader_length += XDLC_CONTROL_LEN(control, is_extended);\r\nif (XDLC_IS_INFORMATION(control)) {\r\nnext_tvb = tvb_new_subset_length(tvb, offset+header_length,\r\nlen-header_length);\r\nswitch (msg_type) {\r\ncase 0x20:\r\nif (len <= 4)\r\nbreak;\r\ncall_dissector(sub_handles[SUB_RSL], next_tvb, pinfo, tree);\r\nbreak;\r\ncase 0xbc:\r\ncase 0xdc:\r\ncase 0xa0:\r\ncase 0xc0:\r\nif (len <= 4)\r\nbreak;\r\ncall_dissector(sub_handles[SUB_OML], next_tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\ncall_dissector(sub_handles[SUB_DATA], next_tvb, pinfo, tree);\r\nbreak;\r\n}\r\n} else if (control == (XDLC_U | XDLC_XID)) {\r\nproto_tree_add_item(ehdlc_tree, hf_ehdlc_xid_payload,\r\ntvb, offset+header_length,\r\nlen-header_length, ENC_NA);\r\n}\r\nif (len == 0)\r\nlen = 1;\r\noffset += len;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ehdlc(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ehdlc_data_len,\r\n{ "DataLen", "ehdlc.data_len",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"The length of the data (in bytes)", HFILL }\r\n},\r\n{ &hf_ehdlc_protocol,\r\n{ "Protocol", "ehdlc.protocol",\r\nFT_UINT8, BASE_HEX, VALS(ehdlc_protocol_vals), 0x0,\r\n"The HDLC Sub-Protocol", HFILL }\r\n},\r\n#if 0\r\n{ &hf_ehdlc_sapi,\r\n{ "SAPI", "ehdlc.sapi",\r\nFT_UINT8, BASE_DEC, NULL, 0x1f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ehdlc_c_r,\r\n{ "C/R", "ehdlc.c_r",\r\nFT_UINT8, BASE_HEX, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n#endif\r\n{ &hf_ehdlc_xid_payload,\r\n{ "XID Payload", "ehdlc.xid_payload",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ehdlc_control,\r\n{ "Control Field", "ehdlc.control",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ehdlc_n_r,\r\n{ "N(R)", "ehdlc.control.n_r",\r\nFT_UINT16, BASE_DEC, NULL, XDLC_N_R_EXT_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ehdlc_n_s,\r\n{ "N(S)", "ehdlc.control.n_s",\r\nFT_UINT16, BASE_DEC, NULL, XDLC_N_S_EXT_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ehdlc_p,\r\n{ "Poll", "ehdlc.control.p",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), XDLC_P_F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ehdlc_p_ext,\r\n{ "Poll", "ehdlc.control.p",\r\nFT_BOOLEAN, 16, TFS(&tfs_set_notset), XDLC_P_F_EXT,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ehdlc_f,\r\n{ "Final", "ehdlc.control.f",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), XDLC_P_F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ehdlc_f_ext,\r\n{ "Final", "ehdlc.control.f",\r\nFT_BOOLEAN, 16, TFS(&tfs_set_notset), XDLC_P_F_EXT,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ehdlc_s_ftype,\r\n{ "Supervisory frame type", "ehdlc.control.s_ftype",\r\nFT_UINT16, BASE_HEX, VALS(stype_vals), XDLC_S_FTYPE_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ehdlc_u_modifier_cmd,\r\n{ "Command", "ehdlc.control.u_modifier_cmd",\r\nFT_UINT8, BASE_HEX, VALS(modifier_vals_cmd), XDLC_U_MODIFIER_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ehdlc_u_modifier_resp,\r\n{ "Response", "ehdlc.control.u_modifier_resp",\r\nFT_UINT8, BASE_HEX, VALS(modifier_vals_resp), XDLC_U_MODIFIER_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ehdlc_ftype_i,\r\n{ "Frame Type", "ehdlc.control.ftype",\r\nFT_UINT16, BASE_HEX, VALS(ftype_vals), XDLC_I_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ehdlc_ftype_s_u,\r\n{ "Frame Type", "ehdlc.control.ftype",\r\nFT_UINT8, BASE_HEX, VALS(ftype_vals), XDLC_S_U_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ehdlc_ftype_s_u_ext,\r\n{ "Frame Type", "ehdlc.control.ftype",\r\nFT_UINT16, BASE_HEX, VALS(ftype_vals), XDLC_S_U_MASK,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ehdlc,\r\n&ett_ehdlc_control,\r\n};\r\nproto_ehdlc =\r\nproto_register_protocol("Ericsson HDLC",\r\n"Ericsson HDLC as used in A-bis over IP", "ehdlc");\r\nproto_register_field_array(proto_ehdlc, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nehdlc_handle = register_dissector("ehdlc", dissect_ehdlc, proto_ehdlc);\r\n}\r\nvoid\r\nproto_reg_handoff_ehdlc(void)\r\n{\r\nsub_handles[SUB_RSL] = find_dissector_add_dependency("gsm_abis_rsl", proto_ehdlc);\r\nsub_handles[SUB_OML] = find_dissector_add_dependency("gsm_abis_oml", proto_ehdlc);\r\nsub_handles[SUB_DATA] = find_dissector("data");\r\ndissector_add_uint("l2tp.pw_type", L2TPv3_PROTOCOL_ERICSSON, ehdlc_handle);\r\n}
