static void\r\ndissect_nv_pairs(tvbuff_t *tvb, proto_tree *fcgi_tree, gint offset, guint16 len)\r\n{\r\ngint end_offset = offset + len;\r\nwhile (offset < end_offset) {\r\ngint start_offset = offset;\r\nguint32 namelen;\r\nguint32 valuelen;\r\nchar *name;\r\nchar *value;\r\nnamelen = tvb_get_guint8(tvb, offset);\r\nif ((namelen & 0x80) == 0) {\r\noffset += 1;\r\n} else {\r\nnamelen = tvb_get_ntohl(tvb, offset) & 0x7FFFFFFF;\r\noffset += 4;\r\n}\r\nvaluelen = tvb_get_guint8(tvb, offset);\r\nif ((valuelen & 0x80) == 0) {\r\noffset += 1;\r\n} else {\r\nvaluelen = tvb_get_ntohl(tvb, offset) & 0x7FFFFFFF;\r\noffset += 4;\r\n}\r\nname = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, namelen, ENC_ASCII);\r\noffset += namelen;\r\nif (valuelen > 0) {\r\nvalue = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, valuelen, ENC_ASCII);\r\noffset += valuelen;\r\nproto_tree_add_string_format(fcgi_tree, hf_fcgi_nv_name, tvb, start_offset, offset - start_offset,\r\nname, "%s = %s", name, value);\r\n} else {\r\nproto_tree_add_string_format(fcgi_tree, hf_fcgi_nv_name, tvb, start_offset, offset - start_offset,\r\nname, "%s", name);\r\n}\r\n}\r\n}\r\nstatic int\r\ndissect_begin_request(tvbuff_t *tvb, proto_tree *fcgi_tree, gint offset, guint16 len)\r\n{\r\nproto_tree *br_tree;\r\nbr_tree = proto_tree_add_subtree(fcgi_tree, tvb, offset, len, ett_fcgi_begin_request, NULL, "Begin Request:");\r\nproto_tree_add_item(br_tree, hf_fcgi_begin_request_role, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(br_tree, hf_fcgi_begin_request_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(br_tree, hf_fcgi_begin_request_keep_conn, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\noffset += 5;\r\nreturn offset;\r\n}\r\nstatic void\r\ndissect_abort_request(tvbuff_t *tvb, proto_tree *fcgi_tree, gint offset, guint16 len)\r\n{\r\nproto_tree_add_subtree(fcgi_tree, tvb, offset, len, ett_fcgi_abort_request, NULL, "Abort Request:");\r\nreturn;\r\n}\r\nstatic int\r\ndissect_end_request(tvbuff_t *tvb, proto_tree *fcgi_tree, gint offset, guint16 len)\r\n{\r\nproto_tree *er_tree;\r\ner_tree = proto_tree_add_subtree(fcgi_tree, tvb, offset, len, ett_fcgi_end_request, NULL, "End Request:");\r\nproto_tree_add_item(er_tree, hf_fcgi_end_request_app_status, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(er_tree, hf_fcgi_end_request_protocol_status, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\noffset += 3;\r\nreturn offset;\r\n}\r\nstatic void\r\ndissect_params(tvbuff_t *tvb, proto_tree *fcgi_tree, gint offset, guint16 len)\r\n{\r\nproto_tree *p_tree;\r\np_tree = proto_tree_add_subtree(fcgi_tree, tvb, offset, len, ett_fcgi_params, NULL, "Params:");\r\ndissect_nv_pairs(tvb, p_tree, offset, len);\r\nreturn;\r\n}\r\nstatic void\r\ndissect_get_values(tvbuff_t *tvb, proto_tree *fcgi_tree, gint offset, guint16 len)\r\n{\r\nproto_tree *gv_tree;\r\ngv_tree = proto_tree_add_subtree(fcgi_tree, tvb, offset, len, ett_fcgi_params, NULL, "Get Values:");\r\ndissect_nv_pairs(tvb, gv_tree, offset, len);\r\nreturn;\r\n}\r\nstatic void\r\ndissect_get_values_result(tvbuff_t *tvb, proto_tree *fcgi_tree, gint offset, guint16 len)\r\n{\r\nproto_tree *gvr_tree;\r\ngvr_tree = proto_tree_add_subtree(fcgi_tree, tvb, offset, len, ett_fcgi_params, NULL, "Get Values:");\r\ndissect_nv_pairs(tvb, gvr_tree, offset, len);\r\nreturn;\r\n}\r\nstatic int\r\ndissect_fcgi_record(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ngint offset = 0;\r\nguint8 type;\r\ntype = tvb_get_guint8(tvb, 1);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "FCGI");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL,\r\nval_to_str(type, record_types, "Unknown (%u)"));\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\nif (tree) {\r\nproto_item *ti;\r\nproto_tree *fcgi_tree;\r\nguint16 clen;\r\nguint8 plen;\r\nti = proto_tree_add_item(tree, proto_fcgi, tvb, 0, -1, ENC_NA);\r\nproto_item_append_text(ti, " (%s)",\r\nval_to_str(type, record_types, "Unknown (%u)"));\r\nfcgi_tree = proto_item_add_subtree(ti, ett_fcgi);\r\nproto_tree_add_item(fcgi_tree, hf_fcgi_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(fcgi_tree, hf_fcgi_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(fcgi_tree, hf_fcgi_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nclen = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(fcgi_tree, hf_fcgi_content_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nplen = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(fcgi_tree, hf_fcgi_padding_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\noffset += 1;\r\nswitch (type)\r\n{\r\ncase FCGI_BEGIN_REQUEST:\r\ndissect_begin_request(tvb, fcgi_tree, offset, clen);\r\noffset += clen;\r\nbreak;\r\ncase FCGI_ABORT_REQUEST:\r\ndissect_abort_request(tvb, fcgi_tree, offset, clen);\r\noffset += clen;\r\nbreak;\r\ncase FCGI_END_REQUEST:\r\ndissect_end_request(tvb, fcgi_tree, offset, clen);\r\noffset += clen;\r\nbreak;\r\ncase FCGI_PARAMS:\r\ndissect_params(tvb, fcgi_tree, offset, clen);\r\noffset += clen;\r\nbreak;\r\ncase FCGI_GET_VALUES:\r\ndissect_get_values(tvb, fcgi_tree, offset, clen);\r\noffset += clen;\r\nbreak;\r\ncase FCGI_GET_VALUES_RESULT:\r\ndissect_get_values_result(tvb, fcgi_tree, offset, clen);\r\noffset += clen;\r\nbreak;\r\ndefault:\r\nif (clen > 0) {\r\nproto_tree_add_item(fcgi_tree, hf_fcgi_content_data, tvb, offset, clen, ENC_NA);\r\noffset += clen;\r\n}\r\nbreak;\r\n}\r\nif (plen > 0) {\r\nproto_tree_add_item(fcgi_tree, hf_fcgi_padding_data, tvb, offset, plen, ENC_NA);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic guint\r\nget_fcgi_record_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nreturn 8 + tvb_get_ntohs(tvb, offset + 4) + tvb_get_guint8(tvb, offset + 6);\r\n}\r\nstatic int\r\ndissect_fcgi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, tree, TRUE, 8, get_fcgi_record_len, dissect_fcgi_record, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_fcgi(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_fcgi_version,\r\n{ "Version", "fcgi.version",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_fcgi_type,\r\n{ "Type", "fcgi.type",\r\nFT_UINT8, BASE_DEC, VALS(record_types), 0x0, NULL, HFILL } },\r\n{ &hf_fcgi_id,\r\n{ "Request ID", "fcgi.id",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_fcgi_content_length,\r\n{ "Content Length", "fcgi.content.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_fcgi_padding_length,\r\n{ "Padding Length", "fcgi.padding.length",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_fcgi_content_data,\r\n{ "Content Data", "fcgi.content.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_fcgi_padding_data,\r\n{ "Padding Data", "fcgi.padding.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_fcgi_begin_request_role,\r\n{ "Role", "fcgi.begin_request.role",\r\nFT_UINT16, BASE_DEC, VALS(application_roles), 0x0, NULL, HFILL } },\r\n{ &hf_fcgi_begin_request_flags,\r\n{ "Flags", "fcgi.begin_request.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_fcgi_begin_request_keep_conn,\r\n{ "FCGI_KEEP_CONN", "fcgi.begin_request.keep_conn",\r\nFT_BOOLEAN, 8, NULL, FCGI_KEEP_CONN, NULL, HFILL } },\r\n{ &hf_fcgi_end_request_app_status,\r\n{ "Application Status", "fcgi.end_request.app_status",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_fcgi_end_request_protocol_status,\r\n{ "Protocol Status", "fcgi.end_request.protocol_status",\r\nFT_UINT32, BASE_DEC, VALS(protocol_statuses), 0x0, NULL, HFILL } },\r\n{ &hf_fcgi_nv_name,\r\n{ "NV Pair name", "fcgi.nv_name",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n};\r\nstatic gint *ett[] = {\r\n&ett_fcgi,\r\n&ett_fcgi_begin_request,\r\n&ett_fcgi_abort_request,\r\n&ett_fcgi_end_request,\r\n&ett_fcgi_params\r\n};\r\nmodule_t *fcgi_module;\r\nproto_fcgi = proto_register_protocol("FastCGI", "FCGI", "fcgi");\r\nproto_register_field_array(proto_fcgi, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nfcgi_module = prefs_register_protocol(proto_fcgi, proto_reg_handoff_fcgi);\r\nprefs_register_uint_preference(fcgi_module,\r\n"tcp.port",\r\n"TCP port for FCGI",\r\n"Set the TCP port for FastCGI traffic",\r\n10,\r\n&tcp_port);\r\nfcgi_handle = register_dissector("fcgi", dissect_fcgi, proto_fcgi);\r\n}\r\nvoid\r\nproto_reg_handoff_fcgi(void)\r\n{\r\nstatic gboolean initialized = FALSE;\r\nstatic guint saved_tcp_port;\r\nif (!initialized) {\r\ndissector_add_for_decode_as("tcp.port", fcgi_handle);\r\ninitialized = TRUE;\r\n} else if (saved_tcp_port != 0) {\r\ndissector_delete_uint("tcp.port", saved_tcp_port, fcgi_handle);\r\n}\r\nif (tcp_port != 0) {\r\ndissector_add_uint("tcp.port", tcp_port, fcgi_handle);\r\n}\r\nsaved_tcp_port = tcp_port;\r\n}
