static void dissect_bt_tunneled_proto(proto_tree* tree, tvbuff_t* tvb, packet_info* pinfo, int hfid, h248_curr_info_t* i _U_, void* d _U_) {
tvbuff_t* bctp_tvb = NULL;
gint8 appclass;
gboolean pc;
gint32 tag;
asn1_ctx_t asn1_ctx;
asn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);
get_ber_identifier(tvb, 0, &appclass, &pc, &tag);
if (tag == BER_UNI_TAG_OCTETSTRING) {
dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, 0, hfid, &bctp_tvb);
if (bctp_tvb) {
call_dissector(bctp_dissector,bctp_tvb,pinfo,tree);
}
} else {
proto_tree_add_item(tree,hfid,tvb,0,-1,ENC_NA);
}
}
void proto_reg_handoff_q1950(void) {
bctp_dissector = find_dissector_add_dependency("bctp", proto_q1950);
}
void proto_register_q1950(void) {
static hf_register_info hf[] = {
{ &hf_h248_pkg_BCP,
{ "BCP (Bearer characteristics package)", "h248.BCP",
FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_BCP_BNCChar,
{ "BNCChar (BNC Characteristics)", "h248.bcp.bncchar",
FT_UINT32, BASE_HEX|BASE_EXT_STRING, &bearer_network_connection_characteristics_vals_ext, 0, "BNC Characteristics", HFILL }
},
{ &hf_h248_pkg_BNCCT,
{ "BNCCT (Bearer network connection cut-through package)", "h248.BNCCT",
FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_BNCCT_prop,
{ "Bearer network connection cut-through capability", "h248.bcp.bncct",
FT_UINT32, BASE_HEX, VALS(h248_pkg_BNCCT_prop_vals), 0, "This property allows the MGC to ask the MG when the cut through of a bearer will occur, early or late.", HFILL }
},
{ &hf_h248_pkg_GB,
{ "GB (Generic bearer connection)", "h248.GB",
FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_GB_BNCChange,
{ "BNCChange", "h248.GB.BNCChang",
FT_BYTES, BASE_NONE, NULL, 0, "This event occurs whenever a change to a Bearer Network connection occurs", HFILL }
},
{ &hf_h248_pkg_GB_BNCChange_type,
{ "Type", "h248.GB.BNCChang.Type",
FT_UINT32, BASE_HEX, VALS(h248_pkg_GB_BNCChange_type_vals), 0, NULL, HFILL }
},
{ &hf_h248_pkg_GB_EstBNC,
{ "Type", "h248.GB.BNCChang.EstBNC",
FT_BYTES, BASE_NONE, NULL, 0, "This signal triggers the bearer control function to send bearer establishment signalling", HFILL }
},
{ &hf_h248_pkg_GB_ModBNC,
{ "Type", "h248.GB.BNCChang.ModBNC",
FT_BYTES, BASE_NONE, NULL, 0, "This signal triggers the bearer control function to send bearer modification", HFILL }
},
{ &hf_h248_pkg_GB_RelBNC,
{ "RelBNC", "h248.GB.BNCChang.RelBNC",
FT_BYTES, BASE_NONE, NULL, 0, "This signal triggers the bearer control function to send bearer release", HFILL }
},
{ &hf_h248_pkg_GB_RelBNC_Generalcause,
{ "Generalcause", "h248.GB.BNCChang.RelBNC.Generalcause",
FT_UINT32, BASE_HEX, VALS(h248_pkg_GB_RelBNC_Generalcause_vals), 0, "This indicates the general reason for the Release", HFILL }
},
{ &hf_h248_pkg_GB_RelBNC_Failurecause,
{ "Failurecause", "h248.GB.BNCChang.RelBNC.Failurecause",
FT_BYTES, BASE_NONE, NULL, 0, "The Release Cause is the value generated by the Released equipment", HFILL }
},
{ &hf_h248_pkg_GB_RelBNC_Reset,
{ "RelBNC", "h248.GB.BNCChang.RelBNC.Reset",
FT_BOOLEAN, BASE_NONE, NULL, 0x0, "This signal triggers the bearer control function to send bearer release", HFILL }
},
{ &hf_h248_pkg_RI,
{ "RI (Reuse idle package)", "h248.RI",
FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_RII,
{ "Reuse Idle Indication", "h248.bcp.rii",
FT_UINT32, BASE_HEX, VALS(h248_pkg_RII_vals), 0, "This property indicates that the provided bearer network connection relates to an Idle Bearer.", HFILL }
},
{ &hf_h248_pkg_bt,
{ "BT (Bearer control Tunneling)", "h248.BT",
FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_bt_tunopt,
{ "Tunnelling Options", "h248.BT.TunOpt",
FT_UINT32, BASE_DEC, VALS(h248_pkg_bt_tunopt_vals), 0, NULL, HFILL }
},
{ &hf_h248_pkg_bt_tind,
{ "tind (Tunnel INDication)", "h248.BT.TIND",
FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_bt_bit,
{ "Bearer Information Transport", "h248.BT.BIT",
FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_bcg,
{ "bcg (Basic call progress tones generator with directionality)", "h248.bcg",
FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_bcg_sig_bdt_par_btd,
{ "btd (Tone Direction)", "h248.bcp.btd",
FT_UINT32, BASE_HEX, VALS(h248_pkg_bcg_sig_bdt_par_btd_vals), 0, NULL, HFILL }
},
{ &hf_h248_pkg_bcg_sig_bdt,
{ "bdt (Dial Tone)", "h248.bcg.bdt",
FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_bcg_sig_brt,
{ "brt (Ringing tone)", "h248.bcg.brt",
FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_bcg_sig_bbt,
{ "bbt (Busy tone)", "h248.bcg.bbt",
FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_bcg_sig_bct,
{ "bct (Congestion tone)", "h248.bcg.bct",
FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_bcg_sig_bsit,
{ "bsit (Special information tone)", "h248.bcg.bsit",
FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_bcg_sig_bwt,
{ "bwt (Warning tone)", "h248.bcg.bwt",
FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_bcg_sig_bpt,
{ "bpt (Payphone recognition tone)", "h248.bcg.bpt",
FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_bcg_sig_bcw,
{ "bcw (Call waiting tone)", "h248.bcg.bcw",
FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_bcg_sig_bcr,
{ "bcr (Call ringing tone)", "h248.bcg.bcr",
FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }
},
{ &hf_h248_pkg_bcg_sig_bpy,
{ "bpy (Pay tone)", "h248.bcg.bpy",
FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }
},
};
static gint *ett[] = {
&ett_h248_pkg_BCP,
&ett_h248_pkg_bt,
&ett_h248_pkg_bt_tind,
&ett_h248_pkg_bt_bit,
&ett_h248_pkg_bcg,
&ett_h248_pkg_bcg_sig_bdt,
&ett_h248_pkg_BNCCT,
&ett_h248_pkg_RI,
&ett_h248_pkg_GB,
&ett_h248_pkg_GB_EstBNC,
&ett_h248_pkg_GB_ModBNC,
&ett_h248_pkg_GB_RelBNC,
&ett_h248_pkg_GB_BNCChange
};
proto_q1950 = proto_register_protocol(PNAME, PSNAME, PFNAME);
proto_register_field_array(proto_q1950, hf, array_length(hf));
proto_register_subtree_array(ett, array_length(ett));
h248_register_package(&h248_pkg_BCP,REPLACE_PKG);
h248_register_package(&h248_pkg_BNCCT,REPLACE_PKG);
h248_register_package(&h248_pkg_RI,REPLACE_PKG);
h248_register_package(&h248_pkg_GB,REPLACE_PKG);
h248_register_package(&h248_pkg_bcg,REPLACE_PKG);
h248_register_package(&h248_pkg_bct,REPLACE_PKG);
}
