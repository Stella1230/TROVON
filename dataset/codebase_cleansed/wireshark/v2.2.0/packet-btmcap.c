static gint\r\ndissect_btmcap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *main_item;\r\nproto_tree *main_tree;\r\nproto_item *pitem;\r\ngint offset = 0;\r\nguint32 op_code;\r\nguint32 response_code;\r\nguint32 mdl_id;\r\nguint32 mdep_id;\r\nguint32 bluetooth_clock_sync_time;\r\nguint64 timestamp_sync_time;\r\nmain_item = proto_tree_add_item(tree, proto_btmcap, tvb, offset, tvb_captured_length(tvb), ENC_NA);\r\nmain_tree = proto_item_add_subtree(main_item, ett_btmcap);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MCAP");\r\nswitch (pinfo->p2p_dir) {\r\ncase P2P_DIR_SENT:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Sent ");\r\nbreak;\r\ncase P2P_DIR_RECV:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");\r\nbreak;\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");\r\nbreak;\r\n}\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_op_code, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nop_code = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s", val_to_str(op_code, op_code_vals, "Unknown Op Code"));\r\nif (op_code >= 0x11 && op_code <= 0x20) {\r\nproto_item_append_text(pitem, " (Clock Sync)");\r\ncol_append_str(pinfo->cinfo, COL_INFO, " (Clock Sync)");\r\n} else {\r\nproto_item_append_text(pitem, " (Standard)");\r\ncol_append_str(pinfo->cinfo, COL_INFO, " (Standard)");\r\n}\r\nif (op_code & 0x01) {\r\nswitch(op_code) {\r\ncase 0x01:\r\ncase 0x03:\r\ncase 0x05:\r\ncase 0x07:\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_mdl_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nmdl_id = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - MDL ID: %u", mdl_id);\r\nif (mdl_id == 0xFFFF) {\r\nproto_item_append_text(pitem, " (Indicates all MDLs)");\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (Indicates all MDLs)");\r\n} else if (mdl_id >= 0x0001 && mdl_id <= 0xFEFF) {\r\nproto_item_append_text(pitem, " (Dynamic Range)");\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (Dynamic Range)");\r\n} else if (mdl_id == 0x0000) {\r\nproto_item_append_text(pitem, " (Reserved)");\r\ncol_append_str(pinfo->cinfo, COL_INFO, " (Reserved)");\r\n}\r\nif (op_code != 0x07 && mdl_id == 0xFFFF) {\r\nexpert_add_info(pinfo, pitem, &ei_btmcap_mdl_id_ffff);\r\n}\r\nif (op_code == 0x01) {\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_mdep_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nmdep_id = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\nif (mdep_id <= 0x7F) {\r\nproto_item_append_text(pitem, " (Available for use)");\r\n} else {\r\nproto_item_append_text(pitem, " (Reserved)");\r\n}\r\nproto_tree_add_item(main_tree, hf_btmcap_configuration, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\n}\r\nbreak;\r\ncase 0x11:\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_timestamp_required_accuracy, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(pitem, " ppm");\r\noffset += 2;\r\nbreak;\r\ncase 0x13:\r\nproto_tree_add_item(main_tree, hf_btmcap_timestamp_update_information, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_bluetooth_clock_sync_time, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbluetooth_clock_sync_time = tvb_get_ntohl(tvb, offset);\r\nif (bluetooth_clock_sync_time == 0xFFFFFFFF)\r\nproto_item_append_text(pitem, " (Instant Synchronization)");\r\nelse\r\nproto_item_append_text(pitem, " (Baseband Half-Slot Instant)");\r\noffset += 4;\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_timestamp_sync_time, tvb, offset, 8, ENC_BIG_ENDIAN);\r\ntimestamp_sync_time = tvb_get_ntoh64(tvb, offset);\r\nif (timestamp_sync_time == G_GUINT64_CONSTANT(0xFFFFFFFFFFFFFFFF))\r\nproto_item_append_text(pitem, " (No Time Synchronization)");\r\nelse\r\nproto_item_append_text(pitem, " (Time-Stamp Clock Instant)");\r\noffset += 8;\r\nbreak;\r\ncase 0x15:\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_bluetooth_clock_sync_time, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_item_append_text(pitem, " (Baseband Half-Slot Instant)");\r\noffset += 4;\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_timestamp_sync_time, tvb, offset, 8, ENC_BIG_ENDIAN);\r\nproto_item_append_text(pitem, " (Time-Stamp Clock Instant)");\r\noffset += 8;\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_timestamp_sample_accuracy, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(pitem, " us");\r\noffset += 2;\r\nbreak;\r\n}\r\n} else {\r\nproto_tree_add_item(main_tree, hf_btmcap_response_code, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nresponse_code = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - %s", val_to_str(response_code, response_code_vals, "Unknown ResponseCode"));\r\nif (op_code >= 0x11 && op_code <= 0x20) {\r\nswitch(op_code) {\r\ncase 0x12:\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_bluetooth_clock_access_resolution, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(pitem, " (Baseband half-slots)");\r\noffset += 1;\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_sync_lead_time, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(pitem, " ms");\r\noffset += 2;\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_timestamp_native_resolution, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(pitem, " us");\r\noffset += 2;\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_timestamp_native_accuracy, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(pitem, " ppm");\r\noffset += 2;\r\nbreak;\r\ncase 0x14:\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_bluetooth_clock_sync_time, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbluetooth_clock_sync_time = tvb_get_ntohl(tvb, offset);\r\nif (bluetooth_clock_sync_time == 0xFFFFFFFF)\r\nproto_item_append_text(pitem, " (Instant Synchronization)");\r\nelse\r\nproto_item_append_text(pitem, " (Baseband Half-Slot Instant)");\r\noffset += 4;\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_timestamp_sync_time, tvb, offset, 8, ENC_BIG_ENDIAN);\r\ntimestamp_sync_time = tvb_get_ntoh64(tvb, offset);\r\nif (timestamp_sync_time == G_GUINT64_CONSTANT(0xFFFFFFFFFFFFFFFF))\r\nproto_item_append_text(pitem, " (No Time Synchronization)");\r\nelse\r\nproto_item_append_text(pitem, " (Time-Stamp Clock Instant)");\r\noffset += 8;\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_timestamp_sample_accuracy, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(pitem, " us");\r\noffset += 2;\r\nbreak;\r\n}\r\n} else {\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_mdl_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nmdl_id = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - %u", mdl_id);\r\nif (mdl_id == 0xFFFF) {\r\nproto_item_append_text(pitem, " (Indicates all MDLs)");\r\ncol_append_str(pinfo->cinfo, COL_INFO, " (Indicates all MDLs)");\r\n} else if (mdl_id >= 0x0001 && mdl_id <= 0xFEFF) {\r\nproto_item_append_text(pitem, " (Dynamic Range)");\r\ncol_append_str(pinfo->cinfo, COL_INFO, " (Dynamic Range)");\r\n} else if (mdl_id == 0x0000) {\r\nproto_item_append_text(pitem, " (Reserved)");\r\ncol_append_str(pinfo->cinfo, COL_INFO, " (Reserved)");\r\n}\r\nif ((op_code == 0x03 || op_code == 0x05 || op_code == 0x07) && tvb_reported_length_remaining(tvb, offset)) {\r\nexpert_add_info_format(pinfo, pitem, &ei_btmcap_response_parameters_bad,\r\n"The Response Parameters for MD_RECONNECT_MDL_RSP shall have length zero.");\r\n} else if (tvb_reported_length_remaining(tvb, offset)) {\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_response_parameters, tvb, offset, tvb_reported_length_remaining(tvb, offset), ENC_NA);\r\nif (response_code != 0x00) {\r\nexpert_add_info_format(pinfo, pitem, &ei_btmcap_response_parameters_bad,\r\n"When the Response Code is not Success, the Response Parameters shall have length zero.");\r\n}\r\noffset += tvb_reported_length_remaining(tvb, offset);\r\n}\r\n}\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset)) {\r\npitem = proto_tree_add_item(main_tree, hf_btmcap_data, tvb, offset, tvb_reported_length_remaining(tvb, offset), ENC_NA);\r\nexpert_add_info(pinfo, pitem, &ei_btmcap_unexpected_data);\r\noffset = tvb_reported_length(tvb);\r\n}\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_btmcap(void)\r\n{\r\nmodule_t *module;\r\nexpert_module_t *expert_btmcap;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_btmcap_op_code,\r\n{ "Op Code", "btmcap.op_code",\r\nFT_UINT8, BASE_HEX, VALS(op_code_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btmcap_response_code,\r\n{ "Response Code", "btmcap.response_code",\r\nFT_UINT8, BASE_HEX, VALS(response_code_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btmcap_mdl_id,\r\n{ "MDL ID", "btmcap.mdl_id",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btmcap_mdep_id,\r\n{ "MDEP ID", "btmcap.mdep_id",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btmcap_configuration,\r\n{ "Configuration", "btmcap.configuration",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btmcap_timestamp_required_accuracy,\r\n{ "Timestamp Required Accuracy", "btmcap.timestamp_required_accuracy",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btmcap_timestamp_update_information,\r\n{ "Timestamp Update Information", "btmcap.timestamp_update_information",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btmcap_bluetooth_clock_sync_time,\r\n{ "Bluetooth Clock Sync Time", "btmcap.bluetooth_clock_sync_time",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btmcap_timestamp_sync_time,\r\n{ "Timestamp Sync Time", "btmcap.timestamp_sync_time",\r\nFT_UINT64, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btmcap_timestamp_sample_accuracy,\r\n{ "Timestamp Sample Accuracy", "btmcap.timestamp_sample_accuracy",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btmcap_bluetooth_clock_access_resolution,\r\n{ "Bluetooth Clock Access Resolution","btmcap.bluetooth_clock_access_resolution",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btmcap_sync_lead_time,\r\n{ "Sync Lead Time", "btmcap.sync_lead_time",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btmcap_timestamp_native_resolution,\r\n{ "Timestamp Native Resolution", "btmcap.timestamp_native_resolution",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btmcap_timestamp_native_accuracy,\r\n{ "Timestamp Native Accuracy", "btmcap.timestamp_native_accuracy",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btmcap_response_parameters,\r\n{ "Response Parameters", "btmcap.response_parameters",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btmcap_data,\r\n{ "Data", "btmcap.data",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_btmcap\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_btmcap_mdl_id_ffff, { "btmcap.mdl_id.ffff", PI_PROTOCOL, PI_WARN, "The value 0xFFFF is not a valid MDL ID for this request and shall not be used.", EXPFILL }},\r\n{ &ei_btmcap_response_parameters_bad, { "btmcap.response_parameters.bad", PI_PROTOCOL, PI_WARN, "Response parameters bad", EXPFILL }},\r\n{ &ei_btmcap_unexpected_data, { "btmcap.unexpected_data", PI_PROTOCOL, PI_WARN, "Unexpected data", EXPFILL }},\r\n};\r\nproto_btmcap = proto_register_protocol("Bluetooth MCAP Protocol", "BT MCAP", "btmcap");\r\nbtmcap_handle = register_dissector("btmcap", dissect_btmcap, proto_btmcap);\r\nproto_register_field_array(proto_btmcap, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_btmcap = expert_register_protocol(proto_btmcap);\r\nexpert_register_field_array(expert_btmcap, ei, array_length(ei));\r\nmodule = prefs_register_protocol(proto_btmcap, NULL);\r\nprefs_register_static_text_preference(module, "mcap.version",\r\n"Bluetooth Protocol MCAP version: 1.0",\r\n"Version of protocol supported by this dissector.");\r\n}\r\nvoid\r\nproto_reg_handoff_btmcap(void)\r\n{\r\ndissector_add_string("bluetooth.uuid", "1e", btmcap_handle);\r\ndissector_add_string("bluetooth.uuid", "1f", btmcap_handle);\r\ndissector_add_string("bluetooth.uuid", "1400", btmcap_handle);\r\ndissector_add_string("bluetooth.uuid", "1401", btmcap_handle);\r\ndissector_add_string("bluetooth.uuid", "1402", btmcap_handle);\r\ndissector_add_for_decode_as("btl2cap.psm", btmcap_handle);\r\ndissector_add_for_decode_as("btl2cap.cid", btmcap_handle);\r\n}
