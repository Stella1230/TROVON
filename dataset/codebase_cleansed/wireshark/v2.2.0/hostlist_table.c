static void\r\nreset_host_table_data(hostlist_table *hosts)\r\n{\r\nchar *display_name;\r\nchar title[256];\r\nGString *error_string;\r\nconst char *filter;\r\nGtkListStore *store;\r\nif (hosts->use_dfilter) {\r\nfilter = gtk_entry_get_text(GTK_ENTRY(main_display_filter_widget));\r\n} else {\r\nfilter = hosts->filter;\r\n}\r\nerror_string = set_tap_dfilter (&hosts->hash, filter);\r\nif (error_string) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s", error_string->str);\r\ng_string_free(error_string, TRUE);\r\nreturn;\r\n}\r\nif(hosts->page_lb) {\r\ndisplay_name = cf_get_display_name(&cfile);\r\ng_snprintf(title, sizeof(title), "Endpoints: %s", display_name);\r\ng_free(display_name);\r\ngtk_window_set_title(GTK_WINDOW(hosts->win), title);\r\ng_snprintf(title, sizeof(title), "%s", hosts->name);\r\ngtk_label_set_text(GTK_LABEL(hosts->page_lb), title);\r\ngtk_widget_set_sensitive(hosts->page_lb, FALSE);\r\nif (hosts->use_dfilter) {\r\nif (filter && strlen(filter)) {\r\ng_snprintf(title, sizeof(title), "%s Endpoints - Filter: %s", hosts->name, filter);\r\n} else {\r\ng_snprintf(title, sizeof(title), "%s Endpoints - No Filter", hosts->name);\r\n}\r\n} else {\r\ng_snprintf(title, sizeof(title), "%s Endpoints", hosts->name);\r\n}\r\ngtk_label_set_text(GTK_LABEL(hosts->name_lb), title);\r\n} else {\r\ndisplay_name = cf_get_display_name(&cfile);\r\ng_snprintf(title, sizeof(title), "%s Endpoints: %s", hosts->name, display_name);\r\ng_free(display_name);\r\ngtk_window_set_title(GTK_WINDOW(hosts->win), title);\r\n}\r\nstore = GTK_LIST_STORE(gtk_tree_view_get_model(GTK_TREE_VIEW(hosts->table)));\r\ngtk_list_store_clear(store);\r\nreset_hostlist_table_data(&hosts->hash);\r\n}\r\nstatic void\r\nreset_hostlist_table_data_cb(void *arg)\r\n{\r\nconv_hash_t *hash = (conv_hash_t*)arg;\r\nreset_host_table_data((hostlist_table *)hash->user_data);\r\n}\r\nstatic void\r\nhostlist_win_destroy_cb(GtkWindow *win _U_, gpointer data)\r\n{\r\nhostlist_table *hosts=(hostlist_table *)data;\r\nremove_tap_listener(&hosts->hash);\r\nreset_host_table_data(hosts);\r\ng_free(hosts);\r\n}\r\nstatic gint\r\nhostlist_sort_column(GtkTreeModel *model,\r\nGtkTreeIter *a,\r\nGtkTreeIter *b,\r\ngpointer user_data)\r\n{\r\nguint32 idx1, idx2;\r\ngint data_column = GPOINTER_TO_INT(user_data);\r\nhostlist_table *hl = (hostlist_table *)g_object_get_data(G_OBJECT(model), HOST_PTR_KEY);\r\nhostlist_talker_t *host1 = NULL;\r\nhostlist_talker_t *host2 = NULL;\r\ngtk_tree_model_get(model, a, ENDP_INDEX_COLUMN, &idx1, -1);\r\ngtk_tree_model_get(model, b, ENDP_INDEX_COLUMN, &idx2, -1);\r\nif (!hl || idx1 >= hl->hash.conv_array->len || idx2 >= hl->hash.conv_array->len)\r\nreturn 0;\r\nhost1 = &g_array_index(hl->hash.conv_array, hostlist_talker_t, idx1);\r\nhost2 = &g_array_index(hl->hash.conv_array, hostlist_talker_t, idx2);\r\nswitch(data_column){\r\ncase ENDP_COLUMN_ADDR:\r\nreturn(cmp_address(&host1->myaddress, &host2->myaddress));\r\ncase ENDP_COLUMN_PORT:\r\nCMP_INT(host1->port, host2->port);\r\n#ifdef HAVE_GEOIP\r\ndefault:\r\n{\r\ngchar *text1, *text2;\r\ndouble loc1 = 0, loc2 = 0;\r\ngtk_tree_model_get(model, a, data_column, &text1, -1);\r\ngtk_tree_model_get(model, b, data_column, &text2, -1);\r\nif (text1) {\r\nloc1 = g_ascii_strtod(text1, NULL);\r\ng_free(text1);\r\n}\r\nif (text2) {\r\nloc2 = g_ascii_strtod(text2, NULL);\r\ng_free(text2);\r\n}\r\nCMP_INT(loc1, loc2);\r\n}\r\nbreak;\r\n#endif\r\n}\r\ng_assert_not_reached();\r\nreturn 0;\r\n}\r\nstatic void\r\nhostlist_select_filter_cb(GtkWidget *widget _U_, gpointer callback_data, guint callback_action)\r\n{\r\nguint idx;\r\nhostlist_table *hl=(hostlist_table *)callback_data;\r\nchar *str;\r\nGtkTreeIter iter;\r\nGtkTreeModel *model;\r\nGtkTreeSelection *sel;\r\nhostlist_talker_t *host;\r\nsel = gtk_tree_view_get_selection (GTK_TREE_VIEW(hl->table));\r\nif (!gtk_tree_selection_get_selected(sel, &model, &iter))\r\nreturn;\r\ngtk_tree_model_get (model, &iter,\r\nENDP_INDEX_COLUMN, &idx,\r\n-1);\r\nif(idx>= hl->hash.conv_array->len){\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "No hostlist selected");\r\nreturn;\r\n}\r\nhost = &g_array_index(hl->hash.conv_array, hostlist_talker_t, idx);\r\nstr = get_hostlist_filter(host);\r\napply_selected_filter (callback_action, str);\r\ng_free (str);\r\n}\r\nstatic gboolean\r\nhostlist_show_popup_menu_cb(void *widg _U_, GdkEvent *event, hostlist_table *et)\r\n{\r\nGdkEventButton *bevent = (GdkEventButton *)event;\r\nif(event->type==GDK_BUTTON_PRESS && bevent->button==3){\r\ngtk_menu_popup(GTK_MENU(et->menu), NULL, NULL, NULL, NULL,\r\nbevent->button, bevent->time);\r\n}\r\nreturn FALSE;\r\n}\r\nstatic void\r\napply_as_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\napply_as_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\napply_as_and_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_AND_SELECTED, 0));\r\n}\r\nstatic void\r\napply_as_or_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_OR_SELECTED, 0));\r\n}\r\nstatic void\r\napply_as_and_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_AND_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\napply_as_or_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_OR_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_and_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_AND_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_or_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_OR_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_and_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_AND_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_or_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_OR_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_FIND_FRAME(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_FIND_FRAME(ACTYPE_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_prev_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_FIND_PREVIOUS(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_prev_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_FIND_PREVIOUS(ACTYPE_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_next_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_FIND_NEXT(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_next_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_FIND_NEXT(ACTYPE_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\ncolor_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nhostlist_select_filter_cb( widget , user_data, CALLBACK_COLORIZE(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\nhostlist_create_popup_menu(hostlist_table *hl)\r\n{\r\nGtkUIManager *ui_manager;\r\nGtkActionGroup *action_group;\r\nGError *error = NULL;\r\naction_group = gtk_action_group_new ("HostlistTablePopupActionGroup");\r\ngtk_action_group_add_actions (action_group,\r\nservice_resp_t_popup_entries,\r\nG_N_ELEMENTS(service_resp_t_popup_entries),\r\nhl);\r\nui_manager = gtk_ui_manager_new ();\r\ngtk_ui_manager_insert_action_group (ui_manager,\r\naction_group,\r\n0);\r\ngtk_ui_manager_add_ui_from_string (ui_manager,ui_desc_hostlist_table_popup, -1, &error);\r\nif (error != NULL)\r\n{\r\nfprintf (stderr, "Warning: building hostlist table filter popup failed: %s\n",\r\nerror->message);\r\ng_error_free (error);\r\nerror = NULL;\r\n}\r\nhl->menu = gtk_ui_manager_get_widget(ui_manager, "/HostlistTableFilterPopup");\r\ng_signal_connect(hl->table, "button_press_event", G_CALLBACK(hostlist_show_popup_menu_cb), hl);\r\n}\r\nstatic void\r\ndraw_hostlist_table_addresses(hostlist_table *hl)\r\n{\r\nguint idx;\r\nGtkListStore *store;\r\nGtkTreeIter iter;\r\ngboolean iter_valid;\r\nstore = GTK_LIST_STORE(gtk_tree_view_get_model(hl->table));\r\ng_object_ref(store);\r\ngtk_tree_view_set_model(GTK_TREE_VIEW(hl->table), NULL);\r\niter_valid = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(store), &iter);\r\nwhile (iter_valid) {\r\nhostlist_talker_t *host;\r\nchar *addr_str, *port_str;\r\ngtk_tree_model_get(GTK_TREE_MODEL(store), &iter, ENDP_INDEX_COLUMN, &idx, -1);\r\nhost = &g_array_index(hl->hash.conv_array, hostlist_talker_t, idx);\r\naddr_str = get_conversation_address(NULL, &host->myaddress, hl->resolve_names);\r\nport_str = get_conversation_port(NULL, host->port, host->ptype, hl->resolve_names);\r\ngtk_list_store_set (store, &iter,\r\nENDP_COLUMN_ADDR, addr_str,\r\nENDP_COLUMN_PORT, port_str,\r\n-1);\r\niter_valid = gtk_tree_model_iter_next(GTK_TREE_MODEL(store), &iter);\r\nwmem_free(NULL, addr_str);\r\nwmem_free(NULL, port_str);\r\n}\r\ngtk_tree_view_set_model(GTK_TREE_VIEW(hl->table), GTK_TREE_MODEL(store));\r\ng_object_unref(store);\r\n}\r\nstatic void\r\ndraw_hostlist_table_data(hostlist_table *hl)\r\n{\r\nguint idx, new_idx;\r\nchar title[256];\r\nGtkListStore *store;\r\nGtkTreeIter iter;\r\ngboolean iter_valid;\r\ngboolean first = TRUE;\r\nif (hl->page_lb) {\r\nif(hl->hash.conv_array && hl->hash.conv_array->len) {\r\ng_snprintf(title, sizeof(title), "%s: %u", hl->name, hl->hash.conv_array->len);\r\n} else {\r\ng_snprintf(title, sizeof(title), "%s", hl->name);\r\n}\r\ngtk_label_set_text(GTK_LABEL(hl->page_lb), title);\r\ngtk_widget_set_sensitive(hl->page_lb, hl->hash.conv_array && hl->hash.conv_array->len);\r\n} else {\r\nif(hl->hash.conv_array && hl->hash.conv_array->len) {\r\ng_snprintf(title, sizeof(title), "%s Endpoints: %u", hl->name, hl->hash.conv_array->len);\r\n} else {\r\ng_snprintf(title, sizeof(title), "%s Endpoints", hl->name);\r\n}\r\ngtk_label_set_text(GTK_LABEL(hl->name_lb), title);\r\n}\r\nstore = GTK_LIST_STORE(gtk_tree_view_get_model(hl->table));\r\niter_valid = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(store), &iter);\r\nnew_idx = gtk_tree_model_iter_n_children(GTK_TREE_MODEL(store), NULL);\r\nwhile (iter_valid || (hl->hash.conv_array && new_idx < hl->hash.conv_array->len)) {\r\nhostlist_talker_t *host;\r\nif (iter_valid) {\r\ngtk_tree_model_get(GTK_TREE_MODEL(store), &iter, ENDP_INDEX_COLUMN, &idx, -1);\r\n} else {\r\nidx = new_idx;\r\nnew_idx++;\r\n}\r\nif(!hl->hash.conv_array){\r\ncontinue;\r\n}\r\nhost = &g_array_index(hl->hash.conv_array, hostlist_talker_t, idx);\r\nif (!host->modified) {\r\niter_valid = gtk_tree_model_iter_next(GTK_TREE_MODEL(store), &iter);\r\ncontinue;\r\n}\r\nif (first) {\r\ng_object_ref(store);\r\ngtk_tree_view_set_model(GTK_TREE_VIEW(hl->table), NULL);\r\nfirst = FALSE;\r\n}\r\nhost->modified = FALSE;\r\nif (!iter_valid) {\r\nchar *addr_str, *port_str;\r\n#ifdef HAVE_GEOIP\r\nchar *geoip[ENDP_NUM_GEOIP_COLUMNS];\r\nguint j;\r\nif ((host->myaddress.type == AT_IPv4 || host->myaddress.type == AT_IPv6) && !hl->geoip_visible) {\r\nGList *columns, *list;\r\nGtkTreeViewColumn *column;\r\ncolumns = gtk_tree_view_get_columns(GTK_TREE_VIEW(hl->table));\r\nlist = columns;\r\nwhile(columns) {\r\nconst gchar *title_p;\r\ngint id;\r\ncolumn = (GtkTreeViewColumn *)columns->data;\r\ntitle_p = gtk_tree_view_column_get_title(column);\r\nid = gtk_tree_view_column_get_sort_column_id(column);\r\nif (title_p[0] != 0 && id >= ENDP_COLUMN_GEOIP1) {\r\ngtk_tree_view_column_set_visible(column, TRUE);\r\n}\r\ncolumns = g_list_next(columns);\r\n}\r\ng_list_free(list);\r\nhl->geoip_visible = TRUE;\r\n}\r\nfor (j = 0; j < ENDP_NUM_GEOIP_COLUMNS; j++) {\r\nif (host->myaddress.type == AT_IPv4 && j < geoip_db_num_dbs()) {\r\nguchar *name = geoip_db_lookup_ipv4(j, pntoh32(host->myaddress.data), "-");\r\ngeoip[j] = g_strdup(name);\r\nwmem_free(NULL, name);\r\n} else if (host->myaddress.type == AT_IPv6 && j < geoip_db_num_dbs()) {\r\nguchar *name;\r\nconst struct e_in6_addr *addr = (const struct e_in6_addr *) host->myaddress.data;\r\nname = geoip_db_lookup_ipv6(j, *addr, "-");\r\ngeoip[j] = g_strdup(name);\r\nwmem_free(NULL, name);\r\n} else {\r\ngeoip[j] = NULL;\r\n}\r\n}\r\n#endif\r\naddr_str = get_conversation_address(NULL, &host->myaddress, hl->resolve_names);\r\nport_str = get_conversation_port(NULL, host->port, host->ptype, hl->resolve_names);\r\ngtk_list_store_insert_with_values( store, &iter, G_MAXINT,\r\nENDP_COLUMN_ADDR, addr_str,\r\nENDP_COLUMN_PORT, port_str,\r\nENDP_COLUMN_PACKETS, host->tx_frames+host->rx_frames,\r\nENDP_COLUMN_BYTES, host->tx_bytes+host->rx_bytes,\r\nENDP_COLUMN_PKT_AB, host->tx_frames,\r\nENDP_COLUMN_BYTES_AB, host->tx_bytes,\r\nENDP_COLUMN_PKT_BA, host->rx_frames,\r\nENDP_COLUMN_BYTES_BA, host->rx_bytes,\r\n#ifdef HAVE_GEOIP\r\nENDP_COLUMN_GEOIP1, geoip[0],\r\nENDP_COLUMN_GEOIP2, geoip[1],\r\nENDP_COLUMN_GEOIP3, geoip[2],\r\nENDP_COLUMN_GEOIP4, geoip[3],\r\nENDP_COLUMN_GEOIP5, geoip[4],\r\nENDP_COLUMN_GEOIP6, geoip[5],\r\nENDP_COLUMN_GEOIP7, geoip[6],\r\nENDP_COLUMN_GEOIP8, geoip[7],\r\nENDP_COLUMN_GEOIP9, geoip[8],\r\nENDP_COLUMN_GEOIP10, geoip[9],\r\nENDP_COLUMN_GEOIP11, geoip[10],\r\nENDP_COLUMN_GEOIP12, geoip[11],\r\nENDP_COLUMN_GEOIP13, geoip[12],\r\n#endif\r\nENDP_INDEX_COLUMN, idx,\r\n-1);\r\nwmem_free(NULL, addr_str);\r\nwmem_free(NULL, port_str);\r\n#ifdef HAVE_GEOIP\r\nfor (j = 0; j < ENDP_NUM_GEOIP_COLUMNS; j++)\r\ng_free(geoip[j]);\r\n#endif\r\n}\r\nelse {\r\ngtk_list_store_set (store, &iter,\r\nENDP_COLUMN_PACKETS, host->tx_frames+host->rx_frames,\r\nENDP_COLUMN_BYTES, host->tx_bytes+host->rx_bytes,\r\nENDP_COLUMN_PKT_AB, host->tx_frames,\r\nENDP_COLUMN_BYTES_AB, host->tx_bytes,\r\nENDP_COLUMN_PKT_BA, host->rx_frames,\r\nENDP_COLUMN_BYTES_BA, host->rx_bytes,\r\n-1);\r\n}\r\niter_valid = gtk_tree_model_iter_next(GTK_TREE_MODEL(store), &iter);\r\n}\r\nif (!first) {\r\nif (!hl->fixed_col && hl->hash.conv_array && hl->hash.conv_array->len >= 1000) {\r\nhl->fixed_col = TRUE;\r\nswitch_to_fixed_col(hl->table);\r\n}\r\ngtk_tree_view_set_model(GTK_TREE_VIEW(hl->table), GTK_TREE_MODEL(store));\r\ng_object_unref(store);\r\n}\r\n}\r\nstatic void\r\ndraw_hostlist_table_data_cb(void *arg)\r\n{\r\nconv_hash_t *hash = (conv_hash_t*)arg;\r\ndraw_hostlist_table_data((hostlist_table *)hash->user_data);\r\n}\r\nstatic gboolean\r\ncsv_handle(GtkTreeModel *model, GtkTreePath *path _U_, GtkTreeIter *iter,\r\ngpointer data)\r\n{\r\ncsv_t *csv = (csv_t *)data;\r\ngchar *table_text;\r\nint i;\r\nguint idx;\r\nguint64 value;\r\ngtk_tree_model_get(model, iter, ENDP_INDEX_COLUMN, &idx, -1);\r\nfor (i=0; i< csv->nb_cols; i++) {\r\nif (i)\r\ng_string_append(csv->CSV_str, ",");\r\nswitch(csv->columns_order[i]) {\r\ncase ENDP_COLUMN_ADDR:\r\ncase ENDP_COLUMN_PORT:\r\ngtk_tree_model_get(model, iter, csv->columns_order[i], &table_text, -1);\r\nif (table_text) {\r\ng_string_append_printf(csv->CSV_str, "\"%s\"", table_text);\r\ng_free(table_text);\r\n}\r\nbreak;\r\ncase ENDP_COLUMN_PACKETS:\r\ncase ENDP_COLUMN_BYTES:\r\ncase ENDP_COLUMN_PKT_AB:\r\ncase ENDP_COLUMN_BYTES_AB:\r\ncase ENDP_COLUMN_PKT_BA:\r\ncase ENDP_COLUMN_BYTES_BA:\r\ngtk_tree_model_get(model, iter, csv->columns_order[i], &value, -1);\r\ng_string_append_printf(csv->CSV_str, "\"%" G_GINT64_MODIFIER "u\"", value);\r\nbreak;\r\ndefault:\r\ngtk_tree_model_get(model, iter, csv->columns_order[i], &table_text, -1);\r\nif (table_text) {\r\ng_string_append_printf(csv->CSV_str, "\"%s\"", table_text);\r\ng_free(table_text);\r\n}\r\nbreak;\r\n}\r\n}\r\ng_string_append(csv->CSV_str,"\n");\r\nreturn FALSE;\r\n}\r\nstatic void\r\ncopy_as_csv_cb(GtkWindow *copy_bt, gpointer data _U_)\r\n{\r\nGtkClipboard *cb;\r\nchar *savelocale;\r\nGList *columns, *list;\r\nGtkTreeViewColumn *column;\r\nGtkListStore *store;\r\ncsv_t csv;\r\ncsv.talkers=(hostlist_table *)g_object_get_data(G_OBJECT(copy_bt), HOST_PTR_KEY);\r\nif (!csv.talkers)\r\nreturn;\r\nsavelocale = g_strdup(setlocale(LC_NUMERIC, NULL));\r\nsetlocale(LC_NUMERIC, "C");\r\ncsv.CSV_str = g_string_new("");\r\ncolumns = gtk_tree_view_get_columns(GTK_TREE_VIEW(csv.talkers->table));\r\nlist = columns;\r\ncsv.nb_cols = 0;\r\nwhile(columns) {\r\ncolumn = (GtkTreeViewColumn *)columns->data;\r\nif (gtk_tree_view_column_get_visible(column)) {\r\ncsv.columns_order[csv.nb_cols] = gtk_tree_view_column_get_sort_column_id(column);\r\nif (csv.nb_cols)\r\ng_string_append(csv.CSV_str, ",");\r\ng_string_append_printf(csv.CSV_str, "\"%s\"", gtk_tree_view_column_get_title(column));\r\ncsv.nb_cols++;\r\n}\r\ncolumns = g_list_next(columns);\r\n}\r\ng_list_free(list);\r\ng_string_append(csv.CSV_str,"\n");\r\nstore = GTK_LIST_STORE(gtk_tree_view_get_model(GTK_TREE_VIEW(csv.talkers->table)));\r\ngtk_tree_model_foreach(GTK_TREE_MODEL(store), csv_handle, &csv);\r\ncb = gtk_clipboard_get(GDK_SELECTION_CLIPBOARD);\r\ngtk_clipboard_set_text(cb, csv.CSV_str->str, -1);\r\nsetlocale(LC_NUMERIC, savelocale);\r\ng_free(savelocale);\r\ng_string_free(csv.CSV_str, TRUE);\r\n}\r\nstatic void\r\nopen_as_map_cb(GtkWindow *copy_bt, gpointer data _U_)\r\n{\r\ngchar *err_str;\r\ngchar *file_uri;\r\ngboolean uri_open;\r\nhostlist_table *talkers;\r\ngchar *map_filename;\r\ntalkers = (hostlist_table *)g_object_get_data(G_OBJECT(copy_bt), HOST_PTR_KEY);\r\nif (!talkers) {\r\nreturn;\r\n}\r\nmap_filename = create_endpoint_geoip_map(talkers->hash.conv_array, &err_str);\r\nif (!map_filename) {\r\nsimple_error_message_box("%s", err_str);\r\ng_free(err_str);\r\nreturn;\r\n}\r\nfile_uri = g_filename_to_uri(map_filename, NULL, NULL);\r\ng_free(map_filename);\r\nuri_open = browser_open_url (file_uri);\r\nif(!uri_open) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "Couldn't open the file: \"%s\" in your web browser", file_uri);\r\ng_free(file_uri);\r\nreturn;\r\n}\r\ng_free(file_uri);\r\n}\r\nstatic void\r\ninit_default_col_size(GtkWidget *view)\r\n{\r\ndefault_col_size[ENDP_COLUMN_ADDR] = get_default_col_size(view, "00000000.000000000000");\r\ndefault_col_size[ENDP_COLUMN_PORT] = get_default_col_size(view, "000000");\r\ndefault_col_size[ENDP_COLUMN_PACKETS] = get_default_col_size(view, "00 000 000");\r\ndefault_col_size[ENDP_COLUMN_BYTES] = get_default_col_size(view, "0 000 000 000");\r\ndefault_col_size[ENDP_COLUMN_PKT_AB] = default_col_size[ENDP_COLUMN_PACKETS];\r\ndefault_col_size[ENDP_COLUMN_PKT_BA] = default_col_size[ENDP_COLUMN_PACKETS];\r\ndefault_col_size[ENDP_COLUMN_BYTES_AB] = default_col_size[ENDP_COLUMN_BYTES];\r\ndefault_col_size[ENDP_COLUMN_BYTES_BA] = default_col_size[ENDP_COLUMN_BYTES];\r\n#ifdef HAVE_GEOIP\r\ndefault_col_size[ENDP_COLUMN_GEOIP1] = default_col_size[ENDP_COLUMN_ADDR];\r\ndefault_col_size[ENDP_COLUMN_GEOIP2] = default_col_size[ENDP_COLUMN_GEOIP1];\r\ndefault_col_size[ENDP_COLUMN_GEOIP3] = default_col_size[ENDP_COLUMN_GEOIP1];\r\ndefault_col_size[ENDP_COLUMN_GEOIP4] = default_col_size[ENDP_COLUMN_GEOIP1];\r\ndefault_col_size[ENDP_COLUMN_GEOIP5] = default_col_size[ENDP_COLUMN_GEOIP1];\r\ndefault_col_size[ENDP_COLUMN_GEOIP6] = default_col_size[ENDP_COLUMN_GEOIP1];\r\ndefault_col_size[ENDP_COLUMN_GEOIP7] = default_col_size[ENDP_COLUMN_GEOIP1];\r\ndefault_col_size[ENDP_COLUMN_GEOIP8] = default_col_size[ENDP_COLUMN_GEOIP1];\r\ndefault_col_size[ENDP_COLUMN_GEOIP9] = default_col_size[ENDP_COLUMN_GEOIP1];\r\ndefault_col_size[ENDP_COLUMN_GEOIP10] = default_col_size[ENDP_COLUMN_GEOIP1];\r\ndefault_col_size[ENDP_COLUMN_GEOIP11] = default_col_size[ENDP_COLUMN_GEOIP1];\r\ndefault_col_size[ENDP_COLUMN_GEOIP12] = default_col_size[ENDP_COLUMN_GEOIP1];\r\ndefault_col_size[ENDP_COLUMN_GEOIP13] = default_col_size[ENDP_COLUMN_GEOIP1];\r\n#endif\r\n}\r\nstatic gboolean\r\ninit_hostlist_table_page(hostlist_table *hosttable, GtkWidget *vbox, gboolean hide_ports, const char *table_name, const char *tap_name,\r\nconst char *filter, tap_packet_cb packet_func)\r\n{\r\nguint i;\r\nGString *error_string;\r\nchar title[256];\r\nGtkListStore *store;\r\nGtkWidget *tree;\r\nGtkTreeViewColumn *column;\r\nGtkCellRenderer *renderer;\r\nGtkTreeSortable *sortable;\r\nGtkTreeSelection *sel;\r\nstatic gboolean col_size = FALSE;\r\nhosttable->default_titles[0] = "Address";\r\nhosttable->default_titles[1] = "Port";\r\nhosttable->default_titles[2] = "Packets";\r\nhosttable->default_titles[3] = "Bytes";\r\nhosttable->default_titles[4] = "Tx Packets";\r\nhosttable->default_titles[5] = "Tx Bytes";\r\nhosttable->default_titles[6] = "Rx Packets";\r\nhosttable->default_titles[7] = "Rx Bytes";\r\n#ifdef HAVE_GEOIP\r\nfor (i = 0; i < ENDP_NUM_GEOIP_COLUMNS; i++) {\r\nif (i < geoip_db_num_dbs()) {\r\nhosttable->default_titles[ENDP_NUM_COLUMNS + i] = geoip_db_name(i);\r\n} else {\r\nhosttable->default_titles[ENDP_NUM_COLUMNS + i] = "";\r\n}\r\n}\r\n#endif\r\nif (strcmp(table_name, "NCP")==0) {\r\nhosttable->default_titles[1] = endp_conn_title;\r\n}\r\nhosttable->has_ports=!hide_ports;\r\nhosttable->resolve_names=TRUE;\r\nhosttable->page_lb = NULL;\r\nhosttable->fixed_col = FALSE;\r\nhosttable->geoip_visible = FALSE;\r\ng_snprintf(title, sizeof(title), "%s Endpoints", table_name);\r\nhosttable->name_lb = gtk_label_new(title);\r\ngtk_box_pack_start(GTK_BOX(vbox), hosttable->name_lb, FALSE, FALSE, 0);\r\nstore = gtk_list_store_new (ENDP_INDEX_COLUMN + 1,\r\nG_TYPE_STRING,\r\nG_TYPE_STRING,\r\nG_TYPE_UINT64,\r\nG_TYPE_UINT64,\r\nG_TYPE_UINT64,\r\nG_TYPE_UINT64,\r\nG_TYPE_UINT64,\r\nG_TYPE_UINT64,\r\n#ifdef HAVE_GEOIP\r\nG_TYPE_STRING,\r\nG_TYPE_STRING,\r\nG_TYPE_STRING,\r\nG_TYPE_STRING,\r\nG_TYPE_STRING,\r\nG_TYPE_STRING,\r\nG_TYPE_STRING,\r\nG_TYPE_STRING,\r\nG_TYPE_STRING,\r\nG_TYPE_STRING,\r\nG_TYPE_STRING,\r\nG_TYPE_STRING,\r\nG_TYPE_STRING,\r\n#endif\r\nG_TYPE_UINT);\r\nhosttable->scrolled_window=scrolled_window_new(NULL, NULL);\r\ngtk_box_pack_start(GTK_BOX(vbox), hosttable->scrolled_window, TRUE, TRUE, 0);\r\ntree = gtk_tree_view_new_with_model (GTK_TREE_MODEL (store));\r\nhosttable->table = GTK_TREE_VIEW(tree);\r\nsortable = GTK_TREE_SORTABLE(store);\r\ng_object_unref (G_OBJECT (store));\r\nif (!col_size) {\r\ncol_size = TRUE;\r\ninit_default_col_size(GTK_WIDGET(hosttable->table));\r\n}\r\ng_object_set_data(G_OBJECT(store), HOST_PTR_KEY, hosttable);\r\ng_object_set_data(G_OBJECT(hosttable->table), HOST_PTR_KEY, hosttable);\r\nfor (i = 0; i < ENDP_NUM_COLUMNS+ENDP_NUM_GEOIP_COLUMNS; i++) {\r\nrenderer = gtk_cell_renderer_text_new ();\r\ng_object_set(renderer, "ypad", 0, NULL);\r\nswitch(i) {\r\ncase ENDP_COLUMN_ADDR:\r\ncase ENDP_COLUMN_PORT:\r\ncolumn = gtk_tree_view_column_new_with_attributes (hosttable->default_titles[i], renderer, "text",\r\ni, NULL);\r\nif(hide_ports && i == ENDP_COLUMN_PORT){\r\ngtk_tree_view_column_set_visible(column, FALSE);\r\n}\r\ngtk_tree_sortable_set_sort_func(sortable, i, hostlist_sort_column, GINT_TO_POINTER(i), NULL);\r\nbreak;\r\ncase ENDP_COLUMN_PACKETS:\r\ncase ENDP_COLUMN_BYTES:\r\ncase ENDP_COLUMN_PKT_AB:\r\ncase ENDP_COLUMN_BYTES_AB:\r\ncase ENDP_COLUMN_PKT_BA:\r\ncase ENDP_COLUMN_BYTES_BA:\r\ng_object_set(G_OBJECT(renderer), "xalign", 1.0, NULL);\r\ncolumn = gtk_tree_view_column_new_with_attributes (hosttable->default_titles[i], renderer, NULL);\r\ngtk_tree_view_column_set_cell_data_func(column, renderer, u64_data_func, GINT_TO_POINTER(i), NULL);\r\nbreak;\r\ndefault:\r\ncolumn = gtk_tree_view_column_new_with_attributes (hosttable->default_titles[i], renderer, "text",\r\ni, NULL);\r\ngtk_tree_view_column_set_visible(column, FALSE);\r\n#ifdef HAVE_GEOIP\r\nif (i >= ENDP_NUM_COLUMNS && i - ENDP_NUM_COLUMNS < geoip_db_num_dbs()) {\r\nint goip_type = geoip_db_type(i - ENDP_NUM_COLUMNS);\r\nif (goip_type == WS_LON_FAKE_EDITION || goip_type == WS_LAT_FAKE_EDITION) {\r\ng_object_set(G_OBJECT(renderer), "xalign", 1.0, NULL);\r\ngtk_tree_sortable_set_sort_func(sortable, i, hostlist_sort_column, GINT_TO_POINTER(i), NULL);\r\n}\r\n}\r\n#endif\r\nbreak;\r\n}\r\ngtk_tree_view_column_set_sort_column_id(column, i);\r\ngtk_tree_view_column_set_resizable(column, TRUE);\r\ngtk_tree_view_column_set_reorderable(column, TRUE);\r\ngtk_tree_view_column_set_min_width(column, 40);\r\ngtk_tree_view_column_set_fixed_width(column, default_col_size[i]);\r\ngtk_tree_view_append_column (hosttable->table, column);\r\n#if 0\r\nif (i == PACKETS_COLUMN) {\r\ngtk_tree_view_column_clicked(column);\r\n}\r\n#endif\r\n}\r\ngtk_container_add(GTK_CONTAINER(hosttable->scrolled_window), (GtkWidget *)hosttable->table);\r\ngtk_tree_view_set_rules_hint(hosttable->table, TRUE);\r\ngtk_tree_view_set_headers_clickable(hosttable->table, TRUE);\r\ngtk_tree_view_set_reorderable (hosttable->table, TRUE);\r\nhosttable->hash.conv_array = NULL;\r\nhosttable->hash.hashtable = NULL;\r\nhosttable->hash.user_data = hosttable;\r\nsel = gtk_tree_view_get_selection(GTK_TREE_VIEW(hosttable->table));\r\ngtk_tree_selection_set_mode(sel, GTK_SELECTION_SINGLE);\r\nhostlist_create_popup_menu(hosttable);\r\nerror_string=register_tap_listener(tap_name, &hosttable->hash, filter, 0, reset_hostlist_table_data_cb, packet_func, draw_hostlist_table_data_cb);\r\nif(error_string){\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s", error_string->str);\r\ng_string_free(error_string, TRUE);\r\ng_free(hosttable);\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nvoid\r\ninit_hostlist_table(struct register_ct* ct, const char *filter)\r\n{\r\nhostlist_table *hosttable;\r\nchar *display_name;\r\nchar title[256];\r\nGtkWidget *vbox;\r\nGtkWidget *bbox;\r\nGtkWidget *close_bt, *help_bt;\r\ngboolean ret;\r\nGtkWidget *copy_bt;\r\n#ifdef HAVE_GEOIP\r\nGtkWidget *map_bt;\r\n#endif\r\nwindow_geometry_t tl_geom;\r\nhosttable=g_new0(hostlist_table,1);\r\nhosttable->name=proto_get_protocol_short_name(find_protocol_by_id(get_conversation_proto_id(ct)));\r\nhosttable->filter=filter;\r\nhosttable->use_dfilter=FALSE;\r\ndisplay_name = cf_get_display_name(&cfile);\r\ng_snprintf(title, sizeof(title), "%s Endpoints: %s", hosttable->name, display_name);\r\ng_free(display_name);\r\nhosttable->win = dlg_window_new(title);\r\ngtk_window_set_destroy_with_parent (GTK_WINDOW(hosttable->win), TRUE);\r\nwindow_get_geometry(top_level, &tl_geom);\r\ngtk_window_set_default_size(GTK_WINDOW(hosttable->win), tl_geom.width * 8 / 10, HL_DLG_HEIGHT);\r\nvbox=ws_gtk_box_new(GTK_ORIENTATION_VERTICAL, DLG_LABEL_SPACING, FALSE);\r\ngtk_container_add(GTK_CONTAINER(hosttable->win), vbox);\r\ngtk_container_set_border_width(GTK_CONTAINER(vbox), DLG_OUTER_MARGIN);\r\nret = init_hostlist_table_page(hosttable, vbox, get_conversation_hide_ports(ct), hosttable->name,\r\nproto_get_protocol_filter_name(get_conversation_proto_id(ct)), filter, get_hostlist_packet_func(ct));\r\nif(ret == FALSE) {\r\ng_free(hosttable);\r\nreturn;\r\n}\r\n#ifdef HAVE_GEOIP\r\nif( strstr(hosttable->name, "IPv4") || strstr(hosttable->name, "IPv6") ) {\r\nbbox = dlg_button_row_new(GTK_STOCK_CLOSE, GTK_STOCK_COPY, WIRESHARK_STOCK_MAP, GTK_STOCK_HELP, NULL);\r\n} else {\r\nbbox = dlg_button_row_new(GTK_STOCK_CLOSE, GTK_STOCK_COPY, GTK_STOCK_HELP, NULL);\r\n}\r\n#else\r\nbbox = dlg_button_row_new(GTK_STOCK_CLOSE, GTK_STOCK_COPY, GTK_STOCK_HELP, NULL);\r\n#endif\r\ngtk_box_pack_end(GTK_BOX(vbox), bbox, FALSE, FALSE, 0);\r\nclose_bt = (GtkWidget *)g_object_get_data(G_OBJECT(bbox), GTK_STOCK_CLOSE);\r\nwindow_set_cancel_button(hosttable->win, close_bt, window_cancel_button_cb);\r\ncopy_bt = (GtkWidget *)g_object_get_data(G_OBJECT(bbox), GTK_STOCK_COPY);\r\ngtk_widget_set_tooltip_text(copy_bt, "Copy all statistical values of this page to the clipboard in CSV (Comma Separated Values) format.");\r\ng_object_set_data(G_OBJECT(copy_bt), HOST_PTR_KEY, hosttable);\r\ng_signal_connect(copy_bt, "clicked", G_CALLBACK(copy_as_csv_cb), NULL);\r\n#ifdef HAVE_GEOIP\r\nmap_bt = (GtkWidget *)g_object_get_data(G_OBJECT(bbox), WIRESHARK_STOCK_MAP);\r\nif(map_bt != NULL) {\r\ngtk_widget_set_tooltip_text(map_bt, "Show a map of the IP addresses (internet connection required).");\r\ng_object_set_data(G_OBJECT(map_bt), HOST_PTR_KEY, hosttable);\r\ng_signal_connect(map_bt, "clicked", G_CALLBACK(open_as_map_cb), NULL);\r\n}\r\n#endif\r\nhelp_bt = (GtkWidget *)g_object_get_data(G_OBJECT(bbox), GTK_STOCK_HELP);\r\ng_signal_connect(help_bt, "clicked", G_CALLBACK(topic_cb), (gpointer)HELP_STATS_ENDPOINTS_DIALOG);\r\ng_signal_connect(hosttable->win, "delete_event", G_CALLBACK(window_delete_event_cb), NULL);\r\ng_signal_connect(hosttable->win, "destroy", G_CALLBACK(hostlist_win_destroy_cb), hosttable);\r\ngtk_widget_show_all(hosttable->win);\r\nwindow_present(hosttable->win);\r\ncf_retap_packets(&cfile);\r\ngdk_window_raise(gtk_widget_get_window(hosttable->win));\r\n}\r\nstatic void\r\nct_nb_switch_page_cb(GtkNotebook *nb, gpointer *pg _U_, guint page, gpointer data)\r\n{\r\nGtkWidget *copy_bt = (GtkWidget *) data;\r\nvoid ** pages = (void **)g_object_get_data(G_OBJECT(nb), NB_PAGES_KEY);\r\npage++;\r\nif (pages && page > 0 && (int) page <= GPOINTER_TO_INT(pages[0]) && copy_bt) {\r\ng_object_set_data(G_OBJECT(copy_bt), HOST_PTR_KEY, pages[page]);\r\n}\r\n}\r\nstatic void\r\nct_nb_map_switch_page_cb(GtkNotebook *nb, gpointer *pg _U_, guint page, gpointer data)\r\n{\r\nGtkWidget *map_bt = (GtkWidget *) data;\r\nvoid ** pages = (void **)g_object_get_data(G_OBJECT(nb), NB_PAGES_KEY);\r\npage++;\r\nif (pages && page > 0 && (int) page <= GPOINTER_TO_INT(pages[0]) && map_bt) {\r\ng_object_set_data(G_OBJECT(map_bt), HOST_PTR_KEY, pages[page]);\r\nif( strstr(((hostlist_table *)pages[page])->name, "IPv4") ||\r\nstrstr(((hostlist_table *)pages[page])->name, "IPv6") ) {\r\ngtk_widget_set_sensitive(map_bt, TRUE);\r\n} else {\r\ngtk_widget_set_sensitive(map_bt, FALSE);\r\n}\r\n}\r\n}\r\nstatic void\r\nhostlist_win_destroy_notebook_cb(GtkWindow *win _U_, gpointer data)\r\n{\r\nvoid ** pages = (void **)data;\r\nint page;\r\nfor (page=1; page<=GPOINTER_TO_INT(pages[0]); page++) {\r\nhostlist_win_destroy_cb(NULL, pages[page]);\r\n}\r\ng_free(pages);\r\n}\r\nstatic hostlist_table *\r\ninit_hostlist_notebook_page_cb(register_ct_t *table, const char *filter)\r\n{\r\ngboolean ret;\r\nGtkWidget *page_vbox;\r\nhostlist_table *hosttable;\r\nhosttable=g_new0(hostlist_table,1);\r\nhosttable->name=proto_get_protocol_short_name(find_protocol_by_id(get_conversation_proto_id(table)));\r\nhosttable->filter=filter;\r\nhosttable->use_dfilter=FALSE;\r\npage_vbox=ws_gtk_box_new(GTK_ORIENTATION_VERTICAL, 6, FALSE);\r\nhosttable->win = page_vbox;\r\ngtk_container_set_border_width(GTK_CONTAINER(page_vbox), 6);\r\nret = init_hostlist_table_page(hosttable, page_vbox, get_conversation_hide_ports(table), hosttable->name,\r\nproto_get_protocol_filter_name(get_conversation_proto_id(table)), filter, get_hostlist_packet_func(table));\r\nif(ret == FALSE) {\r\ng_free(hosttable);\r\nreturn NULL;\r\n}\r\nreturn hosttable;\r\n}\r\nstatic void\r\nhostlist_resolve_toggle_dest(GtkWidget *widget, gpointer data)\r\n{\r\nint page;\r\nvoid ** pages = (void **)data;\r\ngboolean resolve_names;\r\nhostlist_table *hosttable;\r\nresolve_names = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON (widget));\r\nfor (page=1; page<=GPOINTER_TO_INT(pages[0]); page++) {\r\nhosttable = (hostlist_table *)pages[page];\r\nhosttable->resolve_names = resolve_names;\r\ndraw_hostlist_table_addresses(hosttable);\r\n}\r\n}\r\nstatic void\r\nhostlist_filter_toggle_dest(GtkWidget *widget, gpointer data)\r\n{\r\nint page;\r\nvoid ** pages = (void **)data;\r\ngboolean use_filter;\r\nhostlist_table *hosttable = NULL;\r\nuse_filter = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON (widget));\r\nfor (page=1; page<=GPOINTER_TO_INT(pages[0]); page++) {\r\nhosttable = (hostlist_table *)pages[page];\r\nhosttable->use_dfilter = use_filter;\r\nreset_host_table_data(hosttable);\r\n}\r\ncf_retap_packets(&cfile);\r\nif (hosttable) {\r\ngdk_window_raise(gtk_widget_get_window(hosttable->win));\r\n}\r\n}\r\nstatic void\r\ninit_host_page(gpointer data, gpointer user_data)\r\n{\r\nregister_ct_t *table = (register_ct_t*)data;\r\ninit_host_page_data* host_page_data = (init_host_page_data*)user_data;\r\nhostlist_table *hosttable;\r\nGtkWidget *page_lb;\r\nhosttable = init_hostlist_notebook_page_cb(table, NULL );\r\nif (hosttable) {\r\ng_object_set_data(G_OBJECT(hosttable->win), HOST_PTR_KEY, hosttable);\r\npage_lb = gtk_label_new("");\r\ngtk_notebook_append_page(GTK_NOTEBOOK(host_page_data->nb), hosttable->win, page_lb);\r\nhosttable->win = host_page_data->win;\r\nhosttable->page_lb = page_lb;\r\nhost_page_data->pages[++host_page_data->page] = hosttable;\r\n}\r\n}\r\nvoid\r\ninit_hostlist_notebook_cb(GtkWidget *w _U_, gpointer d _U_)\r\n{\r\nchar *display_name;\r\nchar title[256];\r\nGtkWidget *vbox;\r\nGtkWidget *hbox;\r\nGtkWidget *bbox;\r\nGtkWidget *close_bt, *help_bt;\r\nGtkWidget *win;\r\nGtkWidget *resolv_cb;\r\nGtkWidget *filter_cb;\r\nvoid ** pages;\r\nGtkWidget *nb;\r\nGtkWidget *copy_bt;\r\n#ifdef HAVE_GEOIP\r\nGtkWidget *map_bt;\r\n#endif\r\nwindow_geometry_t tl_geom;\r\ninit_host_page_data host_page_iter_data;\r\npages = (void **)g_malloc(sizeof(void *) * (conversation_table_get_num() + 1));\r\nwin = dlg_window_new("hostlist");\r\ngtk_window_set_destroy_with_parent (GTK_WINDOW(win), TRUE);\r\ndisplay_name = cf_get_display_name(&cfile);\r\ng_snprintf(title, sizeof(title), "Endpoints: %s", display_name);\r\ng_free(display_name);\r\ngtk_window_set_title(GTK_WINDOW(win), title);\r\nwindow_get_geometry(top_level, &tl_geom);\r\ngtk_window_set_default_size(GTK_WINDOW(win), tl_geom.width * 8 / 10, HL_DLG_HEIGHT);\r\nvbox=ws_gtk_box_new(GTK_ORIENTATION_VERTICAL, DLG_LABEL_SPACING, FALSE);\r\ngtk_container_add(GTK_CONTAINER(win), vbox);\r\ngtk_container_set_border_width(GTK_CONTAINER(vbox), DLG_OUTER_MARGIN);\r\nnb = gtk_notebook_new();\r\ngtk_box_pack_start(GTK_BOX(vbox), nb, TRUE, TRUE, 0);\r\ng_object_set_data(G_OBJECT(nb), NB_PAGES_KEY, pages);\r\nhost_page_iter_data.page = 0;\r\nhost_page_iter_data.pages = pages;\r\nhost_page_iter_data.nb = nb;\r\nhost_page_iter_data.win = win;\r\nconversation_table_iterate_tables(init_host_page, &host_page_iter_data);\r\npages[0] = GINT_TO_POINTER(host_page_iter_data.page);\r\nhbox = ws_gtk_box_new(GTK_ORIENTATION_HORIZONTAL, DLG_UNRELATED_SPACING, FALSE);\r\ngtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);\r\nresolv_cb = gtk_check_button_new_with_mnemonic("Name resolution");\r\ngtk_box_pack_start(GTK_BOX(hbox), resolv_cb, FALSE, FALSE, 0);\r\ngtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(resolv_cb), TRUE);\r\ngtk_widget_set_tooltip_text(resolv_cb,\r\n"Show results of name resolutions rather than the \"raw\" values. Please note: The corresponding name resolution must be enabled.");\r\ng_signal_connect(resolv_cb, "toggled", G_CALLBACK(hostlist_resolve_toggle_dest), pages);\r\nfilter_cb = gtk_check_button_new_with_mnemonic("Limit to display filter");\r\ngtk_box_pack_start(GTK_BOX(hbox), filter_cb, FALSE, FALSE, 0);\r\ngtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(filter_cb), FALSE);\r\ngtk_widget_set_tooltip_text(filter_cb, "Limit the list to endpoints matching the current display filter.");\r\ng_signal_connect(filter_cb, "toggled", G_CALLBACK(hostlist_filter_toggle_dest), pages);\r\n#ifdef HAVE_GEOIP\r\nbbox = dlg_button_row_new(GTK_STOCK_CLOSE, GTK_STOCK_COPY, WIRESHARK_STOCK_MAP, GTK_STOCK_HELP, NULL);\r\n#else\r\nbbox = dlg_button_row_new(GTK_STOCK_CLOSE, GTK_STOCK_COPY, GTK_STOCK_HELP, NULL);\r\n#endif\r\ngtk_box_pack_end(GTK_BOX(vbox), bbox, FALSE, FALSE, 0);\r\nclose_bt = (GtkWidget *)g_object_get_data(G_OBJECT(bbox), GTK_STOCK_CLOSE);\r\nwindow_set_cancel_button(win, close_bt, window_cancel_button_cb);\r\ncopy_bt = (GtkWidget *)g_object_get_data(G_OBJECT(bbox), GTK_STOCK_COPY);\r\ngtk_widget_set_tooltip_text(copy_bt, "Copy all statistical values of this page to the clipboard in CSV (Comma Separated Values) format.");\r\ng_signal_connect(copy_bt, "clicked", G_CALLBACK(copy_as_csv_cb), NULL);\r\ng_object_set_data(G_OBJECT(copy_bt), HOST_PTR_KEY, pages[host_page_iter_data.page]);\r\n#ifdef HAVE_GEOIP\r\nmap_bt = (GtkWidget *)g_object_get_data(G_OBJECT(bbox), WIRESHARK_STOCK_MAP);\r\ngtk_widget_set_tooltip_text(map_bt, "Show a map of the IP addresses (internet connection required).");\r\ng_object_set_data(G_OBJECT(map_bt), HOST_PTR_KEY, pages[host_page_iter_data.page]);\r\ng_signal_connect(map_bt, "clicked", G_CALLBACK(open_as_map_cb), NULL);\r\ng_signal_connect(nb, "switch-page", G_CALLBACK(ct_nb_map_switch_page_cb), map_bt);\r\ngtk_widget_set_sensitive(map_bt, FALSE);\r\n#endif\r\ng_signal_connect(nb, "switch-page", G_CALLBACK(ct_nb_switch_page_cb), copy_bt);\r\nhelp_bt = (GtkWidget *)g_object_get_data(G_OBJECT(bbox), GTK_STOCK_HELP);\r\ng_signal_connect(help_bt, "clicked", G_CALLBACK(topic_cb), (gpointer)HELP_STATS_ENDPOINTS_DIALOG);\r\ng_signal_connect(win, "delete_event", G_CALLBACK(window_delete_event_cb), NULL);\r\ng_signal_connect(win, "destroy", G_CALLBACK(hostlist_win_destroy_notebook_cb), pages);\r\ngtk_widget_show_all(win);\r\nwindow_present(win);\r\ncf_retap_packets(&cfile);\r\ngdk_window_raise(gtk_widget_get_window(win));\r\n}\r\nvoid hostlist_endpoint_cb(register_ct_t* table)\r\n{\r\nchar cmd_str[50];\r\ng_snprintf(cmd_str, 50, "%s,%s", HOSTLIST_TAP_PREFIX, proto_get_protocol_filter_name(get_conversation_proto_id(table)));\r\ndissector_hostlist_init(cmd_str, table);\r\n}
