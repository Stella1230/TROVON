static gchar *\r\ndnd_uri2filename(gchar *cf_name)\r\n{\r\ngchar *src, *dest;\r\ngint ret;\r\nguint i;\r\ngchar esc[3];\r\n#ifdef _WIN32\r\nif (strncmp("file:////", cf_name, 9) == 0) {\r\ncf_name += 7;\r\n} else if (strncmp("file:///", cf_name, 8) == 0) {\r\ncf_name += 8;\r\n}\r\n#else\r\nif (strncmp("file:", cf_name, 5) == 0) {\r\ncf_name += 5;\r\nfor(; cf_name[1] == '/'; ++cf_name);\r\n}\r\n#endif\r\nsrc = cf_name;\r\ndest = cf_name;\r\nwhile (*src) {\r\nif (*src == '%') {\r\nsrc++;\r\nif (*src == '%') {\r\n*dest = *src;\r\nsrc++;\r\ndest++;\r\n} else {\r\nesc[0] = src[0];\r\nesc[1] = src[1];\r\nesc[2] = '\0';\r\nret = sscanf(esc, "%x", &i);\r\nif (ret == 1) {\r\nsrc+=2;\r\n*dest = (gchar) i;\r\ndest++;\r\n} else {\r\nsrc++;\r\n}\r\n}\r\n#ifdef _WIN32\r\n} else if (*src == '/') {\r\n*dest = '\\';\r\nsrc++;\r\ndest++;\r\n#endif\r\n} else {\r\n*dest = *src;\r\nsrc++;\r\ndest++;\r\n}\r\n}\r\n*dest = '\0';\r\nreturn cf_name;\r\n}\r\nvoid\r\ndnd_open_file_cmd(gchar *cf_names_freeme)\r\n{\r\nint err;\r\ngchar *cf_name;\r\nint in_file_count;\r\nint files_work;\r\nchar **in_filenames;\r\nchar *tmpname;\r\nif (cf_names_freeme == NULL) return;\r\ncf_name = cf_names_freeme;\r\nfor(in_file_count = 0; (cf_name = strstr(cf_name, "\r\n")) != NULL; ) {\r\ncf_name += 2;\r\nin_file_count++;\r\n}\r\nif (in_file_count == 0) {\r\ng_free(cf_names_freeme);\r\nreturn;\r\n}\r\nin_filenames = (char **)g_malloc(sizeof(char*) * in_file_count);\r\ncf_name = cf_names_freeme;\r\nin_filenames[0] = cf_name;\r\nfor(files_work = 1; (cf_name = strstr(cf_name, "\r\n")) != NULL && files_work < in_file_count; ) {\r\ncf_name += 2;\r\nin_filenames[files_work] = cf_name;\r\nfiles_work++;\r\n}\r\ncf_name = cf_names_freeme;\r\ng_strdelimit(cf_name, "\r\n", '\0');\r\nfor(files_work = 0; files_work < in_file_count; files_work++) {\r\nin_filenames[files_work] = dnd_uri2filename(in_filenames[files_work]);\r\n}\r\nif (in_file_count == 1) {\r\nif (cf_open(&cfile, in_filenames[0], WTAP_TYPE_AUTO, FALSE, &err) == CF_OK) {\r\ncf_read(&cfile, FALSE);\r\nadd_menu_recent_capture_file(in_filenames[0]);\r\n} else {\r\n}\r\n} else {\r\ntmpname = NULL;\r\nif (cf_merge_files(&tmpname, in_file_count, in_filenames,\r\nWTAP_FILE_TYPE_SUBTYPE_PCAPNG, FALSE) == CF_OK) {\r\ncf_close(&cfile);\r\nif (cf_open(&cfile, tmpname, WTAP_TYPE_AUTO, TRUE , &err) == CF_OK) {\r\ng_free(tmpname);\r\ncf_read(&cfile, FALSE);\r\n} else {\r\ng_free(tmpname);\r\n}\r\n} else {\r\ng_free(tmpname);\r\n}\r\n}\r\ng_free(in_filenames);\r\ng_free(cf_names_freeme);\r\n}\r\nstatic void\r\ndnd_data_received(GtkWidget *widget _U_, GdkDragContext *dc _U_, gint x _U_, gint y _U_,\r\nGtkSelectionData *selection_data, guint info, guint t _U_, gpointer data _U_)\r\n{\r\ngchar *cf_names_freeme;\r\nconst guchar *sel_data_data;\r\ngint sel_data_len;\r\nif (info == DND_TARGET_URL) {\r\n#ifdef HAVE_LIBPCAP\r\nif((global_capture_session.state != CAPTURE_STOPPED)) {\r\nsimple_dialog(ESD_TYPE_CONFIRMATION,\r\nESD_BTN_OK,\r\n"%sDrag and Drop currently not possible!%s\n\n"\r\n"Dropping a file isn't possible while a capture is in progress.",\r\nsimple_dialog_primary_start(), simple_dialog_primary_end());\r\nreturn;\r\n}\r\n#endif\r\nif(cfile.state == FILE_READ_IN_PROGRESS) {\r\nsimple_dialog(ESD_TYPE_CONFIRMATION,\r\nESD_BTN_OK,\r\n"%sDrag and Drop currently not possible!%s\n\n"\r\n"Dropping a file isn't possible while loading another capture file.",\r\nsimple_dialog_primary_start(), simple_dialog_primary_end());\r\nreturn;\r\n}\r\nsel_data_len = gtk_selection_data_get_length(selection_data);\r\nsel_data_data = gtk_selection_data_get_data(selection_data);\r\ncf_names_freeme = (gchar *)g_malloc(sel_data_len + 1);\r\nmemcpy(cf_names_freeme, sel_data_data, sel_data_len);\r\ncf_names_freeme[sel_data_len] = '\0';\r\nif (do_file_close(&cfile, FALSE, " before opening a new capture file"))\r\ndnd_open_file_cmd(cf_names_freeme);\r\n}\r\n}\r\ngboolean\r\ngtk_osx_openFile (GtkosxApplication *app _U_, gchar *path, gpointer user_data _U_)\r\n{\r\nGtkSelectionData selection_data;\r\ngchar* selection_path;\r\nsize_t length = strlen(path);\r\nselection_path = (gchar *)g_malloc(length + 3);\r\nmemcpy(selection_path, path, length);\r\nselection_path[length] = '\r';\r\nselection_path[length + 1] = '\n';\r\nselection_path[length + 2] = '\0';\r\nmemset(&selection_data, 0, sizeof(selection_data));\r\ngtk_selection_data_set(&selection_data, gdk_atom_intern_static_string ("text/uri-list"), 8, (guchar*) selection_path, (gint)(length + 2));\r\ndnd_data_received(NULL, NULL, 0, 0, &selection_data, DND_TARGET_URL, 0, 0);\r\nreturn TRUE;\r\n}\r\nvoid\r\ndnd_init(GtkWidget *w)\r\n{\r\nstatic GtkTargetEntry target_entry[] = {\r\n{"text/uri-list", 0, DND_TARGET_URL}\r\n};\r\ngtk_drag_dest_set(\r\nw, GTK_DEST_DEFAULT_ALL, target_entry,\r\nsizeof(target_entry) / sizeof(GtkTargetEntry),\r\n(GdkDragAction)(GDK_ACTION_MOVE | GDK_ACTION_COPY) );\r\ng_signal_connect(w, "drag_data_received", G_CALLBACK(dnd_data_received), NULL);\r\n#ifdef HAVE_GTKOSXAPPLICATION\r\ng_signal_connect(g_object_new(GTKOSX_TYPE_APPLICATION, NULL), "NSApplicationOpenFile", G_CALLBACK(gtk_osx_openFile), NULL);\r\n#endif\r\n}
