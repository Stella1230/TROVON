void sha256_starts( sha256_context *ctx )\r\n{\r\nctx->total = 0;\r\nctx->state[0] = 0x6A09E667UL;\r\nctx->state[1] = 0xBB67AE85UL;\r\nctx->state[2] = 0x3C6EF372UL;\r\nctx->state[3] = 0xA54FF53AUL;\r\nctx->state[4] = 0x510E527FUL;\r\nctx->state[5] = 0x9B05688CUL;\r\nctx->state[6] = 0x1F83D9ABUL;\r\nctx->state[7] = 0x5BE0CD19UL;\r\n}\r\nstatic void sha256_process( sha256_context *ctx, const guint8 *data )\r\n{\r\nguint32 i, temp1, temp2, W[64], A, B, C, D, E, F, G, H;\r\nGET_UINT32( W[0], data, 0 );\r\nGET_UINT32( W[1], data, 4 );\r\nGET_UINT32( W[2], data, 8 );\r\nGET_UINT32( W[3], data, 12 );\r\nGET_UINT32( W[4], data, 16 );\r\nGET_UINT32( W[5], data, 20 );\r\nGET_UINT32( W[6], data, 24 );\r\nGET_UINT32( W[7], data, 28 );\r\nGET_UINT32( W[8], data, 32 );\r\nGET_UINT32( W[9], data, 36 );\r\nGET_UINT32( W[10], data, 40 );\r\nGET_UINT32( W[11], data, 44 );\r\nGET_UINT32( W[12], data, 48 );\r\nGET_UINT32( W[13], data, 52 );\r\nGET_UINT32( W[14], data, 56 );\r\nGET_UINT32( W[15], data, 60 );\r\n#define RR(x,n) ((x << (32 - n)) | ((x & 0xFFFFFFFF) >> n))\r\n#define S0(x) (RR(x, 7) ^ RR(x, 18) ^ (x >> 3))\r\n#define S1(x) (RR(x, 17) ^ RR(x, 19) ^ (x >> 10))\r\nfor (i = 16; i < 64 ; i++)\r\n{\r\nW[i] = W[i - 16] + S0(W[i - 15]) + W[i - 7] + S1(W[i - 2]);\r\n}\r\nA = ctx->state[0];\r\nB = ctx->state[1];\r\nC = ctx->state[2];\r\nD = ctx->state[3];\r\nE = ctx->state[4];\r\nF = ctx->state[5];\r\nG = ctx->state[6];\r\nH = ctx->state[7];\r\n#undef S0\r\n#undef S1\r\n#define S0(x) (RR(x, 2) ^ RR(x, 13) ^ RR(x, 22))\r\n#define S1(x) (RR(x, 6) ^ RR(x, 11) ^ RR(x, 25))\r\n#define CH(x,y,z) (z ^ (x & (y ^ z)))\r\n#define MAJ(x,y,z) (((x | y) & z) | (x & y))\r\nfor (i = 0; i < 64; ++i) {\r\ntemp1 = H + S1(E) + CH(E, F, G) + K[i] + W[i];\r\ntemp2 = S0(A) + MAJ(A, B, C);\r\nH = G;\r\nG = F;\r\nF = E;\r\nE = D + temp1;\r\nD = C;\r\nC = B;\r\nB = A;\r\nA = temp1 + temp2;\r\n}\r\nctx->state[0] += A;\r\nctx->state[1] += B;\r\nctx->state[2] += C;\r\nctx->state[3] += D;\r\nctx->state[4] += E;\r\nctx->state[5] += F;\r\nctx->state[6] += G;\r\nctx->state[7] += H;\r\n}\r\nvoid sha256_update( sha256_context *ctx, const guint8 *input, guint32 length )\r\n{\r\nguint32 left, fill;\r\nif( ! length ) return;\r\nleft = (guint32)(ctx->total % SHA256_BLOCK_SIZE);\r\nfill = SHA256_BLOCK_SIZE - left;\r\nctx->total += length;\r\nif( left && length >= fill )\r\n{\r\nmemcpy( (void *) (ctx->buffer + left),\r\n(const void *) input, fill );\r\nsha256_process( ctx, ctx->buffer );\r\nlength -= fill;\r\ninput += fill;\r\nleft = 0;\r\n}\r\nwhile( length >= SHA256_BLOCK_SIZE )\r\n{\r\nsha256_process( ctx, input );\r\nlength -= SHA256_BLOCK_SIZE;\r\ninput += SHA256_BLOCK_SIZE;\r\n}\r\nif( length )\r\n{\r\nmemcpy( (void *) (ctx->buffer + left),\r\n(const void *) input, length );\r\n}\r\n}\r\nvoid sha256_finish( sha256_context *ctx, guint8 digest[SHA256_DIGEST_LEN] )\r\n{\r\nguint32 last, padn;\r\nguint64 total_length;\r\nguint8 msglen[8];\r\ntotal_length = ctx->total * 8;\r\nlast = (guint32)(ctx->total % SHA256_BLOCK_SIZE);\r\npadn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );\r\nPUT_UINT32( total_length >> 32, msglen, 0 );\r\nPUT_UINT32( total_length, msglen, 4 );\r\nsha256_update( ctx, sha256_padding, padn );\r\nsha256_update( ctx, msglen, 8 );\r\nPUT_UINT32( ctx->state[0], digest, 0 );\r\nPUT_UINT32( ctx->state[1], digest, 4 );\r\nPUT_UINT32( ctx->state[2], digest, 8 );\r\nPUT_UINT32( ctx->state[3], digest, 12 );\r\nPUT_UINT32( ctx->state[4], digest, 16 );\r\nPUT_UINT32( ctx->state[5], digest, 20 );\r\nPUT_UINT32( ctx->state[6], digest, 24 );\r\nPUT_UINT32( ctx->state[7], digest, 28 );\r\n}\r\nvoid sha256_hmac_starts( sha256_hmac_context *hctx, const guint8 *key, guint32 keylen )\r\n{\r\nguint32 i;\r\nguint8 k_ipad[SHA256_BLOCK_SIZE];\r\nguint8 key_compress[SHA256_DIGEST_LEN];\r\nmemset( k_ipad, 0x36, SHA256_BLOCK_SIZE );\r\nmemset( hctx->k_opad, 0x5C, SHA256_BLOCK_SIZE );\r\nif (keylen > SHA256_BLOCK_SIZE)\r\n{\r\nsha256_starts( &hctx->ctx );\r\nsha256_update( &hctx->ctx, key, keylen );\r\nsha256_finish( &hctx->ctx, key_compress );\r\nkey = key_compress;\r\nkeylen = SHA256_DIGEST_LEN;\r\n}\r\nfor( i = 0; i < keylen; i++ )\r\n{\r\nk_ipad[i] ^= key[i];\r\nhctx->k_opad[i] ^= key[i];\r\n}\r\nsha256_starts( &hctx->ctx );\r\nsha256_update( &hctx->ctx, k_ipad, SHA256_BLOCK_SIZE );\r\n}\r\nvoid sha256_hmac_update( sha256_hmac_context *hctx, const guint8 *buf, guint32 buflen )\r\n{\r\nsha256_update( &hctx->ctx, buf, buflen );\r\n}\r\nvoid sha256_hmac_finish( sha256_hmac_context *hctx, guint8 digest[SHA256_DIGEST_LEN] )\r\n{\r\nguint8 tmpbuf[SHA256_DIGEST_LEN];\r\nsha256_finish( &hctx->ctx, tmpbuf );\r\nsha256_starts( &hctx->ctx );\r\nsha256_update( &hctx->ctx, hctx->k_opad, SHA256_BLOCK_SIZE );\r\nsha256_update( &hctx->ctx, tmpbuf, SHA256_DIGEST_LEN );\r\nsha256_finish( &hctx->ctx, digest );\r\n}\r\nvoid sha256_hmac( const guint8 *key, guint32 keylen, const guint8 *buf, guint32 buflen,\r\nguint8 digest[SHA256_DIGEST_LEN] )\r\n{\r\nsha256_hmac_context hctx;\r\nsha256_hmac_starts( &hctx, key, keylen );\r\nsha256_hmac_update( &hctx, buf, buflen );\r\nsha256_hmac_finish( &hctx, digest );\r\n}
