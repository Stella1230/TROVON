static void\r\nset_uinteger(fvalue_t *fv, guint32 value)\r\n{\r\nipv4_addr_and_mask_set_net_order_addr(&(fv->value.ipv4), value);\r\nipv4_addr_and_mask_set_netmask_bits(&(fv->value.ipv4), 32);\r\n}\r\nstatic gpointer\r\nvalue_get(fvalue_t *fv)\r\n{\r\nreturn &(fv->value.ipv4);\r\n}\r\nstatic gboolean\r\nval_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, gchar **err_msg)\r\n{\r\nguint32 addr;\r\nunsigned int nmask_bits;\r\nconst char *slash, *net_str;\r\nconst char *addr_str;\r\nchar *addr_str_to_free = NULL;\r\nfvalue_t *nmask_fvalue;\r\nslash = strchr(s, '/');\r\nif (slash) {\r\naddr_str_to_free = wmem_strndup(NULL, s, slash - s);\r\naddr_str = addr_str_to_free;\r\n}\r\nelse {\r\naddr_str = s;\r\n}\r\nif (!get_host_ipaddr(addr_str, &addr)) {\r\nif (err_msg != NULL) {\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid hostname or IPv4 address.",\r\naddr_str);\r\n}\r\nif (addr_str_to_free)\r\nwmem_free(NULL, addr_str_to_free);\r\nreturn FALSE;\r\n}\r\nif (addr_str_to_free)\r\nwmem_free(NULL, addr_str_to_free);\r\nipv4_addr_and_mask_set_net_order_addr(&(fv->value.ipv4), addr);\r\nif (slash) {\r\nnet_str = slash + 1;\r\nnmask_fvalue = fvalue_from_unparsed(FT_UINT32, net_str, FALSE, err_msg);\r\nif (!nmask_fvalue) {\r\nreturn FALSE;\r\n}\r\nnmask_bits = fvalue_get_uinteger(nmask_fvalue);\r\nFVALUE_FREE(nmask_fvalue);\r\nif (nmask_bits > 32) {\r\nif (err_msg != NULL) {\r\n*err_msg = g_strdup_printf("Netmask bits in a CIDR IPv4 address should be <= 32, not %u",\r\nnmask_bits);\r\n}\r\nreturn FALSE;\r\n}\r\nipv4_addr_and_mask_set_netmask_bits(&fv->value.ipv4, nmask_bits);\r\n}\r\nelse {\r\nipv4_addr_and_mask_set_netmask_bits(&(fv->value.ipv4), 32);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\nval_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_, int field_display _U_)\r\n{\r\nreturn 15;\r\n}\r\nstatic void\r\nval_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, int field_display _U_, char *buf, unsigned int size _U_)\r\n{\r\nipv4_addr_and_mask_str_buf(&fv->value.ipv4, buf);\r\n}\r\nstatic gboolean\r\ncmp_eq(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn ipv4_addr_and_mask_eq(&a->value.ipv4, &b->value.ipv4);\r\n}\r\nstatic gboolean\r\ncmp_ne(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn ipv4_addr_and_mask_ne(&a->value.ipv4, &b->value.ipv4);\r\n}\r\nstatic gboolean\r\ncmp_gt(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn ipv4_addr_and_mask_gt(&a->value.ipv4, &b->value.ipv4);\r\n}\r\nstatic gboolean\r\ncmp_ge(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn ipv4_addr_and_mask_ge(&a->value.ipv4, &b->value.ipv4);\r\n}\r\nstatic gboolean\r\ncmp_lt(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn ipv4_addr_and_mask_lt(&a->value.ipv4, &b->value.ipv4);\r\n}\r\nstatic gboolean\r\ncmp_le(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn ipv4_addr_and_mask_le(&a->value.ipv4, &b->value.ipv4);\r\n}\r\nstatic gboolean\r\ncmp_bitwise_and(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nguint32 addr_a;\r\nguint32 addr_b;\r\naddr_a = fv_a->value.ipv4.addr & fv_a->value.ipv4.nmask;\r\naddr_b = fv_b->value.ipv4.addr & fv_b->value.ipv4.nmask;\r\nreturn ((addr_a & addr_b) != 0);\r\n}\r\nvoid\r\nftype_register_ipv4(void)\r\n{\r\nstatic ftype_t ipv4_type = {\r\nFT_IPv4,\r\n"FT_IPv4",\r\n"IPv4 address",\r\n4,\r\nNULL,\r\nNULL,\r\nval_from_unparsed,\r\nNULL,\r\nval_to_repr,\r\nval_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nvalue_get,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ncmp_gt,\r\ncmp_ge,\r\ncmp_lt,\r\ncmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nftype_register(FT_IPv4, &ipv4_type);\r\n}
