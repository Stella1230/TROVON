wtap_open_return_val i4btrace_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\ni4b_trace_hdr_t hdr;\r\ngboolean byte_swapped = FALSE;\r\ni4btrace_t *i4btrace;\r\nif (!wtap_read_bytes(wth->fh, &hdr, sizeof(hdr), err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (!I4B_HDR_IS_OK(hdr)) {\r\nhdr.length = GUINT32_SWAP_LE_BE(hdr.length);\r\nhdr.unit = GUINT32_SWAP_LE_BE(hdr.unit);\r\nhdr.type = GUINT32_SWAP_LE_BE(hdr.type);\r\nhdr.dir = GUINT32_SWAP_LE_BE(hdr.dir);\r\nhdr.trunc = GUINT32_SWAP_LE_BE(hdr.trunc);\r\nif (!I4B_HDR_IS_OK(hdr)) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nbyte_swapped = TRUE;\r\n}\r\nif (file_seek(wth->fh, 0, SEEK_SET, err) == -1)\r\nreturn WTAP_OPEN_ERROR;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_I4BTRACE;\r\ni4btrace = (i4btrace_t *)g_malloc(sizeof(i4btrace_t));\r\nwth->priv = (void *)i4btrace;\r\nwth->subtype_read = i4btrace_read;\r\nwth->subtype_seek_read = i4btrace_seek_read;\r\nwth->snapshot_length = 0;\r\ni4btrace->byte_swapped = byte_swapped;\r\nwth->file_encap = WTAP_ENCAP_ISDN;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean i4btrace_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\n*data_offset = file_tell(wth->fh);\r\nreturn i4b_read_rec(wth, wth->fh, &wth->phdr, wth->frame_buffer,\r\nerr, err_info);\r\n}\r\nstatic gboolean\r\ni4btrace_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (!i4b_read_rec(wth, wth->random_fh, phdr, buf, err, err_info)) {\r\nif (*err == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\ni4b_read_rec(wtap *wth, FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\r\nint *err, gchar **err_info)\r\n{\r\ni4btrace_t *i4btrace = (i4btrace_t *)wth->priv;\r\ni4b_trace_hdr_t hdr;\r\nguint32 length;\r\nif (!wtap_read_bytes_or_eof(fh, &hdr, sizeof hdr, err, err_info))\r\nreturn FALSE;\r\nif (i4btrace->byte_swapped) {\r\nhdr.length = GUINT32_SWAP_LE_BE(hdr.length);\r\nhdr.unit = GUINT32_SWAP_LE_BE(hdr.unit);\r\nhdr.type = GUINT32_SWAP_LE_BE(hdr.type);\r\nhdr.dir = GUINT32_SWAP_LE_BE(hdr.dir);\r\nhdr.trunc = GUINT32_SWAP_LE_BE(hdr.trunc);\r\nhdr.count = GUINT32_SWAP_LE_BE(hdr.count);\r\nhdr.ts_sec = GUINT32_SWAP_LE_BE(hdr.ts_sec);\r\nhdr.ts_usec = GUINT32_SWAP_LE_BE(hdr.ts_usec);\r\n}\r\nif (hdr.length < sizeof(hdr)) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("i4btrace: record length %u < header length %lu",\r\nhdr.length, (unsigned long)sizeof(hdr));\r\nreturn FALSE;\r\n}\r\nlength = hdr.length - (guint32)sizeof(hdr);\r\nif (length > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("i4btrace: File has %u-byte packet, bigger than maximum of %u",\r\nlength, WTAP_MAX_PACKET_SIZE);\r\nreturn FALSE;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS;\r\nphdr->len = length;\r\nphdr->caplen = length;\r\nphdr->ts.secs = hdr.ts_sec;\r\nphdr->ts.nsecs = hdr.ts_usec * 1000;\r\nswitch (hdr.type) {\r\ncase TRC_CH_I:\r\nphdr->pkt_encap = WTAP_ENCAP_NULL;\r\nbreak;\r\ncase TRC_CH_D:\r\nphdr->pkt_encap = WTAP_ENCAP_ISDN;\r\nphdr->pseudo_header.isdn.channel = 0;\r\nbreak;\r\ncase TRC_CH_B1:\r\nphdr->pkt_encap = WTAP_ENCAP_ISDN;\r\nphdr->pseudo_header.isdn.channel = 1;\r\nbreak;\r\ncase TRC_CH_B2:\r\nphdr->pkt_encap = WTAP_ENCAP_ISDN;\r\nphdr->pseudo_header.isdn.channel = 2;\r\nbreak;\r\n}\r\nphdr->pseudo_header.isdn.uton = (hdr.dir == FROM_TE);\r\nreturn wtap_read_packet_bytes(fh, buf, length, err, err_info);\r\n}
