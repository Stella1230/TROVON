static int\r\ndissect_pagp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nguint32 raw_word;\r\nguint16 num_tlvs;\r\nguint16 tlv;\r\nguint16 len;\r\nguint16 ii;\r\nguint16 offset = PAGP_FIRST_TLV;\r\nguint8 raw_octet;\r\nguint8 flags;\r\nproto_tree *pagp_tree = NULL;\r\nproto_item *pagp_item, *len_item;\r\nproto_tree *tlv_tree;\r\nstatic const int * pagp_flags[] = {\r\n&hf_pagp_flags_slow_hello,\r\n&hf_pagp_flags_auto_mode,\r\n&hf_pagp_flags_consistent_state,\r\nNULL,\r\n};\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "PAGP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nraw_octet = tvb_get_guint8(tvb, PAGP_VERSION_NUMBER);\r\nif (tree) {\r\npagp_item = proto_tree_add_protocol_format(tree, proto_pagp, tvb,\r\n0, -1, "Port Aggregation Protocol");\r\npagp_tree = proto_item_add_subtree(pagp_item, ett_pagp);\r\nproto_tree_add_uint(pagp_tree, hf_pagp_version_number, tvb,\r\nPAGP_VERSION_NUMBER, 1, raw_octet);\r\n}\r\ncol_append_str(pinfo->cinfo, COL_INFO,\r\nval_to_str_const(raw_octet, pdu_vers, "Unknown PDU version"));\r\nif (raw_octet == PAGP_FLUSH_PDU) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "; Local DevID: %s",\r\ntvb_ether_to_str(tvb, PAGP_FLUSH_LOCAL_DEVICE_ID));\r\nproto_tree_add_item(pagp_tree, hf_pagp_flush_local_device_id, tvb,\r\nPAGP_FLUSH_LOCAL_DEVICE_ID, 6, ENC_NA);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Partner DevID: %s",\r\ntvb_ether_to_str(tvb, PAGP_FLUSH_PARTNER_DEVICE_ID));\r\nproto_tree_add_item(pagp_tree, hf_pagp_flush_partner_device_id, tvb,\r\nPAGP_FLUSH_PARTNER_DEVICE_ID, 6, ENC_NA);\r\nraw_word = tvb_get_ntohl(tvb, PAGP_FLUSH_TRANSACTION_ID);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "; Transaction ID: 0x%x ", raw_word);\r\nproto_tree_add_uint(pagp_tree, hf_pagp_flush_transaction_id, tvb,\r\nPAGP_FLUSH_TRANSACTION_ID, 4, raw_word);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nflags = tvb_get_guint8(tvb, PAGP_FLAGS);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "; Flags 0x%x", flags);\r\nproto_tree_add_bitmask(pagp_tree, tvb, PAGP_FLAGS, hf_pagp_flags, ett_pagp_flags, pagp_flags, ENC_NA);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "; Local DevID: %s",\r\ntvb_ether_to_str(tvb, PAGP_LOCAL_DEVICE_ID));\r\nproto_tree_add_item(pagp_tree, hf_pagp_local_device_id, tvb,\r\nPAGP_LOCAL_DEVICE_ID, 6, ENC_NA);\r\nif (tree) {\r\nproto_tree_add_item(pagp_tree, hf_pagp_local_learn_cap, tvb,\r\nPAGP_LOCAL_LEARN_CAP, 1, ENC_NA);\r\nproto_tree_add_item(pagp_tree, hf_pagp_local_port_priority, tvb,\r\nPAGP_LOCAL_PORT_PRIORITY, 1, ENC_NA);\r\nproto_tree_add_item(pagp_tree, hf_pagp_local_sent_port_ifindex, tvb,\r\nPAGP_LOCAL_SENT_PORT_IFINDEX, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pagp_tree, hf_pagp_local_group_capability, tvb,\r\nPAGP_LOCAL_GROUP_CAPABILITY, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pagp_tree, hf_pagp_local_group_ifindex, tvb,\r\nPAGP_LOCAL_GROUP_IFINDEX, 4, ENC_BIG_ENDIAN);\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Partner DevID: %s",\r\ntvb_ether_to_str(tvb, PAGP_PARTNER_DEVICE_ID));\r\nproto_tree_add_item(pagp_tree, hf_pagp_partner_device_id, tvb,\r\nPAGP_PARTNER_DEVICE_ID, 6, ENC_NA);\r\nproto_tree_add_item(pagp_tree, hf_pagp_partner_learn_cap, tvb,\r\nPAGP_PARTNER_LEARN_CAP, 1, ENC_NA);\r\nproto_tree_add_item(pagp_tree, hf_pagp_partner_port_priority, tvb,\r\nPAGP_PARTNER_PORT_PRIORITY, 1, ENC_NA);\r\nproto_tree_add_item(pagp_tree, hf_pagp_partner_sent_port_ifindex, tvb,\r\nPAGP_PARTNER_SENT_PORT_IFINDEX, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pagp_tree, hf_pagp_partner_group_capability, tvb,\r\nPAGP_PARTNER_GROUP_CAPABILITY, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pagp_tree, hf_pagp_partner_group_ifindex, tvb,\r\nPAGP_PARTNER_GROUP_IFINDEX, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pagp_tree, hf_pagp_partner_count, tvb,\r\nPAGP_PARTNER_COUNT, 2, ENC_BIG_ENDIAN);\r\nnum_tlvs = tvb_get_ntohs(tvb, PAGP_NUM_TLVS);\r\nproto_tree_add_uint(pagp_tree, hf_pagp_num_tlvs, tvb,\r\nPAGP_NUM_TLVS, 2, num_tlvs);\r\nfor ( ii = 0; ii < num_tlvs; ii++ ) {\r\ntlv = tvb_get_ntohs(tvb, offset);\r\nlen = tvb_get_ntohs(tvb, offset + 2);\r\ntlv_tree = proto_tree_add_subtree_format(pagp_tree, tvb, offset, len,\r\nett_pagp_tlvs, NULL, "TLV Entry #%d", ii+1);\r\nproto_tree_add_uint(tlv_tree, hf_pagp_tlv, tvb, offset, 2, tlv);\r\nlen_item = proto_tree_add_uint(tlv_tree, hf_pagp_tlv_length, tvb, offset+2, 2, len);\r\nif ( len == 0 ) {\r\nexpert_add_info_format(pinfo, len_item, &ei_pagp_tlv_length,\r\n"Unknown data - TLV len=0");\r\nreturn offset;\r\n}\r\nif ( tvb_reported_length_remaining(tvb, offset) < len ) {\r\nexpert_add_info_format(pinfo, len_item, &ei_pagp_tlv_length,\r\n"TLV length too large");\r\nreturn offset;\r\n}\r\nswitch (tlv) {\r\ncase PAGP_TLV_DEVICE_NAME:\r\nproto_tree_add_item(tlv_tree, hf_pagp_tlv_device_name,\r\ntvb, offset+4, len-4, ENC_NA|ENC_ASCII);\r\nbreak;\r\ncase PAGP_TLV_PORT_NAME:\r\nproto_tree_add_item(tlv_tree, hf_pagp_tlv_port_name,\r\ntvb, offset+4, len-4, ENC_NA|ENC_ASCII);\r\nbreak;\r\ncase PAGP_TLV_AGPORT_MAC:\r\nproto_tree_add_item(tlv_tree, hf_pagp_tlv_agport_mac,\r\ntvb, offset+4, 6, ENC_NA);\r\nbreak;\r\ncase PAGP_TLV_RESERVED:\r\nbreak;\r\n}\r\noffset += len;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_pagp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_pagp_version_number,\r\n{ "Version", "pagp.version",\r\nFT_UINT8, BASE_HEX, VALS(pdu_vers), 0x0,\r\n"Identifies the PAgP PDU version: 1 = Info, 2 = Flush", HFILL }},\r\n{ &hf_pagp_flags,\r\n{ "Flags", "pagp.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\n"Information flags", HFILL }},\r\n{ &hf_pagp_flags_slow_hello,\r\n{ "Slow Hello", "pagp.flags.slowhello",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), PAGP_FLAGS_SLOW_HELLO,\r\n"1 = using Slow Hello, 0 = Slow Hello disabled", HFILL }},\r\n{ &hf_pagp_flags_auto_mode,\r\n{ "Auto Mode", "pagp.flags.automode",\r\nFT_BOOLEAN, 8, TFS(&automode), PAGP_FLAGS_AUTO_MODE,\r\n"1 = Auto Mode enabled, 0 = Desirable Mode", HFILL }},\r\n{ &hf_pagp_flags_consistent_state,\r\n{ "Consistent State", "pagp.flags.state",\r\nFT_BOOLEAN, 8, NULL, PAGP_FLAGS_CONSISTENT_STATE,\r\n"1 = Consistent State, 0 = Not Ready", HFILL }},\r\n{ &hf_pagp_local_device_id,\r\n{ "Local Device ID", "pagp.localdevid",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pagp_local_learn_cap,\r\n{ "Local Learn Capability", "pagp.localearncap",\r\nFT_UINT8, BASE_HEX, VALS(learn_cap), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pagp_local_port_priority,\r\n{ "Local Port Hot Standby Priority", "pagp.localportpri",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"The local hot standby priority assigned to this port", HFILL }},\r\n{ &hf_pagp_local_sent_port_ifindex,\r\n{ "Local Sent Port ifindex", "pagp.localsentportifindex",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"The interface index of the local port used to send PDU", HFILL }},\r\n{ &hf_pagp_local_group_capability,\r\n{ "Local Group Capability", "pagp.localgroupcap",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"The local group capability", HFILL }},\r\n{ &hf_pagp_local_group_ifindex,\r\n{ "Local Group ifindex", "pagp.localgroupifindex",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"The local group interface index", HFILL }},\r\n{ &hf_pagp_partner_device_id,\r\n{ "Partner Device ID", "pagp.partnerdevid",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\n"Remote Device ID (MAC)", HFILL }},\r\n{ &hf_pagp_partner_learn_cap,\r\n{ "Partner Learn Capability", "pagp.partnerlearncap",\r\nFT_UINT8, BASE_HEX, VALS(learn_cap), 0x0,\r\n"Remote learn capability", HFILL }},\r\n{ &hf_pagp_partner_port_priority,\r\n{ "Partner Port Hot Standby Priority", "pagp.partnerportpri",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Remote port priority", HFILL }},\r\n{ &hf_pagp_partner_sent_port_ifindex,\r\n{ "Partner Sent Port ifindex", "pagp.partnersentportifindex",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Remote port interface index sent", HFILL }},\r\n{ &hf_pagp_partner_group_capability,\r\n{ "Partner Group Capability", "pagp.partnergroupcap",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"Remote group capability", HFILL }},\r\n{ &hf_pagp_partner_group_ifindex,\r\n{ "Partner Group ifindex", "pagp.partnergroupifindex",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Remote group interface index", HFILL }},\r\n{ &hf_pagp_partner_count,\r\n{ "Partner Count", "pagp.partnercount",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pagp_num_tlvs,\r\n{ "Number of TLVs", "pagp.numtlvs",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Number of TLVs following", HFILL }},\r\n{ &hf_pagp_tlv,\r\n{ "Type", "pagp.tlv",\r\nFT_UINT16, BASE_DEC, VALS(tlv_types), 0x0,\r\n"Type/Length/Value", HFILL }},\r\n{ &hf_pagp_tlv_length,\r\n{ "Length", "pagp.tlv_length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pagp_tlv_device_name,\r\n{ "Device Name", "pagp.tlvdevname",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"sysName of device", HFILL }},\r\n{ &hf_pagp_tlv_port_name,\r\n{ "Physical Port Name", "pagp.tlvportname",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Name of port used to send PDU", HFILL }},\r\n{ &hf_pagp_tlv_agport_mac,\r\n{ "Agport MAC Address", "pagp.tlvagportmac",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\n"Source MAC on frames for this aggregate", HFILL }},\r\n{ &hf_pagp_flush_local_device_id,\r\n{ "Flush Local Device ID", "pagp.flushlocaldevid",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pagp_flush_partner_device_id,\r\n{ "Flush Partner Device ID", "pagp.flushpartnerdevid",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\n"Flush remote device ID", HFILL }},\r\n{ &hf_pagp_flush_transaction_id,\r\n{ "Transaction ID", "pagp.transid",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"Flush transaction ID", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_pagp,\r\n&ett_pagp_flags,\r\n&ett_pagp_tlvs,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_pagp_tlv_length, { "pagp.tlv_length.invalid", PI_PROTOCOL, PI_WARN, "Invalid TLV length", EXPFILL }},\r\n};\r\nexpert_module_t* expert_pagp;\r\nproto_pagp = proto_register_protocol("Port Aggregation Protocol", "PAGP", "pagp");\r\nproto_register_field_array(proto_pagp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_pagp = expert_register_protocol(proto_pagp);\r\nexpert_register_field_array(expert_pagp, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_pagp(void)\r\n{\r\ndissector_handle_t pagp_handle;\r\npagp_handle = create_dissector_handle(dissect_pagp, proto_pagp);\r\ndissector_add_uint("llc.cisco_pid", 0x0104, pagp_handle);\r\n}
