static void\r\ndissect_flag(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_item *flag_item;\r\nproto_tree *flag_tree;\r\nflag_item = proto_tree_add_item(tree, hf_wai_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nflag_tree = proto_item_add_subtree (flag_item, ett_wai_flags);\r\nproto_tree_add_item (flag_tree, hf_wai_bk_rekeying_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (flag_tree, hf_wai_preauthentication_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (flag_tree, hf_wai_certificate_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (flag_tree, hf_wai_optional_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (flag_tree, hf_wai_usk_rekeying_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (flag_tree, hf_wai_negotiation_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (flag_tree, hf_wai_revoking_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (flag_tree, hf_wai_reserved_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\ninline static void\r\ndissect_bkid(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_wai_bkid, tvb, offset, 16, ENC_NA);\r\n}\r\ninline static void\r\ndissect_uskid(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_wai_uskid, tvb, offset, 1, ENC_NA);\r\n}\r\ninline static void dissect_wie(tvbuff_t *tvb, guint offset, guint length, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_wai_wie, tvb, offset, length, ENC_NA);\r\n}\r\ninline static void\r\ndissect_message_auth_code(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_wai_message_auth_code, tvb, offset, 20, ENC_NA);\r\n}\r\ninline static void\r\ndissect_mskid(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_wai_mskid, tvb, offset, 1, ENC_NA);\r\n}\r\ninline static void\r\ndissect_key_announcement_identifier(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_wai_key_ann_id, tvb, offset, 16, ENC_NA);\r\n}\r\ninline static void\r\ndissect_counter(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_wai_counter, tvb, offset, 16, ENC_NA);\r\n}\r\ninline static void\r\ndissect_authentication_id(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_wai_auth_id, tvb, offset, 32, ENC_NA);\r\n}\r\nstatic void\r\ndissect_addid(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_item *mac_item;\r\nproto_tree *mac_tree;\r\nmac_item = proto_tree_add_string(tree, hf_wai_addid, tvb, offset, 12, "AE MAC and ASUE MAC addresses");\r\nmac_tree = proto_item_add_subtree(mac_item, ett_wai_mac);\r\nproto_tree_add_item(mac_tree, hf_wai_ae_mac, tvb, offset, 6, ENC_NA);\r\nproto_tree_add_item(mac_tree, hf_wai_asue_mac, tvb, offset+6, 6, ENC_NA);\r\n}\r\nstatic guint16\r\ndissect_identity(tvbuff_t * tvb, const guint16 offset, proto_tree * tree,\r\nconst char * const label)\r\n{\r\nproto_tree *id_tree;\r\nproto_item *id_item;\r\nguint16 length;\r\nlength = tvb_get_ntohs(tvb, offset+2);\r\nid_item = proto_tree_add_item(tree, hf_wai_identity, tvb, offset, length+4, ENC_NA);\r\nid_tree = proto_item_add_subtree(id_item, ett_wai_identity);\r\nproto_item_set_text(id_item, "%sIdentity", ((label==NULL)?"":label));\r\nproto_tree_add_item(id_tree, hf_wai_identity_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(id_tree, hf_wai_identity_len, tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(id_tree, hf_wai_identity_data, tvb, offset+4, length, ENC_NA);\r\nreturn length + 4;\r\n}\r\nstatic gint16\r\ndissect_certificate(tvbuff_t * tvb, const gint offset, proto_tree * tree,\r\nconst gchar * const label)\r\n{\r\nproto_item *certificate_item;\r\nproto_tree *certificate_tree;\r\nproto_item *id_item;\r\nguint16 length;\r\nguint16 id;\r\nconst gchar *id_name = "unknown";\r\nid = tvb_get_ntohs(tvb, offset);\r\nif (id == 1) {\r\nid_name = "X.509 v3";\r\n} else if (id == 2){\r\nid_name = "GBW";\r\n}\r\nlength = tvb_get_ntohs(tvb, offset+2);\r\ncertificate_item = proto_tree_add_item(tree, hf_wai_cert, tvb, offset, length+4, ENC_NA);\r\nproto_item_set_text(certificate_item, "%sCertificate", ((label==NULL)?"":label));\r\ncertificate_tree = proto_item_add_subtree(certificate_item, ett_wai_certificate);\r\nid_item = proto_tree_add_item(certificate_tree, hf_wai_cert_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_item_set_text(id_item, "Certificate Identifier: %s (%#x)", id_name, id);\r\nproto_tree_add_item(certificate_tree, hf_wai_cert_len, tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(certificate_tree, hf_wai_cert_data, tvb, offset+4, length, ENC_NA);\r\nreturn length + 4;\r\n}\r\nstatic guint16\r\ndissect_ecdh_parameter(tvbuff_t * tvb, const gint offset, proto_tree * tree)\r\n{\r\nproto_item *ecdh_item;\r\nproto_tree *ecdh_tree;\r\nproto_item *ecdh_id_item;\r\nguint8 ecdh_id;\r\nguint16 ecdh_len;\r\nconst gchar *id_name = "unknown";\r\necdh_id = tvb_get_guint8(tvb, offset);\r\nif (ecdh_id == 1) {\r\nid_name = "OID";\r\n} else if (ecdh_id == 2) {\r\nid_name = "Detailed parameter";\r\n}\r\necdh_len = tvb_get_ntohs(tvb, offset+1);\r\necdh_item = proto_tree_add_item(tree, hf_wai_ecdh, tvb, offset, ecdh_len+3, ENC_NA);\r\necdh_tree = proto_item_add_subtree(ecdh_item, ett_wai_ecdh_param);\r\necdh_id_item = proto_tree_add_item(ecdh_tree, hf_wai_ecdh_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_set_text(ecdh_id_item, "ID: %s (%#x)", id_name, ecdh_id);\r\nproto_tree_add_item(ecdh_tree, hf_wai_ecdh_len, tvb, offset+1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ecdh_tree, hf_wai_ecdh_content, tvb, offset+3, ecdh_len, ENC_NA);\r\nreturn ecdh_len + 3;\r\n}\r\nstatic guint16\r\ndissect_challenge(tvbuff_t *tvb, guint offset, proto_tree *tree, const gchar * const label)\r\n{\r\nproto_item *challenge_item;\r\nconst guint16 challenge_length = 32;\r\nchallenge_item = proto_tree_add_item(tree, hf_wai_challenge, tvb, offset, 32, ENC_NA);\r\nproto_item_append_text(challenge_item, "(%schallenge)", ((label==NULL)?"":label));\r\nreturn challenge_length;\r\n}\r\nstatic guint16\r\ndissect_key_data(tvbuff_t *tvb, guint offset, proto_tree *tree, const gchar *const label)\r\n{\r\nproto_item *key_data_item;\r\nproto_tree *key_data_tree;\r\nguint8 length;\r\nlength = tvb_get_guint8(tvb, offset);\r\nkey_data_item = proto_tree_add_item(tree, hf_wai_key_data, tvb, offset, length+1, ENC_NA);\r\nproto_item_set_text(key_data_item, "%sKey Data", ((label==NULL)?"":label));\r\nkey_data_tree = proto_item_add_subtree(key_data_item, ett_wai_key_data);\r\nproto_tree_add_item(key_data_tree, hf_wai_key_data_len, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif (length > 0) {\r\nproto_tree_add_item(key_data_tree, hf_wai_key_data_content, tvb, offset+1, length, ENC_NA);\r\n}\r\nreturn length + 1;\r\n}\r\nstatic guint\r\ndissect_multiple_certificate(tvbuff_t * tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_item *multicert_item;\r\nproto_tree *multicert_tree;\r\nproto_item *nonce_1_item;\r\nproto_item *nonce_2_item;\r\nguint length;\r\nlength = tvb_get_ntohs(tvb, offset+1);\r\nmulticert_item = proto_tree_add_item(tree, hf_wai_cert_ver, tvb, offset, length+3, ENC_NA);\r\nmulticert_tree = proto_item_add_subtree(multicert_item, ett_wai_certificate_verification);\r\nproto_tree_add_item(multicert_tree, hf_wai_attr_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(multicert_tree, hf_wai_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nnonce_1_item = proto_tree_add_item(multicert_tree, hf_wai_nonce, tvb, offset, 32, ENC_NA);\r\noffset += 32;\r\nproto_item_append_text(nonce_1_item, " 1");\r\nnonce_2_item = proto_tree_add_item(multicert_tree, hf_wai_nonce, tvb, offset, 32, ENC_NA);\r\noffset += 32;\r\nproto_item_append_text(nonce_2_item, " 2");\r\nproto_tree_add_item(multicert_tree, hf_wai_ver_res, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\noffset += dissect_certificate(tvb, offset, multicert_tree, "1 ");\r\nproto_tree_add_item(multicert_tree, hf_wai_ver_res, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\ndissect_certificate(tvb, offset, multicert_tree, "2 ");\r\nreturn length + 3;\r\n}\r\nstatic guint\r\ndissect_identity_list(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_item *id_list_item;\r\nproto_tree *id_list_tree;\r\nguint16 length;\r\nguint16 no_of_ids;\r\nguint16 i;\r\nlength = tvb_get_ntohs(tvb, offset+1);\r\nid_list_item = proto_tree_add_item(tree, hf_wai_identity_list, tvb, offset, length+3, ENC_NA);\r\nid_list_tree = proto_item_add_subtree(id_list_item, ett_wai_identity_list);\r\nproto_tree_add_item(id_list_tree, hf_wai_attr_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(id_list_tree, hf_wai_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(id_list_tree, hf_wai_reserved_byte, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(id_list_tree, hf_wai_no_of_ids, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nno_of_ids = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\nfor(i=0; i < no_of_ids; i++) {\r\ngchar number[4] = {0};\r\ng_snprintf(number, 4, "%d", i);\r\noffset += dissect_identity(tvb, offset, id_list_tree, number);\r\n}\r\nreturn length + 3;\r\n}\r\nstatic guint16\r\ndissect_signature_algorithm(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_item *sa_item;\r\nproto_tree *sa_tree;\r\nproto_item *param_item;\r\nproto_tree *param_tree;\r\nproto_item *alg_name_item;\r\nproto_item *sig_name_item;\r\nguint16 length;\r\nguint8 alg_id;\r\nguint8 sig_id;\r\nguint16 param_len;\r\nlength = tvb_get_ntohs(tvb, offset);\r\nsa_item = proto_tree_add_item(tree, hf_wai_sign_alg, tvb, offset, length+2, ENC_NA);\r\nsa_tree = proto_item_add_subtree(sa_item, ett_wai_sign_alg);\r\nproto_tree_add_item(sa_tree, hf_wai_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nalg_name_item = proto_tree_add_item(sa_tree, hf_wai_hash_alg_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nalg_id = tvb_get_guint8(tvb, offset);\r\nif (1 == alg_id) {\r\nproto_item_set_text(alg_name_item, "Algorithm Idendifier: SHA-256 (0x01)");\r\n}\r\noffset += 1;\r\nsig_name_item = proto_tree_add_item(sa_tree, hf_wai_sign_alg_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nsig_id = tvb_get_guint8(tvb, offset);\r\nif (1 == sig_id) {\r\nproto_item_set_text(sig_name_item, "Signature Algorithm Identifier: ECDSA-192 (0x01)");\r\n}\r\noffset += 1;\r\nparam_len = tvb_get_ntohs(tvb, offset+1);\r\nparam_item = proto_tree_add_item(sa_tree, hf_wai_param, tvb, offset, param_len+3, ENC_NA);\r\nparam_tree = proto_item_add_subtree(param_item, ett_wai_parameter);\r\nproto_tree_add_item(param_tree, hf_wai_param_id, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(param_tree, hf_wai_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(param_tree, hf_wai_param_content, tvb, offset, param_len, ENC_NA);\r\nreturn length + 2;\r\n}\r\nstatic guint16\r\ndissect_signature_value(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_item *sv_item;\r\nproto_tree *sv_tree;\r\nguint16 length = 0;\r\nlength = tvb_get_ntohs(tvb, offset);\r\nsv_item = proto_tree_add_item(tree, hf_wai_sign_val, tvb, offset, length+2, ENC_NA);\r\nsv_tree = proto_item_add_subtree(sv_item, ett_wai_sign_val);\r\nproto_tree_add_item(sv_tree, hf_wai_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(sv_tree, hf_wai_sign_content, tvb, offset, length, ENC_NA);\r\nreturn length + 2;\r\n}\r\nstatic guint16\r\ndissect_signature(tvbuff_t *tvb, guint offset, proto_tree *tree, const gchar *const label)\r\n{\r\nproto_item *ss_item;\r\nproto_tree *ss_tree;\r\nguint length = 0;\r\nlength = tvb_get_ntohs(tvb, offset+1);\r\nss_item = proto_tree_add_item(tree, hf_wai_sign, tvb, offset, length+3, ENC_NA);\r\nproto_item_set_text(ss_item, "%s", (label==NULL)?"Signature":label);\r\nss_tree = proto_item_add_subtree(ss_item, ett_wai_sign);\r\nproto_tree_add_item(ss_tree, hf_wai_attr_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(ss_tree, hf_wai_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\noffset += dissect_identity(tvb, offset, ss_tree, NULL);\r\noffset += dissect_signature_algorithm(tvb, offset, ss_tree);\r\ndissect_signature_value(tvb, offset, ss_tree);\r\nreturn length + 3;\r\n}\r\nstatic void\r\ndissect_wai_data(tvbuff_t *tvb, proto_tree *tree, guint8 subtype, guint16 lenx)\r\n{\r\nproto_item *data_item;\r\nproto_tree *data_tree;\r\nconst gchar *type_name;\r\ndata_item = proto_tree_add_item(tree, hf_wai_data, tvb, 0, lenx, ENC_NA);\r\ndata_tree = proto_item_add_subtree (data_item, ett_wai_data);\r\ntype_name = val_to_str_ext_const(subtype, &wai_subtype_names_ext, "Unknown type");\r\nproto_item_set_text(data_item, "%s data (%d bytes)", type_name, lenx);\r\nswitch (subtype) {\r\ncase WAI_SUB_PRE_AUTHENTICATION:\r\n{\r\ndissect_flag(tvb, 0, data_tree);\r\ndissect_uskid(tvb, 1, data_tree);\r\ndissect_addid(tvb, 2, data_tree);\r\ndissect_counter(tvb, 14, data_tree);\r\ndissect_message_auth_code(tvb, 30, data_tree);\r\nbreak;\r\n}\r\ncase WAI_SUB_STAKEY_REQ:\r\n{\r\ndissect_flag(tvb, 0, data_tree);\r\nproto_tree_add_item(data_tree, hf_wai_sta_key_id, tvb, 1, 1, ENC_BIG_ENDIAN);\r\ndissect_uskid(tvb, 2, data_tree);\r\ndissect_addid(tvb, 3, data_tree);\r\ndissect_counter(tvb, 15, data_tree);\r\ndissect_message_auth_code(tvb, 31, data_tree);\r\nbreak;\r\n}\r\ncase WAI_SUB_AUTH_ACTIVATION:\r\n{\r\nguint16 offset = 0;\r\ndissect_flag(tvb, offset, data_tree);\r\noffset += 1;\r\ndissect_authentication_id(tvb, offset, data_tree);\r\noffset += 32;\r\noffset += dissect_identity(tvb, offset, data_tree, "Local ASU ");\r\noffset += dissect_certificate(tvb, offset, data_tree, "STE AE ");\r\ndissect_ecdh_parameter(tvb, offset, data_tree);\r\nbreak;\r\n}\r\ncase WAI_SUB_ACCESS_AUTH_REQ:\r\n{\r\nguint16 offset = 0;\r\nguint8 optional_field;\r\noptional_field = tvb_get_guint8(tvb, 0) & FLAG_BIT3;\r\ndissect_flag(tvb, offset, data_tree);\r\noffset += 1;\r\ndissect_authentication_id(tvb, offset, data_tree);\r\noffset += 32;\r\noffset += dissect_challenge(tvb, offset, data_tree, "ASUE ");\r\noffset += dissect_key_data(tvb, offset, data_tree, "ASUE ");\r\noffset += dissect_identity(tvb, offset, data_tree, "STA AE ");\r\noffset += dissect_certificate(tvb, offset, data_tree, "STA ASUE ");\r\noffset += dissect_ecdh_parameter(tvb, offset, data_tree);\r\nif (optional_field) {\r\noffset += dissect_identity_list(tvb, offset, data_tree);\r\n}\r\ndissect_signature(tvb, offset, data_tree, "ASUE Signature");\r\nbreak;\r\n}\r\ncase WAI_SUB_ACCESS_AUTH_RESP:\r\n{\r\nguint16 offset = 0;\r\nguint8 optional_field;\r\noptional_field = tvb_get_guint8(tvb, 0) & FLAG_BIT3;\r\ndissect_flag(tvb, offset, data_tree);\r\noffset += 1;\r\noffset += dissect_challenge(tvb, offset, data_tree, "ASUE ");\r\noffset += dissect_challenge(tvb, offset, data_tree, "AE ");\r\nproto_tree_add_item(data_tree, hf_wai_access_res, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\noffset += dissect_key_data(tvb, offset, data_tree, "ASUE ");\r\noffset += dissect_key_data(tvb, offset, data_tree, "AE ");\r\noffset += dissect_identity(tvb, offset, data_tree, "STA AE ");\r\noffset += dissect_identity(tvb, offset, data_tree, "STA ASUE ");\r\nif (optional_field) {\r\nguint length = 0;\r\noffset += dissect_multiple_certificate(tvb, offset, data_tree);\r\noffset += dissect_signature(tvb, offset, data_tree, "Server Signature trusted by ASUE");\r\nlength = tvb_get_ntohs(tvb, offset+1);\r\nif (length + 3 + offset + 1 < lenx)\r\noffset += dissect_signature(tvb, offset, data_tree, "Server Signature trusted by AE");\r\n}\r\ndissect_signature(tvb, offset, data_tree, "AE Signature");\r\nbreak;\r\n}\r\ncase WAI_SUB_CERT_AUTH_REQ:\r\n{\r\nguint16 offset = 0;\r\nguint8 optional_field;\r\noptional_field = tvb_get_guint8(tvb, 0) & FLAG_BIT3;\r\ndissect_addid(tvb, offset, data_tree);\r\noffset += 12;\r\noffset += dissect_challenge(tvb, offset, data_tree, "AE ");\r\noffset += dissect_challenge(tvb, offset, data_tree, "ASUE ");\r\noffset += dissect_certificate(tvb, offset, data_tree, "STE ASUE ");\r\noffset += dissect_certificate(tvb, offset, data_tree, "STE AE ");\r\nif (optional_field) {\r\ndissect_identity_list(tvb, offset, data_tree);\r\n}\r\nbreak;\r\n}\r\ncase WAI_SUB_CERT_AUTH_RESP:\r\n{\r\nguint16 offset = 0;\r\ndissect_addid(tvb, offset, data_tree);\r\noffset += 12;\r\noffset += dissect_multiple_certificate(tvb, offset, data_tree);\r\noffset += dissect_signature(tvb, offset, data_tree, "Server Signature trusted by ASUE");\r\nif (offset < lenx)\r\ndissect_signature(tvb, offset, data_tree, "Server Signature trusted by AE");\r\nbreak;\r\n}\r\ncase WAI_SUB_UNICAST_KEY_REQ:\r\n{\r\ndissect_flag(tvb, 0, data_tree);\r\ndissect_bkid(tvb, 1, data_tree);\r\ndissect_uskid(tvb, 17, data_tree);\r\ndissect_addid(tvb, 18, data_tree);\r\ndissect_challenge(tvb, 30, data_tree , "AE ");\r\nbreak;\r\n}\r\ncase WAI_SUB_UNICAST_KEY_RESP:\r\n{\r\ntvbuff_t *next_tvb;\r\nguint length = 0;\r\ndissect_flag(tvb, 0, data_tree);\r\ndissect_bkid(tvb, 1, data_tree);\r\ndissect_uskid(tvb, 17, data_tree);\r\ndissect_addid(tvb, 18, data_tree);\r\ndissect_challenge(tvb, 30, data_tree, "ASUE ");\r\ndissect_challenge(tvb, 62, data_tree, "AE ");\r\nnext_tvb = tvb_new_subset_remaining(tvb, 96);\r\nlength = tvb_reported_length(next_tvb);\r\ndissect_wie(next_tvb, 0, length-20, data_tree);\r\ndissect_message_auth_code(next_tvb, length-20, data_tree);\r\nbreak;\r\n}\r\ncase WAI_SUB_UNICAST_KEY_CONFIRM:\r\n{\r\ntvbuff_t *next_tvb;\r\nguint length = 0;\r\ndissect_flag(tvb, 0, data_tree);\r\ndissect_bkid(tvb, 1, data_tree);\r\ndissect_uskid(tvb, 17, data_tree);\r\ndissect_addid(tvb, 18, data_tree);\r\ndissect_challenge(tvb, 30, data_tree, "ASUE ");\r\nnext_tvb = tvb_new_subset_remaining(tvb, 62);\r\nlength = tvb_reported_length(next_tvb);\r\ndissect_wie(next_tvb, 0, length-20, data_tree);\r\ndissect_message_auth_code(next_tvb, length-20, data_tree);\r\nbreak;\r\n}\r\ncase WAI_SUB_MULTICAST_ANNOUNCE:\r\n{\r\nguint16 offset = 0;\r\ndissect_flag(tvb, offset, data_tree);\r\noffset += 1;\r\ndissect_mskid(tvb, offset, data_tree);\r\noffset += 1;\r\ndissect_uskid(tvb, offset, data_tree);\r\noffset += 1;\r\ndissect_addid(tvb, offset, data_tree);\r\noffset += 12;\r\nproto_tree_add_item(data_tree, hf_wai_data_pack_num, tvb, offset, 16, ENC_NA);\r\noffset += 16;\r\ndissect_key_announcement_identifier(tvb, offset, data_tree);\r\noffset += 16;\r\noffset += dissect_key_data(tvb, offset, data_tree, NULL);\r\ndissect_message_auth_code(tvb, offset, data_tree);\r\nbreak;\r\n}\r\ncase WAI_SUB_MULTICAST_ANNOUNCE_RESP:\r\n{\r\ndissect_flag(tvb, 0, data_tree);\r\ndissect_mskid(tvb, 1, data_tree);\r\ndissect_uskid(tvb, 2, data_tree);\r\ndissect_addid(tvb, 3, data_tree);\r\ndissect_key_announcement_identifier(tvb, 15, data_tree);\r\ndissect_message_auth_code(tvb, 31, data_tree);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int\r\ndissect_wai(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\n#define WAI_MESSAGE_LENGTH 12\r\n#define WAI_DATA_OFFSET WAI_MESSAGE_LENGTH\r\nguint16 version;\r\nguint8 subtype;\r\nguint16 length;\r\nguint16 packet_num;\r\nguint8 fragment_num;\r\nguint8 flags;\r\nfragment_head *frag_msg;\r\nproto_tree *wai_tree = NULL;\r\ntvbuff_t *next_tvb;\r\ntvbuff_t *new_tvb;\r\nconst gchar *subtype_name = "Unknown type";\r\nlength = tvb_get_ntohs(tvb, 6)-WAI_MESSAGE_LENGTH;\r\nsubtype = tvb_get_guint8(tvb, 3);\r\nif ((length != tvb_reported_length (tvb)-WAI_MESSAGE_LENGTH) ||\r\n(subtype > WAI_SUB_MULTICAST_ANNOUNCE_RESP)) {\r\nreturn 0;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "WAI");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nversion = tvb_get_ntohs(tvb, 0);\r\nif (version == 1) {\r\nsubtype_name = val_to_str_ext_const(subtype, &wai_subtype_names_ext, "Unknown type");\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s", subtype_name);\r\npacket_num = tvb_get_ntohs(tvb, 8);\r\nfragment_num = tvb_get_guint8(tvb, 10);\r\nflags = tvb_get_guint8(tvb, 11);\r\nif (tree) {\r\nproto_item *wai_item;\r\nwai_item = proto_tree_add_item(tree, proto_wai, tvb, 0, -1, ENC_NA);\r\nproto_item_set_text (wai_item, "WAI Protocol (%s)",\r\nval_to_str_ext_const(subtype, &wai_subtype_names_ext, "Unknown type"));\r\nwai_tree = proto_item_add_subtree(wai_item, ett_wai);\r\nproto_tree_add_item(wai_tree, hf_wai_version, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wai_tree, hf_wai_type, tvb, 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wai_tree, hf_wai_subtype, tvb, 3, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wai_tree, hf_wai_reserved, tvb, 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wai_tree, hf_wai_length, tvb, 6, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wai_tree, hf_wai_seq, tvb, 8, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wai_tree, hf_wai_fragm_seq, tvb, 10, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wai_tree, hf_wai_flag, tvb, 11, 1, ENC_BIG_ENDIAN);\r\n}\r\nfrag_msg = fragment_add_seq_check (&wai_reassembly_table,\r\ntvb, WAI_DATA_OFFSET,\r\npinfo,\r\npacket_num,\r\nNULL,\r\nfragment_num,\r\nlength,\r\nflags);\r\nnext_tvb = tvb_new_subset_remaining(tvb, WAI_DATA_OFFSET);\r\nif (flags) {\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"Fragment (%d) of message, data not dissected", fragment_num);\r\nprocess_reassembled_data(tvb, WAI_DATA_OFFSET, pinfo,\r\n"Reassembled WAI", frag_msg, &wai_frag_items,\r\nNULL, wai_tree);\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n} else {\r\nif (fragment_num > 0) {\r\nnew_tvb = process_reassembled_data(tvb, WAI_DATA_OFFSET, pinfo,\r\n"Reassembled WAI", frag_msg, &wai_frag_items,\r\nNULL, wai_tree);\r\nif (new_tvb) {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Last fragment of message, data dissected");\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, ": ", subtype_name);\r\nnext_tvb=new_tvb;\r\nlength = tvb_reported_length (next_tvb);\r\n}\r\n}\r\nif (tree) {\r\ndissect_wai_data(next_tvb, wai_tree, subtype, length);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void wai_reassemble_init (void)\r\n{\r\nreassembly_table_init(&wai_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\n}\r\nstatic void wai_reassemble_cleanup (void)\r\n{\r\nreassembly_table_destroy(&wai_reassembly_table);\r\n}\r\nvoid\r\nproto_register_wai(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_wai_version,\r\n{ "Version", "wai.version",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Version of authentication infrastructure", HFILL }},\r\n{ &hf_wai_type,\r\n{ "Type", "wai.type",\r\nFT_UINT8, BASE_HEX, VALS(wai_type_names), 0x0,\r\n"Protocol type", HFILL }},\r\n{ &hf_wai_subtype,\r\n{ "Subtype", "wai.subtype",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &wai_subtype_names_ext, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_reserved,\r\n{ "Reserved", "wai.reserved",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_length,\r\n{ "Length", "wai.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_seq,\r\n{ "Sequence number", "wai.seq",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Packet sequence number", HFILL }},\r\n{ &hf_wai_fragm_seq,\r\n{ "Fragment sequence number", "wai.fragm.seq",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_flag,\r\n{ "Flag", "wai.flag",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_data,\r\n{ "Data", "wai.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_bk_rekeying_flag,\r\n{"BK rekeying", "wai.bk.rekeying.flag",\r\nFT_BOOLEAN, 8, TFS (&wai_bk_rekeying_flag), FLAG_BIT0,\r\n"BK rekeying flag", HFILL }},\r\n{ &hf_wai_preauthentication_flag,\r\n{"Pre-Authentication", "wai.preauthentication.flag",\r\nFT_BOOLEAN, 8, TFS (&wai_preauthentication_flag), FLAG_BIT1,\r\n"Pre-Authentication flag", HFILL }},\r\n{ &hf_wai_certificate_flag,\r\n{"Certificate", "wai.certificate.flag",\r\nFT_BOOLEAN, 8, TFS (&wai_certificate_flag), FLAG_BIT2,\r\n"Certificate flag", HFILL }},\r\n{ &hf_wai_optional_flag,\r\n{"Optional", "wai.optional.flag",\r\nFT_BOOLEAN, 8, TFS (&wai_optional_flag), FLAG_BIT3,\r\n"Optional flag", HFILL }},\r\n{ &hf_wai_usk_rekeying_flag,\r\n{"USK rekeying", "wai.usk.rekeying.flag",\r\nFT_BOOLEAN, 8, TFS (&wai_usk_rekeying_flag), FLAG_BIT4,\r\n"USK rekeying flag", HFILL }},\r\n{ &hf_wai_negotiation_flag,\r\n{"STA negotiation", "wai.negotiation.flag",\r\nFT_BOOLEAN, 8, TFS (&wai_negotiation_flag), FLAG_BIT5,\r\n"STA negotiation flag", HFILL }},\r\n{ &hf_wai_revoking_flag,\r\n{"STA revoking", "wai.revoking.flag",\r\nFT_BOOLEAN, 8, TFS (&wai_revoking_flag), FLAG_BIT6,\r\n"STA revoking flag", HFILL }},\r\n{ &hf_wai_reserved_flag,\r\n{"Reserved", "wai.reserved.flag",\r\nFT_BOOLEAN, 8, TFS (&wai_reserved_flag), FLAG_BIT7,\r\n"Reserved flag", HFILL }},\r\n{ &hf_wai_attr_type,\r\n{ "Type", "wai.attrtype",\r\nFT_UINT8, BASE_HEX, VALS(wai_attr_type_names), 0x0,\r\n"Attribute type", HFILL }},\r\n{ &hf_wai_cert,\r\n{"Certificate", "wai.cert",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_cert_id,\r\n{"Id", "wai.cert.id",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"Certificate Id", HFILL }},\r\n{ &hf_wai_cert_data,\r\n{"Data", "wai.cert.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Certificate data", HFILL }},\r\n{ &hf_wai_cert_len,\r\n{"Length", "wai.cert.len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Certificate length", HFILL }},\r\n{ &hf_wai_addid,\r\n{"ADDID", "wai.addid",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_ae_mac,\r\n{"AE MAC", "wai.ae.mac",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\n"AE MAC address", HFILL }},\r\n{ &hf_wai_asue_mac,\r\n{"ASUE MAC", "wai.asue.mac",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\n"ASUE MAC address", HFILL }},\r\n{ &hf_wai_bkid,\r\n{"BKID", "wai.bkid",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_uskid,\r\n{"USKID", "wai.uskid",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_wie,\r\n{"WIE from ASUE", "wai.wie",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_message_auth_code,\r\n{"Message Authentication Code", "wai.message.auth.code",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_mskid,\r\n{"MSKID/STAKeyID", "wai.mskid",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_data_pack_num,\r\n{"Data packet number", "wai.data.packet.num",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_key_data,\r\n{"Key Data", "wai.key.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_key_data_len,\r\n{"Length", "wai.key.data.len",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Key data length", HFILL }},\r\n{ &hf_wai_key_data_content,\r\n{"Content", "wai.key.data.content",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Key data content", HFILL }},\r\n{ &hf_wai_key_ann_id,\r\n{"Key Announcement Identifier", "wai.key.ann.id",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_auth_id,\r\n{"Authentication Identifier", "wai.auth.id",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_identity,\r\n{"Identifier", "wai.identity",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_identity_id,\r\n{"Id", "wai.identity.id",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_identity_len,\r\n{"Length", "wai.identity.len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Identity length", HFILL }},\r\n{ &hf_wai_identity_data,\r\n{"Data", "wai.identity.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Identity data", HFILL }},\r\n{ &hf_wai_ecdh,\r\n{"ECDH Parameter", "wai.ecdhp",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_ecdh_id,\r\n{"ID", "wai.edch.id",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\n"ECDH Parameter Identifier", HFILL }},\r\n{ &hf_wai_ecdh_len,\r\n{"Length", "wai.ecdh.len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"ECDH Parameter Length", HFILL }},\r\n{ &hf_wai_ecdh_content,\r\n{"Content", "wai.ecdh.content",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"ECDH Parameter Content", HFILL }},\r\n{ &hf_wai_counter,\r\n{"Replay counter", "wai.counter",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_sta_key_id,\r\n{"STAKeyID", "wai.sta.key.id",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_challenge,\r\n{"Challenge", "wai.challenge",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_cert_ver,\r\n{"Multiple Certificate Verification Result", "wai.cert.ver",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_nonce,\r\n{"Nonce", "wai.nonce",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_ver_res,\r\n{"Verification result", "wai.ver.res",\r\nFT_UINT8, BASE_HEX, VALS(wai_ver_res_names), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_sign_alg,\r\n{"Signature Algorithm", "wai.sign.alg",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_hash_alg_id,\r\n{"Hash Algorithm Identifier", "wai.hash.alg.id",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_sign_alg_id,\r\n{"Signature Algorithm Identifier", "wai.sign.alg.id",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_param,\r\n{"Parameter", "wai.param",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_param_id,\r\n{"Parameter Identifier", "wai.param.id",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_param_content,\r\n{"Parameter Content", "wai.param.content",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_sign_val,\r\n{"Signature Value", "wai.sign.val",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_sign_content,\r\n{"Signature Content", "wai.sign.content",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_sign,\r\n{"Signature", "wai.sign",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_identity_list,\r\n{"ASU List trusted by ASUE", "wai.identity_list",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Identity list", HFILL }},\r\n{ &hf_wai_reserved_byte,\r\n{"Reserved", "wai.reserved.byte",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_no_of_ids,\r\n{"Number of Identities", "wai.no.of.ids",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_access_res,\r\n{"Access result", "wai.access_result",\r\nFT_UINT8, BASE_HEX, VALS(wai_access_res_names), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_wai_fragments,\r\n{"Message fragments", "wai.fragments",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }},\r\n{ &hf_wai_fragment,\r\n{"Message fragment", "wai.fragment",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }},\r\n{ &hf_wai_fragment_overlap,\r\n{"Message fragment overlap", "wai.fragment.overlap",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }},\r\n{ &hf_wai_fragment_overlap_conflicts,\r\n{"Message fragment overlapping with conflicting data", "wai.fragment.overlap.conflicts",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }},\r\n{ &hf_wai_fragment_multiple_tails,\r\n{"Message has multiple tail fragments", "wai.fragment.multiple_tails",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }},\r\n{ &hf_wai_fragment_too_long_fragment,\r\n{"Message fragment too long", "wai.fragment.too_long_fragment",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }},\r\n{ &hf_wai_fragment_error,\r\n{"Message defragmentation error", "wai.fragment.error",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }},\r\n{ &hf_wai_fragment_count,\r\n{"Message fragment count", "wai.fragment.count",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }},\r\n{ &hf_wai_reassembled_in,\r\n{"Reassembled in", "wai.reassembled.in",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }},\r\n{ &hf_wai_reassembled_length,\r\n{"Reassembled length", "wai.reassembled.length",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_wai,\r\n&ett_wai_data,\r\n&ett_wai_flags,\r\n&ett_wai_certificate,\r\n&ett_wai_mac,\r\n&ett_wai_identity,\r\n&ett_wai_key_data,\r\n&ett_wai_ecdh_param,\r\n&ett_wai_certificate_verification,\r\n&ett_wai_identity_list,\r\n&ett_wai_sign,\r\n&ett_wai_sign_alg,\r\n&ett_wai_sign_val,\r\n&ett_wai_parameter,\r\n&ett_wai_fragment,\r\n&ett_wai_fragments\r\n};\r\nproto_wai = proto_register_protocol("WAI Protocol", "WAI", "wai");\r\nregister_init_routine(&wai_reassemble_init);\r\nregister_cleanup_routine(&wai_reassemble_cleanup);\r\nproto_register_field_array(proto_wai, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nwai_handle = register_dissector("wai", dissect_wai, proto_wai);\r\n}\r\nvoid\r\nproto_reg_handoff_wai(void)\r\n{\r\ndissector_add_uint("ethertype", ETHERTYPE_WAI, wai_handle);\r\n}
