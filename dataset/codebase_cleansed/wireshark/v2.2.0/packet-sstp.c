static int\r\ndissect_sstp_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nguint16 sstp_control_flag;\r\nguint32 offset = 0;\r\nguint8 sstp_major;\r\nguint8 sstp_minor;\r\nproto_item *ti;\r\nproto_tree *sstp_tree;\r\nproto_tree *sstp_tree_attribute;\r\nproto_tree *sstp_tree_version;\r\nguint16 sstp_numattrib;\r\ntvbuff_t *tvb_next;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "SSTP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nti = proto_tree_add_item(tree, proto_sstp, tvb, 0, -1, ENC_NA);\r\nsstp_tree = proto_item_add_subtree(ti, ett_sstp);\r\nsstp_control_flag = tvb_get_guint8(tvb, SSTP_OFFSET_ISCONTROL) & SSTP_BITMASK_CONTROLFLAG;\r\nsstp_minor = (tvb_get_guint8(tvb, SSTP_OFFSET_MINORVERSION) & SSTP_BITMASK_MINORVERSION);\r\nsstp_major = (tvb_get_guint8(tvb, SSTP_OFFSET_MAJORVERSION) >> 4);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "SSTP-%u.%u ", sstp_major, sstp_minor);\r\nsstp_tree_version = proto_tree_add_subtree_format(sstp_tree, tvb, offset, SSTP_FSIZE_MAJORVERSION, ett_sstp_version,\r\nNULL, "Version %d.%d", sstp_major, sstp_minor);\r\nproto_tree_add_item(sstp_tree_version, hf_sstp_major, tvb, SSTP_OFFSET_MAJORVERSION, SSTP_FSIZE_MAJORVERSION, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sstp_tree_version, hf_sstp_minor, tvb, SSTP_OFFSET_MINORVERSION, SSTP_FSIZE_MINORVERSION, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sstp_tree, hf_sstp_reserved, tvb, SSTP_OFFSET_RESERVED, SSTP_FSIZE_RESERVED, ENC_NA);\r\nproto_tree_add_item(sstp_tree, hf_sstp_control_flag, tvb, SSTP_OFFSET_ISCONTROL, SSTP_FSIZE_ISCONTROL, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sstp_tree, hf_sstp_length, tvb, SSTP_OFFSET_LENGTH, SSTP_FSIZE_LENGTH, ENC_BIG_ENDIAN);\r\nif (sstp_control_flag) {\r\nguint16 sstp_messagetype = tvb_get_guint16(tvb, SSTP_OFFSET_MSGTYPE, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Type: CONTROL, %s; ", val_to_str(sstp_messagetype, sstp_messagetypes, "Unknown Messagetype"));\r\nproto_tree_add_item(sstp_tree, hf_sstp_messagetype, tvb, SSTP_OFFSET_MSGTYPE, SSTP_FSIZE_MSGTYPE, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sstp_tree, hf_sstp_numattrib, tvb, SSTP_OFFSET_NUMATTRIB, SSTP_FSIZE_NUMATTRIB, ENC_BIG_ENDIAN);\r\nsstp_numattrib = tvb_get_ntohs(tvb, SSTP_OFFSET_NUMATTRIB);\r\nif (sstp_numattrib > 0) {\r\nguint16 attrib_length = 0;\r\nguint8 attrib_id = 0;\r\nguint8 hashproto = 0;\r\noffset = SSTP_OFFSET_ATTRIBUTES;\r\nfor(;sstp_numattrib > 0; sstp_numattrib--) {\r\nattrib_id = tvb_get_guint8(tvb, offset+1);\r\nsstp_tree_attribute = proto_tree_add_subtree_format(sstp_tree, tvb, offset, SSTP_FSIZE_ATTRIB_RESERVED, ett_sstp_attribute,\r\nNULL, "Attribute %s", val_to_str(attrib_id, sstp_attributes, "Unknown Attribute"));\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_attrib_reserved, tvb, offset, SSTP_FSIZE_ATTRIB_RESERVED, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_attrib_id, tvb, offset, SSTP_FSIZE_ATTRIB_ID, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_attrib_length_reserved, tvb, offset, SSTP_FSIZE_ATTRIB_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_attrib_length, tvb, offset, SSTP_FSIZE_ATTRIB_LENGTH, ENC_BIG_ENDIAN);\r\nattrib_length = (tvb_get_ntohs(tvb, offset) & SSTP_BITMASK_LENGTH_LENGTH);\r\nif (attrib_length >= 4) {\r\nattrib_length -= 4;\r\n}\r\noffset += 2;\r\nswitch(attrib_id) {\r\ncase SSTP_ATTRIB_ENCAPSULATED_PROTOCOL_ID:\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_ecapsulated_protocol, tvb, offset, SSTP_FSIZE_ENCAPSULATED_PROTOCOL, ENC_BIG_ENDIAN);\r\noffset += SSTP_FSIZE_ENCAPSULATED_PROTOCOL;\r\nbreak;\r\ncase SSTP_ATTRIB_STATUS_INFO:\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_reserved, tvb, offset, SSTP_FSIZE_RESERVED2, ENC_NA);\r\noffset += SSTP_FSIZE_RESERVED2;\r\nattrib_length -= SSTP_FSIZE_RESERVED2;\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_attrib_id, tvb, offset, SSTP_FSIZE_ATTRIB_ID, ENC_BIG_ENDIAN);\r\noffset += SSTP_FSIZE_ATTRIB_ID;\r\nattrib_length -= SSTP_FSIZE_ATTRIB_ID;\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_status, tvb, offset, SSTP_FSIZE_STATUS, ENC_BIG_ENDIAN);\r\noffset += SSTP_FSIZE_STATUS;\r\nattrib_length -= SSTP_FSIZE_STATUS;\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_attrib_value, tvb, offset, attrib_length, ENC_NA);\r\noffset += attrib_length;\r\nbreak;\r\ncase SSTP_ATTRIB_CRYPTO_BINDING:\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_reserved, tvb, offset, SSTP_FSIZE_RESERVED2, ENC_NA);\r\noffset += SSTP_FSIZE_RESERVED2;\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_hash_protocol, tvb, offset, SSTP_FSIZE_HASH_PROTOCOL, ENC_BIG_ENDIAN);\r\nhashproto = tvb_get_guint8(tvb, offset);\r\noffset += SSTP_FSIZE_HASH_PROTOCOL;\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_nonce, tvb, offset, SSTP_FSIZE_NONCE, ENC_NA);\r\noffset += SSTP_FSIZE_NONCE;\r\nif (hashproto == SSTP_CERT_HASH_PROTOCOL_SHA1) {\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_cert_hash, tvb, offset, SSTP_FSIZE_CERT_HASH_SHA1, ENC_NA);\r\noffset += SSTP_FSIZE_CERT_HASH_SHA1;\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_padding, tvb, offset, SSTP_FSIZE_PADDING_SHA1, ENC_NA);\r\noffset += SSTP_FSIZE_PADDING_SHA1;\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_compound_mac, tvb, offset, SSTP_FSIZE_COMPOUND_MAC_SHA1, ENC_NA);\r\noffset += SSTP_FSIZE_COMPOUND_MAC_SHA1;\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_padding, tvb, offset, SSTP_FSIZE_PADDING_SHA1, ENC_NA);\r\noffset += SSTP_FSIZE_PADDING_SHA1;\r\n}\r\nif (hashproto == SSTP_CERT_HASH_PROTOCOL_SHA256) {\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_cert_hash, tvb, offset, SSTP_FSIZE_CERT_HASH_SHA256, ENC_NA);\r\noffset += SSTP_FSIZE_CERT_HASH_SHA256;\r\n}\r\nbreak;\r\ncase SSTP_ATTRIB_CRYPTO_BINDING_REQ:\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_reserved, tvb, offset, SSTP_FSIZE_RESERVED2, ENC_NA);\r\noffset += SSTP_FSIZE_RESERVED2;\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_hash_protocol, tvb, offset, SSTP_FSIZE_HASH_PROTOCOL, ENC_BIG_ENDIAN);\r\noffset += SSTP_FSIZE_HASH_PROTOCOL;\r\nproto_tree_add_item(sstp_tree_attribute, hf_sstp_nonce, tvb, offset, SSTP_FSIZE_NONCE, ENC_NA);\r\noffset += SSTP_FSIZE_NONCE;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nproto_tree_add_item(sstp_tree, hf_sstp_data_unknown, tvb, offset, -1, ENC_NA);\r\n}\r\n} else {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Type: DATA; ");\r\ntvb_next = tvb_new_subset_remaining(tvb, SSTP_OFFSET_DATA);\r\ncall_dissector(ppp_handle, tvb_next, pinfo, tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic guint\r\nget_sstp_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nreturn tvb_get_ntohs(tvb, offset+SSTP_OFFSET_LENGTH);\r\n}\r\nstatic int\r\ndissect_sstp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, tree, TRUE, SSTP_OFFSET_LENGTH+SSTP_FSIZE_LENGTH, get_sstp_pdu_len, dissect_sstp_pdu, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_sstp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_sstp_major,\r\n{ "Major Version", "sstp.majorversion",\r\nFT_UINT8, BASE_DEC,\r\nNULL, SSTP_BITMASK_MAJORVERSION,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_minor,\r\n{ "Minor Version", "sstp.minorversion",\r\nFT_UINT8, BASE_DEC,\r\nNULL, SSTP_BITMASK_MINORVERSION,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_reserved,\r\n{ "Reserved", "sstp.reserved",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_control_flag,\r\n{ "Control Packet", "sstp.iscontrol",\r\nFT_BOOLEAN, 8,\r\nNULL, SSTP_BITMASK_CONTROLFLAG,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_length,\r\n{ "Length-Packet", "sstp.length",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_messagetype,\r\n{ "Message Type", "sstp.messagetype",\r\nFT_UINT16, BASE_HEX,\r\nVALS(sstp_messagetypes), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_numattrib,\r\n{ "Number of Attributes", "sstp.numattrib",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_attrib_reserved,\r\n{ "Reserved", "sstp.attribreserved",\r\nFT_UINT8, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_attrib_id,\r\n{ "ID", "sstp.attribid",\r\nFT_UINT8, BASE_DEC,\r\nVALS(sstp_attributes), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_attrib_length_reserved,\r\n{ "Reserved", "sstp.attriblengthreserved",\r\nFT_UINT16, BASE_HEX,\r\nNULL, SSTP_BITMASK_LENGTH_RESERVED,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_attrib_length,\r\n{ "Length", "sstp.attriblength",\r\nFT_UINT16, BASE_DEC,\r\nNULL, SSTP_BITMASK_LENGTH_LENGTH,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_data_unknown,\r\n{ "Unknown Data", "sstp.dataunknown",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_hash_protocol,\r\n{ "Hash Protocol", "sstp.hash",\r\nFT_UINT8, BASE_HEX,\r\nVALS(hash_protocols), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_nonce,\r\n{ "Nonce", "sstp.nonce",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_cert_hash,\r\n{ "Cert Hash", "sstp.cert_hash",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_padding,\r\n{ "Padding", "sstp.padding",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_compound_mac,\r\n{ "Compound Mac", "sstp.compoundmac",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_ecapsulated_protocol,\r\n{ "Encapsulated Procotol", "sstp.encapsulatedprotocol",\r\nFT_UINT16, BASE_HEX,\r\nVALS(encapsulated_protocols), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_status,\r\n{ "Status", "sstp.status",\r\nFT_UINT32, BASE_HEX,\r\nVALS(attrib_status), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sstp_attrib_value,\r\n{ "Attribute Value", "sstp.attribvalue",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_sstp,\r\n&ett_sstp_attribute,\r\n&ett_sstp_version\r\n};\r\nproto_sstp = proto_register_protocol("Secure Socket Tunneling Protocol", "SSTP", "sstp");\r\nregister_dissector("sstp", dissect_sstp, proto_sstp);\r\nproto_register_field_array(proto_sstp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_sstp(void)\r\n{\r\nppp_handle = find_dissector_add_dependency("ppp", proto_sstp);\r\n}
