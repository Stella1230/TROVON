static int\r\ndissect_atmtcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *atmtcp_tree;\r\nguint offset = 0;\r\ngint32 length;\r\ntvbuff_t *next_tvb;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ATMTCP");\r\ncol_add_str(pinfo->cinfo, COL_INFO, "ATMTCP");\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_atmtcp, tvb, 0, -1, ENC_NA);\r\natmtcp_tree = proto_item_add_subtree(ti, ett_atmtcp);\r\nproto_tree_add_item(atmtcp_tree, hf_atmtcp_vpi, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n}\r\noffset += 2;\r\nif (tree) {\r\nproto_tree_add_item(atmtcp_tree, hf_atmtcp_vci, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n}\r\noffset += 2;\r\nif (tree) {\r\nproto_tree_add_item(atmtcp_tree, hf_atmtcp_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\nlength = tvb_get_ntohl(tvb, offset);\r\nif(length == ATMTCP_HDR_MAGIC)\r\n{\r\ncol_append_str(pinfo->cinfo, COL_INFO, " Command");\r\n}\r\nelse\r\n{\r\ncol_append_str(pinfo->cinfo, COL_INFO, " Data");\r\n}\r\noffset += 4;\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nvoid\r\nproto_register_atmtcp(void)\r\n{\r\nmodule_t *atmtcp_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_atmtcp_vpi,\r\n{ "VPI", "atmtcp.vpi", FT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Virtual Path Identifier", HFILL }\r\n},\r\n{ &hf_atmtcp_vci,\r\n{ "VCI", "atmtcp.vci", FT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Virtual Channel Identifier", HFILL }\r\n},\r\n{ &hf_atmtcp_length,\r\n{ "Length", "atmtcp.length", FT_UINT32, BASE_DEC, NULL, 0x0,\r\n"length of data", HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_atmtcp\r\n};\r\nproto_atmtcp = proto_register_protocol("ATM over TCP", "ATMTCP", "atmtcp");\r\nproto_register_field_array(proto_atmtcp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\natmtcp_module = prefs_register_protocol(proto_atmtcp, proto_reg_handoff_atmtcp);\r\nprefs_register_uint_preference(atmtcp_module, "tcp.port", "ATMTCP TCP Port",\r\n"ATMTCP TCP port if other than the default",\r\n10, &global_atmtcp_tcp_port);\r\n}\r\nvoid\r\nproto_reg_handoff_atmtcp(void)\r\n{\r\nstatic gboolean initialized = FALSE;\r\nstatic dissector_handle_t atmtcp_handle;\r\nstatic int current_port;\r\nif (!initialized) {\r\natmtcp_handle = create_dissector_handle(dissect_atmtcp, proto_atmtcp);\r\ninitialized = TRUE;\r\n} else {\r\ndissector_delete_uint("tcp.port", current_port, atmtcp_handle);\r\n}\r\ncurrent_port = global_atmtcp_tcp_port;\r\ndissector_add_uint("tcp.port", current_port, atmtcp_handle);\r\n}
