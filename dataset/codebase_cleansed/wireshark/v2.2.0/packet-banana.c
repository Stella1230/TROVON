static int\r\ndissect_banana_element(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset) {\r\nproto_item *ti;\r\nproto_tree *list_tree;\r\nguint8 byte = 0;\r\ngint64 val = 0;\r\ngint val_len = 0;\r\nint start_offset = offset;\r\nint old_offset;\r\nint i;\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nbyte = tvb_get_guint8(tvb, offset);\r\noffset++;\r\nif (byte & 0x80) {\r\nif (is_element(byte)) {\r\nbreak;\r\n} else {\r\nexpert_add_info_format(pinfo, NULL, &ei_banana_unknown_type, "Unknown type %u", byte);\r\n}\r\n} else {\r\nval_len++;\r\nif (val_len > MAX_ELEMENT_VAL_LEN) {\r\nexpert_add_info(pinfo, NULL, &ei_banana_too_many_value_bytes);\r\n}\r\nval += byte + (val << 7);\r\n}\r\n}\r\nswitch (byte) {\r\ncase BE_LIST:\r\nif (val > MAX_ELEMENT_VAL) {\r\nexpert_add_info_format(pinfo, NULL, &ei_banana_length_too_long, "List length %" G_GINT64_MODIFIER "d longer than we can handle", val);\r\n}\r\nti = proto_tree_add_uint_format_value(tree, hf_banana_list, tvb, start_offset, offset - start_offset - 1, (guint32) val, "(%d items)", (gint) val);\r\nlist_tree = proto_item_add_subtree(ti, ett_list);\r\nfor (i = 0; i < val; i++) {\r\nold_offset = offset;\r\noffset += dissect_banana_element(tvb, pinfo, list_tree, offset);\r\nif (offset <= old_offset) {\r\nreturn offset - start_offset;\r\n}\r\n}\r\nbreak;\r\ncase BE_INT:\r\nif (val > MAX_ELEMENT_VAL) {\r\nexpert_add_info_format(pinfo, NULL, &ei_banana_value_too_large, "Integer value %" G_GINT64_MODIFIER "d too large", val);\r\n}\r\nproto_tree_add_uint(tree, hf_banana_int, tvb, start_offset, offset - start_offset, (guint32) val);\r\nbreak;\r\ncase BE_STRING:\r\nif (val > MAX_ELEMENT_VAL) {\r\nexpert_add_info_format(pinfo, NULL, &ei_banana_length_too_long, "String length %" G_GINT64_MODIFIER "d longer than we can handle", val);\r\n}\r\nproto_tree_add_item(tree, hf_banana_string, tvb, offset, (guint32) val, ENC_ASCII|ENC_NA);\r\noffset += (gint) val;\r\nbreak;\r\ncase BE_NEG_INT:\r\nif (val > MAX_ELEMENT_VAL) {\r\nexpert_add_info_format(pinfo, NULL, &ei_banana_value_too_large, "Integer value -%" G_GINT64_MODIFIER "d too large", val);\r\n}\r\nproto_tree_add_int(tree, hf_banana_neg_int, tvb, start_offset, offset - start_offset, (gint32) val * -1);\r\nbreak;\r\ncase BE_FLOAT:\r\nproto_tree_add_item(tree, hf_banana_float, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\nbreak;\r\ncase BE_LG_INT:\r\nproto_tree_add_item(tree, hf_banana_lg_int, tvb, start_offset, offset - start_offset, ENC_NA);\r\nbreak;\r\ncase BE_LG_NEG_INT:\r\nproto_tree_add_item(tree, hf_banana_lg_neg_int, tvb, start_offset, offset - start_offset, ENC_NA);\r\nbreak;\r\ncase BE_PB:\r\nif (val_len > 1) {\r\nexpert_add_info(pinfo, NULL, &ei_banana_pb_error);\r\n}\r\nproto_tree_add_item(tree, hf_banana_pb, tvb, offset - 2, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\nbreak;\r\n}\r\nreturn offset - start_offset;\r\n}\r\nstatic int\r\ndissect_banana(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_) {\r\nguint8 byte = 0;\r\ngint offset = 0, old_offset;\r\nproto_item *ti;\r\nproto_tree *banana_tree;\r\nif (tvb_reported_length(tvb) < 2)\r\nreturn 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Banana");\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0 && offset < MAX_ELEMENT_VAL_LEN) {\r\nbyte = tvb_get_guint8(tvb, offset);\r\nif (is_element(byte))\r\nbreak;\r\noffset++;\r\n}\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "First element: %s",\r\nval_to_str(byte, type_vals, "Unknown type: %u"));\r\nti = proto_tree_add_item(tree, proto_banana, tvb, 0, -1, ENC_NA);\r\nbanana_tree = proto_item_add_subtree(ti, ett_banana);\r\noffset = 0;\r\nold_offset = -1;\r\nwhile (offset > old_offset) {\r\nold_offset = offset;\r\noffset += dissect_banana_element(tvb, pinfo, banana_tree, offset);\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic void\r\nbanana_prefs(void) {\r\ndissector_delete_uint_range("tcp.port", banana_tcp_range, banana_handle);\r\ng_free(banana_tcp_range);\r\nbanana_tcp_range = range_copy(global_banana_tcp_range);\r\ndissector_add_uint_range("tcp.port", banana_tcp_range, banana_handle);\r\n}\r\nvoid\r\nproto_register_banana(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_banana_list,\r\n{ "List Length", "banana.list",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Banana list", HFILL }\r\n},\r\n{ &hf_banana_int,\r\n{ "Integer", "banana.int",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Banana integer", HFILL }\r\n},\r\n{ &hf_banana_string,\r\n{ "String", "banana.string",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\n"Banana string", HFILL }\r\n},\r\n{ &hf_banana_neg_int,\r\n{ "Negative Integer", "banana.neg_int",\r\nFT_INT32, BASE_DEC, NULL, 0,\r\n"Banana negative integer", HFILL }\r\n},\r\n{ &hf_banana_float,\r\n{ "Float", "banana.float",\r\nFT_DOUBLE, BASE_NONE, NULL, 0,\r\n"Banana float", HFILL }\r\n},\r\n{ &hf_banana_lg_int,\r\n{ "Float", "banana.lg_int",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Banana large integer", HFILL }\r\n},\r\n{ &hf_banana_lg_neg_int,\r\n{ "Float", "banana.lg_neg_int",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Banana large negative integer", HFILL }\r\n},\r\n{ &hf_banana_pb,\r\n{ "pb Profile Value", "banana.pb",\r\nFT_UINT8, BASE_HEX, VALS(pb_vals), 0,\r\n"Banana Perspective Broker Profile Value", HFILL }\r\n}\r\n};\r\nmodule_t *banana_module;\r\nexpert_module_t* expert_banana;\r\nstatic gint *ett[] = {\r\n&ett_banana,\r\n&ett_list\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_banana_unknown_type, { "banana.unknown_type", PI_UNDECODED, PI_ERROR, "Unknown type", EXPFILL }},\r\n{ &ei_banana_too_many_value_bytes, { "banana.too_many_value_bytes", PI_UNDECODED, PI_ERROR, "Too many value/length bytes", EXPFILL }},\r\n{ &ei_banana_length_too_long, { "banana.length_too_long", PI_UNDECODED, PI_ERROR, "Length too long", EXPFILL }},\r\n{ &ei_banana_value_too_large, { "banana.value_too_large", PI_MALFORMED, PI_ERROR, "Value too large", EXPFILL }},\r\n{ &ei_banana_pb_error, { "banana.pb_error", PI_MALFORMED, PI_ERROR, "More than 1 byte before pb", EXPFILL }},\r\n};\r\nproto_banana = proto_register_protocol("Twisted Banana", "Banana", "banana");\r\nproto_register_field_array(proto_banana, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_banana = expert_register_protocol(proto_banana);\r\nexpert_register_field_array(expert_banana, ei, array_length(ei));\r\nbanana_module = prefs_register_protocol(proto_banana, banana_prefs);\r\nbanana_tcp_range = range_empty();\r\nprefs_register_range_preference(banana_module, "tcp.port", "TCP Ports", "Banana TCP Port range", &global_banana_tcp_range, 65535);\r\n}\r\nvoid\r\nproto_reg_handoff_banana(void)\r\n{\r\nbanana_handle = create_dissector_handle(dissect_banana, proto_banana);\r\n}
