static void\r\ndissect_unknown(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree)\r\n{\r\ncall_data_dissector(tvb_new_subset_remaining(tvb, offset), pinfo, tree);\r\n}\r\nstatic void\r\ndissect_cntrl_req(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (!tree)\r\nreturn;\r\nproto_tree_add_uint_format_value(tree, hf_pptp_protocol_version, tvb, offset,\r\n2, tvb_get_ntohs(tvb, offset), "%u.%u",\r\ntvb_get_guint8(tvb, offset), tvb_get_guint8(tvb, offset + 1));\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_reserved, tvb, offset, 2, ENC_NA);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_framing_capabilities, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_bearer_capabilities, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_maximum_channels, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_firmware_revision, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_host_name, tvb, offset, 64, ENC_ASCII|ENC_NA);\r\noffset += 64;\r\nproto_tree_add_item(tree, hf_pptp_vendor_name, tvb, offset, 64, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\ndissect_cntrl_reply(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (!tree)\r\nreturn;\r\nproto_tree_add_uint_format_value(tree, hf_pptp_protocol_version, tvb, offset,\r\n2, tvb_get_ntohs(tvb, offset), "%u.%u",\r\ntvb_get_guint8(tvb, offset), tvb_get_guint8(tvb, offset + 1));\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_control_result, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_pptp_error, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_pptp_framing_capabilities, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_bearer_capabilities, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_maximum_channels, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_firmware_revision, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_host_name, tvb, offset, 64, ENC_ASCII|ENC_NA);\r\noffset += 64;\r\nproto_tree_add_item(tree, hf_pptp_vendor_name, tvb, offset, 64, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\ndissect_stop_req(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (!tree)\r\nreturn;\r\nproto_tree_add_item(tree, hf_pptp_reason, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_pptp_reserved, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_pptp_reserved, tvb, offset, 2, ENC_NA);\r\n}\r\nstatic void\r\ndissect_stop_reply(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (!tree)\r\nreturn;\r\nproto_tree_add_item(tree, hf_pptp_stop_result, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_pptp_error, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_pptp_reserved, tvb, offset, 2, ENC_NA);\r\n}\r\nstatic void\r\ndissect_echo_req(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (!tree)\r\nreturn;\r\nproto_tree_add_item(tree, hf_pptp_identifier, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_echo_reply(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (!tree)\r\nreturn;\r\nproto_tree_add_item(tree, hf_pptp_identifier, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_echo_result, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_pptp_error, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_pptp_reserved, tvb, offset, 2, ENC_NA);\r\n}\r\nstatic void\r\ndissect_out_req(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (!tree)\r\nreturn;\r\nproto_tree_add_item(tree, hf_pptp_call_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_call_serial_number, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_minimum_bps, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_maximum_bps, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_bearer_type, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_framing_type, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_packet_receive_window_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_packet_processing_delay, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_phone_number_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_reserved, tvb, offset, 2, ENC_NA);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_phone_number, tvb, offset, 64, ENC_ASCII|ENC_NA);\r\noffset += 64;\r\nproto_tree_add_item(tree, hf_pptp_subaddress, tvb, offset, 64, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\ndissect_out_reply(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (!tree)\r\nreturn;\r\nproto_tree_add_item(tree, hf_pptp_call_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_peer_call_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_out_result, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_pptp_error, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_pptp_cause, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_connect_speed, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_packet_receive_window_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_packet_processing_delay, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_physical_channel_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_in_req(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (!tree)\r\nreturn;\r\nproto_tree_add_item(tree, hf_pptp_call_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_call_serial_number, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_bearer_type, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_physical_channel_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_dialed_number_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_dialing_number_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_dialed_number, tvb, offset, 64, ENC_ASCII|ENC_NA);\r\noffset += 64;\r\nproto_tree_add_item(tree, hf_pptp_dialing_number, tvb, offset, 64, ENC_ASCII|ENC_NA);\r\noffset += 64;\r\nproto_tree_add_item(tree, hf_pptp_subaddress, tvb, offset, 64, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\ndissect_in_reply(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (!tree)\r\nreturn;\r\nproto_tree_add_item(tree, hf_pptp_call_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_peer_call_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_in_result, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_pptp_error, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_pptp_packet_receive_window_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_packet_processing_delay, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_reserved, tvb, offset, 2, ENC_NA);\r\n}\r\nstatic void\r\ndissect_in_connected(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (!tree)\r\nreturn;\r\nproto_tree_add_item(tree, hf_pptp_peer_call_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_reserved, tvb, offset, 2, ENC_NA);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_connect_speed, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_packet_receive_window_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_packet_processing_delay, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_framing_type, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_clear_req(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (!tree)\r\nreturn;\r\nproto_tree_add_item(tree, hf_pptp_call_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_reserved, tvb, offset, 2, ENC_NA);\r\n}\r\nstatic void\r\ndissect_disc_notify(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (!tree)\r\nreturn;\r\nproto_tree_add_item(tree, hf_pptp_call_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_disc_result, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_pptp_error, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_pptp_cause, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_reserved, tvb, offset, 2, ENC_NA);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_call_statistics, tvb, offset, 64, ENC_ASCII|ENC_NA);\r\n}\r\nstatic void\r\ndissect_error_notify(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (!tree)\r\nreturn;\r\nproto_tree_add_item(tree, hf_pptp_peer_call_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_reserved, tvb, offset, 2, ENC_NA);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_crc_errors, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_framing_errors, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_hardware_overruns, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_buffer_overruns, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_timeout_errors, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_alignment_errors, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_set_link(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nif (!tree)\r\nreturn;\r\nproto_tree_add_item(tree, hf_pptp_peer_call_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_reserved, tvb, offset, 2, ENC_NA);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pptp_send_accm, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pptp_receive_accm, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\nstatic int\r\ndissect_pptp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *pptp_tree = NULL;\r\nproto_item *item = NULL;\r\nint offset = 0;\r\nguint16 len;\r\nguint16 control_message_type;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "PPTP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nlen = tvb_get_ntohs(tvb, offset);\r\ncontrol_message_type = tvb_get_ntohs(tvb, offset + 8);\r\ncol_add_str(pinfo->cinfo, COL_INFO,\r\nval_to_str(control_message_type, control_message_type_vals,\r\n"Unknown control type (%d)"));\r\nif (tree) {\r\nproto_item *ti;\r\nti = proto_tree_add_item(tree, proto_pptp, tvb, offset, len, ENC_NA);\r\npptp_tree = proto_item_add_subtree(ti, ett_pptp);\r\nproto_tree_add_item(pptp_tree, hf_pptp_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pptp_tree, hf_pptp_message_type, tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nitem = proto_tree_add_item(pptp_tree, hf_pptp_magic_cookie, tvb, offset+4, 4, ENC_BIG_ENDIAN);\r\n}\r\nif (tvb_get_ntohl(tvb, offset+4) == MAGIC_COOKIE)\r\nproto_item_append_text(item," (correct)");\r\nelse {\r\nproto_item_append_text(item," (incorrect)");\r\nexpert_add_info(pinfo, item, &ei_pptp_incorrect_magic_cookie);\r\n}\r\nif (tree) {\r\nproto_tree_add_item(pptp_tree, hf_pptp_control_message_type, tvb, offset+8, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pptp_tree, hf_pptp_reserved, tvb, offset+10, 2, ENC_NA);\r\n}\r\noffset += offset + 12;\r\nswitch(control_message_type){\r\ncase CNTRL_REQ:\r\ndissect_cntrl_req(tvb, offset, pinfo, pptp_tree);\r\nbreak;\r\ncase CNTRL_REPLY:\r\ndissect_cntrl_reply(tvb, offset, pinfo, pptp_tree);\r\nbreak;\r\ncase STOP_REQ:\r\ndissect_stop_req(tvb, offset, pinfo, pptp_tree);\r\nbreak;\r\ncase STOP_REPLY:\r\ndissect_stop_reply(tvb, offset, pinfo, pptp_tree);\r\nbreak;\r\ncase ECHO_REQ:\r\ndissect_echo_req(tvb, offset, pinfo, pptp_tree);\r\nbreak;\r\ncase ECHO_REPLY:\r\ndissect_echo_reply(tvb, offset, pinfo, pptp_tree);\r\nbreak;\r\ncase OUT_REQ:\r\ndissect_out_req(tvb, offset, pinfo, pptp_tree);\r\nbreak;\r\ncase OUT_REPLY:\r\ndissect_out_reply(tvb, offset, pinfo, pptp_tree);\r\nbreak;\r\ncase IN_REQ:\r\ndissect_in_req(tvb, offset, pinfo, pptp_tree);\r\nbreak;\r\ncase IN_REPLY:\r\ndissect_in_reply(tvb, offset, pinfo, pptp_tree);\r\nbreak;\r\ncase IN_CONNECTED:\r\ndissect_in_connected(tvb, offset, pinfo, pptp_tree);\r\nbreak;\r\ncase CLEAR_REQ:\r\ndissect_clear_req(tvb, offset, pinfo, pptp_tree);\r\nbreak;\r\ncase DISC_NOTIFY:\r\ndissect_disc_notify(tvb, offset, pinfo, pptp_tree);\r\nbreak;\r\ncase ERROR_NOTIFY:\r\ndissect_error_notify(tvb, offset, pinfo, pptp_tree);\r\nbreak;\r\ncase SET_LINK:\r\ndissect_set_link(tvb, offset, pinfo, pptp_tree);\r\nbreak;\r\ndefault:\r\ndissect_unknown(tvb, offset, pinfo, pptp_tree);\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_pptp(void)\r\n{\r\nstatic gint *ett[] = {\r\n&ett_pptp,\r\n};\r\nstatic hf_register_info hf[] = {\r\n{ &hf_pptp_length,\r\n{ "Length", "pptp.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Total length in octets of this PPTP message", HFILL }\r\n},\r\n{ &hf_pptp_message_type,\r\n{ "Message type", "pptp.type",\r\nFT_UINT16, BASE_DEC, VALS(msgtype_vals), 0x0,\r\n"PPTP message type", HFILL }\r\n},\r\n{ &hf_pptp_magic_cookie,\r\n{ "Magic Cookie", "pptp.magic_cookie",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"This constant value is used as a sanity check on received messages", HFILL }\r\n},\r\n{ &hf_pptp_control_message_type,\r\n{ "Control Message Type", "pptp.control_message_type",\r\nFT_UINT16, BASE_DEC, VALS(control_message_type_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pptp_reserved,\r\n{ "Reserved", "pptp.reserved",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"This field MUST be 0", HFILL }\r\n},\r\n{ &hf_pptp_protocol_version,\r\n{ "Protocol version", "pptp.protocol_version",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"The version of the PPTP protocol", HFILL }\r\n},\r\n{ &hf_pptp_framing_capabilities,\r\n{ "Framing Capabilities", "pptp.framing_capabilities",\r\nFT_UINT32, BASE_DEC, VALS(frametype_vals), 0x0,\r\n"A set of bits indicating the type of framing", HFILL }\r\n},\r\n{ &hf_pptp_bearer_capabilities,\r\n{ "Bearer Capabilities", "pptp.bearer_capabilities",\r\nFT_UINT32, BASE_DEC, VALS(bearertype_vals), 0x0,\r\n"A set of bits indicating the type of bearer", HFILL }\r\n},\r\n{ &hf_pptp_maximum_channels,\r\n{ "Maximum Channels", "pptp.maximum_channels",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"The total number of individual PPP sessions this PAC can support", HFILL }\r\n},\r\n{ &hf_pptp_firmware_revision,\r\n{ "Firmware Revision", "pptp.firmware_revision",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"This field contains the firmware revision", HFILL }\r\n},\r\n{ &hf_pptp_host_name,\r\n{ "Host Name", "pptp.host_name",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"A 64 octet field containing the DNS name", HFILL }\r\n},\r\n{ &hf_pptp_vendor_name,\r\n{ "Vendor Name", "pptp.vendor_name",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"A 64 octet field containing a vendor", HFILL }\r\n},\r\n{ &hf_pptp_control_result,\r\n{ "Result Code", "pptp.control_result",\r\nFT_UINT8, BASE_DEC, VALS(control_resulttype_vals), 0x0,\r\n"Indicates the result of the command channel establishment attempt", HFILL }\r\n},\r\n{ &hf_pptp_error,\r\n{ "Error Code", "pptp.error",\r\nFT_UINT8, BASE_DEC, VALS(errortype_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pptp_reason,\r\n{ "Reason", "pptp.reason",\r\nFT_UINT8, BASE_DEC, VALS(reasontype_vals), 0x0,\r\n"Indicates the reason for the control connection being close", HFILL }\r\n},\r\n{ &hf_pptp_stop_result,\r\n{ "Result Code", "pptp.stop_result",\r\nFT_UINT8, BASE_DEC, VALS(stop_resulttype_vals), 0x0,\r\n"Indicates the result of the attempt to close the control connection", HFILL }\r\n},\r\n{ &hf_pptp_identifier,\r\n{ "Identifier", "pptp.identifier",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pptp_echo_result,\r\n{ "Result Code", "pptp.echo_result",\r\nFT_UINT8, BASE_DEC, VALS(echo_resulttype_vals), 0x0,\r\n"Indicates the result of the receipt of the Echo-Request", HFILL }\r\n},\r\n{ &hf_pptp_call_id,\r\n{ "Call ID", "pptp.call_id",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"A unique identifier, unique to a particular PAC-PNS pair assigned by the PNS", HFILL }\r\n},\r\n{ &hf_pptp_call_serial_number,\r\n{ "Call Serial Number", "pptp.call_serial_number",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"An identifier assigned by the PNS to this session for the purpose of identifying this particular session in logged session information", HFILL }\r\n},\r\n{ &hf_pptp_minimum_bps,\r\n{ "Minimum BPS", "pptp.minimum_bps",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"The lowest acceptable line speed (in bits/second) for this session", HFILL }\r\n},\r\n{ &hf_pptp_maximum_bps,\r\n{ "Maximum BPS", "pptp.maximum_bps",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"The highest acceptable line speed (in bits/second) for this session", HFILL }\r\n},\r\n{ &hf_pptp_framing_type,\r\n{ "Framing Type", "pptp.framing_type",\r\nFT_UINT32, BASE_DEC, VALS(frametype_vals), 0x0,\r\n"A value indicating the type of PPP framing to be used for this outgoing call", HFILL }\r\n},\r\n{ &hf_pptp_bearer_type,\r\n{ "Bearer Type", "pptp.bearer_type",\r\nFT_UINT32, BASE_DEC, VALS(bearertype_vals), 0x0,\r\n"A value indicating the bearer capability required for this outgoing call", HFILL }\r\n},\r\n{ &hf_pptp_packet_receive_window_size,\r\n{ "Packet Receive Window Size", "pptp.packet_receive_window_size",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"A unique identifier, unique to a particular PAC-PNS pair assigned by the PNS", HFILL }\r\n},\r\n{ &hf_pptp_packet_processing_delay,\r\n{ "Packet Processing Delay", "pptp.packet_processing_delay",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"A measure of the packet processing delay that might be imposed on data sent to the PNS from the PAC", HFILL }\r\n},\r\n{ &hf_pptp_phone_number_length,\r\n{ "Phone Number Length", "pptp.phone_number_length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"The actual number of valid digits in the Phone Number field", HFILL }\r\n},\r\n{ &hf_pptp_phone_number,\r\n{ "Phone Number", "pptp.phone_number",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"The number to be dialed to establish the outgoing session", HFILL }\r\n},\r\n{ &hf_pptp_subaddress,\r\n{ "Subaddress", "pptp.subaddress",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"A 64 octet field used to specify additional dialing information.", HFILL }\r\n},\r\n{ &hf_pptp_peer_call_id,\r\n{ "Peer Call ID", "pptp.peer_call_id",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"This field is set to the value received in the Call ID field of the corresponding Outgoing-Call-Request message", HFILL }\r\n},\r\n{ &hf_pptp_out_result,\r\n{ "Result Code", "pptp.out_result",\r\nFT_UINT8, BASE_DEC, VALS(out_resulttype_vals), 0x0,\r\n"Indicates the result of the receipt of the Outgoing-Call-Request attempt", HFILL }\r\n},\r\n{ &hf_pptp_cause,\r\n{ "Cause Code", "pptp.cause",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"This field gives additional information", HFILL }\r\n},\r\n{ &hf_pptp_connect_speed,\r\n{ "Connect Speed", "pptp.connect_speed",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"The actual connection speed used, in bits/second.", HFILL }\r\n},\r\n{ &hf_pptp_physical_channel_id,\r\n{ "Physical Channel ID", "pptp.physical_channel_id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"This field is set by the PAC in a vendor-specific manner to the physical channel number used to place this call", HFILL }\r\n},\r\n{ &hf_pptp_dialed_number_length,\r\n{ "Dialed Number Length", "pptp.dialed_number_length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"The actual number of valid digits in the Dialed Number field", HFILL }\r\n},\r\n{ &hf_pptp_dialed_number,\r\n{ "Dialed Number", "pptp.dialed_number",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"The number that was dialed by the caller", HFILL }\r\n},\r\n{ &hf_pptp_dialing_number_length,\r\n{ "Dialing Number Length", "pptp.dialing_number_length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"The actual number of valid digits in the Dialing Number field", HFILL }\r\n},\r\n{ &hf_pptp_dialing_number,\r\n{ "Dialing Number", "pptp.dialing_number",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"The number from which the call was placed", HFILL }\r\n},\r\n{ &hf_pptp_in_result,\r\n{ "Result Code", "pptp.in_result",\r\nFT_UINT8, BASE_DEC, VALS(in_resulttype_vals), 0x0,\r\n"This value indicates the result of the Incoming-Call-Request attempt", HFILL }\r\n},\r\n{ &hf_pptp_disc_result,\r\n{ "Result Code", "pptp.disc_result",\r\nFT_UINT8, BASE_DEC, VALS(disc_resulttype_vals), 0x0,\r\n"This value indicates the reason for the disconnect", HFILL }\r\n},\r\n{ &hf_pptp_call_statistics,\r\n{ "Call Statistics", "pptp.call_Statistics",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"This field is an ASCII string containing vendor-specific call statistics that can be logged for diagnostic purpose", HFILL }\r\n},\r\n{ &hf_pptp_crc_errors,\r\n{ "CRC Errors", "pptp.crc_errors",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Number of PPP frames received with CRC errors since session was established", HFILL }\r\n},\r\n{ &hf_pptp_framing_errors,\r\n{ "Framing Errors", "pptp.framing_errors",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Number of improperly framed PPP packets received", HFILL }\r\n},\r\n{ &hf_pptp_hardware_overruns,\r\n{ "Hardware overruns", "pptp.hardware_overruns",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Number of receive buffer over-runs since session was established", HFILL }\r\n},\r\n{ &hf_pptp_buffer_overruns,\r\n{ "Buffer overruns", "pptp.buffer_overruns",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Number of buffer over-runs detected since session was established", HFILL }\r\n},\r\n{ &hf_pptp_timeout_errors,\r\n{ "Time-out Errors", "pptp.timeout_errors",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Number of time-outs since call was established", HFILL }\r\n},\r\n{ &hf_pptp_alignment_errors,\r\n{ "Alignment Errors", "pptp.alignment_errors",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Number of Alignment errors since call was established", HFILL }\r\n},\r\n{ &hf_pptp_send_accm,\r\n{ "Send ACCM", "pptp.send_accm",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"The send ACCM value the client should use to process outgoing PPP packets", HFILL }\r\n},\r\n{ &hf_pptp_receive_accm,\r\n{ "Receive ACCM", "pptp.receive_accm",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"The Receive ACCM value the client should use to process incoming PPP packets", HFILL }\r\n},\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_pptp_incorrect_magic_cookie, { "pptp.magic_cookie.incorrect", PI_PROTOCOL, PI_WARN, "Incorrect Magic Cookie", EXPFILL }},\r\n};\r\nexpert_module_t* expert_pptp;\r\nproto_pptp = proto_register_protocol("Point-to-Point Tunnelling Protocol",\r\n"PPTP", "pptp");\r\nproto_register_field_array(proto_pptp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_pptp = expert_register_protocol(proto_pptp);\r\nexpert_register_field_array(expert_pptp, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_pptp(void)\r\n{\r\ndissector_handle_t pptp_handle;\r\npptp_handle = create_dissector_handle(dissect_pptp, proto_pptp);\r\ndissector_add_uint("tcp.port", TCP_PORT_PPTP, pptp_handle);\r\n}
