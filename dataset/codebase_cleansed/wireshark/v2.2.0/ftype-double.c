static void\r\ndouble_fvalue_new(fvalue_t *fv)\r\n{\r\nfv->value.floating = 0.0;\r\n}\r\nstatic void\r\ndouble_fvalue_set_floating(fvalue_t *fv, gdouble value)\r\n{\r\nfv->value.floating = value;\r\n}\r\nstatic double\r\nvalue_get_floating(fvalue_t *fv)\r\n{\r\nreturn fv->value.floating;\r\n}\r\nstatic gboolean\r\nval_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, gchar **err_msg)\r\n{\r\nchar *endptr = NULL;\r\nfv->value.floating = g_ascii_strtod(s, &endptr);\r\nif (endptr == s || *endptr != '\0') {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid number.", s);\r\nreturn FALSE;\r\n}\r\nif (errno == ERANGE) {\r\nif (fv->value.floating == 0) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" causes floating-point underflow.", s);\r\n}\r\nelse if (fv->value.floating == HUGE_VAL) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" causes floating-point overflow.", s);\r\n}\r\nelse {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid floating-point number.",\r\ns);\r\n}\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\nfloat_val_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_, int field_display _U_)\r\n{\r\nreturn DOUBLE_REPR_LENGTH;\r\n}\r\nstatic void\r\nfloat_val_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, int field_display _U_, char *buf, unsigned int size)\r\n{\r\ng_snprintf(buf, size, "%." G_STRINGIFY(FLT_DIG) "g", fv->value.floating);\r\n}\r\nstatic int\r\ndouble_val_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_, int field_display _U_)\r\n{\r\nreturn DOUBLE_REPR_LENGTH;\r\n}\r\nstatic void\r\ndouble_val_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, int field_display _U_, char *buf, unsigned int size)\r\n{\r\ng_snprintf(buf, size, "%." G_STRINGIFY(DBL_DIG) "g", fv->value.floating);\r\n}\r\nstatic gboolean\r\ncmp_eq(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.floating == b->value.floating;\r\n}\r\nstatic gboolean\r\ncmp_ne(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.floating != b->value.floating;\r\n}\r\nstatic gboolean\r\ncmp_gt(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.floating > b->value.floating;\r\n}\r\nstatic gboolean\r\ncmp_ge(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.floating >= b->value.floating;\r\n}\r\nstatic gboolean\r\ncmp_lt(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.floating < b->value.floating;\r\n}\r\nstatic gboolean\r\ncmp_le(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.floating <= b->value.floating;\r\n}\r\nvoid\r\nftype_register_double(void)\r\n{\r\nstatic ftype_t float_type = {\r\nFT_FLOAT,\r\n"FT_FLOAT",\r\n"Floating point (single-precision)",\r\n0,\r\ndouble_fvalue_new,\r\nNULL,\r\nval_from_unparsed,\r\nNULL,\r\nfloat_val_to_repr,\r\nfloat_val_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ndouble_fvalue_set_floating,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nvalue_get_floating,\r\ncmp_eq,\r\ncmp_ne,\r\ncmp_gt,\r\ncmp_ge,\r\ncmp_lt,\r\ncmp_le,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t double_type = {\r\nFT_DOUBLE,\r\n"FT_DOUBLE",\r\n"Floating point (double-precision)",\r\n0,\r\ndouble_fvalue_new,\r\nNULL,\r\nval_from_unparsed,\r\nNULL,\r\ndouble_val_to_repr,\r\ndouble_val_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ndouble_fvalue_set_floating,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nvalue_get_floating,\r\ncmp_eq,\r\ncmp_ne,\r\ncmp_gt,\r\ncmp_ge,\r\ncmp_lt,\r\ncmp_le,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nftype_register(FT_FLOAT, &float_type);\r\nftype_register(FT_DOUBLE, &double_type);\r\n}
