static guint32\r\ndissect_cmd_data_set(guint32 cmd_data_set, proto_tree* tree, tvbuff_t* tvb, guint32 offset, gboolean lreal_pos)\r\n{\r\nguint32 bytes_used = 0;\r\nif ( (cmd_data_set & COMMAND_DATA_SET_POSITION) == COMMAND_DATA_SET_POSITION )\r\n{\r\nif (lreal_pos)\r\n{\r\nproto_tree_add_item(tree, hf_cip_pos_cmd, tvb, offset + bytes_used, 8, ENC_LITTLE_ENDIAN );\r\nbytes_used += 8;\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(tree, hf_cip_pos_cmd_int, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nbytes_used += 4;\r\n}\r\n}\r\nif ( (cmd_data_set & COMMAND_DATA_SET_VELOCITY) == COMMAND_DATA_SET_VELOCITY )\r\n{\r\nproto_tree_add_item(tree, hf_cip_vel_cmd, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nbytes_used += 4;\r\n}\r\nif ( (cmd_data_set & COMMAND_DATA_SET_ACCELERATION) == COMMAND_DATA_SET_ACCELERATION )\r\n{\r\nproto_tree_add_item(tree, hf_cip_accel_cmd, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nbytes_used += 4;\r\n}\r\nif ( (cmd_data_set & COMMAND_DATA_SET_TORQUE) == COMMAND_DATA_SET_TORQUE )\r\n{\r\nproto_tree_add_item(tree, hf_cip_trq_cmd, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nbytes_used += 4;\r\n}\r\nif ( (cmd_data_set & COMMAND_DATA_SET_POSITION_TRIM) == COMMAND_DATA_SET_POSITION_TRIM )\r\n{\r\nproto_tree_add_item(tree, hf_cip_pos_trim, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nbytes_used += 4;\r\n}\r\nif ( (cmd_data_set & COMMAND_DATA_SET_VELOCITY_TRIM) == COMMAND_DATA_SET_VELOCITY_TRIM )\r\n{\r\nproto_tree_add_item(tree, hf_cip_vel_trim, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nbytes_used += 4;\r\n}\r\nif ( (cmd_data_set & COMMAND_DATA_SET_ACCELERATION_TRIM) == COMMAND_DATA_SET_ACCELERATION_TRIM )\r\n{\r\nproto_tree_add_item(tree, hf_cip_accel_trim, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nbytes_used += 4;\r\n}\r\nif ( (cmd_data_set & COMMAND_DATA_SET_TORQUE_TRIM) == COMMAND_DATA_SET_TORQUE_TRIM )\r\n{\r\nproto_tree_add_item(tree, hf_cip_trq_trim, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nbytes_used += 4;\r\n}\r\nreturn bytes_used;\r\n}\r\nstatic guint32\r\ndissect_act_data_set(guint32 act_data_set, proto_tree* tree, tvbuff_t* tvb, guint32 offset)\r\n{\r\nguint32 bytes_used = 0;\r\nif ( (act_data_set & ACTUAL_DATA_SET_POSITION) == ACTUAL_DATA_SET_POSITION )\r\n{\r\nproto_tree_add_item(tree, hf_cip_act_pos, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nbytes_used += 4;\r\n}\r\nif ( (act_data_set & ACTUAL_DATA_SET_VELOCITY) == ACTUAL_DATA_SET_VELOCITY )\r\n{\r\nproto_tree_add_item(tree, hf_cip_act_vel, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nbytes_used += 4;\r\n}\r\nif ( (act_data_set & ACTUAL_DATA_SET_ACCELERATION) == ACTUAL_DATA_SET_ACCELERATION )\r\n{\r\nproto_tree_add_item(tree, hf_cip_act_accel, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nbytes_used += 4;\r\n}\r\nif ( (act_data_set & ACTUAL_DATA_SET_TORQUE) == ACTUAL_DATA_SET_TORQUE )\r\n{\r\nproto_tree_add_item(tree, hf_cip_act_trq, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nbytes_used += 4;\r\n}\r\nif ( (act_data_set & ACTUAL_DATA_SET_CURRENT) == ACTUAL_DATA_SET_CURRENT )\r\n{\r\nproto_tree_add_item(tree, hf_cip_act_crnt, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nbytes_used += 4;\r\n}\r\nif ( (act_data_set & ACTUAL_DATA_SET_VOLTAGE) == ACTUAL_DATA_SET_VOLTAGE )\r\n{\r\nproto_tree_add_item(tree, hf_cip_act_volts, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nbytes_used += 4;\r\n}\r\nif ( (act_data_set & ACTUAL_DATA_SET_FREQUENCY) == ACTUAL_DATA_SET_FREQUENCY )\r\n{\r\nproto_tree_add_item(tree, hf_cip_act_freq, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nbytes_used += 4;\r\n}\r\nreturn bytes_used;\r\n}\r\nstatic guint32\r\ndissect_status_data_set(guint32 status_data_set, proto_tree* tree, tvbuff_t* tvb, guint32 offset)\r\n{\r\nguint32 bytes_used = 0;\r\nproto_item *temp_proto_item;\r\nproto_tree *temp_proto_tree;\r\nif ( (status_data_set & STATUS_DATA_SET_AXIS_FAULT) == STATUS_DATA_SET_AXIS_FAULT )\r\n{\r\nproto_tree_add_item(tree, hf_cip_fault_type, tvb, offset + bytes_used, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += 1;\r\nproto_tree_add_item(tree, hf_cip_axis_fault, tvb, offset + bytes_used, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += 1;\r\nproto_tree_add_item(tree, hf_cip_fault_sub_code, tvb, offset + bytes_used, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += 1;\r\nproto_tree_add_item(tree, hf_cip_fault_action, tvb, offset + bytes_used, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += 1;\r\nproto_tree_add_item(tree, hf_cip_fault_time_stamp, tvb, offset + bytes_used, 8, ENC_LITTLE_ENDIAN);\r\nbytes_used += 8;\r\n}\r\nif ( (status_data_set & STATUS_DATA_SET_AXIS_ALARM) == STATUS_DATA_SET_AXIS_ALARM )\r\n{\r\nproto_tree_add_item(tree, hf_cip_alarm_type, tvb, offset + bytes_used, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += 1;\r\nproto_tree_add_item(tree, hf_cip_axis_alarm, tvb, offset + bytes_used, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += 1;\r\nproto_tree_add_item(tree, hf_cip_alarm_sub_code, tvb, offset + bytes_used, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += 1;\r\nproto_tree_add_item(tree, hf_cip_alarm_state, tvb, offset + bytes_used, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += 1;\r\nproto_tree_add_item(tree, hf_cip_alarm_time_stamp, tvb, offset + bytes_used, 8, ENC_LITTLE_ENDIAN);\r\nbytes_used += 8;\r\n}\r\nif ( (status_data_set & STATUS_DATA_SET_AXIS_STATUS) == STATUS_DATA_SET_AXIS_STATUS )\r\n{\r\ntemp_proto_item = proto_tree_add_item(tree, hf_cip_axis_status, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN);\r\ntemp_proto_tree = proto_item_add_subtree( temp_proto_item, ett_axis_status_set );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_local_ctrl, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_alarm, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_dc_bus, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_pwr_struct, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_tracking, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_pos_lock, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_vel_lock, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_vel_standstill, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_vel_threshold, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_vel_limit, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_acc_limit, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_dec_limit, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_torque_threshold, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_torque_limit, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_cur_limit, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_therm_limit, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_feedback_integ, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_shutdown, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nproto_tree_add_item( temp_proto_tree, hf_cip_axis_sts_in_process, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN );\r\nbytes_used += 4;\r\nproto_tree_add_item(tree, hf_cip_axis_status_mfg, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN);\r\nbytes_used += 4;\r\n}\r\nif ( (status_data_set & STATUS_DATA_SET_AXIS_IO_STATUS) == STATUS_DATA_SET_AXIS_IO_STATUS )\r\n{\r\nproto_tree_add_item(tree, hf_cip_axis_io_status, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN);\r\nbytes_used += 4;\r\nproto_tree_add_item(tree, hf_cip_axis_io_status_mfg, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN);\r\nbytes_used += 4;\r\n}\r\nif ( (status_data_set & STATUS_DATA_SET_AXIS_SAFETY) == STATUS_DATA_SET_AXIS_SAFETY )\r\n{\r\nproto_tree_add_item(tree, hf_cip_axis_safety_status, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN);\r\nbytes_used += 4;\r\nproto_tree_add_item(tree, hf_cip_axis_safety_status_mfg, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN);\r\nbytes_used += 4;\r\nproto_tree_add_item(tree, hf_cip_axis_safety_state, tvb, offset + bytes_used, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += 4;\r\n}\r\nif ( (status_data_set & STATUS_DATA_SET_DRIVE_SAFETY) == STATUS_DATA_SET_DRIVE_SAFETY )\r\n{\r\nproto_tree_add_item(tree, hf_cip_drive_safety_status, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN);\r\nbytes_used += 4;\r\n}\r\nreturn bytes_used;\r\n}\r\nstatic guint32\r\ndissect_cntr_cyclic(guint32 con_format _U_, tvbuff_t* tvb, proto_tree* tree, guint32 offset, guint32 size, guint32 instance _U_)\r\n{\r\nproto_item *temp_proto_item;\r\nproto_tree *header_tree, *temp_proto_tree;\r\nguint32 temp_data;\r\ngboolean lreal_pos;\r\nguint32 bytes_used = 0;\r\nheader_tree = proto_tree_add_subtree(tree, tvb, offset, size, ett_cyclic_data_block, NULL, "Cyclic Data Block");\r\nproto_tree_add_item(header_tree, hf_cip_motor_cntrl, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_fdbk_config, tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_axis_control, tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_control_status, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);\r\ntemp_data = tvb_get_guint8(tvb, offset + 7);\r\nlreal_pos = ( (temp_data & COMMAND_CONTROL_POSITION_DATA_TYPE) == POSITION_DATA_LREAL );\r\ntemp_data = tvb_get_guint8(tvb, offset + 4);\r\ntemp_proto_item = proto_tree_add_item(header_tree, hf_cip_cmd_data_set, tvb, offset + 4, 1, ENC_LITTLE_ENDIAN);\r\ntemp_proto_tree = proto_item_add_subtree(temp_proto_item, ett_command_data_set);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_cmd_data_pos_cmd, tvb, offset + 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_cmd_data_vel_cmd, tvb, offset + 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_cmd_data_acc_cmd, tvb, offset + 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_cmd_data_trq_cmd, tvb, offset + 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_cmd_data_pos_trim_cmd, tvb, offset + 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_cmd_data_vel_trim_cmd, tvb, offset + 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_cmd_data_acc_trim_cmd, tvb, offset + 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_cmd_data_trq_trim_cmd, tvb, offset + 4, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += dissect_cmd_data_set(temp_data, temp_proto_tree, tvb, offset + 8 + bytes_used, lreal_pos);\r\ntemp_proto_item = proto_tree_add_item(header_tree, hf_cip_act_data_set, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\ntemp_proto_tree = proto_item_add_subtree(temp_proto_item, ett_actual_data_set);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_act_data_pos, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_act_data_vel, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_act_data_acc, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_act_data_trq, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_act_data_crnt, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_act_data_vltg, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_act_data_fqcy, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\ntemp_proto_item = proto_tree_add_item(header_tree, hf_cip_sts_data_set, tvb, offset + 6, 1, ENC_LITTLE_ENDIAN);\r\ntemp_proto_tree = proto_item_add_subtree(temp_proto_item, ett_status_data_set);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_sts_flt, tvb, offset + 6, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_sts_alrm, tvb, offset + 6, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_sts_sts, tvb, offset + 6, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_sts_iosts, tvb, offset + 6, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_sts_axis_safety, tvb, offset + 6, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_sts_drive_safety, tvb, offset + 6, 1, ENC_LITTLE_ENDIAN);\r\ntemp_proto_item = proto_tree_add_item(header_tree, hf_cip_command_control, tvb, offset + 7, 1, ENC_LITTLE_ENDIAN);\r\ntemp_proto_tree = proto_item_add_subtree(temp_proto_item, ett_command_control);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_intrp, tvb, offset + 7, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_position_data_type, tvb, offset + 7, 1, ENC_LITTLE_ENDIAN);\r\nreturn offset + 8 + bytes_used;\r\n}\r\nstatic guint32\r\ndissect_devce_cyclic(guint32 con_format _U_, tvbuff_t* tvb, proto_tree* tree, guint32 offset, guint32 size, guint32 instance _U_)\r\n{\r\nproto_item *temp_proto_item;\r\nproto_tree *header_tree, *temp_proto_tree;\r\nguint32 temp_data;\r\nguint32 bytes_used = 0;\r\nheader_tree = proto_tree_add_subtree(tree, tvb, offset, size, ett_cyclic_data_block, NULL, "Cyclic Data Block");\r\nproto_tree_add_item(header_tree, hf_cip_motor_cntrl, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_fdbk_config, tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_axis_response, tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_axis_resp_stat, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);\r\ntemp_data = tvb_get_guint8(tvb, offset + 5);\r\ntemp_proto_item = proto_tree_add_item(header_tree, hf_cip_act_data_set, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\ntemp_proto_tree = proto_item_add_subtree(temp_proto_item, ett_actual_data_set);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_act_data_pos, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_act_data_vel, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_act_data_acc, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_act_data_trq, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_act_data_crnt, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_act_data_vltg, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_act_data_fqcy, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += dissect_act_data_set(temp_data, temp_proto_tree, tvb, offset + 8 + bytes_used);\r\ntemp_data = tvb_get_guint8(tvb, offset + 6);\r\ntemp_proto_item = proto_tree_add_item(header_tree, hf_cip_sts_data_set, tvb, offset + 6, 1, ENC_LITTLE_ENDIAN);\r\ntemp_proto_tree = proto_item_add_subtree(temp_proto_item, ett_status_data_set);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_sts_flt, tvb, offset + 6, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_sts_alrm, tvb, offset + 6, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_sts_sts, tvb, offset + 6, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_sts_iosts, tvb, offset + 6, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_sts_axis_safety, tvb, offset + 6, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_sts_drive_safety, tvb, offset + 6, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += dissect_status_data_set(temp_data, temp_proto_tree, tvb, offset + 8 + bytes_used);\r\nproto_tree_add_item(header_tree, hf_cip_axis_state, tvb, offset + 7, 1, ENC_LITTLE_ENDIAN);\r\nreturn offset + 8 + bytes_used;\r\n}\r\nstatic guint32\r\ndissect_cyclic_wt(tvbuff_t* tvb, proto_tree* tree, guint32 offset, guint32 size)\r\n{\r\nproto_tree *header_tree;\r\nheader_tree = proto_tree_add_subtree(tree, tvb, offset, size, ett_cyclic_rd_wt, NULL, "Cyclic Write Data Block");\r\nproto_tree_add_item(header_tree, hf_cip_cyclic_write_blk, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_cyclic_read_blk, tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);\r\nif ( (size - 4) > 0 )\r\n{\r\nproto_tree_add_item(header_tree, hf_cip_cyclic_wrt_data, tvb, offset + 4, size - 4, ENC_NA);\r\n}\r\nreturn offset + size;\r\n}\r\nstatic guint32\r\ndissect_cyclic_rd(tvbuff_t* tvb, proto_tree* tree, guint32 offset, guint32 size)\r\n{\r\nproto_tree *header_tree;\r\nheader_tree = proto_tree_add_subtree(tree, tvb, offset, size, ett_cyclic_rd_wt, NULL, "Cyclic Read Data Block");\r\nproto_tree_add_item(header_tree, hf_cip_cyclic_write_blk, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_cyclic_write_sts, tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_cyclic_read_blk, tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_cyclic_read_sts, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);\r\nif ( (size - 4) > 0 )\r\n{\r\nproto_tree_add_item(header_tree, hf_cip_cyclic_rd_data, tvb, offset + 4, size - 4, ENC_NA);\r\n}\r\nreturn offset + size;\r\n}\r\nstatic guint32\r\ndissect_cntr_event(tvbuff_t* tvb, proto_tree* tree, guint32 offset, guint32 size)\r\n{\r\nproto_item *temp_proto_item;\r\nproto_tree *header_tree, *temp_proto_tree;\r\nguint32 temp_data;\r\nguint32 acks, cur_ack;\r\nguint32 bytes_used = 0;\r\nheader_tree = proto_tree_add_subtree(tree, tvb, offset, size, ett_event, NULL, "Event Data Block");\r\ntemp_data = tvb_get_letohl(tvb, offset);\r\ntemp_proto_item = proto_tree_add_item(header_tree, hf_cip_event_checking, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\ntemp_proto_tree = proto_item_add_subtree(temp_proto_item, ett_event_check_ctrl);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_reg1_pos, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_reg1_neg, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_reg2_pos, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_reg2_neg, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_reg1_posrearm, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_reg1_negrearm, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_reg2_posrearm, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_reg2_negrearm, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_marker_pos, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_marker_neg, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_home_pos, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_home_neg, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_home_pp, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_home_pm, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_home_mp, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_home_mm, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_ctrl_acks, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_extend_format, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nbytes_used = 4;\r\nacks = (temp_data >> 28) & 0x0F;\r\nfor (cur_ack = 0; cur_ack < acks; cur_ack++)\r\n{\r\nproto_tree_add_item(header_tree, hf_cip_event_ack, tvb, offset + bytes_used, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += 1;\r\nproto_tree_add_item(header_tree, hf_cip_evnt_sts_stat, tvb, offset + bytes_used, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += 1;\r\n}\r\nreturn offset + size;\r\n}\r\nstatic guint32\r\ndissect_devce_event(tvbuff_t* tvb, proto_tree* tree, guint32 offset, guint32 size)\r\n{\r\nproto_item *temp_proto_item;\r\nproto_tree *header_tree, *temp_proto_tree;\r\nguint64 temp_data;\r\nguint64 nots, cur_not;\r\nguint32 bytes_used = 0;\r\nheader_tree = proto_tree_add_subtree(tree, tvb, offset, size, ett_event, NULL, "Event Data Block");\r\ntemp_data = tvb_get_letohl(tvb, offset);\r\ntemp_proto_item = proto_tree_add_item(header_tree, hf_cip_event_status, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\ntemp_proto_tree = proto_item_add_subtree(temp_proto_item, ett_event_check_sts);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_reg1_pos, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_reg1_neg, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_reg2_pos, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_reg2_neg, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_reg1_posrearm, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_reg1_negrearm, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_reg2_posrearm, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_reg2_negrearm, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_marker_pos, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_marker_neg, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_home_pos, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_home_neg, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_home_pp, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_home_pm, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_home_mp, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_home_mm, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_sts_nfs, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_evnt_extend_format, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nbytes_used = 4;\r\nnots = (temp_data >> 28) & 0x0F;\r\nfor (cur_not = 0; cur_not < nots; cur_not++)\r\n{\r\nproto_tree_add_item(header_tree, hf_cip_event_id, tvb, offset + bytes_used, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += 1;\r\nproto_tree_add_item(header_tree, hf_cip_evnt_sts_stat, tvb, offset + bytes_used, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += 1;\r\nproto_tree_add_item(header_tree, hf_cip_evnt_type, tvb, offset + bytes_used, 1, ENC_LITTLE_ENDIAN);\r\nbytes_used += 2;\r\nproto_tree_add_item(header_tree, hf_cip_event_pos, tvb, offset + bytes_used, 4, ENC_LITTLE_ENDIAN);\r\nbytes_used += 4;\r\nproto_tree_add_item(header_tree, hf_cip_event_ts, tvb, offset + bytes_used, 8, ENC_LITTLE_ENDIAN);\r\nbytes_used += 8;\r\n}\r\nreturn size + offset;\r\n}\r\nstatic void\r\ndissect_get_axis_attr_list_request (tvbuff_t* tvb, proto_tree* tree, guint32 offset, guint32 size)\r\n{\r\nproto_item *attr_item;\r\nproto_tree *header_tree, *attr_tree;\r\nguint16 attribute, attribute_cnt;\r\nguint32 local_offset;\r\nguint8 increment_size, dimension;\r\nheader_tree = proto_tree_add_subtree(tree, tvb, offset, size, ett_get_axis_attribute, NULL, "Get Axis Attribute List Request");\r\nattribute_cnt = tvb_get_letohs(tvb, offset);\r\nproto_tree_add_item(header_tree, hf_get_axis_attr_list_attribute_cnt, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nlocal_offset = offset + 4;\r\nfor (attribute = 0; attribute < attribute_cnt; attribute++)\r\n{\r\nincrement_size = 4;\r\ndimension = tvb_get_guint8(tvb, local_offset + 2);\r\nattr_item = proto_tree_add_item(header_tree, hf_get_axis_attr_list_attribute_id, tvb, local_offset, 2, ENC_LITTLE_ENDIAN);\r\nattr_tree = proto_item_add_subtree(attr_item, ett_get_axis_attr_list);\r\nproto_tree_add_item(attr_tree, hf_get_axis_attr_list_dimension, tvb, local_offset + 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(attr_tree, hf_get_axis_attr_list_element_size, tvb, local_offset + 3, 1, ENC_LITTLE_ENDIAN);\r\nif (dimension == 1)\r\n{\r\nproto_tree_add_item(attr_tree, hf_get_axis_attr_list_start_index, tvb, local_offset + 4, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(attr_tree, hf_get_axis_attr_list_data_elements, tvb, local_offset + 6, 2, ENC_LITTLE_ENDIAN);\r\nincrement_size += 4;\r\n}\r\nlocal_offset += increment_size;\r\n}\r\n}\r\nstatic void\r\ndissect_set_axis_attr_list_request (tvbuff_t* tvb, proto_tree* tree, guint32 offset, guint32 size)\r\n{\r\nproto_item *attr_item;\r\nproto_tree *header_tree, *attr_tree;\r\nguint16 attribute, attribute_cnt, data_elements;\r\nguint32 local_offset;\r\nguint32 attribute_size;\r\nguint8 dimension, attribute_start, increment_size;\r\nheader_tree = proto_tree_add_subtree(tree, tvb, offset, size, ett_set_axis_attribute, NULL, "Set Axis Attribute List Request");\r\nattribute_cnt = tvb_get_letohs(tvb, offset);\r\nproto_tree_add_item(header_tree, hf_set_axis_attr_list_attribute_cnt, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nlocal_offset = offset + 4;\r\nfor (attribute = 0; attribute < attribute_cnt; attribute++)\r\n{\r\nincrement_size = 4;\r\ndimension = tvb_get_guint8(tvb, local_offset + 2);\r\nattribute_size = tvb_get_guint8(tvb, local_offset + 3);\r\nattribute_start = 4;\r\nif (dimension == 1)\r\n{\r\ndata_elements = tvb_get_letohs(tvb, local_offset + 6);\r\nattribute_size *= data_elements;\r\nincrement_size += 4;\r\nattribute_start += 4;\r\n}\r\nattr_item = proto_tree_add_item(header_tree, hf_set_axis_attr_list_attribute_id, tvb, local_offset, 2, ENC_LITTLE_ENDIAN);\r\nattr_tree = proto_item_add_subtree(attr_item, ett_set_axis_attr_list);\r\nproto_tree_add_item(attr_tree, hf_set_axis_attr_list_dimension, tvb, local_offset + 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(attr_tree, hf_set_axis_attr_list_element_size, tvb, local_offset + 3, 1, ENC_LITTLE_ENDIAN);\r\nif (dimension == 1)\r\n{\r\nproto_tree_add_item(attr_tree, hf_set_axis_attr_list_start_index, tvb, local_offset + 4, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(attr_tree, hf_set_axis_attr_list_data_elements, tvb, local_offset + 6, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nproto_tree_add_item(attr_tree, hf_cip_attribute_data, tvb, local_offset + attribute_start, attribute_size, ENC_NA);\r\nif (attribute_size % 4 != 0)\r\n{\r\nattribute_size = attribute_size + (4 - (attribute_size % 4));\r\n}\r\nlocal_offset += (attribute_size + increment_size);\r\n}\r\n}\r\nstatic void\r\ndissect_group_sync_request (tvbuff_t* tvb, proto_tree* tree, guint32 offset, guint32 size)\r\n{\r\nproto_tree *header_tree;\r\nheader_tree = proto_tree_add_subtree(tree, tvb, offset, size, ett_group_sync, NULL, "Group Sync Request");\r\nproto_tree_add_item(header_tree, hf_cip_ptp_grandmaster, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic guint32\r\ndissect_cntr_service(tvbuff_t* tvb, proto_tree* tree, guint32 offset, guint32 size)\r\n{\r\nproto_tree *header_tree;\r\nguint8 service;\r\nheader_tree = proto_tree_add_subtree(tree, tvb, offset, size, ett_service, NULL, "Service Data Block");\r\nproto_tree_add_item(header_tree, hf_cip_svc_transction, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nservice = tvb_get_guint8(tvb, offset + 1);\r\nproto_tree_add_item(header_tree, hf_cip_svc_code, tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\r\nswitch(service)\r\n{\r\ncase SC_GET_AXIS_ATTRIBUTE_LIST:\r\ndissect_get_axis_attr_list_request(tvb, header_tree, offset + 4, size);\r\nbreak;\r\ncase SC_SET_AXIS_ATTRIBUTE_LIST:\r\ndissect_set_axis_attr_list_request(tvb, header_tree, offset + 4, size);\r\nbreak;\r\ncase SC_GROUP_SYNC:\r\ndissect_group_sync_request(tvb, header_tree, offset + 4, size);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(header_tree, hf_cip_svc_data, tvb, offset + 4, size - 4, ENC_NA);\r\n}\r\nreturn offset + size;\r\n}\r\nstatic void\r\ndissect_set_axis_attr_list_response (tvbuff_t* tvb, proto_tree* tree, guint32 offset, guint32 size)\r\n{\r\nproto_item *attr_item;\r\nproto_tree *header_tree, *attr_tree;\r\nguint16 attribute, attribute_cnt;\r\nguint32 local_offset;\r\nheader_tree = proto_tree_add_subtree(tree, tvb, offset, size, ett_get_axis_attribute, NULL, "Set Axis Attribute List Response");\r\nattribute_cnt = tvb_get_letohs(tvb, offset);\r\nproto_tree_add_item(header_tree, hf_set_axis_attr_list_attribute_cnt, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nlocal_offset = offset + 4;\r\nfor (attribute = 0; attribute < attribute_cnt; attribute++)\r\n{\r\nattr_item = proto_tree_add_item(header_tree, hf_set_axis_attr_list_attribute_id, tvb, local_offset, 2, ENC_LITTLE_ENDIAN);\r\nattr_tree = proto_item_add_subtree(attr_item, ett_get_axis_attr_list);\r\nproto_tree_add_item(attr_tree, hf_cip_svc_set_axis_attr_sts, tvb, local_offset + 2, 1, ENC_LITTLE_ENDIAN);\r\nlocal_offset += 4;\r\n}\r\n}\r\nstatic void\r\ndissect_get_axis_attr_list_response (tvbuff_t* tvb, proto_tree* tree, guint32 offset, guint32 size)\r\n{\r\nproto_item *attr_item;\r\nproto_tree *header_tree, *attr_tree;\r\nguint16 attribute, attribute_cnt, data_elements;\r\nguint32 attribute_size;\r\nguint8 dimension, attribute_start, increment_size;\r\nguint32 local_offset;\r\nheader_tree = proto_tree_add_subtree(tree, tvb, offset, size, ett_get_axis_attribute, NULL, "Get Axis Attribute List Response");\r\nattribute_cnt = tvb_get_letohs(tvb, offset);\r\nproto_tree_add_item(header_tree, hf_get_axis_attr_list_attribute_cnt, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nlocal_offset = offset + 4;\r\nfor (attribute = 0; attribute < attribute_cnt; attribute++)\r\n{\r\nincrement_size = 4;\r\ndimension = tvb_get_guint8(tvb, local_offset + 2);\r\nattribute_size = tvb_get_guint8(tvb, local_offset + 3);\r\nattribute_start = 4;\r\nif (dimension == 1)\r\n{\r\ndata_elements = tvb_get_letohs(tvb, local_offset + 6);\r\nattribute_size *= data_elements;\r\nincrement_size += 4;\r\nattribute_start += 4;\r\n}\r\nattr_item = proto_tree_add_item(header_tree, hf_get_axis_attr_list_attribute_id, tvb, local_offset, 2, ENC_LITTLE_ENDIAN);\r\nattr_tree = proto_item_add_subtree(attr_item, ett_get_axis_attr_list);\r\nif (dimension == 0xFF)\r\n{\r\nproto_tree_add_item(attr_tree, hf_cip_svc_get_axis_attr_sts, tvb, local_offset + 3, 1, ENC_LITTLE_ENDIAN);\r\nattribute_size = 0;\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(attr_tree, hf_get_axis_attr_list_dimension, tvb, local_offset + 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(attr_tree, hf_get_axis_attr_list_element_size, tvb, local_offset + 3, 1, ENC_LITTLE_ENDIAN);\r\nif (dimension == 1)\r\n{\r\nproto_tree_add_item(attr_tree, hf_get_axis_attr_list_start_index, tvb, local_offset + 4, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(attr_tree, hf_get_axis_attr_list_data_elements, tvb, local_offset + 6, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nproto_tree_add_item(attr_tree, hf_cip_attribute_data, tvb, offset + attribute_start, attribute_size, ENC_NA);\r\nif (attribute_size % 4 != 0)\r\n{\r\nattribute_size = attribute_size + (4 - (attribute_size % 4));\r\n}\r\n}\r\nlocal_offset += (attribute_size + increment_size);\r\n}\r\n}\r\nstatic void\r\ndissect_group_sync_response (tvbuff_t* tvb, proto_tree* tree, guint32 offset, guint32 size _U_)\r\n{\r\nproto_tree_add_item(tree, hf_cip_group_sync, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic guint32\r\ndissect_devce_service(tvbuff_t* tvb, proto_tree* tree, guint32 offset, guint32 size)\r\n{\r\nproto_tree *header_tree;\r\nheader_tree = proto_tree_add_subtree(tree, tvb, offset, size, ett_service, NULL, "Service Data Block");\r\nproto_tree_add_item(header_tree, hf_cip_svc_transction, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_svc_code, tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_svc_sts, tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_svc_ext_status, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);\r\nswitch(tvb_get_guint8(tvb, offset + 1))\r\n{\r\ncase SC_GET_AXIS_ATTRIBUTE_LIST:\r\ndissect_get_axis_attr_list_response(tvb, header_tree, offset + 4, size);\r\nbreak;\r\ncase SC_SET_AXIS_ATTRIBUTE_LIST:\r\ndissect_set_axis_attr_list_response(tvb, header_tree, offset + 4, size);\r\nbreak;\r\ncase SC_GROUP_SYNC:\r\ndissect_group_sync_response(tvb, header_tree, offset + 4, size);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(header_tree, hf_cip_svc_data, tvb, offset + 4, size - 4, ENC_NA);\r\n}\r\nreturn offset + size;\r\n}\r\nstatic void\r\ndissect_var_inst_header(tvbuff_t* tvb, proto_tree* tree, guint32 offset, guint8* inst_number, guint32* cyc_size,\r\nguint32* cyc_blk_size, guint32* evnt_size, guint32* servc_size)\r\n{\r\nguint8 temp_data;\r\nproto_tree *header_tree;\r\n*inst_number = tvb_get_guint8(tvb, offset);\r\nheader_tree = proto_tree_add_subtree_format(tree, tvb, offset, 8, ett_inst_data_header, NULL,\r\n"Instance Data Header - Instance: %d", *inst_number);\r\nproto_tree_add_item(header_tree, hf_var_devce_instance, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\ntemp_data = tvb_get_guint8(tvb, offset + 2);\r\nproto_tree_add_uint_format_value(header_tree, hf_var_devce_instance_block_size,\r\ntvb, offset + 2, 1, temp_data, "%d words", temp_data);\r\ntemp_data = tvb_get_guint8(tvb, offset + 3);\r\nproto_tree_add_uint_format_value(header_tree, hf_var_devce_cyclic_block_size,\r\ntvb, offset + 3, 1, temp_data, "%d words", temp_data);\r\n*cyc_size = (tvb_get_guint8(tvb, offset + 4) * 4);\r\nproto_tree_add_uint_format_value(header_tree, hf_var_devce_cyclic_data_block_size,\r\ntvb, offset + 4, 1, (*cyc_size)/4, "%d words", (*cyc_size)/4);\r\n*cyc_blk_size = (tvb_get_guint8(tvb, offset + 5) * 4);\r\nproto_tree_add_uint_format_value(header_tree, hf_var_devce_cyclic_rw_block_size,\r\ntvb, offset + 5, 1, (*cyc_blk_size)/4, "%d words", (*cyc_blk_size)/4);\r\n*evnt_size = (tvb_get_guint8(tvb, offset + 6) * 4);\r\nproto_tree_add_uint_format_value(header_tree, hf_var_devce_event_block_size,\r\ntvb, offset + 6, 1, (*evnt_size)/4, "%d words", (*evnt_size)/4);\r\n*servc_size = (tvb_get_guint8(tvb, offset + 7) * 4);\r\nproto_tree_add_uint_format_value(header_tree, hf_var_devce_service_block_size,\r\ntvb, offset + 7, 1, (*servc_size)/4, "%d words", (*servc_size)/4);\r\n}\r\nstatic guint32\r\ndissect_var_cont_conn_header(tvbuff_t* tvb, proto_tree* tree, guint32* inst_count, guint32 offset)\r\n{\r\nguint32 header_size;\r\nguint32 temp_data;\r\nproto_item *temp_proto_item;\r\nproto_tree *header_tree, *temp_proto_tree;\r\nheader_size = 8;\r\ntemp_data = tvb_get_guint8(tvb, offset + 7);\r\nif ( (temp_data & TIME_DATA_SET_TIME_STAMP) == TIME_DATA_SET_TIME_STAMP )\r\n{\r\nheader_size += 8;\r\n}\r\nif ( (temp_data & TIME_DATA_SET_TIME_OFFSET) == TIME_DATA_SET_TIME_OFFSET )\r\n{\r\nheader_size += 8;\r\n}\r\nheader_tree = proto_tree_add_subtree(tree, tvb, offset, header_size, ett_cont_dev_header, NULL, "Connection Header");\r\nproto_tree_add_item(header_tree, hf_cip_format, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_revision, tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_updateid, tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);\r\ntemp_proto_item = proto_tree_add_item(header_tree, hf_cip_node_control, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);\r\ntemp_proto_tree = proto_item_add_subtree(temp_proto_item, ett_node_control);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_node_control_remote, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_node_control_sync, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_node_data_valid, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_node_fault_reset, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);\r\n*inst_count = tvb_get_guint8(tvb, offset + 4);\r\nproto_tree_add_item(header_tree, hf_cip_instance_cnt, tvb, offset + 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_last_update, tvb, offset + 6, 1, ENC_LITTLE_ENDIAN);\r\ntemp_data = tvb_get_guint8(tvb, offset + 7);\r\ntemp_proto_item = proto_tree_add_item(header_tree, hf_cip_time_data_set, tvb, offset + 7, 1, ENC_LITTLE_ENDIAN);\r\ntemp_proto_tree = proto_item_add_subtree(temp_proto_item, ett_time_data_set);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_time_data_stamp, tvb, offset + 7, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_time_data_offset, tvb, offset + 7, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_time_data_diag, tvb, offset + 7, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_time_data_time_diag, tvb, offset + 7, 1, ENC_LITTLE_ENDIAN);\r\noffset = (offset + 7 + 1);\r\nif ( (temp_data & TIME_DATA_SET_TIME_STAMP) == TIME_DATA_SET_TIME_STAMP )\r\n{\r\nproto_tree_add_item(header_tree, hf_cip_cont_time_stamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset = (offset + 8);\r\n}\r\nif ( (temp_data & TIME_DATA_SET_TIME_OFFSET) == TIME_DATA_SET_TIME_OFFSET )\r\n{\r\nproto_tree_add_item(header_tree, hf_cip_cont_time_offset, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset = (offset + 8);\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_var_devce_conn_header(tvbuff_t* tvb, proto_tree* tree, guint32* inst_count, guint32 offset)\r\n{\r\nguint32 header_size;\r\nguint32 temp_data;\r\nproto_item *temp_proto_item;\r\nproto_tree *header_tree, *temp_proto_tree;\r\nheader_size = 8;\r\ntemp_data = tvb_get_guint8(tvb, offset + 7);\r\nif ( (temp_data & TIME_DATA_SET_TIME_STAMP) == TIME_DATA_SET_TIME_STAMP )\r\n{\r\nheader_size += 8;\r\n}\r\nif ( (temp_data & TIME_DATA_SET_TIME_OFFSET) == TIME_DATA_SET_TIME_OFFSET )\r\n{\r\nheader_size += 8;\r\n}\r\nif ( (temp_data & TIME_DATA_SET_UPDATE_DIAGNOSTICS) == TIME_DATA_SET_UPDATE_DIAGNOSTICS )\r\n{\r\nheader_size += 4;\r\n}\r\nif ( (temp_data & TIME_DATA_SET_TIME_DIAGNOSTICS) == TIME_DATA_SET_TIME_DIAGNOSTICS )\r\n{\r\nheader_size += 16;\r\n}\r\nheader_tree = proto_tree_add_subtree(tree, tvb, offset, header_size, ett_cont_dev_header, NULL, "Connection Header");\r\nproto_tree_add_item(header_tree, hf_cip_format, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_revision, tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_updateid, tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);\r\ntemp_proto_item = proto_tree_add_item(header_tree, hf_cip_node_status, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);\r\ntemp_proto_tree = proto_item_add_subtree(temp_proto_item, ett_node_status);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_node_control_remote, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_node_control_sync, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_node_data_valid, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_node_device_faulted, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);\r\n*inst_count = tvb_get_guint8(tvb, offset + 4);\r\nproto_tree_add_item(header_tree, hf_cip_instance_cnt, tvb, offset + 4, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_node_fltalarms, tvb, offset + 5, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(header_tree, hf_cip_last_update, tvb, offset + 6, 1, ENC_LITTLE_ENDIAN);\r\ntemp_data = tvb_get_guint8(tvb, offset + 7);\r\ntemp_proto_item = proto_tree_add_item(header_tree, hf_cip_time_data_set, tvb, offset + 7, 1, ENC_LITTLE_ENDIAN);\r\ntemp_proto_tree = proto_item_add_subtree(temp_proto_item, ett_time_data_set);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_time_data_stamp, tvb, offset + 7, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_time_data_offset, tvb, offset + 7, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_time_data_diag, tvb, offset + 7, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(temp_proto_tree, hf_cip_time_data_time_diag, tvb, offset + 7, 1, ENC_LITTLE_ENDIAN);\r\noffset = (offset + 7 + 1);\r\nif ( (temp_data & TIME_DATA_SET_TIME_STAMP) == TIME_DATA_SET_TIME_STAMP )\r\n{\r\nproto_tree_add_item(header_tree, hf_cip_devc_time_stamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset = (offset + 8);\r\n}\r\nif ( (temp_data & TIME_DATA_SET_TIME_OFFSET) == TIME_DATA_SET_TIME_OFFSET )\r\n{\r\nproto_tree_add_item(header_tree, hf_cip_devc_time_offset, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset = (offset + 8);\r\n}\r\nif ( (temp_data & TIME_DATA_SET_UPDATE_DIAGNOSTICS) == TIME_DATA_SET_UPDATE_DIAGNOSTICS )\r\n{\r\nproto_tree_add_item(header_tree, hf_cip_lost_update, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset = (offset + 1);\r\nproto_tree_add_item(header_tree, hf_cip_late_update, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset = (offset + 3);\r\n}\r\nif ( (temp_data & TIME_DATA_SET_TIME_DIAGNOSTICS) == TIME_DATA_SET_TIME_DIAGNOSTICS )\r\n{\r\nproto_tree_add_item(header_tree, hf_cip_data_rx_time_stamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\nproto_tree_add_item(header_tree, hf_cip_data_tx_time_stamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_cipmotion(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree, void* data _U_)\r\n{\r\nguint32 con_format;\r\nguint32 update_id;\r\nproto_item *proto_item_top;\r\nproto_tree *proto_tree_top;\r\nguint32 offset = 0;\r\noffset = (offset + 2);\r\ncon_format = tvb_get_guint8(tvb, offset);\r\nupdate_id = tvb_get_guint8(tvb, offset + 2);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Motion");\r\ncol_add_fstr( pinfo->cinfo, COL_INFO, "%s, Update Id: %d",\r\nval_to_str(con_format, cip_con_format_vals, "Unknown connection format (%x)"), update_id );\r\nif ( tree )\r\n{\r\nproto_item_top = proto_tree_add_item( tree, proto_cipmotion, tvb, 0, -1, ENC_NA );\r\nproto_tree_top = proto_item_add_subtree( proto_item_top, ett_cipmotion );\r\nproto_tree_add_item( proto_tree_top, hf_cip_class1_seqnum, tvb, 0, 2, ENC_LITTLE_ENDIAN );\r\nif (( con_format == FORMAT_VAR_CONTROL_TO_DEVICE ) ||\r\n( con_format == FORMAT_VAR_DEVICE_TO_CONTROL ))\r\n{\r\nguint32 cyc_size, cyc_blk_size, evnt_size, servc_size;\r\nguint32 inst_count = 0, inst;\r\nswitch(con_format)\r\n{\r\ncase FORMAT_VAR_CONTROL_TO_DEVICE:\r\noffset = dissect_var_cont_conn_header(tvb, proto_tree_top, &inst_count, offset);\r\nbreak;\r\ncase FORMAT_VAR_DEVICE_TO_CONTROL:\r\noffset = dissect_var_devce_conn_header(tvb, proto_tree_top, &inst_count, offset);\r\nbreak;\r\n}\r\nfor( inst = 0; inst < inst_count; inst++ )\r\n{\r\nguint8 instance;\r\ndissect_var_inst_header( tvb, proto_tree_top, offset, &instance,\r\n&cyc_size, &cyc_blk_size, &evnt_size, &servc_size );\r\noffset += 8;\r\nswitch(con_format)\r\n{\r\ncase FORMAT_VAR_CONTROL_TO_DEVICE:\r\nif ( cyc_size > 0 )\r\noffset = dissect_cntr_cyclic( con_format, tvb, proto_tree_top, offset, cyc_size, instance );\r\nif ( cyc_blk_size > 0 )\r\noffset = dissect_cyclic_wt(tvb, proto_tree_top, offset, cyc_blk_size);\r\nif ( evnt_size > 0 )\r\noffset = dissect_cntr_event(tvb, proto_tree_top, offset, evnt_size);\r\nif ( servc_size > 0 )\r\noffset = dissect_cntr_service(tvb, proto_tree_top, offset, servc_size);\r\nbreak;\r\ncase FORMAT_VAR_DEVICE_TO_CONTROL:\r\nif ( cyc_size > 0 )\r\noffset = dissect_devce_cyclic( con_format, tvb, proto_tree_top, offset, cyc_size, instance );\r\nif ( cyc_blk_size > 0 )\r\noffset = dissect_cyclic_rd( tvb, proto_tree_top, offset, cyc_blk_size );\r\nif ( evnt_size > 0 )\r\noffset = dissect_devce_event(tvb, proto_tree_top, offset, evnt_size);\r\nif ( servc_size > 0 )\r\noffset = dissect_devce_service(tvb, proto_tree_top, offset, servc_size);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_cipmotion(void)\r\n{\r\nstatic hf_register_info hf[] =\r\n{\r\n{ &hf_cip_format,\r\n{ "Connection Format", "cipm.format",\r\nFT_UINT8, BASE_DEC, VALS(cip_con_format_vals), 0,\r\n"Message connection format", HFILL }\r\n},\r\n{ &hf_cip_revision,\r\n{ "Format Revision", "cipm.revision",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Message format revision", HFILL }\r\n},\r\n{ &hf_cip_class1_seqnum,\r\n{ "CIP Class 1 Sequence Number", "cipm.class1seqnum",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cip_updateid,\r\n{ "Update Id", "cipm.updateid",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Cyclic Transaction Number", HFILL }\r\n},\r\n{ &hf_cip_instance_cnt,\r\n{ "Instance Count", "cipm.instancecount",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cip_last_update,\r\n{ "Last Update Id", "cipm.lastupdate",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cip_node_status,\r\n{ "Node Status", "cipm.nodestatus",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cip_node_control,\r\n{ "Node Control", "cipm.nodecontrol",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cip_node_control_remote,\r\n{ "Remote Control", "cipm.remote",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), 0x01,\r\n"Node Control: Remote Control", HFILL}\r\n},\r\n{ &hf_cip_node_control_sync,\r\n{ "Sync Control", "cipm.sync",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), 0x02,\r\n"Node Control: Synchronous Operation", HFILL}\r\n},\r\n{ &hf_cip_node_data_valid,\r\n{ "Data Valid", "cipm.valid",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), 0x04,\r\n"Node Control: Data Valid", HFILL}\r\n},\r\n{ &hf_cip_node_fault_reset,\r\n{ "Fault Reset", "cipm.fltrst",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), 0x08,\r\n"Node Control: Device Fault Reset", HFILL}\r\n},\r\n{ &hf_cip_node_device_faulted,\r\n{ "Faulted", "cipm.flt",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), 0x08,\r\n"Node Control: Device Faulted", HFILL}\r\n},\r\n{ &hf_cip_node_fltalarms,\r\n{ "Node Faults and Alarms", "cipm.fltalarms",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cip_time_data_set,\r\n{ "Time Data Set", "cipm.timedataset",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cip_time_data_stamp,\r\n{ "Time Stamp", "cipm.time.stamp",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), TIME_DATA_SET_TIME_STAMP,\r\n"Time Data Set: Time Stamp", HFILL}\r\n},\r\n{ &hf_cip_time_data_offset,\r\n{ "Time Offset", "cipm.time.offset",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), TIME_DATA_SET_TIME_OFFSET,\r\n"Time Data Set: Time Offset", HFILL}\r\n},\r\n{ &hf_cip_time_data_diag,\r\n{ "Time Update Diagnostics", "cipm.time.update",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), TIME_DATA_SET_UPDATE_DIAGNOSTICS,\r\n"Time Data Set: Time Update Diagnostics", HFILL}\r\n},\r\n{ &hf_cip_time_data_time_diag,\r\n{ "Time Diagnostics", "cipm.time.diag",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), TIME_DATA_SET_TIME_DIAGNOSTICS,\r\n"Time Data Set: Time Diagnostics", HFILL}\r\n},\r\n{ &hf_cip_cont_time_stamp,\r\n{ "Controller Time Stamp", "cipm.ctrltimestamp",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\n"Time Data Set: Controller Time Stamp", HFILL}\r\n},\r\n{ &hf_cip_cont_time_offset,\r\n{ "Controller Time Offset", "cipm.ctrltimeoffser",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\n"Time Data Set: Controller Time Offset", HFILL}\r\n},\r\n{ &hf_cip_data_rx_time_stamp,\r\n{ "Data Received Time Stamp", "cipm.rxtimestamp",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\n"Time Data Set: Data Received Time Stamp", HFILL}\r\n},\r\n{ &hf_cip_data_tx_time_stamp,\r\n{ "Data Transmit Time Stamp", "cipm.txtimestamp",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\n"Time Data Set: Data Transmit Time Offset", HFILL}\r\n},\r\n{ &hf_cip_devc_time_stamp,\r\n{ "Device Time Stamp", "cipm.devctimestamp",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\n"Time Data Set: Device Time Stamp", HFILL}\r\n},\r\n{ &hf_cip_devc_time_offset,\r\n{ "Device Time Offset", "cipm.devctimeoffser",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\n"Time Data Set: Device Time Offset", HFILL}\r\n},\r\n{ &hf_cip_lost_update,\r\n{ "Lost Updates", "cipm.lostupdates",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Time Data Set: Lost Updates", HFILL}\r\n},\r\n{ &hf_cip_late_update,\r\n{ "Lost Updates", "cipm.lateupdates",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Time Data Set: Late Updates", HFILL}\r\n},\r\n{ &hf_cip_motor_cntrl,\r\n{ "Control Mode", "cipm.ctrlmode",\r\nFT_UINT8, BASE_DEC, VALS(cip_motor_control_vals), 0,\r\n"Cyclic Data Block: Motor Control Mode", HFILL }\r\n},\r\n{ &hf_cip_fdbk_config,\r\n{ "Feedback Config", "cipm.fdbkcfg",\r\nFT_UINT8, BASE_DEC, VALS(cip_fdbk_config_vals), 0,\r\n"Cyclic Data Block: Feedback Configuration", HFILL }\r\n},\r\n{ &hf_cip_axis_control,\r\n{ "Axis Control", "cipm.axisctrl",\r\nFT_UINT8, BASE_DEC, VALS(cip_axis_control_vals), 0,\r\n"Cyclic Data Block: Axis Control", HFILL }\r\n},\r\n{ &hf_cip_control_status,\r\n{ "Control Status", "cipm.csts",\r\nFT_UINT8, BASE_DEC, VALS(cip_control_status_vals), 0,\r\n"Cyclic Data Block: Axis Control Status", HFILL }\r\n},\r\n{ &hf_cip_axis_response,\r\n{ "Axis Response", "cipm.axisresp",\r\nFT_UINT8, BASE_DEC, VALS(cip_axis_response_vals), 0,\r\n"Cyclic Data Block: Axis Response", HFILL }\r\n},\r\n{ &hf_cip_axis_resp_stat,\r\n{ "Response Status", "cipm.respstat",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &cip_gs_vals_ext, 0,\r\n"Cyclic Data Block: Axis Response Status", HFILL }\r\n},\r\n{ &hf_cip_group_sync,\r\n{ "Group Sync Status", "cipm.syncstatus",\r\nFT_UINT8, BASE_HEX, VALS(cip_sync_status_vals), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cip_cmd_data_set,\r\n{ "Command Data Set", "cipm.cmdset",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cip_act_data_set,\r\n{ "Actual Data Set", "cipm.actset",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cip_sts_data_set,\r\n{ "Status Data Set", "cipm.stsset",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cip_cmd_data_pos_cmd,\r\n{ "Command Position", "cipm.cmd.pos",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), COMMAND_DATA_SET_POSITION,\r\n"Command Data Set: Command Position", HFILL}\r\n},\r\n{ &hf_cip_cmd_data_vel_cmd,\r\n{ "Command Velocity", "cipm.cmd.vel",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), COMMAND_DATA_SET_VELOCITY,\r\n"Command Data Set: Command Velocity", HFILL}\r\n},\r\n{ &hf_cip_cmd_data_acc_cmd,\r\n{ "Command Acceleration", "cipm.cmd.acc",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), COMMAND_DATA_SET_ACCELERATION,\r\n"Command Data Set: Command Acceleration", HFILL}\r\n},\r\n{ &hf_cip_cmd_data_trq_cmd,\r\n{ "Command Torque", "cipm.cmd.trq",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), COMMAND_DATA_SET_TORQUE,\r\n"Command Data Set: Command Torque", HFILL}\r\n},\r\n{ &hf_cip_cmd_data_pos_trim_cmd,\r\n{ "Position Trim", "cipm.cmd.postrm",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), COMMAND_DATA_SET_POSITION_TRIM,\r\n"Command Data Set: Position Trim", HFILL}\r\n},\r\n{ &hf_cip_cmd_data_vel_trim_cmd,\r\n{ "Velocity Trim", "cipm.cmd.veltrm",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), COMMAND_DATA_SET_VELOCITY_TRIM,\r\n"Command Data Set: Velocity Trim", HFILL}\r\n},\r\n{ &hf_cip_cmd_data_acc_trim_cmd,\r\n{ "Acceleration Trim", "cipm.cmd.acctrm",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), COMMAND_DATA_SET_ACCELERATION_TRIM,\r\n"Command Data Set: Acceleration Trim", HFILL}\r\n},\r\n{ &hf_cip_cmd_data_trq_trim_cmd,\r\n{ "Torque Trim", "cipm.cmd.trqtrm",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), COMMAND_DATA_SET_TORQUE_TRIM,\r\n"Command Data Set: Torque Trim", HFILL}\r\n},\r\n{ &hf_cip_act_data_pos,\r\n{ "Actual Position", "cipm.act.pos",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), ACTUAL_DATA_SET_POSITION,\r\n"Acutal Data Set: Actual Position", HFILL}\r\n},\r\n{ &hf_cip_act_data_vel,\r\n{ "Actual Velocity", "cipm.act.vel",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), ACTUAL_DATA_SET_VELOCITY,\r\n"Actual Data Set: Actual Velocity", HFILL}\r\n},\r\n{ &hf_cip_act_data_acc,\r\n{ "Actual Acceleration", "cipm.act.acc",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), ACTUAL_DATA_SET_ACCELERATION,\r\n"Actual Data Set: Actual Acceleration", HFILL}\r\n},\r\n{ &hf_cip_act_data_trq,\r\n{ "Actual Torque", "cipm.act.trq",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), ACTUAL_DATA_SET_TORQUE,\r\n"Actual Data Set: Actual Torque", HFILL}\r\n},\r\n{ &hf_cip_act_data_crnt,\r\n{ "Actual Current", "cipm.act.crnt",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), ACTUAL_DATA_SET_CURRENT,\r\n"Actual Data Set: Actual Current", HFILL}\r\n},\r\n{ &hf_cip_act_data_vltg,\r\n{ "Actual Voltage", "cipm.act.vltg",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), ACTUAL_DATA_SET_VOLTAGE,\r\n"Actual Data Set: Actual Voltage", HFILL}\r\n},\r\n{ &hf_cip_act_data_fqcy,\r\n{ "Actual Frequency", "cipm.act.fqcy",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), ACTUAL_DATA_SET_FREQUENCY,\r\n"Actual Data Set: Actual Frequency", HFILL}\r\n},\r\n{ &hf_cip_axis_fault,\r\n{ "Axis Fault Code", "cipm.fault.code",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Status Data Set: Fault Code", HFILL }\r\n},\r\n{ &hf_cip_fault_type,\r\n{ "Axis Fault Type", "cipm.flttype",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Axis Status: Axis Fault Type", HFILL}\r\n},\r\n{ &hf_cip_fault_sub_code,\r\n{ "Axis Fault Sub Code", "cipm.fltsubcode",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Axis Status: Axis Fault Sub Code", HFILL}\r\n},\r\n{ &hf_cip_fault_action,\r\n{ "Axis Fault Action", "cipm.fltaction",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Axis Status: Axis Fault Action", HFILL}\r\n},\r\n{ &hf_cip_fault_time_stamp,\r\n{ "Axis Fault Time Stamp", "cipm.flttimestamp",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\n"Axis Status: Axis Fault Time Stamp", HFILL}\r\n},\r\n{ &hf_cip_alarm_type,\r\n{ "Axis Fault Type", "cipm.alarmtype",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Axis Status: Axis Alarm Type", HFILL}\r\n},\r\n{ &hf_cip_alarm_sub_code,\r\n{ "Axis Alarm Sub Code", "cipm.alarmsubcode",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Axis Status: Axis Alarm Sub Code", HFILL}\r\n},\r\n{ &hf_cip_alarm_state,\r\n{ "Axis Alarm State", "cipm.alarmstate",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Axis Status: Axis Alarm State", HFILL }\r\n},\r\n{ &hf_cip_alarm_time_stamp,\r\n{ "Axis Fault Time Stamp", "cipm.alarmtimestamp",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\n"Axis Status: Axis Alarm Time Stamp", HFILL}\r\n},\r\n{ &hf_cip_axis_status,\r\n{ "Axis Status", "cipm.axisstatus",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cip_axis_status_mfg,\r\n{ "Axis Status Mfg", "cipm.axisstatusmfg",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Axis Status, Manufacturer Specific", HFILL}\r\n},\r\n{ &hf_cip_axis_io_status,\r\n{ "Axis I/O Status", "cipm.axisiostatus",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cip_axis_io_status_mfg,\r\n{ "Axis I/O Status Mfg", "cipm.axisiostatusmfg",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Axis I/O Status, Manufacturer Specific", HFILL}\r\n},\r\n{ &hf_cip_axis_safety_status,\r\n{ "Axis Safety Status", "cipm.safetystatus",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cip_axis_safety_status_mfg,\r\n{ "Axis Safety Status Mfg", "cipm.safetystatusmfg",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Axis Safety Status, Manufacturer Specific", HFILL}\r\n},\r\n{ &hf_cip_axis_safety_state,\r\n{ "Axis Safety State", "cipm.safetystate",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Axis Safety Sate", HFILL}\r\n},\r\n{ &hf_cip_drive_safety_status,\r\n{ "Drive Safety Status", "cipm.drivesafetystatus",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cip_sts_flt,\r\n{ "Axis Fault Codes", "cipm.sts.flt",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), STATUS_DATA_SET_AXIS_FAULT,\r\n"Status Data Set: Axis Fault Codes", HFILL}\r\n},\r\n{ &hf_cip_sts_alrm,\r\n{ "Axis Alarm Codes", "cipm.sts.alarm",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), STATUS_DATA_SET_AXIS_ALARM,\r\n"Status Data Set: Axis Alarm Codes", HFILL}\r\n},\r\n{ &hf_cip_sts_sts,\r\n{ "Axis Status", "cipm.sts.sts",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), STATUS_DATA_SET_AXIS_STATUS,\r\n"Status Data Set: Axis Status", HFILL}\r\n},\r\n{ &hf_cip_sts_iosts,\r\n{ "Axis I/O Status", "cipm.sts.iosts",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), STATUS_DATA_SET_AXIS_IO_STATUS,\r\n"Status Data Set: Axis I/O Status", HFILL}\r\n},\r\n{ &hf_cip_sts_axis_safety,\r\n{ "Axis Safety Status", "cipm.sts.safety",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), STATUS_DATA_SET_AXIS_SAFETY,\r\n"Status Data Set: Axis Safety Status", HFILL}\r\n},\r\n{ &hf_cip_sts_drive_safety,\r\n{ "Drive Safety Status", "cipm.sts.safety",\r\nFT_BOOLEAN, 8, TFS(&tfs_true_false), STATUS_DATA_SET_DRIVE_SAFETY,\r\n"Status Data Set: Drive Safety Status", HFILL}\r\n},\r\n{ &hf_cip_intrp,\r\n{ "Interpolation Control", "cipm.intrp",\r\nFT_UINT8, BASE_DEC, VALS(cip_interpolation_vals), COMMAND_CONTROL_TARGET_UPDATE,\r\n"Cyclic Data Block: Interpolation Control", HFILL}\r\n},\r\n{ &hf_cip_position_data_type,\r\n{ "Position Data Type", "cipm.posdatatype",\r\nFT_UINT8, BASE_DEC, VALS(cip_pos_data_type_vals), COMMAND_CONTROL_POSITION_DATA_TYPE,\r\n"Cyclic Data Block: Position Data Type", HFILL }\r\n},\r\n{ &hf_cip_axis_state,\r\n{ "Axis State", "cipm.axste",\r\nFT_UINT8, BASE_DEC, VALS(cip_axis_state_vals), 0,\r\n"Cyclic Data Block: Axis State", HFILL}\r\n},\r\n{ &hf_cip_command_control,\r\n{ "Command Control", "cipm.cmdcontrol",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Cyclic Data Block: Command Control", HFILL }\r\n},\r\n{ &hf_cip_cyclic_wrt_data,\r\n{ "Write Data", "cipm.writedata",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Cyclic Write: Data", HFILL }\r\n},\r\n{ &hf_cip_cyclic_rd_data,\r\n{ "Read Data", "cipm.readdata",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Cyclic Read: Data", HFILL }\r\n},\r\n{ &hf_cip_cyclic_write_blk,\r\n{ "Write Block", "cipm.writeblk",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Cyclic Data Block: Write Block Id", HFILL }\r\n},\r\n{ &hf_cip_cyclic_read_blk,\r\n{ "Read Block", "cipm.readblk",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Cyclic Data Block: Read Block Id", HFILL}\r\n},\r\n{ &hf_cip_cyclic_write_sts,\r\n{ "Write Status", "cipm.writests",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Cyclic Data Block: Write Status", HFILL }\r\n},\r\n{ &hf_cip_cyclic_read_sts,\r\n{ "Read Status", "cipm.readsts",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Cyclic Data Block: Read Status", HFILL }\r\n},\r\n{ &hf_cip_event_checking,\r\n{ "Event Control", "cipm.evntchkcontrol",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Event Channel: Event Checking Control", HFILL}\r\n},\r\n{ &hf_cip_event_ack,\r\n{ "Event Acknowledgement", "cipm.evntack",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Event Channel: Event Acknowledgement", HFILL}\r\n},\r\n{ &hf_cip_event_status,\r\n{ "Event Status", "cipm.evntchkstatus",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Event Channel: Event Checking Status", HFILL}\r\n},\r\n{ &hf_cip_event_id,\r\n{ "Event Id", "cipm.evntack",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Event Channel: Event Id", HFILL }\r\n},\r\n{ &hf_cip_event_pos,\r\n{ "Event Position", "cipm.evntpos",\r\nFT_INT32, BASE_DEC, NULL, 0,\r\n"Event Channel: Event Position", HFILL}\r\n},\r\n{ &hf_cip_event_ts,\r\n{ "Event Time Stamp", "cipm.evntimestamp",\r\nFT_UINT64, BASE_DEC, NULL, 0,\r\n"Event Channel: Time Stamp", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_reg1_pos,\r\n{ "Reg 1 Pos Edge", "cipm.evnt.ctrl.reg1posedge",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000001,\r\n"Event Checking Control: Reg 1 Pos Edge", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_reg1_neg,\r\n{ "Reg 1 Neg Edge", "cipm.evnt.ctrl.reg1negedge",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000002,\r\n"Event Checking Control: Reg 1 Neg Edge", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_reg2_pos,\r\n{ "Reg 2 Pos Edge", "cipm.evnt.ctrl.reg2posedge",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000004,\r\n"Event Checking Control: Reg 2 Pos Edge", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_reg2_neg,\r\n{ "Reg 2 Neg Edge", "cipm.evnt.ctrl.reg2negedge",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000008,\r\n"Event Checking Control: Reg 2 Neg Edge", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_reg1_posrearm,\r\n{ "Reg 1 Pos Rearm", "cipm.evnt.ctrl.reg1posrearm",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000100,\r\n"Event Checking Control: Reg 1 Pos Rearm", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_reg1_negrearm,\r\n{ "Reg 1 Neg Rearm", "cipm.evnt.ctrl.reg1negrearm",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000200,\r\n"Event Checking Control: Reg 1 Neg Rearm", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_reg2_posrearm,\r\n{ "Reg 2 Pos Rearm", "cipm.evnt.ctrl.reg2posrearm",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000400,\r\n"Event Checking Control: Reg 2 Pos Rearm", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_reg2_negrearm,\r\n{ "Reg 2 Neg Rearm", "cipm.evnt.ctrl.reg2negrearm",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000800,\r\n"Event Checking Control: Reg 2 Neg Rearm", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_marker_pos,\r\n{ "Marker Pos Edge", "cipm.evnt.ctrl.mrkrpos",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00010000,\r\n"Event Checking Control: Marker Pos Edge", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_marker_neg,\r\n{ "Marker Neg Edge", "cipm.evnt.ctrl.mrkrneg",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00020000,\r\n"Event Checking Control: Marker Neg Edge", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_home_pos,\r\n{ "Home Pos Edge", "cipm.evnt.ctrl.homepos",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00040000,\r\n"Event Checking Control: Home Pos Edge", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_home_neg,\r\n{ "Home Neg Edge", "cipm.evnt.ctrl.homeneg",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00080000,\r\n"Event Checking Control: Home Neg Edge", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_home_pp,\r\n{ "Home-Switch-Marker Plus Plus", "cipm.evnt.ctrl.homepp",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00100000,\r\n"Event Checking Control: Home-Switch-Marker Plus Plus", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_home_pm,\r\n{ "Home-Switch-Marker Plus Minus", "cipm.evnt.ctrl.homepm",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00200000,\r\n"Event Checking Control: Home-Switch-Marker Plus Minus", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_home_mp,\r\n{ "Home-Switch-Marker Minus Plus", "cipm.evnt.ctrl.homemp",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00400000,\r\n"Event Checking Control: Home-Switch-Marker Minus Plus", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_home_mm,\r\n{ "Home-Switch-Marker Minus Minus", "cipm.evnt.ctrl.homemm",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00800000,\r\n"Event Checking Control: Home-Switch-Marker Minus Minus", HFILL}\r\n},\r\n{ &hf_cip_evnt_ctrl_acks,\r\n{ "Event Acknowledge Blocks", "cipm.evnt.ctrl.acks",\r\nFT_UINT32, BASE_DEC, NULL, 0x70000000,\r\n"Event Checking Control: Event Acknowledge Blocks", HFILL}\r\n},\r\n{ &hf_cip_evnt_extend_format,\r\n{ "Extended Event Format", "cipm.evnt.extend",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x80000000,\r\n"Event Checking Control: Extended Event Format", HFILL}\r\n},\r\n{ &hf_cip_evnt_sts_reg1_pos,\r\n{ "Reg 1 Pos Edge", "cipm.evnt.sts.reg1posedge",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000001,\r\n"Event Checking Status: Reg 1 Pos Edge", HFILL}\r\n},\r\n{ &hf_cip_evnt_sts_reg1_neg,\r\n{ "Reg 1 Neg Edge", "cipm.evnt.sts.reg1negedge",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000002,\r\n"Event Checking Status: Reg 1 Neg Edge", HFILL }\r\n},\r\n{ &hf_cip_evnt_sts_reg2_pos,\r\n{ "Reg 2 Pos Edge", "cipm.evnt.sts.reg2posedge",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000004,\r\n"Event Checking Status: Reg 2 Pos Edge", HFILL}\r\n},\r\n{ &hf_cip_evnt_sts_reg2_neg,\r\n{ "Reg 2 Neg Edge", "cipm.evnt.sts.reg2negedge",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000008,\r\n"Event Checking Status: Reg 2 Neg Edge", HFILL}\r\n},\r\n{ &hf_cip_evnt_sts_reg1_posrearm,\r\n{ "Reg 1 Pos Rearm", "cipm.evnt.sts.reg1posrearm",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000100,\r\n"Event Checking Status: Reg 1 Pos Rearm", HFILL}\r\n},\r\n{ &hf_cip_evnt_sts_reg1_negrearm,\r\n{ "Reg 1 Neg Rearm", "cipm.evnt.sts.reg1negrearm",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000200,\r\n"Event Checking Status: Reg 1 Neg Rearm", HFILL}\r\n},\r\n{ &hf_cip_evnt_sts_reg2_posrearm,\r\n{ "Reg 2 Pos Rearm", "cipm.evnt.sts.reg2posrearm",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000400,\r\n"Event Checking Status: Reg 2 Pos Rearm", HFILL}\r\n},\r\n{ &hf_cip_evnt_sts_reg2_negrearm,\r\n{ "Reg 2 Neg Rearm", "cipm.evnt.sts.reg2negrearm",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000800,\r\n"Event Checking Status: Reg 2 Neg Rearm", HFILL}\r\n},\r\n{ &hf_cip_evnt_sts_marker_pos,\r\n{ "Marker Pos Edge", "cipm.evnt.sts.mrkrpos",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00010000,\r\n"Event Checking Status: Marker Pos Edge", HFILL}\r\n},\r\n{ &hf_cip_evnt_sts_marker_neg,\r\n{ "Marker Neg Edge", "cipm.evnt.sts.mrkrneg",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00020000,\r\n"Event Checking Status: Marker Neg Edge", HFILL }\r\n},\r\n{ &hf_cip_evnt_sts_home_pos,\r\n{ "Home Pos Edge", "cipm.evnt.sts.homepos",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00040000,\r\n"Event Checking Status: Home Pos Edge", HFILL}\r\n},\r\n{ &hf_cip_evnt_sts_home_neg,\r\n{ "Home Neg Edge", "cipm.evnt.sts.homeneg",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00080000,\r\n"Event Checking Status: Home Neg Edge", HFILL }\r\n},\r\n{ &hf_cip_evnt_sts_home_pp,\r\n{ "Home-Switch-Marker Plus Plus", "cipm.evnt.sts.homepp",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00100000,\r\n"Event Checking Status: Home-Switch-Marker Plus Plus", HFILL}\r\n},\r\n{ &hf_cip_evnt_sts_home_pm,\r\n{ "Home-Switch-Marker Plus Minus", "cipm.evnt.sts.homepm",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00200000,\r\n"Event Checking Status: Home-Switch-Marker Plus Minus", HFILL}\r\n},\r\n{ &hf_cip_evnt_sts_home_mp,\r\n{ "Home-Switch-Marker Minus Plus", "cipm.evnt.sts.homemp",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00400000,\r\n"Event Checking Status: Home-Switch-Marker Minus Plus", HFILL}\r\n},\r\n{ &hf_cip_evnt_sts_home_mm,\r\n{ "Home-Switch-Marker Minus Minus", "cipm.evnt.sts.homemm",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00800000,\r\n"Event Checking Status: Home-Switch-Marker Minus Minus", HFILL}\r\n},\r\n{ &hf_cip_evnt_sts_nfs,\r\n{ "Event Notification Blocks", "cipm.evnt.sts.nfs",\r\nFT_UINT32, BASE_DEC, NULL, 0x70000000,\r\n"Event Checking Status: Event Notification Blocks", HFILL}\r\n},\r\n{ &hf_cip_evnt_sts_stat,\r\n{ "Event Status", "cipm.evnt.stat",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &cip_gs_vals_ext, 0,\r\n"Event Data Block: Event Status", HFILL }\r\n},\r\n{ &hf_cip_evnt_type,\r\n{ "Event Type", "cipm.evnt.type",\r\nFT_UINT8, BASE_DEC, VALS(cip_event_type_vals), 0,\r\n"Event Data Block: Event Type", HFILL}\r\n},\r\n{ &hf_cip_svc_code,\r\n{ "Service Code", "cipm.svc.code",\r\nFT_UINT8, BASE_DEC, VALS(cip_sc_vals), 0,\r\n"Service Data Block: Service Code", HFILL}\r\n},\r\n{ &hf_cip_svc_sts,\r\n{ "General Status", "cipm.svc.sts",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &cip_gs_vals_ext, 0,\r\n"Service Data Block: General Status", HFILL }\r\n},\r\n{ &hf_cip_svc_transction,\r\n{ "Transaction Id", "cipm.svc.tranid",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Service Data Block: Transaction Id", HFILL }\r\n},\r\n{ &hf_cip_svc_ext_status,\r\n{ "Extended Status", "cipm.svc.extstatus",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Service Data Block: Extended Status", HFILL }\r\n},\r\n{ &hf_cip_svc_data,\r\n{ "Service Data", "cipm.svc.data",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Service Data Block: Data", HFILL }\r\n},\r\n{ &hf_cip_attribute_data,\r\n{ "Attribute Data", "cipm.attrdata",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Attribute Service: Data", HFILL }\r\n},\r\n{ &hf_cip_ptp_grandmaster,\r\n{ "Grandmaster", "cipm.grandmaster",\r\nFT_UINT64, BASE_HEX, NULL, 0,\r\n"Group Sync: Grandmaster Id", HFILL}\r\n},\r\n{ &hf_cip_svc_get_axis_attr_sts,\r\n{ "Attribute Status", "cipm.getaxisattr.sts",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &cip_gs_vals_ext, 0,\r\n"Service Channel: Get Axis Attribute List Response Status", HFILL }\r\n},\r\n{ &hf_get_axis_attr_list_attribute_cnt,\r\n{ "Number of attributes", "cipm.getaxisattr.cnt",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Service Channel: Get Axis Attribute List Attribute Count", HFILL}\r\n},\r\n{ &hf_get_axis_attr_list_attribute_id,\r\n{ "Attribute ID", "cipm.getaxisattr.id",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Service Channel: Get Axis Attribute List Attribute ID", HFILL}\r\n},\r\n{ &hf_get_axis_attr_list_dimension,\r\n{ "Dimension", "cipm.getaxisattr.dimension",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Service Channel: Get Axis Attribute List Dimension", HFILL}\r\n},\r\n{ &hf_get_axis_attr_list_element_size,\r\n{ "Element size", "cipm.getaxisattr.element_size",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Service Channel: Get Axis Attribute List Element Size", HFILL}\r\n},\r\n{ &hf_get_axis_attr_list_start_index,\r\n{ "Start index", "cipm.getaxisattr.start_index",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Service Channel: Get Axis Attribute List Start index", HFILL}\r\n},\r\n{ &hf_get_axis_attr_list_data_elements,\r\n{ "Data elements", "cipm.getaxisattr.data_elements",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Service Channel: Get Axis Attribute List Data elements", HFILL}\r\n},\r\n{ &hf_cip_svc_set_axis_attr_sts,\r\n{ "Attribute Status", "cipm.setaxisattr.sts",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &cip_gs_vals_ext, 0,\r\n"Service Channel: Set Axis Attribute List Response Status", HFILL }\r\n},\r\n{ &hf_set_axis_attr_list_attribute_cnt,\r\n{ "Number of attributes", "cipm.setaxisattr.cnt",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Service Channel: Set Axis Attribute List Attribute Count", HFILL}\r\n},\r\n{ &hf_set_axis_attr_list_attribute_id,\r\n{ "Attribute ID", "cipm.setaxisattr.id",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Service Channel: Set Axis Attribute List Attribute ID", HFILL}\r\n},\r\n{ &hf_set_axis_attr_list_dimension,\r\n{ "Dimension", "cipm.setaxisattr.dimension",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Service Channel: Set Axis Attribute List Dimension", HFILL}\r\n},\r\n{ &hf_set_axis_attr_list_element_size,\r\n{ "Element size", "cipm.setaxisattr.element_size",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Service Channel: Set Axis Attribute List Element Size", HFILL}\r\n},\r\n{ &hf_set_axis_attr_list_start_index,\r\n{ "Start index", "cipm.setaxisattr.start_index",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Service Channel: Set Axis Attribute List Start index", HFILL}\r\n},\r\n{ &hf_set_axis_attr_list_data_elements,\r\n{ "Data elements", "cipm.setaxisattr.data_elements",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Service Channel: Set Axis Attribute List Data elements", HFILL}\r\n},\r\n{ &hf_var_devce_instance,\r\n{ "Instance Number", "cipm.var_devce.header.instance",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Variable Device Header: Instance Number", HFILL}\r\n},\r\n{ &hf_var_devce_instance_block_size,\r\n{ "Instance Block Size", "cipm.var_devce.header.instance_block_size",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Variable Device Header: Instance Block Size", HFILL}\r\n},\r\n{ &hf_var_devce_cyclic_block_size,\r\n{ "Cyclic Block Size", "cipm.var_devce.header.cyclic_block_size",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Variable Device Header: Cyclic Block Size", HFILL}\r\n},\r\n{ &hf_var_devce_cyclic_data_block_size,\r\n{ "Cyclic Data Block Size", "cipm.var_devce.header.cyclic_data_block_size",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Variable Device Header: Cyclic Data Block Size", HFILL}\r\n},\r\n{ &hf_var_devce_cyclic_rw_block_size,\r\n{ "Cyclic Read/Write Block Size", "cipm.var_devce.header.cyclic_rw_block_size",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Variable Device Header: Cyclic Read/Write Block Size", HFILL}\r\n},\r\n{ &hf_var_devce_event_block_size,\r\n{ "Event Block Size", "cipm.var_devce.header.event_block_size",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Variable Device Header: Event Block Size", HFILL}\r\n},\r\n{ &hf_var_devce_service_block_size,\r\n{ "Service Block Size", "cipm.var_devce.header.service_block_size",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Variable Device Header: Service Block Size", HFILL}\r\n},\r\n{ &hf_cip_axis_alarm,\r\n{ "Axis Alarm Code", "cipm.alarm.code",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Status Data Set: Alarm Code", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_local_ctrl,\r\n{ "Local Control", "cipm.axis.local",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000001,\r\n"Axis Status Data Set: Local Contol", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_alarm,\r\n{ "Alarm", "cipm.axis.alarm",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000002,\r\n"Axis Status Data Set: Alarm", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_dc_bus,\r\n{ "DC Bus", "cipm.axis.bus",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000004,\r\n"Axis Status Data Set: DC Bus", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_pwr_struct,\r\n{ "Power Struct", "cipm.axis.pwr",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000008,\r\n"Axis Status Data Set: Power Struct", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_tracking,\r\n{ "Tracking", "cipm.axis.track",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000020,\r\n"Axis Status Data Set: Tracking", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_pos_lock,\r\n{ "Pos Lock", "cipm.axis.poslock",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000040,\r\n"Axis Status Data Set: Pos Lock", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_vel_lock,\r\n{ "Vel Lock", "cipm.axis.vellock",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000080,\r\n"Axis Status Data Set: Vel Lock", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_vel_standstill,\r\n{ "Standstill", "cipm.axis.nomo",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000100,\r\n"Axis Status Data Set: Standstill", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_vel_threshold,\r\n{ "Vel Threshold", "cipm.axis.vthresh",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000200,\r\n"Axis Status Data Set: Vel Threshold", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_vel_limit,\r\n{ "Vel Limit", "cipm.axis.vlim",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000400,\r\n"Axis Status Data Set: Vel Limit", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_acc_limit,\r\n{ "Acc Limit", "cipm.axis.alim",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00000800,\r\n"Axis Status Data Set: Acc Limit", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_dec_limit,\r\n{ "Dec Limit", "cipm.axis.dlim",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00001000,\r\n"Axis Status Data Set: Dec Limit", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_torque_threshold,\r\n{ "Torque Threshold", "cipm.axis.tthresh",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00002000,\r\n"Axis Status Data Set: Torque Threshold", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_torque_limit,\r\n{ "Torque Limit", "cipm.axis.tlim",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00004000,\r\n"Axis Status Data Set: Torque Limit", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_cur_limit,\r\n{ "Current Limit", "cipm.axis.ilim",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00008000,\r\n"Axis Status Data Set: Current Limit", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_therm_limit,\r\n{ "Thermal Limit", "cipm.axis.hot",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00010000,\r\n"Axis Status Data Set: Thermal Limit", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_feedback_integ,\r\n{ "Feedback Integrity", "cipm.axis.fgood",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00020000,\r\n"Axis Status Data Set: Feedback Integrity", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_shutdown,\r\n{ "Shutdown", "cipm.axis.sdwn",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00040000,\r\n"Axis Status Data Set: Shutdown", HFILL }\r\n},\r\n{ &hf_cip_axis_sts_in_process,\r\n{ "In Process", "cipm.axis.inp",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x00080000,\r\n"Axis Status Data Set: In Process", HFILL }\r\n},\r\n{ &hf_cip_act_pos,\r\n{ "Actual Position", "cipm.actpos",\r\nFT_INT32, BASE_DEC, NULL, 0,\r\n"Cyclic Data Set: Actual Position", HFILL }\r\n},\r\n{ &hf_cip_act_vel,\r\n{ "Actual Velocity", "cipm.actvel",\r\nFT_FLOAT, BASE_NONE, NULL, 0,\r\n"Cyclic Data Set: Actual Velocity", HFILL }\r\n},\r\n{ &hf_cip_act_accel,\r\n{ "Actual Acceleration", "cipm.actaccel",\r\nFT_FLOAT, BASE_NONE, NULL, 0,\r\n"Cyclic Data Set: Actual Acceleration", HFILL }\r\n},\r\n{ &hf_cip_act_trq,\r\n{ "Actual Torque", "cipm.acttrq",\r\nFT_FLOAT, BASE_NONE, NULL, 0,\r\n"Cyclic Data Set: Actual Torque", HFILL }\r\n},\r\n{ &hf_cip_act_crnt,\r\n{ "Actual Current", "cipm.actcrnt",\r\nFT_FLOAT, BASE_NONE, NULL, 0,\r\n"Cyclic Data Set: Actual Current", HFILL }\r\n},\r\n{ &hf_cip_act_volts,\r\n{ "Actual Volts", "cipm.actvolts",\r\nFT_FLOAT, BASE_NONE, NULL, 0,\r\n"Cyclic Data Set: Actual Volts", HFILL }\r\n},\r\n{ &hf_cip_act_freq,\r\n{ "Actual Frequency", "cipm.actfreq",\r\nFT_FLOAT, BASE_NONE, NULL, 0,\r\n"Cyclic Data Set: Actual Frequency", HFILL }\r\n},\r\n{ &hf_cip_pos_cmd,\r\n{ "Position Command", "cipm.posfcmd",\r\nFT_DOUBLE, BASE_NONE, NULL, 0,\r\n"Cyclic Data Set: Position Command (LREAL)", HFILL }\r\n},\r\n{ &hf_cip_pos_cmd_int,\r\n{ "Position Command", "cipm.posicmd",\r\nFT_INT32, BASE_DEC, NULL, 0,\r\n"Cyclic Data Set: Position Command (DINT)", HFILL }\r\n},\r\n{ &hf_cip_vel_cmd,\r\n{ "Velocity Command", "cipm.velcmd",\r\nFT_FLOAT, BASE_NONE, NULL, 0,\r\n"Cyclic Data Set: Velocity Command", HFILL }\r\n},\r\n{ &hf_cip_accel_cmd,\r\n{ "Acceleration Command", "cipm.accelcmd",\r\nFT_FLOAT, BASE_NONE, NULL, 0,\r\n"Cyclic Data Set: Acceleration Command", HFILL }\r\n},\r\n{ &hf_cip_trq_cmd,\r\n{ "Torque Command", "cipm.torquecmd",\r\nFT_FLOAT, BASE_NONE, NULL, 0,\r\n"Cyclic Data Set: Torque Command", HFILL }\r\n},\r\n{ &hf_cip_pos_trim,\r\n{ "Position Trim", "cipm.postrim",\r\nFT_FLOAT, BASE_NONE, NULL, 0,\r\n"Cyclic Data Set: Position Trim", HFILL }\r\n},\r\n{ &hf_cip_vel_trim,\r\n{ "Velocity Trim", "cipm.veltrim",\r\nFT_FLOAT, BASE_NONE, NULL, 0,\r\n"Cyclic Data Set: Velocity Trim", HFILL }\r\n},\r\n{ &hf_cip_accel_trim,\r\n{ "Acceleration Trim", "cipm.acceltrim",\r\nFT_FLOAT, BASE_NONE, NULL, 0,\r\n"Cyclic Data Set: Acceleration Trim", HFILL }\r\n},\r\n{ &hf_cip_trq_trim,\r\n{ "Torque Trim", "cipm.trqtrim",\r\nFT_FLOAT, BASE_NONE, NULL, 0,\r\n"Cyclic Data Set: Torque Trim", HFILL }\r\n}\r\n};\r\nstatic gint *cip_subtree[] = {\r\n&ett_cipmotion,\r\n&ett_cont_dev_header,\r\n&ett_node_control,\r\n&ett_node_status,\r\n&ett_time_data_set,\r\n&ett_inst_data_header,\r\n&ett_cyclic_data_block,\r\n&ett_control_mode,\r\n&ett_feedback_config,\r\n&ett_command_data_set,\r\n&ett_actual_data_set,\r\n&ett_status_data_set,\r\n&ett_interp_control,\r\n&ett_cyclic_rd_wt,\r\n&ett_event,\r\n&ett_event_check_ctrl,\r\n&ett_event_check_sts,\r\n&ett_service,\r\n&ett_get_axis_attribute,\r\n&ett_set_axis_attribute,\r\n&ett_get_axis_attr_list,\r\n&ett_set_axis_attr_list,\r\n&ett_group_sync,\r\n&ett_axis_status_set,\r\n&ett_command_control\r\n};\r\nproto_cipmotion = proto_register_protocol(\r\n"Common Industrial Protocol, Motion",\r\n"CIP Motion",\r\n"cipm");\r\n;\r\nproto_register_field_array(proto_cipmotion, hf, array_length(hf));\r\nproto_register_subtree_array(cip_subtree, array_length(cip_subtree));\r\ncipmotion_handle = register_dissector("cipmotion", dissect_cipmotion, proto_cipmotion);\r\n}\r\nvoid proto_reg_handoff_cipmotion(void)\r\n{\r\ndissector_add_for_decode_as("enip.io", cipmotion_handle);\r\n}
