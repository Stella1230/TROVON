static int\r\nhc2b(unsigned char hex)\r\n{\r\nhex = g_ascii_tolower(hex);\r\nif ((hex >= '0') && (hex <= '9'))\r\nreturn hex - '0';\r\nif ((hex >= 'a') && (hex <= 'f'))\r\nreturn hex - 'a' + 10;\r\nreturn -1;\r\n}\r\nstatic int\r\nhex2bin(guint8 *out, guint8 *out_end, char *in)\r\n{\r\nguint8 *out_start = out;\r\nint is_low = 0;\r\nint c;\r\nwhile (*in != '\0')\r\n{\r\nc = hc2b(*(unsigned char *)in);\r\nif (c < 0)\r\n{\r\nin++;\r\ncontinue;\r\n}\r\nif (out == out_end)\r\n{\r\nreturn -1;\r\n}\r\nif (is_low == 0)\r\n{\r\n*out = c << 4;\r\nis_low = 1;\r\n} else {\r\n*out |= (c & 0x0f);\r\nis_low = 0;\r\nout++;\r\n}\r\nin++;\r\n}\r\nreturn (int)(out - out_start);\r\n}\r\nstatic int\r\nxml_get_int(int *val, const char *str, const char *pattern)\r\n{\r\nconst char *ptr;\r\nchar *start, *end;\r\nchar buf[32];\r\nptr = strstr(str, pattern);\r\nif (ptr == NULL)\r\nreturn -1;\r\nstart = strchr(ptr, '"');\r\nif (start == NULL)\r\nreturn -2;\r\nstart++;\r\nend = strchr(start, '"');\r\nif (end == NULL)\r\nreturn -3;\r\nif (end - start > 31)\r\nreturn -4;\r\nmemcpy(buf, start, end - start);\r\nbuf[end - start] = '\0';\r\n*val = atoi(buf);\r\nreturn 0;\r\n}\r\nwtap_open_return_val dct3trace_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nchar line1[64], line2[64];\r\nif (file_gets(line1, sizeof(line1), wth->fh) == NULL ||\r\nfile_gets(line2, sizeof(line2), wth->fh) == NULL)\r\n{\r\n*err = file_error(wth->fh, err_info);\r\nif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif( strncmp(dct3trace_magic_line1, line1, strlen(dct3trace_magic_line1)) != 0 ||\r\nstrncmp(dct3trace_magic_line2, line2, strlen(dct3trace_magic_line2)) != 0)\r\n{\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nwth->file_encap = WTAP_ENCAP_GSM_UM;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_DCT3TRACE;\r\nwth->snapshot_length = 0;\r\nwth->subtype_read = dct3trace_read;\r\nwth->subtype_seek_read = dct3trace_seek_read;\r\nwth->file_tsprec = WTAP_TSPREC_SEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean dct3trace_get_packet(FILE_T fh, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nchar line[1024];\r\nguint8 databuf[MAX_PACKET_LEN], *bufp;\r\ngboolean have_data = FALSE;\r\nint len = 0;\r\nbufp = &databuf[0];\r\nwhile (file_gets(line, sizeof(line), fh) != NULL)\r\n{\r\nif( memcmp(dct3trace_magic_end, line, strlen(dct3trace_magic_end)) == 0 )\r\n{\r\n*err = 0;\r\nreturn FALSE;\r\n}\r\nelse if( memcmp(dct3trace_magic_record_end, line, strlen(dct3trace_magic_record_end)) == 0 )\r\n{\r\nif( have_data )\r\n{\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = 0;\r\nphdr->ts.secs = 0;\r\nphdr->ts.nsecs = 0;\r\nphdr->caplen = len;\r\nphdr->len = len;\r\n*err = 0;\r\nws_buffer_assure_space(buf, phdr->caplen);\r\nmemcpy( ws_buffer_start_ptr(buf), databuf, phdr->caplen );\r\nreturn TRUE;\r\n}\r\nelse\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("dct3trace: record without data");\r\nreturn FALSE;\r\n}\r\n}\r\nelse if( memcmp(dct3trace_magic_record_start, line, strlen(dct3trace_magic_record_start)) == 0 )\r\n{\r\nint channel, tmp;\r\nchar *ptr;\r\nphdr->pseudo_header.gsm_um.uplink = !strstr(line, "direction=\"down\"");\r\nif (xml_get_int(&channel, line, "logicalchannel") != 0)\r\ngoto baddata;\r\nif( !phdr->pseudo_header.gsm_um.uplink )\r\n{\r\nif (xml_get_int(&tmp, line, "physicalchannel") != 0)\r\ngoto baddata;\r\nphdr->pseudo_header.gsm_um.arfcn = tmp;\r\nif (xml_get_int(&tmp, line, "sequence") != 0)\r\ngoto baddata;\r\nphdr->pseudo_header.gsm_um.tdma_frame = tmp;\r\nif (xml_get_int(&tmp, line, "bsic") != 0)\r\ngoto baddata;\r\nphdr->pseudo_header.gsm_um.bsic = tmp;\r\nif (xml_get_int(&tmp, line, "error") != 0)\r\ngoto baddata;\r\nphdr->pseudo_header.gsm_um.error = tmp;\r\nif (xml_get_int(&tmp, line, "timeshift") != 0)\r\ngoto baddata;\r\nphdr->pseudo_header.gsm_um.timeshift = tmp;\r\n}\r\nswitch( channel )\r\n{\r\ncase 128: phdr->pseudo_header.gsm_um.channel = GSM_UM_CHANNEL_SDCCH; break;\r\ncase 112: phdr->pseudo_header.gsm_um.channel = GSM_UM_CHANNEL_SACCH; break;\r\ncase 176: phdr->pseudo_header.gsm_um.channel = GSM_UM_CHANNEL_FACCH; break;\r\ncase 96: phdr->pseudo_header.gsm_um.channel = GSM_UM_CHANNEL_CCCH; break;\r\ncase 80: phdr->pseudo_header.gsm_um.channel = GSM_UM_CHANNEL_BCCH; break;\r\ndefault: phdr->pseudo_header.gsm_um.channel = GSM_UM_CHANNEL_UNKNOWN; break;\r\n}\r\nptr = strstr(line, "data=\"");\r\nif( ptr )\r\n{\r\nhave_data = TRUE;\r\nlen = hex2bin(bufp, &databuf[MAX_PACKET_LEN], ptr+6);\r\nif (len == -1)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("dct3trace: record length %d too long", phdr->caplen);\r\nreturn FALSE;\r\n}\r\n}\r\n}\r\nelse if( !have_data && memcmp(dct3trace_magic_l2_start, line, strlen(dct3trace_magic_l2_start)) == 0 )\r\n{\r\nint data_len;\r\nchar *ptr = strstr(line, "data=\"");\r\nif( !ptr )\r\n{\r\ncontinue;\r\n}\r\nhave_data = TRUE;\r\nif( phdr->pseudo_header.gsm_um.channel == GSM_UM_CHANNEL_SACCH || phdr->pseudo_header.gsm_um.channel == GSM_UM_CHANNEL_FACCH || phdr->pseudo_header.gsm_um.channel == GSM_UM_CHANNEL_SDCCH )\r\n{\r\nmemset(bufp, 0x1, 2);\r\nlen = 3;\r\n}\r\nelse\r\n{\r\nlen = 1;\r\n}\r\nbufp += len;\r\ndata_len = hex2bin(bufp, &databuf[MAX_PACKET_LEN], ptr+6);\r\nif (data_len == -1)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("dct3trace: record length %d too long", phdr->caplen);\r\nreturn FALSE;\r\n}\r\nlen += data_len;\r\n*(bufp - 1) = data_len << 2 | 0x1;\r\n}\r\n}\r\n*err = file_error(fh, err_info);\r\nif (*err == 0)\r\n{\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn FALSE;\r\nbaddata:\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("dct3trace: record missing mandatory attributes");\r\nreturn FALSE;\r\n}\r\nstatic gboolean dct3trace_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\n*data_offset = file_tell(wth->fh);\r\nreturn dct3trace_get_packet(wth->fh, &wth->phdr, wth->frame_buffer,\r\nerr, err_info);\r\n}\r\nstatic gboolean dct3trace_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\n{\r\nreturn FALSE;\r\n}\r\nreturn dct3trace_get_packet(wth->random_fh, phdr, buf, err, err_info);\r\n}
