static int\r\ndissect_bmControl(proto_tree *tree, tvbuff_t *tvb, int offset,\r\ngint ett_subtree, const int** bm_items)\r\n{\r\nguint8 bm_size = 0;\r\nbm_size = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_usb_vid_bControlSize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n++offset;\r\nif (bm_size > 0)\r\n{\r\nproto_tree_add_bitmask_len(tree, tvb, offset, bm_size, hf_usb_vid_bmControl,\r\nett_subtree, bm_items, &ei_usb_vid_bitmask_len, ENC_LITTLE_ENDIAN);\r\noffset += bm_size;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_usb_video_camera_terminal(proto_tree *tree, tvbuff_t *tvb, int offset)\r\n{\r\nstatic const int *control_bits[] = {\r\n&hf_usb_vid_cam_control_D[0],\r\n&hf_usb_vid_cam_control_D[1],\r\n&hf_usb_vid_cam_control_D[2],\r\n&hf_usb_vid_cam_control_D[3],\r\n&hf_usb_vid_cam_control_D[4],\r\n&hf_usb_vid_cam_control_D[5],\r\n&hf_usb_vid_cam_control_D[6],\r\n&hf_usb_vid_cam_control_D[7],\r\n&hf_usb_vid_cam_control_D[8],\r\n&hf_usb_vid_cam_control_D[9],\r\n&hf_usb_vid_cam_control_D[10],\r\n&hf_usb_vid_cam_control_D[11],\r\n&hf_usb_vid_cam_control_D[12],\r\n&hf_usb_vid_cam_control_D[13],\r\n&hf_usb_vid_cam_control_D[14],\r\n&hf_usb_vid_cam_control_D[15],\r\n&hf_usb_vid_cam_control_D[16],\r\n&hf_usb_vid_cam_control_D[17],\r\n&hf_usb_vid_cam_control_D[18],\r\n&hf_usb_vid_cam_control_D[19],\r\n&hf_usb_vid_cam_control_D[20],\r\n&hf_usb_vid_cam_control_D[21],\r\nNULL\r\n};\r\nDISSECTOR_ASSERT(array_length(control_bits) == (1+array_length(hf_usb_vid_cam_control_D)));\r\nproto_tree_add_item(tree, hf_usb_vid_cam_objective_focal_len_min, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_usb_vid_cam_objective_focal_len_max, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_usb_vid_cam_ocular_focal_len, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\noffset = dissect_bmControl(tree, tvb, offset, ett_camera_controls, control_bits);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_usb_video_processing_unit(proto_tree *tree, tvbuff_t *tvb, int offset)\r\n{\r\nstatic const int *control_bits[] = {\r\n&hf_usb_vid_proc_control_D[0],\r\n&hf_usb_vid_proc_control_D[1],\r\n&hf_usb_vid_proc_control_D[2],\r\n&hf_usb_vid_proc_control_D[3],\r\n&hf_usb_vid_proc_control_D[4],\r\n&hf_usb_vid_proc_control_D[5],\r\n&hf_usb_vid_proc_control_D[6],\r\n&hf_usb_vid_proc_control_D[7],\r\n&hf_usb_vid_proc_control_D[8],\r\n&hf_usb_vid_proc_control_D[9],\r\n&hf_usb_vid_proc_control_D[10],\r\n&hf_usb_vid_proc_control_D[11],\r\n&hf_usb_vid_proc_control_D[12],\r\n&hf_usb_vid_proc_control_D[13],\r\n&hf_usb_vid_proc_control_D[14],\r\n&hf_usb_vid_proc_control_D[15],\r\n&hf_usb_vid_proc_control_D[16],\r\n&hf_usb_vid_proc_control_D[17],\r\n&hf_usb_vid_proc_control_D[18],\r\nNULL\r\n};\r\nDISSECTOR_ASSERT(array_length(control_bits) == (1+array_length(hf_usb_vid_proc_control_D)));\r\nproto_tree_add_item(tree, hf_usb_vid_control_ifdesc_src_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_max_multiplier, tvb, offset+1, 2, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\noffset = dissect_bmControl(tree, tvb, offset, ett_processing_controls, control_bits);\r\nproto_tree_add_item(tree, hf_usb_vid_iProcessing, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n++offset;\r\nif (tvb_reported_length_remaining(tvb, offset) > 0)\r\n{\r\nstatic const int *standard_bits[] = {\r\n&hf_usb_vid_proc_standards_D[0],\r\n&hf_usb_vid_proc_standards_D[1],\r\n&hf_usb_vid_proc_standards_D[2],\r\n&hf_usb_vid_proc_standards_D[3],\r\n&hf_usb_vid_proc_standards_D[4],\r\n&hf_usb_vid_proc_standards_D[5],\r\nNULL\r\n};\r\nDISSECTOR_ASSERT(array_length(standard_bits) == (1+array_length(hf_usb_vid_proc_standards_D)));\r\nproto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_proc_standards,\r\nett_video_standards, standard_bits, ENC_NA);\r\n++offset;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_usb_video_selector_unit(proto_tree *tree, tvbuff_t *tvb, int offset)\r\n{\r\nguint8 num_inputs;\r\nnum_inputs = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_usb_vid_num_inputs, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n++offset;\r\nif (num_inputs > 0)\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_sources, tvb, offset, num_inputs, ENC_NA);\r\noffset += num_inputs;\r\n}\r\nproto_tree_add_item(tree, hf_usb_vid_iSelector, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n++offset;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_usb_video_extension_unit(proto_tree *tree, tvbuff_t *tvb, int offset)\r\n{\r\nguint8 num_inputs;\r\nguint8 control_size;\r\nproto_tree_add_item(tree, hf_usb_vid_exten_guid, tvb, offset, 16, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_exten_num_controls, tvb, offset+16, 1, ENC_LITTLE_ENDIAN);\r\noffset += 17;\r\nnum_inputs = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_usb_vid_num_inputs, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n++offset;\r\nif (num_inputs > 0)\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_sources, tvb, offset, num_inputs, ENC_NA);\r\noffset += num_inputs;\r\n}\r\ncontrol_size = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_usb_vid_bControlSize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n++offset;\r\nif (control_size > 0)\r\n{\r\nif (control_size <= proto_registrar_get_length(hf_usb_vid_bmControl))\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_bmControl, tvb, offset, control_size,\r\nENC_LITTLE_ENDIAN);\r\n}\r\nelse\r\n{\r\nproto_tree_add_bytes_format(tree, hf_usb_vid_bmControl_bytes, tvb, offset, control_size, NULL, "bmControl");\r\n}\r\noffset += control_size;\r\n}\r\nproto_tree_add_item(tree, hf_usb_vid_iExtension, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n++offset;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,\r\nguint8 descriptor_len, packet_info *pinfo, usb_conv_info_t *usb_conv_info)\r\n{\r\nvideo_conv_info_t *video_conv_info = NULL;\r\nvideo_entity_t *entity = NULL;\r\nproto_item *item = NULL;\r\nproto_item *subtype_item = NULL;\r\nproto_tree *tree = NULL;\r\nguint8 entity_id = 0;\r\nguint16 terminal_type = 0;\r\nint offset = 0;\r\nguint8 subtype;\r\nsubtype = tvb_get_guint8(tvb, offset+2);\r\nif (parent_tree)\r\n{\r\nconst gchar *subtype_str;\r\nsubtype_str = val_to_str_ext(subtype, &vc_if_descriptor_subtypes_ext, "Unknown (0x%x)");\r\ntree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,\r\nett_descriptor_video_control, &item, "VIDEO CONTROL INTERFACE DESCRIPTOR [%s]",\r\nsubtype_str);\r\n}\r\ndissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);\r\nsubtype_item = proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\nif (subtype == VC_HEADER)\r\n{\r\nguint8 num_vs_interfaces;\r\nproto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bcdUVC, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_ifdesc_wTotalLength, tvb, offset+2, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_control_ifdesc_dwClockFrequency, tvb, offset+4, 4, ENC_LITTLE_ENDIAN);\r\nnum_vs_interfaces = tvb_get_guint8(tvb, offset+8);\r\nproto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bInCollection, tvb, offset+8, 1, ENC_LITTLE_ENDIAN);\r\nif (num_vs_interfaces > 0)\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_control_ifdesc_baInterfaceNr, tvb, offset+9, num_vs_interfaces, ENC_NA);\r\n}\r\noffset += 9 + num_vs_interfaces;\r\n}\r\nelse if ((subtype == VC_INPUT_TERMINAL) || (subtype == VC_OUTPUT_TERMINAL))\r\n{\r\nentity_id = tvb_get_guint8(tvb, offset);\r\nterminal_type = tvb_get_letohs(tvb, offset+1);\r\nproto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_type, tvb, offset+1, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_control_ifdesc_assoc_terminal, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nif (subtype == VC_OUTPUT_TERMINAL)\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_control_ifdesc_src_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n++offset;\r\n}\r\nproto_tree_add_item(tree, hf_usb_vid_control_ifdesc_iTerminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n++offset;\r\nif (subtype == VC_INPUT_TERMINAL)\r\n{\r\nif (terminal_type == ITT_CAMERA)\r\n{\r\noffset = dissect_usb_video_camera_terminal(tree, tvb, offset);\r\n}\r\nelse if (terminal_type == ITT_MEDIA_TRANSPORT_INPUT)\r\n{\r\n}\r\n}\r\nif (subtype == VC_OUTPUT_TERMINAL)\r\n{\r\nif (terminal_type == OTT_MEDIA_TRANSPORT_OUTPUT)\r\n{\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nentity_id = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_usb_vid_control_ifdesc_unit_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n++offset;\r\nif (subtype == VC_PROCESSING_UNIT)\r\n{\r\noffset = dissect_usb_video_processing_unit(tree, tvb, offset);\r\n}\r\nelse if (subtype == VC_SELECTOR_UNIT)\r\n{\r\noffset = dissect_usb_video_selector_unit(tree, tvb, offset);\r\n}\r\nelse if (subtype == VC_EXTENSION_UNIT)\r\n{\r\noffset = dissect_usb_video_extension_unit(tree, tvb, offset);\r\n}\r\nelse if (subtype == VC_ENCODING_UNIT)\r\n{\r\n}\r\nelse\r\n{\r\nexpert_add_info_format(pinfo, subtype_item, &ei_usb_vid_subtype_unknown,\r\n"Unknown VC subtype %u", subtype);\r\n}\r\n}\r\nif (offset < descriptor_len)\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);\r\n}\r\nif (entity_id != 0)\r\nproto_item_append_text(item, " (Entity %d)", entity_id);\r\nif (subtype != VC_HEADER && usb_conv_info)\r\n{\r\nusb_conv_info = get_usb_iface_conv_info(pinfo, usb_conv_info->interfaceNum);\r\nvideo_conv_info = (video_conv_info_t *)usb_conv_info->class_data;\r\nif (!video_conv_info)\r\n{\r\nvideo_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);\r\nvideo_conv_info->entities = wmem_tree_new(wmem_file_scope());\r\nusb_conv_info->class_data = video_conv_info;\r\nusb_conv_info->class_data_type = USB_CONV_VIDEO;\r\n} else if (usb_conv_info->class_data_type != USB_CONV_VIDEO) {\r\nreturn descriptor_len;\r\n}\r\nentity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);\r\nif (!entity)\r\n{\r\nentity = wmem_new(wmem_file_scope(), video_entity_t);\r\nentity->entityID = entity_id;\r\nentity->subtype = subtype;\r\nentity->terminalType = terminal_type;\r\nwmem_tree_insert32(video_conv_info->entities, entity_id, entity);\r\n}\r\n}\r\nreturn descriptor_len;\r\n}\r\nstatic int\r\ndissect_usb_video_streaming_input_header(proto_tree *tree, tvbuff_t *tvb, int offset)\r\n{\r\nguint8 num_formats;\r\nguint8 bm_size;\r\nstatic const int *info_bits[] = {\r\n&hf_usb_vid_streaming_info_D[0],\r\nNULL\r\n};\r\nstatic const int *control_bits[] = {\r\n&hf_usb_vid_streaming_control_D[0],\r\n&hf_usb_vid_streaming_control_D[1],\r\n&hf_usb_vid_streaming_control_D[2],\r\n&hf_usb_vid_streaming_control_D[3],\r\n&hf_usb_vid_streaming_control_D[4],\r\n&hf_usb_vid_streaming_control_D[5],\r\nNULL\r\n};\r\nDISSECTOR_ASSERT(array_length(control_bits) == (1+array_length(hf_usb_vid_streaming_control_D)));\r\nnum_formats = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_usb_vid_streaming_ifdesc_bNumFormats, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_ifdesc_wTotalLength, tvb, offset+1, 2, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\ndissect_usb_endpoint_address(tree, tvb, offset);\r\noffset++;\r\nproto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_streaming_bmInfo,\r\nett_streaming_info, info_bits, ENC_NA);\r\nproto_tree_add_item(tree, hf_usb_vid_streaming_terminal_link, tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_streaming_still_capture_method, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\nproto_tree_add_item(tree, hf_usb_vid_streaming_trigger_support, tvb, offset, 1, ENC_NA);\r\nif (tvb_get_guint8(tvb, offset) > 0)\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_streaming_trigger_usage, tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nelse\r\n{\r\nproto_tree_add_uint_format_value(tree, hf_usb_vid_streaming_trigger_usage, tvb, offset+1, 1, 0, "Not applicable");\r\n}\r\noffset += 2;\r\nbm_size = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_usb_vid_bControlSize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n++offset;\r\nif (bm_size > 0)\r\n{\r\nguint8 i;\r\nfor (i=0; i<num_formats; ++i)\r\n{\r\nproto_tree_add_bitmask_len(tree, tvb, offset, bm_size, hf_usb_vid_bmControl,\r\nett_streaming_controls, control_bits, &ei_usb_vid_bitmask_len,\r\nENC_LITTLE_ENDIAN);\r\noffset += bm_size;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_usb_video_format(proto_tree *tree, tvbuff_t *tvb, int offset,\r\nguint8 subtype)\r\n{\r\nstatic const int *interlace_bits[] = {\r\n&hf_usb_vid_is_interlaced,\r\n&hf_usb_vid_interlaced_fields,\r\n&hf_usb_vid_field_1_first,\r\n&hf_usb_vid_field_pattern,\r\nNULL\r\n};\r\nproto_item *desc_item;\r\nguint8 format_index;\r\nformat_index = tvb_get_guint8(tvb, offset);\r\ndesc_item = proto_tree_get_parent(tree);\r\nproto_item_append_text(desc_item, " (Format %u)", format_index);\r\nproto_tree_add_item(tree, hf_usb_vid_format_index, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_format_num_frame_descriptors, tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nif ((subtype == VS_FORMAT_UNCOMPRESSED) || (subtype == VS_FORMAT_FRAME_BASED))\r\n{\r\nchar fourcc[5];\r\ntvb_memcpy(tvb, (guint8 *)fourcc, offset, 4);\r\nfourcc[4] = '\0';\r\nproto_item_append_text(desc_item, ": %s", fourcc);\r\nproto_tree_add_item(tree, hf_usb_vid_format_guid, tvb, offset, 16, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_format_bits_per_pixel, tvb, offset+16, 1, ENC_LITTLE_ENDIAN);\r\noffset += 17;\r\n}\r\nelse if (subtype == VS_FORMAT_MJPEG)\r\n{\r\nstatic const int * flags[] = {\r\n&hf_usb_vid_mjpeg_fixed_samples,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_mjpeg_flags, ett_mjpeg_flags, flags, ENC_NA);\r\noffset++;\r\n}\r\nelse\r\n{\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\n}\r\nproto_tree_add_item(tree, hf_usb_vid_default_frame_index, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_aspect_ratio_x, tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_aspect_ratio_y, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\n#if 0\r\nif (something)\r\nproto_tree_add_uint_format_value(tree, hf_usb_vid_interlace_flags, tvb, offset, 1, tvb_get_guint8(tvb, offset), "Not applicable");\r\n#endif\r\nproto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_interlace_flags,\r\nett_interlace_flags, interlace_bits, ENC_NA);\r\noffset++;\r\nproto_tree_add_item(tree, hf_usb_vid_copy_protect, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\nif (subtype == VS_FORMAT_FRAME_BASED)\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_variable_size, tvb, offset, 1, ENC_NA);\r\noffset++;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_usb_video_frame(proto_tree *tree, tvbuff_t *tvb, int offset,\r\nguint8 subtype)\r\n{\r\nstatic const int *capability_bits[] = {\r\n&hf_usb_vid_frame_stills_supported,\r\n&hf_usb_vid_frame_fixed_frame_rate,\r\nNULL\r\n};\r\nproto_item *desc_item;\r\nguint8 bFrameIntervalType;\r\nguint8 frame_index;\r\nguint16 frame_width;\r\nguint16 frame_height;\r\nframe_index = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_usb_vid_frame_index, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\nproto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_frame_capabilities,\r\nett_frame_capability_flags, capability_bits, ENC_NA);\r\noffset++;\r\nproto_tree_add_item(tree, hf_usb_vid_frame_width, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_frame_height, tvb, offset+2, 2, ENC_LITTLE_ENDIAN);\r\nframe_width = tvb_get_letohs(tvb, offset);\r\nframe_height = tvb_get_letohs(tvb, offset+2);\r\ndesc_item = proto_tree_get_parent(tree);\r\nproto_item_append_text(desc_item, " (Index %2u): %4u x %4u", frame_index, frame_width, frame_height);\r\nproto_tree_add_item(tree, hf_usb_vid_frame_min_bit_rate, tvb, offset+4, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_frame_max_bit_rate, tvb, offset+8, 4, ENC_LITTLE_ENDIAN);\r\noffset += 12;\r\nif (subtype != VS_FRAME_FRAME_BASED)\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_frame_max_frame_sz, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\n}\r\nproto_tree_add_item(tree, hf_usb_vid_frame_default_interval, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbFrameIntervalType = tvb_get_guint8(tvb, offset);\r\nif (bFrameIntervalType == 0)\r\n{\r\nproto_tree_add_uint_format_value(tree, hf_usb_vid_frame_interval_type, tvb, offset, 1,\r\nbFrameIntervalType, "Continuous (0)");\r\noffset++;\r\nif (subtype == VS_FRAME_FRAME_BASED)\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_frame_bytes_per_line, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\n}\r\nproto_tree_add_item(tree, hf_usb_vid_frame_min_interval, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_frame_max_interval, tvb, offset+4, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_frame_step_interval, tvb, offset+8, 4, ENC_LITTLE_ENDIAN);\r\noffset += 12;\r\n}\r\nelse\r\n{\r\nguint8 i;\r\nproto_tree_add_uint_format_value(tree, hf_usb_vid_frame_interval_type, tvb, offset, 1,\r\nbFrameIntervalType, "Discrete (%u choice%s)",\r\nbFrameIntervalType, (bFrameIntervalType > 1) ? "s" : "");\r\noffset++;\r\nif (subtype == VS_FRAME_FRAME_BASED)\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_frame_bytes_per_line, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\n}\r\nfor (i=0; i<bFrameIntervalType; ++i)\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_frame_interval, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_usb_video_colorformat(proto_tree *tree, tvbuff_t *tvb, int offset)\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_color_primaries, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_transfer_characteristics, tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_matrix_coefficients, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\r\noffset +=3;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_usb_video_streaming_interface_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,\r\nguint8 descriptor_len)\r\n{\r\nproto_tree *tree;\r\nint offset = 0;\r\nconst gchar *subtype_str;\r\nguint8 subtype;\r\nsubtype = tvb_get_guint8(tvb, offset+2);\r\nsubtype_str = val_to_str_ext(subtype, &vs_if_descriptor_subtypes_ext, "Unknown (0x%x)");\r\ntree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,\r\nett_descriptor_video_streaming, NULL, "VIDEO STREAMING INTERFACE DESCRIPTOR [%s]",\r\nsubtype_str);\r\ndissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);\r\nproto_tree_add_item(tree, hf_usb_vid_streaming_ifdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\nswitch (subtype)\r\n{\r\ncase VS_INPUT_HEADER:\r\noffset = dissect_usb_video_streaming_input_header(tree, tvb, offset);\r\nbreak;\r\ncase VS_FORMAT_UNCOMPRESSED:\r\ncase VS_FORMAT_MJPEG:\r\ncase VS_FORMAT_FRAME_BASED:\r\noffset = dissect_usb_video_format(tree, tvb, offset, subtype);\r\nbreak;\r\ncase VS_FRAME_UNCOMPRESSED:\r\ncase VS_FRAME_MJPEG:\r\ncase VS_FRAME_FRAME_BASED:\r\noffset = dissect_usb_video_frame(tree, tvb, offset, subtype);\r\nbreak;\r\ncase VS_COLORFORMAT:\r\noffset = dissect_usb_video_colorformat(tree, tvb, offset);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (offset < descriptor_len)\r\nproto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);\r\nreturn descriptor_len;\r\n}\r\nstatic int\r\ndissect_usb_video_endpoint_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,\r\nguint8 descriptor_len)\r\n{\r\nproto_tree *tree = NULL;\r\nint offset = 0;\r\nguint8 subtype;\r\nsubtype = tvb_get_guint8(tvb, offset+2);\r\nif (parent_tree)\r\n{\r\nconst gchar* subtype_str;\r\nsubtype_str = val_to_str(subtype, vc_ep_descriptor_subtypes, "Unknown (0x%x)");\r\ntree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,\r\nett_descriptor_video_endpoint, NULL, "VIDEO CONTROL ENDPOINT DESCRIPTOR [%s]",\r\nsubtype_str);\r\n}\r\ndissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);\r\nproto_tree_add_item(tree, hf_usb_vid_epdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\nif (subtype == EP_INTERRUPT)\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_epdesc_max_transfer_sz, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\n}\r\nif (offset < descriptor_len)\r\nproto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);\r\nreturn descriptor_len;\r\n}\r\nstatic int\r\ndissect_usb_vid_descriptor(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nint offset = 0;\r\nguint8 descriptor_len;\r\nguint8 descriptor_type;\r\ngint bytes_available;\r\nusb_conv_info_t *usb_conv_info = (usb_conv_info_t *)data;\r\ntvbuff_t *desc_tvb;\r\ndescriptor_len = tvb_get_guint8(tvb, offset);\r\ndescriptor_type = tvb_get_guint8(tvb, offset+1);\r\nbytes_available = tvb_captured_length_remaining(tvb, offset);\r\ndesc_tvb = tvb_new_subset(tvb, 0, bytes_available, descriptor_len);\r\nif (descriptor_type == CS_ENDPOINT)\r\n{\r\noffset = dissect_usb_video_endpoint_descriptor(tree, desc_tvb,\r\ndescriptor_len);\r\n}\r\nelse if (descriptor_type == CS_INTERFACE)\r\n{\r\nif (usb_conv_info && usb_conv_info->interfaceSubclass == SC_VIDEOCONTROL)\r\n{\r\noffset = dissect_usb_video_control_interface_descriptor(tree, desc_tvb,\r\ndescriptor_len,\r\npinfo, usb_conv_info);\r\n}\r\nelse if (usb_conv_info && usb_conv_info->interfaceSubclass == SC_VIDEOSTREAMING)\r\n{\r\noffset = dissect_usb_video_streaming_interface_descriptor(tree, desc_tvb,\r\ndescriptor_len);\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_usb_vid_probe(proto_tree *parent_tree, tvbuff_t *tvb, int offset)\r\n{\r\nproto_tree *tree;\r\nstatic const int *hint_bits[] = {\r\n&hf_usb_vid_probe_hint_D[0],\r\n&hf_usb_vid_probe_hint_D[1],\r\n&hf_usb_vid_probe_hint_D[2],\r\n&hf_usb_vid_probe_hint_D[3],\r\n&hf_usb_vid_probe_hint_D[4],\r\nNULL\r\n};\r\nDISSECTOR_ASSERT(array_length(hint_bits) == (1+array_length(hf_usb_vid_probe_hint_D)));\r\ntree = proto_tree_add_subtree(parent_tree, tvb, offset, -1, ett_video_probe, NULL, "Probe/Commit Info");\r\nproto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_probe_hint,\r\nett_probe_hint, hint_bits, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_format_index, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_frame_index, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_frame_interval, tvb, offset+4, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_probe_key_frame_rate, tvb, offset+8, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_probe_p_frame_rate, tvb, offset+10, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_probe_comp_quality, tvb, offset+12, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_probe_comp_window, tvb, offset+14, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_probe_delay, tvb, offset+16, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_probe_max_frame_sz, tvb, offset+18, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_probe_max_payload_sz, tvb, offset+22, 4, ENC_LITTLE_ENDIAN);\r\noffset += 26;\r\nif (tvb_reported_length_remaining(tvb, offset) > 0)\r\n{\r\nstatic const int *framing_bits[] = {\r\n&hf_usb_vid_probe_framing_D[0],\r\n&hf_usb_vid_probe_framing_D[1],\r\nNULL\r\n};\r\nDISSECTOR_ASSERT(array_length(framing_bits) == (1+array_length(hf_usb_vid_probe_framing_D)));\r\nproto_tree_add_item(tree, hf_usb_vid_probe_clock_freq, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_probe_framing,\r\nett_probe_framing, framing_bits, ENC_NA);\r\noffset++;\r\nproto_tree_add_item(tree, hf_usb_vid_probe_preferred_ver, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_probe_min_ver, tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_usb_vid_probe_max_ver, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\n}\r\nreturn offset;\r\n}\r\nstatic value_string_ext*\r\nget_control_selector_values(guint8 entity_id, usb_conv_info_t *usb_conv_info)\r\n{\r\nvideo_conv_info_t *video_conv_info;\r\nvideo_entity_t *entity = NULL;\r\nvalue_string_ext *selectors = NULL;\r\nif (usb_conv_info == NULL)\r\nreturn NULL;\r\nvideo_conv_info = (video_conv_info_t *)usb_conv_info->class_data;\r\nif (video_conv_info)\r\nentity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);\r\nif (entity_id == 0)\r\n{\r\nswitch (usb_conv_info->interfaceSubclass)\r\n{\r\ncase SC_VIDEOCONTROL:\r\nselectors = &cs_control_interface_ext;\r\nbreak;\r\ncase SC_VIDEOSTREAMING:\r\nselectors = &cs_streaming_interface_ext;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nelse if (entity)\r\n{\r\nswitch (entity->subtype)\r\n{\r\ncase VC_INPUT_TERMINAL:\r\nif (entity->terminalType == ITT_CAMERA)\r\n{\r\nselectors = &cs_camera_terminal_ext;\r\n}\r\nbreak;\r\ncase VC_PROCESSING_UNIT:\r\nselectors = &cs_processing_unit_ext;\r\nbreak;\r\ncase VC_SELECTOR_UNIT:\r\nselectors = &cs_selector_unit_ext;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn selectors;\r\n}\r\nstatic const gchar*\r\nget_control_selector_name(guint8 entity_id, guint8 control_sel, usb_conv_info_t *usb_conv_info)\r\n{\r\nconst gchar *control_name = NULL;\r\nvalue_string_ext *selectors = NULL;\r\nselectors = get_control_selector_values(entity_id, usb_conv_info);\r\nif (selectors)\r\ncontrol_name = try_val_to_str_ext(control_sel, selectors);\r\nreturn control_name;\r\n}\r\nstatic int\r\ndissect_usb_vid_control_info(proto_tree *tree, tvbuff_t *tvb, int offset)\r\n{\r\nstatic const int *capability_bits[] = {\r\n&hf_usb_vid_control_info_D[0],\r\n&hf_usb_vid_control_info_D[1],\r\n&hf_usb_vid_control_info_D[2],\r\n&hf_usb_vid_control_info_D[3],\r\n&hf_usb_vid_control_info_D[4],\r\n&hf_usb_vid_control_info_D[5],\r\n&hf_usb_vid_control_info_D[6],\r\nNULL\r\n};\r\nDISSECTOR_ASSERT(array_length(capability_bits) == (1+array_length(hf_usb_vid_control_info_D)));\r\nproto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_control_info,\r\nett_control_capabilities, capability_bits, ENC_NA);\r\nreturn offset+1;\r\n}\r\nstatic void\r\ndissect_usb_vid_control_value(proto_tree *tree, tvbuff_t *tvb, int offset, guint8 request)\r\n{\r\ngint value_size;\r\nconst char *fallback_name;\r\nint hf;\r\nswitch (request)\r\n{\r\ncase USB_SETUP_GET_DEF:\r\nhf = hf_usb_vid_control_default;\r\nfallback_name = "Default Value";\r\nbreak;\r\ncase USB_SETUP_GET_MIN:\r\ncase CONTROL_CHANGE_MIN:\r\nhf = hf_usb_vid_control_min;\r\nfallback_name = "Min Value";\r\nbreak;\r\ncase USB_SETUP_GET_MAX:\r\ncase CONTROL_CHANGE_MAX:\r\nhf = hf_usb_vid_control_max;\r\nfallback_name = "Max Value";\r\nbreak;\r\ncase USB_SETUP_GET_RES:\r\nhf = hf_usb_vid_control_res;\r\nfallback_name = "Resolution";\r\nbreak;\r\ncase USB_SETUP_GET_CUR:\r\ncase USB_SETUP_SET_CUR:\r\ncase CONTROL_CHANGE_VALUE:\r\nhf = hf_usb_vid_control_cur;\r\nfallback_name = "Current Value";\r\nbreak;\r\ndefault:\r\nhf = -1;\r\nfallback_name = "Value";\r\nbreak;\r\n}\r\nvalue_size = tvb_reported_length_remaining(tvb, offset);\r\nif (hf != -1)\r\n{\r\nheader_field_info *hfinfo;\r\nhfinfo = proto_registrar_get_nth(hf);\r\nDISSECTOR_ASSERT(IS_FT_INT(hfinfo->type) || IS_FT_UINT(hfinfo->type));\r\n}\r\nif ((hf != -1) && (value_size <= 4))\r\n{\r\nproto_tree_add_item(tree, hf, tvb, offset, value_size, ENC_LITTLE_ENDIAN);\r\n}\r\nelse\r\n{\r\nproto_tree_add_bytes_format(tree, hf_usb_vid_control_value, tvb, offset, value_size, NULL, "%s", fallback_name);\r\n}\r\n}\r\nstatic int\r\ndissect_usb_vid_get_set(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\r\nint offset, gboolean is_request,\r\nusb_trans_info_t *usb_trans_info,\r\nusb_conv_info_t *usb_conv_info)\r\n{\r\nconst gchar *short_name = NULL;\r\nguint8 control_sel;\r\nguint8 entity_id;\r\nentity_id = usb_trans_info->setup.wIndex >> 8;\r\ncontrol_sel = usb_trans_info->setup.wValue >> 8;\r\ncol_append_str(pinfo->cinfo, COL_INFO, " [");\r\nshort_name = get_control_selector_name(entity_id, control_sel, usb_conv_info);\r\nif (short_name)\r\ncol_append_str(pinfo->cinfo, COL_INFO, short_name);\r\nelse\r\n{\r\nshort_name = "Unknown";\r\nif (entity_id == 0)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Interface %u control 0x%x",\r\nusb_conv_info->interfaceNum, control_sel);\r\n}\r\nelse\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Unit %u control 0x%x",\r\nentity_id, control_sel);\r\n}\r\n}\r\ncol_append_str(pinfo->cinfo, COL_INFO, "]");\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\nif (is_request)\r\n{\r\noffset++;\r\nproto_tree_add_uint_format_value(tree, hf_usb_vid_control_selector, tvb,\r\noffset, 1, control_sel, "%s (0x%02x)", short_name, control_sel);\r\noffset++;\r\nproto_tree_add_item(tree, hf_usb_vid_control_interface, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(tree, hf_usb_vid_control_entity, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(tree, hf_usb_vid_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\n}\r\nelse\r\n{\r\nproto_item *ti;\r\nti = proto_tree_add_uint(tree, hf_usb_vid_control_interface, tvb, 0, 0,\r\nusb_trans_info->setup.wIndex & 0xFF);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nti = proto_tree_add_uint(tree, hf_usb_vid_control_entity, tvb, 0, 0, entity_id);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nti = proto_tree_add_uint_format_value(tree, hf_usb_vid_control_selector, tvb,\r\n0, 0, control_sel, "%s (0x%02x)", short_name, control_sel);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\n}\r\nif (!is_request || (usb_trans_info->setup.request == USB_SETUP_SET_CUR))\r\n{\r\ngint value_size = tvb_reported_length_remaining(tvb, offset);\r\nif (value_size != 0)\r\n{\r\nif ((entity_id == 0) && (usb_conv_info->interfaceSubclass == SC_VIDEOSTREAMING))\r\n{\r\nif ((control_sel == VS_PROBE_CONTROL) || (control_sel == VS_COMMIT_CONTROL))\r\n{\r\nint old_offset = offset;\r\noffset = dissect_usb_vid_probe(tree, tvb, offset);\r\nvalue_size -= (offset - old_offset);\r\n}\r\n}\r\nelse\r\n{\r\nif (usb_trans_info->setup.request == USB_SETUP_GET_INFO)\r\n{\r\ndissect_usb_vid_control_info(tree, tvb, offset);\r\noffset++;\r\nvalue_size--;\r\n}\r\nelse if (usb_trans_info->setup.request == USB_SETUP_GET_LEN)\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_control_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nvalue_size -= 2;\r\n}\r\nelse if ( (usb_trans_info->setup.request == USB_SETUP_GET_CUR)\r\n&& (entity_id == 0)\r\n&& (usb_conv_info->interfaceSubclass == SC_VIDEOCONTROL)\r\n&& (control_sel == VC_REQUEST_ERROR_CODE_CONTROL))\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_request_error, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\nvalue_size--;\r\n}\r\nelse\r\n{\r\ndissect_usb_vid_control_value(tree, tvb, offset, usb_trans_info->setup.request);\r\noffset += value_size;\r\nvalue_size = 0;\r\n}\r\n}\r\nif (value_size > 0)\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_control_data, tvb, offset, -1, ENC_NA);\r\noffset += value_size;\r\n}\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_usb_vid_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\ngboolean is_request = (pinfo->srcport == NO_ENDPOINT);\r\nusb_conv_info_t *usb_conv_info;\r\nusb_trans_info_t *usb_trans_info;\r\nint offset = 0;\r\nusb_setup_dissector dissector = NULL;\r\nconst usb_setup_dissector_table_t *tmp;\r\nif (data == NULL || ((usb_conv_info_t *)data)->usb_trans_info == NULL)\r\nreturn 0;\r\nusb_conv_info = (usb_conv_info_t *)data;\r\nusb_trans_info = usb_conv_info->usb_trans_info;\r\nfor (tmp=setup_dissectors; tmp->dissector; tmp++)\r\n{\r\nif (tmp->request == usb_trans_info->setup.request)\r\n{\r\ndissector = tmp->dissector;\r\nbreak;\r\n}\r\n}\r\nif (!dissector)\r\nreturn 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "USBVIDEO");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s %s",\r\nval_to_str(usb_trans_info->setup.request, setup_request_names_vals, "Unknown type %x"),\r\nis_request?"Request ":"Response");\r\nif (is_request)\r\n{\r\nproto_tree_add_item(tree, hf_usb_vid_request, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\n}\r\noffset = dissector(pinfo, tree, tvb, offset, is_request, usb_trans_info, usb_conv_info);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_usb_vid_interrupt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nusb_conv_info_t *usb_conv_info;\r\ngint bytes_available;\r\nint offset = 0;\r\nusb_conv_info = (usb_conv_info_t *)data;\r\nbytes_available = tvb_reported_length_remaining(tvb, offset);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "USBVIDEO");\r\nif (bytes_available > 0)\r\n{\r\nguint8 originating_interface;\r\nguint8 originating_entity;\r\noriginating_interface = tvb_get_guint8(tvb, offset) & INT_ORIGINATOR_MASK;\r\nproto_tree_add_item(tree, hf_usb_vid_interrupt_bStatusType, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\noriginating_entity = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_usb_vid_interrupt_bOriginator, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\nif (originating_interface == INT_VIDEOCONTROL)\r\n{\r\nguint8 control_sel;\r\nguint8 attribute;\r\nconst gchar *control_name;\r\nproto_tree_add_item(tree, hf_usb_vid_control_interrupt_bEvent, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\ncontrol_sel = tvb_get_guint8(tvb, offset);\r\ncontrol_name = get_control_selector_name(originating_entity, control_sel, usb_conv_info);\r\nif (!control_name)\r\ncontrol_name = "Unknown";\r\nproto_tree_add_uint_format_value(tree, hf_usb_vid_control_selector, tvb,\r\noffset, 1, control_sel, "%s (0x%02x)",\r\ncontrol_name, control_sel);\r\noffset++;\r\nattribute = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_usb_vid_interrupt_bAttribute, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\nswitch (attribute)\r\n{\r\ncase CONTROL_CHANGE_FAILURE:\r\nproto_tree_add_item(tree, hf_usb_vid_request_error, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\nbreak;\r\ncase CONTROL_CHANGE_INFO:\r\noffset = dissect_usb_vid_control_info(tree, tvb, offset);\r\nbreak;\r\ncase CONTROL_CHANGE_VALUE:\r\ncase CONTROL_CHANGE_MIN:\r\ncase CONTROL_CHANGE_MAX:\r\ndissect_usb_vid_control_value(tree, tvb, offset, attribute);\r\noffset += tvb_reported_length_remaining(tvb, offset);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tree, hf_usb_vid_value_data, tvb, offset, -1, ENC_NA);\r\noffset += tvb_reported_length_remaining(tvb, offset);\r\nbreak;\r\n}\r\n}\r\nelse if (originating_interface == INT_VIDEOSTREAMING)\r\n{\r\n}\r\n}\r\nelse\r\noffset = -2;\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_usb_vid(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_usb_vid_request,\r\n{ "bRequest", "usbvideo.setup.bRequest", FT_UINT8, BASE_HEX, VALS(setup_request_names_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_length,\r\n{ "wLength", "usbvideo.setup.wLength", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_request_error,\r\n{ "bRequestErrorCode", "usbvideo.reqerror.code",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING,\r\n&request_error_codes_ext, 0,\r\n"Request Error Code", HFILL }\r\n},\r\n{ &hf_usb_vid_control_selector,\r\n{ "Control Selector", "usbvideo.control.selector", FT_UINT8, BASE_HEX, NULL, 0x0,\r\n"ID of the control within its entity", HFILL }\r\n},\r\n{ &hf_usb_vid_control_entity,\r\n{ "Entity", "usbvideo.control.entity", FT_UINT8, BASE_HEX, NULL, 0x0,\r\n"Unit or terminal to which the control belongs", HFILL }\r\n},\r\n{ &hf_usb_vid_control_interface,\r\n{ "Interface", "usbvideo.control.interface", FT_UINT8, BASE_HEX, NULL, 0x0,\r\n"Interface to which the control belongs", HFILL }\r\n},\r\n{ &hf_usb_vid_control_info,\r\n{ "Info (Capabilities/State)", "usbvideo.control.info",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Control capabilities and current state", HFILL }\r\n},\r\n{ &hf_usb_vid_control_info_D[0],\r\n{ "Supports GET", "usbvideo.control.info.D0",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<0),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_info_D[1],\r\n{ "Supports SET", "usbvideo.control.info.D1",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<1),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_info_D[2],\r\n{ "Disabled due to automatic mode", "usbvideo.control.info.D2",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<2),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_info_D[3],\r\n{ "Autoupdate", "usbvideo.control.info.D3",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<3),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_info_D[4],\r\n{ "Asynchronous", "usbvideo.control.info.D4",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<4),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_info_D[5],\r\n{ "Disabled due to incompatibility with Commit state", "usbvideo.control.info.D5",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<5),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_info_D[6],\r\n{ "Reserved", "usbvideo.control.info.D6",\r\nFT_UINT8, BASE_HEX, NULL, (3<<6),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_length,\r\n{ "Control Length", "usbvideo.control.len",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Control size in bytes", HFILL }\r\n},\r\n{ &hf_usb_vid_control_default,\r\n{ "Default value", "usbvideo.control.value.default",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_min,\r\n{ "Minimum value", "usbvideo.control.value.min",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_max,\r\n{ "Maximum value", "usbvideo.control.value.max",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_res,\r\n{ "Resolution", "usbvideo.control.value.res",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_cur,\r\n{ "Current value", "usbvideo.control.value.cur",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_ifdesc_iTerminal,\r\n{ "iTerminal", "usbvideo.terminal.name", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"String Descriptor describing this terminal", HFILL }\r\n},\r\n{ &hf_usb_vid_control_ifdesc_terminal_id,\r\n{ "bTerminalID", "usbvideo.terminal.id", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_ifdesc_terminal_type,\r\n{ "wTerminalType", "usbvideo.terminal.type",\r\nFT_UINT16, BASE_HEX | BASE_EXT_STRING, &vc_terminal_types_ext, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_ifdesc_assoc_terminal,\r\n{ "bAssocTerminal", "usbvideo.terminal.assocTerminal", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Associated Terminal", HFILL }\r\n},\r\n{ &hf_usb_vid_cam_objective_focal_len_min,\r\n{ "wObjectiveFocalLengthMin", "usbvideo.camera.objectiveFocalLengthMin",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Minimum Focal Length for Optical Zoom", HFILL }\r\n},\r\n{ &hf_usb_vid_cam_objective_focal_len_max,\r\n{ "wObjectiveFocalLengthMax", "usbvideo.camera.objectiveFocalLengthMax",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Minimum Focal Length for Optical Zoom", HFILL }\r\n},\r\n{ &hf_usb_vid_cam_ocular_focal_len,\r\n{ "wOcularFocalLength", "usbvideo.camera.ocularFocalLength",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Ocular Focal Length for Optical Zoom", HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[0],\r\n{ "Scanning Mode", "usbvideo.camera.control.D0",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<0),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[1],\r\n{ "Auto Exposure Mode", "usbvideo.camera.control.D1",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<1),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[2],\r\n{ "Auto Exposure Priority", "usbvideo.camera.control.D2",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<2),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[3],\r\n{ "Exposure Time (Absolute)", "usbvideo.camera.control.D3",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<3),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[4],\r\n{ "Exposure Time (Relative)", "usbvideo.camera.control.D4",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<4),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[5],\r\n{ "Focus (Absolute)", "usbvideo.camera.control.D5",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<5),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[6],\r\n{ "Focus (Relative)", "usbvideo.camera.control.D6",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<6),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[7],\r\n{ "Iris (Absolute)", "usbvideo.camera.control.D7",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<7),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[8],\r\n{ "Iris (Relative)", "usbvideo.camera.control.D8",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<8),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[9],\r\n{ "Zoom (Absolute)", "usbvideo.camera.control.D9",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<9),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[10],\r\n{ "Zoom (Relative)", "usbvideo.camera.control.D10",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<10),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[11],\r\n{ "PanTilt (Absolute)", "usbvideo.camera.control.D11",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<11),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[12],\r\n{ "PanTilt (Relative)", "usbvideo.camera.control.D12",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<12),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[13],\r\n{ "Roll (Absolute)", "usbvideo.camera.control.D13",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<13),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[14],\r\n{ "Roll (Relative)", "usbvideo.camera.control.D14",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<14),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[15],\r\n{ "D15", "usbvideo.camera.control.D15",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<15),\r\n"Reserved", HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[16],\r\n{ "D16", "usbvideo.camera.control.D16",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<16),\r\n"Reserved", HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[17],\r\n{ "Auto Focus", "usbvideo.camera.control.D17",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<17),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[18],\r\n{ "Privacy", "usbvideo.camera.control.D18",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<18),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[19],\r\n{ "Focus (Simple)", "usbvideo.camera.control.D19",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<19),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[20],\r\n{ "Window", "usbvideo.camera.control.D20",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<20),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_cam_control_D[21],\r\n{ "Region of Interest", "usbvideo.camera.control.D21",\r\nFT_BOOLEAN,\r\narray_length(hf_usb_vid_cam_control_D),\r\nTFS(&tfs_yes_no), (1<<21),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_ifdesc_unit_id,\r\n{ "bUnitID", "usbvideo.unit.id", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_num_inputs,\r\n{ "bNrInPins", "usbvideo.unit.numInputs",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Number of input pins", HFILL }\r\n},\r\n{ &hf_usb_vid_sources,\r\n{ "baSourceID", "usbvideo.unit.sources",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Input entity IDs", HFILL }\r\n},\r\n{ &hf_usb_vid_iProcessing,\r\n{ "iProcessing", "usbvideo.processor.name", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"String Descriptor describing this terminal", HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[0],\r\n{ "Brightness", "usbvideo.processor.control.D0",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<0),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[1],\r\n{ "Contrast", "usbvideo.processor.control.D1",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<1),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[2],\r\n{ "Hue", "usbvideo.processor.control.D2",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<2),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[3],\r\n{ "Saturation", "usbvideo.processor.control.D3",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<3),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[4],\r\n{ "Sharpness", "usbvideo.processor.control.D4",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<4),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[5],\r\n{ "Gamma", "usbvideo.processor.control.D5",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<5),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[6],\r\n{ "White Balance Temperature", "usbvideo.processor.control.D6",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<6),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[7],\r\n{ "White Balance Component", "usbvideo.processor.control.D7",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<7),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[8],\r\n{ "Backlight Compensation", "usbvideo.processor.control.D8",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<8),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[9],\r\n{ "Gain", "usbvideo.processor.control.D9",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<9),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[10],\r\n{ "Power Line Frequency", "usbvideo.processor.control.D10",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<10),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[11],\r\n{ "Hue, Auto", "usbvideo.processor.control.D11",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<11),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[12],\r\n{ "White Balance Temperature, Auto", "usbvideo.processor.control.D12",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<12),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[13],\r\n{ "White Balance Component, Auto", "usbvideo.processor.control.D13",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<13),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[14],\r\n{ "Digital Multiplier", "usbvideo.processor.control.D14",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<14),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[15],\r\n{ "Digital Multiplier Limit", "usbvideo.processor.control.D15",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<15),\r\n"Reserved", HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[16],\r\n{ "Analog Video Standard", "usbvideo.processor.control.D16",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<16),\r\n"Reserved", HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[17],\r\n{ "Analog Video Lock Status", "usbvideo.processor.control.D17",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<17),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_control_D[18],\r\n{ "Contrast, Auto", "usbvideo.processor.control.D18",\r\nFT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<18),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_standards,\r\n{ "bmVideoStandards", "usbvideo.processor.standards",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Supported analog video standards", HFILL }\r\n},\r\n{ &hf_usb_vid_proc_standards_D[0],\r\n{ "None", "usbvideo.processor.standards.D0",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<0),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_standards_D[1],\r\n{ "NTSC - 525/60", "usbvideo.processor.standards.D1",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<1),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_standards_D[2],\r\n{ "PAL - 625/50", "usbvideo.processor.standards.D2",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<2),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_standards_D[3],\r\n{ "SECAM - 625/50", "usbvideo.processor.standards.D3",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<3),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_standards_D[4],\r\n{ "NTSC - 625/50", "usbvideo.processor.standards.D4",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<4),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_proc_standards_D[5],\r\n{ "PAL - 525/60", "usbvideo.processor.standards.D5",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<5),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_max_multiplier,\r\n{ "wMaxMultiplier", "usbvideo.processor.maxMultiplier",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"100 x max digital multiplication", HFILL }\r\n},\r\n{ &hf_usb_vid_iSelector,\r\n{ "iSelector", "usbvideo.selector.name", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"String Descriptor describing this terminal", HFILL }\r\n},\r\n{ &hf_usb_vid_iExtension,\r\n{ "iExtension", "usbvideo.extension.name", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"String Descriptor describing this terminal", HFILL }\r\n},\r\n{ &hf_usb_vid_exten_guid,\r\n{ "guid", "usbvideo.extension.guid",\r\nFT_GUID, BASE_NONE, NULL, 0,\r\n"Identifier", HFILL }\r\n},\r\n{ &hf_usb_vid_exten_num_controls,\r\n{ "bNumControls", "usbvideo.extension.numControls",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Number of controls", HFILL }\r\n},\r\n{ &hf_usb_vid_probe_hint,\r\n{ "bmHint", "usbvideo.probe.hint",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\n"Fields to hold constant during negotiation", HFILL }\r\n},\r\n{ &hf_usb_vid_probe_hint_D[0],\r\n{ "dwFrameInterval", "usbvideo.probe.hint.D0",\r\nFT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<0),\r\n"Frame Rate", HFILL }\r\n},\r\n{ &hf_usb_vid_probe_hint_D[1],\r\n{ "wKeyFrameRate", "usbvideo.probe.hint.D1",\r\nFT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<1),\r\n"Key Frame Rate", HFILL }\r\n},\r\n{ &hf_usb_vid_probe_hint_D[2],\r\n{ "wPFrameRate", "usbvideo.probe.hint.D2",\r\nFT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<2),\r\n"P-Frame Rate", HFILL }\r\n},\r\n{ &hf_usb_vid_probe_hint_D[3],\r\n{ "wCompQuality", "usbvideo.probe.hint.D3",\r\nFT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<3),\r\n"Compression Quality", HFILL }\r\n},\r\n{ &hf_usb_vid_probe_hint_D[4],\r\n{ "wCompWindowSize", "usbvideo.probe.hint.D4",\r\nFT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<4),\r\n"Compression Window Size", HFILL }\r\n},\r\n{ &hf_usb_vid_probe_key_frame_rate,\r\n{ "wKeyFrameRate", "usbvideo.probe.keyFrameRate",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Key frame rate", HFILL }\r\n},\r\n{ &hf_usb_vid_probe_p_frame_rate,\r\n{ "wPFrameRate", "usbvideo.probe.pFrameRate",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"P frame rate", HFILL }\r\n},\r\n{ &hf_usb_vid_probe_comp_quality,\r\n{ "wCompQuality", "usbvideo.probe.compQuality",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Compression quality [0-10000]", HFILL }\r\n},\r\n{ &hf_usb_vid_probe_comp_window,\r\n{ "wCompWindow", "usbvideo.probe.compWindow",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Window size for average bit rate control", HFILL }\r\n},\r\n{ &hf_usb_vid_probe_delay,\r\n{ "wDelay", "usbvideo.probe.delay",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Latency in ms from capture to USB", HFILL }\r\n},\r\n{ &hf_usb_vid_probe_max_frame_sz,\r\n{ "dwMaxVideoFrameSize", "usbvideo.probe.maxVideoFrameSize",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_probe_max_payload_sz,\r\n{ "dwMaxPayloadTransferSize", "usbvideo.probe.maxPayloadTransferSize",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_probe_clock_freq,\r\n{ "dwClockFrequency", "usbvideo.probe.clockFrequency",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Device clock frequency in Hz", HFILL }\r\n},\r\n{ &hf_usb_vid_probe_framing,\r\n{ "bmFramingInfo", "usbvideo.probe.framing",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_probe_framing_D[0],\r\n{ "Frame ID required", "usbvideo.probe.framing.D0",\r\nFT_BOOLEAN, 2, TFS(&tfs_yes_no), (1<<0),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_probe_framing_D[1],\r\n{ "EOF utilized", "usbvideo.probe.framing.D1",\r\nFT_BOOLEAN, 2, TFS(&tfs_yes_no), (1<<1),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_probe_preferred_ver,\r\n{ "bPreferredVersion", "usbvideo.probe.preferredVersion",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Preferred payload format version", HFILL }\r\n},\r\n{ &hf_usb_vid_probe_min_ver,\r\n{ "bMinVersion", "usbvideo.probe.minVersion",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Min supported payload format version", HFILL }\r\n},\r\n{ &hf_usb_vid_probe_max_ver,\r\n{ "bPreferredVersion", "usbvideo.probe.maxVer",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Max supported payload format version", HFILL }\r\n},\r\n{ &hf_usb_vid_control_ifdesc_dwClockFrequency,\r\n{ "dwClockFrequency", "usbvideo.probe.clockFrequency",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Device clock frequency (Hz) for selected format", HFILL }\r\n},\r\n{ &hf_usb_vid_format_index,\r\n{ "bFormatIndex", "usbvideo.format.index",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Index of this format descriptor", HFILL }\r\n},\r\n{ &hf_usb_vid_format_num_frame_descriptors,\r\n{ "bNumFrameDescriptors", "usbvideo.format.numFrameDescriptors",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Number of frame descriptors for this format", HFILL }\r\n},\r\n{ &hf_usb_vid_format_guid,\r\n{ "guidFormat", "usbvideo.format.guid",\r\nFT_GUID, BASE_NONE, NULL, 0,\r\n"Stream encoding format", HFILL }\r\n},\r\n{ &hf_usb_vid_format_bits_per_pixel,\r\n{ "bBitsPerPixel", "usbvideo.format.bitsPerPixel",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Bits per pixel", HFILL }\r\n},\r\n{ &hf_usb_vid_default_frame_index,\r\n{ "bDefaultFrameIndex", "usbvideo.format.defaultFrameIndex",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Optimum frame index for this stream", HFILL }\r\n},\r\n{ &hf_usb_vid_aspect_ratio_x,\r\n{ "bAspectRatioX", "usbvideo.format.aspectRatioX",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"X dimension of picture aspect ratio", HFILL }\r\n},\r\n{ &hf_usb_vid_aspect_ratio_y,\r\n{ "bAspectRatioY", "usbvideo.format.aspectRatioY",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Y dimension of picture aspect ratio", HFILL }\r\n},\r\n{ &hf_usb_vid_interlace_flags,\r\n{ "bmInterlaceFlags", "usbvideo.format.interlace",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_is_interlaced,\r\n{ "Interlaced stream", "usbvideo.format.interlace.D0",\r\nFT_BOOLEAN, 8, TFS(&is_interlaced_meaning), (1<<0),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_interlaced_fields,\r\n{ "Fields per frame", "usbvideo.format.interlace.D1",\r\nFT_BOOLEAN, 8, TFS(&interlaced_fields_meaning), (1<<1),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_field_1_first,\r\n{ "Field 1 first", "usbvideo.format.interlace.D2",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<2),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_field_pattern,\r\n{ "Field pattern", "usbvideo.format.interlace.pattern",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING,\r\n&field_pattern_meaning_ext, (3<<4),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_copy_protect,\r\n{ "bCopyProtect", "usbvideo.format.copyProtect",\r\nFT_UINT8, BASE_DEC, VALS(copy_protect_meaning), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_variable_size,\r\n{ "Variable size", "usbvideo.format.variableSize",\r\nFT_BOOLEAN, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_mjpeg_flags,\r\n{ "bmFlags", "usbvideo.mjpeg.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Characteristics", HFILL }\r\n},\r\n{ &hf_usb_vid_mjpeg_fixed_samples,\r\n{ "Fixed size samples", "usbvideo.mjpeg.fixed_size",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<0),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_frame_index,\r\n{ "bFrameIndex", "usbvideo.frame.index",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Index of this frame descriptor", HFILL }\r\n},\r\n{ &hf_usb_vid_frame_capabilities,\r\n{ "bmCapabilities", "usbvideo.frame.capabilities",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Capabilities", HFILL }\r\n},\r\n{ &hf_usb_vid_frame_stills_supported,\r\n{ "Still image", "usbvideo.frame.stills",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), (1<<0),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_frame_interval,\r\n{ "dwFrameInterval", "usbvideo.frame.interval",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Frame interval multiple of 100 ns", HFILL }\r\n},\r\n{ &hf_usb_vid_frame_fixed_frame_rate,\r\n{ "Fixed frame rate", "usbvideo.frame.fixedRate",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<1),\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_frame_width,\r\n{ "wWidth", "usbvideo.frame.width",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Width of frame in pixels", HFILL }\r\n},\r\n{ &hf_usb_vid_frame_height,\r\n{ "wHeight", "usbvideo.frame.height",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Height of frame in pixels", HFILL }\r\n},\r\n{ &hf_usb_vid_frame_min_bit_rate,\r\n{ "dwMinBitRate", "usbvideo.frame.minBitRate",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Minimum bit rate in bps", HFILL }\r\n},\r\n{ &hf_usb_vid_frame_max_bit_rate,\r\n{ "dwMaxBitRate", "usbvideo.frame.maxBitRate",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Maximum bit rate in bps", HFILL }\r\n},\r\n{ &hf_usb_vid_frame_max_frame_sz,\r\n{ "dwMaxVideoFrameBufferSize", "usbvideo.frame.maxBuffer",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Maximum bytes per frame", HFILL }\r\n},\r\n{ &hf_usb_vid_frame_default_interval,\r\n{ "dwDefaultFrameInterval", "usbvideo.frame.interval.default",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Suggested default", HFILL }\r\n},\r\n{ &hf_usb_vid_frame_interval_type,\r\n{ "bFrameIntervalType", "usbvideo.frame.interval.type",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Frame rate control (continuous/discrete)", HFILL }\r\n},\r\n{ &hf_usb_vid_frame_min_interval,\r\n{ "dwMinFrameInterval", "usbvideo.frame.interval.min",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Shortest frame interval (* 100 ns)", HFILL }\r\n},\r\n{ &hf_usb_vid_frame_max_interval,\r\n{ "dwMaxFrameInterval", "usbvideo.frame.interval.max",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Longest frame interval (* 100 ns)", HFILL }\r\n},\r\n{ &hf_usb_vid_frame_step_interval,\r\n{ "dwMinFrameInterval", "usbvideo.frame.interval.step",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Granularity of frame interval (* 100 ns)", HFILL }\r\n},\r\n{ &hf_usb_vid_frame_bytes_per_line,\r\n{ "dwBytesPerLine", "usbvideo.frame.bytesPerLine",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Fixed number of bytes per video line", HFILL }\r\n},\r\n{ &hf_usb_vid_color_primaries,\r\n{ "bColorPrimaries", "usbvideo.color.primaries",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING,\r\n&color_primaries_meaning_ext, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_transfer_characteristics,\r\n{ "bTransferCharacteristics", "usbvideo.color.transferCharacteristics",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING,\r\n&color_transfer_characteristics_ext, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_matrix_coefficients,\r\n{ "bMatrixCoefficients", "usbvideo.color.matrixCoefficients",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING,\r\n&matrix_coefficients_meaning_ext, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_ifdesc_bcdUVC,\r\n{ "bcdUVC", "usbvideo.bcdUVC",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\n"Video Device Class Specification release number", HFILL }\r\n},\r\n{ &hf_usb_vid_control_ifdesc_bInCollection,\r\n{ "bInCollection", "usbvideo.numStreamingInterfaces",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Number of VideoStreaming interfaces", HFILL }\r\n},\r\n{ &hf_usb_vid_control_ifdesc_baInterfaceNr,\r\n{ "baInterfaceNr", "usbvideo.streamingInterfaceNumbers",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Interface numbers of VideoStreaming interfaces", HFILL }},\r\n{ &hf_usb_vid_streaming_ifdesc_bNumFormats,\r\n{ "bNumFormats", "usbvideo.streaming.numFormats",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Number of video payload format descriptors", HFILL }\r\n},\r\n{ &hf_usb_vid_streaming_bmInfo,\r\n{ "bmInfo", "usbvideo.streaming.info",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Capabilities", HFILL }\r\n},\r\n{ &hf_usb_vid_streaming_info_D[0],\r\n{ "Dynamic Format Change", "usbvideo.streaming.info.D0",\r\nFT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<0),\r\n"Dynamic Format Change", HFILL }\r\n},\r\n{ &hf_usb_vid_streaming_control_D[0],\r\n{ "wKeyFrameRate", "usbvideo.streaming.control.D0",\r\nFT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<0),\r\n"Probe and Commit support", HFILL }\r\n},\r\n{ &hf_usb_vid_streaming_control_D[1],\r\n{ "wPFrameRate", "usbvideo.streaming.control.D1",\r\nFT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<1),\r\n"Probe and Commit support", HFILL }\r\n},\r\n{ &hf_usb_vid_streaming_control_D[2],\r\n{ "wCompQuality", "usbvideo.streaming.control.D2",\r\nFT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<2),\r\n"Probe and Commit support", HFILL }\r\n},\r\n{ &hf_usb_vid_streaming_control_D[3],\r\n{ "wCompWindowSize", "usbvideo.streaming.control.D3",\r\nFT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<3),\r\n"Probe and Commit support", HFILL }\r\n},\r\n{ &hf_usb_vid_streaming_control_D[4],\r\n{ "Generate Key Frame", "usbvideo.streaming.control.D4",\r\nFT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<4),\r\n"Probe and Commit support", HFILL }\r\n},\r\n{ &hf_usb_vid_streaming_control_D[5],\r\n{ "Update Frame Segment", "usbvideo.streaming.control.D5",\r\nFT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<5),\r\n"Probe and Commit support", HFILL }\r\n},\r\n{ &hf_usb_vid_streaming_terminal_link,\r\n{ "bTerminalLink", "usbvideo.streaming.terminalLink", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Output terminal ID", HFILL }\r\n},\r\n{ &hf_usb_vid_streaming_still_capture_method,\r\n{ "bStillCaptureMethod", "usbvideo.streaming.stillCaptureMethod",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING,\r\n&vs_still_capture_methods_ext, 0,\r\n"Method of Still Image Capture", HFILL }\r\n},\r\n{ &hf_usb_vid_streaming_trigger_support,\r\n{ "HW Triggering", "usbvideo.streaming.triggerSupport",\r\nFT_BOOLEAN, BASE_DEC, TFS(&tfs_supported_not_supported), 0,\r\n"Is HW triggering supported", HFILL }\r\n},\r\n{ &hf_usb_vid_streaming_trigger_usage,\r\n{ "bTriggerUsage", "usbvideo.streaming.triggerUsage",\r\nFT_UINT8, BASE_DEC, VALS(vs_trigger_usage), 0,\r\n"How host SW should respond to trigger", HFILL }\r\n},\r\n{ &hf_usb_vid_interrupt_bStatusType,\r\n{ "Status Type", "usbvideo.interrupt.statusType",\r\nFT_UINT8, BASE_HEX, VALS(interrupt_status_types), 0xF,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_interrupt_bAttribute,\r\n{ "Change Type", "usbvideo.interrupt.attribute",\r\nFT_UINT8, BASE_HEX | BASE_EXT_STRING,\r\n&control_change_types_ext, 0,\r\n"Type of control change", HFILL }\r\n},\r\n{ &hf_usb_vid_interrupt_bOriginator,\r\n{ "Originator", "usbvideo.interrupt.originator",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"ID of the entity that reports this interrupt", HFILL }\r\n},\r\n{ &hf_usb_vid_control_interrupt_bEvent,\r\n{ "Event", "usbvideo.interrupt.controlEvent",\r\nFT_UINT8, BASE_HEX, VALS(control_interrupt_events), 0,\r\n"Type of event", HFILL }\r\n},\r\n{ &hf_usb_vid_epdesc_subtype,\r\n{ "Subtype", "usbvideo.ep.descriptorSubType",\r\nFT_UINT8, BASE_DEC, VALS(vc_ep_descriptor_subtypes), 0,\r\n"Descriptor Subtype", HFILL }\r\n},\r\n{ &hf_usb_vid_epdesc_max_transfer_sz,\r\n{ "wMaxTransferSize", "usbvideo.ep.maxInterruptSize", FT_UINT16,\r\nBASE_DEC, NULL, 0x0, "Max interrupt structure size", HFILL }\r\n},\r\n{ &hf_usb_vid_ifdesc_wTotalLength,\r\n{ "wTotalLength", "usbvideo.totalLength",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Video interface descriptor size", HFILL }\r\n},\r\n{ &hf_usb_vid_bControlSize,\r\n{ "bControlSize", "usbvideo.bmcontrolSize",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Size of bmControls field", HFILL }\r\n},\r\n{ &hf_usb_vid_bmControl,\r\n{ "bmControl", "usbvideo.availableControls",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Available controls", HFILL }\r\n},\r\n{ &hf_usb_vid_bmControl_bytes,\r\n{ "bmControl", "usbvideo.availableControls.bytes",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Available controls", HFILL }\r\n},\r\n{ &hf_usb_vid_control_ifdesc_src_id,\r\n{ "bSourceID", "usbvideo.sourceID", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Entity to which this terminal/unit is connected", HFILL }\r\n},\r\n{ &hf_usb_vid_control_ifdesc_subtype,\r\n{ "Subtype", "usbvideo.control.descriptorSubType",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING,\r\n&vc_if_descriptor_subtypes_ext, 0,\r\n"Descriptor Subtype", HFILL }\r\n},\r\n{ &hf_usb_vid_streaming_ifdesc_subtype,\r\n{ "Subtype", "usbvideo.streaming.descriptorSubType",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING,\r\n&vs_if_descriptor_subtypes_ext, 0,\r\n"Descriptor Subtype", HFILL }\r\n},\r\n{ &hf_usb_vid_descriptor_data,\r\n{ "Descriptor data", "usbvideo.descriptor_data", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_data,\r\n{ "Control data", "usbvideo.control_data", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_control_value,\r\n{ "Control value", "usbvideo.control_value", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_vid_value_data,\r\n{ "Value data", "usbvideo.value_data", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *usb_vid_subtrees[] = {\r\n&ett_usb_vid,\r\n&ett_descriptor_video_endpoint,\r\n&ett_descriptor_video_control,\r\n&ett_descriptor_video_streaming,\r\n&ett_camera_controls,\r\n&ett_processing_controls,\r\n&ett_streaming_controls,\r\n&ett_streaming_info,\r\n&ett_interlace_flags,\r\n&ett_frame_capability_flags,\r\n&ett_mjpeg_flags,\r\n&ett_video_probe,\r\n&ett_probe_hint,\r\n&ett_probe_framing,\r\n&ett_video_standards,\r\n&ett_control_capabilities\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_usb_vid_subtype_unknown, { "usbvideo.subtype.unknown", PI_UNDECODED, PI_WARN, "Unknown VC subtype", EXPFILL }},\r\n{ &ei_usb_vid_bitmask_len, { "usbvideo.bitmask_len_error", PI_UNDECODED, PI_WARN, "Only least-significant bytes decoded", EXPFILL }},\r\n};\r\nexpert_module_t* expert_usb_vid;\r\nproto_usb_vid = proto_register_protocol("USB Video", "USBVIDEO", "usbvideo");\r\nproto_register_field_array(proto_usb_vid, hf, array_length(hf));\r\nproto_register_subtree_array(usb_vid_subtrees, array_length(usb_vid_subtrees));\r\nexpert_usb_vid = expert_register_protocol(proto_usb_vid);\r\nexpert_register_field_array(expert_usb_vid, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_usb_vid(void)\r\n{\r\ndissector_handle_t usb_vid_control_handle;\r\ndissector_handle_t usb_vid_descriptor_handle;\r\ndissector_handle_t usb_vid_interrupt_handle;\r\nusb_vid_control_handle = create_dissector_handle(dissect_usb_vid_control, proto_usb_vid);\r\ndissector_add_uint("usb.control", IF_CLASS_VIDEO, usb_vid_control_handle);\r\nusb_vid_descriptor_handle = create_dissector_handle(dissect_usb_vid_descriptor, proto_usb_vid);\r\ndissector_add_uint("usb.descriptor", IF_CLASS_VIDEO, usb_vid_descriptor_handle);\r\nusb_vid_interrupt_handle = create_dissector_handle(dissect_usb_vid_interrupt, proto_usb_vid);\r\ndissector_add_uint("usb.interrupt", IF_CLASS_VIDEO, usb_vid_interrupt_handle);\r\n}
