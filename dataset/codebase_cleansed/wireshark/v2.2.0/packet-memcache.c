static guint\r\nget_memcache_pdu_len (packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset, void *data _U_)\r\n{\r\nguint32 body_len;\r\nbody_len = tvb_get_ntohl(tvb, offset+8);\r\nreturn body_len + MEMCACHE_HEADER_LEN;\r\n}\r\nstatic void\r\ndissect_extras (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, guint8 extras_len, guint8 opcode, gboolean request)\r\n{\r\nproto_tree *extras_tree = NULL;\r\nproto_item *extras_item = NULL, *ti;\r\ngint save_offset = offset;\r\ngboolean illegal = FALSE;\r\ngboolean missing = FALSE;\r\nif (extras_len) {\r\nextras_item = proto_tree_add_item (tree, hf_extras, tvb, offset, extras_len, ENC_NA);\r\nextras_tree = proto_item_add_subtree (extras_item, ett_extras);\r\n}\r\nswitch (opcode) {\r\ncase OP_GET:\r\ncase OP_GET_Q:\r\ncase OP_GET_K:\r\ncase OP_GET_K_Q:\r\nif (extras_len) {\r\nif (request) {\r\nillegal = TRUE;\r\n} else {\r\nproto_tree_add_item (extras_tree, hf_extras_flags, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\n} else if (!request) {\r\nmissing = TRUE;\r\n}\r\nbreak;\r\ncase OP_SET:\r\ncase OP_SET_Q:\r\ncase OP_ADD:\r\ncase OP_ADD_Q:\r\ncase OP_REPLACE:\r\ncase OP_REPLACE_Q:\r\nif (extras_len) {\r\nif (request) {\r\nproto_tree_add_item (extras_tree, hf_extras_flags, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item (extras_tree, hf_extras_expiration, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n} else {\r\nillegal = TRUE;\r\n}\r\n} else if (request) {\r\nmissing = TRUE;\r\n}\r\nbreak;\r\ncase OP_INCREMENT:\r\ncase OP_INCREMENT_Q:\r\ncase OP_DECREMENT:\r\ncase OP_DECREMENT_Q:\r\nif (extras_len) {\r\nif (request) {\r\nproto_tree_add_item (extras_tree, hf_extras_delta, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\nproto_tree_add_item (extras_tree, hf_extras_initial, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\nproto_tree_add_item (extras_tree, hf_extras_expiration, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n} else {\r\nillegal = TRUE;\r\n}\r\n} else if (request) {\r\nmissing = TRUE;\r\n}\r\nbreak;\r\ncase OP_FLUSH:\r\ncase OP_FLUSH_Q:\r\nif (extras_len) {\r\nproto_tree_add_item (extras_tree, hf_extras_expiration, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nbreak;\r\ncase OP_DELETE:\r\ncase OP_DELETE_Q:\r\ncase OP_QUIT:\r\ncase OP_QUIT_Q:\r\ncase OP_VERSION:\r\ncase OP_APPEND:\r\ncase OP_APPEND_Q:\r\ncase OP_PREPEND:\r\ncase OP_PREPEND_Q:\r\ncase OP_STAT:\r\nif (extras_len) {\r\nillegal = TRUE;\r\n}\r\nbreak;\r\ndefault:\r\nif (extras_len) {\r\nproto_tree_add_item (extras_tree, hf_extras_unknown, tvb, offset, extras_len, ENC_NA);\r\noffset += extras_len;\r\n}\r\nbreak;\r\n}\r\nif (illegal) {\r\nti = proto_tree_add_item (extras_tree, hf_extras_unknown, tvb, offset, extras_len, ENC_NA);\r\nexpert_add_info_format(pinfo, ti, &ei_extras_unknown, "%s %s shall not have Extras",\r\nval_to_str (opcode, opcode_vals, "Opcode %d"),\r\nrequest ? "Request" : "Response");\r\noffset += extras_len;\r\n} else if (missing) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_extras_missing, tvb, offset, 0, "%s %s must have Extras",\r\nval_to_str (opcode, opcode_vals, "Opcode %d"),\r\nrequest ? "Request" : "Response");\r\n}\r\nif ((offset - save_offset) != extras_len) {\r\nexpert_add_info_format(pinfo, extras_item, &ei_extras_unknown, "Illegal Extras length, should be %d", offset - save_offset);\r\n}\r\n}\r\nstatic void\r\ndissect_key (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, int key_len, guint8 opcode, gboolean request)\r\n{\r\nproto_item *ti = NULL;\r\ngboolean illegal = FALSE;\r\ngboolean missing = FALSE;\r\nif (key_len) {\r\nti = proto_tree_add_item (tree, hf_key, tvb, offset, key_len, ENC_ASCII|ENC_NA);\r\noffset += key_len;\r\nif ((opcode == OP_QUIT) || (opcode == OP_QUIT_Q) || (opcode == OP_NO_OP) || (opcode == OP_VERSION)) {\r\nillegal = TRUE;\r\n}\r\nif ((opcode == OP_SET) || (opcode == OP_ADD) || (opcode == OP_REPLACE) || (opcode == OP_DELETE) ||\r\n(opcode == OP_SET_Q) || (opcode == OP_ADD_Q) || (opcode == OP_REPLACE_Q) || (opcode == OP_DELETE_Q) ||\r\n(opcode == OP_FLUSH) || (opcode == OP_APPEND) || (opcode == OP_PREPEND) ||\r\n(opcode == OP_FLUSH_Q) || (opcode == OP_APPEND_Q) || (opcode == OP_PREPEND_Q))\r\n{\r\nif (!request) {\r\nillegal = TRUE;\r\n}\r\n}\r\n} else {\r\nif ((opcode == OP_GET) || (opcode == OP_GET_Q) || (opcode == OP_GET_K) || (opcode == OP_GET_K_Q) ||\r\n(opcode == OP_SET) || (opcode == OP_ADD) || (opcode == OP_REPLACE) || (opcode == OP_DELETE) ||\r\n(opcode == OP_SET_Q) || (opcode == OP_ADD_Q) || (opcode == OP_REPLACE_Q) || (opcode == OP_DELETE_Q) ||\r\n(opcode == OP_INCREMENT) || (opcode == OP_DECREMENT) || (opcode == OP_INCREMENT_Q) || (opcode == OP_DECREMENT_Q))\r\n{\r\nif (request) {\r\nmissing = TRUE;\r\n}\r\n}\r\n}\r\nif (illegal) {\r\nexpert_add_info_format(pinfo, ti, &ei_key_unknown, "%s %s shall not have Key",\r\nval_to_str (opcode, opcode_vals, "Opcode %d"),\r\nrequest ? "Request" : "Response");\r\n} else if (missing) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_key_missing, tvb, offset, 0, "%s Request must have Key",\r\nval_to_str (opcode, opcode_vals, "Opcode %d"));\r\n}\r\n}\r\nstatic void\r\ndissect_value (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, guint32 value_len, guint8 opcode, gboolean request)\r\n{\r\nproto_item *ti = NULL;\r\ngboolean illegal = FALSE;\r\ngboolean missing = FALSE;\r\nif (value_len > 0) {\r\nif (!request && ((opcode == OP_INCREMENT) || (opcode == OP_DECREMENT))) {\r\nti = proto_tree_add_item (tree, hf_uint64_response, tvb, offset, 8, ENC_BIG_ENDIAN);\r\nif (value_len != 8) {\r\nexpert_add_info_format(pinfo, ti, &ei_value_length, "Illegal Value length, should be 8");\r\n}\r\n} else {\r\nti = proto_tree_add_item (tree, hf_value, tvb, offset, value_len, ENC_ASCII|ENC_NA);\r\n}\r\noffset += value_len;\r\n}\r\nif (value_len) {\r\nif ((opcode == OP_GET) || (opcode == OP_GET_Q) || (opcode == OP_GET_K) || (opcode == OP_GET_K_Q) ||\r\n(opcode == OP_INCREMENT) || (opcode == OP_DECREMENT) || (opcode == OP_VERSION) ||\r\n(opcode == OP_INCREMENT_Q) || (opcode == OP_DECREMENT_Q))\r\n{\r\nif (request) {\r\nillegal = TRUE;\r\n}\r\n}\r\nif ((opcode == OP_DELETE) || (opcode == OP_QUIT) || (opcode == OP_FLUSH) || (opcode == OP_NO_OP) ||\r\n(opcode == OP_DELETE_Q) || (opcode == OP_QUIT_Q) || (opcode == OP_FLUSH_Q))\r\n{\r\nillegal = TRUE;\r\n}\r\nif ((opcode == OP_SET) || (opcode == OP_ADD) || (opcode == OP_REPLACE) ||\r\n(opcode == OP_SET_Q) || (opcode == OP_ADD_Q) || (opcode == OP_REPLACE_Q) ||\r\n(opcode == OP_APPEND) || (opcode == OP_PREPEND) || (opcode == OP_APPEND_Q) || (opcode == OP_PREPEND_Q))\r\n{\r\nif (!request) {\r\nillegal = TRUE;\r\n}\r\n}\r\n} else {\r\nif ((opcode == OP_SET) || (opcode == OP_ADD) || (opcode == OP_REPLACE) ||\r\n(opcode == OP_SET_Q) || (opcode == OP_ADD_Q) || (opcode == OP_REPLACE_Q) ||\r\n(opcode == OP_APPEND) || (opcode == OP_PREPEND) || (opcode == OP_APPEND_Q) || (opcode == OP_PREPEND_Q))\r\n{\r\nif (request) {\r\nmissing = TRUE;\r\n}\r\n}\r\n}\r\nif (illegal) {\r\nexpert_add_info_format(pinfo, ti, &ei_value_unknown, "%s %s shall not have Value",\r\nval_to_str (opcode, opcode_vals, "Opcode %d"),\r\nrequest ? "Request" : "Response");\r\n} else if (missing) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_value_missing, tvb, offset, 0, "%s %s must have Value",\r\nval_to_str (opcode, opcode_vals, "Opcode %d"),\r\nrequest ? "Request" : "Response");\r\n}\r\n}\r\nstatic int\r\ndissect_memcache (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *memcache_tree;\r\nproto_item *memcache_item, *ti;\r\ngint offset = 0;\r\nguint8 magic, opcode, extras_len;\r\nguint16 key_len, status = 0;\r\nguint32 body_len, value_len;\r\ngboolean request;\r\ncol_set_str (pinfo->cinfo, COL_PROTOCOL, PSNAME);\r\ncol_clear (pinfo->cinfo, COL_INFO);\r\nmemcache_item = proto_tree_add_item (tree, proto_memcache, tvb, offset, -1, ENC_NA);\r\nmemcache_tree = proto_item_add_subtree (memcache_item, ett_memcache);\r\nmagic = tvb_get_guint8 (tvb, offset);\r\nti = proto_tree_add_item (memcache_tree, hf_magic, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif (try_val_to_str (magic, magic_vals) == NULL) {\r\nexpert_add_info_format(pinfo, ti, &ei_magic_unknown, "Unknown magic byte: %d", magic);\r\n}\r\nopcode = tvb_get_guint8 (tvb, offset);\r\nti = proto_tree_add_item (memcache_tree, hf_opcode, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif (try_val_to_str (opcode, opcode_vals) == NULL) {\r\nexpert_add_info_format(pinfo, ti, &ei_opcode_unknown, "Unknown opcode: %d", opcode);\r\n}\r\nproto_item_append_text (memcache_item, ", %s %s", val_to_str (opcode, opcode_vals, "Unknown opcode (%d)"),\r\nval_to_str (magic, magic_vals, "Unknown magic (%d)"));\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, "%s %s",\r\nval_to_str (opcode, opcode_vals, "Unknown opcode (%d)"),\r\nval_to_str (magic, magic_vals, "Unknown magic (%d)"));\r\nkey_len = tvb_get_ntohs (tvb, offset);\r\nproto_tree_add_item (memcache_tree, hf_key_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nextras_len = tvb_get_guint8 (tvb, offset);\r\nproto_tree_add_item (memcache_tree, hf_extras_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item (memcache_tree, hf_data_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nstatus = tvb_get_ntohs (tvb, offset);\r\nif (magic & 0x01) {\r\nrequest = FALSE;\r\nti = proto_tree_add_item (memcache_tree, hf_status, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nif (status != 0) {\r\nexpert_add_info_format(pinfo, ti, &ei_status_response, "%s: %s",\r\nval_to_str (opcode, opcode_vals, "Unknown opcode (%d)"),\r\nval_to_str (status, status_vals, "Status: %d"));\r\n}\r\n} else {\r\nrequest = TRUE;\r\nti = proto_tree_add_item (memcache_tree, hf_reserved, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nif (status != 0) {\r\nexpert_add_info_format(pinfo, ti, &ei_reserved_value, "Reserved value: %d", status);\r\n}\r\n}\r\noffset += 2;\r\nbody_len = tvb_get_ntohl (tvb, offset);\r\nvalue_len = body_len - extras_len - key_len;\r\nti = proto_tree_add_uint (memcache_tree, hf_value_length, tvb, offset, 0, value_len);\r\nPROTO_ITEM_SET_GENERATED (ti);\r\nproto_tree_add_item (memcache_tree, hf_total_body_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item (memcache_tree, hf_opaque, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item (memcache_tree, hf_cas, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\nif (status == 0) {\r\ndissect_extras (tvb, pinfo, memcache_tree, offset, extras_len, opcode, request);\r\noffset += extras_len;\r\ndissect_key (tvb, pinfo, memcache_tree, offset, key_len, opcode, request);\r\noffset += key_len;\r\ndissect_value (tvb, pinfo, memcache_tree, offset, value_len, opcode, request);\r\n} else if (body_len) {\r\nproto_tree_add_item (memcache_tree, hf_value, tvb, offset, body_len, ENC_ASCII|ENC_NA);\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, " (%s)",\r\nval_to_str (status, status_vals, "Unknown status: %d"));\r\n} else {\r\nproto_tree_add_expert_format(memcache_tree, pinfo, &ei_value_missing, tvb, offset, 0, "%s with status %s (%d) must have Value",\r\nval_to_str (opcode, opcode_vals, "Opcode %d"),\r\nval_to_str_const (status, status_vals, "Unknown"), status);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\nget_payload_length (tvbuff_t *tvb, const int token_number, int offset,\r\nguint32 *bytes, gboolean *content_length_found)\r\n{\r\nconst guchar *next_token;\r\nconst guchar *line, *lineend;\r\nguchar *bytes_val;\r\nint tokenlen, i = 0, linelen;\r\ngint next_offset;\r\nlinelen = tvb_find_line_end (tvb, offset, -1, &next_offset,\r\nFALSE);\r\nif (linelen < 0) {\r\nreturn FALSE;\r\n}\r\nline = tvb_get_ptr (tvb, offset, linelen);\r\nlineend = line + linelen;\r\nwhile (++i < token_number) {\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn FALSE;\r\n}\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\n}\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn FALSE;\r\n}\r\nbytes_val = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, tokenlen, ENC_ASCII);\r\nif (bytes_val) {\r\nif (sscanf (bytes_val, "%u", bytes) == 1) {\r\n*content_length_found = TRUE;\r\n} else {\r\nreturn FALSE;\r\n}\r\n} else {\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\ndesegment_pdus (tvbuff_t *tvb, packet_info *pinfo, const int offset,\r\nconst int data_offset, guint32 content_length)\r\n{\r\ngint length_remaining, reported_length_remaining;\r\nif (!tvb_bytes_exist (tvb, data_offset, content_length)) {\r\nlength_remaining = tvb_captured_length_remaining (tvb, data_offset);\r\nreported_length_remaining = tvb_reported_length_remaining (tvb, data_offset);\r\nif (length_remaining < reported_length_remaining) {\r\nreturn FALSE;\r\n}\r\nif (length_remaining == -1) {\r\nlength_remaining = 0;\r\n}\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = (content_length + 2) - length_remaining;\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nmemcache_req_resp_hdrs_do_reassembly (\r\ntvbuff_t *tvb, const int offset, packet_info *pinfo,\r\nconst gboolean desegment_headers, const gboolean desegment_body,\r\nconst memcache_type_t type, const int expect_content_length)\r\n{\r\nint linelen;\r\ngint next_offset;\r\ngint length_remaining;\r\ngint reported_length_remaining;\r\nguint32 content_length = 0;\r\ngboolean content_length_found = FALSE;\r\ngboolean ret = FALSE;\r\nif (desegment_headers && pinfo->can_desegment) {\r\nnext_offset = offset;\r\nreported_length_remaining = tvb_reported_length_remaining (tvb, next_offset);\r\nif (reported_length_remaining < 1) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn FALSE;\r\n}\r\nlength_remaining = tvb_captured_length_remaining (tvb, next_offset);\r\nlinelen = tvb_find_line_end (tvb, next_offset, -1, &next_offset, TRUE);\r\nif (linelen == -1 && length_remaining >= reported_length_remaining) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn FALSE;\r\n}\r\nif (expect_content_length == TRUE) {\r\nswitch (type) {\r\ncase MEMCACHE_REQUEST:\r\nret = get_payload_length (tvb, 5 , offset, &content_length, &content_length_found);\r\nif (!ret) {\r\nreturn FALSE;\r\n}\r\nbreak;\r\ncase MEMCACHE_RESPONSE:\r\nret = get_payload_length (tvb, 4 , offset, &content_length, &content_length_found);\r\nif (!ret) {\r\nreturn FALSE;\r\n}\r\nbreak;\r\ndefault:\r\nreturn FALSE;\r\n}\r\n}\r\n}\r\nif (desegment_body && content_length_found) {\r\nreturn !desegment_pdus (tvb, pinfo, offset, next_offset, content_length);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\ndissect_memcache_message (tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree)\r\n{\r\nconst guchar *line;\r\nconst guchar *lineend;\r\nint orig_offset;\r\nint first_linelen;\r\nint datalen;\r\nint expect_content_length = FALSE;\r\ngint next_offset;\r\ngboolean is_request_or_reply;\r\nmemcache_type_t memcache_type;\r\nReqRespDissector reqresp_dissector = NULL;\r\nproto_tree *memcache_tree = NULL;\r\nproto_item *memcache_item = NULL;\r\nguint8 opcode = 0xff;\r\nfirst_linelen = tvb_find_line_end (tvb, offset, -1, &next_offset,\r\nFALSE);\r\nif (first_linelen < 0) {\r\nreturn -1;\r\n}\r\nline = tvb_get_ptr (tvb, offset, first_linelen);\r\nlineend = line + first_linelen;\r\nmemcache_type = MEMCACHE_UNKNOWN;\r\nis_request_or_reply =\r\nis_memcache_request_or_reply ((const gchar *)line,\r\nfirst_linelen, &opcode, &memcache_type,\r\n&expect_content_length, &reqresp_dissector);\r\nif (is_request_or_reply) {\r\nif (!memcache_req_resp_hdrs_do_reassembly (tvb, offset, pinfo, memcache_desegment_headers,\r\nmemcache_desegment_body, memcache_type,\r\nexpect_content_length))\r\n{\r\nreturn -1;\r\n}\r\n}\r\ncol_set_str (pinfo->cinfo, COL_PROTOCOL, PSNAME);\r\nif (is_request_or_reply) {\r\nline = tvb_get_ptr (tvb, offset, first_linelen);\r\ncol_add_fstr (pinfo->cinfo, COL_INFO, "%s ",\r\nformat_text (line, first_linelen));\r\n} else {\r\ncol_set_str (pinfo->cinfo, COL_INFO, "MEMCACHE Continuation");\r\n}\r\norig_offset = offset;\r\nmemcache_item = proto_tree_add_item (tree, proto_memcache, tvb, offset, -1, ENC_NA);\r\nmemcache_tree = proto_item_add_subtree (memcache_item, ett_memcache);\r\nif (tvb_reported_length_remaining (tvb, offset) != 0) {\r\nif (is_request_or_reply && reqresp_dissector) {\r\nnext_offset = reqresp_dissector (tvb, pinfo, memcache_tree,\r\noffset, line, lineend, opcode);\r\nif (next_offset == -1) {\r\nreturn -1;\r\n}\r\noffset = next_offset;\r\n}\r\n}\r\ndatalen = tvb_captured_length_remaining (tvb, offset);\r\nif (datalen > 0) {\r\noffset += datalen;\r\n}\r\nreturn offset - orig_offset;\r\n}\r\nstatic int\r\ncontent_data_dissector (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset,\r\nint content_length, guint8 opcode)\r\n{\r\ngint datalen;\r\ngboolean short_pkt = FALSE;\r\nif (tvb_reported_length_remaining (tvb, offset) != 0) {\r\ndatalen = tvb_captured_length_remaining (tvb, offset);\r\nif (content_length >= 0) {\r\nif (datalen >= (content_length + 2)) {\r\ndatalen = content_length;\r\n} else {\r\nshort_pkt = TRUE;\r\n}\r\n}\r\ndissect_value (tvb, pinfo, tree, offset, datalen, opcode, TRUE);\r\nif (datalen > 0) {\r\nif (!short_pkt) {\r\noffset += (datalen + 2);\r\n} else {\r\noffset += datalen;\r\n}\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic guint\r\nfind_stat_colon (const guchar *line, const guchar *lineend,\r\nconst guchar **first_colon, const guchar **last_colon)\r\n{\r\nconst guchar *linep, *temp;\r\nguint occurrences = 0;\r\nguchar c;\r\nlinep = line;\r\nwhile (linep < lineend) {\r\ntemp = linep;\r\nc = *linep++;\r\nswitch (c) {\r\ncase ':':\r\noccurrences++;\r\nif (occurrences == 1) {\r\n*first_colon = temp;\r\n} else if (occurrences == 2) {\r\n*last_colon = temp;\r\n} else {\r\nreturn occurrences;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn occurrences;\r\n}\r\nstatic int\r\nincr_dissector (tvbuff_t *tvb, proto_tree *tree, int offset)\r\n{\r\ngint next_offset;\r\nint linelen;\r\nconst guchar *line, *lineend;\r\nconst guchar *next_token;\r\nint tokenlen;\r\nif (tvb_offset_exists (tvb, offset)) {\r\nlinelen = tvb_find_line_end (tvb, offset, -1, &next_offset, FALSE);\r\nif (linelen < 0) {\r\nreturn -1;\r\n}\r\nline = tvb_get_ptr (tvb, offset, linelen);\r\nlineend = line + linelen;\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn -1;\r\n}\r\nproto_tree_add_item (tree, hf_uint64_response, tvb, offset, tokenlen, ENC_BIG_ENDIAN);\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn next_offset;\r\n} else {\r\nreturn -1;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\nstat_dissector (tvbuff_t *tvb, proto_tree *tree, int offset)\r\n{\r\nguint occurrences = 0;\r\nconst guchar *first_colon = NULL, *last_colon = NULL;\r\nint tokenlen, linelen;\r\ngint next_offset;\r\nconst guchar *next_token;\r\nconst guchar *line, *lineend;\r\nguint32 slabclass;\r\nguchar response_chars[21];\r\nwhile (tvb_offset_exists (tvb, offset)) {\r\nlinelen = tvb_find_line_end (tvb, offset, -1, &next_offset,\r\nFALSE);\r\nif (linelen < 0) {\r\nreturn -1;\r\n}\r\nline = tvb_get_ptr (tvb, offset, linelen);\r\nlineend = line + linelen;\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif ((tokenlen == 4) && strncmp (line, "STAT", tokenlen) == 0) {\r\nproto_tree_add_item (tree, hf_command, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\noccurrences = find_stat_colon (line, lineend, &first_colon, &last_colon);\r\n} else if ((tokenlen == 3) && strncmp (line, "END", tokenlen) == 0) {\r\noffset += (int) (next_token - line);\r\nreturn offset;\r\n} else {\r\nreturn -1;\r\n}\r\nswitch (occurrences) {\r\ncase 2:\r\ntokenlen = (int) (first_colon - line);\r\nproto_tree_add_item (tree, hf_subcommand, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\noffset += tokenlen + 1;\r\ntokenlen = (int) (last_colon - first_colon - 1);\r\nif (tokenlen > 10 || tokenlen <= 0) {\r\nreturn -1;\r\n}\r\nmemcpy (response_chars, first_colon + 1, tokenlen);\r\nresponse_chars[tokenlen] = '\0';\r\nslabclass = (guint32) strtoul (response_chars, NULL, 10);\r\nproto_tree_add_uint (tree, hf_slabclass, tvb, offset, tokenlen, slabclass);\r\noffset += tokenlen + 1;\r\nline = last_colon + 1;\r\nbreak;\r\ncase 1:\r\ntokenlen = (int) (first_colon - line);\r\nif (tokenlen > 10 || tokenlen <= 0) {\r\nreturn -1;\r\n}\r\nmemcpy (response_chars, line, tokenlen);\r\nresponse_chars[tokenlen] = '\0';\r\nslabclass = (guint32) strtoul (response_chars, NULL, 10);\r\nproto_tree_add_uint (tree, hf_slabclass, tvb, offset, tokenlen, slabclass);\r\noffset += (int) (tokenlen + 1);\r\nline = first_colon + 1;\r\nbreak;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn -1;\r\n}\r\nproto_tree_add_item (tree, hf_name, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn -1;\r\n}\r\nproto_tree_add_item (tree, hf_name_value, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\noffset = next_offset;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\nget_response_dissector (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset)\r\n{\r\ngint next_offset;\r\nint linelen;\r\nconst guchar *line, *lineend;\r\nconst guchar *next_token;\r\nint tokenlen;\r\nguint16 flags;\r\nguint32 bytes;\r\nguint64 cas;\r\nguint8 opcode = 0xff;\r\ngchar response_chars[21];\r\nwhile (tvb_offset_exists (tvb, offset)) {\r\nlinelen = tvb_find_line_end (tvb, offset, -1, &next_offset,\r\nFALSE);\r\nif (linelen < 0) {\r\nreturn -1;\r\n}\r\nline = tvb_get_ptr (tvb, offset, linelen);\r\nlineend = line + linelen;\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn -1;\r\n}\r\nif ((tokenlen == 5) && strncmp (line, "VALUE", tokenlen) == 0) {\r\n} else if ((tokenlen == 3) && strncmp (line, "END", tokenlen) == 0) {\r\noffset += (int) (next_token - line);\r\nreturn offset;\r\n} else {\r\nreturn -1;\r\n}\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn -1;\r\n}\r\ndissect_key (tvb, pinfo, tree, offset, tokenlen, opcode, TRUE);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0 || tokenlen > 5) {\r\nreturn -1;\r\n}\r\nmemcpy (response_chars, line, tokenlen);\r\nresponse_chars[tokenlen] = '\0';\r\nflags = (guint16) strtoul (response_chars, NULL, 10);\r\nproto_tree_add_uint (tree, hf_flags, tvb, offset, tokenlen, flags);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0 || tokenlen > 10) {\r\nreturn -1;\r\n}\r\nmemcpy (response_chars, line, tokenlen);\r\nresponse_chars[tokenlen] = '\0';\r\nbytes = (guint32) strtoul (response_chars, NULL, 10);\r\nproto_tree_add_uint (tree, hf_value_length, tvb, offset, tokenlen, bytes);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen > 20) {\r\nreturn -1;\r\n}\r\nif (tokenlen != 0) {\r\nmemcpy (response_chars, line, tokenlen);\r\nresponse_chars[tokenlen] = '\0';\r\ncas = (guint64) strtoul (response_chars, NULL, 10);\r\nproto_tree_add_uint64 (tree, hf_cas, tvb, offset, tokenlen, cas);\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen != 0) {\r\nreturn -1;\r\n}\r\n}\r\noffset = next_offset;\r\noffset = content_data_dissector (tvb, pinfo, tree, offset, bytes, opcode);\r\nif (offset == -1) {\r\nreturn offset;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\nmemcache_response_dissector (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset,\r\nconst guchar *line, const guchar *lineend, guint8 opcode)\r\n{\r\nconst guchar *next_token;\r\nint tokenlen;\r\nswitch (opcode) {\r\ncase OP_GET:\r\ncase OP_GETS:\r\nreturn get_response_dissector (tvb, pinfo, tree, offset);\r\ncase OP_VERSION:\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn -1;\r\n}\r\nif ((tokenlen == 7) && strncmp (line, "VERSION", tokenlen) == 0) {\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\n} else {\r\nreturn -1;\r\n}\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn -1;\r\n}\r\nproto_tree_add_item (tree, hf_version, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen != 0) {\r\nreturn -1;\r\n}\r\nreturn offset;\r\ncase OP_STAT:\r\nreturn stat_dissector (tvb, tree, offset);\r\ndefault:\r\nbreak;\r\n}\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn -1;\r\n}\r\nif ((tokenlen == 6 && strncmp (line, "STORED", tokenlen) == 0) ||\r\n(tokenlen == 10 && strncmp (line, "NOT_STORED", tokenlen) == 0) ||\r\n(tokenlen == 6 && strncmp (line, "EXISTS", tokenlen) == 0) ||\r\n(tokenlen == 9 && strncmp (line, "NOT_FOUND", tokenlen) == 0) ||\r\n(tokenlen == 7 && strncmp (line, "DELETED", tokenlen) == 0) ||\r\n(tokenlen == 2 && strncmp (line, "OK", tokenlen) == 0) ||\r\n(tokenlen == 3 && strncmp (line, "END", tokenlen) == 0))\r\n{\r\nproto_tree_add_item (tree, hf_response, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\noffset += (int) (next_token - line);\r\nreturn offset;\r\n}\r\nif (opcode == OP_INCREMENT) {\r\nreturn incr_dissector (tvb, tree, offset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\nmemcache_request_dissector (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset,\r\nconst guchar *line, const guchar *lineend, guint8 opcode)\r\n{\r\nconst guchar *next_token;\r\nint tokenlen;\r\nguint16 flags;\r\nguint32 expiration;\r\nguint32 bytes;\r\nguint64 cas;\r\ngchar response_chars[21];\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn -1;\r\n}\r\nproto_tree_add_item (tree, hf_command, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\nswitch (opcode) {\r\ncase OP_SET:\r\ncase OP_ADD:\r\ncase OP_REPLACE:\r\ncase OP_APPEND:\r\ncase OP_PREPEND:\r\ncase OP_CAS:\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn -1;\r\n}\r\ndissect_key (tvb, pinfo, tree, offset, tokenlen, opcode, TRUE);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0 || tokenlen > 5) {\r\nreturn -1;\r\n}\r\nmemcpy (response_chars, line, tokenlen);\r\nresponse_chars[tokenlen] = '\0';\r\nflags = (guint16) strtoul (response_chars, NULL, 10);\r\nproto_tree_add_uint (tree, hf_flags, tvb, offset, tokenlen, flags);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0 || tokenlen > 10) {\r\nreturn -1;\r\n}\r\nmemcpy (response_chars, line, tokenlen);\r\nresponse_chars[tokenlen] = '\0';\r\nexpiration = (guint32) strtoul (response_chars, NULL, 10);\r\nproto_tree_add_uint (tree, hf_expiration, tvb, offset, tokenlen, expiration);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0 || tokenlen > 10) {\r\nreturn -1;\r\n}\r\nmemcpy (response_chars, line, tokenlen);\r\nresponse_chars[tokenlen] = '\0';\r\nbytes = (guint32) strtoul (response_chars, NULL, 10);\r\nproto_tree_add_uint (tree, hf_value_length, tvb, offset, tokenlen, bytes);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\nif (opcode == OP_CAS) {\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0 || tokenlen > 20) {\r\nreturn -1;\r\n}\r\nmemcpy (response_chars, line, tokenlen);\r\nresponse_chars[tokenlen] = '\0';\r\ncas = (guint64) strtoul (response_chars, NULL, 10);\r\nproto_tree_add_uint64 (tree, hf_cas, tvb, offset, tokenlen, cas);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\n}\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen != 0) {\r\nif (tokenlen == 7 && strncmp (line, "noreply", 7) == 0) {\r\nproto_tree_add_item (tree, hf_noreply, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\n}\r\noffset += (int) (next_token - line);\r\n}\r\noffset += 2 ;\r\noffset = content_data_dissector (tvb, pinfo, tree, offset, bytes, opcode);\r\nif (offset == -1) {\r\nreturn offset;\r\n}\r\nbreak;\r\ncase OP_INCREMENT:\r\ncase OP_DECREMENT:\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn -1;\r\n}\r\ndissect_key (tvb, pinfo, tree, offset, tokenlen, opcode, TRUE);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn -1;\r\n}\r\nproto_tree_add_item (tree, hf_value, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn offset;\r\n}\r\nif (tokenlen == 7 && strncmp (line, "noreply", 7) == 0) {\r\nproto_tree_add_item (tree, hf_noreply, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\n} else {\r\nreturn -1;\r\n}\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn offset;\r\n} else {\r\nreturn -1;\r\n}\r\nbreak;\r\ncase OP_DELETE:\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn -1;\r\n}\r\ndissect_key (tvb, pinfo, tree, offset, tokenlen, opcode, TRUE);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn offset;\r\n}\r\nif (tokenlen <= 10) {\r\nif (tokenlen == 7 && strncmp (line, "noreply", 7) == 0) {\r\nproto_tree_add_item (tree, hf_noreply, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\n} else {\r\nmemcpy (response_chars, line, tokenlen);\r\nresponse_chars[tokenlen] = '\0';\r\nexpiration = (guint32) strtoul (response_chars, NULL, 10);\r\nproto_tree_add_uint (tree, hf_expiration, tvb, offset, tokenlen, expiration);\r\n}\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\n} else {\r\nreturn -1;\r\n}\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn offset;\r\n} else {\r\nreturn -1;\r\n}\r\nbreak;\r\ncase OP_GET:\r\ncase OP_GETS:\r\nwhile (tokenlen != 0) {\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn offset;\r\n}\r\ndissect_key (tvb, pinfo, tree, offset, tokenlen, opcode, TRUE);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\n}\r\nbreak;\r\ncase OP_STAT:\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn offset;\r\n} else {\r\nproto_tree_add_item (tree, hf_subcommand, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\n}\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn offset;\r\n} else {\r\nreturn -1;\r\n}\r\nbreak;\r\ncase OP_FLUSH:\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn offset;\r\n}\r\nif (tokenlen <= 10) {\r\nif (tokenlen == 7 && strncmp (line, "noreply", 7) == 0) {\r\nproto_tree_add_item (tree, hf_noreply, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\n} else {\r\nmemcpy (response_chars, line, tokenlen);\r\nresponse_chars[tokenlen] = '\0';\r\nexpiration = (guint32) strtoul (response_chars, NULL, 10);\r\nproto_tree_add_uint (tree, hf_expiration, tvb, offset, tokenlen, expiration);\r\n}\r\noffset += (int) (next_token - line);\r\nline = next_token;\r\n} else {\r\nreturn -1;\r\n}\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn offset;\r\n}\r\nif (tokenlen == 7 && strncmp (line, "noreply", 7) == 0) {\r\nproto_tree_add_item (tree, hf_noreply, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\noffset += (int) (next_token - line);\r\n} else {\r\nreturn -1;\r\n}\r\nbreak;\r\ncase OP_VERBOSE:\r\nbreak;\r\ncase OP_VERSION:\r\ncase OP_QUIT:\r\ntokenlen = get_token_len (line, lineend, &next_token);\r\nif (tokenlen == 0) {\r\nreturn offset;\r\n} else {\r\nreturn -1;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\nis_memcache_request_or_reply (const gchar *data, int linelen, guint8 *opcode,\r\nmemcache_type_t *type, int *expect_content_length,\r\nReqRespDissector *reqresp_dissector)\r\n{\r\nconst guchar *ptr = (const guchar *)data;\r\nint is_request_or_response = FALSE;\r\nint indx = 0;\r\nwhile (indx < linelen) {\r\nif (*ptr == ' ')\r\nbreak;\r\nptr++;\r\nindx++;\r\n}\r\nswitch (indx) {\r\ncase 2:\r\nif (strncmp (data, "OK", indx) == 0) {\r\n*type = MEMCACHE_RESPONSE;\r\nis_request_or_response = TRUE;\r\n}\r\nbreak;\r\ncase 3:\r\nif (strncmp (data, "END", indx) == 0) {\r\n*type = MEMCACHE_RESPONSE;\r\nis_request_or_response = TRUE;\r\n}\r\nbreak;\r\ncase 4:\r\nif (strncmp (data, "STAT", indx) == 0) {\r\n*opcode = OP_STAT;\r\n*type = MEMCACHE_RESPONSE;\r\nis_request_or_response = TRUE;\r\n}\r\nbreak;\r\ncase 5:\r\nif (strncmp (data, "VALUE", indx) == 0) {\r\n*opcode = OP_GET;\r\n*type = MEMCACHE_RESPONSE;\r\n*expect_content_length = TRUE;\r\nis_request_or_response = TRUE;\r\n}\r\nbreak;\r\ncase 6:\r\nif (strncmp (data, "EXISTS", indx) == 0 ||\r\nstrncmp (data, "STORED", indx) == 0) {\r\n*type = MEMCACHE_RESPONSE;\r\nis_request_or_response = TRUE;\r\n}\r\nbreak;\r\ncase 7:\r\nif (strncmp (data, "VERSION", indx) == 0) {\r\n*opcode = OP_VERSION;\r\n*type = MEMCACHE_RESPONSE;\r\nis_request_or_response = TRUE;\r\n} else if (strncmp (data, "DELETED", indx) == 0) {\r\n*opcode = OP_DELETE;\r\n*type = MEMCACHE_RESPONSE;\r\nis_request_or_response = TRUE;\r\n}\r\nbreak;\r\ncase 9:\r\nif (strncmp (data, "NOT_FOUND", indx) == 0) {\r\n*type = MEMCACHE_RESPONSE;\r\nis_request_or_response = TRUE;\r\n}\r\nbreak;\r\ncase 10:\r\nif (strncmp (data, "NOT_STORED", indx) == 0) {\r\n*type = MEMCACHE_RESPONSE;\r\nis_request_or_response = TRUE;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (is_request_or_response && reqresp_dissector) {\r\n*reqresp_dissector = memcache_response_dissector;\r\nreturn is_request_or_response;\r\n}\r\nswitch (indx) {\r\ncase 3:\r\nif (strncmp (data, "get", indx) == 0) {\r\n*opcode = OP_GET;\r\n*type = MEMCACHE_REQUEST;\r\nis_request_or_response = TRUE;\r\n} else if (strncmp (data, "set", indx) == 0) {\r\n*opcode = OP_SET;\r\n*type = MEMCACHE_REQUEST;\r\n*expect_content_length = TRUE;\r\nis_request_or_response = TRUE;\r\n} else if (strncmp (data, "add", indx) == 0) {\r\n*opcode = OP_ADD;\r\n*type = MEMCACHE_REQUEST;\r\n*expect_content_length = TRUE;\r\nis_request_or_response = TRUE;\r\n} else if (strncmp (data, "cas", indx) == 0) {\r\n*opcode = OP_CAS;\r\n*type = MEMCACHE_REQUEST;\r\n*expect_content_length = TRUE;\r\nis_request_or_response = TRUE;\r\n}\r\nbreak;\r\ncase 4:\r\nif (strncmp (data, "gets", indx) == 0) {\r\n*opcode = OP_GETS;\r\n*type = MEMCACHE_REQUEST;\r\nis_request_or_response = TRUE;\r\n} else if (strncmp (data, "incr", indx) == 0) {\r\n*opcode = OP_INCREMENT;\r\n*type = MEMCACHE_REQUEST;\r\nis_request_or_response = TRUE;\r\n} else if (strncmp (data, "decr", indx) == 0) {\r\n*opcode = OP_DECREMENT;\r\n*type = MEMCACHE_REQUEST;\r\nis_request_or_response = TRUE;\r\n} else if (strncmp (data, "quit", indx) == 0) {\r\n*opcode = OP_QUIT;\r\n*type = MEMCACHE_REQUEST;\r\nis_request_or_response = TRUE;\r\n}\r\nbreak;\r\ncase 5:\r\nif (strncmp (data, "stats", indx) == 0) {\r\n*opcode = OP_STAT;\r\n*type = MEMCACHE_REQUEST;\r\nis_request_or_response = TRUE;\r\n}\r\nbreak;\r\ncase 6:\r\nif (strncmp (data, "append", indx) == 0) {\r\n*opcode = OP_APPEND;\r\n*type = MEMCACHE_REQUEST;\r\n*expect_content_length = TRUE;\r\nis_request_or_response = TRUE;\r\n} else if (strncmp (data, "delete", indx) == 0) {\r\n*opcode = OP_DELETE;\r\n*type = MEMCACHE_REQUEST;\r\nis_request_or_response = TRUE;\r\n}\r\nbreak;\r\ncase 7:\r\nif (strncmp (data, "replace", indx) == 0) {\r\n*opcode = OP_REPLACE;\r\n*type = MEMCACHE_REQUEST;\r\n*expect_content_length = TRUE;\r\nis_request_or_response = TRUE;\r\n} else if (strncmp (data, "prepend", indx) == 0) {\r\n*opcode = OP_PREPEND;\r\n*type = MEMCACHE_REQUEST;\r\n*expect_content_length = TRUE;\r\nis_request_or_response = TRUE;\r\n} else if (strncmp (data, "version", indx) == 0) {\r\n*opcode = OP_VERSION;\r\n*type = MEMCACHE_REQUEST;\r\nis_request_or_response = TRUE;\r\n}\r\nbreak;\r\ncase 9:\r\nif (strncmp (data, "flush_all", indx) == 0) {\r\n*opcode = OP_FLUSH;\r\n*type = MEMCACHE_REQUEST;\r\nis_request_or_response = TRUE;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (is_request_or_response && reqresp_dissector) {\r\n*reqresp_dissector = memcache_request_dissector;\r\nreturn is_request_or_response;\r\n}\r\nreturn is_request_or_response;\r\n}\r\nstatic void\r\ndissect_memcache_text (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nint offset = 0;\r\nint len;\r\nwhile (tvb_reported_length_remaining (tvb, offset) != 0) {\r\nlen = dissect_memcache_message (tvb, offset, pinfo, tree);\r\nif (len == -1)\r\nbreak;\r\noffset += len;\r\ncol_set_fence (pinfo->cinfo, COL_INFO);\r\n}\r\n}\r\nstatic int\r\ndissect_memcache_tcp (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ngint offset = 0;\r\nguint8 magic;\r\nmagic = tvb_get_guint8 (tvb, offset);\r\nif (try_val_to_str (magic, magic_vals) != NULL) {\r\ntcp_dissect_pdus (tvb, pinfo, tree, memcache_desegment_body, 12,\r\nget_memcache_pdu_len, dissect_memcache, data);\r\n} else {\r\ndissect_memcache_text (tvb, pinfo, tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_memcache_udp (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ngint offset = 0;\r\nguint8 magic;\r\nmagic = tvb_get_guint8 (tvb, offset);\r\nif (try_val_to_str (magic, magic_vals) != NULL) {\r\ndissect_memcache (tvb, pinfo, tree, data);\r\n} else {\r\ndissect_memcache_message (tvb, 0, pinfo, tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_memcache (void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_magic,\r\n{ "Magic", "memcache.magic",\r\nFT_UINT8, BASE_DEC, VALS (magic_vals), 0x0,\r\n"Magic number", HFILL } },\r\n{ &hf_opcode,\r\n{ "Opcode", "memcache.opcode",\r\nFT_UINT8, BASE_DEC, VALS (opcode_vals), 0x0,\r\n"Command code", HFILL } },\r\n{ &hf_extras_length,\r\n{ "Extras length", "memcache.extras.length",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Length in bytes of the command extras", HFILL } },\r\n{ &hf_key_length,\r\n{ "Key Length", "memcache.key.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Length in bytes of the text key that follows the command extras", HFILL } },\r\n{ &hf_value_length,\r\n{ "Value length", "memcache.value.length",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Length in bytes of the value that follows the key", HFILL } },\r\n{ &hf_data_type,\r\n{ "Data type", "memcache.data_type",\r\nFT_UINT8, BASE_DEC, VALS (data_type_vals), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_reserved,\r\n{ "Reserved", "memcache.reserved",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Reserved for future use", HFILL } },\r\n{ &hf_status,\r\n{ "Status", "memcache.status",\r\nFT_UINT16, BASE_DEC, VALS (status_vals), 0x0,\r\n"Status of the response", HFILL } },\r\n{ &hf_total_body_length,\r\n{ "Total body length", "memcache.total_body_length",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Length in bytes of extra + key + value", HFILL } },\r\n{ &hf_opaque,\r\n{ "Opaque", "memcache.opaque",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_cas,\r\n{ "CAS", "memcache.cas",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\n"Data version check", HFILL } },\r\n{ &hf_extras,\r\n{ "Extras", "memcache.extras",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_extras_flags,\r\n{ "Flags", "memcache.extras.flags",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_extras_expiration,\r\n{ "Expiration", "memcache.extras.expiration",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_extras_delta,\r\n{ "Amount to add", "memcache.extras.delta",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_extras_initial,\r\n{ "Initial value", "memcache.extras.initial",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_extras_unknown,\r\n{ "Unknown", "memcache.extras.unknown",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Unknown Extras", HFILL } },\r\n{ &hf_key,\r\n{ "Key", "memcache.key",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_value,\r\n{ "Value", "memcache.value",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_uint64_response,\r\n{ "Response", "memcache.extras.response",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_command,\r\n{ "Command", "memcache.command",\r\nFT_STRING, BASE_NONE , NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_subcommand,\r\n{ "Sub command", "memcache.subcommand",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Sub command if any", HFILL } },\r\n{ &hf_flags,\r\n{ "Flags", "memcache.flags",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_expiration,\r\n{ "Expiration", "memcache.expiration",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_noreply,\r\n{ "Noreply", "memcache.noreply",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Client does not expect a reply", HFILL } },\r\n{ &hf_response,\r\n{ "Response", "memcache.response",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Response command", HFILL } },\r\n{ &hf_version,\r\n{ "Version", "memcache.version",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Version of running memcache", HFILL } },\r\n{ &hf_slabclass,\r\n{ "Slab class", "memcache.slabclass",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Slab class of a stat", HFILL } },\r\n{ &hf_name,\r\n{ "Stat name", "memcache.name",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Name of a stat", HFILL } },\r\n{ &hf_name_value,\r\n{ "Stat value", "memcache.name_value",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Value of a stat", HFILL } },\r\n};\r\nstatic gint *ett[] = {\r\n&ett_memcache,\r\n&ett_extras\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_extras_unknown, { "memcache.extras.notexpected", PI_UNDECODED, PI_WARN, "shall not have Extras", EXPFILL }},\r\n{ &ei_extras_missing, { "memcache.extras.missing", PI_UNDECODED, PI_WARN, "must have Extras", EXPFILL }},\r\n{ &ei_key_unknown, { "memcache.key.notexpected", PI_UNDECODED, PI_WARN, "shall not have Key", EXPFILL }},\r\n{ &ei_key_missing, { "memcache.key.missing", PI_UNDECODED, PI_WARN, "must have Key", EXPFILL }},\r\n{ &ei_value_length, { "memcache.value.invalid", PI_UNDECODED, PI_WARN, "Illegal Value length, should be 8", EXPFILL }},\r\n{ &ei_value_unknown, { "memcache.value.notexpected", PI_UNDECODED, PI_WARN, "shall not have Value", EXPFILL }},\r\n{ &ei_value_missing, { "memcache.value.missing", PI_UNDECODED, PI_WARN, "must have Value", EXPFILL }},\r\n{ &ei_magic_unknown, { "memcache.magic.unknown", PI_UNDECODED, PI_WARN, "Unknown magic byte", EXPFILL }},\r\n{ &ei_opcode_unknown, { "memcache.opcode.unknown", PI_UNDECODED, PI_WARN, "Unknown opcode", EXPFILL }},\r\n{ &ei_status_response, { "memcache.status.response", PI_RESPONSE_CODE, PI_NOTE, "Error response", EXPFILL }},\r\n{ &ei_reserved_value, { "memcache.reserved.expert", PI_UNDECODED, PI_WARN, "Reserved value", EXPFILL }},\r\n};\r\nmodule_t *memcache_module;\r\nexpert_module_t *expert_memcache;\r\nproto_memcache = proto_register_protocol (PNAME, PSNAME, PFNAME);\r\nmemcache_tcp_handle = register_dissector ("memcache.tcp", dissect_memcache_tcp, proto_memcache);\r\nmemcache_udp_handle = register_dissector ("memcache.udp", dissect_memcache_udp, proto_memcache);\r\nproto_register_field_array (proto_memcache, hf, array_length (hf));\r\nproto_register_subtree_array (ett, array_length (ett));\r\nexpert_memcache = expert_register_protocol(proto_memcache);\r\nexpert_register_field_array(expert_memcache, ei, array_length(ei));\r\nmemcache_module = prefs_register_protocol (proto_memcache, proto_reg_handoff_memcache);\r\nprefs_register_bool_preference (memcache_module, "desegment_headers",\r\n"Reassemble MEMCACHE headers spanning multiple TCP segments",\r\n"Whether the MEMCACHE dissector should reassemble headers "\r\n"of a request spanning multiple TCP segments. "\r\n"To use this option, you must also enable "\r\n"\"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&memcache_desegment_headers);\r\nprefs_register_bool_preference (memcache_module, "desegment_pdus",\r\n"Reassemble PDUs spanning multiple TCP segments",\r\n"Whether the memcache dissector should reassemble PDUs"\r\n" spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors"\r\n" to reassemble TCP streams\" in the TCP protocol settings.",\r\n&memcache_desegment_body);\r\nrange_convert_str(&memcache_tcp_port_range, MEMCACHE_DEFAULT_RANGE, 65535);\r\nrange_convert_str(&memcache_udp_port_range, MEMCACHE_DEFAULT_RANGE, 65535);\r\nprefs_register_range_preference(memcache_module, "tcp.ports", \\r\n"MEMCACHE TCP Port range", \\r\n"MEMCACHE TCP Port range", \\r\n&memcache_tcp_port_range, \\r\n65535);\r\nprefs_register_range_preference(memcache_module, "udp.ports", \\r\n"MEMCACHE UDP Port range", \\r\n"MEMCACHE UDP Port range", \\r\n&memcache_udp_port_range, \\r\n65535);\r\n}\r\nvoid\r\nproto_reg_handoff_memcache (void)\r\n{\r\nstatic range_t *orig_memcache_tcp_port_range = NULL;\r\nstatic range_t *orig_memcache_udp_port_range = NULL;\r\ndissector_delete_uint_range("tcp.port", orig_memcache_tcp_port_range, memcache_tcp_handle);\r\ndissector_delete_uint_range("udp.port", orig_memcache_udp_port_range, memcache_udp_handle);\r\ng_free(orig_memcache_tcp_port_range);\r\ng_free(orig_memcache_udp_port_range);\r\norig_memcache_tcp_port_range = range_copy(memcache_tcp_port_range);\r\norig_memcache_udp_port_range = range_copy(memcache_udp_port_range);\r\ndissector_add_uint_range("tcp.port", orig_memcache_tcp_port_range, memcache_tcp_handle);\r\ndissector_add_uint_range("udp.port", orig_memcache_udp_port_range, memcache_udp_handle);\r\n}
