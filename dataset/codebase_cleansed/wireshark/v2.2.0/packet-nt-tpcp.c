static int\r\ndissect_tpcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *tpcp_tree = NULL;\r\nproto_item *ti;\r\nguint8 version, type;\r\nguint16 id, cport;\r\nstatic const int * tpcp_flags[] = {\r\n&hf_tpcp_flags_tcp,\r\n&hf_tpcp_flags_redir,\r\n&hf_tpcp_flags_xon,\r\n&hf_tpcp_flags_xoff,\r\nNULL\r\n};\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "TPCP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nversion = tvb_get_guint8(tvb, 0);\r\nif ((version != TPCP_VER_1) && (version != TPCP_VER_2)) {\r\nreturn 0;\r\n}\r\nti = proto_tree_add_protocol_format(tree, proto_tpcp, tvb, 0, -1,\r\n"Alteon WebSystems - Transparent Proxy Cache Protocol");\r\ntpcp_tree = proto_item_add_subtree(ti, ett_tpcp);\r\nproto_tree_add_item(tpcp_tree, hf_tpcp_version, tvb, 0, 1, ENC_BIG_ENDIAN);\r\ntype = tvb_get_guint8(tvb, 1);\r\nproto_tree_add_item(tpcp_tree, hf_tpcp_type, tvb, 1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(tpcp_tree, tvb, 2, hf_tpcp_flags, ett_tpcp_flags, tpcp_flags, ENC_NA);\r\nid = tvb_get_ntohs(tvb, 4);\r\nproto_tree_add_item(tpcp_tree, hf_tpcp_id, tvb, 4, 2, ENC_BIG_ENDIAN);\r\ncport = tvb_get_ntohs(tvb, 6);\r\nproto_tree_add_uint_format_value(tpcp_tree, hf_tpcp_cport, tvb, 6, 2, cport,\r\n"%s", udp_port_to_display(wmem_packet_scope(), cport));\r\nproto_tree_add_item(tpcp_tree, hf_tpcp_caddr, tvb, 8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tpcp_tree, hf_tpcp_saddr, tvb, 12, 4, ENC_BIG_ENDIAN);\r\nif (version == TPCP_VER_2) {\r\nproto_tree_add_item(tpcp_tree, hf_tpcp_vaddr, tvb, 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tpcp_tree, hf_tpcp_rasaddr, tvb, 20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tpcp_tree, hf_tpcp_signature, tvb, 24, 4, ENC_BIG_ENDIAN);\r\n}\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,"%s id %d CPort %s CIP %s SIP %s",\r\nval_to_str_const(type, type_vals, "Unknown"),\r\nid,\r\nudp_port_to_display(wmem_packet_scope(), cport),\r\ntvb_ip_to_str(tvb, 8),\r\ntvb_ip_to_str(tvb, 12));\r\nif (version == TPCP_VER_1)\r\nreturn TPCP_VER_1_LENGTH;\r\nreturn TPCP_VER_2_LENGTH;\r\n}\r\nvoid\r\nproto_register_tpcp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_tpcp_version,\r\n{ "Version", "tpcp.version", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"TPCP version", HFILL }},\r\n{ &hf_tpcp_type,\r\n{ "Type", "tpcp.type", FT_UINT8, BASE_DEC, VALS(type_vals), 0x0,\r\n"PDU type", HFILL }},\r\n{ &hf_tpcp_flags,\r\n{ "Flags", "tpcp.flags", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tpcp_flags_tcp,\r\n{ "UDP/TCP", "tpcp.flags.tcp", FT_BOOLEAN, 8, TFS(&tfs_set_notset), TF_TPCP_UDPTCP,\r\n"Protocol type", HFILL }},\r\n{ &hf_tpcp_flags_redir,\r\n{ "No Redirect", "tpcp.flags.redir", FT_BOOLEAN, 8, TFS(&tfs_set_notset), TF_TPCP_DONTREDIRECT,\r\n"Don't redirect client", HFILL }},\r\n{ &hf_tpcp_flags_xon,\r\n{ "XON", "tpcp.flags.xon", FT_BOOLEAN, 8, TFS(&tfs_set_notset), TF_TPCP_XON,\r\nNULL, HFILL }},\r\n{ &hf_tpcp_flags_xoff,\r\n{ "XOFF", "tpcp.flags.xoff", FT_BOOLEAN, 8, TFS(&tfs_set_notset), TF_TPCP_XOFF,\r\nNULL, HFILL }},\r\n{ &hf_tpcp_id,\r\n{ "Client indent", "tpcp.cid", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tpcp_cport,\r\n{ "Client Source Port", "tpcp.cport", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tpcp_caddr,\r\n{ "Client Source IP address", "tpcp.caddr", FT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tpcp_saddr,\r\n{ "Server IP address", "tpcp.saddr", FT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tpcp_vaddr,\r\n{ "Virtual Server IP address", "tpcp.vaddr", FT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tpcp_rasaddr,\r\n{ "RAS server IP address", "tpcp.rasaddr", FT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tpcp_signature,\r\n{ "Signature", "tpcp.signature", FT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_tpcp,\r\n&ett_tpcp_flags,\r\n};\r\nproto_tpcp = proto_register_protocol("Alteon - Transparent Proxy Cache Protocol",\r\n"TPCP", "tpcp");\r\nproto_register_field_array(proto_tpcp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_tpcp(void)\r\n{\r\ndissector_handle_t tpcp_handle;\r\ntpcp_handle = create_dissector_handle(dissect_tpcp, proto_tpcp);\r\ndissector_add_uint("udp.port", UDP_PORT_TPCP, tpcp_handle);\r\n}
