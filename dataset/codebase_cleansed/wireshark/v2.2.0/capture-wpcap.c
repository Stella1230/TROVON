void\r\nload_wpcap(void)\r\n{\r\nstatic const symbol_table_t symbols[] = {\r\nSYM(pcap_lookupdev, FALSE),\r\nSYM(pcap_close, FALSE),\r\nSYM(pcap_stats, FALSE),\r\nSYM(pcap_dispatch, FALSE),\r\nSYM(pcap_snapshot, FALSE),\r\nSYM(pcap_datalink, FALSE),\r\nSYM(pcap_setfilter, FALSE),\r\nSYM(pcap_geterr, FALSE),\r\nSYM(pcap_compile, FALSE),\r\nSYM(pcap_compile_nopcap, FALSE),\r\nSYM(pcap_lookupnet, FALSE),\r\n#ifdef HAVE_PCAP_REMOTE\r\nSYM(pcap_open, FALSE),\r\nSYM(pcap_findalldevs_ex, FALSE),\r\nSYM(pcap_createsrcstr, FALSE),\r\n#endif\r\nSYM(pcap_open_live, FALSE),\r\n#ifdef HAVE_PCAP_OPEN_DEAD\r\nSYM(pcap_open_dead, FALSE),\r\n#endif\r\n#ifdef HAVE_PCAP_SETSAMPLING\r\nSYM(pcap_setsampling, TRUE),\r\n#endif\r\nSYM(pcap_loop, FALSE),\r\nSYM(pcap_freecode, TRUE),\r\n#ifdef HAVE_PCAP_FINDALLDEVS\r\nSYM(pcap_findalldevs, TRUE),\r\nSYM(pcap_freealldevs, TRUE),\r\n#endif\r\n#ifdef HAVE_PCAP_DATALINK_NAME_TO_VAL\r\nSYM(pcap_datalink_name_to_val, TRUE),\r\n#endif\r\n#ifdef HAVE_PCAP_DATALINK_VAL_TO_NAME\r\nSYM(pcap_datalink_val_to_name, TRUE),\r\n#endif\r\n#ifdef HAVE_PCAP_DATALINK_VAL_TO_DESCRIPTION\r\nSYM(pcap_datalink_val_to_description, TRUE),\r\n#endif\r\n#ifdef HAVE_PCAP_BREAKLOOP\r\nSYM(pcap_breakloop, FALSE),\r\n#endif\r\nSYM(pcap_lib_version, TRUE),\r\nSYM(pcap_setbuff, TRUE),\r\nSYM(pcap_next_ex, TRUE),\r\n#ifdef HAVE_PCAP_LIST_DATALINKS\r\nSYM(pcap_list_datalinks, FALSE),\r\n#endif\r\n#ifdef HAVE_PCAP_SET_DATALINK\r\nSYM(pcap_set_datalink, FALSE),\r\n#endif\r\n#ifdef HAVE_PCAP_FREE_DATALINKS\r\nSYM(pcap_free_datalinks, TRUE),\r\n#endif\r\n#ifdef HAVE_BPF_IMAGE\r\nSYM(bpf_image, FALSE),\r\n#endif\r\n#ifdef HAVE_PCAP_CREATE\r\nSYM(pcap_create, TRUE),\r\nSYM(pcap_set_snaplen, TRUE),\r\nSYM(pcap_set_promisc, TRUE),\r\nSYM(pcap_can_set_rfmon, TRUE),\r\nSYM(pcap_set_rfmon, TRUE),\r\nSYM(pcap_set_timeout, FALSE),\r\nSYM(pcap_set_buffer_size, FALSE),\r\nSYM(pcap_activate, TRUE),\r\nSYM(pcap_statustostr, TRUE),\r\n#endif\r\n{ NULL, NULL, FALSE }\r\n};\r\nGModule *wh;\r\nconst symbol_table_t *sym;\r\nwh = ws_module_open("wpcap.dll", 0);\r\nif (!wh) {\r\nreturn;\r\n}\r\nsym = symbols;\r\nwhile (sym->name) {\r\nif (!g_module_symbol(wh, sym->name, sym->ptr)) {\r\nif (sym->optional) {\r\n*sym->ptr = NULL;\r\n} else {\r\nreturn;\r\n}\r\n}\r\nsym++;\r\n}\r\nhas_wpcap = TRUE;\r\n}\r\nchar *\r\ncant_load_winpcap_err(const char *app_name)\r\n{\r\nreturn g_strdup_printf(\r\n"Unable to load WinPcap (wpcap.dll); %s will not be able to capture\n"\r\n"packets.\n"\r\n"\n"\r\n"In order to capture packets, WinPcap must be installed; see\n"\r\n"\n"\r\n" https://www.winpcap.org/\n"\r\n"\n"\r\n"for a downloadable version of WinPcap and for instructions on how to install\n"\r\n"WinPcap.",\r\napp_name);\r\n}\r\nchar*\r\npcap_lookupdev (char *a)\r\n{\r\nif (!has_wpcap) {\r\nreturn NULL;\r\n}\r\nreturn p_pcap_lookupdev(a);\r\n}\r\nvoid\r\npcap_close(pcap_t *a)\r\n{\r\ng_assert(has_wpcap);\r\np_pcap_close(a);\r\n}\r\nint\r\npcap_stats(pcap_t *a, struct pcap_stat *b)\r\n{\r\ng_assert(has_wpcap);\r\nreturn p_pcap_stats(a, b);\r\n}\r\nint\r\npcap_dispatch(pcap_t *a, int b, pcap_handler c, guchar *d)\r\n{\r\ng_assert(has_wpcap);\r\nreturn p_pcap_dispatch(a, b, c, d);\r\n}\r\nint\r\npcap_snapshot(pcap_t *a)\r\n{\r\ng_assert(has_wpcap);\r\nreturn p_pcap_snapshot(a);\r\n}\r\nint\r\npcap_datalink(pcap_t *a)\r\n{\r\ng_assert(has_wpcap);\r\nreturn p_pcap_datalink(a);\r\n}\r\nint\r\npcap_set_datalink(pcap_t *p, int dlt)\r\n{\r\ng_assert(has_wpcap);\r\nreturn p_pcap_set_datalink(p, dlt);\r\n}\r\nint\r\npcap_setfilter(pcap_t *a, struct bpf_program *b)\r\n{\r\ng_assert(has_wpcap);\r\nreturn p_pcap_setfilter(a, b);\r\n}\r\nchar*\r\npcap_geterr(pcap_t *a)\r\n{\r\ng_assert(has_wpcap);\r\nreturn p_pcap_geterr(a);\r\n}\r\nint\r\npcap_compile(pcap_t *a, struct bpf_program *b, const char *c, int d,\r\nbpf_u_int32 e)\r\n{\r\ng_assert(has_wpcap);\r\nreturn p_pcap_compile(a, b, c, d, e);\r\n}\r\nint\r\npcap_compile_nopcap(int a, int b, struct bpf_program *c, const char *d, int e,\r\nbpf_u_int32 f)\r\n{\r\ng_assert(has_wpcap);\r\nreturn p_pcap_compile_nopcap(a, b, c, d, e, f);\r\n}\r\nint\r\npcap_lookupnet(const char *a, bpf_u_int32 *b, bpf_u_int32 *c, char *d)\r\n{\r\ng_assert(has_wpcap);\r\nreturn p_pcap_lookupnet(a, b, c, d);\r\n}\r\npcap_t*\r\npcap_open_live(const char *a, int b, int c, int d, char *e)\r\n{\r\nif (!has_wpcap) {\r\ng_snprintf(e, PCAP_ERRBUF_SIZE,\r\n"unable to load WinPcap (wpcap.dll); can't open %s to capture",\r\na);\r\nreturn NULL;\r\n}\r\nreturn p_pcap_open_live(a, b, c, d, e);\r\n}\r\npcap_t*\r\npcap_open_dead(int a, int b)\r\n{\r\nif (!has_wpcap) {\r\nreturn NULL;\r\n}\r\nreturn p_pcap_open_dead(a, b);\r\n}\r\nchar *\r\nbpf_image(const struct bpf_insn *a, int b)\r\n{\r\nif (!has_wpcap) {\r\nreturn NULL;\r\n}\r\nreturn p_bpf_image(a, b);\r\n}\r\npcap_t*\r\npcap_open(const char *a, int b, int c, int d, struct pcap_rmtauth *e, char *f)\r\n{\r\nif (!has_wpcap) {\r\ng_snprintf(f, PCAP_ERRBUF_SIZE,\r\n"unable to load WinPcap (wpcap.dll); can't open %s to capture",\r\na);\r\nreturn NULL;\r\n}\r\nreturn p_pcap_open(a, b, c, d, e, f);\r\n}\r\nint\r\npcap_findalldevs_ex(char *a, struct pcap_rmtauth *b, pcap_if_t **c, char *d)\r\n{\r\ng_assert(has_wpcap);\r\nreturn p_pcap_findalldevs_ex(a, b, c, d);\r\n}\r\nint\r\npcap_createsrcstr(char *a, int b, const char *c, const char *d, const char *e,\r\nchar *f)\r\n{\r\ng_assert(has_wpcap);\r\nreturn p_pcap_createsrcstr(a, b, c, d, e, f);\r\n}\r\nstruct pcap_samp *\r\npcap_setsampling(pcap_t *a)\r\n{\r\ng_assert(has_wpcap);\r\nif (p_pcap_setsampling != NULL) {\r\nreturn p_pcap_setsampling(a);\r\n}\r\nreturn NULL;\r\n}\r\nint\r\npcap_loop(pcap_t *a, int b, pcap_handler c, guchar *d)\r\n{\r\ng_assert(has_wpcap);\r\nreturn p_pcap_loop(a, b, c, d);\r\n}\r\nvoid\r\npcap_freecode(struct bpf_program *a)\r\n{\r\ng_assert(has_wpcap);\r\nif(p_pcap_freecode) {\r\np_pcap_freecode(a);\r\n}\r\n}\r\nint\r\npcap_findalldevs(pcap_if_t **a, char *b)\r\n{\r\ng_assert(has_wpcap && p_pcap_findalldevs != NULL);\r\nreturn p_pcap_findalldevs(a, b);\r\n}\r\nvoid\r\npcap_freealldevs(pcap_if_t *a)\r\n{\r\ng_assert(has_wpcap && p_pcap_freealldevs != NULL);\r\np_pcap_freealldevs(a);\r\n}\r\npcap_t *\r\npcap_create(const char *a, char *b)\r\n{\r\ng_assert(has_wpcap && p_pcap_create != NULL);\r\nreturn p_pcap_create(a, b);\r\n}\r\nint\r\npcap_set_snaplen(pcap_t *a, int b)\r\n{\r\ng_assert(has_wpcap && p_pcap_set_snaplen != NULL);\r\nreturn p_pcap_set_snaplen(a, b);\r\n}\r\nint\r\npcap_set_promisc(pcap_t *a, int b)\r\n{\r\ng_assert(has_wpcap && p_pcap_set_promisc != NULL);\r\nreturn p_pcap_set_promisc(a, b);\r\n}\r\nint\r\npcap_can_set_rfmon(pcap_t *a)\r\n{\r\ng_assert(has_wpcap);\r\nif (p_pcap_can_set_rfmon != NULL) {\r\nreturn p_pcap_can_set_rfmon(a);\r\n}\r\nreturn 0;\r\n}\r\nint\r\npcap_set_rfmon(pcap_t *a, int b)\r\n{\r\ng_assert(has_wpcap && p_pcap_set_rfmon != NULL);\r\nreturn p_pcap_set_rfmon(a, b);\r\n}\r\nint\r\npcap_set_timeout(pcap_t *a, int b)\r\n{\r\ng_assert(has_wpcap && pcap_set_timeout != NULL);\r\nreturn p_pcap_set_timeout(a, b);\r\n}\r\nint\r\npcap_set_buffer_size(pcap_t *a, int b)\r\n{\r\ng_assert(has_wpcap && pcap_set_timeout != NULL);\r\nreturn p_pcap_set_buffer_size(a, b);\r\n}\r\nint\r\npcap_activate(pcap_t *a)\r\n{\r\ng_assert(has_wpcap && pcap_activate != NULL);\r\nreturn p_pcap_activate(a);\r\n}\r\nconst char *\r\npcap_statustostr(int a)\r\n{\r\nstatic char ebuf[15 + 10 + 1];\r\ng_assert(has_wpcap);\r\nif (pcap_statustostr != NULL) {\r\nreturn pcap_statustostr(a);\r\n}\r\n(void)g_snprintf(ebuf, sizeof ebuf, "Don't have pcap_statustostr(), can't translate error: %d", a);\r\nreturn(ebuf);\r\n}\r\nint\r\npcap_datalink_name_to_val(const char *name)\r\n{\r\nint i;\r\nif (has_wpcap && (p_pcap_datalink_name_to_val != NULL))\r\nreturn p_pcap_datalink_name_to_val(name);\r\nelse {\r\nfor (i = 0; dlt_choices[i].name != NULL; i++) {\r\nif (g_ascii_strcasecmp(dlt_choices[i].name + sizeof("DLT_") - 1,\r\nname) == 0)\r\nreturn dlt_choices[i].dlt;\r\n}\r\nreturn -1;\r\n}\r\n}\r\nint\r\npcap_list_datalinks(pcap_t *p, int **ddlt)\r\n{\r\ng_assert(has_wpcap);\r\nreturn p_pcap_list_datalinks(p, ddlt);\r\n}\r\nvoid\r\npcap_free_datalinks(int *ddlt)\r\n{\r\ng_assert(has_wpcap);\r\nif (p_pcap_free_datalinks != NULL)\r\np_pcap_free_datalinks(ddlt);\r\n}\r\nconst char *\r\npcap_datalink_val_to_name(int dlt)\r\n{\r\nint i;\r\nif (has_wpcap && (p_pcap_datalink_val_to_name != NULL))\r\nreturn p_pcap_datalink_val_to_name(dlt);\r\nelse {\r\nfor (i = 0; dlt_choices[i].name != NULL; i++) {\r\nif (dlt_choices[i].dlt == dlt)\r\nreturn dlt_choices[i].name + sizeof("DLT_") - 1;\r\n}\r\nreturn NULL;\r\n}\r\n}\r\nconst char *\r\npcap_datalink_val_to_description(int dlt)\r\n{\r\nint i;\r\nif (has_wpcap && (p_pcap_datalink_val_to_description != NULL))\r\nreturn p_pcap_datalink_val_to_description(dlt);\r\nelse {\r\nfor (i = 0; dlt_choices[i].name != NULL; i++) {\r\nif (dlt_choices[i].dlt == dlt)\r\nreturn (dlt_choices[i].description);\r\n}\r\nreturn NULL;\r\n}\r\n}\r\nvoid pcap_breakloop(pcap_t *a)\r\n{\r\np_pcap_breakloop(a);\r\n}\r\nint pcap_setbuff(pcap_t *a, int b)\r\n{\r\ng_assert(has_wpcap);\r\nreturn p_pcap_setbuff(a, b);\r\n}\r\nint pcap_next_ex (pcap_t *a, struct pcap_pkthdr **b, const u_char **c)\r\n{\r\ng_assert(has_wpcap);\r\nreturn p_pcap_next_ex(a, b, c);\r\n}\r\nGList *\r\nget_remote_interface_list(const char *hostname, const char *port,\r\nint auth_type, const char *username,\r\nconst char *passwd, int *err, char **err_str)\r\n{\r\nstruct pcap_rmtauth auth;\r\nchar source[PCAP_BUF_SIZE];\r\nchar errbuf[PCAP_ERRBUF_SIZE];\r\nGList *result;\r\nif (pcap_createsrcstr(source, PCAP_SRC_IFREMOTE, hostname, port,\r\nNULL, errbuf) == -1) {\r\n*err = CANT_GET_INTERFACE_LIST;\r\nif (err_str != NULL)\r\n*err_str = cant_get_if_list_error_message(errbuf);\r\nreturn NULL;\r\n}\r\nauth.type = auth_type;\r\nauth.username = g_strdup(username);\r\nauth.password = g_strdup(passwd);\r\nresult = get_interface_list_findalldevs_ex(source, &auth, err, err_str);\r\ng_free(auth.username);\r\ng_free(auth.password);\r\nreturn result;\r\n}\r\nGList *\r\nget_interface_list(int *err, char **err_str)\r\n{\r\nGList *il = NULL;\r\nwchar_t *names;\r\nchar *win95names;\r\nchar ascii_name[MAX_WIN_IF_NAME_LEN + 1];\r\nchar ascii_desc[MAX_WIN_IF_NAME_LEN + 1];\r\nint i, j;\r\nchar errbuf[PCAP_ERRBUF_SIZE];\r\nif (!has_wpcap) {\r\n*err = DONT_HAVE_PCAP;\r\nif (err_str != NULL)\r\n*err_str = cant_load_winpcap_err("you");\r\nreturn NULL;\r\n}\r\n#ifdef HAVE_PCAP_FINDALLDEVS\r\nif (p_pcap_findalldevs != NULL)\r\nreturn get_interface_list_findalldevs(err, err_str);\r\n#endif\r\nnames = (wchar_t *)pcap_lookupdev(errbuf);\r\ni = 0;\r\nif (names) {\r\nchar* desc = 0;\r\nint desc_pos = 0;\r\nif (names[0]<256) {\r\nwhile (*(names+desc_pos) || *(names+desc_pos-1))\r\ndesc_pos++;\r\ndesc_pos++;\r\ndesc = (char*)(names + desc_pos);\r\nwhile (names[i] != 0) {\r\nj = 0;\r\nwhile (*desc != 0) {\r\nif (j < MAX_WIN_IF_NAME_LEN)\r\nascii_desc[j++] = *desc;\r\ndesc++;\r\n}\r\nascii_desc[j] = '\0';\r\ndesc++;\r\nj = 0;\r\nwhile (names[i] != 0) {\r\nif (j < MAX_WIN_IF_NAME_LEN)\r\nascii_name[j++] = (char) names[i++];\r\n}\r\nascii_name[j] = '\0';\r\ni++;\r\nil = g_list_append(il,\r\nif_info_new(ascii_name, ascii_desc, FALSE));\r\n}\r\n} else {\r\nwin95names=(char *)names;\r\nwhile (*(win95names+desc_pos) || *(win95names+desc_pos-1))\r\ndesc_pos++;\r\ndesc_pos++;\r\ndesc = win95names + desc_pos;\r\nwhile (win95names[i] != '\0') {\r\nil = g_list_append(il,\r\nif_info_new(&win95names[i], desc, FALSE));\r\nwhile (*desc != 0)\r\ndesc++;\r\ndesc++;\r\nwhile (win95names[i] != 0)\r\ni++;\r\ni++;\r\n}\r\n}\r\n}\r\nif (il == NULL) {\r\n*err = 0;\r\nif (err_str != NULL)\r\n*err_str = NULL;\r\n}\r\nreturn il;\r\n}\r\ngchar *\r\ncant_get_if_list_error_message(const char *err_str)\r\n{\r\nif (strstr(err_str, "Not enough storage is available to process this command") != NULL ||\r\nstrstr(err_str, "The operation completed successfully") != NULL) {\r\nreturn g_strdup_printf("Can't get list of interfaces: %s\n"\r\n"This might be a problem with WinPcap 3.0; you should try updating to\n"\r\n"a later version of WinPcap - see the WinPcap site at www.winpcap.org",\r\nerr_str);\r\n}\r\nreturn g_strdup_printf("Can't get list of interfaces: %s", err_str);\r\n}\r\nif_capabilities_t *\r\nget_if_capabilities_local(interface_options *interface_opts, char **err_str)\r\n{\r\n#ifdef HAVE_PCAP_CREATE\r\nif (p_pcap_create != NULL)\r\nreturn get_if_capabilities_pcap_create(interface_opts, err_str);\r\n#endif\r\nreturn get_if_capabilities_pcap_open_live(interface_opts, err_str);\r\n}\r\nvoid\r\nget_compiled_caplibs_version(GString *str)\r\n{\r\ng_string_append(str, "with WinPcap (" G_STRINGIFY(WINPCAP_VERSION) ")");\r\n}\r\nvoid\r\nget_runtime_caplibs_version(GString *str)\r\n{\r\nGModule *handle;\r\nstatic gchar *packetVer;\r\ngchar *blankp;\r\nif (has_wpcap) {\r\ng_string_append_printf(str, "with ");\r\nif (p_pcap_lib_version != NULL)\r\ng_string_append_printf(str, p_pcap_lib_version());\r\nelse {\r\nif (packetVer == NULL) {\r\npacketVer = "version unknown";\r\nhandle = ws_module_open("packet.dll", 0);\r\nif (handle != NULL) {\r\nif (g_module_symbol(handle,\r\n"PacketLibraryVersion",\r\n(gpointer*)&packetVer)) {\r\npacketVer = g_strdup(packetVer);\r\nblankp = strchr(packetVer, ' ');\r\nif (blankp != NULL)\r\n*blankp = '\0';\r\n} else {\r\npacketVer = "version unknown";\r\n}\r\ng_module_close(handle);\r\n}\r\n}\r\ng_string_append_printf(str, "WinPcap (%s)", packetVer);\r\n}\r\n} else\r\ng_string_append(str, "without WinPcap");\r\n}\r\ngboolean\r\nnpf_sys_is_running(void)\r\n{\r\nSC_HANDLE h_scm, h_serv;\r\nSERVICE_STATUS ss;\r\nh_scm = OpenSCManager(NULL, NULL, 0);\r\nif (!h_scm)\r\nreturn FALSE;\r\nh_serv = OpenService(h_scm, _T("npf"), SC_MANAGER_CONNECT|SERVICE_QUERY_STATUS);\r\nif (!h_serv) {\r\nh_serv = OpenService(h_scm, _T("npcap"), SC_MANAGER_CONNECT|SERVICE_QUERY_STATUS);\r\nif (!h_serv) {\r\nCloseServiceHandle(h_scm);\r\nreturn FALSE;\r\n}\r\n}\r\nif (QueryServiceStatus(h_serv, &ss)) {\r\nif (ss.dwCurrentState & SERVICE_RUNNING) {\r\nCloseServiceHandle(h_serv);\r\nCloseServiceHandle(h_scm);\r\nreturn TRUE;\r\n}\r\n}\r\nCloseServiceHandle(h_serv);\r\nCloseServiceHandle(h_scm);\r\nreturn FALSE;\r\n}\r\nvoid\r\nload_wpcap(void)\r\n{\r\nreturn;\r\n}\r\nvoid\r\nget_compiled_caplibs_version(GString *str)\r\n{\r\ng_string_append(str, "without WinPcap");\r\n}\r\nvoid\r\nget_runtime_caplibs_version(GString *str _U_)\r\n{\r\n}
