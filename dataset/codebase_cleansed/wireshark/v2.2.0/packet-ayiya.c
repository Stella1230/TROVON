static int\r\ndissect_ayiya(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *ayiya_tree;\r\nint offset = 0;\r\nint idlen, siglen, ayiya_len;\r\nguint8 next_header, opcode;\r\ntvbuff_t *payload;\r\nidlen = 1 << tvb_get_bits8(tvb, 0, 4);\r\nsiglen = tvb_get_bits8(tvb, 8, 4) * 4;\r\nopcode = tvb_get_bits8(tvb, 20, 4);\r\nnext_header = tvb_get_guint8(tvb, 3);\r\nayiya_len = 8+idlen+siglen;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "AYIYA");\r\nif (tree) {\r\nproto_item *ti;\r\nnstime_t tv;\r\nti = proto_tree_add_protocol_format( tree, proto_ayiya, tvb,\r\noffset, ayiya_len, "AYIYA" );\r\nayiya_tree = proto_item_add_subtree(ti, ett_ayiya);\r\nproto_tree_add_bits_item(ayiya_tree, hf_id_len, tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(ayiya_tree, hf_id_type, tvb, 4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(ayiya_tree, hf_sig_len, tvb, 8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(ayiya_tree, hf_hash_method, tvb, 12, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(ayiya_tree, hf_auth_method, tvb, 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(ayiya_tree, hf_opcode, tvb, 20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint_format_value(ayiya_tree, hf_next_header, tvb,\r\n3, 1, next_header,\r\n"%s (0x%02x)",\r\nipprotostr(next_header), next_header);\r\ntv.secs = tvb_get_ntohl(tvb, 4);\r\ntv.nsecs = 0;\r\nproto_tree_add_time(ayiya_tree, hf_epoch, tvb, 4, 4, &tv);\r\nproto_tree_add_item(ayiya_tree, hf_identity, tvb, 8, idlen, ENC_NA);\r\nproto_tree_add_item(ayiya_tree, hf_signature, tvb, 8+idlen, siglen, ENC_NA);\r\n}\r\noffset = ayiya_len;\r\nswitch (opcode) {\r\ncase OPCODE_FORWARD:\r\npayload = tvb_new_subset_remaining(tvb, offset);\r\ndissector_try_uint(ip_dissector_table, next_header, payload, pinfo, tree);\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ayiya(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_id_len,\r\n{ "Identity field length", "ayiya.idlen", FT_UINT8,\r\nBASE_HEX, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_id_type,\r\n{ "Identity field type", "ayiya.idtype", FT_UINT8,\r\nBASE_HEX, VALS(identity_types), 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_sig_len,\r\n{ "Signature Length", "ayiya.siglen", FT_UINT8,\r\nBASE_HEX, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_hash_method,\r\n{ "Hash method", "ayiya.hashmethod", FT_UINT8,\r\nBASE_HEX, VALS(hash_methods), 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_auth_method,\r\n{ "Authentication method", "ayiya.authmethod", FT_UINT8,\r\nBASE_HEX, VALS(auth_methods), 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_opcode,\r\n{ "Operation Code", "ayiya.opcode", FT_UINT8,\r\nBASE_HEX, VALS(opcodes), 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_next_header,\r\n{ "Next Header", "ayiya.nextheader", FT_UINT8,\r\nBASE_HEX, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_epoch,\r\n{ "Epoch", "ayiya.epoch", FT_ABSOLUTE_TIME,\r\nABSOLUTE_TIME_LOCAL, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_identity,\r\n{ "Identity", "ayiya.identity", FT_BYTES,\r\nBASE_NONE, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_signature,\r\n{ "Signature", "ayiya.signature", FT_BYTES,\r\nBASE_NONE, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ayiya,\r\n};\r\nproto_ayiya = proto_register_protocol("Anything in Anything Protocol",\r\n"AYIYA", "ayiya");\r\nregister_dissector("ayiya", dissect_ayiya, proto_ayiya);\r\nproto_register_field_array(proto_ayiya, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_ayiya(void)\r\n{\r\ndissector_handle_t ayiya_handle;\r\nayiya_handle = find_dissector("ayiya");\r\ndissector_add_uint("udp.port", UDP_PORT_AYIYA, ayiya_handle);\r\nip_dissector_table = find_dissector_table("ip.proto");\r\n}
