static int\r\ndissect_rip(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\nproto_tree *rip_tree = NULL;\r\nproto_item *ti;\r\nguint8 command;\r\nguint8 version;\r\nguint16 family;\r\ngint trailer_len = 0;\r\ngboolean is_md5_auth = FALSE;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "RIP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ncommand = tvb_get_guint8(tvb, 0);\r\nversion = tvb_get_guint8(tvb, 1);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL,\r\nval_to_str_const(version, version_vals, "RIP"));\r\ncol_add_str(pinfo->cinfo, COL_INFO,\r\nval_to_str(command, command_vals, "Unknown command (%u)"));\r\nti = proto_tree_add_item(tree, hfi_rip, tvb, 0, -1, ENC_NA);\r\nrip_tree = proto_item_add_subtree(ti, ett_rip);\r\nproto_tree_add_uint(rip_tree, &hfi_rip_command, tvb, 0, 1, command);\r\nproto_tree_add_uint(rip_tree, &hfi_rip_version, tvb, 1, 1, version);\r\nif (version == RIPv2 && pref_display_routing_domain == TRUE)\r\nproto_tree_add_uint(rip_tree, &hfi_rip_routing_domain, tvb, 2, 2,\r\ntvb_get_ntohs(tvb, 2));\r\noffset = RIP_HEADER_LENGTH;\r\nwhile (tvb_reported_length_remaining(tvb, offset) > trailer_len ) {\r\nfamily = tvb_get_ntohs(tvb, offset);\r\nswitch (family) {\r\ncase AFVAL_UNSPEC:\r\ndissect_unspec_rip_vektor(tvb, offset, version, rip_tree);\r\nbreak;\r\ncase AFVAL_IP:\r\ndissect_ip_rip_vektor(tvb, offset, version, rip_tree);\r\nbreak;\r\ncase 0xFFFF:\r\nif( offset == RIP_HEADER_LENGTH ) {\r\ntrailer_len=dissect_rip_authentication(tvb, offset, rip_tree);\r\nis_md5_auth = TRUE;\r\nbreak;\r\n}\r\nif(is_md5_auth && tvb_reported_length_remaining(tvb, offset) == 20)\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert_format(rip_tree, pinfo, &ei_rip_unknown_address_family, tvb, offset,\r\nRIP_ENTRY_LENGTH, "Unknown address family %u", family);\r\nbreak;\r\n}\r\noffset += RIP_ENTRY_LENGTH;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_unspec_rip_vektor(tvbuff_t *tvb, int offset, guint8 version,\r\nproto_tree *tree)\r\n{\r\nproto_tree *rip_vektor_tree;\r\nguint32 metric;\r\nmetric = tvb_get_ntohl(tvb, offset+16);\r\nrip_vektor_tree = proto_tree_add_subtree_format(tree, tvb, offset,\r\nRIP_ENTRY_LENGTH, ett_rip_vec, NULL, "Address not specified, Metric: %u",\r\nmetric);\r\nproto_tree_add_item(rip_vektor_tree, &hfi_rip_family, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nif (version == RIPv2) {\r\nproto_tree_add_item(rip_vektor_tree, &hfi_rip_route_tag, tvb, offset+2, 2,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(rip_vektor_tree, &hfi_rip_netmask, tvb, offset+8, 4,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(rip_vektor_tree, &hfi_rip_next_hop, tvb, offset+12, 4,\r\nENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_uint(rip_vektor_tree, &hfi_rip_metric, tvb,\r\noffset+16, 4, metric);\r\n}\r\nstatic void\r\ndissect_ip_rip_vektor(tvbuff_t *tvb, int offset, guint8 version,\r\nproto_tree *tree)\r\n{\r\nproto_tree *rip_vektor_tree;\r\nguint32 metric;\r\nmetric = tvb_get_ntohl(tvb, offset+16);\r\nrip_vektor_tree = proto_tree_add_subtree_format(tree, tvb, offset,\r\nRIP_ENTRY_LENGTH, ett_rip_vec, NULL, "IP Address: %s, Metric: %u",\r\ntvb_ip_to_str(tvb, offset+4), metric);\r\nproto_tree_add_item(rip_vektor_tree, &hfi_rip_family, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nif (version == RIPv2) {\r\nproto_tree_add_item(rip_vektor_tree, &hfi_rip_route_tag, tvb, offset+2, 2,\r\nENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(rip_vektor_tree, &hfi_rip_ip, tvb, offset+4, 4, ENC_BIG_ENDIAN);\r\nif (version == RIPv2) {\r\nproto_tree_add_item(rip_vektor_tree, &hfi_rip_netmask, tvb, offset+8, 4,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(rip_vektor_tree, &hfi_rip_next_hop, tvb, offset+12, 4,\r\nENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_uint(rip_vektor_tree, &hfi_rip_metric, tvb,\r\noffset+16, 4, metric);\r\n}\r\nstatic gint\r\ndissect_rip_authentication(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nproto_tree *rip_authentication_tree;\r\nguint16 authtype;\r\nguint32 digest_off, auth_data_len;\r\nauth_data_len = 0;\r\nauthtype = tvb_get_ntohs(tvb, offset + 2);\r\nrip_authentication_tree = proto_tree_add_subtree_format(tree, tvb, offset, RIP_ENTRY_LENGTH,\r\nett_rip_vec, NULL, "Authentication: %s", val_to_str( authtype, rip_auth_type, "Unknown (%u)" ) );\r\nproto_tree_add_uint(rip_authentication_tree, &hfi_rip_auth, tvb, offset+2, 2,\r\nauthtype);\r\nswitch ( authtype ) {\r\ncase AUTH_PASSWORD:\r\nproto_tree_add_item(rip_authentication_tree, &hfi_rip_auth_passwd,\r\ntvb, offset+4, 16, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase AUTH_KEYED_MSG_DIGEST:\r\ndigest_off = tvb_get_ntohs( tvb, offset+4 );\r\nproto_tree_add_item( rip_authentication_tree, &hfi_rip_digest_offset, tvb, offset+4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item( rip_authentication_tree, &hfi_rip_key_id, tvb, offset+6, 1, ENC_NA);\r\nauth_data_len = tvb_get_guint8( tvb, offset+7 );\r\nproto_tree_add_item( rip_authentication_tree, &hfi_rip_auth_data_len, tvb, offset+7, 1, ENC_NA);\r\nproto_tree_add_item( rip_authentication_tree, &hfi_rip_auth_seq_num, tvb, offset+8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item( rip_authentication_tree, &hfi_rip_zero_padding, tvb, offset+12, 8, ENC_NA);\r\nrip_authentication_tree = proto_tree_add_subtree( rip_authentication_tree, tvb, offset-4+digest_off,\r\nMD5_AUTH_DATA_LEN+4, ett_auth_vec, NULL, "Authentication Data Trailer" );\r\nproto_tree_add_item( rip_authentication_tree, &hfi_rip_authentication_data, tvb, offset-4+digest_off+4,\r\nMD5_AUTH_DATA_LEN, ENC_NA);\r\nbreak;\r\n}\r\nreturn auth_data_len;\r\n}\r\nvoid\r\nproto_register_rip(void)\r\n{\r\n#ifndef HAVE_HFI_SECTION_INIT\r\nstatic header_field_info *hfi[] = {\r\n&hfi_rip_command,\r\n&hfi_rip_version,\r\n&hfi_rip_routing_domain,\r\n&hfi_rip_ip,\r\n&hfi_rip_netmask,\r\n&hfi_rip_next_hop,\r\n&hfi_rip_metric,\r\n&hfi_rip_auth,\r\n&hfi_rip_auth_passwd,\r\n&hfi_rip_family,\r\n&hfi_rip_route_tag,\r\n&hfi_rip_zero_padding,\r\n&hfi_rip_digest_offset,\r\n&hfi_rip_key_id,\r\n&hfi_rip_auth_data_len,\r\n&hfi_rip_auth_seq_num,\r\n&hfi_rip_authentication_data,\r\n};\r\n#endif\r\nstatic gint *ett[] = {\r\n&ett_rip,\r\n&ett_rip_vec,\r\n&ett_auth_vec,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_rip_unknown_address_family, { "rip.unknown_address_family", PI_PROTOCOL, PI_WARN, "Unknown address family", EXPFILL }},\r\n};\r\nexpert_module_t* expert_rip;\r\nmodule_t *rip_module;\r\nint proto_rip;\r\nproto_rip = proto_register_protocol("Routing Information Protocol", "RIP", "rip");\r\nhfi_rip = proto_registrar_get_nth(proto_rip);\r\nproto_register_fields(proto_rip, hfi, array_length(hfi));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_rip = expert_register_protocol(proto_rip);\r\nexpert_register_field_array(expert_rip, ei, array_length(ei));\r\nrip_module = prefs_register_protocol(proto_rip, proto_reg_handoff_rip);\r\nprefs_register_bool_preference(rip_module, "display_routing_domain", "Display Routing Domain field", "Display the third and forth bytes of the RIPv2 header as the Routing Domain field (introduced in RFC 1388 [January 1993] and obsolete as of RFC 1723 [November 1994])", &pref_display_routing_domain);\r\nrip_handle = create_dissector_handle(dissect_rip, proto_rip);\r\n}\r\nvoid\r\nproto_reg_handoff_rip(void)\r\n{\r\ndissector_add_uint("udp.port", UDP_PORT_RIP, rip_handle);\r\n}
