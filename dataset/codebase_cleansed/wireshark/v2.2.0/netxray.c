wtap_open_return_val\r\nnetxray_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nchar magic[MAGIC_SIZE];\r\ngboolean is_old;\r\nstruct netxray_hdr hdr;\r\nguint network_type;\r\ndouble ticks_per_sec;\r\nint version_major, version_minor;\r\nint file_type;\r\ndouble start_timestamp;\r\nstatic const int netxray_encap[] = {\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_ETHERNET,\r\nWTAP_ENCAP_TOKEN_RING,\r\nWTAP_ENCAP_FDDI_BITSWAPPED,\r\nWTAP_ENCAP_ETHERNET,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_UNKNOWN,\r\nWTAP_ENCAP_ATM_PDUS_UNTRUNCATED,\r\nWTAP_ENCAP_IEEE_802_11_WITH_RADIO,\r\nWTAP_ENCAP_UNKNOWN\r\n};\r\n#define NUM_NETXRAY_ENCAPS (sizeof netxray_encap / sizeof netxray_encap[0])\r\nint file_encap;\r\nguint isdn_type = 0;\r\nnetxray_t *netxray;\r\nif (!wtap_read_bytes(wth->fh, magic, MAGIC_SIZE, err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (memcmp(magic, netxray_magic, MAGIC_SIZE) == 0) {\r\nis_old = FALSE;\r\n} else if (memcmp(magic, old_netxray_magic, MAGIC_SIZE) == 0) {\r\nis_old = TRUE;\r\n} else {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (!wtap_read_bytes(wth->fh, &hdr, sizeof hdr, err, err_info))\r\nreturn WTAP_OPEN_ERROR;\r\nif (is_old) {\r\nversion_major = 0;\r\nversion_minor = 0;\r\nfile_type = WTAP_FILE_TYPE_SUBTYPE_NETXRAY_OLD;\r\n} else {\r\nif (memcmp(hdr.version, vers_1_0, sizeof vers_1_0) == 0) {\r\nversion_major = 1;\r\nversion_minor = 0;\r\nfile_type = WTAP_FILE_TYPE_SUBTYPE_NETXRAY_1_0;\r\n} else if (memcmp(hdr.version, vers_1_1, sizeof vers_1_1) == 0) {\r\nversion_major = 1;\r\nversion_minor = 1;\r\nfile_type = WTAP_FILE_TYPE_SUBTYPE_NETXRAY_1_1;\r\n} else if (memcmp(hdr.version, vers_2_000, sizeof vers_2_000) == 0) {\r\nversion_major = 2;\r\nversion_minor = 0;\r\nfile_type = WTAP_FILE_TYPE_SUBTYPE_NETXRAY_2_00x;\r\n} else if (memcmp(hdr.version, vers_2_001, sizeof vers_2_001) == 0) {\r\nversion_major = 2;\r\nversion_minor = 1;\r\nfile_type = WTAP_FILE_TYPE_SUBTYPE_NETXRAY_2_00x;\r\n} else if (memcmp(hdr.version, vers_2_002, sizeof vers_2_002) == 0) {\r\nversion_major = 2;\r\nversion_minor = 2;\r\nfile_type = WTAP_FILE_TYPE_SUBTYPE_NETXRAY_2_00x;\r\n} else if (memcmp(hdr.version, vers_2_003, sizeof vers_2_003) == 0) {\r\nversion_major = 2;\r\nversion_minor = 3;\r\nfile_type = WTAP_FILE_TYPE_SUBTYPE_NETXRAY_2_00x;\r\n} else {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("netxray: version \"%.8s\" unsupported", hdr.version);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\n}\r\nswitch (hdr.network_plus) {\r\ncase 0:\r\nnetwork_type = hdr.network + 1;\r\nbreak;\r\ncase 2:\r\nnetwork_type = hdr.network;\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("netxray: the byte after the network type has the value %u, which I don't understand",\r\nhdr.network_plus);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (network_type >= NUM_NETXRAY_ENCAPS\r\n|| netxray_encap[network_type] == WTAP_ENCAP_UNKNOWN) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("netxray: network type %u (%u) unknown or unsupported",\r\nnetwork_type, hdr.network_plus);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nstart_timestamp = (double)pletoh32(&hdr.timelo)\r\n+ (double)pletoh32(&hdr.timehi)*4294967296.0;\r\nswitch (file_type) {\r\ncase WTAP_FILE_TYPE_SUBTYPE_NETXRAY_OLD:\r\nticks_per_sec = 1000.0;\r\nwth->file_tsprec = WTAP_TSPREC_MSEC;\r\nbreak;\r\ncase WTAP_FILE_TYPE_SUBTYPE_NETXRAY_1_0:\r\nticks_per_sec = 1000.0;\r\nwth->file_tsprec = WTAP_TSPREC_MSEC;\r\nbreak;\r\ncase WTAP_FILE_TYPE_SUBTYPE_NETXRAY_1_1:\r\nticks_per_sec = 1000000.0;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nbreak;\r\ncase WTAP_FILE_TYPE_SUBTYPE_NETXRAY_2_00x:\r\nswitch (network_type) {\r\ncase 1:\r\nswitch (hdr.captype) {\r\ncase CAPTYPE_NDIS:\r\nif (hdr.timeunit >= NUM_NETXRAY_TIMEUNITS) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf(\r\n"netxray: Unknown timeunit %u for Ethernet/CAPTYPE_NDIS version %.8s capture",\r\nhdr.timeunit, hdr.version);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (hdr.timeunit == 2) {\r\nticks_per_sec = pletoh32(hdr.realtick);\r\n}\r\nelse {\r\nticks_per_sec = TpS[hdr.timeunit];\r\n}\r\nbreak;\r\ncase ETH_CAPTYPE_GIGPOD:\r\nif (hdr.timeunit >= NUM_NETXRAY_TIMEUNITS_GIGPOD\r\n|| TpS_gigpod[hdr.timeunit] == 0.0) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf(\r\n"netxray: Unknown timeunit %u for Ethernet/ETH_CAPTYPE_GIGPOD version %.8s capture",\r\nhdr.timeunit, hdr.version);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nticks_per_sec = TpS_gigpod[hdr.timeunit];\r\nif (version_minor == 2 || version_minor == 3)\r\nstart_timestamp = 0.0;\r\nbreak;\r\ncase ETH_CAPTYPE_OTHERPOD:\r\nif (hdr.timeunit >= NUM_NETXRAY_TIMEUNITS_OTHERPOD\r\n|| TpS_otherpod[hdr.timeunit] == 0.0) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf(\r\n"netxray: Unknown timeunit %u for Ethernet/ETH_CAPTYPE_OTHERPOD version %.8s capture",\r\nhdr.timeunit, hdr.version);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nticks_per_sec = TpS_otherpod[hdr.timeunit];\r\nif (version_minor == 2 || version_minor == 3)\r\nstart_timestamp = 0.0;\r\nbreak;\r\ncase ETH_CAPTYPE_OTHERPOD2:\r\nif (hdr.timeunit >= NUM_NETXRAY_TIMEUNITS_OTHERPOD2\r\n|| TpS_otherpod2[hdr.timeunit] == 0.0) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf(\r\n"netxray: Unknown timeunit %u for Ethernet/ETH_CAPTYPE_OTHERPOD2 version %.8s capture",\r\nhdr.timeunit, hdr.version);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nticks_per_sec = TpS_otherpod2[hdr.timeunit];\r\nif (version_minor == 2 || version_minor == 3)\r\nstart_timestamp = 0.0;\r\nbreak;\r\ncase ETH_CAPTYPE_GIGPOD2:\r\nif (hdr.timeunit >= NUM_NETXRAY_TIMEUNITS_GIGPOD2\r\n|| TpS_gigpod2[hdr.timeunit] == 0.0) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf(\r\n"netxray: Unknown timeunit %u for Ethernet/ETH_CAPTYPE_GIGPOD2 version %.8s capture",\r\nhdr.timeunit, hdr.version);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nticks_per_sec = TpS_gigpod2[hdr.timeunit];\r\nif (version_minor == 2 || version_minor == 3)\r\nstart_timestamp = 0.0;\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf(\r\n"netxray: Unknown capture type %u for Ethernet version %.8s capture",\r\nhdr.captype, hdr.version);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nbreak;\r\ndefault:\r\nif (hdr.timeunit >= NUM_NETXRAY_TIMEUNITS) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf(\r\n"netxray: Unknown timeunit %u for %u/%u version %.8s capture",\r\nhdr.timeunit, network_type, hdr.captype,\r\nhdr.version);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nticks_per_sec = TpS[hdr.timeunit];\r\nbreak;\r\n}\r\nif (ticks_per_sec >= 1e7)\r\nwth->file_tsprec = WTAP_TSPREC_NSEC;\r\nelse\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nticks_per_sec = 0.0;\r\n}\r\nstart_timestamp = start_timestamp/ticks_per_sec;\r\nif (network_type == 4) {\r\nif (version_major == 2) {\r\nswitch (hdr.captype) {\r\ncase WAN_CAPTYPE_PPP:\r\nfile_encap = WTAP_ENCAP_PPP_WITH_PHDR;\r\nbreak;\r\ncase WAN_CAPTYPE_FRELAY:\r\nfile_encap = WTAP_ENCAP_FRELAY_WITH_PHDR;\r\nbreak;\r\ncase WAN_CAPTYPE_HDLC:\r\ncase WAN_CAPTYPE_HDLC2:\r\nswitch (hdr.wan_hdlc_subsub_captype) {\r\ncase 0:\r\nfile_encap = WTAP_ENCAP_LAPB;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nfile_encap = WTAP_ENCAP_ISDN;\r\nisdn_type = hdr.wan_hdlc_subsub_captype;\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("netxray: WAN HDLC capture subsubtype 0x%02x unknown or unsupported",\r\nhdr.wan_hdlc_subsub_captype);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nbreak;\r\ncase WAN_CAPTYPE_SDLC:\r\nfile_encap = WTAP_ENCAP_SDLC;\r\nbreak;\r\ncase WAN_CAPTYPE_CHDLC:\r\nfile_encap = WTAP_ENCAP_CHDLC_WITH_PHDR;\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("netxray: WAN capture subtype 0x%02x unknown or unsupported",\r\nhdr.captype);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\n} else\r\nfile_encap = WTAP_ENCAP_ETHERNET;\r\n} else\r\nfile_encap = netxray_encap[network_type];\r\nwth->file_type_subtype = file_type;\r\nnetxray = (netxray_t *)g_malloc(sizeof(netxray_t));\r\nwth->priv = (void *)netxray;\r\nwth->subtype_read = netxray_read;\r\nwth->subtype_seek_read = netxray_seek_read;\r\nwth->file_encap = file_encap;\r\nwth->snapshot_length = 0;\r\nnetxray->start_time = pletoh32(&hdr.start_time);\r\nnetxray->ticks_per_sec = ticks_per_sec;\r\nnetxray->start_timestamp = start_timestamp;\r\nnetxray->version_major = version_major;\r\nnetxray->fcs_valid = FALSE;\r\nswitch (file_encap) {\r\ncase WTAP_ENCAP_ETHERNET:\r\ncase WTAP_ENCAP_IEEE_802_11_WITH_RADIO:\r\ncase WTAP_ENCAP_ISDN:\r\ncase WTAP_ENCAP_LAPB:\r\nif (version_major == 2) {\r\nif (hdr.realtick[1] == 0x34 && hdr.realtick[2] == 0x12)\r\nnetxray->fcs_valid = TRUE;\r\n}\r\nbreak;\r\n}\r\nnetxray->isdn_type = isdn_type;\r\nnetxray->wrapped = FALSE;\r\nnetxray->nframes = pletoh32(&hdr.nframes);\r\nnetxray->start_offset = pletoh32(&hdr.start_offset);\r\nnetxray->end_offset = pletoh32(&hdr.end_offset);\r\nif (file_seek(wth->fh, netxray->start_offset, SEEK_SET, err) == -1) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean\r\nnetxray_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\nnetxray_t *netxray = (netxray_t *)wth->priv;\r\nint padding;\r\nreread:\r\n*data_offset = file_tell(wth->fh);\r\nif (*data_offset == netxray->end_offset) {\r\n*err = 0;\r\nreturn FALSE;\r\n}\r\npadding = netxray_process_rec_header(wth, wth->fh, &wth->phdr, err,\r\nerr_info);\r\nif (padding < 0) {\r\nif (*err != 0) {\r\nreturn FALSE;\r\n}\r\nif (netxray->start_offset < netxray->end_offset) {\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nif (!netxray->wrapped) {\r\nnetxray->wrapped = TRUE;\r\nif (file_seek(wth->fh, CAPTUREFILE_HEADER_SIZE,\r\nSEEK_SET, err) == -1)\r\nreturn FALSE;\r\ngoto reread;\r\n}\r\nreturn FALSE;\r\n}\r\nif (!wtap_read_packet_bytes(wth->fh, wth->frame_buffer,\r\nwth->phdr.caplen, err, err_info))\r\nreturn FALSE;\r\nif (file_seek(wth->fh, padding, SEEK_CUR, err) == -1)\r\nreturn FALSE;\r\nnetxray_guess_atm_type(wth, &wth->phdr, wth->frame_buffer);\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nnetxray_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf,\r\nint *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (netxray_process_rec_header(wth, wth->random_fh, phdr, err,\r\nerr_info) == -1) {\r\nif (*err == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn FALSE;\r\n}\r\nif (!wtap_read_packet_bytes(wth->random_fh, buf, phdr->caplen, err,\r\nerr_info))\r\nreturn FALSE;\r\nnetxray_guess_atm_type(wth, phdr, buf);\r\nreturn TRUE;\r\n}\r\nstatic int\r\nnetxray_process_rec_header(wtap *wth, FILE_T fh, struct wtap_pkthdr *phdr,\r\nint *err, gchar **err_info)\r\n{\r\nnetxray_t *netxray = (netxray_t *)wth->priv;\r\nunion netxrayrec_hdr hdr;\r\nint hdr_size = 0;\r\ndouble t;\r\nint packet_size;\r\nint padding = 0;\r\nswitch (netxray->version_major) {\r\ncase 0:\r\nhdr_size = sizeof (struct old_netxrayrec_hdr);\r\nbreak;\r\ncase 1:\r\nhdr_size = sizeof (struct netxrayrec_1_x_hdr);\r\nbreak;\r\ncase 2:\r\nhdr_size = sizeof (struct netxrayrec_2_x_hdr);\r\nbreak;\r\n}\r\nif (!wtap_read_bytes_or_eof(fh, (void *)&hdr, hdr_size, err, err_info)) {\r\nreturn -1;\r\n}\r\nswitch (netxray->version_major) {\r\ncase 1:\r\nswitch (wth->file_encap) {\r\ncase WTAP_ENCAP_ETHERNET:\r\nphdr->pseudo_header.eth.fcs_len = 0;\r\nbreak;\r\n}\r\nbreak;\r\ncase 2:\r\nswitch (wth->file_encap) {\r\ncase WTAP_ENCAP_ETHERNET:\r\nif (hdr.hdr_2_x.xxx[2] == 0xff &&\r\nhdr.hdr_2_x.xxx[3] == 0xff) {\r\nif (netxray->fcs_valid) {\r\nphdr->pseudo_header.eth.fcs_len = 4;\r\n} else {\r\npadding = 4;\r\n}\r\n} else\r\nphdr->pseudo_header.eth.fcs_len = 0;\r\nbreak;\r\ncase WTAP_ENCAP_IEEE_802_11_WITH_RADIO:\r\nmemset(&phdr->pseudo_header.ieee_802_11, 0, sizeof(phdr->pseudo_header.ieee_802_11));\r\nif (hdr.hdr_2_x.xxx[2] == 0xff &&\r\nhdr.hdr_2_x.xxx[3] == 0xff) {\r\nif (netxray->fcs_valid) {\r\nphdr->pseudo_header.ieee_802_11.fcs_len = 4;\r\n} else {\r\npadding = 4;\r\n}\r\n} else\r\nphdr->pseudo_header.ieee_802_11.fcs_len = 0;\r\nphdr->pseudo_header.ieee_802_11.decrypted = FALSE;\r\nphdr->pseudo_header.ieee_802_11.datapad = FALSE;\r\nphdr->pseudo_header.ieee_802_11.phy = PHDR_802_11_PHY_UNKNOWN;\r\nphdr->pseudo_header.ieee_802_11.has_channel = TRUE;\r\nphdr->pseudo_header.ieee_802_11.channel =\r\nhdr.hdr_2_x.xxx[12];\r\nphdr->pseudo_header.ieee_802_11.has_data_rate = TRUE;\r\nphdr->pseudo_header.ieee_802_11.data_rate =\r\nhdr.hdr_2_x.xxx[13];\r\nphdr->pseudo_header.ieee_802_11.has_signal_percent = TRUE;\r\nphdr->pseudo_header.ieee_802_11.signal_percent =\r\nhdr.hdr_2_x.xxx[14];\r\nif (hdr.hdr_2_x.xxx[15] != 0xFF) {\r\nphdr->pseudo_header.ieee_802_11.has_noise_percent = TRUE;\r\nphdr->pseudo_header.ieee_802_11.noise_percent =\r\nhdr.hdr_2_x.xxx[15]*100/127;\r\n}\r\nbreak;\r\ncase WTAP_ENCAP_ISDN:\r\nphdr->pseudo_header.isdn.uton =\r\n(hdr.hdr_2_x.xxx[12] & 0x01);\r\nphdr->pseudo_header.isdn.channel =\r\nhdr.hdr_2_x.xxx[13] & 0x1F;\r\nswitch (netxray->isdn_type) {\r\ncase 1:\r\nif (phdr->pseudo_header.isdn.channel == 16)\r\nphdr->pseudo_header.isdn.channel = 0;\r\nelse if (phdr->pseudo_header.isdn.channel > 16)\r\nphdr->pseudo_header.isdn.channel -= 1;\r\nbreak;\r\ncase 2:\r\nif (phdr->pseudo_header.isdn.channel == 24)\r\nphdr->pseudo_header.isdn.channel = 0;\r\nelse if (phdr->pseudo_header.isdn.channel > 24)\r\nphdr->pseudo_header.isdn.channel -= 1;\r\nbreak;\r\n}\r\nif (hdr.hdr_2_x.xxx[2] == 0xff &&\r\nhdr.hdr_2_x.xxx[3] == 0xff) {\r\npadding = 4;\r\n}\r\nbreak;\r\ncase WTAP_ENCAP_LAPB:\r\ncase WTAP_ENCAP_FRELAY_WITH_PHDR:\r\nphdr->pseudo_header.x25.flags =\r\n(hdr.hdr_2_x.xxx[12] & 0x01) ? 0x00 : FROM_DCE;\r\nif (hdr.hdr_2_x.xxx[2] == 0xff &&\r\nhdr.hdr_2_x.xxx[3] == 0xff) {\r\npadding = 4;\r\n}\r\nbreak;\r\ncase WTAP_ENCAP_PPP_WITH_PHDR:\r\ncase WTAP_ENCAP_SDLC:\r\ncase WTAP_ENCAP_CHDLC_WITH_PHDR:\r\nphdr->pseudo_header.p2p.sent =\r\n(hdr.hdr_2_x.xxx[12] & 0x01) ? TRUE : FALSE;\r\nbreak;\r\ncase WTAP_ENCAP_ATM_PDUS_UNTRUNCATED:\r\nphdr->pseudo_header.atm.flags = 0;\r\nif (hdr.hdr_2_x.xxx[8] & 0x01)\r\nphdr->pseudo_header.atm.flags |= ATM_REASSEMBLY_ERROR;\r\nif (hdr.hdr_2_x.xxx[9] & 0x04)\r\nphdr->pseudo_header.atm.flags |= ATM_RAW_CELL;\r\nphdr->pseudo_header.atm.vpi = hdr.hdr_2_x.xxx[11];\r\nphdr->pseudo_header.atm.vci = pletoh16(&hdr.hdr_2_x.xxx[12]);\r\nphdr->pseudo_header.atm.channel =\r\n(hdr.hdr_2_x.xxx[15] & 0x10)? 1 : 0;\r\nphdr->pseudo_header.atm.cells = 0;\r\nswitch (hdr.hdr_2_x.xxx[0] & 0x70) {\r\ncase 0x00:\r\nphdr->pseudo_header.atm.aal = AAL_UNKNOWN;\r\nphdr->pseudo_header.atm.type = TRAF_UNKNOWN;\r\nphdr->pseudo_header.atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase 0x10:\r\nphdr->pseudo_header.atm.aal = AAL_UNKNOWN;\r\nphdr->pseudo_header.atm.type = TRAF_UNKNOWN;\r\nphdr->pseudo_header.atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase 0x20:\r\nphdr->pseudo_header.atm.aal = AAL_UNKNOWN;\r\nphdr->pseudo_header.atm.type = TRAF_UNKNOWN;\r\nphdr->pseudo_header.atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase 0x40:\r\nphdr->pseudo_header.atm.aal = AAL_UNKNOWN;\r\nphdr->pseudo_header.atm.type = TRAF_UNKNOWN;\r\nphdr->pseudo_header.atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase 0x30:\r\ncase 0x50:\r\ncase 0x60:\r\ncase 0x70:\r\nphdr->pseudo_header.atm.aal = AAL_5;\r\nswitch (hdr.hdr_2_x.xxx[0] & 0x07) {\r\ncase 0x01:\r\ncase 0x02:\r\nphdr->pseudo_header.atm.aal = AAL_SIGNALLING;\r\nphdr->pseudo_header.atm.type = TRAF_UNKNOWN;\r\nphdr->pseudo_header.atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase 0x03:\r\nphdr->pseudo_header.atm.type = TRAF_ILMI;\r\nphdr->pseudo_header.atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase 0x00:\r\ncase 0x04:\r\ncase 0x05:\r\nphdr->pseudo_header.atm.type = TRAF_LANE;\r\nphdr->pseudo_header.atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase 0x06:\r\nphdr->pseudo_header.atm.type = TRAF_UNKNOWN;\r\nphdr->pseudo_header.atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\ncase 0x07:\r\nphdr->pseudo_header.atm.type = TRAF_LLCMX;\r\nphdr->pseudo_header.atm.subtype = TRAF_ST_UNKNOWN;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nif (netxray->version_major == 0) {\r\nphdr->presence_flags = WTAP_HAS_TS;\r\nt = (double)pletoh32(&hdr.old_hdr.timelo)\r\n+ (double)pletoh32(&hdr.old_hdr.timehi)*4294967296.0;\r\nt /= netxray->ticks_per_sec;\r\nt -= netxray->start_timestamp;\r\nphdr->ts.secs = netxray->start_time + (long)t;\r\nphdr->ts.nsecs = (int)((t-(double)(unsigned long)(t))\r\n*1.0e9);\r\npacket_size = pletoh16(&hdr.old_hdr.len);\r\nphdr->caplen = packet_size - padding;\r\nphdr->len = phdr->caplen;\r\n} else {\r\nphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\nt = (double)pletoh32(&hdr.hdr_1_x.timelo)\r\n+ (double)pletoh32(&hdr.hdr_1_x.timehi)*4294967296.0;\r\nt /= netxray->ticks_per_sec;\r\nt -= netxray->start_timestamp;\r\nphdr->ts.secs = netxray->start_time + (time_t)t;\r\nphdr->ts.nsecs = (int)((t-(double)(unsigned long)(t))\r\n*1.0e9);\r\npacket_size = pletoh16(&hdr.hdr_1_x.incl_len);\r\nphdr->caplen = packet_size - padding;\r\nphdr->len = pletoh16(&hdr.hdr_1_x.orig_len) - padding;\r\n}\r\nreturn padding;\r\n}\r\nstatic void\r\nnetxray_guess_atm_type(wtap *wth, struct wtap_pkthdr *phdr, Buffer *buf)\r\n{\r\nconst guint8 *pd;\r\nif (wth->file_encap == WTAP_ENCAP_ATM_PDUS_UNTRUNCATED &&\r\n!(phdr->pseudo_header.atm.flags & ATM_REASSEMBLY_ERROR)) {\r\nif (phdr->pseudo_header.atm.aal == AAL_UNKNOWN) {\r\npd = ws_buffer_start_ptr(buf);\r\natm_guess_traffic_type(phdr, pd);\r\n} else if (phdr->pseudo_header.atm.aal == AAL_5 &&\r\nphdr->pseudo_header.atm.type == TRAF_LANE) {\r\npd = ws_buffer_start_ptr(buf);\r\natm_guess_lane_type(phdr, pd);\r\n}\r\n}\r\n}\r\nstatic int\r\nwtap_encap_to_netxray_1_1_encap(int encap)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < NUM_WTAP_ENCAPS_1_1; i++) {\r\nif (encap == wtap_encap_1_1[i].wtap_encap_value)\r\nreturn wtap_encap_1_1[i].ndis_value;\r\n}\r\nreturn -1;\r\n}\r\nint\r\nnetxray_dump_can_write_encap_1_1(int encap)\r\n{\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nif (wtap_encap_to_netxray_1_1_encap(encap) == -1)\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\nreturn 0;\r\n}\r\ngboolean\r\nnetxray_dump_open_1_1(wtap_dumper *wdh, int *err)\r\n{\r\nnetxray_dump_t *netxray;\r\nwdh->subtype_write = netxray_dump_1_1;\r\nwdh->subtype_finish = netxray_dump_finish_1_1;\r\nif (wtap_dump_file_seek(wdh, CAPTUREFILE_HEADER_SIZE, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nwdh->bytes_dumped += CAPTUREFILE_HEADER_SIZE;\r\nnetxray = (netxray_dump_t *)g_malloc(sizeof(netxray_dump_t));\r\nwdh->priv = (void *)netxray;\r\nnetxray->first_frame = TRUE;\r\nnetxray->start.secs = 0;\r\nnetxray->start.nsecs = 0;\r\nnetxray->nframes = 0;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nnetxray_dump_1_1(wtap_dumper *wdh,\r\nconst struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info _U_)\r\n{\r\nnetxray_dump_t *netxray = (netxray_dump_t *)wdh->priv;\r\nguint64 timestamp;\r\nguint32 t32;\r\nstruct netxrayrec_1_x_hdr rec_hdr;\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\nif (phdr->caplen > 65535) {\r\n*err = WTAP_ERR_PACKET_TOO_LARGE;\r\nreturn FALSE;\r\n}\r\nif (netxray->first_frame) {\r\nnetxray->first_frame = FALSE;\r\nnetxray->start = phdr->ts;\r\n}\r\nmemset(&rec_hdr, '\0', sizeof(rec_hdr));\r\ntimestamp = ((guint64)phdr->ts.secs - (guint64)netxray->start.secs)*1000000\r\n+ ((guint64)phdr->ts.nsecs)/1000;\r\nt32 = (guint32)(timestamp%G_GINT64_CONSTANT(4294967296));\r\nrec_hdr.timelo = GUINT32_TO_LE(t32);\r\nt32 = (guint32)(timestamp/G_GINT64_CONSTANT(4294967296));\r\nrec_hdr.timehi = GUINT32_TO_LE(t32);\r\nrec_hdr.orig_len = GUINT16_TO_LE(phdr->len);\r\nrec_hdr.incl_len = GUINT16_TO_LE(phdr->caplen);\r\nif (!wtap_dump_file_write(wdh, &rec_hdr, sizeof(rec_hdr), err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += sizeof(rec_hdr);\r\nif (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += phdr->caplen;\r\nnetxray->nframes++;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nnetxray_dump_finish_1_1(wtap_dumper *wdh, int *err)\r\n{\r\nchar hdr_buf[CAPTUREFILE_HEADER_SIZE - sizeof(netxray_magic)];\r\nnetxray_dump_t *netxray = (netxray_dump_t *)wdh->priv;\r\ngint64 filelen;\r\nstruct netxray_hdr file_hdr;\r\nif (-1 == (filelen = wtap_dump_file_tell(wdh, err)))\r\nreturn FALSE;\r\nif (wtap_dump_file_seek(wdh, 0, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (!wtap_dump_file_write(wdh, netxray_magic, sizeof netxray_magic, err))\r\nreturn FALSE;\r\nmemset(&file_hdr, '\0', sizeof file_hdr);\r\nmemcpy(file_hdr.version, vers_1_1, sizeof vers_1_1);\r\nfile_hdr.start_time = GUINT32_TO_LE(netxray->start.secs);\r\nfile_hdr.nframes = GUINT32_TO_LE(netxray->nframes);\r\nfile_hdr.start_offset = GUINT32_TO_LE(CAPTUREFILE_HEADER_SIZE);\r\nfile_hdr.end_offset = GUINT32_TO_LE((guint32)filelen);\r\nfile_hdr.network = wtap_encap_to_netxray_1_1_encap(wdh->encap);\r\nfile_hdr.timelo = GUINT32_TO_LE(0);\r\nfile_hdr.timehi = GUINT32_TO_LE(0);\r\nmemset(hdr_buf, '\0', sizeof hdr_buf);\r\nmemcpy(hdr_buf, &file_hdr, sizeof(file_hdr));\r\nif (!wtap_dump_file_write(wdh, hdr_buf, sizeof hdr_buf, err))\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\nstatic int\r\nwtap_encap_to_netxray_2_0_encap(int encap)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < NUM_WTAP_ENCAPS_2_0; i++) {\r\nif (encap == wtap_encap_2_0[i].wtap_encap_value)\r\nreturn wtap_encap_2_0[i].ndis_value;\r\n}\r\nreturn -1;\r\n}\r\nint\r\nnetxray_dump_can_write_encap_2_0(int encap)\r\n{\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nif (wtap_encap_to_netxray_2_0_encap(encap) == -1)\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\nreturn 0;\r\n}\r\ngboolean\r\nnetxray_dump_open_2_0(wtap_dumper *wdh, int *err)\r\n{\r\nnetxray_dump_t *netxray;\r\nwdh->subtype_write = netxray_dump_2_0;\r\nwdh->subtype_finish = netxray_dump_finish_2_0;\r\nif (wtap_dump_file_seek(wdh, CAPTUREFILE_HEADER_SIZE, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nwdh->bytes_dumped += CAPTUREFILE_HEADER_SIZE;\r\nnetxray = (netxray_dump_t *)g_malloc(sizeof(netxray_dump_t));\r\nwdh->priv = (void *)netxray;\r\nnetxray->first_frame = TRUE;\r\nnetxray->start.secs = 0;\r\nnetxray->start.nsecs = 0;\r\nnetxray->nframes = 0;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nnetxray_dump_2_0(wtap_dumper *wdh,\r\nconst struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info _U_)\r\n{\r\nconst union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nnetxray_dump_t *netxray = (netxray_dump_t *)wdh->priv;\r\nguint64 timestamp;\r\nguint32 t32;\r\nstruct netxrayrec_2_x_hdr rec_hdr;\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\nif (phdr->caplen > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_PACKET_TOO_LARGE;\r\nreturn FALSE;\r\n}\r\nif (netxray->first_frame) {\r\nnetxray->first_frame = FALSE;\r\nnetxray->start = phdr->ts;\r\n}\r\nmemset(&rec_hdr, '\0', sizeof(rec_hdr));\r\ntimestamp = ((guint64)phdr->ts.secs - (guint64)netxray->start.secs)*1000000\r\n+ ((guint64)phdr->ts.nsecs)/1000;\r\nt32 = (guint32)(timestamp%G_GINT64_CONSTANT(4294967296));\r\nrec_hdr.timelo = GUINT32_TO_LE(t32);\r\nt32 = (guint32)(timestamp/G_GINT64_CONSTANT(4294967296));\r\nrec_hdr.timehi = GUINT32_TO_LE(t32);\r\nrec_hdr.orig_len = GUINT16_TO_LE(phdr->len);\r\nrec_hdr.incl_len = GUINT16_TO_LE(phdr->caplen);\r\nswitch (phdr->pkt_encap) {\r\ncase WTAP_ENCAP_IEEE_802_11_WITH_RADIO:\r\nrec_hdr.xxx[12] =\r\npseudo_header->ieee_802_11.has_channel ?\r\npseudo_header->ieee_802_11.channel :\r\n0;\r\nrec_hdr.xxx[13] =\r\npseudo_header->ieee_802_11.has_data_rate ?\r\n(guint8)pseudo_header->ieee_802_11.data_rate :\r\n0;\r\nrec_hdr.xxx[14] =\r\npseudo_header->ieee_802_11.has_signal_percent ?\r\npseudo_header->ieee_802_11.signal_percent :\r\n0;\r\nrec_hdr.xxx[15] =\r\npseudo_header->ieee_802_11.has_noise_percent ?\r\npseudo_header->ieee_802_11.noise_percent*127/100 :\r\n0xFF;\r\nbreak;\r\ncase WTAP_ENCAP_PPP_WITH_PHDR:\r\ncase WTAP_ENCAP_SDLC:\r\nrec_hdr.xxx[12] |= pseudo_header->p2p.sent ? 0x01 : 0x00;\r\nbreak;\r\ncase WTAP_ENCAP_FRELAY_WITH_PHDR:\r\nrec_hdr.xxx[12] |= (pseudo_header->x25.flags & FROM_DCE) ? 0x00 : 0x01;\r\nbreak;\r\n}\r\nif (!wtap_dump_file_write(wdh, &rec_hdr, sizeof(rec_hdr), err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += sizeof(rec_hdr);\r\nif (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += phdr->caplen;\r\nnetxray->nframes++;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nnetxray_dump_finish_2_0(wtap_dumper *wdh, int *err)\r\n{\r\nchar hdr_buf[CAPTUREFILE_HEADER_SIZE - sizeof(netxray_magic)];\r\nnetxray_dump_t *netxray = (netxray_dump_t *)wdh->priv;\r\ngint64 filelen;\r\nstruct netxray_hdr file_hdr;\r\nif (-1 == (filelen = wtap_dump_file_tell(wdh, err)))\r\nreturn FALSE;\r\nif (wtap_dump_file_seek(wdh, 0, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (!wtap_dump_file_write(wdh, netxray_magic, sizeof netxray_magic, err))\r\nreturn FALSE;\r\nmemset(&file_hdr, '\0', sizeof file_hdr);\r\nmemcpy(file_hdr.version, vers_2_001, sizeof vers_2_001);\r\nfile_hdr.start_time = GUINT32_TO_LE(netxray->start.secs);\r\nfile_hdr.nframes = GUINT32_TO_LE(netxray->nframes);\r\nfile_hdr.start_offset = GUINT32_TO_LE(CAPTUREFILE_HEADER_SIZE);\r\nfile_hdr.end_offset = GUINT32_TO_LE((guint32)filelen);\r\nfile_hdr.network = wtap_encap_to_netxray_2_0_encap(wdh->encap);\r\nfile_hdr.timelo = GUINT32_TO_LE(0);\r\nfile_hdr.timehi = GUINT32_TO_LE(0);\r\nswitch (wdh->encap) {\r\ncase WTAP_ENCAP_PPP_WITH_PHDR:\r\nfile_hdr.captype = WAN_CAPTYPE_PPP;\r\nbreak;\r\ncase WTAP_ENCAP_FRELAY_WITH_PHDR:\r\nfile_hdr.captype = WAN_CAPTYPE_FRELAY;\r\nbreak;\r\ncase WTAP_ENCAP_LAPB:\r\nfile_hdr.captype = WAN_CAPTYPE_HDLC;\r\nfile_hdr.wan_hdlc_subsub_captype = 0;\r\nbreak;\r\ncase WTAP_ENCAP_SDLC:\r\nfile_hdr.captype = WAN_CAPTYPE_SDLC;\r\nbreak;\r\ndefault:\r\nfile_hdr.captype = CAPTYPE_NDIS;\r\nbreak;\r\n}\r\nmemset(hdr_buf, '\0', sizeof hdr_buf);\r\nmemcpy(hdr_buf, &file_hdr, sizeof(file_hdr));\r\nif (!wtap_dump_file_write(wdh, hdr_buf, sizeof hdr_buf, err))\r\nreturn FALSE;\r\nreturn TRUE;\r\n}
