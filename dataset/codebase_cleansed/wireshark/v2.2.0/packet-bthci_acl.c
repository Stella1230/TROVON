static gint\r\ndissect_bthci_acl(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nproto_item *bthci_acl_itam;\r\nproto_tree *bthci_acl_tree;\r\nproto_item *sub_item;\r\nproto_item *length_item;\r\nguint16 flags;\r\nguint16 length;\r\ngboolean fragmented;\r\ngint offset = 0;\r\nguint16 pb_flag, l2cap_length = 0;\r\ntvbuff_t *next_tvb;\r\nbthci_acl_data_t *acl_data;\r\nchandle_data_t *chandle_data;\r\nbluetooth_data_t *bluetooth_data;\r\nwmem_tree_t *subtree;\r\nwmem_tree_key_t key[6];\r\nguint32 interface_id;\r\nguint32 adapter_id;\r\nguint32 connection_handle;\r\nguint32 direction;\r\nguint32 frame_number;\r\nremote_bdaddr_t *remote_bdaddr;\r\nconst gchar *localhost_name;\r\nguint8 localhost_bdaddr[6];\r\nconst gchar *localhost_ether_addr;\r\ngchar *localhost_addr_name;\r\ngint localhost_length;\r\nlocalhost_bdaddr_entry_t *localhost_bdaddr_entry;\r\nlocalhost_name_entry_t *localhost_name_entry;\r\nconst guint8 unknown_bd_addr[6] = {0, 0, 0, 0, 0, 0};\r\nconst guint8 *src_bd_addr = &unknown_bd_addr[0];\r\nconst gchar *src_name = "";\r\nconst gchar *src_addr_name = "";\r\nconst guint8 *dst_bd_addr = &unknown_bd_addr[0];\r\nconst gchar *dst_name = "";\r\nconst gchar *dst_addr_name = "";\r\nchandle_session_t *chandle_session;\r\nguint32 src_role = ROLE_UNKNOWN;\r\nguint32 dst_role = ROLE_UNKNOWN;\r\nguint32 role_last_change_in_frame = 0;\r\nconnection_mode_t *connection_mode;\r\ngint32 mode = -1;\r\nguint32 mode_last_change_in_frame = 0;\r\nif (data == NULL)\r\nreturn 0;\r\nbluetooth_data = (bluetooth_data_t *) data;\r\nbthci_acl_itam = proto_tree_add_item(tree, proto_bthci_acl, tvb, offset, -1, ENC_NA);\r\nbthci_acl_tree = proto_item_add_subtree(bthci_acl_itam, ett_bthci_acl);\r\nswitch (pinfo->p2p_dir) {\r\ncase P2P_DIR_SENT:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Sent ");\r\nbreak;\r\ncase P2P_DIR_RECV:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");\r\nbreak;\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");\r\nbreak;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "HCI_ACL");\r\nflags = tvb_get_letohs(tvb, offset);\r\npb_flag = (flags & 0x3000) >> 12;\r\nproto_tree_add_item(bthci_acl_tree, hf_bthci_acl_chandle, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(bthci_acl_tree, hf_bthci_acl_pb_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(bthci_acl_tree, hf_bthci_acl_bc_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\ninterface_id = bluetooth_data->interface_id;\r\nadapter_id = bluetooth_data->adapter_id;\r\nconnection_handle = flags & 0x0fff;\r\ndirection = pinfo->p2p_dir;\r\nframe_number = pinfo->num;\r\nacl_data = wmem_new(wmem_packet_scope(), bthci_acl_data_t);\r\nacl_data->interface_id = interface_id;\r\nacl_data->adapter_id = adapter_id;\r\nacl_data->adapter_disconnect_in_frame = bluetooth_data->adapter_disconnect_in_frame;\r\nacl_data->chandle = connection_handle;\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &connection_handle;\r\nkey[3].length = 0;\r\nkey[3].key = NULL;\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(bluetooth_data->chandle_sessions, key);\r\nchandle_session = (subtree) ? (chandle_session_t *) wmem_tree_lookup32_le(subtree, pinfo->num) : NULL;\r\nif (chandle_session &&\r\nchandle_session->connect_in_frame < pinfo->num &&\r\nchandle_session->disconnect_in_frame > pinfo->num) {\r\nacl_data->disconnect_in_frame = &chandle_session->disconnect_in_frame;\r\n} else {\r\nacl_data->disconnect_in_frame = &invalid_session;\r\nchandle_session = NULL;\r\n}\r\nacl_data->remote_bd_addr_oui = 0;\r\nacl_data->remote_bd_addr_id = 0;\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(bluetooth_data->chandle_to_mode, key);\r\nconnection_mode = (subtree) ? (connection_mode_t *) wmem_tree_lookup32_le(subtree, pinfo->num) : NULL;\r\nif (connection_mode) {\r\nmode = connection_mode->mode;\r\nmode_last_change_in_frame = connection_mode->change_in_frame;\r\n}\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(bluetooth_data->chandle_to_bdaddr, key);\r\nremote_bdaddr = (subtree) ? (remote_bdaddr_t *) wmem_tree_lookup32_le(subtree, pinfo->num) : NULL;\r\nif (remote_bdaddr) {\r\nguint32 k_bd_addr_oui;\r\nguint32 k_bd_addr_id;\r\nguint32 bd_addr_oui;\r\nguint32 bd_addr_id;\r\ndevice_name_t *device_name;\r\ndevice_role_t *device_role;\r\nconst gchar *remote_name;\r\nconst gchar *remote_ether_addr;\r\ngchar *remote_addr_name;\r\ngint remote_length;\r\nbd_addr_oui = remote_bdaddr->bd_addr[0] << 16 | remote_bdaddr->bd_addr[1] << 8 | remote_bdaddr->bd_addr[2];\r\nbd_addr_id = remote_bdaddr->bd_addr[3] << 16 | remote_bdaddr->bd_addr[4] << 8 | remote_bdaddr->bd_addr[5];\r\nacl_data->remote_bd_addr_oui = bd_addr_oui;\r\nacl_data->remote_bd_addr_id = bd_addr_id;\r\nk_bd_addr_oui = bd_addr_oui;\r\nk_bd_addr_id = bd_addr_id;\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &k_bd_addr_id;\r\nkey[3].length = 1;\r\nkey[3].key = &k_bd_addr_oui;\r\nkey[4].length = 0;\r\nkey[4].key = NULL;\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(bluetooth_data->bdaddr_to_role, key);\r\ndevice_role = (subtree) ? (device_role_t *) wmem_tree_lookup32_le(subtree, pinfo->num) : NULL;\r\nif (device_role) {\r\nif ((pinfo->p2p_dir == P2P_DIR_SENT && device_role->role == ROLE_MASTER) ||\r\n(pinfo->p2p_dir == P2P_DIR_RECV && device_role->role == ROLE_SLAVE)) {\r\nsrc_role = ROLE_SLAVE;\r\ndst_role = ROLE_MASTER;\r\n} else if ((pinfo->p2p_dir == P2P_DIR_SENT && device_role->role == ROLE_SLAVE) ||\r\n(pinfo->p2p_dir == P2P_DIR_RECV && device_role->role == ROLE_MASTER)) {\r\nsrc_role = ROLE_MASTER;\r\ndst_role = ROLE_SLAVE;\r\n}\r\nrole_last_change_in_frame = device_role->change_in_frame;\r\n}\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(bluetooth_data->bdaddr_to_name, key);\r\ndevice_name = (subtree) ? (device_name_t *) wmem_tree_lookup32_le(subtree, pinfo->num) : NULL;\r\nif (device_name)\r\nremote_name = device_name->name;\r\nelse\r\nremote_name = "";\r\nremote_ether_addr = get_ether_name(remote_bdaddr->bd_addr);\r\nremote_length = (gint)(strlen(remote_ether_addr) + 3 + strlen(remote_name) + 1);\r\nremote_addr_name = (gchar *)wmem_alloc(pinfo->pool, remote_length);\r\ng_snprintf(remote_addr_name, remote_length, "%s (%s)", remote_ether_addr, remote_name);\r\nif (pinfo->p2p_dir == P2P_DIR_RECV) {\r\nsrc_bd_addr = remote_bdaddr->bd_addr;\r\nsrc_name = remote_name;\r\nsrc_addr_name = remote_addr_name;\r\n} else if (pinfo->p2p_dir == P2P_DIR_SENT) {\r\ndst_bd_addr = remote_bdaddr->bd_addr;\r\ndst_name = remote_name;\r\ndst_addr_name = remote_addr_name;\r\n}\r\n} else {\r\nif (pinfo->p2p_dir == P2P_DIR_RECV)\r\nsrc_addr_name = "remote ()";\r\nelse if (pinfo->p2p_dir == P2P_DIR_SENT)\r\ndst_addr_name = "remote ()";\r\n}\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 0;\r\nkey[2].key = NULL;\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(bluetooth_data->localhost_bdaddr, key);\r\nlocalhost_bdaddr_entry = (subtree) ? (localhost_bdaddr_entry_t *) wmem_tree_lookup32_le(subtree, pinfo->num) : NULL;\r\nif (localhost_bdaddr_entry) {\r\nlocalhost_ether_addr = get_ether_name(localhost_bdaddr_entry->bd_addr);\r\nmemcpy(localhost_bdaddr, localhost_bdaddr_entry->bd_addr, 6);\r\n} else {\r\nlocalhost_ether_addr = "localhost";\r\nmemcpy(localhost_bdaddr, unknown_bd_addr, 6);\r\n}\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(bluetooth_data->localhost_name, key);\r\nlocalhost_name_entry = (subtree) ? (localhost_name_entry_t *) wmem_tree_lookup32_le(subtree, pinfo->num) : NULL;\r\nif (localhost_name_entry)\r\nlocalhost_name = localhost_name_entry->name;\r\nelse\r\nlocalhost_name = "";\r\nlocalhost_length = (gint)(strlen(localhost_ether_addr) + 3 + strlen(localhost_name) + 1);\r\nlocalhost_addr_name = (gchar *)wmem_alloc(pinfo->pool, localhost_length);\r\ng_snprintf(localhost_addr_name, localhost_length, "%s (%s)", localhost_ether_addr, localhost_name);\r\nif (pinfo->p2p_dir == P2P_DIR_RECV) {\r\ndst_bd_addr = localhost_bdaddr;\r\ndst_name = localhost_name;\r\ndst_addr_name = localhost_addr_name;\r\n} else if (pinfo->p2p_dir == P2P_DIR_SENT) {\r\nsrc_bd_addr = localhost_bdaddr;\r\nsrc_name = localhost_name;\r\nsrc_addr_name = localhost_addr_name;\r\n}\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &connection_handle;\r\nkey[3].length = 1;\r\nkey[3].key = &direction;\r\nkey[4].length = 0;\r\nkey[4].key = NULL;\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(chandle_tree, key);\r\nchandle_data = (subtree) ? (chandle_data_t *) wmem_tree_lookup32_le(subtree, pinfo->num) : NULL;\r\nif (!pinfo->fd->flags.visited && !chandle_data) {\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &connection_handle;\r\nkey[3].length = 1;\r\nkey[3].key = &direction;\r\nkey[4].length = 1;\r\nkey[4].key = &frame_number;\r\nkey[5].length = 0;\r\nkey[5].key = NULL;\r\nchandle_data = (chandle_data_t *)wmem_alloc(wmem_file_scope(), sizeof(chandle_data_t));\r\nchandle_data->start_fragments = wmem_tree_new(wmem_file_scope());\r\nwmem_tree_insert32_array(chandle_tree, key, chandle_data);\r\n} else if (pinfo->fd->flags.visited && !chandle_data) {\r\nDISSECTOR_ASSERT_HINT(0, "Impossible: no previously session saved");\r\n}\r\nlength = tvb_get_letohs(tvb, offset);\r\nlength_item = proto_tree_add_item(bthci_acl_tree, hf_bthci_acl_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nswitch(pb_flag) {\r\ncase 0x01:\r\nfragmented = TRUE;\r\nbreak;\r\ncase 0x00:\r\ncase 0x02:\r\nl2cap_length = tvb_get_letohs(tvb, offset);\r\nfragmented = (l2cap_length + 4 != length);\r\nbreak;\r\ndefault:\r\nfragmented = FALSE;\r\n}\r\nif (!fragmented || (!acl_reassembly && !(pb_flag & 0x01))) {\r\nif (length < tvb_captured_length_remaining(tvb, offset)) {\r\nexpert_add_info(pinfo, length_item, &ei_length_bad);\r\nlength = tvb_captured_length_remaining(tvb, offset);\r\n}\r\nnext_tvb = tvb_new_subset(tvb, offset, tvb_captured_length_remaining(tvb, offset), length);\r\noffset += call_dissector_with_data(btl2cap_handle, next_tvb, pinfo, tree, acl_data);\r\n} else if (fragmented && acl_reassembly) {\r\nmulti_fragment_pdu_t *mfp = NULL;\r\ngint len;\r\nif (!(pb_flag & 0x01)) {\r\nif (!pinfo->fd->flags.visited) {\r\nmfp = (multi_fragment_pdu_t *) wmem_new(wmem_file_scope(), multi_fragment_pdu_t);\r\nmfp->first_frame = pinfo->num;\r\nmfp->last_frame = 0;\r\nmfp->tot_len = l2cap_length + 4;\r\nmfp->reassembled = (char *) wmem_alloc(wmem_file_scope(), mfp->tot_len);\r\nlen = tvb_captured_length_remaining(tvb, offset);\r\nif (len <= mfp->tot_len) {\r\ntvb_memcpy(tvb, (guint8 *) mfp->reassembled, offset, len);\r\nmfp->cur_off = len;\r\nwmem_tree_insert32(chandle_data->start_fragments, pinfo->num, mfp);\r\n}\r\n} else {\r\nmfp = (multi_fragment_pdu_t *)wmem_tree_lookup32(chandle_data->start_fragments, pinfo->num);\r\n}\r\nif (mfp != NULL && mfp->last_frame) {\r\nproto_item *item;\r\nitem = proto_tree_add_uint(bthci_acl_tree, hf_bthci_acl_reassembled_in, tvb, 0, 0, mfp->last_frame);\r\nPROTO_ITEM_SET_GENERATED(item);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " [Reassembled in #%u]", mfp->last_frame);\r\n}\r\n}\r\nif (pb_flag == 0x01) {\r\nmfp = (multi_fragment_pdu_t *)wmem_tree_lookup32_le(chandle_data->start_fragments, pinfo->num);\r\nif (!pinfo->fd->flags.visited) {\r\nlen = tvb_captured_length_remaining(tvb, offset);\r\nif (mfp != NULL && !mfp->last_frame && (mfp->tot_len >= mfp->cur_off + len)) {\r\ntvb_memcpy(tvb, (guint8 *) mfp->reassembled + mfp->cur_off, offset, len);\r\nmfp->cur_off += len;\r\nif (mfp->cur_off == mfp->tot_len) {\r\nmfp->last_frame = pinfo->num;\r\n}\r\n}\r\n}\r\nif (mfp) {\r\nproto_item *item;\r\nitem = proto_tree_add_uint(bthci_acl_tree, hf_bthci_acl_continuation_to, tvb, 0, 0, mfp->first_frame);\r\nPROTO_ITEM_SET_GENERATED(item);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " [Continuation to #%u]", mfp->first_frame);\r\n}\r\nif (mfp != NULL && mfp->last_frame == pinfo->num) {\r\nnext_tvb = tvb_new_child_real_data(tvb, (guint8 *) mfp->reassembled, mfp->tot_len, mfp->tot_len);\r\nadd_new_data_source(pinfo, next_tvb, "Reassembled BTHCI ACL");\r\noffset += call_dissector_with_data(btl2cap_handle, next_tvb, pinfo, tree, acl_data);\r\n}\r\n}\r\n}\r\nif (tvb_captured_length_remaining(tvb, offset) > 0)\r\nproto_tree_add_item(bthci_acl_tree, hf_bthci_acl_data, tvb, offset, -1, ENC_NA);\r\nif (chandle_session) {\r\nsub_item = proto_tree_add_uint(bthci_acl_tree, hf_bthci_acl_connect_in, tvb, 0, 0, chandle_session->connect_in_frame);\r\nPROTO_ITEM_SET_GENERATED(sub_item);\r\nif (chandle_session->disconnect_in_frame < G_MAXUINT32) {\r\nsub_item = proto_tree_add_uint(bthci_acl_tree, hf_bthci_acl_disconnect_in, tvb, 0, 0, chandle_session->disconnect_in_frame);\r\nPROTO_ITEM_SET_GENERATED(sub_item);\r\n}\r\n}\r\nif (acl_data->disconnect_in_frame == &invalid_session) {\r\nexpert_add_info(pinfo, bthci_acl_itam, &ei_invalid_session);\r\n}\r\nset_address(&pinfo->net_src, AT_STRINGZ, (int)strlen(src_name) + 1, src_name);\r\nset_address(&pinfo->dl_src, AT_ETHER, 6, src_bd_addr);\r\nset_address(&pinfo->src, AT_STRINGZ, (int)strlen(src_addr_name) + 1, src_addr_name);\r\nset_address(&pinfo->net_dst, AT_STRINGZ, (int)strlen(dst_name) + 1, dst_name);\r\nset_address(&pinfo->dl_dst, AT_ETHER, 6, dst_bd_addr);\r\nset_address(&pinfo->dst, AT_STRINGZ, (int)strlen(dst_addr_name) + 1, dst_addr_name);\r\nif (!pinfo->fd->flags.visited) {\r\naddress *addr;\r\naddr = (address *) wmem_memdup(wmem_file_scope(), &pinfo->dl_src, sizeof(address));\r\naddr->data = wmem_memdup(wmem_file_scope(), pinfo->dl_src.data, pinfo->dl_src.len);\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_bluetooth, BLUETOOTH_DATA_SRC, addr);\r\naddr = (address *) wmem_memdup(wmem_file_scope(), &pinfo->dl_dst, sizeof(address));\r\naddr->data = wmem_memdup(wmem_file_scope(), pinfo->dl_dst.data, pinfo->dl_dst.len);\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_bluetooth, BLUETOOTH_DATA_DST, addr);\r\n}\r\nsub_item = proto_tree_add_ether(bthci_acl_tree, hf_bthci_acl_src_bd_addr, tvb, 0, 0, src_bd_addr);\r\nPROTO_ITEM_SET_GENERATED(sub_item);\r\nsub_item = proto_tree_add_string(bthci_acl_tree, hf_bthci_acl_src_name, tvb, 0, 0, src_name);\r\nPROTO_ITEM_SET_GENERATED(sub_item);\r\nsub_item = proto_tree_add_uint(bthci_acl_tree, hf_bthci_acl_src_role, tvb, 0, 0, src_role);\r\nPROTO_ITEM_SET_GENERATED(sub_item);\r\nsub_item = proto_tree_add_ether(bthci_acl_tree, hf_bthci_acl_dst_bd_addr, tvb, 0, 0, dst_bd_addr);\r\nPROTO_ITEM_SET_GENERATED(sub_item);\r\nsub_item = proto_tree_add_string(bthci_acl_tree, hf_bthci_acl_dst_name, tvb, 0, 0, dst_name);\r\nPROTO_ITEM_SET_GENERATED(sub_item);\r\nsub_item = proto_tree_add_uint(bthci_acl_tree, hf_bthci_acl_dst_role, tvb, 0, 0, dst_role);\r\nPROTO_ITEM_SET_GENERATED(sub_item);\r\nif (role_last_change_in_frame > 0) {\r\nsub_item = proto_tree_add_uint(bthci_acl_tree, hf_bthci_acl_role_last_change_in_frame, tvb, 0, 0, role_last_change_in_frame);\r\nPROTO_ITEM_SET_GENERATED(sub_item);\r\n}\r\nsub_item = proto_tree_add_int(bthci_acl_tree, hf_bthci_acl_mode, tvb, 0, 0, mode);\r\nPROTO_ITEM_SET_GENERATED(sub_item);\r\nif (mode_last_change_in_frame > 0) {\r\nsub_item = proto_tree_add_uint(bthci_acl_tree, hf_bthci_acl_mode_last_change_in_frame, tvb, 0, 0, mode_last_change_in_frame);\r\nPROTO_ITEM_SET_GENERATED(sub_item);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_bthci_acl(void)\r\n{\r\nmodule_t *bthci_acl_module;\r\nexpert_module_t *bthci_acl_expert_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_bthci_acl_chandle,\r\n{ "Connection Handle", "bthci_acl.chandle",\r\nFT_UINT16, BASE_HEX, NULL, 0x0FFF,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_acl_pb_flag,\r\n{ "PB Flag", "bthci_acl.pb_flag",\r\nFT_UINT16, BASE_DEC, VALS(pb_flag_vals), 0x3000,\r\n"Packet Boundary Flag", HFILL }\r\n},\r\n{ &hf_bthci_acl_bc_flag,\r\n{ "BC Flag", "bthci_acl.bc_flag",\r\nFT_UINT16, BASE_DEC, VALS(bc_flag_vals), 0xC000,\r\n"Broadcast Flag", HFILL }\r\n},\r\n{ &hf_bthci_acl_length,\r\n{ "Data Total Length", "bthci_acl.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_acl_data,\r\n{ "Data", "bthci_acl.data",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_acl_continuation_to,\r\n{ "This is a continuation to the PDU in frame", "bthci_acl.continuation_to",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n"This is a continuation to the PDU in frame #", HFILL }\r\n},\r\n{ &hf_bthci_acl_reassembled_in,\r\n{ "This PDU is reassembled in frame", "bthci_acl.reassembled_in",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n"This PDU is reassembled in frame #", HFILL }\r\n},\r\n{ &hf_bthci_acl_connect_in,\r\n{ "Connect in frame", "bthci_acl.connect_in",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_acl_disconnect_in,\r\n{ "Disconnect in frame", "bthci_acl.disconnect_in",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_acl_src_bd_addr,\r\n{ "Source BD_ADDR", "bthci_acl.src.bd_addr",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_acl_src_name,\r\n{ "Source Device Name", "bthci_acl.src.name",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_acl_src_role,\r\n{ "Source Role", "bthci_acl.src.role",\r\nFT_UINT32, BASE_DEC, VALS(role_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_acl_dst_bd_addr,\r\n{ "Destination BD_ADDR", "bthci_acl.dst.bd_addr",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_acl_dst_name,\r\n{ "Destination Device Name", "bthci_acl.dst.name",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_acl_dst_role,\r\n{ "Destination Role", "bthci_acl.dst.role",\r\nFT_UINT32, BASE_DEC, VALS(role_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_acl_role_last_change_in_frame,\r\n{ "Last Role Change in Frame", "bthci_acl.last_change_in_frame.role",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_acl_mode,\r\n{ "Current Mode", "bthci_acl.mode",\r\nFT_INT32, BASE_DEC, VALS(mode_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_acl_mode_last_change_in_frame,\r\n{ "Last Mode Change in Frame", "bthci_acl.last_change_in_frame.mode",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_bthci_acl,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_invalid_session, { "bthci_acl.invalid_session", PI_PROTOCOL, PI_ERROR, "Frame is out of any \"connection handle\" session", EXPFILL }},\r\n{ &ei_length_bad, { "bthci_acl.length.bad", PI_MALFORMED, PI_WARN, "Length too short", EXPFILL }},\r\n};\r\nproto_bthci_acl = proto_register_protocol("Bluetooth HCI ACL Packet", "HCI_ACL", "bthci_acl");\r\nbthci_acl_handle = register_dissector("bthci_acl", dissect_bthci_acl, proto_bthci_acl);\r\nproto_register_field_array(proto_bthci_acl, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nbthci_acl_expert_module = expert_register_protocol(proto_bthci_acl);\r\nexpert_register_field_array(bthci_acl_expert_module, ei, array_length(ei));\r\nbthci_acl_module = prefs_register_protocol(proto_bthci_acl, NULL);\r\nprefs_register_bool_preference(bthci_acl_module, "hci_acl_reassembly",\r\n"Reassemble ACL Fragments",\r\n"Whether the ACL dissector should reassemble fragmented PDUs",\r\n&acl_reassembly);\r\nchandle_tree = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\n}\r\nvoid\r\nproto_reg_handoff_bthci_acl(void)\r\n{\r\ndissector_add_uint("hci_h4.type", HCI_H4_TYPE_ACL, bthci_acl_handle);\r\ndissector_add_uint("hci_h1.type", BTHCI_CHANNEL_ACL, bthci_acl_handle);\r\nbtl2cap_handle = find_dissector_add_dependency("btl2cap", proto_bthci_acl);\r\n}
