static int\r\ndissect_device_list_request(packet_info *pinfo)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Device List Request");\r\nreturn 0;\r\n}\r\nstatic int\r\ndissect_device(proto_tree *tree, tvbuff_t *tvb, int offset)\r\n{\r\nguint32 product;\r\nguint32 vendor_id;\r\nguint32 product_id;\r\nproto_tree_add_item(tree, hf_usbip_path, tvb, offset, 256, ENC_ASCII | ENC_NA);\r\noffset += 256;\r\nproto_tree_add_item(tree, hf_usbip_busid, tvb, offset, 32, ENC_ASCII | ENC_NA);\r\noffset += 32;\r\nproto_tree_add_item(tree, hf_usbip_busnum, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_usbip_devnum, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_usbip_speed, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item_ret_uint(tree, hf_usbip_idVendor, tvb, offset, 2, ENC_BIG_ENDIAN, &vendor_id);\r\noffset += 2;\r\nproduct_id = tvb_get_ntohs(tvb, offset);\r\nproduct = vendor_id << 16 | product_id;\r\nproto_tree_add_uint_format_value(tree, hf_usbip_idProduct, tvb, offset, 2,\r\nproduct_id, "%s (0x%04x)", val_to_str_ext_const(product, &ext_usb_products_vals,\r\n"Unknown"), product_id);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_usbip_bcdDevice, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_usbip_bDeviceClass, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_usbip_bDeviceSubClass, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_usbip_bDeviceProtocol, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_usbip_bConfigurationValue, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_usbip_bNumConfigurations, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_usbip_bNumInterfaces, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_device_list_response(packet_info *pinfo, proto_tree *tree,\r\ntvbuff_t *tvb,\r\nint offset)\r\n{\r\nproto_item *ti_intf;\r\nproto_item *ti_dev;\r\nproto_tree *intf_tree = NULL;\r\nproto_tree *dev_tree = NULL;\r\nguint32 num_of_devs;\r\nguint32 i;\r\nguint8 num_of_intf;\r\nguint8 j;\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Device List Response");\r\nproto_tree_add_item_ret_uint(tree, hf_usbip_number_devices, tvb, offset, 4,\r\nENC_BIG_ENDIAN, &num_of_devs);\r\noffset += 4;\r\nfor (i = 0; i < num_of_devs; i++) {\r\nnum_of_intf = tvb_get_guint8(tvb, offset + 0x137);\r\nti_dev = proto_tree_add_uint(tree, hf_usbip_device, tvb, offset,\r\n0x138 + 4 * num_of_intf, i + 1);\r\nPROTO_ITEM_SET_GENERATED(ti_dev);\r\ndev_tree = proto_item_add_subtree(ti_dev, ett_usbip_dev);\r\noffset = dissect_device(dev_tree, tvb, offset);\r\nfor (j = 0; j < num_of_intf; j++) {\r\nti_intf = proto_tree_add_uint(dev_tree, hf_usbip_interface, tvb,\r\noffset, 3, j + 1);\r\nintf_tree = proto_item_add_subtree(ti_intf, ett_usbip_intf);\r\nproto_tree_add_item(intf_tree, hf_usbip_bInterfaceClass, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(intf_tree, hf_usbip_bInterfaceSubClass, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(intf_tree, hf_usbip_bInterfaceProtocol, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(intf_tree, hf_usbip_padding, tvb,\r\noffset, 1, ENC_NA);\r\noffset += 1;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_import_request(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\r\nint offset)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Import Request");\r\nproto_tree_add_item(tree, hf_usbip_busid, tvb, offset, 32, ENC_ASCII | ENC_NA);\r\nreturn offset + 32;\r\n}\r\nstatic int\r\ndissect_import_response(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\r\nint offset, guint32 status)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Import Response");\r\nif (status == 0)\r\noffset = dissect_device(tree, tvb, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_cmd_submit(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\r\nint offset)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_INFO, "URB Submit");\r\nproto_tree_add_item(tree, hf_usbip_transfer_flags, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_usbip_transfer_buffer_length, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_usbip_start_frame, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_usbip_number_of_packets, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_usbip_interval, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_usbip_setup, tvb, offset, 8, ENC_NA);\r\noffset += 8;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_ret_submit(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\r\nint offset)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_INFO, "URB Response");\r\nproto_tree_add_item(tree, hf_usbip_status, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_usbip_actual_length, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_usbip_start_frame, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_usbip_number_of_packets, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_usbip_error_count, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_usbip_setup, tvb, offset, 8, ENC_NA);\r\noffset += 8;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_cmd_unlink(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\r\nint offset, usbip_conv_info_t *usbip_info,\r\nusbip_transaction_t *trans)\r\n{\r\nusbip_transaction_t *victim;\r\nguint32 seqnum;\r\ncol_set_str(pinfo->cinfo, COL_INFO, "URB Unlink");\r\nproto_tree_add_item_ret_uint(tree, hf_usbip_seqnum, tvb, offset, 4, ENC_BIG_ENDIAN, &seqnum);\r\ntrans->unlink_seqnum = seqnum;\r\noffset += 4;\r\nvictim = (usbip_transaction_t *) wmem_tree_lookup32(usbip_info->pdus, seqnum);\r\nif (victim) {\r\nproto_item *ti;\r\nti = proto_tree_add_uint(tree, hf_usbip_vic_frame, NULL, 0, 0,\r\nvictim->cmd_frame);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_ret_unlink(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\r\nint offset, usbip_conv_info_t *usbip_info,\r\nguint32 seqnum)\r\n{\r\nusbip_transaction_t *victim;\r\ncol_set_str(pinfo->cinfo, COL_INFO, "URB Unlink Response");\r\nvictim = (usbip_transaction_t *) wmem_tree_lookup32(usbip_info->pdus, seqnum);\r\nif (victim) {\r\nproto_item *ti;\r\nvictim->ret_frame = pinfo->num;\r\nti = proto_tree_add_uint(tree, hf_usbip_vic_frame, NULL, 0, 0,\r\nvictim->cmd_frame);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\n}\r\nproto_tree_add_item(tree, hf_usbip_status, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nreturn offset;\r\n}\r\nstatic usbip_conv_info_t *\r\nusbip_get_usbip_conv(packet_info *pinfo)\r\n{\r\nconversation_t *conversation;\r\nusbip_conv_info_t *usbip_info;\r\nconversation = find_or_create_conversation(pinfo);\r\nusbip_info = (usbip_conv_info_t *) conversation_get_proto_data(conversation,\r\nproto_usbip);\r\nif (!usbip_info) {\r\nusbip_info = wmem_new(wmem_file_scope(), usbip_conv_info_t);\r\nusbip_info->pdus = wmem_tree_new(wmem_file_scope());\r\nconversation_add_proto_data(conversation, proto_usbip, usbip_info);\r\n}\r\nreturn usbip_info;\r\n}\r\nstatic int\r\nusbip_dissect_op(packet_info *pinfo, tvbuff_t *tvb, proto_tree *tree,\r\nint offset)\r\n{\r\nproto_item *ti = NULL;\r\nguint32 operation;\r\ngint32 status;\r\nproto_tree_add_item(tree, hf_usbip_version, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item_ret_uint(tree, hf_usbip_operation, tvb, offset, 2,\r\nENC_BIG_ENDIAN, &operation);\r\noffset += 2;\r\nproto_tree_add_item_ret_int(tree, hf_usbip_status, tvb, offset, 4, ENC_BIG_ENDIAN, &status);\r\noffset += 4;\r\nswitch (operation) {\r\ncase OP_REQ_IMPORT:\r\noffset = dissect_import_request(pinfo, tree, tvb, offset);\r\nbreak;\r\ncase OP_REP_IMPORT:\r\noffset = dissect_import_response(pinfo, tree, tvb, offset, status);\r\nbreak;\r\ncase OP_REQ_DEVLIST:\r\noffset = dissect_device_list_request(pinfo);\r\nbreak;\r\ncase OP_REP_DEVLIST:\r\noffset = dissect_device_list_response(pinfo, tree, tvb, offset);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tree, hf_usbip_urb_data, tvb, offset, -1, ENC_NA);\r\noffset = tvb_reported_length_remaining(tvb, offset);\r\nexpert_add_info_format(\r\npinfo, ti, &ei_usbip,\r\n"Dissector for USBIP Operation"\r\n" (%x) code not implemented, Contact"\r\n" Wireshark developers if you want this supported",\r\noperation);\r\nproto_item_append_text(ti, ": Undecoded");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\nusbip_dissect_urb(packet_info *pinfo, tvbuff_t *tvb, proto_tree *tree,\r\nproto_tree *orig, int offset,\r\nusbip_conv_info_t *usbip_info)\r\n{\r\nproto_item *ti = NULL;\r\nusbip_transaction_t *usbip_trans;\r\nguint32 command;\r\nguint32 devid;\r\nguint32 seqnum;\r\nguint32 dir;\r\nguint32 ep;\r\nstruct usbip_header header;\r\nproto_tree_add_item_ret_uint(tree, hf_usbip_command, tvb, offset, 4, ENC_BIG_ENDIAN, &command);\r\noffset += 4;\r\nproto_tree_add_item_ret_uint(tree, hf_usbip_seqnum, tvb, offset, 4, ENC_BIG_ENDIAN, &seqnum);\r\noffset += 4;\r\ndir = tvb_get_ntohl(tvb, offset + 4);\r\nep = tvb_get_ntohl(tvb, offset + 8);\r\ndevid = tvb_get_ntohl(tvb, offset);\r\nif (!PINFO_FD_VISITED(pinfo)) {\r\nif (command == OP_CMD_SUBMIT || command == OP_CMD_UNLINK) {\r\nusbip_trans = wmem_new(wmem_file_scope(), usbip_transaction_t);\r\nusbip_trans->devid = devid;\r\nusbip_trans->dir = dir;\r\nusbip_trans->ep = ep;\r\nusbip_trans->seqnum = seqnum;\r\nusbip_trans->cmd_frame = pinfo->num;\r\nusbip_trans->ret_frame = 0;\r\nusbip_trans->unlink_seqnum = 0;\r\nwmem_tree_insert32(usbip_info->pdus, seqnum, (void *) usbip_trans);\r\n} else {\r\nusbip_trans = (usbip_transaction_t *) wmem_tree_lookup32(usbip_info->pdus, seqnum);\r\nif (usbip_trans)\r\nusbip_trans->ret_frame = pinfo->num;\r\n}\r\n} else {\r\nusbip_trans = (usbip_transaction_t *) wmem_tree_lookup32(usbip_info->pdus, seqnum);\r\n}\r\nif (!usbip_trans) {\r\nusbip_trans = wmem_new(wmem_packet_scope(), usbip_transaction_t);\r\nusbip_trans->cmd_frame = 0;\r\nusbip_trans->ret_frame = 0;\r\nusbip_trans->devid = 0;\r\nusbip_trans->unlink_seqnum = 0;\r\nusbip_trans->seqnum = seqnum;\r\n}\r\nif (command == OP_RET_SUBMIT || command == OP_RET_UNLINK) {\r\ndevid = usbip_trans->devid;\r\nep = usbip_trans->ep;\r\ndir = usbip_trans->dir;\r\n}\r\nti = proto_tree_add_uint(tree, hf_usbip_cmd_frame, NULL, 0, 0,\r\nusbip_trans->cmd_frame);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nti = proto_tree_add_uint(tree, hf_usbip_ret_frame, NULL, 0, 0,\r\nusbip_trans->ret_frame);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nti = proto_tree_add_uint(tree, hf_usbip_devid, NULL, 0, 0, devid);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nti = proto_tree_add_uint(tree, hf_usbip_direction, NULL, 0, 0, dir);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nti = proto_tree_add_uint(tree, hf_usbip_ep, NULL, 0, 0, ep);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nproto_tree_add_item(tree, hf_usbip_devid, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_usbip_direction, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_usbip_ep, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nheader.ep = ep;\r\nheader.dir = dir;\r\nheader.devid = devid & 0x00ff;\r\nheader.busid = devid >> 16;\r\nswitch (command) {\r\ncase OP_CMD_SUBMIT:\r\noffset = dissect_cmd_submit(pinfo, tree, tvb, offset);\r\ndissect_usb_common(tvb, pinfo, orig, USB_HEADER_USBIP, &header);\r\nbreak;\r\ncase OP_CMD_UNLINK:\r\noffset = dissect_cmd_unlink(pinfo, tree, tvb, offset, usbip_info,\r\nusbip_trans);\r\nbreak;\r\ncase OP_RET_SUBMIT: {\r\nguint32 status;\r\nstatus = tvb_get_ntohl(tvb, offset);\r\noffset = dissect_ret_submit(pinfo, tree, tvb, offset);\r\nif (status == 0)\r\ndissect_usb_common(tvb, pinfo, orig, USB_HEADER_USBIP, &header);\r\nbreak;\r\n}\r\ncase OP_RET_UNLINK:\r\noffset = dissect_ret_unlink(pinfo, tree, tvb, offset, usbip_info,\r\nusbip_trans->unlink_seqnum);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tree, hf_usbip_urb_data, tvb, offset, -1, ENC_NA);\r\noffset = tvb_reported_length_remaining(tvb, offset);\r\nexpert_add_info_format(\r\npinfo, ti, &ei_usbip,\r\n"Dissector for USBIP Command"\r\n" (%x) code not implemented, Contact"\r\n" Wireshark developers if you want this supported",\r\ncommand);\r\nproto_item_append_text(ti, ": Undecoded");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_usbip_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nvoid *data _U_)\r\n{\r\nguint16 version;\r\nint offset = 0;\r\nproto_item *ti = NULL;\r\nproto_tree *usbip_tree = NULL;\r\nusbip_conv_info_t *usbip_info;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "USBIP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nusbip_info = usbip_get_usbip_conv(pinfo);\r\nti = proto_tree_add_item(tree, proto_usbip, tvb, 0, -1, ENC_NA);\r\nusbip_tree = proto_item_add_subtree(ti, ett_usbip);\r\nversion = tvb_get_ntohs(tvb, 0);\r\nif (version == USBIP_SUPPORTED_VERSION) {\r\noffset = usbip_dissect_op(pinfo, tvb, usbip_tree, offset);\r\n} else if (version == 0x0000) {\r\noffset = usbip_dissect_urb(pinfo, tvb, usbip_tree, tree, offset,\r\nusbip_info);\r\n} else {\r\nproto_tree_add_item(usbip_tree, hf_usbip_urb_data, tvb, offset, -1,\r\nENC_NA);\r\noffset = tvb_reported_length_remaining(tvb, offset);\r\nexpert_add_info_format(\r\npinfo, ti, &ei_usbip,\r\n"Dissector for USBIP Version"\r\n" (%d.%d) not implemented, Contact"\r\n" Wireshark developers if you want this supported",\r\nversion >> 8, version & 0xff);\r\nproto_item_append_text(ti, ": Undecoded");\r\n}\r\nreturn offset;\r\n}\r\nstatic unsigned int\r\nget_usbip_message_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset,\r\nvoid *data _U_)\r\n{\r\nguint16 version;\r\nversion = tvb_get_ntohs(tvb, offset);\r\nif (version == USBIP_SUPPORTED_VERSION) {\r\nguint16 op = tvb_get_ntohs(tvb, offset + 2);\r\nswitch (op) {\r\ncase OP_REQ_IMPORT:\r\nreturn 40;\r\ncase OP_REP_IMPORT:\r\nif (tvb_get_ntohl(tvb, offset + 4) == 0) {\r\nreturn 0x140;\r\n} else {\r\nreturn 0x8;\r\n}\r\ncase OP_REQ_DEVLIST:\r\nreturn 8;\r\ncase OP_REP_DEVLIST: {\r\nunsigned int expected_size = 0xc;\r\nunsigned int num_of_devs;\r\nunsigned int i;\r\nif (tvb_captured_length(tvb) < 0xc) {\r\nreturn 0x0;\r\n}\r\noffset += 8;\r\nnum_of_devs = tvb_get_ntohl(tvb, offset);\r\noffset += 4;\r\nif (num_of_devs == 0)\r\nreturn expected_size;\r\nif (tvb_captured_length_remaining(tvb, offset) < (gint) (0x138 * num_of_devs))\r\nreturn 0;\r\nfor (i = 0; i < num_of_devs; i++) {\r\nguint8 num_of_intf = tvb_get_guint8(tvb, offset + 0x137);\r\nint skip = num_of_intf * 4;\r\nexpected_size += 0x138 + skip;\r\noffset += 0x138 + skip;\r\n}\r\nreturn expected_size;\r\n}\r\n}\r\n} else if (version == 0x0000) {\r\nguint32 cmd = tvb_get_ntohl(tvb, offset);\r\nif (tvb_captured_length_remaining(tvb, offset) < USBIP_HEADER_LEN)\r\nreturn 0;\r\nswitch (cmd) {\r\ncase OP_RET_UNLINK:\r\nreturn USBIP_HEADER_LEN;\r\ncase OP_CMD_UNLINK:\r\nreturn USBIP_HEADER_LEN;\r\ncase OP_CMD_SUBMIT: {\r\nint expected_size = USBIP_HEADER_LEN;\r\nif (tvb_get_ntohl(tvb, offset + 0xc) == USBIP_DIR_OUT)\r\nexpected_size += tvb_get_ntohl(tvb, offset + 0x18);\r\nexpected_size += tvb_get_ntohl(tvb, offset + 0x20) * 4 * 4;\r\nreturn expected_size;\r\n}\r\ncase OP_RET_SUBMIT: {\r\nint expected_size = USBIP_HEADER_LEN;\r\nusbip_transaction_t *usbip_trans = NULL;\r\nusbip_conv_info_t *usbip_info = usbip_get_usbip_conv(pinfo);\r\nguint32 status = tvb_get_ntohl(tvb, offset + 0x14);\r\nif (usbip_info) {\r\nusbip_trans = (usbip_transaction_t *) wmem_tree_lookup32(\r\nusbip_info->pdus, tvb_get_ntohl(tvb, offset + 4));\r\nif (usbip_trans && usbip_trans->dir == USBIP_DIR_IN && status == 0)\r\nexpected_size += tvb_get_ntohl(tvb, offset + 0x18);\r\n}\r\nif (status == 0)\r\nexpected_size += tvb_get_ntohl(tvb, offset + 0x20) * 4 * 4;\r\nelse\r\nexpected_size = tvb_captured_length(tvb);\r\nreturn expected_size;\r\n}\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_usbip(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nif (tvb_reported_length(tvb) < 4) {\r\nreturn 0;\r\n}\r\ntcp_dissect_pdus(tvb, pinfo, tree, TRUE, FRAME_HEADER_LEN,\r\nget_usbip_message_len, dissect_usbip_common, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_usbip(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{&hf_usbip_version,\r\n{"Version", "usbip.version",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"Version of the protocol", HFILL}},\r\n{&hf_usbip_operation,\r\n{"Operation", "usbip.operation",\r\nFT_UINT16, BASE_HEX | BASE_EXT_STRING, &usbip_operation_vals_ext,\r\n0x0,\r\n"USBIP Operation", HFILL}},\r\n{&hf_usbip_command,\r\n{"Command", "usbip.urb",\r\nFT_UINT32, BASE_HEX | BASE_EXT_STRING, &usbip_urb_vals_ext, 0x0,\r\n"USBIP URB Transaction", HFILL}},\r\n{&hf_usbip_status,\r\n{"Status", "usbip.status",\r\nFT_INT32, BASE_DEC | BASE_EXT_STRING, &usb_urb_status_vals_ext, 0,\r\n"USBIP Status", HFILL}},\r\n{&hf_usbip_number_devices,\r\n{"Number of exported Devices", "usbip.number_of_devices",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_path,\r\n{"System Path", "usbip.system_path",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_devid,\r\n{"Devid", "usbip.devid",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}},\r\n{&hf_usbip_busid,\r\n{"Busid", "usbip.busid",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_busnum,\r\n{"Bus number", "usbip.bus_num",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}},\r\n{&hf_usbip_devnum,\r\n{"Device Number", "usbip.dev_num",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}},\r\n{&hf_usbip_speed,\r\n{"Connected Speed", "usbip.speed",\r\nFT_UINT32, BASE_DEC | BASE_EXT_STRING, &usbip_speed_vals_ext, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_idVendor,\r\n{"idVendor", "usbip.idVendor",\r\nFT_UINT16, BASE_HEX | BASE_EXT_STRING, &ext_usb_vendors_vals, 0x0,\r\nNULL, HFILL}},\r\n{&hf_usbip_idProduct,\r\n{"idProduct", "usbip.idProduct",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}},\r\n{&hf_usbip_bcdDevice,\r\n{"bcdDevice", "usbip.bcdDevice",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}},\r\n{&hf_usbip_bDeviceClass,\r\n{"bDeviceClass", "usbip.bDeviceClass",\r\nFT_UINT8, BASE_HEX | BASE_EXT_STRING, &usb_class_vals_ext, 0x0,\r\nNULL, HFILL}},\r\n{&hf_usbip_bDeviceSubClass,\r\n{"bDeviceSubClass", "usbip.bDeviceSubClass",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_bDeviceProtocol,\r\n{"bDeviceProtocol", "usbip.bDeviceProtocol",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_bConfigurationValue,\r\n{"bConfigurationValue", "usbip.bConfigurationValue",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_bNumConfigurations,\r\n{"bNumConfigurations", "usbip.bNumConfigurations",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_bNumInterfaces,\r\n{"bNumInterfaces", "usbip.bNumInterfaces",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_bInterfaceClass,\r\n{"bInterfaceClass", "usbip.bInterfaceClass",\r\nFT_UINT8, BASE_HEX | BASE_EXT_STRING, &usb_class_vals_ext, 0x0,\r\nNULL, HFILL}},\r\n{&hf_usbip_bInterfaceSubClass,\r\n{"bInterfaceSubClass", "usbip.bInterfaceSubClass",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}},\r\n{&hf_usbip_bInterfaceProtocol,\r\n{"bInterfaceProtocol", "usbip.bInterfaceProtocol",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}},\r\n{&hf_usbip_padding,\r\n{"Padding", "usbip.padding",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_device,\r\n{"Device", "usbip.device",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_interface,\r\n{"Interface", "usbip.interface",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_interval,\r\n{"Interval", "usbip.interval",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"maximum time for the request on the server-side host controller",\r\nHFILL}},\r\n{&hf_usbip_actual_length,\r\n{"Actual length", "usbip.actual_length",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_error_count,\r\n{"ISO error count", "usbip.iso.error_count",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_seqnum,\r\n{"Sequence", "usbip.sequence_no",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Sequence number", HFILL}},\r\n{&hf_usbip_cmd_frame,\r\n{"Command frame", "usbip.cmd_frame",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_ret_frame,\r\n{"Return frame", "usbip.ret_frame",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_vic_frame,\r\n{"Victim frame", "usbip.vic_frame",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0,\r\n"Frame which was forcefully cancelled", HFILL}},\r\n{&hf_usbip_direction,\r\n{"Direction", "usbip.endpoint_number.direction",\r\nFT_UINT8, BASE_HEX, VALS(usb_endpoint_direction_vals), 0x1,\r\n"USB endpoint direction", HFILL}},\r\n{&hf_usbip_ep,\r\n{"Endpoint", "usbip.endpoint_number",\r\nFT_UINT8, BASE_HEX, NULL, 0xf,\r\n"USB endpoint number", HFILL}},\r\n{&hf_usbip_transfer_flags,\r\n{"Transfer flags", "usbip.transfer_flags",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"USBIP Transferflag", HFILL}},\r\n{&hf_usbip_transfer_buffer_length,\r\n{"Transfer buffer length [bytes]", "usbip.transfer_buffer_length",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Data length in bytes", HFILL}},\r\n{&hf_usbip_start_frame,\r\n{"ISO Start frame", "usbip.iso.start_frame",\r\nFT_INT32, BASE_DEC, NULL, 0,\r\n"For an ISO frame the actually selected frame to transmit", HFILL}},\r\n{&hf_usbip_number_of_packets,\r\n{"Number of ISO descriptors", "usbip.iso.num_of_packets",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_setup,\r\n{"Setup Data", "usbip.setup",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL}},\r\n{&hf_usbip_urb_data,\r\n{"Data", "usbip.data",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Raw Data", HFILL}},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_usbip,\r\n&ett_usbip_dev,\r\n&ett_usbip_intf,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{&ei_usbip,\r\n{ "usbip.unsupported_version", PI_MALFORMED, PI_ERROR,\r\n"Unsupported element", EXPFILL}},\r\n};\r\nexpert_module_t *expert_usbip;\r\nexpert_usbip = expert_register_protocol(proto_usbip);\r\nexpert_register_field_array(expert_usbip, ei, array_length(ei));\r\nproto_usbip = proto_register_protocol("USBIP Protocol", "USBIP", "usbip");\r\nproto_register_field_array(proto_usbip, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_usbip(void)\r\n{\r\ndissector_handle_t usbip_handle;\r\nusbip_handle = create_dissector_handle(dissect_usbip, proto_usbip);\r\ndissector_add_for_decode_as("tcp.port", usbip_handle);\r\n}
