static gboolean\r\nbutton_press_handler(GtkWidget *widget, GdkEvent *event, gpointer data _U_)\r\n{\r\nif (widget == NULL || event == NULL) {\r\nreturn FALSE;\r\n}\r\ntree_view_select(widget, (GdkEventButton *) event);\r\nif (event->type == GDK_2BUTTON_PRESS) {\r\nGtkTreePath *path;\r\nif (gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(widget),\r\n(gint) (((GdkEventButton *)event)->x),\r\n(gint) (((GdkEventButton *)event)->y),\r\n&path, NULL, NULL, NULL))\r\n{\r\nif (gtk_tree_view_row_expanded(GTK_TREE_VIEW(widget), path)) {\r\ngtk_tree_view_collapse_row(GTK_TREE_VIEW(widget), path);\r\n} else {\r\ngtk_tree_view_expand_row(GTK_TREE_VIEW(widget), path, FALSE);\r\n}\r\ngtk_tree_path_free(path);\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nstatic char*\r\ncreate_packet_window_title(void)\r\n{\r\nGString *title;\r\nint i;\r\ntitle = g_string_new("");\r\nfor (i = 0; i < cfile.cinfo.num_cols; ++i) {\r\ng_string_append(title, cfile.cinfo.columns[i].col_data);\r\ng_string_append_c(title, ' ');\r\n}\r\nreturn g_string_free(title, FALSE);\r\n}\r\nstatic void\r\nredissect_packet_window(gpointer object, gpointer user_data _U_)\r\n{\r\nstruct PacketWinData *DataPtr = (struct PacketWinData *)object;\r\nchar *title;\r\nproto_tree_draw(NULL, DataPtr->tree_view);\r\nepan_dissect_cleanup(&(DataPtr->edt));\r\nepan_dissect_init(&(DataPtr->edt), cfile.epan, TRUE, TRUE);\r\nepan_dissect_run(&(DataPtr->edt), cfile.cd_t, &DataPtr->phdr, frame_tvbuff_new(DataPtr->frame, DataPtr->pd), DataPtr->frame, NULL);\r\nadd_byte_views(&(DataPtr->edt), DataPtr->tree_view, DataPtr->bv_nb_ptr);\r\nproto_tree_draw(DataPtr->edt.tree, DataPtr->tree_view);\r\ntitle = create_packet_window_title();\r\ngtk_window_set_title(GTK_WINDOW(DataPtr->main), title);\r\ng_free(title);\r\n}\r\nstatic field_info *\r\nproto_finfo_find(proto_tree *tree, field_info *old_finfo)\r\n{\r\nproto_node *node;\r\nfor (node = tree->first_child; node != NULL; node = node->next) {\r\nfield_info *cur = PNODE_FINFO(node);\r\nif (!cur)\r\ncontinue;\r\nif (cur->hfinfo == old_finfo->hfinfo &&\r\ncur->start == old_finfo->start && cur->length == old_finfo->length &&\r\ncur->appendix_start == old_finfo->appendix_start && cur->appendix_length == old_finfo->appendix_length &&\r\ncur->tree_type == old_finfo->tree_type && cur->flags == old_finfo->flags)\r\n{\r\nreturn cur;\r\n}\r\nif ((cur = proto_finfo_find((proto_tree *)node, old_finfo)))\r\nreturn cur;\r\n}\r\nreturn NULL;\r\n}\r\nstatic gboolean\r\nfinfo_window_refresh(struct FieldinfoWinData *DataPtr)\r\n{\r\nfield_info *old_finfo = DataPtr->finfo;\r\nfield_info *finfo;\r\nepan_dissect_t edt;\r\nconst guint8 *data;\r\nGtkWidget *byte_view;\r\ngchar label_str[ITEM_LABEL_LENGTH];\r\nif (DataPtr->bv && (byte_view = get_notebook_bv_ptr(DataPtr->bv))) {\r\nint pos_inside = DataPtr->pd_offset - DataPtr->start_offset - old_finfo->start;\r\nif (pos_inside < 0 || pos_inside >= old_finfo->length)\r\npos_inside = -1;\r\ndata = DataPtr->pd + DataPtr->start_offset + old_finfo->start;\r\npacket_hex_editor_print(byte_view, data, DataPtr->frame, pos_inside, DataPtr->pd_bitoffset, old_finfo->length);\r\n}\r\nif (DataPtr->app_bv && (byte_view = get_notebook_bv_ptr(DataPtr->app_bv))) {\r\nint pos_inside = DataPtr->pd_offset - DataPtr->start_offset - old_finfo->appendix_start;\r\nif (pos_inside < 0 || pos_inside >= old_finfo->appendix_length)\r\npos_inside = -1;\r\ndata = DataPtr->pd + DataPtr->start_offset + old_finfo->appendix_start;\r\npacket_hex_editor_print(byte_view, data, DataPtr->frame, pos_inside, DataPtr->pd_bitoffset, old_finfo->appendix_length);\r\n}\r\nepan_dissect_init(&edt, cfile.epan, TRUE, TRUE);\r\nepan_dissect_run(&edt, cfile.cd_t, &DataPtr->phdr, frame_tvbuff_new(DataPtr->frame, DataPtr->pd), DataPtr->frame, NULL);\r\nif (!(finfo = proto_finfo_find(edt.tree, old_finfo))) {\r\nepan_dissect_cleanup(&edt);\r\ngtk_entry_set_text(GTK_ENTRY(DataPtr->repr), "[finfo not found, try with another value, or restore old. If you think it is bug, fill bugreport]");\r\nreturn FALSE;\r\n}\r\nif (finfo->rep == NULL) {\r\nproto_item_fill_label(finfo, label_str);\r\ngtk_entry_set_text(GTK_ENTRY(DataPtr->repr), label_str);\r\n} else\r\ngtk_entry_set_text(GTK_ENTRY(DataPtr->repr), finfo->rep->representation);\r\nepan_dissect_cleanup(&edt);\r\nreturn TRUE;\r\n}\r\nstatic void\r\nfinfo_integer_common(struct FieldinfoWinData *DataPtr, guint64 u_val)\r\n{\r\nconst field_info *finfo = DataPtr->finfo;\r\nconst header_field_info *hfinfo = finfo->hfinfo;\r\nunsigned int finfo_offset = DataPtr->start_offset + finfo->start;\r\nint finfo_length = finfo->length;\r\nif (finfo_offset <= DataPtr->frame->cap_len && finfo_offset + finfo_length <= DataPtr->frame->cap_len) {\r\nguint64 u_mask = hfinfo->bitmask;\r\nwhile (finfo_length--) {\r\nguint8 *ptr = (FI_GET_FLAG(finfo, FI_LITTLE_ENDIAN)) ?\r\n&(DataPtr->pd[finfo_offset++]) :\r\n&(DataPtr->pd[finfo_offset + finfo_length]);\r\nif (u_mask) {\r\nguint8 n_val = *ptr;\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nif (u_mask & 1) {\r\nif (u_val & 1)\r\nn_val |= (1 << i);\r\nelse\r\nn_val &= ~(1 << i);\r\n}\r\nu_mask >>= 1;\r\nu_val >>= 1;\r\n}\r\n*ptr = n_val;\r\nif (!u_mask)\r\nbreak;\r\n} else {\r\n*ptr = u_val & 0xff;\r\nu_val >>= 8;\r\n}\r\n}\r\n}\r\nfinfo_window_refresh(DataPtr);\r\n}\r\nstatic void\r\nfinfo_string_changed(GtkEditable *editable, gpointer user_data)\r\n{\r\nstruct FieldinfoWinData *DataPtr = (struct FieldinfoWinData *) user_data;\r\nconst field_info *finfo = DataPtr->finfo;\r\nunsigned int finfo_offset = DataPtr->start_offset + finfo->start;\r\nint finfo_length = finfo->length;\r\nint finfo_type = (finfo->hfinfo) ? finfo->hfinfo->type : FT_NONE;\r\nconst gchar *val = gtk_entry_get_text(GTK_ENTRY(editable));\r\nif (finfo_offset <= DataPtr->frame->cap_len && finfo_offset + finfo_length <= DataPtr->frame->cap_len) {\r\nwhile (finfo_length && *val) {\r\nDataPtr->pd[finfo_offset++] = *val;\r\nfinfo_length--;\r\nval++;\r\n}\r\nif (finfo_type == FT_STRINGZ && finfo_length) {\r\nDataPtr->pd[finfo_offset++] = '\0';\r\nfinfo_length--;\r\n}\r\nwhile (finfo_length > 0) {\r\nDataPtr->pd[finfo_offset++] = '\0';\r\nfinfo_length--;\r\n}\r\n}\r\nfinfo_window_refresh(DataPtr);\r\n}\r\nstatic void\r\nfinfo_boolean_changed(GtkToggleButton *togglebutton, gpointer user_data)\r\n{\r\nstruct FieldinfoWinData *DataPtr = (struct FieldinfoWinData *) user_data;\r\ngboolean val = gtk_toggle_button_get_active(togglebutton);\r\nfinfo_integer_common(DataPtr, val ? G_MAXUINT64 : 0);\r\n}\r\nstatic void\r\nfinfo_integer_changed(GtkSpinButton *spinbutton, gpointer user_data)\r\n{\r\nstruct FieldinfoWinData *DataPtr = (struct FieldinfoWinData *) user_data;\r\nconst field_info *finfo = DataPtr->finfo;\r\nconst header_field_info *hfinfo = finfo->hfinfo;\r\nint finfo_type = (hfinfo) ? hfinfo->type : FT_NONE;\r\ngdouble val = gtk_spin_button_get_value(spinbutton);\r\nguint64 u_val;\r\nif (finfo_type == FT_INT8 || finfo_type == FT_INT16 || finfo_type == FT_INT24 || finfo_type == FT_INT32 || finfo_type == FT_INT64)\r\nu_val = (guint64) ((gint64) val);\r\nelse if (finfo_type == FT_UINT8 || finfo_type == FT_UINT16 || finfo_type == FT_UINT24 || finfo_type == FT_UINT32 || finfo_type == FT_UINT64)\r\nu_val = (guint64) val;\r\nelse {\r\ng_assert_not_reached();\r\nreturn;\r\n}\r\nif (hfinfo->bitmask)\r\nu_val <<= hfinfo_bitshift(hfinfo);\r\nfinfo_integer_common(DataPtr, u_val);\r\n}\r\nstatic void\r\nfinfo_ipv4_changed(GtkSpinButton *spinbutton, gpointer user_data)\r\n{\r\nstruct FieldinfoWinData *DataPtr = (struct FieldinfoWinData *) user_data;\r\ngdouble val = gtk_spin_button_get_value(spinbutton);\r\nfinfo_integer_common(DataPtr, (guint32) val);\r\n}\r\nstatic gboolean\r\nfinfo_bv_key_pressed_cb(GtkWidget *bv _U_, GdkEventKey *event, gpointer user_data)\r\n{\r\nstruct FieldinfoWinData *DataPtr = (struct FieldinfoWinData *)user_data;\r\nconst field_info *finfo = DataPtr->finfo;\r\nstruct CommonWinData data;\r\ngboolean have_appendix;\r\ngboolean ret;\r\ndata.frame = DataPtr->frame;\r\ndata.pd = DataPtr->pd;\r\ndata.pd_offset = DataPtr->pd_offset;\r\ndata.pd_bitoffset = DataPtr->pd_bitoffset;\r\nret = edit_pkt_common_key_pressed_cb(event, &data);\r\nDataPtr->pd_offset = data.pd_offset;\r\nDataPtr->pd_bitoffset = data.pd_bitoffset;\r\nhave_appendix = (finfo->appendix_start >= 0 && finfo->appendix_length > 0);\r\nif ((DataPtr->pd_offset >= DataPtr->start_offset + finfo->start && DataPtr->pd_offset < DataPtr->start_offset + finfo->start + finfo->length) ||\r\n(have_appendix && DataPtr->pd_offset >= DataPtr->start_offset + finfo->appendix_start && DataPtr->pd_offset < DataPtr->start_offset + finfo->appendix_start + finfo->appendix_length))\r\n{ }\r\nelse\r\nif (have_appendix && DataPtr->pd_offset >= DataPtr->start_offset + finfo->appendix_start + finfo->appendix_length) {\r\nDataPtr->pd_offset = DataPtr->start_offset + finfo->start;\r\nDataPtr->pd_bitoffset = 0;\r\n} else if (DataPtr->pd_offset >= DataPtr->start_offset + finfo->start + finfo->length) {\r\nif (have_appendix)\r\nDataPtr->pd_offset = DataPtr->start_offset + finfo->appendix_start;\r\nelse\r\nDataPtr->pd_offset = DataPtr->start_offset + finfo->start;\r\nDataPtr->pd_bitoffset = 0;\r\n}\r\nelse\r\nif (DataPtr->pd_offset < DataPtr->start_offset + finfo->start) {\r\nif (have_appendix)\r\nDataPtr->pd_offset = DataPtr->start_offset + finfo->appendix_start + finfo->appendix_length-1;\r\nelse\r\nDataPtr->pd_offset = DataPtr->start_offset + finfo->start + finfo->length-1;\r\n} else if (have_appendix && DataPtr->pd_offset < DataPtr->start_offset + finfo->appendix_start) {\r\nDataPtr->pd_offset = DataPtr->start_offset + finfo->start + finfo->length-1;\r\n}\r\nif (ret)\r\nfinfo_window_refresh(DataPtr);\r\nreturn ret;\r\n}\r\nstatic gint\r\nfinfo_ipv4_input(GtkSpinButton *spinbutton, gpointer arg1, gpointer user_data _U_)\r\n{\r\nconst gchar *addr_str = gtk_entry_get_text(GTK_ENTRY(spinbutton));\r\ngdouble *out_val = (gdouble *) arg1;\r\nguint32 addr;\r\n#if 0\r\nif (!get_host_ipaddr(addr_str, &addr))\r\nreturn GTK_INPUT_ERROR;\r\naddr = GUINT32_FROM_BE(addr);\r\n#else\r\nunsigned int a0, a1, a2, a3;\r\nif (sscanf(addr_str, "%u.%u.%u.%u", &a0, &a1, &a2, &a3) != 4)\r\nreturn GTK_INPUT_ERROR;\r\nif (a0 > 255 || a1 > 255 || a2 > 255 || a3 > 255)\r\nreturn GTK_INPUT_ERROR;\r\naddr = a0 << 24 | a1 << 16 | a2 << 8 | a3;\r\n#endif\r\n*out_val = (gdouble) addr;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nfinfo_ipv4_output(GtkSpinButton *spinbutton, gpointer user_data _U_)\r\n{\r\nGtkAdjustment *adj;\r\nguint32 value;\r\naddress addr;\r\nchar* addr_str;\r\nadj = gtk_spin_button_get_adjustment(spinbutton);\r\nvalue = (guint32) gtk_adjustment_get_value(adj);\r\nvalue = GUINT32_TO_BE(value);\r\nset_address(&addr, AT_IPv4, 4, &value);\r\naddr_str = (char*)address_to_str(NULL, &addr);\r\ngtk_entry_set_text(GTK_ENTRY(spinbutton), addr_str);\r\nwmem_free(NULL, addr_str);\r\nreturn TRUE;\r\n}\r\nstatic gint\r\nnew_finfo_window(GtkWidget *w, struct FieldinfoWinData *DataPtr)\r\n{\r\nfield_info *finfo = DataPtr->finfo;\r\nconst header_field_info *hfinfo = finfo->hfinfo;\r\nint finfo_type = (hfinfo) ? hfinfo->type : FT_NONE;\r\n#if !GTK_CHECK_VERSION(3, 10, 0)\r\nGtkWidget *dialog = gtk_dialog_new_with_buttons("Editing finfo: ....",\r\nGTK_WINDOW(w),\r\n(GtkDialogFlags) (GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT),\r\nGTK_STOCK_OK, GTK_RESPONSE_ACCEPT,\r\nGTK_STOCK_CANCEL, GTK_RESPONSE_REJECT,\r\nNULL);\r\n#else\r\nGtkWidget *dialog = gtk_dialog_new_with_buttons("Editing finfo: ....",\r\nGTK_WINDOW(w),\r\n(GtkDialogFlags) (GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT),\r\n"_OK", GTK_RESPONSE_ACCEPT,\r\n"_Cancel", GTK_RESPONSE_REJECT,\r\nNULL);\r\n#endif\r\nGtkWidget *dialog_vbox = gtk_dialog_get_content_area(GTK_DIALOG(dialog));\r\nGtkWidget *fvalue_edit;\r\nGtkWidget *native_repr;\r\nGtkWidget *bv_nb_ptr;\r\nGtkWidget *frame, *frame_vbox;\r\ngint result;\r\nif (!FI_GET_FLAG(finfo, FI_LITTLE_ENDIAN) && !FI_GET_FLAG(finfo, FI_BIG_ENDIAN)) {\r\nfvalue_edit = gtk_entry_new();\r\ngtk_entry_set_text(GTK_ENTRY(fvalue_edit), "<not added by proto_tree_add_item()>");\r\ngtk_editable_set_editable(GTK_EDITABLE(fvalue_edit), FALSE);\r\ngtk_widget_set_sensitive(fvalue_edit, FALSE);\r\n} else if (finfo_type == FT_INT8 || finfo_type == FT_INT16 || finfo_type == FT_INT24 || finfo_type == FT_INT32 ||\r\nfinfo_type == FT_UINT8 || finfo_type == FT_UINT16 || finfo_type == FT_UINT24 || finfo_type == FT_UINT32)\r\n{\r\n#if GTK_CHECK_VERSION(3,0,0)\r\nGtkAdjustment *adj;\r\n#else\r\nGtkObject *adj;\r\n#endif\r\nint bitcount = 0;\r\nif (finfo_type == FT_INT8 || finfo_type == FT_UINT8)\r\nbitcount = 8;\r\nif (finfo_type == FT_INT16 || finfo_type == FT_UINT16)\r\nbitcount = 16;\r\nif (finfo_type == FT_INT24 || finfo_type == FT_UINT24)\r\nbitcount = 24;\r\nif (finfo_type == FT_INT32 || finfo_type == FT_UINT32)\r\nbitcount = 32;\r\nif (finfo->length * 8 < bitcount)\r\nbitcount = finfo->length / 8;\r\nif (hfinfo->bitmask)\r\nbitcount -= hfinfo_bitshift(hfinfo);\r\nif (finfo_type == FT_INT8 || finfo_type == FT_INT16 || finfo_type == FT_INT24 || finfo_type == FT_INT32 )\r\nadj = gtk_adjustment_new((double) fvalue_get_sinteger(&finfo->value), (double) -(G_GINT64_CONSTANT(1) << (bitcount-1)), (double) ((G_GINT64_CONSTANT(1) << (bitcount-1))-1), 1.0, 10.0, 0);\r\nelse if (finfo_type == FT_UINT8 || finfo_type == FT_UINT16 || finfo_type == FT_UINT24 || finfo_type == FT_UINT32 )\r\nadj = gtk_adjustment_new((double) fvalue_get_uinteger(&finfo->value), 0.0, (double) ((G_GUINT64_CONSTANT(1) << bitcount)-1), 1.0, 10.0, 0);\r\nelse {\r\ng_assert_not_reached();\r\ngoto not_supported;\r\n}\r\nfvalue_edit = gtk_spin_button_new(GTK_ADJUSTMENT(adj), 1.0, 0);\r\ngtk_spin_button_set_numeric(GTK_SPIN_BUTTON(fvalue_edit), TRUE);\r\ng_signal_connect(fvalue_edit, "value-changed", G_CALLBACK(finfo_integer_changed), DataPtr);\r\n} else if (finfo_type == FT_STRING || finfo_type == FT_STRINGZ || finfo_type == FT_STRINGZPAD) {\r\nfvalue_edit = gtk_entry_new();\r\ngtk_entry_set_max_length(GTK_ENTRY(fvalue_edit), finfo->length);\r\ngtk_entry_set_text(GTK_ENTRY(fvalue_edit), (const gchar*) fvalue_get(&finfo->value));\r\ng_signal_connect(fvalue_edit, "changed", G_CALLBACK(finfo_string_changed), DataPtr);\r\n} else if (finfo_type == FT_BOOLEAN) {\r\nfvalue_edit = gtk_check_button_new();\r\ngtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(fvalue_edit), (fvalue_get_uinteger64(&finfo->value) != 0));\r\ng_signal_connect(fvalue_edit, "toggled", G_CALLBACK(finfo_boolean_changed), DataPtr);\r\n} else if (finfo_type == FT_IPv4) {\r\nguint32 net_addr = ipv4_get_net_order_addr((ipv4_addr_and_mask *)fvalue_get(&finfo->value));\r\n#if GTK_CHECK_VERSION(3,0,0)\r\nGtkAdjustment *adj;\r\n#else\r\nGtkObject *adj;\r\n#endif\r\nadj = gtk_adjustment_new((double) (GUINT32_FROM_BE(net_addr)), 0.0, 4294967295.0 , 1.0, 256.0, 0);\r\nfvalue_edit = gtk_spin_button_new(GTK_ADJUSTMENT(adj), 1.0, 0);\r\ngtk_spin_button_set_update_policy(GTK_SPIN_BUTTON(fvalue_edit), GTK_UPDATE_IF_VALID);\r\ng_signal_connect(fvalue_edit, "value-changed", G_CALLBACK(finfo_ipv4_changed), DataPtr);\r\ng_signal_connect(fvalue_edit, "input", G_CALLBACK(finfo_ipv4_input), NULL);\r\ng_signal_connect(fvalue_edit, "output", G_CALLBACK(finfo_ipv4_output), NULL);\r\n} else {\r\nnot_supported:\r\nfvalue_edit = gtk_entry_new();\r\ngtk_entry_set_text(GTK_ENTRY(fvalue_edit), "<not supported>");\r\ngtk_editable_set_editable(GTK_EDITABLE(fvalue_edit), FALSE);\r\ngtk_widget_set_sensitive(fvalue_edit, FALSE);\r\n}\r\ngtk_box_pack_start(GTK_BOX(dialog_vbox), fvalue_edit, FALSE, FALSE, 0);\r\ngtk_widget_show(fvalue_edit);\r\nDataPtr->edit = fvalue_edit;\r\nnative_repr = gtk_entry_new();\r\ngtk_editable_set_editable(GTK_EDITABLE(native_repr), FALSE);\r\ngtk_widget_set_sensitive(native_repr, FALSE);\r\ngtk_box_pack_start(GTK_BOX(dialog_vbox), native_repr, FALSE, FALSE, 0);\r\ngtk_widget_show(native_repr);\r\nDataPtr->repr = native_repr;\r\nframe = gtk_frame_new("Hex edit");\r\nframe_vbox = ws_gtk_box_new(GTK_ORIENTATION_VERTICAL, 1, TRUE);\r\nif (finfo->start >= 0 && finfo->length > 0) {\r\nGtkWidget *byte_view;\r\nbv_nb_ptr = byte_view_new();\r\ngtk_box_pack_start(GTK_BOX(frame_vbox), bv_nb_ptr, TRUE, TRUE, 0);\r\ngtk_widget_set_size_request(bv_nb_ptr, -1, BV_SIZE);\r\ngtk_widget_show(bv_nb_ptr);\r\nif ((byte_view = get_notebook_bv_ptr(bv_nb_ptr)))\r\ng_signal_connect(byte_view, "key-press-event", G_CALLBACK(finfo_bv_key_pressed_cb), DataPtr);\r\nDataPtr->bv = bv_nb_ptr;\r\n}\r\nif (finfo->appendix_start >= 0 && finfo->appendix_length > 0) {\r\nGtkWidget *byte_view;\r\nbv_nb_ptr = byte_view_new();\r\ngtk_box_pack_start(GTK_BOX(frame_vbox), bv_nb_ptr, TRUE, TRUE, 0);\r\ngtk_widget_set_size_request(bv_nb_ptr, -1, BV_SIZE);\r\ngtk_widget_show(bv_nb_ptr);\r\nif ((byte_view = get_notebook_bv_ptr(bv_nb_ptr)))\r\ng_signal_connect(byte_view, "key-press-event", G_CALLBACK(finfo_bv_key_pressed_cb), DataPtr);\r\nDataPtr->app_bv = bv_nb_ptr;\r\n}\r\ngtk_container_add(GTK_CONTAINER(frame), frame_vbox);\r\ngtk_widget_show(frame_vbox); gtk_widget_show(frame);\r\ngtk_container_add(GTK_CONTAINER(dialog_vbox), frame);\r\ngtk_window_set_default_size(GTK_WINDOW(dialog), DEF_WIDTH, -1);\r\nfinfo_window_refresh(DataPtr);\r\nresult = gtk_dialog_run(GTK_DIALOG(dialog));\r\ngtk_widget_destroy(dialog);\r\nreturn result;\r\n}\r\nstatic void\r\nedit_pkt_tree_row_activated_cb(GtkTreeView *tree_view, GtkTreePath *path, GtkTreeViewColumn *column _U_, gpointer user_data)\r\n{\r\nstruct PacketWinData *DataPtr = (struct PacketWinData*)user_data;\r\nGtkTreeModel *model;\r\nGtkTreeIter iter;\r\nfield_info *finfo;\r\nmodel = gtk_tree_view_get_model(tree_view);\r\nif (!gtk_tree_model_get_iter(model, &iter, path))\r\nreturn;\r\ngtk_tree_model_get(model, &iter, 1, &finfo, -1);\r\nif (!finfo)\r\nreturn;\r\nif (!FI_GET_FLAG(finfo, FI_GENERATED) &&\r\nfinfo->ds_tvb && finfo->ds_tvb->real_data >= DataPtr->pd && finfo->ds_tvb->real_data <= DataPtr->pd + DataPtr->frame->cap_len)\r\n{\r\nstruct FieldinfoWinData data;\r\ndata.epan = cfile.epan;\r\ndata.frame = DataPtr->frame;\r\ndata.phdr = DataPtr->phdr;\r\ndata.pd = (guint8 *) g_memdup(DataPtr->pd, DataPtr->frame->cap_len);\r\ndata.start_offset = (int) (finfo->ds_tvb->real_data - DataPtr->pd);\r\ndata.finfo = finfo;\r\ndata.app_bv = data.bv = NULL;\r\ndata.repr = data.edit = NULL;\r\ndata.pd_offset = data.start_offset + finfo->start;\r\ndata.pd_bitoffset = 0;\r\nif (new_finfo_window(DataPtr->main, &data) == GTK_RESPONSE_ACCEPT) {\r\nmemcpy(DataPtr->pd, data.pd, DataPtr->frame->cap_len);\r\nproto_tree_draw(NULL, DataPtr->tree_view);\r\nepan_dissect_cleanup(&(DataPtr->edt));\r\nepan_dissect_init(&(DataPtr->edt), cfile.epan, TRUE, TRUE);\r\nepan_dissect_run(&(DataPtr->edt), cfile.cd_t, &DataPtr->phdr, frame_tvbuff_new(DataPtr->frame, DataPtr->pd), DataPtr->frame, NULL);\r\nadd_byte_views(&(DataPtr->edt), DataPtr->tree_view, DataPtr->bv_nb_ptr);\r\nproto_tree_draw(DataPtr->edt.tree, DataPtr->tree_view);\r\n}\r\ng_free(data.pd);\r\n} else {\r\nsimple_dialog(ESD_TYPE_WARN, ESD_BTN_OK, "Item can't be edited. FI_GENERATED or tvb not subset of packet data (uncompressed?)");\r\n}\r\n}\r\nstatic gboolean\r\nedit_pkt_common_key_pressed_cb(GdkEventKey *event, struct CommonWinData *DataPtr)\r\n{\r\nint val = -1;\r\nswitch (recent.gui_bytes_view) {\r\ncase BYTES_HEX:\r\nif (event->keyval >= 'a' && event->keyval <= 'f')\r\nval = (event->keyval - 'a') + 10;\r\nelse if (event->keyval >= 'A' && event->keyval <= 'F')\r\nval = (event->keyval - 'A') + 10;\r\nelse if (event->keyval >= '0' && event->keyval <= '9')\r\nval = (event->keyval - '0');\r\nelse if (event->keyval == GDK_Left)\r\nDataPtr->pd_bitoffset -= 4;\r\nelse if (event->keyval == GDK_Right)\r\nDataPtr->pd_bitoffset += 4;\r\nelse\r\nreturn FALSE;\r\nif (val != -1) {\r\nif (DataPtr->pd_bitoffset < 4) {\r\nDataPtr->pd[DataPtr->pd_offset] = (DataPtr->pd[DataPtr->pd_offset] & 0x0f) | (val << 4);\r\nDataPtr->pd_bitoffset = 4;\r\n} else {\r\nDataPtr->pd[DataPtr->pd_offset] = (DataPtr->pd[DataPtr->pd_offset] & 0xf0) | val;\r\nDataPtr->pd_bitoffset = 8;\r\n}\r\n}\r\nbreak;\r\ncase BYTES_BITS:\r\nif (event->keyval == '0' || event->keyval == '1')\r\nval = (event->keyval != '0');\r\nelse if (event->keyval == GDK_Left)\r\nDataPtr->pd_bitoffset -= 1;\r\nelse if (event->keyval == GDK_Right)\r\nDataPtr->pd_bitoffset += 1;\r\nelse\r\nreturn FALSE;\r\nif (val != -1) {\r\nif (val)\r\nDataPtr->pd[DataPtr->pd_offset] |= (1 << (7-DataPtr->pd_bitoffset));\r\nelse\r\nDataPtr->pd[DataPtr->pd_offset] &= ~(1 << (7-DataPtr->pd_bitoffset));\r\nDataPtr->pd_bitoffset += 1;\r\n}\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nreturn FALSE;\r\n}\r\nwhile (DataPtr->pd_bitoffset >= 8) {\r\nDataPtr->pd_offset += 1;\r\nDataPtr->pd_bitoffset -= 8;\r\n}\r\nwhile (DataPtr->pd_bitoffset < 0) {\r\nDataPtr->pd_offset -= 1;\r\nDataPtr->pd_bitoffset += 8;\r\n}\r\nDataPtr->val = val;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nedit_pkt_win_key_pressed_cb(GtkWidget *win _U_, GdkEventKey *event, gpointer user_data)\r\n{\r\nstruct PacketWinData *DataPtr = (struct PacketWinData *)user_data;\r\nstruct CommonWinData data;\r\nGSList *src_le;\r\ngboolean ret;\r\ntvbuff_t *ds_tvb = NULL;\r\ndata.frame = DataPtr->frame;\r\ndata.pd = DataPtr->pd;\r\ndata.pd_offset = DataPtr->pd_offset;\r\ndata.pd_bitoffset = DataPtr->pd_bitoffset;\r\nret = edit_pkt_common_key_pressed_cb(event, &data);\r\nDataPtr->pd_offset = data.pd_offset;\r\nDataPtr->pd_bitoffset = data.pd_bitoffset;\r\nif (DataPtr->pd_offset < 0) {\r\nDataPtr->pd_offset = DataPtr->frame->cap_len-1;\r\n}\r\nif ((guint)DataPtr->pd_offset >= DataPtr->frame->cap_len) {\r\nDataPtr->pd_offset = 0;\r\nDataPtr->pd_bitoffset = 0;\r\n}\r\nif (!ret)\r\nreturn FALSE;\r\nif (data.val != -1) {\r\nredissect_packet_window(DataPtr, NULL);\r\n}\r\nfor (src_le = DataPtr->edt.pi.data_src; src_le != NULL; src_le = src_le->next) {\r\nconst struct data_source *src = (const struct data_source *)src_le->data;\r\ntvbuff_t *tvb = get_data_source_tvb(src);\r\nif (tvb && tvb->real_data == DataPtr->pd) {\r\nds_tvb = tvb;\r\nbreak;\r\n}\r\n}\r\nif (ds_tvb != NULL) {\r\nGtkWidget *byte_view;\r\nset_notebook_page(DataPtr->bv_nb_ptr, ds_tvb);\r\nbyte_view = get_notebook_bv_ptr(DataPtr->bv_nb_ptr);\r\nif (byte_view)\r\npacket_hex_editor_print(byte_view, DataPtr->pd, DataPtr->frame, DataPtr->pd_offset, DataPtr->pd_bitoffset, DataPtr->frame->cap_len);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic void\r\nedit_pkt_destroy_new_window(GObject *object _U_, gpointer user_data)\r\n{\r\nstruct PacketWinData *DataPtr = (struct PacketWinData *)user_data;\r\ndetail_windows = g_list_remove(detail_windows, DataPtr);\r\nproto_tree_draw(NULL, DataPtr->tree_view);\r\nepan_dissect_cleanup(&(DataPtr->edt));\r\ng_free(DataPtr);\r\n}\r\nvoid new_packet_window(GtkWidget *w _U_, gboolean reference, gboolean editable _U_)\r\n{\r\nchar *title;\r\nGtkWidget *main_w, *main_vbox, *pane,\r\n*tree_view, *tv_scrollw,\r\n*bv_nb_ptr;\r\nstruct PacketWinData *DataPtr;\r\nframe_data *fd;\r\nif(reference) {\r\nguint32 framenum;\r\nheader_field_info *hfinfo;\r\nif (! cfile.finfo_selected) {\r\nreturn;\r\n}\r\nhfinfo = cfile.finfo_selected->hfinfo;\r\ng_assert(hfinfo);\r\nif (hfinfo->type != FT_FRAMENUM) {\r\nreturn;\r\n}\r\nframenum = fvalue_get_uinteger(&cfile.finfo_selected->value);\r\nif (framenum == 0) {\r\nreturn;\r\n}\r\nfd = frame_data_sequence_find(cfile.frames, framenum);\r\n}\r\nelse {\r\nfd = cfile.current_frame;\r\n}\r\nif (!fd) {\r\nreturn;\r\n}\r\nif (!cf_read_record(&cfile, fd)) {\r\nreturn;\r\n}\r\nDataPtr = (struct PacketWinData *) g_malloc(sizeof(struct PacketWinData));\r\nDataPtr->frame = fd;\r\nDataPtr->phdr = cfile.phdr;\r\nDataPtr->pd = (guint8 *)g_malloc(DataPtr->frame->cap_len);\r\nmemcpy(DataPtr->pd, ws_buffer_start_ptr(&cfile.buf), DataPtr->frame->cap_len);\r\nepan_dissect_init(&(DataPtr->edt), cfile.epan, TRUE, TRUE);\r\nepan_dissect_run(&(DataPtr->edt), cfile.cd_t, &DataPtr->phdr,\r\nframe_tvbuff_new(DataPtr->frame, DataPtr->pd),\r\nDataPtr->frame, &cfile.cinfo);\r\nepan_dissect_fill_in_columns(&(DataPtr->edt), FALSE, TRUE);\r\ntitle = create_packet_window_title();\r\nmain_w = window_new(GTK_WINDOW_TOPLEVEL, title);\r\ng_free(title);\r\ngtk_window_set_default_size(GTK_WINDOW(main_w), DEF_WIDTH, -1);\r\nmain_vbox = ws_gtk_box_new(GTK_ORIENTATION_VERTICAL, 1, FALSE);\r\ngtk_container_set_border_width(GTK_CONTAINER(main_vbox), 1);\r\ngtk_container_add(GTK_CONTAINER(main_w), main_vbox);\r\ngtk_widget_show(main_vbox);\r\npane = gtk_paned_new(GTK_ORIENTATION_VERTICAL);\r\ngtk_box_pack_start(GTK_BOX(main_vbox), pane, TRUE, TRUE, 0);\r\ngtk_widget_show(pane);\r\ntv_scrollw = proto_tree_view_new(&tree_view);\r\ngtk_paned_pack1(GTK_PANED(pane), tv_scrollw, TRUE, TRUE);\r\ngtk_widget_set_size_request(tv_scrollw, -1, TV_SIZE);\r\ngtk_widget_show(tv_scrollw);\r\ngtk_widget_show(tree_view);\r\nbv_nb_ptr = byte_view_new();\r\ngtk_paned_pack2(GTK_PANED(pane), bv_nb_ptr, FALSE, FALSE);\r\ngtk_widget_set_size_request(bv_nb_ptr, -1, BV_SIZE);\r\ngtk_widget_show(bv_nb_ptr);\r\nDataPtr->main = main_w;\r\nDataPtr->tv_scrollw = tv_scrollw;\r\nDataPtr->tree_view = tree_view;\r\nDataPtr->bv_nb_ptr = bv_nb_ptr;\r\ndetail_windows = g_list_append(detail_windows, DataPtr);\r\ng_signal_connect(gtk_tree_view_get_selection(GTK_TREE_VIEW(tree_view)),\r\n"changed", G_CALLBACK(new_tree_view_selection_changed_cb), DataPtr);\r\ng_signal_connect(tree_view, "button_press_event", G_CALLBACK(button_press_handler), NULL);\r\n#ifdef WANT_PACKET_EDITOR\r\nif (editable && DataPtr->frame->cap_len != 0) {\r\ng_signal_connect(main_w, "key-press-event", G_CALLBACK(edit_pkt_win_key_pressed_cb), DataPtr);\r\ng_signal_connect(tree_view, "row-activated", G_CALLBACK(edit_pkt_tree_row_activated_cb), DataPtr);\r\ng_signal_connect(main_w, "destroy", G_CALLBACK(edit_pkt_destroy_new_window), DataPtr);\r\n} else\r\n#endif\r\ng_signal_connect(main_w, "destroy", G_CALLBACK(destroy_new_window), DataPtr);\r\nadd_byte_views(&(DataPtr->edt), tree_view, DataPtr->bv_nb_ptr);\r\nproto_tree_draw(DataPtr->edt.tree, tree_view);\r\nDataPtr->finfo_selected = NULL;\r\nDataPtr->pd_offset = 0;\r\nDataPtr->pd_bitoffset = 0;\r\ngtk_widget_show(main_w);\r\n#ifdef WANT_PACKET_EDITOR\r\nif (editable && DataPtr->frame->cap_len != 0) {\r\ncf_set_frame_edited(&cfile, DataPtr->frame, &DataPtr->phdr,\r\nDataPtr->pd);\r\nmain_update_for_unsaved_changes(&cfile);\r\n}\r\n#endif\r\n}\r\nvoid\r\nredissect_all_packet_windows(void)\r\n{\r\ng_list_foreach(detail_windows, redissect_packet_window, NULL);\r\n}\r\nstatic void\r\ndestroy_new_window(GObject *object _U_, gpointer user_data)\r\n{\r\nstruct PacketWinData *DataPtr = (struct PacketWinData *)user_data;\r\ndetail_windows = g_list_remove(detail_windows, DataPtr);\r\nproto_tree_draw(NULL, DataPtr->tree_view);\r\nepan_dissect_cleanup(&(DataPtr->edt));\r\ng_free(DataPtr->pd);\r\ng_free(DataPtr);\r\n}\r\nstatic void\r\nnew_tree_view_selection_changed_cb(GtkTreeSelection *sel, gpointer user_data)\r\n{\r\nfield_info *finfo;\r\nGtkWidget *byte_view;\r\nconst guint8 *data;\r\nguint len;\r\nGtkTreeModel *model;\r\nGtkTreeIter iter;\r\nstruct PacketWinData *DataPtr = (struct PacketWinData*)user_data;\r\nif (gtk_tree_selection_get_selected(sel, &model, &iter))\r\n{\r\ngtk_tree_model_get(model, &iter, 1, &finfo, -1);\r\nif (!finfo) return;\r\nset_notebook_page(DataPtr->bv_nb_ptr, finfo->ds_tvb);\r\nbyte_view = get_notebook_bv_ptr(DataPtr->bv_nb_ptr);\r\nif (!byte_view)\r\nreturn;\r\ndata = get_byte_view_data_and_length(byte_view, &len);\r\nif (data == NULL) {\r\ndata = DataPtr->pd;\r\nlen = DataPtr->frame->cap_len;\r\n}\r\nDataPtr->finfo_selected = finfo;\r\n#ifdef WANT_PACKET_EDITOR\r\nDataPtr->pd_offset = 0;\r\nDataPtr->pd_bitoffset = 0;\r\nif (!FI_GET_FLAG(finfo, FI_GENERATED) &&\r\nfinfo->ds_tvb && finfo->ds_tvb->real_data >= DataPtr->pd && finfo->ds_tvb->real_data <= DataPtr->pd + DataPtr->frame->cap_len)\r\n{\r\nint pd_offset = (int) (finfo->ds_tvb->real_data - DataPtr->pd);\r\nint finfo_offset = finfo->start;\r\nint finfo_len = finfo->length;\r\nif (!(finfo_offset >= 0 && finfo_len > 0)) {\r\nfinfo_offset = finfo->appendix_start;\r\nfinfo_len = finfo->appendix_length;\r\n}\r\nif (finfo_offset >= 0 && finfo_len > 0) {\r\nDataPtr->pd_offset = pd_offset + finfo_offset;\r\nDataPtr->pd_bitoffset = 0;\r\n}\r\nif (DataPtr->pd_offset < 0)\r\nDataPtr->pd_offset = 0;\r\nif ((guint)DataPtr->pd_offset >= DataPtr->frame->cap_len)\r\nDataPtr->pd_offset = 0;\r\n}\r\n#endif\r\npacket_hex_print(byte_view, data, DataPtr->frame, finfo, len);\r\n}\r\nelse\r\n{\r\nDataPtr->finfo_selected = NULL;\r\nbyte_view = get_notebook_bv_ptr(DataPtr->bv_nb_ptr);\r\nif (!byte_view)\r\nreturn;\r\ndata = get_byte_view_data_and_length(byte_view, &len);\r\ng_assert(data != NULL);\r\npacket_hex_reprint(byte_view);\r\n}\r\n}\r\nvoid\r\ndestroy_packet_wins(void)\r\n{\r\nstruct PacketWinData *DataPtr;\r\nwhile (detail_windows != NULL) {\r\nDataPtr = (struct PacketWinData *)(detail_windows->data);\r\nwindow_destroy(DataPtr->main);\r\n}\r\n}\r\nstatic void\r\nredraw_packet_bytes_cb(gpointer data, gpointer user_data _U_)\r\n{\r\nstruct PacketWinData *DataPtr = (struct PacketWinData *)data;\r\nredraw_packet_bytes(DataPtr->bv_nb_ptr, DataPtr->frame, DataPtr->finfo_selected);\r\n}\r\nvoid\r\nredraw_packet_bytes_packet_wins(void)\r\n{\r\ng_list_foreach(detail_windows, redraw_packet_bytes_cb, NULL);\r\n}
