static void\r\ndissect_exteap(proto_tree *eap_tree, tvbuff_t *tvb, int offset,\r\ngint size, packet_info* pinfo)\r\n{\r\nproto_tree_add_item(eap_tree, hf_eap_ext_vendor_id, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\nsize -= 3;\r\nproto_tree_add_item(eap_tree, hf_eap_ext_vendor_type, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nsize -= 4;\r\ndissect_exteap_wps(eap_tree, tvb, offset, size, pinfo);\r\n}\r\nstatic gboolean\r\ntest_flag(unsigned char flag, unsigned char mask)\r\n{\r\nreturn ( ( flag & mask ) != 0 );\r\n}\r\nstatic void\r\neap_tls_defragment_init(void)\r\n{\r\nreassembly_table_init(&eap_tls_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\n}\r\nstatic void\r\neap_tls_defragment_cleanup(void)\r\n{\r\nreassembly_table_destroy(&eap_tls_reassembly_table);\r\n}\r\nstatic void\r\ndissect_eap_mschapv2(proto_tree *eap_tree, tvbuff_t *tvb, packet_info *pinfo, int offset,\r\ngint size)\r\n{\r\nproto_item *item;\r\ngint left = size;\r\ngint ms_len;\r\nguint8 value_size;\r\nguint8 opcode;\r\nopcode = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(eap_tree, hf_eap_ms_chap_v2_opcode, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nleft -= 1;\r\nif (left <= 0)\r\nreturn;\r\nproto_tree_add_item(eap_tree, hf_eap_ms_chap_v2_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nleft -= 1;\r\nif (left <= 0)\r\nreturn;\r\nitem = proto_tree_add_item(eap_tree, hf_eap_ms_chap_v2_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nms_len = tvb_get_ntohs(tvb, offset);\r\nif (ms_len != size)\r\nexpert_add_info(pinfo, item, &ei_eap_ms_chap_v2_length);\r\noffset += 2;\r\nleft -= 2;\r\nswitch (opcode) {\r\ncase MS_CHAP_V2_CHALLENGE:\r\nif (left <= 0)\r\nbreak;\r\nvalue_size = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(eap_tree, hf_eap_ms_chap_v2_value_size,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nleft -= 1;\r\nproto_tree_add_item(eap_tree, hf_eap_ms_chap_v2_challenge,\r\ntvb, offset, value_size, ENC_NA);\r\noffset += value_size;\r\nleft -= value_size;\r\nif (left <= 0)\r\nbreak;\r\nproto_tree_add_item(eap_tree, hf_eap_ms_chap_v2_name,\r\ntvb, offset, left, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase MS_CHAP_V2_RESPONSE:\r\nif (left <= 0)\r\nbreak;\r\nvalue_size = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(eap_tree, hf_eap_ms_chap_v2_value_size,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nleft -= 1;\r\nif (value_size == 49) {\r\nproto_tree_add_item(eap_tree, hf_eap_ms_chap_v2_peer_challenge,\r\ntvb, offset, 16, ENC_NA);\r\noffset += 16;\r\nproto_tree_add_item(eap_tree, hf_eap_ms_chap_v2_reserved,\r\ntvb, offset, 8, ENC_NA);\r\noffset += 8;\r\nproto_tree_add_item(eap_tree, hf_eap_ms_chap_v2_nt_response,\r\ntvb, offset, 24, ENC_NA);\r\noffset += 24;\r\nproto_tree_add_item(eap_tree, hf_eap_ms_chap_v2_flags,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nleft -= value_size;\r\n} else {\r\nproto_tree_add_item(eap_tree, hf_eap_ms_chap_v2_response, tvb, offset, value_size, ENC_NA);\r\noffset += value_size;\r\nleft -= value_size;\r\n}\r\nif (left <= 0)\r\nbreak;\r\nproto_tree_add_item(eap_tree, hf_eap_ms_chap_v2_name, tvb, offset, left, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase MS_CHAP_V2_SUCCESS:\r\nif (left <= 0)\r\nbreak;\r\nproto_tree_add_item(eap_tree, hf_eap_ms_chap_v2_message,\r\ntvb, offset, left, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase MS_CHAP_V2_FAILURE:\r\nif (left <= 0)\r\nbreak;\r\nproto_tree_add_item(eap_tree, hf_eap_ms_chap_v2_failure_request,\r\ntvb, offset, left, ENC_ASCII|ENC_NA);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(eap_tree, hf_eap_ms_chap_v2_data, tvb, offset, left, ENC_NA);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndissect_eap_sim(proto_tree *eap_tree, tvbuff_t *tvb, int offset, gint size)\r\n{\r\ngint left = size;\r\nproto_tree_add_item(eap_tree, hf_eap_sim_subtype, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nleft -= 1;\r\nif (left < 2)\r\nreturn;\r\nproto_tree_add_item(eap_tree, hf_eap_sim_reserved, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nleft -= 2;\r\nwhile (left >= 2) {\r\nguint8 type, length;\r\nproto_item *pi;\r\nproto_tree *attr_tree;\r\nint aoffset;\r\ngint aleft;\r\naoffset = offset;\r\ntype = tvb_get_guint8(tvb, aoffset);\r\nlength = tvb_get_guint8(tvb, aoffset + 1);\r\naleft = 4 * length;\r\npi = proto_tree_add_none_format(eap_tree, hf_eap_sim_subtype_attribute, tvb,\r\naoffset, aleft, "EAP-SIM Attribute: %s (%d)",\r\nval_to_str_ext_const(type,\r\n&eap_sim_aka_attribute_vals_ext,\r\n"Unknown"),\r\ntype);\r\nattr_tree = proto_item_add_subtree(pi, ett_eap_sim_attr);\r\nproto_tree_add_uint(attr_tree, hf_eap_sim_subtype_type, tvb, aoffset, 1, type);\r\naoffset += 1;\r\naleft -= 1;\r\nif (aleft <= 0)\r\nbreak;\r\nproto_tree_add_item(attr_tree, hf_eap_sim_subtype_length, tvb, aoffset, 1, ENC_BIG_ENDIAN);\r\naoffset += 1;\r\naleft -= 1;\r\nproto_tree_add_item(attr_tree, hf_eap_sim_subtype_value, tvb, aoffset, aleft, ENC_NA);\r\noffset += 4 * length;\r\nleft -= 4 * length;\r\n}\r\n}\r\nstatic void\r\ndissect_eap_aka(proto_tree *eap_tree, tvbuff_t *tvb, int offset, gint size)\r\n{\r\ngint left = size;\r\nproto_tree_add_item(eap_tree, hf_eap_aka_subtype, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nleft -= 1;\r\nif (left < 2)\r\nreturn;\r\nproto_tree_add_item(eap_tree, hf_eap_aka_reserved, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nleft -= 2;\r\nwhile (left >= 2) {\r\nguint8 type, length;\r\nproto_item *pi;\r\nproto_tree *attr_tree;\r\nint aoffset;\r\ngint aleft;\r\naoffset = offset;\r\ntype = tvb_get_guint8(tvb, aoffset);\r\nlength = tvb_get_guint8(tvb, aoffset + 1);\r\naleft = 4 * length;\r\npi = proto_tree_add_none_format(eap_tree, hf_eap_aka_subtype_attribute, tvb,\r\naoffset, aleft, "EAP-AKA Attribute: %s (%d)",\r\nval_to_str_ext_const(type,\r\n&eap_sim_aka_attribute_vals_ext,\r\n"Unknown"),\r\ntype);\r\nattr_tree = proto_item_add_subtree(pi, ett_eap_aka_attr);\r\nproto_tree_add_uint(attr_tree, hf_eap_aka_subtype_type, tvb, aoffset, 1, type);\r\naoffset += 1;\r\naleft -= 1;\r\nif (aleft <= 0)\r\nbreak;\r\nproto_tree_add_item(attr_tree, hf_eap_aka_subtype_length, tvb, aoffset, 1, ENC_BIG_ENDIAN);\r\naoffset += 1;\r\naleft -= 1;\r\nproto_tree_add_item(attr_tree, hf_eap_aka_subtype_value, tvb, aoffset, aleft, ENC_NA);\r\noffset += 4 * length;\r\nleft -= 4 * length;\r\n}\r\n}\r\nstatic int\r\ndissect_eap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nguint8 eap_code;\r\nguint16 eap_len;\r\nguint8 eap_type;\r\ngint len;\r\nconversation_t *conversation;\r\nconv_state_t *conversation_state;\r\nframe_state_t *packet_state;\r\nint leap_state;\r\nproto_tree *ti;\r\nproto_tree *eap_tree = NULL;\r\nproto_tree *eap_tls_flags_tree = NULL;\r\nproto_item *eap_type_item = NULL;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "EAP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\neap_code = tvb_get_guint8(tvb, 0);\r\ncol_add_str(pinfo->cinfo, COL_INFO,\r\nval_to_str(eap_code, eap_code_vals, "Unknown code (0x%02X)"));\r\nif (pinfo->destport == pinfo->match_uint) {\r\nconversation = find_conversation(pinfo->num, &pinfo->dst, &pinfo->src,\r\npinfo->ptype, pinfo->destport,\r\n0, NO_PORT_B);\r\n} else {\r\nconversation = find_conversation(pinfo->num, &pinfo->src, &pinfo->dst,\r\npinfo->ptype, pinfo->srcport,\r\n0, NO_PORT_B);\r\n}\r\nif (conversation == NULL) {\r\nif (pinfo->destport == pinfo->match_uint) {\r\nconversation = conversation_new(pinfo->num, &pinfo->dst, &pinfo->src,\r\npinfo->ptype, pinfo->destport,\r\n0, NO_PORT2);\r\n} else {\r\nconversation = conversation_new(pinfo->num, &pinfo->src, &pinfo->dst,\r\npinfo->ptype, pinfo->srcport,\r\n0, NO_PORT2);\r\n}\r\n}\r\nconversation_state = (conv_state_t *)conversation_get_proto_data(conversation, proto_eap);\r\nif (conversation_state == NULL) {\r\nconversation_state = wmem_new(wmem_file_scope(), conv_state_t);\r\nconversation_state->eap_tls_seq = -1;\r\nconversation_state->eap_reass_cookie = 0;\r\nconversation_state->leap_state = -1;\r\nconversation_add_proto_data(conversation, proto_eap, conversation_state);\r\n}\r\nif (eap_code == EAP_FAILURE)\r\nconversation_state->leap_state = -1;\r\neap_len = tvb_get_ntohs(tvb, 2);\r\nlen = eap_len;\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_eap, tvb, 0, len, ENC_NA);\r\neap_tree = proto_item_add_subtree(ti, ett_eap);\r\nproto_tree_add_item(eap_tree, hf_eap_code, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(eap_tree, hf_eap_identifier, tvb, 1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(eap_tree, hf_eap_len, tvb, 2, 2, ENC_BIG_ENDIAN);\r\n}\r\nswitch (eap_code) {\r\ncase EAP_SUCCESS:\r\ncase EAP_FAILURE:\r\nbreak;\r\ncase EAP_REQUEST:\r\ncase EAP_RESPONSE:\r\neap_type = tvb_get_guint8(tvb, 4);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %s",\r\nval_to_str_ext(eap_type, &eap_type_vals_ext,\r\n"Unknown type (0x%02x)"));\r\nif (tree)\r\neap_type_item = proto_tree_add_item(eap_tree, hf_eap_type, tvb, 4, 1, ENC_BIG_ENDIAN);\r\nif ((len > 5) || ((len == 5) && (eap_type == EAP_TYPE_ID))) {\r\nint offset = 5;\r\ngint size = len - offset;\r\nswitch (eap_type) {\r\ncase EAP_TYPE_ID:\r\nif (tree && size > 0) {\r\nproto_tree_add_item(eap_tree, hf_eap_identity, tvb, offset, size, ENC_ASCII|ENC_NA);\r\n}\r\nif(!pinfo->fd->flags.visited) {\r\nconversation_state->leap_state = 0;\r\nconversation_state->eap_tls_seq = -1;\r\n}\r\nbreak;\r\ncase EAP_TYPE_NOTIFY:\r\nif (tree) {\r\nproto_tree_add_item(eap_tree, hf_eap_notification, tvb,\r\noffset, size, ENC_ASCII|ENC_NA);\r\n}\r\nbreak;\r\ncase EAP_TYPE_NAK:\r\nif (tree) {\r\nproto_tree_add_item(eap_tree, hf_eap_type_nak, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase EAP_TYPE_MD5:\r\n{\r\nguint8 value_size = tvb_get_guint8(tvb, offset);\r\ngint extra_len = size - 1 - value_size;\r\nproto_item *item;\r\nexpert_add_info(pinfo, eap_type_item, &ei_eap_mitm_attacks);\r\nitem = proto_tree_add_item(eap_tree, hf_eap_md5_value_size, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif (value_size > (size - 1))\r\n{\r\nexpert_add_info(pinfo, item, &ei_eap_md5_value_size_overflow);\r\nvalue_size = size - 1;\r\n}\r\noffset += 1;\r\nproto_tree_add_item(eap_tree, hf_eap_md5_value, tvb, offset, value_size, ENC_NA);\r\noffset += value_size;\r\nif (extra_len > 0) {\r\nproto_tree_add_item(eap_tree, hf_eap_md5_extra_data, tvb, offset, extra_len, ENC_NA);\r\n}\r\n}\r\nbreak;\r\ncase EAP_TYPE_FAST:\r\ncase EAP_TYPE_PEAP:\r\ncase EAP_TYPE_TTLS:\r\ncase EAP_TYPE_TLS:\r\n{\r\nguint8 flags = tvb_get_guint8(tvb, offset);\r\ngboolean more_fragments;\r\ngboolean has_length;\r\ngboolean is_start;\r\nint eap_tls_seq = -1;\r\nguint32 eap_reass_cookie = 0;\r\ngboolean needs_reassembly = FALSE;\r\nmore_fragments = test_flag(flags,EAP_TLS_FLAG_M);\r\nhas_length = test_flag(flags,EAP_TLS_FLAG_L);\r\nis_start = test_flag(flags,EAP_TLS_FLAG_S);\r\nif (is_start)\r\nconversation_state->eap_tls_seq = -1;\r\nif (tree) {\r\nti = proto_tree_add_item(eap_tree, hf_eap_tls_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\r\neap_tls_flags_tree = proto_item_add_subtree(ti, ett_eap_tls_flags);\r\nproto_tree_add_item(eap_tls_flags_tree, hf_eap_tls_flag_l, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(eap_tls_flags_tree, hf_eap_tls_flag_m, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(eap_tls_flags_tree, hf_eap_tls_flag_s, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif ((eap_type == EAP_TYPE_PEAP) || (eap_type == EAP_TYPE_TTLS) ||\r\n(eap_type == EAP_TYPE_FAST)) {\r\nproto_tree_add_item(eap_tls_flags_tree, hf_eap_tls_flags_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nsize -= 1;\r\noffset += 1;\r\nif (has_length) {\r\nif (tree)\r\nproto_tree_add_item(eap_tree, hf_eap_tls_len, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nsize -= 4;\r\noffset += 4;\r\n}\r\nif (size > 0) {\r\ntvbuff_t *next_tvb;\r\ngint tvb_len;\r\ngboolean save_fragmented;\r\ntvb_len = tvb_captured_length_remaining(tvb, offset);\r\nif (size < tvb_len)\r\ntvb_len = size;\r\npacket_state = (frame_state_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_eap, 0);\r\nif (packet_state == NULL) {\r\nif (!pinfo->fd->flags.visited) {\r\nif (conversation_state->eap_tls_seq != -1) {\r\nneeds_reassembly = TRUE;\r\nconversation_state->eap_tls_seq++;\r\neap_reass_cookie = conversation_state->eap_reass_cookie;\r\neap_tls_seq = conversation_state->eap_tls_seq;\r\n} else if (more_fragments && has_length) {\r\nneeds_reassembly = TRUE;\r\nconversation_state->eap_reass_cookie = pinfo->num;\r\nconversation_state->eap_tls_seq = 0;\r\neap_tls_seq = conversation_state->eap_tls_seq;\r\neap_reass_cookie = conversation_state->eap_reass_cookie;\r\n}\r\nif (needs_reassembly) {\r\npacket_state = wmem_new(wmem_file_scope(), frame_state_t);\r\npacket_state->info = eap_reass_cookie;\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_eap, 0, packet_state);\r\n}\r\n}\r\n} else {\r\nneeds_reassembly = TRUE;\r\neap_reass_cookie = packet_state->info;\r\neap_tls_seq = 0;\r\n}\r\nif (needs_reassembly) {\r\nfragment_head *fd_head;\r\nsave_fragmented = pinfo->fragmented;\r\npinfo->fragmented = TRUE;\r\nfd_head = fragment_add_seq(&eap_tls_reassembly_table,\r\ntvb, offset,\r\npinfo, eap_reass_cookie, NULL,\r\neap_tls_seq,\r\nsize,\r\nmore_fragments, 0);\r\nif (fd_head != NULL)\r\n{\r\nproto_item *frag_tree_item;\r\nnext_tvb = tvb_new_chain(tvb, fd_head->tvb_data);\r\nadd_new_data_source(pinfo, next_tvb, "Reassembled EAP-TLS");\r\nshow_fragment_seq_tree(fd_head, &eap_tls_frag_items,\r\neap_tree, pinfo, next_tvb, &frag_tree_item);\r\ncall_dissector(ssl_handle, next_tvb, pinfo, eap_tree);\r\nif (!pinfo->fd->flags.visited)\r\nconversation_state->eap_tls_seq = -1;\r\n}\r\npinfo->fragmented = save_fragmented;\r\n} else {\r\nnext_tvb = tvb_new_subset(tvb, offset, tvb_len, size);\r\ncall_dissector(ssl_handle, next_tvb, pinfo, eap_tree);\r\n}\r\n}\r\n}\r\nbreak;\r\ncase EAP_TYPE_LEAP:\r\n{\r\nguint8 count, namesize;\r\nexpert_add_info(pinfo, eap_type_item, &ei_eap_dictionary_attacks);\r\nif (tree) {\r\nproto_tree_add_item(eap_tree, hf_eap_leap_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\noffset += 1;\r\nif (tree) {\r\nproto_tree_add_item(eap_tree, hf_eap_leap_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\noffset += 1;\r\ncount = tvb_get_guint8(tvb, offset);\r\nif (tree) {\r\nproto_tree_add_item(eap_tree, hf_eap_leap_count, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\noffset += 1;\r\npacket_state = (frame_state_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_eap, 0);\r\nif (packet_state == NULL) {\r\nleap_state = conversation_state->leap_state;\r\nif (leap_state==0) leap_state = 1; else\r\nif (leap_state==1) leap_state = 2; else\r\nif (leap_state==2) leap_state = 3; else\r\nif (leap_state==3) leap_state = 4; else\r\nif (leap_state==4) leap_state = -1;\r\npacket_state = wmem_new(wmem_file_scope(), frame_state_t);\r\npacket_state->info = leap_state;\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_eap, 0, packet_state);\r\nconversation_state->leap_state = leap_state;\r\n}\r\nleap_state = packet_state->info;\r\nif (tree) {\r\nswitch (leap_state) {\r\ncase 1:\r\nproto_tree_add_item(eap_tree, hf_eap_leap_peer_challenge, tvb, offset, count, ENC_NA);\r\nbreak;\r\ncase 2:\r\nproto_tree_add_item(eap_tree, hf_eap_leap_peer_response, tvb, offset, count, ENC_NA);\r\nbreak;\r\ncase 3:\r\nproto_tree_add_item(eap_tree, hf_eap_leap_ap_challenge, tvb, offset, count, ENC_NA);\r\nbreak;\r\ncase 4:\r\nproto_tree_add_item(eap_tree, hf_eap_leap_ap_response, tvb, offset, count, ENC_NA);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(eap_tree, hf_eap_leap_data, tvb, offset, count, ENC_NA);\r\nbreak;\r\n}\r\n}\r\noffset += count;\r\nnamesize = eap_len - (8+count);\r\nif (tree) {\r\nproto_tree_add_item(eap_tree, hf_eap_leap_name, tvb, offset, namesize, ENC_ASCII|ENC_NA);\r\n}\r\n}\r\nbreak;\r\ncase EAP_TYPE_MSCHAPV2:\r\ndissect_eap_mschapv2(eap_tree, tvb, pinfo, offset, size);\r\nbreak;\r\ncase EAP_TYPE_SIM:\r\nif (tree)\r\ndissect_eap_sim(eap_tree, tvb, offset, size);\r\nbreak;\r\ncase EAP_TYPE_AKA:\r\ncase EAP_TYPE_AKA_PRIME:\r\nif (tree)\r\ndissect_eap_aka(eap_tree, tvb, offset, size);\r\nbreak;\r\ncase EAP_TYPE_EXT:\r\n{\r\nproto_tree *exptree;\r\nexptree = proto_tree_add_subtree(eap_tree, tvb, offset, size, ett_eap_exp_attr, NULL, "Expanded Type");\r\ndissect_exteap(exptree, tvb, offset, size, pinfo);\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(eap_tree, hf_eap_data, tvb, offset, size, ENC_NA);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_eap(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_eap_code, {\r\n"Code", "eap.code",\r\nFT_UINT8, BASE_DEC, VALS(eap_code_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_identifier, {\r\n"Id", "eap.id",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_len, {\r\n"Length", "eap.len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_type, {\r\n"Type", "eap.type",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &eap_type_vals_ext, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_type_nak, {\r\n"Desired Auth Type", "eap.desired_type",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &eap_type_vals_ext, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_identity, {\r\n"Identity", "eap.identity",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_notification, {\r\n"Notification", "eap.notification",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_md5_value_size, {\r\n"EAP-MD5 Value-Size", "eap.md5.value_size",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_md5_value, {\r\n"EAP-MD5 Value", "eap.md5.value",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_md5_extra_data, {\r\n"EAP-MD5 Extra Data", "eap.md5.extra_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_tls_flags, {\r\n"EAP-TLS Flags", "eap.tls.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_tls_flag_l, {\r\n"Length Included", "eap.tls.flags.len_included",\r\nFT_BOOLEAN, 8, NULL, EAP_TLS_FLAG_L,\r\nNULL, HFILL }},\r\n{ &hf_eap_tls_flag_m, {\r\n"More Fragments", "eap.tls.flags.more_fragments",\r\nFT_BOOLEAN, 8, NULL, EAP_TLS_FLAG_M,\r\nNULL, HFILL }},\r\n{ &hf_eap_tls_flag_s, {\r\n"Start", "eap.tls.flags.start",\r\nFT_BOOLEAN, 8, NULL, EAP_TLS_FLAG_S,\r\nNULL, HFILL }},\r\n{ &hf_eap_tls_flags_version, {\r\n"Version", "eap.tls.flags.version",\r\nFT_UINT8, BASE_DEC, NULL, EAP_TLS_FLAGS_VERSION,\r\nNULL, HFILL }},\r\n{ &hf_eap_tls_len, {\r\n"EAP-TLS Length", "eap.tls.len",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_tls_fragment, {\r\n"EAP-TLS Fragment", "eap.tls.fragment",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_tls_fragments, {\r\n"EAP-TLS Fragments", "eap.tls.fragments",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_tls_fragment_overlap, {\r\n"Fragment Overlap", "eap.tls.fragment.overlap",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Fragment overlaps with other fragments", HFILL }},\r\n{ &hf_eap_tls_fragment_overlap_conflict, {\r\n"Conflicting Data In Fragment Overlap", "eap.tls.fragment.overlap_conflict",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Overlapping fragments contained conflicting data", HFILL }},\r\n{ &hf_eap_tls_fragment_multiple_tails, {\r\n"Multiple Tail Fragments Found", "eap.tls.fragment.multiple_tails",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Several tails were found when defragmenting the packet", HFILL }},\r\n{ &hf_eap_tls_fragment_too_long_fragment,{\r\n"Fragment Too Long", "eap.tls.fragment.fragment.too_long",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Fragment contained data past end of packet", HFILL }},\r\n{ &hf_eap_tls_fragment_error, {\r\n"Defragmentation Error", "eap.tls.fragment.error",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n"Defragmentation error due to illegal fragments", HFILL }},\r\n{ &hf_eap_tls_fragment_count, {\r\n"Fragment Count", "eap.tls.fragment.count",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Total length of the reassembled payload", HFILL }},\r\n{ &hf_eap_tls_reassembled_length, {\r\n"Reassembled EAP-TLS Length", "eap.tls.reassembled.len",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Total length of the reassembled payload", HFILL }},\r\n{ &hf_eap_sim_subtype, {\r\n"EAP-SIM Subtype", "eap.sim.subtype",\r\nFT_UINT8, BASE_DEC, VALS(eap_sim_subtype_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_sim_reserved, {\r\n"EAP-SIM Reserved", "eap.sim.reserved",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_sim_subtype_attribute, {\r\n"EAP-SIM Attribute", "eap.sim.subtype.attribute",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_sim_subtype_type, {\r\n"EAP-SIM Type", "eap.sim.subtype.type",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &eap_sim_aka_attribute_vals_ext, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_sim_subtype_length, {\r\n"EAP-SIM Length", "eap.sim.subtype.len",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_sim_subtype_value, {\r\n"EAP-SIM Value", "eap.sim.subtype.value",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_aka_subtype, {\r\n"EAP-AKA Subtype", "eap.aka.subtype",\r\nFT_UINT8, BASE_DEC, VALS(eap_aka_subtype_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_aka_reserved, {\r\n"EAP-AKA Reserved", "eap.aka.reserved",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_aka_subtype_attribute, {\r\n"EAP-AKA Attribute", "eap.aka.subtype.attribute",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_aka_subtype_type, {\r\n"EAP-AKA Type", "eap.aka.subtype.type",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &eap_sim_aka_attribute_vals_ext, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_aka_subtype_length, {\r\n"EAP-AKA Length", "eap.aka.subtype.len",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_aka_subtype_value, {\r\n"EAP-AKA Value", "eap.aka.subtype.value",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_leap_version, {\r\n"EAP-LEAP Version", "eap.leap.version",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_leap_reserved, {\r\n"EAP-LEAP Reserved", "eap.leap.reserved",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_leap_count, {\r\n"EAP-LEAP Count", "eap.leap.count",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_leap_peer_challenge, {\r\n"EAP-LEAP Peer-Challenge", "eap.leap.peer_challenge",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_leap_peer_response, {\r\n"EAP-LEAP Peer-Response", "eap.leap.peer_response",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_leap_ap_challenge, {\r\n"EAP-LEAP AP-Challenge", "eap.leap.ap_challenge",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_leap_ap_response, {\r\n"EAP-LEAP AP-Response", "eap.leap.ap_response",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_leap_data, {\r\n"EAP-LEAP Data", "eap.leap.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_leap_name, {\r\n"EAP-LEAP Name", "eap.leap.name",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_ms_chap_v2_opcode, {\r\n"EAP-MS-CHAP-v2 OpCode", "eap.ms_chap_v2.opcode",\r\nFT_UINT8, BASE_DEC, VALS(eap_ms_chap_v2_opcode_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_ms_chap_v2_id, {\r\n"EAP-MS-CHAP-v2 Id", "eap.ms_chap_v2.id",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_ms_chap_v2_length, {\r\n"EAP-MS-CHAP-v2 Length", "eap.ms_chap_v2.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_ms_chap_v2_value_size, {\r\n"EAP-MS-CHAP-v2 Value-Size", "eap.ms_chap_v2.value_size",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_ms_chap_v2_challenge, {\r\n"EAP-MS-CHAP-v2 Challenge", "eap.ms_chap_v2.challenge",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_ms_chap_v2_name, {\r\n"EAP-MS-CHAP-v2 Name", "eap.ms_chap_v2.name",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_ms_chap_v2_peer_challenge, {\r\n"EAP-MS-CHAP-v2 Peer-Challenge", "eap.ms_chap_v2.peer_challenge",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_ms_chap_v2_reserved, {\r\n"EAP-MS-CHAP-v2 Reserved", "eap.ms_chap_v2.reserved",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_ms_chap_v2_nt_response, {\r\n"EAP-MS-CHAP-v2 NT-Response", "eap.ms_chap_v2.nt_response",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_ms_chap_v2_flags, {\r\n"EAP-MS-CHAP-v2 Flags", "eap.ms_chap_v2.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_ms_chap_v2_response, {\r\n"EAP-MS-CHAP-v2 Response (Unknown Length)", "eap.ms_chap_v2.response",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_ms_chap_v2_message, {\r\n"EAP-MS-CHAP-v2 Message", "eap.ms_chap_v2.message",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_ms_chap_v2_failure_request, {\r\n"EAP-MS-CHAP-v2 Failure-Request", "eap.ms_chap_v2.failure_request",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_ms_chap_v2_data, {\r\n"EAP-MS-CHAP-v2 Data", "eap.ms_chap_v2.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_data, {\r\n"EAP Data", "eap.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_ext_vendor_id, {\r\n"EAP-EXT Vendor Id", "eap.ext.vendor_id",\r\nFT_UINT16, BASE_HEX, VALS(eap_ext_vendor_id_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_eap_ext_vendor_type, {\r\n"EAP-EXT Vendor Type", "eap.ext.vendor_type",\r\nFT_UINT8, BASE_HEX, VALS(eap_ext_vendor_type_vals), 0x0,\r\nNULL, HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_eap,\r\n&ett_eap_tls_fragment,\r\n&ett_eap_tls_fragments,\r\n&ett_eap_sim_attr,\r\n&ett_eap_aka_attr,\r\n&ett_eap_exp_attr,\r\n&ett_eap_tls_flags\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_eap_ms_chap_v2_length, { "eap.ms_chap_v2.length.invalid", PI_PROTOCOL, PI_WARN, "Invalid Length", EXPFILL }},\r\n{ &ei_eap_mitm_attacks, { "eap.mitm_attacks", PI_SECURITY, PI_WARN, "Vulnerable to MITM attacks. If possible, change EAP type.", EXPFILL }},\r\n{ &ei_eap_md5_value_size_overflow, { "eap.md5.value_size.overflow", PI_PROTOCOL, PI_WARN, "Overflow", EXPFILL }},\r\n{ &ei_eap_dictionary_attacks, { "eap.dictionary_attacks", PI_SECURITY, PI_WARN,\r\n"Vulnerable to dictionary attacks. If possible, change EAP type."\r\n" See http://www.cisco.com/warp/public/cc/pd/witc/ao350ap/prodlit/2331_pp.pdf", EXPFILL }},\r\n};\r\nexpert_module_t* expert_eap;\r\nproto_eap = proto_register_protocol("Extensible Authentication Protocol",\r\n"EAP", "eap");\r\nproto_register_field_array(proto_eap, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_eap = expert_register_protocol(proto_eap);\r\nexpert_register_field_array(expert_eap, ei, array_length(ei));\r\neap_handle = register_dissector("eap", dissect_eap, proto_eap);\r\nregister_init_routine(eap_tls_defragment_init);\r\nregister_cleanup_routine(eap_tls_defragment_cleanup);\r\n}\r\nvoid\r\nproto_reg_handoff_eap(void)\r\n{\r\nssl_handle = find_dissector_add_dependency("ssl", proto_eap);\r\ndissector_add_uint("ppp.protocol", PPP_EAP, eap_handle);\r\n}
