static int\r\ngetExtendedHeader(tvbuff_t *tvb, proto_tree *field_tree, int offset, guint8* sizeMuxPPPHeader){\r\nint i;\r\n*sizeMuxPPPHeader = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_size, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif (*sizeMuxPPPHeader > 0){\r\nint tmpOffset = 1;\r\nguint16 tmpStartByte = 0;\r\nguint16 tmpLastByte = 0;\r\nfor (i=0; i < *sizeMuxPPPHeader/7; i++){\r\nswitch(i){\r\ncase(0) :\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_msg_number_I, tvb, offset+tmpOffset, 2, ENC_BIG_ENDIAN);\r\ntmpOffset+=2;\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_freq_number_I, tvb, offset+tmpOffset, 2, ENC_BIG_ENDIAN);\r\ntmpOffset+=2;\r\ntmpStartByte = tvb_get_guint8(tvb, tmpOffset) + *sizeMuxPPPHeader + 1;\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_start_pos_I, tvb, offset+tmpOffset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_start_byte_I, tvb, tmpStartByte, 1, ENC_BIG_ENDIAN);\r\ntmpOffset+=1;\r\ntmpLastByte = tvb_get_guint8(tvb, tmpOffset) + *sizeMuxPPPHeader + 1;\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_end_pos_I, tvb, offset+tmpOffset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_end_byte_I, tvb, tmpLastByte, 1, ENC_BIG_ENDIAN);\r\ntmpOffset+=1;\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_flag_ended_I, tvb, offset+tmpOffset, 1, ENC_BIG_ENDIAN);\r\nif ((tvb_get_guint8(tvb, tmpOffset) & MUX27010_EXTENDED_HEADER_NOT_ENDED) == MUX27010_EXTENDED_HEADER_NOT_ENDED)\r\nproto_tree_add_uint_format(field_tree, hf_mux27010_extended_header_flag_ended_I, tvb, offset+tmpOffset, 1, 1, "Not Last Packet in Frequence");\r\nelse\r\nproto_tree_add_uint_format(field_tree, hf_mux27010_extended_header_flag_ended_I, tvb, offset+tmpOffset, 1, 1, "Last Packet in Frequence");\r\nbreak;\r\ncase(1) :\r\ntmpOffset+=1;\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_msg_number_II, tvb, offset+tmpOffset, 2, ENC_BIG_ENDIAN);\r\ntmpOffset+=2;\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_freq_number_II, tvb, offset+tmpOffset, 2, ENC_BIG_ENDIAN);\r\ntmpOffset+=2;\r\ntmpStartByte = tvb_get_guint8(tvb, tmpOffset) + *sizeMuxPPPHeader + 1;\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_start_pos_II, tvb, offset+tmpOffset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_start_byte_II, tvb, tmpStartByte, 1, ENC_BIG_ENDIAN);\r\ntmpOffset+=1;\r\ntmpLastByte = tvb_get_guint8(tvb, tmpOffset) + *sizeMuxPPPHeader + 1;\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_end_pos_II, tvb, offset+tmpOffset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_end_byte_II, tvb, tmpLastByte, 1, ENC_BIG_ENDIAN);\r\ntmpOffset+=1;\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_flag_ended_II, tvb, offset+tmpOffset, 1, ENC_BIG_ENDIAN);\r\nif ((tvb_get_guint8(tvb, tmpOffset) & MUX27010_EXTENDED_HEADER_NOT_ENDED) == MUX27010_EXTENDED_HEADER_NOT_ENDED)\r\nproto_tree_add_uint_format(field_tree, hf_mux27010_extended_header_flag_ended_II, tvb, offset+tmpOffset, 1, 1, "Not Last Packet in Frequence");\r\nelse\r\nproto_tree_add_uint_format(field_tree, hf_mux27010_extended_header_flag_ended_II, tvb, offset+tmpOffset, 1, 1, "Last Packet in Frequence");\r\nbreak;\r\ncase(2) :\r\ntmpOffset+=1;\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_msg_number_III, tvb, offset+tmpOffset, 2, ENC_BIG_ENDIAN);\r\ntmpOffset+=2;\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_freq_number_III, tvb, offset+tmpOffset, 2, ENC_BIG_ENDIAN);\r\ntmpOffset+=2;\r\ntmpStartByte = tvb_get_guint8(tvb, tmpOffset) + *sizeMuxPPPHeader + 1;\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_start_pos_III, tvb, offset+tmpOffset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_start_byte_III, tvb, tmpStartByte, 1, ENC_BIG_ENDIAN);\r\ntmpOffset+=1;\r\ntmpLastByte = tvb_get_guint8(tvb, tmpOffset) + *sizeMuxPPPHeader + 1;\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_end_pos_III, tvb, offset+tmpOffset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_end_byte_III, tvb, tmpLastByte, 1, ENC_BIG_ENDIAN);\r\ntmpOffset+=1;\r\nproto_tree_add_item(field_tree, hf_mux27010_extended_header_flag_ended_III, tvb, offset+tmpOffset, 1, ENC_BIG_ENDIAN);\r\nif ((tvb_get_guint8(tvb, tmpOffset) & MUX27010_EXTENDED_HEADER_NOT_ENDED) == MUX27010_EXTENDED_HEADER_NOT_ENDED)\r\nproto_tree_add_uint_format(field_tree, hf_mux27010_extended_header_flag_ended_III, tvb, offset+tmpOffset, 1, 1, "Not Last Packet in Frequence");\r\nelse\r\nproto_tree_add_uint_format(field_tree, hf_mux27010_extended_header_flag_ended_III, tvb, offset+tmpOffset, 1, 1, "Last Packet in Frequence");\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn *sizeMuxPPPHeader;\r\n}\r\nstatic int\r\ngetFrameDirection(tvbuff_t *tvb, packet_info *pinfo, proto_tree *field_tree, int offset){\r\nguint8 direction_in_out;\r\ndirection_in_out = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(field_tree, hf_mux27010_direction, tvb, offset, 1, direction_in_out & 3);\r\nswitch (direction_in_out & 3) {\r\ncase (0):\r\ncol_set_str(pinfo->cinfo, COL_DEF_SRC, "Application DLCI ");\r\ncol_set_str(pinfo->cinfo, COL_DEF_DST, "Module");\r\nbreak;\r\ncase (1):\r\ncol_set_str(pinfo->cinfo, COL_DEF_SRC, "Module DLCI ");\r\ncol_set_str(pinfo->cinfo, COL_DEF_DST, "Application");\r\nbreak;\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_DEF_SRC, "Direction not valid ");\r\ncol_set_str(pinfo->cinfo, COL_DEF_DST, "Direction not valid ");\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\ngetFrameAddress(tvbuff_t *tvb, packet_info *pinfo, proto_tree *field_tree_addr, int offset, guint8* dlci_number){\r\nguint8 byte;\r\nbyte = tvb_get_guint8(tvb, offset);\r\n*dlci_number = (byte & MUX27010_DLCI_ADDRESS_FLAG) >> 2;\r\ncol_append_fstr(pinfo->cinfo, COL_DEF_SRC, "%d ", *dlci_number);\r\nproto_tree_add_item(field_tree_addr, hf_mux27010_eaaddressflag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_addr, hf_mux27010_craddressflag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_addr, hf_mux27010_dlciaddressflag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nreturn 1;\r\n}\r\nstatic int\r\ngetFrameControlData(tvbuff_t *tvb, packet_info *pinfo, proto_tree *field_tree, int offset, guint8* frame_type){\r\nguint8 known_frame_type = 0;\r\n*frame_type = tvb_get_guint8(tvb, offset) & MUX27010_FRAMETYPE_CONTROL_FLAG;\r\nswitch (*frame_type) {\r\ncase (MUX27010_FRAMETYPE_CONTROL_FLAG_SABM):\r\ncase (MUX27010_FRAMETYPE_CONTROL_FLAG_UA):\r\ncase (MUX27010_FRAMETYPE_CONTROL_FLAG_DM):\r\ncase (MUX27010_FRAMETYPE_CONTROL_FLAG_DISC):\r\ncase (MUX27010_FRAMETYPE_CONTROL_FLAG_UIH):\r\nproto_tree_add_uint(field_tree, hf_mux27010_controlframetype, tvb, offset, 1, *frame_type);\r\nbreak;\r\ndefault:\r\nif ((MUX27010_FRAMETYPE_CONTROL_FLAG_UIH_E | MUX27010_FRAMETYPE_CONTROL_FLAG_NS | MUX27010_FRAMETYPE_CONTROL_FLAG_NR) == (*frame_type | MUX27010_FRAMETYPE_CONTROL_FLAG_NS | MUX27010_FRAMETYPE_CONTROL_FLAG_NR)) {\r\n*frame_type = MUX27010_FRAMETYPE_CONTROL_FLAG_UIH_E;\r\nproto_tree_add_uint(field_tree, hf_mux27010_controlframetype, tvb, offset, 1, MUX27010_FRAMETYPE_CONTROL_FLAG_UIH_E);\r\nproto_tree_add_item(field_tree, hf_mux27010_controlframetypens, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree, hf_mux27010_controlframetypenr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nknown_frame_type = 1;\r\n}\r\nif ((MUX27010_FRAMETYPE_CONTROL_FLAG_RR | MUX27010_FRAMETYPE_CONTROL_FLAG_NR) == (*frame_type | MUX27010_FRAMETYPE_CONTROL_FLAG_NR)) {\r\n*frame_type = MUX27010_FRAMETYPE_CONTROL_FLAG_RR;\r\nproto_tree_add_uint(field_tree, hf_mux27010_controlframetype, tvb, offset, 1, MUX27010_FRAMETYPE_CONTROL_FLAG_RR);\r\nproto_tree_add_item(field_tree, hf_mux27010_controlframetypenr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nknown_frame_type = 1;\r\n}\r\nif ((MUX27010_FRAMETYPE_CONTROL_FLAG_RNR | MUX27010_FRAMETYPE_CONTROL_FLAG_NR) == (*frame_type | MUX27010_FRAMETYPE_CONTROL_FLAG_NR)) {\r\n*frame_type = MUX27010_FRAMETYPE_CONTROL_FLAG_RNR;\r\nproto_tree_add_uint(field_tree, hf_mux27010_controlframetype, tvb, offset, 1, MUX27010_FRAMETYPE_CONTROL_FLAG_RNR);\r\nproto_tree_add_item(field_tree, hf_mux27010_controlframetypenr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nknown_frame_type = 1;\r\n}\r\nif ((MUX27010_FRAMETYPE_CONTROL_FLAG_REJ | MUX27010_FRAMETYPE_CONTROL_FLAG_NR) == (*frame_type | MUX27010_FRAMETYPE_CONTROL_FLAG_NR)) {\r\n*frame_type = MUX27010_FRAMETYPE_CONTROL_FLAG_REJ;\r\nproto_tree_add_uint(field_tree, hf_mux27010_controlframetype, tvb, offset, 1, MUX27010_FRAMETYPE_CONTROL_FLAG_REJ);\r\nproto_tree_add_item(field_tree, hf_mux27010_controlframetypenr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nknown_frame_type = 1;\r\n}\r\nif (known_frame_type == 0) {\r\nproto_tree_add_uint(field_tree, hf_mux27010_controlframetype, tvb, offset, 1, *frame_type);\r\n}\r\n}\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "(%s)", val_to_str_const(*frame_type, frame_type_vals, "Unknown"));\r\nproto_tree_add_item(field_tree, hf_mux27010_controlframetype, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree, hf_mux27010_pfcontrolflag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nreturn 1;\r\n}\r\nstatic int\r\ngetFrameLength(tvbuff_t *tvb, proto_tree *field_tree, int offset, guint16* length_info){\r\nguint8 length_ea = tvb_get_guint8(tvb, offset) & MUX27010_EA_LENGTH_FLAG;\r\nproto_tree_add_item(field_tree, hf_mux27010_ealengthflag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif (length_ea == 1) {\r\nproto_tree_add_item(field_tree, hf_mux27010_lengthframesize, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n*length_info = (tvb_get_guint8(tvb, offset) & MUX27010_FRAMESIZE_LENGTH_FLAG) >> 1;\r\nreturn 1;\r\n}\r\nproto_tree_add_item(field_tree, hf_mux27010_lengthframesize_ea, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n*length_info = (tvb_get_ntohs(tvb, offset) & MUX27010_FRAMESIZE_LENGTH_FLAG_EA) >> 1;\r\nreturn 2;\r\n}\r\nstatic int\r\ngetControlChannelFrameType(tvbuff_t *tvb, packet_info *pinfo, proto_tree *field_tree_ctr, int offset,\r\nstruct controlchannel_type* cctype){\r\nguint8 controlchannel_type_ea;\r\ncontrolchannel_type_ea = tvb_get_guint8(tvb, offset) & MUX27010_EA_CONTROLCHANNEL_FRAMETYPE_FLAG;\r\ncctype->number_of_type_frames = 0;\r\nif (controlchannel_type_ea == 1)\r\ncctype->number_of_type_frames++;\r\nwhile (controlchannel_type_ea == 0){\r\ncctype->number_of_type_frames++;\r\ncontrolchannel_type_ea = tvb_get_guint8(tvb, offset+cctype->number_of_type_frames) & MUX27010_EA_CONTROLCHANNEL_FRAMETYPE_FLAG;\r\n}\r\ncctype->cr = (tvb_get_guint8(tvb, offset) & MUX27010_CR_CONTROLCHANNEL_FRAMETYPE_FLAG) >> 1;\r\ncctype->command = tvb_get_guint8(tvb, offset) & MUX27010_COMMAND_CONTROLCHANNEL_FRAMETYPE_FLAG;\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneleaframetype, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchannelcrframetype, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchannelframetypecommand, tvb, offset, 1, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " %s", val_to_str_const(cctype->command>>2, command_vals, "Unknown"));\r\nif (cctype->cr == 1) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, " (Command)");\r\n}\r\nelse{\r\ncol_append_str(pinfo->cinfo, COL_INFO, " (Response)");\r\n}\r\nreturn cctype->number_of_type_frames;\r\n}\r\nstatic int\r\ngetControlChannelLength(tvbuff_t *tvb, proto_tree *field_tree_ctr, int offset, struct controlchannel* cc) {\r\nguint8 controlchannel_length_ea;\r\ncontrolchannel_length_ea = tvb_get_guint8(tvb, offset) & MUX27010_EA_CONTROLCHANNEL_LENGTH_FLAG;\r\ncc->number_of_length_frames = 0;\r\nif (controlchannel_length_ea == 1)\r\ncc->number_of_length_frames++;\r\nwhile (controlchannel_length_ea == 0){\r\ncc->number_of_length_frames++;\r\ncontrolchannel_length_ea = tvb_get_guint8(tvb, offset+cc->number_of_length_frames) & MUX27010_EA_CONTROLCHANNEL_LENGTH_FLAG;\r\n}\r\ncc->length_value = (tvb_get_guint8(tvb, offset) & MUX27010_LENGTHFIELD_CONTROLCHANNEL_LENGTH_FLAG) >> 1;\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchannelealength, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchannellengthfield, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nreturn cc->number_of_length_frames;\r\n}\r\nstatic int\r\ngetControlChannelValues(tvbuff_t *tvb, proto_tree *field_tree_ctr, int offset,\r\nstruct controlchannel* cc, struct controlchannel_type* cctype){\r\nguint8 controlchannel_iei;\r\nguint8 controlchannel_psc;\r\nswitch (cctype->command | MUX27010_EA_CONTROLCHANNEL_FRAMETYPE_FLAG | MUX27010_CR_CONTROLCHANNEL_FRAMETYPE_FLAG)\r\n{\r\ncase MUX27010_COMMAND_TEST_COMMAND:\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvaluetestcommandversion, tvb, offset, 1, ENC_BIG_ENDIAN);\r\ncontrolchannel_iei = tvb_get_guint8(tvb, offset);\r\nif ((controlchannel_iei == MUX27010_VALUE_CONTROLCHANNEL_TEST_IEI_TE) ||\r\n(controlchannel_iei == MUX27010_VALUE_CONTROLCHANNEL_TEST_IEI_MS)) {\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchannel_iei_coding, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchannelvalue, tvb, offset+1, cc->length_value-1, ENC_NA|ENC_ASCII);\r\nbreak;\r\ncase MUX27010_COMMAND_POWER_SAVING_CONTROL:\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvalue, tvb, offset, 1, ENC_BIG_ENDIAN);\r\ncontrolchannel_psc = tvb_get_guint8(tvb, offset);\r\nif (cctype->cr == 0 && controlchannel_psc == 0)\r\nproto_tree_add_uint(field_tree_ctr, hf_mux27010_controlchannel_detailedvalue_response, tvb, offset, cc->length_value, 0);\r\nif (cctype->cr == 0 && controlchannel_psc == 1)\r\nproto_tree_add_uint(field_tree_ctr, hf_mux27010_controlchannel_detailedvalue_response, tvb, offset, cc->length_value, 1);\r\nbreak;\r\ncase MUX27010_COMMAND_NON_SUPPORTED_COMMAND_RESPONSE:\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvalue, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase MUX27010_COMMAND_MODEM_STATUS_COMMAND:\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvaluemscdlci, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvaluemscv24fc, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvaluemscv24rtc, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvaluemscv24rtr, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvaluemscv24ring, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvaluemscv24dcd, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nif (cc->length_value == 3) {\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvaluemscbreak, tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase MUX27010_COMMAND_PARAMETER_NEGOTIATION:\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvaluepndlci, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvaluepnframetype, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvaluepncl, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvaluepnprio, tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvaluepntimer, tvb, offset+3, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvaluepnframesize, tvb, offset+4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvaluepnna, tvb, offset+6, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(field_tree_ctr, hf_mux27010_controlchanneldetailedvaluepnwinsize, tvb, offset+7, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\nreturn cc->length_value;\r\n}\r\nstatic int\r\ngetFrameInformation(tvbuff_t *tvb, packet_info *pinfo, proto_tree *field_tree,\r\nint offset, guint16 length_info){\r\nchar *information_field = tvb_get_string_enc(wmem_packet_scope(), tvb,offset,length_info, ENC_ASCII);\r\ninformation_field = g_strdelimit(information_field, "\r\n", ' ');\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " %s", information_field);\r\nproto_tree_add_string(field_tree, hf_mux27010_information_str, tvb, offset, length_info, information_field);\r\nreturn length_info;\r\n}\r\nstatic int\r\ndissect_mux27010(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti, *tf, *tf_extended_header, *tf_addr, *tf_ctr;\r\nproto_tree *mux27010_tree, *field_tree, *field_tree_extended_header, *field_tree_addr, *field_tree_ctr;\r\nint offset = 0;\r\nguint16 length_info;\r\ngboolean save_fragmented;\r\ngint8 dlci_number = 0;\r\nguint8 frame_type;\r\nguint8 sizeMuxPPPHeader;\r\nstruct controlchannel_type cc_type;\r\nstruct controlchannel cc;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, PROTO_TAG_MUX27010);\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\noffset = 0;\r\nti = proto_tree_add_item(tree, proto_mux27010, tvb, 0, -1, ENC_NA);\r\nmux27010_tree = proto_item_add_subtree(ti, ett_mux27010);\r\ntf_extended_header = proto_tree_add_item(mux27010_tree, hf_mux27010_extended_header, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nfield_tree_extended_header = proto_item_add_subtree(tf_extended_header, ett_mux27010_extended_header);\r\noffset += getExtendedHeader(tvb, field_tree_extended_header, offset, &sizeMuxPPPHeader);\r\noffset++;\r\noffset += getFrameDirection(tvb, pinfo, mux27010_tree, offset);\r\nproto_tree_add_item(mux27010_tree, hf_mux27010, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\ntf_addr = proto_tree_add_item(mux27010_tree, hf_mux27010_address, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nfield_tree_addr = proto_item_add_subtree(tf_addr, ett_mux27010_address);\r\noffset += getFrameAddress(tvb, pinfo, field_tree_addr, offset, &dlci_number);\r\ntf = proto_tree_add_item(mux27010_tree, hf_mux27010_control, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nfield_tree = proto_item_add_subtree(tf, ett_mux27010_control);\r\noffset += getFrameControlData(tvb, pinfo, field_tree, offset, &frame_type);\r\nlength_info = 0;\r\nif ((frame_type != MUX27010_FRAMETYPE_CONTROL_FLAG_RR) && (frame_type != MUX27010_FRAMETYPE_CONTROL_FLAG_RNR) &&\r\n(frame_type != MUX27010_FRAMETYPE_CONTROL_FLAG_REJ)){\r\ntf = proto_tree_add_item(mux27010_tree, hf_mux27010_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nfield_tree = proto_item_add_subtree(tf, ett_mux27010_length);\r\noffset += getFrameLength(tvb, field_tree, offset, &length_info);\r\n}\r\nif (dlci_number == 0) {\r\nif (length_info > 0) {\r\ntf = proto_tree_add_item(mux27010_tree, hf_mux27010_controlchannel, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nfield_tree = proto_item_add_subtree(tf, ett_mux27010_controlchannel);\r\ntf_ctr = proto_tree_add_item(field_tree, hf_mux27010_controlchannelframetype, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nfield_tree_ctr = proto_item_add_subtree(tf_ctr, ett_mux27010_controlchannelframetype);\r\noffset += getControlChannelFrameType(tvb, pinfo, field_tree_ctr, offset, &cc_type);\r\nproto_item_set_len(tf_ctr, cc_type.number_of_type_frames);\r\ntf_ctr = proto_tree_add_item(field_tree, hf_mux27010_controlchannellength, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nfield_tree_ctr = proto_item_add_subtree(tf_ctr, ett_mux27010_controlchannellength);\r\noffset += getControlChannelLength(tvb, field_tree_ctr, offset, &cc);\r\nproto_item_set_len(tf_ctr, cc.number_of_length_frames);\r\nif (cc.length_value > 0) {\r\nfield_tree_ctr = proto_tree_add_subtree_format(field_tree, tvb, offset, cc.length_value,\r\nett_mux27010_controlchannelvalue, NULL, "Data: %i Byte(s)", cc.length_value);\r\noffset += getControlChannelValues(tvb, field_tree_ctr, offset, &cc, &cc_type);\r\n}\r\n}\r\n}\r\nif (dlci_number != 0 && length_info > 0) {\r\ntf = proto_tree_add_item(mux27010_tree, hf_mux27010_information, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nfield_tree = proto_item_add_subtree(tf, ett_mux27010_information);\r\nif (sizeMuxPPPHeader > 0){\r\nguint16 tmpOffset = 1;\r\nguint16 tmpOffsetBegin = 1;\r\nguint16 tmpOffsetEnd = 1;\r\nguint16 msg_seqid;\r\nguint16 msg_num;\r\nguint8 msg_start;\r\nguint8 msg_end;\r\nguint8 msg_flag;\r\nfragment_head *frag_msg = NULL;\r\ntvbuff_t *new_tvb = NULL;\r\ntvbuff_t *next_tvb2 = NULL;\r\nint i;\r\nfor (i = 0; i < sizeMuxPPPHeader/7; i++){\r\ntmpOffset = 7;\r\ntmpOffset = (i * tmpOffset)+1;\r\nmsg_seqid = tvb_get_ntohs(tvb, tmpOffset); tmpOffset += 2;\r\nmsg_num = tvb_get_ntohs(tvb, tmpOffset); tmpOffset += 2;\r\nmsg_start = tvb_get_guint8(tvb, tmpOffset); tmpOffset += 1;\r\nmsg_end = tvb_get_guint8(tvb, tmpOffset); tmpOffset += 1;\r\nmsg_flag = tvb_get_guint8(tvb, tmpOffset); tmpOffset += 1;\r\nif (msg_end <= msg_start) {\r\nproto_tree_add_expert(field_tree, pinfo, &ei_mux27010_message_illogical,\r\ntvb, tmpOffset-3, 2);\r\ncontinue;\r\n}\r\ntmpOffsetBegin = sizeMuxPPPHeader + 1 + msg_start;\r\ntmpOffsetEnd = sizeMuxPPPHeader + 1 + msg_end;\r\nsave_fragmented = pinfo->fragmented;\r\npinfo->fragmented = TRUE;\r\nfrag_msg = fragment_add_seq_check(&msg_reassembly_table,\r\ntvb, tmpOffsetBegin,\r\npinfo,\r\nmsg_seqid,\r\nNULL,\r\nmsg_num,\r\n(tmpOffsetEnd-tmpOffsetBegin)+1,\r\nmsg_flag);\r\nnew_tvb = process_reassembled_data(tvb, tmpOffsetBegin, pinfo,\r\n"Reassembled Message", frag_msg, &msg_frag_items,\r\nNULL, mux27010_tree);\r\nif (!frag_msg) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, " [Split Msg]");\r\n}\r\nif (new_tvb) {\r\nnext_tvb2 = tvb_new_subset_remaining(new_tvb, 1);\r\ncall_dissector(ppp_handle, next_tvb2, pinfo, tree);\r\n}\r\npinfo->fragmented = save_fragmented;\r\n}\r\n}\r\noffset += getFrameInformation(tvb, pinfo, field_tree, offset, length_info);\r\n}\r\ntf = proto_tree_add_item(mux27010_tree, hf_mux27010_checksum, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nfield_tree = proto_item_add_subtree(tf, ett_mux27010_checksum);\r\nif (check_fcs(tvb,offset-sizeMuxPPPHeader-3-length_info, sizeMuxPPPHeader+3, tvb_get_guint8(tvb, offset))){\r\nproto_tree_add_boolean(field_tree, hf_mux27010_checksum_correct, tvb, offset, 1, TRUE);\r\n}\r\nelse{\r\nexpert_add_info(pinfo, tf, &ei_mux27010_checksum_incorrect);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\nmux27010_init(void)\r\n{\r\nreassembly_table_init(&msg_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\n}\r\nstatic void\r\nmux27010_cleanup(void)\r\n{\r\nreassembly_table_destroy(&msg_reassembly_table);\r\n}\r\nvoid\r\nproto_register_mux27010 (void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{&hf_mux27010_extended_header,\r\n{ "Extended Header", "mux27010.ext_header",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_size,\r\n{ "Header Size", "mux27010.ext_header.size",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_msg_number_I,\r\n{ "Message Number I", "mux27010.ext_header.msg_number_I",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_freq_number_I,\r\n{ "Frequenz Number I", "mux27010.ext_header.frequenz_number_I",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_start_pos_I,\r\n{ "Start Position I", "mux27010.ext_header.start_pos_I",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_start_byte_I,\r\n{ "Start Byte I", "mux27010.ext_header.start_byte_I",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_end_pos_I,\r\n{ "End Position I", "mux27010.ext_header.end_pos_I",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_end_byte_I,\r\n{ "End Byte I", "mux27010.ext_header.end_byte_I",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_flag_ended_I,\r\n{ "Flag Ended I", "mux27010.ext_header.flag_ended_I",\r\nFT_UINT8, BASE_HEX, NULL, MUX27010_EXTENDED_HEADER_NOT_ENDED, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_msg_number_II,\r\n{ "Message Number II", "mux27010.ext_header.msg_number_II",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_freq_number_II,\r\n{ "Frequenz Number II", "mux27010.ext_header.frequenz_number_II",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_start_pos_II,\r\n{ "Start Position II", "mux27010.ext_header.start_pos_II",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_start_byte_II,\r\n{ "Start Byte II", "mux27010.ext_header.start_byte_II",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_end_pos_II,\r\n{ "End Position II", "mux27010.ext_header.end_pos_II",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_end_byte_II,\r\n{ "End Byte II", "mux27010.ext_header.end_byte_II",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_flag_ended_II,\r\n{ "Flag Ended II", "mux27010.ext_header.flag_ended_II",\r\nFT_UINT8, BASE_HEX, NULL, MUX27010_EXTENDED_HEADER_NOT_ENDED, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_msg_number_III,\r\n{ "Message Number III", "mux27010.ext_header.msg_number_III",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_freq_number_III,\r\n{ "Frequenz Number III", "mux27010.ext_header.frequenz_number_III",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_start_pos_III,\r\n{ "Start Position III", "mux27010.ext_header.start_pos_III",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_start_byte_III,\r\n{ "Start Byte III", "mux27010.ext_header.start_byte_III",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_end_pos_III,\r\n{ "End Position III", "mux27010.ext_header.end_pos_III",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_end_byte_III,\r\n{ "End Byte III", "mux27010.ext_header.end_byte_III",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_mux27010_extended_header_flag_ended_III,\r\n{ "Flag Ended III", "mux27010.ext_header.flag_ended_III",\r\nFT_UINT8, BASE_HEX, NULL, MUX27010_EXTENDED_HEADER_NOT_ENDED, NULL, HFILL }},\r\n{&hf_mux27010_direction,\r\n{ "Direction", "mux27010.direction",\r\nFT_UINT8, BASE_HEX, VALS(direction_vals), 0x0, NULL, HFILL }},\r\n{&hf_mux27010,\r\n{ "Flag", "mux27010.flag",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_mux27010_address,\r\n{ "Address field", "mux27010.address",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,NULL, HFILL }},\r\n{ &hf_mux27010_dlciaddressflag,\r\n{ "DLCI number (decimal)", "mux27010.address.dlciaddress",\r\nFT_UINT8, BASE_DEC, NULL, MUX27010_DLCI_ADDRESS_FLAG, NULL, HFILL }},\r\n{ &hf_mux27010_eaaddressflag,\r\n{ "EA Address Flag", "mux27010.address.eaaddress",\r\nFT_BOOLEAN, 8, NULL, MUX27010_EA_ADDRESS_FLAG, NULL, HFILL }},\r\n{ &hf_mux27010_craddressflag,\r\n{ "C/R Address Flag", "mux27010.address.craddress",\r\nFT_BOOLEAN, 8, NULL, MUX27010_CR_ADDRESS_FLAG, NULL, HFILL }},\r\n#if 0\r\n{ &hf_mux27010_addressdirection,\r\n{ "Direction", "mux27010.address.direction",\r\nFT_UINT8, BASE_HEX, NULL, MUX27010_CR_ADDRESS_FLAG, NULL, HFILL }},\r\n#endif\r\n{ &hf_mux27010_control,\r\n{ "Control field", "mux27010.control",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,NULL, HFILL }},\r\n{ &hf_mux27010_controlframetype,\r\n{ "Frame Type", "mux27010.control.frametype",\r\nFT_UINT8, BASE_HEX, VALS(frame_type_vals), MUX27010_FRAMETYPE_CONTROL_FLAG, NULL, HFILL }},\r\n{ &hf_mux27010_controlframetypens,\r\n{ "N(S) Sequence Number", "mux27010.control.frametype.ns",\r\nFT_UINT8, BASE_DEC, NULL, MUX27010_FRAMETYPE_CONTROL_FLAG_NS, NULL, HFILL }},\r\n{ &hf_mux27010_controlframetypenr,\r\n{ "N(R) Receive Number", "mux27010.control.frametype.nr",\r\nFT_UINT8, BASE_DEC, NULL, MUX27010_FRAMETYPE_CONTROL_FLAG_NR, NULL, HFILL }},\r\n{ &hf_mux27010_pfcontrolflag,\r\n{ "Poll/Final bit", "mux27010.control.pfcontrol",\r\nFT_UINT8, BASE_DEC, NULL, MUX27010_PF_CONTROL_FLAG, NULL, HFILL }},\r\n{ &hf_mux27010_length,\r\n{ "Length field", "mux27010.length",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_mux27010_ealengthflag,\r\n{ "E/A Flag", "mux27010.length.ealength",\r\nFT_BOOLEAN, 8, NULL, MUX27010_EA_LENGTH_FLAG, NULL, HFILL }},\r\n{ &hf_mux27010_lengthframesize_ea,\r\n{ "Info length", "mux27010.length.framesize_ea",\r\nFT_UINT16, BASE_DEC, NULL, MUX27010_FRAMESIZE_LENGTH_FLAG_EA, NULL, HFILL }},\r\n{ &hf_mux27010_lengthframesize,\r\n{ "Info length", "mux27010.length.framesize",\r\nFT_UINT8, BASE_DEC, NULL, MUX27010_FRAMESIZE_LENGTH_FLAG, NULL, HFILL }},\r\n{ &hf_mux27010_controlchannel,\r\n{ "Control Channel", "mux27010.controlchannel",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_mux27010_controlchannelframetype,\r\n{ "Frame Type", "mux27010.controlchannel.frametype",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneleaframetype,\r\n{ "EA Flag", "mux27010.controlchannel.frametype.eatype",\r\nFT_BOOLEAN, 8, NULL, MUX27010_EA_CONTROLCHANNEL_FRAMETYPE_FLAG, NULL, HFILL }},\r\n{ &hf_mux27010_controlchannelcrframetype,\r\n{ "C/R Flag", "mux27010.controlchannel.frametype.crtype",\r\nFT_BOOLEAN, 8, NULL, MUX27010_CR_CONTROLCHANNEL_FRAMETYPE_FLAG, NULL, HFILL }},\r\n{ &hf_mux27010_controlchannelframetypecommand,\r\n{ "Command Type", "mux27010.controlchannel.frametype.command",\r\nFT_UINT8, BASE_HEX, VALS(command_vals), MUX27010_COMMAND_CONTROLCHANNEL_FRAMETYPE_FLAG, NULL, HFILL }},\r\n{ &hf_mux27010_controlchannellength,\r\n{ "Length", "mux27010.controlchannel.length",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_mux27010_controlchannelealength,\r\n{ "EA Flag", "mux27010.controlchannel.length.ealength",\r\nFT_BOOLEAN, 8, NULL, MUX27010_EA_CONTROLCHANNEL_LENGTH_FLAG, NULL, HFILL }},\r\n{ &hf_mux27010_controlchannellengthfield,\r\n{ "Length field", "mux27010.controlchannel.length.length",\r\nFT_UINT8, BASE_DEC, NULL, MUX27010_LENGTHFIELD_CONTROLCHANNEL_LENGTH_FLAG, NULL, HFILL }},\r\n{ &hf_mux27010_controlchannelvalue,\r\n{ "Value (ASCII)", "mux27010.controlchannel.value",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_mux27010_controlchannel_iei_coding,\r\n{ "IEI coding", "mux27010.controlchannel.value.iei_coding",\r\nFT_UINT8, BASE_HEX, VALS(iei_coding_vals), 0x0, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneldetailedvalue,\r\n{ "Detailed Values", "mux27010.controlchannel.value.detailedvalues",\r\nFT_UINT8, BASE_HEX, NULL, 0xFF, NULL, HFILL }},\r\n{ &hf_mux27010_controlchannel_detailedvalue_response,\r\n{ "Response", "mux27010.controlchannel.value.detailedvalue.response",\r\nFT_UINT8, BASE_DEC, VALS(detailedvalue_response_vals), 0, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneldetailedvaluetestcommandversion,\r\n{ "Version", "mux27010.controlchannel.value.detailedvaluetestcommandversion",\r\nFT_UINT8, BASE_HEX, NULL, MUX27010_VALUE_CONTROLCHANNEL_TEST_VERSION, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneldetailedvaluemscdlci,\r\n{ "DLCI number (decimal)", "mux27010.controlchannel.value.detailedvaluemscdlci",\r\nFT_UINT8, BASE_DEC, NULL, MUX27010_VALUE_CONTROLCHANNEL_MSC_DCLI, NULL, HFILL }},\r\n#if 0\r\n{ &hf_mux27010_controlchanneldetailedvaluemscv24,\r\n{ "V.24 Signal", "mux27010.controlchannel.value.detailedvaluemscv24",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n#endif\r\n{ &hf_mux27010_controlchanneldetailedvaluemscv24fc,\r\n{ "FC", "mux27010.controlchannel.value.detailedvaluemscv24.fc",\r\nFT_BOOLEAN, 8, NULL, MUX27010_VALUE_CONTROLCHANNEL_MSC_V24_FC, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneldetailedvaluemscv24rtc,\r\n{ "RTC", "mux27010.controlchannel.value.detailedvaluemscv24.rtc",\r\nFT_BOOLEAN, 8, NULL, MUX27010_VALUE_CONTROLCHANNEL_MSC_V24_RTC, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneldetailedvaluemscv24rtr,\r\n{ "RTR", "mux27010.controlchannel.value.detailedvaluemscv24.rtr",\r\nFT_BOOLEAN, 8, NULL, MUX27010_VALUE_CONTROLCHANNEL_MSC_V24_RTR, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneldetailedvaluemscv24ring,\r\n{ "RING", "mux27010.controlchannel.value.detailedvaluemscv24.ring",\r\nFT_BOOLEAN, 8, NULL, MUX27010_VALUE_CONTROLCHANNEL_MSC_V24_RING, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneldetailedvaluemscv24dcd,\r\n{ "DCD", "mux27010.controlchannel.value.detailedvaluemscv24.dcd",\r\nFT_BOOLEAN, 8, NULL, MUX27010_VALUE_CONTROLCHANNEL_MSC_V24_DCD, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneldetailedvaluemscbreak,\r\n{ "Break Signal", "mux27010.controlchannel.value.detailedvaluemscbreak",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneldetailedvaluepndlci,\r\n{ "DLCI", "mux27010.controlchannel.value.detailedvaluepndlci",\r\nFT_UINT8, BASE_DEC, NULL, MUX27010_VALUE_CONTROLCHANNEL_PN_DLCI, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneldetailedvaluepnframetype,\r\n{ "Frame Type", "mux27010.controlchannel.value.detailedvaluepnframetype",\r\nFT_UINT8, BASE_HEX, NULL, MUX27010_VALUE_CONTROLCHANNEL_PN_FRAMETYPE, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneldetailedvaluepncl,\r\n{ "Convergence Layer", "mux27010.controlchannel.value.detailedvaluepncl",\r\nFT_UINT8, BASE_DEC, NULL, MUX27010_VALUE_CONTROLCHANNEL_PN_CL, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneldetailedvaluepnprio,\r\n{ "Priority", "mux27010.controlchannel.value.detailedvaluepnprio",\r\nFT_UINT8, BASE_DEC, NULL, MUX27010_VALUE_CONTROLCHANNEL_PN_PRIO, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneldetailedvaluepntimer,\r\n{ "Acknowledgment Timer (ms)", "mux27010.controlchannel.value.detailedvaluepntimer",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneldetailedvaluepnframesize,\r\n{ "Max. Frame Size", "mux27010.controlchannel.value.detailedvaluepnframesize",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneldetailedvaluepnna,\r\n{ "Max. Number of Retransmissions", "mux27010.controlchannel.value.detailedvaluepnna",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_mux27010_controlchanneldetailedvaluepnwinsize,\r\n{ "Window Size for Error Recovery Mode", "mux27010.controlchannel.value.detailedvaluepnwinsize",\r\nFT_UINT8, BASE_DEC, NULL, MUX27010_VALUE_CONTROLCHANNEL_PN_WINSIZE, NULL, HFILL }},\r\n{ &hf_mux27010_information,\r\n{ "Information field", "mux27010.information",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_mux27010_information_str,\r\n{ "Information", "mux27010.information_str",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_mux27010_checksum,\r\n{ "Checksum", "mux27010.checksum",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_mux27010_checksum_correct,\r\n{ "Correct", "mux27010.checksum_correct",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{&hf_msg_fragments,\r\n{"Message fragments", "mux27010.fragments",\r\nFT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } },\r\n{&hf_msg_fragment,\r\n{"Message fragment", "mux27010.fragment",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } },\r\n{&hf_msg_fragment_overlap,\r\n{"Message fragment overlap", "mux27010.fragment.overlap",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL } },\r\n{&hf_msg_fragment_overlap_conflicts,\r\n{"Message fragment overlapping with conflicting data",\r\n"mux27010.fragment.overlap.conflicts",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL } },\r\n{&hf_msg_fragment_multiple_tails,\r\n{"Message has multiple tail fragments",\r\n"mux27010.fragment.multiple_tails",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL } },\r\n{&hf_msg_fragment_too_long_fragment,\r\n{"Message fragment too long", "mux27010.fragment.too_long_fragment",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL } },\r\n{&hf_msg_fragment_error,\r\n{"Message defragmentation error", "mux27010.fragment.error",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } },\r\n{&hf_msg_fragment_count,\r\n{"Message fragment count", "mux27010.fragment.count",\r\nFT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL } },\r\n{&hf_msg_reassembled_in,\r\n{"Reassembled in", "mux27010.reassembled.in",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } },\r\n{&hf_msg_reassembled_length,\r\n{"Reassembled length", "mux27010.reassembled.length",\r\nFT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL } },\r\n};\r\nstatic gint *ett[] = {\r\n&ett_mux27010_extended_header,\r\n&ett_mux27010,\r\n&ett_mux27010_address,\r\n&ett_mux27010_control,\r\n&ett_mux27010_length,\r\n&ett_mux27010_controlchannel,\r\n&ett_mux27010_controlchannelframetype,\r\n&ett_mux27010_controlchannellength,\r\n&ett_mux27010_controlchannelvalue,\r\n&ett_mux27010_information,\r\n&ett_mux27010_checksum,\r\n&ett_msg_fragment,\r\n&ett_msg_fragments\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_mux27010_message_illogical, { "mux27010.message_illogical", PI_MALFORMED, PI_ERROR, "Message start and end are illogical, aborting dissection", EXPFILL }},\r\n{ &ei_mux27010_checksum_incorrect, { "mux27010.checksum_incorrect", PI_CHECKSUM, PI_WARN, "Checksum: incorrect", EXPFILL }},\r\n};\r\nexpert_module_t* expert_mux27010;\r\nproto_mux27010 = proto_register_protocol ("MUX27010 Protocol", "MUX27010", "mux27010");\r\nproto_register_field_array (proto_mux27010, hf, array_length (hf));\r\nproto_register_subtree_array (ett, array_length (ett));\r\nmux27010_handle = register_dissector("mux27010", dissect_mux27010, proto_mux27010);\r\nexpert_mux27010 = expert_register_protocol(proto_mux27010);\r\nexpert_register_field_array(expert_mux27010, ei, array_length(ei));\r\nregister_init_routine(mux27010_init);\r\nregister_cleanup_routine(mux27010_cleanup);\r\n}\r\nvoid\r\nproto_reg_handoff_mux27010(void)\r\n{\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_MUX27010, mux27010_handle);\r\nppp_handle = find_dissector_add_dependency("ppp", proto_mux27010);\r\n}
