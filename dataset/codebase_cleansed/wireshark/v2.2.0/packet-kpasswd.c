static void\r\ndissect_kpasswd_ap_req_data(packet_info *pinfo _U_, tvbuff_t *tvb, proto_tree *parent_tree)\r\n{\r\nproto_item *it;\r\nproto_tree *tree=NULL;\r\nif(parent_tree){\r\nit=proto_tree_add_item(parent_tree, hf_kpasswd_ap_req_data, tvb, 0, -1, ENC_NA);\r\ntree=proto_item_add_subtree(it, ett_ap_req_data);\r\n}\r\ndissect_kerberos_main(tvb, pinfo, tree, FALSE, NULL);\r\n}\r\nstatic int\r\ndissect_kpasswd_user_data_request(packet_info *pinfo, tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nint offset=0;\r\nasn1_ctx_t asn1_ctx;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\r\noffset=dissect_kerberos_ChangePasswdData (FALSE, tvb, offset, &asn1_ctx, tree, hf_kpasswd_ChangePasswdData);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_kpasswd_user_data_reply(packet_info *pinfo, tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nint offset=0;\r\nguint16 result;\r\nresult = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint(tree, hf_kpasswd_result, tvb, offset, 2, result);\r\noffset+=2;\r\ncol_add_str(pinfo->cinfo, COL_INFO,\r\nval_to_str(result, kpasswd_result_types, "Result: %u"));\r\nif(tvb_reported_length_remaining(tvb, offset) > 0){\r\nproto_tree_add_item(tree, hf_kpasswd_result_string, tvb, offset, tvb_reported_length_remaining(tvb, offset), ENC_ASCII|ENC_NA);\r\noffset = tvb_reported_length(tvb);\r\n}\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_kpasswd_krb_priv_message(packet_info *pinfo _U_, tvbuff_t *tvb, proto_tree *parent_tree, gboolean isrequest)\r\n{\r\nproto_item *it;\r\nproto_tree *tree=NULL;\r\ngint offset;\r\nif(parent_tree){\r\nit=proto_tree_add_item(parent_tree, hf_kpasswd_krb_priv_message, tvb, 0, -1, ENC_NA);\r\ntree=proto_item_add_subtree(it, ett_krb_priv_message);\r\n}\r\nif(isrequest){\r\noffset = dissect_kerberos_main(tvb, pinfo, tree, FALSE, cb_req);\r\n} else {\r\noffset = dissect_kerberos_main(tvb, pinfo, tree, FALSE, cb_rep);\r\n}\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_kpasswd_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean have_rm)\r\n{\r\nproto_item *kpasswd_item=NULL;\r\nproto_tree *kpasswd_tree=NULL;\r\nint offset = 0;\r\nguint16 message_len, version, ap_req_len;\r\ntvbuff_t *next_tvb;\r\nguint32 krb_rm = 0;\r\ngint krb_reclen = 0;\r\ngint krb_rm_size = 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "KPASSWD");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (have_rm) {\r\nkrb_rm = tvb_get_ntohl(tvb, offset);\r\nkrb_reclen = kerberos_rm_to_reclen(krb_rm);\r\nkrb_rm_size = 4;\r\nif (krb_reclen > 10 * 1024 * 1024) {\r\nreturn (-1);\r\n}\r\noffset += krb_rm_size;\r\n}\r\nif(tvb_get_guint8(tvb, offset)==0x7e){\r\nnext_tvb=tvb_new_subset_remaining(tvb, offset);\r\nreturn dissect_kerberos_main(next_tvb, pinfo, tree, FALSE, NULL);\r\n}\r\nmessage_len=tvb_get_ntohs(tvb, offset);\r\nversion=tvb_get_ntohs(tvb, offset+2);\r\nap_req_len=tvb_get_ntohs(tvb, offset+4);\r\nif(tree){\r\nkpasswd_item=proto_tree_add_item(tree, proto_kpasswd, tvb, offset-krb_rm_size, message_len+krb_rm_size, ENC_NA);\r\nkpasswd_tree=proto_item_add_subtree(kpasswd_item, ett_kpasswd);\r\nif (have_rm) {\r\nshow_krb_recordmark(kpasswd_tree, tvb, offset-krb_rm_size, krb_rm);\r\n}\r\n}\r\nproto_tree_add_uint(kpasswd_tree, hf_kpasswd_message_len, tvb, offset, 2, message_len);\r\nproto_tree_add_uint(kpasswd_tree, hf_kpasswd_version, tvb, offset+2, 2, version);\r\ncol_set_str(pinfo->cinfo, COL_INFO, val_to_str_const(version, vers_vals, "Unknown command"));\r\nproto_tree_add_uint(kpasswd_tree, hf_kpasswd_ap_req_len, tvb, offset+4, 2, ap_req_len);\r\noffset+=6;\r\nnext_tvb=tvb_new_subset_length(tvb, offset, ap_req_len);\r\ndissect_kpasswd_ap_req_data(pinfo, next_tvb, kpasswd_tree);\r\noffset+=ap_req_len;\r\nnext_tvb=tvb_new_subset_remaining(tvb, offset);\r\noffset += dissect_kpasswd_krb_priv_message(pinfo, next_tvb, kpasswd_tree, (version==0xff80));\r\nproto_item_set_len(kpasswd_item, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_kpasswd_udp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ndissect_kpasswd_common(tvb, pinfo, tree, FALSE);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_kpasswd_tcp_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\npinfo->fragmented = TRUE;\r\nif (dissect_kpasswd_common(tvb, pinfo, tree, TRUE) < 0) {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Continuation");\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_kpasswd_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "KPASSWD");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ntcp_dissect_pdus(tvb, pinfo, tree, kpasswd_desegment, 4, get_krb_pdu_len, dissect_kpasswd_tcp_pdu, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_kpasswd(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_kpasswd_message_len,\r\n{ "Message Length", "kpasswd.message_len", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_kpasswd_ap_req_len,\r\n{ "AP_REQ Length", "kpasswd.ap_req_len", FT_UINT16, BASE_DEC,\r\nNULL, 0, "Length of AP_REQ data", HFILL }},\r\n{ &hf_kpasswd_version,\r\n{ "Version", "kpasswd.version", FT_UINT16, BASE_HEX,\r\nVALS(vers_vals), 0, NULL, HFILL }},\r\n{ &hf_kpasswd_result,\r\n{ "Result", "kpasswd.result", FT_UINT16, BASE_DEC,\r\nVALS(kpasswd_result_types), 0, NULL, HFILL }},\r\n{ &hf_kpasswd_result_string,\r\n{ "Result String", "kpasswd.result_string", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_kpasswd_newpassword,\r\n{ "New Password", "kpasswd.new_password", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_kpasswd_ap_req_data,\r\n{ "AP_REQ", "kpasswd.ap_req", FT_NONE, BASE_NONE,\r\nNULL, 0, "AP_REQ structure", HFILL }},\r\n{ &hf_kpasswd_krb_priv_message,\r\n{ "KRB-PRIV", "kpasswd.krb_priv", FT_NONE, BASE_NONE,\r\nNULL, 0, "KRB-PRIV message", HFILL }},\r\n{ &hf_kpasswd_ChangePasswdData, {\r\n"ChangePasswdData", "kpasswd.ChangePasswdData", FT_NONE, BASE_NONE,\r\nNULL, 0, "Change Password Data structure", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_kpasswd,\r\n&ett_ap_req_data,\r\n&ett_krb_priv_message,\r\n};\r\nmodule_t *kpasswd_module;\r\nproto_kpasswd = proto_register_protocol("MS Kpasswd",\r\n"Kpasswd", "kpasswd");\r\nproto_register_field_array(proto_kpasswd, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nkpasswd_module = prefs_register_protocol(proto_kpasswd, NULL);\r\nprefs_register_bool_preference(kpasswd_module, "desegment",\r\n"Reassemble Kpasswd over TCP messages spanning multiple TCP segments",\r\n"Whether the Kpasswd dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&kpasswd_desegment);\r\n}\r\nvoid\r\nproto_reg_handoff_kpasswd(void)\r\n{\r\ndissector_handle_t kpasswd_handle_udp;\r\ndissector_handle_t kpasswd_handle_tcp;\r\nkpasswd_handle_udp = create_dissector_handle(dissect_kpasswd_udp, proto_kpasswd);\r\nkpasswd_handle_tcp = create_dissector_handle(dissect_kpasswd_tcp, proto_kpasswd);\r\ndissector_add_uint("udp.port", UDP_PORT_KPASSWD, kpasswd_handle_udp);\r\ndissector_add_uint("tcp.port", TCP_PORT_KPASSWD, kpasswd_handle_tcp);\r\n}
