static int\r\ndissect_nettl(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nif (tree) {\r\nproto_tree *nettl_tree;\r\nproto_item *nettl_item;\r\nnettl_item = proto_tree_add_protocol_format(tree, proto_nettl, tvb,\r\n0, -1, "HP-UX Network Tracing and Logging (nettl) header");\r\nnettl_tree = proto_item_add_subtree(nettl_item, ett_nettl);\r\nproto_tree_add_uint_format_value(nettl_tree, hf_nettl_subsys, tvb,\r\n0, 0, pinfo->pseudo_header->nettl.subsys, "%d (%s)",\r\npinfo->pseudo_header->nettl.subsys,\r\nval_to_str_ext_const(pinfo->pseudo_header->nettl.subsys, &subsystem_ext, "Unknown"));\r\nproto_tree_add_int(nettl_tree, hf_nettl_devid, tvb,\r\n0, 0, pinfo->pseudo_header->nettl.devid);\r\nproto_tree_add_uint_format_value(nettl_tree, hf_nettl_kind, tvb,\r\n0, 0, pinfo->pseudo_header->nettl.kind,\r\n"0x%08x (%s)", pinfo->pseudo_header->nettl.kind,\r\nval_to_str_const(pinfo->pseudo_header->nettl.kind & ~NETTL_HDR_SUBSYSTEM_BITS_MASK, trace_kind, "Unknown"));\r\nproto_tree_add_int(nettl_tree, hf_nettl_pid, tvb,\r\n0, 0, pinfo->pseudo_header->nettl.pid);\r\nproto_tree_add_uint(nettl_tree, hf_nettl_uid, tvb,\r\n0, 0, pinfo->pseudo_header->nettl.uid);\r\n}\r\nswitch (pinfo->pkt_encap) {\r\ncase WTAP_ENCAP_NETTL_ETHERNET:\r\ncall_dissector(eth_withoutfcs_handle, tvb, pinfo, tree);\r\nbreak;\r\ncase WTAP_ENCAP_NETTL_TOKEN_RING:\r\ncall_dissector(tr_handle, tvb, pinfo, tree);\r\nbreak;\r\ncase WTAP_ENCAP_NETTL_FDDI:\r\ncall_dissector(fddi_bitswapped_handle, tvb, pinfo, tree);\r\nbreak;\r\ncase WTAP_ENCAP_NETTL_RAW_IP:\r\nif ( (pinfo->pseudo_header->nettl.kind & NETTL_HDR_PDU_MASK) == 0 )\r\ncall_data_dissector(tvb, pinfo, tree);\r\nelse if (pinfo->pseudo_header->nettl.subsys == NETTL_SUBSYS_NS_LS_SCTP )\r\ncall_dissector(sctp_handle, tvb, pinfo, tree);\r\nelse\r\ncall_dissector(raw_ip_handle, tvb, pinfo, tree);\r\nbreak;\r\ncase WTAP_ENCAP_NETTL_RAW_ICMP:\r\nif (!dissector_try_uint(ip_proto_dissector_table,\r\nIP_PROTO_ICMP, tvb, pinfo, tree))\r\ncall_data_dissector(tvb, pinfo, tree);\r\nbreak;\r\ncase WTAP_ENCAP_NETTL_RAW_ICMPV6:\r\nif (!dissector_try_uint(ip_proto_dissector_table,\r\nIP_PROTO_ICMPV6, tvb, pinfo, tree))\r\ncall_data_dissector(tvb, pinfo, tree);\r\nbreak;\r\ncase WTAP_ENCAP_NETTL_X25:\r\nif (pinfo->pseudo_header->nettl.kind == NETTL_HDR_PDUIN)\r\npinfo->p2p_dir = P2P_DIR_RECV;\r\nelse if (pinfo->pseudo_header->nettl.kind == NETTL_HDR_PDUOUT)\r\npinfo->p2p_dir = P2P_DIR_SENT;\r\nif (pinfo->pseudo_header->nettl.subsys == NETTL_SUBSYS_SX25L2)\r\ncall_dissector(lapb_handle, tvb, pinfo, tree);\r\nelse\r\ncall_dissector(x25_handle, tvb, pinfo, tree);\r\nbreak;\r\ncase WTAP_ENCAP_NETTL_RAW_TELNET:\r\nif (!dissector_try_uint(tcp_subdissector_table,\r\nTCP_PORT_TELNET, tvb, pinfo, tree))\r\ncall_data_dissector(tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "UNKNOWN");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Unsupported nettl subsytem: %d (%s)",\r\npinfo->pseudo_header->nettl.subsys,\r\nval_to_str_ext_const(pinfo->pseudo_header->nettl.subsys, &subsystem_ext, "Unknown"));\r\ncall_data_dissector(tvb, pinfo, tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_nettl(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_nettl_subsys,\r\n{ "Subsystem", "nettl.subsys", FT_UINT16, BASE_DEC | BASE_EXT_STRING, &subsystem_ext, 0x0,\r\n"HP-UX Subsystem/Driver", HFILL }},\r\n{ &hf_nettl_devid,\r\n{ "Device ID", "nettl.devid", FT_INT32, BASE_DEC, NULL, 0x0,\r\n"HP-UX Device ID", HFILL }},\r\n{ &hf_nettl_kind,\r\n{ "Trace Kind", "nettl.kind", FT_UINT32, BASE_HEX, VALS(trace_kind), 0x0,\r\n"HP-UX Trace record kind", HFILL}},\r\n{ &hf_nettl_pid,\r\n{ "Process ID (pid/ktid)", "nettl.pid", FT_INT32, BASE_DEC, NULL, 0x0,\r\n"HP-UX Process/thread id", HFILL}},\r\n{ &hf_nettl_uid,\r\n{ "User ID (uid)", "nettl.uid", FT_UINT16, BASE_DEC, NULL, 0x0,\r\n"HP-UX User ID", HFILL}}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_nettl\r\n};\r\nproto_nettl = proto_register_protocol("HP-UX Network Tracing and Logging", "nettl", "nettl");\r\nproto_register_field_array(proto_nettl, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_nettl(void)\r\n{\r\ndissector_handle_t nettl_handle;\r\neth_withoutfcs_handle = find_dissector_add_dependency("eth_withoutfcs", proto_nettl);\r\ntr_handle = find_dissector_add_dependency("tr", proto_nettl);\r\nfddi_bitswapped_handle = find_dissector_add_dependency("fddi_bitswapped", proto_nettl);\r\nlapb_handle = find_dissector_add_dependency("lapb", proto_nettl);\r\nx25_handle = find_dissector_add_dependency("x.25", proto_nettl);\r\nsctp_handle = find_dissector_add_dependency("sctp", proto_nettl);\r\nraw_ip_handle = find_dissector_add_dependency("raw_ip", proto_nettl);\r\nip_proto_dissector_table = find_dissector_table("ip.proto");\r\ntcp_subdissector_table = find_dissector_table("tcp.port");\r\nnettl_handle = create_dissector_handle(dissect_nettl, proto_nettl);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_NETTL_ETHERNET, nettl_handle);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_NETTL_TOKEN_RING, nettl_handle);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_NETTL_FDDI, nettl_handle);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_NETTL_RAW_IP, nettl_handle);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_NETTL_RAW_ICMP, nettl_handle);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_NETTL_RAW_ICMPV6, nettl_handle);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_NETTL_RAW_TELNET, nettl_handle);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_NETTL_X25, nettl_handle);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_NETTL_UNKNOWN, nettl_handle);\r\n}
