static guint get_bzr_prefixed_len(tvbuff_t *tvb, int offset)\r\n{\r\nguint header_len;\r\nheader_len = tvb_get_ntohl(tvb, offset);\r\nreturn 4 + header_len;\r\n}\r\nstatic guint\r\nget_bzr_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset)\r\n{\r\nint next_offset;\r\ngint len = 0;\r\ngint protocol_version_len;\r\nguint8 cmd = 0;\r\nprotocol_version_len = tvb_find_line_end(tvb, offset, -1, &next_offset,\r\nTRUE);\r\nif (protocol_version_len == -1)\r\nreturn -1;\r\nlen += protocol_version_len + 1;\r\nlen += get_bzr_prefixed_len(tvb, next_offset);\r\nwhile (tvb_reported_length_remaining(tvb, offset + len) > 0) {\r\ncmd = tvb_get_guint8(tvb, offset + len);\r\nlen += 1;\r\nswitch (cmd) {\r\ncase 's':\r\ncase 'b':\r\nlen += get_bzr_prefixed_len(tvb, offset + len);\r\nbreak;\r\ncase 'o':\r\nlen += 1;\r\nbreak;\r\ncase 'e':\r\nreturn len;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic gint\r\ndissect_prefixed_bencode(tvbuff_t *tvb, gint offset, packet_info *pinfo,\r\nproto_tree *tree)\r\n{\r\nguint32 plen;\r\nproto_tree *prefixed_bencode_tree;\r\nproto_item *ti;\r\ntvbuff_t *subtvb;\r\nplen = tvb_get_ntohl(tvb, offset);\r\nti = proto_tree_add_item(tree, hf_bzr_prefixed_bencode, tvb, offset, 4 +\r\nplen, ENC_NA);\r\nprefixed_bencode_tree = proto_item_add_subtree(ti, ett_prefixed_bencode);\r\nproto_tree_add_item(prefixed_bencode_tree, hf_bzr_prefixed_bencode_len,\r\ntvb, offset, 4, ENC_BIG_ENDIAN);\r\nsubtvb = tvb_new_subset_length(tvb, offset+4, plen);\r\ncall_dissector(bencode_handle, subtvb, pinfo, prefixed_bencode_tree);\r\nreturn 4 + plen;\r\n}\r\nstatic gint\r\ndissect_prefixed_bytes(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\r\nproto_tree *tree)\r\n{\r\nguint32 plen;\r\nproto_tree *prefixed_bytes_tree;\r\nproto_item *ti;\r\nplen = tvb_get_ntohl(tvb, offset);\r\nti = proto_tree_add_item(tree, hf_bzr_bytes, tvb, offset, 4 +\r\nplen, ENC_NA);\r\nprefixed_bytes_tree = proto_item_add_subtree(ti, ett_prefixed_bytes);\r\nif (prefixed_bytes_tree)\r\n{\r\nproto_tree_add_item(prefixed_bytes_tree, hf_bzr_bytes_length,\r\ntvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(prefixed_bytes_tree, hf_bzr_bytes_data,\r\ntvb, offset+4, plen, ENC_NA);\r\n}\r\nreturn 4 + plen;\r\n}\r\nstatic gint\r\ndissect_body(tvbuff_t *tvb, gint offset, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint8 cmd = 0;\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\ncmd = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_bzr_packet_kind, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nswitch (cmd) {\r\ncase 's':\r\noffset += dissect_prefixed_bencode(tvb, offset, pinfo, tree);\r\nbreak;\r\ncase 'b':\r\noffset += dissect_prefixed_bytes(tvb, offset, pinfo, tree);\r\nbreak;\r\ncase 'o':\r\nproto_tree_add_item(tree, hf_bzr_result, tvb, offset, 1,\r\nENC_BIG_ENDIAN);\r\noffset += 1;\r\nbreak;\r\ncase 'e':\r\nbreak;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic void\r\ndissect_bzr_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nproto_tree *bzr_tree;\r\nproto_item *ti;\r\nint offset = 0;\r\ngint protocol_version_len;\r\nti = proto_tree_add_item(tree, proto_bzr, tvb, offset, -1, ENC_NA);\r\nbzr_tree = proto_item_add_subtree(ti, ett_bzr);\r\nprotocol_version_len = tvb_find_line_end(tvb, offset, -1, &offset, TRUE);\r\nif (protocol_version_len == -1)\r\nreturn;\r\nif (bzr_tree)\r\n{\r\nproto_tree_add_item(bzr_tree, hf_bzr_packet_protocol_version, tvb, 0,\r\nprotocol_version_len+1, ENC_ASCII|ENC_NA);\r\n}\r\noffset += dissect_prefixed_bencode(tvb, offset, pinfo, bzr_tree);\r\ndissect_body(tvb, offset, pinfo, bzr_tree);\r\n}\r\nstatic int\r\ndissect_bzr(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ngint offset = 0, pdu_len;\r\ntvbuff_t *next_tvb;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "BZR");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Bazaar Smart Protocol");\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\npdu_len = get_bzr_pdu_len(pinfo, tvb, offset);\r\nif (pdu_len == -1) {\r\nif (pinfo->can_desegment && bzr_desegment) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn tvb_captured_length(tvb);\r\n} else {\r\npdu_len = tvb_reported_length_remaining(tvb, offset);\r\n}\r\n}\r\nnext_tvb = tvb_new_subset_length(tvb, offset, pdu_len);\r\ndissect_bzr_pdu(next_tvb, pinfo, tree);\r\noffset += pdu_len;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_bzr(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_bzr_packet_kind,\r\n{ "Packet kind", "bzr.kind", FT_UINT8, BASE_DEC,\r\nVALS(message_part_kind), 0x0, NULL, HFILL },\r\n},\r\n{ &hf_bzr_packet_protocol_version,\r\n{ "Protocol version", "bzr.protocol_version", FT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL },\r\n},\r\n{ &hf_bzr_prefixed_bencode,\r\n{ "Bencode packet", "bzr.bencode", FT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Serialized structure of integers, dictionaries, strings and "\r\n"lists.", HFILL },\r\n},\r\n{ &hf_bzr_prefixed_bencode_len,\r\n{ "Bencode packet length", "bzr.bencode.length", FT_UINT32,\r\nBASE_HEX, NULL, 0x0, NULL, HFILL },\r\n},\r\n{ &hf_bzr_bytes,\r\n{ "Prefixed bytes", "bzr.bytes", FT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Bytes field with prefixed 32-bit length", HFILL },\r\n},\r\n{ &hf_bzr_bytes_data,\r\n{ "Prefixed bytes data", "bzr.bytes.data", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL },\r\n},\r\n{ &hf_bzr_bytes_length,\r\n{ "Prefixed bytes length", "bzr.bytes.length", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL },\r\n},\r\n{ &hf_bzr_result,\r\n{ "Result", "bzr.result", FT_UINT8, BASE_HEX,\r\nVALS(message_results), 0x0,\r\n"Command result (success or failure with error message)", HFILL\r\n},\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_bzr,\r\n&ett_prefixed_bencode,\r\n&ett_prefixed_bytes,\r\n};\r\nmodule_t *bzr_module;\r\nproto_bzr = proto_register_protocol("Bazaar Smart Protocol", "Bazaar", "bzr");\r\nregister_dissector("bzr", dissect_bzr, proto_bzr);\r\nproto_register_field_array(proto_bzr, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nbzr_module = prefs_register_protocol(proto_bzr, NULL);\r\nprefs_register_bool_preference(bzr_module, "desegment",\r\n"Reassemble Bazaar messages spanning multiple TCP segments",\r\n"Whether the Bazaar dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\""\r\n" in the TCP protocol settings.",\r\n&bzr_desegment);\r\n}\r\nvoid\r\nproto_reg_handoff_bzr(void)\r\n{\r\ndissector_handle_t bzr_handle;\r\nbencode_handle = find_dissector_add_dependency("bencode", proto_bzr);\r\nbzr_handle = find_dissector("bzr");\r\ndissector_add_uint("tcp.port", TCP_PORT_BZR, bzr_handle);\r\n}
