static void\r\ndissect_rsync_version_header(tvbuff_t *tvb, packet_info *pinfo, proto_tree *rsync_tree, enum rsync_who me)\r\n{\r\nint offset = 0;\r\nguint8 *version;\r\nguint len;\r\nproto_tree_add_item(rsync_tree, &hfi_rsync_hdr_magic, tvb, offset, RSYNCD_MAGIC_HEADER_LEN, ENC_ASCII|ENC_NA);\r\noffset += RSYNCD_MAGIC_HEADER_LEN;\r\noffset += 1;\r\nproto_tree_add_item(rsync_tree, &hfi_rsync_hdr_version, tvb, offset, -1, ENC_ASCII|ENC_NA);\r\nlen = tvb_reported_length_remaining(tvb, offset);\r\nversion = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, len, ENC_ASCII|ENC_NA);\r\nif (len > 0 && version[len - 1] == '\n')\r\nversion[len - 1] = 0x0;\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s Initialisation (Version %s)", (me == SERVER ? "Server" : "Client"), version);\r\n}\r\nstatic int\r\ndissect_rsync_encap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngboolean desegment _U_)\r\n{\r\nconversation_t *conversation;\r\nstruct rsync_conversation_data *conversation_data;\r\nstruct rsync_frame_data *rsync_frame_data_p;\r\nproto_item *ti;\r\nproto_tree *rsync_tree;\r\nenum rsync_who me;\r\nint offset = 0;\r\nguint buff_length;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "RSYNC");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nme = pinfo->srcport == glb_rsync_tcp_port ? SERVER : CLIENT;\r\nconversation = find_or_create_conversation(pinfo);\r\nconversation_data = (struct rsync_conversation_data *)conversation_get_proto_data(conversation, hfi_rsync->id);\r\nif (conversation_data == NULL) {\r\nconversation_data = wmem_new(wmem_file_scope(), struct rsync_conversation_data);\r\nconversation_data->client_state = RSYNC_INIT;\r\nconversation_data->server_state = RSYNC_SERV_INIT;\r\nconversation_add_proto_data(conversation, hfi_rsync->id, conversation_data);\r\n}\r\nconversation_set_dissector(conversation, rsync_handle);\r\nti = proto_tree_add_item(tree, hfi_rsync, tvb, 0, -1, ENC_NA);\r\nrsync_tree = proto_item_add_subtree(ti, ett_rsync);\r\nrsync_frame_data_p = (struct rsync_frame_data *)p_get_proto_data(wmem_file_scope(), pinfo, hfi_rsync->id, 0);\r\nif (!rsync_frame_data_p) {\r\nrsync_frame_data_p = wmem_new(wmem_file_scope(), struct rsync_frame_data);\r\nrsync_frame_data_p->state = (me == SERVER) ? conversation_data->server_state : conversation_data->client_state;\r\np_add_proto_data(wmem_file_scope(), pinfo, hfi_rsync->id, 0, rsync_frame_data_p);\r\n}\r\nif (me == SERVER) {\r\nswitch (rsync_frame_data_p->state) {\r\ncase RSYNC_SERV_INIT:\r\ndissect_rsync_version_header(tvb, pinfo, rsync_tree, me);\r\nconversation_data->server_state = RSYNC_SERV_MOTD;\r\nbreak;\r\ncase RSYNC_SERV_MOTD:\r\nproto_tree_add_item(rsync_tree, &hfi_rsync_motd_string, tvb, offset, -1, ENC_ASCII|ENC_NA);\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Server MOTD");\r\nconversation_data->server_state = RSYNC_SERV_MOTD;\r\nbreak;\r\ncase RSYNC_MODULE_LIST:\r\nif (0 == tvb_strneql(tvb, offset, RSYNCD_AUTHREQD, RSYNCD_AUTHREQD_LEN)) {\r\nproto_tree_add_item(rsync_tree, &hfi_rsync_rsyncdok_string, tvb, offset, -1, ENC_ASCII|ENC_NA);\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Authentication");\r\nconversation_data->server_state = RSYNC_DATA;\r\n} else {\r\nproto_tree_add_item(rsync_tree, &hfi_rsync_module_list_string, tvb, offset, -1, ENC_ASCII|ENC_NA);\r\nbuff_length = tvb_captured_length_remaining(tvb, offset);\r\nif (buff_length > RSYNCD_EXIT_LEN &&\r\n0 == tvb_strneql(tvb, buff_length-RSYNCD_EXIT_LEN-1, RSYNCD_EXIT, RSYNCD_EXIT_LEN)) {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Final module list");\r\nconversation_data->server_state = RSYNC_DATA;\r\n} else {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Module list");\r\nconversation_data->server_state = RSYNC_MODULE_LIST;\r\n}\r\n}\r\nbreak;\r\ncase RSYNC_DATA:\r\nproto_tree_add_item(rsync_tree, &hfi_rsync_data, tvb, offset, -1, ENC_NA);\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Data");\r\nconversation_data->server_state = RSYNC_DATA;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nswitch (rsync_frame_data_p->state) {\r\ncase RSYNC_INIT:\r\ndissect_rsync_version_header(tvb, pinfo, rsync_tree, me);\r\nconversation_data->client_state = RSYNC_CLIENT_QUERY;\r\nbreak;\r\ncase RSYNC_CLIENT_QUERY:\r\nproto_tree_add_item(rsync_tree, &hfi_rsync_query_string, tvb, offset, -1, ENC_ASCII|ENC_NA);\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Client Query");\r\nconversation_data->client_state = RSYNC_COMMAND;\r\nif (tvb_captured_length(tvb) == RSYNC_MODULE_LIST_QUERY_LEN &&\r\n0 == tvb_strneql(tvb, offset, RSYNC_MODULE_LIST_QUERY, RSYNC_MODULE_LIST_QUERY_LEN)) {\r\nconversation_data->server_state = RSYNC_MODULE_LIST;\r\n} else {\r\nconversation_data->server_state = RSYNC_DATA;\r\n}\r\nbreak;\r\ncase RSYNC_COMMAND:\r\nproto_tree_add_item(rsync_tree, &hfi_rsync_command_string, tvb, offset, -1, ENC_ASCII|ENC_NA);\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Client Command");\r\nconversation_data->client_state = RSYNC_COMMAND;\r\nbreak;\r\ncase RSYNC_DATA:\r\nproto_tree_add_item(rsync_tree, &hfi_rsync_data, tvb, offset, -1, ENC_NA);\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Data");\r\nconversation_data->client_state = RSYNC_DATA;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_rsync(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nreturn dissect_rsync_encap(tvb, pinfo, tree, rsync_desegment);\r\n}\r\nvoid\r\nproto_register_rsync(void)\r\n{\r\n#ifndef HAVE_HFI_SECTION_INIT\r\nstatic header_field_info *hfi[] = {\r\n&hfi_rsync_hdr_magic,\r\n&hfi_rsync_hdr_version,\r\n&hfi_rsync_query_string,\r\n&hfi_rsync_module_list_string,\r\n&hfi_rsync_motd_string,\r\n&hfi_rsync_rsyncdok_string,\r\n&hfi_rsync_command_string,\r\n&hfi_rsync_data,\r\n};\r\n#endif\r\nstatic gint *ett[] = {\r\n&ett_rsync,\r\n};\r\nmodule_t *rsync_module;\r\nint proto_rsync;\r\nproto_rsync = proto_register_protocol("RSYNC File Synchroniser",\r\n"RSYNC", "rsync");\r\nhfi_rsync = proto_registrar_get_nth(proto_rsync);\r\nproto_register_fields(proto_rsync, hfi, array_length(hfi));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nrsync_module = prefs_register_protocol(proto_rsync, proto_reg_handoff_rsync);\r\nprefs_register_uint_preference(rsync_module, "tcp_port",\r\n"rsync TCP Port",\r\n"Set the TCP port for RSYNC messages",\r\n10,\r\n&glb_rsync_tcp_port);\r\nprefs_register_bool_preference(rsync_module, "desegment",\r\n"Reassemble RSYNC messages spanning multiple TCP segments",\r\n"Whether the RSYNC dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable"\r\n" \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&rsync_desegment);\r\nrsync_handle = create_dissector_handle(dissect_rsync, proto_rsync);\r\n}\r\nvoid\r\nproto_reg_handoff_rsync(void)\r\n{\r\nstatic gboolean initialized = FALSE;\r\nstatic guint saved_rsync_tcp_port;\r\nif (!initialized) {\r\ninitialized = TRUE;\r\n} else {\r\ndissector_delete_uint("tcp.port", saved_rsync_tcp_port, rsync_handle);\r\n}\r\ndissector_add_uint("tcp.port", glb_rsync_tcp_port, rsync_handle);\r\nsaved_rsync_tcp_port = glb_rsync_tcp_port;\r\n}
