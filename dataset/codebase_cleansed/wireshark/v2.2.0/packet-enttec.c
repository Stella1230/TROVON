static gint\r\ndissect_enttec_poll_reply(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_enttec_poll_reply_mac, tvb,\r\noffset, 6, ENC_NA);\r\noffset += 6;\r\nproto_tree_add_item(tree, hf_enttec_poll_reply_node_type, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_enttec_poll_reply_version, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_enttec_poll_reply_switch, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_enttec_poll_reply_name, tvb,\r\noffset, 10, ENC_ASCII|ENC_NA);\r\noffset += 10;\r\nproto_tree_add_item(tree, hf_enttec_poll_reply_option, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_enttec_poll_reply_tos, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_enttec_poll_reply_ttl, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_enttec_poll(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_enttec_poll_type, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_enttec_ack(tvbuff_t *tvb _U_, guint offset, proto_tree *tree _U_)\r\n{\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_enttec_dmx_data(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nstatic const char* chan_format[] = {\r\n"%2u ",\r\n"%02x ",\r\n"%3u "\r\n};\r\nstatic const char* string_format[] = {\r\n"%03x: %s",\r\n"%3u: %s"\r\n};\r\nguint8 *dmx_data = (guint8 *)wmem_alloc(wmem_packet_scope(), 512 * sizeof(guint8));\r\nguint16 *dmx_data_offset = (guint16 *)wmem_alloc(wmem_packet_scope(), 513 * sizeof(guint16));\r\nwmem_strbuf_t *dmx_epstr;\r\nproto_tree *hi,*si;\r\nproto_item *item;\r\nguint16 length,r,c,row_count;\r\nguint8 v,type,count;\r\nguint16 ci,ui,i,start_offset,end_offset;\r\nproto_tree_add_item(tree, hf_enttec_dmx_data_universe, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_enttec_dmx_data_start_code, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\ntype = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_enttec_dmx_data_type, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nlength = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(tree, hf_enttec_dmx_data_size, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif (length > 512)\r\nlength = 512;\r\nif (type == ENTTEC_DATA_TYPE_RLE) {\r\nui = 0;\r\nci = 0;\r\nwhile (ci < length && ui < 512) {\r\nv = tvb_get_guint8(tvb, offset+ci);\r\nif (v == 0xFE) {\r\nci++;\r\ncount = tvb_get_guint8(tvb, offset+ci);\r\nci++;\r\nv = tvb_get_guint8(tvb, offset+ci);\r\nci++;\r\nfor (i=0;i < count && ui < 512;i++) {\r\ndmx_data[ui] = v;\r\ndmx_data_offset[ui] = ci-3;\r\nui++;\r\n}\r\n} else if (v == 0xFD) {\r\nci++;\r\nv = tvb_get_guint8(tvb, offset+ci);\r\ndmx_data[ui] = v;\r\ndmx_data_offset[ui] = ci;\r\nci++;\r\nui++;\r\n} else {\r\ndmx_data[ui] = v;\r\ndmx_data_offset[ui] = ci;\r\nui++;\r\nci++;\r\n}\r\n}\r\ndmx_data_offset[ui] = ci;\r\n} else {\r\nfor (ui=0; ui < length;ui++) {\r\ndmx_data[ui] = tvb_get_guint8(tvb, offset+ui);\r\ndmx_data_offset[ui] = ui;\r\n}\r\ndmx_data_offset[ui] = ui;\r\n}\r\nif ((type == ENTTEC_DATA_TYPE_DMX || type == ENTTEC_DATA_TYPE_RLE) && global_disp_col_count > 0) {\r\nhi = proto_tree_add_item(tree,\r\nhf_enttec_dmx_data_data,\r\ntvb,\r\noffset,\r\nlength,\r\nENC_NA);\r\nsi = proto_item_add_subtree(hi, ett_enttec);\r\nrow_count = (ui/global_disp_col_count) + ((ui%global_disp_col_count) == 0 ? 0 : 1);\r\ndmx_epstr = wmem_strbuf_new_label(wmem_packet_scope());\r\nfor (r=0; r < row_count;r++) {\r\nfor (c=0;(c < global_disp_col_count) && (((r*global_disp_col_count)+c) < ui);c++) {\r\nif ((global_disp_col_count > 1) && (c % (global_disp_col_count/2)) == 0) {\r\nwmem_strbuf_append_c(dmx_epstr, ' ');\r\n}\r\nv = dmx_data[(r*global_disp_col_count)+c];\r\nif (global_disp_chan_val_type == 0) {\r\nv = (v * 100) / 255;\r\nif (v == 100) {\r\nwmem_strbuf_append(dmx_epstr, "FL ");\r\n} else {\r\nwmem_strbuf_append_printf(dmx_epstr, chan_format[global_disp_chan_val_type], v);\r\n}\r\n} else {\r\nwmem_strbuf_append_printf(dmx_epstr, chan_format[global_disp_chan_val_type], v);\r\n}\r\n}\r\nstart_offset = dmx_data_offset[(r*global_disp_col_count)];\r\nend_offset = dmx_data_offset[(r*global_disp_col_count)+c];\r\nproto_tree_add_none_format(si,hf_enttec_dmx_data_dmx_data, tvb,\r\noffset+start_offset,\r\nend_offset-start_offset,\r\nstring_format[global_disp_chan_nr_type], (r*global_disp_col_count)+1,\r\nwmem_strbuf_get_str(dmx_epstr));\r\nwmem_strbuf_truncate(dmx_epstr, 0);\r\n}\r\nitem = proto_tree_add_item(si, hf_enttec_dmx_data_data_filter, tvb,\r\noffset, length, ENC_NA );\r\nPROTO_ITEM_SET_HIDDEN(item);\r\noffset += length;\r\n}\r\nelse {\r\nproto_tree_add_item(tree, hf_enttec_dmx_data_data_filter, tvb,\r\noffset, length, ENC_NA);\r\noffset += length;\r\n}\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_enttec_reset(tvbuff_t *tvb _U_, guint offset, proto_tree *tree _U_)\r\n{\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_enttec_udp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\ngint offset = 0;\r\nguint32 head = 0;\r\nproto_tree *ti, *enttec_tree;\r\nif (!tvb_bytes_exist(tvb, offset, 4))\r\nreturn 0;\r\nhead = tvb_get_ntohl(tvb, offset);\r\nswitch (head) {\r\ncase ENTTEC_HEAD_ESPR:\r\ncase ENTTEC_HEAD_ESPP:\r\ncase ENTTEC_HEAD_ESAP:\r\ncase ENTTEC_HEAD_ESDD:\r\ncase ENTTEC_HEAD_ESZZ:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ENTTEC");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s",\r\nval_to_str(head, enttec_head_vals, "Unknown (0x%08x)"));\r\nti = proto_tree_add_item(tree, proto_enttec, tvb, offset, -1, ENC_NA);\r\nenttec_tree = proto_item_add_subtree(ti, ett_enttec);\r\nproto_tree_add_item(enttec_tree, hf_enttec_head, tvb,\r\noffset, 4, ENC_BIG_ENDIAN );\r\noffset += 4;\r\nswitch (head) {\r\ncase ENTTEC_HEAD_ESPR:\r\noffset = dissect_enttec_poll_reply( tvb, offset, enttec_tree);\r\nbreak;\r\ncase ENTTEC_HEAD_ESPP:\r\noffset = dissect_enttec_poll( tvb, offset, enttec_tree);\r\nbreak;\r\ncase ENTTEC_HEAD_ESAP:\r\noffset = dissect_enttec_ack( tvb, offset, enttec_tree);\r\nbreak;\r\ncase ENTTEC_HEAD_ESDD:\r\noffset = dissect_enttec_dmx_data( tvb, offset, enttec_tree);\r\nbreak;\r\ncase ENTTEC_HEAD_ESZZ:\r\noffset = dissect_enttec_reset( tvb, offset, enttec_tree);\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_enttec_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\ngint offset = 0;\r\nguint32 head = 0;\r\nproto_tree *ti,*enttec_tree;\r\nif (!tvb_bytes_exist(tvb, offset, 4))\r\nreturn 0;\r\nhead = tvb_get_ntohl(tvb, offset);\r\nif (head != ENTTEC_HEAD_ESNC) {\r\nreturn 0;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ENTTEC");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s",\r\nval_to_str(head, enttec_head_vals, "Unknown (0x%08x)"));\r\nti = proto_tree_add_item(tree, proto_enttec, tvb, offset, -1, ENC_NA);\r\nenttec_tree = proto_item_add_subtree(ti, ett_enttec);\r\nproto_tree_add_item(enttec_tree, hf_enttec_head, tvb,\r\noffset, 4, ENC_BIG_ENDIAN );\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_enttec(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_enttec_head,\r\n{ "Head", "enttec.head",\r\nFT_UINT32, BASE_HEX, VALS(enttec_head_vals), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_enttec_poll_reply_mac,\r\n{ "MAC", "enttec.poll_reply.mac",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_enttec_poll_reply_node_type,\r\n{ "Node Type", "enttec.poll_reply.node_type",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_enttec_poll_reply_version,\r\n{ "Version", "enttec.poll_reply.version",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_enttec_poll_reply_switch,\r\n{ "Switch settings", "enttec.poll_reply.switch_settings",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_enttec_poll_reply_name,\r\n{ "Name", "enttec.poll_reply.name",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_enttec_poll_reply_option,\r\n{ "Option Field", "enttec.poll_reply.option_field",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_enttec_poll_reply_tos,\r\n{ "TOS", "enttec.poll_reply.tos",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_enttec_poll_reply_ttl,\r\n{ "TTL", "enttec.poll_reply.ttl",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_enttec_dmx_data_universe,\r\n{ "Universe", "enttec.dmx_data.universe",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_enttec_dmx_data_start_code,\r\n{ "Start Code", "enttec.dmx_data.start_code",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_enttec_dmx_data_type,\r\n{ "Data Type", "enttec.dmx_data.type",\r\nFT_UINT8, BASE_HEX, VALS(enttec_data_type_vals), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_enttec_dmx_data_size,\r\n{ "Data Size", "enttec.dmx_data.size",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_enttec_dmx_data_data,\r\n{ "DMX Data", "enttec.dmx_data.data",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_enttec_dmx_data_data_filter,\r\n{ "DMX Data", "enttec.dmx_data.data_filter",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_enttec_dmx_data_dmx_data,\r\n{ "DMX Data", "enttec.dmx_data.dmx_data",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_enttec_poll_type,\r\n{ "Reply Type", "enttec.poll.reply_type",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } }\r\n};\r\nstatic gint *ett[] = {\r\n&ett_enttec,\r\n};\r\nmodule_t *enttec_module;\r\nstatic const enum_val_t disp_chan_val_types[] = {\r\n{ "pro", "Percent", 0 },\r\n{ "hex", "Hexadecimal", 1 },\r\n{ "dec", "Decimal", 2 },\r\n{ NULL, NULL, 0 }\r\n};\r\nstatic const enum_val_t disp_chan_nr_types[] = {\r\n{ "hex", "Hexadecimal", 0 },\r\n{ "dec", "Decimal", 1 },\r\n{ NULL, NULL, 0 }\r\n};\r\nstatic const enum_val_t col_count[] = {\r\n{ "6", "6", 6 },\r\n{ "10", "10", 10 },\r\n{ "12", "12", 12 },\r\n{ "16", "16", 16 },\r\n{ "24", "24", 24 },\r\n{ NULL, NULL, 0 }\r\n};\r\nproto_enttec = proto_register_protocol("ENTTEC", "ENTTEC","enttec");\r\nproto_register_field_array(proto_enttec,hf,array_length(hf));\r\nproto_register_subtree_array(ett,array_length(ett));\r\nenttec_module = prefs_register_protocol(proto_enttec,\r\nproto_reg_handoff_enttec);\r\nprefs_register_uint_preference(enttec_module, "udp_port",\r\n"ENTTEC UDP Port",\r\n"The UDP port on which ENTTEC packets will be sent",\r\n10,&global_udp_port_enttec);\r\nprefs_register_uint_preference(enttec_module, "tcp_port",\r\n"ENTTEC TCP Port",\r\n"The TCP port on which ENTTEC packets will be sent",\r\n10,&global_tcp_port_enttec);\r\nprefs_register_enum_preference(enttec_module, "dmx_disp_chan_val_type",\r\n"DMX Display channel value type",\r\n"The way DMX values are displayed",\r\n&global_disp_chan_val_type,\r\ndisp_chan_val_types, FALSE);\r\nprefs_register_enum_preference(enttec_module, "dmx_disp_chan_nr_type",\r\n"DMX Display channel nr. type",\r\n"The way DMX channel numbers are displayed",\r\n&global_disp_chan_nr_type,\r\ndisp_chan_nr_types, FALSE);\r\nprefs_register_enum_preference(enttec_module, "dmx_disp_col_count",\r\n"DMX Display Column Count",\r\n"The number of columns for the DMX display",\r\n&global_disp_col_count,\r\ncol_count, FALSE);\r\n}\r\nvoid\r\nproto_reg_handoff_enttec(void) {\r\nstatic gboolean enttec_initialized = FALSE;\r\nstatic dissector_handle_t enttec_udp_handle, enttec_tcp_handle;\r\nstatic guint udp_port_enttec;\r\nstatic guint tcp_port_enttec;\r\nif(!enttec_initialized) {\r\nenttec_udp_handle = create_dissector_handle(dissect_enttec_udp,proto_enttec);\r\nenttec_tcp_handle = create_dissector_handle(dissect_enttec_tcp,proto_enttec);\r\nenttec_initialized = TRUE;\r\n} else {\r\ndissector_delete_uint("udp.port",udp_port_enttec,enttec_udp_handle);\r\ndissector_delete_uint("tcp.port",tcp_port_enttec,enttec_tcp_handle);\r\n}\r\nudp_port_enttec = global_udp_port_enttec;\r\ntcp_port_enttec = global_tcp_port_enttec;\r\ndissector_add_uint("udp.port",global_udp_port_enttec,enttec_udp_handle);\r\ndissector_add_uint("tcp.port",global_tcp_port_enttec,enttec_tcp_handle);\r\n}
