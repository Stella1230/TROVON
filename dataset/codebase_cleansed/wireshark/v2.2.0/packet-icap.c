static int\r\ndissect_icap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *icap_tree = NULL;\r\nproto_item *ti = NULL;\r\nproto_item *hidden_item;\r\ntvbuff_t *new_tvb;\r\ngint offset = 0;\r\nconst guchar *line;\r\ngint next_offset;\r\nconst guchar *linep, *lineend;\r\nint linelen;\r\nguchar c;\r\nicap_type_t icap_type;\r\nint datalen;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ICAP");\r\nlinelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\r\nline = tvb_get_ptr(tvb, offset, linelen);\r\nicap_type = ICAP_OTHER;\r\nif (is_icap_message(line, linelen, &icap_type))\r\ncol_add_str(pinfo->cinfo, COL_INFO,\r\nformat_text(line, linelen));\r\nelse\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Continuation");\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_icap, tvb, offset, -1,\r\nENC_NA);\r\nicap_tree = proto_item_add_subtree(ti, ett_icap);\r\n}\r\nicap_type = ICAP_OTHER;\r\nwhile (tvb_offset_exists(tvb, offset)) {\r\ngboolean is_icap = FALSE;\r\ngboolean loop_done = FALSE;\r\nlinelen = tvb_find_line_end(tvb, offset, -1, &next_offset,\r\nFALSE);\r\nline = tvb_get_ptr(tvb, offset, linelen);\r\nlineend = line + linelen;\r\nif (is_icap_message(line, linelen, &icap_type)) {\r\ngoto is_icap_header;\r\n}\r\nif (linelen == 0) {\r\ngoto is_icap_header;\r\n}\r\nlinep = line;\r\nloop_done = FALSE;\r\nwhile (linep < lineend && (!loop_done)) {\r\nc = *linep++;\r\nif (!g_ascii_isprint(c)) {\r\nis_icap = FALSE;\r\nbreak;\r\n}\r\nswitch (c) {\r\ncase '(':\r\ncase ')':\r\ncase '<':\r\ncase '>':\r\ncase '@':\r\ncase ',':\r\ncase ';':\r\ncase '\\':\r\ncase '"':\r\ncase '/':\r\ncase '[':\r\ncase ']':\r\ncase '?':\r\ncase '=':\r\ncase '{':\r\ncase '}':\r\nis_icap = FALSE;\r\nloop_done = TRUE;\r\nbreak;\r\ncase ':':\r\ngoto is_icap_header;\r\n}\r\n}\r\nif (!is_icap)\r\nbreak;\r\nis_icap_header:\r\nproto_tree_add_format_text(icap_tree, tvb, offset, next_offset - offset);\r\noffset = next_offset;\r\n}\r\nif (tree) {\r\nswitch (icap_type) {\r\ncase ICAP_OPTIONS:\r\nhidden_item = proto_tree_add_boolean(icap_tree,\r\nhf_icap_options, tvb, 0, 0, 1);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nbreak;\r\ncase ICAP_REQMOD:\r\nhidden_item = proto_tree_add_boolean(icap_tree,\r\nhf_icap_reqmod, tvb, 0, 0, 1);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nbreak;\r\ncase ICAP_RESPMOD:\r\nhidden_item = proto_tree_add_boolean(icap_tree,\r\nhf_icap_respmod, tvb, 0, 0, 1);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nbreak;\r\ncase ICAP_RESPONSE:\r\nhidden_item = proto_tree_add_boolean(icap_tree,\r\nhf_icap_response, tvb, 0, 0, 1);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nbreak;\r\ncase ICAP_OTHER:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ndatalen = tvb_reported_length_remaining(tvb, offset);\r\nif (datalen > 0) {\r\nif(http_handle){\r\nnew_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_dissector(http_handle, new_tvb, pinfo, icap_tree);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\nis_icap_message(const guchar *data, int linelen, icap_type_t *type)\r\n{\r\n#define ICAP_COMPARE(string, length, msgtype) { \\r\nif (strncmp(data, string, length) == 0) { \\r\nif (*type == ICAP_OTHER) \\r\n*type = msgtype; \\r\nreturn TRUE; \\r\n} \\r\n}\r\nif (linelen >= 5) {\r\nICAP_COMPARE("ICAP/", 5, ICAP_RESPONSE);\r\n}\r\nif (linelen >= 7) {\r\nICAP_COMPARE("REQMOD ", 7, ICAP_REQMOD);\r\n}\r\nif (linelen >= 8) {\r\nICAP_COMPARE("OPTIONS ", 8, ICAP_OPTIONS);\r\nICAP_COMPARE("RESPMOD ", 8, ICAP_RESPMOD);\r\n}\r\nreturn FALSE;\r\n#undef ICAP_COMPARE\r\n}\r\nvoid\r\nproto_register_icap(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_icap_response,\r\n{ "Response", "icap.response",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"TRUE if ICAP response", HFILL }},\r\n{ &hf_icap_reqmod,\r\n{ "Reqmod", "icap.reqmod",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"TRUE if ICAP reqmod", HFILL }},\r\n{ &hf_icap_respmod,\r\n{ "Respmod", "icap.respmod",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"TRUE if ICAP respmod", HFILL }},\r\n{ &hf_icap_options,\r\n{ "Options", "icap.options",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"TRUE if ICAP options", HFILL }},\r\n#if 0\r\n{ &hf_icap_other,\r\n{ "Other", "icap.other",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"TRUE if ICAP other", HFILL }},\r\n#endif\r\n};\r\nstatic gint *ett[] = {\r\n&ett_icap,\r\n};\r\nproto_icap = proto_register_protocol(\r\n"Internet Content Adaptation Protocol",\r\n"ICAP", "icap");\r\nproto_register_field_array(proto_icap, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_icap(void)\r\n{\r\ndissector_handle_t icap_handle;\r\nhttp_handle = find_dissector_add_dependency("http", proto_icap);\r\nicap_handle = create_dissector_handle(dissect_icap, proto_icap);\r\ndissector_add_uint("tcp.port", TCP_PORT_ICAP, icap_handle);\r\n}
