static void init_gmt_to_localtime_offset(void)\r\n{\r\nif (gmt_to_localtime_offset == (time_t) -1) {\r\ntime_t ansi_epoch_plus_one_day = 86400;\r\nstruct tm gmt_tm;\r\nstruct tm local_tm;\r\ngmt_tm = *gmtime(&ansi_epoch_plus_one_day);\r\nlocal_tm = *localtime(&ansi_epoch_plus_one_day);\r\nlocal_tm.tm_isdst = 0;\r\ngmt_to_localtime_offset = mktime(&gmt_tm) - mktime(&local_tm);\r\n}\r\n}\r\nwtap_open_return_val network_instruments_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nint offset;\r\ncapture_file_header file_header;\r\nguint i;\r\ntlv_header tlvh;\r\nint seek_increment;\r\nint header_offset;\r\npacket_entry_header packet_header;\r\nobserver_dump_private_state * private_state = NULL;\r\noffset = 0;\r\nif (!wtap_read_bytes(wth->fh, &file_header, sizeof file_header,\r\nerr, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\noffset += (int)sizeof file_header;\r\nCAPTURE_FILE_HEADER_FROM_LE_IN_PLACE(file_header);\r\nif (memcmp(file_header.observer_version, network_instruments_magic, true_magic_length)!=0) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nprivate_state = (observer_dump_private_state *) g_malloc(sizeof(observer_dump_private_state));\r\nprivate_state->time_format = TIME_INFO_LOCAL;\r\nwth->priv = (void *) private_state;\r\nheader_offset = file_header.offset_to_first_packet + ((int)(file_header.offset_to_first_packet_high_byte)<<16);\r\nfor (i = 0; i < file_header.number_of_information_elements; i++) {\r\nif (offset >= header_offset)\r\nbreak;\r\nif (!wtap_read_bytes(wth->fh, &tlvh, sizeof tlvh, err, err_info))\r\nreturn WTAP_OPEN_ERROR;\r\noffset += (int)sizeof tlvh;\r\nTLV_HEADER_FROM_LE_IN_PLACE(tlvh);\r\nif (tlvh.length < sizeof tlvh) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("Observer: bad record (TLV length %u < %lu)",\r\ntlvh.length, (unsigned long)sizeof tlvh);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nswitch (tlvh.type) {\r\ncase INFORMATION_TYPE_TIME_INFO:\r\nif (!wtap_read_bytes(wth->fh, &private_state->time_format,\r\nsizeof private_state->time_format,\r\nerr, err_info))\r\nreturn WTAP_OPEN_ERROR;\r\nprivate_state->time_format = GUINT32_FROM_LE(private_state->time_format);\r\noffset += (int)sizeof private_state->time_format;\r\nbreak;\r\ndefault:\r\nseek_increment = tlvh.length - (int)sizeof tlvh;\r\nif (seek_increment > 0) {\r\nif (file_seek(wth->fh, seek_increment, SEEK_CUR, err) == -1)\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\noffset += seek_increment;\r\n}\r\n}\r\nif (header_offset < offset) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("Observer: bad record (offset to first packet %d < %d)",\r\nheader_offset, offset);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nseek_increment = header_offset - offset;\r\nif (seek_increment > 0) {\r\nif (file_seek(wth->fh, seek_increment, SEEK_CUR, err) == -1)\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (!wtap_read_bytes(wth->fh, &packet_header, sizeof packet_header,\r\nerr, err_info))\r\nreturn WTAP_OPEN_ERROR;\r\nPACKET_ENTRY_HEADER_FROM_LE_IN_PLACE(packet_header);\r\nif (packet_header.packet_magic != observer_packet_magic) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("Observer: unsupported packet version %ul", packet_header.packet_magic);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (observer_to_wtap_encap(packet_header.network_type) == WTAP_ENCAP_UNKNOWN) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("Observer: network type %u unknown or unsupported", packet_header.network_type);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nwth->file_encap = observer_to_wtap_encap(packet_header.network_type);\r\nprivate_state->packet_count = 0;\r\nprivate_state->network_type = wtap_to_observer_encap(wth->file_encap);\r\nwth->subtype_read = observer_read;\r\nwth->subtype_seek_read = observer_seek_read;\r\nwth->subtype_close = NULL;\r\nwth->subtype_sequential_close = NULL;\r\nwth->snapshot_length = 0;\r\nwth->file_tsprec = WTAP_TSPREC_NSEC;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_NETWORK_INSTRUMENTS;\r\nif (file_seek(wth->fh, header_offset, SEEK_SET, err) == -1)\r\nreturn WTAP_OPEN_ERROR;\r\ninit_gmt_to_localtime_offset();\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean observer_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\nint header_bytes_consumed;\r\nint data_bytes_consumed;\r\npacket_entry_header packet_header;\r\nfor (;;) {\r\n*data_offset = file_tell(wth->fh);\r\nheader_bytes_consumed = read_packet_header(wth, wth->fh, &wth->phdr.pseudo_header, &packet_header, err,\r\nerr_info);\r\nif (header_bytes_consumed <= 0)\r\nreturn FALSE;\r\nif (packet_header.packet_type == PACKET_TYPE_DATA_PACKET)\r\nbreak;\r\nif (!skip_to_next_packet(wth, packet_header.offset_to_next_packet,\r\nheader_bytes_consumed, err, err_info)) {\r\nreturn FALSE;\r\n}\r\n}\r\nif (!process_packet_header(wth, &packet_header, &wth->phdr, err, err_info))\r\nreturn FALSE;\r\ndata_bytes_consumed = read_packet_data(wth->fh, packet_header.offset_to_frame,\r\nheader_bytes_consumed, wth->frame_buffer,\r\nwth->phdr.caplen, err, err_info);\r\nif (data_bytes_consumed < 0) {\r\nreturn FALSE;\r\n}\r\nif (!skip_to_next_packet(wth, packet_header.offset_to_next_packet,\r\nheader_bytes_consumed + data_bytes_consumed, err, err_info)) {\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean observer_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\npacket_entry_header packet_header;\r\nint offset;\r\nint data_bytes_consumed;\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\noffset = read_packet_header(wth, wth->random_fh, pseudo_header, &packet_header, err,\r\nerr_info);\r\nif (offset <= 0)\r\nreturn FALSE;\r\nif (!process_packet_header(wth, &packet_header, phdr, err, err_info))\r\nreturn FALSE;\r\ndata_bytes_consumed = read_packet_data(wth->random_fh, packet_header.offset_to_frame,\r\noffset, buf, phdr->caplen, err, err_info);\r\nif (data_bytes_consumed < 0) {\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\nread_packet_header(wtap *wth, FILE_T fh, union wtap_pseudo_header *pseudo_header,\r\npacket_entry_header *packet_header, int *err, gchar **err_info)\r\n{\r\nint offset;\r\nguint i;\r\ntlv_header tlvh;\r\nint seek_increment;\r\ntlv_wireless_info wireless_header;\r\noffset = 0;\r\nif (!wtap_read_bytes_or_eof(fh, packet_header, sizeof *packet_header,\r\nerr, err_info)) {\r\nif (*err != 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\noffset += (int)sizeof *packet_header;\r\nPACKET_ENTRY_HEADER_FROM_LE_IN_PLACE(*packet_header);\r\nif (packet_header->packet_magic != observer_packet_magic) {\r\nfor (i = 0; i < sizeof *packet_header; i++) {\r\nif (((guint8*) packet_header)[i] != 0)\r\nbreak;\r\n}\r\nif (i == sizeof *packet_header) {\r\n*err = 0;\r\nreturn 0;\r\n}\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("Observer: bad record: Invalid magic number 0x%08x",\r\npacket_header->packet_magic);\r\nreturn -1;\r\n}\r\nswitch (wth->file_encap) {\r\ncase WTAP_ENCAP_ETHERNET:\r\npseudo_header->eth.fcs_len = 0;\r\nbreak;\r\ncase WTAP_ENCAP_IEEE_802_11_WITH_RADIO:\r\nmemset(&pseudo_header->ieee_802_11, 0, sizeof(pseudo_header->ieee_802_11));\r\npseudo_header->ieee_802_11.fcs_len = 0;\r\npseudo_header->ieee_802_11.decrypted = FALSE;\r\npseudo_header->ieee_802_11.datapad = FALSE;\r\npseudo_header->ieee_802_11.phy = PHDR_802_11_PHY_UNKNOWN;\r\nbreak;\r\n}\r\nfor (i = 0; i < packet_header->number_of_information_elements; i++) {\r\nif (!wtap_read_bytes(fh, &tlvh, sizeof tlvh, err, err_info))\r\nreturn -1;\r\noffset += (int)sizeof tlvh;\r\nTLV_HEADER_FROM_LE_IN_PLACE(tlvh);\r\nif (tlvh.length < sizeof tlvh) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("Observer: bad record (TLV length %u < %lu)",\r\ntlvh.length, (unsigned long)sizeof tlvh);\r\nreturn -1;\r\n}\r\nswitch (tlvh.type) {\r\ncase INFORMATION_TYPE_WIRELESS:\r\nif (!wtap_read_bytes(fh, &wireless_header, sizeof wireless_header,\r\nerr, err_info))\r\nreturn -1;\r\npseudo_header->ieee_802_11.decrypted = (wireless_header.conditions & WIRELESS_WEP_SUCCESS) != 0;\r\npseudo_header->ieee_802_11.has_channel = TRUE;\r\npseudo_header->ieee_802_11.channel = wireless_header.frequency;\r\npseudo_header->ieee_802_11.has_data_rate = TRUE;\r\npseudo_header->ieee_802_11.data_rate = wireless_header.rate;\r\npseudo_header->ieee_802_11.has_signal_percent = TRUE;\r\npseudo_header->ieee_802_11.signal_percent = wireless_header.strengthPercent;\r\noffset += (int)sizeof wireless_header;\r\nbreak;\r\ndefault:\r\nseek_increment = tlvh.length - (int)sizeof tlvh;\r\nif (seek_increment > 0) {\r\nif (file_seek(fh, seek_increment, SEEK_CUR, err) == -1)\r\nreturn -1;\r\n}\r\noffset += seek_increment;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic gboolean\r\nprocess_packet_header(wtap *wth, packet_entry_header *packet_header,\r\nstruct wtap_pkthdr *phdr, int *err, gchar **err_info)\r\n{\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\nphdr->pkt_encap = observer_to_wtap_encap(packet_header->network_type);\r\nif(wth->file_encap == WTAP_ENCAP_FIBRE_CHANNEL_FC2_WITH_FRAME_DELIMS) {\r\nphdr->len = packet_header->network_size;\r\nphdr->caplen = packet_header->captured_size;\r\n} else {\r\nif (packet_header->network_size < 4) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("Observer: bad record: Packet length %u < 4",\r\npacket_header->network_size);\r\nreturn FALSE;\r\n}\r\nphdr->len = packet_header->network_size - 4;\r\nphdr->caplen = MIN(packet_header->captured_size, phdr->len);\r\n}\r\nphdr->ts.secs = (time_t) ((packet_header->nano_seconds_since_2000 / 1000000000) + ansi_to_observer_epoch_offset);\r\nphdr->ts.nsecs = (int) (packet_header->nano_seconds_since_2000 % 1000000000);\r\nif (((observer_dump_private_state*)wth->priv)->time_format == TIME_INFO_LOCAL)\r\n{\r\nstruct tm daylight_tm;\r\nstruct tm standard_tm;\r\ntime_t dst_offset;\r\nphdr->ts.secs += gmt_to_localtime_offset;\r\nstandard_tm = *localtime(&phdr->ts.secs);\r\nif (standard_tm.tm_isdst > 0) {\r\ndaylight_tm = standard_tm;\r\nstandard_tm.tm_isdst = 0;\r\ndst_offset = mktime(&standard_tm) - mktime(&daylight_tm);\r\nphdr->ts.secs -= dst_offset;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\nread_packet_data(FILE_T fh, int offset_to_frame, int current_offset_from_packet_header, Buffer *buf,\r\nint length, int *err, char **err_info)\r\n{\r\nint seek_increment;\r\nint bytes_consumed = 0;\r\nif (offset_to_frame < current_offset_from_packet_header) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("Observer: bad record (offset to packet data %d < %d)",\r\noffset_to_frame, current_offset_from_packet_header);\r\nreturn -1;\r\n}\r\nseek_increment = offset_to_frame - current_offset_from_packet_header;\r\nif (seek_increment > 0) {\r\nif (file_seek(fh, seek_increment, SEEK_CUR, err) == -1) {\r\nreturn -1;\r\n}\r\nbytes_consumed += seek_increment;\r\n}\r\nws_buffer_assure_space(buf, length);\r\nif (!wtap_read_packet_bytes(fh, buf, length, err, err_info))\r\nreturn FALSE;\r\nbytes_consumed += length;\r\nreturn bytes_consumed;\r\n}\r\nstatic gboolean\r\nskip_to_next_packet(wtap *wth, int offset_to_next_packet, int current_offset_from_packet_header, int *err,\r\nchar **err_info)\r\n{\r\nint seek_increment;\r\nif (offset_to_next_packet < current_offset_from_packet_header) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("Observer: bad record (offset to next packet %d < %d)",\r\noffset_to_next_packet, current_offset_from_packet_header);\r\nreturn FALSE;\r\n}\r\nseek_increment = offset_to_next_packet - current_offset_from_packet_header;\r\nif (seek_increment > 0) {\r\nif (file_seek(wth->fh, seek_increment, SEEK_CUR, err) == -1)\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nint network_instruments_dump_can_write_encap(int encap)\r\n{\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nif (encap < 0 || (wtap_to_observer_encap(encap) == OBSERVER_UNDEFINED))\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\nreturn 0;\r\n}\r\ngboolean network_instruments_dump_open(wtap_dumper *wdh, int *err)\r\n{\r\nobserver_dump_private_state * private_state = NULL;\r\ncapture_file_header file_header;\r\ntlv_header comment_header;\r\ntlv_time_info time_header;\r\nchar comment[64];\r\nsize_t comment_length;\r\nstruct tm * current_time;\r\ntime_t system_time;\r\nprivate_state = (observer_dump_private_state *) g_malloc(sizeof(observer_dump_private_state));\r\nprivate_state->packet_count = 0;\r\nprivate_state->network_type = wtap_to_observer_encap(wdh->encap);\r\nprivate_state->time_format = TIME_INFO_GMT;\r\nwdh->priv = (void *) private_state;\r\nwdh->subtype_write = observer_dump;\r\nmemset(&file_header, 0x00, sizeof(file_header));\r\ng_strlcpy(file_header.observer_version, network_instruments_magic, 31);\r\nfile_header.offset_to_first_packet = (guint16)sizeof(file_header);\r\nfile_header.offset_to_first_packet_high_byte = 0;\r\n{\r\ntime(&system_time);\r\ncurrent_time = localtime(&system_time);\r\nmemset(&comment, 0x00, sizeof(comment));\r\ng_snprintf(comment, 64, "This capture was saved from Wireshark on %s", asctime(current_time));\r\ncomment_length = strlen(comment);\r\ncomment_header.type = INFORMATION_TYPE_COMMENT;\r\ncomment_header.length = (guint16) (sizeof(comment_header) + comment_length);\r\nfile_header.number_of_information_elements++;\r\nfile_header.offset_to_first_packet += comment_header.length;\r\n}\r\n{\r\ntime_header.type = INFORMATION_TYPE_TIME_INFO;\r\ntime_header.length = (guint16) (sizeof(time_header));\r\ntime_header.time_format = TIME_INFO_GMT;\r\nfile_header.number_of_information_elements++;\r\nfile_header.offset_to_first_packet += time_header.length;\r\n}\r\nCAPTURE_FILE_HEADER_TO_LE_IN_PLACE(file_header);\r\nif (!wtap_dump_file_write(wdh, &file_header, sizeof(file_header), err)) {\r\nreturn FALSE;\r\n}\r\nwdh->bytes_dumped += sizeof(file_header);\r\n{\r\nTLV_HEADER_TO_LE_IN_PLACE(comment_header);\r\nif (!wtap_dump_file_write(wdh, &comment_header, sizeof(comment_header), err)) {\r\nreturn FALSE;\r\n}\r\nwdh->bytes_dumped += sizeof(comment_header);\r\nif (!wtap_dump_file_write(wdh, &comment, comment_length, err)) {\r\nreturn FALSE;\r\n}\r\nwdh->bytes_dumped += comment_length;\r\n}\r\n{\r\nTLV_TIME_INFO_TO_LE_IN_PLACE(time_header);\r\nif (!wtap_dump_file_write(wdh, &time_header, sizeof(time_header), err)) {\r\nreturn FALSE;\r\n}\r\nwdh->bytes_dumped += sizeof(time_header);\r\n}\r\ninit_gmt_to_localtime_offset();\r\nreturn TRUE;\r\n}\r\nstatic gboolean observer_dump(wtap_dumper *wdh, const struct wtap_pkthdr *phdr,\r\nconst guint8 *pd,\r\nint *err, gchar **err_info _U_)\r\n{\r\nobserver_dump_private_state * private_state = NULL;\r\npacket_entry_header packet_header;\r\nguint64 seconds_since_2000;\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\nif (phdr->caplen > 65535) {\r\n*err = WTAP_ERR_PACKET_TOO_LARGE;\r\nreturn FALSE;\r\n}\r\nif (phdr->ts.secs < ansi_to_observer_epoch_offset) {\r\nif(phdr->ts.secs > (time_t) 0) {\r\nseconds_since_2000 = phdr->ts.secs;\r\n} else {\r\nseconds_since_2000 = (time_t) 0;\r\n}\r\n} else {\r\nseconds_since_2000 = phdr->ts.secs - ansi_to_observer_epoch_offset;\r\n}\r\nprivate_state = (observer_dump_private_state *) wdh->priv;\r\nmemset(&packet_header, 0x00, sizeof(packet_header));\r\npacket_header.packet_magic = observer_packet_magic;\r\npacket_header.network_speed = 1000000;\r\npacket_header.captured_size = (guint16) phdr->caplen;\r\npacket_header.network_size = (guint16) (phdr->len + 4);\r\npacket_header.offset_to_frame = sizeof(packet_header);\r\npacket_header.offset_to_next_packet = (guint16)sizeof(packet_header) + phdr->caplen;\r\npacket_header.network_type = private_state->network_type;\r\npacket_header.flags = 0x00;\r\npacket_header.number_of_information_elements = 0;\r\npacket_header.packet_type = PACKET_TYPE_DATA_PACKET;\r\npacket_header.packet_number = private_state->packet_count;\r\npacket_header.original_packet_number = packet_header.packet_number;\r\npacket_header.nano_seconds_since_2000 = seconds_since_2000 * 1000000000 + phdr->ts.nsecs;\r\nprivate_state->packet_count++;\r\nPACKET_ENTRY_HEADER_TO_LE_IN_PLACE(packet_header);\r\nif (!wtap_dump_file_write(wdh, &packet_header, sizeof(packet_header), err)) {\r\nreturn FALSE;\r\n}\r\nwdh->bytes_dumped += sizeof(packet_header);\r\nif (!wtap_dump_file_write(wdh, pd, phdr->caplen, err)) {\r\nreturn FALSE;\r\n}\r\nwdh->bytes_dumped += phdr->caplen;\r\nreturn TRUE;\r\n}\r\nstatic gint observer_to_wtap_encap(int observer_encap)\r\n{\r\nswitch(observer_encap) {\r\ncase OBSERVER_ETHERNET:\r\nreturn WTAP_ENCAP_ETHERNET;\r\ncase OBSERVER_TOKENRING:\r\nreturn WTAP_ENCAP_TOKEN_RING;\r\ncase OBSERVER_FIBRE_CHANNEL:\r\nreturn WTAP_ENCAP_FIBRE_CHANNEL_FC2_WITH_FRAME_DELIMS;\r\ncase OBSERVER_WIRELESS_802_11:\r\nreturn WTAP_ENCAP_IEEE_802_11_WITH_RADIO;\r\ncase OBSERVER_UNDEFINED:\r\nreturn WTAP_ENCAP_UNKNOWN;\r\n}\r\nreturn WTAP_ENCAP_UNKNOWN;\r\n}\r\nstatic gint wtap_to_observer_encap(int wtap_encap)\r\n{\r\nswitch(wtap_encap) {\r\ncase WTAP_ENCAP_ETHERNET:\r\nreturn OBSERVER_ETHERNET;\r\ncase WTAP_ENCAP_TOKEN_RING:\r\nreturn OBSERVER_TOKENRING;\r\ncase WTAP_ENCAP_FIBRE_CHANNEL_FC2_WITH_FRAME_DELIMS:\r\nreturn OBSERVER_FIBRE_CHANNEL;\r\ncase WTAP_ENCAP_UNKNOWN:\r\nreturn OBSERVER_UNDEFINED;\r\n}\r\nreturn OBSERVER_UNDEFINED;\r\n}
