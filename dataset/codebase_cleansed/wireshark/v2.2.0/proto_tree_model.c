static GtkTreeModelFlags\r\nproto_tree_model_get_flags(GtkTreeModel *tree_model)\r\n{\r\ng_return_val_if_fail(PROTO_IS_TREE(tree_model), (GtkTreeModelFlags)0);\r\nreturn GTK_TREE_MODEL_ITERS_PERSIST;\r\n}\r\nstatic gint\r\nproto_tree_model_get_n_columns(GtkTreeModel *tree_model)\r\n{\r\ng_return_val_if_fail(PROTO_IS_TREE(tree_model), 0);\r\nreturn 2;\r\n}\r\nstatic GType\r\nproto_tree_model_get_column_type(GtkTreeModel *tree_model, gint idx)\r\n{\r\ng_return_val_if_fail(PROTO_IS_TREE(tree_model), G_TYPE_INVALID);\r\ng_return_val_if_fail(idx == 0 || idx == 1, G_TYPE_INVALID);\r\nswitch (idx) {\r\ncase 0:\r\nreturn G_TYPE_STRING;\r\ncase 1:\r\nreturn G_TYPE_POINTER;\r\n}\r\nreturn G_TYPE_INVALID;\r\n}\r\nstatic gboolean\r\nproto_tree_model_iter_nth_child(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *parent, gint n)\r\n{\r\nProtoTreeModel *model;\r\nproto_node *node;\r\ng_return_val_if_fail(PROTO_IS_TREE(tree_model), FALSE);\r\nmodel = (ProtoTreeModel *) tree_model;\r\nif (parent) {\r\ng_return_val_if_fail(parent->stamp == model->stamp, FALSE);\r\nnode = (proto_node *)parent->user_data;\r\n} else\r\nnode = model->protocol_tree;\r\nif (!node)\r\nreturn FALSE;\r\nnode = node->first_child;\r\nwhile (node != NULL) {\r\nif (model->with_hidden || !PROTO_ITEM_IS_HIDDEN(node)) {\r\nif (!n)\r\nbreak;\r\nn--;\r\n}\r\nnode = node->next;\r\n}\r\nif (!node)\r\nreturn FALSE;\r\niter->stamp = model->stamp;\r\niter->user_data = node;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nproto_tree_model_get_iter(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreePath *path)\r\n{\r\ngint *indices, depth;\r\ng_assert(PROTO_IS_TREE(tree_model));\r\ng_assert(path != NULL);\r\nindices = gtk_tree_path_get_indices(path);\r\ndepth = gtk_tree_path_get_depth(path);\r\ng_return_val_if_fail(depth > 0, FALSE);\r\nif (!proto_tree_model_iter_nth_child(tree_model, iter, NULL, indices[0]))\r\nreturn FALSE;\r\nwhile (--depth) {\r\nindices++;\r\nif (!proto_tree_model_iter_nth_child(tree_model, iter, iter, *indices))\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic char *\r\nfi_get_string(field_info *fi)\r\n{\r\ngchar label_str[ITEM_LABEL_LENGTH];\r\ngchar *label_ptr;\r\nif (!fi->rep) {\r\nlabel_ptr = label_str;\r\nproto_item_fill_label(fi, label_str);\r\n} else\r\nlabel_ptr = fi->rep->representation;\r\nif (FI_GET_FLAG(fi, FI_GENERATED)) {\r\nif (FI_GET_FLAG(fi, FI_HIDDEN))\r\nlabel_ptr = g_strdup_printf("<[%s]>", label_ptr);\r\nelse\r\nlabel_ptr = g_strdup_printf("[%s]", label_ptr);\r\n} else if (FI_GET_FLAG(fi, FI_HIDDEN))\r\nlabel_ptr = g_strdup_printf("<%s>", label_ptr);\r\nelse\r\nlabel_ptr = g_strdup(label_ptr);\r\nreturn label_ptr;\r\n}\r\nstatic void\r\nproto_tree_model_get_value(GtkTreeModel *tree_model, GtkTreeIter *iter, gint column, GValue *value)\r\n{\r\nProtoTreeModel *model;\r\nproto_node *node;\r\nfield_info *fi;\r\ng_return_if_fail(PROTO_IS_TREE(tree_model));\r\nmodel = (ProtoTreeModel *) tree_model;\r\ng_return_if_fail(iter != NULL);\r\ng_return_if_fail(iter->stamp == model->stamp);\r\ng_return_if_fail(column == 0 || column == 1);\r\nnode = (proto_node *)iter->user_data;\r\nfi = PNODE_FINFO(node);\r\ng_assert(fi);\r\nswitch (column) {\r\ncase 0:\r\n{\r\ng_value_init(value, G_TYPE_STRING);\r\nif (model->resolv_forced) {\r\ne_addr_resolve old_flags = gbl_resolv_flags;\r\ngbl_resolv_flags = model->resolv_flags;\r\ng_value_take_string(value, fi_get_string(fi));\r\ngbl_resolv_flags = old_flags;\r\n} else\r\ng_value_take_string(value, fi_get_string(fi));\r\nbreak;\r\n}\r\ncase 1:\r\ng_value_init(value, G_TYPE_POINTER);\r\ng_value_set_pointer(value, fi);\r\nbreak;\r\n}\r\n}\r\nstatic gboolean\r\nproto_tree_model_iter_next(GtkTreeModel *tree_model, GtkTreeIter *iter)\r\n{\r\nProtoTreeModel *model;\r\nproto_node *current;\r\ng_return_val_if_fail(PROTO_IS_TREE(tree_model), FALSE);\r\nmodel = (ProtoTreeModel *) tree_model;\r\ng_return_val_if_fail(iter->stamp == model->stamp, FALSE);\r\ncurrent = (proto_node *)iter->user_data;\r\ncurrent = current->next;\r\nwhile (current) {\r\nif (model->with_hidden || !PROTO_ITEM_IS_HIDDEN(current)) {\r\niter->user_data = current;\r\nreturn TRUE;\r\n}\r\ncurrent = current->next;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nproto_tree_model_iter_children(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *parent)\r\n{\r\nreturn proto_tree_model_iter_nth_child(tree_model, iter, parent, 0);\r\n}\r\nstatic gint\r\nproto_tree_model_iter_n_children(GtkTreeModel *tree_model, GtkTreeIter *iter)\r\n{\r\nProtoTreeModel *model;\r\nproto_node *node;\r\ngint count;\r\ng_return_val_if_fail(PROTO_IS_TREE(tree_model), 0);\r\nmodel = (ProtoTreeModel *) tree_model;\r\ng_return_val_if_fail(iter == NULL || iter->user_data != NULL, 0);\r\nif (iter) {\r\ng_return_val_if_fail(iter->stamp == model->stamp, 0);\r\nnode = (proto_node *)iter->user_data;\r\n} else\r\nnode = model->protocol_tree;\r\nif (!node)\r\nreturn 0;\r\ncount = 0;\r\nnode = node->first_child;\r\nwhile (node != NULL) {\r\nif (model->with_hidden || !PROTO_ITEM_IS_HIDDEN(node))\r\ncount++;\r\nnode = node->next;\r\n}\r\nreturn count;\r\n}\r\nstatic GtkTreePath *\r\nproto_tree_model_get_path(GtkTreeModel *tree_model, GtkTreeIter *iter)\r\n{\r\nProtoTreeModel *model;\r\nGtkTreePath *path;\r\nproto_node *node;\r\ng_return_val_if_fail(PROTO_IS_TREE(tree_model), NULL);\r\nmodel = (ProtoTreeModel *) tree_model;\r\ng_return_val_if_fail(iter != NULL, NULL);\r\ng_return_val_if_fail(iter->stamp == model->stamp, NULL);\r\nnode = (proto_node *)iter->user_data;\r\ng_return_val_if_fail(node != model->protocol_tree, NULL);\r\npath = gtk_tree_path_new();\r\ndo {\r\nproto_node *cur = node;\r\nproto_node *node_i;\r\nint pos;\r\nnode = node->parent;\r\npos = 0;\r\nfor (node_i = node->first_child; node_i; node_i = node_i->next) {\r\nif (model->with_hidden || !PROTO_ITEM_IS_HIDDEN(node_i)) {\r\nif (node_i == cur)\r\nbreak;\r\npos++;\r\n}\r\n}\r\ng_assert(node_i != NULL);\r\ngtk_tree_path_prepend_index(path, pos);\r\n} while (node != model->protocol_tree);\r\nreturn path;\r\n}\r\nstatic gboolean\r\nproto_tree_model_iter_has_child(GtkTreeModel *tree_model, GtkTreeIter *iter)\r\n{\r\nProtoTreeModel *model;\r\nproto_node *node;\r\ng_return_val_if_fail(PROTO_IS_TREE(tree_model), FALSE);\r\nmodel = (ProtoTreeModel *) tree_model;\r\ng_return_val_if_fail(iter == NULL || iter->user_data != NULL, FALSE);\r\nif (iter) {\r\ng_return_val_if_fail(iter->stamp == model->stamp, FALSE);\r\nnode = (proto_node *)iter->user_data;\r\n} else\r\nnode = model->protocol_tree;\r\nif (!node)\r\nreturn FALSE;\r\nnode = node->first_child;\r\nwhile (node != NULL) {\r\nif (model->with_hidden || !PROTO_ITEM_IS_HIDDEN(node))\r\nreturn TRUE;\r\nnode = node->next;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nproto_tree_model_iter_parent(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *child)\r\n{\r\nProtoTreeModel *model;\r\nproto_node *node;\r\ng_return_val_if_fail(PROTO_IS_TREE(tree_model), FALSE);\r\nmodel = (ProtoTreeModel *) tree_model;\r\ng_return_val_if_fail(iter != NULL, FALSE);\r\ng_return_val_if_fail(child->stamp == model->stamp, FALSE);\r\nnode = (proto_node *)child->user_data;\r\nif (node->parent == model->protocol_tree)\r\nreturn FALSE;\r\ng_return_val_if_fail(node->parent != NULL, FALSE);\r\niter->stamp = model->stamp;\r\niter->user_data = node->parent;\r\nreturn TRUE;\r\n}\r\nstatic void\r\nproto_tree_model_tree_init(GtkTreeModelIface *iface)\r\n{\r\niface->get_flags = proto_tree_model_get_flags;\r\niface->get_n_columns = proto_tree_model_get_n_columns;\r\niface->get_column_type = proto_tree_model_get_column_type;\r\niface->get_iter = proto_tree_model_get_iter;\r\niface->get_path = proto_tree_model_get_path;\r\niface->get_value = proto_tree_model_get_value;\r\niface->iter_next = proto_tree_model_iter_next;\r\niface->iter_children = proto_tree_model_iter_children;\r\niface->iter_has_child = proto_tree_model_iter_has_child;\r\niface->iter_n_children = proto_tree_model_iter_n_children;\r\niface->iter_nth_child = proto_tree_model_iter_nth_child;\r\niface->iter_parent = proto_tree_model_iter_parent;\r\n}\r\nstatic void\r\nproto_tree_model_init(ProtoTreeModel *model)\r\n{\r\nmodel->stamp = g_random_int();\r\n}\r\nstatic void\r\n_class_finalize(GObject *object)\r\n{\r\n(*parent_class->finalize)(object);\r\n}\r\nstatic void\r\nproto_tree_model_class_init(ProtoTreeModelClass *klass)\r\n{\r\nGObjectClass *object_class;\r\nparent_class = (GObjectClass*) g_type_class_peek_parent(klass);\r\nobject_class = (GObjectClass*) klass;\r\nobject_class->finalize = _class_finalize;\r\n}\r\nGType\r\nproto_tree_model_get_type(void)\r\n{\r\nstatic GType proto_tree_type = 0;\r\nif (proto_tree_type == 0) {\r\nstatic const GTypeInfo proto_tree_info = {\r\nsizeof(ProtoTreeModelClass),\r\nNULL,\r\nNULL,\r\n(GClassInitFunc) proto_tree_model_class_init,\r\nNULL,\r\nNULL,\r\nsizeof(ProtoTreeModel),\r\n0,\r\n(GInstanceInitFunc) proto_tree_model_init,\r\nNULL\r\n};\r\nstatic const GInterfaceInfo tree_model_info = {\r\n(GInterfaceInitFunc) proto_tree_model_tree_init,\r\nNULL,\r\nNULL\r\n};\r\nproto_tree_type = g_type_register_static(G_TYPE_OBJECT,\r\n"ProtoTreeModel",\r\n&proto_tree_info,\r\n(GTypeFlags)0);\r\ng_type_add_interface_static(proto_tree_type,\r\nGTK_TYPE_TREE_MODEL,\r\n&tree_model_info);\r\n}\r\nreturn proto_tree_type;\r\n}\r\nvoid\r\nproto_tree_model_force_resolv(ProtoTreeModel *model, const e_addr_resolve *flags)\r\n{\r\nmodel->resolv_forced = TRUE;\r\nmodel->resolv_flags = *flags;\r\n}\r\nProtoTreeModel *\r\nproto_tree_model_new(proto_tree *protocol_tree, int display_hidden_proto_items)\r\n{\r\nProtoTreeModel *model;\r\nmodel = (ProtoTreeModel *) g_object_new(PROTO_TYPE_TREE, NULL);\r\ng_assert(model != NULL);\r\nmodel->protocol_tree = protocol_tree;\r\nmodel->with_hidden = display_hidden_proto_items;\r\nmodel->resolv_forced = FALSE;\r\nreturn model;\r\n}
