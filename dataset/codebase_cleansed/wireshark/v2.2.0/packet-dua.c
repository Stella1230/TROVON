static void\r\ndissect_int_interface_identifier_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nproto_tree_add_item(parameter_tree, hf_int_interface_id,\r\nparameter_tvb, INT_INTERFACE_ID_OFFSET, INT_INTERFACE_ID_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_append_text(parameter_item, " (%d)", tvb_get_ntohl(parameter_tvb, INT_INTERFACE_ID_OFFSET));\r\n}\r\nstatic void\r\ndissect_text_interface_identifier_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 interface_id_length;\r\ninterface_id_length = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET) - PARAMETER_HEADER_LENGTH;\r\nproto_tree_add_item(parameter_tree, hf_text_interface_id,\r\nparameter_tvb, TEXT_INTERFACE_ID_OFFSET, interface_id_length, ENC_ASCII|ENC_NA);\r\nproto_item_append_text(parameter_item, " (%.*s)", interface_id_length,\r\ntvb_format_text(parameter_tvb, TEXT_INTERFACE_ID_OFFSET, interface_id_length));\r\n}\r\nstatic void\r\ndissect_info_string_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 info_string_length;\r\ninfo_string_length = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET) - PARAMETER_HEADER_LENGTH;\r\nproto_tree_add_item(parameter_tree, hf_info_string,\r\nparameter_tvb, INFO_STRING_OFFSET, info_string_length, ENC_ASCII|ENC_NA);\r\nproto_item_append_text(parameter_item, " (%.*s)", info_string_length,\r\ntvb_format_text(parameter_tvb, INFO_STRING_OFFSET, info_string_length));\r\n}\r\nstatic void\r\ndissect_dlci_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree)\r\n{\r\nproto_tree_add_item(parameter_tree, hf_dlci_reserved, parameter_tvb, DLCI_OFFSET, DLCI_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parameter_tree, hf_dlci_v_bit, parameter_tvb, DLCI_OFFSET, DLCI_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parameter_tree, hf_dlci_zero_bit, parameter_tvb, DLCI_OFFSET, DLCI_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parameter_tree, hf_dlci_channel, parameter_tvb, DLCI_OFFSET, DLCI_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parameter_tree, hf_dlci_one_bit, parameter_tvb, DLCI_OFFSET, DLCI_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parameter_tree, hf_dlci_spare, parameter_tvb, SPARE_OFFSET, SPARE_LENGTH, ENC_BIG_ENDIAN);\r\n}\r\nstatic void\r\ndissect_diagnostic_information_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 diag_info_length;\r\ndiag_info_length = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET) - PARAMETER_HEADER_LENGTH;\r\nproto_tree_add_item(parameter_tree, hf_diag_info, parameter_tvb, PARAMETER_VALUE_OFFSET, diag_info_length, ENC_NA);\r\nproto_item_append_text(parameter_item, " (%u byte%s)", diag_info_length, plurality(diag_info_length, "", "s"));\r\n}\r\nstatic void\r\ndissect_integer_range_interface_identifier_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 number_of_ranges, range_number;\r\ngint offset;\r\nnumber_of_ranges = (tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET) - PARAMETER_HEADER_LENGTH) / INTERVAL_LENGTH;\r\noffset = PARAMETER_VALUE_OFFSET;\r\nfor(range_number = 0; range_number < number_of_ranges; range_number++) {\r\nproto_tree_add_item(parameter_tree, hf_interface_range_start,\r\nparameter_tvb, offset + START_OFFSET, START_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parameter_tree, hf_interface_range_end,\r\nparameter_tvb, offset + END_OFFSET, END_LENGTH, ENC_BIG_ENDIAN);\r\noffset += INTERVAL_LENGTH;\r\n};\r\nproto_item_append_text(parameter_item, " (%u range%s)", number_of_ranges, plurality(number_of_ranges, "", "s"));\r\n}\r\nstatic void\r\ndissect_heartbeat_data_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 heartbeat_data_length;\r\nheartbeat_data_length = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET) - PARAMETER_HEADER_LENGTH;\r\nproto_tree_add_item(parameter_tree, hf_heartbeat_data,\r\nparameter_tvb, HEARTBEAT_DATA_OFFSET, heartbeat_data_length, ENC_NA);\r\nproto_item_append_text(parameter_item, " (%u byte%s)", heartbeat_data_length, plurality(heartbeat_data_length, "", "s"));\r\n}\r\nstatic void\r\ndissect_traffic_mode_type_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nproto_tree_add_item(parameter_tree, hf_traffic_mode_type,\r\nparameter_tvb, TRAFFIC_MODE_TYPE_OFFSET, TRAFFIC_MODE_TYPE_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_append_text(parameter_item, " (%s)",\r\nval_to_str_const(tvb_get_ntohl(parameter_tvb, TRAFFIC_MODE_TYPE_OFFSET),\r\ntraffic_mode_type_values, "unknown"));\r\n}\r\nstatic void\r\ndissect_error_code_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nproto_tree_add_item(parameter_tree, hf_error_code,\r\nparameter_tvb, ERROR_CODE_OFFSET, ERROR_CODE_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_append_text(parameter_item, " (%s)",\r\nval_to_str_const(tvb_get_ntohl(parameter_tvb, ERROR_CODE_OFFSET),\r\nerror_code_values,\r\n"unknown"));\r\n}\r\nstatic void\r\ndissect_status_type_identification_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 status_type, status_id;\r\nstatus_type = tvb_get_ntohs(parameter_tvb, STATUS_TYPE_OFFSET);\r\nstatus_id = tvb_get_ntohs(parameter_tvb, STATUS_IDENT_OFFSET);\r\nproto_tree_add_item(parameter_tree, hf_status_type,\r\nparameter_tvb, STATUS_TYPE_OFFSET, STATUS_TYPE_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint_format_value(parameter_tree, hf_status_id, parameter_tvb, STATUS_IDENT_OFFSET, STATUS_IDENT_LENGTH,\r\nstatus_id, "%u (%s)", status_id,\r\nval_to_str_const(status_type * 256 * 256 + status_id, status_type_id_values, "unknown"));\r\nproto_item_append_text(parameter_item, " (%s)",\r\nval_to_str_const(status_type * 256 * 256 + status_id,\r\nstatus_type_id_values,\r\n"unknown status information"));\r\n}\r\nstatic void\r\ndissect_protocol_data_parameter(tvbuff_t *parameter_tvb, proto_item *parameter_item, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint16 protocol_data_length;\r\ntvbuff_t *protocol_data_tvb;\r\nprotocol_data_length = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET) - PARAMETER_HEADER_LENGTH;\r\nprotocol_data_tvb = tvb_new_subset_length(parameter_tvb, PROTOCOL_DATA_OFFSET, protocol_data_length);\r\nif(dpnss_handle){\r\ncall_dissector(dpnss_handle, protocol_data_tvb, pinfo, tree);\r\nreturn;\r\n}\r\ncall_data_dissector(protocol_data_tvb, pinfo, tree);\r\nproto_item_append_text(parameter_item, " (%u byte%s)", protocol_data_length, plurality(protocol_data_length, "", "s"));\r\n}\r\nstatic void\r\ndissect_release_reason_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nproto_tree_add_item(parameter_tree, hf_release_reason,\r\nparameter_tvb, RELEASE_REASON_OFFSET, RELEASE_REASON_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_append_text(parameter_item, " (%s)",\r\nval_to_str_const(tvb_get_ntohl(parameter_tvb, RELEASE_REASON_OFFSET),\r\nrelease_reason_values,\r\n"unknown"));\r\n}\r\nstatic void\r\ndissect_tei_status_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nproto_tree_add_item(parameter_tree, hf_tei_status,\r\nparameter_tvb, TEI_STATUS_OFFSET, TEI_STATUS_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_append_text(parameter_item, " (%s)",\r\nval_to_str_const(tvb_get_ntohl(parameter_tvb, TEI_STATUS_OFFSET),\r\ntei_status_values,\r\n"unknown"));\r\n}\r\nstatic void\r\ndissect_asp_identifier_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nproto_tree_add_item(parameter_tree, hf_asp_id, parameter_tvb, ASP_ID_OFFSET, ASP_ID_LENGTH, ENC_BIG_ENDIAN);\r\nproto_item_append_text(parameter_item, " (%u)", tvb_get_ntohl(parameter_tvb, ASP_ID_OFFSET));\r\n}\r\nstatic void\r\ndissect_dlc_status_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item _U_)\r\n{\r\nguint16 parameter_value_length;\r\nparameter_value_length = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET) - PARAMETER_HEADER_LENGTH;\r\nif (parameter_value_length > 0)\r\nproto_tree_add_item(parameter_tree,\r\nhf_states, parameter_tvb, PARAMETER_VALUE_OFFSET, parameter_value_length, ENC_NA);\r\n}\r\nstatic void\r\ndissect_unknown_parameter(tvbuff_t *parameter_tvb, proto_tree *parameter_tree, proto_item *parameter_item)\r\n{\r\nguint16 parameter_value_length;\r\nparameter_value_length = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET) - PARAMETER_HEADER_LENGTH;\r\nif (parameter_value_length > 0)\r\nproto_tree_add_item(parameter_tree, hf_parameter_value,\r\nparameter_tvb, PARAMETER_VALUE_OFFSET, parameter_value_length, ENC_NA);\r\nproto_item_append_text(parameter_item, " with tag %u and %u byte%s value",\r\ntvb_get_ntohs(parameter_tvb, PARAMETER_TAG_OFFSET),\r\nparameter_value_length, plurality(parameter_value_length, "", "s"));\r\n}\r\nstatic void\r\ndissect_parameter(tvbuff_t *parameter_tvb, packet_info *pinfo, proto_tree *tree, proto_tree *dua_tree)\r\n{\r\nguint16 tag, length, padding_length;\r\nproto_item *parameter_item;\r\nproto_tree *parameter_tree;\r\ntag = tvb_get_ntohs(parameter_tvb, PARAMETER_TAG_OFFSET);\r\nlength = tvb_get_ntohs(parameter_tvb, PARAMETER_LENGTH_OFFSET);\r\npadding_length = tvb_reported_length(parameter_tvb) - length;\r\nparameter_tree = proto_tree_add_subtree(dua_tree, parameter_tvb, PARAMETER_HEADER_OFFSET,\r\n-1, ett_dua_parameter, &parameter_item,\r\nval_to_str_const(tag, parameter_tag_values, "Unknown parameter"));\r\nproto_tree_add_item(parameter_tree, hf_parameter_tag,\r\nparameter_tvb, PARAMETER_TAG_OFFSET, PARAMETER_TAG_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(parameter_tree, hf_parameter_length,\r\nparameter_tvb, PARAMETER_LENGTH_OFFSET, PARAMETER_LENGTH_LENGTH, ENC_BIG_ENDIAN);\r\nswitch(tag) {\r\ncase INT_INTERFACE_IDENTIFIER_PARAMETER_TAG:\r\ndissect_int_interface_identifier_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase TEXT_INTERFACE_IDENTIFIER_PARAMETER_TAG:\r\ndissect_text_interface_identifier_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase INFO_PARAMETER_TAG:\r\ndissect_info_string_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase DLCI_PARAMETER_TAG:\r\ndissect_dlci_parameter(parameter_tvb, parameter_tree);\r\nbreak;\r\ncase DIAGNOSTIC_INFORMATION_PARAMETER_TAG:\r\ndissect_diagnostic_information_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase INTEGER_RANGE_INTERFACE_IDENTIFIER_PARAMETER_TAG:\r\ndissect_integer_range_interface_identifier_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase HEARTBEAT_DATA_PARAMETER_TAG:\r\ndissect_heartbeat_data_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase TRAFFIC_MODE_TYPE_PARAMETER_TAG:\r\ndissect_traffic_mode_type_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase ERROR_CODE_PARAMETER_TAG:\r\ndissect_error_code_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase STATUS_TYPE_INDENTIFICATION_PARAMETER_TAG:\r\ndissect_status_type_identification_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase PROTOCOL_DATA_PARAMETER_TAG:\r\ndissect_protocol_data_parameter(parameter_tvb, parameter_item, pinfo, tree);\r\nbreak;\r\ncase RELEASE_REASON_PARAMETER_TAG:\r\ndissect_release_reason_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase TEI_STATUS_PARAMETER_TAG:\r\ndissect_tei_status_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase ASP_IDENTIFIER_PARAMETER_TAG:\r\ndissect_asp_identifier_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ncase DLC_STATUS_PARAMETER_TAG:\r\ndissect_dlc_status_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\ndefault:\r\ndissect_unknown_parameter(parameter_tvb, parameter_tree, parameter_item);\r\nbreak;\r\n};\r\nif (padding_length > 0)\r\nproto_tree_add_item(parameter_tree, hf_parameter_padding,\r\nparameter_tvb, PARAMETER_HEADER_OFFSET + length, padding_length, ENC_NA);\r\n}\r\nstatic void\r\ndissect_parameters(tvbuff_t *parameters_tvb, packet_info *pinfo, proto_tree *tree, proto_tree *dua_tree)\r\n{\r\ngint offset, length, total_length, remaining_length;\r\ntvbuff_t *parameter_tvb;\r\noffset = 0;\r\nwhile((remaining_length = tvb_reported_length_remaining(parameters_tvb, offset))) {\r\nlength = tvb_get_ntohs(parameters_tvb, offset + PARAMETER_LENGTH_OFFSET);\r\ntotal_length = ADD_PADDING(length);\r\nif (remaining_length >= length)\r\ntotal_length = MIN(total_length, remaining_length);\r\nparameter_tvb = tvb_new_subset_length(parameters_tvb, offset, total_length);\r\ndissect_parameter(parameter_tvb, pinfo, tree, dua_tree);\r\noffset += total_length;\r\n}\r\n}\r\nstatic void\r\ndissect_common_header(tvbuff_t *common_header_tvb, packet_info *pinfo, proto_tree *dua_tree)\r\n{\r\nguint8 message_class, message_type;\r\nmessage_class = tvb_get_guint8(common_header_tvb, MESSAGE_CLASS_OFFSET);\r\nmessage_type = tvb_get_guint8(common_header_tvb, MESSAGE_TYPE_OFFSET);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s ", val_to_str_const(message_class * 256 + message_type,\r\nmessage_class_type_acro_values,\r\n"Unknown"));\r\nif (dua_tree) {\r\nproto_tree_add_item(dua_tree, hf_version, common_header_tvb, VERSION_OFFSET, VERSION_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(dua_tree, hf_reserved, common_header_tvb, RESERVED_OFFSET, RESERVED_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(dua_tree, hf_message_class,\r\ncommon_header_tvb, MESSAGE_CLASS_OFFSET, MESSAGE_CLASS_LENGTH, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint_format_value(dua_tree, hf_message_type,\r\ncommon_header_tvb, MESSAGE_TYPE_OFFSET, MESSAGE_TYPE_LENGTH,\r\nmessage_type, "%u (%s)",\r\nmessage_type, val_to_str_const(message_class * 256 + message_type,\r\nmessage_class_type_values,\r\n"reserved"));\r\nproto_tree_add_item(dua_tree, hf_message_length,\r\ncommon_header_tvb, MESSAGE_LENGTH_OFFSET, MESSAGE_LENGTH_LENGTH, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_dua_message(tvbuff_t *message_tvb, packet_info *pinfo, proto_tree *tree, proto_tree *dua_tree)\r\n{\r\ntvbuff_t *common_header_tvb, *parameters_tvb;\r\ncommon_header_tvb = tvb_new_subset_length(message_tvb, COMMON_HEADER_OFFSET, COMMON_HEADER_LENGTH);\r\nparameters_tvb = tvb_new_subset_remaining(message_tvb, PARAMETERS_OFFSET);\r\ndissect_common_header(common_header_tvb, pinfo, dua_tree);\r\ndissect_parameters(parameters_tvb, pinfo, tree, dua_tree);\r\n}\r\nstatic int\r\ndissect_dua(tvbuff_t *message_tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *dua_item;\r\nproto_tree *dua_tree;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "DUA");\r\ndua_item = proto_tree_add_item(tree, proto_dua, message_tvb, 0, -1, ENC_NA);\r\ndua_tree = proto_item_add_subtree(dua_item, ett_dua);\r\ndissect_dua_message(message_tvb, pinfo, tree, dua_tree);\r\nreturn tvb_captured_length(message_tvb);\r\n}\r\nvoid\r\nproto_register_dua(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_int_interface_id,\r\n{ "Integer interface identifier", "dua.int_interface_identifier",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_text_interface_id,\r\n{ "Text interface identifier", "dua.text_interface_identifier",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_info_string,\r\n{ "Info string", "dua.info_string",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_dlci_reserved,\r\n{ "Reserved", "dua.dlci_reserved",\r\nFT_UINT16, BASE_DEC, NULL, RESERVED_BIT_MASK,\r\nNULL, HFILL } },\r\n{ &hf_dlci_v_bit,\r\n{ "V-bit", "dua.dlci_v_bit",\r\nFT_BOOLEAN, 16, NULL, V_BIT_MASK,\r\nNULL, HFILL } },\r\n{ &hf_dlci_zero_bit,\r\n{ "Zero bit", "dua.dlci_zero_bit",\r\nFT_BOOLEAN, 16, NULL, ZERO_BIT_MASK,\r\nNULL, HFILL } },\r\n{ &hf_dlci_channel,\r\n{ "Channel", "dua.dlci_channel",\r\nFT_UINT16, BASE_DEC, NULL, CHANNEL_BIT_MASK,\r\nNULL, HFILL } },\r\n{ &hf_dlci_one_bit,\r\n{ "One bit", "dua.dlci_one_bit",\r\nFT_BOOLEAN, 16, NULL, ONE_BIT_MASK,\r\nNULL, HFILL } },\r\n{ &hf_dlci_spare,\r\n{ "Spare", "dua.dlci_spare",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_diag_info,\r\n{ "Diagnostic information", "dua.diagnostic_information",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_interface_range_start,\r\n{ "Start", "dua.interface_range_start",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_interface_range_end,\r\n{ "End", "dua.interface_range_end",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_heartbeat_data,\r\n{ "Heartbeat data", "dua.heartbeat_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_traffic_mode_type,\r\n{ "Traffic mode type", "dua.traffic_mode_type",\r\nFT_UINT32, BASE_HEX, VALS(traffic_mode_type_values), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_error_code,\r\n{ "Error code", "dua.error_code",\r\nFT_UINT32, BASE_DEC, VALS(error_code_values), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_status_type,\r\n{ "Status type", "dua.status_type",\r\nFT_UINT16, BASE_DEC, VALS(status_type_values), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_status_id,\r\n{ "Status identification", "dua.status_identification",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_release_reason,\r\n{ "Reason", "dua.release_reason",\r\nFT_UINT32, BASE_HEX, VALS(release_reason_values), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_tei_status,\r\n{ "TEI status", "dua.tei_status",\r\nFT_UINT32, BASE_HEX, VALS(tei_status_values), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_asp_id,\r\n{ "ASP identifier", "dua.asp_identifier",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_states,\r\n{ "States", "dua.states",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_parameter_tag,\r\n{ "Parameter Tag", "dua.parameter_tag",\r\nFT_UINT16, BASE_DEC, VALS(parameter_tag_values), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_parameter_length,\r\n{ "Parameter length", "dua.parameter_length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_parameter_value,\r\n{ "Parameter value", "dua.parameter_value",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_parameter_padding,\r\n{ "Parameter padding", "dua.parameter_padding",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_version,\r\n{ "Version", "dua.version",\r\nFT_UINT8, BASE_DEC, VALS(protocol_version_values), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_reserved,\r\n{ "Reserved", "dua.reserved",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_message_class,\r\n{ "Message class", "dua.message_class",\r\nFT_UINT8, BASE_DEC, VALS(message_class_values), 0x0,\r\nNULL, HFILL } },\r\n{ &hf_message_type,\r\n{ "Message Type", "dua.message_type",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_message_length,\r\n{ "Message length", "dua.message_length",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n};\r\nstatic gint *ett[] = {\r\n&ett_dua,\r\n&ett_dua_parameter,\r\n};\r\nproto_dua = proto_register_protocol("DPNSS/DASS2-User Adaptation Layer", "DUA", "dua");\r\nproto_register_field_array(proto_dua, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nregister_dissector("dua", dissect_dua, proto_dua);\r\n}\r\nvoid\r\nproto_reg_handoff_dua(void)\r\n{\r\ndissector_handle_t dua_handle;\r\ndua_handle = find_dissector("dua");\r\ndpnss_handle = find_dissector_add_dependency("dpnss", proto_dua);\r\ndissector_add_uint("sctp.ppi", DUA_PAYLOAD_PROTOCOL_ID, dua_handle);\r\n}
