wtap_open_return_val\r\niseries_open (wtap * wth, int *err, gchar ** err_info)\r\n{\r\ngint offset;\r\nchar magic[ISERIES_LINE_LENGTH];\r\nif (!wtap_read_bytes (wth->fh, &magic, sizeof magic, err, err_info))\r\n{\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\noffset=0;\r\nwhile ((unsigned int)offset < (ISERIES_LINE_LENGTH - (sizeof iseries_hdr_magic_le_ucs_2)))\r\n{\r\nif (memcmp (magic + offset, iseries_hdr_magic_le_ucs_2, sizeof iseries_hdr_magic_le_ucs_2) == 0) {\r\nif (file_seek (wth->fh, 0, SEEK_SET, err) == -1)\r\n{\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (!iseries_check_file_type (wth, err, err_info, ISERIES_FORMAT_UNICODE))\r\n{\r\nif (*err == 0)\r\nreturn WTAP_OPEN_NOT_MINE;\r\nelse\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nwth->file_encap = WTAP_ENCAP_ETHERNET;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_ISERIES;\r\nwth->snapshot_length = 0;\r\nwth->subtype_read = iseries_read;\r\nwth->subtype_seek_read = iseries_seek_read;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nif (file_seek (wth->fh, 0, SEEK_SET, err) == -1)\r\n{\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nreturn WTAP_OPEN_MINE;\r\n}\r\noffset += 1;\r\n}\r\noffset=0;\r\nwhile ((unsigned int)offset < (ISERIES_LINE_LENGTH - sizeof iseries_hdr_magic_ascii))\r\n{\r\nif (memcmp (magic + offset, iseries_hdr_magic_ascii, sizeof iseries_hdr_magic_ascii) == 0)\r\n{\r\nif (file_seek (wth->fh, 0, SEEK_SET, err) == -1)\r\n{\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (!iseries_check_file_type (wth, err, err_info, ISERIES_FORMAT_ASCII))\r\n{\r\nif (*err == 0)\r\nreturn WTAP_OPEN_NOT_MINE;\r\nelse\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nwth->file_encap = WTAP_ENCAP_ETHERNET;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_ISERIES;\r\nwth->snapshot_length = 0;\r\nwth->subtype_read = iseries_read;\r\nwth->subtype_seek_read = iseries_seek_read;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nif (file_seek (wth->fh, 0, SEEK_SET, err) == -1)\r\n{\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nreturn WTAP_OPEN_MINE;\r\n}\r\noffset += 1;\r\n}\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nstatic gboolean\r\niseries_check_file_type (wtap * wth, int *err, gchar **err_info, int format)\r\n{\r\ngboolean is_iseries = FALSE;\r\nguint line;\r\nint num_items_scanned;\r\nchar buf[ISERIES_LINE_LENGTH], protocol[9];\r\niseries_t *iseries;\r\niseries = (iseries_t *) g_malloc (sizeof (iseries_t));\r\niseries->have_date = FALSE;\r\niseries->format = format;\r\nfor (line = 0; line < ISERIES_HDR_LINES_TO_CHECK; line++)\r\n{\r\nmemset(buf, 0x0, sizeof(buf));\r\nif (file_gets (buf, ISERIES_LINE_LENGTH, wth->fh) == NULL)\r\n{\r\n*err = file_error (wth->fh, err_info);\r\nif (*err == WTAP_ERR_SHORT_READ)\r\n*err = 0;\r\nbreak;\r\n}\r\nif (iseries->format == ISERIES_FORMAT_UNICODE)\r\n{\r\niseries_UNICODE_to_ASCII ((guint8 *)buf, ISERIES_LINE_LENGTH);\r\n}\r\nascii_strup_inplace (buf);\r\nnum_items_scanned = sscanf (buf,\r\n"%*[ \n\t]OBJECT PROTOCOL%*[ .:\n\t]%8s",\r\nprotocol);\r\nif (num_items_scanned == 1)\r\n{\r\nif (memcmp (protocol, "ETHERNET", 8) == 0)\r\n{\r\n*err = 0;\r\nis_iseries = TRUE;\r\n}\r\n}\r\nnum_items_scanned = sscanf (buf,\r\n"%*[ \n\t]START DATE/TIME%*[ .:\n\t]%2d/%2d/%2d",\r\n&iseries->month, &iseries->day,\r\n&iseries->year);\r\nif (num_items_scanned == 3)\r\n{\r\niseries->have_date = TRUE;\r\n}\r\n}\r\nif (is_iseries)\r\nwth->priv = (void *) iseries;\r\nelse\r\ng_free(iseries);\r\nreturn is_iseries;\r\n}\r\nstatic gboolean\r\niseries_read (wtap * wth, int *err, gchar ** err_info, gint64 *data_offset)\r\n{\r\ngint64 offset;\r\noffset = iseries_seek_next_packet (wth, err, err_info);\r\nif (offset < 0)\r\nreturn FALSE;\r\n*data_offset = offset;\r\nreturn iseries_parse_packet (wth, wth->fh, &wth->phdr, wth->frame_buffer,\r\nerr, err_info);\r\n}\r\nstatic gint64\r\niseries_seek_next_packet (wtap * wth, int *err, gchar **err_info)\r\n{\r\niseries_t *iseries = (iseries_t *)wth->priv;\r\nchar buf[ISERIES_LINE_LENGTH],type[5];\r\nint line, num_items_scanned;\r\ngint64 cur_off;\r\nlong buflen;\r\nfor (line = 0; line < ISERIES_MAX_TRACE_LEN; line++)\r\n{\r\nif (file_gets (buf, ISERIES_LINE_LENGTH, wth->fh) == NULL)\r\n{\r\n*err = file_error (wth->fh, err_info);\r\nreturn -1;\r\n}\r\nif (iseries->format == ISERIES_FORMAT_UNICODE)\r\n{\r\nbuflen = iseries_UNICODE_to_ASCII ((guint8 *) buf, ISERIES_LINE_LENGTH);\r\n}\r\nelse\r\n{\r\nbuflen = (long) strlen (buf);\r\n}\r\nascii_strup_inplace (buf);\r\nnum_items_scanned =\r\nsscanf (buf+78,\r\n"%*[ \n\t]ETHV2%*[ .:\n\t]TYPE%*[ .:\n\t]%4s",type);\r\nif (num_items_scanned == 1)\r\n{\r\ncur_off = file_tell (wth->fh);\r\nif (cur_off == -1)\r\n{\r\n*err = file_error (wth->fh, err_info);\r\nreturn -1;\r\n}\r\nif (file_seek (wth->fh, cur_off - buflen, SEEK_SET, err) == -1)\r\n{\r\nreturn -1;\r\n}\r\nreturn cur_off - buflen;\r\n}\r\n}\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info =\r\ng_strdup_printf ("iseries: next packet header not found within %d lines",\r\nISERIES_MAX_TRACE_LEN);\r\nreturn -1;\r\n}\r\nstatic gboolean\r\niseries_seek_read (wtap * wth, gint64 seek_off, struct wtap_pkthdr *phdr,\r\nBuffer * buf, int *err, gchar ** err_info)\r\n{\r\nif (file_seek (wth->random_fh, seek_off - 1, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nreturn iseries_parse_packet (wth, wth->random_fh, phdr, buf,\r\nerr, err_info);\r\n}\r\nstatic int\r\nappend_hex_digits(char *ascii_buf, int ascii_offset, int max_offset,\r\nchar *data, int *err, gchar **err_info)\r\n{\r\nint in_offset, out_offset;\r\nint c;\r\nunsigned int i;\r\ngboolean overflow = FALSE;\r\nin_offset = 0;\r\nout_offset = ascii_offset;\r\nfor (;;)\r\n{\r\nfor (i = 0; i < 16; i++, in_offset++)\r\n{\r\nc = data[in_offset] & 0xFF;\r\nif (c == '\0' || c == ' ' || c == '*' || c == '\r' || c == '\n')\r\n{\r\ngoto done;\r\n}\r\nif (!g_ascii_isxdigit(c) || g_ascii_islower(c))\r\n{\r\nreturn ascii_offset;\r\n}\r\nif (out_offset >= max_offset)\r\noverflow = TRUE;\r\nelse\r\n{\r\nascii_buf[out_offset] = c;\r\nout_offset++;\r\n}\r\n}\r\nfor (; (data[in_offset] & 0xFF) == ' '; in_offset++)\r\n;\r\n}\r\ndone:\r\nif ((i % 2) != 0)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("iseries: odd number of hex digits in a line");\r\nreturn -1;\r\n}\r\nif (overflow)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("iseries: more packet data than the packet length indicated");\r\nreturn -1;\r\n}\r\nreturn out_offset;\r\n}\r\nstatic gboolean\r\niseries_parse_packet (wtap * wth, FILE_T fh, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\niseries_t *iseries = (iseries_t *)wth->priv;\r\ngint64 cur_off;\r\ngboolean isValid, isCurrentPacket;\r\nint num_items_scanned, line, pktline, buflen;\r\nint pkt_len, pktnum, hr, min, sec;\r\nchar direction[2], destmac[13], srcmac[13], type[5], csec[9+1];\r\nchar data[ISERIES_LINE_LENGTH * 2];\r\nint offset;\r\nchar *ascii_buf;\r\nint ascii_offset;\r\nstruct tm tm;\r\nisValid = FALSE;\r\nfor (line = 1; line < ISERIES_PKT_LINES_TO_CHECK; line++)\r\n{\r\nif (file_gets (data, ISERIES_LINE_LENGTH, fh) == NULL)\r\n{\r\n*err = file_error (fh, err_info);\r\nreturn FALSE;\r\n}\r\nif (iseries->format == ISERIES_FORMAT_UNICODE)\r\n{\r\niseries_UNICODE_to_ASCII ((guint8 *)data, ISERIES_LINE_LENGTH);\r\n}\r\nascii_strup_inplace (data);\r\nnum_items_scanned =\r\nsscanf (data,\r\n"%*[ \n\t]%6d%*[ *\n\t]%1s%*[ \n\t]%6d%*[ \n\t]%2d:%2d:%2d.%9[0-9]%*[ \n\t]"\r\n"%12s%*[ \n\t]%12s%*[ \n\t]ETHV2%*[ \n\t]TYPE:%*[ \n\t]%4s",\r\n&pktnum, direction, &pkt_len, &hr, &min, &sec, csec, destmac,\r\nsrcmac, type);\r\nif (num_items_scanned == 10)\r\n{\r\nif (pktnum < 0)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup ("iseries: packet header has a negative packet number");\r\nreturn FALSE;\r\n}\r\nif (pkt_len < 0)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup ("iseries: packet header has a negative packet length");\r\nreturn FALSE;\r\n}\r\nif (hr < 0)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup ("iseries: packet header has a negative hour in the time stamp");\r\nreturn FALSE;\r\n}\r\nif (hr > 23)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup ("iseries: packet header has a hour in the time stamp greater than 23");\r\nreturn FALSE;\r\n}\r\nif (min < 0)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup ("iseries: packet header has a negative minute in the time stamp");\r\nreturn FALSE;\r\n}\r\nif (min > 59)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup ("iseries: packet header has a minute in the time stamp greater than 59");\r\nreturn FALSE;\r\n}\r\nif (sec < 0)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup ("iseries: packet header has a negative second in the time stamp");\r\nreturn FALSE;\r\n}\r\nif (sec > 60)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup ("iseries: packet header has a second in the time stamp greater than 60");\r\nreturn FALSE;\r\n}\r\nif (strlen(destmac) != 12)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup ("iseries: packet header has a destination MAC address shorter than 6 bytes");\r\nreturn FALSE;\r\n}\r\nif (strlen(srcmac) != 12)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup ("iseries: packet header has a source MAC address shorter than 6 bytes");\r\nreturn FALSE;\r\n}\r\nif (strlen(type) != 4)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup ("iseries: packet header has an Ethernet type/length field than 2 bytes");\r\nreturn FALSE;\r\n}\r\nisValid = TRUE;\r\nif (pkt_len > WTAP_MAX_PACKET_SIZE - 14)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("iseries: File has %" G_GUINT64_FORMAT "-byte packet, bigger than maximum of %u",\r\n(guint64)pkt_len + 14,\r\nWTAP_MAX_PACKET_SIZE);\r\nreturn FALSE;\r\n}\r\npkt_len += 14;\r\nbreak;\r\n}\r\n}\r\nif (!isValid)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup ("iseries: packet header isn't valid");\r\nreturn FALSE;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_CAP_LEN;\r\nif (iseries->have_date)\r\n{\r\nphdr->presence_flags |= WTAP_HAS_TS;\r\ntm.tm_year = 100 + iseries->year;\r\ntm.tm_mon = iseries->month - 1;\r\ntm.tm_mday = iseries->day;\r\ntm.tm_hour = hr;\r\ntm.tm_min = min;\r\ntm.tm_sec = sec;\r\ntm.tm_isdst = -1;\r\nphdr->ts.secs = mktime (&tm);\r\ncsec[sizeof(csec) - 1] = '\0';\r\nswitch (strlen(csec))\r\n{\r\ncase 0:\r\nphdr->ts.nsecs = 0;\r\nbreak;\r\ncase 1:\r\nphdr->ts.nsecs = atoi(csec) * 100000000;\r\nbreak;\r\ncase 2:\r\nphdr->ts.nsecs = atoi(csec) * 10000000;\r\nbreak;\r\ncase 3:\r\nphdr->ts.nsecs = atoi(csec) * 1000000;\r\nbreak;\r\ncase 4:\r\nphdr->ts.nsecs = atoi(csec) * 100000;\r\nbreak;\r\ncase 5:\r\nphdr->ts.nsecs = atoi(csec) * 10000;\r\nbreak;\r\ncase 6:\r\nphdr->ts.nsecs = atoi(csec) * 1000;\r\nbreak;\r\ncase 7:\r\nphdr->ts.nsecs = atoi(csec) * 100;\r\nbreak;\r\ncase 8:\r\nphdr->ts.nsecs = atoi(csec) * 10;\r\nbreak;\r\ncase 9:\r\nphdr->ts.nsecs = atoi(csec);\r\nbreak;\r\n}\r\n}\r\nphdr->len = pkt_len;\r\nphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\r\nphdr->pseudo_header.eth.fcs_len = -1;\r\nascii_buf = (char *)g_malloc (pkt_len*2);\r\nascii_offset = 0;\r\nmemcpy(&ascii_buf[0], destmac, 12);\r\nascii_offset += 12;\r\nmemcpy(&ascii_buf[12], srcmac, 12);\r\nascii_offset += 12;\r\nmemcpy(&ascii_buf[24], type, 4);\r\nascii_offset += 4;\r\nisCurrentPacket = TRUE;\r\npktline = 0;\r\nwhile (isCurrentPacket)\r\n{\r\npktline++;\r\nif (file_gets (data, ISERIES_LINE_LENGTH, fh) == NULL)\r\n{\r\n*err = file_error (fh, err_info);\r\nif (*err == 0)\r\n{\r\nbreak;\r\n}\r\ngoto errxit;\r\n}\r\nif (iseries->format == ISERIES_FORMAT_UNICODE)\r\n{\r\nbuflen = iseries_UNICODE_to_ASCII ((guint8 *)data, ISERIES_LINE_LENGTH);\r\n}\r\nelse\r\n{\r\nbuflen = (int) strlen (data);\r\n}\r\nfor (offset = 0; g_ascii_isspace(data[offset]); offset++)\r\n;\r\nif (offset == 22)\r\n{\r\nif (strncmp(data + 22, "IP Header : ", 14) == 0 ||\r\nstrncmp(data + 22, "IPv6 Header: ", 14) == 0 ||\r\nstrncmp(data + 22, "ARP Header : ", 14) == 0 ||\r\nstrncmp(data + 22, "TCP Header : ", 14) == 0 ||\r\nstrncmp(data + 22, "UDP Header : ", 14) == 0 ||\r\nstrncmp(data + 22, "ICMP Header: ", 14) == 0 ||\r\nstrncmp(data + 22, "ICMPv6 Hdr: ", 14) == 0 ||\r\nstrncmp(data + 22, "Option Hdr: ", 14) == 0)\r\n{\r\nascii_offset = append_hex_digits(ascii_buf, ascii_offset,\r\npkt_len*2,\r\ndata + 22 + 14, err,\r\nerr_info);\r\nif (ascii_offset == -1)\r\n{\r\nreturn FALSE;\r\n}\r\ncontinue;\r\n}\r\n}\r\nif (offset == 9)\r\n{\r\nif (strncmp(data + 9, "Data . . . . . : ", 18) == 0)\r\n{\r\nascii_offset = append_hex_digits(ascii_buf, ascii_offset,\r\npkt_len*2,\r\ndata + 9 + 18, err,\r\nerr_info);\r\nif (ascii_offset == -1)\r\n{\r\nreturn FALSE;\r\n}\r\ncontinue;\r\n}\r\n}\r\nif (offset == 36 || offset == 27)\r\n{\r\nascii_offset = append_hex_digits(ascii_buf, ascii_offset,\r\npkt_len*2,\r\ndata + offset, err,\r\nerr_info);\r\nif (ascii_offset == -1)\r\n{\r\nreturn FALSE;\r\n}\r\ncontinue;\r\n}\r\nascii_strup_inplace (data);\r\nnum_items_scanned =\r\nsscanf (data+78,\r\n"%*[ \n\t]ETHV2%*[ .:\n\t]TYPE%*[ .:\n\t]%4s",type);\r\nif ((num_items_scanned == 1) && pktline > 1)\r\n{\r\nisCurrentPacket = FALSE;\r\ncur_off = file_tell( fh);\r\nif (cur_off == -1)\r\n{\r\n*err = file_error (fh, err_info);\r\ngoto errxit;\r\n}\r\nif (file_seek (fh, cur_off - buflen, SEEK_SET, err) == -1)\r\n{\r\ngoto errxit;\r\n}\r\n}\r\n}\r\nphdr->caplen = ((guint32) ascii_offset)/2;\r\nws_buffer_assure_space (buf, phdr->caplen);\r\niseries_parse_hex_string (ascii_buf, ws_buffer_start_ptr (buf), ascii_offset);\r\n*err = 0;\r\ng_free (ascii_buf);\r\nreturn TRUE;\r\nerrxit:\r\ng_free (ascii_buf);\r\nreturn FALSE;\r\n}\r\nstatic int\r\niseries_UNICODE_to_ASCII (guint8 * buf, guint bytes)\r\n{\r\nguint i;\r\nguint8 *bufptr;\r\nbufptr = buf;\r\nfor (i = 0; i < bytes; i++)\r\n{\r\nswitch (buf[i])\r\n{\r\ncase 0xFE:\r\ncase 0xFF:\r\ncase 0x00:\r\nbreak;\r\ndefault:\r\n*bufptr = buf[i];\r\nbufptr++;\r\n}\r\nif (buf[i] == 0x0A)\r\nreturn i;\r\n}\r\nreturn i;\r\n}\r\nstatic gboolean\r\niseries_parse_hex_string (const char * ascii, guint8 * buf, size_t len)\r\n{\r\nsize_t i;\r\nint byte;\r\ngint hexvalue;\r\nguint8 bytevalue;\r\nbyte = 0;\r\nfor (i = 0; i < len; i++)\r\n{\r\nhexvalue = g_ascii_xdigit_value(ascii[i]);\r\ni++;\r\nif (hexvalue == -1)\r\nreturn FALSE;\r\nbytevalue = (guint8)(hexvalue << 4);\r\nif (i >= len)\r\nreturn FALSE;\r\nhexvalue = g_ascii_xdigit_value(ascii[i]);\r\nif (hexvalue == -1)\r\nreturn FALSE;\r\nbytevalue |= (guint8) hexvalue;\r\nbuf[byte] = bytevalue;\r\nbyte++;\r\n}\r\nreturn TRUE;\r\n}
