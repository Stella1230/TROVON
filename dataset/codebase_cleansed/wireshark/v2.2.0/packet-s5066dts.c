static void dissect_s5066dts_eow_drc_request(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_s5066dts_eow_drc_request_data_rate, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_eow_drc_request_interleaving, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_eow_drc_request_others, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nstatic void dissect_s5066dts_eow_drc_response(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_s5066dts_eow_drc_response_response, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_eow_drc_response_reason, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nstatic void dissect_s5066dts_eow_unrec_type(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_s5066dts_eow_unrec_type_response, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_eow_unrec_type_reason, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nstatic void dissect_s5066dts_eow_capability(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_s5066dts_eow_capability_adaptive, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_eow_capability_stanag_4529, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_eow_capability_mil_std_188_110a, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_eow_capability_extended, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_eow_capability_full_duplex, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_eow_capability_split_frequency, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_eow_capability_non_arcs_ale, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_eow_capability_arcs, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nstatic void dissect_s5066dts_eow_alm_request(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_s5066dts_eow_alm_request_data_rate, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_eow_alm_request_interleaving, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_eow_alm_request_others, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nstatic void dissect_s5066dts_eow_alm_response(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_s5066dts_eow_alm_response_response, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_eow_alm_response_reason, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nstatic void dissect_s5066dts_eow_hdr_drc_request(tvbuff_t *tvb, packet_info * pinfo, guint offset,\r\nproto_tree *tree, guint pdu_type)\r\n{\r\nif (pdu_type != S5066_DPDU_MANAGEMENT)\r\n{\r\nexpert_add_info(pinfo, tree, &ei_s5066dts_eow_hdr_drc_request_invalid);\r\nreturn;\r\n}\r\nproto_tree_add_item(tree, hf_s5066dts_eow_hdr_drc_request_waveform, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_eow_hdr_drc_request_num_channels, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nstatic void dissect_s5066dts_eow_hftrp(tvbuff_t *tvb, packet_info * pinfo, guint offset,\r\nproto_tree *tree, guint pdu_type)\r\n{\r\nif (pdu_type != S5066_DPDU_MANAGEMENT)\r\n{\r\nexpert_add_info(pinfo, tree, &ei_s5066dts_eow_hftrp_invalid);\r\nreturn;\r\n}\r\nproto_tree_add_item(tree, hf_s5066dts_eow_hftrp_hftrp_token, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nstatic guint dissect_s5066dts_eow(tvbuff_t *tvb, packet_info * pinfo, guint offset, proto_tree *tree,\r\nguint pdu_type)\r\n{\r\nproto_tree *eow_tree;\r\nguint eow_type;\r\neow_type = tvb_get_guint8(tvb, offset) & 0x0F;\r\neow_tree = proto_tree_add_subtree(tree, tvb, offset, 2, ett_s5066dts_eow, NULL, "EOW Field");\r\nproto_tree_add_item(eow_tree, hf_s5066dts_eow_type, tvb, offset, 1, ENC_BIG_ENDIAN); offset++;\r\nswitch (eow_type)\r\n{\r\ncase S5066_EOW_RESERVED:\r\nproto_tree_add_item(eow_tree, hf_s5066dts_eow_data, tvb, offset, 1, ENC_BIG_ENDIAN); break;\r\ncase S5066_EOW_DRC_REQUEST:\r\ndissect_s5066dts_eow_drc_request(tvb, offset, eow_tree); break;\r\ncase S5066_EOW_DRC_RESPONSE:\r\ndissect_s5066dts_eow_drc_response(tvb, offset, eow_tree); break;\r\ncase S5066_EOW_UNRECOGNIZED_TYPE:\r\ndissect_s5066dts_eow_unrec_type(tvb, offset, eow_tree); break;\r\ncase S5066_EOW_CAPABILITY:\r\ndissect_s5066dts_eow_capability(tvb, offset, eow_tree); break;\r\ncase S5066_EOW_ALM_REQUEST:\r\ndissect_s5066dts_eow_alm_request(tvb, offset, eow_tree); break;\r\ncase S5066_EOW_ALM_RESPONSE:\r\ndissect_s5066dts_eow_alm_response(tvb, offset, eow_tree); break;\r\ncase S5066_EOW_HDR_DRC_REQUEST:\r\ndissect_s5066dts_eow_hdr_drc_request(tvb, pinfo, offset, eow_tree, pdu_type); break;\r\ncase S5066_EOW_HFTRP_TOKEN:\r\ndissect_s5066dts_eow_hftrp(tvb, pinfo, offset, eow_tree, pdu_type); break;\r\n}\r\nreturn ++offset;\r\n}\r\nstatic void\r\ns5066dts_address_format( gchar *result, guint32 address_value )\r\n{\r\ng_snprintf( result, ITEM_LABEL_LENGTH, "%d.%d.%d.%d",\r\naddress_value >> 24,\r\n(address_value >> 16) & 0xFF,\r\n(address_value >> 8) & 0xFF,\r\naddress_value & 0xFF);\r\n}\r\nstatic guint dissect_s5066dts_address(tvbuff_t *tvb, guint offset, proto_tree *tree, packet_info *pinfo,\r\nguint addr_size)\r\n{\r\nguint32 source_address = 0, destination_address = 0;\r\nproto_tree *address_tree;\r\nunsigned int i;\r\nfor ( i = 0; i < addr_size; i++)\r\n{\r\ndestination_address = (destination_address << 4) | ((!(i % 2)\r\n? (tvb_get_guint8(tvb, offset + i / 2) >> 4)\r\n: (tvb_get_guint8(tvb, offset + i / 2))) & 0x0F);\r\nsource_address = (source_address << 4) | ((!((i + addr_size) % 2)\r\n? (tvb_get_guint8(tvb, offset + (i + addr_size) / 2) >> 4)\r\n: (tvb_get_guint8(tvb, offset + (i + addr_size) / 2))) & 0x0F);\r\n}\r\naddress_tree = proto_tree_add_subtree(tree, tvb, offset, addr_size, ett_s5066dts_address, NULL, "Destination & Source Addresses");\r\nproto_tree_add_uint(address_tree, hf_s5066dts_dest_addr, tvb, offset, addr_size - addr_size / 2, destination_address);\r\nproto_tree_add_uint(address_tree, hf_s5066dts_src_addr, tvb, offset + addr_size / 2, addr_size - addr_size / 2, source_address);\r\ncol_add_fstr(pinfo->cinfo, COL_DEF_SRC, "%d.%d.%d.%d",\r\nsource_address >> 24,\r\n(source_address >> 16) & 0xFF,\r\n(source_address >> 8) & 0xFF,\r\nsource_address & 0xFF);\r\ncol_add_fstr(pinfo->cinfo, COL_DEF_DST, "%d.%d.%d.%d",\r\ndestination_address >> 24,\r\n(destination_address >> 16) & 0xFF,\r\n(destination_address >> 8) & 0xFF,\r\ndestination_address & 0xFF);\r\noffset += addr_size;\r\nreturn offset;\r\n}\r\nstatic guint dissect_s5066dts_header_crc(tvbuff_t *tvb, guint offset, proto_tree *tree,\r\nguint address_size, guint header_size)\r\n{\r\nguint16 header_crc;\r\nproto_item *ti;\r\nheader_crc = crc16_0x9949_tvb_offset_seed(tvb, S5066_DPDU_SYNC_SEQUENCE_SIZE,\r\nheader_size + address_size - S5066_DPDU_SYNC_SEQUENCE_SIZE, 0);\r\nti = proto_tree_add_item(tree, hf_s5066dts_header_crc, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nif (header_crc == tvb_get_letohs(tvb, offset))\r\nproto_item_append_text(ti, " (Correct)");\r\nelse\r\nproto_item_append_text(ti, " (Incorrect, should be %x)", header_crc);\r\noffset += 2;\r\nreturn offset;\r\n}\r\nstatic guint dissect_s5066dts_cpdu_crc(tvbuff_t *tvb, guint offset, proto_tree *tree,\r\nguint address_size, guint header_size, guint segmented_cpdu_size)\r\n{\r\nguint32 cpdu_crc;\r\nproto_item *ti;\r\ncpdu_crc = crc32_0x0AA725CF_tvb_offset_seed(tvb, header_size + address_size + S5066_DPDU_SYNC_SEQUENCE_SIZE,\r\nsegmented_cpdu_size, 0);\r\nti = proto_tree_add_item(tree, hf_s5066dts_cpdu_crc, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nif (cpdu_crc == tvb_get_letohl(tvb, offset))\r\nproto_item_append_text(ti, " (Correct)");\r\nelse\r\nproto_item_append_text(ti, " (Incorrect, should be %x)", cpdu_crc);\r\noffset +=4;\r\nreturn offset;\r\n}\r\nstatic guint dissect_s5066dts_data_only(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_s5066dts_data_only_cpdu_start, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_data_only_cpdu_end, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_data_only_deliver_in_order, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_data_only_drop_cpdu, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_data_only_tx_win_uwe, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_data_only_tx_win_lwe, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_data_only_segmented_cpdu_size, tvb, offset, 2, ENC_BIG_ENDIAN); offset +=2;\r\nproto_tree_add_item(tree, hf_s5066dts_data_only_transmit_sequence_number, tvb, offset, 1, ENC_BIG_ENDIAN); offset++;\r\nreturn offset;\r\n}\r\nstatic guint dissect_s5066dts_ack_only(tvbuff_t *tvb, guint offset, proto_tree *tree,\r\nguint header_size)\r\n{\r\nguint ack_size;\r\nack_size = header_size - 7;\r\nproto_tree_add_item(tree, hf_s5066dts_ack_only_rx_lwe, tvb, offset, 1, ENC_BIG_ENDIAN); offset++;\r\nif (ack_size > 0){\r\nproto_tree_add_item(tree, hf_s5066dts_ack_only_acks, tvb, offset, ack_size, ENC_NA); offset += ack_size;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint dissect_s5066dts_data_ack(tvbuff_t *tvb, guint offset, proto_tree *tree,\r\nguint header_size)\r\n{\r\nguint ack_size;\r\nack_size = header_size - 10;\r\nproto_tree_add_item(tree, hf_s5066dts_data_ack_cpdu_start, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_data_ack_cpdu_end, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_data_ack_deliver_in_order, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_data_ack_drop_cpdu, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_data_ack_tx_win_uwe, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_data_ack_tx_win_lwe, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_data_ack_segmented_cpdu_size, tvb, offset, 2, ENC_BIG_ENDIAN); offset +=2;\r\nproto_tree_add_item(tree, hf_s5066dts_data_ack_transmit_sequence_number, tvb, offset, 1, ENC_BIG_ENDIAN); offset++;\r\nproto_tree_add_item(tree, hf_s5066dts_data_ack_rx_lwe, tvb, offset, 1, ENC_BIG_ENDIAN); offset++;\r\nif (ack_size > 0){\r\nproto_tree_add_item(tree, hf_s5066dts_data_ack_acks, tvb, offset, ack_size, ENC_NA); offset += ack_size;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint dissect_s5066dts_reset_win_resync(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_s5066dts_reset_win_resync_unused, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_reset_win_resync_full_reset_command, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_reset_win_resync_reset_tx_win_rqst, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_reset_win_resync_reset_rx_win_cmnd, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_reset_win_resync_reset_ack, tvb, offset, 1, ENC_BIG_ENDIAN); offset++;\r\nproto_tree_add_item(tree, hf_s5066dts_reset_win_resync_new_rx_lwe, tvb, offset, 1, ENC_BIG_ENDIAN); offset++;\r\nproto_tree_add_item(tree, hf_s5066dts_reset_win_resync_reset_frame_id_number, tvb, offset, 1, ENC_BIG_ENDIAN); offset++;\r\nreturn offset;\r\n}\r\nstatic guint dissect_s5066dts_exp_data_only(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_s5066dts_exp_data_only_cpdu_start, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_exp_data_only_cpdu_end, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_exp_data_only_cpdu_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_exp_data_only_segmented_cpdu_size, tvb, offset, 2, ENC_BIG_ENDIAN); offset +=2;\r\nproto_tree_add_item(tree, hf_s5066dts_exp_data_only_transmit_sequence_number, tvb, offset, 1, ENC_BIG_ENDIAN); offset++;\r\nreturn offset;\r\n}\r\nstatic guint dissect_s5066dts_exp_ack_only(tvbuff_t *tvb, guint offset, proto_tree *tree,\r\nguint header_size)\r\n{\r\nguint ack_size;\r\nack_size = header_size - 7;\r\nproto_tree_add_item(tree, hf_s5066dts_exp_ack_only_rx_lwe, tvb, offset, 1, ENC_BIG_ENDIAN); offset++;\r\nif (ack_size > 0)\r\nproto_tree_add_item(tree, hf_s5066dts_exp_ack_only_acks, tvb, offset, ack_size, ENC_NA);\r\noffset += ack_size;\r\nreturn offset;\r\n}\r\nstatic guint dissect_s5066dts_management(tvbuff_t *tvb, guint offset, proto_tree *tree, guint header_size)\r\n{\r\nguint8 eow_content;\r\nproto_tree *hftrp_token_tree = NULL;\r\nguint eow_type;\r\nguint extended_message_size;\r\neow_type = tvb_get_guint8(tvb, offset) & 0x0F;\r\neow_content = tvb_get_guint8(tvb, S5066_DPDU_EOW_CONTENT_INDEX);\r\nextended_message_size = header_size - 8;\r\nproto_tree_add_item(tree, hf_s5066dts_management_unused, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_management_extended_message_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_management_message, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_management_ack, tvb, offset, 1, ENC_BIG_ENDIAN); offset++;\r\nproto_tree_add_item(tree, hf_s5066dts_management_management_frame_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nif (eow_type == S5066_EOW_HDR_DRC_REQUEST)\r\n{\r\nproto_tree_add_item(tree, hf_s5066dts_eow_hdr_drc_request_data_rate, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_s5066dts_eow_hdr_drc_request_interleaver_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n}\r\nelse if (extended_message_size > 0)\r\n{\r\nif (eow_type == S5066_EOW_HFTRP_TOKEN)\r\n{\r\nhftrp_token_tree = proto_tree_add_subtree_format(tree, tvb, offset, extended_message_size,\r\nett_s5066dts_hftrp_token, NULL, "HFTRP Token (%s)",\r\nval_to_str_const(eow_content, s5066dts_eow_hftrp_frame_control, "UNKNOWN_HFTRP_TOKEN"));\r\nproto_tree_add_item(hftrp_token_tree,\r\nhf_s5066dts_management_extended_message_hftrp_payload_size, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2;\r\nproto_tree_add_item(hftrp_token_tree,\r\nhf_s5066dts_management_extended_message_hftrp_ra, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4;\r\nproto_tree_add_item(hftrp_token_tree,\r\nhf_s5066dts_management_extended_message_hftrp_seq_id, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4;\r\nproto_tree_add_item(hftrp_token_tree,\r\nhf_s5066dts_management_extended_message_hftrp_gen_seq_id, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4;\r\nproto_tree_add_item(hftrp_token_tree,\r\nhf_s5066dts_management_extended_message_hftrp_new_successor_id, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4;\r\nproto_tree_add_item(hftrp_token_tree,\r\nhf_s5066dts_management_extended_message_hftrp_number_of_nodes, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2;\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(tree, hf_s5066dts_management_extended_message, tvb, offset, extended_message_size, ENC_NA);\r\noffset += extended_message_size;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic guint dissect_s5066dts_non_arq_data(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_s5066dts_non_arq_data_cpdu_id_1, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_non_arq_data_deliver_in_order, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_non_arq_data_group_address, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_non_arq_data_segmented_cpdu_size, tvb, offset, 2, ENC_BIG_ENDIAN); offset +=2;\r\nproto_tree_add_item(tree, hf_s5066dts_non_arq_data_cpdu_id_2, tvb, offset, 1, ENC_BIG_ENDIAN); offset++;\r\nproto_tree_add_item(tree, hf_s5066dts_non_arq_data_cpdu_size, tvb, offset, 2, ENC_BIG_ENDIAN); offset +=2;\r\nproto_tree_add_item(tree, hf_s5066dts_non_arq_data_cpdu_segment_offset, tvb, offset, 2, ENC_BIG_ENDIAN); offset +=2;\r\nproto_tree_add_item(tree, hf_s5066dts_non_arq_data_cpdu_reception_window, tvb, offset, 2, ENC_BIG_ENDIAN); offset +=2;\r\nreturn offset;\r\n}\r\nstatic guint dissect_s5066dts_exp_non_arq_data(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_s5066dts_exp_non_arq_data_cpdu_id_1, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_exp_non_arq_data_deliver_in_order, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_exp_non_arq_data_group_address, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_exp_non_arq_data_segmented_cpdu_size, tvb, offset, 2, ENC_BIG_ENDIAN); offset +=2;\r\nproto_tree_add_item(tree, hf_s5066dts_exp_non_arq_data_cpdu_id_2, tvb, offset, 1, ENC_BIG_ENDIAN); offset++;\r\nproto_tree_add_item(tree, hf_s5066dts_exp_non_arq_data_cpdu_size, tvb, offset, 2, ENC_BIG_ENDIAN); offset +=2;\r\nproto_tree_add_item(tree, hf_s5066dts_exp_non_arq_data_cpdu_segment_offset, tvb, offset, 2, ENC_BIG_ENDIAN); offset +=2;\r\nproto_tree_add_item(tree, hf_s5066dts_exp_non_arq_data_cpdu_reception_window, tvb, offset, 2, ENC_BIG_ENDIAN); offset +=2;\r\nreturn offset;\r\n}\r\nstatic guint dissect_s5066dts_warning(tvbuff_t *tvb, guint offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_s5066dts_warning_frame_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_s5066dts_warning_reason, tvb, offset, 1, ENC_BIG_ENDIAN); offset++;\r\nreturn offset;\r\n}\r\nstatic guint calculate_s5066dts_dpdu_len(packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset _U_, void *data _U_)\r\n{\r\nguint pdu_type;\r\nguint address_size;\r\nguint header_size;\r\nguint pdu_size;\r\nguint segmented_cpdu_size;\r\nif (tvb_get_guint8(tvb, 0) != 0x90)\r\nreturn 1;\r\nelse if (tvb_get_guint8(tvb, 1) != 0xEB)\r\nreturn 2;\r\npdu_type = (tvb_get_guint8(tvb, 2) & 0xF0) >> 4;\r\naddress_size = (tvb_get_guint8(tvb, S5066_DPDU_SIZE_OF_ADDRESS_INDEX) & 0xE0) >> 5;\r\nheader_size = tvb_get_guint8(tvb, S5066_DPDU_SIZE_OF_HEADER_INDEX) & 0x1F;\r\npdu_size = header_size + address_size + S5066_DPDU_SYNC_SEQUENCE_SIZE;\r\nif (pdu_type == S5066_DPDU_DATA_ONLY || pdu_type == S5066_DPDU_DATA_ACK ||\r\npdu_type == S5066_DPDU_EXP_DATA_ONLY || pdu_type == S5066_DPDU_NON_ARQ_DATA ||\r\npdu_type == S5066_DPDU_EXP_NON_ARQ_DATA)\r\n{\r\nsegmented_cpdu_size = tvb_get_ntohs(tvb, 6 + address_size) & 0x03FF;\r\npdu_size += segmented_cpdu_size + 4;\r\n}\r\nreturn pdu_size;\r\n}\r\nstatic int dissect_s5066dts(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *s5066dts_tree = NULL, *pdu_tree = NULL;\r\nproto_item *ti = NULL;\r\nguint offset = 0;\r\nguint pdu_type;\r\nguint address_size;\r\nguint header_size;\r\nguint segmented_cpdu_size;\r\nguint8 eow_type;\r\nguint8 eow_content;\r\nif (tvb_get_guint8(tvb, 0) != 0x90 || tvb_get_guint8(tvb, 1) != 0xEB) {\r\nreturn 0;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, DISSECTOR_NAME);\r\npdu_type = (tvb_get_guint8(tvb, 2) & 0xF0) >> 4;\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "DpduType=%d (%s)", pdu_type, val_to_str(pdu_type, s5066dts_dpdu_type,\r\n"Unknown (0x%02x)"));\r\naddress_size = (tvb_get_guint8(tvb, S5066_DPDU_SIZE_OF_ADDRESS_INDEX) & 0xE0) >> 5;\r\neow_type = tvb_get_guint8(tvb, S5066_DPDU_EOW_TYPE_INDEX) & 0x0F;\r\neow_content = tvb_get_guint8(tvb, S5066_DPDU_EOW_CONTENT_INDEX);\r\nswitch (eow_type)\r\n{\r\ncase S5066_EOW_RESERVED:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " EowType=RESERVED");\r\nbreak;\r\ncase S5066_EOW_DRC_REQUEST:\r\ncase S5066_EOW_DRC_RESPONSE:\r\ncase S5066_EOW_UNRECOGNIZED_TYPE:\r\ncase S5066_EOW_CAPABILITY:\r\ncase S5066_EOW_ALM_REQUEST:\r\ncase S5066_EOW_ALM_RESPONSE:\r\ncase S5066_EOW_HDR_DRC_REQUEST:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " EowType=%d (%s)", eow_type,\r\nval_to_str_const(eow_type, s5066dts_eow_type, "UNKNOWN_EOW_TYPE"));\r\nbreak;\r\ncase 8:\r\ncase 9:\r\ncase 10:\r\ncase 11:\r\ncase 12:\r\ncase 13:\r\ncase 14:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " EowType=UNSPECIFIED");\r\nbreak;\r\ncase S5066_EOW_HFTRP_TOKEN:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " EowType=%d (%s:%s)", eow_type,\r\nval_to_str_const(eow_type, s5066dts_eow_type, "UNKNOWN_EOW_TYPE"),\r\nval_to_str_const(eow_content, s5066dts_eow_hftrp_frame_control_abbr, "UNKNOWN_HFTRP_TOKEN"));\r\nbreak;\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " EOT=%d", tvb_get_guint8(tvb, S5066_DPDU_EOT_INDEX));\r\nswitch (pdu_type)\r\n{\r\ncase S5066_DPDU_DATA_ONLY:\r\ncase S5066_DPDU_EXP_DATA_ONLY:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " Seq=%d", tvb_get_guint8(tvb, 8 + address_size));\r\nbreak;\r\ncase S5066_DPDU_ACK_ONLY:\r\ncase S5066_DPDU_EXP_ACK_ONLY:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " RxLWE=%d", tvb_get_guint8(tvb, 6 + address_size));\r\nbreak;\r\ncase S5066_DPDU_DATA_ACK:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " Seq=%d RxLWE=%d",\r\ntvb_get_guint8(tvb, 8 + address_size),\r\ntvb_get_guint8(tvb, 9 + address_size));\r\nbreak;\r\ncase S5066_DPDU_MANAGEMENT:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " FrameID=%d", tvb_get_guint8(tvb, 7 + address_size));\r\nbreak;\r\n}\r\nif (tree)\r\n{\r\nti = proto_tree_add_protocol_format(tree, proto_s5066dts, tvb, 0, -1, "STANAG 5066 (DTS Layer)");\r\ns5066dts_tree = proto_item_add_subtree(ti, ett_s5066dts);\r\nproto_tree_add_item(s5066dts_tree, hf_s5066dts_sync_word, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2;\r\nproto_tree_add_item(s5066dts_tree, hf_s5066dts_dpdu_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset = dissect_s5066dts_eow(tvb, pinfo, offset, s5066dts_tree, pdu_type);\r\nproto_item_append_text(ti, ", DPDU Type %s ", val_to_str_const(pdu_type, s5066dts_dpdu_type, "UNKNOWN_DPDU_TYPE"));\r\nproto_tree_add_item(s5066dts_tree, hf_s5066dts_eot, tvb, offset, 1, ENC_BIG_ENDIAN); offset++;\r\nproto_tree_add_item(s5066dts_tree, hf_s5066dts_address_size, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(s5066dts_tree, hf_s5066dts_header_size, tvb, offset, 1, ENC_BIG_ENDIAN); offset++;\r\noffset = dissect_s5066dts_address(tvb, offset, s5066dts_tree, pinfo, address_size);\r\nheader_size = tvb_get_guint8(tvb, S5066_DPDU_SIZE_OF_HEADER_INDEX) & 0x1F;\r\npdu_tree = proto_tree_add_subtree(s5066dts_tree, tvb, offset, header_size - 6, ett_s5066dts_pdu, NULL, "D_PDU Type Specific Header");\r\nswitch (pdu_type)\r\n{\r\ncase S5066_DPDU_DATA_ONLY: offset = dissect_s5066dts_data_only(tvb, offset, pdu_tree); break;\r\ncase S5066_DPDU_ACK_ONLY: offset = dissect_s5066dts_ack_only(tvb, offset, pdu_tree, header_size); break;\r\ncase S5066_DPDU_DATA_ACK: offset = dissect_s5066dts_data_ack(tvb, offset, pdu_tree, header_size); break;\r\ncase S5066_DPDU_RESET_WIN_RESYNC: offset = dissect_s5066dts_reset_win_resync(tvb, offset, pdu_tree); break;\r\ncase S5066_DPDU_EXP_DATA_ONLY: offset = dissect_s5066dts_exp_data_only(tvb, offset, pdu_tree); break;\r\ncase S5066_DPDU_EXP_ACK_ONLY: offset = dissect_s5066dts_exp_ack_only(tvb, offset, pdu_tree, header_size); break;\r\ncase S5066_DPDU_MANAGEMENT: offset = dissect_s5066dts_management(tvb, offset, pdu_tree, header_size); break;\r\ncase S5066_DPDU_NON_ARQ_DATA: offset = dissect_s5066dts_non_arq_data(tvb, offset, pdu_tree); break;\r\ncase S5066_DPDU_EXP_NON_ARQ_DATA: offset = dissect_s5066dts_exp_non_arq_data(tvb, offset, pdu_tree); break;\r\ncase S5066_DPDU_WARNING: offset = dissect_s5066dts_warning(tvb, offset, pdu_tree); break;\r\n}\r\noffset = dissect_s5066dts_header_crc(tvb, offset, s5066dts_tree, address_size, header_size);\r\nif (pdu_type == S5066_DPDU_DATA_ONLY || pdu_type == S5066_DPDU_DATA_ACK\r\n|| pdu_type == S5066_DPDU_EXP_DATA_ONLY || pdu_type == S5066_DPDU_NON_ARQ_DATA\r\n|| pdu_type == S5066_DPDU_EXP_NON_ARQ_DATA)\r\n{\r\nsegmented_cpdu_size = tvb_get_ntohs(tvb, 6 + address_size) & 0x03FF;\r\nproto_tree_add_item(s5066dts_tree, hf_s5066dts_segmented_cpdu, tvb, offset, segmented_cpdu_size, ENC_NA);\r\noffset += segmented_cpdu_size;\r\ndissect_s5066dts_cpdu_crc(tvb, offset, s5066dts_tree, address_size, header_size, segmented_cpdu_size);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int dissect_s5066dts_raw(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nguint b_length = tvb_captured_length(tvb);\r\nif ( b_length < S5066_DPDU_FRAME_HEADER_LEN){\r\nreturn 0;\r\n}\r\nif ((tvb_get_guint8(tvb, 0) != 0x90) || (tvb_get_guint8(tvb, 1) != 0xEB)) {\r\nreturn 0;\r\n}\r\ncalculate_s5066dts_dpdu_len(pinfo, tvb, 0, NULL);\r\ndissect_s5066dts(tvb, pinfo, tree, NULL);\r\nreturn b_length;\r\n}\r\nstatic int dissect_s5066dts_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nguint b_length = tvb_captured_length(tvb);\r\nif ( b_length < S5066_DPDU_FRAME_HEADER_LEN){\r\nreturn 0;\r\n}\r\nif ((tvb_get_guint8(tvb, 0) != 0x90) || (tvb_get_guint8(tvb, 1) != 0xEB)) {\r\nreturn 0;\r\n}\r\nif ( pinfo->destport != config_s5066dts_port) {\r\nreturn 0;\r\n}\r\ntcp_dissect_pdus(tvb, pinfo, tree, config_proto_desegment, S5066_DPDU_FRAME_HEADER_LEN, calculate_s5066dts_dpdu_len,\r\ndissect_s5066dts, data);\r\nreturn b_length;\r\n}\r\nvoid proto_register_s5066dts (void)\r\n{\r\nmodule_t *s5066dts_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_s5066dts_sync_word,\r\n{ "Sync preamble", "s5066dts.sync", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_dpdu_type,\r\n{ "D_PDU type", "s5066dts.type", FT_UINT8, BASE_DEC, VALS(s5066dts_dpdu_type), 0xF0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_type,\r\n{ "EOW type", "s5066dts.eow.type", FT_UINT8, BASE_DEC, VALS(s5066dts_eow_type), 0x0F, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_data,\r\n{ "EOW data", "s5066dts.eow.data", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eot,\r\n{ "EOT", "s5066dts.eot", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_address_size,\r\n{ "Address size (1/2 bytes)", "s5066dts.address.size", FT_UINT8, BASE_DEC, NULL, 0xE0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_header_size,\r\n{ "Header size", "s5066dts.header_size", FT_UINT8, BASE_DEC, NULL, 0x1F, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_segmented_cpdu,\r\n{ "C_PDU Segment", "s5066dts.segmented_cpdu", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_dest_addr,\r\n{ "Destination Address", "s5066dts.dest_addr", FT_UINT32, BASE_CUSTOM, CF_FUNC(s5066dts_address_format), 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_src_addr,\r\n{ "Source Address", "s5066dts.src_addr", FT_UINT32, BASE_CUSTOM, CF_FUNC(s5066dts_address_format), 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_header_crc,\r\n{ "CRC on header", "s5066dts.header_crc", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_cpdu_crc,\r\n{ "CRC on C_PDU segment", "s5066dts.cpdu_crc", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_drc_request_data_rate,\r\n{ "Data Rate", "s5066dts.eow.drc_request.data_rate", FT_UINT8, BASE_DEC, VALS(s5066dts_eow_data_rate),\r\n0xF0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_drc_request_interleaving,\r\n{ "Interleaver parameter", "s5066dts.eow.drc_request.interleaving", FT_UINT8, BASE_DEC,\r\nVALS(s5066dts_eow_interleaving), 0x0C, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_drc_request_others,\r\n{ "Other parameters", "s5066dts.eow.drc_request.others", FT_UINT8, BASE_DEC,\r\nVALS(s5066dts_eow_others), 0x03, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_drc_response_response,\r\n{ "Response for DRC", "s5066dts.eow.drc_response.response", FT_UINT8, BASE_DEC,\r\nVALS(s5066dts_eow_response), 0xE0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_drc_response_reason,\r\n{ "Reason", "s5066dts.eow.drc_response.reason", FT_UINT8, BASE_DEC,\r\nVALS(s5066dts_eow_reason), 0x1F, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_unrec_type_response,\r\n{ "This value should be set to 0", "s5066dts.eow.unrec_type.response", FT_UINT8, BASE_DEC,\r\nNULL, 0xE0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_unrec_type_reason,\r\n{ "Reason", "s5066dts.eow.unrec_type.reason", FT_UINT8, BASE_DEC, NULL, 0x1F, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_capability_adaptive,\r\n{ "Adaptive modem parameters capable", "s5066dts.eow.capability.adaptive", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_capability_stanag_4529,\r\n{ "STANAG 4529 available", "s5066dts.eow.capability.stanag_4529", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_capability_mil_std_188_110a,\r\n{ "MIL-STD-188-110A available", "s5066dts.eow.capability.mil_std_188_110a", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_capability_extended,\r\n{ "Extended data rate available", "s5066dts.eow.capability.extended", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_capability_full_duplex,\r\n{ "Full duplex supported", "s5066dts.eow.capability.full_duplex", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_capability_split_frequency,\r\n{ "Split frequency supported", "s5066dts.eow.capability.split_frequency", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_capability_non_arcs_ale,\r\n{ "Non-ARCS ALE capable", "s5066dts.eow.capability.non_arcs_ale", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_capability_arcs,\r\n{ "ARCS capable", "s5066dts.eow.capability.arcs", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_alm_request_data_rate,\r\n{ "Data Rate", "s5066dts.eow.alm_request.data_rate", FT_UINT8, BASE_DEC,\r\nVALS(s5066dts_eow_data_rate), 0xF0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_alm_request_interleaving,\r\n{ "Interleaver parameter", "s5066dts.eow.alm_request.interleaving", FT_UINT8, BASE_DEC,\r\nVALS(s5066dts_eow_interleaving), 0x0C, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_alm_request_others,\r\n{ "Other parameters", "s5066dts.eow.alm_request.others", FT_UINT8, BASE_DEC,\r\nVALS(s5066dts_eow_others), 0x03, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_alm_response_response,\r\n{ "Response for DRC", "s5066dts.eow.alm_response.response", FT_UINT8, BASE_DEC,\r\nVALS(s5066dts_eow_response), 0xE0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_alm_response_reason,\r\n{ "Reason", "s5066dts.eow.alm_response.reason", FT_UINT8, BASE_DEC, VALS(s5066dts_alm_reason), 0x1F, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_hdr_drc_request_waveform,\r\n{ "Modem waveform", "s5066dts.eow.hdr_drc_request.waveform", FT_UINT8, BASE_DEC,\r\nVALS(s5066dts_eow_waveform), 0xF8, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_hdr_drc_request_num_channels,\r\n{ "Number of channels", "s5066dts.eow.hdr_drc_request.num_channels", FT_UINT8, BASE_DEC, NULL, 0x07, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_hdr_drc_request_data_rate,\r\n{ "Requested data rate for each channel", "s5066dts.eow.hdr_drc_request.data_rate",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_hdr_drc_request_interleaver_length,\r\n{ "Interleaver length for each channel", "s5066dts.eow.hdr_drc_request.interleaver_length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_eow_hftrp_hftrp_token,\r\n{ "HFTRP Token Type", "s5066dts.eow.hftrp.token_type", FT_UINT8, BASE_DEC, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_only_cpdu_start,\r\n{ "C_PDU Start", "s5066dts.data_only.cpdu_start", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_only_cpdu_end,\r\n{ "C_PDU End", "s5066dts.data_only.cpdu_end", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_only_deliver_in_order,\r\n{ "C_PDU Deliver-in-Order", "s5066dts.data_only.deliver_in_order", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_only_drop_cpdu,\r\n{ "Drop C_PDU", "s5066dts.data_only.drop_cpdu", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_only_tx_win_uwe,\r\n{ "TX WIN UWE", "s5066dts.data_only.tx_win_uwe", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_only_tx_win_lwe,\r\n{ "TX WIN LWE", "s5066dts.data_only.tx_win_lwe", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_only_segmented_cpdu_size,\r\n{ "Size of segmented C_PDU", "s5066dts.data_only.segmented_cpdu_size", FT_UINT16, BASE_DEC,\r\nNULL, 0x03FF, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_only_transmit_sequence_number,\r\n{ "TX Frame Sequence Number", "s5066dts.data_only.transmit_sequence_number", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_ack_only_rx_lwe,\r\n{ "RX LWE", "s5066dts.ack_only.rx_lwe", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_ack_only_acks,\r\n{ "Selective ACK", "s5066dts.ack_only.acks", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_ack_cpdu_start,\r\n{ "C_PDU Start", "s5066dts.data_ack.cpdu_start", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_ack_cpdu_end,\r\n{ "C_PDU End", "s5066dts.data_ack.cpdu_end", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_ack_deliver_in_order,\r\n{ "C_PDU Deliver-in-Order", "s5066dts.data_ack.deliver_in_order", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_ack_drop_cpdu,\r\n{ "Drop C_PDU", "s5066dts.data_ack.drop_cpdu", FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_ack_tx_win_uwe,\r\n{ "TX WIN UWE", "s5066dts.data_ack.tx_win_uwe", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_ack_tx_win_lwe,\r\n{ "TX WIN LWE", "s5066dts.data_ack.tx_win_lwe", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_ack_segmented_cpdu_size,\r\n{ "Size of segmented C_PDU", "s5066dts.data_ack.segmented_cpdu_size", FT_UINT16, BASE_DEC,\r\nNULL, 0x03FF, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_ack_transmit_sequence_number,\r\n{ "TX frame sequence number", "s5066dts.data_ack.transmit_sequence_number", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_ack_rx_lwe,\r\n{ "RX LWE", "s5066dts.data_ack.rx_lwe", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_data_ack_acks,\r\n{ "Selective ACK", "s5066dts.data_ack.acks", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_reset_win_resync_unused,\r\n{ "Unused", "s5066dts.reset_win_resync.unused", FT_UINT8, BASE_HEX, NULL, 0xF0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_reset_win_resync_full_reset_command,\r\n{ "Full reset command", "s5066dts.reset_win_resync.full_reset", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_reset_win_resync_reset_tx_win_rqst,\r\n{ "Reset TX-WIN request", "s5066dts.reset_win_resync.reset_tx_win", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_reset_win_resync_reset_rx_win_cmnd,\r\n{ "Reset RX-WIN command", "s5066dts.reset_win_resync.reset_rx_win", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_reset_win_resync_reset_ack,\r\n{ "Reset acknowledgment", "s5066dts.reset_win_resync.reset_ack", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_reset_win_resync_new_rx_lwe,\r\n{ "New receiver ARQ RX-LWE", "s5066dts.reset_win_resync.new_rx_lwe", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_reset_win_resync_reset_frame_id_number,\r\n{ "Reset frame ID number", "s5066dts.reset_win_resync.reset_frame_id", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_exp_data_only_cpdu_start,\r\n{ "C_PDU Start", "s5066dts.exp_data_only.cpdu_start", FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_exp_data_only_cpdu_end,\r\n{ "C_PDU End", "s5066dts.exp_data_only.cpdu_end", FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_exp_data_only_cpdu_id,\r\n{ "Segmented C_PDU ID", "s5066dts.exp_data_only.cpdu_id", FT_UINT8, BASE_DEC, NULL, 0x3C, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_exp_data_only_segmented_cpdu_size,\r\n{ "Size of segmented C_PDU", "s5066dts.exp_data_only.segmented_cpdu_size", FT_UINT16, BASE_DEC, NULL, 0x03FF, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_exp_data_only_transmit_sequence_number,\r\n{ "TX frame sequence number", "s5066dts.exp_data_only.transmit_sequence_number", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_exp_ack_only_rx_lwe,\r\n{ "RX LWE", "s5066dts.exp_ack_only.rx_lwe", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_exp_ack_only_acks,\r\n{ "Selective ACK", "s5066dts.exp_ack_only.acks", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_management_unused,\r\n{ "Unused", "s5066dts.management.unused", FT_UINT8, BASE_HEX, NULL, 0xF8, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_management_extended_message_flag,\r\n{ "Extended message flag", "s5066dts.management.extended_message_flag", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_management_message,\r\n{ "Valid message", "s5066dts.management.message", FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_management_ack,\r\n{ "Acknowledgment", "s5066dts.management.ack", FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_management_management_frame_id,\r\n{ "Management frame ID number", "s5066dts.management.manegement_frame_id", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_management_extended_message,\r\n{ "Extended management message", "s5066dts.management.extended_message", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_management_extended_message_hftrp_payload_size,\r\n{ "Payload Size", "s5066dts.management.extended_message.reserved", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_management_extended_message_hftrp_ra,\r\n{ "Ring Address", "s5066dts.management.extended_message.ring_address", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_management_extended_message_hftrp_seq_id,\r\n{ "Sequence ID", "s5066dts.management.extended_message.sequence_id", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_management_extended_message_hftrp_gen_seq_id,\r\n{ "Generation Sequence ID", "s5066dts.management.extended_message.generation_sequence_id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_management_extended_message_hftrp_new_successor_id,\r\n{ "New Successor ID", "s5066dts.management.extended_message.new_successor_id", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_management_extended_message_hftrp_number_of_nodes,\r\n{ "Number of Nodes", "s5066dts.management.extended_message.number_of_nodes", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_non_arq_data_cpdu_id_1,\r\n{ "C_PDU ID number (field 1)", "s5066dts.non_arq_data.cpdu_id_1", FT_UINT8, BASE_DEC, NULL, 0xF0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_non_arq_data_deliver_in_order,\r\n{ "C_PDU Deliver-in-Order", "s5066dts.non_arq_data.deliver_in_order", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_non_arq_data_group_address,\r\n{ "Group Address", "s5066dts.non_arq_data.group_address", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_non_arq_data_cpdu_id_2,\r\n{ "C_PDU ID number (field 2)", "s5066dts.non_arq_data.cpdu_id_2", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_non_arq_data_cpdu_size,\r\n{ "C_PDU size", "s5066dts.non_arq_data.cpdu_size", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_non_arq_data_cpdu_segment_offset,\r\n{ "Offset of segmented C_PDU", "s5066dts.non_arq_data.cpdu_segment_offset", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_non_arq_data_cpdu_reception_window,\r\n{ "C_PDU reception window", "s5066dts.non_arq_data.cpdu_reception_window", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_non_arq_data_segmented_cpdu_size,\r\n{ "Size of segmented C_PDU", "s5066dts.non_arq_data.segmented_cpdu_size", FT_UINT16, BASE_DEC,\r\nNULL, 0x03FF, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_exp_non_arq_data_cpdu_id_1,\r\n{ "C_PDU ID number (field 1)", "s5066dts.exp_non_arq_data.cpdu_id_1", FT_UINT8, BASE_DEC, NULL, 0xF0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_exp_non_arq_data_deliver_in_order,\r\n{ "C_PDU Deliver-in-Order", "s5066dts.exp_non_arq_data.deliver_in_order", FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_exp_non_arq_data_group_address,\r\n{ "Group Address", "s5066dts.exp_non_arq_data.group_address", FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_exp_non_arq_data_cpdu_id_2,\r\n{ "C_PDU ID number (field 2)", "s5066dts.exp_non_arq_data.cpdu_id_2", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_exp_non_arq_data_cpdu_size,\r\n{ "C_PDU size", "s5066dts.exp_non_arq_data.cpdu_size", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_exp_non_arq_data_cpdu_segment_offset,\r\n{ "Offset of segmented C_PDU", "s5066dts.exp_non_arq_data.cpdu_segment_offset", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_exp_non_arq_data_cpdu_reception_window,\r\n{ "C_PDU reception window", "s5066dts.exp_non_arq_data.cpdu_reception_window", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_exp_non_arq_data_segmented_cpdu_size,\r\n{ "Size of segmented C_PDU", "s5066dts.exp_non_arq_data.segmented_cpdu_size", FT_UINT16, BASE_DEC,\r\nNULL, 0x03FF, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_warning_frame_type,\r\n{ "Received frame type", "s5066dts.warning.frame_type", FT_UINT8, BASE_DEC, NULL, 0xF0, NULL, HFILL }\r\n},\r\n{ &hf_s5066dts_warning_reason,\r\n{ "Reason warning sent", "s5066dts.warning.reason", FT_UINT8, BASE_DEC, NULL, 0x0F, NULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_s5066dts,\r\n&ett_s5066dts_eow,\r\n&ett_s5066dts_address,\r\n&ett_s5066dts_pdu,\r\n&ett_s5066dts_hftrp_token,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_s5066dts_eow_hdr_drc_request_invalid, { "s5066dts.eow_hdr_drc_request.invalid", PI_MALFORMED, PI_ERROR,\r\n"High data rate change request can only be made in Management D_PDU", EXPFILL }},\r\n{ &ei_s5066dts_eow_hftrp_invalid, { "s5066dts.eow_hftrp.invalid", PI_MALFORMED, PI_ERROR,\r\n"HFTRP tokens can only be carried with Management D_PDU", EXPFILL }},\r\n};\r\nexpert_module_t* expert_s5066dts;\r\nif (proto_s5066dts == -1)\r\n{\r\nproto_s5066dts = proto_register_protocol ("STANAG 5066(DTS layer)", "STANAG 5066 DTS", "s5066dts");\r\nproto_register_field_array(proto_s5066dts, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_s5066dts = expert_register_protocol(proto_s5066dts);\r\nexpert_register_field_array(expert_s5066dts, ei, array_length(ei));\r\nregister_dissector(DISSECTOR_NAME, dissect_s5066dts_tcp, proto_s5066dts);\r\n}\r\ns5066dts_module = prefs_register_protocol(proto_s5066dts, proto_reg_handoff_s5066dts);\r\nprefs_register_bool_preference(s5066dts_module, "proto_desegment",\r\n"Reassemble STANAG 5066 DPDUs spanning multiple TCP segments",\r\n"Whether the STANAG 5066 DTS Layer dissector should reassemble DPDUs spanning multiple TCP segments",\r\n&config_proto_desegment);\r\nprefs_register_uint_preference(s5066dts_module, "tcp.port",\r\n"STANAG 5066 DTS Layer TCP Port",\r\n"Set the port for STANAG 5066 DTS Layer. (If other than the default 5067.)",\r\n10, &config_s5066dts_port);\r\n}\r\nvoid proto_reg_handoff_s5066dts(void)\r\n{\r\nstatic gint initialized = FALSE;\r\nstatic dissector_handle_t s5066dts_handle;\r\nstatic dissector_handle_t s5066dts_over_tcp_handle;\r\nstatic int currentPort;\r\nif (!initialized) {\r\ns5066dts_handle = create_dissector_handle(dissect_s5066dts_raw, proto_s5066dts);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_STANAG_5066_D_PDU, s5066dts_handle);\r\ns5066dts_over_tcp_handle = create_dissector_handle(dissect_s5066dts_tcp, proto_s5066dts);\r\ninitialized = TRUE;\r\n}\r\nelse {\r\ndissector_delete_uint("tcp.port", currentPort, s5066dts_over_tcp_handle);\r\n}\r\ncurrentPort = config_s5066dts_port;\r\ndissector_add_uint("tcp.port", currentPort, s5066dts_over_tcp_handle);\r\n}
